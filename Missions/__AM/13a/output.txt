// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 600 0 0
// InitMacro ;
  19: CALL 56494 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 48346 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 48346 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 48346 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 48346 0 9
// PrepareArabian ;
 147: CALL 3510 0 0
// PrepareRussian ;
 151: CALL 2645 0 0
// PrepareAlliance ;
 155: CALL 710 0 0
// MC_Start ( ) ;
 159: CALL 58606 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6673 0 0
// end ;
 180: END
// export function CustomInitMacro ; var i ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 185: LD_ADDR_EXP 82
 189: PUSH
 190: LD_INT 1
 192: PUSH
 193: LD_INT 2
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 200: LD_ADDR_EXP 83
 204: PUSH
 205: LD_INT 3
 207: PUSH
 208: LD_INT 4
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 215: LD_INT 1
 217: PPUSH
 218: LD_INT 12
 220: PUSH
 221: LD_INT 15
 223: PUSH
 224: LD_INT 18
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: PUSH
 232: LD_OWVAR 67
 236: ARRAY
 237: PPUSH
 238: LD_INT 7
 240: PPUSH
 241: CALL 79349 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 245: LD_INT 1
 247: PPUSH
 248: LD_EXP 53
 252: PPUSH
 253: CALL 79775 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 257: LD_INT 1
 259: PPUSH
 260: LD_INT 6
 262: PPUSH
 263: CALL 80170 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 267: LD_INT 1
 269: PPUSH
 270: LD_INT 9
 272: PUSH
 273: EMPTY
 274: LIST
 275: PPUSH
 276: CALL 80439 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 13
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 2
 291: PUSH
 292: LD_INT 32
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: PUSH
 301: EMPTY
 302: LIST
 303: PPUSH
 304: CALL 79715 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 308: LD_INT 2
 310: PPUSH
 311: LD_INT 12
 313: PUSH
 314: LD_INT 14
 316: PUSH
 317: LD_INT 10
 319: PUSH
 320: LD_INT 11
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 80346 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_EXP 50
 340: PPUSH
 341: CALL 79775 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 345: LD_INT 2
 347: PPUSH
 348: LD_INT 8
 350: PPUSH
 351: CALL 80170 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 355: LD_INT 2
 357: PPUSH
 358: LD_INT 10
 360: PUSH
 361: EMPTY
 362: LIST
 363: PPUSH
 364: CALL 80439 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 368: LD_INT 2
 370: PPUSH
 371: LD_INT 6
 373: PUSH
 374: LD_INT 71
 376: PUSH
 377: LD_INT 116
 379: PUSH
 380: LD_INT 4
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_INT 4
 391: PUSH
 392: LD_INT 85
 394: PUSH
 395: LD_INT 116
 397: PUSH
 398: LD_INT 4
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: LD_INT 32
 409: PUSH
 410: LD_INT 83
 412: PUSH
 413: LD_INT 111
 415: PUSH
 416: LD_INT 4
 418: PUSH
 419: EMPTY
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: PUSH
 425: LD_INT 32
 427: PUSH
 428: LD_INT 87
 430: PUSH
 431: LD_INT 121
 433: PUSH
 434: LD_INT 4
 436: PUSH
 437: EMPTY
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 88
 448: PUSH
 449: LD_INT 128
 451: PUSH
 452: LD_INT 4
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: PUSH
 461: LD_INT 32
 463: PUSH
 464: LD_INT 59
 466: PUSH
 467: LD_INT 89
 469: PUSH
 470: LD_INT 3
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_INT 33
 481: PUSH
 482: LD_INT 69
 484: PUSH
 485: LD_INT 98
 487: PUSH
 488: LD_INT 3
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: PUSH
 497: LD_INT 33
 499: PUSH
 500: LD_INT 77
 502: PUSH
 503: LD_INT 103
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 33
 517: PUSH
 518: LD_INT 83
 520: PUSH
 521: LD_INT 105
 523: PUSH
 524: LD_INT 3
 526: PUSH
 527: EMPTY
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 33
 535: PUSH
 536: LD_INT 71
 538: PUSH
 539: LD_INT 125
 541: PUSH
 542: LD_INT 5
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PPUSH
 563: CALL 79559 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
 567: LD_INT 2
 569: PPUSH
 570: LD_INT 21
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 3
 578: PUSH
 579: LD_INT 51
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PUSH
 588: EMPTY
 589: LIST
 590: PPUSH
 591: CALL 79715 0 2
// end ;
 595: LD_VAR 0 1
 599: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 600: LD_INT 0
 602: PPUSH
// debug := false ;
 603: LD_ADDR_EXP 1
 607: PUSH
 608: LD_INT 0
 610: ST_TO_ADDR
// game := true ;
 611: LD_ADDR_EXP 2
 615: PUSH
 616: LD_INT 1
 618: ST_TO_ADDR
// gossudarov_arrive := false ;
 619: LD_ADDR_EXP 4
 623: PUSH
 624: LD_INT 0
 626: ST_TO_ADDR
// ru_lab_builded := false ;
 627: LD_ADDR_EXP 5
 631: PUSH
 632: LD_INT 0
 634: ST_TO_ADDR
// player_spotted := false ;
 635: LD_ADDR_EXP 6
 639: PUSH
 640: LD_INT 0
 642: ST_TO_ADDR
// first_attack := false ;
 643: LD_ADDR_EXP 7
 647: PUSH
 648: LD_INT 0
 650: ST_TO_ADDR
// ru_attackers := [ ] ;
 651: LD_ADDR_EXP 51
 655: PUSH
 656: EMPTY
 657: ST_TO_ADDR
// ar_base_spotted := false ;
 658: LD_ADDR_EXP 8
 662: PUSH
 663: LD_INT 0
 665: ST_TO_ADDR
// ar_active_attack := false ;
 666: LD_ADDR_EXP 9
 670: PUSH
 671: LD_INT 0
 673: ST_TO_ADDR
// ar_attackers := [ ] ;
 674: LD_ADDR_EXP 10
 678: PUSH
 679: EMPTY
 680: ST_TO_ADDR
// first_powell_attack := false ;
 681: LD_ADDR_EXP 11
 685: PUSH
 686: LD_INT 0
 688: ST_TO_ADDR
// abdul_escaped := true ;
 689: LD_ADDR_EXP 12
 693: PUSH
 694: LD_INT 1
 696: ST_TO_ADDR
// loss_counter := 0 ;
 697: LD_ADDR_EXP 13
 701: PUSH
 702: LD_INT 0
 704: ST_TO_ADDR
// end ; end_of_file
 705: LD_VAR 0 1
 709: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 710: LD_INT 0
 712: PPUSH
 713: PPUSH
 714: PPUSH
 715: PPUSH
// uc_side := 7 ;
 716: LD_ADDR_OWVAR 20
 720: PUSH
 721: LD_INT 7
 723: ST_TO_ADDR
// uc_nation := 1 ;
 724: LD_ADDR_OWVAR 21
 728: PUSH
 729: LD_INT 1
 731: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 732: LD_ADDR_EXP 14
 736: PUSH
 737: LD_STRING JMM
 739: PPUSH
 740: LD_EXP 1
 744: NOT
 745: PPUSH
 746: LD_STRING 12a_
 748: PPUSH
 749: CALL 13929 0 3
 753: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 754: LD_EXP 14
 758: PPUSH
 759: LD_INT 71
 761: PPUSH
 762: LD_INT 23
 764: PPUSH
 765: LD_INT 0
 767: PPUSH
 768: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 772: LD_EXP 14
 776: PPUSH
 777: LD_INT 2
 779: PPUSH
 780: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 784: LD_ADDR_EXP 15
 788: PUSH
 789: LD_STRING Roth
 791: PPUSH
 792: LD_EXP 1
 796: NOT
 797: PPUSH
 798: LD_STRING 12a_
 800: PPUSH
 801: CALL 13929 0 3
 805: ST_TO_ADDR
// if Roth then
 806: LD_EXP 15
 810: IFFALSE 830
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 812: LD_EXP 15
 816: PPUSH
 817: LD_INT 71
 819: PPUSH
 820: LD_INT 21
 822: PPUSH
 823: LD_INT 0
 825: PPUSH
 826: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 830: LD_ADDR_EXP 16
 834: PUSH
 835: LD_STRING Lisa
 837: PPUSH
 838: LD_EXP 1
 842: NOT
 843: PPUSH
 844: LD_STRING 12a_
 846: PPUSH
 847: CALL 13929 0 3
 851: ST_TO_ADDR
// if Lisa then
 852: LD_EXP 16
 856: IFFALSE 873
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 858: LD_EXP 16
 862: PPUSH
 863: LD_INT 13
 865: PPUSH
 866: LD_INT 0
 868: PPUSH
 869: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 873: LD_ADDR_EXP 17
 877: PUSH
 878: LD_STRING Donaldson
 880: PPUSH
 881: LD_EXP 1
 885: NOT
 886: PPUSH
 887: LD_STRING 12a_
 889: PPUSH
 890: CALL 13929 0 3
 894: ST_TO_ADDR
// if Donaldson then
 895: LD_EXP 17
 899: IFFALSE 916
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 901: LD_EXP 17
 905: PPUSH
 906: LD_INT 13
 908: PPUSH
 909: LD_INT 0
 911: PPUSH
 912: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 916: LD_ADDR_EXP 18
 920: PUSH
 921: LD_STRING Bobby
 923: PPUSH
 924: LD_EXP 1
 928: NOT
 929: PPUSH
 930: LD_STRING 12a_
 932: PPUSH
 933: CALL 13929 0 3
 937: ST_TO_ADDR
// if Bobby then
 938: LD_EXP 18
 942: IFFALSE 959
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 944: LD_EXP 18
 948: PPUSH
 949: LD_INT 13
 951: PPUSH
 952: LD_INT 0
 954: PPUSH
 955: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 959: LD_ADDR_EXP 19
 963: PUSH
 964: LD_STRING Cyrus
 966: PPUSH
 967: LD_EXP 1
 971: NOT
 972: PPUSH
 973: LD_STRING 12a_
 975: PPUSH
 976: CALL 13929 0 3
 980: ST_TO_ADDR
// if Cyrus then
 981: LD_EXP 19
 985: IFFALSE 1002
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
 987: LD_EXP 19
 991: PPUSH
 992: LD_INT 13
 994: PPUSH
 995: LD_INT 0
 997: PPUSH
 998: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1002: LD_ADDR_EXP 20
1006: PUSH
1007: LD_STRING Denis
1009: PPUSH
1010: LD_EXP 1
1014: NOT
1015: PPUSH
1016: LD_STRING 12a_
1018: PPUSH
1019: CALL 13929 0 3
1023: ST_TO_ADDR
// if Denis then
1024: LD_EXP 20
1028: IFFALSE 1045
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1030: LD_EXP 20
1034: PPUSH
1035: LD_INT 13
1037: PPUSH
1038: LD_INT 0
1040: PPUSH
1041: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1045: LD_ADDR_EXP 21
1049: PUSH
1050: LD_STRING Brown
1052: PPUSH
1053: LD_EXP 1
1057: NOT
1058: PPUSH
1059: LD_STRING 12a_
1061: PPUSH
1062: CALL 13929 0 3
1066: ST_TO_ADDR
// if Brown then
1067: LD_EXP 21
1071: IFFALSE 1088
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1073: LD_EXP 21
1077: PPUSH
1078: LD_INT 13
1080: PPUSH
1081: LD_INT 0
1083: PPUSH
1084: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1088: LD_ADDR_EXP 22
1092: PUSH
1093: LD_STRING Gladstone
1095: PPUSH
1096: LD_EXP 1
1100: NOT
1101: PPUSH
1102: LD_STRING 12a_
1104: PPUSH
1105: CALL 13929 0 3
1109: ST_TO_ADDR
// if Gladstone then
1110: LD_EXP 22
1114: IFFALSE 1131
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1116: LD_EXP 22
1120: PPUSH
1121: LD_INT 13
1123: PPUSH
1124: LD_INT 0
1126: PPUSH
1127: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1131: LD_ADDR_EXP 23
1135: PUSH
1136: LD_STRING Houten
1138: PPUSH
1139: LD_EXP 1
1143: NOT
1144: PPUSH
1145: LD_STRING 12a_
1147: PPUSH
1148: CALL 13929 0 3
1152: ST_TO_ADDR
// if Houten then
1153: LD_EXP 23
1157: IFFALSE 1174
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1159: LD_EXP 23
1163: PPUSH
1164: LD_INT 13
1166: PPUSH
1167: LD_INT 0
1169: PPUSH
1170: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1174: LD_ADDR_EXP 24
1178: PUSH
1179: LD_STRING Cornell
1181: PPUSH
1182: LD_EXP 1
1186: NOT
1187: PPUSH
1188: LD_STRING 12a_
1190: PPUSH
1191: CALL 13929 0 3
1195: ST_TO_ADDR
// if Cornel then
1196: LD_EXP 24
1200: IFFALSE 1217
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1202: LD_EXP 24
1206: PPUSH
1207: LD_INT 13
1209: PPUSH
1210: LD_INT 0
1212: PPUSH
1213: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1217: LD_ADDR_EXP 25
1221: PUSH
1222: LD_STRING Gary
1224: PPUSH
1225: LD_EXP 1
1229: NOT
1230: PPUSH
1231: LD_STRING 12a_
1233: PPUSH
1234: CALL 13929 0 3
1238: ST_TO_ADDR
// if Gary then
1239: LD_EXP 25
1243: IFFALSE 1260
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1245: LD_EXP 25
1249: PPUSH
1250: LD_INT 13
1252: PPUSH
1253: LD_INT 0
1255: PPUSH
1256: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1260: LD_ADDR_EXP 26
1264: PUSH
1265: LD_STRING Frank
1267: PPUSH
1268: LD_EXP 1
1272: NOT
1273: PPUSH
1274: LD_STRING 12a_
1276: PPUSH
1277: CALL 13929 0 3
1281: ST_TO_ADDR
// if Frank then
1282: LD_EXP 26
1286: IFFALSE 1303
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1288: LD_EXP 26
1292: PPUSH
1293: LD_INT 13
1295: PPUSH
1296: LD_INT 0
1298: PPUSH
1299: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1303: LD_ADDR_EXP 27
1307: PUSH
1308: LD_STRING Kikuchi
1310: PPUSH
1311: LD_EXP 1
1315: NOT
1316: PPUSH
1317: LD_STRING 12a_
1319: PPUSH
1320: CALL 13929 0 3
1324: ST_TO_ADDR
// if Kikuchi then
1325: LD_EXP 27
1329: IFFALSE 1346
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1331: LD_EXP 27
1335: PPUSH
1336: LD_INT 13
1338: PPUSH
1339: LD_INT 0
1341: PPUSH
1342: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1346: LD_ADDR_EXP 28
1350: PUSH
1351: LD_STRING Simms
1353: PPUSH
1354: LD_EXP 1
1358: NOT
1359: PPUSH
1360: LD_STRING 12a_
1362: PPUSH
1363: CALL 13929 0 3
1367: ST_TO_ADDR
// if Simms then
1368: LD_EXP 28
1372: IFFALSE 1389
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1374: LD_EXP 28
1378: PPUSH
1379: LD_INT 13
1381: PPUSH
1382: LD_INT 0
1384: PPUSH
1385: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1389: LD_ADDR_EXP 29
1393: PUSH
1394: LD_STRING Joan
1396: PPUSH
1397: LD_EXP 1
1401: NOT
1402: PPUSH
1403: LD_STRING 12a_
1405: PPUSH
1406: CALL 13929 0 3
1410: ST_TO_ADDR
// if Joan then
1411: LD_EXP 29
1415: IFFALSE 1432
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1417: LD_EXP 29
1421: PPUSH
1422: LD_INT 13
1424: PPUSH
1425: LD_INT 0
1427: PPUSH
1428: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1432: LD_ADDR_EXP 30
1436: PUSH
1437: LD_STRING DeltaDoctor
1439: PPUSH
1440: LD_EXP 1
1444: NOT
1445: PPUSH
1446: LD_STRING 12a_
1448: PPUSH
1449: CALL 13929 0 3
1453: ST_TO_ADDR
// if DeltaDoctor then
1454: LD_EXP 30
1458: IFFALSE 1475
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1460: LD_EXP 30
1464: PPUSH
1465: LD_INT 13
1467: PPUSH
1468: LD_INT 0
1470: PPUSH
1471: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1475: LD_ADDR_VAR 0 4
1479: PUSH
1480: LD_STRING 12a_others
1482: PPUSH
1483: CALL_OW 31
1487: ST_TO_ADDR
// if tmp then
1488: LD_VAR 0 4
1492: IFFALSE 1526
// for i in tmp do
1494: LD_ADDR_VAR 0 3
1498: PUSH
1499: LD_VAR 0 4
1503: PUSH
1504: FOR_IN
1505: IFFALSE 1524
// PlaceUnitArea ( i , alliance_start , false ) ;
1507: LD_VAR 0 3
1511: PPUSH
1512: LD_INT 13
1514: PPUSH
1515: LD_INT 0
1517: PPUSH
1518: CALL_OW 49
1522: GO 1504
1524: POP
1525: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1526: LD_INT 3
1528: PPUSH
1529: LD_INT 3
1531: PPUSH
1532: LD_INT 3
1534: PPUSH
1535: LD_INT 12
1537: PPUSH
1538: LD_INT 100
1540: PPUSH
1541: CALL 20532 0 5
// veh := CreateVehicle ;
1545: LD_ADDR_VAR 0 2
1549: PUSH
1550: CALL_OW 45
1554: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1555: LD_VAR 0 2
1559: PPUSH
1560: LD_INT 2
1562: PPUSH
1563: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1567: LD_VAR 0 2
1571: PPUSH
1572: LD_INT 60
1574: PPUSH
1575: LD_INT 6
1577: PPUSH
1578: LD_INT 0
1580: PPUSH
1581: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1585: LD_VAR 0 2
1589: PPUSH
1590: LD_INT 4
1592: PPUSH
1593: LD_INT 30
1595: PPUSH
1596: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1600: LD_STRING 11_artifact_captured
1602: PPUSH
1603: LD_INT 0
1605: PPUSH
1606: CALL_OW 30
1610: IFFALSE 1686
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1612: LD_INT 3
1614: PPUSH
1615: LD_INT 3
1617: PPUSH
1618: LD_INT 3
1620: PPUSH
1621: LD_INT 12
1623: PPUSH
1624: LD_INT 100
1626: PPUSH
1627: CALL 20532 0 5
// veh := CreateVehicle ;
1631: LD_ADDR_VAR 0 2
1635: PUSH
1636: CALL_OW 45
1640: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1641: LD_VAR 0 2
1645: PPUSH
1646: LD_INT 3
1648: PPUSH
1649: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1653: LD_VAR 0 2
1657: PPUSH
1658: LD_INT 75
1660: PPUSH
1661: LD_INT 6
1663: PPUSH
1664: LD_INT 0
1666: PPUSH
1667: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1671: LD_VAR 0 2
1675: PPUSH
1676: LD_INT 4
1678: PPUSH
1679: LD_INT 50
1681: PPUSH
1682: CALL_OW 290
// end ; end ;
1686: LD_VAR 0 1
1690: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1691: LD_INT 0
1693: PPUSH
1694: PPUSH
1695: PPUSH
1696: PPUSH
// uc_side := 6 ;
1697: LD_ADDR_OWVAR 20
1701: PUSH
1702: LD_INT 6
1704: ST_TO_ADDR
// uc_nation := 3 ;
1705: LD_ADDR_OWVAR 21
1709: PUSH
1710: LD_INT 3
1712: ST_TO_ADDR
// InitHc ;
1713: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1717: LD_ADDR_EXP 31
1721: PUSH
1722: LD_STRING Gossudarov
1724: PPUSH
1725: CALL_OW 25
1729: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1730: LD_ADDR_EXP 32
1734: PUSH
1735: LD_STRING Kirilenkova
1737: PPUSH
1738: CALL_OW 25
1742: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1743: LD_ADDR_EXP 33
1747: PUSH
1748: LD_STRING Titov
1750: PPUSH
1751: CALL_OW 25
1755: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1756: LD_ADDR_EXP 38
1760: PUSH
1761: LD_STRING Oblukov
1763: PPUSH
1764: CALL_OW 25
1768: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1769: LD_ADDR_EXP 35
1773: PUSH
1774: LD_STRING Dolgov
1776: PPUSH
1777: CALL_OW 25
1781: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1782: LD_ADDR_EXP 36
1786: PUSH
1787: LD_STRING Petrosyan
1789: PPUSH
1790: CALL_OW 25
1794: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1795: LD_ADDR_EXP 37
1799: PUSH
1800: LD_STRING Scholtze
1802: PPUSH
1803: CALL_OW 25
1807: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1808: LD_ADDR_EXP 39
1812: PUSH
1813: LD_STRING Kapitsova
1815: PPUSH
1816: CALL_OW 25
1820: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1821: LD_ADDR_VAR 0 2
1825: PUSH
1826: LD_EXP 31
1830: PUSH
1831: LD_EXP 32
1835: PUSH
1836: LD_EXP 33
1840: PUSH
1841: LD_EXP 38
1845: PUSH
1846: LD_EXP 35
1850: PUSH
1851: LD_EXP 36
1855: PUSH
1856: LD_EXP 37
1860: PUSH
1861: LD_EXP 39
1865: PUSH
1866: EMPTY
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: LIST
1873: LIST
1874: LIST
1875: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1876: LD_INT 1
1878: PPUSH
1879: LD_INT 4
1881: PPUSH
1882: LD_INT 8
1884: PPUSH
1885: CALL_OW 380
// un := CreateHuman ;
1889: LD_ADDR_VAR 0 4
1893: PUSH
1894: CALL_OW 44
1898: ST_TO_ADDR
// tmp := tmp ^ un ;
1899: LD_ADDR_VAR 0 2
1903: PUSH
1904: LD_VAR 0 2
1908: PUSH
1909: LD_VAR 0 4
1913: ADD
1914: ST_TO_ADDR
// for i in tmp do
1915: LD_ADDR_VAR 0 3
1919: PUSH
1920: LD_VAR 0 2
1924: PUSH
1925: FOR_IN
1926: IFFALSE 1945
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1928: LD_VAR 0 3
1932: PPUSH
1933: LD_INT 14
1935: PPUSH
1936: LD_INT 0
1938: PPUSH
1939: CALL_OW 49
1943: GO 1925
1945: POP
1946: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1947: LD_VAR 0 2
1951: PPUSH
1952: LD_EXP 3
1956: PPUSH
1957: CALL_OW 250
1961: PPUSH
1962: LD_EXP 3
1966: PPUSH
1967: CALL_OW 251
1971: PPUSH
1972: CALL_OW 111
// end ;
1976: LD_VAR 0 1
1980: RET
// export function PrepareBelkov ; begin
1981: LD_INT 0
1983: PPUSH
// uc_side := 4 ;
1984: LD_ADDR_OWVAR 20
1988: PUSH
1989: LD_INT 4
1991: ST_TO_ADDR
// uc_nation := 3 ;
1992: LD_ADDR_OWVAR 21
1996: PUSH
1997: LD_INT 3
1999: ST_TO_ADDR
// InitHc ;
2000: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2004: LD_ADDR_EXP 46
2008: PUSH
2009: LD_STRING Belkov
2011: PPUSH
2012: CALL_OW 25
2016: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2017: LD_EXP 46
2021: PPUSH
2022: LD_INT 14
2024: PPUSH
2025: LD_INT 0
2027: PPUSH
2028: CALL_OW 49
// end ;
2032: LD_VAR 0 1
2036: RET
// export function PrepareGnyevko ; begin
2037: LD_INT 0
2039: PPUSH
// uc_side := 4 ;
2040: LD_ADDR_OWVAR 20
2044: PUSH
2045: LD_INT 4
2047: ST_TO_ADDR
// uc_nation := 3 ;
2048: LD_ADDR_OWVAR 21
2052: PUSH
2053: LD_INT 3
2055: ST_TO_ADDR
// InitHc ;
2056: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2060: LD_ADDR_EXP 47
2064: PUSH
2065: LD_STRING Gnyevko
2067: PPUSH
2068: CALL_OW 25
2072: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2073: LD_EXP 47
2077: PPUSH
2078: LD_INT 14
2080: PPUSH
2081: LD_INT 0
2083: PPUSH
2084: CALL_OW 49
// end ;
2088: LD_VAR 0 1
2092: RET
// export function PrepareBurlak ; var i , tmp ; begin
2093: LD_INT 0
2095: PPUSH
2096: PPUSH
2097: PPUSH
// uc_side := 4 ;
2098: LD_ADDR_OWVAR 20
2102: PUSH
2103: LD_INT 4
2105: ST_TO_ADDR
// uc_nation := 3 ;
2106: LD_ADDR_OWVAR 21
2110: PUSH
2111: LD_INT 3
2113: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
2114: LD_INT 35
2116: PPUSH
2117: CALL_OW 67
// until not FilterAllUnits ( [ f_distxy , 123 , 3 , 3 ] ) ;
2121: LD_INT 92
2123: PUSH
2124: LD_INT 123
2126: PUSH
2127: LD_INT 3
2129: PUSH
2130: LD_INT 3
2132: PUSH
2133: EMPTY
2134: LIST
2135: LIST
2136: LIST
2137: LIST
2138: PPUSH
2139: CALL_OW 69
2143: NOT
2144: IFFALSE 2114
// InitHc ;
2146: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2150: LD_ADDR_EXP 45
2154: PUSH
2155: LD_STRING Burlak
2157: PPUSH
2158: CALL_OW 25
2162: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2163: LD_INT 24
2165: PUSH
2166: LD_INT 23
2168: PUSH
2169: LD_INT 22
2171: PUSH
2172: EMPTY
2173: LIST
2174: LIST
2175: LIST
2176: PUSH
2177: LD_OWVAR 67
2181: ARRAY
2182: PPUSH
2183: LD_INT 1
2185: PPUSH
2186: LD_INT 1
2188: PPUSH
2189: LD_INT 45
2191: PUSH
2192: LD_INT 44
2194: PUSH
2195: LD_INT 43
2197: PUSH
2198: EMPTY
2199: LIST
2200: LIST
2201: LIST
2202: PUSH
2203: LD_OWVAR 67
2207: ARRAY
2208: PPUSH
2209: LD_INT 0
2211: PPUSH
2212: CALL 20532 0 5
// Masha := CreateVehicle ;
2216: LD_ADDR_EXP 48
2220: PUSH
2221: CALL_OW 45
2225: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2226: LD_EXP 48
2230: PUSH
2231: LD_EXP 45
2235: PUSH
2236: EMPTY
2237: LIST
2238: LIST
2239: PPUSH
2240: LD_INT 499
2242: PPUSH
2243: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2247: LD_EXP 48
2251: PPUSH
2252: LD_INT 3
2254: PPUSH
2255: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2259: LD_EXP 48
2263: PPUSH
2264: LD_INT 1
2266: PPUSH
2267: CALL_OW 242
// PlaceUnitArea ( Masha , burlak_spawn , false ) ;
2271: LD_EXP 48
2275: PPUSH
2276: LD_INT 18
2278: PPUSH
2279: LD_INT 0
2281: PPUSH
2282: CALL_OW 49
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2286: LD_EXP 45
2290: PPUSH
2291: LD_INT 125
2293: PPUSH
2294: LD_INT 1
2296: PPUSH
2297: LD_INT 0
2299: PPUSH
2300: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2304: LD_EXP 45
2308: PPUSH
2309: LD_EXP 48
2313: PPUSH
2314: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2318: LD_INT 10
2320: PPUSH
2321: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2325: LD_EXP 48
2329: PPUSH
2330: LD_INT 110
2332: PPUSH
2333: LD_INT 10
2335: PPUSH
2336: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2340: LD_ADDR_EXP 41
2344: PUSH
2345: LD_STRING Petrovova
2347: PPUSH
2348: CALL_OW 25
2352: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2353: LD_ADDR_EXP 43
2357: PUSH
2358: LD_STRING Kuzmov
2360: PPUSH
2361: CALL_OW 25
2365: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2366: LD_ADDR_EXP 42
2370: PUSH
2371: LD_STRING Kovalyuk
2373: PPUSH
2374: CALL_OW 25
2378: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2379: LD_ADDR_EXP 40
2383: PUSH
2384: LD_STRING Lipshchin
2386: PPUSH
2387: CALL_OW 25
2391: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2392: LD_ADDR_EXP 44
2396: PUSH
2397: LD_STRING Karamazov
2399: PPUSH
2400: CALL_OW 25
2404: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2405: LD_ADDR_VAR 0 3
2409: PUSH
2410: LD_EXP 41
2414: PUSH
2415: LD_EXP 43
2419: PUSH
2420: LD_EXP 42
2424: PUSH
2425: LD_EXP 40
2429: PUSH
2430: LD_EXP 44
2434: PUSH
2435: EMPTY
2436: LIST
2437: LIST
2438: LIST
2439: LIST
2440: LIST
2441: ST_TO_ADDR
// for i in tmp do
2442: LD_ADDR_VAR 0 2
2446: PUSH
2447: LD_VAR 0 3
2451: PUSH
2452: FOR_IN
2453: IFFALSE 2492
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2455: LD_VAR 0 2
2459: PPUSH
2460: LD_INT 399
2462: PPUSH
2463: LD_INT 799
2465: PPUSH
2466: CALL_OW 12
2470: PPUSH
2471: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2475: LD_VAR 0 2
2479: PPUSH
2480: LD_INT 19
2482: PPUSH
2483: LD_INT 0
2485: PPUSH
2486: CALL_OW 49
// end ;
2490: GO 2452
2492: POP
2493: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2494: LD_VAR 0 3
2498: PPUSH
2499: LD_INT 116
2501: PPUSH
2502: LD_INT 8
2504: PPUSH
2505: CALL_OW 111
// AddComHold ( tmp ) ;
2509: LD_VAR 0 3
2513: PPUSH
2514: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2518: LD_ADDR_VAR 0 2
2522: PUSH
2523: LD_VAR 0 3
2527: PPUSH
2528: LD_INT 25
2530: PUSH
2531: LD_INT 1
2533: PUSH
2534: EMPTY
2535: LIST
2536: LIST
2537: PPUSH
2538: CALL_OW 72
2542: PUSH
2543: FOR_IN
2544: IFFALSE 2584
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2546: LD_VAR 0 2
2550: PPUSH
2551: LD_INT 20
2553: PPUSH
2554: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2558: LD_VAR 0 2
2562: PPUSH
2563: LD_INT 147
2565: PPUSH
2566: LD_INT 45
2568: PPUSH
2569: CALL_OW 178
// AddComCrawl ( i ) ;
2573: LD_VAR 0 2
2577: PPUSH
2578: CALL_OW 197
// end ;
2582: GO 2543
2584: POP
2585: POP
// repeat wait ( 0 0$1 ) ;
2586: LD_INT 35
2588: PPUSH
2589: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2593: LD_EXP 48
2597: PPUSH
2598: LD_INT 110
2600: PPUSH
2601: LD_INT 10
2603: PPUSH
2604: CALL_OW 307
2608: PUSH
2609: LD_EXP 48
2613: PPUSH
2614: CALL_OW 305
2618: NOT
2619: OR
2620: IFFALSE 2586
// ComStop ( Burlak ) ;
2622: LD_EXP 45
2626: PPUSH
2627: CALL_OW 141
// AddComHold ( Burlak ) ;
2631: LD_EXP 45
2635: PPUSH
2636: CALL_OW 200
// end ; end_of_file
2640: LD_VAR 0 1
2644: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2645: LD_INT 0
2647: PPUSH
2648: PPUSH
2649: PPUSH
2650: PPUSH
// uc_side := 3 ;
2651: LD_ADDR_OWVAR 20
2655: PUSH
2656: LD_INT 3
2658: ST_TO_ADDR
// uc_nation := 3 ;
2659: LD_ADDR_OWVAR 21
2663: PUSH
2664: LD_INT 3
2666: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2667: LD_ADDR_EXP 49
2671: PUSH
2672: LD_INT 47
2674: PPUSH
2675: LD_INT 4
2677: PPUSH
2678: LD_STRING 
2680: PPUSH
2681: LD_INT 7
2683: PUSH
2684: LD_INT 8
2686: PUSH
2687: LD_INT 9
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: LIST
2694: PUSH
2695: LD_OWVAR 67
2699: ARRAY
2700: PPUSH
2701: LD_INT 10000
2703: PUSH
2704: LD_INT 3000
2706: PUSH
2707: LD_INT 300
2709: PUSH
2710: EMPTY
2711: LIST
2712: LIST
2713: LIST
2714: PPUSH
2715: LD_INT 9
2717: PUSH
2718: LD_INT 5
2720: PUSH
2721: LD_INT 6
2723: PUSH
2724: LD_INT 6
2726: PUSH
2727: EMPTY
2728: LIST
2729: LIST
2730: LIST
2731: LIST
2732: PPUSH
2733: CALL 23941 0 6
2737: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2738: LD_ADDR_EXP 58
2742: PUSH
2743: LD_EXP 58
2747: PPUSH
2748: LD_INT 2
2750: PPUSH
2751: LD_EXP 49
2755: PPUSH
2756: CALL_OW 1
2760: ST_TO_ADDR
// tmp := [ ] ;
2761: LD_ADDR_VAR 0 4
2765: PUSH
2766: EMPTY
2767: ST_TO_ADDR
// for i = 1 to 4 do
2768: LD_ADDR_VAR 0 2
2772: PUSH
2773: DOUBLE
2774: LD_INT 1
2776: DEC
2777: ST_TO_ADDR
2778: LD_INT 4
2780: PUSH
2781: FOR_TO
2782: IFFALSE 2875
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2784: LD_INT 22
2786: PPUSH
2787: LD_INT 3
2789: PPUSH
2790: LD_INT 3
2792: PPUSH
2793: LD_INT 43
2795: PUSH
2796: LD_INT 45
2798: PUSH
2799: LD_INT 45
2801: PUSH
2802: LD_INT 44
2804: PUSH
2805: EMPTY
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: PUSH
2811: LD_VAR 0 2
2815: PUSH
2816: LD_INT 4
2818: MOD
2819: PUSH
2820: LD_INT 1
2822: PLUS
2823: ARRAY
2824: PPUSH
2825: LD_INT 100
2827: PPUSH
2828: CALL 20532 0 5
// veh := CreateVehicle ;
2832: LD_ADDR_VAR 0 3
2836: PUSH
2837: CALL_OW 45
2841: ST_TO_ADDR
// tmp := tmp ^ veh ;
2842: LD_ADDR_VAR 0 4
2846: PUSH
2847: LD_VAR 0 4
2851: PUSH
2852: LD_VAR 0 3
2856: ADD
2857: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2858: LD_VAR 0 3
2862: PPUSH
2863: LD_INT 2
2865: PPUSH
2866: LD_INT 0
2868: PPUSH
2869: CALL_OW 49
// end ;
2873: GO 2781
2875: POP
2876: POP
// russian_guard := tmp ;
2877: LD_ADDR_EXP 50
2881: PUSH
2882: LD_VAR 0 4
2886: ST_TO_ADDR
// end ;
2887: LD_VAR 0 1
2891: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2892: LD_INT 47
2894: PPUSH
2895: CALL_OW 302
2899: PUSH
2900: LD_EXP 6
2904: AND
2905: IFFALSE 3507
2907: GO 2909
2909: DISABLE
2910: LD_INT 0
2912: PPUSH
2913: PPUSH
2914: PPUSH
2915: PPUSH
2916: PPUSH
2917: PPUSH
// begin enable ;
2918: ENABLE
// base := 2 ;
2919: LD_ADDR_VAR 0 2
2923: PUSH
2924: LD_INT 2
2926: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
2927: LD_ADDR_VAR 0 4
2931: PUSH
2932: LD_INT 0
2934: PUSH
2935: LD_INT 0
2937: PUSH
2938: LD_INT 0
2940: PUSH
2941: LD_INT 0
2943: PUSH
2944: LD_INT 0
2946: PUSH
2947: LD_INT 0
2949: PUSH
2950: LD_INT 0
2952: PUSH
2953: LD_INT 0
2955: PUSH
2956: LD_INT 1
2958: PUSH
2959: LD_INT 0
2961: PUSH
2962: EMPTY
2963: LIST
2964: LIST
2965: LIST
2966: LIST
2967: LIST
2968: LIST
2969: LIST
2970: LIST
2971: LIST
2972: LIST
2973: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
2974: LD_ADDR_VAR 0 3
2978: PUSH
2979: LD_INT 22
2981: PUSH
2982: LD_INT 1
2984: PUSH
2985: LD_INT 3
2987: PUSH
2988: LD_INT 45
2990: PUSH
2991: EMPTY
2992: LIST
2993: LIST
2994: LIST
2995: LIST
2996: PUSH
2997: LD_INT 21
2999: PUSH
3000: LD_INT 1
3002: PUSH
3003: LD_INT 3
3005: PUSH
3006: LD_INT 45
3008: PUSH
3009: EMPTY
3010: LIST
3011: LIST
3012: LIST
3013: LIST
3014: PUSH
3015: LD_INT 22
3017: PUSH
3018: LD_INT 1
3020: PUSH
3021: LD_INT 3
3023: PUSH
3024: LD_INT 45
3026: PUSH
3027: EMPTY
3028: LIST
3029: LIST
3030: LIST
3031: LIST
3032: PUSH
3033: LD_INT 23
3035: PUSH
3036: LD_INT 1
3038: PUSH
3039: LD_INT 3
3041: PUSH
3042: LD_INT 46
3044: PUSH
3045: EMPTY
3046: LIST
3047: LIST
3048: LIST
3049: LIST
3050: PUSH
3051: EMPTY
3052: LIST
3053: LIST
3054: LIST
3055: LIST
3056: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3057: LD_ADDR_VAR 0 1
3061: PUSH
3062: DOUBLE
3063: LD_INT 1
3065: DEC
3066: ST_TO_ADDR
3067: LD_OWVAR 67
3071: PUSH
3072: LD_OWVAR 1
3076: PUSH
3077: LD_INT 21000
3079: DIV
3080: PLUS
3081: PUSH
3082: FOR_TO
3083: IFFALSE 3171
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3085: LD_ADDR_VAR 0 3
3089: PUSH
3090: LD_VAR 0 3
3094: PPUSH
3095: LD_VAR 0 3
3099: PUSH
3100: LD_INT 1
3102: PLUS
3103: PPUSH
3104: LD_INT 23
3106: PUSH
3107: LD_INT 24
3109: PUSH
3110: EMPTY
3111: LIST
3112: LIST
3113: PUSH
3114: LD_INT 1
3116: PPUSH
3117: LD_INT 2
3119: PPUSH
3120: CALL_OW 12
3124: ARRAY
3125: PUSH
3126: LD_INT 1
3128: PUSH
3129: LD_INT 3
3131: PUSH
3132: LD_INT 46
3134: PUSH
3135: LD_INT 47
3137: PUSH
3138: LD_INT 45
3140: PUSH
3141: EMPTY
3142: LIST
3143: LIST
3144: LIST
3145: PUSH
3146: LD_INT 1
3148: PPUSH
3149: LD_INT 3
3151: PPUSH
3152: CALL_OW 12
3156: ARRAY
3157: PUSH
3158: EMPTY
3159: LIST
3160: LIST
3161: LIST
3162: LIST
3163: PPUSH
3164: CALL_OW 2
3168: ST_TO_ADDR
3169: GO 3082
3171: POP
3172: POP
// MC_InsertProduceList ( base , tmp ) ;
3173: LD_VAR 0 2
3177: PPUSH
3178: LD_VAR 0 3
3182: PPUSH
3183: CALL 79715 0 2
// repeat wait ( 0 0$1 ) ;
3187: LD_INT 35
3189: PPUSH
3190: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3194: LD_EXP 77
3198: PUSH
3199: LD_VAR 0 2
3203: ARRAY
3204: PUSH
3205: LD_INT 6
3207: GREATER
3208: IFFALSE 3187
// wait ( 0 0$20 ) ;
3210: LD_INT 700
3212: PPUSH
3213: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3217: LD_ADDR_VAR 0 5
3221: PUSH
3222: LD_INT 71
3224: PUSH
3225: LD_INT 19
3227: PUSH
3228: EMPTY
3229: LIST
3230: LIST
3231: PUSH
3232: LD_INT 91
3234: PUSH
3235: LD_INT 67
3237: PUSH
3238: EMPTY
3239: LIST
3240: LIST
3241: PUSH
3242: LD_INT 52
3244: PUSH
3245: LD_INT 44
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: PUSH
3252: LD_INT 68
3254: PUSH
3255: LD_INT 48
3257: PUSH
3258: EMPTY
3259: LIST
3260: LIST
3261: PUSH
3262: EMPTY
3263: LIST
3264: LIST
3265: LIST
3266: LIST
3267: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3268: LD_ADDR_VAR 0 6
3272: PUSH
3273: LD_EXP 77
3277: PUSH
3278: LD_VAR 0 2
3282: ARRAY
3283: PUSH
3284: LD_EXP 77
3288: PUSH
3289: LD_VAR 0 2
3293: ARRAY
3294: PPUSH
3295: LD_INT 2
3297: PUSH
3298: LD_INT 34
3300: PUSH
3301: LD_INT 51
3303: PUSH
3304: EMPTY
3305: LIST
3306: LIST
3307: PUSH
3308: LD_INT 34
3310: PUSH
3311: LD_INT 52
3313: PUSH
3314: EMPTY
3315: LIST
3316: LIST
3317: PUSH
3318: EMPTY
3319: LIST
3320: LIST
3321: LIST
3322: PPUSH
3323: CALL_OW 72
3327: DIFF
3328: ST_TO_ADDR
// if not attackers then
3329: LD_VAR 0 6
3333: NOT
3334: IFFALSE 3338
// exit ;
3336: GO 3507
// ru_attackers := attackers ;
3338: LD_ADDR_EXP 51
3342: PUSH
3343: LD_VAR 0 6
3347: ST_TO_ADDR
// for i = 1 to attackers do
3348: LD_ADDR_VAR 0 1
3352: PUSH
3353: DOUBLE
3354: LD_INT 1
3356: DEC
3357: ST_TO_ADDR
3358: LD_VAR 0 6
3362: PUSH
3363: FOR_TO
3364: IFFALSE 3441
// begin case i mod 3 of 0 :
3366: LD_VAR 0 1
3370: PUSH
3371: LD_INT 3
3373: MOD
3374: PUSH
3375: LD_INT 0
3377: DOUBLE
3378: EQUAL
3379: IFTRUE 3383
3381: GO 3386
3383: POP
// ; 1 :
3384: GO 3439
3386: LD_INT 1
3388: DOUBLE
3389: EQUAL
3390: IFTRUE 3394
3392: GO 3412
3394: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3395: LD_VAR 0 1
3399: PPUSH
3400: LD_INT 32
3402: PPUSH
3403: LD_INT 49
3405: PPUSH
3406: CALL_OW 114
3410: GO 3439
3412: LD_INT 2
3414: DOUBLE
3415: EQUAL
3416: IFTRUE 3420
3418: GO 3438
3420: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3421: LD_VAR 0 1
3425: PPUSH
3426: LD_INT 117
3428: PPUSH
3429: LD_INT 107
3431: PPUSH
3432: CALL_OW 114
3436: GO 3439
3438: POP
// end ;
3439: GO 3363
3441: POP
3442: POP
// repeat wait ( 0 0$1 ) ;
3443: LD_INT 35
3445: PPUSH
3446: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3450: LD_VAR 0 6
3454: PPUSH
3455: LD_INT 60
3457: PUSH
3458: EMPTY
3459: LIST
3460: PPUSH
3461: CALL_OW 72
3465: NOT
3466: IFFALSE 3443
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3468: LD_VAR 0 2
3472: PPUSH
3473: LD_VAR 0 6
3477: PPUSH
3478: LD_VAR 0 5
3482: PPUSH
3483: LD_VAR 0 4
3487: PPUSH
3488: CALL 79900 0 4
// if not first_attack then
3492: LD_EXP 7
3496: NOT
3497: IFFALSE 3507
// first_attack := true ;
3499: LD_ADDR_EXP 7
3503: PUSH
3504: LD_INT 1
3506: ST_TO_ADDR
// end ; end_of_file
3507: PPOPN 6
3509: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3510: LD_INT 0
3512: PPUSH
3513: PPUSH
3514: PPUSH
3515: PPUSH
3516: PPUSH
3517: PPUSH
3518: PPUSH
// uc_side := 2 ;
3519: LD_ADDR_OWVAR 20
3523: PUSH
3524: LD_INT 2
3526: ST_TO_ADDR
// uc_nation := 2 ;
3527: LD_ADDR_OWVAR 21
3531: PUSH
3532: LD_INT 2
3534: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3535: LD_ADDR_EXP 54
3539: PUSH
3540: LD_STRING Abdul
3542: PPUSH
3543: CALL_OW 25
3547: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3548: LD_EXP 54
3552: PPUSH
3553: LD_INT 11
3555: PPUSH
3556: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3560: LD_EXP 54
3564: PPUSH
3565: LD_INT 1
3567: PPUSH
3568: CALL_OW 52
// vc_chassis := 31 ;
3572: LD_ADDR_OWVAR 37
3576: PUSH
3577: LD_INT 31
3579: ST_TO_ADDR
// vc_control := control_rider ;
3580: LD_ADDR_OWVAR 38
3584: PUSH
3585: LD_INT 4
3587: ST_TO_ADDR
// mastodont := CreateVehicle ;
3588: LD_ADDR_EXP 55
3592: PUSH
3593: CALL_OW 45
3597: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3598: LD_EXP 55
3602: PPUSH
3603: LD_INT 153
3605: PPUSH
3606: LD_INT 71
3608: PPUSH
3609: LD_INT 0
3611: PPUSH
3612: CALL_OW 48
// InitVc ;
3616: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3620: LD_ADDR_EXP 52
3624: PUSH
3625: LD_INT 1
3627: PPUSH
3628: LD_INT 3
3630: PPUSH
3631: LD_STRING 
3633: PPUSH
3634: LD_INT 7
3636: PUSH
3637: LD_INT 8
3639: PUSH
3640: LD_INT 9
3642: PUSH
3643: EMPTY
3644: LIST
3645: LIST
3646: LIST
3647: PUSH
3648: LD_OWVAR 67
3652: ARRAY
3653: PPUSH
3654: LD_INT 5000
3656: PUSH
3657: LD_INT 1000
3659: PUSH
3660: LD_INT 300
3662: PUSH
3663: EMPTY
3664: LIST
3665: LIST
3666: LIST
3667: PPUSH
3668: LD_INT 22
3670: PUSH
3671: LD_INT 5
3673: PUSH
3674: LD_INT 6
3676: PUSH
3677: LD_INT 9
3679: PUSH
3680: EMPTY
3681: LIST
3682: LIST
3683: LIST
3684: LIST
3685: PPUSH
3686: CALL 23941 0 6
3690: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3691: LD_ADDR_EXP 58
3695: PUSH
3696: LD_EXP 58
3700: PPUSH
3701: LD_INT 1
3703: PPUSH
3704: LD_EXP 52
3708: PPUSH
3709: CALL_OW 1
3713: ST_TO_ADDR
// tmp := [ ] ;
3714: LD_ADDR_VAR 0 4
3718: PUSH
3719: EMPTY
3720: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3721: LD_ADDR_OWVAR 37
3725: PUSH
3726: LD_INT 14
3728: ST_TO_ADDR
// vc_engine := engine_siberite ;
3729: LD_ADDR_OWVAR 39
3733: PUSH
3734: LD_INT 3
3736: ST_TO_ADDR
// vc_control := control_manual ;
3737: LD_ADDR_OWVAR 38
3741: PUSH
3742: LD_INT 1
3744: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3745: LD_ADDR_OWVAR 40
3749: PUSH
3750: LD_INT 31
3752: ST_TO_ADDR
// for i = 1 to 3 do
3753: LD_ADDR_VAR 0 2
3757: PUSH
3758: DOUBLE
3759: LD_INT 1
3761: DEC
3762: ST_TO_ADDR
3763: LD_INT 3
3765: PUSH
3766: FOR_TO
3767: IFFALSE 4011
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3769: LD_ADDR_VAR 0 5
3773: PUSH
3774: LD_INT 153
3776: PUSH
3777: LD_INT 71
3779: PUSH
3780: EMPTY
3781: LIST
3782: LIST
3783: PUSH
3784: LD_INT 155
3786: PUSH
3787: LD_INT 81
3789: PUSH
3790: EMPTY
3791: LIST
3792: LIST
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PUSH
3798: LD_VAR 0 2
3802: PUSH
3803: LD_INT 2
3805: MOD
3806: PUSH
3807: LD_INT 1
3809: PLUS
3810: ARRAY
3811: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3812: LD_INT 0
3814: PPUSH
3815: LD_INT 3
3817: PPUSH
3818: LD_INT 7
3820: PUSH
3821: LD_INT 8
3823: PUSH
3824: LD_INT 9
3826: PUSH
3827: EMPTY
3828: LIST
3829: LIST
3830: LIST
3831: PUSH
3832: LD_OWVAR 67
3836: ARRAY
3837: PPUSH
3838: CALL_OW 380
// un := CreateVehicle ;
3842: LD_ADDR_VAR 0 6
3846: PUSH
3847: CALL_OW 45
3851: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3852: LD_VAR 0 6
3856: PPUSH
3857: LD_INT 0
3859: PPUSH
3860: LD_INT 5
3862: PPUSH
3863: CALL_OW 12
3867: PPUSH
3868: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3872: LD_VAR 0 6
3876: PPUSH
3877: LD_VAR 0 5
3881: PUSH
3882: LD_INT 1
3884: ARRAY
3885: PPUSH
3886: LD_VAR 0 5
3890: PUSH
3891: LD_INT 2
3893: ARRAY
3894: PPUSH
3895: LD_INT 6
3897: PPUSH
3898: LD_INT 0
3900: PPUSH
3901: CALL_OW 50
// un2 := CreateHuman ;
3905: LD_ADDR_VAR 0 7
3909: PUSH
3910: CALL_OW 44
3914: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
3915: LD_VAR 0 7
3919: PPUSH
3920: LD_VAR 0 6
3924: PPUSH
3925: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
3929: LD_ADDR_EXP 58
3933: PUSH
3934: LD_EXP 58
3938: PPUSH
3939: LD_INT 1
3941: PUSH
3942: LD_EXP 58
3946: PUSH
3947: LD_INT 1
3949: ARRAY
3950: PUSH
3951: LD_INT 1
3953: PLUS
3954: PUSH
3955: EMPTY
3956: LIST
3957: LIST
3958: PPUSH
3959: LD_VAR 0 6
3963: PPUSH
3964: CALL 20654 0 3
3968: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
3969: LD_ADDR_EXP 58
3973: PUSH
3974: LD_EXP 58
3978: PPUSH
3979: LD_INT 1
3981: PUSH
3982: LD_EXP 58
3986: PUSH
3987: LD_INT 1
3989: ARRAY
3990: PUSH
3991: LD_INT 1
3993: PLUS
3994: PUSH
3995: EMPTY
3996: LIST
3997: LIST
3998: PPUSH
3999: LD_VAR 0 7
4003: PPUSH
4004: CALL 20654 0 3
4008: ST_TO_ADDR
// end ;
4009: GO 3766
4011: POP
4012: POP
// for i = 1 to 5 do
4013: LD_ADDR_VAR 0 2
4017: PUSH
4018: DOUBLE
4019: LD_INT 1
4021: DEC
4022: ST_TO_ADDR
4023: LD_INT 5
4025: PUSH
4026: FOR_TO
4027: IFFALSE 4120
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4029: LD_INT 14
4031: PPUSH
4032: LD_INT 3
4034: PPUSH
4035: LD_INT 1
4037: PPUSH
4038: LD_INT 25
4040: PUSH
4041: LD_INT 28
4043: PUSH
4044: LD_INT 28
4046: PUSH
4047: LD_INT 26
4049: PUSH
4050: EMPTY
4051: LIST
4052: LIST
4053: LIST
4054: LIST
4055: PUSH
4056: LD_VAR 0 2
4060: PUSH
4061: LD_INT 4
4063: MOD
4064: PUSH
4065: LD_INT 1
4067: PLUS
4068: ARRAY
4069: PPUSH
4070: LD_INT 100
4072: PPUSH
4073: CALL 20532 0 5
// veh := CreateVehicle ;
4077: LD_ADDR_VAR 0 3
4081: PUSH
4082: CALL_OW 45
4086: ST_TO_ADDR
// tmp := tmp ^ veh ;
4087: LD_ADDR_VAR 0 4
4091: PUSH
4092: LD_VAR 0 4
4096: PUSH
4097: LD_VAR 0 3
4101: ADD
4102: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4103: LD_VAR 0 3
4107: PPUSH
4108: LD_INT 1
4110: PPUSH
4111: LD_INT 0
4113: PPUSH
4114: CALL_OW 49
// end ;
4118: GO 4026
4120: POP
4121: POP
// arabian_guard := tmp ;
4122: LD_ADDR_EXP 53
4126: PUSH
4127: LD_VAR 0 4
4131: ST_TO_ADDR
// end ;
4132: LD_VAR 0 1
4136: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4137: LD_INT 22
4139: PUSH
4140: LD_INT 7
4142: PUSH
4143: EMPTY
4144: LIST
4145: LIST
4146: PUSH
4147: LD_INT 91
4149: PUSH
4150: LD_INT 1
4152: PUSH
4153: LD_INT 12
4155: PUSH
4156: EMPTY
4157: LIST
4158: LIST
4159: LIST
4160: PUSH
4161: EMPTY
4162: LIST
4163: LIST
4164: PPUSH
4165: CALL_OW 69
4169: PUSH
4170: LD_EXP 55
4174: PPUSH
4175: CALL_OW 256
4179: PUSH
4180: LD_INT 990
4182: LESS
4183: OR
4184: PUSH
4185: LD_EXP 54
4189: PPUSH
4190: CALL_OW 256
4194: PUSH
4195: LD_INT 990
4197: LESS
4198: OR
4199: IFFALSE 4342
4201: GO 4203
4203: DISABLE
// begin if IsInUnit ( Abdul ) then
4204: LD_EXP 54
4208: PPUSH
4209: CALL_OW 310
4213: IFFALSE 4224
// ComExitBuilding ( Abdul ) ;
4215: LD_EXP 54
4219: PPUSH
4220: CALL_OW 122
// if Mastodont then
4224: LD_EXP 55
4228: IFFALSE 4245
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4230: LD_EXP 55
4234: PPUSH
4235: LD_INT 205
4237: PPUSH
4238: LD_INT 132
4240: PPUSH
4241: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4245: LD_EXP 54
4249: PPUSH
4250: LD_INT 205
4252: PPUSH
4253: LD_INT 132
4255: PPUSH
4256: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4260: LD_INT 35
4262: PPUSH
4263: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4267: LD_EXP 54
4271: PPUSH
4272: LD_INT 21
4274: PPUSH
4275: CALL_OW 308
4279: IFFALSE 4260
// RemoveUnit ( Abdul ) ;
4281: LD_EXP 54
4285: PPUSH
4286: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4290: LD_INT 35
4292: PPUSH
4293: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4297: LD_EXP 55
4301: PPUSH
4302: LD_INT 21
4304: PPUSH
4305: CALL_OW 308
4309: PUSH
4310: LD_EXP 55
4314: PPUSH
4315: CALL_OW 301
4319: OR
4320: IFFALSE 4290
// if IsOk ( Mastodont ) then
4322: LD_EXP 55
4326: PPUSH
4327: CALL_OW 302
4331: IFFALSE 4342
// RemoveUnit ( Mastodont ) ;
4333: LD_EXP 55
4337: PPUSH
4338: CALL_OW 64
// end ;
4342: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4343: LD_EXP 54
4347: PPUSH
4348: CALL_OW 301
4352: PUSH
4353: LD_INT 22
4355: PUSH
4356: LD_INT 2
4358: PUSH
4359: EMPTY
4360: LIST
4361: LIST
4362: PUSH
4363: LD_INT 2
4365: PUSH
4366: LD_INT 25
4368: PUSH
4369: LD_INT 1
4371: PUSH
4372: EMPTY
4373: LIST
4374: LIST
4375: PUSH
4376: LD_INT 25
4378: PUSH
4379: LD_INT 2
4381: PUSH
4382: EMPTY
4383: LIST
4384: LIST
4385: PUSH
4386: LD_INT 25
4388: PUSH
4389: LD_INT 3
4391: PUSH
4392: EMPTY
4393: LIST
4394: LIST
4395: PUSH
4396: LD_INT 25
4398: PUSH
4399: LD_INT 4
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: PUSH
4406: LD_INT 25
4408: PUSH
4409: LD_INT 8
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: LIST
4420: LIST
4421: LIST
4422: LIST
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PPUSH
4428: CALL_OW 69
4432: PUSH
4433: LD_INT 16
4435: PUSH
4436: LD_INT 19
4438: PUSH
4439: LD_INT 22
4441: PUSH
4442: EMPTY
4443: LIST
4444: LIST
4445: LIST
4446: PUSH
4447: LD_OWVAR 67
4451: ARRAY
4452: LESS
4453: OR
4454: IFFALSE 5127
4456: GO 4458
4458: DISABLE
4459: LD_INT 0
4461: PPUSH
4462: PPUSH
4463: PPUSH
4464: PPUSH
4465: PPUSH
4466: PPUSH
// begin MC_Kill ( 1 ) ;
4467: LD_INT 1
4469: PPUSH
4470: CALL 56729 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4474: LD_ADDR_VAR 0 2
4478: PUSH
4479: LD_INT 22
4481: PUSH
4482: LD_INT 2
4484: PUSH
4485: EMPTY
4486: LIST
4487: LIST
4488: PUSH
4489: LD_INT 2
4491: PUSH
4492: LD_INT 25
4494: PUSH
4495: LD_INT 1
4497: PUSH
4498: EMPTY
4499: LIST
4500: LIST
4501: PUSH
4502: LD_INT 25
4504: PUSH
4505: LD_INT 2
4507: PUSH
4508: EMPTY
4509: LIST
4510: LIST
4511: PUSH
4512: LD_INT 25
4514: PUSH
4515: LD_INT 3
4517: PUSH
4518: EMPTY
4519: LIST
4520: LIST
4521: PUSH
4522: LD_INT 25
4524: PUSH
4525: LD_INT 4
4527: PUSH
4528: EMPTY
4529: LIST
4530: LIST
4531: PUSH
4532: LD_INT 25
4534: PUSH
4535: LD_INT 8
4537: PUSH
4538: EMPTY
4539: LIST
4540: LIST
4541: PUSH
4542: EMPTY
4543: LIST
4544: LIST
4545: LIST
4546: LIST
4547: LIST
4548: LIST
4549: PUSH
4550: EMPTY
4551: LIST
4552: LIST
4553: PPUSH
4554: CALL_OW 69
4558: ST_TO_ADDR
// for i in tmp do
4559: LD_ADDR_VAR 0 5
4563: PUSH
4564: LD_VAR 0 2
4568: PUSH
4569: FOR_IN
4570: IFFALSE 4586
// SetTag ( i , 10 ) ;
4572: LD_VAR 0 5
4576: PPUSH
4577: LD_INT 10
4579: PPUSH
4580: CALL_OW 109
4584: GO 4569
4586: POP
4587: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4588: LD_ADDR_VAR 0 3
4592: PUSH
4593: LD_INT 22
4595: PUSH
4596: LD_INT 2
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: PUSH
4603: LD_INT 21
4605: PUSH
4606: LD_INT 1
4608: PUSH
4609: EMPTY
4610: LIST
4611: LIST
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: PPUSH
4617: CALL_OW 69
4621: PUSH
4622: LD_VAR 0 2
4626: DIFF
4627: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4628: LD_ADDR_VAR 0 1
4632: PUSH
4633: LD_INT 22
4635: PUSH
4636: LD_INT 2
4638: PUSH
4639: EMPTY
4640: LIST
4641: LIST
4642: PUSH
4643: LD_INT 21
4645: PUSH
4646: LD_INT 2
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: PUSH
4653: LD_INT 24
4655: PUSH
4656: LD_INT 300
4658: PUSH
4659: EMPTY
4660: LIST
4661: LIST
4662: PUSH
4663: EMPTY
4664: LIST
4665: LIST
4666: LIST
4667: PPUSH
4668: CALL_OW 69
4672: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4673: LD_ADDR_VAR 0 4
4677: PUSH
4678: LD_VAR 0 1
4682: PPUSH
4683: LD_INT 33
4685: PUSH
4686: LD_INT 1
4688: PUSH
4689: EMPTY
4690: LIST
4691: LIST
4692: PUSH
4693: LD_INT 58
4695: PUSH
4696: EMPTY
4697: LIST
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: PPUSH
4703: CALL_OW 72
4707: ST_TO_ADDR
// for i in tmp do
4708: LD_ADDR_VAR 0 5
4712: PUSH
4713: LD_VAR 0 2
4717: PUSH
4718: FOR_IN
4719: IFFALSE 4903
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4721: LD_VAR 0 5
4725: PUSH
4726: LD_INT 55
4728: PUSH
4729: EMPTY
4730: LIST
4731: PPUSH
4732: CALL_OW 69
4736: IN
4737: IFFALSE 4756
// begin AddComMoveXY ( i , 209 , 132 ) ;
4739: LD_VAR 0 5
4743: PPUSH
4744: LD_INT 209
4746: PPUSH
4747: LD_INT 132
4749: PPUSH
4750: CALL_OW 171
// continue ;
4754: GO 4718
// end ; if IsInUnit ( i ) then
4756: LD_VAR 0 5
4760: PPUSH
4761: CALL_OW 310
4765: IFFALSE 4783
// begin ComExitBuilding ( i ) ;
4767: LD_VAR 0 5
4771: PPUSH
4772: CALL_OW 122
// wait ( 3 ) ;
4776: LD_INT 3
4778: PPUSH
4779: CALL_OW 67
// end ; if tmp_empty then
4783: LD_VAR 0 4
4787: IFFALSE 4886
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4789: LD_VAR 0 5
4793: PPUSH
4794: LD_VAR 0 4
4798: PPUSH
4799: LD_VAR 0 5
4803: PPUSH
4804: CALL_OW 74
4808: PPUSH
4809: CALL_OW 296
4813: PUSH
4814: LD_INT 25
4816: LESS
4817: IFFALSE 4886
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4819: LD_ADDR_VAR 0 6
4823: PUSH
4824: LD_VAR 0 4
4828: PPUSH
4829: LD_VAR 0 5
4833: PPUSH
4834: CALL_OW 74
4838: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4839: LD_VAR 0 5
4843: PPUSH
4844: LD_VAR 0 6
4848: PPUSH
4849: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4853: LD_VAR 0 5
4857: PPUSH
4858: LD_INT 209
4860: PPUSH
4861: LD_INT 132
4863: PPUSH
4864: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4868: LD_ADDR_VAR 0 4
4872: PUSH
4873: LD_VAR 0 4
4877: PUSH
4878: LD_VAR 0 6
4882: DIFF
4883: ST_TO_ADDR
// continue ;
4884: GO 4718
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4886: LD_VAR 0 5
4890: PPUSH
4891: LD_INT 201
4893: PPUSH
4894: LD_INT 132
4896: PPUSH
4897: CALL_OW 171
// end ;
4901: GO 4718
4903: POP
4904: POP
// for i in tmp_ape do
4905: LD_ADDR_VAR 0 5
4909: PUSH
4910: LD_VAR 0 3
4914: PUSH
4915: FOR_IN
4916: IFFALSE 4955
// begin if IsInUnit ( i ) then
4918: LD_VAR 0 5
4922: PPUSH
4923: CALL_OW 310
4927: IFFALSE 4938
// ComExitBuilding ( i ) ;
4929: LD_VAR 0 5
4933: PPUSH
4934: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
4938: LD_VAR 0 5
4942: PPUSH
4943: LD_INT 201
4945: PPUSH
4946: LD_INT 132
4948: PPUSH
4949: CALL_OW 171
// end ;
4953: GO 4915
4955: POP
4956: POP
// repeat wait ( 0 0$1 ) ;
4957: LD_INT 35
4959: PPUSH
4960: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
4964: LD_ADDR_VAR 0 5
4968: PUSH
4969: LD_VAR 0 2
4973: PUSH
4974: LD_VAR 0 3
4978: UNION
4979: PUSH
4980: LD_VAR 0 1
4984: UNION
4985: PUSH
4986: FOR_IN
4987: IFFALSE 5018
// if not HasTask ( i ) then
4989: LD_VAR 0 5
4993: PPUSH
4994: CALL_OW 314
4998: NOT
4999: IFFALSE 5016
// ComMoveXY ( i , 201 , 132 ) ;
5001: LD_VAR 0 5
5005: PPUSH
5006: LD_INT 201
5008: PPUSH
5009: LD_INT 132
5011: PPUSH
5012: CALL_OW 111
5016: GO 4986
5018: POP
5019: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5020: LD_INT 21
5022: PPUSH
5023: LD_INT 22
5025: PUSH
5026: LD_INT 2
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: PPUSH
5033: CALL_OW 70
5037: IFFALSE 5078
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5039: LD_ADDR_VAR 0 5
5043: PUSH
5044: LD_INT 21
5046: PPUSH
5047: LD_INT 22
5049: PUSH
5050: LD_INT 2
5052: PUSH
5053: EMPTY
5054: LIST
5055: LIST
5056: PPUSH
5057: CALL_OW 70
5061: PUSH
5062: FOR_IN
5063: IFFALSE 5076
// RemoveUnit ( i ) ;
5065: LD_VAR 0 5
5069: PPUSH
5070: CALL_OW 64
5074: GO 5062
5076: POP
5077: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5078: LD_INT 22
5080: PUSH
5081: LD_INT 2
5083: PUSH
5084: EMPTY
5085: LIST
5086: LIST
5087: PUSH
5088: LD_INT 2
5090: PUSH
5091: LD_INT 21
5093: PUSH
5094: LD_INT 1
5096: PUSH
5097: EMPTY
5098: LIST
5099: LIST
5100: PUSH
5101: LD_INT 21
5103: PUSH
5104: LD_INT 2
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: PUSH
5111: EMPTY
5112: LIST
5113: LIST
5114: LIST
5115: PUSH
5116: EMPTY
5117: LIST
5118: LIST
5119: PPUSH
5120: CALL_OW 69
5124: NOT
5125: IFFALSE 4957
// end ;
5127: PPOPN 6
5129: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5130: LD_EXP 9
5134: PUSH
5135: LD_INT 92
5137: PPUSH
5138: LD_INT 40
5140: PPUSH
5141: CALL_OW 428
5145: PPUSH
5146: CALL_OW 266
5150: PUSH
5151: LD_INT 30
5153: EQUAL
5154: AND
5155: IFFALSE 5351
5157: GO 5159
5159: DISABLE
5160: LD_INT 0
5162: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5163: LD_ADDR_VAR 0 1
5167: PUSH
5168: LD_EXP 58
5172: PUSH
5173: LD_INT 1
5175: ARRAY
5176: PPUSH
5177: LD_INT 25
5179: PUSH
5180: LD_INT 4
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: PPUSH
5187: CALL_OW 72
5191: ST_TO_ADDR
// if not sci then
5192: LD_VAR 0 1
5196: NOT
5197: IFFALSE 5201
// exit ;
5199: GO 5351
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5201: LD_ADDR_EXP 58
5205: PUSH
5206: LD_EXP 58
5210: PPUSH
5211: LD_INT 1
5213: PPUSH
5214: LD_EXP 58
5218: PUSH
5219: LD_INT 1
5221: ARRAY
5222: PUSH
5223: LD_VAR 0 1
5227: PUSH
5228: LD_INT 1
5230: ARRAY
5231: DIFF
5232: PPUSH
5233: CALL_OW 1
5237: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5238: LD_VAR 0 1
5242: PUSH
5243: LD_INT 1
5245: ARRAY
5246: PPUSH
5247: CALL_OW 310
5251: IFFALSE 5266
// ComExitBuilding ( sci [ 1 ] ) ;
5253: LD_VAR 0 1
5257: PUSH
5258: LD_INT 1
5260: ARRAY
5261: PPUSH
5262: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5266: LD_INT 2
5268: PPUSH
5269: LD_INT 105
5271: PPUSH
5272: LD_INT 14
5274: PPUSH
5275: LD_INT 20
5277: PPUSH
5278: CALL 21550 0 4
5282: PUSH
5283: LD_INT 4
5285: ARRAY
5286: PUSH
5287: LD_INT 10
5289: LESS
5290: IFFALSE 5313
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5292: LD_VAR 0 1
5296: PUSH
5297: LD_INT 1
5299: ARRAY
5300: PPUSH
5301: LD_INT 105
5303: PPUSH
5304: LD_INT 14
5306: PPUSH
5307: CALL_OW 171
5311: GO 5332
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5313: LD_VAR 0 1
5317: PUSH
5318: LD_INT 1
5320: ARRAY
5321: PPUSH
5322: LD_INT 118
5324: PPUSH
5325: LD_INT 77
5327: PPUSH
5328: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5332: LD_VAR 0 1
5336: PUSH
5337: LD_INT 1
5339: ARRAY
5340: PPUSH
5341: LD_INT 92
5343: PPUSH
5344: LD_INT 40
5346: PPUSH
5347: CALL_OW 218
// end ;
5351: PPOPN 1
5353: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5354: LD_INT 1
5356: PPUSH
5357: CALL_OW 302
5361: PUSH
5362: LD_EXP 9
5366: AND
5367: IFFALSE 5826
5369: GO 5371
5371: DISABLE
5372: LD_INT 0
5374: PPUSH
5375: PPUSH
5376: PPUSH
5377: PPUSH
5378: PPUSH
5379: PPUSH
// begin enable ;
5380: ENABLE
// base := 1 ;
5381: LD_ADDR_VAR 0 2
5385: PUSH
5386: LD_INT 1
5388: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5389: LD_ADDR_VAR 0 4
5393: PUSH
5394: LD_INT 0
5396: PUSH
5397: LD_INT 0
5399: PUSH
5400: LD_INT 0
5402: PUSH
5403: LD_INT 0
5405: PUSH
5406: LD_INT 0
5408: PUSH
5409: LD_INT 0
5411: PUSH
5412: LD_INT 0
5414: PUSH
5415: LD_INT 0
5417: PUSH
5418: LD_INT 1
5420: PUSH
5421: LD_INT 0
5423: PUSH
5424: EMPTY
5425: LIST
5426: LIST
5427: LIST
5428: LIST
5429: LIST
5430: LIST
5431: LIST
5432: LIST
5433: LIST
5434: LIST
5435: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5436: LD_ADDR_VAR 0 3
5440: PUSH
5441: LD_INT 14
5443: PUSH
5444: LD_INT 1
5446: PUSH
5447: LD_INT 2
5449: PUSH
5450: LD_INT 26
5452: PUSH
5453: EMPTY
5454: LIST
5455: LIST
5456: LIST
5457: LIST
5458: PUSH
5459: LD_INT 14
5461: PUSH
5462: LD_INT 1
5464: PUSH
5465: LD_INT 2
5467: PUSH
5468: LD_INT 28
5470: PUSH
5471: EMPTY
5472: LIST
5473: LIST
5474: LIST
5475: LIST
5476: PUSH
5477: LD_INT 13
5479: PUSH
5480: LD_INT 1
5482: PUSH
5483: LD_INT 2
5485: PUSH
5486: LD_INT 29
5488: PUSH
5489: EMPTY
5490: LIST
5491: LIST
5492: LIST
5493: LIST
5494: PUSH
5495: EMPTY
5496: LIST
5497: LIST
5498: LIST
5499: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5500: LD_ADDR_VAR 0 1
5504: PUSH
5505: DOUBLE
5506: LD_INT 1
5508: DEC
5509: ST_TO_ADDR
5510: LD_OWVAR 67
5514: PUSH
5515: LD_OWVAR 1
5519: PUSH
5520: LD_INT 21000
5522: DIV
5523: PLUS
5524: PUSH
5525: FOR_TO
5526: IFFALSE 5618
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5528: LD_ADDR_VAR 0 3
5532: PUSH
5533: LD_VAR 0 3
5537: PPUSH
5538: LD_VAR 0 3
5542: PUSH
5543: LD_INT 1
5545: PLUS
5546: PPUSH
5547: LD_INT 13
5549: PUSH
5550: LD_INT 14
5552: PUSH
5553: EMPTY
5554: LIST
5555: LIST
5556: PUSH
5557: LD_INT 1
5559: PPUSH
5560: LD_INT 2
5562: PPUSH
5563: CALL_OW 12
5567: ARRAY
5568: PUSH
5569: LD_INT 1
5571: PUSH
5572: LD_INT 2
5574: PUSH
5575: LD_INT 28
5577: PUSH
5578: LD_INT 29
5580: PUSH
5581: LD_INT 25
5583: PUSH
5584: LD_INT 26
5586: PUSH
5587: EMPTY
5588: LIST
5589: LIST
5590: LIST
5591: LIST
5592: PUSH
5593: LD_INT 1
5595: PPUSH
5596: LD_INT 4
5598: PPUSH
5599: CALL_OW 12
5603: ARRAY
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: LIST
5609: LIST
5610: PPUSH
5611: CALL_OW 2
5615: ST_TO_ADDR
5616: GO 5525
5618: POP
5619: POP
// MC_InsertProduceList ( base , tmp ) ;
5620: LD_VAR 0 2
5624: PPUSH
5625: LD_VAR 0 3
5629: PPUSH
5630: CALL 79715 0 2
// repeat wait ( 0 0$1 ) ;
5634: LD_INT 35
5636: PPUSH
5637: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5641: LD_EXP 77
5645: PUSH
5646: LD_VAR 0 2
5650: ARRAY
5651: PUSH
5652: LD_INT 6
5654: GREATER
5655: IFFALSE 5634
// wait ( 0 0$20 ) ;
5657: LD_INT 700
5659: PPUSH
5660: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5664: LD_ADDR_VAR 0 5
5668: PUSH
5669: LD_INT 124
5671: PUSH
5672: LD_INT 85
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: PUSH
5679: LD_INT 90
5681: PUSH
5682: LD_INT 61
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: PUSH
5689: LD_INT 69
5691: PUSH
5692: LD_INT 48
5694: PUSH
5695: EMPTY
5696: LIST
5697: LIST
5698: PUSH
5699: LD_INT 68
5701: PUSH
5702: LD_INT 48
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: PUSH
5709: EMPTY
5710: LIST
5711: LIST
5712: LIST
5713: LIST
5714: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5715: LD_ADDR_VAR 0 6
5719: PUSH
5720: LD_EXP 77
5724: PUSH
5725: LD_VAR 0 2
5729: ARRAY
5730: PUSH
5731: LD_EXP 77
5735: PUSH
5736: LD_VAR 0 2
5740: ARRAY
5741: PPUSH
5742: LD_INT 34
5744: PUSH
5745: LD_INT 32
5747: PUSH
5748: EMPTY
5749: LIST
5750: LIST
5751: PPUSH
5752: CALL_OW 72
5756: DIFF
5757: ST_TO_ADDR
// if not attackers then
5758: LD_VAR 0 6
5762: NOT
5763: IFFALSE 5767
// exit ;
5765: GO 5826
// ar_attackers := attackers ;
5767: LD_ADDR_EXP 10
5771: PUSH
5772: LD_VAR 0 6
5776: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5777: LD_INT 35
5779: PPUSH
5780: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5784: LD_VAR 0 6
5788: PPUSH
5789: LD_INT 60
5791: PUSH
5792: EMPTY
5793: LIST
5794: PPUSH
5795: CALL_OW 72
5799: NOT
5800: IFFALSE 5777
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5802: LD_VAR 0 2
5806: PPUSH
5807: LD_VAR 0 6
5811: PPUSH
5812: LD_VAR 0 5
5816: PPUSH
5817: LD_VAR 0 4
5821: PPUSH
5822: CALL 79900 0 4
// end ;
5826: PPOPN 6
5828: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5829: LD_INT 1
5831: PPUSH
5832: CALL_OW 302
5836: PUSH
5837: LD_EXP 9
5841: AND
5842: PUSH
5843: LD_EXP 48
5847: PPUSH
5848: LD_INT 22
5850: PPUSH
5851: CALL_OW 308
5855: AND
5856: PUSH
5857: LD_INT 1
5859: PPUSH
5860: CALL 80063 0 1
5864: PUSH
5865: LD_INT 0
5867: EQUAL
5868: AND
5869: PUSH
5870: LD_EXP 10
5874: NOT
5875: AND
5876: IFFALSE 6340
5878: GO 5880
5880: DISABLE
5881: LD_INT 0
5883: PPUSH
5884: PPUSH
5885: PPUSH
5886: PPUSH
5887: PPUSH
5888: PPUSH
5889: PPUSH
// begin base := 1 ;
5890: LD_ADDR_VAR 0 2
5894: PUSH
5895: LD_INT 1
5897: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5898: LD_ADDR_VAR 0 4
5902: PUSH
5903: LD_INT 0
5905: PUSH
5906: LD_INT 0
5908: PUSH
5909: LD_INT 0
5911: PUSH
5912: LD_INT 0
5914: PUSH
5915: LD_INT 0
5917: PUSH
5918: LD_INT 0
5920: PUSH
5921: LD_INT 0
5923: PUSH
5924: LD_INT 0
5926: PUSH
5927: LD_INT 1
5929: PUSH
5930: LD_INT 0
5932: PUSH
5933: EMPTY
5934: LIST
5935: LIST
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: LIST
5943: LIST
5944: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
5945: LD_ADDR_VAR 0 3
5949: PUSH
5950: LD_INT 13
5952: PUSH
5953: LD_INT 1
5955: PUSH
5956: LD_INT 2
5958: PUSH
5959: LD_INT 28
5961: PUSH
5962: EMPTY
5963: LIST
5964: LIST
5965: LIST
5966: LIST
5967: PUSH
5968: LD_INT 13
5970: PUSH
5971: LD_INT 1
5973: PUSH
5974: LD_INT 2
5976: PUSH
5977: LD_INT 27
5979: PUSH
5980: EMPTY
5981: LIST
5982: LIST
5983: LIST
5984: LIST
5985: PUSH
5986: LD_INT 13
5988: PUSH
5989: LD_INT 1
5991: PUSH
5992: LD_INT 2
5994: PUSH
5995: LD_INT 25
5997: PUSH
5998: EMPTY
5999: LIST
6000: LIST
6001: LIST
6002: LIST
6003: PUSH
6004: LD_INT 11
6006: PUSH
6007: LD_INT 2
6009: PUSH
6010: LD_INT 2
6012: PUSH
6013: LD_INT 24
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: PUSH
6022: LD_INT 11
6024: PUSH
6025: LD_INT 2
6027: PUSH
6028: LD_INT 2
6030: PUSH
6031: LD_INT 24
6033: PUSH
6034: EMPTY
6035: LIST
6036: LIST
6037: LIST
6038: LIST
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: LIST
6044: LIST
6045: LIST
6046: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6047: LD_VAR 0 2
6051: PPUSH
6052: LD_VAR 0 3
6056: PPUSH
6057: CALL 79715 0 2
// repeat wait ( 0 0$1 ) ;
6061: LD_INT 35
6063: PPUSH
6064: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6068: LD_EXP 77
6072: PUSH
6073: LD_VAR 0 2
6077: ARRAY
6078: PUSH
6079: LD_INT 6
6081: GREATEREQUAL
6082: IFFALSE 6061
// wait ( 0 0$20 ) ;
6084: LD_INT 700
6086: PPUSH
6087: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6091: LD_ADDR_VAR 0 5
6095: PUSH
6096: LD_INT 119
6098: PUSH
6099: LD_INT 9
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PUSH
6106: EMPTY
6107: LIST
6108: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6109: LD_ADDR_VAR 0 6
6113: PUSH
6114: LD_EXP 77
6118: PUSH
6119: LD_VAR 0 2
6123: ARRAY
6124: PUSH
6125: LD_EXP 77
6129: PUSH
6130: LD_VAR 0 2
6134: ARRAY
6135: PPUSH
6136: LD_INT 34
6138: PUSH
6139: LD_INT 32
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: PPUSH
6146: CALL_OW 72
6150: DIFF
6151: ST_TO_ADDR
// if not attackers then
6152: LD_VAR 0 6
6156: NOT
6157: IFFALSE 6161
// exit ;
6159: GO 6340
// uc_side := 2 ;
6161: LD_ADDR_OWVAR 20
6165: PUSH
6166: LD_INT 2
6168: ST_TO_ADDR
// uc_nation := 2 ;
6169: LD_ADDR_OWVAR 21
6173: PUSH
6174: LD_INT 2
6176: ST_TO_ADDR
// InitHc ;
6177: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6181: LD_ADDR_VAR 0 1
6185: PUSH
6186: DOUBLE
6187: LD_INT 1
6189: DEC
6190: ST_TO_ADDR
6191: LD_INT 4
6193: PUSH
6194: LD_INT 5
6196: PUSH
6197: LD_INT 6
6199: PUSH
6200: EMPTY
6201: LIST
6202: LIST
6203: LIST
6204: PUSH
6205: LD_OWVAR 67
6209: ARRAY
6210: PUSH
6211: FOR_TO
6212: IFFALSE 6289
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6214: LD_INT 0
6216: PPUSH
6217: LD_INT 15
6219: PUSH
6220: LD_INT 17
6222: PUSH
6223: EMPTY
6224: LIST
6225: LIST
6226: PUSH
6227: LD_INT 1
6229: PPUSH
6230: LD_INT 2
6232: PPUSH
6233: CALL_OW 12
6237: ARRAY
6238: PPUSH
6239: LD_INT 8
6241: PPUSH
6242: CALL_OW 380
// un := CreateHuman ;
6246: LD_ADDR_VAR 0 7
6250: PUSH
6251: CALL_OW 44
6255: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6256: LD_VAR 0 7
6260: PPUSH
6261: LD_INT 23
6263: PPUSH
6264: LD_INT 0
6266: PPUSH
6267: CALL_OW 49
// attackers := attackers union un ;
6271: LD_ADDR_VAR 0 6
6275: PUSH
6276: LD_VAR 0 6
6280: PUSH
6281: LD_VAR 0 7
6285: UNION
6286: ST_TO_ADDR
// end ;
6287: GO 6211
6289: POP
6290: POP
// repeat wait ( 0 0$1 ) ;
6291: LD_INT 35
6293: PPUSH
6294: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6298: LD_VAR 0 6
6302: PPUSH
6303: LD_INT 60
6305: PUSH
6306: EMPTY
6307: LIST
6308: PPUSH
6309: CALL_OW 72
6313: NOT
6314: IFFALSE 6291
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6316: LD_VAR 0 2
6320: PPUSH
6321: LD_VAR 0 6
6325: PPUSH
6326: LD_VAR 0 5
6330: PPUSH
6331: LD_VAR 0 4
6335: PPUSH
6336: CALL 79900 0 4
// end ; end_of_file
6340: PPOPN 7
6342: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6343: LD_INT 0
6345: PPUSH
6346: PPUSH
6347: PPUSH
6348: PPUSH
// uc_side := 1 ;
6349: LD_ADDR_OWVAR 20
6353: PUSH
6354: LD_INT 1
6356: ST_TO_ADDR
// uc_nation := 1 ;
6357: LD_ADDR_OWVAR 21
6361: PUSH
6362: LD_INT 1
6364: ST_TO_ADDR
// InitHc ;
6365: CALL_OW 19
// InitVc ;
6369: CALL_OW 20
// tmp := [ ] ;
6373: LD_ADDR_VAR 0 3
6377: PUSH
6378: EMPTY
6379: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6380: LD_ADDR_VAR 0 2
6384: PUSH
6385: DOUBLE
6386: LD_INT 1
6388: DEC
6389: ST_TO_ADDR
6390: LD_INT 5
6392: PUSH
6393: LD_INT 6
6395: PUSH
6396: LD_INT 6
6398: PUSH
6399: EMPTY
6400: LIST
6401: LIST
6402: LIST
6403: PUSH
6404: LD_OWVAR 67
6408: ARRAY
6409: PUSH
6410: FOR_TO
6411: IFFALSE 6548
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6413: LD_INT 2
6415: PUSH
6416: LD_INT 4
6418: PUSH
6419: LD_INT 5
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: LIST
6426: PUSH
6427: LD_INT 1
6429: PPUSH
6430: LD_INT 3
6432: PPUSH
6433: CALL_OW 12
6437: ARRAY
6438: PPUSH
6439: LD_INT 1
6441: PUSH
6442: LD_INT 3
6444: PUSH
6445: EMPTY
6446: LIST
6447: LIST
6448: PUSH
6449: LD_INT 1
6451: PPUSH
6452: LD_INT 2
6454: PPUSH
6455: CALL_OW 12
6459: ARRAY
6460: PPUSH
6461: LD_INT 3
6463: PPUSH
6464: LD_INT 9
6466: PUSH
6467: LD_INT 7
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: PUSH
6474: LD_INT 1
6476: PPUSH
6477: LD_INT 2
6479: PPUSH
6480: CALL_OW 12
6484: ARRAY
6485: PPUSH
6486: LD_INT 78
6488: PPUSH
6489: CALL 20532 0 5
// veh := CreateVehicle ;
6493: LD_ADDR_VAR 0 4
6497: PUSH
6498: CALL_OW 45
6502: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6503: LD_VAR 0 4
6507: PPUSH
6508: LD_INT 2
6510: PPUSH
6511: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6515: LD_VAR 0 4
6519: PPUSH
6520: LD_INT 17
6522: PPUSH
6523: LD_INT 0
6525: PPUSH
6526: CALL_OW 49
// tmp := tmp ^ veh ;
6530: LD_ADDR_VAR 0 3
6534: PUSH
6535: LD_VAR 0 3
6539: PUSH
6540: LD_VAR 0 4
6544: ADD
6545: ST_TO_ADDR
// end ;
6546: GO 6410
6548: POP
6549: POP
// if not tmp then
6550: LD_VAR 0 3
6554: NOT
6555: IFFALSE 6559
// exit ;
6557: GO 6668
// if not first_powell_attack then
6559: LD_EXP 11
6563: NOT
6564: IFFALSE 6574
// first_powell_attack := true ;
6566: LD_ADDR_EXP 11
6570: PUSH
6571: LD_INT 1
6573: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6574: LD_INT 70
6576: PPUSH
6577: CALL_OW 67
// for i in tmp do
6581: LD_ADDR_VAR 0 2
6585: PUSH
6586: LD_VAR 0 3
6590: PUSH
6591: FOR_IN
6592: IFFALSE 6659
// if IsOk ( i ) then
6594: LD_VAR 0 2
6598: PPUSH
6599: CALL_OW 302
6603: IFFALSE 6641
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6605: LD_VAR 0 2
6609: PPUSH
6610: LD_INT 81
6612: PUSH
6613: LD_INT 1
6615: PUSH
6616: EMPTY
6617: LIST
6618: LIST
6619: PPUSH
6620: CALL_OW 69
6624: PPUSH
6625: LD_VAR 0 2
6629: PPUSH
6630: CALL_OW 74
6634: PPUSH
6635: CALL_OW 115
6639: GO 6657
// tmp := tmp diff i ;
6641: LD_ADDR_VAR 0 3
6645: PUSH
6646: LD_VAR 0 3
6650: PUSH
6651: LD_VAR 0 2
6655: DIFF
6656: ST_TO_ADDR
6657: GO 6591
6659: POP
6660: POP
// until not tmp ;
6661: LD_VAR 0 3
6665: NOT
6666: IFFALSE 6574
// end ; end_of_file
6668: LD_VAR 0 1
6672: RET
// export function Action ; var tmp , i , un ; begin
6673: LD_INT 0
6675: PPUSH
6676: PPUSH
6677: PPUSH
6678: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6679: LD_INT 68
6681: PPUSH
6682: LD_INT 39
6684: PPUSH
6685: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6689: LD_ADDR_VAR 0 2
6693: PUSH
6694: LD_INT 22
6696: PUSH
6697: LD_INT 7
6699: PUSH
6700: EMPTY
6701: LIST
6702: LIST
6703: PPUSH
6704: CALL_OW 69
6708: ST_TO_ADDR
// InGameOn ;
6709: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6713: LD_VAR 0 2
6717: PPUSH
6718: LD_INT 71
6720: PPUSH
6721: LD_INT 49
6723: PPUSH
6724: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6728: LD_INT 35
6730: PPUSH
6731: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6735: LD_INT 7
6737: PPUSH
6738: LD_INT 71
6740: PPUSH
6741: LD_INT 51
6743: PPUSH
6744: CALL_OW 293
6748: IFFALSE 6728
// DialogueOn ;
6750: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6754: LD_EXP 14
6758: PPUSH
6759: LD_STRING D1-JMM-1
6761: PPUSH
6762: CALL_OW 88
// if Joan then
6766: LD_EXP 29
6770: IFFALSE 6784
// Say ( Joan , D1-Joan-1 ) ;
6772: LD_EXP 29
6776: PPUSH
6777: LD_STRING D1-Joan-1
6779: PPUSH
6780: CALL_OW 88
// if Lisa then
6784: LD_EXP 16
6788: IFFALSE 6802
// Say ( Lisa , D1-Lisa-1 ) ;
6790: LD_EXP 16
6794: PPUSH
6795: LD_STRING D1-Lisa-1
6797: PPUSH
6798: CALL_OW 88
// if Joan or Lisa then
6802: LD_EXP 29
6806: PUSH
6807: LD_EXP 16
6811: OR
6812: IFFALSE 6826
// Say ( JMM , D1-JMM-2 ) ;
6814: LD_EXP 14
6818: PPUSH
6819: LD_STRING D1-JMM-2
6821: PPUSH
6822: CALL_OW 88
// DialogueOff ;
6826: CALL_OW 7
// InGameOff ;
6830: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6834: LD_INT 71
6836: PPUSH
6837: LD_INT 50
6839: PPUSH
6840: LD_INT 7
6842: PPUSH
6843: LD_INT 30
6845: NEG
6846: PPUSH
6847: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6851: LD_INT 71
6853: PPUSH
6854: LD_INT 50
6856: PPUSH
6857: LD_INT 7
6859: PPUSH
6860: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6864: LD_STRING M1
6866: PPUSH
6867: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6871: LD_INT 35
6873: PPUSH
6874: CALL_OW 67
// until freedom ;
6878: LD_EXP 3
6882: IFFALSE 6871
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6884: LD_INT 350
6886: PPUSH
6887: LD_INT 700
6889: PPUSH
6890: CALL_OW 12
6894: PPUSH
6895: CALL_OW 67
// PrepareGossudarov ;
6899: CALL 1691 0 0
// repeat wait ( 0 0$1 ) ;
6903: LD_INT 35
6905: PPUSH
6906: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
6910: LD_INT 22
6912: PUSH
6913: LD_INT 6
6915: PUSH
6916: EMPTY
6917: LIST
6918: LIST
6919: PUSH
6920: LD_INT 3
6922: PUSH
6923: LD_INT 24
6925: PUSH
6926: LD_INT 1000
6928: PUSH
6929: EMPTY
6930: LIST
6931: LIST
6932: PUSH
6933: EMPTY
6934: LIST
6935: LIST
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: PPUSH
6941: CALL_OW 69
6945: PUSH
6946: LD_INT 7
6948: PPUSH
6949: LD_EXP 31
6953: PPUSH
6954: CALL_OW 292
6958: OR
6959: IFFALSE 6903
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
6961: LD_ADDR_VAR 0 2
6965: PUSH
6966: LD_INT 22
6968: PUSH
6969: LD_INT 6
6971: PUSH
6972: EMPTY
6973: LIST
6974: LIST
6975: PPUSH
6976: CALL_OW 69
6980: ST_TO_ADDR
// for i in tmp do
6981: LD_ADDR_VAR 0 3
6985: PUSH
6986: LD_VAR 0 2
6990: PUSH
6991: FOR_IN
6992: IFFALSE 7008
// SetSide ( i , 7 ) ;
6994: LD_VAR 0 3
6998: PPUSH
6999: LD_INT 7
7001: PPUSH
7002: CALL_OW 235
7006: GO 6991
7008: POP
7009: POP
// DialogueOn ;
7010: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7014: LD_EXP 14
7018: PUSH
7019: LD_EXP 15
7023: PUSH
7024: EMPTY
7025: LIST
7026: LIST
7027: PPUSH
7028: LD_EXP 31
7032: PPUSH
7033: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7037: LD_EXP 31
7041: PPUSH
7042: CALL_OW 87
// if not Roth then
7046: LD_EXP 15
7050: NOT
7051: IFFALSE 7143
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7053: LD_VAR 0 2
7057: PPUSH
7058: LD_INT 3
7060: PUSH
7061: LD_INT 24
7063: PUSH
7064: LD_INT 1000
7066: PUSH
7067: EMPTY
7068: LIST
7069: LIST
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: PPUSH
7075: CALL_OW 72
7079: IFFALSE 7093
// Say ( JMM , D2-JMM-1 ) ;
7081: LD_EXP 14
7085: PPUSH
7086: LD_STRING D2-JMM-1
7088: PPUSH
7089: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7093: LD_EXP 14
7097: PPUSH
7098: LD_STRING D2-JMM-1b
7100: PPUSH
7101: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7105: LD_EXP 31
7109: PPUSH
7110: LD_STRING D2-Gos-1
7112: PPUSH
7113: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7117: LD_EXP 14
7121: PPUSH
7122: LD_STRING D2-JMM-2
7124: PPUSH
7125: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7129: LD_EXP 31
7133: PPUSH
7134: LD_STRING D2-Gos-2
7136: PPUSH
7137: CALL_OW 88
// end else
7141: GO 7295
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7143: LD_VAR 0 2
7147: PPUSH
7148: LD_INT 3
7150: PUSH
7151: LD_INT 24
7153: PUSH
7154: LD_INT 1000
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: PUSH
7161: EMPTY
7162: LIST
7163: LIST
7164: PPUSH
7165: CALL_OW 72
7169: IFFALSE 7195
// begin Say ( Roth , D2-Roth-2 ) ;
7171: LD_EXP 15
7175: PPUSH
7176: LD_STRING D2-Roth-2
7178: PPUSH
7179: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7183: LD_EXP 14
7187: PPUSH
7188: LD_STRING D2-JMM-1a
7190: PPUSH
7191: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7195: LD_EXP 15
7199: PPUSH
7200: LD_STRING D2-Roth-2a
7202: PPUSH
7203: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7207: LD_EXP 15
7211: PPUSH
7212: LD_STRING D2-Roth-2b
7214: PPUSH
7215: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7219: LD_EXP 14
7223: PPUSH
7224: LD_STRING D2-JMM-3
7226: PPUSH
7227: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7231: LD_VAR 0 2
7235: PPUSH
7236: LD_INT 3
7238: PUSH
7239: LD_INT 24
7241: PUSH
7242: LD_INT 1000
7244: PUSH
7245: EMPTY
7246: LIST
7247: LIST
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: PPUSH
7253: CALL_OW 72
7257: IFFALSE 7295
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7259: LD_EXP 31
7263: PPUSH
7264: LD_STRING D2-Gos-3
7266: PPUSH
7267: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7271: LD_EXP 14
7275: PPUSH
7276: LD_STRING D2-JMM-4
7278: PPUSH
7279: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7283: LD_EXP 31
7287: PPUSH
7288: LD_STRING D2-Gos-4
7290: PPUSH
7291: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7295: LD_EXP 14
7299: PPUSH
7300: LD_STRING D2-JMM-5
7302: PPUSH
7303: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7307: LD_EXP 31
7311: PPUSH
7312: LD_STRING D2-Gos-5
7314: PPUSH
7315: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7319: LD_EXP 14
7323: PPUSH
7324: LD_STRING D2-JMM-6
7326: PPUSH
7327: CALL_OW 88
// DialogueOff ;
7331: CALL_OW 7
// wait ( 0 0$2 ) ;
7335: LD_INT 70
7337: PPUSH
7338: CALL_OW 67
// if Kirilenkova then
7342: LD_EXP 32
7346: IFFALSE 7360
// Say ( Kirilenkova , D3-Kir-1 ) ;
7348: LD_EXP 32
7352: PPUSH
7353: LD_STRING D3-Kir-1
7355: PPUSH
7356: CALL_OW 88
// gossudarov_arrive := true ;
7360: LD_ADDR_EXP 4
7364: PUSH
7365: LD_INT 1
7367: ST_TO_ADDR
// Hint ( CombinedForces ) ;
7368: LD_STRING CombinedForces
7370: PPUSH
7371: CALL_OW 339
// repeat wait ( 0 0$1 ) ;
7375: LD_INT 35
7377: PPUSH
7378: CALL_OW 67
// until ru_lab_builded ;
7382: LD_EXP 5
7386: IFFALSE 7375
// if Kirilenkova then
7388: LD_EXP 32
7392: IFFALSE 7408
// Say ( Kirilenkova , D3a-Kir-1 ) else
7394: LD_EXP 32
7398: PPUSH
7399: LD_STRING D3a-Kir-1
7401: PPUSH
7402: CALL_OW 88
7406: GO 7430
// begin un := SciRu ;
7408: LD_ADDR_VAR 0 4
7412: PUSH
7413: CALL 12400 0 0
7417: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7418: LD_VAR 0 4
7422: PPUSH
7423: LD_STRING D3a-Sci1-1
7425: PPUSH
7426: CALL_OW 88
// end ; if Kirilenkova or un then
7430: LD_EXP 32
7434: PUSH
7435: LD_VAR 0 4
7439: OR
7440: IFFALSE 7454
// Say ( JMM , D3a-JMM-1 ) ;
7442: LD_EXP 14
7446: PPUSH
7447: LD_STRING D3a-JMM-1
7449: PPUSH
7450: CALL_OW 88
// end ;
7454: LD_VAR 0 1
7458: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7459: LD_EXP 4
7463: PUSH
7464: LD_INT 22
7466: PUSH
7467: LD_INT 7
7469: PUSH
7470: EMPTY
7471: LIST
7472: LIST
7473: PUSH
7474: LD_INT 2
7476: PUSH
7477: LD_INT 25
7479: PUSH
7480: LD_INT 1
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: PUSH
7487: LD_INT 25
7489: PUSH
7490: LD_INT 2
7492: PUSH
7493: EMPTY
7494: LIST
7495: LIST
7496: PUSH
7497: LD_INT 25
7499: PUSH
7500: LD_INT 3
7502: PUSH
7503: EMPTY
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 25
7509: PUSH
7510: LD_INT 4
7512: PUSH
7513: EMPTY
7514: LIST
7515: LIST
7516: PUSH
7517: LD_INT 25
7519: PUSH
7520: LD_INT 5
7522: PUSH
7523: EMPTY
7524: LIST
7525: LIST
7526: PUSH
7527: LD_INT 25
7529: PUSH
7530: LD_INT 8
7532: PUSH
7533: EMPTY
7534: LIST
7535: LIST
7536: PUSH
7537: LD_INT 25
7539: PUSH
7540: LD_INT 9
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: LIST
7551: LIST
7552: LIST
7553: LIST
7554: LIST
7555: LIST
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: PPUSH
7561: CALL_OW 69
7565: PUSH
7566: LD_INT 7
7568: LESS
7569: AND
7570: IFFALSE 7582
7572: GO 7574
7574: DISABLE
// YouLost ( TooMany ) ;
7575: LD_STRING TooMany
7577: PPUSH
7578: CALL_OW 104
7582: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7583: LD_EXP 31
7587: PPUSH
7588: CALL_OW 255
7592: PUSH
7593: LD_INT 7
7595: EQUAL
7596: IFFALSE 7796
7598: GO 7600
7600: DISABLE
7601: LD_INT 0
7603: PPUSH
7604: PPUSH
7605: PPUSH
// begin uc_side := 3 ;
7606: LD_ADDR_OWVAR 20
7610: PUSH
7611: LD_INT 3
7613: ST_TO_ADDR
// uc_nation := 3 ;
7614: LD_ADDR_OWVAR 21
7618: PUSH
7619: LD_INT 3
7621: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7622: LD_INT 21
7624: PPUSH
7625: LD_INT 3
7627: PPUSH
7628: LD_INT 3
7630: PPUSH
7631: LD_INT 42
7633: PPUSH
7634: LD_INT 100
7636: PPUSH
7637: CALL 20532 0 5
// un := CreateVehicle ;
7641: LD_ADDR_VAR 0 3
7645: PUSH
7646: CALL_OW 45
7650: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7651: LD_VAR 0 3
7655: PPUSH
7656: LD_INT 15
7658: PPUSH
7659: LD_INT 0
7661: PPUSH
7662: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7666: LD_VAR 0 3
7670: PPUSH
7671: LD_INT 67
7673: PPUSH
7674: LD_INT 45
7676: PPUSH
7677: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7681: LD_VAR 0 3
7685: PPUSH
7686: LD_INT 70
7688: PPUSH
7689: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7693: LD_VAR 0 3
7697: PPUSH
7698: LD_INT 69
7700: PPUSH
7701: LD_INT 18
7703: PPUSH
7704: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7708: LD_VAR 0 3
7712: PPUSH
7713: LD_INT 60
7715: PPUSH
7716: LD_INT 2
7718: PPUSH
7719: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7723: LD_INT 35
7725: PPUSH
7726: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7730: LD_VAR 0 3
7734: PPUSH
7735: CALL_OW 302
7739: NOT
7740: PUSH
7741: LD_VAR 0 3
7745: PPUSH
7746: LD_INT 17
7748: PPUSH
7749: CALL_OW 308
7753: OR
7754: IFFALSE 7723
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7756: LD_VAR 0 3
7760: PPUSH
7761: LD_INT 17
7763: PPUSH
7764: CALL_OW 308
7768: PUSH
7769: LD_VAR 0 3
7773: PPUSH
7774: LD_INT 60
7776: PPUSH
7777: LD_INT 2
7779: PPUSH
7780: CALL_OW 307
7784: OR
7785: IFFALSE 7796
// RemoveUnit ( un ) ;
7787: LD_VAR 0 3
7791: PPUSH
7792: CALL_OW 64
// end ;
7796: PPOPN 3
7798: END
// every 0 0$2 do var i , un , tmp ;
7799: GO 7801
7801: DISABLE
7802: LD_INT 0
7804: PPUSH
7805: PPUSH
7806: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7807: LD_INT 70
7809: PPUSH
7810: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7814: LD_ADDR_VAR 0 3
7818: PUSH
7819: LD_INT 22
7821: PUSH
7822: LD_INT 7
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: PUSH
7829: LD_INT 101
7831: PUSH
7832: LD_INT 3
7834: PUSH
7835: EMPTY
7836: LIST
7837: LIST
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: PPUSH
7843: CALL_OW 69
7847: ST_TO_ADDR
// until tmp ;
7848: LD_VAR 0 3
7852: IFFALSE 7807
// un := NearestUnitToUnit ( tmp , JMM ) ;
7854: LD_ADDR_VAR 0 2
7858: PUSH
7859: LD_VAR 0 3
7863: PPUSH
7864: LD_EXP 14
7868: PPUSH
7869: CALL_OW 74
7873: ST_TO_ADDR
// player_spotted := true ;
7874: LD_ADDR_EXP 6
7878: PUSH
7879: LD_INT 1
7881: ST_TO_ADDR
// tmp := SciRu ;
7882: LD_ADDR_VAR 0 3
7886: PUSH
7887: CALL 12400 0 0
7891: ST_TO_ADDR
// if not tmp then
7892: LD_VAR 0 3
7896: NOT
7897: IFFALSE 7909
// tmp := SolRu ;
7899: LD_ADDR_VAR 0 3
7903: PUSH
7904: CALL 12547 0 0
7908: ST_TO_ADDR
// DialogueOn ;
7909: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7913: LD_VAR 0 2
7917: PPUSH
7918: CALL_OW 250
7922: PPUSH
7923: LD_VAR 0 2
7927: PPUSH
7928: CALL_OW 251
7932: PPUSH
7933: LD_INT 7
7935: PPUSH
7936: LD_INT 8
7938: NEG
7939: PPUSH
7940: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7944: LD_VAR 0 2
7948: PPUSH
7949: CALL_OW 87
// if tmp then
7953: LD_VAR 0 3
7957: IFFALSE 7971
// Say ( tmp , D4-RSci1-1 ) ;
7959: LD_VAR 0 3
7963: PPUSH
7964: LD_STRING D4-RSci1-1
7966: PPUSH
7967: CALL_OW 88
// if Gossudarov then
7971: LD_EXP 31
7975: IFFALSE 8001
// begin Say ( Gossudarov , D4-Gos-1 ) ;
7977: LD_EXP 31
7981: PPUSH
7982: LD_STRING D4-Gos-1
7984: PPUSH
7985: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
7989: LD_EXP 14
7993: PPUSH
7994: LD_STRING D4-JMM-1
7996: PPUSH
7997: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8001: LD_VAR 0 2
8005: PPUSH
8006: CALL_OW 250
8010: PPUSH
8011: LD_VAR 0 2
8015: PPUSH
8016: CALL_OW 251
8020: PPUSH
8021: LD_INT 7
8023: PPUSH
8024: CALL_OW 331
// DialogueOff ;
8028: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8032: LD_STRING M5
8034: PPUSH
8035: CALL_OW 337
// end ;
8039: PPOPN 3
8041: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8042: LD_EXP 6
8046: IFFALSE 8635
8048: GO 8050
8050: DISABLE
8051: LD_INT 0
8053: PPUSH
8054: PPUSH
8055: PPUSH
// begin PrepareBelkov ;
8056: CALL 1981 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8060: LD_EXP 46
8064: PPUSH
8065: LD_INT 118
8067: PPUSH
8068: LD_INT 106
8070: PPUSH
8071: CALL_OW 111
// AddComHold ( Belkov ) ;
8075: LD_EXP 46
8079: PPUSH
8080: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8084: LD_INT 35
8086: PPUSH
8087: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8091: LD_EXP 46
8095: PPUSH
8096: LD_INT 118
8098: PPUSH
8099: LD_INT 106
8101: PPUSH
8102: CALL_OW 307
8106: IFFALSE 8084
// ChangeSideFog ( 4 , 7 ) ;
8108: LD_INT 4
8110: PPUSH
8111: LD_INT 7
8113: PPUSH
8114: CALL_OW 343
// if IsOk ( Belkov ) then
8118: LD_EXP 46
8122: PPUSH
8123: CALL_OW 302
8127: IFFALSE 8211
// begin InGameOn ;
8129: CALL_OW 8
// DialogueOn ;
8133: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8137: LD_EXP 46
8141: PPUSH
8142: LD_STRING D5-Bel-1
8144: PPUSH
8145: CALL_OW 94
// if Gossudarov then
8149: LD_EXP 31
8153: IFFALSE 8203
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8155: LD_EXP 31
8159: PPUSH
8160: LD_STRING D5-Gos-1
8162: PPUSH
8163: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8167: LD_EXP 14
8171: PPUSH
8172: LD_STRING D5-JMM-1
8174: PPUSH
8175: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8179: LD_EXP 31
8183: PPUSH
8184: LD_STRING D5-Gos-2
8186: PPUSH
8187: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8191: LD_EXP 14
8195: PPUSH
8196: LD_STRING D5-JMM-2
8198: PPUSH
8199: CALL_OW 88
// end ; DialogueOff ;
8203: CALL_OW 7
// InGameOff ;
8207: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8211: LD_STRING QSaveBelkov
8213: PPUSH
8214: CALL_OW 97
8218: PUSH
8219: LD_INT 1
8221: DOUBLE
8222: EQUAL
8223: IFTRUE 8227
8225: GO 8277
8227: POP
// begin DialogueOn ;
8228: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8232: LD_EXP 14
8236: PPUSH
8237: LD_STRING D5a-JMM-1
8239: PPUSH
8240: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8244: LD_EXP 46
8248: PPUSH
8249: LD_STRING D5a-Bel-1
8251: PPUSH
8252: CALL_OW 94
// DialogueOff ;
8256: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8260: LD_EXP 46
8264: PPUSH
8265: LD_INT 83
8267: PPUSH
8268: LD_INT 49
8270: PPUSH
8271: CALL_OW 111
// end ; 2 :
8275: GO 8310
8277: LD_INT 2
8279: DOUBLE
8280: EQUAL
8281: IFTRUE 8285
8283: GO 8309
8285: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8286: LD_EXP 14
8290: PPUSH
8291: LD_STRING D5a-JMM-2
8293: PPUSH
8294: CALL_OW 88
// ComHold ( Belkov ) ;
8298: LD_EXP 46
8302: PPUSH
8303: CALL_OW 140
// end ; end ;
8307: GO 8310
8309: POP
// time := 0 0$00 ;
8310: LD_ADDR_VAR 0 1
8314: PUSH
8315: LD_INT 0
8317: ST_TO_ADDR
// vehSpawned := false ;
8318: LD_ADDR_VAR 0 3
8322: PUSH
8323: LD_INT 0
8325: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8326: LD_INT 35
8328: PPUSH
8329: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8333: LD_VAR 0 1
8337: PUSH
8338: LD_INT 350
8340: PUSH
8341: LD_INT 175
8343: PUSH
8344: LD_INT 70
8346: PUSH
8347: EMPTY
8348: LIST
8349: LIST
8350: LIST
8351: PUSH
8352: LD_OWVAR 67
8356: ARRAY
8357: GREATEREQUAL
8358: PUSH
8359: LD_VAR 0 3
8363: NOT
8364: AND
8365: IFFALSE 8455
// begin vehSpawned := true ;
8367: LD_ADDR_VAR 0 3
8371: PUSH
8372: LD_INT 1
8374: ST_TO_ADDR
// uc_side := 3 ;
8375: LD_ADDR_OWVAR 20
8379: PUSH
8380: LD_INT 3
8382: ST_TO_ADDR
// uc_nation := 3 ;
8383: LD_ADDR_OWVAR 21
8387: PUSH
8388: LD_INT 3
8390: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8391: LD_INT 22
8393: PPUSH
8394: LD_INT 3
8396: PPUSH
8397: LD_INT 3
8399: PPUSH
8400: LD_INT 43
8402: PPUSH
8403: LD_INT 100
8405: PPUSH
8406: CALL 20532 0 5
// veh := CreateVehicle ;
8410: LD_ADDR_VAR 0 2
8414: PUSH
8415: CALL_OW 45
8419: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8420: LD_VAR 0 2
8424: PPUSH
8425: LD_INT 130
8427: PPUSH
8428: LD_INT 131
8430: PPUSH
8431: LD_INT 0
8433: PPUSH
8434: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8438: LD_VAR 0 2
8442: PPUSH
8443: LD_INT 100
8445: PPUSH
8446: LD_INT 82
8448: PPUSH
8449: CALL_OW 114
// end else
8453: GO 8469
// time := time + 0 0$1 ;
8455: LD_ADDR_VAR 0 1
8459: PUSH
8460: LD_VAR 0 1
8464: PUSH
8465: LD_INT 35
8467: PLUS
8468: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8469: LD_EXP 46
8473: PPUSH
8474: CALL_OW 301
8478: PUSH
8479: LD_EXP 46
8483: PPUSH
8484: CALL_OW 255
8488: PUSH
8489: LD_INT 4
8491: EQUAL
8492: AND
8493: PUSH
8494: LD_INT 22
8496: PUSH
8497: LD_INT 7
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: PPUSH
8504: CALL_OW 69
8508: PPUSH
8509: LD_EXP 46
8513: PPUSH
8514: CALL_OW 74
8518: PPUSH
8519: LD_EXP 46
8523: PPUSH
8524: CALL_OW 296
8528: PUSH
8529: LD_INT 10
8531: LESS
8532: OR
8533: IFFALSE 8326
// if IsDead ( Belkov ) then
8535: LD_EXP 46
8539: PPUSH
8540: CALL_OW 301
8544: IFFALSE 8569
// begin CenterNowOnUnits ( Belkov ) ;
8546: LD_EXP 46
8550: PPUSH
8551: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8555: LD_EXP 14
8559: PPUSH
8560: LD_STRING D5a-JMM-2a
8562: PPUSH
8563: CALL_OW 88
// exit ;
8567: GO 8635
// end ; if See ( 7 , Belkov ) then
8569: LD_INT 7
8571: PPUSH
8572: LD_EXP 46
8576: PPUSH
8577: CALL_OW 292
8581: IFFALSE 8595
// SetSide ( Belkov , 7 ) ;
8583: LD_EXP 46
8587: PPUSH
8588: LD_INT 7
8590: PPUSH
8591: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8595: LD_INT 35
8597: PPUSH
8598: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8602: LD_EXP 46
8606: PPUSH
8607: LD_INT 66
8609: PPUSH
8610: LD_INT 45
8612: PPUSH
8613: CALL_OW 297
8617: PUSH
8618: LD_INT 30
8620: LESS
8621: IFFALSE 8595
// Say ( Belkov , D6-Bel-1 ) ;
8623: LD_EXP 46
8627: PPUSH
8628: LD_STRING D6-Bel-1
8630: PPUSH
8631: CALL_OW 88
// end ;
8635: PPOPN 3
8637: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8638: LD_EXP 46
8642: PPUSH
8643: CALL_OW 302
8647: PUSH
8648: LD_EXP 46
8652: PPUSH
8653: CALL_OW 504
8657: PUSH
8658: LD_INT 2
8660: PUSH
8661: LD_INT 34
8663: PUSH
8664: LD_INT 47
8666: PUSH
8667: EMPTY
8668: LIST
8669: LIST
8670: PUSH
8671: LD_INT 34
8673: PUSH
8674: LD_INT 45
8676: PUSH
8677: EMPTY
8678: LIST
8679: LIST
8680: PUSH
8681: EMPTY
8682: LIST
8683: LIST
8684: LIST
8685: PPUSH
8686: CALL_OW 69
8690: IN
8691: AND
8692: IFFALSE 8709
8694: GO 8696
8696: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8697: LD_EXP 46
8701: PPUSH
8702: LD_STRING D7-Bel-1
8704: PPUSH
8705: CALL_OW 88
8709: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8710: LD_INT 22
8712: PUSH
8713: LD_INT 7
8715: PUSH
8716: EMPTY
8717: LIST
8718: LIST
8719: PUSH
8720: LD_INT 101
8722: PUSH
8723: LD_INT 2
8725: PUSH
8726: EMPTY
8727: LIST
8728: LIST
8729: PUSH
8730: EMPTY
8731: LIST
8732: LIST
8733: PPUSH
8734: CALL_OW 69
8738: PUSH
8739: LD_EXP 8
8743: NOT
8744: AND
8745: PUSH
8746: LD_EXP 45
8750: PPUSH
8751: CALL_OW 305
8755: NOT
8756: AND
8757: IFFALSE 9227
8759: GO 8761
8761: DISABLE
8762: LD_INT 0
8764: PPUSH
// begin ar_base_spotted := true ;
8765: LD_ADDR_EXP 8
8769: PUSH
8770: LD_INT 1
8772: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8773: LD_ADDR_VAR 0 1
8777: PUSH
8778: LD_INT 22
8780: PUSH
8781: LD_INT 2
8783: PUSH
8784: EMPTY
8785: LIST
8786: LIST
8787: PUSH
8788: LD_INT 21
8790: PUSH
8791: LD_INT 3
8793: PUSH
8794: EMPTY
8795: LIST
8796: LIST
8797: PUSH
8798: EMPTY
8799: LIST
8800: LIST
8801: PPUSH
8802: CALL_OW 69
8806: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8807: LD_ADDR_VAR 0 1
8811: PUSH
8812: LD_VAR 0 1
8816: PPUSH
8817: LD_EXP 14
8821: PPUSH
8822: CALL_OW 74
8826: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8827: LD_INT 7
8829: PPUSH
8830: LD_INT 3
8832: PPUSH
8833: CALL_OW 332
// DialogueOn ;
8837: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8841: LD_VAR 0 1
8845: PPUSH
8846: CALL_OW 250
8850: PPUSH
8851: LD_VAR 0 1
8855: PPUSH
8856: CALL_OW 251
8860: PPUSH
8861: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8865: LD_ADDR_VAR 0 1
8869: PUSH
8870: LD_INT 22
8872: PUSH
8873: LD_INT 7
8875: PUSH
8876: EMPTY
8877: LIST
8878: LIST
8879: PUSH
8880: LD_INT 23
8882: PUSH
8883: LD_INT 1
8885: PUSH
8886: EMPTY
8887: LIST
8888: LIST
8889: PUSH
8890: LD_INT 26
8892: PUSH
8893: LD_INT 1
8895: PUSH
8896: EMPTY
8897: LIST
8898: LIST
8899: PUSH
8900: EMPTY
8901: LIST
8902: LIST
8903: LIST
8904: PPUSH
8905: CALL_OW 69
8909: PUSH
8910: LD_EXP 14
8914: PUSH
8915: LD_EXP 18
8919: PUSH
8920: LD_EXP 19
8924: PUSH
8925: LD_EXP 26
8929: PUSH
8930: LD_EXP 15
8934: PUSH
8935: LD_EXP 24
8939: PUSH
8940: LD_EXP 20
8944: PUSH
8945: LD_EXP 22
8949: PUSH
8950: EMPTY
8951: LIST
8952: LIST
8953: LIST
8954: LIST
8955: LIST
8956: LIST
8957: LIST
8958: LIST
8959: DIFF
8960: ST_TO_ADDR
// if not tmp then
8961: LD_VAR 0 1
8965: NOT
8966: IFFALSE 9040
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
8968: LD_ADDR_VAR 0 1
8972: PUSH
8973: LD_INT 22
8975: PUSH
8976: LD_INT 7
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: PUSH
8983: LD_INT 23
8985: PUSH
8986: LD_INT 1
8988: PUSH
8989: EMPTY
8990: LIST
8991: LIST
8992: PUSH
8993: LD_INT 26
8995: PUSH
8996: LD_INT 2
8998: PUSH
8999: EMPTY
9000: LIST
9001: LIST
9002: PUSH
9003: EMPTY
9004: LIST
9005: LIST
9006: LIST
9007: PPUSH
9008: CALL_OW 69
9012: PUSH
9013: LD_EXP 29
9017: PUSH
9018: LD_EXP 16
9022: PUSH
9023: LD_EXP 27
9027: PUSH
9028: LD_EXP 28
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: LIST
9037: LIST
9038: DIFF
9039: ST_TO_ADDR
// if tmp then
9040: LD_VAR 0 1
9044: IFFALSE 9115
// case GetSex ( tmp [ 1 ] ) of sex_male :
9046: LD_VAR 0 1
9050: PUSH
9051: LD_INT 1
9053: ARRAY
9054: PPUSH
9055: CALL_OW 258
9059: PUSH
9060: LD_INT 1
9062: DOUBLE
9063: EQUAL
9064: IFTRUE 9068
9066: GO 9087
9068: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9069: LD_VAR 0 1
9073: PUSH
9074: LD_INT 1
9076: ARRAY
9077: PPUSH
9078: LD_STRING D9-Sol1-1
9080: PPUSH
9081: CALL_OW 88
9085: GO 9115
9087: LD_INT 2
9089: DOUBLE
9090: EQUAL
9091: IFTRUE 9095
9093: GO 9114
9095: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9096: LD_VAR 0 1
9100: PUSH
9101: LD_INT 1
9103: ARRAY
9104: PPUSH
9105: LD_STRING D9-FSol1-1
9107: PPUSH
9108: CALL_OW 88
9112: GO 9115
9114: POP
// if Frank then
9115: LD_EXP 26
9119: IFFALSE 9223
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9121: LD_EXP 55
9125: PPUSH
9126: CALL_OW 250
9130: PPUSH
9131: LD_EXP 55
9135: PPUSH
9136: CALL_OW 251
9140: PPUSH
9141: LD_INT 7
9143: PPUSH
9144: LD_INT 8
9146: PPUSH
9147: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9151: LD_EXP 55
9155: PPUSH
9156: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9160: LD_EXP 26
9164: PPUSH
9165: LD_STRING D9-Frank-1
9167: PPUSH
9168: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9172: LD_EXP 14
9176: PPUSH
9177: LD_STRING D9-JMM-1
9179: PPUSH
9180: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9184: LD_EXP 26
9188: PPUSH
9189: LD_STRING D9-Frank-2
9191: PPUSH
9192: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9196: LD_EXP 55
9200: PPUSH
9201: CALL_OW 250
9205: PPUSH
9206: LD_EXP 55
9210: PPUSH
9211: CALL_OW 251
9215: PPUSH
9216: LD_INT 7
9218: PPUSH
9219: CALL_OW 331
// end ; DialogueOff ;
9223: CALL_OW 7
// end ;
9227: PPOPN 1
9229: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9230: LD_EXP 7
9234: PUSH
9235: LD_OWVAR 1
9239: PUSH
9240: LD_INT 42000
9242: GREATEREQUAL
9243: OR
9244: IFFALSE 10271
9246: GO 9248
9248: DISABLE
9249: LD_INT 0
9251: PPUSH
9252: PPUSH
// begin selected_option := 1 ;
9253: LD_ADDR_VAR 0 2
9257: PUSH
9258: LD_INT 1
9260: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9261: LD_INT 10500
9263: PPUSH
9264: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9268: LD_INT 35
9270: PPUSH
9271: CALL_OW 67
// until not ru_attackers ;
9275: LD_EXP 51
9279: NOT
9280: IFFALSE 9268
// PrepareBurlak ;
9282: CALL 2093 0 0
// repeat wait ( 0 0$2 ) ;
9286: LD_INT 70
9288: PPUSH
9289: CALL_OW 67
// until not HasTask ( Burlak ) ;
9293: LD_EXP 45
9297: PPUSH
9298: CALL_OW 314
9302: NOT
9303: IFFALSE 9286
// InGameOn ;
9305: CALL_OW 8
// DialogueOn ;
9309: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9313: LD_EXP 48
9317: PPUSH
9318: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9322: LD_EXP 45
9326: PPUSH
9327: LD_STRING D10-Bur-1
9329: PPUSH
9330: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9334: LD_EXP 46
9338: PUSH
9339: LD_EXP 46
9343: PPUSH
9344: CALL_OW 255
9348: PUSH
9349: LD_INT 7
9351: EQUAL
9352: AND
9353: IFFALSE 9367
// Say ( Belkov , D10-Bel-1 ) ;
9355: LD_EXP 46
9359: PPUSH
9360: LD_STRING D10-Bel-1
9362: PPUSH
9363: CALL_OW 88
// if Gossudarov then
9367: LD_EXP 31
9371: IFFALSE 9385
// Say ( Gossudarov , D10-Gos-1 ) ;
9373: LD_EXP 31
9377: PPUSH
9378: LD_STRING D10-Gos-1
9380: PPUSH
9381: CALL_OW 88
// if Kirilenkova then
9385: LD_EXP 32
9389: IFFALSE 9403
// Say ( Kirilenkova , D10-Kir-1 ) ;
9391: LD_EXP 32
9395: PPUSH
9396: LD_STRING D10-Kir-1
9398: PPUSH
9399: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9403: CALL 12547 0 0
9407: PPUSH
9408: LD_STRING D10-RSol1-1
9410: PPUSH
9411: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9415: LD_EXP 45
9419: PPUSH
9420: LD_STRING D10-Bur-2
9422: PPUSH
9423: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9427: LD_EXP 14
9431: PPUSH
9432: LD_STRING D10-JMM-2
9434: PPUSH
9435: CALL_OW 88
// if Kirilenkova then
9439: LD_EXP 32
9443: IFFALSE 9459
// Say ( Kirilenkova , D10-Kir-2 ) else
9445: LD_EXP 32
9449: PPUSH
9450: LD_STRING D10-Kir-2
9452: PPUSH
9453: CALL_OW 88
9457: GO 9471
// Say ( SolRu , D10-RSol1-2 ) ;
9459: CALL 12547 0 0
9463: PPUSH
9464: LD_STRING D10-RSol1-2
9466: PPUSH
9467: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9471: LD_EXP 14
9475: PPUSH
9476: LD_STRING D10-JMM-3
9478: PPUSH
9479: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9483: LD_EXP 45
9487: PPUSH
9488: LD_STRING D10-Bur-3
9490: PPUSH
9491: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9495: LD_EXP 14
9499: PPUSH
9500: LD_STRING D10-JMM-4
9502: PPUSH
9503: CALL_OW 88
// DialogueOff ;
9507: CALL_OW 7
// InGameOff ;
9511: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9515: LD_STRING M2
9517: PPUSH
9518: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9522: LD_INT 35
9524: PPUSH
9525: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9529: LD_INT 22
9531: PUSH
9532: LD_INT 7
9534: PUSH
9535: EMPTY
9536: LIST
9537: LIST
9538: PUSH
9539: LD_INT 91
9541: PUSH
9542: LD_EXP 45
9546: PUSH
9547: LD_INT 8
9549: PUSH
9550: EMPTY
9551: LIST
9552: LIST
9553: LIST
9554: PUSH
9555: EMPTY
9556: LIST
9557: LIST
9558: PPUSH
9559: CALL_OW 69
9563: IFFALSE 9522
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9565: LD_ADDR_VAR 0 1
9569: PUSH
9570: LD_INT 22
9572: PUSH
9573: LD_INT 4
9575: PUSH
9576: EMPTY
9577: LIST
9578: LIST
9579: PPUSH
9580: CALL_OW 69
9584: PUSH
9585: FOR_IN
9586: IFFALSE 9602
// SetSide ( i , 7 ) ;
9588: LD_VAR 0 1
9592: PPUSH
9593: LD_INT 7
9595: PPUSH
9596: CALL_OW 235
9600: GO 9585
9602: POP
9603: POP
// ChangeMissionObjectives ( M3 ) ;
9604: LD_STRING M3
9606: PPUSH
9607: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9611: LD_INT 35
9613: PPUSH
9614: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9618: LD_EXP 14
9622: PPUSH
9623: LD_EXP 45
9627: PPUSH
9628: CALL_OW 296
9632: PUSH
9633: LD_INT 8
9635: LESS
9636: IFFALSE 9611
// ComTurnUnit ( JMM , Burlak ) ;
9638: LD_EXP 14
9642: PPUSH
9643: LD_EXP 45
9647: PPUSH
9648: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9652: LD_EXP 45
9656: PPUSH
9657: LD_EXP 14
9661: PPUSH
9662: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9666: LD_INT 10
9668: PPUSH
9669: CALL_OW 67
// DialogueOn ;
9673: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9677: LD_EXP 14
9681: PPUSH
9682: LD_STRING D11-JMM-1
9684: PPUSH
9685: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9689: LD_EXP 45
9693: PPUSH
9694: LD_STRING D11-Bur-1
9696: PPUSH
9697: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9701: LD_EXP 14
9705: PPUSH
9706: LD_STRING D11-JMM-2
9708: PPUSH
9709: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9713: LD_EXP 45
9717: PPUSH
9718: LD_STRING D11-Bur-2
9720: PPUSH
9721: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9725: LD_EXP 14
9729: PPUSH
9730: LD_STRING D11-JMM-3
9732: PPUSH
9733: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9737: LD_EXP 45
9741: PPUSH
9742: LD_STRING D11-Bur-3
9744: PPUSH
9745: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9749: LD_EXP 14
9753: PPUSH
9754: LD_STRING D11-JMM-4
9756: PPUSH
9757: CALL_OW 88
// if ar_base_spotted then
9761: LD_EXP 8
9765: IFFALSE 9781
// Say ( Burlak , D12-Bur-1 ) else
9767: LD_EXP 45
9771: PPUSH
9772: LD_STRING D12-Bur-1
9774: PPUSH
9775: CALL_OW 88
9779: GO 9820
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9781: LD_INT 7
9783: PPUSH
9784: LD_INT 3
9786: PPUSH
9787: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9791: LD_INT 127
9793: PPUSH
9794: LD_INT 45
9796: PPUSH
9797: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9801: LD_EXP 45
9805: PPUSH
9806: LD_STRING D12-Bur-1a
9808: PPUSH
9809: CALL_OW 88
// dwait ( 0 0$2 ) ;
9813: LD_INT 70
9815: PPUSH
9816: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9820: LD_EXP 45
9824: PPUSH
9825: LD_STRING D12-Bur-1b
9827: PPUSH
9828: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9832: LD_EXP 14
9836: PPUSH
9837: LD_STRING D12-JMM-1
9839: PPUSH
9840: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9844: LD_EXP 45
9848: PPUSH
9849: LD_STRING D12-Bur-2
9851: PPUSH
9852: CALL_OW 88
// if Roth then
9856: LD_EXP 15
9860: IFFALSE 9876
// Say ( Roth , D12-Roth-2 ) else
9862: LD_EXP 15
9866: PPUSH
9867: LD_STRING D12-Roth-2
9869: PPUSH
9870: CALL_OW 88
9874: GO 9888
// Say ( SciRu , D12-RSci1-2 ) ;
9876: CALL 12400 0 0
9880: PPUSH
9881: LD_STRING D12-RSci1-2
9883: PPUSH
9884: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9888: LD_EXP 14
9892: PPUSH
9893: LD_STRING D12-JMM-2
9895: PPUSH
9896: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9900: LD_EXP 45
9904: PPUSH
9905: LD_STRING D12-Bur-3
9907: PPUSH
9908: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9912: LD_EXP 14
9916: PPUSH
9917: LD_STRING D12-JMM-3
9919: PPUSH
9920: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
9924: LD_EXP 45
9928: PPUSH
9929: LD_STRING D12-Bur-4
9931: PPUSH
9932: CALL_OW 88
// case Query ( QBase ) of 1 :
9936: LD_STRING QBase
9938: PPUSH
9939: CALL_OW 97
9943: PUSH
9944: LD_INT 1
9946: DOUBLE
9947: EQUAL
9948: IFTRUE 9952
9950: GO 10070
9952: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
9953: LD_EXP 14
9957: PPUSH
9958: LD_STRING D13a-JMM-1
9960: PPUSH
9961: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
9965: LD_EXP 45
9969: PPUSH
9970: LD_STRING D13a-Bur-1
9972: PPUSH
9973: CALL_OW 88
// if Roth then
9977: LD_EXP 15
9981: IFFALSE 9997
// Say ( Roth , D13a-Roth-1 ) else
9983: LD_EXP 15
9987: PPUSH
9988: LD_STRING D13a-Roth-1
9990: PPUSH
9991: CALL_OW 88
9995: GO 10009
// Say ( SciRu , D13a-RSci1-1 ) ;
9997: CALL 12400 0 0
10001: PPUSH
10002: LD_STRING D13a-RSci1-1
10004: PPUSH
10005: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10009: LD_EXP 14
10013: PPUSH
10014: LD_STRING D13a-JMM-2
10016: PPUSH
10017: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10021: LD_STRING QBaseAgain
10023: PPUSH
10024: CALL_OW 97
10028: PUSH
10029: LD_INT 1
10031: DOUBLE
10032: EQUAL
10033: IFTRUE 10037
10035: GO 10048
10037: POP
// selected_option := 2 ; 2 :
10038: LD_ADDR_VAR 0 2
10042: PUSH
10043: LD_INT 2
10045: ST_TO_ADDR
10046: GO 10068
10048: LD_INT 2
10050: DOUBLE
10051: EQUAL
10052: IFTRUE 10056
10054: GO 10067
10056: POP
// selected_option := 3 ; end ;
10057: LD_ADDR_VAR 0 2
10061: PUSH
10062: LD_INT 3
10064: ST_TO_ADDR
10065: GO 10068
10067: POP
// end ; 2 :
10068: GO 10109
10070: LD_INT 2
10072: DOUBLE
10073: EQUAL
10074: IFTRUE 10078
10076: GO 10089
10078: POP
// selected_option := 2 ; 3 :
10079: LD_ADDR_VAR 0 2
10083: PUSH
10084: LD_INT 2
10086: ST_TO_ADDR
10087: GO 10109
10089: LD_INT 3
10091: DOUBLE
10092: EQUAL
10093: IFTRUE 10097
10095: GO 10108
10097: POP
// selected_option := 3 ; end ;
10098: LD_ADDR_VAR 0 2
10102: PUSH
10103: LD_INT 3
10105: ST_TO_ADDR
10106: GO 10109
10108: POP
// if selected_option = 2 then
10109: LD_VAR 0 2
10113: PUSH
10114: LD_INT 2
10116: EQUAL
10117: IFFALSE 10211
// begin Say ( JMM , D13b-JMM-1 ) ;
10119: LD_EXP 14
10123: PPUSH
10124: LD_STRING D13b-JMM-1
10126: PPUSH
10127: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10131: LD_EXP 45
10135: PPUSH
10136: LD_STRING D13b-Bur-1
10138: PPUSH
10139: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10143: LD_EXP 14
10147: PPUSH
10148: LD_STRING D13b-JMM-2
10150: PPUSH
10151: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10155: LD_EXP 54
10159: PPUSH
10160: LD_STRING D13b-Abd-2
10162: PPUSH
10163: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10167: LD_EXP 14
10171: PPUSH
10172: LD_STRING D13b-JMM-3
10174: PPUSH
10175: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10179: LD_EXP 54
10183: PPUSH
10184: LD_STRING D13b-Abd-3
10186: PPUSH
10187: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10191: LD_EXP 14
10195: PPUSH
10196: LD_STRING D13b-JMM-4
10198: PPUSH
10199: CALL_OW 88
// ar_active_attack := true ;
10203: LD_ADDR_EXP 9
10207: PUSH
10208: LD_INT 1
10210: ST_TO_ADDR
// end ; if selected_option = 3 then
10211: LD_VAR 0 2
10215: PUSH
10216: LD_INT 3
10218: EQUAL
10219: IFFALSE 10245
// begin Say ( JMM , D13c-JMM-1 ) ;
10221: LD_EXP 14
10225: PPUSH
10226: LD_STRING D13c-JMM-1
10228: PPUSH
10229: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10233: LD_EXP 45
10237: PPUSH
10238: LD_STRING D13c-Bur-1
10240: PPUSH
10241: CALL_OW 88
// end ; DialogueOff ;
10245: CALL_OW 7
// if not ar_active_attack then
10249: LD_EXP 9
10253: NOT
10254: IFFALSE 10271
// begin wait ( 6 6$00 ) ;
10256: LD_INT 12600
10258: PPUSH
10259: CALL_OW 67
// ar_active_attack := true ;
10263: LD_ADDR_EXP 9
10267: PUSH
10268: LD_INT 1
10270: ST_TO_ADDR
// end ; end ;
10271: PPOPN 2
10273: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10274: LD_EXP 45
10278: PPUSH
10279: CALL_OW 305
10283: PUSH
10284: LD_EXP 45
10288: PPUSH
10289: CALL_OW 255
10293: PUSH
10294: LD_INT 7
10296: EQUAL
10297: AND
10298: IFFALSE 10494
10300: GO 10302
10302: DISABLE
10303: LD_INT 0
10305: PPUSH
// begin wait ( 4 4$40 ) ;
10306: LD_INT 9800
10308: PPUSH
10309: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10313: LD_INT 35
10315: PPUSH
10316: CALL_OW 67
// until not ru_attackers ;
10320: LD_EXP 51
10324: NOT
10325: IFFALSE 10313
// PrepareGnyevko ;
10327: CALL 2037 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10331: LD_EXP 47
10335: PPUSH
10336: LD_INT 124
10338: PPUSH
10339: LD_INT 118
10341: PPUSH
10342: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10346: LD_EXP 47
10350: PPUSH
10351: CALL_OW 200
// time := 0 0$00 ;
10355: LD_ADDR_VAR 0 1
10359: PUSH
10360: LD_INT 0
10362: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10363: LD_INT 35
10365: PPUSH
10366: CALL_OW 67
// time := time + 0 0$1 ;
10370: LD_ADDR_VAR 0 1
10374: PUSH
10375: LD_VAR 0 1
10379: PUSH
10380: LD_INT 35
10382: PLUS
10383: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10384: LD_EXP 47
10388: PPUSH
10389: LD_INT 124
10391: PPUSH
10392: LD_INT 118
10394: PPUSH
10395: CALL_OW 307
10399: PUSH
10400: LD_VAR 0 1
10404: PUSH
10405: LD_INT 1050
10407: GREATEREQUAL
10408: OR
10409: IFFALSE 10363
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10411: LD_EXP 47
10415: PPUSH
10416: LD_STRING DBelkov-Gny-1
10418: PPUSH
10419: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10423: LD_EXP 45
10427: PPUSH
10428: LD_STRING DBelkov-Bur-1a
10430: PPUSH
10431: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10435: LD_INT 35
10437: PPUSH
10438: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10442: LD_EXP 47
10446: PPUSH
10447: LD_INT 22
10449: PUSH
10450: LD_INT 7
10452: PUSH
10453: EMPTY
10454: LIST
10455: LIST
10456: PPUSH
10457: CALL_OW 69
10461: PPUSH
10462: LD_EXP 47
10466: PPUSH
10467: CALL_OW 74
10471: PPUSH
10472: CALL_OW 296
10476: PUSH
10477: LD_INT 8
10479: LESS
10480: IFFALSE 10435
// SetSide ( Gnyevko , 7 ) ;
10482: LD_EXP 47
10486: PPUSH
10487: LD_INT 7
10489: PPUSH
10490: CALL_OW 235
// end ;
10494: PPOPN 1
10496: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10497: LD_EXP 45
10501: PPUSH
10502: CALL_OW 255
10506: PUSH
10507: LD_INT 7
10509: EQUAL
10510: IFFALSE 10520
10512: GO 10514
10514: DISABLE
// begin enable ;
10515: ENABLE
// PrepareAmericanAttack ;
10516: CALL 6343 0 0
// end ;
10520: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10521: LD_INT 22
10523: PUSH
10524: LD_INT 1
10526: PUSH
10527: EMPTY
10528: LIST
10529: LIST
10530: PPUSH
10531: CALL_OW 69
10535: IFFALSE 10719
10537: GO 10539
10539: DISABLE
10540: LD_INT 0
10542: PPUSH
10543: PPUSH
// begin while true do
10544: LD_INT 1
10546: IFFALSE 10603
// begin wait ( 0 0$1 ) ;
10548: LD_INT 35
10550: PPUSH
10551: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10555: LD_ADDR_VAR 0 2
10559: PUSH
10560: LD_INT 22
10562: PUSH
10563: LD_INT 1
10565: PUSH
10566: EMPTY
10567: LIST
10568: LIST
10569: PPUSH
10570: CALL_OW 69
10574: PPUSH
10575: LD_EXP 14
10579: PPUSH
10580: CALL_OW 74
10584: ST_TO_ADDR
// if See ( 7 , tmp ) then
10585: LD_INT 7
10587: PPUSH
10588: LD_VAR 0 2
10592: PPUSH
10593: CALL_OW 292
10597: IFFALSE 10601
// break ;
10599: GO 10603
// end ;
10601: GO 10544
// DialogueOn ;
10603: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10607: LD_VAR 0 2
10611: PPUSH
10612: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10616: LD_VAR 0 2
10620: PPUSH
10621: CALL_OW 250
10625: PPUSH
10626: LD_VAR 0 2
10630: PPUSH
10631: CALL_OW 251
10635: PPUSH
10636: LD_INT 7
10638: PPUSH
10639: LD_INT 8
10641: PPUSH
10642: CALL_OW 330
// if Denis then
10646: LD_EXP 20
10650: IFFALSE 10664
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10652: LD_EXP 20
10656: PPUSH
10657: LD_STRING DAmerAttack-Pet-1
10659: PPUSH
10660: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10664: LD_EXP 14
10668: PPUSH
10669: LD_STRING DAmerAttack-JMM-1
10671: PPUSH
10672: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10676: LD_EXP 45
10680: PPUSH
10681: LD_STRING DStop-Bur-1
10683: PPUSH
10684: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10688: LD_VAR 0 2
10692: PPUSH
10693: CALL_OW 250
10697: PPUSH
10698: LD_VAR 0 2
10702: PPUSH
10703: CALL_OW 251
10707: PPUSH
10708: LD_INT 7
10710: PPUSH
10711: CALL_OW 331
// DialogueOff ;
10715: CALL_OW 7
// end ;
10719: PPOPN 2
10721: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10722: LD_INT 22
10724: PUSH
10725: LD_INT 3
10727: PUSH
10728: EMPTY
10729: LIST
10730: LIST
10731: PUSH
10732: LD_INT 21
10734: PUSH
10735: LD_INT 1
10737: PUSH
10738: EMPTY
10739: LIST
10740: LIST
10741: PUSH
10742: EMPTY
10743: LIST
10744: LIST
10745: PPUSH
10746: CALL_OW 69
10750: PUSH
10751: LD_INT 0
10753: EQUAL
10754: IFFALSE 10796
10756: GO 10758
10758: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10759: LD_STRING M5a
10761: PPUSH
10762: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10766: LD_EXP 14
10770: PPUSH
10771: LD_STRING D8-JMM-1
10773: PPUSH
10774: CALL_OW 88
// if Gossudarov then
10778: LD_EXP 31
10782: IFFALSE 10796
// Say ( Gossudarov , D8-Gos-1 ) ;
10784: LD_EXP 31
10788: PPUSH
10789: LD_STRING D8-Gos-1
10791: PPUSH
10792: CALL_OW 88
// end ;
10796: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10797: LD_INT 22
10799: PUSH
10800: LD_INT 2
10802: PUSH
10803: EMPTY
10804: LIST
10805: LIST
10806: PUSH
10807: LD_INT 21
10809: PUSH
10810: LD_INT 1
10812: PUSH
10813: EMPTY
10814: LIST
10815: LIST
10816: PUSH
10817: EMPTY
10818: LIST
10819: LIST
10820: PPUSH
10821: CALL_OW 69
10825: PUSH
10826: LD_INT 0
10828: EQUAL
10829: IFFALSE 10879
10831: GO 10833
10833: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10834: LD_STRING M4c
10836: PPUSH
10837: CALL_OW 337
// if Roth then
10841: LD_EXP 15
10845: IFFALSE 10861
// Say ( Roth , DStop-Roth-1 ) else
10847: LD_EXP 15
10851: PPUSH
10852: LD_STRING DStop-Roth-1
10854: PPUSH
10855: CALL_OW 88
10859: GO 10879
// if Gossudarov then
10861: LD_EXP 31
10865: IFFALSE 10879
// Say ( Gossudarov , D8-Gos-1a ) ;
10867: LD_EXP 31
10871: PPUSH
10872: LD_STRING D8-Gos-1a
10874: PPUSH
10875: CALL_OW 88
// end ;
10879: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10880: LD_INT 7
10882: PPUSH
10883: LD_INT 1
10885: PPUSH
10886: LD_INT 1
10888: PPUSH
10889: CALL 13992 0 3
10893: PUSH
10894: LD_INT 0
10896: EQUAL
10897: PUSH
10898: LD_INT 7
10900: PPUSH
10901: LD_INT 3
10903: PPUSH
10904: LD_INT 1
10906: PPUSH
10907: CALL 13992 0 3
10911: PUSH
10912: LD_INT 0
10914: EQUAL
10915: AND
10916: IFFALSE 10928
10918: GO 10920
10920: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
10921: LD_STRING M1a
10923: PPUSH
10924: CALL_OW 337
// end ;
10928: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 ;
10929: LD_INT 22
10931: PUSH
10932: LD_INT 2
10934: PUSH
10935: EMPTY
10936: LIST
10937: LIST
10938: PUSH
10939: LD_INT 21
10941: PUSH
10942: LD_INT 1
10944: PUSH
10945: EMPTY
10946: LIST
10947: LIST
10948: PUSH
10949: EMPTY
10950: LIST
10951: LIST
10952: PPUSH
10953: CALL_OW 69
10957: PUSH
10958: LD_INT 0
10960: EQUAL
10961: PUSH
10962: LD_INT 22
10964: PUSH
10965: LD_INT 3
10967: PUSH
10968: EMPTY
10969: LIST
10970: LIST
10971: PUSH
10972: LD_INT 21
10974: PUSH
10975: LD_INT 1
10977: PUSH
10978: EMPTY
10979: LIST
10980: LIST
10981: PUSH
10982: EMPTY
10983: LIST
10984: LIST
10985: PPUSH
10986: CALL_OW 69
10990: PUSH
10991: LD_INT 0
10993: EQUAL
10994: AND
10995: PUSH
10996: LD_INT 22
10998: PUSH
10999: LD_INT 1
11001: PUSH
11002: EMPTY
11003: LIST
11004: LIST
11005: PPUSH
11006: CALL_OW 69
11010: PUSH
11011: LD_INT 0
11013: EQUAL
11014: AND
11015: PUSH
11016: LD_INT 7
11018: PPUSH
11019: LD_INT 1
11021: PPUSH
11022: LD_INT 1
11024: PPUSH
11025: CALL 13992 0 3
11029: PUSH
11030: LD_INT 0
11032: EQUAL
11033: AND
11034: PUSH
11035: LD_INT 7
11037: PPUSH
11038: LD_INT 3
11040: PPUSH
11041: LD_INT 1
11043: PPUSH
11044: CALL 13992 0 3
11048: PUSH
11049: LD_INT 0
11051: EQUAL
11052: AND
11053: IFFALSE 12397
11055: GO 11057
11057: DISABLE
11058: LD_INT 0
11060: PPUSH
11061: PPUSH
11062: PPUSH
// begin wait ( 0 0$3 ) ;
11063: LD_INT 105
11065: PPUSH
11066: CALL_OW 67
// if not IsDead ( Masha ) then
11070: LD_EXP 48
11074: PPUSH
11075: CALL_OW 301
11079: NOT
11080: IFFALSE 11094
// AddMedal ( Masha , 1 ) else
11082: LD_STRING Masha
11084: PPUSH
11085: LD_INT 1
11087: PPUSH
11088: CALL_OW 101
11092: GO 11105
// AddMedal ( Masha , - 1 ) ;
11094: LD_STRING Masha
11096: PPUSH
11097: LD_INT 1
11099: NEG
11100: PPUSH
11101: CALL_OW 101
// if abdul_escaped then
11105: LD_EXP 12
11109: IFFALSE 11124
// AddMedal ( Abdul , - 1 ) else
11111: LD_STRING Abdul
11113: PPUSH
11114: LD_INT 1
11116: NEG
11117: PPUSH
11118: CALL_OW 101
11122: GO 11134
// AddMedal ( Abdul , 1 ) ;
11124: LD_STRING Abdul
11126: PPUSH
11127: LD_INT 1
11129: PPUSH
11130: CALL_OW 101
// if loss_counter = 0 then
11134: LD_EXP 13
11138: PUSH
11139: LD_INT 0
11141: EQUAL
11142: IFFALSE 11156
// AddMedal ( People , 2 ) else
11144: LD_STRING People
11146: PPUSH
11147: LD_INT 2
11149: PPUSH
11150: CALL_OW 101
11154: GO 11206
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11156: LD_EXP 13
11160: PUSH
11161: LD_INT 3
11163: PUSH
11164: LD_INT 2
11166: PUSH
11167: LD_INT 2
11169: PUSH
11170: EMPTY
11171: LIST
11172: LIST
11173: LIST
11174: PUSH
11175: LD_OWVAR 67
11179: ARRAY
11180: LESSEQUAL
11181: IFFALSE 11195
// AddMedal ( People , 1 ) else
11183: LD_STRING People
11185: PPUSH
11186: LD_INT 1
11188: PPUSH
11189: CALL_OW 101
11193: GO 11206
// AddMedal ( People , - 1 ) ;
11195: LD_STRING People
11197: PPUSH
11198: LD_INT 1
11200: NEG
11201: PPUSH
11202: CALL_OW 101
// GiveMedals ( MAIN ) ;
11206: LD_STRING MAIN
11208: PPUSH
11209: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11213: LD_ADDR_VAR 0 2
11217: PUSH
11218: LD_INT 22
11220: PUSH
11221: LD_INT 7
11223: PUSH
11224: EMPTY
11225: LIST
11226: LIST
11227: PUSH
11228: LD_INT 2
11230: PUSH
11231: LD_INT 25
11233: PUSH
11234: LD_INT 1
11236: PUSH
11237: EMPTY
11238: LIST
11239: LIST
11240: PUSH
11241: LD_INT 25
11243: PUSH
11244: LD_INT 2
11246: PUSH
11247: EMPTY
11248: LIST
11249: LIST
11250: PUSH
11251: LD_INT 25
11253: PUSH
11254: LD_INT 3
11256: PUSH
11257: EMPTY
11258: LIST
11259: LIST
11260: PUSH
11261: LD_INT 25
11263: PUSH
11264: LD_INT 4
11266: PUSH
11267: EMPTY
11268: LIST
11269: LIST
11270: PUSH
11271: LD_INT 25
11273: PUSH
11274: LD_INT 5
11276: PUSH
11277: EMPTY
11278: LIST
11279: LIST
11280: PUSH
11281: LD_INT 25
11283: PUSH
11284: LD_INT 8
11286: PUSH
11287: EMPTY
11288: LIST
11289: LIST
11290: PUSH
11291: LD_INT 25
11293: PUSH
11294: LD_INT 9
11296: PUSH
11297: EMPTY
11298: LIST
11299: LIST
11300: PUSH
11301: EMPTY
11302: LIST
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: LIST
11308: LIST
11309: LIST
11310: PUSH
11311: EMPTY
11312: LIST
11313: LIST
11314: PPUSH
11315: CALL_OW 69
11319: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11320: LD_VAR 0 2
11324: PPUSH
11325: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11329: LD_ADDR_VAR 0 3
11333: PUSH
11334: LD_EXP 14
11338: PUSH
11339: LD_EXP 15
11343: PUSH
11344: LD_EXP 16
11348: PUSH
11349: LD_EXP 17
11353: PUSH
11354: LD_EXP 18
11358: PUSH
11359: LD_EXP 19
11363: PUSH
11364: LD_EXP 20
11368: PUSH
11369: LD_EXP 21
11373: PUSH
11374: LD_EXP 22
11378: PUSH
11379: LD_EXP 23
11383: PUSH
11384: LD_EXP 24
11388: PUSH
11389: LD_EXP 25
11393: PUSH
11394: LD_EXP 26
11398: PUSH
11399: LD_EXP 27
11403: PUSH
11404: LD_EXP 28
11408: PUSH
11409: LD_EXP 29
11413: PUSH
11414: LD_EXP 30
11418: PUSH
11419: LD_EXP 31
11423: PUSH
11424: LD_EXP 32
11428: PUSH
11429: LD_EXP 33
11433: PUSH
11434: LD_EXP 35
11438: PUSH
11439: LD_EXP 36
11443: PUSH
11444: LD_EXP 37
11448: PUSH
11449: LD_EXP 38
11453: PUSH
11454: LD_EXP 39
11458: PUSH
11459: LD_EXP 40
11463: PUSH
11464: LD_EXP 41
11468: PUSH
11469: LD_EXP 42
11473: PUSH
11474: LD_EXP 43
11478: PUSH
11479: LD_EXP 44
11483: PUSH
11484: LD_EXP 45
11488: PUSH
11489: LD_EXP 46
11493: PUSH
11494: LD_EXP 47
11498: PUSH
11499: EMPTY
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: ST_TO_ADDR
// if tmp diff tmp2 then
11534: LD_VAR 0 2
11538: PUSH
11539: LD_VAR 0 3
11543: DIFF
11544: IFFALSE 11564
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11546: LD_VAR 0 2
11550: PUSH
11551: LD_VAR 0 3
11555: DIFF
11556: PPUSH
11557: LD_STRING 13a_others
11559: PPUSH
11560: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11564: LD_EXP 14
11568: PPUSH
11569: LD_STRING 13a_JMM
11571: PPUSH
11572: CALL_OW 38
// if Titov then
11576: LD_EXP 33
11580: IFFALSE 11594
// SaveCharacters ( Titov , 13a_Titov ) ;
11582: LD_EXP 33
11586: PPUSH
11587: LD_STRING 13a_Titov
11589: PPUSH
11590: CALL_OW 38
// if Dolgov then
11594: LD_EXP 35
11598: IFFALSE 11612
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11600: LD_EXP 35
11604: PPUSH
11605: LD_STRING 13a_Dolgov
11607: PPUSH
11608: CALL_OW 38
// if Petrosyan then
11612: LD_EXP 36
11616: IFFALSE 11630
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11618: LD_EXP 36
11622: PPUSH
11623: LD_STRING 13a_Petrosyan
11625: PPUSH
11626: CALL_OW 38
// if Scholtze then
11630: LD_EXP 37
11634: IFFALSE 11648
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11636: LD_EXP 37
11640: PPUSH
11641: LD_STRING 13a_Scholtze
11643: PPUSH
11644: CALL_OW 38
// if Oblukov then
11648: LD_EXP 38
11652: IFFALSE 11666
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11654: LD_EXP 38
11658: PPUSH
11659: LD_STRING 13a_Oblukov
11661: PPUSH
11662: CALL_OW 38
// if Kapitsova then
11666: LD_EXP 39
11670: IFFALSE 11684
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11672: LD_EXP 39
11676: PPUSH
11677: LD_STRING 13a_Kapitsova
11679: PPUSH
11680: CALL_OW 38
// if Lipshchin then
11684: LD_EXP 40
11688: IFFALSE 11702
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11690: LD_EXP 40
11694: PPUSH
11695: LD_STRING 13a_Lipshchin
11697: PPUSH
11698: CALL_OW 38
// if Petrovova then
11702: LD_EXP 41
11706: IFFALSE 11720
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11708: LD_EXP 41
11712: PPUSH
11713: LD_STRING 13a_Petrovova
11715: PPUSH
11716: CALL_OW 38
// if Kovalyuk then
11720: LD_EXP 42
11724: IFFALSE 11738
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11726: LD_EXP 42
11730: PPUSH
11731: LD_STRING 13a_Kovalyuk
11733: PPUSH
11734: CALL_OW 38
// if Kuzmov then
11738: LD_EXP 43
11742: IFFALSE 11756
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11744: LD_EXP 43
11748: PPUSH
11749: LD_STRING 13a_Kuzmov
11751: PPUSH
11752: CALL_OW 38
// if Karamazov then
11756: LD_EXP 44
11760: IFFALSE 11774
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11762: LD_EXP 44
11766: PPUSH
11767: LD_STRING 13a_Karamazov
11769: PPUSH
11770: CALL_OW 38
// if Burlak then
11774: LD_EXP 45
11778: IFFALSE 11792
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11780: LD_EXP 45
11784: PPUSH
11785: LD_STRING 13a_Burlak
11787: PPUSH
11788: CALL_OW 38
// if Belkov then
11792: LD_EXP 46
11796: IFFALSE 11810
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11798: LD_EXP 46
11802: PPUSH
11803: LD_STRING 13a_Belkov
11805: PPUSH
11806: CALL_OW 38
// if Gnyevko then
11810: LD_EXP 47
11814: IFFALSE 11828
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11816: LD_EXP 47
11820: PPUSH
11821: LD_STRING 13a_Gnyevko
11823: PPUSH
11824: CALL_OW 38
// if Lisa then
11828: LD_EXP 16
11832: IFFALSE 11846
// SaveCharacters ( Lisa , 13a_Lisa ) ;
11834: LD_EXP 16
11838: PPUSH
11839: LD_STRING 13a_Lisa
11841: PPUSH
11842: CALL_OW 38
// if Donaldson then
11846: LD_EXP 17
11850: IFFALSE 11864
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
11852: LD_EXP 17
11856: PPUSH
11857: LD_STRING 13a_Donaldson
11859: PPUSH
11860: CALL_OW 38
// if Bobby then
11864: LD_EXP 18
11868: IFFALSE 11882
// SaveCharacters ( Bobby , 13a_Bobby ) ;
11870: LD_EXP 18
11874: PPUSH
11875: LD_STRING 13a_Bobby
11877: PPUSH
11878: CALL_OW 38
// if Cyrus then
11882: LD_EXP 19
11886: IFFALSE 11900
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
11888: LD_EXP 19
11892: PPUSH
11893: LD_STRING 13a_Cyrus
11895: PPUSH
11896: CALL_OW 38
// if Denis then
11900: LD_EXP 20
11904: IFFALSE 11918
// SaveCharacters ( Denis , 13a_Denis ) ;
11906: LD_EXP 20
11910: PPUSH
11911: LD_STRING 13a_Denis
11913: PPUSH
11914: CALL_OW 38
// if Brown then
11918: LD_EXP 21
11922: IFFALSE 11936
// SaveCharacters ( Brown , 13a_Brown ) ;
11924: LD_EXP 21
11928: PPUSH
11929: LD_STRING 13a_Brown
11931: PPUSH
11932: CALL_OW 38
// if Gladstone then
11936: LD_EXP 22
11940: IFFALSE 11954
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
11942: LD_EXP 22
11946: PPUSH
11947: LD_STRING 13a_Gladstone
11949: PPUSH
11950: CALL_OW 38
// if Houten then
11954: LD_EXP 23
11958: IFFALSE 11972
// SaveCharacters ( Houten , 13a_Houten ) ;
11960: LD_EXP 23
11964: PPUSH
11965: LD_STRING 13a_Houten
11967: PPUSH
11968: CALL_OW 38
// if Cornel then
11972: LD_EXP 24
11976: IFFALSE 11990
// SaveCharacters ( Cornel , 13a_Cornel ) ;
11978: LD_EXP 24
11982: PPUSH
11983: LD_STRING 13a_Cornel
11985: PPUSH
11986: CALL_OW 38
// if Gary then
11990: LD_EXP 25
11994: IFFALSE 12008
// SaveCharacters ( Gary , 13a_Gary ) ;
11996: LD_EXP 25
12000: PPUSH
12001: LD_STRING 13a_Gary
12003: PPUSH
12004: CALL_OW 38
// if Frank then
12008: LD_EXP 26
12012: IFFALSE 12026
// SaveCharacters ( Frank , 13a_Frank ) ;
12014: LD_EXP 26
12018: PPUSH
12019: LD_STRING 13a_Frank
12021: PPUSH
12022: CALL_OW 38
// if Kikuchi then
12026: LD_EXP 27
12030: IFFALSE 12044
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12032: LD_EXP 27
12036: PPUSH
12037: LD_STRING 13a_Kikuchi
12039: PPUSH
12040: CALL_OW 38
// if Simms then
12044: LD_EXP 28
12048: IFFALSE 12062
// SaveCharacters ( Simms , 13a_Simms ) ;
12050: LD_EXP 28
12054: PPUSH
12055: LD_STRING 13a_Simms
12057: PPUSH
12058: CALL_OW 38
// if Joan then
12062: LD_EXP 29
12066: IFFALSE 12080
// SaveCharacters ( Joan , 13a_Joan ) ;
12068: LD_EXP 29
12072: PPUSH
12073: LD_STRING 13a_Joan
12075: PPUSH
12076: CALL_OW 38
// if DeltaDoctor then
12080: LD_EXP 30
12084: IFFALSE 12098
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12086: LD_EXP 30
12090: PPUSH
12091: LD_STRING 13a_DeltaDoctor
12093: PPUSH
12094: CALL_OW 38
// if Gossudarov then
12098: LD_EXP 31
12102: IFFALSE 12116
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12104: LD_EXP 31
12108: PPUSH
12109: LD_STRING 13a_Gossudarov
12111: PPUSH
12112: CALL_OW 38
// if Kirilenkova then
12116: LD_EXP 32
12120: IFFALSE 12134
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12122: LD_EXP 32
12126: PPUSH
12127: LD_STRING 13a_Kirilenkova
12129: PPUSH
12130: CALL_OW 38
// if Masha then
12134: LD_EXP 48
12138: IFFALSE 12193
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12140: LD_EXP 48
12144: PPUSH
12145: CALL_OW 265
12149: PUSH
12150: LD_EXP 48
12154: PPUSH
12155: CALL_OW 262
12159: PUSH
12160: LD_EXP 48
12164: PPUSH
12165: CALL_OW 263
12169: PUSH
12170: LD_EXP 48
12174: PPUSH
12175: CALL_OW 264
12179: PUSH
12180: EMPTY
12181: LIST
12182: LIST
12183: LIST
12184: LIST
12185: PPUSH
12186: LD_STRING 13a_Masha
12188: PPUSH
12189: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12193: LD_ADDR_VAR 0 2
12197: PUSH
12198: LD_INT 21
12200: PUSH
12201: LD_INT 3
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PPUSH
12208: CALL_OW 69
12212: ST_TO_ADDR
// tmp2 := [ ] ;
12213: LD_ADDR_VAR 0 3
12217: PUSH
12218: EMPTY
12219: ST_TO_ADDR
// if tmp then
12220: LD_VAR 0 2
12224: IFFALSE 12375
// for i in tmp do
12226: LD_ADDR_VAR 0 1
12230: PUSH
12231: LD_VAR 0 2
12235: PUSH
12236: FOR_IN
12237: IFFALSE 12373
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12239: LD_ADDR_VAR 0 3
12243: PUSH
12244: LD_VAR 0 3
12248: PUSH
12249: LD_VAR 0 1
12253: PPUSH
12254: CALL_OW 255
12258: PUSH
12259: LD_VAR 0 1
12263: PPUSH
12264: CALL_OW 248
12268: PUSH
12269: LD_VAR 0 1
12273: PPUSH
12274: CALL_OW 266
12278: PUSH
12279: LD_VAR 0 1
12283: PPUSH
12284: CALL_OW 250
12288: PUSH
12289: LD_VAR 0 1
12293: PPUSH
12294: CALL_OW 251
12298: PUSH
12299: LD_VAR 0 1
12303: PPUSH
12304: CALL_OW 254
12308: PUSH
12309: LD_VAR 0 1
12313: PPUSH
12314: CALL_OW 267
12318: PUSH
12319: LD_VAR 0 1
12323: PPUSH
12324: LD_INT 1
12326: PPUSH
12327: CALL_OW 268
12331: PUSH
12332: LD_VAR 0 1
12336: PPUSH
12337: LD_INT 2
12339: PPUSH
12340: CALL_OW 268
12344: PUSH
12345: LD_VAR 0 1
12349: PPUSH
12350: CALL_OW 269
12354: PUSH
12355: EMPTY
12356: LIST
12357: LIST
12358: LIST
12359: LIST
12360: LIST
12361: LIST
12362: LIST
12363: LIST
12364: LIST
12365: LIST
12366: PUSH
12367: EMPTY
12368: LIST
12369: ADD
12370: ST_TO_ADDR
12371: GO 12236
12373: POP
12374: POP
// if tmp2 then
12375: LD_VAR 0 3
12379: IFFALSE 12393
// SaveVariable ( tmp2 , 13a_buildings ) ;
12381: LD_VAR 0 3
12385: PPUSH
12386: LD_STRING 13a_buildings
12388: PPUSH
12389: CALL_OW 39
// YouWin ;
12393: CALL_OW 103
// end ;
12397: PPOPN 3
12399: END
// export function SciRu ; var tmp , t ; begin
12400: LD_INT 0
12402: PPUSH
12403: PPUSH
12404: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12405: LD_ADDR_VAR 0 3
12409: PUSH
12410: LD_EXP 31
12414: PUSH
12415: LD_EXP 45
12419: PUSH
12420: LD_EXP 33
12424: PUSH
12425: LD_EXP 46
12429: PUSH
12430: LD_EXP 47
12434: PUSH
12435: LD_EXP 36
12439: PUSH
12440: LD_EXP 37
12444: PUSH
12445: LD_EXP 35
12449: PUSH
12450: EMPTY
12451: LIST
12452: LIST
12453: LIST
12454: LIST
12455: LIST
12456: LIST
12457: LIST
12458: LIST
12459: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12460: LD_ADDR_VAR 0 2
12464: PUSH
12465: LD_INT 22
12467: PUSH
12468: LD_INT 7
12470: PUSH
12471: EMPTY
12472: LIST
12473: LIST
12474: PUSH
12475: LD_INT 23
12477: PUSH
12478: LD_INT 3
12480: PUSH
12481: EMPTY
12482: LIST
12483: LIST
12484: PUSH
12485: LD_INT 25
12487: PUSH
12488: LD_INT 4
12490: PUSH
12491: EMPTY
12492: LIST
12493: LIST
12494: PUSH
12495: LD_INT 26
12497: PUSH
12498: LD_INT 1
12500: PUSH
12501: EMPTY
12502: LIST
12503: LIST
12504: PUSH
12505: EMPTY
12506: LIST
12507: LIST
12508: LIST
12509: LIST
12510: PPUSH
12511: CALL_OW 69
12515: PUSH
12516: LD_VAR 0 3
12520: DIFF
12521: ST_TO_ADDR
// if tmp then
12522: LD_VAR 0 2
12526: IFFALSE 12542
// result := tmp [ 1 ] ;
12528: LD_ADDR_VAR 0 1
12532: PUSH
12533: LD_VAR 0 2
12537: PUSH
12538: LD_INT 1
12540: ARRAY
12541: ST_TO_ADDR
// end ;
12542: LD_VAR 0 1
12546: RET
// export function SolRu ; var tmp , t ; begin
12547: LD_INT 0
12549: PPUSH
12550: PPUSH
12551: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12552: LD_ADDR_VAR 0 3
12556: PUSH
12557: LD_EXP 31
12561: PUSH
12562: LD_EXP 45
12566: PUSH
12567: LD_EXP 33
12571: PUSH
12572: LD_EXP 46
12576: PUSH
12577: LD_EXP 47
12581: PUSH
12582: LD_EXP 36
12586: PUSH
12587: LD_EXP 37
12591: PUSH
12592: LD_EXP 35
12596: PUSH
12597: EMPTY
12598: LIST
12599: LIST
12600: LIST
12601: LIST
12602: LIST
12603: LIST
12604: LIST
12605: LIST
12606: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12607: LD_ADDR_VAR 0 2
12611: PUSH
12612: LD_INT 22
12614: PUSH
12615: LD_INT 7
12617: PUSH
12618: EMPTY
12619: LIST
12620: LIST
12621: PUSH
12622: LD_INT 23
12624: PUSH
12625: LD_INT 3
12627: PUSH
12628: EMPTY
12629: LIST
12630: LIST
12631: PUSH
12632: LD_INT 25
12634: PUSH
12635: LD_INT 1
12637: PUSH
12638: EMPTY
12639: LIST
12640: LIST
12641: PUSH
12642: LD_INT 26
12644: PUSH
12645: LD_INT 1
12647: PUSH
12648: EMPTY
12649: LIST
12650: LIST
12651: PUSH
12652: EMPTY
12653: LIST
12654: LIST
12655: LIST
12656: LIST
12657: PPUSH
12658: CALL_OW 69
12662: PUSH
12663: LD_VAR 0 3
12667: DIFF
12668: ST_TO_ADDR
// if tmp then
12669: LD_VAR 0 2
12673: IFFALSE 12689
// result := tmp [ 1 ] ;
12675: LD_ADDR_VAR 0 1
12679: PUSH
12680: LD_VAR 0 2
12684: PUSH
12685: LD_INT 1
12687: ARRAY
12688: ST_TO_ADDR
// end ; end_of_file
12689: LD_VAR 0 1
12693: RET
// export function CustomEvent ( event ) ; begin
12694: LD_INT 0
12696: PPUSH
// end ;
12697: LD_VAR 0 2
12701: RET
// on UnitDestroyed ( un ) do var i , side ;
12702: LD_INT 0
12704: PPUSH
12705: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12706: LD_VAR 0 1
12710: PUSH
12711: LD_INT 22
12713: PUSH
12714: LD_INT 7
12716: PUSH
12717: EMPTY
12718: LIST
12719: LIST
12720: PUSH
12721: LD_INT 2
12723: PUSH
12724: LD_INT 25
12726: PUSH
12727: LD_INT 1
12729: PUSH
12730: EMPTY
12731: LIST
12732: LIST
12733: PUSH
12734: LD_INT 25
12736: PUSH
12737: LD_INT 2
12739: PUSH
12740: EMPTY
12741: LIST
12742: LIST
12743: PUSH
12744: LD_INT 25
12746: PUSH
12747: LD_INT 3
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PUSH
12754: LD_INT 25
12756: PUSH
12757: LD_INT 4
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: LD_INT 25
12766: PUSH
12767: LD_INT 5
12769: PUSH
12770: EMPTY
12771: LIST
12772: LIST
12773: PUSH
12774: LD_INT 25
12776: PUSH
12777: LD_INT 8
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: PUSH
12784: LD_INT 25
12786: PUSH
12787: LD_INT 9
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: EMPTY
12795: LIST
12796: LIST
12797: LIST
12798: LIST
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: PUSH
12804: EMPTY
12805: LIST
12806: LIST
12807: PPUSH
12808: CALL_OW 69
12812: IN
12813: IFFALSE 12829
// loss_counter := loss_counter + 1 ;
12815: LD_ADDR_EXP 13
12819: PUSH
12820: LD_EXP 13
12824: PUSH
12825: LD_INT 1
12827: PLUS
12828: ST_TO_ADDR
// if un = Abdul then
12829: LD_VAR 0 1
12833: PUSH
12834: LD_EXP 54
12838: EQUAL
12839: IFFALSE 12849
// abdul_escaped := false ;
12841: LD_ADDR_EXP 12
12845: PUSH
12846: LD_INT 0
12848: ST_TO_ADDR
// if un in ru_attackers then
12849: LD_VAR 0 1
12853: PUSH
12854: LD_EXP 51
12858: IN
12859: IFFALSE 12877
// ru_attackers := ru_attackers diff un ;
12861: LD_ADDR_EXP 51
12865: PUSH
12866: LD_EXP 51
12870: PUSH
12871: LD_VAR 0 1
12875: DIFF
12876: ST_TO_ADDR
// if un in ar_attackers then
12877: LD_VAR 0 1
12881: PUSH
12882: LD_EXP 10
12886: IN
12887: IFFALSE 12905
// ar_attackers := ar_attackers diff un ;
12889: LD_ADDR_EXP 10
12893: PUSH
12894: LD_EXP 10
12898: PUSH
12899: LD_VAR 0 1
12903: DIFF
12904: ST_TO_ADDR
// if un = JMM then
12905: LD_VAR 0 1
12909: PUSH
12910: LD_EXP 14
12914: EQUAL
12915: IFFALSE 12926
// begin YouLost ( JMM ) ;
12917: LD_STRING JMM
12919: PPUSH
12920: CALL_OW 104
// exit ;
12924: GO 13015
// end ; if un = Burlak then
12926: LD_VAR 0 1
12930: PUSH
12931: LD_EXP 45
12935: EQUAL
12936: IFFALSE 12947
// begin YouLost ( Burlak ) ;
12938: LD_STRING Burlak
12940: PPUSH
12941: CALL_OW 104
// exit ;
12945: GO 13015
// end ; if un = freedom then
12947: LD_VAR 0 1
12951: PUSH
12952: LD_EXP 3
12956: EQUAL
12957: IFFALSE 12968
// begin YouLost ( Destroyed ) ;
12959: LD_STRING Destroyed
12961: PPUSH
12962: CALL_OW 104
// exit ;
12966: GO 13015
// end ; if un = Masha then
12968: LD_VAR 0 1
12972: PUSH
12973: LD_EXP 48
12977: EQUAL
12978: IFFALSE 12987
// ChangeMissionObjectives ( M4b ) ;
12980: LD_STRING M4b
12982: PPUSH
12983: CALL_OW 337
// if un = Mastodont then
12987: LD_VAR 0 1
12991: PUSH
12992: LD_EXP 55
12996: EQUAL
12997: IFFALSE 13006
// ChangeMissionObjectives ( M4a ) ;
12999: LD_STRING M4a
13001: PPUSH
13002: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13006: LD_VAR 0 1
13010: PPUSH
13011: CALL 83044 0 1
// end ;
13015: PPOPN 3
13017: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13018: LD_VAR 0 1
13022: PPUSH
13023: LD_VAR 0 2
13027: PPUSH
13028: CALL 85099 0 2
// end ;
13032: PPOPN 2
13034: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13035: LD_VAR 0 1
13039: PPUSH
13040: CALL 84167 0 1
// end ;
13044: PPOPN 1
13046: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13047: LD_VAR 0 1
13051: PUSH
13052: LD_INT 22
13054: PUSH
13055: LD_INT 7
13057: PUSH
13058: EMPTY
13059: LIST
13060: LIST
13061: PUSH
13062: LD_INT 30
13064: PUSH
13065: LD_INT 0
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: PPUSH
13076: CALL_OW 69
13080: IN
13081: IFFALSE 13120
// begin SetBName ( building , freedom ) ;
13083: LD_VAR 0 1
13087: PPUSH
13088: LD_STRING freedom
13090: PPUSH
13091: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13095: LD_INT 0
13097: PPUSH
13098: LD_INT 7
13100: PPUSH
13101: LD_INT 0
13103: PPUSH
13104: CALL_OW 324
// freedom := building ;
13108: LD_ADDR_EXP 3
13112: PUSH
13113: LD_VAR 0 1
13117: ST_TO_ADDR
// exit ;
13118: GO 13186
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13120: LD_VAR 0 1
13124: PUSH
13125: LD_INT 22
13127: PUSH
13128: LD_INT 7
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: PUSH
13135: LD_INT 23
13137: PUSH
13138: LD_INT 3
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: PUSH
13145: LD_INT 30
13147: PUSH
13148: LD_INT 6
13150: PUSH
13151: EMPTY
13152: LIST
13153: LIST
13154: PUSH
13155: EMPTY
13156: LIST
13157: LIST
13158: LIST
13159: PPUSH
13160: CALL_OW 69
13164: IN
13165: IFFALSE 13177
// begin ru_lab_builded := true ;
13167: LD_ADDR_EXP 5
13171: PUSH
13172: LD_INT 1
13174: ST_TO_ADDR
// exit ;
13175: GO 13186
// end ; MCE_BuildingComplete ( building ) ;
13177: LD_VAR 0 1
13181: PPUSH
13182: CALL 84408 0 1
// end ;
13186: PPOPN 1
13188: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13189: LD_VAR 0 1
13193: PPUSH
13194: LD_VAR 0 2
13198: PPUSH
13199: CALL 82740 0 2
// end ;
13203: PPOPN 2
13205: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13206: LD_VAR 0 1
13210: PPUSH
13211: LD_VAR 0 2
13215: PPUSH
13216: LD_VAR 0 3
13220: PPUSH
13221: LD_VAR 0 4
13225: PPUSH
13226: LD_VAR 0 5
13230: PPUSH
13231: CALL 82360 0 5
// end ;
13235: PPOPN 5
13237: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13238: LD_VAR 0 1
13242: PPUSH
13243: LD_VAR 0 2
13247: PPUSH
13248: CALL 81956 0 2
// end ;
13252: PPOPN 2
13254: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13255: LD_VAR 0 1
13259: PPUSH
13260: LD_VAR 0 2
13264: PPUSH
13265: LD_VAR 0 3
13269: PPUSH
13270: LD_VAR 0 4
13274: PPUSH
13275: CALL 81794 0 4
// end ;
13279: PPOPN 4
13281: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13282: LD_VAR 0 1
13286: PPUSH
13287: LD_VAR 0 2
13291: PPUSH
13292: LD_VAR 0 3
13296: PPUSH
13297: CALL 81569 0 3
// end ;
13301: PPOPN 3
13303: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13304: LD_VAR 0 1
13308: PPUSH
13309: LD_VAR 0 2
13313: PPUSH
13314: CALL 81454 0 2
// end ;
13318: PPOPN 2
13320: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13321: LD_VAR 0 1
13325: PPUSH
13326: LD_VAR 0 2
13330: PPUSH
13331: CALL 85360 0 2
// end ;
13335: PPOPN 2
13337: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13338: LD_VAR 0 1
13342: PPUSH
13343: LD_VAR 0 2
13347: PPUSH
13348: LD_VAR 0 3
13352: PPUSH
13353: LD_VAR 0 4
13357: PPUSH
13358: CALL 85576 0 4
// end ;
13362: PPOPN 4
13364: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13365: LD_VAR 0 1
13369: PPUSH
13370: LD_VAR 0 2
13374: PPUSH
13375: CALL 81263 0 2
// end ;
13379: PPOPN 2
13381: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13382: LD_VAR 0 1
13386: PPUSH
13387: CALL 85859 0 1
// end ; end_of_file
13391: PPOPN 1
13393: END
// every 0 0$30 do var cr , time ;
13394: GO 13396
13396: DISABLE
13397: LD_INT 0
13399: PPUSH
13400: PPUSH
// begin time := 0 0$30 ;
13401: LD_ADDR_VAR 0 2
13405: PUSH
13406: LD_INT 1050
13408: ST_TO_ADDR
// while game do
13409: LD_EXP 2
13413: IFFALSE 13512
// begin wait ( time ) ;
13415: LD_VAR 0 2
13419: PPUSH
13420: CALL_OW 67
// if tick > 2 2$00 then
13424: LD_OWVAR 1
13428: PUSH
13429: LD_INT 4200
13431: GREATER
13432: IFFALSE 13465
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13434: LD_ADDR_VAR 0 2
13438: PUSH
13439: LD_VAR 0 2
13443: PUSH
13444: LD_INT 280
13446: PUSH
13447: LD_INT 420
13449: PUSH
13450: LD_INT 630
13452: PUSH
13453: EMPTY
13454: LIST
13455: LIST
13456: LIST
13457: PUSH
13458: LD_OWVAR 67
13462: ARRAY
13463: PLUS
13464: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13465: LD_INT 1
13467: PPUSH
13468: LD_INT 5
13470: PPUSH
13471: CALL_OW 12
13475: PPUSH
13476: LD_INT 70
13478: PPUSH
13479: LD_INT 49
13481: PPUSH
13482: LD_INT 25
13484: PPUSH
13485: LD_INT 1
13487: PPUSH
13488: CALL_OW 56
// if time > 5 5$00 then
13492: LD_VAR 0 2
13496: PUSH
13497: LD_INT 10500
13499: GREATER
13500: IFFALSE 13510
// time := 0 0$30 ;
13502: LD_ADDR_VAR 0 2
13506: PUSH
13507: LD_INT 1050
13509: ST_TO_ADDR
// end ;
13510: GO 13409
// end ;
13512: PPOPN 2
13514: END
// every 0 0$30 do var cr , time ;
13515: GO 13517
13517: DISABLE
13518: LD_INT 0
13520: PPUSH
13521: PPUSH
// begin time := 0 0$20 ;
13522: LD_ADDR_VAR 0 2
13526: PUSH
13527: LD_INT 700
13529: ST_TO_ADDR
// while game do
13530: LD_EXP 2
13534: IFFALSE 13623
// begin wait ( time ) ;
13536: LD_VAR 0 2
13540: PPUSH
13541: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13545: LD_ADDR_VAR 0 2
13549: PUSH
13550: LD_VAR 0 2
13554: PUSH
13555: LD_INT 490
13557: PUSH
13558: LD_INT 525
13560: PUSH
13561: LD_INT 560
13563: PUSH
13564: EMPTY
13565: LIST
13566: LIST
13567: LIST
13568: PUSH
13569: LD_OWVAR 67
13573: ARRAY
13574: PLUS
13575: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13576: LD_INT 3
13578: PPUSH
13579: LD_INT 5
13581: PPUSH
13582: CALL_OW 12
13586: PPUSH
13587: LD_INT 26
13589: PPUSH
13590: LD_INT 9
13592: PPUSH
13593: LD_INT 30
13595: PPUSH
13596: LD_INT 1
13598: PPUSH
13599: CALL_OW 56
// if time > 3 3$00 then
13603: LD_VAR 0 2
13607: PUSH
13608: LD_INT 6300
13610: GREATER
13611: IFFALSE 13621
// time := 0 0$20 ;
13613: LD_ADDR_VAR 0 2
13617: PUSH
13618: LD_INT 700
13620: ST_TO_ADDR
// end ;
13621: GO 13530
// end ;
13623: PPOPN 2
13625: END
// every 0 0$30 do var cr , time ;
13626: GO 13628
13628: DISABLE
13629: LD_INT 0
13631: PPUSH
13632: PPUSH
// begin time := 0 0$20 ;
13633: LD_ADDR_VAR 0 2
13637: PUSH
13638: LD_INT 700
13640: ST_TO_ADDR
// while game do
13641: LD_EXP 2
13645: IFFALSE 13770
// begin wait ( time ) ;
13647: LD_VAR 0 2
13651: PPUSH
13652: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13656: LD_ADDR_VAR 0 2
13660: PUSH
13661: LD_VAR 0 2
13665: PUSH
13666: LD_INT 175
13668: PUSH
13669: LD_INT 210
13671: PUSH
13672: LD_INT 280
13674: PUSH
13675: EMPTY
13676: LIST
13677: LIST
13678: LIST
13679: PUSH
13680: LD_OWVAR 67
13684: ARRAY
13685: PLUS
13686: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13687: LD_INT 1
13689: PPUSH
13690: LD_INT 5
13692: PPUSH
13693: CALL_OW 12
13697: PPUSH
13698: LD_INT 179
13700: PPUSH
13701: LD_INT 101
13703: PPUSH
13704: LD_INT 20
13706: PPUSH
13707: LD_INT 1
13709: PPUSH
13710: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13714: LD_INT 350
13716: PPUSH
13717: LD_INT 525
13719: PPUSH
13720: CALL_OW 12
13724: PPUSH
13725: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13729: LD_INT 1
13731: PPUSH
13732: LD_INT 5
13734: PPUSH
13735: CALL_OW 12
13739: PPUSH
13740: LD_INT 9
13742: PPUSH
13743: LD_INT 1
13745: PPUSH
13746: CALL_OW 55
// if time > 4 4$00 then
13750: LD_VAR 0 2
13754: PUSH
13755: LD_INT 8400
13757: GREATER
13758: IFFALSE 13768
// time := 0 0$30 ;
13760: LD_ADDR_VAR 0 2
13764: PUSH
13765: LD_INT 1050
13767: ST_TO_ADDR
// end ;
13768: GO 13641
// end ;
13770: PPOPN 2
13772: END
// every 0 0$30 do var cr , time ;
13773: GO 13775
13775: DISABLE
13776: LD_INT 0
13778: PPUSH
13779: PPUSH
// begin time := 0 0$10 ;
13780: LD_ADDR_VAR 0 2
13784: PUSH
13785: LD_INT 350
13787: ST_TO_ADDR
// while game do
13788: LD_EXP 2
13792: IFFALSE 13926
// begin wait ( time ) ;
13794: LD_VAR 0 2
13798: PPUSH
13799: CALL_OW 67
// time := time + 0 0$10 ;
13803: LD_ADDR_VAR 0 2
13807: PUSH
13808: LD_VAR 0 2
13812: PUSH
13813: LD_INT 350
13815: PLUS
13816: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
13817: LD_INT 1
13819: PPUSH
13820: LD_INT 5
13822: PPUSH
13823: CALL_OW 12
13827: PPUSH
13828: LD_INT 11
13830: PPUSH
13831: LD_INT 1
13833: PPUSH
13834: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
13838: LD_ADDR_VAR 0 1
13842: PUSH
13843: LD_INT 1
13845: PPUSH
13846: LD_INT 3
13848: PPUSH
13849: CALL_OW 12
13853: ST_TO_ADDR
// if cr = 1 then
13854: LD_VAR 0 1
13858: PUSH
13859: LD_INT 1
13861: EQUAL
13862: IFFALSE 13906
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
13864: LD_INT 700
13866: PPUSH
13867: LD_INT 1575
13869: PPUSH
13870: CALL_OW 12
13874: PPUSH
13875: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
13879: LD_INT 1
13881: PPUSH
13882: LD_INT 5
13884: PPUSH
13885: CALL_OW 12
13889: PPUSH
13890: LD_INT 34
13892: PPUSH
13893: LD_INT 50
13895: PPUSH
13896: LD_INT 7
13898: PPUSH
13899: LD_INT 1
13901: PPUSH
13902: CALL_OW 56
// end ; if time > 8 8$00 then
13906: LD_VAR 0 2
13910: PUSH
13911: LD_INT 16800
13913: GREATER
13914: IFFALSE 13924
// time := 0 0$40 ;
13916: LD_ADDR_VAR 0 2
13920: PUSH
13921: LD_INT 1400
13923: ST_TO_ADDR
// end ;
13924: GO 13788
// end ; end_of_file
13926: PPOPN 2
13928: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13929: LD_INT 0
13931: PPUSH
13932: PPUSH
// if exist_mode then
13933: LD_VAR 0 2
13937: IFFALSE 13962
// unit := CreateCharacter ( prefix & ident ) else
13939: LD_ADDR_VAR 0 5
13943: PUSH
13944: LD_VAR 0 3
13948: PUSH
13949: LD_VAR 0 1
13953: STR
13954: PPUSH
13955: CALL_OW 34
13959: ST_TO_ADDR
13960: GO 13977
// unit := NewCharacter ( ident ) ;
13962: LD_ADDR_VAR 0 5
13966: PUSH
13967: LD_VAR 0 1
13971: PPUSH
13972: CALL_OW 25
13976: ST_TO_ADDR
// result := unit ;
13977: LD_ADDR_VAR 0 4
13981: PUSH
13982: LD_VAR 0 5
13986: ST_TO_ADDR
// end ;
13987: LD_VAR 0 4
13991: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13992: LD_INT 0
13994: PPUSH
13995: PPUSH
// if not side or not nation then
13996: LD_VAR 0 1
14000: NOT
14001: PUSH
14002: LD_VAR 0 2
14006: NOT
14007: OR
14008: IFFALSE 14012
// exit ;
14010: GO 14648
// case nation of nation_american :
14012: LD_VAR 0 2
14016: PUSH
14017: LD_INT 1
14019: DOUBLE
14020: EQUAL
14021: IFTRUE 14025
14023: GO 14195
14025: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
14026: LD_ADDR_VAR 0 4
14030: PUSH
14031: LD_INT 35
14033: PUSH
14034: LD_INT 45
14036: PUSH
14037: LD_INT 46
14039: PUSH
14040: LD_INT 47
14042: PUSH
14043: LD_INT 1
14045: PUSH
14046: LD_INT 2
14048: PUSH
14049: LD_INT 6
14051: PUSH
14052: LD_INT 15
14054: PUSH
14055: LD_INT 16
14057: PUSH
14058: LD_INT 7
14060: PUSH
14061: LD_INT 12
14063: PUSH
14064: LD_INT 13
14066: PUSH
14067: LD_INT 10
14069: PUSH
14070: LD_INT 14
14072: PUSH
14073: LD_INT 20
14075: PUSH
14076: LD_INT 21
14078: PUSH
14079: LD_INT 22
14081: PUSH
14082: LD_INT 25
14084: PUSH
14085: LD_INT 32
14087: PUSH
14088: LD_INT 27
14090: PUSH
14091: LD_INT 36
14093: PUSH
14094: LD_INT 69
14096: PUSH
14097: LD_INT 39
14099: PUSH
14100: LD_INT 34
14102: PUSH
14103: LD_INT 40
14105: PUSH
14106: LD_INT 48
14108: PUSH
14109: LD_INT 49
14111: PUSH
14112: LD_INT 50
14114: PUSH
14115: LD_INT 51
14117: PUSH
14118: LD_INT 52
14120: PUSH
14121: LD_INT 53
14123: PUSH
14124: LD_INT 54
14126: PUSH
14127: LD_INT 55
14129: PUSH
14130: LD_INT 56
14132: PUSH
14133: LD_INT 57
14135: PUSH
14136: LD_INT 58
14138: PUSH
14139: LD_INT 59
14141: PUSH
14142: LD_INT 60
14144: PUSH
14145: LD_INT 61
14147: PUSH
14148: LD_INT 62
14150: PUSH
14151: EMPTY
14152: LIST
14153: LIST
14154: LIST
14155: LIST
14156: LIST
14157: LIST
14158: LIST
14159: LIST
14160: LIST
14161: LIST
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: LIST
14167: LIST
14168: LIST
14169: LIST
14170: LIST
14171: LIST
14172: LIST
14173: LIST
14174: LIST
14175: LIST
14176: LIST
14177: LIST
14178: LIST
14179: LIST
14180: LIST
14181: LIST
14182: LIST
14183: LIST
14184: LIST
14185: LIST
14186: LIST
14187: LIST
14188: LIST
14189: LIST
14190: LIST
14191: LIST
14192: ST_TO_ADDR
14193: GO 14572
14195: LD_INT 2
14197: DOUBLE
14198: EQUAL
14199: IFTRUE 14203
14201: GO 14381
14203: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
14204: LD_ADDR_VAR 0 4
14208: PUSH
14209: LD_INT 35
14211: PUSH
14212: LD_INT 45
14214: PUSH
14215: LD_INT 46
14217: PUSH
14218: LD_INT 47
14220: PUSH
14221: LD_INT 70
14223: PUSH
14224: LD_INT 1
14226: PUSH
14227: LD_INT 11
14229: PUSH
14230: LD_INT 3
14232: PUSH
14233: LD_INT 4
14235: PUSH
14236: LD_INT 5
14238: PUSH
14239: LD_INT 6
14241: PUSH
14242: LD_INT 15
14244: PUSH
14245: LD_INT 18
14247: PUSH
14248: LD_INT 7
14250: PUSH
14251: LD_INT 17
14253: PUSH
14254: LD_INT 8
14256: PUSH
14257: LD_INT 20
14259: PUSH
14260: LD_INT 21
14262: PUSH
14263: LD_INT 22
14265: PUSH
14266: LD_INT 72
14268: PUSH
14269: LD_INT 26
14271: PUSH
14272: LD_INT 69
14274: PUSH
14275: LD_INT 39
14277: PUSH
14278: LD_INT 40
14280: PUSH
14281: LD_INT 41
14283: PUSH
14284: LD_INT 42
14286: PUSH
14287: LD_INT 43
14289: PUSH
14290: LD_INT 48
14292: PUSH
14293: LD_INT 49
14295: PUSH
14296: LD_INT 50
14298: PUSH
14299: LD_INT 51
14301: PUSH
14302: LD_INT 52
14304: PUSH
14305: LD_INT 53
14307: PUSH
14308: LD_INT 54
14310: PUSH
14311: LD_INT 55
14313: PUSH
14314: LD_INT 56
14316: PUSH
14317: LD_INT 60
14319: PUSH
14320: LD_INT 61
14322: PUSH
14323: LD_INT 62
14325: PUSH
14326: LD_INT 66
14328: PUSH
14329: LD_INT 67
14331: PUSH
14332: LD_INT 68
14334: PUSH
14335: EMPTY
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: LIST
14371: LIST
14372: LIST
14373: LIST
14374: LIST
14375: LIST
14376: LIST
14377: LIST
14378: ST_TO_ADDR
14379: GO 14572
14381: LD_INT 3
14383: DOUBLE
14384: EQUAL
14385: IFTRUE 14389
14387: GO 14571
14389: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14390: LD_ADDR_VAR 0 4
14394: PUSH
14395: LD_INT 46
14397: PUSH
14398: LD_INT 47
14400: PUSH
14401: LD_INT 1
14403: PUSH
14404: LD_INT 2
14406: PUSH
14407: LD_INT 11
14409: PUSH
14410: LD_INT 9
14412: PUSH
14413: LD_INT 20
14415: PUSH
14416: LD_INT 19
14418: PUSH
14419: LD_INT 21
14421: PUSH
14422: LD_INT 24
14424: PUSH
14425: LD_INT 22
14427: PUSH
14428: LD_INT 25
14430: PUSH
14431: LD_INT 28
14433: PUSH
14434: LD_INT 29
14436: PUSH
14437: LD_INT 30
14439: PUSH
14440: LD_INT 31
14442: PUSH
14443: LD_INT 37
14445: PUSH
14446: LD_INT 38
14448: PUSH
14449: LD_INT 32
14451: PUSH
14452: LD_INT 27
14454: PUSH
14455: LD_INT 33
14457: PUSH
14458: LD_INT 69
14460: PUSH
14461: LD_INT 39
14463: PUSH
14464: LD_INT 34
14466: PUSH
14467: LD_INT 40
14469: PUSH
14470: LD_INT 71
14472: PUSH
14473: LD_INT 23
14475: PUSH
14476: LD_INT 44
14478: PUSH
14479: LD_INT 48
14481: PUSH
14482: LD_INT 49
14484: PUSH
14485: LD_INT 50
14487: PUSH
14488: LD_INT 51
14490: PUSH
14491: LD_INT 52
14493: PUSH
14494: LD_INT 53
14496: PUSH
14497: LD_INT 54
14499: PUSH
14500: LD_INT 55
14502: PUSH
14503: LD_INT 56
14505: PUSH
14506: LD_INT 57
14508: PUSH
14509: LD_INT 58
14511: PUSH
14512: LD_INT 59
14514: PUSH
14515: LD_INT 63
14517: PUSH
14518: LD_INT 64
14520: PUSH
14521: LD_INT 65
14523: PUSH
14524: EMPTY
14525: LIST
14526: LIST
14527: LIST
14528: LIST
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: LIST
14534: LIST
14535: LIST
14536: LIST
14537: LIST
14538: LIST
14539: LIST
14540: LIST
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: LIST
14560: LIST
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: ST_TO_ADDR
14569: GO 14572
14571: POP
// if state > - 1 and state < 3 then
14572: LD_VAR 0 3
14576: PUSH
14577: LD_INT 1
14579: NEG
14580: GREATER
14581: PUSH
14582: LD_VAR 0 3
14586: PUSH
14587: LD_INT 3
14589: LESS
14590: AND
14591: IFFALSE 14648
// for i in result do
14593: LD_ADDR_VAR 0 5
14597: PUSH
14598: LD_VAR 0 4
14602: PUSH
14603: FOR_IN
14604: IFFALSE 14646
// if GetTech ( i , side ) <> state then
14606: LD_VAR 0 5
14610: PPUSH
14611: LD_VAR 0 1
14615: PPUSH
14616: CALL_OW 321
14620: PUSH
14621: LD_VAR 0 3
14625: NONEQUAL
14626: IFFALSE 14644
// result := result diff i ;
14628: LD_ADDR_VAR 0 4
14632: PUSH
14633: LD_VAR 0 4
14637: PUSH
14638: LD_VAR 0 5
14642: DIFF
14643: ST_TO_ADDR
14644: GO 14603
14646: POP
14647: POP
// end ;
14648: LD_VAR 0 4
14652: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14653: LD_INT 0
14655: PPUSH
14656: PPUSH
14657: PPUSH
// result := true ;
14658: LD_ADDR_VAR 0 3
14662: PUSH
14663: LD_INT 1
14665: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14666: LD_ADDR_VAR 0 5
14670: PUSH
14671: LD_VAR 0 2
14675: PPUSH
14676: CALL_OW 480
14680: ST_TO_ADDR
// if not tmp then
14681: LD_VAR 0 5
14685: NOT
14686: IFFALSE 14690
// exit ;
14688: GO 14739
// for i in tmp do
14690: LD_ADDR_VAR 0 4
14694: PUSH
14695: LD_VAR 0 5
14699: PUSH
14700: FOR_IN
14701: IFFALSE 14737
// if GetTech ( i , side ) <> state_researched then
14703: LD_VAR 0 4
14707: PPUSH
14708: LD_VAR 0 1
14712: PPUSH
14713: CALL_OW 321
14717: PUSH
14718: LD_INT 2
14720: NONEQUAL
14721: IFFALSE 14735
// begin result := false ;
14723: LD_ADDR_VAR 0 3
14727: PUSH
14728: LD_INT 0
14730: ST_TO_ADDR
// exit ;
14731: POP
14732: POP
14733: GO 14739
// end ;
14735: GO 14700
14737: POP
14738: POP
// end ;
14739: LD_VAR 0 3
14743: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14744: LD_INT 0
14746: PPUSH
14747: PPUSH
14748: PPUSH
14749: PPUSH
14750: PPUSH
14751: PPUSH
14752: PPUSH
14753: PPUSH
14754: PPUSH
14755: PPUSH
14756: PPUSH
14757: PPUSH
14758: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14759: LD_VAR 0 1
14763: NOT
14764: PUSH
14765: LD_VAR 0 1
14769: PPUSH
14770: CALL_OW 257
14774: PUSH
14775: LD_INT 9
14777: NONEQUAL
14778: OR
14779: IFFALSE 14783
// exit ;
14781: GO 15356
// side := GetSide ( unit ) ;
14783: LD_ADDR_VAR 0 9
14787: PUSH
14788: LD_VAR 0 1
14792: PPUSH
14793: CALL_OW 255
14797: ST_TO_ADDR
// tech_space := tech_spacanom ;
14798: LD_ADDR_VAR 0 12
14802: PUSH
14803: LD_INT 29
14805: ST_TO_ADDR
// tech_time := tech_taurad ;
14806: LD_ADDR_VAR 0 13
14810: PUSH
14811: LD_INT 28
14813: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14814: LD_ADDR_VAR 0 11
14818: PUSH
14819: LD_VAR 0 1
14823: PPUSH
14824: CALL_OW 310
14828: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14829: LD_VAR 0 11
14833: PPUSH
14834: CALL_OW 247
14838: PUSH
14839: LD_INT 2
14841: EQUAL
14842: IFFALSE 14846
// exit ;
14844: GO 15356
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14846: LD_ADDR_VAR 0 8
14850: PUSH
14851: LD_INT 81
14853: PUSH
14854: LD_VAR 0 9
14858: PUSH
14859: EMPTY
14860: LIST
14861: LIST
14862: PUSH
14863: LD_INT 3
14865: PUSH
14866: LD_INT 21
14868: PUSH
14869: LD_INT 3
14871: PUSH
14872: EMPTY
14873: LIST
14874: LIST
14875: PUSH
14876: EMPTY
14877: LIST
14878: LIST
14879: PUSH
14880: EMPTY
14881: LIST
14882: LIST
14883: PPUSH
14884: CALL_OW 69
14888: ST_TO_ADDR
// if not tmp then
14889: LD_VAR 0 8
14893: NOT
14894: IFFALSE 14898
// exit ;
14896: GO 15356
// if in_unit then
14898: LD_VAR 0 11
14902: IFFALSE 14926
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14904: LD_ADDR_VAR 0 10
14908: PUSH
14909: LD_VAR 0 8
14913: PPUSH
14914: LD_VAR 0 11
14918: PPUSH
14919: CALL_OW 74
14923: ST_TO_ADDR
14924: GO 14946
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14926: LD_ADDR_VAR 0 10
14930: PUSH
14931: LD_VAR 0 8
14935: PPUSH
14936: LD_VAR 0 1
14940: PPUSH
14941: CALL_OW 74
14945: ST_TO_ADDR
// if not enemy then
14946: LD_VAR 0 10
14950: NOT
14951: IFFALSE 14955
// exit ;
14953: GO 15356
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14955: LD_VAR 0 11
14959: PUSH
14960: LD_VAR 0 11
14964: PPUSH
14965: LD_VAR 0 10
14969: PPUSH
14970: CALL_OW 296
14974: PUSH
14975: LD_INT 13
14977: GREATER
14978: AND
14979: PUSH
14980: LD_VAR 0 1
14984: PPUSH
14985: LD_VAR 0 10
14989: PPUSH
14990: CALL_OW 296
14994: PUSH
14995: LD_INT 12
14997: GREATER
14998: OR
14999: IFFALSE 15003
// exit ;
15001: GO 15356
// missile := [ 1 ] ;
15003: LD_ADDR_VAR 0 14
15007: PUSH
15008: LD_INT 1
15010: PUSH
15011: EMPTY
15012: LIST
15013: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15014: LD_VAR 0 9
15018: PPUSH
15019: LD_VAR 0 12
15023: PPUSH
15024: CALL_OW 325
15028: IFFALSE 15057
// missile := Insert ( missile , missile + 1 , 2 ) ;
15030: LD_ADDR_VAR 0 14
15034: PUSH
15035: LD_VAR 0 14
15039: PPUSH
15040: LD_VAR 0 14
15044: PUSH
15045: LD_INT 1
15047: PLUS
15048: PPUSH
15049: LD_INT 2
15051: PPUSH
15052: CALL_OW 2
15056: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15057: LD_VAR 0 9
15061: PPUSH
15062: LD_VAR 0 13
15066: PPUSH
15067: CALL_OW 325
15071: PUSH
15072: LD_VAR 0 10
15076: PPUSH
15077: CALL_OW 255
15081: PPUSH
15082: LD_VAR 0 13
15086: PPUSH
15087: CALL_OW 325
15091: NOT
15092: AND
15093: IFFALSE 15122
// missile := Insert ( missile , missile + 1 , 3 ) ;
15095: LD_ADDR_VAR 0 14
15099: PUSH
15100: LD_VAR 0 14
15104: PPUSH
15105: LD_VAR 0 14
15109: PUSH
15110: LD_INT 1
15112: PLUS
15113: PPUSH
15114: LD_INT 3
15116: PPUSH
15117: CALL_OW 2
15121: ST_TO_ADDR
// if missile < 2 then
15122: LD_VAR 0 14
15126: PUSH
15127: LD_INT 2
15129: LESS
15130: IFFALSE 15134
// exit ;
15132: GO 15356
// x := GetX ( enemy ) ;
15134: LD_ADDR_VAR 0 4
15138: PUSH
15139: LD_VAR 0 10
15143: PPUSH
15144: CALL_OW 250
15148: ST_TO_ADDR
// y := GetY ( enemy ) ;
15149: LD_ADDR_VAR 0 5
15153: PUSH
15154: LD_VAR 0 10
15158: PPUSH
15159: CALL_OW 251
15163: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15164: LD_ADDR_VAR 0 6
15168: PUSH
15169: LD_VAR 0 4
15173: PUSH
15174: LD_INT 1
15176: NEG
15177: PPUSH
15178: LD_INT 1
15180: PPUSH
15181: CALL_OW 12
15185: PLUS
15186: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15187: LD_ADDR_VAR 0 7
15191: PUSH
15192: LD_VAR 0 5
15196: PUSH
15197: LD_INT 1
15199: NEG
15200: PPUSH
15201: LD_INT 1
15203: PPUSH
15204: CALL_OW 12
15208: PLUS
15209: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15210: LD_VAR 0 6
15214: PPUSH
15215: LD_VAR 0 7
15219: PPUSH
15220: CALL_OW 488
15224: NOT
15225: IFFALSE 15247
// begin _x := x ;
15227: LD_ADDR_VAR 0 6
15231: PUSH
15232: LD_VAR 0 4
15236: ST_TO_ADDR
// _y := y ;
15237: LD_ADDR_VAR 0 7
15241: PUSH
15242: LD_VAR 0 5
15246: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15247: LD_ADDR_VAR 0 3
15251: PUSH
15252: LD_INT 1
15254: PPUSH
15255: LD_VAR 0 14
15259: PPUSH
15260: CALL_OW 12
15264: ST_TO_ADDR
// case i of 1 :
15265: LD_VAR 0 3
15269: PUSH
15270: LD_INT 1
15272: DOUBLE
15273: EQUAL
15274: IFTRUE 15278
15276: GO 15295
15278: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15279: LD_VAR 0 1
15283: PPUSH
15284: LD_VAR 0 10
15288: PPUSH
15289: CALL_OW 115
15293: GO 15356
15295: LD_INT 2
15297: DOUBLE
15298: EQUAL
15299: IFTRUE 15303
15301: GO 15325
15303: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15304: LD_VAR 0 1
15308: PPUSH
15309: LD_VAR 0 6
15313: PPUSH
15314: LD_VAR 0 7
15318: PPUSH
15319: CALL_OW 153
15323: GO 15356
15325: LD_INT 3
15327: DOUBLE
15328: EQUAL
15329: IFTRUE 15333
15331: GO 15355
15333: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15334: LD_VAR 0 1
15338: PPUSH
15339: LD_VAR 0 6
15343: PPUSH
15344: LD_VAR 0 7
15348: PPUSH
15349: CALL_OW 154
15353: GO 15356
15355: POP
// end ;
15356: LD_VAR 0 2
15360: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15361: LD_INT 0
15363: PPUSH
15364: PPUSH
15365: PPUSH
15366: PPUSH
15367: PPUSH
15368: PPUSH
// if not unit or not building then
15369: LD_VAR 0 1
15373: NOT
15374: PUSH
15375: LD_VAR 0 2
15379: NOT
15380: OR
15381: IFFALSE 15385
// exit ;
15383: GO 15543
// x := GetX ( building ) ;
15385: LD_ADDR_VAR 0 5
15389: PUSH
15390: LD_VAR 0 2
15394: PPUSH
15395: CALL_OW 250
15399: ST_TO_ADDR
// y := GetY ( building ) ;
15400: LD_ADDR_VAR 0 6
15404: PUSH
15405: LD_VAR 0 2
15409: PPUSH
15410: CALL_OW 251
15414: ST_TO_ADDR
// for i = 0 to 5 do
15415: LD_ADDR_VAR 0 4
15419: PUSH
15420: DOUBLE
15421: LD_INT 0
15423: DEC
15424: ST_TO_ADDR
15425: LD_INT 5
15427: PUSH
15428: FOR_TO
15429: IFFALSE 15541
// begin _x := ShiftX ( x , i , 3 ) ;
15431: LD_ADDR_VAR 0 7
15435: PUSH
15436: LD_VAR 0 5
15440: PPUSH
15441: LD_VAR 0 4
15445: PPUSH
15446: LD_INT 3
15448: PPUSH
15449: CALL_OW 272
15453: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15454: LD_ADDR_VAR 0 8
15458: PUSH
15459: LD_VAR 0 6
15463: PPUSH
15464: LD_VAR 0 4
15468: PPUSH
15469: LD_INT 3
15471: PPUSH
15472: CALL_OW 273
15476: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15477: LD_VAR 0 7
15481: PPUSH
15482: LD_VAR 0 8
15486: PPUSH
15487: CALL_OW 488
15491: NOT
15492: IFFALSE 15496
// continue ;
15494: GO 15428
// if HexInfo ( _x , _y ) = 0 then
15496: LD_VAR 0 7
15500: PPUSH
15501: LD_VAR 0 8
15505: PPUSH
15506: CALL_OW 428
15510: PUSH
15511: LD_INT 0
15513: EQUAL
15514: IFFALSE 15539
// begin ComMoveXY ( unit , _x , _y ) ;
15516: LD_VAR 0 1
15520: PPUSH
15521: LD_VAR 0 7
15525: PPUSH
15526: LD_VAR 0 8
15530: PPUSH
15531: CALL_OW 111
// exit ;
15535: POP
15536: POP
15537: GO 15543
// end ; end ;
15539: GO 15428
15541: POP
15542: POP
// end ;
15543: LD_VAR 0 3
15547: RET
// export function ScanBase ( side , base_area ) ; begin
15548: LD_INT 0
15550: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15551: LD_ADDR_VAR 0 3
15555: PUSH
15556: LD_VAR 0 2
15560: PPUSH
15561: LD_INT 81
15563: PUSH
15564: LD_VAR 0 1
15568: PUSH
15569: EMPTY
15570: LIST
15571: LIST
15572: PPUSH
15573: CALL_OW 70
15577: ST_TO_ADDR
// end ;
15578: LD_VAR 0 3
15582: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15583: LD_INT 0
15585: PPUSH
15586: PPUSH
15587: PPUSH
15588: PPUSH
15589: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15590: LD_VAR 0 1
15594: NOT
15595: PUSH
15596: LD_EXP 58
15600: PUSH
15601: LD_VAR 0 1
15605: ARRAY
15606: NOT
15607: OR
15608: PUSH
15609: LD_VAR 0 2
15613: NOT
15614: OR
15615: PUSH
15616: LD_VAR 0 3
15620: NOT
15621: OR
15622: IFFALSE 15626
// exit ;
15624: GO 16076
// side := mc_sides [ base ] ;
15626: LD_ADDR_VAR 0 6
15630: PUSH
15631: LD_EXP 84
15635: PUSH
15636: LD_VAR 0 1
15640: ARRAY
15641: ST_TO_ADDR
// if not side then
15642: LD_VAR 0 6
15646: NOT
15647: IFFALSE 15651
// exit ;
15649: GO 16076
// for i in solds do
15651: LD_ADDR_VAR 0 7
15655: PUSH
15656: LD_VAR 0 2
15660: PUSH
15661: FOR_IN
15662: IFFALSE 15723
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15664: LD_VAR 0 7
15668: PPUSH
15669: CALL_OW 310
15673: PPUSH
15674: CALL_OW 266
15678: PUSH
15679: LD_INT 32
15681: PUSH
15682: LD_INT 31
15684: PUSH
15685: EMPTY
15686: LIST
15687: LIST
15688: IN
15689: IFFALSE 15709
// solds := solds diff i else
15691: LD_ADDR_VAR 0 2
15695: PUSH
15696: LD_VAR 0 2
15700: PUSH
15701: LD_VAR 0 7
15705: DIFF
15706: ST_TO_ADDR
15707: GO 15721
// SetTag ( i , 18 ) ;
15709: LD_VAR 0 7
15713: PPUSH
15714: LD_INT 18
15716: PPUSH
15717: CALL_OW 109
15721: GO 15661
15723: POP
15724: POP
// if not solds then
15725: LD_VAR 0 2
15729: NOT
15730: IFFALSE 15734
// exit ;
15732: GO 16076
// repeat wait ( 0 0$1 ) ;
15734: LD_INT 35
15736: PPUSH
15737: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15741: LD_ADDR_VAR 0 5
15745: PUSH
15746: LD_VAR 0 6
15750: PPUSH
15751: LD_VAR 0 3
15755: PPUSH
15756: CALL 15548 0 2
15760: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
15761: LD_VAR 0 5
15765: NOT
15766: PUSH
15767: LD_VAR 0 5
15771: PUSH
15772: LD_INT 3
15774: GREATER
15775: OR
15776: PUSH
15777: LD_EXP 80
15781: PUSH
15782: LD_VAR 0 1
15786: ARRAY
15787: OR
15788: IFFALSE 15829
// begin for i in solds do
15790: LD_ADDR_VAR 0 7
15794: PUSH
15795: LD_VAR 0 2
15799: PUSH
15800: FOR_IN
15801: IFFALSE 15825
// if HasTask ( i ) then
15803: LD_VAR 0 7
15807: PPUSH
15808: CALL_OW 314
15812: IFFALSE 15823
// ComStop ( i ) ;
15814: LD_VAR 0 7
15818: PPUSH
15819: CALL_OW 141
15823: GO 15800
15825: POP
15826: POP
// break ;
15827: GO 16064
// end ; for i in solds do
15829: LD_ADDR_VAR 0 7
15833: PUSH
15834: LD_VAR 0 2
15838: PUSH
15839: FOR_IN
15840: IFFALSE 16056
// begin if IsInUnit ( i ) then
15842: LD_VAR 0 7
15846: PPUSH
15847: CALL_OW 310
15851: IFFALSE 15862
// ComExitBuilding ( i ) ;
15853: LD_VAR 0 7
15857: PPUSH
15858: CALL_OW 122
// if GetLives ( i ) > 333 then
15862: LD_VAR 0 7
15866: PPUSH
15867: CALL_OW 256
15871: PUSH
15872: LD_INT 333
15874: GREATER
15875: IFFALSE 15903
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15877: LD_VAR 0 7
15881: PPUSH
15882: LD_VAR 0 5
15886: PPUSH
15887: LD_VAR 0 7
15891: PPUSH
15892: CALL_OW 74
15896: PPUSH
15897: CALL_OW 115
15901: GO 16054
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
15903: LD_ADDR_VAR 0 8
15907: PUSH
15908: LD_EXP 58
15912: PUSH
15913: LD_VAR 0 1
15917: ARRAY
15918: PPUSH
15919: LD_INT 2
15921: PUSH
15922: LD_INT 30
15924: PUSH
15925: LD_INT 0
15927: PUSH
15928: EMPTY
15929: LIST
15930: LIST
15931: PUSH
15932: LD_INT 30
15934: PUSH
15935: LD_INT 1
15937: PUSH
15938: EMPTY
15939: LIST
15940: LIST
15941: PUSH
15942: LD_INT 30
15944: PUSH
15945: LD_INT 6
15947: PUSH
15948: EMPTY
15949: LIST
15950: LIST
15951: PUSH
15952: EMPTY
15953: LIST
15954: LIST
15955: LIST
15956: LIST
15957: PPUSH
15958: CALL_OW 72
15962: PPUSH
15963: LD_VAR 0 7
15967: PPUSH
15968: CALL_OW 74
15972: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
15973: LD_VAR 0 7
15977: PPUSH
15978: LD_VAR 0 8
15982: PPUSH
15983: CALL_OW 250
15987: PPUSH
15988: LD_INT 3
15990: PPUSH
15991: LD_INT 5
15993: PPUSH
15994: CALL_OW 272
15998: PPUSH
15999: LD_VAR 0 8
16003: PPUSH
16004: CALL_OW 251
16008: PPUSH
16009: LD_INT 3
16011: PPUSH
16012: LD_INT 5
16014: PPUSH
16015: CALL_OW 273
16019: PPUSH
16020: CALL_OW 111
// SetTag ( i , 0 ) ;
16024: LD_VAR 0 7
16028: PPUSH
16029: LD_INT 0
16031: PPUSH
16032: CALL_OW 109
// solds := solds diff i ;
16036: LD_ADDR_VAR 0 2
16040: PUSH
16041: LD_VAR 0 2
16045: PUSH
16046: LD_VAR 0 7
16050: DIFF
16051: ST_TO_ADDR
// continue ;
16052: GO 15839
// end ; end ;
16054: GO 15839
16056: POP
16057: POP
// until solds ;
16058: LD_VAR 0 2
16062: IFFALSE 15734
// MC_Reset ( base , 18 ) ;
16064: LD_VAR 0 1
16068: PPUSH
16069: LD_INT 18
16071: PPUSH
16072: CALL 60572 0 2
// end ;
16076: LD_VAR 0 4
16080: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16081: LD_INT 0
16083: PPUSH
16084: PPUSH
16085: PPUSH
16086: PPUSH
16087: PPUSH
16088: PPUSH
16089: PPUSH
16090: PPUSH
16091: PPUSH
16092: PPUSH
16093: PPUSH
16094: PPUSH
16095: PPUSH
16096: PPUSH
16097: PPUSH
16098: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16099: LD_ADDR_VAR 0 12
16103: PUSH
16104: LD_EXP 58
16108: PUSH
16109: LD_VAR 0 1
16113: ARRAY
16114: PPUSH
16115: LD_INT 25
16117: PUSH
16118: LD_INT 3
16120: PUSH
16121: EMPTY
16122: LIST
16123: LIST
16124: PPUSH
16125: CALL_OW 72
16129: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16130: LD_ADDR_VAR 0 8
16134: PUSH
16135: LD_EXP 58
16139: PUSH
16140: LD_VAR 0 1
16144: ARRAY
16145: PPUSH
16146: LD_INT 2
16148: PUSH
16149: LD_INT 25
16151: PUSH
16152: LD_INT 1
16154: PUSH
16155: EMPTY
16156: LIST
16157: LIST
16158: PUSH
16159: LD_INT 25
16161: PUSH
16162: LD_INT 5
16164: PUSH
16165: EMPTY
16166: LIST
16167: LIST
16168: PUSH
16169: LD_INT 25
16171: PUSH
16172: LD_INT 8
16174: PUSH
16175: EMPTY
16176: LIST
16177: LIST
16178: PUSH
16179: LD_INT 25
16181: PUSH
16182: LD_INT 9
16184: PUSH
16185: EMPTY
16186: LIST
16187: LIST
16188: PUSH
16189: EMPTY
16190: LIST
16191: LIST
16192: LIST
16193: LIST
16194: LIST
16195: PPUSH
16196: CALL_OW 72
16200: ST_TO_ADDR
// if not defenders and not solds then
16201: LD_VAR 0 2
16205: NOT
16206: PUSH
16207: LD_VAR 0 8
16211: NOT
16212: AND
16213: IFFALSE 16217
// exit ;
16215: GO 17546
// depot_under_attack := false ;
16217: LD_ADDR_VAR 0 16
16221: PUSH
16222: LD_INT 0
16224: ST_TO_ADDR
// sold_defenders := [ ] ;
16225: LD_ADDR_VAR 0 17
16229: PUSH
16230: EMPTY
16231: ST_TO_ADDR
// if mechs then
16232: LD_VAR 0 12
16236: IFFALSE 16365
// for i in defenders do
16238: LD_ADDR_VAR 0 5
16242: PUSH
16243: LD_VAR 0 2
16247: PUSH
16248: FOR_IN
16249: IFFALSE 16363
// begin SetTag ( i , 20 ) ;
16251: LD_VAR 0 5
16255: PPUSH
16256: LD_INT 20
16258: PPUSH
16259: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16263: LD_VAR 0 5
16267: PPUSH
16268: CALL_OW 263
16272: PUSH
16273: LD_INT 1
16275: EQUAL
16276: PUSH
16277: LD_VAR 0 5
16281: PPUSH
16282: CALL_OW 311
16286: NOT
16287: AND
16288: PUSH
16289: LD_VAR 0 12
16293: AND
16294: IFFALSE 16361
// begin un := mechs [ 1 ] ;
16296: LD_ADDR_VAR 0 10
16300: PUSH
16301: LD_VAR 0 12
16305: PUSH
16306: LD_INT 1
16308: ARRAY
16309: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16310: LD_VAR 0 10
16314: PPUSH
16315: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16319: LD_VAR 0 10
16323: PPUSH
16324: LD_VAR 0 5
16328: PPUSH
16329: CALL_OW 180
// SetTag ( un , 19 ) ;
16333: LD_VAR 0 10
16337: PPUSH
16338: LD_INT 19
16340: PPUSH
16341: CALL_OW 109
// mechs := mechs diff un ;
16345: LD_ADDR_VAR 0 12
16349: PUSH
16350: LD_VAR 0 12
16354: PUSH
16355: LD_VAR 0 10
16359: DIFF
16360: ST_TO_ADDR
// end ; end ;
16361: GO 16248
16363: POP
16364: POP
// if solds then
16365: LD_VAR 0 8
16369: IFFALSE 16428
// for i in solds do
16371: LD_ADDR_VAR 0 5
16375: PUSH
16376: LD_VAR 0 8
16380: PUSH
16381: FOR_IN
16382: IFFALSE 16426
// if not GetTag ( i ) then
16384: LD_VAR 0 5
16388: PPUSH
16389: CALL_OW 110
16393: NOT
16394: IFFALSE 16424
// begin defenders := defenders union i ;
16396: LD_ADDR_VAR 0 2
16400: PUSH
16401: LD_VAR 0 2
16405: PUSH
16406: LD_VAR 0 5
16410: UNION
16411: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16412: LD_VAR 0 5
16416: PPUSH
16417: LD_INT 18
16419: PPUSH
16420: CALL_OW 109
// end ;
16424: GO 16381
16426: POP
16427: POP
// repeat wait ( 0 0$1 ) ;
16428: LD_INT 35
16430: PPUSH
16431: CALL_OW 67
// enemy := mc_scan [ base ] ;
16435: LD_ADDR_VAR 0 3
16439: PUSH
16440: LD_EXP 81
16444: PUSH
16445: LD_VAR 0 1
16449: ARRAY
16450: ST_TO_ADDR
// for i in defenders do
16451: LD_ADDR_VAR 0 5
16455: PUSH
16456: LD_VAR 0 2
16460: PUSH
16461: FOR_IN
16462: IFFALSE 17147
// begin e := NearestUnitToUnit ( enemy , i ) ;
16464: LD_ADDR_VAR 0 13
16468: PUSH
16469: LD_VAR 0 3
16473: PPUSH
16474: LD_VAR 0 5
16478: PPUSH
16479: CALL_OW 74
16483: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
16484: LD_ADDR_VAR 0 16
16488: PUSH
16489: LD_EXP 58
16493: PUSH
16494: LD_VAR 0 1
16498: ARRAY
16499: PPUSH
16500: LD_INT 2
16502: PUSH
16503: LD_INT 30
16505: PUSH
16506: LD_INT 0
16508: PUSH
16509: EMPTY
16510: LIST
16511: LIST
16512: PUSH
16513: LD_INT 30
16515: PUSH
16516: LD_INT 1
16518: PUSH
16519: EMPTY
16520: LIST
16521: LIST
16522: PUSH
16523: EMPTY
16524: LIST
16525: LIST
16526: LIST
16527: PPUSH
16528: CALL_OW 72
16532: NOT
16533: PUSH
16534: LD_EXP 58
16538: PUSH
16539: LD_VAR 0 1
16543: ARRAY
16544: PPUSH
16545: LD_INT 2
16547: PUSH
16548: LD_INT 30
16550: PUSH
16551: LD_INT 0
16553: PUSH
16554: EMPTY
16555: LIST
16556: LIST
16557: PUSH
16558: LD_INT 30
16560: PUSH
16561: LD_INT 1
16563: PUSH
16564: EMPTY
16565: LIST
16566: LIST
16567: PUSH
16568: EMPTY
16569: LIST
16570: LIST
16571: LIST
16572: PPUSH
16573: CALL_OW 72
16577: PPUSH
16578: CALL_OW 256
16582: PUSH
16583: LD_INT 600
16585: LESS
16586: OR
16587: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
16588: LD_VAR 0 5
16592: PPUSH
16593: CALL_OW 247
16597: PUSH
16598: LD_INT 2
16600: DOUBLE
16601: EQUAL
16602: IFTRUE 16606
16604: GO 16853
16606: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
16607: LD_VAR 0 5
16611: PPUSH
16612: CALL_OW 256
16616: PUSH
16617: LD_INT 650
16619: GREATER
16620: PUSH
16621: LD_VAR 0 5
16625: PPUSH
16626: LD_VAR 0 13
16630: PPUSH
16631: CALL_OW 296
16635: PUSH
16636: LD_INT 40
16638: LESS
16639: AND
16640: IFFALSE 16658
// ComAttackUnit ( i , e ) else
16642: LD_VAR 0 5
16646: PPUSH
16647: LD_VAR 0 13
16651: PPUSH
16652: CALL_OW 115
16656: GO 16736
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
16658: LD_VAR 0 5
16662: PPUSH
16663: LD_VAR 0 13
16667: PPUSH
16668: CALL_OW 296
16672: PUSH
16673: LD_INT 30
16675: GREATEREQUAL
16676: PUSH
16677: LD_VAR 0 5
16681: PPUSH
16682: CALL_OW 256
16686: PUSH
16687: LD_INT 650
16689: LESSEQUAL
16690: OR
16691: PUSH
16692: LD_VAR 0 5
16696: PPUSH
16697: LD_EXP 82
16701: PUSH
16702: LD_VAR 0 1
16706: ARRAY
16707: PPUSH
16708: CALL_OW 308
16712: NOT
16713: AND
16714: IFFALSE 16736
// ComMoveToArea ( i , mc_parking [ base ] ) ;
16716: LD_VAR 0 5
16720: PPUSH
16721: LD_EXP 82
16725: PUSH
16726: LD_VAR 0 1
16730: ARRAY
16731: PPUSH
16732: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
16736: LD_VAR 0 5
16740: PPUSH
16741: CALL_OW 256
16745: PUSH
16746: LD_INT 998
16748: LESS
16749: PUSH
16750: LD_VAR 0 5
16754: PPUSH
16755: CALL_OW 263
16759: PUSH
16760: LD_INT 1
16762: EQUAL
16763: AND
16764: PUSH
16765: LD_VAR 0 5
16769: PPUSH
16770: CALL_OW 311
16774: AND
16775: PUSH
16776: LD_VAR 0 5
16780: PPUSH
16781: LD_EXP 82
16785: PUSH
16786: LD_VAR 0 1
16790: ARRAY
16791: PPUSH
16792: CALL_OW 308
16796: AND
16797: IFFALSE 16851
// begin mech := IsDrivenBy ( i ) ;
16799: LD_ADDR_VAR 0 9
16803: PUSH
16804: LD_VAR 0 5
16808: PPUSH
16809: CALL_OW 311
16813: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
16814: LD_VAR 0 9
16818: PPUSH
16819: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
16823: LD_VAR 0 9
16827: PPUSH
16828: LD_VAR 0 5
16832: PPUSH
16833: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
16837: LD_VAR 0 9
16841: PPUSH
16842: LD_VAR 0 5
16846: PPUSH
16847: CALL_OW 180
// end ; end ; unit_human :
16851: GO 17118
16853: LD_INT 1
16855: DOUBLE
16856: EQUAL
16857: IFTRUE 16861
16859: GO 17117
16861: POP
// begin b := IsInUnit ( i ) ;
16862: LD_ADDR_VAR 0 18
16866: PUSH
16867: LD_VAR 0 5
16871: PPUSH
16872: CALL_OW 310
16876: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
16877: LD_ADDR_VAR 0 19
16881: PUSH
16882: LD_VAR 0 18
16886: NOT
16887: PUSH
16888: LD_VAR 0 18
16892: PPUSH
16893: CALL_OW 266
16897: PUSH
16898: LD_INT 32
16900: PUSH
16901: LD_INT 31
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: IN
16908: OR
16909: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
16910: LD_VAR 0 16
16914: PUSH
16915: LD_VAR 0 2
16919: PPUSH
16920: LD_INT 21
16922: PUSH
16923: LD_INT 2
16925: PUSH
16926: EMPTY
16927: LIST
16928: LIST
16929: PPUSH
16930: CALL_OW 72
16934: PUSH
16935: LD_INT 1
16937: LESSEQUAL
16938: OR
16939: PUSH
16940: LD_VAR 0 19
16944: AND
16945: PUSH
16946: LD_VAR 0 5
16950: PUSH
16951: LD_VAR 0 17
16955: IN
16956: NOT
16957: AND
16958: IFFALSE 17051
// begin if b then
16960: LD_VAR 0 18
16964: IFFALSE 17013
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
16966: LD_VAR 0 18
16970: PPUSH
16971: LD_VAR 0 3
16975: PPUSH
16976: LD_VAR 0 18
16980: PPUSH
16981: CALL_OW 74
16985: PPUSH
16986: CALL_OW 296
16990: PUSH
16991: LD_INT 10
16993: LESS
16994: PUSH
16995: LD_VAR 0 18
16999: PPUSH
17000: CALL_OW 461
17004: PUSH
17005: LD_INT 7
17007: NONEQUAL
17008: AND
17009: IFFALSE 17013
// continue ;
17011: GO 16461
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
17013: LD_ADDR_VAR 0 17
17017: PUSH
17018: LD_VAR 0 17
17022: PPUSH
17023: LD_VAR 0 17
17027: PUSH
17028: LD_INT 1
17030: PLUS
17031: PPUSH
17032: LD_VAR 0 5
17036: PPUSH
17037: CALL_OW 1
17041: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17042: LD_VAR 0 5
17046: PPUSH
17047: CALL_OW 122
// end ; if sold_defenders then
17051: LD_VAR 0 17
17055: IFFALSE 17115
// if i in sold_defenders then
17057: LD_VAR 0 5
17061: PUSH
17062: LD_VAR 0 17
17066: IN
17067: IFFALSE 17115
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17069: LD_VAR 0 5
17073: PPUSH
17074: CALL_OW 314
17078: NOT
17079: PUSH
17080: LD_VAR 0 5
17084: PPUSH
17085: LD_VAR 0 13
17089: PPUSH
17090: CALL_OW 296
17094: PUSH
17095: LD_INT 30
17097: LESS
17098: AND
17099: IFFALSE 17115
// ComAttackUnit ( i , e ) ;
17101: LD_VAR 0 5
17105: PPUSH
17106: LD_VAR 0 13
17110: PPUSH
17111: CALL_OW 115
// end ; end ; end ;
17115: GO 17118
17117: POP
// if IsDead ( i ) then
17118: LD_VAR 0 5
17122: PPUSH
17123: CALL_OW 301
17127: IFFALSE 17145
// defenders := defenders diff i ;
17129: LD_ADDR_VAR 0 2
17133: PUSH
17134: LD_VAR 0 2
17138: PUSH
17139: LD_VAR 0 5
17143: DIFF
17144: ST_TO_ADDR
// end ;
17145: GO 16461
17147: POP
17148: POP
// until not enemy or not defenders ;
17149: LD_VAR 0 3
17153: NOT
17154: PUSH
17155: LD_VAR 0 2
17159: NOT
17160: OR
17161: IFFALSE 16428
// MC_Reset ( base , 18 ) ;
17163: LD_VAR 0 1
17167: PPUSH
17168: LD_INT 18
17170: PPUSH
17171: CALL 60572 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17175: LD_ADDR_VAR 0 2
17179: PUSH
17180: LD_VAR 0 2
17184: PUSH
17185: LD_VAR 0 2
17189: PPUSH
17190: LD_INT 2
17192: PUSH
17193: LD_INT 25
17195: PUSH
17196: LD_INT 1
17198: PUSH
17199: EMPTY
17200: LIST
17201: LIST
17202: PUSH
17203: LD_INT 25
17205: PUSH
17206: LD_INT 5
17208: PUSH
17209: EMPTY
17210: LIST
17211: LIST
17212: PUSH
17213: LD_INT 25
17215: PUSH
17216: LD_INT 8
17218: PUSH
17219: EMPTY
17220: LIST
17221: LIST
17222: PUSH
17223: LD_INT 25
17225: PUSH
17226: LD_INT 9
17228: PUSH
17229: EMPTY
17230: LIST
17231: LIST
17232: PUSH
17233: EMPTY
17234: LIST
17235: LIST
17236: LIST
17237: LIST
17238: LIST
17239: PPUSH
17240: CALL_OW 72
17244: DIFF
17245: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17246: LD_VAR 0 3
17250: NOT
17251: PUSH
17252: LD_VAR 0 2
17256: PPUSH
17257: LD_INT 21
17259: PUSH
17260: LD_INT 2
17262: PUSH
17263: EMPTY
17264: LIST
17265: LIST
17266: PPUSH
17267: CALL_OW 72
17271: AND
17272: IFFALSE 17534
// begin tmp := FilterByTag ( defenders , 19 ) ;
17274: LD_ADDR_VAR 0 11
17278: PUSH
17279: LD_VAR 0 2
17283: PPUSH
17284: LD_INT 19
17286: PPUSH
17287: CALL 53914 0 2
17291: ST_TO_ADDR
// if tmp then
17292: LD_VAR 0 11
17296: IFFALSE 17366
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
17298: LD_ADDR_VAR 0 11
17302: PUSH
17303: LD_VAR 0 11
17307: PPUSH
17308: LD_INT 25
17310: PUSH
17311: LD_INT 3
17313: PUSH
17314: EMPTY
17315: LIST
17316: LIST
17317: PPUSH
17318: CALL_OW 72
17322: ST_TO_ADDR
// if tmp then
17323: LD_VAR 0 11
17327: IFFALSE 17366
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
17329: LD_ADDR_EXP 70
17333: PUSH
17334: LD_EXP 70
17338: PPUSH
17339: LD_VAR 0 1
17343: PPUSH
17344: LD_EXP 70
17348: PUSH
17349: LD_VAR 0 1
17353: ARRAY
17354: PUSH
17355: LD_VAR 0 11
17359: UNION
17360: PPUSH
17361: CALL_OW 1
17365: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
17366: LD_VAR 0 1
17370: PPUSH
17371: LD_INT 19
17373: PPUSH
17374: CALL 60572 0 2
// repeat wait ( 0 0$1 ) ;
17378: LD_INT 35
17380: PPUSH
17381: CALL_OW 67
// for i in defenders do
17385: LD_ADDR_VAR 0 5
17389: PUSH
17390: LD_VAR 0 2
17394: PUSH
17395: FOR_IN
17396: IFFALSE 17485
// begin if not IsInArea ( i , mc_parking [ base ] ) then
17398: LD_VAR 0 5
17402: PPUSH
17403: LD_EXP 82
17407: PUSH
17408: LD_VAR 0 1
17412: ARRAY
17413: PPUSH
17414: CALL_OW 308
17418: NOT
17419: IFFALSE 17443
// ComMoveToArea ( i , mc_parking [ base ] ) else
17421: LD_VAR 0 5
17425: PPUSH
17426: LD_EXP 82
17430: PUSH
17431: LD_VAR 0 1
17435: ARRAY
17436: PPUSH
17437: CALL_OW 113
17441: GO 17483
// if GetControl ( i ) = control_manual then
17443: LD_VAR 0 5
17447: PPUSH
17448: CALL_OW 263
17452: PUSH
17453: LD_INT 1
17455: EQUAL
17456: IFFALSE 17483
// if IsDrivenBy ( i ) then
17458: LD_VAR 0 5
17462: PPUSH
17463: CALL_OW 311
17467: IFFALSE 17483
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
17469: LD_VAR 0 5
17473: PPUSH
17474: CALL_OW 311
17478: PPUSH
17479: CALL_OW 121
// end ;
17483: GO 17395
17485: POP
17486: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
17487: LD_VAR 0 2
17491: PPUSH
17492: LD_INT 95
17494: PUSH
17495: LD_EXP 82
17499: PUSH
17500: LD_VAR 0 1
17504: ARRAY
17505: PUSH
17506: EMPTY
17507: LIST
17508: LIST
17509: PPUSH
17510: CALL_OW 72
17514: PUSH
17515: LD_VAR 0 2
17519: EQUAL
17520: PUSH
17521: LD_EXP 81
17525: PUSH
17526: LD_VAR 0 1
17530: ARRAY
17531: OR
17532: IFFALSE 17378
// end ; MC_Reset ( base , 20 ) ;
17534: LD_VAR 0 1
17538: PPUSH
17539: LD_INT 20
17541: PPUSH
17542: CALL 60572 0 2
// end ;
17546: LD_VAR 0 4
17550: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17551: LD_INT 0
17553: PPUSH
17554: PPUSH
17555: PPUSH
17556: PPUSH
// result := false ;
17557: LD_ADDR_VAR 0 2
17561: PUSH
17562: LD_INT 0
17564: ST_TO_ADDR
// side := GetSide ( unit ) ;
17565: LD_ADDR_VAR 0 3
17569: PUSH
17570: LD_VAR 0 1
17574: PPUSH
17575: CALL_OW 255
17579: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17580: LD_ADDR_VAR 0 4
17584: PUSH
17585: LD_VAR 0 1
17589: PPUSH
17590: CALL_OW 248
17594: ST_TO_ADDR
// case nat of 1 :
17595: LD_VAR 0 4
17599: PUSH
17600: LD_INT 1
17602: DOUBLE
17603: EQUAL
17604: IFTRUE 17608
17606: GO 17619
17608: POP
// tech := tech_lassight ; 2 :
17609: LD_ADDR_VAR 0 5
17613: PUSH
17614: LD_INT 12
17616: ST_TO_ADDR
17617: GO 17658
17619: LD_INT 2
17621: DOUBLE
17622: EQUAL
17623: IFTRUE 17627
17625: GO 17638
17627: POP
// tech := tech_mortar ; 3 :
17628: LD_ADDR_VAR 0 5
17632: PUSH
17633: LD_INT 41
17635: ST_TO_ADDR
17636: GO 17658
17638: LD_INT 3
17640: DOUBLE
17641: EQUAL
17642: IFTRUE 17646
17644: GO 17657
17646: POP
// tech := tech_bazooka ; end ;
17647: LD_ADDR_VAR 0 5
17651: PUSH
17652: LD_INT 44
17654: ST_TO_ADDR
17655: GO 17658
17657: POP
// if Researched ( side , tech ) then
17658: LD_VAR 0 3
17662: PPUSH
17663: LD_VAR 0 5
17667: PPUSH
17668: CALL_OW 325
17672: IFFALSE 17699
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17674: LD_ADDR_VAR 0 2
17678: PUSH
17679: LD_INT 5
17681: PUSH
17682: LD_INT 8
17684: PUSH
17685: LD_INT 9
17687: PUSH
17688: EMPTY
17689: LIST
17690: LIST
17691: LIST
17692: PUSH
17693: LD_VAR 0 4
17697: ARRAY
17698: ST_TO_ADDR
// end ;
17699: LD_VAR 0 2
17703: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17704: LD_INT 0
17706: PPUSH
17707: PPUSH
17708: PPUSH
// if not mines then
17709: LD_VAR 0 2
17713: NOT
17714: IFFALSE 17718
// exit ;
17716: GO 17862
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17718: LD_ADDR_VAR 0 5
17722: PUSH
17723: LD_INT 81
17725: PUSH
17726: LD_VAR 0 1
17730: PUSH
17731: EMPTY
17732: LIST
17733: LIST
17734: PUSH
17735: LD_INT 3
17737: PUSH
17738: LD_INT 21
17740: PUSH
17741: LD_INT 3
17743: PUSH
17744: EMPTY
17745: LIST
17746: LIST
17747: PUSH
17748: EMPTY
17749: LIST
17750: LIST
17751: PUSH
17752: EMPTY
17753: LIST
17754: LIST
17755: PPUSH
17756: CALL_OW 69
17760: ST_TO_ADDR
// for i in mines do
17761: LD_ADDR_VAR 0 4
17765: PUSH
17766: LD_VAR 0 2
17770: PUSH
17771: FOR_IN
17772: IFFALSE 17860
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
17774: LD_VAR 0 4
17778: PUSH
17779: LD_INT 1
17781: ARRAY
17782: PPUSH
17783: LD_VAR 0 4
17787: PUSH
17788: LD_INT 2
17790: ARRAY
17791: PPUSH
17792: CALL_OW 458
17796: NOT
17797: IFFALSE 17801
// continue ;
17799: GO 17771
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
17801: LD_VAR 0 4
17805: PUSH
17806: LD_INT 1
17808: ARRAY
17809: PPUSH
17810: LD_VAR 0 4
17814: PUSH
17815: LD_INT 2
17817: ARRAY
17818: PPUSH
17819: CALL_OW 428
17823: PUSH
17824: LD_VAR 0 5
17828: IN
17829: IFFALSE 17858
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17831: LD_VAR 0 4
17835: PUSH
17836: LD_INT 1
17838: ARRAY
17839: PPUSH
17840: LD_VAR 0 4
17844: PUSH
17845: LD_INT 2
17847: ARRAY
17848: PPUSH
17849: LD_VAR 0 1
17853: PPUSH
17854: CALL_OW 456
// end ;
17858: GO 17771
17860: POP
17861: POP
// end ;
17862: LD_VAR 0 3
17866: RET
// export function Count ( array ) ; var i ; begin
17867: LD_INT 0
17869: PPUSH
17870: PPUSH
// result := 0 ;
17871: LD_ADDR_VAR 0 2
17875: PUSH
17876: LD_INT 0
17878: ST_TO_ADDR
// for i in array do
17879: LD_ADDR_VAR 0 3
17883: PUSH
17884: LD_VAR 0 1
17888: PUSH
17889: FOR_IN
17890: IFFALSE 17914
// if i then
17892: LD_VAR 0 3
17896: IFFALSE 17912
// result := result + 1 ;
17898: LD_ADDR_VAR 0 2
17902: PUSH
17903: LD_VAR 0 2
17907: PUSH
17908: LD_INT 1
17910: PLUS
17911: ST_TO_ADDR
17912: GO 17889
17914: POP
17915: POP
// end ;
17916: LD_VAR 0 2
17920: RET
// export function IsEmpty ( building ) ; begin
17921: LD_INT 0
17923: PPUSH
// if not building then
17924: LD_VAR 0 1
17928: NOT
17929: IFFALSE 17933
// exit ;
17931: GO 17976
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17933: LD_ADDR_VAR 0 2
17937: PUSH
17938: LD_VAR 0 1
17942: PUSH
17943: LD_INT 22
17945: PUSH
17946: LD_VAR 0 1
17950: PPUSH
17951: CALL_OW 255
17955: PUSH
17956: EMPTY
17957: LIST
17958: LIST
17959: PUSH
17960: LD_INT 58
17962: PUSH
17963: EMPTY
17964: LIST
17965: PUSH
17966: EMPTY
17967: LIST
17968: LIST
17969: PPUSH
17970: CALL_OW 69
17974: IN
17975: ST_TO_ADDR
// end ;
17976: LD_VAR 0 2
17980: RET
// export function IsNotFull ( building ) ; begin
17981: LD_INT 0
17983: PPUSH
// if not building then
17984: LD_VAR 0 1
17988: NOT
17989: IFFALSE 17993
// exit ;
17991: GO 18012
// result := UnitsInside ( building ) < 6 ;
17993: LD_ADDR_VAR 0 2
17997: PUSH
17998: LD_VAR 0 1
18002: PPUSH
18003: CALL_OW 313
18007: PUSH
18008: LD_INT 6
18010: LESS
18011: ST_TO_ADDR
// end ;
18012: LD_VAR 0 2
18016: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18017: LD_INT 0
18019: PPUSH
18020: PPUSH
18021: PPUSH
18022: PPUSH
// tmp := [ ] ;
18023: LD_ADDR_VAR 0 3
18027: PUSH
18028: EMPTY
18029: ST_TO_ADDR
// list := [ ] ;
18030: LD_ADDR_VAR 0 5
18034: PUSH
18035: EMPTY
18036: ST_TO_ADDR
// for i = 16 to 25 do
18037: LD_ADDR_VAR 0 4
18041: PUSH
18042: DOUBLE
18043: LD_INT 16
18045: DEC
18046: ST_TO_ADDR
18047: LD_INT 25
18049: PUSH
18050: FOR_TO
18051: IFFALSE 18124
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18053: LD_ADDR_VAR 0 3
18057: PUSH
18058: LD_VAR 0 3
18062: PUSH
18063: LD_INT 22
18065: PUSH
18066: LD_VAR 0 1
18070: PPUSH
18071: CALL_OW 255
18075: PUSH
18076: EMPTY
18077: LIST
18078: LIST
18079: PUSH
18080: LD_INT 91
18082: PUSH
18083: LD_VAR 0 1
18087: PUSH
18088: LD_INT 6
18090: PUSH
18091: EMPTY
18092: LIST
18093: LIST
18094: LIST
18095: PUSH
18096: LD_INT 30
18098: PUSH
18099: LD_VAR 0 4
18103: PUSH
18104: EMPTY
18105: LIST
18106: LIST
18107: PUSH
18108: EMPTY
18109: LIST
18110: LIST
18111: LIST
18112: PUSH
18113: EMPTY
18114: LIST
18115: PPUSH
18116: CALL_OW 69
18120: ADD
18121: ST_TO_ADDR
18122: GO 18050
18124: POP
18125: POP
// for i = 1 to tmp do
18126: LD_ADDR_VAR 0 4
18130: PUSH
18131: DOUBLE
18132: LD_INT 1
18134: DEC
18135: ST_TO_ADDR
18136: LD_VAR 0 3
18140: PUSH
18141: FOR_TO
18142: IFFALSE 18230
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18144: LD_ADDR_VAR 0 5
18148: PUSH
18149: LD_VAR 0 5
18153: PUSH
18154: LD_VAR 0 3
18158: PUSH
18159: LD_VAR 0 4
18163: ARRAY
18164: PPUSH
18165: CALL_OW 266
18169: PUSH
18170: LD_VAR 0 3
18174: PUSH
18175: LD_VAR 0 4
18179: ARRAY
18180: PPUSH
18181: CALL_OW 250
18185: PUSH
18186: LD_VAR 0 3
18190: PUSH
18191: LD_VAR 0 4
18195: ARRAY
18196: PPUSH
18197: CALL_OW 251
18201: PUSH
18202: LD_VAR 0 3
18206: PUSH
18207: LD_VAR 0 4
18211: ARRAY
18212: PPUSH
18213: CALL_OW 254
18217: PUSH
18218: EMPTY
18219: LIST
18220: LIST
18221: LIST
18222: LIST
18223: PUSH
18224: EMPTY
18225: LIST
18226: ADD
18227: ST_TO_ADDR
18228: GO 18141
18230: POP
18231: POP
// result := list ;
18232: LD_ADDR_VAR 0 2
18236: PUSH
18237: LD_VAR 0 5
18241: ST_TO_ADDR
// end ;
18242: LD_VAR 0 2
18246: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18247: LD_INT 0
18249: PPUSH
18250: PPUSH
18251: PPUSH
18252: PPUSH
18253: PPUSH
18254: PPUSH
18255: PPUSH
// if not factory then
18256: LD_VAR 0 1
18260: NOT
18261: IFFALSE 18265
// exit ;
18263: GO 18797
// if control = control_apeman then
18265: LD_VAR 0 4
18269: PUSH
18270: LD_INT 5
18272: EQUAL
18273: IFFALSE 18382
// begin tmp := UnitsInside ( factory ) ;
18275: LD_ADDR_VAR 0 8
18279: PUSH
18280: LD_VAR 0 1
18284: PPUSH
18285: CALL_OW 313
18289: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18290: LD_VAR 0 8
18294: PPUSH
18295: LD_INT 25
18297: PUSH
18298: LD_INT 12
18300: PUSH
18301: EMPTY
18302: LIST
18303: LIST
18304: PPUSH
18305: CALL_OW 72
18309: NOT
18310: IFFALSE 18320
// control := control_manual ;
18312: LD_ADDR_VAR 0 4
18316: PUSH
18317: LD_INT 1
18319: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18320: LD_ADDR_VAR 0 8
18324: PUSH
18325: LD_VAR 0 1
18329: PPUSH
18330: CALL 18017 0 1
18334: ST_TO_ADDR
// if tmp then
18335: LD_VAR 0 8
18339: IFFALSE 18382
// begin for i in tmp do
18341: LD_ADDR_VAR 0 7
18345: PUSH
18346: LD_VAR 0 8
18350: PUSH
18351: FOR_IN
18352: IFFALSE 18380
// if i [ 1 ] = b_ext_radio then
18354: LD_VAR 0 7
18358: PUSH
18359: LD_INT 1
18361: ARRAY
18362: PUSH
18363: LD_INT 22
18365: EQUAL
18366: IFFALSE 18378
// begin control := control_remote ;
18368: LD_ADDR_VAR 0 4
18372: PUSH
18373: LD_INT 2
18375: ST_TO_ADDR
// break ;
18376: GO 18380
// end ;
18378: GO 18351
18380: POP
18381: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18382: LD_VAR 0 1
18386: PPUSH
18387: LD_VAR 0 2
18391: PPUSH
18392: LD_VAR 0 3
18396: PPUSH
18397: LD_VAR 0 4
18401: PPUSH
18402: LD_VAR 0 5
18406: PPUSH
18407: CALL_OW 448
18411: IFFALSE 18446
// begin result := [ chassis , engine , control , weapon ] ;
18413: LD_ADDR_VAR 0 6
18417: PUSH
18418: LD_VAR 0 2
18422: PUSH
18423: LD_VAR 0 3
18427: PUSH
18428: LD_VAR 0 4
18432: PUSH
18433: LD_VAR 0 5
18437: PUSH
18438: EMPTY
18439: LIST
18440: LIST
18441: LIST
18442: LIST
18443: ST_TO_ADDR
// exit ;
18444: GO 18797
// end ; _chassis := AvailableChassisList ( factory ) ;
18446: LD_ADDR_VAR 0 9
18450: PUSH
18451: LD_VAR 0 1
18455: PPUSH
18456: CALL_OW 475
18460: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18461: LD_ADDR_VAR 0 11
18465: PUSH
18466: LD_VAR 0 1
18470: PPUSH
18471: CALL_OW 476
18475: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18476: LD_ADDR_VAR 0 12
18480: PUSH
18481: LD_VAR 0 1
18485: PPUSH
18486: CALL_OW 477
18490: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18491: LD_ADDR_VAR 0 10
18495: PUSH
18496: LD_VAR 0 1
18500: PPUSH
18501: CALL_OW 478
18505: ST_TO_ADDR
// if not chassis in _chassis then
18506: LD_VAR 0 2
18510: PUSH
18511: LD_VAR 0 9
18515: IN
18516: NOT
18517: IFFALSE 18543
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18519: LD_ADDR_VAR 0 2
18523: PUSH
18524: LD_VAR 0 9
18528: PUSH
18529: LD_INT 1
18531: PPUSH
18532: LD_VAR 0 9
18536: PPUSH
18537: CALL_OW 12
18541: ARRAY
18542: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18543: LD_VAR 0 2
18547: PPUSH
18548: LD_VAR 0 3
18552: PPUSH
18553: CALL 18802 0 2
18557: NOT
18558: IFFALSE 18617
// repeat engine := _engine [ 1 ] ;
18560: LD_ADDR_VAR 0 3
18564: PUSH
18565: LD_VAR 0 11
18569: PUSH
18570: LD_INT 1
18572: ARRAY
18573: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18574: LD_ADDR_VAR 0 11
18578: PUSH
18579: LD_VAR 0 11
18583: PPUSH
18584: LD_INT 1
18586: PPUSH
18587: CALL_OW 3
18591: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18592: LD_VAR 0 2
18596: PPUSH
18597: LD_VAR 0 3
18601: PPUSH
18602: CALL 18802 0 2
18606: PUSH
18607: LD_VAR 0 11
18611: PUSH
18612: EMPTY
18613: EQUAL
18614: OR
18615: IFFALSE 18560
// if not control in _control then
18617: LD_VAR 0 4
18621: PUSH
18622: LD_VAR 0 12
18626: IN
18627: NOT
18628: IFFALSE 18654
// control := _control [ rand ( 1 , _control ) ] ;
18630: LD_ADDR_VAR 0 4
18634: PUSH
18635: LD_VAR 0 12
18639: PUSH
18640: LD_INT 1
18642: PPUSH
18643: LD_VAR 0 12
18647: PPUSH
18648: CALL_OW 12
18652: ARRAY
18653: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18654: LD_VAR 0 2
18658: PPUSH
18659: LD_VAR 0 5
18663: PPUSH
18664: CALL 19022 0 2
18668: NOT
18669: IFFALSE 18728
// repeat weapon := _weapon [ 1 ] ;
18671: LD_ADDR_VAR 0 5
18675: PUSH
18676: LD_VAR 0 10
18680: PUSH
18681: LD_INT 1
18683: ARRAY
18684: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18685: LD_ADDR_VAR 0 10
18689: PUSH
18690: LD_VAR 0 10
18694: PPUSH
18695: LD_INT 1
18697: PPUSH
18698: CALL_OW 3
18702: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18703: LD_VAR 0 2
18707: PPUSH
18708: LD_VAR 0 5
18712: PPUSH
18713: CALL 19022 0 2
18717: PUSH
18718: LD_VAR 0 10
18722: PUSH
18723: EMPTY
18724: EQUAL
18725: OR
18726: IFFALSE 18671
// result := [ ] ;
18728: LD_ADDR_VAR 0 6
18732: PUSH
18733: EMPTY
18734: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18735: LD_VAR 0 1
18739: PPUSH
18740: LD_VAR 0 2
18744: PPUSH
18745: LD_VAR 0 3
18749: PPUSH
18750: LD_VAR 0 4
18754: PPUSH
18755: LD_VAR 0 5
18759: PPUSH
18760: CALL_OW 448
18764: IFFALSE 18797
// result := [ chassis , engine , control , weapon ] ;
18766: LD_ADDR_VAR 0 6
18770: PUSH
18771: LD_VAR 0 2
18775: PUSH
18776: LD_VAR 0 3
18780: PUSH
18781: LD_VAR 0 4
18785: PUSH
18786: LD_VAR 0 5
18790: PUSH
18791: EMPTY
18792: LIST
18793: LIST
18794: LIST
18795: LIST
18796: ST_TO_ADDR
// end ;
18797: LD_VAR 0 6
18801: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18802: LD_INT 0
18804: PPUSH
// if not chassis or not engine then
18805: LD_VAR 0 1
18809: NOT
18810: PUSH
18811: LD_VAR 0 2
18815: NOT
18816: OR
18817: IFFALSE 18821
// exit ;
18819: GO 19017
// case engine of engine_solar :
18821: LD_VAR 0 2
18825: PUSH
18826: LD_INT 2
18828: DOUBLE
18829: EQUAL
18830: IFTRUE 18834
18832: GO 18872
18834: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18835: LD_ADDR_VAR 0 3
18839: PUSH
18840: LD_INT 11
18842: PUSH
18843: LD_INT 12
18845: PUSH
18846: LD_INT 13
18848: PUSH
18849: LD_INT 14
18851: PUSH
18852: LD_INT 1
18854: PUSH
18855: LD_INT 2
18857: PUSH
18858: LD_INT 3
18860: PUSH
18861: EMPTY
18862: LIST
18863: LIST
18864: LIST
18865: LIST
18866: LIST
18867: LIST
18868: LIST
18869: ST_TO_ADDR
18870: GO 19001
18872: LD_INT 1
18874: DOUBLE
18875: EQUAL
18876: IFTRUE 18880
18878: GO 18942
18880: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18881: LD_ADDR_VAR 0 3
18885: PUSH
18886: LD_INT 11
18888: PUSH
18889: LD_INT 12
18891: PUSH
18892: LD_INT 13
18894: PUSH
18895: LD_INT 14
18897: PUSH
18898: LD_INT 1
18900: PUSH
18901: LD_INT 2
18903: PUSH
18904: LD_INT 3
18906: PUSH
18907: LD_INT 4
18909: PUSH
18910: LD_INT 5
18912: PUSH
18913: LD_INT 21
18915: PUSH
18916: LD_INT 23
18918: PUSH
18919: LD_INT 22
18921: PUSH
18922: LD_INT 24
18924: PUSH
18925: EMPTY
18926: LIST
18927: LIST
18928: LIST
18929: LIST
18930: LIST
18931: LIST
18932: LIST
18933: LIST
18934: LIST
18935: LIST
18936: LIST
18937: LIST
18938: LIST
18939: ST_TO_ADDR
18940: GO 19001
18942: LD_INT 3
18944: DOUBLE
18945: EQUAL
18946: IFTRUE 18950
18948: GO 19000
18950: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18951: LD_ADDR_VAR 0 3
18955: PUSH
18956: LD_INT 13
18958: PUSH
18959: LD_INT 14
18961: PUSH
18962: LD_INT 2
18964: PUSH
18965: LD_INT 3
18967: PUSH
18968: LD_INT 4
18970: PUSH
18971: LD_INT 5
18973: PUSH
18974: LD_INT 21
18976: PUSH
18977: LD_INT 22
18979: PUSH
18980: LD_INT 23
18982: PUSH
18983: LD_INT 24
18985: PUSH
18986: EMPTY
18987: LIST
18988: LIST
18989: LIST
18990: LIST
18991: LIST
18992: LIST
18993: LIST
18994: LIST
18995: LIST
18996: LIST
18997: ST_TO_ADDR
18998: GO 19001
19000: POP
// result := ( chassis in result ) ;
19001: LD_ADDR_VAR 0 3
19005: PUSH
19006: LD_VAR 0 1
19010: PUSH
19011: LD_VAR 0 3
19015: IN
19016: ST_TO_ADDR
// end ;
19017: LD_VAR 0 3
19021: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19022: LD_INT 0
19024: PPUSH
// if not chassis or not weapon then
19025: LD_VAR 0 1
19029: NOT
19030: PUSH
19031: LD_VAR 0 2
19035: NOT
19036: OR
19037: IFFALSE 19041
// exit ;
19039: GO 20067
// case weapon of us_machine_gun :
19041: LD_VAR 0 2
19045: PUSH
19046: LD_INT 2
19048: DOUBLE
19049: EQUAL
19050: IFTRUE 19054
19052: GO 19084
19054: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19055: LD_ADDR_VAR 0 3
19059: PUSH
19060: LD_INT 1
19062: PUSH
19063: LD_INT 2
19065: PUSH
19066: LD_INT 3
19068: PUSH
19069: LD_INT 4
19071: PUSH
19072: LD_INT 5
19074: PUSH
19075: EMPTY
19076: LIST
19077: LIST
19078: LIST
19079: LIST
19080: LIST
19081: ST_TO_ADDR
19082: GO 20051
19084: LD_INT 3
19086: DOUBLE
19087: EQUAL
19088: IFTRUE 19092
19090: GO 19122
19092: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19093: LD_ADDR_VAR 0 3
19097: PUSH
19098: LD_INT 1
19100: PUSH
19101: LD_INT 2
19103: PUSH
19104: LD_INT 3
19106: PUSH
19107: LD_INT 4
19109: PUSH
19110: LD_INT 5
19112: PUSH
19113: EMPTY
19114: LIST
19115: LIST
19116: LIST
19117: LIST
19118: LIST
19119: ST_TO_ADDR
19120: GO 20051
19122: LD_INT 11
19124: DOUBLE
19125: EQUAL
19126: IFTRUE 19130
19128: GO 19160
19130: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19131: LD_ADDR_VAR 0 3
19135: PUSH
19136: LD_INT 1
19138: PUSH
19139: LD_INT 2
19141: PUSH
19142: LD_INT 3
19144: PUSH
19145: LD_INT 4
19147: PUSH
19148: LD_INT 5
19150: PUSH
19151: EMPTY
19152: LIST
19153: LIST
19154: LIST
19155: LIST
19156: LIST
19157: ST_TO_ADDR
19158: GO 20051
19160: LD_INT 4
19162: DOUBLE
19163: EQUAL
19164: IFTRUE 19168
19166: GO 19194
19168: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19169: LD_ADDR_VAR 0 3
19173: PUSH
19174: LD_INT 2
19176: PUSH
19177: LD_INT 3
19179: PUSH
19180: LD_INT 4
19182: PUSH
19183: LD_INT 5
19185: PUSH
19186: EMPTY
19187: LIST
19188: LIST
19189: LIST
19190: LIST
19191: ST_TO_ADDR
19192: GO 20051
19194: LD_INT 5
19196: DOUBLE
19197: EQUAL
19198: IFTRUE 19202
19200: GO 19228
19202: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19203: LD_ADDR_VAR 0 3
19207: PUSH
19208: LD_INT 2
19210: PUSH
19211: LD_INT 3
19213: PUSH
19214: LD_INT 4
19216: PUSH
19217: LD_INT 5
19219: PUSH
19220: EMPTY
19221: LIST
19222: LIST
19223: LIST
19224: LIST
19225: ST_TO_ADDR
19226: GO 20051
19228: LD_INT 9
19230: DOUBLE
19231: EQUAL
19232: IFTRUE 19236
19234: GO 19262
19236: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19237: LD_ADDR_VAR 0 3
19241: PUSH
19242: LD_INT 2
19244: PUSH
19245: LD_INT 3
19247: PUSH
19248: LD_INT 4
19250: PUSH
19251: LD_INT 5
19253: PUSH
19254: EMPTY
19255: LIST
19256: LIST
19257: LIST
19258: LIST
19259: ST_TO_ADDR
19260: GO 20051
19262: LD_INT 7
19264: DOUBLE
19265: EQUAL
19266: IFTRUE 19270
19268: GO 19296
19270: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19271: LD_ADDR_VAR 0 3
19275: PUSH
19276: LD_INT 2
19278: PUSH
19279: LD_INT 3
19281: PUSH
19282: LD_INT 4
19284: PUSH
19285: LD_INT 5
19287: PUSH
19288: EMPTY
19289: LIST
19290: LIST
19291: LIST
19292: LIST
19293: ST_TO_ADDR
19294: GO 20051
19296: LD_INT 12
19298: DOUBLE
19299: EQUAL
19300: IFTRUE 19304
19302: GO 19330
19304: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
19305: LD_ADDR_VAR 0 3
19309: PUSH
19310: LD_INT 2
19312: PUSH
19313: LD_INT 3
19315: PUSH
19316: LD_INT 4
19318: PUSH
19319: LD_INT 5
19321: PUSH
19322: EMPTY
19323: LIST
19324: LIST
19325: LIST
19326: LIST
19327: ST_TO_ADDR
19328: GO 20051
19330: LD_INT 13
19332: DOUBLE
19333: EQUAL
19334: IFTRUE 19338
19336: GO 19364
19338: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
19339: LD_ADDR_VAR 0 3
19343: PUSH
19344: LD_INT 2
19346: PUSH
19347: LD_INT 3
19349: PUSH
19350: LD_INT 4
19352: PUSH
19353: LD_INT 5
19355: PUSH
19356: EMPTY
19357: LIST
19358: LIST
19359: LIST
19360: LIST
19361: ST_TO_ADDR
19362: GO 20051
19364: LD_INT 14
19366: DOUBLE
19367: EQUAL
19368: IFTRUE 19372
19370: GO 19390
19372: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
19373: LD_ADDR_VAR 0 3
19377: PUSH
19378: LD_INT 4
19380: PUSH
19381: LD_INT 5
19383: PUSH
19384: EMPTY
19385: LIST
19386: LIST
19387: ST_TO_ADDR
19388: GO 20051
19390: LD_INT 6
19392: DOUBLE
19393: EQUAL
19394: IFTRUE 19398
19396: GO 19416
19398: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19399: LD_ADDR_VAR 0 3
19403: PUSH
19404: LD_INT 4
19406: PUSH
19407: LD_INT 5
19409: PUSH
19410: EMPTY
19411: LIST
19412: LIST
19413: ST_TO_ADDR
19414: GO 20051
19416: LD_INT 10
19418: DOUBLE
19419: EQUAL
19420: IFTRUE 19424
19422: GO 19442
19424: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19425: LD_ADDR_VAR 0 3
19429: PUSH
19430: LD_INT 4
19432: PUSH
19433: LD_INT 5
19435: PUSH
19436: EMPTY
19437: LIST
19438: LIST
19439: ST_TO_ADDR
19440: GO 20051
19442: LD_INT 22
19444: DOUBLE
19445: EQUAL
19446: IFTRUE 19450
19448: GO 19476
19450: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19451: LD_ADDR_VAR 0 3
19455: PUSH
19456: LD_INT 11
19458: PUSH
19459: LD_INT 12
19461: PUSH
19462: LD_INT 13
19464: PUSH
19465: LD_INT 14
19467: PUSH
19468: EMPTY
19469: LIST
19470: LIST
19471: LIST
19472: LIST
19473: ST_TO_ADDR
19474: GO 20051
19476: LD_INT 23
19478: DOUBLE
19479: EQUAL
19480: IFTRUE 19484
19482: GO 19510
19484: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19485: LD_ADDR_VAR 0 3
19489: PUSH
19490: LD_INT 11
19492: PUSH
19493: LD_INT 12
19495: PUSH
19496: LD_INT 13
19498: PUSH
19499: LD_INT 14
19501: PUSH
19502: EMPTY
19503: LIST
19504: LIST
19505: LIST
19506: LIST
19507: ST_TO_ADDR
19508: GO 20051
19510: LD_INT 24
19512: DOUBLE
19513: EQUAL
19514: IFTRUE 19518
19516: GO 19544
19518: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19519: LD_ADDR_VAR 0 3
19523: PUSH
19524: LD_INT 11
19526: PUSH
19527: LD_INT 12
19529: PUSH
19530: LD_INT 13
19532: PUSH
19533: LD_INT 14
19535: PUSH
19536: EMPTY
19537: LIST
19538: LIST
19539: LIST
19540: LIST
19541: ST_TO_ADDR
19542: GO 20051
19544: LD_INT 30
19546: DOUBLE
19547: EQUAL
19548: IFTRUE 19552
19550: GO 19578
19552: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19553: LD_ADDR_VAR 0 3
19557: PUSH
19558: LD_INT 11
19560: PUSH
19561: LD_INT 12
19563: PUSH
19564: LD_INT 13
19566: PUSH
19567: LD_INT 14
19569: PUSH
19570: EMPTY
19571: LIST
19572: LIST
19573: LIST
19574: LIST
19575: ST_TO_ADDR
19576: GO 20051
19578: LD_INT 25
19580: DOUBLE
19581: EQUAL
19582: IFTRUE 19586
19584: GO 19604
19586: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19587: LD_ADDR_VAR 0 3
19591: PUSH
19592: LD_INT 13
19594: PUSH
19595: LD_INT 14
19597: PUSH
19598: EMPTY
19599: LIST
19600: LIST
19601: ST_TO_ADDR
19602: GO 20051
19604: LD_INT 27
19606: DOUBLE
19607: EQUAL
19608: IFTRUE 19612
19610: GO 19630
19612: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19613: LD_ADDR_VAR 0 3
19617: PUSH
19618: LD_INT 13
19620: PUSH
19621: LD_INT 14
19623: PUSH
19624: EMPTY
19625: LIST
19626: LIST
19627: ST_TO_ADDR
19628: GO 20051
19630: LD_INT 28
19632: DOUBLE
19633: EQUAL
19634: IFTRUE 19638
19636: GO 19656
19638: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19639: LD_ADDR_VAR 0 3
19643: PUSH
19644: LD_INT 13
19646: PUSH
19647: LD_INT 14
19649: PUSH
19650: EMPTY
19651: LIST
19652: LIST
19653: ST_TO_ADDR
19654: GO 20051
19656: LD_INT 29
19658: DOUBLE
19659: EQUAL
19660: IFTRUE 19664
19662: GO 19682
19664: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19665: LD_ADDR_VAR 0 3
19669: PUSH
19670: LD_INT 13
19672: PUSH
19673: LD_INT 14
19675: PUSH
19676: EMPTY
19677: LIST
19678: LIST
19679: ST_TO_ADDR
19680: GO 20051
19682: LD_INT 31
19684: DOUBLE
19685: EQUAL
19686: IFTRUE 19690
19688: GO 19708
19690: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19691: LD_ADDR_VAR 0 3
19695: PUSH
19696: LD_INT 13
19698: PUSH
19699: LD_INT 14
19701: PUSH
19702: EMPTY
19703: LIST
19704: LIST
19705: ST_TO_ADDR
19706: GO 20051
19708: LD_INT 26
19710: DOUBLE
19711: EQUAL
19712: IFTRUE 19716
19714: GO 19734
19716: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19717: LD_ADDR_VAR 0 3
19721: PUSH
19722: LD_INT 13
19724: PUSH
19725: LD_INT 14
19727: PUSH
19728: EMPTY
19729: LIST
19730: LIST
19731: ST_TO_ADDR
19732: GO 20051
19734: LD_INT 42
19736: DOUBLE
19737: EQUAL
19738: IFTRUE 19742
19740: GO 19768
19742: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19743: LD_ADDR_VAR 0 3
19747: PUSH
19748: LD_INT 21
19750: PUSH
19751: LD_INT 22
19753: PUSH
19754: LD_INT 23
19756: PUSH
19757: LD_INT 24
19759: PUSH
19760: EMPTY
19761: LIST
19762: LIST
19763: LIST
19764: LIST
19765: ST_TO_ADDR
19766: GO 20051
19768: LD_INT 43
19770: DOUBLE
19771: EQUAL
19772: IFTRUE 19776
19774: GO 19802
19776: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19777: LD_ADDR_VAR 0 3
19781: PUSH
19782: LD_INT 21
19784: PUSH
19785: LD_INT 22
19787: PUSH
19788: LD_INT 23
19790: PUSH
19791: LD_INT 24
19793: PUSH
19794: EMPTY
19795: LIST
19796: LIST
19797: LIST
19798: LIST
19799: ST_TO_ADDR
19800: GO 20051
19802: LD_INT 44
19804: DOUBLE
19805: EQUAL
19806: IFTRUE 19810
19808: GO 19836
19810: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19811: LD_ADDR_VAR 0 3
19815: PUSH
19816: LD_INT 21
19818: PUSH
19819: LD_INT 22
19821: PUSH
19822: LD_INT 23
19824: PUSH
19825: LD_INT 24
19827: PUSH
19828: EMPTY
19829: LIST
19830: LIST
19831: LIST
19832: LIST
19833: ST_TO_ADDR
19834: GO 20051
19836: LD_INT 45
19838: DOUBLE
19839: EQUAL
19840: IFTRUE 19844
19842: GO 19870
19844: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19845: LD_ADDR_VAR 0 3
19849: PUSH
19850: LD_INT 21
19852: PUSH
19853: LD_INT 22
19855: PUSH
19856: LD_INT 23
19858: PUSH
19859: LD_INT 24
19861: PUSH
19862: EMPTY
19863: LIST
19864: LIST
19865: LIST
19866: LIST
19867: ST_TO_ADDR
19868: GO 20051
19870: LD_INT 49
19872: DOUBLE
19873: EQUAL
19874: IFTRUE 19878
19876: GO 19904
19878: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19879: LD_ADDR_VAR 0 3
19883: PUSH
19884: LD_INT 21
19886: PUSH
19887: LD_INT 22
19889: PUSH
19890: LD_INT 23
19892: PUSH
19893: LD_INT 24
19895: PUSH
19896: EMPTY
19897: LIST
19898: LIST
19899: LIST
19900: LIST
19901: ST_TO_ADDR
19902: GO 20051
19904: LD_INT 51
19906: DOUBLE
19907: EQUAL
19908: IFTRUE 19912
19910: GO 19938
19912: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19913: LD_ADDR_VAR 0 3
19917: PUSH
19918: LD_INT 21
19920: PUSH
19921: LD_INT 22
19923: PUSH
19924: LD_INT 23
19926: PUSH
19927: LD_INT 24
19929: PUSH
19930: EMPTY
19931: LIST
19932: LIST
19933: LIST
19934: LIST
19935: ST_TO_ADDR
19936: GO 20051
19938: LD_INT 52
19940: DOUBLE
19941: EQUAL
19942: IFTRUE 19946
19944: GO 19972
19946: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19947: LD_ADDR_VAR 0 3
19951: PUSH
19952: LD_INT 21
19954: PUSH
19955: LD_INT 22
19957: PUSH
19958: LD_INT 23
19960: PUSH
19961: LD_INT 24
19963: PUSH
19964: EMPTY
19965: LIST
19966: LIST
19967: LIST
19968: LIST
19969: ST_TO_ADDR
19970: GO 20051
19972: LD_INT 53
19974: DOUBLE
19975: EQUAL
19976: IFTRUE 19980
19978: GO 19998
19980: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19981: LD_ADDR_VAR 0 3
19985: PUSH
19986: LD_INT 23
19988: PUSH
19989: LD_INT 24
19991: PUSH
19992: EMPTY
19993: LIST
19994: LIST
19995: ST_TO_ADDR
19996: GO 20051
19998: LD_INT 46
20000: DOUBLE
20001: EQUAL
20002: IFTRUE 20006
20004: GO 20024
20006: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20007: LD_ADDR_VAR 0 3
20011: PUSH
20012: LD_INT 23
20014: PUSH
20015: LD_INT 24
20017: PUSH
20018: EMPTY
20019: LIST
20020: LIST
20021: ST_TO_ADDR
20022: GO 20051
20024: LD_INT 47
20026: DOUBLE
20027: EQUAL
20028: IFTRUE 20032
20030: GO 20050
20032: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20033: LD_ADDR_VAR 0 3
20037: PUSH
20038: LD_INT 23
20040: PUSH
20041: LD_INT 24
20043: PUSH
20044: EMPTY
20045: LIST
20046: LIST
20047: ST_TO_ADDR
20048: GO 20051
20050: POP
// result := ( chassis in result ) ;
20051: LD_ADDR_VAR 0 3
20055: PUSH
20056: LD_VAR 0 1
20060: PUSH
20061: LD_VAR 0 3
20065: IN
20066: ST_TO_ADDR
// end ;
20067: LD_VAR 0 3
20071: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20072: LD_INT 0
20074: PPUSH
20075: PPUSH
20076: PPUSH
20077: PPUSH
20078: PPUSH
20079: PPUSH
20080: PPUSH
// result := array ;
20081: LD_ADDR_VAR 0 5
20085: PUSH
20086: LD_VAR 0 1
20090: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20091: LD_VAR 0 1
20095: NOT
20096: PUSH
20097: LD_VAR 0 2
20101: NOT
20102: OR
20103: PUSH
20104: LD_VAR 0 3
20108: NOT
20109: OR
20110: PUSH
20111: LD_VAR 0 2
20115: PUSH
20116: LD_VAR 0 1
20120: GREATER
20121: OR
20122: PUSH
20123: LD_VAR 0 3
20127: PUSH
20128: LD_VAR 0 1
20132: GREATER
20133: OR
20134: IFFALSE 20138
// exit ;
20136: GO 20434
// if direction then
20138: LD_VAR 0 4
20142: IFFALSE 20206
// begin d := 1 ;
20144: LD_ADDR_VAR 0 9
20148: PUSH
20149: LD_INT 1
20151: ST_TO_ADDR
// if i_from > i_to then
20152: LD_VAR 0 2
20156: PUSH
20157: LD_VAR 0 3
20161: GREATER
20162: IFFALSE 20188
// length := ( array - i_from ) + i_to else
20164: LD_ADDR_VAR 0 11
20168: PUSH
20169: LD_VAR 0 1
20173: PUSH
20174: LD_VAR 0 2
20178: MINUS
20179: PUSH
20180: LD_VAR 0 3
20184: PLUS
20185: ST_TO_ADDR
20186: GO 20204
// length := i_to - i_from ;
20188: LD_ADDR_VAR 0 11
20192: PUSH
20193: LD_VAR 0 3
20197: PUSH
20198: LD_VAR 0 2
20202: MINUS
20203: ST_TO_ADDR
// end else
20204: GO 20267
// begin d := - 1 ;
20206: LD_ADDR_VAR 0 9
20210: PUSH
20211: LD_INT 1
20213: NEG
20214: ST_TO_ADDR
// if i_from > i_to then
20215: LD_VAR 0 2
20219: PUSH
20220: LD_VAR 0 3
20224: GREATER
20225: IFFALSE 20245
// length := i_from - i_to else
20227: LD_ADDR_VAR 0 11
20231: PUSH
20232: LD_VAR 0 2
20236: PUSH
20237: LD_VAR 0 3
20241: MINUS
20242: ST_TO_ADDR
20243: GO 20267
// length := ( array - i_to ) + i_from ;
20245: LD_ADDR_VAR 0 11
20249: PUSH
20250: LD_VAR 0 1
20254: PUSH
20255: LD_VAR 0 3
20259: MINUS
20260: PUSH
20261: LD_VAR 0 2
20265: PLUS
20266: ST_TO_ADDR
// end ; if not length then
20267: LD_VAR 0 11
20271: NOT
20272: IFFALSE 20276
// exit ;
20274: GO 20434
// tmp := array ;
20276: LD_ADDR_VAR 0 10
20280: PUSH
20281: LD_VAR 0 1
20285: ST_TO_ADDR
// for i = 1 to length do
20286: LD_ADDR_VAR 0 6
20290: PUSH
20291: DOUBLE
20292: LD_INT 1
20294: DEC
20295: ST_TO_ADDR
20296: LD_VAR 0 11
20300: PUSH
20301: FOR_TO
20302: IFFALSE 20422
// begin for j = 1 to array do
20304: LD_ADDR_VAR 0 7
20308: PUSH
20309: DOUBLE
20310: LD_INT 1
20312: DEC
20313: ST_TO_ADDR
20314: LD_VAR 0 1
20318: PUSH
20319: FOR_TO
20320: IFFALSE 20408
// begin k := j + d ;
20322: LD_ADDR_VAR 0 8
20326: PUSH
20327: LD_VAR 0 7
20331: PUSH
20332: LD_VAR 0 9
20336: PLUS
20337: ST_TO_ADDR
// if k > array then
20338: LD_VAR 0 8
20342: PUSH
20343: LD_VAR 0 1
20347: GREATER
20348: IFFALSE 20358
// k := 1 ;
20350: LD_ADDR_VAR 0 8
20354: PUSH
20355: LD_INT 1
20357: ST_TO_ADDR
// if not k then
20358: LD_VAR 0 8
20362: NOT
20363: IFFALSE 20375
// k := array ;
20365: LD_ADDR_VAR 0 8
20369: PUSH
20370: LD_VAR 0 1
20374: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
20375: LD_ADDR_VAR 0 10
20379: PUSH
20380: LD_VAR 0 10
20384: PPUSH
20385: LD_VAR 0 8
20389: PPUSH
20390: LD_VAR 0 1
20394: PUSH
20395: LD_VAR 0 7
20399: ARRAY
20400: PPUSH
20401: CALL_OW 1
20405: ST_TO_ADDR
// end ;
20406: GO 20319
20408: POP
20409: POP
// array := tmp ;
20410: LD_ADDR_VAR 0 1
20414: PUSH
20415: LD_VAR 0 10
20419: ST_TO_ADDR
// end ;
20420: GO 20301
20422: POP
20423: POP
// result := array ;
20424: LD_ADDR_VAR 0 5
20428: PUSH
20429: LD_VAR 0 1
20433: ST_TO_ADDR
// end ;
20434: LD_VAR 0 5
20438: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20439: LD_INT 0
20441: PPUSH
20442: PPUSH
// result := 0 ;
20443: LD_ADDR_VAR 0 3
20447: PUSH
20448: LD_INT 0
20450: ST_TO_ADDR
// if not array or not value in array then
20451: LD_VAR 0 1
20455: NOT
20456: PUSH
20457: LD_VAR 0 2
20461: PUSH
20462: LD_VAR 0 1
20466: IN
20467: NOT
20468: OR
20469: IFFALSE 20473
// exit ;
20471: GO 20527
// for i = 1 to array do
20473: LD_ADDR_VAR 0 4
20477: PUSH
20478: DOUBLE
20479: LD_INT 1
20481: DEC
20482: ST_TO_ADDR
20483: LD_VAR 0 1
20487: PUSH
20488: FOR_TO
20489: IFFALSE 20525
// if value = array [ i ] then
20491: LD_VAR 0 2
20495: PUSH
20496: LD_VAR 0 1
20500: PUSH
20501: LD_VAR 0 4
20505: ARRAY
20506: EQUAL
20507: IFFALSE 20523
// begin result := i ;
20509: LD_ADDR_VAR 0 3
20513: PUSH
20514: LD_VAR 0 4
20518: ST_TO_ADDR
// exit ;
20519: POP
20520: POP
20521: GO 20527
// end ;
20523: GO 20488
20525: POP
20526: POP
// end ;
20527: LD_VAR 0 3
20531: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20532: LD_INT 0
20534: PPUSH
// vc_chassis := chassis ;
20535: LD_ADDR_OWVAR 37
20539: PUSH
20540: LD_VAR 0 1
20544: ST_TO_ADDR
// vc_engine := engine ;
20545: LD_ADDR_OWVAR 39
20549: PUSH
20550: LD_VAR 0 2
20554: ST_TO_ADDR
// vc_control := control ;
20555: LD_ADDR_OWVAR 38
20559: PUSH
20560: LD_VAR 0 3
20564: ST_TO_ADDR
// vc_weapon := weapon ;
20565: LD_ADDR_OWVAR 40
20569: PUSH
20570: LD_VAR 0 4
20574: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20575: LD_ADDR_OWVAR 41
20579: PUSH
20580: LD_VAR 0 5
20584: ST_TO_ADDR
// end ;
20585: LD_VAR 0 6
20589: RET
// export function WantPlant ( unit ) ; var task ; begin
20590: LD_INT 0
20592: PPUSH
20593: PPUSH
// result := false ;
20594: LD_ADDR_VAR 0 2
20598: PUSH
20599: LD_INT 0
20601: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20602: LD_ADDR_VAR 0 3
20606: PUSH
20607: LD_VAR 0 1
20611: PPUSH
20612: CALL_OW 437
20616: ST_TO_ADDR
// if task then
20617: LD_VAR 0 3
20621: IFFALSE 20649
// if task [ 1 ] [ 1 ] = p then
20623: LD_VAR 0 3
20627: PUSH
20628: LD_INT 1
20630: ARRAY
20631: PUSH
20632: LD_INT 1
20634: ARRAY
20635: PUSH
20636: LD_STRING p
20638: EQUAL
20639: IFFALSE 20649
// result := true ;
20641: LD_ADDR_VAR 0 2
20645: PUSH
20646: LD_INT 1
20648: ST_TO_ADDR
// end ;
20649: LD_VAR 0 2
20653: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20654: LD_INT 0
20656: PPUSH
20657: PPUSH
20658: PPUSH
20659: PPUSH
// if pos < 1 then
20660: LD_VAR 0 2
20664: PUSH
20665: LD_INT 1
20667: LESS
20668: IFFALSE 20672
// exit ;
20670: GO 20975
// if pos = 1 then
20672: LD_VAR 0 2
20676: PUSH
20677: LD_INT 1
20679: EQUAL
20680: IFFALSE 20713
// result := Replace ( arr , pos [ 1 ] , value ) else
20682: LD_ADDR_VAR 0 4
20686: PUSH
20687: LD_VAR 0 1
20691: PPUSH
20692: LD_VAR 0 2
20696: PUSH
20697: LD_INT 1
20699: ARRAY
20700: PPUSH
20701: LD_VAR 0 3
20705: PPUSH
20706: CALL_OW 1
20710: ST_TO_ADDR
20711: GO 20975
// begin tmp := arr ;
20713: LD_ADDR_VAR 0 6
20717: PUSH
20718: LD_VAR 0 1
20722: ST_TO_ADDR
// s_arr := [ tmp ] ;
20723: LD_ADDR_VAR 0 7
20727: PUSH
20728: LD_VAR 0 6
20732: PUSH
20733: EMPTY
20734: LIST
20735: ST_TO_ADDR
// for i = 1 to pos - 1 do
20736: LD_ADDR_VAR 0 5
20740: PUSH
20741: DOUBLE
20742: LD_INT 1
20744: DEC
20745: ST_TO_ADDR
20746: LD_VAR 0 2
20750: PUSH
20751: LD_INT 1
20753: MINUS
20754: PUSH
20755: FOR_TO
20756: IFFALSE 20801
// begin tmp := tmp [ pos [ i ] ] ;
20758: LD_ADDR_VAR 0 6
20762: PUSH
20763: LD_VAR 0 6
20767: PUSH
20768: LD_VAR 0 2
20772: PUSH
20773: LD_VAR 0 5
20777: ARRAY
20778: ARRAY
20779: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20780: LD_ADDR_VAR 0 7
20784: PUSH
20785: LD_VAR 0 7
20789: PUSH
20790: LD_VAR 0 6
20794: PUSH
20795: EMPTY
20796: LIST
20797: ADD
20798: ST_TO_ADDR
// end ;
20799: GO 20755
20801: POP
20802: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20803: LD_ADDR_VAR 0 6
20807: PUSH
20808: LD_VAR 0 6
20812: PPUSH
20813: LD_VAR 0 2
20817: PUSH
20818: LD_VAR 0 2
20822: ARRAY
20823: PPUSH
20824: LD_VAR 0 3
20828: PPUSH
20829: CALL_OW 1
20833: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20834: LD_ADDR_VAR 0 7
20838: PUSH
20839: LD_VAR 0 7
20843: PPUSH
20844: LD_VAR 0 7
20848: PPUSH
20849: LD_VAR 0 6
20853: PPUSH
20854: CALL_OW 1
20858: ST_TO_ADDR
// for i = s_arr downto 2 do
20859: LD_ADDR_VAR 0 5
20863: PUSH
20864: DOUBLE
20865: LD_VAR 0 7
20869: INC
20870: ST_TO_ADDR
20871: LD_INT 2
20873: PUSH
20874: FOR_DOWNTO
20875: IFFALSE 20959
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20877: LD_ADDR_VAR 0 6
20881: PUSH
20882: LD_VAR 0 7
20886: PUSH
20887: LD_VAR 0 5
20891: PUSH
20892: LD_INT 1
20894: MINUS
20895: ARRAY
20896: PPUSH
20897: LD_VAR 0 2
20901: PUSH
20902: LD_VAR 0 5
20906: PUSH
20907: LD_INT 1
20909: MINUS
20910: ARRAY
20911: PPUSH
20912: LD_VAR 0 7
20916: PUSH
20917: LD_VAR 0 5
20921: ARRAY
20922: PPUSH
20923: CALL_OW 1
20927: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20928: LD_ADDR_VAR 0 7
20932: PUSH
20933: LD_VAR 0 7
20937: PPUSH
20938: LD_VAR 0 5
20942: PUSH
20943: LD_INT 1
20945: MINUS
20946: PPUSH
20947: LD_VAR 0 6
20951: PPUSH
20952: CALL_OW 1
20956: ST_TO_ADDR
// end ;
20957: GO 20874
20959: POP
20960: POP
// result := s_arr [ 1 ] ;
20961: LD_ADDR_VAR 0 4
20965: PUSH
20966: LD_VAR 0 7
20970: PUSH
20971: LD_INT 1
20973: ARRAY
20974: ST_TO_ADDR
// end ; end ;
20975: LD_VAR 0 4
20979: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20980: LD_INT 0
20982: PPUSH
20983: PPUSH
// if not list then
20984: LD_VAR 0 1
20988: NOT
20989: IFFALSE 20993
// exit ;
20991: GO 21084
// i := list [ pos1 ] ;
20993: LD_ADDR_VAR 0 5
20997: PUSH
20998: LD_VAR 0 1
21002: PUSH
21003: LD_VAR 0 2
21007: ARRAY
21008: ST_TO_ADDR
// if not i then
21009: LD_VAR 0 5
21013: NOT
21014: IFFALSE 21018
// exit ;
21016: GO 21084
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21018: LD_ADDR_VAR 0 1
21022: PUSH
21023: LD_VAR 0 1
21027: PPUSH
21028: LD_VAR 0 2
21032: PPUSH
21033: LD_VAR 0 1
21037: PUSH
21038: LD_VAR 0 3
21042: ARRAY
21043: PPUSH
21044: CALL_OW 1
21048: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21049: LD_ADDR_VAR 0 1
21053: PUSH
21054: LD_VAR 0 1
21058: PPUSH
21059: LD_VAR 0 3
21063: PPUSH
21064: LD_VAR 0 5
21068: PPUSH
21069: CALL_OW 1
21073: ST_TO_ADDR
// result := list ;
21074: LD_ADDR_VAR 0 4
21078: PUSH
21079: LD_VAR 0 1
21083: ST_TO_ADDR
// end ;
21084: LD_VAR 0 4
21088: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21089: LD_INT 0
21091: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21092: LD_ADDR_VAR 0 5
21096: PUSH
21097: LD_VAR 0 1
21101: PPUSH
21102: CALL_OW 250
21106: PPUSH
21107: LD_VAR 0 1
21111: PPUSH
21112: CALL_OW 251
21116: PPUSH
21117: LD_VAR 0 2
21121: PPUSH
21122: LD_VAR 0 3
21126: PPUSH
21127: LD_VAR 0 4
21131: PPUSH
21132: CALL 21142 0 5
21136: ST_TO_ADDR
// end ;
21137: LD_VAR 0 5
21141: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
21142: LD_INT 0
21144: PPUSH
21145: PPUSH
21146: PPUSH
21147: PPUSH
// if not list then
21148: LD_VAR 0 3
21152: NOT
21153: IFFALSE 21157
// exit ;
21155: GO 21545
// result := [ ] ;
21157: LD_ADDR_VAR 0 6
21161: PUSH
21162: EMPTY
21163: ST_TO_ADDR
// for i in list do
21164: LD_ADDR_VAR 0 7
21168: PUSH
21169: LD_VAR 0 3
21173: PUSH
21174: FOR_IN
21175: IFFALSE 21377
// begin tmp := GetDistUnitXY ( i , x , y ) ;
21177: LD_ADDR_VAR 0 9
21181: PUSH
21182: LD_VAR 0 7
21186: PPUSH
21187: LD_VAR 0 1
21191: PPUSH
21192: LD_VAR 0 2
21196: PPUSH
21197: CALL_OW 297
21201: ST_TO_ADDR
// if not result then
21202: LD_VAR 0 6
21206: NOT
21207: IFFALSE 21233
// result := [ [ i , tmp ] ] else
21209: LD_ADDR_VAR 0 6
21213: PUSH
21214: LD_VAR 0 7
21218: PUSH
21219: LD_VAR 0 9
21223: PUSH
21224: EMPTY
21225: LIST
21226: LIST
21227: PUSH
21228: EMPTY
21229: LIST
21230: ST_TO_ADDR
21231: GO 21375
// begin if result [ result ] [ 2 ] < tmp then
21233: LD_VAR 0 6
21237: PUSH
21238: LD_VAR 0 6
21242: ARRAY
21243: PUSH
21244: LD_INT 2
21246: ARRAY
21247: PUSH
21248: LD_VAR 0 9
21252: LESS
21253: IFFALSE 21295
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21255: LD_ADDR_VAR 0 6
21259: PUSH
21260: LD_VAR 0 6
21264: PPUSH
21265: LD_VAR 0 6
21269: PUSH
21270: LD_INT 1
21272: PLUS
21273: PPUSH
21274: LD_VAR 0 7
21278: PUSH
21279: LD_VAR 0 9
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: PPUSH
21288: CALL_OW 2
21292: ST_TO_ADDR
21293: GO 21375
// for j = 1 to result do
21295: LD_ADDR_VAR 0 8
21299: PUSH
21300: DOUBLE
21301: LD_INT 1
21303: DEC
21304: ST_TO_ADDR
21305: LD_VAR 0 6
21309: PUSH
21310: FOR_TO
21311: IFFALSE 21373
// begin if tmp < result [ j ] [ 2 ] then
21313: LD_VAR 0 9
21317: PUSH
21318: LD_VAR 0 6
21322: PUSH
21323: LD_VAR 0 8
21327: ARRAY
21328: PUSH
21329: LD_INT 2
21331: ARRAY
21332: LESS
21333: IFFALSE 21371
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21335: LD_ADDR_VAR 0 6
21339: PUSH
21340: LD_VAR 0 6
21344: PPUSH
21345: LD_VAR 0 8
21349: PPUSH
21350: LD_VAR 0 7
21354: PUSH
21355: LD_VAR 0 9
21359: PUSH
21360: EMPTY
21361: LIST
21362: LIST
21363: PPUSH
21364: CALL_OW 2
21368: ST_TO_ADDR
// break ;
21369: GO 21373
// end ; end ;
21371: GO 21310
21373: POP
21374: POP
// end ; end ;
21375: GO 21174
21377: POP
21378: POP
// if result and not asc then
21379: LD_VAR 0 6
21383: PUSH
21384: LD_VAR 0 4
21388: NOT
21389: AND
21390: IFFALSE 21465
// begin tmp := result ;
21392: LD_ADDR_VAR 0 9
21396: PUSH
21397: LD_VAR 0 6
21401: ST_TO_ADDR
// for i = tmp downto 1 do
21402: LD_ADDR_VAR 0 7
21406: PUSH
21407: DOUBLE
21408: LD_VAR 0 9
21412: INC
21413: ST_TO_ADDR
21414: LD_INT 1
21416: PUSH
21417: FOR_DOWNTO
21418: IFFALSE 21463
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21420: LD_ADDR_VAR 0 6
21424: PUSH
21425: LD_VAR 0 6
21429: PPUSH
21430: LD_VAR 0 9
21434: PUSH
21435: LD_VAR 0 7
21439: MINUS
21440: PUSH
21441: LD_INT 1
21443: PLUS
21444: PPUSH
21445: LD_VAR 0 9
21449: PUSH
21450: LD_VAR 0 7
21454: ARRAY
21455: PPUSH
21456: CALL_OW 1
21460: ST_TO_ADDR
21461: GO 21417
21463: POP
21464: POP
// end ; tmp := [ ] ;
21465: LD_ADDR_VAR 0 9
21469: PUSH
21470: EMPTY
21471: ST_TO_ADDR
// if mode then
21472: LD_VAR 0 5
21476: IFFALSE 21545
// begin for i = 1 to result do
21478: LD_ADDR_VAR 0 7
21482: PUSH
21483: DOUBLE
21484: LD_INT 1
21486: DEC
21487: ST_TO_ADDR
21488: LD_VAR 0 6
21492: PUSH
21493: FOR_TO
21494: IFFALSE 21533
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21496: LD_ADDR_VAR 0 9
21500: PUSH
21501: LD_VAR 0 9
21505: PPUSH
21506: LD_VAR 0 7
21510: PPUSH
21511: LD_VAR 0 6
21515: PUSH
21516: LD_VAR 0 7
21520: ARRAY
21521: PUSH
21522: LD_INT 1
21524: ARRAY
21525: PPUSH
21526: CALL_OW 1
21530: ST_TO_ADDR
21531: GO 21493
21533: POP
21534: POP
// result := tmp ;
21535: LD_ADDR_VAR 0 6
21539: PUSH
21540: LD_VAR 0 9
21544: ST_TO_ADDR
// end ; end ;
21545: LD_VAR 0 6
21549: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21550: LD_INT 0
21552: PPUSH
21553: PPUSH
21554: PPUSH
21555: PPUSH
21556: PPUSH
21557: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21558: LD_ADDR_VAR 0 5
21562: PUSH
21563: LD_INT 0
21565: PUSH
21566: LD_INT 0
21568: PUSH
21569: LD_INT 0
21571: PUSH
21572: EMPTY
21573: PUSH
21574: EMPTY
21575: LIST
21576: LIST
21577: LIST
21578: LIST
21579: ST_TO_ADDR
// if not x or not y then
21580: LD_VAR 0 2
21584: NOT
21585: PUSH
21586: LD_VAR 0 3
21590: NOT
21591: OR
21592: IFFALSE 21596
// exit ;
21594: GO 23242
// if not range then
21596: LD_VAR 0 4
21600: NOT
21601: IFFALSE 21611
// range := 10 ;
21603: LD_ADDR_VAR 0 4
21607: PUSH
21608: LD_INT 10
21610: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21611: LD_ADDR_VAR 0 8
21615: PUSH
21616: LD_INT 81
21618: PUSH
21619: LD_VAR 0 1
21623: PUSH
21624: EMPTY
21625: LIST
21626: LIST
21627: PUSH
21628: LD_INT 92
21630: PUSH
21631: LD_VAR 0 2
21635: PUSH
21636: LD_VAR 0 3
21640: PUSH
21641: LD_VAR 0 4
21645: PUSH
21646: EMPTY
21647: LIST
21648: LIST
21649: LIST
21650: LIST
21651: PUSH
21652: LD_INT 3
21654: PUSH
21655: LD_INT 21
21657: PUSH
21658: LD_INT 3
21660: PUSH
21661: EMPTY
21662: LIST
21663: LIST
21664: PUSH
21665: EMPTY
21666: LIST
21667: LIST
21668: PUSH
21669: EMPTY
21670: LIST
21671: LIST
21672: LIST
21673: PPUSH
21674: CALL_OW 69
21678: ST_TO_ADDR
// if not tmp then
21679: LD_VAR 0 8
21683: NOT
21684: IFFALSE 21688
// exit ;
21686: GO 23242
// for i in tmp do
21688: LD_ADDR_VAR 0 6
21692: PUSH
21693: LD_VAR 0 8
21697: PUSH
21698: FOR_IN
21699: IFFALSE 23217
// begin points := [ 0 , 0 , 0 ] ;
21701: LD_ADDR_VAR 0 9
21705: PUSH
21706: LD_INT 0
21708: PUSH
21709: LD_INT 0
21711: PUSH
21712: LD_INT 0
21714: PUSH
21715: EMPTY
21716: LIST
21717: LIST
21718: LIST
21719: ST_TO_ADDR
// bpoints := 1 ;
21720: LD_ADDR_VAR 0 10
21724: PUSH
21725: LD_INT 1
21727: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21728: LD_VAR 0 6
21732: PPUSH
21733: CALL_OW 247
21737: PUSH
21738: LD_INT 1
21740: DOUBLE
21741: EQUAL
21742: IFTRUE 21746
21744: GO 22324
21746: POP
// begin if GetClass ( i ) = 1 then
21747: LD_VAR 0 6
21751: PPUSH
21752: CALL_OW 257
21756: PUSH
21757: LD_INT 1
21759: EQUAL
21760: IFFALSE 21781
// points := [ 10 , 5 , 3 ] ;
21762: LD_ADDR_VAR 0 9
21766: PUSH
21767: LD_INT 10
21769: PUSH
21770: LD_INT 5
21772: PUSH
21773: LD_INT 3
21775: PUSH
21776: EMPTY
21777: LIST
21778: LIST
21779: LIST
21780: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21781: LD_VAR 0 6
21785: PPUSH
21786: CALL_OW 257
21790: PUSH
21791: LD_INT 2
21793: PUSH
21794: LD_INT 3
21796: PUSH
21797: LD_INT 4
21799: PUSH
21800: EMPTY
21801: LIST
21802: LIST
21803: LIST
21804: IN
21805: IFFALSE 21826
// points := [ 3 , 2 , 1 ] ;
21807: LD_ADDR_VAR 0 9
21811: PUSH
21812: LD_INT 3
21814: PUSH
21815: LD_INT 2
21817: PUSH
21818: LD_INT 1
21820: PUSH
21821: EMPTY
21822: LIST
21823: LIST
21824: LIST
21825: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21826: LD_VAR 0 6
21830: PPUSH
21831: CALL_OW 257
21835: PUSH
21836: LD_INT 5
21838: EQUAL
21839: IFFALSE 21860
// points := [ 130 , 5 , 2 ] ;
21841: LD_ADDR_VAR 0 9
21845: PUSH
21846: LD_INT 130
21848: PUSH
21849: LD_INT 5
21851: PUSH
21852: LD_INT 2
21854: PUSH
21855: EMPTY
21856: LIST
21857: LIST
21858: LIST
21859: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21860: LD_VAR 0 6
21864: PPUSH
21865: CALL_OW 257
21869: PUSH
21870: LD_INT 8
21872: EQUAL
21873: IFFALSE 21894
// points := [ 35 , 35 , 30 ] ;
21875: LD_ADDR_VAR 0 9
21879: PUSH
21880: LD_INT 35
21882: PUSH
21883: LD_INT 35
21885: PUSH
21886: LD_INT 30
21888: PUSH
21889: EMPTY
21890: LIST
21891: LIST
21892: LIST
21893: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21894: LD_VAR 0 6
21898: PPUSH
21899: CALL_OW 257
21903: PUSH
21904: LD_INT 9
21906: EQUAL
21907: IFFALSE 21928
// points := [ 20 , 55 , 40 ] ;
21909: LD_ADDR_VAR 0 9
21913: PUSH
21914: LD_INT 20
21916: PUSH
21917: LD_INT 55
21919: PUSH
21920: LD_INT 40
21922: PUSH
21923: EMPTY
21924: LIST
21925: LIST
21926: LIST
21927: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21928: LD_VAR 0 6
21932: PPUSH
21933: CALL_OW 257
21937: PUSH
21938: LD_INT 12
21940: PUSH
21941: LD_INT 16
21943: PUSH
21944: EMPTY
21945: LIST
21946: LIST
21947: IN
21948: IFFALSE 21969
// points := [ 5 , 3 , 2 ] ;
21950: LD_ADDR_VAR 0 9
21954: PUSH
21955: LD_INT 5
21957: PUSH
21958: LD_INT 3
21960: PUSH
21961: LD_INT 2
21963: PUSH
21964: EMPTY
21965: LIST
21966: LIST
21967: LIST
21968: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21969: LD_VAR 0 6
21973: PPUSH
21974: CALL_OW 257
21978: PUSH
21979: LD_INT 17
21981: EQUAL
21982: IFFALSE 22003
// points := [ 100 , 50 , 75 ] ;
21984: LD_ADDR_VAR 0 9
21988: PUSH
21989: LD_INT 100
21991: PUSH
21992: LD_INT 50
21994: PUSH
21995: LD_INT 75
21997: PUSH
21998: EMPTY
21999: LIST
22000: LIST
22001: LIST
22002: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22003: LD_VAR 0 6
22007: PPUSH
22008: CALL_OW 257
22012: PUSH
22013: LD_INT 15
22015: EQUAL
22016: IFFALSE 22037
// points := [ 10 , 5 , 3 ] ;
22018: LD_ADDR_VAR 0 9
22022: PUSH
22023: LD_INT 10
22025: PUSH
22026: LD_INT 5
22028: PUSH
22029: LD_INT 3
22031: PUSH
22032: EMPTY
22033: LIST
22034: LIST
22035: LIST
22036: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22037: LD_VAR 0 6
22041: PPUSH
22042: CALL_OW 257
22046: PUSH
22047: LD_INT 14
22049: EQUAL
22050: IFFALSE 22071
// points := [ 10 , 0 , 0 ] ;
22052: LD_ADDR_VAR 0 9
22056: PUSH
22057: LD_INT 10
22059: PUSH
22060: LD_INT 0
22062: PUSH
22063: LD_INT 0
22065: PUSH
22066: EMPTY
22067: LIST
22068: LIST
22069: LIST
22070: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22071: LD_VAR 0 6
22075: PPUSH
22076: CALL_OW 257
22080: PUSH
22081: LD_INT 11
22083: EQUAL
22084: IFFALSE 22105
// points := [ 30 , 10 , 5 ] ;
22086: LD_ADDR_VAR 0 9
22090: PUSH
22091: LD_INT 30
22093: PUSH
22094: LD_INT 10
22096: PUSH
22097: LD_INT 5
22099: PUSH
22100: EMPTY
22101: LIST
22102: LIST
22103: LIST
22104: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22105: LD_VAR 0 1
22109: PPUSH
22110: LD_INT 5
22112: PPUSH
22113: CALL_OW 321
22117: PUSH
22118: LD_INT 2
22120: EQUAL
22121: IFFALSE 22138
// bpoints := bpoints * 1.8 ;
22123: LD_ADDR_VAR 0 10
22127: PUSH
22128: LD_VAR 0 10
22132: PUSH
22133: LD_REAL  1.80000000000000E+0000
22136: MUL
22137: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
22138: LD_VAR 0 6
22142: PPUSH
22143: CALL_OW 257
22147: PUSH
22148: LD_INT 1
22150: PUSH
22151: LD_INT 2
22153: PUSH
22154: LD_INT 3
22156: PUSH
22157: LD_INT 4
22159: PUSH
22160: EMPTY
22161: LIST
22162: LIST
22163: LIST
22164: LIST
22165: IN
22166: PUSH
22167: LD_VAR 0 1
22171: PPUSH
22172: LD_INT 51
22174: PPUSH
22175: CALL_OW 321
22179: PUSH
22180: LD_INT 2
22182: EQUAL
22183: AND
22184: IFFALSE 22201
// bpoints := bpoints * 1.2 ;
22186: LD_ADDR_VAR 0 10
22190: PUSH
22191: LD_VAR 0 10
22195: PUSH
22196: LD_REAL  1.20000000000000E+0000
22199: MUL
22200: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
22201: LD_VAR 0 6
22205: PPUSH
22206: CALL_OW 257
22210: PUSH
22211: LD_INT 5
22213: PUSH
22214: LD_INT 7
22216: PUSH
22217: LD_INT 9
22219: PUSH
22220: EMPTY
22221: LIST
22222: LIST
22223: LIST
22224: IN
22225: PUSH
22226: LD_VAR 0 1
22230: PPUSH
22231: LD_INT 52
22233: PPUSH
22234: CALL_OW 321
22238: PUSH
22239: LD_INT 2
22241: EQUAL
22242: AND
22243: IFFALSE 22260
// bpoints := bpoints * 1.5 ;
22245: LD_ADDR_VAR 0 10
22249: PUSH
22250: LD_VAR 0 10
22254: PUSH
22255: LD_REAL  1.50000000000000E+0000
22258: MUL
22259: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22260: LD_VAR 0 1
22264: PPUSH
22265: LD_INT 66
22267: PPUSH
22268: CALL_OW 321
22272: PUSH
22273: LD_INT 2
22275: EQUAL
22276: IFFALSE 22293
// bpoints := bpoints * 1.1 ;
22278: LD_ADDR_VAR 0 10
22282: PUSH
22283: LD_VAR 0 10
22287: PUSH
22288: LD_REAL  1.10000000000000E+0000
22291: MUL
22292: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
22293: LD_ADDR_VAR 0 10
22297: PUSH
22298: LD_VAR 0 10
22302: PUSH
22303: LD_VAR 0 6
22307: PPUSH
22308: LD_INT 1
22310: PPUSH
22311: CALL_OW 259
22315: PUSH
22316: LD_REAL  1.15000000000000E+0000
22319: MUL
22320: MUL
22321: ST_TO_ADDR
// end ; unit_vehicle :
22322: GO 23146
22324: LD_INT 2
22326: DOUBLE
22327: EQUAL
22328: IFTRUE 22332
22330: GO 23134
22332: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
22333: LD_VAR 0 6
22337: PPUSH
22338: CALL_OW 264
22342: PUSH
22343: LD_INT 2
22345: PUSH
22346: LD_INT 42
22348: PUSH
22349: LD_INT 24
22351: PUSH
22352: EMPTY
22353: LIST
22354: LIST
22355: LIST
22356: IN
22357: IFFALSE 22378
// points := [ 25 , 5 , 3 ] ;
22359: LD_ADDR_VAR 0 9
22363: PUSH
22364: LD_INT 25
22366: PUSH
22367: LD_INT 5
22369: PUSH
22370: LD_INT 3
22372: PUSH
22373: EMPTY
22374: LIST
22375: LIST
22376: LIST
22377: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
22378: LD_VAR 0 6
22382: PPUSH
22383: CALL_OW 264
22387: PUSH
22388: LD_INT 4
22390: PUSH
22391: LD_INT 43
22393: PUSH
22394: LD_INT 25
22396: PUSH
22397: EMPTY
22398: LIST
22399: LIST
22400: LIST
22401: IN
22402: IFFALSE 22423
// points := [ 40 , 15 , 5 ] ;
22404: LD_ADDR_VAR 0 9
22408: PUSH
22409: LD_INT 40
22411: PUSH
22412: LD_INT 15
22414: PUSH
22415: LD_INT 5
22417: PUSH
22418: EMPTY
22419: LIST
22420: LIST
22421: LIST
22422: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22423: LD_VAR 0 6
22427: PPUSH
22428: CALL_OW 264
22432: PUSH
22433: LD_INT 3
22435: PUSH
22436: LD_INT 23
22438: PUSH
22439: EMPTY
22440: LIST
22441: LIST
22442: IN
22443: IFFALSE 22464
// points := [ 7 , 25 , 8 ] ;
22445: LD_ADDR_VAR 0 9
22449: PUSH
22450: LD_INT 7
22452: PUSH
22453: LD_INT 25
22455: PUSH
22456: LD_INT 8
22458: PUSH
22459: EMPTY
22460: LIST
22461: LIST
22462: LIST
22463: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22464: LD_VAR 0 6
22468: PPUSH
22469: CALL_OW 264
22473: PUSH
22474: LD_INT 5
22476: PUSH
22477: LD_INT 27
22479: PUSH
22480: LD_INT 44
22482: PUSH
22483: EMPTY
22484: LIST
22485: LIST
22486: LIST
22487: IN
22488: IFFALSE 22509
// points := [ 14 , 50 , 16 ] ;
22490: LD_ADDR_VAR 0 9
22494: PUSH
22495: LD_INT 14
22497: PUSH
22498: LD_INT 50
22500: PUSH
22501: LD_INT 16
22503: PUSH
22504: EMPTY
22505: LIST
22506: LIST
22507: LIST
22508: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22509: LD_VAR 0 6
22513: PPUSH
22514: CALL_OW 264
22518: PUSH
22519: LD_INT 6
22521: PUSH
22522: LD_INT 46
22524: PUSH
22525: EMPTY
22526: LIST
22527: LIST
22528: IN
22529: IFFALSE 22550
// points := [ 32 , 120 , 70 ] ;
22531: LD_ADDR_VAR 0 9
22535: PUSH
22536: LD_INT 32
22538: PUSH
22539: LD_INT 120
22541: PUSH
22542: LD_INT 70
22544: PUSH
22545: EMPTY
22546: LIST
22547: LIST
22548: LIST
22549: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
22550: LD_VAR 0 6
22554: PPUSH
22555: CALL_OW 264
22559: PUSH
22560: LD_INT 7
22562: PUSH
22563: LD_INT 28
22565: PUSH
22566: LD_INT 45
22568: PUSH
22569: EMPTY
22570: LIST
22571: LIST
22572: LIST
22573: IN
22574: IFFALSE 22595
// points := [ 35 , 20 , 45 ] ;
22576: LD_ADDR_VAR 0 9
22580: PUSH
22581: LD_INT 35
22583: PUSH
22584: LD_INT 20
22586: PUSH
22587: LD_INT 45
22589: PUSH
22590: EMPTY
22591: LIST
22592: LIST
22593: LIST
22594: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22595: LD_VAR 0 6
22599: PPUSH
22600: CALL_OW 264
22604: PUSH
22605: LD_INT 47
22607: PUSH
22608: EMPTY
22609: LIST
22610: IN
22611: IFFALSE 22632
// points := [ 67 , 45 , 75 ] ;
22613: LD_ADDR_VAR 0 9
22617: PUSH
22618: LD_INT 67
22620: PUSH
22621: LD_INT 45
22623: PUSH
22624: LD_INT 75
22626: PUSH
22627: EMPTY
22628: LIST
22629: LIST
22630: LIST
22631: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22632: LD_VAR 0 6
22636: PPUSH
22637: CALL_OW 264
22641: PUSH
22642: LD_INT 26
22644: PUSH
22645: EMPTY
22646: LIST
22647: IN
22648: IFFALSE 22669
// points := [ 120 , 30 , 80 ] ;
22650: LD_ADDR_VAR 0 9
22654: PUSH
22655: LD_INT 120
22657: PUSH
22658: LD_INT 30
22660: PUSH
22661: LD_INT 80
22663: PUSH
22664: EMPTY
22665: LIST
22666: LIST
22667: LIST
22668: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22669: LD_VAR 0 6
22673: PPUSH
22674: CALL_OW 264
22678: PUSH
22679: LD_INT 22
22681: PUSH
22682: EMPTY
22683: LIST
22684: IN
22685: IFFALSE 22706
// points := [ 40 , 1 , 1 ] ;
22687: LD_ADDR_VAR 0 9
22691: PUSH
22692: LD_INT 40
22694: PUSH
22695: LD_INT 1
22697: PUSH
22698: LD_INT 1
22700: PUSH
22701: EMPTY
22702: LIST
22703: LIST
22704: LIST
22705: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22706: LD_VAR 0 6
22710: PPUSH
22711: CALL_OW 264
22715: PUSH
22716: LD_INT 29
22718: PUSH
22719: EMPTY
22720: LIST
22721: IN
22722: IFFALSE 22743
// points := [ 70 , 200 , 400 ] ;
22724: LD_ADDR_VAR 0 9
22728: PUSH
22729: LD_INT 70
22731: PUSH
22732: LD_INT 200
22734: PUSH
22735: LD_INT 400
22737: PUSH
22738: EMPTY
22739: LIST
22740: LIST
22741: LIST
22742: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22743: LD_VAR 0 6
22747: PPUSH
22748: CALL_OW 264
22752: PUSH
22753: LD_INT 14
22755: PUSH
22756: LD_INT 53
22758: PUSH
22759: EMPTY
22760: LIST
22761: LIST
22762: IN
22763: IFFALSE 22784
// points := [ 40 , 10 , 20 ] ;
22765: LD_ADDR_VAR 0 9
22769: PUSH
22770: LD_INT 40
22772: PUSH
22773: LD_INT 10
22775: PUSH
22776: LD_INT 20
22778: PUSH
22779: EMPTY
22780: LIST
22781: LIST
22782: LIST
22783: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22784: LD_VAR 0 6
22788: PPUSH
22789: CALL_OW 264
22793: PUSH
22794: LD_INT 9
22796: PUSH
22797: EMPTY
22798: LIST
22799: IN
22800: IFFALSE 22821
// points := [ 5 , 70 , 20 ] ;
22802: LD_ADDR_VAR 0 9
22806: PUSH
22807: LD_INT 5
22809: PUSH
22810: LD_INT 70
22812: PUSH
22813: LD_INT 20
22815: PUSH
22816: EMPTY
22817: LIST
22818: LIST
22819: LIST
22820: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22821: LD_VAR 0 6
22825: PPUSH
22826: CALL_OW 264
22830: PUSH
22831: LD_INT 10
22833: PUSH
22834: EMPTY
22835: LIST
22836: IN
22837: IFFALSE 22858
// points := [ 35 , 110 , 70 ] ;
22839: LD_ADDR_VAR 0 9
22843: PUSH
22844: LD_INT 35
22846: PUSH
22847: LD_INT 110
22849: PUSH
22850: LD_INT 70
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: LIST
22857: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22858: LD_VAR 0 6
22862: PPUSH
22863: CALL_OW 265
22867: PUSH
22868: LD_INT 25
22870: EQUAL
22871: IFFALSE 22892
// points := [ 80 , 65 , 100 ] ;
22873: LD_ADDR_VAR 0 9
22877: PUSH
22878: LD_INT 80
22880: PUSH
22881: LD_INT 65
22883: PUSH
22884: LD_INT 100
22886: PUSH
22887: EMPTY
22888: LIST
22889: LIST
22890: LIST
22891: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22892: LD_VAR 0 6
22896: PPUSH
22897: CALL_OW 263
22901: PUSH
22902: LD_INT 1
22904: EQUAL
22905: IFFALSE 22940
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22907: LD_ADDR_VAR 0 10
22911: PUSH
22912: LD_VAR 0 10
22916: PUSH
22917: LD_VAR 0 6
22921: PPUSH
22922: CALL_OW 311
22926: PPUSH
22927: LD_INT 3
22929: PPUSH
22930: CALL_OW 259
22934: PUSH
22935: LD_INT 4
22937: MUL
22938: MUL
22939: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22940: LD_VAR 0 6
22944: PPUSH
22945: CALL_OW 263
22949: PUSH
22950: LD_INT 2
22952: EQUAL
22953: IFFALSE 23004
// begin j := IsControledBy ( i ) ;
22955: LD_ADDR_VAR 0 7
22959: PUSH
22960: LD_VAR 0 6
22964: PPUSH
22965: CALL_OW 312
22969: ST_TO_ADDR
// if j then
22970: LD_VAR 0 7
22974: IFFALSE 23004
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22976: LD_ADDR_VAR 0 10
22980: PUSH
22981: LD_VAR 0 10
22985: PUSH
22986: LD_VAR 0 7
22990: PPUSH
22991: LD_INT 3
22993: PPUSH
22994: CALL_OW 259
22998: PUSH
22999: LD_INT 3
23001: MUL
23002: MUL
23003: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23004: LD_VAR 0 6
23008: PPUSH
23009: CALL_OW 264
23013: PUSH
23014: LD_INT 5
23016: PUSH
23017: LD_INT 6
23019: PUSH
23020: LD_INT 46
23022: PUSH
23023: LD_INT 44
23025: PUSH
23026: LD_INT 47
23028: PUSH
23029: LD_INT 45
23031: PUSH
23032: LD_INT 28
23034: PUSH
23035: LD_INT 7
23037: PUSH
23038: LD_INT 27
23040: PUSH
23041: LD_INT 29
23043: PUSH
23044: EMPTY
23045: LIST
23046: LIST
23047: LIST
23048: LIST
23049: LIST
23050: LIST
23051: LIST
23052: LIST
23053: LIST
23054: LIST
23055: IN
23056: PUSH
23057: LD_VAR 0 1
23061: PPUSH
23062: LD_INT 52
23064: PPUSH
23065: CALL_OW 321
23069: PUSH
23070: LD_INT 2
23072: EQUAL
23073: AND
23074: IFFALSE 23091
// bpoints := bpoints * 1.2 ;
23076: LD_ADDR_VAR 0 10
23080: PUSH
23081: LD_VAR 0 10
23085: PUSH
23086: LD_REAL  1.20000000000000E+0000
23089: MUL
23090: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23091: LD_VAR 0 6
23095: PPUSH
23096: CALL_OW 264
23100: PUSH
23101: LD_INT 6
23103: PUSH
23104: LD_INT 46
23106: PUSH
23107: LD_INT 47
23109: PUSH
23110: EMPTY
23111: LIST
23112: LIST
23113: LIST
23114: IN
23115: IFFALSE 23132
// bpoints := bpoints * 1.2 ;
23117: LD_ADDR_VAR 0 10
23121: PUSH
23122: LD_VAR 0 10
23126: PUSH
23127: LD_REAL  1.20000000000000E+0000
23130: MUL
23131: ST_TO_ADDR
// end ; unit_building :
23132: GO 23146
23134: LD_INT 3
23136: DOUBLE
23137: EQUAL
23138: IFTRUE 23142
23140: GO 23145
23142: POP
// ; end ;
23143: GO 23146
23145: POP
// for j = 1 to 3 do
23146: LD_ADDR_VAR 0 7
23150: PUSH
23151: DOUBLE
23152: LD_INT 1
23154: DEC
23155: ST_TO_ADDR
23156: LD_INT 3
23158: PUSH
23159: FOR_TO
23160: IFFALSE 23213
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
23162: LD_ADDR_VAR 0 5
23166: PUSH
23167: LD_VAR 0 5
23171: PPUSH
23172: LD_VAR 0 7
23176: PPUSH
23177: LD_VAR 0 5
23181: PUSH
23182: LD_VAR 0 7
23186: ARRAY
23187: PUSH
23188: LD_VAR 0 9
23192: PUSH
23193: LD_VAR 0 7
23197: ARRAY
23198: PUSH
23199: LD_VAR 0 10
23203: MUL
23204: PLUS
23205: PPUSH
23206: CALL_OW 1
23210: ST_TO_ADDR
23211: GO 23159
23213: POP
23214: POP
// end ;
23215: GO 21698
23217: POP
23218: POP
// result := Replace ( result , 4 , tmp ) ;
23219: LD_ADDR_VAR 0 5
23223: PUSH
23224: LD_VAR 0 5
23228: PPUSH
23229: LD_INT 4
23231: PPUSH
23232: LD_VAR 0 8
23236: PPUSH
23237: CALL_OW 1
23241: ST_TO_ADDR
// end ;
23242: LD_VAR 0 5
23246: RET
// export function DangerAtRange ( unit , range ) ; begin
23247: LD_INT 0
23249: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23250: LD_ADDR_VAR 0 3
23254: PUSH
23255: LD_VAR 0 1
23259: PPUSH
23260: CALL_OW 255
23264: PPUSH
23265: LD_VAR 0 1
23269: PPUSH
23270: CALL_OW 250
23274: PPUSH
23275: LD_VAR 0 1
23279: PPUSH
23280: CALL_OW 251
23284: PPUSH
23285: LD_VAR 0 2
23289: PPUSH
23290: CALL 21550 0 4
23294: ST_TO_ADDR
// end ;
23295: LD_VAR 0 3
23299: RET
// export function DangerInArea ( side , area ) ; begin
23300: LD_INT 0
23302: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
23303: LD_ADDR_VAR 0 3
23307: PUSH
23308: LD_VAR 0 2
23312: PPUSH
23313: LD_INT 81
23315: PUSH
23316: LD_VAR 0 1
23320: PUSH
23321: EMPTY
23322: LIST
23323: LIST
23324: PPUSH
23325: CALL_OW 70
23329: ST_TO_ADDR
// end ;
23330: LD_VAR 0 3
23334: RET
// export function IsExtension ( b ) ; begin
23335: LD_INT 0
23337: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
23338: LD_ADDR_VAR 0 2
23342: PUSH
23343: LD_VAR 0 1
23347: PUSH
23348: LD_INT 23
23350: PUSH
23351: LD_INT 20
23353: PUSH
23354: LD_INT 22
23356: PUSH
23357: LD_INT 17
23359: PUSH
23360: LD_INT 24
23362: PUSH
23363: LD_INT 21
23365: PUSH
23366: LD_INT 19
23368: PUSH
23369: LD_INT 16
23371: PUSH
23372: LD_INT 25
23374: PUSH
23375: LD_INT 18
23377: PUSH
23378: EMPTY
23379: LIST
23380: LIST
23381: LIST
23382: LIST
23383: LIST
23384: LIST
23385: LIST
23386: LIST
23387: LIST
23388: LIST
23389: IN
23390: ST_TO_ADDR
// end ;
23391: LD_VAR 0 2
23395: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
23396: LD_INT 0
23398: PPUSH
23399: PPUSH
23400: PPUSH
// result := [ ] ;
23401: LD_ADDR_VAR 0 3
23405: PUSH
23406: EMPTY
23407: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23408: LD_ADDR_VAR 0 4
23412: PUSH
23413: LD_VAR 0 2
23417: PPUSH
23418: LD_INT 21
23420: PUSH
23421: LD_INT 3
23423: PUSH
23424: EMPTY
23425: LIST
23426: LIST
23427: PPUSH
23428: CALL_OW 70
23432: ST_TO_ADDR
// if not tmp then
23433: LD_VAR 0 4
23437: NOT
23438: IFFALSE 23442
// exit ;
23440: GO 23500
// for i in tmp do
23442: LD_ADDR_VAR 0 5
23446: PUSH
23447: LD_VAR 0 4
23451: PUSH
23452: FOR_IN
23453: IFFALSE 23488
// if GetBase ( i ) <> base then
23455: LD_VAR 0 5
23459: PPUSH
23460: CALL_OW 274
23464: PUSH
23465: LD_VAR 0 1
23469: NONEQUAL
23470: IFFALSE 23486
// ComLinkToBase ( base , i ) ;
23472: LD_VAR 0 1
23476: PPUSH
23477: LD_VAR 0 5
23481: PPUSH
23482: CALL_OW 169
23486: GO 23452
23488: POP
23489: POP
// result := tmp ;
23490: LD_ADDR_VAR 0 3
23494: PUSH
23495: LD_VAR 0 4
23499: ST_TO_ADDR
// end ;
23500: LD_VAR 0 3
23504: RET
// export function ComComplete ( unit , b ) ; var i ; begin
23505: LD_INT 0
23507: PPUSH
23508: PPUSH
// if BuildingStatus ( b ) = bs_build then
23509: LD_VAR 0 2
23513: PPUSH
23514: CALL_OW 461
23518: PUSH
23519: LD_INT 1
23521: EQUAL
23522: IFFALSE 23582
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23524: LD_VAR 0 1
23528: PPUSH
23529: LD_STRING h
23531: PUSH
23532: LD_VAR 0 2
23536: PPUSH
23537: CALL_OW 250
23541: PUSH
23542: LD_VAR 0 2
23546: PPUSH
23547: CALL_OW 251
23551: PUSH
23552: LD_VAR 0 2
23556: PUSH
23557: LD_INT 0
23559: PUSH
23560: LD_INT 0
23562: PUSH
23563: LD_INT 0
23565: PUSH
23566: EMPTY
23567: LIST
23568: LIST
23569: LIST
23570: LIST
23571: LIST
23572: LIST
23573: LIST
23574: PUSH
23575: EMPTY
23576: LIST
23577: PPUSH
23578: CALL_OW 446
// end ;
23582: LD_VAR 0 3
23586: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23587: LD_INT 0
23589: PPUSH
23590: PPUSH
23591: PPUSH
23592: PPUSH
23593: PPUSH
23594: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
23595: LD_VAR 0 1
23599: NOT
23600: PUSH
23601: LD_VAR 0 1
23605: PPUSH
23606: CALL_OW 263
23610: PUSH
23611: LD_INT 2
23613: EQUAL
23614: NOT
23615: OR
23616: IFFALSE 23620
// exit ;
23618: GO 23936
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23620: LD_ADDR_VAR 0 6
23624: PUSH
23625: LD_INT 22
23627: PUSH
23628: LD_VAR 0 1
23632: PPUSH
23633: CALL_OW 255
23637: PUSH
23638: EMPTY
23639: LIST
23640: LIST
23641: PUSH
23642: LD_INT 2
23644: PUSH
23645: LD_INT 30
23647: PUSH
23648: LD_INT 36
23650: PUSH
23651: EMPTY
23652: LIST
23653: LIST
23654: PUSH
23655: LD_INT 34
23657: PUSH
23658: LD_INT 31
23660: PUSH
23661: EMPTY
23662: LIST
23663: LIST
23664: PUSH
23665: EMPTY
23666: LIST
23667: LIST
23668: LIST
23669: PUSH
23670: EMPTY
23671: LIST
23672: LIST
23673: PPUSH
23674: CALL_OW 69
23678: ST_TO_ADDR
// if not tmp then
23679: LD_VAR 0 6
23683: NOT
23684: IFFALSE 23688
// exit ;
23686: GO 23936
// result := [ ] ;
23688: LD_ADDR_VAR 0 2
23692: PUSH
23693: EMPTY
23694: ST_TO_ADDR
// for i in tmp do
23695: LD_ADDR_VAR 0 3
23699: PUSH
23700: LD_VAR 0 6
23704: PUSH
23705: FOR_IN
23706: IFFALSE 23777
// begin t := UnitsInside ( i ) ;
23708: LD_ADDR_VAR 0 4
23712: PUSH
23713: LD_VAR 0 3
23717: PPUSH
23718: CALL_OW 313
23722: ST_TO_ADDR
// if t then
23723: LD_VAR 0 4
23727: IFFALSE 23775
// for j in t do
23729: LD_ADDR_VAR 0 7
23733: PUSH
23734: LD_VAR 0 4
23738: PUSH
23739: FOR_IN
23740: IFFALSE 23773
// result := Insert ( result , result + 1 , j ) ;
23742: LD_ADDR_VAR 0 2
23746: PUSH
23747: LD_VAR 0 2
23751: PPUSH
23752: LD_VAR 0 2
23756: PUSH
23757: LD_INT 1
23759: PLUS
23760: PPUSH
23761: LD_VAR 0 7
23765: PPUSH
23766: CALL_OW 2
23770: ST_TO_ADDR
23771: GO 23739
23773: POP
23774: POP
// end ;
23775: GO 23705
23777: POP
23778: POP
// if not result then
23779: LD_VAR 0 2
23783: NOT
23784: IFFALSE 23788
// exit ;
23786: GO 23936
// mech := result [ 1 ] ;
23788: LD_ADDR_VAR 0 5
23792: PUSH
23793: LD_VAR 0 2
23797: PUSH
23798: LD_INT 1
23800: ARRAY
23801: ST_TO_ADDR
// if result > 1 then
23802: LD_VAR 0 2
23806: PUSH
23807: LD_INT 1
23809: GREATER
23810: IFFALSE 23922
// for i = 2 to result do
23812: LD_ADDR_VAR 0 3
23816: PUSH
23817: DOUBLE
23818: LD_INT 2
23820: DEC
23821: ST_TO_ADDR
23822: LD_VAR 0 2
23826: PUSH
23827: FOR_TO
23828: IFFALSE 23920
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23830: LD_ADDR_VAR 0 4
23834: PUSH
23835: LD_VAR 0 2
23839: PUSH
23840: LD_VAR 0 3
23844: ARRAY
23845: PPUSH
23846: LD_INT 3
23848: PPUSH
23849: CALL_OW 259
23853: PUSH
23854: LD_VAR 0 2
23858: PUSH
23859: LD_VAR 0 3
23863: ARRAY
23864: PPUSH
23865: CALL_OW 432
23869: MINUS
23870: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23871: LD_VAR 0 4
23875: PUSH
23876: LD_VAR 0 5
23880: PPUSH
23881: LD_INT 3
23883: PPUSH
23884: CALL_OW 259
23888: PUSH
23889: LD_VAR 0 5
23893: PPUSH
23894: CALL_OW 432
23898: MINUS
23899: GREATEREQUAL
23900: IFFALSE 23918
// mech := result [ i ] ;
23902: LD_ADDR_VAR 0 5
23906: PUSH
23907: LD_VAR 0 2
23911: PUSH
23912: LD_VAR 0 3
23916: ARRAY
23917: ST_TO_ADDR
// end ;
23918: GO 23827
23920: POP
23921: POP
// ComLinkTo ( vehicle , mech ) ;
23922: LD_VAR 0 1
23926: PPUSH
23927: LD_VAR 0 5
23931: PPUSH
23932: CALL_OW 135
// end ;
23936: LD_VAR 0 2
23940: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23941: LD_INT 0
23943: PPUSH
23944: PPUSH
23945: PPUSH
23946: PPUSH
23947: PPUSH
23948: PPUSH
23949: PPUSH
23950: PPUSH
23951: PPUSH
23952: PPUSH
23953: PPUSH
23954: PPUSH
23955: PPUSH
// result := [ ] ;
23956: LD_ADDR_VAR 0 7
23960: PUSH
23961: EMPTY
23962: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23963: LD_VAR 0 1
23967: PPUSH
23968: CALL_OW 266
23972: PUSH
23973: LD_INT 0
23975: PUSH
23976: LD_INT 1
23978: PUSH
23979: EMPTY
23980: LIST
23981: LIST
23982: IN
23983: NOT
23984: IFFALSE 23988
// exit ;
23986: GO 25619
// if name then
23988: LD_VAR 0 3
23992: IFFALSE 24008
// SetBName ( base_dep , name ) ;
23994: LD_VAR 0 1
23998: PPUSH
23999: LD_VAR 0 3
24003: PPUSH
24004: CALL_OW 500
// base := GetBase ( base_dep ) ;
24008: LD_ADDR_VAR 0 15
24012: PUSH
24013: LD_VAR 0 1
24017: PPUSH
24018: CALL_OW 274
24022: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24023: LD_ADDR_VAR 0 16
24027: PUSH
24028: LD_VAR 0 1
24032: PPUSH
24033: CALL_OW 255
24037: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24038: LD_ADDR_VAR 0 17
24042: PUSH
24043: LD_VAR 0 1
24047: PPUSH
24048: CALL_OW 248
24052: ST_TO_ADDR
// if sources then
24053: LD_VAR 0 5
24057: IFFALSE 24104
// for i = 1 to 3 do
24059: LD_ADDR_VAR 0 8
24063: PUSH
24064: DOUBLE
24065: LD_INT 1
24067: DEC
24068: ST_TO_ADDR
24069: LD_INT 3
24071: PUSH
24072: FOR_TO
24073: IFFALSE 24102
// AddResourceType ( base , i , sources [ i ] ) ;
24075: LD_VAR 0 15
24079: PPUSH
24080: LD_VAR 0 8
24084: PPUSH
24085: LD_VAR 0 5
24089: PUSH
24090: LD_VAR 0 8
24094: ARRAY
24095: PPUSH
24096: CALL_OW 276
24100: GO 24072
24102: POP
24103: POP
// buildings := GetBaseBuildings ( base , area ) ;
24104: LD_ADDR_VAR 0 18
24108: PUSH
24109: LD_VAR 0 15
24113: PPUSH
24114: LD_VAR 0 2
24118: PPUSH
24119: CALL 23396 0 2
24123: ST_TO_ADDR
// InitHc ;
24124: CALL_OW 19
// InitUc ;
24128: CALL_OW 18
// uc_side := side ;
24132: LD_ADDR_OWVAR 20
24136: PUSH
24137: LD_VAR 0 16
24141: ST_TO_ADDR
// uc_nation := nation ;
24142: LD_ADDR_OWVAR 21
24146: PUSH
24147: LD_VAR 0 17
24151: ST_TO_ADDR
// if buildings then
24152: LD_VAR 0 18
24156: IFFALSE 25478
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
24158: LD_ADDR_VAR 0 19
24162: PUSH
24163: LD_VAR 0 18
24167: PPUSH
24168: LD_INT 2
24170: PUSH
24171: LD_INT 30
24173: PUSH
24174: LD_INT 29
24176: PUSH
24177: EMPTY
24178: LIST
24179: LIST
24180: PUSH
24181: LD_INT 30
24183: PUSH
24184: LD_INT 30
24186: PUSH
24187: EMPTY
24188: LIST
24189: LIST
24190: PUSH
24191: EMPTY
24192: LIST
24193: LIST
24194: LIST
24195: PPUSH
24196: CALL_OW 72
24200: ST_TO_ADDR
// if tmp then
24201: LD_VAR 0 19
24205: IFFALSE 24253
// for i in tmp do
24207: LD_ADDR_VAR 0 8
24211: PUSH
24212: LD_VAR 0 19
24216: PUSH
24217: FOR_IN
24218: IFFALSE 24251
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24220: LD_VAR 0 8
24224: PPUSH
24225: CALL_OW 250
24229: PPUSH
24230: LD_VAR 0 8
24234: PPUSH
24235: CALL_OW 251
24239: PPUSH
24240: LD_VAR 0 16
24244: PPUSH
24245: CALL_OW 441
24249: GO 24217
24251: POP
24252: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24253: LD_VAR 0 18
24257: PPUSH
24258: LD_INT 2
24260: PUSH
24261: LD_INT 30
24263: PUSH
24264: LD_INT 32
24266: PUSH
24267: EMPTY
24268: LIST
24269: LIST
24270: PUSH
24271: LD_INT 30
24273: PUSH
24274: LD_INT 33
24276: PUSH
24277: EMPTY
24278: LIST
24279: LIST
24280: PUSH
24281: EMPTY
24282: LIST
24283: LIST
24284: LIST
24285: PPUSH
24286: CALL_OW 72
24290: IFFALSE 24378
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
24292: LD_ADDR_VAR 0 8
24296: PUSH
24297: LD_VAR 0 18
24301: PPUSH
24302: LD_INT 2
24304: PUSH
24305: LD_INT 30
24307: PUSH
24308: LD_INT 32
24310: PUSH
24311: EMPTY
24312: LIST
24313: LIST
24314: PUSH
24315: LD_INT 30
24317: PUSH
24318: LD_INT 33
24320: PUSH
24321: EMPTY
24322: LIST
24323: LIST
24324: PUSH
24325: EMPTY
24326: LIST
24327: LIST
24328: LIST
24329: PPUSH
24330: CALL_OW 72
24334: PUSH
24335: FOR_IN
24336: IFFALSE 24376
// begin if not GetBWeapon ( i ) then
24338: LD_VAR 0 8
24342: PPUSH
24343: CALL_OW 269
24347: NOT
24348: IFFALSE 24374
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
24350: LD_VAR 0 8
24354: PPUSH
24355: LD_VAR 0 8
24359: PPUSH
24360: LD_VAR 0 2
24364: PPUSH
24365: CALL 25624 0 2
24369: PPUSH
24370: CALL_OW 431
// end ;
24374: GO 24335
24376: POP
24377: POP
// end ; for i = 1 to personel do
24378: LD_ADDR_VAR 0 8
24382: PUSH
24383: DOUBLE
24384: LD_INT 1
24386: DEC
24387: ST_TO_ADDR
24388: LD_VAR 0 6
24392: PUSH
24393: FOR_TO
24394: IFFALSE 25458
// begin if i > 4 then
24396: LD_VAR 0 8
24400: PUSH
24401: LD_INT 4
24403: GREATER
24404: IFFALSE 24408
// break ;
24406: GO 25458
// case i of 1 :
24408: LD_VAR 0 8
24412: PUSH
24413: LD_INT 1
24415: DOUBLE
24416: EQUAL
24417: IFTRUE 24421
24419: GO 24501
24421: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24422: LD_ADDR_VAR 0 12
24426: PUSH
24427: LD_VAR 0 18
24431: PPUSH
24432: LD_INT 22
24434: PUSH
24435: LD_VAR 0 16
24439: PUSH
24440: EMPTY
24441: LIST
24442: LIST
24443: PUSH
24444: LD_INT 58
24446: PUSH
24447: EMPTY
24448: LIST
24449: PUSH
24450: LD_INT 2
24452: PUSH
24453: LD_INT 30
24455: PUSH
24456: LD_INT 32
24458: PUSH
24459: EMPTY
24460: LIST
24461: LIST
24462: PUSH
24463: LD_INT 30
24465: PUSH
24466: LD_INT 4
24468: PUSH
24469: EMPTY
24470: LIST
24471: LIST
24472: PUSH
24473: LD_INT 30
24475: PUSH
24476: LD_INT 5
24478: PUSH
24479: EMPTY
24480: LIST
24481: LIST
24482: PUSH
24483: EMPTY
24484: LIST
24485: LIST
24486: LIST
24487: LIST
24488: PUSH
24489: EMPTY
24490: LIST
24491: LIST
24492: LIST
24493: PPUSH
24494: CALL_OW 72
24498: ST_TO_ADDR
24499: GO 24723
24501: LD_INT 2
24503: DOUBLE
24504: EQUAL
24505: IFTRUE 24509
24507: GO 24571
24509: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24510: LD_ADDR_VAR 0 12
24514: PUSH
24515: LD_VAR 0 18
24519: PPUSH
24520: LD_INT 22
24522: PUSH
24523: LD_VAR 0 16
24527: PUSH
24528: EMPTY
24529: LIST
24530: LIST
24531: PUSH
24532: LD_INT 2
24534: PUSH
24535: LD_INT 30
24537: PUSH
24538: LD_INT 0
24540: PUSH
24541: EMPTY
24542: LIST
24543: LIST
24544: PUSH
24545: LD_INT 30
24547: PUSH
24548: LD_INT 1
24550: PUSH
24551: EMPTY
24552: LIST
24553: LIST
24554: PUSH
24555: EMPTY
24556: LIST
24557: LIST
24558: LIST
24559: PUSH
24560: EMPTY
24561: LIST
24562: LIST
24563: PPUSH
24564: CALL_OW 72
24568: ST_TO_ADDR
24569: GO 24723
24571: LD_INT 3
24573: DOUBLE
24574: EQUAL
24575: IFTRUE 24579
24577: GO 24641
24579: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24580: LD_ADDR_VAR 0 12
24584: PUSH
24585: LD_VAR 0 18
24589: PPUSH
24590: LD_INT 22
24592: PUSH
24593: LD_VAR 0 16
24597: PUSH
24598: EMPTY
24599: LIST
24600: LIST
24601: PUSH
24602: LD_INT 2
24604: PUSH
24605: LD_INT 30
24607: PUSH
24608: LD_INT 2
24610: PUSH
24611: EMPTY
24612: LIST
24613: LIST
24614: PUSH
24615: LD_INT 30
24617: PUSH
24618: LD_INT 3
24620: PUSH
24621: EMPTY
24622: LIST
24623: LIST
24624: PUSH
24625: EMPTY
24626: LIST
24627: LIST
24628: LIST
24629: PUSH
24630: EMPTY
24631: LIST
24632: LIST
24633: PPUSH
24634: CALL_OW 72
24638: ST_TO_ADDR
24639: GO 24723
24641: LD_INT 4
24643: DOUBLE
24644: EQUAL
24645: IFTRUE 24649
24647: GO 24722
24649: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24650: LD_ADDR_VAR 0 12
24654: PUSH
24655: LD_VAR 0 18
24659: PPUSH
24660: LD_INT 22
24662: PUSH
24663: LD_VAR 0 16
24667: PUSH
24668: EMPTY
24669: LIST
24670: LIST
24671: PUSH
24672: LD_INT 2
24674: PUSH
24675: LD_INT 30
24677: PUSH
24678: LD_INT 6
24680: PUSH
24681: EMPTY
24682: LIST
24683: LIST
24684: PUSH
24685: LD_INT 30
24687: PUSH
24688: LD_INT 7
24690: PUSH
24691: EMPTY
24692: LIST
24693: LIST
24694: PUSH
24695: LD_INT 30
24697: PUSH
24698: LD_INT 8
24700: PUSH
24701: EMPTY
24702: LIST
24703: LIST
24704: PUSH
24705: EMPTY
24706: LIST
24707: LIST
24708: LIST
24709: LIST
24710: PUSH
24711: EMPTY
24712: LIST
24713: LIST
24714: PPUSH
24715: CALL_OW 72
24719: ST_TO_ADDR
24720: GO 24723
24722: POP
// if i = 1 then
24723: LD_VAR 0 8
24727: PUSH
24728: LD_INT 1
24730: EQUAL
24731: IFFALSE 24842
// begin tmp := [ ] ;
24733: LD_ADDR_VAR 0 19
24737: PUSH
24738: EMPTY
24739: ST_TO_ADDR
// for j in f do
24740: LD_ADDR_VAR 0 9
24744: PUSH
24745: LD_VAR 0 12
24749: PUSH
24750: FOR_IN
24751: IFFALSE 24824
// if GetBType ( j ) = b_bunker then
24753: LD_VAR 0 9
24757: PPUSH
24758: CALL_OW 266
24762: PUSH
24763: LD_INT 32
24765: EQUAL
24766: IFFALSE 24793
// tmp := Insert ( tmp , 1 , j ) else
24768: LD_ADDR_VAR 0 19
24772: PUSH
24773: LD_VAR 0 19
24777: PPUSH
24778: LD_INT 1
24780: PPUSH
24781: LD_VAR 0 9
24785: PPUSH
24786: CALL_OW 2
24790: ST_TO_ADDR
24791: GO 24822
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24793: LD_ADDR_VAR 0 19
24797: PUSH
24798: LD_VAR 0 19
24802: PPUSH
24803: LD_VAR 0 19
24807: PUSH
24808: LD_INT 1
24810: PLUS
24811: PPUSH
24812: LD_VAR 0 9
24816: PPUSH
24817: CALL_OW 2
24821: ST_TO_ADDR
24822: GO 24750
24824: POP
24825: POP
// if tmp then
24826: LD_VAR 0 19
24830: IFFALSE 24842
// f := tmp ;
24832: LD_ADDR_VAR 0 12
24836: PUSH
24837: LD_VAR 0 19
24841: ST_TO_ADDR
// end ; x := personel [ i ] ;
24842: LD_ADDR_VAR 0 13
24846: PUSH
24847: LD_VAR 0 6
24851: PUSH
24852: LD_VAR 0 8
24856: ARRAY
24857: ST_TO_ADDR
// if x = - 1 then
24858: LD_VAR 0 13
24862: PUSH
24863: LD_INT 1
24865: NEG
24866: EQUAL
24867: IFFALSE 25076
// begin for j in f do
24869: LD_ADDR_VAR 0 9
24873: PUSH
24874: LD_VAR 0 12
24878: PUSH
24879: FOR_IN
24880: IFFALSE 25072
// repeat InitHc ;
24882: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24886: LD_VAR 0 9
24890: PPUSH
24891: CALL_OW 266
24895: PUSH
24896: LD_INT 5
24898: EQUAL
24899: IFFALSE 24969
// begin if UnitsInside ( j ) < 3 then
24901: LD_VAR 0 9
24905: PPUSH
24906: CALL_OW 313
24910: PUSH
24911: LD_INT 3
24913: LESS
24914: IFFALSE 24950
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24916: LD_INT 0
24918: PPUSH
24919: LD_INT 5
24921: PUSH
24922: LD_INT 8
24924: PUSH
24925: LD_INT 9
24927: PUSH
24928: EMPTY
24929: LIST
24930: LIST
24931: LIST
24932: PUSH
24933: LD_VAR 0 17
24937: ARRAY
24938: PPUSH
24939: LD_VAR 0 4
24943: PPUSH
24944: CALL_OW 380
24948: GO 24967
// PrepareHuman ( false , i , skill ) ;
24950: LD_INT 0
24952: PPUSH
24953: LD_VAR 0 8
24957: PPUSH
24958: LD_VAR 0 4
24962: PPUSH
24963: CALL_OW 380
// end else
24967: GO 24986
// PrepareHuman ( false , i , skill ) ;
24969: LD_INT 0
24971: PPUSH
24972: LD_VAR 0 8
24976: PPUSH
24977: LD_VAR 0 4
24981: PPUSH
24982: CALL_OW 380
// un := CreateHuman ;
24986: LD_ADDR_VAR 0 14
24990: PUSH
24991: CALL_OW 44
24995: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24996: LD_ADDR_VAR 0 7
25000: PUSH
25001: LD_VAR 0 7
25005: PPUSH
25006: LD_INT 1
25008: PPUSH
25009: LD_VAR 0 14
25013: PPUSH
25014: CALL_OW 2
25018: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25019: LD_VAR 0 14
25023: PPUSH
25024: LD_VAR 0 9
25028: PPUSH
25029: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25033: LD_VAR 0 9
25037: PPUSH
25038: CALL_OW 313
25042: PUSH
25043: LD_INT 6
25045: EQUAL
25046: PUSH
25047: LD_VAR 0 9
25051: PPUSH
25052: CALL_OW 266
25056: PUSH
25057: LD_INT 32
25059: PUSH
25060: LD_INT 31
25062: PUSH
25063: EMPTY
25064: LIST
25065: LIST
25066: IN
25067: OR
25068: IFFALSE 24882
25070: GO 24879
25072: POP
25073: POP
// end else
25074: GO 25456
// for j = 1 to x do
25076: LD_ADDR_VAR 0 9
25080: PUSH
25081: DOUBLE
25082: LD_INT 1
25084: DEC
25085: ST_TO_ADDR
25086: LD_VAR 0 13
25090: PUSH
25091: FOR_TO
25092: IFFALSE 25454
// begin InitHc ;
25094: CALL_OW 19
// if not f then
25098: LD_VAR 0 12
25102: NOT
25103: IFFALSE 25192
// begin PrepareHuman ( false , i , skill ) ;
25105: LD_INT 0
25107: PPUSH
25108: LD_VAR 0 8
25112: PPUSH
25113: LD_VAR 0 4
25117: PPUSH
25118: CALL_OW 380
// un := CreateHuman ;
25122: LD_ADDR_VAR 0 14
25126: PUSH
25127: CALL_OW 44
25131: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25132: LD_ADDR_VAR 0 7
25136: PUSH
25137: LD_VAR 0 7
25141: PPUSH
25142: LD_INT 1
25144: PPUSH
25145: LD_VAR 0 14
25149: PPUSH
25150: CALL_OW 2
25154: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25155: LD_VAR 0 14
25159: PPUSH
25160: LD_VAR 0 1
25164: PPUSH
25165: CALL_OW 250
25169: PPUSH
25170: LD_VAR 0 1
25174: PPUSH
25175: CALL_OW 251
25179: PPUSH
25180: LD_INT 10
25182: PPUSH
25183: LD_INT 0
25185: PPUSH
25186: CALL_OW 50
// continue ;
25190: GO 25091
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25192: LD_VAR 0 12
25196: PUSH
25197: LD_INT 1
25199: ARRAY
25200: PPUSH
25201: CALL_OW 313
25205: PUSH
25206: LD_VAR 0 12
25210: PUSH
25211: LD_INT 1
25213: ARRAY
25214: PPUSH
25215: CALL_OW 266
25219: PUSH
25220: LD_INT 32
25222: PUSH
25223: LD_INT 31
25225: PUSH
25226: EMPTY
25227: LIST
25228: LIST
25229: IN
25230: AND
25231: PUSH
25232: LD_VAR 0 12
25236: PUSH
25237: LD_INT 1
25239: ARRAY
25240: PPUSH
25241: CALL_OW 313
25245: PUSH
25246: LD_INT 6
25248: EQUAL
25249: OR
25250: IFFALSE 25270
// f := Delete ( f , 1 ) ;
25252: LD_ADDR_VAR 0 12
25256: PUSH
25257: LD_VAR 0 12
25261: PPUSH
25262: LD_INT 1
25264: PPUSH
25265: CALL_OW 3
25269: ST_TO_ADDR
// if not f then
25270: LD_VAR 0 12
25274: NOT
25275: IFFALSE 25293
// begin x := x + 2 ;
25277: LD_ADDR_VAR 0 13
25281: PUSH
25282: LD_VAR 0 13
25286: PUSH
25287: LD_INT 2
25289: PLUS
25290: ST_TO_ADDR
// continue ;
25291: GO 25091
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
25293: LD_VAR 0 12
25297: PUSH
25298: LD_INT 1
25300: ARRAY
25301: PPUSH
25302: CALL_OW 266
25306: PUSH
25307: LD_INT 5
25309: EQUAL
25310: IFFALSE 25384
// begin if UnitsInside ( f [ 1 ] ) < 3 then
25312: LD_VAR 0 12
25316: PUSH
25317: LD_INT 1
25319: ARRAY
25320: PPUSH
25321: CALL_OW 313
25325: PUSH
25326: LD_INT 3
25328: LESS
25329: IFFALSE 25365
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25331: LD_INT 0
25333: PPUSH
25334: LD_INT 5
25336: PUSH
25337: LD_INT 8
25339: PUSH
25340: LD_INT 9
25342: PUSH
25343: EMPTY
25344: LIST
25345: LIST
25346: LIST
25347: PUSH
25348: LD_VAR 0 17
25352: ARRAY
25353: PPUSH
25354: LD_VAR 0 4
25358: PPUSH
25359: CALL_OW 380
25363: GO 25382
// PrepareHuman ( false , i , skill ) ;
25365: LD_INT 0
25367: PPUSH
25368: LD_VAR 0 8
25372: PPUSH
25373: LD_VAR 0 4
25377: PPUSH
25378: CALL_OW 380
// end else
25382: GO 25401
// PrepareHuman ( false , i , skill ) ;
25384: LD_INT 0
25386: PPUSH
25387: LD_VAR 0 8
25391: PPUSH
25392: LD_VAR 0 4
25396: PPUSH
25397: CALL_OW 380
// un := CreateHuman ;
25401: LD_ADDR_VAR 0 14
25405: PUSH
25406: CALL_OW 44
25410: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25411: LD_ADDR_VAR 0 7
25415: PUSH
25416: LD_VAR 0 7
25420: PPUSH
25421: LD_INT 1
25423: PPUSH
25424: LD_VAR 0 14
25428: PPUSH
25429: CALL_OW 2
25433: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25434: LD_VAR 0 14
25438: PPUSH
25439: LD_VAR 0 12
25443: PUSH
25444: LD_INT 1
25446: ARRAY
25447: PPUSH
25448: CALL_OW 52
// end ;
25452: GO 25091
25454: POP
25455: POP
// end ;
25456: GO 24393
25458: POP
25459: POP
// result := result ^ buildings ;
25460: LD_ADDR_VAR 0 7
25464: PUSH
25465: LD_VAR 0 7
25469: PUSH
25470: LD_VAR 0 18
25474: ADD
25475: ST_TO_ADDR
// end else
25476: GO 25619
// begin for i = 1 to personel do
25478: LD_ADDR_VAR 0 8
25482: PUSH
25483: DOUBLE
25484: LD_INT 1
25486: DEC
25487: ST_TO_ADDR
25488: LD_VAR 0 6
25492: PUSH
25493: FOR_TO
25494: IFFALSE 25617
// begin if i > 4 then
25496: LD_VAR 0 8
25500: PUSH
25501: LD_INT 4
25503: GREATER
25504: IFFALSE 25508
// break ;
25506: GO 25617
// x := personel [ i ] ;
25508: LD_ADDR_VAR 0 13
25512: PUSH
25513: LD_VAR 0 6
25517: PUSH
25518: LD_VAR 0 8
25522: ARRAY
25523: ST_TO_ADDR
// if x = - 1 then
25524: LD_VAR 0 13
25528: PUSH
25529: LD_INT 1
25531: NEG
25532: EQUAL
25533: IFFALSE 25537
// continue ;
25535: GO 25493
// PrepareHuman ( false , i , skill ) ;
25537: LD_INT 0
25539: PPUSH
25540: LD_VAR 0 8
25544: PPUSH
25545: LD_VAR 0 4
25549: PPUSH
25550: CALL_OW 380
// un := CreateHuman ;
25554: LD_ADDR_VAR 0 14
25558: PUSH
25559: CALL_OW 44
25563: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25564: LD_VAR 0 14
25568: PPUSH
25569: LD_VAR 0 1
25573: PPUSH
25574: CALL_OW 250
25578: PPUSH
25579: LD_VAR 0 1
25583: PPUSH
25584: CALL_OW 251
25588: PPUSH
25589: LD_INT 10
25591: PPUSH
25592: LD_INT 0
25594: PPUSH
25595: CALL_OW 50
// result := result ^ un ;
25599: LD_ADDR_VAR 0 7
25603: PUSH
25604: LD_VAR 0 7
25608: PUSH
25609: LD_VAR 0 14
25613: ADD
25614: ST_TO_ADDR
// end ;
25615: GO 25493
25617: POP
25618: POP
// end ; end ;
25619: LD_VAR 0 7
25623: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25624: LD_INT 0
25626: PPUSH
25627: PPUSH
25628: PPUSH
25629: PPUSH
25630: PPUSH
25631: PPUSH
25632: PPUSH
25633: PPUSH
25634: PPUSH
25635: PPUSH
25636: PPUSH
25637: PPUSH
25638: PPUSH
25639: PPUSH
25640: PPUSH
25641: PPUSH
// result := false ;
25642: LD_ADDR_VAR 0 3
25646: PUSH
25647: LD_INT 0
25649: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25650: LD_VAR 0 1
25654: NOT
25655: PUSH
25656: LD_VAR 0 1
25660: PPUSH
25661: CALL_OW 266
25665: PUSH
25666: LD_INT 32
25668: PUSH
25669: LD_INT 33
25671: PUSH
25672: EMPTY
25673: LIST
25674: LIST
25675: IN
25676: NOT
25677: OR
25678: IFFALSE 25682
// exit ;
25680: GO 26818
// nat := GetNation ( tower ) ;
25682: LD_ADDR_VAR 0 12
25686: PUSH
25687: LD_VAR 0 1
25691: PPUSH
25692: CALL_OW 248
25696: ST_TO_ADDR
// side := GetSide ( tower ) ;
25697: LD_ADDR_VAR 0 16
25701: PUSH
25702: LD_VAR 0 1
25706: PPUSH
25707: CALL_OW 255
25711: ST_TO_ADDR
// x := GetX ( tower ) ;
25712: LD_ADDR_VAR 0 10
25716: PUSH
25717: LD_VAR 0 1
25721: PPUSH
25722: CALL_OW 250
25726: ST_TO_ADDR
// y := GetY ( tower ) ;
25727: LD_ADDR_VAR 0 11
25731: PUSH
25732: LD_VAR 0 1
25736: PPUSH
25737: CALL_OW 251
25741: ST_TO_ADDR
// if not x or not y then
25742: LD_VAR 0 10
25746: NOT
25747: PUSH
25748: LD_VAR 0 11
25752: NOT
25753: OR
25754: IFFALSE 25758
// exit ;
25756: GO 26818
// weapon := 0 ;
25758: LD_ADDR_VAR 0 18
25762: PUSH
25763: LD_INT 0
25765: ST_TO_ADDR
// fac_list := [ ] ;
25766: LD_ADDR_VAR 0 17
25770: PUSH
25771: EMPTY
25772: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
25773: LD_ADDR_VAR 0 6
25777: PUSH
25778: LD_VAR 0 1
25782: PPUSH
25783: CALL_OW 274
25787: PPUSH
25788: LD_VAR 0 2
25792: PPUSH
25793: CALL 23396 0 2
25797: PPUSH
25798: LD_INT 30
25800: PUSH
25801: LD_INT 3
25803: PUSH
25804: EMPTY
25805: LIST
25806: LIST
25807: PPUSH
25808: CALL_OW 72
25812: ST_TO_ADDR
// if not factories then
25813: LD_VAR 0 6
25817: NOT
25818: IFFALSE 25822
// exit ;
25820: GO 26818
// for i in factories do
25822: LD_ADDR_VAR 0 8
25826: PUSH
25827: LD_VAR 0 6
25831: PUSH
25832: FOR_IN
25833: IFFALSE 25858
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25835: LD_ADDR_VAR 0 17
25839: PUSH
25840: LD_VAR 0 17
25844: PUSH
25845: LD_VAR 0 8
25849: PPUSH
25850: CALL_OW 478
25854: UNION
25855: ST_TO_ADDR
25856: GO 25832
25858: POP
25859: POP
// if not fac_list then
25860: LD_VAR 0 17
25864: NOT
25865: IFFALSE 25869
// exit ;
25867: GO 26818
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25869: LD_ADDR_VAR 0 5
25873: PUSH
25874: LD_INT 4
25876: PUSH
25877: LD_INT 5
25879: PUSH
25880: LD_INT 9
25882: PUSH
25883: LD_INT 10
25885: PUSH
25886: LD_INT 6
25888: PUSH
25889: LD_INT 7
25891: PUSH
25892: LD_INT 11
25894: PUSH
25895: EMPTY
25896: LIST
25897: LIST
25898: LIST
25899: LIST
25900: LIST
25901: LIST
25902: LIST
25903: PUSH
25904: LD_INT 27
25906: PUSH
25907: LD_INT 28
25909: PUSH
25910: LD_INT 26
25912: PUSH
25913: LD_INT 30
25915: PUSH
25916: EMPTY
25917: LIST
25918: LIST
25919: LIST
25920: LIST
25921: PUSH
25922: LD_INT 43
25924: PUSH
25925: LD_INT 44
25927: PUSH
25928: LD_INT 46
25930: PUSH
25931: LD_INT 45
25933: PUSH
25934: LD_INT 47
25936: PUSH
25937: LD_INT 49
25939: PUSH
25940: EMPTY
25941: LIST
25942: LIST
25943: LIST
25944: LIST
25945: LIST
25946: LIST
25947: PUSH
25948: EMPTY
25949: LIST
25950: LIST
25951: LIST
25952: PUSH
25953: LD_VAR 0 12
25957: ARRAY
25958: ST_TO_ADDR
// for i in list do
25959: LD_ADDR_VAR 0 8
25963: PUSH
25964: LD_VAR 0 5
25968: PUSH
25969: FOR_IN
25970: IFFALSE 26003
// if not i in fac_list then
25972: LD_VAR 0 8
25976: PUSH
25977: LD_VAR 0 17
25981: IN
25982: NOT
25983: IFFALSE 26001
// list := list diff i ;
25985: LD_ADDR_VAR 0 5
25989: PUSH
25990: LD_VAR 0 5
25994: PUSH
25995: LD_VAR 0 8
25999: DIFF
26000: ST_TO_ADDR
26001: GO 25969
26003: POP
26004: POP
// if not list then
26005: LD_VAR 0 5
26009: NOT
26010: IFFALSE 26014
// exit ;
26012: GO 26818
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26014: LD_VAR 0 12
26018: PUSH
26019: LD_INT 3
26021: EQUAL
26022: PUSH
26023: LD_INT 49
26025: PUSH
26026: LD_VAR 0 5
26030: IN
26031: AND
26032: PUSH
26033: LD_INT 31
26035: PPUSH
26036: LD_VAR 0 16
26040: PPUSH
26041: CALL_OW 321
26045: PUSH
26046: LD_INT 2
26048: EQUAL
26049: AND
26050: IFFALSE 26110
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26052: LD_INT 22
26054: PUSH
26055: LD_VAR 0 16
26059: PUSH
26060: EMPTY
26061: LIST
26062: LIST
26063: PUSH
26064: LD_INT 35
26066: PUSH
26067: LD_INT 49
26069: PUSH
26070: EMPTY
26071: LIST
26072: LIST
26073: PUSH
26074: LD_INT 91
26076: PUSH
26077: LD_VAR 0 1
26081: PUSH
26082: LD_INT 10
26084: PUSH
26085: EMPTY
26086: LIST
26087: LIST
26088: LIST
26089: PUSH
26090: EMPTY
26091: LIST
26092: LIST
26093: LIST
26094: PPUSH
26095: CALL_OW 69
26099: NOT
26100: IFFALSE 26110
// weapon := ru_time_lapser ;
26102: LD_ADDR_VAR 0 18
26106: PUSH
26107: LD_INT 49
26109: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26110: LD_VAR 0 12
26114: PUSH
26115: LD_INT 1
26117: PUSH
26118: LD_INT 2
26120: PUSH
26121: EMPTY
26122: LIST
26123: LIST
26124: IN
26125: PUSH
26126: LD_INT 11
26128: PUSH
26129: LD_VAR 0 5
26133: IN
26134: PUSH
26135: LD_INT 30
26137: PUSH
26138: LD_VAR 0 5
26142: IN
26143: OR
26144: AND
26145: PUSH
26146: LD_INT 6
26148: PPUSH
26149: LD_VAR 0 16
26153: PPUSH
26154: CALL_OW 321
26158: PUSH
26159: LD_INT 2
26161: EQUAL
26162: AND
26163: IFFALSE 26328
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
26165: LD_INT 22
26167: PUSH
26168: LD_VAR 0 16
26172: PUSH
26173: EMPTY
26174: LIST
26175: LIST
26176: PUSH
26177: LD_INT 2
26179: PUSH
26180: LD_INT 35
26182: PUSH
26183: LD_INT 11
26185: PUSH
26186: EMPTY
26187: LIST
26188: LIST
26189: PUSH
26190: LD_INT 35
26192: PUSH
26193: LD_INT 30
26195: PUSH
26196: EMPTY
26197: LIST
26198: LIST
26199: PUSH
26200: EMPTY
26201: LIST
26202: LIST
26203: LIST
26204: PUSH
26205: LD_INT 91
26207: PUSH
26208: LD_VAR 0 1
26212: PUSH
26213: LD_INT 18
26215: PUSH
26216: EMPTY
26217: LIST
26218: LIST
26219: LIST
26220: PUSH
26221: EMPTY
26222: LIST
26223: LIST
26224: LIST
26225: PPUSH
26226: CALL_OW 69
26230: NOT
26231: PUSH
26232: LD_INT 22
26234: PUSH
26235: LD_VAR 0 16
26239: PUSH
26240: EMPTY
26241: LIST
26242: LIST
26243: PUSH
26244: LD_INT 2
26246: PUSH
26247: LD_INT 30
26249: PUSH
26250: LD_INT 32
26252: PUSH
26253: EMPTY
26254: LIST
26255: LIST
26256: PUSH
26257: LD_INT 30
26259: PUSH
26260: LD_INT 33
26262: PUSH
26263: EMPTY
26264: LIST
26265: LIST
26266: PUSH
26267: EMPTY
26268: LIST
26269: LIST
26270: LIST
26271: PUSH
26272: LD_INT 91
26274: PUSH
26275: LD_VAR 0 1
26279: PUSH
26280: LD_INT 12
26282: PUSH
26283: EMPTY
26284: LIST
26285: LIST
26286: LIST
26287: PUSH
26288: EMPTY
26289: LIST
26290: LIST
26291: LIST
26292: PUSH
26293: EMPTY
26294: LIST
26295: PPUSH
26296: CALL_OW 69
26300: PUSH
26301: LD_INT 2
26303: GREATER
26304: AND
26305: IFFALSE 26328
// weapon := [ us_radar , ar_radar ] [ nat ] ;
26307: LD_ADDR_VAR 0 18
26311: PUSH
26312: LD_INT 11
26314: PUSH
26315: LD_INT 30
26317: PUSH
26318: EMPTY
26319: LIST
26320: LIST
26321: PUSH
26322: LD_VAR 0 12
26326: ARRAY
26327: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
26328: LD_VAR 0 18
26332: NOT
26333: PUSH
26334: LD_INT 40
26336: PPUSH
26337: LD_VAR 0 16
26341: PPUSH
26342: CALL_OW 321
26346: PUSH
26347: LD_INT 2
26349: EQUAL
26350: AND
26351: PUSH
26352: LD_INT 7
26354: PUSH
26355: LD_VAR 0 5
26359: IN
26360: PUSH
26361: LD_INT 28
26363: PUSH
26364: LD_VAR 0 5
26368: IN
26369: OR
26370: PUSH
26371: LD_INT 45
26373: PUSH
26374: LD_VAR 0 5
26378: IN
26379: OR
26380: AND
26381: IFFALSE 26635
// begin hex := GetHexInfo ( x , y ) ;
26383: LD_ADDR_VAR 0 4
26387: PUSH
26388: LD_VAR 0 10
26392: PPUSH
26393: LD_VAR 0 11
26397: PPUSH
26398: CALL_OW 546
26402: ST_TO_ADDR
// if hex [ 1 ] then
26403: LD_VAR 0 4
26407: PUSH
26408: LD_INT 1
26410: ARRAY
26411: IFFALSE 26415
// exit ;
26413: GO 26818
// height := hex [ 2 ] ;
26415: LD_ADDR_VAR 0 15
26419: PUSH
26420: LD_VAR 0 4
26424: PUSH
26425: LD_INT 2
26427: ARRAY
26428: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26429: LD_ADDR_VAR 0 14
26433: PUSH
26434: LD_INT 0
26436: PUSH
26437: LD_INT 2
26439: PUSH
26440: LD_INT 3
26442: PUSH
26443: LD_INT 5
26445: PUSH
26446: EMPTY
26447: LIST
26448: LIST
26449: LIST
26450: LIST
26451: ST_TO_ADDR
// for i in tmp do
26452: LD_ADDR_VAR 0 8
26456: PUSH
26457: LD_VAR 0 14
26461: PUSH
26462: FOR_IN
26463: IFFALSE 26633
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26465: LD_ADDR_VAR 0 9
26469: PUSH
26470: LD_VAR 0 10
26474: PPUSH
26475: LD_VAR 0 8
26479: PPUSH
26480: LD_INT 5
26482: PPUSH
26483: CALL_OW 272
26487: PUSH
26488: LD_VAR 0 11
26492: PPUSH
26493: LD_VAR 0 8
26497: PPUSH
26498: LD_INT 5
26500: PPUSH
26501: CALL_OW 273
26505: PUSH
26506: EMPTY
26507: LIST
26508: LIST
26509: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26510: LD_VAR 0 9
26514: PUSH
26515: LD_INT 1
26517: ARRAY
26518: PPUSH
26519: LD_VAR 0 9
26523: PUSH
26524: LD_INT 2
26526: ARRAY
26527: PPUSH
26528: CALL_OW 488
26532: IFFALSE 26631
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26534: LD_ADDR_VAR 0 4
26538: PUSH
26539: LD_VAR 0 9
26543: PUSH
26544: LD_INT 1
26546: ARRAY
26547: PPUSH
26548: LD_VAR 0 9
26552: PUSH
26553: LD_INT 2
26555: ARRAY
26556: PPUSH
26557: CALL_OW 546
26561: ST_TO_ADDR
// if hex [ 1 ] then
26562: LD_VAR 0 4
26566: PUSH
26567: LD_INT 1
26569: ARRAY
26570: IFFALSE 26574
// continue ;
26572: GO 26462
// h := hex [ 2 ] ;
26574: LD_ADDR_VAR 0 13
26578: PUSH
26579: LD_VAR 0 4
26583: PUSH
26584: LD_INT 2
26586: ARRAY
26587: ST_TO_ADDR
// if h + 7 < height then
26588: LD_VAR 0 13
26592: PUSH
26593: LD_INT 7
26595: PLUS
26596: PUSH
26597: LD_VAR 0 15
26601: LESS
26602: IFFALSE 26631
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26604: LD_ADDR_VAR 0 18
26608: PUSH
26609: LD_INT 7
26611: PUSH
26612: LD_INT 28
26614: PUSH
26615: LD_INT 45
26617: PUSH
26618: EMPTY
26619: LIST
26620: LIST
26621: LIST
26622: PUSH
26623: LD_VAR 0 12
26627: ARRAY
26628: ST_TO_ADDR
// break ;
26629: GO 26633
// end ; end ; end ;
26631: GO 26462
26633: POP
26634: POP
// end ; if not weapon then
26635: LD_VAR 0 18
26639: NOT
26640: IFFALSE 26700
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26642: LD_ADDR_VAR 0 5
26646: PUSH
26647: LD_VAR 0 5
26651: PUSH
26652: LD_INT 11
26654: PUSH
26655: LD_INT 30
26657: PUSH
26658: LD_INT 49
26660: PUSH
26661: EMPTY
26662: LIST
26663: LIST
26664: LIST
26665: DIFF
26666: ST_TO_ADDR
// if not list then
26667: LD_VAR 0 5
26671: NOT
26672: IFFALSE 26676
// exit ;
26674: GO 26818
// weapon := list [ rand ( 1 , list ) ] ;
26676: LD_ADDR_VAR 0 18
26680: PUSH
26681: LD_VAR 0 5
26685: PUSH
26686: LD_INT 1
26688: PPUSH
26689: LD_VAR 0 5
26693: PPUSH
26694: CALL_OW 12
26698: ARRAY
26699: ST_TO_ADDR
// end ; if weapon then
26700: LD_VAR 0 18
26704: IFFALSE 26818
// begin tmp := CostOfWeapon ( weapon ) ;
26706: LD_ADDR_VAR 0 14
26710: PUSH
26711: LD_VAR 0 18
26715: PPUSH
26716: CALL_OW 451
26720: ST_TO_ADDR
// j := GetBase ( tower ) ;
26721: LD_ADDR_VAR 0 9
26725: PUSH
26726: LD_VAR 0 1
26730: PPUSH
26731: CALL_OW 274
26735: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26736: LD_VAR 0 9
26740: PPUSH
26741: LD_INT 1
26743: PPUSH
26744: CALL_OW 275
26748: PUSH
26749: LD_VAR 0 14
26753: PUSH
26754: LD_INT 1
26756: ARRAY
26757: GREATEREQUAL
26758: PUSH
26759: LD_VAR 0 9
26763: PPUSH
26764: LD_INT 2
26766: PPUSH
26767: CALL_OW 275
26771: PUSH
26772: LD_VAR 0 14
26776: PUSH
26777: LD_INT 2
26779: ARRAY
26780: GREATEREQUAL
26781: AND
26782: PUSH
26783: LD_VAR 0 9
26787: PPUSH
26788: LD_INT 3
26790: PPUSH
26791: CALL_OW 275
26795: PUSH
26796: LD_VAR 0 14
26800: PUSH
26801: LD_INT 3
26803: ARRAY
26804: GREATEREQUAL
26805: AND
26806: IFFALSE 26818
// result := weapon ;
26808: LD_ADDR_VAR 0 3
26812: PUSH
26813: LD_VAR 0 18
26817: ST_TO_ADDR
// end ; end ;
26818: LD_VAR 0 3
26822: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26823: LD_INT 0
26825: PPUSH
26826: PPUSH
// result := true ;
26827: LD_ADDR_VAR 0 3
26831: PUSH
26832: LD_INT 1
26834: ST_TO_ADDR
// if array1 = array2 then
26835: LD_VAR 0 1
26839: PUSH
26840: LD_VAR 0 2
26844: EQUAL
26845: IFFALSE 26905
// begin for i = 1 to array1 do
26847: LD_ADDR_VAR 0 4
26851: PUSH
26852: DOUBLE
26853: LD_INT 1
26855: DEC
26856: ST_TO_ADDR
26857: LD_VAR 0 1
26861: PUSH
26862: FOR_TO
26863: IFFALSE 26901
// if array1 [ i ] <> array2 [ i ] then
26865: LD_VAR 0 1
26869: PUSH
26870: LD_VAR 0 4
26874: ARRAY
26875: PUSH
26876: LD_VAR 0 2
26880: PUSH
26881: LD_VAR 0 4
26885: ARRAY
26886: NONEQUAL
26887: IFFALSE 26899
// begin result := false ;
26889: LD_ADDR_VAR 0 3
26893: PUSH
26894: LD_INT 0
26896: ST_TO_ADDR
// break ;
26897: GO 26901
// end ;
26899: GO 26862
26901: POP
26902: POP
// end else
26903: GO 26913
// result := false ;
26905: LD_ADDR_VAR 0 3
26909: PUSH
26910: LD_INT 0
26912: ST_TO_ADDR
// end ;
26913: LD_VAR 0 3
26917: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26918: LD_INT 0
26920: PPUSH
26921: PPUSH
26922: PPUSH
// pom := GetBase ( fac ) ;
26923: LD_ADDR_VAR 0 5
26927: PUSH
26928: LD_VAR 0 1
26932: PPUSH
26933: CALL_OW 274
26937: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26938: LD_ADDR_VAR 0 4
26942: PUSH
26943: LD_VAR 0 2
26947: PUSH
26948: LD_INT 1
26950: ARRAY
26951: PPUSH
26952: LD_VAR 0 2
26956: PUSH
26957: LD_INT 2
26959: ARRAY
26960: PPUSH
26961: LD_VAR 0 2
26965: PUSH
26966: LD_INT 3
26968: ARRAY
26969: PPUSH
26970: LD_VAR 0 2
26974: PUSH
26975: LD_INT 4
26977: ARRAY
26978: PPUSH
26979: CALL_OW 449
26983: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26984: LD_ADDR_VAR 0 3
26988: PUSH
26989: LD_VAR 0 5
26993: PPUSH
26994: LD_INT 1
26996: PPUSH
26997: CALL_OW 275
27001: PUSH
27002: LD_VAR 0 4
27006: PUSH
27007: LD_INT 1
27009: ARRAY
27010: GREATEREQUAL
27011: PUSH
27012: LD_VAR 0 5
27016: PPUSH
27017: LD_INT 2
27019: PPUSH
27020: CALL_OW 275
27024: PUSH
27025: LD_VAR 0 4
27029: PUSH
27030: LD_INT 2
27032: ARRAY
27033: GREATEREQUAL
27034: AND
27035: PUSH
27036: LD_VAR 0 5
27040: PPUSH
27041: LD_INT 3
27043: PPUSH
27044: CALL_OW 275
27048: PUSH
27049: LD_VAR 0 4
27053: PUSH
27054: LD_INT 3
27056: ARRAY
27057: GREATEREQUAL
27058: AND
27059: ST_TO_ADDR
// end ;
27060: LD_VAR 0 3
27064: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27065: LD_INT 0
27067: PPUSH
27068: PPUSH
27069: PPUSH
27070: PPUSH
// pom := GetBase ( building ) ;
27071: LD_ADDR_VAR 0 3
27075: PUSH
27076: LD_VAR 0 1
27080: PPUSH
27081: CALL_OW 274
27085: ST_TO_ADDR
// if not pom then
27086: LD_VAR 0 3
27090: NOT
27091: IFFALSE 27095
// exit ;
27093: GO 27265
// btype := GetBType ( building ) ;
27095: LD_ADDR_VAR 0 5
27099: PUSH
27100: LD_VAR 0 1
27104: PPUSH
27105: CALL_OW 266
27109: ST_TO_ADDR
// if btype = b_armoury then
27110: LD_VAR 0 5
27114: PUSH
27115: LD_INT 4
27117: EQUAL
27118: IFFALSE 27128
// btype := b_barracks ;
27120: LD_ADDR_VAR 0 5
27124: PUSH
27125: LD_INT 5
27127: ST_TO_ADDR
// if btype = b_depot then
27128: LD_VAR 0 5
27132: PUSH
27133: LD_INT 0
27135: EQUAL
27136: IFFALSE 27146
// btype := b_warehouse ;
27138: LD_ADDR_VAR 0 5
27142: PUSH
27143: LD_INT 1
27145: ST_TO_ADDR
// if btype = b_workshop then
27146: LD_VAR 0 5
27150: PUSH
27151: LD_INT 2
27153: EQUAL
27154: IFFALSE 27164
// btype := b_factory ;
27156: LD_ADDR_VAR 0 5
27160: PUSH
27161: LD_INT 3
27163: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27164: LD_ADDR_VAR 0 4
27168: PUSH
27169: LD_VAR 0 5
27173: PPUSH
27174: LD_VAR 0 1
27178: PPUSH
27179: CALL_OW 248
27183: PPUSH
27184: CALL_OW 450
27188: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27189: LD_ADDR_VAR 0 2
27193: PUSH
27194: LD_VAR 0 3
27198: PPUSH
27199: LD_INT 1
27201: PPUSH
27202: CALL_OW 275
27206: PUSH
27207: LD_VAR 0 4
27211: PUSH
27212: LD_INT 1
27214: ARRAY
27215: GREATEREQUAL
27216: PUSH
27217: LD_VAR 0 3
27221: PPUSH
27222: LD_INT 2
27224: PPUSH
27225: CALL_OW 275
27229: PUSH
27230: LD_VAR 0 4
27234: PUSH
27235: LD_INT 2
27237: ARRAY
27238: GREATEREQUAL
27239: AND
27240: PUSH
27241: LD_VAR 0 3
27245: PPUSH
27246: LD_INT 3
27248: PPUSH
27249: CALL_OW 275
27253: PUSH
27254: LD_VAR 0 4
27258: PUSH
27259: LD_INT 3
27261: ARRAY
27262: GREATEREQUAL
27263: AND
27264: ST_TO_ADDR
// end ;
27265: LD_VAR 0 2
27269: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
27270: LD_INT 0
27272: PPUSH
27273: PPUSH
27274: PPUSH
// pom := GetBase ( building ) ;
27275: LD_ADDR_VAR 0 4
27279: PUSH
27280: LD_VAR 0 1
27284: PPUSH
27285: CALL_OW 274
27289: ST_TO_ADDR
// if not pom then
27290: LD_VAR 0 4
27294: NOT
27295: IFFALSE 27299
// exit ;
27297: GO 27400
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27299: LD_ADDR_VAR 0 5
27303: PUSH
27304: LD_VAR 0 2
27308: PPUSH
27309: LD_VAR 0 1
27313: PPUSH
27314: CALL_OW 248
27318: PPUSH
27319: CALL_OW 450
27323: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27324: LD_ADDR_VAR 0 3
27328: PUSH
27329: LD_VAR 0 4
27333: PPUSH
27334: LD_INT 1
27336: PPUSH
27337: CALL_OW 275
27341: PUSH
27342: LD_VAR 0 5
27346: PUSH
27347: LD_INT 1
27349: ARRAY
27350: GREATEREQUAL
27351: PUSH
27352: LD_VAR 0 4
27356: PPUSH
27357: LD_INT 2
27359: PPUSH
27360: CALL_OW 275
27364: PUSH
27365: LD_VAR 0 5
27369: PUSH
27370: LD_INT 2
27372: ARRAY
27373: GREATEREQUAL
27374: AND
27375: PUSH
27376: LD_VAR 0 4
27380: PPUSH
27381: LD_INT 3
27383: PPUSH
27384: CALL_OW 275
27388: PUSH
27389: LD_VAR 0 5
27393: PUSH
27394: LD_INT 3
27396: ARRAY
27397: GREATEREQUAL
27398: AND
27399: ST_TO_ADDR
// end ;
27400: LD_VAR 0 3
27404: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
27405: LD_INT 0
27407: PPUSH
27408: PPUSH
27409: PPUSH
27410: PPUSH
27411: PPUSH
27412: PPUSH
27413: PPUSH
27414: PPUSH
27415: PPUSH
27416: PPUSH
// result := false ;
27417: LD_ADDR_VAR 0 6
27421: PUSH
27422: LD_INT 0
27424: ST_TO_ADDR
// if not base or not btype or not x or not y then
27425: LD_VAR 0 1
27429: NOT
27430: PUSH
27431: LD_VAR 0 2
27435: NOT
27436: OR
27437: PUSH
27438: LD_VAR 0 3
27442: NOT
27443: OR
27444: PUSH
27445: LD_VAR 0 4
27449: NOT
27450: OR
27451: IFFALSE 27455
// exit ;
27453: GO 28064
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
27455: LD_ADDR_VAR 0 12
27459: PUSH
27460: LD_VAR 0 2
27464: PPUSH
27465: LD_VAR 0 3
27469: PPUSH
27470: LD_VAR 0 4
27474: PPUSH
27475: LD_VAR 0 5
27479: PPUSH
27480: LD_VAR 0 1
27484: PUSH
27485: LD_INT 1
27487: ARRAY
27488: PPUSH
27489: CALL_OW 248
27493: PPUSH
27494: LD_INT 0
27496: PPUSH
27497: CALL 28901 0 6
27501: ST_TO_ADDR
// if not hexes then
27502: LD_VAR 0 12
27506: NOT
27507: IFFALSE 27511
// exit ;
27509: GO 28064
// for i = 1 to hexes do
27511: LD_ADDR_VAR 0 7
27515: PUSH
27516: DOUBLE
27517: LD_INT 1
27519: DEC
27520: ST_TO_ADDR
27521: LD_VAR 0 12
27525: PUSH
27526: FOR_TO
27527: IFFALSE 28062
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27529: LD_ADDR_VAR 0 11
27533: PUSH
27534: LD_VAR 0 12
27538: PUSH
27539: LD_VAR 0 7
27543: ARRAY
27544: PUSH
27545: LD_INT 1
27547: ARRAY
27548: PPUSH
27549: LD_VAR 0 12
27553: PUSH
27554: LD_VAR 0 7
27558: ARRAY
27559: PUSH
27560: LD_INT 2
27562: ARRAY
27563: PPUSH
27564: CALL_OW 428
27568: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27569: LD_VAR 0 12
27573: PUSH
27574: LD_VAR 0 7
27578: ARRAY
27579: PUSH
27580: LD_INT 1
27582: ARRAY
27583: PPUSH
27584: LD_VAR 0 12
27588: PUSH
27589: LD_VAR 0 7
27593: ARRAY
27594: PUSH
27595: LD_INT 2
27597: ARRAY
27598: PPUSH
27599: CALL_OW 351
27603: PUSH
27604: LD_VAR 0 12
27608: PUSH
27609: LD_VAR 0 7
27613: ARRAY
27614: PUSH
27615: LD_INT 1
27617: ARRAY
27618: PPUSH
27619: LD_VAR 0 12
27623: PUSH
27624: LD_VAR 0 7
27628: ARRAY
27629: PUSH
27630: LD_INT 2
27632: ARRAY
27633: PPUSH
27634: CALL_OW 488
27638: NOT
27639: OR
27640: PUSH
27641: LD_VAR 0 11
27645: PPUSH
27646: CALL_OW 247
27650: PUSH
27651: LD_INT 3
27653: EQUAL
27654: OR
27655: IFFALSE 27661
// exit ;
27657: POP
27658: POP
27659: GO 28064
// if not tmp or not tmp in base then
27661: LD_VAR 0 11
27665: NOT
27666: PUSH
27667: LD_VAR 0 11
27671: PUSH
27672: LD_VAR 0 1
27676: IN
27677: NOT
27678: OR
27679: IFFALSE 27683
// continue ;
27681: GO 27526
// result := true ;
27683: LD_ADDR_VAR 0 6
27687: PUSH
27688: LD_INT 1
27690: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27691: LD_ADDR_VAR 0 15
27695: PUSH
27696: LD_VAR 0 1
27700: PPUSH
27701: LD_INT 22
27703: PUSH
27704: LD_VAR 0 11
27708: PPUSH
27709: CALL_OW 255
27713: PUSH
27714: EMPTY
27715: LIST
27716: LIST
27717: PUSH
27718: LD_INT 2
27720: PUSH
27721: LD_INT 30
27723: PUSH
27724: LD_INT 0
27726: PUSH
27727: EMPTY
27728: LIST
27729: LIST
27730: PUSH
27731: LD_INT 30
27733: PUSH
27734: LD_INT 1
27736: PUSH
27737: EMPTY
27738: LIST
27739: LIST
27740: PUSH
27741: EMPTY
27742: LIST
27743: LIST
27744: LIST
27745: PUSH
27746: EMPTY
27747: LIST
27748: LIST
27749: PPUSH
27750: CALL_OW 72
27754: ST_TO_ADDR
// if dep then
27755: LD_VAR 0 15
27759: IFFALSE 27895
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27761: LD_ADDR_VAR 0 14
27765: PUSH
27766: LD_VAR 0 15
27770: PUSH
27771: LD_INT 1
27773: ARRAY
27774: PPUSH
27775: CALL_OW 250
27779: PPUSH
27780: LD_VAR 0 15
27784: PUSH
27785: LD_INT 1
27787: ARRAY
27788: PPUSH
27789: CALL_OW 254
27793: PPUSH
27794: LD_INT 5
27796: PPUSH
27797: CALL_OW 272
27801: PUSH
27802: LD_VAR 0 15
27806: PUSH
27807: LD_INT 1
27809: ARRAY
27810: PPUSH
27811: CALL_OW 251
27815: PPUSH
27816: LD_VAR 0 15
27820: PUSH
27821: LD_INT 1
27823: ARRAY
27824: PPUSH
27825: CALL_OW 254
27829: PPUSH
27830: LD_INT 5
27832: PPUSH
27833: CALL_OW 273
27837: PUSH
27838: EMPTY
27839: LIST
27840: LIST
27841: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27842: LD_VAR 0 14
27846: PUSH
27847: LD_INT 1
27849: ARRAY
27850: PPUSH
27851: LD_VAR 0 14
27855: PUSH
27856: LD_INT 2
27858: ARRAY
27859: PPUSH
27860: CALL_OW 488
27864: IFFALSE 27895
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27866: LD_VAR 0 11
27870: PPUSH
27871: LD_VAR 0 14
27875: PUSH
27876: LD_INT 1
27878: ARRAY
27879: PPUSH
27880: LD_VAR 0 14
27884: PUSH
27885: LD_INT 2
27887: ARRAY
27888: PPUSH
27889: CALL_OW 111
// continue ;
27893: GO 27526
// end ; end ; r := GetDir ( tmp ) ;
27895: LD_ADDR_VAR 0 13
27899: PUSH
27900: LD_VAR 0 11
27904: PPUSH
27905: CALL_OW 254
27909: ST_TO_ADDR
// if r = 5 then
27910: LD_VAR 0 13
27914: PUSH
27915: LD_INT 5
27917: EQUAL
27918: IFFALSE 27928
// r := 0 ;
27920: LD_ADDR_VAR 0 13
27924: PUSH
27925: LD_INT 0
27927: ST_TO_ADDR
// for j = r to 5 do
27928: LD_ADDR_VAR 0 8
27932: PUSH
27933: DOUBLE
27934: LD_VAR 0 13
27938: DEC
27939: ST_TO_ADDR
27940: LD_INT 5
27942: PUSH
27943: FOR_TO
27944: IFFALSE 28058
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27946: LD_ADDR_VAR 0 9
27950: PUSH
27951: LD_VAR 0 11
27955: PPUSH
27956: CALL_OW 250
27960: PPUSH
27961: LD_VAR 0 8
27965: PPUSH
27966: LD_INT 2
27968: PPUSH
27969: CALL_OW 272
27973: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27974: LD_ADDR_VAR 0 10
27978: PUSH
27979: LD_VAR 0 11
27983: PPUSH
27984: CALL_OW 251
27988: PPUSH
27989: LD_VAR 0 8
27993: PPUSH
27994: LD_INT 2
27996: PPUSH
27997: CALL_OW 273
28001: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28002: LD_VAR 0 9
28006: PPUSH
28007: LD_VAR 0 10
28011: PPUSH
28012: CALL_OW 488
28016: PUSH
28017: LD_VAR 0 9
28021: PPUSH
28022: LD_VAR 0 10
28026: PPUSH
28027: CALL_OW 428
28031: NOT
28032: AND
28033: IFFALSE 28056
// begin ComMoveXY ( tmp , _x , _y ) ;
28035: LD_VAR 0 11
28039: PPUSH
28040: LD_VAR 0 9
28044: PPUSH
28045: LD_VAR 0 10
28049: PPUSH
28050: CALL_OW 111
// break ;
28054: GO 28058
// end ; end ;
28056: GO 27943
28058: POP
28059: POP
// end ;
28060: GO 27526
28062: POP
28063: POP
// end ;
28064: LD_VAR 0 6
28068: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
28069: LD_INT 0
28071: PPUSH
28072: PPUSH
28073: PPUSH
28074: PPUSH
28075: PPUSH
28076: PPUSH
28077: PPUSH
28078: PPUSH
28079: PPUSH
28080: PPUSH
// result := false ;
28081: LD_ADDR_VAR 0 6
28085: PUSH
28086: LD_INT 0
28088: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28089: LD_VAR 0 1
28093: NOT
28094: PUSH
28095: LD_VAR 0 1
28099: PPUSH
28100: CALL_OW 266
28104: PUSH
28105: LD_INT 0
28107: PUSH
28108: LD_INT 1
28110: PUSH
28111: EMPTY
28112: LIST
28113: LIST
28114: IN
28115: NOT
28116: OR
28117: PUSH
28118: LD_VAR 0 2
28122: NOT
28123: OR
28124: PUSH
28125: LD_VAR 0 5
28129: PUSH
28130: LD_INT 0
28132: PUSH
28133: LD_INT 1
28135: PUSH
28136: LD_INT 2
28138: PUSH
28139: LD_INT 3
28141: PUSH
28142: LD_INT 4
28144: PUSH
28145: LD_INT 5
28147: PUSH
28148: EMPTY
28149: LIST
28150: LIST
28151: LIST
28152: LIST
28153: LIST
28154: LIST
28155: IN
28156: NOT
28157: OR
28158: PUSH
28159: LD_VAR 0 3
28163: PPUSH
28164: LD_VAR 0 4
28168: PPUSH
28169: CALL_OW 488
28173: NOT
28174: OR
28175: IFFALSE 28179
// exit ;
28177: GO 28896
// pom := GetBase ( depot ) ;
28179: LD_ADDR_VAR 0 10
28183: PUSH
28184: LD_VAR 0 1
28188: PPUSH
28189: CALL_OW 274
28193: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28194: LD_ADDR_VAR 0 11
28198: PUSH
28199: LD_VAR 0 2
28203: PPUSH
28204: LD_VAR 0 1
28208: PPUSH
28209: CALL_OW 248
28213: PPUSH
28214: CALL_OW 450
28218: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28219: LD_VAR 0 10
28223: PPUSH
28224: LD_INT 1
28226: PPUSH
28227: CALL_OW 275
28231: PUSH
28232: LD_VAR 0 11
28236: PUSH
28237: LD_INT 1
28239: ARRAY
28240: GREATEREQUAL
28241: PUSH
28242: LD_VAR 0 10
28246: PPUSH
28247: LD_INT 2
28249: PPUSH
28250: CALL_OW 275
28254: PUSH
28255: LD_VAR 0 11
28259: PUSH
28260: LD_INT 2
28262: ARRAY
28263: GREATEREQUAL
28264: AND
28265: PUSH
28266: LD_VAR 0 10
28270: PPUSH
28271: LD_INT 3
28273: PPUSH
28274: CALL_OW 275
28278: PUSH
28279: LD_VAR 0 11
28283: PUSH
28284: LD_INT 3
28286: ARRAY
28287: GREATEREQUAL
28288: AND
28289: NOT
28290: IFFALSE 28294
// exit ;
28292: GO 28896
// if GetBType ( depot ) = b_depot then
28294: LD_VAR 0 1
28298: PPUSH
28299: CALL_OW 266
28303: PUSH
28304: LD_INT 0
28306: EQUAL
28307: IFFALSE 28319
// dist := 28 else
28309: LD_ADDR_VAR 0 14
28313: PUSH
28314: LD_INT 28
28316: ST_TO_ADDR
28317: GO 28327
// dist := 36 ;
28319: LD_ADDR_VAR 0 14
28323: PUSH
28324: LD_INT 36
28326: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28327: LD_VAR 0 1
28331: PPUSH
28332: LD_VAR 0 3
28336: PPUSH
28337: LD_VAR 0 4
28341: PPUSH
28342: CALL_OW 297
28346: PUSH
28347: LD_VAR 0 14
28351: GREATER
28352: IFFALSE 28356
// exit ;
28354: GO 28896
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28356: LD_ADDR_VAR 0 12
28360: PUSH
28361: LD_VAR 0 2
28365: PPUSH
28366: LD_VAR 0 3
28370: PPUSH
28371: LD_VAR 0 4
28375: PPUSH
28376: LD_VAR 0 5
28380: PPUSH
28381: LD_VAR 0 1
28385: PPUSH
28386: CALL_OW 248
28390: PPUSH
28391: LD_INT 0
28393: PPUSH
28394: CALL 28901 0 6
28398: ST_TO_ADDR
// if not hexes then
28399: LD_VAR 0 12
28403: NOT
28404: IFFALSE 28408
// exit ;
28406: GO 28896
// hex := GetHexInfo ( x , y ) ;
28408: LD_ADDR_VAR 0 15
28412: PUSH
28413: LD_VAR 0 3
28417: PPUSH
28418: LD_VAR 0 4
28422: PPUSH
28423: CALL_OW 546
28427: ST_TO_ADDR
// if hex [ 1 ] then
28428: LD_VAR 0 15
28432: PUSH
28433: LD_INT 1
28435: ARRAY
28436: IFFALSE 28440
// exit ;
28438: GO 28896
// height := hex [ 2 ] ;
28440: LD_ADDR_VAR 0 13
28444: PUSH
28445: LD_VAR 0 15
28449: PUSH
28450: LD_INT 2
28452: ARRAY
28453: ST_TO_ADDR
// for i = 1 to hexes do
28454: LD_ADDR_VAR 0 7
28458: PUSH
28459: DOUBLE
28460: LD_INT 1
28462: DEC
28463: ST_TO_ADDR
28464: LD_VAR 0 12
28468: PUSH
28469: FOR_TO
28470: IFFALSE 28800
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28472: LD_VAR 0 12
28476: PUSH
28477: LD_VAR 0 7
28481: ARRAY
28482: PUSH
28483: LD_INT 1
28485: ARRAY
28486: PPUSH
28487: LD_VAR 0 12
28491: PUSH
28492: LD_VAR 0 7
28496: ARRAY
28497: PUSH
28498: LD_INT 2
28500: ARRAY
28501: PPUSH
28502: CALL_OW 488
28506: NOT
28507: PUSH
28508: LD_VAR 0 12
28512: PUSH
28513: LD_VAR 0 7
28517: ARRAY
28518: PUSH
28519: LD_INT 1
28521: ARRAY
28522: PPUSH
28523: LD_VAR 0 12
28527: PUSH
28528: LD_VAR 0 7
28532: ARRAY
28533: PUSH
28534: LD_INT 2
28536: ARRAY
28537: PPUSH
28538: CALL_OW 428
28542: PUSH
28543: LD_INT 0
28545: GREATER
28546: OR
28547: PUSH
28548: LD_VAR 0 12
28552: PUSH
28553: LD_VAR 0 7
28557: ARRAY
28558: PUSH
28559: LD_INT 1
28561: ARRAY
28562: PPUSH
28563: LD_VAR 0 12
28567: PUSH
28568: LD_VAR 0 7
28572: ARRAY
28573: PUSH
28574: LD_INT 2
28576: ARRAY
28577: PPUSH
28578: CALL_OW 351
28582: OR
28583: IFFALSE 28589
// exit ;
28585: POP
28586: POP
28587: GO 28896
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28589: LD_ADDR_VAR 0 8
28593: PUSH
28594: LD_VAR 0 12
28598: PUSH
28599: LD_VAR 0 7
28603: ARRAY
28604: PUSH
28605: LD_INT 1
28607: ARRAY
28608: PPUSH
28609: LD_VAR 0 12
28613: PUSH
28614: LD_VAR 0 7
28618: ARRAY
28619: PUSH
28620: LD_INT 2
28622: ARRAY
28623: PPUSH
28624: CALL_OW 546
28628: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28629: LD_VAR 0 8
28633: PUSH
28634: LD_INT 1
28636: ARRAY
28637: PUSH
28638: LD_VAR 0 8
28642: PUSH
28643: LD_INT 2
28645: ARRAY
28646: PUSH
28647: LD_VAR 0 13
28651: PUSH
28652: LD_INT 2
28654: PLUS
28655: GREATER
28656: OR
28657: PUSH
28658: LD_VAR 0 8
28662: PUSH
28663: LD_INT 2
28665: ARRAY
28666: PUSH
28667: LD_VAR 0 13
28671: PUSH
28672: LD_INT 2
28674: MINUS
28675: LESS
28676: OR
28677: PUSH
28678: LD_VAR 0 8
28682: PUSH
28683: LD_INT 3
28685: ARRAY
28686: PUSH
28687: LD_INT 0
28689: PUSH
28690: LD_INT 8
28692: PUSH
28693: LD_INT 9
28695: PUSH
28696: LD_INT 10
28698: PUSH
28699: LD_INT 11
28701: PUSH
28702: LD_INT 12
28704: PUSH
28705: LD_INT 13
28707: PUSH
28708: LD_INT 16
28710: PUSH
28711: LD_INT 17
28713: PUSH
28714: LD_INT 18
28716: PUSH
28717: LD_INT 19
28719: PUSH
28720: LD_INT 20
28722: PUSH
28723: LD_INT 21
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: LIST
28730: LIST
28731: LIST
28732: LIST
28733: LIST
28734: LIST
28735: LIST
28736: LIST
28737: LIST
28738: LIST
28739: LIST
28740: IN
28741: NOT
28742: OR
28743: PUSH
28744: LD_VAR 0 8
28748: PUSH
28749: LD_INT 5
28751: ARRAY
28752: NOT
28753: OR
28754: PUSH
28755: LD_VAR 0 8
28759: PUSH
28760: LD_INT 6
28762: ARRAY
28763: PUSH
28764: LD_INT 1
28766: PUSH
28767: LD_INT 2
28769: PUSH
28770: LD_INT 7
28772: PUSH
28773: LD_INT 9
28775: PUSH
28776: LD_INT 10
28778: PUSH
28779: LD_INT 11
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: LIST
28786: LIST
28787: LIST
28788: LIST
28789: IN
28790: NOT
28791: OR
28792: IFFALSE 28798
// exit ;
28794: POP
28795: POP
28796: GO 28896
// end ;
28798: GO 28469
28800: POP
28801: POP
// side := GetSide ( depot ) ;
28802: LD_ADDR_VAR 0 9
28806: PUSH
28807: LD_VAR 0 1
28811: PPUSH
28812: CALL_OW 255
28816: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28817: LD_VAR 0 9
28821: PPUSH
28822: LD_VAR 0 3
28826: PPUSH
28827: LD_VAR 0 4
28831: PPUSH
28832: LD_INT 20
28834: PPUSH
28835: CALL 21550 0 4
28839: PUSH
28840: LD_INT 4
28842: ARRAY
28843: IFFALSE 28847
// exit ;
28845: GO 28896
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28847: LD_VAR 0 2
28851: PUSH
28852: LD_INT 29
28854: PUSH
28855: LD_INT 30
28857: PUSH
28858: EMPTY
28859: LIST
28860: LIST
28861: IN
28862: PUSH
28863: LD_VAR 0 3
28867: PPUSH
28868: LD_VAR 0 4
28872: PPUSH
28873: LD_VAR 0 9
28877: PPUSH
28878: CALL_OW 440
28882: NOT
28883: AND
28884: IFFALSE 28888
// exit ;
28886: GO 28896
// result := true ;
28888: LD_ADDR_VAR 0 6
28892: PUSH
28893: LD_INT 1
28895: ST_TO_ADDR
// end ;
28896: LD_VAR 0 6
28900: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
28901: LD_INT 0
28903: PPUSH
28904: PPUSH
28905: PPUSH
28906: PPUSH
28907: PPUSH
28908: PPUSH
28909: PPUSH
28910: PPUSH
28911: PPUSH
28912: PPUSH
28913: PPUSH
28914: PPUSH
28915: PPUSH
28916: PPUSH
28917: PPUSH
28918: PPUSH
28919: PPUSH
28920: PPUSH
28921: PPUSH
28922: PPUSH
28923: PPUSH
28924: PPUSH
28925: PPUSH
28926: PPUSH
28927: PPUSH
28928: PPUSH
28929: PPUSH
28930: PPUSH
28931: PPUSH
28932: PPUSH
28933: PPUSH
28934: PPUSH
28935: PPUSH
28936: PPUSH
28937: PPUSH
28938: PPUSH
28939: PPUSH
28940: PPUSH
28941: PPUSH
28942: PPUSH
28943: PPUSH
28944: PPUSH
28945: PPUSH
28946: PPUSH
28947: PPUSH
28948: PPUSH
28949: PPUSH
28950: PPUSH
28951: PPUSH
28952: PPUSH
28953: PPUSH
28954: PPUSH
28955: PPUSH
28956: PPUSH
28957: PPUSH
28958: PPUSH
28959: PPUSH
28960: PPUSH
// result = [ ] ;
28961: LD_ADDR_VAR 0 7
28965: PUSH
28966: EMPTY
28967: ST_TO_ADDR
// temp_list = [ ] ;
28968: LD_ADDR_VAR 0 9
28972: PUSH
28973: EMPTY
28974: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28975: LD_VAR 0 4
28979: PUSH
28980: LD_INT 0
28982: PUSH
28983: LD_INT 1
28985: PUSH
28986: LD_INT 2
28988: PUSH
28989: LD_INT 3
28991: PUSH
28992: LD_INT 4
28994: PUSH
28995: LD_INT 5
28997: PUSH
28998: EMPTY
28999: LIST
29000: LIST
29001: LIST
29002: LIST
29003: LIST
29004: LIST
29005: IN
29006: NOT
29007: PUSH
29008: LD_VAR 0 1
29012: PUSH
29013: LD_INT 0
29015: PUSH
29016: LD_INT 1
29018: PUSH
29019: EMPTY
29020: LIST
29021: LIST
29022: IN
29023: PUSH
29024: LD_VAR 0 5
29028: PUSH
29029: LD_INT 1
29031: PUSH
29032: LD_INT 2
29034: PUSH
29035: LD_INT 3
29037: PUSH
29038: EMPTY
29039: LIST
29040: LIST
29041: LIST
29042: IN
29043: NOT
29044: AND
29045: OR
29046: IFFALSE 29050
// exit ;
29048: GO 47441
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29050: LD_VAR 0 1
29054: PUSH
29055: LD_INT 6
29057: PUSH
29058: LD_INT 7
29060: PUSH
29061: LD_INT 8
29063: PUSH
29064: LD_INT 13
29066: PUSH
29067: LD_INT 12
29069: PUSH
29070: LD_INT 15
29072: PUSH
29073: LD_INT 11
29075: PUSH
29076: LD_INT 14
29078: PUSH
29079: LD_INT 10
29081: PUSH
29082: EMPTY
29083: LIST
29084: LIST
29085: LIST
29086: LIST
29087: LIST
29088: LIST
29089: LIST
29090: LIST
29091: LIST
29092: IN
29093: IFFALSE 29103
// btype = b_lab ;
29095: LD_ADDR_VAR 0 1
29099: PUSH
29100: LD_INT 6
29102: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29103: LD_VAR 0 6
29107: PUSH
29108: LD_INT 0
29110: PUSH
29111: LD_INT 1
29113: PUSH
29114: LD_INT 2
29116: PUSH
29117: EMPTY
29118: LIST
29119: LIST
29120: LIST
29121: IN
29122: NOT
29123: PUSH
29124: LD_VAR 0 1
29128: PUSH
29129: LD_INT 0
29131: PUSH
29132: LD_INT 1
29134: PUSH
29135: LD_INT 2
29137: PUSH
29138: LD_INT 3
29140: PUSH
29141: LD_INT 6
29143: PUSH
29144: LD_INT 36
29146: PUSH
29147: LD_INT 4
29149: PUSH
29150: LD_INT 5
29152: PUSH
29153: LD_INT 31
29155: PUSH
29156: LD_INT 32
29158: PUSH
29159: LD_INT 33
29161: PUSH
29162: EMPTY
29163: LIST
29164: LIST
29165: LIST
29166: LIST
29167: LIST
29168: LIST
29169: LIST
29170: LIST
29171: LIST
29172: LIST
29173: LIST
29174: IN
29175: NOT
29176: PUSH
29177: LD_VAR 0 6
29181: PUSH
29182: LD_INT 1
29184: EQUAL
29185: AND
29186: OR
29187: PUSH
29188: LD_VAR 0 1
29192: PUSH
29193: LD_INT 2
29195: PUSH
29196: LD_INT 3
29198: PUSH
29199: EMPTY
29200: LIST
29201: LIST
29202: IN
29203: NOT
29204: PUSH
29205: LD_VAR 0 6
29209: PUSH
29210: LD_INT 2
29212: EQUAL
29213: AND
29214: OR
29215: IFFALSE 29225
// mode = 0 ;
29217: LD_ADDR_VAR 0 6
29221: PUSH
29222: LD_INT 0
29224: ST_TO_ADDR
// case mode of 0 :
29225: LD_VAR 0 6
29229: PUSH
29230: LD_INT 0
29232: DOUBLE
29233: EQUAL
29234: IFTRUE 29238
29236: GO 40691
29238: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29239: LD_ADDR_VAR 0 11
29243: PUSH
29244: LD_INT 0
29246: PUSH
29247: LD_INT 0
29249: PUSH
29250: EMPTY
29251: LIST
29252: LIST
29253: PUSH
29254: LD_INT 0
29256: PUSH
29257: LD_INT 1
29259: NEG
29260: PUSH
29261: EMPTY
29262: LIST
29263: LIST
29264: PUSH
29265: LD_INT 1
29267: PUSH
29268: LD_INT 0
29270: PUSH
29271: EMPTY
29272: LIST
29273: LIST
29274: PUSH
29275: LD_INT 1
29277: PUSH
29278: LD_INT 1
29280: PUSH
29281: EMPTY
29282: LIST
29283: LIST
29284: PUSH
29285: LD_INT 0
29287: PUSH
29288: LD_INT 1
29290: PUSH
29291: EMPTY
29292: LIST
29293: LIST
29294: PUSH
29295: LD_INT 1
29297: NEG
29298: PUSH
29299: LD_INT 0
29301: PUSH
29302: EMPTY
29303: LIST
29304: LIST
29305: PUSH
29306: LD_INT 1
29308: NEG
29309: PUSH
29310: LD_INT 1
29312: NEG
29313: PUSH
29314: EMPTY
29315: LIST
29316: LIST
29317: PUSH
29318: LD_INT 1
29320: NEG
29321: PUSH
29322: LD_INT 2
29324: NEG
29325: PUSH
29326: EMPTY
29327: LIST
29328: LIST
29329: PUSH
29330: LD_INT 0
29332: PUSH
29333: LD_INT 2
29335: NEG
29336: PUSH
29337: EMPTY
29338: LIST
29339: LIST
29340: PUSH
29341: LD_INT 1
29343: PUSH
29344: LD_INT 1
29346: NEG
29347: PUSH
29348: EMPTY
29349: LIST
29350: LIST
29351: PUSH
29352: LD_INT 1
29354: PUSH
29355: LD_INT 2
29357: PUSH
29358: EMPTY
29359: LIST
29360: LIST
29361: PUSH
29362: LD_INT 0
29364: PUSH
29365: LD_INT 2
29367: PUSH
29368: EMPTY
29369: LIST
29370: LIST
29371: PUSH
29372: LD_INT 1
29374: NEG
29375: PUSH
29376: LD_INT 1
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: PUSH
29383: LD_INT 1
29385: PUSH
29386: LD_INT 3
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PUSH
29393: LD_INT 0
29395: PUSH
29396: LD_INT 3
29398: PUSH
29399: EMPTY
29400: LIST
29401: LIST
29402: PUSH
29403: LD_INT 1
29405: NEG
29406: PUSH
29407: LD_INT 2
29409: PUSH
29410: EMPTY
29411: LIST
29412: LIST
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: LIST
29418: LIST
29419: LIST
29420: LIST
29421: LIST
29422: LIST
29423: LIST
29424: LIST
29425: LIST
29426: LIST
29427: LIST
29428: LIST
29429: LIST
29430: LIST
29431: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29432: LD_ADDR_VAR 0 12
29436: PUSH
29437: LD_INT 0
29439: PUSH
29440: LD_INT 0
29442: PUSH
29443: EMPTY
29444: LIST
29445: LIST
29446: PUSH
29447: LD_INT 0
29449: PUSH
29450: LD_INT 1
29452: NEG
29453: PUSH
29454: EMPTY
29455: LIST
29456: LIST
29457: PUSH
29458: LD_INT 1
29460: PUSH
29461: LD_INT 0
29463: PUSH
29464: EMPTY
29465: LIST
29466: LIST
29467: PUSH
29468: LD_INT 1
29470: PUSH
29471: LD_INT 1
29473: PUSH
29474: EMPTY
29475: LIST
29476: LIST
29477: PUSH
29478: LD_INT 0
29480: PUSH
29481: LD_INT 1
29483: PUSH
29484: EMPTY
29485: LIST
29486: LIST
29487: PUSH
29488: LD_INT 1
29490: NEG
29491: PUSH
29492: LD_INT 0
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: LD_INT 1
29501: NEG
29502: PUSH
29503: LD_INT 1
29505: NEG
29506: PUSH
29507: EMPTY
29508: LIST
29509: LIST
29510: PUSH
29511: LD_INT 1
29513: PUSH
29514: LD_INT 1
29516: NEG
29517: PUSH
29518: EMPTY
29519: LIST
29520: LIST
29521: PUSH
29522: LD_INT 2
29524: PUSH
29525: LD_INT 0
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: PUSH
29532: LD_INT 2
29534: PUSH
29535: LD_INT 1
29537: PUSH
29538: EMPTY
29539: LIST
29540: LIST
29541: PUSH
29542: LD_INT 1
29544: NEG
29545: PUSH
29546: LD_INT 1
29548: PUSH
29549: EMPTY
29550: LIST
29551: LIST
29552: PUSH
29553: LD_INT 2
29555: NEG
29556: PUSH
29557: LD_INT 0
29559: PUSH
29560: EMPTY
29561: LIST
29562: LIST
29563: PUSH
29564: LD_INT 2
29566: NEG
29567: PUSH
29568: LD_INT 1
29570: NEG
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: LD_INT 2
29578: NEG
29579: PUSH
29580: LD_INT 1
29582: PUSH
29583: EMPTY
29584: LIST
29585: LIST
29586: PUSH
29587: LD_INT 3
29589: NEG
29590: PUSH
29591: LD_INT 0
29593: PUSH
29594: EMPTY
29595: LIST
29596: LIST
29597: PUSH
29598: LD_INT 3
29600: NEG
29601: PUSH
29602: LD_INT 1
29604: NEG
29605: PUSH
29606: EMPTY
29607: LIST
29608: LIST
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: LIST
29614: LIST
29615: LIST
29616: LIST
29617: LIST
29618: LIST
29619: LIST
29620: LIST
29621: LIST
29622: LIST
29623: LIST
29624: LIST
29625: LIST
29626: LIST
29627: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29628: LD_ADDR_VAR 0 13
29632: PUSH
29633: LD_INT 0
29635: PUSH
29636: LD_INT 0
29638: PUSH
29639: EMPTY
29640: LIST
29641: LIST
29642: PUSH
29643: LD_INT 0
29645: PUSH
29646: LD_INT 1
29648: NEG
29649: PUSH
29650: EMPTY
29651: LIST
29652: LIST
29653: PUSH
29654: LD_INT 1
29656: PUSH
29657: LD_INT 0
29659: PUSH
29660: EMPTY
29661: LIST
29662: LIST
29663: PUSH
29664: LD_INT 1
29666: PUSH
29667: LD_INT 1
29669: PUSH
29670: EMPTY
29671: LIST
29672: LIST
29673: PUSH
29674: LD_INT 0
29676: PUSH
29677: LD_INT 1
29679: PUSH
29680: EMPTY
29681: LIST
29682: LIST
29683: PUSH
29684: LD_INT 1
29686: NEG
29687: PUSH
29688: LD_INT 0
29690: PUSH
29691: EMPTY
29692: LIST
29693: LIST
29694: PUSH
29695: LD_INT 1
29697: NEG
29698: PUSH
29699: LD_INT 1
29701: NEG
29702: PUSH
29703: EMPTY
29704: LIST
29705: LIST
29706: PUSH
29707: LD_INT 1
29709: NEG
29710: PUSH
29711: LD_INT 2
29713: NEG
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: PUSH
29719: LD_INT 2
29721: PUSH
29722: LD_INT 1
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PUSH
29729: LD_INT 2
29731: PUSH
29732: LD_INT 2
29734: PUSH
29735: EMPTY
29736: LIST
29737: LIST
29738: PUSH
29739: LD_INT 1
29741: PUSH
29742: LD_INT 2
29744: PUSH
29745: EMPTY
29746: LIST
29747: LIST
29748: PUSH
29749: LD_INT 2
29751: NEG
29752: PUSH
29753: LD_INT 1
29755: NEG
29756: PUSH
29757: EMPTY
29758: LIST
29759: LIST
29760: PUSH
29761: LD_INT 2
29763: NEG
29764: PUSH
29765: LD_INT 2
29767: NEG
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: PUSH
29773: LD_INT 2
29775: NEG
29776: PUSH
29777: LD_INT 3
29779: NEG
29780: PUSH
29781: EMPTY
29782: LIST
29783: LIST
29784: PUSH
29785: LD_INT 3
29787: NEG
29788: PUSH
29789: LD_INT 2
29791: NEG
29792: PUSH
29793: EMPTY
29794: LIST
29795: LIST
29796: PUSH
29797: LD_INT 3
29799: NEG
29800: PUSH
29801: LD_INT 3
29803: NEG
29804: PUSH
29805: EMPTY
29806: LIST
29807: LIST
29808: PUSH
29809: EMPTY
29810: LIST
29811: LIST
29812: LIST
29813: LIST
29814: LIST
29815: LIST
29816: LIST
29817: LIST
29818: LIST
29819: LIST
29820: LIST
29821: LIST
29822: LIST
29823: LIST
29824: LIST
29825: LIST
29826: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29827: LD_ADDR_VAR 0 14
29831: PUSH
29832: LD_INT 0
29834: PUSH
29835: LD_INT 0
29837: PUSH
29838: EMPTY
29839: LIST
29840: LIST
29841: PUSH
29842: LD_INT 0
29844: PUSH
29845: LD_INT 1
29847: NEG
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: LD_INT 1
29855: PUSH
29856: LD_INT 0
29858: PUSH
29859: EMPTY
29860: LIST
29861: LIST
29862: PUSH
29863: LD_INT 1
29865: PUSH
29866: LD_INT 1
29868: PUSH
29869: EMPTY
29870: LIST
29871: LIST
29872: PUSH
29873: LD_INT 0
29875: PUSH
29876: LD_INT 1
29878: PUSH
29879: EMPTY
29880: LIST
29881: LIST
29882: PUSH
29883: LD_INT 1
29885: NEG
29886: PUSH
29887: LD_INT 0
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 1
29896: NEG
29897: PUSH
29898: LD_INT 1
29900: NEG
29901: PUSH
29902: EMPTY
29903: LIST
29904: LIST
29905: PUSH
29906: LD_INT 1
29908: NEG
29909: PUSH
29910: LD_INT 2
29912: NEG
29913: PUSH
29914: EMPTY
29915: LIST
29916: LIST
29917: PUSH
29918: LD_INT 0
29920: PUSH
29921: LD_INT 2
29923: NEG
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 1
29931: PUSH
29932: LD_INT 1
29934: NEG
29935: PUSH
29936: EMPTY
29937: LIST
29938: LIST
29939: PUSH
29940: LD_INT 1
29942: PUSH
29943: LD_INT 2
29945: PUSH
29946: EMPTY
29947: LIST
29948: LIST
29949: PUSH
29950: LD_INT 0
29952: PUSH
29953: LD_INT 2
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: PUSH
29960: LD_INT 1
29962: NEG
29963: PUSH
29964: LD_INT 1
29966: PUSH
29967: EMPTY
29968: LIST
29969: LIST
29970: PUSH
29971: LD_INT 1
29973: NEG
29974: PUSH
29975: LD_INT 3
29977: NEG
29978: PUSH
29979: EMPTY
29980: LIST
29981: LIST
29982: PUSH
29983: LD_INT 0
29985: PUSH
29986: LD_INT 3
29988: NEG
29989: PUSH
29990: EMPTY
29991: LIST
29992: LIST
29993: PUSH
29994: LD_INT 1
29996: PUSH
29997: LD_INT 2
29999: NEG
30000: PUSH
30001: EMPTY
30002: LIST
30003: LIST
30004: PUSH
30005: EMPTY
30006: LIST
30007: LIST
30008: LIST
30009: LIST
30010: LIST
30011: LIST
30012: LIST
30013: LIST
30014: LIST
30015: LIST
30016: LIST
30017: LIST
30018: LIST
30019: LIST
30020: LIST
30021: LIST
30022: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30023: LD_ADDR_VAR 0 15
30027: PUSH
30028: LD_INT 0
30030: PUSH
30031: LD_INT 0
30033: PUSH
30034: EMPTY
30035: LIST
30036: LIST
30037: PUSH
30038: LD_INT 0
30040: PUSH
30041: LD_INT 1
30043: NEG
30044: PUSH
30045: EMPTY
30046: LIST
30047: LIST
30048: PUSH
30049: LD_INT 1
30051: PUSH
30052: LD_INT 0
30054: PUSH
30055: EMPTY
30056: LIST
30057: LIST
30058: PUSH
30059: LD_INT 1
30061: PUSH
30062: LD_INT 1
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: PUSH
30069: LD_INT 0
30071: PUSH
30072: LD_INT 1
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: PUSH
30079: LD_INT 1
30081: NEG
30082: PUSH
30083: LD_INT 0
30085: PUSH
30086: EMPTY
30087: LIST
30088: LIST
30089: PUSH
30090: LD_INT 1
30092: NEG
30093: PUSH
30094: LD_INT 1
30096: NEG
30097: PUSH
30098: EMPTY
30099: LIST
30100: LIST
30101: PUSH
30102: LD_INT 1
30104: PUSH
30105: LD_INT 1
30107: NEG
30108: PUSH
30109: EMPTY
30110: LIST
30111: LIST
30112: PUSH
30113: LD_INT 2
30115: PUSH
30116: LD_INT 0
30118: PUSH
30119: EMPTY
30120: LIST
30121: LIST
30122: PUSH
30123: LD_INT 2
30125: PUSH
30126: LD_INT 1
30128: PUSH
30129: EMPTY
30130: LIST
30131: LIST
30132: PUSH
30133: LD_INT 1
30135: NEG
30136: PUSH
30137: LD_INT 1
30139: PUSH
30140: EMPTY
30141: LIST
30142: LIST
30143: PUSH
30144: LD_INT 2
30146: NEG
30147: PUSH
30148: LD_INT 0
30150: PUSH
30151: EMPTY
30152: LIST
30153: LIST
30154: PUSH
30155: LD_INT 2
30157: NEG
30158: PUSH
30159: LD_INT 1
30161: NEG
30162: PUSH
30163: EMPTY
30164: LIST
30165: LIST
30166: PUSH
30167: LD_INT 2
30169: PUSH
30170: LD_INT 1
30172: NEG
30173: PUSH
30174: EMPTY
30175: LIST
30176: LIST
30177: PUSH
30178: LD_INT 3
30180: PUSH
30181: LD_INT 0
30183: PUSH
30184: EMPTY
30185: LIST
30186: LIST
30187: PUSH
30188: LD_INT 3
30190: PUSH
30191: LD_INT 1
30193: PUSH
30194: EMPTY
30195: LIST
30196: LIST
30197: PUSH
30198: EMPTY
30199: LIST
30200: LIST
30201: LIST
30202: LIST
30203: LIST
30204: LIST
30205: LIST
30206: LIST
30207: LIST
30208: LIST
30209: LIST
30210: LIST
30211: LIST
30212: LIST
30213: LIST
30214: LIST
30215: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30216: LD_ADDR_VAR 0 16
30220: PUSH
30221: LD_INT 0
30223: PUSH
30224: LD_INT 0
30226: PUSH
30227: EMPTY
30228: LIST
30229: LIST
30230: PUSH
30231: LD_INT 0
30233: PUSH
30234: LD_INT 1
30236: NEG
30237: PUSH
30238: EMPTY
30239: LIST
30240: LIST
30241: PUSH
30242: LD_INT 1
30244: PUSH
30245: LD_INT 0
30247: PUSH
30248: EMPTY
30249: LIST
30250: LIST
30251: PUSH
30252: LD_INT 1
30254: PUSH
30255: LD_INT 1
30257: PUSH
30258: EMPTY
30259: LIST
30260: LIST
30261: PUSH
30262: LD_INT 0
30264: PUSH
30265: LD_INT 1
30267: PUSH
30268: EMPTY
30269: LIST
30270: LIST
30271: PUSH
30272: LD_INT 1
30274: NEG
30275: PUSH
30276: LD_INT 0
30278: PUSH
30279: EMPTY
30280: LIST
30281: LIST
30282: PUSH
30283: LD_INT 1
30285: NEG
30286: PUSH
30287: LD_INT 1
30289: NEG
30290: PUSH
30291: EMPTY
30292: LIST
30293: LIST
30294: PUSH
30295: LD_INT 1
30297: NEG
30298: PUSH
30299: LD_INT 2
30301: NEG
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: PUSH
30307: LD_INT 2
30309: PUSH
30310: LD_INT 1
30312: PUSH
30313: EMPTY
30314: LIST
30315: LIST
30316: PUSH
30317: LD_INT 2
30319: PUSH
30320: LD_INT 2
30322: PUSH
30323: EMPTY
30324: LIST
30325: LIST
30326: PUSH
30327: LD_INT 1
30329: PUSH
30330: LD_INT 2
30332: PUSH
30333: EMPTY
30334: LIST
30335: LIST
30336: PUSH
30337: LD_INT 2
30339: NEG
30340: PUSH
30341: LD_INT 1
30343: NEG
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: PUSH
30349: LD_INT 2
30351: NEG
30352: PUSH
30353: LD_INT 2
30355: NEG
30356: PUSH
30357: EMPTY
30358: LIST
30359: LIST
30360: PUSH
30361: LD_INT 3
30363: PUSH
30364: LD_INT 2
30366: PUSH
30367: EMPTY
30368: LIST
30369: LIST
30370: PUSH
30371: LD_INT 3
30373: PUSH
30374: LD_INT 3
30376: PUSH
30377: EMPTY
30378: LIST
30379: LIST
30380: PUSH
30381: LD_INT 2
30383: PUSH
30384: LD_INT 3
30386: PUSH
30387: EMPTY
30388: LIST
30389: LIST
30390: PUSH
30391: EMPTY
30392: LIST
30393: LIST
30394: LIST
30395: LIST
30396: LIST
30397: LIST
30398: LIST
30399: LIST
30400: LIST
30401: LIST
30402: LIST
30403: LIST
30404: LIST
30405: LIST
30406: LIST
30407: LIST
30408: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30409: LD_ADDR_VAR 0 17
30413: PUSH
30414: LD_INT 0
30416: PUSH
30417: LD_INT 0
30419: PUSH
30420: EMPTY
30421: LIST
30422: LIST
30423: PUSH
30424: LD_INT 0
30426: PUSH
30427: LD_INT 1
30429: NEG
30430: PUSH
30431: EMPTY
30432: LIST
30433: LIST
30434: PUSH
30435: LD_INT 1
30437: PUSH
30438: LD_INT 0
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PUSH
30445: LD_INT 1
30447: PUSH
30448: LD_INT 1
30450: PUSH
30451: EMPTY
30452: LIST
30453: LIST
30454: PUSH
30455: LD_INT 0
30457: PUSH
30458: LD_INT 1
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: PUSH
30465: LD_INT 1
30467: NEG
30468: PUSH
30469: LD_INT 0
30471: PUSH
30472: EMPTY
30473: LIST
30474: LIST
30475: PUSH
30476: LD_INT 1
30478: NEG
30479: PUSH
30480: LD_INT 1
30482: NEG
30483: PUSH
30484: EMPTY
30485: LIST
30486: LIST
30487: PUSH
30488: LD_INT 1
30490: NEG
30491: PUSH
30492: LD_INT 2
30494: NEG
30495: PUSH
30496: EMPTY
30497: LIST
30498: LIST
30499: PUSH
30500: LD_INT 0
30502: PUSH
30503: LD_INT 2
30505: NEG
30506: PUSH
30507: EMPTY
30508: LIST
30509: LIST
30510: PUSH
30511: LD_INT 1
30513: PUSH
30514: LD_INT 1
30516: NEG
30517: PUSH
30518: EMPTY
30519: LIST
30520: LIST
30521: PUSH
30522: LD_INT 2
30524: PUSH
30525: LD_INT 0
30527: PUSH
30528: EMPTY
30529: LIST
30530: LIST
30531: PUSH
30532: LD_INT 2
30534: PUSH
30535: LD_INT 1
30537: PUSH
30538: EMPTY
30539: LIST
30540: LIST
30541: PUSH
30542: LD_INT 2
30544: PUSH
30545: LD_INT 2
30547: PUSH
30548: EMPTY
30549: LIST
30550: LIST
30551: PUSH
30552: LD_INT 1
30554: PUSH
30555: LD_INT 2
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: PUSH
30562: LD_INT 0
30564: PUSH
30565: LD_INT 2
30567: PUSH
30568: EMPTY
30569: LIST
30570: LIST
30571: PUSH
30572: LD_INT 1
30574: NEG
30575: PUSH
30576: LD_INT 1
30578: PUSH
30579: EMPTY
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 2
30585: NEG
30586: PUSH
30587: LD_INT 0
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 2
30596: NEG
30597: PUSH
30598: LD_INT 1
30600: NEG
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: LD_INT 2
30608: NEG
30609: PUSH
30610: LD_INT 2
30612: NEG
30613: PUSH
30614: EMPTY
30615: LIST
30616: LIST
30617: PUSH
30618: EMPTY
30619: LIST
30620: LIST
30621: LIST
30622: LIST
30623: LIST
30624: LIST
30625: LIST
30626: LIST
30627: LIST
30628: LIST
30629: LIST
30630: LIST
30631: LIST
30632: LIST
30633: LIST
30634: LIST
30635: LIST
30636: LIST
30637: LIST
30638: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30639: LD_ADDR_VAR 0 18
30643: PUSH
30644: LD_INT 0
30646: PUSH
30647: LD_INT 0
30649: PUSH
30650: EMPTY
30651: LIST
30652: LIST
30653: PUSH
30654: LD_INT 0
30656: PUSH
30657: LD_INT 1
30659: NEG
30660: PUSH
30661: EMPTY
30662: LIST
30663: LIST
30664: PUSH
30665: LD_INT 1
30667: PUSH
30668: LD_INT 0
30670: PUSH
30671: EMPTY
30672: LIST
30673: LIST
30674: PUSH
30675: LD_INT 1
30677: PUSH
30678: LD_INT 1
30680: PUSH
30681: EMPTY
30682: LIST
30683: LIST
30684: PUSH
30685: LD_INT 0
30687: PUSH
30688: LD_INT 1
30690: PUSH
30691: EMPTY
30692: LIST
30693: LIST
30694: PUSH
30695: LD_INT 1
30697: NEG
30698: PUSH
30699: LD_INT 0
30701: PUSH
30702: EMPTY
30703: LIST
30704: LIST
30705: PUSH
30706: LD_INT 1
30708: NEG
30709: PUSH
30710: LD_INT 1
30712: NEG
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: LD_INT 1
30720: NEG
30721: PUSH
30722: LD_INT 2
30724: NEG
30725: PUSH
30726: EMPTY
30727: LIST
30728: LIST
30729: PUSH
30730: LD_INT 0
30732: PUSH
30733: LD_INT 2
30735: NEG
30736: PUSH
30737: EMPTY
30738: LIST
30739: LIST
30740: PUSH
30741: LD_INT 1
30743: PUSH
30744: LD_INT 1
30746: NEG
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PUSH
30752: LD_INT 2
30754: PUSH
30755: LD_INT 0
30757: PUSH
30758: EMPTY
30759: LIST
30760: LIST
30761: PUSH
30762: LD_INT 2
30764: PUSH
30765: LD_INT 1
30767: PUSH
30768: EMPTY
30769: LIST
30770: LIST
30771: PUSH
30772: LD_INT 2
30774: PUSH
30775: LD_INT 2
30777: PUSH
30778: EMPTY
30779: LIST
30780: LIST
30781: PUSH
30782: LD_INT 1
30784: PUSH
30785: LD_INT 2
30787: PUSH
30788: EMPTY
30789: LIST
30790: LIST
30791: PUSH
30792: LD_INT 0
30794: PUSH
30795: LD_INT 2
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: LD_INT 1
30804: NEG
30805: PUSH
30806: LD_INT 1
30808: PUSH
30809: EMPTY
30810: LIST
30811: LIST
30812: PUSH
30813: LD_INT 2
30815: NEG
30816: PUSH
30817: LD_INT 0
30819: PUSH
30820: EMPTY
30821: LIST
30822: LIST
30823: PUSH
30824: LD_INT 2
30826: NEG
30827: PUSH
30828: LD_INT 1
30830: NEG
30831: PUSH
30832: EMPTY
30833: LIST
30834: LIST
30835: PUSH
30836: LD_INT 2
30838: NEG
30839: PUSH
30840: LD_INT 2
30842: NEG
30843: PUSH
30844: EMPTY
30845: LIST
30846: LIST
30847: PUSH
30848: EMPTY
30849: LIST
30850: LIST
30851: LIST
30852: LIST
30853: LIST
30854: LIST
30855: LIST
30856: LIST
30857: LIST
30858: LIST
30859: LIST
30860: LIST
30861: LIST
30862: LIST
30863: LIST
30864: LIST
30865: LIST
30866: LIST
30867: LIST
30868: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30869: LD_ADDR_VAR 0 19
30873: PUSH
30874: LD_INT 0
30876: PUSH
30877: LD_INT 0
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: PUSH
30884: LD_INT 0
30886: PUSH
30887: LD_INT 1
30889: NEG
30890: PUSH
30891: EMPTY
30892: LIST
30893: LIST
30894: PUSH
30895: LD_INT 1
30897: PUSH
30898: LD_INT 0
30900: PUSH
30901: EMPTY
30902: LIST
30903: LIST
30904: PUSH
30905: LD_INT 1
30907: PUSH
30908: LD_INT 1
30910: PUSH
30911: EMPTY
30912: LIST
30913: LIST
30914: PUSH
30915: LD_INT 0
30917: PUSH
30918: LD_INT 1
30920: PUSH
30921: EMPTY
30922: LIST
30923: LIST
30924: PUSH
30925: LD_INT 1
30927: NEG
30928: PUSH
30929: LD_INT 0
30931: PUSH
30932: EMPTY
30933: LIST
30934: LIST
30935: PUSH
30936: LD_INT 1
30938: NEG
30939: PUSH
30940: LD_INT 1
30942: NEG
30943: PUSH
30944: EMPTY
30945: LIST
30946: LIST
30947: PUSH
30948: LD_INT 1
30950: NEG
30951: PUSH
30952: LD_INT 2
30954: NEG
30955: PUSH
30956: EMPTY
30957: LIST
30958: LIST
30959: PUSH
30960: LD_INT 0
30962: PUSH
30963: LD_INT 2
30965: NEG
30966: PUSH
30967: EMPTY
30968: LIST
30969: LIST
30970: PUSH
30971: LD_INT 1
30973: PUSH
30974: LD_INT 1
30976: NEG
30977: PUSH
30978: EMPTY
30979: LIST
30980: LIST
30981: PUSH
30982: LD_INT 2
30984: PUSH
30985: LD_INT 0
30987: PUSH
30988: EMPTY
30989: LIST
30990: LIST
30991: PUSH
30992: LD_INT 2
30994: PUSH
30995: LD_INT 1
30997: PUSH
30998: EMPTY
30999: LIST
31000: LIST
31001: PUSH
31002: LD_INT 2
31004: PUSH
31005: LD_INT 2
31007: PUSH
31008: EMPTY
31009: LIST
31010: LIST
31011: PUSH
31012: LD_INT 1
31014: PUSH
31015: LD_INT 2
31017: PUSH
31018: EMPTY
31019: LIST
31020: LIST
31021: PUSH
31022: LD_INT 0
31024: PUSH
31025: LD_INT 2
31027: PUSH
31028: EMPTY
31029: LIST
31030: LIST
31031: PUSH
31032: LD_INT 1
31034: NEG
31035: PUSH
31036: LD_INT 1
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: PUSH
31043: LD_INT 2
31045: NEG
31046: PUSH
31047: LD_INT 0
31049: PUSH
31050: EMPTY
31051: LIST
31052: LIST
31053: PUSH
31054: LD_INT 2
31056: NEG
31057: PUSH
31058: LD_INT 1
31060: NEG
31061: PUSH
31062: EMPTY
31063: LIST
31064: LIST
31065: PUSH
31066: LD_INT 2
31068: NEG
31069: PUSH
31070: LD_INT 2
31072: NEG
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: EMPTY
31079: LIST
31080: LIST
31081: LIST
31082: LIST
31083: LIST
31084: LIST
31085: LIST
31086: LIST
31087: LIST
31088: LIST
31089: LIST
31090: LIST
31091: LIST
31092: LIST
31093: LIST
31094: LIST
31095: LIST
31096: LIST
31097: LIST
31098: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31099: LD_ADDR_VAR 0 20
31103: PUSH
31104: LD_INT 0
31106: PUSH
31107: LD_INT 0
31109: PUSH
31110: EMPTY
31111: LIST
31112: LIST
31113: PUSH
31114: LD_INT 0
31116: PUSH
31117: LD_INT 1
31119: NEG
31120: PUSH
31121: EMPTY
31122: LIST
31123: LIST
31124: PUSH
31125: LD_INT 1
31127: PUSH
31128: LD_INT 0
31130: PUSH
31131: EMPTY
31132: LIST
31133: LIST
31134: PUSH
31135: LD_INT 1
31137: PUSH
31138: LD_INT 1
31140: PUSH
31141: EMPTY
31142: LIST
31143: LIST
31144: PUSH
31145: LD_INT 0
31147: PUSH
31148: LD_INT 1
31150: PUSH
31151: EMPTY
31152: LIST
31153: LIST
31154: PUSH
31155: LD_INT 1
31157: NEG
31158: PUSH
31159: LD_INT 0
31161: PUSH
31162: EMPTY
31163: LIST
31164: LIST
31165: PUSH
31166: LD_INT 1
31168: NEG
31169: PUSH
31170: LD_INT 1
31172: NEG
31173: PUSH
31174: EMPTY
31175: LIST
31176: LIST
31177: PUSH
31178: LD_INT 1
31180: NEG
31181: PUSH
31182: LD_INT 2
31184: NEG
31185: PUSH
31186: EMPTY
31187: LIST
31188: LIST
31189: PUSH
31190: LD_INT 0
31192: PUSH
31193: LD_INT 2
31195: NEG
31196: PUSH
31197: EMPTY
31198: LIST
31199: LIST
31200: PUSH
31201: LD_INT 1
31203: PUSH
31204: LD_INT 1
31206: NEG
31207: PUSH
31208: EMPTY
31209: LIST
31210: LIST
31211: PUSH
31212: LD_INT 2
31214: PUSH
31215: LD_INT 0
31217: PUSH
31218: EMPTY
31219: LIST
31220: LIST
31221: PUSH
31222: LD_INT 2
31224: PUSH
31225: LD_INT 1
31227: PUSH
31228: EMPTY
31229: LIST
31230: LIST
31231: PUSH
31232: LD_INT 2
31234: PUSH
31235: LD_INT 2
31237: PUSH
31238: EMPTY
31239: LIST
31240: LIST
31241: PUSH
31242: LD_INT 1
31244: PUSH
31245: LD_INT 2
31247: PUSH
31248: EMPTY
31249: LIST
31250: LIST
31251: PUSH
31252: LD_INT 0
31254: PUSH
31255: LD_INT 2
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: PUSH
31262: LD_INT 1
31264: NEG
31265: PUSH
31266: LD_INT 1
31268: PUSH
31269: EMPTY
31270: LIST
31271: LIST
31272: PUSH
31273: LD_INT 2
31275: NEG
31276: PUSH
31277: LD_INT 0
31279: PUSH
31280: EMPTY
31281: LIST
31282: LIST
31283: PUSH
31284: LD_INT 2
31286: NEG
31287: PUSH
31288: LD_INT 1
31290: NEG
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: PUSH
31296: LD_INT 2
31298: NEG
31299: PUSH
31300: LD_INT 2
31302: NEG
31303: PUSH
31304: EMPTY
31305: LIST
31306: LIST
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: LIST
31312: LIST
31313: LIST
31314: LIST
31315: LIST
31316: LIST
31317: LIST
31318: LIST
31319: LIST
31320: LIST
31321: LIST
31322: LIST
31323: LIST
31324: LIST
31325: LIST
31326: LIST
31327: LIST
31328: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31329: LD_ADDR_VAR 0 21
31333: PUSH
31334: LD_INT 0
31336: PUSH
31337: LD_INT 0
31339: PUSH
31340: EMPTY
31341: LIST
31342: LIST
31343: PUSH
31344: LD_INT 0
31346: PUSH
31347: LD_INT 1
31349: NEG
31350: PUSH
31351: EMPTY
31352: LIST
31353: LIST
31354: PUSH
31355: LD_INT 1
31357: PUSH
31358: LD_INT 0
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: PUSH
31365: LD_INT 1
31367: PUSH
31368: LD_INT 1
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 0
31377: PUSH
31378: LD_INT 1
31380: PUSH
31381: EMPTY
31382: LIST
31383: LIST
31384: PUSH
31385: LD_INT 1
31387: NEG
31388: PUSH
31389: LD_INT 0
31391: PUSH
31392: EMPTY
31393: LIST
31394: LIST
31395: PUSH
31396: LD_INT 1
31398: NEG
31399: PUSH
31400: LD_INT 1
31402: NEG
31403: PUSH
31404: EMPTY
31405: LIST
31406: LIST
31407: PUSH
31408: LD_INT 1
31410: NEG
31411: PUSH
31412: LD_INT 2
31414: NEG
31415: PUSH
31416: EMPTY
31417: LIST
31418: LIST
31419: PUSH
31420: LD_INT 0
31422: PUSH
31423: LD_INT 2
31425: NEG
31426: PUSH
31427: EMPTY
31428: LIST
31429: LIST
31430: PUSH
31431: LD_INT 1
31433: PUSH
31434: LD_INT 1
31436: NEG
31437: PUSH
31438: EMPTY
31439: LIST
31440: LIST
31441: PUSH
31442: LD_INT 2
31444: PUSH
31445: LD_INT 0
31447: PUSH
31448: EMPTY
31449: LIST
31450: LIST
31451: PUSH
31452: LD_INT 2
31454: PUSH
31455: LD_INT 1
31457: PUSH
31458: EMPTY
31459: LIST
31460: LIST
31461: PUSH
31462: LD_INT 2
31464: PUSH
31465: LD_INT 2
31467: PUSH
31468: EMPTY
31469: LIST
31470: LIST
31471: PUSH
31472: LD_INT 1
31474: PUSH
31475: LD_INT 2
31477: PUSH
31478: EMPTY
31479: LIST
31480: LIST
31481: PUSH
31482: LD_INT 0
31484: PUSH
31485: LD_INT 2
31487: PUSH
31488: EMPTY
31489: LIST
31490: LIST
31491: PUSH
31492: LD_INT 1
31494: NEG
31495: PUSH
31496: LD_INT 1
31498: PUSH
31499: EMPTY
31500: LIST
31501: LIST
31502: PUSH
31503: LD_INT 2
31505: NEG
31506: PUSH
31507: LD_INT 0
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 2
31516: NEG
31517: PUSH
31518: LD_INT 1
31520: NEG
31521: PUSH
31522: EMPTY
31523: LIST
31524: LIST
31525: PUSH
31526: LD_INT 2
31528: NEG
31529: PUSH
31530: LD_INT 2
31532: NEG
31533: PUSH
31534: EMPTY
31535: LIST
31536: LIST
31537: PUSH
31538: EMPTY
31539: LIST
31540: LIST
31541: LIST
31542: LIST
31543: LIST
31544: LIST
31545: LIST
31546: LIST
31547: LIST
31548: LIST
31549: LIST
31550: LIST
31551: LIST
31552: LIST
31553: LIST
31554: LIST
31555: LIST
31556: LIST
31557: LIST
31558: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31559: LD_ADDR_VAR 0 22
31563: PUSH
31564: LD_INT 0
31566: PUSH
31567: LD_INT 0
31569: PUSH
31570: EMPTY
31571: LIST
31572: LIST
31573: PUSH
31574: LD_INT 0
31576: PUSH
31577: LD_INT 1
31579: NEG
31580: PUSH
31581: EMPTY
31582: LIST
31583: LIST
31584: PUSH
31585: LD_INT 1
31587: PUSH
31588: LD_INT 0
31590: PUSH
31591: EMPTY
31592: LIST
31593: LIST
31594: PUSH
31595: LD_INT 1
31597: PUSH
31598: LD_INT 1
31600: PUSH
31601: EMPTY
31602: LIST
31603: LIST
31604: PUSH
31605: LD_INT 0
31607: PUSH
31608: LD_INT 1
31610: PUSH
31611: EMPTY
31612: LIST
31613: LIST
31614: PUSH
31615: LD_INT 1
31617: NEG
31618: PUSH
31619: LD_INT 0
31621: PUSH
31622: EMPTY
31623: LIST
31624: LIST
31625: PUSH
31626: LD_INT 1
31628: NEG
31629: PUSH
31630: LD_INT 1
31632: NEG
31633: PUSH
31634: EMPTY
31635: LIST
31636: LIST
31637: PUSH
31638: LD_INT 1
31640: NEG
31641: PUSH
31642: LD_INT 2
31644: NEG
31645: PUSH
31646: EMPTY
31647: LIST
31648: LIST
31649: PUSH
31650: LD_INT 0
31652: PUSH
31653: LD_INT 2
31655: NEG
31656: PUSH
31657: EMPTY
31658: LIST
31659: LIST
31660: PUSH
31661: LD_INT 1
31663: PUSH
31664: LD_INT 1
31666: NEG
31667: PUSH
31668: EMPTY
31669: LIST
31670: LIST
31671: PUSH
31672: LD_INT 2
31674: PUSH
31675: LD_INT 0
31677: PUSH
31678: EMPTY
31679: LIST
31680: LIST
31681: PUSH
31682: LD_INT 2
31684: PUSH
31685: LD_INT 1
31687: PUSH
31688: EMPTY
31689: LIST
31690: LIST
31691: PUSH
31692: LD_INT 2
31694: PUSH
31695: LD_INT 2
31697: PUSH
31698: EMPTY
31699: LIST
31700: LIST
31701: PUSH
31702: LD_INT 1
31704: PUSH
31705: LD_INT 2
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: PUSH
31712: LD_INT 0
31714: PUSH
31715: LD_INT 2
31717: PUSH
31718: EMPTY
31719: LIST
31720: LIST
31721: PUSH
31722: LD_INT 1
31724: NEG
31725: PUSH
31726: LD_INT 1
31728: PUSH
31729: EMPTY
31730: LIST
31731: LIST
31732: PUSH
31733: LD_INT 2
31735: NEG
31736: PUSH
31737: LD_INT 0
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: PUSH
31744: LD_INT 2
31746: NEG
31747: PUSH
31748: LD_INT 1
31750: NEG
31751: PUSH
31752: EMPTY
31753: LIST
31754: LIST
31755: PUSH
31756: LD_INT 2
31758: NEG
31759: PUSH
31760: LD_INT 2
31762: NEG
31763: PUSH
31764: EMPTY
31765: LIST
31766: LIST
31767: PUSH
31768: EMPTY
31769: LIST
31770: LIST
31771: LIST
31772: LIST
31773: LIST
31774: LIST
31775: LIST
31776: LIST
31777: LIST
31778: LIST
31779: LIST
31780: LIST
31781: LIST
31782: LIST
31783: LIST
31784: LIST
31785: LIST
31786: LIST
31787: LIST
31788: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31789: LD_ADDR_VAR 0 23
31793: PUSH
31794: LD_INT 0
31796: PUSH
31797: LD_INT 0
31799: PUSH
31800: EMPTY
31801: LIST
31802: LIST
31803: PUSH
31804: LD_INT 0
31806: PUSH
31807: LD_INT 1
31809: NEG
31810: PUSH
31811: EMPTY
31812: LIST
31813: LIST
31814: PUSH
31815: LD_INT 1
31817: PUSH
31818: LD_INT 0
31820: PUSH
31821: EMPTY
31822: LIST
31823: LIST
31824: PUSH
31825: LD_INT 1
31827: PUSH
31828: LD_INT 1
31830: PUSH
31831: EMPTY
31832: LIST
31833: LIST
31834: PUSH
31835: LD_INT 0
31837: PUSH
31838: LD_INT 1
31840: PUSH
31841: EMPTY
31842: LIST
31843: LIST
31844: PUSH
31845: LD_INT 1
31847: NEG
31848: PUSH
31849: LD_INT 0
31851: PUSH
31852: EMPTY
31853: LIST
31854: LIST
31855: PUSH
31856: LD_INT 1
31858: NEG
31859: PUSH
31860: LD_INT 1
31862: NEG
31863: PUSH
31864: EMPTY
31865: LIST
31866: LIST
31867: PUSH
31868: LD_INT 1
31870: NEG
31871: PUSH
31872: LD_INT 2
31874: NEG
31875: PUSH
31876: EMPTY
31877: LIST
31878: LIST
31879: PUSH
31880: LD_INT 0
31882: PUSH
31883: LD_INT 2
31885: NEG
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 1
31893: PUSH
31894: LD_INT 1
31896: NEG
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: PUSH
31902: LD_INT 2
31904: PUSH
31905: LD_INT 0
31907: PUSH
31908: EMPTY
31909: LIST
31910: LIST
31911: PUSH
31912: LD_INT 2
31914: PUSH
31915: LD_INT 1
31917: PUSH
31918: EMPTY
31919: LIST
31920: LIST
31921: PUSH
31922: LD_INT 2
31924: PUSH
31925: LD_INT 2
31927: PUSH
31928: EMPTY
31929: LIST
31930: LIST
31931: PUSH
31932: LD_INT 1
31934: PUSH
31935: LD_INT 2
31937: PUSH
31938: EMPTY
31939: LIST
31940: LIST
31941: PUSH
31942: LD_INT 0
31944: PUSH
31945: LD_INT 2
31947: PUSH
31948: EMPTY
31949: LIST
31950: LIST
31951: PUSH
31952: LD_INT 1
31954: NEG
31955: PUSH
31956: LD_INT 1
31958: PUSH
31959: EMPTY
31960: LIST
31961: LIST
31962: PUSH
31963: LD_INT 2
31965: NEG
31966: PUSH
31967: LD_INT 0
31969: PUSH
31970: EMPTY
31971: LIST
31972: LIST
31973: PUSH
31974: LD_INT 2
31976: NEG
31977: PUSH
31978: LD_INT 1
31980: NEG
31981: PUSH
31982: EMPTY
31983: LIST
31984: LIST
31985: PUSH
31986: LD_INT 2
31988: NEG
31989: PUSH
31990: LD_INT 2
31992: NEG
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: PUSH
31998: LD_INT 2
32000: NEG
32001: PUSH
32002: LD_INT 3
32004: NEG
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PUSH
32010: LD_INT 1
32012: NEG
32013: PUSH
32014: LD_INT 3
32016: NEG
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PUSH
32022: LD_INT 1
32024: PUSH
32025: LD_INT 2
32027: NEG
32028: PUSH
32029: EMPTY
32030: LIST
32031: LIST
32032: PUSH
32033: LD_INT 2
32035: PUSH
32036: LD_INT 1
32038: NEG
32039: PUSH
32040: EMPTY
32041: LIST
32042: LIST
32043: PUSH
32044: EMPTY
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: LIST
32056: LIST
32057: LIST
32058: LIST
32059: LIST
32060: LIST
32061: LIST
32062: LIST
32063: LIST
32064: LIST
32065: LIST
32066: LIST
32067: LIST
32068: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32069: LD_ADDR_VAR 0 24
32073: PUSH
32074: LD_INT 0
32076: PUSH
32077: LD_INT 0
32079: PUSH
32080: EMPTY
32081: LIST
32082: LIST
32083: PUSH
32084: LD_INT 0
32086: PUSH
32087: LD_INT 1
32089: NEG
32090: PUSH
32091: EMPTY
32092: LIST
32093: LIST
32094: PUSH
32095: LD_INT 1
32097: PUSH
32098: LD_INT 0
32100: PUSH
32101: EMPTY
32102: LIST
32103: LIST
32104: PUSH
32105: LD_INT 1
32107: PUSH
32108: LD_INT 1
32110: PUSH
32111: EMPTY
32112: LIST
32113: LIST
32114: PUSH
32115: LD_INT 0
32117: PUSH
32118: LD_INT 1
32120: PUSH
32121: EMPTY
32122: LIST
32123: LIST
32124: PUSH
32125: LD_INT 1
32127: NEG
32128: PUSH
32129: LD_INT 0
32131: PUSH
32132: EMPTY
32133: LIST
32134: LIST
32135: PUSH
32136: LD_INT 1
32138: NEG
32139: PUSH
32140: LD_INT 1
32142: NEG
32143: PUSH
32144: EMPTY
32145: LIST
32146: LIST
32147: PUSH
32148: LD_INT 1
32150: NEG
32151: PUSH
32152: LD_INT 2
32154: NEG
32155: PUSH
32156: EMPTY
32157: LIST
32158: LIST
32159: PUSH
32160: LD_INT 0
32162: PUSH
32163: LD_INT 2
32165: NEG
32166: PUSH
32167: EMPTY
32168: LIST
32169: LIST
32170: PUSH
32171: LD_INT 1
32173: PUSH
32174: LD_INT 1
32176: NEG
32177: PUSH
32178: EMPTY
32179: LIST
32180: LIST
32181: PUSH
32182: LD_INT 2
32184: PUSH
32185: LD_INT 0
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: LD_INT 2
32194: PUSH
32195: LD_INT 1
32197: PUSH
32198: EMPTY
32199: LIST
32200: LIST
32201: PUSH
32202: LD_INT 2
32204: PUSH
32205: LD_INT 2
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 1
32214: PUSH
32215: LD_INT 2
32217: PUSH
32218: EMPTY
32219: LIST
32220: LIST
32221: PUSH
32222: LD_INT 0
32224: PUSH
32225: LD_INT 2
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 1
32234: NEG
32235: PUSH
32236: LD_INT 1
32238: PUSH
32239: EMPTY
32240: LIST
32241: LIST
32242: PUSH
32243: LD_INT 2
32245: NEG
32246: PUSH
32247: LD_INT 0
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: PUSH
32254: LD_INT 2
32256: NEG
32257: PUSH
32258: LD_INT 1
32260: NEG
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: LD_INT 2
32268: NEG
32269: PUSH
32270: LD_INT 2
32272: NEG
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: PUSH
32278: LD_INT 1
32280: PUSH
32281: LD_INT 2
32283: NEG
32284: PUSH
32285: EMPTY
32286: LIST
32287: LIST
32288: PUSH
32289: LD_INT 2
32291: PUSH
32292: LD_INT 1
32294: NEG
32295: PUSH
32296: EMPTY
32297: LIST
32298: LIST
32299: PUSH
32300: LD_INT 3
32302: PUSH
32303: LD_INT 1
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: PUSH
32310: LD_INT 3
32312: PUSH
32313: LD_INT 2
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: EMPTY
32321: LIST
32322: LIST
32323: LIST
32324: LIST
32325: LIST
32326: LIST
32327: LIST
32328: LIST
32329: LIST
32330: LIST
32331: LIST
32332: LIST
32333: LIST
32334: LIST
32335: LIST
32336: LIST
32337: LIST
32338: LIST
32339: LIST
32340: LIST
32341: LIST
32342: LIST
32343: LIST
32344: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32345: LD_ADDR_VAR 0 25
32349: PUSH
32350: LD_INT 0
32352: PUSH
32353: LD_INT 0
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: PUSH
32360: LD_INT 0
32362: PUSH
32363: LD_INT 1
32365: NEG
32366: PUSH
32367: EMPTY
32368: LIST
32369: LIST
32370: PUSH
32371: LD_INT 1
32373: PUSH
32374: LD_INT 0
32376: PUSH
32377: EMPTY
32378: LIST
32379: LIST
32380: PUSH
32381: LD_INT 1
32383: PUSH
32384: LD_INT 1
32386: PUSH
32387: EMPTY
32388: LIST
32389: LIST
32390: PUSH
32391: LD_INT 0
32393: PUSH
32394: LD_INT 1
32396: PUSH
32397: EMPTY
32398: LIST
32399: LIST
32400: PUSH
32401: LD_INT 1
32403: NEG
32404: PUSH
32405: LD_INT 0
32407: PUSH
32408: EMPTY
32409: LIST
32410: LIST
32411: PUSH
32412: LD_INT 1
32414: NEG
32415: PUSH
32416: LD_INT 1
32418: NEG
32419: PUSH
32420: EMPTY
32421: LIST
32422: LIST
32423: PUSH
32424: LD_INT 1
32426: NEG
32427: PUSH
32428: LD_INT 2
32430: NEG
32431: PUSH
32432: EMPTY
32433: LIST
32434: LIST
32435: PUSH
32436: LD_INT 0
32438: PUSH
32439: LD_INT 2
32441: NEG
32442: PUSH
32443: EMPTY
32444: LIST
32445: LIST
32446: PUSH
32447: LD_INT 1
32449: PUSH
32450: LD_INT 1
32452: NEG
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PUSH
32458: LD_INT 2
32460: PUSH
32461: LD_INT 0
32463: PUSH
32464: EMPTY
32465: LIST
32466: LIST
32467: PUSH
32468: LD_INT 2
32470: PUSH
32471: LD_INT 1
32473: PUSH
32474: EMPTY
32475: LIST
32476: LIST
32477: PUSH
32478: LD_INT 2
32480: PUSH
32481: LD_INT 2
32483: PUSH
32484: EMPTY
32485: LIST
32486: LIST
32487: PUSH
32488: LD_INT 1
32490: PUSH
32491: LD_INT 2
32493: PUSH
32494: EMPTY
32495: LIST
32496: LIST
32497: PUSH
32498: LD_INT 0
32500: PUSH
32501: LD_INT 2
32503: PUSH
32504: EMPTY
32505: LIST
32506: LIST
32507: PUSH
32508: LD_INT 1
32510: NEG
32511: PUSH
32512: LD_INT 1
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 2
32521: NEG
32522: PUSH
32523: LD_INT 0
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 2
32532: NEG
32533: PUSH
32534: LD_INT 1
32536: NEG
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 2
32544: NEG
32545: PUSH
32546: LD_INT 2
32548: NEG
32549: PUSH
32550: EMPTY
32551: LIST
32552: LIST
32553: PUSH
32554: LD_INT 3
32556: PUSH
32557: LD_INT 1
32559: PUSH
32560: EMPTY
32561: LIST
32562: LIST
32563: PUSH
32564: LD_INT 3
32566: PUSH
32567: LD_INT 2
32569: PUSH
32570: EMPTY
32571: LIST
32572: LIST
32573: PUSH
32574: LD_INT 2
32576: PUSH
32577: LD_INT 3
32579: PUSH
32580: EMPTY
32581: LIST
32582: LIST
32583: PUSH
32584: LD_INT 1
32586: PUSH
32587: LD_INT 3
32589: PUSH
32590: EMPTY
32591: LIST
32592: LIST
32593: PUSH
32594: EMPTY
32595: LIST
32596: LIST
32597: LIST
32598: LIST
32599: LIST
32600: LIST
32601: LIST
32602: LIST
32603: LIST
32604: LIST
32605: LIST
32606: LIST
32607: LIST
32608: LIST
32609: LIST
32610: LIST
32611: LIST
32612: LIST
32613: LIST
32614: LIST
32615: LIST
32616: LIST
32617: LIST
32618: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32619: LD_ADDR_VAR 0 26
32623: PUSH
32624: LD_INT 0
32626: PUSH
32627: LD_INT 0
32629: PUSH
32630: EMPTY
32631: LIST
32632: LIST
32633: PUSH
32634: LD_INT 0
32636: PUSH
32637: LD_INT 1
32639: NEG
32640: PUSH
32641: EMPTY
32642: LIST
32643: LIST
32644: PUSH
32645: LD_INT 1
32647: PUSH
32648: LD_INT 0
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: PUSH
32655: LD_INT 1
32657: PUSH
32658: LD_INT 1
32660: PUSH
32661: EMPTY
32662: LIST
32663: LIST
32664: PUSH
32665: LD_INT 0
32667: PUSH
32668: LD_INT 1
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: PUSH
32675: LD_INT 1
32677: NEG
32678: PUSH
32679: LD_INT 0
32681: PUSH
32682: EMPTY
32683: LIST
32684: LIST
32685: PUSH
32686: LD_INT 1
32688: NEG
32689: PUSH
32690: LD_INT 1
32692: NEG
32693: PUSH
32694: EMPTY
32695: LIST
32696: LIST
32697: PUSH
32698: LD_INT 1
32700: NEG
32701: PUSH
32702: LD_INT 2
32704: NEG
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PUSH
32710: LD_INT 0
32712: PUSH
32713: LD_INT 2
32715: NEG
32716: PUSH
32717: EMPTY
32718: LIST
32719: LIST
32720: PUSH
32721: LD_INT 1
32723: PUSH
32724: LD_INT 1
32726: NEG
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: PUSH
32732: LD_INT 2
32734: PUSH
32735: LD_INT 0
32737: PUSH
32738: EMPTY
32739: LIST
32740: LIST
32741: PUSH
32742: LD_INT 2
32744: PUSH
32745: LD_INT 1
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: PUSH
32752: LD_INT 2
32754: PUSH
32755: LD_INT 2
32757: PUSH
32758: EMPTY
32759: LIST
32760: LIST
32761: PUSH
32762: LD_INT 1
32764: PUSH
32765: LD_INT 2
32767: PUSH
32768: EMPTY
32769: LIST
32770: LIST
32771: PUSH
32772: LD_INT 0
32774: PUSH
32775: LD_INT 2
32777: PUSH
32778: EMPTY
32779: LIST
32780: LIST
32781: PUSH
32782: LD_INT 1
32784: NEG
32785: PUSH
32786: LD_INT 1
32788: PUSH
32789: EMPTY
32790: LIST
32791: LIST
32792: PUSH
32793: LD_INT 2
32795: NEG
32796: PUSH
32797: LD_INT 0
32799: PUSH
32800: EMPTY
32801: LIST
32802: LIST
32803: PUSH
32804: LD_INT 2
32806: NEG
32807: PUSH
32808: LD_INT 1
32810: NEG
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: PUSH
32816: LD_INT 2
32818: NEG
32819: PUSH
32820: LD_INT 2
32822: NEG
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 2
32830: PUSH
32831: LD_INT 3
32833: PUSH
32834: EMPTY
32835: LIST
32836: LIST
32837: PUSH
32838: LD_INT 1
32840: PUSH
32841: LD_INT 3
32843: PUSH
32844: EMPTY
32845: LIST
32846: LIST
32847: PUSH
32848: LD_INT 1
32850: NEG
32851: PUSH
32852: LD_INT 2
32854: PUSH
32855: EMPTY
32856: LIST
32857: LIST
32858: PUSH
32859: LD_INT 2
32861: NEG
32862: PUSH
32863: LD_INT 1
32865: PUSH
32866: EMPTY
32867: LIST
32868: LIST
32869: PUSH
32870: EMPTY
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: LIST
32876: LIST
32877: LIST
32878: LIST
32879: LIST
32880: LIST
32881: LIST
32882: LIST
32883: LIST
32884: LIST
32885: LIST
32886: LIST
32887: LIST
32888: LIST
32889: LIST
32890: LIST
32891: LIST
32892: LIST
32893: LIST
32894: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32895: LD_ADDR_VAR 0 27
32899: PUSH
32900: LD_INT 0
32902: PUSH
32903: LD_INT 0
32905: PUSH
32906: EMPTY
32907: LIST
32908: LIST
32909: PUSH
32910: LD_INT 0
32912: PUSH
32913: LD_INT 1
32915: NEG
32916: PUSH
32917: EMPTY
32918: LIST
32919: LIST
32920: PUSH
32921: LD_INT 1
32923: PUSH
32924: LD_INT 0
32926: PUSH
32927: EMPTY
32928: LIST
32929: LIST
32930: PUSH
32931: LD_INT 1
32933: PUSH
32934: LD_INT 1
32936: PUSH
32937: EMPTY
32938: LIST
32939: LIST
32940: PUSH
32941: LD_INT 0
32943: PUSH
32944: LD_INT 1
32946: PUSH
32947: EMPTY
32948: LIST
32949: LIST
32950: PUSH
32951: LD_INT 1
32953: NEG
32954: PUSH
32955: LD_INT 0
32957: PUSH
32958: EMPTY
32959: LIST
32960: LIST
32961: PUSH
32962: LD_INT 1
32964: NEG
32965: PUSH
32966: LD_INT 1
32968: NEG
32969: PUSH
32970: EMPTY
32971: LIST
32972: LIST
32973: PUSH
32974: LD_INT 1
32976: NEG
32977: PUSH
32978: LD_INT 2
32980: NEG
32981: PUSH
32982: EMPTY
32983: LIST
32984: LIST
32985: PUSH
32986: LD_INT 0
32988: PUSH
32989: LD_INT 2
32991: NEG
32992: PUSH
32993: EMPTY
32994: LIST
32995: LIST
32996: PUSH
32997: LD_INT 1
32999: PUSH
33000: LD_INT 1
33002: NEG
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: PUSH
33008: LD_INT 2
33010: PUSH
33011: LD_INT 0
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 2
33020: PUSH
33021: LD_INT 1
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: LD_INT 2
33030: PUSH
33031: LD_INT 2
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: PUSH
33038: LD_INT 1
33040: PUSH
33041: LD_INT 2
33043: PUSH
33044: EMPTY
33045: LIST
33046: LIST
33047: PUSH
33048: LD_INT 0
33050: PUSH
33051: LD_INT 2
33053: PUSH
33054: EMPTY
33055: LIST
33056: LIST
33057: PUSH
33058: LD_INT 1
33060: NEG
33061: PUSH
33062: LD_INT 1
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 2
33071: NEG
33072: PUSH
33073: LD_INT 0
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: LD_INT 2
33082: NEG
33083: PUSH
33084: LD_INT 1
33086: NEG
33087: PUSH
33088: EMPTY
33089: LIST
33090: LIST
33091: PUSH
33092: LD_INT 2
33094: NEG
33095: PUSH
33096: LD_INT 2
33098: NEG
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 1
33106: NEG
33107: PUSH
33108: LD_INT 2
33110: PUSH
33111: EMPTY
33112: LIST
33113: LIST
33114: PUSH
33115: LD_INT 2
33117: NEG
33118: PUSH
33119: LD_INT 1
33121: PUSH
33122: EMPTY
33123: LIST
33124: LIST
33125: PUSH
33126: LD_INT 3
33128: NEG
33129: PUSH
33130: LD_INT 1
33132: NEG
33133: PUSH
33134: EMPTY
33135: LIST
33136: LIST
33137: PUSH
33138: LD_INT 3
33140: NEG
33141: PUSH
33142: LD_INT 2
33144: NEG
33145: PUSH
33146: EMPTY
33147: LIST
33148: LIST
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: LIST
33168: LIST
33169: LIST
33170: LIST
33171: LIST
33172: LIST
33173: LIST
33174: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33175: LD_ADDR_VAR 0 28
33179: PUSH
33180: LD_INT 0
33182: PUSH
33183: LD_INT 0
33185: PUSH
33186: EMPTY
33187: LIST
33188: LIST
33189: PUSH
33190: LD_INT 0
33192: PUSH
33193: LD_INT 1
33195: NEG
33196: PUSH
33197: EMPTY
33198: LIST
33199: LIST
33200: PUSH
33201: LD_INT 1
33203: PUSH
33204: LD_INT 0
33206: PUSH
33207: EMPTY
33208: LIST
33209: LIST
33210: PUSH
33211: LD_INT 1
33213: PUSH
33214: LD_INT 1
33216: PUSH
33217: EMPTY
33218: LIST
33219: LIST
33220: PUSH
33221: LD_INT 0
33223: PUSH
33224: LD_INT 1
33226: PUSH
33227: EMPTY
33228: LIST
33229: LIST
33230: PUSH
33231: LD_INT 1
33233: NEG
33234: PUSH
33235: LD_INT 0
33237: PUSH
33238: EMPTY
33239: LIST
33240: LIST
33241: PUSH
33242: LD_INT 1
33244: NEG
33245: PUSH
33246: LD_INT 1
33248: NEG
33249: PUSH
33250: EMPTY
33251: LIST
33252: LIST
33253: PUSH
33254: LD_INT 1
33256: NEG
33257: PUSH
33258: LD_INT 2
33260: NEG
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 0
33268: PUSH
33269: LD_INT 2
33271: NEG
33272: PUSH
33273: EMPTY
33274: LIST
33275: LIST
33276: PUSH
33277: LD_INT 1
33279: PUSH
33280: LD_INT 1
33282: NEG
33283: PUSH
33284: EMPTY
33285: LIST
33286: LIST
33287: PUSH
33288: LD_INT 2
33290: PUSH
33291: LD_INT 0
33293: PUSH
33294: EMPTY
33295: LIST
33296: LIST
33297: PUSH
33298: LD_INT 2
33300: PUSH
33301: LD_INT 1
33303: PUSH
33304: EMPTY
33305: LIST
33306: LIST
33307: PUSH
33308: LD_INT 2
33310: PUSH
33311: LD_INT 2
33313: PUSH
33314: EMPTY
33315: LIST
33316: LIST
33317: PUSH
33318: LD_INT 1
33320: PUSH
33321: LD_INT 2
33323: PUSH
33324: EMPTY
33325: LIST
33326: LIST
33327: PUSH
33328: LD_INT 0
33330: PUSH
33331: LD_INT 2
33333: PUSH
33334: EMPTY
33335: LIST
33336: LIST
33337: PUSH
33338: LD_INT 1
33340: NEG
33341: PUSH
33342: LD_INT 1
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 2
33351: NEG
33352: PUSH
33353: LD_INT 0
33355: PUSH
33356: EMPTY
33357: LIST
33358: LIST
33359: PUSH
33360: LD_INT 2
33362: NEG
33363: PUSH
33364: LD_INT 1
33366: NEG
33367: PUSH
33368: EMPTY
33369: LIST
33370: LIST
33371: PUSH
33372: LD_INT 2
33374: NEG
33375: PUSH
33376: LD_INT 2
33378: NEG
33379: PUSH
33380: EMPTY
33381: LIST
33382: LIST
33383: PUSH
33384: LD_INT 2
33386: NEG
33387: PUSH
33388: LD_INT 3
33390: NEG
33391: PUSH
33392: EMPTY
33393: LIST
33394: LIST
33395: PUSH
33396: LD_INT 1
33398: NEG
33399: PUSH
33400: LD_INT 3
33402: NEG
33403: PUSH
33404: EMPTY
33405: LIST
33406: LIST
33407: PUSH
33408: LD_INT 3
33410: NEG
33411: PUSH
33412: LD_INT 1
33414: NEG
33415: PUSH
33416: EMPTY
33417: LIST
33418: LIST
33419: PUSH
33420: LD_INT 3
33422: NEG
33423: PUSH
33424: LD_INT 2
33426: NEG
33427: PUSH
33428: EMPTY
33429: LIST
33430: LIST
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: LIST
33436: LIST
33437: LIST
33438: LIST
33439: LIST
33440: LIST
33441: LIST
33442: LIST
33443: LIST
33444: LIST
33445: LIST
33446: LIST
33447: LIST
33448: LIST
33449: LIST
33450: LIST
33451: LIST
33452: LIST
33453: LIST
33454: LIST
33455: LIST
33456: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33457: LD_ADDR_VAR 0 29
33461: PUSH
33462: LD_INT 0
33464: PUSH
33465: LD_INT 0
33467: PUSH
33468: EMPTY
33469: LIST
33470: LIST
33471: PUSH
33472: LD_INT 0
33474: PUSH
33475: LD_INT 1
33477: NEG
33478: PUSH
33479: EMPTY
33480: LIST
33481: LIST
33482: PUSH
33483: LD_INT 1
33485: PUSH
33486: LD_INT 0
33488: PUSH
33489: EMPTY
33490: LIST
33491: LIST
33492: PUSH
33493: LD_INT 1
33495: PUSH
33496: LD_INT 1
33498: PUSH
33499: EMPTY
33500: LIST
33501: LIST
33502: PUSH
33503: LD_INT 0
33505: PUSH
33506: LD_INT 1
33508: PUSH
33509: EMPTY
33510: LIST
33511: LIST
33512: PUSH
33513: LD_INT 1
33515: NEG
33516: PUSH
33517: LD_INT 0
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 1
33526: NEG
33527: PUSH
33528: LD_INT 1
33530: NEG
33531: PUSH
33532: EMPTY
33533: LIST
33534: LIST
33535: PUSH
33536: LD_INT 1
33538: NEG
33539: PUSH
33540: LD_INT 2
33542: NEG
33543: PUSH
33544: EMPTY
33545: LIST
33546: LIST
33547: PUSH
33548: LD_INT 0
33550: PUSH
33551: LD_INT 2
33553: NEG
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 1
33561: PUSH
33562: LD_INT 1
33564: NEG
33565: PUSH
33566: EMPTY
33567: LIST
33568: LIST
33569: PUSH
33570: LD_INT 2
33572: PUSH
33573: LD_INT 0
33575: PUSH
33576: EMPTY
33577: LIST
33578: LIST
33579: PUSH
33580: LD_INT 2
33582: PUSH
33583: LD_INT 1
33585: PUSH
33586: EMPTY
33587: LIST
33588: LIST
33589: PUSH
33590: LD_INT 1
33592: PUSH
33593: LD_INT 2
33595: PUSH
33596: EMPTY
33597: LIST
33598: LIST
33599: PUSH
33600: LD_INT 0
33602: PUSH
33603: LD_INT 2
33605: PUSH
33606: EMPTY
33607: LIST
33608: LIST
33609: PUSH
33610: LD_INT 1
33612: NEG
33613: PUSH
33614: LD_INT 1
33616: PUSH
33617: EMPTY
33618: LIST
33619: LIST
33620: PUSH
33621: LD_INT 2
33623: NEG
33624: PUSH
33625: LD_INT 1
33627: NEG
33628: PUSH
33629: EMPTY
33630: LIST
33631: LIST
33632: PUSH
33633: LD_INT 2
33635: NEG
33636: PUSH
33637: LD_INT 2
33639: NEG
33640: PUSH
33641: EMPTY
33642: LIST
33643: LIST
33644: PUSH
33645: LD_INT 2
33647: NEG
33648: PUSH
33649: LD_INT 3
33651: NEG
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: PUSH
33657: LD_INT 2
33659: PUSH
33660: LD_INT 1
33662: NEG
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: LD_INT 3
33670: PUSH
33671: LD_INT 1
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PUSH
33678: LD_INT 1
33680: PUSH
33681: LD_INT 3
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 1
33690: NEG
33691: PUSH
33692: LD_INT 2
33694: PUSH
33695: EMPTY
33696: LIST
33697: LIST
33698: PUSH
33699: LD_INT 3
33701: NEG
33702: PUSH
33703: LD_INT 2
33705: NEG
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PUSH
33711: EMPTY
33712: LIST
33713: LIST
33714: LIST
33715: LIST
33716: LIST
33717: LIST
33718: LIST
33719: LIST
33720: LIST
33721: LIST
33722: LIST
33723: LIST
33724: LIST
33725: LIST
33726: LIST
33727: LIST
33728: LIST
33729: LIST
33730: LIST
33731: LIST
33732: LIST
33733: LIST
33734: LIST
33735: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33736: LD_ADDR_VAR 0 30
33740: PUSH
33741: LD_INT 0
33743: PUSH
33744: LD_INT 0
33746: PUSH
33747: EMPTY
33748: LIST
33749: LIST
33750: PUSH
33751: LD_INT 0
33753: PUSH
33754: LD_INT 1
33756: NEG
33757: PUSH
33758: EMPTY
33759: LIST
33760: LIST
33761: PUSH
33762: LD_INT 1
33764: PUSH
33765: LD_INT 0
33767: PUSH
33768: EMPTY
33769: LIST
33770: LIST
33771: PUSH
33772: LD_INT 1
33774: PUSH
33775: LD_INT 1
33777: PUSH
33778: EMPTY
33779: LIST
33780: LIST
33781: PUSH
33782: LD_INT 0
33784: PUSH
33785: LD_INT 1
33787: PUSH
33788: EMPTY
33789: LIST
33790: LIST
33791: PUSH
33792: LD_INT 1
33794: NEG
33795: PUSH
33796: LD_INT 0
33798: PUSH
33799: EMPTY
33800: LIST
33801: LIST
33802: PUSH
33803: LD_INT 1
33805: NEG
33806: PUSH
33807: LD_INT 1
33809: NEG
33810: PUSH
33811: EMPTY
33812: LIST
33813: LIST
33814: PUSH
33815: LD_INT 1
33817: NEG
33818: PUSH
33819: LD_INT 2
33821: NEG
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PUSH
33827: LD_INT 0
33829: PUSH
33830: LD_INT 2
33832: NEG
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: PUSH
33838: LD_INT 1
33840: PUSH
33841: LD_INT 1
33843: NEG
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: PUSH
33849: LD_INT 2
33851: PUSH
33852: LD_INT 0
33854: PUSH
33855: EMPTY
33856: LIST
33857: LIST
33858: PUSH
33859: LD_INT 2
33861: PUSH
33862: LD_INT 1
33864: PUSH
33865: EMPTY
33866: LIST
33867: LIST
33868: PUSH
33869: LD_INT 2
33871: PUSH
33872: LD_INT 2
33874: PUSH
33875: EMPTY
33876: LIST
33877: LIST
33878: PUSH
33879: LD_INT 1
33881: PUSH
33882: LD_INT 2
33884: PUSH
33885: EMPTY
33886: LIST
33887: LIST
33888: PUSH
33889: LD_INT 1
33891: NEG
33892: PUSH
33893: LD_INT 1
33895: PUSH
33896: EMPTY
33897: LIST
33898: LIST
33899: PUSH
33900: LD_INT 2
33902: NEG
33903: PUSH
33904: LD_INT 0
33906: PUSH
33907: EMPTY
33908: LIST
33909: LIST
33910: PUSH
33911: LD_INT 2
33913: NEG
33914: PUSH
33915: LD_INT 1
33917: NEG
33918: PUSH
33919: EMPTY
33920: LIST
33921: LIST
33922: PUSH
33923: LD_INT 1
33925: NEG
33926: PUSH
33927: LD_INT 3
33929: NEG
33930: PUSH
33931: EMPTY
33932: LIST
33933: LIST
33934: PUSH
33935: LD_INT 1
33937: PUSH
33938: LD_INT 2
33940: NEG
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: PUSH
33946: LD_INT 3
33948: PUSH
33949: LD_INT 2
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: PUSH
33956: LD_INT 2
33958: PUSH
33959: LD_INT 3
33961: PUSH
33962: EMPTY
33963: LIST
33964: LIST
33965: PUSH
33966: LD_INT 2
33968: NEG
33969: PUSH
33970: LD_INT 1
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: LD_INT 3
33979: NEG
33980: PUSH
33981: LD_INT 1
33983: NEG
33984: PUSH
33985: EMPTY
33986: LIST
33987: LIST
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: LIST
33993: LIST
33994: LIST
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: LIST
34000: LIST
34001: LIST
34002: LIST
34003: LIST
34004: LIST
34005: LIST
34006: LIST
34007: LIST
34008: LIST
34009: LIST
34010: LIST
34011: LIST
34012: LIST
34013: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34014: LD_ADDR_VAR 0 31
34018: PUSH
34019: LD_INT 0
34021: PUSH
34022: LD_INT 0
34024: PUSH
34025: EMPTY
34026: LIST
34027: LIST
34028: PUSH
34029: LD_INT 0
34031: PUSH
34032: LD_INT 1
34034: NEG
34035: PUSH
34036: EMPTY
34037: LIST
34038: LIST
34039: PUSH
34040: LD_INT 1
34042: PUSH
34043: LD_INT 0
34045: PUSH
34046: EMPTY
34047: LIST
34048: LIST
34049: PUSH
34050: LD_INT 1
34052: PUSH
34053: LD_INT 1
34055: PUSH
34056: EMPTY
34057: LIST
34058: LIST
34059: PUSH
34060: LD_INT 0
34062: PUSH
34063: LD_INT 1
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: PUSH
34070: LD_INT 1
34072: NEG
34073: PUSH
34074: LD_INT 0
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 1
34083: NEG
34084: PUSH
34085: LD_INT 1
34087: NEG
34088: PUSH
34089: EMPTY
34090: LIST
34091: LIST
34092: PUSH
34093: LD_INT 1
34095: NEG
34096: PUSH
34097: LD_INT 2
34099: NEG
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PUSH
34105: LD_INT 1
34107: PUSH
34108: LD_INT 1
34110: NEG
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 2
34118: PUSH
34119: LD_INT 0
34121: PUSH
34122: EMPTY
34123: LIST
34124: LIST
34125: PUSH
34126: LD_INT 2
34128: PUSH
34129: LD_INT 1
34131: PUSH
34132: EMPTY
34133: LIST
34134: LIST
34135: PUSH
34136: LD_INT 2
34138: PUSH
34139: LD_INT 2
34141: PUSH
34142: EMPTY
34143: LIST
34144: LIST
34145: PUSH
34146: LD_INT 1
34148: PUSH
34149: LD_INT 2
34151: PUSH
34152: EMPTY
34153: LIST
34154: LIST
34155: PUSH
34156: LD_INT 0
34158: PUSH
34159: LD_INT 2
34161: PUSH
34162: EMPTY
34163: LIST
34164: LIST
34165: PUSH
34166: LD_INT 1
34168: NEG
34169: PUSH
34170: LD_INT 1
34172: PUSH
34173: EMPTY
34174: LIST
34175: LIST
34176: PUSH
34177: LD_INT 2
34179: NEG
34180: PUSH
34181: LD_INT 1
34183: NEG
34184: PUSH
34185: EMPTY
34186: LIST
34187: LIST
34188: PUSH
34189: LD_INT 2
34191: NEG
34192: PUSH
34193: LD_INT 2
34195: NEG
34196: PUSH
34197: EMPTY
34198: LIST
34199: LIST
34200: PUSH
34201: LD_INT 2
34203: NEG
34204: PUSH
34205: LD_INT 3
34207: NEG
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 2
34215: PUSH
34216: LD_INT 1
34218: NEG
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 3
34226: PUSH
34227: LD_INT 1
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: LD_INT 1
34236: PUSH
34237: LD_INT 3
34239: PUSH
34240: EMPTY
34241: LIST
34242: LIST
34243: PUSH
34244: LD_INT 1
34246: NEG
34247: PUSH
34248: LD_INT 2
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: LD_INT 3
34257: NEG
34258: PUSH
34259: LD_INT 2
34261: NEG
34262: PUSH
34263: EMPTY
34264: LIST
34265: LIST
34266: PUSH
34267: EMPTY
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: LIST
34279: LIST
34280: LIST
34281: LIST
34282: LIST
34283: LIST
34284: LIST
34285: LIST
34286: LIST
34287: LIST
34288: LIST
34289: LIST
34290: LIST
34291: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34292: LD_ADDR_VAR 0 32
34296: PUSH
34297: LD_INT 0
34299: PUSH
34300: LD_INT 0
34302: PUSH
34303: EMPTY
34304: LIST
34305: LIST
34306: PUSH
34307: LD_INT 0
34309: PUSH
34310: LD_INT 1
34312: NEG
34313: PUSH
34314: EMPTY
34315: LIST
34316: LIST
34317: PUSH
34318: LD_INT 1
34320: PUSH
34321: LD_INT 0
34323: PUSH
34324: EMPTY
34325: LIST
34326: LIST
34327: PUSH
34328: LD_INT 1
34330: PUSH
34331: LD_INT 1
34333: PUSH
34334: EMPTY
34335: LIST
34336: LIST
34337: PUSH
34338: LD_INT 0
34340: PUSH
34341: LD_INT 1
34343: PUSH
34344: EMPTY
34345: LIST
34346: LIST
34347: PUSH
34348: LD_INT 1
34350: NEG
34351: PUSH
34352: LD_INT 0
34354: PUSH
34355: EMPTY
34356: LIST
34357: LIST
34358: PUSH
34359: LD_INT 1
34361: NEG
34362: PUSH
34363: LD_INT 1
34365: NEG
34366: PUSH
34367: EMPTY
34368: LIST
34369: LIST
34370: PUSH
34371: LD_INT 1
34373: NEG
34374: PUSH
34375: LD_INT 2
34377: NEG
34378: PUSH
34379: EMPTY
34380: LIST
34381: LIST
34382: PUSH
34383: LD_INT 0
34385: PUSH
34386: LD_INT 2
34388: NEG
34389: PUSH
34390: EMPTY
34391: LIST
34392: LIST
34393: PUSH
34394: LD_INT 1
34396: PUSH
34397: LD_INT 1
34399: NEG
34400: PUSH
34401: EMPTY
34402: LIST
34403: LIST
34404: PUSH
34405: LD_INT 2
34407: PUSH
34408: LD_INT 1
34410: PUSH
34411: EMPTY
34412: LIST
34413: LIST
34414: PUSH
34415: LD_INT 2
34417: PUSH
34418: LD_INT 2
34420: PUSH
34421: EMPTY
34422: LIST
34423: LIST
34424: PUSH
34425: LD_INT 1
34427: PUSH
34428: LD_INT 2
34430: PUSH
34431: EMPTY
34432: LIST
34433: LIST
34434: PUSH
34435: LD_INT 0
34437: PUSH
34438: LD_INT 2
34440: PUSH
34441: EMPTY
34442: LIST
34443: LIST
34444: PUSH
34445: LD_INT 1
34447: NEG
34448: PUSH
34449: LD_INT 1
34451: PUSH
34452: EMPTY
34453: LIST
34454: LIST
34455: PUSH
34456: LD_INT 2
34458: NEG
34459: PUSH
34460: LD_INT 0
34462: PUSH
34463: EMPTY
34464: LIST
34465: LIST
34466: PUSH
34467: LD_INT 2
34469: NEG
34470: PUSH
34471: LD_INT 1
34473: NEG
34474: PUSH
34475: EMPTY
34476: LIST
34477: LIST
34478: PUSH
34479: LD_INT 1
34481: NEG
34482: PUSH
34483: LD_INT 3
34485: NEG
34486: PUSH
34487: EMPTY
34488: LIST
34489: LIST
34490: PUSH
34491: LD_INT 1
34493: PUSH
34494: LD_INT 2
34496: NEG
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: PUSH
34502: LD_INT 3
34504: PUSH
34505: LD_INT 2
34507: PUSH
34508: EMPTY
34509: LIST
34510: LIST
34511: PUSH
34512: LD_INT 2
34514: PUSH
34515: LD_INT 3
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PUSH
34522: LD_INT 2
34524: NEG
34525: PUSH
34526: LD_INT 1
34528: PUSH
34529: EMPTY
34530: LIST
34531: LIST
34532: PUSH
34533: LD_INT 3
34535: NEG
34536: PUSH
34537: LD_INT 1
34539: NEG
34540: PUSH
34541: EMPTY
34542: LIST
34543: LIST
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: LIST
34549: LIST
34550: LIST
34551: LIST
34552: LIST
34553: LIST
34554: LIST
34555: LIST
34556: LIST
34557: LIST
34558: LIST
34559: LIST
34560: LIST
34561: LIST
34562: LIST
34563: LIST
34564: LIST
34565: LIST
34566: LIST
34567: LIST
34568: LIST
34569: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34570: LD_ADDR_VAR 0 33
34574: PUSH
34575: LD_INT 0
34577: PUSH
34578: LD_INT 0
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 0
34587: PUSH
34588: LD_INT 1
34590: NEG
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PUSH
34596: LD_INT 1
34598: PUSH
34599: LD_INT 0
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 1
34608: PUSH
34609: LD_INT 1
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 0
34618: PUSH
34619: LD_INT 1
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 1
34628: NEG
34629: PUSH
34630: LD_INT 0
34632: PUSH
34633: EMPTY
34634: LIST
34635: LIST
34636: PUSH
34637: LD_INT 1
34639: NEG
34640: PUSH
34641: LD_INT 1
34643: NEG
34644: PUSH
34645: EMPTY
34646: LIST
34647: LIST
34648: PUSH
34649: LD_INT 1
34651: NEG
34652: PUSH
34653: LD_INT 2
34655: NEG
34656: PUSH
34657: EMPTY
34658: LIST
34659: LIST
34660: PUSH
34661: LD_INT 1
34663: PUSH
34664: LD_INT 1
34666: NEG
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 2
34674: PUSH
34675: LD_INT 0
34677: PUSH
34678: EMPTY
34679: LIST
34680: LIST
34681: PUSH
34682: LD_INT 2
34684: PUSH
34685: LD_INT 1
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: PUSH
34692: LD_INT 1
34694: PUSH
34695: LD_INT 2
34697: PUSH
34698: EMPTY
34699: LIST
34700: LIST
34701: PUSH
34702: LD_INT 0
34704: PUSH
34705: LD_INT 2
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: LD_INT 1
34714: NEG
34715: PUSH
34716: LD_INT 1
34718: PUSH
34719: EMPTY
34720: LIST
34721: LIST
34722: PUSH
34723: LD_INT 2
34725: NEG
34726: PUSH
34727: LD_INT 0
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 2
34736: NEG
34737: PUSH
34738: LD_INT 1
34740: NEG
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PUSH
34746: LD_INT 2
34748: NEG
34749: PUSH
34750: LD_INT 2
34752: NEG
34753: PUSH
34754: EMPTY
34755: LIST
34756: LIST
34757: PUSH
34758: LD_INT 2
34760: NEG
34761: PUSH
34762: LD_INT 3
34764: NEG
34765: PUSH
34766: EMPTY
34767: LIST
34768: LIST
34769: PUSH
34770: LD_INT 2
34772: PUSH
34773: LD_INT 1
34775: NEG
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: PUSH
34781: LD_INT 3
34783: PUSH
34784: LD_INT 1
34786: PUSH
34787: EMPTY
34788: LIST
34789: LIST
34790: PUSH
34791: LD_INT 1
34793: PUSH
34794: LD_INT 3
34796: PUSH
34797: EMPTY
34798: LIST
34799: LIST
34800: PUSH
34801: LD_INT 1
34803: NEG
34804: PUSH
34805: LD_INT 2
34807: PUSH
34808: EMPTY
34809: LIST
34810: LIST
34811: PUSH
34812: LD_INT 3
34814: NEG
34815: PUSH
34816: LD_INT 2
34818: NEG
34819: PUSH
34820: EMPTY
34821: LIST
34822: LIST
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: LIST
34828: LIST
34829: LIST
34830: LIST
34831: LIST
34832: LIST
34833: LIST
34834: LIST
34835: LIST
34836: LIST
34837: LIST
34838: LIST
34839: LIST
34840: LIST
34841: LIST
34842: LIST
34843: LIST
34844: LIST
34845: LIST
34846: LIST
34847: LIST
34848: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34849: LD_ADDR_VAR 0 34
34853: PUSH
34854: LD_INT 0
34856: PUSH
34857: LD_INT 0
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: PUSH
34864: LD_INT 0
34866: PUSH
34867: LD_INT 1
34869: NEG
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 1
34877: PUSH
34878: LD_INT 0
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 1
34887: PUSH
34888: LD_INT 1
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 0
34897: PUSH
34898: LD_INT 1
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: PUSH
34905: LD_INT 1
34907: NEG
34908: PUSH
34909: LD_INT 0
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 1
34918: NEG
34919: PUSH
34920: LD_INT 1
34922: NEG
34923: PUSH
34924: EMPTY
34925: LIST
34926: LIST
34927: PUSH
34928: LD_INT 1
34930: NEG
34931: PUSH
34932: LD_INT 2
34934: NEG
34935: PUSH
34936: EMPTY
34937: LIST
34938: LIST
34939: PUSH
34940: LD_INT 0
34942: PUSH
34943: LD_INT 2
34945: NEG
34946: PUSH
34947: EMPTY
34948: LIST
34949: LIST
34950: PUSH
34951: LD_INT 1
34953: PUSH
34954: LD_INT 1
34956: NEG
34957: PUSH
34958: EMPTY
34959: LIST
34960: LIST
34961: PUSH
34962: LD_INT 2
34964: PUSH
34965: LD_INT 1
34967: PUSH
34968: EMPTY
34969: LIST
34970: LIST
34971: PUSH
34972: LD_INT 2
34974: PUSH
34975: LD_INT 2
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: LD_INT 1
34984: PUSH
34985: LD_INT 2
34987: PUSH
34988: EMPTY
34989: LIST
34990: LIST
34991: PUSH
34992: LD_INT 1
34994: NEG
34995: PUSH
34996: LD_INT 1
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: PUSH
35003: LD_INT 2
35005: NEG
35006: PUSH
35007: LD_INT 0
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: PUSH
35014: LD_INT 2
35016: NEG
35017: PUSH
35018: LD_INT 1
35020: NEG
35021: PUSH
35022: EMPTY
35023: LIST
35024: LIST
35025: PUSH
35026: LD_INT 2
35028: NEG
35029: PUSH
35030: LD_INT 2
35032: NEG
35033: PUSH
35034: EMPTY
35035: LIST
35036: LIST
35037: PUSH
35038: LD_INT 1
35040: NEG
35041: PUSH
35042: LD_INT 3
35044: NEG
35045: PUSH
35046: EMPTY
35047: LIST
35048: LIST
35049: PUSH
35050: LD_INT 1
35052: PUSH
35053: LD_INT 2
35055: NEG
35056: PUSH
35057: EMPTY
35058: LIST
35059: LIST
35060: PUSH
35061: LD_INT 3
35063: PUSH
35064: LD_INT 2
35066: PUSH
35067: EMPTY
35068: LIST
35069: LIST
35070: PUSH
35071: LD_INT 2
35073: PUSH
35074: LD_INT 3
35076: PUSH
35077: EMPTY
35078: LIST
35079: LIST
35080: PUSH
35081: LD_INT 2
35083: NEG
35084: PUSH
35085: LD_INT 1
35087: PUSH
35088: EMPTY
35089: LIST
35090: LIST
35091: PUSH
35092: LD_INT 3
35094: NEG
35095: PUSH
35096: LD_INT 1
35098: NEG
35099: PUSH
35100: EMPTY
35101: LIST
35102: LIST
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: LIST
35108: LIST
35109: LIST
35110: LIST
35111: LIST
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35129: LD_ADDR_VAR 0 35
35133: PUSH
35134: LD_INT 0
35136: PUSH
35137: LD_INT 0
35139: PUSH
35140: EMPTY
35141: LIST
35142: LIST
35143: PUSH
35144: LD_INT 0
35146: PUSH
35147: LD_INT 1
35149: NEG
35150: PUSH
35151: EMPTY
35152: LIST
35153: LIST
35154: PUSH
35155: LD_INT 1
35157: PUSH
35158: LD_INT 0
35160: PUSH
35161: EMPTY
35162: LIST
35163: LIST
35164: PUSH
35165: LD_INT 1
35167: PUSH
35168: LD_INT 1
35170: PUSH
35171: EMPTY
35172: LIST
35173: LIST
35174: PUSH
35175: LD_INT 0
35177: PUSH
35178: LD_INT 1
35180: PUSH
35181: EMPTY
35182: LIST
35183: LIST
35184: PUSH
35185: LD_INT 1
35187: NEG
35188: PUSH
35189: LD_INT 0
35191: PUSH
35192: EMPTY
35193: LIST
35194: LIST
35195: PUSH
35196: LD_INT 1
35198: NEG
35199: PUSH
35200: LD_INT 1
35202: NEG
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 2
35210: PUSH
35211: LD_INT 1
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: LD_INT 2
35220: NEG
35221: PUSH
35222: LD_INT 1
35224: NEG
35225: PUSH
35226: EMPTY
35227: LIST
35228: LIST
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: LIST
35234: LIST
35235: LIST
35236: LIST
35237: LIST
35238: LIST
35239: LIST
35240: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35241: LD_ADDR_VAR 0 36
35245: PUSH
35246: LD_INT 0
35248: PUSH
35249: LD_INT 0
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: LD_INT 0
35258: PUSH
35259: LD_INT 1
35261: NEG
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: LD_INT 1
35269: PUSH
35270: LD_INT 0
35272: PUSH
35273: EMPTY
35274: LIST
35275: LIST
35276: PUSH
35277: LD_INT 1
35279: PUSH
35280: LD_INT 1
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: PUSH
35287: LD_INT 0
35289: PUSH
35290: LD_INT 1
35292: PUSH
35293: EMPTY
35294: LIST
35295: LIST
35296: PUSH
35297: LD_INT 1
35299: NEG
35300: PUSH
35301: LD_INT 0
35303: PUSH
35304: EMPTY
35305: LIST
35306: LIST
35307: PUSH
35308: LD_INT 1
35310: NEG
35311: PUSH
35312: LD_INT 1
35314: NEG
35315: PUSH
35316: EMPTY
35317: LIST
35318: LIST
35319: PUSH
35320: LD_INT 1
35322: NEG
35323: PUSH
35324: LD_INT 2
35326: NEG
35327: PUSH
35328: EMPTY
35329: LIST
35330: LIST
35331: PUSH
35332: LD_INT 1
35334: PUSH
35335: LD_INT 2
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: EMPTY
35343: LIST
35344: LIST
35345: LIST
35346: LIST
35347: LIST
35348: LIST
35349: LIST
35350: LIST
35351: LIST
35352: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35353: LD_ADDR_VAR 0 37
35357: PUSH
35358: LD_INT 0
35360: PUSH
35361: LD_INT 0
35363: PUSH
35364: EMPTY
35365: LIST
35366: LIST
35367: PUSH
35368: LD_INT 0
35370: PUSH
35371: LD_INT 1
35373: NEG
35374: PUSH
35375: EMPTY
35376: LIST
35377: LIST
35378: PUSH
35379: LD_INT 1
35381: PUSH
35382: LD_INT 0
35384: PUSH
35385: EMPTY
35386: LIST
35387: LIST
35388: PUSH
35389: LD_INT 1
35391: PUSH
35392: LD_INT 1
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 0
35401: PUSH
35402: LD_INT 1
35404: PUSH
35405: EMPTY
35406: LIST
35407: LIST
35408: PUSH
35409: LD_INT 1
35411: NEG
35412: PUSH
35413: LD_INT 0
35415: PUSH
35416: EMPTY
35417: LIST
35418: LIST
35419: PUSH
35420: LD_INT 1
35422: NEG
35423: PUSH
35424: LD_INT 1
35426: NEG
35427: PUSH
35428: EMPTY
35429: LIST
35430: LIST
35431: PUSH
35432: LD_INT 1
35434: PUSH
35435: LD_INT 1
35437: NEG
35438: PUSH
35439: EMPTY
35440: LIST
35441: LIST
35442: PUSH
35443: LD_INT 1
35445: NEG
35446: PUSH
35447: LD_INT 1
35449: PUSH
35450: EMPTY
35451: LIST
35452: LIST
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: LIST
35458: LIST
35459: LIST
35460: LIST
35461: LIST
35462: LIST
35463: LIST
35464: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35465: LD_ADDR_VAR 0 38
35469: PUSH
35470: LD_INT 0
35472: PUSH
35473: LD_INT 0
35475: PUSH
35476: EMPTY
35477: LIST
35478: LIST
35479: PUSH
35480: LD_INT 0
35482: PUSH
35483: LD_INT 1
35485: NEG
35486: PUSH
35487: EMPTY
35488: LIST
35489: LIST
35490: PUSH
35491: LD_INT 1
35493: PUSH
35494: LD_INT 0
35496: PUSH
35497: EMPTY
35498: LIST
35499: LIST
35500: PUSH
35501: LD_INT 1
35503: PUSH
35504: LD_INT 1
35506: PUSH
35507: EMPTY
35508: LIST
35509: LIST
35510: PUSH
35511: LD_INT 0
35513: PUSH
35514: LD_INT 1
35516: PUSH
35517: EMPTY
35518: LIST
35519: LIST
35520: PUSH
35521: LD_INT 1
35523: NEG
35524: PUSH
35525: LD_INT 0
35527: PUSH
35528: EMPTY
35529: LIST
35530: LIST
35531: PUSH
35532: LD_INT 1
35534: NEG
35535: PUSH
35536: LD_INT 1
35538: NEG
35539: PUSH
35540: EMPTY
35541: LIST
35542: LIST
35543: PUSH
35544: LD_INT 2
35546: PUSH
35547: LD_INT 1
35549: PUSH
35550: EMPTY
35551: LIST
35552: LIST
35553: PUSH
35554: LD_INT 2
35556: NEG
35557: PUSH
35558: LD_INT 1
35560: NEG
35561: PUSH
35562: EMPTY
35563: LIST
35564: LIST
35565: PUSH
35566: EMPTY
35567: LIST
35568: LIST
35569: LIST
35570: LIST
35571: LIST
35572: LIST
35573: LIST
35574: LIST
35575: LIST
35576: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35577: LD_ADDR_VAR 0 39
35581: PUSH
35582: LD_INT 0
35584: PUSH
35585: LD_INT 0
35587: PUSH
35588: EMPTY
35589: LIST
35590: LIST
35591: PUSH
35592: LD_INT 0
35594: PUSH
35595: LD_INT 1
35597: NEG
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: PUSH
35603: LD_INT 1
35605: PUSH
35606: LD_INT 0
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: LD_INT 1
35615: PUSH
35616: LD_INT 1
35618: PUSH
35619: EMPTY
35620: LIST
35621: LIST
35622: PUSH
35623: LD_INT 0
35625: PUSH
35626: LD_INT 1
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: PUSH
35633: LD_INT 1
35635: NEG
35636: PUSH
35637: LD_INT 0
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: LD_INT 1
35646: NEG
35647: PUSH
35648: LD_INT 1
35650: NEG
35651: PUSH
35652: EMPTY
35653: LIST
35654: LIST
35655: PUSH
35656: LD_INT 1
35658: NEG
35659: PUSH
35660: LD_INT 2
35662: NEG
35663: PUSH
35664: EMPTY
35665: LIST
35666: LIST
35667: PUSH
35668: LD_INT 1
35670: PUSH
35671: LD_INT 2
35673: PUSH
35674: EMPTY
35675: LIST
35676: LIST
35677: PUSH
35678: EMPTY
35679: LIST
35680: LIST
35681: LIST
35682: LIST
35683: LIST
35684: LIST
35685: LIST
35686: LIST
35687: LIST
35688: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35689: LD_ADDR_VAR 0 40
35693: PUSH
35694: LD_INT 0
35696: PUSH
35697: LD_INT 0
35699: PUSH
35700: EMPTY
35701: LIST
35702: LIST
35703: PUSH
35704: LD_INT 0
35706: PUSH
35707: LD_INT 1
35709: NEG
35710: PUSH
35711: EMPTY
35712: LIST
35713: LIST
35714: PUSH
35715: LD_INT 1
35717: PUSH
35718: LD_INT 0
35720: PUSH
35721: EMPTY
35722: LIST
35723: LIST
35724: PUSH
35725: LD_INT 1
35727: PUSH
35728: LD_INT 1
35730: PUSH
35731: EMPTY
35732: LIST
35733: LIST
35734: PUSH
35735: LD_INT 0
35737: PUSH
35738: LD_INT 1
35740: PUSH
35741: EMPTY
35742: LIST
35743: LIST
35744: PUSH
35745: LD_INT 1
35747: NEG
35748: PUSH
35749: LD_INT 0
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: PUSH
35756: LD_INT 1
35758: NEG
35759: PUSH
35760: LD_INT 1
35762: NEG
35763: PUSH
35764: EMPTY
35765: LIST
35766: LIST
35767: PUSH
35768: LD_INT 1
35770: PUSH
35771: LD_INT 1
35773: NEG
35774: PUSH
35775: EMPTY
35776: LIST
35777: LIST
35778: PUSH
35779: LD_INT 1
35781: NEG
35782: PUSH
35783: LD_INT 1
35785: PUSH
35786: EMPTY
35787: LIST
35788: LIST
35789: PUSH
35790: EMPTY
35791: LIST
35792: LIST
35793: LIST
35794: LIST
35795: LIST
35796: LIST
35797: LIST
35798: LIST
35799: LIST
35800: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35801: LD_ADDR_VAR 0 41
35805: PUSH
35806: LD_INT 0
35808: PUSH
35809: LD_INT 0
35811: PUSH
35812: EMPTY
35813: LIST
35814: LIST
35815: PUSH
35816: LD_INT 0
35818: PUSH
35819: LD_INT 1
35821: NEG
35822: PUSH
35823: EMPTY
35824: LIST
35825: LIST
35826: PUSH
35827: LD_INT 1
35829: PUSH
35830: LD_INT 0
35832: PUSH
35833: EMPTY
35834: LIST
35835: LIST
35836: PUSH
35837: LD_INT 1
35839: PUSH
35840: LD_INT 1
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: LD_INT 0
35849: PUSH
35850: LD_INT 1
35852: PUSH
35853: EMPTY
35854: LIST
35855: LIST
35856: PUSH
35857: LD_INT 1
35859: NEG
35860: PUSH
35861: LD_INT 0
35863: PUSH
35864: EMPTY
35865: LIST
35866: LIST
35867: PUSH
35868: LD_INT 1
35870: NEG
35871: PUSH
35872: LD_INT 1
35874: NEG
35875: PUSH
35876: EMPTY
35877: LIST
35878: LIST
35879: PUSH
35880: LD_INT 1
35882: NEG
35883: PUSH
35884: LD_INT 2
35886: NEG
35887: PUSH
35888: EMPTY
35889: LIST
35890: LIST
35891: PUSH
35892: LD_INT 1
35894: PUSH
35895: LD_INT 1
35897: NEG
35898: PUSH
35899: EMPTY
35900: LIST
35901: LIST
35902: PUSH
35903: LD_INT 2
35905: PUSH
35906: LD_INT 0
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: PUSH
35913: LD_INT 2
35915: PUSH
35916: LD_INT 1
35918: PUSH
35919: EMPTY
35920: LIST
35921: LIST
35922: PUSH
35923: LD_INT 2
35925: PUSH
35926: LD_INT 2
35928: PUSH
35929: EMPTY
35930: LIST
35931: LIST
35932: PUSH
35933: LD_INT 1
35935: PUSH
35936: LD_INT 2
35938: PUSH
35939: EMPTY
35940: LIST
35941: LIST
35942: PUSH
35943: LD_INT 1
35945: NEG
35946: PUSH
35947: LD_INT 1
35949: PUSH
35950: EMPTY
35951: LIST
35952: LIST
35953: PUSH
35954: LD_INT 2
35956: NEG
35957: PUSH
35958: LD_INT 0
35960: PUSH
35961: EMPTY
35962: LIST
35963: LIST
35964: PUSH
35965: LD_INT 2
35967: NEG
35968: PUSH
35969: LD_INT 1
35971: NEG
35972: PUSH
35973: EMPTY
35974: LIST
35975: LIST
35976: PUSH
35977: LD_INT 2
35979: NEG
35980: PUSH
35981: LD_INT 2
35983: NEG
35984: PUSH
35985: EMPTY
35986: LIST
35987: LIST
35988: PUSH
35989: LD_INT 2
35991: NEG
35992: PUSH
35993: LD_INT 3
35995: NEG
35996: PUSH
35997: EMPTY
35998: LIST
35999: LIST
36000: PUSH
36001: LD_INT 2
36003: PUSH
36004: LD_INT 1
36006: NEG
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: PUSH
36012: LD_INT 3
36014: PUSH
36015: LD_INT 0
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 3
36024: PUSH
36025: LD_INT 1
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: LD_INT 3
36034: PUSH
36035: LD_INT 2
36037: PUSH
36038: EMPTY
36039: LIST
36040: LIST
36041: PUSH
36042: LD_INT 3
36044: PUSH
36045: LD_INT 3
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: LD_INT 2
36054: PUSH
36055: LD_INT 3
36057: PUSH
36058: EMPTY
36059: LIST
36060: LIST
36061: PUSH
36062: LD_INT 2
36064: NEG
36065: PUSH
36066: LD_INT 1
36068: PUSH
36069: EMPTY
36070: LIST
36071: LIST
36072: PUSH
36073: LD_INT 3
36075: NEG
36076: PUSH
36077: LD_INT 0
36079: PUSH
36080: EMPTY
36081: LIST
36082: LIST
36083: PUSH
36084: LD_INT 3
36086: NEG
36087: PUSH
36088: LD_INT 1
36090: NEG
36091: PUSH
36092: EMPTY
36093: LIST
36094: LIST
36095: PUSH
36096: LD_INT 3
36098: NEG
36099: PUSH
36100: LD_INT 2
36102: NEG
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PUSH
36108: LD_INT 3
36110: NEG
36111: PUSH
36112: LD_INT 3
36114: NEG
36115: PUSH
36116: EMPTY
36117: LIST
36118: LIST
36119: PUSH
36120: EMPTY
36121: LIST
36122: LIST
36123: LIST
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: LIST
36133: LIST
36134: LIST
36135: LIST
36136: LIST
36137: LIST
36138: LIST
36139: LIST
36140: LIST
36141: LIST
36142: LIST
36143: LIST
36144: LIST
36145: LIST
36146: LIST
36147: LIST
36148: LIST
36149: LIST
36150: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36151: LD_ADDR_VAR 0 42
36155: PUSH
36156: LD_INT 0
36158: PUSH
36159: LD_INT 0
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PUSH
36166: LD_INT 0
36168: PUSH
36169: LD_INT 1
36171: NEG
36172: PUSH
36173: EMPTY
36174: LIST
36175: LIST
36176: PUSH
36177: LD_INT 1
36179: PUSH
36180: LD_INT 0
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 1
36189: PUSH
36190: LD_INT 1
36192: PUSH
36193: EMPTY
36194: LIST
36195: LIST
36196: PUSH
36197: LD_INT 0
36199: PUSH
36200: LD_INT 1
36202: PUSH
36203: EMPTY
36204: LIST
36205: LIST
36206: PUSH
36207: LD_INT 1
36209: NEG
36210: PUSH
36211: LD_INT 0
36213: PUSH
36214: EMPTY
36215: LIST
36216: LIST
36217: PUSH
36218: LD_INT 1
36220: NEG
36221: PUSH
36222: LD_INT 1
36224: NEG
36225: PUSH
36226: EMPTY
36227: LIST
36228: LIST
36229: PUSH
36230: LD_INT 1
36232: NEG
36233: PUSH
36234: LD_INT 2
36236: NEG
36237: PUSH
36238: EMPTY
36239: LIST
36240: LIST
36241: PUSH
36242: LD_INT 0
36244: PUSH
36245: LD_INT 2
36247: NEG
36248: PUSH
36249: EMPTY
36250: LIST
36251: LIST
36252: PUSH
36253: LD_INT 1
36255: PUSH
36256: LD_INT 1
36258: NEG
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: LD_INT 2
36266: PUSH
36267: LD_INT 1
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 2
36276: PUSH
36277: LD_INT 2
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: LD_INT 1
36286: PUSH
36287: LD_INT 2
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: PUSH
36294: LD_INT 0
36296: PUSH
36297: LD_INT 2
36299: PUSH
36300: EMPTY
36301: LIST
36302: LIST
36303: PUSH
36304: LD_INT 1
36306: NEG
36307: PUSH
36308: LD_INT 1
36310: PUSH
36311: EMPTY
36312: LIST
36313: LIST
36314: PUSH
36315: LD_INT 2
36317: NEG
36318: PUSH
36319: LD_INT 1
36321: NEG
36322: PUSH
36323: EMPTY
36324: LIST
36325: LIST
36326: PUSH
36327: LD_INT 2
36329: NEG
36330: PUSH
36331: LD_INT 2
36333: NEG
36334: PUSH
36335: EMPTY
36336: LIST
36337: LIST
36338: PUSH
36339: LD_INT 2
36341: NEG
36342: PUSH
36343: LD_INT 3
36345: NEG
36346: PUSH
36347: EMPTY
36348: LIST
36349: LIST
36350: PUSH
36351: LD_INT 1
36353: NEG
36354: PUSH
36355: LD_INT 3
36357: NEG
36358: PUSH
36359: EMPTY
36360: LIST
36361: LIST
36362: PUSH
36363: LD_INT 0
36365: PUSH
36366: LD_INT 3
36368: NEG
36369: PUSH
36370: EMPTY
36371: LIST
36372: LIST
36373: PUSH
36374: LD_INT 1
36376: PUSH
36377: LD_INT 2
36379: NEG
36380: PUSH
36381: EMPTY
36382: LIST
36383: LIST
36384: PUSH
36385: LD_INT 3
36387: PUSH
36388: LD_INT 2
36390: PUSH
36391: EMPTY
36392: LIST
36393: LIST
36394: PUSH
36395: LD_INT 3
36397: PUSH
36398: LD_INT 3
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: PUSH
36405: LD_INT 2
36407: PUSH
36408: LD_INT 3
36410: PUSH
36411: EMPTY
36412: LIST
36413: LIST
36414: PUSH
36415: LD_INT 1
36417: PUSH
36418: LD_INT 3
36420: PUSH
36421: EMPTY
36422: LIST
36423: LIST
36424: PUSH
36425: LD_INT 0
36427: PUSH
36428: LD_INT 3
36430: PUSH
36431: EMPTY
36432: LIST
36433: LIST
36434: PUSH
36435: LD_INT 1
36437: NEG
36438: PUSH
36439: LD_INT 2
36441: PUSH
36442: EMPTY
36443: LIST
36444: LIST
36445: PUSH
36446: LD_INT 3
36448: NEG
36449: PUSH
36450: LD_INT 2
36452: NEG
36453: PUSH
36454: EMPTY
36455: LIST
36456: LIST
36457: PUSH
36458: LD_INT 3
36460: NEG
36461: PUSH
36462: LD_INT 3
36464: NEG
36465: PUSH
36466: EMPTY
36467: LIST
36468: LIST
36469: PUSH
36470: EMPTY
36471: LIST
36472: LIST
36473: LIST
36474: LIST
36475: LIST
36476: LIST
36477: LIST
36478: LIST
36479: LIST
36480: LIST
36481: LIST
36482: LIST
36483: LIST
36484: LIST
36485: LIST
36486: LIST
36487: LIST
36488: LIST
36489: LIST
36490: LIST
36491: LIST
36492: LIST
36493: LIST
36494: LIST
36495: LIST
36496: LIST
36497: LIST
36498: LIST
36499: LIST
36500: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36501: LD_ADDR_VAR 0 43
36505: PUSH
36506: LD_INT 0
36508: PUSH
36509: LD_INT 0
36511: PUSH
36512: EMPTY
36513: LIST
36514: LIST
36515: PUSH
36516: LD_INT 0
36518: PUSH
36519: LD_INT 1
36521: NEG
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PUSH
36527: LD_INT 1
36529: PUSH
36530: LD_INT 0
36532: PUSH
36533: EMPTY
36534: LIST
36535: LIST
36536: PUSH
36537: LD_INT 1
36539: PUSH
36540: LD_INT 1
36542: PUSH
36543: EMPTY
36544: LIST
36545: LIST
36546: PUSH
36547: LD_INT 0
36549: PUSH
36550: LD_INT 1
36552: PUSH
36553: EMPTY
36554: LIST
36555: LIST
36556: PUSH
36557: LD_INT 1
36559: NEG
36560: PUSH
36561: LD_INT 0
36563: PUSH
36564: EMPTY
36565: LIST
36566: LIST
36567: PUSH
36568: LD_INT 1
36570: NEG
36571: PUSH
36572: LD_INT 1
36574: NEG
36575: PUSH
36576: EMPTY
36577: LIST
36578: LIST
36579: PUSH
36580: LD_INT 1
36582: NEG
36583: PUSH
36584: LD_INT 2
36586: NEG
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PUSH
36592: LD_INT 0
36594: PUSH
36595: LD_INT 2
36597: NEG
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: PUSH
36603: LD_INT 1
36605: PUSH
36606: LD_INT 1
36608: NEG
36609: PUSH
36610: EMPTY
36611: LIST
36612: LIST
36613: PUSH
36614: LD_INT 2
36616: PUSH
36617: LD_INT 0
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 2
36626: PUSH
36627: LD_INT 1
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: PUSH
36634: LD_INT 1
36636: PUSH
36637: LD_INT 2
36639: PUSH
36640: EMPTY
36641: LIST
36642: LIST
36643: PUSH
36644: LD_INT 0
36646: PUSH
36647: LD_INT 2
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 1
36656: NEG
36657: PUSH
36658: LD_INT 1
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: LD_INT 2
36667: NEG
36668: PUSH
36669: LD_INT 0
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: LD_INT 2
36678: NEG
36679: PUSH
36680: LD_INT 1
36682: NEG
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: LD_INT 1
36690: NEG
36691: PUSH
36692: LD_INT 3
36694: NEG
36695: PUSH
36696: EMPTY
36697: LIST
36698: LIST
36699: PUSH
36700: LD_INT 0
36702: PUSH
36703: LD_INT 3
36705: NEG
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: LD_INT 1
36713: PUSH
36714: LD_INT 2
36716: NEG
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: LD_INT 2
36724: PUSH
36725: LD_INT 1
36727: NEG
36728: PUSH
36729: EMPTY
36730: LIST
36731: LIST
36732: PUSH
36733: LD_INT 3
36735: PUSH
36736: LD_INT 0
36738: PUSH
36739: EMPTY
36740: LIST
36741: LIST
36742: PUSH
36743: LD_INT 3
36745: PUSH
36746: LD_INT 1
36748: PUSH
36749: EMPTY
36750: LIST
36751: LIST
36752: PUSH
36753: LD_INT 1
36755: PUSH
36756: LD_INT 3
36758: PUSH
36759: EMPTY
36760: LIST
36761: LIST
36762: PUSH
36763: LD_INT 0
36765: PUSH
36766: LD_INT 3
36768: PUSH
36769: EMPTY
36770: LIST
36771: LIST
36772: PUSH
36773: LD_INT 1
36775: NEG
36776: PUSH
36777: LD_INT 2
36779: PUSH
36780: EMPTY
36781: LIST
36782: LIST
36783: PUSH
36784: LD_INT 2
36786: NEG
36787: PUSH
36788: LD_INT 1
36790: PUSH
36791: EMPTY
36792: LIST
36793: LIST
36794: PUSH
36795: LD_INT 3
36797: NEG
36798: PUSH
36799: LD_INT 0
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: LD_INT 3
36808: NEG
36809: PUSH
36810: LD_INT 1
36812: NEG
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: EMPTY
36819: LIST
36820: LIST
36821: LIST
36822: LIST
36823: LIST
36824: LIST
36825: LIST
36826: LIST
36827: LIST
36828: LIST
36829: LIST
36830: LIST
36831: LIST
36832: LIST
36833: LIST
36834: LIST
36835: LIST
36836: LIST
36837: LIST
36838: LIST
36839: LIST
36840: LIST
36841: LIST
36842: LIST
36843: LIST
36844: LIST
36845: LIST
36846: LIST
36847: LIST
36848: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36849: LD_ADDR_VAR 0 44
36853: PUSH
36854: LD_INT 0
36856: PUSH
36857: LD_INT 0
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PUSH
36864: LD_INT 0
36866: PUSH
36867: LD_INT 1
36869: NEG
36870: PUSH
36871: EMPTY
36872: LIST
36873: LIST
36874: PUSH
36875: LD_INT 1
36877: PUSH
36878: LD_INT 0
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: PUSH
36885: LD_INT 1
36887: PUSH
36888: LD_INT 1
36890: PUSH
36891: EMPTY
36892: LIST
36893: LIST
36894: PUSH
36895: LD_INT 0
36897: PUSH
36898: LD_INT 1
36900: PUSH
36901: EMPTY
36902: LIST
36903: LIST
36904: PUSH
36905: LD_INT 1
36907: NEG
36908: PUSH
36909: LD_INT 0
36911: PUSH
36912: EMPTY
36913: LIST
36914: LIST
36915: PUSH
36916: LD_INT 1
36918: NEG
36919: PUSH
36920: LD_INT 1
36922: NEG
36923: PUSH
36924: EMPTY
36925: LIST
36926: LIST
36927: PUSH
36928: LD_INT 1
36930: NEG
36931: PUSH
36932: LD_INT 2
36934: NEG
36935: PUSH
36936: EMPTY
36937: LIST
36938: LIST
36939: PUSH
36940: LD_INT 1
36942: PUSH
36943: LD_INT 1
36945: NEG
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PUSH
36951: LD_INT 2
36953: PUSH
36954: LD_INT 0
36956: PUSH
36957: EMPTY
36958: LIST
36959: LIST
36960: PUSH
36961: LD_INT 2
36963: PUSH
36964: LD_INT 1
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: LD_INT 2
36973: PUSH
36974: LD_INT 2
36976: PUSH
36977: EMPTY
36978: LIST
36979: LIST
36980: PUSH
36981: LD_INT 1
36983: PUSH
36984: LD_INT 2
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: PUSH
36991: LD_INT 1
36993: NEG
36994: PUSH
36995: LD_INT 1
36997: PUSH
36998: EMPTY
36999: LIST
37000: LIST
37001: PUSH
37002: LD_INT 2
37004: NEG
37005: PUSH
37006: LD_INT 0
37008: PUSH
37009: EMPTY
37010: LIST
37011: LIST
37012: PUSH
37013: LD_INT 2
37015: NEG
37016: PUSH
37017: LD_INT 1
37019: NEG
37020: PUSH
37021: EMPTY
37022: LIST
37023: LIST
37024: PUSH
37025: LD_INT 2
37027: NEG
37028: PUSH
37029: LD_INT 2
37031: NEG
37032: PUSH
37033: EMPTY
37034: LIST
37035: LIST
37036: PUSH
37037: LD_INT 2
37039: NEG
37040: PUSH
37041: LD_INT 3
37043: NEG
37044: PUSH
37045: EMPTY
37046: LIST
37047: LIST
37048: PUSH
37049: LD_INT 2
37051: PUSH
37052: LD_INT 1
37054: NEG
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 3
37062: PUSH
37063: LD_INT 0
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 3
37072: PUSH
37073: LD_INT 1
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: LD_INT 3
37082: PUSH
37083: LD_INT 2
37085: PUSH
37086: EMPTY
37087: LIST
37088: LIST
37089: PUSH
37090: LD_INT 3
37092: PUSH
37093: LD_INT 3
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 2
37102: PUSH
37103: LD_INT 3
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: PUSH
37110: LD_INT 2
37112: NEG
37113: PUSH
37114: LD_INT 1
37116: PUSH
37117: EMPTY
37118: LIST
37119: LIST
37120: PUSH
37121: LD_INT 3
37123: NEG
37124: PUSH
37125: LD_INT 0
37127: PUSH
37128: EMPTY
37129: LIST
37130: LIST
37131: PUSH
37132: LD_INT 3
37134: NEG
37135: PUSH
37136: LD_INT 1
37138: NEG
37139: PUSH
37140: EMPTY
37141: LIST
37142: LIST
37143: PUSH
37144: LD_INT 3
37146: NEG
37147: PUSH
37148: LD_INT 2
37150: NEG
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 3
37158: NEG
37159: PUSH
37160: LD_INT 3
37162: NEG
37163: PUSH
37164: EMPTY
37165: LIST
37166: LIST
37167: PUSH
37168: EMPTY
37169: LIST
37170: LIST
37171: LIST
37172: LIST
37173: LIST
37174: LIST
37175: LIST
37176: LIST
37177: LIST
37178: LIST
37179: LIST
37180: LIST
37181: LIST
37182: LIST
37183: LIST
37184: LIST
37185: LIST
37186: LIST
37187: LIST
37188: LIST
37189: LIST
37190: LIST
37191: LIST
37192: LIST
37193: LIST
37194: LIST
37195: LIST
37196: LIST
37197: LIST
37198: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37199: LD_ADDR_VAR 0 45
37203: PUSH
37204: LD_INT 0
37206: PUSH
37207: LD_INT 0
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 0
37216: PUSH
37217: LD_INT 1
37219: NEG
37220: PUSH
37221: EMPTY
37222: LIST
37223: LIST
37224: PUSH
37225: LD_INT 1
37227: PUSH
37228: LD_INT 0
37230: PUSH
37231: EMPTY
37232: LIST
37233: LIST
37234: PUSH
37235: LD_INT 1
37237: PUSH
37238: LD_INT 1
37240: PUSH
37241: EMPTY
37242: LIST
37243: LIST
37244: PUSH
37245: LD_INT 0
37247: PUSH
37248: LD_INT 1
37250: PUSH
37251: EMPTY
37252: LIST
37253: LIST
37254: PUSH
37255: LD_INT 1
37257: NEG
37258: PUSH
37259: LD_INT 0
37261: PUSH
37262: EMPTY
37263: LIST
37264: LIST
37265: PUSH
37266: LD_INT 1
37268: NEG
37269: PUSH
37270: LD_INT 1
37272: NEG
37273: PUSH
37274: EMPTY
37275: LIST
37276: LIST
37277: PUSH
37278: LD_INT 1
37280: NEG
37281: PUSH
37282: LD_INT 2
37284: NEG
37285: PUSH
37286: EMPTY
37287: LIST
37288: LIST
37289: PUSH
37290: LD_INT 0
37292: PUSH
37293: LD_INT 2
37295: NEG
37296: PUSH
37297: EMPTY
37298: LIST
37299: LIST
37300: PUSH
37301: LD_INT 1
37303: PUSH
37304: LD_INT 1
37306: NEG
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: PUSH
37312: LD_INT 2
37314: PUSH
37315: LD_INT 1
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 2
37324: PUSH
37325: LD_INT 2
37327: PUSH
37328: EMPTY
37329: LIST
37330: LIST
37331: PUSH
37332: LD_INT 1
37334: PUSH
37335: LD_INT 2
37337: PUSH
37338: EMPTY
37339: LIST
37340: LIST
37341: PUSH
37342: LD_INT 0
37344: PUSH
37345: LD_INT 2
37347: PUSH
37348: EMPTY
37349: LIST
37350: LIST
37351: PUSH
37352: LD_INT 1
37354: NEG
37355: PUSH
37356: LD_INT 1
37358: PUSH
37359: EMPTY
37360: LIST
37361: LIST
37362: PUSH
37363: LD_INT 2
37365: NEG
37366: PUSH
37367: LD_INT 1
37369: NEG
37370: PUSH
37371: EMPTY
37372: LIST
37373: LIST
37374: PUSH
37375: LD_INT 2
37377: NEG
37378: PUSH
37379: LD_INT 2
37381: NEG
37382: PUSH
37383: EMPTY
37384: LIST
37385: LIST
37386: PUSH
37387: LD_INT 2
37389: NEG
37390: PUSH
37391: LD_INT 3
37393: NEG
37394: PUSH
37395: EMPTY
37396: LIST
37397: LIST
37398: PUSH
37399: LD_INT 1
37401: NEG
37402: PUSH
37403: LD_INT 3
37405: NEG
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: PUSH
37411: LD_INT 0
37413: PUSH
37414: LD_INT 3
37416: NEG
37417: PUSH
37418: EMPTY
37419: LIST
37420: LIST
37421: PUSH
37422: LD_INT 1
37424: PUSH
37425: LD_INT 2
37427: NEG
37428: PUSH
37429: EMPTY
37430: LIST
37431: LIST
37432: PUSH
37433: LD_INT 3
37435: PUSH
37436: LD_INT 2
37438: PUSH
37439: EMPTY
37440: LIST
37441: LIST
37442: PUSH
37443: LD_INT 3
37445: PUSH
37446: LD_INT 3
37448: PUSH
37449: EMPTY
37450: LIST
37451: LIST
37452: PUSH
37453: LD_INT 2
37455: PUSH
37456: LD_INT 3
37458: PUSH
37459: EMPTY
37460: LIST
37461: LIST
37462: PUSH
37463: LD_INT 1
37465: PUSH
37466: LD_INT 3
37468: PUSH
37469: EMPTY
37470: LIST
37471: LIST
37472: PUSH
37473: LD_INT 0
37475: PUSH
37476: LD_INT 3
37478: PUSH
37479: EMPTY
37480: LIST
37481: LIST
37482: PUSH
37483: LD_INT 1
37485: NEG
37486: PUSH
37487: LD_INT 2
37489: PUSH
37490: EMPTY
37491: LIST
37492: LIST
37493: PUSH
37494: LD_INT 3
37496: NEG
37497: PUSH
37498: LD_INT 2
37500: NEG
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: PUSH
37506: LD_INT 3
37508: NEG
37509: PUSH
37510: LD_INT 3
37512: NEG
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: EMPTY
37519: LIST
37520: LIST
37521: LIST
37522: LIST
37523: LIST
37524: LIST
37525: LIST
37526: LIST
37527: LIST
37528: LIST
37529: LIST
37530: LIST
37531: LIST
37532: LIST
37533: LIST
37534: LIST
37535: LIST
37536: LIST
37537: LIST
37538: LIST
37539: LIST
37540: LIST
37541: LIST
37542: LIST
37543: LIST
37544: LIST
37545: LIST
37546: LIST
37547: LIST
37548: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37549: LD_ADDR_VAR 0 46
37553: PUSH
37554: LD_INT 0
37556: PUSH
37557: LD_INT 0
37559: PUSH
37560: EMPTY
37561: LIST
37562: LIST
37563: PUSH
37564: LD_INT 0
37566: PUSH
37567: LD_INT 1
37569: NEG
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: LD_INT 1
37577: PUSH
37578: LD_INT 0
37580: PUSH
37581: EMPTY
37582: LIST
37583: LIST
37584: PUSH
37585: LD_INT 1
37587: PUSH
37588: LD_INT 1
37590: PUSH
37591: EMPTY
37592: LIST
37593: LIST
37594: PUSH
37595: LD_INT 0
37597: PUSH
37598: LD_INT 1
37600: PUSH
37601: EMPTY
37602: LIST
37603: LIST
37604: PUSH
37605: LD_INT 1
37607: NEG
37608: PUSH
37609: LD_INT 0
37611: PUSH
37612: EMPTY
37613: LIST
37614: LIST
37615: PUSH
37616: LD_INT 1
37618: NEG
37619: PUSH
37620: LD_INT 1
37622: NEG
37623: PUSH
37624: EMPTY
37625: LIST
37626: LIST
37627: PUSH
37628: LD_INT 1
37630: NEG
37631: PUSH
37632: LD_INT 2
37634: NEG
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PUSH
37640: LD_INT 0
37642: PUSH
37643: LD_INT 2
37645: NEG
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 1
37653: PUSH
37654: LD_INT 1
37656: NEG
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 2
37664: PUSH
37665: LD_INT 0
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 2
37674: PUSH
37675: LD_INT 1
37677: PUSH
37678: EMPTY
37679: LIST
37680: LIST
37681: PUSH
37682: LD_INT 1
37684: PUSH
37685: LD_INT 2
37687: PUSH
37688: EMPTY
37689: LIST
37690: LIST
37691: PUSH
37692: LD_INT 0
37694: PUSH
37695: LD_INT 2
37697: PUSH
37698: EMPTY
37699: LIST
37700: LIST
37701: PUSH
37702: LD_INT 1
37704: NEG
37705: PUSH
37706: LD_INT 1
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: PUSH
37713: LD_INT 2
37715: NEG
37716: PUSH
37717: LD_INT 0
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 2
37726: NEG
37727: PUSH
37728: LD_INT 1
37730: NEG
37731: PUSH
37732: EMPTY
37733: LIST
37734: LIST
37735: PUSH
37736: LD_INT 1
37738: NEG
37739: PUSH
37740: LD_INT 3
37742: NEG
37743: PUSH
37744: EMPTY
37745: LIST
37746: LIST
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: LD_INT 3
37753: NEG
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: PUSH
37759: LD_INT 1
37761: PUSH
37762: LD_INT 2
37764: NEG
37765: PUSH
37766: EMPTY
37767: LIST
37768: LIST
37769: PUSH
37770: LD_INT 2
37772: PUSH
37773: LD_INT 1
37775: NEG
37776: PUSH
37777: EMPTY
37778: LIST
37779: LIST
37780: PUSH
37781: LD_INT 3
37783: PUSH
37784: LD_INT 0
37786: PUSH
37787: EMPTY
37788: LIST
37789: LIST
37790: PUSH
37791: LD_INT 3
37793: PUSH
37794: LD_INT 1
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 1
37803: PUSH
37804: LD_INT 3
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: PUSH
37811: LD_INT 0
37813: PUSH
37814: LD_INT 3
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: PUSH
37821: LD_INT 1
37823: NEG
37824: PUSH
37825: LD_INT 2
37827: PUSH
37828: EMPTY
37829: LIST
37830: LIST
37831: PUSH
37832: LD_INT 2
37834: NEG
37835: PUSH
37836: LD_INT 1
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 3
37845: NEG
37846: PUSH
37847: LD_INT 0
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 3
37856: NEG
37857: PUSH
37858: LD_INT 1
37860: NEG
37861: PUSH
37862: EMPTY
37863: LIST
37864: LIST
37865: PUSH
37866: EMPTY
37867: LIST
37868: LIST
37869: LIST
37870: LIST
37871: LIST
37872: LIST
37873: LIST
37874: LIST
37875: LIST
37876: LIST
37877: LIST
37878: LIST
37879: LIST
37880: LIST
37881: LIST
37882: LIST
37883: LIST
37884: LIST
37885: LIST
37886: LIST
37887: LIST
37888: LIST
37889: LIST
37890: LIST
37891: LIST
37892: LIST
37893: LIST
37894: LIST
37895: LIST
37896: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37897: LD_ADDR_VAR 0 47
37901: PUSH
37902: LD_INT 0
37904: PUSH
37905: LD_INT 0
37907: PUSH
37908: EMPTY
37909: LIST
37910: LIST
37911: PUSH
37912: LD_INT 0
37914: PUSH
37915: LD_INT 1
37917: NEG
37918: PUSH
37919: EMPTY
37920: LIST
37921: LIST
37922: PUSH
37923: LD_INT 1
37925: PUSH
37926: LD_INT 0
37928: PUSH
37929: EMPTY
37930: LIST
37931: LIST
37932: PUSH
37933: LD_INT 1
37935: PUSH
37936: LD_INT 1
37938: PUSH
37939: EMPTY
37940: LIST
37941: LIST
37942: PUSH
37943: LD_INT 0
37945: PUSH
37946: LD_INT 1
37948: PUSH
37949: EMPTY
37950: LIST
37951: LIST
37952: PUSH
37953: LD_INT 1
37955: NEG
37956: PUSH
37957: LD_INT 0
37959: PUSH
37960: EMPTY
37961: LIST
37962: LIST
37963: PUSH
37964: LD_INT 1
37966: NEG
37967: PUSH
37968: LD_INT 1
37970: NEG
37971: PUSH
37972: EMPTY
37973: LIST
37974: LIST
37975: PUSH
37976: LD_INT 1
37978: NEG
37979: PUSH
37980: LD_INT 2
37982: NEG
37983: PUSH
37984: EMPTY
37985: LIST
37986: LIST
37987: PUSH
37988: LD_INT 0
37990: PUSH
37991: LD_INT 2
37993: NEG
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: LD_INT 1
38001: PUSH
38002: LD_INT 1
38004: NEG
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 2
38012: NEG
38013: PUSH
38014: LD_INT 1
38016: NEG
38017: PUSH
38018: EMPTY
38019: LIST
38020: LIST
38021: PUSH
38022: LD_INT 2
38024: NEG
38025: PUSH
38026: LD_INT 2
38028: NEG
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PUSH
38034: EMPTY
38035: LIST
38036: LIST
38037: LIST
38038: LIST
38039: LIST
38040: LIST
38041: LIST
38042: LIST
38043: LIST
38044: LIST
38045: LIST
38046: LIST
38047: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38048: LD_ADDR_VAR 0 48
38052: PUSH
38053: LD_INT 0
38055: PUSH
38056: LD_INT 0
38058: PUSH
38059: EMPTY
38060: LIST
38061: LIST
38062: PUSH
38063: LD_INT 0
38065: PUSH
38066: LD_INT 1
38068: NEG
38069: PUSH
38070: EMPTY
38071: LIST
38072: LIST
38073: PUSH
38074: LD_INT 1
38076: PUSH
38077: LD_INT 0
38079: PUSH
38080: EMPTY
38081: LIST
38082: LIST
38083: PUSH
38084: LD_INT 1
38086: PUSH
38087: LD_INT 1
38089: PUSH
38090: EMPTY
38091: LIST
38092: LIST
38093: PUSH
38094: LD_INT 0
38096: PUSH
38097: LD_INT 1
38099: PUSH
38100: EMPTY
38101: LIST
38102: LIST
38103: PUSH
38104: LD_INT 1
38106: NEG
38107: PUSH
38108: LD_INT 0
38110: PUSH
38111: EMPTY
38112: LIST
38113: LIST
38114: PUSH
38115: LD_INT 1
38117: NEG
38118: PUSH
38119: LD_INT 1
38121: NEG
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: PUSH
38127: LD_INT 1
38129: NEG
38130: PUSH
38131: LD_INT 2
38133: NEG
38134: PUSH
38135: EMPTY
38136: LIST
38137: LIST
38138: PUSH
38139: LD_INT 0
38141: PUSH
38142: LD_INT 2
38144: NEG
38145: PUSH
38146: EMPTY
38147: LIST
38148: LIST
38149: PUSH
38150: LD_INT 1
38152: PUSH
38153: LD_INT 1
38155: NEG
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 2
38163: PUSH
38164: LD_INT 0
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 2
38173: PUSH
38174: LD_INT 1
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: EMPTY
38182: LIST
38183: LIST
38184: LIST
38185: LIST
38186: LIST
38187: LIST
38188: LIST
38189: LIST
38190: LIST
38191: LIST
38192: LIST
38193: LIST
38194: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38195: LD_ADDR_VAR 0 49
38199: PUSH
38200: LD_INT 0
38202: PUSH
38203: LD_INT 0
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 0
38212: PUSH
38213: LD_INT 1
38215: NEG
38216: PUSH
38217: EMPTY
38218: LIST
38219: LIST
38220: PUSH
38221: LD_INT 1
38223: PUSH
38224: LD_INT 0
38226: PUSH
38227: EMPTY
38228: LIST
38229: LIST
38230: PUSH
38231: LD_INT 1
38233: PUSH
38234: LD_INT 1
38236: PUSH
38237: EMPTY
38238: LIST
38239: LIST
38240: PUSH
38241: LD_INT 0
38243: PUSH
38244: LD_INT 1
38246: PUSH
38247: EMPTY
38248: LIST
38249: LIST
38250: PUSH
38251: LD_INT 1
38253: NEG
38254: PUSH
38255: LD_INT 0
38257: PUSH
38258: EMPTY
38259: LIST
38260: LIST
38261: PUSH
38262: LD_INT 1
38264: NEG
38265: PUSH
38266: LD_INT 1
38268: NEG
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PUSH
38274: LD_INT 1
38276: PUSH
38277: LD_INT 1
38279: NEG
38280: PUSH
38281: EMPTY
38282: LIST
38283: LIST
38284: PUSH
38285: LD_INT 2
38287: PUSH
38288: LD_INT 0
38290: PUSH
38291: EMPTY
38292: LIST
38293: LIST
38294: PUSH
38295: LD_INT 2
38297: PUSH
38298: LD_INT 1
38300: PUSH
38301: EMPTY
38302: LIST
38303: LIST
38304: PUSH
38305: LD_INT 2
38307: PUSH
38308: LD_INT 2
38310: PUSH
38311: EMPTY
38312: LIST
38313: LIST
38314: PUSH
38315: LD_INT 1
38317: PUSH
38318: LD_INT 2
38320: PUSH
38321: EMPTY
38322: LIST
38323: LIST
38324: PUSH
38325: EMPTY
38326: LIST
38327: LIST
38328: LIST
38329: LIST
38330: LIST
38331: LIST
38332: LIST
38333: LIST
38334: LIST
38335: LIST
38336: LIST
38337: LIST
38338: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38339: LD_ADDR_VAR 0 50
38343: PUSH
38344: LD_INT 0
38346: PUSH
38347: LD_INT 0
38349: PUSH
38350: EMPTY
38351: LIST
38352: LIST
38353: PUSH
38354: LD_INT 0
38356: PUSH
38357: LD_INT 1
38359: NEG
38360: PUSH
38361: EMPTY
38362: LIST
38363: LIST
38364: PUSH
38365: LD_INT 1
38367: PUSH
38368: LD_INT 0
38370: PUSH
38371: EMPTY
38372: LIST
38373: LIST
38374: PUSH
38375: LD_INT 1
38377: PUSH
38378: LD_INT 1
38380: PUSH
38381: EMPTY
38382: LIST
38383: LIST
38384: PUSH
38385: LD_INT 0
38387: PUSH
38388: LD_INT 1
38390: PUSH
38391: EMPTY
38392: LIST
38393: LIST
38394: PUSH
38395: LD_INT 1
38397: NEG
38398: PUSH
38399: LD_INT 0
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: PUSH
38406: LD_INT 1
38408: NEG
38409: PUSH
38410: LD_INT 1
38412: NEG
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 2
38420: PUSH
38421: LD_INT 1
38423: PUSH
38424: EMPTY
38425: LIST
38426: LIST
38427: PUSH
38428: LD_INT 2
38430: PUSH
38431: LD_INT 2
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: PUSH
38438: LD_INT 1
38440: PUSH
38441: LD_INT 2
38443: PUSH
38444: EMPTY
38445: LIST
38446: LIST
38447: PUSH
38448: LD_INT 0
38450: PUSH
38451: LD_INT 2
38453: PUSH
38454: EMPTY
38455: LIST
38456: LIST
38457: PUSH
38458: LD_INT 1
38460: NEG
38461: PUSH
38462: LD_INT 1
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: PUSH
38469: EMPTY
38470: LIST
38471: LIST
38472: LIST
38473: LIST
38474: LIST
38475: LIST
38476: LIST
38477: LIST
38478: LIST
38479: LIST
38480: LIST
38481: LIST
38482: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38483: LD_ADDR_VAR 0 51
38487: PUSH
38488: LD_INT 0
38490: PUSH
38491: LD_INT 0
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: PUSH
38498: LD_INT 0
38500: PUSH
38501: LD_INT 1
38503: NEG
38504: PUSH
38505: EMPTY
38506: LIST
38507: LIST
38508: PUSH
38509: LD_INT 1
38511: PUSH
38512: LD_INT 0
38514: PUSH
38515: EMPTY
38516: LIST
38517: LIST
38518: PUSH
38519: LD_INT 1
38521: PUSH
38522: LD_INT 1
38524: PUSH
38525: EMPTY
38526: LIST
38527: LIST
38528: PUSH
38529: LD_INT 0
38531: PUSH
38532: LD_INT 1
38534: PUSH
38535: EMPTY
38536: LIST
38537: LIST
38538: PUSH
38539: LD_INT 1
38541: NEG
38542: PUSH
38543: LD_INT 0
38545: PUSH
38546: EMPTY
38547: LIST
38548: LIST
38549: PUSH
38550: LD_INT 1
38552: NEG
38553: PUSH
38554: LD_INT 1
38556: NEG
38557: PUSH
38558: EMPTY
38559: LIST
38560: LIST
38561: PUSH
38562: LD_INT 1
38564: PUSH
38565: LD_INT 2
38567: PUSH
38568: EMPTY
38569: LIST
38570: LIST
38571: PUSH
38572: LD_INT 0
38574: PUSH
38575: LD_INT 2
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 1
38584: NEG
38585: PUSH
38586: LD_INT 1
38588: PUSH
38589: EMPTY
38590: LIST
38591: LIST
38592: PUSH
38593: LD_INT 2
38595: NEG
38596: PUSH
38597: LD_INT 0
38599: PUSH
38600: EMPTY
38601: LIST
38602: LIST
38603: PUSH
38604: LD_INT 2
38606: NEG
38607: PUSH
38608: LD_INT 1
38610: NEG
38611: PUSH
38612: EMPTY
38613: LIST
38614: LIST
38615: PUSH
38616: EMPTY
38617: LIST
38618: LIST
38619: LIST
38620: LIST
38621: LIST
38622: LIST
38623: LIST
38624: LIST
38625: LIST
38626: LIST
38627: LIST
38628: LIST
38629: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38630: LD_ADDR_VAR 0 52
38634: PUSH
38635: LD_INT 0
38637: PUSH
38638: LD_INT 0
38640: PUSH
38641: EMPTY
38642: LIST
38643: LIST
38644: PUSH
38645: LD_INT 0
38647: PUSH
38648: LD_INT 1
38650: NEG
38651: PUSH
38652: EMPTY
38653: LIST
38654: LIST
38655: PUSH
38656: LD_INT 1
38658: PUSH
38659: LD_INT 0
38661: PUSH
38662: EMPTY
38663: LIST
38664: LIST
38665: PUSH
38666: LD_INT 1
38668: PUSH
38669: LD_INT 1
38671: PUSH
38672: EMPTY
38673: LIST
38674: LIST
38675: PUSH
38676: LD_INT 0
38678: PUSH
38679: LD_INT 1
38681: PUSH
38682: EMPTY
38683: LIST
38684: LIST
38685: PUSH
38686: LD_INT 1
38688: NEG
38689: PUSH
38690: LD_INT 0
38692: PUSH
38693: EMPTY
38694: LIST
38695: LIST
38696: PUSH
38697: LD_INT 1
38699: NEG
38700: PUSH
38701: LD_INT 1
38703: NEG
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: PUSH
38709: LD_INT 1
38711: NEG
38712: PUSH
38713: LD_INT 2
38715: NEG
38716: PUSH
38717: EMPTY
38718: LIST
38719: LIST
38720: PUSH
38721: LD_INT 1
38723: NEG
38724: PUSH
38725: LD_INT 1
38727: PUSH
38728: EMPTY
38729: LIST
38730: LIST
38731: PUSH
38732: LD_INT 2
38734: NEG
38735: PUSH
38736: LD_INT 0
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PUSH
38743: LD_INT 2
38745: NEG
38746: PUSH
38747: LD_INT 1
38749: NEG
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: LD_INT 2
38757: NEG
38758: PUSH
38759: LD_INT 2
38761: NEG
38762: PUSH
38763: EMPTY
38764: LIST
38765: LIST
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: LIST
38771: LIST
38772: LIST
38773: LIST
38774: LIST
38775: LIST
38776: LIST
38777: LIST
38778: LIST
38779: LIST
38780: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38781: LD_ADDR_VAR 0 53
38785: PUSH
38786: LD_INT 0
38788: PUSH
38789: LD_INT 0
38791: PUSH
38792: EMPTY
38793: LIST
38794: LIST
38795: PUSH
38796: LD_INT 0
38798: PUSH
38799: LD_INT 1
38801: NEG
38802: PUSH
38803: EMPTY
38804: LIST
38805: LIST
38806: PUSH
38807: LD_INT 1
38809: PUSH
38810: LD_INT 0
38812: PUSH
38813: EMPTY
38814: LIST
38815: LIST
38816: PUSH
38817: LD_INT 1
38819: PUSH
38820: LD_INT 1
38822: PUSH
38823: EMPTY
38824: LIST
38825: LIST
38826: PUSH
38827: LD_INT 0
38829: PUSH
38830: LD_INT 1
38832: PUSH
38833: EMPTY
38834: LIST
38835: LIST
38836: PUSH
38837: LD_INT 1
38839: NEG
38840: PUSH
38841: LD_INT 0
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: LD_INT 1
38850: NEG
38851: PUSH
38852: LD_INT 1
38854: NEG
38855: PUSH
38856: EMPTY
38857: LIST
38858: LIST
38859: PUSH
38860: LD_INT 1
38862: NEG
38863: PUSH
38864: LD_INT 2
38866: NEG
38867: PUSH
38868: EMPTY
38869: LIST
38870: LIST
38871: PUSH
38872: LD_INT 0
38874: PUSH
38875: LD_INT 2
38877: NEG
38878: PUSH
38879: EMPTY
38880: LIST
38881: LIST
38882: PUSH
38883: LD_INT 1
38885: PUSH
38886: LD_INT 1
38888: NEG
38889: PUSH
38890: EMPTY
38891: LIST
38892: LIST
38893: PUSH
38894: LD_INT 2
38896: PUSH
38897: LD_INT 0
38899: PUSH
38900: EMPTY
38901: LIST
38902: LIST
38903: PUSH
38904: LD_INT 2
38906: PUSH
38907: LD_INT 1
38909: PUSH
38910: EMPTY
38911: LIST
38912: LIST
38913: PUSH
38914: LD_INT 2
38916: PUSH
38917: LD_INT 2
38919: PUSH
38920: EMPTY
38921: LIST
38922: LIST
38923: PUSH
38924: LD_INT 1
38926: PUSH
38927: LD_INT 2
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: PUSH
38934: LD_INT 0
38936: PUSH
38937: LD_INT 2
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: PUSH
38944: LD_INT 1
38946: NEG
38947: PUSH
38948: LD_INT 1
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: PUSH
38955: LD_INT 2
38957: NEG
38958: PUSH
38959: LD_INT 0
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: PUSH
38966: LD_INT 2
38968: NEG
38969: PUSH
38970: LD_INT 1
38972: NEG
38973: PUSH
38974: EMPTY
38975: LIST
38976: LIST
38977: PUSH
38978: LD_INT 2
38980: NEG
38981: PUSH
38982: LD_INT 2
38984: NEG
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: EMPTY
38991: LIST
38992: LIST
38993: LIST
38994: LIST
38995: LIST
38996: LIST
38997: LIST
38998: LIST
38999: LIST
39000: LIST
39001: LIST
39002: LIST
39003: LIST
39004: LIST
39005: LIST
39006: LIST
39007: LIST
39008: LIST
39009: LIST
39010: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39011: LD_ADDR_VAR 0 54
39015: PUSH
39016: LD_INT 0
39018: PUSH
39019: LD_INT 0
39021: PUSH
39022: EMPTY
39023: LIST
39024: LIST
39025: PUSH
39026: LD_INT 0
39028: PUSH
39029: LD_INT 1
39031: NEG
39032: PUSH
39033: EMPTY
39034: LIST
39035: LIST
39036: PUSH
39037: LD_INT 1
39039: PUSH
39040: LD_INT 0
39042: PUSH
39043: EMPTY
39044: LIST
39045: LIST
39046: PUSH
39047: LD_INT 1
39049: PUSH
39050: LD_INT 1
39052: PUSH
39053: EMPTY
39054: LIST
39055: LIST
39056: PUSH
39057: LD_INT 0
39059: PUSH
39060: LD_INT 1
39062: PUSH
39063: EMPTY
39064: LIST
39065: LIST
39066: PUSH
39067: LD_INT 1
39069: NEG
39070: PUSH
39071: LD_INT 0
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 1
39080: NEG
39081: PUSH
39082: LD_INT 1
39084: NEG
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PUSH
39090: LD_INT 1
39092: NEG
39093: PUSH
39094: LD_INT 2
39096: NEG
39097: PUSH
39098: EMPTY
39099: LIST
39100: LIST
39101: PUSH
39102: LD_INT 0
39104: PUSH
39105: LD_INT 2
39107: NEG
39108: PUSH
39109: EMPTY
39110: LIST
39111: LIST
39112: PUSH
39113: LD_INT 1
39115: PUSH
39116: LD_INT 1
39118: NEG
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: PUSH
39124: LD_INT 2
39126: PUSH
39127: LD_INT 0
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 2
39136: PUSH
39137: LD_INT 1
39139: PUSH
39140: EMPTY
39141: LIST
39142: LIST
39143: PUSH
39144: LD_INT 2
39146: PUSH
39147: LD_INT 2
39149: PUSH
39150: EMPTY
39151: LIST
39152: LIST
39153: PUSH
39154: LD_INT 1
39156: PUSH
39157: LD_INT 2
39159: PUSH
39160: EMPTY
39161: LIST
39162: LIST
39163: PUSH
39164: LD_INT 0
39166: PUSH
39167: LD_INT 2
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: PUSH
39174: LD_INT 1
39176: NEG
39177: PUSH
39178: LD_INT 1
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: PUSH
39185: LD_INT 2
39187: NEG
39188: PUSH
39189: LD_INT 0
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: PUSH
39196: LD_INT 2
39198: NEG
39199: PUSH
39200: LD_INT 1
39202: NEG
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: LD_INT 2
39210: NEG
39211: PUSH
39212: LD_INT 2
39214: NEG
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: PUSH
39220: EMPTY
39221: LIST
39222: LIST
39223: LIST
39224: LIST
39225: LIST
39226: LIST
39227: LIST
39228: LIST
39229: LIST
39230: LIST
39231: LIST
39232: LIST
39233: LIST
39234: LIST
39235: LIST
39236: LIST
39237: LIST
39238: LIST
39239: LIST
39240: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39241: LD_ADDR_VAR 0 55
39245: PUSH
39246: LD_INT 0
39248: PUSH
39249: LD_INT 0
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PUSH
39256: LD_INT 0
39258: PUSH
39259: LD_INT 1
39261: NEG
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 1
39269: PUSH
39270: LD_INT 0
39272: PUSH
39273: EMPTY
39274: LIST
39275: LIST
39276: PUSH
39277: LD_INT 1
39279: PUSH
39280: LD_INT 1
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: PUSH
39287: LD_INT 0
39289: PUSH
39290: LD_INT 1
39292: PUSH
39293: EMPTY
39294: LIST
39295: LIST
39296: PUSH
39297: LD_INT 1
39299: NEG
39300: PUSH
39301: LD_INT 0
39303: PUSH
39304: EMPTY
39305: LIST
39306: LIST
39307: PUSH
39308: LD_INT 1
39310: NEG
39311: PUSH
39312: LD_INT 1
39314: NEG
39315: PUSH
39316: EMPTY
39317: LIST
39318: LIST
39319: PUSH
39320: LD_INT 1
39322: NEG
39323: PUSH
39324: LD_INT 2
39326: NEG
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: LD_INT 0
39334: PUSH
39335: LD_INT 2
39337: NEG
39338: PUSH
39339: EMPTY
39340: LIST
39341: LIST
39342: PUSH
39343: LD_INT 1
39345: PUSH
39346: LD_INT 1
39348: NEG
39349: PUSH
39350: EMPTY
39351: LIST
39352: LIST
39353: PUSH
39354: LD_INT 2
39356: PUSH
39357: LD_INT 0
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: PUSH
39364: LD_INT 2
39366: PUSH
39367: LD_INT 1
39369: PUSH
39370: EMPTY
39371: LIST
39372: LIST
39373: PUSH
39374: LD_INT 2
39376: PUSH
39377: LD_INT 2
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: LD_INT 1
39386: PUSH
39387: LD_INT 2
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 0
39396: PUSH
39397: LD_INT 2
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: LD_INT 1
39406: NEG
39407: PUSH
39408: LD_INT 1
39410: PUSH
39411: EMPTY
39412: LIST
39413: LIST
39414: PUSH
39415: LD_INT 2
39417: NEG
39418: PUSH
39419: LD_INT 0
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: PUSH
39426: LD_INT 2
39428: NEG
39429: PUSH
39430: LD_INT 1
39432: NEG
39433: PUSH
39434: EMPTY
39435: LIST
39436: LIST
39437: PUSH
39438: LD_INT 2
39440: NEG
39441: PUSH
39442: LD_INT 2
39444: NEG
39445: PUSH
39446: EMPTY
39447: LIST
39448: LIST
39449: PUSH
39450: EMPTY
39451: LIST
39452: LIST
39453: LIST
39454: LIST
39455: LIST
39456: LIST
39457: LIST
39458: LIST
39459: LIST
39460: LIST
39461: LIST
39462: LIST
39463: LIST
39464: LIST
39465: LIST
39466: LIST
39467: LIST
39468: LIST
39469: LIST
39470: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39471: LD_ADDR_VAR 0 56
39475: PUSH
39476: LD_INT 0
39478: PUSH
39479: LD_INT 0
39481: PUSH
39482: EMPTY
39483: LIST
39484: LIST
39485: PUSH
39486: LD_INT 0
39488: PUSH
39489: LD_INT 1
39491: NEG
39492: PUSH
39493: EMPTY
39494: LIST
39495: LIST
39496: PUSH
39497: LD_INT 1
39499: PUSH
39500: LD_INT 0
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PUSH
39507: LD_INT 1
39509: PUSH
39510: LD_INT 1
39512: PUSH
39513: EMPTY
39514: LIST
39515: LIST
39516: PUSH
39517: LD_INT 0
39519: PUSH
39520: LD_INT 1
39522: PUSH
39523: EMPTY
39524: LIST
39525: LIST
39526: PUSH
39527: LD_INT 1
39529: NEG
39530: PUSH
39531: LD_INT 0
39533: PUSH
39534: EMPTY
39535: LIST
39536: LIST
39537: PUSH
39538: LD_INT 1
39540: NEG
39541: PUSH
39542: LD_INT 1
39544: NEG
39545: PUSH
39546: EMPTY
39547: LIST
39548: LIST
39549: PUSH
39550: LD_INT 1
39552: NEG
39553: PUSH
39554: LD_INT 2
39556: NEG
39557: PUSH
39558: EMPTY
39559: LIST
39560: LIST
39561: PUSH
39562: LD_INT 0
39564: PUSH
39565: LD_INT 2
39567: NEG
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 1
39575: PUSH
39576: LD_INT 1
39578: NEG
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 2
39586: PUSH
39587: LD_INT 0
39589: PUSH
39590: EMPTY
39591: LIST
39592: LIST
39593: PUSH
39594: LD_INT 2
39596: PUSH
39597: LD_INT 1
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: PUSH
39604: LD_INT 2
39606: PUSH
39607: LD_INT 2
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: PUSH
39614: LD_INT 1
39616: PUSH
39617: LD_INT 2
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: PUSH
39624: LD_INT 0
39626: PUSH
39627: LD_INT 2
39629: PUSH
39630: EMPTY
39631: LIST
39632: LIST
39633: PUSH
39634: LD_INT 1
39636: NEG
39637: PUSH
39638: LD_INT 1
39640: PUSH
39641: EMPTY
39642: LIST
39643: LIST
39644: PUSH
39645: LD_INT 2
39647: NEG
39648: PUSH
39649: LD_INT 0
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: LD_INT 2
39658: NEG
39659: PUSH
39660: LD_INT 1
39662: NEG
39663: PUSH
39664: EMPTY
39665: LIST
39666: LIST
39667: PUSH
39668: LD_INT 2
39670: NEG
39671: PUSH
39672: LD_INT 2
39674: NEG
39675: PUSH
39676: EMPTY
39677: LIST
39678: LIST
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: LIST
39684: LIST
39685: LIST
39686: LIST
39687: LIST
39688: LIST
39689: LIST
39690: LIST
39691: LIST
39692: LIST
39693: LIST
39694: LIST
39695: LIST
39696: LIST
39697: LIST
39698: LIST
39699: LIST
39700: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39701: LD_ADDR_VAR 0 57
39705: PUSH
39706: LD_INT 0
39708: PUSH
39709: LD_INT 0
39711: PUSH
39712: EMPTY
39713: LIST
39714: LIST
39715: PUSH
39716: LD_INT 0
39718: PUSH
39719: LD_INT 1
39721: NEG
39722: PUSH
39723: EMPTY
39724: LIST
39725: LIST
39726: PUSH
39727: LD_INT 1
39729: PUSH
39730: LD_INT 0
39732: PUSH
39733: EMPTY
39734: LIST
39735: LIST
39736: PUSH
39737: LD_INT 1
39739: PUSH
39740: LD_INT 1
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 0
39749: PUSH
39750: LD_INT 1
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: PUSH
39757: LD_INT 1
39759: NEG
39760: PUSH
39761: LD_INT 0
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: LD_INT 1
39770: NEG
39771: PUSH
39772: LD_INT 1
39774: NEG
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 1
39782: NEG
39783: PUSH
39784: LD_INT 2
39786: NEG
39787: PUSH
39788: EMPTY
39789: LIST
39790: LIST
39791: PUSH
39792: LD_INT 0
39794: PUSH
39795: LD_INT 2
39797: NEG
39798: PUSH
39799: EMPTY
39800: LIST
39801: LIST
39802: PUSH
39803: LD_INT 1
39805: PUSH
39806: LD_INT 1
39808: NEG
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: PUSH
39814: LD_INT 2
39816: PUSH
39817: LD_INT 0
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: LD_INT 2
39826: PUSH
39827: LD_INT 1
39829: PUSH
39830: EMPTY
39831: LIST
39832: LIST
39833: PUSH
39834: LD_INT 2
39836: PUSH
39837: LD_INT 2
39839: PUSH
39840: EMPTY
39841: LIST
39842: LIST
39843: PUSH
39844: LD_INT 1
39846: PUSH
39847: LD_INT 2
39849: PUSH
39850: EMPTY
39851: LIST
39852: LIST
39853: PUSH
39854: LD_INT 0
39856: PUSH
39857: LD_INT 2
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: PUSH
39864: LD_INT 1
39866: NEG
39867: PUSH
39868: LD_INT 1
39870: PUSH
39871: EMPTY
39872: LIST
39873: LIST
39874: PUSH
39875: LD_INT 2
39877: NEG
39878: PUSH
39879: LD_INT 0
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PUSH
39886: LD_INT 2
39888: NEG
39889: PUSH
39890: LD_INT 1
39892: NEG
39893: PUSH
39894: EMPTY
39895: LIST
39896: LIST
39897: PUSH
39898: LD_INT 2
39900: NEG
39901: PUSH
39902: LD_INT 2
39904: NEG
39905: PUSH
39906: EMPTY
39907: LIST
39908: LIST
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: LIST
39918: LIST
39919: LIST
39920: LIST
39921: LIST
39922: LIST
39923: LIST
39924: LIST
39925: LIST
39926: LIST
39927: LIST
39928: LIST
39929: LIST
39930: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39931: LD_ADDR_VAR 0 58
39935: PUSH
39936: LD_INT 0
39938: PUSH
39939: LD_INT 0
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PUSH
39946: LD_INT 0
39948: PUSH
39949: LD_INT 1
39951: NEG
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: PUSH
39957: LD_INT 1
39959: PUSH
39960: LD_INT 0
39962: PUSH
39963: EMPTY
39964: LIST
39965: LIST
39966: PUSH
39967: LD_INT 1
39969: PUSH
39970: LD_INT 1
39972: PUSH
39973: EMPTY
39974: LIST
39975: LIST
39976: PUSH
39977: LD_INT 0
39979: PUSH
39980: LD_INT 1
39982: PUSH
39983: EMPTY
39984: LIST
39985: LIST
39986: PUSH
39987: LD_INT 1
39989: NEG
39990: PUSH
39991: LD_INT 0
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PUSH
39998: LD_INT 1
40000: NEG
40001: PUSH
40002: LD_INT 1
40004: NEG
40005: PUSH
40006: EMPTY
40007: LIST
40008: LIST
40009: PUSH
40010: LD_INT 1
40012: NEG
40013: PUSH
40014: LD_INT 2
40016: NEG
40017: PUSH
40018: EMPTY
40019: LIST
40020: LIST
40021: PUSH
40022: LD_INT 0
40024: PUSH
40025: LD_INT 2
40027: NEG
40028: PUSH
40029: EMPTY
40030: LIST
40031: LIST
40032: PUSH
40033: LD_INT 1
40035: PUSH
40036: LD_INT 1
40038: NEG
40039: PUSH
40040: EMPTY
40041: LIST
40042: LIST
40043: PUSH
40044: LD_INT 2
40046: PUSH
40047: LD_INT 0
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: PUSH
40054: LD_INT 2
40056: PUSH
40057: LD_INT 1
40059: PUSH
40060: EMPTY
40061: LIST
40062: LIST
40063: PUSH
40064: LD_INT 2
40066: PUSH
40067: LD_INT 2
40069: PUSH
40070: EMPTY
40071: LIST
40072: LIST
40073: PUSH
40074: LD_INT 1
40076: PUSH
40077: LD_INT 2
40079: PUSH
40080: EMPTY
40081: LIST
40082: LIST
40083: PUSH
40084: LD_INT 0
40086: PUSH
40087: LD_INT 2
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: LD_INT 1
40096: NEG
40097: PUSH
40098: LD_INT 1
40100: PUSH
40101: EMPTY
40102: LIST
40103: LIST
40104: PUSH
40105: LD_INT 2
40107: NEG
40108: PUSH
40109: LD_INT 0
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 2
40118: NEG
40119: PUSH
40120: LD_INT 1
40122: NEG
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PUSH
40128: LD_INT 2
40130: NEG
40131: PUSH
40132: LD_INT 2
40134: NEG
40135: PUSH
40136: EMPTY
40137: LIST
40138: LIST
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: LIST
40144: LIST
40145: LIST
40146: LIST
40147: LIST
40148: LIST
40149: LIST
40150: LIST
40151: LIST
40152: LIST
40153: LIST
40154: LIST
40155: LIST
40156: LIST
40157: LIST
40158: LIST
40159: LIST
40160: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40161: LD_ADDR_VAR 0 59
40165: PUSH
40166: LD_INT 0
40168: PUSH
40169: LD_INT 0
40171: PUSH
40172: EMPTY
40173: LIST
40174: LIST
40175: PUSH
40176: LD_INT 0
40178: PUSH
40179: LD_INT 1
40181: NEG
40182: PUSH
40183: EMPTY
40184: LIST
40185: LIST
40186: PUSH
40187: LD_INT 1
40189: PUSH
40190: LD_INT 0
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: PUSH
40197: LD_INT 1
40199: PUSH
40200: LD_INT 1
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 0
40209: PUSH
40210: LD_INT 1
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: LD_INT 1
40219: NEG
40220: PUSH
40221: LD_INT 0
40223: PUSH
40224: EMPTY
40225: LIST
40226: LIST
40227: PUSH
40228: LD_INT 1
40230: NEG
40231: PUSH
40232: LD_INT 1
40234: NEG
40235: PUSH
40236: EMPTY
40237: LIST
40238: LIST
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: LIST
40244: LIST
40245: LIST
40246: LIST
40247: LIST
40248: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40249: LD_ADDR_VAR 0 60
40253: PUSH
40254: LD_INT 0
40256: PUSH
40257: LD_INT 0
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: PUSH
40264: LD_INT 0
40266: PUSH
40267: LD_INT 1
40269: NEG
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: PUSH
40275: LD_INT 1
40277: PUSH
40278: LD_INT 0
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: LD_INT 1
40287: PUSH
40288: LD_INT 1
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PUSH
40295: LD_INT 0
40297: PUSH
40298: LD_INT 1
40300: PUSH
40301: EMPTY
40302: LIST
40303: LIST
40304: PUSH
40305: LD_INT 1
40307: NEG
40308: PUSH
40309: LD_INT 0
40311: PUSH
40312: EMPTY
40313: LIST
40314: LIST
40315: PUSH
40316: LD_INT 1
40318: NEG
40319: PUSH
40320: LD_INT 1
40322: NEG
40323: PUSH
40324: EMPTY
40325: LIST
40326: LIST
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: LIST
40332: LIST
40333: LIST
40334: LIST
40335: LIST
40336: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40337: LD_ADDR_VAR 0 61
40341: PUSH
40342: LD_INT 0
40344: PUSH
40345: LD_INT 0
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: PUSH
40352: LD_INT 0
40354: PUSH
40355: LD_INT 1
40357: NEG
40358: PUSH
40359: EMPTY
40360: LIST
40361: LIST
40362: PUSH
40363: LD_INT 1
40365: PUSH
40366: LD_INT 0
40368: PUSH
40369: EMPTY
40370: LIST
40371: LIST
40372: PUSH
40373: LD_INT 1
40375: PUSH
40376: LD_INT 1
40378: PUSH
40379: EMPTY
40380: LIST
40381: LIST
40382: PUSH
40383: LD_INT 0
40385: PUSH
40386: LD_INT 1
40388: PUSH
40389: EMPTY
40390: LIST
40391: LIST
40392: PUSH
40393: LD_INT 1
40395: NEG
40396: PUSH
40397: LD_INT 0
40399: PUSH
40400: EMPTY
40401: LIST
40402: LIST
40403: PUSH
40404: LD_INT 1
40406: NEG
40407: PUSH
40408: LD_INT 1
40410: NEG
40411: PUSH
40412: EMPTY
40413: LIST
40414: LIST
40415: PUSH
40416: EMPTY
40417: LIST
40418: LIST
40419: LIST
40420: LIST
40421: LIST
40422: LIST
40423: LIST
40424: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40425: LD_ADDR_VAR 0 62
40429: PUSH
40430: LD_INT 0
40432: PUSH
40433: LD_INT 0
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: PUSH
40440: LD_INT 0
40442: PUSH
40443: LD_INT 1
40445: NEG
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: LD_INT 1
40453: PUSH
40454: LD_INT 0
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: PUSH
40461: LD_INT 1
40463: PUSH
40464: LD_INT 1
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 0
40473: PUSH
40474: LD_INT 1
40476: PUSH
40477: EMPTY
40478: LIST
40479: LIST
40480: PUSH
40481: LD_INT 1
40483: NEG
40484: PUSH
40485: LD_INT 0
40487: PUSH
40488: EMPTY
40489: LIST
40490: LIST
40491: PUSH
40492: LD_INT 1
40494: NEG
40495: PUSH
40496: LD_INT 1
40498: NEG
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: EMPTY
40505: LIST
40506: LIST
40507: LIST
40508: LIST
40509: LIST
40510: LIST
40511: LIST
40512: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40513: LD_ADDR_VAR 0 63
40517: PUSH
40518: LD_INT 0
40520: PUSH
40521: LD_INT 0
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 0
40530: PUSH
40531: LD_INT 1
40533: NEG
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: PUSH
40539: LD_INT 1
40541: PUSH
40542: LD_INT 0
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: LD_INT 1
40551: PUSH
40552: LD_INT 1
40554: PUSH
40555: EMPTY
40556: LIST
40557: LIST
40558: PUSH
40559: LD_INT 0
40561: PUSH
40562: LD_INT 1
40564: PUSH
40565: EMPTY
40566: LIST
40567: LIST
40568: PUSH
40569: LD_INT 1
40571: NEG
40572: PUSH
40573: LD_INT 0
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: PUSH
40580: LD_INT 1
40582: NEG
40583: PUSH
40584: LD_INT 1
40586: NEG
40587: PUSH
40588: EMPTY
40589: LIST
40590: LIST
40591: PUSH
40592: EMPTY
40593: LIST
40594: LIST
40595: LIST
40596: LIST
40597: LIST
40598: LIST
40599: LIST
40600: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40601: LD_ADDR_VAR 0 64
40605: PUSH
40606: LD_INT 0
40608: PUSH
40609: LD_INT 0
40611: PUSH
40612: EMPTY
40613: LIST
40614: LIST
40615: PUSH
40616: LD_INT 0
40618: PUSH
40619: LD_INT 1
40621: NEG
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: PUSH
40627: LD_INT 1
40629: PUSH
40630: LD_INT 0
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: PUSH
40637: LD_INT 1
40639: PUSH
40640: LD_INT 1
40642: PUSH
40643: EMPTY
40644: LIST
40645: LIST
40646: PUSH
40647: LD_INT 0
40649: PUSH
40650: LD_INT 1
40652: PUSH
40653: EMPTY
40654: LIST
40655: LIST
40656: PUSH
40657: LD_INT 1
40659: NEG
40660: PUSH
40661: LD_INT 0
40663: PUSH
40664: EMPTY
40665: LIST
40666: LIST
40667: PUSH
40668: LD_INT 1
40670: NEG
40671: PUSH
40672: LD_INT 1
40674: NEG
40675: PUSH
40676: EMPTY
40677: LIST
40678: LIST
40679: PUSH
40680: EMPTY
40681: LIST
40682: LIST
40683: LIST
40684: LIST
40685: LIST
40686: LIST
40687: LIST
40688: ST_TO_ADDR
// end ; 1 :
40689: GO 46586
40691: LD_INT 1
40693: DOUBLE
40694: EQUAL
40695: IFTRUE 40699
40697: GO 43322
40699: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40700: LD_ADDR_VAR 0 11
40704: PUSH
40705: LD_INT 1
40707: NEG
40708: PUSH
40709: LD_INT 3
40711: NEG
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: LD_INT 0
40719: PUSH
40720: LD_INT 3
40722: NEG
40723: PUSH
40724: EMPTY
40725: LIST
40726: LIST
40727: PUSH
40728: LD_INT 1
40730: PUSH
40731: LD_INT 2
40733: NEG
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: PUSH
40739: EMPTY
40740: LIST
40741: LIST
40742: LIST
40743: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40744: LD_ADDR_VAR 0 12
40748: PUSH
40749: LD_INT 2
40751: PUSH
40752: LD_INT 1
40754: NEG
40755: PUSH
40756: EMPTY
40757: LIST
40758: LIST
40759: PUSH
40760: LD_INT 3
40762: PUSH
40763: LD_INT 0
40765: PUSH
40766: EMPTY
40767: LIST
40768: LIST
40769: PUSH
40770: LD_INT 3
40772: PUSH
40773: LD_INT 1
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: PUSH
40780: EMPTY
40781: LIST
40782: LIST
40783: LIST
40784: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40785: LD_ADDR_VAR 0 13
40789: PUSH
40790: LD_INT 3
40792: PUSH
40793: LD_INT 2
40795: PUSH
40796: EMPTY
40797: LIST
40798: LIST
40799: PUSH
40800: LD_INT 3
40802: PUSH
40803: LD_INT 3
40805: PUSH
40806: EMPTY
40807: LIST
40808: LIST
40809: PUSH
40810: LD_INT 2
40812: PUSH
40813: LD_INT 3
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: PUSH
40820: EMPTY
40821: LIST
40822: LIST
40823: LIST
40824: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40825: LD_ADDR_VAR 0 14
40829: PUSH
40830: LD_INT 1
40832: PUSH
40833: LD_INT 3
40835: PUSH
40836: EMPTY
40837: LIST
40838: LIST
40839: PUSH
40840: LD_INT 0
40842: PUSH
40843: LD_INT 3
40845: PUSH
40846: EMPTY
40847: LIST
40848: LIST
40849: PUSH
40850: LD_INT 1
40852: NEG
40853: PUSH
40854: LD_INT 2
40856: PUSH
40857: EMPTY
40858: LIST
40859: LIST
40860: PUSH
40861: EMPTY
40862: LIST
40863: LIST
40864: LIST
40865: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40866: LD_ADDR_VAR 0 15
40870: PUSH
40871: LD_INT 2
40873: NEG
40874: PUSH
40875: LD_INT 1
40877: PUSH
40878: EMPTY
40879: LIST
40880: LIST
40881: PUSH
40882: LD_INT 3
40884: NEG
40885: PUSH
40886: LD_INT 0
40888: PUSH
40889: EMPTY
40890: LIST
40891: LIST
40892: PUSH
40893: LD_INT 3
40895: NEG
40896: PUSH
40897: LD_INT 1
40899: NEG
40900: PUSH
40901: EMPTY
40902: LIST
40903: LIST
40904: PUSH
40905: EMPTY
40906: LIST
40907: LIST
40908: LIST
40909: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40910: LD_ADDR_VAR 0 16
40914: PUSH
40915: LD_INT 2
40917: NEG
40918: PUSH
40919: LD_INT 3
40921: NEG
40922: PUSH
40923: EMPTY
40924: LIST
40925: LIST
40926: PUSH
40927: LD_INT 3
40929: NEG
40930: PUSH
40931: LD_INT 2
40933: NEG
40934: PUSH
40935: EMPTY
40936: LIST
40937: LIST
40938: PUSH
40939: LD_INT 3
40941: NEG
40942: PUSH
40943: LD_INT 3
40945: NEG
40946: PUSH
40947: EMPTY
40948: LIST
40949: LIST
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: LIST
40955: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40956: LD_ADDR_VAR 0 17
40960: PUSH
40961: LD_INT 1
40963: NEG
40964: PUSH
40965: LD_INT 3
40967: NEG
40968: PUSH
40969: EMPTY
40970: LIST
40971: LIST
40972: PUSH
40973: LD_INT 0
40975: PUSH
40976: LD_INT 3
40978: NEG
40979: PUSH
40980: EMPTY
40981: LIST
40982: LIST
40983: PUSH
40984: LD_INT 1
40986: PUSH
40987: LD_INT 2
40989: NEG
40990: PUSH
40991: EMPTY
40992: LIST
40993: LIST
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: LIST
40999: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41000: LD_ADDR_VAR 0 18
41004: PUSH
41005: LD_INT 2
41007: PUSH
41008: LD_INT 1
41010: NEG
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PUSH
41016: LD_INT 3
41018: PUSH
41019: LD_INT 0
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PUSH
41026: LD_INT 3
41028: PUSH
41029: LD_INT 1
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: EMPTY
41037: LIST
41038: LIST
41039: LIST
41040: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41041: LD_ADDR_VAR 0 19
41045: PUSH
41046: LD_INT 3
41048: PUSH
41049: LD_INT 2
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: PUSH
41056: LD_INT 3
41058: PUSH
41059: LD_INT 3
41061: PUSH
41062: EMPTY
41063: LIST
41064: LIST
41065: PUSH
41066: LD_INT 2
41068: PUSH
41069: LD_INT 3
41071: PUSH
41072: EMPTY
41073: LIST
41074: LIST
41075: PUSH
41076: EMPTY
41077: LIST
41078: LIST
41079: LIST
41080: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41081: LD_ADDR_VAR 0 20
41085: PUSH
41086: LD_INT 1
41088: PUSH
41089: LD_INT 3
41091: PUSH
41092: EMPTY
41093: LIST
41094: LIST
41095: PUSH
41096: LD_INT 0
41098: PUSH
41099: LD_INT 3
41101: PUSH
41102: EMPTY
41103: LIST
41104: LIST
41105: PUSH
41106: LD_INT 1
41108: NEG
41109: PUSH
41110: LD_INT 2
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PUSH
41117: EMPTY
41118: LIST
41119: LIST
41120: LIST
41121: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41122: LD_ADDR_VAR 0 21
41126: PUSH
41127: LD_INT 2
41129: NEG
41130: PUSH
41131: LD_INT 1
41133: PUSH
41134: EMPTY
41135: LIST
41136: LIST
41137: PUSH
41138: LD_INT 3
41140: NEG
41141: PUSH
41142: LD_INT 0
41144: PUSH
41145: EMPTY
41146: LIST
41147: LIST
41148: PUSH
41149: LD_INT 3
41151: NEG
41152: PUSH
41153: LD_INT 1
41155: NEG
41156: PUSH
41157: EMPTY
41158: LIST
41159: LIST
41160: PUSH
41161: EMPTY
41162: LIST
41163: LIST
41164: LIST
41165: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41166: LD_ADDR_VAR 0 22
41170: PUSH
41171: LD_INT 2
41173: NEG
41174: PUSH
41175: LD_INT 3
41177: NEG
41178: PUSH
41179: EMPTY
41180: LIST
41181: LIST
41182: PUSH
41183: LD_INT 3
41185: NEG
41186: PUSH
41187: LD_INT 2
41189: NEG
41190: PUSH
41191: EMPTY
41192: LIST
41193: LIST
41194: PUSH
41195: LD_INT 3
41197: NEG
41198: PUSH
41199: LD_INT 3
41201: NEG
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: PUSH
41207: EMPTY
41208: LIST
41209: LIST
41210: LIST
41211: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41212: LD_ADDR_VAR 0 23
41216: PUSH
41217: LD_INT 0
41219: PUSH
41220: LD_INT 3
41222: NEG
41223: PUSH
41224: EMPTY
41225: LIST
41226: LIST
41227: PUSH
41228: LD_INT 1
41230: NEG
41231: PUSH
41232: LD_INT 4
41234: NEG
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: PUSH
41240: LD_INT 1
41242: PUSH
41243: LD_INT 3
41245: NEG
41246: PUSH
41247: EMPTY
41248: LIST
41249: LIST
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: LIST
41255: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41256: LD_ADDR_VAR 0 24
41260: PUSH
41261: LD_INT 3
41263: PUSH
41264: LD_INT 0
41266: PUSH
41267: EMPTY
41268: LIST
41269: LIST
41270: PUSH
41271: LD_INT 3
41273: PUSH
41274: LD_INT 1
41276: NEG
41277: PUSH
41278: EMPTY
41279: LIST
41280: LIST
41281: PUSH
41282: LD_INT 4
41284: PUSH
41285: LD_INT 1
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: EMPTY
41293: LIST
41294: LIST
41295: LIST
41296: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41297: LD_ADDR_VAR 0 25
41301: PUSH
41302: LD_INT 3
41304: PUSH
41305: LD_INT 3
41307: PUSH
41308: EMPTY
41309: LIST
41310: LIST
41311: PUSH
41312: LD_INT 4
41314: PUSH
41315: LD_INT 3
41317: PUSH
41318: EMPTY
41319: LIST
41320: LIST
41321: PUSH
41322: LD_INT 3
41324: PUSH
41325: LD_INT 4
41327: PUSH
41328: EMPTY
41329: LIST
41330: LIST
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: LIST
41336: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41337: LD_ADDR_VAR 0 26
41341: PUSH
41342: LD_INT 0
41344: PUSH
41345: LD_INT 3
41347: PUSH
41348: EMPTY
41349: LIST
41350: LIST
41351: PUSH
41352: LD_INT 1
41354: PUSH
41355: LD_INT 4
41357: PUSH
41358: EMPTY
41359: LIST
41360: LIST
41361: PUSH
41362: LD_INT 1
41364: NEG
41365: PUSH
41366: LD_INT 3
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: PUSH
41373: EMPTY
41374: LIST
41375: LIST
41376: LIST
41377: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41378: LD_ADDR_VAR 0 27
41382: PUSH
41383: LD_INT 3
41385: NEG
41386: PUSH
41387: LD_INT 0
41389: PUSH
41390: EMPTY
41391: LIST
41392: LIST
41393: PUSH
41394: LD_INT 3
41396: NEG
41397: PUSH
41398: LD_INT 1
41400: PUSH
41401: EMPTY
41402: LIST
41403: LIST
41404: PUSH
41405: LD_INT 4
41407: NEG
41408: PUSH
41409: LD_INT 1
41411: NEG
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: PUSH
41417: EMPTY
41418: LIST
41419: LIST
41420: LIST
41421: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41422: LD_ADDR_VAR 0 28
41426: PUSH
41427: LD_INT 3
41429: NEG
41430: PUSH
41431: LD_INT 3
41433: NEG
41434: PUSH
41435: EMPTY
41436: LIST
41437: LIST
41438: PUSH
41439: LD_INT 3
41441: NEG
41442: PUSH
41443: LD_INT 4
41445: NEG
41446: PUSH
41447: EMPTY
41448: LIST
41449: LIST
41450: PUSH
41451: LD_INT 4
41453: NEG
41454: PUSH
41455: LD_INT 3
41457: NEG
41458: PUSH
41459: EMPTY
41460: LIST
41461: LIST
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: LIST
41467: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41468: LD_ADDR_VAR 0 29
41472: PUSH
41473: LD_INT 1
41475: NEG
41476: PUSH
41477: LD_INT 3
41479: NEG
41480: PUSH
41481: EMPTY
41482: LIST
41483: LIST
41484: PUSH
41485: LD_INT 0
41487: PUSH
41488: LD_INT 3
41490: NEG
41491: PUSH
41492: EMPTY
41493: LIST
41494: LIST
41495: PUSH
41496: LD_INT 1
41498: PUSH
41499: LD_INT 2
41501: NEG
41502: PUSH
41503: EMPTY
41504: LIST
41505: LIST
41506: PUSH
41507: LD_INT 1
41509: NEG
41510: PUSH
41511: LD_INT 4
41513: NEG
41514: PUSH
41515: EMPTY
41516: LIST
41517: LIST
41518: PUSH
41519: LD_INT 0
41521: PUSH
41522: LD_INT 4
41524: NEG
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: LD_INT 1
41532: PUSH
41533: LD_INT 3
41535: NEG
41536: PUSH
41537: EMPTY
41538: LIST
41539: LIST
41540: PUSH
41541: LD_INT 1
41543: NEG
41544: PUSH
41545: LD_INT 5
41547: NEG
41548: PUSH
41549: EMPTY
41550: LIST
41551: LIST
41552: PUSH
41553: LD_INT 0
41555: PUSH
41556: LD_INT 5
41558: NEG
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: PUSH
41564: LD_INT 1
41566: PUSH
41567: LD_INT 4
41569: NEG
41570: PUSH
41571: EMPTY
41572: LIST
41573: LIST
41574: PUSH
41575: LD_INT 1
41577: NEG
41578: PUSH
41579: LD_INT 6
41581: NEG
41582: PUSH
41583: EMPTY
41584: LIST
41585: LIST
41586: PUSH
41587: LD_INT 0
41589: PUSH
41590: LD_INT 6
41592: NEG
41593: PUSH
41594: EMPTY
41595: LIST
41596: LIST
41597: PUSH
41598: LD_INT 1
41600: PUSH
41601: LD_INT 5
41603: NEG
41604: PUSH
41605: EMPTY
41606: LIST
41607: LIST
41608: PUSH
41609: EMPTY
41610: LIST
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: LIST
41616: LIST
41617: LIST
41618: LIST
41619: LIST
41620: LIST
41621: LIST
41622: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41623: LD_ADDR_VAR 0 30
41627: PUSH
41628: LD_INT 2
41630: PUSH
41631: LD_INT 1
41633: NEG
41634: PUSH
41635: EMPTY
41636: LIST
41637: LIST
41638: PUSH
41639: LD_INT 3
41641: PUSH
41642: LD_INT 0
41644: PUSH
41645: EMPTY
41646: LIST
41647: LIST
41648: PUSH
41649: LD_INT 3
41651: PUSH
41652: LD_INT 1
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: PUSH
41659: LD_INT 3
41661: PUSH
41662: LD_INT 1
41664: NEG
41665: PUSH
41666: EMPTY
41667: LIST
41668: LIST
41669: PUSH
41670: LD_INT 4
41672: PUSH
41673: LD_INT 0
41675: PUSH
41676: EMPTY
41677: LIST
41678: LIST
41679: PUSH
41680: LD_INT 4
41682: PUSH
41683: LD_INT 1
41685: PUSH
41686: EMPTY
41687: LIST
41688: LIST
41689: PUSH
41690: LD_INT 4
41692: PUSH
41693: LD_INT 1
41695: NEG
41696: PUSH
41697: EMPTY
41698: LIST
41699: LIST
41700: PUSH
41701: LD_INT 5
41703: PUSH
41704: LD_INT 0
41706: PUSH
41707: EMPTY
41708: LIST
41709: LIST
41710: PUSH
41711: LD_INT 5
41713: PUSH
41714: LD_INT 1
41716: PUSH
41717: EMPTY
41718: LIST
41719: LIST
41720: PUSH
41721: LD_INT 5
41723: PUSH
41724: LD_INT 1
41726: NEG
41727: PUSH
41728: EMPTY
41729: LIST
41730: LIST
41731: PUSH
41732: LD_INT 6
41734: PUSH
41735: LD_INT 0
41737: PUSH
41738: EMPTY
41739: LIST
41740: LIST
41741: PUSH
41742: LD_INT 6
41744: PUSH
41745: LD_INT 1
41747: PUSH
41748: EMPTY
41749: LIST
41750: LIST
41751: PUSH
41752: EMPTY
41753: LIST
41754: LIST
41755: LIST
41756: LIST
41757: LIST
41758: LIST
41759: LIST
41760: LIST
41761: LIST
41762: LIST
41763: LIST
41764: LIST
41765: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41766: LD_ADDR_VAR 0 31
41770: PUSH
41771: LD_INT 3
41773: PUSH
41774: LD_INT 2
41776: PUSH
41777: EMPTY
41778: LIST
41779: LIST
41780: PUSH
41781: LD_INT 3
41783: PUSH
41784: LD_INT 3
41786: PUSH
41787: EMPTY
41788: LIST
41789: LIST
41790: PUSH
41791: LD_INT 2
41793: PUSH
41794: LD_INT 3
41796: PUSH
41797: EMPTY
41798: LIST
41799: LIST
41800: PUSH
41801: LD_INT 4
41803: PUSH
41804: LD_INT 3
41806: PUSH
41807: EMPTY
41808: LIST
41809: LIST
41810: PUSH
41811: LD_INT 4
41813: PUSH
41814: LD_INT 4
41816: PUSH
41817: EMPTY
41818: LIST
41819: LIST
41820: PUSH
41821: LD_INT 3
41823: PUSH
41824: LD_INT 4
41826: PUSH
41827: EMPTY
41828: LIST
41829: LIST
41830: PUSH
41831: LD_INT 5
41833: PUSH
41834: LD_INT 4
41836: PUSH
41837: EMPTY
41838: LIST
41839: LIST
41840: PUSH
41841: LD_INT 5
41843: PUSH
41844: LD_INT 5
41846: PUSH
41847: EMPTY
41848: LIST
41849: LIST
41850: PUSH
41851: LD_INT 4
41853: PUSH
41854: LD_INT 5
41856: PUSH
41857: EMPTY
41858: LIST
41859: LIST
41860: PUSH
41861: LD_INT 6
41863: PUSH
41864: LD_INT 5
41866: PUSH
41867: EMPTY
41868: LIST
41869: LIST
41870: PUSH
41871: LD_INT 6
41873: PUSH
41874: LD_INT 6
41876: PUSH
41877: EMPTY
41878: LIST
41879: LIST
41880: PUSH
41881: LD_INT 5
41883: PUSH
41884: LD_INT 6
41886: PUSH
41887: EMPTY
41888: LIST
41889: LIST
41890: PUSH
41891: EMPTY
41892: LIST
41893: LIST
41894: LIST
41895: LIST
41896: LIST
41897: LIST
41898: LIST
41899: LIST
41900: LIST
41901: LIST
41902: LIST
41903: LIST
41904: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41905: LD_ADDR_VAR 0 32
41909: PUSH
41910: LD_INT 1
41912: PUSH
41913: LD_INT 3
41915: PUSH
41916: EMPTY
41917: LIST
41918: LIST
41919: PUSH
41920: LD_INT 0
41922: PUSH
41923: LD_INT 3
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: LD_INT 1
41932: NEG
41933: PUSH
41934: LD_INT 2
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PUSH
41941: LD_INT 1
41943: PUSH
41944: LD_INT 4
41946: PUSH
41947: EMPTY
41948: LIST
41949: LIST
41950: PUSH
41951: LD_INT 0
41953: PUSH
41954: LD_INT 4
41956: PUSH
41957: EMPTY
41958: LIST
41959: LIST
41960: PUSH
41961: LD_INT 1
41963: NEG
41964: PUSH
41965: LD_INT 3
41967: PUSH
41968: EMPTY
41969: LIST
41970: LIST
41971: PUSH
41972: LD_INT 1
41974: PUSH
41975: LD_INT 5
41977: PUSH
41978: EMPTY
41979: LIST
41980: LIST
41981: PUSH
41982: LD_INT 0
41984: PUSH
41985: LD_INT 5
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: PUSH
41992: LD_INT 1
41994: NEG
41995: PUSH
41996: LD_INT 4
41998: PUSH
41999: EMPTY
42000: LIST
42001: LIST
42002: PUSH
42003: LD_INT 1
42005: PUSH
42006: LD_INT 6
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: PUSH
42013: LD_INT 0
42015: PUSH
42016: LD_INT 6
42018: PUSH
42019: EMPTY
42020: LIST
42021: LIST
42022: PUSH
42023: LD_INT 1
42025: NEG
42026: PUSH
42027: LD_INT 5
42029: PUSH
42030: EMPTY
42031: LIST
42032: LIST
42033: PUSH
42034: EMPTY
42035: LIST
42036: LIST
42037: LIST
42038: LIST
42039: LIST
42040: LIST
42041: LIST
42042: LIST
42043: LIST
42044: LIST
42045: LIST
42046: LIST
42047: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42048: LD_ADDR_VAR 0 33
42052: PUSH
42053: LD_INT 2
42055: NEG
42056: PUSH
42057: LD_INT 1
42059: PUSH
42060: EMPTY
42061: LIST
42062: LIST
42063: PUSH
42064: LD_INT 3
42066: NEG
42067: PUSH
42068: LD_INT 0
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: PUSH
42075: LD_INT 3
42077: NEG
42078: PUSH
42079: LD_INT 1
42081: NEG
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: PUSH
42087: LD_INT 3
42089: NEG
42090: PUSH
42091: LD_INT 1
42093: PUSH
42094: EMPTY
42095: LIST
42096: LIST
42097: PUSH
42098: LD_INT 4
42100: NEG
42101: PUSH
42102: LD_INT 0
42104: PUSH
42105: EMPTY
42106: LIST
42107: LIST
42108: PUSH
42109: LD_INT 4
42111: NEG
42112: PUSH
42113: LD_INT 1
42115: NEG
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 4
42123: NEG
42124: PUSH
42125: LD_INT 1
42127: PUSH
42128: EMPTY
42129: LIST
42130: LIST
42131: PUSH
42132: LD_INT 5
42134: NEG
42135: PUSH
42136: LD_INT 0
42138: PUSH
42139: EMPTY
42140: LIST
42141: LIST
42142: PUSH
42143: LD_INT 5
42145: NEG
42146: PUSH
42147: LD_INT 1
42149: NEG
42150: PUSH
42151: EMPTY
42152: LIST
42153: LIST
42154: PUSH
42155: LD_INT 5
42157: NEG
42158: PUSH
42159: LD_INT 1
42161: PUSH
42162: EMPTY
42163: LIST
42164: LIST
42165: PUSH
42166: LD_INT 6
42168: NEG
42169: PUSH
42170: LD_INT 0
42172: PUSH
42173: EMPTY
42174: LIST
42175: LIST
42176: PUSH
42177: LD_INT 6
42179: NEG
42180: PUSH
42181: LD_INT 1
42183: NEG
42184: PUSH
42185: EMPTY
42186: LIST
42187: LIST
42188: PUSH
42189: EMPTY
42190: LIST
42191: LIST
42192: LIST
42193: LIST
42194: LIST
42195: LIST
42196: LIST
42197: LIST
42198: LIST
42199: LIST
42200: LIST
42201: LIST
42202: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42203: LD_ADDR_VAR 0 34
42207: PUSH
42208: LD_INT 2
42210: NEG
42211: PUSH
42212: LD_INT 3
42214: NEG
42215: PUSH
42216: EMPTY
42217: LIST
42218: LIST
42219: PUSH
42220: LD_INT 3
42222: NEG
42223: PUSH
42224: LD_INT 2
42226: NEG
42227: PUSH
42228: EMPTY
42229: LIST
42230: LIST
42231: PUSH
42232: LD_INT 3
42234: NEG
42235: PUSH
42236: LD_INT 3
42238: NEG
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: PUSH
42244: LD_INT 3
42246: NEG
42247: PUSH
42248: LD_INT 4
42250: NEG
42251: PUSH
42252: EMPTY
42253: LIST
42254: LIST
42255: PUSH
42256: LD_INT 4
42258: NEG
42259: PUSH
42260: LD_INT 3
42262: NEG
42263: PUSH
42264: EMPTY
42265: LIST
42266: LIST
42267: PUSH
42268: LD_INT 4
42270: NEG
42271: PUSH
42272: LD_INT 4
42274: NEG
42275: PUSH
42276: EMPTY
42277: LIST
42278: LIST
42279: PUSH
42280: LD_INT 4
42282: NEG
42283: PUSH
42284: LD_INT 5
42286: NEG
42287: PUSH
42288: EMPTY
42289: LIST
42290: LIST
42291: PUSH
42292: LD_INT 5
42294: NEG
42295: PUSH
42296: LD_INT 4
42298: NEG
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: LD_INT 5
42306: NEG
42307: PUSH
42308: LD_INT 5
42310: NEG
42311: PUSH
42312: EMPTY
42313: LIST
42314: LIST
42315: PUSH
42316: LD_INT 5
42318: NEG
42319: PUSH
42320: LD_INT 6
42322: NEG
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: PUSH
42328: LD_INT 6
42330: NEG
42331: PUSH
42332: LD_INT 5
42334: NEG
42335: PUSH
42336: EMPTY
42337: LIST
42338: LIST
42339: PUSH
42340: LD_INT 6
42342: NEG
42343: PUSH
42344: LD_INT 6
42346: NEG
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: LIST
42356: LIST
42357: LIST
42358: LIST
42359: LIST
42360: LIST
42361: LIST
42362: LIST
42363: LIST
42364: LIST
42365: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42366: LD_ADDR_VAR 0 41
42370: PUSH
42371: LD_INT 0
42373: PUSH
42374: LD_INT 2
42376: NEG
42377: PUSH
42378: EMPTY
42379: LIST
42380: LIST
42381: PUSH
42382: LD_INT 1
42384: NEG
42385: PUSH
42386: LD_INT 3
42388: NEG
42389: PUSH
42390: EMPTY
42391: LIST
42392: LIST
42393: PUSH
42394: LD_INT 1
42396: PUSH
42397: LD_INT 2
42399: NEG
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: LIST
42409: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42410: LD_ADDR_VAR 0 42
42414: PUSH
42415: LD_INT 2
42417: PUSH
42418: LD_INT 0
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: PUSH
42425: LD_INT 2
42427: PUSH
42428: LD_INT 1
42430: NEG
42431: PUSH
42432: EMPTY
42433: LIST
42434: LIST
42435: PUSH
42436: LD_INT 3
42438: PUSH
42439: LD_INT 1
42441: PUSH
42442: EMPTY
42443: LIST
42444: LIST
42445: PUSH
42446: EMPTY
42447: LIST
42448: LIST
42449: LIST
42450: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42451: LD_ADDR_VAR 0 43
42455: PUSH
42456: LD_INT 2
42458: PUSH
42459: LD_INT 2
42461: PUSH
42462: EMPTY
42463: LIST
42464: LIST
42465: PUSH
42466: LD_INT 3
42468: PUSH
42469: LD_INT 2
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: PUSH
42476: LD_INT 2
42478: PUSH
42479: LD_INT 3
42481: PUSH
42482: EMPTY
42483: LIST
42484: LIST
42485: PUSH
42486: EMPTY
42487: LIST
42488: LIST
42489: LIST
42490: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42491: LD_ADDR_VAR 0 44
42495: PUSH
42496: LD_INT 0
42498: PUSH
42499: LD_INT 2
42501: PUSH
42502: EMPTY
42503: LIST
42504: LIST
42505: PUSH
42506: LD_INT 1
42508: PUSH
42509: LD_INT 3
42511: PUSH
42512: EMPTY
42513: LIST
42514: LIST
42515: PUSH
42516: LD_INT 1
42518: NEG
42519: PUSH
42520: LD_INT 2
42522: PUSH
42523: EMPTY
42524: LIST
42525: LIST
42526: PUSH
42527: EMPTY
42528: LIST
42529: LIST
42530: LIST
42531: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42532: LD_ADDR_VAR 0 45
42536: PUSH
42537: LD_INT 2
42539: NEG
42540: PUSH
42541: LD_INT 0
42543: PUSH
42544: EMPTY
42545: LIST
42546: LIST
42547: PUSH
42548: LD_INT 2
42550: NEG
42551: PUSH
42552: LD_INT 1
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: LD_INT 3
42561: NEG
42562: PUSH
42563: LD_INT 1
42565: NEG
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: PUSH
42571: EMPTY
42572: LIST
42573: LIST
42574: LIST
42575: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42576: LD_ADDR_VAR 0 46
42580: PUSH
42581: LD_INT 2
42583: NEG
42584: PUSH
42585: LD_INT 2
42587: NEG
42588: PUSH
42589: EMPTY
42590: LIST
42591: LIST
42592: PUSH
42593: LD_INT 2
42595: NEG
42596: PUSH
42597: LD_INT 3
42599: NEG
42600: PUSH
42601: EMPTY
42602: LIST
42603: LIST
42604: PUSH
42605: LD_INT 3
42607: NEG
42608: PUSH
42609: LD_INT 2
42611: NEG
42612: PUSH
42613: EMPTY
42614: LIST
42615: LIST
42616: PUSH
42617: EMPTY
42618: LIST
42619: LIST
42620: LIST
42621: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42622: LD_ADDR_VAR 0 47
42626: PUSH
42627: LD_INT 2
42629: NEG
42630: PUSH
42631: LD_INT 3
42633: NEG
42634: PUSH
42635: EMPTY
42636: LIST
42637: LIST
42638: PUSH
42639: LD_INT 1
42641: NEG
42642: PUSH
42643: LD_INT 3
42645: NEG
42646: PUSH
42647: EMPTY
42648: LIST
42649: LIST
42650: PUSH
42651: EMPTY
42652: LIST
42653: LIST
42654: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42655: LD_ADDR_VAR 0 48
42659: PUSH
42660: LD_INT 1
42662: PUSH
42663: LD_INT 2
42665: NEG
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: PUSH
42671: LD_INT 2
42673: PUSH
42674: LD_INT 1
42676: NEG
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: PUSH
42682: EMPTY
42683: LIST
42684: LIST
42685: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42686: LD_ADDR_VAR 0 49
42690: PUSH
42691: LD_INT 3
42693: PUSH
42694: LD_INT 1
42696: PUSH
42697: EMPTY
42698: LIST
42699: LIST
42700: PUSH
42701: LD_INT 3
42703: PUSH
42704: LD_INT 2
42706: PUSH
42707: EMPTY
42708: LIST
42709: LIST
42710: PUSH
42711: EMPTY
42712: LIST
42713: LIST
42714: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42715: LD_ADDR_VAR 0 50
42719: PUSH
42720: LD_INT 2
42722: PUSH
42723: LD_INT 3
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: PUSH
42730: LD_INT 1
42732: PUSH
42733: LD_INT 3
42735: PUSH
42736: EMPTY
42737: LIST
42738: LIST
42739: PUSH
42740: EMPTY
42741: LIST
42742: LIST
42743: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42744: LD_ADDR_VAR 0 51
42748: PUSH
42749: LD_INT 1
42751: NEG
42752: PUSH
42753: LD_INT 2
42755: PUSH
42756: EMPTY
42757: LIST
42758: LIST
42759: PUSH
42760: LD_INT 2
42762: NEG
42763: PUSH
42764: LD_INT 1
42766: PUSH
42767: EMPTY
42768: LIST
42769: LIST
42770: PUSH
42771: EMPTY
42772: LIST
42773: LIST
42774: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42775: LD_ADDR_VAR 0 52
42779: PUSH
42780: LD_INT 3
42782: NEG
42783: PUSH
42784: LD_INT 1
42786: NEG
42787: PUSH
42788: EMPTY
42789: LIST
42790: LIST
42791: PUSH
42792: LD_INT 3
42794: NEG
42795: PUSH
42796: LD_INT 2
42798: NEG
42799: PUSH
42800: EMPTY
42801: LIST
42802: LIST
42803: PUSH
42804: EMPTY
42805: LIST
42806: LIST
42807: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42808: LD_ADDR_VAR 0 53
42812: PUSH
42813: LD_INT 1
42815: NEG
42816: PUSH
42817: LD_INT 3
42819: NEG
42820: PUSH
42821: EMPTY
42822: LIST
42823: LIST
42824: PUSH
42825: LD_INT 0
42827: PUSH
42828: LD_INT 3
42830: NEG
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: PUSH
42836: LD_INT 1
42838: PUSH
42839: LD_INT 2
42841: NEG
42842: PUSH
42843: EMPTY
42844: LIST
42845: LIST
42846: PUSH
42847: EMPTY
42848: LIST
42849: LIST
42850: LIST
42851: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42852: LD_ADDR_VAR 0 54
42856: PUSH
42857: LD_INT 2
42859: PUSH
42860: LD_INT 1
42862: NEG
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: PUSH
42868: LD_INT 3
42870: PUSH
42871: LD_INT 0
42873: PUSH
42874: EMPTY
42875: LIST
42876: LIST
42877: PUSH
42878: LD_INT 3
42880: PUSH
42881: LD_INT 1
42883: PUSH
42884: EMPTY
42885: LIST
42886: LIST
42887: PUSH
42888: EMPTY
42889: LIST
42890: LIST
42891: LIST
42892: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42893: LD_ADDR_VAR 0 55
42897: PUSH
42898: LD_INT 3
42900: PUSH
42901: LD_INT 2
42903: PUSH
42904: EMPTY
42905: LIST
42906: LIST
42907: PUSH
42908: LD_INT 3
42910: PUSH
42911: LD_INT 3
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: PUSH
42918: LD_INT 2
42920: PUSH
42921: LD_INT 3
42923: PUSH
42924: EMPTY
42925: LIST
42926: LIST
42927: PUSH
42928: EMPTY
42929: LIST
42930: LIST
42931: LIST
42932: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42933: LD_ADDR_VAR 0 56
42937: PUSH
42938: LD_INT 1
42940: PUSH
42941: LD_INT 3
42943: PUSH
42944: EMPTY
42945: LIST
42946: LIST
42947: PUSH
42948: LD_INT 0
42950: PUSH
42951: LD_INT 3
42953: PUSH
42954: EMPTY
42955: LIST
42956: LIST
42957: PUSH
42958: LD_INT 1
42960: NEG
42961: PUSH
42962: LD_INT 2
42964: PUSH
42965: EMPTY
42966: LIST
42967: LIST
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: LIST
42973: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42974: LD_ADDR_VAR 0 57
42978: PUSH
42979: LD_INT 2
42981: NEG
42982: PUSH
42983: LD_INT 1
42985: PUSH
42986: EMPTY
42987: LIST
42988: LIST
42989: PUSH
42990: LD_INT 3
42992: NEG
42993: PUSH
42994: LD_INT 0
42996: PUSH
42997: EMPTY
42998: LIST
42999: LIST
43000: PUSH
43001: LD_INT 3
43003: NEG
43004: PUSH
43005: LD_INT 1
43007: NEG
43008: PUSH
43009: EMPTY
43010: LIST
43011: LIST
43012: PUSH
43013: EMPTY
43014: LIST
43015: LIST
43016: LIST
43017: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43018: LD_ADDR_VAR 0 58
43022: PUSH
43023: LD_INT 2
43025: NEG
43026: PUSH
43027: LD_INT 3
43029: NEG
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: LD_INT 3
43037: NEG
43038: PUSH
43039: LD_INT 2
43041: NEG
43042: PUSH
43043: EMPTY
43044: LIST
43045: LIST
43046: PUSH
43047: LD_INT 3
43049: NEG
43050: PUSH
43051: LD_INT 3
43053: NEG
43054: PUSH
43055: EMPTY
43056: LIST
43057: LIST
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: LIST
43063: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43064: LD_ADDR_VAR 0 59
43068: PUSH
43069: LD_INT 1
43071: NEG
43072: PUSH
43073: LD_INT 2
43075: NEG
43076: PUSH
43077: EMPTY
43078: LIST
43079: LIST
43080: PUSH
43081: LD_INT 0
43083: PUSH
43084: LD_INT 2
43086: NEG
43087: PUSH
43088: EMPTY
43089: LIST
43090: LIST
43091: PUSH
43092: LD_INT 1
43094: PUSH
43095: LD_INT 1
43097: NEG
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: LIST
43107: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43108: LD_ADDR_VAR 0 60
43112: PUSH
43113: LD_INT 1
43115: PUSH
43116: LD_INT 1
43118: NEG
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: PUSH
43124: LD_INT 2
43126: PUSH
43127: LD_INT 0
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: PUSH
43134: LD_INT 2
43136: PUSH
43137: LD_INT 1
43139: PUSH
43140: EMPTY
43141: LIST
43142: LIST
43143: PUSH
43144: EMPTY
43145: LIST
43146: LIST
43147: LIST
43148: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43149: LD_ADDR_VAR 0 61
43153: PUSH
43154: LD_INT 2
43156: PUSH
43157: LD_INT 1
43159: PUSH
43160: EMPTY
43161: LIST
43162: LIST
43163: PUSH
43164: LD_INT 2
43166: PUSH
43167: LD_INT 2
43169: PUSH
43170: EMPTY
43171: LIST
43172: LIST
43173: PUSH
43174: LD_INT 1
43176: PUSH
43177: LD_INT 2
43179: PUSH
43180: EMPTY
43181: LIST
43182: LIST
43183: PUSH
43184: EMPTY
43185: LIST
43186: LIST
43187: LIST
43188: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43189: LD_ADDR_VAR 0 62
43193: PUSH
43194: LD_INT 1
43196: PUSH
43197: LD_INT 2
43199: PUSH
43200: EMPTY
43201: LIST
43202: LIST
43203: PUSH
43204: LD_INT 0
43206: PUSH
43207: LD_INT 2
43209: PUSH
43210: EMPTY
43211: LIST
43212: LIST
43213: PUSH
43214: LD_INT 1
43216: NEG
43217: PUSH
43218: LD_INT 1
43220: PUSH
43221: EMPTY
43222: LIST
43223: LIST
43224: PUSH
43225: EMPTY
43226: LIST
43227: LIST
43228: LIST
43229: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43230: LD_ADDR_VAR 0 63
43234: PUSH
43235: LD_INT 1
43237: NEG
43238: PUSH
43239: LD_INT 1
43241: PUSH
43242: EMPTY
43243: LIST
43244: LIST
43245: PUSH
43246: LD_INT 2
43248: NEG
43249: PUSH
43250: LD_INT 0
43252: PUSH
43253: EMPTY
43254: LIST
43255: LIST
43256: PUSH
43257: LD_INT 2
43259: NEG
43260: PUSH
43261: LD_INT 1
43263: NEG
43264: PUSH
43265: EMPTY
43266: LIST
43267: LIST
43268: PUSH
43269: EMPTY
43270: LIST
43271: LIST
43272: LIST
43273: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43274: LD_ADDR_VAR 0 64
43278: PUSH
43279: LD_INT 1
43281: NEG
43282: PUSH
43283: LD_INT 2
43285: NEG
43286: PUSH
43287: EMPTY
43288: LIST
43289: LIST
43290: PUSH
43291: LD_INT 2
43293: NEG
43294: PUSH
43295: LD_INT 1
43297: NEG
43298: PUSH
43299: EMPTY
43300: LIST
43301: LIST
43302: PUSH
43303: LD_INT 2
43305: NEG
43306: PUSH
43307: LD_INT 2
43309: NEG
43310: PUSH
43311: EMPTY
43312: LIST
43313: LIST
43314: PUSH
43315: EMPTY
43316: LIST
43317: LIST
43318: LIST
43319: ST_TO_ADDR
// end ; 2 :
43320: GO 46586
43322: LD_INT 2
43324: DOUBLE
43325: EQUAL
43326: IFTRUE 43330
43328: GO 46585
43330: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43331: LD_ADDR_VAR 0 29
43335: PUSH
43336: LD_INT 4
43338: PUSH
43339: LD_INT 0
43341: PUSH
43342: EMPTY
43343: LIST
43344: LIST
43345: PUSH
43346: LD_INT 4
43348: PUSH
43349: LD_INT 1
43351: NEG
43352: PUSH
43353: EMPTY
43354: LIST
43355: LIST
43356: PUSH
43357: LD_INT 5
43359: PUSH
43360: LD_INT 0
43362: PUSH
43363: EMPTY
43364: LIST
43365: LIST
43366: PUSH
43367: LD_INT 5
43369: PUSH
43370: LD_INT 1
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: LD_INT 4
43379: PUSH
43380: LD_INT 1
43382: PUSH
43383: EMPTY
43384: LIST
43385: LIST
43386: PUSH
43387: LD_INT 3
43389: PUSH
43390: LD_INT 0
43392: PUSH
43393: EMPTY
43394: LIST
43395: LIST
43396: PUSH
43397: LD_INT 3
43399: PUSH
43400: LD_INT 1
43402: NEG
43403: PUSH
43404: EMPTY
43405: LIST
43406: LIST
43407: PUSH
43408: LD_INT 3
43410: PUSH
43411: LD_INT 2
43413: NEG
43414: PUSH
43415: EMPTY
43416: LIST
43417: LIST
43418: PUSH
43419: LD_INT 5
43421: PUSH
43422: LD_INT 2
43424: PUSH
43425: EMPTY
43426: LIST
43427: LIST
43428: PUSH
43429: LD_INT 3
43431: PUSH
43432: LD_INT 3
43434: PUSH
43435: EMPTY
43436: LIST
43437: LIST
43438: PUSH
43439: LD_INT 3
43441: PUSH
43442: LD_INT 2
43444: PUSH
43445: EMPTY
43446: LIST
43447: LIST
43448: PUSH
43449: LD_INT 4
43451: PUSH
43452: LD_INT 3
43454: PUSH
43455: EMPTY
43456: LIST
43457: LIST
43458: PUSH
43459: LD_INT 4
43461: PUSH
43462: LD_INT 4
43464: PUSH
43465: EMPTY
43466: LIST
43467: LIST
43468: PUSH
43469: LD_INT 3
43471: PUSH
43472: LD_INT 4
43474: PUSH
43475: EMPTY
43476: LIST
43477: LIST
43478: PUSH
43479: LD_INT 2
43481: PUSH
43482: LD_INT 3
43484: PUSH
43485: EMPTY
43486: LIST
43487: LIST
43488: PUSH
43489: LD_INT 2
43491: PUSH
43492: LD_INT 2
43494: PUSH
43495: EMPTY
43496: LIST
43497: LIST
43498: PUSH
43499: LD_INT 4
43501: PUSH
43502: LD_INT 2
43504: PUSH
43505: EMPTY
43506: LIST
43507: LIST
43508: PUSH
43509: LD_INT 2
43511: PUSH
43512: LD_INT 4
43514: PUSH
43515: EMPTY
43516: LIST
43517: LIST
43518: PUSH
43519: LD_INT 0
43521: PUSH
43522: LD_INT 4
43524: PUSH
43525: EMPTY
43526: LIST
43527: LIST
43528: PUSH
43529: LD_INT 0
43531: PUSH
43532: LD_INT 3
43534: PUSH
43535: EMPTY
43536: LIST
43537: LIST
43538: PUSH
43539: LD_INT 1
43541: PUSH
43542: LD_INT 4
43544: PUSH
43545: EMPTY
43546: LIST
43547: LIST
43548: PUSH
43549: LD_INT 1
43551: PUSH
43552: LD_INT 5
43554: PUSH
43555: EMPTY
43556: LIST
43557: LIST
43558: PUSH
43559: LD_INT 0
43561: PUSH
43562: LD_INT 5
43564: PUSH
43565: EMPTY
43566: LIST
43567: LIST
43568: PUSH
43569: LD_INT 1
43571: NEG
43572: PUSH
43573: LD_INT 4
43575: PUSH
43576: EMPTY
43577: LIST
43578: LIST
43579: PUSH
43580: LD_INT 1
43582: NEG
43583: PUSH
43584: LD_INT 3
43586: PUSH
43587: EMPTY
43588: LIST
43589: LIST
43590: PUSH
43591: LD_INT 2
43593: PUSH
43594: LD_INT 5
43596: PUSH
43597: EMPTY
43598: LIST
43599: LIST
43600: PUSH
43601: LD_INT 2
43603: NEG
43604: PUSH
43605: LD_INT 3
43607: PUSH
43608: EMPTY
43609: LIST
43610: LIST
43611: PUSH
43612: LD_INT 3
43614: NEG
43615: PUSH
43616: LD_INT 0
43618: PUSH
43619: EMPTY
43620: LIST
43621: LIST
43622: PUSH
43623: LD_INT 3
43625: NEG
43626: PUSH
43627: LD_INT 1
43629: NEG
43630: PUSH
43631: EMPTY
43632: LIST
43633: LIST
43634: PUSH
43635: LD_INT 2
43637: NEG
43638: PUSH
43639: LD_INT 0
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: PUSH
43646: LD_INT 2
43648: NEG
43649: PUSH
43650: LD_INT 1
43652: PUSH
43653: EMPTY
43654: LIST
43655: LIST
43656: PUSH
43657: LD_INT 3
43659: NEG
43660: PUSH
43661: LD_INT 1
43663: PUSH
43664: EMPTY
43665: LIST
43666: LIST
43667: PUSH
43668: LD_INT 4
43670: NEG
43671: PUSH
43672: LD_INT 0
43674: PUSH
43675: EMPTY
43676: LIST
43677: LIST
43678: PUSH
43679: LD_INT 4
43681: NEG
43682: PUSH
43683: LD_INT 1
43685: NEG
43686: PUSH
43687: EMPTY
43688: LIST
43689: LIST
43690: PUSH
43691: LD_INT 4
43693: NEG
43694: PUSH
43695: LD_INT 2
43697: NEG
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: PUSH
43703: LD_INT 2
43705: NEG
43706: PUSH
43707: LD_INT 2
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: LD_INT 4
43716: NEG
43717: PUSH
43718: LD_INT 4
43720: NEG
43721: PUSH
43722: EMPTY
43723: LIST
43724: LIST
43725: PUSH
43726: LD_INT 4
43728: NEG
43729: PUSH
43730: LD_INT 5
43732: NEG
43733: PUSH
43734: EMPTY
43735: LIST
43736: LIST
43737: PUSH
43738: LD_INT 3
43740: NEG
43741: PUSH
43742: LD_INT 4
43744: NEG
43745: PUSH
43746: EMPTY
43747: LIST
43748: LIST
43749: PUSH
43750: LD_INT 3
43752: NEG
43753: PUSH
43754: LD_INT 3
43756: NEG
43757: PUSH
43758: EMPTY
43759: LIST
43760: LIST
43761: PUSH
43762: LD_INT 4
43764: NEG
43765: PUSH
43766: LD_INT 3
43768: NEG
43769: PUSH
43770: EMPTY
43771: LIST
43772: LIST
43773: PUSH
43774: LD_INT 5
43776: NEG
43777: PUSH
43778: LD_INT 4
43780: NEG
43781: PUSH
43782: EMPTY
43783: LIST
43784: LIST
43785: PUSH
43786: LD_INT 5
43788: NEG
43789: PUSH
43790: LD_INT 5
43792: NEG
43793: PUSH
43794: EMPTY
43795: LIST
43796: LIST
43797: PUSH
43798: LD_INT 3
43800: NEG
43801: PUSH
43802: LD_INT 5
43804: NEG
43805: PUSH
43806: EMPTY
43807: LIST
43808: LIST
43809: PUSH
43810: LD_INT 5
43812: NEG
43813: PUSH
43814: LD_INT 3
43816: NEG
43817: PUSH
43818: EMPTY
43819: LIST
43820: LIST
43821: PUSH
43822: EMPTY
43823: LIST
43824: LIST
43825: LIST
43826: LIST
43827: LIST
43828: LIST
43829: LIST
43830: LIST
43831: LIST
43832: LIST
43833: LIST
43834: LIST
43835: LIST
43836: LIST
43837: LIST
43838: LIST
43839: LIST
43840: LIST
43841: LIST
43842: LIST
43843: LIST
43844: LIST
43845: LIST
43846: LIST
43847: LIST
43848: LIST
43849: LIST
43850: LIST
43851: LIST
43852: LIST
43853: LIST
43854: LIST
43855: LIST
43856: LIST
43857: LIST
43858: LIST
43859: LIST
43860: LIST
43861: LIST
43862: LIST
43863: LIST
43864: LIST
43865: LIST
43866: LIST
43867: LIST
43868: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43869: LD_ADDR_VAR 0 30
43873: PUSH
43874: LD_INT 4
43876: PUSH
43877: LD_INT 4
43879: PUSH
43880: EMPTY
43881: LIST
43882: LIST
43883: PUSH
43884: LD_INT 4
43886: PUSH
43887: LD_INT 3
43889: PUSH
43890: EMPTY
43891: LIST
43892: LIST
43893: PUSH
43894: LD_INT 5
43896: PUSH
43897: LD_INT 4
43899: PUSH
43900: EMPTY
43901: LIST
43902: LIST
43903: PUSH
43904: LD_INT 5
43906: PUSH
43907: LD_INT 5
43909: PUSH
43910: EMPTY
43911: LIST
43912: LIST
43913: PUSH
43914: LD_INT 4
43916: PUSH
43917: LD_INT 5
43919: PUSH
43920: EMPTY
43921: LIST
43922: LIST
43923: PUSH
43924: LD_INT 3
43926: PUSH
43927: LD_INT 4
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: PUSH
43934: LD_INT 3
43936: PUSH
43937: LD_INT 3
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: LD_INT 5
43946: PUSH
43947: LD_INT 3
43949: PUSH
43950: EMPTY
43951: LIST
43952: LIST
43953: PUSH
43954: LD_INT 3
43956: PUSH
43957: LD_INT 5
43959: PUSH
43960: EMPTY
43961: LIST
43962: LIST
43963: PUSH
43964: LD_INT 0
43966: PUSH
43967: LD_INT 3
43969: PUSH
43970: EMPTY
43971: LIST
43972: LIST
43973: PUSH
43974: LD_INT 0
43976: PUSH
43977: LD_INT 2
43979: PUSH
43980: EMPTY
43981: LIST
43982: LIST
43983: PUSH
43984: LD_INT 1
43986: PUSH
43987: LD_INT 3
43989: PUSH
43990: EMPTY
43991: LIST
43992: LIST
43993: PUSH
43994: LD_INT 1
43996: PUSH
43997: LD_INT 4
43999: PUSH
44000: EMPTY
44001: LIST
44002: LIST
44003: PUSH
44004: LD_INT 0
44006: PUSH
44007: LD_INT 4
44009: PUSH
44010: EMPTY
44011: LIST
44012: LIST
44013: PUSH
44014: LD_INT 1
44016: NEG
44017: PUSH
44018: LD_INT 3
44020: PUSH
44021: EMPTY
44022: LIST
44023: LIST
44024: PUSH
44025: LD_INT 1
44027: NEG
44028: PUSH
44029: LD_INT 2
44031: PUSH
44032: EMPTY
44033: LIST
44034: LIST
44035: PUSH
44036: LD_INT 2
44038: PUSH
44039: LD_INT 4
44041: PUSH
44042: EMPTY
44043: LIST
44044: LIST
44045: PUSH
44046: LD_INT 2
44048: NEG
44049: PUSH
44050: LD_INT 2
44052: PUSH
44053: EMPTY
44054: LIST
44055: LIST
44056: PUSH
44057: LD_INT 4
44059: NEG
44060: PUSH
44061: LD_INT 0
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: PUSH
44068: LD_INT 4
44070: NEG
44071: PUSH
44072: LD_INT 1
44074: NEG
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PUSH
44080: LD_INT 3
44082: NEG
44083: PUSH
44084: LD_INT 0
44086: PUSH
44087: EMPTY
44088: LIST
44089: LIST
44090: PUSH
44091: LD_INT 3
44093: NEG
44094: PUSH
44095: LD_INT 1
44097: PUSH
44098: EMPTY
44099: LIST
44100: LIST
44101: PUSH
44102: LD_INT 4
44104: NEG
44105: PUSH
44106: LD_INT 1
44108: PUSH
44109: EMPTY
44110: LIST
44111: LIST
44112: PUSH
44113: LD_INT 5
44115: NEG
44116: PUSH
44117: LD_INT 0
44119: PUSH
44120: EMPTY
44121: LIST
44122: LIST
44123: PUSH
44124: LD_INT 5
44126: NEG
44127: PUSH
44128: LD_INT 1
44130: NEG
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: PUSH
44136: LD_INT 5
44138: NEG
44139: PUSH
44140: LD_INT 2
44142: NEG
44143: PUSH
44144: EMPTY
44145: LIST
44146: LIST
44147: PUSH
44148: LD_INT 3
44150: NEG
44151: PUSH
44152: LD_INT 2
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PUSH
44159: LD_INT 3
44161: NEG
44162: PUSH
44163: LD_INT 3
44165: NEG
44166: PUSH
44167: EMPTY
44168: LIST
44169: LIST
44170: PUSH
44171: LD_INT 3
44173: NEG
44174: PUSH
44175: LD_INT 4
44177: NEG
44178: PUSH
44179: EMPTY
44180: LIST
44181: LIST
44182: PUSH
44183: LD_INT 2
44185: NEG
44186: PUSH
44187: LD_INT 3
44189: NEG
44190: PUSH
44191: EMPTY
44192: LIST
44193: LIST
44194: PUSH
44195: LD_INT 2
44197: NEG
44198: PUSH
44199: LD_INT 2
44201: NEG
44202: PUSH
44203: EMPTY
44204: LIST
44205: LIST
44206: PUSH
44207: LD_INT 3
44209: NEG
44210: PUSH
44211: LD_INT 2
44213: NEG
44214: PUSH
44215: EMPTY
44216: LIST
44217: LIST
44218: PUSH
44219: LD_INT 4
44221: NEG
44222: PUSH
44223: LD_INT 3
44225: NEG
44226: PUSH
44227: EMPTY
44228: LIST
44229: LIST
44230: PUSH
44231: LD_INT 4
44233: NEG
44234: PUSH
44235: LD_INT 4
44237: NEG
44238: PUSH
44239: EMPTY
44240: LIST
44241: LIST
44242: PUSH
44243: LD_INT 2
44245: NEG
44246: PUSH
44247: LD_INT 4
44249: NEG
44250: PUSH
44251: EMPTY
44252: LIST
44253: LIST
44254: PUSH
44255: LD_INT 4
44257: NEG
44258: PUSH
44259: LD_INT 2
44261: NEG
44262: PUSH
44263: EMPTY
44264: LIST
44265: LIST
44266: PUSH
44267: LD_INT 0
44269: PUSH
44270: LD_INT 4
44272: NEG
44273: PUSH
44274: EMPTY
44275: LIST
44276: LIST
44277: PUSH
44278: LD_INT 0
44280: PUSH
44281: LD_INT 5
44283: NEG
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: PUSH
44289: LD_INT 1
44291: PUSH
44292: LD_INT 4
44294: NEG
44295: PUSH
44296: EMPTY
44297: LIST
44298: LIST
44299: PUSH
44300: LD_INT 1
44302: PUSH
44303: LD_INT 3
44305: NEG
44306: PUSH
44307: EMPTY
44308: LIST
44309: LIST
44310: PUSH
44311: LD_INT 0
44313: PUSH
44314: LD_INT 3
44316: NEG
44317: PUSH
44318: EMPTY
44319: LIST
44320: LIST
44321: PUSH
44322: LD_INT 1
44324: NEG
44325: PUSH
44326: LD_INT 4
44328: NEG
44329: PUSH
44330: EMPTY
44331: LIST
44332: LIST
44333: PUSH
44334: LD_INT 1
44336: NEG
44337: PUSH
44338: LD_INT 5
44340: NEG
44341: PUSH
44342: EMPTY
44343: LIST
44344: LIST
44345: PUSH
44346: LD_INT 2
44348: PUSH
44349: LD_INT 3
44351: NEG
44352: PUSH
44353: EMPTY
44354: LIST
44355: LIST
44356: PUSH
44357: LD_INT 2
44359: NEG
44360: PUSH
44361: LD_INT 5
44363: NEG
44364: PUSH
44365: EMPTY
44366: LIST
44367: LIST
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: LIST
44373: LIST
44374: LIST
44375: LIST
44376: LIST
44377: LIST
44378: LIST
44379: LIST
44380: LIST
44381: LIST
44382: LIST
44383: LIST
44384: LIST
44385: LIST
44386: LIST
44387: LIST
44388: LIST
44389: LIST
44390: LIST
44391: LIST
44392: LIST
44393: LIST
44394: LIST
44395: LIST
44396: LIST
44397: LIST
44398: LIST
44399: LIST
44400: LIST
44401: LIST
44402: LIST
44403: LIST
44404: LIST
44405: LIST
44406: LIST
44407: LIST
44408: LIST
44409: LIST
44410: LIST
44411: LIST
44412: LIST
44413: LIST
44414: LIST
44415: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44416: LD_ADDR_VAR 0 31
44420: PUSH
44421: LD_INT 0
44423: PUSH
44424: LD_INT 4
44426: PUSH
44427: EMPTY
44428: LIST
44429: LIST
44430: PUSH
44431: LD_INT 0
44433: PUSH
44434: LD_INT 3
44436: PUSH
44437: EMPTY
44438: LIST
44439: LIST
44440: PUSH
44441: LD_INT 1
44443: PUSH
44444: LD_INT 4
44446: PUSH
44447: EMPTY
44448: LIST
44449: LIST
44450: PUSH
44451: LD_INT 1
44453: PUSH
44454: LD_INT 5
44456: PUSH
44457: EMPTY
44458: LIST
44459: LIST
44460: PUSH
44461: LD_INT 0
44463: PUSH
44464: LD_INT 5
44466: PUSH
44467: EMPTY
44468: LIST
44469: LIST
44470: PUSH
44471: LD_INT 1
44473: NEG
44474: PUSH
44475: LD_INT 4
44477: PUSH
44478: EMPTY
44479: LIST
44480: LIST
44481: PUSH
44482: LD_INT 1
44484: NEG
44485: PUSH
44486: LD_INT 3
44488: PUSH
44489: EMPTY
44490: LIST
44491: LIST
44492: PUSH
44493: LD_INT 2
44495: PUSH
44496: LD_INT 5
44498: PUSH
44499: EMPTY
44500: LIST
44501: LIST
44502: PUSH
44503: LD_INT 2
44505: NEG
44506: PUSH
44507: LD_INT 3
44509: PUSH
44510: EMPTY
44511: LIST
44512: LIST
44513: PUSH
44514: LD_INT 3
44516: NEG
44517: PUSH
44518: LD_INT 0
44520: PUSH
44521: EMPTY
44522: LIST
44523: LIST
44524: PUSH
44525: LD_INT 3
44527: NEG
44528: PUSH
44529: LD_INT 1
44531: NEG
44532: PUSH
44533: EMPTY
44534: LIST
44535: LIST
44536: PUSH
44537: LD_INT 2
44539: NEG
44540: PUSH
44541: LD_INT 0
44543: PUSH
44544: EMPTY
44545: LIST
44546: LIST
44547: PUSH
44548: LD_INT 2
44550: NEG
44551: PUSH
44552: LD_INT 1
44554: PUSH
44555: EMPTY
44556: LIST
44557: LIST
44558: PUSH
44559: LD_INT 3
44561: NEG
44562: PUSH
44563: LD_INT 1
44565: PUSH
44566: EMPTY
44567: LIST
44568: LIST
44569: PUSH
44570: LD_INT 4
44572: NEG
44573: PUSH
44574: LD_INT 0
44576: PUSH
44577: EMPTY
44578: LIST
44579: LIST
44580: PUSH
44581: LD_INT 4
44583: NEG
44584: PUSH
44585: LD_INT 1
44587: NEG
44588: PUSH
44589: EMPTY
44590: LIST
44591: LIST
44592: PUSH
44593: LD_INT 4
44595: NEG
44596: PUSH
44597: LD_INT 2
44599: NEG
44600: PUSH
44601: EMPTY
44602: LIST
44603: LIST
44604: PUSH
44605: LD_INT 2
44607: NEG
44608: PUSH
44609: LD_INT 2
44611: PUSH
44612: EMPTY
44613: LIST
44614: LIST
44615: PUSH
44616: LD_INT 4
44618: NEG
44619: PUSH
44620: LD_INT 4
44622: NEG
44623: PUSH
44624: EMPTY
44625: LIST
44626: LIST
44627: PUSH
44628: LD_INT 4
44630: NEG
44631: PUSH
44632: LD_INT 5
44634: NEG
44635: PUSH
44636: EMPTY
44637: LIST
44638: LIST
44639: PUSH
44640: LD_INT 3
44642: NEG
44643: PUSH
44644: LD_INT 4
44646: NEG
44647: PUSH
44648: EMPTY
44649: LIST
44650: LIST
44651: PUSH
44652: LD_INT 3
44654: NEG
44655: PUSH
44656: LD_INT 3
44658: NEG
44659: PUSH
44660: EMPTY
44661: LIST
44662: LIST
44663: PUSH
44664: LD_INT 4
44666: NEG
44667: PUSH
44668: LD_INT 3
44670: NEG
44671: PUSH
44672: EMPTY
44673: LIST
44674: LIST
44675: PUSH
44676: LD_INT 5
44678: NEG
44679: PUSH
44680: LD_INT 4
44682: NEG
44683: PUSH
44684: EMPTY
44685: LIST
44686: LIST
44687: PUSH
44688: LD_INT 5
44690: NEG
44691: PUSH
44692: LD_INT 5
44694: NEG
44695: PUSH
44696: EMPTY
44697: LIST
44698: LIST
44699: PUSH
44700: LD_INT 3
44702: NEG
44703: PUSH
44704: LD_INT 5
44706: NEG
44707: PUSH
44708: EMPTY
44709: LIST
44710: LIST
44711: PUSH
44712: LD_INT 5
44714: NEG
44715: PUSH
44716: LD_INT 3
44718: NEG
44719: PUSH
44720: EMPTY
44721: LIST
44722: LIST
44723: PUSH
44724: LD_INT 0
44726: PUSH
44727: LD_INT 3
44729: NEG
44730: PUSH
44731: EMPTY
44732: LIST
44733: LIST
44734: PUSH
44735: LD_INT 0
44737: PUSH
44738: LD_INT 4
44740: NEG
44741: PUSH
44742: EMPTY
44743: LIST
44744: LIST
44745: PUSH
44746: LD_INT 1
44748: PUSH
44749: LD_INT 3
44751: NEG
44752: PUSH
44753: EMPTY
44754: LIST
44755: LIST
44756: PUSH
44757: LD_INT 1
44759: PUSH
44760: LD_INT 2
44762: NEG
44763: PUSH
44764: EMPTY
44765: LIST
44766: LIST
44767: PUSH
44768: LD_INT 0
44770: PUSH
44771: LD_INT 2
44773: NEG
44774: PUSH
44775: EMPTY
44776: LIST
44777: LIST
44778: PUSH
44779: LD_INT 1
44781: NEG
44782: PUSH
44783: LD_INT 3
44785: NEG
44786: PUSH
44787: EMPTY
44788: LIST
44789: LIST
44790: PUSH
44791: LD_INT 1
44793: NEG
44794: PUSH
44795: LD_INT 4
44797: NEG
44798: PUSH
44799: EMPTY
44800: LIST
44801: LIST
44802: PUSH
44803: LD_INT 2
44805: PUSH
44806: LD_INT 2
44808: NEG
44809: PUSH
44810: EMPTY
44811: LIST
44812: LIST
44813: PUSH
44814: LD_INT 2
44816: NEG
44817: PUSH
44818: LD_INT 4
44820: NEG
44821: PUSH
44822: EMPTY
44823: LIST
44824: LIST
44825: PUSH
44826: LD_INT 4
44828: PUSH
44829: LD_INT 0
44831: PUSH
44832: EMPTY
44833: LIST
44834: LIST
44835: PUSH
44836: LD_INT 4
44838: PUSH
44839: LD_INT 1
44841: NEG
44842: PUSH
44843: EMPTY
44844: LIST
44845: LIST
44846: PUSH
44847: LD_INT 5
44849: PUSH
44850: LD_INT 0
44852: PUSH
44853: EMPTY
44854: LIST
44855: LIST
44856: PUSH
44857: LD_INT 5
44859: PUSH
44860: LD_INT 1
44862: PUSH
44863: EMPTY
44864: LIST
44865: LIST
44866: PUSH
44867: LD_INT 4
44869: PUSH
44870: LD_INT 1
44872: PUSH
44873: EMPTY
44874: LIST
44875: LIST
44876: PUSH
44877: LD_INT 3
44879: PUSH
44880: LD_INT 0
44882: PUSH
44883: EMPTY
44884: LIST
44885: LIST
44886: PUSH
44887: LD_INT 3
44889: PUSH
44890: LD_INT 1
44892: NEG
44893: PUSH
44894: EMPTY
44895: LIST
44896: LIST
44897: PUSH
44898: LD_INT 3
44900: PUSH
44901: LD_INT 2
44903: NEG
44904: PUSH
44905: EMPTY
44906: LIST
44907: LIST
44908: PUSH
44909: LD_INT 5
44911: PUSH
44912: LD_INT 2
44914: PUSH
44915: EMPTY
44916: LIST
44917: LIST
44918: PUSH
44919: EMPTY
44920: LIST
44921: LIST
44922: LIST
44923: LIST
44924: LIST
44925: LIST
44926: LIST
44927: LIST
44928: LIST
44929: LIST
44930: LIST
44931: LIST
44932: LIST
44933: LIST
44934: LIST
44935: LIST
44936: LIST
44937: LIST
44938: LIST
44939: LIST
44940: LIST
44941: LIST
44942: LIST
44943: LIST
44944: LIST
44945: LIST
44946: LIST
44947: LIST
44948: LIST
44949: LIST
44950: LIST
44951: LIST
44952: LIST
44953: LIST
44954: LIST
44955: LIST
44956: LIST
44957: LIST
44958: LIST
44959: LIST
44960: LIST
44961: LIST
44962: LIST
44963: LIST
44964: LIST
44965: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44966: LD_ADDR_VAR 0 32
44970: PUSH
44971: LD_INT 4
44973: NEG
44974: PUSH
44975: LD_INT 0
44977: PUSH
44978: EMPTY
44979: LIST
44980: LIST
44981: PUSH
44982: LD_INT 4
44984: NEG
44985: PUSH
44986: LD_INT 1
44988: NEG
44989: PUSH
44990: EMPTY
44991: LIST
44992: LIST
44993: PUSH
44994: LD_INT 3
44996: NEG
44997: PUSH
44998: LD_INT 0
45000: PUSH
45001: EMPTY
45002: LIST
45003: LIST
45004: PUSH
45005: LD_INT 3
45007: NEG
45008: PUSH
45009: LD_INT 1
45011: PUSH
45012: EMPTY
45013: LIST
45014: LIST
45015: PUSH
45016: LD_INT 4
45018: NEG
45019: PUSH
45020: LD_INT 1
45022: PUSH
45023: EMPTY
45024: LIST
45025: LIST
45026: PUSH
45027: LD_INT 5
45029: NEG
45030: PUSH
45031: LD_INT 0
45033: PUSH
45034: EMPTY
45035: LIST
45036: LIST
45037: PUSH
45038: LD_INT 5
45040: NEG
45041: PUSH
45042: LD_INT 1
45044: NEG
45045: PUSH
45046: EMPTY
45047: LIST
45048: LIST
45049: PUSH
45050: LD_INT 5
45052: NEG
45053: PUSH
45054: LD_INT 2
45056: NEG
45057: PUSH
45058: EMPTY
45059: LIST
45060: LIST
45061: PUSH
45062: LD_INT 3
45064: NEG
45065: PUSH
45066: LD_INT 2
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: PUSH
45073: LD_INT 3
45075: NEG
45076: PUSH
45077: LD_INT 3
45079: NEG
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: PUSH
45085: LD_INT 3
45087: NEG
45088: PUSH
45089: LD_INT 4
45091: NEG
45092: PUSH
45093: EMPTY
45094: LIST
45095: LIST
45096: PUSH
45097: LD_INT 2
45099: NEG
45100: PUSH
45101: LD_INT 3
45103: NEG
45104: PUSH
45105: EMPTY
45106: LIST
45107: LIST
45108: PUSH
45109: LD_INT 2
45111: NEG
45112: PUSH
45113: LD_INT 2
45115: NEG
45116: PUSH
45117: EMPTY
45118: LIST
45119: LIST
45120: PUSH
45121: LD_INT 3
45123: NEG
45124: PUSH
45125: LD_INT 2
45127: NEG
45128: PUSH
45129: EMPTY
45130: LIST
45131: LIST
45132: PUSH
45133: LD_INT 4
45135: NEG
45136: PUSH
45137: LD_INT 3
45139: NEG
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: LD_INT 4
45147: NEG
45148: PUSH
45149: LD_INT 4
45151: NEG
45152: PUSH
45153: EMPTY
45154: LIST
45155: LIST
45156: PUSH
45157: LD_INT 2
45159: NEG
45160: PUSH
45161: LD_INT 4
45163: NEG
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: PUSH
45169: LD_INT 4
45171: NEG
45172: PUSH
45173: LD_INT 2
45175: NEG
45176: PUSH
45177: EMPTY
45178: LIST
45179: LIST
45180: PUSH
45181: LD_INT 0
45183: PUSH
45184: LD_INT 4
45186: NEG
45187: PUSH
45188: EMPTY
45189: LIST
45190: LIST
45191: PUSH
45192: LD_INT 0
45194: PUSH
45195: LD_INT 5
45197: NEG
45198: PUSH
45199: EMPTY
45200: LIST
45201: LIST
45202: PUSH
45203: LD_INT 1
45205: PUSH
45206: LD_INT 4
45208: NEG
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: PUSH
45214: LD_INT 1
45216: PUSH
45217: LD_INT 3
45219: NEG
45220: PUSH
45221: EMPTY
45222: LIST
45223: LIST
45224: PUSH
45225: LD_INT 0
45227: PUSH
45228: LD_INT 3
45230: NEG
45231: PUSH
45232: EMPTY
45233: LIST
45234: LIST
45235: PUSH
45236: LD_INT 1
45238: NEG
45239: PUSH
45240: LD_INT 4
45242: NEG
45243: PUSH
45244: EMPTY
45245: LIST
45246: LIST
45247: PUSH
45248: LD_INT 1
45250: NEG
45251: PUSH
45252: LD_INT 5
45254: NEG
45255: PUSH
45256: EMPTY
45257: LIST
45258: LIST
45259: PUSH
45260: LD_INT 2
45262: PUSH
45263: LD_INT 3
45265: NEG
45266: PUSH
45267: EMPTY
45268: LIST
45269: LIST
45270: PUSH
45271: LD_INT 2
45273: NEG
45274: PUSH
45275: LD_INT 5
45277: NEG
45278: PUSH
45279: EMPTY
45280: LIST
45281: LIST
45282: PUSH
45283: LD_INT 3
45285: PUSH
45286: LD_INT 0
45288: PUSH
45289: EMPTY
45290: LIST
45291: LIST
45292: PUSH
45293: LD_INT 3
45295: PUSH
45296: LD_INT 1
45298: NEG
45299: PUSH
45300: EMPTY
45301: LIST
45302: LIST
45303: PUSH
45304: LD_INT 4
45306: PUSH
45307: LD_INT 0
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: PUSH
45314: LD_INT 4
45316: PUSH
45317: LD_INT 1
45319: PUSH
45320: EMPTY
45321: LIST
45322: LIST
45323: PUSH
45324: LD_INT 3
45326: PUSH
45327: LD_INT 1
45329: PUSH
45330: EMPTY
45331: LIST
45332: LIST
45333: PUSH
45334: LD_INT 2
45336: PUSH
45337: LD_INT 0
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: PUSH
45344: LD_INT 2
45346: PUSH
45347: LD_INT 1
45349: NEG
45350: PUSH
45351: EMPTY
45352: LIST
45353: LIST
45354: PUSH
45355: LD_INT 2
45357: PUSH
45358: LD_INT 2
45360: NEG
45361: PUSH
45362: EMPTY
45363: LIST
45364: LIST
45365: PUSH
45366: LD_INT 4
45368: PUSH
45369: LD_INT 2
45371: PUSH
45372: EMPTY
45373: LIST
45374: LIST
45375: PUSH
45376: LD_INT 4
45378: PUSH
45379: LD_INT 4
45381: PUSH
45382: EMPTY
45383: LIST
45384: LIST
45385: PUSH
45386: LD_INT 4
45388: PUSH
45389: LD_INT 3
45391: PUSH
45392: EMPTY
45393: LIST
45394: LIST
45395: PUSH
45396: LD_INT 5
45398: PUSH
45399: LD_INT 4
45401: PUSH
45402: EMPTY
45403: LIST
45404: LIST
45405: PUSH
45406: LD_INT 5
45408: PUSH
45409: LD_INT 5
45411: PUSH
45412: EMPTY
45413: LIST
45414: LIST
45415: PUSH
45416: LD_INT 4
45418: PUSH
45419: LD_INT 5
45421: PUSH
45422: EMPTY
45423: LIST
45424: LIST
45425: PUSH
45426: LD_INT 3
45428: PUSH
45429: LD_INT 4
45431: PUSH
45432: EMPTY
45433: LIST
45434: LIST
45435: PUSH
45436: LD_INT 3
45438: PUSH
45439: LD_INT 3
45441: PUSH
45442: EMPTY
45443: LIST
45444: LIST
45445: PUSH
45446: LD_INT 5
45448: PUSH
45449: LD_INT 3
45451: PUSH
45452: EMPTY
45453: LIST
45454: LIST
45455: PUSH
45456: LD_INT 3
45458: PUSH
45459: LD_INT 5
45461: PUSH
45462: EMPTY
45463: LIST
45464: LIST
45465: PUSH
45466: EMPTY
45467: LIST
45468: LIST
45469: LIST
45470: LIST
45471: LIST
45472: LIST
45473: LIST
45474: LIST
45475: LIST
45476: LIST
45477: LIST
45478: LIST
45479: LIST
45480: LIST
45481: LIST
45482: LIST
45483: LIST
45484: LIST
45485: LIST
45486: LIST
45487: LIST
45488: LIST
45489: LIST
45490: LIST
45491: LIST
45492: LIST
45493: LIST
45494: LIST
45495: LIST
45496: LIST
45497: LIST
45498: LIST
45499: LIST
45500: LIST
45501: LIST
45502: LIST
45503: LIST
45504: LIST
45505: LIST
45506: LIST
45507: LIST
45508: LIST
45509: LIST
45510: LIST
45511: LIST
45512: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45513: LD_ADDR_VAR 0 33
45517: PUSH
45518: LD_INT 4
45520: NEG
45521: PUSH
45522: LD_INT 4
45524: NEG
45525: PUSH
45526: EMPTY
45527: LIST
45528: LIST
45529: PUSH
45530: LD_INT 4
45532: NEG
45533: PUSH
45534: LD_INT 5
45536: NEG
45537: PUSH
45538: EMPTY
45539: LIST
45540: LIST
45541: PUSH
45542: LD_INT 3
45544: NEG
45545: PUSH
45546: LD_INT 4
45548: NEG
45549: PUSH
45550: EMPTY
45551: LIST
45552: LIST
45553: PUSH
45554: LD_INT 3
45556: NEG
45557: PUSH
45558: LD_INT 3
45560: NEG
45561: PUSH
45562: EMPTY
45563: LIST
45564: LIST
45565: PUSH
45566: LD_INT 4
45568: NEG
45569: PUSH
45570: LD_INT 3
45572: NEG
45573: PUSH
45574: EMPTY
45575: LIST
45576: LIST
45577: PUSH
45578: LD_INT 5
45580: NEG
45581: PUSH
45582: LD_INT 4
45584: NEG
45585: PUSH
45586: EMPTY
45587: LIST
45588: LIST
45589: PUSH
45590: LD_INT 5
45592: NEG
45593: PUSH
45594: LD_INT 5
45596: NEG
45597: PUSH
45598: EMPTY
45599: LIST
45600: LIST
45601: PUSH
45602: LD_INT 3
45604: NEG
45605: PUSH
45606: LD_INT 5
45608: NEG
45609: PUSH
45610: EMPTY
45611: LIST
45612: LIST
45613: PUSH
45614: LD_INT 5
45616: NEG
45617: PUSH
45618: LD_INT 3
45620: NEG
45621: PUSH
45622: EMPTY
45623: LIST
45624: LIST
45625: PUSH
45626: LD_INT 0
45628: PUSH
45629: LD_INT 3
45631: NEG
45632: PUSH
45633: EMPTY
45634: LIST
45635: LIST
45636: PUSH
45637: LD_INT 0
45639: PUSH
45640: LD_INT 4
45642: NEG
45643: PUSH
45644: EMPTY
45645: LIST
45646: LIST
45647: PUSH
45648: LD_INT 1
45650: PUSH
45651: LD_INT 3
45653: NEG
45654: PUSH
45655: EMPTY
45656: LIST
45657: LIST
45658: PUSH
45659: LD_INT 1
45661: PUSH
45662: LD_INT 2
45664: NEG
45665: PUSH
45666: EMPTY
45667: LIST
45668: LIST
45669: PUSH
45670: LD_INT 0
45672: PUSH
45673: LD_INT 2
45675: NEG
45676: PUSH
45677: EMPTY
45678: LIST
45679: LIST
45680: PUSH
45681: LD_INT 1
45683: NEG
45684: PUSH
45685: LD_INT 3
45687: NEG
45688: PUSH
45689: EMPTY
45690: LIST
45691: LIST
45692: PUSH
45693: LD_INT 1
45695: NEG
45696: PUSH
45697: LD_INT 4
45699: NEG
45700: PUSH
45701: EMPTY
45702: LIST
45703: LIST
45704: PUSH
45705: LD_INT 2
45707: PUSH
45708: LD_INT 2
45710: NEG
45711: PUSH
45712: EMPTY
45713: LIST
45714: LIST
45715: PUSH
45716: LD_INT 2
45718: NEG
45719: PUSH
45720: LD_INT 4
45722: NEG
45723: PUSH
45724: EMPTY
45725: LIST
45726: LIST
45727: PUSH
45728: LD_INT 4
45730: PUSH
45731: LD_INT 0
45733: PUSH
45734: EMPTY
45735: LIST
45736: LIST
45737: PUSH
45738: LD_INT 4
45740: PUSH
45741: LD_INT 1
45743: NEG
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PUSH
45749: LD_INT 5
45751: PUSH
45752: LD_INT 0
45754: PUSH
45755: EMPTY
45756: LIST
45757: LIST
45758: PUSH
45759: LD_INT 5
45761: PUSH
45762: LD_INT 1
45764: PUSH
45765: EMPTY
45766: LIST
45767: LIST
45768: PUSH
45769: LD_INT 4
45771: PUSH
45772: LD_INT 1
45774: PUSH
45775: EMPTY
45776: LIST
45777: LIST
45778: PUSH
45779: LD_INT 3
45781: PUSH
45782: LD_INT 0
45784: PUSH
45785: EMPTY
45786: LIST
45787: LIST
45788: PUSH
45789: LD_INT 3
45791: PUSH
45792: LD_INT 1
45794: NEG
45795: PUSH
45796: EMPTY
45797: LIST
45798: LIST
45799: PUSH
45800: LD_INT 3
45802: PUSH
45803: LD_INT 2
45805: NEG
45806: PUSH
45807: EMPTY
45808: LIST
45809: LIST
45810: PUSH
45811: LD_INT 5
45813: PUSH
45814: LD_INT 2
45816: PUSH
45817: EMPTY
45818: LIST
45819: LIST
45820: PUSH
45821: LD_INT 3
45823: PUSH
45824: LD_INT 3
45826: PUSH
45827: EMPTY
45828: LIST
45829: LIST
45830: PUSH
45831: LD_INT 3
45833: PUSH
45834: LD_INT 2
45836: PUSH
45837: EMPTY
45838: LIST
45839: LIST
45840: PUSH
45841: LD_INT 4
45843: PUSH
45844: LD_INT 3
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: PUSH
45851: LD_INT 4
45853: PUSH
45854: LD_INT 4
45856: PUSH
45857: EMPTY
45858: LIST
45859: LIST
45860: PUSH
45861: LD_INT 3
45863: PUSH
45864: LD_INT 4
45866: PUSH
45867: EMPTY
45868: LIST
45869: LIST
45870: PUSH
45871: LD_INT 2
45873: PUSH
45874: LD_INT 3
45876: PUSH
45877: EMPTY
45878: LIST
45879: LIST
45880: PUSH
45881: LD_INT 2
45883: PUSH
45884: LD_INT 2
45886: PUSH
45887: EMPTY
45888: LIST
45889: LIST
45890: PUSH
45891: LD_INT 4
45893: PUSH
45894: LD_INT 2
45896: PUSH
45897: EMPTY
45898: LIST
45899: LIST
45900: PUSH
45901: LD_INT 2
45903: PUSH
45904: LD_INT 4
45906: PUSH
45907: EMPTY
45908: LIST
45909: LIST
45910: PUSH
45911: LD_INT 0
45913: PUSH
45914: LD_INT 4
45916: PUSH
45917: EMPTY
45918: LIST
45919: LIST
45920: PUSH
45921: LD_INT 0
45923: PUSH
45924: LD_INT 3
45926: PUSH
45927: EMPTY
45928: LIST
45929: LIST
45930: PUSH
45931: LD_INT 1
45933: PUSH
45934: LD_INT 4
45936: PUSH
45937: EMPTY
45938: LIST
45939: LIST
45940: PUSH
45941: LD_INT 1
45943: PUSH
45944: LD_INT 5
45946: PUSH
45947: EMPTY
45948: LIST
45949: LIST
45950: PUSH
45951: LD_INT 0
45953: PUSH
45954: LD_INT 5
45956: PUSH
45957: EMPTY
45958: LIST
45959: LIST
45960: PUSH
45961: LD_INT 1
45963: NEG
45964: PUSH
45965: LD_INT 4
45967: PUSH
45968: EMPTY
45969: LIST
45970: LIST
45971: PUSH
45972: LD_INT 1
45974: NEG
45975: PUSH
45976: LD_INT 3
45978: PUSH
45979: EMPTY
45980: LIST
45981: LIST
45982: PUSH
45983: LD_INT 2
45985: PUSH
45986: LD_INT 5
45988: PUSH
45989: EMPTY
45990: LIST
45991: LIST
45992: PUSH
45993: LD_INT 2
45995: NEG
45996: PUSH
45997: LD_INT 3
45999: PUSH
46000: EMPTY
46001: LIST
46002: LIST
46003: PUSH
46004: EMPTY
46005: LIST
46006: LIST
46007: LIST
46008: LIST
46009: LIST
46010: LIST
46011: LIST
46012: LIST
46013: LIST
46014: LIST
46015: LIST
46016: LIST
46017: LIST
46018: LIST
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: LIST
46030: LIST
46031: LIST
46032: LIST
46033: LIST
46034: LIST
46035: LIST
46036: LIST
46037: LIST
46038: LIST
46039: LIST
46040: LIST
46041: LIST
46042: LIST
46043: LIST
46044: LIST
46045: LIST
46046: LIST
46047: LIST
46048: LIST
46049: LIST
46050: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46051: LD_ADDR_VAR 0 34
46055: PUSH
46056: LD_INT 0
46058: PUSH
46059: LD_INT 4
46061: NEG
46062: PUSH
46063: EMPTY
46064: LIST
46065: LIST
46066: PUSH
46067: LD_INT 0
46069: PUSH
46070: LD_INT 5
46072: NEG
46073: PUSH
46074: EMPTY
46075: LIST
46076: LIST
46077: PUSH
46078: LD_INT 1
46080: PUSH
46081: LD_INT 4
46083: NEG
46084: PUSH
46085: EMPTY
46086: LIST
46087: LIST
46088: PUSH
46089: LD_INT 1
46091: PUSH
46092: LD_INT 3
46094: NEG
46095: PUSH
46096: EMPTY
46097: LIST
46098: LIST
46099: PUSH
46100: LD_INT 0
46102: PUSH
46103: LD_INT 3
46105: NEG
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: PUSH
46111: LD_INT 1
46113: NEG
46114: PUSH
46115: LD_INT 4
46117: NEG
46118: PUSH
46119: EMPTY
46120: LIST
46121: LIST
46122: PUSH
46123: LD_INT 1
46125: NEG
46126: PUSH
46127: LD_INT 5
46129: NEG
46130: PUSH
46131: EMPTY
46132: LIST
46133: LIST
46134: PUSH
46135: LD_INT 2
46137: PUSH
46138: LD_INT 3
46140: NEG
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: PUSH
46146: LD_INT 2
46148: NEG
46149: PUSH
46150: LD_INT 5
46152: NEG
46153: PUSH
46154: EMPTY
46155: LIST
46156: LIST
46157: PUSH
46158: LD_INT 3
46160: PUSH
46161: LD_INT 0
46163: PUSH
46164: EMPTY
46165: LIST
46166: LIST
46167: PUSH
46168: LD_INT 3
46170: PUSH
46171: LD_INT 1
46173: NEG
46174: PUSH
46175: EMPTY
46176: LIST
46177: LIST
46178: PUSH
46179: LD_INT 4
46181: PUSH
46182: LD_INT 0
46184: PUSH
46185: EMPTY
46186: LIST
46187: LIST
46188: PUSH
46189: LD_INT 4
46191: PUSH
46192: LD_INT 1
46194: PUSH
46195: EMPTY
46196: LIST
46197: LIST
46198: PUSH
46199: LD_INT 3
46201: PUSH
46202: LD_INT 1
46204: PUSH
46205: EMPTY
46206: LIST
46207: LIST
46208: PUSH
46209: LD_INT 2
46211: PUSH
46212: LD_INT 0
46214: PUSH
46215: EMPTY
46216: LIST
46217: LIST
46218: PUSH
46219: LD_INT 2
46221: PUSH
46222: LD_INT 1
46224: NEG
46225: PUSH
46226: EMPTY
46227: LIST
46228: LIST
46229: PUSH
46230: LD_INT 2
46232: PUSH
46233: LD_INT 2
46235: NEG
46236: PUSH
46237: EMPTY
46238: LIST
46239: LIST
46240: PUSH
46241: LD_INT 4
46243: PUSH
46244: LD_INT 2
46246: PUSH
46247: EMPTY
46248: LIST
46249: LIST
46250: PUSH
46251: LD_INT 4
46253: PUSH
46254: LD_INT 4
46256: PUSH
46257: EMPTY
46258: LIST
46259: LIST
46260: PUSH
46261: LD_INT 4
46263: PUSH
46264: LD_INT 3
46266: PUSH
46267: EMPTY
46268: LIST
46269: LIST
46270: PUSH
46271: LD_INT 5
46273: PUSH
46274: LD_INT 4
46276: PUSH
46277: EMPTY
46278: LIST
46279: LIST
46280: PUSH
46281: LD_INT 5
46283: PUSH
46284: LD_INT 5
46286: PUSH
46287: EMPTY
46288: LIST
46289: LIST
46290: PUSH
46291: LD_INT 4
46293: PUSH
46294: LD_INT 5
46296: PUSH
46297: EMPTY
46298: LIST
46299: LIST
46300: PUSH
46301: LD_INT 3
46303: PUSH
46304: LD_INT 4
46306: PUSH
46307: EMPTY
46308: LIST
46309: LIST
46310: PUSH
46311: LD_INT 3
46313: PUSH
46314: LD_INT 3
46316: PUSH
46317: EMPTY
46318: LIST
46319: LIST
46320: PUSH
46321: LD_INT 5
46323: PUSH
46324: LD_INT 3
46326: PUSH
46327: EMPTY
46328: LIST
46329: LIST
46330: PUSH
46331: LD_INT 3
46333: PUSH
46334: LD_INT 5
46336: PUSH
46337: EMPTY
46338: LIST
46339: LIST
46340: PUSH
46341: LD_INT 0
46343: PUSH
46344: LD_INT 3
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 0
46353: PUSH
46354: LD_INT 2
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: LD_INT 1
46363: PUSH
46364: LD_INT 3
46366: PUSH
46367: EMPTY
46368: LIST
46369: LIST
46370: PUSH
46371: LD_INT 1
46373: PUSH
46374: LD_INT 4
46376: PUSH
46377: EMPTY
46378: LIST
46379: LIST
46380: PUSH
46381: LD_INT 0
46383: PUSH
46384: LD_INT 4
46386: PUSH
46387: EMPTY
46388: LIST
46389: LIST
46390: PUSH
46391: LD_INT 1
46393: NEG
46394: PUSH
46395: LD_INT 3
46397: PUSH
46398: EMPTY
46399: LIST
46400: LIST
46401: PUSH
46402: LD_INT 1
46404: NEG
46405: PUSH
46406: LD_INT 2
46408: PUSH
46409: EMPTY
46410: LIST
46411: LIST
46412: PUSH
46413: LD_INT 2
46415: PUSH
46416: LD_INT 4
46418: PUSH
46419: EMPTY
46420: LIST
46421: LIST
46422: PUSH
46423: LD_INT 2
46425: NEG
46426: PUSH
46427: LD_INT 2
46429: PUSH
46430: EMPTY
46431: LIST
46432: LIST
46433: PUSH
46434: LD_INT 4
46436: NEG
46437: PUSH
46438: LD_INT 0
46440: PUSH
46441: EMPTY
46442: LIST
46443: LIST
46444: PUSH
46445: LD_INT 4
46447: NEG
46448: PUSH
46449: LD_INT 1
46451: NEG
46452: PUSH
46453: EMPTY
46454: LIST
46455: LIST
46456: PUSH
46457: LD_INT 3
46459: NEG
46460: PUSH
46461: LD_INT 0
46463: PUSH
46464: EMPTY
46465: LIST
46466: LIST
46467: PUSH
46468: LD_INT 3
46470: NEG
46471: PUSH
46472: LD_INT 1
46474: PUSH
46475: EMPTY
46476: LIST
46477: LIST
46478: PUSH
46479: LD_INT 4
46481: NEG
46482: PUSH
46483: LD_INT 1
46485: PUSH
46486: EMPTY
46487: LIST
46488: LIST
46489: PUSH
46490: LD_INT 5
46492: NEG
46493: PUSH
46494: LD_INT 0
46496: PUSH
46497: EMPTY
46498: LIST
46499: LIST
46500: PUSH
46501: LD_INT 5
46503: NEG
46504: PUSH
46505: LD_INT 1
46507: NEG
46508: PUSH
46509: EMPTY
46510: LIST
46511: LIST
46512: PUSH
46513: LD_INT 5
46515: NEG
46516: PUSH
46517: LD_INT 2
46519: NEG
46520: PUSH
46521: EMPTY
46522: LIST
46523: LIST
46524: PUSH
46525: LD_INT 3
46527: NEG
46528: PUSH
46529: LD_INT 2
46531: PUSH
46532: EMPTY
46533: LIST
46534: LIST
46535: PUSH
46536: EMPTY
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: LIST
46546: LIST
46547: LIST
46548: LIST
46549: LIST
46550: LIST
46551: LIST
46552: LIST
46553: LIST
46554: LIST
46555: LIST
46556: LIST
46557: LIST
46558: LIST
46559: LIST
46560: LIST
46561: LIST
46562: LIST
46563: LIST
46564: LIST
46565: LIST
46566: LIST
46567: LIST
46568: LIST
46569: LIST
46570: LIST
46571: LIST
46572: LIST
46573: LIST
46574: LIST
46575: LIST
46576: LIST
46577: LIST
46578: LIST
46579: LIST
46580: LIST
46581: LIST
46582: ST_TO_ADDR
// end ; end ;
46583: GO 46586
46585: POP
// case btype of b_depot , b_warehouse :
46586: LD_VAR 0 1
46590: PUSH
46591: LD_INT 0
46593: DOUBLE
46594: EQUAL
46595: IFTRUE 46605
46597: LD_INT 1
46599: DOUBLE
46600: EQUAL
46601: IFTRUE 46605
46603: GO 46806
46605: POP
// case nation of nation_american :
46606: LD_VAR 0 5
46610: PUSH
46611: LD_INT 1
46613: DOUBLE
46614: EQUAL
46615: IFTRUE 46619
46617: GO 46675
46619: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
46620: LD_ADDR_VAR 0 9
46624: PUSH
46625: LD_VAR 0 11
46629: PUSH
46630: LD_VAR 0 12
46634: PUSH
46635: LD_VAR 0 13
46639: PUSH
46640: LD_VAR 0 14
46644: PUSH
46645: LD_VAR 0 15
46649: PUSH
46650: LD_VAR 0 16
46654: PUSH
46655: EMPTY
46656: LIST
46657: LIST
46658: LIST
46659: LIST
46660: LIST
46661: LIST
46662: PUSH
46663: LD_VAR 0 4
46667: PUSH
46668: LD_INT 1
46670: PLUS
46671: ARRAY
46672: ST_TO_ADDR
46673: GO 46804
46675: LD_INT 2
46677: DOUBLE
46678: EQUAL
46679: IFTRUE 46683
46681: GO 46739
46683: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
46684: LD_ADDR_VAR 0 9
46688: PUSH
46689: LD_VAR 0 17
46693: PUSH
46694: LD_VAR 0 18
46698: PUSH
46699: LD_VAR 0 19
46703: PUSH
46704: LD_VAR 0 20
46708: PUSH
46709: LD_VAR 0 21
46713: PUSH
46714: LD_VAR 0 22
46718: PUSH
46719: EMPTY
46720: LIST
46721: LIST
46722: LIST
46723: LIST
46724: LIST
46725: LIST
46726: PUSH
46727: LD_VAR 0 4
46731: PUSH
46732: LD_INT 1
46734: PLUS
46735: ARRAY
46736: ST_TO_ADDR
46737: GO 46804
46739: LD_INT 3
46741: DOUBLE
46742: EQUAL
46743: IFTRUE 46747
46745: GO 46803
46747: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46748: LD_ADDR_VAR 0 9
46752: PUSH
46753: LD_VAR 0 23
46757: PUSH
46758: LD_VAR 0 24
46762: PUSH
46763: LD_VAR 0 25
46767: PUSH
46768: LD_VAR 0 26
46772: PUSH
46773: LD_VAR 0 27
46777: PUSH
46778: LD_VAR 0 28
46782: PUSH
46783: EMPTY
46784: LIST
46785: LIST
46786: LIST
46787: LIST
46788: LIST
46789: LIST
46790: PUSH
46791: LD_VAR 0 4
46795: PUSH
46796: LD_INT 1
46798: PLUS
46799: ARRAY
46800: ST_TO_ADDR
46801: GO 46804
46803: POP
46804: GO 47359
46806: LD_INT 2
46808: DOUBLE
46809: EQUAL
46810: IFTRUE 46820
46812: LD_INT 3
46814: DOUBLE
46815: EQUAL
46816: IFTRUE 46820
46818: GO 46876
46820: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46821: LD_ADDR_VAR 0 9
46825: PUSH
46826: LD_VAR 0 29
46830: PUSH
46831: LD_VAR 0 30
46835: PUSH
46836: LD_VAR 0 31
46840: PUSH
46841: LD_VAR 0 32
46845: PUSH
46846: LD_VAR 0 33
46850: PUSH
46851: LD_VAR 0 34
46855: PUSH
46856: EMPTY
46857: LIST
46858: LIST
46859: LIST
46860: LIST
46861: LIST
46862: LIST
46863: PUSH
46864: LD_VAR 0 4
46868: PUSH
46869: LD_INT 1
46871: PLUS
46872: ARRAY
46873: ST_TO_ADDR
46874: GO 47359
46876: LD_INT 16
46878: DOUBLE
46879: EQUAL
46880: IFTRUE 46938
46882: LD_INT 17
46884: DOUBLE
46885: EQUAL
46886: IFTRUE 46938
46888: LD_INT 18
46890: DOUBLE
46891: EQUAL
46892: IFTRUE 46938
46894: LD_INT 19
46896: DOUBLE
46897: EQUAL
46898: IFTRUE 46938
46900: LD_INT 22
46902: DOUBLE
46903: EQUAL
46904: IFTRUE 46938
46906: LD_INT 20
46908: DOUBLE
46909: EQUAL
46910: IFTRUE 46938
46912: LD_INT 21
46914: DOUBLE
46915: EQUAL
46916: IFTRUE 46938
46918: LD_INT 23
46920: DOUBLE
46921: EQUAL
46922: IFTRUE 46938
46924: LD_INT 24
46926: DOUBLE
46927: EQUAL
46928: IFTRUE 46938
46930: LD_INT 25
46932: DOUBLE
46933: EQUAL
46934: IFTRUE 46938
46936: GO 46994
46938: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46939: LD_ADDR_VAR 0 9
46943: PUSH
46944: LD_VAR 0 35
46948: PUSH
46949: LD_VAR 0 36
46953: PUSH
46954: LD_VAR 0 37
46958: PUSH
46959: LD_VAR 0 38
46963: PUSH
46964: LD_VAR 0 39
46968: PUSH
46969: LD_VAR 0 40
46973: PUSH
46974: EMPTY
46975: LIST
46976: LIST
46977: LIST
46978: LIST
46979: LIST
46980: LIST
46981: PUSH
46982: LD_VAR 0 4
46986: PUSH
46987: LD_INT 1
46989: PLUS
46990: ARRAY
46991: ST_TO_ADDR
46992: GO 47359
46994: LD_INT 6
46996: DOUBLE
46997: EQUAL
46998: IFTRUE 47050
47000: LD_INT 7
47002: DOUBLE
47003: EQUAL
47004: IFTRUE 47050
47006: LD_INT 8
47008: DOUBLE
47009: EQUAL
47010: IFTRUE 47050
47012: LD_INT 13
47014: DOUBLE
47015: EQUAL
47016: IFTRUE 47050
47018: LD_INT 12
47020: DOUBLE
47021: EQUAL
47022: IFTRUE 47050
47024: LD_INT 15
47026: DOUBLE
47027: EQUAL
47028: IFTRUE 47050
47030: LD_INT 11
47032: DOUBLE
47033: EQUAL
47034: IFTRUE 47050
47036: LD_INT 14
47038: DOUBLE
47039: EQUAL
47040: IFTRUE 47050
47042: LD_INT 10
47044: DOUBLE
47045: EQUAL
47046: IFTRUE 47050
47048: GO 47106
47050: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
47051: LD_ADDR_VAR 0 9
47055: PUSH
47056: LD_VAR 0 41
47060: PUSH
47061: LD_VAR 0 42
47065: PUSH
47066: LD_VAR 0 43
47070: PUSH
47071: LD_VAR 0 44
47075: PUSH
47076: LD_VAR 0 45
47080: PUSH
47081: LD_VAR 0 46
47085: PUSH
47086: EMPTY
47087: LIST
47088: LIST
47089: LIST
47090: LIST
47091: LIST
47092: LIST
47093: PUSH
47094: LD_VAR 0 4
47098: PUSH
47099: LD_INT 1
47101: PLUS
47102: ARRAY
47103: ST_TO_ADDR
47104: GO 47359
47106: LD_INT 36
47108: DOUBLE
47109: EQUAL
47110: IFTRUE 47114
47112: GO 47170
47114: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47115: LD_ADDR_VAR 0 9
47119: PUSH
47120: LD_VAR 0 47
47124: PUSH
47125: LD_VAR 0 48
47129: PUSH
47130: LD_VAR 0 49
47134: PUSH
47135: LD_VAR 0 50
47139: PUSH
47140: LD_VAR 0 51
47144: PUSH
47145: LD_VAR 0 52
47149: PUSH
47150: EMPTY
47151: LIST
47152: LIST
47153: LIST
47154: LIST
47155: LIST
47156: LIST
47157: PUSH
47158: LD_VAR 0 4
47162: PUSH
47163: LD_INT 1
47165: PLUS
47166: ARRAY
47167: ST_TO_ADDR
47168: GO 47359
47170: LD_INT 4
47172: DOUBLE
47173: EQUAL
47174: IFTRUE 47196
47176: LD_INT 5
47178: DOUBLE
47179: EQUAL
47180: IFTRUE 47196
47182: LD_INT 34
47184: DOUBLE
47185: EQUAL
47186: IFTRUE 47196
47188: LD_INT 37
47190: DOUBLE
47191: EQUAL
47192: IFTRUE 47196
47194: GO 47252
47196: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47197: LD_ADDR_VAR 0 9
47201: PUSH
47202: LD_VAR 0 53
47206: PUSH
47207: LD_VAR 0 54
47211: PUSH
47212: LD_VAR 0 55
47216: PUSH
47217: LD_VAR 0 56
47221: PUSH
47222: LD_VAR 0 57
47226: PUSH
47227: LD_VAR 0 58
47231: PUSH
47232: EMPTY
47233: LIST
47234: LIST
47235: LIST
47236: LIST
47237: LIST
47238: LIST
47239: PUSH
47240: LD_VAR 0 4
47244: PUSH
47245: LD_INT 1
47247: PLUS
47248: ARRAY
47249: ST_TO_ADDR
47250: GO 47359
47252: LD_INT 31
47254: DOUBLE
47255: EQUAL
47256: IFTRUE 47302
47258: LD_INT 32
47260: DOUBLE
47261: EQUAL
47262: IFTRUE 47302
47264: LD_INT 33
47266: DOUBLE
47267: EQUAL
47268: IFTRUE 47302
47270: LD_INT 27
47272: DOUBLE
47273: EQUAL
47274: IFTRUE 47302
47276: LD_INT 26
47278: DOUBLE
47279: EQUAL
47280: IFTRUE 47302
47282: LD_INT 28
47284: DOUBLE
47285: EQUAL
47286: IFTRUE 47302
47288: LD_INT 29
47290: DOUBLE
47291: EQUAL
47292: IFTRUE 47302
47294: LD_INT 30
47296: DOUBLE
47297: EQUAL
47298: IFTRUE 47302
47300: GO 47358
47302: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
47303: LD_ADDR_VAR 0 9
47307: PUSH
47308: LD_VAR 0 59
47312: PUSH
47313: LD_VAR 0 60
47317: PUSH
47318: LD_VAR 0 61
47322: PUSH
47323: LD_VAR 0 62
47327: PUSH
47328: LD_VAR 0 63
47332: PUSH
47333: LD_VAR 0 64
47337: PUSH
47338: EMPTY
47339: LIST
47340: LIST
47341: LIST
47342: LIST
47343: LIST
47344: LIST
47345: PUSH
47346: LD_VAR 0 4
47350: PUSH
47351: LD_INT 1
47353: PLUS
47354: ARRAY
47355: ST_TO_ADDR
47356: GO 47359
47358: POP
// temp_list2 = [ ] ;
47359: LD_ADDR_VAR 0 10
47363: PUSH
47364: EMPTY
47365: ST_TO_ADDR
// for i in temp_list do
47366: LD_ADDR_VAR 0 8
47370: PUSH
47371: LD_VAR 0 9
47375: PUSH
47376: FOR_IN
47377: IFFALSE 47429
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47379: LD_ADDR_VAR 0 10
47383: PUSH
47384: LD_VAR 0 10
47388: PUSH
47389: LD_VAR 0 8
47393: PUSH
47394: LD_INT 1
47396: ARRAY
47397: PUSH
47398: LD_VAR 0 2
47402: PLUS
47403: PUSH
47404: LD_VAR 0 8
47408: PUSH
47409: LD_INT 2
47411: ARRAY
47412: PUSH
47413: LD_VAR 0 3
47417: PLUS
47418: PUSH
47419: EMPTY
47420: LIST
47421: LIST
47422: PUSH
47423: EMPTY
47424: LIST
47425: ADD
47426: ST_TO_ADDR
47427: GO 47376
47429: POP
47430: POP
// result = temp_list2 ;
47431: LD_ADDR_VAR 0 7
47435: PUSH
47436: LD_VAR 0 10
47440: ST_TO_ADDR
// end ;
47441: LD_VAR 0 7
47445: RET
// export function EnemyInRange ( unit , dist ) ; begin
47446: LD_INT 0
47448: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47449: LD_ADDR_VAR 0 3
47453: PUSH
47454: LD_VAR 0 1
47458: PPUSH
47459: CALL_OW 255
47463: PPUSH
47464: LD_VAR 0 1
47468: PPUSH
47469: CALL_OW 250
47473: PPUSH
47474: LD_VAR 0 1
47478: PPUSH
47479: CALL_OW 251
47483: PPUSH
47484: LD_VAR 0 2
47488: PPUSH
47489: CALL 21550 0 4
47493: PUSH
47494: LD_INT 4
47496: ARRAY
47497: ST_TO_ADDR
// end ;
47498: LD_VAR 0 3
47502: RET
// export function PlayerSeeMe ( unit ) ; begin
47503: LD_INT 0
47505: PPUSH
// result := See ( your_side , unit ) ;
47506: LD_ADDR_VAR 0 2
47510: PUSH
47511: LD_OWVAR 2
47515: PPUSH
47516: LD_VAR 0 1
47520: PPUSH
47521: CALL_OW 292
47525: ST_TO_ADDR
// end ;
47526: LD_VAR 0 2
47530: RET
// export function ReverseDir ( unit ) ; begin
47531: LD_INT 0
47533: PPUSH
// if not unit then
47534: LD_VAR 0 1
47538: NOT
47539: IFFALSE 47543
// exit ;
47541: GO 47589
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
47543: LD_ADDR_VAR 0 2
47547: PUSH
47548: LD_INT 3
47550: PUSH
47551: LD_INT 4
47553: PUSH
47554: LD_INT 5
47556: PUSH
47557: LD_INT 0
47559: PUSH
47560: LD_INT 1
47562: PUSH
47563: LD_INT 2
47565: PUSH
47566: EMPTY
47567: LIST
47568: LIST
47569: LIST
47570: LIST
47571: LIST
47572: LIST
47573: PUSH
47574: LD_VAR 0 1
47578: PPUSH
47579: CALL_OW 254
47583: PUSH
47584: LD_INT 1
47586: PLUS
47587: ARRAY
47588: ST_TO_ADDR
// end ;
47589: LD_VAR 0 2
47593: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47594: LD_INT 0
47596: PPUSH
47597: PPUSH
47598: PPUSH
47599: PPUSH
47600: PPUSH
// if not hexes then
47601: LD_VAR 0 2
47605: NOT
47606: IFFALSE 47610
// exit ;
47608: GO 47758
// dist := 9999 ;
47610: LD_ADDR_VAR 0 5
47614: PUSH
47615: LD_INT 9999
47617: ST_TO_ADDR
// for i = 1 to hexes do
47618: LD_ADDR_VAR 0 4
47622: PUSH
47623: DOUBLE
47624: LD_INT 1
47626: DEC
47627: ST_TO_ADDR
47628: LD_VAR 0 2
47632: PUSH
47633: FOR_TO
47634: IFFALSE 47746
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47636: LD_VAR 0 1
47640: PPUSH
47641: LD_VAR 0 2
47645: PUSH
47646: LD_VAR 0 4
47650: ARRAY
47651: PUSH
47652: LD_INT 1
47654: ARRAY
47655: PPUSH
47656: LD_VAR 0 2
47660: PUSH
47661: LD_VAR 0 4
47665: ARRAY
47666: PUSH
47667: LD_INT 2
47669: ARRAY
47670: PPUSH
47671: CALL_OW 297
47675: PUSH
47676: LD_VAR 0 5
47680: LESS
47681: IFFALSE 47744
// begin hex := hexes [ i ] ;
47683: LD_ADDR_VAR 0 7
47687: PUSH
47688: LD_VAR 0 2
47692: PUSH
47693: LD_VAR 0 4
47697: ARRAY
47698: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47699: LD_ADDR_VAR 0 5
47703: PUSH
47704: LD_VAR 0 1
47708: PPUSH
47709: LD_VAR 0 2
47713: PUSH
47714: LD_VAR 0 4
47718: ARRAY
47719: PUSH
47720: LD_INT 1
47722: ARRAY
47723: PPUSH
47724: LD_VAR 0 2
47728: PUSH
47729: LD_VAR 0 4
47733: ARRAY
47734: PUSH
47735: LD_INT 2
47737: ARRAY
47738: PPUSH
47739: CALL_OW 297
47743: ST_TO_ADDR
// end ; end ;
47744: GO 47633
47746: POP
47747: POP
// result := hex ;
47748: LD_ADDR_VAR 0 3
47752: PUSH
47753: LD_VAR 0 7
47757: ST_TO_ADDR
// end ;
47758: LD_VAR 0 3
47762: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47763: LD_INT 0
47765: PPUSH
47766: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47767: LD_VAR 0 1
47771: NOT
47772: PUSH
47773: LD_VAR 0 1
47777: PUSH
47778: LD_INT 21
47780: PUSH
47781: LD_INT 2
47783: PUSH
47784: EMPTY
47785: LIST
47786: LIST
47787: PUSH
47788: LD_INT 23
47790: PUSH
47791: LD_INT 2
47793: PUSH
47794: EMPTY
47795: LIST
47796: LIST
47797: PUSH
47798: EMPTY
47799: LIST
47800: LIST
47801: PPUSH
47802: CALL_OW 69
47806: IN
47807: NOT
47808: OR
47809: IFFALSE 47813
// exit ;
47811: GO 47860
// for i = 1 to 3 do
47813: LD_ADDR_VAR 0 3
47817: PUSH
47818: DOUBLE
47819: LD_INT 1
47821: DEC
47822: ST_TO_ADDR
47823: LD_INT 3
47825: PUSH
47826: FOR_TO
47827: IFFALSE 47858
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47829: LD_VAR 0 1
47833: PPUSH
47834: CALL_OW 250
47838: PPUSH
47839: LD_VAR 0 1
47843: PPUSH
47844: CALL_OW 251
47848: PPUSH
47849: LD_INT 1
47851: PPUSH
47852: CALL_OW 453
47856: GO 47826
47858: POP
47859: POP
// end ;
47860: LD_VAR 0 2
47864: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47865: LD_INT 0
47867: PPUSH
47868: PPUSH
47869: PPUSH
47870: PPUSH
47871: PPUSH
47872: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47873: LD_VAR 0 1
47877: NOT
47878: PUSH
47879: LD_VAR 0 2
47883: NOT
47884: OR
47885: PUSH
47886: LD_VAR 0 1
47890: PPUSH
47891: CALL_OW 314
47895: OR
47896: IFFALSE 47900
// exit ;
47898: GO 48341
// x := GetX ( enemy_unit ) ;
47900: LD_ADDR_VAR 0 7
47904: PUSH
47905: LD_VAR 0 2
47909: PPUSH
47910: CALL_OW 250
47914: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47915: LD_ADDR_VAR 0 8
47919: PUSH
47920: LD_VAR 0 2
47924: PPUSH
47925: CALL_OW 251
47929: ST_TO_ADDR
// if not x or not y then
47930: LD_VAR 0 7
47934: NOT
47935: PUSH
47936: LD_VAR 0 8
47940: NOT
47941: OR
47942: IFFALSE 47946
// exit ;
47944: GO 48341
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47946: LD_ADDR_VAR 0 6
47950: PUSH
47951: LD_VAR 0 7
47955: PPUSH
47956: LD_INT 0
47958: PPUSH
47959: LD_INT 4
47961: PPUSH
47962: CALL_OW 272
47966: PUSH
47967: LD_VAR 0 8
47971: PPUSH
47972: LD_INT 0
47974: PPUSH
47975: LD_INT 4
47977: PPUSH
47978: CALL_OW 273
47982: PUSH
47983: EMPTY
47984: LIST
47985: LIST
47986: PUSH
47987: LD_VAR 0 7
47991: PPUSH
47992: LD_INT 1
47994: PPUSH
47995: LD_INT 4
47997: PPUSH
47998: CALL_OW 272
48002: PUSH
48003: LD_VAR 0 8
48007: PPUSH
48008: LD_INT 1
48010: PPUSH
48011: LD_INT 4
48013: PPUSH
48014: CALL_OW 273
48018: PUSH
48019: EMPTY
48020: LIST
48021: LIST
48022: PUSH
48023: LD_VAR 0 7
48027: PPUSH
48028: LD_INT 2
48030: PPUSH
48031: LD_INT 4
48033: PPUSH
48034: CALL_OW 272
48038: PUSH
48039: LD_VAR 0 8
48043: PPUSH
48044: LD_INT 2
48046: PPUSH
48047: LD_INT 4
48049: PPUSH
48050: CALL_OW 273
48054: PUSH
48055: EMPTY
48056: LIST
48057: LIST
48058: PUSH
48059: LD_VAR 0 7
48063: PPUSH
48064: LD_INT 3
48066: PPUSH
48067: LD_INT 4
48069: PPUSH
48070: CALL_OW 272
48074: PUSH
48075: LD_VAR 0 8
48079: PPUSH
48080: LD_INT 3
48082: PPUSH
48083: LD_INT 4
48085: PPUSH
48086: CALL_OW 273
48090: PUSH
48091: EMPTY
48092: LIST
48093: LIST
48094: PUSH
48095: LD_VAR 0 7
48099: PPUSH
48100: LD_INT 4
48102: PPUSH
48103: LD_INT 4
48105: PPUSH
48106: CALL_OW 272
48110: PUSH
48111: LD_VAR 0 8
48115: PPUSH
48116: LD_INT 4
48118: PPUSH
48119: LD_INT 4
48121: PPUSH
48122: CALL_OW 273
48126: PUSH
48127: EMPTY
48128: LIST
48129: LIST
48130: PUSH
48131: LD_VAR 0 7
48135: PPUSH
48136: LD_INT 5
48138: PPUSH
48139: LD_INT 4
48141: PPUSH
48142: CALL_OW 272
48146: PUSH
48147: LD_VAR 0 8
48151: PPUSH
48152: LD_INT 5
48154: PPUSH
48155: LD_INT 4
48157: PPUSH
48158: CALL_OW 273
48162: PUSH
48163: EMPTY
48164: LIST
48165: LIST
48166: PUSH
48167: EMPTY
48168: LIST
48169: LIST
48170: LIST
48171: LIST
48172: LIST
48173: LIST
48174: ST_TO_ADDR
// for i = tmp downto 1 do
48175: LD_ADDR_VAR 0 4
48179: PUSH
48180: DOUBLE
48181: LD_VAR 0 6
48185: INC
48186: ST_TO_ADDR
48187: LD_INT 1
48189: PUSH
48190: FOR_DOWNTO
48191: IFFALSE 48292
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48193: LD_VAR 0 6
48197: PUSH
48198: LD_VAR 0 4
48202: ARRAY
48203: PUSH
48204: LD_INT 1
48206: ARRAY
48207: PPUSH
48208: LD_VAR 0 6
48212: PUSH
48213: LD_VAR 0 4
48217: ARRAY
48218: PUSH
48219: LD_INT 2
48221: ARRAY
48222: PPUSH
48223: CALL_OW 488
48227: NOT
48228: PUSH
48229: LD_VAR 0 6
48233: PUSH
48234: LD_VAR 0 4
48238: ARRAY
48239: PUSH
48240: LD_INT 1
48242: ARRAY
48243: PPUSH
48244: LD_VAR 0 6
48248: PUSH
48249: LD_VAR 0 4
48253: ARRAY
48254: PUSH
48255: LD_INT 2
48257: ARRAY
48258: PPUSH
48259: CALL_OW 428
48263: PUSH
48264: LD_INT 0
48266: NONEQUAL
48267: OR
48268: IFFALSE 48290
// tmp := Delete ( tmp , i ) ;
48270: LD_ADDR_VAR 0 6
48274: PUSH
48275: LD_VAR 0 6
48279: PPUSH
48280: LD_VAR 0 4
48284: PPUSH
48285: CALL_OW 3
48289: ST_TO_ADDR
48290: GO 48190
48292: POP
48293: POP
// j := GetClosestHex ( unit , tmp ) ;
48294: LD_ADDR_VAR 0 5
48298: PUSH
48299: LD_VAR 0 1
48303: PPUSH
48304: LD_VAR 0 6
48308: PPUSH
48309: CALL 47594 0 2
48313: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48314: LD_VAR 0 1
48318: PPUSH
48319: LD_VAR 0 5
48323: PUSH
48324: LD_INT 1
48326: ARRAY
48327: PPUSH
48328: LD_VAR 0 5
48332: PUSH
48333: LD_INT 2
48335: ARRAY
48336: PPUSH
48337: CALL_OW 111
// end ;
48341: LD_VAR 0 3
48345: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48346: LD_INT 0
48348: PPUSH
48349: PPUSH
48350: PPUSH
// uc_side = 0 ;
48351: LD_ADDR_OWVAR 20
48355: PUSH
48356: LD_INT 0
48358: ST_TO_ADDR
// uc_nation = 0 ;
48359: LD_ADDR_OWVAR 21
48363: PUSH
48364: LD_INT 0
48366: ST_TO_ADDR
// InitHc ;
48367: CALL_OW 19
// InitVc ;
48371: CALL_OW 20
// if mastodonts then
48375: LD_VAR 0 6
48379: IFFALSE 48446
// for i = 1 to mastodonts do
48381: LD_ADDR_VAR 0 11
48385: PUSH
48386: DOUBLE
48387: LD_INT 1
48389: DEC
48390: ST_TO_ADDR
48391: LD_VAR 0 6
48395: PUSH
48396: FOR_TO
48397: IFFALSE 48444
// begin vc_chassis := 31 ;
48399: LD_ADDR_OWVAR 37
48403: PUSH
48404: LD_INT 31
48406: ST_TO_ADDR
// vc_control := control_rider ;
48407: LD_ADDR_OWVAR 38
48411: PUSH
48412: LD_INT 4
48414: ST_TO_ADDR
// animal := CreateVehicle ;
48415: LD_ADDR_VAR 0 12
48419: PUSH
48420: CALL_OW 45
48424: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48425: LD_VAR 0 12
48429: PPUSH
48430: LD_VAR 0 8
48434: PPUSH
48435: LD_INT 0
48437: PPUSH
48438: CALL 55191 0 3
// end ;
48442: GO 48396
48444: POP
48445: POP
// if horses then
48446: LD_VAR 0 5
48450: IFFALSE 48517
// for i = 1 to horses do
48452: LD_ADDR_VAR 0 11
48456: PUSH
48457: DOUBLE
48458: LD_INT 1
48460: DEC
48461: ST_TO_ADDR
48462: LD_VAR 0 5
48466: PUSH
48467: FOR_TO
48468: IFFALSE 48515
// begin hc_class := 21 ;
48470: LD_ADDR_OWVAR 28
48474: PUSH
48475: LD_INT 21
48477: ST_TO_ADDR
// hc_gallery :=  ;
48478: LD_ADDR_OWVAR 33
48482: PUSH
48483: LD_STRING 
48485: ST_TO_ADDR
// animal := CreateHuman ;
48486: LD_ADDR_VAR 0 12
48490: PUSH
48491: CALL_OW 44
48495: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48496: LD_VAR 0 12
48500: PPUSH
48501: LD_VAR 0 8
48505: PPUSH
48506: LD_INT 0
48508: PPUSH
48509: CALL 55191 0 3
// end ;
48513: GO 48467
48515: POP
48516: POP
// if birds then
48517: LD_VAR 0 1
48521: IFFALSE 48588
// for i = 1 to birds do
48523: LD_ADDR_VAR 0 11
48527: PUSH
48528: DOUBLE
48529: LD_INT 1
48531: DEC
48532: ST_TO_ADDR
48533: LD_VAR 0 1
48537: PUSH
48538: FOR_TO
48539: IFFALSE 48586
// begin hc_class = 18 ;
48541: LD_ADDR_OWVAR 28
48545: PUSH
48546: LD_INT 18
48548: ST_TO_ADDR
// hc_gallery =  ;
48549: LD_ADDR_OWVAR 33
48553: PUSH
48554: LD_STRING 
48556: ST_TO_ADDR
// animal := CreateHuman ;
48557: LD_ADDR_VAR 0 12
48561: PUSH
48562: CALL_OW 44
48566: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48567: LD_VAR 0 12
48571: PPUSH
48572: LD_VAR 0 8
48576: PPUSH
48577: LD_INT 0
48579: PPUSH
48580: CALL 55191 0 3
// end ;
48584: GO 48538
48586: POP
48587: POP
// if tigers then
48588: LD_VAR 0 2
48592: IFFALSE 48676
// for i = 1 to tigers do
48594: LD_ADDR_VAR 0 11
48598: PUSH
48599: DOUBLE
48600: LD_INT 1
48602: DEC
48603: ST_TO_ADDR
48604: LD_VAR 0 2
48608: PUSH
48609: FOR_TO
48610: IFFALSE 48674
// begin hc_class = class_tiger ;
48612: LD_ADDR_OWVAR 28
48616: PUSH
48617: LD_INT 14
48619: ST_TO_ADDR
// hc_gallery =  ;
48620: LD_ADDR_OWVAR 33
48624: PUSH
48625: LD_STRING 
48627: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48628: LD_ADDR_OWVAR 35
48632: PUSH
48633: LD_INT 7
48635: NEG
48636: PPUSH
48637: LD_INT 7
48639: PPUSH
48640: CALL_OW 12
48644: ST_TO_ADDR
// animal := CreateHuman ;
48645: LD_ADDR_VAR 0 12
48649: PUSH
48650: CALL_OW 44
48654: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48655: LD_VAR 0 12
48659: PPUSH
48660: LD_VAR 0 8
48664: PPUSH
48665: LD_INT 0
48667: PPUSH
48668: CALL 55191 0 3
// end ;
48672: GO 48609
48674: POP
48675: POP
// if apemans then
48676: LD_VAR 0 3
48680: IFFALSE 48803
// for i = 1 to apemans do
48682: LD_ADDR_VAR 0 11
48686: PUSH
48687: DOUBLE
48688: LD_INT 1
48690: DEC
48691: ST_TO_ADDR
48692: LD_VAR 0 3
48696: PUSH
48697: FOR_TO
48698: IFFALSE 48801
// begin hc_class = class_apeman ;
48700: LD_ADDR_OWVAR 28
48704: PUSH
48705: LD_INT 12
48707: ST_TO_ADDR
// hc_gallery =  ;
48708: LD_ADDR_OWVAR 33
48712: PUSH
48713: LD_STRING 
48715: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
48716: LD_ADDR_OWVAR 35
48720: PUSH
48721: LD_INT 5
48723: NEG
48724: PPUSH
48725: LD_INT 5
48727: PPUSH
48728: CALL_OW 12
48732: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48733: LD_ADDR_OWVAR 31
48737: PUSH
48738: LD_INT 1
48740: PPUSH
48741: LD_INT 3
48743: PPUSH
48744: CALL_OW 12
48748: PUSH
48749: LD_INT 1
48751: PPUSH
48752: LD_INT 3
48754: PPUSH
48755: CALL_OW 12
48759: PUSH
48760: LD_INT 0
48762: PUSH
48763: LD_INT 0
48765: PUSH
48766: EMPTY
48767: LIST
48768: LIST
48769: LIST
48770: LIST
48771: ST_TO_ADDR
// animal := CreateHuman ;
48772: LD_ADDR_VAR 0 12
48776: PUSH
48777: CALL_OW 44
48781: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48782: LD_VAR 0 12
48786: PPUSH
48787: LD_VAR 0 8
48791: PPUSH
48792: LD_INT 0
48794: PPUSH
48795: CALL 55191 0 3
// end ;
48799: GO 48697
48801: POP
48802: POP
// if enchidnas then
48803: LD_VAR 0 4
48807: IFFALSE 48874
// for i = 1 to enchidnas do
48809: LD_ADDR_VAR 0 11
48813: PUSH
48814: DOUBLE
48815: LD_INT 1
48817: DEC
48818: ST_TO_ADDR
48819: LD_VAR 0 4
48823: PUSH
48824: FOR_TO
48825: IFFALSE 48872
// begin hc_class = 13 ;
48827: LD_ADDR_OWVAR 28
48831: PUSH
48832: LD_INT 13
48834: ST_TO_ADDR
// hc_gallery =  ;
48835: LD_ADDR_OWVAR 33
48839: PUSH
48840: LD_STRING 
48842: ST_TO_ADDR
// animal := CreateHuman ;
48843: LD_ADDR_VAR 0 12
48847: PUSH
48848: CALL_OW 44
48852: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48853: LD_VAR 0 12
48857: PPUSH
48858: LD_VAR 0 8
48862: PPUSH
48863: LD_INT 0
48865: PPUSH
48866: CALL 55191 0 3
// end ;
48870: GO 48824
48872: POP
48873: POP
// if fishes then
48874: LD_VAR 0 7
48878: IFFALSE 48945
// for i = 1 to fishes do
48880: LD_ADDR_VAR 0 11
48884: PUSH
48885: DOUBLE
48886: LD_INT 1
48888: DEC
48889: ST_TO_ADDR
48890: LD_VAR 0 7
48894: PUSH
48895: FOR_TO
48896: IFFALSE 48943
// begin hc_class = 20 ;
48898: LD_ADDR_OWVAR 28
48902: PUSH
48903: LD_INT 20
48905: ST_TO_ADDR
// hc_gallery =  ;
48906: LD_ADDR_OWVAR 33
48910: PUSH
48911: LD_STRING 
48913: ST_TO_ADDR
// animal := CreateHuman ;
48914: LD_ADDR_VAR 0 12
48918: PUSH
48919: CALL_OW 44
48923: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48924: LD_VAR 0 12
48928: PPUSH
48929: LD_VAR 0 9
48933: PPUSH
48934: LD_INT 0
48936: PPUSH
48937: CALL 55191 0 3
// end ;
48941: GO 48895
48943: POP
48944: POP
// end ;
48945: LD_VAR 0 10
48949: RET
// export function WantHeal ( sci , unit ) ; begin
48950: LD_INT 0
48952: PPUSH
// if GetTaskList ( sci ) > 0 then
48953: LD_VAR 0 1
48957: PPUSH
48958: CALL_OW 437
48962: PUSH
48963: LD_INT 0
48965: GREATER
48966: IFFALSE 49036
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48968: LD_VAR 0 1
48972: PPUSH
48973: CALL_OW 437
48977: PUSH
48978: LD_INT 1
48980: ARRAY
48981: PUSH
48982: LD_INT 1
48984: ARRAY
48985: PUSH
48986: LD_STRING l
48988: EQUAL
48989: PUSH
48990: LD_VAR 0 1
48994: PPUSH
48995: CALL_OW 437
48999: PUSH
49000: LD_INT 1
49002: ARRAY
49003: PUSH
49004: LD_INT 4
49006: ARRAY
49007: PUSH
49008: LD_VAR 0 2
49012: EQUAL
49013: AND
49014: IFFALSE 49026
// result := true else
49016: LD_ADDR_VAR 0 3
49020: PUSH
49021: LD_INT 1
49023: ST_TO_ADDR
49024: GO 49034
// result := false ;
49026: LD_ADDR_VAR 0 3
49030: PUSH
49031: LD_INT 0
49033: ST_TO_ADDR
// end else
49034: GO 49044
// result := false ;
49036: LD_ADDR_VAR 0 3
49040: PUSH
49041: LD_INT 0
49043: ST_TO_ADDR
// end ;
49044: LD_VAR 0 3
49048: RET
// export function HealTarget ( sci ) ; begin
49049: LD_INT 0
49051: PPUSH
// if not sci then
49052: LD_VAR 0 1
49056: NOT
49057: IFFALSE 49061
// exit ;
49059: GO 49126
// result := 0 ;
49061: LD_ADDR_VAR 0 2
49065: PUSH
49066: LD_INT 0
49068: ST_TO_ADDR
// if GetTaskList ( sci ) then
49069: LD_VAR 0 1
49073: PPUSH
49074: CALL_OW 437
49078: IFFALSE 49126
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49080: LD_VAR 0 1
49084: PPUSH
49085: CALL_OW 437
49089: PUSH
49090: LD_INT 1
49092: ARRAY
49093: PUSH
49094: LD_INT 1
49096: ARRAY
49097: PUSH
49098: LD_STRING l
49100: EQUAL
49101: IFFALSE 49126
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49103: LD_ADDR_VAR 0 2
49107: PUSH
49108: LD_VAR 0 1
49112: PPUSH
49113: CALL_OW 437
49117: PUSH
49118: LD_INT 1
49120: ARRAY
49121: PUSH
49122: LD_INT 4
49124: ARRAY
49125: ST_TO_ADDR
// end ;
49126: LD_VAR 0 2
49130: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
49131: LD_INT 0
49133: PPUSH
49134: PPUSH
49135: PPUSH
49136: PPUSH
49137: PPUSH
49138: PPUSH
49139: PPUSH
49140: PPUSH
49141: PPUSH
49142: PPUSH
49143: PPUSH
49144: PPUSH
49145: PPUSH
49146: PPUSH
49147: PPUSH
49148: PPUSH
49149: PPUSH
49150: PPUSH
49151: PPUSH
49152: PPUSH
49153: PPUSH
49154: PPUSH
49155: PPUSH
49156: PPUSH
49157: PPUSH
49158: PPUSH
49159: PPUSH
49160: PPUSH
49161: PPUSH
49162: PPUSH
49163: PPUSH
49164: PPUSH
49165: PPUSH
49166: PPUSH
// if not list then
49167: LD_VAR 0 1
49171: NOT
49172: IFFALSE 49176
// exit ;
49174: GO 53802
// base := list [ 1 ] ;
49176: LD_ADDR_VAR 0 3
49180: PUSH
49181: LD_VAR 0 1
49185: PUSH
49186: LD_INT 1
49188: ARRAY
49189: ST_TO_ADDR
// group := list [ 2 ] ;
49190: LD_ADDR_VAR 0 4
49194: PUSH
49195: LD_VAR 0 1
49199: PUSH
49200: LD_INT 2
49202: ARRAY
49203: ST_TO_ADDR
// path := list [ 3 ] ;
49204: LD_ADDR_VAR 0 5
49208: PUSH
49209: LD_VAR 0 1
49213: PUSH
49214: LD_INT 3
49216: ARRAY
49217: ST_TO_ADDR
// flags := list [ 4 ] ;
49218: LD_ADDR_VAR 0 6
49222: PUSH
49223: LD_VAR 0 1
49227: PUSH
49228: LD_INT 4
49230: ARRAY
49231: ST_TO_ADDR
// mined := [ ] ;
49232: LD_ADDR_VAR 0 27
49236: PUSH
49237: EMPTY
49238: ST_TO_ADDR
// bombed := [ ] ;
49239: LD_ADDR_VAR 0 28
49243: PUSH
49244: EMPTY
49245: ST_TO_ADDR
// healers := [ ] ;
49246: LD_ADDR_VAR 0 31
49250: PUSH
49251: EMPTY
49252: ST_TO_ADDR
// to_heal := [ ] ;
49253: LD_ADDR_VAR 0 30
49257: PUSH
49258: EMPTY
49259: ST_TO_ADDR
// repairs := [ ] ;
49260: LD_ADDR_VAR 0 33
49264: PUSH
49265: EMPTY
49266: ST_TO_ADDR
// to_repair := [ ] ;
49267: LD_ADDR_VAR 0 32
49271: PUSH
49272: EMPTY
49273: ST_TO_ADDR
// if not group or not path then
49274: LD_VAR 0 4
49278: NOT
49279: PUSH
49280: LD_VAR 0 5
49284: NOT
49285: OR
49286: IFFALSE 49290
// exit ;
49288: GO 53802
// side := GetSide ( group [ 1 ] ) ;
49290: LD_ADDR_VAR 0 35
49294: PUSH
49295: LD_VAR 0 4
49299: PUSH
49300: LD_INT 1
49302: ARRAY
49303: PPUSH
49304: CALL_OW 255
49308: ST_TO_ADDR
// if flags then
49309: LD_VAR 0 6
49313: IFFALSE 49457
// begin f_ignore_area := flags [ 1 ] ;
49315: LD_ADDR_VAR 0 17
49319: PUSH
49320: LD_VAR 0 6
49324: PUSH
49325: LD_INT 1
49327: ARRAY
49328: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
49329: LD_ADDR_VAR 0 18
49333: PUSH
49334: LD_VAR 0 6
49338: PUSH
49339: LD_INT 2
49341: ARRAY
49342: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
49343: LD_ADDR_VAR 0 19
49347: PUSH
49348: LD_VAR 0 6
49352: PUSH
49353: LD_INT 3
49355: ARRAY
49356: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
49357: LD_ADDR_VAR 0 20
49361: PUSH
49362: LD_VAR 0 6
49366: PUSH
49367: LD_INT 4
49369: ARRAY
49370: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
49371: LD_ADDR_VAR 0 21
49375: PUSH
49376: LD_VAR 0 6
49380: PUSH
49381: LD_INT 5
49383: ARRAY
49384: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
49385: LD_ADDR_VAR 0 22
49389: PUSH
49390: LD_VAR 0 6
49394: PUSH
49395: LD_INT 6
49397: ARRAY
49398: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
49399: LD_ADDR_VAR 0 23
49403: PUSH
49404: LD_VAR 0 6
49408: PUSH
49409: LD_INT 7
49411: ARRAY
49412: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
49413: LD_ADDR_VAR 0 24
49417: PUSH
49418: LD_VAR 0 6
49422: PUSH
49423: LD_INT 8
49425: ARRAY
49426: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
49427: LD_ADDR_VAR 0 25
49431: PUSH
49432: LD_VAR 0 6
49436: PUSH
49437: LD_INT 9
49439: ARRAY
49440: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
49441: LD_ADDR_VAR 0 26
49445: PUSH
49446: LD_VAR 0 6
49450: PUSH
49451: LD_INT 10
49453: ARRAY
49454: ST_TO_ADDR
// end else
49455: GO 49537
// begin f_ignore_area := false ;
49457: LD_ADDR_VAR 0 17
49461: PUSH
49462: LD_INT 0
49464: ST_TO_ADDR
// f_capture := false ;
49465: LD_ADDR_VAR 0 18
49469: PUSH
49470: LD_INT 0
49472: ST_TO_ADDR
// f_ignore_civ := false ;
49473: LD_ADDR_VAR 0 19
49477: PUSH
49478: LD_INT 0
49480: ST_TO_ADDR
// f_murder := false ;
49481: LD_ADDR_VAR 0 20
49485: PUSH
49486: LD_INT 0
49488: ST_TO_ADDR
// f_mines := false ;
49489: LD_ADDR_VAR 0 21
49493: PUSH
49494: LD_INT 0
49496: ST_TO_ADDR
// f_repair := false ;
49497: LD_ADDR_VAR 0 22
49501: PUSH
49502: LD_INT 0
49504: ST_TO_ADDR
// f_heal := false ;
49505: LD_ADDR_VAR 0 23
49509: PUSH
49510: LD_INT 0
49512: ST_TO_ADDR
// f_spacetime := false ;
49513: LD_ADDR_VAR 0 24
49517: PUSH
49518: LD_INT 0
49520: ST_TO_ADDR
// f_attack_depot := false ;
49521: LD_ADDR_VAR 0 25
49525: PUSH
49526: LD_INT 0
49528: ST_TO_ADDR
// f_crawl := false ;
49529: LD_ADDR_VAR 0 26
49533: PUSH
49534: LD_INT 0
49536: ST_TO_ADDR
// end ; if f_heal then
49537: LD_VAR 0 23
49541: IFFALSE 49568
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
49543: LD_ADDR_VAR 0 31
49547: PUSH
49548: LD_VAR 0 4
49552: PPUSH
49553: LD_INT 25
49555: PUSH
49556: LD_INT 4
49558: PUSH
49559: EMPTY
49560: LIST
49561: LIST
49562: PPUSH
49563: CALL_OW 72
49567: ST_TO_ADDR
// if f_repair then
49568: LD_VAR 0 22
49572: IFFALSE 49599
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
49574: LD_ADDR_VAR 0 33
49578: PUSH
49579: LD_VAR 0 4
49583: PPUSH
49584: LD_INT 25
49586: PUSH
49587: LD_INT 3
49589: PUSH
49590: EMPTY
49591: LIST
49592: LIST
49593: PPUSH
49594: CALL_OW 72
49598: ST_TO_ADDR
// units_path := [ ] ;
49599: LD_ADDR_VAR 0 16
49603: PUSH
49604: EMPTY
49605: ST_TO_ADDR
// for i = 1 to group do
49606: LD_ADDR_VAR 0 7
49610: PUSH
49611: DOUBLE
49612: LD_INT 1
49614: DEC
49615: ST_TO_ADDR
49616: LD_VAR 0 4
49620: PUSH
49621: FOR_TO
49622: IFFALSE 49651
// units_path := Replace ( units_path , i , path ) ;
49624: LD_ADDR_VAR 0 16
49628: PUSH
49629: LD_VAR 0 16
49633: PPUSH
49634: LD_VAR 0 7
49638: PPUSH
49639: LD_VAR 0 5
49643: PPUSH
49644: CALL_OW 1
49648: ST_TO_ADDR
49649: GO 49621
49651: POP
49652: POP
// repeat for i = group downto 1 do
49653: LD_ADDR_VAR 0 7
49657: PUSH
49658: DOUBLE
49659: LD_VAR 0 4
49663: INC
49664: ST_TO_ADDR
49665: LD_INT 1
49667: PUSH
49668: FOR_DOWNTO
49669: IFFALSE 53765
// begin wait ( 5 ) ;
49671: LD_INT 5
49673: PPUSH
49674: CALL_OW 67
// tmp := [ ] ;
49678: LD_ADDR_VAR 0 14
49682: PUSH
49683: EMPTY
49684: ST_TO_ADDR
// attacking := false ;
49685: LD_ADDR_VAR 0 29
49689: PUSH
49690: LD_INT 0
49692: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
49693: LD_VAR 0 4
49697: PUSH
49698: LD_VAR 0 7
49702: ARRAY
49703: PPUSH
49704: CALL_OW 301
49708: PUSH
49709: LD_VAR 0 4
49713: PUSH
49714: LD_VAR 0 7
49718: ARRAY
49719: NOT
49720: OR
49721: IFFALSE 49830
// begin if GetType ( group [ i ] ) = unit_human then
49723: LD_VAR 0 4
49727: PUSH
49728: LD_VAR 0 7
49732: ARRAY
49733: PPUSH
49734: CALL_OW 247
49738: PUSH
49739: LD_INT 1
49741: EQUAL
49742: IFFALSE 49788
// begin to_heal := to_heal diff group [ i ] ;
49744: LD_ADDR_VAR 0 30
49748: PUSH
49749: LD_VAR 0 30
49753: PUSH
49754: LD_VAR 0 4
49758: PUSH
49759: LD_VAR 0 7
49763: ARRAY
49764: DIFF
49765: ST_TO_ADDR
// healers := healers diff group [ i ] ;
49766: LD_ADDR_VAR 0 31
49770: PUSH
49771: LD_VAR 0 31
49775: PUSH
49776: LD_VAR 0 4
49780: PUSH
49781: LD_VAR 0 7
49785: ARRAY
49786: DIFF
49787: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
49788: LD_ADDR_VAR 0 4
49792: PUSH
49793: LD_VAR 0 4
49797: PPUSH
49798: LD_VAR 0 7
49802: PPUSH
49803: CALL_OW 3
49807: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
49808: LD_ADDR_VAR 0 16
49812: PUSH
49813: LD_VAR 0 16
49817: PPUSH
49818: LD_VAR 0 7
49822: PPUSH
49823: CALL_OW 3
49827: ST_TO_ADDR
// continue ;
49828: GO 49668
// end ; if f_repair then
49830: LD_VAR 0 22
49834: IFFALSE 50323
// begin if GetType ( group [ i ] ) = unit_vehicle then
49836: LD_VAR 0 4
49840: PUSH
49841: LD_VAR 0 7
49845: ARRAY
49846: PPUSH
49847: CALL_OW 247
49851: PUSH
49852: LD_INT 2
49854: EQUAL
49855: IFFALSE 50045
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
49857: LD_VAR 0 4
49861: PUSH
49862: LD_VAR 0 7
49866: ARRAY
49867: PPUSH
49868: CALL_OW 256
49872: PUSH
49873: LD_INT 700
49875: LESS
49876: PUSH
49877: LD_VAR 0 4
49881: PUSH
49882: LD_VAR 0 7
49886: ARRAY
49887: PUSH
49888: LD_VAR 0 32
49892: IN
49893: NOT
49894: AND
49895: IFFALSE 49919
// to_repair := to_repair union group [ i ] ;
49897: LD_ADDR_VAR 0 32
49901: PUSH
49902: LD_VAR 0 32
49906: PUSH
49907: LD_VAR 0 4
49911: PUSH
49912: LD_VAR 0 7
49916: ARRAY
49917: UNION
49918: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
49919: LD_VAR 0 4
49923: PUSH
49924: LD_VAR 0 7
49928: ARRAY
49929: PPUSH
49930: CALL_OW 256
49934: PUSH
49935: LD_INT 1000
49937: EQUAL
49938: PUSH
49939: LD_VAR 0 4
49943: PUSH
49944: LD_VAR 0 7
49948: ARRAY
49949: PUSH
49950: LD_VAR 0 32
49954: IN
49955: AND
49956: IFFALSE 49980
// to_repair := to_repair diff group [ i ] ;
49958: LD_ADDR_VAR 0 32
49962: PUSH
49963: LD_VAR 0 32
49967: PUSH
49968: LD_VAR 0 4
49972: PUSH
49973: LD_VAR 0 7
49977: ARRAY
49978: DIFF
49979: ST_TO_ADDR
// if group [ i ] in to_repair then
49980: LD_VAR 0 4
49984: PUSH
49985: LD_VAR 0 7
49989: ARRAY
49990: PUSH
49991: LD_VAR 0 32
49995: IN
49996: IFFALSE 50043
// begin if not IsInArea ( group [ i ] , f_repair ) then
49998: LD_VAR 0 4
50002: PUSH
50003: LD_VAR 0 7
50007: ARRAY
50008: PPUSH
50009: LD_VAR 0 22
50013: PPUSH
50014: CALL_OW 308
50018: NOT
50019: IFFALSE 50041
// ComMoveToArea ( group [ i ] , f_repair ) ;
50021: LD_VAR 0 4
50025: PUSH
50026: LD_VAR 0 7
50030: ARRAY
50031: PPUSH
50032: LD_VAR 0 22
50036: PPUSH
50037: CALL_OW 113
// continue ;
50041: GO 49668
// end ; end else
50043: GO 50323
// if group [ i ] in repairs then
50045: LD_VAR 0 4
50049: PUSH
50050: LD_VAR 0 7
50054: ARRAY
50055: PUSH
50056: LD_VAR 0 33
50060: IN
50061: IFFALSE 50323
// begin if IsInUnit ( group [ i ] ) then
50063: LD_VAR 0 4
50067: PUSH
50068: LD_VAR 0 7
50072: ARRAY
50073: PPUSH
50074: CALL_OW 310
50078: IFFALSE 50146
// begin z := IsInUnit ( group [ i ] ) ;
50080: LD_ADDR_VAR 0 13
50084: PUSH
50085: LD_VAR 0 4
50089: PUSH
50090: LD_VAR 0 7
50094: ARRAY
50095: PPUSH
50096: CALL_OW 310
50100: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
50101: LD_VAR 0 13
50105: PUSH
50106: LD_VAR 0 32
50110: IN
50111: PUSH
50112: LD_VAR 0 13
50116: PPUSH
50117: LD_VAR 0 22
50121: PPUSH
50122: CALL_OW 308
50126: AND
50127: IFFALSE 50144
// ComExitVehicle ( group [ i ] ) ;
50129: LD_VAR 0 4
50133: PUSH
50134: LD_VAR 0 7
50138: ARRAY
50139: PPUSH
50140: CALL_OW 121
// end else
50144: GO 50323
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
50146: LD_ADDR_VAR 0 13
50150: PUSH
50151: LD_VAR 0 4
50155: PPUSH
50156: LD_INT 95
50158: PUSH
50159: LD_VAR 0 22
50163: PUSH
50164: EMPTY
50165: LIST
50166: LIST
50167: PUSH
50168: LD_INT 58
50170: PUSH
50171: EMPTY
50172: LIST
50173: PUSH
50174: EMPTY
50175: LIST
50176: LIST
50177: PPUSH
50178: CALL_OW 72
50182: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
50183: LD_VAR 0 4
50187: PUSH
50188: LD_VAR 0 7
50192: ARRAY
50193: PPUSH
50194: CALL_OW 314
50198: NOT
50199: IFFALSE 50321
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
50201: LD_ADDR_VAR 0 10
50205: PUSH
50206: LD_VAR 0 13
50210: PPUSH
50211: LD_VAR 0 4
50215: PUSH
50216: LD_VAR 0 7
50220: ARRAY
50221: PPUSH
50222: CALL_OW 74
50226: ST_TO_ADDR
// if not x then
50227: LD_VAR 0 10
50231: NOT
50232: IFFALSE 50236
// continue ;
50234: GO 49668
// if GetLives ( x ) < 1000 then
50236: LD_VAR 0 10
50240: PPUSH
50241: CALL_OW 256
50245: PUSH
50246: LD_INT 1000
50248: LESS
50249: IFFALSE 50273
// ComRepairVehicle ( group [ i ] , x ) else
50251: LD_VAR 0 4
50255: PUSH
50256: LD_VAR 0 7
50260: ARRAY
50261: PPUSH
50262: LD_VAR 0 10
50266: PPUSH
50267: CALL_OW 129
50271: GO 50321
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
50273: LD_VAR 0 23
50277: PUSH
50278: LD_VAR 0 4
50282: PUSH
50283: LD_VAR 0 7
50287: ARRAY
50288: PPUSH
50289: CALL_OW 256
50293: PUSH
50294: LD_INT 1000
50296: LESS
50297: AND
50298: NOT
50299: IFFALSE 50321
// ComEnterUnit ( group [ i ] , x ) ;
50301: LD_VAR 0 4
50305: PUSH
50306: LD_VAR 0 7
50310: ARRAY
50311: PPUSH
50312: LD_VAR 0 10
50316: PPUSH
50317: CALL_OW 120
// end ; continue ;
50321: GO 49668
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
50323: LD_VAR 0 23
50327: PUSH
50328: LD_VAR 0 4
50332: PUSH
50333: LD_VAR 0 7
50337: ARRAY
50338: PPUSH
50339: CALL_OW 247
50343: PUSH
50344: LD_INT 1
50346: EQUAL
50347: AND
50348: IFFALSE 50826
// begin if group [ i ] in healers then
50350: LD_VAR 0 4
50354: PUSH
50355: LD_VAR 0 7
50359: ARRAY
50360: PUSH
50361: LD_VAR 0 31
50365: IN
50366: IFFALSE 50639
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
50368: LD_VAR 0 4
50372: PUSH
50373: LD_VAR 0 7
50377: ARRAY
50378: PPUSH
50379: LD_VAR 0 23
50383: PPUSH
50384: CALL_OW 308
50388: NOT
50389: PUSH
50390: LD_VAR 0 4
50394: PUSH
50395: LD_VAR 0 7
50399: ARRAY
50400: PPUSH
50401: CALL_OW 314
50405: NOT
50406: AND
50407: IFFALSE 50431
// ComMoveToArea ( group [ i ] , f_heal ) else
50409: LD_VAR 0 4
50413: PUSH
50414: LD_VAR 0 7
50418: ARRAY
50419: PPUSH
50420: LD_VAR 0 23
50424: PPUSH
50425: CALL_OW 113
50429: GO 50637
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
50431: LD_VAR 0 4
50435: PUSH
50436: LD_VAR 0 7
50440: ARRAY
50441: PPUSH
50442: CALL 49049 0 1
50446: PPUSH
50447: CALL_OW 256
50451: PUSH
50452: LD_INT 1000
50454: EQUAL
50455: IFFALSE 50474
// ComStop ( group [ i ] ) else
50457: LD_VAR 0 4
50461: PUSH
50462: LD_VAR 0 7
50466: ARRAY
50467: PPUSH
50468: CALL_OW 141
50472: GO 50637
// if not HasTask ( group [ i ] ) and to_heal then
50474: LD_VAR 0 4
50478: PUSH
50479: LD_VAR 0 7
50483: ARRAY
50484: PPUSH
50485: CALL_OW 314
50489: NOT
50490: PUSH
50491: LD_VAR 0 30
50495: AND
50496: IFFALSE 50637
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
50498: LD_ADDR_VAR 0 13
50502: PUSH
50503: LD_VAR 0 30
50507: PPUSH
50508: LD_INT 3
50510: PUSH
50511: LD_INT 54
50513: PUSH
50514: EMPTY
50515: LIST
50516: PUSH
50517: EMPTY
50518: LIST
50519: LIST
50520: PPUSH
50521: CALL_OW 72
50525: PPUSH
50526: LD_VAR 0 4
50530: PUSH
50531: LD_VAR 0 7
50535: ARRAY
50536: PPUSH
50537: CALL_OW 74
50541: ST_TO_ADDR
// if z then
50542: LD_VAR 0 13
50546: IFFALSE 50637
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
50548: LD_INT 91
50550: PUSH
50551: LD_VAR 0 13
50555: PUSH
50556: LD_INT 10
50558: PUSH
50559: EMPTY
50560: LIST
50561: LIST
50562: LIST
50563: PUSH
50564: LD_INT 81
50566: PUSH
50567: LD_VAR 0 13
50571: PPUSH
50572: CALL_OW 255
50576: PUSH
50577: EMPTY
50578: LIST
50579: LIST
50580: PUSH
50581: EMPTY
50582: LIST
50583: LIST
50584: PPUSH
50585: CALL_OW 69
50589: PUSH
50590: LD_INT 0
50592: EQUAL
50593: IFFALSE 50617
// ComHeal ( group [ i ] , z ) else
50595: LD_VAR 0 4
50599: PUSH
50600: LD_VAR 0 7
50604: ARRAY
50605: PPUSH
50606: LD_VAR 0 13
50610: PPUSH
50611: CALL_OW 128
50615: GO 50637
// ComMoveToArea ( group [ i ] , f_heal ) ;
50617: LD_VAR 0 4
50621: PUSH
50622: LD_VAR 0 7
50626: ARRAY
50627: PPUSH
50628: LD_VAR 0 23
50632: PPUSH
50633: CALL_OW 113
// end ; continue ;
50637: GO 49668
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
50639: LD_VAR 0 4
50643: PUSH
50644: LD_VAR 0 7
50648: ARRAY
50649: PPUSH
50650: CALL_OW 256
50654: PUSH
50655: LD_INT 700
50657: LESS
50658: PUSH
50659: LD_VAR 0 4
50663: PUSH
50664: LD_VAR 0 7
50668: ARRAY
50669: PUSH
50670: LD_VAR 0 30
50674: IN
50675: NOT
50676: AND
50677: IFFALSE 50701
// to_heal := to_heal union group [ i ] ;
50679: LD_ADDR_VAR 0 30
50683: PUSH
50684: LD_VAR 0 30
50688: PUSH
50689: LD_VAR 0 4
50693: PUSH
50694: LD_VAR 0 7
50698: ARRAY
50699: UNION
50700: ST_TO_ADDR
// if group [ i ] in to_heal then
50701: LD_VAR 0 4
50705: PUSH
50706: LD_VAR 0 7
50710: ARRAY
50711: PUSH
50712: LD_VAR 0 30
50716: IN
50717: IFFALSE 50826
// begin if GetLives ( group [ i ] ) = 1000 then
50719: LD_VAR 0 4
50723: PUSH
50724: LD_VAR 0 7
50728: ARRAY
50729: PPUSH
50730: CALL_OW 256
50734: PUSH
50735: LD_INT 1000
50737: EQUAL
50738: IFFALSE 50764
// to_heal := to_heal diff group [ i ] else
50740: LD_ADDR_VAR 0 30
50744: PUSH
50745: LD_VAR 0 30
50749: PUSH
50750: LD_VAR 0 4
50754: PUSH
50755: LD_VAR 0 7
50759: ARRAY
50760: DIFF
50761: ST_TO_ADDR
50762: GO 50826
// begin if not IsInArea ( group [ i ] , to_heal ) then
50764: LD_VAR 0 4
50768: PUSH
50769: LD_VAR 0 7
50773: ARRAY
50774: PPUSH
50775: LD_VAR 0 30
50779: PPUSH
50780: CALL_OW 308
50784: NOT
50785: IFFALSE 50809
// ComMoveToArea ( group [ i ] , f_heal ) else
50787: LD_VAR 0 4
50791: PUSH
50792: LD_VAR 0 7
50796: ARRAY
50797: PPUSH
50798: LD_VAR 0 23
50802: PPUSH
50803: CALL_OW 113
50807: GO 50824
// ComHold ( group [ i ] ) ;
50809: LD_VAR 0 4
50813: PUSH
50814: LD_VAR 0 7
50818: ARRAY
50819: PPUSH
50820: CALL_OW 140
// continue ;
50824: GO 49668
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
50826: LD_VAR 0 4
50830: PUSH
50831: LD_VAR 0 7
50835: ARRAY
50836: PPUSH
50837: LD_INT 10
50839: PPUSH
50840: CALL 47446 0 2
50844: NOT
50845: PUSH
50846: LD_VAR 0 16
50850: PUSH
50851: LD_VAR 0 7
50855: ARRAY
50856: PUSH
50857: EMPTY
50858: EQUAL
50859: NOT
50860: AND
50861: IFFALSE 51127
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
50863: LD_VAR 0 4
50867: PUSH
50868: LD_VAR 0 7
50872: ARRAY
50873: PPUSH
50874: CALL_OW 262
50878: PUSH
50879: LD_INT 1
50881: PUSH
50882: LD_INT 2
50884: PUSH
50885: EMPTY
50886: LIST
50887: LIST
50888: IN
50889: IFFALSE 50930
// if GetFuel ( group [ i ] ) < 10 then
50891: LD_VAR 0 4
50895: PUSH
50896: LD_VAR 0 7
50900: ARRAY
50901: PPUSH
50902: CALL_OW 261
50906: PUSH
50907: LD_INT 10
50909: LESS
50910: IFFALSE 50930
// SetFuel ( group [ i ] , 12 ) ;
50912: LD_VAR 0 4
50916: PUSH
50917: LD_VAR 0 7
50921: ARRAY
50922: PPUSH
50923: LD_INT 12
50925: PPUSH
50926: CALL_OW 240
// if units_path [ i ] then
50930: LD_VAR 0 16
50934: PUSH
50935: LD_VAR 0 7
50939: ARRAY
50940: IFFALSE 51125
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
50942: LD_VAR 0 4
50946: PUSH
50947: LD_VAR 0 7
50951: ARRAY
50952: PPUSH
50953: LD_VAR 0 16
50957: PUSH
50958: LD_VAR 0 7
50962: ARRAY
50963: PUSH
50964: LD_INT 1
50966: ARRAY
50967: PUSH
50968: LD_INT 1
50970: ARRAY
50971: PPUSH
50972: LD_VAR 0 16
50976: PUSH
50977: LD_VAR 0 7
50981: ARRAY
50982: PUSH
50983: LD_INT 1
50985: ARRAY
50986: PUSH
50987: LD_INT 2
50989: ARRAY
50990: PPUSH
50991: CALL_OW 297
50995: PUSH
50996: LD_INT 6
50998: GREATER
50999: IFFALSE 51074
// begin if not HasTask ( group [ i ] ) then
51001: LD_VAR 0 4
51005: PUSH
51006: LD_VAR 0 7
51010: ARRAY
51011: PPUSH
51012: CALL_OW 314
51016: NOT
51017: IFFALSE 51072
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
51019: LD_VAR 0 4
51023: PUSH
51024: LD_VAR 0 7
51028: ARRAY
51029: PPUSH
51030: LD_VAR 0 16
51034: PUSH
51035: LD_VAR 0 7
51039: ARRAY
51040: PUSH
51041: LD_INT 1
51043: ARRAY
51044: PUSH
51045: LD_INT 1
51047: ARRAY
51048: PPUSH
51049: LD_VAR 0 16
51053: PUSH
51054: LD_VAR 0 7
51058: ARRAY
51059: PUSH
51060: LD_INT 1
51062: ARRAY
51063: PUSH
51064: LD_INT 2
51066: ARRAY
51067: PPUSH
51068: CALL_OW 114
// end else
51072: GO 51125
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
51074: LD_ADDR_VAR 0 15
51078: PUSH
51079: LD_VAR 0 16
51083: PUSH
51084: LD_VAR 0 7
51088: ARRAY
51089: PPUSH
51090: LD_INT 1
51092: PPUSH
51093: CALL_OW 3
51097: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
51098: LD_ADDR_VAR 0 16
51102: PUSH
51103: LD_VAR 0 16
51107: PPUSH
51108: LD_VAR 0 7
51112: PPUSH
51113: LD_VAR 0 15
51117: PPUSH
51118: CALL_OW 1
51122: ST_TO_ADDR
// continue ;
51123: GO 49668
// end ; end ; end else
51125: GO 53763
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
51127: LD_ADDR_VAR 0 14
51131: PUSH
51132: LD_INT 81
51134: PUSH
51135: LD_VAR 0 4
51139: PUSH
51140: LD_VAR 0 7
51144: ARRAY
51145: PPUSH
51146: CALL_OW 255
51150: PUSH
51151: EMPTY
51152: LIST
51153: LIST
51154: PPUSH
51155: CALL_OW 69
51159: ST_TO_ADDR
// if not tmp then
51160: LD_VAR 0 14
51164: NOT
51165: IFFALSE 51169
// continue ;
51167: GO 49668
// if f_ignore_area then
51169: LD_VAR 0 17
51173: IFFALSE 51261
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
51175: LD_ADDR_VAR 0 15
51179: PUSH
51180: LD_VAR 0 14
51184: PPUSH
51185: LD_INT 3
51187: PUSH
51188: LD_INT 92
51190: PUSH
51191: LD_VAR 0 17
51195: PUSH
51196: LD_INT 1
51198: ARRAY
51199: PUSH
51200: LD_VAR 0 17
51204: PUSH
51205: LD_INT 2
51207: ARRAY
51208: PUSH
51209: LD_VAR 0 17
51213: PUSH
51214: LD_INT 3
51216: ARRAY
51217: PUSH
51218: EMPTY
51219: LIST
51220: LIST
51221: LIST
51222: LIST
51223: PUSH
51224: EMPTY
51225: LIST
51226: LIST
51227: PPUSH
51228: CALL_OW 72
51232: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51233: LD_VAR 0 14
51237: PUSH
51238: LD_VAR 0 15
51242: DIFF
51243: IFFALSE 51261
// tmp := tmp diff tmp2 ;
51245: LD_ADDR_VAR 0 14
51249: PUSH
51250: LD_VAR 0 14
51254: PUSH
51255: LD_VAR 0 15
51259: DIFF
51260: ST_TO_ADDR
// end ; if not f_murder then
51261: LD_VAR 0 20
51265: NOT
51266: IFFALSE 51324
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
51268: LD_ADDR_VAR 0 15
51272: PUSH
51273: LD_VAR 0 14
51277: PPUSH
51278: LD_INT 3
51280: PUSH
51281: LD_INT 50
51283: PUSH
51284: EMPTY
51285: LIST
51286: PUSH
51287: EMPTY
51288: LIST
51289: LIST
51290: PPUSH
51291: CALL_OW 72
51295: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51296: LD_VAR 0 14
51300: PUSH
51301: LD_VAR 0 15
51305: DIFF
51306: IFFALSE 51324
// tmp := tmp diff tmp2 ;
51308: LD_ADDR_VAR 0 14
51312: PUSH
51313: LD_VAR 0 14
51317: PUSH
51318: LD_VAR 0 15
51322: DIFF
51323: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
51324: LD_ADDR_VAR 0 14
51328: PUSH
51329: LD_VAR 0 4
51333: PUSH
51334: LD_VAR 0 7
51338: ARRAY
51339: PPUSH
51340: LD_VAR 0 14
51344: PPUSH
51345: LD_INT 1
51347: PPUSH
51348: LD_INT 1
51350: PPUSH
51351: CALL 21089 0 4
51355: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
51356: LD_VAR 0 4
51360: PUSH
51361: LD_VAR 0 7
51365: ARRAY
51366: PPUSH
51367: CALL_OW 257
51371: PUSH
51372: LD_INT 1
51374: EQUAL
51375: IFFALSE 51823
// begin if WantPlant ( group [ i ] ) then
51377: LD_VAR 0 4
51381: PUSH
51382: LD_VAR 0 7
51386: ARRAY
51387: PPUSH
51388: CALL 20590 0 1
51392: IFFALSE 51396
// continue ;
51394: GO 49668
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
51396: LD_VAR 0 18
51400: PUSH
51401: LD_VAR 0 4
51405: PUSH
51406: LD_VAR 0 7
51410: ARRAY
51411: PPUSH
51412: CALL_OW 310
51416: NOT
51417: AND
51418: PUSH
51419: LD_VAR 0 14
51423: PUSH
51424: LD_INT 1
51426: ARRAY
51427: PUSH
51428: LD_VAR 0 14
51432: PPUSH
51433: LD_INT 21
51435: PUSH
51436: LD_INT 2
51438: PUSH
51439: EMPTY
51440: LIST
51441: LIST
51442: PUSH
51443: LD_INT 58
51445: PUSH
51446: EMPTY
51447: LIST
51448: PUSH
51449: EMPTY
51450: LIST
51451: LIST
51452: PPUSH
51453: CALL_OW 72
51457: IN
51458: AND
51459: IFFALSE 51495
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
51461: LD_VAR 0 4
51465: PUSH
51466: LD_VAR 0 7
51470: ARRAY
51471: PPUSH
51472: LD_VAR 0 14
51476: PUSH
51477: LD_INT 1
51479: ARRAY
51480: PPUSH
51481: CALL_OW 120
// attacking := true ;
51485: LD_ADDR_VAR 0 29
51489: PUSH
51490: LD_INT 1
51492: ST_TO_ADDR
// continue ;
51493: GO 49668
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
51495: LD_VAR 0 26
51499: PUSH
51500: LD_VAR 0 4
51504: PUSH
51505: LD_VAR 0 7
51509: ARRAY
51510: PPUSH
51511: CALL_OW 257
51515: PUSH
51516: LD_INT 1
51518: EQUAL
51519: AND
51520: PUSH
51521: LD_VAR 0 4
51525: PUSH
51526: LD_VAR 0 7
51530: ARRAY
51531: PPUSH
51532: CALL_OW 256
51536: PUSH
51537: LD_INT 800
51539: LESS
51540: AND
51541: PUSH
51542: LD_VAR 0 4
51546: PUSH
51547: LD_VAR 0 7
51551: ARRAY
51552: PPUSH
51553: CALL_OW 318
51557: NOT
51558: AND
51559: IFFALSE 51576
// ComCrawl ( group [ i ] ) ;
51561: LD_VAR 0 4
51565: PUSH
51566: LD_VAR 0 7
51570: ARRAY
51571: PPUSH
51572: CALL_OW 137
// if f_mines then
51576: LD_VAR 0 21
51580: IFFALSE 51823
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
51582: LD_VAR 0 14
51586: PUSH
51587: LD_INT 1
51589: ARRAY
51590: PPUSH
51591: CALL_OW 247
51595: PUSH
51596: LD_INT 3
51598: EQUAL
51599: PUSH
51600: LD_VAR 0 14
51604: PUSH
51605: LD_INT 1
51607: ARRAY
51608: PUSH
51609: LD_VAR 0 27
51613: IN
51614: NOT
51615: AND
51616: IFFALSE 51823
// begin x := GetX ( tmp [ 1 ] ) ;
51618: LD_ADDR_VAR 0 10
51622: PUSH
51623: LD_VAR 0 14
51627: PUSH
51628: LD_INT 1
51630: ARRAY
51631: PPUSH
51632: CALL_OW 250
51636: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
51637: LD_ADDR_VAR 0 11
51641: PUSH
51642: LD_VAR 0 14
51646: PUSH
51647: LD_INT 1
51649: ARRAY
51650: PPUSH
51651: CALL_OW 251
51655: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
51656: LD_ADDR_VAR 0 12
51660: PUSH
51661: LD_VAR 0 4
51665: PUSH
51666: LD_VAR 0 7
51670: ARRAY
51671: PPUSH
51672: CALL 47531 0 1
51676: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
51677: LD_VAR 0 4
51681: PUSH
51682: LD_VAR 0 7
51686: ARRAY
51687: PPUSH
51688: LD_VAR 0 10
51692: PPUSH
51693: LD_VAR 0 11
51697: PPUSH
51698: LD_VAR 0 14
51702: PUSH
51703: LD_INT 1
51705: ARRAY
51706: PPUSH
51707: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
51711: LD_VAR 0 4
51715: PUSH
51716: LD_VAR 0 7
51720: ARRAY
51721: PPUSH
51722: LD_VAR 0 10
51726: PPUSH
51727: LD_VAR 0 12
51731: PPUSH
51732: LD_INT 7
51734: PPUSH
51735: CALL_OW 272
51739: PPUSH
51740: LD_VAR 0 11
51744: PPUSH
51745: LD_VAR 0 12
51749: PPUSH
51750: LD_INT 7
51752: PPUSH
51753: CALL_OW 273
51757: PPUSH
51758: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
51762: LD_VAR 0 4
51766: PUSH
51767: LD_VAR 0 7
51771: ARRAY
51772: PPUSH
51773: LD_INT 71
51775: PPUSH
51776: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
51780: LD_ADDR_VAR 0 27
51784: PUSH
51785: LD_VAR 0 27
51789: PPUSH
51790: LD_VAR 0 27
51794: PUSH
51795: LD_INT 1
51797: PLUS
51798: PPUSH
51799: LD_VAR 0 14
51803: PUSH
51804: LD_INT 1
51806: ARRAY
51807: PPUSH
51808: CALL_OW 1
51812: ST_TO_ADDR
// attacking := true ;
51813: LD_ADDR_VAR 0 29
51817: PUSH
51818: LD_INT 1
51820: ST_TO_ADDR
// continue ;
51821: GO 49668
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
51823: LD_VAR 0 4
51827: PUSH
51828: LD_VAR 0 7
51832: ARRAY
51833: PPUSH
51834: CALL_OW 257
51838: PUSH
51839: LD_INT 17
51841: EQUAL
51842: PUSH
51843: LD_VAR 0 4
51847: PUSH
51848: LD_VAR 0 7
51852: ARRAY
51853: PPUSH
51854: CALL_OW 110
51858: PUSH
51859: LD_INT 71
51861: EQUAL
51862: NOT
51863: AND
51864: IFFALSE 52010
// begin attacking := false ;
51866: LD_ADDR_VAR 0 29
51870: PUSH
51871: LD_INT 0
51873: ST_TO_ADDR
// k := 5 ;
51874: LD_ADDR_VAR 0 9
51878: PUSH
51879: LD_INT 5
51881: ST_TO_ADDR
// if tmp < k then
51882: LD_VAR 0 14
51886: PUSH
51887: LD_VAR 0 9
51891: LESS
51892: IFFALSE 51904
// k := tmp ;
51894: LD_ADDR_VAR 0 9
51898: PUSH
51899: LD_VAR 0 14
51903: ST_TO_ADDR
// for j = 1 to k do
51904: LD_ADDR_VAR 0 8
51908: PUSH
51909: DOUBLE
51910: LD_INT 1
51912: DEC
51913: ST_TO_ADDR
51914: LD_VAR 0 9
51918: PUSH
51919: FOR_TO
51920: IFFALSE 52008
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
51922: LD_VAR 0 14
51926: PUSH
51927: LD_VAR 0 8
51931: ARRAY
51932: PUSH
51933: LD_VAR 0 14
51937: PPUSH
51938: LD_INT 58
51940: PUSH
51941: EMPTY
51942: LIST
51943: PPUSH
51944: CALL_OW 72
51948: IN
51949: NOT
51950: IFFALSE 52006
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
51952: LD_VAR 0 4
51956: PUSH
51957: LD_VAR 0 7
51961: ARRAY
51962: PPUSH
51963: LD_VAR 0 14
51967: PUSH
51968: LD_VAR 0 8
51972: ARRAY
51973: PPUSH
51974: CALL_OW 115
// attacking := true ;
51978: LD_ADDR_VAR 0 29
51982: PUSH
51983: LD_INT 1
51985: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
51986: LD_VAR 0 4
51990: PUSH
51991: LD_VAR 0 7
51995: ARRAY
51996: PPUSH
51997: LD_INT 71
51999: PPUSH
52000: CALL_OW 109
// continue ;
52004: GO 51919
// end ; end ;
52006: GO 51919
52008: POP
52009: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
52010: LD_VAR 0 4
52014: PUSH
52015: LD_VAR 0 7
52019: ARRAY
52020: PPUSH
52021: CALL_OW 257
52025: PUSH
52026: LD_INT 8
52028: EQUAL
52029: PUSH
52030: LD_VAR 0 4
52034: PUSH
52035: LD_VAR 0 7
52039: ARRAY
52040: PPUSH
52041: CALL_OW 264
52045: PUSH
52046: LD_INT 28
52048: PUSH
52049: LD_INT 45
52051: PUSH
52052: LD_INT 7
52054: PUSH
52055: LD_INT 47
52057: PUSH
52058: EMPTY
52059: LIST
52060: LIST
52061: LIST
52062: LIST
52063: IN
52064: OR
52065: IFFALSE 52295
// begin attacking := false ;
52067: LD_ADDR_VAR 0 29
52071: PUSH
52072: LD_INT 0
52074: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
52075: LD_VAR 0 14
52079: PUSH
52080: LD_INT 1
52082: ARRAY
52083: PPUSH
52084: CALL_OW 266
52088: PUSH
52089: LD_INT 32
52091: PUSH
52092: LD_INT 31
52094: PUSH
52095: LD_INT 33
52097: PUSH
52098: LD_INT 4
52100: PUSH
52101: LD_INT 5
52103: PUSH
52104: EMPTY
52105: LIST
52106: LIST
52107: LIST
52108: LIST
52109: LIST
52110: IN
52111: IFFALSE 52295
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
52113: LD_ADDR_VAR 0 9
52117: PUSH
52118: LD_VAR 0 14
52122: PUSH
52123: LD_INT 1
52125: ARRAY
52126: PPUSH
52127: CALL_OW 266
52131: PPUSH
52132: LD_VAR 0 14
52136: PUSH
52137: LD_INT 1
52139: ARRAY
52140: PPUSH
52141: CALL_OW 250
52145: PPUSH
52146: LD_VAR 0 14
52150: PUSH
52151: LD_INT 1
52153: ARRAY
52154: PPUSH
52155: CALL_OW 251
52159: PPUSH
52160: LD_VAR 0 14
52164: PUSH
52165: LD_INT 1
52167: ARRAY
52168: PPUSH
52169: CALL_OW 254
52173: PPUSH
52174: LD_VAR 0 14
52178: PUSH
52179: LD_INT 1
52181: ARRAY
52182: PPUSH
52183: CALL_OW 248
52187: PPUSH
52188: LD_INT 0
52190: PPUSH
52191: CALL 28901 0 6
52195: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
52196: LD_ADDR_VAR 0 8
52200: PUSH
52201: LD_VAR 0 4
52205: PUSH
52206: LD_VAR 0 7
52210: ARRAY
52211: PPUSH
52212: LD_VAR 0 9
52216: PPUSH
52217: CALL 47594 0 2
52221: ST_TO_ADDR
// if j then
52222: LD_VAR 0 8
52226: IFFALSE 52295
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
52228: LD_VAR 0 8
52232: PUSH
52233: LD_INT 1
52235: ARRAY
52236: PPUSH
52237: LD_VAR 0 8
52241: PUSH
52242: LD_INT 2
52244: ARRAY
52245: PPUSH
52246: CALL_OW 488
52250: IFFALSE 52295
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
52252: LD_VAR 0 4
52256: PUSH
52257: LD_VAR 0 7
52261: ARRAY
52262: PPUSH
52263: LD_VAR 0 8
52267: PUSH
52268: LD_INT 1
52270: ARRAY
52271: PPUSH
52272: LD_VAR 0 8
52276: PUSH
52277: LD_INT 2
52279: ARRAY
52280: PPUSH
52281: CALL_OW 116
// attacking := true ;
52285: LD_ADDR_VAR 0 29
52289: PUSH
52290: LD_INT 1
52292: ST_TO_ADDR
// continue ;
52293: GO 49668
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
52295: LD_VAR 0 4
52299: PUSH
52300: LD_VAR 0 7
52304: ARRAY
52305: PPUSH
52306: CALL_OW 265
52310: PUSH
52311: LD_INT 11
52313: EQUAL
52314: IFFALSE 52592
// begin k := 10 ;
52316: LD_ADDR_VAR 0 9
52320: PUSH
52321: LD_INT 10
52323: ST_TO_ADDR
// x := 0 ;
52324: LD_ADDR_VAR 0 10
52328: PUSH
52329: LD_INT 0
52331: ST_TO_ADDR
// if tmp < k then
52332: LD_VAR 0 14
52336: PUSH
52337: LD_VAR 0 9
52341: LESS
52342: IFFALSE 52354
// k := tmp ;
52344: LD_ADDR_VAR 0 9
52348: PUSH
52349: LD_VAR 0 14
52353: ST_TO_ADDR
// for j = k downto 1 do
52354: LD_ADDR_VAR 0 8
52358: PUSH
52359: DOUBLE
52360: LD_VAR 0 9
52364: INC
52365: ST_TO_ADDR
52366: LD_INT 1
52368: PUSH
52369: FOR_DOWNTO
52370: IFFALSE 52445
// begin if GetType ( tmp [ j ] ) = unit_human then
52372: LD_VAR 0 14
52376: PUSH
52377: LD_VAR 0 8
52381: ARRAY
52382: PPUSH
52383: CALL_OW 247
52387: PUSH
52388: LD_INT 1
52390: EQUAL
52391: IFFALSE 52443
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
52393: LD_VAR 0 4
52397: PUSH
52398: LD_VAR 0 7
52402: ARRAY
52403: PPUSH
52404: LD_VAR 0 14
52408: PUSH
52409: LD_VAR 0 8
52413: ARRAY
52414: PPUSH
52415: CALL 47865 0 2
// x := tmp [ j ] ;
52419: LD_ADDR_VAR 0 10
52423: PUSH
52424: LD_VAR 0 14
52428: PUSH
52429: LD_VAR 0 8
52433: ARRAY
52434: ST_TO_ADDR
// attacking := true ;
52435: LD_ADDR_VAR 0 29
52439: PUSH
52440: LD_INT 1
52442: ST_TO_ADDR
// end ; end ;
52443: GO 52369
52445: POP
52446: POP
// if not x then
52447: LD_VAR 0 10
52451: NOT
52452: IFFALSE 52592
// begin attacking := true ;
52454: LD_ADDR_VAR 0 29
52458: PUSH
52459: LD_INT 1
52461: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
52462: LD_VAR 0 4
52466: PUSH
52467: LD_VAR 0 7
52471: ARRAY
52472: PPUSH
52473: CALL_OW 250
52477: PPUSH
52478: LD_VAR 0 4
52482: PUSH
52483: LD_VAR 0 7
52487: ARRAY
52488: PPUSH
52489: CALL_OW 251
52493: PPUSH
52494: CALL_OW 546
52498: PUSH
52499: LD_INT 2
52501: ARRAY
52502: PUSH
52503: LD_VAR 0 14
52507: PUSH
52508: LD_INT 1
52510: ARRAY
52511: PPUSH
52512: CALL_OW 250
52516: PPUSH
52517: LD_VAR 0 14
52521: PUSH
52522: LD_INT 1
52524: ARRAY
52525: PPUSH
52526: CALL_OW 251
52530: PPUSH
52531: CALL_OW 546
52535: PUSH
52536: LD_INT 2
52538: ARRAY
52539: EQUAL
52540: IFFALSE 52568
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
52542: LD_VAR 0 4
52546: PUSH
52547: LD_VAR 0 7
52551: ARRAY
52552: PPUSH
52553: LD_VAR 0 14
52557: PUSH
52558: LD_INT 1
52560: ARRAY
52561: PPUSH
52562: CALL 47865 0 2
52566: GO 52592
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52568: LD_VAR 0 4
52572: PUSH
52573: LD_VAR 0 7
52577: ARRAY
52578: PPUSH
52579: LD_VAR 0 14
52583: PUSH
52584: LD_INT 1
52586: ARRAY
52587: PPUSH
52588: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
52592: LD_VAR 0 4
52596: PUSH
52597: LD_VAR 0 7
52601: ARRAY
52602: PPUSH
52603: CALL_OW 264
52607: PUSH
52608: LD_INT 29
52610: EQUAL
52611: IFFALSE 52977
// begin if WantsToAttack ( group [ i ] ) in bombed then
52613: LD_VAR 0 4
52617: PUSH
52618: LD_VAR 0 7
52622: ARRAY
52623: PPUSH
52624: CALL_OW 319
52628: PUSH
52629: LD_VAR 0 28
52633: IN
52634: IFFALSE 52638
// continue ;
52636: GO 49668
// k := 8 ;
52638: LD_ADDR_VAR 0 9
52642: PUSH
52643: LD_INT 8
52645: ST_TO_ADDR
// x := 0 ;
52646: LD_ADDR_VAR 0 10
52650: PUSH
52651: LD_INT 0
52653: ST_TO_ADDR
// if tmp < k then
52654: LD_VAR 0 14
52658: PUSH
52659: LD_VAR 0 9
52663: LESS
52664: IFFALSE 52676
// k := tmp ;
52666: LD_ADDR_VAR 0 9
52670: PUSH
52671: LD_VAR 0 14
52675: ST_TO_ADDR
// for j = 1 to k do
52676: LD_ADDR_VAR 0 8
52680: PUSH
52681: DOUBLE
52682: LD_INT 1
52684: DEC
52685: ST_TO_ADDR
52686: LD_VAR 0 9
52690: PUSH
52691: FOR_TO
52692: IFFALSE 52824
// begin if GetType ( tmp [ j ] ) = unit_building then
52694: LD_VAR 0 14
52698: PUSH
52699: LD_VAR 0 8
52703: ARRAY
52704: PPUSH
52705: CALL_OW 247
52709: PUSH
52710: LD_INT 3
52712: EQUAL
52713: IFFALSE 52822
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
52715: LD_VAR 0 14
52719: PUSH
52720: LD_VAR 0 8
52724: ARRAY
52725: PUSH
52726: LD_VAR 0 28
52730: IN
52731: NOT
52732: PUSH
52733: LD_VAR 0 14
52737: PUSH
52738: LD_VAR 0 8
52742: ARRAY
52743: PPUSH
52744: CALL_OW 313
52748: AND
52749: IFFALSE 52822
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52751: LD_VAR 0 4
52755: PUSH
52756: LD_VAR 0 7
52760: ARRAY
52761: PPUSH
52762: LD_VAR 0 14
52766: PUSH
52767: LD_VAR 0 8
52771: ARRAY
52772: PPUSH
52773: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
52777: LD_ADDR_VAR 0 28
52781: PUSH
52782: LD_VAR 0 28
52786: PPUSH
52787: LD_VAR 0 28
52791: PUSH
52792: LD_INT 1
52794: PLUS
52795: PPUSH
52796: LD_VAR 0 14
52800: PUSH
52801: LD_VAR 0 8
52805: ARRAY
52806: PPUSH
52807: CALL_OW 1
52811: ST_TO_ADDR
// attacking := true ;
52812: LD_ADDR_VAR 0 29
52816: PUSH
52817: LD_INT 1
52819: ST_TO_ADDR
// break ;
52820: GO 52824
// end ; end ;
52822: GO 52691
52824: POP
52825: POP
// if not attacking and f_attack_depot then
52826: LD_VAR 0 29
52830: NOT
52831: PUSH
52832: LD_VAR 0 25
52836: AND
52837: IFFALSE 52932
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52839: LD_ADDR_VAR 0 13
52843: PUSH
52844: LD_VAR 0 14
52848: PPUSH
52849: LD_INT 2
52851: PUSH
52852: LD_INT 30
52854: PUSH
52855: LD_INT 0
52857: PUSH
52858: EMPTY
52859: LIST
52860: LIST
52861: PUSH
52862: LD_INT 30
52864: PUSH
52865: LD_INT 1
52867: PUSH
52868: EMPTY
52869: LIST
52870: LIST
52871: PUSH
52872: EMPTY
52873: LIST
52874: LIST
52875: LIST
52876: PPUSH
52877: CALL_OW 72
52881: ST_TO_ADDR
// if z then
52882: LD_VAR 0 13
52886: IFFALSE 52932
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
52888: LD_VAR 0 4
52892: PUSH
52893: LD_VAR 0 7
52897: ARRAY
52898: PPUSH
52899: LD_VAR 0 13
52903: PPUSH
52904: LD_VAR 0 4
52908: PUSH
52909: LD_VAR 0 7
52913: ARRAY
52914: PPUSH
52915: CALL_OW 74
52919: PPUSH
52920: CALL_OW 115
// attacking := true ;
52924: LD_ADDR_VAR 0 29
52928: PUSH
52929: LD_INT 1
52931: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
52932: LD_VAR 0 4
52936: PUSH
52937: LD_VAR 0 7
52941: ARRAY
52942: PPUSH
52943: CALL_OW 256
52947: PUSH
52948: LD_INT 500
52950: LESS
52951: IFFALSE 52977
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52953: LD_VAR 0 4
52957: PUSH
52958: LD_VAR 0 7
52962: ARRAY
52963: PPUSH
52964: LD_VAR 0 14
52968: PUSH
52969: LD_INT 1
52971: ARRAY
52972: PPUSH
52973: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
52977: LD_VAR 0 4
52981: PUSH
52982: LD_VAR 0 7
52986: ARRAY
52987: PPUSH
52988: CALL_OW 264
52992: PUSH
52993: LD_INT 49
52995: EQUAL
52996: IFFALSE 53117
// begin if not HasTask ( group [ i ] ) then
52998: LD_VAR 0 4
53002: PUSH
53003: LD_VAR 0 7
53007: ARRAY
53008: PPUSH
53009: CALL_OW 314
53013: NOT
53014: IFFALSE 53117
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
53016: LD_ADDR_VAR 0 9
53020: PUSH
53021: LD_INT 81
53023: PUSH
53024: LD_VAR 0 4
53028: PUSH
53029: LD_VAR 0 7
53033: ARRAY
53034: PPUSH
53035: CALL_OW 255
53039: PUSH
53040: EMPTY
53041: LIST
53042: LIST
53043: PPUSH
53044: CALL_OW 69
53048: PPUSH
53049: LD_VAR 0 4
53053: PUSH
53054: LD_VAR 0 7
53058: ARRAY
53059: PPUSH
53060: CALL_OW 74
53064: ST_TO_ADDR
// if k then
53065: LD_VAR 0 9
53069: IFFALSE 53117
// if GetDistUnits ( group [ i ] , k ) > 10 then
53071: LD_VAR 0 4
53075: PUSH
53076: LD_VAR 0 7
53080: ARRAY
53081: PPUSH
53082: LD_VAR 0 9
53086: PPUSH
53087: CALL_OW 296
53091: PUSH
53092: LD_INT 10
53094: GREATER
53095: IFFALSE 53117
// ComMoveUnit ( group [ i ] , k ) ;
53097: LD_VAR 0 4
53101: PUSH
53102: LD_VAR 0 7
53106: ARRAY
53107: PPUSH
53108: LD_VAR 0 9
53112: PPUSH
53113: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53117: LD_VAR 0 4
53121: PUSH
53122: LD_VAR 0 7
53126: ARRAY
53127: PPUSH
53128: CALL_OW 256
53132: PUSH
53133: LD_INT 250
53135: LESS
53136: PUSH
53137: LD_VAR 0 4
53141: PUSH
53142: LD_VAR 0 7
53146: ARRAY
53147: PUSH
53148: LD_INT 21
53150: PUSH
53151: LD_INT 2
53153: PUSH
53154: EMPTY
53155: LIST
53156: LIST
53157: PUSH
53158: LD_INT 23
53160: PUSH
53161: LD_INT 2
53163: PUSH
53164: EMPTY
53165: LIST
53166: LIST
53167: PUSH
53168: EMPTY
53169: LIST
53170: LIST
53171: PPUSH
53172: CALL_OW 69
53176: IN
53177: AND
53178: IFFALSE 53303
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
53180: LD_ADDR_VAR 0 9
53184: PUSH
53185: LD_OWVAR 3
53189: PUSH
53190: LD_VAR 0 4
53194: PUSH
53195: LD_VAR 0 7
53199: ARRAY
53200: DIFF
53201: PPUSH
53202: LD_VAR 0 4
53206: PUSH
53207: LD_VAR 0 7
53211: ARRAY
53212: PPUSH
53213: CALL_OW 74
53217: ST_TO_ADDR
// if not k then
53218: LD_VAR 0 9
53222: NOT
53223: IFFALSE 53227
// continue ;
53225: GO 49668
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
53227: LD_VAR 0 9
53231: PUSH
53232: LD_INT 81
53234: PUSH
53235: LD_VAR 0 4
53239: PUSH
53240: LD_VAR 0 7
53244: ARRAY
53245: PPUSH
53246: CALL_OW 255
53250: PUSH
53251: EMPTY
53252: LIST
53253: LIST
53254: PPUSH
53255: CALL_OW 69
53259: IN
53260: PUSH
53261: LD_VAR 0 9
53265: PPUSH
53266: LD_VAR 0 4
53270: PUSH
53271: LD_VAR 0 7
53275: ARRAY
53276: PPUSH
53277: CALL_OW 296
53281: PUSH
53282: LD_INT 5
53284: LESS
53285: AND
53286: IFFALSE 53303
// ComAutodestruct ( group [ i ] ) ;
53288: LD_VAR 0 4
53292: PUSH
53293: LD_VAR 0 7
53297: ARRAY
53298: PPUSH
53299: CALL 47763 0 1
// end ; if f_attack_depot then
53303: LD_VAR 0 25
53307: IFFALSE 53419
// begin k := 6 ;
53309: LD_ADDR_VAR 0 9
53313: PUSH
53314: LD_INT 6
53316: ST_TO_ADDR
// if tmp < k then
53317: LD_VAR 0 14
53321: PUSH
53322: LD_VAR 0 9
53326: LESS
53327: IFFALSE 53339
// k := tmp ;
53329: LD_ADDR_VAR 0 9
53333: PUSH
53334: LD_VAR 0 14
53338: ST_TO_ADDR
// for j = 1 to k do
53339: LD_ADDR_VAR 0 8
53343: PUSH
53344: DOUBLE
53345: LD_INT 1
53347: DEC
53348: ST_TO_ADDR
53349: LD_VAR 0 9
53353: PUSH
53354: FOR_TO
53355: IFFALSE 53417
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
53357: LD_VAR 0 8
53361: PPUSH
53362: CALL_OW 266
53366: PUSH
53367: LD_INT 0
53369: PUSH
53370: LD_INT 1
53372: PUSH
53373: EMPTY
53374: LIST
53375: LIST
53376: IN
53377: IFFALSE 53415
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53379: LD_VAR 0 4
53383: PUSH
53384: LD_VAR 0 7
53388: ARRAY
53389: PPUSH
53390: LD_VAR 0 14
53394: PUSH
53395: LD_VAR 0 8
53399: ARRAY
53400: PPUSH
53401: CALL_OW 115
// attacking := true ;
53405: LD_ADDR_VAR 0 29
53409: PUSH
53410: LD_INT 1
53412: ST_TO_ADDR
// break ;
53413: GO 53417
// end ;
53415: GO 53354
53417: POP
53418: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
53419: LD_VAR 0 4
53423: PUSH
53424: LD_VAR 0 7
53428: ARRAY
53429: PPUSH
53430: CALL_OW 302
53434: PUSH
53435: LD_VAR 0 29
53439: NOT
53440: AND
53441: IFFALSE 53763
// begin if GetTag ( group [ i ] ) = 71 then
53443: LD_VAR 0 4
53447: PUSH
53448: LD_VAR 0 7
53452: ARRAY
53453: PPUSH
53454: CALL_OW 110
53458: PUSH
53459: LD_INT 71
53461: EQUAL
53462: IFFALSE 53503
// begin if HasTask ( group [ i ] ) then
53464: LD_VAR 0 4
53468: PUSH
53469: LD_VAR 0 7
53473: ARRAY
53474: PPUSH
53475: CALL_OW 314
53479: IFFALSE 53485
// continue else
53481: GO 49668
53483: GO 53503
// SetTag ( group [ i ] , 0 ) ;
53485: LD_VAR 0 4
53489: PUSH
53490: LD_VAR 0 7
53494: ARRAY
53495: PPUSH
53496: LD_INT 0
53498: PPUSH
53499: CALL_OW 109
// end ; k := 8 ;
53503: LD_ADDR_VAR 0 9
53507: PUSH
53508: LD_INT 8
53510: ST_TO_ADDR
// x := 0 ;
53511: LD_ADDR_VAR 0 10
53515: PUSH
53516: LD_INT 0
53518: ST_TO_ADDR
// if tmp < k then
53519: LD_VAR 0 14
53523: PUSH
53524: LD_VAR 0 9
53528: LESS
53529: IFFALSE 53541
// k := tmp ;
53531: LD_ADDR_VAR 0 9
53535: PUSH
53536: LD_VAR 0 14
53540: ST_TO_ADDR
// for j = 1 to k do
53541: LD_ADDR_VAR 0 8
53545: PUSH
53546: DOUBLE
53547: LD_INT 1
53549: DEC
53550: ST_TO_ADDR
53551: LD_VAR 0 9
53555: PUSH
53556: FOR_TO
53557: IFFALSE 53655
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
53559: LD_VAR 0 14
53563: PUSH
53564: LD_VAR 0 8
53568: ARRAY
53569: PPUSH
53570: CALL_OW 247
53574: PUSH
53575: LD_INT 1
53577: EQUAL
53578: PUSH
53579: LD_VAR 0 14
53583: PUSH
53584: LD_VAR 0 8
53588: ARRAY
53589: PPUSH
53590: CALL_OW 256
53594: PUSH
53595: LD_INT 250
53597: LESS
53598: PUSH
53599: LD_VAR 0 20
53603: AND
53604: PUSH
53605: LD_VAR 0 20
53609: NOT
53610: PUSH
53611: LD_VAR 0 14
53615: PUSH
53616: LD_VAR 0 8
53620: ARRAY
53621: PPUSH
53622: CALL_OW 256
53626: PUSH
53627: LD_INT 250
53629: GREATEREQUAL
53630: AND
53631: OR
53632: AND
53633: IFFALSE 53653
// begin x := tmp [ j ] ;
53635: LD_ADDR_VAR 0 10
53639: PUSH
53640: LD_VAR 0 14
53644: PUSH
53645: LD_VAR 0 8
53649: ARRAY
53650: ST_TO_ADDR
// break ;
53651: GO 53655
// end ;
53653: GO 53556
53655: POP
53656: POP
// if x then
53657: LD_VAR 0 10
53661: IFFALSE 53685
// ComAttackUnit ( group [ i ] , x ) else
53663: LD_VAR 0 4
53667: PUSH
53668: LD_VAR 0 7
53672: ARRAY
53673: PPUSH
53674: LD_VAR 0 10
53678: PPUSH
53679: CALL_OW 115
53683: GO 53709
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53685: LD_VAR 0 4
53689: PUSH
53690: LD_VAR 0 7
53694: ARRAY
53695: PPUSH
53696: LD_VAR 0 14
53700: PUSH
53701: LD_INT 1
53703: ARRAY
53704: PPUSH
53705: CALL_OW 115
// if not HasTask ( group [ i ] ) then
53709: LD_VAR 0 4
53713: PUSH
53714: LD_VAR 0 7
53718: ARRAY
53719: PPUSH
53720: CALL_OW 314
53724: NOT
53725: IFFALSE 53763
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
53727: LD_VAR 0 4
53731: PUSH
53732: LD_VAR 0 7
53736: ARRAY
53737: PPUSH
53738: LD_VAR 0 14
53742: PPUSH
53743: LD_VAR 0 4
53747: PUSH
53748: LD_VAR 0 7
53752: ARRAY
53753: PPUSH
53754: CALL_OW 74
53758: PPUSH
53759: CALL_OW 115
// end ; end ; end ;
53763: GO 49668
53765: POP
53766: POP
// wait ( 0 0$1 ) ;
53767: LD_INT 35
53769: PPUSH
53770: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
53774: LD_VAR 0 4
53778: PUSH
53779: EMPTY
53780: EQUAL
53781: PUSH
53782: LD_INT 81
53784: PUSH
53785: LD_VAR 0 35
53789: PUSH
53790: EMPTY
53791: LIST
53792: LIST
53793: PPUSH
53794: CALL_OW 69
53798: NOT
53799: OR
53800: IFFALSE 49653
// end ;
53802: LD_VAR 0 2
53806: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53807: LD_INT 0
53809: PPUSH
53810: PPUSH
53811: PPUSH
53812: PPUSH
// if not base_units then
53813: LD_VAR 0 1
53817: NOT
53818: IFFALSE 53822
// exit ;
53820: GO 53909
// result := false ;
53822: LD_ADDR_VAR 0 2
53826: PUSH
53827: LD_INT 0
53829: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53830: LD_ADDR_VAR 0 5
53834: PUSH
53835: LD_VAR 0 1
53839: PPUSH
53840: LD_INT 21
53842: PUSH
53843: LD_INT 3
53845: PUSH
53846: EMPTY
53847: LIST
53848: LIST
53849: PPUSH
53850: CALL_OW 72
53854: ST_TO_ADDR
// if not tmp then
53855: LD_VAR 0 5
53859: NOT
53860: IFFALSE 53864
// exit ;
53862: GO 53909
// for i in tmp do
53864: LD_ADDR_VAR 0 3
53868: PUSH
53869: LD_VAR 0 5
53873: PUSH
53874: FOR_IN
53875: IFFALSE 53907
// begin result := EnemyInRange ( i , 22 ) ;
53877: LD_ADDR_VAR 0 2
53881: PUSH
53882: LD_VAR 0 3
53886: PPUSH
53887: LD_INT 22
53889: PPUSH
53890: CALL 47446 0 2
53894: ST_TO_ADDR
// if result then
53895: LD_VAR 0 2
53899: IFFALSE 53905
// exit ;
53901: POP
53902: POP
53903: GO 53909
// end ;
53905: GO 53874
53907: POP
53908: POP
// end ;
53909: LD_VAR 0 2
53913: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
53914: LD_INT 0
53916: PPUSH
53917: PPUSH
// if not units then
53918: LD_VAR 0 1
53922: NOT
53923: IFFALSE 53927
// exit ;
53925: GO 53997
// result := [ ] ;
53927: LD_ADDR_VAR 0 3
53931: PUSH
53932: EMPTY
53933: ST_TO_ADDR
// for i in units do
53934: LD_ADDR_VAR 0 4
53938: PUSH
53939: LD_VAR 0 1
53943: PUSH
53944: FOR_IN
53945: IFFALSE 53995
// if GetTag ( i ) = tag then
53947: LD_VAR 0 4
53951: PPUSH
53952: CALL_OW 110
53956: PUSH
53957: LD_VAR 0 2
53961: EQUAL
53962: IFFALSE 53993
// result := Insert ( result , result + 1 , i ) ;
53964: LD_ADDR_VAR 0 3
53968: PUSH
53969: LD_VAR 0 3
53973: PPUSH
53974: LD_VAR 0 3
53978: PUSH
53979: LD_INT 1
53981: PLUS
53982: PPUSH
53983: LD_VAR 0 4
53987: PPUSH
53988: CALL_OW 2
53992: ST_TO_ADDR
53993: GO 53944
53995: POP
53996: POP
// end ;
53997: LD_VAR 0 3
54001: RET
// export function IsDriver ( un ) ; begin
54002: LD_INT 0
54004: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54005: LD_ADDR_VAR 0 2
54009: PUSH
54010: LD_VAR 0 1
54014: PUSH
54015: LD_INT 55
54017: PUSH
54018: EMPTY
54019: LIST
54020: PPUSH
54021: CALL_OW 69
54025: IN
54026: ST_TO_ADDR
// end ;
54027: LD_VAR 0 2
54031: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54032: LD_INT 0
54034: PPUSH
54035: PPUSH
// list := [ ] ;
54036: LD_ADDR_VAR 0 5
54040: PUSH
54041: EMPTY
54042: ST_TO_ADDR
// case d of 0 :
54043: LD_VAR 0 3
54047: PUSH
54048: LD_INT 0
54050: DOUBLE
54051: EQUAL
54052: IFTRUE 54056
54054: GO 54189
54056: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54057: LD_ADDR_VAR 0 5
54061: PUSH
54062: LD_VAR 0 1
54066: PUSH
54067: LD_INT 4
54069: MINUS
54070: PUSH
54071: LD_VAR 0 2
54075: PUSH
54076: LD_INT 4
54078: MINUS
54079: PUSH
54080: LD_INT 2
54082: PUSH
54083: EMPTY
54084: LIST
54085: LIST
54086: LIST
54087: PUSH
54088: LD_VAR 0 1
54092: PUSH
54093: LD_INT 3
54095: MINUS
54096: PUSH
54097: LD_VAR 0 2
54101: PUSH
54102: LD_INT 1
54104: PUSH
54105: EMPTY
54106: LIST
54107: LIST
54108: LIST
54109: PUSH
54110: LD_VAR 0 1
54114: PUSH
54115: LD_INT 4
54117: PLUS
54118: PUSH
54119: LD_VAR 0 2
54123: PUSH
54124: LD_INT 4
54126: PUSH
54127: EMPTY
54128: LIST
54129: LIST
54130: LIST
54131: PUSH
54132: LD_VAR 0 1
54136: PUSH
54137: LD_INT 3
54139: PLUS
54140: PUSH
54141: LD_VAR 0 2
54145: PUSH
54146: LD_INT 3
54148: PLUS
54149: PUSH
54150: LD_INT 5
54152: PUSH
54153: EMPTY
54154: LIST
54155: LIST
54156: LIST
54157: PUSH
54158: LD_VAR 0 1
54162: PUSH
54163: LD_VAR 0 2
54167: PUSH
54168: LD_INT 4
54170: PLUS
54171: PUSH
54172: LD_INT 0
54174: PUSH
54175: EMPTY
54176: LIST
54177: LIST
54178: LIST
54179: PUSH
54180: EMPTY
54181: LIST
54182: LIST
54183: LIST
54184: LIST
54185: LIST
54186: ST_TO_ADDR
// end ; 1 :
54187: GO 54887
54189: LD_INT 1
54191: DOUBLE
54192: EQUAL
54193: IFTRUE 54197
54195: GO 54330
54197: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54198: LD_ADDR_VAR 0 5
54202: PUSH
54203: LD_VAR 0 1
54207: PUSH
54208: LD_VAR 0 2
54212: PUSH
54213: LD_INT 4
54215: MINUS
54216: PUSH
54217: LD_INT 3
54219: PUSH
54220: EMPTY
54221: LIST
54222: LIST
54223: LIST
54224: PUSH
54225: LD_VAR 0 1
54229: PUSH
54230: LD_INT 3
54232: MINUS
54233: PUSH
54234: LD_VAR 0 2
54238: PUSH
54239: LD_INT 3
54241: MINUS
54242: PUSH
54243: LD_INT 2
54245: PUSH
54246: EMPTY
54247: LIST
54248: LIST
54249: LIST
54250: PUSH
54251: LD_VAR 0 1
54255: PUSH
54256: LD_INT 4
54258: MINUS
54259: PUSH
54260: LD_VAR 0 2
54264: PUSH
54265: LD_INT 1
54267: PUSH
54268: EMPTY
54269: LIST
54270: LIST
54271: LIST
54272: PUSH
54273: LD_VAR 0 1
54277: PUSH
54278: LD_VAR 0 2
54282: PUSH
54283: LD_INT 3
54285: PLUS
54286: PUSH
54287: LD_INT 0
54289: PUSH
54290: EMPTY
54291: LIST
54292: LIST
54293: LIST
54294: PUSH
54295: LD_VAR 0 1
54299: PUSH
54300: LD_INT 4
54302: PLUS
54303: PUSH
54304: LD_VAR 0 2
54308: PUSH
54309: LD_INT 4
54311: PLUS
54312: PUSH
54313: LD_INT 5
54315: PUSH
54316: EMPTY
54317: LIST
54318: LIST
54319: LIST
54320: PUSH
54321: EMPTY
54322: LIST
54323: LIST
54324: LIST
54325: LIST
54326: LIST
54327: ST_TO_ADDR
// end ; 2 :
54328: GO 54887
54330: LD_INT 2
54332: DOUBLE
54333: EQUAL
54334: IFTRUE 54338
54336: GO 54467
54338: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54339: LD_ADDR_VAR 0 5
54343: PUSH
54344: LD_VAR 0 1
54348: PUSH
54349: LD_VAR 0 2
54353: PUSH
54354: LD_INT 3
54356: MINUS
54357: PUSH
54358: LD_INT 3
54360: PUSH
54361: EMPTY
54362: LIST
54363: LIST
54364: LIST
54365: PUSH
54366: LD_VAR 0 1
54370: PUSH
54371: LD_INT 4
54373: PLUS
54374: PUSH
54375: LD_VAR 0 2
54379: PUSH
54380: LD_INT 4
54382: PUSH
54383: EMPTY
54384: LIST
54385: LIST
54386: LIST
54387: PUSH
54388: LD_VAR 0 1
54392: PUSH
54393: LD_VAR 0 2
54397: PUSH
54398: LD_INT 4
54400: PLUS
54401: PUSH
54402: LD_INT 0
54404: PUSH
54405: EMPTY
54406: LIST
54407: LIST
54408: LIST
54409: PUSH
54410: LD_VAR 0 1
54414: PUSH
54415: LD_INT 3
54417: MINUS
54418: PUSH
54419: LD_VAR 0 2
54423: PUSH
54424: LD_INT 1
54426: PUSH
54427: EMPTY
54428: LIST
54429: LIST
54430: LIST
54431: PUSH
54432: LD_VAR 0 1
54436: PUSH
54437: LD_INT 4
54439: MINUS
54440: PUSH
54441: LD_VAR 0 2
54445: PUSH
54446: LD_INT 4
54448: MINUS
54449: PUSH
54450: LD_INT 2
54452: PUSH
54453: EMPTY
54454: LIST
54455: LIST
54456: LIST
54457: PUSH
54458: EMPTY
54459: LIST
54460: LIST
54461: LIST
54462: LIST
54463: LIST
54464: ST_TO_ADDR
// end ; 3 :
54465: GO 54887
54467: LD_INT 3
54469: DOUBLE
54470: EQUAL
54471: IFTRUE 54475
54473: GO 54608
54475: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54476: LD_ADDR_VAR 0 5
54480: PUSH
54481: LD_VAR 0 1
54485: PUSH
54486: LD_INT 3
54488: PLUS
54489: PUSH
54490: LD_VAR 0 2
54494: PUSH
54495: LD_INT 4
54497: PUSH
54498: EMPTY
54499: LIST
54500: LIST
54501: LIST
54502: PUSH
54503: LD_VAR 0 1
54507: PUSH
54508: LD_INT 4
54510: PLUS
54511: PUSH
54512: LD_VAR 0 2
54516: PUSH
54517: LD_INT 4
54519: PLUS
54520: PUSH
54521: LD_INT 5
54523: PUSH
54524: EMPTY
54525: LIST
54526: LIST
54527: LIST
54528: PUSH
54529: LD_VAR 0 1
54533: PUSH
54534: LD_INT 4
54536: MINUS
54537: PUSH
54538: LD_VAR 0 2
54542: PUSH
54543: LD_INT 1
54545: PUSH
54546: EMPTY
54547: LIST
54548: LIST
54549: LIST
54550: PUSH
54551: LD_VAR 0 1
54555: PUSH
54556: LD_VAR 0 2
54560: PUSH
54561: LD_INT 4
54563: MINUS
54564: PUSH
54565: LD_INT 3
54567: PUSH
54568: EMPTY
54569: LIST
54570: LIST
54571: LIST
54572: PUSH
54573: LD_VAR 0 1
54577: PUSH
54578: LD_INT 3
54580: MINUS
54581: PUSH
54582: LD_VAR 0 2
54586: PUSH
54587: LD_INT 3
54589: MINUS
54590: PUSH
54591: LD_INT 2
54593: PUSH
54594: EMPTY
54595: LIST
54596: LIST
54597: LIST
54598: PUSH
54599: EMPTY
54600: LIST
54601: LIST
54602: LIST
54603: LIST
54604: LIST
54605: ST_TO_ADDR
// end ; 4 :
54606: GO 54887
54608: LD_INT 4
54610: DOUBLE
54611: EQUAL
54612: IFTRUE 54616
54614: GO 54749
54616: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54617: LD_ADDR_VAR 0 5
54621: PUSH
54622: LD_VAR 0 1
54626: PUSH
54627: LD_VAR 0 2
54631: PUSH
54632: LD_INT 4
54634: PLUS
54635: PUSH
54636: LD_INT 0
54638: PUSH
54639: EMPTY
54640: LIST
54641: LIST
54642: LIST
54643: PUSH
54644: LD_VAR 0 1
54648: PUSH
54649: LD_INT 3
54651: PLUS
54652: PUSH
54653: LD_VAR 0 2
54657: PUSH
54658: LD_INT 3
54660: PLUS
54661: PUSH
54662: LD_INT 5
54664: PUSH
54665: EMPTY
54666: LIST
54667: LIST
54668: LIST
54669: PUSH
54670: LD_VAR 0 1
54674: PUSH
54675: LD_INT 4
54677: PLUS
54678: PUSH
54679: LD_VAR 0 2
54683: PUSH
54684: LD_INT 4
54686: PUSH
54687: EMPTY
54688: LIST
54689: LIST
54690: LIST
54691: PUSH
54692: LD_VAR 0 1
54696: PUSH
54697: LD_VAR 0 2
54701: PUSH
54702: LD_INT 3
54704: MINUS
54705: PUSH
54706: LD_INT 3
54708: PUSH
54709: EMPTY
54710: LIST
54711: LIST
54712: LIST
54713: PUSH
54714: LD_VAR 0 1
54718: PUSH
54719: LD_INT 4
54721: MINUS
54722: PUSH
54723: LD_VAR 0 2
54727: PUSH
54728: LD_INT 4
54730: MINUS
54731: PUSH
54732: LD_INT 2
54734: PUSH
54735: EMPTY
54736: LIST
54737: LIST
54738: LIST
54739: PUSH
54740: EMPTY
54741: LIST
54742: LIST
54743: LIST
54744: LIST
54745: LIST
54746: ST_TO_ADDR
// end ; 5 :
54747: GO 54887
54749: LD_INT 5
54751: DOUBLE
54752: EQUAL
54753: IFTRUE 54757
54755: GO 54886
54757: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54758: LD_ADDR_VAR 0 5
54762: PUSH
54763: LD_VAR 0 1
54767: PUSH
54768: LD_INT 4
54770: MINUS
54771: PUSH
54772: LD_VAR 0 2
54776: PUSH
54777: LD_INT 1
54779: PUSH
54780: EMPTY
54781: LIST
54782: LIST
54783: LIST
54784: PUSH
54785: LD_VAR 0 1
54789: PUSH
54790: LD_VAR 0 2
54794: PUSH
54795: LD_INT 4
54797: MINUS
54798: PUSH
54799: LD_INT 3
54801: PUSH
54802: EMPTY
54803: LIST
54804: LIST
54805: LIST
54806: PUSH
54807: LD_VAR 0 1
54811: PUSH
54812: LD_INT 4
54814: PLUS
54815: PUSH
54816: LD_VAR 0 2
54820: PUSH
54821: LD_INT 4
54823: PLUS
54824: PUSH
54825: LD_INT 5
54827: PUSH
54828: EMPTY
54829: LIST
54830: LIST
54831: LIST
54832: PUSH
54833: LD_VAR 0 1
54837: PUSH
54838: LD_INT 3
54840: PLUS
54841: PUSH
54842: LD_VAR 0 2
54846: PUSH
54847: LD_INT 4
54849: PUSH
54850: EMPTY
54851: LIST
54852: LIST
54853: LIST
54854: PUSH
54855: LD_VAR 0 1
54859: PUSH
54860: LD_VAR 0 2
54864: PUSH
54865: LD_INT 3
54867: PLUS
54868: PUSH
54869: LD_INT 0
54871: PUSH
54872: EMPTY
54873: LIST
54874: LIST
54875: LIST
54876: PUSH
54877: EMPTY
54878: LIST
54879: LIST
54880: LIST
54881: LIST
54882: LIST
54883: ST_TO_ADDR
// end ; end ;
54884: GO 54887
54886: POP
// result := list ;
54887: LD_ADDR_VAR 0 4
54891: PUSH
54892: LD_VAR 0 5
54896: ST_TO_ADDR
// end ;
54897: LD_VAR 0 4
54901: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54902: LD_INT 0
54904: PPUSH
54905: PPUSH
54906: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54907: LD_VAR 0 1
54911: NOT
54912: PUSH
54913: LD_VAR 0 2
54917: PUSH
54918: LD_INT 1
54920: PUSH
54921: LD_INT 2
54923: PUSH
54924: LD_INT 3
54926: PUSH
54927: LD_INT 4
54929: PUSH
54930: EMPTY
54931: LIST
54932: LIST
54933: LIST
54934: LIST
54935: IN
54936: NOT
54937: OR
54938: IFFALSE 54942
// exit ;
54940: GO 55034
// tmp := [ ] ;
54942: LD_ADDR_VAR 0 5
54946: PUSH
54947: EMPTY
54948: ST_TO_ADDR
// for i in units do
54949: LD_ADDR_VAR 0 4
54953: PUSH
54954: LD_VAR 0 1
54958: PUSH
54959: FOR_IN
54960: IFFALSE 55003
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
54962: LD_ADDR_VAR 0 5
54966: PUSH
54967: LD_VAR 0 5
54971: PPUSH
54972: LD_VAR 0 5
54976: PUSH
54977: LD_INT 1
54979: PLUS
54980: PPUSH
54981: LD_VAR 0 4
54985: PPUSH
54986: LD_VAR 0 2
54990: PPUSH
54991: CALL_OW 259
54995: PPUSH
54996: CALL_OW 2
55000: ST_TO_ADDR
55001: GO 54959
55003: POP
55004: POP
// if not tmp then
55005: LD_VAR 0 5
55009: NOT
55010: IFFALSE 55014
// exit ;
55012: GO 55034
// result := SortListByListDesc ( units , tmp ) ;
55014: LD_ADDR_VAR 0 3
55018: PUSH
55019: LD_VAR 0 1
55023: PPUSH
55024: LD_VAR 0 5
55028: PPUSH
55029: CALL_OW 77
55033: ST_TO_ADDR
// end ;
55034: LD_VAR 0 3
55038: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55039: LD_INT 0
55041: PPUSH
55042: PPUSH
55043: PPUSH
// x := GetX ( building ) ;
55044: LD_ADDR_VAR 0 4
55048: PUSH
55049: LD_VAR 0 2
55053: PPUSH
55054: CALL_OW 250
55058: ST_TO_ADDR
// y := GetY ( building ) ;
55059: LD_ADDR_VAR 0 5
55063: PUSH
55064: LD_VAR 0 2
55068: PPUSH
55069: CALL_OW 251
55073: ST_TO_ADDR
// if GetTaskList ( unit ) then
55074: LD_VAR 0 1
55078: PPUSH
55079: CALL_OW 437
55083: IFFALSE 55178
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55085: LD_STRING e
55087: PUSH
55088: LD_VAR 0 1
55092: PPUSH
55093: CALL_OW 437
55097: PUSH
55098: LD_INT 1
55100: ARRAY
55101: PUSH
55102: LD_INT 1
55104: ARRAY
55105: EQUAL
55106: PUSH
55107: LD_VAR 0 4
55111: PUSH
55112: LD_VAR 0 1
55116: PPUSH
55117: CALL_OW 437
55121: PUSH
55122: LD_INT 1
55124: ARRAY
55125: PUSH
55126: LD_INT 2
55128: ARRAY
55129: EQUAL
55130: AND
55131: PUSH
55132: LD_VAR 0 5
55136: PUSH
55137: LD_VAR 0 1
55141: PPUSH
55142: CALL_OW 437
55146: PUSH
55147: LD_INT 1
55149: ARRAY
55150: PUSH
55151: LD_INT 3
55153: ARRAY
55154: EQUAL
55155: AND
55156: IFFALSE 55168
// result := true else
55158: LD_ADDR_VAR 0 3
55162: PUSH
55163: LD_INT 1
55165: ST_TO_ADDR
55166: GO 55176
// result := false ;
55168: LD_ADDR_VAR 0 3
55172: PUSH
55173: LD_INT 0
55175: ST_TO_ADDR
// end else
55176: GO 55186
// result := false ;
55178: LD_ADDR_VAR 0 3
55182: PUSH
55183: LD_INT 0
55185: ST_TO_ADDR
// end ;
55186: LD_VAR 0 3
55190: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55191: LD_INT 0
55193: PPUSH
55194: PPUSH
55195: PPUSH
55196: PPUSH
// if not unit or not area then
55197: LD_VAR 0 1
55201: NOT
55202: PUSH
55203: LD_VAR 0 2
55207: NOT
55208: OR
55209: IFFALSE 55213
// exit ;
55211: GO 55377
// tmp := AreaToList ( area , i ) ;
55213: LD_ADDR_VAR 0 6
55217: PUSH
55218: LD_VAR 0 2
55222: PPUSH
55223: LD_VAR 0 5
55227: PPUSH
55228: CALL_OW 517
55232: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55233: LD_ADDR_VAR 0 5
55237: PUSH
55238: DOUBLE
55239: LD_INT 1
55241: DEC
55242: ST_TO_ADDR
55243: LD_VAR 0 6
55247: PUSH
55248: LD_INT 1
55250: ARRAY
55251: PUSH
55252: FOR_TO
55253: IFFALSE 55375
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55255: LD_ADDR_VAR 0 7
55259: PUSH
55260: LD_VAR 0 6
55264: PUSH
55265: LD_INT 1
55267: ARRAY
55268: PUSH
55269: LD_VAR 0 5
55273: ARRAY
55274: PUSH
55275: LD_VAR 0 6
55279: PUSH
55280: LD_INT 2
55282: ARRAY
55283: PUSH
55284: LD_VAR 0 5
55288: ARRAY
55289: PUSH
55290: EMPTY
55291: LIST
55292: LIST
55293: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
55294: LD_VAR 0 7
55298: PUSH
55299: LD_INT 1
55301: ARRAY
55302: PPUSH
55303: LD_VAR 0 7
55307: PUSH
55308: LD_INT 2
55310: ARRAY
55311: PPUSH
55312: CALL_OW 428
55316: PUSH
55317: LD_INT 0
55319: EQUAL
55320: IFFALSE 55373
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55322: LD_VAR 0 1
55326: PPUSH
55327: LD_VAR 0 7
55331: PUSH
55332: LD_INT 1
55334: ARRAY
55335: PPUSH
55336: LD_VAR 0 7
55340: PUSH
55341: LD_INT 2
55343: ARRAY
55344: PPUSH
55345: LD_VAR 0 3
55349: PPUSH
55350: CALL_OW 48
// result := IsPlaced ( unit ) ;
55354: LD_ADDR_VAR 0 4
55358: PUSH
55359: LD_VAR 0 1
55363: PPUSH
55364: CALL_OW 305
55368: ST_TO_ADDR
// exit ;
55369: POP
55370: POP
55371: GO 55377
// end ; end ;
55373: GO 55252
55375: POP
55376: POP
// end ;
55377: LD_VAR 0 4
55381: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55382: LD_INT 0
55384: PPUSH
55385: PPUSH
55386: PPUSH
// if not side or side > 8 then
55387: LD_VAR 0 1
55391: NOT
55392: PUSH
55393: LD_VAR 0 1
55397: PUSH
55398: LD_INT 8
55400: GREATER
55401: OR
55402: IFFALSE 55406
// exit ;
55404: GO 55593
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55406: LD_ADDR_VAR 0 4
55410: PUSH
55411: LD_INT 22
55413: PUSH
55414: LD_VAR 0 1
55418: PUSH
55419: EMPTY
55420: LIST
55421: LIST
55422: PUSH
55423: LD_INT 21
55425: PUSH
55426: LD_INT 3
55428: PUSH
55429: EMPTY
55430: LIST
55431: LIST
55432: PUSH
55433: EMPTY
55434: LIST
55435: LIST
55436: PPUSH
55437: CALL_OW 69
55441: ST_TO_ADDR
// if not tmp then
55442: LD_VAR 0 4
55446: NOT
55447: IFFALSE 55451
// exit ;
55449: GO 55593
// enable_addtolog := true ;
55451: LD_ADDR_OWVAR 81
55455: PUSH
55456: LD_INT 1
55458: ST_TO_ADDR
// AddToLog ( [ ) ;
55459: LD_STRING [
55461: PPUSH
55462: CALL_OW 561
// for i in tmp do
55466: LD_ADDR_VAR 0 3
55470: PUSH
55471: LD_VAR 0 4
55475: PUSH
55476: FOR_IN
55477: IFFALSE 55584
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55479: LD_STRING [
55481: PUSH
55482: LD_VAR 0 3
55486: PPUSH
55487: CALL_OW 266
55491: STR
55492: PUSH
55493: LD_STRING , 
55495: STR
55496: PUSH
55497: LD_VAR 0 3
55501: PPUSH
55502: CALL_OW 250
55506: STR
55507: PUSH
55508: LD_STRING , 
55510: STR
55511: PUSH
55512: LD_VAR 0 3
55516: PPUSH
55517: CALL_OW 251
55521: STR
55522: PUSH
55523: LD_STRING , 
55525: STR
55526: PUSH
55527: LD_VAR 0 3
55531: PPUSH
55532: CALL_OW 254
55536: STR
55537: PUSH
55538: LD_STRING , 
55540: STR
55541: PUSH
55542: LD_VAR 0 3
55546: PPUSH
55547: LD_INT 1
55549: PPUSH
55550: CALL_OW 268
55554: STR
55555: PUSH
55556: LD_STRING , 
55558: STR
55559: PUSH
55560: LD_VAR 0 3
55564: PPUSH
55565: LD_INT 2
55567: PPUSH
55568: CALL_OW 268
55572: STR
55573: PUSH
55574: LD_STRING ],
55576: STR
55577: PPUSH
55578: CALL_OW 561
// end ;
55582: GO 55476
55584: POP
55585: POP
// AddToLog ( ]; ) ;
55586: LD_STRING ];
55588: PPUSH
55589: CALL_OW 561
// end ;
55593: LD_VAR 0 2
55597: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55598: LD_INT 0
55600: PPUSH
55601: PPUSH
55602: PPUSH
55603: PPUSH
55604: PPUSH
// if not area or not rate or not max then
55605: LD_VAR 0 1
55609: NOT
55610: PUSH
55611: LD_VAR 0 2
55615: NOT
55616: OR
55617: PUSH
55618: LD_VAR 0 4
55622: NOT
55623: OR
55624: IFFALSE 55628
// exit ;
55626: GO 55820
// while 1 do
55628: LD_INT 1
55630: IFFALSE 55820
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55632: LD_ADDR_VAR 0 9
55636: PUSH
55637: LD_VAR 0 1
55641: PPUSH
55642: LD_INT 1
55644: PPUSH
55645: CALL_OW 287
55649: PUSH
55650: LD_INT 10
55652: MUL
55653: ST_TO_ADDR
// r := rate / 10 ;
55654: LD_ADDR_VAR 0 7
55658: PUSH
55659: LD_VAR 0 2
55663: PUSH
55664: LD_INT 10
55666: DIVREAL
55667: ST_TO_ADDR
// time := 1 1$00 ;
55668: LD_ADDR_VAR 0 8
55672: PUSH
55673: LD_INT 2100
55675: ST_TO_ADDR
// if amount < min then
55676: LD_VAR 0 9
55680: PUSH
55681: LD_VAR 0 3
55685: LESS
55686: IFFALSE 55704
// r := r * 2 else
55688: LD_ADDR_VAR 0 7
55692: PUSH
55693: LD_VAR 0 7
55697: PUSH
55698: LD_INT 2
55700: MUL
55701: ST_TO_ADDR
55702: GO 55730
// if amount > max then
55704: LD_VAR 0 9
55708: PUSH
55709: LD_VAR 0 4
55713: GREATER
55714: IFFALSE 55730
// r := r / 2 ;
55716: LD_ADDR_VAR 0 7
55720: PUSH
55721: LD_VAR 0 7
55725: PUSH
55726: LD_INT 2
55728: DIVREAL
55729: ST_TO_ADDR
// time := time / r ;
55730: LD_ADDR_VAR 0 8
55734: PUSH
55735: LD_VAR 0 8
55739: PUSH
55740: LD_VAR 0 7
55744: DIVREAL
55745: ST_TO_ADDR
// if time < 0 then
55746: LD_VAR 0 8
55750: PUSH
55751: LD_INT 0
55753: LESS
55754: IFFALSE 55771
// time := time * - 1 ;
55756: LD_ADDR_VAR 0 8
55760: PUSH
55761: LD_VAR 0 8
55765: PUSH
55766: LD_INT 1
55768: NEG
55769: MUL
55770: ST_TO_ADDR
// wait ( time ) ;
55771: LD_VAR 0 8
55775: PPUSH
55776: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
55780: LD_INT 35
55782: PPUSH
55783: LD_INT 875
55785: PPUSH
55786: CALL_OW 12
55790: PPUSH
55791: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55795: LD_INT 1
55797: PPUSH
55798: LD_INT 5
55800: PPUSH
55801: CALL_OW 12
55805: PPUSH
55806: LD_VAR 0 1
55810: PPUSH
55811: LD_INT 1
55813: PPUSH
55814: CALL_OW 55
// end ;
55818: GO 55628
// end ;
55820: LD_VAR 0 5
55824: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55825: LD_INT 0
55827: PPUSH
55828: PPUSH
55829: PPUSH
55830: PPUSH
55831: PPUSH
55832: PPUSH
55833: PPUSH
55834: PPUSH
// if not turrets or not factories then
55835: LD_VAR 0 1
55839: NOT
55840: PUSH
55841: LD_VAR 0 2
55845: NOT
55846: OR
55847: IFFALSE 55851
// exit ;
55849: GO 56158
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55851: LD_ADDR_VAR 0 10
55855: PUSH
55856: LD_INT 5
55858: PUSH
55859: LD_INT 6
55861: PUSH
55862: EMPTY
55863: LIST
55864: LIST
55865: PUSH
55866: LD_INT 2
55868: PUSH
55869: LD_INT 4
55871: PUSH
55872: EMPTY
55873: LIST
55874: LIST
55875: PUSH
55876: LD_INT 3
55878: PUSH
55879: LD_INT 5
55881: PUSH
55882: EMPTY
55883: LIST
55884: LIST
55885: PUSH
55886: EMPTY
55887: LIST
55888: LIST
55889: LIST
55890: PUSH
55891: LD_INT 24
55893: PUSH
55894: LD_INT 25
55896: PUSH
55897: EMPTY
55898: LIST
55899: LIST
55900: PUSH
55901: LD_INT 23
55903: PUSH
55904: LD_INT 27
55906: PUSH
55907: EMPTY
55908: LIST
55909: LIST
55910: PUSH
55911: EMPTY
55912: LIST
55913: LIST
55914: PUSH
55915: LD_INT 42
55917: PUSH
55918: LD_INT 43
55920: PUSH
55921: EMPTY
55922: LIST
55923: LIST
55924: PUSH
55925: LD_INT 44
55927: PUSH
55928: LD_INT 46
55930: PUSH
55931: EMPTY
55932: LIST
55933: LIST
55934: PUSH
55935: LD_INT 45
55937: PUSH
55938: LD_INT 47
55940: PUSH
55941: EMPTY
55942: LIST
55943: LIST
55944: PUSH
55945: EMPTY
55946: LIST
55947: LIST
55948: LIST
55949: PUSH
55950: EMPTY
55951: LIST
55952: LIST
55953: LIST
55954: ST_TO_ADDR
// result := [ ] ;
55955: LD_ADDR_VAR 0 3
55959: PUSH
55960: EMPTY
55961: ST_TO_ADDR
// for i in turrets do
55962: LD_ADDR_VAR 0 4
55966: PUSH
55967: LD_VAR 0 1
55971: PUSH
55972: FOR_IN
55973: IFFALSE 56156
// begin nat := GetNation ( i ) ;
55975: LD_ADDR_VAR 0 7
55979: PUSH
55980: LD_VAR 0 4
55984: PPUSH
55985: CALL_OW 248
55989: ST_TO_ADDR
// weapon := 0 ;
55990: LD_ADDR_VAR 0 8
55994: PUSH
55995: LD_INT 0
55997: ST_TO_ADDR
// if not nat then
55998: LD_VAR 0 7
56002: NOT
56003: IFFALSE 56007
// continue ;
56005: GO 55972
// for j in list [ nat ] do
56007: LD_ADDR_VAR 0 5
56011: PUSH
56012: LD_VAR 0 10
56016: PUSH
56017: LD_VAR 0 7
56021: ARRAY
56022: PUSH
56023: FOR_IN
56024: IFFALSE 56065
// if GetBWeapon ( i ) = j [ 1 ] then
56026: LD_VAR 0 4
56030: PPUSH
56031: CALL_OW 269
56035: PUSH
56036: LD_VAR 0 5
56040: PUSH
56041: LD_INT 1
56043: ARRAY
56044: EQUAL
56045: IFFALSE 56063
// begin weapon := j [ 2 ] ;
56047: LD_ADDR_VAR 0 8
56051: PUSH
56052: LD_VAR 0 5
56056: PUSH
56057: LD_INT 2
56059: ARRAY
56060: ST_TO_ADDR
// break ;
56061: GO 56065
// end ;
56063: GO 56023
56065: POP
56066: POP
// if not weapon then
56067: LD_VAR 0 8
56071: NOT
56072: IFFALSE 56076
// continue ;
56074: GO 55972
// for k in factories do
56076: LD_ADDR_VAR 0 6
56080: PUSH
56081: LD_VAR 0 2
56085: PUSH
56086: FOR_IN
56087: IFFALSE 56152
// begin weapons := AvailableWeaponList ( k ) ;
56089: LD_ADDR_VAR 0 9
56093: PUSH
56094: LD_VAR 0 6
56098: PPUSH
56099: CALL_OW 478
56103: ST_TO_ADDR
// if not weapons then
56104: LD_VAR 0 9
56108: NOT
56109: IFFALSE 56113
// continue ;
56111: GO 56086
// if weapon in weapons then
56113: LD_VAR 0 8
56117: PUSH
56118: LD_VAR 0 9
56122: IN
56123: IFFALSE 56150
// begin result := [ i , weapon ] ;
56125: LD_ADDR_VAR 0 3
56129: PUSH
56130: LD_VAR 0 4
56134: PUSH
56135: LD_VAR 0 8
56139: PUSH
56140: EMPTY
56141: LIST
56142: LIST
56143: ST_TO_ADDR
// exit ;
56144: POP
56145: POP
56146: POP
56147: POP
56148: GO 56158
// end ; end ;
56150: GO 56086
56152: POP
56153: POP
// end ;
56154: GO 55972
56156: POP
56157: POP
// end ;
56158: LD_VAR 0 3
56162: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56163: LD_INT 0
56165: PPUSH
// if not side or side > 8 then
56166: LD_VAR 0 3
56170: NOT
56171: PUSH
56172: LD_VAR 0 3
56176: PUSH
56177: LD_INT 8
56179: GREATER
56180: OR
56181: IFFALSE 56185
// exit ;
56183: GO 56244
// if not range then
56185: LD_VAR 0 4
56189: NOT
56190: IFFALSE 56201
// range := - 12 ;
56192: LD_ADDR_VAR 0 4
56196: PUSH
56197: LD_INT 12
56199: NEG
56200: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56201: LD_VAR 0 1
56205: PPUSH
56206: LD_VAR 0 2
56210: PPUSH
56211: LD_VAR 0 3
56215: PPUSH
56216: LD_VAR 0 4
56220: PPUSH
56221: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56225: LD_VAR 0 1
56229: PPUSH
56230: LD_VAR 0 2
56234: PPUSH
56235: LD_VAR 0 3
56239: PPUSH
56240: CALL_OW 331
// end ;
56244: LD_VAR 0 5
56248: RET
// export function Video ( mode ) ; begin
56249: LD_INT 0
56251: PPUSH
// ingame_video = mode ;
56252: LD_ADDR_OWVAR 52
56256: PUSH
56257: LD_VAR 0 1
56261: ST_TO_ADDR
// interface_hidden = mode ;
56262: LD_ADDR_OWVAR 54
56266: PUSH
56267: LD_VAR 0 1
56271: ST_TO_ADDR
// end ;
56272: LD_VAR 0 2
56276: RET
// export function Join ( array , element ) ; begin
56277: LD_INT 0
56279: PPUSH
// result := array ^ element ;
56280: LD_ADDR_VAR 0 3
56284: PUSH
56285: LD_VAR 0 1
56289: PUSH
56290: LD_VAR 0 2
56294: ADD
56295: ST_TO_ADDR
// end ;
56296: LD_VAR 0 3
56300: RET
// export function JoinUnion ( array , element ) ; begin
56301: LD_INT 0
56303: PPUSH
// result := array union element ;
56304: LD_ADDR_VAR 0 3
56308: PUSH
56309: LD_VAR 0 1
56313: PUSH
56314: LD_VAR 0 2
56318: UNION
56319: ST_TO_ADDR
// end ;
56320: LD_VAR 0 3
56324: RET
// export function GetBehemoths ( side ) ; begin
56325: LD_INT 0
56327: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
56328: LD_ADDR_VAR 0 2
56332: PUSH
56333: LD_INT 22
56335: PUSH
56336: LD_VAR 0 1
56340: PUSH
56341: EMPTY
56342: LIST
56343: LIST
56344: PUSH
56345: LD_INT 31
56347: PUSH
56348: LD_INT 25
56350: PUSH
56351: EMPTY
56352: LIST
56353: LIST
56354: PUSH
56355: EMPTY
56356: LIST
56357: LIST
56358: PPUSH
56359: CALL_OW 69
56363: ST_TO_ADDR
// end ;
56364: LD_VAR 0 2
56368: RET
// export function Shuffle ( array ) ; var i , index ; begin
56369: LD_INT 0
56371: PPUSH
56372: PPUSH
56373: PPUSH
// result := [ ] ;
56374: LD_ADDR_VAR 0 2
56378: PUSH
56379: EMPTY
56380: ST_TO_ADDR
// if not array then
56381: LD_VAR 0 1
56385: NOT
56386: IFFALSE 56390
// exit ;
56388: GO 56489
// Randomize ;
56390: CALL_OW 10
// for i = array downto 1 do
56394: LD_ADDR_VAR 0 3
56398: PUSH
56399: DOUBLE
56400: LD_VAR 0 1
56404: INC
56405: ST_TO_ADDR
56406: LD_INT 1
56408: PUSH
56409: FOR_DOWNTO
56410: IFFALSE 56487
// begin index := rand ( 1 , array ) ;
56412: LD_ADDR_VAR 0 4
56416: PUSH
56417: LD_INT 1
56419: PPUSH
56420: LD_VAR 0 1
56424: PPUSH
56425: CALL_OW 12
56429: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56430: LD_ADDR_VAR 0 2
56434: PUSH
56435: LD_VAR 0 2
56439: PPUSH
56440: LD_VAR 0 2
56444: PUSH
56445: LD_INT 1
56447: PLUS
56448: PPUSH
56449: LD_VAR 0 1
56453: PUSH
56454: LD_VAR 0 4
56458: ARRAY
56459: PPUSH
56460: CALL_OW 2
56464: ST_TO_ADDR
// array := Delete ( array , index ) ;
56465: LD_ADDR_VAR 0 1
56469: PUSH
56470: LD_VAR 0 1
56474: PPUSH
56475: LD_VAR 0 4
56479: PPUSH
56480: CALL_OW 3
56484: ST_TO_ADDR
// end ;
56485: GO 56409
56487: POP
56488: POP
// end ; end_of_file
56489: LD_VAR 0 2
56493: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
56494: LD_INT 0
56496: PPUSH
56497: PPUSH
// skirmish := false ;
56498: LD_ADDR_EXP 56
56502: PUSH
56503: LD_INT 0
56505: ST_TO_ADDR
// debug_mc := false ;
56506: LD_ADDR_EXP 57
56510: PUSH
56511: LD_INT 0
56513: ST_TO_ADDR
// mc_bases := [ ] ;
56514: LD_ADDR_EXP 58
56518: PUSH
56519: EMPTY
56520: ST_TO_ADDR
// mc_sides := [ ] ;
56521: LD_ADDR_EXP 84
56525: PUSH
56526: EMPTY
56527: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
56528: LD_ADDR_EXP 59
56532: PUSH
56533: EMPTY
56534: ST_TO_ADDR
// mc_building_repairs := [ ] ;
56535: LD_ADDR_EXP 60
56539: PUSH
56540: EMPTY
56541: ST_TO_ADDR
// mc_need_heal := [ ] ;
56542: LD_ADDR_EXP 61
56546: PUSH
56547: EMPTY
56548: ST_TO_ADDR
// mc_healers := [ ] ;
56549: LD_ADDR_EXP 62
56553: PUSH
56554: EMPTY
56555: ST_TO_ADDR
// mc_build_list := [ ] ;
56556: LD_ADDR_EXP 63
56560: PUSH
56561: EMPTY
56562: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
56563: LD_ADDR_EXP 90
56567: PUSH
56568: EMPTY
56569: ST_TO_ADDR
// mc_builders := [ ] ;
56570: LD_ADDR_EXP 64
56574: PUSH
56575: EMPTY
56576: ST_TO_ADDR
// mc_construct_list := [ ] ;
56577: LD_ADDR_EXP 65
56581: PUSH
56582: EMPTY
56583: ST_TO_ADDR
// mc_turret_list := [ ] ;
56584: LD_ADDR_EXP 66
56588: PUSH
56589: EMPTY
56590: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
56591: LD_ADDR_EXP 67
56595: PUSH
56596: EMPTY
56597: ST_TO_ADDR
// mc_miners := [ ] ;
56598: LD_ADDR_EXP 72
56602: PUSH
56603: EMPTY
56604: ST_TO_ADDR
// mc_mines := [ ] ;
56605: LD_ADDR_EXP 71
56609: PUSH
56610: EMPTY
56611: ST_TO_ADDR
// mc_minefields := [ ] ;
56612: LD_ADDR_EXP 73
56616: PUSH
56617: EMPTY
56618: ST_TO_ADDR
// mc_crates := [ ] ;
56619: LD_ADDR_EXP 74
56623: PUSH
56624: EMPTY
56625: ST_TO_ADDR
// mc_crates_collector := [ ] ;
56626: LD_ADDR_EXP 75
56630: PUSH
56631: EMPTY
56632: ST_TO_ADDR
// mc_crates_area := [ ] ;
56633: LD_ADDR_EXP 76
56637: PUSH
56638: EMPTY
56639: ST_TO_ADDR
// mc_vehicles := [ ] ;
56640: LD_ADDR_EXP 77
56644: PUSH
56645: EMPTY
56646: ST_TO_ADDR
// mc_attack := [ ] ;
56647: LD_ADDR_EXP 78
56651: PUSH
56652: EMPTY
56653: ST_TO_ADDR
// mc_produce := [ ] ;
56654: LD_ADDR_EXP 79
56658: PUSH
56659: EMPTY
56660: ST_TO_ADDR
// mc_defender := [ ] ;
56661: LD_ADDR_EXP 80
56665: PUSH
56666: EMPTY
56667: ST_TO_ADDR
// mc_parking := [ ] ;
56668: LD_ADDR_EXP 82
56672: PUSH
56673: EMPTY
56674: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
56675: LD_ADDR_EXP 68
56679: PUSH
56680: EMPTY
56681: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
56682: LD_ADDR_EXP 70
56686: PUSH
56687: EMPTY
56688: ST_TO_ADDR
// mc_scan := [ ] ;
56689: LD_ADDR_EXP 81
56693: PUSH
56694: EMPTY
56695: ST_TO_ADDR
// mc_scan_area := [ ] ;
56696: LD_ADDR_EXP 83
56700: PUSH
56701: EMPTY
56702: ST_TO_ADDR
// mc_tech := [ ] ;
56703: LD_ADDR_EXP 85
56707: PUSH
56708: EMPTY
56709: ST_TO_ADDR
// mc_class := [ ] ;
56710: LD_ADDR_EXP 99
56714: PUSH
56715: EMPTY
56716: ST_TO_ADDR
// mc_class_case_use := [ ] ;
56717: LD_ADDR_EXP 100
56721: PUSH
56722: EMPTY
56723: ST_TO_ADDR
// end ;
56724: LD_VAR 0 1
56728: RET
// export function MC_Kill ( base ) ; begin
56729: LD_INT 0
56731: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
56732: LD_ADDR_EXP 58
56736: PUSH
56737: LD_EXP 58
56741: PPUSH
56742: LD_VAR 0 1
56746: PPUSH
56747: EMPTY
56748: PPUSH
56749: CALL_OW 1
56753: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56754: LD_ADDR_EXP 59
56758: PUSH
56759: LD_EXP 59
56763: PPUSH
56764: LD_VAR 0 1
56768: PPUSH
56769: EMPTY
56770: PPUSH
56771: CALL_OW 1
56775: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56776: LD_ADDR_EXP 60
56780: PUSH
56781: LD_EXP 60
56785: PPUSH
56786: LD_VAR 0 1
56790: PPUSH
56791: EMPTY
56792: PPUSH
56793: CALL_OW 1
56797: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56798: LD_ADDR_EXP 61
56802: PUSH
56803: LD_EXP 61
56807: PPUSH
56808: LD_VAR 0 1
56812: PPUSH
56813: EMPTY
56814: PPUSH
56815: CALL_OW 1
56819: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56820: LD_ADDR_EXP 62
56824: PUSH
56825: LD_EXP 62
56829: PPUSH
56830: LD_VAR 0 1
56834: PPUSH
56835: EMPTY
56836: PPUSH
56837: CALL_OW 1
56841: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56842: LD_ADDR_EXP 63
56846: PUSH
56847: LD_EXP 63
56851: PPUSH
56852: LD_VAR 0 1
56856: PPUSH
56857: EMPTY
56858: PPUSH
56859: CALL_OW 1
56863: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56864: LD_ADDR_EXP 64
56868: PUSH
56869: LD_EXP 64
56873: PPUSH
56874: LD_VAR 0 1
56878: PPUSH
56879: EMPTY
56880: PPUSH
56881: CALL_OW 1
56885: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56886: LD_ADDR_EXP 65
56890: PUSH
56891: LD_EXP 65
56895: PPUSH
56896: LD_VAR 0 1
56900: PPUSH
56901: EMPTY
56902: PPUSH
56903: CALL_OW 1
56907: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56908: LD_ADDR_EXP 66
56912: PUSH
56913: LD_EXP 66
56917: PPUSH
56918: LD_VAR 0 1
56922: PPUSH
56923: EMPTY
56924: PPUSH
56925: CALL_OW 1
56929: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56930: LD_ADDR_EXP 67
56934: PUSH
56935: LD_EXP 67
56939: PPUSH
56940: LD_VAR 0 1
56944: PPUSH
56945: EMPTY
56946: PPUSH
56947: CALL_OW 1
56951: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56952: LD_ADDR_EXP 68
56956: PUSH
56957: LD_EXP 68
56961: PPUSH
56962: LD_VAR 0 1
56966: PPUSH
56967: EMPTY
56968: PPUSH
56969: CALL_OW 1
56973: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56974: LD_ADDR_EXP 69
56978: PUSH
56979: LD_EXP 69
56983: PPUSH
56984: LD_VAR 0 1
56988: PPUSH
56989: LD_INT 0
56991: PPUSH
56992: CALL_OW 1
56996: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56997: LD_ADDR_EXP 70
57001: PUSH
57002: LD_EXP 70
57006: PPUSH
57007: LD_VAR 0 1
57011: PPUSH
57012: EMPTY
57013: PPUSH
57014: CALL_OW 1
57018: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57019: LD_ADDR_EXP 71
57023: PUSH
57024: LD_EXP 71
57028: PPUSH
57029: LD_VAR 0 1
57033: PPUSH
57034: EMPTY
57035: PPUSH
57036: CALL_OW 1
57040: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57041: LD_ADDR_EXP 72
57045: PUSH
57046: LD_EXP 72
57050: PPUSH
57051: LD_VAR 0 1
57055: PPUSH
57056: EMPTY
57057: PPUSH
57058: CALL_OW 1
57062: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57063: LD_ADDR_EXP 73
57067: PUSH
57068: LD_EXP 73
57072: PPUSH
57073: LD_VAR 0 1
57077: PPUSH
57078: EMPTY
57079: PPUSH
57080: CALL_OW 1
57084: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57085: LD_ADDR_EXP 74
57089: PUSH
57090: LD_EXP 74
57094: PPUSH
57095: LD_VAR 0 1
57099: PPUSH
57100: EMPTY
57101: PPUSH
57102: CALL_OW 1
57106: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57107: LD_ADDR_EXP 75
57111: PUSH
57112: LD_EXP 75
57116: PPUSH
57117: LD_VAR 0 1
57121: PPUSH
57122: EMPTY
57123: PPUSH
57124: CALL_OW 1
57128: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57129: LD_ADDR_EXP 76
57133: PUSH
57134: LD_EXP 76
57138: PPUSH
57139: LD_VAR 0 1
57143: PPUSH
57144: EMPTY
57145: PPUSH
57146: CALL_OW 1
57150: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57151: LD_ADDR_EXP 77
57155: PUSH
57156: LD_EXP 77
57160: PPUSH
57161: LD_VAR 0 1
57165: PPUSH
57166: EMPTY
57167: PPUSH
57168: CALL_OW 1
57172: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57173: LD_ADDR_EXP 78
57177: PUSH
57178: LD_EXP 78
57182: PPUSH
57183: LD_VAR 0 1
57187: PPUSH
57188: EMPTY
57189: PPUSH
57190: CALL_OW 1
57194: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57195: LD_ADDR_EXP 79
57199: PUSH
57200: LD_EXP 79
57204: PPUSH
57205: LD_VAR 0 1
57209: PPUSH
57210: EMPTY
57211: PPUSH
57212: CALL_OW 1
57216: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57217: LD_ADDR_EXP 80
57221: PUSH
57222: LD_EXP 80
57226: PPUSH
57227: LD_VAR 0 1
57231: PPUSH
57232: EMPTY
57233: PPUSH
57234: CALL_OW 1
57238: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57239: LD_ADDR_EXP 81
57243: PUSH
57244: LD_EXP 81
57248: PPUSH
57249: LD_VAR 0 1
57253: PPUSH
57254: EMPTY
57255: PPUSH
57256: CALL_OW 1
57260: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57261: LD_ADDR_EXP 82
57265: PUSH
57266: LD_EXP 82
57270: PPUSH
57271: LD_VAR 0 1
57275: PPUSH
57276: EMPTY
57277: PPUSH
57278: CALL_OW 1
57282: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57283: LD_ADDR_EXP 83
57287: PUSH
57288: LD_EXP 83
57292: PPUSH
57293: LD_VAR 0 1
57297: PPUSH
57298: EMPTY
57299: PPUSH
57300: CALL_OW 1
57304: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57305: LD_ADDR_EXP 85
57309: PUSH
57310: LD_EXP 85
57314: PPUSH
57315: LD_VAR 0 1
57319: PPUSH
57320: EMPTY
57321: PPUSH
57322: CALL_OW 1
57326: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57327: LD_ADDR_EXP 87
57331: PUSH
57332: LD_EXP 87
57336: PPUSH
57337: LD_VAR 0 1
57341: PPUSH
57342: EMPTY
57343: PPUSH
57344: CALL_OW 1
57348: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57349: LD_ADDR_EXP 88
57353: PUSH
57354: LD_EXP 88
57358: PPUSH
57359: LD_VAR 0 1
57363: PPUSH
57364: EMPTY
57365: PPUSH
57366: CALL_OW 1
57370: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57371: LD_ADDR_EXP 89
57375: PUSH
57376: LD_EXP 89
57380: PPUSH
57381: LD_VAR 0 1
57385: PPUSH
57386: EMPTY
57387: PPUSH
57388: CALL_OW 1
57392: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57393: LD_ADDR_EXP 90
57397: PUSH
57398: LD_EXP 90
57402: PPUSH
57403: LD_VAR 0 1
57407: PPUSH
57408: EMPTY
57409: PPUSH
57410: CALL_OW 1
57414: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57415: LD_ADDR_EXP 91
57419: PUSH
57420: LD_EXP 91
57424: PPUSH
57425: LD_VAR 0 1
57429: PPUSH
57430: EMPTY
57431: PPUSH
57432: CALL_OW 1
57436: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57437: LD_ADDR_EXP 92
57441: PUSH
57442: LD_EXP 92
57446: PPUSH
57447: LD_VAR 0 1
57451: PPUSH
57452: EMPTY
57453: PPUSH
57454: CALL_OW 1
57458: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57459: LD_ADDR_EXP 93
57463: PUSH
57464: LD_EXP 93
57468: PPUSH
57469: LD_VAR 0 1
57473: PPUSH
57474: EMPTY
57475: PPUSH
57476: CALL_OW 1
57480: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57481: LD_ADDR_EXP 94
57485: PUSH
57486: LD_EXP 94
57490: PPUSH
57491: LD_VAR 0 1
57495: PPUSH
57496: EMPTY
57497: PPUSH
57498: CALL_OW 1
57502: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57503: LD_ADDR_EXP 95
57507: PUSH
57508: LD_EXP 95
57512: PPUSH
57513: LD_VAR 0 1
57517: PPUSH
57518: EMPTY
57519: PPUSH
57520: CALL_OW 1
57524: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57525: LD_ADDR_EXP 96
57529: PUSH
57530: LD_EXP 96
57534: PPUSH
57535: LD_VAR 0 1
57539: PPUSH
57540: EMPTY
57541: PPUSH
57542: CALL_OW 1
57546: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57547: LD_ADDR_EXP 97
57551: PUSH
57552: LD_EXP 97
57556: PPUSH
57557: LD_VAR 0 1
57561: PPUSH
57562: EMPTY
57563: PPUSH
57564: CALL_OW 1
57568: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57569: LD_ADDR_EXP 98
57573: PUSH
57574: LD_EXP 98
57578: PPUSH
57579: LD_VAR 0 1
57583: PPUSH
57584: EMPTY
57585: PPUSH
57586: CALL_OW 1
57590: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57591: LD_ADDR_EXP 99
57595: PUSH
57596: LD_EXP 99
57600: PPUSH
57601: LD_VAR 0 1
57605: PPUSH
57606: EMPTY
57607: PPUSH
57608: CALL_OW 1
57612: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57613: LD_ADDR_EXP 100
57617: PUSH
57618: LD_EXP 100
57622: PPUSH
57623: LD_VAR 0 1
57627: PPUSH
57628: LD_INT 0
57630: PPUSH
57631: CALL_OW 1
57635: ST_TO_ADDR
// end ;
57636: LD_VAR 0 2
57640: RET
// export function MC_Add ( side , units ) ; var base ; begin
57641: LD_INT 0
57643: PPUSH
57644: PPUSH
// base := mc_bases + 1 ;
57645: LD_ADDR_VAR 0 4
57649: PUSH
57650: LD_EXP 58
57654: PUSH
57655: LD_INT 1
57657: PLUS
57658: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
57659: LD_ADDR_EXP 84
57663: PUSH
57664: LD_EXP 84
57668: PPUSH
57669: LD_VAR 0 4
57673: PPUSH
57674: LD_VAR 0 1
57678: PPUSH
57679: CALL_OW 1
57683: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
57684: LD_ADDR_EXP 58
57688: PUSH
57689: LD_EXP 58
57693: PPUSH
57694: LD_VAR 0 4
57698: PPUSH
57699: LD_VAR 0 2
57703: PPUSH
57704: CALL_OW 1
57708: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57709: LD_ADDR_EXP 59
57713: PUSH
57714: LD_EXP 59
57718: PPUSH
57719: LD_VAR 0 4
57723: PPUSH
57724: EMPTY
57725: PPUSH
57726: CALL_OW 1
57730: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57731: LD_ADDR_EXP 60
57735: PUSH
57736: LD_EXP 60
57740: PPUSH
57741: LD_VAR 0 4
57745: PPUSH
57746: EMPTY
57747: PPUSH
57748: CALL_OW 1
57752: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57753: LD_ADDR_EXP 61
57757: PUSH
57758: LD_EXP 61
57762: PPUSH
57763: LD_VAR 0 4
57767: PPUSH
57768: EMPTY
57769: PPUSH
57770: CALL_OW 1
57774: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57775: LD_ADDR_EXP 62
57779: PUSH
57780: LD_EXP 62
57784: PPUSH
57785: LD_VAR 0 4
57789: PPUSH
57790: EMPTY
57791: PPUSH
57792: CALL_OW 1
57796: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57797: LD_ADDR_EXP 63
57801: PUSH
57802: LD_EXP 63
57806: PPUSH
57807: LD_VAR 0 4
57811: PPUSH
57812: EMPTY
57813: PPUSH
57814: CALL_OW 1
57818: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57819: LD_ADDR_EXP 64
57823: PUSH
57824: LD_EXP 64
57828: PPUSH
57829: LD_VAR 0 4
57833: PPUSH
57834: EMPTY
57835: PPUSH
57836: CALL_OW 1
57840: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57841: LD_ADDR_EXP 65
57845: PUSH
57846: LD_EXP 65
57850: PPUSH
57851: LD_VAR 0 4
57855: PPUSH
57856: EMPTY
57857: PPUSH
57858: CALL_OW 1
57862: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57863: LD_ADDR_EXP 66
57867: PUSH
57868: LD_EXP 66
57872: PPUSH
57873: LD_VAR 0 4
57877: PPUSH
57878: EMPTY
57879: PPUSH
57880: CALL_OW 1
57884: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57885: LD_ADDR_EXP 67
57889: PUSH
57890: LD_EXP 67
57894: PPUSH
57895: LD_VAR 0 4
57899: PPUSH
57900: EMPTY
57901: PPUSH
57902: CALL_OW 1
57906: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57907: LD_ADDR_EXP 68
57911: PUSH
57912: LD_EXP 68
57916: PPUSH
57917: LD_VAR 0 4
57921: PPUSH
57922: EMPTY
57923: PPUSH
57924: CALL_OW 1
57928: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57929: LD_ADDR_EXP 69
57933: PUSH
57934: LD_EXP 69
57938: PPUSH
57939: LD_VAR 0 4
57943: PPUSH
57944: LD_INT 0
57946: PPUSH
57947: CALL_OW 1
57951: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57952: LD_ADDR_EXP 70
57956: PUSH
57957: LD_EXP 70
57961: PPUSH
57962: LD_VAR 0 4
57966: PPUSH
57967: EMPTY
57968: PPUSH
57969: CALL_OW 1
57973: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57974: LD_ADDR_EXP 71
57978: PUSH
57979: LD_EXP 71
57983: PPUSH
57984: LD_VAR 0 4
57988: PPUSH
57989: EMPTY
57990: PPUSH
57991: CALL_OW 1
57995: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57996: LD_ADDR_EXP 72
58000: PUSH
58001: LD_EXP 72
58005: PPUSH
58006: LD_VAR 0 4
58010: PPUSH
58011: EMPTY
58012: PPUSH
58013: CALL_OW 1
58017: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58018: LD_ADDR_EXP 73
58022: PUSH
58023: LD_EXP 73
58027: PPUSH
58028: LD_VAR 0 4
58032: PPUSH
58033: EMPTY
58034: PPUSH
58035: CALL_OW 1
58039: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58040: LD_ADDR_EXP 74
58044: PUSH
58045: LD_EXP 74
58049: PPUSH
58050: LD_VAR 0 4
58054: PPUSH
58055: EMPTY
58056: PPUSH
58057: CALL_OW 1
58061: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58062: LD_ADDR_EXP 75
58066: PUSH
58067: LD_EXP 75
58071: PPUSH
58072: LD_VAR 0 4
58076: PPUSH
58077: EMPTY
58078: PPUSH
58079: CALL_OW 1
58083: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58084: LD_ADDR_EXP 76
58088: PUSH
58089: LD_EXP 76
58093: PPUSH
58094: LD_VAR 0 4
58098: PPUSH
58099: EMPTY
58100: PPUSH
58101: CALL_OW 1
58105: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58106: LD_ADDR_EXP 77
58110: PUSH
58111: LD_EXP 77
58115: PPUSH
58116: LD_VAR 0 4
58120: PPUSH
58121: EMPTY
58122: PPUSH
58123: CALL_OW 1
58127: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58128: LD_ADDR_EXP 78
58132: PUSH
58133: LD_EXP 78
58137: PPUSH
58138: LD_VAR 0 4
58142: PPUSH
58143: EMPTY
58144: PPUSH
58145: CALL_OW 1
58149: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58150: LD_ADDR_EXP 79
58154: PUSH
58155: LD_EXP 79
58159: PPUSH
58160: LD_VAR 0 4
58164: PPUSH
58165: EMPTY
58166: PPUSH
58167: CALL_OW 1
58171: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58172: LD_ADDR_EXP 80
58176: PUSH
58177: LD_EXP 80
58181: PPUSH
58182: LD_VAR 0 4
58186: PPUSH
58187: EMPTY
58188: PPUSH
58189: CALL_OW 1
58193: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58194: LD_ADDR_EXP 81
58198: PUSH
58199: LD_EXP 81
58203: PPUSH
58204: LD_VAR 0 4
58208: PPUSH
58209: EMPTY
58210: PPUSH
58211: CALL_OW 1
58215: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58216: LD_ADDR_EXP 82
58220: PUSH
58221: LD_EXP 82
58225: PPUSH
58226: LD_VAR 0 4
58230: PPUSH
58231: EMPTY
58232: PPUSH
58233: CALL_OW 1
58237: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58238: LD_ADDR_EXP 83
58242: PUSH
58243: LD_EXP 83
58247: PPUSH
58248: LD_VAR 0 4
58252: PPUSH
58253: EMPTY
58254: PPUSH
58255: CALL_OW 1
58259: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58260: LD_ADDR_EXP 85
58264: PUSH
58265: LD_EXP 85
58269: PPUSH
58270: LD_VAR 0 4
58274: PPUSH
58275: EMPTY
58276: PPUSH
58277: CALL_OW 1
58281: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58282: LD_ADDR_EXP 87
58286: PUSH
58287: LD_EXP 87
58291: PPUSH
58292: LD_VAR 0 4
58296: PPUSH
58297: EMPTY
58298: PPUSH
58299: CALL_OW 1
58303: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58304: LD_ADDR_EXP 88
58308: PUSH
58309: LD_EXP 88
58313: PPUSH
58314: LD_VAR 0 4
58318: PPUSH
58319: EMPTY
58320: PPUSH
58321: CALL_OW 1
58325: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58326: LD_ADDR_EXP 89
58330: PUSH
58331: LD_EXP 89
58335: PPUSH
58336: LD_VAR 0 4
58340: PPUSH
58341: EMPTY
58342: PPUSH
58343: CALL_OW 1
58347: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58348: LD_ADDR_EXP 90
58352: PUSH
58353: LD_EXP 90
58357: PPUSH
58358: LD_VAR 0 4
58362: PPUSH
58363: EMPTY
58364: PPUSH
58365: CALL_OW 1
58369: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58370: LD_ADDR_EXP 91
58374: PUSH
58375: LD_EXP 91
58379: PPUSH
58380: LD_VAR 0 4
58384: PPUSH
58385: EMPTY
58386: PPUSH
58387: CALL_OW 1
58391: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58392: LD_ADDR_EXP 92
58396: PUSH
58397: LD_EXP 92
58401: PPUSH
58402: LD_VAR 0 4
58406: PPUSH
58407: EMPTY
58408: PPUSH
58409: CALL_OW 1
58413: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58414: LD_ADDR_EXP 93
58418: PUSH
58419: LD_EXP 93
58423: PPUSH
58424: LD_VAR 0 4
58428: PPUSH
58429: EMPTY
58430: PPUSH
58431: CALL_OW 1
58435: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58436: LD_ADDR_EXP 94
58440: PUSH
58441: LD_EXP 94
58445: PPUSH
58446: LD_VAR 0 4
58450: PPUSH
58451: EMPTY
58452: PPUSH
58453: CALL_OW 1
58457: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58458: LD_ADDR_EXP 95
58462: PUSH
58463: LD_EXP 95
58467: PPUSH
58468: LD_VAR 0 4
58472: PPUSH
58473: EMPTY
58474: PPUSH
58475: CALL_OW 1
58479: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58480: LD_ADDR_EXP 96
58484: PUSH
58485: LD_EXP 96
58489: PPUSH
58490: LD_VAR 0 4
58494: PPUSH
58495: EMPTY
58496: PPUSH
58497: CALL_OW 1
58501: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58502: LD_ADDR_EXP 97
58506: PUSH
58507: LD_EXP 97
58511: PPUSH
58512: LD_VAR 0 4
58516: PPUSH
58517: EMPTY
58518: PPUSH
58519: CALL_OW 1
58523: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58524: LD_ADDR_EXP 98
58528: PUSH
58529: LD_EXP 98
58533: PPUSH
58534: LD_VAR 0 4
58538: PPUSH
58539: EMPTY
58540: PPUSH
58541: CALL_OW 1
58545: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58546: LD_ADDR_EXP 99
58550: PUSH
58551: LD_EXP 99
58555: PPUSH
58556: LD_VAR 0 4
58560: PPUSH
58561: EMPTY
58562: PPUSH
58563: CALL_OW 1
58567: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58568: LD_ADDR_EXP 100
58572: PUSH
58573: LD_EXP 100
58577: PPUSH
58578: LD_VAR 0 4
58582: PPUSH
58583: LD_INT 0
58585: PPUSH
58586: CALL_OW 1
58590: ST_TO_ADDR
// result := base ;
58591: LD_ADDR_VAR 0 3
58595: PUSH
58596: LD_VAR 0 4
58600: ST_TO_ADDR
// end ;
58601: LD_VAR 0 3
58605: RET
// export function MC_Start ( ) ; var i ; begin
58606: LD_INT 0
58608: PPUSH
58609: PPUSH
// for i = 1 to mc_bases do
58610: LD_ADDR_VAR 0 2
58614: PUSH
58615: DOUBLE
58616: LD_INT 1
58618: DEC
58619: ST_TO_ADDR
58620: LD_EXP 58
58624: PUSH
58625: FOR_TO
58626: IFFALSE 59703
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
58628: LD_ADDR_EXP 58
58632: PUSH
58633: LD_EXP 58
58637: PPUSH
58638: LD_VAR 0 2
58642: PPUSH
58643: LD_EXP 58
58647: PUSH
58648: LD_VAR 0 2
58652: ARRAY
58653: PUSH
58654: LD_INT 0
58656: DIFF
58657: PPUSH
58658: CALL_OW 1
58662: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
58663: LD_ADDR_EXP 59
58667: PUSH
58668: LD_EXP 59
58672: PPUSH
58673: LD_VAR 0 2
58677: PPUSH
58678: EMPTY
58679: PPUSH
58680: CALL_OW 1
58684: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
58685: LD_ADDR_EXP 60
58689: PUSH
58690: LD_EXP 60
58694: PPUSH
58695: LD_VAR 0 2
58699: PPUSH
58700: EMPTY
58701: PPUSH
58702: CALL_OW 1
58706: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
58707: LD_ADDR_EXP 61
58711: PUSH
58712: LD_EXP 61
58716: PPUSH
58717: LD_VAR 0 2
58721: PPUSH
58722: EMPTY
58723: PPUSH
58724: CALL_OW 1
58728: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
58729: LD_ADDR_EXP 62
58733: PUSH
58734: LD_EXP 62
58738: PPUSH
58739: LD_VAR 0 2
58743: PPUSH
58744: EMPTY
58745: PUSH
58746: EMPTY
58747: PUSH
58748: EMPTY
58749: LIST
58750: LIST
58751: PPUSH
58752: CALL_OW 1
58756: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
58757: LD_ADDR_EXP 63
58761: PUSH
58762: LD_EXP 63
58766: PPUSH
58767: LD_VAR 0 2
58771: PPUSH
58772: EMPTY
58773: PPUSH
58774: CALL_OW 1
58778: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
58779: LD_ADDR_EXP 90
58783: PUSH
58784: LD_EXP 90
58788: PPUSH
58789: LD_VAR 0 2
58793: PPUSH
58794: EMPTY
58795: PPUSH
58796: CALL_OW 1
58800: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
58801: LD_ADDR_EXP 64
58805: PUSH
58806: LD_EXP 64
58810: PPUSH
58811: LD_VAR 0 2
58815: PPUSH
58816: EMPTY
58817: PPUSH
58818: CALL_OW 1
58822: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
58823: LD_ADDR_EXP 65
58827: PUSH
58828: LD_EXP 65
58832: PPUSH
58833: LD_VAR 0 2
58837: PPUSH
58838: EMPTY
58839: PPUSH
58840: CALL_OW 1
58844: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
58845: LD_ADDR_EXP 66
58849: PUSH
58850: LD_EXP 66
58854: PPUSH
58855: LD_VAR 0 2
58859: PPUSH
58860: LD_EXP 58
58864: PUSH
58865: LD_VAR 0 2
58869: ARRAY
58870: PPUSH
58871: LD_INT 2
58873: PUSH
58874: LD_INT 30
58876: PUSH
58877: LD_INT 32
58879: PUSH
58880: EMPTY
58881: LIST
58882: LIST
58883: PUSH
58884: LD_INT 30
58886: PUSH
58887: LD_INT 33
58889: PUSH
58890: EMPTY
58891: LIST
58892: LIST
58893: PUSH
58894: EMPTY
58895: LIST
58896: LIST
58897: LIST
58898: PPUSH
58899: CALL_OW 72
58903: PPUSH
58904: CALL_OW 1
58908: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
58909: LD_ADDR_EXP 67
58913: PUSH
58914: LD_EXP 67
58918: PPUSH
58919: LD_VAR 0 2
58923: PPUSH
58924: LD_EXP 58
58928: PUSH
58929: LD_VAR 0 2
58933: ARRAY
58934: PPUSH
58935: LD_INT 2
58937: PUSH
58938: LD_INT 30
58940: PUSH
58941: LD_INT 32
58943: PUSH
58944: EMPTY
58945: LIST
58946: LIST
58947: PUSH
58948: LD_INT 30
58950: PUSH
58951: LD_INT 31
58953: PUSH
58954: EMPTY
58955: LIST
58956: LIST
58957: PUSH
58958: EMPTY
58959: LIST
58960: LIST
58961: LIST
58962: PUSH
58963: LD_INT 58
58965: PUSH
58966: EMPTY
58967: LIST
58968: PUSH
58969: EMPTY
58970: LIST
58971: LIST
58972: PPUSH
58973: CALL_OW 72
58977: PPUSH
58978: CALL_OW 1
58982: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
58983: LD_ADDR_EXP 68
58987: PUSH
58988: LD_EXP 68
58992: PPUSH
58993: LD_VAR 0 2
58997: PPUSH
58998: EMPTY
58999: PPUSH
59000: CALL_OW 1
59004: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
59005: LD_ADDR_EXP 72
59009: PUSH
59010: LD_EXP 72
59014: PPUSH
59015: LD_VAR 0 2
59019: PPUSH
59020: EMPTY
59021: PPUSH
59022: CALL_OW 1
59026: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
59027: LD_ADDR_EXP 71
59031: PUSH
59032: LD_EXP 71
59036: PPUSH
59037: LD_VAR 0 2
59041: PPUSH
59042: EMPTY
59043: PPUSH
59044: CALL_OW 1
59048: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
59049: LD_ADDR_EXP 73
59053: PUSH
59054: LD_EXP 73
59058: PPUSH
59059: LD_VAR 0 2
59063: PPUSH
59064: EMPTY
59065: PPUSH
59066: CALL_OW 1
59070: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
59071: LD_ADDR_EXP 74
59075: PUSH
59076: LD_EXP 74
59080: PPUSH
59081: LD_VAR 0 2
59085: PPUSH
59086: EMPTY
59087: PPUSH
59088: CALL_OW 1
59092: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
59093: LD_ADDR_EXP 75
59097: PUSH
59098: LD_EXP 75
59102: PPUSH
59103: LD_VAR 0 2
59107: PPUSH
59108: EMPTY
59109: PPUSH
59110: CALL_OW 1
59114: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
59115: LD_ADDR_EXP 76
59119: PUSH
59120: LD_EXP 76
59124: PPUSH
59125: LD_VAR 0 2
59129: PPUSH
59130: EMPTY
59131: PPUSH
59132: CALL_OW 1
59136: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
59137: LD_ADDR_EXP 77
59141: PUSH
59142: LD_EXP 77
59146: PPUSH
59147: LD_VAR 0 2
59151: PPUSH
59152: EMPTY
59153: PPUSH
59154: CALL_OW 1
59158: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
59159: LD_ADDR_EXP 78
59163: PUSH
59164: LD_EXP 78
59168: PPUSH
59169: LD_VAR 0 2
59173: PPUSH
59174: EMPTY
59175: PPUSH
59176: CALL_OW 1
59180: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
59181: LD_ADDR_EXP 79
59185: PUSH
59186: LD_EXP 79
59190: PPUSH
59191: LD_VAR 0 2
59195: PPUSH
59196: EMPTY
59197: PPUSH
59198: CALL_OW 1
59202: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
59203: LD_ADDR_EXP 80
59207: PUSH
59208: LD_EXP 80
59212: PPUSH
59213: LD_VAR 0 2
59217: PPUSH
59218: EMPTY
59219: PPUSH
59220: CALL_OW 1
59224: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
59225: LD_ADDR_EXP 69
59229: PUSH
59230: LD_EXP 69
59234: PPUSH
59235: LD_VAR 0 2
59239: PPUSH
59240: LD_INT 0
59242: PPUSH
59243: CALL_OW 1
59247: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
59248: LD_ADDR_EXP 82
59252: PUSH
59253: LD_EXP 82
59257: PPUSH
59258: LD_VAR 0 2
59262: PPUSH
59263: LD_INT 0
59265: PPUSH
59266: CALL_OW 1
59270: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59271: LD_ADDR_EXP 70
59275: PUSH
59276: LD_EXP 70
59280: PPUSH
59281: LD_VAR 0 2
59285: PPUSH
59286: EMPTY
59287: PPUSH
59288: CALL_OW 1
59292: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
59293: LD_ADDR_EXP 81
59297: PUSH
59298: LD_EXP 81
59302: PPUSH
59303: LD_VAR 0 2
59307: PPUSH
59308: LD_INT 0
59310: PPUSH
59311: CALL_OW 1
59315: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
59316: LD_ADDR_EXP 83
59320: PUSH
59321: LD_EXP 83
59325: PPUSH
59326: LD_VAR 0 2
59330: PPUSH
59331: EMPTY
59332: PPUSH
59333: CALL_OW 1
59337: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
59338: LD_ADDR_EXP 86
59342: PUSH
59343: LD_EXP 86
59347: PPUSH
59348: LD_VAR 0 2
59352: PPUSH
59353: LD_INT 0
59355: PPUSH
59356: CALL_OW 1
59360: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
59361: LD_ADDR_EXP 87
59365: PUSH
59366: LD_EXP 87
59370: PPUSH
59371: LD_VAR 0 2
59375: PPUSH
59376: EMPTY
59377: PPUSH
59378: CALL_OW 1
59382: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
59383: LD_ADDR_EXP 88
59387: PUSH
59388: LD_EXP 88
59392: PPUSH
59393: LD_VAR 0 2
59397: PPUSH
59398: EMPTY
59399: PPUSH
59400: CALL_OW 1
59404: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59405: LD_ADDR_EXP 89
59409: PUSH
59410: LD_EXP 89
59414: PPUSH
59415: LD_VAR 0 2
59419: PPUSH
59420: EMPTY
59421: PPUSH
59422: CALL_OW 1
59426: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
59427: LD_ADDR_EXP 91
59431: PUSH
59432: LD_EXP 91
59436: PPUSH
59437: LD_VAR 0 2
59441: PPUSH
59442: LD_EXP 58
59446: PUSH
59447: LD_VAR 0 2
59451: ARRAY
59452: PPUSH
59453: LD_INT 2
59455: PUSH
59456: LD_INT 30
59458: PUSH
59459: LD_INT 6
59461: PUSH
59462: EMPTY
59463: LIST
59464: LIST
59465: PUSH
59466: LD_INT 30
59468: PUSH
59469: LD_INT 7
59471: PUSH
59472: EMPTY
59473: LIST
59474: LIST
59475: PUSH
59476: LD_INT 30
59478: PUSH
59479: LD_INT 8
59481: PUSH
59482: EMPTY
59483: LIST
59484: LIST
59485: PUSH
59486: EMPTY
59487: LIST
59488: LIST
59489: LIST
59490: LIST
59491: PPUSH
59492: CALL_OW 72
59496: PPUSH
59497: CALL_OW 1
59501: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
59502: LD_ADDR_EXP 92
59506: PUSH
59507: LD_EXP 92
59511: PPUSH
59512: LD_VAR 0 2
59516: PPUSH
59517: EMPTY
59518: PPUSH
59519: CALL_OW 1
59523: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
59524: LD_ADDR_EXP 93
59528: PUSH
59529: LD_EXP 93
59533: PPUSH
59534: LD_VAR 0 2
59538: PPUSH
59539: EMPTY
59540: PPUSH
59541: CALL_OW 1
59545: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
59546: LD_ADDR_EXP 94
59550: PUSH
59551: LD_EXP 94
59555: PPUSH
59556: LD_VAR 0 2
59560: PPUSH
59561: EMPTY
59562: PPUSH
59563: CALL_OW 1
59567: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
59568: LD_ADDR_EXP 95
59572: PUSH
59573: LD_EXP 95
59577: PPUSH
59578: LD_VAR 0 2
59582: PPUSH
59583: EMPTY
59584: PPUSH
59585: CALL_OW 1
59589: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59590: LD_ADDR_EXP 96
59594: PUSH
59595: LD_EXP 96
59599: PPUSH
59600: LD_VAR 0 2
59604: PPUSH
59605: EMPTY
59606: PPUSH
59607: CALL_OW 1
59611: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
59612: LD_ADDR_EXP 97
59616: PUSH
59617: LD_EXP 97
59621: PPUSH
59622: LD_VAR 0 2
59626: PPUSH
59627: EMPTY
59628: PPUSH
59629: CALL_OW 1
59633: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
59634: LD_ADDR_EXP 98
59638: PUSH
59639: LD_EXP 98
59643: PPUSH
59644: LD_VAR 0 2
59648: PPUSH
59649: EMPTY
59650: PPUSH
59651: CALL_OW 1
59655: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
59656: LD_ADDR_EXP 99
59660: PUSH
59661: LD_EXP 99
59665: PPUSH
59666: LD_VAR 0 2
59670: PPUSH
59671: EMPTY
59672: PPUSH
59673: CALL_OW 1
59677: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
59678: LD_ADDR_EXP 100
59682: PUSH
59683: LD_EXP 100
59687: PPUSH
59688: LD_VAR 0 2
59692: PPUSH
59693: LD_INT 0
59695: PPUSH
59696: CALL_OW 1
59700: ST_TO_ADDR
// end ;
59701: GO 58625
59703: POP
59704: POP
// MC_InitSides ( ) ;
59705: CALL 59991 0 0
// MC_InitResearch ( ) ;
59709: CALL 59730 0 0
// CustomInitMacro ( ) ;
59713: CALL 181 0 0
// skirmish := true ;
59717: LD_ADDR_EXP 56
59721: PUSH
59722: LD_INT 1
59724: ST_TO_ADDR
// end ;
59725: LD_VAR 0 1
59729: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
59730: LD_INT 0
59732: PPUSH
59733: PPUSH
59734: PPUSH
59735: PPUSH
59736: PPUSH
59737: PPUSH
// if not mc_bases then
59738: LD_EXP 58
59742: NOT
59743: IFFALSE 59747
// exit ;
59745: GO 59986
// for i = 1 to 8 do
59747: LD_ADDR_VAR 0 2
59751: PUSH
59752: DOUBLE
59753: LD_INT 1
59755: DEC
59756: ST_TO_ADDR
59757: LD_INT 8
59759: PUSH
59760: FOR_TO
59761: IFFALSE 59787
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
59763: LD_ADDR_EXP 85
59767: PUSH
59768: LD_EXP 85
59772: PPUSH
59773: LD_VAR 0 2
59777: PPUSH
59778: EMPTY
59779: PPUSH
59780: CALL_OW 1
59784: ST_TO_ADDR
59785: GO 59760
59787: POP
59788: POP
// tmp := [ ] ;
59789: LD_ADDR_VAR 0 5
59793: PUSH
59794: EMPTY
59795: ST_TO_ADDR
// for i = 1 to mc_sides do
59796: LD_ADDR_VAR 0 2
59800: PUSH
59801: DOUBLE
59802: LD_INT 1
59804: DEC
59805: ST_TO_ADDR
59806: LD_EXP 84
59810: PUSH
59811: FOR_TO
59812: IFFALSE 59870
// if not mc_sides [ i ] in tmp then
59814: LD_EXP 84
59818: PUSH
59819: LD_VAR 0 2
59823: ARRAY
59824: PUSH
59825: LD_VAR 0 5
59829: IN
59830: NOT
59831: IFFALSE 59868
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
59833: LD_ADDR_VAR 0 5
59837: PUSH
59838: LD_VAR 0 5
59842: PPUSH
59843: LD_VAR 0 5
59847: PUSH
59848: LD_INT 1
59850: PLUS
59851: PPUSH
59852: LD_EXP 84
59856: PUSH
59857: LD_VAR 0 2
59861: ARRAY
59862: PPUSH
59863: CALL_OW 2
59867: ST_TO_ADDR
59868: GO 59811
59870: POP
59871: POP
// if not tmp then
59872: LD_VAR 0 5
59876: NOT
59877: IFFALSE 59881
// exit ;
59879: GO 59986
// for j in tmp do
59881: LD_ADDR_VAR 0 3
59885: PUSH
59886: LD_VAR 0 5
59890: PUSH
59891: FOR_IN
59892: IFFALSE 59984
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
59894: LD_ADDR_VAR 0 6
59898: PUSH
59899: LD_INT 22
59901: PUSH
59902: LD_VAR 0 3
59906: PUSH
59907: EMPTY
59908: LIST
59909: LIST
59910: PPUSH
59911: CALL_OW 69
59915: ST_TO_ADDR
// if not un then
59916: LD_VAR 0 6
59920: NOT
59921: IFFALSE 59925
// continue ;
59923: GO 59891
// nation := GetNation ( un [ 1 ] ) ;
59925: LD_ADDR_VAR 0 4
59929: PUSH
59930: LD_VAR 0 6
59934: PUSH
59935: LD_INT 1
59937: ARRAY
59938: PPUSH
59939: CALL_OW 248
59943: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
59944: LD_ADDR_EXP 85
59948: PUSH
59949: LD_EXP 85
59953: PPUSH
59954: LD_VAR 0 3
59958: PPUSH
59959: LD_VAR 0 3
59963: PPUSH
59964: LD_VAR 0 4
59968: PPUSH
59969: LD_INT 1
59971: PPUSH
59972: CALL 13992 0 3
59976: PPUSH
59977: CALL_OW 1
59981: ST_TO_ADDR
// end ;
59982: GO 59891
59984: POP
59985: POP
// end ;
59986: LD_VAR 0 1
59990: RET
// export function MC_InitSides ( ) ; var i ; begin
59991: LD_INT 0
59993: PPUSH
59994: PPUSH
// if not mc_bases then
59995: LD_EXP 58
59999: NOT
60000: IFFALSE 60004
// exit ;
60002: GO 60078
// for i = 1 to mc_bases do
60004: LD_ADDR_VAR 0 2
60008: PUSH
60009: DOUBLE
60010: LD_INT 1
60012: DEC
60013: ST_TO_ADDR
60014: LD_EXP 58
60018: PUSH
60019: FOR_TO
60020: IFFALSE 60076
// if mc_bases [ i ] then
60022: LD_EXP 58
60026: PUSH
60027: LD_VAR 0 2
60031: ARRAY
60032: IFFALSE 60074
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
60034: LD_ADDR_EXP 84
60038: PUSH
60039: LD_EXP 84
60043: PPUSH
60044: LD_VAR 0 2
60048: PPUSH
60049: LD_EXP 58
60053: PUSH
60054: LD_VAR 0 2
60058: ARRAY
60059: PUSH
60060: LD_INT 1
60062: ARRAY
60063: PPUSH
60064: CALL_OW 255
60068: PPUSH
60069: CALL_OW 1
60073: ST_TO_ADDR
60074: GO 60019
60076: POP
60077: POP
// end ;
60078: LD_VAR 0 1
60082: RET
// every 0 0$01 trigger skirmish do
60083: LD_EXP 56
60087: IFFALSE 60241
60089: GO 60091
60091: DISABLE
// begin enable ;
60092: ENABLE
// MC_CheckBuildings ( ) ;
60093: CALL 64730 0 0
// MC_CheckPeopleLife ( ) ;
60097: CALL 64855 0 0
// RaiseSailEvent ( 100 ) ;
60101: LD_INT 100
60103: PPUSH
60104: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
60108: LD_INT 103
60110: PPUSH
60111: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
60115: LD_INT 104
60117: PPUSH
60118: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
60122: LD_INT 105
60124: PPUSH
60125: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
60129: LD_INT 106
60131: PPUSH
60132: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
60136: LD_INT 107
60138: PPUSH
60139: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
60143: LD_INT 108
60145: PPUSH
60146: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
60150: LD_INT 109
60152: PPUSH
60153: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
60157: LD_INT 110
60159: PPUSH
60160: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
60164: LD_INT 111
60166: PPUSH
60167: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
60171: LD_INT 112
60173: PPUSH
60174: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
60178: LD_INT 113
60180: PPUSH
60181: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
60185: LD_INT 120
60187: PPUSH
60188: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
60192: LD_INT 121
60194: PPUSH
60195: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
60199: LD_INT 122
60201: PPUSH
60202: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
60206: LD_INT 123
60208: PPUSH
60209: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
60213: LD_INT 124
60215: PPUSH
60216: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
60220: LD_INT 125
60222: PPUSH
60223: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
60227: LD_INT 126
60229: PPUSH
60230: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
60234: LD_INT 200
60236: PPUSH
60237: CALL_OW 427
// end ;
60241: END
// on SailEvent ( event ) do begin if event < 100 then
60242: LD_VAR 0 1
60246: PUSH
60247: LD_INT 100
60249: LESS
60250: IFFALSE 60261
// CustomEvent ( event ) ;
60252: LD_VAR 0 1
60256: PPUSH
60257: CALL 12694 0 1
// if event = 100 then
60261: LD_VAR 0 1
60265: PUSH
60266: LD_INT 100
60268: EQUAL
60269: IFFALSE 60275
// MC_ClassManager ( ) ;
60271: CALL 60667 0 0
// if event = 101 then
60275: LD_VAR 0 1
60279: PUSH
60280: LD_INT 101
60282: EQUAL
60283: IFFALSE 60289
// MC_RepairBuildings ( ) ;
60285: CALL 65451 0 0
// if event = 102 then
60289: LD_VAR 0 1
60293: PUSH
60294: LD_INT 102
60296: EQUAL
60297: IFFALSE 60303
// MC_Heal ( ) ;
60299: CALL 65857 0 0
// if event = 103 then
60303: LD_VAR 0 1
60307: PUSH
60308: LD_INT 103
60310: EQUAL
60311: IFFALSE 60317
// MC_Build ( ) ;
60313: CALL 66279 0 0
// if event = 104 then
60317: LD_VAR 0 1
60321: PUSH
60322: LD_INT 104
60324: EQUAL
60325: IFFALSE 60331
// MC_TurretWeapon ( ) ;
60327: CALL 67892 0 0
// if event = 105 then
60331: LD_VAR 0 1
60335: PUSH
60336: LD_INT 105
60338: EQUAL
60339: IFFALSE 60345
// MC_BuildUpgrade ( ) ;
60341: CALL 67443 0 0
// if event = 106 then
60345: LD_VAR 0 1
60349: PUSH
60350: LD_INT 106
60352: EQUAL
60353: IFFALSE 60359
// MC_PlantMines ( ) ;
60355: CALL 68322 0 0
// if event = 107 then
60359: LD_VAR 0 1
60363: PUSH
60364: LD_INT 107
60366: EQUAL
60367: IFFALSE 60373
// MC_CollectCrates ( ) ;
60369: CALL 69356 0 0
// if event = 108 then
60373: LD_VAR 0 1
60377: PUSH
60378: LD_INT 108
60380: EQUAL
60381: IFFALSE 60387
// MC_LinkRemoteControl ( ) ;
60383: CALL 71113 0 0
// if event = 109 then
60387: LD_VAR 0 1
60391: PUSH
60392: LD_INT 109
60394: EQUAL
60395: IFFALSE 60401
// MC_ProduceVehicle ( ) ;
60397: CALL 71294 0 0
// if event = 110 then
60401: LD_VAR 0 1
60405: PUSH
60406: LD_INT 110
60408: EQUAL
60409: IFFALSE 60415
// MC_SendAttack ( ) ;
60411: CALL 71775 0 0
// if event = 111 then
60415: LD_VAR 0 1
60419: PUSH
60420: LD_INT 111
60422: EQUAL
60423: IFFALSE 60429
// MC_Defend ( ) ;
60425: CALL 71883 0 0
// if event = 112 then
60429: LD_VAR 0 1
60433: PUSH
60434: LD_INT 112
60436: EQUAL
60437: IFFALSE 60443
// MC_Research ( ) ;
60439: CALL 72488 0 0
// if event = 113 then
60443: LD_VAR 0 1
60447: PUSH
60448: LD_INT 113
60450: EQUAL
60451: IFFALSE 60457
// MC_MinesTrigger ( ) ;
60453: CALL 73602 0 0
// if event = 120 then
60457: LD_VAR 0 1
60461: PUSH
60462: LD_INT 120
60464: EQUAL
60465: IFFALSE 60471
// MC_RepairVehicle ( ) ;
60467: CALL 73701 0 0
// if event = 121 then
60471: LD_VAR 0 1
60475: PUSH
60476: LD_INT 121
60478: EQUAL
60479: IFFALSE 60485
// MC_TameApe ( ) ;
60481: CALL 74408 0 0
// if event = 122 then
60485: LD_VAR 0 1
60489: PUSH
60490: LD_INT 122
60492: EQUAL
60493: IFFALSE 60499
// MC_ChangeApeClass ( ) ;
60495: CALL 75237 0 0
// if event = 123 then
60499: LD_VAR 0 1
60503: PUSH
60504: LD_INT 123
60506: EQUAL
60507: IFFALSE 60513
// MC_Bazooka ( ) ;
60509: CALL 75887 0 0
// if event = 124 then
60513: LD_VAR 0 1
60517: PUSH
60518: LD_INT 124
60520: EQUAL
60521: IFFALSE 60527
// MC_TeleportExit ( ) ;
60523: CALL 76085 0 0
// if event = 125 then
60527: LD_VAR 0 1
60531: PUSH
60532: LD_INT 125
60534: EQUAL
60535: IFFALSE 60541
// MC_Deposits ( ) ;
60537: CALL 76732 0 0
// if event = 126 then
60541: LD_VAR 0 1
60545: PUSH
60546: LD_INT 126
60548: EQUAL
60549: IFFALSE 60555
// MC_RemoteDriver ( ) ;
60551: CALL 77357 0 0
// if event = 200 then
60555: LD_VAR 0 1
60559: PUSH
60560: LD_INT 200
60562: EQUAL
60563: IFFALSE 60569
// MC_Idle ( ) ;
60565: CALL 79090 0 0
// end ;
60569: PPOPN 1
60571: END
// export function MC_Reset ( base , tag ) ; var i ; begin
60572: LD_INT 0
60574: PPUSH
60575: PPUSH
// if not mc_bases [ base ] or not tag then
60576: LD_EXP 58
60580: PUSH
60581: LD_VAR 0 1
60585: ARRAY
60586: NOT
60587: PUSH
60588: LD_VAR 0 2
60592: NOT
60593: OR
60594: IFFALSE 60598
// exit ;
60596: GO 60662
// for i in mc_bases [ base ] union mc_ape [ base ] do
60598: LD_ADDR_VAR 0 4
60602: PUSH
60603: LD_EXP 58
60607: PUSH
60608: LD_VAR 0 1
60612: ARRAY
60613: PUSH
60614: LD_EXP 87
60618: PUSH
60619: LD_VAR 0 1
60623: ARRAY
60624: UNION
60625: PUSH
60626: FOR_IN
60627: IFFALSE 60660
// if GetTag ( i ) = tag then
60629: LD_VAR 0 4
60633: PPUSH
60634: CALL_OW 110
60638: PUSH
60639: LD_VAR 0 2
60643: EQUAL
60644: IFFALSE 60658
// SetTag ( i , 0 ) ;
60646: LD_VAR 0 4
60650: PPUSH
60651: LD_INT 0
60653: PPUSH
60654: CALL_OW 109
60658: GO 60626
60660: POP
60661: POP
// end ;
60662: LD_VAR 0 3
60666: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
60667: LD_INT 0
60669: PPUSH
60670: PPUSH
60671: PPUSH
60672: PPUSH
60673: PPUSH
60674: PPUSH
60675: PPUSH
60676: PPUSH
// if not mc_bases then
60677: LD_EXP 58
60681: NOT
60682: IFFALSE 60686
// exit ;
60684: GO 61144
// for i = 1 to mc_bases do
60686: LD_ADDR_VAR 0 2
60690: PUSH
60691: DOUBLE
60692: LD_INT 1
60694: DEC
60695: ST_TO_ADDR
60696: LD_EXP 58
60700: PUSH
60701: FOR_TO
60702: IFFALSE 61142
// begin tmp := MC_ClassCheckReq ( i ) ;
60704: LD_ADDR_VAR 0 4
60708: PUSH
60709: LD_VAR 0 2
60713: PPUSH
60714: CALL 61149 0 1
60718: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
60719: LD_ADDR_EXP 99
60723: PUSH
60724: LD_EXP 99
60728: PPUSH
60729: LD_VAR 0 2
60733: PPUSH
60734: LD_VAR 0 4
60738: PPUSH
60739: CALL_OW 1
60743: ST_TO_ADDR
// if not tmp then
60744: LD_VAR 0 4
60748: NOT
60749: IFFALSE 60753
// continue ;
60751: GO 60701
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
60753: LD_ADDR_VAR 0 6
60757: PUSH
60758: LD_EXP 58
60762: PUSH
60763: LD_VAR 0 2
60767: ARRAY
60768: PPUSH
60769: LD_INT 2
60771: PUSH
60772: LD_INT 30
60774: PUSH
60775: LD_INT 4
60777: PUSH
60778: EMPTY
60779: LIST
60780: LIST
60781: PUSH
60782: LD_INT 30
60784: PUSH
60785: LD_INT 5
60787: PUSH
60788: EMPTY
60789: LIST
60790: LIST
60791: PUSH
60792: EMPTY
60793: LIST
60794: LIST
60795: LIST
60796: PPUSH
60797: CALL_OW 72
60801: PUSH
60802: LD_EXP 58
60806: PUSH
60807: LD_VAR 0 2
60811: ARRAY
60812: PPUSH
60813: LD_INT 2
60815: PUSH
60816: LD_INT 30
60818: PUSH
60819: LD_INT 0
60821: PUSH
60822: EMPTY
60823: LIST
60824: LIST
60825: PUSH
60826: LD_INT 30
60828: PUSH
60829: LD_INT 1
60831: PUSH
60832: EMPTY
60833: LIST
60834: LIST
60835: PUSH
60836: EMPTY
60837: LIST
60838: LIST
60839: LIST
60840: PPUSH
60841: CALL_OW 72
60845: PUSH
60846: LD_EXP 58
60850: PUSH
60851: LD_VAR 0 2
60855: ARRAY
60856: PPUSH
60857: LD_INT 30
60859: PUSH
60860: LD_INT 3
60862: PUSH
60863: EMPTY
60864: LIST
60865: LIST
60866: PPUSH
60867: CALL_OW 72
60871: PUSH
60872: LD_EXP 58
60876: PUSH
60877: LD_VAR 0 2
60881: ARRAY
60882: PPUSH
60883: LD_INT 2
60885: PUSH
60886: LD_INT 30
60888: PUSH
60889: LD_INT 6
60891: PUSH
60892: EMPTY
60893: LIST
60894: LIST
60895: PUSH
60896: LD_INT 30
60898: PUSH
60899: LD_INT 7
60901: PUSH
60902: EMPTY
60903: LIST
60904: LIST
60905: PUSH
60906: LD_INT 30
60908: PUSH
60909: LD_INT 8
60911: PUSH
60912: EMPTY
60913: LIST
60914: LIST
60915: PUSH
60916: EMPTY
60917: LIST
60918: LIST
60919: LIST
60920: LIST
60921: PPUSH
60922: CALL_OW 72
60926: PUSH
60927: EMPTY
60928: LIST
60929: LIST
60930: LIST
60931: LIST
60932: ST_TO_ADDR
// for j = 1 to 4 do
60933: LD_ADDR_VAR 0 3
60937: PUSH
60938: DOUBLE
60939: LD_INT 1
60941: DEC
60942: ST_TO_ADDR
60943: LD_INT 4
60945: PUSH
60946: FOR_TO
60947: IFFALSE 61138
// begin if not tmp [ j ] then
60949: LD_VAR 0 4
60953: PUSH
60954: LD_VAR 0 3
60958: ARRAY
60959: NOT
60960: IFFALSE 60964
// continue ;
60962: GO 60946
// for p in tmp [ j ] do
60964: LD_ADDR_VAR 0 5
60968: PUSH
60969: LD_VAR 0 4
60973: PUSH
60974: LD_VAR 0 3
60978: ARRAY
60979: PUSH
60980: FOR_IN
60981: IFFALSE 61134
// begin if not b [ j ] then
60983: LD_VAR 0 6
60987: PUSH
60988: LD_VAR 0 3
60992: ARRAY
60993: NOT
60994: IFFALSE 60998
// break ;
60996: GO 61134
// e := 0 ;
60998: LD_ADDR_VAR 0 7
61002: PUSH
61003: LD_INT 0
61005: ST_TO_ADDR
// for k in b [ j ] do
61006: LD_ADDR_VAR 0 8
61010: PUSH
61011: LD_VAR 0 6
61015: PUSH
61016: LD_VAR 0 3
61020: ARRAY
61021: PUSH
61022: FOR_IN
61023: IFFALSE 61050
// if IsNotFull ( k ) then
61025: LD_VAR 0 8
61029: PPUSH
61030: CALL 17981 0 1
61034: IFFALSE 61048
// begin e := k ;
61036: LD_ADDR_VAR 0 7
61040: PUSH
61041: LD_VAR 0 8
61045: ST_TO_ADDR
// break ;
61046: GO 61050
// end ;
61048: GO 61022
61050: POP
61051: POP
// if e and not UnitGoingToBuilding ( p , e ) then
61052: LD_VAR 0 7
61056: PUSH
61057: LD_VAR 0 5
61061: PPUSH
61062: LD_VAR 0 7
61066: PPUSH
61067: CALL 55039 0 2
61071: NOT
61072: AND
61073: IFFALSE 61132
// begin if IsInUnit ( p ) then
61075: LD_VAR 0 5
61079: PPUSH
61080: CALL_OW 310
61084: IFFALSE 61095
// ComExitBuilding ( p ) ;
61086: LD_VAR 0 5
61090: PPUSH
61091: CALL_OW 122
// ComEnterUnit ( p , e ) ;
61095: LD_VAR 0 5
61099: PPUSH
61100: LD_VAR 0 7
61104: PPUSH
61105: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
61109: LD_VAR 0 5
61113: PPUSH
61114: LD_VAR 0 3
61118: PPUSH
61119: CALL_OW 183
// AddComExitBuilding ( p ) ;
61123: LD_VAR 0 5
61127: PPUSH
61128: CALL_OW 182
// end ; end ;
61132: GO 60980
61134: POP
61135: POP
// end ;
61136: GO 60946
61138: POP
61139: POP
// end ;
61140: GO 60701
61142: POP
61143: POP
// end ;
61144: LD_VAR 0 1
61148: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
61149: LD_INT 0
61151: PPUSH
61152: PPUSH
61153: PPUSH
61154: PPUSH
61155: PPUSH
61156: PPUSH
61157: PPUSH
61158: PPUSH
61159: PPUSH
61160: PPUSH
61161: PPUSH
61162: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61163: LD_VAR 0 1
61167: NOT
61168: PUSH
61169: LD_EXP 58
61173: PUSH
61174: LD_VAR 0 1
61178: ARRAY
61179: NOT
61180: OR
61181: PUSH
61182: LD_EXP 58
61186: PUSH
61187: LD_VAR 0 1
61191: ARRAY
61192: PPUSH
61193: LD_INT 2
61195: PUSH
61196: LD_INT 30
61198: PUSH
61199: LD_INT 0
61201: PUSH
61202: EMPTY
61203: LIST
61204: LIST
61205: PUSH
61206: LD_INT 30
61208: PUSH
61209: LD_INT 1
61211: PUSH
61212: EMPTY
61213: LIST
61214: LIST
61215: PUSH
61216: EMPTY
61217: LIST
61218: LIST
61219: LIST
61220: PPUSH
61221: CALL_OW 72
61225: NOT
61226: OR
61227: IFFALSE 61231
// exit ;
61229: GO 64725
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61231: LD_ADDR_VAR 0 4
61235: PUSH
61236: LD_EXP 58
61240: PUSH
61241: LD_VAR 0 1
61245: ARRAY
61246: PPUSH
61247: LD_INT 2
61249: PUSH
61250: LD_INT 25
61252: PUSH
61253: LD_INT 1
61255: PUSH
61256: EMPTY
61257: LIST
61258: LIST
61259: PUSH
61260: LD_INT 25
61262: PUSH
61263: LD_INT 2
61265: PUSH
61266: EMPTY
61267: LIST
61268: LIST
61269: PUSH
61270: LD_INT 25
61272: PUSH
61273: LD_INT 3
61275: PUSH
61276: EMPTY
61277: LIST
61278: LIST
61279: PUSH
61280: LD_INT 25
61282: PUSH
61283: LD_INT 4
61285: PUSH
61286: EMPTY
61287: LIST
61288: LIST
61289: PUSH
61290: LD_INT 25
61292: PUSH
61293: LD_INT 5
61295: PUSH
61296: EMPTY
61297: LIST
61298: LIST
61299: PUSH
61300: LD_INT 25
61302: PUSH
61303: LD_INT 8
61305: PUSH
61306: EMPTY
61307: LIST
61308: LIST
61309: PUSH
61310: LD_INT 25
61312: PUSH
61313: LD_INT 9
61315: PUSH
61316: EMPTY
61317: LIST
61318: LIST
61319: PUSH
61320: EMPTY
61321: LIST
61322: LIST
61323: LIST
61324: LIST
61325: LIST
61326: LIST
61327: LIST
61328: LIST
61329: PPUSH
61330: CALL_OW 72
61334: ST_TO_ADDR
// for i in tmp do
61335: LD_ADDR_VAR 0 3
61339: PUSH
61340: LD_VAR 0 4
61344: PUSH
61345: FOR_IN
61346: IFFALSE 61377
// if GetTag ( i ) then
61348: LD_VAR 0 3
61352: PPUSH
61353: CALL_OW 110
61357: IFFALSE 61375
// tmp := tmp diff i ;
61359: LD_ADDR_VAR 0 4
61363: PUSH
61364: LD_VAR 0 4
61368: PUSH
61369: LD_VAR 0 3
61373: DIFF
61374: ST_TO_ADDR
61375: GO 61345
61377: POP
61378: POP
// if not tmp then
61379: LD_VAR 0 4
61383: NOT
61384: IFFALSE 61388
// exit ;
61386: GO 64725
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61388: LD_ADDR_VAR 0 5
61392: PUSH
61393: LD_EXP 58
61397: PUSH
61398: LD_VAR 0 1
61402: ARRAY
61403: PPUSH
61404: LD_INT 2
61406: PUSH
61407: LD_INT 25
61409: PUSH
61410: LD_INT 1
61412: PUSH
61413: EMPTY
61414: LIST
61415: LIST
61416: PUSH
61417: LD_INT 25
61419: PUSH
61420: LD_INT 5
61422: PUSH
61423: EMPTY
61424: LIST
61425: LIST
61426: PUSH
61427: LD_INT 25
61429: PUSH
61430: LD_INT 8
61432: PUSH
61433: EMPTY
61434: LIST
61435: LIST
61436: PUSH
61437: LD_INT 25
61439: PUSH
61440: LD_INT 9
61442: PUSH
61443: EMPTY
61444: LIST
61445: LIST
61446: PUSH
61447: EMPTY
61448: LIST
61449: LIST
61450: LIST
61451: LIST
61452: LIST
61453: PPUSH
61454: CALL_OW 72
61458: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
61459: LD_ADDR_VAR 0 6
61463: PUSH
61464: LD_EXP 58
61468: PUSH
61469: LD_VAR 0 1
61473: ARRAY
61474: PPUSH
61475: LD_INT 25
61477: PUSH
61478: LD_INT 2
61480: PUSH
61481: EMPTY
61482: LIST
61483: LIST
61484: PPUSH
61485: CALL_OW 72
61489: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
61490: LD_ADDR_VAR 0 7
61494: PUSH
61495: LD_EXP 58
61499: PUSH
61500: LD_VAR 0 1
61504: ARRAY
61505: PPUSH
61506: LD_INT 25
61508: PUSH
61509: LD_INT 3
61511: PUSH
61512: EMPTY
61513: LIST
61514: LIST
61515: PPUSH
61516: CALL_OW 72
61520: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
61521: LD_ADDR_VAR 0 8
61525: PUSH
61526: LD_EXP 58
61530: PUSH
61531: LD_VAR 0 1
61535: ARRAY
61536: PPUSH
61537: LD_INT 25
61539: PUSH
61540: LD_INT 4
61542: PUSH
61543: EMPTY
61544: LIST
61545: LIST
61546: PUSH
61547: LD_INT 24
61549: PUSH
61550: LD_INT 251
61552: PUSH
61553: EMPTY
61554: LIST
61555: LIST
61556: PUSH
61557: EMPTY
61558: LIST
61559: LIST
61560: PPUSH
61561: CALL_OW 72
61565: ST_TO_ADDR
// if mc_scan [ base ] then
61566: LD_EXP 81
61570: PUSH
61571: LD_VAR 0 1
61575: ARRAY
61576: IFFALSE 62037
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
61578: LD_ADDR_EXP 100
61582: PUSH
61583: LD_EXP 100
61587: PPUSH
61588: LD_VAR 0 1
61592: PPUSH
61593: LD_INT 4
61595: PPUSH
61596: CALL_OW 1
61600: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
61601: LD_ADDR_VAR 0 12
61605: PUSH
61606: LD_EXP 58
61610: PUSH
61611: LD_VAR 0 1
61615: ARRAY
61616: PPUSH
61617: LD_INT 2
61619: PUSH
61620: LD_INT 30
61622: PUSH
61623: LD_INT 4
61625: PUSH
61626: EMPTY
61627: LIST
61628: LIST
61629: PUSH
61630: LD_INT 30
61632: PUSH
61633: LD_INT 5
61635: PUSH
61636: EMPTY
61637: LIST
61638: LIST
61639: PUSH
61640: EMPTY
61641: LIST
61642: LIST
61643: LIST
61644: PPUSH
61645: CALL_OW 72
61649: ST_TO_ADDR
// if not b then
61650: LD_VAR 0 12
61654: NOT
61655: IFFALSE 61659
// exit ;
61657: GO 64725
// p := [ ] ;
61659: LD_ADDR_VAR 0 11
61663: PUSH
61664: EMPTY
61665: ST_TO_ADDR
// if sci >= 2 then
61666: LD_VAR 0 8
61670: PUSH
61671: LD_INT 2
61673: GREATEREQUAL
61674: IFFALSE 61705
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
61676: LD_ADDR_VAR 0 8
61680: PUSH
61681: LD_VAR 0 8
61685: PUSH
61686: LD_INT 1
61688: ARRAY
61689: PUSH
61690: LD_VAR 0 8
61694: PUSH
61695: LD_INT 2
61697: ARRAY
61698: PUSH
61699: EMPTY
61700: LIST
61701: LIST
61702: ST_TO_ADDR
61703: GO 61766
// if sci = 1 then
61705: LD_VAR 0 8
61709: PUSH
61710: LD_INT 1
61712: EQUAL
61713: IFFALSE 61734
// sci := [ sci [ 1 ] ] else
61715: LD_ADDR_VAR 0 8
61719: PUSH
61720: LD_VAR 0 8
61724: PUSH
61725: LD_INT 1
61727: ARRAY
61728: PUSH
61729: EMPTY
61730: LIST
61731: ST_TO_ADDR
61732: GO 61766
// if sci = 0 then
61734: LD_VAR 0 8
61738: PUSH
61739: LD_INT 0
61741: EQUAL
61742: IFFALSE 61766
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
61744: LD_ADDR_VAR 0 11
61748: PUSH
61749: LD_VAR 0 4
61753: PPUSH
61754: LD_INT 4
61756: PPUSH
61757: CALL 54902 0 2
61761: PUSH
61762: LD_INT 1
61764: ARRAY
61765: ST_TO_ADDR
// if eng > 4 then
61766: LD_VAR 0 6
61770: PUSH
61771: LD_INT 4
61773: GREATER
61774: IFFALSE 61820
// for i = eng downto 4 do
61776: LD_ADDR_VAR 0 3
61780: PUSH
61781: DOUBLE
61782: LD_VAR 0 6
61786: INC
61787: ST_TO_ADDR
61788: LD_INT 4
61790: PUSH
61791: FOR_DOWNTO
61792: IFFALSE 61818
// eng := eng diff eng [ i ] ;
61794: LD_ADDR_VAR 0 6
61798: PUSH
61799: LD_VAR 0 6
61803: PUSH
61804: LD_VAR 0 6
61808: PUSH
61809: LD_VAR 0 3
61813: ARRAY
61814: DIFF
61815: ST_TO_ADDR
61816: GO 61791
61818: POP
61819: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
61820: LD_ADDR_VAR 0 4
61824: PUSH
61825: LD_VAR 0 4
61829: PUSH
61830: LD_VAR 0 5
61834: PUSH
61835: LD_VAR 0 6
61839: UNION
61840: PUSH
61841: LD_VAR 0 7
61845: UNION
61846: PUSH
61847: LD_VAR 0 8
61851: UNION
61852: DIFF
61853: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
61854: LD_ADDR_VAR 0 13
61858: PUSH
61859: LD_EXP 58
61863: PUSH
61864: LD_VAR 0 1
61868: ARRAY
61869: PPUSH
61870: LD_INT 2
61872: PUSH
61873: LD_INT 30
61875: PUSH
61876: LD_INT 32
61878: PUSH
61879: EMPTY
61880: LIST
61881: LIST
61882: PUSH
61883: LD_INT 30
61885: PUSH
61886: LD_INT 31
61888: PUSH
61889: EMPTY
61890: LIST
61891: LIST
61892: PUSH
61893: EMPTY
61894: LIST
61895: LIST
61896: LIST
61897: PPUSH
61898: CALL_OW 72
61902: PUSH
61903: LD_EXP 58
61907: PUSH
61908: LD_VAR 0 1
61912: ARRAY
61913: PPUSH
61914: LD_INT 2
61916: PUSH
61917: LD_INT 30
61919: PUSH
61920: LD_INT 4
61922: PUSH
61923: EMPTY
61924: LIST
61925: LIST
61926: PUSH
61927: LD_INT 30
61929: PUSH
61930: LD_INT 5
61932: PUSH
61933: EMPTY
61934: LIST
61935: LIST
61936: PUSH
61937: EMPTY
61938: LIST
61939: LIST
61940: LIST
61941: PPUSH
61942: CALL_OW 72
61946: PUSH
61947: LD_INT 6
61949: MUL
61950: PLUS
61951: ST_TO_ADDR
// if bcount < tmp then
61952: LD_VAR 0 13
61956: PUSH
61957: LD_VAR 0 4
61961: LESS
61962: IFFALSE 62008
// for i = tmp downto bcount do
61964: LD_ADDR_VAR 0 3
61968: PUSH
61969: DOUBLE
61970: LD_VAR 0 4
61974: INC
61975: ST_TO_ADDR
61976: LD_VAR 0 13
61980: PUSH
61981: FOR_DOWNTO
61982: IFFALSE 62006
// tmp := Delete ( tmp , tmp ) ;
61984: LD_ADDR_VAR 0 4
61988: PUSH
61989: LD_VAR 0 4
61993: PPUSH
61994: LD_VAR 0 4
61998: PPUSH
61999: CALL_OW 3
62003: ST_TO_ADDR
62004: GO 61981
62006: POP
62007: POP
// result := [ tmp , 0 , 0 , p ] ;
62008: LD_ADDR_VAR 0 2
62012: PUSH
62013: LD_VAR 0 4
62017: PUSH
62018: LD_INT 0
62020: PUSH
62021: LD_INT 0
62023: PUSH
62024: LD_VAR 0 11
62028: PUSH
62029: EMPTY
62030: LIST
62031: LIST
62032: LIST
62033: LIST
62034: ST_TO_ADDR
// exit ;
62035: GO 64725
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62037: LD_EXP 58
62041: PUSH
62042: LD_VAR 0 1
62046: ARRAY
62047: PPUSH
62048: LD_INT 2
62050: PUSH
62051: LD_INT 30
62053: PUSH
62054: LD_INT 6
62056: PUSH
62057: EMPTY
62058: LIST
62059: LIST
62060: PUSH
62061: LD_INT 30
62063: PUSH
62064: LD_INT 7
62066: PUSH
62067: EMPTY
62068: LIST
62069: LIST
62070: PUSH
62071: LD_INT 30
62073: PUSH
62074: LD_INT 8
62076: PUSH
62077: EMPTY
62078: LIST
62079: LIST
62080: PUSH
62081: EMPTY
62082: LIST
62083: LIST
62084: LIST
62085: LIST
62086: PPUSH
62087: CALL_OW 72
62091: NOT
62092: PUSH
62093: LD_EXP 58
62097: PUSH
62098: LD_VAR 0 1
62102: ARRAY
62103: PPUSH
62104: LD_INT 30
62106: PUSH
62107: LD_INT 3
62109: PUSH
62110: EMPTY
62111: LIST
62112: LIST
62113: PPUSH
62114: CALL_OW 72
62118: NOT
62119: AND
62120: IFFALSE 62192
// begin if eng = tmp then
62122: LD_VAR 0 6
62126: PUSH
62127: LD_VAR 0 4
62131: EQUAL
62132: IFFALSE 62136
// exit ;
62134: GO 64725
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
62136: LD_ADDR_EXP 100
62140: PUSH
62141: LD_EXP 100
62145: PPUSH
62146: LD_VAR 0 1
62150: PPUSH
62151: LD_INT 1
62153: PPUSH
62154: CALL_OW 1
62158: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
62159: LD_ADDR_VAR 0 2
62163: PUSH
62164: LD_INT 0
62166: PUSH
62167: LD_VAR 0 4
62171: PUSH
62172: LD_VAR 0 6
62176: DIFF
62177: PUSH
62178: LD_INT 0
62180: PUSH
62181: LD_INT 0
62183: PUSH
62184: EMPTY
62185: LIST
62186: LIST
62187: LIST
62188: LIST
62189: ST_TO_ADDR
// exit ;
62190: GO 64725
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62192: LD_EXP 85
62196: PUSH
62197: LD_EXP 84
62201: PUSH
62202: LD_VAR 0 1
62206: ARRAY
62207: ARRAY
62208: PUSH
62209: LD_EXP 58
62213: PUSH
62214: LD_VAR 0 1
62218: ARRAY
62219: PPUSH
62220: LD_INT 2
62222: PUSH
62223: LD_INT 30
62225: PUSH
62226: LD_INT 6
62228: PUSH
62229: EMPTY
62230: LIST
62231: LIST
62232: PUSH
62233: LD_INT 30
62235: PUSH
62236: LD_INT 7
62238: PUSH
62239: EMPTY
62240: LIST
62241: LIST
62242: PUSH
62243: LD_INT 30
62245: PUSH
62246: LD_INT 8
62248: PUSH
62249: EMPTY
62250: LIST
62251: LIST
62252: PUSH
62253: EMPTY
62254: LIST
62255: LIST
62256: LIST
62257: LIST
62258: PPUSH
62259: CALL_OW 72
62263: AND
62264: PUSH
62265: LD_EXP 58
62269: PUSH
62270: LD_VAR 0 1
62274: ARRAY
62275: PPUSH
62276: LD_INT 30
62278: PUSH
62279: LD_INT 3
62281: PUSH
62282: EMPTY
62283: LIST
62284: LIST
62285: PPUSH
62286: CALL_OW 72
62290: NOT
62291: AND
62292: IFFALSE 62506
// begin if sci >= 6 then
62294: LD_VAR 0 8
62298: PUSH
62299: LD_INT 6
62301: GREATEREQUAL
62302: IFFALSE 62306
// exit ;
62304: GO 64725
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
62306: LD_ADDR_EXP 100
62310: PUSH
62311: LD_EXP 100
62315: PPUSH
62316: LD_VAR 0 1
62320: PPUSH
62321: LD_INT 2
62323: PPUSH
62324: CALL_OW 1
62328: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
62329: LD_ADDR_VAR 0 9
62333: PUSH
62334: LD_VAR 0 4
62338: PUSH
62339: LD_VAR 0 8
62343: DIFF
62344: PPUSH
62345: LD_INT 4
62347: PPUSH
62348: CALL 54902 0 2
62352: ST_TO_ADDR
// p := [ ] ;
62353: LD_ADDR_VAR 0 11
62357: PUSH
62358: EMPTY
62359: ST_TO_ADDR
// if sci < 6 and sort > 6 then
62360: LD_VAR 0 8
62364: PUSH
62365: LD_INT 6
62367: LESS
62368: PUSH
62369: LD_VAR 0 9
62373: PUSH
62374: LD_INT 6
62376: GREATER
62377: AND
62378: IFFALSE 62459
// begin for i = 1 to 6 - sci do
62380: LD_ADDR_VAR 0 3
62384: PUSH
62385: DOUBLE
62386: LD_INT 1
62388: DEC
62389: ST_TO_ADDR
62390: LD_INT 6
62392: PUSH
62393: LD_VAR 0 8
62397: MINUS
62398: PUSH
62399: FOR_TO
62400: IFFALSE 62455
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
62402: LD_ADDR_VAR 0 11
62406: PUSH
62407: LD_VAR 0 11
62411: PPUSH
62412: LD_VAR 0 11
62416: PUSH
62417: LD_INT 1
62419: PLUS
62420: PPUSH
62421: LD_VAR 0 9
62425: PUSH
62426: LD_INT 1
62428: ARRAY
62429: PPUSH
62430: CALL_OW 2
62434: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
62435: LD_ADDR_VAR 0 9
62439: PUSH
62440: LD_VAR 0 9
62444: PPUSH
62445: LD_INT 1
62447: PPUSH
62448: CALL_OW 3
62452: ST_TO_ADDR
// end ;
62453: GO 62399
62455: POP
62456: POP
// end else
62457: GO 62479
// if sort then
62459: LD_VAR 0 9
62463: IFFALSE 62479
// p := sort [ 1 ] ;
62465: LD_ADDR_VAR 0 11
62469: PUSH
62470: LD_VAR 0 9
62474: PUSH
62475: LD_INT 1
62477: ARRAY
62478: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
62479: LD_ADDR_VAR 0 2
62483: PUSH
62484: LD_INT 0
62486: PUSH
62487: LD_INT 0
62489: PUSH
62490: LD_INT 0
62492: PUSH
62493: LD_VAR 0 11
62497: PUSH
62498: EMPTY
62499: LIST
62500: LIST
62501: LIST
62502: LIST
62503: ST_TO_ADDR
// exit ;
62504: GO 64725
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62506: LD_EXP 85
62510: PUSH
62511: LD_EXP 84
62515: PUSH
62516: LD_VAR 0 1
62520: ARRAY
62521: ARRAY
62522: PUSH
62523: LD_EXP 58
62527: PUSH
62528: LD_VAR 0 1
62532: ARRAY
62533: PPUSH
62534: LD_INT 2
62536: PUSH
62537: LD_INT 30
62539: PUSH
62540: LD_INT 6
62542: PUSH
62543: EMPTY
62544: LIST
62545: LIST
62546: PUSH
62547: LD_INT 30
62549: PUSH
62550: LD_INT 7
62552: PUSH
62553: EMPTY
62554: LIST
62555: LIST
62556: PUSH
62557: LD_INT 30
62559: PUSH
62560: LD_INT 8
62562: PUSH
62563: EMPTY
62564: LIST
62565: LIST
62566: PUSH
62567: EMPTY
62568: LIST
62569: LIST
62570: LIST
62571: LIST
62572: PPUSH
62573: CALL_OW 72
62577: AND
62578: PUSH
62579: LD_EXP 58
62583: PUSH
62584: LD_VAR 0 1
62588: ARRAY
62589: PPUSH
62590: LD_INT 30
62592: PUSH
62593: LD_INT 3
62595: PUSH
62596: EMPTY
62597: LIST
62598: LIST
62599: PPUSH
62600: CALL_OW 72
62604: AND
62605: IFFALSE 63339
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
62607: LD_ADDR_EXP 100
62611: PUSH
62612: LD_EXP 100
62616: PPUSH
62617: LD_VAR 0 1
62621: PPUSH
62622: LD_INT 3
62624: PPUSH
62625: CALL_OW 1
62629: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62630: LD_ADDR_VAR 0 2
62634: PUSH
62635: LD_INT 0
62637: PUSH
62638: LD_INT 0
62640: PUSH
62641: LD_INT 0
62643: PUSH
62644: LD_INT 0
62646: PUSH
62647: EMPTY
62648: LIST
62649: LIST
62650: LIST
62651: LIST
62652: ST_TO_ADDR
// if not eng then
62653: LD_VAR 0 6
62657: NOT
62658: IFFALSE 62721
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
62660: LD_ADDR_VAR 0 11
62664: PUSH
62665: LD_VAR 0 4
62669: PPUSH
62670: LD_INT 2
62672: PPUSH
62673: CALL 54902 0 2
62677: PUSH
62678: LD_INT 1
62680: ARRAY
62681: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
62682: LD_ADDR_VAR 0 2
62686: PUSH
62687: LD_VAR 0 2
62691: PPUSH
62692: LD_INT 2
62694: PPUSH
62695: LD_VAR 0 11
62699: PPUSH
62700: CALL_OW 1
62704: ST_TO_ADDR
// tmp := tmp diff p ;
62705: LD_ADDR_VAR 0 4
62709: PUSH
62710: LD_VAR 0 4
62714: PUSH
62715: LD_VAR 0 11
62719: DIFF
62720: ST_TO_ADDR
// end ; if tmp and sci < 6 then
62721: LD_VAR 0 4
62725: PUSH
62726: LD_VAR 0 8
62730: PUSH
62731: LD_INT 6
62733: LESS
62734: AND
62735: IFFALSE 62923
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
62737: LD_ADDR_VAR 0 9
62741: PUSH
62742: LD_VAR 0 4
62746: PUSH
62747: LD_VAR 0 8
62751: PUSH
62752: LD_VAR 0 7
62756: UNION
62757: DIFF
62758: PPUSH
62759: LD_INT 4
62761: PPUSH
62762: CALL 54902 0 2
62766: ST_TO_ADDR
// p := [ ] ;
62767: LD_ADDR_VAR 0 11
62771: PUSH
62772: EMPTY
62773: ST_TO_ADDR
// if sort then
62774: LD_VAR 0 9
62778: IFFALSE 62894
// for i = 1 to 6 - sci do
62780: LD_ADDR_VAR 0 3
62784: PUSH
62785: DOUBLE
62786: LD_INT 1
62788: DEC
62789: ST_TO_ADDR
62790: LD_INT 6
62792: PUSH
62793: LD_VAR 0 8
62797: MINUS
62798: PUSH
62799: FOR_TO
62800: IFFALSE 62892
// begin if i = sort then
62802: LD_VAR 0 3
62806: PUSH
62807: LD_VAR 0 9
62811: EQUAL
62812: IFFALSE 62816
// break ;
62814: GO 62892
// if GetClass ( i ) = 4 then
62816: LD_VAR 0 3
62820: PPUSH
62821: CALL_OW 257
62825: PUSH
62826: LD_INT 4
62828: EQUAL
62829: IFFALSE 62833
// continue ;
62831: GO 62799
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62833: LD_ADDR_VAR 0 11
62837: PUSH
62838: LD_VAR 0 11
62842: PPUSH
62843: LD_VAR 0 11
62847: PUSH
62848: LD_INT 1
62850: PLUS
62851: PPUSH
62852: LD_VAR 0 9
62856: PUSH
62857: LD_VAR 0 3
62861: ARRAY
62862: PPUSH
62863: CALL_OW 2
62867: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62868: LD_ADDR_VAR 0 4
62872: PUSH
62873: LD_VAR 0 4
62877: PUSH
62878: LD_VAR 0 9
62882: PUSH
62883: LD_VAR 0 3
62887: ARRAY
62888: DIFF
62889: ST_TO_ADDR
// end ;
62890: GO 62799
62892: POP
62893: POP
// if p then
62894: LD_VAR 0 11
62898: IFFALSE 62923
// result := Replace ( result , 4 , p ) ;
62900: LD_ADDR_VAR 0 2
62904: PUSH
62905: LD_VAR 0 2
62909: PPUSH
62910: LD_INT 4
62912: PPUSH
62913: LD_VAR 0 11
62917: PPUSH
62918: CALL_OW 1
62922: ST_TO_ADDR
// end ; if tmp and mech < 6 then
62923: LD_VAR 0 4
62927: PUSH
62928: LD_VAR 0 7
62932: PUSH
62933: LD_INT 6
62935: LESS
62936: AND
62937: IFFALSE 63125
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62939: LD_ADDR_VAR 0 9
62943: PUSH
62944: LD_VAR 0 4
62948: PUSH
62949: LD_VAR 0 8
62953: PUSH
62954: LD_VAR 0 7
62958: UNION
62959: DIFF
62960: PPUSH
62961: LD_INT 3
62963: PPUSH
62964: CALL 54902 0 2
62968: ST_TO_ADDR
// p := [ ] ;
62969: LD_ADDR_VAR 0 11
62973: PUSH
62974: EMPTY
62975: ST_TO_ADDR
// if sort then
62976: LD_VAR 0 9
62980: IFFALSE 63096
// for i = 1 to 6 - mech do
62982: LD_ADDR_VAR 0 3
62986: PUSH
62987: DOUBLE
62988: LD_INT 1
62990: DEC
62991: ST_TO_ADDR
62992: LD_INT 6
62994: PUSH
62995: LD_VAR 0 7
62999: MINUS
63000: PUSH
63001: FOR_TO
63002: IFFALSE 63094
// begin if i = sort then
63004: LD_VAR 0 3
63008: PUSH
63009: LD_VAR 0 9
63013: EQUAL
63014: IFFALSE 63018
// break ;
63016: GO 63094
// if GetClass ( i ) = 3 then
63018: LD_VAR 0 3
63022: PPUSH
63023: CALL_OW 257
63027: PUSH
63028: LD_INT 3
63030: EQUAL
63031: IFFALSE 63035
// continue ;
63033: GO 63001
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63035: LD_ADDR_VAR 0 11
63039: PUSH
63040: LD_VAR 0 11
63044: PPUSH
63045: LD_VAR 0 11
63049: PUSH
63050: LD_INT 1
63052: PLUS
63053: PPUSH
63054: LD_VAR 0 9
63058: PUSH
63059: LD_VAR 0 3
63063: ARRAY
63064: PPUSH
63065: CALL_OW 2
63069: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63070: LD_ADDR_VAR 0 4
63074: PUSH
63075: LD_VAR 0 4
63079: PUSH
63080: LD_VAR 0 9
63084: PUSH
63085: LD_VAR 0 3
63089: ARRAY
63090: DIFF
63091: ST_TO_ADDR
// end ;
63092: GO 63001
63094: POP
63095: POP
// if p then
63096: LD_VAR 0 11
63100: IFFALSE 63125
// result := Replace ( result , 3 , p ) ;
63102: LD_ADDR_VAR 0 2
63106: PUSH
63107: LD_VAR 0 2
63111: PPUSH
63112: LD_INT 3
63114: PPUSH
63115: LD_VAR 0 11
63119: PPUSH
63120: CALL_OW 1
63124: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
63125: LD_VAR 0 4
63129: PUSH
63130: LD_INT 6
63132: GREATER
63133: PUSH
63134: LD_VAR 0 6
63138: PUSH
63139: LD_INT 6
63141: LESS
63142: AND
63143: IFFALSE 63337
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63145: LD_ADDR_VAR 0 9
63149: PUSH
63150: LD_VAR 0 4
63154: PUSH
63155: LD_VAR 0 8
63159: PUSH
63160: LD_VAR 0 7
63164: UNION
63165: PUSH
63166: LD_VAR 0 6
63170: UNION
63171: DIFF
63172: PPUSH
63173: LD_INT 2
63175: PPUSH
63176: CALL 54902 0 2
63180: ST_TO_ADDR
// p := [ ] ;
63181: LD_ADDR_VAR 0 11
63185: PUSH
63186: EMPTY
63187: ST_TO_ADDR
// if sort then
63188: LD_VAR 0 9
63192: IFFALSE 63308
// for i = 1 to 6 - eng do
63194: LD_ADDR_VAR 0 3
63198: PUSH
63199: DOUBLE
63200: LD_INT 1
63202: DEC
63203: ST_TO_ADDR
63204: LD_INT 6
63206: PUSH
63207: LD_VAR 0 6
63211: MINUS
63212: PUSH
63213: FOR_TO
63214: IFFALSE 63306
// begin if i = sort then
63216: LD_VAR 0 3
63220: PUSH
63221: LD_VAR 0 9
63225: EQUAL
63226: IFFALSE 63230
// break ;
63228: GO 63306
// if GetClass ( i ) = 2 then
63230: LD_VAR 0 3
63234: PPUSH
63235: CALL_OW 257
63239: PUSH
63240: LD_INT 2
63242: EQUAL
63243: IFFALSE 63247
// continue ;
63245: GO 63213
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63247: LD_ADDR_VAR 0 11
63251: PUSH
63252: LD_VAR 0 11
63256: PPUSH
63257: LD_VAR 0 11
63261: PUSH
63262: LD_INT 1
63264: PLUS
63265: PPUSH
63266: LD_VAR 0 9
63270: PUSH
63271: LD_VAR 0 3
63275: ARRAY
63276: PPUSH
63277: CALL_OW 2
63281: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63282: LD_ADDR_VAR 0 4
63286: PUSH
63287: LD_VAR 0 4
63291: PUSH
63292: LD_VAR 0 9
63296: PUSH
63297: LD_VAR 0 3
63301: ARRAY
63302: DIFF
63303: ST_TO_ADDR
// end ;
63304: GO 63213
63306: POP
63307: POP
// if p then
63308: LD_VAR 0 11
63312: IFFALSE 63337
// result := Replace ( result , 2 , p ) ;
63314: LD_ADDR_VAR 0 2
63318: PUSH
63319: LD_VAR 0 2
63323: PPUSH
63324: LD_INT 2
63326: PPUSH
63327: LD_VAR 0 11
63331: PPUSH
63332: CALL_OW 1
63336: ST_TO_ADDR
// end ; exit ;
63337: GO 64725
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
63339: LD_EXP 85
63343: PUSH
63344: LD_EXP 84
63348: PUSH
63349: LD_VAR 0 1
63353: ARRAY
63354: ARRAY
63355: NOT
63356: PUSH
63357: LD_EXP 58
63361: PUSH
63362: LD_VAR 0 1
63366: ARRAY
63367: PPUSH
63368: LD_INT 30
63370: PUSH
63371: LD_INT 3
63373: PUSH
63374: EMPTY
63375: LIST
63376: LIST
63377: PPUSH
63378: CALL_OW 72
63382: AND
63383: PUSH
63384: LD_EXP 63
63388: PUSH
63389: LD_VAR 0 1
63393: ARRAY
63394: AND
63395: IFFALSE 64003
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
63397: LD_ADDR_EXP 100
63401: PUSH
63402: LD_EXP 100
63406: PPUSH
63407: LD_VAR 0 1
63411: PPUSH
63412: LD_INT 5
63414: PPUSH
63415: CALL_OW 1
63419: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63420: LD_ADDR_VAR 0 2
63424: PUSH
63425: LD_INT 0
63427: PUSH
63428: LD_INT 0
63430: PUSH
63431: LD_INT 0
63433: PUSH
63434: LD_INT 0
63436: PUSH
63437: EMPTY
63438: LIST
63439: LIST
63440: LIST
63441: LIST
63442: ST_TO_ADDR
// if sci > 1 then
63443: LD_VAR 0 8
63447: PUSH
63448: LD_INT 1
63450: GREATER
63451: IFFALSE 63479
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
63453: LD_ADDR_VAR 0 4
63457: PUSH
63458: LD_VAR 0 4
63462: PUSH
63463: LD_VAR 0 8
63467: PUSH
63468: LD_VAR 0 8
63472: PUSH
63473: LD_INT 1
63475: ARRAY
63476: DIFF
63477: DIFF
63478: ST_TO_ADDR
// if tmp and not sci then
63479: LD_VAR 0 4
63483: PUSH
63484: LD_VAR 0 8
63488: NOT
63489: AND
63490: IFFALSE 63559
// begin sort := SortBySkill ( tmp , 4 ) ;
63492: LD_ADDR_VAR 0 9
63496: PUSH
63497: LD_VAR 0 4
63501: PPUSH
63502: LD_INT 4
63504: PPUSH
63505: CALL 54902 0 2
63509: ST_TO_ADDR
// if sort then
63510: LD_VAR 0 9
63514: IFFALSE 63530
// p := sort [ 1 ] ;
63516: LD_ADDR_VAR 0 11
63520: PUSH
63521: LD_VAR 0 9
63525: PUSH
63526: LD_INT 1
63528: ARRAY
63529: ST_TO_ADDR
// if p then
63530: LD_VAR 0 11
63534: IFFALSE 63559
// result := Replace ( result , 4 , p ) ;
63536: LD_ADDR_VAR 0 2
63540: PUSH
63541: LD_VAR 0 2
63545: PPUSH
63546: LD_INT 4
63548: PPUSH
63549: LD_VAR 0 11
63553: PPUSH
63554: CALL_OW 1
63558: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
63559: LD_ADDR_VAR 0 4
63563: PUSH
63564: LD_VAR 0 4
63568: PUSH
63569: LD_VAR 0 7
63573: DIFF
63574: ST_TO_ADDR
// if tmp and mech < 6 then
63575: LD_VAR 0 4
63579: PUSH
63580: LD_VAR 0 7
63584: PUSH
63585: LD_INT 6
63587: LESS
63588: AND
63589: IFFALSE 63777
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63591: LD_ADDR_VAR 0 9
63595: PUSH
63596: LD_VAR 0 4
63600: PUSH
63601: LD_VAR 0 8
63605: PUSH
63606: LD_VAR 0 7
63610: UNION
63611: DIFF
63612: PPUSH
63613: LD_INT 3
63615: PPUSH
63616: CALL 54902 0 2
63620: ST_TO_ADDR
// p := [ ] ;
63621: LD_ADDR_VAR 0 11
63625: PUSH
63626: EMPTY
63627: ST_TO_ADDR
// if sort then
63628: LD_VAR 0 9
63632: IFFALSE 63748
// for i = 1 to 6 - mech do
63634: LD_ADDR_VAR 0 3
63638: PUSH
63639: DOUBLE
63640: LD_INT 1
63642: DEC
63643: ST_TO_ADDR
63644: LD_INT 6
63646: PUSH
63647: LD_VAR 0 7
63651: MINUS
63652: PUSH
63653: FOR_TO
63654: IFFALSE 63746
// begin if i = sort then
63656: LD_VAR 0 3
63660: PUSH
63661: LD_VAR 0 9
63665: EQUAL
63666: IFFALSE 63670
// break ;
63668: GO 63746
// if GetClass ( i ) = 3 then
63670: LD_VAR 0 3
63674: PPUSH
63675: CALL_OW 257
63679: PUSH
63680: LD_INT 3
63682: EQUAL
63683: IFFALSE 63687
// continue ;
63685: GO 63653
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63687: LD_ADDR_VAR 0 11
63691: PUSH
63692: LD_VAR 0 11
63696: PPUSH
63697: LD_VAR 0 11
63701: PUSH
63702: LD_INT 1
63704: PLUS
63705: PPUSH
63706: LD_VAR 0 9
63710: PUSH
63711: LD_VAR 0 3
63715: ARRAY
63716: PPUSH
63717: CALL_OW 2
63721: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63722: LD_ADDR_VAR 0 4
63726: PUSH
63727: LD_VAR 0 4
63731: PUSH
63732: LD_VAR 0 9
63736: PUSH
63737: LD_VAR 0 3
63741: ARRAY
63742: DIFF
63743: ST_TO_ADDR
// end ;
63744: GO 63653
63746: POP
63747: POP
// if p then
63748: LD_VAR 0 11
63752: IFFALSE 63777
// result := Replace ( result , 3 , p ) ;
63754: LD_ADDR_VAR 0 2
63758: PUSH
63759: LD_VAR 0 2
63763: PPUSH
63764: LD_INT 3
63766: PPUSH
63767: LD_VAR 0 11
63771: PPUSH
63772: CALL_OW 1
63776: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
63777: LD_ADDR_VAR 0 4
63781: PUSH
63782: LD_VAR 0 4
63786: PUSH
63787: LD_VAR 0 6
63791: DIFF
63792: ST_TO_ADDR
// if tmp and eng < 6 then
63793: LD_VAR 0 4
63797: PUSH
63798: LD_VAR 0 6
63802: PUSH
63803: LD_INT 6
63805: LESS
63806: AND
63807: IFFALSE 64001
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63809: LD_ADDR_VAR 0 9
63813: PUSH
63814: LD_VAR 0 4
63818: PUSH
63819: LD_VAR 0 8
63823: PUSH
63824: LD_VAR 0 7
63828: UNION
63829: PUSH
63830: LD_VAR 0 6
63834: UNION
63835: DIFF
63836: PPUSH
63837: LD_INT 2
63839: PPUSH
63840: CALL 54902 0 2
63844: ST_TO_ADDR
// p := [ ] ;
63845: LD_ADDR_VAR 0 11
63849: PUSH
63850: EMPTY
63851: ST_TO_ADDR
// if sort then
63852: LD_VAR 0 9
63856: IFFALSE 63972
// for i = 1 to 6 - eng do
63858: LD_ADDR_VAR 0 3
63862: PUSH
63863: DOUBLE
63864: LD_INT 1
63866: DEC
63867: ST_TO_ADDR
63868: LD_INT 6
63870: PUSH
63871: LD_VAR 0 6
63875: MINUS
63876: PUSH
63877: FOR_TO
63878: IFFALSE 63970
// begin if i = sort then
63880: LD_VAR 0 3
63884: PUSH
63885: LD_VAR 0 9
63889: EQUAL
63890: IFFALSE 63894
// break ;
63892: GO 63970
// if GetClass ( i ) = 2 then
63894: LD_VAR 0 3
63898: PPUSH
63899: CALL_OW 257
63903: PUSH
63904: LD_INT 2
63906: EQUAL
63907: IFFALSE 63911
// continue ;
63909: GO 63877
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63911: LD_ADDR_VAR 0 11
63915: PUSH
63916: LD_VAR 0 11
63920: PPUSH
63921: LD_VAR 0 11
63925: PUSH
63926: LD_INT 1
63928: PLUS
63929: PPUSH
63930: LD_VAR 0 9
63934: PUSH
63935: LD_VAR 0 3
63939: ARRAY
63940: PPUSH
63941: CALL_OW 2
63945: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63946: LD_ADDR_VAR 0 4
63950: PUSH
63951: LD_VAR 0 4
63955: PUSH
63956: LD_VAR 0 9
63960: PUSH
63961: LD_VAR 0 3
63965: ARRAY
63966: DIFF
63967: ST_TO_ADDR
// end ;
63968: GO 63877
63970: POP
63971: POP
// if p then
63972: LD_VAR 0 11
63976: IFFALSE 64001
// result := Replace ( result , 2 , p ) ;
63978: LD_ADDR_VAR 0 2
63982: PUSH
63983: LD_VAR 0 2
63987: PPUSH
63988: LD_INT 2
63990: PPUSH
63991: LD_VAR 0 11
63995: PPUSH
63996: CALL_OW 1
64000: ST_TO_ADDR
// end ; exit ;
64001: GO 64725
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
64003: LD_EXP 85
64007: PUSH
64008: LD_EXP 84
64012: PUSH
64013: LD_VAR 0 1
64017: ARRAY
64018: ARRAY
64019: NOT
64020: PUSH
64021: LD_EXP 58
64025: PUSH
64026: LD_VAR 0 1
64030: ARRAY
64031: PPUSH
64032: LD_INT 30
64034: PUSH
64035: LD_INT 3
64037: PUSH
64038: EMPTY
64039: LIST
64040: LIST
64041: PPUSH
64042: CALL_OW 72
64046: AND
64047: PUSH
64048: LD_EXP 63
64052: PUSH
64053: LD_VAR 0 1
64057: ARRAY
64058: NOT
64059: AND
64060: IFFALSE 64725
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
64062: LD_ADDR_EXP 100
64066: PUSH
64067: LD_EXP 100
64071: PPUSH
64072: LD_VAR 0 1
64076: PPUSH
64077: LD_INT 6
64079: PPUSH
64080: CALL_OW 1
64084: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64085: LD_ADDR_VAR 0 2
64089: PUSH
64090: LD_INT 0
64092: PUSH
64093: LD_INT 0
64095: PUSH
64096: LD_INT 0
64098: PUSH
64099: LD_INT 0
64101: PUSH
64102: EMPTY
64103: LIST
64104: LIST
64105: LIST
64106: LIST
64107: ST_TO_ADDR
// if sci >= 1 then
64108: LD_VAR 0 8
64112: PUSH
64113: LD_INT 1
64115: GREATEREQUAL
64116: IFFALSE 64138
// tmp := tmp diff sci [ 1 ] ;
64118: LD_ADDR_VAR 0 4
64122: PUSH
64123: LD_VAR 0 4
64127: PUSH
64128: LD_VAR 0 8
64132: PUSH
64133: LD_INT 1
64135: ARRAY
64136: DIFF
64137: ST_TO_ADDR
// if tmp and not sci then
64138: LD_VAR 0 4
64142: PUSH
64143: LD_VAR 0 8
64147: NOT
64148: AND
64149: IFFALSE 64218
// begin sort := SortBySkill ( tmp , 4 ) ;
64151: LD_ADDR_VAR 0 9
64155: PUSH
64156: LD_VAR 0 4
64160: PPUSH
64161: LD_INT 4
64163: PPUSH
64164: CALL 54902 0 2
64168: ST_TO_ADDR
// if sort then
64169: LD_VAR 0 9
64173: IFFALSE 64189
// p := sort [ 1 ] ;
64175: LD_ADDR_VAR 0 11
64179: PUSH
64180: LD_VAR 0 9
64184: PUSH
64185: LD_INT 1
64187: ARRAY
64188: ST_TO_ADDR
// if p then
64189: LD_VAR 0 11
64193: IFFALSE 64218
// result := Replace ( result , 4 , p ) ;
64195: LD_ADDR_VAR 0 2
64199: PUSH
64200: LD_VAR 0 2
64204: PPUSH
64205: LD_INT 4
64207: PPUSH
64208: LD_VAR 0 11
64212: PPUSH
64213: CALL_OW 1
64217: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64218: LD_ADDR_VAR 0 4
64222: PUSH
64223: LD_VAR 0 4
64227: PUSH
64228: LD_VAR 0 7
64232: DIFF
64233: ST_TO_ADDR
// if tmp and mech < 6 then
64234: LD_VAR 0 4
64238: PUSH
64239: LD_VAR 0 7
64243: PUSH
64244: LD_INT 6
64246: LESS
64247: AND
64248: IFFALSE 64430
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
64250: LD_ADDR_VAR 0 9
64254: PUSH
64255: LD_VAR 0 4
64259: PUSH
64260: LD_VAR 0 7
64264: DIFF
64265: PPUSH
64266: LD_INT 3
64268: PPUSH
64269: CALL 54902 0 2
64273: ST_TO_ADDR
// p := [ ] ;
64274: LD_ADDR_VAR 0 11
64278: PUSH
64279: EMPTY
64280: ST_TO_ADDR
// if sort then
64281: LD_VAR 0 9
64285: IFFALSE 64401
// for i = 1 to 6 - mech do
64287: LD_ADDR_VAR 0 3
64291: PUSH
64292: DOUBLE
64293: LD_INT 1
64295: DEC
64296: ST_TO_ADDR
64297: LD_INT 6
64299: PUSH
64300: LD_VAR 0 7
64304: MINUS
64305: PUSH
64306: FOR_TO
64307: IFFALSE 64399
// begin if i = sort then
64309: LD_VAR 0 3
64313: PUSH
64314: LD_VAR 0 9
64318: EQUAL
64319: IFFALSE 64323
// break ;
64321: GO 64399
// if GetClass ( i ) = 3 then
64323: LD_VAR 0 3
64327: PPUSH
64328: CALL_OW 257
64332: PUSH
64333: LD_INT 3
64335: EQUAL
64336: IFFALSE 64340
// continue ;
64338: GO 64306
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64340: LD_ADDR_VAR 0 11
64344: PUSH
64345: LD_VAR 0 11
64349: PPUSH
64350: LD_VAR 0 11
64354: PUSH
64355: LD_INT 1
64357: PLUS
64358: PPUSH
64359: LD_VAR 0 9
64363: PUSH
64364: LD_VAR 0 3
64368: ARRAY
64369: PPUSH
64370: CALL_OW 2
64374: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64375: LD_ADDR_VAR 0 4
64379: PUSH
64380: LD_VAR 0 4
64384: PUSH
64385: LD_VAR 0 9
64389: PUSH
64390: LD_VAR 0 3
64394: ARRAY
64395: DIFF
64396: ST_TO_ADDR
// end ;
64397: GO 64306
64399: POP
64400: POP
// if p then
64401: LD_VAR 0 11
64405: IFFALSE 64430
// result := Replace ( result , 3 , p ) ;
64407: LD_ADDR_VAR 0 2
64411: PUSH
64412: LD_VAR 0 2
64416: PPUSH
64417: LD_INT 3
64419: PPUSH
64420: LD_VAR 0 11
64424: PPUSH
64425: CALL_OW 1
64429: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64430: LD_ADDR_VAR 0 4
64434: PUSH
64435: LD_VAR 0 4
64439: PUSH
64440: LD_VAR 0 6
64444: DIFF
64445: ST_TO_ADDR
// if tmp and eng < 4 then
64446: LD_VAR 0 4
64450: PUSH
64451: LD_VAR 0 6
64455: PUSH
64456: LD_INT 4
64458: LESS
64459: AND
64460: IFFALSE 64650
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
64462: LD_ADDR_VAR 0 9
64466: PUSH
64467: LD_VAR 0 4
64471: PUSH
64472: LD_VAR 0 7
64476: PUSH
64477: LD_VAR 0 6
64481: UNION
64482: DIFF
64483: PPUSH
64484: LD_INT 2
64486: PPUSH
64487: CALL 54902 0 2
64491: ST_TO_ADDR
// p := [ ] ;
64492: LD_ADDR_VAR 0 11
64496: PUSH
64497: EMPTY
64498: ST_TO_ADDR
// if sort then
64499: LD_VAR 0 9
64503: IFFALSE 64619
// for i = 1 to 4 - eng do
64505: LD_ADDR_VAR 0 3
64509: PUSH
64510: DOUBLE
64511: LD_INT 1
64513: DEC
64514: ST_TO_ADDR
64515: LD_INT 4
64517: PUSH
64518: LD_VAR 0 6
64522: MINUS
64523: PUSH
64524: FOR_TO
64525: IFFALSE 64617
// begin if i = sort then
64527: LD_VAR 0 3
64531: PUSH
64532: LD_VAR 0 9
64536: EQUAL
64537: IFFALSE 64541
// break ;
64539: GO 64617
// if GetClass ( i ) = 2 then
64541: LD_VAR 0 3
64545: PPUSH
64546: CALL_OW 257
64550: PUSH
64551: LD_INT 2
64553: EQUAL
64554: IFFALSE 64558
// continue ;
64556: GO 64524
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64558: LD_ADDR_VAR 0 11
64562: PUSH
64563: LD_VAR 0 11
64567: PPUSH
64568: LD_VAR 0 11
64572: PUSH
64573: LD_INT 1
64575: PLUS
64576: PPUSH
64577: LD_VAR 0 9
64581: PUSH
64582: LD_VAR 0 3
64586: ARRAY
64587: PPUSH
64588: CALL_OW 2
64592: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64593: LD_ADDR_VAR 0 4
64597: PUSH
64598: LD_VAR 0 4
64602: PUSH
64603: LD_VAR 0 9
64607: PUSH
64608: LD_VAR 0 3
64612: ARRAY
64613: DIFF
64614: ST_TO_ADDR
// end ;
64615: GO 64524
64617: POP
64618: POP
// if p then
64619: LD_VAR 0 11
64623: IFFALSE 64648
// result := Replace ( result , 2 , p ) ;
64625: LD_ADDR_VAR 0 2
64629: PUSH
64630: LD_VAR 0 2
64634: PPUSH
64635: LD_INT 2
64637: PPUSH
64638: LD_VAR 0 11
64642: PPUSH
64643: CALL_OW 1
64647: ST_TO_ADDR
// end else
64648: GO 64694
// for i = eng downto 5 do
64650: LD_ADDR_VAR 0 3
64654: PUSH
64655: DOUBLE
64656: LD_VAR 0 6
64660: INC
64661: ST_TO_ADDR
64662: LD_INT 5
64664: PUSH
64665: FOR_DOWNTO
64666: IFFALSE 64692
// tmp := tmp union eng [ i ] ;
64668: LD_ADDR_VAR 0 4
64672: PUSH
64673: LD_VAR 0 4
64677: PUSH
64678: LD_VAR 0 6
64682: PUSH
64683: LD_VAR 0 3
64687: ARRAY
64688: UNION
64689: ST_TO_ADDR
64690: GO 64665
64692: POP
64693: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
64694: LD_ADDR_VAR 0 2
64698: PUSH
64699: LD_VAR 0 2
64703: PPUSH
64704: LD_INT 1
64706: PPUSH
64707: LD_VAR 0 4
64711: PUSH
64712: LD_VAR 0 5
64716: DIFF
64717: PPUSH
64718: CALL_OW 1
64722: ST_TO_ADDR
// exit ;
64723: GO 64725
// end ; end ;
64725: LD_VAR 0 2
64729: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
64730: LD_INT 0
64732: PPUSH
64733: PPUSH
64734: PPUSH
// if not mc_bases then
64735: LD_EXP 58
64739: NOT
64740: IFFALSE 64744
// exit ;
64742: GO 64850
// for i = 1 to mc_bases do
64744: LD_ADDR_VAR 0 2
64748: PUSH
64749: DOUBLE
64750: LD_INT 1
64752: DEC
64753: ST_TO_ADDR
64754: LD_EXP 58
64758: PUSH
64759: FOR_TO
64760: IFFALSE 64841
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64762: LD_ADDR_VAR 0 3
64766: PUSH
64767: LD_EXP 58
64771: PUSH
64772: LD_VAR 0 2
64776: ARRAY
64777: PPUSH
64778: LD_INT 21
64780: PUSH
64781: LD_INT 3
64783: PUSH
64784: EMPTY
64785: LIST
64786: LIST
64787: PUSH
64788: LD_INT 3
64790: PUSH
64791: LD_INT 24
64793: PUSH
64794: LD_INT 1000
64796: PUSH
64797: EMPTY
64798: LIST
64799: LIST
64800: PUSH
64801: EMPTY
64802: LIST
64803: LIST
64804: PUSH
64805: EMPTY
64806: LIST
64807: LIST
64808: PPUSH
64809: CALL_OW 72
64813: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
64814: LD_ADDR_EXP 59
64818: PUSH
64819: LD_EXP 59
64823: PPUSH
64824: LD_VAR 0 2
64828: PPUSH
64829: LD_VAR 0 3
64833: PPUSH
64834: CALL_OW 1
64838: ST_TO_ADDR
// end ;
64839: GO 64759
64841: POP
64842: POP
// RaiseSailEvent ( 101 ) ;
64843: LD_INT 101
64845: PPUSH
64846: CALL_OW 427
// end ;
64850: LD_VAR 0 1
64854: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
64855: LD_INT 0
64857: PPUSH
64858: PPUSH
64859: PPUSH
64860: PPUSH
64861: PPUSH
64862: PPUSH
64863: PPUSH
// if not mc_bases then
64864: LD_EXP 58
64868: NOT
64869: IFFALSE 64873
// exit ;
64871: GO 65446
// for i = 1 to mc_bases do
64873: LD_ADDR_VAR 0 2
64877: PUSH
64878: DOUBLE
64879: LD_INT 1
64881: DEC
64882: ST_TO_ADDR
64883: LD_EXP 58
64887: PUSH
64888: FOR_TO
64889: IFFALSE 65437
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
64891: LD_ADDR_VAR 0 5
64895: PUSH
64896: LD_EXP 58
64900: PUSH
64901: LD_VAR 0 2
64905: ARRAY
64906: PUSH
64907: LD_EXP 87
64911: PUSH
64912: LD_VAR 0 2
64916: ARRAY
64917: UNION
64918: PPUSH
64919: LD_INT 21
64921: PUSH
64922: LD_INT 1
64924: PUSH
64925: EMPTY
64926: LIST
64927: LIST
64928: PUSH
64929: LD_INT 1
64931: PUSH
64932: LD_INT 3
64934: PUSH
64935: LD_INT 54
64937: PUSH
64938: EMPTY
64939: LIST
64940: PUSH
64941: EMPTY
64942: LIST
64943: LIST
64944: PUSH
64945: LD_INT 3
64947: PUSH
64948: LD_INT 24
64950: PUSH
64951: LD_INT 800
64953: PUSH
64954: EMPTY
64955: LIST
64956: LIST
64957: PUSH
64958: EMPTY
64959: LIST
64960: LIST
64961: PUSH
64962: EMPTY
64963: LIST
64964: LIST
64965: LIST
64966: PUSH
64967: EMPTY
64968: LIST
64969: LIST
64970: PPUSH
64971: CALL_OW 72
64975: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
64976: LD_ADDR_VAR 0 6
64980: PUSH
64981: LD_EXP 58
64985: PUSH
64986: LD_VAR 0 2
64990: ARRAY
64991: PPUSH
64992: LD_INT 21
64994: PUSH
64995: LD_INT 1
64997: PUSH
64998: EMPTY
64999: LIST
65000: LIST
65001: PUSH
65002: LD_INT 1
65004: PUSH
65005: LD_INT 3
65007: PUSH
65008: LD_INT 54
65010: PUSH
65011: EMPTY
65012: LIST
65013: PUSH
65014: EMPTY
65015: LIST
65016: LIST
65017: PUSH
65018: LD_INT 3
65020: PUSH
65021: LD_INT 24
65023: PUSH
65024: LD_INT 250
65026: PUSH
65027: EMPTY
65028: LIST
65029: LIST
65030: PUSH
65031: EMPTY
65032: LIST
65033: LIST
65034: PUSH
65035: EMPTY
65036: LIST
65037: LIST
65038: LIST
65039: PUSH
65040: EMPTY
65041: LIST
65042: LIST
65043: PPUSH
65044: CALL_OW 72
65048: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
65049: LD_ADDR_VAR 0 7
65053: PUSH
65054: LD_VAR 0 5
65058: PUSH
65059: LD_VAR 0 6
65063: DIFF
65064: ST_TO_ADDR
// if not need_heal_1 then
65065: LD_VAR 0 6
65069: NOT
65070: IFFALSE 65103
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
65072: LD_ADDR_EXP 61
65076: PUSH
65077: LD_EXP 61
65081: PPUSH
65082: LD_VAR 0 2
65086: PUSH
65087: LD_INT 1
65089: PUSH
65090: EMPTY
65091: LIST
65092: LIST
65093: PPUSH
65094: EMPTY
65095: PPUSH
65096: CALL 20654 0 3
65100: ST_TO_ADDR
65101: GO 65173
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
65103: LD_ADDR_EXP 61
65107: PUSH
65108: LD_EXP 61
65112: PPUSH
65113: LD_VAR 0 2
65117: PUSH
65118: LD_INT 1
65120: PUSH
65121: EMPTY
65122: LIST
65123: LIST
65124: PPUSH
65125: LD_EXP 61
65129: PUSH
65130: LD_VAR 0 2
65134: ARRAY
65135: PUSH
65136: LD_INT 1
65138: ARRAY
65139: PPUSH
65140: LD_INT 3
65142: PUSH
65143: LD_INT 24
65145: PUSH
65146: LD_INT 1000
65148: PUSH
65149: EMPTY
65150: LIST
65151: LIST
65152: PUSH
65153: EMPTY
65154: LIST
65155: LIST
65156: PPUSH
65157: CALL_OW 72
65161: PUSH
65162: LD_VAR 0 6
65166: UNION
65167: PPUSH
65168: CALL 20654 0 3
65172: ST_TO_ADDR
// if not need_heal_2 then
65173: LD_VAR 0 7
65177: NOT
65178: IFFALSE 65211
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
65180: LD_ADDR_EXP 61
65184: PUSH
65185: LD_EXP 61
65189: PPUSH
65190: LD_VAR 0 2
65194: PUSH
65195: LD_INT 2
65197: PUSH
65198: EMPTY
65199: LIST
65200: LIST
65201: PPUSH
65202: EMPTY
65203: PPUSH
65204: CALL 20654 0 3
65208: ST_TO_ADDR
65209: GO 65243
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
65211: LD_ADDR_EXP 61
65215: PUSH
65216: LD_EXP 61
65220: PPUSH
65221: LD_VAR 0 2
65225: PUSH
65226: LD_INT 2
65228: PUSH
65229: EMPTY
65230: LIST
65231: LIST
65232: PPUSH
65233: LD_VAR 0 7
65237: PPUSH
65238: CALL 20654 0 3
65242: ST_TO_ADDR
// if need_heal_2 then
65243: LD_VAR 0 7
65247: IFFALSE 65419
// for j in need_heal_2 do
65249: LD_ADDR_VAR 0 3
65253: PUSH
65254: LD_VAR 0 7
65258: PUSH
65259: FOR_IN
65260: IFFALSE 65417
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
65262: LD_ADDR_VAR 0 5
65266: PUSH
65267: LD_EXP 58
65271: PUSH
65272: LD_VAR 0 2
65276: ARRAY
65277: PPUSH
65278: LD_INT 2
65280: PUSH
65281: LD_INT 30
65283: PUSH
65284: LD_INT 6
65286: PUSH
65287: EMPTY
65288: LIST
65289: LIST
65290: PUSH
65291: LD_INT 30
65293: PUSH
65294: LD_INT 7
65296: PUSH
65297: EMPTY
65298: LIST
65299: LIST
65300: PUSH
65301: LD_INT 30
65303: PUSH
65304: LD_INT 8
65306: PUSH
65307: EMPTY
65308: LIST
65309: LIST
65310: PUSH
65311: LD_INT 30
65313: PUSH
65314: LD_INT 0
65316: PUSH
65317: EMPTY
65318: LIST
65319: LIST
65320: PUSH
65321: LD_INT 30
65323: PUSH
65324: LD_INT 1
65326: PUSH
65327: EMPTY
65328: LIST
65329: LIST
65330: PUSH
65331: LD_INT 25
65333: PUSH
65334: LD_INT 4
65336: PUSH
65337: EMPTY
65338: LIST
65339: LIST
65340: PUSH
65341: EMPTY
65342: LIST
65343: LIST
65344: LIST
65345: LIST
65346: LIST
65347: LIST
65348: LIST
65349: PPUSH
65350: CALL_OW 72
65354: ST_TO_ADDR
// if tmp then
65355: LD_VAR 0 5
65359: IFFALSE 65415
// begin k := NearestUnitToUnit ( tmp , j ) ;
65361: LD_ADDR_VAR 0 4
65365: PUSH
65366: LD_VAR 0 5
65370: PPUSH
65371: LD_VAR 0 3
65375: PPUSH
65376: CALL_OW 74
65380: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
65381: LD_VAR 0 3
65385: PPUSH
65386: LD_VAR 0 4
65390: PPUSH
65391: CALL_OW 296
65395: PUSH
65396: LD_INT 7
65398: GREATER
65399: IFFALSE 65415
// ComMoveUnit ( j , k ) ;
65401: LD_VAR 0 3
65405: PPUSH
65406: LD_VAR 0 4
65410: PPUSH
65411: CALL_OW 112
// end ; end ;
65415: GO 65259
65417: POP
65418: POP
// if not need_heal_1 and not need_heal_2 then
65419: LD_VAR 0 6
65423: NOT
65424: PUSH
65425: LD_VAR 0 7
65429: NOT
65430: AND
65431: IFFALSE 65435
// continue ;
65433: GO 64888
// end ;
65435: GO 64888
65437: POP
65438: POP
// RaiseSailEvent ( 102 ) ;
65439: LD_INT 102
65441: PPUSH
65442: CALL_OW 427
// end ;
65446: LD_VAR 0 1
65450: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
65451: LD_INT 0
65453: PPUSH
65454: PPUSH
65455: PPUSH
65456: PPUSH
65457: PPUSH
// if not mc_bases then
65458: LD_EXP 58
65462: NOT
65463: IFFALSE 65467
// exit ;
65465: GO 65852
// for i = 1 to mc_bases do
65467: LD_ADDR_VAR 0 2
65471: PUSH
65472: DOUBLE
65473: LD_INT 1
65475: DEC
65476: ST_TO_ADDR
65477: LD_EXP 58
65481: PUSH
65482: FOR_TO
65483: IFFALSE 65850
// begin if not mc_building_need_repair [ i ] then
65485: LD_EXP 59
65489: PUSH
65490: LD_VAR 0 2
65494: ARRAY
65495: NOT
65496: IFFALSE 65534
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
65498: LD_ADDR_EXP 60
65502: PUSH
65503: LD_EXP 60
65507: PPUSH
65508: LD_VAR 0 2
65512: PPUSH
65513: EMPTY
65514: PPUSH
65515: CALL_OW 1
65519: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
65520: LD_VAR 0 2
65524: PPUSH
65525: LD_INT 101
65527: PPUSH
65528: CALL 60572 0 2
// continue ;
65532: GO 65482
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
65534: LD_ADDR_EXP 64
65538: PUSH
65539: LD_EXP 64
65543: PPUSH
65544: LD_VAR 0 2
65548: PPUSH
65549: EMPTY
65550: PPUSH
65551: CALL_OW 1
65555: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65556: LD_VAR 0 2
65560: PPUSH
65561: LD_INT 103
65563: PPUSH
65564: CALL 60572 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
65568: LD_ADDR_VAR 0 5
65572: PUSH
65573: LD_EXP 58
65577: PUSH
65578: LD_VAR 0 2
65582: ARRAY
65583: PUSH
65584: LD_EXP 87
65588: PUSH
65589: LD_VAR 0 2
65593: ARRAY
65594: UNION
65595: PPUSH
65596: LD_INT 2
65598: PUSH
65599: LD_INT 25
65601: PUSH
65602: LD_INT 2
65604: PUSH
65605: EMPTY
65606: LIST
65607: LIST
65608: PUSH
65609: LD_INT 25
65611: PUSH
65612: LD_INT 16
65614: PUSH
65615: EMPTY
65616: LIST
65617: LIST
65618: PUSH
65619: EMPTY
65620: LIST
65621: LIST
65622: LIST
65623: PUSH
65624: EMPTY
65625: LIST
65626: PPUSH
65627: CALL_OW 72
65631: ST_TO_ADDR
// if not tmp then
65632: LD_VAR 0 5
65636: NOT
65637: IFFALSE 65641
// continue ;
65639: GO 65482
// for j in tmp do
65641: LD_ADDR_VAR 0 3
65645: PUSH
65646: LD_VAR 0 5
65650: PUSH
65651: FOR_IN
65652: IFFALSE 65846
// begin if mc_need_heal [ i ] then
65654: LD_EXP 61
65658: PUSH
65659: LD_VAR 0 2
65663: ARRAY
65664: IFFALSE 65712
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
65666: LD_VAR 0 3
65670: PUSH
65671: LD_EXP 61
65675: PUSH
65676: LD_VAR 0 2
65680: ARRAY
65681: PUSH
65682: LD_INT 1
65684: ARRAY
65685: IN
65686: PUSH
65687: LD_VAR 0 3
65691: PUSH
65692: LD_EXP 61
65696: PUSH
65697: LD_VAR 0 2
65701: ARRAY
65702: PUSH
65703: LD_INT 2
65705: ARRAY
65706: IN
65707: OR
65708: IFFALSE 65712
// continue ;
65710: GO 65651
// if IsInUnit ( j ) then
65712: LD_VAR 0 3
65716: PPUSH
65717: CALL_OW 310
65721: IFFALSE 65732
// ComExitBuilding ( j ) ;
65723: LD_VAR 0 3
65727: PPUSH
65728: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
65732: LD_VAR 0 3
65736: PUSH
65737: LD_EXP 60
65741: PUSH
65742: LD_VAR 0 2
65746: ARRAY
65747: IN
65748: NOT
65749: IFFALSE 65807
// begin SetTag ( j , 101 ) ;
65751: LD_VAR 0 3
65755: PPUSH
65756: LD_INT 101
65758: PPUSH
65759: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
65763: LD_ADDR_EXP 60
65767: PUSH
65768: LD_EXP 60
65772: PPUSH
65773: LD_VAR 0 2
65777: PUSH
65778: LD_EXP 60
65782: PUSH
65783: LD_VAR 0 2
65787: ARRAY
65788: PUSH
65789: LD_INT 1
65791: PLUS
65792: PUSH
65793: EMPTY
65794: LIST
65795: LIST
65796: PPUSH
65797: LD_VAR 0 3
65801: PPUSH
65802: CALL 20654 0 3
65806: ST_TO_ADDR
// end ; wait ( 1 ) ;
65807: LD_INT 1
65809: PPUSH
65810: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
65814: LD_VAR 0 3
65818: PPUSH
65819: LD_EXP 59
65823: PUSH
65824: LD_VAR 0 2
65828: ARRAY
65829: PPUSH
65830: LD_VAR 0 3
65834: PPUSH
65835: CALL_OW 74
65839: PPUSH
65840: CALL_OW 130
// end ;
65844: GO 65651
65846: POP
65847: POP
// end ;
65848: GO 65482
65850: POP
65851: POP
// end ;
65852: LD_VAR 0 1
65856: RET
// export function MC_Heal ; var i , j , tmp ; begin
65857: LD_INT 0
65859: PPUSH
65860: PPUSH
65861: PPUSH
65862: PPUSH
// if not mc_bases then
65863: LD_EXP 58
65867: NOT
65868: IFFALSE 65872
// exit ;
65870: GO 66274
// for i = 1 to mc_bases do
65872: LD_ADDR_VAR 0 2
65876: PUSH
65877: DOUBLE
65878: LD_INT 1
65880: DEC
65881: ST_TO_ADDR
65882: LD_EXP 58
65886: PUSH
65887: FOR_TO
65888: IFFALSE 66272
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
65890: LD_EXP 61
65894: PUSH
65895: LD_VAR 0 2
65899: ARRAY
65900: PUSH
65901: LD_INT 1
65903: ARRAY
65904: NOT
65905: PUSH
65906: LD_EXP 61
65910: PUSH
65911: LD_VAR 0 2
65915: ARRAY
65916: PUSH
65917: LD_INT 2
65919: ARRAY
65920: NOT
65921: AND
65922: IFFALSE 65960
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
65924: LD_ADDR_EXP 62
65928: PUSH
65929: LD_EXP 62
65933: PPUSH
65934: LD_VAR 0 2
65938: PPUSH
65939: EMPTY
65940: PPUSH
65941: CALL_OW 1
65945: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
65946: LD_VAR 0 2
65950: PPUSH
65951: LD_INT 102
65953: PPUSH
65954: CALL 60572 0 2
// continue ;
65958: GO 65887
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
65960: LD_ADDR_VAR 0 4
65964: PUSH
65965: LD_EXP 58
65969: PUSH
65970: LD_VAR 0 2
65974: ARRAY
65975: PPUSH
65976: LD_INT 25
65978: PUSH
65979: LD_INT 4
65981: PUSH
65982: EMPTY
65983: LIST
65984: LIST
65985: PPUSH
65986: CALL_OW 72
65990: ST_TO_ADDR
// if not tmp then
65991: LD_VAR 0 4
65995: NOT
65996: IFFALSE 66000
// continue ;
65998: GO 65887
// if mc_taming [ i ] then
66000: LD_EXP 89
66004: PUSH
66005: LD_VAR 0 2
66009: ARRAY
66010: IFFALSE 66034
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
66012: LD_ADDR_EXP 89
66016: PUSH
66017: LD_EXP 89
66021: PPUSH
66022: LD_VAR 0 2
66026: PPUSH
66027: EMPTY
66028: PPUSH
66029: CALL_OW 1
66033: ST_TO_ADDR
// for j in tmp do
66034: LD_ADDR_VAR 0 3
66038: PUSH
66039: LD_VAR 0 4
66043: PUSH
66044: FOR_IN
66045: IFFALSE 66268
// begin if IsInUnit ( j ) then
66047: LD_VAR 0 3
66051: PPUSH
66052: CALL_OW 310
66056: IFFALSE 66067
// ComExitBuilding ( j ) ;
66058: LD_VAR 0 3
66062: PPUSH
66063: CALL_OW 122
// if not j in mc_healers [ i ] then
66067: LD_VAR 0 3
66071: PUSH
66072: LD_EXP 62
66076: PUSH
66077: LD_VAR 0 2
66081: ARRAY
66082: IN
66083: NOT
66084: IFFALSE 66130
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
66086: LD_ADDR_EXP 62
66090: PUSH
66091: LD_EXP 62
66095: PPUSH
66096: LD_VAR 0 2
66100: PUSH
66101: LD_EXP 62
66105: PUSH
66106: LD_VAR 0 2
66110: ARRAY
66111: PUSH
66112: LD_INT 1
66114: PLUS
66115: PUSH
66116: EMPTY
66117: LIST
66118: LIST
66119: PPUSH
66120: LD_VAR 0 3
66124: PPUSH
66125: CALL 20654 0 3
66129: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
66130: LD_VAR 0 3
66134: PPUSH
66135: CALL_OW 110
66139: PUSH
66140: LD_INT 102
66142: NONEQUAL
66143: IFFALSE 66157
// SetTag ( j , 102 ) ;
66145: LD_VAR 0 3
66149: PPUSH
66150: LD_INT 102
66152: PPUSH
66153: CALL_OW 109
// Wait ( 3 ) ;
66157: LD_INT 3
66159: PPUSH
66160: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
66164: LD_EXP 61
66168: PUSH
66169: LD_VAR 0 2
66173: ARRAY
66174: PUSH
66175: LD_INT 1
66177: ARRAY
66178: IFFALSE 66210
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
66180: LD_VAR 0 3
66184: PPUSH
66185: LD_EXP 61
66189: PUSH
66190: LD_VAR 0 2
66194: ARRAY
66195: PUSH
66196: LD_INT 1
66198: ARRAY
66199: PUSH
66200: LD_INT 1
66202: ARRAY
66203: PPUSH
66204: CALL_OW 128
66208: GO 66266
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
66210: LD_VAR 0 3
66214: PPUSH
66215: CALL_OW 314
66219: NOT
66220: PUSH
66221: LD_EXP 61
66225: PUSH
66226: LD_VAR 0 2
66230: ARRAY
66231: PUSH
66232: LD_INT 2
66234: ARRAY
66235: AND
66236: IFFALSE 66266
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
66238: LD_VAR 0 3
66242: PPUSH
66243: LD_EXP 61
66247: PUSH
66248: LD_VAR 0 2
66252: ARRAY
66253: PUSH
66254: LD_INT 2
66256: ARRAY
66257: PUSH
66258: LD_INT 1
66260: ARRAY
66261: PPUSH
66262: CALL_OW 128
// end ;
66266: GO 66044
66268: POP
66269: POP
// end ;
66270: GO 65887
66272: POP
66273: POP
// end ;
66274: LD_VAR 0 1
66278: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
66279: LD_INT 0
66281: PPUSH
66282: PPUSH
66283: PPUSH
66284: PPUSH
66285: PPUSH
// if not mc_bases then
66286: LD_EXP 58
66290: NOT
66291: IFFALSE 66295
// exit ;
66293: GO 67438
// for i = 1 to mc_bases do
66295: LD_ADDR_VAR 0 2
66299: PUSH
66300: DOUBLE
66301: LD_INT 1
66303: DEC
66304: ST_TO_ADDR
66305: LD_EXP 58
66309: PUSH
66310: FOR_TO
66311: IFFALSE 67436
// begin if mc_scan [ i ] then
66313: LD_EXP 81
66317: PUSH
66318: LD_VAR 0 2
66322: ARRAY
66323: IFFALSE 66327
// continue ;
66325: GO 66310
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
66327: LD_EXP 63
66331: PUSH
66332: LD_VAR 0 2
66336: ARRAY
66337: NOT
66338: PUSH
66339: LD_EXP 65
66343: PUSH
66344: LD_VAR 0 2
66348: ARRAY
66349: NOT
66350: AND
66351: PUSH
66352: LD_EXP 64
66356: PUSH
66357: LD_VAR 0 2
66361: ARRAY
66362: AND
66363: IFFALSE 66401
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
66365: LD_ADDR_EXP 64
66369: PUSH
66370: LD_EXP 64
66374: PPUSH
66375: LD_VAR 0 2
66379: PPUSH
66380: EMPTY
66381: PPUSH
66382: CALL_OW 1
66386: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66387: LD_VAR 0 2
66391: PPUSH
66392: LD_INT 103
66394: PPUSH
66395: CALL 60572 0 2
// continue ;
66399: GO 66310
// end ; if mc_construct_list [ i ] then
66401: LD_EXP 65
66405: PUSH
66406: LD_VAR 0 2
66410: ARRAY
66411: IFFALSE 66631
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
66413: LD_ADDR_VAR 0 4
66417: PUSH
66418: LD_EXP 58
66422: PUSH
66423: LD_VAR 0 2
66427: ARRAY
66428: PPUSH
66429: LD_INT 25
66431: PUSH
66432: LD_INT 2
66434: PUSH
66435: EMPTY
66436: LIST
66437: LIST
66438: PPUSH
66439: CALL_OW 72
66443: PUSH
66444: LD_EXP 60
66448: PUSH
66449: LD_VAR 0 2
66453: ARRAY
66454: DIFF
66455: ST_TO_ADDR
// if not tmp then
66456: LD_VAR 0 4
66460: NOT
66461: IFFALSE 66465
// continue ;
66463: GO 66310
// for j in tmp do
66465: LD_ADDR_VAR 0 3
66469: PUSH
66470: LD_VAR 0 4
66474: PUSH
66475: FOR_IN
66476: IFFALSE 66627
// begin if not mc_builders [ i ] then
66478: LD_EXP 64
66482: PUSH
66483: LD_VAR 0 2
66487: ARRAY
66488: NOT
66489: IFFALSE 66547
// begin SetTag ( j , 103 ) ;
66491: LD_VAR 0 3
66495: PPUSH
66496: LD_INT 103
66498: PPUSH
66499: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
66503: LD_ADDR_EXP 64
66507: PUSH
66508: LD_EXP 64
66512: PPUSH
66513: LD_VAR 0 2
66517: PUSH
66518: LD_EXP 64
66522: PUSH
66523: LD_VAR 0 2
66527: ARRAY
66528: PUSH
66529: LD_INT 1
66531: PLUS
66532: PUSH
66533: EMPTY
66534: LIST
66535: LIST
66536: PPUSH
66537: LD_VAR 0 3
66541: PPUSH
66542: CALL 20654 0 3
66546: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
66547: LD_VAR 0 3
66551: PPUSH
66552: CALL_OW 310
66556: IFFALSE 66567
// ComExitBuilding ( j ) ;
66558: LD_VAR 0 3
66562: PPUSH
66563: CALL_OW 122
// wait ( 3 ) ;
66567: LD_INT 3
66569: PPUSH
66570: CALL_OW 67
// if not mc_construct_list [ i ] then
66574: LD_EXP 65
66578: PUSH
66579: LD_VAR 0 2
66583: ARRAY
66584: NOT
66585: IFFALSE 66589
// break ;
66587: GO 66627
// if not HasTask ( j ) then
66589: LD_VAR 0 3
66593: PPUSH
66594: CALL_OW 314
66598: NOT
66599: IFFALSE 66625
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
66601: LD_VAR 0 3
66605: PPUSH
66606: LD_EXP 65
66610: PUSH
66611: LD_VAR 0 2
66615: ARRAY
66616: PUSH
66617: LD_INT 1
66619: ARRAY
66620: PPUSH
66621: CALL 23505 0 2
// end ;
66625: GO 66475
66627: POP
66628: POP
// end else
66629: GO 67434
// if mc_build_list [ i ] then
66631: LD_EXP 63
66635: PUSH
66636: LD_VAR 0 2
66640: ARRAY
66641: IFFALSE 67434
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66643: LD_ADDR_VAR 0 5
66647: PUSH
66648: LD_EXP 58
66652: PUSH
66653: LD_VAR 0 2
66657: ARRAY
66658: PPUSH
66659: LD_INT 2
66661: PUSH
66662: LD_INT 30
66664: PUSH
66665: LD_INT 0
66667: PUSH
66668: EMPTY
66669: LIST
66670: LIST
66671: PUSH
66672: LD_INT 30
66674: PUSH
66675: LD_INT 1
66677: PUSH
66678: EMPTY
66679: LIST
66680: LIST
66681: PUSH
66682: EMPTY
66683: LIST
66684: LIST
66685: LIST
66686: PPUSH
66687: CALL_OW 72
66691: ST_TO_ADDR
// if depot then
66692: LD_VAR 0 5
66696: IFFALSE 66714
// depot := depot [ 1 ] else
66698: LD_ADDR_VAR 0 5
66702: PUSH
66703: LD_VAR 0 5
66707: PUSH
66708: LD_INT 1
66710: ARRAY
66711: ST_TO_ADDR
66712: GO 66722
// depot := 0 ;
66714: LD_ADDR_VAR 0 5
66718: PUSH
66719: LD_INT 0
66721: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
66722: LD_EXP 63
66726: PUSH
66727: LD_VAR 0 2
66731: ARRAY
66732: PUSH
66733: LD_INT 1
66735: ARRAY
66736: PUSH
66737: LD_INT 1
66739: ARRAY
66740: PPUSH
66741: CALL 23335 0 1
66745: PUSH
66746: LD_EXP 58
66750: PUSH
66751: LD_VAR 0 2
66755: ARRAY
66756: PPUSH
66757: LD_INT 2
66759: PUSH
66760: LD_INT 30
66762: PUSH
66763: LD_INT 2
66765: PUSH
66766: EMPTY
66767: LIST
66768: LIST
66769: PUSH
66770: LD_INT 30
66772: PUSH
66773: LD_INT 3
66775: PUSH
66776: EMPTY
66777: LIST
66778: LIST
66779: PUSH
66780: EMPTY
66781: LIST
66782: LIST
66783: LIST
66784: PPUSH
66785: CALL_OW 72
66789: NOT
66790: AND
66791: IFFALSE 66896
// begin for j = 1 to mc_build_list [ i ] do
66793: LD_ADDR_VAR 0 3
66797: PUSH
66798: DOUBLE
66799: LD_INT 1
66801: DEC
66802: ST_TO_ADDR
66803: LD_EXP 63
66807: PUSH
66808: LD_VAR 0 2
66812: ARRAY
66813: PUSH
66814: FOR_TO
66815: IFFALSE 66894
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
66817: LD_EXP 63
66821: PUSH
66822: LD_VAR 0 2
66826: ARRAY
66827: PUSH
66828: LD_VAR 0 3
66832: ARRAY
66833: PUSH
66834: LD_INT 1
66836: ARRAY
66837: PUSH
66838: LD_INT 2
66840: EQUAL
66841: IFFALSE 66892
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
66843: LD_ADDR_EXP 63
66847: PUSH
66848: LD_EXP 63
66852: PPUSH
66853: LD_VAR 0 2
66857: PPUSH
66858: LD_EXP 63
66862: PUSH
66863: LD_VAR 0 2
66867: ARRAY
66868: PPUSH
66869: LD_VAR 0 3
66873: PPUSH
66874: LD_INT 1
66876: PPUSH
66877: LD_INT 0
66879: PPUSH
66880: CALL 20072 0 4
66884: PPUSH
66885: CALL_OW 1
66889: ST_TO_ADDR
// break ;
66890: GO 66894
// end ;
66892: GO 66814
66894: POP
66895: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
66896: LD_EXP 63
66900: PUSH
66901: LD_VAR 0 2
66905: ARRAY
66906: PUSH
66907: LD_INT 1
66909: ARRAY
66910: PUSH
66911: LD_INT 1
66913: ARRAY
66914: PUSH
66915: LD_INT 0
66917: EQUAL
66918: PUSH
66919: LD_VAR 0 5
66923: PUSH
66924: LD_VAR 0 5
66928: PPUSH
66929: LD_EXP 63
66933: PUSH
66934: LD_VAR 0 2
66938: ARRAY
66939: PUSH
66940: LD_INT 1
66942: ARRAY
66943: PUSH
66944: LD_INT 1
66946: ARRAY
66947: PPUSH
66948: LD_EXP 63
66952: PUSH
66953: LD_VAR 0 2
66957: ARRAY
66958: PUSH
66959: LD_INT 1
66961: ARRAY
66962: PUSH
66963: LD_INT 2
66965: ARRAY
66966: PPUSH
66967: LD_EXP 63
66971: PUSH
66972: LD_VAR 0 2
66976: ARRAY
66977: PUSH
66978: LD_INT 1
66980: ARRAY
66981: PUSH
66982: LD_INT 3
66984: ARRAY
66985: PPUSH
66986: LD_EXP 63
66990: PUSH
66991: LD_VAR 0 2
66995: ARRAY
66996: PUSH
66997: LD_INT 1
66999: ARRAY
67000: PUSH
67001: LD_INT 4
67003: ARRAY
67004: PPUSH
67005: CALL 28069 0 5
67009: AND
67010: OR
67011: IFFALSE 67292
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67013: LD_ADDR_VAR 0 4
67017: PUSH
67018: LD_EXP 58
67022: PUSH
67023: LD_VAR 0 2
67027: ARRAY
67028: PPUSH
67029: LD_INT 25
67031: PUSH
67032: LD_INT 2
67034: PUSH
67035: EMPTY
67036: LIST
67037: LIST
67038: PPUSH
67039: CALL_OW 72
67043: PUSH
67044: LD_EXP 60
67048: PUSH
67049: LD_VAR 0 2
67053: ARRAY
67054: DIFF
67055: ST_TO_ADDR
// if not tmp then
67056: LD_VAR 0 4
67060: NOT
67061: IFFALSE 67065
// continue ;
67063: GO 66310
// for j in tmp do
67065: LD_ADDR_VAR 0 3
67069: PUSH
67070: LD_VAR 0 4
67074: PUSH
67075: FOR_IN
67076: IFFALSE 67288
// begin if not mc_builders [ i ] then
67078: LD_EXP 64
67082: PUSH
67083: LD_VAR 0 2
67087: ARRAY
67088: NOT
67089: IFFALSE 67147
// begin SetTag ( j , 103 ) ;
67091: LD_VAR 0 3
67095: PPUSH
67096: LD_INT 103
67098: PPUSH
67099: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67103: LD_ADDR_EXP 64
67107: PUSH
67108: LD_EXP 64
67112: PPUSH
67113: LD_VAR 0 2
67117: PUSH
67118: LD_EXP 64
67122: PUSH
67123: LD_VAR 0 2
67127: ARRAY
67128: PUSH
67129: LD_INT 1
67131: PLUS
67132: PUSH
67133: EMPTY
67134: LIST
67135: LIST
67136: PPUSH
67137: LD_VAR 0 3
67141: PPUSH
67142: CALL 20654 0 3
67146: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67147: LD_VAR 0 3
67151: PPUSH
67152: CALL_OW 310
67156: IFFALSE 67167
// ComExitBuilding ( j ) ;
67158: LD_VAR 0 3
67162: PPUSH
67163: CALL_OW 122
// wait ( 3 ) ;
67167: LD_INT 3
67169: PPUSH
67170: CALL_OW 67
// if not mc_build_list [ i ] then
67174: LD_EXP 63
67178: PUSH
67179: LD_VAR 0 2
67183: ARRAY
67184: NOT
67185: IFFALSE 67189
// break ;
67187: GO 67288
// if not HasTask ( j ) then
67189: LD_VAR 0 3
67193: PPUSH
67194: CALL_OW 314
67198: NOT
67199: IFFALSE 67286
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
67201: LD_VAR 0 3
67205: PPUSH
67206: LD_EXP 63
67210: PUSH
67211: LD_VAR 0 2
67215: ARRAY
67216: PUSH
67217: LD_INT 1
67219: ARRAY
67220: PUSH
67221: LD_INT 1
67223: ARRAY
67224: PPUSH
67225: LD_EXP 63
67229: PUSH
67230: LD_VAR 0 2
67234: ARRAY
67235: PUSH
67236: LD_INT 1
67238: ARRAY
67239: PUSH
67240: LD_INT 2
67242: ARRAY
67243: PPUSH
67244: LD_EXP 63
67248: PUSH
67249: LD_VAR 0 2
67253: ARRAY
67254: PUSH
67255: LD_INT 1
67257: ARRAY
67258: PUSH
67259: LD_INT 3
67261: ARRAY
67262: PPUSH
67263: LD_EXP 63
67267: PUSH
67268: LD_VAR 0 2
67272: ARRAY
67273: PUSH
67274: LD_INT 1
67276: ARRAY
67277: PUSH
67278: LD_INT 4
67280: ARRAY
67281: PPUSH
67282: CALL_OW 145
// end ;
67286: GO 67075
67288: POP
67289: POP
// end else
67290: GO 67434
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
67292: LD_EXP 58
67296: PUSH
67297: LD_VAR 0 2
67301: ARRAY
67302: PPUSH
67303: LD_EXP 63
67307: PUSH
67308: LD_VAR 0 2
67312: ARRAY
67313: PUSH
67314: LD_INT 1
67316: ARRAY
67317: PUSH
67318: LD_INT 1
67320: ARRAY
67321: PPUSH
67322: LD_EXP 63
67326: PUSH
67327: LD_VAR 0 2
67331: ARRAY
67332: PUSH
67333: LD_INT 1
67335: ARRAY
67336: PUSH
67337: LD_INT 2
67339: ARRAY
67340: PPUSH
67341: LD_EXP 63
67345: PUSH
67346: LD_VAR 0 2
67350: ARRAY
67351: PUSH
67352: LD_INT 1
67354: ARRAY
67355: PUSH
67356: LD_INT 3
67358: ARRAY
67359: PPUSH
67360: LD_EXP 63
67364: PUSH
67365: LD_VAR 0 2
67369: ARRAY
67370: PUSH
67371: LD_INT 1
67373: ARRAY
67374: PUSH
67375: LD_INT 4
67377: ARRAY
67378: PPUSH
67379: CALL 27405 0 5
67383: NOT
67384: IFFALSE 67434
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
67386: LD_ADDR_EXP 63
67390: PUSH
67391: LD_EXP 63
67395: PPUSH
67396: LD_VAR 0 2
67400: PPUSH
67401: LD_EXP 63
67405: PUSH
67406: LD_VAR 0 2
67410: ARRAY
67411: PPUSH
67412: LD_INT 1
67414: PPUSH
67415: LD_INT 1
67417: NEG
67418: PPUSH
67419: LD_INT 0
67421: PPUSH
67422: CALL 20072 0 4
67426: PPUSH
67427: CALL_OW 1
67431: ST_TO_ADDR
// continue ;
67432: GO 66310
// end ; end ; end ;
67434: GO 66310
67436: POP
67437: POP
// end ;
67438: LD_VAR 0 1
67442: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
67443: LD_INT 0
67445: PPUSH
67446: PPUSH
67447: PPUSH
67448: PPUSH
67449: PPUSH
67450: PPUSH
// if not mc_bases then
67451: LD_EXP 58
67455: NOT
67456: IFFALSE 67460
// exit ;
67458: GO 67887
// for i = 1 to mc_bases do
67460: LD_ADDR_VAR 0 2
67464: PUSH
67465: DOUBLE
67466: LD_INT 1
67468: DEC
67469: ST_TO_ADDR
67470: LD_EXP 58
67474: PUSH
67475: FOR_TO
67476: IFFALSE 67885
// begin tmp := mc_build_upgrade [ i ] ;
67478: LD_ADDR_VAR 0 4
67482: PUSH
67483: LD_EXP 90
67487: PUSH
67488: LD_VAR 0 2
67492: ARRAY
67493: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
67494: LD_ADDR_VAR 0 6
67498: PUSH
67499: LD_EXP 91
67503: PUSH
67504: LD_VAR 0 2
67508: ARRAY
67509: PPUSH
67510: LD_INT 2
67512: PUSH
67513: LD_INT 30
67515: PUSH
67516: LD_INT 6
67518: PUSH
67519: EMPTY
67520: LIST
67521: LIST
67522: PUSH
67523: LD_INT 30
67525: PUSH
67526: LD_INT 7
67528: PUSH
67529: EMPTY
67530: LIST
67531: LIST
67532: PUSH
67533: EMPTY
67534: LIST
67535: LIST
67536: LIST
67537: PPUSH
67538: CALL_OW 72
67542: ST_TO_ADDR
// if not tmp and not lab then
67543: LD_VAR 0 4
67547: NOT
67548: PUSH
67549: LD_VAR 0 6
67553: NOT
67554: AND
67555: IFFALSE 67559
// continue ;
67557: GO 67475
// if tmp then
67559: LD_VAR 0 4
67563: IFFALSE 67683
// for j in tmp do
67565: LD_ADDR_VAR 0 3
67569: PUSH
67570: LD_VAR 0 4
67574: PUSH
67575: FOR_IN
67576: IFFALSE 67681
// begin if UpgradeCost ( j ) then
67578: LD_VAR 0 3
67582: PPUSH
67583: CALL 27065 0 1
67587: IFFALSE 67679
// begin ComUpgrade ( j ) ;
67589: LD_VAR 0 3
67593: PPUSH
67594: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
67598: LD_ADDR_EXP 90
67602: PUSH
67603: LD_EXP 90
67607: PPUSH
67608: LD_VAR 0 2
67612: PPUSH
67613: LD_EXP 90
67617: PUSH
67618: LD_VAR 0 2
67622: ARRAY
67623: PUSH
67624: LD_VAR 0 3
67628: DIFF
67629: PPUSH
67630: CALL_OW 1
67634: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
67635: LD_ADDR_EXP 65
67639: PUSH
67640: LD_EXP 65
67644: PPUSH
67645: LD_VAR 0 2
67649: PUSH
67650: LD_EXP 65
67654: PUSH
67655: LD_VAR 0 2
67659: ARRAY
67660: PUSH
67661: LD_INT 1
67663: PLUS
67664: PUSH
67665: EMPTY
67666: LIST
67667: LIST
67668: PPUSH
67669: LD_VAR 0 3
67673: PPUSH
67674: CALL 20654 0 3
67678: ST_TO_ADDR
// end ; end ;
67679: GO 67575
67681: POP
67682: POP
// if not lab or not mc_lab_upgrade [ i ] then
67683: LD_VAR 0 6
67687: NOT
67688: PUSH
67689: LD_EXP 92
67693: PUSH
67694: LD_VAR 0 2
67698: ARRAY
67699: NOT
67700: OR
67701: IFFALSE 67705
// continue ;
67703: GO 67475
// for j in lab do
67705: LD_ADDR_VAR 0 3
67709: PUSH
67710: LD_VAR 0 6
67714: PUSH
67715: FOR_IN
67716: IFFALSE 67881
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
67718: LD_VAR 0 3
67722: PPUSH
67723: CALL_OW 266
67727: PUSH
67728: LD_INT 6
67730: PUSH
67731: LD_INT 7
67733: PUSH
67734: EMPTY
67735: LIST
67736: LIST
67737: IN
67738: PUSH
67739: LD_VAR 0 3
67743: PPUSH
67744: CALL_OW 461
67748: PUSH
67749: LD_INT 1
67751: NONEQUAL
67752: AND
67753: IFFALSE 67879
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
67755: LD_VAR 0 3
67759: PPUSH
67760: LD_EXP 92
67764: PUSH
67765: LD_VAR 0 2
67769: ARRAY
67770: PUSH
67771: LD_INT 1
67773: ARRAY
67774: PPUSH
67775: CALL 27270 0 2
67779: IFFALSE 67879
// begin ComCancel ( j ) ;
67781: LD_VAR 0 3
67785: PPUSH
67786: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
67790: LD_VAR 0 3
67794: PPUSH
67795: LD_EXP 92
67799: PUSH
67800: LD_VAR 0 2
67804: ARRAY
67805: PUSH
67806: LD_INT 1
67808: ARRAY
67809: PPUSH
67810: CALL_OW 207
// if not j in mc_construct_list [ i ] then
67814: LD_VAR 0 3
67818: PUSH
67819: LD_EXP 65
67823: PUSH
67824: LD_VAR 0 2
67828: ARRAY
67829: IN
67830: NOT
67831: IFFALSE 67877
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
67833: LD_ADDR_EXP 65
67837: PUSH
67838: LD_EXP 65
67842: PPUSH
67843: LD_VAR 0 2
67847: PUSH
67848: LD_EXP 65
67852: PUSH
67853: LD_VAR 0 2
67857: ARRAY
67858: PUSH
67859: LD_INT 1
67861: PLUS
67862: PUSH
67863: EMPTY
67864: LIST
67865: LIST
67866: PPUSH
67867: LD_VAR 0 3
67871: PPUSH
67872: CALL 20654 0 3
67876: ST_TO_ADDR
// break ;
67877: GO 67881
// end ; end ; end ;
67879: GO 67715
67881: POP
67882: POP
// end ;
67883: GO 67475
67885: POP
67886: POP
// end ;
67887: LD_VAR 0 1
67891: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
67892: LD_INT 0
67894: PPUSH
67895: PPUSH
67896: PPUSH
67897: PPUSH
67898: PPUSH
67899: PPUSH
67900: PPUSH
67901: PPUSH
67902: PPUSH
// if not mc_bases then
67903: LD_EXP 58
67907: NOT
67908: IFFALSE 67912
// exit ;
67910: GO 68317
// for i = 1 to mc_bases do
67912: LD_ADDR_VAR 0 2
67916: PUSH
67917: DOUBLE
67918: LD_INT 1
67920: DEC
67921: ST_TO_ADDR
67922: LD_EXP 58
67926: PUSH
67927: FOR_TO
67928: IFFALSE 68315
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
67930: LD_EXP 66
67934: PUSH
67935: LD_VAR 0 2
67939: ARRAY
67940: NOT
67941: PUSH
67942: LD_EXP 58
67946: PUSH
67947: LD_VAR 0 2
67951: ARRAY
67952: PPUSH
67953: LD_INT 30
67955: PUSH
67956: LD_INT 3
67958: PUSH
67959: EMPTY
67960: LIST
67961: LIST
67962: PPUSH
67963: CALL_OW 72
67967: NOT
67968: OR
67969: IFFALSE 67973
// continue ;
67971: GO 67927
// busy := false ;
67973: LD_ADDR_VAR 0 8
67977: PUSH
67978: LD_INT 0
67980: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67981: LD_ADDR_VAR 0 4
67985: PUSH
67986: LD_EXP 58
67990: PUSH
67991: LD_VAR 0 2
67995: ARRAY
67996: PPUSH
67997: LD_INT 30
67999: PUSH
68000: LD_INT 3
68002: PUSH
68003: EMPTY
68004: LIST
68005: LIST
68006: PPUSH
68007: CALL_OW 72
68011: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
68012: LD_ADDR_VAR 0 6
68016: PUSH
68017: LD_EXP 66
68021: PUSH
68022: LD_VAR 0 2
68026: ARRAY
68027: PPUSH
68028: LD_INT 2
68030: PUSH
68031: LD_INT 30
68033: PUSH
68034: LD_INT 32
68036: PUSH
68037: EMPTY
68038: LIST
68039: LIST
68040: PUSH
68041: LD_INT 30
68043: PUSH
68044: LD_INT 33
68046: PUSH
68047: EMPTY
68048: LIST
68049: LIST
68050: PUSH
68051: EMPTY
68052: LIST
68053: LIST
68054: LIST
68055: PPUSH
68056: CALL_OW 72
68060: ST_TO_ADDR
// if not t then
68061: LD_VAR 0 6
68065: NOT
68066: IFFALSE 68070
// continue ;
68068: GO 67927
// for j in tmp do
68070: LD_ADDR_VAR 0 3
68074: PUSH
68075: LD_VAR 0 4
68079: PUSH
68080: FOR_IN
68081: IFFALSE 68111
// if not BuildingStatus ( j ) = bs_idle then
68083: LD_VAR 0 3
68087: PPUSH
68088: CALL_OW 461
68092: PUSH
68093: LD_INT 2
68095: EQUAL
68096: NOT
68097: IFFALSE 68109
// begin busy := true ;
68099: LD_ADDR_VAR 0 8
68103: PUSH
68104: LD_INT 1
68106: ST_TO_ADDR
// break ;
68107: GO 68111
// end ;
68109: GO 68080
68111: POP
68112: POP
// if busy then
68113: LD_VAR 0 8
68117: IFFALSE 68121
// continue ;
68119: GO 67927
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
68121: LD_ADDR_VAR 0 7
68125: PUSH
68126: LD_VAR 0 6
68130: PPUSH
68131: LD_INT 35
68133: PUSH
68134: LD_INT 0
68136: PUSH
68137: EMPTY
68138: LIST
68139: LIST
68140: PPUSH
68141: CALL_OW 72
68145: ST_TO_ADDR
// if tw then
68146: LD_VAR 0 7
68150: IFFALSE 68227
// begin tw := tw [ 1 ] ;
68152: LD_ADDR_VAR 0 7
68156: PUSH
68157: LD_VAR 0 7
68161: PUSH
68162: LD_INT 1
68164: ARRAY
68165: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
68166: LD_ADDR_VAR 0 9
68170: PUSH
68171: LD_VAR 0 7
68175: PPUSH
68176: LD_EXP 83
68180: PUSH
68181: LD_VAR 0 2
68185: ARRAY
68186: PPUSH
68187: CALL 25624 0 2
68191: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
68192: LD_EXP 97
68196: PUSH
68197: LD_VAR 0 2
68201: ARRAY
68202: IFFALSE 68225
// if not weapon in mc_allowed_tower_weapons [ i ] then
68204: LD_VAR 0 9
68208: PUSH
68209: LD_EXP 97
68213: PUSH
68214: LD_VAR 0 2
68218: ARRAY
68219: IN
68220: NOT
68221: IFFALSE 68225
// continue ;
68223: GO 67927
// end else
68225: GO 68290
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
68227: LD_ADDR_VAR 0 5
68231: PUSH
68232: LD_EXP 66
68236: PUSH
68237: LD_VAR 0 2
68241: ARRAY
68242: PPUSH
68243: LD_VAR 0 4
68247: PPUSH
68248: CALL 55825 0 2
68252: ST_TO_ADDR
// if not tmp2 then
68253: LD_VAR 0 5
68257: NOT
68258: IFFALSE 68262
// continue ;
68260: GO 67927
// tw := tmp2 [ 1 ] ;
68262: LD_ADDR_VAR 0 7
68266: PUSH
68267: LD_VAR 0 5
68271: PUSH
68272: LD_INT 1
68274: ARRAY
68275: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
68276: LD_ADDR_VAR 0 9
68280: PUSH
68281: LD_VAR 0 5
68285: PUSH
68286: LD_INT 2
68288: ARRAY
68289: ST_TO_ADDR
// end ; if not weapon then
68290: LD_VAR 0 9
68294: NOT
68295: IFFALSE 68299
// continue ;
68297: GO 67927
// ComPlaceWeapon ( tw , weapon ) ;
68299: LD_VAR 0 7
68303: PPUSH
68304: LD_VAR 0 9
68308: PPUSH
68309: CALL_OW 148
// end ;
68313: GO 67927
68315: POP
68316: POP
// end ;
68317: LD_VAR 0 1
68321: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
68322: LD_INT 0
68324: PPUSH
68325: PPUSH
68326: PPUSH
68327: PPUSH
68328: PPUSH
68329: PPUSH
// if not mc_bases then
68330: LD_EXP 58
68334: NOT
68335: IFFALSE 68339
// exit ;
68337: GO 69351
// for i = 1 to mc_bases do
68339: LD_ADDR_VAR 0 2
68343: PUSH
68344: DOUBLE
68345: LD_INT 1
68347: DEC
68348: ST_TO_ADDR
68349: LD_EXP 58
68353: PUSH
68354: FOR_TO
68355: IFFALSE 69349
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
68357: LD_EXP 71
68361: PUSH
68362: LD_VAR 0 2
68366: ARRAY
68367: NOT
68368: PUSH
68369: LD_EXP 71
68373: PUSH
68374: LD_VAR 0 2
68378: ARRAY
68379: PUSH
68380: LD_EXP 72
68384: PUSH
68385: LD_VAR 0 2
68389: ARRAY
68390: EQUAL
68391: OR
68392: IFFALSE 68396
// continue ;
68394: GO 68354
// if mc_miners [ i ] then
68396: LD_EXP 72
68400: PUSH
68401: LD_VAR 0 2
68405: ARRAY
68406: IFFALSE 69036
// begin k := 1 ;
68408: LD_ADDR_VAR 0 4
68412: PUSH
68413: LD_INT 1
68415: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
68416: LD_ADDR_VAR 0 3
68420: PUSH
68421: DOUBLE
68422: LD_EXP 72
68426: PUSH
68427: LD_VAR 0 2
68431: ARRAY
68432: INC
68433: ST_TO_ADDR
68434: LD_INT 1
68436: PUSH
68437: FOR_DOWNTO
68438: IFFALSE 69034
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
68440: LD_EXP 72
68444: PUSH
68445: LD_VAR 0 2
68449: ARRAY
68450: PUSH
68451: LD_VAR 0 3
68455: ARRAY
68456: PPUSH
68457: CALL_OW 301
68461: PUSH
68462: LD_EXP 72
68466: PUSH
68467: LD_VAR 0 2
68471: ARRAY
68472: PUSH
68473: LD_VAR 0 3
68477: ARRAY
68478: PPUSH
68479: CALL_OW 257
68483: PUSH
68484: LD_INT 1
68486: NONEQUAL
68487: OR
68488: IFFALSE 68551
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
68490: LD_ADDR_VAR 0 5
68494: PUSH
68495: LD_EXP 72
68499: PUSH
68500: LD_VAR 0 2
68504: ARRAY
68505: PUSH
68506: LD_EXP 72
68510: PUSH
68511: LD_VAR 0 2
68515: ARRAY
68516: PUSH
68517: LD_VAR 0 3
68521: ARRAY
68522: DIFF
68523: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
68524: LD_ADDR_EXP 72
68528: PUSH
68529: LD_EXP 72
68533: PPUSH
68534: LD_VAR 0 2
68538: PPUSH
68539: LD_VAR 0 5
68543: PPUSH
68544: CALL_OW 1
68548: ST_TO_ADDR
// continue ;
68549: GO 68437
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
68551: LD_EXP 72
68555: PUSH
68556: LD_VAR 0 2
68560: ARRAY
68561: PUSH
68562: LD_VAR 0 3
68566: ARRAY
68567: PPUSH
68568: CALL 20590 0 1
68572: PUSH
68573: LD_EXP 72
68577: PUSH
68578: LD_VAR 0 2
68582: ARRAY
68583: PUSH
68584: LD_VAR 0 3
68588: ARRAY
68589: PPUSH
68590: CALL_OW 255
68594: PPUSH
68595: LD_EXP 71
68599: PUSH
68600: LD_VAR 0 2
68604: ARRAY
68605: PUSH
68606: LD_VAR 0 4
68610: ARRAY
68611: PUSH
68612: LD_INT 1
68614: ARRAY
68615: PPUSH
68616: LD_EXP 71
68620: PUSH
68621: LD_VAR 0 2
68625: ARRAY
68626: PUSH
68627: LD_VAR 0 4
68631: ARRAY
68632: PUSH
68633: LD_INT 2
68635: ARRAY
68636: PPUSH
68637: LD_INT 15
68639: PPUSH
68640: CALL 21550 0 4
68644: PUSH
68645: LD_INT 4
68647: ARRAY
68648: PUSH
68649: LD_EXP 72
68653: PUSH
68654: LD_VAR 0 2
68658: ARRAY
68659: PUSH
68660: LD_VAR 0 3
68664: ARRAY
68665: PPUSH
68666: LD_INT 10
68668: PPUSH
68669: CALL 23247 0 2
68673: PUSH
68674: LD_INT 4
68676: ARRAY
68677: OR
68678: AND
68679: IFFALSE 68702
// ComStop ( mc_miners [ i ] [ j ] ) ;
68681: LD_EXP 72
68685: PUSH
68686: LD_VAR 0 2
68690: ARRAY
68691: PUSH
68692: LD_VAR 0 3
68696: ARRAY
68697: PPUSH
68698: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
68702: LD_EXP 72
68706: PUSH
68707: LD_VAR 0 2
68711: ARRAY
68712: PUSH
68713: LD_VAR 0 3
68717: ARRAY
68718: PPUSH
68719: CALL_OW 257
68723: PUSH
68724: LD_INT 1
68726: EQUAL
68727: PUSH
68728: LD_EXP 72
68732: PUSH
68733: LD_VAR 0 2
68737: ARRAY
68738: PUSH
68739: LD_VAR 0 3
68743: ARRAY
68744: PPUSH
68745: CALL_OW 459
68749: NOT
68750: AND
68751: PUSH
68752: LD_EXP 72
68756: PUSH
68757: LD_VAR 0 2
68761: ARRAY
68762: PUSH
68763: LD_VAR 0 3
68767: ARRAY
68768: PPUSH
68769: CALL_OW 255
68773: PPUSH
68774: LD_EXP 71
68778: PUSH
68779: LD_VAR 0 2
68783: ARRAY
68784: PUSH
68785: LD_VAR 0 4
68789: ARRAY
68790: PUSH
68791: LD_INT 1
68793: ARRAY
68794: PPUSH
68795: LD_EXP 71
68799: PUSH
68800: LD_VAR 0 2
68804: ARRAY
68805: PUSH
68806: LD_VAR 0 4
68810: ARRAY
68811: PUSH
68812: LD_INT 2
68814: ARRAY
68815: PPUSH
68816: LD_INT 15
68818: PPUSH
68819: CALL 21550 0 4
68823: PUSH
68824: LD_INT 4
68826: ARRAY
68827: PUSH
68828: LD_INT 0
68830: EQUAL
68831: AND
68832: PUSH
68833: LD_EXP 72
68837: PUSH
68838: LD_VAR 0 2
68842: ARRAY
68843: PUSH
68844: LD_VAR 0 3
68848: ARRAY
68849: PPUSH
68850: CALL_OW 314
68854: NOT
68855: AND
68856: IFFALSE 69032
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
68858: LD_EXP 72
68862: PUSH
68863: LD_VAR 0 2
68867: ARRAY
68868: PUSH
68869: LD_VAR 0 3
68873: ARRAY
68874: PPUSH
68875: CALL_OW 310
68879: IFFALSE 68902
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
68881: LD_EXP 72
68885: PUSH
68886: LD_VAR 0 2
68890: ARRAY
68891: PUSH
68892: LD_VAR 0 3
68896: ARRAY
68897: PPUSH
68898: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
68902: LD_EXP 72
68906: PUSH
68907: LD_VAR 0 2
68911: ARRAY
68912: PUSH
68913: LD_VAR 0 3
68917: ARRAY
68918: PPUSH
68919: CALL_OW 314
68923: NOT
68924: IFFALSE 68992
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
68926: LD_EXP 72
68930: PUSH
68931: LD_VAR 0 2
68935: ARRAY
68936: PUSH
68937: LD_VAR 0 3
68941: ARRAY
68942: PPUSH
68943: LD_EXP 71
68947: PUSH
68948: LD_VAR 0 2
68952: ARRAY
68953: PUSH
68954: LD_VAR 0 4
68958: ARRAY
68959: PUSH
68960: LD_INT 1
68962: ARRAY
68963: PPUSH
68964: LD_EXP 71
68968: PUSH
68969: LD_VAR 0 2
68973: ARRAY
68974: PUSH
68975: LD_VAR 0 4
68979: ARRAY
68980: PUSH
68981: LD_INT 2
68983: ARRAY
68984: PPUSH
68985: LD_INT 0
68987: PPUSH
68988: CALL_OW 193
// k := k + 1 ;
68992: LD_ADDR_VAR 0 4
68996: PUSH
68997: LD_VAR 0 4
69001: PUSH
69002: LD_INT 1
69004: PLUS
69005: ST_TO_ADDR
// if k > mc_mines [ i ] then
69006: LD_VAR 0 4
69010: PUSH
69011: LD_EXP 71
69015: PUSH
69016: LD_VAR 0 2
69020: ARRAY
69021: GREATER
69022: IFFALSE 69032
// k := 1 ;
69024: LD_ADDR_VAR 0 4
69028: PUSH
69029: LD_INT 1
69031: ST_TO_ADDR
// end ; end ;
69032: GO 68437
69034: POP
69035: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
69036: LD_ADDR_VAR 0 5
69040: PUSH
69041: LD_EXP 58
69045: PUSH
69046: LD_VAR 0 2
69050: ARRAY
69051: PPUSH
69052: LD_INT 2
69054: PUSH
69055: LD_INT 30
69057: PUSH
69058: LD_INT 4
69060: PUSH
69061: EMPTY
69062: LIST
69063: LIST
69064: PUSH
69065: LD_INT 30
69067: PUSH
69068: LD_INT 5
69070: PUSH
69071: EMPTY
69072: LIST
69073: LIST
69074: PUSH
69075: LD_INT 30
69077: PUSH
69078: LD_INT 32
69080: PUSH
69081: EMPTY
69082: LIST
69083: LIST
69084: PUSH
69085: EMPTY
69086: LIST
69087: LIST
69088: LIST
69089: LIST
69090: PPUSH
69091: CALL_OW 72
69095: ST_TO_ADDR
// if not tmp then
69096: LD_VAR 0 5
69100: NOT
69101: IFFALSE 69105
// continue ;
69103: GO 68354
// list := [ ] ;
69105: LD_ADDR_VAR 0 6
69109: PUSH
69110: EMPTY
69111: ST_TO_ADDR
// for j in tmp do
69112: LD_ADDR_VAR 0 3
69116: PUSH
69117: LD_VAR 0 5
69121: PUSH
69122: FOR_IN
69123: IFFALSE 69192
// begin for k in UnitsInside ( j ) do
69125: LD_ADDR_VAR 0 4
69129: PUSH
69130: LD_VAR 0 3
69134: PPUSH
69135: CALL_OW 313
69139: PUSH
69140: FOR_IN
69141: IFFALSE 69188
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
69143: LD_VAR 0 4
69147: PPUSH
69148: CALL_OW 257
69152: PUSH
69153: LD_INT 1
69155: EQUAL
69156: PUSH
69157: LD_VAR 0 4
69161: PPUSH
69162: CALL_OW 459
69166: NOT
69167: AND
69168: IFFALSE 69186
// list := list ^ k ;
69170: LD_ADDR_VAR 0 6
69174: PUSH
69175: LD_VAR 0 6
69179: PUSH
69180: LD_VAR 0 4
69184: ADD
69185: ST_TO_ADDR
69186: GO 69140
69188: POP
69189: POP
// end ;
69190: GO 69122
69192: POP
69193: POP
// list := list diff mc_miners [ i ] ;
69194: LD_ADDR_VAR 0 6
69198: PUSH
69199: LD_VAR 0 6
69203: PUSH
69204: LD_EXP 72
69208: PUSH
69209: LD_VAR 0 2
69213: ARRAY
69214: DIFF
69215: ST_TO_ADDR
// if not list then
69216: LD_VAR 0 6
69220: NOT
69221: IFFALSE 69225
// continue ;
69223: GO 68354
// k := mc_mines [ i ] - mc_miners [ i ] ;
69225: LD_ADDR_VAR 0 4
69229: PUSH
69230: LD_EXP 71
69234: PUSH
69235: LD_VAR 0 2
69239: ARRAY
69240: PUSH
69241: LD_EXP 72
69245: PUSH
69246: LD_VAR 0 2
69250: ARRAY
69251: MINUS
69252: ST_TO_ADDR
// if k > list then
69253: LD_VAR 0 4
69257: PUSH
69258: LD_VAR 0 6
69262: GREATER
69263: IFFALSE 69275
// k := list ;
69265: LD_ADDR_VAR 0 4
69269: PUSH
69270: LD_VAR 0 6
69274: ST_TO_ADDR
// for j = 1 to k do
69275: LD_ADDR_VAR 0 3
69279: PUSH
69280: DOUBLE
69281: LD_INT 1
69283: DEC
69284: ST_TO_ADDR
69285: LD_VAR 0 4
69289: PUSH
69290: FOR_TO
69291: IFFALSE 69345
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
69293: LD_ADDR_EXP 72
69297: PUSH
69298: LD_EXP 72
69302: PPUSH
69303: LD_VAR 0 2
69307: PUSH
69308: LD_EXP 72
69312: PUSH
69313: LD_VAR 0 2
69317: ARRAY
69318: PUSH
69319: LD_INT 1
69321: PLUS
69322: PUSH
69323: EMPTY
69324: LIST
69325: LIST
69326: PPUSH
69327: LD_VAR 0 6
69331: PUSH
69332: LD_VAR 0 3
69336: ARRAY
69337: PPUSH
69338: CALL 20654 0 3
69342: ST_TO_ADDR
69343: GO 69290
69345: POP
69346: POP
// end ;
69347: GO 68354
69349: POP
69350: POP
// end ;
69351: LD_VAR 0 1
69355: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
69356: LD_INT 0
69358: PPUSH
69359: PPUSH
69360: PPUSH
69361: PPUSH
69362: PPUSH
69363: PPUSH
69364: PPUSH
69365: PPUSH
69366: PPUSH
69367: PPUSH
// if not mc_bases then
69368: LD_EXP 58
69372: NOT
69373: IFFALSE 69377
// exit ;
69375: GO 71108
// for i = 1 to mc_bases do
69377: LD_ADDR_VAR 0 2
69381: PUSH
69382: DOUBLE
69383: LD_INT 1
69385: DEC
69386: ST_TO_ADDR
69387: LD_EXP 58
69391: PUSH
69392: FOR_TO
69393: IFFALSE 71106
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
69395: LD_EXP 58
69399: PUSH
69400: LD_VAR 0 2
69404: ARRAY
69405: NOT
69406: PUSH
69407: LD_EXP 65
69411: PUSH
69412: LD_VAR 0 2
69416: ARRAY
69417: OR
69418: IFFALSE 69422
// continue ;
69420: GO 69392
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
69422: LD_EXP 74
69426: PUSH
69427: LD_VAR 0 2
69431: ARRAY
69432: NOT
69433: PUSH
69434: LD_EXP 75
69438: PUSH
69439: LD_VAR 0 2
69443: ARRAY
69444: AND
69445: IFFALSE 69483
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
69447: LD_ADDR_EXP 75
69451: PUSH
69452: LD_EXP 75
69456: PPUSH
69457: LD_VAR 0 2
69461: PPUSH
69462: EMPTY
69463: PPUSH
69464: CALL_OW 1
69468: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
69469: LD_VAR 0 2
69473: PPUSH
69474: LD_INT 107
69476: PPUSH
69477: CALL 60572 0 2
// continue ;
69481: GO 69392
// end ; target := [ ] ;
69483: LD_ADDR_VAR 0 6
69487: PUSH
69488: EMPTY
69489: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
69490: LD_ADDR_VAR 0 3
69494: PUSH
69495: DOUBLE
69496: LD_EXP 74
69500: PUSH
69501: LD_VAR 0 2
69505: ARRAY
69506: INC
69507: ST_TO_ADDR
69508: LD_INT 1
69510: PUSH
69511: FOR_DOWNTO
69512: IFFALSE 69772
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
69514: LD_EXP 74
69518: PUSH
69519: LD_VAR 0 2
69523: ARRAY
69524: PUSH
69525: LD_VAR 0 3
69529: ARRAY
69530: PUSH
69531: LD_INT 2
69533: ARRAY
69534: PPUSH
69535: LD_EXP 74
69539: PUSH
69540: LD_VAR 0 2
69544: ARRAY
69545: PUSH
69546: LD_VAR 0 3
69550: ARRAY
69551: PUSH
69552: LD_INT 3
69554: ARRAY
69555: PPUSH
69556: CALL_OW 488
69560: PUSH
69561: LD_EXP 74
69565: PUSH
69566: LD_VAR 0 2
69570: ARRAY
69571: PUSH
69572: LD_VAR 0 3
69576: ARRAY
69577: PUSH
69578: LD_INT 2
69580: ARRAY
69581: PPUSH
69582: LD_EXP 74
69586: PUSH
69587: LD_VAR 0 2
69591: ARRAY
69592: PUSH
69593: LD_VAR 0 3
69597: ARRAY
69598: PUSH
69599: LD_INT 3
69601: ARRAY
69602: PPUSH
69603: CALL_OW 284
69607: PUSH
69608: LD_INT 0
69610: EQUAL
69611: AND
69612: IFFALSE 69667
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
69614: LD_ADDR_VAR 0 5
69618: PUSH
69619: LD_EXP 74
69623: PUSH
69624: LD_VAR 0 2
69628: ARRAY
69629: PPUSH
69630: LD_VAR 0 3
69634: PPUSH
69635: CALL_OW 3
69639: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
69640: LD_ADDR_EXP 74
69644: PUSH
69645: LD_EXP 74
69649: PPUSH
69650: LD_VAR 0 2
69654: PPUSH
69655: LD_VAR 0 5
69659: PPUSH
69660: CALL_OW 1
69664: ST_TO_ADDR
// continue ;
69665: GO 69511
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
69667: LD_EXP 58
69671: PUSH
69672: LD_VAR 0 2
69676: ARRAY
69677: PUSH
69678: LD_INT 1
69680: ARRAY
69681: PPUSH
69682: CALL_OW 255
69686: PPUSH
69687: LD_EXP 74
69691: PUSH
69692: LD_VAR 0 2
69696: ARRAY
69697: PUSH
69698: LD_VAR 0 3
69702: ARRAY
69703: PUSH
69704: LD_INT 2
69706: ARRAY
69707: PPUSH
69708: LD_EXP 74
69712: PUSH
69713: LD_VAR 0 2
69717: ARRAY
69718: PUSH
69719: LD_VAR 0 3
69723: ARRAY
69724: PUSH
69725: LD_INT 3
69727: ARRAY
69728: PPUSH
69729: LD_INT 30
69731: PPUSH
69732: CALL 21550 0 4
69736: PUSH
69737: LD_INT 4
69739: ARRAY
69740: PUSH
69741: LD_INT 0
69743: EQUAL
69744: IFFALSE 69770
// begin target := mc_crates [ i ] [ j ] ;
69746: LD_ADDR_VAR 0 6
69750: PUSH
69751: LD_EXP 74
69755: PUSH
69756: LD_VAR 0 2
69760: ARRAY
69761: PUSH
69762: LD_VAR 0 3
69766: ARRAY
69767: ST_TO_ADDR
// break ;
69768: GO 69772
// end ; end ;
69770: GO 69511
69772: POP
69773: POP
// if not target then
69774: LD_VAR 0 6
69778: NOT
69779: IFFALSE 69783
// continue ;
69781: GO 69392
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
69783: LD_ADDR_VAR 0 7
69787: PUSH
69788: LD_EXP 77
69792: PUSH
69793: LD_VAR 0 2
69797: ARRAY
69798: PPUSH
69799: LD_INT 2
69801: PUSH
69802: LD_INT 3
69804: PUSH
69805: LD_INT 58
69807: PUSH
69808: EMPTY
69809: LIST
69810: PUSH
69811: EMPTY
69812: LIST
69813: LIST
69814: PUSH
69815: LD_INT 61
69817: PUSH
69818: EMPTY
69819: LIST
69820: PUSH
69821: LD_INT 33
69823: PUSH
69824: LD_INT 5
69826: PUSH
69827: EMPTY
69828: LIST
69829: LIST
69830: PUSH
69831: LD_INT 33
69833: PUSH
69834: LD_INT 3
69836: PUSH
69837: EMPTY
69838: LIST
69839: LIST
69840: PUSH
69841: EMPTY
69842: LIST
69843: LIST
69844: LIST
69845: LIST
69846: LIST
69847: PUSH
69848: LD_INT 2
69850: PUSH
69851: LD_INT 34
69853: PUSH
69854: LD_INT 32
69856: PUSH
69857: EMPTY
69858: LIST
69859: LIST
69860: PUSH
69861: LD_INT 34
69863: PUSH
69864: LD_INT 51
69866: PUSH
69867: EMPTY
69868: LIST
69869: LIST
69870: PUSH
69871: LD_INT 34
69873: PUSH
69874: LD_INT 12
69876: PUSH
69877: EMPTY
69878: LIST
69879: LIST
69880: PUSH
69881: EMPTY
69882: LIST
69883: LIST
69884: LIST
69885: LIST
69886: PUSH
69887: EMPTY
69888: LIST
69889: LIST
69890: PPUSH
69891: CALL_OW 72
69895: ST_TO_ADDR
// if not cargo then
69896: LD_VAR 0 7
69900: NOT
69901: IFFALSE 70544
// begin if mc_crates_collector [ i ] < 5 then
69903: LD_EXP 75
69907: PUSH
69908: LD_VAR 0 2
69912: ARRAY
69913: PUSH
69914: LD_INT 5
69916: LESS
69917: IFFALSE 70283
// begin if mc_ape [ i ] then
69919: LD_EXP 87
69923: PUSH
69924: LD_VAR 0 2
69928: ARRAY
69929: IFFALSE 69976
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
69931: LD_ADDR_VAR 0 5
69935: PUSH
69936: LD_EXP 87
69940: PUSH
69941: LD_VAR 0 2
69945: ARRAY
69946: PPUSH
69947: LD_INT 25
69949: PUSH
69950: LD_INT 16
69952: PUSH
69953: EMPTY
69954: LIST
69955: LIST
69956: PUSH
69957: LD_INT 24
69959: PUSH
69960: LD_INT 750
69962: PUSH
69963: EMPTY
69964: LIST
69965: LIST
69966: PUSH
69967: EMPTY
69968: LIST
69969: LIST
69970: PPUSH
69971: CALL_OW 72
69975: ST_TO_ADDR
// if not tmp then
69976: LD_VAR 0 5
69980: NOT
69981: IFFALSE 70028
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
69983: LD_ADDR_VAR 0 5
69987: PUSH
69988: LD_EXP 58
69992: PUSH
69993: LD_VAR 0 2
69997: ARRAY
69998: PPUSH
69999: LD_INT 25
70001: PUSH
70002: LD_INT 2
70004: PUSH
70005: EMPTY
70006: LIST
70007: LIST
70008: PUSH
70009: LD_INT 24
70011: PUSH
70012: LD_INT 750
70014: PUSH
70015: EMPTY
70016: LIST
70017: LIST
70018: PUSH
70019: EMPTY
70020: LIST
70021: LIST
70022: PPUSH
70023: CALL_OW 72
70027: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
70028: LD_EXP 87
70032: PUSH
70033: LD_VAR 0 2
70037: ARRAY
70038: PUSH
70039: LD_EXP 58
70043: PUSH
70044: LD_VAR 0 2
70048: ARRAY
70049: PPUSH
70050: LD_INT 25
70052: PUSH
70053: LD_INT 2
70055: PUSH
70056: EMPTY
70057: LIST
70058: LIST
70059: PUSH
70060: LD_INT 24
70062: PUSH
70063: LD_INT 750
70065: PUSH
70066: EMPTY
70067: LIST
70068: LIST
70069: PUSH
70070: EMPTY
70071: LIST
70072: LIST
70073: PPUSH
70074: CALL_OW 72
70078: AND
70079: PUSH
70080: LD_VAR 0 5
70084: PUSH
70085: LD_INT 5
70087: LESS
70088: AND
70089: IFFALSE 70171
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
70091: LD_ADDR_VAR 0 3
70095: PUSH
70096: LD_EXP 58
70100: PUSH
70101: LD_VAR 0 2
70105: ARRAY
70106: PPUSH
70107: LD_INT 25
70109: PUSH
70110: LD_INT 2
70112: PUSH
70113: EMPTY
70114: LIST
70115: LIST
70116: PUSH
70117: LD_INT 24
70119: PUSH
70120: LD_INT 750
70122: PUSH
70123: EMPTY
70124: LIST
70125: LIST
70126: PUSH
70127: EMPTY
70128: LIST
70129: LIST
70130: PPUSH
70131: CALL_OW 72
70135: PUSH
70136: FOR_IN
70137: IFFALSE 70169
// begin tmp := tmp union j ;
70139: LD_ADDR_VAR 0 5
70143: PUSH
70144: LD_VAR 0 5
70148: PUSH
70149: LD_VAR 0 3
70153: UNION
70154: ST_TO_ADDR
// if tmp >= 5 then
70155: LD_VAR 0 5
70159: PUSH
70160: LD_INT 5
70162: GREATEREQUAL
70163: IFFALSE 70167
// break ;
70165: GO 70169
// end ;
70167: GO 70136
70169: POP
70170: POP
// end ; if not tmp then
70171: LD_VAR 0 5
70175: NOT
70176: IFFALSE 70180
// continue ;
70178: GO 69392
// for j in tmp do
70180: LD_ADDR_VAR 0 3
70184: PUSH
70185: LD_VAR 0 5
70189: PUSH
70190: FOR_IN
70191: IFFALSE 70281
// if not GetTag ( j ) then
70193: LD_VAR 0 3
70197: PPUSH
70198: CALL_OW 110
70202: NOT
70203: IFFALSE 70279
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
70205: LD_ADDR_EXP 75
70209: PUSH
70210: LD_EXP 75
70214: PPUSH
70215: LD_VAR 0 2
70219: PUSH
70220: LD_EXP 75
70224: PUSH
70225: LD_VAR 0 2
70229: ARRAY
70230: PUSH
70231: LD_INT 1
70233: PLUS
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: PPUSH
70239: LD_VAR 0 3
70243: PPUSH
70244: CALL 20654 0 3
70248: ST_TO_ADDR
// SetTag ( j , 107 ) ;
70249: LD_VAR 0 3
70253: PPUSH
70254: LD_INT 107
70256: PPUSH
70257: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
70261: LD_EXP 75
70265: PUSH
70266: LD_VAR 0 2
70270: ARRAY
70271: PUSH
70272: LD_INT 5
70274: GREATEREQUAL
70275: IFFALSE 70279
// break ;
70277: GO 70281
// end ;
70279: GO 70190
70281: POP
70282: POP
// end ; if mc_crates_collector [ i ] and target then
70283: LD_EXP 75
70287: PUSH
70288: LD_VAR 0 2
70292: ARRAY
70293: PUSH
70294: LD_VAR 0 6
70298: AND
70299: IFFALSE 70542
// begin if mc_crates_collector [ i ] < target [ 1 ] then
70301: LD_EXP 75
70305: PUSH
70306: LD_VAR 0 2
70310: ARRAY
70311: PUSH
70312: LD_VAR 0 6
70316: PUSH
70317: LD_INT 1
70319: ARRAY
70320: LESS
70321: IFFALSE 70341
// tmp := mc_crates_collector [ i ] else
70323: LD_ADDR_VAR 0 5
70327: PUSH
70328: LD_EXP 75
70332: PUSH
70333: LD_VAR 0 2
70337: ARRAY
70338: ST_TO_ADDR
70339: GO 70355
// tmp := target [ 1 ] ;
70341: LD_ADDR_VAR 0 5
70345: PUSH
70346: LD_VAR 0 6
70350: PUSH
70351: LD_INT 1
70353: ARRAY
70354: ST_TO_ADDR
// k := 0 ;
70355: LD_ADDR_VAR 0 4
70359: PUSH
70360: LD_INT 0
70362: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
70363: LD_ADDR_VAR 0 3
70367: PUSH
70368: LD_EXP 75
70372: PUSH
70373: LD_VAR 0 2
70377: ARRAY
70378: PUSH
70379: FOR_IN
70380: IFFALSE 70540
// begin k := k + 1 ;
70382: LD_ADDR_VAR 0 4
70386: PUSH
70387: LD_VAR 0 4
70391: PUSH
70392: LD_INT 1
70394: PLUS
70395: ST_TO_ADDR
// if k > tmp then
70396: LD_VAR 0 4
70400: PUSH
70401: LD_VAR 0 5
70405: GREATER
70406: IFFALSE 70410
// break ;
70408: GO 70540
// if not GetClass ( j ) in [ 2 , 16 ] then
70410: LD_VAR 0 3
70414: PPUSH
70415: CALL_OW 257
70419: PUSH
70420: LD_INT 2
70422: PUSH
70423: LD_INT 16
70425: PUSH
70426: EMPTY
70427: LIST
70428: LIST
70429: IN
70430: NOT
70431: IFFALSE 70484
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
70433: LD_ADDR_EXP 75
70437: PUSH
70438: LD_EXP 75
70442: PPUSH
70443: LD_VAR 0 2
70447: PPUSH
70448: LD_EXP 75
70452: PUSH
70453: LD_VAR 0 2
70457: ARRAY
70458: PUSH
70459: LD_VAR 0 3
70463: DIFF
70464: PPUSH
70465: CALL_OW 1
70469: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70470: LD_VAR 0 3
70474: PPUSH
70475: LD_INT 0
70477: PPUSH
70478: CALL_OW 109
// continue ;
70482: GO 70379
// end ; if IsInUnit ( j ) then
70484: LD_VAR 0 3
70488: PPUSH
70489: CALL_OW 310
70493: IFFALSE 70504
// ComExitBuilding ( j ) ;
70495: LD_VAR 0 3
70499: PPUSH
70500: CALL_OW 122
// wait ( 3 ) ;
70504: LD_INT 3
70506: PPUSH
70507: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
70511: LD_VAR 0 3
70515: PPUSH
70516: LD_VAR 0 6
70520: PUSH
70521: LD_INT 2
70523: ARRAY
70524: PPUSH
70525: LD_VAR 0 6
70529: PUSH
70530: LD_INT 3
70532: ARRAY
70533: PPUSH
70534: CALL_OW 117
// end ;
70538: GO 70379
70540: POP
70541: POP
// end ; end else
70542: GO 71104
// begin for j in cargo do
70544: LD_ADDR_VAR 0 3
70548: PUSH
70549: LD_VAR 0 7
70553: PUSH
70554: FOR_IN
70555: IFFALSE 71102
// begin if GetTag ( j ) <> 0 then
70557: LD_VAR 0 3
70561: PPUSH
70562: CALL_OW 110
70566: PUSH
70567: LD_INT 0
70569: NONEQUAL
70570: IFFALSE 70574
// continue ;
70572: GO 70554
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
70574: LD_VAR 0 3
70578: PPUSH
70579: CALL_OW 256
70583: PUSH
70584: LD_INT 1000
70586: LESS
70587: PUSH
70588: LD_VAR 0 3
70592: PPUSH
70593: LD_EXP 82
70597: PUSH
70598: LD_VAR 0 2
70602: ARRAY
70603: PPUSH
70604: CALL_OW 308
70608: NOT
70609: AND
70610: IFFALSE 70632
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70612: LD_VAR 0 3
70616: PPUSH
70617: LD_EXP 82
70621: PUSH
70622: LD_VAR 0 2
70626: ARRAY
70627: PPUSH
70628: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
70632: LD_VAR 0 3
70636: PPUSH
70637: CALL_OW 256
70641: PUSH
70642: LD_INT 1000
70644: LESS
70645: PUSH
70646: LD_VAR 0 3
70650: PPUSH
70651: LD_EXP 82
70655: PUSH
70656: LD_VAR 0 2
70660: ARRAY
70661: PPUSH
70662: CALL_OW 308
70666: AND
70667: IFFALSE 70671
// continue ;
70669: GO 70554
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
70671: LD_VAR 0 3
70675: PPUSH
70676: CALL_OW 262
70680: PUSH
70681: LD_INT 2
70683: EQUAL
70684: PUSH
70685: LD_VAR 0 3
70689: PPUSH
70690: CALL_OW 261
70694: PUSH
70695: LD_INT 15
70697: LESS
70698: AND
70699: IFFALSE 70703
// continue ;
70701: GO 70554
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
70703: LD_VAR 0 3
70707: PPUSH
70708: CALL_OW 262
70712: PUSH
70713: LD_INT 1
70715: EQUAL
70716: PUSH
70717: LD_VAR 0 3
70721: PPUSH
70722: CALL_OW 261
70726: PUSH
70727: LD_INT 10
70729: LESS
70730: AND
70731: IFFALSE 71041
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70733: LD_ADDR_VAR 0 8
70737: PUSH
70738: LD_EXP 58
70742: PUSH
70743: LD_VAR 0 2
70747: ARRAY
70748: PPUSH
70749: LD_INT 2
70751: PUSH
70752: LD_INT 30
70754: PUSH
70755: LD_INT 0
70757: PUSH
70758: EMPTY
70759: LIST
70760: LIST
70761: PUSH
70762: LD_INT 30
70764: PUSH
70765: LD_INT 1
70767: PUSH
70768: EMPTY
70769: LIST
70770: LIST
70771: PUSH
70772: EMPTY
70773: LIST
70774: LIST
70775: LIST
70776: PPUSH
70777: CALL_OW 72
70781: ST_TO_ADDR
// if not depot then
70782: LD_VAR 0 8
70786: NOT
70787: IFFALSE 70791
// continue ;
70789: GO 70554
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
70791: LD_VAR 0 3
70795: PPUSH
70796: LD_VAR 0 8
70800: PPUSH
70801: LD_VAR 0 3
70805: PPUSH
70806: CALL_OW 74
70810: PPUSH
70811: CALL_OW 296
70815: PUSH
70816: LD_INT 6
70818: LESS
70819: IFFALSE 70835
// SetFuel ( j , 100 ) else
70821: LD_VAR 0 3
70825: PPUSH
70826: LD_INT 100
70828: PPUSH
70829: CALL_OW 240
70833: GO 71041
// if GetFuel ( j ) = 0 then
70835: LD_VAR 0 3
70839: PPUSH
70840: CALL_OW 261
70844: PUSH
70845: LD_INT 0
70847: EQUAL
70848: IFFALSE 71041
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
70850: LD_ADDR_EXP 77
70854: PUSH
70855: LD_EXP 77
70859: PPUSH
70860: LD_VAR 0 2
70864: PPUSH
70865: LD_EXP 77
70869: PUSH
70870: LD_VAR 0 2
70874: ARRAY
70875: PUSH
70876: LD_VAR 0 3
70880: DIFF
70881: PPUSH
70882: CALL_OW 1
70886: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
70887: LD_VAR 0 3
70891: PPUSH
70892: CALL_OW 263
70896: PUSH
70897: LD_INT 1
70899: EQUAL
70900: IFFALSE 70916
// ComExitVehicle ( IsInUnit ( j ) ) ;
70902: LD_VAR 0 3
70906: PPUSH
70907: CALL_OW 310
70911: PPUSH
70912: CALL_OW 121
// if GetControl ( j ) = control_remote then
70916: LD_VAR 0 3
70920: PPUSH
70921: CALL_OW 263
70925: PUSH
70926: LD_INT 2
70928: EQUAL
70929: IFFALSE 70940
// ComUnlink ( j ) ;
70931: LD_VAR 0 3
70935: PPUSH
70936: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
70940: LD_ADDR_VAR 0 9
70944: PUSH
70945: LD_VAR 0 2
70949: PPUSH
70950: LD_INT 3
70952: PPUSH
70953: CALL 80087 0 2
70957: ST_TO_ADDR
// if fac then
70958: LD_VAR 0 9
70962: IFFALSE 71039
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
70964: LD_ADDR_VAR 0 10
70968: PUSH
70969: LD_VAR 0 9
70973: PPUSH
70974: LD_VAR 0 3
70978: PPUSH
70979: CALL_OW 265
70983: PPUSH
70984: LD_VAR 0 3
70988: PPUSH
70989: CALL_OW 262
70993: PPUSH
70994: LD_VAR 0 3
70998: PPUSH
70999: CALL_OW 263
71003: PPUSH
71004: LD_VAR 0 3
71008: PPUSH
71009: CALL_OW 264
71013: PPUSH
71014: CALL 18247 0 5
71018: ST_TO_ADDR
// if components then
71019: LD_VAR 0 10
71023: IFFALSE 71039
// MC_InsertProduceList ( i , components ) ;
71025: LD_VAR 0 2
71029: PPUSH
71030: LD_VAR 0 10
71034: PPUSH
71035: CALL 79715 0 2
// end ; continue ;
71039: GO 70554
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
71041: LD_VAR 0 3
71045: PPUSH
71046: LD_INT 1
71048: PPUSH
71049: CALL_OW 289
71053: PUSH
71054: LD_INT 100
71056: LESS
71057: PUSH
71058: LD_VAR 0 3
71062: PPUSH
71063: CALL_OW 314
71067: NOT
71068: AND
71069: IFFALSE 71098
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71071: LD_VAR 0 3
71075: PPUSH
71076: LD_VAR 0 6
71080: PUSH
71081: LD_INT 2
71083: ARRAY
71084: PPUSH
71085: LD_VAR 0 6
71089: PUSH
71090: LD_INT 3
71092: ARRAY
71093: PPUSH
71094: CALL_OW 117
// break ;
71098: GO 71102
// end ;
71100: GO 70554
71102: POP
71103: POP
// end ; end ;
71104: GO 69392
71106: POP
71107: POP
// end ;
71108: LD_VAR 0 1
71112: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
71113: LD_INT 0
71115: PPUSH
71116: PPUSH
71117: PPUSH
71118: PPUSH
// if not mc_bases then
71119: LD_EXP 58
71123: NOT
71124: IFFALSE 71128
// exit ;
71126: GO 71289
// for i = 1 to mc_bases do
71128: LD_ADDR_VAR 0 2
71132: PUSH
71133: DOUBLE
71134: LD_INT 1
71136: DEC
71137: ST_TO_ADDR
71138: LD_EXP 58
71142: PUSH
71143: FOR_TO
71144: IFFALSE 71287
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
71146: LD_ADDR_VAR 0 4
71150: PUSH
71151: LD_EXP 77
71155: PUSH
71156: LD_VAR 0 2
71160: ARRAY
71161: PUSH
71162: LD_EXP 80
71166: PUSH
71167: LD_VAR 0 2
71171: ARRAY
71172: UNION
71173: PPUSH
71174: LD_INT 33
71176: PUSH
71177: LD_INT 2
71179: PUSH
71180: EMPTY
71181: LIST
71182: LIST
71183: PPUSH
71184: CALL_OW 72
71188: ST_TO_ADDR
// if tmp then
71189: LD_VAR 0 4
71193: IFFALSE 71285
// for j in tmp do
71195: LD_ADDR_VAR 0 3
71199: PUSH
71200: LD_VAR 0 4
71204: PUSH
71205: FOR_IN
71206: IFFALSE 71283
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
71208: LD_VAR 0 3
71212: PPUSH
71213: CALL_OW 312
71217: NOT
71218: PUSH
71219: LD_VAR 0 3
71223: PPUSH
71224: CALL_OW 256
71228: PUSH
71229: LD_INT 250
71231: GREATEREQUAL
71232: AND
71233: IFFALSE 71246
// Connect ( j ) else
71235: LD_VAR 0 3
71239: PPUSH
71240: CALL 23587 0 1
71244: GO 71281
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
71246: LD_VAR 0 3
71250: PPUSH
71251: CALL_OW 256
71255: PUSH
71256: LD_INT 250
71258: LESS
71259: PUSH
71260: LD_VAR 0 3
71264: PPUSH
71265: CALL_OW 312
71269: AND
71270: IFFALSE 71281
// ComUnlink ( j ) ;
71272: LD_VAR 0 3
71276: PPUSH
71277: CALL_OW 136
71281: GO 71205
71283: POP
71284: POP
// end ;
71285: GO 71143
71287: POP
71288: POP
// end ;
71289: LD_VAR 0 1
71293: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
71294: LD_INT 0
71296: PPUSH
71297: PPUSH
71298: PPUSH
71299: PPUSH
71300: PPUSH
// if not mc_bases then
71301: LD_EXP 58
71305: NOT
71306: IFFALSE 71310
// exit ;
71308: GO 71770
// for i = 1 to mc_bases do
71310: LD_ADDR_VAR 0 2
71314: PUSH
71315: DOUBLE
71316: LD_INT 1
71318: DEC
71319: ST_TO_ADDR
71320: LD_EXP 58
71324: PUSH
71325: FOR_TO
71326: IFFALSE 71768
// begin if not mc_produce [ i ] then
71328: LD_EXP 79
71332: PUSH
71333: LD_VAR 0 2
71337: ARRAY
71338: NOT
71339: IFFALSE 71343
// continue ;
71341: GO 71325
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71343: LD_ADDR_VAR 0 5
71347: PUSH
71348: LD_EXP 58
71352: PUSH
71353: LD_VAR 0 2
71357: ARRAY
71358: PPUSH
71359: LD_INT 30
71361: PUSH
71362: LD_INT 3
71364: PUSH
71365: EMPTY
71366: LIST
71367: LIST
71368: PPUSH
71369: CALL_OW 72
71373: ST_TO_ADDR
// if not fac then
71374: LD_VAR 0 5
71378: NOT
71379: IFFALSE 71383
// continue ;
71381: GO 71325
// for j in fac do
71383: LD_ADDR_VAR 0 3
71387: PUSH
71388: LD_VAR 0 5
71392: PUSH
71393: FOR_IN
71394: IFFALSE 71764
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
71396: LD_VAR 0 3
71400: PPUSH
71401: CALL_OW 461
71405: PUSH
71406: LD_INT 2
71408: NONEQUAL
71409: PUSH
71410: LD_VAR 0 3
71414: PPUSH
71415: LD_INT 15
71417: PPUSH
71418: CALL 23247 0 2
71422: PUSH
71423: LD_INT 4
71425: ARRAY
71426: OR
71427: PUSH
71428: LD_VAR 0 3
71432: PPUSH
71433: CALL_OW 313
71437: PUSH
71438: LD_INT 0
71440: EQUAL
71441: OR
71442: IFFALSE 71446
// continue ;
71444: GO 71393
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
71446: LD_VAR 0 3
71450: PPUSH
71451: LD_EXP 79
71455: PUSH
71456: LD_VAR 0 2
71460: ARRAY
71461: PUSH
71462: LD_INT 1
71464: ARRAY
71465: PUSH
71466: LD_INT 1
71468: ARRAY
71469: PPUSH
71470: LD_EXP 79
71474: PUSH
71475: LD_VAR 0 2
71479: ARRAY
71480: PUSH
71481: LD_INT 1
71483: ARRAY
71484: PUSH
71485: LD_INT 2
71487: ARRAY
71488: PPUSH
71489: LD_EXP 79
71493: PUSH
71494: LD_VAR 0 2
71498: ARRAY
71499: PUSH
71500: LD_INT 1
71502: ARRAY
71503: PUSH
71504: LD_INT 3
71506: ARRAY
71507: PPUSH
71508: LD_EXP 79
71512: PUSH
71513: LD_VAR 0 2
71517: ARRAY
71518: PUSH
71519: LD_INT 1
71521: ARRAY
71522: PUSH
71523: LD_INT 4
71525: ARRAY
71526: PPUSH
71527: CALL_OW 448
71531: PUSH
71532: LD_VAR 0 3
71536: PPUSH
71537: LD_EXP 79
71541: PUSH
71542: LD_VAR 0 2
71546: ARRAY
71547: PUSH
71548: LD_INT 1
71550: ARRAY
71551: PUSH
71552: LD_INT 1
71554: ARRAY
71555: PUSH
71556: LD_EXP 79
71560: PUSH
71561: LD_VAR 0 2
71565: ARRAY
71566: PUSH
71567: LD_INT 1
71569: ARRAY
71570: PUSH
71571: LD_INT 2
71573: ARRAY
71574: PUSH
71575: LD_EXP 79
71579: PUSH
71580: LD_VAR 0 2
71584: ARRAY
71585: PUSH
71586: LD_INT 1
71588: ARRAY
71589: PUSH
71590: LD_INT 3
71592: ARRAY
71593: PUSH
71594: LD_EXP 79
71598: PUSH
71599: LD_VAR 0 2
71603: ARRAY
71604: PUSH
71605: LD_INT 1
71607: ARRAY
71608: PUSH
71609: LD_INT 4
71611: ARRAY
71612: PUSH
71613: EMPTY
71614: LIST
71615: LIST
71616: LIST
71617: LIST
71618: PPUSH
71619: CALL 26918 0 2
71623: AND
71624: IFFALSE 71762
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
71626: LD_VAR 0 3
71630: PPUSH
71631: LD_EXP 79
71635: PUSH
71636: LD_VAR 0 2
71640: ARRAY
71641: PUSH
71642: LD_INT 1
71644: ARRAY
71645: PUSH
71646: LD_INT 1
71648: ARRAY
71649: PPUSH
71650: LD_EXP 79
71654: PUSH
71655: LD_VAR 0 2
71659: ARRAY
71660: PUSH
71661: LD_INT 1
71663: ARRAY
71664: PUSH
71665: LD_INT 2
71667: ARRAY
71668: PPUSH
71669: LD_EXP 79
71673: PUSH
71674: LD_VAR 0 2
71678: ARRAY
71679: PUSH
71680: LD_INT 1
71682: ARRAY
71683: PUSH
71684: LD_INT 3
71686: ARRAY
71687: PPUSH
71688: LD_EXP 79
71692: PUSH
71693: LD_VAR 0 2
71697: ARRAY
71698: PUSH
71699: LD_INT 1
71701: ARRAY
71702: PUSH
71703: LD_INT 4
71705: ARRAY
71706: PPUSH
71707: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
71711: LD_ADDR_VAR 0 4
71715: PUSH
71716: LD_EXP 79
71720: PUSH
71721: LD_VAR 0 2
71725: ARRAY
71726: PPUSH
71727: LD_INT 1
71729: PPUSH
71730: CALL_OW 3
71734: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
71735: LD_ADDR_EXP 79
71739: PUSH
71740: LD_EXP 79
71744: PPUSH
71745: LD_VAR 0 2
71749: PPUSH
71750: LD_VAR 0 4
71754: PPUSH
71755: CALL_OW 1
71759: ST_TO_ADDR
// break ;
71760: GO 71764
// end ; end ;
71762: GO 71393
71764: POP
71765: POP
// end ;
71766: GO 71325
71768: POP
71769: POP
// end ;
71770: LD_VAR 0 1
71774: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
71775: LD_INT 0
71777: PPUSH
71778: PPUSH
71779: PPUSH
// if not mc_bases then
71780: LD_EXP 58
71784: NOT
71785: IFFALSE 71789
// exit ;
71787: GO 71878
// for i = 1 to mc_bases do
71789: LD_ADDR_VAR 0 2
71793: PUSH
71794: DOUBLE
71795: LD_INT 1
71797: DEC
71798: ST_TO_ADDR
71799: LD_EXP 58
71803: PUSH
71804: FOR_TO
71805: IFFALSE 71876
// begin if mc_attack [ i ] then
71807: LD_EXP 78
71811: PUSH
71812: LD_VAR 0 2
71816: ARRAY
71817: IFFALSE 71874
// begin tmp := mc_attack [ i ] [ 1 ] ;
71819: LD_ADDR_VAR 0 3
71823: PUSH
71824: LD_EXP 78
71828: PUSH
71829: LD_VAR 0 2
71833: ARRAY
71834: PUSH
71835: LD_INT 1
71837: ARRAY
71838: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
71839: LD_ADDR_EXP 78
71843: PUSH
71844: LD_EXP 78
71848: PPUSH
71849: LD_VAR 0 2
71853: PPUSH
71854: EMPTY
71855: PPUSH
71856: CALL_OW 1
71860: ST_TO_ADDR
// Attack ( tmp ) ;
71861: LD_VAR 0 3
71865: PPUSH
71866: CALL 49131 0 1
// exit ;
71870: POP
71871: POP
71872: GO 71878
// end ; end ;
71874: GO 71804
71876: POP
71877: POP
// end ;
71878: LD_VAR 0 1
71882: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
71883: LD_INT 0
71885: PPUSH
71886: PPUSH
71887: PPUSH
71888: PPUSH
71889: PPUSH
71890: PPUSH
71891: PPUSH
// if not mc_bases then
71892: LD_EXP 58
71896: NOT
71897: IFFALSE 71901
// exit ;
71899: GO 72483
// for i = 1 to mc_bases do
71901: LD_ADDR_VAR 0 2
71905: PUSH
71906: DOUBLE
71907: LD_INT 1
71909: DEC
71910: ST_TO_ADDR
71911: LD_EXP 58
71915: PUSH
71916: FOR_TO
71917: IFFALSE 72481
// begin if not mc_bases [ i ] then
71919: LD_EXP 58
71923: PUSH
71924: LD_VAR 0 2
71928: ARRAY
71929: NOT
71930: IFFALSE 71934
// continue ;
71932: GO 71916
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
71934: LD_ADDR_VAR 0 7
71938: PUSH
71939: LD_EXP 58
71943: PUSH
71944: LD_VAR 0 2
71948: ARRAY
71949: PUSH
71950: LD_INT 1
71952: ARRAY
71953: PPUSH
71954: CALL 17551 0 1
71958: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
71959: LD_ADDR_EXP 81
71963: PUSH
71964: LD_EXP 81
71968: PPUSH
71969: LD_VAR 0 2
71973: PPUSH
71974: LD_EXP 58
71978: PUSH
71979: LD_VAR 0 2
71983: ARRAY
71984: PUSH
71985: LD_INT 1
71987: ARRAY
71988: PPUSH
71989: CALL_OW 255
71993: PPUSH
71994: LD_EXP 83
71998: PUSH
71999: LD_VAR 0 2
72003: ARRAY
72004: PPUSH
72005: CALL 15548 0 2
72009: PPUSH
72010: CALL_OW 1
72014: ST_TO_ADDR
// if not mc_scan [ i ] then
72015: LD_EXP 81
72019: PUSH
72020: LD_VAR 0 2
72024: ARRAY
72025: NOT
72026: IFFALSE 72181
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72028: LD_ADDR_VAR 0 4
72032: PUSH
72033: LD_EXP 58
72037: PUSH
72038: LD_VAR 0 2
72042: ARRAY
72043: PPUSH
72044: LD_INT 2
72046: PUSH
72047: LD_INT 25
72049: PUSH
72050: LD_INT 5
72052: PUSH
72053: EMPTY
72054: LIST
72055: LIST
72056: PUSH
72057: LD_INT 25
72059: PUSH
72060: LD_INT 8
72062: PUSH
72063: EMPTY
72064: LIST
72065: LIST
72066: PUSH
72067: LD_INT 25
72069: PUSH
72070: LD_INT 9
72072: PUSH
72073: EMPTY
72074: LIST
72075: LIST
72076: PUSH
72077: EMPTY
72078: LIST
72079: LIST
72080: LIST
72081: LIST
72082: PPUSH
72083: CALL_OW 72
72087: ST_TO_ADDR
// if not tmp then
72088: LD_VAR 0 4
72092: NOT
72093: IFFALSE 72097
// continue ;
72095: GO 71916
// for j in tmp do
72097: LD_ADDR_VAR 0 3
72101: PUSH
72102: LD_VAR 0 4
72106: PUSH
72107: FOR_IN
72108: IFFALSE 72179
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
72110: LD_VAR 0 3
72114: PPUSH
72115: CALL_OW 310
72119: PPUSH
72120: CALL_OW 266
72124: PUSH
72125: LD_INT 5
72127: EQUAL
72128: PUSH
72129: LD_VAR 0 3
72133: PPUSH
72134: CALL_OW 257
72138: PUSH
72139: LD_INT 1
72141: EQUAL
72142: AND
72143: PUSH
72144: LD_VAR 0 3
72148: PPUSH
72149: CALL_OW 459
72153: NOT
72154: AND
72155: PUSH
72156: LD_VAR 0 7
72160: AND
72161: IFFALSE 72177
// ComChangeProfession ( j , class ) ;
72163: LD_VAR 0 3
72167: PPUSH
72168: LD_VAR 0 7
72172: PPUSH
72173: CALL_OW 123
72177: GO 72107
72179: POP
72180: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
72181: LD_EXP 81
72185: PUSH
72186: LD_VAR 0 2
72190: ARRAY
72191: PUSH
72192: LD_EXP 80
72196: PUSH
72197: LD_VAR 0 2
72201: ARRAY
72202: NOT
72203: AND
72204: PUSH
72205: LD_EXP 58
72209: PUSH
72210: LD_VAR 0 2
72214: ARRAY
72215: PPUSH
72216: LD_INT 30
72218: PUSH
72219: LD_INT 32
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: PPUSH
72226: CALL_OW 72
72230: NOT
72231: AND
72232: PUSH
72233: LD_EXP 58
72237: PUSH
72238: LD_VAR 0 2
72242: ARRAY
72243: PPUSH
72244: LD_INT 2
72246: PUSH
72247: LD_INT 30
72249: PUSH
72250: LD_INT 4
72252: PUSH
72253: EMPTY
72254: LIST
72255: LIST
72256: PUSH
72257: LD_INT 30
72259: PUSH
72260: LD_INT 5
72262: PUSH
72263: EMPTY
72264: LIST
72265: LIST
72266: PUSH
72267: EMPTY
72268: LIST
72269: LIST
72270: LIST
72271: PPUSH
72272: CALL_OW 72
72276: NOT
72277: AND
72278: IFFALSE 72410
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72280: LD_ADDR_VAR 0 4
72284: PUSH
72285: LD_EXP 58
72289: PUSH
72290: LD_VAR 0 2
72294: ARRAY
72295: PPUSH
72296: LD_INT 2
72298: PUSH
72299: LD_INT 25
72301: PUSH
72302: LD_INT 1
72304: PUSH
72305: EMPTY
72306: LIST
72307: LIST
72308: PUSH
72309: LD_INT 25
72311: PUSH
72312: LD_INT 5
72314: PUSH
72315: EMPTY
72316: LIST
72317: LIST
72318: PUSH
72319: LD_INT 25
72321: PUSH
72322: LD_INT 8
72324: PUSH
72325: EMPTY
72326: LIST
72327: LIST
72328: PUSH
72329: LD_INT 25
72331: PUSH
72332: LD_INT 9
72334: PUSH
72335: EMPTY
72336: LIST
72337: LIST
72338: PUSH
72339: EMPTY
72340: LIST
72341: LIST
72342: LIST
72343: LIST
72344: LIST
72345: PPUSH
72346: CALL_OW 72
72350: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
72351: LD_ADDR_VAR 0 4
72355: PUSH
72356: LD_VAR 0 4
72360: PUSH
72361: LD_VAR 0 4
72365: PPUSH
72366: LD_INT 18
72368: PPUSH
72369: CALL 53914 0 2
72373: DIFF
72374: ST_TO_ADDR
// if tmp then
72375: LD_VAR 0 4
72379: IFFALSE 72410
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
72381: LD_VAR 0 2
72385: PPUSH
72386: LD_VAR 0 4
72390: PPUSH
72391: LD_EXP 83
72395: PUSH
72396: LD_VAR 0 2
72400: ARRAY
72401: PPUSH
72402: CALL 15583 0 3
// exit ;
72406: POP
72407: POP
72408: GO 72483
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
72410: LD_EXP 81
72414: PUSH
72415: LD_VAR 0 2
72419: ARRAY
72420: PUSH
72421: LD_EXP 80
72425: PUSH
72426: LD_VAR 0 2
72430: ARRAY
72431: AND
72432: IFFALSE 72479
// begin tmp := mc_defender [ i ] ;
72434: LD_ADDR_VAR 0 4
72438: PUSH
72439: LD_EXP 80
72443: PUSH
72444: LD_VAR 0 2
72448: ARRAY
72449: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
72450: LD_VAR 0 2
72454: PPUSH
72455: LD_VAR 0 4
72459: PPUSH
72460: LD_EXP 81
72464: PUSH
72465: LD_VAR 0 2
72469: ARRAY
72470: PPUSH
72471: CALL 16081 0 3
// exit ;
72475: POP
72476: POP
72477: GO 72483
// end ; end ;
72479: GO 71916
72481: POP
72482: POP
// end ;
72483: LD_VAR 0 1
72487: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
72488: LD_INT 0
72490: PPUSH
72491: PPUSH
72492: PPUSH
72493: PPUSH
72494: PPUSH
72495: PPUSH
72496: PPUSH
72497: PPUSH
72498: PPUSH
72499: PPUSH
72500: PPUSH
// if not mc_bases then
72501: LD_EXP 58
72505: NOT
72506: IFFALSE 72510
// exit ;
72508: GO 73597
// for i = 1 to mc_bases do
72510: LD_ADDR_VAR 0 2
72514: PUSH
72515: DOUBLE
72516: LD_INT 1
72518: DEC
72519: ST_TO_ADDR
72520: LD_EXP 58
72524: PUSH
72525: FOR_TO
72526: IFFALSE 73595
// begin tmp := mc_lab [ i ] ;
72528: LD_ADDR_VAR 0 6
72532: PUSH
72533: LD_EXP 91
72537: PUSH
72538: LD_VAR 0 2
72542: ARRAY
72543: ST_TO_ADDR
// if not tmp then
72544: LD_VAR 0 6
72548: NOT
72549: IFFALSE 72553
// continue ;
72551: GO 72525
// idle_lab := 0 ;
72553: LD_ADDR_VAR 0 11
72557: PUSH
72558: LD_INT 0
72560: ST_TO_ADDR
// for j in tmp do
72561: LD_ADDR_VAR 0 3
72565: PUSH
72566: LD_VAR 0 6
72570: PUSH
72571: FOR_IN
72572: IFFALSE 73591
// begin researching := false ;
72574: LD_ADDR_VAR 0 10
72578: PUSH
72579: LD_INT 0
72581: ST_TO_ADDR
// side := GetSide ( j ) ;
72582: LD_ADDR_VAR 0 4
72586: PUSH
72587: LD_VAR 0 3
72591: PPUSH
72592: CALL_OW 255
72596: ST_TO_ADDR
// if not mc_tech [ side ] then
72597: LD_EXP 85
72601: PUSH
72602: LD_VAR 0 4
72606: ARRAY
72607: NOT
72608: IFFALSE 72612
// continue ;
72610: GO 72571
// if BuildingStatus ( j ) = bs_idle then
72612: LD_VAR 0 3
72616: PPUSH
72617: CALL_OW 461
72621: PUSH
72622: LD_INT 2
72624: EQUAL
72625: IFFALSE 72813
// begin if idle_lab and UnitsInside ( j ) < 6 then
72627: LD_VAR 0 11
72631: PUSH
72632: LD_VAR 0 3
72636: PPUSH
72637: CALL_OW 313
72641: PUSH
72642: LD_INT 6
72644: LESS
72645: AND
72646: IFFALSE 72717
// begin tmp2 := UnitsInside ( idle_lab ) ;
72648: LD_ADDR_VAR 0 9
72652: PUSH
72653: LD_VAR 0 11
72657: PPUSH
72658: CALL_OW 313
72662: ST_TO_ADDR
// if tmp2 then
72663: LD_VAR 0 9
72667: IFFALSE 72709
// for x in tmp2 do
72669: LD_ADDR_VAR 0 7
72673: PUSH
72674: LD_VAR 0 9
72678: PUSH
72679: FOR_IN
72680: IFFALSE 72707
// begin ComExitBuilding ( x ) ;
72682: LD_VAR 0 7
72686: PPUSH
72687: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72691: LD_VAR 0 7
72695: PPUSH
72696: LD_VAR 0 3
72700: PPUSH
72701: CALL_OW 180
// end ;
72705: GO 72679
72707: POP
72708: POP
// idle_lab := 0 ;
72709: LD_ADDR_VAR 0 11
72713: PUSH
72714: LD_INT 0
72716: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
72717: LD_ADDR_VAR 0 5
72721: PUSH
72722: LD_EXP 85
72726: PUSH
72727: LD_VAR 0 4
72731: ARRAY
72732: PUSH
72733: FOR_IN
72734: IFFALSE 72794
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
72736: LD_VAR 0 3
72740: PPUSH
72741: LD_VAR 0 5
72745: PPUSH
72746: CALL_OW 430
72750: PUSH
72751: LD_VAR 0 4
72755: PPUSH
72756: LD_VAR 0 5
72760: PPUSH
72761: CALL 14653 0 2
72765: AND
72766: IFFALSE 72792
// begin researching := true ;
72768: LD_ADDR_VAR 0 10
72772: PUSH
72773: LD_INT 1
72775: ST_TO_ADDR
// ComResearch ( j , t ) ;
72776: LD_VAR 0 3
72780: PPUSH
72781: LD_VAR 0 5
72785: PPUSH
72786: CALL_OW 124
// break ;
72790: GO 72794
// end ;
72792: GO 72733
72794: POP
72795: POP
// if not researching then
72796: LD_VAR 0 10
72800: NOT
72801: IFFALSE 72813
// idle_lab := j ;
72803: LD_ADDR_VAR 0 11
72807: PUSH
72808: LD_VAR 0 3
72812: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
72813: LD_VAR 0 3
72817: PPUSH
72818: CALL_OW 461
72822: PUSH
72823: LD_INT 10
72825: EQUAL
72826: IFFALSE 73414
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
72828: LD_EXP 87
72832: PUSH
72833: LD_VAR 0 2
72837: ARRAY
72838: NOT
72839: PUSH
72840: LD_EXP 88
72844: PUSH
72845: LD_VAR 0 2
72849: ARRAY
72850: NOT
72851: AND
72852: PUSH
72853: LD_EXP 85
72857: PUSH
72858: LD_VAR 0 4
72862: ARRAY
72863: PUSH
72864: LD_INT 1
72866: GREATER
72867: AND
72868: IFFALSE 72999
// begin ComCancel ( j ) ;
72870: LD_VAR 0 3
72874: PPUSH
72875: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
72879: LD_ADDR_EXP 85
72883: PUSH
72884: LD_EXP 85
72888: PPUSH
72889: LD_VAR 0 4
72893: PPUSH
72894: LD_EXP 85
72898: PUSH
72899: LD_VAR 0 4
72903: ARRAY
72904: PPUSH
72905: LD_EXP 85
72909: PUSH
72910: LD_VAR 0 4
72914: ARRAY
72915: PUSH
72916: LD_INT 1
72918: MINUS
72919: PPUSH
72920: LD_EXP 85
72924: PUSH
72925: LD_VAR 0 4
72929: ARRAY
72930: PPUSH
72931: LD_INT 0
72933: PPUSH
72934: CALL 20072 0 4
72938: PPUSH
72939: CALL_OW 1
72943: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
72944: LD_ADDR_EXP 85
72948: PUSH
72949: LD_EXP 85
72953: PPUSH
72954: LD_VAR 0 4
72958: PPUSH
72959: LD_EXP 85
72963: PUSH
72964: LD_VAR 0 4
72968: ARRAY
72969: PPUSH
72970: LD_EXP 85
72974: PUSH
72975: LD_VAR 0 4
72979: ARRAY
72980: PPUSH
72981: LD_INT 1
72983: PPUSH
72984: LD_INT 0
72986: PPUSH
72987: CALL 20072 0 4
72991: PPUSH
72992: CALL_OW 1
72996: ST_TO_ADDR
// continue ;
72997: GO 72571
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
72999: LD_EXP 87
73003: PUSH
73004: LD_VAR 0 2
73008: ARRAY
73009: PUSH
73010: LD_EXP 88
73014: PUSH
73015: LD_VAR 0 2
73019: ARRAY
73020: NOT
73021: AND
73022: IFFALSE 73149
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
73024: LD_ADDR_EXP 88
73028: PUSH
73029: LD_EXP 88
73033: PPUSH
73034: LD_VAR 0 2
73038: PUSH
73039: LD_EXP 88
73043: PUSH
73044: LD_VAR 0 2
73048: ARRAY
73049: PUSH
73050: LD_INT 1
73052: PLUS
73053: PUSH
73054: EMPTY
73055: LIST
73056: LIST
73057: PPUSH
73058: LD_EXP 87
73062: PUSH
73063: LD_VAR 0 2
73067: ARRAY
73068: PUSH
73069: LD_INT 1
73071: ARRAY
73072: PPUSH
73073: CALL 20654 0 3
73077: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
73078: LD_EXP 87
73082: PUSH
73083: LD_VAR 0 2
73087: ARRAY
73088: PUSH
73089: LD_INT 1
73091: ARRAY
73092: PPUSH
73093: LD_INT 112
73095: PPUSH
73096: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
73100: LD_ADDR_VAR 0 9
73104: PUSH
73105: LD_EXP 87
73109: PUSH
73110: LD_VAR 0 2
73114: ARRAY
73115: PPUSH
73116: LD_INT 1
73118: PPUSH
73119: CALL_OW 3
73123: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
73124: LD_ADDR_EXP 87
73128: PUSH
73129: LD_EXP 87
73133: PPUSH
73134: LD_VAR 0 2
73138: PPUSH
73139: LD_VAR 0 9
73143: PPUSH
73144: CALL_OW 1
73148: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
73149: LD_EXP 87
73153: PUSH
73154: LD_VAR 0 2
73158: ARRAY
73159: PUSH
73160: LD_EXP 88
73164: PUSH
73165: LD_VAR 0 2
73169: ARRAY
73170: AND
73171: PUSH
73172: LD_EXP 88
73176: PUSH
73177: LD_VAR 0 2
73181: ARRAY
73182: PUSH
73183: LD_INT 1
73185: ARRAY
73186: PPUSH
73187: CALL_OW 310
73191: NOT
73192: AND
73193: PUSH
73194: LD_VAR 0 3
73198: PPUSH
73199: CALL_OW 313
73203: PUSH
73204: LD_INT 6
73206: EQUAL
73207: AND
73208: IFFALSE 73264
// begin tmp2 := UnitsInside ( j ) ;
73210: LD_ADDR_VAR 0 9
73214: PUSH
73215: LD_VAR 0 3
73219: PPUSH
73220: CALL_OW 313
73224: ST_TO_ADDR
// if tmp2 = 6 then
73225: LD_VAR 0 9
73229: PUSH
73230: LD_INT 6
73232: EQUAL
73233: IFFALSE 73264
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
73235: LD_VAR 0 9
73239: PUSH
73240: LD_INT 1
73242: ARRAY
73243: PPUSH
73244: LD_INT 112
73246: PPUSH
73247: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
73251: LD_VAR 0 9
73255: PUSH
73256: LD_INT 1
73258: ARRAY
73259: PPUSH
73260: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
73264: LD_EXP 88
73268: PUSH
73269: LD_VAR 0 2
73273: ARRAY
73274: PUSH
73275: LD_EXP 88
73279: PUSH
73280: LD_VAR 0 2
73284: ARRAY
73285: PUSH
73286: LD_INT 1
73288: ARRAY
73289: PPUSH
73290: CALL_OW 314
73294: NOT
73295: AND
73296: PUSH
73297: LD_EXP 88
73301: PUSH
73302: LD_VAR 0 2
73306: ARRAY
73307: PUSH
73308: LD_INT 1
73310: ARRAY
73311: PPUSH
73312: CALL_OW 310
73316: NOT
73317: AND
73318: IFFALSE 73344
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
73320: LD_EXP 88
73324: PUSH
73325: LD_VAR 0 2
73329: ARRAY
73330: PUSH
73331: LD_INT 1
73333: ARRAY
73334: PPUSH
73335: LD_VAR 0 3
73339: PPUSH
73340: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
73344: LD_EXP 88
73348: PUSH
73349: LD_VAR 0 2
73353: ARRAY
73354: PUSH
73355: LD_INT 1
73357: ARRAY
73358: PPUSH
73359: CALL_OW 310
73363: PUSH
73364: LD_EXP 88
73368: PUSH
73369: LD_VAR 0 2
73373: ARRAY
73374: PUSH
73375: LD_INT 1
73377: ARRAY
73378: PPUSH
73379: CALL_OW 310
73383: PPUSH
73384: CALL_OW 461
73388: PUSH
73389: LD_INT 3
73391: NONEQUAL
73392: AND
73393: IFFALSE 73414
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
73395: LD_EXP 88
73399: PUSH
73400: LD_VAR 0 2
73404: ARRAY
73405: PUSH
73406: LD_INT 1
73408: ARRAY
73409: PPUSH
73410: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
73414: LD_VAR 0 3
73418: PPUSH
73419: CALL_OW 461
73423: PUSH
73424: LD_INT 6
73426: EQUAL
73427: PUSH
73428: LD_VAR 0 6
73432: PUSH
73433: LD_INT 1
73435: GREATER
73436: AND
73437: IFFALSE 73589
// begin sci := [ ] ;
73439: LD_ADDR_VAR 0 8
73443: PUSH
73444: EMPTY
73445: ST_TO_ADDR
// for x in ( tmp diff j ) do
73446: LD_ADDR_VAR 0 7
73450: PUSH
73451: LD_VAR 0 6
73455: PUSH
73456: LD_VAR 0 3
73460: DIFF
73461: PUSH
73462: FOR_IN
73463: IFFALSE 73515
// begin if sci = 6 then
73465: LD_VAR 0 8
73469: PUSH
73470: LD_INT 6
73472: EQUAL
73473: IFFALSE 73477
// break ;
73475: GO 73515
// if BuildingStatus ( x ) = bs_idle then
73477: LD_VAR 0 7
73481: PPUSH
73482: CALL_OW 461
73486: PUSH
73487: LD_INT 2
73489: EQUAL
73490: IFFALSE 73513
// sci := sci ^ UnitsInside ( x ) ;
73492: LD_ADDR_VAR 0 8
73496: PUSH
73497: LD_VAR 0 8
73501: PUSH
73502: LD_VAR 0 7
73506: PPUSH
73507: CALL_OW 313
73511: ADD
73512: ST_TO_ADDR
// end ;
73513: GO 73462
73515: POP
73516: POP
// if not sci then
73517: LD_VAR 0 8
73521: NOT
73522: IFFALSE 73526
// continue ;
73524: GO 72571
// for x in sci do
73526: LD_ADDR_VAR 0 7
73530: PUSH
73531: LD_VAR 0 8
73535: PUSH
73536: FOR_IN
73537: IFFALSE 73587
// if IsInUnit ( x ) and not HasTask ( x ) then
73539: LD_VAR 0 7
73543: PPUSH
73544: CALL_OW 310
73548: PUSH
73549: LD_VAR 0 7
73553: PPUSH
73554: CALL_OW 314
73558: NOT
73559: AND
73560: IFFALSE 73585
// begin ComExitBuilding ( x ) ;
73562: LD_VAR 0 7
73566: PPUSH
73567: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73571: LD_VAR 0 7
73575: PPUSH
73576: LD_VAR 0 3
73580: PPUSH
73581: CALL_OW 180
// end ;
73585: GO 73536
73587: POP
73588: POP
// end ; end ;
73589: GO 72571
73591: POP
73592: POP
// end ;
73593: GO 72525
73595: POP
73596: POP
// end ;
73597: LD_VAR 0 1
73601: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
73602: LD_INT 0
73604: PPUSH
73605: PPUSH
// if not mc_bases then
73606: LD_EXP 58
73610: NOT
73611: IFFALSE 73615
// exit ;
73613: GO 73696
// for i = 1 to mc_bases do
73615: LD_ADDR_VAR 0 2
73619: PUSH
73620: DOUBLE
73621: LD_INT 1
73623: DEC
73624: ST_TO_ADDR
73625: LD_EXP 58
73629: PUSH
73630: FOR_TO
73631: IFFALSE 73694
// if mc_mines [ i ] and mc_miners [ i ] then
73633: LD_EXP 71
73637: PUSH
73638: LD_VAR 0 2
73642: ARRAY
73643: PUSH
73644: LD_EXP 72
73648: PUSH
73649: LD_VAR 0 2
73653: ARRAY
73654: AND
73655: IFFALSE 73692
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
73657: LD_EXP 72
73661: PUSH
73662: LD_VAR 0 2
73666: ARRAY
73667: PUSH
73668: LD_INT 1
73670: ARRAY
73671: PPUSH
73672: CALL_OW 255
73676: PPUSH
73677: LD_EXP 71
73681: PUSH
73682: LD_VAR 0 2
73686: ARRAY
73687: PPUSH
73688: CALL 17704 0 2
73692: GO 73630
73694: POP
73695: POP
// end ;
73696: LD_VAR 0 1
73700: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
73701: LD_INT 0
73703: PPUSH
73704: PPUSH
73705: PPUSH
73706: PPUSH
73707: PPUSH
73708: PPUSH
73709: PPUSH
73710: PPUSH
// if not mc_bases or not mc_parking then
73711: LD_EXP 58
73715: NOT
73716: PUSH
73717: LD_EXP 82
73721: NOT
73722: OR
73723: IFFALSE 73727
// exit ;
73725: GO 74403
// for i = 1 to mc_bases do
73727: LD_ADDR_VAR 0 2
73731: PUSH
73732: DOUBLE
73733: LD_INT 1
73735: DEC
73736: ST_TO_ADDR
73737: LD_EXP 58
73741: PUSH
73742: FOR_TO
73743: IFFALSE 74401
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
73745: LD_EXP 58
73749: PUSH
73750: LD_VAR 0 2
73754: ARRAY
73755: NOT
73756: PUSH
73757: LD_EXP 82
73761: PUSH
73762: LD_VAR 0 2
73766: ARRAY
73767: NOT
73768: OR
73769: IFFALSE 73773
// continue ;
73771: GO 73742
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
73773: LD_ADDR_VAR 0 5
73777: PUSH
73778: LD_EXP 58
73782: PUSH
73783: LD_VAR 0 2
73787: ARRAY
73788: PUSH
73789: LD_INT 1
73791: ARRAY
73792: PPUSH
73793: CALL_OW 255
73797: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73798: LD_ADDR_VAR 0 6
73802: PUSH
73803: LD_EXP 58
73807: PUSH
73808: LD_VAR 0 2
73812: ARRAY
73813: PPUSH
73814: LD_INT 30
73816: PUSH
73817: LD_INT 3
73819: PUSH
73820: EMPTY
73821: LIST
73822: LIST
73823: PPUSH
73824: CALL_OW 72
73828: ST_TO_ADDR
// if not fac then
73829: LD_VAR 0 6
73833: NOT
73834: IFFALSE 73885
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73836: LD_ADDR_VAR 0 6
73840: PUSH
73841: LD_EXP 58
73845: PUSH
73846: LD_VAR 0 2
73850: ARRAY
73851: PPUSH
73852: LD_INT 2
73854: PUSH
73855: LD_INT 30
73857: PUSH
73858: LD_INT 0
73860: PUSH
73861: EMPTY
73862: LIST
73863: LIST
73864: PUSH
73865: LD_INT 30
73867: PUSH
73868: LD_INT 1
73870: PUSH
73871: EMPTY
73872: LIST
73873: LIST
73874: PUSH
73875: EMPTY
73876: LIST
73877: LIST
73878: LIST
73879: PPUSH
73880: CALL_OW 72
73884: ST_TO_ADDR
// if not fac then
73885: LD_VAR 0 6
73889: NOT
73890: IFFALSE 73894
// continue ;
73892: GO 73742
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73894: LD_ADDR_VAR 0 7
73898: PUSH
73899: LD_EXP 82
73903: PUSH
73904: LD_VAR 0 2
73908: ARRAY
73909: PPUSH
73910: LD_INT 22
73912: PUSH
73913: LD_VAR 0 5
73917: PUSH
73918: EMPTY
73919: LIST
73920: LIST
73921: PUSH
73922: LD_INT 21
73924: PUSH
73925: LD_INT 2
73927: PUSH
73928: EMPTY
73929: LIST
73930: LIST
73931: PUSH
73932: LD_INT 3
73934: PUSH
73935: LD_INT 24
73937: PUSH
73938: LD_INT 1000
73940: PUSH
73941: EMPTY
73942: LIST
73943: LIST
73944: PUSH
73945: EMPTY
73946: LIST
73947: LIST
73948: PUSH
73949: EMPTY
73950: LIST
73951: LIST
73952: LIST
73953: PPUSH
73954: CALL_OW 70
73958: PUSH
73959: LD_INT 22
73961: PUSH
73962: LD_VAR 0 5
73966: PUSH
73967: EMPTY
73968: LIST
73969: LIST
73970: PUSH
73971: LD_INT 91
73973: PUSH
73974: LD_VAR 0 6
73978: PUSH
73979: LD_INT 1
73981: ARRAY
73982: PUSH
73983: LD_INT 25
73985: PUSH
73986: EMPTY
73987: LIST
73988: LIST
73989: LIST
73990: PUSH
73991: LD_INT 21
73993: PUSH
73994: LD_INT 2
73996: PUSH
73997: EMPTY
73998: LIST
73999: LIST
74000: PUSH
74001: LD_INT 3
74003: PUSH
74004: LD_INT 24
74006: PUSH
74007: LD_INT 1000
74009: PUSH
74010: EMPTY
74011: LIST
74012: LIST
74013: PUSH
74014: EMPTY
74015: LIST
74016: LIST
74017: PUSH
74018: EMPTY
74019: LIST
74020: LIST
74021: LIST
74022: LIST
74023: PPUSH
74024: CALL_OW 69
74028: UNION
74029: ST_TO_ADDR
// if not vehs then
74030: LD_VAR 0 7
74034: NOT
74035: IFFALSE 74061
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
74037: LD_ADDR_EXP 70
74041: PUSH
74042: LD_EXP 70
74046: PPUSH
74047: LD_VAR 0 2
74051: PPUSH
74052: EMPTY
74053: PPUSH
74054: CALL_OW 1
74058: ST_TO_ADDR
// continue ;
74059: GO 73742
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74061: LD_ADDR_VAR 0 8
74065: PUSH
74066: LD_EXP 58
74070: PUSH
74071: LD_VAR 0 2
74075: ARRAY
74076: PPUSH
74077: LD_INT 30
74079: PUSH
74080: LD_INT 3
74082: PUSH
74083: EMPTY
74084: LIST
74085: LIST
74086: PPUSH
74087: CALL_OW 72
74091: ST_TO_ADDR
// if tmp then
74092: LD_VAR 0 8
74096: IFFALSE 74199
// begin for j in tmp do
74098: LD_ADDR_VAR 0 3
74102: PUSH
74103: LD_VAR 0 8
74107: PUSH
74108: FOR_IN
74109: IFFALSE 74197
// for k in UnitsInside ( j ) do
74111: LD_ADDR_VAR 0 4
74115: PUSH
74116: LD_VAR 0 3
74120: PPUSH
74121: CALL_OW 313
74125: PUSH
74126: FOR_IN
74127: IFFALSE 74193
// if k then
74129: LD_VAR 0 4
74133: IFFALSE 74191
// if not k in mc_repair_vehicle [ i ] then
74135: LD_VAR 0 4
74139: PUSH
74140: LD_EXP 70
74144: PUSH
74145: LD_VAR 0 2
74149: ARRAY
74150: IN
74151: NOT
74152: IFFALSE 74191
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
74154: LD_ADDR_EXP 70
74158: PUSH
74159: LD_EXP 70
74163: PPUSH
74164: LD_VAR 0 2
74168: PPUSH
74169: LD_EXP 70
74173: PUSH
74174: LD_VAR 0 2
74178: ARRAY
74179: PUSH
74180: LD_VAR 0 4
74184: UNION
74185: PPUSH
74186: CALL_OW 1
74190: ST_TO_ADDR
74191: GO 74126
74193: POP
74194: POP
74195: GO 74108
74197: POP
74198: POP
// end ; if not mc_repair_vehicle [ i ] then
74199: LD_EXP 70
74203: PUSH
74204: LD_VAR 0 2
74208: ARRAY
74209: NOT
74210: IFFALSE 74214
// continue ;
74212: GO 73742
// for j in mc_repair_vehicle [ i ] do
74214: LD_ADDR_VAR 0 3
74218: PUSH
74219: LD_EXP 70
74223: PUSH
74224: LD_VAR 0 2
74228: ARRAY
74229: PUSH
74230: FOR_IN
74231: IFFALSE 74397
// begin if GetClass ( j ) <> 3 then
74233: LD_VAR 0 3
74237: PPUSH
74238: CALL_OW 257
74242: PUSH
74243: LD_INT 3
74245: NONEQUAL
74246: IFFALSE 74287
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
74248: LD_ADDR_EXP 70
74252: PUSH
74253: LD_EXP 70
74257: PPUSH
74258: LD_VAR 0 2
74262: PPUSH
74263: LD_EXP 70
74267: PUSH
74268: LD_VAR 0 2
74272: ARRAY
74273: PUSH
74274: LD_VAR 0 3
74278: DIFF
74279: PPUSH
74280: CALL_OW 1
74284: ST_TO_ADDR
// continue ;
74285: GO 74230
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74287: LD_VAR 0 3
74291: PPUSH
74292: CALL_OW 311
74296: NOT
74297: PUSH
74298: LD_VAR 0 3
74302: PUSH
74303: LD_EXP 61
74307: PUSH
74308: LD_VAR 0 2
74312: ARRAY
74313: PUSH
74314: LD_INT 1
74316: ARRAY
74317: IN
74318: NOT
74319: AND
74320: PUSH
74321: LD_VAR 0 3
74325: PUSH
74326: LD_EXP 61
74330: PUSH
74331: LD_VAR 0 2
74335: ARRAY
74336: PUSH
74337: LD_INT 2
74339: ARRAY
74340: IN
74341: NOT
74342: AND
74343: IFFALSE 74395
// begin if IsInUnit ( j ) then
74345: LD_VAR 0 3
74349: PPUSH
74350: CALL_OW 310
74354: IFFALSE 74365
// ComExitBuilding ( j ) ;
74356: LD_VAR 0 3
74360: PPUSH
74361: CALL_OW 122
// if not HasTask ( j ) then
74365: LD_VAR 0 3
74369: PPUSH
74370: CALL_OW 314
74374: NOT
74375: IFFALSE 74395
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
74377: LD_VAR 0 3
74381: PPUSH
74382: LD_VAR 0 7
74386: PUSH
74387: LD_INT 1
74389: ARRAY
74390: PPUSH
74391: CALL_OW 189
// end ; end ;
74395: GO 74230
74397: POP
74398: POP
// end ;
74399: GO 73742
74401: POP
74402: POP
// end ;
74403: LD_VAR 0 1
74407: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
74408: LD_INT 0
74410: PPUSH
74411: PPUSH
74412: PPUSH
74413: PPUSH
74414: PPUSH
74415: PPUSH
74416: PPUSH
74417: PPUSH
74418: PPUSH
74419: PPUSH
74420: PPUSH
// if not mc_bases then
74421: LD_EXP 58
74425: NOT
74426: IFFALSE 74430
// exit ;
74428: GO 75232
// for i = 1 to mc_bases do
74430: LD_ADDR_VAR 0 2
74434: PUSH
74435: DOUBLE
74436: LD_INT 1
74438: DEC
74439: ST_TO_ADDR
74440: LD_EXP 58
74444: PUSH
74445: FOR_TO
74446: IFFALSE 75230
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
74448: LD_EXP 86
74452: PUSH
74453: LD_VAR 0 2
74457: ARRAY
74458: NOT
74459: PUSH
74460: LD_EXP 61
74464: PUSH
74465: LD_VAR 0 2
74469: ARRAY
74470: PUSH
74471: LD_INT 1
74473: ARRAY
74474: OR
74475: PUSH
74476: LD_EXP 61
74480: PUSH
74481: LD_VAR 0 2
74485: ARRAY
74486: PUSH
74487: LD_INT 2
74489: ARRAY
74490: OR
74491: PUSH
74492: LD_EXP 84
74496: PUSH
74497: LD_VAR 0 2
74501: ARRAY
74502: PPUSH
74503: LD_INT 1
74505: PPUSH
74506: CALL_OW 325
74510: NOT
74511: OR
74512: PUSH
74513: LD_EXP 81
74517: PUSH
74518: LD_VAR 0 2
74522: ARRAY
74523: OR
74524: IFFALSE 74528
// continue ;
74526: GO 74445
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
74528: LD_ADDR_VAR 0 8
74532: PUSH
74533: LD_EXP 58
74537: PUSH
74538: LD_VAR 0 2
74542: ARRAY
74543: PPUSH
74544: LD_INT 25
74546: PUSH
74547: LD_INT 4
74549: PUSH
74550: EMPTY
74551: LIST
74552: LIST
74553: PUSH
74554: LD_INT 50
74556: PUSH
74557: EMPTY
74558: LIST
74559: PUSH
74560: LD_INT 3
74562: PUSH
74563: LD_INT 60
74565: PUSH
74566: EMPTY
74567: LIST
74568: PUSH
74569: EMPTY
74570: LIST
74571: LIST
74572: PUSH
74573: EMPTY
74574: LIST
74575: LIST
74576: LIST
74577: PPUSH
74578: CALL_OW 72
74582: PUSH
74583: LD_EXP 62
74587: PUSH
74588: LD_VAR 0 2
74592: ARRAY
74593: DIFF
74594: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74595: LD_ADDR_VAR 0 9
74599: PUSH
74600: LD_EXP 58
74604: PUSH
74605: LD_VAR 0 2
74609: ARRAY
74610: PPUSH
74611: LD_INT 2
74613: PUSH
74614: LD_INT 30
74616: PUSH
74617: LD_INT 0
74619: PUSH
74620: EMPTY
74621: LIST
74622: LIST
74623: PUSH
74624: LD_INT 30
74626: PUSH
74627: LD_INT 1
74629: PUSH
74630: EMPTY
74631: LIST
74632: LIST
74633: PUSH
74634: EMPTY
74635: LIST
74636: LIST
74637: LIST
74638: PPUSH
74639: CALL_OW 72
74643: ST_TO_ADDR
// if not tmp or not dep then
74644: LD_VAR 0 8
74648: NOT
74649: PUSH
74650: LD_VAR 0 9
74654: NOT
74655: OR
74656: IFFALSE 74660
// continue ;
74658: GO 74445
// side := GetSide ( tmp [ 1 ] ) ;
74660: LD_ADDR_VAR 0 11
74664: PUSH
74665: LD_VAR 0 8
74669: PUSH
74670: LD_INT 1
74672: ARRAY
74673: PPUSH
74674: CALL_OW 255
74678: ST_TO_ADDR
// dep := dep [ 1 ] ;
74679: LD_ADDR_VAR 0 9
74683: PUSH
74684: LD_VAR 0 9
74688: PUSH
74689: LD_INT 1
74691: ARRAY
74692: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
74693: LD_ADDR_VAR 0 7
74697: PUSH
74698: LD_EXP 86
74702: PUSH
74703: LD_VAR 0 2
74707: ARRAY
74708: PPUSH
74709: LD_INT 22
74711: PUSH
74712: LD_INT 0
74714: PUSH
74715: EMPTY
74716: LIST
74717: LIST
74718: PUSH
74719: LD_INT 25
74721: PUSH
74722: LD_INT 12
74724: PUSH
74725: EMPTY
74726: LIST
74727: LIST
74728: PUSH
74729: EMPTY
74730: LIST
74731: LIST
74732: PPUSH
74733: CALL_OW 70
74737: PUSH
74738: LD_INT 22
74740: PUSH
74741: LD_INT 0
74743: PUSH
74744: EMPTY
74745: LIST
74746: LIST
74747: PUSH
74748: LD_INT 25
74750: PUSH
74751: LD_INT 12
74753: PUSH
74754: EMPTY
74755: LIST
74756: LIST
74757: PUSH
74758: LD_INT 91
74760: PUSH
74761: LD_VAR 0 9
74765: PUSH
74766: LD_INT 20
74768: PUSH
74769: EMPTY
74770: LIST
74771: LIST
74772: LIST
74773: PUSH
74774: EMPTY
74775: LIST
74776: LIST
74777: LIST
74778: PPUSH
74779: CALL_OW 69
74783: UNION
74784: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
74785: LD_ADDR_VAR 0 10
74789: PUSH
74790: LD_EXP 86
74794: PUSH
74795: LD_VAR 0 2
74799: ARRAY
74800: PPUSH
74801: LD_INT 81
74803: PUSH
74804: LD_VAR 0 11
74808: PUSH
74809: EMPTY
74810: LIST
74811: LIST
74812: PPUSH
74813: CALL_OW 70
74817: ST_TO_ADDR
// if not apes or danger_at_area then
74818: LD_VAR 0 7
74822: NOT
74823: PUSH
74824: LD_VAR 0 10
74828: OR
74829: IFFALSE 74879
// begin if mc_taming [ i ] then
74831: LD_EXP 89
74835: PUSH
74836: LD_VAR 0 2
74840: ARRAY
74841: IFFALSE 74877
// begin MC_Reset ( i , 121 ) ;
74843: LD_VAR 0 2
74847: PPUSH
74848: LD_INT 121
74850: PPUSH
74851: CALL 60572 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
74855: LD_ADDR_EXP 89
74859: PUSH
74860: LD_EXP 89
74864: PPUSH
74865: LD_VAR 0 2
74869: PPUSH
74870: EMPTY
74871: PPUSH
74872: CALL_OW 1
74876: ST_TO_ADDR
// end ; continue ;
74877: GO 74445
// end ; for j in tmp do
74879: LD_ADDR_VAR 0 3
74883: PUSH
74884: LD_VAR 0 8
74888: PUSH
74889: FOR_IN
74890: IFFALSE 75226
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
74892: LD_VAR 0 3
74896: PUSH
74897: LD_EXP 89
74901: PUSH
74902: LD_VAR 0 2
74906: ARRAY
74907: IN
74908: NOT
74909: PUSH
74910: LD_EXP 89
74914: PUSH
74915: LD_VAR 0 2
74919: ARRAY
74920: PUSH
74921: LD_INT 3
74923: LESS
74924: AND
74925: IFFALSE 74983
// begin SetTag ( j , 121 ) ;
74927: LD_VAR 0 3
74931: PPUSH
74932: LD_INT 121
74934: PPUSH
74935: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
74939: LD_ADDR_EXP 89
74943: PUSH
74944: LD_EXP 89
74948: PPUSH
74949: LD_VAR 0 2
74953: PUSH
74954: LD_EXP 89
74958: PUSH
74959: LD_VAR 0 2
74963: ARRAY
74964: PUSH
74965: LD_INT 1
74967: PLUS
74968: PUSH
74969: EMPTY
74970: LIST
74971: LIST
74972: PPUSH
74973: LD_VAR 0 3
74977: PPUSH
74978: CALL 20654 0 3
74982: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
74983: LD_VAR 0 3
74987: PUSH
74988: LD_EXP 89
74992: PUSH
74993: LD_VAR 0 2
74997: ARRAY
74998: IN
74999: IFFALSE 75224
// begin if GetClass ( j ) <> 4 then
75001: LD_VAR 0 3
75005: PPUSH
75006: CALL_OW 257
75010: PUSH
75011: LD_INT 4
75013: NONEQUAL
75014: IFFALSE 75067
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
75016: LD_ADDR_EXP 89
75020: PUSH
75021: LD_EXP 89
75025: PPUSH
75026: LD_VAR 0 2
75030: PPUSH
75031: LD_EXP 89
75035: PUSH
75036: LD_VAR 0 2
75040: ARRAY
75041: PUSH
75042: LD_VAR 0 3
75046: DIFF
75047: PPUSH
75048: CALL_OW 1
75052: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75053: LD_VAR 0 3
75057: PPUSH
75058: LD_INT 0
75060: PPUSH
75061: CALL_OW 109
// continue ;
75065: GO 74889
// end ; if IsInUnit ( j ) then
75067: LD_VAR 0 3
75071: PPUSH
75072: CALL_OW 310
75076: IFFALSE 75087
// ComExitBuilding ( j ) ;
75078: LD_VAR 0 3
75082: PPUSH
75083: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
75087: LD_ADDR_VAR 0 6
75091: PUSH
75092: LD_VAR 0 7
75096: PPUSH
75097: LD_VAR 0 3
75101: PPUSH
75102: CALL_OW 74
75106: ST_TO_ADDR
// if not ape then
75107: LD_VAR 0 6
75111: NOT
75112: IFFALSE 75116
// break ;
75114: GO 75226
// x := GetX ( ape ) ;
75116: LD_ADDR_VAR 0 4
75120: PUSH
75121: LD_VAR 0 6
75125: PPUSH
75126: CALL_OW 250
75130: ST_TO_ADDR
// y := GetY ( ape ) ;
75131: LD_ADDR_VAR 0 5
75135: PUSH
75136: LD_VAR 0 6
75140: PPUSH
75141: CALL_OW 251
75145: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
75146: LD_VAR 0 4
75150: PPUSH
75151: LD_VAR 0 5
75155: PPUSH
75156: CALL_OW 488
75160: NOT
75161: PUSH
75162: LD_VAR 0 11
75166: PPUSH
75167: LD_VAR 0 4
75171: PPUSH
75172: LD_VAR 0 5
75176: PPUSH
75177: LD_INT 20
75179: PPUSH
75180: CALL 21550 0 4
75184: PUSH
75185: LD_INT 4
75187: ARRAY
75188: OR
75189: IFFALSE 75193
// break ;
75191: GO 75226
// if not HasTask ( j ) then
75193: LD_VAR 0 3
75197: PPUSH
75198: CALL_OW 314
75202: NOT
75203: IFFALSE 75224
// ComTameXY ( j , x , y ) ;
75205: LD_VAR 0 3
75209: PPUSH
75210: LD_VAR 0 4
75214: PPUSH
75215: LD_VAR 0 5
75219: PPUSH
75220: CALL_OW 131
// end ; end ;
75224: GO 74889
75226: POP
75227: POP
// end ;
75228: GO 74445
75230: POP
75231: POP
// end ;
75232: LD_VAR 0 1
75236: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
75237: LD_INT 0
75239: PPUSH
75240: PPUSH
75241: PPUSH
75242: PPUSH
75243: PPUSH
75244: PPUSH
75245: PPUSH
75246: PPUSH
// if not mc_bases then
75247: LD_EXP 58
75251: NOT
75252: IFFALSE 75256
// exit ;
75254: GO 75882
// for i = 1 to mc_bases do
75256: LD_ADDR_VAR 0 2
75260: PUSH
75261: DOUBLE
75262: LD_INT 1
75264: DEC
75265: ST_TO_ADDR
75266: LD_EXP 58
75270: PUSH
75271: FOR_TO
75272: IFFALSE 75880
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
75274: LD_EXP 87
75278: PUSH
75279: LD_VAR 0 2
75283: ARRAY
75284: NOT
75285: PUSH
75286: LD_EXP 87
75290: PUSH
75291: LD_VAR 0 2
75295: ARRAY
75296: PPUSH
75297: LD_INT 25
75299: PUSH
75300: LD_INT 12
75302: PUSH
75303: EMPTY
75304: LIST
75305: LIST
75306: PPUSH
75307: CALL_OW 72
75311: NOT
75312: OR
75313: IFFALSE 75317
// continue ;
75315: GO 75271
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
75317: LD_ADDR_VAR 0 5
75321: PUSH
75322: LD_EXP 87
75326: PUSH
75327: LD_VAR 0 2
75331: ARRAY
75332: PUSH
75333: LD_INT 1
75335: ARRAY
75336: PPUSH
75337: CALL_OW 255
75341: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
75342: LD_VAR 0 5
75346: PPUSH
75347: LD_INT 2
75349: PPUSH
75350: CALL_OW 325
75354: IFFALSE 75607
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
75356: LD_ADDR_VAR 0 4
75360: PUSH
75361: LD_EXP 87
75365: PUSH
75366: LD_VAR 0 2
75370: ARRAY
75371: PPUSH
75372: LD_INT 25
75374: PUSH
75375: LD_INT 16
75377: PUSH
75378: EMPTY
75379: LIST
75380: LIST
75381: PPUSH
75382: CALL_OW 72
75386: ST_TO_ADDR
// if tmp < 6 then
75387: LD_VAR 0 4
75391: PUSH
75392: LD_INT 6
75394: LESS
75395: IFFALSE 75607
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75397: LD_ADDR_VAR 0 6
75401: PUSH
75402: LD_EXP 58
75406: PUSH
75407: LD_VAR 0 2
75411: ARRAY
75412: PPUSH
75413: LD_INT 2
75415: PUSH
75416: LD_INT 30
75418: PUSH
75419: LD_INT 0
75421: PUSH
75422: EMPTY
75423: LIST
75424: LIST
75425: PUSH
75426: LD_INT 30
75428: PUSH
75429: LD_INT 1
75431: PUSH
75432: EMPTY
75433: LIST
75434: LIST
75435: PUSH
75436: EMPTY
75437: LIST
75438: LIST
75439: LIST
75440: PPUSH
75441: CALL_OW 72
75445: ST_TO_ADDR
// if depot then
75446: LD_VAR 0 6
75450: IFFALSE 75607
// begin selected := 0 ;
75452: LD_ADDR_VAR 0 7
75456: PUSH
75457: LD_INT 0
75459: ST_TO_ADDR
// for j in depot do
75460: LD_ADDR_VAR 0 3
75464: PUSH
75465: LD_VAR 0 6
75469: PUSH
75470: FOR_IN
75471: IFFALSE 75502
// begin if UnitsInside ( j ) < 6 then
75473: LD_VAR 0 3
75477: PPUSH
75478: CALL_OW 313
75482: PUSH
75483: LD_INT 6
75485: LESS
75486: IFFALSE 75500
// begin selected := j ;
75488: LD_ADDR_VAR 0 7
75492: PUSH
75493: LD_VAR 0 3
75497: ST_TO_ADDR
// break ;
75498: GO 75502
// end ; end ;
75500: GO 75470
75502: POP
75503: POP
// if selected then
75504: LD_VAR 0 7
75508: IFFALSE 75607
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
75510: LD_ADDR_VAR 0 3
75514: PUSH
75515: LD_EXP 87
75519: PUSH
75520: LD_VAR 0 2
75524: ARRAY
75525: PPUSH
75526: LD_INT 25
75528: PUSH
75529: LD_INT 12
75531: PUSH
75532: EMPTY
75533: LIST
75534: LIST
75535: PPUSH
75536: CALL_OW 72
75540: PUSH
75541: FOR_IN
75542: IFFALSE 75605
// if not HasTask ( j ) then
75544: LD_VAR 0 3
75548: PPUSH
75549: CALL_OW 314
75553: NOT
75554: IFFALSE 75603
// begin if not IsInUnit ( j ) then
75556: LD_VAR 0 3
75560: PPUSH
75561: CALL_OW 310
75565: NOT
75566: IFFALSE 75582
// ComEnterUnit ( j , selected ) ;
75568: LD_VAR 0 3
75572: PPUSH
75573: LD_VAR 0 7
75577: PPUSH
75578: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
75582: LD_VAR 0 3
75586: PPUSH
75587: LD_INT 16
75589: PPUSH
75590: CALL_OW 183
// AddComExitBuilding ( j ) ;
75594: LD_VAR 0 3
75598: PPUSH
75599: CALL_OW 182
// end ;
75603: GO 75541
75605: POP
75606: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
75607: LD_VAR 0 5
75611: PPUSH
75612: LD_INT 11
75614: PPUSH
75615: CALL_OW 325
75619: IFFALSE 75878
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
75621: LD_ADDR_VAR 0 4
75625: PUSH
75626: LD_EXP 87
75630: PUSH
75631: LD_VAR 0 2
75635: ARRAY
75636: PPUSH
75637: LD_INT 25
75639: PUSH
75640: LD_INT 16
75642: PUSH
75643: EMPTY
75644: LIST
75645: LIST
75646: PPUSH
75647: CALL_OW 72
75651: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
75652: LD_VAR 0 4
75656: PUSH
75657: LD_INT 6
75659: GREATEREQUAL
75660: PUSH
75661: LD_VAR 0 5
75665: PPUSH
75666: LD_INT 2
75668: PPUSH
75669: CALL_OW 325
75673: NOT
75674: OR
75675: IFFALSE 75878
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
75677: LD_ADDR_VAR 0 8
75681: PUSH
75682: LD_EXP 58
75686: PUSH
75687: LD_VAR 0 2
75691: ARRAY
75692: PPUSH
75693: LD_INT 2
75695: PUSH
75696: LD_INT 30
75698: PUSH
75699: LD_INT 4
75701: PUSH
75702: EMPTY
75703: LIST
75704: LIST
75705: PUSH
75706: LD_INT 30
75708: PUSH
75709: LD_INT 5
75711: PUSH
75712: EMPTY
75713: LIST
75714: LIST
75715: PUSH
75716: EMPTY
75717: LIST
75718: LIST
75719: LIST
75720: PPUSH
75721: CALL_OW 72
75725: ST_TO_ADDR
// if barracks then
75726: LD_VAR 0 8
75730: IFFALSE 75878
// begin selected := 0 ;
75732: LD_ADDR_VAR 0 7
75736: PUSH
75737: LD_INT 0
75739: ST_TO_ADDR
// for j in barracks do
75740: LD_ADDR_VAR 0 3
75744: PUSH
75745: LD_VAR 0 8
75749: PUSH
75750: FOR_IN
75751: IFFALSE 75782
// begin if UnitsInside ( j ) < 6 then
75753: LD_VAR 0 3
75757: PPUSH
75758: CALL_OW 313
75762: PUSH
75763: LD_INT 6
75765: LESS
75766: IFFALSE 75780
// begin selected := j ;
75768: LD_ADDR_VAR 0 7
75772: PUSH
75773: LD_VAR 0 3
75777: ST_TO_ADDR
// break ;
75778: GO 75782
// end ; end ;
75780: GO 75750
75782: POP
75783: POP
// if selected then
75784: LD_VAR 0 7
75788: IFFALSE 75878
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
75790: LD_ADDR_VAR 0 3
75794: PUSH
75795: LD_EXP 87
75799: PUSH
75800: LD_VAR 0 2
75804: ARRAY
75805: PPUSH
75806: LD_INT 25
75808: PUSH
75809: LD_INT 12
75811: PUSH
75812: EMPTY
75813: LIST
75814: LIST
75815: PPUSH
75816: CALL_OW 72
75820: PUSH
75821: FOR_IN
75822: IFFALSE 75876
// if not IsInUnit ( j ) and not HasTask ( j ) then
75824: LD_VAR 0 3
75828: PPUSH
75829: CALL_OW 310
75833: NOT
75834: PUSH
75835: LD_VAR 0 3
75839: PPUSH
75840: CALL_OW 314
75844: NOT
75845: AND
75846: IFFALSE 75874
// begin ComEnterUnit ( j , selected ) ;
75848: LD_VAR 0 3
75852: PPUSH
75853: LD_VAR 0 7
75857: PPUSH
75858: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
75862: LD_VAR 0 3
75866: PPUSH
75867: LD_INT 15
75869: PPUSH
75870: CALL_OW 183
// end ;
75874: GO 75821
75876: POP
75877: POP
// end ; end ; end ; end ; end ;
75878: GO 75271
75880: POP
75881: POP
// end ;
75882: LD_VAR 0 1
75886: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
75887: LD_INT 0
75889: PPUSH
75890: PPUSH
75891: PPUSH
75892: PPUSH
// if not mc_bases then
75893: LD_EXP 58
75897: NOT
75898: IFFALSE 75902
// exit ;
75900: GO 76080
// for i = 1 to mc_bases do
75902: LD_ADDR_VAR 0 2
75906: PUSH
75907: DOUBLE
75908: LD_INT 1
75910: DEC
75911: ST_TO_ADDR
75912: LD_EXP 58
75916: PUSH
75917: FOR_TO
75918: IFFALSE 76078
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
75920: LD_ADDR_VAR 0 4
75924: PUSH
75925: LD_EXP 58
75929: PUSH
75930: LD_VAR 0 2
75934: ARRAY
75935: PPUSH
75936: LD_INT 25
75938: PUSH
75939: LD_INT 9
75941: PUSH
75942: EMPTY
75943: LIST
75944: LIST
75945: PPUSH
75946: CALL_OW 72
75950: ST_TO_ADDR
// if not tmp then
75951: LD_VAR 0 4
75955: NOT
75956: IFFALSE 75960
// continue ;
75958: GO 75917
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
75960: LD_EXP 84
75964: PUSH
75965: LD_VAR 0 2
75969: ARRAY
75970: PPUSH
75971: LD_INT 29
75973: PPUSH
75974: CALL_OW 325
75978: NOT
75979: PUSH
75980: LD_EXP 84
75984: PUSH
75985: LD_VAR 0 2
75989: ARRAY
75990: PPUSH
75991: LD_INT 28
75993: PPUSH
75994: CALL_OW 325
75998: NOT
75999: AND
76000: IFFALSE 76004
// continue ;
76002: GO 75917
// for j in tmp do
76004: LD_ADDR_VAR 0 3
76008: PUSH
76009: LD_VAR 0 4
76013: PUSH
76014: FOR_IN
76015: IFFALSE 76074
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
76017: LD_VAR 0 3
76021: PUSH
76022: LD_EXP 61
76026: PUSH
76027: LD_VAR 0 2
76031: ARRAY
76032: PUSH
76033: LD_INT 1
76035: ARRAY
76036: IN
76037: NOT
76038: PUSH
76039: LD_VAR 0 3
76043: PUSH
76044: LD_EXP 61
76048: PUSH
76049: LD_VAR 0 2
76053: ARRAY
76054: PUSH
76055: LD_INT 2
76057: ARRAY
76058: IN
76059: NOT
76060: AND
76061: IFFALSE 76072
// ComSpaceTimeShoot ( j ) ;
76063: LD_VAR 0 3
76067: PPUSH
76068: CALL 14744 0 1
76072: GO 76014
76074: POP
76075: POP
// end ;
76076: GO 75917
76078: POP
76079: POP
// end ;
76080: LD_VAR 0 1
76084: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
76085: LD_INT 0
76087: PPUSH
76088: PPUSH
76089: PPUSH
76090: PPUSH
76091: PPUSH
76092: PPUSH
76093: PPUSH
76094: PPUSH
76095: PPUSH
// if not mc_bases then
76096: LD_EXP 58
76100: NOT
76101: IFFALSE 76105
// exit ;
76103: GO 76727
// for i = 1 to mc_bases do
76105: LD_ADDR_VAR 0 2
76109: PUSH
76110: DOUBLE
76111: LD_INT 1
76113: DEC
76114: ST_TO_ADDR
76115: LD_EXP 58
76119: PUSH
76120: FOR_TO
76121: IFFALSE 76725
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
76123: LD_EXP 93
76127: PUSH
76128: LD_VAR 0 2
76132: ARRAY
76133: NOT
76134: PUSH
76135: LD_INT 38
76137: PPUSH
76138: LD_EXP 84
76142: PUSH
76143: LD_VAR 0 2
76147: ARRAY
76148: PPUSH
76149: CALL_OW 321
76153: PUSH
76154: LD_INT 2
76156: NONEQUAL
76157: OR
76158: IFFALSE 76162
// continue ;
76160: GO 76120
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
76162: LD_ADDR_VAR 0 8
76166: PUSH
76167: LD_EXP 58
76171: PUSH
76172: LD_VAR 0 2
76176: ARRAY
76177: PPUSH
76178: LD_INT 30
76180: PUSH
76181: LD_INT 34
76183: PUSH
76184: EMPTY
76185: LIST
76186: LIST
76187: PPUSH
76188: CALL_OW 72
76192: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
76193: LD_ADDR_VAR 0 9
76197: PUSH
76198: LD_EXP 58
76202: PUSH
76203: LD_VAR 0 2
76207: ARRAY
76208: PPUSH
76209: LD_INT 25
76211: PUSH
76212: LD_INT 4
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: PPUSH
76219: CALL_OW 72
76223: PPUSH
76224: LD_INT 0
76226: PPUSH
76227: CALL 53914 0 2
76231: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
76232: LD_VAR 0 9
76236: NOT
76237: PUSH
76238: LD_VAR 0 8
76242: NOT
76243: OR
76244: PUSH
76245: LD_EXP 58
76249: PUSH
76250: LD_VAR 0 2
76254: ARRAY
76255: PPUSH
76256: LD_INT 124
76258: PPUSH
76259: CALL 53914 0 2
76263: OR
76264: IFFALSE 76268
// continue ;
76266: GO 76120
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
76268: LD_EXP 94
76272: PUSH
76273: LD_VAR 0 2
76277: ARRAY
76278: PUSH
76279: LD_EXP 93
76283: PUSH
76284: LD_VAR 0 2
76288: ARRAY
76289: LESS
76290: PUSH
76291: LD_EXP 94
76295: PUSH
76296: LD_VAR 0 2
76300: ARRAY
76301: PUSH
76302: LD_VAR 0 8
76306: LESS
76307: AND
76308: IFFALSE 76723
// begin tmp := sci [ 1 ] ;
76310: LD_ADDR_VAR 0 7
76314: PUSH
76315: LD_VAR 0 9
76319: PUSH
76320: LD_INT 1
76322: ARRAY
76323: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
76324: LD_VAR 0 7
76328: PPUSH
76329: LD_INT 124
76331: PPUSH
76332: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
76336: LD_ADDR_VAR 0 3
76340: PUSH
76341: DOUBLE
76342: LD_EXP 93
76346: PUSH
76347: LD_VAR 0 2
76351: ARRAY
76352: INC
76353: ST_TO_ADDR
76354: LD_EXP 93
76358: PUSH
76359: LD_VAR 0 2
76363: ARRAY
76364: PUSH
76365: FOR_DOWNTO
76366: IFFALSE 76709
// begin if IsInUnit ( tmp ) then
76368: LD_VAR 0 7
76372: PPUSH
76373: CALL_OW 310
76377: IFFALSE 76388
// ComExitBuilding ( tmp ) ;
76379: LD_VAR 0 7
76383: PPUSH
76384: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
76388: LD_INT 35
76390: PPUSH
76391: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
76395: LD_VAR 0 7
76399: PPUSH
76400: CALL_OW 310
76404: NOT
76405: PUSH
76406: LD_VAR 0 7
76410: PPUSH
76411: CALL_OW 314
76415: NOT
76416: AND
76417: IFFALSE 76388
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
76419: LD_ADDR_VAR 0 6
76423: PUSH
76424: LD_VAR 0 7
76428: PPUSH
76429: CALL_OW 250
76433: PUSH
76434: LD_VAR 0 7
76438: PPUSH
76439: CALL_OW 251
76443: PUSH
76444: EMPTY
76445: LIST
76446: LIST
76447: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
76448: LD_INT 35
76450: PPUSH
76451: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
76455: LD_ADDR_VAR 0 4
76459: PUSH
76460: LD_EXP 93
76464: PUSH
76465: LD_VAR 0 2
76469: ARRAY
76470: PUSH
76471: LD_VAR 0 3
76475: ARRAY
76476: PUSH
76477: LD_INT 1
76479: ARRAY
76480: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
76481: LD_ADDR_VAR 0 5
76485: PUSH
76486: LD_EXP 93
76490: PUSH
76491: LD_VAR 0 2
76495: ARRAY
76496: PUSH
76497: LD_VAR 0 3
76501: ARRAY
76502: PUSH
76503: LD_INT 2
76505: ARRAY
76506: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
76507: LD_VAR 0 7
76511: PPUSH
76512: LD_INT 10
76514: PPUSH
76515: CALL 23247 0 2
76519: PUSH
76520: LD_INT 4
76522: ARRAY
76523: IFFALSE 76561
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
76525: LD_VAR 0 7
76529: PPUSH
76530: LD_VAR 0 6
76534: PUSH
76535: LD_INT 1
76537: ARRAY
76538: PPUSH
76539: LD_VAR 0 6
76543: PUSH
76544: LD_INT 2
76546: ARRAY
76547: PPUSH
76548: CALL_OW 111
// wait ( 0 0$10 ) ;
76552: LD_INT 350
76554: PPUSH
76555: CALL_OW 67
// end else
76559: GO 76587
// begin ComMoveXY ( tmp , x , y ) ;
76561: LD_VAR 0 7
76565: PPUSH
76566: LD_VAR 0 4
76570: PPUSH
76571: LD_VAR 0 5
76575: PPUSH
76576: CALL_OW 111
// wait ( 0 0$3 ) ;
76580: LD_INT 105
76582: PPUSH
76583: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
76587: LD_VAR 0 7
76591: PPUSH
76592: LD_VAR 0 4
76596: PPUSH
76597: LD_VAR 0 5
76601: PPUSH
76602: CALL_OW 307
76606: IFFALSE 76448
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
76608: LD_VAR 0 7
76612: PPUSH
76613: LD_VAR 0 4
76617: PPUSH
76618: LD_VAR 0 5
76622: PPUSH
76623: LD_VAR 0 8
76627: PUSH
76628: LD_VAR 0 3
76632: ARRAY
76633: PPUSH
76634: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
76638: LD_INT 35
76640: PPUSH
76641: CALL_OW 67
// until not HasTask ( tmp ) ;
76645: LD_VAR 0 7
76649: PPUSH
76650: CALL_OW 314
76654: NOT
76655: IFFALSE 76638
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
76657: LD_ADDR_EXP 94
76661: PUSH
76662: LD_EXP 94
76666: PPUSH
76667: LD_VAR 0 2
76671: PUSH
76672: LD_EXP 94
76676: PUSH
76677: LD_VAR 0 2
76681: ARRAY
76682: PUSH
76683: LD_INT 1
76685: PLUS
76686: PUSH
76687: EMPTY
76688: LIST
76689: LIST
76690: PPUSH
76691: LD_VAR 0 8
76695: PUSH
76696: LD_VAR 0 3
76700: ARRAY
76701: PPUSH
76702: CALL 20654 0 3
76706: ST_TO_ADDR
// end ;
76707: GO 76365
76709: POP
76710: POP
// MC_Reset ( i , 124 ) ;
76711: LD_VAR 0 2
76715: PPUSH
76716: LD_INT 124
76718: PPUSH
76719: CALL 60572 0 2
// end ; end ;
76723: GO 76120
76725: POP
76726: POP
// end ;
76727: LD_VAR 0 1
76731: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
76732: LD_INT 0
76734: PPUSH
76735: PPUSH
76736: PPUSH
// if not mc_bases then
76737: LD_EXP 58
76741: NOT
76742: IFFALSE 76746
// exit ;
76744: GO 77352
// for i = 1 to mc_bases do
76746: LD_ADDR_VAR 0 2
76750: PUSH
76751: DOUBLE
76752: LD_INT 1
76754: DEC
76755: ST_TO_ADDR
76756: LD_EXP 58
76760: PUSH
76761: FOR_TO
76762: IFFALSE 77350
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
76764: LD_ADDR_VAR 0 3
76768: PUSH
76769: LD_EXP 58
76773: PUSH
76774: LD_VAR 0 2
76778: ARRAY
76779: PPUSH
76780: LD_INT 25
76782: PUSH
76783: LD_INT 4
76785: PUSH
76786: EMPTY
76787: LIST
76788: LIST
76789: PPUSH
76790: CALL_OW 72
76794: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
76795: LD_VAR 0 3
76799: NOT
76800: PUSH
76801: LD_EXP 95
76805: PUSH
76806: LD_VAR 0 2
76810: ARRAY
76811: NOT
76812: OR
76813: PUSH
76814: LD_EXP 58
76818: PUSH
76819: LD_VAR 0 2
76823: ARRAY
76824: PPUSH
76825: LD_INT 2
76827: PUSH
76828: LD_INT 30
76830: PUSH
76831: LD_INT 0
76833: PUSH
76834: EMPTY
76835: LIST
76836: LIST
76837: PUSH
76838: LD_INT 30
76840: PUSH
76841: LD_INT 1
76843: PUSH
76844: EMPTY
76845: LIST
76846: LIST
76847: PUSH
76848: EMPTY
76849: LIST
76850: LIST
76851: LIST
76852: PPUSH
76853: CALL_OW 72
76857: NOT
76858: OR
76859: IFFALSE 76909
// begin if mc_deposits_finder [ i ] then
76861: LD_EXP 96
76865: PUSH
76866: LD_VAR 0 2
76870: ARRAY
76871: IFFALSE 76907
// begin MC_Reset ( i , 125 ) ;
76873: LD_VAR 0 2
76877: PPUSH
76878: LD_INT 125
76880: PPUSH
76881: CALL 60572 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76885: LD_ADDR_EXP 96
76889: PUSH
76890: LD_EXP 96
76894: PPUSH
76895: LD_VAR 0 2
76899: PPUSH
76900: EMPTY
76901: PPUSH
76902: CALL_OW 1
76906: ST_TO_ADDR
// end ; continue ;
76907: GO 76761
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
76909: LD_EXP 95
76913: PUSH
76914: LD_VAR 0 2
76918: ARRAY
76919: PUSH
76920: LD_INT 1
76922: ARRAY
76923: PUSH
76924: LD_INT 3
76926: ARRAY
76927: PUSH
76928: LD_INT 1
76930: EQUAL
76931: PUSH
76932: LD_INT 20
76934: PPUSH
76935: LD_EXP 84
76939: PUSH
76940: LD_VAR 0 2
76944: ARRAY
76945: PPUSH
76946: CALL_OW 321
76950: PUSH
76951: LD_INT 2
76953: NONEQUAL
76954: AND
76955: IFFALSE 77005
// begin if mc_deposits_finder [ i ] then
76957: LD_EXP 96
76961: PUSH
76962: LD_VAR 0 2
76966: ARRAY
76967: IFFALSE 77003
// begin MC_Reset ( i , 125 ) ;
76969: LD_VAR 0 2
76973: PPUSH
76974: LD_INT 125
76976: PPUSH
76977: CALL 60572 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76981: LD_ADDR_EXP 96
76985: PUSH
76986: LD_EXP 96
76990: PPUSH
76991: LD_VAR 0 2
76995: PPUSH
76996: EMPTY
76997: PPUSH
76998: CALL_OW 1
77002: ST_TO_ADDR
// end ; continue ;
77003: GO 76761
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
77005: LD_EXP 95
77009: PUSH
77010: LD_VAR 0 2
77014: ARRAY
77015: PUSH
77016: LD_INT 1
77018: ARRAY
77019: PUSH
77020: LD_INT 1
77022: ARRAY
77023: PPUSH
77024: LD_EXP 95
77028: PUSH
77029: LD_VAR 0 2
77033: ARRAY
77034: PUSH
77035: LD_INT 1
77037: ARRAY
77038: PUSH
77039: LD_INT 2
77041: ARRAY
77042: PPUSH
77043: LD_EXP 84
77047: PUSH
77048: LD_VAR 0 2
77052: ARRAY
77053: PPUSH
77054: CALL_OW 440
77058: IFFALSE 77101
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
77060: LD_ADDR_EXP 95
77064: PUSH
77065: LD_EXP 95
77069: PPUSH
77070: LD_VAR 0 2
77074: PPUSH
77075: LD_EXP 95
77079: PUSH
77080: LD_VAR 0 2
77084: ARRAY
77085: PPUSH
77086: LD_INT 1
77088: PPUSH
77089: CALL_OW 3
77093: PPUSH
77094: CALL_OW 1
77098: ST_TO_ADDR
77099: GO 77348
// begin if not mc_deposits_finder [ i ] then
77101: LD_EXP 96
77105: PUSH
77106: LD_VAR 0 2
77110: ARRAY
77111: NOT
77112: IFFALSE 77164
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
77114: LD_ADDR_EXP 96
77118: PUSH
77119: LD_EXP 96
77123: PPUSH
77124: LD_VAR 0 2
77128: PPUSH
77129: LD_VAR 0 3
77133: PUSH
77134: LD_INT 1
77136: ARRAY
77137: PUSH
77138: EMPTY
77139: LIST
77140: PPUSH
77141: CALL_OW 1
77145: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
77146: LD_VAR 0 3
77150: PUSH
77151: LD_INT 1
77153: ARRAY
77154: PPUSH
77155: LD_INT 125
77157: PPUSH
77158: CALL_OW 109
// end else
77162: GO 77348
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
77164: LD_EXP 96
77168: PUSH
77169: LD_VAR 0 2
77173: ARRAY
77174: PUSH
77175: LD_INT 1
77177: ARRAY
77178: PPUSH
77179: CALL_OW 310
77183: IFFALSE 77206
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
77185: LD_EXP 96
77189: PUSH
77190: LD_VAR 0 2
77194: ARRAY
77195: PUSH
77196: LD_INT 1
77198: ARRAY
77199: PPUSH
77200: CALL_OW 122
77204: GO 77348
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
77206: LD_EXP 96
77210: PUSH
77211: LD_VAR 0 2
77215: ARRAY
77216: PUSH
77217: LD_INT 1
77219: ARRAY
77220: PPUSH
77221: CALL_OW 314
77225: NOT
77226: PUSH
77227: LD_EXP 96
77231: PUSH
77232: LD_VAR 0 2
77236: ARRAY
77237: PUSH
77238: LD_INT 1
77240: ARRAY
77241: PPUSH
77242: LD_EXP 95
77246: PUSH
77247: LD_VAR 0 2
77251: ARRAY
77252: PUSH
77253: LD_INT 1
77255: ARRAY
77256: PUSH
77257: LD_INT 1
77259: ARRAY
77260: PPUSH
77261: LD_EXP 95
77265: PUSH
77266: LD_VAR 0 2
77270: ARRAY
77271: PUSH
77272: LD_INT 1
77274: ARRAY
77275: PUSH
77276: LD_INT 2
77278: ARRAY
77279: PPUSH
77280: CALL_OW 297
77284: PUSH
77285: LD_INT 6
77287: GREATER
77288: AND
77289: IFFALSE 77348
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
77291: LD_EXP 96
77295: PUSH
77296: LD_VAR 0 2
77300: ARRAY
77301: PUSH
77302: LD_INT 1
77304: ARRAY
77305: PPUSH
77306: LD_EXP 95
77310: PUSH
77311: LD_VAR 0 2
77315: ARRAY
77316: PUSH
77317: LD_INT 1
77319: ARRAY
77320: PUSH
77321: LD_INT 1
77323: ARRAY
77324: PPUSH
77325: LD_EXP 95
77329: PUSH
77330: LD_VAR 0 2
77334: ARRAY
77335: PUSH
77336: LD_INT 1
77338: ARRAY
77339: PUSH
77340: LD_INT 2
77342: ARRAY
77343: PPUSH
77344: CALL_OW 111
// end ; end ; end ;
77348: GO 76761
77350: POP
77351: POP
// end ;
77352: LD_VAR 0 1
77356: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
77357: LD_INT 0
77359: PPUSH
77360: PPUSH
77361: PPUSH
77362: PPUSH
77363: PPUSH
77364: PPUSH
77365: PPUSH
77366: PPUSH
77367: PPUSH
77368: PPUSH
77369: PPUSH
// if not mc_bases then
77370: LD_EXP 58
77374: NOT
77375: IFFALSE 77379
// exit ;
77377: GO 78103
// for i = 1 to mc_bases do
77379: LD_ADDR_VAR 0 2
77383: PUSH
77384: DOUBLE
77385: LD_INT 1
77387: DEC
77388: ST_TO_ADDR
77389: LD_EXP 58
77393: PUSH
77394: FOR_TO
77395: IFFALSE 78101
// begin if not mc_bases [ i ] then
77397: LD_EXP 58
77401: PUSH
77402: LD_VAR 0 2
77406: ARRAY
77407: NOT
77408: IFFALSE 77412
// continue ;
77410: GO 77394
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
77412: LD_ADDR_VAR 0 7
77416: PUSH
77417: LD_EXP 58
77421: PUSH
77422: LD_VAR 0 2
77426: ARRAY
77427: PUSH
77428: LD_INT 1
77430: ARRAY
77431: PPUSH
77432: CALL_OW 248
77436: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
77437: LD_VAR 0 7
77441: PUSH
77442: LD_INT 3
77444: EQUAL
77445: PUSH
77446: LD_EXP 77
77450: PUSH
77451: LD_VAR 0 2
77455: ARRAY
77456: PUSH
77457: LD_EXP 80
77461: PUSH
77462: LD_VAR 0 2
77466: ARRAY
77467: UNION
77468: PPUSH
77469: LD_INT 33
77471: PUSH
77472: LD_INT 2
77474: PUSH
77475: EMPTY
77476: LIST
77477: LIST
77478: PPUSH
77479: CALL_OW 72
77483: NOT
77484: OR
77485: IFFALSE 77489
// continue ;
77487: GO 77394
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
77489: LD_ADDR_VAR 0 9
77493: PUSH
77494: LD_EXP 58
77498: PUSH
77499: LD_VAR 0 2
77503: ARRAY
77504: PPUSH
77505: LD_INT 30
77507: PUSH
77508: LD_INT 36
77510: PUSH
77511: EMPTY
77512: LIST
77513: LIST
77514: PPUSH
77515: CALL_OW 72
77519: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
77520: LD_ADDR_VAR 0 10
77524: PUSH
77525: LD_EXP 77
77529: PUSH
77530: LD_VAR 0 2
77534: ARRAY
77535: PPUSH
77536: LD_INT 34
77538: PUSH
77539: LD_INT 31
77541: PUSH
77542: EMPTY
77543: LIST
77544: LIST
77545: PPUSH
77546: CALL_OW 72
77550: ST_TO_ADDR
// if not cts and not mcts then
77551: LD_VAR 0 9
77555: NOT
77556: PUSH
77557: LD_VAR 0 10
77561: NOT
77562: AND
77563: IFFALSE 77567
// continue ;
77565: GO 77394
// x := cts ;
77567: LD_ADDR_VAR 0 11
77571: PUSH
77572: LD_VAR 0 9
77576: ST_TO_ADDR
// if not x then
77577: LD_VAR 0 11
77581: NOT
77582: IFFALSE 77594
// x := mcts ;
77584: LD_ADDR_VAR 0 11
77588: PUSH
77589: LD_VAR 0 10
77593: ST_TO_ADDR
// if mc_remote_driver [ i ] then
77594: LD_EXP 98
77598: PUSH
77599: LD_VAR 0 2
77603: ARRAY
77604: IFFALSE 77873
// for j in mc_remote_driver [ i ] do
77606: LD_ADDR_VAR 0 3
77610: PUSH
77611: LD_EXP 98
77615: PUSH
77616: LD_VAR 0 2
77620: ARRAY
77621: PUSH
77622: FOR_IN
77623: IFFALSE 77871
// begin if GetClass ( j ) <> 3 then
77625: LD_VAR 0 3
77629: PPUSH
77630: CALL_OW 257
77634: PUSH
77635: LD_INT 3
77637: NONEQUAL
77638: IFFALSE 77691
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
77640: LD_ADDR_EXP 98
77644: PUSH
77645: LD_EXP 98
77649: PPUSH
77650: LD_VAR 0 2
77654: PPUSH
77655: LD_EXP 98
77659: PUSH
77660: LD_VAR 0 2
77664: ARRAY
77665: PUSH
77666: LD_VAR 0 3
77670: DIFF
77671: PPUSH
77672: CALL_OW 1
77676: ST_TO_ADDR
// SetTag ( j , 0 ) ;
77677: LD_VAR 0 3
77681: PPUSH
77682: LD_INT 0
77684: PPUSH
77685: CALL_OW 109
// continue ;
77689: GO 77622
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
77691: LD_VAR 0 3
77695: PPUSH
77696: CALL_OW 310
77700: NOT
77701: PUSH
77702: LD_VAR 0 3
77706: PPUSH
77707: CALL_OW 310
77711: PPUSH
77712: CALL_OW 266
77716: PUSH
77717: LD_INT 36
77719: NONEQUAL
77720: PUSH
77721: LD_VAR 0 3
77725: PPUSH
77726: CALL 54002 0 1
77730: NOT
77731: AND
77732: OR
77733: IFFALSE 77869
// begin if IsInUnit ( j ) then
77735: LD_VAR 0 3
77739: PPUSH
77740: CALL_OW 310
77744: IFFALSE 77755
// ComExitBuilding ( j ) ;
77746: LD_VAR 0 3
77750: PPUSH
77751: CALL_OW 122
// ct := 0 ;
77755: LD_ADDR_VAR 0 8
77759: PUSH
77760: LD_INT 0
77762: ST_TO_ADDR
// for k in x do
77763: LD_ADDR_VAR 0 4
77767: PUSH
77768: LD_VAR 0 11
77772: PUSH
77773: FOR_IN
77774: IFFALSE 77847
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
77776: LD_VAR 0 4
77780: PPUSH
77781: CALL_OW 264
77785: PUSH
77786: LD_INT 31
77788: EQUAL
77789: PUSH
77790: LD_VAR 0 4
77794: PPUSH
77795: CALL_OW 311
77799: NOT
77800: AND
77801: PUSH
77802: LD_VAR 0 4
77806: PPUSH
77807: CALL_OW 266
77811: PUSH
77812: LD_INT 36
77814: EQUAL
77815: PUSH
77816: LD_VAR 0 4
77820: PPUSH
77821: CALL_OW 313
77825: PUSH
77826: LD_INT 3
77828: LESS
77829: AND
77830: OR
77831: IFFALSE 77845
// begin ct := k ;
77833: LD_ADDR_VAR 0 8
77837: PUSH
77838: LD_VAR 0 4
77842: ST_TO_ADDR
// break ;
77843: GO 77847
// end ;
77845: GO 77773
77847: POP
77848: POP
// if ct then
77849: LD_VAR 0 8
77853: IFFALSE 77869
// ComEnterUnit ( j , ct ) ;
77855: LD_VAR 0 3
77859: PPUSH
77860: LD_VAR 0 8
77864: PPUSH
77865: CALL_OW 120
// end ; end ;
77869: GO 77622
77871: POP
77872: POP
// places := 0 ;
77873: LD_ADDR_VAR 0 5
77877: PUSH
77878: LD_INT 0
77880: ST_TO_ADDR
// for j = 1 to x do
77881: LD_ADDR_VAR 0 3
77885: PUSH
77886: DOUBLE
77887: LD_INT 1
77889: DEC
77890: ST_TO_ADDR
77891: LD_VAR 0 11
77895: PUSH
77896: FOR_TO
77897: IFFALSE 77952
// if GetWeapon ( x [ j ] ) = ar_control_tower then
77899: LD_VAR 0 11
77903: PUSH
77904: LD_VAR 0 3
77908: ARRAY
77909: PPUSH
77910: CALL_OW 264
77914: PUSH
77915: LD_INT 31
77917: EQUAL
77918: IFFALSE 77936
// places := places + 1 else
77920: LD_ADDR_VAR 0 5
77924: PUSH
77925: LD_VAR 0 5
77929: PUSH
77930: LD_INT 1
77932: PLUS
77933: ST_TO_ADDR
77934: GO 77950
// places := places + 3 ;
77936: LD_ADDR_VAR 0 5
77940: PUSH
77941: LD_VAR 0 5
77945: PUSH
77946: LD_INT 3
77948: PLUS
77949: ST_TO_ADDR
77950: GO 77896
77952: POP
77953: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
77954: LD_ADDR_VAR 0 6
77958: PUSH
77959: LD_EXP 58
77963: PUSH
77964: LD_VAR 0 2
77968: ARRAY
77969: PPUSH
77970: LD_INT 25
77972: PUSH
77973: LD_INT 3
77975: PUSH
77976: EMPTY
77977: LIST
77978: LIST
77979: PPUSH
77980: CALL_OW 72
77984: PUSH
77985: LD_EXP 98
77989: PUSH
77990: LD_VAR 0 2
77994: ARRAY
77995: DIFF
77996: PPUSH
77997: LD_INT 3
77999: PPUSH
78000: CALL 54902 0 2
78004: ST_TO_ADDR
// if not tmp then
78005: LD_VAR 0 6
78009: NOT
78010: IFFALSE 78014
// continue ;
78012: GO 77394
// places := places - mc_remote_driver [ i ] ;
78014: LD_ADDR_VAR 0 5
78018: PUSH
78019: LD_VAR 0 5
78023: PUSH
78024: LD_EXP 98
78028: PUSH
78029: LD_VAR 0 2
78033: ARRAY
78034: MINUS
78035: ST_TO_ADDR
// if places then
78036: LD_VAR 0 5
78040: IFFALSE 78099
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
78042: LD_ADDR_EXP 98
78046: PUSH
78047: LD_EXP 98
78051: PPUSH
78052: LD_VAR 0 2
78056: PPUSH
78057: LD_EXP 98
78061: PUSH
78062: LD_VAR 0 2
78066: ARRAY
78067: PUSH
78068: LD_VAR 0 6
78072: PUSH
78073: LD_INT 1
78075: ARRAY
78076: UNION
78077: PPUSH
78078: CALL_OW 1
78082: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
78083: LD_VAR 0 6
78087: PUSH
78088: LD_INT 1
78090: ARRAY
78091: PPUSH
78092: LD_INT 126
78094: PPUSH
78095: CALL_OW 109
// end ; end ;
78099: GO 77394
78101: POP
78102: POP
// end ;
78103: LD_VAR 0 1
78107: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
78108: LD_INT 0
78110: PPUSH
78111: PPUSH
78112: PPUSH
78113: PPUSH
78114: PPUSH
78115: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
78116: LD_VAR 0 1
78120: NOT
78121: PUSH
78122: LD_VAR 0 2
78126: NOT
78127: OR
78128: PUSH
78129: LD_VAR 0 3
78133: NOT
78134: OR
78135: PUSH
78136: LD_VAR 0 4
78140: PUSH
78141: LD_INT 1
78143: PUSH
78144: LD_INT 2
78146: PUSH
78147: LD_INT 3
78149: PUSH
78150: LD_INT 4
78152: PUSH
78153: LD_INT 5
78155: PUSH
78156: LD_INT 8
78158: PUSH
78159: LD_INT 9
78161: PUSH
78162: LD_INT 15
78164: PUSH
78165: LD_INT 16
78167: PUSH
78168: EMPTY
78169: LIST
78170: LIST
78171: LIST
78172: LIST
78173: LIST
78174: LIST
78175: LIST
78176: LIST
78177: LIST
78178: IN
78179: NOT
78180: OR
78181: IFFALSE 78185
// exit ;
78183: GO 79085
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
78185: LD_ADDR_VAR 0 2
78189: PUSH
78190: LD_VAR 0 2
78194: PPUSH
78195: LD_INT 21
78197: PUSH
78198: LD_INT 3
78200: PUSH
78201: EMPTY
78202: LIST
78203: LIST
78204: PUSH
78205: LD_INT 24
78207: PUSH
78208: LD_INT 250
78210: PUSH
78211: EMPTY
78212: LIST
78213: LIST
78214: PUSH
78215: EMPTY
78216: LIST
78217: LIST
78218: PPUSH
78219: CALL_OW 72
78223: ST_TO_ADDR
// case class of 1 , 15 :
78224: LD_VAR 0 4
78228: PUSH
78229: LD_INT 1
78231: DOUBLE
78232: EQUAL
78233: IFTRUE 78243
78235: LD_INT 15
78237: DOUBLE
78238: EQUAL
78239: IFTRUE 78243
78241: GO 78328
78243: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
78244: LD_ADDR_VAR 0 8
78248: PUSH
78249: LD_VAR 0 2
78253: PPUSH
78254: LD_INT 2
78256: PUSH
78257: LD_INT 30
78259: PUSH
78260: LD_INT 32
78262: PUSH
78263: EMPTY
78264: LIST
78265: LIST
78266: PUSH
78267: LD_INT 30
78269: PUSH
78270: LD_INT 31
78272: PUSH
78273: EMPTY
78274: LIST
78275: LIST
78276: PUSH
78277: EMPTY
78278: LIST
78279: LIST
78280: LIST
78281: PPUSH
78282: CALL_OW 72
78286: PUSH
78287: LD_VAR 0 2
78291: PPUSH
78292: LD_INT 2
78294: PUSH
78295: LD_INT 30
78297: PUSH
78298: LD_INT 4
78300: PUSH
78301: EMPTY
78302: LIST
78303: LIST
78304: PUSH
78305: LD_INT 30
78307: PUSH
78308: LD_INT 5
78310: PUSH
78311: EMPTY
78312: LIST
78313: LIST
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: LIST
78319: PPUSH
78320: CALL_OW 72
78324: ADD
78325: ST_TO_ADDR
78326: GO 78574
78328: LD_INT 2
78330: DOUBLE
78331: EQUAL
78332: IFTRUE 78342
78334: LD_INT 16
78336: DOUBLE
78337: EQUAL
78338: IFTRUE 78342
78340: GO 78388
78342: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
78343: LD_ADDR_VAR 0 8
78347: PUSH
78348: LD_VAR 0 2
78352: PPUSH
78353: LD_INT 2
78355: PUSH
78356: LD_INT 30
78358: PUSH
78359: LD_INT 0
78361: PUSH
78362: EMPTY
78363: LIST
78364: LIST
78365: PUSH
78366: LD_INT 30
78368: PUSH
78369: LD_INT 1
78371: PUSH
78372: EMPTY
78373: LIST
78374: LIST
78375: PUSH
78376: EMPTY
78377: LIST
78378: LIST
78379: LIST
78380: PPUSH
78381: CALL_OW 72
78385: ST_TO_ADDR
78386: GO 78574
78388: LD_INT 3
78390: DOUBLE
78391: EQUAL
78392: IFTRUE 78396
78394: GO 78442
78396: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
78397: LD_ADDR_VAR 0 8
78401: PUSH
78402: LD_VAR 0 2
78406: PPUSH
78407: LD_INT 2
78409: PUSH
78410: LD_INT 30
78412: PUSH
78413: LD_INT 2
78415: PUSH
78416: EMPTY
78417: LIST
78418: LIST
78419: PUSH
78420: LD_INT 30
78422: PUSH
78423: LD_INT 3
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: EMPTY
78431: LIST
78432: LIST
78433: LIST
78434: PPUSH
78435: CALL_OW 72
78439: ST_TO_ADDR
78440: GO 78574
78442: LD_INT 4
78444: DOUBLE
78445: EQUAL
78446: IFTRUE 78450
78448: GO 78507
78450: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
78451: LD_ADDR_VAR 0 8
78455: PUSH
78456: LD_VAR 0 2
78460: PPUSH
78461: LD_INT 2
78463: PUSH
78464: LD_INT 30
78466: PUSH
78467: LD_INT 6
78469: PUSH
78470: EMPTY
78471: LIST
78472: LIST
78473: PUSH
78474: LD_INT 30
78476: PUSH
78477: LD_INT 7
78479: PUSH
78480: EMPTY
78481: LIST
78482: LIST
78483: PUSH
78484: LD_INT 30
78486: PUSH
78487: LD_INT 8
78489: PUSH
78490: EMPTY
78491: LIST
78492: LIST
78493: PUSH
78494: EMPTY
78495: LIST
78496: LIST
78497: LIST
78498: LIST
78499: PPUSH
78500: CALL_OW 72
78504: ST_TO_ADDR
78505: GO 78574
78507: LD_INT 5
78509: DOUBLE
78510: EQUAL
78511: IFTRUE 78527
78513: LD_INT 8
78515: DOUBLE
78516: EQUAL
78517: IFTRUE 78527
78519: LD_INT 9
78521: DOUBLE
78522: EQUAL
78523: IFTRUE 78527
78525: GO 78573
78527: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
78528: LD_ADDR_VAR 0 8
78532: PUSH
78533: LD_VAR 0 2
78537: PPUSH
78538: LD_INT 2
78540: PUSH
78541: LD_INT 30
78543: PUSH
78544: LD_INT 4
78546: PUSH
78547: EMPTY
78548: LIST
78549: LIST
78550: PUSH
78551: LD_INT 30
78553: PUSH
78554: LD_INT 5
78556: PUSH
78557: EMPTY
78558: LIST
78559: LIST
78560: PUSH
78561: EMPTY
78562: LIST
78563: LIST
78564: LIST
78565: PPUSH
78566: CALL_OW 72
78570: ST_TO_ADDR
78571: GO 78574
78573: POP
// if not tmp then
78574: LD_VAR 0 8
78578: NOT
78579: IFFALSE 78583
// exit ;
78581: GO 79085
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
78583: LD_VAR 0 4
78587: PUSH
78588: LD_INT 1
78590: PUSH
78591: LD_INT 15
78593: PUSH
78594: EMPTY
78595: LIST
78596: LIST
78597: IN
78598: PUSH
78599: LD_EXP 67
78603: PUSH
78604: LD_VAR 0 1
78608: ARRAY
78609: AND
78610: IFFALSE 78766
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
78612: LD_ADDR_VAR 0 9
78616: PUSH
78617: LD_EXP 67
78621: PUSH
78622: LD_VAR 0 1
78626: ARRAY
78627: PUSH
78628: LD_INT 1
78630: ARRAY
78631: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
78632: LD_VAR 0 9
78636: PUSH
78637: LD_EXP 68
78641: PUSH
78642: LD_VAR 0 1
78646: ARRAY
78647: IN
78648: NOT
78649: IFFALSE 78764
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
78651: LD_ADDR_EXP 68
78655: PUSH
78656: LD_EXP 68
78660: PPUSH
78661: LD_VAR 0 1
78665: PUSH
78666: LD_EXP 68
78670: PUSH
78671: LD_VAR 0 1
78675: ARRAY
78676: PUSH
78677: LD_INT 1
78679: PLUS
78680: PUSH
78681: EMPTY
78682: LIST
78683: LIST
78684: PPUSH
78685: LD_VAR 0 9
78689: PPUSH
78690: CALL 20654 0 3
78694: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
78695: LD_ADDR_EXP 67
78699: PUSH
78700: LD_EXP 67
78704: PPUSH
78705: LD_VAR 0 1
78709: PPUSH
78710: LD_EXP 67
78714: PUSH
78715: LD_VAR 0 1
78719: ARRAY
78720: PUSH
78721: LD_VAR 0 9
78725: DIFF
78726: PPUSH
78727: CALL_OW 1
78731: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
78732: LD_VAR 0 3
78736: PPUSH
78737: LD_EXP 68
78741: PUSH
78742: LD_VAR 0 1
78746: ARRAY
78747: PUSH
78748: LD_EXP 68
78752: PUSH
78753: LD_VAR 0 1
78757: ARRAY
78758: ARRAY
78759: PPUSH
78760: CALL_OW 120
// end ; exit ;
78764: GO 79085
// end ; if tmp > 1 then
78766: LD_VAR 0 8
78770: PUSH
78771: LD_INT 1
78773: GREATER
78774: IFFALSE 78878
// for i = 2 to tmp do
78776: LD_ADDR_VAR 0 6
78780: PUSH
78781: DOUBLE
78782: LD_INT 2
78784: DEC
78785: ST_TO_ADDR
78786: LD_VAR 0 8
78790: PUSH
78791: FOR_TO
78792: IFFALSE 78876
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
78794: LD_VAR 0 8
78798: PUSH
78799: LD_VAR 0 6
78803: ARRAY
78804: PPUSH
78805: CALL_OW 461
78809: PUSH
78810: LD_INT 6
78812: EQUAL
78813: IFFALSE 78874
// begin x := tmp [ i ] ;
78815: LD_ADDR_VAR 0 9
78819: PUSH
78820: LD_VAR 0 8
78824: PUSH
78825: LD_VAR 0 6
78829: ARRAY
78830: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
78831: LD_ADDR_VAR 0 8
78835: PUSH
78836: LD_VAR 0 8
78840: PPUSH
78841: LD_VAR 0 6
78845: PPUSH
78846: CALL_OW 3
78850: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
78851: LD_ADDR_VAR 0 8
78855: PUSH
78856: LD_VAR 0 8
78860: PPUSH
78861: LD_INT 1
78863: PPUSH
78864: LD_VAR 0 9
78868: PPUSH
78869: CALL_OW 2
78873: ST_TO_ADDR
// end ;
78874: GO 78791
78876: POP
78877: POP
// for i in tmp do
78878: LD_ADDR_VAR 0 6
78882: PUSH
78883: LD_VAR 0 8
78887: PUSH
78888: FOR_IN
78889: IFFALSE 78958
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
78891: LD_VAR 0 6
78895: PPUSH
78896: CALL_OW 313
78900: PUSH
78901: LD_INT 6
78903: LESS
78904: PUSH
78905: LD_VAR 0 6
78909: PPUSH
78910: CALL_OW 266
78914: PUSH
78915: LD_INT 31
78917: PUSH
78918: LD_INT 32
78920: PUSH
78921: EMPTY
78922: LIST
78923: LIST
78924: IN
78925: NOT
78926: AND
78927: PUSH
78928: LD_VAR 0 6
78932: PPUSH
78933: CALL_OW 313
78937: PUSH
78938: LD_INT 0
78940: EQUAL
78941: OR
78942: IFFALSE 78956
// begin j := i ;
78944: LD_ADDR_VAR 0 7
78948: PUSH
78949: LD_VAR 0 6
78953: ST_TO_ADDR
// break ;
78954: GO 78958
// end ; end ;
78956: GO 78888
78958: POP
78959: POP
// if j then
78960: LD_VAR 0 7
78964: IFFALSE 78982
// ComEnterUnit ( unit , j ) else
78966: LD_VAR 0 3
78970: PPUSH
78971: LD_VAR 0 7
78975: PPUSH
78976: CALL_OW 120
78980: GO 79085
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78982: LD_ADDR_VAR 0 10
78986: PUSH
78987: LD_VAR 0 2
78991: PPUSH
78992: LD_INT 2
78994: PUSH
78995: LD_INT 30
78997: PUSH
78998: LD_INT 0
79000: PUSH
79001: EMPTY
79002: LIST
79003: LIST
79004: PUSH
79005: LD_INT 30
79007: PUSH
79008: LD_INT 1
79010: PUSH
79011: EMPTY
79012: LIST
79013: LIST
79014: PUSH
79015: EMPTY
79016: LIST
79017: LIST
79018: LIST
79019: PPUSH
79020: CALL_OW 72
79024: ST_TO_ADDR
// if depot then
79025: LD_VAR 0 10
79029: IFFALSE 79085
// begin depot := NearestUnitToUnit ( depot , unit ) ;
79031: LD_ADDR_VAR 0 10
79035: PUSH
79036: LD_VAR 0 10
79040: PPUSH
79041: LD_VAR 0 3
79045: PPUSH
79046: CALL_OW 74
79050: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
79051: LD_VAR 0 3
79055: PPUSH
79056: LD_VAR 0 10
79060: PPUSH
79061: CALL_OW 296
79065: PUSH
79066: LD_INT 10
79068: GREATER
79069: IFFALSE 79085
// ComStandNearbyBuilding ( unit , depot ) ;
79071: LD_VAR 0 3
79075: PPUSH
79076: LD_VAR 0 10
79080: PPUSH
79081: CALL 15361 0 2
// end ; end ; end ;
79085: LD_VAR 0 5
79089: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
79090: LD_INT 0
79092: PPUSH
79093: PPUSH
79094: PPUSH
79095: PPUSH
// if not mc_bases then
79096: LD_EXP 58
79100: NOT
79101: IFFALSE 79105
// exit ;
79103: GO 79344
// for i = 1 to mc_bases do
79105: LD_ADDR_VAR 0 2
79109: PUSH
79110: DOUBLE
79111: LD_INT 1
79113: DEC
79114: ST_TO_ADDR
79115: LD_EXP 58
79119: PUSH
79120: FOR_TO
79121: IFFALSE 79342
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
79123: LD_ADDR_VAR 0 4
79127: PUSH
79128: LD_EXP 58
79132: PUSH
79133: LD_VAR 0 2
79137: ARRAY
79138: PPUSH
79139: LD_INT 21
79141: PUSH
79142: LD_INT 1
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PPUSH
79149: CALL_OW 72
79153: PUSH
79154: LD_EXP 87
79158: PUSH
79159: LD_VAR 0 2
79163: ARRAY
79164: UNION
79165: ST_TO_ADDR
// if not tmp then
79166: LD_VAR 0 4
79170: NOT
79171: IFFALSE 79175
// continue ;
79173: GO 79120
// for j in tmp do
79175: LD_ADDR_VAR 0 3
79179: PUSH
79180: LD_VAR 0 4
79184: PUSH
79185: FOR_IN
79186: IFFALSE 79338
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
79188: LD_VAR 0 3
79192: PPUSH
79193: CALL_OW 110
79197: NOT
79198: PUSH
79199: LD_VAR 0 3
79203: PPUSH
79204: CALL_OW 314
79208: NOT
79209: AND
79210: PUSH
79211: LD_VAR 0 3
79215: PPUSH
79216: CALL_OW 311
79220: NOT
79221: AND
79222: PUSH
79223: LD_VAR 0 3
79227: PPUSH
79228: CALL_OW 310
79232: NOT
79233: AND
79234: PUSH
79235: LD_VAR 0 3
79239: PUSH
79240: LD_EXP 61
79244: PUSH
79245: LD_VAR 0 2
79249: ARRAY
79250: PUSH
79251: LD_INT 1
79253: ARRAY
79254: IN
79255: NOT
79256: AND
79257: PUSH
79258: LD_VAR 0 3
79262: PUSH
79263: LD_EXP 61
79267: PUSH
79268: LD_VAR 0 2
79272: ARRAY
79273: PUSH
79274: LD_INT 2
79276: ARRAY
79277: IN
79278: NOT
79279: AND
79280: PUSH
79281: LD_VAR 0 3
79285: PUSH
79286: LD_EXP 70
79290: PUSH
79291: LD_VAR 0 2
79295: ARRAY
79296: IN
79297: NOT
79298: AND
79299: IFFALSE 79336
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
79301: LD_VAR 0 2
79305: PPUSH
79306: LD_EXP 58
79310: PUSH
79311: LD_VAR 0 2
79315: ARRAY
79316: PPUSH
79317: LD_VAR 0 3
79321: PPUSH
79322: LD_VAR 0 3
79326: PPUSH
79327: CALL_OW 257
79331: PPUSH
79332: CALL 78108 0 4
// end ;
79336: GO 79185
79338: POP
79339: POP
// end ;
79340: GO 79120
79342: POP
79343: POP
// end ;
79344: LD_VAR 0 1
79348: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
79349: LD_INT 0
79351: PPUSH
79352: PPUSH
79353: PPUSH
79354: PPUSH
79355: PPUSH
79356: PPUSH
// if not mc_bases [ base ] then
79357: LD_EXP 58
79361: PUSH
79362: LD_VAR 0 1
79366: ARRAY
79367: NOT
79368: IFFALSE 79372
// exit ;
79370: GO 79554
// tmp := [ ] ;
79372: LD_ADDR_VAR 0 6
79376: PUSH
79377: EMPTY
79378: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
79379: LD_ADDR_VAR 0 7
79383: PUSH
79384: LD_VAR 0 3
79388: PPUSH
79389: LD_INT 0
79391: PPUSH
79392: CALL_OW 517
79396: ST_TO_ADDR
// if not list then
79397: LD_VAR 0 7
79401: NOT
79402: IFFALSE 79406
// exit ;
79404: GO 79554
// for i = 1 to amount do
79406: LD_ADDR_VAR 0 5
79410: PUSH
79411: DOUBLE
79412: LD_INT 1
79414: DEC
79415: ST_TO_ADDR
79416: LD_VAR 0 2
79420: PUSH
79421: FOR_TO
79422: IFFALSE 79502
// begin x := rand ( 1 , list [ 1 ] ) ;
79424: LD_ADDR_VAR 0 8
79428: PUSH
79429: LD_INT 1
79431: PPUSH
79432: LD_VAR 0 7
79436: PUSH
79437: LD_INT 1
79439: ARRAY
79440: PPUSH
79441: CALL_OW 12
79445: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
79446: LD_ADDR_VAR 0 6
79450: PUSH
79451: LD_VAR 0 6
79455: PPUSH
79456: LD_VAR 0 5
79460: PPUSH
79461: LD_VAR 0 7
79465: PUSH
79466: LD_INT 1
79468: ARRAY
79469: PUSH
79470: LD_VAR 0 8
79474: ARRAY
79475: PUSH
79476: LD_VAR 0 7
79480: PUSH
79481: LD_INT 2
79483: ARRAY
79484: PUSH
79485: LD_VAR 0 8
79489: ARRAY
79490: PUSH
79491: EMPTY
79492: LIST
79493: LIST
79494: PPUSH
79495: CALL_OW 1
79499: ST_TO_ADDR
// end ;
79500: GO 79421
79502: POP
79503: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
79504: LD_ADDR_EXP 71
79508: PUSH
79509: LD_EXP 71
79513: PPUSH
79514: LD_VAR 0 1
79518: PPUSH
79519: LD_VAR 0 6
79523: PPUSH
79524: CALL_OW 1
79528: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
79529: LD_ADDR_EXP 73
79533: PUSH
79534: LD_EXP 73
79538: PPUSH
79539: LD_VAR 0 1
79543: PPUSH
79544: LD_VAR 0 3
79548: PPUSH
79549: CALL_OW 1
79553: ST_TO_ADDR
// end ;
79554: LD_VAR 0 4
79558: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
79559: LD_INT 0
79561: PPUSH
// if not mc_bases [ base ] then
79562: LD_EXP 58
79566: PUSH
79567: LD_VAR 0 1
79571: ARRAY
79572: NOT
79573: IFFALSE 79577
// exit ;
79575: GO 79602
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
79577: LD_ADDR_EXP 63
79581: PUSH
79582: LD_EXP 63
79586: PPUSH
79587: LD_VAR 0 1
79591: PPUSH
79592: LD_VAR 0 2
79596: PPUSH
79597: CALL_OW 1
79601: ST_TO_ADDR
// end ;
79602: LD_VAR 0 3
79606: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
79607: LD_INT 0
79609: PPUSH
// if not mc_bases [ base ] then
79610: LD_EXP 58
79614: PUSH
79615: LD_VAR 0 1
79619: ARRAY
79620: NOT
79621: IFFALSE 79625
// exit ;
79623: GO 79662
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
79625: LD_ADDR_EXP 63
79629: PUSH
79630: LD_EXP 63
79634: PPUSH
79635: LD_VAR 0 1
79639: PPUSH
79640: LD_EXP 63
79644: PUSH
79645: LD_VAR 0 1
79649: ARRAY
79650: PUSH
79651: LD_VAR 0 2
79655: UNION
79656: PPUSH
79657: CALL_OW 1
79661: ST_TO_ADDR
// end ;
79662: LD_VAR 0 3
79666: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
79667: LD_INT 0
79669: PPUSH
// if not mc_bases [ base ] then
79670: LD_EXP 58
79674: PUSH
79675: LD_VAR 0 1
79679: ARRAY
79680: NOT
79681: IFFALSE 79685
// exit ;
79683: GO 79710
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
79685: LD_ADDR_EXP 79
79689: PUSH
79690: LD_EXP 79
79694: PPUSH
79695: LD_VAR 0 1
79699: PPUSH
79700: LD_VAR 0 2
79704: PPUSH
79705: CALL_OW 1
79709: ST_TO_ADDR
// end ;
79710: LD_VAR 0 3
79714: RET
// export function MC_InsertProduceList ( base , components ) ; begin
79715: LD_INT 0
79717: PPUSH
// if not mc_bases [ base ] then
79718: LD_EXP 58
79722: PUSH
79723: LD_VAR 0 1
79727: ARRAY
79728: NOT
79729: IFFALSE 79733
// exit ;
79731: GO 79770
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
79733: LD_ADDR_EXP 79
79737: PUSH
79738: LD_EXP 79
79742: PPUSH
79743: LD_VAR 0 1
79747: PPUSH
79748: LD_EXP 79
79752: PUSH
79753: LD_VAR 0 1
79757: ARRAY
79758: PUSH
79759: LD_VAR 0 2
79763: ADD
79764: PPUSH
79765: CALL_OW 1
79769: ST_TO_ADDR
// end ;
79770: LD_VAR 0 3
79774: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
79775: LD_INT 0
79777: PPUSH
// if not mc_bases [ base ] then
79778: LD_EXP 58
79782: PUSH
79783: LD_VAR 0 1
79787: ARRAY
79788: NOT
79789: IFFALSE 79793
// exit ;
79791: GO 79847
// mc_defender := Replace ( mc_defender , base , deflist ) ;
79793: LD_ADDR_EXP 80
79797: PUSH
79798: LD_EXP 80
79802: PPUSH
79803: LD_VAR 0 1
79807: PPUSH
79808: LD_VAR 0 2
79812: PPUSH
79813: CALL_OW 1
79817: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
79818: LD_ADDR_EXP 69
79822: PUSH
79823: LD_EXP 69
79827: PPUSH
79828: LD_VAR 0 1
79832: PPUSH
79833: LD_VAR 0 2
79837: PUSH
79838: LD_INT 0
79840: PLUS
79841: PPUSH
79842: CALL_OW 1
79846: ST_TO_ADDR
// end ;
79847: LD_VAR 0 3
79851: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
79852: LD_INT 0
79854: PPUSH
// if not mc_bases [ base ] then
79855: LD_EXP 58
79859: PUSH
79860: LD_VAR 0 1
79864: ARRAY
79865: NOT
79866: IFFALSE 79870
// exit ;
79868: GO 79895
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
79870: LD_ADDR_EXP 69
79874: PUSH
79875: LD_EXP 69
79879: PPUSH
79880: LD_VAR 0 1
79884: PPUSH
79885: LD_VAR 0 2
79889: PPUSH
79890: CALL_OW 1
79894: ST_TO_ADDR
// end ;
79895: LD_VAR 0 3
79899: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
79900: LD_INT 0
79902: PPUSH
79903: PPUSH
79904: PPUSH
79905: PPUSH
// if not mc_bases [ base ] then
79906: LD_EXP 58
79910: PUSH
79911: LD_VAR 0 1
79915: ARRAY
79916: NOT
79917: IFFALSE 79921
// exit ;
79919: GO 79986
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
79921: LD_ADDR_EXP 78
79925: PUSH
79926: LD_EXP 78
79930: PPUSH
79931: LD_VAR 0 1
79935: PUSH
79936: LD_EXP 78
79940: PUSH
79941: LD_VAR 0 1
79945: ARRAY
79946: PUSH
79947: LD_INT 1
79949: PLUS
79950: PUSH
79951: EMPTY
79952: LIST
79953: LIST
79954: PPUSH
79955: LD_VAR 0 1
79959: PUSH
79960: LD_VAR 0 2
79964: PUSH
79965: LD_VAR 0 3
79969: PUSH
79970: LD_VAR 0 4
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: LIST
79979: LIST
79980: PPUSH
79981: CALL 20654 0 3
79985: ST_TO_ADDR
// end ;
79986: LD_VAR 0 5
79990: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
79991: LD_INT 0
79993: PPUSH
// if not mc_bases [ base ] then
79994: LD_EXP 58
79998: PUSH
79999: LD_VAR 0 1
80003: ARRAY
80004: NOT
80005: IFFALSE 80009
// exit ;
80007: GO 80034
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
80009: LD_ADDR_EXP 95
80013: PUSH
80014: LD_EXP 95
80018: PPUSH
80019: LD_VAR 0 1
80023: PPUSH
80024: LD_VAR 0 2
80028: PPUSH
80029: CALL_OW 1
80033: ST_TO_ADDR
// end ;
80034: LD_VAR 0 3
80038: RET
// export function MC_GetMinesField ( base ) ; begin
80039: LD_INT 0
80041: PPUSH
// result := mc_mines [ base ] ;
80042: LD_ADDR_VAR 0 2
80046: PUSH
80047: LD_EXP 71
80051: PUSH
80052: LD_VAR 0 1
80056: ARRAY
80057: ST_TO_ADDR
// end ;
80058: LD_VAR 0 2
80062: RET
// export function MC_GetProduceList ( base ) ; begin
80063: LD_INT 0
80065: PPUSH
// result := mc_produce [ base ] ;
80066: LD_ADDR_VAR 0 2
80070: PUSH
80071: LD_EXP 79
80075: PUSH
80076: LD_VAR 0 1
80080: ARRAY
80081: ST_TO_ADDR
// end ;
80082: LD_VAR 0 2
80086: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
80087: LD_INT 0
80089: PPUSH
80090: PPUSH
// if not mc_bases then
80091: LD_EXP 58
80095: NOT
80096: IFFALSE 80100
// exit ;
80098: GO 80165
// if mc_bases [ base ] then
80100: LD_EXP 58
80104: PUSH
80105: LD_VAR 0 1
80109: ARRAY
80110: IFFALSE 80165
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80112: LD_ADDR_VAR 0 3
80116: PUSH
80117: LD_EXP 58
80121: PUSH
80122: LD_VAR 0 1
80126: ARRAY
80127: PPUSH
80128: LD_INT 30
80130: PUSH
80131: LD_VAR 0 2
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: PPUSH
80140: CALL_OW 72
80144: ST_TO_ADDR
// if result then
80145: LD_VAR 0 3
80149: IFFALSE 80165
// result := result [ 1 ] ;
80151: LD_ADDR_VAR 0 3
80155: PUSH
80156: LD_VAR 0 3
80160: PUSH
80161: LD_INT 1
80163: ARRAY
80164: ST_TO_ADDR
// end ; end ;
80165: LD_VAR 0 3
80169: RET
// export function MC_SetTame ( base , area ) ; begin
80170: LD_INT 0
80172: PPUSH
// if not mc_bases or not base then
80173: LD_EXP 58
80177: NOT
80178: PUSH
80179: LD_VAR 0 1
80183: NOT
80184: OR
80185: IFFALSE 80189
// exit ;
80187: GO 80214
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
80189: LD_ADDR_EXP 86
80193: PUSH
80194: LD_EXP 86
80198: PPUSH
80199: LD_VAR 0 1
80203: PPUSH
80204: LD_VAR 0 2
80208: PPUSH
80209: CALL_OW 1
80213: ST_TO_ADDR
// end ;
80214: LD_VAR 0 3
80218: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
80219: LD_INT 0
80221: PPUSH
80222: PPUSH
// if not mc_bases or not base then
80223: LD_EXP 58
80227: NOT
80228: PUSH
80229: LD_VAR 0 1
80233: NOT
80234: OR
80235: IFFALSE 80239
// exit ;
80237: GO 80341
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80239: LD_ADDR_VAR 0 4
80243: PUSH
80244: LD_EXP 58
80248: PUSH
80249: LD_VAR 0 1
80253: ARRAY
80254: PPUSH
80255: LD_INT 30
80257: PUSH
80258: LD_VAR 0 2
80262: PUSH
80263: EMPTY
80264: LIST
80265: LIST
80266: PPUSH
80267: CALL_OW 72
80271: ST_TO_ADDR
// if not tmp then
80272: LD_VAR 0 4
80276: NOT
80277: IFFALSE 80281
// exit ;
80279: GO 80341
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
80281: LD_ADDR_EXP 90
80285: PUSH
80286: LD_EXP 90
80290: PPUSH
80291: LD_VAR 0 1
80295: PPUSH
80296: LD_EXP 90
80300: PUSH
80301: LD_VAR 0 1
80305: ARRAY
80306: PPUSH
80307: LD_EXP 90
80311: PUSH
80312: LD_VAR 0 1
80316: ARRAY
80317: PUSH
80318: LD_INT 1
80320: PLUS
80321: PPUSH
80322: LD_VAR 0 4
80326: PUSH
80327: LD_INT 1
80329: ARRAY
80330: PPUSH
80331: CALL_OW 2
80335: PPUSH
80336: CALL_OW 1
80340: ST_TO_ADDR
// end ;
80341: LD_VAR 0 3
80345: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
80346: LD_INT 0
80348: PPUSH
80349: PPUSH
// if not mc_bases or not base or not kinds then
80350: LD_EXP 58
80354: NOT
80355: PUSH
80356: LD_VAR 0 1
80360: NOT
80361: OR
80362: PUSH
80363: LD_VAR 0 2
80367: NOT
80368: OR
80369: IFFALSE 80373
// exit ;
80371: GO 80434
// for i in kinds do
80373: LD_ADDR_VAR 0 4
80377: PUSH
80378: LD_VAR 0 2
80382: PUSH
80383: FOR_IN
80384: IFFALSE 80432
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
80386: LD_ADDR_EXP 92
80390: PUSH
80391: LD_EXP 92
80395: PPUSH
80396: LD_VAR 0 1
80400: PUSH
80401: LD_EXP 92
80405: PUSH
80406: LD_VAR 0 1
80410: ARRAY
80411: PUSH
80412: LD_INT 1
80414: PLUS
80415: PUSH
80416: EMPTY
80417: LIST
80418: LIST
80419: PPUSH
80420: LD_VAR 0 4
80424: PPUSH
80425: CALL 20654 0 3
80429: ST_TO_ADDR
80430: GO 80383
80432: POP
80433: POP
// end ;
80434: LD_VAR 0 3
80438: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
80439: LD_INT 0
80441: PPUSH
// if not mc_bases or not base or not areas then
80442: LD_EXP 58
80446: NOT
80447: PUSH
80448: LD_VAR 0 1
80452: NOT
80453: OR
80454: PUSH
80455: LD_VAR 0 2
80459: NOT
80460: OR
80461: IFFALSE 80465
// exit ;
80463: GO 80490
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
80465: LD_ADDR_EXP 76
80469: PUSH
80470: LD_EXP 76
80474: PPUSH
80475: LD_VAR 0 1
80479: PPUSH
80480: LD_VAR 0 2
80484: PPUSH
80485: CALL_OW 1
80489: ST_TO_ADDR
// end ;
80490: LD_VAR 0 3
80494: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
80495: LD_INT 0
80497: PPUSH
// if not mc_bases or not base or not teleports_exit then
80498: LD_EXP 58
80502: NOT
80503: PUSH
80504: LD_VAR 0 1
80508: NOT
80509: OR
80510: PUSH
80511: LD_VAR 0 2
80515: NOT
80516: OR
80517: IFFALSE 80521
// exit ;
80519: GO 80546
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
80521: LD_ADDR_EXP 93
80525: PUSH
80526: LD_EXP 93
80530: PPUSH
80531: LD_VAR 0 1
80535: PPUSH
80536: LD_VAR 0 2
80540: PPUSH
80541: CALL_OW 1
80545: ST_TO_ADDR
// end ;
80546: LD_VAR 0 3
80550: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
80551: LD_INT 0
80553: PPUSH
80554: PPUSH
80555: PPUSH
// if not mc_bases or not base or not ext_list then
80556: LD_EXP 58
80560: NOT
80561: PUSH
80562: LD_VAR 0 1
80566: NOT
80567: OR
80568: PUSH
80569: LD_VAR 0 5
80573: NOT
80574: OR
80575: IFFALSE 80579
// exit ;
80577: GO 80752
// tmp := GetFacExtXYD ( x , y , d ) ;
80579: LD_ADDR_VAR 0 8
80583: PUSH
80584: LD_VAR 0 2
80588: PPUSH
80589: LD_VAR 0 3
80593: PPUSH
80594: LD_VAR 0 4
80598: PPUSH
80599: CALL 54032 0 3
80603: ST_TO_ADDR
// if not tmp then
80604: LD_VAR 0 8
80608: NOT
80609: IFFALSE 80613
// exit ;
80611: GO 80752
// for i in tmp do
80613: LD_ADDR_VAR 0 7
80617: PUSH
80618: LD_VAR 0 8
80622: PUSH
80623: FOR_IN
80624: IFFALSE 80750
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
80626: LD_ADDR_EXP 63
80630: PUSH
80631: LD_EXP 63
80635: PPUSH
80636: LD_VAR 0 1
80640: PPUSH
80641: LD_EXP 63
80645: PUSH
80646: LD_VAR 0 1
80650: ARRAY
80651: PPUSH
80652: LD_EXP 63
80656: PUSH
80657: LD_VAR 0 1
80661: ARRAY
80662: PUSH
80663: LD_INT 1
80665: PLUS
80666: PPUSH
80667: LD_VAR 0 5
80671: PUSH
80672: LD_INT 1
80674: ARRAY
80675: PUSH
80676: LD_VAR 0 7
80680: PUSH
80681: LD_INT 1
80683: ARRAY
80684: PUSH
80685: LD_VAR 0 7
80689: PUSH
80690: LD_INT 2
80692: ARRAY
80693: PUSH
80694: LD_VAR 0 7
80698: PUSH
80699: LD_INT 3
80701: ARRAY
80702: PUSH
80703: EMPTY
80704: LIST
80705: LIST
80706: LIST
80707: LIST
80708: PPUSH
80709: CALL_OW 2
80713: PPUSH
80714: CALL_OW 1
80718: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
80719: LD_ADDR_VAR 0 5
80723: PUSH
80724: LD_VAR 0 5
80728: PPUSH
80729: LD_INT 1
80731: PPUSH
80732: CALL_OW 3
80736: ST_TO_ADDR
// if not ext_list then
80737: LD_VAR 0 5
80741: NOT
80742: IFFALSE 80748
// exit ;
80744: POP
80745: POP
80746: GO 80752
// end ;
80748: GO 80623
80750: POP
80751: POP
// end ;
80752: LD_VAR 0 6
80756: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
80757: LD_INT 0
80759: PPUSH
// if not mc_bases or not base or not weapon_list then
80760: LD_EXP 58
80764: NOT
80765: PUSH
80766: LD_VAR 0 1
80770: NOT
80771: OR
80772: PUSH
80773: LD_VAR 0 2
80777: NOT
80778: OR
80779: IFFALSE 80783
// exit ;
80781: GO 80808
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
80783: LD_ADDR_EXP 97
80787: PUSH
80788: LD_EXP 97
80792: PPUSH
80793: LD_VAR 0 1
80797: PPUSH
80798: LD_VAR 0 2
80802: PPUSH
80803: CALL_OW 1
80807: ST_TO_ADDR
// end ;
80808: LD_VAR 0 3
80812: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
80813: LD_INT 0
80815: PPUSH
// if not mc_bases or not base or not tech_list then
80816: LD_EXP 58
80820: NOT
80821: PUSH
80822: LD_VAR 0 1
80826: NOT
80827: OR
80828: PUSH
80829: LD_VAR 0 2
80833: NOT
80834: OR
80835: IFFALSE 80839
// exit ;
80837: GO 80864
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
80839: LD_ADDR_EXP 85
80843: PUSH
80844: LD_EXP 85
80848: PPUSH
80849: LD_VAR 0 1
80853: PPUSH
80854: LD_VAR 0 2
80858: PPUSH
80859: CALL_OW 1
80863: ST_TO_ADDR
// end ;
80864: LD_VAR 0 3
80868: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
80869: LD_INT 0
80871: PPUSH
// if not mc_bases or not parking_area or not base then
80872: LD_EXP 58
80876: NOT
80877: PUSH
80878: LD_VAR 0 2
80882: NOT
80883: OR
80884: PUSH
80885: LD_VAR 0 1
80889: NOT
80890: OR
80891: IFFALSE 80895
// exit ;
80893: GO 80920
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
80895: LD_ADDR_EXP 82
80899: PUSH
80900: LD_EXP 82
80904: PPUSH
80905: LD_VAR 0 1
80909: PPUSH
80910: LD_VAR 0 2
80914: PPUSH
80915: CALL_OW 1
80919: ST_TO_ADDR
// end ;
80920: LD_VAR 0 3
80924: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
80925: LD_INT 0
80927: PPUSH
// if not mc_bases or not base or not scan_area then
80928: LD_EXP 58
80932: NOT
80933: PUSH
80934: LD_VAR 0 1
80938: NOT
80939: OR
80940: PUSH
80941: LD_VAR 0 2
80945: NOT
80946: OR
80947: IFFALSE 80951
// exit ;
80949: GO 80976
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
80951: LD_ADDR_EXP 83
80955: PUSH
80956: LD_EXP 83
80960: PPUSH
80961: LD_VAR 0 1
80965: PPUSH
80966: LD_VAR 0 2
80970: PPUSH
80971: CALL_OW 1
80975: ST_TO_ADDR
// end ;
80976: LD_VAR 0 3
80980: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
80981: LD_INT 0
80983: PPUSH
80984: PPUSH
// if not mc_bases or not base then
80985: LD_EXP 58
80989: NOT
80990: PUSH
80991: LD_VAR 0 1
80995: NOT
80996: OR
80997: IFFALSE 81001
// exit ;
80999: GO 81065
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
81001: LD_ADDR_VAR 0 3
81005: PUSH
81006: LD_INT 1
81008: PUSH
81009: LD_INT 2
81011: PUSH
81012: LD_INT 3
81014: PUSH
81015: LD_INT 4
81017: PUSH
81018: LD_INT 11
81020: PUSH
81021: EMPTY
81022: LIST
81023: LIST
81024: LIST
81025: LIST
81026: LIST
81027: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
81028: LD_ADDR_EXP 85
81032: PUSH
81033: LD_EXP 85
81037: PPUSH
81038: LD_VAR 0 1
81042: PPUSH
81043: LD_EXP 85
81047: PUSH
81048: LD_VAR 0 1
81052: ARRAY
81053: PUSH
81054: LD_VAR 0 3
81058: DIFF
81059: PPUSH
81060: CALL_OW 1
81064: ST_TO_ADDR
// end ;
81065: LD_VAR 0 2
81069: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
81070: LD_INT 0
81072: PPUSH
// result := mc_vehicles [ base ] ;
81073: LD_ADDR_VAR 0 3
81077: PUSH
81078: LD_EXP 77
81082: PUSH
81083: LD_VAR 0 1
81087: ARRAY
81088: ST_TO_ADDR
// if onlyCombat then
81089: LD_VAR 0 2
81093: IFFALSE 81258
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
81095: LD_ADDR_VAR 0 3
81099: PUSH
81100: LD_VAR 0 3
81104: PUSH
81105: LD_VAR 0 3
81109: PPUSH
81110: LD_INT 2
81112: PUSH
81113: LD_INT 34
81115: PUSH
81116: LD_INT 12
81118: PUSH
81119: EMPTY
81120: LIST
81121: LIST
81122: PUSH
81123: LD_INT 34
81125: PUSH
81126: LD_INT 51
81128: PUSH
81129: EMPTY
81130: LIST
81131: LIST
81132: PUSH
81133: LD_INT 34
81135: PUSH
81136: LD_EXP 102
81140: PUSH
81141: EMPTY
81142: LIST
81143: LIST
81144: PUSH
81145: LD_INT 34
81147: PUSH
81148: LD_INT 32
81150: PUSH
81151: EMPTY
81152: LIST
81153: LIST
81154: PUSH
81155: LD_INT 34
81157: PUSH
81158: LD_INT 13
81160: PUSH
81161: EMPTY
81162: LIST
81163: LIST
81164: PUSH
81165: LD_INT 34
81167: PUSH
81168: LD_INT 52
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: PUSH
81175: LD_INT 34
81177: PUSH
81178: LD_INT 14
81180: PUSH
81181: EMPTY
81182: LIST
81183: LIST
81184: PUSH
81185: LD_INT 34
81187: PUSH
81188: LD_INT 53
81190: PUSH
81191: EMPTY
81192: LIST
81193: LIST
81194: PUSH
81195: LD_INT 34
81197: PUSH
81198: LD_EXP 101
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PUSH
81207: LD_INT 34
81209: PUSH
81210: LD_INT 31
81212: PUSH
81213: EMPTY
81214: LIST
81215: LIST
81216: PUSH
81217: LD_INT 34
81219: PUSH
81220: LD_INT 48
81222: PUSH
81223: EMPTY
81224: LIST
81225: LIST
81226: PUSH
81227: LD_INT 34
81229: PUSH
81230: LD_INT 8
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: EMPTY
81238: LIST
81239: LIST
81240: LIST
81241: LIST
81242: LIST
81243: LIST
81244: LIST
81245: LIST
81246: LIST
81247: LIST
81248: LIST
81249: LIST
81250: LIST
81251: PPUSH
81252: CALL_OW 72
81256: DIFF
81257: ST_TO_ADDR
// end ; end_of_file
81258: LD_VAR 0 3
81262: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
81263: LD_INT 0
81265: PPUSH
81266: PPUSH
81267: PPUSH
// if not mc_bases or not skirmish then
81268: LD_EXP 58
81272: NOT
81273: PUSH
81274: LD_EXP 56
81278: NOT
81279: OR
81280: IFFALSE 81284
// exit ;
81282: GO 81449
// for i = 1 to mc_bases do
81284: LD_ADDR_VAR 0 4
81288: PUSH
81289: DOUBLE
81290: LD_INT 1
81292: DEC
81293: ST_TO_ADDR
81294: LD_EXP 58
81298: PUSH
81299: FOR_TO
81300: IFFALSE 81447
// begin if sci in mc_bases [ i ] then
81302: LD_VAR 0 2
81306: PUSH
81307: LD_EXP 58
81311: PUSH
81312: LD_VAR 0 4
81316: ARRAY
81317: IN
81318: IFFALSE 81445
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
81320: LD_ADDR_EXP 87
81324: PUSH
81325: LD_EXP 87
81329: PPUSH
81330: LD_VAR 0 4
81334: PUSH
81335: LD_EXP 87
81339: PUSH
81340: LD_VAR 0 4
81344: ARRAY
81345: PUSH
81346: LD_INT 1
81348: PLUS
81349: PUSH
81350: EMPTY
81351: LIST
81352: LIST
81353: PPUSH
81354: LD_VAR 0 1
81358: PPUSH
81359: CALL 20654 0 3
81363: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
81364: LD_ADDR_VAR 0 5
81368: PUSH
81369: LD_EXP 58
81373: PUSH
81374: LD_VAR 0 4
81378: ARRAY
81379: PPUSH
81380: LD_INT 2
81382: PUSH
81383: LD_INT 30
81385: PUSH
81386: LD_INT 0
81388: PUSH
81389: EMPTY
81390: LIST
81391: LIST
81392: PUSH
81393: LD_INT 30
81395: PUSH
81396: LD_INT 1
81398: PUSH
81399: EMPTY
81400: LIST
81401: LIST
81402: PUSH
81403: EMPTY
81404: LIST
81405: LIST
81406: LIST
81407: PPUSH
81408: CALL_OW 72
81412: PPUSH
81413: LD_VAR 0 1
81417: PPUSH
81418: CALL_OW 74
81422: ST_TO_ADDR
// if tmp then
81423: LD_VAR 0 5
81427: IFFALSE 81443
// ComStandNearbyBuilding ( ape , tmp ) ;
81429: LD_VAR 0 1
81433: PPUSH
81434: LD_VAR 0 5
81438: PPUSH
81439: CALL 15361 0 2
// break ;
81443: GO 81447
// end ; end ;
81445: GO 81299
81447: POP
81448: POP
// end ;
81449: LD_VAR 0 3
81453: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
81454: LD_INT 0
81456: PPUSH
81457: PPUSH
81458: PPUSH
// if not mc_bases or not skirmish then
81459: LD_EXP 58
81463: NOT
81464: PUSH
81465: LD_EXP 56
81469: NOT
81470: OR
81471: IFFALSE 81475
// exit ;
81473: GO 81564
// for i = 1 to mc_bases do
81475: LD_ADDR_VAR 0 4
81479: PUSH
81480: DOUBLE
81481: LD_INT 1
81483: DEC
81484: ST_TO_ADDR
81485: LD_EXP 58
81489: PUSH
81490: FOR_TO
81491: IFFALSE 81562
// begin if building in mc_busy_turret_list [ i ] then
81493: LD_VAR 0 1
81497: PUSH
81498: LD_EXP 68
81502: PUSH
81503: LD_VAR 0 4
81507: ARRAY
81508: IN
81509: IFFALSE 81560
// begin tmp := mc_busy_turret_list [ i ] diff building ;
81511: LD_ADDR_VAR 0 5
81515: PUSH
81516: LD_EXP 68
81520: PUSH
81521: LD_VAR 0 4
81525: ARRAY
81526: PUSH
81527: LD_VAR 0 1
81531: DIFF
81532: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
81533: LD_ADDR_EXP 68
81537: PUSH
81538: LD_EXP 68
81542: PPUSH
81543: LD_VAR 0 4
81547: PPUSH
81548: LD_VAR 0 5
81552: PPUSH
81553: CALL_OW 1
81557: ST_TO_ADDR
// break ;
81558: GO 81562
// end ; end ;
81560: GO 81490
81562: POP
81563: POP
// end ;
81564: LD_VAR 0 3
81568: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
81569: LD_INT 0
81571: PPUSH
81572: PPUSH
81573: PPUSH
// if not mc_bases or not skirmish then
81574: LD_EXP 58
81578: NOT
81579: PUSH
81580: LD_EXP 56
81584: NOT
81585: OR
81586: IFFALSE 81590
// exit ;
81588: GO 81789
// for i = 1 to mc_bases do
81590: LD_ADDR_VAR 0 5
81594: PUSH
81595: DOUBLE
81596: LD_INT 1
81598: DEC
81599: ST_TO_ADDR
81600: LD_EXP 58
81604: PUSH
81605: FOR_TO
81606: IFFALSE 81787
// if building in mc_bases [ i ] then
81608: LD_VAR 0 1
81612: PUSH
81613: LD_EXP 58
81617: PUSH
81618: LD_VAR 0 5
81622: ARRAY
81623: IN
81624: IFFALSE 81785
// begin tmp := mc_bases [ i ] diff building ;
81626: LD_ADDR_VAR 0 6
81630: PUSH
81631: LD_EXP 58
81635: PUSH
81636: LD_VAR 0 5
81640: ARRAY
81641: PUSH
81642: LD_VAR 0 1
81646: DIFF
81647: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
81648: LD_ADDR_EXP 58
81652: PUSH
81653: LD_EXP 58
81657: PPUSH
81658: LD_VAR 0 5
81662: PPUSH
81663: LD_VAR 0 6
81667: PPUSH
81668: CALL_OW 1
81672: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
81673: LD_VAR 0 1
81677: PUSH
81678: LD_EXP 66
81682: PUSH
81683: LD_VAR 0 5
81687: ARRAY
81688: IN
81689: IFFALSE 81728
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
81691: LD_ADDR_EXP 66
81695: PUSH
81696: LD_EXP 66
81700: PPUSH
81701: LD_VAR 0 5
81705: PPUSH
81706: LD_EXP 66
81710: PUSH
81711: LD_VAR 0 5
81715: ARRAY
81716: PUSH
81717: LD_VAR 0 1
81721: DIFF
81722: PPUSH
81723: CALL_OW 1
81727: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
81728: LD_VAR 0 1
81732: PUSH
81733: LD_EXP 67
81737: PUSH
81738: LD_VAR 0 5
81742: ARRAY
81743: IN
81744: IFFALSE 81783
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
81746: LD_ADDR_EXP 67
81750: PUSH
81751: LD_EXP 67
81755: PPUSH
81756: LD_VAR 0 5
81760: PPUSH
81761: LD_EXP 67
81765: PUSH
81766: LD_VAR 0 5
81770: ARRAY
81771: PUSH
81772: LD_VAR 0 1
81776: DIFF
81777: PPUSH
81778: CALL_OW 1
81782: ST_TO_ADDR
// break ;
81783: GO 81787
// end ;
81785: GO 81605
81787: POP
81788: POP
// end ;
81789: LD_VAR 0 4
81793: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
81794: LD_INT 0
81796: PPUSH
81797: PPUSH
81798: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
81799: LD_EXP 58
81803: NOT
81804: PUSH
81805: LD_EXP 56
81809: NOT
81810: OR
81811: PUSH
81812: LD_VAR 0 3
81816: PUSH
81817: LD_EXP 84
81821: IN
81822: NOT
81823: OR
81824: IFFALSE 81828
// exit ;
81826: GO 81951
// for i = 1 to mc_vehicles do
81828: LD_ADDR_VAR 0 6
81832: PUSH
81833: DOUBLE
81834: LD_INT 1
81836: DEC
81837: ST_TO_ADDR
81838: LD_EXP 77
81842: PUSH
81843: FOR_TO
81844: IFFALSE 81949
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
81846: LD_VAR 0 2
81850: PUSH
81851: LD_EXP 77
81855: PUSH
81856: LD_VAR 0 6
81860: ARRAY
81861: IN
81862: PUSH
81863: LD_VAR 0 1
81867: PUSH
81868: LD_EXP 77
81872: PUSH
81873: LD_VAR 0 6
81877: ARRAY
81878: IN
81879: OR
81880: IFFALSE 81947
// begin tmp := mc_vehicles [ i ] diff old ;
81882: LD_ADDR_VAR 0 7
81886: PUSH
81887: LD_EXP 77
81891: PUSH
81892: LD_VAR 0 6
81896: ARRAY
81897: PUSH
81898: LD_VAR 0 2
81902: DIFF
81903: ST_TO_ADDR
// tmp := tmp diff new ;
81904: LD_ADDR_VAR 0 7
81908: PUSH
81909: LD_VAR 0 7
81913: PUSH
81914: LD_VAR 0 1
81918: DIFF
81919: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
81920: LD_ADDR_EXP 77
81924: PUSH
81925: LD_EXP 77
81929: PPUSH
81930: LD_VAR 0 6
81934: PPUSH
81935: LD_VAR 0 7
81939: PPUSH
81940: CALL_OW 1
81944: ST_TO_ADDR
// break ;
81945: GO 81949
// end ;
81947: GO 81843
81949: POP
81950: POP
// end ;
81951: LD_VAR 0 5
81955: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
81956: LD_INT 0
81958: PPUSH
81959: PPUSH
81960: PPUSH
81961: PPUSH
// if not mc_bases or not skirmish then
81962: LD_EXP 58
81966: NOT
81967: PUSH
81968: LD_EXP 56
81972: NOT
81973: OR
81974: IFFALSE 81978
// exit ;
81976: GO 82355
// side := GetSide ( vehicle ) ;
81978: LD_ADDR_VAR 0 5
81982: PUSH
81983: LD_VAR 0 1
81987: PPUSH
81988: CALL_OW 255
81992: ST_TO_ADDR
// for i = 1 to mc_bases do
81993: LD_ADDR_VAR 0 4
81997: PUSH
81998: DOUBLE
81999: LD_INT 1
82001: DEC
82002: ST_TO_ADDR
82003: LD_EXP 58
82007: PUSH
82008: FOR_TO
82009: IFFALSE 82353
// begin if factory in mc_bases [ i ] then
82011: LD_VAR 0 2
82015: PUSH
82016: LD_EXP 58
82020: PUSH
82021: LD_VAR 0 4
82025: ARRAY
82026: IN
82027: IFFALSE 82351
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
82029: LD_EXP 80
82033: PUSH
82034: LD_VAR 0 4
82038: ARRAY
82039: PUSH
82040: LD_EXP 69
82044: PUSH
82045: LD_VAR 0 4
82049: ARRAY
82050: LESS
82051: PUSH
82052: LD_VAR 0 1
82056: PPUSH
82057: CALL_OW 264
82061: PUSH
82062: LD_INT 31
82064: PUSH
82065: LD_INT 32
82067: PUSH
82068: LD_INT 51
82070: PUSH
82071: LD_EXP 102
82075: PUSH
82076: LD_INT 12
82078: PUSH
82079: LD_INT 30
82081: PUSH
82082: LD_EXP 101
82086: PUSH
82087: LD_INT 11
82089: PUSH
82090: LD_INT 53
82092: PUSH
82093: LD_INT 14
82095: PUSH
82096: LD_EXP 105
82100: PUSH
82101: LD_INT 29
82103: PUSH
82104: LD_EXP 103
82108: PUSH
82109: LD_INT 13
82111: PUSH
82112: LD_INT 52
82114: PUSH
82115: LD_INT 48
82117: PUSH
82118: LD_INT 8
82120: PUSH
82121: EMPTY
82122: LIST
82123: LIST
82124: LIST
82125: LIST
82126: LIST
82127: LIST
82128: LIST
82129: LIST
82130: LIST
82131: LIST
82132: LIST
82133: LIST
82134: LIST
82135: LIST
82136: LIST
82137: LIST
82138: LIST
82139: IN
82140: NOT
82141: AND
82142: IFFALSE 82190
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
82144: LD_ADDR_EXP 80
82148: PUSH
82149: LD_EXP 80
82153: PPUSH
82154: LD_VAR 0 4
82158: PUSH
82159: LD_EXP 80
82163: PUSH
82164: LD_VAR 0 4
82168: ARRAY
82169: PUSH
82170: LD_INT 1
82172: PLUS
82173: PUSH
82174: EMPTY
82175: LIST
82176: LIST
82177: PPUSH
82178: LD_VAR 0 1
82182: PPUSH
82183: CALL 20654 0 3
82187: ST_TO_ADDR
82188: GO 82234
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
82190: LD_ADDR_EXP 77
82194: PUSH
82195: LD_EXP 77
82199: PPUSH
82200: LD_VAR 0 4
82204: PUSH
82205: LD_EXP 77
82209: PUSH
82210: LD_VAR 0 4
82214: ARRAY
82215: PUSH
82216: LD_INT 1
82218: PLUS
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: PPUSH
82224: LD_VAR 0 1
82228: PPUSH
82229: CALL 20654 0 3
82233: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
82234: LD_VAR 0 1
82238: PPUSH
82239: CALL_OW 263
82243: PUSH
82244: LD_INT 2
82246: EQUAL
82247: IFFALSE 82267
// begin repeat wait ( 0 0$1 ) ;
82249: LD_INT 35
82251: PPUSH
82252: CALL_OW 67
// until IsControledBy ( vehicle ) ;
82256: LD_VAR 0 1
82260: PPUSH
82261: CALL_OW 312
82265: IFFALSE 82249
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
82267: LD_VAR 0 1
82271: PPUSH
82272: LD_EXP 82
82276: PUSH
82277: LD_VAR 0 4
82281: ARRAY
82282: PPUSH
82283: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
82287: LD_VAR 0 1
82291: PPUSH
82292: CALL_OW 263
82296: PUSH
82297: LD_INT 1
82299: NONEQUAL
82300: IFFALSE 82304
// break ;
82302: GO 82353
// repeat wait ( 0 0$1 ) ;
82304: LD_INT 35
82306: PPUSH
82307: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
82311: LD_VAR 0 1
82315: PPUSH
82316: LD_EXP 82
82320: PUSH
82321: LD_VAR 0 4
82325: ARRAY
82326: PPUSH
82327: CALL_OW 308
82331: IFFALSE 82304
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
82333: LD_VAR 0 1
82337: PPUSH
82338: CALL_OW 311
82342: PPUSH
82343: CALL_OW 121
// exit ;
82347: POP
82348: POP
82349: GO 82355
// end ; end ;
82351: GO 82008
82353: POP
82354: POP
// end ;
82355: LD_VAR 0 3
82359: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
82360: LD_INT 0
82362: PPUSH
82363: PPUSH
82364: PPUSH
82365: PPUSH
// if not mc_bases or not skirmish then
82366: LD_EXP 58
82370: NOT
82371: PUSH
82372: LD_EXP 56
82376: NOT
82377: OR
82378: IFFALSE 82382
// exit ;
82380: GO 82735
// repeat wait ( 0 0$1 ) ;
82382: LD_INT 35
82384: PPUSH
82385: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
82389: LD_VAR 0 2
82393: PPUSH
82394: LD_VAR 0 3
82398: PPUSH
82399: CALL_OW 284
82403: IFFALSE 82382
// if GetResourceTypeXY ( x , y ) = mat_artefact then
82405: LD_VAR 0 2
82409: PPUSH
82410: LD_VAR 0 3
82414: PPUSH
82415: CALL_OW 283
82419: PUSH
82420: LD_INT 4
82422: EQUAL
82423: IFFALSE 82427
// exit ;
82425: GO 82735
// for i = 1 to mc_bases do
82427: LD_ADDR_VAR 0 7
82431: PUSH
82432: DOUBLE
82433: LD_INT 1
82435: DEC
82436: ST_TO_ADDR
82437: LD_EXP 58
82441: PUSH
82442: FOR_TO
82443: IFFALSE 82733
// begin if mc_crates_area [ i ] then
82445: LD_EXP 76
82449: PUSH
82450: LD_VAR 0 7
82454: ARRAY
82455: IFFALSE 82566
// for j in mc_crates_area [ i ] do
82457: LD_ADDR_VAR 0 8
82461: PUSH
82462: LD_EXP 76
82466: PUSH
82467: LD_VAR 0 7
82471: ARRAY
82472: PUSH
82473: FOR_IN
82474: IFFALSE 82564
// if InArea ( x , y , j ) then
82476: LD_VAR 0 2
82480: PPUSH
82481: LD_VAR 0 3
82485: PPUSH
82486: LD_VAR 0 8
82490: PPUSH
82491: CALL_OW 309
82495: IFFALSE 82562
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82497: LD_ADDR_EXP 74
82501: PUSH
82502: LD_EXP 74
82506: PPUSH
82507: LD_VAR 0 7
82511: PUSH
82512: LD_EXP 74
82516: PUSH
82517: LD_VAR 0 7
82521: ARRAY
82522: PUSH
82523: LD_INT 1
82525: PLUS
82526: PUSH
82527: EMPTY
82528: LIST
82529: LIST
82530: PPUSH
82531: LD_VAR 0 4
82535: PUSH
82536: LD_VAR 0 2
82540: PUSH
82541: LD_VAR 0 3
82545: PUSH
82546: EMPTY
82547: LIST
82548: LIST
82549: LIST
82550: PPUSH
82551: CALL 20654 0 3
82555: ST_TO_ADDR
// exit ;
82556: POP
82557: POP
82558: POP
82559: POP
82560: GO 82735
// end ;
82562: GO 82473
82564: POP
82565: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82566: LD_ADDR_VAR 0 9
82570: PUSH
82571: LD_EXP 58
82575: PUSH
82576: LD_VAR 0 7
82580: ARRAY
82581: PPUSH
82582: LD_INT 2
82584: PUSH
82585: LD_INT 30
82587: PUSH
82588: LD_INT 0
82590: PUSH
82591: EMPTY
82592: LIST
82593: LIST
82594: PUSH
82595: LD_INT 30
82597: PUSH
82598: LD_INT 1
82600: PUSH
82601: EMPTY
82602: LIST
82603: LIST
82604: PUSH
82605: EMPTY
82606: LIST
82607: LIST
82608: LIST
82609: PPUSH
82610: CALL_OW 72
82614: ST_TO_ADDR
// if not depot then
82615: LD_VAR 0 9
82619: NOT
82620: IFFALSE 82624
// continue ;
82622: GO 82442
// for j in depot do
82624: LD_ADDR_VAR 0 8
82628: PUSH
82629: LD_VAR 0 9
82633: PUSH
82634: FOR_IN
82635: IFFALSE 82729
// if GetDistUnitXY ( j , x , y ) < 30 then
82637: LD_VAR 0 8
82641: PPUSH
82642: LD_VAR 0 2
82646: PPUSH
82647: LD_VAR 0 3
82651: PPUSH
82652: CALL_OW 297
82656: PUSH
82657: LD_INT 30
82659: LESS
82660: IFFALSE 82727
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82662: LD_ADDR_EXP 74
82666: PUSH
82667: LD_EXP 74
82671: PPUSH
82672: LD_VAR 0 7
82676: PUSH
82677: LD_EXP 74
82681: PUSH
82682: LD_VAR 0 7
82686: ARRAY
82687: PUSH
82688: LD_INT 1
82690: PLUS
82691: PUSH
82692: EMPTY
82693: LIST
82694: LIST
82695: PPUSH
82696: LD_VAR 0 4
82700: PUSH
82701: LD_VAR 0 2
82705: PUSH
82706: LD_VAR 0 3
82710: PUSH
82711: EMPTY
82712: LIST
82713: LIST
82714: LIST
82715: PPUSH
82716: CALL 20654 0 3
82720: ST_TO_ADDR
// exit ;
82721: POP
82722: POP
82723: POP
82724: POP
82725: GO 82735
// end ;
82727: GO 82634
82729: POP
82730: POP
// end ;
82731: GO 82442
82733: POP
82734: POP
// end ;
82735: LD_VAR 0 6
82739: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
82740: LD_INT 0
82742: PPUSH
82743: PPUSH
82744: PPUSH
82745: PPUSH
// if not mc_bases or not skirmish then
82746: LD_EXP 58
82750: NOT
82751: PUSH
82752: LD_EXP 56
82756: NOT
82757: OR
82758: IFFALSE 82762
// exit ;
82760: GO 83039
// side := GetSide ( lab ) ;
82762: LD_ADDR_VAR 0 4
82766: PUSH
82767: LD_VAR 0 2
82771: PPUSH
82772: CALL_OW 255
82776: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
82777: LD_VAR 0 4
82781: PUSH
82782: LD_EXP 84
82786: IN
82787: NOT
82788: PUSH
82789: LD_EXP 85
82793: NOT
82794: OR
82795: PUSH
82796: LD_EXP 58
82800: NOT
82801: OR
82802: IFFALSE 82806
// exit ;
82804: GO 83039
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
82806: LD_ADDR_EXP 85
82810: PUSH
82811: LD_EXP 85
82815: PPUSH
82816: LD_VAR 0 4
82820: PPUSH
82821: LD_EXP 85
82825: PUSH
82826: LD_VAR 0 4
82830: ARRAY
82831: PUSH
82832: LD_VAR 0 1
82836: DIFF
82837: PPUSH
82838: CALL_OW 1
82842: ST_TO_ADDR
// for i = 1 to mc_bases do
82843: LD_ADDR_VAR 0 5
82847: PUSH
82848: DOUBLE
82849: LD_INT 1
82851: DEC
82852: ST_TO_ADDR
82853: LD_EXP 58
82857: PUSH
82858: FOR_TO
82859: IFFALSE 83037
// begin if lab in mc_bases [ i ] then
82861: LD_VAR 0 2
82865: PUSH
82866: LD_EXP 58
82870: PUSH
82871: LD_VAR 0 5
82875: ARRAY
82876: IN
82877: IFFALSE 83035
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
82879: LD_VAR 0 1
82883: PUSH
82884: LD_INT 11
82886: PUSH
82887: LD_INT 4
82889: PUSH
82890: LD_INT 3
82892: PUSH
82893: LD_INT 2
82895: PUSH
82896: EMPTY
82897: LIST
82898: LIST
82899: LIST
82900: LIST
82901: IN
82902: PUSH
82903: LD_EXP 88
82907: PUSH
82908: LD_VAR 0 5
82912: ARRAY
82913: AND
82914: IFFALSE 83035
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
82916: LD_ADDR_VAR 0 6
82920: PUSH
82921: LD_EXP 88
82925: PUSH
82926: LD_VAR 0 5
82930: ARRAY
82931: PUSH
82932: LD_INT 1
82934: ARRAY
82935: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82936: LD_ADDR_EXP 88
82940: PUSH
82941: LD_EXP 88
82945: PPUSH
82946: LD_VAR 0 5
82950: PPUSH
82951: EMPTY
82952: PPUSH
82953: CALL_OW 1
82957: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
82958: LD_VAR 0 6
82962: PPUSH
82963: LD_INT 0
82965: PPUSH
82966: CALL_OW 109
// ComExitBuilding ( tmp ) ;
82970: LD_VAR 0 6
82974: PPUSH
82975: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
82979: LD_ADDR_EXP 87
82983: PUSH
82984: LD_EXP 87
82988: PPUSH
82989: LD_VAR 0 5
82993: PPUSH
82994: LD_EXP 87
82998: PUSH
82999: LD_VAR 0 5
83003: ARRAY
83004: PPUSH
83005: LD_INT 1
83007: PPUSH
83008: LD_VAR 0 6
83012: PPUSH
83013: CALL_OW 2
83017: PPUSH
83018: CALL_OW 1
83022: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
83023: LD_VAR 0 5
83027: PPUSH
83028: LD_INT 112
83030: PPUSH
83031: CALL 60572 0 2
// end ; end ; end ;
83035: GO 82858
83037: POP
83038: POP
// end ;
83039: LD_VAR 0 3
83043: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
83044: LD_INT 0
83046: PPUSH
83047: PPUSH
83048: PPUSH
83049: PPUSH
83050: PPUSH
83051: PPUSH
83052: PPUSH
83053: PPUSH
// if not mc_bases or not skirmish then
83054: LD_EXP 58
83058: NOT
83059: PUSH
83060: LD_EXP 56
83064: NOT
83065: OR
83066: IFFALSE 83070
// exit ;
83068: GO 84162
// for i = 1 to mc_bases do
83070: LD_ADDR_VAR 0 3
83074: PUSH
83075: DOUBLE
83076: LD_INT 1
83078: DEC
83079: ST_TO_ADDR
83080: LD_EXP 58
83084: PUSH
83085: FOR_TO
83086: IFFALSE 84160
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
83088: LD_VAR 0 1
83092: PUSH
83093: LD_EXP 58
83097: PUSH
83098: LD_VAR 0 3
83102: ARRAY
83103: IN
83104: PUSH
83105: LD_VAR 0 1
83109: PUSH
83110: LD_EXP 65
83114: PUSH
83115: LD_VAR 0 3
83119: ARRAY
83120: IN
83121: OR
83122: PUSH
83123: LD_VAR 0 1
83127: PUSH
83128: LD_EXP 80
83132: PUSH
83133: LD_VAR 0 3
83137: ARRAY
83138: IN
83139: OR
83140: PUSH
83141: LD_VAR 0 1
83145: PUSH
83146: LD_EXP 77
83150: PUSH
83151: LD_VAR 0 3
83155: ARRAY
83156: IN
83157: OR
83158: PUSH
83159: LD_VAR 0 1
83163: PUSH
83164: LD_EXP 87
83168: PUSH
83169: LD_VAR 0 3
83173: ARRAY
83174: IN
83175: OR
83176: PUSH
83177: LD_VAR 0 1
83181: PUSH
83182: LD_EXP 88
83186: PUSH
83187: LD_VAR 0 3
83191: ARRAY
83192: IN
83193: OR
83194: IFFALSE 84158
// begin if un in mc_ape [ i ] then
83196: LD_VAR 0 1
83200: PUSH
83201: LD_EXP 87
83205: PUSH
83206: LD_VAR 0 3
83210: ARRAY
83211: IN
83212: IFFALSE 83251
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
83214: LD_ADDR_EXP 87
83218: PUSH
83219: LD_EXP 87
83223: PPUSH
83224: LD_VAR 0 3
83228: PPUSH
83229: LD_EXP 87
83233: PUSH
83234: LD_VAR 0 3
83238: ARRAY
83239: PUSH
83240: LD_VAR 0 1
83244: DIFF
83245: PPUSH
83246: CALL_OW 1
83250: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
83251: LD_VAR 0 1
83255: PUSH
83256: LD_EXP 88
83260: PUSH
83261: LD_VAR 0 3
83265: ARRAY
83266: IN
83267: IFFALSE 83291
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83269: LD_ADDR_EXP 88
83273: PUSH
83274: LD_EXP 88
83278: PPUSH
83279: LD_VAR 0 3
83283: PPUSH
83284: EMPTY
83285: PPUSH
83286: CALL_OW 1
83290: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] ) then
83291: LD_VAR 0 1
83295: PPUSH
83296: CALL_OW 247
83300: PUSH
83301: LD_INT 2
83303: EQUAL
83304: PUSH
83305: LD_VAR 0 1
83309: PPUSH
83310: CALL_OW 110
83314: PUSH
83315: LD_INT 20
83317: EQUAL
83318: PUSH
83319: LD_VAR 0 1
83323: PUSH
83324: LD_EXP 80
83328: PUSH
83329: LD_VAR 0 3
83333: ARRAY
83334: IN
83335: OR
83336: AND
83337: IFFALSE 83498
// begin if un in mc_defender [ i ] then
83339: LD_VAR 0 1
83343: PUSH
83344: LD_EXP 80
83348: PUSH
83349: LD_VAR 0 3
83353: ARRAY
83354: IN
83355: IFFALSE 83394
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
83357: LD_ADDR_EXP 80
83361: PUSH
83362: LD_EXP 80
83366: PPUSH
83367: LD_VAR 0 3
83371: PPUSH
83372: LD_EXP 80
83376: PUSH
83377: LD_VAR 0 3
83381: ARRAY
83382: PUSH
83383: LD_VAR 0 1
83387: DIFF
83388: PPUSH
83389: CALL_OW 1
83393: ST_TO_ADDR
// fac := MC_GetBuilding ( i , b_factory ) ;
83394: LD_ADDR_VAR 0 8
83398: PUSH
83399: LD_VAR 0 3
83403: PPUSH
83404: LD_INT 3
83406: PPUSH
83407: CALL 80087 0 2
83411: ST_TO_ADDR
// if fac then
83412: LD_VAR 0 8
83416: IFFALSE 83498
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
83418: LD_ADDR_VAR 0 9
83422: PUSH
83423: LD_VAR 0 8
83427: PPUSH
83428: LD_VAR 0 1
83432: PPUSH
83433: CALL_OW 265
83437: PPUSH
83438: LD_VAR 0 1
83442: PPUSH
83443: CALL_OW 262
83447: PPUSH
83448: LD_VAR 0 1
83452: PPUSH
83453: CALL_OW 263
83457: PPUSH
83458: LD_VAR 0 1
83462: PPUSH
83463: CALL_OW 264
83467: PPUSH
83468: CALL 18247 0 5
83472: ST_TO_ADDR
// if components then
83473: LD_VAR 0 9
83477: IFFALSE 83496
// MC_InsertProduceList ( i , [ components ] ) ;
83479: LD_VAR 0 3
83483: PPUSH
83484: LD_VAR 0 9
83488: PUSH
83489: EMPTY
83490: LIST
83491: PPUSH
83492: CALL 79715 0 2
// break ;
83496: GO 84160
// end ; end ; if GetType ( un ) = unit_building then
83498: LD_VAR 0 1
83502: PPUSH
83503: CALL_OW 247
83507: PUSH
83508: LD_INT 3
83510: EQUAL
83511: IFFALSE 83826
// begin btype := GetBType ( un ) ;
83513: LD_ADDR_VAR 0 5
83517: PUSH
83518: LD_VAR 0 1
83522: PPUSH
83523: CALL_OW 266
83527: ST_TO_ADDR
// if btype = b_warehouse then
83528: LD_VAR 0 5
83532: PUSH
83533: LD_INT 1
83535: EQUAL
83536: IFFALSE 83554
// begin btype := b_depot ;
83538: LD_ADDR_VAR 0 5
83542: PUSH
83543: LD_INT 0
83545: ST_TO_ADDR
// pos := 1 ;
83546: LD_ADDR_VAR 0 6
83550: PUSH
83551: LD_INT 1
83553: ST_TO_ADDR
// end ; if btype = b_factory then
83554: LD_VAR 0 5
83558: PUSH
83559: LD_INT 3
83561: EQUAL
83562: IFFALSE 83580
// begin btype := b_workshop ;
83564: LD_ADDR_VAR 0 5
83568: PUSH
83569: LD_INT 2
83571: ST_TO_ADDR
// pos := 1 ;
83572: LD_ADDR_VAR 0 6
83576: PUSH
83577: LD_INT 1
83579: ST_TO_ADDR
// end ; if btype = b_barracks then
83580: LD_VAR 0 5
83584: PUSH
83585: LD_INT 5
83587: EQUAL
83588: IFFALSE 83598
// btype := b_armoury ;
83590: LD_ADDR_VAR 0 5
83594: PUSH
83595: LD_INT 4
83597: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
83598: LD_VAR 0 5
83602: PUSH
83603: LD_INT 7
83605: PUSH
83606: LD_INT 8
83608: PUSH
83609: EMPTY
83610: LIST
83611: LIST
83612: IN
83613: IFFALSE 83623
// btype := b_lab ;
83615: LD_ADDR_VAR 0 5
83619: PUSH
83620: LD_INT 6
83622: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
83623: LD_ADDR_EXP 63
83627: PUSH
83628: LD_EXP 63
83632: PPUSH
83633: LD_VAR 0 3
83637: PUSH
83638: LD_EXP 63
83642: PUSH
83643: LD_VAR 0 3
83647: ARRAY
83648: PUSH
83649: LD_INT 1
83651: PLUS
83652: PUSH
83653: EMPTY
83654: LIST
83655: LIST
83656: PPUSH
83657: LD_VAR 0 5
83661: PUSH
83662: LD_VAR 0 1
83666: PPUSH
83667: CALL_OW 250
83671: PUSH
83672: LD_VAR 0 1
83676: PPUSH
83677: CALL_OW 251
83681: PUSH
83682: LD_VAR 0 1
83686: PPUSH
83687: CALL_OW 254
83691: PUSH
83692: EMPTY
83693: LIST
83694: LIST
83695: LIST
83696: LIST
83697: PPUSH
83698: CALL 20654 0 3
83702: ST_TO_ADDR
// if pos = 1 then
83703: LD_VAR 0 6
83707: PUSH
83708: LD_INT 1
83710: EQUAL
83711: IFFALSE 83826
// begin tmp := mc_build_list [ i ] ;
83713: LD_ADDR_VAR 0 7
83717: PUSH
83718: LD_EXP 63
83722: PUSH
83723: LD_VAR 0 3
83727: ARRAY
83728: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
83729: LD_VAR 0 7
83733: PPUSH
83734: LD_INT 2
83736: PUSH
83737: LD_INT 30
83739: PUSH
83740: LD_INT 0
83742: PUSH
83743: EMPTY
83744: LIST
83745: LIST
83746: PUSH
83747: LD_INT 30
83749: PUSH
83750: LD_INT 1
83752: PUSH
83753: EMPTY
83754: LIST
83755: LIST
83756: PUSH
83757: EMPTY
83758: LIST
83759: LIST
83760: LIST
83761: PPUSH
83762: CALL_OW 72
83766: IFFALSE 83776
// pos := 2 ;
83768: LD_ADDR_VAR 0 6
83772: PUSH
83773: LD_INT 2
83775: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
83776: LD_ADDR_VAR 0 7
83780: PUSH
83781: LD_VAR 0 7
83785: PPUSH
83786: LD_VAR 0 6
83790: PPUSH
83791: LD_VAR 0 7
83795: PPUSH
83796: CALL 20980 0 3
83800: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
83801: LD_ADDR_EXP 63
83805: PUSH
83806: LD_EXP 63
83810: PPUSH
83811: LD_VAR 0 3
83815: PPUSH
83816: LD_VAR 0 7
83820: PPUSH
83821: CALL_OW 1
83825: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
83826: LD_VAR 0 1
83830: PUSH
83831: LD_EXP 58
83835: PUSH
83836: LD_VAR 0 3
83840: ARRAY
83841: IN
83842: IFFALSE 83881
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
83844: LD_ADDR_EXP 58
83848: PUSH
83849: LD_EXP 58
83853: PPUSH
83854: LD_VAR 0 3
83858: PPUSH
83859: LD_EXP 58
83863: PUSH
83864: LD_VAR 0 3
83868: ARRAY
83869: PUSH
83870: LD_VAR 0 1
83874: DIFF
83875: PPUSH
83876: CALL_OW 1
83880: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
83881: LD_VAR 0 1
83885: PUSH
83886: LD_EXP 65
83890: PUSH
83891: LD_VAR 0 3
83895: ARRAY
83896: IN
83897: IFFALSE 83936
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
83899: LD_ADDR_EXP 65
83903: PUSH
83904: LD_EXP 65
83908: PPUSH
83909: LD_VAR 0 3
83913: PPUSH
83914: LD_EXP 65
83918: PUSH
83919: LD_VAR 0 3
83923: ARRAY
83924: PUSH
83925: LD_VAR 0 1
83929: DIFF
83930: PPUSH
83931: CALL_OW 1
83935: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
83936: LD_VAR 0 1
83940: PUSH
83941: LD_EXP 77
83945: PUSH
83946: LD_VAR 0 3
83950: ARRAY
83951: IN
83952: IFFALSE 83991
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
83954: LD_ADDR_EXP 77
83958: PUSH
83959: LD_EXP 77
83963: PPUSH
83964: LD_VAR 0 3
83968: PPUSH
83969: LD_EXP 77
83973: PUSH
83974: LD_VAR 0 3
83978: ARRAY
83979: PUSH
83980: LD_VAR 0 1
83984: DIFF
83985: PPUSH
83986: CALL_OW 1
83990: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
83991: LD_VAR 0 1
83995: PUSH
83996: LD_EXP 80
84000: PUSH
84001: LD_VAR 0 3
84005: ARRAY
84006: IN
84007: IFFALSE 84046
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84009: LD_ADDR_EXP 80
84013: PUSH
84014: LD_EXP 80
84018: PPUSH
84019: LD_VAR 0 3
84023: PPUSH
84024: LD_EXP 80
84028: PUSH
84029: LD_VAR 0 3
84033: ARRAY
84034: PUSH
84035: LD_VAR 0 1
84039: DIFF
84040: PPUSH
84041: CALL_OW 1
84045: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
84046: LD_VAR 0 1
84050: PUSH
84051: LD_EXP 67
84055: PUSH
84056: LD_VAR 0 3
84060: ARRAY
84061: IN
84062: IFFALSE 84101
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
84064: LD_ADDR_EXP 67
84068: PUSH
84069: LD_EXP 67
84073: PPUSH
84074: LD_VAR 0 3
84078: PPUSH
84079: LD_EXP 67
84083: PUSH
84084: LD_VAR 0 3
84088: ARRAY
84089: PUSH
84090: LD_VAR 0 1
84094: DIFF
84095: PPUSH
84096: CALL_OW 1
84100: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
84101: LD_VAR 0 1
84105: PUSH
84106: LD_EXP 66
84110: PUSH
84111: LD_VAR 0 3
84115: ARRAY
84116: IN
84117: IFFALSE 84156
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
84119: LD_ADDR_EXP 66
84123: PUSH
84124: LD_EXP 66
84128: PPUSH
84129: LD_VAR 0 3
84133: PPUSH
84134: LD_EXP 66
84138: PUSH
84139: LD_VAR 0 3
84143: ARRAY
84144: PUSH
84145: LD_VAR 0 1
84149: DIFF
84150: PPUSH
84151: CALL_OW 1
84155: ST_TO_ADDR
// end ; break ;
84156: GO 84160
// end ;
84158: GO 83085
84160: POP
84161: POP
// end ;
84162: LD_VAR 0 2
84166: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
84167: LD_INT 0
84169: PPUSH
84170: PPUSH
84171: PPUSH
// if not mc_bases or not skirmish then
84172: LD_EXP 58
84176: NOT
84177: PUSH
84178: LD_EXP 56
84182: NOT
84183: OR
84184: IFFALSE 84188
// exit ;
84186: GO 84403
// for i = 1 to mc_bases do
84188: LD_ADDR_VAR 0 3
84192: PUSH
84193: DOUBLE
84194: LD_INT 1
84196: DEC
84197: ST_TO_ADDR
84198: LD_EXP 58
84202: PUSH
84203: FOR_TO
84204: IFFALSE 84401
// begin if building in mc_construct_list [ i ] then
84206: LD_VAR 0 1
84210: PUSH
84211: LD_EXP 65
84215: PUSH
84216: LD_VAR 0 3
84220: ARRAY
84221: IN
84222: IFFALSE 84399
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84224: LD_ADDR_EXP 65
84228: PUSH
84229: LD_EXP 65
84233: PPUSH
84234: LD_VAR 0 3
84238: PPUSH
84239: LD_EXP 65
84243: PUSH
84244: LD_VAR 0 3
84248: ARRAY
84249: PUSH
84250: LD_VAR 0 1
84254: DIFF
84255: PPUSH
84256: CALL_OW 1
84260: ST_TO_ADDR
// if building in mc_lab [ i ] then
84261: LD_VAR 0 1
84265: PUSH
84266: LD_EXP 91
84270: PUSH
84271: LD_VAR 0 3
84275: ARRAY
84276: IN
84277: IFFALSE 84332
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
84279: LD_ADDR_EXP 92
84283: PUSH
84284: LD_EXP 92
84288: PPUSH
84289: LD_VAR 0 3
84293: PPUSH
84294: LD_EXP 92
84298: PUSH
84299: LD_VAR 0 3
84303: ARRAY
84304: PPUSH
84305: LD_INT 1
84307: PPUSH
84308: LD_EXP 92
84312: PUSH
84313: LD_VAR 0 3
84317: ARRAY
84318: PPUSH
84319: LD_INT 0
84321: PPUSH
84322: CALL 20072 0 4
84326: PPUSH
84327: CALL_OW 1
84331: ST_TO_ADDR
// if not building in mc_bases [ i ] then
84332: LD_VAR 0 1
84336: PUSH
84337: LD_EXP 58
84341: PUSH
84342: LD_VAR 0 3
84346: ARRAY
84347: IN
84348: NOT
84349: IFFALSE 84395
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84351: LD_ADDR_EXP 58
84355: PUSH
84356: LD_EXP 58
84360: PPUSH
84361: LD_VAR 0 3
84365: PUSH
84366: LD_EXP 58
84370: PUSH
84371: LD_VAR 0 3
84375: ARRAY
84376: PUSH
84377: LD_INT 1
84379: PLUS
84380: PUSH
84381: EMPTY
84382: LIST
84383: LIST
84384: PPUSH
84385: LD_VAR 0 1
84389: PPUSH
84390: CALL 20654 0 3
84394: ST_TO_ADDR
// exit ;
84395: POP
84396: POP
84397: GO 84403
// end ; end ;
84399: GO 84203
84401: POP
84402: POP
// end ;
84403: LD_VAR 0 2
84407: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
84408: LD_INT 0
84410: PPUSH
84411: PPUSH
84412: PPUSH
84413: PPUSH
84414: PPUSH
84415: PPUSH
84416: PPUSH
// if not mc_bases or not skirmish then
84417: LD_EXP 58
84421: NOT
84422: PUSH
84423: LD_EXP 56
84427: NOT
84428: OR
84429: IFFALSE 84433
// exit ;
84431: GO 85094
// for i = 1 to mc_bases do
84433: LD_ADDR_VAR 0 3
84437: PUSH
84438: DOUBLE
84439: LD_INT 1
84441: DEC
84442: ST_TO_ADDR
84443: LD_EXP 58
84447: PUSH
84448: FOR_TO
84449: IFFALSE 85092
// begin if building in mc_construct_list [ i ] then
84451: LD_VAR 0 1
84455: PUSH
84456: LD_EXP 65
84460: PUSH
84461: LD_VAR 0 3
84465: ARRAY
84466: IN
84467: IFFALSE 85090
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84469: LD_ADDR_EXP 65
84473: PUSH
84474: LD_EXP 65
84478: PPUSH
84479: LD_VAR 0 3
84483: PPUSH
84484: LD_EXP 65
84488: PUSH
84489: LD_VAR 0 3
84493: ARRAY
84494: PUSH
84495: LD_VAR 0 1
84499: DIFF
84500: PPUSH
84501: CALL_OW 1
84505: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84506: LD_ADDR_EXP 58
84510: PUSH
84511: LD_EXP 58
84515: PPUSH
84516: LD_VAR 0 3
84520: PUSH
84521: LD_EXP 58
84525: PUSH
84526: LD_VAR 0 3
84530: ARRAY
84531: PUSH
84532: LD_INT 1
84534: PLUS
84535: PUSH
84536: EMPTY
84537: LIST
84538: LIST
84539: PPUSH
84540: LD_VAR 0 1
84544: PPUSH
84545: CALL 20654 0 3
84549: ST_TO_ADDR
// btype := GetBType ( building ) ;
84550: LD_ADDR_VAR 0 5
84554: PUSH
84555: LD_VAR 0 1
84559: PPUSH
84560: CALL_OW 266
84564: ST_TO_ADDR
// side := GetSide ( building ) ;
84565: LD_ADDR_VAR 0 8
84569: PUSH
84570: LD_VAR 0 1
84574: PPUSH
84575: CALL_OW 255
84579: ST_TO_ADDR
// if btype = b_lab then
84580: LD_VAR 0 5
84584: PUSH
84585: LD_INT 6
84587: EQUAL
84588: IFFALSE 84638
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
84590: LD_ADDR_EXP 91
84594: PUSH
84595: LD_EXP 91
84599: PPUSH
84600: LD_VAR 0 3
84604: PUSH
84605: LD_EXP 91
84609: PUSH
84610: LD_VAR 0 3
84614: ARRAY
84615: PUSH
84616: LD_INT 1
84618: PLUS
84619: PUSH
84620: EMPTY
84621: LIST
84622: LIST
84623: PPUSH
84624: LD_VAR 0 1
84628: PPUSH
84629: CALL 20654 0 3
84633: ST_TO_ADDR
// exit ;
84634: POP
84635: POP
84636: GO 85094
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
84638: LD_VAR 0 5
84642: PUSH
84643: LD_INT 0
84645: PUSH
84646: LD_INT 2
84648: PUSH
84649: LD_INT 4
84651: PUSH
84652: EMPTY
84653: LIST
84654: LIST
84655: LIST
84656: IN
84657: IFFALSE 84781
// begin if btype = b_armoury then
84659: LD_VAR 0 5
84663: PUSH
84664: LD_INT 4
84666: EQUAL
84667: IFFALSE 84677
// btype := b_barracks ;
84669: LD_ADDR_VAR 0 5
84673: PUSH
84674: LD_INT 5
84676: ST_TO_ADDR
// if btype = b_depot then
84677: LD_VAR 0 5
84681: PUSH
84682: LD_INT 0
84684: EQUAL
84685: IFFALSE 84695
// btype := b_warehouse ;
84687: LD_ADDR_VAR 0 5
84691: PUSH
84692: LD_INT 1
84694: ST_TO_ADDR
// if btype = b_workshop then
84695: LD_VAR 0 5
84699: PUSH
84700: LD_INT 2
84702: EQUAL
84703: IFFALSE 84713
// btype := b_factory ;
84705: LD_ADDR_VAR 0 5
84709: PUSH
84710: LD_INT 3
84712: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
84713: LD_VAR 0 5
84717: PPUSH
84718: LD_VAR 0 8
84722: PPUSH
84723: CALL_OW 323
84727: PUSH
84728: LD_INT 1
84730: EQUAL
84731: IFFALSE 84777
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
84733: LD_ADDR_EXP 90
84737: PUSH
84738: LD_EXP 90
84742: PPUSH
84743: LD_VAR 0 3
84747: PUSH
84748: LD_EXP 90
84752: PUSH
84753: LD_VAR 0 3
84757: ARRAY
84758: PUSH
84759: LD_INT 1
84761: PLUS
84762: PUSH
84763: EMPTY
84764: LIST
84765: LIST
84766: PPUSH
84767: LD_VAR 0 1
84771: PPUSH
84772: CALL 20654 0 3
84776: ST_TO_ADDR
// exit ;
84777: POP
84778: POP
84779: GO 85094
// end ; if btype in [ b_bunker , b_turret ] then
84781: LD_VAR 0 5
84785: PUSH
84786: LD_INT 32
84788: PUSH
84789: LD_INT 33
84791: PUSH
84792: EMPTY
84793: LIST
84794: LIST
84795: IN
84796: IFFALSE 85086
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
84798: LD_ADDR_EXP 66
84802: PUSH
84803: LD_EXP 66
84807: PPUSH
84808: LD_VAR 0 3
84812: PUSH
84813: LD_EXP 66
84817: PUSH
84818: LD_VAR 0 3
84822: ARRAY
84823: PUSH
84824: LD_INT 1
84826: PLUS
84827: PUSH
84828: EMPTY
84829: LIST
84830: LIST
84831: PPUSH
84832: LD_VAR 0 1
84836: PPUSH
84837: CALL 20654 0 3
84841: ST_TO_ADDR
// if btype = b_bunker then
84842: LD_VAR 0 5
84846: PUSH
84847: LD_INT 32
84849: EQUAL
84850: IFFALSE 85086
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84852: LD_ADDR_EXP 67
84856: PUSH
84857: LD_EXP 67
84861: PPUSH
84862: LD_VAR 0 3
84866: PUSH
84867: LD_EXP 67
84871: PUSH
84872: LD_VAR 0 3
84876: ARRAY
84877: PUSH
84878: LD_INT 1
84880: PLUS
84881: PUSH
84882: EMPTY
84883: LIST
84884: LIST
84885: PPUSH
84886: LD_VAR 0 1
84890: PPUSH
84891: CALL 20654 0 3
84895: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
84896: LD_ADDR_VAR 0 6
84900: PUSH
84901: LD_EXP 58
84905: PUSH
84906: LD_VAR 0 3
84910: ARRAY
84911: PPUSH
84912: LD_INT 25
84914: PUSH
84915: LD_INT 1
84917: PUSH
84918: EMPTY
84919: LIST
84920: LIST
84921: PUSH
84922: LD_INT 3
84924: PUSH
84925: LD_INT 54
84927: PUSH
84928: EMPTY
84929: LIST
84930: PUSH
84931: EMPTY
84932: LIST
84933: LIST
84934: PUSH
84935: EMPTY
84936: LIST
84937: LIST
84938: PPUSH
84939: CALL_OW 72
84943: ST_TO_ADDR
// if tmp then
84944: LD_VAR 0 6
84948: IFFALSE 84954
// exit ;
84950: POP
84951: POP
84952: GO 85094
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
84954: LD_ADDR_VAR 0 6
84958: PUSH
84959: LD_EXP 58
84963: PUSH
84964: LD_VAR 0 3
84968: ARRAY
84969: PPUSH
84970: LD_INT 2
84972: PUSH
84973: LD_INT 30
84975: PUSH
84976: LD_INT 4
84978: PUSH
84979: EMPTY
84980: LIST
84981: LIST
84982: PUSH
84983: LD_INT 30
84985: PUSH
84986: LD_INT 5
84988: PUSH
84989: EMPTY
84990: LIST
84991: LIST
84992: PUSH
84993: EMPTY
84994: LIST
84995: LIST
84996: LIST
84997: PPUSH
84998: CALL_OW 72
85002: ST_TO_ADDR
// if not tmp then
85003: LD_VAR 0 6
85007: NOT
85008: IFFALSE 85014
// exit ;
85010: POP
85011: POP
85012: GO 85094
// for j in tmp do
85014: LD_ADDR_VAR 0 4
85018: PUSH
85019: LD_VAR 0 6
85023: PUSH
85024: FOR_IN
85025: IFFALSE 85084
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
85027: LD_ADDR_VAR 0 7
85031: PUSH
85032: LD_VAR 0 4
85036: PPUSH
85037: CALL_OW 313
85041: PPUSH
85042: LD_INT 25
85044: PUSH
85045: LD_INT 1
85047: PUSH
85048: EMPTY
85049: LIST
85050: LIST
85051: PPUSH
85052: CALL_OW 72
85056: ST_TO_ADDR
// if units then
85057: LD_VAR 0 7
85061: IFFALSE 85082
// begin ComExitBuilding ( units [ 1 ] ) ;
85063: LD_VAR 0 7
85067: PUSH
85068: LD_INT 1
85070: ARRAY
85071: PPUSH
85072: CALL_OW 122
// exit ;
85076: POP
85077: POP
85078: POP
85079: POP
85080: GO 85094
// end ; end ;
85082: GO 85024
85084: POP
85085: POP
// end ; end ; exit ;
85086: POP
85087: POP
85088: GO 85094
// end ; end ;
85090: GO 84448
85092: POP
85093: POP
// end ;
85094: LD_VAR 0 2
85098: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
85099: LD_INT 0
85101: PPUSH
85102: PPUSH
85103: PPUSH
85104: PPUSH
85105: PPUSH
85106: PPUSH
85107: PPUSH
// if not mc_bases or not skirmish then
85108: LD_EXP 58
85112: NOT
85113: PUSH
85114: LD_EXP 56
85118: NOT
85119: OR
85120: IFFALSE 85124
// exit ;
85122: GO 85355
// btype := GetBType ( building ) ;
85124: LD_ADDR_VAR 0 6
85128: PUSH
85129: LD_VAR 0 1
85133: PPUSH
85134: CALL_OW 266
85138: ST_TO_ADDR
// x := GetX ( building ) ;
85139: LD_ADDR_VAR 0 7
85143: PUSH
85144: LD_VAR 0 1
85148: PPUSH
85149: CALL_OW 250
85153: ST_TO_ADDR
// y := GetY ( building ) ;
85154: LD_ADDR_VAR 0 8
85158: PUSH
85159: LD_VAR 0 1
85163: PPUSH
85164: CALL_OW 251
85168: ST_TO_ADDR
// d := GetDir ( building ) ;
85169: LD_ADDR_VAR 0 9
85173: PUSH
85174: LD_VAR 0 1
85178: PPUSH
85179: CALL_OW 254
85183: ST_TO_ADDR
// for i = 1 to mc_bases do
85184: LD_ADDR_VAR 0 4
85188: PUSH
85189: DOUBLE
85190: LD_INT 1
85192: DEC
85193: ST_TO_ADDR
85194: LD_EXP 58
85198: PUSH
85199: FOR_TO
85200: IFFALSE 85353
// begin if not mc_build_list [ i ] then
85202: LD_EXP 63
85206: PUSH
85207: LD_VAR 0 4
85211: ARRAY
85212: NOT
85213: IFFALSE 85217
// continue ;
85215: GO 85199
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
85217: LD_VAR 0 6
85221: PUSH
85222: LD_VAR 0 7
85226: PUSH
85227: LD_VAR 0 8
85231: PUSH
85232: LD_VAR 0 9
85236: PUSH
85237: EMPTY
85238: LIST
85239: LIST
85240: LIST
85241: LIST
85242: PPUSH
85243: LD_EXP 63
85247: PUSH
85248: LD_VAR 0 4
85252: ARRAY
85253: PUSH
85254: LD_INT 1
85256: ARRAY
85257: PPUSH
85258: CALL 26823 0 2
85262: IFFALSE 85351
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
85264: LD_ADDR_EXP 63
85268: PUSH
85269: LD_EXP 63
85273: PPUSH
85274: LD_VAR 0 4
85278: PPUSH
85279: LD_EXP 63
85283: PUSH
85284: LD_VAR 0 4
85288: ARRAY
85289: PPUSH
85290: LD_INT 1
85292: PPUSH
85293: CALL_OW 3
85297: PPUSH
85298: CALL_OW 1
85302: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
85303: LD_ADDR_EXP 65
85307: PUSH
85308: LD_EXP 65
85312: PPUSH
85313: LD_VAR 0 4
85317: PUSH
85318: LD_EXP 65
85322: PUSH
85323: LD_VAR 0 4
85327: ARRAY
85328: PUSH
85329: LD_INT 1
85331: PLUS
85332: PUSH
85333: EMPTY
85334: LIST
85335: LIST
85336: PPUSH
85337: LD_VAR 0 1
85341: PPUSH
85342: CALL 20654 0 3
85346: ST_TO_ADDR
// exit ;
85347: POP
85348: POP
85349: GO 85355
// end ; end ;
85351: GO 85199
85353: POP
85354: POP
// end ;
85355: LD_VAR 0 3
85359: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
85360: LD_INT 0
85362: PPUSH
85363: PPUSH
85364: PPUSH
// if not mc_bases or not skirmish then
85365: LD_EXP 58
85369: NOT
85370: PUSH
85371: LD_EXP 56
85375: NOT
85376: OR
85377: IFFALSE 85381
// exit ;
85379: GO 85571
// for i = 1 to mc_bases do
85381: LD_ADDR_VAR 0 4
85385: PUSH
85386: DOUBLE
85387: LD_INT 1
85389: DEC
85390: ST_TO_ADDR
85391: LD_EXP 58
85395: PUSH
85396: FOR_TO
85397: IFFALSE 85484
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
85399: LD_VAR 0 1
85403: PUSH
85404: LD_EXP 66
85408: PUSH
85409: LD_VAR 0 4
85413: ARRAY
85414: IN
85415: PUSH
85416: LD_VAR 0 1
85420: PUSH
85421: LD_EXP 67
85425: PUSH
85426: LD_VAR 0 4
85430: ARRAY
85431: IN
85432: NOT
85433: AND
85434: IFFALSE 85482
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
85436: LD_ADDR_EXP 67
85440: PUSH
85441: LD_EXP 67
85445: PPUSH
85446: LD_VAR 0 4
85450: PUSH
85451: LD_EXP 67
85455: PUSH
85456: LD_VAR 0 4
85460: ARRAY
85461: PUSH
85462: LD_INT 1
85464: PLUS
85465: PUSH
85466: EMPTY
85467: LIST
85468: LIST
85469: PPUSH
85470: LD_VAR 0 1
85474: PPUSH
85475: CALL 20654 0 3
85479: ST_TO_ADDR
// break ;
85480: GO 85484
// end ; end ;
85482: GO 85396
85484: POP
85485: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
85486: LD_VAR 0 1
85490: PPUSH
85491: CALL_OW 257
85495: PUSH
85496: LD_EXP 84
85500: IN
85501: PUSH
85502: LD_VAR 0 1
85506: PPUSH
85507: CALL_OW 266
85511: PUSH
85512: LD_INT 5
85514: EQUAL
85515: AND
85516: PUSH
85517: LD_VAR 0 2
85521: PPUSH
85522: CALL_OW 110
85526: PUSH
85527: LD_INT 18
85529: NONEQUAL
85530: AND
85531: IFFALSE 85571
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
85533: LD_VAR 0 2
85537: PPUSH
85538: CALL_OW 257
85542: PUSH
85543: LD_INT 5
85545: PUSH
85546: LD_INT 8
85548: PUSH
85549: LD_INT 9
85551: PUSH
85552: EMPTY
85553: LIST
85554: LIST
85555: LIST
85556: IN
85557: IFFALSE 85571
// SetClass ( unit , 1 ) ;
85559: LD_VAR 0 2
85563: PPUSH
85564: LD_INT 1
85566: PPUSH
85567: CALL_OW 336
// end ;
85571: LD_VAR 0 3
85575: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
85576: LD_INT 0
85578: PPUSH
85579: PPUSH
// if not mc_bases or not skirmish then
85580: LD_EXP 58
85584: NOT
85585: PUSH
85586: LD_EXP 56
85590: NOT
85591: OR
85592: IFFALSE 85596
// exit ;
85594: GO 85712
// if GetLives ( abandoned_vehicle ) > 250 then
85596: LD_VAR 0 2
85600: PPUSH
85601: CALL_OW 256
85605: PUSH
85606: LD_INT 250
85608: GREATER
85609: IFFALSE 85613
// exit ;
85611: GO 85712
// for i = 1 to mc_bases do
85613: LD_ADDR_VAR 0 6
85617: PUSH
85618: DOUBLE
85619: LD_INT 1
85621: DEC
85622: ST_TO_ADDR
85623: LD_EXP 58
85627: PUSH
85628: FOR_TO
85629: IFFALSE 85710
// begin if driver in mc_bases [ i ] then
85631: LD_VAR 0 1
85635: PUSH
85636: LD_EXP 58
85640: PUSH
85641: LD_VAR 0 6
85645: ARRAY
85646: IN
85647: IFFALSE 85708
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
85649: LD_VAR 0 1
85653: PPUSH
85654: LD_EXP 58
85658: PUSH
85659: LD_VAR 0 6
85663: ARRAY
85664: PPUSH
85665: LD_INT 2
85667: PUSH
85668: LD_INT 30
85670: PUSH
85671: LD_INT 0
85673: PUSH
85674: EMPTY
85675: LIST
85676: LIST
85677: PUSH
85678: LD_INT 30
85680: PUSH
85681: LD_INT 1
85683: PUSH
85684: EMPTY
85685: LIST
85686: LIST
85687: PUSH
85688: EMPTY
85689: LIST
85690: LIST
85691: LIST
85692: PPUSH
85693: CALL_OW 72
85697: PUSH
85698: LD_INT 1
85700: ARRAY
85701: PPUSH
85702: CALL_OW 112
// break ;
85706: GO 85710
// end ; end ;
85708: GO 85628
85710: POP
85711: POP
// end ; end_of_file
85712: LD_VAR 0 5
85716: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
85717: GO 85719
85719: DISABLE
// begin ru_radar := 98 ;
85720: LD_ADDR_EXP 101
85724: PUSH
85725: LD_INT 98
85727: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
85728: LD_ADDR_EXP 102
85732: PUSH
85733: LD_INT 89
85735: ST_TO_ADDR
// us_hack := 99 ;
85736: LD_ADDR_EXP 103
85740: PUSH
85741: LD_INT 99
85743: ST_TO_ADDR
// us_artillery := 97 ;
85744: LD_ADDR_EXP 104
85748: PUSH
85749: LD_INT 97
85751: ST_TO_ADDR
// ar_bio_bomb := 91 ;
85752: LD_ADDR_EXP 105
85756: PUSH
85757: LD_INT 91
85759: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
85760: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
85761: LD_INT 0
85763: PPUSH
85764: PPUSH
85765: PPUSH
85766: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
85767: LD_VAR 0 1
85771: PPUSH
85772: CALL_OW 264
85776: PUSH
85777: LD_EXP 105
85781: EQUAL
85782: IFFALSE 85854
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
85784: LD_INT 68
85786: PPUSH
85787: LD_VAR 0 1
85791: PPUSH
85792: CALL_OW 255
85796: PPUSH
85797: CALL_OW 321
85801: PUSH
85802: LD_INT 2
85804: EQUAL
85805: IFFALSE 85817
// eff := 70 else
85807: LD_ADDR_VAR 0 6
85811: PUSH
85812: LD_INT 70
85814: ST_TO_ADDR
85815: GO 85825
// eff := 30 ;
85817: LD_ADDR_VAR 0 6
85821: PUSH
85822: LD_INT 30
85824: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
85825: LD_VAR 0 1
85829: PPUSH
85830: CALL_OW 250
85834: PPUSH
85835: LD_VAR 0 1
85839: PPUSH
85840: CALL_OW 251
85844: PPUSH
85845: LD_VAR 0 6
85849: PPUSH
85850: CALL_OW 495
// end ; end ;
85854: LD_VAR 0 4
85858: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
85859: LD_INT 0
85861: PPUSH
85862: PPUSH
85863: PPUSH
85864: PPUSH
85865: PPUSH
85866: PPUSH
// if cmd = 124 then
85867: LD_VAR 0 1
85871: PUSH
85872: LD_INT 124
85874: EQUAL
85875: IFFALSE 86081
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
85877: LD_ADDR_VAR 0 5
85881: PUSH
85882: LD_INT 2
85884: PUSH
85885: LD_INT 34
85887: PUSH
85888: LD_INT 53
85890: PUSH
85891: EMPTY
85892: LIST
85893: LIST
85894: PUSH
85895: LD_INT 34
85897: PUSH
85898: LD_INT 14
85900: PUSH
85901: EMPTY
85902: LIST
85903: LIST
85904: PUSH
85905: EMPTY
85906: LIST
85907: LIST
85908: LIST
85909: PPUSH
85910: CALL_OW 69
85914: ST_TO_ADDR
// if not tmp then
85915: LD_VAR 0 5
85919: NOT
85920: IFFALSE 85924
// exit ;
85922: GO 86081
// for i in tmp do
85924: LD_ADDR_VAR 0 3
85928: PUSH
85929: LD_VAR 0 5
85933: PUSH
85934: FOR_IN
85935: IFFALSE 86079
// begin taskList := GetTaskList ( i ) ;
85937: LD_ADDR_VAR 0 6
85941: PUSH
85942: LD_VAR 0 3
85946: PPUSH
85947: CALL_OW 437
85951: ST_TO_ADDR
// if not taskList then
85952: LD_VAR 0 6
85956: NOT
85957: IFFALSE 85961
// continue ;
85959: GO 85934
// for j = 1 to taskList do
85961: LD_ADDR_VAR 0 4
85965: PUSH
85966: DOUBLE
85967: LD_INT 1
85969: DEC
85970: ST_TO_ADDR
85971: LD_VAR 0 6
85975: PUSH
85976: FOR_TO
85977: IFFALSE 86075
// if taskList [ j ] [ 1 ] = | then
85979: LD_VAR 0 6
85983: PUSH
85984: LD_VAR 0 4
85988: ARRAY
85989: PUSH
85990: LD_INT 1
85992: ARRAY
85993: PUSH
85994: LD_STRING |
85996: EQUAL
85997: IFFALSE 86073
// begin _taskList := Delete ( taskList , 1 ) ;
85999: LD_ADDR_VAR 0 7
86003: PUSH
86004: LD_VAR 0 6
86008: PPUSH
86009: LD_INT 1
86011: PPUSH
86012: CALL_OW 3
86016: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
86017: LD_VAR 0 3
86021: PPUSH
86022: LD_VAR 0 7
86026: PPUSH
86027: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
86031: LD_VAR 0 3
86035: PPUSH
86036: LD_VAR 0 6
86040: PUSH
86041: LD_VAR 0 4
86045: ARRAY
86046: PUSH
86047: LD_INT 2
86049: ARRAY
86050: PPUSH
86051: LD_VAR 0 6
86055: PUSH
86056: LD_VAR 0 4
86060: ARRAY
86061: PUSH
86062: LD_INT 3
86064: ARRAY
86065: PPUSH
86066: LD_INT 8
86068: PPUSH
86069: CALL 86086 0 4
// end ;
86073: GO 85976
86075: POP
86076: POP
// end ;
86077: GO 85934
86079: POP
86080: POP
// end ; end ;
86081: LD_VAR 0 2
86085: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
86086: LD_INT 0
86088: PPUSH
86089: PPUSH
86090: PPUSH
86091: PPUSH
86092: PPUSH
86093: PPUSH
86094: PPUSH
86095: PPUSH
86096: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
86097: LD_VAR 0 1
86101: NOT
86102: PUSH
86103: LD_VAR 0 2
86107: PPUSH
86108: LD_VAR 0 3
86112: PPUSH
86113: CALL_OW 488
86117: NOT
86118: OR
86119: PUSH
86120: LD_VAR 0 4
86124: NOT
86125: OR
86126: IFFALSE 86130
// exit ;
86128: GO 86470
// list := [ ] ;
86130: LD_ADDR_VAR 0 13
86134: PUSH
86135: EMPTY
86136: ST_TO_ADDR
// if x - r < 0 then
86137: LD_VAR 0 2
86141: PUSH
86142: LD_VAR 0 4
86146: MINUS
86147: PUSH
86148: LD_INT 0
86150: LESS
86151: IFFALSE 86163
// min_x := 0 else
86153: LD_ADDR_VAR 0 7
86157: PUSH
86158: LD_INT 0
86160: ST_TO_ADDR
86161: GO 86179
// min_x := x - r ;
86163: LD_ADDR_VAR 0 7
86167: PUSH
86168: LD_VAR 0 2
86172: PUSH
86173: LD_VAR 0 4
86177: MINUS
86178: ST_TO_ADDR
// if y - r < 0 then
86179: LD_VAR 0 3
86183: PUSH
86184: LD_VAR 0 4
86188: MINUS
86189: PUSH
86190: LD_INT 0
86192: LESS
86193: IFFALSE 86205
// min_y := 0 else
86195: LD_ADDR_VAR 0 8
86199: PUSH
86200: LD_INT 0
86202: ST_TO_ADDR
86203: GO 86221
// min_y := y - r ;
86205: LD_ADDR_VAR 0 8
86209: PUSH
86210: LD_VAR 0 3
86214: PUSH
86215: LD_VAR 0 4
86219: MINUS
86220: ST_TO_ADDR
// max_x := x + r ;
86221: LD_ADDR_VAR 0 9
86225: PUSH
86226: LD_VAR 0 2
86230: PUSH
86231: LD_VAR 0 4
86235: PLUS
86236: ST_TO_ADDR
// max_y := y + r ;
86237: LD_ADDR_VAR 0 10
86241: PUSH
86242: LD_VAR 0 3
86246: PUSH
86247: LD_VAR 0 4
86251: PLUS
86252: ST_TO_ADDR
// for _x = min_x to max_x do
86253: LD_ADDR_VAR 0 11
86257: PUSH
86258: DOUBLE
86259: LD_VAR 0 7
86263: DEC
86264: ST_TO_ADDR
86265: LD_VAR 0 9
86269: PUSH
86270: FOR_TO
86271: IFFALSE 86388
// for _y = min_y to max_y do
86273: LD_ADDR_VAR 0 12
86277: PUSH
86278: DOUBLE
86279: LD_VAR 0 8
86283: DEC
86284: ST_TO_ADDR
86285: LD_VAR 0 10
86289: PUSH
86290: FOR_TO
86291: IFFALSE 86384
// begin if not ValidHex ( _x , _y ) then
86293: LD_VAR 0 11
86297: PPUSH
86298: LD_VAR 0 12
86302: PPUSH
86303: CALL_OW 488
86307: NOT
86308: IFFALSE 86312
// continue ;
86310: GO 86290
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
86312: LD_VAR 0 11
86316: PPUSH
86317: LD_VAR 0 12
86321: PPUSH
86322: CALL_OW 351
86326: PUSH
86327: LD_VAR 0 11
86331: PPUSH
86332: LD_VAR 0 12
86336: PPUSH
86337: CALL_OW 554
86341: AND
86342: IFFALSE 86382
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
86344: LD_ADDR_VAR 0 13
86348: PUSH
86349: LD_VAR 0 13
86353: PPUSH
86354: LD_VAR 0 13
86358: PUSH
86359: LD_INT 1
86361: PLUS
86362: PPUSH
86363: LD_VAR 0 11
86367: PUSH
86368: LD_VAR 0 12
86372: PUSH
86373: EMPTY
86374: LIST
86375: LIST
86376: PPUSH
86377: CALL_OW 2
86381: ST_TO_ADDR
// end ;
86382: GO 86290
86384: POP
86385: POP
86386: GO 86270
86388: POP
86389: POP
// if not list then
86390: LD_VAR 0 13
86394: NOT
86395: IFFALSE 86399
// exit ;
86397: GO 86470
// for i in list do
86399: LD_ADDR_VAR 0 6
86403: PUSH
86404: LD_VAR 0 13
86408: PUSH
86409: FOR_IN
86410: IFFALSE 86468
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
86412: LD_VAR 0 1
86416: PPUSH
86417: LD_STRING M
86419: PUSH
86420: LD_VAR 0 6
86424: PUSH
86425: LD_INT 1
86427: ARRAY
86428: PUSH
86429: LD_VAR 0 6
86433: PUSH
86434: LD_INT 2
86436: ARRAY
86437: PUSH
86438: LD_INT 0
86440: PUSH
86441: LD_INT 0
86443: PUSH
86444: LD_INT 0
86446: PUSH
86447: LD_INT 0
86449: PUSH
86450: EMPTY
86451: LIST
86452: LIST
86453: LIST
86454: LIST
86455: LIST
86456: LIST
86457: LIST
86458: PUSH
86459: EMPTY
86460: LIST
86461: PPUSH
86462: CALL_OW 447
86466: GO 86409
86468: POP
86469: POP
// end ;
86470: LD_VAR 0 5
86474: RET
