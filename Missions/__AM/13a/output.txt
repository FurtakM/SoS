// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 623 0 0
// InitMacro ;
  19: CALL 57291 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 49058 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 49058 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 49058 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 49058 0 9
// PrepareArabian ;
 147: CALL 3602 0 0
// PrepareRussian ;
 151: CALL 2737 0 0
// PrepareAlliance ;
 155: CALL 733 0 0
// MC_Start ( ) ;
 159: CALL 59403 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6765 0 0
// PrepareBurlak ;
 180: CALL 2116 0 0
// end ;
 184: END
// export function CustomInitMacro ; var i ; begin
 185: LD_INT 0
 187: PPUSH
 188: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 189: LD_ADDR_EXP 82
 193: PUSH
 194: LD_INT 1
 196: PUSH
 197: LD_INT 2
 199: PUSH
 200: EMPTY
 201: LIST
 202: LIST
 203: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 204: LD_ADDR_EXP 83
 208: PUSH
 209: LD_INT 3
 211: PUSH
 212: LD_INT 4
 214: PUSH
 215: EMPTY
 216: LIST
 217: LIST
 218: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 219: LD_INT 1
 221: PPUSH
 222: LD_INT 12
 224: PUSH
 225: LD_INT 15
 227: PUSH
 228: LD_INT 18
 230: PUSH
 231: EMPTY
 232: LIST
 233: LIST
 234: LIST
 235: PUSH
 236: LD_OWVAR 67
 240: ARRAY
 241: PPUSH
 242: LD_INT 7
 244: PPUSH
 245: CALL 80724 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 249: LD_INT 1
 251: PPUSH
 252: LD_EXP 53
 256: PPUSH
 257: CALL 81150 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 261: LD_INT 1
 263: PPUSH
 264: LD_INT 6
 266: PPUSH
 267: CALL 81608 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 271: LD_INT 1
 273: PPUSH
 274: LD_INT 9
 276: PUSH
 277: EMPTY
 278: LIST
 279: PPUSH
 280: CALL 81877 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 284: LD_INT 1
 286: PPUSH
 287: LD_INT 13
 289: PUSH
 290: LD_INT 1
 292: PUSH
 293: LD_INT 2
 295: PUSH
 296: LD_INT 32
 298: PUSH
 299: EMPTY
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: PUSH
 305: EMPTY
 306: LIST
 307: PPUSH
 308: CALL 81090 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 312: LD_INT 2
 314: PPUSH
 315: LD_INT 12
 317: PUSH
 318: LD_INT 14
 320: PUSH
 321: LD_INT 10
 323: PUSH
 324: LD_INT 11
 326: PUSH
 327: EMPTY
 328: LIST
 329: LIST
 330: LIST
 331: LIST
 332: PPUSH
 333: CALL 81784 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 337: LD_INT 2
 339: PPUSH
 340: LD_EXP 50
 344: PPUSH
 345: CALL 81150 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 349: LD_INT 2
 351: PPUSH
 352: LD_INT 8
 354: PPUSH
 355: CALL 81608 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 359: LD_INT 2
 361: PPUSH
 362: LD_INT 10
 364: PUSH
 365: EMPTY
 366: LIST
 367: PPUSH
 368: CALL 81877 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 372: LD_INT 2
 374: PPUSH
 375: LD_INT 6
 377: PUSH
 378: LD_INT 71
 380: PUSH
 381: LD_INT 116
 383: PUSH
 384: LD_INT 4
 386: PUSH
 387: EMPTY
 388: LIST
 389: LIST
 390: LIST
 391: LIST
 392: PUSH
 393: LD_INT 4
 395: PUSH
 396: LD_INT 85
 398: PUSH
 399: LD_INT 116
 401: PUSH
 402: LD_INT 4
 404: PUSH
 405: EMPTY
 406: LIST
 407: LIST
 408: LIST
 409: LIST
 410: PUSH
 411: LD_INT 32
 413: PUSH
 414: LD_INT 83
 416: PUSH
 417: LD_INT 111
 419: PUSH
 420: LD_INT 4
 422: PUSH
 423: EMPTY
 424: LIST
 425: LIST
 426: LIST
 427: LIST
 428: PUSH
 429: LD_INT 32
 431: PUSH
 432: LD_INT 87
 434: PUSH
 435: LD_INT 121
 437: PUSH
 438: LD_INT 4
 440: PUSH
 441: EMPTY
 442: LIST
 443: LIST
 444: LIST
 445: LIST
 446: PUSH
 447: LD_INT 33
 449: PUSH
 450: LD_INT 88
 452: PUSH
 453: LD_INT 128
 455: PUSH
 456: LD_INT 4
 458: PUSH
 459: EMPTY
 460: LIST
 461: LIST
 462: LIST
 463: LIST
 464: PUSH
 465: LD_INT 32
 467: PUSH
 468: LD_INT 59
 470: PUSH
 471: LD_INT 89
 473: PUSH
 474: LD_INT 3
 476: PUSH
 477: EMPTY
 478: LIST
 479: LIST
 480: LIST
 481: LIST
 482: PUSH
 483: LD_INT 33
 485: PUSH
 486: LD_INT 69
 488: PUSH
 489: LD_INT 98
 491: PUSH
 492: LD_INT 3
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: PUSH
 501: LD_INT 33
 503: PUSH
 504: LD_INT 77
 506: PUSH
 507: LD_INT 103
 509: PUSH
 510: LD_INT 3
 512: PUSH
 513: EMPTY
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: PUSH
 519: LD_INT 33
 521: PUSH
 522: LD_INT 83
 524: PUSH
 525: LD_INT 105
 527: PUSH
 528: LD_INT 3
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: LIST
 535: LIST
 536: PUSH
 537: LD_INT 33
 539: PUSH
 540: LD_INT 71
 542: PUSH
 543: LD_INT 125
 545: PUSH
 546: LD_INT 5
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: LIST
 553: LIST
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: LIST
 563: LIST
 564: LIST
 565: LIST
 566: PPUSH
 567: CALL 80934 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 571: LD_INT 2
 573: PPUSH
 574: LD_INT 21
 576: PUSH
 577: LD_INT 1
 579: PUSH
 580: LD_INT 3
 582: PUSH
 583: LD_INT 51
 585: PUSH
 586: EMPTY
 587: LIST
 588: LIST
 589: LIST
 590: LIST
 591: PUSH
 592: LD_INT 22
 594: PUSH
 595: LD_INT 1
 597: PUSH
 598: LD_INT 3
 600: PUSH
 601: LD_INT 52
 603: PUSH
 604: EMPTY
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: PUSH
 610: EMPTY
 611: LIST
 612: LIST
 613: PPUSH
 614: CALL 81090 0 2
// end ;
 618: LD_VAR 0 1
 622: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 623: LD_INT 0
 625: PPUSH
// debug := 1 ;
 626: LD_ADDR_EXP 1
 630: PUSH
 631: LD_INT 1
 633: ST_TO_ADDR
// game := true ;
 634: LD_ADDR_EXP 2
 638: PUSH
 639: LD_INT 1
 641: ST_TO_ADDR
// gossudarov_arrive := false ;
 642: LD_ADDR_EXP 4
 646: PUSH
 647: LD_INT 0
 649: ST_TO_ADDR
// ru_lab_builded := false ;
 650: LD_ADDR_EXP 5
 654: PUSH
 655: LD_INT 0
 657: ST_TO_ADDR
// player_spotted := false ;
 658: LD_ADDR_EXP 6
 662: PUSH
 663: LD_INT 0
 665: ST_TO_ADDR
// first_attack := false ;
 666: LD_ADDR_EXP 7
 670: PUSH
 671: LD_INT 0
 673: ST_TO_ADDR
// ru_attackers := [ ] ;
 674: LD_ADDR_EXP 51
 678: PUSH
 679: EMPTY
 680: ST_TO_ADDR
// ar_base_spotted := false ;
 681: LD_ADDR_EXP 8
 685: PUSH
 686: LD_INT 0
 688: ST_TO_ADDR
// ar_active_attack := false ;
 689: LD_ADDR_EXP 9
 693: PUSH
 694: LD_INT 0
 696: ST_TO_ADDR
// ar_attackers := [ ] ;
 697: LD_ADDR_EXP 10
 701: PUSH
 702: EMPTY
 703: ST_TO_ADDR
// first_powell_attack := false ;
 704: LD_ADDR_EXP 11
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// abdul_escaped := true ;
 712: LD_ADDR_EXP 12
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// loss_counter := 0 ;
 720: LD_ADDR_EXP 13
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// end ; end_of_file
 728: LD_VAR 0 1
 732: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 733: LD_INT 0
 735: PPUSH
 736: PPUSH
 737: PPUSH
 738: PPUSH
// uc_side := 7 ;
 739: LD_ADDR_OWVAR 20
 743: PUSH
 744: LD_INT 7
 746: ST_TO_ADDR
// uc_nation := 1 ;
 747: LD_ADDR_OWVAR 21
 751: PUSH
 752: LD_INT 1
 754: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 755: LD_ADDR_EXP 14
 759: PUSH
 760: LD_STRING JMM
 762: PPUSH
 763: LD_EXP 1
 767: NOT
 768: PPUSH
 769: LD_STRING 12a_
 771: PPUSH
 772: CALL 14129 0 3
 776: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 777: LD_EXP 14
 781: PPUSH
 782: LD_INT 71
 784: PPUSH
 785: LD_INT 23
 787: PPUSH
 788: LD_INT 0
 790: PPUSH
 791: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 795: LD_EXP 14
 799: PPUSH
 800: LD_INT 2
 802: PPUSH
 803: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 807: LD_ADDR_EXP 15
 811: PUSH
 812: LD_STRING Roth
 814: PPUSH
 815: LD_EXP 1
 819: NOT
 820: PPUSH
 821: LD_STRING 12a_
 823: PPUSH
 824: CALL 14129 0 3
 828: ST_TO_ADDR
// if Roth then
 829: LD_EXP 15
 833: IFFALSE 853
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 835: LD_EXP 15
 839: PPUSH
 840: LD_INT 71
 842: PPUSH
 843: LD_INT 21
 845: PPUSH
 846: LD_INT 0
 848: PPUSH
 849: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 853: LD_ADDR_EXP 16
 857: PUSH
 858: LD_STRING Lisa
 860: PPUSH
 861: LD_EXP 1
 865: NOT
 866: PPUSH
 867: LD_STRING 12a_
 869: PPUSH
 870: CALL 14129 0 3
 874: ST_TO_ADDR
// if Lisa then
 875: LD_EXP 16
 879: IFFALSE 896
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 881: LD_EXP 16
 885: PPUSH
 886: LD_INT 13
 888: PPUSH
 889: LD_INT 0
 891: PPUSH
 892: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 896: LD_ADDR_EXP 17
 900: PUSH
 901: LD_STRING Donaldson
 903: PPUSH
 904: LD_EXP 1
 908: NOT
 909: PPUSH
 910: LD_STRING 12a_
 912: PPUSH
 913: CALL 14129 0 3
 917: ST_TO_ADDR
// if Donaldson then
 918: LD_EXP 17
 922: IFFALSE 939
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 924: LD_EXP 17
 928: PPUSH
 929: LD_INT 13
 931: PPUSH
 932: LD_INT 0
 934: PPUSH
 935: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 939: LD_ADDR_EXP 18
 943: PUSH
 944: LD_STRING Bobby
 946: PPUSH
 947: LD_EXP 1
 951: NOT
 952: PPUSH
 953: LD_STRING 12a_
 955: PPUSH
 956: CALL 14129 0 3
 960: ST_TO_ADDR
// if Bobby then
 961: LD_EXP 18
 965: IFFALSE 982
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 967: LD_EXP 18
 971: PPUSH
 972: LD_INT 13
 974: PPUSH
 975: LD_INT 0
 977: PPUSH
 978: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 982: LD_ADDR_EXP 19
 986: PUSH
 987: LD_STRING Cyrus
 989: PPUSH
 990: LD_EXP 1
 994: NOT
 995: PPUSH
 996: LD_STRING 12a_
 998: PPUSH
 999: CALL 14129 0 3
1003: ST_TO_ADDR
// if Cyrus then
1004: LD_EXP 19
1008: IFFALSE 1025
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1010: LD_EXP 19
1014: PPUSH
1015: LD_INT 13
1017: PPUSH
1018: LD_INT 0
1020: PPUSH
1021: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1025: LD_ADDR_EXP 20
1029: PUSH
1030: LD_STRING Denis
1032: PPUSH
1033: LD_EXP 1
1037: NOT
1038: PPUSH
1039: LD_STRING 12a_
1041: PPUSH
1042: CALL 14129 0 3
1046: ST_TO_ADDR
// if Denis then
1047: LD_EXP 20
1051: IFFALSE 1068
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1053: LD_EXP 20
1057: PPUSH
1058: LD_INT 13
1060: PPUSH
1061: LD_INT 0
1063: PPUSH
1064: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1068: LD_ADDR_EXP 21
1072: PUSH
1073: LD_STRING Brown
1075: PPUSH
1076: LD_EXP 1
1080: NOT
1081: PPUSH
1082: LD_STRING 12a_
1084: PPUSH
1085: CALL 14129 0 3
1089: ST_TO_ADDR
// if Brown then
1090: LD_EXP 21
1094: IFFALSE 1111
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1096: LD_EXP 21
1100: PPUSH
1101: LD_INT 13
1103: PPUSH
1104: LD_INT 0
1106: PPUSH
1107: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1111: LD_ADDR_EXP 22
1115: PUSH
1116: LD_STRING Gladstone
1118: PPUSH
1119: LD_EXP 1
1123: NOT
1124: PPUSH
1125: LD_STRING 12a_
1127: PPUSH
1128: CALL 14129 0 3
1132: ST_TO_ADDR
// if Gladstone then
1133: LD_EXP 22
1137: IFFALSE 1154
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1139: LD_EXP 22
1143: PPUSH
1144: LD_INT 13
1146: PPUSH
1147: LD_INT 0
1149: PPUSH
1150: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1154: LD_ADDR_EXP 23
1158: PUSH
1159: LD_STRING Houten
1161: PPUSH
1162: LD_EXP 1
1166: NOT
1167: PPUSH
1168: LD_STRING 12a_
1170: PPUSH
1171: CALL 14129 0 3
1175: ST_TO_ADDR
// if Houten then
1176: LD_EXP 23
1180: IFFALSE 1197
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1182: LD_EXP 23
1186: PPUSH
1187: LD_INT 13
1189: PPUSH
1190: LD_INT 0
1192: PPUSH
1193: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1197: LD_ADDR_EXP 24
1201: PUSH
1202: LD_STRING Cornell
1204: PPUSH
1205: LD_EXP 1
1209: NOT
1210: PPUSH
1211: LD_STRING 12a_
1213: PPUSH
1214: CALL 14129 0 3
1218: ST_TO_ADDR
// if Cornel then
1219: LD_EXP 24
1223: IFFALSE 1240
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1225: LD_EXP 24
1229: PPUSH
1230: LD_INT 13
1232: PPUSH
1233: LD_INT 0
1235: PPUSH
1236: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1240: LD_ADDR_EXP 25
1244: PUSH
1245: LD_STRING Gary
1247: PPUSH
1248: LD_EXP 1
1252: NOT
1253: PPUSH
1254: LD_STRING 12a_
1256: PPUSH
1257: CALL 14129 0 3
1261: ST_TO_ADDR
// if Gary then
1262: LD_EXP 25
1266: IFFALSE 1283
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1268: LD_EXP 25
1272: PPUSH
1273: LD_INT 13
1275: PPUSH
1276: LD_INT 0
1278: PPUSH
1279: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1283: LD_ADDR_EXP 26
1287: PUSH
1288: LD_STRING Frank
1290: PPUSH
1291: LD_EXP 1
1295: NOT
1296: PPUSH
1297: LD_STRING 12a_
1299: PPUSH
1300: CALL 14129 0 3
1304: ST_TO_ADDR
// if Frank then
1305: LD_EXP 26
1309: IFFALSE 1326
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1311: LD_EXP 26
1315: PPUSH
1316: LD_INT 13
1318: PPUSH
1319: LD_INT 0
1321: PPUSH
1322: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1326: LD_ADDR_EXP 27
1330: PUSH
1331: LD_STRING Kikuchi
1333: PPUSH
1334: LD_EXP 1
1338: NOT
1339: PPUSH
1340: LD_STRING 12a_
1342: PPUSH
1343: CALL 14129 0 3
1347: ST_TO_ADDR
// if Kikuchi then
1348: LD_EXP 27
1352: IFFALSE 1369
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1354: LD_EXP 27
1358: PPUSH
1359: LD_INT 13
1361: PPUSH
1362: LD_INT 0
1364: PPUSH
1365: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1369: LD_ADDR_EXP 28
1373: PUSH
1374: LD_STRING Simms
1376: PPUSH
1377: LD_EXP 1
1381: NOT
1382: PPUSH
1383: LD_STRING 12a_
1385: PPUSH
1386: CALL 14129 0 3
1390: ST_TO_ADDR
// if Simms then
1391: LD_EXP 28
1395: IFFALSE 1412
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1397: LD_EXP 28
1401: PPUSH
1402: LD_INT 13
1404: PPUSH
1405: LD_INT 0
1407: PPUSH
1408: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1412: LD_ADDR_EXP 29
1416: PUSH
1417: LD_STRING Joan
1419: PPUSH
1420: LD_EXP 1
1424: NOT
1425: PPUSH
1426: LD_STRING 12a_
1428: PPUSH
1429: CALL 14129 0 3
1433: ST_TO_ADDR
// if Joan then
1434: LD_EXP 29
1438: IFFALSE 1455
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1440: LD_EXP 29
1444: PPUSH
1445: LD_INT 13
1447: PPUSH
1448: LD_INT 0
1450: PPUSH
1451: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1455: LD_ADDR_EXP 30
1459: PUSH
1460: LD_STRING DeltaDoctor
1462: PPUSH
1463: LD_EXP 1
1467: NOT
1468: PPUSH
1469: LD_STRING 12a_
1471: PPUSH
1472: CALL 14129 0 3
1476: ST_TO_ADDR
// if DeltaDoctor then
1477: LD_EXP 30
1481: IFFALSE 1498
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1483: LD_EXP 30
1487: PPUSH
1488: LD_INT 13
1490: PPUSH
1491: LD_INT 0
1493: PPUSH
1494: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1498: LD_ADDR_VAR 0 4
1502: PUSH
1503: LD_STRING 12a_others
1505: PPUSH
1506: CALL_OW 31
1510: ST_TO_ADDR
// if tmp then
1511: LD_VAR 0 4
1515: IFFALSE 1549
// for i in tmp do
1517: LD_ADDR_VAR 0 3
1521: PUSH
1522: LD_VAR 0 4
1526: PUSH
1527: FOR_IN
1528: IFFALSE 1547
// PlaceUnitArea ( i , alliance_start , false ) ;
1530: LD_VAR 0 3
1534: PPUSH
1535: LD_INT 13
1537: PPUSH
1538: LD_INT 0
1540: PPUSH
1541: CALL_OW 49
1545: GO 1527
1547: POP
1548: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1549: LD_INT 3
1551: PPUSH
1552: LD_INT 3
1554: PPUSH
1555: LD_INT 3
1557: PPUSH
1558: LD_INT 12
1560: PPUSH
1561: LD_INT 100
1563: PPUSH
1564: CALL 21244 0 5
// veh := CreateVehicle ;
1568: LD_ADDR_VAR 0 2
1572: PUSH
1573: CALL_OW 45
1577: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1578: LD_VAR 0 2
1582: PPUSH
1583: LD_INT 2
1585: PPUSH
1586: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1590: LD_VAR 0 2
1594: PPUSH
1595: LD_INT 60
1597: PPUSH
1598: LD_INT 6
1600: PPUSH
1601: LD_INT 0
1603: PPUSH
1604: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1608: LD_VAR 0 2
1612: PPUSH
1613: LD_INT 4
1615: PPUSH
1616: LD_INT 30
1618: PPUSH
1619: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1623: LD_STRING 11_artifact_captured
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 30
1633: IFFALSE 1709
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1635: LD_INT 3
1637: PPUSH
1638: LD_INT 3
1640: PPUSH
1641: LD_INT 3
1643: PPUSH
1644: LD_INT 12
1646: PPUSH
1647: LD_INT 100
1649: PPUSH
1650: CALL 21244 0 5
// veh := CreateVehicle ;
1654: LD_ADDR_VAR 0 2
1658: PUSH
1659: CALL_OW 45
1663: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1664: LD_VAR 0 2
1668: PPUSH
1669: LD_INT 3
1671: PPUSH
1672: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1676: LD_VAR 0 2
1680: PPUSH
1681: LD_INT 75
1683: PPUSH
1684: LD_INT 6
1686: PPUSH
1687: LD_INT 0
1689: PPUSH
1690: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1694: LD_VAR 0 2
1698: PPUSH
1699: LD_INT 4
1701: PPUSH
1702: LD_INT 50
1704: PPUSH
1705: CALL_OW 290
// end ; end ;
1709: LD_VAR 0 1
1713: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1714: LD_INT 0
1716: PPUSH
1717: PPUSH
1718: PPUSH
1719: PPUSH
// uc_side := 6 ;
1720: LD_ADDR_OWVAR 20
1724: PUSH
1725: LD_INT 6
1727: ST_TO_ADDR
// uc_nation := 3 ;
1728: LD_ADDR_OWVAR 21
1732: PUSH
1733: LD_INT 3
1735: ST_TO_ADDR
// InitHc ;
1736: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1740: LD_ADDR_EXP 31
1744: PUSH
1745: LD_STRING Gossudarov
1747: PPUSH
1748: CALL_OW 25
1752: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1753: LD_ADDR_EXP 32
1757: PUSH
1758: LD_STRING Kirilenkova
1760: PPUSH
1761: CALL_OW 25
1765: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1766: LD_ADDR_EXP 33
1770: PUSH
1771: LD_STRING Titov
1773: PPUSH
1774: CALL_OW 25
1778: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1779: LD_ADDR_EXP 38
1783: PUSH
1784: LD_STRING Oblukov
1786: PPUSH
1787: CALL_OW 25
1791: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1792: LD_ADDR_EXP 35
1796: PUSH
1797: LD_STRING Dolgov
1799: PPUSH
1800: CALL_OW 25
1804: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1805: LD_ADDR_EXP 36
1809: PUSH
1810: LD_STRING Petrosyan
1812: PPUSH
1813: CALL_OW 25
1817: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1818: LD_ADDR_EXP 37
1822: PUSH
1823: LD_STRING Scholtze
1825: PPUSH
1826: CALL_OW 25
1830: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1831: LD_ADDR_EXP 39
1835: PUSH
1836: LD_STRING Kapitsova
1838: PPUSH
1839: CALL_OW 25
1843: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1844: LD_ADDR_VAR 0 2
1848: PUSH
1849: LD_EXP 31
1853: PUSH
1854: LD_EXP 32
1858: PUSH
1859: LD_EXP 33
1863: PUSH
1864: LD_EXP 38
1868: PUSH
1869: LD_EXP 35
1873: PUSH
1874: LD_EXP 36
1878: PUSH
1879: LD_EXP 37
1883: PUSH
1884: LD_EXP 39
1888: PUSH
1889: EMPTY
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1899: LD_INT 1
1901: PPUSH
1902: LD_INT 4
1904: PPUSH
1905: LD_INT 8
1907: PPUSH
1908: CALL_OW 380
// un := CreateHuman ;
1912: LD_ADDR_VAR 0 4
1916: PUSH
1917: CALL_OW 44
1921: ST_TO_ADDR
// tmp := tmp ^ un ;
1922: LD_ADDR_VAR 0 2
1926: PUSH
1927: LD_VAR 0 2
1931: PUSH
1932: LD_VAR 0 4
1936: ADD
1937: ST_TO_ADDR
// for i in tmp do
1938: LD_ADDR_VAR 0 3
1942: PUSH
1943: LD_VAR 0 2
1947: PUSH
1948: FOR_IN
1949: IFFALSE 1968
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1951: LD_VAR 0 3
1955: PPUSH
1956: LD_INT 14
1958: PPUSH
1959: LD_INT 0
1961: PPUSH
1962: CALL_OW 49
1966: GO 1948
1968: POP
1969: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1970: LD_VAR 0 2
1974: PPUSH
1975: LD_EXP 3
1979: PPUSH
1980: CALL_OW 250
1984: PPUSH
1985: LD_EXP 3
1989: PPUSH
1990: CALL_OW 251
1994: PPUSH
1995: CALL_OW 111
// end ;
1999: LD_VAR 0 1
2003: RET
// export function PrepareBelkov ; begin
2004: LD_INT 0
2006: PPUSH
// uc_side := 4 ;
2007: LD_ADDR_OWVAR 20
2011: PUSH
2012: LD_INT 4
2014: ST_TO_ADDR
// uc_nation := 3 ;
2015: LD_ADDR_OWVAR 21
2019: PUSH
2020: LD_INT 3
2022: ST_TO_ADDR
// InitHc ;
2023: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2027: LD_ADDR_EXP 46
2031: PUSH
2032: LD_STRING Belkov
2034: PPUSH
2035: CALL_OW 25
2039: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2040: LD_EXP 46
2044: PPUSH
2045: LD_INT 14
2047: PPUSH
2048: LD_INT 0
2050: PPUSH
2051: CALL_OW 49
// end ;
2055: LD_VAR 0 1
2059: RET
// export function PrepareGnyevko ; begin
2060: LD_INT 0
2062: PPUSH
// uc_side := 4 ;
2063: LD_ADDR_OWVAR 20
2067: PUSH
2068: LD_INT 4
2070: ST_TO_ADDR
// uc_nation := 3 ;
2071: LD_ADDR_OWVAR 21
2075: PUSH
2076: LD_INT 3
2078: ST_TO_ADDR
// InitHc ;
2079: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2083: LD_ADDR_EXP 47
2087: PUSH
2088: LD_STRING Gnyevko
2090: PPUSH
2091: CALL_OW 25
2095: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2096: LD_EXP 47
2100: PPUSH
2101: LD_INT 14
2103: PPUSH
2104: LD_INT 0
2106: PPUSH
2107: CALL_OW 49
// end ;
2111: LD_VAR 0 1
2115: RET
// export function PrepareBurlak ; var i , tmp ; begin
2116: LD_INT 0
2118: PPUSH
2119: PPUSH
2120: PPUSH
// uc_side := 4 ;
2121: LD_ADDR_OWVAR 20
2125: PUSH
2126: LD_INT 4
2128: ST_TO_ADDR
// uc_nation := 3 ;
2129: LD_ADDR_OWVAR 21
2133: PUSH
2134: LD_INT 3
2136: ST_TO_ADDR
// InitHc ;
2137: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2141: LD_ADDR_EXP 45
2145: PUSH
2146: LD_STRING Burlak
2148: PPUSH
2149: CALL_OW 25
2153: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2154: LD_INT 24
2156: PUSH
2157: LD_INT 23
2159: PUSH
2160: LD_INT 22
2162: PUSH
2163: EMPTY
2164: LIST
2165: LIST
2166: LIST
2167: PUSH
2168: LD_OWVAR 67
2172: ARRAY
2173: PPUSH
2174: LD_INT 1
2176: PPUSH
2177: LD_INT 1
2179: PPUSH
2180: LD_INT 45
2182: PUSH
2183: LD_INT 44
2185: PUSH
2186: LD_INT 43
2188: PUSH
2189: EMPTY
2190: LIST
2191: LIST
2192: LIST
2193: PUSH
2194: LD_OWVAR 67
2198: ARRAY
2199: PPUSH
2200: LD_INT 0
2202: PPUSH
2203: CALL 21244 0 5
// Masha := CreateVehicle ;
2207: LD_ADDR_EXP 48
2211: PUSH
2212: CALL_OW 45
2216: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2217: LD_EXP 48
2221: PUSH
2222: LD_EXP 45
2226: PUSH
2227: EMPTY
2228: LIST
2229: LIST
2230: PPUSH
2231: LD_INT 499
2233: PPUSH
2234: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2238: LD_EXP 48
2242: PPUSH
2243: LD_INT 3
2245: PPUSH
2246: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2250: LD_EXP 48
2254: PPUSH
2255: LD_INT 1
2257: PPUSH
2258: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2262: LD_INT 1
2264: PPUSH
2265: LD_INT 18
2267: PPUSH
2268: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2272: LD_INT 35
2274: PPUSH
2275: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2279: LD_ADDR_VAR 0 3
2283: PUSH
2284: LD_INT 18
2286: PPUSH
2287: EMPTY
2288: PPUSH
2289: CALL_OW 70
2293: ST_TO_ADDR
// if tmp then
2294: LD_VAR 0 3
2298: IFFALSE 2332
// for i in tmp do
2300: LD_ADDR_VAR 0 2
2304: PUSH
2305: LD_VAR 0 3
2309: PUSH
2310: FOR_IN
2311: IFFALSE 2330
// ComMoveXY ( i , 114 , 9 ) ;
2313: LD_VAR 0 2
2317: PPUSH
2318: LD_INT 114
2320: PPUSH
2321: LD_INT 9
2323: PPUSH
2324: CALL_OW 111
2328: GO 2310
2330: POP
2331: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2332: LD_INT 18
2334: PPUSH
2335: EMPTY
2336: PPUSH
2337: CALL_OW 70
2341: NOT
2342: PUSH
2343: LD_INT 123
2345: PPUSH
2346: LD_INT 3
2348: PPUSH
2349: CALL_OW 428
2353: PUSH
2354: LD_INT 0
2356: EQUAL
2357: AND
2358: IFFALSE 2272
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2360: LD_EXP 48
2364: PPUSH
2365: LD_INT 123
2367: PPUSH
2368: LD_INT 3
2370: PPUSH
2371: LD_INT 0
2373: PPUSH
2374: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2378: LD_EXP 45
2382: PPUSH
2383: LD_INT 125
2385: PPUSH
2386: LD_INT 1
2388: PPUSH
2389: LD_INT 0
2391: PPUSH
2392: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2396: LD_EXP 45
2400: PPUSH
2401: LD_EXP 48
2405: PPUSH
2406: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2410: LD_INT 10
2412: PPUSH
2413: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2417: LD_EXP 48
2421: PPUSH
2422: LD_INT 110
2424: PPUSH
2425: LD_INT 10
2427: PPUSH
2428: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2432: LD_ADDR_EXP 41
2436: PUSH
2437: LD_STRING Petrovova
2439: PPUSH
2440: CALL_OW 25
2444: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2445: LD_ADDR_EXP 43
2449: PUSH
2450: LD_STRING Kuzmov
2452: PPUSH
2453: CALL_OW 25
2457: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2458: LD_ADDR_EXP 42
2462: PUSH
2463: LD_STRING Kovalyuk
2465: PPUSH
2466: CALL_OW 25
2470: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2471: LD_ADDR_EXP 40
2475: PUSH
2476: LD_STRING Lipshchin
2478: PPUSH
2479: CALL_OW 25
2483: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2484: LD_ADDR_EXP 44
2488: PUSH
2489: LD_STRING Karamazov
2491: PPUSH
2492: CALL_OW 25
2496: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2497: LD_ADDR_VAR 0 3
2501: PUSH
2502: LD_EXP 41
2506: PUSH
2507: LD_EXP 43
2511: PUSH
2512: LD_EXP 42
2516: PUSH
2517: LD_EXP 40
2521: PUSH
2522: LD_EXP 44
2526: PUSH
2527: EMPTY
2528: LIST
2529: LIST
2530: LIST
2531: LIST
2532: LIST
2533: ST_TO_ADDR
// for i in tmp do
2534: LD_ADDR_VAR 0 2
2538: PUSH
2539: LD_VAR 0 3
2543: PUSH
2544: FOR_IN
2545: IFFALSE 2584
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2547: LD_VAR 0 2
2551: PPUSH
2552: LD_INT 399
2554: PPUSH
2555: LD_INT 799
2557: PPUSH
2558: CALL_OW 12
2562: PPUSH
2563: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2567: LD_VAR 0 2
2571: PPUSH
2572: LD_INT 19
2574: PPUSH
2575: LD_INT 0
2577: PPUSH
2578: CALL_OW 49
// end ;
2582: GO 2544
2584: POP
2585: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2586: LD_VAR 0 3
2590: PPUSH
2591: LD_INT 116
2593: PPUSH
2594: LD_INT 8
2596: PPUSH
2597: CALL_OW 111
// AddComHold ( tmp ) ;
2601: LD_VAR 0 3
2605: PPUSH
2606: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2610: LD_ADDR_VAR 0 2
2614: PUSH
2615: LD_VAR 0 3
2619: PPUSH
2620: LD_INT 25
2622: PUSH
2623: LD_INT 1
2625: PUSH
2626: EMPTY
2627: LIST
2628: LIST
2629: PPUSH
2630: CALL_OW 72
2634: PUSH
2635: FOR_IN
2636: IFFALSE 2676
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2638: LD_VAR 0 2
2642: PPUSH
2643: LD_INT 20
2645: PPUSH
2646: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2650: LD_VAR 0 2
2654: PPUSH
2655: LD_INT 147
2657: PPUSH
2658: LD_INT 45
2660: PPUSH
2661: CALL_OW 178
// AddComCrawl ( i ) ;
2665: LD_VAR 0 2
2669: PPUSH
2670: CALL_OW 197
// end ;
2674: GO 2635
2676: POP
2677: POP
// repeat wait ( 0 0$1 ) ;
2678: LD_INT 35
2680: PPUSH
2681: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2685: LD_EXP 48
2689: PPUSH
2690: LD_INT 110
2692: PPUSH
2693: LD_INT 10
2695: PPUSH
2696: CALL_OW 307
2700: PUSH
2701: LD_EXP 48
2705: PPUSH
2706: CALL_OW 305
2710: NOT
2711: OR
2712: IFFALSE 2678
// ComStop ( Burlak ) ;
2714: LD_EXP 45
2718: PPUSH
2719: CALL_OW 141
// AddComHold ( Burlak ) ;
2723: LD_EXP 45
2727: PPUSH
2728: CALL_OW 200
// end ; end_of_file
2732: LD_VAR 0 1
2736: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2737: LD_INT 0
2739: PPUSH
2740: PPUSH
2741: PPUSH
2742: PPUSH
// uc_side := 3 ;
2743: LD_ADDR_OWVAR 20
2747: PUSH
2748: LD_INT 3
2750: ST_TO_ADDR
// uc_nation := 3 ;
2751: LD_ADDR_OWVAR 21
2755: PUSH
2756: LD_INT 3
2758: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2759: LD_ADDR_EXP 49
2763: PUSH
2764: LD_INT 47
2766: PPUSH
2767: LD_INT 4
2769: PPUSH
2770: LD_STRING 
2772: PPUSH
2773: LD_INT 7
2775: PUSH
2776: LD_INT 8
2778: PUSH
2779: LD_INT 9
2781: PUSH
2782: EMPTY
2783: LIST
2784: LIST
2785: LIST
2786: PUSH
2787: LD_OWVAR 67
2791: ARRAY
2792: PPUSH
2793: LD_INT 10000
2795: PUSH
2796: LD_INT 3000
2798: PUSH
2799: LD_INT 300
2801: PUSH
2802: EMPTY
2803: LIST
2804: LIST
2805: LIST
2806: PPUSH
2807: LD_INT 9
2809: PUSH
2810: LD_INT 5
2812: PUSH
2813: LD_INT 6
2815: PUSH
2816: LD_INT 6
2818: PUSH
2819: EMPTY
2820: LIST
2821: LIST
2822: LIST
2823: LIST
2824: PPUSH
2825: CALL 24653 0 6
2829: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2830: LD_ADDR_EXP 58
2834: PUSH
2835: LD_EXP 58
2839: PPUSH
2840: LD_INT 2
2842: PPUSH
2843: LD_EXP 49
2847: PPUSH
2848: CALL_OW 1
2852: ST_TO_ADDR
// tmp := [ ] ;
2853: LD_ADDR_VAR 0 4
2857: PUSH
2858: EMPTY
2859: ST_TO_ADDR
// for i = 1 to 4 do
2860: LD_ADDR_VAR 0 2
2864: PUSH
2865: DOUBLE
2866: LD_INT 1
2868: DEC
2869: ST_TO_ADDR
2870: LD_INT 4
2872: PUSH
2873: FOR_TO
2874: IFFALSE 2967
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2876: LD_INT 22
2878: PPUSH
2879: LD_INT 3
2881: PPUSH
2882: LD_INT 3
2884: PPUSH
2885: LD_INT 43
2887: PUSH
2888: LD_INT 45
2890: PUSH
2891: LD_INT 45
2893: PUSH
2894: LD_INT 44
2896: PUSH
2897: EMPTY
2898: LIST
2899: LIST
2900: LIST
2901: LIST
2902: PUSH
2903: LD_VAR 0 2
2907: PUSH
2908: LD_INT 4
2910: MOD
2911: PUSH
2912: LD_INT 1
2914: PLUS
2915: ARRAY
2916: PPUSH
2917: LD_INT 100
2919: PPUSH
2920: CALL 21244 0 5
// veh := CreateVehicle ;
2924: LD_ADDR_VAR 0 3
2928: PUSH
2929: CALL_OW 45
2933: ST_TO_ADDR
// tmp := tmp ^ veh ;
2934: LD_ADDR_VAR 0 4
2938: PUSH
2939: LD_VAR 0 4
2943: PUSH
2944: LD_VAR 0 3
2948: ADD
2949: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2950: LD_VAR 0 3
2954: PPUSH
2955: LD_INT 2
2957: PPUSH
2958: LD_INT 0
2960: PPUSH
2961: CALL_OW 49
// end ;
2965: GO 2873
2967: POP
2968: POP
// russian_guard := tmp ;
2969: LD_ADDR_EXP 50
2973: PUSH
2974: LD_VAR 0 4
2978: ST_TO_ADDR
// end ;
2979: LD_VAR 0 1
2983: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2984: LD_INT 47
2986: PPUSH
2987: CALL_OW 302
2991: PUSH
2992: LD_EXP 6
2996: AND
2997: IFFALSE 3599
2999: GO 3001
3001: DISABLE
3002: LD_INT 0
3004: PPUSH
3005: PPUSH
3006: PPUSH
3007: PPUSH
3008: PPUSH
3009: PPUSH
// begin enable ;
3010: ENABLE
// base := 2 ;
3011: LD_ADDR_VAR 0 2
3015: PUSH
3016: LD_INT 2
3018: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3019: LD_ADDR_VAR 0 4
3023: PUSH
3024: LD_INT 0
3026: PUSH
3027: LD_INT 0
3029: PUSH
3030: LD_INT 0
3032: PUSH
3033: LD_INT 0
3035: PUSH
3036: LD_INT 0
3038: PUSH
3039: LD_INT 0
3041: PUSH
3042: LD_INT 0
3044: PUSH
3045: LD_INT 0
3047: PUSH
3048: LD_INT 1
3050: PUSH
3051: LD_INT 0
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: LIST
3058: LIST
3059: LIST
3060: LIST
3061: LIST
3062: LIST
3063: LIST
3064: LIST
3065: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3066: LD_ADDR_VAR 0 3
3070: PUSH
3071: LD_INT 22
3073: PUSH
3074: LD_INT 1
3076: PUSH
3077: LD_INT 3
3079: PUSH
3080: LD_INT 45
3082: PUSH
3083: EMPTY
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: PUSH
3089: LD_INT 21
3091: PUSH
3092: LD_INT 1
3094: PUSH
3095: LD_INT 3
3097: PUSH
3098: LD_INT 45
3100: PUSH
3101: EMPTY
3102: LIST
3103: LIST
3104: LIST
3105: LIST
3106: PUSH
3107: LD_INT 22
3109: PUSH
3110: LD_INT 1
3112: PUSH
3113: LD_INT 3
3115: PUSH
3116: LD_INT 45
3118: PUSH
3119: EMPTY
3120: LIST
3121: LIST
3122: LIST
3123: LIST
3124: PUSH
3125: LD_INT 23
3127: PUSH
3128: LD_INT 1
3130: PUSH
3131: LD_INT 3
3133: PUSH
3134: LD_INT 46
3136: PUSH
3137: EMPTY
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3149: LD_ADDR_VAR 0 1
3153: PUSH
3154: DOUBLE
3155: LD_INT 1
3157: DEC
3158: ST_TO_ADDR
3159: LD_OWVAR 67
3163: PUSH
3164: LD_OWVAR 1
3168: PUSH
3169: LD_INT 21000
3171: DIV
3172: PLUS
3173: PUSH
3174: FOR_TO
3175: IFFALSE 3263
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3177: LD_ADDR_VAR 0 3
3181: PUSH
3182: LD_VAR 0 3
3186: PPUSH
3187: LD_VAR 0 3
3191: PUSH
3192: LD_INT 1
3194: PLUS
3195: PPUSH
3196: LD_INT 23
3198: PUSH
3199: LD_INT 24
3201: PUSH
3202: EMPTY
3203: LIST
3204: LIST
3205: PUSH
3206: LD_INT 1
3208: PPUSH
3209: LD_INT 2
3211: PPUSH
3212: CALL_OW 12
3216: ARRAY
3217: PUSH
3218: LD_INT 1
3220: PUSH
3221: LD_INT 3
3223: PUSH
3224: LD_INT 46
3226: PUSH
3227: LD_INT 47
3229: PUSH
3230: LD_INT 45
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: LIST
3237: PUSH
3238: LD_INT 1
3240: PPUSH
3241: LD_INT 3
3243: PPUSH
3244: CALL_OW 12
3248: ARRAY
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: LIST
3254: LIST
3255: PPUSH
3256: CALL_OW 2
3260: ST_TO_ADDR
3261: GO 3174
3263: POP
3264: POP
// MC_InsertProduceList ( base , tmp ) ;
3265: LD_VAR 0 2
3269: PPUSH
3270: LD_VAR 0 3
3274: PPUSH
3275: CALL 81090 0 2
// repeat wait ( 0 0$1 ) ;
3279: LD_INT 35
3281: PPUSH
3282: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3286: LD_EXP 77
3290: PUSH
3291: LD_VAR 0 2
3295: ARRAY
3296: PUSH
3297: LD_INT 6
3299: GREATER
3300: IFFALSE 3279
// wait ( 0 0$20 ) ;
3302: LD_INT 700
3304: PPUSH
3305: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3309: LD_ADDR_VAR 0 5
3313: PUSH
3314: LD_INT 71
3316: PUSH
3317: LD_INT 19
3319: PUSH
3320: EMPTY
3321: LIST
3322: LIST
3323: PUSH
3324: LD_INT 91
3326: PUSH
3327: LD_INT 67
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PUSH
3334: LD_INT 52
3336: PUSH
3337: LD_INT 44
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: PUSH
3344: LD_INT 68
3346: PUSH
3347: LD_INT 48
3349: PUSH
3350: EMPTY
3351: LIST
3352: LIST
3353: PUSH
3354: EMPTY
3355: LIST
3356: LIST
3357: LIST
3358: LIST
3359: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3360: LD_ADDR_VAR 0 6
3364: PUSH
3365: LD_EXP 77
3369: PUSH
3370: LD_VAR 0 2
3374: ARRAY
3375: PUSH
3376: LD_EXP 77
3380: PUSH
3381: LD_VAR 0 2
3385: ARRAY
3386: PPUSH
3387: LD_INT 2
3389: PUSH
3390: LD_INT 34
3392: PUSH
3393: LD_INT 51
3395: PUSH
3396: EMPTY
3397: LIST
3398: LIST
3399: PUSH
3400: LD_INT 34
3402: PUSH
3403: LD_INT 52
3405: PUSH
3406: EMPTY
3407: LIST
3408: LIST
3409: PUSH
3410: EMPTY
3411: LIST
3412: LIST
3413: LIST
3414: PPUSH
3415: CALL_OW 72
3419: DIFF
3420: ST_TO_ADDR
// if not attackers then
3421: LD_VAR 0 6
3425: NOT
3426: IFFALSE 3430
// exit ;
3428: GO 3599
// ru_attackers := attackers ;
3430: LD_ADDR_EXP 51
3434: PUSH
3435: LD_VAR 0 6
3439: ST_TO_ADDR
// for i = 1 to attackers do
3440: LD_ADDR_VAR 0 1
3444: PUSH
3445: DOUBLE
3446: LD_INT 1
3448: DEC
3449: ST_TO_ADDR
3450: LD_VAR 0 6
3454: PUSH
3455: FOR_TO
3456: IFFALSE 3533
// begin case i mod 3 of 0 :
3458: LD_VAR 0 1
3462: PUSH
3463: LD_INT 3
3465: MOD
3466: PUSH
3467: LD_INT 0
3469: DOUBLE
3470: EQUAL
3471: IFTRUE 3475
3473: GO 3478
3475: POP
// ; 1 :
3476: GO 3531
3478: LD_INT 1
3480: DOUBLE
3481: EQUAL
3482: IFTRUE 3486
3484: GO 3504
3486: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3487: LD_VAR 0 1
3491: PPUSH
3492: LD_INT 32
3494: PPUSH
3495: LD_INT 49
3497: PPUSH
3498: CALL_OW 114
3502: GO 3531
3504: LD_INT 2
3506: DOUBLE
3507: EQUAL
3508: IFTRUE 3512
3510: GO 3530
3512: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3513: LD_VAR 0 1
3517: PPUSH
3518: LD_INT 117
3520: PPUSH
3521: LD_INT 107
3523: PPUSH
3524: CALL_OW 114
3528: GO 3531
3530: POP
// end ;
3531: GO 3455
3533: POP
3534: POP
// repeat wait ( 0 0$1 ) ;
3535: LD_INT 35
3537: PPUSH
3538: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3542: LD_VAR 0 6
3546: PPUSH
3547: LD_INT 60
3549: PUSH
3550: EMPTY
3551: LIST
3552: PPUSH
3553: CALL_OW 72
3557: NOT
3558: IFFALSE 3535
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3560: LD_VAR 0 2
3564: PPUSH
3565: LD_VAR 0 6
3569: PPUSH
3570: LD_VAR 0 5
3574: PPUSH
3575: LD_VAR 0 4
3579: PPUSH
3580: CALL 81275 0 4
// if not first_attack then
3584: LD_EXP 7
3588: NOT
3589: IFFALSE 3599
// first_attack := true ;
3591: LD_ADDR_EXP 7
3595: PUSH
3596: LD_INT 1
3598: ST_TO_ADDR
// end ; end_of_file
3599: PPOPN 6
3601: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3602: LD_INT 0
3604: PPUSH
3605: PPUSH
3606: PPUSH
3607: PPUSH
3608: PPUSH
3609: PPUSH
3610: PPUSH
// uc_side := 2 ;
3611: LD_ADDR_OWVAR 20
3615: PUSH
3616: LD_INT 2
3618: ST_TO_ADDR
// uc_nation := 2 ;
3619: LD_ADDR_OWVAR 21
3623: PUSH
3624: LD_INT 2
3626: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3627: LD_ADDR_EXP 54
3631: PUSH
3632: LD_STRING Abdul
3634: PPUSH
3635: CALL_OW 25
3639: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3640: LD_EXP 54
3644: PPUSH
3645: LD_INT 11
3647: PPUSH
3648: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3652: LD_EXP 54
3656: PPUSH
3657: LD_INT 1
3659: PPUSH
3660: CALL_OW 52
// vc_chassis := 31 ;
3664: LD_ADDR_OWVAR 37
3668: PUSH
3669: LD_INT 31
3671: ST_TO_ADDR
// vc_control := control_rider ;
3672: LD_ADDR_OWVAR 38
3676: PUSH
3677: LD_INT 4
3679: ST_TO_ADDR
// mastodont := CreateVehicle ;
3680: LD_ADDR_EXP 55
3684: PUSH
3685: CALL_OW 45
3689: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3690: LD_EXP 55
3694: PPUSH
3695: LD_INT 153
3697: PPUSH
3698: LD_INT 71
3700: PPUSH
3701: LD_INT 0
3703: PPUSH
3704: CALL_OW 48
// InitVc ;
3708: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3712: LD_ADDR_EXP 52
3716: PUSH
3717: LD_INT 1
3719: PPUSH
3720: LD_INT 3
3722: PPUSH
3723: LD_STRING 
3725: PPUSH
3726: LD_INT 7
3728: PUSH
3729: LD_INT 8
3731: PUSH
3732: LD_INT 9
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: LIST
3739: PUSH
3740: LD_OWVAR 67
3744: ARRAY
3745: PPUSH
3746: LD_INT 5000
3748: PUSH
3749: LD_INT 1000
3751: PUSH
3752: LD_INT 300
3754: PUSH
3755: EMPTY
3756: LIST
3757: LIST
3758: LIST
3759: PPUSH
3760: LD_INT 22
3762: PUSH
3763: LD_INT 5
3765: PUSH
3766: LD_INT 6
3768: PUSH
3769: LD_INT 9
3771: PUSH
3772: EMPTY
3773: LIST
3774: LIST
3775: LIST
3776: LIST
3777: PPUSH
3778: CALL 24653 0 6
3782: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3783: LD_ADDR_EXP 58
3787: PUSH
3788: LD_EXP 58
3792: PPUSH
3793: LD_INT 1
3795: PPUSH
3796: LD_EXP 52
3800: PPUSH
3801: CALL_OW 1
3805: ST_TO_ADDR
// tmp := [ ] ;
3806: LD_ADDR_VAR 0 4
3810: PUSH
3811: EMPTY
3812: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3813: LD_ADDR_OWVAR 37
3817: PUSH
3818: LD_INT 14
3820: ST_TO_ADDR
// vc_engine := engine_siberite ;
3821: LD_ADDR_OWVAR 39
3825: PUSH
3826: LD_INT 3
3828: ST_TO_ADDR
// vc_control := control_manual ;
3829: LD_ADDR_OWVAR 38
3833: PUSH
3834: LD_INT 1
3836: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3837: LD_ADDR_OWVAR 40
3841: PUSH
3842: LD_INT 31
3844: ST_TO_ADDR
// for i = 1 to 3 do
3845: LD_ADDR_VAR 0 2
3849: PUSH
3850: DOUBLE
3851: LD_INT 1
3853: DEC
3854: ST_TO_ADDR
3855: LD_INT 3
3857: PUSH
3858: FOR_TO
3859: IFFALSE 4103
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3861: LD_ADDR_VAR 0 5
3865: PUSH
3866: LD_INT 153
3868: PUSH
3869: LD_INT 71
3871: PUSH
3872: EMPTY
3873: LIST
3874: LIST
3875: PUSH
3876: LD_INT 155
3878: PUSH
3879: LD_INT 81
3881: PUSH
3882: EMPTY
3883: LIST
3884: LIST
3885: PUSH
3886: EMPTY
3887: LIST
3888: LIST
3889: PUSH
3890: LD_VAR 0 2
3894: PUSH
3895: LD_INT 2
3897: MOD
3898: PUSH
3899: LD_INT 1
3901: PLUS
3902: ARRAY
3903: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3904: LD_INT 0
3906: PPUSH
3907: LD_INT 3
3909: PPUSH
3910: LD_INT 7
3912: PUSH
3913: LD_INT 8
3915: PUSH
3916: LD_INT 9
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: LIST
3923: PUSH
3924: LD_OWVAR 67
3928: ARRAY
3929: PPUSH
3930: CALL_OW 380
// un := CreateVehicle ;
3934: LD_ADDR_VAR 0 6
3938: PUSH
3939: CALL_OW 45
3943: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3944: LD_VAR 0 6
3948: PPUSH
3949: LD_INT 0
3951: PPUSH
3952: LD_INT 5
3954: PPUSH
3955: CALL_OW 12
3959: PPUSH
3960: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3964: LD_VAR 0 6
3968: PPUSH
3969: LD_VAR 0 5
3973: PUSH
3974: LD_INT 1
3976: ARRAY
3977: PPUSH
3978: LD_VAR 0 5
3982: PUSH
3983: LD_INT 2
3985: ARRAY
3986: PPUSH
3987: LD_INT 6
3989: PPUSH
3990: LD_INT 0
3992: PPUSH
3993: CALL_OW 50
// un2 := CreateHuman ;
3997: LD_ADDR_VAR 0 7
4001: PUSH
4002: CALL_OW 44
4006: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4007: LD_VAR 0 7
4011: PPUSH
4012: LD_VAR 0 6
4016: PPUSH
4017: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4021: LD_ADDR_EXP 58
4025: PUSH
4026: LD_EXP 58
4030: PPUSH
4031: LD_INT 1
4033: PUSH
4034: LD_EXP 58
4038: PUSH
4039: LD_INT 1
4041: ARRAY
4042: PUSH
4043: LD_INT 1
4045: PLUS
4046: PUSH
4047: EMPTY
4048: LIST
4049: LIST
4050: PPUSH
4051: LD_VAR 0 6
4055: PPUSH
4056: CALL 21366 0 3
4060: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4061: LD_ADDR_EXP 58
4065: PUSH
4066: LD_EXP 58
4070: PPUSH
4071: LD_INT 1
4073: PUSH
4074: LD_EXP 58
4078: PUSH
4079: LD_INT 1
4081: ARRAY
4082: PUSH
4083: LD_INT 1
4085: PLUS
4086: PUSH
4087: EMPTY
4088: LIST
4089: LIST
4090: PPUSH
4091: LD_VAR 0 7
4095: PPUSH
4096: CALL 21366 0 3
4100: ST_TO_ADDR
// end ;
4101: GO 3858
4103: POP
4104: POP
// for i = 1 to 5 do
4105: LD_ADDR_VAR 0 2
4109: PUSH
4110: DOUBLE
4111: LD_INT 1
4113: DEC
4114: ST_TO_ADDR
4115: LD_INT 5
4117: PUSH
4118: FOR_TO
4119: IFFALSE 4212
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4121: LD_INT 14
4123: PPUSH
4124: LD_INT 3
4126: PPUSH
4127: LD_INT 1
4129: PPUSH
4130: LD_INT 25
4132: PUSH
4133: LD_INT 28
4135: PUSH
4136: LD_INT 28
4138: PUSH
4139: LD_INT 26
4141: PUSH
4142: EMPTY
4143: LIST
4144: LIST
4145: LIST
4146: LIST
4147: PUSH
4148: LD_VAR 0 2
4152: PUSH
4153: LD_INT 4
4155: MOD
4156: PUSH
4157: LD_INT 1
4159: PLUS
4160: ARRAY
4161: PPUSH
4162: LD_INT 100
4164: PPUSH
4165: CALL 21244 0 5
// veh := CreateVehicle ;
4169: LD_ADDR_VAR 0 3
4173: PUSH
4174: CALL_OW 45
4178: ST_TO_ADDR
// tmp := tmp ^ veh ;
4179: LD_ADDR_VAR 0 4
4183: PUSH
4184: LD_VAR 0 4
4188: PUSH
4189: LD_VAR 0 3
4193: ADD
4194: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4195: LD_VAR 0 3
4199: PPUSH
4200: LD_INT 1
4202: PPUSH
4203: LD_INT 0
4205: PPUSH
4206: CALL_OW 49
// end ;
4210: GO 4118
4212: POP
4213: POP
// arabian_guard := tmp ;
4214: LD_ADDR_EXP 53
4218: PUSH
4219: LD_VAR 0 4
4223: ST_TO_ADDR
// end ;
4224: LD_VAR 0 1
4228: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4229: LD_INT 22
4231: PUSH
4232: LD_INT 7
4234: PUSH
4235: EMPTY
4236: LIST
4237: LIST
4238: PUSH
4239: LD_INT 91
4241: PUSH
4242: LD_INT 1
4244: PUSH
4245: LD_INT 12
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: LIST
4252: PUSH
4253: EMPTY
4254: LIST
4255: LIST
4256: PPUSH
4257: CALL_OW 69
4261: PUSH
4262: LD_EXP 55
4266: PPUSH
4267: CALL_OW 256
4271: PUSH
4272: LD_INT 990
4274: LESS
4275: OR
4276: PUSH
4277: LD_EXP 54
4281: PPUSH
4282: CALL_OW 256
4286: PUSH
4287: LD_INT 990
4289: LESS
4290: OR
4291: IFFALSE 4434
4293: GO 4295
4295: DISABLE
// begin if IsInUnit ( Abdul ) then
4296: LD_EXP 54
4300: PPUSH
4301: CALL_OW 310
4305: IFFALSE 4316
// ComExitBuilding ( Abdul ) ;
4307: LD_EXP 54
4311: PPUSH
4312: CALL_OW 122
// if Mastodont then
4316: LD_EXP 55
4320: IFFALSE 4337
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4322: LD_EXP 55
4326: PPUSH
4327: LD_INT 205
4329: PPUSH
4330: LD_INT 132
4332: PPUSH
4333: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4337: LD_EXP 54
4341: PPUSH
4342: LD_INT 205
4344: PPUSH
4345: LD_INT 132
4347: PPUSH
4348: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4352: LD_INT 35
4354: PPUSH
4355: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4359: LD_EXP 54
4363: PPUSH
4364: LD_INT 21
4366: PPUSH
4367: CALL_OW 308
4371: IFFALSE 4352
// RemoveUnit ( Abdul ) ;
4373: LD_EXP 54
4377: PPUSH
4378: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4382: LD_INT 35
4384: PPUSH
4385: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4389: LD_EXP 55
4393: PPUSH
4394: LD_INT 21
4396: PPUSH
4397: CALL_OW 308
4401: PUSH
4402: LD_EXP 55
4406: PPUSH
4407: CALL_OW 301
4411: OR
4412: IFFALSE 4382
// if IsOk ( Mastodont ) then
4414: LD_EXP 55
4418: PPUSH
4419: CALL_OW 302
4423: IFFALSE 4434
// RemoveUnit ( Mastodont ) ;
4425: LD_EXP 55
4429: PPUSH
4430: CALL_OW 64
// end ;
4434: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4435: LD_EXP 54
4439: PPUSH
4440: CALL_OW 301
4444: PUSH
4445: LD_INT 22
4447: PUSH
4448: LD_INT 2
4450: PUSH
4451: EMPTY
4452: LIST
4453: LIST
4454: PUSH
4455: LD_INT 2
4457: PUSH
4458: LD_INT 25
4460: PUSH
4461: LD_INT 1
4463: PUSH
4464: EMPTY
4465: LIST
4466: LIST
4467: PUSH
4468: LD_INT 25
4470: PUSH
4471: LD_INT 2
4473: PUSH
4474: EMPTY
4475: LIST
4476: LIST
4477: PUSH
4478: LD_INT 25
4480: PUSH
4481: LD_INT 3
4483: PUSH
4484: EMPTY
4485: LIST
4486: LIST
4487: PUSH
4488: LD_INT 25
4490: PUSH
4491: LD_INT 4
4493: PUSH
4494: EMPTY
4495: LIST
4496: LIST
4497: PUSH
4498: LD_INT 25
4500: PUSH
4501: LD_INT 8
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: PUSH
4508: EMPTY
4509: LIST
4510: LIST
4511: LIST
4512: LIST
4513: LIST
4514: LIST
4515: PUSH
4516: EMPTY
4517: LIST
4518: LIST
4519: PPUSH
4520: CALL_OW 69
4524: PUSH
4525: LD_INT 16
4527: PUSH
4528: LD_INT 19
4530: PUSH
4531: LD_INT 22
4533: PUSH
4534: EMPTY
4535: LIST
4536: LIST
4537: LIST
4538: PUSH
4539: LD_OWVAR 67
4543: ARRAY
4544: LESS
4545: OR
4546: IFFALSE 5219
4548: GO 4550
4550: DISABLE
4551: LD_INT 0
4553: PPUSH
4554: PPUSH
4555: PPUSH
4556: PPUSH
4557: PPUSH
4558: PPUSH
// begin MC_Kill ( 1 ) ;
4559: LD_INT 1
4561: PPUSH
4562: CALL 57526 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4566: LD_ADDR_VAR 0 2
4570: PUSH
4571: LD_INT 22
4573: PUSH
4574: LD_INT 2
4576: PUSH
4577: EMPTY
4578: LIST
4579: LIST
4580: PUSH
4581: LD_INT 2
4583: PUSH
4584: LD_INT 25
4586: PUSH
4587: LD_INT 1
4589: PUSH
4590: EMPTY
4591: LIST
4592: LIST
4593: PUSH
4594: LD_INT 25
4596: PUSH
4597: LD_INT 2
4599: PUSH
4600: EMPTY
4601: LIST
4602: LIST
4603: PUSH
4604: LD_INT 25
4606: PUSH
4607: LD_INT 3
4609: PUSH
4610: EMPTY
4611: LIST
4612: LIST
4613: PUSH
4614: LD_INT 25
4616: PUSH
4617: LD_INT 4
4619: PUSH
4620: EMPTY
4621: LIST
4622: LIST
4623: PUSH
4624: LD_INT 25
4626: PUSH
4627: LD_INT 8
4629: PUSH
4630: EMPTY
4631: LIST
4632: LIST
4633: PUSH
4634: EMPTY
4635: LIST
4636: LIST
4637: LIST
4638: LIST
4639: LIST
4640: LIST
4641: PUSH
4642: EMPTY
4643: LIST
4644: LIST
4645: PPUSH
4646: CALL_OW 69
4650: ST_TO_ADDR
// for i in tmp do
4651: LD_ADDR_VAR 0 5
4655: PUSH
4656: LD_VAR 0 2
4660: PUSH
4661: FOR_IN
4662: IFFALSE 4678
// SetTag ( i , 10 ) ;
4664: LD_VAR 0 5
4668: PPUSH
4669: LD_INT 10
4671: PPUSH
4672: CALL_OW 109
4676: GO 4661
4678: POP
4679: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4680: LD_ADDR_VAR 0 3
4684: PUSH
4685: LD_INT 22
4687: PUSH
4688: LD_INT 2
4690: PUSH
4691: EMPTY
4692: LIST
4693: LIST
4694: PUSH
4695: LD_INT 21
4697: PUSH
4698: LD_INT 1
4700: PUSH
4701: EMPTY
4702: LIST
4703: LIST
4704: PUSH
4705: EMPTY
4706: LIST
4707: LIST
4708: PPUSH
4709: CALL_OW 69
4713: PUSH
4714: LD_VAR 0 2
4718: DIFF
4719: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4720: LD_ADDR_VAR 0 1
4724: PUSH
4725: LD_INT 22
4727: PUSH
4728: LD_INT 2
4730: PUSH
4731: EMPTY
4732: LIST
4733: LIST
4734: PUSH
4735: LD_INT 21
4737: PUSH
4738: LD_INT 2
4740: PUSH
4741: EMPTY
4742: LIST
4743: LIST
4744: PUSH
4745: LD_INT 24
4747: PUSH
4748: LD_INT 300
4750: PUSH
4751: EMPTY
4752: LIST
4753: LIST
4754: PUSH
4755: EMPTY
4756: LIST
4757: LIST
4758: LIST
4759: PPUSH
4760: CALL_OW 69
4764: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4765: LD_ADDR_VAR 0 4
4769: PUSH
4770: LD_VAR 0 1
4774: PPUSH
4775: LD_INT 33
4777: PUSH
4778: LD_INT 1
4780: PUSH
4781: EMPTY
4782: LIST
4783: LIST
4784: PUSH
4785: LD_INT 58
4787: PUSH
4788: EMPTY
4789: LIST
4790: PUSH
4791: EMPTY
4792: LIST
4793: LIST
4794: PPUSH
4795: CALL_OW 72
4799: ST_TO_ADDR
// for i in tmp do
4800: LD_ADDR_VAR 0 5
4804: PUSH
4805: LD_VAR 0 2
4809: PUSH
4810: FOR_IN
4811: IFFALSE 4995
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4813: LD_VAR 0 5
4817: PUSH
4818: LD_INT 55
4820: PUSH
4821: EMPTY
4822: LIST
4823: PPUSH
4824: CALL_OW 69
4828: IN
4829: IFFALSE 4848
// begin AddComMoveXY ( i , 209 , 132 ) ;
4831: LD_VAR 0 5
4835: PPUSH
4836: LD_INT 209
4838: PPUSH
4839: LD_INT 132
4841: PPUSH
4842: CALL_OW 171
// continue ;
4846: GO 4810
// end ; if IsInUnit ( i ) then
4848: LD_VAR 0 5
4852: PPUSH
4853: CALL_OW 310
4857: IFFALSE 4875
// begin ComExitBuilding ( i ) ;
4859: LD_VAR 0 5
4863: PPUSH
4864: CALL_OW 122
// wait ( 3 ) ;
4868: LD_INT 3
4870: PPUSH
4871: CALL_OW 67
// end ; if tmp_empty then
4875: LD_VAR 0 4
4879: IFFALSE 4978
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4881: LD_VAR 0 5
4885: PPUSH
4886: LD_VAR 0 4
4890: PPUSH
4891: LD_VAR 0 5
4895: PPUSH
4896: CALL_OW 74
4900: PPUSH
4901: CALL_OW 296
4905: PUSH
4906: LD_INT 25
4908: LESS
4909: IFFALSE 4978
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4911: LD_ADDR_VAR 0 6
4915: PUSH
4916: LD_VAR 0 4
4920: PPUSH
4921: LD_VAR 0 5
4925: PPUSH
4926: CALL_OW 74
4930: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4931: LD_VAR 0 5
4935: PPUSH
4936: LD_VAR 0 6
4940: PPUSH
4941: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4945: LD_VAR 0 5
4949: PPUSH
4950: LD_INT 209
4952: PPUSH
4953: LD_INT 132
4955: PPUSH
4956: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4960: LD_ADDR_VAR 0 4
4964: PUSH
4965: LD_VAR 0 4
4969: PUSH
4970: LD_VAR 0 6
4974: DIFF
4975: ST_TO_ADDR
// continue ;
4976: GO 4810
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4978: LD_VAR 0 5
4982: PPUSH
4983: LD_INT 201
4985: PPUSH
4986: LD_INT 132
4988: PPUSH
4989: CALL_OW 171
// end ;
4993: GO 4810
4995: POP
4996: POP
// for i in tmp_ape do
4997: LD_ADDR_VAR 0 5
5001: PUSH
5002: LD_VAR 0 3
5006: PUSH
5007: FOR_IN
5008: IFFALSE 5047
// begin if IsInUnit ( i ) then
5010: LD_VAR 0 5
5014: PPUSH
5015: CALL_OW 310
5019: IFFALSE 5030
// ComExitBuilding ( i ) ;
5021: LD_VAR 0 5
5025: PPUSH
5026: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5030: LD_VAR 0 5
5034: PPUSH
5035: LD_INT 201
5037: PPUSH
5038: LD_INT 132
5040: PPUSH
5041: CALL_OW 171
// end ;
5045: GO 5007
5047: POP
5048: POP
// repeat wait ( 0 0$1 ) ;
5049: LD_INT 35
5051: PPUSH
5052: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5056: LD_ADDR_VAR 0 5
5060: PUSH
5061: LD_VAR 0 2
5065: PUSH
5066: LD_VAR 0 3
5070: UNION
5071: PUSH
5072: LD_VAR 0 1
5076: UNION
5077: PUSH
5078: FOR_IN
5079: IFFALSE 5110
// if not HasTask ( i ) then
5081: LD_VAR 0 5
5085: PPUSH
5086: CALL_OW 314
5090: NOT
5091: IFFALSE 5108
// ComMoveXY ( i , 201 , 132 ) ;
5093: LD_VAR 0 5
5097: PPUSH
5098: LD_INT 201
5100: PPUSH
5101: LD_INT 132
5103: PPUSH
5104: CALL_OW 111
5108: GO 5078
5110: POP
5111: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5112: LD_INT 21
5114: PPUSH
5115: LD_INT 22
5117: PUSH
5118: LD_INT 2
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: PPUSH
5125: CALL_OW 70
5129: IFFALSE 5170
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5131: LD_ADDR_VAR 0 5
5135: PUSH
5136: LD_INT 21
5138: PPUSH
5139: LD_INT 22
5141: PUSH
5142: LD_INT 2
5144: PUSH
5145: EMPTY
5146: LIST
5147: LIST
5148: PPUSH
5149: CALL_OW 70
5153: PUSH
5154: FOR_IN
5155: IFFALSE 5168
// RemoveUnit ( i ) ;
5157: LD_VAR 0 5
5161: PPUSH
5162: CALL_OW 64
5166: GO 5154
5168: POP
5169: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5170: LD_INT 22
5172: PUSH
5173: LD_INT 2
5175: PUSH
5176: EMPTY
5177: LIST
5178: LIST
5179: PUSH
5180: LD_INT 2
5182: PUSH
5183: LD_INT 21
5185: PUSH
5186: LD_INT 1
5188: PUSH
5189: EMPTY
5190: LIST
5191: LIST
5192: PUSH
5193: LD_INT 21
5195: PUSH
5196: LD_INT 2
5198: PUSH
5199: EMPTY
5200: LIST
5201: LIST
5202: PUSH
5203: EMPTY
5204: LIST
5205: LIST
5206: LIST
5207: PUSH
5208: EMPTY
5209: LIST
5210: LIST
5211: PPUSH
5212: CALL_OW 69
5216: NOT
5217: IFFALSE 5049
// end ;
5219: PPOPN 6
5221: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5222: LD_EXP 9
5226: PUSH
5227: LD_INT 92
5229: PPUSH
5230: LD_INT 40
5232: PPUSH
5233: CALL_OW 428
5237: PPUSH
5238: CALL_OW 266
5242: PUSH
5243: LD_INT 30
5245: EQUAL
5246: AND
5247: IFFALSE 5443
5249: GO 5251
5251: DISABLE
5252: LD_INT 0
5254: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5255: LD_ADDR_VAR 0 1
5259: PUSH
5260: LD_EXP 58
5264: PUSH
5265: LD_INT 1
5267: ARRAY
5268: PPUSH
5269: LD_INT 25
5271: PUSH
5272: LD_INT 4
5274: PUSH
5275: EMPTY
5276: LIST
5277: LIST
5278: PPUSH
5279: CALL_OW 72
5283: ST_TO_ADDR
// if not sci then
5284: LD_VAR 0 1
5288: NOT
5289: IFFALSE 5293
// exit ;
5291: GO 5443
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5293: LD_ADDR_EXP 58
5297: PUSH
5298: LD_EXP 58
5302: PPUSH
5303: LD_INT 1
5305: PPUSH
5306: LD_EXP 58
5310: PUSH
5311: LD_INT 1
5313: ARRAY
5314: PUSH
5315: LD_VAR 0 1
5319: PUSH
5320: LD_INT 1
5322: ARRAY
5323: DIFF
5324: PPUSH
5325: CALL_OW 1
5329: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5330: LD_VAR 0 1
5334: PUSH
5335: LD_INT 1
5337: ARRAY
5338: PPUSH
5339: CALL_OW 310
5343: IFFALSE 5358
// ComExitBuilding ( sci [ 1 ] ) ;
5345: LD_VAR 0 1
5349: PUSH
5350: LD_INT 1
5352: ARRAY
5353: PPUSH
5354: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5358: LD_INT 2
5360: PPUSH
5361: LD_INT 105
5363: PPUSH
5364: LD_INT 14
5366: PPUSH
5367: LD_INT 20
5369: PPUSH
5370: CALL 22262 0 4
5374: PUSH
5375: LD_INT 4
5377: ARRAY
5378: PUSH
5379: LD_INT 10
5381: LESS
5382: IFFALSE 5405
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5384: LD_VAR 0 1
5388: PUSH
5389: LD_INT 1
5391: ARRAY
5392: PPUSH
5393: LD_INT 105
5395: PPUSH
5396: LD_INT 14
5398: PPUSH
5399: CALL_OW 171
5403: GO 5424
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5405: LD_VAR 0 1
5409: PUSH
5410: LD_INT 1
5412: ARRAY
5413: PPUSH
5414: LD_INT 118
5416: PPUSH
5417: LD_INT 77
5419: PPUSH
5420: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5424: LD_VAR 0 1
5428: PUSH
5429: LD_INT 1
5431: ARRAY
5432: PPUSH
5433: LD_INT 92
5435: PPUSH
5436: LD_INT 40
5438: PPUSH
5439: CALL_OW 218
// end ;
5443: PPOPN 1
5445: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5446: LD_INT 1
5448: PPUSH
5449: CALL_OW 302
5453: PUSH
5454: LD_EXP 9
5458: AND
5459: IFFALSE 5918
5461: GO 5463
5463: DISABLE
5464: LD_INT 0
5466: PPUSH
5467: PPUSH
5468: PPUSH
5469: PPUSH
5470: PPUSH
5471: PPUSH
// begin enable ;
5472: ENABLE
// base := 1 ;
5473: LD_ADDR_VAR 0 2
5477: PUSH
5478: LD_INT 1
5480: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5481: LD_ADDR_VAR 0 4
5485: PUSH
5486: LD_INT 0
5488: PUSH
5489: LD_INT 0
5491: PUSH
5492: LD_INT 0
5494: PUSH
5495: LD_INT 0
5497: PUSH
5498: LD_INT 0
5500: PUSH
5501: LD_INT 0
5503: PUSH
5504: LD_INT 0
5506: PUSH
5507: LD_INT 0
5509: PUSH
5510: LD_INT 1
5512: PUSH
5513: LD_INT 0
5515: PUSH
5516: EMPTY
5517: LIST
5518: LIST
5519: LIST
5520: LIST
5521: LIST
5522: LIST
5523: LIST
5524: LIST
5525: LIST
5526: LIST
5527: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5528: LD_ADDR_VAR 0 3
5532: PUSH
5533: LD_INT 14
5535: PUSH
5536: LD_INT 1
5538: PUSH
5539: LD_INT 2
5541: PUSH
5542: LD_INT 26
5544: PUSH
5545: EMPTY
5546: LIST
5547: LIST
5548: LIST
5549: LIST
5550: PUSH
5551: LD_INT 14
5553: PUSH
5554: LD_INT 1
5556: PUSH
5557: LD_INT 2
5559: PUSH
5560: LD_INT 28
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: LIST
5567: LIST
5568: PUSH
5569: LD_INT 13
5571: PUSH
5572: LD_INT 1
5574: PUSH
5575: LD_INT 2
5577: PUSH
5578: LD_INT 29
5580: PUSH
5581: EMPTY
5582: LIST
5583: LIST
5584: LIST
5585: LIST
5586: PUSH
5587: EMPTY
5588: LIST
5589: LIST
5590: LIST
5591: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5592: LD_ADDR_VAR 0 1
5596: PUSH
5597: DOUBLE
5598: LD_INT 1
5600: DEC
5601: ST_TO_ADDR
5602: LD_OWVAR 67
5606: PUSH
5607: LD_OWVAR 1
5611: PUSH
5612: LD_INT 21000
5614: DIV
5615: PLUS
5616: PUSH
5617: FOR_TO
5618: IFFALSE 5710
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5620: LD_ADDR_VAR 0 3
5624: PUSH
5625: LD_VAR 0 3
5629: PPUSH
5630: LD_VAR 0 3
5634: PUSH
5635: LD_INT 1
5637: PLUS
5638: PPUSH
5639: LD_INT 13
5641: PUSH
5642: LD_INT 14
5644: PUSH
5645: EMPTY
5646: LIST
5647: LIST
5648: PUSH
5649: LD_INT 1
5651: PPUSH
5652: LD_INT 2
5654: PPUSH
5655: CALL_OW 12
5659: ARRAY
5660: PUSH
5661: LD_INT 1
5663: PUSH
5664: LD_INT 2
5666: PUSH
5667: LD_INT 28
5669: PUSH
5670: LD_INT 29
5672: PUSH
5673: LD_INT 25
5675: PUSH
5676: LD_INT 26
5678: PUSH
5679: EMPTY
5680: LIST
5681: LIST
5682: LIST
5683: LIST
5684: PUSH
5685: LD_INT 1
5687: PPUSH
5688: LD_INT 4
5690: PPUSH
5691: CALL_OW 12
5695: ARRAY
5696: PUSH
5697: EMPTY
5698: LIST
5699: LIST
5700: LIST
5701: LIST
5702: PPUSH
5703: CALL_OW 2
5707: ST_TO_ADDR
5708: GO 5617
5710: POP
5711: POP
// MC_InsertProduceList ( base , tmp ) ;
5712: LD_VAR 0 2
5716: PPUSH
5717: LD_VAR 0 3
5721: PPUSH
5722: CALL 81090 0 2
// repeat wait ( 0 0$1 ) ;
5726: LD_INT 35
5728: PPUSH
5729: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5733: LD_EXP 77
5737: PUSH
5738: LD_VAR 0 2
5742: ARRAY
5743: PUSH
5744: LD_INT 6
5746: GREATER
5747: IFFALSE 5726
// wait ( 0 0$20 ) ;
5749: LD_INT 700
5751: PPUSH
5752: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5756: LD_ADDR_VAR 0 5
5760: PUSH
5761: LD_INT 124
5763: PUSH
5764: LD_INT 85
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: PUSH
5771: LD_INT 90
5773: PUSH
5774: LD_INT 61
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: PUSH
5781: LD_INT 69
5783: PUSH
5784: LD_INT 48
5786: PUSH
5787: EMPTY
5788: LIST
5789: LIST
5790: PUSH
5791: LD_INT 68
5793: PUSH
5794: LD_INT 48
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: LIST
5805: LIST
5806: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5807: LD_ADDR_VAR 0 6
5811: PUSH
5812: LD_EXP 77
5816: PUSH
5817: LD_VAR 0 2
5821: ARRAY
5822: PUSH
5823: LD_EXP 77
5827: PUSH
5828: LD_VAR 0 2
5832: ARRAY
5833: PPUSH
5834: LD_INT 34
5836: PUSH
5837: LD_INT 32
5839: PUSH
5840: EMPTY
5841: LIST
5842: LIST
5843: PPUSH
5844: CALL_OW 72
5848: DIFF
5849: ST_TO_ADDR
// if not attackers then
5850: LD_VAR 0 6
5854: NOT
5855: IFFALSE 5859
// exit ;
5857: GO 5918
// ar_attackers := attackers ;
5859: LD_ADDR_EXP 10
5863: PUSH
5864: LD_VAR 0 6
5868: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5869: LD_INT 35
5871: PPUSH
5872: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5876: LD_VAR 0 6
5880: PPUSH
5881: LD_INT 60
5883: PUSH
5884: EMPTY
5885: LIST
5886: PPUSH
5887: CALL_OW 72
5891: NOT
5892: IFFALSE 5869
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5894: LD_VAR 0 2
5898: PPUSH
5899: LD_VAR 0 6
5903: PPUSH
5904: LD_VAR 0 5
5908: PPUSH
5909: LD_VAR 0 4
5913: PPUSH
5914: CALL 81275 0 4
// end ;
5918: PPOPN 6
5920: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5921: LD_INT 1
5923: PPUSH
5924: CALL_OW 302
5928: PUSH
5929: LD_EXP 9
5933: AND
5934: PUSH
5935: LD_EXP 48
5939: PPUSH
5940: LD_INT 22
5942: PPUSH
5943: CALL_OW 308
5947: AND
5948: PUSH
5949: LD_INT 1
5951: PPUSH
5952: CALL 81438 0 1
5956: PUSH
5957: LD_INT 0
5959: EQUAL
5960: AND
5961: PUSH
5962: LD_EXP 10
5966: NOT
5967: AND
5968: IFFALSE 6432
5970: GO 5972
5972: DISABLE
5973: LD_INT 0
5975: PPUSH
5976: PPUSH
5977: PPUSH
5978: PPUSH
5979: PPUSH
5980: PPUSH
5981: PPUSH
// begin base := 1 ;
5982: LD_ADDR_VAR 0 2
5986: PUSH
5987: LD_INT 1
5989: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5990: LD_ADDR_VAR 0 4
5994: PUSH
5995: LD_INT 0
5997: PUSH
5998: LD_INT 0
6000: PUSH
6001: LD_INT 0
6003: PUSH
6004: LD_INT 0
6006: PUSH
6007: LD_INT 0
6009: PUSH
6010: LD_INT 0
6012: PUSH
6013: LD_INT 0
6015: PUSH
6016: LD_INT 0
6018: PUSH
6019: LD_INT 1
6021: PUSH
6022: LD_INT 0
6024: PUSH
6025: EMPTY
6026: LIST
6027: LIST
6028: LIST
6029: LIST
6030: LIST
6031: LIST
6032: LIST
6033: LIST
6034: LIST
6035: LIST
6036: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6037: LD_ADDR_VAR 0 3
6041: PUSH
6042: LD_INT 13
6044: PUSH
6045: LD_INT 1
6047: PUSH
6048: LD_INT 2
6050: PUSH
6051: LD_INT 28
6053: PUSH
6054: EMPTY
6055: LIST
6056: LIST
6057: LIST
6058: LIST
6059: PUSH
6060: LD_INT 13
6062: PUSH
6063: LD_INT 1
6065: PUSH
6066: LD_INT 2
6068: PUSH
6069: LD_INT 27
6071: PUSH
6072: EMPTY
6073: LIST
6074: LIST
6075: LIST
6076: LIST
6077: PUSH
6078: LD_INT 13
6080: PUSH
6081: LD_INT 1
6083: PUSH
6084: LD_INT 2
6086: PUSH
6087: LD_INT 25
6089: PUSH
6090: EMPTY
6091: LIST
6092: LIST
6093: LIST
6094: LIST
6095: PUSH
6096: LD_INT 11
6098: PUSH
6099: LD_INT 2
6101: PUSH
6102: LD_INT 2
6104: PUSH
6105: LD_INT 24
6107: PUSH
6108: EMPTY
6109: LIST
6110: LIST
6111: LIST
6112: LIST
6113: PUSH
6114: LD_INT 11
6116: PUSH
6117: LD_INT 2
6119: PUSH
6120: LD_INT 2
6122: PUSH
6123: LD_INT 24
6125: PUSH
6126: EMPTY
6127: LIST
6128: LIST
6129: LIST
6130: LIST
6131: PUSH
6132: EMPTY
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: LIST
6138: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6139: LD_VAR 0 2
6143: PPUSH
6144: LD_VAR 0 3
6148: PPUSH
6149: CALL 81090 0 2
// repeat wait ( 0 0$1 ) ;
6153: LD_INT 35
6155: PPUSH
6156: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6160: LD_EXP 77
6164: PUSH
6165: LD_VAR 0 2
6169: ARRAY
6170: PUSH
6171: LD_INT 6
6173: GREATEREQUAL
6174: IFFALSE 6153
// wait ( 0 0$20 ) ;
6176: LD_INT 700
6178: PPUSH
6179: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6183: LD_ADDR_VAR 0 5
6187: PUSH
6188: LD_INT 119
6190: PUSH
6191: LD_INT 9
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: PUSH
6198: EMPTY
6199: LIST
6200: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6201: LD_ADDR_VAR 0 6
6205: PUSH
6206: LD_EXP 77
6210: PUSH
6211: LD_VAR 0 2
6215: ARRAY
6216: PUSH
6217: LD_EXP 77
6221: PUSH
6222: LD_VAR 0 2
6226: ARRAY
6227: PPUSH
6228: LD_INT 34
6230: PUSH
6231: LD_INT 32
6233: PUSH
6234: EMPTY
6235: LIST
6236: LIST
6237: PPUSH
6238: CALL_OW 72
6242: DIFF
6243: ST_TO_ADDR
// if not attackers then
6244: LD_VAR 0 6
6248: NOT
6249: IFFALSE 6253
// exit ;
6251: GO 6432
// uc_side := 2 ;
6253: LD_ADDR_OWVAR 20
6257: PUSH
6258: LD_INT 2
6260: ST_TO_ADDR
// uc_nation := 2 ;
6261: LD_ADDR_OWVAR 21
6265: PUSH
6266: LD_INT 2
6268: ST_TO_ADDR
// InitHc ;
6269: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6273: LD_ADDR_VAR 0 1
6277: PUSH
6278: DOUBLE
6279: LD_INT 1
6281: DEC
6282: ST_TO_ADDR
6283: LD_INT 4
6285: PUSH
6286: LD_INT 5
6288: PUSH
6289: LD_INT 6
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: LIST
6296: PUSH
6297: LD_OWVAR 67
6301: ARRAY
6302: PUSH
6303: FOR_TO
6304: IFFALSE 6381
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6306: LD_INT 0
6308: PPUSH
6309: LD_INT 15
6311: PUSH
6312: LD_INT 17
6314: PUSH
6315: EMPTY
6316: LIST
6317: LIST
6318: PUSH
6319: LD_INT 1
6321: PPUSH
6322: LD_INT 2
6324: PPUSH
6325: CALL_OW 12
6329: ARRAY
6330: PPUSH
6331: LD_INT 8
6333: PPUSH
6334: CALL_OW 380
// un := CreateHuman ;
6338: LD_ADDR_VAR 0 7
6342: PUSH
6343: CALL_OW 44
6347: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6348: LD_VAR 0 7
6352: PPUSH
6353: LD_INT 23
6355: PPUSH
6356: LD_INT 0
6358: PPUSH
6359: CALL_OW 49
// attackers := attackers union un ;
6363: LD_ADDR_VAR 0 6
6367: PUSH
6368: LD_VAR 0 6
6372: PUSH
6373: LD_VAR 0 7
6377: UNION
6378: ST_TO_ADDR
// end ;
6379: GO 6303
6381: POP
6382: POP
// repeat wait ( 0 0$1 ) ;
6383: LD_INT 35
6385: PPUSH
6386: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6390: LD_VAR 0 6
6394: PPUSH
6395: LD_INT 60
6397: PUSH
6398: EMPTY
6399: LIST
6400: PPUSH
6401: CALL_OW 72
6405: NOT
6406: IFFALSE 6383
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6408: LD_VAR 0 2
6412: PPUSH
6413: LD_VAR 0 6
6417: PPUSH
6418: LD_VAR 0 5
6422: PPUSH
6423: LD_VAR 0 4
6427: PPUSH
6428: CALL 81275 0 4
// end ; end_of_file
6432: PPOPN 7
6434: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6435: LD_INT 0
6437: PPUSH
6438: PPUSH
6439: PPUSH
6440: PPUSH
// uc_side := 1 ;
6441: LD_ADDR_OWVAR 20
6445: PUSH
6446: LD_INT 1
6448: ST_TO_ADDR
// uc_nation := 1 ;
6449: LD_ADDR_OWVAR 21
6453: PUSH
6454: LD_INT 1
6456: ST_TO_ADDR
// InitHc ;
6457: CALL_OW 19
// InitVc ;
6461: CALL_OW 20
// tmp := [ ] ;
6465: LD_ADDR_VAR 0 3
6469: PUSH
6470: EMPTY
6471: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6472: LD_ADDR_VAR 0 2
6476: PUSH
6477: DOUBLE
6478: LD_INT 1
6480: DEC
6481: ST_TO_ADDR
6482: LD_INT 5
6484: PUSH
6485: LD_INT 6
6487: PUSH
6488: LD_INT 6
6490: PUSH
6491: EMPTY
6492: LIST
6493: LIST
6494: LIST
6495: PUSH
6496: LD_OWVAR 67
6500: ARRAY
6501: PUSH
6502: FOR_TO
6503: IFFALSE 6640
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6505: LD_INT 2
6507: PUSH
6508: LD_INT 4
6510: PUSH
6511: LD_INT 5
6513: PUSH
6514: EMPTY
6515: LIST
6516: LIST
6517: LIST
6518: PUSH
6519: LD_INT 1
6521: PPUSH
6522: LD_INT 3
6524: PPUSH
6525: CALL_OW 12
6529: ARRAY
6530: PPUSH
6531: LD_INT 1
6533: PUSH
6534: LD_INT 3
6536: PUSH
6537: EMPTY
6538: LIST
6539: LIST
6540: PUSH
6541: LD_INT 1
6543: PPUSH
6544: LD_INT 2
6546: PPUSH
6547: CALL_OW 12
6551: ARRAY
6552: PPUSH
6553: LD_INT 3
6555: PPUSH
6556: LD_INT 9
6558: PUSH
6559: LD_INT 7
6561: PUSH
6562: EMPTY
6563: LIST
6564: LIST
6565: PUSH
6566: LD_INT 1
6568: PPUSH
6569: LD_INT 2
6571: PPUSH
6572: CALL_OW 12
6576: ARRAY
6577: PPUSH
6578: LD_INT 78
6580: PPUSH
6581: CALL 21244 0 5
// veh := CreateVehicle ;
6585: LD_ADDR_VAR 0 4
6589: PUSH
6590: CALL_OW 45
6594: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6595: LD_VAR 0 4
6599: PPUSH
6600: LD_INT 2
6602: PPUSH
6603: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6607: LD_VAR 0 4
6611: PPUSH
6612: LD_INT 17
6614: PPUSH
6615: LD_INT 0
6617: PPUSH
6618: CALL_OW 49
// tmp := tmp ^ veh ;
6622: LD_ADDR_VAR 0 3
6626: PUSH
6627: LD_VAR 0 3
6631: PUSH
6632: LD_VAR 0 4
6636: ADD
6637: ST_TO_ADDR
// end ;
6638: GO 6502
6640: POP
6641: POP
// if not tmp then
6642: LD_VAR 0 3
6646: NOT
6647: IFFALSE 6651
// exit ;
6649: GO 6760
// if not first_powell_attack then
6651: LD_EXP 11
6655: NOT
6656: IFFALSE 6666
// first_powell_attack := true ;
6658: LD_ADDR_EXP 11
6662: PUSH
6663: LD_INT 1
6665: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6666: LD_INT 70
6668: PPUSH
6669: CALL_OW 67
// for i in tmp do
6673: LD_ADDR_VAR 0 2
6677: PUSH
6678: LD_VAR 0 3
6682: PUSH
6683: FOR_IN
6684: IFFALSE 6751
// if IsOk ( i ) then
6686: LD_VAR 0 2
6690: PPUSH
6691: CALL_OW 302
6695: IFFALSE 6733
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6697: LD_VAR 0 2
6701: PPUSH
6702: LD_INT 81
6704: PUSH
6705: LD_INT 1
6707: PUSH
6708: EMPTY
6709: LIST
6710: LIST
6711: PPUSH
6712: CALL_OW 69
6716: PPUSH
6717: LD_VAR 0 2
6721: PPUSH
6722: CALL_OW 74
6726: PPUSH
6727: CALL_OW 115
6731: GO 6749
// tmp := tmp diff i ;
6733: LD_ADDR_VAR 0 3
6737: PUSH
6738: LD_VAR 0 3
6742: PUSH
6743: LD_VAR 0 2
6747: DIFF
6748: ST_TO_ADDR
6749: GO 6683
6751: POP
6752: POP
// until not tmp ;
6753: LD_VAR 0 3
6757: NOT
6758: IFFALSE 6666
// end ; end_of_file
6760: LD_VAR 0 1
6764: RET
// export function Action ; var tmp , i , un ; begin
6765: LD_INT 0
6767: PPUSH
6768: PPUSH
6769: PPUSH
6770: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6771: LD_INT 68
6773: PPUSH
6774: LD_INT 39
6776: PPUSH
6777: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6781: LD_ADDR_VAR 0 2
6785: PUSH
6786: LD_INT 22
6788: PUSH
6789: LD_INT 7
6791: PUSH
6792: EMPTY
6793: LIST
6794: LIST
6795: PPUSH
6796: CALL_OW 69
6800: ST_TO_ADDR
// InGameOn ;
6801: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6805: LD_VAR 0 2
6809: PPUSH
6810: LD_INT 71
6812: PPUSH
6813: LD_INT 49
6815: PPUSH
6816: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6820: LD_INT 35
6822: PPUSH
6823: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6827: LD_INT 7
6829: PPUSH
6830: LD_INT 71
6832: PPUSH
6833: LD_INT 51
6835: PPUSH
6836: CALL_OW 293
6840: IFFALSE 6820
// DialogueOn ;
6842: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6846: LD_EXP 14
6850: PPUSH
6851: LD_STRING D1-JMM-1
6853: PPUSH
6854: CALL_OW 88
// if Joan then
6858: LD_EXP 29
6862: IFFALSE 6876
// Say ( Joan , D1-Joan-1 ) ;
6864: LD_EXP 29
6868: PPUSH
6869: LD_STRING D1-Joan-1
6871: PPUSH
6872: CALL_OW 88
// if Lisa then
6876: LD_EXP 16
6880: IFFALSE 6894
// Say ( Lisa , D1-Lisa-1 ) ;
6882: LD_EXP 16
6886: PPUSH
6887: LD_STRING D1-Lisa-1
6889: PPUSH
6890: CALL_OW 88
// if Joan or Lisa then
6894: LD_EXP 29
6898: PUSH
6899: LD_EXP 16
6903: OR
6904: IFFALSE 6918
// Say ( JMM , D1-JMM-2 ) ;
6906: LD_EXP 14
6910: PPUSH
6911: LD_STRING D1-JMM-2
6913: PPUSH
6914: CALL_OW 88
// DialogueOff ;
6918: CALL_OW 7
// InGameOff ;
6922: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6926: LD_INT 71
6928: PPUSH
6929: LD_INT 50
6931: PPUSH
6932: LD_INT 7
6934: PPUSH
6935: LD_INT 30
6937: NEG
6938: PPUSH
6939: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6943: LD_INT 71
6945: PPUSH
6946: LD_INT 50
6948: PPUSH
6949: LD_INT 7
6951: PPUSH
6952: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6956: LD_STRING M1
6958: PPUSH
6959: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6963: LD_INT 35
6965: PPUSH
6966: CALL_OW 67
// until freedom ;
6970: LD_EXP 3
6974: IFFALSE 6963
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6976: LD_INT 350
6978: PPUSH
6979: LD_INT 700
6981: PPUSH
6982: CALL_OW 12
6986: PPUSH
6987: CALL_OW 67
// PrepareGossudarov ;
6991: CALL 1714 0 0
// repeat wait ( 0 0$1 ) ;
6995: LD_INT 35
6997: PPUSH
6998: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7002: LD_INT 22
7004: PUSH
7005: LD_INT 6
7007: PUSH
7008: EMPTY
7009: LIST
7010: LIST
7011: PUSH
7012: LD_INT 3
7014: PUSH
7015: LD_INT 24
7017: PUSH
7018: LD_INT 1000
7020: PUSH
7021: EMPTY
7022: LIST
7023: LIST
7024: PUSH
7025: EMPTY
7026: LIST
7027: LIST
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: PPUSH
7033: CALL_OW 69
7037: PUSH
7038: LD_INT 7
7040: PPUSH
7041: LD_EXP 31
7045: PPUSH
7046: CALL_OW 292
7050: OR
7051: IFFALSE 6995
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7053: LD_ADDR_VAR 0 2
7057: PUSH
7058: LD_INT 22
7060: PUSH
7061: LD_INT 6
7063: PUSH
7064: EMPTY
7065: LIST
7066: LIST
7067: PPUSH
7068: CALL_OW 69
7072: ST_TO_ADDR
// for i in tmp do
7073: LD_ADDR_VAR 0 3
7077: PUSH
7078: LD_VAR 0 2
7082: PUSH
7083: FOR_IN
7084: IFFALSE 7100
// SetSide ( i , 7 ) ;
7086: LD_VAR 0 3
7090: PPUSH
7091: LD_INT 7
7093: PPUSH
7094: CALL_OW 235
7098: GO 7083
7100: POP
7101: POP
// DialogueOn ;
7102: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7106: LD_EXP 14
7110: PUSH
7111: LD_EXP 15
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: PPUSH
7120: LD_EXP 31
7124: PPUSH
7125: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7129: LD_EXP 31
7133: PPUSH
7134: CALL_OW 87
// if not Roth then
7138: LD_EXP 15
7142: NOT
7143: IFFALSE 7235
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7145: LD_VAR 0 2
7149: PPUSH
7150: LD_INT 3
7152: PUSH
7153: LD_INT 24
7155: PUSH
7156: LD_INT 1000
7158: PUSH
7159: EMPTY
7160: LIST
7161: LIST
7162: PUSH
7163: EMPTY
7164: LIST
7165: LIST
7166: PPUSH
7167: CALL_OW 72
7171: IFFALSE 7185
// Say ( JMM , D2-JMM-1 ) ;
7173: LD_EXP 14
7177: PPUSH
7178: LD_STRING D2-JMM-1
7180: PPUSH
7181: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7185: LD_EXP 14
7189: PPUSH
7190: LD_STRING D2-JMM-1b
7192: PPUSH
7193: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7197: LD_EXP 31
7201: PPUSH
7202: LD_STRING D2-Gos-1
7204: PPUSH
7205: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7209: LD_EXP 14
7213: PPUSH
7214: LD_STRING D2-JMM-2
7216: PPUSH
7217: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7221: LD_EXP 31
7225: PPUSH
7226: LD_STRING D2-Gos-2
7228: PPUSH
7229: CALL_OW 88
// end else
7233: GO 7387
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7235: LD_VAR 0 2
7239: PPUSH
7240: LD_INT 3
7242: PUSH
7243: LD_INT 24
7245: PUSH
7246: LD_INT 1000
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: PUSH
7253: EMPTY
7254: LIST
7255: LIST
7256: PPUSH
7257: CALL_OW 72
7261: IFFALSE 7287
// begin Say ( Roth , D2-Roth-2 ) ;
7263: LD_EXP 15
7267: PPUSH
7268: LD_STRING D2-Roth-2
7270: PPUSH
7271: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7275: LD_EXP 14
7279: PPUSH
7280: LD_STRING D2-JMM-1a
7282: PPUSH
7283: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7287: LD_EXP 15
7291: PPUSH
7292: LD_STRING D2-Roth-2a
7294: PPUSH
7295: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7299: LD_EXP 15
7303: PPUSH
7304: LD_STRING D2-Roth-2b
7306: PPUSH
7307: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7311: LD_EXP 14
7315: PPUSH
7316: LD_STRING D2-JMM-3
7318: PPUSH
7319: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7323: LD_VAR 0 2
7327: PPUSH
7328: LD_INT 3
7330: PUSH
7331: LD_INT 24
7333: PUSH
7334: LD_INT 1000
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: PPUSH
7345: CALL_OW 72
7349: IFFALSE 7387
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7351: LD_EXP 31
7355: PPUSH
7356: LD_STRING D2-Gos-3
7358: PPUSH
7359: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7363: LD_EXP 14
7367: PPUSH
7368: LD_STRING D2-JMM-4
7370: PPUSH
7371: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7375: LD_EXP 31
7379: PPUSH
7380: LD_STRING D2-Gos-4
7382: PPUSH
7383: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7387: LD_EXP 14
7391: PPUSH
7392: LD_STRING D2-JMM-5
7394: PPUSH
7395: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7399: LD_EXP 31
7403: PPUSH
7404: LD_STRING D2-Gos-5
7406: PPUSH
7407: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7411: LD_EXP 14
7415: PPUSH
7416: LD_STRING D2-JMM-6
7418: PPUSH
7419: CALL_OW 88
// DialogueOff ;
7423: CALL_OW 7
// wait ( 0 0$2 ) ;
7427: LD_INT 70
7429: PPUSH
7430: CALL_OW 67
// if Kirilenkova then
7434: LD_EXP 32
7438: IFFALSE 7452
// Say ( Kirilenkova , D3-Kir-1 ) ;
7440: LD_EXP 32
7444: PPUSH
7445: LD_STRING D3-Kir-1
7447: PPUSH
7448: CALL_OW 88
// gossudarov_arrive := true ;
7452: LD_ADDR_EXP 4
7456: PUSH
7457: LD_INT 1
7459: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7460: LD_INT 35
7462: PPUSH
7463: CALL_OW 67
// until ru_lab_builded ;
7467: LD_EXP 5
7471: IFFALSE 7460
// if Kirilenkova then
7473: LD_EXP 32
7477: IFFALSE 7493
// Say ( Kirilenkova , D3a-Kir-1 ) else
7479: LD_EXP 32
7483: PPUSH
7484: LD_STRING D3a-Kir-1
7486: PPUSH
7487: CALL_OW 88
7491: GO 7515
// begin un := SciRu ;
7493: LD_ADDR_VAR 0 4
7497: PUSH
7498: CALL 12600 0 0
7502: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7503: LD_VAR 0 4
7507: PPUSH
7508: LD_STRING D3a-Sci1-1
7510: PPUSH
7511: CALL_OW 88
// end ; if Kirilenkova or un then
7515: LD_EXP 32
7519: PUSH
7520: LD_VAR 0 4
7524: OR
7525: IFFALSE 7539
// Say ( JMM , D3a-JMM-1 ) ;
7527: LD_EXP 14
7531: PPUSH
7532: LD_STRING D3a-JMM-1
7534: PPUSH
7535: CALL_OW 88
// end ;
7539: LD_VAR 0 1
7543: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7544: LD_EXP 4
7548: PUSH
7549: LD_INT 22
7551: PUSH
7552: LD_INT 7
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: PUSH
7559: LD_INT 2
7561: PUSH
7562: LD_INT 25
7564: PUSH
7565: LD_INT 1
7567: PUSH
7568: EMPTY
7569: LIST
7570: LIST
7571: PUSH
7572: LD_INT 25
7574: PUSH
7575: LD_INT 2
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: PUSH
7582: LD_INT 25
7584: PUSH
7585: LD_INT 3
7587: PUSH
7588: EMPTY
7589: LIST
7590: LIST
7591: PUSH
7592: LD_INT 25
7594: PUSH
7595: LD_INT 4
7597: PUSH
7598: EMPTY
7599: LIST
7600: LIST
7601: PUSH
7602: LD_INT 25
7604: PUSH
7605: LD_INT 5
7607: PUSH
7608: EMPTY
7609: LIST
7610: LIST
7611: PUSH
7612: LD_INT 25
7614: PUSH
7615: LD_INT 8
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: PUSH
7622: LD_INT 25
7624: PUSH
7625: LD_INT 9
7627: PUSH
7628: EMPTY
7629: LIST
7630: LIST
7631: PUSH
7632: EMPTY
7633: LIST
7634: LIST
7635: LIST
7636: LIST
7637: LIST
7638: LIST
7639: LIST
7640: LIST
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: PPUSH
7646: CALL_OW 69
7650: PUSH
7651: LD_INT 7
7653: LESS
7654: AND
7655: IFFALSE 7667
7657: GO 7659
7659: DISABLE
// YouLost ( TooMany ) ;
7660: LD_STRING TooMany
7662: PPUSH
7663: CALL_OW 104
7667: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7668: LD_EXP 31
7672: PPUSH
7673: CALL_OW 255
7677: PUSH
7678: LD_INT 7
7680: EQUAL
7681: IFFALSE 7881
7683: GO 7685
7685: DISABLE
7686: LD_INT 0
7688: PPUSH
7689: PPUSH
7690: PPUSH
// begin uc_side := 3 ;
7691: LD_ADDR_OWVAR 20
7695: PUSH
7696: LD_INT 3
7698: ST_TO_ADDR
// uc_nation := 3 ;
7699: LD_ADDR_OWVAR 21
7703: PUSH
7704: LD_INT 3
7706: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7707: LD_INT 21
7709: PPUSH
7710: LD_INT 3
7712: PPUSH
7713: LD_INT 3
7715: PPUSH
7716: LD_INT 42
7718: PPUSH
7719: LD_INT 100
7721: PPUSH
7722: CALL 21244 0 5
// un := CreateVehicle ;
7726: LD_ADDR_VAR 0 3
7730: PUSH
7731: CALL_OW 45
7735: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7736: LD_VAR 0 3
7740: PPUSH
7741: LD_INT 15
7743: PPUSH
7744: LD_INT 0
7746: PPUSH
7747: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7751: LD_VAR 0 3
7755: PPUSH
7756: LD_INT 67
7758: PPUSH
7759: LD_INT 45
7761: PPUSH
7762: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7766: LD_VAR 0 3
7770: PPUSH
7771: LD_INT 70
7773: PPUSH
7774: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7778: LD_VAR 0 3
7782: PPUSH
7783: LD_INT 69
7785: PPUSH
7786: LD_INT 18
7788: PPUSH
7789: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7793: LD_VAR 0 3
7797: PPUSH
7798: LD_INT 60
7800: PPUSH
7801: LD_INT 2
7803: PPUSH
7804: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7808: LD_INT 35
7810: PPUSH
7811: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7815: LD_VAR 0 3
7819: PPUSH
7820: CALL_OW 302
7824: NOT
7825: PUSH
7826: LD_VAR 0 3
7830: PPUSH
7831: LD_INT 17
7833: PPUSH
7834: CALL_OW 308
7838: OR
7839: IFFALSE 7808
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7841: LD_VAR 0 3
7845: PPUSH
7846: LD_INT 17
7848: PPUSH
7849: CALL_OW 308
7853: PUSH
7854: LD_VAR 0 3
7858: PPUSH
7859: LD_INT 60
7861: PPUSH
7862: LD_INT 2
7864: PPUSH
7865: CALL_OW 307
7869: OR
7870: IFFALSE 7881
// RemoveUnit ( un ) ;
7872: LD_VAR 0 3
7876: PPUSH
7877: CALL_OW 64
// end ;
7881: PPOPN 3
7883: END
// every 0 0$2 do var i , un , tmp ;
7884: GO 7886
7886: DISABLE
7887: LD_INT 0
7889: PPUSH
7890: PPUSH
7891: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7892: LD_INT 70
7894: PPUSH
7895: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7899: LD_ADDR_VAR 0 3
7903: PUSH
7904: LD_INT 22
7906: PUSH
7907: LD_INT 7
7909: PUSH
7910: EMPTY
7911: LIST
7912: LIST
7913: PUSH
7914: LD_INT 101
7916: PUSH
7917: LD_INT 3
7919: PUSH
7920: EMPTY
7921: LIST
7922: LIST
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PPUSH
7928: CALL_OW 69
7932: ST_TO_ADDR
// until tmp ;
7933: LD_VAR 0 3
7937: IFFALSE 7892
// un := NearestUnitToUnit ( tmp , JMM ) ;
7939: LD_ADDR_VAR 0 2
7943: PUSH
7944: LD_VAR 0 3
7948: PPUSH
7949: LD_EXP 14
7953: PPUSH
7954: CALL_OW 74
7958: ST_TO_ADDR
// player_spotted := true ;
7959: LD_ADDR_EXP 6
7963: PUSH
7964: LD_INT 1
7966: ST_TO_ADDR
// tmp := SciRu ;
7967: LD_ADDR_VAR 0 3
7971: PUSH
7972: CALL 12600 0 0
7976: ST_TO_ADDR
// if not tmp then
7977: LD_VAR 0 3
7981: NOT
7982: IFFALSE 7994
// tmp := SolRu ;
7984: LD_ADDR_VAR 0 3
7988: PUSH
7989: CALL 12747 0 0
7993: ST_TO_ADDR
// DialogueOn ;
7994: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7998: LD_VAR 0 2
8002: PPUSH
8003: CALL_OW 250
8007: PPUSH
8008: LD_VAR 0 2
8012: PPUSH
8013: CALL_OW 251
8017: PPUSH
8018: LD_INT 7
8020: PPUSH
8021: LD_INT 8
8023: NEG
8024: PPUSH
8025: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8029: LD_VAR 0 2
8033: PPUSH
8034: CALL_OW 87
// if tmp then
8038: LD_VAR 0 3
8042: IFFALSE 8056
// Say ( tmp , D4-RSci1-1 ) ;
8044: LD_VAR 0 3
8048: PPUSH
8049: LD_STRING D4-RSci1-1
8051: PPUSH
8052: CALL_OW 88
// if Gossudarov then
8056: LD_EXP 31
8060: IFFALSE 8086
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8062: LD_EXP 31
8066: PPUSH
8067: LD_STRING D4-Gos-1
8069: PPUSH
8070: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8074: LD_EXP 14
8078: PPUSH
8079: LD_STRING D4-JMM-1
8081: PPUSH
8082: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8086: LD_VAR 0 2
8090: PPUSH
8091: CALL_OW 250
8095: PPUSH
8096: LD_VAR 0 2
8100: PPUSH
8101: CALL_OW 251
8105: PPUSH
8106: LD_INT 7
8108: PPUSH
8109: CALL_OW 331
// DialogueOff ;
8113: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8117: LD_STRING M5
8119: PPUSH
8120: CALL_OW 337
// end ;
8124: PPOPN 3
8126: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8127: LD_EXP 6
8131: IFFALSE 8720
8133: GO 8135
8135: DISABLE
8136: LD_INT 0
8138: PPUSH
8139: PPUSH
8140: PPUSH
// begin PrepareBelkov ;
8141: CALL 2004 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8145: LD_EXP 46
8149: PPUSH
8150: LD_INT 118
8152: PPUSH
8153: LD_INT 106
8155: PPUSH
8156: CALL_OW 111
// AddComHold ( Belkov ) ;
8160: LD_EXP 46
8164: PPUSH
8165: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8169: LD_INT 35
8171: PPUSH
8172: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8176: LD_EXP 46
8180: PPUSH
8181: LD_INT 118
8183: PPUSH
8184: LD_INT 106
8186: PPUSH
8187: CALL_OW 307
8191: IFFALSE 8169
// ChangeSideFog ( 4 , 7 ) ;
8193: LD_INT 4
8195: PPUSH
8196: LD_INT 7
8198: PPUSH
8199: CALL_OW 343
// if IsOk ( Belkov ) then
8203: LD_EXP 46
8207: PPUSH
8208: CALL_OW 302
8212: IFFALSE 8296
// begin InGameOn ;
8214: CALL_OW 8
// DialogueOn ;
8218: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8222: LD_EXP 46
8226: PPUSH
8227: LD_STRING D5-Bel-1
8229: PPUSH
8230: CALL_OW 94
// if Gossudarov then
8234: LD_EXP 31
8238: IFFALSE 8288
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8240: LD_EXP 31
8244: PPUSH
8245: LD_STRING D5-Gos-1
8247: PPUSH
8248: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8252: LD_EXP 14
8256: PPUSH
8257: LD_STRING D5-JMM-1
8259: PPUSH
8260: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8264: LD_EXP 31
8268: PPUSH
8269: LD_STRING D5-Gos-2
8271: PPUSH
8272: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8276: LD_EXP 14
8280: PPUSH
8281: LD_STRING D5-JMM-2
8283: PPUSH
8284: CALL_OW 88
// end ; DialogueOff ;
8288: CALL_OW 7
// InGameOff ;
8292: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8296: LD_STRING QSaveBelkov
8298: PPUSH
8299: CALL_OW 97
8303: PUSH
8304: LD_INT 1
8306: DOUBLE
8307: EQUAL
8308: IFTRUE 8312
8310: GO 8362
8312: POP
// begin DialogueOn ;
8313: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8317: LD_EXP 14
8321: PPUSH
8322: LD_STRING D5a-JMM-1
8324: PPUSH
8325: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8329: LD_EXP 46
8333: PPUSH
8334: LD_STRING D5a-Bel-1
8336: PPUSH
8337: CALL_OW 94
// DialogueOff ;
8341: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8345: LD_EXP 46
8349: PPUSH
8350: LD_INT 83
8352: PPUSH
8353: LD_INT 49
8355: PPUSH
8356: CALL_OW 111
// end ; 2 :
8360: GO 8395
8362: LD_INT 2
8364: DOUBLE
8365: EQUAL
8366: IFTRUE 8370
8368: GO 8394
8370: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8371: LD_EXP 14
8375: PPUSH
8376: LD_STRING D5a-JMM-2
8378: PPUSH
8379: CALL_OW 88
// ComHold ( Belkov ) ;
8383: LD_EXP 46
8387: PPUSH
8388: CALL_OW 140
// end ; end ;
8392: GO 8395
8394: POP
// time := 0 0$00 ;
8395: LD_ADDR_VAR 0 1
8399: PUSH
8400: LD_INT 0
8402: ST_TO_ADDR
// vehSpawned := false ;
8403: LD_ADDR_VAR 0 3
8407: PUSH
8408: LD_INT 0
8410: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8411: LD_INT 35
8413: PPUSH
8414: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8418: LD_VAR 0 1
8422: PUSH
8423: LD_INT 350
8425: PUSH
8426: LD_INT 175
8428: PUSH
8429: LD_INT 70
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: LIST
8436: PUSH
8437: LD_OWVAR 67
8441: ARRAY
8442: GREATEREQUAL
8443: PUSH
8444: LD_VAR 0 3
8448: NOT
8449: AND
8450: IFFALSE 8540
// begin vehSpawned := true ;
8452: LD_ADDR_VAR 0 3
8456: PUSH
8457: LD_INT 1
8459: ST_TO_ADDR
// uc_side := 3 ;
8460: LD_ADDR_OWVAR 20
8464: PUSH
8465: LD_INT 3
8467: ST_TO_ADDR
// uc_nation := 3 ;
8468: LD_ADDR_OWVAR 21
8472: PUSH
8473: LD_INT 3
8475: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8476: LD_INT 22
8478: PPUSH
8479: LD_INT 3
8481: PPUSH
8482: LD_INT 3
8484: PPUSH
8485: LD_INT 43
8487: PPUSH
8488: LD_INT 100
8490: PPUSH
8491: CALL 21244 0 5
// veh := CreateVehicle ;
8495: LD_ADDR_VAR 0 2
8499: PUSH
8500: CALL_OW 45
8504: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8505: LD_VAR 0 2
8509: PPUSH
8510: LD_INT 130
8512: PPUSH
8513: LD_INT 131
8515: PPUSH
8516: LD_INT 0
8518: PPUSH
8519: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8523: LD_VAR 0 2
8527: PPUSH
8528: LD_INT 100
8530: PPUSH
8531: LD_INT 82
8533: PPUSH
8534: CALL_OW 114
// end else
8538: GO 8554
// time := time + 0 0$1 ;
8540: LD_ADDR_VAR 0 1
8544: PUSH
8545: LD_VAR 0 1
8549: PUSH
8550: LD_INT 35
8552: PLUS
8553: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8554: LD_EXP 46
8558: PPUSH
8559: CALL_OW 301
8563: PUSH
8564: LD_EXP 46
8568: PPUSH
8569: CALL_OW 255
8573: PUSH
8574: LD_INT 4
8576: EQUAL
8577: AND
8578: PUSH
8579: LD_INT 22
8581: PUSH
8582: LD_INT 7
8584: PUSH
8585: EMPTY
8586: LIST
8587: LIST
8588: PPUSH
8589: CALL_OW 69
8593: PPUSH
8594: LD_EXP 46
8598: PPUSH
8599: CALL_OW 74
8603: PPUSH
8604: LD_EXP 46
8608: PPUSH
8609: CALL_OW 296
8613: PUSH
8614: LD_INT 10
8616: LESS
8617: OR
8618: IFFALSE 8411
// if IsDead ( Belkov ) then
8620: LD_EXP 46
8624: PPUSH
8625: CALL_OW 301
8629: IFFALSE 8654
// begin CenterNowOnUnits ( Belkov ) ;
8631: LD_EXP 46
8635: PPUSH
8636: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8640: LD_EXP 14
8644: PPUSH
8645: LD_STRING D5a-JMM-2a
8647: PPUSH
8648: CALL_OW 88
// exit ;
8652: GO 8720
// end ; if See ( 7 , Belkov ) then
8654: LD_INT 7
8656: PPUSH
8657: LD_EXP 46
8661: PPUSH
8662: CALL_OW 292
8666: IFFALSE 8680
// SetSide ( Belkov , 7 ) ;
8668: LD_EXP 46
8672: PPUSH
8673: LD_INT 7
8675: PPUSH
8676: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8680: LD_INT 35
8682: PPUSH
8683: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8687: LD_EXP 46
8691: PPUSH
8692: LD_INT 66
8694: PPUSH
8695: LD_INT 45
8697: PPUSH
8698: CALL_OW 297
8702: PUSH
8703: LD_INT 30
8705: LESS
8706: IFFALSE 8680
// Say ( Belkov , D6-Bel-1 ) ;
8708: LD_EXP 46
8712: PPUSH
8713: LD_STRING D6-Bel-1
8715: PPUSH
8716: CALL_OW 88
// end ;
8720: PPOPN 3
8722: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8723: LD_EXP 46
8727: PPUSH
8728: CALL_OW 302
8732: PUSH
8733: LD_EXP 46
8737: PPUSH
8738: CALL_OW 504
8742: PUSH
8743: LD_INT 2
8745: PUSH
8746: LD_INT 34
8748: PUSH
8749: LD_INT 47
8751: PUSH
8752: EMPTY
8753: LIST
8754: LIST
8755: PUSH
8756: LD_INT 34
8758: PUSH
8759: LD_INT 45
8761: PUSH
8762: EMPTY
8763: LIST
8764: LIST
8765: PUSH
8766: EMPTY
8767: LIST
8768: LIST
8769: LIST
8770: PPUSH
8771: CALL_OW 69
8775: IN
8776: AND
8777: IFFALSE 8794
8779: GO 8781
8781: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8782: LD_EXP 46
8786: PPUSH
8787: LD_STRING D7-Bel-1
8789: PPUSH
8790: CALL_OW 88
8794: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8795: LD_INT 22
8797: PUSH
8798: LD_INT 7
8800: PUSH
8801: EMPTY
8802: LIST
8803: LIST
8804: PUSH
8805: LD_INT 101
8807: PUSH
8808: LD_INT 2
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: PUSH
8815: EMPTY
8816: LIST
8817: LIST
8818: PPUSH
8819: CALL_OW 69
8823: PUSH
8824: LD_EXP 8
8828: NOT
8829: AND
8830: PUSH
8831: LD_EXP 45
8835: PPUSH
8836: CALL_OW 305
8840: NOT
8841: AND
8842: IFFALSE 9312
8844: GO 8846
8846: DISABLE
8847: LD_INT 0
8849: PPUSH
// begin ar_base_spotted := true ;
8850: LD_ADDR_EXP 8
8854: PUSH
8855: LD_INT 1
8857: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8858: LD_ADDR_VAR 0 1
8862: PUSH
8863: LD_INT 22
8865: PUSH
8866: LD_INT 2
8868: PUSH
8869: EMPTY
8870: LIST
8871: LIST
8872: PUSH
8873: LD_INT 21
8875: PUSH
8876: LD_INT 3
8878: PUSH
8879: EMPTY
8880: LIST
8881: LIST
8882: PUSH
8883: EMPTY
8884: LIST
8885: LIST
8886: PPUSH
8887: CALL_OW 69
8891: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8892: LD_ADDR_VAR 0 1
8896: PUSH
8897: LD_VAR 0 1
8901: PPUSH
8902: LD_EXP 14
8906: PPUSH
8907: CALL_OW 74
8911: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8912: LD_INT 7
8914: PPUSH
8915: LD_INT 3
8917: PPUSH
8918: CALL_OW 332
// DialogueOn ;
8922: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8926: LD_VAR 0 1
8930: PPUSH
8931: CALL_OW 250
8935: PPUSH
8936: LD_VAR 0 1
8940: PPUSH
8941: CALL_OW 251
8945: PPUSH
8946: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8950: LD_ADDR_VAR 0 1
8954: PUSH
8955: LD_INT 22
8957: PUSH
8958: LD_INT 7
8960: PUSH
8961: EMPTY
8962: LIST
8963: LIST
8964: PUSH
8965: LD_INT 23
8967: PUSH
8968: LD_INT 1
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: PUSH
8975: LD_INT 26
8977: PUSH
8978: LD_INT 1
8980: PUSH
8981: EMPTY
8982: LIST
8983: LIST
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: LIST
8989: PPUSH
8990: CALL_OW 69
8994: PUSH
8995: LD_EXP 14
8999: PUSH
9000: LD_EXP 18
9004: PUSH
9005: LD_EXP 19
9009: PUSH
9010: LD_EXP 26
9014: PUSH
9015: LD_EXP 15
9019: PUSH
9020: LD_EXP 24
9024: PUSH
9025: LD_EXP 20
9029: PUSH
9030: LD_EXP 22
9034: PUSH
9035: EMPTY
9036: LIST
9037: LIST
9038: LIST
9039: LIST
9040: LIST
9041: LIST
9042: LIST
9043: LIST
9044: DIFF
9045: ST_TO_ADDR
// if not tmp then
9046: LD_VAR 0 1
9050: NOT
9051: IFFALSE 9125
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9053: LD_ADDR_VAR 0 1
9057: PUSH
9058: LD_INT 22
9060: PUSH
9061: LD_INT 7
9063: PUSH
9064: EMPTY
9065: LIST
9066: LIST
9067: PUSH
9068: LD_INT 23
9070: PUSH
9071: LD_INT 1
9073: PUSH
9074: EMPTY
9075: LIST
9076: LIST
9077: PUSH
9078: LD_INT 26
9080: PUSH
9081: LD_INT 2
9083: PUSH
9084: EMPTY
9085: LIST
9086: LIST
9087: PUSH
9088: EMPTY
9089: LIST
9090: LIST
9091: LIST
9092: PPUSH
9093: CALL_OW 69
9097: PUSH
9098: LD_EXP 29
9102: PUSH
9103: LD_EXP 16
9107: PUSH
9108: LD_EXP 27
9112: PUSH
9113: LD_EXP 28
9117: PUSH
9118: EMPTY
9119: LIST
9120: LIST
9121: LIST
9122: LIST
9123: DIFF
9124: ST_TO_ADDR
// if tmp then
9125: LD_VAR 0 1
9129: IFFALSE 9200
// case GetSex ( tmp [ 1 ] ) of sex_male :
9131: LD_VAR 0 1
9135: PUSH
9136: LD_INT 1
9138: ARRAY
9139: PPUSH
9140: CALL_OW 258
9144: PUSH
9145: LD_INT 1
9147: DOUBLE
9148: EQUAL
9149: IFTRUE 9153
9151: GO 9172
9153: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9154: LD_VAR 0 1
9158: PUSH
9159: LD_INT 1
9161: ARRAY
9162: PPUSH
9163: LD_STRING D9-Sol1-1
9165: PPUSH
9166: CALL_OW 88
9170: GO 9200
9172: LD_INT 2
9174: DOUBLE
9175: EQUAL
9176: IFTRUE 9180
9178: GO 9199
9180: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9181: LD_VAR 0 1
9185: PUSH
9186: LD_INT 1
9188: ARRAY
9189: PPUSH
9190: LD_STRING D9-FSol1-1
9192: PPUSH
9193: CALL_OW 88
9197: GO 9200
9199: POP
// if Frank then
9200: LD_EXP 26
9204: IFFALSE 9308
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9206: LD_EXP 55
9210: PPUSH
9211: CALL_OW 250
9215: PPUSH
9216: LD_EXP 55
9220: PPUSH
9221: CALL_OW 251
9225: PPUSH
9226: LD_INT 7
9228: PPUSH
9229: LD_INT 8
9231: PPUSH
9232: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9236: LD_EXP 55
9240: PPUSH
9241: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9245: LD_EXP 26
9249: PPUSH
9250: LD_STRING D9-Frank-1
9252: PPUSH
9253: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9257: LD_EXP 14
9261: PPUSH
9262: LD_STRING D9-JMM-1
9264: PPUSH
9265: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9269: LD_EXP 26
9273: PPUSH
9274: LD_STRING D9-Frank-2
9276: PPUSH
9277: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9281: LD_EXP 55
9285: PPUSH
9286: CALL_OW 250
9290: PPUSH
9291: LD_EXP 55
9295: PPUSH
9296: CALL_OW 251
9300: PPUSH
9301: LD_INT 7
9303: PPUSH
9304: CALL_OW 331
// end ; DialogueOff ;
9308: CALL_OW 7
// end ;
9312: PPOPN 1
9314: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9315: LD_EXP 7
9319: PUSH
9320: LD_OWVAR 1
9324: PUSH
9325: LD_INT 42000
9327: GREATEREQUAL
9328: OR
9329: IFFALSE 10356
9331: GO 9333
9333: DISABLE
9334: LD_INT 0
9336: PPUSH
9337: PPUSH
// begin selected_option := 1 ;
9338: LD_ADDR_VAR 0 2
9342: PUSH
9343: LD_INT 1
9345: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9346: LD_INT 10500
9348: PPUSH
9349: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9353: LD_INT 35
9355: PPUSH
9356: CALL_OW 67
// until not ru_attackers ;
9360: LD_EXP 51
9364: NOT
9365: IFFALSE 9353
// PrepareBurlak ;
9367: CALL 2116 0 0
// repeat wait ( 0 0$2 ) ;
9371: LD_INT 70
9373: PPUSH
9374: CALL_OW 67
// until not HasTask ( Burlak ) ;
9378: LD_EXP 45
9382: PPUSH
9383: CALL_OW 314
9387: NOT
9388: IFFALSE 9371
// InGameOn ;
9390: CALL_OW 8
// DialogueOn ;
9394: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9398: LD_EXP 48
9402: PPUSH
9403: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9407: LD_EXP 45
9411: PPUSH
9412: LD_STRING D10-Bur-1
9414: PPUSH
9415: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9419: LD_EXP 46
9423: PUSH
9424: LD_EXP 46
9428: PPUSH
9429: CALL_OW 255
9433: PUSH
9434: LD_INT 7
9436: EQUAL
9437: AND
9438: IFFALSE 9452
// Say ( Belkov , D10-Bel-1 ) ;
9440: LD_EXP 46
9444: PPUSH
9445: LD_STRING D10-Bel-1
9447: PPUSH
9448: CALL_OW 88
// if Gossudarov then
9452: LD_EXP 31
9456: IFFALSE 9470
// Say ( Gossudarov , D10-Gos-1 ) ;
9458: LD_EXP 31
9462: PPUSH
9463: LD_STRING D10-Gos-1
9465: PPUSH
9466: CALL_OW 88
// if Kirilenkova then
9470: LD_EXP 32
9474: IFFALSE 9488
// Say ( Kirilenkova , D10-Kir-1 ) ;
9476: LD_EXP 32
9480: PPUSH
9481: LD_STRING D10-Kir-1
9483: PPUSH
9484: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9488: CALL 12747 0 0
9492: PPUSH
9493: LD_STRING D10-RSol1-1
9495: PPUSH
9496: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9500: LD_EXP 45
9504: PPUSH
9505: LD_STRING D10-Bur-2
9507: PPUSH
9508: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9512: LD_EXP 14
9516: PPUSH
9517: LD_STRING D10-JMM-2
9519: PPUSH
9520: CALL_OW 88
// if Kirilenkova then
9524: LD_EXP 32
9528: IFFALSE 9544
// Say ( Kirilenkova , D10-Kir-2 ) else
9530: LD_EXP 32
9534: PPUSH
9535: LD_STRING D10-Kir-2
9537: PPUSH
9538: CALL_OW 88
9542: GO 9556
// Say ( SolRu , D10-RSol1-2 ) ;
9544: CALL 12747 0 0
9548: PPUSH
9549: LD_STRING D10-RSol1-2
9551: PPUSH
9552: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9556: LD_EXP 14
9560: PPUSH
9561: LD_STRING D10-JMM-3
9563: PPUSH
9564: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9568: LD_EXP 45
9572: PPUSH
9573: LD_STRING D10-Bur-3
9575: PPUSH
9576: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9580: LD_EXP 14
9584: PPUSH
9585: LD_STRING D10-JMM-4
9587: PPUSH
9588: CALL_OW 88
// DialogueOff ;
9592: CALL_OW 7
// InGameOff ;
9596: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9600: LD_STRING M2
9602: PPUSH
9603: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9607: LD_INT 35
9609: PPUSH
9610: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9614: LD_INT 22
9616: PUSH
9617: LD_INT 7
9619: PUSH
9620: EMPTY
9621: LIST
9622: LIST
9623: PUSH
9624: LD_INT 91
9626: PUSH
9627: LD_EXP 45
9631: PUSH
9632: LD_INT 8
9634: PUSH
9635: EMPTY
9636: LIST
9637: LIST
9638: LIST
9639: PUSH
9640: EMPTY
9641: LIST
9642: LIST
9643: PPUSH
9644: CALL_OW 69
9648: IFFALSE 9607
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9650: LD_ADDR_VAR 0 1
9654: PUSH
9655: LD_INT 22
9657: PUSH
9658: LD_INT 4
9660: PUSH
9661: EMPTY
9662: LIST
9663: LIST
9664: PPUSH
9665: CALL_OW 69
9669: PUSH
9670: FOR_IN
9671: IFFALSE 9687
// SetSide ( i , 7 ) ;
9673: LD_VAR 0 1
9677: PPUSH
9678: LD_INT 7
9680: PPUSH
9681: CALL_OW 235
9685: GO 9670
9687: POP
9688: POP
// ChangeMissionObjectives ( M3 ) ;
9689: LD_STRING M3
9691: PPUSH
9692: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9696: LD_INT 35
9698: PPUSH
9699: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9703: LD_EXP 14
9707: PPUSH
9708: LD_EXP 45
9712: PPUSH
9713: CALL_OW 296
9717: PUSH
9718: LD_INT 8
9720: LESS
9721: IFFALSE 9696
// ComTurnUnit ( JMM , Burlak ) ;
9723: LD_EXP 14
9727: PPUSH
9728: LD_EXP 45
9732: PPUSH
9733: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9737: LD_EXP 45
9741: PPUSH
9742: LD_EXP 14
9746: PPUSH
9747: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9751: LD_INT 10
9753: PPUSH
9754: CALL_OW 67
// DialogueOn ;
9758: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9762: LD_EXP 14
9766: PPUSH
9767: LD_STRING D11-JMM-1
9769: PPUSH
9770: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9774: LD_EXP 45
9778: PPUSH
9779: LD_STRING D11-Bur-1
9781: PPUSH
9782: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9786: LD_EXP 14
9790: PPUSH
9791: LD_STRING D11-JMM-2
9793: PPUSH
9794: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9798: LD_EXP 45
9802: PPUSH
9803: LD_STRING D11-Bur-2
9805: PPUSH
9806: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9810: LD_EXP 14
9814: PPUSH
9815: LD_STRING D11-JMM-3
9817: PPUSH
9818: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9822: LD_EXP 45
9826: PPUSH
9827: LD_STRING D11-Bur-3
9829: PPUSH
9830: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9834: LD_EXP 14
9838: PPUSH
9839: LD_STRING D11-JMM-4
9841: PPUSH
9842: CALL_OW 88
// if ar_base_spotted then
9846: LD_EXP 8
9850: IFFALSE 9866
// Say ( Burlak , D12-Bur-1 ) else
9852: LD_EXP 45
9856: PPUSH
9857: LD_STRING D12-Bur-1
9859: PPUSH
9860: CALL_OW 88
9864: GO 9905
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9866: LD_INT 7
9868: PPUSH
9869: LD_INT 3
9871: PPUSH
9872: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9876: LD_INT 127
9878: PPUSH
9879: LD_INT 45
9881: PPUSH
9882: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9886: LD_EXP 45
9890: PPUSH
9891: LD_STRING D12-Bur-1a
9893: PPUSH
9894: CALL_OW 88
// dwait ( 0 0$2 ) ;
9898: LD_INT 70
9900: PPUSH
9901: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9905: LD_EXP 45
9909: PPUSH
9910: LD_STRING D12-Bur-1b
9912: PPUSH
9913: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9917: LD_EXP 14
9921: PPUSH
9922: LD_STRING D12-JMM-1
9924: PPUSH
9925: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9929: LD_EXP 45
9933: PPUSH
9934: LD_STRING D12-Bur-2
9936: PPUSH
9937: CALL_OW 88
// if Roth then
9941: LD_EXP 15
9945: IFFALSE 9961
// Say ( Roth , D12-Roth-2 ) else
9947: LD_EXP 15
9951: PPUSH
9952: LD_STRING D12-Roth-2
9954: PPUSH
9955: CALL_OW 88
9959: GO 9973
// Say ( SciRu , D12-RSci1-2 ) ;
9961: CALL 12600 0 0
9965: PPUSH
9966: LD_STRING D12-RSci1-2
9968: PPUSH
9969: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9973: LD_EXP 14
9977: PPUSH
9978: LD_STRING D12-JMM-2
9980: PPUSH
9981: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9985: LD_EXP 45
9989: PPUSH
9990: LD_STRING D12-Bur-3
9992: PPUSH
9993: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9997: LD_EXP 14
10001: PPUSH
10002: LD_STRING D12-JMM-3
10004: PPUSH
10005: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10009: LD_EXP 45
10013: PPUSH
10014: LD_STRING D12-Bur-4
10016: PPUSH
10017: CALL_OW 88
// case Query ( QBase ) of 1 :
10021: LD_STRING QBase
10023: PPUSH
10024: CALL_OW 97
10028: PUSH
10029: LD_INT 1
10031: DOUBLE
10032: EQUAL
10033: IFTRUE 10037
10035: GO 10155
10037: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10038: LD_EXP 14
10042: PPUSH
10043: LD_STRING D13a-JMM-1
10045: PPUSH
10046: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10050: LD_EXP 45
10054: PPUSH
10055: LD_STRING D13a-Bur-1
10057: PPUSH
10058: CALL_OW 88
// if Roth then
10062: LD_EXP 15
10066: IFFALSE 10082
// Say ( Roth , D13a-Roth-1 ) else
10068: LD_EXP 15
10072: PPUSH
10073: LD_STRING D13a-Roth-1
10075: PPUSH
10076: CALL_OW 88
10080: GO 10094
// Say ( SciRu , D13a-RSci1-1 ) ;
10082: CALL 12600 0 0
10086: PPUSH
10087: LD_STRING D13a-RSci1-1
10089: PPUSH
10090: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10094: LD_EXP 14
10098: PPUSH
10099: LD_STRING D13a-JMM-2
10101: PPUSH
10102: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10106: LD_STRING QBaseAgain
10108: PPUSH
10109: CALL_OW 97
10113: PUSH
10114: LD_INT 1
10116: DOUBLE
10117: EQUAL
10118: IFTRUE 10122
10120: GO 10133
10122: POP
// selected_option := 2 ; 2 :
10123: LD_ADDR_VAR 0 2
10127: PUSH
10128: LD_INT 2
10130: ST_TO_ADDR
10131: GO 10153
10133: LD_INT 2
10135: DOUBLE
10136: EQUAL
10137: IFTRUE 10141
10139: GO 10152
10141: POP
// selected_option := 3 ; end ;
10142: LD_ADDR_VAR 0 2
10146: PUSH
10147: LD_INT 3
10149: ST_TO_ADDR
10150: GO 10153
10152: POP
// end ; 2 :
10153: GO 10194
10155: LD_INT 2
10157: DOUBLE
10158: EQUAL
10159: IFTRUE 10163
10161: GO 10174
10163: POP
// selected_option := 2 ; 3 :
10164: LD_ADDR_VAR 0 2
10168: PUSH
10169: LD_INT 2
10171: ST_TO_ADDR
10172: GO 10194
10174: LD_INT 3
10176: DOUBLE
10177: EQUAL
10178: IFTRUE 10182
10180: GO 10193
10182: POP
// selected_option := 3 ; end ;
10183: LD_ADDR_VAR 0 2
10187: PUSH
10188: LD_INT 3
10190: ST_TO_ADDR
10191: GO 10194
10193: POP
// if selected_option = 2 then
10194: LD_VAR 0 2
10198: PUSH
10199: LD_INT 2
10201: EQUAL
10202: IFFALSE 10296
// begin Say ( JMM , D13b-JMM-1 ) ;
10204: LD_EXP 14
10208: PPUSH
10209: LD_STRING D13b-JMM-1
10211: PPUSH
10212: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10216: LD_EXP 45
10220: PPUSH
10221: LD_STRING D13b-Bur-1
10223: PPUSH
10224: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10228: LD_EXP 14
10232: PPUSH
10233: LD_STRING D13b-JMM-2
10235: PPUSH
10236: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10240: LD_EXP 54
10244: PPUSH
10245: LD_STRING D13b-Abd-2
10247: PPUSH
10248: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10252: LD_EXP 14
10256: PPUSH
10257: LD_STRING D13b-JMM-3
10259: PPUSH
10260: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10264: LD_EXP 54
10268: PPUSH
10269: LD_STRING D13b-Abd-3
10271: PPUSH
10272: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10276: LD_EXP 14
10280: PPUSH
10281: LD_STRING D13b-JMM-4
10283: PPUSH
10284: CALL_OW 88
// ar_active_attack := true ;
10288: LD_ADDR_EXP 9
10292: PUSH
10293: LD_INT 1
10295: ST_TO_ADDR
// end ; if selected_option = 3 then
10296: LD_VAR 0 2
10300: PUSH
10301: LD_INT 3
10303: EQUAL
10304: IFFALSE 10330
// begin Say ( JMM , D13c-JMM-1 ) ;
10306: LD_EXP 14
10310: PPUSH
10311: LD_STRING D13c-JMM-1
10313: PPUSH
10314: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10318: LD_EXP 45
10322: PPUSH
10323: LD_STRING D13c-Bur-1
10325: PPUSH
10326: CALL_OW 88
// end ; DialogueOff ;
10330: CALL_OW 7
// if not ar_active_attack then
10334: LD_EXP 9
10338: NOT
10339: IFFALSE 10356
// begin wait ( 6 6$00 ) ;
10341: LD_INT 12600
10343: PPUSH
10344: CALL_OW 67
// ar_active_attack := true ;
10348: LD_ADDR_EXP 9
10352: PUSH
10353: LD_INT 1
10355: ST_TO_ADDR
// end ; end ;
10356: PPOPN 2
10358: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10359: LD_EXP 45
10363: PPUSH
10364: CALL_OW 305
10368: PUSH
10369: LD_EXP 45
10373: PPUSH
10374: CALL_OW 255
10378: PUSH
10379: LD_INT 7
10381: EQUAL
10382: AND
10383: IFFALSE 10579
10385: GO 10387
10387: DISABLE
10388: LD_INT 0
10390: PPUSH
// begin wait ( 4 4$40 ) ;
10391: LD_INT 9800
10393: PPUSH
10394: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10398: LD_INT 35
10400: PPUSH
10401: CALL_OW 67
// until not ru_attackers ;
10405: LD_EXP 51
10409: NOT
10410: IFFALSE 10398
// PrepareGnyevko ;
10412: CALL 2060 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10416: LD_EXP 47
10420: PPUSH
10421: LD_INT 124
10423: PPUSH
10424: LD_INT 118
10426: PPUSH
10427: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10431: LD_EXP 47
10435: PPUSH
10436: CALL_OW 200
// time := 0 0$00 ;
10440: LD_ADDR_VAR 0 1
10444: PUSH
10445: LD_INT 0
10447: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10448: LD_INT 35
10450: PPUSH
10451: CALL_OW 67
// time := time + 0 0$1 ;
10455: LD_ADDR_VAR 0 1
10459: PUSH
10460: LD_VAR 0 1
10464: PUSH
10465: LD_INT 35
10467: PLUS
10468: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10469: LD_EXP 47
10473: PPUSH
10474: LD_INT 124
10476: PPUSH
10477: LD_INT 118
10479: PPUSH
10480: CALL_OW 307
10484: PUSH
10485: LD_VAR 0 1
10489: PUSH
10490: LD_INT 1050
10492: GREATEREQUAL
10493: OR
10494: IFFALSE 10448
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10496: LD_EXP 47
10500: PPUSH
10501: LD_STRING DBelkov-Gny-1
10503: PPUSH
10504: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10508: LD_EXP 45
10512: PPUSH
10513: LD_STRING DBelkov-Bur-1a
10515: PPUSH
10516: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10520: LD_INT 35
10522: PPUSH
10523: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10527: LD_EXP 47
10531: PPUSH
10532: LD_INT 22
10534: PUSH
10535: LD_INT 7
10537: PUSH
10538: EMPTY
10539: LIST
10540: LIST
10541: PPUSH
10542: CALL_OW 69
10546: PPUSH
10547: LD_EXP 47
10551: PPUSH
10552: CALL_OW 74
10556: PPUSH
10557: CALL_OW 296
10561: PUSH
10562: LD_INT 8
10564: LESS
10565: IFFALSE 10520
// SetSide ( Gnyevko , 7 ) ;
10567: LD_EXP 47
10571: PPUSH
10572: LD_INT 7
10574: PPUSH
10575: CALL_OW 235
// end ;
10579: PPOPN 1
10581: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10582: LD_EXP 45
10586: PPUSH
10587: CALL_OW 255
10591: PUSH
10592: LD_INT 7
10594: EQUAL
10595: IFFALSE 10605
10597: GO 10599
10599: DISABLE
// begin enable ;
10600: ENABLE
// PrepareAmericanAttack ;
10601: CALL 6435 0 0
// end ;
10605: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10606: LD_INT 22
10608: PUSH
10609: LD_INT 1
10611: PUSH
10612: EMPTY
10613: LIST
10614: LIST
10615: PPUSH
10616: CALL_OW 69
10620: IFFALSE 10804
10622: GO 10624
10624: DISABLE
10625: LD_INT 0
10627: PPUSH
10628: PPUSH
// begin while true do
10629: LD_INT 1
10631: IFFALSE 10688
// begin wait ( 0 0$1 ) ;
10633: LD_INT 35
10635: PPUSH
10636: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10640: LD_ADDR_VAR 0 2
10644: PUSH
10645: LD_INT 22
10647: PUSH
10648: LD_INT 1
10650: PUSH
10651: EMPTY
10652: LIST
10653: LIST
10654: PPUSH
10655: CALL_OW 69
10659: PPUSH
10660: LD_EXP 14
10664: PPUSH
10665: CALL_OW 74
10669: ST_TO_ADDR
// if See ( 7 , tmp ) then
10670: LD_INT 7
10672: PPUSH
10673: LD_VAR 0 2
10677: PPUSH
10678: CALL_OW 292
10682: IFFALSE 10686
// break ;
10684: GO 10688
// end ;
10686: GO 10629
// DialogueOn ;
10688: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10692: LD_VAR 0 2
10696: PPUSH
10697: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10701: LD_VAR 0 2
10705: PPUSH
10706: CALL_OW 250
10710: PPUSH
10711: LD_VAR 0 2
10715: PPUSH
10716: CALL_OW 251
10720: PPUSH
10721: LD_INT 7
10723: PPUSH
10724: LD_INT 8
10726: PPUSH
10727: CALL_OW 330
// if Denis then
10731: LD_EXP 20
10735: IFFALSE 10749
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10737: LD_EXP 20
10741: PPUSH
10742: LD_STRING DAmerAttack-Pet-1
10744: PPUSH
10745: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10749: LD_EXP 14
10753: PPUSH
10754: LD_STRING DAmerAttack-JMM-1
10756: PPUSH
10757: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10761: LD_EXP 45
10765: PPUSH
10766: LD_STRING DStop-Bur-1
10768: PPUSH
10769: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10773: LD_VAR 0 2
10777: PPUSH
10778: CALL_OW 250
10782: PPUSH
10783: LD_VAR 0 2
10787: PPUSH
10788: CALL_OW 251
10792: PPUSH
10793: LD_INT 7
10795: PPUSH
10796: CALL_OW 331
// DialogueOff ;
10800: CALL_OW 7
// end ;
10804: PPOPN 2
10806: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10807: LD_INT 22
10809: PUSH
10810: LD_INT 3
10812: PUSH
10813: EMPTY
10814: LIST
10815: LIST
10816: PUSH
10817: LD_INT 21
10819: PUSH
10820: LD_INT 1
10822: PUSH
10823: EMPTY
10824: LIST
10825: LIST
10826: PUSH
10827: EMPTY
10828: LIST
10829: LIST
10830: PPUSH
10831: CALL_OW 69
10835: PUSH
10836: LD_INT 0
10838: EQUAL
10839: IFFALSE 10881
10841: GO 10843
10843: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10844: LD_STRING M5a
10846: PPUSH
10847: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10851: LD_EXP 14
10855: PPUSH
10856: LD_STRING D8-JMM-1
10858: PPUSH
10859: CALL_OW 88
// if Gossudarov then
10863: LD_EXP 31
10867: IFFALSE 10881
// Say ( Gossudarov , D8-Gos-1 ) ;
10869: LD_EXP 31
10873: PPUSH
10874: LD_STRING D8-Gos-1
10876: PPUSH
10877: CALL_OW 88
// end ;
10881: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10882: LD_INT 22
10884: PUSH
10885: LD_INT 2
10887: PUSH
10888: EMPTY
10889: LIST
10890: LIST
10891: PUSH
10892: LD_INT 21
10894: PUSH
10895: LD_INT 1
10897: PUSH
10898: EMPTY
10899: LIST
10900: LIST
10901: PUSH
10902: EMPTY
10903: LIST
10904: LIST
10905: PPUSH
10906: CALL_OW 69
10910: PUSH
10911: LD_INT 0
10913: EQUAL
10914: IFFALSE 10964
10916: GO 10918
10918: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10919: LD_STRING M4c
10921: PPUSH
10922: CALL_OW 337
// if Roth then
10926: LD_EXP 15
10930: IFFALSE 10946
// Say ( Roth , DStop-Roth-1 ) else
10932: LD_EXP 15
10936: PPUSH
10937: LD_STRING DStop-Roth-1
10939: PPUSH
10940: CALL_OW 88
10944: GO 10964
// if Gossudarov then
10946: LD_EXP 31
10950: IFFALSE 10964
// Say ( Gossudarov , D8-Gos-1a ) ;
10952: LD_EXP 31
10956: PPUSH
10957: LD_STRING D8-Gos-1a
10959: PPUSH
10960: CALL_OW 88
// end ;
10964: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10965: LD_INT 7
10967: PPUSH
10968: LD_INT 1
10970: PPUSH
10971: LD_INT 1
10973: PPUSH
10974: CALL 14192 0 3
10978: PUSH
10979: LD_INT 0
10981: EQUAL
10982: PUSH
10983: LD_INT 7
10985: PPUSH
10986: LD_INT 3
10988: PPUSH
10989: LD_INT 1
10991: PPUSH
10992: CALL 14192 0 3
10996: PUSH
10997: LD_INT 0
10999: EQUAL
11000: AND
11001: IFFALSE 11013
11003: GO 11005
11005: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11006: LD_STRING M1a
11008: PPUSH
11009: CALL_OW 337
// end ;
11013: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11014: LD_INT 22
11016: PUSH
11017: LD_INT 2
11019: PUSH
11020: EMPTY
11021: LIST
11022: LIST
11023: PUSH
11024: LD_INT 21
11026: PUSH
11027: LD_INT 1
11029: PUSH
11030: EMPTY
11031: LIST
11032: LIST
11033: PUSH
11034: EMPTY
11035: LIST
11036: LIST
11037: PPUSH
11038: CALL_OW 69
11042: PUSH
11043: LD_INT 0
11045: EQUAL
11046: PUSH
11047: LD_INT 22
11049: PUSH
11050: LD_INT 3
11052: PUSH
11053: EMPTY
11054: LIST
11055: LIST
11056: PUSH
11057: LD_INT 21
11059: PUSH
11060: LD_INT 1
11062: PUSH
11063: EMPTY
11064: LIST
11065: LIST
11066: PUSH
11067: EMPTY
11068: LIST
11069: LIST
11070: PPUSH
11071: CALL_OW 69
11075: PUSH
11076: LD_INT 0
11078: EQUAL
11079: AND
11080: PUSH
11081: LD_INT 22
11083: PUSH
11084: LD_INT 1
11086: PUSH
11087: EMPTY
11088: LIST
11089: LIST
11090: PPUSH
11091: CALL_OW 69
11095: PUSH
11096: LD_INT 0
11098: EQUAL
11099: AND
11100: PUSH
11101: LD_INT 7
11103: PPUSH
11104: LD_INT 1
11106: PPUSH
11107: LD_INT 1
11109: PPUSH
11110: CALL 14192 0 3
11114: PUSH
11115: LD_INT 0
11117: EQUAL
11118: AND
11119: PUSH
11120: LD_INT 7
11122: PPUSH
11123: LD_INT 3
11125: PPUSH
11126: LD_INT 1
11128: PPUSH
11129: CALL 14192 0 3
11133: PUSH
11134: LD_INT 0
11136: EQUAL
11137: AND
11138: IFFALSE 12597
11140: GO 11142
11142: DISABLE
11143: LD_INT 0
11145: PPUSH
11146: PPUSH
11147: PPUSH
11148: PPUSH
11149: PPUSH
11150: PPUSH
// begin m1 := false ;
11151: LD_ADDR_VAR 0 4
11155: PUSH
11156: LD_INT 0
11158: ST_TO_ADDR
// m2 := false ;
11159: LD_ADDR_VAR 0 5
11163: PUSH
11164: LD_INT 0
11166: ST_TO_ADDR
// m3 := false ;
11167: LD_ADDR_VAR 0 6
11171: PUSH
11172: LD_INT 0
11174: ST_TO_ADDR
// wait ( 0 0$3 ) ;
11175: LD_INT 105
11177: PPUSH
11178: CALL_OW 67
// if not IsDead ( Masha ) then
11182: LD_EXP 48
11186: PPUSH
11187: CALL_OW 301
11191: NOT
11192: IFFALSE 11214
// begin m1 := true ;
11194: LD_ADDR_VAR 0 4
11198: PUSH
11199: LD_INT 1
11201: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11202: LD_STRING Masha
11204: PPUSH
11205: LD_INT 1
11207: PPUSH
11208: CALL_OW 101
// end else
11212: GO 11225
// AddMedal ( Masha , - 1 ) ;
11214: LD_STRING Masha
11216: PPUSH
11217: LD_INT 1
11219: NEG
11220: PPUSH
11221: CALL_OW 101
// if abdul_escaped then
11225: LD_EXP 12
11229: IFFALSE 11244
// AddMedal ( Abdul , - 1 ) else
11231: LD_STRING Abdul
11233: PPUSH
11234: LD_INT 1
11236: NEG
11237: PPUSH
11238: CALL_OW 101
11242: GO 11262
// begin m2 := true ;
11244: LD_ADDR_VAR 0 5
11248: PUSH
11249: LD_INT 1
11251: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11252: LD_STRING Abdul
11254: PPUSH
11255: LD_INT 1
11257: PPUSH
11258: CALL_OW 101
// end ; if loss_counter = 0 then
11262: LD_EXP 13
11266: PUSH
11267: LD_INT 0
11269: EQUAL
11270: IFFALSE 11292
// begin m3 := true ;
11272: LD_ADDR_VAR 0 6
11276: PUSH
11277: LD_INT 1
11279: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11280: LD_STRING People
11282: PPUSH
11283: LD_INT 2
11285: PPUSH
11286: CALL_OW 101
// end else
11290: GO 11350
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11292: LD_EXP 13
11296: PUSH
11297: LD_INT 3
11299: PUSH
11300: LD_INT 2
11302: PUSH
11303: LD_INT 2
11305: PUSH
11306: EMPTY
11307: LIST
11308: LIST
11309: LIST
11310: PUSH
11311: LD_OWVAR 67
11315: ARRAY
11316: LESSEQUAL
11317: IFFALSE 11339
// begin AddMedal ( People , 1 ) ;
11319: LD_STRING People
11321: PPUSH
11322: LD_INT 1
11324: PPUSH
11325: CALL_OW 101
// m3 := true ;
11329: LD_ADDR_VAR 0 6
11333: PUSH
11334: LD_INT 1
11336: ST_TO_ADDR
// end else
11337: GO 11350
// AddMedal ( People , - 1 ) ;
11339: LD_STRING People
11341: PPUSH
11342: LD_INT 1
11344: NEG
11345: PPUSH
11346: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11350: LD_OWVAR 67
11354: PUSH
11355: LD_INT 3
11357: EQUAL
11358: PUSH
11359: LD_VAR 0 4
11363: AND
11364: PUSH
11365: LD_VAR 0 5
11369: AND
11370: PUSH
11371: LD_VAR 0 6
11375: AND
11376: IFFALSE 11388
// SetAchievementEX ( ACH_AMER , 17 ) ;
11378: LD_STRING ACH_AMER
11380: PPUSH
11381: LD_INT 17
11383: PPUSH
11384: CALL_OW 564
// GiveMedals ( MAIN ) ;
11388: LD_STRING MAIN
11390: PPUSH
11391: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11395: LD_ADDR_VAR 0 2
11399: PUSH
11400: LD_INT 22
11402: PUSH
11403: LD_INT 7
11405: PUSH
11406: EMPTY
11407: LIST
11408: LIST
11409: PUSH
11410: LD_INT 2
11412: PUSH
11413: LD_INT 25
11415: PUSH
11416: LD_INT 1
11418: PUSH
11419: EMPTY
11420: LIST
11421: LIST
11422: PUSH
11423: LD_INT 25
11425: PUSH
11426: LD_INT 2
11428: PUSH
11429: EMPTY
11430: LIST
11431: LIST
11432: PUSH
11433: LD_INT 25
11435: PUSH
11436: LD_INT 3
11438: PUSH
11439: EMPTY
11440: LIST
11441: LIST
11442: PUSH
11443: LD_INT 25
11445: PUSH
11446: LD_INT 4
11448: PUSH
11449: EMPTY
11450: LIST
11451: LIST
11452: PUSH
11453: LD_INT 25
11455: PUSH
11456: LD_INT 5
11458: PUSH
11459: EMPTY
11460: LIST
11461: LIST
11462: PUSH
11463: LD_INT 25
11465: PUSH
11466: LD_INT 8
11468: PUSH
11469: EMPTY
11470: LIST
11471: LIST
11472: PUSH
11473: LD_INT 25
11475: PUSH
11476: LD_INT 9
11478: PUSH
11479: EMPTY
11480: LIST
11481: LIST
11482: PUSH
11483: EMPTY
11484: LIST
11485: LIST
11486: LIST
11487: LIST
11488: LIST
11489: LIST
11490: LIST
11491: LIST
11492: PUSH
11493: EMPTY
11494: LIST
11495: LIST
11496: PPUSH
11497: CALL_OW 69
11501: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11502: LD_VAR 0 2
11506: PPUSH
11507: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11511: LD_ADDR_VAR 0 3
11515: PUSH
11516: LD_EXP 14
11520: PUSH
11521: LD_EXP 15
11525: PUSH
11526: LD_EXP 16
11530: PUSH
11531: LD_EXP 17
11535: PUSH
11536: LD_EXP 18
11540: PUSH
11541: LD_EXP 19
11545: PUSH
11546: LD_EXP 20
11550: PUSH
11551: LD_EXP 21
11555: PUSH
11556: LD_EXP 22
11560: PUSH
11561: LD_EXP 23
11565: PUSH
11566: LD_EXP 24
11570: PUSH
11571: LD_EXP 25
11575: PUSH
11576: LD_EXP 26
11580: PUSH
11581: LD_EXP 27
11585: PUSH
11586: LD_EXP 28
11590: PUSH
11591: LD_EXP 29
11595: PUSH
11596: LD_EXP 30
11600: PUSH
11601: LD_EXP 31
11605: PUSH
11606: LD_EXP 32
11610: PUSH
11611: LD_EXP 33
11615: PUSH
11616: LD_EXP 35
11620: PUSH
11621: LD_EXP 36
11625: PUSH
11626: LD_EXP 37
11630: PUSH
11631: LD_EXP 38
11635: PUSH
11636: LD_EXP 39
11640: PUSH
11641: LD_EXP 40
11645: PUSH
11646: LD_EXP 41
11650: PUSH
11651: LD_EXP 42
11655: PUSH
11656: LD_EXP 43
11660: PUSH
11661: LD_EXP 44
11665: PUSH
11666: LD_EXP 45
11670: PUSH
11671: LD_EXP 46
11675: PUSH
11676: LD_EXP 47
11680: PUSH
11681: EMPTY
11682: LIST
11683: LIST
11684: LIST
11685: LIST
11686: LIST
11687: LIST
11688: LIST
11689: LIST
11690: LIST
11691: LIST
11692: LIST
11693: LIST
11694: LIST
11695: LIST
11696: LIST
11697: LIST
11698: LIST
11699: LIST
11700: LIST
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: LIST
11707: LIST
11708: LIST
11709: LIST
11710: LIST
11711: LIST
11712: LIST
11713: LIST
11714: LIST
11715: ST_TO_ADDR
// if tmp diff tmp2 then
11716: LD_VAR 0 2
11720: PUSH
11721: LD_VAR 0 3
11725: DIFF
11726: IFFALSE 11746
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11728: LD_VAR 0 2
11732: PUSH
11733: LD_VAR 0 3
11737: DIFF
11738: PPUSH
11739: LD_STRING 13a_others
11741: PPUSH
11742: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11746: LD_EXP 14
11750: PPUSH
11751: LD_STRING 13a_JMM
11753: PPUSH
11754: CALL_OW 38
// if Titov then
11758: LD_EXP 33
11762: IFFALSE 11776
// SaveCharacters ( Titov , 13a_Titov ) ;
11764: LD_EXP 33
11768: PPUSH
11769: LD_STRING 13a_Titov
11771: PPUSH
11772: CALL_OW 38
// if Dolgov then
11776: LD_EXP 35
11780: IFFALSE 11794
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11782: LD_EXP 35
11786: PPUSH
11787: LD_STRING 13a_Dolgov
11789: PPUSH
11790: CALL_OW 38
// if Petrosyan then
11794: LD_EXP 36
11798: IFFALSE 11812
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11800: LD_EXP 36
11804: PPUSH
11805: LD_STRING 13a_Petrosyan
11807: PPUSH
11808: CALL_OW 38
// if Scholtze then
11812: LD_EXP 37
11816: IFFALSE 11830
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11818: LD_EXP 37
11822: PPUSH
11823: LD_STRING 13a_Scholtze
11825: PPUSH
11826: CALL_OW 38
// if Oblukov then
11830: LD_EXP 38
11834: IFFALSE 11848
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11836: LD_EXP 38
11840: PPUSH
11841: LD_STRING 13a_Oblukov
11843: PPUSH
11844: CALL_OW 38
// if Kapitsova then
11848: LD_EXP 39
11852: IFFALSE 11866
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11854: LD_EXP 39
11858: PPUSH
11859: LD_STRING 13a_Kapitsova
11861: PPUSH
11862: CALL_OW 38
// if Lipshchin then
11866: LD_EXP 40
11870: IFFALSE 11884
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11872: LD_EXP 40
11876: PPUSH
11877: LD_STRING 13a_Lipshchin
11879: PPUSH
11880: CALL_OW 38
// if Petrovova then
11884: LD_EXP 41
11888: IFFALSE 11902
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11890: LD_EXP 41
11894: PPUSH
11895: LD_STRING 13a_Petrovova
11897: PPUSH
11898: CALL_OW 38
// if Kovalyuk then
11902: LD_EXP 42
11906: IFFALSE 11920
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11908: LD_EXP 42
11912: PPUSH
11913: LD_STRING 13a_Kovalyuk
11915: PPUSH
11916: CALL_OW 38
// if Kuzmov then
11920: LD_EXP 43
11924: IFFALSE 11938
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11926: LD_EXP 43
11930: PPUSH
11931: LD_STRING 13a_Kuzmov
11933: PPUSH
11934: CALL_OW 38
// if Karamazov then
11938: LD_EXP 44
11942: IFFALSE 11956
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11944: LD_EXP 44
11948: PPUSH
11949: LD_STRING 13a_Karamazov
11951: PPUSH
11952: CALL_OW 38
// if Burlak then
11956: LD_EXP 45
11960: IFFALSE 11974
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11962: LD_EXP 45
11966: PPUSH
11967: LD_STRING 13a_Burlak
11969: PPUSH
11970: CALL_OW 38
// if Belkov then
11974: LD_EXP 46
11978: IFFALSE 11992
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11980: LD_EXP 46
11984: PPUSH
11985: LD_STRING 13a_Belkov
11987: PPUSH
11988: CALL_OW 38
// if Gnyevko then
11992: LD_EXP 47
11996: IFFALSE 12010
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11998: LD_EXP 47
12002: PPUSH
12003: LD_STRING 13a_Gnyevko
12005: PPUSH
12006: CALL_OW 38
// if Lisa then
12010: LD_EXP 16
12014: IFFALSE 12028
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12016: LD_EXP 16
12020: PPUSH
12021: LD_STRING 13a_Lisa
12023: PPUSH
12024: CALL_OW 38
// if Donaldson then
12028: LD_EXP 17
12032: IFFALSE 12046
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12034: LD_EXP 17
12038: PPUSH
12039: LD_STRING 13a_Donaldson
12041: PPUSH
12042: CALL_OW 38
// if Bobby then
12046: LD_EXP 18
12050: IFFALSE 12064
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12052: LD_EXP 18
12056: PPUSH
12057: LD_STRING 13a_Bobby
12059: PPUSH
12060: CALL_OW 38
// if Cyrus then
12064: LD_EXP 19
12068: IFFALSE 12082
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12070: LD_EXP 19
12074: PPUSH
12075: LD_STRING 13a_Cyrus
12077: PPUSH
12078: CALL_OW 38
// if Denis then
12082: LD_EXP 20
12086: IFFALSE 12100
// SaveCharacters ( Denis , 13a_Denis ) ;
12088: LD_EXP 20
12092: PPUSH
12093: LD_STRING 13a_Denis
12095: PPUSH
12096: CALL_OW 38
// if Brown then
12100: LD_EXP 21
12104: IFFALSE 12118
// SaveCharacters ( Brown , 13a_Brown ) ;
12106: LD_EXP 21
12110: PPUSH
12111: LD_STRING 13a_Brown
12113: PPUSH
12114: CALL_OW 38
// if Gladstone then
12118: LD_EXP 22
12122: IFFALSE 12136
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12124: LD_EXP 22
12128: PPUSH
12129: LD_STRING 13a_Gladstone
12131: PPUSH
12132: CALL_OW 38
// if Houten then
12136: LD_EXP 23
12140: IFFALSE 12154
// SaveCharacters ( Houten , 13a_Houten ) ;
12142: LD_EXP 23
12146: PPUSH
12147: LD_STRING 13a_Houten
12149: PPUSH
12150: CALL_OW 38
// if Cornel then
12154: LD_EXP 24
12158: IFFALSE 12172
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12160: LD_EXP 24
12164: PPUSH
12165: LD_STRING 13a_Cornel
12167: PPUSH
12168: CALL_OW 38
// if Gary then
12172: LD_EXP 25
12176: IFFALSE 12190
// SaveCharacters ( Gary , 13a_Gary ) ;
12178: LD_EXP 25
12182: PPUSH
12183: LD_STRING 13a_Gary
12185: PPUSH
12186: CALL_OW 38
// if Frank then
12190: LD_EXP 26
12194: IFFALSE 12208
// SaveCharacters ( Frank , 13a_Frank ) ;
12196: LD_EXP 26
12200: PPUSH
12201: LD_STRING 13a_Frank
12203: PPUSH
12204: CALL_OW 38
// if Kikuchi then
12208: LD_EXP 27
12212: IFFALSE 12226
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12214: LD_EXP 27
12218: PPUSH
12219: LD_STRING 13a_Kikuchi
12221: PPUSH
12222: CALL_OW 38
// if Simms then
12226: LD_EXP 28
12230: IFFALSE 12244
// SaveCharacters ( Simms , 13a_Simms ) ;
12232: LD_EXP 28
12236: PPUSH
12237: LD_STRING 13a_Simms
12239: PPUSH
12240: CALL_OW 38
// if Joan then
12244: LD_EXP 29
12248: IFFALSE 12262
// SaveCharacters ( Joan , 13a_Joan ) ;
12250: LD_EXP 29
12254: PPUSH
12255: LD_STRING 13a_Joan
12257: PPUSH
12258: CALL_OW 38
// if DeltaDoctor then
12262: LD_EXP 30
12266: IFFALSE 12280
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12268: LD_EXP 30
12272: PPUSH
12273: LD_STRING 13a_DeltaDoctor
12275: PPUSH
12276: CALL_OW 38
// if Gossudarov then
12280: LD_EXP 31
12284: IFFALSE 12298
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12286: LD_EXP 31
12290: PPUSH
12291: LD_STRING 13a_Gossudarov
12293: PPUSH
12294: CALL_OW 38
// if Kirilenkova then
12298: LD_EXP 32
12302: IFFALSE 12316
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12304: LD_EXP 32
12308: PPUSH
12309: LD_STRING 13a_Kirilenkova
12311: PPUSH
12312: CALL_OW 38
// if Roth then
12316: LD_EXP 15
12320: IFFALSE 12334
// SaveCharacters ( Roth , 13a_Roth ) ;
12322: LD_EXP 15
12326: PPUSH
12327: LD_STRING 13a_Roth
12329: PPUSH
12330: CALL_OW 38
// if Masha then
12334: LD_EXP 48
12338: IFFALSE 12393
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12340: LD_EXP 48
12344: PPUSH
12345: CALL_OW 265
12349: PUSH
12350: LD_EXP 48
12354: PPUSH
12355: CALL_OW 262
12359: PUSH
12360: LD_EXP 48
12364: PPUSH
12365: CALL_OW 263
12369: PUSH
12370: LD_EXP 48
12374: PPUSH
12375: CALL_OW 264
12379: PUSH
12380: EMPTY
12381: LIST
12382: LIST
12383: LIST
12384: LIST
12385: PPUSH
12386: LD_STRING 13a_Masha
12388: PPUSH
12389: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12393: LD_ADDR_VAR 0 2
12397: PUSH
12398: LD_INT 21
12400: PUSH
12401: LD_INT 3
12403: PUSH
12404: EMPTY
12405: LIST
12406: LIST
12407: PPUSH
12408: CALL_OW 69
12412: ST_TO_ADDR
// tmp2 := [ ] ;
12413: LD_ADDR_VAR 0 3
12417: PUSH
12418: EMPTY
12419: ST_TO_ADDR
// if tmp then
12420: LD_VAR 0 2
12424: IFFALSE 12575
// for i in tmp do
12426: LD_ADDR_VAR 0 1
12430: PUSH
12431: LD_VAR 0 2
12435: PUSH
12436: FOR_IN
12437: IFFALSE 12573
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12439: LD_ADDR_VAR 0 3
12443: PUSH
12444: LD_VAR 0 3
12448: PUSH
12449: LD_VAR 0 1
12453: PPUSH
12454: CALL_OW 255
12458: PUSH
12459: LD_VAR 0 1
12463: PPUSH
12464: CALL_OW 248
12468: PUSH
12469: LD_VAR 0 1
12473: PPUSH
12474: CALL_OW 266
12478: PUSH
12479: LD_VAR 0 1
12483: PPUSH
12484: CALL_OW 250
12488: PUSH
12489: LD_VAR 0 1
12493: PPUSH
12494: CALL_OW 251
12498: PUSH
12499: LD_VAR 0 1
12503: PPUSH
12504: CALL_OW 254
12508: PUSH
12509: LD_VAR 0 1
12513: PPUSH
12514: CALL_OW 267
12518: PUSH
12519: LD_VAR 0 1
12523: PPUSH
12524: LD_INT 1
12526: PPUSH
12527: CALL_OW 268
12531: PUSH
12532: LD_VAR 0 1
12536: PPUSH
12537: LD_INT 2
12539: PPUSH
12540: CALL_OW 268
12544: PUSH
12545: LD_VAR 0 1
12549: PPUSH
12550: CALL_OW 269
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: LIST
12559: LIST
12560: LIST
12561: LIST
12562: LIST
12563: LIST
12564: LIST
12565: LIST
12566: PUSH
12567: EMPTY
12568: LIST
12569: ADD
12570: ST_TO_ADDR
12571: GO 12436
12573: POP
12574: POP
// if tmp2 then
12575: LD_VAR 0 3
12579: IFFALSE 12593
// SaveVariable ( tmp2 , 13a_buildings ) ;
12581: LD_VAR 0 3
12585: PPUSH
12586: LD_STRING 13a_buildings
12588: PPUSH
12589: CALL_OW 39
// YouWin ;
12593: CALL_OW 103
// end ;
12597: PPOPN 6
12599: END
// export function SciRu ; var tmp , t ; begin
12600: LD_INT 0
12602: PPUSH
12603: PPUSH
12604: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12605: LD_ADDR_VAR 0 3
12609: PUSH
12610: LD_EXP 31
12614: PUSH
12615: LD_EXP 45
12619: PUSH
12620: LD_EXP 33
12624: PUSH
12625: LD_EXP 46
12629: PUSH
12630: LD_EXP 47
12634: PUSH
12635: LD_EXP 36
12639: PUSH
12640: LD_EXP 37
12644: PUSH
12645: LD_EXP 35
12649: PUSH
12650: EMPTY
12651: LIST
12652: LIST
12653: LIST
12654: LIST
12655: LIST
12656: LIST
12657: LIST
12658: LIST
12659: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12660: LD_ADDR_VAR 0 2
12664: PUSH
12665: LD_INT 22
12667: PUSH
12668: LD_INT 7
12670: PUSH
12671: EMPTY
12672: LIST
12673: LIST
12674: PUSH
12675: LD_INT 23
12677: PUSH
12678: LD_INT 3
12680: PUSH
12681: EMPTY
12682: LIST
12683: LIST
12684: PUSH
12685: LD_INT 25
12687: PUSH
12688: LD_INT 4
12690: PUSH
12691: EMPTY
12692: LIST
12693: LIST
12694: PUSH
12695: LD_INT 26
12697: PUSH
12698: LD_INT 1
12700: PUSH
12701: EMPTY
12702: LIST
12703: LIST
12704: PUSH
12705: EMPTY
12706: LIST
12707: LIST
12708: LIST
12709: LIST
12710: PPUSH
12711: CALL_OW 69
12715: PUSH
12716: LD_VAR 0 3
12720: DIFF
12721: ST_TO_ADDR
// if tmp then
12722: LD_VAR 0 2
12726: IFFALSE 12742
// result := tmp [ 1 ] ;
12728: LD_ADDR_VAR 0 1
12732: PUSH
12733: LD_VAR 0 2
12737: PUSH
12738: LD_INT 1
12740: ARRAY
12741: ST_TO_ADDR
// end ;
12742: LD_VAR 0 1
12746: RET
// export function SolRu ; var tmp , t ; begin
12747: LD_INT 0
12749: PPUSH
12750: PPUSH
12751: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12752: LD_ADDR_VAR 0 3
12756: PUSH
12757: LD_EXP 31
12761: PUSH
12762: LD_EXP 45
12766: PUSH
12767: LD_EXP 33
12771: PUSH
12772: LD_EXP 46
12776: PUSH
12777: LD_EXP 47
12781: PUSH
12782: LD_EXP 36
12786: PUSH
12787: LD_EXP 37
12791: PUSH
12792: LD_EXP 35
12796: PUSH
12797: EMPTY
12798: LIST
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: LIST
12804: LIST
12805: LIST
12806: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12807: LD_ADDR_VAR 0 2
12811: PUSH
12812: LD_INT 22
12814: PUSH
12815: LD_INT 7
12817: PUSH
12818: EMPTY
12819: LIST
12820: LIST
12821: PUSH
12822: LD_INT 23
12824: PUSH
12825: LD_INT 3
12827: PUSH
12828: EMPTY
12829: LIST
12830: LIST
12831: PUSH
12832: LD_INT 25
12834: PUSH
12835: LD_INT 1
12837: PUSH
12838: EMPTY
12839: LIST
12840: LIST
12841: PUSH
12842: LD_INT 26
12844: PUSH
12845: LD_INT 1
12847: PUSH
12848: EMPTY
12849: LIST
12850: LIST
12851: PUSH
12852: EMPTY
12853: LIST
12854: LIST
12855: LIST
12856: LIST
12857: PPUSH
12858: CALL_OW 69
12862: PUSH
12863: LD_VAR 0 3
12867: DIFF
12868: ST_TO_ADDR
// if tmp then
12869: LD_VAR 0 2
12873: IFFALSE 12889
// result := tmp [ 1 ] ;
12875: LD_ADDR_VAR 0 1
12879: PUSH
12880: LD_VAR 0 2
12884: PUSH
12885: LD_INT 1
12887: ARRAY
12888: ST_TO_ADDR
// end ; end_of_file
12889: LD_VAR 0 1
12893: RET
// export function CustomEvent ( event ) ; begin
12894: LD_INT 0
12896: PPUSH
// end ;
12897: LD_VAR 0 2
12901: RET
// on UnitDestroyed ( un ) do var i , side ;
12902: LD_INT 0
12904: PPUSH
12905: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12906: LD_VAR 0 1
12910: PUSH
12911: LD_INT 22
12913: PUSH
12914: LD_INT 7
12916: PUSH
12917: EMPTY
12918: LIST
12919: LIST
12920: PUSH
12921: LD_INT 2
12923: PUSH
12924: LD_INT 25
12926: PUSH
12927: LD_INT 1
12929: PUSH
12930: EMPTY
12931: LIST
12932: LIST
12933: PUSH
12934: LD_INT 25
12936: PUSH
12937: LD_INT 2
12939: PUSH
12940: EMPTY
12941: LIST
12942: LIST
12943: PUSH
12944: LD_INT 25
12946: PUSH
12947: LD_INT 3
12949: PUSH
12950: EMPTY
12951: LIST
12952: LIST
12953: PUSH
12954: LD_INT 25
12956: PUSH
12957: LD_INT 4
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: PUSH
12964: LD_INT 25
12966: PUSH
12967: LD_INT 5
12969: PUSH
12970: EMPTY
12971: LIST
12972: LIST
12973: PUSH
12974: LD_INT 25
12976: PUSH
12977: LD_INT 8
12979: PUSH
12980: EMPTY
12981: LIST
12982: LIST
12983: PUSH
12984: LD_INT 25
12986: PUSH
12987: LD_INT 9
12989: PUSH
12990: EMPTY
12991: LIST
12992: LIST
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: LIST
12998: LIST
12999: LIST
13000: LIST
13001: LIST
13002: LIST
13003: PUSH
13004: EMPTY
13005: LIST
13006: LIST
13007: PPUSH
13008: CALL_OW 69
13012: IN
13013: IFFALSE 13029
// loss_counter := loss_counter + 1 ;
13015: LD_ADDR_EXP 13
13019: PUSH
13020: LD_EXP 13
13024: PUSH
13025: LD_INT 1
13027: PLUS
13028: ST_TO_ADDR
// if un = Abdul then
13029: LD_VAR 0 1
13033: PUSH
13034: LD_EXP 54
13038: EQUAL
13039: IFFALSE 13049
// abdul_escaped := false ;
13041: LD_ADDR_EXP 12
13045: PUSH
13046: LD_INT 0
13048: ST_TO_ADDR
// if un in ru_attackers then
13049: LD_VAR 0 1
13053: PUSH
13054: LD_EXP 51
13058: IN
13059: IFFALSE 13077
// ru_attackers := ru_attackers diff un ;
13061: LD_ADDR_EXP 51
13065: PUSH
13066: LD_EXP 51
13070: PUSH
13071: LD_VAR 0 1
13075: DIFF
13076: ST_TO_ADDR
// if un in ar_attackers then
13077: LD_VAR 0 1
13081: PUSH
13082: LD_EXP 10
13086: IN
13087: IFFALSE 13105
// ar_attackers := ar_attackers diff un ;
13089: LD_ADDR_EXP 10
13093: PUSH
13094: LD_EXP 10
13098: PUSH
13099: LD_VAR 0 1
13103: DIFF
13104: ST_TO_ADDR
// if un = JMM then
13105: LD_VAR 0 1
13109: PUSH
13110: LD_EXP 14
13114: EQUAL
13115: IFFALSE 13126
// begin YouLost ( JMM ) ;
13117: LD_STRING JMM
13119: PPUSH
13120: CALL_OW 104
// exit ;
13124: GO 13215
// end ; if un = Burlak then
13126: LD_VAR 0 1
13130: PUSH
13131: LD_EXP 45
13135: EQUAL
13136: IFFALSE 13147
// begin YouLost ( Burlak ) ;
13138: LD_STRING Burlak
13140: PPUSH
13141: CALL_OW 104
// exit ;
13145: GO 13215
// end ; if un = freedom then
13147: LD_VAR 0 1
13151: PUSH
13152: LD_EXP 3
13156: EQUAL
13157: IFFALSE 13168
// begin YouLost ( Destroyed ) ;
13159: LD_STRING Destroyed
13161: PPUSH
13162: CALL_OW 104
// exit ;
13166: GO 13215
// end ; if un = Masha then
13168: LD_VAR 0 1
13172: PUSH
13173: LD_EXP 48
13177: EQUAL
13178: IFFALSE 13187
// ChangeMissionObjectives ( M4b ) ;
13180: LD_STRING M4b
13182: PPUSH
13183: CALL_OW 337
// if un = Mastodont then
13187: LD_VAR 0 1
13191: PUSH
13192: LD_EXP 55
13196: EQUAL
13197: IFFALSE 13206
// ChangeMissionObjectives ( M4a ) ;
13199: LD_STRING M4a
13201: PPUSH
13202: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13206: LD_VAR 0 1
13210: PPUSH
13211: CALL 84482 0 1
// end ;
13215: PPOPN 3
13217: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13218: LD_VAR 0 1
13222: PPUSH
13223: LD_VAR 0 2
13227: PPUSH
13228: CALL 86816 0 2
// end ;
13232: PPOPN 2
13234: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13235: LD_VAR 0 1
13239: PPUSH
13240: CALL 85884 0 1
// end ;
13244: PPOPN 1
13246: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13247: LD_VAR 0 1
13251: PUSH
13252: LD_INT 22
13254: PUSH
13255: LD_INT 7
13257: PUSH
13258: EMPTY
13259: LIST
13260: LIST
13261: PUSH
13262: LD_INT 30
13264: PUSH
13265: LD_INT 0
13267: PUSH
13268: EMPTY
13269: LIST
13270: LIST
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: PPUSH
13276: CALL_OW 69
13280: IN
13281: IFFALSE 13320
// begin SetBName ( building , freedom ) ;
13283: LD_VAR 0 1
13287: PPUSH
13288: LD_STRING freedom
13290: PPUSH
13291: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13295: LD_INT 0
13297: PPUSH
13298: LD_INT 7
13300: PPUSH
13301: LD_INT 0
13303: PPUSH
13304: CALL_OW 324
// freedom := building ;
13308: LD_ADDR_EXP 3
13312: PUSH
13313: LD_VAR 0 1
13317: ST_TO_ADDR
// exit ;
13318: GO 13386
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13320: LD_VAR 0 1
13324: PUSH
13325: LD_INT 22
13327: PUSH
13328: LD_INT 7
13330: PUSH
13331: EMPTY
13332: LIST
13333: LIST
13334: PUSH
13335: LD_INT 23
13337: PUSH
13338: LD_INT 3
13340: PUSH
13341: EMPTY
13342: LIST
13343: LIST
13344: PUSH
13345: LD_INT 30
13347: PUSH
13348: LD_INT 6
13350: PUSH
13351: EMPTY
13352: LIST
13353: LIST
13354: PUSH
13355: EMPTY
13356: LIST
13357: LIST
13358: LIST
13359: PPUSH
13360: CALL_OW 69
13364: IN
13365: IFFALSE 13377
// begin ru_lab_builded := true ;
13367: LD_ADDR_EXP 5
13371: PUSH
13372: LD_INT 1
13374: ST_TO_ADDR
// exit ;
13375: GO 13386
// end ; MCE_BuildingComplete ( building ) ;
13377: LD_VAR 0 1
13381: PPUSH
13382: CALL 86125 0 1
// end ;
13386: PPOPN 1
13388: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13389: LD_VAR 0 1
13393: PPUSH
13394: LD_VAR 0 2
13398: PPUSH
13399: CALL 84178 0 2
// end ;
13403: PPOPN 2
13405: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13406: LD_VAR 0 1
13410: PPUSH
13411: LD_VAR 0 2
13415: PPUSH
13416: LD_VAR 0 3
13420: PPUSH
13421: LD_VAR 0 4
13425: PPUSH
13426: LD_VAR 0 5
13430: PPUSH
13431: CALL 83798 0 5
// end ;
13435: PPOPN 5
13437: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13438: LD_VAR 0 1
13442: PPUSH
13443: LD_VAR 0 2
13447: PPUSH
13448: CALL 83394 0 2
// end ;
13452: PPOPN 2
13454: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13455: LD_VAR 0 1
13459: PPUSH
13460: LD_VAR 0 2
13464: PPUSH
13465: LD_VAR 0 3
13469: PPUSH
13470: LD_VAR 0 4
13474: PPUSH
13475: CALL 83232 0 4
// end ;
13479: PPOPN 4
13481: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13482: LD_VAR 0 1
13486: PPUSH
13487: LD_VAR 0 2
13491: PPUSH
13492: LD_VAR 0 3
13496: PPUSH
13497: CALL 83007 0 3
// end ;
13501: PPOPN 3
13503: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13504: LD_VAR 0 1
13508: PPUSH
13509: LD_VAR 0 2
13513: PPUSH
13514: CALL 82892 0 2
// end ;
13518: PPOPN 2
13520: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13521: LD_VAR 0 1
13525: PPUSH
13526: LD_VAR 0 2
13530: PPUSH
13531: CALL 87077 0 2
// end ;
13535: PPOPN 2
13537: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13538: LD_VAR 0 1
13542: PPUSH
13543: LD_VAR 0 2
13547: PPUSH
13548: LD_VAR 0 3
13552: PPUSH
13553: LD_VAR 0 4
13557: PPUSH
13558: CALL 87293 0 4
// end ;
13562: PPOPN 4
13564: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13565: LD_VAR 0 1
13569: PPUSH
13570: LD_VAR 0 2
13574: PPUSH
13575: CALL 82701 0 2
// end ;
13579: PPOPN 2
13581: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13582: LD_VAR 0 1
13586: PPUSH
13587: CALL 87576 0 1
// end ; end_of_file
13591: PPOPN 1
13593: END
// every 0 0$30 do var cr , time ;
13594: GO 13596
13596: DISABLE
13597: LD_INT 0
13599: PPUSH
13600: PPUSH
// begin time := 0 0$30 ;
13601: LD_ADDR_VAR 0 2
13605: PUSH
13606: LD_INT 1050
13608: ST_TO_ADDR
// while game do
13609: LD_EXP 2
13613: IFFALSE 13712
// begin wait ( time ) ;
13615: LD_VAR 0 2
13619: PPUSH
13620: CALL_OW 67
// if tick > 2 2$00 then
13624: LD_OWVAR 1
13628: PUSH
13629: LD_INT 4200
13631: GREATER
13632: IFFALSE 13665
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13634: LD_ADDR_VAR 0 2
13638: PUSH
13639: LD_VAR 0 2
13643: PUSH
13644: LD_INT 280
13646: PUSH
13647: LD_INT 420
13649: PUSH
13650: LD_INT 630
13652: PUSH
13653: EMPTY
13654: LIST
13655: LIST
13656: LIST
13657: PUSH
13658: LD_OWVAR 67
13662: ARRAY
13663: PLUS
13664: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13665: LD_INT 1
13667: PPUSH
13668: LD_INT 5
13670: PPUSH
13671: CALL_OW 12
13675: PPUSH
13676: LD_INT 70
13678: PPUSH
13679: LD_INT 49
13681: PPUSH
13682: LD_INT 25
13684: PPUSH
13685: LD_INT 1
13687: PPUSH
13688: CALL_OW 56
// if time > 5 5$00 then
13692: LD_VAR 0 2
13696: PUSH
13697: LD_INT 10500
13699: GREATER
13700: IFFALSE 13710
// time := 0 0$30 ;
13702: LD_ADDR_VAR 0 2
13706: PUSH
13707: LD_INT 1050
13709: ST_TO_ADDR
// end ;
13710: GO 13609
// end ;
13712: PPOPN 2
13714: END
// every 0 0$30 do var cr , time ;
13715: GO 13717
13717: DISABLE
13718: LD_INT 0
13720: PPUSH
13721: PPUSH
// begin time := 0 0$20 ;
13722: LD_ADDR_VAR 0 2
13726: PUSH
13727: LD_INT 700
13729: ST_TO_ADDR
// while game do
13730: LD_EXP 2
13734: IFFALSE 13823
// begin wait ( time ) ;
13736: LD_VAR 0 2
13740: PPUSH
13741: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13745: LD_ADDR_VAR 0 2
13749: PUSH
13750: LD_VAR 0 2
13754: PUSH
13755: LD_INT 490
13757: PUSH
13758: LD_INT 525
13760: PUSH
13761: LD_INT 560
13763: PUSH
13764: EMPTY
13765: LIST
13766: LIST
13767: LIST
13768: PUSH
13769: LD_OWVAR 67
13773: ARRAY
13774: PLUS
13775: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13776: LD_INT 3
13778: PPUSH
13779: LD_INT 5
13781: PPUSH
13782: CALL_OW 12
13786: PPUSH
13787: LD_INT 26
13789: PPUSH
13790: LD_INT 9
13792: PPUSH
13793: LD_INT 30
13795: PPUSH
13796: LD_INT 1
13798: PPUSH
13799: CALL_OW 56
// if time > 3 3$00 then
13803: LD_VAR 0 2
13807: PUSH
13808: LD_INT 6300
13810: GREATER
13811: IFFALSE 13821
// time := 0 0$20 ;
13813: LD_ADDR_VAR 0 2
13817: PUSH
13818: LD_INT 700
13820: ST_TO_ADDR
// end ;
13821: GO 13730
// end ;
13823: PPOPN 2
13825: END
// every 0 0$30 do var cr , time ;
13826: GO 13828
13828: DISABLE
13829: LD_INT 0
13831: PPUSH
13832: PPUSH
// begin time := 0 0$20 ;
13833: LD_ADDR_VAR 0 2
13837: PUSH
13838: LD_INT 700
13840: ST_TO_ADDR
// while game do
13841: LD_EXP 2
13845: IFFALSE 13970
// begin wait ( time ) ;
13847: LD_VAR 0 2
13851: PPUSH
13852: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13856: LD_ADDR_VAR 0 2
13860: PUSH
13861: LD_VAR 0 2
13865: PUSH
13866: LD_INT 175
13868: PUSH
13869: LD_INT 210
13871: PUSH
13872: LD_INT 280
13874: PUSH
13875: EMPTY
13876: LIST
13877: LIST
13878: LIST
13879: PUSH
13880: LD_OWVAR 67
13884: ARRAY
13885: PLUS
13886: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13887: LD_INT 1
13889: PPUSH
13890: LD_INT 5
13892: PPUSH
13893: CALL_OW 12
13897: PPUSH
13898: LD_INT 179
13900: PPUSH
13901: LD_INT 101
13903: PPUSH
13904: LD_INT 20
13906: PPUSH
13907: LD_INT 1
13909: PPUSH
13910: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13914: LD_INT 350
13916: PPUSH
13917: LD_INT 525
13919: PPUSH
13920: CALL_OW 12
13924: PPUSH
13925: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13929: LD_INT 1
13931: PPUSH
13932: LD_INT 5
13934: PPUSH
13935: CALL_OW 12
13939: PPUSH
13940: LD_INT 9
13942: PPUSH
13943: LD_INT 1
13945: PPUSH
13946: CALL_OW 55
// if time > 4 4$00 then
13950: LD_VAR 0 2
13954: PUSH
13955: LD_INT 8400
13957: GREATER
13958: IFFALSE 13968
// time := 0 0$30 ;
13960: LD_ADDR_VAR 0 2
13964: PUSH
13965: LD_INT 1050
13967: ST_TO_ADDR
// end ;
13968: GO 13841
// end ;
13970: PPOPN 2
13972: END
// every 0 0$30 do var cr , time ;
13973: GO 13975
13975: DISABLE
13976: LD_INT 0
13978: PPUSH
13979: PPUSH
// begin time := 0 0$10 ;
13980: LD_ADDR_VAR 0 2
13984: PUSH
13985: LD_INT 350
13987: ST_TO_ADDR
// while game do
13988: LD_EXP 2
13992: IFFALSE 14126
// begin wait ( time ) ;
13994: LD_VAR 0 2
13998: PPUSH
13999: CALL_OW 67
// time := time + 0 0$10 ;
14003: LD_ADDR_VAR 0 2
14007: PUSH
14008: LD_VAR 0 2
14012: PUSH
14013: LD_INT 350
14015: PLUS
14016: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14017: LD_INT 1
14019: PPUSH
14020: LD_INT 5
14022: PPUSH
14023: CALL_OW 12
14027: PPUSH
14028: LD_INT 11
14030: PPUSH
14031: LD_INT 1
14033: PPUSH
14034: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14038: LD_ADDR_VAR 0 1
14042: PUSH
14043: LD_INT 1
14045: PPUSH
14046: LD_INT 3
14048: PPUSH
14049: CALL_OW 12
14053: ST_TO_ADDR
// if cr = 1 then
14054: LD_VAR 0 1
14058: PUSH
14059: LD_INT 1
14061: EQUAL
14062: IFFALSE 14106
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14064: LD_INT 700
14066: PPUSH
14067: LD_INT 1575
14069: PPUSH
14070: CALL_OW 12
14074: PPUSH
14075: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14079: LD_INT 1
14081: PPUSH
14082: LD_INT 5
14084: PPUSH
14085: CALL_OW 12
14089: PPUSH
14090: LD_INT 34
14092: PPUSH
14093: LD_INT 50
14095: PPUSH
14096: LD_INT 7
14098: PPUSH
14099: LD_INT 1
14101: PPUSH
14102: CALL_OW 56
// end ; if time > 8 8$00 then
14106: LD_VAR 0 2
14110: PUSH
14111: LD_INT 16800
14113: GREATER
14114: IFFALSE 14124
// time := 0 0$40 ;
14116: LD_ADDR_VAR 0 2
14120: PUSH
14121: LD_INT 1400
14123: ST_TO_ADDR
// end ;
14124: GO 13988
// end ; end_of_file
14126: PPOPN 2
14128: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14129: LD_INT 0
14131: PPUSH
14132: PPUSH
// if exist_mode then
14133: LD_VAR 0 2
14137: IFFALSE 14162
// unit := CreateCharacter ( prefix & ident ) else
14139: LD_ADDR_VAR 0 5
14143: PUSH
14144: LD_VAR 0 3
14148: PUSH
14149: LD_VAR 0 1
14153: STR
14154: PPUSH
14155: CALL_OW 34
14159: ST_TO_ADDR
14160: GO 14177
// unit := NewCharacter ( ident ) ;
14162: LD_ADDR_VAR 0 5
14166: PUSH
14167: LD_VAR 0 1
14171: PPUSH
14172: CALL_OW 25
14176: ST_TO_ADDR
// result := unit ;
14177: LD_ADDR_VAR 0 4
14181: PUSH
14182: LD_VAR 0 5
14186: ST_TO_ADDR
// end ;
14187: LD_VAR 0 4
14191: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14192: LD_INT 0
14194: PPUSH
14195: PPUSH
// if not side or not nation then
14196: LD_VAR 0 1
14200: NOT
14201: PUSH
14202: LD_VAR 0 2
14206: NOT
14207: OR
14208: IFFALSE 14212
// exit ;
14210: GO 14856
// case nation of nation_american :
14212: LD_VAR 0 2
14216: PUSH
14217: LD_INT 1
14219: DOUBLE
14220: EQUAL
14221: IFTRUE 14225
14223: GO 14399
14225: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
14226: LD_ADDR_VAR 0 4
14230: PUSH
14231: LD_INT 35
14233: PUSH
14234: LD_INT 45
14236: PUSH
14237: LD_INT 46
14239: PUSH
14240: LD_INT 47
14242: PUSH
14243: LD_INT 1
14245: PUSH
14246: LD_INT 2
14248: PUSH
14249: LD_INT 6
14251: PUSH
14252: LD_INT 15
14254: PUSH
14255: LD_INT 16
14257: PUSH
14258: LD_INT 7
14260: PUSH
14261: LD_INT 12
14263: PUSH
14264: LD_INT 13
14266: PUSH
14267: LD_INT 10
14269: PUSH
14270: LD_INT 14
14272: PUSH
14273: LD_INT 20
14275: PUSH
14276: LD_INT 21
14278: PUSH
14279: LD_INT 22
14281: PUSH
14282: LD_INT 25
14284: PUSH
14285: LD_INT 32
14287: PUSH
14288: LD_INT 27
14290: PUSH
14291: LD_INT 36
14293: PUSH
14294: LD_INT 69
14296: PUSH
14297: LD_INT 39
14299: PUSH
14300: LD_INT 34
14302: PUSH
14303: LD_INT 40
14305: PUSH
14306: LD_INT 48
14308: PUSH
14309: LD_INT 49
14311: PUSH
14312: LD_INT 50
14314: PUSH
14315: LD_INT 51
14317: PUSH
14318: LD_INT 52
14320: PUSH
14321: LD_INT 53
14323: PUSH
14324: LD_INT 54
14326: PUSH
14327: LD_INT 55
14329: PUSH
14330: LD_INT 56
14332: PUSH
14333: LD_INT 57
14335: PUSH
14336: LD_INT 58
14338: PUSH
14339: LD_INT 59
14341: PUSH
14342: LD_INT 60
14344: PUSH
14345: LD_INT 61
14347: PUSH
14348: LD_INT 62
14350: PUSH
14351: LD_INT 80
14353: PUSH
14354: EMPTY
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: LIST
14371: LIST
14372: LIST
14373: LIST
14374: LIST
14375: LIST
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: LIST
14382: LIST
14383: LIST
14384: LIST
14385: LIST
14386: LIST
14387: LIST
14388: LIST
14389: LIST
14390: LIST
14391: LIST
14392: LIST
14393: LIST
14394: LIST
14395: LIST
14396: ST_TO_ADDR
14397: GO 14780
14399: LD_INT 2
14401: DOUBLE
14402: EQUAL
14403: IFTRUE 14407
14405: GO 14589
14407: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
14408: LD_ADDR_VAR 0 4
14412: PUSH
14413: LD_INT 35
14415: PUSH
14416: LD_INT 45
14418: PUSH
14419: LD_INT 46
14421: PUSH
14422: LD_INT 47
14424: PUSH
14425: LD_INT 70
14427: PUSH
14428: LD_INT 1
14430: PUSH
14431: LD_INT 11
14433: PUSH
14434: LD_INT 3
14436: PUSH
14437: LD_INT 4
14439: PUSH
14440: LD_INT 5
14442: PUSH
14443: LD_INT 6
14445: PUSH
14446: LD_INT 15
14448: PUSH
14449: LD_INT 18
14451: PUSH
14452: LD_INT 7
14454: PUSH
14455: LD_INT 17
14457: PUSH
14458: LD_INT 8
14460: PUSH
14461: LD_INT 20
14463: PUSH
14464: LD_INT 21
14466: PUSH
14467: LD_INT 22
14469: PUSH
14470: LD_INT 72
14472: PUSH
14473: LD_INT 26
14475: PUSH
14476: LD_INT 69
14478: PUSH
14479: LD_INT 39
14481: PUSH
14482: LD_INT 40
14484: PUSH
14485: LD_INT 41
14487: PUSH
14488: LD_INT 42
14490: PUSH
14491: LD_INT 43
14493: PUSH
14494: LD_INT 48
14496: PUSH
14497: LD_INT 49
14499: PUSH
14500: LD_INT 50
14502: PUSH
14503: LD_INT 51
14505: PUSH
14506: LD_INT 52
14508: PUSH
14509: LD_INT 53
14511: PUSH
14512: LD_INT 54
14514: PUSH
14515: LD_INT 55
14517: PUSH
14518: LD_INT 56
14520: PUSH
14521: LD_INT 60
14523: PUSH
14524: LD_INT 61
14526: PUSH
14527: LD_INT 62
14529: PUSH
14530: LD_INT 66
14532: PUSH
14533: LD_INT 67
14535: PUSH
14536: LD_INT 68
14538: PUSH
14539: LD_INT 81
14541: PUSH
14542: EMPTY
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: LIST
14560: LIST
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: LIST
14573: LIST
14574: LIST
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: ST_TO_ADDR
14587: GO 14780
14589: LD_INT 3
14591: DOUBLE
14592: EQUAL
14593: IFTRUE 14597
14595: GO 14779
14597: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14598: LD_ADDR_VAR 0 4
14602: PUSH
14603: LD_INT 46
14605: PUSH
14606: LD_INT 47
14608: PUSH
14609: LD_INT 1
14611: PUSH
14612: LD_INT 2
14614: PUSH
14615: LD_INT 11
14617: PUSH
14618: LD_INT 9
14620: PUSH
14621: LD_INT 20
14623: PUSH
14624: LD_INT 19
14626: PUSH
14627: LD_INT 21
14629: PUSH
14630: LD_INT 24
14632: PUSH
14633: LD_INT 22
14635: PUSH
14636: LD_INT 25
14638: PUSH
14639: LD_INT 28
14641: PUSH
14642: LD_INT 29
14644: PUSH
14645: LD_INT 30
14647: PUSH
14648: LD_INT 31
14650: PUSH
14651: LD_INT 37
14653: PUSH
14654: LD_INT 38
14656: PUSH
14657: LD_INT 32
14659: PUSH
14660: LD_INT 27
14662: PUSH
14663: LD_INT 33
14665: PUSH
14666: LD_INT 69
14668: PUSH
14669: LD_INT 39
14671: PUSH
14672: LD_INT 34
14674: PUSH
14675: LD_INT 40
14677: PUSH
14678: LD_INT 71
14680: PUSH
14681: LD_INT 23
14683: PUSH
14684: LD_INT 44
14686: PUSH
14687: LD_INT 48
14689: PUSH
14690: LD_INT 49
14692: PUSH
14693: LD_INT 50
14695: PUSH
14696: LD_INT 51
14698: PUSH
14699: LD_INT 52
14701: PUSH
14702: LD_INT 53
14704: PUSH
14705: LD_INT 54
14707: PUSH
14708: LD_INT 55
14710: PUSH
14711: LD_INT 56
14713: PUSH
14714: LD_INT 57
14716: PUSH
14717: LD_INT 58
14719: PUSH
14720: LD_INT 59
14722: PUSH
14723: LD_INT 63
14725: PUSH
14726: LD_INT 64
14728: PUSH
14729: LD_INT 65
14731: PUSH
14732: EMPTY
14733: LIST
14734: LIST
14735: LIST
14736: LIST
14737: LIST
14738: LIST
14739: LIST
14740: LIST
14741: LIST
14742: LIST
14743: LIST
14744: LIST
14745: LIST
14746: LIST
14747: LIST
14748: LIST
14749: LIST
14750: LIST
14751: LIST
14752: LIST
14753: LIST
14754: LIST
14755: LIST
14756: LIST
14757: LIST
14758: LIST
14759: LIST
14760: LIST
14761: LIST
14762: LIST
14763: LIST
14764: LIST
14765: LIST
14766: LIST
14767: LIST
14768: LIST
14769: LIST
14770: LIST
14771: LIST
14772: LIST
14773: LIST
14774: LIST
14775: LIST
14776: ST_TO_ADDR
14777: GO 14780
14779: POP
// if state > - 1 and state < 3 then
14780: LD_VAR 0 3
14784: PUSH
14785: LD_INT 1
14787: NEG
14788: GREATER
14789: PUSH
14790: LD_VAR 0 3
14794: PUSH
14795: LD_INT 3
14797: LESS
14798: AND
14799: IFFALSE 14856
// for i in result do
14801: LD_ADDR_VAR 0 5
14805: PUSH
14806: LD_VAR 0 4
14810: PUSH
14811: FOR_IN
14812: IFFALSE 14854
// if GetTech ( i , side ) <> state then
14814: LD_VAR 0 5
14818: PPUSH
14819: LD_VAR 0 1
14823: PPUSH
14824: CALL_OW 321
14828: PUSH
14829: LD_VAR 0 3
14833: NONEQUAL
14834: IFFALSE 14852
// result := result diff i ;
14836: LD_ADDR_VAR 0 4
14840: PUSH
14841: LD_VAR 0 4
14845: PUSH
14846: LD_VAR 0 5
14850: DIFF
14851: ST_TO_ADDR
14852: GO 14811
14854: POP
14855: POP
// end ;
14856: LD_VAR 0 4
14860: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14861: LD_INT 0
14863: PPUSH
14864: PPUSH
14865: PPUSH
// result := true ;
14866: LD_ADDR_VAR 0 3
14870: PUSH
14871: LD_INT 1
14873: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14874: LD_ADDR_VAR 0 5
14878: PUSH
14879: LD_VAR 0 2
14883: PPUSH
14884: CALL_OW 480
14888: ST_TO_ADDR
// if not tmp then
14889: LD_VAR 0 5
14893: NOT
14894: IFFALSE 14898
// exit ;
14896: GO 14947
// for i in tmp do
14898: LD_ADDR_VAR 0 4
14902: PUSH
14903: LD_VAR 0 5
14907: PUSH
14908: FOR_IN
14909: IFFALSE 14945
// if GetTech ( i , side ) <> state_researched then
14911: LD_VAR 0 4
14915: PPUSH
14916: LD_VAR 0 1
14920: PPUSH
14921: CALL_OW 321
14925: PUSH
14926: LD_INT 2
14928: NONEQUAL
14929: IFFALSE 14943
// begin result := false ;
14931: LD_ADDR_VAR 0 3
14935: PUSH
14936: LD_INT 0
14938: ST_TO_ADDR
// exit ;
14939: POP
14940: POP
14941: GO 14947
// end ;
14943: GO 14908
14945: POP
14946: POP
// end ;
14947: LD_VAR 0 3
14951: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14952: LD_INT 0
14954: PPUSH
14955: PPUSH
14956: PPUSH
14957: PPUSH
14958: PPUSH
14959: PPUSH
14960: PPUSH
14961: PPUSH
14962: PPUSH
14963: PPUSH
14964: PPUSH
14965: PPUSH
14966: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14967: LD_VAR 0 1
14971: NOT
14972: PUSH
14973: LD_VAR 0 1
14977: PPUSH
14978: CALL_OW 257
14982: PUSH
14983: LD_INT 9
14985: NONEQUAL
14986: OR
14987: IFFALSE 14991
// exit ;
14989: GO 15564
// side := GetSide ( unit ) ;
14991: LD_ADDR_VAR 0 9
14995: PUSH
14996: LD_VAR 0 1
15000: PPUSH
15001: CALL_OW 255
15005: ST_TO_ADDR
// tech_space := tech_spacanom ;
15006: LD_ADDR_VAR 0 12
15010: PUSH
15011: LD_INT 29
15013: ST_TO_ADDR
// tech_time := tech_taurad ;
15014: LD_ADDR_VAR 0 13
15018: PUSH
15019: LD_INT 28
15021: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15022: LD_ADDR_VAR 0 11
15026: PUSH
15027: LD_VAR 0 1
15031: PPUSH
15032: CALL_OW 310
15036: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15037: LD_VAR 0 11
15041: PPUSH
15042: CALL_OW 247
15046: PUSH
15047: LD_INT 2
15049: EQUAL
15050: IFFALSE 15054
// exit ;
15052: GO 15564
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15054: LD_ADDR_VAR 0 8
15058: PUSH
15059: LD_INT 81
15061: PUSH
15062: LD_VAR 0 9
15066: PUSH
15067: EMPTY
15068: LIST
15069: LIST
15070: PUSH
15071: LD_INT 3
15073: PUSH
15074: LD_INT 21
15076: PUSH
15077: LD_INT 3
15079: PUSH
15080: EMPTY
15081: LIST
15082: LIST
15083: PUSH
15084: EMPTY
15085: LIST
15086: LIST
15087: PUSH
15088: EMPTY
15089: LIST
15090: LIST
15091: PPUSH
15092: CALL_OW 69
15096: ST_TO_ADDR
// if not tmp then
15097: LD_VAR 0 8
15101: NOT
15102: IFFALSE 15106
// exit ;
15104: GO 15564
// if in_unit then
15106: LD_VAR 0 11
15110: IFFALSE 15134
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15112: LD_ADDR_VAR 0 10
15116: PUSH
15117: LD_VAR 0 8
15121: PPUSH
15122: LD_VAR 0 11
15126: PPUSH
15127: CALL_OW 74
15131: ST_TO_ADDR
15132: GO 15154
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15134: LD_ADDR_VAR 0 10
15138: PUSH
15139: LD_VAR 0 8
15143: PPUSH
15144: LD_VAR 0 1
15148: PPUSH
15149: CALL_OW 74
15153: ST_TO_ADDR
// if not enemy then
15154: LD_VAR 0 10
15158: NOT
15159: IFFALSE 15163
// exit ;
15161: GO 15564
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15163: LD_VAR 0 11
15167: PUSH
15168: LD_VAR 0 11
15172: PPUSH
15173: LD_VAR 0 10
15177: PPUSH
15178: CALL_OW 296
15182: PUSH
15183: LD_INT 13
15185: GREATER
15186: AND
15187: PUSH
15188: LD_VAR 0 1
15192: PPUSH
15193: LD_VAR 0 10
15197: PPUSH
15198: CALL_OW 296
15202: PUSH
15203: LD_INT 12
15205: GREATER
15206: OR
15207: IFFALSE 15211
// exit ;
15209: GO 15564
// missile := [ 1 ] ;
15211: LD_ADDR_VAR 0 14
15215: PUSH
15216: LD_INT 1
15218: PUSH
15219: EMPTY
15220: LIST
15221: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15222: LD_VAR 0 9
15226: PPUSH
15227: LD_VAR 0 12
15231: PPUSH
15232: CALL_OW 325
15236: IFFALSE 15265
// missile := Insert ( missile , missile + 1 , 2 ) ;
15238: LD_ADDR_VAR 0 14
15242: PUSH
15243: LD_VAR 0 14
15247: PPUSH
15248: LD_VAR 0 14
15252: PUSH
15253: LD_INT 1
15255: PLUS
15256: PPUSH
15257: LD_INT 2
15259: PPUSH
15260: CALL_OW 2
15264: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15265: LD_VAR 0 9
15269: PPUSH
15270: LD_VAR 0 13
15274: PPUSH
15275: CALL_OW 325
15279: PUSH
15280: LD_VAR 0 10
15284: PPUSH
15285: CALL_OW 255
15289: PPUSH
15290: LD_VAR 0 13
15294: PPUSH
15295: CALL_OW 325
15299: NOT
15300: AND
15301: IFFALSE 15330
// missile := Insert ( missile , missile + 1 , 3 ) ;
15303: LD_ADDR_VAR 0 14
15307: PUSH
15308: LD_VAR 0 14
15312: PPUSH
15313: LD_VAR 0 14
15317: PUSH
15318: LD_INT 1
15320: PLUS
15321: PPUSH
15322: LD_INT 3
15324: PPUSH
15325: CALL_OW 2
15329: ST_TO_ADDR
// if missile < 2 then
15330: LD_VAR 0 14
15334: PUSH
15335: LD_INT 2
15337: LESS
15338: IFFALSE 15342
// exit ;
15340: GO 15564
// x := GetX ( enemy ) ;
15342: LD_ADDR_VAR 0 4
15346: PUSH
15347: LD_VAR 0 10
15351: PPUSH
15352: CALL_OW 250
15356: ST_TO_ADDR
// y := GetY ( enemy ) ;
15357: LD_ADDR_VAR 0 5
15361: PUSH
15362: LD_VAR 0 10
15366: PPUSH
15367: CALL_OW 251
15371: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15372: LD_ADDR_VAR 0 6
15376: PUSH
15377: LD_VAR 0 4
15381: PUSH
15382: LD_INT 1
15384: NEG
15385: PPUSH
15386: LD_INT 1
15388: PPUSH
15389: CALL_OW 12
15393: PLUS
15394: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15395: LD_ADDR_VAR 0 7
15399: PUSH
15400: LD_VAR 0 5
15404: PUSH
15405: LD_INT 1
15407: NEG
15408: PPUSH
15409: LD_INT 1
15411: PPUSH
15412: CALL_OW 12
15416: PLUS
15417: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15418: LD_VAR 0 6
15422: PPUSH
15423: LD_VAR 0 7
15427: PPUSH
15428: CALL_OW 488
15432: NOT
15433: IFFALSE 15455
// begin _x := x ;
15435: LD_ADDR_VAR 0 6
15439: PUSH
15440: LD_VAR 0 4
15444: ST_TO_ADDR
// _y := y ;
15445: LD_ADDR_VAR 0 7
15449: PUSH
15450: LD_VAR 0 5
15454: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15455: LD_ADDR_VAR 0 3
15459: PUSH
15460: LD_INT 1
15462: PPUSH
15463: LD_VAR 0 14
15467: PPUSH
15468: CALL_OW 12
15472: ST_TO_ADDR
// case i of 1 :
15473: LD_VAR 0 3
15477: PUSH
15478: LD_INT 1
15480: DOUBLE
15481: EQUAL
15482: IFTRUE 15486
15484: GO 15503
15486: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15487: LD_VAR 0 1
15491: PPUSH
15492: LD_VAR 0 10
15496: PPUSH
15497: CALL_OW 115
15501: GO 15564
15503: LD_INT 2
15505: DOUBLE
15506: EQUAL
15507: IFTRUE 15511
15509: GO 15533
15511: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15512: LD_VAR 0 1
15516: PPUSH
15517: LD_VAR 0 6
15521: PPUSH
15522: LD_VAR 0 7
15526: PPUSH
15527: CALL_OW 153
15531: GO 15564
15533: LD_INT 3
15535: DOUBLE
15536: EQUAL
15537: IFTRUE 15541
15539: GO 15563
15541: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15542: LD_VAR 0 1
15546: PPUSH
15547: LD_VAR 0 6
15551: PPUSH
15552: LD_VAR 0 7
15556: PPUSH
15557: CALL_OW 154
15561: GO 15564
15563: POP
// end ;
15564: LD_VAR 0 2
15568: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15569: LD_INT 0
15571: PPUSH
15572: PPUSH
15573: PPUSH
15574: PPUSH
15575: PPUSH
15576: PPUSH
// if not unit or not building then
15577: LD_VAR 0 1
15581: NOT
15582: PUSH
15583: LD_VAR 0 2
15587: NOT
15588: OR
15589: IFFALSE 15593
// exit ;
15591: GO 15751
// x := GetX ( building ) ;
15593: LD_ADDR_VAR 0 5
15597: PUSH
15598: LD_VAR 0 2
15602: PPUSH
15603: CALL_OW 250
15607: ST_TO_ADDR
// y := GetY ( building ) ;
15608: LD_ADDR_VAR 0 6
15612: PUSH
15613: LD_VAR 0 2
15617: PPUSH
15618: CALL_OW 251
15622: ST_TO_ADDR
// for i = 0 to 5 do
15623: LD_ADDR_VAR 0 4
15627: PUSH
15628: DOUBLE
15629: LD_INT 0
15631: DEC
15632: ST_TO_ADDR
15633: LD_INT 5
15635: PUSH
15636: FOR_TO
15637: IFFALSE 15749
// begin _x := ShiftX ( x , i , 3 ) ;
15639: LD_ADDR_VAR 0 7
15643: PUSH
15644: LD_VAR 0 5
15648: PPUSH
15649: LD_VAR 0 4
15653: PPUSH
15654: LD_INT 3
15656: PPUSH
15657: CALL_OW 272
15661: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15662: LD_ADDR_VAR 0 8
15666: PUSH
15667: LD_VAR 0 6
15671: PPUSH
15672: LD_VAR 0 4
15676: PPUSH
15677: LD_INT 3
15679: PPUSH
15680: CALL_OW 273
15684: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15685: LD_VAR 0 7
15689: PPUSH
15690: LD_VAR 0 8
15694: PPUSH
15695: CALL_OW 488
15699: NOT
15700: IFFALSE 15704
// continue ;
15702: GO 15636
// if HexInfo ( _x , _y ) = 0 then
15704: LD_VAR 0 7
15708: PPUSH
15709: LD_VAR 0 8
15713: PPUSH
15714: CALL_OW 428
15718: PUSH
15719: LD_INT 0
15721: EQUAL
15722: IFFALSE 15747
// begin ComMoveXY ( unit , _x , _y ) ;
15724: LD_VAR 0 1
15728: PPUSH
15729: LD_VAR 0 7
15733: PPUSH
15734: LD_VAR 0 8
15738: PPUSH
15739: CALL_OW 111
// exit ;
15743: POP
15744: POP
15745: GO 15751
// end ; end ;
15747: GO 15636
15749: POP
15750: POP
// end ;
15751: LD_VAR 0 3
15755: RET
// export function ScanBase ( side , base_area ) ; begin
15756: LD_INT 0
15758: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15759: LD_ADDR_VAR 0 3
15763: PUSH
15764: LD_VAR 0 2
15768: PPUSH
15769: LD_INT 81
15771: PUSH
15772: LD_VAR 0 1
15776: PUSH
15777: EMPTY
15778: LIST
15779: LIST
15780: PPUSH
15781: CALL_OW 70
15785: ST_TO_ADDR
// end ;
15786: LD_VAR 0 3
15790: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15791: LD_INT 0
15793: PPUSH
15794: PPUSH
15795: PPUSH
15796: PPUSH
15797: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15798: LD_VAR 0 1
15802: NOT
15803: PUSH
15804: LD_EXP 58
15808: PUSH
15809: LD_VAR 0 1
15813: ARRAY
15814: NOT
15815: OR
15816: PUSH
15817: LD_VAR 0 2
15821: NOT
15822: OR
15823: PUSH
15824: LD_VAR 0 3
15828: NOT
15829: OR
15830: IFFALSE 15834
// exit ;
15832: GO 16347
// side := mc_sides [ base ] ;
15834: LD_ADDR_VAR 0 6
15838: PUSH
15839: LD_EXP 84
15843: PUSH
15844: LD_VAR 0 1
15848: ARRAY
15849: ST_TO_ADDR
// if not side then
15850: LD_VAR 0 6
15854: NOT
15855: IFFALSE 15859
// exit ;
15857: GO 16347
// for i in solds do
15859: LD_ADDR_VAR 0 7
15863: PUSH
15864: LD_VAR 0 2
15868: PUSH
15869: FOR_IN
15870: IFFALSE 15931
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15872: LD_VAR 0 7
15876: PPUSH
15877: CALL_OW 310
15881: PPUSH
15882: CALL_OW 266
15886: PUSH
15887: LD_INT 32
15889: PUSH
15890: LD_INT 31
15892: PUSH
15893: EMPTY
15894: LIST
15895: LIST
15896: IN
15897: IFFALSE 15917
// solds := solds diff i else
15899: LD_ADDR_VAR 0 2
15903: PUSH
15904: LD_VAR 0 2
15908: PUSH
15909: LD_VAR 0 7
15913: DIFF
15914: ST_TO_ADDR
15915: GO 15929
// SetTag ( i , 18 ) ;
15917: LD_VAR 0 7
15921: PPUSH
15922: LD_INT 18
15924: PPUSH
15925: CALL_OW 109
15929: GO 15869
15931: POP
15932: POP
// if not solds then
15933: LD_VAR 0 2
15937: NOT
15938: IFFALSE 15942
// exit ;
15940: GO 16347
// repeat wait ( 0 0$1 ) ;
15942: LD_INT 35
15944: PPUSH
15945: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15949: LD_ADDR_VAR 0 5
15953: PUSH
15954: LD_VAR 0 6
15958: PPUSH
15959: LD_VAR 0 3
15963: PPUSH
15964: CALL 15756 0 2
15968: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
15969: LD_EXP 58
15973: PUSH
15974: LD_VAR 0 1
15978: ARRAY
15979: NOT
15980: PUSH
15981: LD_EXP 58
15985: PUSH
15986: LD_VAR 0 1
15990: ARRAY
15991: PUSH
15992: EMPTY
15993: EQUAL
15994: OR
15995: IFFALSE 16032
// begin for i in solds do
15997: LD_ADDR_VAR 0 7
16001: PUSH
16002: LD_VAR 0 2
16006: PUSH
16007: FOR_IN
16008: IFFALSE 16021
// ComStop ( i ) ;
16010: LD_VAR 0 7
16014: PPUSH
16015: CALL_OW 141
16019: GO 16007
16021: POP
16022: POP
// solds := [ ] ;
16023: LD_ADDR_VAR 0 2
16027: PUSH
16028: EMPTY
16029: ST_TO_ADDR
// exit ;
16030: GO 16347
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
16032: LD_VAR 0 5
16036: NOT
16037: PUSH
16038: LD_VAR 0 5
16042: PUSH
16043: LD_INT 3
16045: GREATER
16046: OR
16047: PUSH
16048: LD_EXP 80
16052: PUSH
16053: LD_VAR 0 1
16057: ARRAY
16058: OR
16059: IFFALSE 16100
// begin for i in solds do
16061: LD_ADDR_VAR 0 7
16065: PUSH
16066: LD_VAR 0 2
16070: PUSH
16071: FOR_IN
16072: IFFALSE 16096
// if HasTask ( i ) then
16074: LD_VAR 0 7
16078: PPUSH
16079: CALL_OW 314
16083: IFFALSE 16094
// ComStop ( i ) ;
16085: LD_VAR 0 7
16089: PPUSH
16090: CALL_OW 141
16094: GO 16071
16096: POP
16097: POP
// break ;
16098: GO 16335
// end ; for i in solds do
16100: LD_ADDR_VAR 0 7
16104: PUSH
16105: LD_VAR 0 2
16109: PUSH
16110: FOR_IN
16111: IFFALSE 16327
// begin if IsInUnit ( i ) then
16113: LD_VAR 0 7
16117: PPUSH
16118: CALL_OW 310
16122: IFFALSE 16133
// ComExitBuilding ( i ) ;
16124: LD_VAR 0 7
16128: PPUSH
16129: CALL_OW 122
// if GetLives ( i ) > 333 then
16133: LD_VAR 0 7
16137: PPUSH
16138: CALL_OW 256
16142: PUSH
16143: LD_INT 333
16145: GREATER
16146: IFFALSE 16174
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
16148: LD_VAR 0 7
16152: PPUSH
16153: LD_VAR 0 5
16157: PPUSH
16158: LD_VAR 0 7
16162: PPUSH
16163: CALL_OW 74
16167: PPUSH
16168: CALL_OW 115
16172: GO 16325
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
16174: LD_ADDR_VAR 0 8
16178: PUSH
16179: LD_EXP 58
16183: PUSH
16184: LD_VAR 0 1
16188: ARRAY
16189: PPUSH
16190: LD_INT 2
16192: PUSH
16193: LD_INT 30
16195: PUSH
16196: LD_INT 0
16198: PUSH
16199: EMPTY
16200: LIST
16201: LIST
16202: PUSH
16203: LD_INT 30
16205: PUSH
16206: LD_INT 1
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: PUSH
16213: LD_INT 30
16215: PUSH
16216: LD_INT 6
16218: PUSH
16219: EMPTY
16220: LIST
16221: LIST
16222: PUSH
16223: EMPTY
16224: LIST
16225: LIST
16226: LIST
16227: LIST
16228: PPUSH
16229: CALL_OW 72
16233: PPUSH
16234: LD_VAR 0 7
16238: PPUSH
16239: CALL_OW 74
16243: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
16244: LD_VAR 0 7
16248: PPUSH
16249: LD_VAR 0 8
16253: PPUSH
16254: CALL_OW 250
16258: PPUSH
16259: LD_INT 3
16261: PPUSH
16262: LD_INT 5
16264: PPUSH
16265: CALL_OW 272
16269: PPUSH
16270: LD_VAR 0 8
16274: PPUSH
16275: CALL_OW 251
16279: PPUSH
16280: LD_INT 3
16282: PPUSH
16283: LD_INT 5
16285: PPUSH
16286: CALL_OW 273
16290: PPUSH
16291: CALL_OW 111
// SetTag ( i , 0 ) ;
16295: LD_VAR 0 7
16299: PPUSH
16300: LD_INT 0
16302: PPUSH
16303: CALL_OW 109
// solds := solds diff i ;
16307: LD_ADDR_VAR 0 2
16311: PUSH
16312: LD_VAR 0 2
16316: PUSH
16317: LD_VAR 0 7
16321: DIFF
16322: ST_TO_ADDR
// continue ;
16323: GO 16110
// end ; end ;
16325: GO 16110
16327: POP
16328: POP
// until solds ;
16329: LD_VAR 0 2
16333: IFFALSE 15942
// MC_Reset ( base , 18 ) ;
16335: LD_VAR 0 1
16339: PPUSH
16340: LD_INT 18
16342: PPUSH
16343: CALL 61369 0 2
// end ;
16347: LD_VAR 0 4
16351: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16352: LD_INT 0
16354: PPUSH
16355: PPUSH
16356: PPUSH
16357: PPUSH
16358: PPUSH
16359: PPUSH
16360: PPUSH
16361: PPUSH
16362: PPUSH
16363: PPUSH
16364: PPUSH
16365: PPUSH
16366: PPUSH
16367: PPUSH
16368: PPUSH
16369: PPUSH
16370: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16371: LD_ADDR_VAR 0 13
16375: PUSH
16376: LD_EXP 58
16380: PUSH
16381: LD_VAR 0 1
16385: ARRAY
16386: PPUSH
16387: LD_INT 25
16389: PUSH
16390: LD_INT 3
16392: PUSH
16393: EMPTY
16394: LIST
16395: LIST
16396: PPUSH
16397: CALL_OW 72
16401: ST_TO_ADDR
// if mc_remote_driver [ base ] then
16402: LD_EXP 98
16406: PUSH
16407: LD_VAR 0 1
16411: ARRAY
16412: IFFALSE 16436
// mechs := mechs diff mc_remote_driver [ base ] ;
16414: LD_ADDR_VAR 0 13
16418: PUSH
16419: LD_VAR 0 13
16423: PUSH
16424: LD_EXP 98
16428: PUSH
16429: LD_VAR 0 1
16433: ARRAY
16434: DIFF
16435: ST_TO_ADDR
// for i in mechs do
16436: LD_ADDR_VAR 0 5
16440: PUSH
16441: LD_VAR 0 13
16445: PUSH
16446: FOR_IN
16447: IFFALSE 16482
// if GetTag ( i ) > 0 then
16449: LD_VAR 0 5
16453: PPUSH
16454: CALL_OW 110
16458: PUSH
16459: LD_INT 0
16461: GREATER
16462: IFFALSE 16480
// mechs := mechs diff i ;
16464: LD_ADDR_VAR 0 13
16468: PUSH
16469: LD_VAR 0 13
16473: PUSH
16474: LD_VAR 0 5
16478: DIFF
16479: ST_TO_ADDR
16480: GO 16446
16482: POP
16483: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16484: LD_ADDR_VAR 0 9
16488: PUSH
16489: LD_EXP 58
16493: PUSH
16494: LD_VAR 0 1
16498: ARRAY
16499: PPUSH
16500: LD_INT 2
16502: PUSH
16503: LD_INT 25
16505: PUSH
16506: LD_INT 1
16508: PUSH
16509: EMPTY
16510: LIST
16511: LIST
16512: PUSH
16513: LD_INT 25
16515: PUSH
16516: LD_INT 5
16518: PUSH
16519: EMPTY
16520: LIST
16521: LIST
16522: PUSH
16523: LD_INT 25
16525: PUSH
16526: LD_INT 8
16528: PUSH
16529: EMPTY
16530: LIST
16531: LIST
16532: PUSH
16533: LD_INT 25
16535: PUSH
16536: LD_INT 9
16538: PUSH
16539: EMPTY
16540: LIST
16541: LIST
16542: PUSH
16543: EMPTY
16544: LIST
16545: LIST
16546: LIST
16547: LIST
16548: LIST
16549: PPUSH
16550: CALL_OW 72
16554: ST_TO_ADDR
// if not defenders and not solds then
16555: LD_VAR 0 2
16559: NOT
16560: PUSH
16561: LD_VAR 0 9
16565: NOT
16566: AND
16567: IFFALSE 16571
// exit ;
16569: GO 18197
// depot_under_attack := false ;
16571: LD_ADDR_VAR 0 17
16575: PUSH
16576: LD_INT 0
16578: ST_TO_ADDR
// sold_defenders := [ ] ;
16579: LD_ADDR_VAR 0 18
16583: PUSH
16584: EMPTY
16585: ST_TO_ADDR
// if mechs then
16586: LD_VAR 0 13
16590: IFFALSE 16719
// for i in defenders do
16592: LD_ADDR_VAR 0 5
16596: PUSH
16597: LD_VAR 0 2
16601: PUSH
16602: FOR_IN
16603: IFFALSE 16717
// begin SetTag ( i , 20 ) ;
16605: LD_VAR 0 5
16609: PPUSH
16610: LD_INT 20
16612: PPUSH
16613: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16617: LD_VAR 0 5
16621: PPUSH
16622: CALL_OW 263
16626: PUSH
16627: LD_INT 1
16629: EQUAL
16630: PUSH
16631: LD_VAR 0 5
16635: PPUSH
16636: CALL_OW 311
16640: NOT
16641: AND
16642: PUSH
16643: LD_VAR 0 13
16647: AND
16648: IFFALSE 16715
// begin un := mechs [ 1 ] ;
16650: LD_ADDR_VAR 0 11
16654: PUSH
16655: LD_VAR 0 13
16659: PUSH
16660: LD_INT 1
16662: ARRAY
16663: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16664: LD_VAR 0 11
16668: PPUSH
16669: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16673: LD_VAR 0 11
16677: PPUSH
16678: LD_VAR 0 5
16682: PPUSH
16683: CALL_OW 180
// SetTag ( un , 19 ) ;
16687: LD_VAR 0 11
16691: PPUSH
16692: LD_INT 19
16694: PPUSH
16695: CALL_OW 109
// mechs := mechs diff un ;
16699: LD_ADDR_VAR 0 13
16703: PUSH
16704: LD_VAR 0 13
16708: PUSH
16709: LD_VAR 0 11
16713: DIFF
16714: ST_TO_ADDR
// end ; end ;
16715: GO 16602
16717: POP
16718: POP
// if solds then
16719: LD_VAR 0 9
16723: IFFALSE 16782
// for i in solds do
16725: LD_ADDR_VAR 0 5
16729: PUSH
16730: LD_VAR 0 9
16734: PUSH
16735: FOR_IN
16736: IFFALSE 16780
// if not GetTag ( i ) then
16738: LD_VAR 0 5
16742: PPUSH
16743: CALL_OW 110
16747: NOT
16748: IFFALSE 16778
// begin defenders := defenders union i ;
16750: LD_ADDR_VAR 0 2
16754: PUSH
16755: LD_VAR 0 2
16759: PUSH
16760: LD_VAR 0 5
16764: UNION
16765: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16766: LD_VAR 0 5
16770: PPUSH
16771: LD_INT 18
16773: PPUSH
16774: CALL_OW 109
// end ;
16778: GO 16735
16780: POP
16781: POP
// repeat wait ( 0 0$1 ) ;
16782: LD_INT 35
16784: PPUSH
16785: CALL_OW 67
// enemy := mc_scan [ base ] ;
16789: LD_ADDR_VAR 0 3
16793: PUSH
16794: LD_EXP 81
16798: PUSH
16799: LD_VAR 0 1
16803: ARRAY
16804: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
16805: LD_EXP 58
16809: PUSH
16810: LD_VAR 0 1
16814: ARRAY
16815: NOT
16816: PUSH
16817: LD_EXP 58
16821: PUSH
16822: LD_VAR 0 1
16826: ARRAY
16827: PUSH
16828: EMPTY
16829: EQUAL
16830: OR
16831: IFFALSE 16868
// begin for i in defenders do
16833: LD_ADDR_VAR 0 5
16837: PUSH
16838: LD_VAR 0 2
16842: PUSH
16843: FOR_IN
16844: IFFALSE 16857
// ComStop ( i ) ;
16846: LD_VAR 0 5
16850: PPUSH
16851: CALL_OW 141
16855: GO 16843
16857: POP
16858: POP
// defenders := [ ] ;
16859: LD_ADDR_VAR 0 2
16863: PUSH
16864: EMPTY
16865: ST_TO_ADDR
// exit ;
16866: GO 18197
// end ; for i in defenders do
16868: LD_ADDR_VAR 0 5
16872: PUSH
16873: LD_VAR 0 2
16877: PUSH
16878: FOR_IN
16879: IFFALSE 17697
// begin e := NearestUnitToUnit ( enemy , i ) ;
16881: LD_ADDR_VAR 0 14
16885: PUSH
16886: LD_VAR 0 3
16890: PPUSH
16891: LD_VAR 0 5
16895: PPUSH
16896: CALL_OW 74
16900: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
16901: LD_ADDR_VAR 0 8
16905: PUSH
16906: LD_EXP 58
16910: PUSH
16911: LD_VAR 0 1
16915: ARRAY
16916: PPUSH
16917: LD_INT 2
16919: PUSH
16920: LD_INT 30
16922: PUSH
16923: LD_INT 0
16925: PUSH
16926: EMPTY
16927: LIST
16928: LIST
16929: PUSH
16930: LD_INT 30
16932: PUSH
16933: LD_INT 1
16935: PUSH
16936: EMPTY
16937: LIST
16938: LIST
16939: PUSH
16940: EMPTY
16941: LIST
16942: LIST
16943: LIST
16944: PPUSH
16945: CALL_OW 72
16949: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
16950: LD_ADDR_VAR 0 17
16954: PUSH
16955: LD_VAR 0 8
16959: NOT
16960: PUSH
16961: LD_VAR 0 8
16965: PPUSH
16966: LD_INT 3
16968: PUSH
16969: LD_INT 24
16971: PUSH
16972: LD_INT 600
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: PUSH
16979: EMPTY
16980: LIST
16981: LIST
16982: PPUSH
16983: CALL_OW 72
16987: OR
16988: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
16989: LD_VAR 0 5
16993: PPUSH
16994: CALL_OW 247
16998: PUSH
16999: LD_INT 2
17001: DOUBLE
17002: EQUAL
17003: IFTRUE 17007
17005: GO 17403
17007: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
17008: LD_VAR 0 5
17012: PPUSH
17013: CALL_OW 256
17017: PUSH
17018: LD_INT 650
17020: GREATER
17021: PUSH
17022: LD_VAR 0 5
17026: PPUSH
17027: LD_VAR 0 14
17031: PPUSH
17032: CALL_OW 296
17036: PUSH
17037: LD_INT 40
17039: LESS
17040: PUSH
17041: LD_VAR 0 14
17045: PPUSH
17046: LD_EXP 83
17050: PUSH
17051: LD_VAR 0 1
17055: ARRAY
17056: PPUSH
17057: CALL_OW 308
17061: OR
17062: AND
17063: IFFALSE 17185
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
17065: LD_VAR 0 5
17069: PPUSH
17070: CALL_OW 262
17074: PUSH
17075: LD_INT 1
17077: EQUAL
17078: PUSH
17079: LD_VAR 0 5
17083: PPUSH
17084: CALL_OW 261
17088: PUSH
17089: LD_INT 30
17091: LESS
17092: AND
17093: PUSH
17094: LD_VAR 0 8
17098: AND
17099: IFFALSE 17169
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
17101: LD_VAR 0 5
17105: PPUSH
17106: LD_VAR 0 8
17110: PPUSH
17111: LD_VAR 0 5
17115: PPUSH
17116: CALL_OW 74
17120: PPUSH
17121: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
17125: LD_VAR 0 5
17129: PPUSH
17130: LD_VAR 0 8
17134: PPUSH
17135: LD_VAR 0 5
17139: PPUSH
17140: CALL_OW 74
17144: PPUSH
17145: CALL_OW 296
17149: PUSH
17150: LD_INT 6
17152: LESS
17153: IFFALSE 17167
// SetFuel ( i , 100 ) ;
17155: LD_VAR 0 5
17159: PPUSH
17160: LD_INT 100
17162: PPUSH
17163: CALL_OW 240
// end else
17167: GO 17183
// ComAttackUnit ( i , e ) ;
17169: LD_VAR 0 5
17173: PPUSH
17174: LD_VAR 0 14
17178: PPUSH
17179: CALL_OW 115
// end else
17183: GO 17286
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
17185: LD_VAR 0 14
17189: PPUSH
17190: LD_EXP 83
17194: PUSH
17195: LD_VAR 0 1
17199: ARRAY
17200: PPUSH
17201: CALL_OW 308
17205: NOT
17206: PUSH
17207: LD_VAR 0 5
17211: PPUSH
17212: LD_VAR 0 14
17216: PPUSH
17217: CALL_OW 296
17221: PUSH
17222: LD_INT 40
17224: GREATEREQUAL
17225: AND
17226: PUSH
17227: LD_VAR 0 5
17231: PPUSH
17232: CALL_OW 256
17236: PUSH
17237: LD_INT 650
17239: LESSEQUAL
17240: OR
17241: PUSH
17242: LD_VAR 0 5
17246: PPUSH
17247: LD_EXP 82
17251: PUSH
17252: LD_VAR 0 1
17256: ARRAY
17257: PPUSH
17258: CALL_OW 308
17262: NOT
17263: AND
17264: IFFALSE 17286
// ComMoveToArea ( i , mc_parking [ base ] ) ;
17266: LD_VAR 0 5
17270: PPUSH
17271: LD_EXP 82
17275: PUSH
17276: LD_VAR 0 1
17280: ARRAY
17281: PPUSH
17282: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
17286: LD_VAR 0 5
17290: PPUSH
17291: CALL_OW 256
17295: PUSH
17296: LD_INT 998
17298: LESS
17299: PUSH
17300: LD_VAR 0 5
17304: PPUSH
17305: CALL_OW 263
17309: PUSH
17310: LD_INT 1
17312: EQUAL
17313: AND
17314: PUSH
17315: LD_VAR 0 5
17319: PPUSH
17320: CALL_OW 311
17324: AND
17325: PUSH
17326: LD_VAR 0 5
17330: PPUSH
17331: LD_EXP 82
17335: PUSH
17336: LD_VAR 0 1
17340: ARRAY
17341: PPUSH
17342: CALL_OW 308
17346: AND
17347: IFFALSE 17401
// begin mech := IsDrivenBy ( i ) ;
17349: LD_ADDR_VAR 0 10
17353: PUSH
17354: LD_VAR 0 5
17358: PPUSH
17359: CALL_OW 311
17363: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
17364: LD_VAR 0 10
17368: PPUSH
17369: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
17373: LD_VAR 0 10
17377: PPUSH
17378: LD_VAR 0 5
17382: PPUSH
17383: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
17387: LD_VAR 0 10
17391: PPUSH
17392: LD_VAR 0 5
17396: PPUSH
17397: CALL_OW 180
// end ; end ; unit_human :
17401: GO 17668
17403: LD_INT 1
17405: DOUBLE
17406: EQUAL
17407: IFTRUE 17411
17409: GO 17667
17411: POP
// begin b := IsInUnit ( i ) ;
17412: LD_ADDR_VAR 0 19
17416: PUSH
17417: LD_VAR 0 5
17421: PPUSH
17422: CALL_OW 310
17426: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
17427: LD_ADDR_VAR 0 20
17431: PUSH
17432: LD_VAR 0 19
17436: NOT
17437: PUSH
17438: LD_VAR 0 19
17442: PPUSH
17443: CALL_OW 266
17447: PUSH
17448: LD_INT 32
17450: PUSH
17451: LD_INT 31
17453: PUSH
17454: EMPTY
17455: LIST
17456: LIST
17457: IN
17458: OR
17459: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
17460: LD_VAR 0 17
17464: PUSH
17465: LD_VAR 0 2
17469: PPUSH
17470: LD_INT 21
17472: PUSH
17473: LD_INT 2
17475: PUSH
17476: EMPTY
17477: LIST
17478: LIST
17479: PPUSH
17480: CALL_OW 72
17484: PUSH
17485: LD_INT 1
17487: LESSEQUAL
17488: OR
17489: PUSH
17490: LD_VAR 0 20
17494: AND
17495: PUSH
17496: LD_VAR 0 5
17500: PUSH
17501: LD_VAR 0 18
17505: IN
17506: NOT
17507: AND
17508: IFFALSE 17601
// begin if b then
17510: LD_VAR 0 19
17514: IFFALSE 17563
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
17516: LD_VAR 0 19
17520: PPUSH
17521: LD_VAR 0 3
17525: PPUSH
17526: LD_VAR 0 19
17530: PPUSH
17531: CALL_OW 74
17535: PPUSH
17536: CALL_OW 296
17540: PUSH
17541: LD_INT 10
17543: LESS
17544: PUSH
17545: LD_VAR 0 19
17549: PPUSH
17550: CALL_OW 461
17554: PUSH
17555: LD_INT 7
17557: NONEQUAL
17558: AND
17559: IFFALSE 17563
// continue ;
17561: GO 16878
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
17563: LD_ADDR_VAR 0 18
17567: PUSH
17568: LD_VAR 0 18
17572: PPUSH
17573: LD_VAR 0 18
17577: PUSH
17578: LD_INT 1
17580: PLUS
17581: PPUSH
17582: LD_VAR 0 5
17586: PPUSH
17587: CALL_OW 1
17591: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17592: LD_VAR 0 5
17596: PPUSH
17597: CALL_OW 122
// end ; if sold_defenders then
17601: LD_VAR 0 18
17605: IFFALSE 17665
// if i in sold_defenders then
17607: LD_VAR 0 5
17611: PUSH
17612: LD_VAR 0 18
17616: IN
17617: IFFALSE 17665
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17619: LD_VAR 0 5
17623: PPUSH
17624: CALL_OW 314
17628: NOT
17629: PUSH
17630: LD_VAR 0 5
17634: PPUSH
17635: LD_VAR 0 14
17639: PPUSH
17640: CALL_OW 296
17644: PUSH
17645: LD_INT 30
17647: LESS
17648: AND
17649: IFFALSE 17665
// ComAttackUnit ( i , e ) ;
17651: LD_VAR 0 5
17655: PPUSH
17656: LD_VAR 0 14
17660: PPUSH
17661: CALL_OW 115
// end ; end ; end ;
17665: GO 17668
17667: POP
// if IsDead ( i ) then
17668: LD_VAR 0 5
17672: PPUSH
17673: CALL_OW 301
17677: IFFALSE 17695
// defenders := defenders diff i ;
17679: LD_ADDR_VAR 0 2
17683: PUSH
17684: LD_VAR 0 2
17688: PUSH
17689: LD_VAR 0 5
17693: DIFF
17694: ST_TO_ADDR
// end ;
17695: GO 16878
17697: POP
17698: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
17699: LD_VAR 0 3
17703: NOT
17704: PUSH
17705: LD_VAR 0 2
17709: NOT
17710: OR
17711: PUSH
17712: LD_EXP 58
17716: PUSH
17717: LD_VAR 0 1
17721: ARRAY
17722: NOT
17723: OR
17724: IFFALSE 16782
// MC_Reset ( base , 18 ) ;
17726: LD_VAR 0 1
17730: PPUSH
17731: LD_INT 18
17733: PPUSH
17734: CALL 61369 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17738: LD_ADDR_VAR 0 2
17742: PUSH
17743: LD_VAR 0 2
17747: PUSH
17748: LD_VAR 0 2
17752: PPUSH
17753: LD_INT 2
17755: PUSH
17756: LD_INT 25
17758: PUSH
17759: LD_INT 1
17761: PUSH
17762: EMPTY
17763: LIST
17764: LIST
17765: PUSH
17766: LD_INT 25
17768: PUSH
17769: LD_INT 5
17771: PUSH
17772: EMPTY
17773: LIST
17774: LIST
17775: PUSH
17776: LD_INT 25
17778: PUSH
17779: LD_INT 8
17781: PUSH
17782: EMPTY
17783: LIST
17784: LIST
17785: PUSH
17786: LD_INT 25
17788: PUSH
17789: LD_INT 9
17791: PUSH
17792: EMPTY
17793: LIST
17794: LIST
17795: PUSH
17796: EMPTY
17797: LIST
17798: LIST
17799: LIST
17800: LIST
17801: LIST
17802: PPUSH
17803: CALL_OW 72
17807: DIFF
17808: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17809: LD_VAR 0 3
17813: NOT
17814: PUSH
17815: LD_VAR 0 2
17819: PPUSH
17820: LD_INT 21
17822: PUSH
17823: LD_INT 2
17825: PUSH
17826: EMPTY
17827: LIST
17828: LIST
17829: PPUSH
17830: CALL_OW 72
17834: AND
17835: IFFALSE 18173
// begin tmp := FilterByTag ( defenders , 19 ) ;
17837: LD_ADDR_VAR 0 12
17841: PUSH
17842: LD_VAR 0 2
17846: PPUSH
17847: LD_INT 19
17849: PPUSH
17850: CALL 54626 0 2
17854: ST_TO_ADDR
// if tmp then
17855: LD_VAR 0 12
17859: IFFALSE 17929
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
17861: LD_ADDR_VAR 0 12
17865: PUSH
17866: LD_VAR 0 12
17870: PPUSH
17871: LD_INT 25
17873: PUSH
17874: LD_INT 3
17876: PUSH
17877: EMPTY
17878: LIST
17879: LIST
17880: PPUSH
17881: CALL_OW 72
17885: ST_TO_ADDR
// if tmp then
17886: LD_VAR 0 12
17890: IFFALSE 17929
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
17892: LD_ADDR_EXP 70
17896: PUSH
17897: LD_EXP 70
17901: PPUSH
17902: LD_VAR 0 1
17906: PPUSH
17907: LD_EXP 70
17911: PUSH
17912: LD_VAR 0 1
17916: ARRAY
17917: PUSH
17918: LD_VAR 0 12
17922: UNION
17923: PPUSH
17924: CALL_OW 1
17928: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
17929: LD_VAR 0 1
17933: PPUSH
17934: LD_INT 19
17936: PPUSH
17937: CALL 61369 0 2
// repeat wait ( 0 0$1 ) ;
17941: LD_INT 35
17943: PPUSH
17944: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
17948: LD_EXP 58
17952: PUSH
17953: LD_VAR 0 1
17957: ARRAY
17958: NOT
17959: PUSH
17960: LD_EXP 58
17964: PUSH
17965: LD_VAR 0 1
17969: ARRAY
17970: PUSH
17971: EMPTY
17972: EQUAL
17973: OR
17974: IFFALSE 18011
// begin for i in defenders do
17976: LD_ADDR_VAR 0 5
17980: PUSH
17981: LD_VAR 0 2
17985: PUSH
17986: FOR_IN
17987: IFFALSE 18000
// ComStop ( i ) ;
17989: LD_VAR 0 5
17993: PPUSH
17994: CALL_OW 141
17998: GO 17986
18000: POP
18001: POP
// defenders := [ ] ;
18002: LD_ADDR_VAR 0 2
18006: PUSH
18007: EMPTY
18008: ST_TO_ADDR
// exit ;
18009: GO 18197
// end ; for i in defenders do
18011: LD_ADDR_VAR 0 5
18015: PUSH
18016: LD_VAR 0 2
18020: PUSH
18021: FOR_IN
18022: IFFALSE 18111
// begin if not IsInArea ( i , mc_parking [ base ] ) then
18024: LD_VAR 0 5
18028: PPUSH
18029: LD_EXP 82
18033: PUSH
18034: LD_VAR 0 1
18038: ARRAY
18039: PPUSH
18040: CALL_OW 308
18044: NOT
18045: IFFALSE 18069
// ComMoveToArea ( i , mc_parking [ base ] ) else
18047: LD_VAR 0 5
18051: PPUSH
18052: LD_EXP 82
18056: PUSH
18057: LD_VAR 0 1
18061: ARRAY
18062: PPUSH
18063: CALL_OW 113
18067: GO 18109
// if GetControl ( i ) = control_manual then
18069: LD_VAR 0 5
18073: PPUSH
18074: CALL_OW 263
18078: PUSH
18079: LD_INT 1
18081: EQUAL
18082: IFFALSE 18109
// if IsDrivenBy ( i ) then
18084: LD_VAR 0 5
18088: PPUSH
18089: CALL_OW 311
18093: IFFALSE 18109
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
18095: LD_VAR 0 5
18099: PPUSH
18100: CALL_OW 311
18104: PPUSH
18105: CALL_OW 121
// end ;
18109: GO 18021
18111: POP
18112: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
18113: LD_VAR 0 2
18117: PPUSH
18118: LD_INT 95
18120: PUSH
18121: LD_EXP 82
18125: PUSH
18126: LD_VAR 0 1
18130: ARRAY
18131: PUSH
18132: EMPTY
18133: LIST
18134: LIST
18135: PPUSH
18136: CALL_OW 72
18140: PUSH
18141: LD_VAR 0 2
18145: EQUAL
18146: PUSH
18147: LD_EXP 81
18151: PUSH
18152: LD_VAR 0 1
18156: ARRAY
18157: OR
18158: PUSH
18159: LD_EXP 58
18163: PUSH
18164: LD_VAR 0 1
18168: ARRAY
18169: NOT
18170: OR
18171: IFFALSE 17941
// end ; MC_Reset ( base , 19 ) ;
18173: LD_VAR 0 1
18177: PPUSH
18178: LD_INT 19
18180: PPUSH
18181: CALL 61369 0 2
// MC_Reset ( base , 20 ) ;
18185: LD_VAR 0 1
18189: PPUSH
18190: LD_INT 20
18192: PPUSH
18193: CALL 61369 0 2
// end ;
18197: LD_VAR 0 4
18201: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
18202: LD_INT 0
18204: PPUSH
18205: PPUSH
18206: PPUSH
18207: PPUSH
// result := false ;
18208: LD_ADDR_VAR 0 2
18212: PUSH
18213: LD_INT 0
18215: ST_TO_ADDR
// side := GetSide ( unit ) ;
18216: LD_ADDR_VAR 0 3
18220: PUSH
18221: LD_VAR 0 1
18225: PPUSH
18226: CALL_OW 255
18230: ST_TO_ADDR
// nat := GetNation ( unit ) ;
18231: LD_ADDR_VAR 0 4
18235: PUSH
18236: LD_VAR 0 1
18240: PPUSH
18241: CALL_OW 248
18245: ST_TO_ADDR
// case nat of 1 :
18246: LD_VAR 0 4
18250: PUSH
18251: LD_INT 1
18253: DOUBLE
18254: EQUAL
18255: IFTRUE 18259
18257: GO 18270
18259: POP
// tech := tech_lassight ; 2 :
18260: LD_ADDR_VAR 0 5
18264: PUSH
18265: LD_INT 12
18267: ST_TO_ADDR
18268: GO 18309
18270: LD_INT 2
18272: DOUBLE
18273: EQUAL
18274: IFTRUE 18278
18276: GO 18289
18278: POP
// tech := tech_mortar ; 3 :
18279: LD_ADDR_VAR 0 5
18283: PUSH
18284: LD_INT 41
18286: ST_TO_ADDR
18287: GO 18309
18289: LD_INT 3
18291: DOUBLE
18292: EQUAL
18293: IFTRUE 18297
18295: GO 18308
18297: POP
// tech := tech_bazooka ; end ;
18298: LD_ADDR_VAR 0 5
18302: PUSH
18303: LD_INT 44
18305: ST_TO_ADDR
18306: GO 18309
18308: POP
// if Researched ( side , tech ) then
18309: LD_VAR 0 3
18313: PPUSH
18314: LD_VAR 0 5
18318: PPUSH
18319: CALL_OW 325
18323: IFFALSE 18350
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
18325: LD_ADDR_VAR 0 2
18329: PUSH
18330: LD_INT 5
18332: PUSH
18333: LD_INT 8
18335: PUSH
18336: LD_INT 9
18338: PUSH
18339: EMPTY
18340: LIST
18341: LIST
18342: LIST
18343: PUSH
18344: LD_VAR 0 4
18348: ARRAY
18349: ST_TO_ADDR
// end ;
18350: LD_VAR 0 2
18354: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
18355: LD_INT 0
18357: PPUSH
18358: PPUSH
18359: PPUSH
// if not mines then
18360: LD_VAR 0 2
18364: NOT
18365: IFFALSE 18369
// exit ;
18367: GO 18513
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18369: LD_ADDR_VAR 0 5
18373: PUSH
18374: LD_INT 81
18376: PUSH
18377: LD_VAR 0 1
18381: PUSH
18382: EMPTY
18383: LIST
18384: LIST
18385: PUSH
18386: LD_INT 3
18388: PUSH
18389: LD_INT 21
18391: PUSH
18392: LD_INT 3
18394: PUSH
18395: EMPTY
18396: LIST
18397: LIST
18398: PUSH
18399: EMPTY
18400: LIST
18401: LIST
18402: PUSH
18403: EMPTY
18404: LIST
18405: LIST
18406: PPUSH
18407: CALL_OW 69
18411: ST_TO_ADDR
// for i in mines do
18412: LD_ADDR_VAR 0 4
18416: PUSH
18417: LD_VAR 0 2
18421: PUSH
18422: FOR_IN
18423: IFFALSE 18511
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
18425: LD_VAR 0 4
18429: PUSH
18430: LD_INT 1
18432: ARRAY
18433: PPUSH
18434: LD_VAR 0 4
18438: PUSH
18439: LD_INT 2
18441: ARRAY
18442: PPUSH
18443: CALL_OW 458
18447: NOT
18448: IFFALSE 18452
// continue ;
18450: GO 18422
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
18452: LD_VAR 0 4
18456: PUSH
18457: LD_INT 1
18459: ARRAY
18460: PPUSH
18461: LD_VAR 0 4
18465: PUSH
18466: LD_INT 2
18468: ARRAY
18469: PPUSH
18470: CALL_OW 428
18474: PUSH
18475: LD_VAR 0 5
18479: IN
18480: IFFALSE 18509
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
18482: LD_VAR 0 4
18486: PUSH
18487: LD_INT 1
18489: ARRAY
18490: PPUSH
18491: LD_VAR 0 4
18495: PUSH
18496: LD_INT 2
18498: ARRAY
18499: PPUSH
18500: LD_VAR 0 1
18504: PPUSH
18505: CALL_OW 456
// end ;
18509: GO 18422
18511: POP
18512: POP
// end ;
18513: LD_VAR 0 3
18517: RET
// export function Count ( array ) ; var i ; begin
18518: LD_INT 0
18520: PPUSH
18521: PPUSH
// result := 0 ;
18522: LD_ADDR_VAR 0 2
18526: PUSH
18527: LD_INT 0
18529: ST_TO_ADDR
// for i in array do
18530: LD_ADDR_VAR 0 3
18534: PUSH
18535: LD_VAR 0 1
18539: PUSH
18540: FOR_IN
18541: IFFALSE 18565
// if i then
18543: LD_VAR 0 3
18547: IFFALSE 18563
// result := result + 1 ;
18549: LD_ADDR_VAR 0 2
18553: PUSH
18554: LD_VAR 0 2
18558: PUSH
18559: LD_INT 1
18561: PLUS
18562: ST_TO_ADDR
18563: GO 18540
18565: POP
18566: POP
// end ;
18567: LD_VAR 0 2
18571: RET
// export function IsEmpty ( building ) ; begin
18572: LD_INT 0
18574: PPUSH
// if not building then
18575: LD_VAR 0 1
18579: NOT
18580: IFFALSE 18584
// exit ;
18582: GO 18627
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18584: LD_ADDR_VAR 0 2
18588: PUSH
18589: LD_VAR 0 1
18593: PUSH
18594: LD_INT 22
18596: PUSH
18597: LD_VAR 0 1
18601: PPUSH
18602: CALL_OW 255
18606: PUSH
18607: EMPTY
18608: LIST
18609: LIST
18610: PUSH
18611: LD_INT 58
18613: PUSH
18614: EMPTY
18615: LIST
18616: PUSH
18617: EMPTY
18618: LIST
18619: LIST
18620: PPUSH
18621: CALL_OW 69
18625: IN
18626: ST_TO_ADDR
// end ;
18627: LD_VAR 0 2
18631: RET
// export function IsNotFull ( building ) ; begin
18632: LD_INT 0
18634: PPUSH
// if not building then
18635: LD_VAR 0 1
18639: NOT
18640: IFFALSE 18644
// exit ;
18642: GO 18663
// result := UnitsInside ( building ) < 6 ;
18644: LD_ADDR_VAR 0 2
18648: PUSH
18649: LD_VAR 0 1
18653: PPUSH
18654: CALL_OW 313
18658: PUSH
18659: LD_INT 6
18661: LESS
18662: ST_TO_ADDR
// end ;
18663: LD_VAR 0 2
18667: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18668: LD_INT 0
18670: PPUSH
18671: PPUSH
18672: PPUSH
18673: PPUSH
// tmp := [ ] ;
18674: LD_ADDR_VAR 0 3
18678: PUSH
18679: EMPTY
18680: ST_TO_ADDR
// list := [ ] ;
18681: LD_ADDR_VAR 0 5
18685: PUSH
18686: EMPTY
18687: ST_TO_ADDR
// for i = 16 to 25 do
18688: LD_ADDR_VAR 0 4
18692: PUSH
18693: DOUBLE
18694: LD_INT 16
18696: DEC
18697: ST_TO_ADDR
18698: LD_INT 25
18700: PUSH
18701: FOR_TO
18702: IFFALSE 18775
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18704: LD_ADDR_VAR 0 3
18708: PUSH
18709: LD_VAR 0 3
18713: PUSH
18714: LD_INT 22
18716: PUSH
18717: LD_VAR 0 1
18721: PPUSH
18722: CALL_OW 255
18726: PUSH
18727: EMPTY
18728: LIST
18729: LIST
18730: PUSH
18731: LD_INT 91
18733: PUSH
18734: LD_VAR 0 1
18738: PUSH
18739: LD_INT 6
18741: PUSH
18742: EMPTY
18743: LIST
18744: LIST
18745: LIST
18746: PUSH
18747: LD_INT 30
18749: PUSH
18750: LD_VAR 0 4
18754: PUSH
18755: EMPTY
18756: LIST
18757: LIST
18758: PUSH
18759: EMPTY
18760: LIST
18761: LIST
18762: LIST
18763: PUSH
18764: EMPTY
18765: LIST
18766: PPUSH
18767: CALL_OW 69
18771: ADD
18772: ST_TO_ADDR
18773: GO 18701
18775: POP
18776: POP
// for i = 1 to tmp do
18777: LD_ADDR_VAR 0 4
18781: PUSH
18782: DOUBLE
18783: LD_INT 1
18785: DEC
18786: ST_TO_ADDR
18787: LD_VAR 0 3
18791: PUSH
18792: FOR_TO
18793: IFFALSE 18881
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18795: LD_ADDR_VAR 0 5
18799: PUSH
18800: LD_VAR 0 5
18804: PUSH
18805: LD_VAR 0 3
18809: PUSH
18810: LD_VAR 0 4
18814: ARRAY
18815: PPUSH
18816: CALL_OW 266
18820: PUSH
18821: LD_VAR 0 3
18825: PUSH
18826: LD_VAR 0 4
18830: ARRAY
18831: PPUSH
18832: CALL_OW 250
18836: PUSH
18837: LD_VAR 0 3
18841: PUSH
18842: LD_VAR 0 4
18846: ARRAY
18847: PPUSH
18848: CALL_OW 251
18852: PUSH
18853: LD_VAR 0 3
18857: PUSH
18858: LD_VAR 0 4
18862: ARRAY
18863: PPUSH
18864: CALL_OW 254
18868: PUSH
18869: EMPTY
18870: LIST
18871: LIST
18872: LIST
18873: LIST
18874: PUSH
18875: EMPTY
18876: LIST
18877: ADD
18878: ST_TO_ADDR
18879: GO 18792
18881: POP
18882: POP
// result := list ;
18883: LD_ADDR_VAR 0 2
18887: PUSH
18888: LD_VAR 0 5
18892: ST_TO_ADDR
// end ;
18893: LD_VAR 0 2
18897: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18898: LD_INT 0
18900: PPUSH
18901: PPUSH
18902: PPUSH
18903: PPUSH
18904: PPUSH
18905: PPUSH
18906: PPUSH
// if not factory then
18907: LD_VAR 0 1
18911: NOT
18912: IFFALSE 18916
// exit ;
18914: GO 19509
// if control = control_apeman then
18916: LD_VAR 0 4
18920: PUSH
18921: LD_INT 5
18923: EQUAL
18924: IFFALSE 19033
// begin tmp := UnitsInside ( factory ) ;
18926: LD_ADDR_VAR 0 8
18930: PUSH
18931: LD_VAR 0 1
18935: PPUSH
18936: CALL_OW 313
18940: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18941: LD_VAR 0 8
18945: PPUSH
18946: LD_INT 25
18948: PUSH
18949: LD_INT 12
18951: PUSH
18952: EMPTY
18953: LIST
18954: LIST
18955: PPUSH
18956: CALL_OW 72
18960: NOT
18961: IFFALSE 18971
// control := control_manual ;
18963: LD_ADDR_VAR 0 4
18967: PUSH
18968: LD_INT 1
18970: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18971: LD_ADDR_VAR 0 8
18975: PUSH
18976: LD_VAR 0 1
18980: PPUSH
18981: CALL 18668 0 1
18985: ST_TO_ADDR
// if tmp then
18986: LD_VAR 0 8
18990: IFFALSE 19033
// begin for i in tmp do
18992: LD_ADDR_VAR 0 7
18996: PUSH
18997: LD_VAR 0 8
19001: PUSH
19002: FOR_IN
19003: IFFALSE 19031
// if i [ 1 ] = b_ext_radio then
19005: LD_VAR 0 7
19009: PUSH
19010: LD_INT 1
19012: ARRAY
19013: PUSH
19014: LD_INT 22
19016: EQUAL
19017: IFFALSE 19029
// begin control := control_remote ;
19019: LD_ADDR_VAR 0 4
19023: PUSH
19024: LD_INT 2
19026: ST_TO_ADDR
// break ;
19027: GO 19031
// end ;
19029: GO 19002
19031: POP
19032: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19033: LD_VAR 0 1
19037: PPUSH
19038: LD_VAR 0 2
19042: PPUSH
19043: LD_VAR 0 3
19047: PPUSH
19048: LD_VAR 0 4
19052: PPUSH
19053: LD_VAR 0 5
19057: PPUSH
19058: CALL_OW 448
19062: IFFALSE 19097
// begin result := [ chassis , engine , control , weapon ] ;
19064: LD_ADDR_VAR 0 6
19068: PUSH
19069: LD_VAR 0 2
19073: PUSH
19074: LD_VAR 0 3
19078: PUSH
19079: LD_VAR 0 4
19083: PUSH
19084: LD_VAR 0 5
19088: PUSH
19089: EMPTY
19090: LIST
19091: LIST
19092: LIST
19093: LIST
19094: ST_TO_ADDR
// exit ;
19095: GO 19509
// end ; _chassis := AvailableChassisList ( factory ) ;
19097: LD_ADDR_VAR 0 9
19101: PUSH
19102: LD_VAR 0 1
19106: PPUSH
19107: CALL_OW 475
19111: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
19112: LD_ADDR_VAR 0 11
19116: PUSH
19117: LD_VAR 0 1
19121: PPUSH
19122: CALL_OW 476
19126: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
19127: LD_ADDR_VAR 0 12
19131: PUSH
19132: LD_VAR 0 1
19136: PPUSH
19137: CALL_OW 477
19141: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
19142: LD_ADDR_VAR 0 10
19146: PUSH
19147: LD_VAR 0 1
19151: PPUSH
19152: CALL_OW 478
19156: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
19157: LD_VAR 0 9
19161: NOT
19162: PUSH
19163: LD_VAR 0 11
19167: NOT
19168: OR
19169: PUSH
19170: LD_VAR 0 12
19174: NOT
19175: OR
19176: PUSH
19177: LD_VAR 0 10
19181: NOT
19182: OR
19183: IFFALSE 19218
// begin result := [ chassis , engine , control , weapon ] ;
19185: LD_ADDR_VAR 0 6
19189: PUSH
19190: LD_VAR 0 2
19194: PUSH
19195: LD_VAR 0 3
19199: PUSH
19200: LD_VAR 0 4
19204: PUSH
19205: LD_VAR 0 5
19209: PUSH
19210: EMPTY
19211: LIST
19212: LIST
19213: LIST
19214: LIST
19215: ST_TO_ADDR
// exit ;
19216: GO 19509
// end ; if not chassis in _chassis then
19218: LD_VAR 0 2
19222: PUSH
19223: LD_VAR 0 9
19227: IN
19228: NOT
19229: IFFALSE 19255
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
19231: LD_ADDR_VAR 0 2
19235: PUSH
19236: LD_VAR 0 9
19240: PUSH
19241: LD_INT 1
19243: PPUSH
19244: LD_VAR 0 9
19248: PPUSH
19249: CALL_OW 12
19253: ARRAY
19254: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
19255: LD_VAR 0 2
19259: PPUSH
19260: LD_VAR 0 3
19264: PPUSH
19265: CALL 19514 0 2
19269: NOT
19270: IFFALSE 19329
// repeat engine := _engine [ 1 ] ;
19272: LD_ADDR_VAR 0 3
19276: PUSH
19277: LD_VAR 0 11
19281: PUSH
19282: LD_INT 1
19284: ARRAY
19285: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
19286: LD_ADDR_VAR 0 11
19290: PUSH
19291: LD_VAR 0 11
19295: PPUSH
19296: LD_INT 1
19298: PPUSH
19299: CALL_OW 3
19303: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
19304: LD_VAR 0 2
19308: PPUSH
19309: LD_VAR 0 3
19313: PPUSH
19314: CALL 19514 0 2
19318: PUSH
19319: LD_VAR 0 11
19323: PUSH
19324: EMPTY
19325: EQUAL
19326: OR
19327: IFFALSE 19272
// if not control in _control then
19329: LD_VAR 0 4
19333: PUSH
19334: LD_VAR 0 12
19338: IN
19339: NOT
19340: IFFALSE 19366
// control := _control [ rand ( 1 , _control ) ] ;
19342: LD_ADDR_VAR 0 4
19346: PUSH
19347: LD_VAR 0 12
19351: PUSH
19352: LD_INT 1
19354: PPUSH
19355: LD_VAR 0 12
19359: PPUSH
19360: CALL_OW 12
19364: ARRAY
19365: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
19366: LD_VAR 0 2
19370: PPUSH
19371: LD_VAR 0 5
19375: PPUSH
19376: CALL 19734 0 2
19380: NOT
19381: IFFALSE 19440
// repeat weapon := _weapon [ 1 ] ;
19383: LD_ADDR_VAR 0 5
19387: PUSH
19388: LD_VAR 0 10
19392: PUSH
19393: LD_INT 1
19395: ARRAY
19396: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
19397: LD_ADDR_VAR 0 10
19401: PUSH
19402: LD_VAR 0 10
19406: PPUSH
19407: LD_INT 1
19409: PPUSH
19410: CALL_OW 3
19414: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
19415: LD_VAR 0 2
19419: PPUSH
19420: LD_VAR 0 5
19424: PPUSH
19425: CALL 19734 0 2
19429: PUSH
19430: LD_VAR 0 10
19434: PUSH
19435: EMPTY
19436: EQUAL
19437: OR
19438: IFFALSE 19383
// result := [ ] ;
19440: LD_ADDR_VAR 0 6
19444: PUSH
19445: EMPTY
19446: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19447: LD_VAR 0 1
19451: PPUSH
19452: LD_VAR 0 2
19456: PPUSH
19457: LD_VAR 0 3
19461: PPUSH
19462: LD_VAR 0 4
19466: PPUSH
19467: LD_VAR 0 5
19471: PPUSH
19472: CALL_OW 448
19476: IFFALSE 19509
// result := [ chassis , engine , control , weapon ] ;
19478: LD_ADDR_VAR 0 6
19482: PUSH
19483: LD_VAR 0 2
19487: PUSH
19488: LD_VAR 0 3
19492: PUSH
19493: LD_VAR 0 4
19497: PUSH
19498: LD_VAR 0 5
19502: PUSH
19503: EMPTY
19504: LIST
19505: LIST
19506: LIST
19507: LIST
19508: ST_TO_ADDR
// end ;
19509: LD_VAR 0 6
19513: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
19514: LD_INT 0
19516: PPUSH
// if not chassis or not engine then
19517: LD_VAR 0 1
19521: NOT
19522: PUSH
19523: LD_VAR 0 2
19527: NOT
19528: OR
19529: IFFALSE 19533
// exit ;
19531: GO 19729
// case engine of engine_solar :
19533: LD_VAR 0 2
19537: PUSH
19538: LD_INT 2
19540: DOUBLE
19541: EQUAL
19542: IFTRUE 19546
19544: GO 19584
19546: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19547: LD_ADDR_VAR 0 3
19551: PUSH
19552: LD_INT 11
19554: PUSH
19555: LD_INT 12
19557: PUSH
19558: LD_INT 13
19560: PUSH
19561: LD_INT 14
19563: PUSH
19564: LD_INT 1
19566: PUSH
19567: LD_INT 2
19569: PUSH
19570: LD_INT 3
19572: PUSH
19573: EMPTY
19574: LIST
19575: LIST
19576: LIST
19577: LIST
19578: LIST
19579: LIST
19580: LIST
19581: ST_TO_ADDR
19582: GO 19713
19584: LD_INT 1
19586: DOUBLE
19587: EQUAL
19588: IFTRUE 19592
19590: GO 19654
19592: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19593: LD_ADDR_VAR 0 3
19597: PUSH
19598: LD_INT 11
19600: PUSH
19601: LD_INT 12
19603: PUSH
19604: LD_INT 13
19606: PUSH
19607: LD_INT 14
19609: PUSH
19610: LD_INT 1
19612: PUSH
19613: LD_INT 2
19615: PUSH
19616: LD_INT 3
19618: PUSH
19619: LD_INT 4
19621: PUSH
19622: LD_INT 5
19624: PUSH
19625: LD_INT 21
19627: PUSH
19628: LD_INT 23
19630: PUSH
19631: LD_INT 22
19633: PUSH
19634: LD_INT 24
19636: PUSH
19637: EMPTY
19638: LIST
19639: LIST
19640: LIST
19641: LIST
19642: LIST
19643: LIST
19644: LIST
19645: LIST
19646: LIST
19647: LIST
19648: LIST
19649: LIST
19650: LIST
19651: ST_TO_ADDR
19652: GO 19713
19654: LD_INT 3
19656: DOUBLE
19657: EQUAL
19658: IFTRUE 19662
19660: GO 19712
19662: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19663: LD_ADDR_VAR 0 3
19667: PUSH
19668: LD_INT 13
19670: PUSH
19671: LD_INT 14
19673: PUSH
19674: LD_INT 2
19676: PUSH
19677: LD_INT 3
19679: PUSH
19680: LD_INT 4
19682: PUSH
19683: LD_INT 5
19685: PUSH
19686: LD_INT 21
19688: PUSH
19689: LD_INT 22
19691: PUSH
19692: LD_INT 23
19694: PUSH
19695: LD_INT 24
19697: PUSH
19698: EMPTY
19699: LIST
19700: LIST
19701: LIST
19702: LIST
19703: LIST
19704: LIST
19705: LIST
19706: LIST
19707: LIST
19708: LIST
19709: ST_TO_ADDR
19710: GO 19713
19712: POP
// result := ( chassis in result ) ;
19713: LD_ADDR_VAR 0 3
19717: PUSH
19718: LD_VAR 0 1
19722: PUSH
19723: LD_VAR 0 3
19727: IN
19728: ST_TO_ADDR
// end ;
19729: LD_VAR 0 3
19733: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19734: LD_INT 0
19736: PPUSH
// if not chassis or not weapon then
19737: LD_VAR 0 1
19741: NOT
19742: PUSH
19743: LD_VAR 0 2
19747: NOT
19748: OR
19749: IFFALSE 19753
// exit ;
19751: GO 20779
// case weapon of us_machine_gun :
19753: LD_VAR 0 2
19757: PUSH
19758: LD_INT 2
19760: DOUBLE
19761: EQUAL
19762: IFTRUE 19766
19764: GO 19796
19766: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19767: LD_ADDR_VAR 0 3
19771: PUSH
19772: LD_INT 1
19774: PUSH
19775: LD_INT 2
19777: PUSH
19778: LD_INT 3
19780: PUSH
19781: LD_INT 4
19783: PUSH
19784: LD_INT 5
19786: PUSH
19787: EMPTY
19788: LIST
19789: LIST
19790: LIST
19791: LIST
19792: LIST
19793: ST_TO_ADDR
19794: GO 20763
19796: LD_INT 3
19798: DOUBLE
19799: EQUAL
19800: IFTRUE 19804
19802: GO 19834
19804: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19805: LD_ADDR_VAR 0 3
19809: PUSH
19810: LD_INT 1
19812: PUSH
19813: LD_INT 2
19815: PUSH
19816: LD_INT 3
19818: PUSH
19819: LD_INT 4
19821: PUSH
19822: LD_INT 5
19824: PUSH
19825: EMPTY
19826: LIST
19827: LIST
19828: LIST
19829: LIST
19830: LIST
19831: ST_TO_ADDR
19832: GO 20763
19834: LD_INT 11
19836: DOUBLE
19837: EQUAL
19838: IFTRUE 19842
19840: GO 19872
19842: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19843: LD_ADDR_VAR 0 3
19847: PUSH
19848: LD_INT 1
19850: PUSH
19851: LD_INT 2
19853: PUSH
19854: LD_INT 3
19856: PUSH
19857: LD_INT 4
19859: PUSH
19860: LD_INT 5
19862: PUSH
19863: EMPTY
19864: LIST
19865: LIST
19866: LIST
19867: LIST
19868: LIST
19869: ST_TO_ADDR
19870: GO 20763
19872: LD_INT 4
19874: DOUBLE
19875: EQUAL
19876: IFTRUE 19880
19878: GO 19906
19880: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19881: LD_ADDR_VAR 0 3
19885: PUSH
19886: LD_INT 2
19888: PUSH
19889: LD_INT 3
19891: PUSH
19892: LD_INT 4
19894: PUSH
19895: LD_INT 5
19897: PUSH
19898: EMPTY
19899: LIST
19900: LIST
19901: LIST
19902: LIST
19903: ST_TO_ADDR
19904: GO 20763
19906: LD_INT 5
19908: DOUBLE
19909: EQUAL
19910: IFTRUE 19914
19912: GO 19940
19914: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19915: LD_ADDR_VAR 0 3
19919: PUSH
19920: LD_INT 2
19922: PUSH
19923: LD_INT 3
19925: PUSH
19926: LD_INT 4
19928: PUSH
19929: LD_INT 5
19931: PUSH
19932: EMPTY
19933: LIST
19934: LIST
19935: LIST
19936: LIST
19937: ST_TO_ADDR
19938: GO 20763
19940: LD_INT 9
19942: DOUBLE
19943: EQUAL
19944: IFTRUE 19948
19946: GO 19974
19948: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19949: LD_ADDR_VAR 0 3
19953: PUSH
19954: LD_INT 2
19956: PUSH
19957: LD_INT 3
19959: PUSH
19960: LD_INT 4
19962: PUSH
19963: LD_INT 5
19965: PUSH
19966: EMPTY
19967: LIST
19968: LIST
19969: LIST
19970: LIST
19971: ST_TO_ADDR
19972: GO 20763
19974: LD_INT 7
19976: DOUBLE
19977: EQUAL
19978: IFTRUE 19982
19980: GO 20008
19982: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19983: LD_ADDR_VAR 0 3
19987: PUSH
19988: LD_INT 2
19990: PUSH
19991: LD_INT 3
19993: PUSH
19994: LD_INT 4
19996: PUSH
19997: LD_INT 5
19999: PUSH
20000: EMPTY
20001: LIST
20002: LIST
20003: LIST
20004: LIST
20005: ST_TO_ADDR
20006: GO 20763
20008: LD_INT 12
20010: DOUBLE
20011: EQUAL
20012: IFTRUE 20016
20014: GO 20042
20016: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
20017: LD_ADDR_VAR 0 3
20021: PUSH
20022: LD_INT 2
20024: PUSH
20025: LD_INT 3
20027: PUSH
20028: LD_INT 4
20030: PUSH
20031: LD_INT 5
20033: PUSH
20034: EMPTY
20035: LIST
20036: LIST
20037: LIST
20038: LIST
20039: ST_TO_ADDR
20040: GO 20763
20042: LD_INT 13
20044: DOUBLE
20045: EQUAL
20046: IFTRUE 20050
20048: GO 20076
20050: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
20051: LD_ADDR_VAR 0 3
20055: PUSH
20056: LD_INT 2
20058: PUSH
20059: LD_INT 3
20061: PUSH
20062: LD_INT 4
20064: PUSH
20065: LD_INT 5
20067: PUSH
20068: EMPTY
20069: LIST
20070: LIST
20071: LIST
20072: LIST
20073: ST_TO_ADDR
20074: GO 20763
20076: LD_INT 14
20078: DOUBLE
20079: EQUAL
20080: IFTRUE 20084
20082: GO 20102
20084: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
20085: LD_ADDR_VAR 0 3
20089: PUSH
20090: LD_INT 4
20092: PUSH
20093: LD_INT 5
20095: PUSH
20096: EMPTY
20097: LIST
20098: LIST
20099: ST_TO_ADDR
20100: GO 20763
20102: LD_INT 6
20104: DOUBLE
20105: EQUAL
20106: IFTRUE 20110
20108: GO 20128
20110: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
20111: LD_ADDR_VAR 0 3
20115: PUSH
20116: LD_INT 4
20118: PUSH
20119: LD_INT 5
20121: PUSH
20122: EMPTY
20123: LIST
20124: LIST
20125: ST_TO_ADDR
20126: GO 20763
20128: LD_INT 10
20130: DOUBLE
20131: EQUAL
20132: IFTRUE 20136
20134: GO 20154
20136: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
20137: LD_ADDR_VAR 0 3
20141: PUSH
20142: LD_INT 4
20144: PUSH
20145: LD_INT 5
20147: PUSH
20148: EMPTY
20149: LIST
20150: LIST
20151: ST_TO_ADDR
20152: GO 20763
20154: LD_INT 22
20156: DOUBLE
20157: EQUAL
20158: IFTRUE 20162
20160: GO 20188
20162: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
20163: LD_ADDR_VAR 0 3
20167: PUSH
20168: LD_INT 11
20170: PUSH
20171: LD_INT 12
20173: PUSH
20174: LD_INT 13
20176: PUSH
20177: LD_INT 14
20179: PUSH
20180: EMPTY
20181: LIST
20182: LIST
20183: LIST
20184: LIST
20185: ST_TO_ADDR
20186: GO 20763
20188: LD_INT 23
20190: DOUBLE
20191: EQUAL
20192: IFTRUE 20196
20194: GO 20222
20196: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
20197: LD_ADDR_VAR 0 3
20201: PUSH
20202: LD_INT 11
20204: PUSH
20205: LD_INT 12
20207: PUSH
20208: LD_INT 13
20210: PUSH
20211: LD_INT 14
20213: PUSH
20214: EMPTY
20215: LIST
20216: LIST
20217: LIST
20218: LIST
20219: ST_TO_ADDR
20220: GO 20763
20222: LD_INT 24
20224: DOUBLE
20225: EQUAL
20226: IFTRUE 20230
20228: GO 20256
20230: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
20231: LD_ADDR_VAR 0 3
20235: PUSH
20236: LD_INT 11
20238: PUSH
20239: LD_INT 12
20241: PUSH
20242: LD_INT 13
20244: PUSH
20245: LD_INT 14
20247: PUSH
20248: EMPTY
20249: LIST
20250: LIST
20251: LIST
20252: LIST
20253: ST_TO_ADDR
20254: GO 20763
20256: LD_INT 30
20258: DOUBLE
20259: EQUAL
20260: IFTRUE 20264
20262: GO 20290
20264: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
20265: LD_ADDR_VAR 0 3
20269: PUSH
20270: LD_INT 11
20272: PUSH
20273: LD_INT 12
20275: PUSH
20276: LD_INT 13
20278: PUSH
20279: LD_INT 14
20281: PUSH
20282: EMPTY
20283: LIST
20284: LIST
20285: LIST
20286: LIST
20287: ST_TO_ADDR
20288: GO 20763
20290: LD_INT 25
20292: DOUBLE
20293: EQUAL
20294: IFTRUE 20298
20296: GO 20316
20298: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
20299: LD_ADDR_VAR 0 3
20303: PUSH
20304: LD_INT 13
20306: PUSH
20307: LD_INT 14
20309: PUSH
20310: EMPTY
20311: LIST
20312: LIST
20313: ST_TO_ADDR
20314: GO 20763
20316: LD_INT 27
20318: DOUBLE
20319: EQUAL
20320: IFTRUE 20324
20322: GO 20342
20324: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
20325: LD_ADDR_VAR 0 3
20329: PUSH
20330: LD_INT 13
20332: PUSH
20333: LD_INT 14
20335: PUSH
20336: EMPTY
20337: LIST
20338: LIST
20339: ST_TO_ADDR
20340: GO 20763
20342: LD_INT 28
20344: DOUBLE
20345: EQUAL
20346: IFTRUE 20350
20348: GO 20368
20350: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
20351: LD_ADDR_VAR 0 3
20355: PUSH
20356: LD_INT 13
20358: PUSH
20359: LD_INT 14
20361: PUSH
20362: EMPTY
20363: LIST
20364: LIST
20365: ST_TO_ADDR
20366: GO 20763
20368: LD_INT 29
20370: DOUBLE
20371: EQUAL
20372: IFTRUE 20376
20374: GO 20394
20376: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
20377: LD_ADDR_VAR 0 3
20381: PUSH
20382: LD_INT 13
20384: PUSH
20385: LD_INT 14
20387: PUSH
20388: EMPTY
20389: LIST
20390: LIST
20391: ST_TO_ADDR
20392: GO 20763
20394: LD_INT 31
20396: DOUBLE
20397: EQUAL
20398: IFTRUE 20402
20400: GO 20420
20402: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
20403: LD_ADDR_VAR 0 3
20407: PUSH
20408: LD_INT 13
20410: PUSH
20411: LD_INT 14
20413: PUSH
20414: EMPTY
20415: LIST
20416: LIST
20417: ST_TO_ADDR
20418: GO 20763
20420: LD_INT 26
20422: DOUBLE
20423: EQUAL
20424: IFTRUE 20428
20426: GO 20446
20428: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
20429: LD_ADDR_VAR 0 3
20433: PUSH
20434: LD_INT 13
20436: PUSH
20437: LD_INT 14
20439: PUSH
20440: EMPTY
20441: LIST
20442: LIST
20443: ST_TO_ADDR
20444: GO 20763
20446: LD_INT 42
20448: DOUBLE
20449: EQUAL
20450: IFTRUE 20454
20452: GO 20480
20454: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
20455: LD_ADDR_VAR 0 3
20459: PUSH
20460: LD_INT 21
20462: PUSH
20463: LD_INT 22
20465: PUSH
20466: LD_INT 23
20468: PUSH
20469: LD_INT 24
20471: PUSH
20472: EMPTY
20473: LIST
20474: LIST
20475: LIST
20476: LIST
20477: ST_TO_ADDR
20478: GO 20763
20480: LD_INT 43
20482: DOUBLE
20483: EQUAL
20484: IFTRUE 20488
20486: GO 20514
20488: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
20489: LD_ADDR_VAR 0 3
20493: PUSH
20494: LD_INT 21
20496: PUSH
20497: LD_INT 22
20499: PUSH
20500: LD_INT 23
20502: PUSH
20503: LD_INT 24
20505: PUSH
20506: EMPTY
20507: LIST
20508: LIST
20509: LIST
20510: LIST
20511: ST_TO_ADDR
20512: GO 20763
20514: LD_INT 44
20516: DOUBLE
20517: EQUAL
20518: IFTRUE 20522
20520: GO 20548
20522: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
20523: LD_ADDR_VAR 0 3
20527: PUSH
20528: LD_INT 21
20530: PUSH
20531: LD_INT 22
20533: PUSH
20534: LD_INT 23
20536: PUSH
20537: LD_INT 24
20539: PUSH
20540: EMPTY
20541: LIST
20542: LIST
20543: LIST
20544: LIST
20545: ST_TO_ADDR
20546: GO 20763
20548: LD_INT 45
20550: DOUBLE
20551: EQUAL
20552: IFTRUE 20556
20554: GO 20582
20556: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20557: LD_ADDR_VAR 0 3
20561: PUSH
20562: LD_INT 21
20564: PUSH
20565: LD_INT 22
20567: PUSH
20568: LD_INT 23
20570: PUSH
20571: LD_INT 24
20573: PUSH
20574: EMPTY
20575: LIST
20576: LIST
20577: LIST
20578: LIST
20579: ST_TO_ADDR
20580: GO 20763
20582: LD_INT 49
20584: DOUBLE
20585: EQUAL
20586: IFTRUE 20590
20588: GO 20616
20590: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20591: LD_ADDR_VAR 0 3
20595: PUSH
20596: LD_INT 21
20598: PUSH
20599: LD_INT 22
20601: PUSH
20602: LD_INT 23
20604: PUSH
20605: LD_INT 24
20607: PUSH
20608: EMPTY
20609: LIST
20610: LIST
20611: LIST
20612: LIST
20613: ST_TO_ADDR
20614: GO 20763
20616: LD_INT 51
20618: DOUBLE
20619: EQUAL
20620: IFTRUE 20624
20622: GO 20650
20624: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20625: LD_ADDR_VAR 0 3
20629: PUSH
20630: LD_INT 21
20632: PUSH
20633: LD_INT 22
20635: PUSH
20636: LD_INT 23
20638: PUSH
20639: LD_INT 24
20641: PUSH
20642: EMPTY
20643: LIST
20644: LIST
20645: LIST
20646: LIST
20647: ST_TO_ADDR
20648: GO 20763
20650: LD_INT 52
20652: DOUBLE
20653: EQUAL
20654: IFTRUE 20658
20656: GO 20684
20658: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20659: LD_ADDR_VAR 0 3
20663: PUSH
20664: LD_INT 21
20666: PUSH
20667: LD_INT 22
20669: PUSH
20670: LD_INT 23
20672: PUSH
20673: LD_INT 24
20675: PUSH
20676: EMPTY
20677: LIST
20678: LIST
20679: LIST
20680: LIST
20681: ST_TO_ADDR
20682: GO 20763
20684: LD_INT 53
20686: DOUBLE
20687: EQUAL
20688: IFTRUE 20692
20690: GO 20710
20692: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20693: LD_ADDR_VAR 0 3
20697: PUSH
20698: LD_INT 23
20700: PUSH
20701: LD_INT 24
20703: PUSH
20704: EMPTY
20705: LIST
20706: LIST
20707: ST_TO_ADDR
20708: GO 20763
20710: LD_INT 46
20712: DOUBLE
20713: EQUAL
20714: IFTRUE 20718
20716: GO 20736
20718: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20719: LD_ADDR_VAR 0 3
20723: PUSH
20724: LD_INT 23
20726: PUSH
20727: LD_INT 24
20729: PUSH
20730: EMPTY
20731: LIST
20732: LIST
20733: ST_TO_ADDR
20734: GO 20763
20736: LD_INT 47
20738: DOUBLE
20739: EQUAL
20740: IFTRUE 20744
20742: GO 20762
20744: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20745: LD_ADDR_VAR 0 3
20749: PUSH
20750: LD_INT 23
20752: PUSH
20753: LD_INT 24
20755: PUSH
20756: EMPTY
20757: LIST
20758: LIST
20759: ST_TO_ADDR
20760: GO 20763
20762: POP
// result := ( chassis in result ) ;
20763: LD_ADDR_VAR 0 3
20767: PUSH
20768: LD_VAR 0 1
20772: PUSH
20773: LD_VAR 0 3
20777: IN
20778: ST_TO_ADDR
// end ;
20779: LD_VAR 0 3
20783: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20784: LD_INT 0
20786: PPUSH
20787: PPUSH
20788: PPUSH
20789: PPUSH
20790: PPUSH
20791: PPUSH
20792: PPUSH
// result := array ;
20793: LD_ADDR_VAR 0 5
20797: PUSH
20798: LD_VAR 0 1
20802: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20803: LD_VAR 0 1
20807: NOT
20808: PUSH
20809: LD_VAR 0 2
20813: NOT
20814: OR
20815: PUSH
20816: LD_VAR 0 3
20820: NOT
20821: OR
20822: PUSH
20823: LD_VAR 0 2
20827: PUSH
20828: LD_VAR 0 1
20832: GREATER
20833: OR
20834: PUSH
20835: LD_VAR 0 3
20839: PUSH
20840: LD_VAR 0 1
20844: GREATER
20845: OR
20846: IFFALSE 20850
// exit ;
20848: GO 21146
// if direction then
20850: LD_VAR 0 4
20854: IFFALSE 20918
// begin d := 1 ;
20856: LD_ADDR_VAR 0 9
20860: PUSH
20861: LD_INT 1
20863: ST_TO_ADDR
// if i_from > i_to then
20864: LD_VAR 0 2
20868: PUSH
20869: LD_VAR 0 3
20873: GREATER
20874: IFFALSE 20900
// length := ( array - i_from ) + i_to else
20876: LD_ADDR_VAR 0 11
20880: PUSH
20881: LD_VAR 0 1
20885: PUSH
20886: LD_VAR 0 2
20890: MINUS
20891: PUSH
20892: LD_VAR 0 3
20896: PLUS
20897: ST_TO_ADDR
20898: GO 20916
// length := i_to - i_from ;
20900: LD_ADDR_VAR 0 11
20904: PUSH
20905: LD_VAR 0 3
20909: PUSH
20910: LD_VAR 0 2
20914: MINUS
20915: ST_TO_ADDR
// end else
20916: GO 20979
// begin d := - 1 ;
20918: LD_ADDR_VAR 0 9
20922: PUSH
20923: LD_INT 1
20925: NEG
20926: ST_TO_ADDR
// if i_from > i_to then
20927: LD_VAR 0 2
20931: PUSH
20932: LD_VAR 0 3
20936: GREATER
20937: IFFALSE 20957
// length := i_from - i_to else
20939: LD_ADDR_VAR 0 11
20943: PUSH
20944: LD_VAR 0 2
20948: PUSH
20949: LD_VAR 0 3
20953: MINUS
20954: ST_TO_ADDR
20955: GO 20979
// length := ( array - i_to ) + i_from ;
20957: LD_ADDR_VAR 0 11
20961: PUSH
20962: LD_VAR 0 1
20966: PUSH
20967: LD_VAR 0 3
20971: MINUS
20972: PUSH
20973: LD_VAR 0 2
20977: PLUS
20978: ST_TO_ADDR
// end ; if not length then
20979: LD_VAR 0 11
20983: NOT
20984: IFFALSE 20988
// exit ;
20986: GO 21146
// tmp := array ;
20988: LD_ADDR_VAR 0 10
20992: PUSH
20993: LD_VAR 0 1
20997: ST_TO_ADDR
// for i = 1 to length do
20998: LD_ADDR_VAR 0 6
21002: PUSH
21003: DOUBLE
21004: LD_INT 1
21006: DEC
21007: ST_TO_ADDR
21008: LD_VAR 0 11
21012: PUSH
21013: FOR_TO
21014: IFFALSE 21134
// begin for j = 1 to array do
21016: LD_ADDR_VAR 0 7
21020: PUSH
21021: DOUBLE
21022: LD_INT 1
21024: DEC
21025: ST_TO_ADDR
21026: LD_VAR 0 1
21030: PUSH
21031: FOR_TO
21032: IFFALSE 21120
// begin k := j + d ;
21034: LD_ADDR_VAR 0 8
21038: PUSH
21039: LD_VAR 0 7
21043: PUSH
21044: LD_VAR 0 9
21048: PLUS
21049: ST_TO_ADDR
// if k > array then
21050: LD_VAR 0 8
21054: PUSH
21055: LD_VAR 0 1
21059: GREATER
21060: IFFALSE 21070
// k := 1 ;
21062: LD_ADDR_VAR 0 8
21066: PUSH
21067: LD_INT 1
21069: ST_TO_ADDR
// if not k then
21070: LD_VAR 0 8
21074: NOT
21075: IFFALSE 21087
// k := array ;
21077: LD_ADDR_VAR 0 8
21081: PUSH
21082: LD_VAR 0 1
21086: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
21087: LD_ADDR_VAR 0 10
21091: PUSH
21092: LD_VAR 0 10
21096: PPUSH
21097: LD_VAR 0 8
21101: PPUSH
21102: LD_VAR 0 1
21106: PUSH
21107: LD_VAR 0 7
21111: ARRAY
21112: PPUSH
21113: CALL_OW 1
21117: ST_TO_ADDR
// end ;
21118: GO 21031
21120: POP
21121: POP
// array := tmp ;
21122: LD_ADDR_VAR 0 1
21126: PUSH
21127: LD_VAR 0 10
21131: ST_TO_ADDR
// end ;
21132: GO 21013
21134: POP
21135: POP
// result := array ;
21136: LD_ADDR_VAR 0 5
21140: PUSH
21141: LD_VAR 0 1
21145: ST_TO_ADDR
// end ;
21146: LD_VAR 0 5
21150: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
21151: LD_INT 0
21153: PPUSH
21154: PPUSH
// result := 0 ;
21155: LD_ADDR_VAR 0 3
21159: PUSH
21160: LD_INT 0
21162: ST_TO_ADDR
// if not array or not value in array then
21163: LD_VAR 0 1
21167: NOT
21168: PUSH
21169: LD_VAR 0 2
21173: PUSH
21174: LD_VAR 0 1
21178: IN
21179: NOT
21180: OR
21181: IFFALSE 21185
// exit ;
21183: GO 21239
// for i = 1 to array do
21185: LD_ADDR_VAR 0 4
21189: PUSH
21190: DOUBLE
21191: LD_INT 1
21193: DEC
21194: ST_TO_ADDR
21195: LD_VAR 0 1
21199: PUSH
21200: FOR_TO
21201: IFFALSE 21237
// if value = array [ i ] then
21203: LD_VAR 0 2
21207: PUSH
21208: LD_VAR 0 1
21212: PUSH
21213: LD_VAR 0 4
21217: ARRAY
21218: EQUAL
21219: IFFALSE 21235
// begin result := i ;
21221: LD_ADDR_VAR 0 3
21225: PUSH
21226: LD_VAR 0 4
21230: ST_TO_ADDR
// exit ;
21231: POP
21232: POP
21233: GO 21239
// end ;
21235: GO 21200
21237: POP
21238: POP
// end ;
21239: LD_VAR 0 3
21243: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
21244: LD_INT 0
21246: PPUSH
// vc_chassis := chassis ;
21247: LD_ADDR_OWVAR 37
21251: PUSH
21252: LD_VAR 0 1
21256: ST_TO_ADDR
// vc_engine := engine ;
21257: LD_ADDR_OWVAR 39
21261: PUSH
21262: LD_VAR 0 2
21266: ST_TO_ADDR
// vc_control := control ;
21267: LD_ADDR_OWVAR 38
21271: PUSH
21272: LD_VAR 0 3
21276: ST_TO_ADDR
// vc_weapon := weapon ;
21277: LD_ADDR_OWVAR 40
21281: PUSH
21282: LD_VAR 0 4
21286: ST_TO_ADDR
// vc_fuel_battery := fuel ;
21287: LD_ADDR_OWVAR 41
21291: PUSH
21292: LD_VAR 0 5
21296: ST_TO_ADDR
// end ;
21297: LD_VAR 0 6
21301: RET
// export function WantPlant ( unit ) ; var task ; begin
21302: LD_INT 0
21304: PPUSH
21305: PPUSH
// result := false ;
21306: LD_ADDR_VAR 0 2
21310: PUSH
21311: LD_INT 0
21313: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
21314: LD_ADDR_VAR 0 3
21318: PUSH
21319: LD_VAR 0 1
21323: PPUSH
21324: CALL_OW 437
21328: ST_TO_ADDR
// if task then
21329: LD_VAR 0 3
21333: IFFALSE 21361
// if task [ 1 ] [ 1 ] = p then
21335: LD_VAR 0 3
21339: PUSH
21340: LD_INT 1
21342: ARRAY
21343: PUSH
21344: LD_INT 1
21346: ARRAY
21347: PUSH
21348: LD_STRING p
21350: EQUAL
21351: IFFALSE 21361
// result := true ;
21353: LD_ADDR_VAR 0 2
21357: PUSH
21358: LD_INT 1
21360: ST_TO_ADDR
// end ;
21361: LD_VAR 0 2
21365: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
21366: LD_INT 0
21368: PPUSH
21369: PPUSH
21370: PPUSH
21371: PPUSH
// if pos < 1 then
21372: LD_VAR 0 2
21376: PUSH
21377: LD_INT 1
21379: LESS
21380: IFFALSE 21384
// exit ;
21382: GO 21687
// if pos = 1 then
21384: LD_VAR 0 2
21388: PUSH
21389: LD_INT 1
21391: EQUAL
21392: IFFALSE 21425
// result := Replace ( arr , pos [ 1 ] , value ) else
21394: LD_ADDR_VAR 0 4
21398: PUSH
21399: LD_VAR 0 1
21403: PPUSH
21404: LD_VAR 0 2
21408: PUSH
21409: LD_INT 1
21411: ARRAY
21412: PPUSH
21413: LD_VAR 0 3
21417: PPUSH
21418: CALL_OW 1
21422: ST_TO_ADDR
21423: GO 21687
// begin tmp := arr ;
21425: LD_ADDR_VAR 0 6
21429: PUSH
21430: LD_VAR 0 1
21434: ST_TO_ADDR
// s_arr := [ tmp ] ;
21435: LD_ADDR_VAR 0 7
21439: PUSH
21440: LD_VAR 0 6
21444: PUSH
21445: EMPTY
21446: LIST
21447: ST_TO_ADDR
// for i = 1 to pos - 1 do
21448: LD_ADDR_VAR 0 5
21452: PUSH
21453: DOUBLE
21454: LD_INT 1
21456: DEC
21457: ST_TO_ADDR
21458: LD_VAR 0 2
21462: PUSH
21463: LD_INT 1
21465: MINUS
21466: PUSH
21467: FOR_TO
21468: IFFALSE 21513
// begin tmp := tmp [ pos [ i ] ] ;
21470: LD_ADDR_VAR 0 6
21474: PUSH
21475: LD_VAR 0 6
21479: PUSH
21480: LD_VAR 0 2
21484: PUSH
21485: LD_VAR 0 5
21489: ARRAY
21490: ARRAY
21491: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
21492: LD_ADDR_VAR 0 7
21496: PUSH
21497: LD_VAR 0 7
21501: PUSH
21502: LD_VAR 0 6
21506: PUSH
21507: EMPTY
21508: LIST
21509: ADD
21510: ST_TO_ADDR
// end ;
21511: GO 21467
21513: POP
21514: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
21515: LD_ADDR_VAR 0 6
21519: PUSH
21520: LD_VAR 0 6
21524: PPUSH
21525: LD_VAR 0 2
21529: PUSH
21530: LD_VAR 0 2
21534: ARRAY
21535: PPUSH
21536: LD_VAR 0 3
21540: PPUSH
21541: CALL_OW 1
21545: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21546: LD_ADDR_VAR 0 7
21550: PUSH
21551: LD_VAR 0 7
21555: PPUSH
21556: LD_VAR 0 7
21560: PPUSH
21561: LD_VAR 0 6
21565: PPUSH
21566: CALL_OW 1
21570: ST_TO_ADDR
// for i = s_arr downto 2 do
21571: LD_ADDR_VAR 0 5
21575: PUSH
21576: DOUBLE
21577: LD_VAR 0 7
21581: INC
21582: ST_TO_ADDR
21583: LD_INT 2
21585: PUSH
21586: FOR_DOWNTO
21587: IFFALSE 21671
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21589: LD_ADDR_VAR 0 6
21593: PUSH
21594: LD_VAR 0 7
21598: PUSH
21599: LD_VAR 0 5
21603: PUSH
21604: LD_INT 1
21606: MINUS
21607: ARRAY
21608: PPUSH
21609: LD_VAR 0 2
21613: PUSH
21614: LD_VAR 0 5
21618: PUSH
21619: LD_INT 1
21621: MINUS
21622: ARRAY
21623: PPUSH
21624: LD_VAR 0 7
21628: PUSH
21629: LD_VAR 0 5
21633: ARRAY
21634: PPUSH
21635: CALL_OW 1
21639: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21640: LD_ADDR_VAR 0 7
21644: PUSH
21645: LD_VAR 0 7
21649: PPUSH
21650: LD_VAR 0 5
21654: PUSH
21655: LD_INT 1
21657: MINUS
21658: PPUSH
21659: LD_VAR 0 6
21663: PPUSH
21664: CALL_OW 1
21668: ST_TO_ADDR
// end ;
21669: GO 21586
21671: POP
21672: POP
// result := s_arr [ 1 ] ;
21673: LD_ADDR_VAR 0 4
21677: PUSH
21678: LD_VAR 0 7
21682: PUSH
21683: LD_INT 1
21685: ARRAY
21686: ST_TO_ADDR
// end ; end ;
21687: LD_VAR 0 4
21691: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21692: LD_INT 0
21694: PPUSH
21695: PPUSH
// if not list then
21696: LD_VAR 0 1
21700: NOT
21701: IFFALSE 21705
// exit ;
21703: GO 21796
// i := list [ pos1 ] ;
21705: LD_ADDR_VAR 0 5
21709: PUSH
21710: LD_VAR 0 1
21714: PUSH
21715: LD_VAR 0 2
21719: ARRAY
21720: ST_TO_ADDR
// if not i then
21721: LD_VAR 0 5
21725: NOT
21726: IFFALSE 21730
// exit ;
21728: GO 21796
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21730: LD_ADDR_VAR 0 1
21734: PUSH
21735: LD_VAR 0 1
21739: PPUSH
21740: LD_VAR 0 2
21744: PPUSH
21745: LD_VAR 0 1
21749: PUSH
21750: LD_VAR 0 3
21754: ARRAY
21755: PPUSH
21756: CALL_OW 1
21760: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21761: LD_ADDR_VAR 0 1
21765: PUSH
21766: LD_VAR 0 1
21770: PPUSH
21771: LD_VAR 0 3
21775: PPUSH
21776: LD_VAR 0 5
21780: PPUSH
21781: CALL_OW 1
21785: ST_TO_ADDR
// result := list ;
21786: LD_ADDR_VAR 0 4
21790: PUSH
21791: LD_VAR 0 1
21795: ST_TO_ADDR
// end ;
21796: LD_VAR 0 4
21800: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21801: LD_INT 0
21803: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21804: LD_ADDR_VAR 0 5
21808: PUSH
21809: LD_VAR 0 1
21813: PPUSH
21814: CALL_OW 250
21818: PPUSH
21819: LD_VAR 0 1
21823: PPUSH
21824: CALL_OW 251
21828: PPUSH
21829: LD_VAR 0 2
21833: PPUSH
21834: LD_VAR 0 3
21838: PPUSH
21839: LD_VAR 0 4
21843: PPUSH
21844: CALL 21854 0 5
21848: ST_TO_ADDR
// end ;
21849: LD_VAR 0 5
21853: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
21854: LD_INT 0
21856: PPUSH
21857: PPUSH
21858: PPUSH
21859: PPUSH
// if not list then
21860: LD_VAR 0 3
21864: NOT
21865: IFFALSE 21869
// exit ;
21867: GO 22257
// result := [ ] ;
21869: LD_ADDR_VAR 0 6
21873: PUSH
21874: EMPTY
21875: ST_TO_ADDR
// for i in list do
21876: LD_ADDR_VAR 0 7
21880: PUSH
21881: LD_VAR 0 3
21885: PUSH
21886: FOR_IN
21887: IFFALSE 22089
// begin tmp := GetDistUnitXY ( i , x , y ) ;
21889: LD_ADDR_VAR 0 9
21893: PUSH
21894: LD_VAR 0 7
21898: PPUSH
21899: LD_VAR 0 1
21903: PPUSH
21904: LD_VAR 0 2
21908: PPUSH
21909: CALL_OW 297
21913: ST_TO_ADDR
// if not result then
21914: LD_VAR 0 6
21918: NOT
21919: IFFALSE 21945
// result := [ [ i , tmp ] ] else
21921: LD_ADDR_VAR 0 6
21925: PUSH
21926: LD_VAR 0 7
21930: PUSH
21931: LD_VAR 0 9
21935: PUSH
21936: EMPTY
21937: LIST
21938: LIST
21939: PUSH
21940: EMPTY
21941: LIST
21942: ST_TO_ADDR
21943: GO 22087
// begin if result [ result ] [ 2 ] < tmp then
21945: LD_VAR 0 6
21949: PUSH
21950: LD_VAR 0 6
21954: ARRAY
21955: PUSH
21956: LD_INT 2
21958: ARRAY
21959: PUSH
21960: LD_VAR 0 9
21964: LESS
21965: IFFALSE 22007
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21967: LD_ADDR_VAR 0 6
21971: PUSH
21972: LD_VAR 0 6
21976: PPUSH
21977: LD_VAR 0 6
21981: PUSH
21982: LD_INT 1
21984: PLUS
21985: PPUSH
21986: LD_VAR 0 7
21990: PUSH
21991: LD_VAR 0 9
21995: PUSH
21996: EMPTY
21997: LIST
21998: LIST
21999: PPUSH
22000: CALL_OW 2
22004: ST_TO_ADDR
22005: GO 22087
// for j = 1 to result do
22007: LD_ADDR_VAR 0 8
22011: PUSH
22012: DOUBLE
22013: LD_INT 1
22015: DEC
22016: ST_TO_ADDR
22017: LD_VAR 0 6
22021: PUSH
22022: FOR_TO
22023: IFFALSE 22085
// begin if tmp < result [ j ] [ 2 ] then
22025: LD_VAR 0 9
22029: PUSH
22030: LD_VAR 0 6
22034: PUSH
22035: LD_VAR 0 8
22039: ARRAY
22040: PUSH
22041: LD_INT 2
22043: ARRAY
22044: LESS
22045: IFFALSE 22083
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22047: LD_ADDR_VAR 0 6
22051: PUSH
22052: LD_VAR 0 6
22056: PPUSH
22057: LD_VAR 0 8
22061: PPUSH
22062: LD_VAR 0 7
22066: PUSH
22067: LD_VAR 0 9
22071: PUSH
22072: EMPTY
22073: LIST
22074: LIST
22075: PPUSH
22076: CALL_OW 2
22080: ST_TO_ADDR
// break ;
22081: GO 22085
// end ; end ;
22083: GO 22022
22085: POP
22086: POP
// end ; end ;
22087: GO 21886
22089: POP
22090: POP
// if result and not asc then
22091: LD_VAR 0 6
22095: PUSH
22096: LD_VAR 0 4
22100: NOT
22101: AND
22102: IFFALSE 22177
// begin tmp := result ;
22104: LD_ADDR_VAR 0 9
22108: PUSH
22109: LD_VAR 0 6
22113: ST_TO_ADDR
// for i = tmp downto 1 do
22114: LD_ADDR_VAR 0 7
22118: PUSH
22119: DOUBLE
22120: LD_VAR 0 9
22124: INC
22125: ST_TO_ADDR
22126: LD_INT 1
22128: PUSH
22129: FOR_DOWNTO
22130: IFFALSE 22175
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
22132: LD_ADDR_VAR 0 6
22136: PUSH
22137: LD_VAR 0 6
22141: PPUSH
22142: LD_VAR 0 9
22146: PUSH
22147: LD_VAR 0 7
22151: MINUS
22152: PUSH
22153: LD_INT 1
22155: PLUS
22156: PPUSH
22157: LD_VAR 0 9
22161: PUSH
22162: LD_VAR 0 7
22166: ARRAY
22167: PPUSH
22168: CALL_OW 1
22172: ST_TO_ADDR
22173: GO 22129
22175: POP
22176: POP
// end ; tmp := [ ] ;
22177: LD_ADDR_VAR 0 9
22181: PUSH
22182: EMPTY
22183: ST_TO_ADDR
// if mode then
22184: LD_VAR 0 5
22188: IFFALSE 22257
// begin for i = 1 to result do
22190: LD_ADDR_VAR 0 7
22194: PUSH
22195: DOUBLE
22196: LD_INT 1
22198: DEC
22199: ST_TO_ADDR
22200: LD_VAR 0 6
22204: PUSH
22205: FOR_TO
22206: IFFALSE 22245
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
22208: LD_ADDR_VAR 0 9
22212: PUSH
22213: LD_VAR 0 9
22217: PPUSH
22218: LD_VAR 0 7
22222: PPUSH
22223: LD_VAR 0 6
22227: PUSH
22228: LD_VAR 0 7
22232: ARRAY
22233: PUSH
22234: LD_INT 1
22236: ARRAY
22237: PPUSH
22238: CALL_OW 1
22242: ST_TO_ADDR
22243: GO 22205
22245: POP
22246: POP
// result := tmp ;
22247: LD_ADDR_VAR 0 6
22251: PUSH
22252: LD_VAR 0 9
22256: ST_TO_ADDR
// end ; end ;
22257: LD_VAR 0 6
22261: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
22262: LD_INT 0
22264: PPUSH
22265: PPUSH
22266: PPUSH
22267: PPUSH
22268: PPUSH
22269: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
22270: LD_ADDR_VAR 0 5
22274: PUSH
22275: LD_INT 0
22277: PUSH
22278: LD_INT 0
22280: PUSH
22281: LD_INT 0
22283: PUSH
22284: EMPTY
22285: PUSH
22286: EMPTY
22287: LIST
22288: LIST
22289: LIST
22290: LIST
22291: ST_TO_ADDR
// if not x or not y then
22292: LD_VAR 0 2
22296: NOT
22297: PUSH
22298: LD_VAR 0 3
22302: NOT
22303: OR
22304: IFFALSE 22308
// exit ;
22306: GO 23954
// if not range then
22308: LD_VAR 0 4
22312: NOT
22313: IFFALSE 22323
// range := 10 ;
22315: LD_ADDR_VAR 0 4
22319: PUSH
22320: LD_INT 10
22322: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22323: LD_ADDR_VAR 0 8
22327: PUSH
22328: LD_INT 81
22330: PUSH
22331: LD_VAR 0 1
22335: PUSH
22336: EMPTY
22337: LIST
22338: LIST
22339: PUSH
22340: LD_INT 92
22342: PUSH
22343: LD_VAR 0 2
22347: PUSH
22348: LD_VAR 0 3
22352: PUSH
22353: LD_VAR 0 4
22357: PUSH
22358: EMPTY
22359: LIST
22360: LIST
22361: LIST
22362: LIST
22363: PUSH
22364: LD_INT 3
22366: PUSH
22367: LD_INT 21
22369: PUSH
22370: LD_INT 3
22372: PUSH
22373: EMPTY
22374: LIST
22375: LIST
22376: PUSH
22377: EMPTY
22378: LIST
22379: LIST
22380: PUSH
22381: EMPTY
22382: LIST
22383: LIST
22384: LIST
22385: PPUSH
22386: CALL_OW 69
22390: ST_TO_ADDR
// if not tmp then
22391: LD_VAR 0 8
22395: NOT
22396: IFFALSE 22400
// exit ;
22398: GO 23954
// for i in tmp do
22400: LD_ADDR_VAR 0 6
22404: PUSH
22405: LD_VAR 0 8
22409: PUSH
22410: FOR_IN
22411: IFFALSE 23929
// begin points := [ 0 , 0 , 0 ] ;
22413: LD_ADDR_VAR 0 9
22417: PUSH
22418: LD_INT 0
22420: PUSH
22421: LD_INT 0
22423: PUSH
22424: LD_INT 0
22426: PUSH
22427: EMPTY
22428: LIST
22429: LIST
22430: LIST
22431: ST_TO_ADDR
// bpoints := 1 ;
22432: LD_ADDR_VAR 0 10
22436: PUSH
22437: LD_INT 1
22439: ST_TO_ADDR
// case GetType ( i ) of unit_human :
22440: LD_VAR 0 6
22444: PPUSH
22445: CALL_OW 247
22449: PUSH
22450: LD_INT 1
22452: DOUBLE
22453: EQUAL
22454: IFTRUE 22458
22456: GO 23036
22458: POP
// begin if GetClass ( i ) = 1 then
22459: LD_VAR 0 6
22463: PPUSH
22464: CALL_OW 257
22468: PUSH
22469: LD_INT 1
22471: EQUAL
22472: IFFALSE 22493
// points := [ 10 , 5 , 3 ] ;
22474: LD_ADDR_VAR 0 9
22478: PUSH
22479: LD_INT 10
22481: PUSH
22482: LD_INT 5
22484: PUSH
22485: LD_INT 3
22487: PUSH
22488: EMPTY
22489: LIST
22490: LIST
22491: LIST
22492: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
22493: LD_VAR 0 6
22497: PPUSH
22498: CALL_OW 257
22502: PUSH
22503: LD_INT 2
22505: PUSH
22506: LD_INT 3
22508: PUSH
22509: LD_INT 4
22511: PUSH
22512: EMPTY
22513: LIST
22514: LIST
22515: LIST
22516: IN
22517: IFFALSE 22538
// points := [ 3 , 2 , 1 ] ;
22519: LD_ADDR_VAR 0 9
22523: PUSH
22524: LD_INT 3
22526: PUSH
22527: LD_INT 2
22529: PUSH
22530: LD_INT 1
22532: PUSH
22533: EMPTY
22534: LIST
22535: LIST
22536: LIST
22537: ST_TO_ADDR
// if GetClass ( i ) = 5 then
22538: LD_VAR 0 6
22542: PPUSH
22543: CALL_OW 257
22547: PUSH
22548: LD_INT 5
22550: EQUAL
22551: IFFALSE 22572
// points := [ 130 , 5 , 2 ] ;
22553: LD_ADDR_VAR 0 9
22557: PUSH
22558: LD_INT 130
22560: PUSH
22561: LD_INT 5
22563: PUSH
22564: LD_INT 2
22566: PUSH
22567: EMPTY
22568: LIST
22569: LIST
22570: LIST
22571: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22572: LD_VAR 0 6
22576: PPUSH
22577: CALL_OW 257
22581: PUSH
22582: LD_INT 8
22584: EQUAL
22585: IFFALSE 22606
// points := [ 35 , 35 , 30 ] ;
22587: LD_ADDR_VAR 0 9
22591: PUSH
22592: LD_INT 35
22594: PUSH
22595: LD_INT 35
22597: PUSH
22598: LD_INT 30
22600: PUSH
22601: EMPTY
22602: LIST
22603: LIST
22604: LIST
22605: ST_TO_ADDR
// if GetClass ( i ) = 9 then
22606: LD_VAR 0 6
22610: PPUSH
22611: CALL_OW 257
22615: PUSH
22616: LD_INT 9
22618: EQUAL
22619: IFFALSE 22640
// points := [ 20 , 55 , 40 ] ;
22621: LD_ADDR_VAR 0 9
22625: PUSH
22626: LD_INT 20
22628: PUSH
22629: LD_INT 55
22631: PUSH
22632: LD_INT 40
22634: PUSH
22635: EMPTY
22636: LIST
22637: LIST
22638: LIST
22639: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
22640: LD_VAR 0 6
22644: PPUSH
22645: CALL_OW 257
22649: PUSH
22650: LD_INT 12
22652: PUSH
22653: LD_INT 16
22655: PUSH
22656: EMPTY
22657: LIST
22658: LIST
22659: IN
22660: IFFALSE 22681
// points := [ 5 , 3 , 2 ] ;
22662: LD_ADDR_VAR 0 9
22666: PUSH
22667: LD_INT 5
22669: PUSH
22670: LD_INT 3
22672: PUSH
22673: LD_INT 2
22675: PUSH
22676: EMPTY
22677: LIST
22678: LIST
22679: LIST
22680: ST_TO_ADDR
// if GetClass ( i ) = 17 then
22681: LD_VAR 0 6
22685: PPUSH
22686: CALL_OW 257
22690: PUSH
22691: LD_INT 17
22693: EQUAL
22694: IFFALSE 22715
// points := [ 100 , 50 , 75 ] ;
22696: LD_ADDR_VAR 0 9
22700: PUSH
22701: LD_INT 100
22703: PUSH
22704: LD_INT 50
22706: PUSH
22707: LD_INT 75
22709: PUSH
22710: EMPTY
22711: LIST
22712: LIST
22713: LIST
22714: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22715: LD_VAR 0 6
22719: PPUSH
22720: CALL_OW 257
22724: PUSH
22725: LD_INT 15
22727: EQUAL
22728: IFFALSE 22749
// points := [ 10 , 5 , 3 ] ;
22730: LD_ADDR_VAR 0 9
22734: PUSH
22735: LD_INT 10
22737: PUSH
22738: LD_INT 5
22740: PUSH
22741: LD_INT 3
22743: PUSH
22744: EMPTY
22745: LIST
22746: LIST
22747: LIST
22748: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22749: LD_VAR 0 6
22753: PPUSH
22754: CALL_OW 257
22758: PUSH
22759: LD_INT 14
22761: EQUAL
22762: IFFALSE 22783
// points := [ 10 , 0 , 0 ] ;
22764: LD_ADDR_VAR 0 9
22768: PUSH
22769: LD_INT 10
22771: PUSH
22772: LD_INT 0
22774: PUSH
22775: LD_INT 0
22777: PUSH
22778: EMPTY
22779: LIST
22780: LIST
22781: LIST
22782: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22783: LD_VAR 0 6
22787: PPUSH
22788: CALL_OW 257
22792: PUSH
22793: LD_INT 11
22795: EQUAL
22796: IFFALSE 22817
// points := [ 30 , 10 , 5 ] ;
22798: LD_ADDR_VAR 0 9
22802: PUSH
22803: LD_INT 30
22805: PUSH
22806: LD_INT 10
22808: PUSH
22809: LD_INT 5
22811: PUSH
22812: EMPTY
22813: LIST
22814: LIST
22815: LIST
22816: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22817: LD_VAR 0 1
22821: PPUSH
22822: LD_INT 5
22824: PPUSH
22825: CALL_OW 321
22829: PUSH
22830: LD_INT 2
22832: EQUAL
22833: IFFALSE 22850
// bpoints := bpoints * 1.8 ;
22835: LD_ADDR_VAR 0 10
22839: PUSH
22840: LD_VAR 0 10
22844: PUSH
22845: LD_REAL  1.80000000000000E+0000
22848: MUL
22849: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
22850: LD_VAR 0 6
22854: PPUSH
22855: CALL_OW 257
22859: PUSH
22860: LD_INT 1
22862: PUSH
22863: LD_INT 2
22865: PUSH
22866: LD_INT 3
22868: PUSH
22869: LD_INT 4
22871: PUSH
22872: EMPTY
22873: LIST
22874: LIST
22875: LIST
22876: LIST
22877: IN
22878: PUSH
22879: LD_VAR 0 1
22883: PPUSH
22884: LD_INT 51
22886: PPUSH
22887: CALL_OW 321
22891: PUSH
22892: LD_INT 2
22894: EQUAL
22895: AND
22896: IFFALSE 22913
// bpoints := bpoints * 1.2 ;
22898: LD_ADDR_VAR 0 10
22902: PUSH
22903: LD_VAR 0 10
22907: PUSH
22908: LD_REAL  1.20000000000000E+0000
22911: MUL
22912: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
22913: LD_VAR 0 6
22917: PPUSH
22918: CALL_OW 257
22922: PUSH
22923: LD_INT 5
22925: PUSH
22926: LD_INT 7
22928: PUSH
22929: LD_INT 9
22931: PUSH
22932: EMPTY
22933: LIST
22934: LIST
22935: LIST
22936: IN
22937: PUSH
22938: LD_VAR 0 1
22942: PPUSH
22943: LD_INT 52
22945: PPUSH
22946: CALL_OW 321
22950: PUSH
22951: LD_INT 2
22953: EQUAL
22954: AND
22955: IFFALSE 22972
// bpoints := bpoints * 1.5 ;
22957: LD_ADDR_VAR 0 10
22961: PUSH
22962: LD_VAR 0 10
22966: PUSH
22967: LD_REAL  1.50000000000000E+0000
22970: MUL
22971: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22972: LD_VAR 0 1
22976: PPUSH
22977: LD_INT 66
22979: PPUSH
22980: CALL_OW 321
22984: PUSH
22985: LD_INT 2
22987: EQUAL
22988: IFFALSE 23005
// bpoints := bpoints * 1.1 ;
22990: LD_ADDR_VAR 0 10
22994: PUSH
22995: LD_VAR 0 10
22999: PUSH
23000: LD_REAL  1.10000000000000E+0000
23003: MUL
23004: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
23005: LD_ADDR_VAR 0 10
23009: PUSH
23010: LD_VAR 0 10
23014: PUSH
23015: LD_VAR 0 6
23019: PPUSH
23020: LD_INT 1
23022: PPUSH
23023: CALL_OW 259
23027: PUSH
23028: LD_REAL  1.15000000000000E+0000
23031: MUL
23032: MUL
23033: ST_TO_ADDR
// end ; unit_vehicle :
23034: GO 23858
23036: LD_INT 2
23038: DOUBLE
23039: EQUAL
23040: IFTRUE 23044
23042: GO 23846
23044: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
23045: LD_VAR 0 6
23049: PPUSH
23050: CALL_OW 264
23054: PUSH
23055: LD_INT 2
23057: PUSH
23058: LD_INT 42
23060: PUSH
23061: LD_INT 24
23063: PUSH
23064: EMPTY
23065: LIST
23066: LIST
23067: LIST
23068: IN
23069: IFFALSE 23090
// points := [ 25 , 5 , 3 ] ;
23071: LD_ADDR_VAR 0 9
23075: PUSH
23076: LD_INT 25
23078: PUSH
23079: LD_INT 5
23081: PUSH
23082: LD_INT 3
23084: PUSH
23085: EMPTY
23086: LIST
23087: LIST
23088: LIST
23089: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
23090: LD_VAR 0 6
23094: PPUSH
23095: CALL_OW 264
23099: PUSH
23100: LD_INT 4
23102: PUSH
23103: LD_INT 43
23105: PUSH
23106: LD_INT 25
23108: PUSH
23109: EMPTY
23110: LIST
23111: LIST
23112: LIST
23113: IN
23114: IFFALSE 23135
// points := [ 40 , 15 , 5 ] ;
23116: LD_ADDR_VAR 0 9
23120: PUSH
23121: LD_INT 40
23123: PUSH
23124: LD_INT 15
23126: PUSH
23127: LD_INT 5
23129: PUSH
23130: EMPTY
23131: LIST
23132: LIST
23133: LIST
23134: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
23135: LD_VAR 0 6
23139: PPUSH
23140: CALL_OW 264
23144: PUSH
23145: LD_INT 3
23147: PUSH
23148: LD_INT 23
23150: PUSH
23151: EMPTY
23152: LIST
23153: LIST
23154: IN
23155: IFFALSE 23176
// points := [ 7 , 25 , 8 ] ;
23157: LD_ADDR_VAR 0 9
23161: PUSH
23162: LD_INT 7
23164: PUSH
23165: LD_INT 25
23167: PUSH
23168: LD_INT 8
23170: PUSH
23171: EMPTY
23172: LIST
23173: LIST
23174: LIST
23175: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
23176: LD_VAR 0 6
23180: PPUSH
23181: CALL_OW 264
23185: PUSH
23186: LD_INT 5
23188: PUSH
23189: LD_INT 27
23191: PUSH
23192: LD_INT 44
23194: PUSH
23195: EMPTY
23196: LIST
23197: LIST
23198: LIST
23199: IN
23200: IFFALSE 23221
// points := [ 14 , 50 , 16 ] ;
23202: LD_ADDR_VAR 0 9
23206: PUSH
23207: LD_INT 14
23209: PUSH
23210: LD_INT 50
23212: PUSH
23213: LD_INT 16
23215: PUSH
23216: EMPTY
23217: LIST
23218: LIST
23219: LIST
23220: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
23221: LD_VAR 0 6
23225: PPUSH
23226: CALL_OW 264
23230: PUSH
23231: LD_INT 6
23233: PUSH
23234: LD_INT 46
23236: PUSH
23237: EMPTY
23238: LIST
23239: LIST
23240: IN
23241: IFFALSE 23262
// points := [ 32 , 120 , 70 ] ;
23243: LD_ADDR_VAR 0 9
23247: PUSH
23248: LD_INT 32
23250: PUSH
23251: LD_INT 120
23253: PUSH
23254: LD_INT 70
23256: PUSH
23257: EMPTY
23258: LIST
23259: LIST
23260: LIST
23261: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
23262: LD_VAR 0 6
23266: PPUSH
23267: CALL_OW 264
23271: PUSH
23272: LD_INT 7
23274: PUSH
23275: LD_INT 28
23277: PUSH
23278: LD_INT 45
23280: PUSH
23281: EMPTY
23282: LIST
23283: LIST
23284: LIST
23285: IN
23286: IFFALSE 23307
// points := [ 35 , 20 , 45 ] ;
23288: LD_ADDR_VAR 0 9
23292: PUSH
23293: LD_INT 35
23295: PUSH
23296: LD_INT 20
23298: PUSH
23299: LD_INT 45
23301: PUSH
23302: EMPTY
23303: LIST
23304: LIST
23305: LIST
23306: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
23307: LD_VAR 0 6
23311: PPUSH
23312: CALL_OW 264
23316: PUSH
23317: LD_INT 47
23319: PUSH
23320: EMPTY
23321: LIST
23322: IN
23323: IFFALSE 23344
// points := [ 67 , 45 , 75 ] ;
23325: LD_ADDR_VAR 0 9
23329: PUSH
23330: LD_INT 67
23332: PUSH
23333: LD_INT 45
23335: PUSH
23336: LD_INT 75
23338: PUSH
23339: EMPTY
23340: LIST
23341: LIST
23342: LIST
23343: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
23344: LD_VAR 0 6
23348: PPUSH
23349: CALL_OW 264
23353: PUSH
23354: LD_INT 26
23356: PUSH
23357: EMPTY
23358: LIST
23359: IN
23360: IFFALSE 23381
// points := [ 120 , 30 , 80 ] ;
23362: LD_ADDR_VAR 0 9
23366: PUSH
23367: LD_INT 120
23369: PUSH
23370: LD_INT 30
23372: PUSH
23373: LD_INT 80
23375: PUSH
23376: EMPTY
23377: LIST
23378: LIST
23379: LIST
23380: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
23381: LD_VAR 0 6
23385: PPUSH
23386: CALL_OW 264
23390: PUSH
23391: LD_INT 22
23393: PUSH
23394: EMPTY
23395: LIST
23396: IN
23397: IFFALSE 23418
// points := [ 40 , 1 , 1 ] ;
23399: LD_ADDR_VAR 0 9
23403: PUSH
23404: LD_INT 40
23406: PUSH
23407: LD_INT 1
23409: PUSH
23410: LD_INT 1
23412: PUSH
23413: EMPTY
23414: LIST
23415: LIST
23416: LIST
23417: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
23418: LD_VAR 0 6
23422: PPUSH
23423: CALL_OW 264
23427: PUSH
23428: LD_INT 29
23430: PUSH
23431: EMPTY
23432: LIST
23433: IN
23434: IFFALSE 23455
// points := [ 70 , 200 , 400 ] ;
23436: LD_ADDR_VAR 0 9
23440: PUSH
23441: LD_INT 70
23443: PUSH
23444: LD_INT 200
23446: PUSH
23447: LD_INT 400
23449: PUSH
23450: EMPTY
23451: LIST
23452: LIST
23453: LIST
23454: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
23455: LD_VAR 0 6
23459: PPUSH
23460: CALL_OW 264
23464: PUSH
23465: LD_INT 14
23467: PUSH
23468: LD_INT 53
23470: PUSH
23471: EMPTY
23472: LIST
23473: LIST
23474: IN
23475: IFFALSE 23496
// points := [ 40 , 10 , 20 ] ;
23477: LD_ADDR_VAR 0 9
23481: PUSH
23482: LD_INT 40
23484: PUSH
23485: LD_INT 10
23487: PUSH
23488: LD_INT 20
23490: PUSH
23491: EMPTY
23492: LIST
23493: LIST
23494: LIST
23495: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
23496: LD_VAR 0 6
23500: PPUSH
23501: CALL_OW 264
23505: PUSH
23506: LD_INT 9
23508: PUSH
23509: EMPTY
23510: LIST
23511: IN
23512: IFFALSE 23533
// points := [ 5 , 70 , 20 ] ;
23514: LD_ADDR_VAR 0 9
23518: PUSH
23519: LD_INT 5
23521: PUSH
23522: LD_INT 70
23524: PUSH
23525: LD_INT 20
23527: PUSH
23528: EMPTY
23529: LIST
23530: LIST
23531: LIST
23532: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
23533: LD_VAR 0 6
23537: PPUSH
23538: CALL_OW 264
23542: PUSH
23543: LD_INT 10
23545: PUSH
23546: EMPTY
23547: LIST
23548: IN
23549: IFFALSE 23570
// points := [ 35 , 110 , 70 ] ;
23551: LD_ADDR_VAR 0 9
23555: PUSH
23556: LD_INT 35
23558: PUSH
23559: LD_INT 110
23561: PUSH
23562: LD_INT 70
23564: PUSH
23565: EMPTY
23566: LIST
23567: LIST
23568: LIST
23569: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23570: LD_VAR 0 6
23574: PPUSH
23575: CALL_OW 265
23579: PUSH
23580: LD_INT 25
23582: EQUAL
23583: IFFALSE 23604
// points := [ 80 , 65 , 100 ] ;
23585: LD_ADDR_VAR 0 9
23589: PUSH
23590: LD_INT 80
23592: PUSH
23593: LD_INT 65
23595: PUSH
23596: LD_INT 100
23598: PUSH
23599: EMPTY
23600: LIST
23601: LIST
23602: LIST
23603: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
23604: LD_VAR 0 6
23608: PPUSH
23609: CALL_OW 263
23613: PUSH
23614: LD_INT 1
23616: EQUAL
23617: IFFALSE 23652
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
23619: LD_ADDR_VAR 0 10
23623: PUSH
23624: LD_VAR 0 10
23628: PUSH
23629: LD_VAR 0 6
23633: PPUSH
23634: CALL_OW 311
23638: PPUSH
23639: LD_INT 3
23641: PPUSH
23642: CALL_OW 259
23646: PUSH
23647: LD_INT 4
23649: MUL
23650: MUL
23651: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
23652: LD_VAR 0 6
23656: PPUSH
23657: CALL_OW 263
23661: PUSH
23662: LD_INT 2
23664: EQUAL
23665: IFFALSE 23716
// begin j := IsControledBy ( i ) ;
23667: LD_ADDR_VAR 0 7
23671: PUSH
23672: LD_VAR 0 6
23676: PPUSH
23677: CALL_OW 312
23681: ST_TO_ADDR
// if j then
23682: LD_VAR 0 7
23686: IFFALSE 23716
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
23688: LD_ADDR_VAR 0 10
23692: PUSH
23693: LD_VAR 0 10
23697: PUSH
23698: LD_VAR 0 7
23702: PPUSH
23703: LD_INT 3
23705: PPUSH
23706: CALL_OW 259
23710: PUSH
23711: LD_INT 3
23713: MUL
23714: MUL
23715: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23716: LD_VAR 0 6
23720: PPUSH
23721: CALL_OW 264
23725: PUSH
23726: LD_INT 5
23728: PUSH
23729: LD_INT 6
23731: PUSH
23732: LD_INT 46
23734: PUSH
23735: LD_INT 44
23737: PUSH
23738: LD_INT 47
23740: PUSH
23741: LD_INT 45
23743: PUSH
23744: LD_INT 28
23746: PUSH
23747: LD_INT 7
23749: PUSH
23750: LD_INT 27
23752: PUSH
23753: LD_INT 29
23755: PUSH
23756: EMPTY
23757: LIST
23758: LIST
23759: LIST
23760: LIST
23761: LIST
23762: LIST
23763: LIST
23764: LIST
23765: LIST
23766: LIST
23767: IN
23768: PUSH
23769: LD_VAR 0 1
23773: PPUSH
23774: LD_INT 52
23776: PPUSH
23777: CALL_OW 321
23781: PUSH
23782: LD_INT 2
23784: EQUAL
23785: AND
23786: IFFALSE 23803
// bpoints := bpoints * 1.2 ;
23788: LD_ADDR_VAR 0 10
23792: PUSH
23793: LD_VAR 0 10
23797: PUSH
23798: LD_REAL  1.20000000000000E+0000
23801: MUL
23802: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23803: LD_VAR 0 6
23807: PPUSH
23808: CALL_OW 264
23812: PUSH
23813: LD_INT 6
23815: PUSH
23816: LD_INT 46
23818: PUSH
23819: LD_INT 47
23821: PUSH
23822: EMPTY
23823: LIST
23824: LIST
23825: LIST
23826: IN
23827: IFFALSE 23844
// bpoints := bpoints * 1.2 ;
23829: LD_ADDR_VAR 0 10
23833: PUSH
23834: LD_VAR 0 10
23838: PUSH
23839: LD_REAL  1.20000000000000E+0000
23842: MUL
23843: ST_TO_ADDR
// end ; unit_building :
23844: GO 23858
23846: LD_INT 3
23848: DOUBLE
23849: EQUAL
23850: IFTRUE 23854
23852: GO 23857
23854: POP
// ; end ;
23855: GO 23858
23857: POP
// for j = 1 to 3 do
23858: LD_ADDR_VAR 0 7
23862: PUSH
23863: DOUBLE
23864: LD_INT 1
23866: DEC
23867: ST_TO_ADDR
23868: LD_INT 3
23870: PUSH
23871: FOR_TO
23872: IFFALSE 23925
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
23874: LD_ADDR_VAR 0 5
23878: PUSH
23879: LD_VAR 0 5
23883: PPUSH
23884: LD_VAR 0 7
23888: PPUSH
23889: LD_VAR 0 5
23893: PUSH
23894: LD_VAR 0 7
23898: ARRAY
23899: PUSH
23900: LD_VAR 0 9
23904: PUSH
23905: LD_VAR 0 7
23909: ARRAY
23910: PUSH
23911: LD_VAR 0 10
23915: MUL
23916: PLUS
23917: PPUSH
23918: CALL_OW 1
23922: ST_TO_ADDR
23923: GO 23871
23925: POP
23926: POP
// end ;
23927: GO 22410
23929: POP
23930: POP
// result := Replace ( result , 4 , tmp ) ;
23931: LD_ADDR_VAR 0 5
23935: PUSH
23936: LD_VAR 0 5
23940: PPUSH
23941: LD_INT 4
23943: PPUSH
23944: LD_VAR 0 8
23948: PPUSH
23949: CALL_OW 1
23953: ST_TO_ADDR
// end ;
23954: LD_VAR 0 5
23958: RET
// export function DangerAtRange ( unit , range ) ; begin
23959: LD_INT 0
23961: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23962: LD_ADDR_VAR 0 3
23966: PUSH
23967: LD_VAR 0 1
23971: PPUSH
23972: CALL_OW 255
23976: PPUSH
23977: LD_VAR 0 1
23981: PPUSH
23982: CALL_OW 250
23986: PPUSH
23987: LD_VAR 0 1
23991: PPUSH
23992: CALL_OW 251
23996: PPUSH
23997: LD_VAR 0 2
24001: PPUSH
24002: CALL 22262 0 4
24006: ST_TO_ADDR
// end ;
24007: LD_VAR 0 3
24011: RET
// export function DangerInArea ( side , area ) ; begin
24012: LD_INT 0
24014: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
24015: LD_ADDR_VAR 0 3
24019: PUSH
24020: LD_VAR 0 2
24024: PPUSH
24025: LD_INT 81
24027: PUSH
24028: LD_VAR 0 1
24032: PUSH
24033: EMPTY
24034: LIST
24035: LIST
24036: PPUSH
24037: CALL_OW 70
24041: ST_TO_ADDR
// end ;
24042: LD_VAR 0 3
24046: RET
// export function IsExtension ( b ) ; begin
24047: LD_INT 0
24049: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
24050: LD_ADDR_VAR 0 2
24054: PUSH
24055: LD_VAR 0 1
24059: PUSH
24060: LD_INT 23
24062: PUSH
24063: LD_INT 20
24065: PUSH
24066: LD_INT 22
24068: PUSH
24069: LD_INT 17
24071: PUSH
24072: LD_INT 24
24074: PUSH
24075: LD_INT 21
24077: PUSH
24078: LD_INT 19
24080: PUSH
24081: LD_INT 16
24083: PUSH
24084: LD_INT 25
24086: PUSH
24087: LD_INT 18
24089: PUSH
24090: EMPTY
24091: LIST
24092: LIST
24093: LIST
24094: LIST
24095: LIST
24096: LIST
24097: LIST
24098: LIST
24099: LIST
24100: LIST
24101: IN
24102: ST_TO_ADDR
// end ;
24103: LD_VAR 0 2
24107: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
24108: LD_INT 0
24110: PPUSH
24111: PPUSH
24112: PPUSH
// result := [ ] ;
24113: LD_ADDR_VAR 0 3
24117: PUSH
24118: EMPTY
24119: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
24120: LD_ADDR_VAR 0 4
24124: PUSH
24125: LD_VAR 0 2
24129: PPUSH
24130: LD_INT 21
24132: PUSH
24133: LD_INT 3
24135: PUSH
24136: EMPTY
24137: LIST
24138: LIST
24139: PPUSH
24140: CALL_OW 70
24144: ST_TO_ADDR
// if not tmp then
24145: LD_VAR 0 4
24149: NOT
24150: IFFALSE 24154
// exit ;
24152: GO 24212
// for i in tmp do
24154: LD_ADDR_VAR 0 5
24158: PUSH
24159: LD_VAR 0 4
24163: PUSH
24164: FOR_IN
24165: IFFALSE 24200
// if GetBase ( i ) <> base then
24167: LD_VAR 0 5
24171: PPUSH
24172: CALL_OW 274
24176: PUSH
24177: LD_VAR 0 1
24181: NONEQUAL
24182: IFFALSE 24198
// ComLinkToBase ( base , i ) ;
24184: LD_VAR 0 1
24188: PPUSH
24189: LD_VAR 0 5
24193: PPUSH
24194: CALL_OW 169
24198: GO 24164
24200: POP
24201: POP
// result := tmp ;
24202: LD_ADDR_VAR 0 3
24206: PUSH
24207: LD_VAR 0 4
24211: ST_TO_ADDR
// end ;
24212: LD_VAR 0 3
24216: RET
// export function ComComplete ( unit , b ) ; var i ; begin
24217: LD_INT 0
24219: PPUSH
24220: PPUSH
// if BuildingStatus ( b ) = bs_build then
24221: LD_VAR 0 2
24225: PPUSH
24226: CALL_OW 461
24230: PUSH
24231: LD_INT 1
24233: EQUAL
24234: IFFALSE 24294
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
24236: LD_VAR 0 1
24240: PPUSH
24241: LD_STRING h
24243: PUSH
24244: LD_VAR 0 2
24248: PPUSH
24249: CALL_OW 250
24253: PUSH
24254: LD_VAR 0 2
24258: PPUSH
24259: CALL_OW 251
24263: PUSH
24264: LD_VAR 0 2
24268: PUSH
24269: LD_INT 0
24271: PUSH
24272: LD_INT 0
24274: PUSH
24275: LD_INT 0
24277: PUSH
24278: EMPTY
24279: LIST
24280: LIST
24281: LIST
24282: LIST
24283: LIST
24284: LIST
24285: LIST
24286: PUSH
24287: EMPTY
24288: LIST
24289: PPUSH
24290: CALL_OW 446
// end ;
24294: LD_VAR 0 3
24298: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
24299: LD_INT 0
24301: PPUSH
24302: PPUSH
24303: PPUSH
24304: PPUSH
24305: PPUSH
24306: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
24307: LD_VAR 0 1
24311: NOT
24312: PUSH
24313: LD_VAR 0 1
24317: PPUSH
24318: CALL_OW 263
24322: PUSH
24323: LD_INT 2
24325: EQUAL
24326: NOT
24327: OR
24328: IFFALSE 24332
// exit ;
24330: GO 24648
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
24332: LD_ADDR_VAR 0 6
24336: PUSH
24337: LD_INT 22
24339: PUSH
24340: LD_VAR 0 1
24344: PPUSH
24345: CALL_OW 255
24349: PUSH
24350: EMPTY
24351: LIST
24352: LIST
24353: PUSH
24354: LD_INT 2
24356: PUSH
24357: LD_INT 30
24359: PUSH
24360: LD_INT 36
24362: PUSH
24363: EMPTY
24364: LIST
24365: LIST
24366: PUSH
24367: LD_INT 34
24369: PUSH
24370: LD_INT 31
24372: PUSH
24373: EMPTY
24374: LIST
24375: LIST
24376: PUSH
24377: EMPTY
24378: LIST
24379: LIST
24380: LIST
24381: PUSH
24382: EMPTY
24383: LIST
24384: LIST
24385: PPUSH
24386: CALL_OW 69
24390: ST_TO_ADDR
// if not tmp then
24391: LD_VAR 0 6
24395: NOT
24396: IFFALSE 24400
// exit ;
24398: GO 24648
// result := [ ] ;
24400: LD_ADDR_VAR 0 2
24404: PUSH
24405: EMPTY
24406: ST_TO_ADDR
// for i in tmp do
24407: LD_ADDR_VAR 0 3
24411: PUSH
24412: LD_VAR 0 6
24416: PUSH
24417: FOR_IN
24418: IFFALSE 24489
// begin t := UnitsInside ( i ) ;
24420: LD_ADDR_VAR 0 4
24424: PUSH
24425: LD_VAR 0 3
24429: PPUSH
24430: CALL_OW 313
24434: ST_TO_ADDR
// if t then
24435: LD_VAR 0 4
24439: IFFALSE 24487
// for j in t do
24441: LD_ADDR_VAR 0 7
24445: PUSH
24446: LD_VAR 0 4
24450: PUSH
24451: FOR_IN
24452: IFFALSE 24485
// result := Insert ( result , result + 1 , j ) ;
24454: LD_ADDR_VAR 0 2
24458: PUSH
24459: LD_VAR 0 2
24463: PPUSH
24464: LD_VAR 0 2
24468: PUSH
24469: LD_INT 1
24471: PLUS
24472: PPUSH
24473: LD_VAR 0 7
24477: PPUSH
24478: CALL_OW 2
24482: ST_TO_ADDR
24483: GO 24451
24485: POP
24486: POP
// end ;
24487: GO 24417
24489: POP
24490: POP
// if not result then
24491: LD_VAR 0 2
24495: NOT
24496: IFFALSE 24500
// exit ;
24498: GO 24648
// mech := result [ 1 ] ;
24500: LD_ADDR_VAR 0 5
24504: PUSH
24505: LD_VAR 0 2
24509: PUSH
24510: LD_INT 1
24512: ARRAY
24513: ST_TO_ADDR
// if result > 1 then
24514: LD_VAR 0 2
24518: PUSH
24519: LD_INT 1
24521: GREATER
24522: IFFALSE 24634
// for i = 2 to result do
24524: LD_ADDR_VAR 0 3
24528: PUSH
24529: DOUBLE
24530: LD_INT 2
24532: DEC
24533: ST_TO_ADDR
24534: LD_VAR 0 2
24538: PUSH
24539: FOR_TO
24540: IFFALSE 24632
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
24542: LD_ADDR_VAR 0 4
24546: PUSH
24547: LD_VAR 0 2
24551: PUSH
24552: LD_VAR 0 3
24556: ARRAY
24557: PPUSH
24558: LD_INT 3
24560: PPUSH
24561: CALL_OW 259
24565: PUSH
24566: LD_VAR 0 2
24570: PUSH
24571: LD_VAR 0 3
24575: ARRAY
24576: PPUSH
24577: CALL_OW 432
24581: MINUS
24582: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
24583: LD_VAR 0 4
24587: PUSH
24588: LD_VAR 0 5
24592: PPUSH
24593: LD_INT 3
24595: PPUSH
24596: CALL_OW 259
24600: PUSH
24601: LD_VAR 0 5
24605: PPUSH
24606: CALL_OW 432
24610: MINUS
24611: GREATEREQUAL
24612: IFFALSE 24630
// mech := result [ i ] ;
24614: LD_ADDR_VAR 0 5
24618: PUSH
24619: LD_VAR 0 2
24623: PUSH
24624: LD_VAR 0 3
24628: ARRAY
24629: ST_TO_ADDR
// end ;
24630: GO 24539
24632: POP
24633: POP
// ComLinkTo ( vehicle , mech ) ;
24634: LD_VAR 0 1
24638: PPUSH
24639: LD_VAR 0 5
24643: PPUSH
24644: CALL_OW 135
// end ;
24648: LD_VAR 0 2
24652: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
24653: LD_INT 0
24655: PPUSH
24656: PPUSH
24657: PPUSH
24658: PPUSH
24659: PPUSH
24660: PPUSH
24661: PPUSH
24662: PPUSH
24663: PPUSH
24664: PPUSH
24665: PPUSH
24666: PPUSH
24667: PPUSH
// result := [ ] ;
24668: LD_ADDR_VAR 0 7
24672: PUSH
24673: EMPTY
24674: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
24675: LD_VAR 0 1
24679: PPUSH
24680: CALL_OW 266
24684: PUSH
24685: LD_INT 0
24687: PUSH
24688: LD_INT 1
24690: PUSH
24691: EMPTY
24692: LIST
24693: LIST
24694: IN
24695: NOT
24696: IFFALSE 24700
// exit ;
24698: GO 26331
// if name then
24700: LD_VAR 0 3
24704: IFFALSE 24720
// SetBName ( base_dep , name ) ;
24706: LD_VAR 0 1
24710: PPUSH
24711: LD_VAR 0 3
24715: PPUSH
24716: CALL_OW 500
// base := GetBase ( base_dep ) ;
24720: LD_ADDR_VAR 0 15
24724: PUSH
24725: LD_VAR 0 1
24729: PPUSH
24730: CALL_OW 274
24734: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24735: LD_ADDR_VAR 0 16
24739: PUSH
24740: LD_VAR 0 1
24744: PPUSH
24745: CALL_OW 255
24749: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24750: LD_ADDR_VAR 0 17
24754: PUSH
24755: LD_VAR 0 1
24759: PPUSH
24760: CALL_OW 248
24764: ST_TO_ADDR
// if sources then
24765: LD_VAR 0 5
24769: IFFALSE 24816
// for i = 1 to 3 do
24771: LD_ADDR_VAR 0 8
24775: PUSH
24776: DOUBLE
24777: LD_INT 1
24779: DEC
24780: ST_TO_ADDR
24781: LD_INT 3
24783: PUSH
24784: FOR_TO
24785: IFFALSE 24814
// AddResourceType ( base , i , sources [ i ] ) ;
24787: LD_VAR 0 15
24791: PPUSH
24792: LD_VAR 0 8
24796: PPUSH
24797: LD_VAR 0 5
24801: PUSH
24802: LD_VAR 0 8
24806: ARRAY
24807: PPUSH
24808: CALL_OW 276
24812: GO 24784
24814: POP
24815: POP
// buildings := GetBaseBuildings ( base , area ) ;
24816: LD_ADDR_VAR 0 18
24820: PUSH
24821: LD_VAR 0 15
24825: PPUSH
24826: LD_VAR 0 2
24830: PPUSH
24831: CALL 24108 0 2
24835: ST_TO_ADDR
// InitHc ;
24836: CALL_OW 19
// InitUc ;
24840: CALL_OW 18
// uc_side := side ;
24844: LD_ADDR_OWVAR 20
24848: PUSH
24849: LD_VAR 0 16
24853: ST_TO_ADDR
// uc_nation := nation ;
24854: LD_ADDR_OWVAR 21
24858: PUSH
24859: LD_VAR 0 17
24863: ST_TO_ADDR
// if buildings then
24864: LD_VAR 0 18
24868: IFFALSE 26190
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
24870: LD_ADDR_VAR 0 19
24874: PUSH
24875: LD_VAR 0 18
24879: PPUSH
24880: LD_INT 2
24882: PUSH
24883: LD_INT 30
24885: PUSH
24886: LD_INT 29
24888: PUSH
24889: EMPTY
24890: LIST
24891: LIST
24892: PUSH
24893: LD_INT 30
24895: PUSH
24896: LD_INT 30
24898: PUSH
24899: EMPTY
24900: LIST
24901: LIST
24902: PUSH
24903: EMPTY
24904: LIST
24905: LIST
24906: LIST
24907: PPUSH
24908: CALL_OW 72
24912: ST_TO_ADDR
// if tmp then
24913: LD_VAR 0 19
24917: IFFALSE 24965
// for i in tmp do
24919: LD_ADDR_VAR 0 8
24923: PUSH
24924: LD_VAR 0 19
24928: PUSH
24929: FOR_IN
24930: IFFALSE 24963
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24932: LD_VAR 0 8
24936: PPUSH
24937: CALL_OW 250
24941: PPUSH
24942: LD_VAR 0 8
24946: PPUSH
24947: CALL_OW 251
24951: PPUSH
24952: LD_VAR 0 16
24956: PPUSH
24957: CALL_OW 441
24961: GO 24929
24963: POP
24964: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24965: LD_VAR 0 18
24969: PPUSH
24970: LD_INT 2
24972: PUSH
24973: LD_INT 30
24975: PUSH
24976: LD_INT 32
24978: PUSH
24979: EMPTY
24980: LIST
24981: LIST
24982: PUSH
24983: LD_INT 30
24985: PUSH
24986: LD_INT 33
24988: PUSH
24989: EMPTY
24990: LIST
24991: LIST
24992: PUSH
24993: EMPTY
24994: LIST
24995: LIST
24996: LIST
24997: PPUSH
24998: CALL_OW 72
25002: IFFALSE 25090
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
25004: LD_ADDR_VAR 0 8
25008: PUSH
25009: LD_VAR 0 18
25013: PPUSH
25014: LD_INT 2
25016: PUSH
25017: LD_INT 30
25019: PUSH
25020: LD_INT 32
25022: PUSH
25023: EMPTY
25024: LIST
25025: LIST
25026: PUSH
25027: LD_INT 30
25029: PUSH
25030: LD_INT 33
25032: PUSH
25033: EMPTY
25034: LIST
25035: LIST
25036: PUSH
25037: EMPTY
25038: LIST
25039: LIST
25040: LIST
25041: PPUSH
25042: CALL_OW 72
25046: PUSH
25047: FOR_IN
25048: IFFALSE 25088
// begin if not GetBWeapon ( i ) then
25050: LD_VAR 0 8
25054: PPUSH
25055: CALL_OW 269
25059: NOT
25060: IFFALSE 25086
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
25062: LD_VAR 0 8
25066: PPUSH
25067: LD_VAR 0 8
25071: PPUSH
25072: LD_VAR 0 2
25076: PPUSH
25077: CALL 26336 0 2
25081: PPUSH
25082: CALL_OW 431
// end ;
25086: GO 25047
25088: POP
25089: POP
// end ; for i = 1 to personel do
25090: LD_ADDR_VAR 0 8
25094: PUSH
25095: DOUBLE
25096: LD_INT 1
25098: DEC
25099: ST_TO_ADDR
25100: LD_VAR 0 6
25104: PUSH
25105: FOR_TO
25106: IFFALSE 26170
// begin if i > 4 then
25108: LD_VAR 0 8
25112: PUSH
25113: LD_INT 4
25115: GREATER
25116: IFFALSE 25120
// break ;
25118: GO 26170
// case i of 1 :
25120: LD_VAR 0 8
25124: PUSH
25125: LD_INT 1
25127: DOUBLE
25128: EQUAL
25129: IFTRUE 25133
25131: GO 25213
25133: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
25134: LD_ADDR_VAR 0 12
25138: PUSH
25139: LD_VAR 0 18
25143: PPUSH
25144: LD_INT 22
25146: PUSH
25147: LD_VAR 0 16
25151: PUSH
25152: EMPTY
25153: LIST
25154: LIST
25155: PUSH
25156: LD_INT 58
25158: PUSH
25159: EMPTY
25160: LIST
25161: PUSH
25162: LD_INT 2
25164: PUSH
25165: LD_INT 30
25167: PUSH
25168: LD_INT 32
25170: PUSH
25171: EMPTY
25172: LIST
25173: LIST
25174: PUSH
25175: LD_INT 30
25177: PUSH
25178: LD_INT 4
25180: PUSH
25181: EMPTY
25182: LIST
25183: LIST
25184: PUSH
25185: LD_INT 30
25187: PUSH
25188: LD_INT 5
25190: PUSH
25191: EMPTY
25192: LIST
25193: LIST
25194: PUSH
25195: EMPTY
25196: LIST
25197: LIST
25198: LIST
25199: LIST
25200: PUSH
25201: EMPTY
25202: LIST
25203: LIST
25204: LIST
25205: PPUSH
25206: CALL_OW 72
25210: ST_TO_ADDR
25211: GO 25435
25213: LD_INT 2
25215: DOUBLE
25216: EQUAL
25217: IFTRUE 25221
25219: GO 25283
25221: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
25222: LD_ADDR_VAR 0 12
25226: PUSH
25227: LD_VAR 0 18
25231: PPUSH
25232: LD_INT 22
25234: PUSH
25235: LD_VAR 0 16
25239: PUSH
25240: EMPTY
25241: LIST
25242: LIST
25243: PUSH
25244: LD_INT 2
25246: PUSH
25247: LD_INT 30
25249: PUSH
25250: LD_INT 0
25252: PUSH
25253: EMPTY
25254: LIST
25255: LIST
25256: PUSH
25257: LD_INT 30
25259: PUSH
25260: LD_INT 1
25262: PUSH
25263: EMPTY
25264: LIST
25265: LIST
25266: PUSH
25267: EMPTY
25268: LIST
25269: LIST
25270: LIST
25271: PUSH
25272: EMPTY
25273: LIST
25274: LIST
25275: PPUSH
25276: CALL_OW 72
25280: ST_TO_ADDR
25281: GO 25435
25283: LD_INT 3
25285: DOUBLE
25286: EQUAL
25287: IFTRUE 25291
25289: GO 25353
25291: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
25292: LD_ADDR_VAR 0 12
25296: PUSH
25297: LD_VAR 0 18
25301: PPUSH
25302: LD_INT 22
25304: PUSH
25305: LD_VAR 0 16
25309: PUSH
25310: EMPTY
25311: LIST
25312: LIST
25313: PUSH
25314: LD_INT 2
25316: PUSH
25317: LD_INT 30
25319: PUSH
25320: LD_INT 2
25322: PUSH
25323: EMPTY
25324: LIST
25325: LIST
25326: PUSH
25327: LD_INT 30
25329: PUSH
25330: LD_INT 3
25332: PUSH
25333: EMPTY
25334: LIST
25335: LIST
25336: PUSH
25337: EMPTY
25338: LIST
25339: LIST
25340: LIST
25341: PUSH
25342: EMPTY
25343: LIST
25344: LIST
25345: PPUSH
25346: CALL_OW 72
25350: ST_TO_ADDR
25351: GO 25435
25353: LD_INT 4
25355: DOUBLE
25356: EQUAL
25357: IFTRUE 25361
25359: GO 25434
25361: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
25362: LD_ADDR_VAR 0 12
25366: PUSH
25367: LD_VAR 0 18
25371: PPUSH
25372: LD_INT 22
25374: PUSH
25375: LD_VAR 0 16
25379: PUSH
25380: EMPTY
25381: LIST
25382: LIST
25383: PUSH
25384: LD_INT 2
25386: PUSH
25387: LD_INT 30
25389: PUSH
25390: LD_INT 6
25392: PUSH
25393: EMPTY
25394: LIST
25395: LIST
25396: PUSH
25397: LD_INT 30
25399: PUSH
25400: LD_INT 7
25402: PUSH
25403: EMPTY
25404: LIST
25405: LIST
25406: PUSH
25407: LD_INT 30
25409: PUSH
25410: LD_INT 8
25412: PUSH
25413: EMPTY
25414: LIST
25415: LIST
25416: PUSH
25417: EMPTY
25418: LIST
25419: LIST
25420: LIST
25421: LIST
25422: PUSH
25423: EMPTY
25424: LIST
25425: LIST
25426: PPUSH
25427: CALL_OW 72
25431: ST_TO_ADDR
25432: GO 25435
25434: POP
// if i = 1 then
25435: LD_VAR 0 8
25439: PUSH
25440: LD_INT 1
25442: EQUAL
25443: IFFALSE 25554
// begin tmp := [ ] ;
25445: LD_ADDR_VAR 0 19
25449: PUSH
25450: EMPTY
25451: ST_TO_ADDR
// for j in f do
25452: LD_ADDR_VAR 0 9
25456: PUSH
25457: LD_VAR 0 12
25461: PUSH
25462: FOR_IN
25463: IFFALSE 25536
// if GetBType ( j ) = b_bunker then
25465: LD_VAR 0 9
25469: PPUSH
25470: CALL_OW 266
25474: PUSH
25475: LD_INT 32
25477: EQUAL
25478: IFFALSE 25505
// tmp := Insert ( tmp , 1 , j ) else
25480: LD_ADDR_VAR 0 19
25484: PUSH
25485: LD_VAR 0 19
25489: PPUSH
25490: LD_INT 1
25492: PPUSH
25493: LD_VAR 0 9
25497: PPUSH
25498: CALL_OW 2
25502: ST_TO_ADDR
25503: GO 25534
// tmp := Insert ( tmp , tmp + 1 , j ) ;
25505: LD_ADDR_VAR 0 19
25509: PUSH
25510: LD_VAR 0 19
25514: PPUSH
25515: LD_VAR 0 19
25519: PUSH
25520: LD_INT 1
25522: PLUS
25523: PPUSH
25524: LD_VAR 0 9
25528: PPUSH
25529: CALL_OW 2
25533: ST_TO_ADDR
25534: GO 25462
25536: POP
25537: POP
// if tmp then
25538: LD_VAR 0 19
25542: IFFALSE 25554
// f := tmp ;
25544: LD_ADDR_VAR 0 12
25548: PUSH
25549: LD_VAR 0 19
25553: ST_TO_ADDR
// end ; x := personel [ i ] ;
25554: LD_ADDR_VAR 0 13
25558: PUSH
25559: LD_VAR 0 6
25563: PUSH
25564: LD_VAR 0 8
25568: ARRAY
25569: ST_TO_ADDR
// if x = - 1 then
25570: LD_VAR 0 13
25574: PUSH
25575: LD_INT 1
25577: NEG
25578: EQUAL
25579: IFFALSE 25788
// begin for j in f do
25581: LD_ADDR_VAR 0 9
25585: PUSH
25586: LD_VAR 0 12
25590: PUSH
25591: FOR_IN
25592: IFFALSE 25784
// repeat InitHc ;
25594: CALL_OW 19
// if GetBType ( j ) = b_barracks then
25598: LD_VAR 0 9
25602: PPUSH
25603: CALL_OW 266
25607: PUSH
25608: LD_INT 5
25610: EQUAL
25611: IFFALSE 25681
// begin if UnitsInside ( j ) < 3 then
25613: LD_VAR 0 9
25617: PPUSH
25618: CALL_OW 313
25622: PUSH
25623: LD_INT 3
25625: LESS
25626: IFFALSE 25662
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25628: LD_INT 0
25630: PPUSH
25631: LD_INT 5
25633: PUSH
25634: LD_INT 8
25636: PUSH
25637: LD_INT 9
25639: PUSH
25640: EMPTY
25641: LIST
25642: LIST
25643: LIST
25644: PUSH
25645: LD_VAR 0 17
25649: ARRAY
25650: PPUSH
25651: LD_VAR 0 4
25655: PPUSH
25656: CALL_OW 380
25660: GO 25679
// PrepareHuman ( false , i , skill ) ;
25662: LD_INT 0
25664: PPUSH
25665: LD_VAR 0 8
25669: PPUSH
25670: LD_VAR 0 4
25674: PPUSH
25675: CALL_OW 380
// end else
25679: GO 25698
// PrepareHuman ( false , i , skill ) ;
25681: LD_INT 0
25683: PPUSH
25684: LD_VAR 0 8
25688: PPUSH
25689: LD_VAR 0 4
25693: PPUSH
25694: CALL_OW 380
// un := CreateHuman ;
25698: LD_ADDR_VAR 0 14
25702: PUSH
25703: CALL_OW 44
25707: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25708: LD_ADDR_VAR 0 7
25712: PUSH
25713: LD_VAR 0 7
25717: PPUSH
25718: LD_INT 1
25720: PPUSH
25721: LD_VAR 0 14
25725: PPUSH
25726: CALL_OW 2
25730: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25731: LD_VAR 0 14
25735: PPUSH
25736: LD_VAR 0 9
25740: PPUSH
25741: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25745: LD_VAR 0 9
25749: PPUSH
25750: CALL_OW 313
25754: PUSH
25755: LD_INT 6
25757: EQUAL
25758: PUSH
25759: LD_VAR 0 9
25763: PPUSH
25764: CALL_OW 266
25768: PUSH
25769: LD_INT 32
25771: PUSH
25772: LD_INT 31
25774: PUSH
25775: EMPTY
25776: LIST
25777: LIST
25778: IN
25779: OR
25780: IFFALSE 25594
25782: GO 25591
25784: POP
25785: POP
// end else
25786: GO 26168
// for j = 1 to x do
25788: LD_ADDR_VAR 0 9
25792: PUSH
25793: DOUBLE
25794: LD_INT 1
25796: DEC
25797: ST_TO_ADDR
25798: LD_VAR 0 13
25802: PUSH
25803: FOR_TO
25804: IFFALSE 26166
// begin InitHc ;
25806: CALL_OW 19
// if not f then
25810: LD_VAR 0 12
25814: NOT
25815: IFFALSE 25904
// begin PrepareHuman ( false , i , skill ) ;
25817: LD_INT 0
25819: PPUSH
25820: LD_VAR 0 8
25824: PPUSH
25825: LD_VAR 0 4
25829: PPUSH
25830: CALL_OW 380
// un := CreateHuman ;
25834: LD_ADDR_VAR 0 14
25838: PUSH
25839: CALL_OW 44
25843: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25844: LD_ADDR_VAR 0 7
25848: PUSH
25849: LD_VAR 0 7
25853: PPUSH
25854: LD_INT 1
25856: PPUSH
25857: LD_VAR 0 14
25861: PPUSH
25862: CALL_OW 2
25866: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25867: LD_VAR 0 14
25871: PPUSH
25872: LD_VAR 0 1
25876: PPUSH
25877: CALL_OW 250
25881: PPUSH
25882: LD_VAR 0 1
25886: PPUSH
25887: CALL_OW 251
25891: PPUSH
25892: LD_INT 10
25894: PPUSH
25895: LD_INT 0
25897: PPUSH
25898: CALL_OW 50
// continue ;
25902: GO 25803
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25904: LD_VAR 0 12
25908: PUSH
25909: LD_INT 1
25911: ARRAY
25912: PPUSH
25913: CALL_OW 313
25917: PUSH
25918: LD_VAR 0 12
25922: PUSH
25923: LD_INT 1
25925: ARRAY
25926: PPUSH
25927: CALL_OW 266
25931: PUSH
25932: LD_INT 32
25934: PUSH
25935: LD_INT 31
25937: PUSH
25938: EMPTY
25939: LIST
25940: LIST
25941: IN
25942: AND
25943: PUSH
25944: LD_VAR 0 12
25948: PUSH
25949: LD_INT 1
25951: ARRAY
25952: PPUSH
25953: CALL_OW 313
25957: PUSH
25958: LD_INT 6
25960: EQUAL
25961: OR
25962: IFFALSE 25982
// f := Delete ( f , 1 ) ;
25964: LD_ADDR_VAR 0 12
25968: PUSH
25969: LD_VAR 0 12
25973: PPUSH
25974: LD_INT 1
25976: PPUSH
25977: CALL_OW 3
25981: ST_TO_ADDR
// if not f then
25982: LD_VAR 0 12
25986: NOT
25987: IFFALSE 26005
// begin x := x + 2 ;
25989: LD_ADDR_VAR 0 13
25993: PUSH
25994: LD_VAR 0 13
25998: PUSH
25999: LD_INT 2
26001: PLUS
26002: ST_TO_ADDR
// continue ;
26003: GO 25803
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
26005: LD_VAR 0 12
26009: PUSH
26010: LD_INT 1
26012: ARRAY
26013: PPUSH
26014: CALL_OW 266
26018: PUSH
26019: LD_INT 5
26021: EQUAL
26022: IFFALSE 26096
// begin if UnitsInside ( f [ 1 ] ) < 3 then
26024: LD_VAR 0 12
26028: PUSH
26029: LD_INT 1
26031: ARRAY
26032: PPUSH
26033: CALL_OW 313
26037: PUSH
26038: LD_INT 3
26040: LESS
26041: IFFALSE 26077
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26043: LD_INT 0
26045: PPUSH
26046: LD_INT 5
26048: PUSH
26049: LD_INT 8
26051: PUSH
26052: LD_INT 9
26054: PUSH
26055: EMPTY
26056: LIST
26057: LIST
26058: LIST
26059: PUSH
26060: LD_VAR 0 17
26064: ARRAY
26065: PPUSH
26066: LD_VAR 0 4
26070: PPUSH
26071: CALL_OW 380
26075: GO 26094
// PrepareHuman ( false , i , skill ) ;
26077: LD_INT 0
26079: PPUSH
26080: LD_VAR 0 8
26084: PPUSH
26085: LD_VAR 0 4
26089: PPUSH
26090: CALL_OW 380
// end else
26094: GO 26113
// PrepareHuman ( false , i , skill ) ;
26096: LD_INT 0
26098: PPUSH
26099: LD_VAR 0 8
26103: PPUSH
26104: LD_VAR 0 4
26108: PPUSH
26109: CALL_OW 380
// un := CreateHuman ;
26113: LD_ADDR_VAR 0 14
26117: PUSH
26118: CALL_OW 44
26122: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26123: LD_ADDR_VAR 0 7
26127: PUSH
26128: LD_VAR 0 7
26132: PPUSH
26133: LD_INT 1
26135: PPUSH
26136: LD_VAR 0 14
26140: PPUSH
26141: CALL_OW 2
26145: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
26146: LD_VAR 0 14
26150: PPUSH
26151: LD_VAR 0 12
26155: PUSH
26156: LD_INT 1
26158: ARRAY
26159: PPUSH
26160: CALL_OW 52
// end ;
26164: GO 25803
26166: POP
26167: POP
// end ;
26168: GO 25105
26170: POP
26171: POP
// result := result ^ buildings ;
26172: LD_ADDR_VAR 0 7
26176: PUSH
26177: LD_VAR 0 7
26181: PUSH
26182: LD_VAR 0 18
26186: ADD
26187: ST_TO_ADDR
// end else
26188: GO 26331
// begin for i = 1 to personel do
26190: LD_ADDR_VAR 0 8
26194: PUSH
26195: DOUBLE
26196: LD_INT 1
26198: DEC
26199: ST_TO_ADDR
26200: LD_VAR 0 6
26204: PUSH
26205: FOR_TO
26206: IFFALSE 26329
// begin if i > 4 then
26208: LD_VAR 0 8
26212: PUSH
26213: LD_INT 4
26215: GREATER
26216: IFFALSE 26220
// break ;
26218: GO 26329
// x := personel [ i ] ;
26220: LD_ADDR_VAR 0 13
26224: PUSH
26225: LD_VAR 0 6
26229: PUSH
26230: LD_VAR 0 8
26234: ARRAY
26235: ST_TO_ADDR
// if x = - 1 then
26236: LD_VAR 0 13
26240: PUSH
26241: LD_INT 1
26243: NEG
26244: EQUAL
26245: IFFALSE 26249
// continue ;
26247: GO 26205
// PrepareHuman ( false , i , skill ) ;
26249: LD_INT 0
26251: PPUSH
26252: LD_VAR 0 8
26256: PPUSH
26257: LD_VAR 0 4
26261: PPUSH
26262: CALL_OW 380
// un := CreateHuman ;
26266: LD_ADDR_VAR 0 14
26270: PUSH
26271: CALL_OW 44
26275: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26276: LD_VAR 0 14
26280: PPUSH
26281: LD_VAR 0 1
26285: PPUSH
26286: CALL_OW 250
26290: PPUSH
26291: LD_VAR 0 1
26295: PPUSH
26296: CALL_OW 251
26300: PPUSH
26301: LD_INT 10
26303: PPUSH
26304: LD_INT 0
26306: PPUSH
26307: CALL_OW 50
// result := result ^ un ;
26311: LD_ADDR_VAR 0 7
26315: PUSH
26316: LD_VAR 0 7
26320: PUSH
26321: LD_VAR 0 14
26325: ADD
26326: ST_TO_ADDR
// end ;
26327: GO 26205
26329: POP
26330: POP
// end ; end ;
26331: LD_VAR 0 7
26335: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
26336: LD_INT 0
26338: PPUSH
26339: PPUSH
26340: PPUSH
26341: PPUSH
26342: PPUSH
26343: PPUSH
26344: PPUSH
26345: PPUSH
26346: PPUSH
26347: PPUSH
26348: PPUSH
26349: PPUSH
26350: PPUSH
26351: PPUSH
26352: PPUSH
26353: PPUSH
// result := false ;
26354: LD_ADDR_VAR 0 3
26358: PUSH
26359: LD_INT 0
26361: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
26362: LD_VAR 0 1
26366: NOT
26367: PUSH
26368: LD_VAR 0 1
26372: PPUSH
26373: CALL_OW 266
26377: PUSH
26378: LD_INT 32
26380: PUSH
26381: LD_INT 33
26383: PUSH
26384: EMPTY
26385: LIST
26386: LIST
26387: IN
26388: NOT
26389: OR
26390: IFFALSE 26394
// exit ;
26392: GO 27530
// nat := GetNation ( tower ) ;
26394: LD_ADDR_VAR 0 12
26398: PUSH
26399: LD_VAR 0 1
26403: PPUSH
26404: CALL_OW 248
26408: ST_TO_ADDR
// side := GetSide ( tower ) ;
26409: LD_ADDR_VAR 0 16
26413: PUSH
26414: LD_VAR 0 1
26418: PPUSH
26419: CALL_OW 255
26423: ST_TO_ADDR
// x := GetX ( tower ) ;
26424: LD_ADDR_VAR 0 10
26428: PUSH
26429: LD_VAR 0 1
26433: PPUSH
26434: CALL_OW 250
26438: ST_TO_ADDR
// y := GetY ( tower ) ;
26439: LD_ADDR_VAR 0 11
26443: PUSH
26444: LD_VAR 0 1
26448: PPUSH
26449: CALL_OW 251
26453: ST_TO_ADDR
// if not x or not y then
26454: LD_VAR 0 10
26458: NOT
26459: PUSH
26460: LD_VAR 0 11
26464: NOT
26465: OR
26466: IFFALSE 26470
// exit ;
26468: GO 27530
// weapon := 0 ;
26470: LD_ADDR_VAR 0 18
26474: PUSH
26475: LD_INT 0
26477: ST_TO_ADDR
// fac_list := [ ] ;
26478: LD_ADDR_VAR 0 17
26482: PUSH
26483: EMPTY
26484: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
26485: LD_ADDR_VAR 0 6
26489: PUSH
26490: LD_VAR 0 1
26494: PPUSH
26495: CALL_OW 274
26499: PPUSH
26500: LD_VAR 0 2
26504: PPUSH
26505: CALL 24108 0 2
26509: PPUSH
26510: LD_INT 30
26512: PUSH
26513: LD_INT 3
26515: PUSH
26516: EMPTY
26517: LIST
26518: LIST
26519: PPUSH
26520: CALL_OW 72
26524: ST_TO_ADDR
// if not factories then
26525: LD_VAR 0 6
26529: NOT
26530: IFFALSE 26534
// exit ;
26532: GO 27530
// for i in factories do
26534: LD_ADDR_VAR 0 8
26538: PUSH
26539: LD_VAR 0 6
26543: PUSH
26544: FOR_IN
26545: IFFALSE 26570
// fac_list := fac_list union AvailableWeaponList ( i ) ;
26547: LD_ADDR_VAR 0 17
26551: PUSH
26552: LD_VAR 0 17
26556: PUSH
26557: LD_VAR 0 8
26561: PPUSH
26562: CALL_OW 478
26566: UNION
26567: ST_TO_ADDR
26568: GO 26544
26570: POP
26571: POP
// if not fac_list then
26572: LD_VAR 0 17
26576: NOT
26577: IFFALSE 26581
// exit ;
26579: GO 27530
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
26581: LD_ADDR_VAR 0 5
26585: PUSH
26586: LD_INT 4
26588: PUSH
26589: LD_INT 5
26591: PUSH
26592: LD_INT 9
26594: PUSH
26595: LD_INT 10
26597: PUSH
26598: LD_INT 6
26600: PUSH
26601: LD_INT 7
26603: PUSH
26604: LD_INT 11
26606: PUSH
26607: EMPTY
26608: LIST
26609: LIST
26610: LIST
26611: LIST
26612: LIST
26613: LIST
26614: LIST
26615: PUSH
26616: LD_INT 27
26618: PUSH
26619: LD_INT 28
26621: PUSH
26622: LD_INT 26
26624: PUSH
26625: LD_INT 30
26627: PUSH
26628: EMPTY
26629: LIST
26630: LIST
26631: LIST
26632: LIST
26633: PUSH
26634: LD_INT 43
26636: PUSH
26637: LD_INT 44
26639: PUSH
26640: LD_INT 46
26642: PUSH
26643: LD_INT 45
26645: PUSH
26646: LD_INT 47
26648: PUSH
26649: LD_INT 49
26651: PUSH
26652: EMPTY
26653: LIST
26654: LIST
26655: LIST
26656: LIST
26657: LIST
26658: LIST
26659: PUSH
26660: EMPTY
26661: LIST
26662: LIST
26663: LIST
26664: PUSH
26665: LD_VAR 0 12
26669: ARRAY
26670: ST_TO_ADDR
// for i in list do
26671: LD_ADDR_VAR 0 8
26675: PUSH
26676: LD_VAR 0 5
26680: PUSH
26681: FOR_IN
26682: IFFALSE 26715
// if not i in fac_list then
26684: LD_VAR 0 8
26688: PUSH
26689: LD_VAR 0 17
26693: IN
26694: NOT
26695: IFFALSE 26713
// list := list diff i ;
26697: LD_ADDR_VAR 0 5
26701: PUSH
26702: LD_VAR 0 5
26706: PUSH
26707: LD_VAR 0 8
26711: DIFF
26712: ST_TO_ADDR
26713: GO 26681
26715: POP
26716: POP
// if not list then
26717: LD_VAR 0 5
26721: NOT
26722: IFFALSE 26726
// exit ;
26724: GO 27530
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26726: LD_VAR 0 12
26730: PUSH
26731: LD_INT 3
26733: EQUAL
26734: PUSH
26735: LD_INT 49
26737: PUSH
26738: LD_VAR 0 5
26742: IN
26743: AND
26744: PUSH
26745: LD_INT 31
26747: PPUSH
26748: LD_VAR 0 16
26752: PPUSH
26753: CALL_OW 321
26757: PUSH
26758: LD_INT 2
26760: EQUAL
26761: AND
26762: IFFALSE 26822
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26764: LD_INT 22
26766: PUSH
26767: LD_VAR 0 16
26771: PUSH
26772: EMPTY
26773: LIST
26774: LIST
26775: PUSH
26776: LD_INT 35
26778: PUSH
26779: LD_INT 49
26781: PUSH
26782: EMPTY
26783: LIST
26784: LIST
26785: PUSH
26786: LD_INT 91
26788: PUSH
26789: LD_VAR 0 1
26793: PUSH
26794: LD_INT 10
26796: PUSH
26797: EMPTY
26798: LIST
26799: LIST
26800: LIST
26801: PUSH
26802: EMPTY
26803: LIST
26804: LIST
26805: LIST
26806: PPUSH
26807: CALL_OW 69
26811: NOT
26812: IFFALSE 26822
// weapon := ru_time_lapser ;
26814: LD_ADDR_VAR 0 18
26818: PUSH
26819: LD_INT 49
26821: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26822: LD_VAR 0 12
26826: PUSH
26827: LD_INT 1
26829: PUSH
26830: LD_INT 2
26832: PUSH
26833: EMPTY
26834: LIST
26835: LIST
26836: IN
26837: PUSH
26838: LD_INT 11
26840: PUSH
26841: LD_VAR 0 5
26845: IN
26846: PUSH
26847: LD_INT 30
26849: PUSH
26850: LD_VAR 0 5
26854: IN
26855: OR
26856: AND
26857: PUSH
26858: LD_INT 6
26860: PPUSH
26861: LD_VAR 0 16
26865: PPUSH
26866: CALL_OW 321
26870: PUSH
26871: LD_INT 2
26873: EQUAL
26874: AND
26875: IFFALSE 27040
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
26877: LD_INT 22
26879: PUSH
26880: LD_VAR 0 16
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: PUSH
26889: LD_INT 2
26891: PUSH
26892: LD_INT 35
26894: PUSH
26895: LD_INT 11
26897: PUSH
26898: EMPTY
26899: LIST
26900: LIST
26901: PUSH
26902: LD_INT 35
26904: PUSH
26905: LD_INT 30
26907: PUSH
26908: EMPTY
26909: LIST
26910: LIST
26911: PUSH
26912: EMPTY
26913: LIST
26914: LIST
26915: LIST
26916: PUSH
26917: LD_INT 91
26919: PUSH
26920: LD_VAR 0 1
26924: PUSH
26925: LD_INT 18
26927: PUSH
26928: EMPTY
26929: LIST
26930: LIST
26931: LIST
26932: PUSH
26933: EMPTY
26934: LIST
26935: LIST
26936: LIST
26937: PPUSH
26938: CALL_OW 69
26942: NOT
26943: PUSH
26944: LD_INT 22
26946: PUSH
26947: LD_VAR 0 16
26951: PUSH
26952: EMPTY
26953: LIST
26954: LIST
26955: PUSH
26956: LD_INT 2
26958: PUSH
26959: LD_INT 30
26961: PUSH
26962: LD_INT 32
26964: PUSH
26965: EMPTY
26966: LIST
26967: LIST
26968: PUSH
26969: LD_INT 30
26971: PUSH
26972: LD_INT 33
26974: PUSH
26975: EMPTY
26976: LIST
26977: LIST
26978: PUSH
26979: EMPTY
26980: LIST
26981: LIST
26982: LIST
26983: PUSH
26984: LD_INT 91
26986: PUSH
26987: LD_VAR 0 1
26991: PUSH
26992: LD_INT 12
26994: PUSH
26995: EMPTY
26996: LIST
26997: LIST
26998: LIST
26999: PUSH
27000: EMPTY
27001: LIST
27002: LIST
27003: LIST
27004: PUSH
27005: EMPTY
27006: LIST
27007: PPUSH
27008: CALL_OW 69
27012: PUSH
27013: LD_INT 2
27015: GREATER
27016: AND
27017: IFFALSE 27040
// weapon := [ us_radar , ar_radar ] [ nat ] ;
27019: LD_ADDR_VAR 0 18
27023: PUSH
27024: LD_INT 11
27026: PUSH
27027: LD_INT 30
27029: PUSH
27030: EMPTY
27031: LIST
27032: LIST
27033: PUSH
27034: LD_VAR 0 12
27038: ARRAY
27039: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
27040: LD_VAR 0 18
27044: NOT
27045: PUSH
27046: LD_INT 40
27048: PPUSH
27049: LD_VAR 0 16
27053: PPUSH
27054: CALL_OW 321
27058: PUSH
27059: LD_INT 2
27061: EQUAL
27062: AND
27063: PUSH
27064: LD_INT 7
27066: PUSH
27067: LD_VAR 0 5
27071: IN
27072: PUSH
27073: LD_INT 28
27075: PUSH
27076: LD_VAR 0 5
27080: IN
27081: OR
27082: PUSH
27083: LD_INT 45
27085: PUSH
27086: LD_VAR 0 5
27090: IN
27091: OR
27092: AND
27093: IFFALSE 27347
// begin hex := GetHexInfo ( x , y ) ;
27095: LD_ADDR_VAR 0 4
27099: PUSH
27100: LD_VAR 0 10
27104: PPUSH
27105: LD_VAR 0 11
27109: PPUSH
27110: CALL_OW 546
27114: ST_TO_ADDR
// if hex [ 1 ] then
27115: LD_VAR 0 4
27119: PUSH
27120: LD_INT 1
27122: ARRAY
27123: IFFALSE 27127
// exit ;
27125: GO 27530
// height := hex [ 2 ] ;
27127: LD_ADDR_VAR 0 15
27131: PUSH
27132: LD_VAR 0 4
27136: PUSH
27137: LD_INT 2
27139: ARRAY
27140: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
27141: LD_ADDR_VAR 0 14
27145: PUSH
27146: LD_INT 0
27148: PUSH
27149: LD_INT 2
27151: PUSH
27152: LD_INT 3
27154: PUSH
27155: LD_INT 5
27157: PUSH
27158: EMPTY
27159: LIST
27160: LIST
27161: LIST
27162: LIST
27163: ST_TO_ADDR
// for i in tmp do
27164: LD_ADDR_VAR 0 8
27168: PUSH
27169: LD_VAR 0 14
27173: PUSH
27174: FOR_IN
27175: IFFALSE 27345
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
27177: LD_ADDR_VAR 0 9
27181: PUSH
27182: LD_VAR 0 10
27186: PPUSH
27187: LD_VAR 0 8
27191: PPUSH
27192: LD_INT 5
27194: PPUSH
27195: CALL_OW 272
27199: PUSH
27200: LD_VAR 0 11
27204: PPUSH
27205: LD_VAR 0 8
27209: PPUSH
27210: LD_INT 5
27212: PPUSH
27213: CALL_OW 273
27217: PUSH
27218: EMPTY
27219: LIST
27220: LIST
27221: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
27222: LD_VAR 0 9
27226: PUSH
27227: LD_INT 1
27229: ARRAY
27230: PPUSH
27231: LD_VAR 0 9
27235: PUSH
27236: LD_INT 2
27238: ARRAY
27239: PPUSH
27240: CALL_OW 488
27244: IFFALSE 27343
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
27246: LD_ADDR_VAR 0 4
27250: PUSH
27251: LD_VAR 0 9
27255: PUSH
27256: LD_INT 1
27258: ARRAY
27259: PPUSH
27260: LD_VAR 0 9
27264: PUSH
27265: LD_INT 2
27267: ARRAY
27268: PPUSH
27269: CALL_OW 546
27273: ST_TO_ADDR
// if hex [ 1 ] then
27274: LD_VAR 0 4
27278: PUSH
27279: LD_INT 1
27281: ARRAY
27282: IFFALSE 27286
// continue ;
27284: GO 27174
// h := hex [ 2 ] ;
27286: LD_ADDR_VAR 0 13
27290: PUSH
27291: LD_VAR 0 4
27295: PUSH
27296: LD_INT 2
27298: ARRAY
27299: ST_TO_ADDR
// if h + 7 < height then
27300: LD_VAR 0 13
27304: PUSH
27305: LD_INT 7
27307: PLUS
27308: PUSH
27309: LD_VAR 0 15
27313: LESS
27314: IFFALSE 27343
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
27316: LD_ADDR_VAR 0 18
27320: PUSH
27321: LD_INT 7
27323: PUSH
27324: LD_INT 28
27326: PUSH
27327: LD_INT 45
27329: PUSH
27330: EMPTY
27331: LIST
27332: LIST
27333: LIST
27334: PUSH
27335: LD_VAR 0 12
27339: ARRAY
27340: ST_TO_ADDR
// break ;
27341: GO 27345
// end ; end ; end ;
27343: GO 27174
27345: POP
27346: POP
// end ; if not weapon then
27347: LD_VAR 0 18
27351: NOT
27352: IFFALSE 27412
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
27354: LD_ADDR_VAR 0 5
27358: PUSH
27359: LD_VAR 0 5
27363: PUSH
27364: LD_INT 11
27366: PUSH
27367: LD_INT 30
27369: PUSH
27370: LD_INT 49
27372: PUSH
27373: EMPTY
27374: LIST
27375: LIST
27376: LIST
27377: DIFF
27378: ST_TO_ADDR
// if not list then
27379: LD_VAR 0 5
27383: NOT
27384: IFFALSE 27388
// exit ;
27386: GO 27530
// weapon := list [ rand ( 1 , list ) ] ;
27388: LD_ADDR_VAR 0 18
27392: PUSH
27393: LD_VAR 0 5
27397: PUSH
27398: LD_INT 1
27400: PPUSH
27401: LD_VAR 0 5
27405: PPUSH
27406: CALL_OW 12
27410: ARRAY
27411: ST_TO_ADDR
// end ; if weapon then
27412: LD_VAR 0 18
27416: IFFALSE 27530
// begin tmp := CostOfWeapon ( weapon ) ;
27418: LD_ADDR_VAR 0 14
27422: PUSH
27423: LD_VAR 0 18
27427: PPUSH
27428: CALL_OW 451
27432: ST_TO_ADDR
// j := GetBase ( tower ) ;
27433: LD_ADDR_VAR 0 9
27437: PUSH
27438: LD_VAR 0 1
27442: PPUSH
27443: CALL_OW 274
27447: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
27448: LD_VAR 0 9
27452: PPUSH
27453: LD_INT 1
27455: PPUSH
27456: CALL_OW 275
27460: PUSH
27461: LD_VAR 0 14
27465: PUSH
27466: LD_INT 1
27468: ARRAY
27469: GREATEREQUAL
27470: PUSH
27471: LD_VAR 0 9
27475: PPUSH
27476: LD_INT 2
27478: PPUSH
27479: CALL_OW 275
27483: PUSH
27484: LD_VAR 0 14
27488: PUSH
27489: LD_INT 2
27491: ARRAY
27492: GREATEREQUAL
27493: AND
27494: PUSH
27495: LD_VAR 0 9
27499: PPUSH
27500: LD_INT 3
27502: PPUSH
27503: CALL_OW 275
27507: PUSH
27508: LD_VAR 0 14
27512: PUSH
27513: LD_INT 3
27515: ARRAY
27516: GREATEREQUAL
27517: AND
27518: IFFALSE 27530
// result := weapon ;
27520: LD_ADDR_VAR 0 3
27524: PUSH
27525: LD_VAR 0 18
27529: ST_TO_ADDR
// end ; end ;
27530: LD_VAR 0 3
27534: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
27535: LD_INT 0
27537: PPUSH
27538: PPUSH
// result := true ;
27539: LD_ADDR_VAR 0 3
27543: PUSH
27544: LD_INT 1
27546: ST_TO_ADDR
// if array1 = array2 then
27547: LD_VAR 0 1
27551: PUSH
27552: LD_VAR 0 2
27556: EQUAL
27557: IFFALSE 27617
// begin for i = 1 to array1 do
27559: LD_ADDR_VAR 0 4
27563: PUSH
27564: DOUBLE
27565: LD_INT 1
27567: DEC
27568: ST_TO_ADDR
27569: LD_VAR 0 1
27573: PUSH
27574: FOR_TO
27575: IFFALSE 27613
// if array1 [ i ] <> array2 [ i ] then
27577: LD_VAR 0 1
27581: PUSH
27582: LD_VAR 0 4
27586: ARRAY
27587: PUSH
27588: LD_VAR 0 2
27592: PUSH
27593: LD_VAR 0 4
27597: ARRAY
27598: NONEQUAL
27599: IFFALSE 27611
// begin result := false ;
27601: LD_ADDR_VAR 0 3
27605: PUSH
27606: LD_INT 0
27608: ST_TO_ADDR
// break ;
27609: GO 27613
// end ;
27611: GO 27574
27613: POP
27614: POP
// end else
27615: GO 27625
// result := false ;
27617: LD_ADDR_VAR 0 3
27621: PUSH
27622: LD_INT 0
27624: ST_TO_ADDR
// end ;
27625: LD_VAR 0 3
27629: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
27630: LD_INT 0
27632: PPUSH
27633: PPUSH
27634: PPUSH
// pom := GetBase ( fac ) ;
27635: LD_ADDR_VAR 0 5
27639: PUSH
27640: LD_VAR 0 1
27644: PPUSH
27645: CALL_OW 274
27649: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
27650: LD_ADDR_VAR 0 4
27654: PUSH
27655: LD_VAR 0 2
27659: PUSH
27660: LD_INT 1
27662: ARRAY
27663: PPUSH
27664: LD_VAR 0 2
27668: PUSH
27669: LD_INT 2
27671: ARRAY
27672: PPUSH
27673: LD_VAR 0 2
27677: PUSH
27678: LD_INT 3
27680: ARRAY
27681: PPUSH
27682: LD_VAR 0 2
27686: PUSH
27687: LD_INT 4
27689: ARRAY
27690: PPUSH
27691: CALL_OW 449
27695: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27696: LD_ADDR_VAR 0 3
27700: PUSH
27701: LD_VAR 0 5
27705: PPUSH
27706: LD_INT 1
27708: PPUSH
27709: CALL_OW 275
27713: PUSH
27714: LD_VAR 0 4
27718: PUSH
27719: LD_INT 1
27721: ARRAY
27722: GREATEREQUAL
27723: PUSH
27724: LD_VAR 0 5
27728: PPUSH
27729: LD_INT 2
27731: PPUSH
27732: CALL_OW 275
27736: PUSH
27737: LD_VAR 0 4
27741: PUSH
27742: LD_INT 2
27744: ARRAY
27745: GREATEREQUAL
27746: AND
27747: PUSH
27748: LD_VAR 0 5
27752: PPUSH
27753: LD_INT 3
27755: PPUSH
27756: CALL_OW 275
27760: PUSH
27761: LD_VAR 0 4
27765: PUSH
27766: LD_INT 3
27768: ARRAY
27769: GREATEREQUAL
27770: AND
27771: ST_TO_ADDR
// end ;
27772: LD_VAR 0 3
27776: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27777: LD_INT 0
27779: PPUSH
27780: PPUSH
27781: PPUSH
27782: PPUSH
// pom := GetBase ( building ) ;
27783: LD_ADDR_VAR 0 3
27787: PUSH
27788: LD_VAR 0 1
27792: PPUSH
27793: CALL_OW 274
27797: ST_TO_ADDR
// if not pom then
27798: LD_VAR 0 3
27802: NOT
27803: IFFALSE 27807
// exit ;
27805: GO 27977
// btype := GetBType ( building ) ;
27807: LD_ADDR_VAR 0 5
27811: PUSH
27812: LD_VAR 0 1
27816: PPUSH
27817: CALL_OW 266
27821: ST_TO_ADDR
// if btype = b_armoury then
27822: LD_VAR 0 5
27826: PUSH
27827: LD_INT 4
27829: EQUAL
27830: IFFALSE 27840
// btype := b_barracks ;
27832: LD_ADDR_VAR 0 5
27836: PUSH
27837: LD_INT 5
27839: ST_TO_ADDR
// if btype = b_depot then
27840: LD_VAR 0 5
27844: PUSH
27845: LD_INT 0
27847: EQUAL
27848: IFFALSE 27858
// btype := b_warehouse ;
27850: LD_ADDR_VAR 0 5
27854: PUSH
27855: LD_INT 1
27857: ST_TO_ADDR
// if btype = b_workshop then
27858: LD_VAR 0 5
27862: PUSH
27863: LD_INT 2
27865: EQUAL
27866: IFFALSE 27876
// btype := b_factory ;
27868: LD_ADDR_VAR 0 5
27872: PUSH
27873: LD_INT 3
27875: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27876: LD_ADDR_VAR 0 4
27880: PUSH
27881: LD_VAR 0 5
27885: PPUSH
27886: LD_VAR 0 1
27890: PPUSH
27891: CALL_OW 248
27895: PPUSH
27896: CALL_OW 450
27900: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27901: LD_ADDR_VAR 0 2
27905: PUSH
27906: LD_VAR 0 3
27910: PPUSH
27911: LD_INT 1
27913: PPUSH
27914: CALL_OW 275
27918: PUSH
27919: LD_VAR 0 4
27923: PUSH
27924: LD_INT 1
27926: ARRAY
27927: GREATEREQUAL
27928: PUSH
27929: LD_VAR 0 3
27933: PPUSH
27934: LD_INT 2
27936: PPUSH
27937: CALL_OW 275
27941: PUSH
27942: LD_VAR 0 4
27946: PUSH
27947: LD_INT 2
27949: ARRAY
27950: GREATEREQUAL
27951: AND
27952: PUSH
27953: LD_VAR 0 3
27957: PPUSH
27958: LD_INT 3
27960: PPUSH
27961: CALL_OW 275
27965: PUSH
27966: LD_VAR 0 4
27970: PUSH
27971: LD_INT 3
27973: ARRAY
27974: GREATEREQUAL
27975: AND
27976: ST_TO_ADDR
// end ;
27977: LD_VAR 0 2
27981: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
27982: LD_INT 0
27984: PPUSH
27985: PPUSH
27986: PPUSH
// pom := GetBase ( building ) ;
27987: LD_ADDR_VAR 0 4
27991: PUSH
27992: LD_VAR 0 1
27996: PPUSH
27997: CALL_OW 274
28001: ST_TO_ADDR
// if not pom then
28002: LD_VAR 0 4
28006: NOT
28007: IFFALSE 28011
// exit ;
28009: GO 28112
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28011: LD_ADDR_VAR 0 5
28015: PUSH
28016: LD_VAR 0 2
28020: PPUSH
28021: LD_VAR 0 1
28025: PPUSH
28026: CALL_OW 248
28030: PPUSH
28031: CALL_OW 450
28035: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28036: LD_ADDR_VAR 0 3
28040: PUSH
28041: LD_VAR 0 4
28045: PPUSH
28046: LD_INT 1
28048: PPUSH
28049: CALL_OW 275
28053: PUSH
28054: LD_VAR 0 5
28058: PUSH
28059: LD_INT 1
28061: ARRAY
28062: GREATEREQUAL
28063: PUSH
28064: LD_VAR 0 4
28068: PPUSH
28069: LD_INT 2
28071: PPUSH
28072: CALL_OW 275
28076: PUSH
28077: LD_VAR 0 5
28081: PUSH
28082: LD_INT 2
28084: ARRAY
28085: GREATEREQUAL
28086: AND
28087: PUSH
28088: LD_VAR 0 4
28092: PPUSH
28093: LD_INT 3
28095: PPUSH
28096: CALL_OW 275
28100: PUSH
28101: LD_VAR 0 5
28105: PUSH
28106: LD_INT 3
28108: ARRAY
28109: GREATEREQUAL
28110: AND
28111: ST_TO_ADDR
// end ;
28112: LD_VAR 0 3
28116: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
28117: LD_INT 0
28119: PPUSH
28120: PPUSH
28121: PPUSH
28122: PPUSH
28123: PPUSH
28124: PPUSH
28125: PPUSH
28126: PPUSH
28127: PPUSH
28128: PPUSH
// result := false ;
28129: LD_ADDR_VAR 0 6
28133: PUSH
28134: LD_INT 0
28136: ST_TO_ADDR
// if not base or not btype or not x or not y then
28137: LD_VAR 0 1
28141: NOT
28142: PUSH
28143: LD_VAR 0 2
28147: NOT
28148: OR
28149: PUSH
28150: LD_VAR 0 3
28154: NOT
28155: OR
28156: PUSH
28157: LD_VAR 0 4
28161: NOT
28162: OR
28163: IFFALSE 28167
// exit ;
28165: GO 28776
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
28167: LD_ADDR_VAR 0 12
28171: PUSH
28172: LD_VAR 0 2
28176: PPUSH
28177: LD_VAR 0 3
28181: PPUSH
28182: LD_VAR 0 4
28186: PPUSH
28187: LD_VAR 0 5
28191: PPUSH
28192: LD_VAR 0 1
28196: PUSH
28197: LD_INT 1
28199: ARRAY
28200: PPUSH
28201: CALL_OW 248
28205: PPUSH
28206: LD_INT 0
28208: PPUSH
28209: CALL 29613 0 6
28213: ST_TO_ADDR
// if not hexes then
28214: LD_VAR 0 12
28218: NOT
28219: IFFALSE 28223
// exit ;
28221: GO 28776
// for i = 1 to hexes do
28223: LD_ADDR_VAR 0 7
28227: PUSH
28228: DOUBLE
28229: LD_INT 1
28231: DEC
28232: ST_TO_ADDR
28233: LD_VAR 0 12
28237: PUSH
28238: FOR_TO
28239: IFFALSE 28774
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28241: LD_ADDR_VAR 0 11
28245: PUSH
28246: LD_VAR 0 12
28250: PUSH
28251: LD_VAR 0 7
28255: ARRAY
28256: PUSH
28257: LD_INT 1
28259: ARRAY
28260: PPUSH
28261: LD_VAR 0 12
28265: PUSH
28266: LD_VAR 0 7
28270: ARRAY
28271: PUSH
28272: LD_INT 2
28274: ARRAY
28275: PPUSH
28276: CALL_OW 428
28280: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
28281: LD_VAR 0 12
28285: PUSH
28286: LD_VAR 0 7
28290: ARRAY
28291: PUSH
28292: LD_INT 1
28294: ARRAY
28295: PPUSH
28296: LD_VAR 0 12
28300: PUSH
28301: LD_VAR 0 7
28305: ARRAY
28306: PUSH
28307: LD_INT 2
28309: ARRAY
28310: PPUSH
28311: CALL_OW 351
28315: PUSH
28316: LD_VAR 0 12
28320: PUSH
28321: LD_VAR 0 7
28325: ARRAY
28326: PUSH
28327: LD_INT 1
28329: ARRAY
28330: PPUSH
28331: LD_VAR 0 12
28335: PUSH
28336: LD_VAR 0 7
28340: ARRAY
28341: PUSH
28342: LD_INT 2
28344: ARRAY
28345: PPUSH
28346: CALL_OW 488
28350: NOT
28351: OR
28352: PUSH
28353: LD_VAR 0 11
28357: PPUSH
28358: CALL_OW 247
28362: PUSH
28363: LD_INT 3
28365: EQUAL
28366: OR
28367: IFFALSE 28373
// exit ;
28369: POP
28370: POP
28371: GO 28776
// if not tmp or not tmp in base then
28373: LD_VAR 0 11
28377: NOT
28378: PUSH
28379: LD_VAR 0 11
28383: PUSH
28384: LD_VAR 0 1
28388: IN
28389: NOT
28390: OR
28391: IFFALSE 28395
// continue ;
28393: GO 28238
// result := true ;
28395: LD_ADDR_VAR 0 6
28399: PUSH
28400: LD_INT 1
28402: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28403: LD_ADDR_VAR 0 15
28407: PUSH
28408: LD_VAR 0 1
28412: PPUSH
28413: LD_INT 22
28415: PUSH
28416: LD_VAR 0 11
28420: PPUSH
28421: CALL_OW 255
28425: PUSH
28426: EMPTY
28427: LIST
28428: LIST
28429: PUSH
28430: LD_INT 2
28432: PUSH
28433: LD_INT 30
28435: PUSH
28436: LD_INT 0
28438: PUSH
28439: EMPTY
28440: LIST
28441: LIST
28442: PUSH
28443: LD_INT 30
28445: PUSH
28446: LD_INT 1
28448: PUSH
28449: EMPTY
28450: LIST
28451: LIST
28452: PUSH
28453: EMPTY
28454: LIST
28455: LIST
28456: LIST
28457: PUSH
28458: EMPTY
28459: LIST
28460: LIST
28461: PPUSH
28462: CALL_OW 72
28466: ST_TO_ADDR
// if dep then
28467: LD_VAR 0 15
28471: IFFALSE 28607
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
28473: LD_ADDR_VAR 0 14
28477: PUSH
28478: LD_VAR 0 15
28482: PUSH
28483: LD_INT 1
28485: ARRAY
28486: PPUSH
28487: CALL_OW 250
28491: PPUSH
28492: LD_VAR 0 15
28496: PUSH
28497: LD_INT 1
28499: ARRAY
28500: PPUSH
28501: CALL_OW 254
28505: PPUSH
28506: LD_INT 5
28508: PPUSH
28509: CALL_OW 272
28513: PUSH
28514: LD_VAR 0 15
28518: PUSH
28519: LD_INT 1
28521: ARRAY
28522: PPUSH
28523: CALL_OW 251
28527: PPUSH
28528: LD_VAR 0 15
28532: PUSH
28533: LD_INT 1
28535: ARRAY
28536: PPUSH
28537: CALL_OW 254
28541: PPUSH
28542: LD_INT 5
28544: PPUSH
28545: CALL_OW 273
28549: PUSH
28550: EMPTY
28551: LIST
28552: LIST
28553: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
28554: LD_VAR 0 14
28558: PUSH
28559: LD_INT 1
28561: ARRAY
28562: PPUSH
28563: LD_VAR 0 14
28567: PUSH
28568: LD_INT 2
28570: ARRAY
28571: PPUSH
28572: CALL_OW 488
28576: IFFALSE 28607
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
28578: LD_VAR 0 11
28582: PPUSH
28583: LD_VAR 0 14
28587: PUSH
28588: LD_INT 1
28590: ARRAY
28591: PPUSH
28592: LD_VAR 0 14
28596: PUSH
28597: LD_INT 2
28599: ARRAY
28600: PPUSH
28601: CALL_OW 111
// continue ;
28605: GO 28238
// end ; end ; r := GetDir ( tmp ) ;
28607: LD_ADDR_VAR 0 13
28611: PUSH
28612: LD_VAR 0 11
28616: PPUSH
28617: CALL_OW 254
28621: ST_TO_ADDR
// if r = 5 then
28622: LD_VAR 0 13
28626: PUSH
28627: LD_INT 5
28629: EQUAL
28630: IFFALSE 28640
// r := 0 ;
28632: LD_ADDR_VAR 0 13
28636: PUSH
28637: LD_INT 0
28639: ST_TO_ADDR
// for j = r to 5 do
28640: LD_ADDR_VAR 0 8
28644: PUSH
28645: DOUBLE
28646: LD_VAR 0 13
28650: DEC
28651: ST_TO_ADDR
28652: LD_INT 5
28654: PUSH
28655: FOR_TO
28656: IFFALSE 28770
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
28658: LD_ADDR_VAR 0 9
28662: PUSH
28663: LD_VAR 0 11
28667: PPUSH
28668: CALL_OW 250
28672: PPUSH
28673: LD_VAR 0 8
28677: PPUSH
28678: LD_INT 2
28680: PPUSH
28681: CALL_OW 272
28685: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
28686: LD_ADDR_VAR 0 10
28690: PUSH
28691: LD_VAR 0 11
28695: PPUSH
28696: CALL_OW 251
28700: PPUSH
28701: LD_VAR 0 8
28705: PPUSH
28706: LD_INT 2
28708: PPUSH
28709: CALL_OW 273
28713: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28714: LD_VAR 0 9
28718: PPUSH
28719: LD_VAR 0 10
28723: PPUSH
28724: CALL_OW 488
28728: PUSH
28729: LD_VAR 0 9
28733: PPUSH
28734: LD_VAR 0 10
28738: PPUSH
28739: CALL_OW 428
28743: NOT
28744: AND
28745: IFFALSE 28768
// begin ComMoveXY ( tmp , _x , _y ) ;
28747: LD_VAR 0 11
28751: PPUSH
28752: LD_VAR 0 9
28756: PPUSH
28757: LD_VAR 0 10
28761: PPUSH
28762: CALL_OW 111
// break ;
28766: GO 28770
// end ; end ;
28768: GO 28655
28770: POP
28771: POP
// end ;
28772: GO 28238
28774: POP
28775: POP
// end ;
28776: LD_VAR 0 6
28780: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
28781: LD_INT 0
28783: PPUSH
28784: PPUSH
28785: PPUSH
28786: PPUSH
28787: PPUSH
28788: PPUSH
28789: PPUSH
28790: PPUSH
28791: PPUSH
28792: PPUSH
// result := false ;
28793: LD_ADDR_VAR 0 6
28797: PUSH
28798: LD_INT 0
28800: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28801: LD_VAR 0 1
28805: NOT
28806: PUSH
28807: LD_VAR 0 1
28811: PPUSH
28812: CALL_OW 266
28816: PUSH
28817: LD_INT 0
28819: PUSH
28820: LD_INT 1
28822: PUSH
28823: EMPTY
28824: LIST
28825: LIST
28826: IN
28827: NOT
28828: OR
28829: PUSH
28830: LD_VAR 0 2
28834: NOT
28835: OR
28836: PUSH
28837: LD_VAR 0 5
28841: PUSH
28842: LD_INT 0
28844: PUSH
28845: LD_INT 1
28847: PUSH
28848: LD_INT 2
28850: PUSH
28851: LD_INT 3
28853: PUSH
28854: LD_INT 4
28856: PUSH
28857: LD_INT 5
28859: PUSH
28860: EMPTY
28861: LIST
28862: LIST
28863: LIST
28864: LIST
28865: LIST
28866: LIST
28867: IN
28868: NOT
28869: OR
28870: PUSH
28871: LD_VAR 0 3
28875: PPUSH
28876: LD_VAR 0 4
28880: PPUSH
28881: CALL_OW 488
28885: NOT
28886: OR
28887: IFFALSE 28891
// exit ;
28889: GO 29608
// pom := GetBase ( depot ) ;
28891: LD_ADDR_VAR 0 10
28895: PUSH
28896: LD_VAR 0 1
28900: PPUSH
28901: CALL_OW 274
28905: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28906: LD_ADDR_VAR 0 11
28910: PUSH
28911: LD_VAR 0 2
28915: PPUSH
28916: LD_VAR 0 1
28920: PPUSH
28921: CALL_OW 248
28925: PPUSH
28926: CALL_OW 450
28930: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28931: LD_VAR 0 10
28935: PPUSH
28936: LD_INT 1
28938: PPUSH
28939: CALL_OW 275
28943: PUSH
28944: LD_VAR 0 11
28948: PUSH
28949: LD_INT 1
28951: ARRAY
28952: GREATEREQUAL
28953: PUSH
28954: LD_VAR 0 10
28958: PPUSH
28959: LD_INT 2
28961: PPUSH
28962: CALL_OW 275
28966: PUSH
28967: LD_VAR 0 11
28971: PUSH
28972: LD_INT 2
28974: ARRAY
28975: GREATEREQUAL
28976: AND
28977: PUSH
28978: LD_VAR 0 10
28982: PPUSH
28983: LD_INT 3
28985: PPUSH
28986: CALL_OW 275
28990: PUSH
28991: LD_VAR 0 11
28995: PUSH
28996: LD_INT 3
28998: ARRAY
28999: GREATEREQUAL
29000: AND
29001: NOT
29002: IFFALSE 29006
// exit ;
29004: GO 29608
// if GetBType ( depot ) = b_depot then
29006: LD_VAR 0 1
29010: PPUSH
29011: CALL_OW 266
29015: PUSH
29016: LD_INT 0
29018: EQUAL
29019: IFFALSE 29031
// dist := 28 else
29021: LD_ADDR_VAR 0 14
29025: PUSH
29026: LD_INT 28
29028: ST_TO_ADDR
29029: GO 29039
// dist := 36 ;
29031: LD_ADDR_VAR 0 14
29035: PUSH
29036: LD_INT 36
29038: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
29039: LD_VAR 0 1
29043: PPUSH
29044: LD_VAR 0 3
29048: PPUSH
29049: LD_VAR 0 4
29053: PPUSH
29054: CALL_OW 297
29058: PUSH
29059: LD_VAR 0 14
29063: GREATER
29064: IFFALSE 29068
// exit ;
29066: GO 29608
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
29068: LD_ADDR_VAR 0 12
29072: PUSH
29073: LD_VAR 0 2
29077: PPUSH
29078: LD_VAR 0 3
29082: PPUSH
29083: LD_VAR 0 4
29087: PPUSH
29088: LD_VAR 0 5
29092: PPUSH
29093: LD_VAR 0 1
29097: PPUSH
29098: CALL_OW 248
29102: PPUSH
29103: LD_INT 0
29105: PPUSH
29106: CALL 29613 0 6
29110: ST_TO_ADDR
// if not hexes then
29111: LD_VAR 0 12
29115: NOT
29116: IFFALSE 29120
// exit ;
29118: GO 29608
// hex := GetHexInfo ( x , y ) ;
29120: LD_ADDR_VAR 0 15
29124: PUSH
29125: LD_VAR 0 3
29129: PPUSH
29130: LD_VAR 0 4
29134: PPUSH
29135: CALL_OW 546
29139: ST_TO_ADDR
// if hex [ 1 ] then
29140: LD_VAR 0 15
29144: PUSH
29145: LD_INT 1
29147: ARRAY
29148: IFFALSE 29152
// exit ;
29150: GO 29608
// height := hex [ 2 ] ;
29152: LD_ADDR_VAR 0 13
29156: PUSH
29157: LD_VAR 0 15
29161: PUSH
29162: LD_INT 2
29164: ARRAY
29165: ST_TO_ADDR
// for i = 1 to hexes do
29166: LD_ADDR_VAR 0 7
29170: PUSH
29171: DOUBLE
29172: LD_INT 1
29174: DEC
29175: ST_TO_ADDR
29176: LD_VAR 0 12
29180: PUSH
29181: FOR_TO
29182: IFFALSE 29512
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
29184: LD_VAR 0 12
29188: PUSH
29189: LD_VAR 0 7
29193: ARRAY
29194: PUSH
29195: LD_INT 1
29197: ARRAY
29198: PPUSH
29199: LD_VAR 0 12
29203: PUSH
29204: LD_VAR 0 7
29208: ARRAY
29209: PUSH
29210: LD_INT 2
29212: ARRAY
29213: PPUSH
29214: CALL_OW 488
29218: NOT
29219: PUSH
29220: LD_VAR 0 12
29224: PUSH
29225: LD_VAR 0 7
29229: ARRAY
29230: PUSH
29231: LD_INT 1
29233: ARRAY
29234: PPUSH
29235: LD_VAR 0 12
29239: PUSH
29240: LD_VAR 0 7
29244: ARRAY
29245: PUSH
29246: LD_INT 2
29248: ARRAY
29249: PPUSH
29250: CALL_OW 428
29254: PUSH
29255: LD_INT 0
29257: GREATER
29258: OR
29259: PUSH
29260: LD_VAR 0 12
29264: PUSH
29265: LD_VAR 0 7
29269: ARRAY
29270: PUSH
29271: LD_INT 1
29273: ARRAY
29274: PPUSH
29275: LD_VAR 0 12
29279: PUSH
29280: LD_VAR 0 7
29284: ARRAY
29285: PUSH
29286: LD_INT 2
29288: ARRAY
29289: PPUSH
29290: CALL_OW 351
29294: OR
29295: IFFALSE 29301
// exit ;
29297: POP
29298: POP
29299: GO 29608
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29301: LD_ADDR_VAR 0 8
29305: PUSH
29306: LD_VAR 0 12
29310: PUSH
29311: LD_VAR 0 7
29315: ARRAY
29316: PUSH
29317: LD_INT 1
29319: ARRAY
29320: PPUSH
29321: LD_VAR 0 12
29325: PUSH
29326: LD_VAR 0 7
29330: ARRAY
29331: PUSH
29332: LD_INT 2
29334: ARRAY
29335: PPUSH
29336: CALL_OW 546
29340: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
29341: LD_VAR 0 8
29345: PUSH
29346: LD_INT 1
29348: ARRAY
29349: PUSH
29350: LD_VAR 0 8
29354: PUSH
29355: LD_INT 2
29357: ARRAY
29358: PUSH
29359: LD_VAR 0 13
29363: PUSH
29364: LD_INT 2
29366: PLUS
29367: GREATER
29368: OR
29369: PUSH
29370: LD_VAR 0 8
29374: PUSH
29375: LD_INT 2
29377: ARRAY
29378: PUSH
29379: LD_VAR 0 13
29383: PUSH
29384: LD_INT 2
29386: MINUS
29387: LESS
29388: OR
29389: PUSH
29390: LD_VAR 0 8
29394: PUSH
29395: LD_INT 3
29397: ARRAY
29398: PUSH
29399: LD_INT 0
29401: PUSH
29402: LD_INT 8
29404: PUSH
29405: LD_INT 9
29407: PUSH
29408: LD_INT 10
29410: PUSH
29411: LD_INT 11
29413: PUSH
29414: LD_INT 12
29416: PUSH
29417: LD_INT 13
29419: PUSH
29420: LD_INT 16
29422: PUSH
29423: LD_INT 17
29425: PUSH
29426: LD_INT 18
29428: PUSH
29429: LD_INT 19
29431: PUSH
29432: LD_INT 20
29434: PUSH
29435: LD_INT 21
29437: PUSH
29438: EMPTY
29439: LIST
29440: LIST
29441: LIST
29442: LIST
29443: LIST
29444: LIST
29445: LIST
29446: LIST
29447: LIST
29448: LIST
29449: LIST
29450: LIST
29451: LIST
29452: IN
29453: NOT
29454: OR
29455: PUSH
29456: LD_VAR 0 8
29460: PUSH
29461: LD_INT 5
29463: ARRAY
29464: NOT
29465: OR
29466: PUSH
29467: LD_VAR 0 8
29471: PUSH
29472: LD_INT 6
29474: ARRAY
29475: PUSH
29476: LD_INT 1
29478: PUSH
29479: LD_INT 2
29481: PUSH
29482: LD_INT 7
29484: PUSH
29485: LD_INT 9
29487: PUSH
29488: LD_INT 10
29490: PUSH
29491: LD_INT 11
29493: PUSH
29494: EMPTY
29495: LIST
29496: LIST
29497: LIST
29498: LIST
29499: LIST
29500: LIST
29501: IN
29502: NOT
29503: OR
29504: IFFALSE 29510
// exit ;
29506: POP
29507: POP
29508: GO 29608
// end ;
29510: GO 29181
29512: POP
29513: POP
// side := GetSide ( depot ) ;
29514: LD_ADDR_VAR 0 9
29518: PUSH
29519: LD_VAR 0 1
29523: PPUSH
29524: CALL_OW 255
29528: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
29529: LD_VAR 0 9
29533: PPUSH
29534: LD_VAR 0 3
29538: PPUSH
29539: LD_VAR 0 4
29543: PPUSH
29544: LD_INT 20
29546: PPUSH
29547: CALL 22262 0 4
29551: PUSH
29552: LD_INT 4
29554: ARRAY
29555: IFFALSE 29559
// exit ;
29557: GO 29608
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
29559: LD_VAR 0 2
29563: PUSH
29564: LD_INT 29
29566: PUSH
29567: LD_INT 30
29569: PUSH
29570: EMPTY
29571: LIST
29572: LIST
29573: IN
29574: PUSH
29575: LD_VAR 0 3
29579: PPUSH
29580: LD_VAR 0 4
29584: PPUSH
29585: LD_VAR 0 9
29589: PPUSH
29590: CALL_OW 440
29594: NOT
29595: AND
29596: IFFALSE 29600
// exit ;
29598: GO 29608
// result := true ;
29600: LD_ADDR_VAR 0 6
29604: PUSH
29605: LD_INT 1
29607: ST_TO_ADDR
// end ;
29608: LD_VAR 0 6
29612: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
29613: LD_INT 0
29615: PPUSH
29616: PPUSH
29617: PPUSH
29618: PPUSH
29619: PPUSH
29620: PPUSH
29621: PPUSH
29622: PPUSH
29623: PPUSH
29624: PPUSH
29625: PPUSH
29626: PPUSH
29627: PPUSH
29628: PPUSH
29629: PPUSH
29630: PPUSH
29631: PPUSH
29632: PPUSH
29633: PPUSH
29634: PPUSH
29635: PPUSH
29636: PPUSH
29637: PPUSH
29638: PPUSH
29639: PPUSH
29640: PPUSH
29641: PPUSH
29642: PPUSH
29643: PPUSH
29644: PPUSH
29645: PPUSH
29646: PPUSH
29647: PPUSH
29648: PPUSH
29649: PPUSH
29650: PPUSH
29651: PPUSH
29652: PPUSH
29653: PPUSH
29654: PPUSH
29655: PPUSH
29656: PPUSH
29657: PPUSH
29658: PPUSH
29659: PPUSH
29660: PPUSH
29661: PPUSH
29662: PPUSH
29663: PPUSH
29664: PPUSH
29665: PPUSH
29666: PPUSH
29667: PPUSH
29668: PPUSH
29669: PPUSH
29670: PPUSH
29671: PPUSH
29672: PPUSH
// result = [ ] ;
29673: LD_ADDR_VAR 0 7
29677: PUSH
29678: EMPTY
29679: ST_TO_ADDR
// temp_list = [ ] ;
29680: LD_ADDR_VAR 0 9
29684: PUSH
29685: EMPTY
29686: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29687: LD_VAR 0 4
29691: PUSH
29692: LD_INT 0
29694: PUSH
29695: LD_INT 1
29697: PUSH
29698: LD_INT 2
29700: PUSH
29701: LD_INT 3
29703: PUSH
29704: LD_INT 4
29706: PUSH
29707: LD_INT 5
29709: PUSH
29710: EMPTY
29711: LIST
29712: LIST
29713: LIST
29714: LIST
29715: LIST
29716: LIST
29717: IN
29718: NOT
29719: PUSH
29720: LD_VAR 0 1
29724: PUSH
29725: LD_INT 0
29727: PUSH
29728: LD_INT 1
29730: PUSH
29731: EMPTY
29732: LIST
29733: LIST
29734: IN
29735: PUSH
29736: LD_VAR 0 5
29740: PUSH
29741: LD_INT 1
29743: PUSH
29744: LD_INT 2
29746: PUSH
29747: LD_INT 3
29749: PUSH
29750: EMPTY
29751: LIST
29752: LIST
29753: LIST
29754: IN
29755: NOT
29756: AND
29757: OR
29758: IFFALSE 29762
// exit ;
29760: GO 48153
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29762: LD_VAR 0 1
29766: PUSH
29767: LD_INT 6
29769: PUSH
29770: LD_INT 7
29772: PUSH
29773: LD_INT 8
29775: PUSH
29776: LD_INT 13
29778: PUSH
29779: LD_INT 12
29781: PUSH
29782: LD_INT 15
29784: PUSH
29785: LD_INT 11
29787: PUSH
29788: LD_INT 14
29790: PUSH
29791: LD_INT 10
29793: PUSH
29794: EMPTY
29795: LIST
29796: LIST
29797: LIST
29798: LIST
29799: LIST
29800: LIST
29801: LIST
29802: LIST
29803: LIST
29804: IN
29805: IFFALSE 29815
// btype = b_lab ;
29807: LD_ADDR_VAR 0 1
29811: PUSH
29812: LD_INT 6
29814: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29815: LD_VAR 0 6
29819: PUSH
29820: LD_INT 0
29822: PUSH
29823: LD_INT 1
29825: PUSH
29826: LD_INT 2
29828: PUSH
29829: EMPTY
29830: LIST
29831: LIST
29832: LIST
29833: IN
29834: NOT
29835: PUSH
29836: LD_VAR 0 1
29840: PUSH
29841: LD_INT 0
29843: PUSH
29844: LD_INT 1
29846: PUSH
29847: LD_INT 2
29849: PUSH
29850: LD_INT 3
29852: PUSH
29853: LD_INT 6
29855: PUSH
29856: LD_INT 36
29858: PUSH
29859: LD_INT 4
29861: PUSH
29862: LD_INT 5
29864: PUSH
29865: LD_INT 31
29867: PUSH
29868: LD_INT 32
29870: PUSH
29871: LD_INT 33
29873: PUSH
29874: EMPTY
29875: LIST
29876: LIST
29877: LIST
29878: LIST
29879: LIST
29880: LIST
29881: LIST
29882: LIST
29883: LIST
29884: LIST
29885: LIST
29886: IN
29887: NOT
29888: PUSH
29889: LD_VAR 0 6
29893: PUSH
29894: LD_INT 1
29896: EQUAL
29897: AND
29898: OR
29899: PUSH
29900: LD_VAR 0 1
29904: PUSH
29905: LD_INT 2
29907: PUSH
29908: LD_INT 3
29910: PUSH
29911: EMPTY
29912: LIST
29913: LIST
29914: IN
29915: NOT
29916: PUSH
29917: LD_VAR 0 6
29921: PUSH
29922: LD_INT 2
29924: EQUAL
29925: AND
29926: OR
29927: IFFALSE 29937
// mode = 0 ;
29929: LD_ADDR_VAR 0 6
29933: PUSH
29934: LD_INT 0
29936: ST_TO_ADDR
// case mode of 0 :
29937: LD_VAR 0 6
29941: PUSH
29942: LD_INT 0
29944: DOUBLE
29945: EQUAL
29946: IFTRUE 29950
29948: GO 41403
29950: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29951: LD_ADDR_VAR 0 11
29955: PUSH
29956: LD_INT 0
29958: PUSH
29959: LD_INT 0
29961: PUSH
29962: EMPTY
29963: LIST
29964: LIST
29965: PUSH
29966: LD_INT 0
29968: PUSH
29969: LD_INT 1
29971: NEG
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: PUSH
29977: LD_INT 1
29979: PUSH
29980: LD_INT 0
29982: PUSH
29983: EMPTY
29984: LIST
29985: LIST
29986: PUSH
29987: LD_INT 1
29989: PUSH
29990: LD_INT 1
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: LD_INT 0
29999: PUSH
30000: LD_INT 1
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: LD_INT 1
30009: NEG
30010: PUSH
30011: LD_INT 0
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: PUSH
30018: LD_INT 1
30020: NEG
30021: PUSH
30022: LD_INT 1
30024: NEG
30025: PUSH
30026: EMPTY
30027: LIST
30028: LIST
30029: PUSH
30030: LD_INT 1
30032: NEG
30033: PUSH
30034: LD_INT 2
30036: NEG
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: LD_INT 0
30044: PUSH
30045: LD_INT 2
30047: NEG
30048: PUSH
30049: EMPTY
30050: LIST
30051: LIST
30052: PUSH
30053: LD_INT 1
30055: PUSH
30056: LD_INT 1
30058: NEG
30059: PUSH
30060: EMPTY
30061: LIST
30062: LIST
30063: PUSH
30064: LD_INT 1
30066: PUSH
30067: LD_INT 2
30069: PUSH
30070: EMPTY
30071: LIST
30072: LIST
30073: PUSH
30074: LD_INT 0
30076: PUSH
30077: LD_INT 2
30079: PUSH
30080: EMPTY
30081: LIST
30082: LIST
30083: PUSH
30084: LD_INT 1
30086: NEG
30087: PUSH
30088: LD_INT 1
30090: PUSH
30091: EMPTY
30092: LIST
30093: LIST
30094: PUSH
30095: LD_INT 1
30097: PUSH
30098: LD_INT 3
30100: PUSH
30101: EMPTY
30102: LIST
30103: LIST
30104: PUSH
30105: LD_INT 0
30107: PUSH
30108: LD_INT 3
30110: PUSH
30111: EMPTY
30112: LIST
30113: LIST
30114: PUSH
30115: LD_INT 1
30117: NEG
30118: PUSH
30119: LD_INT 2
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: PUSH
30126: EMPTY
30127: LIST
30128: LIST
30129: LIST
30130: LIST
30131: LIST
30132: LIST
30133: LIST
30134: LIST
30135: LIST
30136: LIST
30137: LIST
30138: LIST
30139: LIST
30140: LIST
30141: LIST
30142: LIST
30143: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30144: LD_ADDR_VAR 0 12
30148: PUSH
30149: LD_INT 0
30151: PUSH
30152: LD_INT 0
30154: PUSH
30155: EMPTY
30156: LIST
30157: LIST
30158: PUSH
30159: LD_INT 0
30161: PUSH
30162: LD_INT 1
30164: NEG
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 1
30172: PUSH
30173: LD_INT 0
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: LD_INT 1
30182: PUSH
30183: LD_INT 1
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: LD_INT 0
30192: PUSH
30193: LD_INT 1
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: LD_INT 1
30202: NEG
30203: PUSH
30204: LD_INT 0
30206: PUSH
30207: EMPTY
30208: LIST
30209: LIST
30210: PUSH
30211: LD_INT 1
30213: NEG
30214: PUSH
30215: LD_INT 1
30217: NEG
30218: PUSH
30219: EMPTY
30220: LIST
30221: LIST
30222: PUSH
30223: LD_INT 1
30225: PUSH
30226: LD_INT 1
30228: NEG
30229: PUSH
30230: EMPTY
30231: LIST
30232: LIST
30233: PUSH
30234: LD_INT 2
30236: PUSH
30237: LD_INT 0
30239: PUSH
30240: EMPTY
30241: LIST
30242: LIST
30243: PUSH
30244: LD_INT 2
30246: PUSH
30247: LD_INT 1
30249: PUSH
30250: EMPTY
30251: LIST
30252: LIST
30253: PUSH
30254: LD_INT 1
30256: NEG
30257: PUSH
30258: LD_INT 1
30260: PUSH
30261: EMPTY
30262: LIST
30263: LIST
30264: PUSH
30265: LD_INT 2
30267: NEG
30268: PUSH
30269: LD_INT 0
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: PUSH
30276: LD_INT 2
30278: NEG
30279: PUSH
30280: LD_INT 1
30282: NEG
30283: PUSH
30284: EMPTY
30285: LIST
30286: LIST
30287: PUSH
30288: LD_INT 2
30290: NEG
30291: PUSH
30292: LD_INT 1
30294: PUSH
30295: EMPTY
30296: LIST
30297: LIST
30298: PUSH
30299: LD_INT 3
30301: NEG
30302: PUSH
30303: LD_INT 0
30305: PUSH
30306: EMPTY
30307: LIST
30308: LIST
30309: PUSH
30310: LD_INT 3
30312: NEG
30313: PUSH
30314: LD_INT 1
30316: NEG
30317: PUSH
30318: EMPTY
30319: LIST
30320: LIST
30321: PUSH
30322: EMPTY
30323: LIST
30324: LIST
30325: LIST
30326: LIST
30327: LIST
30328: LIST
30329: LIST
30330: LIST
30331: LIST
30332: LIST
30333: LIST
30334: LIST
30335: LIST
30336: LIST
30337: LIST
30338: LIST
30339: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30340: LD_ADDR_VAR 0 13
30344: PUSH
30345: LD_INT 0
30347: PUSH
30348: LD_INT 0
30350: PUSH
30351: EMPTY
30352: LIST
30353: LIST
30354: PUSH
30355: LD_INT 0
30357: PUSH
30358: LD_INT 1
30360: NEG
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: PUSH
30366: LD_INT 1
30368: PUSH
30369: LD_INT 0
30371: PUSH
30372: EMPTY
30373: LIST
30374: LIST
30375: PUSH
30376: LD_INT 1
30378: PUSH
30379: LD_INT 1
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: PUSH
30386: LD_INT 0
30388: PUSH
30389: LD_INT 1
30391: PUSH
30392: EMPTY
30393: LIST
30394: LIST
30395: PUSH
30396: LD_INT 1
30398: NEG
30399: PUSH
30400: LD_INT 0
30402: PUSH
30403: EMPTY
30404: LIST
30405: LIST
30406: PUSH
30407: LD_INT 1
30409: NEG
30410: PUSH
30411: LD_INT 1
30413: NEG
30414: PUSH
30415: EMPTY
30416: LIST
30417: LIST
30418: PUSH
30419: LD_INT 1
30421: NEG
30422: PUSH
30423: LD_INT 2
30425: NEG
30426: PUSH
30427: EMPTY
30428: LIST
30429: LIST
30430: PUSH
30431: LD_INT 2
30433: PUSH
30434: LD_INT 1
30436: PUSH
30437: EMPTY
30438: LIST
30439: LIST
30440: PUSH
30441: LD_INT 2
30443: PUSH
30444: LD_INT 2
30446: PUSH
30447: EMPTY
30448: LIST
30449: LIST
30450: PUSH
30451: LD_INT 1
30453: PUSH
30454: LD_INT 2
30456: PUSH
30457: EMPTY
30458: LIST
30459: LIST
30460: PUSH
30461: LD_INT 2
30463: NEG
30464: PUSH
30465: LD_INT 1
30467: NEG
30468: PUSH
30469: EMPTY
30470: LIST
30471: LIST
30472: PUSH
30473: LD_INT 2
30475: NEG
30476: PUSH
30477: LD_INT 2
30479: NEG
30480: PUSH
30481: EMPTY
30482: LIST
30483: LIST
30484: PUSH
30485: LD_INT 2
30487: NEG
30488: PUSH
30489: LD_INT 3
30491: NEG
30492: PUSH
30493: EMPTY
30494: LIST
30495: LIST
30496: PUSH
30497: LD_INT 3
30499: NEG
30500: PUSH
30501: LD_INT 2
30503: NEG
30504: PUSH
30505: EMPTY
30506: LIST
30507: LIST
30508: PUSH
30509: LD_INT 3
30511: NEG
30512: PUSH
30513: LD_INT 3
30515: NEG
30516: PUSH
30517: EMPTY
30518: LIST
30519: LIST
30520: PUSH
30521: EMPTY
30522: LIST
30523: LIST
30524: LIST
30525: LIST
30526: LIST
30527: LIST
30528: LIST
30529: LIST
30530: LIST
30531: LIST
30532: LIST
30533: LIST
30534: LIST
30535: LIST
30536: LIST
30537: LIST
30538: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
30539: LD_ADDR_VAR 0 14
30543: PUSH
30544: LD_INT 0
30546: PUSH
30547: LD_INT 0
30549: PUSH
30550: EMPTY
30551: LIST
30552: LIST
30553: PUSH
30554: LD_INT 0
30556: PUSH
30557: LD_INT 1
30559: NEG
30560: PUSH
30561: EMPTY
30562: LIST
30563: LIST
30564: PUSH
30565: LD_INT 1
30567: PUSH
30568: LD_INT 0
30570: PUSH
30571: EMPTY
30572: LIST
30573: LIST
30574: PUSH
30575: LD_INT 1
30577: PUSH
30578: LD_INT 1
30580: PUSH
30581: EMPTY
30582: LIST
30583: LIST
30584: PUSH
30585: LD_INT 0
30587: PUSH
30588: LD_INT 1
30590: PUSH
30591: EMPTY
30592: LIST
30593: LIST
30594: PUSH
30595: LD_INT 1
30597: NEG
30598: PUSH
30599: LD_INT 0
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: LD_INT 1
30608: NEG
30609: PUSH
30610: LD_INT 1
30612: NEG
30613: PUSH
30614: EMPTY
30615: LIST
30616: LIST
30617: PUSH
30618: LD_INT 1
30620: NEG
30621: PUSH
30622: LD_INT 2
30624: NEG
30625: PUSH
30626: EMPTY
30627: LIST
30628: LIST
30629: PUSH
30630: LD_INT 0
30632: PUSH
30633: LD_INT 2
30635: NEG
30636: PUSH
30637: EMPTY
30638: LIST
30639: LIST
30640: PUSH
30641: LD_INT 1
30643: PUSH
30644: LD_INT 1
30646: NEG
30647: PUSH
30648: EMPTY
30649: LIST
30650: LIST
30651: PUSH
30652: LD_INT 1
30654: PUSH
30655: LD_INT 2
30657: PUSH
30658: EMPTY
30659: LIST
30660: LIST
30661: PUSH
30662: LD_INT 0
30664: PUSH
30665: LD_INT 2
30667: PUSH
30668: EMPTY
30669: LIST
30670: LIST
30671: PUSH
30672: LD_INT 1
30674: NEG
30675: PUSH
30676: LD_INT 1
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: LD_INT 1
30685: NEG
30686: PUSH
30687: LD_INT 3
30689: NEG
30690: PUSH
30691: EMPTY
30692: LIST
30693: LIST
30694: PUSH
30695: LD_INT 0
30697: PUSH
30698: LD_INT 3
30700: NEG
30701: PUSH
30702: EMPTY
30703: LIST
30704: LIST
30705: PUSH
30706: LD_INT 1
30708: PUSH
30709: LD_INT 2
30711: NEG
30712: PUSH
30713: EMPTY
30714: LIST
30715: LIST
30716: PUSH
30717: EMPTY
30718: LIST
30719: LIST
30720: LIST
30721: LIST
30722: LIST
30723: LIST
30724: LIST
30725: LIST
30726: LIST
30727: LIST
30728: LIST
30729: LIST
30730: LIST
30731: LIST
30732: LIST
30733: LIST
30734: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30735: LD_ADDR_VAR 0 15
30739: PUSH
30740: LD_INT 0
30742: PUSH
30743: LD_INT 0
30745: PUSH
30746: EMPTY
30747: LIST
30748: LIST
30749: PUSH
30750: LD_INT 0
30752: PUSH
30753: LD_INT 1
30755: NEG
30756: PUSH
30757: EMPTY
30758: LIST
30759: LIST
30760: PUSH
30761: LD_INT 1
30763: PUSH
30764: LD_INT 0
30766: PUSH
30767: EMPTY
30768: LIST
30769: LIST
30770: PUSH
30771: LD_INT 1
30773: PUSH
30774: LD_INT 1
30776: PUSH
30777: EMPTY
30778: LIST
30779: LIST
30780: PUSH
30781: LD_INT 0
30783: PUSH
30784: LD_INT 1
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 1
30793: NEG
30794: PUSH
30795: LD_INT 0
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: LD_INT 1
30804: NEG
30805: PUSH
30806: LD_INT 1
30808: NEG
30809: PUSH
30810: EMPTY
30811: LIST
30812: LIST
30813: PUSH
30814: LD_INT 1
30816: PUSH
30817: LD_INT 1
30819: NEG
30820: PUSH
30821: EMPTY
30822: LIST
30823: LIST
30824: PUSH
30825: LD_INT 2
30827: PUSH
30828: LD_INT 0
30830: PUSH
30831: EMPTY
30832: LIST
30833: LIST
30834: PUSH
30835: LD_INT 2
30837: PUSH
30838: LD_INT 1
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: PUSH
30845: LD_INT 1
30847: NEG
30848: PUSH
30849: LD_INT 1
30851: PUSH
30852: EMPTY
30853: LIST
30854: LIST
30855: PUSH
30856: LD_INT 2
30858: NEG
30859: PUSH
30860: LD_INT 0
30862: PUSH
30863: EMPTY
30864: LIST
30865: LIST
30866: PUSH
30867: LD_INT 2
30869: NEG
30870: PUSH
30871: LD_INT 1
30873: NEG
30874: PUSH
30875: EMPTY
30876: LIST
30877: LIST
30878: PUSH
30879: LD_INT 2
30881: PUSH
30882: LD_INT 1
30884: NEG
30885: PUSH
30886: EMPTY
30887: LIST
30888: LIST
30889: PUSH
30890: LD_INT 3
30892: PUSH
30893: LD_INT 0
30895: PUSH
30896: EMPTY
30897: LIST
30898: LIST
30899: PUSH
30900: LD_INT 3
30902: PUSH
30903: LD_INT 1
30905: PUSH
30906: EMPTY
30907: LIST
30908: LIST
30909: PUSH
30910: EMPTY
30911: LIST
30912: LIST
30913: LIST
30914: LIST
30915: LIST
30916: LIST
30917: LIST
30918: LIST
30919: LIST
30920: LIST
30921: LIST
30922: LIST
30923: LIST
30924: LIST
30925: LIST
30926: LIST
30927: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30928: LD_ADDR_VAR 0 16
30932: PUSH
30933: LD_INT 0
30935: PUSH
30936: LD_INT 0
30938: PUSH
30939: EMPTY
30940: LIST
30941: LIST
30942: PUSH
30943: LD_INT 0
30945: PUSH
30946: LD_INT 1
30948: NEG
30949: PUSH
30950: EMPTY
30951: LIST
30952: LIST
30953: PUSH
30954: LD_INT 1
30956: PUSH
30957: LD_INT 0
30959: PUSH
30960: EMPTY
30961: LIST
30962: LIST
30963: PUSH
30964: LD_INT 1
30966: PUSH
30967: LD_INT 1
30969: PUSH
30970: EMPTY
30971: LIST
30972: LIST
30973: PUSH
30974: LD_INT 0
30976: PUSH
30977: LD_INT 1
30979: PUSH
30980: EMPTY
30981: LIST
30982: LIST
30983: PUSH
30984: LD_INT 1
30986: NEG
30987: PUSH
30988: LD_INT 0
30990: PUSH
30991: EMPTY
30992: LIST
30993: LIST
30994: PUSH
30995: LD_INT 1
30997: NEG
30998: PUSH
30999: LD_INT 1
31001: NEG
31002: PUSH
31003: EMPTY
31004: LIST
31005: LIST
31006: PUSH
31007: LD_INT 1
31009: NEG
31010: PUSH
31011: LD_INT 2
31013: NEG
31014: PUSH
31015: EMPTY
31016: LIST
31017: LIST
31018: PUSH
31019: LD_INT 2
31021: PUSH
31022: LD_INT 1
31024: PUSH
31025: EMPTY
31026: LIST
31027: LIST
31028: PUSH
31029: LD_INT 2
31031: PUSH
31032: LD_INT 2
31034: PUSH
31035: EMPTY
31036: LIST
31037: LIST
31038: PUSH
31039: LD_INT 1
31041: PUSH
31042: LD_INT 2
31044: PUSH
31045: EMPTY
31046: LIST
31047: LIST
31048: PUSH
31049: LD_INT 2
31051: NEG
31052: PUSH
31053: LD_INT 1
31055: NEG
31056: PUSH
31057: EMPTY
31058: LIST
31059: LIST
31060: PUSH
31061: LD_INT 2
31063: NEG
31064: PUSH
31065: LD_INT 2
31067: NEG
31068: PUSH
31069: EMPTY
31070: LIST
31071: LIST
31072: PUSH
31073: LD_INT 3
31075: PUSH
31076: LD_INT 2
31078: PUSH
31079: EMPTY
31080: LIST
31081: LIST
31082: PUSH
31083: LD_INT 3
31085: PUSH
31086: LD_INT 3
31088: PUSH
31089: EMPTY
31090: LIST
31091: LIST
31092: PUSH
31093: LD_INT 2
31095: PUSH
31096: LD_INT 3
31098: PUSH
31099: EMPTY
31100: LIST
31101: LIST
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: LIST
31107: LIST
31108: LIST
31109: LIST
31110: LIST
31111: LIST
31112: LIST
31113: LIST
31114: LIST
31115: LIST
31116: LIST
31117: LIST
31118: LIST
31119: LIST
31120: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31121: LD_ADDR_VAR 0 17
31125: PUSH
31126: LD_INT 0
31128: PUSH
31129: LD_INT 0
31131: PUSH
31132: EMPTY
31133: LIST
31134: LIST
31135: PUSH
31136: LD_INT 0
31138: PUSH
31139: LD_INT 1
31141: NEG
31142: PUSH
31143: EMPTY
31144: LIST
31145: LIST
31146: PUSH
31147: LD_INT 1
31149: PUSH
31150: LD_INT 0
31152: PUSH
31153: EMPTY
31154: LIST
31155: LIST
31156: PUSH
31157: LD_INT 1
31159: PUSH
31160: LD_INT 1
31162: PUSH
31163: EMPTY
31164: LIST
31165: LIST
31166: PUSH
31167: LD_INT 0
31169: PUSH
31170: LD_INT 1
31172: PUSH
31173: EMPTY
31174: LIST
31175: LIST
31176: PUSH
31177: LD_INT 1
31179: NEG
31180: PUSH
31181: LD_INT 0
31183: PUSH
31184: EMPTY
31185: LIST
31186: LIST
31187: PUSH
31188: LD_INT 1
31190: NEG
31191: PUSH
31192: LD_INT 1
31194: NEG
31195: PUSH
31196: EMPTY
31197: LIST
31198: LIST
31199: PUSH
31200: LD_INT 1
31202: NEG
31203: PUSH
31204: LD_INT 2
31206: NEG
31207: PUSH
31208: EMPTY
31209: LIST
31210: LIST
31211: PUSH
31212: LD_INT 0
31214: PUSH
31215: LD_INT 2
31217: NEG
31218: PUSH
31219: EMPTY
31220: LIST
31221: LIST
31222: PUSH
31223: LD_INT 1
31225: PUSH
31226: LD_INT 1
31228: NEG
31229: PUSH
31230: EMPTY
31231: LIST
31232: LIST
31233: PUSH
31234: LD_INT 2
31236: PUSH
31237: LD_INT 0
31239: PUSH
31240: EMPTY
31241: LIST
31242: LIST
31243: PUSH
31244: LD_INT 2
31246: PUSH
31247: LD_INT 1
31249: PUSH
31250: EMPTY
31251: LIST
31252: LIST
31253: PUSH
31254: LD_INT 2
31256: PUSH
31257: LD_INT 2
31259: PUSH
31260: EMPTY
31261: LIST
31262: LIST
31263: PUSH
31264: LD_INT 1
31266: PUSH
31267: LD_INT 2
31269: PUSH
31270: EMPTY
31271: LIST
31272: LIST
31273: PUSH
31274: LD_INT 0
31276: PUSH
31277: LD_INT 2
31279: PUSH
31280: EMPTY
31281: LIST
31282: LIST
31283: PUSH
31284: LD_INT 1
31286: NEG
31287: PUSH
31288: LD_INT 1
31290: PUSH
31291: EMPTY
31292: LIST
31293: LIST
31294: PUSH
31295: LD_INT 2
31297: NEG
31298: PUSH
31299: LD_INT 0
31301: PUSH
31302: EMPTY
31303: LIST
31304: LIST
31305: PUSH
31306: LD_INT 2
31308: NEG
31309: PUSH
31310: LD_INT 1
31312: NEG
31313: PUSH
31314: EMPTY
31315: LIST
31316: LIST
31317: PUSH
31318: LD_INT 2
31320: NEG
31321: PUSH
31322: LD_INT 2
31324: NEG
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: EMPTY
31331: LIST
31332: LIST
31333: LIST
31334: LIST
31335: LIST
31336: LIST
31337: LIST
31338: LIST
31339: LIST
31340: LIST
31341: LIST
31342: LIST
31343: LIST
31344: LIST
31345: LIST
31346: LIST
31347: LIST
31348: LIST
31349: LIST
31350: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31351: LD_ADDR_VAR 0 18
31355: PUSH
31356: LD_INT 0
31358: PUSH
31359: LD_INT 0
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: LD_INT 0
31368: PUSH
31369: LD_INT 1
31371: NEG
31372: PUSH
31373: EMPTY
31374: LIST
31375: LIST
31376: PUSH
31377: LD_INT 1
31379: PUSH
31380: LD_INT 0
31382: PUSH
31383: EMPTY
31384: LIST
31385: LIST
31386: PUSH
31387: LD_INT 1
31389: PUSH
31390: LD_INT 1
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: LD_INT 0
31399: PUSH
31400: LD_INT 1
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 1
31409: NEG
31410: PUSH
31411: LD_INT 0
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 1
31420: NEG
31421: PUSH
31422: LD_INT 1
31424: NEG
31425: PUSH
31426: EMPTY
31427: LIST
31428: LIST
31429: PUSH
31430: LD_INT 1
31432: NEG
31433: PUSH
31434: LD_INT 2
31436: NEG
31437: PUSH
31438: EMPTY
31439: LIST
31440: LIST
31441: PUSH
31442: LD_INT 0
31444: PUSH
31445: LD_INT 2
31447: NEG
31448: PUSH
31449: EMPTY
31450: LIST
31451: LIST
31452: PUSH
31453: LD_INT 1
31455: PUSH
31456: LD_INT 1
31458: NEG
31459: PUSH
31460: EMPTY
31461: LIST
31462: LIST
31463: PUSH
31464: LD_INT 2
31466: PUSH
31467: LD_INT 0
31469: PUSH
31470: EMPTY
31471: LIST
31472: LIST
31473: PUSH
31474: LD_INT 2
31476: PUSH
31477: LD_INT 1
31479: PUSH
31480: EMPTY
31481: LIST
31482: LIST
31483: PUSH
31484: LD_INT 2
31486: PUSH
31487: LD_INT 2
31489: PUSH
31490: EMPTY
31491: LIST
31492: LIST
31493: PUSH
31494: LD_INT 1
31496: PUSH
31497: LD_INT 2
31499: PUSH
31500: EMPTY
31501: LIST
31502: LIST
31503: PUSH
31504: LD_INT 0
31506: PUSH
31507: LD_INT 2
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 1
31516: NEG
31517: PUSH
31518: LD_INT 1
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 2
31527: NEG
31528: PUSH
31529: LD_INT 0
31531: PUSH
31532: EMPTY
31533: LIST
31534: LIST
31535: PUSH
31536: LD_INT 2
31538: NEG
31539: PUSH
31540: LD_INT 1
31542: NEG
31543: PUSH
31544: EMPTY
31545: LIST
31546: LIST
31547: PUSH
31548: LD_INT 2
31550: NEG
31551: PUSH
31552: LD_INT 2
31554: NEG
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: EMPTY
31561: LIST
31562: LIST
31563: LIST
31564: LIST
31565: LIST
31566: LIST
31567: LIST
31568: LIST
31569: LIST
31570: LIST
31571: LIST
31572: LIST
31573: LIST
31574: LIST
31575: LIST
31576: LIST
31577: LIST
31578: LIST
31579: LIST
31580: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31581: LD_ADDR_VAR 0 19
31585: PUSH
31586: LD_INT 0
31588: PUSH
31589: LD_INT 0
31591: PUSH
31592: EMPTY
31593: LIST
31594: LIST
31595: PUSH
31596: LD_INT 0
31598: PUSH
31599: LD_INT 1
31601: NEG
31602: PUSH
31603: EMPTY
31604: LIST
31605: LIST
31606: PUSH
31607: LD_INT 1
31609: PUSH
31610: LD_INT 0
31612: PUSH
31613: EMPTY
31614: LIST
31615: LIST
31616: PUSH
31617: LD_INT 1
31619: PUSH
31620: LD_INT 1
31622: PUSH
31623: EMPTY
31624: LIST
31625: LIST
31626: PUSH
31627: LD_INT 0
31629: PUSH
31630: LD_INT 1
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: PUSH
31637: LD_INT 1
31639: NEG
31640: PUSH
31641: LD_INT 0
31643: PUSH
31644: EMPTY
31645: LIST
31646: LIST
31647: PUSH
31648: LD_INT 1
31650: NEG
31651: PUSH
31652: LD_INT 1
31654: NEG
31655: PUSH
31656: EMPTY
31657: LIST
31658: LIST
31659: PUSH
31660: LD_INT 1
31662: NEG
31663: PUSH
31664: LD_INT 2
31666: NEG
31667: PUSH
31668: EMPTY
31669: LIST
31670: LIST
31671: PUSH
31672: LD_INT 0
31674: PUSH
31675: LD_INT 2
31677: NEG
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PUSH
31683: LD_INT 1
31685: PUSH
31686: LD_INT 1
31688: NEG
31689: PUSH
31690: EMPTY
31691: LIST
31692: LIST
31693: PUSH
31694: LD_INT 2
31696: PUSH
31697: LD_INT 0
31699: PUSH
31700: EMPTY
31701: LIST
31702: LIST
31703: PUSH
31704: LD_INT 2
31706: PUSH
31707: LD_INT 1
31709: PUSH
31710: EMPTY
31711: LIST
31712: LIST
31713: PUSH
31714: LD_INT 2
31716: PUSH
31717: LD_INT 2
31719: PUSH
31720: EMPTY
31721: LIST
31722: LIST
31723: PUSH
31724: LD_INT 1
31726: PUSH
31727: LD_INT 2
31729: PUSH
31730: EMPTY
31731: LIST
31732: LIST
31733: PUSH
31734: LD_INT 0
31736: PUSH
31737: LD_INT 2
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: PUSH
31744: LD_INT 1
31746: NEG
31747: PUSH
31748: LD_INT 1
31750: PUSH
31751: EMPTY
31752: LIST
31753: LIST
31754: PUSH
31755: LD_INT 2
31757: NEG
31758: PUSH
31759: LD_INT 0
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 2
31768: NEG
31769: PUSH
31770: LD_INT 1
31772: NEG
31773: PUSH
31774: EMPTY
31775: LIST
31776: LIST
31777: PUSH
31778: LD_INT 2
31780: NEG
31781: PUSH
31782: LD_INT 2
31784: NEG
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: EMPTY
31791: LIST
31792: LIST
31793: LIST
31794: LIST
31795: LIST
31796: LIST
31797: LIST
31798: LIST
31799: LIST
31800: LIST
31801: LIST
31802: LIST
31803: LIST
31804: LIST
31805: LIST
31806: LIST
31807: LIST
31808: LIST
31809: LIST
31810: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31811: LD_ADDR_VAR 0 20
31815: PUSH
31816: LD_INT 0
31818: PUSH
31819: LD_INT 0
31821: PUSH
31822: EMPTY
31823: LIST
31824: LIST
31825: PUSH
31826: LD_INT 0
31828: PUSH
31829: LD_INT 1
31831: NEG
31832: PUSH
31833: EMPTY
31834: LIST
31835: LIST
31836: PUSH
31837: LD_INT 1
31839: PUSH
31840: LD_INT 0
31842: PUSH
31843: EMPTY
31844: LIST
31845: LIST
31846: PUSH
31847: LD_INT 1
31849: PUSH
31850: LD_INT 1
31852: PUSH
31853: EMPTY
31854: LIST
31855: LIST
31856: PUSH
31857: LD_INT 0
31859: PUSH
31860: LD_INT 1
31862: PUSH
31863: EMPTY
31864: LIST
31865: LIST
31866: PUSH
31867: LD_INT 1
31869: NEG
31870: PUSH
31871: LD_INT 0
31873: PUSH
31874: EMPTY
31875: LIST
31876: LIST
31877: PUSH
31878: LD_INT 1
31880: NEG
31881: PUSH
31882: LD_INT 1
31884: NEG
31885: PUSH
31886: EMPTY
31887: LIST
31888: LIST
31889: PUSH
31890: LD_INT 1
31892: NEG
31893: PUSH
31894: LD_INT 2
31896: NEG
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: PUSH
31902: LD_INT 0
31904: PUSH
31905: LD_INT 2
31907: NEG
31908: PUSH
31909: EMPTY
31910: LIST
31911: LIST
31912: PUSH
31913: LD_INT 1
31915: PUSH
31916: LD_INT 1
31918: NEG
31919: PUSH
31920: EMPTY
31921: LIST
31922: LIST
31923: PUSH
31924: LD_INT 2
31926: PUSH
31927: LD_INT 0
31929: PUSH
31930: EMPTY
31931: LIST
31932: LIST
31933: PUSH
31934: LD_INT 2
31936: PUSH
31937: LD_INT 1
31939: PUSH
31940: EMPTY
31941: LIST
31942: LIST
31943: PUSH
31944: LD_INT 2
31946: PUSH
31947: LD_INT 2
31949: PUSH
31950: EMPTY
31951: LIST
31952: LIST
31953: PUSH
31954: LD_INT 1
31956: PUSH
31957: LD_INT 2
31959: PUSH
31960: EMPTY
31961: LIST
31962: LIST
31963: PUSH
31964: LD_INT 0
31966: PUSH
31967: LD_INT 2
31969: PUSH
31970: EMPTY
31971: LIST
31972: LIST
31973: PUSH
31974: LD_INT 1
31976: NEG
31977: PUSH
31978: LD_INT 1
31980: PUSH
31981: EMPTY
31982: LIST
31983: LIST
31984: PUSH
31985: LD_INT 2
31987: NEG
31988: PUSH
31989: LD_INT 0
31991: PUSH
31992: EMPTY
31993: LIST
31994: LIST
31995: PUSH
31996: LD_INT 2
31998: NEG
31999: PUSH
32000: LD_INT 1
32002: NEG
32003: PUSH
32004: EMPTY
32005: LIST
32006: LIST
32007: PUSH
32008: LD_INT 2
32010: NEG
32011: PUSH
32012: LD_INT 2
32014: NEG
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: EMPTY
32021: LIST
32022: LIST
32023: LIST
32024: LIST
32025: LIST
32026: LIST
32027: LIST
32028: LIST
32029: LIST
32030: LIST
32031: LIST
32032: LIST
32033: LIST
32034: LIST
32035: LIST
32036: LIST
32037: LIST
32038: LIST
32039: LIST
32040: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32041: LD_ADDR_VAR 0 21
32045: PUSH
32046: LD_INT 0
32048: PUSH
32049: LD_INT 0
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PUSH
32056: LD_INT 0
32058: PUSH
32059: LD_INT 1
32061: NEG
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: PUSH
32067: LD_INT 1
32069: PUSH
32070: LD_INT 0
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: PUSH
32077: LD_INT 1
32079: PUSH
32080: LD_INT 1
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: PUSH
32087: LD_INT 0
32089: PUSH
32090: LD_INT 1
32092: PUSH
32093: EMPTY
32094: LIST
32095: LIST
32096: PUSH
32097: LD_INT 1
32099: NEG
32100: PUSH
32101: LD_INT 0
32103: PUSH
32104: EMPTY
32105: LIST
32106: LIST
32107: PUSH
32108: LD_INT 1
32110: NEG
32111: PUSH
32112: LD_INT 1
32114: NEG
32115: PUSH
32116: EMPTY
32117: LIST
32118: LIST
32119: PUSH
32120: LD_INT 1
32122: NEG
32123: PUSH
32124: LD_INT 2
32126: NEG
32127: PUSH
32128: EMPTY
32129: LIST
32130: LIST
32131: PUSH
32132: LD_INT 0
32134: PUSH
32135: LD_INT 2
32137: NEG
32138: PUSH
32139: EMPTY
32140: LIST
32141: LIST
32142: PUSH
32143: LD_INT 1
32145: PUSH
32146: LD_INT 1
32148: NEG
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PUSH
32154: LD_INT 2
32156: PUSH
32157: LD_INT 0
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: LD_INT 2
32166: PUSH
32167: LD_INT 1
32169: PUSH
32170: EMPTY
32171: LIST
32172: LIST
32173: PUSH
32174: LD_INT 2
32176: PUSH
32177: LD_INT 2
32179: PUSH
32180: EMPTY
32181: LIST
32182: LIST
32183: PUSH
32184: LD_INT 1
32186: PUSH
32187: LD_INT 2
32189: PUSH
32190: EMPTY
32191: LIST
32192: LIST
32193: PUSH
32194: LD_INT 0
32196: PUSH
32197: LD_INT 2
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PUSH
32204: LD_INT 1
32206: NEG
32207: PUSH
32208: LD_INT 1
32210: PUSH
32211: EMPTY
32212: LIST
32213: LIST
32214: PUSH
32215: LD_INT 2
32217: NEG
32218: PUSH
32219: LD_INT 0
32221: PUSH
32222: EMPTY
32223: LIST
32224: LIST
32225: PUSH
32226: LD_INT 2
32228: NEG
32229: PUSH
32230: LD_INT 1
32232: NEG
32233: PUSH
32234: EMPTY
32235: LIST
32236: LIST
32237: PUSH
32238: LD_INT 2
32240: NEG
32241: PUSH
32242: LD_INT 2
32244: NEG
32245: PUSH
32246: EMPTY
32247: LIST
32248: LIST
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: LIST
32254: LIST
32255: LIST
32256: LIST
32257: LIST
32258: LIST
32259: LIST
32260: LIST
32261: LIST
32262: LIST
32263: LIST
32264: LIST
32265: LIST
32266: LIST
32267: LIST
32268: LIST
32269: LIST
32270: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32271: LD_ADDR_VAR 0 22
32275: PUSH
32276: LD_INT 0
32278: PUSH
32279: LD_INT 0
32281: PUSH
32282: EMPTY
32283: LIST
32284: LIST
32285: PUSH
32286: LD_INT 0
32288: PUSH
32289: LD_INT 1
32291: NEG
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 1
32299: PUSH
32300: LD_INT 0
32302: PUSH
32303: EMPTY
32304: LIST
32305: LIST
32306: PUSH
32307: LD_INT 1
32309: PUSH
32310: LD_INT 1
32312: PUSH
32313: EMPTY
32314: LIST
32315: LIST
32316: PUSH
32317: LD_INT 0
32319: PUSH
32320: LD_INT 1
32322: PUSH
32323: EMPTY
32324: LIST
32325: LIST
32326: PUSH
32327: LD_INT 1
32329: NEG
32330: PUSH
32331: LD_INT 0
32333: PUSH
32334: EMPTY
32335: LIST
32336: LIST
32337: PUSH
32338: LD_INT 1
32340: NEG
32341: PUSH
32342: LD_INT 1
32344: NEG
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PUSH
32350: LD_INT 1
32352: NEG
32353: PUSH
32354: LD_INT 2
32356: NEG
32357: PUSH
32358: EMPTY
32359: LIST
32360: LIST
32361: PUSH
32362: LD_INT 0
32364: PUSH
32365: LD_INT 2
32367: NEG
32368: PUSH
32369: EMPTY
32370: LIST
32371: LIST
32372: PUSH
32373: LD_INT 1
32375: PUSH
32376: LD_INT 1
32378: NEG
32379: PUSH
32380: EMPTY
32381: LIST
32382: LIST
32383: PUSH
32384: LD_INT 2
32386: PUSH
32387: LD_INT 0
32389: PUSH
32390: EMPTY
32391: LIST
32392: LIST
32393: PUSH
32394: LD_INT 2
32396: PUSH
32397: LD_INT 1
32399: PUSH
32400: EMPTY
32401: LIST
32402: LIST
32403: PUSH
32404: LD_INT 2
32406: PUSH
32407: LD_INT 2
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 1
32416: PUSH
32417: LD_INT 2
32419: PUSH
32420: EMPTY
32421: LIST
32422: LIST
32423: PUSH
32424: LD_INT 0
32426: PUSH
32427: LD_INT 2
32429: PUSH
32430: EMPTY
32431: LIST
32432: LIST
32433: PUSH
32434: LD_INT 1
32436: NEG
32437: PUSH
32438: LD_INT 1
32440: PUSH
32441: EMPTY
32442: LIST
32443: LIST
32444: PUSH
32445: LD_INT 2
32447: NEG
32448: PUSH
32449: LD_INT 0
32451: PUSH
32452: EMPTY
32453: LIST
32454: LIST
32455: PUSH
32456: LD_INT 2
32458: NEG
32459: PUSH
32460: LD_INT 1
32462: NEG
32463: PUSH
32464: EMPTY
32465: LIST
32466: LIST
32467: PUSH
32468: LD_INT 2
32470: NEG
32471: PUSH
32472: LD_INT 2
32474: NEG
32475: PUSH
32476: EMPTY
32477: LIST
32478: LIST
32479: PUSH
32480: EMPTY
32481: LIST
32482: LIST
32483: LIST
32484: LIST
32485: LIST
32486: LIST
32487: LIST
32488: LIST
32489: LIST
32490: LIST
32491: LIST
32492: LIST
32493: LIST
32494: LIST
32495: LIST
32496: LIST
32497: LIST
32498: LIST
32499: LIST
32500: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
32501: LD_ADDR_VAR 0 23
32505: PUSH
32506: LD_INT 0
32508: PUSH
32509: LD_INT 0
32511: PUSH
32512: EMPTY
32513: LIST
32514: LIST
32515: PUSH
32516: LD_INT 0
32518: PUSH
32519: LD_INT 1
32521: NEG
32522: PUSH
32523: EMPTY
32524: LIST
32525: LIST
32526: PUSH
32527: LD_INT 1
32529: PUSH
32530: LD_INT 0
32532: PUSH
32533: EMPTY
32534: LIST
32535: LIST
32536: PUSH
32537: LD_INT 1
32539: PUSH
32540: LD_INT 1
32542: PUSH
32543: EMPTY
32544: LIST
32545: LIST
32546: PUSH
32547: LD_INT 0
32549: PUSH
32550: LD_INT 1
32552: PUSH
32553: EMPTY
32554: LIST
32555: LIST
32556: PUSH
32557: LD_INT 1
32559: NEG
32560: PUSH
32561: LD_INT 0
32563: PUSH
32564: EMPTY
32565: LIST
32566: LIST
32567: PUSH
32568: LD_INT 1
32570: NEG
32571: PUSH
32572: LD_INT 1
32574: NEG
32575: PUSH
32576: EMPTY
32577: LIST
32578: LIST
32579: PUSH
32580: LD_INT 1
32582: NEG
32583: PUSH
32584: LD_INT 2
32586: NEG
32587: PUSH
32588: EMPTY
32589: LIST
32590: LIST
32591: PUSH
32592: LD_INT 0
32594: PUSH
32595: LD_INT 2
32597: NEG
32598: PUSH
32599: EMPTY
32600: LIST
32601: LIST
32602: PUSH
32603: LD_INT 1
32605: PUSH
32606: LD_INT 1
32608: NEG
32609: PUSH
32610: EMPTY
32611: LIST
32612: LIST
32613: PUSH
32614: LD_INT 2
32616: PUSH
32617: LD_INT 0
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: LD_INT 2
32626: PUSH
32627: LD_INT 1
32629: PUSH
32630: EMPTY
32631: LIST
32632: LIST
32633: PUSH
32634: LD_INT 2
32636: PUSH
32637: LD_INT 2
32639: PUSH
32640: EMPTY
32641: LIST
32642: LIST
32643: PUSH
32644: LD_INT 1
32646: PUSH
32647: LD_INT 2
32649: PUSH
32650: EMPTY
32651: LIST
32652: LIST
32653: PUSH
32654: LD_INT 0
32656: PUSH
32657: LD_INT 2
32659: PUSH
32660: EMPTY
32661: LIST
32662: LIST
32663: PUSH
32664: LD_INT 1
32666: NEG
32667: PUSH
32668: LD_INT 1
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: PUSH
32675: LD_INT 2
32677: NEG
32678: PUSH
32679: LD_INT 0
32681: PUSH
32682: EMPTY
32683: LIST
32684: LIST
32685: PUSH
32686: LD_INT 2
32688: NEG
32689: PUSH
32690: LD_INT 1
32692: NEG
32693: PUSH
32694: EMPTY
32695: LIST
32696: LIST
32697: PUSH
32698: LD_INT 2
32700: NEG
32701: PUSH
32702: LD_INT 2
32704: NEG
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PUSH
32710: LD_INT 2
32712: NEG
32713: PUSH
32714: LD_INT 3
32716: NEG
32717: PUSH
32718: EMPTY
32719: LIST
32720: LIST
32721: PUSH
32722: LD_INT 1
32724: NEG
32725: PUSH
32726: LD_INT 3
32728: NEG
32729: PUSH
32730: EMPTY
32731: LIST
32732: LIST
32733: PUSH
32734: LD_INT 1
32736: PUSH
32737: LD_INT 2
32739: NEG
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 2
32747: PUSH
32748: LD_INT 1
32750: NEG
32751: PUSH
32752: EMPTY
32753: LIST
32754: LIST
32755: PUSH
32756: EMPTY
32757: LIST
32758: LIST
32759: LIST
32760: LIST
32761: LIST
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: LIST
32767: LIST
32768: LIST
32769: LIST
32770: LIST
32771: LIST
32772: LIST
32773: LIST
32774: LIST
32775: LIST
32776: LIST
32777: LIST
32778: LIST
32779: LIST
32780: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32781: LD_ADDR_VAR 0 24
32785: PUSH
32786: LD_INT 0
32788: PUSH
32789: LD_INT 0
32791: PUSH
32792: EMPTY
32793: LIST
32794: LIST
32795: PUSH
32796: LD_INT 0
32798: PUSH
32799: LD_INT 1
32801: NEG
32802: PUSH
32803: EMPTY
32804: LIST
32805: LIST
32806: PUSH
32807: LD_INT 1
32809: PUSH
32810: LD_INT 0
32812: PUSH
32813: EMPTY
32814: LIST
32815: LIST
32816: PUSH
32817: LD_INT 1
32819: PUSH
32820: LD_INT 1
32822: PUSH
32823: EMPTY
32824: LIST
32825: LIST
32826: PUSH
32827: LD_INT 0
32829: PUSH
32830: LD_INT 1
32832: PUSH
32833: EMPTY
32834: LIST
32835: LIST
32836: PUSH
32837: LD_INT 1
32839: NEG
32840: PUSH
32841: LD_INT 0
32843: PUSH
32844: EMPTY
32845: LIST
32846: LIST
32847: PUSH
32848: LD_INT 1
32850: NEG
32851: PUSH
32852: LD_INT 1
32854: NEG
32855: PUSH
32856: EMPTY
32857: LIST
32858: LIST
32859: PUSH
32860: LD_INT 1
32862: NEG
32863: PUSH
32864: LD_INT 2
32866: NEG
32867: PUSH
32868: EMPTY
32869: LIST
32870: LIST
32871: PUSH
32872: LD_INT 0
32874: PUSH
32875: LD_INT 2
32877: NEG
32878: PUSH
32879: EMPTY
32880: LIST
32881: LIST
32882: PUSH
32883: LD_INT 1
32885: PUSH
32886: LD_INT 1
32888: NEG
32889: PUSH
32890: EMPTY
32891: LIST
32892: LIST
32893: PUSH
32894: LD_INT 2
32896: PUSH
32897: LD_INT 0
32899: PUSH
32900: EMPTY
32901: LIST
32902: LIST
32903: PUSH
32904: LD_INT 2
32906: PUSH
32907: LD_INT 1
32909: PUSH
32910: EMPTY
32911: LIST
32912: LIST
32913: PUSH
32914: LD_INT 2
32916: PUSH
32917: LD_INT 2
32919: PUSH
32920: EMPTY
32921: LIST
32922: LIST
32923: PUSH
32924: LD_INT 1
32926: PUSH
32927: LD_INT 2
32929: PUSH
32930: EMPTY
32931: LIST
32932: LIST
32933: PUSH
32934: LD_INT 0
32936: PUSH
32937: LD_INT 2
32939: PUSH
32940: EMPTY
32941: LIST
32942: LIST
32943: PUSH
32944: LD_INT 1
32946: NEG
32947: PUSH
32948: LD_INT 1
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 2
32957: NEG
32958: PUSH
32959: LD_INT 0
32961: PUSH
32962: EMPTY
32963: LIST
32964: LIST
32965: PUSH
32966: LD_INT 2
32968: NEG
32969: PUSH
32970: LD_INT 1
32972: NEG
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 2
32980: NEG
32981: PUSH
32982: LD_INT 2
32984: NEG
32985: PUSH
32986: EMPTY
32987: LIST
32988: LIST
32989: PUSH
32990: LD_INT 1
32992: PUSH
32993: LD_INT 2
32995: NEG
32996: PUSH
32997: EMPTY
32998: LIST
32999: LIST
33000: PUSH
33001: LD_INT 2
33003: PUSH
33004: LD_INT 1
33006: NEG
33007: PUSH
33008: EMPTY
33009: LIST
33010: LIST
33011: PUSH
33012: LD_INT 3
33014: PUSH
33015: LD_INT 1
33017: PUSH
33018: EMPTY
33019: LIST
33020: LIST
33021: PUSH
33022: LD_INT 3
33024: PUSH
33025: LD_INT 2
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: PUSH
33032: EMPTY
33033: LIST
33034: LIST
33035: LIST
33036: LIST
33037: LIST
33038: LIST
33039: LIST
33040: LIST
33041: LIST
33042: LIST
33043: LIST
33044: LIST
33045: LIST
33046: LIST
33047: LIST
33048: LIST
33049: LIST
33050: LIST
33051: LIST
33052: LIST
33053: LIST
33054: LIST
33055: LIST
33056: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
33057: LD_ADDR_VAR 0 25
33061: PUSH
33062: LD_INT 0
33064: PUSH
33065: LD_INT 0
33067: PUSH
33068: EMPTY
33069: LIST
33070: LIST
33071: PUSH
33072: LD_INT 0
33074: PUSH
33075: LD_INT 1
33077: NEG
33078: PUSH
33079: EMPTY
33080: LIST
33081: LIST
33082: PUSH
33083: LD_INT 1
33085: PUSH
33086: LD_INT 0
33088: PUSH
33089: EMPTY
33090: LIST
33091: LIST
33092: PUSH
33093: LD_INT 1
33095: PUSH
33096: LD_INT 1
33098: PUSH
33099: EMPTY
33100: LIST
33101: LIST
33102: PUSH
33103: LD_INT 0
33105: PUSH
33106: LD_INT 1
33108: PUSH
33109: EMPTY
33110: LIST
33111: LIST
33112: PUSH
33113: LD_INT 1
33115: NEG
33116: PUSH
33117: LD_INT 0
33119: PUSH
33120: EMPTY
33121: LIST
33122: LIST
33123: PUSH
33124: LD_INT 1
33126: NEG
33127: PUSH
33128: LD_INT 1
33130: NEG
33131: PUSH
33132: EMPTY
33133: LIST
33134: LIST
33135: PUSH
33136: LD_INT 1
33138: NEG
33139: PUSH
33140: LD_INT 2
33142: NEG
33143: PUSH
33144: EMPTY
33145: LIST
33146: LIST
33147: PUSH
33148: LD_INT 0
33150: PUSH
33151: LD_INT 2
33153: NEG
33154: PUSH
33155: EMPTY
33156: LIST
33157: LIST
33158: PUSH
33159: LD_INT 1
33161: PUSH
33162: LD_INT 1
33164: NEG
33165: PUSH
33166: EMPTY
33167: LIST
33168: LIST
33169: PUSH
33170: LD_INT 2
33172: PUSH
33173: LD_INT 0
33175: PUSH
33176: EMPTY
33177: LIST
33178: LIST
33179: PUSH
33180: LD_INT 2
33182: PUSH
33183: LD_INT 1
33185: PUSH
33186: EMPTY
33187: LIST
33188: LIST
33189: PUSH
33190: LD_INT 2
33192: PUSH
33193: LD_INT 2
33195: PUSH
33196: EMPTY
33197: LIST
33198: LIST
33199: PUSH
33200: LD_INT 1
33202: PUSH
33203: LD_INT 2
33205: PUSH
33206: EMPTY
33207: LIST
33208: LIST
33209: PUSH
33210: LD_INT 0
33212: PUSH
33213: LD_INT 2
33215: PUSH
33216: EMPTY
33217: LIST
33218: LIST
33219: PUSH
33220: LD_INT 1
33222: NEG
33223: PUSH
33224: LD_INT 1
33226: PUSH
33227: EMPTY
33228: LIST
33229: LIST
33230: PUSH
33231: LD_INT 2
33233: NEG
33234: PUSH
33235: LD_INT 0
33237: PUSH
33238: EMPTY
33239: LIST
33240: LIST
33241: PUSH
33242: LD_INT 2
33244: NEG
33245: PUSH
33246: LD_INT 1
33248: NEG
33249: PUSH
33250: EMPTY
33251: LIST
33252: LIST
33253: PUSH
33254: LD_INT 2
33256: NEG
33257: PUSH
33258: LD_INT 2
33260: NEG
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 3
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 3
33278: PUSH
33279: LD_INT 2
33281: PUSH
33282: EMPTY
33283: LIST
33284: LIST
33285: PUSH
33286: LD_INT 2
33288: PUSH
33289: LD_INT 3
33291: PUSH
33292: EMPTY
33293: LIST
33294: LIST
33295: PUSH
33296: LD_INT 1
33298: PUSH
33299: LD_INT 3
33301: PUSH
33302: EMPTY
33303: LIST
33304: LIST
33305: PUSH
33306: EMPTY
33307: LIST
33308: LIST
33309: LIST
33310: LIST
33311: LIST
33312: LIST
33313: LIST
33314: LIST
33315: LIST
33316: LIST
33317: LIST
33318: LIST
33319: LIST
33320: LIST
33321: LIST
33322: LIST
33323: LIST
33324: LIST
33325: LIST
33326: LIST
33327: LIST
33328: LIST
33329: LIST
33330: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
33331: LD_ADDR_VAR 0 26
33335: PUSH
33336: LD_INT 0
33338: PUSH
33339: LD_INT 0
33341: PUSH
33342: EMPTY
33343: LIST
33344: LIST
33345: PUSH
33346: LD_INT 0
33348: PUSH
33349: LD_INT 1
33351: NEG
33352: PUSH
33353: EMPTY
33354: LIST
33355: LIST
33356: PUSH
33357: LD_INT 1
33359: PUSH
33360: LD_INT 0
33362: PUSH
33363: EMPTY
33364: LIST
33365: LIST
33366: PUSH
33367: LD_INT 1
33369: PUSH
33370: LD_INT 1
33372: PUSH
33373: EMPTY
33374: LIST
33375: LIST
33376: PUSH
33377: LD_INT 0
33379: PUSH
33380: LD_INT 1
33382: PUSH
33383: EMPTY
33384: LIST
33385: LIST
33386: PUSH
33387: LD_INT 1
33389: NEG
33390: PUSH
33391: LD_INT 0
33393: PUSH
33394: EMPTY
33395: LIST
33396: LIST
33397: PUSH
33398: LD_INT 1
33400: NEG
33401: PUSH
33402: LD_INT 1
33404: NEG
33405: PUSH
33406: EMPTY
33407: LIST
33408: LIST
33409: PUSH
33410: LD_INT 1
33412: NEG
33413: PUSH
33414: LD_INT 2
33416: NEG
33417: PUSH
33418: EMPTY
33419: LIST
33420: LIST
33421: PUSH
33422: LD_INT 0
33424: PUSH
33425: LD_INT 2
33427: NEG
33428: PUSH
33429: EMPTY
33430: LIST
33431: LIST
33432: PUSH
33433: LD_INT 1
33435: PUSH
33436: LD_INT 1
33438: NEG
33439: PUSH
33440: EMPTY
33441: LIST
33442: LIST
33443: PUSH
33444: LD_INT 2
33446: PUSH
33447: LD_INT 0
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PUSH
33454: LD_INT 2
33456: PUSH
33457: LD_INT 1
33459: PUSH
33460: EMPTY
33461: LIST
33462: LIST
33463: PUSH
33464: LD_INT 2
33466: PUSH
33467: LD_INT 2
33469: PUSH
33470: EMPTY
33471: LIST
33472: LIST
33473: PUSH
33474: LD_INT 1
33476: PUSH
33477: LD_INT 2
33479: PUSH
33480: EMPTY
33481: LIST
33482: LIST
33483: PUSH
33484: LD_INT 0
33486: PUSH
33487: LD_INT 2
33489: PUSH
33490: EMPTY
33491: LIST
33492: LIST
33493: PUSH
33494: LD_INT 1
33496: NEG
33497: PUSH
33498: LD_INT 1
33500: PUSH
33501: EMPTY
33502: LIST
33503: LIST
33504: PUSH
33505: LD_INT 2
33507: NEG
33508: PUSH
33509: LD_INT 0
33511: PUSH
33512: EMPTY
33513: LIST
33514: LIST
33515: PUSH
33516: LD_INT 2
33518: NEG
33519: PUSH
33520: LD_INT 1
33522: NEG
33523: PUSH
33524: EMPTY
33525: LIST
33526: LIST
33527: PUSH
33528: LD_INT 2
33530: NEG
33531: PUSH
33532: LD_INT 2
33534: NEG
33535: PUSH
33536: EMPTY
33537: LIST
33538: LIST
33539: PUSH
33540: LD_INT 2
33542: PUSH
33543: LD_INT 3
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: LD_INT 1
33552: PUSH
33553: LD_INT 3
33555: PUSH
33556: EMPTY
33557: LIST
33558: LIST
33559: PUSH
33560: LD_INT 1
33562: NEG
33563: PUSH
33564: LD_INT 2
33566: PUSH
33567: EMPTY
33568: LIST
33569: LIST
33570: PUSH
33571: LD_INT 2
33573: NEG
33574: PUSH
33575: LD_INT 1
33577: PUSH
33578: EMPTY
33579: LIST
33580: LIST
33581: PUSH
33582: EMPTY
33583: LIST
33584: LIST
33585: LIST
33586: LIST
33587: LIST
33588: LIST
33589: LIST
33590: LIST
33591: LIST
33592: LIST
33593: LIST
33594: LIST
33595: LIST
33596: LIST
33597: LIST
33598: LIST
33599: LIST
33600: LIST
33601: LIST
33602: LIST
33603: LIST
33604: LIST
33605: LIST
33606: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33607: LD_ADDR_VAR 0 27
33611: PUSH
33612: LD_INT 0
33614: PUSH
33615: LD_INT 0
33617: PUSH
33618: EMPTY
33619: LIST
33620: LIST
33621: PUSH
33622: LD_INT 0
33624: PUSH
33625: LD_INT 1
33627: NEG
33628: PUSH
33629: EMPTY
33630: LIST
33631: LIST
33632: PUSH
33633: LD_INT 1
33635: PUSH
33636: LD_INT 0
33638: PUSH
33639: EMPTY
33640: LIST
33641: LIST
33642: PUSH
33643: LD_INT 1
33645: PUSH
33646: LD_INT 1
33648: PUSH
33649: EMPTY
33650: LIST
33651: LIST
33652: PUSH
33653: LD_INT 0
33655: PUSH
33656: LD_INT 1
33658: PUSH
33659: EMPTY
33660: LIST
33661: LIST
33662: PUSH
33663: LD_INT 1
33665: NEG
33666: PUSH
33667: LD_INT 0
33669: PUSH
33670: EMPTY
33671: LIST
33672: LIST
33673: PUSH
33674: LD_INT 1
33676: NEG
33677: PUSH
33678: LD_INT 1
33680: NEG
33681: PUSH
33682: EMPTY
33683: LIST
33684: LIST
33685: PUSH
33686: LD_INT 1
33688: NEG
33689: PUSH
33690: LD_INT 2
33692: NEG
33693: PUSH
33694: EMPTY
33695: LIST
33696: LIST
33697: PUSH
33698: LD_INT 0
33700: PUSH
33701: LD_INT 2
33703: NEG
33704: PUSH
33705: EMPTY
33706: LIST
33707: LIST
33708: PUSH
33709: LD_INT 1
33711: PUSH
33712: LD_INT 1
33714: NEG
33715: PUSH
33716: EMPTY
33717: LIST
33718: LIST
33719: PUSH
33720: LD_INT 2
33722: PUSH
33723: LD_INT 0
33725: PUSH
33726: EMPTY
33727: LIST
33728: LIST
33729: PUSH
33730: LD_INT 2
33732: PUSH
33733: LD_INT 1
33735: PUSH
33736: EMPTY
33737: LIST
33738: LIST
33739: PUSH
33740: LD_INT 2
33742: PUSH
33743: LD_INT 2
33745: PUSH
33746: EMPTY
33747: LIST
33748: LIST
33749: PUSH
33750: LD_INT 1
33752: PUSH
33753: LD_INT 2
33755: PUSH
33756: EMPTY
33757: LIST
33758: LIST
33759: PUSH
33760: LD_INT 0
33762: PUSH
33763: LD_INT 2
33765: PUSH
33766: EMPTY
33767: LIST
33768: LIST
33769: PUSH
33770: LD_INT 1
33772: NEG
33773: PUSH
33774: LD_INT 1
33776: PUSH
33777: EMPTY
33778: LIST
33779: LIST
33780: PUSH
33781: LD_INT 2
33783: NEG
33784: PUSH
33785: LD_INT 0
33787: PUSH
33788: EMPTY
33789: LIST
33790: LIST
33791: PUSH
33792: LD_INT 2
33794: NEG
33795: PUSH
33796: LD_INT 1
33798: NEG
33799: PUSH
33800: EMPTY
33801: LIST
33802: LIST
33803: PUSH
33804: LD_INT 2
33806: NEG
33807: PUSH
33808: LD_INT 2
33810: NEG
33811: PUSH
33812: EMPTY
33813: LIST
33814: LIST
33815: PUSH
33816: LD_INT 1
33818: NEG
33819: PUSH
33820: LD_INT 2
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PUSH
33827: LD_INT 2
33829: NEG
33830: PUSH
33831: LD_INT 1
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: PUSH
33838: LD_INT 3
33840: NEG
33841: PUSH
33842: LD_INT 1
33844: NEG
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: LD_INT 3
33852: NEG
33853: PUSH
33854: LD_INT 2
33856: NEG
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: EMPTY
33863: LIST
33864: LIST
33865: LIST
33866: LIST
33867: LIST
33868: LIST
33869: LIST
33870: LIST
33871: LIST
33872: LIST
33873: LIST
33874: LIST
33875: LIST
33876: LIST
33877: LIST
33878: LIST
33879: LIST
33880: LIST
33881: LIST
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33887: LD_ADDR_VAR 0 28
33891: PUSH
33892: LD_INT 0
33894: PUSH
33895: LD_INT 0
33897: PUSH
33898: EMPTY
33899: LIST
33900: LIST
33901: PUSH
33902: LD_INT 0
33904: PUSH
33905: LD_INT 1
33907: NEG
33908: PUSH
33909: EMPTY
33910: LIST
33911: LIST
33912: PUSH
33913: LD_INT 1
33915: PUSH
33916: LD_INT 0
33918: PUSH
33919: EMPTY
33920: LIST
33921: LIST
33922: PUSH
33923: LD_INT 1
33925: PUSH
33926: LD_INT 1
33928: PUSH
33929: EMPTY
33930: LIST
33931: LIST
33932: PUSH
33933: LD_INT 0
33935: PUSH
33936: LD_INT 1
33938: PUSH
33939: EMPTY
33940: LIST
33941: LIST
33942: PUSH
33943: LD_INT 1
33945: NEG
33946: PUSH
33947: LD_INT 0
33949: PUSH
33950: EMPTY
33951: LIST
33952: LIST
33953: PUSH
33954: LD_INT 1
33956: NEG
33957: PUSH
33958: LD_INT 1
33960: NEG
33961: PUSH
33962: EMPTY
33963: LIST
33964: LIST
33965: PUSH
33966: LD_INT 1
33968: NEG
33969: PUSH
33970: LD_INT 2
33972: NEG
33973: PUSH
33974: EMPTY
33975: LIST
33976: LIST
33977: PUSH
33978: LD_INT 0
33980: PUSH
33981: LD_INT 2
33983: NEG
33984: PUSH
33985: EMPTY
33986: LIST
33987: LIST
33988: PUSH
33989: LD_INT 1
33991: PUSH
33992: LD_INT 1
33994: NEG
33995: PUSH
33996: EMPTY
33997: LIST
33998: LIST
33999: PUSH
34000: LD_INT 2
34002: PUSH
34003: LD_INT 0
34005: PUSH
34006: EMPTY
34007: LIST
34008: LIST
34009: PUSH
34010: LD_INT 2
34012: PUSH
34013: LD_INT 1
34015: PUSH
34016: EMPTY
34017: LIST
34018: LIST
34019: PUSH
34020: LD_INT 2
34022: PUSH
34023: LD_INT 2
34025: PUSH
34026: EMPTY
34027: LIST
34028: LIST
34029: PUSH
34030: LD_INT 1
34032: PUSH
34033: LD_INT 2
34035: PUSH
34036: EMPTY
34037: LIST
34038: LIST
34039: PUSH
34040: LD_INT 0
34042: PUSH
34043: LD_INT 2
34045: PUSH
34046: EMPTY
34047: LIST
34048: LIST
34049: PUSH
34050: LD_INT 1
34052: NEG
34053: PUSH
34054: LD_INT 1
34056: PUSH
34057: EMPTY
34058: LIST
34059: LIST
34060: PUSH
34061: LD_INT 2
34063: NEG
34064: PUSH
34065: LD_INT 0
34067: PUSH
34068: EMPTY
34069: LIST
34070: LIST
34071: PUSH
34072: LD_INT 2
34074: NEG
34075: PUSH
34076: LD_INT 1
34078: NEG
34079: PUSH
34080: EMPTY
34081: LIST
34082: LIST
34083: PUSH
34084: LD_INT 2
34086: NEG
34087: PUSH
34088: LD_INT 2
34090: NEG
34091: PUSH
34092: EMPTY
34093: LIST
34094: LIST
34095: PUSH
34096: LD_INT 2
34098: NEG
34099: PUSH
34100: LD_INT 3
34102: NEG
34103: PUSH
34104: EMPTY
34105: LIST
34106: LIST
34107: PUSH
34108: LD_INT 1
34110: NEG
34111: PUSH
34112: LD_INT 3
34114: NEG
34115: PUSH
34116: EMPTY
34117: LIST
34118: LIST
34119: PUSH
34120: LD_INT 3
34122: NEG
34123: PUSH
34124: LD_INT 1
34126: NEG
34127: PUSH
34128: EMPTY
34129: LIST
34130: LIST
34131: PUSH
34132: LD_INT 3
34134: NEG
34135: PUSH
34136: LD_INT 2
34138: NEG
34139: PUSH
34140: EMPTY
34141: LIST
34142: LIST
34143: PUSH
34144: EMPTY
34145: LIST
34146: LIST
34147: LIST
34148: LIST
34149: LIST
34150: LIST
34151: LIST
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: LIST
34157: LIST
34158: LIST
34159: LIST
34160: LIST
34161: LIST
34162: LIST
34163: LIST
34164: LIST
34165: LIST
34166: LIST
34167: LIST
34168: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34169: LD_ADDR_VAR 0 29
34173: PUSH
34174: LD_INT 0
34176: PUSH
34177: LD_INT 0
34179: PUSH
34180: EMPTY
34181: LIST
34182: LIST
34183: PUSH
34184: LD_INT 0
34186: PUSH
34187: LD_INT 1
34189: NEG
34190: PUSH
34191: EMPTY
34192: LIST
34193: LIST
34194: PUSH
34195: LD_INT 1
34197: PUSH
34198: LD_INT 0
34200: PUSH
34201: EMPTY
34202: LIST
34203: LIST
34204: PUSH
34205: LD_INT 1
34207: PUSH
34208: LD_INT 1
34210: PUSH
34211: EMPTY
34212: LIST
34213: LIST
34214: PUSH
34215: LD_INT 0
34217: PUSH
34218: LD_INT 1
34220: PUSH
34221: EMPTY
34222: LIST
34223: LIST
34224: PUSH
34225: LD_INT 1
34227: NEG
34228: PUSH
34229: LD_INT 0
34231: PUSH
34232: EMPTY
34233: LIST
34234: LIST
34235: PUSH
34236: LD_INT 1
34238: NEG
34239: PUSH
34240: LD_INT 1
34242: NEG
34243: PUSH
34244: EMPTY
34245: LIST
34246: LIST
34247: PUSH
34248: LD_INT 1
34250: NEG
34251: PUSH
34252: LD_INT 2
34254: NEG
34255: PUSH
34256: EMPTY
34257: LIST
34258: LIST
34259: PUSH
34260: LD_INT 0
34262: PUSH
34263: LD_INT 2
34265: NEG
34266: PUSH
34267: EMPTY
34268: LIST
34269: LIST
34270: PUSH
34271: LD_INT 1
34273: PUSH
34274: LD_INT 1
34276: NEG
34277: PUSH
34278: EMPTY
34279: LIST
34280: LIST
34281: PUSH
34282: LD_INT 2
34284: PUSH
34285: LD_INT 0
34287: PUSH
34288: EMPTY
34289: LIST
34290: LIST
34291: PUSH
34292: LD_INT 2
34294: PUSH
34295: LD_INT 1
34297: PUSH
34298: EMPTY
34299: LIST
34300: LIST
34301: PUSH
34302: LD_INT 1
34304: PUSH
34305: LD_INT 2
34307: PUSH
34308: EMPTY
34309: LIST
34310: LIST
34311: PUSH
34312: LD_INT 0
34314: PUSH
34315: LD_INT 2
34317: PUSH
34318: EMPTY
34319: LIST
34320: LIST
34321: PUSH
34322: LD_INT 1
34324: NEG
34325: PUSH
34326: LD_INT 1
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: PUSH
34333: LD_INT 2
34335: NEG
34336: PUSH
34337: LD_INT 1
34339: NEG
34340: PUSH
34341: EMPTY
34342: LIST
34343: LIST
34344: PUSH
34345: LD_INT 2
34347: NEG
34348: PUSH
34349: LD_INT 2
34351: NEG
34352: PUSH
34353: EMPTY
34354: LIST
34355: LIST
34356: PUSH
34357: LD_INT 2
34359: NEG
34360: PUSH
34361: LD_INT 3
34363: NEG
34364: PUSH
34365: EMPTY
34366: LIST
34367: LIST
34368: PUSH
34369: LD_INT 2
34371: PUSH
34372: LD_INT 1
34374: NEG
34375: PUSH
34376: EMPTY
34377: LIST
34378: LIST
34379: PUSH
34380: LD_INT 3
34382: PUSH
34383: LD_INT 1
34385: PUSH
34386: EMPTY
34387: LIST
34388: LIST
34389: PUSH
34390: LD_INT 1
34392: PUSH
34393: LD_INT 3
34395: PUSH
34396: EMPTY
34397: LIST
34398: LIST
34399: PUSH
34400: LD_INT 1
34402: NEG
34403: PUSH
34404: LD_INT 2
34406: PUSH
34407: EMPTY
34408: LIST
34409: LIST
34410: PUSH
34411: LD_INT 3
34413: NEG
34414: PUSH
34415: LD_INT 2
34417: NEG
34418: PUSH
34419: EMPTY
34420: LIST
34421: LIST
34422: PUSH
34423: EMPTY
34424: LIST
34425: LIST
34426: LIST
34427: LIST
34428: LIST
34429: LIST
34430: LIST
34431: LIST
34432: LIST
34433: LIST
34434: LIST
34435: LIST
34436: LIST
34437: LIST
34438: LIST
34439: LIST
34440: LIST
34441: LIST
34442: LIST
34443: LIST
34444: LIST
34445: LIST
34446: LIST
34447: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34448: LD_ADDR_VAR 0 30
34452: PUSH
34453: LD_INT 0
34455: PUSH
34456: LD_INT 0
34458: PUSH
34459: EMPTY
34460: LIST
34461: LIST
34462: PUSH
34463: LD_INT 0
34465: PUSH
34466: LD_INT 1
34468: NEG
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 1
34476: PUSH
34477: LD_INT 0
34479: PUSH
34480: EMPTY
34481: LIST
34482: LIST
34483: PUSH
34484: LD_INT 1
34486: PUSH
34487: LD_INT 1
34489: PUSH
34490: EMPTY
34491: LIST
34492: LIST
34493: PUSH
34494: LD_INT 0
34496: PUSH
34497: LD_INT 1
34499: PUSH
34500: EMPTY
34501: LIST
34502: LIST
34503: PUSH
34504: LD_INT 1
34506: NEG
34507: PUSH
34508: LD_INT 0
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: LD_INT 1
34517: NEG
34518: PUSH
34519: LD_INT 1
34521: NEG
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 1
34529: NEG
34530: PUSH
34531: LD_INT 2
34533: NEG
34534: PUSH
34535: EMPTY
34536: LIST
34537: LIST
34538: PUSH
34539: LD_INT 0
34541: PUSH
34542: LD_INT 2
34544: NEG
34545: PUSH
34546: EMPTY
34547: LIST
34548: LIST
34549: PUSH
34550: LD_INT 1
34552: PUSH
34553: LD_INT 1
34555: NEG
34556: PUSH
34557: EMPTY
34558: LIST
34559: LIST
34560: PUSH
34561: LD_INT 2
34563: PUSH
34564: LD_INT 0
34566: PUSH
34567: EMPTY
34568: LIST
34569: LIST
34570: PUSH
34571: LD_INT 2
34573: PUSH
34574: LD_INT 1
34576: PUSH
34577: EMPTY
34578: LIST
34579: LIST
34580: PUSH
34581: LD_INT 2
34583: PUSH
34584: LD_INT 2
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: PUSH
34591: LD_INT 1
34593: PUSH
34594: LD_INT 2
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 1
34603: NEG
34604: PUSH
34605: LD_INT 1
34607: PUSH
34608: EMPTY
34609: LIST
34610: LIST
34611: PUSH
34612: LD_INT 2
34614: NEG
34615: PUSH
34616: LD_INT 0
34618: PUSH
34619: EMPTY
34620: LIST
34621: LIST
34622: PUSH
34623: LD_INT 2
34625: NEG
34626: PUSH
34627: LD_INT 1
34629: NEG
34630: PUSH
34631: EMPTY
34632: LIST
34633: LIST
34634: PUSH
34635: LD_INT 1
34637: NEG
34638: PUSH
34639: LD_INT 3
34641: NEG
34642: PUSH
34643: EMPTY
34644: LIST
34645: LIST
34646: PUSH
34647: LD_INT 1
34649: PUSH
34650: LD_INT 2
34652: NEG
34653: PUSH
34654: EMPTY
34655: LIST
34656: LIST
34657: PUSH
34658: LD_INT 3
34660: PUSH
34661: LD_INT 2
34663: PUSH
34664: EMPTY
34665: LIST
34666: LIST
34667: PUSH
34668: LD_INT 2
34670: PUSH
34671: LD_INT 3
34673: PUSH
34674: EMPTY
34675: LIST
34676: LIST
34677: PUSH
34678: LD_INT 2
34680: NEG
34681: PUSH
34682: LD_INT 1
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: PUSH
34689: LD_INT 3
34691: NEG
34692: PUSH
34693: LD_INT 1
34695: NEG
34696: PUSH
34697: EMPTY
34698: LIST
34699: LIST
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: LIST
34705: LIST
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34726: LD_ADDR_VAR 0 31
34730: PUSH
34731: LD_INT 0
34733: PUSH
34734: LD_INT 0
34736: PUSH
34737: EMPTY
34738: LIST
34739: LIST
34740: PUSH
34741: LD_INT 0
34743: PUSH
34744: LD_INT 1
34746: NEG
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: PUSH
34752: LD_INT 1
34754: PUSH
34755: LD_INT 0
34757: PUSH
34758: EMPTY
34759: LIST
34760: LIST
34761: PUSH
34762: LD_INT 1
34764: PUSH
34765: LD_INT 1
34767: PUSH
34768: EMPTY
34769: LIST
34770: LIST
34771: PUSH
34772: LD_INT 0
34774: PUSH
34775: LD_INT 1
34777: PUSH
34778: EMPTY
34779: LIST
34780: LIST
34781: PUSH
34782: LD_INT 1
34784: NEG
34785: PUSH
34786: LD_INT 0
34788: PUSH
34789: EMPTY
34790: LIST
34791: LIST
34792: PUSH
34793: LD_INT 1
34795: NEG
34796: PUSH
34797: LD_INT 1
34799: NEG
34800: PUSH
34801: EMPTY
34802: LIST
34803: LIST
34804: PUSH
34805: LD_INT 1
34807: NEG
34808: PUSH
34809: LD_INT 2
34811: NEG
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PUSH
34817: LD_INT 1
34819: PUSH
34820: LD_INT 1
34822: NEG
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: LD_INT 2
34830: PUSH
34831: LD_INT 0
34833: PUSH
34834: EMPTY
34835: LIST
34836: LIST
34837: PUSH
34838: LD_INT 2
34840: PUSH
34841: LD_INT 1
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: PUSH
34848: LD_INT 2
34850: PUSH
34851: LD_INT 2
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 1
34860: PUSH
34861: LD_INT 2
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 0
34870: PUSH
34871: LD_INT 2
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: LD_INT 1
34880: NEG
34881: PUSH
34882: LD_INT 1
34884: PUSH
34885: EMPTY
34886: LIST
34887: LIST
34888: PUSH
34889: LD_INT 2
34891: NEG
34892: PUSH
34893: LD_INT 1
34895: NEG
34896: PUSH
34897: EMPTY
34898: LIST
34899: LIST
34900: PUSH
34901: LD_INT 2
34903: NEG
34904: PUSH
34905: LD_INT 2
34907: NEG
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: LD_INT 2
34915: NEG
34916: PUSH
34917: LD_INT 3
34919: NEG
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: LD_INT 2
34927: PUSH
34928: LD_INT 1
34930: NEG
34931: PUSH
34932: EMPTY
34933: LIST
34934: LIST
34935: PUSH
34936: LD_INT 3
34938: PUSH
34939: LD_INT 1
34941: PUSH
34942: EMPTY
34943: LIST
34944: LIST
34945: PUSH
34946: LD_INT 1
34948: PUSH
34949: LD_INT 3
34951: PUSH
34952: EMPTY
34953: LIST
34954: LIST
34955: PUSH
34956: LD_INT 1
34958: NEG
34959: PUSH
34960: LD_INT 2
34962: PUSH
34963: EMPTY
34964: LIST
34965: LIST
34966: PUSH
34967: LD_INT 3
34969: NEG
34970: PUSH
34971: LD_INT 2
34973: NEG
34974: PUSH
34975: EMPTY
34976: LIST
34977: LIST
34978: PUSH
34979: EMPTY
34980: LIST
34981: LIST
34982: LIST
34983: LIST
34984: LIST
34985: LIST
34986: LIST
34987: LIST
34988: LIST
34989: LIST
34990: LIST
34991: LIST
34992: LIST
34993: LIST
34994: LIST
34995: LIST
34996: LIST
34997: LIST
34998: LIST
34999: LIST
35000: LIST
35001: LIST
35002: LIST
35003: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35004: LD_ADDR_VAR 0 32
35008: PUSH
35009: LD_INT 0
35011: PUSH
35012: LD_INT 0
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 0
35021: PUSH
35022: LD_INT 1
35024: NEG
35025: PUSH
35026: EMPTY
35027: LIST
35028: LIST
35029: PUSH
35030: LD_INT 1
35032: PUSH
35033: LD_INT 0
35035: PUSH
35036: EMPTY
35037: LIST
35038: LIST
35039: PUSH
35040: LD_INT 1
35042: PUSH
35043: LD_INT 1
35045: PUSH
35046: EMPTY
35047: LIST
35048: LIST
35049: PUSH
35050: LD_INT 0
35052: PUSH
35053: LD_INT 1
35055: PUSH
35056: EMPTY
35057: LIST
35058: LIST
35059: PUSH
35060: LD_INT 1
35062: NEG
35063: PUSH
35064: LD_INT 0
35066: PUSH
35067: EMPTY
35068: LIST
35069: LIST
35070: PUSH
35071: LD_INT 1
35073: NEG
35074: PUSH
35075: LD_INT 1
35077: NEG
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: PUSH
35083: LD_INT 1
35085: NEG
35086: PUSH
35087: LD_INT 2
35089: NEG
35090: PUSH
35091: EMPTY
35092: LIST
35093: LIST
35094: PUSH
35095: LD_INT 0
35097: PUSH
35098: LD_INT 2
35100: NEG
35101: PUSH
35102: EMPTY
35103: LIST
35104: LIST
35105: PUSH
35106: LD_INT 1
35108: PUSH
35109: LD_INT 1
35111: NEG
35112: PUSH
35113: EMPTY
35114: LIST
35115: LIST
35116: PUSH
35117: LD_INT 2
35119: PUSH
35120: LD_INT 1
35122: PUSH
35123: EMPTY
35124: LIST
35125: LIST
35126: PUSH
35127: LD_INT 2
35129: PUSH
35130: LD_INT 2
35132: PUSH
35133: EMPTY
35134: LIST
35135: LIST
35136: PUSH
35137: LD_INT 1
35139: PUSH
35140: LD_INT 2
35142: PUSH
35143: EMPTY
35144: LIST
35145: LIST
35146: PUSH
35147: LD_INT 0
35149: PUSH
35150: LD_INT 2
35152: PUSH
35153: EMPTY
35154: LIST
35155: LIST
35156: PUSH
35157: LD_INT 1
35159: NEG
35160: PUSH
35161: LD_INT 1
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: PUSH
35168: LD_INT 2
35170: NEG
35171: PUSH
35172: LD_INT 0
35174: PUSH
35175: EMPTY
35176: LIST
35177: LIST
35178: PUSH
35179: LD_INT 2
35181: NEG
35182: PUSH
35183: LD_INT 1
35185: NEG
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PUSH
35191: LD_INT 1
35193: NEG
35194: PUSH
35195: LD_INT 3
35197: NEG
35198: PUSH
35199: EMPTY
35200: LIST
35201: LIST
35202: PUSH
35203: LD_INT 1
35205: PUSH
35206: LD_INT 2
35208: NEG
35209: PUSH
35210: EMPTY
35211: LIST
35212: LIST
35213: PUSH
35214: LD_INT 3
35216: PUSH
35217: LD_INT 2
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: LD_INT 2
35226: PUSH
35227: LD_INT 3
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 2
35236: NEG
35237: PUSH
35238: LD_INT 1
35240: PUSH
35241: EMPTY
35242: LIST
35243: LIST
35244: PUSH
35245: LD_INT 3
35247: NEG
35248: PUSH
35249: LD_INT 1
35251: NEG
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: LIST
35261: LIST
35262: LIST
35263: LIST
35264: LIST
35265: LIST
35266: LIST
35267: LIST
35268: LIST
35269: LIST
35270: LIST
35271: LIST
35272: LIST
35273: LIST
35274: LIST
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35282: LD_ADDR_VAR 0 33
35286: PUSH
35287: LD_INT 0
35289: PUSH
35290: LD_INT 0
35292: PUSH
35293: EMPTY
35294: LIST
35295: LIST
35296: PUSH
35297: LD_INT 0
35299: PUSH
35300: LD_INT 1
35302: NEG
35303: PUSH
35304: EMPTY
35305: LIST
35306: LIST
35307: PUSH
35308: LD_INT 1
35310: PUSH
35311: LD_INT 0
35313: PUSH
35314: EMPTY
35315: LIST
35316: LIST
35317: PUSH
35318: LD_INT 1
35320: PUSH
35321: LD_INT 1
35323: PUSH
35324: EMPTY
35325: LIST
35326: LIST
35327: PUSH
35328: LD_INT 0
35330: PUSH
35331: LD_INT 1
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: PUSH
35338: LD_INT 1
35340: NEG
35341: PUSH
35342: LD_INT 0
35344: PUSH
35345: EMPTY
35346: LIST
35347: LIST
35348: PUSH
35349: LD_INT 1
35351: NEG
35352: PUSH
35353: LD_INT 1
35355: NEG
35356: PUSH
35357: EMPTY
35358: LIST
35359: LIST
35360: PUSH
35361: LD_INT 1
35363: NEG
35364: PUSH
35365: LD_INT 2
35367: NEG
35368: PUSH
35369: EMPTY
35370: LIST
35371: LIST
35372: PUSH
35373: LD_INT 1
35375: PUSH
35376: LD_INT 1
35378: NEG
35379: PUSH
35380: EMPTY
35381: LIST
35382: LIST
35383: PUSH
35384: LD_INT 2
35386: PUSH
35387: LD_INT 0
35389: PUSH
35390: EMPTY
35391: LIST
35392: LIST
35393: PUSH
35394: LD_INT 2
35396: PUSH
35397: LD_INT 1
35399: PUSH
35400: EMPTY
35401: LIST
35402: LIST
35403: PUSH
35404: LD_INT 1
35406: PUSH
35407: LD_INT 2
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: LD_INT 0
35416: PUSH
35417: LD_INT 2
35419: PUSH
35420: EMPTY
35421: LIST
35422: LIST
35423: PUSH
35424: LD_INT 1
35426: NEG
35427: PUSH
35428: LD_INT 1
35430: PUSH
35431: EMPTY
35432: LIST
35433: LIST
35434: PUSH
35435: LD_INT 2
35437: NEG
35438: PUSH
35439: LD_INT 0
35441: PUSH
35442: EMPTY
35443: LIST
35444: LIST
35445: PUSH
35446: LD_INT 2
35448: NEG
35449: PUSH
35450: LD_INT 1
35452: NEG
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: PUSH
35458: LD_INT 2
35460: NEG
35461: PUSH
35462: LD_INT 2
35464: NEG
35465: PUSH
35466: EMPTY
35467: LIST
35468: LIST
35469: PUSH
35470: LD_INT 2
35472: NEG
35473: PUSH
35474: LD_INT 3
35476: NEG
35477: PUSH
35478: EMPTY
35479: LIST
35480: LIST
35481: PUSH
35482: LD_INT 2
35484: PUSH
35485: LD_INT 1
35487: NEG
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: PUSH
35493: LD_INT 3
35495: PUSH
35496: LD_INT 1
35498: PUSH
35499: EMPTY
35500: LIST
35501: LIST
35502: PUSH
35503: LD_INT 1
35505: PUSH
35506: LD_INT 3
35508: PUSH
35509: EMPTY
35510: LIST
35511: LIST
35512: PUSH
35513: LD_INT 1
35515: NEG
35516: PUSH
35517: LD_INT 2
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 3
35526: NEG
35527: PUSH
35528: LD_INT 2
35530: NEG
35531: PUSH
35532: EMPTY
35533: LIST
35534: LIST
35535: PUSH
35536: EMPTY
35537: LIST
35538: LIST
35539: LIST
35540: LIST
35541: LIST
35542: LIST
35543: LIST
35544: LIST
35545: LIST
35546: LIST
35547: LIST
35548: LIST
35549: LIST
35550: LIST
35551: LIST
35552: LIST
35553: LIST
35554: LIST
35555: LIST
35556: LIST
35557: LIST
35558: LIST
35559: LIST
35560: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35561: LD_ADDR_VAR 0 34
35565: PUSH
35566: LD_INT 0
35568: PUSH
35569: LD_INT 0
35571: PUSH
35572: EMPTY
35573: LIST
35574: LIST
35575: PUSH
35576: LD_INT 0
35578: PUSH
35579: LD_INT 1
35581: NEG
35582: PUSH
35583: EMPTY
35584: LIST
35585: LIST
35586: PUSH
35587: LD_INT 1
35589: PUSH
35590: LD_INT 0
35592: PUSH
35593: EMPTY
35594: LIST
35595: LIST
35596: PUSH
35597: LD_INT 1
35599: PUSH
35600: LD_INT 1
35602: PUSH
35603: EMPTY
35604: LIST
35605: LIST
35606: PUSH
35607: LD_INT 0
35609: PUSH
35610: LD_INT 1
35612: PUSH
35613: EMPTY
35614: LIST
35615: LIST
35616: PUSH
35617: LD_INT 1
35619: NEG
35620: PUSH
35621: LD_INT 0
35623: PUSH
35624: EMPTY
35625: LIST
35626: LIST
35627: PUSH
35628: LD_INT 1
35630: NEG
35631: PUSH
35632: LD_INT 1
35634: NEG
35635: PUSH
35636: EMPTY
35637: LIST
35638: LIST
35639: PUSH
35640: LD_INT 1
35642: NEG
35643: PUSH
35644: LD_INT 2
35646: NEG
35647: PUSH
35648: EMPTY
35649: LIST
35650: LIST
35651: PUSH
35652: LD_INT 0
35654: PUSH
35655: LD_INT 2
35657: NEG
35658: PUSH
35659: EMPTY
35660: LIST
35661: LIST
35662: PUSH
35663: LD_INT 1
35665: PUSH
35666: LD_INT 1
35668: NEG
35669: PUSH
35670: EMPTY
35671: LIST
35672: LIST
35673: PUSH
35674: LD_INT 2
35676: PUSH
35677: LD_INT 1
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: LD_INT 2
35686: PUSH
35687: LD_INT 2
35689: PUSH
35690: EMPTY
35691: LIST
35692: LIST
35693: PUSH
35694: LD_INT 1
35696: PUSH
35697: LD_INT 2
35699: PUSH
35700: EMPTY
35701: LIST
35702: LIST
35703: PUSH
35704: LD_INT 1
35706: NEG
35707: PUSH
35708: LD_INT 1
35710: PUSH
35711: EMPTY
35712: LIST
35713: LIST
35714: PUSH
35715: LD_INT 2
35717: NEG
35718: PUSH
35719: LD_INT 0
35721: PUSH
35722: EMPTY
35723: LIST
35724: LIST
35725: PUSH
35726: LD_INT 2
35728: NEG
35729: PUSH
35730: LD_INT 1
35732: NEG
35733: PUSH
35734: EMPTY
35735: LIST
35736: LIST
35737: PUSH
35738: LD_INT 2
35740: NEG
35741: PUSH
35742: LD_INT 2
35744: NEG
35745: PUSH
35746: EMPTY
35747: LIST
35748: LIST
35749: PUSH
35750: LD_INT 1
35752: NEG
35753: PUSH
35754: LD_INT 3
35756: NEG
35757: PUSH
35758: EMPTY
35759: LIST
35760: LIST
35761: PUSH
35762: LD_INT 1
35764: PUSH
35765: LD_INT 2
35767: NEG
35768: PUSH
35769: EMPTY
35770: LIST
35771: LIST
35772: PUSH
35773: LD_INT 3
35775: PUSH
35776: LD_INT 2
35778: PUSH
35779: EMPTY
35780: LIST
35781: LIST
35782: PUSH
35783: LD_INT 2
35785: PUSH
35786: LD_INT 3
35788: PUSH
35789: EMPTY
35790: LIST
35791: LIST
35792: PUSH
35793: LD_INT 2
35795: NEG
35796: PUSH
35797: LD_INT 1
35799: PUSH
35800: EMPTY
35801: LIST
35802: LIST
35803: PUSH
35804: LD_INT 3
35806: NEG
35807: PUSH
35808: LD_INT 1
35810: NEG
35811: PUSH
35812: EMPTY
35813: LIST
35814: LIST
35815: PUSH
35816: EMPTY
35817: LIST
35818: LIST
35819: LIST
35820: LIST
35821: LIST
35822: LIST
35823: LIST
35824: LIST
35825: LIST
35826: LIST
35827: LIST
35828: LIST
35829: LIST
35830: LIST
35831: LIST
35832: LIST
35833: LIST
35834: LIST
35835: LIST
35836: LIST
35837: LIST
35838: LIST
35839: LIST
35840: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35841: LD_ADDR_VAR 0 35
35845: PUSH
35846: LD_INT 0
35848: PUSH
35849: LD_INT 0
35851: PUSH
35852: EMPTY
35853: LIST
35854: LIST
35855: PUSH
35856: LD_INT 0
35858: PUSH
35859: LD_INT 1
35861: NEG
35862: PUSH
35863: EMPTY
35864: LIST
35865: LIST
35866: PUSH
35867: LD_INT 1
35869: PUSH
35870: LD_INT 0
35872: PUSH
35873: EMPTY
35874: LIST
35875: LIST
35876: PUSH
35877: LD_INT 1
35879: PUSH
35880: LD_INT 1
35882: PUSH
35883: EMPTY
35884: LIST
35885: LIST
35886: PUSH
35887: LD_INT 0
35889: PUSH
35890: LD_INT 1
35892: PUSH
35893: EMPTY
35894: LIST
35895: LIST
35896: PUSH
35897: LD_INT 1
35899: NEG
35900: PUSH
35901: LD_INT 0
35903: PUSH
35904: EMPTY
35905: LIST
35906: LIST
35907: PUSH
35908: LD_INT 1
35910: NEG
35911: PUSH
35912: LD_INT 1
35914: NEG
35915: PUSH
35916: EMPTY
35917: LIST
35918: LIST
35919: PUSH
35920: LD_INT 2
35922: PUSH
35923: LD_INT 1
35925: PUSH
35926: EMPTY
35927: LIST
35928: LIST
35929: PUSH
35930: LD_INT 2
35932: NEG
35933: PUSH
35934: LD_INT 1
35936: NEG
35937: PUSH
35938: EMPTY
35939: LIST
35940: LIST
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: LIST
35946: LIST
35947: LIST
35948: LIST
35949: LIST
35950: LIST
35951: LIST
35952: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35953: LD_ADDR_VAR 0 36
35957: PUSH
35958: LD_INT 0
35960: PUSH
35961: LD_INT 0
35963: PUSH
35964: EMPTY
35965: LIST
35966: LIST
35967: PUSH
35968: LD_INT 0
35970: PUSH
35971: LD_INT 1
35973: NEG
35974: PUSH
35975: EMPTY
35976: LIST
35977: LIST
35978: PUSH
35979: LD_INT 1
35981: PUSH
35982: LD_INT 0
35984: PUSH
35985: EMPTY
35986: LIST
35987: LIST
35988: PUSH
35989: LD_INT 1
35991: PUSH
35992: LD_INT 1
35994: PUSH
35995: EMPTY
35996: LIST
35997: LIST
35998: PUSH
35999: LD_INT 0
36001: PUSH
36002: LD_INT 1
36004: PUSH
36005: EMPTY
36006: LIST
36007: LIST
36008: PUSH
36009: LD_INT 1
36011: NEG
36012: PUSH
36013: LD_INT 0
36015: PUSH
36016: EMPTY
36017: LIST
36018: LIST
36019: PUSH
36020: LD_INT 1
36022: NEG
36023: PUSH
36024: LD_INT 1
36026: NEG
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: LD_INT 1
36034: NEG
36035: PUSH
36036: LD_INT 2
36038: NEG
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 1
36046: PUSH
36047: LD_INT 2
36049: PUSH
36050: EMPTY
36051: LIST
36052: LIST
36053: PUSH
36054: EMPTY
36055: LIST
36056: LIST
36057: LIST
36058: LIST
36059: LIST
36060: LIST
36061: LIST
36062: LIST
36063: LIST
36064: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36065: LD_ADDR_VAR 0 37
36069: PUSH
36070: LD_INT 0
36072: PUSH
36073: LD_INT 0
36075: PUSH
36076: EMPTY
36077: LIST
36078: LIST
36079: PUSH
36080: LD_INT 0
36082: PUSH
36083: LD_INT 1
36085: NEG
36086: PUSH
36087: EMPTY
36088: LIST
36089: LIST
36090: PUSH
36091: LD_INT 1
36093: PUSH
36094: LD_INT 0
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: LD_INT 1
36103: PUSH
36104: LD_INT 1
36106: PUSH
36107: EMPTY
36108: LIST
36109: LIST
36110: PUSH
36111: LD_INT 0
36113: PUSH
36114: LD_INT 1
36116: PUSH
36117: EMPTY
36118: LIST
36119: LIST
36120: PUSH
36121: LD_INT 1
36123: NEG
36124: PUSH
36125: LD_INT 0
36127: PUSH
36128: EMPTY
36129: LIST
36130: LIST
36131: PUSH
36132: LD_INT 1
36134: NEG
36135: PUSH
36136: LD_INT 1
36138: NEG
36139: PUSH
36140: EMPTY
36141: LIST
36142: LIST
36143: PUSH
36144: LD_INT 1
36146: PUSH
36147: LD_INT 1
36149: NEG
36150: PUSH
36151: EMPTY
36152: LIST
36153: LIST
36154: PUSH
36155: LD_INT 1
36157: NEG
36158: PUSH
36159: LD_INT 1
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: LIST
36170: LIST
36171: LIST
36172: LIST
36173: LIST
36174: LIST
36175: LIST
36176: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36177: LD_ADDR_VAR 0 38
36181: PUSH
36182: LD_INT 0
36184: PUSH
36185: LD_INT 0
36187: PUSH
36188: EMPTY
36189: LIST
36190: LIST
36191: PUSH
36192: LD_INT 0
36194: PUSH
36195: LD_INT 1
36197: NEG
36198: PUSH
36199: EMPTY
36200: LIST
36201: LIST
36202: PUSH
36203: LD_INT 1
36205: PUSH
36206: LD_INT 0
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: PUSH
36213: LD_INT 1
36215: PUSH
36216: LD_INT 1
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: PUSH
36223: LD_INT 0
36225: PUSH
36226: LD_INT 1
36228: PUSH
36229: EMPTY
36230: LIST
36231: LIST
36232: PUSH
36233: LD_INT 1
36235: NEG
36236: PUSH
36237: LD_INT 0
36239: PUSH
36240: EMPTY
36241: LIST
36242: LIST
36243: PUSH
36244: LD_INT 1
36246: NEG
36247: PUSH
36248: LD_INT 1
36250: NEG
36251: PUSH
36252: EMPTY
36253: LIST
36254: LIST
36255: PUSH
36256: LD_INT 2
36258: PUSH
36259: LD_INT 1
36261: PUSH
36262: EMPTY
36263: LIST
36264: LIST
36265: PUSH
36266: LD_INT 2
36268: NEG
36269: PUSH
36270: LD_INT 1
36272: NEG
36273: PUSH
36274: EMPTY
36275: LIST
36276: LIST
36277: PUSH
36278: EMPTY
36279: LIST
36280: LIST
36281: LIST
36282: LIST
36283: LIST
36284: LIST
36285: LIST
36286: LIST
36287: LIST
36288: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36289: LD_ADDR_VAR 0 39
36293: PUSH
36294: LD_INT 0
36296: PUSH
36297: LD_INT 0
36299: PUSH
36300: EMPTY
36301: LIST
36302: LIST
36303: PUSH
36304: LD_INT 0
36306: PUSH
36307: LD_INT 1
36309: NEG
36310: PUSH
36311: EMPTY
36312: LIST
36313: LIST
36314: PUSH
36315: LD_INT 1
36317: PUSH
36318: LD_INT 0
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: LD_INT 1
36327: PUSH
36328: LD_INT 1
36330: PUSH
36331: EMPTY
36332: LIST
36333: LIST
36334: PUSH
36335: LD_INT 0
36337: PUSH
36338: LD_INT 1
36340: PUSH
36341: EMPTY
36342: LIST
36343: LIST
36344: PUSH
36345: LD_INT 1
36347: NEG
36348: PUSH
36349: LD_INT 0
36351: PUSH
36352: EMPTY
36353: LIST
36354: LIST
36355: PUSH
36356: LD_INT 1
36358: NEG
36359: PUSH
36360: LD_INT 1
36362: NEG
36363: PUSH
36364: EMPTY
36365: LIST
36366: LIST
36367: PUSH
36368: LD_INT 1
36370: NEG
36371: PUSH
36372: LD_INT 2
36374: NEG
36375: PUSH
36376: EMPTY
36377: LIST
36378: LIST
36379: PUSH
36380: LD_INT 1
36382: PUSH
36383: LD_INT 2
36385: PUSH
36386: EMPTY
36387: LIST
36388: LIST
36389: PUSH
36390: EMPTY
36391: LIST
36392: LIST
36393: LIST
36394: LIST
36395: LIST
36396: LIST
36397: LIST
36398: LIST
36399: LIST
36400: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36401: LD_ADDR_VAR 0 40
36405: PUSH
36406: LD_INT 0
36408: PUSH
36409: LD_INT 0
36411: PUSH
36412: EMPTY
36413: LIST
36414: LIST
36415: PUSH
36416: LD_INT 0
36418: PUSH
36419: LD_INT 1
36421: NEG
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 1
36429: PUSH
36430: LD_INT 0
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: PUSH
36437: LD_INT 1
36439: PUSH
36440: LD_INT 1
36442: PUSH
36443: EMPTY
36444: LIST
36445: LIST
36446: PUSH
36447: LD_INT 0
36449: PUSH
36450: LD_INT 1
36452: PUSH
36453: EMPTY
36454: LIST
36455: LIST
36456: PUSH
36457: LD_INT 1
36459: NEG
36460: PUSH
36461: LD_INT 0
36463: PUSH
36464: EMPTY
36465: LIST
36466: LIST
36467: PUSH
36468: LD_INT 1
36470: NEG
36471: PUSH
36472: LD_INT 1
36474: NEG
36475: PUSH
36476: EMPTY
36477: LIST
36478: LIST
36479: PUSH
36480: LD_INT 1
36482: PUSH
36483: LD_INT 1
36485: NEG
36486: PUSH
36487: EMPTY
36488: LIST
36489: LIST
36490: PUSH
36491: LD_INT 1
36493: NEG
36494: PUSH
36495: LD_INT 1
36497: PUSH
36498: EMPTY
36499: LIST
36500: LIST
36501: PUSH
36502: EMPTY
36503: LIST
36504: LIST
36505: LIST
36506: LIST
36507: LIST
36508: LIST
36509: LIST
36510: LIST
36511: LIST
36512: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36513: LD_ADDR_VAR 0 41
36517: PUSH
36518: LD_INT 0
36520: PUSH
36521: LD_INT 0
36523: PUSH
36524: EMPTY
36525: LIST
36526: LIST
36527: PUSH
36528: LD_INT 0
36530: PUSH
36531: LD_INT 1
36533: NEG
36534: PUSH
36535: EMPTY
36536: LIST
36537: LIST
36538: PUSH
36539: LD_INT 1
36541: PUSH
36542: LD_INT 0
36544: PUSH
36545: EMPTY
36546: LIST
36547: LIST
36548: PUSH
36549: LD_INT 1
36551: PUSH
36552: LD_INT 1
36554: PUSH
36555: EMPTY
36556: LIST
36557: LIST
36558: PUSH
36559: LD_INT 0
36561: PUSH
36562: LD_INT 1
36564: PUSH
36565: EMPTY
36566: LIST
36567: LIST
36568: PUSH
36569: LD_INT 1
36571: NEG
36572: PUSH
36573: LD_INT 0
36575: PUSH
36576: EMPTY
36577: LIST
36578: LIST
36579: PUSH
36580: LD_INT 1
36582: NEG
36583: PUSH
36584: LD_INT 1
36586: NEG
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PUSH
36592: LD_INT 1
36594: NEG
36595: PUSH
36596: LD_INT 2
36598: NEG
36599: PUSH
36600: EMPTY
36601: LIST
36602: LIST
36603: PUSH
36604: LD_INT 1
36606: PUSH
36607: LD_INT 1
36609: NEG
36610: PUSH
36611: EMPTY
36612: LIST
36613: LIST
36614: PUSH
36615: LD_INT 2
36617: PUSH
36618: LD_INT 0
36620: PUSH
36621: EMPTY
36622: LIST
36623: LIST
36624: PUSH
36625: LD_INT 2
36627: PUSH
36628: LD_INT 1
36630: PUSH
36631: EMPTY
36632: LIST
36633: LIST
36634: PUSH
36635: LD_INT 2
36637: PUSH
36638: LD_INT 2
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: LD_INT 1
36647: PUSH
36648: LD_INT 2
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: PUSH
36655: LD_INT 1
36657: NEG
36658: PUSH
36659: LD_INT 1
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: PUSH
36666: LD_INT 2
36668: NEG
36669: PUSH
36670: LD_INT 0
36672: PUSH
36673: EMPTY
36674: LIST
36675: LIST
36676: PUSH
36677: LD_INT 2
36679: NEG
36680: PUSH
36681: LD_INT 1
36683: NEG
36684: PUSH
36685: EMPTY
36686: LIST
36687: LIST
36688: PUSH
36689: LD_INT 2
36691: NEG
36692: PUSH
36693: LD_INT 2
36695: NEG
36696: PUSH
36697: EMPTY
36698: LIST
36699: LIST
36700: PUSH
36701: LD_INT 2
36703: NEG
36704: PUSH
36705: LD_INT 3
36707: NEG
36708: PUSH
36709: EMPTY
36710: LIST
36711: LIST
36712: PUSH
36713: LD_INT 2
36715: PUSH
36716: LD_INT 1
36718: NEG
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PUSH
36724: LD_INT 3
36726: PUSH
36727: LD_INT 0
36729: PUSH
36730: EMPTY
36731: LIST
36732: LIST
36733: PUSH
36734: LD_INT 3
36736: PUSH
36737: LD_INT 1
36739: PUSH
36740: EMPTY
36741: LIST
36742: LIST
36743: PUSH
36744: LD_INT 3
36746: PUSH
36747: LD_INT 2
36749: PUSH
36750: EMPTY
36751: LIST
36752: LIST
36753: PUSH
36754: LD_INT 3
36756: PUSH
36757: LD_INT 3
36759: PUSH
36760: EMPTY
36761: LIST
36762: LIST
36763: PUSH
36764: LD_INT 2
36766: PUSH
36767: LD_INT 3
36769: PUSH
36770: EMPTY
36771: LIST
36772: LIST
36773: PUSH
36774: LD_INT 2
36776: NEG
36777: PUSH
36778: LD_INT 1
36780: PUSH
36781: EMPTY
36782: LIST
36783: LIST
36784: PUSH
36785: LD_INT 3
36787: NEG
36788: PUSH
36789: LD_INT 0
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: PUSH
36796: LD_INT 3
36798: NEG
36799: PUSH
36800: LD_INT 1
36802: NEG
36803: PUSH
36804: EMPTY
36805: LIST
36806: LIST
36807: PUSH
36808: LD_INT 3
36810: NEG
36811: PUSH
36812: LD_INT 2
36814: NEG
36815: PUSH
36816: EMPTY
36817: LIST
36818: LIST
36819: PUSH
36820: LD_INT 3
36822: NEG
36823: PUSH
36824: LD_INT 3
36826: NEG
36827: PUSH
36828: EMPTY
36829: LIST
36830: LIST
36831: PUSH
36832: EMPTY
36833: LIST
36834: LIST
36835: LIST
36836: LIST
36837: LIST
36838: LIST
36839: LIST
36840: LIST
36841: LIST
36842: LIST
36843: LIST
36844: LIST
36845: LIST
36846: LIST
36847: LIST
36848: LIST
36849: LIST
36850: LIST
36851: LIST
36852: LIST
36853: LIST
36854: LIST
36855: LIST
36856: LIST
36857: LIST
36858: LIST
36859: LIST
36860: LIST
36861: LIST
36862: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36863: LD_ADDR_VAR 0 42
36867: PUSH
36868: LD_INT 0
36870: PUSH
36871: LD_INT 0
36873: PUSH
36874: EMPTY
36875: LIST
36876: LIST
36877: PUSH
36878: LD_INT 0
36880: PUSH
36881: LD_INT 1
36883: NEG
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: PUSH
36889: LD_INT 1
36891: PUSH
36892: LD_INT 0
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: LD_INT 1
36901: PUSH
36902: LD_INT 1
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: LD_INT 0
36911: PUSH
36912: LD_INT 1
36914: PUSH
36915: EMPTY
36916: LIST
36917: LIST
36918: PUSH
36919: LD_INT 1
36921: NEG
36922: PUSH
36923: LD_INT 0
36925: PUSH
36926: EMPTY
36927: LIST
36928: LIST
36929: PUSH
36930: LD_INT 1
36932: NEG
36933: PUSH
36934: LD_INT 1
36936: NEG
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: PUSH
36942: LD_INT 1
36944: NEG
36945: PUSH
36946: LD_INT 2
36948: NEG
36949: PUSH
36950: EMPTY
36951: LIST
36952: LIST
36953: PUSH
36954: LD_INT 0
36956: PUSH
36957: LD_INT 2
36959: NEG
36960: PUSH
36961: EMPTY
36962: LIST
36963: LIST
36964: PUSH
36965: LD_INT 1
36967: PUSH
36968: LD_INT 1
36970: NEG
36971: PUSH
36972: EMPTY
36973: LIST
36974: LIST
36975: PUSH
36976: LD_INT 2
36978: PUSH
36979: LD_INT 1
36981: PUSH
36982: EMPTY
36983: LIST
36984: LIST
36985: PUSH
36986: LD_INT 2
36988: PUSH
36989: LD_INT 2
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: LD_INT 1
36998: PUSH
36999: LD_INT 2
37001: PUSH
37002: EMPTY
37003: LIST
37004: LIST
37005: PUSH
37006: LD_INT 0
37008: PUSH
37009: LD_INT 2
37011: PUSH
37012: EMPTY
37013: LIST
37014: LIST
37015: PUSH
37016: LD_INT 1
37018: NEG
37019: PUSH
37020: LD_INT 1
37022: PUSH
37023: EMPTY
37024: LIST
37025: LIST
37026: PUSH
37027: LD_INT 2
37029: NEG
37030: PUSH
37031: LD_INT 1
37033: NEG
37034: PUSH
37035: EMPTY
37036: LIST
37037: LIST
37038: PUSH
37039: LD_INT 2
37041: NEG
37042: PUSH
37043: LD_INT 2
37045: NEG
37046: PUSH
37047: EMPTY
37048: LIST
37049: LIST
37050: PUSH
37051: LD_INT 2
37053: NEG
37054: PUSH
37055: LD_INT 3
37057: NEG
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: PUSH
37063: LD_INT 1
37065: NEG
37066: PUSH
37067: LD_INT 3
37069: NEG
37070: PUSH
37071: EMPTY
37072: LIST
37073: LIST
37074: PUSH
37075: LD_INT 0
37077: PUSH
37078: LD_INT 3
37080: NEG
37081: PUSH
37082: EMPTY
37083: LIST
37084: LIST
37085: PUSH
37086: LD_INT 1
37088: PUSH
37089: LD_INT 2
37091: NEG
37092: PUSH
37093: EMPTY
37094: LIST
37095: LIST
37096: PUSH
37097: LD_INT 3
37099: PUSH
37100: LD_INT 2
37102: PUSH
37103: EMPTY
37104: LIST
37105: LIST
37106: PUSH
37107: LD_INT 3
37109: PUSH
37110: LD_INT 3
37112: PUSH
37113: EMPTY
37114: LIST
37115: LIST
37116: PUSH
37117: LD_INT 2
37119: PUSH
37120: LD_INT 3
37122: PUSH
37123: EMPTY
37124: LIST
37125: LIST
37126: PUSH
37127: LD_INT 1
37129: PUSH
37130: LD_INT 3
37132: PUSH
37133: EMPTY
37134: LIST
37135: LIST
37136: PUSH
37137: LD_INT 0
37139: PUSH
37140: LD_INT 3
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: PUSH
37147: LD_INT 1
37149: NEG
37150: PUSH
37151: LD_INT 2
37153: PUSH
37154: EMPTY
37155: LIST
37156: LIST
37157: PUSH
37158: LD_INT 3
37160: NEG
37161: PUSH
37162: LD_INT 2
37164: NEG
37165: PUSH
37166: EMPTY
37167: LIST
37168: LIST
37169: PUSH
37170: LD_INT 3
37172: NEG
37173: PUSH
37174: LD_INT 3
37176: NEG
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: EMPTY
37183: LIST
37184: LIST
37185: LIST
37186: LIST
37187: LIST
37188: LIST
37189: LIST
37190: LIST
37191: LIST
37192: LIST
37193: LIST
37194: LIST
37195: LIST
37196: LIST
37197: LIST
37198: LIST
37199: LIST
37200: LIST
37201: LIST
37202: LIST
37203: LIST
37204: LIST
37205: LIST
37206: LIST
37207: LIST
37208: LIST
37209: LIST
37210: LIST
37211: LIST
37212: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37213: LD_ADDR_VAR 0 43
37217: PUSH
37218: LD_INT 0
37220: PUSH
37221: LD_INT 0
37223: PUSH
37224: EMPTY
37225: LIST
37226: LIST
37227: PUSH
37228: LD_INT 0
37230: PUSH
37231: LD_INT 1
37233: NEG
37234: PUSH
37235: EMPTY
37236: LIST
37237: LIST
37238: PUSH
37239: LD_INT 1
37241: PUSH
37242: LD_INT 0
37244: PUSH
37245: EMPTY
37246: LIST
37247: LIST
37248: PUSH
37249: LD_INT 1
37251: PUSH
37252: LD_INT 1
37254: PUSH
37255: EMPTY
37256: LIST
37257: LIST
37258: PUSH
37259: LD_INT 0
37261: PUSH
37262: LD_INT 1
37264: PUSH
37265: EMPTY
37266: LIST
37267: LIST
37268: PUSH
37269: LD_INT 1
37271: NEG
37272: PUSH
37273: LD_INT 0
37275: PUSH
37276: EMPTY
37277: LIST
37278: LIST
37279: PUSH
37280: LD_INT 1
37282: NEG
37283: PUSH
37284: LD_INT 1
37286: NEG
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 1
37294: NEG
37295: PUSH
37296: LD_INT 2
37298: NEG
37299: PUSH
37300: EMPTY
37301: LIST
37302: LIST
37303: PUSH
37304: LD_INT 0
37306: PUSH
37307: LD_INT 2
37309: NEG
37310: PUSH
37311: EMPTY
37312: LIST
37313: LIST
37314: PUSH
37315: LD_INT 1
37317: PUSH
37318: LD_INT 1
37320: NEG
37321: PUSH
37322: EMPTY
37323: LIST
37324: LIST
37325: PUSH
37326: LD_INT 2
37328: PUSH
37329: LD_INT 0
37331: PUSH
37332: EMPTY
37333: LIST
37334: LIST
37335: PUSH
37336: LD_INT 2
37338: PUSH
37339: LD_INT 1
37341: PUSH
37342: EMPTY
37343: LIST
37344: LIST
37345: PUSH
37346: LD_INT 1
37348: PUSH
37349: LD_INT 2
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: PUSH
37356: LD_INT 0
37358: PUSH
37359: LD_INT 2
37361: PUSH
37362: EMPTY
37363: LIST
37364: LIST
37365: PUSH
37366: LD_INT 1
37368: NEG
37369: PUSH
37370: LD_INT 1
37372: PUSH
37373: EMPTY
37374: LIST
37375: LIST
37376: PUSH
37377: LD_INT 2
37379: NEG
37380: PUSH
37381: LD_INT 0
37383: PUSH
37384: EMPTY
37385: LIST
37386: LIST
37387: PUSH
37388: LD_INT 2
37390: NEG
37391: PUSH
37392: LD_INT 1
37394: NEG
37395: PUSH
37396: EMPTY
37397: LIST
37398: LIST
37399: PUSH
37400: LD_INT 1
37402: NEG
37403: PUSH
37404: LD_INT 3
37406: NEG
37407: PUSH
37408: EMPTY
37409: LIST
37410: LIST
37411: PUSH
37412: LD_INT 0
37414: PUSH
37415: LD_INT 3
37417: NEG
37418: PUSH
37419: EMPTY
37420: LIST
37421: LIST
37422: PUSH
37423: LD_INT 1
37425: PUSH
37426: LD_INT 2
37428: NEG
37429: PUSH
37430: EMPTY
37431: LIST
37432: LIST
37433: PUSH
37434: LD_INT 2
37436: PUSH
37437: LD_INT 1
37439: NEG
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: PUSH
37445: LD_INT 3
37447: PUSH
37448: LD_INT 0
37450: PUSH
37451: EMPTY
37452: LIST
37453: LIST
37454: PUSH
37455: LD_INT 3
37457: PUSH
37458: LD_INT 1
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: PUSH
37465: LD_INT 1
37467: PUSH
37468: LD_INT 3
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PUSH
37475: LD_INT 0
37477: PUSH
37478: LD_INT 3
37480: PUSH
37481: EMPTY
37482: LIST
37483: LIST
37484: PUSH
37485: LD_INT 1
37487: NEG
37488: PUSH
37489: LD_INT 2
37491: PUSH
37492: EMPTY
37493: LIST
37494: LIST
37495: PUSH
37496: LD_INT 2
37498: NEG
37499: PUSH
37500: LD_INT 1
37502: PUSH
37503: EMPTY
37504: LIST
37505: LIST
37506: PUSH
37507: LD_INT 3
37509: NEG
37510: PUSH
37511: LD_INT 0
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 3
37520: NEG
37521: PUSH
37522: LD_INT 1
37524: NEG
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: EMPTY
37531: LIST
37532: LIST
37533: LIST
37534: LIST
37535: LIST
37536: LIST
37537: LIST
37538: LIST
37539: LIST
37540: LIST
37541: LIST
37542: LIST
37543: LIST
37544: LIST
37545: LIST
37546: LIST
37547: LIST
37548: LIST
37549: LIST
37550: LIST
37551: LIST
37552: LIST
37553: LIST
37554: LIST
37555: LIST
37556: LIST
37557: LIST
37558: LIST
37559: LIST
37560: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37561: LD_ADDR_VAR 0 44
37565: PUSH
37566: LD_INT 0
37568: PUSH
37569: LD_INT 0
37571: PUSH
37572: EMPTY
37573: LIST
37574: LIST
37575: PUSH
37576: LD_INT 0
37578: PUSH
37579: LD_INT 1
37581: NEG
37582: PUSH
37583: EMPTY
37584: LIST
37585: LIST
37586: PUSH
37587: LD_INT 1
37589: PUSH
37590: LD_INT 0
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 1
37599: PUSH
37600: LD_INT 1
37602: PUSH
37603: EMPTY
37604: LIST
37605: LIST
37606: PUSH
37607: LD_INT 0
37609: PUSH
37610: LD_INT 1
37612: PUSH
37613: EMPTY
37614: LIST
37615: LIST
37616: PUSH
37617: LD_INT 1
37619: NEG
37620: PUSH
37621: LD_INT 0
37623: PUSH
37624: EMPTY
37625: LIST
37626: LIST
37627: PUSH
37628: LD_INT 1
37630: NEG
37631: PUSH
37632: LD_INT 1
37634: NEG
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PUSH
37640: LD_INT 1
37642: NEG
37643: PUSH
37644: LD_INT 2
37646: NEG
37647: PUSH
37648: EMPTY
37649: LIST
37650: LIST
37651: PUSH
37652: LD_INT 1
37654: PUSH
37655: LD_INT 1
37657: NEG
37658: PUSH
37659: EMPTY
37660: LIST
37661: LIST
37662: PUSH
37663: LD_INT 2
37665: PUSH
37666: LD_INT 0
37668: PUSH
37669: EMPTY
37670: LIST
37671: LIST
37672: PUSH
37673: LD_INT 2
37675: PUSH
37676: LD_INT 1
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 2
37685: PUSH
37686: LD_INT 2
37688: PUSH
37689: EMPTY
37690: LIST
37691: LIST
37692: PUSH
37693: LD_INT 1
37695: PUSH
37696: LD_INT 2
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 1
37705: NEG
37706: PUSH
37707: LD_INT 1
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: PUSH
37714: LD_INT 2
37716: NEG
37717: PUSH
37718: LD_INT 0
37720: PUSH
37721: EMPTY
37722: LIST
37723: LIST
37724: PUSH
37725: LD_INT 2
37727: NEG
37728: PUSH
37729: LD_INT 1
37731: NEG
37732: PUSH
37733: EMPTY
37734: LIST
37735: LIST
37736: PUSH
37737: LD_INT 2
37739: NEG
37740: PUSH
37741: LD_INT 2
37743: NEG
37744: PUSH
37745: EMPTY
37746: LIST
37747: LIST
37748: PUSH
37749: LD_INT 2
37751: NEG
37752: PUSH
37753: LD_INT 3
37755: NEG
37756: PUSH
37757: EMPTY
37758: LIST
37759: LIST
37760: PUSH
37761: LD_INT 2
37763: PUSH
37764: LD_INT 1
37766: NEG
37767: PUSH
37768: EMPTY
37769: LIST
37770: LIST
37771: PUSH
37772: LD_INT 3
37774: PUSH
37775: LD_INT 0
37777: PUSH
37778: EMPTY
37779: LIST
37780: LIST
37781: PUSH
37782: LD_INT 3
37784: PUSH
37785: LD_INT 1
37787: PUSH
37788: EMPTY
37789: LIST
37790: LIST
37791: PUSH
37792: LD_INT 3
37794: PUSH
37795: LD_INT 2
37797: PUSH
37798: EMPTY
37799: LIST
37800: LIST
37801: PUSH
37802: LD_INT 3
37804: PUSH
37805: LD_INT 3
37807: PUSH
37808: EMPTY
37809: LIST
37810: LIST
37811: PUSH
37812: LD_INT 2
37814: PUSH
37815: LD_INT 3
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PUSH
37822: LD_INT 2
37824: NEG
37825: PUSH
37826: LD_INT 1
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: PUSH
37833: LD_INT 3
37835: NEG
37836: PUSH
37837: LD_INT 0
37839: PUSH
37840: EMPTY
37841: LIST
37842: LIST
37843: PUSH
37844: LD_INT 3
37846: NEG
37847: PUSH
37848: LD_INT 1
37850: NEG
37851: PUSH
37852: EMPTY
37853: LIST
37854: LIST
37855: PUSH
37856: LD_INT 3
37858: NEG
37859: PUSH
37860: LD_INT 2
37862: NEG
37863: PUSH
37864: EMPTY
37865: LIST
37866: LIST
37867: PUSH
37868: LD_INT 3
37870: NEG
37871: PUSH
37872: LD_INT 3
37874: NEG
37875: PUSH
37876: EMPTY
37877: LIST
37878: LIST
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: LIST
37884: LIST
37885: LIST
37886: LIST
37887: LIST
37888: LIST
37889: LIST
37890: LIST
37891: LIST
37892: LIST
37893: LIST
37894: LIST
37895: LIST
37896: LIST
37897: LIST
37898: LIST
37899: LIST
37900: LIST
37901: LIST
37902: LIST
37903: LIST
37904: LIST
37905: LIST
37906: LIST
37907: LIST
37908: LIST
37909: LIST
37910: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37911: LD_ADDR_VAR 0 45
37915: PUSH
37916: LD_INT 0
37918: PUSH
37919: LD_INT 0
37921: PUSH
37922: EMPTY
37923: LIST
37924: LIST
37925: PUSH
37926: LD_INT 0
37928: PUSH
37929: LD_INT 1
37931: NEG
37932: PUSH
37933: EMPTY
37934: LIST
37935: LIST
37936: PUSH
37937: LD_INT 1
37939: PUSH
37940: LD_INT 0
37942: PUSH
37943: EMPTY
37944: LIST
37945: LIST
37946: PUSH
37947: LD_INT 1
37949: PUSH
37950: LD_INT 1
37952: PUSH
37953: EMPTY
37954: LIST
37955: LIST
37956: PUSH
37957: LD_INT 0
37959: PUSH
37960: LD_INT 1
37962: PUSH
37963: EMPTY
37964: LIST
37965: LIST
37966: PUSH
37967: LD_INT 1
37969: NEG
37970: PUSH
37971: LD_INT 0
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: LD_INT 1
37980: NEG
37981: PUSH
37982: LD_INT 1
37984: NEG
37985: PUSH
37986: EMPTY
37987: LIST
37988: LIST
37989: PUSH
37990: LD_INT 1
37992: NEG
37993: PUSH
37994: LD_INT 2
37996: NEG
37997: PUSH
37998: EMPTY
37999: LIST
38000: LIST
38001: PUSH
38002: LD_INT 0
38004: PUSH
38005: LD_INT 2
38007: NEG
38008: PUSH
38009: EMPTY
38010: LIST
38011: LIST
38012: PUSH
38013: LD_INT 1
38015: PUSH
38016: LD_INT 1
38018: NEG
38019: PUSH
38020: EMPTY
38021: LIST
38022: LIST
38023: PUSH
38024: LD_INT 2
38026: PUSH
38027: LD_INT 1
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PUSH
38034: LD_INT 2
38036: PUSH
38037: LD_INT 2
38039: PUSH
38040: EMPTY
38041: LIST
38042: LIST
38043: PUSH
38044: LD_INT 1
38046: PUSH
38047: LD_INT 2
38049: PUSH
38050: EMPTY
38051: LIST
38052: LIST
38053: PUSH
38054: LD_INT 0
38056: PUSH
38057: LD_INT 2
38059: PUSH
38060: EMPTY
38061: LIST
38062: LIST
38063: PUSH
38064: LD_INT 1
38066: NEG
38067: PUSH
38068: LD_INT 1
38070: PUSH
38071: EMPTY
38072: LIST
38073: LIST
38074: PUSH
38075: LD_INT 2
38077: NEG
38078: PUSH
38079: LD_INT 1
38081: NEG
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 2
38089: NEG
38090: PUSH
38091: LD_INT 2
38093: NEG
38094: PUSH
38095: EMPTY
38096: LIST
38097: LIST
38098: PUSH
38099: LD_INT 2
38101: NEG
38102: PUSH
38103: LD_INT 3
38105: NEG
38106: PUSH
38107: EMPTY
38108: LIST
38109: LIST
38110: PUSH
38111: LD_INT 1
38113: NEG
38114: PUSH
38115: LD_INT 3
38117: NEG
38118: PUSH
38119: EMPTY
38120: LIST
38121: LIST
38122: PUSH
38123: LD_INT 0
38125: PUSH
38126: LD_INT 3
38128: NEG
38129: PUSH
38130: EMPTY
38131: LIST
38132: LIST
38133: PUSH
38134: LD_INT 1
38136: PUSH
38137: LD_INT 2
38139: NEG
38140: PUSH
38141: EMPTY
38142: LIST
38143: LIST
38144: PUSH
38145: LD_INT 3
38147: PUSH
38148: LD_INT 2
38150: PUSH
38151: EMPTY
38152: LIST
38153: LIST
38154: PUSH
38155: LD_INT 3
38157: PUSH
38158: LD_INT 3
38160: PUSH
38161: EMPTY
38162: LIST
38163: LIST
38164: PUSH
38165: LD_INT 2
38167: PUSH
38168: LD_INT 3
38170: PUSH
38171: EMPTY
38172: LIST
38173: LIST
38174: PUSH
38175: LD_INT 1
38177: PUSH
38178: LD_INT 3
38180: PUSH
38181: EMPTY
38182: LIST
38183: LIST
38184: PUSH
38185: LD_INT 0
38187: PUSH
38188: LD_INT 3
38190: PUSH
38191: EMPTY
38192: LIST
38193: LIST
38194: PUSH
38195: LD_INT 1
38197: NEG
38198: PUSH
38199: LD_INT 2
38201: PUSH
38202: EMPTY
38203: LIST
38204: LIST
38205: PUSH
38206: LD_INT 3
38208: NEG
38209: PUSH
38210: LD_INT 2
38212: NEG
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 3
38220: NEG
38221: PUSH
38222: LD_INT 3
38224: NEG
38225: PUSH
38226: EMPTY
38227: LIST
38228: LIST
38229: PUSH
38230: EMPTY
38231: LIST
38232: LIST
38233: LIST
38234: LIST
38235: LIST
38236: LIST
38237: LIST
38238: LIST
38239: LIST
38240: LIST
38241: LIST
38242: LIST
38243: LIST
38244: LIST
38245: LIST
38246: LIST
38247: LIST
38248: LIST
38249: LIST
38250: LIST
38251: LIST
38252: LIST
38253: LIST
38254: LIST
38255: LIST
38256: LIST
38257: LIST
38258: LIST
38259: LIST
38260: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38261: LD_ADDR_VAR 0 46
38265: PUSH
38266: LD_INT 0
38268: PUSH
38269: LD_INT 0
38271: PUSH
38272: EMPTY
38273: LIST
38274: LIST
38275: PUSH
38276: LD_INT 0
38278: PUSH
38279: LD_INT 1
38281: NEG
38282: PUSH
38283: EMPTY
38284: LIST
38285: LIST
38286: PUSH
38287: LD_INT 1
38289: PUSH
38290: LD_INT 0
38292: PUSH
38293: EMPTY
38294: LIST
38295: LIST
38296: PUSH
38297: LD_INT 1
38299: PUSH
38300: LD_INT 1
38302: PUSH
38303: EMPTY
38304: LIST
38305: LIST
38306: PUSH
38307: LD_INT 0
38309: PUSH
38310: LD_INT 1
38312: PUSH
38313: EMPTY
38314: LIST
38315: LIST
38316: PUSH
38317: LD_INT 1
38319: NEG
38320: PUSH
38321: LD_INT 0
38323: PUSH
38324: EMPTY
38325: LIST
38326: LIST
38327: PUSH
38328: LD_INT 1
38330: NEG
38331: PUSH
38332: LD_INT 1
38334: NEG
38335: PUSH
38336: EMPTY
38337: LIST
38338: LIST
38339: PUSH
38340: LD_INT 1
38342: NEG
38343: PUSH
38344: LD_INT 2
38346: NEG
38347: PUSH
38348: EMPTY
38349: LIST
38350: LIST
38351: PUSH
38352: LD_INT 0
38354: PUSH
38355: LD_INT 2
38357: NEG
38358: PUSH
38359: EMPTY
38360: LIST
38361: LIST
38362: PUSH
38363: LD_INT 1
38365: PUSH
38366: LD_INT 1
38368: NEG
38369: PUSH
38370: EMPTY
38371: LIST
38372: LIST
38373: PUSH
38374: LD_INT 2
38376: PUSH
38377: LD_INT 0
38379: PUSH
38380: EMPTY
38381: LIST
38382: LIST
38383: PUSH
38384: LD_INT 2
38386: PUSH
38387: LD_INT 1
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: PUSH
38394: LD_INT 1
38396: PUSH
38397: LD_INT 2
38399: PUSH
38400: EMPTY
38401: LIST
38402: LIST
38403: PUSH
38404: LD_INT 0
38406: PUSH
38407: LD_INT 2
38409: PUSH
38410: EMPTY
38411: LIST
38412: LIST
38413: PUSH
38414: LD_INT 1
38416: NEG
38417: PUSH
38418: LD_INT 1
38420: PUSH
38421: EMPTY
38422: LIST
38423: LIST
38424: PUSH
38425: LD_INT 2
38427: NEG
38428: PUSH
38429: LD_INT 0
38431: PUSH
38432: EMPTY
38433: LIST
38434: LIST
38435: PUSH
38436: LD_INT 2
38438: NEG
38439: PUSH
38440: LD_INT 1
38442: NEG
38443: PUSH
38444: EMPTY
38445: LIST
38446: LIST
38447: PUSH
38448: LD_INT 1
38450: NEG
38451: PUSH
38452: LD_INT 3
38454: NEG
38455: PUSH
38456: EMPTY
38457: LIST
38458: LIST
38459: PUSH
38460: LD_INT 0
38462: PUSH
38463: LD_INT 3
38465: NEG
38466: PUSH
38467: EMPTY
38468: LIST
38469: LIST
38470: PUSH
38471: LD_INT 1
38473: PUSH
38474: LD_INT 2
38476: NEG
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: LD_INT 2
38484: PUSH
38485: LD_INT 1
38487: NEG
38488: PUSH
38489: EMPTY
38490: LIST
38491: LIST
38492: PUSH
38493: LD_INT 3
38495: PUSH
38496: LD_INT 0
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 3
38505: PUSH
38506: LD_INT 1
38508: PUSH
38509: EMPTY
38510: LIST
38511: LIST
38512: PUSH
38513: LD_INT 1
38515: PUSH
38516: LD_INT 3
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: PUSH
38523: LD_INT 0
38525: PUSH
38526: LD_INT 3
38528: PUSH
38529: EMPTY
38530: LIST
38531: LIST
38532: PUSH
38533: LD_INT 1
38535: NEG
38536: PUSH
38537: LD_INT 2
38539: PUSH
38540: EMPTY
38541: LIST
38542: LIST
38543: PUSH
38544: LD_INT 2
38546: NEG
38547: PUSH
38548: LD_INT 1
38550: PUSH
38551: EMPTY
38552: LIST
38553: LIST
38554: PUSH
38555: LD_INT 3
38557: NEG
38558: PUSH
38559: LD_INT 0
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: PUSH
38566: LD_INT 3
38568: NEG
38569: PUSH
38570: LD_INT 1
38572: NEG
38573: PUSH
38574: EMPTY
38575: LIST
38576: LIST
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: LIST
38582: LIST
38583: LIST
38584: LIST
38585: LIST
38586: LIST
38587: LIST
38588: LIST
38589: LIST
38590: LIST
38591: LIST
38592: LIST
38593: LIST
38594: LIST
38595: LIST
38596: LIST
38597: LIST
38598: LIST
38599: LIST
38600: LIST
38601: LIST
38602: LIST
38603: LIST
38604: LIST
38605: LIST
38606: LIST
38607: LIST
38608: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38609: LD_ADDR_VAR 0 47
38613: PUSH
38614: LD_INT 0
38616: PUSH
38617: LD_INT 0
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: PUSH
38624: LD_INT 0
38626: PUSH
38627: LD_INT 1
38629: NEG
38630: PUSH
38631: EMPTY
38632: LIST
38633: LIST
38634: PUSH
38635: LD_INT 1
38637: PUSH
38638: LD_INT 0
38640: PUSH
38641: EMPTY
38642: LIST
38643: LIST
38644: PUSH
38645: LD_INT 1
38647: PUSH
38648: LD_INT 1
38650: PUSH
38651: EMPTY
38652: LIST
38653: LIST
38654: PUSH
38655: LD_INT 0
38657: PUSH
38658: LD_INT 1
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: PUSH
38665: LD_INT 1
38667: NEG
38668: PUSH
38669: LD_INT 0
38671: PUSH
38672: EMPTY
38673: LIST
38674: LIST
38675: PUSH
38676: LD_INT 1
38678: NEG
38679: PUSH
38680: LD_INT 1
38682: NEG
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PUSH
38688: LD_INT 1
38690: NEG
38691: PUSH
38692: LD_INT 2
38694: NEG
38695: PUSH
38696: EMPTY
38697: LIST
38698: LIST
38699: PUSH
38700: LD_INT 0
38702: PUSH
38703: LD_INT 2
38705: NEG
38706: PUSH
38707: EMPTY
38708: LIST
38709: LIST
38710: PUSH
38711: LD_INT 1
38713: PUSH
38714: LD_INT 1
38716: NEG
38717: PUSH
38718: EMPTY
38719: LIST
38720: LIST
38721: PUSH
38722: LD_INT 2
38724: NEG
38725: PUSH
38726: LD_INT 1
38728: NEG
38729: PUSH
38730: EMPTY
38731: LIST
38732: LIST
38733: PUSH
38734: LD_INT 2
38736: NEG
38737: PUSH
38738: LD_INT 2
38740: NEG
38741: PUSH
38742: EMPTY
38743: LIST
38744: LIST
38745: PUSH
38746: EMPTY
38747: LIST
38748: LIST
38749: LIST
38750: LIST
38751: LIST
38752: LIST
38753: LIST
38754: LIST
38755: LIST
38756: LIST
38757: LIST
38758: LIST
38759: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38760: LD_ADDR_VAR 0 48
38764: PUSH
38765: LD_INT 0
38767: PUSH
38768: LD_INT 0
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: PUSH
38775: LD_INT 0
38777: PUSH
38778: LD_INT 1
38780: NEG
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: PUSH
38786: LD_INT 1
38788: PUSH
38789: LD_INT 0
38791: PUSH
38792: EMPTY
38793: LIST
38794: LIST
38795: PUSH
38796: LD_INT 1
38798: PUSH
38799: LD_INT 1
38801: PUSH
38802: EMPTY
38803: LIST
38804: LIST
38805: PUSH
38806: LD_INT 0
38808: PUSH
38809: LD_INT 1
38811: PUSH
38812: EMPTY
38813: LIST
38814: LIST
38815: PUSH
38816: LD_INT 1
38818: NEG
38819: PUSH
38820: LD_INT 0
38822: PUSH
38823: EMPTY
38824: LIST
38825: LIST
38826: PUSH
38827: LD_INT 1
38829: NEG
38830: PUSH
38831: LD_INT 1
38833: NEG
38834: PUSH
38835: EMPTY
38836: LIST
38837: LIST
38838: PUSH
38839: LD_INT 1
38841: NEG
38842: PUSH
38843: LD_INT 2
38845: NEG
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: PUSH
38851: LD_INT 0
38853: PUSH
38854: LD_INT 2
38856: NEG
38857: PUSH
38858: EMPTY
38859: LIST
38860: LIST
38861: PUSH
38862: LD_INT 1
38864: PUSH
38865: LD_INT 1
38867: NEG
38868: PUSH
38869: EMPTY
38870: LIST
38871: LIST
38872: PUSH
38873: LD_INT 2
38875: PUSH
38876: LD_INT 0
38878: PUSH
38879: EMPTY
38880: LIST
38881: LIST
38882: PUSH
38883: LD_INT 2
38885: PUSH
38886: LD_INT 1
38888: PUSH
38889: EMPTY
38890: LIST
38891: LIST
38892: PUSH
38893: EMPTY
38894: LIST
38895: LIST
38896: LIST
38897: LIST
38898: LIST
38899: LIST
38900: LIST
38901: LIST
38902: LIST
38903: LIST
38904: LIST
38905: LIST
38906: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38907: LD_ADDR_VAR 0 49
38911: PUSH
38912: LD_INT 0
38914: PUSH
38915: LD_INT 0
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 0
38924: PUSH
38925: LD_INT 1
38927: NEG
38928: PUSH
38929: EMPTY
38930: LIST
38931: LIST
38932: PUSH
38933: LD_INT 1
38935: PUSH
38936: LD_INT 0
38938: PUSH
38939: EMPTY
38940: LIST
38941: LIST
38942: PUSH
38943: LD_INT 1
38945: PUSH
38946: LD_INT 1
38948: PUSH
38949: EMPTY
38950: LIST
38951: LIST
38952: PUSH
38953: LD_INT 0
38955: PUSH
38956: LD_INT 1
38958: PUSH
38959: EMPTY
38960: LIST
38961: LIST
38962: PUSH
38963: LD_INT 1
38965: NEG
38966: PUSH
38967: LD_INT 0
38969: PUSH
38970: EMPTY
38971: LIST
38972: LIST
38973: PUSH
38974: LD_INT 1
38976: NEG
38977: PUSH
38978: LD_INT 1
38980: NEG
38981: PUSH
38982: EMPTY
38983: LIST
38984: LIST
38985: PUSH
38986: LD_INT 1
38988: PUSH
38989: LD_INT 1
38991: NEG
38992: PUSH
38993: EMPTY
38994: LIST
38995: LIST
38996: PUSH
38997: LD_INT 2
38999: PUSH
39000: LD_INT 0
39002: PUSH
39003: EMPTY
39004: LIST
39005: LIST
39006: PUSH
39007: LD_INT 2
39009: PUSH
39010: LD_INT 1
39012: PUSH
39013: EMPTY
39014: LIST
39015: LIST
39016: PUSH
39017: LD_INT 2
39019: PUSH
39020: LD_INT 2
39022: PUSH
39023: EMPTY
39024: LIST
39025: LIST
39026: PUSH
39027: LD_INT 1
39029: PUSH
39030: LD_INT 2
39032: PUSH
39033: EMPTY
39034: LIST
39035: LIST
39036: PUSH
39037: EMPTY
39038: LIST
39039: LIST
39040: LIST
39041: LIST
39042: LIST
39043: LIST
39044: LIST
39045: LIST
39046: LIST
39047: LIST
39048: LIST
39049: LIST
39050: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39051: LD_ADDR_VAR 0 50
39055: PUSH
39056: LD_INT 0
39058: PUSH
39059: LD_INT 0
39061: PUSH
39062: EMPTY
39063: LIST
39064: LIST
39065: PUSH
39066: LD_INT 0
39068: PUSH
39069: LD_INT 1
39071: NEG
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: PUSH
39077: LD_INT 1
39079: PUSH
39080: LD_INT 0
39082: PUSH
39083: EMPTY
39084: LIST
39085: LIST
39086: PUSH
39087: LD_INT 1
39089: PUSH
39090: LD_INT 1
39092: PUSH
39093: EMPTY
39094: LIST
39095: LIST
39096: PUSH
39097: LD_INT 0
39099: PUSH
39100: LD_INT 1
39102: PUSH
39103: EMPTY
39104: LIST
39105: LIST
39106: PUSH
39107: LD_INT 1
39109: NEG
39110: PUSH
39111: LD_INT 0
39113: PUSH
39114: EMPTY
39115: LIST
39116: LIST
39117: PUSH
39118: LD_INT 1
39120: NEG
39121: PUSH
39122: LD_INT 1
39124: NEG
39125: PUSH
39126: EMPTY
39127: LIST
39128: LIST
39129: PUSH
39130: LD_INT 2
39132: PUSH
39133: LD_INT 1
39135: PUSH
39136: EMPTY
39137: LIST
39138: LIST
39139: PUSH
39140: LD_INT 2
39142: PUSH
39143: LD_INT 2
39145: PUSH
39146: EMPTY
39147: LIST
39148: LIST
39149: PUSH
39150: LD_INT 1
39152: PUSH
39153: LD_INT 2
39155: PUSH
39156: EMPTY
39157: LIST
39158: LIST
39159: PUSH
39160: LD_INT 0
39162: PUSH
39163: LD_INT 2
39165: PUSH
39166: EMPTY
39167: LIST
39168: LIST
39169: PUSH
39170: LD_INT 1
39172: NEG
39173: PUSH
39174: LD_INT 1
39176: PUSH
39177: EMPTY
39178: LIST
39179: LIST
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: LIST
39185: LIST
39186: LIST
39187: LIST
39188: LIST
39189: LIST
39190: LIST
39191: LIST
39192: LIST
39193: LIST
39194: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39195: LD_ADDR_VAR 0 51
39199: PUSH
39200: LD_INT 0
39202: PUSH
39203: LD_INT 0
39205: PUSH
39206: EMPTY
39207: LIST
39208: LIST
39209: PUSH
39210: LD_INT 0
39212: PUSH
39213: LD_INT 1
39215: NEG
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: PUSH
39221: LD_INT 1
39223: PUSH
39224: LD_INT 0
39226: PUSH
39227: EMPTY
39228: LIST
39229: LIST
39230: PUSH
39231: LD_INT 1
39233: PUSH
39234: LD_INT 1
39236: PUSH
39237: EMPTY
39238: LIST
39239: LIST
39240: PUSH
39241: LD_INT 0
39243: PUSH
39244: LD_INT 1
39246: PUSH
39247: EMPTY
39248: LIST
39249: LIST
39250: PUSH
39251: LD_INT 1
39253: NEG
39254: PUSH
39255: LD_INT 0
39257: PUSH
39258: EMPTY
39259: LIST
39260: LIST
39261: PUSH
39262: LD_INT 1
39264: NEG
39265: PUSH
39266: LD_INT 1
39268: NEG
39269: PUSH
39270: EMPTY
39271: LIST
39272: LIST
39273: PUSH
39274: LD_INT 1
39276: PUSH
39277: LD_INT 2
39279: PUSH
39280: EMPTY
39281: LIST
39282: LIST
39283: PUSH
39284: LD_INT 0
39286: PUSH
39287: LD_INT 2
39289: PUSH
39290: EMPTY
39291: LIST
39292: LIST
39293: PUSH
39294: LD_INT 1
39296: NEG
39297: PUSH
39298: LD_INT 1
39300: PUSH
39301: EMPTY
39302: LIST
39303: LIST
39304: PUSH
39305: LD_INT 2
39307: NEG
39308: PUSH
39309: LD_INT 0
39311: PUSH
39312: EMPTY
39313: LIST
39314: LIST
39315: PUSH
39316: LD_INT 2
39318: NEG
39319: PUSH
39320: LD_INT 1
39322: NEG
39323: PUSH
39324: EMPTY
39325: LIST
39326: LIST
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: LIST
39332: LIST
39333: LIST
39334: LIST
39335: LIST
39336: LIST
39337: LIST
39338: LIST
39339: LIST
39340: LIST
39341: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39342: LD_ADDR_VAR 0 52
39346: PUSH
39347: LD_INT 0
39349: PUSH
39350: LD_INT 0
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PUSH
39357: LD_INT 0
39359: PUSH
39360: LD_INT 1
39362: NEG
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: PUSH
39368: LD_INT 1
39370: PUSH
39371: LD_INT 0
39373: PUSH
39374: EMPTY
39375: LIST
39376: LIST
39377: PUSH
39378: LD_INT 1
39380: PUSH
39381: LD_INT 1
39383: PUSH
39384: EMPTY
39385: LIST
39386: LIST
39387: PUSH
39388: LD_INT 0
39390: PUSH
39391: LD_INT 1
39393: PUSH
39394: EMPTY
39395: LIST
39396: LIST
39397: PUSH
39398: LD_INT 1
39400: NEG
39401: PUSH
39402: LD_INT 0
39404: PUSH
39405: EMPTY
39406: LIST
39407: LIST
39408: PUSH
39409: LD_INT 1
39411: NEG
39412: PUSH
39413: LD_INT 1
39415: NEG
39416: PUSH
39417: EMPTY
39418: LIST
39419: LIST
39420: PUSH
39421: LD_INT 1
39423: NEG
39424: PUSH
39425: LD_INT 2
39427: NEG
39428: PUSH
39429: EMPTY
39430: LIST
39431: LIST
39432: PUSH
39433: LD_INT 1
39435: NEG
39436: PUSH
39437: LD_INT 1
39439: PUSH
39440: EMPTY
39441: LIST
39442: LIST
39443: PUSH
39444: LD_INT 2
39446: NEG
39447: PUSH
39448: LD_INT 0
39450: PUSH
39451: EMPTY
39452: LIST
39453: LIST
39454: PUSH
39455: LD_INT 2
39457: NEG
39458: PUSH
39459: LD_INT 1
39461: NEG
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PUSH
39467: LD_INT 2
39469: NEG
39470: PUSH
39471: LD_INT 2
39473: NEG
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PUSH
39479: EMPTY
39480: LIST
39481: LIST
39482: LIST
39483: LIST
39484: LIST
39485: LIST
39486: LIST
39487: LIST
39488: LIST
39489: LIST
39490: LIST
39491: LIST
39492: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39493: LD_ADDR_VAR 0 53
39497: PUSH
39498: LD_INT 0
39500: PUSH
39501: LD_INT 0
39503: PUSH
39504: EMPTY
39505: LIST
39506: LIST
39507: PUSH
39508: LD_INT 0
39510: PUSH
39511: LD_INT 1
39513: NEG
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: PUSH
39519: LD_INT 1
39521: PUSH
39522: LD_INT 0
39524: PUSH
39525: EMPTY
39526: LIST
39527: LIST
39528: PUSH
39529: LD_INT 1
39531: PUSH
39532: LD_INT 1
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: PUSH
39539: LD_INT 0
39541: PUSH
39542: LD_INT 1
39544: PUSH
39545: EMPTY
39546: LIST
39547: LIST
39548: PUSH
39549: LD_INT 1
39551: NEG
39552: PUSH
39553: LD_INT 0
39555: PUSH
39556: EMPTY
39557: LIST
39558: LIST
39559: PUSH
39560: LD_INT 1
39562: NEG
39563: PUSH
39564: LD_INT 1
39566: NEG
39567: PUSH
39568: EMPTY
39569: LIST
39570: LIST
39571: PUSH
39572: LD_INT 1
39574: NEG
39575: PUSH
39576: LD_INT 2
39578: NEG
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 0
39586: PUSH
39587: LD_INT 2
39589: NEG
39590: PUSH
39591: EMPTY
39592: LIST
39593: LIST
39594: PUSH
39595: LD_INT 1
39597: PUSH
39598: LD_INT 1
39600: NEG
39601: PUSH
39602: EMPTY
39603: LIST
39604: LIST
39605: PUSH
39606: LD_INT 2
39608: PUSH
39609: LD_INT 0
39611: PUSH
39612: EMPTY
39613: LIST
39614: LIST
39615: PUSH
39616: LD_INT 2
39618: PUSH
39619: LD_INT 1
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: PUSH
39626: LD_INT 2
39628: PUSH
39629: LD_INT 2
39631: PUSH
39632: EMPTY
39633: LIST
39634: LIST
39635: PUSH
39636: LD_INT 1
39638: PUSH
39639: LD_INT 2
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: LD_INT 0
39648: PUSH
39649: LD_INT 2
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: LD_INT 1
39658: NEG
39659: PUSH
39660: LD_INT 1
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 2
39669: NEG
39670: PUSH
39671: LD_INT 0
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: PUSH
39678: LD_INT 2
39680: NEG
39681: PUSH
39682: LD_INT 1
39684: NEG
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 2
39692: NEG
39693: PUSH
39694: LD_INT 2
39696: NEG
39697: PUSH
39698: EMPTY
39699: LIST
39700: LIST
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: LIST
39706: LIST
39707: LIST
39708: LIST
39709: LIST
39710: LIST
39711: LIST
39712: LIST
39713: LIST
39714: LIST
39715: LIST
39716: LIST
39717: LIST
39718: LIST
39719: LIST
39720: LIST
39721: LIST
39722: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39723: LD_ADDR_VAR 0 54
39727: PUSH
39728: LD_INT 0
39730: PUSH
39731: LD_INT 0
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: LD_INT 0
39740: PUSH
39741: LD_INT 1
39743: NEG
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: PUSH
39749: LD_INT 1
39751: PUSH
39752: LD_INT 0
39754: PUSH
39755: EMPTY
39756: LIST
39757: LIST
39758: PUSH
39759: LD_INT 1
39761: PUSH
39762: LD_INT 1
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 0
39771: PUSH
39772: LD_INT 1
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 1
39781: NEG
39782: PUSH
39783: LD_INT 0
39785: PUSH
39786: EMPTY
39787: LIST
39788: LIST
39789: PUSH
39790: LD_INT 1
39792: NEG
39793: PUSH
39794: LD_INT 1
39796: NEG
39797: PUSH
39798: EMPTY
39799: LIST
39800: LIST
39801: PUSH
39802: LD_INT 1
39804: NEG
39805: PUSH
39806: LD_INT 2
39808: NEG
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: PUSH
39814: LD_INT 0
39816: PUSH
39817: LD_INT 2
39819: NEG
39820: PUSH
39821: EMPTY
39822: LIST
39823: LIST
39824: PUSH
39825: LD_INT 1
39827: PUSH
39828: LD_INT 1
39830: NEG
39831: PUSH
39832: EMPTY
39833: LIST
39834: LIST
39835: PUSH
39836: LD_INT 2
39838: PUSH
39839: LD_INT 0
39841: PUSH
39842: EMPTY
39843: LIST
39844: LIST
39845: PUSH
39846: LD_INT 2
39848: PUSH
39849: LD_INT 1
39851: PUSH
39852: EMPTY
39853: LIST
39854: LIST
39855: PUSH
39856: LD_INT 2
39858: PUSH
39859: LD_INT 2
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: LD_INT 1
39868: PUSH
39869: LD_INT 2
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PUSH
39876: LD_INT 0
39878: PUSH
39879: LD_INT 2
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PUSH
39886: LD_INT 1
39888: NEG
39889: PUSH
39890: LD_INT 1
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 2
39899: NEG
39900: PUSH
39901: LD_INT 0
39903: PUSH
39904: EMPTY
39905: LIST
39906: LIST
39907: PUSH
39908: LD_INT 2
39910: NEG
39911: PUSH
39912: LD_INT 1
39914: NEG
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: PUSH
39920: LD_INT 2
39922: NEG
39923: PUSH
39924: LD_INT 2
39926: NEG
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: EMPTY
39933: LIST
39934: LIST
39935: LIST
39936: LIST
39937: LIST
39938: LIST
39939: LIST
39940: LIST
39941: LIST
39942: LIST
39943: LIST
39944: LIST
39945: LIST
39946: LIST
39947: LIST
39948: LIST
39949: LIST
39950: LIST
39951: LIST
39952: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39953: LD_ADDR_VAR 0 55
39957: PUSH
39958: LD_INT 0
39960: PUSH
39961: LD_INT 0
39963: PUSH
39964: EMPTY
39965: LIST
39966: LIST
39967: PUSH
39968: LD_INT 0
39970: PUSH
39971: LD_INT 1
39973: NEG
39974: PUSH
39975: EMPTY
39976: LIST
39977: LIST
39978: PUSH
39979: LD_INT 1
39981: PUSH
39982: LD_INT 0
39984: PUSH
39985: EMPTY
39986: LIST
39987: LIST
39988: PUSH
39989: LD_INT 1
39991: PUSH
39992: LD_INT 1
39994: PUSH
39995: EMPTY
39996: LIST
39997: LIST
39998: PUSH
39999: LD_INT 0
40001: PUSH
40002: LD_INT 1
40004: PUSH
40005: EMPTY
40006: LIST
40007: LIST
40008: PUSH
40009: LD_INT 1
40011: NEG
40012: PUSH
40013: LD_INT 0
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PUSH
40020: LD_INT 1
40022: NEG
40023: PUSH
40024: LD_INT 1
40026: NEG
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: PUSH
40032: LD_INT 1
40034: NEG
40035: PUSH
40036: LD_INT 2
40038: NEG
40039: PUSH
40040: EMPTY
40041: LIST
40042: LIST
40043: PUSH
40044: LD_INT 0
40046: PUSH
40047: LD_INT 2
40049: NEG
40050: PUSH
40051: EMPTY
40052: LIST
40053: LIST
40054: PUSH
40055: LD_INT 1
40057: PUSH
40058: LD_INT 1
40060: NEG
40061: PUSH
40062: EMPTY
40063: LIST
40064: LIST
40065: PUSH
40066: LD_INT 2
40068: PUSH
40069: LD_INT 0
40071: PUSH
40072: EMPTY
40073: LIST
40074: LIST
40075: PUSH
40076: LD_INT 2
40078: PUSH
40079: LD_INT 1
40081: PUSH
40082: EMPTY
40083: LIST
40084: LIST
40085: PUSH
40086: LD_INT 2
40088: PUSH
40089: LD_INT 2
40091: PUSH
40092: EMPTY
40093: LIST
40094: LIST
40095: PUSH
40096: LD_INT 1
40098: PUSH
40099: LD_INT 2
40101: PUSH
40102: EMPTY
40103: LIST
40104: LIST
40105: PUSH
40106: LD_INT 0
40108: PUSH
40109: LD_INT 2
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 1
40118: NEG
40119: PUSH
40120: LD_INT 1
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PUSH
40127: LD_INT 2
40129: NEG
40130: PUSH
40131: LD_INT 0
40133: PUSH
40134: EMPTY
40135: LIST
40136: LIST
40137: PUSH
40138: LD_INT 2
40140: NEG
40141: PUSH
40142: LD_INT 1
40144: NEG
40145: PUSH
40146: EMPTY
40147: LIST
40148: LIST
40149: PUSH
40150: LD_INT 2
40152: NEG
40153: PUSH
40154: LD_INT 2
40156: NEG
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: EMPTY
40163: LIST
40164: LIST
40165: LIST
40166: LIST
40167: LIST
40168: LIST
40169: LIST
40170: LIST
40171: LIST
40172: LIST
40173: LIST
40174: LIST
40175: LIST
40176: LIST
40177: LIST
40178: LIST
40179: LIST
40180: LIST
40181: LIST
40182: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40183: LD_ADDR_VAR 0 56
40187: PUSH
40188: LD_INT 0
40190: PUSH
40191: LD_INT 0
40193: PUSH
40194: EMPTY
40195: LIST
40196: LIST
40197: PUSH
40198: LD_INT 0
40200: PUSH
40201: LD_INT 1
40203: NEG
40204: PUSH
40205: EMPTY
40206: LIST
40207: LIST
40208: PUSH
40209: LD_INT 1
40211: PUSH
40212: LD_INT 0
40214: PUSH
40215: EMPTY
40216: LIST
40217: LIST
40218: PUSH
40219: LD_INT 1
40221: PUSH
40222: LD_INT 1
40224: PUSH
40225: EMPTY
40226: LIST
40227: LIST
40228: PUSH
40229: LD_INT 0
40231: PUSH
40232: LD_INT 1
40234: PUSH
40235: EMPTY
40236: LIST
40237: LIST
40238: PUSH
40239: LD_INT 1
40241: NEG
40242: PUSH
40243: LD_INT 0
40245: PUSH
40246: EMPTY
40247: LIST
40248: LIST
40249: PUSH
40250: LD_INT 1
40252: NEG
40253: PUSH
40254: LD_INT 1
40256: NEG
40257: PUSH
40258: EMPTY
40259: LIST
40260: LIST
40261: PUSH
40262: LD_INT 1
40264: NEG
40265: PUSH
40266: LD_INT 2
40268: NEG
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: LD_INT 0
40276: PUSH
40277: LD_INT 2
40279: NEG
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: LD_INT 1
40287: PUSH
40288: LD_INT 1
40290: NEG
40291: PUSH
40292: EMPTY
40293: LIST
40294: LIST
40295: PUSH
40296: LD_INT 2
40298: PUSH
40299: LD_INT 0
40301: PUSH
40302: EMPTY
40303: LIST
40304: LIST
40305: PUSH
40306: LD_INT 2
40308: PUSH
40309: LD_INT 1
40311: PUSH
40312: EMPTY
40313: LIST
40314: LIST
40315: PUSH
40316: LD_INT 2
40318: PUSH
40319: LD_INT 2
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PUSH
40326: LD_INT 1
40328: PUSH
40329: LD_INT 2
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: LD_INT 0
40338: PUSH
40339: LD_INT 2
40341: PUSH
40342: EMPTY
40343: LIST
40344: LIST
40345: PUSH
40346: LD_INT 1
40348: NEG
40349: PUSH
40350: LD_INT 1
40352: PUSH
40353: EMPTY
40354: LIST
40355: LIST
40356: PUSH
40357: LD_INT 2
40359: NEG
40360: PUSH
40361: LD_INT 0
40363: PUSH
40364: EMPTY
40365: LIST
40366: LIST
40367: PUSH
40368: LD_INT 2
40370: NEG
40371: PUSH
40372: LD_INT 1
40374: NEG
40375: PUSH
40376: EMPTY
40377: LIST
40378: LIST
40379: PUSH
40380: LD_INT 2
40382: NEG
40383: PUSH
40384: LD_INT 2
40386: NEG
40387: PUSH
40388: EMPTY
40389: LIST
40390: LIST
40391: PUSH
40392: EMPTY
40393: LIST
40394: LIST
40395: LIST
40396: LIST
40397: LIST
40398: LIST
40399: LIST
40400: LIST
40401: LIST
40402: LIST
40403: LIST
40404: LIST
40405: LIST
40406: LIST
40407: LIST
40408: LIST
40409: LIST
40410: LIST
40411: LIST
40412: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40413: LD_ADDR_VAR 0 57
40417: PUSH
40418: LD_INT 0
40420: PUSH
40421: LD_INT 0
40423: PUSH
40424: EMPTY
40425: LIST
40426: LIST
40427: PUSH
40428: LD_INT 0
40430: PUSH
40431: LD_INT 1
40433: NEG
40434: PUSH
40435: EMPTY
40436: LIST
40437: LIST
40438: PUSH
40439: LD_INT 1
40441: PUSH
40442: LD_INT 0
40444: PUSH
40445: EMPTY
40446: LIST
40447: LIST
40448: PUSH
40449: LD_INT 1
40451: PUSH
40452: LD_INT 1
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: LD_INT 0
40461: PUSH
40462: LD_INT 1
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: LD_INT 1
40471: NEG
40472: PUSH
40473: LD_INT 0
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PUSH
40480: LD_INT 1
40482: NEG
40483: PUSH
40484: LD_INT 1
40486: NEG
40487: PUSH
40488: EMPTY
40489: LIST
40490: LIST
40491: PUSH
40492: LD_INT 1
40494: NEG
40495: PUSH
40496: LD_INT 2
40498: NEG
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: LD_INT 0
40506: PUSH
40507: LD_INT 2
40509: NEG
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 1
40517: PUSH
40518: LD_INT 1
40520: NEG
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: PUSH
40526: LD_INT 2
40528: PUSH
40529: LD_INT 0
40531: PUSH
40532: EMPTY
40533: LIST
40534: LIST
40535: PUSH
40536: LD_INT 2
40538: PUSH
40539: LD_INT 1
40541: PUSH
40542: EMPTY
40543: LIST
40544: LIST
40545: PUSH
40546: LD_INT 2
40548: PUSH
40549: LD_INT 2
40551: PUSH
40552: EMPTY
40553: LIST
40554: LIST
40555: PUSH
40556: LD_INT 1
40558: PUSH
40559: LD_INT 2
40561: PUSH
40562: EMPTY
40563: LIST
40564: LIST
40565: PUSH
40566: LD_INT 0
40568: PUSH
40569: LD_INT 2
40571: PUSH
40572: EMPTY
40573: LIST
40574: LIST
40575: PUSH
40576: LD_INT 1
40578: NEG
40579: PUSH
40580: LD_INT 1
40582: PUSH
40583: EMPTY
40584: LIST
40585: LIST
40586: PUSH
40587: LD_INT 2
40589: NEG
40590: PUSH
40591: LD_INT 0
40593: PUSH
40594: EMPTY
40595: LIST
40596: LIST
40597: PUSH
40598: LD_INT 2
40600: NEG
40601: PUSH
40602: LD_INT 1
40604: NEG
40605: PUSH
40606: EMPTY
40607: LIST
40608: LIST
40609: PUSH
40610: LD_INT 2
40612: NEG
40613: PUSH
40614: LD_INT 2
40616: NEG
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: PUSH
40622: EMPTY
40623: LIST
40624: LIST
40625: LIST
40626: LIST
40627: LIST
40628: LIST
40629: LIST
40630: LIST
40631: LIST
40632: LIST
40633: LIST
40634: LIST
40635: LIST
40636: LIST
40637: LIST
40638: LIST
40639: LIST
40640: LIST
40641: LIST
40642: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40643: LD_ADDR_VAR 0 58
40647: PUSH
40648: LD_INT 0
40650: PUSH
40651: LD_INT 0
40653: PUSH
40654: EMPTY
40655: LIST
40656: LIST
40657: PUSH
40658: LD_INT 0
40660: PUSH
40661: LD_INT 1
40663: NEG
40664: PUSH
40665: EMPTY
40666: LIST
40667: LIST
40668: PUSH
40669: LD_INT 1
40671: PUSH
40672: LD_INT 0
40674: PUSH
40675: EMPTY
40676: LIST
40677: LIST
40678: PUSH
40679: LD_INT 1
40681: PUSH
40682: LD_INT 1
40684: PUSH
40685: EMPTY
40686: LIST
40687: LIST
40688: PUSH
40689: LD_INT 0
40691: PUSH
40692: LD_INT 1
40694: PUSH
40695: EMPTY
40696: LIST
40697: LIST
40698: PUSH
40699: LD_INT 1
40701: NEG
40702: PUSH
40703: LD_INT 0
40705: PUSH
40706: EMPTY
40707: LIST
40708: LIST
40709: PUSH
40710: LD_INT 1
40712: NEG
40713: PUSH
40714: LD_INT 1
40716: NEG
40717: PUSH
40718: EMPTY
40719: LIST
40720: LIST
40721: PUSH
40722: LD_INT 1
40724: NEG
40725: PUSH
40726: LD_INT 2
40728: NEG
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: PUSH
40734: LD_INT 0
40736: PUSH
40737: LD_INT 2
40739: NEG
40740: PUSH
40741: EMPTY
40742: LIST
40743: LIST
40744: PUSH
40745: LD_INT 1
40747: PUSH
40748: LD_INT 1
40750: NEG
40751: PUSH
40752: EMPTY
40753: LIST
40754: LIST
40755: PUSH
40756: LD_INT 2
40758: PUSH
40759: LD_INT 0
40761: PUSH
40762: EMPTY
40763: LIST
40764: LIST
40765: PUSH
40766: LD_INT 2
40768: PUSH
40769: LD_INT 1
40771: PUSH
40772: EMPTY
40773: LIST
40774: LIST
40775: PUSH
40776: LD_INT 2
40778: PUSH
40779: LD_INT 2
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 1
40788: PUSH
40789: LD_INT 2
40791: PUSH
40792: EMPTY
40793: LIST
40794: LIST
40795: PUSH
40796: LD_INT 0
40798: PUSH
40799: LD_INT 2
40801: PUSH
40802: EMPTY
40803: LIST
40804: LIST
40805: PUSH
40806: LD_INT 1
40808: NEG
40809: PUSH
40810: LD_INT 1
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PUSH
40817: LD_INT 2
40819: NEG
40820: PUSH
40821: LD_INT 0
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: PUSH
40828: LD_INT 2
40830: NEG
40831: PUSH
40832: LD_INT 1
40834: NEG
40835: PUSH
40836: EMPTY
40837: LIST
40838: LIST
40839: PUSH
40840: LD_INT 2
40842: NEG
40843: PUSH
40844: LD_INT 2
40846: NEG
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: EMPTY
40853: LIST
40854: LIST
40855: LIST
40856: LIST
40857: LIST
40858: LIST
40859: LIST
40860: LIST
40861: LIST
40862: LIST
40863: LIST
40864: LIST
40865: LIST
40866: LIST
40867: LIST
40868: LIST
40869: LIST
40870: LIST
40871: LIST
40872: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40873: LD_ADDR_VAR 0 59
40877: PUSH
40878: LD_INT 0
40880: PUSH
40881: LD_INT 0
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: LD_INT 0
40890: PUSH
40891: LD_INT 1
40893: NEG
40894: PUSH
40895: EMPTY
40896: LIST
40897: LIST
40898: PUSH
40899: LD_INT 1
40901: PUSH
40902: LD_INT 0
40904: PUSH
40905: EMPTY
40906: LIST
40907: LIST
40908: PUSH
40909: LD_INT 1
40911: PUSH
40912: LD_INT 1
40914: PUSH
40915: EMPTY
40916: LIST
40917: LIST
40918: PUSH
40919: LD_INT 0
40921: PUSH
40922: LD_INT 1
40924: PUSH
40925: EMPTY
40926: LIST
40927: LIST
40928: PUSH
40929: LD_INT 1
40931: NEG
40932: PUSH
40933: LD_INT 0
40935: PUSH
40936: EMPTY
40937: LIST
40938: LIST
40939: PUSH
40940: LD_INT 1
40942: NEG
40943: PUSH
40944: LD_INT 1
40946: NEG
40947: PUSH
40948: EMPTY
40949: LIST
40950: LIST
40951: PUSH
40952: EMPTY
40953: LIST
40954: LIST
40955: LIST
40956: LIST
40957: LIST
40958: LIST
40959: LIST
40960: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40961: LD_ADDR_VAR 0 60
40965: PUSH
40966: LD_INT 0
40968: PUSH
40969: LD_INT 0
40971: PUSH
40972: EMPTY
40973: LIST
40974: LIST
40975: PUSH
40976: LD_INT 0
40978: PUSH
40979: LD_INT 1
40981: NEG
40982: PUSH
40983: EMPTY
40984: LIST
40985: LIST
40986: PUSH
40987: LD_INT 1
40989: PUSH
40990: LD_INT 0
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PUSH
40997: LD_INT 1
40999: PUSH
41000: LD_INT 1
41002: PUSH
41003: EMPTY
41004: LIST
41005: LIST
41006: PUSH
41007: LD_INT 0
41009: PUSH
41010: LD_INT 1
41012: PUSH
41013: EMPTY
41014: LIST
41015: LIST
41016: PUSH
41017: LD_INT 1
41019: NEG
41020: PUSH
41021: LD_INT 0
41023: PUSH
41024: EMPTY
41025: LIST
41026: LIST
41027: PUSH
41028: LD_INT 1
41030: NEG
41031: PUSH
41032: LD_INT 1
41034: NEG
41035: PUSH
41036: EMPTY
41037: LIST
41038: LIST
41039: PUSH
41040: EMPTY
41041: LIST
41042: LIST
41043: LIST
41044: LIST
41045: LIST
41046: LIST
41047: LIST
41048: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41049: LD_ADDR_VAR 0 61
41053: PUSH
41054: LD_INT 0
41056: PUSH
41057: LD_INT 0
41059: PUSH
41060: EMPTY
41061: LIST
41062: LIST
41063: PUSH
41064: LD_INT 0
41066: PUSH
41067: LD_INT 1
41069: NEG
41070: PUSH
41071: EMPTY
41072: LIST
41073: LIST
41074: PUSH
41075: LD_INT 1
41077: PUSH
41078: LD_INT 0
41080: PUSH
41081: EMPTY
41082: LIST
41083: LIST
41084: PUSH
41085: LD_INT 1
41087: PUSH
41088: LD_INT 1
41090: PUSH
41091: EMPTY
41092: LIST
41093: LIST
41094: PUSH
41095: LD_INT 0
41097: PUSH
41098: LD_INT 1
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: PUSH
41105: LD_INT 1
41107: NEG
41108: PUSH
41109: LD_INT 0
41111: PUSH
41112: EMPTY
41113: LIST
41114: LIST
41115: PUSH
41116: LD_INT 1
41118: NEG
41119: PUSH
41120: LD_INT 1
41122: NEG
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: LIST
41132: LIST
41133: LIST
41134: LIST
41135: LIST
41136: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41137: LD_ADDR_VAR 0 62
41141: PUSH
41142: LD_INT 0
41144: PUSH
41145: LD_INT 0
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 0
41154: PUSH
41155: LD_INT 1
41157: NEG
41158: PUSH
41159: EMPTY
41160: LIST
41161: LIST
41162: PUSH
41163: LD_INT 1
41165: PUSH
41166: LD_INT 0
41168: PUSH
41169: EMPTY
41170: LIST
41171: LIST
41172: PUSH
41173: LD_INT 1
41175: PUSH
41176: LD_INT 1
41178: PUSH
41179: EMPTY
41180: LIST
41181: LIST
41182: PUSH
41183: LD_INT 0
41185: PUSH
41186: LD_INT 1
41188: PUSH
41189: EMPTY
41190: LIST
41191: LIST
41192: PUSH
41193: LD_INT 1
41195: NEG
41196: PUSH
41197: LD_INT 0
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: PUSH
41204: LD_INT 1
41206: NEG
41207: PUSH
41208: LD_INT 1
41210: NEG
41211: PUSH
41212: EMPTY
41213: LIST
41214: LIST
41215: PUSH
41216: EMPTY
41217: LIST
41218: LIST
41219: LIST
41220: LIST
41221: LIST
41222: LIST
41223: LIST
41224: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41225: LD_ADDR_VAR 0 63
41229: PUSH
41230: LD_INT 0
41232: PUSH
41233: LD_INT 0
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: PUSH
41240: LD_INT 0
41242: PUSH
41243: LD_INT 1
41245: NEG
41246: PUSH
41247: EMPTY
41248: LIST
41249: LIST
41250: PUSH
41251: LD_INT 1
41253: PUSH
41254: LD_INT 0
41256: PUSH
41257: EMPTY
41258: LIST
41259: LIST
41260: PUSH
41261: LD_INT 1
41263: PUSH
41264: LD_INT 1
41266: PUSH
41267: EMPTY
41268: LIST
41269: LIST
41270: PUSH
41271: LD_INT 0
41273: PUSH
41274: LD_INT 1
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: PUSH
41281: LD_INT 1
41283: NEG
41284: PUSH
41285: LD_INT 0
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: LD_INT 1
41294: NEG
41295: PUSH
41296: LD_INT 1
41298: NEG
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: PUSH
41304: EMPTY
41305: LIST
41306: LIST
41307: LIST
41308: LIST
41309: LIST
41310: LIST
41311: LIST
41312: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41313: LD_ADDR_VAR 0 64
41317: PUSH
41318: LD_INT 0
41320: PUSH
41321: LD_INT 0
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: PUSH
41328: LD_INT 0
41330: PUSH
41331: LD_INT 1
41333: NEG
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PUSH
41339: LD_INT 1
41341: PUSH
41342: LD_INT 0
41344: PUSH
41345: EMPTY
41346: LIST
41347: LIST
41348: PUSH
41349: LD_INT 1
41351: PUSH
41352: LD_INT 1
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: PUSH
41359: LD_INT 0
41361: PUSH
41362: LD_INT 1
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: LD_INT 1
41371: NEG
41372: PUSH
41373: LD_INT 0
41375: PUSH
41376: EMPTY
41377: LIST
41378: LIST
41379: PUSH
41380: LD_INT 1
41382: NEG
41383: PUSH
41384: LD_INT 1
41386: NEG
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: PUSH
41392: EMPTY
41393: LIST
41394: LIST
41395: LIST
41396: LIST
41397: LIST
41398: LIST
41399: LIST
41400: ST_TO_ADDR
// end ; 1 :
41401: GO 47298
41403: LD_INT 1
41405: DOUBLE
41406: EQUAL
41407: IFTRUE 41411
41409: GO 44034
41411: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41412: LD_ADDR_VAR 0 11
41416: PUSH
41417: LD_INT 1
41419: NEG
41420: PUSH
41421: LD_INT 3
41423: NEG
41424: PUSH
41425: EMPTY
41426: LIST
41427: LIST
41428: PUSH
41429: LD_INT 0
41431: PUSH
41432: LD_INT 3
41434: NEG
41435: PUSH
41436: EMPTY
41437: LIST
41438: LIST
41439: PUSH
41440: LD_INT 1
41442: PUSH
41443: LD_INT 2
41445: NEG
41446: PUSH
41447: EMPTY
41448: LIST
41449: LIST
41450: PUSH
41451: EMPTY
41452: LIST
41453: LIST
41454: LIST
41455: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41456: LD_ADDR_VAR 0 12
41460: PUSH
41461: LD_INT 2
41463: PUSH
41464: LD_INT 1
41466: NEG
41467: PUSH
41468: EMPTY
41469: LIST
41470: LIST
41471: PUSH
41472: LD_INT 3
41474: PUSH
41475: LD_INT 0
41477: PUSH
41478: EMPTY
41479: LIST
41480: LIST
41481: PUSH
41482: LD_INT 3
41484: PUSH
41485: LD_INT 1
41487: PUSH
41488: EMPTY
41489: LIST
41490: LIST
41491: PUSH
41492: EMPTY
41493: LIST
41494: LIST
41495: LIST
41496: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41497: LD_ADDR_VAR 0 13
41501: PUSH
41502: LD_INT 3
41504: PUSH
41505: LD_INT 2
41507: PUSH
41508: EMPTY
41509: LIST
41510: LIST
41511: PUSH
41512: LD_INT 3
41514: PUSH
41515: LD_INT 3
41517: PUSH
41518: EMPTY
41519: LIST
41520: LIST
41521: PUSH
41522: LD_INT 2
41524: PUSH
41525: LD_INT 3
41527: PUSH
41528: EMPTY
41529: LIST
41530: LIST
41531: PUSH
41532: EMPTY
41533: LIST
41534: LIST
41535: LIST
41536: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41537: LD_ADDR_VAR 0 14
41541: PUSH
41542: LD_INT 1
41544: PUSH
41545: LD_INT 3
41547: PUSH
41548: EMPTY
41549: LIST
41550: LIST
41551: PUSH
41552: LD_INT 0
41554: PUSH
41555: LD_INT 3
41557: PUSH
41558: EMPTY
41559: LIST
41560: LIST
41561: PUSH
41562: LD_INT 1
41564: NEG
41565: PUSH
41566: LD_INT 2
41568: PUSH
41569: EMPTY
41570: LIST
41571: LIST
41572: PUSH
41573: EMPTY
41574: LIST
41575: LIST
41576: LIST
41577: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41578: LD_ADDR_VAR 0 15
41582: PUSH
41583: LD_INT 2
41585: NEG
41586: PUSH
41587: LD_INT 1
41589: PUSH
41590: EMPTY
41591: LIST
41592: LIST
41593: PUSH
41594: LD_INT 3
41596: NEG
41597: PUSH
41598: LD_INT 0
41600: PUSH
41601: EMPTY
41602: LIST
41603: LIST
41604: PUSH
41605: LD_INT 3
41607: NEG
41608: PUSH
41609: LD_INT 1
41611: NEG
41612: PUSH
41613: EMPTY
41614: LIST
41615: LIST
41616: PUSH
41617: EMPTY
41618: LIST
41619: LIST
41620: LIST
41621: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41622: LD_ADDR_VAR 0 16
41626: PUSH
41627: LD_INT 2
41629: NEG
41630: PUSH
41631: LD_INT 3
41633: NEG
41634: PUSH
41635: EMPTY
41636: LIST
41637: LIST
41638: PUSH
41639: LD_INT 3
41641: NEG
41642: PUSH
41643: LD_INT 2
41645: NEG
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: PUSH
41651: LD_INT 3
41653: NEG
41654: PUSH
41655: LD_INT 3
41657: NEG
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: PUSH
41663: EMPTY
41664: LIST
41665: LIST
41666: LIST
41667: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41668: LD_ADDR_VAR 0 17
41672: PUSH
41673: LD_INT 1
41675: NEG
41676: PUSH
41677: LD_INT 3
41679: NEG
41680: PUSH
41681: EMPTY
41682: LIST
41683: LIST
41684: PUSH
41685: LD_INT 0
41687: PUSH
41688: LD_INT 3
41690: NEG
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 1
41698: PUSH
41699: LD_INT 2
41701: NEG
41702: PUSH
41703: EMPTY
41704: LIST
41705: LIST
41706: PUSH
41707: EMPTY
41708: LIST
41709: LIST
41710: LIST
41711: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41712: LD_ADDR_VAR 0 18
41716: PUSH
41717: LD_INT 2
41719: PUSH
41720: LD_INT 1
41722: NEG
41723: PUSH
41724: EMPTY
41725: LIST
41726: LIST
41727: PUSH
41728: LD_INT 3
41730: PUSH
41731: LD_INT 0
41733: PUSH
41734: EMPTY
41735: LIST
41736: LIST
41737: PUSH
41738: LD_INT 3
41740: PUSH
41741: LD_INT 1
41743: PUSH
41744: EMPTY
41745: LIST
41746: LIST
41747: PUSH
41748: EMPTY
41749: LIST
41750: LIST
41751: LIST
41752: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41753: LD_ADDR_VAR 0 19
41757: PUSH
41758: LD_INT 3
41760: PUSH
41761: LD_INT 2
41763: PUSH
41764: EMPTY
41765: LIST
41766: LIST
41767: PUSH
41768: LD_INT 3
41770: PUSH
41771: LD_INT 3
41773: PUSH
41774: EMPTY
41775: LIST
41776: LIST
41777: PUSH
41778: LD_INT 2
41780: PUSH
41781: LD_INT 3
41783: PUSH
41784: EMPTY
41785: LIST
41786: LIST
41787: PUSH
41788: EMPTY
41789: LIST
41790: LIST
41791: LIST
41792: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41793: LD_ADDR_VAR 0 20
41797: PUSH
41798: LD_INT 1
41800: PUSH
41801: LD_INT 3
41803: PUSH
41804: EMPTY
41805: LIST
41806: LIST
41807: PUSH
41808: LD_INT 0
41810: PUSH
41811: LD_INT 3
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: PUSH
41818: LD_INT 1
41820: NEG
41821: PUSH
41822: LD_INT 2
41824: PUSH
41825: EMPTY
41826: LIST
41827: LIST
41828: PUSH
41829: EMPTY
41830: LIST
41831: LIST
41832: LIST
41833: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41834: LD_ADDR_VAR 0 21
41838: PUSH
41839: LD_INT 2
41841: NEG
41842: PUSH
41843: LD_INT 1
41845: PUSH
41846: EMPTY
41847: LIST
41848: LIST
41849: PUSH
41850: LD_INT 3
41852: NEG
41853: PUSH
41854: LD_INT 0
41856: PUSH
41857: EMPTY
41858: LIST
41859: LIST
41860: PUSH
41861: LD_INT 3
41863: NEG
41864: PUSH
41865: LD_INT 1
41867: NEG
41868: PUSH
41869: EMPTY
41870: LIST
41871: LIST
41872: PUSH
41873: EMPTY
41874: LIST
41875: LIST
41876: LIST
41877: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41878: LD_ADDR_VAR 0 22
41882: PUSH
41883: LD_INT 2
41885: NEG
41886: PUSH
41887: LD_INT 3
41889: NEG
41890: PUSH
41891: EMPTY
41892: LIST
41893: LIST
41894: PUSH
41895: LD_INT 3
41897: NEG
41898: PUSH
41899: LD_INT 2
41901: NEG
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: PUSH
41907: LD_INT 3
41909: NEG
41910: PUSH
41911: LD_INT 3
41913: NEG
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PUSH
41919: EMPTY
41920: LIST
41921: LIST
41922: LIST
41923: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41924: LD_ADDR_VAR 0 23
41928: PUSH
41929: LD_INT 0
41931: PUSH
41932: LD_INT 3
41934: NEG
41935: PUSH
41936: EMPTY
41937: LIST
41938: LIST
41939: PUSH
41940: LD_INT 1
41942: NEG
41943: PUSH
41944: LD_INT 4
41946: NEG
41947: PUSH
41948: EMPTY
41949: LIST
41950: LIST
41951: PUSH
41952: LD_INT 1
41954: PUSH
41955: LD_INT 3
41957: NEG
41958: PUSH
41959: EMPTY
41960: LIST
41961: LIST
41962: PUSH
41963: EMPTY
41964: LIST
41965: LIST
41966: LIST
41967: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41968: LD_ADDR_VAR 0 24
41972: PUSH
41973: LD_INT 3
41975: PUSH
41976: LD_INT 0
41978: PUSH
41979: EMPTY
41980: LIST
41981: LIST
41982: PUSH
41983: LD_INT 3
41985: PUSH
41986: LD_INT 1
41988: NEG
41989: PUSH
41990: EMPTY
41991: LIST
41992: LIST
41993: PUSH
41994: LD_INT 4
41996: PUSH
41997: LD_INT 1
41999: PUSH
42000: EMPTY
42001: LIST
42002: LIST
42003: PUSH
42004: EMPTY
42005: LIST
42006: LIST
42007: LIST
42008: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
42009: LD_ADDR_VAR 0 25
42013: PUSH
42014: LD_INT 3
42016: PUSH
42017: LD_INT 3
42019: PUSH
42020: EMPTY
42021: LIST
42022: LIST
42023: PUSH
42024: LD_INT 4
42026: PUSH
42027: LD_INT 3
42029: PUSH
42030: EMPTY
42031: LIST
42032: LIST
42033: PUSH
42034: LD_INT 3
42036: PUSH
42037: LD_INT 4
42039: PUSH
42040: EMPTY
42041: LIST
42042: LIST
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: LIST
42048: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
42049: LD_ADDR_VAR 0 26
42053: PUSH
42054: LD_INT 0
42056: PUSH
42057: LD_INT 3
42059: PUSH
42060: EMPTY
42061: LIST
42062: LIST
42063: PUSH
42064: LD_INT 1
42066: PUSH
42067: LD_INT 4
42069: PUSH
42070: EMPTY
42071: LIST
42072: LIST
42073: PUSH
42074: LD_INT 1
42076: NEG
42077: PUSH
42078: LD_INT 3
42080: PUSH
42081: EMPTY
42082: LIST
42083: LIST
42084: PUSH
42085: EMPTY
42086: LIST
42087: LIST
42088: LIST
42089: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
42090: LD_ADDR_VAR 0 27
42094: PUSH
42095: LD_INT 3
42097: NEG
42098: PUSH
42099: LD_INT 0
42101: PUSH
42102: EMPTY
42103: LIST
42104: LIST
42105: PUSH
42106: LD_INT 3
42108: NEG
42109: PUSH
42110: LD_INT 1
42112: PUSH
42113: EMPTY
42114: LIST
42115: LIST
42116: PUSH
42117: LD_INT 4
42119: NEG
42120: PUSH
42121: LD_INT 1
42123: NEG
42124: PUSH
42125: EMPTY
42126: LIST
42127: LIST
42128: PUSH
42129: EMPTY
42130: LIST
42131: LIST
42132: LIST
42133: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
42134: LD_ADDR_VAR 0 28
42138: PUSH
42139: LD_INT 3
42141: NEG
42142: PUSH
42143: LD_INT 3
42145: NEG
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: LD_INT 3
42153: NEG
42154: PUSH
42155: LD_INT 4
42157: NEG
42158: PUSH
42159: EMPTY
42160: LIST
42161: LIST
42162: PUSH
42163: LD_INT 4
42165: NEG
42166: PUSH
42167: LD_INT 3
42169: NEG
42170: PUSH
42171: EMPTY
42172: LIST
42173: LIST
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: LIST
42179: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
42180: LD_ADDR_VAR 0 29
42184: PUSH
42185: LD_INT 1
42187: NEG
42188: PUSH
42189: LD_INT 3
42191: NEG
42192: PUSH
42193: EMPTY
42194: LIST
42195: LIST
42196: PUSH
42197: LD_INT 0
42199: PUSH
42200: LD_INT 3
42202: NEG
42203: PUSH
42204: EMPTY
42205: LIST
42206: LIST
42207: PUSH
42208: LD_INT 1
42210: PUSH
42211: LD_INT 2
42213: NEG
42214: PUSH
42215: EMPTY
42216: LIST
42217: LIST
42218: PUSH
42219: LD_INT 1
42221: NEG
42222: PUSH
42223: LD_INT 4
42225: NEG
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: LD_INT 0
42233: PUSH
42234: LD_INT 4
42236: NEG
42237: PUSH
42238: EMPTY
42239: LIST
42240: LIST
42241: PUSH
42242: LD_INT 1
42244: PUSH
42245: LD_INT 3
42247: NEG
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: PUSH
42253: LD_INT 1
42255: NEG
42256: PUSH
42257: LD_INT 5
42259: NEG
42260: PUSH
42261: EMPTY
42262: LIST
42263: LIST
42264: PUSH
42265: LD_INT 0
42267: PUSH
42268: LD_INT 5
42270: NEG
42271: PUSH
42272: EMPTY
42273: LIST
42274: LIST
42275: PUSH
42276: LD_INT 1
42278: PUSH
42279: LD_INT 4
42281: NEG
42282: PUSH
42283: EMPTY
42284: LIST
42285: LIST
42286: PUSH
42287: LD_INT 1
42289: NEG
42290: PUSH
42291: LD_INT 6
42293: NEG
42294: PUSH
42295: EMPTY
42296: LIST
42297: LIST
42298: PUSH
42299: LD_INT 0
42301: PUSH
42302: LD_INT 6
42304: NEG
42305: PUSH
42306: EMPTY
42307: LIST
42308: LIST
42309: PUSH
42310: LD_INT 1
42312: PUSH
42313: LD_INT 5
42315: NEG
42316: PUSH
42317: EMPTY
42318: LIST
42319: LIST
42320: PUSH
42321: EMPTY
42322: LIST
42323: LIST
42324: LIST
42325: LIST
42326: LIST
42327: LIST
42328: LIST
42329: LIST
42330: LIST
42331: LIST
42332: LIST
42333: LIST
42334: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
42335: LD_ADDR_VAR 0 30
42339: PUSH
42340: LD_INT 2
42342: PUSH
42343: LD_INT 1
42345: NEG
42346: PUSH
42347: EMPTY
42348: LIST
42349: LIST
42350: PUSH
42351: LD_INT 3
42353: PUSH
42354: LD_INT 0
42356: PUSH
42357: EMPTY
42358: LIST
42359: LIST
42360: PUSH
42361: LD_INT 3
42363: PUSH
42364: LD_INT 1
42366: PUSH
42367: EMPTY
42368: LIST
42369: LIST
42370: PUSH
42371: LD_INT 3
42373: PUSH
42374: LD_INT 1
42376: NEG
42377: PUSH
42378: EMPTY
42379: LIST
42380: LIST
42381: PUSH
42382: LD_INT 4
42384: PUSH
42385: LD_INT 0
42387: PUSH
42388: EMPTY
42389: LIST
42390: LIST
42391: PUSH
42392: LD_INT 4
42394: PUSH
42395: LD_INT 1
42397: PUSH
42398: EMPTY
42399: LIST
42400: LIST
42401: PUSH
42402: LD_INT 4
42404: PUSH
42405: LD_INT 1
42407: NEG
42408: PUSH
42409: EMPTY
42410: LIST
42411: LIST
42412: PUSH
42413: LD_INT 5
42415: PUSH
42416: LD_INT 0
42418: PUSH
42419: EMPTY
42420: LIST
42421: LIST
42422: PUSH
42423: LD_INT 5
42425: PUSH
42426: LD_INT 1
42428: PUSH
42429: EMPTY
42430: LIST
42431: LIST
42432: PUSH
42433: LD_INT 5
42435: PUSH
42436: LD_INT 1
42438: NEG
42439: PUSH
42440: EMPTY
42441: LIST
42442: LIST
42443: PUSH
42444: LD_INT 6
42446: PUSH
42447: LD_INT 0
42449: PUSH
42450: EMPTY
42451: LIST
42452: LIST
42453: PUSH
42454: LD_INT 6
42456: PUSH
42457: LD_INT 1
42459: PUSH
42460: EMPTY
42461: LIST
42462: LIST
42463: PUSH
42464: EMPTY
42465: LIST
42466: LIST
42467: LIST
42468: LIST
42469: LIST
42470: LIST
42471: LIST
42472: LIST
42473: LIST
42474: LIST
42475: LIST
42476: LIST
42477: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
42478: LD_ADDR_VAR 0 31
42482: PUSH
42483: LD_INT 3
42485: PUSH
42486: LD_INT 2
42488: PUSH
42489: EMPTY
42490: LIST
42491: LIST
42492: PUSH
42493: LD_INT 3
42495: PUSH
42496: LD_INT 3
42498: PUSH
42499: EMPTY
42500: LIST
42501: LIST
42502: PUSH
42503: LD_INT 2
42505: PUSH
42506: LD_INT 3
42508: PUSH
42509: EMPTY
42510: LIST
42511: LIST
42512: PUSH
42513: LD_INT 4
42515: PUSH
42516: LD_INT 3
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: PUSH
42523: LD_INT 4
42525: PUSH
42526: LD_INT 4
42528: PUSH
42529: EMPTY
42530: LIST
42531: LIST
42532: PUSH
42533: LD_INT 3
42535: PUSH
42536: LD_INT 4
42538: PUSH
42539: EMPTY
42540: LIST
42541: LIST
42542: PUSH
42543: LD_INT 5
42545: PUSH
42546: LD_INT 4
42548: PUSH
42549: EMPTY
42550: LIST
42551: LIST
42552: PUSH
42553: LD_INT 5
42555: PUSH
42556: LD_INT 5
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: PUSH
42563: LD_INT 4
42565: PUSH
42566: LD_INT 5
42568: PUSH
42569: EMPTY
42570: LIST
42571: LIST
42572: PUSH
42573: LD_INT 6
42575: PUSH
42576: LD_INT 5
42578: PUSH
42579: EMPTY
42580: LIST
42581: LIST
42582: PUSH
42583: LD_INT 6
42585: PUSH
42586: LD_INT 6
42588: PUSH
42589: EMPTY
42590: LIST
42591: LIST
42592: PUSH
42593: LD_INT 5
42595: PUSH
42596: LD_INT 6
42598: PUSH
42599: EMPTY
42600: LIST
42601: LIST
42602: PUSH
42603: EMPTY
42604: LIST
42605: LIST
42606: LIST
42607: LIST
42608: LIST
42609: LIST
42610: LIST
42611: LIST
42612: LIST
42613: LIST
42614: LIST
42615: LIST
42616: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42617: LD_ADDR_VAR 0 32
42621: PUSH
42622: LD_INT 1
42624: PUSH
42625: LD_INT 3
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: PUSH
42632: LD_INT 0
42634: PUSH
42635: LD_INT 3
42637: PUSH
42638: EMPTY
42639: LIST
42640: LIST
42641: PUSH
42642: LD_INT 1
42644: NEG
42645: PUSH
42646: LD_INT 2
42648: PUSH
42649: EMPTY
42650: LIST
42651: LIST
42652: PUSH
42653: LD_INT 1
42655: PUSH
42656: LD_INT 4
42658: PUSH
42659: EMPTY
42660: LIST
42661: LIST
42662: PUSH
42663: LD_INT 0
42665: PUSH
42666: LD_INT 4
42668: PUSH
42669: EMPTY
42670: LIST
42671: LIST
42672: PUSH
42673: LD_INT 1
42675: NEG
42676: PUSH
42677: LD_INT 3
42679: PUSH
42680: EMPTY
42681: LIST
42682: LIST
42683: PUSH
42684: LD_INT 1
42686: PUSH
42687: LD_INT 5
42689: PUSH
42690: EMPTY
42691: LIST
42692: LIST
42693: PUSH
42694: LD_INT 0
42696: PUSH
42697: LD_INT 5
42699: PUSH
42700: EMPTY
42701: LIST
42702: LIST
42703: PUSH
42704: LD_INT 1
42706: NEG
42707: PUSH
42708: LD_INT 4
42710: PUSH
42711: EMPTY
42712: LIST
42713: LIST
42714: PUSH
42715: LD_INT 1
42717: PUSH
42718: LD_INT 6
42720: PUSH
42721: EMPTY
42722: LIST
42723: LIST
42724: PUSH
42725: LD_INT 0
42727: PUSH
42728: LD_INT 6
42730: PUSH
42731: EMPTY
42732: LIST
42733: LIST
42734: PUSH
42735: LD_INT 1
42737: NEG
42738: PUSH
42739: LD_INT 5
42741: PUSH
42742: EMPTY
42743: LIST
42744: LIST
42745: PUSH
42746: EMPTY
42747: LIST
42748: LIST
42749: LIST
42750: LIST
42751: LIST
42752: LIST
42753: LIST
42754: LIST
42755: LIST
42756: LIST
42757: LIST
42758: LIST
42759: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42760: LD_ADDR_VAR 0 33
42764: PUSH
42765: LD_INT 2
42767: NEG
42768: PUSH
42769: LD_INT 1
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: PUSH
42776: LD_INT 3
42778: NEG
42779: PUSH
42780: LD_INT 0
42782: PUSH
42783: EMPTY
42784: LIST
42785: LIST
42786: PUSH
42787: LD_INT 3
42789: NEG
42790: PUSH
42791: LD_INT 1
42793: NEG
42794: PUSH
42795: EMPTY
42796: LIST
42797: LIST
42798: PUSH
42799: LD_INT 3
42801: NEG
42802: PUSH
42803: LD_INT 1
42805: PUSH
42806: EMPTY
42807: LIST
42808: LIST
42809: PUSH
42810: LD_INT 4
42812: NEG
42813: PUSH
42814: LD_INT 0
42816: PUSH
42817: EMPTY
42818: LIST
42819: LIST
42820: PUSH
42821: LD_INT 4
42823: NEG
42824: PUSH
42825: LD_INT 1
42827: NEG
42828: PUSH
42829: EMPTY
42830: LIST
42831: LIST
42832: PUSH
42833: LD_INT 4
42835: NEG
42836: PUSH
42837: LD_INT 1
42839: PUSH
42840: EMPTY
42841: LIST
42842: LIST
42843: PUSH
42844: LD_INT 5
42846: NEG
42847: PUSH
42848: LD_INT 0
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: LD_INT 5
42857: NEG
42858: PUSH
42859: LD_INT 1
42861: NEG
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: LD_INT 5
42869: NEG
42870: PUSH
42871: LD_INT 1
42873: PUSH
42874: EMPTY
42875: LIST
42876: LIST
42877: PUSH
42878: LD_INT 6
42880: NEG
42881: PUSH
42882: LD_INT 0
42884: PUSH
42885: EMPTY
42886: LIST
42887: LIST
42888: PUSH
42889: LD_INT 6
42891: NEG
42892: PUSH
42893: LD_INT 1
42895: NEG
42896: PUSH
42897: EMPTY
42898: LIST
42899: LIST
42900: PUSH
42901: EMPTY
42902: LIST
42903: LIST
42904: LIST
42905: LIST
42906: LIST
42907: LIST
42908: LIST
42909: LIST
42910: LIST
42911: LIST
42912: LIST
42913: LIST
42914: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42915: LD_ADDR_VAR 0 34
42919: PUSH
42920: LD_INT 2
42922: NEG
42923: PUSH
42924: LD_INT 3
42926: NEG
42927: PUSH
42928: EMPTY
42929: LIST
42930: LIST
42931: PUSH
42932: LD_INT 3
42934: NEG
42935: PUSH
42936: LD_INT 2
42938: NEG
42939: PUSH
42940: EMPTY
42941: LIST
42942: LIST
42943: PUSH
42944: LD_INT 3
42946: NEG
42947: PUSH
42948: LD_INT 3
42950: NEG
42951: PUSH
42952: EMPTY
42953: LIST
42954: LIST
42955: PUSH
42956: LD_INT 3
42958: NEG
42959: PUSH
42960: LD_INT 4
42962: NEG
42963: PUSH
42964: EMPTY
42965: LIST
42966: LIST
42967: PUSH
42968: LD_INT 4
42970: NEG
42971: PUSH
42972: LD_INT 3
42974: NEG
42975: PUSH
42976: EMPTY
42977: LIST
42978: LIST
42979: PUSH
42980: LD_INT 4
42982: NEG
42983: PUSH
42984: LD_INT 4
42986: NEG
42987: PUSH
42988: EMPTY
42989: LIST
42990: LIST
42991: PUSH
42992: LD_INT 4
42994: NEG
42995: PUSH
42996: LD_INT 5
42998: NEG
42999: PUSH
43000: EMPTY
43001: LIST
43002: LIST
43003: PUSH
43004: LD_INT 5
43006: NEG
43007: PUSH
43008: LD_INT 4
43010: NEG
43011: PUSH
43012: EMPTY
43013: LIST
43014: LIST
43015: PUSH
43016: LD_INT 5
43018: NEG
43019: PUSH
43020: LD_INT 5
43022: NEG
43023: PUSH
43024: EMPTY
43025: LIST
43026: LIST
43027: PUSH
43028: LD_INT 5
43030: NEG
43031: PUSH
43032: LD_INT 6
43034: NEG
43035: PUSH
43036: EMPTY
43037: LIST
43038: LIST
43039: PUSH
43040: LD_INT 6
43042: NEG
43043: PUSH
43044: LD_INT 5
43046: NEG
43047: PUSH
43048: EMPTY
43049: LIST
43050: LIST
43051: PUSH
43052: LD_INT 6
43054: NEG
43055: PUSH
43056: LD_INT 6
43058: NEG
43059: PUSH
43060: EMPTY
43061: LIST
43062: LIST
43063: PUSH
43064: EMPTY
43065: LIST
43066: LIST
43067: LIST
43068: LIST
43069: LIST
43070: LIST
43071: LIST
43072: LIST
43073: LIST
43074: LIST
43075: LIST
43076: LIST
43077: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
43078: LD_ADDR_VAR 0 41
43082: PUSH
43083: LD_INT 0
43085: PUSH
43086: LD_INT 2
43088: NEG
43089: PUSH
43090: EMPTY
43091: LIST
43092: LIST
43093: PUSH
43094: LD_INT 1
43096: NEG
43097: PUSH
43098: LD_INT 3
43100: NEG
43101: PUSH
43102: EMPTY
43103: LIST
43104: LIST
43105: PUSH
43106: LD_INT 1
43108: PUSH
43109: LD_INT 2
43111: NEG
43112: PUSH
43113: EMPTY
43114: LIST
43115: LIST
43116: PUSH
43117: EMPTY
43118: LIST
43119: LIST
43120: LIST
43121: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
43122: LD_ADDR_VAR 0 42
43126: PUSH
43127: LD_INT 2
43129: PUSH
43130: LD_INT 0
43132: PUSH
43133: EMPTY
43134: LIST
43135: LIST
43136: PUSH
43137: LD_INT 2
43139: PUSH
43140: LD_INT 1
43142: NEG
43143: PUSH
43144: EMPTY
43145: LIST
43146: LIST
43147: PUSH
43148: LD_INT 3
43150: PUSH
43151: LD_INT 1
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: PUSH
43158: EMPTY
43159: LIST
43160: LIST
43161: LIST
43162: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
43163: LD_ADDR_VAR 0 43
43167: PUSH
43168: LD_INT 2
43170: PUSH
43171: LD_INT 2
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: PUSH
43178: LD_INT 3
43180: PUSH
43181: LD_INT 2
43183: PUSH
43184: EMPTY
43185: LIST
43186: LIST
43187: PUSH
43188: LD_INT 2
43190: PUSH
43191: LD_INT 3
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: PUSH
43198: EMPTY
43199: LIST
43200: LIST
43201: LIST
43202: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
43203: LD_ADDR_VAR 0 44
43207: PUSH
43208: LD_INT 0
43210: PUSH
43211: LD_INT 2
43213: PUSH
43214: EMPTY
43215: LIST
43216: LIST
43217: PUSH
43218: LD_INT 1
43220: PUSH
43221: LD_INT 3
43223: PUSH
43224: EMPTY
43225: LIST
43226: LIST
43227: PUSH
43228: LD_INT 1
43230: NEG
43231: PUSH
43232: LD_INT 2
43234: PUSH
43235: EMPTY
43236: LIST
43237: LIST
43238: PUSH
43239: EMPTY
43240: LIST
43241: LIST
43242: LIST
43243: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
43244: LD_ADDR_VAR 0 45
43248: PUSH
43249: LD_INT 2
43251: NEG
43252: PUSH
43253: LD_INT 0
43255: PUSH
43256: EMPTY
43257: LIST
43258: LIST
43259: PUSH
43260: LD_INT 2
43262: NEG
43263: PUSH
43264: LD_INT 1
43266: PUSH
43267: EMPTY
43268: LIST
43269: LIST
43270: PUSH
43271: LD_INT 3
43273: NEG
43274: PUSH
43275: LD_INT 1
43277: NEG
43278: PUSH
43279: EMPTY
43280: LIST
43281: LIST
43282: PUSH
43283: EMPTY
43284: LIST
43285: LIST
43286: LIST
43287: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
43288: LD_ADDR_VAR 0 46
43292: PUSH
43293: LD_INT 2
43295: NEG
43296: PUSH
43297: LD_INT 2
43299: NEG
43300: PUSH
43301: EMPTY
43302: LIST
43303: LIST
43304: PUSH
43305: LD_INT 2
43307: NEG
43308: PUSH
43309: LD_INT 3
43311: NEG
43312: PUSH
43313: EMPTY
43314: LIST
43315: LIST
43316: PUSH
43317: LD_INT 3
43319: NEG
43320: PUSH
43321: LD_INT 2
43323: NEG
43324: PUSH
43325: EMPTY
43326: LIST
43327: LIST
43328: PUSH
43329: EMPTY
43330: LIST
43331: LIST
43332: LIST
43333: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
43334: LD_ADDR_VAR 0 47
43338: PUSH
43339: LD_INT 2
43341: NEG
43342: PUSH
43343: LD_INT 3
43345: NEG
43346: PUSH
43347: EMPTY
43348: LIST
43349: LIST
43350: PUSH
43351: LD_INT 1
43353: NEG
43354: PUSH
43355: LD_INT 3
43357: NEG
43358: PUSH
43359: EMPTY
43360: LIST
43361: LIST
43362: PUSH
43363: EMPTY
43364: LIST
43365: LIST
43366: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
43367: LD_ADDR_VAR 0 48
43371: PUSH
43372: LD_INT 1
43374: PUSH
43375: LD_INT 2
43377: NEG
43378: PUSH
43379: EMPTY
43380: LIST
43381: LIST
43382: PUSH
43383: LD_INT 2
43385: PUSH
43386: LD_INT 1
43388: NEG
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
43398: LD_ADDR_VAR 0 49
43402: PUSH
43403: LD_INT 3
43405: PUSH
43406: LD_INT 1
43408: PUSH
43409: EMPTY
43410: LIST
43411: LIST
43412: PUSH
43413: LD_INT 3
43415: PUSH
43416: LD_INT 2
43418: PUSH
43419: EMPTY
43420: LIST
43421: LIST
43422: PUSH
43423: EMPTY
43424: LIST
43425: LIST
43426: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
43427: LD_ADDR_VAR 0 50
43431: PUSH
43432: LD_INT 2
43434: PUSH
43435: LD_INT 3
43437: PUSH
43438: EMPTY
43439: LIST
43440: LIST
43441: PUSH
43442: LD_INT 1
43444: PUSH
43445: LD_INT 3
43447: PUSH
43448: EMPTY
43449: LIST
43450: LIST
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
43456: LD_ADDR_VAR 0 51
43460: PUSH
43461: LD_INT 1
43463: NEG
43464: PUSH
43465: LD_INT 2
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: LD_INT 2
43474: NEG
43475: PUSH
43476: LD_INT 1
43478: PUSH
43479: EMPTY
43480: LIST
43481: LIST
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
43487: LD_ADDR_VAR 0 52
43491: PUSH
43492: LD_INT 3
43494: NEG
43495: PUSH
43496: LD_INT 1
43498: NEG
43499: PUSH
43500: EMPTY
43501: LIST
43502: LIST
43503: PUSH
43504: LD_INT 3
43506: NEG
43507: PUSH
43508: LD_INT 2
43510: NEG
43511: PUSH
43512: EMPTY
43513: LIST
43514: LIST
43515: PUSH
43516: EMPTY
43517: LIST
43518: LIST
43519: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43520: LD_ADDR_VAR 0 53
43524: PUSH
43525: LD_INT 1
43527: NEG
43528: PUSH
43529: LD_INT 3
43531: NEG
43532: PUSH
43533: EMPTY
43534: LIST
43535: LIST
43536: PUSH
43537: LD_INT 0
43539: PUSH
43540: LD_INT 3
43542: NEG
43543: PUSH
43544: EMPTY
43545: LIST
43546: LIST
43547: PUSH
43548: LD_INT 1
43550: PUSH
43551: LD_INT 2
43553: NEG
43554: PUSH
43555: EMPTY
43556: LIST
43557: LIST
43558: PUSH
43559: EMPTY
43560: LIST
43561: LIST
43562: LIST
43563: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43564: LD_ADDR_VAR 0 54
43568: PUSH
43569: LD_INT 2
43571: PUSH
43572: LD_INT 1
43574: NEG
43575: PUSH
43576: EMPTY
43577: LIST
43578: LIST
43579: PUSH
43580: LD_INT 3
43582: PUSH
43583: LD_INT 0
43585: PUSH
43586: EMPTY
43587: LIST
43588: LIST
43589: PUSH
43590: LD_INT 3
43592: PUSH
43593: LD_INT 1
43595: PUSH
43596: EMPTY
43597: LIST
43598: LIST
43599: PUSH
43600: EMPTY
43601: LIST
43602: LIST
43603: LIST
43604: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43605: LD_ADDR_VAR 0 55
43609: PUSH
43610: LD_INT 3
43612: PUSH
43613: LD_INT 2
43615: PUSH
43616: EMPTY
43617: LIST
43618: LIST
43619: PUSH
43620: LD_INT 3
43622: PUSH
43623: LD_INT 3
43625: PUSH
43626: EMPTY
43627: LIST
43628: LIST
43629: PUSH
43630: LD_INT 2
43632: PUSH
43633: LD_INT 3
43635: PUSH
43636: EMPTY
43637: LIST
43638: LIST
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: LIST
43644: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43645: LD_ADDR_VAR 0 56
43649: PUSH
43650: LD_INT 1
43652: PUSH
43653: LD_INT 3
43655: PUSH
43656: EMPTY
43657: LIST
43658: LIST
43659: PUSH
43660: LD_INT 0
43662: PUSH
43663: LD_INT 3
43665: PUSH
43666: EMPTY
43667: LIST
43668: LIST
43669: PUSH
43670: LD_INT 1
43672: NEG
43673: PUSH
43674: LD_INT 2
43676: PUSH
43677: EMPTY
43678: LIST
43679: LIST
43680: PUSH
43681: EMPTY
43682: LIST
43683: LIST
43684: LIST
43685: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43686: LD_ADDR_VAR 0 57
43690: PUSH
43691: LD_INT 2
43693: NEG
43694: PUSH
43695: LD_INT 1
43697: PUSH
43698: EMPTY
43699: LIST
43700: LIST
43701: PUSH
43702: LD_INT 3
43704: NEG
43705: PUSH
43706: LD_INT 0
43708: PUSH
43709: EMPTY
43710: LIST
43711: LIST
43712: PUSH
43713: LD_INT 3
43715: NEG
43716: PUSH
43717: LD_INT 1
43719: NEG
43720: PUSH
43721: EMPTY
43722: LIST
43723: LIST
43724: PUSH
43725: EMPTY
43726: LIST
43727: LIST
43728: LIST
43729: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43730: LD_ADDR_VAR 0 58
43734: PUSH
43735: LD_INT 2
43737: NEG
43738: PUSH
43739: LD_INT 3
43741: NEG
43742: PUSH
43743: EMPTY
43744: LIST
43745: LIST
43746: PUSH
43747: LD_INT 3
43749: NEG
43750: PUSH
43751: LD_INT 2
43753: NEG
43754: PUSH
43755: EMPTY
43756: LIST
43757: LIST
43758: PUSH
43759: LD_INT 3
43761: NEG
43762: PUSH
43763: LD_INT 3
43765: NEG
43766: PUSH
43767: EMPTY
43768: LIST
43769: LIST
43770: PUSH
43771: EMPTY
43772: LIST
43773: LIST
43774: LIST
43775: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43776: LD_ADDR_VAR 0 59
43780: PUSH
43781: LD_INT 1
43783: NEG
43784: PUSH
43785: LD_INT 2
43787: NEG
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PUSH
43793: LD_INT 0
43795: PUSH
43796: LD_INT 2
43798: NEG
43799: PUSH
43800: EMPTY
43801: LIST
43802: LIST
43803: PUSH
43804: LD_INT 1
43806: PUSH
43807: LD_INT 1
43809: NEG
43810: PUSH
43811: EMPTY
43812: LIST
43813: LIST
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: LIST
43819: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43820: LD_ADDR_VAR 0 60
43824: PUSH
43825: LD_INT 1
43827: PUSH
43828: LD_INT 1
43830: NEG
43831: PUSH
43832: EMPTY
43833: LIST
43834: LIST
43835: PUSH
43836: LD_INT 2
43838: PUSH
43839: LD_INT 0
43841: PUSH
43842: EMPTY
43843: LIST
43844: LIST
43845: PUSH
43846: LD_INT 2
43848: PUSH
43849: LD_INT 1
43851: PUSH
43852: EMPTY
43853: LIST
43854: LIST
43855: PUSH
43856: EMPTY
43857: LIST
43858: LIST
43859: LIST
43860: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43861: LD_ADDR_VAR 0 61
43865: PUSH
43866: LD_INT 2
43868: PUSH
43869: LD_INT 1
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: PUSH
43876: LD_INT 2
43878: PUSH
43879: LD_INT 2
43881: PUSH
43882: EMPTY
43883: LIST
43884: LIST
43885: PUSH
43886: LD_INT 1
43888: PUSH
43889: LD_INT 2
43891: PUSH
43892: EMPTY
43893: LIST
43894: LIST
43895: PUSH
43896: EMPTY
43897: LIST
43898: LIST
43899: LIST
43900: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43901: LD_ADDR_VAR 0 62
43905: PUSH
43906: LD_INT 1
43908: PUSH
43909: LD_INT 2
43911: PUSH
43912: EMPTY
43913: LIST
43914: LIST
43915: PUSH
43916: LD_INT 0
43918: PUSH
43919: LD_INT 2
43921: PUSH
43922: EMPTY
43923: LIST
43924: LIST
43925: PUSH
43926: LD_INT 1
43928: NEG
43929: PUSH
43930: LD_INT 1
43932: PUSH
43933: EMPTY
43934: LIST
43935: LIST
43936: PUSH
43937: EMPTY
43938: LIST
43939: LIST
43940: LIST
43941: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43942: LD_ADDR_VAR 0 63
43946: PUSH
43947: LD_INT 1
43949: NEG
43950: PUSH
43951: LD_INT 1
43953: PUSH
43954: EMPTY
43955: LIST
43956: LIST
43957: PUSH
43958: LD_INT 2
43960: NEG
43961: PUSH
43962: LD_INT 0
43964: PUSH
43965: EMPTY
43966: LIST
43967: LIST
43968: PUSH
43969: LD_INT 2
43971: NEG
43972: PUSH
43973: LD_INT 1
43975: NEG
43976: PUSH
43977: EMPTY
43978: LIST
43979: LIST
43980: PUSH
43981: EMPTY
43982: LIST
43983: LIST
43984: LIST
43985: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43986: LD_ADDR_VAR 0 64
43990: PUSH
43991: LD_INT 1
43993: NEG
43994: PUSH
43995: LD_INT 2
43997: NEG
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PUSH
44003: LD_INT 2
44005: NEG
44006: PUSH
44007: LD_INT 1
44009: NEG
44010: PUSH
44011: EMPTY
44012: LIST
44013: LIST
44014: PUSH
44015: LD_INT 2
44017: NEG
44018: PUSH
44019: LD_INT 2
44021: NEG
44022: PUSH
44023: EMPTY
44024: LIST
44025: LIST
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: LIST
44031: ST_TO_ADDR
// end ; 2 :
44032: GO 47298
44034: LD_INT 2
44036: DOUBLE
44037: EQUAL
44038: IFTRUE 44042
44040: GO 47297
44042: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
44043: LD_ADDR_VAR 0 29
44047: PUSH
44048: LD_INT 4
44050: PUSH
44051: LD_INT 0
44053: PUSH
44054: EMPTY
44055: LIST
44056: LIST
44057: PUSH
44058: LD_INT 4
44060: PUSH
44061: LD_INT 1
44063: NEG
44064: PUSH
44065: EMPTY
44066: LIST
44067: LIST
44068: PUSH
44069: LD_INT 5
44071: PUSH
44072: LD_INT 0
44074: PUSH
44075: EMPTY
44076: LIST
44077: LIST
44078: PUSH
44079: LD_INT 5
44081: PUSH
44082: LD_INT 1
44084: PUSH
44085: EMPTY
44086: LIST
44087: LIST
44088: PUSH
44089: LD_INT 4
44091: PUSH
44092: LD_INT 1
44094: PUSH
44095: EMPTY
44096: LIST
44097: LIST
44098: PUSH
44099: LD_INT 3
44101: PUSH
44102: LD_INT 0
44104: PUSH
44105: EMPTY
44106: LIST
44107: LIST
44108: PUSH
44109: LD_INT 3
44111: PUSH
44112: LD_INT 1
44114: NEG
44115: PUSH
44116: EMPTY
44117: LIST
44118: LIST
44119: PUSH
44120: LD_INT 3
44122: PUSH
44123: LD_INT 2
44125: NEG
44126: PUSH
44127: EMPTY
44128: LIST
44129: LIST
44130: PUSH
44131: LD_INT 5
44133: PUSH
44134: LD_INT 2
44136: PUSH
44137: EMPTY
44138: LIST
44139: LIST
44140: PUSH
44141: LD_INT 3
44143: PUSH
44144: LD_INT 3
44146: PUSH
44147: EMPTY
44148: LIST
44149: LIST
44150: PUSH
44151: LD_INT 3
44153: PUSH
44154: LD_INT 2
44156: PUSH
44157: EMPTY
44158: LIST
44159: LIST
44160: PUSH
44161: LD_INT 4
44163: PUSH
44164: LD_INT 3
44166: PUSH
44167: EMPTY
44168: LIST
44169: LIST
44170: PUSH
44171: LD_INT 4
44173: PUSH
44174: LD_INT 4
44176: PUSH
44177: EMPTY
44178: LIST
44179: LIST
44180: PUSH
44181: LD_INT 3
44183: PUSH
44184: LD_INT 4
44186: PUSH
44187: EMPTY
44188: LIST
44189: LIST
44190: PUSH
44191: LD_INT 2
44193: PUSH
44194: LD_INT 3
44196: PUSH
44197: EMPTY
44198: LIST
44199: LIST
44200: PUSH
44201: LD_INT 2
44203: PUSH
44204: LD_INT 2
44206: PUSH
44207: EMPTY
44208: LIST
44209: LIST
44210: PUSH
44211: LD_INT 4
44213: PUSH
44214: LD_INT 2
44216: PUSH
44217: EMPTY
44218: LIST
44219: LIST
44220: PUSH
44221: LD_INT 2
44223: PUSH
44224: LD_INT 4
44226: PUSH
44227: EMPTY
44228: LIST
44229: LIST
44230: PUSH
44231: LD_INT 0
44233: PUSH
44234: LD_INT 4
44236: PUSH
44237: EMPTY
44238: LIST
44239: LIST
44240: PUSH
44241: LD_INT 0
44243: PUSH
44244: LD_INT 3
44246: PUSH
44247: EMPTY
44248: LIST
44249: LIST
44250: PUSH
44251: LD_INT 1
44253: PUSH
44254: LD_INT 4
44256: PUSH
44257: EMPTY
44258: LIST
44259: LIST
44260: PUSH
44261: LD_INT 1
44263: PUSH
44264: LD_INT 5
44266: PUSH
44267: EMPTY
44268: LIST
44269: LIST
44270: PUSH
44271: LD_INT 0
44273: PUSH
44274: LD_INT 5
44276: PUSH
44277: EMPTY
44278: LIST
44279: LIST
44280: PUSH
44281: LD_INT 1
44283: NEG
44284: PUSH
44285: LD_INT 4
44287: PUSH
44288: EMPTY
44289: LIST
44290: LIST
44291: PUSH
44292: LD_INT 1
44294: NEG
44295: PUSH
44296: LD_INT 3
44298: PUSH
44299: EMPTY
44300: LIST
44301: LIST
44302: PUSH
44303: LD_INT 2
44305: PUSH
44306: LD_INT 5
44308: PUSH
44309: EMPTY
44310: LIST
44311: LIST
44312: PUSH
44313: LD_INT 2
44315: NEG
44316: PUSH
44317: LD_INT 3
44319: PUSH
44320: EMPTY
44321: LIST
44322: LIST
44323: PUSH
44324: LD_INT 3
44326: NEG
44327: PUSH
44328: LD_INT 0
44330: PUSH
44331: EMPTY
44332: LIST
44333: LIST
44334: PUSH
44335: LD_INT 3
44337: NEG
44338: PUSH
44339: LD_INT 1
44341: NEG
44342: PUSH
44343: EMPTY
44344: LIST
44345: LIST
44346: PUSH
44347: LD_INT 2
44349: NEG
44350: PUSH
44351: LD_INT 0
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 2
44360: NEG
44361: PUSH
44362: LD_INT 1
44364: PUSH
44365: EMPTY
44366: LIST
44367: LIST
44368: PUSH
44369: LD_INT 3
44371: NEG
44372: PUSH
44373: LD_INT 1
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: PUSH
44380: LD_INT 4
44382: NEG
44383: PUSH
44384: LD_INT 0
44386: PUSH
44387: EMPTY
44388: LIST
44389: LIST
44390: PUSH
44391: LD_INT 4
44393: NEG
44394: PUSH
44395: LD_INT 1
44397: NEG
44398: PUSH
44399: EMPTY
44400: LIST
44401: LIST
44402: PUSH
44403: LD_INT 4
44405: NEG
44406: PUSH
44407: LD_INT 2
44409: NEG
44410: PUSH
44411: EMPTY
44412: LIST
44413: LIST
44414: PUSH
44415: LD_INT 2
44417: NEG
44418: PUSH
44419: LD_INT 2
44421: PUSH
44422: EMPTY
44423: LIST
44424: LIST
44425: PUSH
44426: LD_INT 4
44428: NEG
44429: PUSH
44430: LD_INT 4
44432: NEG
44433: PUSH
44434: EMPTY
44435: LIST
44436: LIST
44437: PUSH
44438: LD_INT 4
44440: NEG
44441: PUSH
44442: LD_INT 5
44444: NEG
44445: PUSH
44446: EMPTY
44447: LIST
44448: LIST
44449: PUSH
44450: LD_INT 3
44452: NEG
44453: PUSH
44454: LD_INT 4
44456: NEG
44457: PUSH
44458: EMPTY
44459: LIST
44460: LIST
44461: PUSH
44462: LD_INT 3
44464: NEG
44465: PUSH
44466: LD_INT 3
44468: NEG
44469: PUSH
44470: EMPTY
44471: LIST
44472: LIST
44473: PUSH
44474: LD_INT 4
44476: NEG
44477: PUSH
44478: LD_INT 3
44480: NEG
44481: PUSH
44482: EMPTY
44483: LIST
44484: LIST
44485: PUSH
44486: LD_INT 5
44488: NEG
44489: PUSH
44490: LD_INT 4
44492: NEG
44493: PUSH
44494: EMPTY
44495: LIST
44496: LIST
44497: PUSH
44498: LD_INT 5
44500: NEG
44501: PUSH
44502: LD_INT 5
44504: NEG
44505: PUSH
44506: EMPTY
44507: LIST
44508: LIST
44509: PUSH
44510: LD_INT 3
44512: NEG
44513: PUSH
44514: LD_INT 5
44516: NEG
44517: PUSH
44518: EMPTY
44519: LIST
44520: LIST
44521: PUSH
44522: LD_INT 5
44524: NEG
44525: PUSH
44526: LD_INT 3
44528: NEG
44529: PUSH
44530: EMPTY
44531: LIST
44532: LIST
44533: PUSH
44534: EMPTY
44535: LIST
44536: LIST
44537: LIST
44538: LIST
44539: LIST
44540: LIST
44541: LIST
44542: LIST
44543: LIST
44544: LIST
44545: LIST
44546: LIST
44547: LIST
44548: LIST
44549: LIST
44550: LIST
44551: LIST
44552: LIST
44553: LIST
44554: LIST
44555: LIST
44556: LIST
44557: LIST
44558: LIST
44559: LIST
44560: LIST
44561: LIST
44562: LIST
44563: LIST
44564: LIST
44565: LIST
44566: LIST
44567: LIST
44568: LIST
44569: LIST
44570: LIST
44571: LIST
44572: LIST
44573: LIST
44574: LIST
44575: LIST
44576: LIST
44577: LIST
44578: LIST
44579: LIST
44580: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
44581: LD_ADDR_VAR 0 30
44585: PUSH
44586: LD_INT 4
44588: PUSH
44589: LD_INT 4
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: PUSH
44596: LD_INT 4
44598: PUSH
44599: LD_INT 3
44601: PUSH
44602: EMPTY
44603: LIST
44604: LIST
44605: PUSH
44606: LD_INT 5
44608: PUSH
44609: LD_INT 4
44611: PUSH
44612: EMPTY
44613: LIST
44614: LIST
44615: PUSH
44616: LD_INT 5
44618: PUSH
44619: LD_INT 5
44621: PUSH
44622: EMPTY
44623: LIST
44624: LIST
44625: PUSH
44626: LD_INT 4
44628: PUSH
44629: LD_INT 5
44631: PUSH
44632: EMPTY
44633: LIST
44634: LIST
44635: PUSH
44636: LD_INT 3
44638: PUSH
44639: LD_INT 4
44641: PUSH
44642: EMPTY
44643: LIST
44644: LIST
44645: PUSH
44646: LD_INT 3
44648: PUSH
44649: LD_INT 3
44651: PUSH
44652: EMPTY
44653: LIST
44654: LIST
44655: PUSH
44656: LD_INT 5
44658: PUSH
44659: LD_INT 3
44661: PUSH
44662: EMPTY
44663: LIST
44664: LIST
44665: PUSH
44666: LD_INT 3
44668: PUSH
44669: LD_INT 5
44671: PUSH
44672: EMPTY
44673: LIST
44674: LIST
44675: PUSH
44676: LD_INT 0
44678: PUSH
44679: LD_INT 3
44681: PUSH
44682: EMPTY
44683: LIST
44684: LIST
44685: PUSH
44686: LD_INT 0
44688: PUSH
44689: LD_INT 2
44691: PUSH
44692: EMPTY
44693: LIST
44694: LIST
44695: PUSH
44696: LD_INT 1
44698: PUSH
44699: LD_INT 3
44701: PUSH
44702: EMPTY
44703: LIST
44704: LIST
44705: PUSH
44706: LD_INT 1
44708: PUSH
44709: LD_INT 4
44711: PUSH
44712: EMPTY
44713: LIST
44714: LIST
44715: PUSH
44716: LD_INT 0
44718: PUSH
44719: LD_INT 4
44721: PUSH
44722: EMPTY
44723: LIST
44724: LIST
44725: PUSH
44726: LD_INT 1
44728: NEG
44729: PUSH
44730: LD_INT 3
44732: PUSH
44733: EMPTY
44734: LIST
44735: LIST
44736: PUSH
44737: LD_INT 1
44739: NEG
44740: PUSH
44741: LD_INT 2
44743: PUSH
44744: EMPTY
44745: LIST
44746: LIST
44747: PUSH
44748: LD_INT 2
44750: PUSH
44751: LD_INT 4
44753: PUSH
44754: EMPTY
44755: LIST
44756: LIST
44757: PUSH
44758: LD_INT 2
44760: NEG
44761: PUSH
44762: LD_INT 2
44764: PUSH
44765: EMPTY
44766: LIST
44767: LIST
44768: PUSH
44769: LD_INT 4
44771: NEG
44772: PUSH
44773: LD_INT 0
44775: PUSH
44776: EMPTY
44777: LIST
44778: LIST
44779: PUSH
44780: LD_INT 4
44782: NEG
44783: PUSH
44784: LD_INT 1
44786: NEG
44787: PUSH
44788: EMPTY
44789: LIST
44790: LIST
44791: PUSH
44792: LD_INT 3
44794: NEG
44795: PUSH
44796: LD_INT 0
44798: PUSH
44799: EMPTY
44800: LIST
44801: LIST
44802: PUSH
44803: LD_INT 3
44805: NEG
44806: PUSH
44807: LD_INT 1
44809: PUSH
44810: EMPTY
44811: LIST
44812: LIST
44813: PUSH
44814: LD_INT 4
44816: NEG
44817: PUSH
44818: LD_INT 1
44820: PUSH
44821: EMPTY
44822: LIST
44823: LIST
44824: PUSH
44825: LD_INT 5
44827: NEG
44828: PUSH
44829: LD_INT 0
44831: PUSH
44832: EMPTY
44833: LIST
44834: LIST
44835: PUSH
44836: LD_INT 5
44838: NEG
44839: PUSH
44840: LD_INT 1
44842: NEG
44843: PUSH
44844: EMPTY
44845: LIST
44846: LIST
44847: PUSH
44848: LD_INT 5
44850: NEG
44851: PUSH
44852: LD_INT 2
44854: NEG
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 3
44862: NEG
44863: PUSH
44864: LD_INT 2
44866: PUSH
44867: EMPTY
44868: LIST
44869: LIST
44870: PUSH
44871: LD_INT 3
44873: NEG
44874: PUSH
44875: LD_INT 3
44877: NEG
44878: PUSH
44879: EMPTY
44880: LIST
44881: LIST
44882: PUSH
44883: LD_INT 3
44885: NEG
44886: PUSH
44887: LD_INT 4
44889: NEG
44890: PUSH
44891: EMPTY
44892: LIST
44893: LIST
44894: PUSH
44895: LD_INT 2
44897: NEG
44898: PUSH
44899: LD_INT 3
44901: NEG
44902: PUSH
44903: EMPTY
44904: LIST
44905: LIST
44906: PUSH
44907: LD_INT 2
44909: NEG
44910: PUSH
44911: LD_INT 2
44913: NEG
44914: PUSH
44915: EMPTY
44916: LIST
44917: LIST
44918: PUSH
44919: LD_INT 3
44921: NEG
44922: PUSH
44923: LD_INT 2
44925: NEG
44926: PUSH
44927: EMPTY
44928: LIST
44929: LIST
44930: PUSH
44931: LD_INT 4
44933: NEG
44934: PUSH
44935: LD_INT 3
44937: NEG
44938: PUSH
44939: EMPTY
44940: LIST
44941: LIST
44942: PUSH
44943: LD_INT 4
44945: NEG
44946: PUSH
44947: LD_INT 4
44949: NEG
44950: PUSH
44951: EMPTY
44952: LIST
44953: LIST
44954: PUSH
44955: LD_INT 2
44957: NEG
44958: PUSH
44959: LD_INT 4
44961: NEG
44962: PUSH
44963: EMPTY
44964: LIST
44965: LIST
44966: PUSH
44967: LD_INT 4
44969: NEG
44970: PUSH
44971: LD_INT 2
44973: NEG
44974: PUSH
44975: EMPTY
44976: LIST
44977: LIST
44978: PUSH
44979: LD_INT 0
44981: PUSH
44982: LD_INT 4
44984: NEG
44985: PUSH
44986: EMPTY
44987: LIST
44988: LIST
44989: PUSH
44990: LD_INT 0
44992: PUSH
44993: LD_INT 5
44995: NEG
44996: PUSH
44997: EMPTY
44998: LIST
44999: LIST
45000: PUSH
45001: LD_INT 1
45003: PUSH
45004: LD_INT 4
45006: NEG
45007: PUSH
45008: EMPTY
45009: LIST
45010: LIST
45011: PUSH
45012: LD_INT 1
45014: PUSH
45015: LD_INT 3
45017: NEG
45018: PUSH
45019: EMPTY
45020: LIST
45021: LIST
45022: PUSH
45023: LD_INT 0
45025: PUSH
45026: LD_INT 3
45028: NEG
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PUSH
45034: LD_INT 1
45036: NEG
45037: PUSH
45038: LD_INT 4
45040: NEG
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: PUSH
45046: LD_INT 1
45048: NEG
45049: PUSH
45050: LD_INT 5
45052: NEG
45053: PUSH
45054: EMPTY
45055: LIST
45056: LIST
45057: PUSH
45058: LD_INT 2
45060: PUSH
45061: LD_INT 3
45063: NEG
45064: PUSH
45065: EMPTY
45066: LIST
45067: LIST
45068: PUSH
45069: LD_INT 2
45071: NEG
45072: PUSH
45073: LD_INT 5
45075: NEG
45076: PUSH
45077: EMPTY
45078: LIST
45079: LIST
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: LIST
45085: LIST
45086: LIST
45087: LIST
45088: LIST
45089: LIST
45090: LIST
45091: LIST
45092: LIST
45093: LIST
45094: LIST
45095: LIST
45096: LIST
45097: LIST
45098: LIST
45099: LIST
45100: LIST
45101: LIST
45102: LIST
45103: LIST
45104: LIST
45105: LIST
45106: LIST
45107: LIST
45108: LIST
45109: LIST
45110: LIST
45111: LIST
45112: LIST
45113: LIST
45114: LIST
45115: LIST
45116: LIST
45117: LIST
45118: LIST
45119: LIST
45120: LIST
45121: LIST
45122: LIST
45123: LIST
45124: LIST
45125: LIST
45126: LIST
45127: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
45128: LD_ADDR_VAR 0 31
45132: PUSH
45133: LD_INT 0
45135: PUSH
45136: LD_INT 4
45138: PUSH
45139: EMPTY
45140: LIST
45141: LIST
45142: PUSH
45143: LD_INT 0
45145: PUSH
45146: LD_INT 3
45148: PUSH
45149: EMPTY
45150: LIST
45151: LIST
45152: PUSH
45153: LD_INT 1
45155: PUSH
45156: LD_INT 4
45158: PUSH
45159: EMPTY
45160: LIST
45161: LIST
45162: PUSH
45163: LD_INT 1
45165: PUSH
45166: LD_INT 5
45168: PUSH
45169: EMPTY
45170: LIST
45171: LIST
45172: PUSH
45173: LD_INT 0
45175: PUSH
45176: LD_INT 5
45178: PUSH
45179: EMPTY
45180: LIST
45181: LIST
45182: PUSH
45183: LD_INT 1
45185: NEG
45186: PUSH
45187: LD_INT 4
45189: PUSH
45190: EMPTY
45191: LIST
45192: LIST
45193: PUSH
45194: LD_INT 1
45196: NEG
45197: PUSH
45198: LD_INT 3
45200: PUSH
45201: EMPTY
45202: LIST
45203: LIST
45204: PUSH
45205: LD_INT 2
45207: PUSH
45208: LD_INT 5
45210: PUSH
45211: EMPTY
45212: LIST
45213: LIST
45214: PUSH
45215: LD_INT 2
45217: NEG
45218: PUSH
45219: LD_INT 3
45221: PUSH
45222: EMPTY
45223: LIST
45224: LIST
45225: PUSH
45226: LD_INT 3
45228: NEG
45229: PUSH
45230: LD_INT 0
45232: PUSH
45233: EMPTY
45234: LIST
45235: LIST
45236: PUSH
45237: LD_INT 3
45239: NEG
45240: PUSH
45241: LD_INT 1
45243: NEG
45244: PUSH
45245: EMPTY
45246: LIST
45247: LIST
45248: PUSH
45249: LD_INT 2
45251: NEG
45252: PUSH
45253: LD_INT 0
45255: PUSH
45256: EMPTY
45257: LIST
45258: LIST
45259: PUSH
45260: LD_INT 2
45262: NEG
45263: PUSH
45264: LD_INT 1
45266: PUSH
45267: EMPTY
45268: LIST
45269: LIST
45270: PUSH
45271: LD_INT 3
45273: NEG
45274: PUSH
45275: LD_INT 1
45277: PUSH
45278: EMPTY
45279: LIST
45280: LIST
45281: PUSH
45282: LD_INT 4
45284: NEG
45285: PUSH
45286: LD_INT 0
45288: PUSH
45289: EMPTY
45290: LIST
45291: LIST
45292: PUSH
45293: LD_INT 4
45295: NEG
45296: PUSH
45297: LD_INT 1
45299: NEG
45300: PUSH
45301: EMPTY
45302: LIST
45303: LIST
45304: PUSH
45305: LD_INT 4
45307: NEG
45308: PUSH
45309: LD_INT 2
45311: NEG
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: PUSH
45317: LD_INT 2
45319: NEG
45320: PUSH
45321: LD_INT 2
45323: PUSH
45324: EMPTY
45325: LIST
45326: LIST
45327: PUSH
45328: LD_INT 4
45330: NEG
45331: PUSH
45332: LD_INT 4
45334: NEG
45335: PUSH
45336: EMPTY
45337: LIST
45338: LIST
45339: PUSH
45340: LD_INT 4
45342: NEG
45343: PUSH
45344: LD_INT 5
45346: NEG
45347: PUSH
45348: EMPTY
45349: LIST
45350: LIST
45351: PUSH
45352: LD_INT 3
45354: NEG
45355: PUSH
45356: LD_INT 4
45358: NEG
45359: PUSH
45360: EMPTY
45361: LIST
45362: LIST
45363: PUSH
45364: LD_INT 3
45366: NEG
45367: PUSH
45368: LD_INT 3
45370: NEG
45371: PUSH
45372: EMPTY
45373: LIST
45374: LIST
45375: PUSH
45376: LD_INT 4
45378: NEG
45379: PUSH
45380: LD_INT 3
45382: NEG
45383: PUSH
45384: EMPTY
45385: LIST
45386: LIST
45387: PUSH
45388: LD_INT 5
45390: NEG
45391: PUSH
45392: LD_INT 4
45394: NEG
45395: PUSH
45396: EMPTY
45397: LIST
45398: LIST
45399: PUSH
45400: LD_INT 5
45402: NEG
45403: PUSH
45404: LD_INT 5
45406: NEG
45407: PUSH
45408: EMPTY
45409: LIST
45410: LIST
45411: PUSH
45412: LD_INT 3
45414: NEG
45415: PUSH
45416: LD_INT 5
45418: NEG
45419: PUSH
45420: EMPTY
45421: LIST
45422: LIST
45423: PUSH
45424: LD_INT 5
45426: NEG
45427: PUSH
45428: LD_INT 3
45430: NEG
45431: PUSH
45432: EMPTY
45433: LIST
45434: LIST
45435: PUSH
45436: LD_INT 0
45438: PUSH
45439: LD_INT 3
45441: NEG
45442: PUSH
45443: EMPTY
45444: LIST
45445: LIST
45446: PUSH
45447: LD_INT 0
45449: PUSH
45450: LD_INT 4
45452: NEG
45453: PUSH
45454: EMPTY
45455: LIST
45456: LIST
45457: PUSH
45458: LD_INT 1
45460: PUSH
45461: LD_INT 3
45463: NEG
45464: PUSH
45465: EMPTY
45466: LIST
45467: LIST
45468: PUSH
45469: LD_INT 1
45471: PUSH
45472: LD_INT 2
45474: NEG
45475: PUSH
45476: EMPTY
45477: LIST
45478: LIST
45479: PUSH
45480: LD_INT 0
45482: PUSH
45483: LD_INT 2
45485: NEG
45486: PUSH
45487: EMPTY
45488: LIST
45489: LIST
45490: PUSH
45491: LD_INT 1
45493: NEG
45494: PUSH
45495: LD_INT 3
45497: NEG
45498: PUSH
45499: EMPTY
45500: LIST
45501: LIST
45502: PUSH
45503: LD_INT 1
45505: NEG
45506: PUSH
45507: LD_INT 4
45509: NEG
45510: PUSH
45511: EMPTY
45512: LIST
45513: LIST
45514: PUSH
45515: LD_INT 2
45517: PUSH
45518: LD_INT 2
45520: NEG
45521: PUSH
45522: EMPTY
45523: LIST
45524: LIST
45525: PUSH
45526: LD_INT 2
45528: NEG
45529: PUSH
45530: LD_INT 4
45532: NEG
45533: PUSH
45534: EMPTY
45535: LIST
45536: LIST
45537: PUSH
45538: LD_INT 4
45540: PUSH
45541: LD_INT 0
45543: PUSH
45544: EMPTY
45545: LIST
45546: LIST
45547: PUSH
45548: LD_INT 4
45550: PUSH
45551: LD_INT 1
45553: NEG
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: PUSH
45559: LD_INT 5
45561: PUSH
45562: LD_INT 0
45564: PUSH
45565: EMPTY
45566: LIST
45567: LIST
45568: PUSH
45569: LD_INT 5
45571: PUSH
45572: LD_INT 1
45574: PUSH
45575: EMPTY
45576: LIST
45577: LIST
45578: PUSH
45579: LD_INT 4
45581: PUSH
45582: LD_INT 1
45584: PUSH
45585: EMPTY
45586: LIST
45587: LIST
45588: PUSH
45589: LD_INT 3
45591: PUSH
45592: LD_INT 0
45594: PUSH
45595: EMPTY
45596: LIST
45597: LIST
45598: PUSH
45599: LD_INT 3
45601: PUSH
45602: LD_INT 1
45604: NEG
45605: PUSH
45606: EMPTY
45607: LIST
45608: LIST
45609: PUSH
45610: LD_INT 3
45612: PUSH
45613: LD_INT 2
45615: NEG
45616: PUSH
45617: EMPTY
45618: LIST
45619: LIST
45620: PUSH
45621: LD_INT 5
45623: PUSH
45624: LD_INT 2
45626: PUSH
45627: EMPTY
45628: LIST
45629: LIST
45630: PUSH
45631: EMPTY
45632: LIST
45633: LIST
45634: LIST
45635: LIST
45636: LIST
45637: LIST
45638: LIST
45639: LIST
45640: LIST
45641: LIST
45642: LIST
45643: LIST
45644: LIST
45645: LIST
45646: LIST
45647: LIST
45648: LIST
45649: LIST
45650: LIST
45651: LIST
45652: LIST
45653: LIST
45654: LIST
45655: LIST
45656: LIST
45657: LIST
45658: LIST
45659: LIST
45660: LIST
45661: LIST
45662: LIST
45663: LIST
45664: LIST
45665: LIST
45666: LIST
45667: LIST
45668: LIST
45669: LIST
45670: LIST
45671: LIST
45672: LIST
45673: LIST
45674: LIST
45675: LIST
45676: LIST
45677: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45678: LD_ADDR_VAR 0 32
45682: PUSH
45683: LD_INT 4
45685: NEG
45686: PUSH
45687: LD_INT 0
45689: PUSH
45690: EMPTY
45691: LIST
45692: LIST
45693: PUSH
45694: LD_INT 4
45696: NEG
45697: PUSH
45698: LD_INT 1
45700: NEG
45701: PUSH
45702: EMPTY
45703: LIST
45704: LIST
45705: PUSH
45706: LD_INT 3
45708: NEG
45709: PUSH
45710: LD_INT 0
45712: PUSH
45713: EMPTY
45714: LIST
45715: LIST
45716: PUSH
45717: LD_INT 3
45719: NEG
45720: PUSH
45721: LD_INT 1
45723: PUSH
45724: EMPTY
45725: LIST
45726: LIST
45727: PUSH
45728: LD_INT 4
45730: NEG
45731: PUSH
45732: LD_INT 1
45734: PUSH
45735: EMPTY
45736: LIST
45737: LIST
45738: PUSH
45739: LD_INT 5
45741: NEG
45742: PUSH
45743: LD_INT 0
45745: PUSH
45746: EMPTY
45747: LIST
45748: LIST
45749: PUSH
45750: LD_INT 5
45752: NEG
45753: PUSH
45754: LD_INT 1
45756: NEG
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PUSH
45762: LD_INT 5
45764: NEG
45765: PUSH
45766: LD_INT 2
45768: NEG
45769: PUSH
45770: EMPTY
45771: LIST
45772: LIST
45773: PUSH
45774: LD_INT 3
45776: NEG
45777: PUSH
45778: LD_INT 2
45780: PUSH
45781: EMPTY
45782: LIST
45783: LIST
45784: PUSH
45785: LD_INT 3
45787: NEG
45788: PUSH
45789: LD_INT 3
45791: NEG
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PUSH
45797: LD_INT 3
45799: NEG
45800: PUSH
45801: LD_INT 4
45803: NEG
45804: PUSH
45805: EMPTY
45806: LIST
45807: LIST
45808: PUSH
45809: LD_INT 2
45811: NEG
45812: PUSH
45813: LD_INT 3
45815: NEG
45816: PUSH
45817: EMPTY
45818: LIST
45819: LIST
45820: PUSH
45821: LD_INT 2
45823: NEG
45824: PUSH
45825: LD_INT 2
45827: NEG
45828: PUSH
45829: EMPTY
45830: LIST
45831: LIST
45832: PUSH
45833: LD_INT 3
45835: NEG
45836: PUSH
45837: LD_INT 2
45839: NEG
45840: PUSH
45841: EMPTY
45842: LIST
45843: LIST
45844: PUSH
45845: LD_INT 4
45847: NEG
45848: PUSH
45849: LD_INT 3
45851: NEG
45852: PUSH
45853: EMPTY
45854: LIST
45855: LIST
45856: PUSH
45857: LD_INT 4
45859: NEG
45860: PUSH
45861: LD_INT 4
45863: NEG
45864: PUSH
45865: EMPTY
45866: LIST
45867: LIST
45868: PUSH
45869: LD_INT 2
45871: NEG
45872: PUSH
45873: LD_INT 4
45875: NEG
45876: PUSH
45877: EMPTY
45878: LIST
45879: LIST
45880: PUSH
45881: LD_INT 4
45883: NEG
45884: PUSH
45885: LD_INT 2
45887: NEG
45888: PUSH
45889: EMPTY
45890: LIST
45891: LIST
45892: PUSH
45893: LD_INT 0
45895: PUSH
45896: LD_INT 4
45898: NEG
45899: PUSH
45900: EMPTY
45901: LIST
45902: LIST
45903: PUSH
45904: LD_INT 0
45906: PUSH
45907: LD_INT 5
45909: NEG
45910: PUSH
45911: EMPTY
45912: LIST
45913: LIST
45914: PUSH
45915: LD_INT 1
45917: PUSH
45918: LD_INT 4
45920: NEG
45921: PUSH
45922: EMPTY
45923: LIST
45924: LIST
45925: PUSH
45926: LD_INT 1
45928: PUSH
45929: LD_INT 3
45931: NEG
45932: PUSH
45933: EMPTY
45934: LIST
45935: LIST
45936: PUSH
45937: LD_INT 0
45939: PUSH
45940: LD_INT 3
45942: NEG
45943: PUSH
45944: EMPTY
45945: LIST
45946: LIST
45947: PUSH
45948: LD_INT 1
45950: NEG
45951: PUSH
45952: LD_INT 4
45954: NEG
45955: PUSH
45956: EMPTY
45957: LIST
45958: LIST
45959: PUSH
45960: LD_INT 1
45962: NEG
45963: PUSH
45964: LD_INT 5
45966: NEG
45967: PUSH
45968: EMPTY
45969: LIST
45970: LIST
45971: PUSH
45972: LD_INT 2
45974: PUSH
45975: LD_INT 3
45977: NEG
45978: PUSH
45979: EMPTY
45980: LIST
45981: LIST
45982: PUSH
45983: LD_INT 2
45985: NEG
45986: PUSH
45987: LD_INT 5
45989: NEG
45990: PUSH
45991: EMPTY
45992: LIST
45993: LIST
45994: PUSH
45995: LD_INT 3
45997: PUSH
45998: LD_INT 0
46000: PUSH
46001: EMPTY
46002: LIST
46003: LIST
46004: PUSH
46005: LD_INT 3
46007: PUSH
46008: LD_INT 1
46010: NEG
46011: PUSH
46012: EMPTY
46013: LIST
46014: LIST
46015: PUSH
46016: LD_INT 4
46018: PUSH
46019: LD_INT 0
46021: PUSH
46022: EMPTY
46023: LIST
46024: LIST
46025: PUSH
46026: LD_INT 4
46028: PUSH
46029: LD_INT 1
46031: PUSH
46032: EMPTY
46033: LIST
46034: LIST
46035: PUSH
46036: LD_INT 3
46038: PUSH
46039: LD_INT 1
46041: PUSH
46042: EMPTY
46043: LIST
46044: LIST
46045: PUSH
46046: LD_INT 2
46048: PUSH
46049: LD_INT 0
46051: PUSH
46052: EMPTY
46053: LIST
46054: LIST
46055: PUSH
46056: LD_INT 2
46058: PUSH
46059: LD_INT 1
46061: NEG
46062: PUSH
46063: EMPTY
46064: LIST
46065: LIST
46066: PUSH
46067: LD_INT 2
46069: PUSH
46070: LD_INT 2
46072: NEG
46073: PUSH
46074: EMPTY
46075: LIST
46076: LIST
46077: PUSH
46078: LD_INT 4
46080: PUSH
46081: LD_INT 2
46083: PUSH
46084: EMPTY
46085: LIST
46086: LIST
46087: PUSH
46088: LD_INT 4
46090: PUSH
46091: LD_INT 4
46093: PUSH
46094: EMPTY
46095: LIST
46096: LIST
46097: PUSH
46098: LD_INT 4
46100: PUSH
46101: LD_INT 3
46103: PUSH
46104: EMPTY
46105: LIST
46106: LIST
46107: PUSH
46108: LD_INT 5
46110: PUSH
46111: LD_INT 4
46113: PUSH
46114: EMPTY
46115: LIST
46116: LIST
46117: PUSH
46118: LD_INT 5
46120: PUSH
46121: LD_INT 5
46123: PUSH
46124: EMPTY
46125: LIST
46126: LIST
46127: PUSH
46128: LD_INT 4
46130: PUSH
46131: LD_INT 5
46133: PUSH
46134: EMPTY
46135: LIST
46136: LIST
46137: PUSH
46138: LD_INT 3
46140: PUSH
46141: LD_INT 4
46143: PUSH
46144: EMPTY
46145: LIST
46146: LIST
46147: PUSH
46148: LD_INT 3
46150: PUSH
46151: LD_INT 3
46153: PUSH
46154: EMPTY
46155: LIST
46156: LIST
46157: PUSH
46158: LD_INT 5
46160: PUSH
46161: LD_INT 3
46163: PUSH
46164: EMPTY
46165: LIST
46166: LIST
46167: PUSH
46168: LD_INT 3
46170: PUSH
46171: LD_INT 5
46173: PUSH
46174: EMPTY
46175: LIST
46176: LIST
46177: PUSH
46178: EMPTY
46179: LIST
46180: LIST
46181: LIST
46182: LIST
46183: LIST
46184: LIST
46185: LIST
46186: LIST
46187: LIST
46188: LIST
46189: LIST
46190: LIST
46191: LIST
46192: LIST
46193: LIST
46194: LIST
46195: LIST
46196: LIST
46197: LIST
46198: LIST
46199: LIST
46200: LIST
46201: LIST
46202: LIST
46203: LIST
46204: LIST
46205: LIST
46206: LIST
46207: LIST
46208: LIST
46209: LIST
46210: LIST
46211: LIST
46212: LIST
46213: LIST
46214: LIST
46215: LIST
46216: LIST
46217: LIST
46218: LIST
46219: LIST
46220: LIST
46221: LIST
46222: LIST
46223: LIST
46224: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
46225: LD_ADDR_VAR 0 33
46229: PUSH
46230: LD_INT 4
46232: NEG
46233: PUSH
46234: LD_INT 4
46236: NEG
46237: PUSH
46238: EMPTY
46239: LIST
46240: LIST
46241: PUSH
46242: LD_INT 4
46244: NEG
46245: PUSH
46246: LD_INT 5
46248: NEG
46249: PUSH
46250: EMPTY
46251: LIST
46252: LIST
46253: PUSH
46254: LD_INT 3
46256: NEG
46257: PUSH
46258: LD_INT 4
46260: NEG
46261: PUSH
46262: EMPTY
46263: LIST
46264: LIST
46265: PUSH
46266: LD_INT 3
46268: NEG
46269: PUSH
46270: LD_INT 3
46272: NEG
46273: PUSH
46274: EMPTY
46275: LIST
46276: LIST
46277: PUSH
46278: LD_INT 4
46280: NEG
46281: PUSH
46282: LD_INT 3
46284: NEG
46285: PUSH
46286: EMPTY
46287: LIST
46288: LIST
46289: PUSH
46290: LD_INT 5
46292: NEG
46293: PUSH
46294: LD_INT 4
46296: NEG
46297: PUSH
46298: EMPTY
46299: LIST
46300: LIST
46301: PUSH
46302: LD_INT 5
46304: NEG
46305: PUSH
46306: LD_INT 5
46308: NEG
46309: PUSH
46310: EMPTY
46311: LIST
46312: LIST
46313: PUSH
46314: LD_INT 3
46316: NEG
46317: PUSH
46318: LD_INT 5
46320: NEG
46321: PUSH
46322: EMPTY
46323: LIST
46324: LIST
46325: PUSH
46326: LD_INT 5
46328: NEG
46329: PUSH
46330: LD_INT 3
46332: NEG
46333: PUSH
46334: EMPTY
46335: LIST
46336: LIST
46337: PUSH
46338: LD_INT 0
46340: PUSH
46341: LD_INT 3
46343: NEG
46344: PUSH
46345: EMPTY
46346: LIST
46347: LIST
46348: PUSH
46349: LD_INT 0
46351: PUSH
46352: LD_INT 4
46354: NEG
46355: PUSH
46356: EMPTY
46357: LIST
46358: LIST
46359: PUSH
46360: LD_INT 1
46362: PUSH
46363: LD_INT 3
46365: NEG
46366: PUSH
46367: EMPTY
46368: LIST
46369: LIST
46370: PUSH
46371: LD_INT 1
46373: PUSH
46374: LD_INT 2
46376: NEG
46377: PUSH
46378: EMPTY
46379: LIST
46380: LIST
46381: PUSH
46382: LD_INT 0
46384: PUSH
46385: LD_INT 2
46387: NEG
46388: PUSH
46389: EMPTY
46390: LIST
46391: LIST
46392: PUSH
46393: LD_INT 1
46395: NEG
46396: PUSH
46397: LD_INT 3
46399: NEG
46400: PUSH
46401: EMPTY
46402: LIST
46403: LIST
46404: PUSH
46405: LD_INT 1
46407: NEG
46408: PUSH
46409: LD_INT 4
46411: NEG
46412: PUSH
46413: EMPTY
46414: LIST
46415: LIST
46416: PUSH
46417: LD_INT 2
46419: PUSH
46420: LD_INT 2
46422: NEG
46423: PUSH
46424: EMPTY
46425: LIST
46426: LIST
46427: PUSH
46428: LD_INT 2
46430: NEG
46431: PUSH
46432: LD_INT 4
46434: NEG
46435: PUSH
46436: EMPTY
46437: LIST
46438: LIST
46439: PUSH
46440: LD_INT 4
46442: PUSH
46443: LD_INT 0
46445: PUSH
46446: EMPTY
46447: LIST
46448: LIST
46449: PUSH
46450: LD_INT 4
46452: PUSH
46453: LD_INT 1
46455: NEG
46456: PUSH
46457: EMPTY
46458: LIST
46459: LIST
46460: PUSH
46461: LD_INT 5
46463: PUSH
46464: LD_INT 0
46466: PUSH
46467: EMPTY
46468: LIST
46469: LIST
46470: PUSH
46471: LD_INT 5
46473: PUSH
46474: LD_INT 1
46476: PUSH
46477: EMPTY
46478: LIST
46479: LIST
46480: PUSH
46481: LD_INT 4
46483: PUSH
46484: LD_INT 1
46486: PUSH
46487: EMPTY
46488: LIST
46489: LIST
46490: PUSH
46491: LD_INT 3
46493: PUSH
46494: LD_INT 0
46496: PUSH
46497: EMPTY
46498: LIST
46499: LIST
46500: PUSH
46501: LD_INT 3
46503: PUSH
46504: LD_INT 1
46506: NEG
46507: PUSH
46508: EMPTY
46509: LIST
46510: LIST
46511: PUSH
46512: LD_INT 3
46514: PUSH
46515: LD_INT 2
46517: NEG
46518: PUSH
46519: EMPTY
46520: LIST
46521: LIST
46522: PUSH
46523: LD_INT 5
46525: PUSH
46526: LD_INT 2
46528: PUSH
46529: EMPTY
46530: LIST
46531: LIST
46532: PUSH
46533: LD_INT 3
46535: PUSH
46536: LD_INT 3
46538: PUSH
46539: EMPTY
46540: LIST
46541: LIST
46542: PUSH
46543: LD_INT 3
46545: PUSH
46546: LD_INT 2
46548: PUSH
46549: EMPTY
46550: LIST
46551: LIST
46552: PUSH
46553: LD_INT 4
46555: PUSH
46556: LD_INT 3
46558: PUSH
46559: EMPTY
46560: LIST
46561: LIST
46562: PUSH
46563: LD_INT 4
46565: PUSH
46566: LD_INT 4
46568: PUSH
46569: EMPTY
46570: LIST
46571: LIST
46572: PUSH
46573: LD_INT 3
46575: PUSH
46576: LD_INT 4
46578: PUSH
46579: EMPTY
46580: LIST
46581: LIST
46582: PUSH
46583: LD_INT 2
46585: PUSH
46586: LD_INT 3
46588: PUSH
46589: EMPTY
46590: LIST
46591: LIST
46592: PUSH
46593: LD_INT 2
46595: PUSH
46596: LD_INT 2
46598: PUSH
46599: EMPTY
46600: LIST
46601: LIST
46602: PUSH
46603: LD_INT 4
46605: PUSH
46606: LD_INT 2
46608: PUSH
46609: EMPTY
46610: LIST
46611: LIST
46612: PUSH
46613: LD_INT 2
46615: PUSH
46616: LD_INT 4
46618: PUSH
46619: EMPTY
46620: LIST
46621: LIST
46622: PUSH
46623: LD_INT 0
46625: PUSH
46626: LD_INT 4
46628: PUSH
46629: EMPTY
46630: LIST
46631: LIST
46632: PUSH
46633: LD_INT 0
46635: PUSH
46636: LD_INT 3
46638: PUSH
46639: EMPTY
46640: LIST
46641: LIST
46642: PUSH
46643: LD_INT 1
46645: PUSH
46646: LD_INT 4
46648: PUSH
46649: EMPTY
46650: LIST
46651: LIST
46652: PUSH
46653: LD_INT 1
46655: PUSH
46656: LD_INT 5
46658: PUSH
46659: EMPTY
46660: LIST
46661: LIST
46662: PUSH
46663: LD_INT 0
46665: PUSH
46666: LD_INT 5
46668: PUSH
46669: EMPTY
46670: LIST
46671: LIST
46672: PUSH
46673: LD_INT 1
46675: NEG
46676: PUSH
46677: LD_INT 4
46679: PUSH
46680: EMPTY
46681: LIST
46682: LIST
46683: PUSH
46684: LD_INT 1
46686: NEG
46687: PUSH
46688: LD_INT 3
46690: PUSH
46691: EMPTY
46692: LIST
46693: LIST
46694: PUSH
46695: LD_INT 2
46697: PUSH
46698: LD_INT 5
46700: PUSH
46701: EMPTY
46702: LIST
46703: LIST
46704: PUSH
46705: LD_INT 2
46707: NEG
46708: PUSH
46709: LD_INT 3
46711: PUSH
46712: EMPTY
46713: LIST
46714: LIST
46715: PUSH
46716: EMPTY
46717: LIST
46718: LIST
46719: LIST
46720: LIST
46721: LIST
46722: LIST
46723: LIST
46724: LIST
46725: LIST
46726: LIST
46727: LIST
46728: LIST
46729: LIST
46730: LIST
46731: LIST
46732: LIST
46733: LIST
46734: LIST
46735: LIST
46736: LIST
46737: LIST
46738: LIST
46739: LIST
46740: LIST
46741: LIST
46742: LIST
46743: LIST
46744: LIST
46745: LIST
46746: LIST
46747: LIST
46748: LIST
46749: LIST
46750: LIST
46751: LIST
46752: LIST
46753: LIST
46754: LIST
46755: LIST
46756: LIST
46757: LIST
46758: LIST
46759: LIST
46760: LIST
46761: LIST
46762: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46763: LD_ADDR_VAR 0 34
46767: PUSH
46768: LD_INT 0
46770: PUSH
46771: LD_INT 4
46773: NEG
46774: PUSH
46775: EMPTY
46776: LIST
46777: LIST
46778: PUSH
46779: LD_INT 0
46781: PUSH
46782: LD_INT 5
46784: NEG
46785: PUSH
46786: EMPTY
46787: LIST
46788: LIST
46789: PUSH
46790: LD_INT 1
46792: PUSH
46793: LD_INT 4
46795: NEG
46796: PUSH
46797: EMPTY
46798: LIST
46799: LIST
46800: PUSH
46801: LD_INT 1
46803: PUSH
46804: LD_INT 3
46806: NEG
46807: PUSH
46808: EMPTY
46809: LIST
46810: LIST
46811: PUSH
46812: LD_INT 0
46814: PUSH
46815: LD_INT 3
46817: NEG
46818: PUSH
46819: EMPTY
46820: LIST
46821: LIST
46822: PUSH
46823: LD_INT 1
46825: NEG
46826: PUSH
46827: LD_INT 4
46829: NEG
46830: PUSH
46831: EMPTY
46832: LIST
46833: LIST
46834: PUSH
46835: LD_INT 1
46837: NEG
46838: PUSH
46839: LD_INT 5
46841: NEG
46842: PUSH
46843: EMPTY
46844: LIST
46845: LIST
46846: PUSH
46847: LD_INT 2
46849: PUSH
46850: LD_INT 3
46852: NEG
46853: PUSH
46854: EMPTY
46855: LIST
46856: LIST
46857: PUSH
46858: LD_INT 2
46860: NEG
46861: PUSH
46862: LD_INT 5
46864: NEG
46865: PUSH
46866: EMPTY
46867: LIST
46868: LIST
46869: PUSH
46870: LD_INT 3
46872: PUSH
46873: LD_INT 0
46875: PUSH
46876: EMPTY
46877: LIST
46878: LIST
46879: PUSH
46880: LD_INT 3
46882: PUSH
46883: LD_INT 1
46885: NEG
46886: PUSH
46887: EMPTY
46888: LIST
46889: LIST
46890: PUSH
46891: LD_INT 4
46893: PUSH
46894: LD_INT 0
46896: PUSH
46897: EMPTY
46898: LIST
46899: LIST
46900: PUSH
46901: LD_INT 4
46903: PUSH
46904: LD_INT 1
46906: PUSH
46907: EMPTY
46908: LIST
46909: LIST
46910: PUSH
46911: LD_INT 3
46913: PUSH
46914: LD_INT 1
46916: PUSH
46917: EMPTY
46918: LIST
46919: LIST
46920: PUSH
46921: LD_INT 2
46923: PUSH
46924: LD_INT 0
46926: PUSH
46927: EMPTY
46928: LIST
46929: LIST
46930: PUSH
46931: LD_INT 2
46933: PUSH
46934: LD_INT 1
46936: NEG
46937: PUSH
46938: EMPTY
46939: LIST
46940: LIST
46941: PUSH
46942: LD_INT 2
46944: PUSH
46945: LD_INT 2
46947: NEG
46948: PUSH
46949: EMPTY
46950: LIST
46951: LIST
46952: PUSH
46953: LD_INT 4
46955: PUSH
46956: LD_INT 2
46958: PUSH
46959: EMPTY
46960: LIST
46961: LIST
46962: PUSH
46963: LD_INT 4
46965: PUSH
46966: LD_INT 4
46968: PUSH
46969: EMPTY
46970: LIST
46971: LIST
46972: PUSH
46973: LD_INT 4
46975: PUSH
46976: LD_INT 3
46978: PUSH
46979: EMPTY
46980: LIST
46981: LIST
46982: PUSH
46983: LD_INT 5
46985: PUSH
46986: LD_INT 4
46988: PUSH
46989: EMPTY
46990: LIST
46991: LIST
46992: PUSH
46993: LD_INT 5
46995: PUSH
46996: LD_INT 5
46998: PUSH
46999: EMPTY
47000: LIST
47001: LIST
47002: PUSH
47003: LD_INT 4
47005: PUSH
47006: LD_INT 5
47008: PUSH
47009: EMPTY
47010: LIST
47011: LIST
47012: PUSH
47013: LD_INT 3
47015: PUSH
47016: LD_INT 4
47018: PUSH
47019: EMPTY
47020: LIST
47021: LIST
47022: PUSH
47023: LD_INT 3
47025: PUSH
47026: LD_INT 3
47028: PUSH
47029: EMPTY
47030: LIST
47031: LIST
47032: PUSH
47033: LD_INT 5
47035: PUSH
47036: LD_INT 3
47038: PUSH
47039: EMPTY
47040: LIST
47041: LIST
47042: PUSH
47043: LD_INT 3
47045: PUSH
47046: LD_INT 5
47048: PUSH
47049: EMPTY
47050: LIST
47051: LIST
47052: PUSH
47053: LD_INT 0
47055: PUSH
47056: LD_INT 3
47058: PUSH
47059: EMPTY
47060: LIST
47061: LIST
47062: PUSH
47063: LD_INT 0
47065: PUSH
47066: LD_INT 2
47068: PUSH
47069: EMPTY
47070: LIST
47071: LIST
47072: PUSH
47073: LD_INT 1
47075: PUSH
47076: LD_INT 3
47078: PUSH
47079: EMPTY
47080: LIST
47081: LIST
47082: PUSH
47083: LD_INT 1
47085: PUSH
47086: LD_INT 4
47088: PUSH
47089: EMPTY
47090: LIST
47091: LIST
47092: PUSH
47093: LD_INT 0
47095: PUSH
47096: LD_INT 4
47098: PUSH
47099: EMPTY
47100: LIST
47101: LIST
47102: PUSH
47103: LD_INT 1
47105: NEG
47106: PUSH
47107: LD_INT 3
47109: PUSH
47110: EMPTY
47111: LIST
47112: LIST
47113: PUSH
47114: LD_INT 1
47116: NEG
47117: PUSH
47118: LD_INT 2
47120: PUSH
47121: EMPTY
47122: LIST
47123: LIST
47124: PUSH
47125: LD_INT 2
47127: PUSH
47128: LD_INT 4
47130: PUSH
47131: EMPTY
47132: LIST
47133: LIST
47134: PUSH
47135: LD_INT 2
47137: NEG
47138: PUSH
47139: LD_INT 2
47141: PUSH
47142: EMPTY
47143: LIST
47144: LIST
47145: PUSH
47146: LD_INT 4
47148: NEG
47149: PUSH
47150: LD_INT 0
47152: PUSH
47153: EMPTY
47154: LIST
47155: LIST
47156: PUSH
47157: LD_INT 4
47159: NEG
47160: PUSH
47161: LD_INT 1
47163: NEG
47164: PUSH
47165: EMPTY
47166: LIST
47167: LIST
47168: PUSH
47169: LD_INT 3
47171: NEG
47172: PUSH
47173: LD_INT 0
47175: PUSH
47176: EMPTY
47177: LIST
47178: LIST
47179: PUSH
47180: LD_INT 3
47182: NEG
47183: PUSH
47184: LD_INT 1
47186: PUSH
47187: EMPTY
47188: LIST
47189: LIST
47190: PUSH
47191: LD_INT 4
47193: NEG
47194: PUSH
47195: LD_INT 1
47197: PUSH
47198: EMPTY
47199: LIST
47200: LIST
47201: PUSH
47202: LD_INT 5
47204: NEG
47205: PUSH
47206: LD_INT 0
47208: PUSH
47209: EMPTY
47210: LIST
47211: LIST
47212: PUSH
47213: LD_INT 5
47215: NEG
47216: PUSH
47217: LD_INT 1
47219: NEG
47220: PUSH
47221: EMPTY
47222: LIST
47223: LIST
47224: PUSH
47225: LD_INT 5
47227: NEG
47228: PUSH
47229: LD_INT 2
47231: NEG
47232: PUSH
47233: EMPTY
47234: LIST
47235: LIST
47236: PUSH
47237: LD_INT 3
47239: NEG
47240: PUSH
47241: LD_INT 2
47243: PUSH
47244: EMPTY
47245: LIST
47246: LIST
47247: PUSH
47248: EMPTY
47249: LIST
47250: LIST
47251: LIST
47252: LIST
47253: LIST
47254: LIST
47255: LIST
47256: LIST
47257: LIST
47258: LIST
47259: LIST
47260: LIST
47261: LIST
47262: LIST
47263: LIST
47264: LIST
47265: LIST
47266: LIST
47267: LIST
47268: LIST
47269: LIST
47270: LIST
47271: LIST
47272: LIST
47273: LIST
47274: LIST
47275: LIST
47276: LIST
47277: LIST
47278: LIST
47279: LIST
47280: LIST
47281: LIST
47282: LIST
47283: LIST
47284: LIST
47285: LIST
47286: LIST
47287: LIST
47288: LIST
47289: LIST
47290: LIST
47291: LIST
47292: LIST
47293: LIST
47294: ST_TO_ADDR
// end ; end ;
47295: GO 47298
47297: POP
// case btype of b_depot , b_warehouse :
47298: LD_VAR 0 1
47302: PUSH
47303: LD_INT 0
47305: DOUBLE
47306: EQUAL
47307: IFTRUE 47317
47309: LD_INT 1
47311: DOUBLE
47312: EQUAL
47313: IFTRUE 47317
47315: GO 47518
47317: POP
// case nation of nation_american :
47318: LD_VAR 0 5
47322: PUSH
47323: LD_INT 1
47325: DOUBLE
47326: EQUAL
47327: IFTRUE 47331
47329: GO 47387
47331: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
47332: LD_ADDR_VAR 0 9
47336: PUSH
47337: LD_VAR 0 11
47341: PUSH
47342: LD_VAR 0 12
47346: PUSH
47347: LD_VAR 0 13
47351: PUSH
47352: LD_VAR 0 14
47356: PUSH
47357: LD_VAR 0 15
47361: PUSH
47362: LD_VAR 0 16
47366: PUSH
47367: EMPTY
47368: LIST
47369: LIST
47370: LIST
47371: LIST
47372: LIST
47373: LIST
47374: PUSH
47375: LD_VAR 0 4
47379: PUSH
47380: LD_INT 1
47382: PLUS
47383: ARRAY
47384: ST_TO_ADDR
47385: GO 47516
47387: LD_INT 2
47389: DOUBLE
47390: EQUAL
47391: IFTRUE 47395
47393: GO 47451
47395: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
47396: LD_ADDR_VAR 0 9
47400: PUSH
47401: LD_VAR 0 17
47405: PUSH
47406: LD_VAR 0 18
47410: PUSH
47411: LD_VAR 0 19
47415: PUSH
47416: LD_VAR 0 20
47420: PUSH
47421: LD_VAR 0 21
47425: PUSH
47426: LD_VAR 0 22
47430: PUSH
47431: EMPTY
47432: LIST
47433: LIST
47434: LIST
47435: LIST
47436: LIST
47437: LIST
47438: PUSH
47439: LD_VAR 0 4
47443: PUSH
47444: LD_INT 1
47446: PLUS
47447: ARRAY
47448: ST_TO_ADDR
47449: GO 47516
47451: LD_INT 3
47453: DOUBLE
47454: EQUAL
47455: IFTRUE 47459
47457: GO 47515
47459: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
47460: LD_ADDR_VAR 0 9
47464: PUSH
47465: LD_VAR 0 23
47469: PUSH
47470: LD_VAR 0 24
47474: PUSH
47475: LD_VAR 0 25
47479: PUSH
47480: LD_VAR 0 26
47484: PUSH
47485: LD_VAR 0 27
47489: PUSH
47490: LD_VAR 0 28
47494: PUSH
47495: EMPTY
47496: LIST
47497: LIST
47498: LIST
47499: LIST
47500: LIST
47501: LIST
47502: PUSH
47503: LD_VAR 0 4
47507: PUSH
47508: LD_INT 1
47510: PLUS
47511: ARRAY
47512: ST_TO_ADDR
47513: GO 47516
47515: POP
47516: GO 48071
47518: LD_INT 2
47520: DOUBLE
47521: EQUAL
47522: IFTRUE 47532
47524: LD_INT 3
47526: DOUBLE
47527: EQUAL
47528: IFTRUE 47532
47530: GO 47588
47532: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
47533: LD_ADDR_VAR 0 9
47537: PUSH
47538: LD_VAR 0 29
47542: PUSH
47543: LD_VAR 0 30
47547: PUSH
47548: LD_VAR 0 31
47552: PUSH
47553: LD_VAR 0 32
47557: PUSH
47558: LD_VAR 0 33
47562: PUSH
47563: LD_VAR 0 34
47567: PUSH
47568: EMPTY
47569: LIST
47570: LIST
47571: LIST
47572: LIST
47573: LIST
47574: LIST
47575: PUSH
47576: LD_VAR 0 4
47580: PUSH
47581: LD_INT 1
47583: PLUS
47584: ARRAY
47585: ST_TO_ADDR
47586: GO 48071
47588: LD_INT 16
47590: DOUBLE
47591: EQUAL
47592: IFTRUE 47650
47594: LD_INT 17
47596: DOUBLE
47597: EQUAL
47598: IFTRUE 47650
47600: LD_INT 18
47602: DOUBLE
47603: EQUAL
47604: IFTRUE 47650
47606: LD_INT 19
47608: DOUBLE
47609: EQUAL
47610: IFTRUE 47650
47612: LD_INT 22
47614: DOUBLE
47615: EQUAL
47616: IFTRUE 47650
47618: LD_INT 20
47620: DOUBLE
47621: EQUAL
47622: IFTRUE 47650
47624: LD_INT 21
47626: DOUBLE
47627: EQUAL
47628: IFTRUE 47650
47630: LD_INT 23
47632: DOUBLE
47633: EQUAL
47634: IFTRUE 47650
47636: LD_INT 24
47638: DOUBLE
47639: EQUAL
47640: IFTRUE 47650
47642: LD_INT 25
47644: DOUBLE
47645: EQUAL
47646: IFTRUE 47650
47648: GO 47706
47650: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47651: LD_ADDR_VAR 0 9
47655: PUSH
47656: LD_VAR 0 35
47660: PUSH
47661: LD_VAR 0 36
47665: PUSH
47666: LD_VAR 0 37
47670: PUSH
47671: LD_VAR 0 38
47675: PUSH
47676: LD_VAR 0 39
47680: PUSH
47681: LD_VAR 0 40
47685: PUSH
47686: EMPTY
47687: LIST
47688: LIST
47689: LIST
47690: LIST
47691: LIST
47692: LIST
47693: PUSH
47694: LD_VAR 0 4
47698: PUSH
47699: LD_INT 1
47701: PLUS
47702: ARRAY
47703: ST_TO_ADDR
47704: GO 48071
47706: LD_INT 6
47708: DOUBLE
47709: EQUAL
47710: IFTRUE 47762
47712: LD_INT 7
47714: DOUBLE
47715: EQUAL
47716: IFTRUE 47762
47718: LD_INT 8
47720: DOUBLE
47721: EQUAL
47722: IFTRUE 47762
47724: LD_INT 13
47726: DOUBLE
47727: EQUAL
47728: IFTRUE 47762
47730: LD_INT 12
47732: DOUBLE
47733: EQUAL
47734: IFTRUE 47762
47736: LD_INT 15
47738: DOUBLE
47739: EQUAL
47740: IFTRUE 47762
47742: LD_INT 11
47744: DOUBLE
47745: EQUAL
47746: IFTRUE 47762
47748: LD_INT 14
47750: DOUBLE
47751: EQUAL
47752: IFTRUE 47762
47754: LD_INT 10
47756: DOUBLE
47757: EQUAL
47758: IFTRUE 47762
47760: GO 47818
47762: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
47763: LD_ADDR_VAR 0 9
47767: PUSH
47768: LD_VAR 0 41
47772: PUSH
47773: LD_VAR 0 42
47777: PUSH
47778: LD_VAR 0 43
47782: PUSH
47783: LD_VAR 0 44
47787: PUSH
47788: LD_VAR 0 45
47792: PUSH
47793: LD_VAR 0 46
47797: PUSH
47798: EMPTY
47799: LIST
47800: LIST
47801: LIST
47802: LIST
47803: LIST
47804: LIST
47805: PUSH
47806: LD_VAR 0 4
47810: PUSH
47811: LD_INT 1
47813: PLUS
47814: ARRAY
47815: ST_TO_ADDR
47816: GO 48071
47818: LD_INT 36
47820: DOUBLE
47821: EQUAL
47822: IFTRUE 47826
47824: GO 47882
47826: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47827: LD_ADDR_VAR 0 9
47831: PUSH
47832: LD_VAR 0 47
47836: PUSH
47837: LD_VAR 0 48
47841: PUSH
47842: LD_VAR 0 49
47846: PUSH
47847: LD_VAR 0 50
47851: PUSH
47852: LD_VAR 0 51
47856: PUSH
47857: LD_VAR 0 52
47861: PUSH
47862: EMPTY
47863: LIST
47864: LIST
47865: LIST
47866: LIST
47867: LIST
47868: LIST
47869: PUSH
47870: LD_VAR 0 4
47874: PUSH
47875: LD_INT 1
47877: PLUS
47878: ARRAY
47879: ST_TO_ADDR
47880: GO 48071
47882: LD_INT 4
47884: DOUBLE
47885: EQUAL
47886: IFTRUE 47908
47888: LD_INT 5
47890: DOUBLE
47891: EQUAL
47892: IFTRUE 47908
47894: LD_INT 34
47896: DOUBLE
47897: EQUAL
47898: IFTRUE 47908
47900: LD_INT 37
47902: DOUBLE
47903: EQUAL
47904: IFTRUE 47908
47906: GO 47964
47908: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47909: LD_ADDR_VAR 0 9
47913: PUSH
47914: LD_VAR 0 53
47918: PUSH
47919: LD_VAR 0 54
47923: PUSH
47924: LD_VAR 0 55
47928: PUSH
47929: LD_VAR 0 56
47933: PUSH
47934: LD_VAR 0 57
47938: PUSH
47939: LD_VAR 0 58
47943: PUSH
47944: EMPTY
47945: LIST
47946: LIST
47947: LIST
47948: LIST
47949: LIST
47950: LIST
47951: PUSH
47952: LD_VAR 0 4
47956: PUSH
47957: LD_INT 1
47959: PLUS
47960: ARRAY
47961: ST_TO_ADDR
47962: GO 48071
47964: LD_INT 31
47966: DOUBLE
47967: EQUAL
47968: IFTRUE 48014
47970: LD_INT 32
47972: DOUBLE
47973: EQUAL
47974: IFTRUE 48014
47976: LD_INT 33
47978: DOUBLE
47979: EQUAL
47980: IFTRUE 48014
47982: LD_INT 27
47984: DOUBLE
47985: EQUAL
47986: IFTRUE 48014
47988: LD_INT 26
47990: DOUBLE
47991: EQUAL
47992: IFTRUE 48014
47994: LD_INT 28
47996: DOUBLE
47997: EQUAL
47998: IFTRUE 48014
48000: LD_INT 29
48002: DOUBLE
48003: EQUAL
48004: IFTRUE 48014
48006: LD_INT 30
48008: DOUBLE
48009: EQUAL
48010: IFTRUE 48014
48012: GO 48070
48014: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
48015: LD_ADDR_VAR 0 9
48019: PUSH
48020: LD_VAR 0 59
48024: PUSH
48025: LD_VAR 0 60
48029: PUSH
48030: LD_VAR 0 61
48034: PUSH
48035: LD_VAR 0 62
48039: PUSH
48040: LD_VAR 0 63
48044: PUSH
48045: LD_VAR 0 64
48049: PUSH
48050: EMPTY
48051: LIST
48052: LIST
48053: LIST
48054: LIST
48055: LIST
48056: LIST
48057: PUSH
48058: LD_VAR 0 4
48062: PUSH
48063: LD_INT 1
48065: PLUS
48066: ARRAY
48067: ST_TO_ADDR
48068: GO 48071
48070: POP
// temp_list2 = [ ] ;
48071: LD_ADDR_VAR 0 10
48075: PUSH
48076: EMPTY
48077: ST_TO_ADDR
// for i in temp_list do
48078: LD_ADDR_VAR 0 8
48082: PUSH
48083: LD_VAR 0 9
48087: PUSH
48088: FOR_IN
48089: IFFALSE 48141
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
48091: LD_ADDR_VAR 0 10
48095: PUSH
48096: LD_VAR 0 10
48100: PUSH
48101: LD_VAR 0 8
48105: PUSH
48106: LD_INT 1
48108: ARRAY
48109: PUSH
48110: LD_VAR 0 2
48114: PLUS
48115: PUSH
48116: LD_VAR 0 8
48120: PUSH
48121: LD_INT 2
48123: ARRAY
48124: PUSH
48125: LD_VAR 0 3
48129: PLUS
48130: PUSH
48131: EMPTY
48132: LIST
48133: LIST
48134: PUSH
48135: EMPTY
48136: LIST
48137: ADD
48138: ST_TO_ADDR
48139: GO 48088
48141: POP
48142: POP
// result = temp_list2 ;
48143: LD_ADDR_VAR 0 7
48147: PUSH
48148: LD_VAR 0 10
48152: ST_TO_ADDR
// end ;
48153: LD_VAR 0 7
48157: RET
// export function EnemyInRange ( unit , dist ) ; begin
48158: LD_INT 0
48160: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
48161: LD_ADDR_VAR 0 3
48165: PUSH
48166: LD_VAR 0 1
48170: PPUSH
48171: CALL_OW 255
48175: PPUSH
48176: LD_VAR 0 1
48180: PPUSH
48181: CALL_OW 250
48185: PPUSH
48186: LD_VAR 0 1
48190: PPUSH
48191: CALL_OW 251
48195: PPUSH
48196: LD_VAR 0 2
48200: PPUSH
48201: CALL 22262 0 4
48205: PUSH
48206: LD_INT 4
48208: ARRAY
48209: ST_TO_ADDR
// end ;
48210: LD_VAR 0 3
48214: RET
// export function PlayerSeeMe ( unit ) ; begin
48215: LD_INT 0
48217: PPUSH
// result := See ( your_side , unit ) ;
48218: LD_ADDR_VAR 0 2
48222: PUSH
48223: LD_OWVAR 2
48227: PPUSH
48228: LD_VAR 0 1
48232: PPUSH
48233: CALL_OW 292
48237: ST_TO_ADDR
// end ;
48238: LD_VAR 0 2
48242: RET
// export function ReverseDir ( unit ) ; begin
48243: LD_INT 0
48245: PPUSH
// if not unit then
48246: LD_VAR 0 1
48250: NOT
48251: IFFALSE 48255
// exit ;
48253: GO 48301
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
48255: LD_ADDR_VAR 0 2
48259: PUSH
48260: LD_INT 3
48262: PUSH
48263: LD_INT 4
48265: PUSH
48266: LD_INT 5
48268: PUSH
48269: LD_INT 0
48271: PUSH
48272: LD_INT 1
48274: PUSH
48275: LD_INT 2
48277: PUSH
48278: EMPTY
48279: LIST
48280: LIST
48281: LIST
48282: LIST
48283: LIST
48284: LIST
48285: PUSH
48286: LD_VAR 0 1
48290: PPUSH
48291: CALL_OW 254
48295: PUSH
48296: LD_INT 1
48298: PLUS
48299: ARRAY
48300: ST_TO_ADDR
// end ;
48301: LD_VAR 0 2
48305: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
48306: LD_INT 0
48308: PPUSH
48309: PPUSH
48310: PPUSH
48311: PPUSH
48312: PPUSH
// if not hexes then
48313: LD_VAR 0 2
48317: NOT
48318: IFFALSE 48322
// exit ;
48320: GO 48470
// dist := 9999 ;
48322: LD_ADDR_VAR 0 5
48326: PUSH
48327: LD_INT 9999
48329: ST_TO_ADDR
// for i = 1 to hexes do
48330: LD_ADDR_VAR 0 4
48334: PUSH
48335: DOUBLE
48336: LD_INT 1
48338: DEC
48339: ST_TO_ADDR
48340: LD_VAR 0 2
48344: PUSH
48345: FOR_TO
48346: IFFALSE 48458
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
48348: LD_VAR 0 1
48352: PPUSH
48353: LD_VAR 0 2
48357: PUSH
48358: LD_VAR 0 4
48362: ARRAY
48363: PUSH
48364: LD_INT 1
48366: ARRAY
48367: PPUSH
48368: LD_VAR 0 2
48372: PUSH
48373: LD_VAR 0 4
48377: ARRAY
48378: PUSH
48379: LD_INT 2
48381: ARRAY
48382: PPUSH
48383: CALL_OW 297
48387: PUSH
48388: LD_VAR 0 5
48392: LESS
48393: IFFALSE 48456
// begin hex := hexes [ i ] ;
48395: LD_ADDR_VAR 0 7
48399: PUSH
48400: LD_VAR 0 2
48404: PUSH
48405: LD_VAR 0 4
48409: ARRAY
48410: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
48411: LD_ADDR_VAR 0 5
48415: PUSH
48416: LD_VAR 0 1
48420: PPUSH
48421: LD_VAR 0 2
48425: PUSH
48426: LD_VAR 0 4
48430: ARRAY
48431: PUSH
48432: LD_INT 1
48434: ARRAY
48435: PPUSH
48436: LD_VAR 0 2
48440: PUSH
48441: LD_VAR 0 4
48445: ARRAY
48446: PUSH
48447: LD_INT 2
48449: ARRAY
48450: PPUSH
48451: CALL_OW 297
48455: ST_TO_ADDR
// end ; end ;
48456: GO 48345
48458: POP
48459: POP
// result := hex ;
48460: LD_ADDR_VAR 0 3
48464: PUSH
48465: LD_VAR 0 7
48469: ST_TO_ADDR
// end ;
48470: LD_VAR 0 3
48474: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
48475: LD_INT 0
48477: PPUSH
48478: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
48479: LD_VAR 0 1
48483: NOT
48484: PUSH
48485: LD_VAR 0 1
48489: PUSH
48490: LD_INT 21
48492: PUSH
48493: LD_INT 2
48495: PUSH
48496: EMPTY
48497: LIST
48498: LIST
48499: PUSH
48500: LD_INT 23
48502: PUSH
48503: LD_INT 2
48505: PUSH
48506: EMPTY
48507: LIST
48508: LIST
48509: PUSH
48510: EMPTY
48511: LIST
48512: LIST
48513: PPUSH
48514: CALL_OW 69
48518: IN
48519: NOT
48520: OR
48521: IFFALSE 48525
// exit ;
48523: GO 48572
// for i = 1 to 3 do
48525: LD_ADDR_VAR 0 3
48529: PUSH
48530: DOUBLE
48531: LD_INT 1
48533: DEC
48534: ST_TO_ADDR
48535: LD_INT 3
48537: PUSH
48538: FOR_TO
48539: IFFALSE 48570
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
48541: LD_VAR 0 1
48545: PPUSH
48546: CALL_OW 250
48550: PPUSH
48551: LD_VAR 0 1
48555: PPUSH
48556: CALL_OW 251
48560: PPUSH
48561: LD_INT 1
48563: PPUSH
48564: CALL_OW 453
48568: GO 48538
48570: POP
48571: POP
// end ;
48572: LD_VAR 0 2
48576: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48577: LD_INT 0
48579: PPUSH
48580: PPUSH
48581: PPUSH
48582: PPUSH
48583: PPUSH
48584: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48585: LD_VAR 0 1
48589: NOT
48590: PUSH
48591: LD_VAR 0 2
48595: NOT
48596: OR
48597: PUSH
48598: LD_VAR 0 1
48602: PPUSH
48603: CALL_OW 314
48607: OR
48608: IFFALSE 48612
// exit ;
48610: GO 49053
// x := GetX ( enemy_unit ) ;
48612: LD_ADDR_VAR 0 7
48616: PUSH
48617: LD_VAR 0 2
48621: PPUSH
48622: CALL_OW 250
48626: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48627: LD_ADDR_VAR 0 8
48631: PUSH
48632: LD_VAR 0 2
48636: PPUSH
48637: CALL_OW 251
48641: ST_TO_ADDR
// if not x or not y then
48642: LD_VAR 0 7
48646: NOT
48647: PUSH
48648: LD_VAR 0 8
48652: NOT
48653: OR
48654: IFFALSE 48658
// exit ;
48656: GO 49053
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48658: LD_ADDR_VAR 0 6
48662: PUSH
48663: LD_VAR 0 7
48667: PPUSH
48668: LD_INT 0
48670: PPUSH
48671: LD_INT 4
48673: PPUSH
48674: CALL_OW 272
48678: PUSH
48679: LD_VAR 0 8
48683: PPUSH
48684: LD_INT 0
48686: PPUSH
48687: LD_INT 4
48689: PPUSH
48690: CALL_OW 273
48694: PUSH
48695: EMPTY
48696: LIST
48697: LIST
48698: PUSH
48699: LD_VAR 0 7
48703: PPUSH
48704: LD_INT 1
48706: PPUSH
48707: LD_INT 4
48709: PPUSH
48710: CALL_OW 272
48714: PUSH
48715: LD_VAR 0 8
48719: PPUSH
48720: LD_INT 1
48722: PPUSH
48723: LD_INT 4
48725: PPUSH
48726: CALL_OW 273
48730: PUSH
48731: EMPTY
48732: LIST
48733: LIST
48734: PUSH
48735: LD_VAR 0 7
48739: PPUSH
48740: LD_INT 2
48742: PPUSH
48743: LD_INT 4
48745: PPUSH
48746: CALL_OW 272
48750: PUSH
48751: LD_VAR 0 8
48755: PPUSH
48756: LD_INT 2
48758: PPUSH
48759: LD_INT 4
48761: PPUSH
48762: CALL_OW 273
48766: PUSH
48767: EMPTY
48768: LIST
48769: LIST
48770: PUSH
48771: LD_VAR 0 7
48775: PPUSH
48776: LD_INT 3
48778: PPUSH
48779: LD_INT 4
48781: PPUSH
48782: CALL_OW 272
48786: PUSH
48787: LD_VAR 0 8
48791: PPUSH
48792: LD_INT 3
48794: PPUSH
48795: LD_INT 4
48797: PPUSH
48798: CALL_OW 273
48802: PUSH
48803: EMPTY
48804: LIST
48805: LIST
48806: PUSH
48807: LD_VAR 0 7
48811: PPUSH
48812: LD_INT 4
48814: PPUSH
48815: LD_INT 4
48817: PPUSH
48818: CALL_OW 272
48822: PUSH
48823: LD_VAR 0 8
48827: PPUSH
48828: LD_INT 4
48830: PPUSH
48831: LD_INT 4
48833: PPUSH
48834: CALL_OW 273
48838: PUSH
48839: EMPTY
48840: LIST
48841: LIST
48842: PUSH
48843: LD_VAR 0 7
48847: PPUSH
48848: LD_INT 5
48850: PPUSH
48851: LD_INT 4
48853: PPUSH
48854: CALL_OW 272
48858: PUSH
48859: LD_VAR 0 8
48863: PPUSH
48864: LD_INT 5
48866: PPUSH
48867: LD_INT 4
48869: PPUSH
48870: CALL_OW 273
48874: PUSH
48875: EMPTY
48876: LIST
48877: LIST
48878: PUSH
48879: EMPTY
48880: LIST
48881: LIST
48882: LIST
48883: LIST
48884: LIST
48885: LIST
48886: ST_TO_ADDR
// for i = tmp downto 1 do
48887: LD_ADDR_VAR 0 4
48891: PUSH
48892: DOUBLE
48893: LD_VAR 0 6
48897: INC
48898: ST_TO_ADDR
48899: LD_INT 1
48901: PUSH
48902: FOR_DOWNTO
48903: IFFALSE 49004
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48905: LD_VAR 0 6
48909: PUSH
48910: LD_VAR 0 4
48914: ARRAY
48915: PUSH
48916: LD_INT 1
48918: ARRAY
48919: PPUSH
48920: LD_VAR 0 6
48924: PUSH
48925: LD_VAR 0 4
48929: ARRAY
48930: PUSH
48931: LD_INT 2
48933: ARRAY
48934: PPUSH
48935: CALL_OW 488
48939: NOT
48940: PUSH
48941: LD_VAR 0 6
48945: PUSH
48946: LD_VAR 0 4
48950: ARRAY
48951: PUSH
48952: LD_INT 1
48954: ARRAY
48955: PPUSH
48956: LD_VAR 0 6
48960: PUSH
48961: LD_VAR 0 4
48965: ARRAY
48966: PUSH
48967: LD_INT 2
48969: ARRAY
48970: PPUSH
48971: CALL_OW 428
48975: PUSH
48976: LD_INT 0
48978: NONEQUAL
48979: OR
48980: IFFALSE 49002
// tmp := Delete ( tmp , i ) ;
48982: LD_ADDR_VAR 0 6
48986: PUSH
48987: LD_VAR 0 6
48991: PPUSH
48992: LD_VAR 0 4
48996: PPUSH
48997: CALL_OW 3
49001: ST_TO_ADDR
49002: GO 48902
49004: POP
49005: POP
// j := GetClosestHex ( unit , tmp ) ;
49006: LD_ADDR_VAR 0 5
49010: PUSH
49011: LD_VAR 0 1
49015: PPUSH
49016: LD_VAR 0 6
49020: PPUSH
49021: CALL 48306 0 2
49025: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
49026: LD_VAR 0 1
49030: PPUSH
49031: LD_VAR 0 5
49035: PUSH
49036: LD_INT 1
49038: ARRAY
49039: PPUSH
49040: LD_VAR 0 5
49044: PUSH
49045: LD_INT 2
49047: ARRAY
49048: PPUSH
49049: CALL_OW 111
// end ;
49053: LD_VAR 0 3
49057: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
49058: LD_INT 0
49060: PPUSH
49061: PPUSH
49062: PPUSH
// uc_side = 0 ;
49063: LD_ADDR_OWVAR 20
49067: PUSH
49068: LD_INT 0
49070: ST_TO_ADDR
// uc_nation = 0 ;
49071: LD_ADDR_OWVAR 21
49075: PUSH
49076: LD_INT 0
49078: ST_TO_ADDR
// InitHc ;
49079: CALL_OW 19
// InitVc ;
49083: CALL_OW 20
// if mastodonts then
49087: LD_VAR 0 6
49091: IFFALSE 49158
// for i = 1 to mastodonts do
49093: LD_ADDR_VAR 0 11
49097: PUSH
49098: DOUBLE
49099: LD_INT 1
49101: DEC
49102: ST_TO_ADDR
49103: LD_VAR 0 6
49107: PUSH
49108: FOR_TO
49109: IFFALSE 49156
// begin vc_chassis := 31 ;
49111: LD_ADDR_OWVAR 37
49115: PUSH
49116: LD_INT 31
49118: ST_TO_ADDR
// vc_control := control_rider ;
49119: LD_ADDR_OWVAR 38
49123: PUSH
49124: LD_INT 4
49126: ST_TO_ADDR
// animal := CreateVehicle ;
49127: LD_ADDR_VAR 0 12
49131: PUSH
49132: CALL_OW 45
49136: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49137: LD_VAR 0 12
49141: PPUSH
49142: LD_VAR 0 8
49146: PPUSH
49147: LD_INT 0
49149: PPUSH
49150: CALL 55903 0 3
// end ;
49154: GO 49108
49156: POP
49157: POP
// if horses then
49158: LD_VAR 0 5
49162: IFFALSE 49229
// for i = 1 to horses do
49164: LD_ADDR_VAR 0 11
49168: PUSH
49169: DOUBLE
49170: LD_INT 1
49172: DEC
49173: ST_TO_ADDR
49174: LD_VAR 0 5
49178: PUSH
49179: FOR_TO
49180: IFFALSE 49227
// begin hc_class := 21 ;
49182: LD_ADDR_OWVAR 28
49186: PUSH
49187: LD_INT 21
49189: ST_TO_ADDR
// hc_gallery :=  ;
49190: LD_ADDR_OWVAR 33
49194: PUSH
49195: LD_STRING 
49197: ST_TO_ADDR
// animal := CreateHuman ;
49198: LD_ADDR_VAR 0 12
49202: PUSH
49203: CALL_OW 44
49207: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49208: LD_VAR 0 12
49212: PPUSH
49213: LD_VAR 0 8
49217: PPUSH
49218: LD_INT 0
49220: PPUSH
49221: CALL 55903 0 3
// end ;
49225: GO 49179
49227: POP
49228: POP
// if birds then
49229: LD_VAR 0 1
49233: IFFALSE 49300
// for i = 1 to birds do
49235: LD_ADDR_VAR 0 11
49239: PUSH
49240: DOUBLE
49241: LD_INT 1
49243: DEC
49244: ST_TO_ADDR
49245: LD_VAR 0 1
49249: PUSH
49250: FOR_TO
49251: IFFALSE 49298
// begin hc_class = 18 ;
49253: LD_ADDR_OWVAR 28
49257: PUSH
49258: LD_INT 18
49260: ST_TO_ADDR
// hc_gallery =  ;
49261: LD_ADDR_OWVAR 33
49265: PUSH
49266: LD_STRING 
49268: ST_TO_ADDR
// animal := CreateHuman ;
49269: LD_ADDR_VAR 0 12
49273: PUSH
49274: CALL_OW 44
49278: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49279: LD_VAR 0 12
49283: PPUSH
49284: LD_VAR 0 8
49288: PPUSH
49289: LD_INT 0
49291: PPUSH
49292: CALL 55903 0 3
// end ;
49296: GO 49250
49298: POP
49299: POP
// if tigers then
49300: LD_VAR 0 2
49304: IFFALSE 49388
// for i = 1 to tigers do
49306: LD_ADDR_VAR 0 11
49310: PUSH
49311: DOUBLE
49312: LD_INT 1
49314: DEC
49315: ST_TO_ADDR
49316: LD_VAR 0 2
49320: PUSH
49321: FOR_TO
49322: IFFALSE 49386
// begin hc_class = class_tiger ;
49324: LD_ADDR_OWVAR 28
49328: PUSH
49329: LD_INT 14
49331: ST_TO_ADDR
// hc_gallery =  ;
49332: LD_ADDR_OWVAR 33
49336: PUSH
49337: LD_STRING 
49339: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49340: LD_ADDR_OWVAR 35
49344: PUSH
49345: LD_INT 7
49347: NEG
49348: PPUSH
49349: LD_INT 7
49351: PPUSH
49352: CALL_OW 12
49356: ST_TO_ADDR
// animal := CreateHuman ;
49357: LD_ADDR_VAR 0 12
49361: PUSH
49362: CALL_OW 44
49366: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49367: LD_VAR 0 12
49371: PPUSH
49372: LD_VAR 0 8
49376: PPUSH
49377: LD_INT 0
49379: PPUSH
49380: CALL 55903 0 3
// end ;
49384: GO 49321
49386: POP
49387: POP
// if apemans then
49388: LD_VAR 0 3
49392: IFFALSE 49515
// for i = 1 to apemans do
49394: LD_ADDR_VAR 0 11
49398: PUSH
49399: DOUBLE
49400: LD_INT 1
49402: DEC
49403: ST_TO_ADDR
49404: LD_VAR 0 3
49408: PUSH
49409: FOR_TO
49410: IFFALSE 49513
// begin hc_class = class_apeman ;
49412: LD_ADDR_OWVAR 28
49416: PUSH
49417: LD_INT 12
49419: ST_TO_ADDR
// hc_gallery =  ;
49420: LD_ADDR_OWVAR 33
49424: PUSH
49425: LD_STRING 
49427: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
49428: LD_ADDR_OWVAR 35
49432: PUSH
49433: LD_INT 5
49435: NEG
49436: PPUSH
49437: LD_INT 5
49439: PPUSH
49440: CALL_OW 12
49444: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49445: LD_ADDR_OWVAR 31
49449: PUSH
49450: LD_INT 1
49452: PPUSH
49453: LD_INT 3
49455: PPUSH
49456: CALL_OW 12
49460: PUSH
49461: LD_INT 1
49463: PPUSH
49464: LD_INT 3
49466: PPUSH
49467: CALL_OW 12
49471: PUSH
49472: LD_INT 0
49474: PUSH
49475: LD_INT 0
49477: PUSH
49478: EMPTY
49479: LIST
49480: LIST
49481: LIST
49482: LIST
49483: ST_TO_ADDR
// animal := CreateHuman ;
49484: LD_ADDR_VAR 0 12
49488: PUSH
49489: CALL_OW 44
49493: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49494: LD_VAR 0 12
49498: PPUSH
49499: LD_VAR 0 8
49503: PPUSH
49504: LD_INT 0
49506: PPUSH
49507: CALL 55903 0 3
// end ;
49511: GO 49409
49513: POP
49514: POP
// if enchidnas then
49515: LD_VAR 0 4
49519: IFFALSE 49586
// for i = 1 to enchidnas do
49521: LD_ADDR_VAR 0 11
49525: PUSH
49526: DOUBLE
49527: LD_INT 1
49529: DEC
49530: ST_TO_ADDR
49531: LD_VAR 0 4
49535: PUSH
49536: FOR_TO
49537: IFFALSE 49584
// begin hc_class = 13 ;
49539: LD_ADDR_OWVAR 28
49543: PUSH
49544: LD_INT 13
49546: ST_TO_ADDR
// hc_gallery =  ;
49547: LD_ADDR_OWVAR 33
49551: PUSH
49552: LD_STRING 
49554: ST_TO_ADDR
// animal := CreateHuman ;
49555: LD_ADDR_VAR 0 12
49559: PUSH
49560: CALL_OW 44
49564: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49565: LD_VAR 0 12
49569: PPUSH
49570: LD_VAR 0 8
49574: PPUSH
49575: LD_INT 0
49577: PPUSH
49578: CALL 55903 0 3
// end ;
49582: GO 49536
49584: POP
49585: POP
// if fishes then
49586: LD_VAR 0 7
49590: IFFALSE 49657
// for i = 1 to fishes do
49592: LD_ADDR_VAR 0 11
49596: PUSH
49597: DOUBLE
49598: LD_INT 1
49600: DEC
49601: ST_TO_ADDR
49602: LD_VAR 0 7
49606: PUSH
49607: FOR_TO
49608: IFFALSE 49655
// begin hc_class = 20 ;
49610: LD_ADDR_OWVAR 28
49614: PUSH
49615: LD_INT 20
49617: ST_TO_ADDR
// hc_gallery =  ;
49618: LD_ADDR_OWVAR 33
49622: PUSH
49623: LD_STRING 
49625: ST_TO_ADDR
// animal := CreateHuman ;
49626: LD_ADDR_VAR 0 12
49630: PUSH
49631: CALL_OW 44
49635: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49636: LD_VAR 0 12
49640: PPUSH
49641: LD_VAR 0 9
49645: PPUSH
49646: LD_INT 0
49648: PPUSH
49649: CALL 55903 0 3
// end ;
49653: GO 49607
49655: POP
49656: POP
// end ;
49657: LD_VAR 0 10
49661: RET
// export function WantHeal ( sci , unit ) ; begin
49662: LD_INT 0
49664: PPUSH
// if GetTaskList ( sci ) > 0 then
49665: LD_VAR 0 1
49669: PPUSH
49670: CALL_OW 437
49674: PUSH
49675: LD_INT 0
49677: GREATER
49678: IFFALSE 49748
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49680: LD_VAR 0 1
49684: PPUSH
49685: CALL_OW 437
49689: PUSH
49690: LD_INT 1
49692: ARRAY
49693: PUSH
49694: LD_INT 1
49696: ARRAY
49697: PUSH
49698: LD_STRING l
49700: EQUAL
49701: PUSH
49702: LD_VAR 0 1
49706: PPUSH
49707: CALL_OW 437
49711: PUSH
49712: LD_INT 1
49714: ARRAY
49715: PUSH
49716: LD_INT 4
49718: ARRAY
49719: PUSH
49720: LD_VAR 0 2
49724: EQUAL
49725: AND
49726: IFFALSE 49738
// result := true else
49728: LD_ADDR_VAR 0 3
49732: PUSH
49733: LD_INT 1
49735: ST_TO_ADDR
49736: GO 49746
// result := false ;
49738: LD_ADDR_VAR 0 3
49742: PUSH
49743: LD_INT 0
49745: ST_TO_ADDR
// end else
49746: GO 49756
// result := false ;
49748: LD_ADDR_VAR 0 3
49752: PUSH
49753: LD_INT 0
49755: ST_TO_ADDR
// end ;
49756: LD_VAR 0 3
49760: RET
// export function HealTarget ( sci ) ; begin
49761: LD_INT 0
49763: PPUSH
// if not sci then
49764: LD_VAR 0 1
49768: NOT
49769: IFFALSE 49773
// exit ;
49771: GO 49838
// result := 0 ;
49773: LD_ADDR_VAR 0 2
49777: PUSH
49778: LD_INT 0
49780: ST_TO_ADDR
// if GetTaskList ( sci ) then
49781: LD_VAR 0 1
49785: PPUSH
49786: CALL_OW 437
49790: IFFALSE 49838
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49792: LD_VAR 0 1
49796: PPUSH
49797: CALL_OW 437
49801: PUSH
49802: LD_INT 1
49804: ARRAY
49805: PUSH
49806: LD_INT 1
49808: ARRAY
49809: PUSH
49810: LD_STRING l
49812: EQUAL
49813: IFFALSE 49838
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49815: LD_ADDR_VAR 0 2
49819: PUSH
49820: LD_VAR 0 1
49824: PPUSH
49825: CALL_OW 437
49829: PUSH
49830: LD_INT 1
49832: ARRAY
49833: PUSH
49834: LD_INT 4
49836: ARRAY
49837: ST_TO_ADDR
// end ;
49838: LD_VAR 0 2
49842: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
49843: LD_INT 0
49845: PPUSH
49846: PPUSH
49847: PPUSH
49848: PPUSH
49849: PPUSH
49850: PPUSH
49851: PPUSH
49852: PPUSH
49853: PPUSH
49854: PPUSH
49855: PPUSH
49856: PPUSH
49857: PPUSH
49858: PPUSH
49859: PPUSH
49860: PPUSH
49861: PPUSH
49862: PPUSH
49863: PPUSH
49864: PPUSH
49865: PPUSH
49866: PPUSH
49867: PPUSH
49868: PPUSH
49869: PPUSH
49870: PPUSH
49871: PPUSH
49872: PPUSH
49873: PPUSH
49874: PPUSH
49875: PPUSH
49876: PPUSH
49877: PPUSH
49878: PPUSH
// if not list then
49879: LD_VAR 0 1
49883: NOT
49884: IFFALSE 49888
// exit ;
49886: GO 54514
// base := list [ 1 ] ;
49888: LD_ADDR_VAR 0 3
49892: PUSH
49893: LD_VAR 0 1
49897: PUSH
49898: LD_INT 1
49900: ARRAY
49901: ST_TO_ADDR
// group := list [ 2 ] ;
49902: LD_ADDR_VAR 0 4
49906: PUSH
49907: LD_VAR 0 1
49911: PUSH
49912: LD_INT 2
49914: ARRAY
49915: ST_TO_ADDR
// path := list [ 3 ] ;
49916: LD_ADDR_VAR 0 5
49920: PUSH
49921: LD_VAR 0 1
49925: PUSH
49926: LD_INT 3
49928: ARRAY
49929: ST_TO_ADDR
// flags := list [ 4 ] ;
49930: LD_ADDR_VAR 0 6
49934: PUSH
49935: LD_VAR 0 1
49939: PUSH
49940: LD_INT 4
49942: ARRAY
49943: ST_TO_ADDR
// mined := [ ] ;
49944: LD_ADDR_VAR 0 27
49948: PUSH
49949: EMPTY
49950: ST_TO_ADDR
// bombed := [ ] ;
49951: LD_ADDR_VAR 0 28
49955: PUSH
49956: EMPTY
49957: ST_TO_ADDR
// healers := [ ] ;
49958: LD_ADDR_VAR 0 31
49962: PUSH
49963: EMPTY
49964: ST_TO_ADDR
// to_heal := [ ] ;
49965: LD_ADDR_VAR 0 30
49969: PUSH
49970: EMPTY
49971: ST_TO_ADDR
// repairs := [ ] ;
49972: LD_ADDR_VAR 0 33
49976: PUSH
49977: EMPTY
49978: ST_TO_ADDR
// to_repair := [ ] ;
49979: LD_ADDR_VAR 0 32
49983: PUSH
49984: EMPTY
49985: ST_TO_ADDR
// if not group or not path then
49986: LD_VAR 0 4
49990: NOT
49991: PUSH
49992: LD_VAR 0 5
49996: NOT
49997: OR
49998: IFFALSE 50002
// exit ;
50000: GO 54514
// side := GetSide ( group [ 1 ] ) ;
50002: LD_ADDR_VAR 0 35
50006: PUSH
50007: LD_VAR 0 4
50011: PUSH
50012: LD_INT 1
50014: ARRAY
50015: PPUSH
50016: CALL_OW 255
50020: ST_TO_ADDR
// if flags then
50021: LD_VAR 0 6
50025: IFFALSE 50169
// begin f_ignore_area := flags [ 1 ] ;
50027: LD_ADDR_VAR 0 17
50031: PUSH
50032: LD_VAR 0 6
50036: PUSH
50037: LD_INT 1
50039: ARRAY
50040: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
50041: LD_ADDR_VAR 0 18
50045: PUSH
50046: LD_VAR 0 6
50050: PUSH
50051: LD_INT 2
50053: ARRAY
50054: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
50055: LD_ADDR_VAR 0 19
50059: PUSH
50060: LD_VAR 0 6
50064: PUSH
50065: LD_INT 3
50067: ARRAY
50068: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
50069: LD_ADDR_VAR 0 20
50073: PUSH
50074: LD_VAR 0 6
50078: PUSH
50079: LD_INT 4
50081: ARRAY
50082: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
50083: LD_ADDR_VAR 0 21
50087: PUSH
50088: LD_VAR 0 6
50092: PUSH
50093: LD_INT 5
50095: ARRAY
50096: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
50097: LD_ADDR_VAR 0 22
50101: PUSH
50102: LD_VAR 0 6
50106: PUSH
50107: LD_INT 6
50109: ARRAY
50110: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
50111: LD_ADDR_VAR 0 23
50115: PUSH
50116: LD_VAR 0 6
50120: PUSH
50121: LD_INT 7
50123: ARRAY
50124: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
50125: LD_ADDR_VAR 0 24
50129: PUSH
50130: LD_VAR 0 6
50134: PUSH
50135: LD_INT 8
50137: ARRAY
50138: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
50139: LD_ADDR_VAR 0 25
50143: PUSH
50144: LD_VAR 0 6
50148: PUSH
50149: LD_INT 9
50151: ARRAY
50152: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
50153: LD_ADDR_VAR 0 26
50157: PUSH
50158: LD_VAR 0 6
50162: PUSH
50163: LD_INT 10
50165: ARRAY
50166: ST_TO_ADDR
// end else
50167: GO 50249
// begin f_ignore_area := false ;
50169: LD_ADDR_VAR 0 17
50173: PUSH
50174: LD_INT 0
50176: ST_TO_ADDR
// f_capture := false ;
50177: LD_ADDR_VAR 0 18
50181: PUSH
50182: LD_INT 0
50184: ST_TO_ADDR
// f_ignore_civ := false ;
50185: LD_ADDR_VAR 0 19
50189: PUSH
50190: LD_INT 0
50192: ST_TO_ADDR
// f_murder := false ;
50193: LD_ADDR_VAR 0 20
50197: PUSH
50198: LD_INT 0
50200: ST_TO_ADDR
// f_mines := false ;
50201: LD_ADDR_VAR 0 21
50205: PUSH
50206: LD_INT 0
50208: ST_TO_ADDR
// f_repair := false ;
50209: LD_ADDR_VAR 0 22
50213: PUSH
50214: LD_INT 0
50216: ST_TO_ADDR
// f_heal := false ;
50217: LD_ADDR_VAR 0 23
50221: PUSH
50222: LD_INT 0
50224: ST_TO_ADDR
// f_spacetime := false ;
50225: LD_ADDR_VAR 0 24
50229: PUSH
50230: LD_INT 0
50232: ST_TO_ADDR
// f_attack_depot := false ;
50233: LD_ADDR_VAR 0 25
50237: PUSH
50238: LD_INT 0
50240: ST_TO_ADDR
// f_crawl := false ;
50241: LD_ADDR_VAR 0 26
50245: PUSH
50246: LD_INT 0
50248: ST_TO_ADDR
// end ; if f_heal then
50249: LD_VAR 0 23
50253: IFFALSE 50280
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
50255: LD_ADDR_VAR 0 31
50259: PUSH
50260: LD_VAR 0 4
50264: PPUSH
50265: LD_INT 25
50267: PUSH
50268: LD_INT 4
50270: PUSH
50271: EMPTY
50272: LIST
50273: LIST
50274: PPUSH
50275: CALL_OW 72
50279: ST_TO_ADDR
// if f_repair then
50280: LD_VAR 0 22
50284: IFFALSE 50311
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
50286: LD_ADDR_VAR 0 33
50290: PUSH
50291: LD_VAR 0 4
50295: PPUSH
50296: LD_INT 25
50298: PUSH
50299: LD_INT 3
50301: PUSH
50302: EMPTY
50303: LIST
50304: LIST
50305: PPUSH
50306: CALL_OW 72
50310: ST_TO_ADDR
// units_path := [ ] ;
50311: LD_ADDR_VAR 0 16
50315: PUSH
50316: EMPTY
50317: ST_TO_ADDR
// for i = 1 to group do
50318: LD_ADDR_VAR 0 7
50322: PUSH
50323: DOUBLE
50324: LD_INT 1
50326: DEC
50327: ST_TO_ADDR
50328: LD_VAR 0 4
50332: PUSH
50333: FOR_TO
50334: IFFALSE 50363
// units_path := Replace ( units_path , i , path ) ;
50336: LD_ADDR_VAR 0 16
50340: PUSH
50341: LD_VAR 0 16
50345: PPUSH
50346: LD_VAR 0 7
50350: PPUSH
50351: LD_VAR 0 5
50355: PPUSH
50356: CALL_OW 1
50360: ST_TO_ADDR
50361: GO 50333
50363: POP
50364: POP
// repeat for i = group downto 1 do
50365: LD_ADDR_VAR 0 7
50369: PUSH
50370: DOUBLE
50371: LD_VAR 0 4
50375: INC
50376: ST_TO_ADDR
50377: LD_INT 1
50379: PUSH
50380: FOR_DOWNTO
50381: IFFALSE 54477
// begin wait ( 5 ) ;
50383: LD_INT 5
50385: PPUSH
50386: CALL_OW 67
// tmp := [ ] ;
50390: LD_ADDR_VAR 0 14
50394: PUSH
50395: EMPTY
50396: ST_TO_ADDR
// attacking := false ;
50397: LD_ADDR_VAR 0 29
50401: PUSH
50402: LD_INT 0
50404: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
50405: LD_VAR 0 4
50409: PUSH
50410: LD_VAR 0 7
50414: ARRAY
50415: PPUSH
50416: CALL_OW 301
50420: PUSH
50421: LD_VAR 0 4
50425: PUSH
50426: LD_VAR 0 7
50430: ARRAY
50431: NOT
50432: OR
50433: IFFALSE 50542
// begin if GetType ( group [ i ] ) = unit_human then
50435: LD_VAR 0 4
50439: PUSH
50440: LD_VAR 0 7
50444: ARRAY
50445: PPUSH
50446: CALL_OW 247
50450: PUSH
50451: LD_INT 1
50453: EQUAL
50454: IFFALSE 50500
// begin to_heal := to_heal diff group [ i ] ;
50456: LD_ADDR_VAR 0 30
50460: PUSH
50461: LD_VAR 0 30
50465: PUSH
50466: LD_VAR 0 4
50470: PUSH
50471: LD_VAR 0 7
50475: ARRAY
50476: DIFF
50477: ST_TO_ADDR
// healers := healers diff group [ i ] ;
50478: LD_ADDR_VAR 0 31
50482: PUSH
50483: LD_VAR 0 31
50487: PUSH
50488: LD_VAR 0 4
50492: PUSH
50493: LD_VAR 0 7
50497: ARRAY
50498: DIFF
50499: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
50500: LD_ADDR_VAR 0 4
50504: PUSH
50505: LD_VAR 0 4
50509: PPUSH
50510: LD_VAR 0 7
50514: PPUSH
50515: CALL_OW 3
50519: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
50520: LD_ADDR_VAR 0 16
50524: PUSH
50525: LD_VAR 0 16
50529: PPUSH
50530: LD_VAR 0 7
50534: PPUSH
50535: CALL_OW 3
50539: ST_TO_ADDR
// continue ;
50540: GO 50380
// end ; if f_repair then
50542: LD_VAR 0 22
50546: IFFALSE 51035
// begin if GetType ( group [ i ] ) = unit_vehicle then
50548: LD_VAR 0 4
50552: PUSH
50553: LD_VAR 0 7
50557: ARRAY
50558: PPUSH
50559: CALL_OW 247
50563: PUSH
50564: LD_INT 2
50566: EQUAL
50567: IFFALSE 50757
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
50569: LD_VAR 0 4
50573: PUSH
50574: LD_VAR 0 7
50578: ARRAY
50579: PPUSH
50580: CALL_OW 256
50584: PUSH
50585: LD_INT 700
50587: LESS
50588: PUSH
50589: LD_VAR 0 4
50593: PUSH
50594: LD_VAR 0 7
50598: ARRAY
50599: PUSH
50600: LD_VAR 0 32
50604: IN
50605: NOT
50606: AND
50607: IFFALSE 50631
// to_repair := to_repair union group [ i ] ;
50609: LD_ADDR_VAR 0 32
50613: PUSH
50614: LD_VAR 0 32
50618: PUSH
50619: LD_VAR 0 4
50623: PUSH
50624: LD_VAR 0 7
50628: ARRAY
50629: UNION
50630: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
50631: LD_VAR 0 4
50635: PUSH
50636: LD_VAR 0 7
50640: ARRAY
50641: PPUSH
50642: CALL_OW 256
50646: PUSH
50647: LD_INT 1000
50649: EQUAL
50650: PUSH
50651: LD_VAR 0 4
50655: PUSH
50656: LD_VAR 0 7
50660: ARRAY
50661: PUSH
50662: LD_VAR 0 32
50666: IN
50667: AND
50668: IFFALSE 50692
// to_repair := to_repair diff group [ i ] ;
50670: LD_ADDR_VAR 0 32
50674: PUSH
50675: LD_VAR 0 32
50679: PUSH
50680: LD_VAR 0 4
50684: PUSH
50685: LD_VAR 0 7
50689: ARRAY
50690: DIFF
50691: ST_TO_ADDR
// if group [ i ] in to_repair then
50692: LD_VAR 0 4
50696: PUSH
50697: LD_VAR 0 7
50701: ARRAY
50702: PUSH
50703: LD_VAR 0 32
50707: IN
50708: IFFALSE 50755
// begin if not IsInArea ( group [ i ] , f_repair ) then
50710: LD_VAR 0 4
50714: PUSH
50715: LD_VAR 0 7
50719: ARRAY
50720: PPUSH
50721: LD_VAR 0 22
50725: PPUSH
50726: CALL_OW 308
50730: NOT
50731: IFFALSE 50753
// ComMoveToArea ( group [ i ] , f_repair ) ;
50733: LD_VAR 0 4
50737: PUSH
50738: LD_VAR 0 7
50742: ARRAY
50743: PPUSH
50744: LD_VAR 0 22
50748: PPUSH
50749: CALL_OW 113
// continue ;
50753: GO 50380
// end ; end else
50755: GO 51035
// if group [ i ] in repairs then
50757: LD_VAR 0 4
50761: PUSH
50762: LD_VAR 0 7
50766: ARRAY
50767: PUSH
50768: LD_VAR 0 33
50772: IN
50773: IFFALSE 51035
// begin if IsInUnit ( group [ i ] ) then
50775: LD_VAR 0 4
50779: PUSH
50780: LD_VAR 0 7
50784: ARRAY
50785: PPUSH
50786: CALL_OW 310
50790: IFFALSE 50858
// begin z := IsInUnit ( group [ i ] ) ;
50792: LD_ADDR_VAR 0 13
50796: PUSH
50797: LD_VAR 0 4
50801: PUSH
50802: LD_VAR 0 7
50806: ARRAY
50807: PPUSH
50808: CALL_OW 310
50812: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
50813: LD_VAR 0 13
50817: PUSH
50818: LD_VAR 0 32
50822: IN
50823: PUSH
50824: LD_VAR 0 13
50828: PPUSH
50829: LD_VAR 0 22
50833: PPUSH
50834: CALL_OW 308
50838: AND
50839: IFFALSE 50856
// ComExitVehicle ( group [ i ] ) ;
50841: LD_VAR 0 4
50845: PUSH
50846: LD_VAR 0 7
50850: ARRAY
50851: PPUSH
50852: CALL_OW 121
// end else
50856: GO 51035
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
50858: LD_ADDR_VAR 0 13
50862: PUSH
50863: LD_VAR 0 4
50867: PPUSH
50868: LD_INT 95
50870: PUSH
50871: LD_VAR 0 22
50875: PUSH
50876: EMPTY
50877: LIST
50878: LIST
50879: PUSH
50880: LD_INT 58
50882: PUSH
50883: EMPTY
50884: LIST
50885: PUSH
50886: EMPTY
50887: LIST
50888: LIST
50889: PPUSH
50890: CALL_OW 72
50894: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
50895: LD_VAR 0 4
50899: PUSH
50900: LD_VAR 0 7
50904: ARRAY
50905: PPUSH
50906: CALL_OW 314
50910: NOT
50911: IFFALSE 51033
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
50913: LD_ADDR_VAR 0 10
50917: PUSH
50918: LD_VAR 0 13
50922: PPUSH
50923: LD_VAR 0 4
50927: PUSH
50928: LD_VAR 0 7
50932: ARRAY
50933: PPUSH
50934: CALL_OW 74
50938: ST_TO_ADDR
// if not x then
50939: LD_VAR 0 10
50943: NOT
50944: IFFALSE 50948
// continue ;
50946: GO 50380
// if GetLives ( x ) < 1000 then
50948: LD_VAR 0 10
50952: PPUSH
50953: CALL_OW 256
50957: PUSH
50958: LD_INT 1000
50960: LESS
50961: IFFALSE 50985
// ComRepairVehicle ( group [ i ] , x ) else
50963: LD_VAR 0 4
50967: PUSH
50968: LD_VAR 0 7
50972: ARRAY
50973: PPUSH
50974: LD_VAR 0 10
50978: PPUSH
50979: CALL_OW 129
50983: GO 51033
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
50985: LD_VAR 0 23
50989: PUSH
50990: LD_VAR 0 4
50994: PUSH
50995: LD_VAR 0 7
50999: ARRAY
51000: PPUSH
51001: CALL_OW 256
51005: PUSH
51006: LD_INT 1000
51008: LESS
51009: AND
51010: NOT
51011: IFFALSE 51033
// ComEnterUnit ( group [ i ] , x ) ;
51013: LD_VAR 0 4
51017: PUSH
51018: LD_VAR 0 7
51022: ARRAY
51023: PPUSH
51024: LD_VAR 0 10
51028: PPUSH
51029: CALL_OW 120
// end ; continue ;
51033: GO 50380
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
51035: LD_VAR 0 23
51039: PUSH
51040: LD_VAR 0 4
51044: PUSH
51045: LD_VAR 0 7
51049: ARRAY
51050: PPUSH
51051: CALL_OW 247
51055: PUSH
51056: LD_INT 1
51058: EQUAL
51059: AND
51060: IFFALSE 51538
// begin if group [ i ] in healers then
51062: LD_VAR 0 4
51066: PUSH
51067: LD_VAR 0 7
51071: ARRAY
51072: PUSH
51073: LD_VAR 0 31
51077: IN
51078: IFFALSE 51351
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
51080: LD_VAR 0 4
51084: PUSH
51085: LD_VAR 0 7
51089: ARRAY
51090: PPUSH
51091: LD_VAR 0 23
51095: PPUSH
51096: CALL_OW 308
51100: NOT
51101: PUSH
51102: LD_VAR 0 4
51106: PUSH
51107: LD_VAR 0 7
51111: ARRAY
51112: PPUSH
51113: CALL_OW 314
51117: NOT
51118: AND
51119: IFFALSE 51143
// ComMoveToArea ( group [ i ] , f_heal ) else
51121: LD_VAR 0 4
51125: PUSH
51126: LD_VAR 0 7
51130: ARRAY
51131: PPUSH
51132: LD_VAR 0 23
51136: PPUSH
51137: CALL_OW 113
51141: GO 51349
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
51143: LD_VAR 0 4
51147: PUSH
51148: LD_VAR 0 7
51152: ARRAY
51153: PPUSH
51154: CALL 49761 0 1
51158: PPUSH
51159: CALL_OW 256
51163: PUSH
51164: LD_INT 1000
51166: EQUAL
51167: IFFALSE 51186
// ComStop ( group [ i ] ) else
51169: LD_VAR 0 4
51173: PUSH
51174: LD_VAR 0 7
51178: ARRAY
51179: PPUSH
51180: CALL_OW 141
51184: GO 51349
// if not HasTask ( group [ i ] ) and to_heal then
51186: LD_VAR 0 4
51190: PUSH
51191: LD_VAR 0 7
51195: ARRAY
51196: PPUSH
51197: CALL_OW 314
51201: NOT
51202: PUSH
51203: LD_VAR 0 30
51207: AND
51208: IFFALSE 51349
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
51210: LD_ADDR_VAR 0 13
51214: PUSH
51215: LD_VAR 0 30
51219: PPUSH
51220: LD_INT 3
51222: PUSH
51223: LD_INT 54
51225: PUSH
51226: EMPTY
51227: LIST
51228: PUSH
51229: EMPTY
51230: LIST
51231: LIST
51232: PPUSH
51233: CALL_OW 72
51237: PPUSH
51238: LD_VAR 0 4
51242: PUSH
51243: LD_VAR 0 7
51247: ARRAY
51248: PPUSH
51249: CALL_OW 74
51253: ST_TO_ADDR
// if z then
51254: LD_VAR 0 13
51258: IFFALSE 51349
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
51260: LD_INT 91
51262: PUSH
51263: LD_VAR 0 13
51267: PUSH
51268: LD_INT 10
51270: PUSH
51271: EMPTY
51272: LIST
51273: LIST
51274: LIST
51275: PUSH
51276: LD_INT 81
51278: PUSH
51279: LD_VAR 0 13
51283: PPUSH
51284: CALL_OW 255
51288: PUSH
51289: EMPTY
51290: LIST
51291: LIST
51292: PUSH
51293: EMPTY
51294: LIST
51295: LIST
51296: PPUSH
51297: CALL_OW 69
51301: PUSH
51302: LD_INT 0
51304: EQUAL
51305: IFFALSE 51329
// ComHeal ( group [ i ] , z ) else
51307: LD_VAR 0 4
51311: PUSH
51312: LD_VAR 0 7
51316: ARRAY
51317: PPUSH
51318: LD_VAR 0 13
51322: PPUSH
51323: CALL_OW 128
51327: GO 51349
// ComMoveToArea ( group [ i ] , f_heal ) ;
51329: LD_VAR 0 4
51333: PUSH
51334: LD_VAR 0 7
51338: ARRAY
51339: PPUSH
51340: LD_VAR 0 23
51344: PPUSH
51345: CALL_OW 113
// end ; continue ;
51349: GO 50380
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
51351: LD_VAR 0 4
51355: PUSH
51356: LD_VAR 0 7
51360: ARRAY
51361: PPUSH
51362: CALL_OW 256
51366: PUSH
51367: LD_INT 700
51369: LESS
51370: PUSH
51371: LD_VAR 0 4
51375: PUSH
51376: LD_VAR 0 7
51380: ARRAY
51381: PUSH
51382: LD_VAR 0 30
51386: IN
51387: NOT
51388: AND
51389: IFFALSE 51413
// to_heal := to_heal union group [ i ] ;
51391: LD_ADDR_VAR 0 30
51395: PUSH
51396: LD_VAR 0 30
51400: PUSH
51401: LD_VAR 0 4
51405: PUSH
51406: LD_VAR 0 7
51410: ARRAY
51411: UNION
51412: ST_TO_ADDR
// if group [ i ] in to_heal then
51413: LD_VAR 0 4
51417: PUSH
51418: LD_VAR 0 7
51422: ARRAY
51423: PUSH
51424: LD_VAR 0 30
51428: IN
51429: IFFALSE 51538
// begin if GetLives ( group [ i ] ) = 1000 then
51431: LD_VAR 0 4
51435: PUSH
51436: LD_VAR 0 7
51440: ARRAY
51441: PPUSH
51442: CALL_OW 256
51446: PUSH
51447: LD_INT 1000
51449: EQUAL
51450: IFFALSE 51476
// to_heal := to_heal diff group [ i ] else
51452: LD_ADDR_VAR 0 30
51456: PUSH
51457: LD_VAR 0 30
51461: PUSH
51462: LD_VAR 0 4
51466: PUSH
51467: LD_VAR 0 7
51471: ARRAY
51472: DIFF
51473: ST_TO_ADDR
51474: GO 51538
// begin if not IsInArea ( group [ i ] , to_heal ) then
51476: LD_VAR 0 4
51480: PUSH
51481: LD_VAR 0 7
51485: ARRAY
51486: PPUSH
51487: LD_VAR 0 30
51491: PPUSH
51492: CALL_OW 308
51496: NOT
51497: IFFALSE 51521
// ComMoveToArea ( group [ i ] , f_heal ) else
51499: LD_VAR 0 4
51503: PUSH
51504: LD_VAR 0 7
51508: ARRAY
51509: PPUSH
51510: LD_VAR 0 23
51514: PPUSH
51515: CALL_OW 113
51519: GO 51536
// ComHold ( group [ i ] ) ;
51521: LD_VAR 0 4
51525: PUSH
51526: LD_VAR 0 7
51530: ARRAY
51531: PPUSH
51532: CALL_OW 140
// continue ;
51536: GO 50380
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
51538: LD_VAR 0 4
51542: PUSH
51543: LD_VAR 0 7
51547: ARRAY
51548: PPUSH
51549: LD_INT 10
51551: PPUSH
51552: CALL 48158 0 2
51556: NOT
51557: PUSH
51558: LD_VAR 0 16
51562: PUSH
51563: LD_VAR 0 7
51567: ARRAY
51568: PUSH
51569: EMPTY
51570: EQUAL
51571: NOT
51572: AND
51573: IFFALSE 51839
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
51575: LD_VAR 0 4
51579: PUSH
51580: LD_VAR 0 7
51584: ARRAY
51585: PPUSH
51586: CALL_OW 262
51590: PUSH
51591: LD_INT 1
51593: PUSH
51594: LD_INT 2
51596: PUSH
51597: EMPTY
51598: LIST
51599: LIST
51600: IN
51601: IFFALSE 51642
// if GetFuel ( group [ i ] ) < 10 then
51603: LD_VAR 0 4
51607: PUSH
51608: LD_VAR 0 7
51612: ARRAY
51613: PPUSH
51614: CALL_OW 261
51618: PUSH
51619: LD_INT 10
51621: LESS
51622: IFFALSE 51642
// SetFuel ( group [ i ] , 12 ) ;
51624: LD_VAR 0 4
51628: PUSH
51629: LD_VAR 0 7
51633: ARRAY
51634: PPUSH
51635: LD_INT 12
51637: PPUSH
51638: CALL_OW 240
// if units_path [ i ] then
51642: LD_VAR 0 16
51646: PUSH
51647: LD_VAR 0 7
51651: ARRAY
51652: IFFALSE 51837
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
51654: LD_VAR 0 4
51658: PUSH
51659: LD_VAR 0 7
51663: ARRAY
51664: PPUSH
51665: LD_VAR 0 16
51669: PUSH
51670: LD_VAR 0 7
51674: ARRAY
51675: PUSH
51676: LD_INT 1
51678: ARRAY
51679: PUSH
51680: LD_INT 1
51682: ARRAY
51683: PPUSH
51684: LD_VAR 0 16
51688: PUSH
51689: LD_VAR 0 7
51693: ARRAY
51694: PUSH
51695: LD_INT 1
51697: ARRAY
51698: PUSH
51699: LD_INT 2
51701: ARRAY
51702: PPUSH
51703: CALL_OW 297
51707: PUSH
51708: LD_INT 6
51710: GREATER
51711: IFFALSE 51786
// begin if not HasTask ( group [ i ] ) then
51713: LD_VAR 0 4
51717: PUSH
51718: LD_VAR 0 7
51722: ARRAY
51723: PPUSH
51724: CALL_OW 314
51728: NOT
51729: IFFALSE 51784
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
51731: LD_VAR 0 4
51735: PUSH
51736: LD_VAR 0 7
51740: ARRAY
51741: PPUSH
51742: LD_VAR 0 16
51746: PUSH
51747: LD_VAR 0 7
51751: ARRAY
51752: PUSH
51753: LD_INT 1
51755: ARRAY
51756: PUSH
51757: LD_INT 1
51759: ARRAY
51760: PPUSH
51761: LD_VAR 0 16
51765: PUSH
51766: LD_VAR 0 7
51770: ARRAY
51771: PUSH
51772: LD_INT 1
51774: ARRAY
51775: PUSH
51776: LD_INT 2
51778: ARRAY
51779: PPUSH
51780: CALL_OW 114
// end else
51784: GO 51837
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
51786: LD_ADDR_VAR 0 15
51790: PUSH
51791: LD_VAR 0 16
51795: PUSH
51796: LD_VAR 0 7
51800: ARRAY
51801: PPUSH
51802: LD_INT 1
51804: PPUSH
51805: CALL_OW 3
51809: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
51810: LD_ADDR_VAR 0 16
51814: PUSH
51815: LD_VAR 0 16
51819: PPUSH
51820: LD_VAR 0 7
51824: PPUSH
51825: LD_VAR 0 15
51829: PPUSH
51830: CALL_OW 1
51834: ST_TO_ADDR
// continue ;
51835: GO 50380
// end ; end ; end else
51837: GO 54475
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
51839: LD_ADDR_VAR 0 14
51843: PUSH
51844: LD_INT 81
51846: PUSH
51847: LD_VAR 0 4
51851: PUSH
51852: LD_VAR 0 7
51856: ARRAY
51857: PPUSH
51858: CALL_OW 255
51862: PUSH
51863: EMPTY
51864: LIST
51865: LIST
51866: PPUSH
51867: CALL_OW 69
51871: ST_TO_ADDR
// if not tmp then
51872: LD_VAR 0 14
51876: NOT
51877: IFFALSE 51881
// continue ;
51879: GO 50380
// if f_ignore_area then
51881: LD_VAR 0 17
51885: IFFALSE 51973
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
51887: LD_ADDR_VAR 0 15
51891: PUSH
51892: LD_VAR 0 14
51896: PPUSH
51897: LD_INT 3
51899: PUSH
51900: LD_INT 92
51902: PUSH
51903: LD_VAR 0 17
51907: PUSH
51908: LD_INT 1
51910: ARRAY
51911: PUSH
51912: LD_VAR 0 17
51916: PUSH
51917: LD_INT 2
51919: ARRAY
51920: PUSH
51921: LD_VAR 0 17
51925: PUSH
51926: LD_INT 3
51928: ARRAY
51929: PUSH
51930: EMPTY
51931: LIST
51932: LIST
51933: LIST
51934: LIST
51935: PUSH
51936: EMPTY
51937: LIST
51938: LIST
51939: PPUSH
51940: CALL_OW 72
51944: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51945: LD_VAR 0 14
51949: PUSH
51950: LD_VAR 0 15
51954: DIFF
51955: IFFALSE 51973
// tmp := tmp diff tmp2 ;
51957: LD_ADDR_VAR 0 14
51961: PUSH
51962: LD_VAR 0 14
51966: PUSH
51967: LD_VAR 0 15
51971: DIFF
51972: ST_TO_ADDR
// end ; if not f_murder then
51973: LD_VAR 0 20
51977: NOT
51978: IFFALSE 52036
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
51980: LD_ADDR_VAR 0 15
51984: PUSH
51985: LD_VAR 0 14
51989: PPUSH
51990: LD_INT 3
51992: PUSH
51993: LD_INT 50
51995: PUSH
51996: EMPTY
51997: LIST
51998: PUSH
51999: EMPTY
52000: LIST
52001: LIST
52002: PPUSH
52003: CALL_OW 72
52007: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
52008: LD_VAR 0 14
52012: PUSH
52013: LD_VAR 0 15
52017: DIFF
52018: IFFALSE 52036
// tmp := tmp diff tmp2 ;
52020: LD_ADDR_VAR 0 14
52024: PUSH
52025: LD_VAR 0 14
52029: PUSH
52030: LD_VAR 0 15
52034: DIFF
52035: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
52036: LD_ADDR_VAR 0 14
52040: PUSH
52041: LD_VAR 0 4
52045: PUSH
52046: LD_VAR 0 7
52050: ARRAY
52051: PPUSH
52052: LD_VAR 0 14
52056: PPUSH
52057: LD_INT 1
52059: PPUSH
52060: LD_INT 1
52062: PPUSH
52063: CALL 21801 0 4
52067: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
52068: LD_VAR 0 4
52072: PUSH
52073: LD_VAR 0 7
52077: ARRAY
52078: PPUSH
52079: CALL_OW 257
52083: PUSH
52084: LD_INT 1
52086: EQUAL
52087: IFFALSE 52535
// begin if WantPlant ( group [ i ] ) then
52089: LD_VAR 0 4
52093: PUSH
52094: LD_VAR 0 7
52098: ARRAY
52099: PPUSH
52100: CALL 21302 0 1
52104: IFFALSE 52108
// continue ;
52106: GO 50380
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
52108: LD_VAR 0 18
52112: PUSH
52113: LD_VAR 0 4
52117: PUSH
52118: LD_VAR 0 7
52122: ARRAY
52123: PPUSH
52124: CALL_OW 310
52128: NOT
52129: AND
52130: PUSH
52131: LD_VAR 0 14
52135: PUSH
52136: LD_INT 1
52138: ARRAY
52139: PUSH
52140: LD_VAR 0 14
52144: PPUSH
52145: LD_INT 21
52147: PUSH
52148: LD_INT 2
52150: PUSH
52151: EMPTY
52152: LIST
52153: LIST
52154: PUSH
52155: LD_INT 58
52157: PUSH
52158: EMPTY
52159: LIST
52160: PUSH
52161: EMPTY
52162: LIST
52163: LIST
52164: PPUSH
52165: CALL_OW 72
52169: IN
52170: AND
52171: IFFALSE 52207
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
52173: LD_VAR 0 4
52177: PUSH
52178: LD_VAR 0 7
52182: ARRAY
52183: PPUSH
52184: LD_VAR 0 14
52188: PUSH
52189: LD_INT 1
52191: ARRAY
52192: PPUSH
52193: CALL_OW 120
// attacking := true ;
52197: LD_ADDR_VAR 0 29
52201: PUSH
52202: LD_INT 1
52204: ST_TO_ADDR
// continue ;
52205: GO 50380
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
52207: LD_VAR 0 26
52211: PUSH
52212: LD_VAR 0 4
52216: PUSH
52217: LD_VAR 0 7
52221: ARRAY
52222: PPUSH
52223: CALL_OW 257
52227: PUSH
52228: LD_INT 1
52230: EQUAL
52231: AND
52232: PUSH
52233: LD_VAR 0 4
52237: PUSH
52238: LD_VAR 0 7
52242: ARRAY
52243: PPUSH
52244: CALL_OW 256
52248: PUSH
52249: LD_INT 800
52251: LESS
52252: AND
52253: PUSH
52254: LD_VAR 0 4
52258: PUSH
52259: LD_VAR 0 7
52263: ARRAY
52264: PPUSH
52265: CALL_OW 318
52269: NOT
52270: AND
52271: IFFALSE 52288
// ComCrawl ( group [ i ] ) ;
52273: LD_VAR 0 4
52277: PUSH
52278: LD_VAR 0 7
52282: ARRAY
52283: PPUSH
52284: CALL_OW 137
// if f_mines then
52288: LD_VAR 0 21
52292: IFFALSE 52535
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
52294: LD_VAR 0 14
52298: PUSH
52299: LD_INT 1
52301: ARRAY
52302: PPUSH
52303: CALL_OW 247
52307: PUSH
52308: LD_INT 3
52310: EQUAL
52311: PUSH
52312: LD_VAR 0 14
52316: PUSH
52317: LD_INT 1
52319: ARRAY
52320: PUSH
52321: LD_VAR 0 27
52325: IN
52326: NOT
52327: AND
52328: IFFALSE 52535
// begin x := GetX ( tmp [ 1 ] ) ;
52330: LD_ADDR_VAR 0 10
52334: PUSH
52335: LD_VAR 0 14
52339: PUSH
52340: LD_INT 1
52342: ARRAY
52343: PPUSH
52344: CALL_OW 250
52348: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
52349: LD_ADDR_VAR 0 11
52353: PUSH
52354: LD_VAR 0 14
52358: PUSH
52359: LD_INT 1
52361: ARRAY
52362: PPUSH
52363: CALL_OW 251
52367: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
52368: LD_ADDR_VAR 0 12
52372: PUSH
52373: LD_VAR 0 4
52377: PUSH
52378: LD_VAR 0 7
52382: ARRAY
52383: PPUSH
52384: CALL 48243 0 1
52388: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
52389: LD_VAR 0 4
52393: PUSH
52394: LD_VAR 0 7
52398: ARRAY
52399: PPUSH
52400: LD_VAR 0 10
52404: PPUSH
52405: LD_VAR 0 11
52409: PPUSH
52410: LD_VAR 0 14
52414: PUSH
52415: LD_INT 1
52417: ARRAY
52418: PPUSH
52419: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
52423: LD_VAR 0 4
52427: PUSH
52428: LD_VAR 0 7
52432: ARRAY
52433: PPUSH
52434: LD_VAR 0 10
52438: PPUSH
52439: LD_VAR 0 12
52443: PPUSH
52444: LD_INT 7
52446: PPUSH
52447: CALL_OW 272
52451: PPUSH
52452: LD_VAR 0 11
52456: PPUSH
52457: LD_VAR 0 12
52461: PPUSH
52462: LD_INT 7
52464: PPUSH
52465: CALL_OW 273
52469: PPUSH
52470: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
52474: LD_VAR 0 4
52478: PUSH
52479: LD_VAR 0 7
52483: ARRAY
52484: PPUSH
52485: LD_INT 71
52487: PPUSH
52488: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
52492: LD_ADDR_VAR 0 27
52496: PUSH
52497: LD_VAR 0 27
52501: PPUSH
52502: LD_VAR 0 27
52506: PUSH
52507: LD_INT 1
52509: PLUS
52510: PPUSH
52511: LD_VAR 0 14
52515: PUSH
52516: LD_INT 1
52518: ARRAY
52519: PPUSH
52520: CALL_OW 1
52524: ST_TO_ADDR
// attacking := true ;
52525: LD_ADDR_VAR 0 29
52529: PUSH
52530: LD_INT 1
52532: ST_TO_ADDR
// continue ;
52533: GO 50380
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
52535: LD_VAR 0 4
52539: PUSH
52540: LD_VAR 0 7
52544: ARRAY
52545: PPUSH
52546: CALL_OW 257
52550: PUSH
52551: LD_INT 17
52553: EQUAL
52554: PUSH
52555: LD_VAR 0 4
52559: PUSH
52560: LD_VAR 0 7
52564: ARRAY
52565: PPUSH
52566: CALL_OW 110
52570: PUSH
52571: LD_INT 71
52573: EQUAL
52574: NOT
52575: AND
52576: IFFALSE 52722
// begin attacking := false ;
52578: LD_ADDR_VAR 0 29
52582: PUSH
52583: LD_INT 0
52585: ST_TO_ADDR
// k := 5 ;
52586: LD_ADDR_VAR 0 9
52590: PUSH
52591: LD_INT 5
52593: ST_TO_ADDR
// if tmp < k then
52594: LD_VAR 0 14
52598: PUSH
52599: LD_VAR 0 9
52603: LESS
52604: IFFALSE 52616
// k := tmp ;
52606: LD_ADDR_VAR 0 9
52610: PUSH
52611: LD_VAR 0 14
52615: ST_TO_ADDR
// for j = 1 to k do
52616: LD_ADDR_VAR 0 8
52620: PUSH
52621: DOUBLE
52622: LD_INT 1
52624: DEC
52625: ST_TO_ADDR
52626: LD_VAR 0 9
52630: PUSH
52631: FOR_TO
52632: IFFALSE 52720
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
52634: LD_VAR 0 14
52638: PUSH
52639: LD_VAR 0 8
52643: ARRAY
52644: PUSH
52645: LD_VAR 0 14
52649: PPUSH
52650: LD_INT 58
52652: PUSH
52653: EMPTY
52654: LIST
52655: PPUSH
52656: CALL_OW 72
52660: IN
52661: NOT
52662: IFFALSE 52718
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52664: LD_VAR 0 4
52668: PUSH
52669: LD_VAR 0 7
52673: ARRAY
52674: PPUSH
52675: LD_VAR 0 14
52679: PUSH
52680: LD_VAR 0 8
52684: ARRAY
52685: PPUSH
52686: CALL_OW 115
// attacking := true ;
52690: LD_ADDR_VAR 0 29
52694: PUSH
52695: LD_INT 1
52697: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
52698: LD_VAR 0 4
52702: PUSH
52703: LD_VAR 0 7
52707: ARRAY
52708: PPUSH
52709: LD_INT 71
52711: PPUSH
52712: CALL_OW 109
// continue ;
52716: GO 52631
// end ; end ;
52718: GO 52631
52720: POP
52721: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
52722: LD_VAR 0 4
52726: PUSH
52727: LD_VAR 0 7
52731: ARRAY
52732: PPUSH
52733: CALL_OW 257
52737: PUSH
52738: LD_INT 8
52740: EQUAL
52741: PUSH
52742: LD_VAR 0 4
52746: PUSH
52747: LD_VAR 0 7
52751: ARRAY
52752: PPUSH
52753: CALL_OW 264
52757: PUSH
52758: LD_INT 28
52760: PUSH
52761: LD_INT 45
52763: PUSH
52764: LD_INT 7
52766: PUSH
52767: LD_INT 47
52769: PUSH
52770: EMPTY
52771: LIST
52772: LIST
52773: LIST
52774: LIST
52775: IN
52776: OR
52777: IFFALSE 53007
// begin attacking := false ;
52779: LD_ADDR_VAR 0 29
52783: PUSH
52784: LD_INT 0
52786: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
52787: LD_VAR 0 14
52791: PUSH
52792: LD_INT 1
52794: ARRAY
52795: PPUSH
52796: CALL_OW 266
52800: PUSH
52801: LD_INT 32
52803: PUSH
52804: LD_INT 31
52806: PUSH
52807: LD_INT 33
52809: PUSH
52810: LD_INT 4
52812: PUSH
52813: LD_INT 5
52815: PUSH
52816: EMPTY
52817: LIST
52818: LIST
52819: LIST
52820: LIST
52821: LIST
52822: IN
52823: IFFALSE 53007
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
52825: LD_ADDR_VAR 0 9
52829: PUSH
52830: LD_VAR 0 14
52834: PUSH
52835: LD_INT 1
52837: ARRAY
52838: PPUSH
52839: CALL_OW 266
52843: PPUSH
52844: LD_VAR 0 14
52848: PUSH
52849: LD_INT 1
52851: ARRAY
52852: PPUSH
52853: CALL_OW 250
52857: PPUSH
52858: LD_VAR 0 14
52862: PUSH
52863: LD_INT 1
52865: ARRAY
52866: PPUSH
52867: CALL_OW 251
52871: PPUSH
52872: LD_VAR 0 14
52876: PUSH
52877: LD_INT 1
52879: ARRAY
52880: PPUSH
52881: CALL_OW 254
52885: PPUSH
52886: LD_VAR 0 14
52890: PUSH
52891: LD_INT 1
52893: ARRAY
52894: PPUSH
52895: CALL_OW 248
52899: PPUSH
52900: LD_INT 0
52902: PPUSH
52903: CALL 29613 0 6
52907: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
52908: LD_ADDR_VAR 0 8
52912: PUSH
52913: LD_VAR 0 4
52917: PUSH
52918: LD_VAR 0 7
52922: ARRAY
52923: PPUSH
52924: LD_VAR 0 9
52928: PPUSH
52929: CALL 48306 0 2
52933: ST_TO_ADDR
// if j then
52934: LD_VAR 0 8
52938: IFFALSE 53007
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
52940: LD_VAR 0 8
52944: PUSH
52945: LD_INT 1
52947: ARRAY
52948: PPUSH
52949: LD_VAR 0 8
52953: PUSH
52954: LD_INT 2
52956: ARRAY
52957: PPUSH
52958: CALL_OW 488
52962: IFFALSE 53007
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
52964: LD_VAR 0 4
52968: PUSH
52969: LD_VAR 0 7
52973: ARRAY
52974: PPUSH
52975: LD_VAR 0 8
52979: PUSH
52980: LD_INT 1
52982: ARRAY
52983: PPUSH
52984: LD_VAR 0 8
52988: PUSH
52989: LD_INT 2
52991: ARRAY
52992: PPUSH
52993: CALL_OW 116
// attacking := true ;
52997: LD_ADDR_VAR 0 29
53001: PUSH
53002: LD_INT 1
53004: ST_TO_ADDR
// continue ;
53005: GO 50380
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
53007: LD_VAR 0 4
53011: PUSH
53012: LD_VAR 0 7
53016: ARRAY
53017: PPUSH
53018: CALL_OW 265
53022: PUSH
53023: LD_INT 11
53025: EQUAL
53026: IFFALSE 53304
// begin k := 10 ;
53028: LD_ADDR_VAR 0 9
53032: PUSH
53033: LD_INT 10
53035: ST_TO_ADDR
// x := 0 ;
53036: LD_ADDR_VAR 0 10
53040: PUSH
53041: LD_INT 0
53043: ST_TO_ADDR
// if tmp < k then
53044: LD_VAR 0 14
53048: PUSH
53049: LD_VAR 0 9
53053: LESS
53054: IFFALSE 53066
// k := tmp ;
53056: LD_ADDR_VAR 0 9
53060: PUSH
53061: LD_VAR 0 14
53065: ST_TO_ADDR
// for j = k downto 1 do
53066: LD_ADDR_VAR 0 8
53070: PUSH
53071: DOUBLE
53072: LD_VAR 0 9
53076: INC
53077: ST_TO_ADDR
53078: LD_INT 1
53080: PUSH
53081: FOR_DOWNTO
53082: IFFALSE 53157
// begin if GetType ( tmp [ j ] ) = unit_human then
53084: LD_VAR 0 14
53088: PUSH
53089: LD_VAR 0 8
53093: ARRAY
53094: PPUSH
53095: CALL_OW 247
53099: PUSH
53100: LD_INT 1
53102: EQUAL
53103: IFFALSE 53155
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
53105: LD_VAR 0 4
53109: PUSH
53110: LD_VAR 0 7
53114: ARRAY
53115: PPUSH
53116: LD_VAR 0 14
53120: PUSH
53121: LD_VAR 0 8
53125: ARRAY
53126: PPUSH
53127: CALL 48577 0 2
// x := tmp [ j ] ;
53131: LD_ADDR_VAR 0 10
53135: PUSH
53136: LD_VAR 0 14
53140: PUSH
53141: LD_VAR 0 8
53145: ARRAY
53146: ST_TO_ADDR
// attacking := true ;
53147: LD_ADDR_VAR 0 29
53151: PUSH
53152: LD_INT 1
53154: ST_TO_ADDR
// end ; end ;
53155: GO 53081
53157: POP
53158: POP
// if not x then
53159: LD_VAR 0 10
53163: NOT
53164: IFFALSE 53304
// begin attacking := true ;
53166: LD_ADDR_VAR 0 29
53170: PUSH
53171: LD_INT 1
53173: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
53174: LD_VAR 0 4
53178: PUSH
53179: LD_VAR 0 7
53183: ARRAY
53184: PPUSH
53185: CALL_OW 250
53189: PPUSH
53190: LD_VAR 0 4
53194: PUSH
53195: LD_VAR 0 7
53199: ARRAY
53200: PPUSH
53201: CALL_OW 251
53205: PPUSH
53206: CALL_OW 546
53210: PUSH
53211: LD_INT 2
53213: ARRAY
53214: PUSH
53215: LD_VAR 0 14
53219: PUSH
53220: LD_INT 1
53222: ARRAY
53223: PPUSH
53224: CALL_OW 250
53228: PPUSH
53229: LD_VAR 0 14
53233: PUSH
53234: LD_INT 1
53236: ARRAY
53237: PPUSH
53238: CALL_OW 251
53242: PPUSH
53243: CALL_OW 546
53247: PUSH
53248: LD_INT 2
53250: ARRAY
53251: EQUAL
53252: IFFALSE 53280
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
53254: LD_VAR 0 4
53258: PUSH
53259: LD_VAR 0 7
53263: ARRAY
53264: PPUSH
53265: LD_VAR 0 14
53269: PUSH
53270: LD_INT 1
53272: ARRAY
53273: PPUSH
53274: CALL 48577 0 2
53278: GO 53304
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53280: LD_VAR 0 4
53284: PUSH
53285: LD_VAR 0 7
53289: ARRAY
53290: PPUSH
53291: LD_VAR 0 14
53295: PUSH
53296: LD_INT 1
53298: ARRAY
53299: PPUSH
53300: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
53304: LD_VAR 0 4
53308: PUSH
53309: LD_VAR 0 7
53313: ARRAY
53314: PPUSH
53315: CALL_OW 264
53319: PUSH
53320: LD_INT 29
53322: EQUAL
53323: IFFALSE 53689
// begin if WantsToAttack ( group [ i ] ) in bombed then
53325: LD_VAR 0 4
53329: PUSH
53330: LD_VAR 0 7
53334: ARRAY
53335: PPUSH
53336: CALL_OW 319
53340: PUSH
53341: LD_VAR 0 28
53345: IN
53346: IFFALSE 53350
// continue ;
53348: GO 50380
// k := 8 ;
53350: LD_ADDR_VAR 0 9
53354: PUSH
53355: LD_INT 8
53357: ST_TO_ADDR
// x := 0 ;
53358: LD_ADDR_VAR 0 10
53362: PUSH
53363: LD_INT 0
53365: ST_TO_ADDR
// if tmp < k then
53366: LD_VAR 0 14
53370: PUSH
53371: LD_VAR 0 9
53375: LESS
53376: IFFALSE 53388
// k := tmp ;
53378: LD_ADDR_VAR 0 9
53382: PUSH
53383: LD_VAR 0 14
53387: ST_TO_ADDR
// for j = 1 to k do
53388: LD_ADDR_VAR 0 8
53392: PUSH
53393: DOUBLE
53394: LD_INT 1
53396: DEC
53397: ST_TO_ADDR
53398: LD_VAR 0 9
53402: PUSH
53403: FOR_TO
53404: IFFALSE 53536
// begin if GetType ( tmp [ j ] ) = unit_building then
53406: LD_VAR 0 14
53410: PUSH
53411: LD_VAR 0 8
53415: ARRAY
53416: PPUSH
53417: CALL_OW 247
53421: PUSH
53422: LD_INT 3
53424: EQUAL
53425: IFFALSE 53534
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
53427: LD_VAR 0 14
53431: PUSH
53432: LD_VAR 0 8
53436: ARRAY
53437: PUSH
53438: LD_VAR 0 28
53442: IN
53443: NOT
53444: PUSH
53445: LD_VAR 0 14
53449: PUSH
53450: LD_VAR 0 8
53454: ARRAY
53455: PPUSH
53456: CALL_OW 313
53460: AND
53461: IFFALSE 53534
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53463: LD_VAR 0 4
53467: PUSH
53468: LD_VAR 0 7
53472: ARRAY
53473: PPUSH
53474: LD_VAR 0 14
53478: PUSH
53479: LD_VAR 0 8
53483: ARRAY
53484: PPUSH
53485: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
53489: LD_ADDR_VAR 0 28
53493: PUSH
53494: LD_VAR 0 28
53498: PPUSH
53499: LD_VAR 0 28
53503: PUSH
53504: LD_INT 1
53506: PLUS
53507: PPUSH
53508: LD_VAR 0 14
53512: PUSH
53513: LD_VAR 0 8
53517: ARRAY
53518: PPUSH
53519: CALL_OW 1
53523: ST_TO_ADDR
// attacking := true ;
53524: LD_ADDR_VAR 0 29
53528: PUSH
53529: LD_INT 1
53531: ST_TO_ADDR
// break ;
53532: GO 53536
// end ; end ;
53534: GO 53403
53536: POP
53537: POP
// if not attacking and f_attack_depot then
53538: LD_VAR 0 29
53542: NOT
53543: PUSH
53544: LD_VAR 0 25
53548: AND
53549: IFFALSE 53644
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53551: LD_ADDR_VAR 0 13
53555: PUSH
53556: LD_VAR 0 14
53560: PPUSH
53561: LD_INT 2
53563: PUSH
53564: LD_INT 30
53566: PUSH
53567: LD_INT 0
53569: PUSH
53570: EMPTY
53571: LIST
53572: LIST
53573: PUSH
53574: LD_INT 30
53576: PUSH
53577: LD_INT 1
53579: PUSH
53580: EMPTY
53581: LIST
53582: LIST
53583: PUSH
53584: EMPTY
53585: LIST
53586: LIST
53587: LIST
53588: PPUSH
53589: CALL_OW 72
53593: ST_TO_ADDR
// if z then
53594: LD_VAR 0 13
53598: IFFALSE 53644
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
53600: LD_VAR 0 4
53604: PUSH
53605: LD_VAR 0 7
53609: ARRAY
53610: PPUSH
53611: LD_VAR 0 13
53615: PPUSH
53616: LD_VAR 0 4
53620: PUSH
53621: LD_VAR 0 7
53625: ARRAY
53626: PPUSH
53627: CALL_OW 74
53631: PPUSH
53632: CALL_OW 115
// attacking := true ;
53636: LD_ADDR_VAR 0 29
53640: PUSH
53641: LD_INT 1
53643: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
53644: LD_VAR 0 4
53648: PUSH
53649: LD_VAR 0 7
53653: ARRAY
53654: PPUSH
53655: CALL_OW 256
53659: PUSH
53660: LD_INT 500
53662: LESS
53663: IFFALSE 53689
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53665: LD_VAR 0 4
53669: PUSH
53670: LD_VAR 0 7
53674: ARRAY
53675: PPUSH
53676: LD_VAR 0 14
53680: PUSH
53681: LD_INT 1
53683: ARRAY
53684: PPUSH
53685: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
53689: LD_VAR 0 4
53693: PUSH
53694: LD_VAR 0 7
53698: ARRAY
53699: PPUSH
53700: CALL_OW 264
53704: PUSH
53705: LD_INT 49
53707: EQUAL
53708: IFFALSE 53829
// begin if not HasTask ( group [ i ] ) then
53710: LD_VAR 0 4
53714: PUSH
53715: LD_VAR 0 7
53719: ARRAY
53720: PPUSH
53721: CALL_OW 314
53725: NOT
53726: IFFALSE 53829
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
53728: LD_ADDR_VAR 0 9
53732: PUSH
53733: LD_INT 81
53735: PUSH
53736: LD_VAR 0 4
53740: PUSH
53741: LD_VAR 0 7
53745: ARRAY
53746: PPUSH
53747: CALL_OW 255
53751: PUSH
53752: EMPTY
53753: LIST
53754: LIST
53755: PPUSH
53756: CALL_OW 69
53760: PPUSH
53761: LD_VAR 0 4
53765: PUSH
53766: LD_VAR 0 7
53770: ARRAY
53771: PPUSH
53772: CALL_OW 74
53776: ST_TO_ADDR
// if k then
53777: LD_VAR 0 9
53781: IFFALSE 53829
// if GetDistUnits ( group [ i ] , k ) > 10 then
53783: LD_VAR 0 4
53787: PUSH
53788: LD_VAR 0 7
53792: ARRAY
53793: PPUSH
53794: LD_VAR 0 9
53798: PPUSH
53799: CALL_OW 296
53803: PUSH
53804: LD_INT 10
53806: GREATER
53807: IFFALSE 53829
// ComMoveUnit ( group [ i ] , k ) ;
53809: LD_VAR 0 4
53813: PUSH
53814: LD_VAR 0 7
53818: ARRAY
53819: PPUSH
53820: LD_VAR 0 9
53824: PPUSH
53825: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53829: LD_VAR 0 4
53833: PUSH
53834: LD_VAR 0 7
53838: ARRAY
53839: PPUSH
53840: CALL_OW 256
53844: PUSH
53845: LD_INT 250
53847: LESS
53848: PUSH
53849: LD_VAR 0 4
53853: PUSH
53854: LD_VAR 0 7
53858: ARRAY
53859: PUSH
53860: LD_INT 21
53862: PUSH
53863: LD_INT 2
53865: PUSH
53866: EMPTY
53867: LIST
53868: LIST
53869: PUSH
53870: LD_INT 23
53872: PUSH
53873: LD_INT 2
53875: PUSH
53876: EMPTY
53877: LIST
53878: LIST
53879: PUSH
53880: EMPTY
53881: LIST
53882: LIST
53883: PPUSH
53884: CALL_OW 69
53888: IN
53889: AND
53890: IFFALSE 54015
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
53892: LD_ADDR_VAR 0 9
53896: PUSH
53897: LD_OWVAR 3
53901: PUSH
53902: LD_VAR 0 4
53906: PUSH
53907: LD_VAR 0 7
53911: ARRAY
53912: DIFF
53913: PPUSH
53914: LD_VAR 0 4
53918: PUSH
53919: LD_VAR 0 7
53923: ARRAY
53924: PPUSH
53925: CALL_OW 74
53929: ST_TO_ADDR
// if not k then
53930: LD_VAR 0 9
53934: NOT
53935: IFFALSE 53939
// continue ;
53937: GO 50380
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
53939: LD_VAR 0 9
53943: PUSH
53944: LD_INT 81
53946: PUSH
53947: LD_VAR 0 4
53951: PUSH
53952: LD_VAR 0 7
53956: ARRAY
53957: PPUSH
53958: CALL_OW 255
53962: PUSH
53963: EMPTY
53964: LIST
53965: LIST
53966: PPUSH
53967: CALL_OW 69
53971: IN
53972: PUSH
53973: LD_VAR 0 9
53977: PPUSH
53978: LD_VAR 0 4
53982: PUSH
53983: LD_VAR 0 7
53987: ARRAY
53988: PPUSH
53989: CALL_OW 296
53993: PUSH
53994: LD_INT 5
53996: LESS
53997: AND
53998: IFFALSE 54015
// ComAutodestruct ( group [ i ] ) ;
54000: LD_VAR 0 4
54004: PUSH
54005: LD_VAR 0 7
54009: ARRAY
54010: PPUSH
54011: CALL 48475 0 1
// end ; if f_attack_depot then
54015: LD_VAR 0 25
54019: IFFALSE 54131
// begin k := 6 ;
54021: LD_ADDR_VAR 0 9
54025: PUSH
54026: LD_INT 6
54028: ST_TO_ADDR
// if tmp < k then
54029: LD_VAR 0 14
54033: PUSH
54034: LD_VAR 0 9
54038: LESS
54039: IFFALSE 54051
// k := tmp ;
54041: LD_ADDR_VAR 0 9
54045: PUSH
54046: LD_VAR 0 14
54050: ST_TO_ADDR
// for j = 1 to k do
54051: LD_ADDR_VAR 0 8
54055: PUSH
54056: DOUBLE
54057: LD_INT 1
54059: DEC
54060: ST_TO_ADDR
54061: LD_VAR 0 9
54065: PUSH
54066: FOR_TO
54067: IFFALSE 54129
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
54069: LD_VAR 0 8
54073: PPUSH
54074: CALL_OW 266
54078: PUSH
54079: LD_INT 0
54081: PUSH
54082: LD_INT 1
54084: PUSH
54085: EMPTY
54086: LIST
54087: LIST
54088: IN
54089: IFFALSE 54127
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
54091: LD_VAR 0 4
54095: PUSH
54096: LD_VAR 0 7
54100: ARRAY
54101: PPUSH
54102: LD_VAR 0 14
54106: PUSH
54107: LD_VAR 0 8
54111: ARRAY
54112: PPUSH
54113: CALL_OW 115
// attacking := true ;
54117: LD_ADDR_VAR 0 29
54121: PUSH
54122: LD_INT 1
54124: ST_TO_ADDR
// break ;
54125: GO 54129
// end ;
54127: GO 54066
54129: POP
54130: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
54131: LD_VAR 0 4
54135: PUSH
54136: LD_VAR 0 7
54140: ARRAY
54141: PPUSH
54142: CALL_OW 302
54146: PUSH
54147: LD_VAR 0 29
54151: NOT
54152: AND
54153: IFFALSE 54475
// begin if GetTag ( group [ i ] ) = 71 then
54155: LD_VAR 0 4
54159: PUSH
54160: LD_VAR 0 7
54164: ARRAY
54165: PPUSH
54166: CALL_OW 110
54170: PUSH
54171: LD_INT 71
54173: EQUAL
54174: IFFALSE 54215
// begin if HasTask ( group [ i ] ) then
54176: LD_VAR 0 4
54180: PUSH
54181: LD_VAR 0 7
54185: ARRAY
54186: PPUSH
54187: CALL_OW 314
54191: IFFALSE 54197
// continue else
54193: GO 50380
54195: GO 54215
// SetTag ( group [ i ] , 0 ) ;
54197: LD_VAR 0 4
54201: PUSH
54202: LD_VAR 0 7
54206: ARRAY
54207: PPUSH
54208: LD_INT 0
54210: PPUSH
54211: CALL_OW 109
// end ; k := 8 ;
54215: LD_ADDR_VAR 0 9
54219: PUSH
54220: LD_INT 8
54222: ST_TO_ADDR
// x := 0 ;
54223: LD_ADDR_VAR 0 10
54227: PUSH
54228: LD_INT 0
54230: ST_TO_ADDR
// if tmp < k then
54231: LD_VAR 0 14
54235: PUSH
54236: LD_VAR 0 9
54240: LESS
54241: IFFALSE 54253
// k := tmp ;
54243: LD_ADDR_VAR 0 9
54247: PUSH
54248: LD_VAR 0 14
54252: ST_TO_ADDR
// for j = 1 to k do
54253: LD_ADDR_VAR 0 8
54257: PUSH
54258: DOUBLE
54259: LD_INT 1
54261: DEC
54262: ST_TO_ADDR
54263: LD_VAR 0 9
54267: PUSH
54268: FOR_TO
54269: IFFALSE 54367
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
54271: LD_VAR 0 14
54275: PUSH
54276: LD_VAR 0 8
54280: ARRAY
54281: PPUSH
54282: CALL_OW 247
54286: PUSH
54287: LD_INT 1
54289: EQUAL
54290: PUSH
54291: LD_VAR 0 14
54295: PUSH
54296: LD_VAR 0 8
54300: ARRAY
54301: PPUSH
54302: CALL_OW 256
54306: PUSH
54307: LD_INT 250
54309: LESS
54310: PUSH
54311: LD_VAR 0 20
54315: AND
54316: PUSH
54317: LD_VAR 0 20
54321: NOT
54322: PUSH
54323: LD_VAR 0 14
54327: PUSH
54328: LD_VAR 0 8
54332: ARRAY
54333: PPUSH
54334: CALL_OW 256
54338: PUSH
54339: LD_INT 250
54341: GREATEREQUAL
54342: AND
54343: OR
54344: AND
54345: IFFALSE 54365
// begin x := tmp [ j ] ;
54347: LD_ADDR_VAR 0 10
54351: PUSH
54352: LD_VAR 0 14
54356: PUSH
54357: LD_VAR 0 8
54361: ARRAY
54362: ST_TO_ADDR
// break ;
54363: GO 54367
// end ;
54365: GO 54268
54367: POP
54368: POP
// if x then
54369: LD_VAR 0 10
54373: IFFALSE 54397
// ComAttackUnit ( group [ i ] , x ) else
54375: LD_VAR 0 4
54379: PUSH
54380: LD_VAR 0 7
54384: ARRAY
54385: PPUSH
54386: LD_VAR 0 10
54390: PPUSH
54391: CALL_OW 115
54395: GO 54421
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
54397: LD_VAR 0 4
54401: PUSH
54402: LD_VAR 0 7
54406: ARRAY
54407: PPUSH
54408: LD_VAR 0 14
54412: PUSH
54413: LD_INT 1
54415: ARRAY
54416: PPUSH
54417: CALL_OW 115
// if not HasTask ( group [ i ] ) then
54421: LD_VAR 0 4
54425: PUSH
54426: LD_VAR 0 7
54430: ARRAY
54431: PPUSH
54432: CALL_OW 314
54436: NOT
54437: IFFALSE 54475
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
54439: LD_VAR 0 4
54443: PUSH
54444: LD_VAR 0 7
54448: ARRAY
54449: PPUSH
54450: LD_VAR 0 14
54454: PPUSH
54455: LD_VAR 0 4
54459: PUSH
54460: LD_VAR 0 7
54464: ARRAY
54465: PPUSH
54466: CALL_OW 74
54470: PPUSH
54471: CALL_OW 115
// end ; end ; end ;
54475: GO 50380
54477: POP
54478: POP
// wait ( 0 0$1 ) ;
54479: LD_INT 35
54481: PPUSH
54482: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
54486: LD_VAR 0 4
54490: PUSH
54491: EMPTY
54492: EQUAL
54493: PUSH
54494: LD_INT 81
54496: PUSH
54497: LD_VAR 0 35
54501: PUSH
54502: EMPTY
54503: LIST
54504: LIST
54505: PPUSH
54506: CALL_OW 69
54510: NOT
54511: OR
54512: IFFALSE 50365
// end ;
54514: LD_VAR 0 2
54518: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54519: LD_INT 0
54521: PPUSH
54522: PPUSH
54523: PPUSH
54524: PPUSH
// if not base_units then
54525: LD_VAR 0 1
54529: NOT
54530: IFFALSE 54534
// exit ;
54532: GO 54621
// result := false ;
54534: LD_ADDR_VAR 0 2
54538: PUSH
54539: LD_INT 0
54541: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54542: LD_ADDR_VAR 0 5
54546: PUSH
54547: LD_VAR 0 1
54551: PPUSH
54552: LD_INT 21
54554: PUSH
54555: LD_INT 3
54557: PUSH
54558: EMPTY
54559: LIST
54560: LIST
54561: PPUSH
54562: CALL_OW 72
54566: ST_TO_ADDR
// if not tmp then
54567: LD_VAR 0 5
54571: NOT
54572: IFFALSE 54576
// exit ;
54574: GO 54621
// for i in tmp do
54576: LD_ADDR_VAR 0 3
54580: PUSH
54581: LD_VAR 0 5
54585: PUSH
54586: FOR_IN
54587: IFFALSE 54619
// begin result := EnemyInRange ( i , 22 ) ;
54589: LD_ADDR_VAR 0 2
54593: PUSH
54594: LD_VAR 0 3
54598: PPUSH
54599: LD_INT 22
54601: PPUSH
54602: CALL 48158 0 2
54606: ST_TO_ADDR
// if result then
54607: LD_VAR 0 2
54611: IFFALSE 54617
// exit ;
54613: POP
54614: POP
54615: GO 54621
// end ;
54617: GO 54586
54619: POP
54620: POP
// end ;
54621: LD_VAR 0 2
54625: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
54626: LD_INT 0
54628: PPUSH
54629: PPUSH
// if not units then
54630: LD_VAR 0 1
54634: NOT
54635: IFFALSE 54639
// exit ;
54637: GO 54709
// result := [ ] ;
54639: LD_ADDR_VAR 0 3
54643: PUSH
54644: EMPTY
54645: ST_TO_ADDR
// for i in units do
54646: LD_ADDR_VAR 0 4
54650: PUSH
54651: LD_VAR 0 1
54655: PUSH
54656: FOR_IN
54657: IFFALSE 54707
// if GetTag ( i ) = tag then
54659: LD_VAR 0 4
54663: PPUSH
54664: CALL_OW 110
54668: PUSH
54669: LD_VAR 0 2
54673: EQUAL
54674: IFFALSE 54705
// result := Insert ( result , result + 1 , i ) ;
54676: LD_ADDR_VAR 0 3
54680: PUSH
54681: LD_VAR 0 3
54685: PPUSH
54686: LD_VAR 0 3
54690: PUSH
54691: LD_INT 1
54693: PLUS
54694: PPUSH
54695: LD_VAR 0 4
54699: PPUSH
54700: CALL_OW 2
54704: ST_TO_ADDR
54705: GO 54656
54707: POP
54708: POP
// end ;
54709: LD_VAR 0 3
54713: RET
// export function IsDriver ( un ) ; begin
54714: LD_INT 0
54716: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54717: LD_ADDR_VAR 0 2
54721: PUSH
54722: LD_VAR 0 1
54726: PUSH
54727: LD_INT 55
54729: PUSH
54730: EMPTY
54731: LIST
54732: PPUSH
54733: CALL_OW 69
54737: IN
54738: ST_TO_ADDR
// end ;
54739: LD_VAR 0 2
54743: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54744: LD_INT 0
54746: PPUSH
54747: PPUSH
// list := [ ] ;
54748: LD_ADDR_VAR 0 5
54752: PUSH
54753: EMPTY
54754: ST_TO_ADDR
// case d of 0 :
54755: LD_VAR 0 3
54759: PUSH
54760: LD_INT 0
54762: DOUBLE
54763: EQUAL
54764: IFTRUE 54768
54766: GO 54901
54768: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54769: LD_ADDR_VAR 0 5
54773: PUSH
54774: LD_VAR 0 1
54778: PUSH
54779: LD_INT 4
54781: MINUS
54782: PUSH
54783: LD_VAR 0 2
54787: PUSH
54788: LD_INT 4
54790: MINUS
54791: PUSH
54792: LD_INT 2
54794: PUSH
54795: EMPTY
54796: LIST
54797: LIST
54798: LIST
54799: PUSH
54800: LD_VAR 0 1
54804: PUSH
54805: LD_INT 3
54807: MINUS
54808: PUSH
54809: LD_VAR 0 2
54813: PUSH
54814: LD_INT 1
54816: PUSH
54817: EMPTY
54818: LIST
54819: LIST
54820: LIST
54821: PUSH
54822: LD_VAR 0 1
54826: PUSH
54827: LD_INT 4
54829: PLUS
54830: PUSH
54831: LD_VAR 0 2
54835: PUSH
54836: LD_INT 4
54838: PUSH
54839: EMPTY
54840: LIST
54841: LIST
54842: LIST
54843: PUSH
54844: LD_VAR 0 1
54848: PUSH
54849: LD_INT 3
54851: PLUS
54852: PUSH
54853: LD_VAR 0 2
54857: PUSH
54858: LD_INT 3
54860: PLUS
54861: PUSH
54862: LD_INT 5
54864: PUSH
54865: EMPTY
54866: LIST
54867: LIST
54868: LIST
54869: PUSH
54870: LD_VAR 0 1
54874: PUSH
54875: LD_VAR 0 2
54879: PUSH
54880: LD_INT 4
54882: PLUS
54883: PUSH
54884: LD_INT 0
54886: PUSH
54887: EMPTY
54888: LIST
54889: LIST
54890: LIST
54891: PUSH
54892: EMPTY
54893: LIST
54894: LIST
54895: LIST
54896: LIST
54897: LIST
54898: ST_TO_ADDR
// end ; 1 :
54899: GO 55599
54901: LD_INT 1
54903: DOUBLE
54904: EQUAL
54905: IFTRUE 54909
54907: GO 55042
54909: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54910: LD_ADDR_VAR 0 5
54914: PUSH
54915: LD_VAR 0 1
54919: PUSH
54920: LD_VAR 0 2
54924: PUSH
54925: LD_INT 4
54927: MINUS
54928: PUSH
54929: LD_INT 3
54931: PUSH
54932: EMPTY
54933: LIST
54934: LIST
54935: LIST
54936: PUSH
54937: LD_VAR 0 1
54941: PUSH
54942: LD_INT 3
54944: MINUS
54945: PUSH
54946: LD_VAR 0 2
54950: PUSH
54951: LD_INT 3
54953: MINUS
54954: PUSH
54955: LD_INT 2
54957: PUSH
54958: EMPTY
54959: LIST
54960: LIST
54961: LIST
54962: PUSH
54963: LD_VAR 0 1
54967: PUSH
54968: LD_INT 4
54970: MINUS
54971: PUSH
54972: LD_VAR 0 2
54976: PUSH
54977: LD_INT 1
54979: PUSH
54980: EMPTY
54981: LIST
54982: LIST
54983: LIST
54984: PUSH
54985: LD_VAR 0 1
54989: PUSH
54990: LD_VAR 0 2
54994: PUSH
54995: LD_INT 3
54997: PLUS
54998: PUSH
54999: LD_INT 0
55001: PUSH
55002: EMPTY
55003: LIST
55004: LIST
55005: LIST
55006: PUSH
55007: LD_VAR 0 1
55011: PUSH
55012: LD_INT 4
55014: PLUS
55015: PUSH
55016: LD_VAR 0 2
55020: PUSH
55021: LD_INT 4
55023: PLUS
55024: PUSH
55025: LD_INT 5
55027: PUSH
55028: EMPTY
55029: LIST
55030: LIST
55031: LIST
55032: PUSH
55033: EMPTY
55034: LIST
55035: LIST
55036: LIST
55037: LIST
55038: LIST
55039: ST_TO_ADDR
// end ; 2 :
55040: GO 55599
55042: LD_INT 2
55044: DOUBLE
55045: EQUAL
55046: IFTRUE 55050
55048: GO 55179
55050: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
55051: LD_ADDR_VAR 0 5
55055: PUSH
55056: LD_VAR 0 1
55060: PUSH
55061: LD_VAR 0 2
55065: PUSH
55066: LD_INT 3
55068: MINUS
55069: PUSH
55070: LD_INT 3
55072: PUSH
55073: EMPTY
55074: LIST
55075: LIST
55076: LIST
55077: PUSH
55078: LD_VAR 0 1
55082: PUSH
55083: LD_INT 4
55085: PLUS
55086: PUSH
55087: LD_VAR 0 2
55091: PUSH
55092: LD_INT 4
55094: PUSH
55095: EMPTY
55096: LIST
55097: LIST
55098: LIST
55099: PUSH
55100: LD_VAR 0 1
55104: PUSH
55105: LD_VAR 0 2
55109: PUSH
55110: LD_INT 4
55112: PLUS
55113: PUSH
55114: LD_INT 0
55116: PUSH
55117: EMPTY
55118: LIST
55119: LIST
55120: LIST
55121: PUSH
55122: LD_VAR 0 1
55126: PUSH
55127: LD_INT 3
55129: MINUS
55130: PUSH
55131: LD_VAR 0 2
55135: PUSH
55136: LD_INT 1
55138: PUSH
55139: EMPTY
55140: LIST
55141: LIST
55142: LIST
55143: PUSH
55144: LD_VAR 0 1
55148: PUSH
55149: LD_INT 4
55151: MINUS
55152: PUSH
55153: LD_VAR 0 2
55157: PUSH
55158: LD_INT 4
55160: MINUS
55161: PUSH
55162: LD_INT 2
55164: PUSH
55165: EMPTY
55166: LIST
55167: LIST
55168: LIST
55169: PUSH
55170: EMPTY
55171: LIST
55172: LIST
55173: LIST
55174: LIST
55175: LIST
55176: ST_TO_ADDR
// end ; 3 :
55177: GO 55599
55179: LD_INT 3
55181: DOUBLE
55182: EQUAL
55183: IFTRUE 55187
55185: GO 55320
55187: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
55188: LD_ADDR_VAR 0 5
55192: PUSH
55193: LD_VAR 0 1
55197: PUSH
55198: LD_INT 3
55200: PLUS
55201: PUSH
55202: LD_VAR 0 2
55206: PUSH
55207: LD_INT 4
55209: PUSH
55210: EMPTY
55211: LIST
55212: LIST
55213: LIST
55214: PUSH
55215: LD_VAR 0 1
55219: PUSH
55220: LD_INT 4
55222: PLUS
55223: PUSH
55224: LD_VAR 0 2
55228: PUSH
55229: LD_INT 4
55231: PLUS
55232: PUSH
55233: LD_INT 5
55235: PUSH
55236: EMPTY
55237: LIST
55238: LIST
55239: LIST
55240: PUSH
55241: LD_VAR 0 1
55245: PUSH
55246: LD_INT 4
55248: MINUS
55249: PUSH
55250: LD_VAR 0 2
55254: PUSH
55255: LD_INT 1
55257: PUSH
55258: EMPTY
55259: LIST
55260: LIST
55261: LIST
55262: PUSH
55263: LD_VAR 0 1
55267: PUSH
55268: LD_VAR 0 2
55272: PUSH
55273: LD_INT 4
55275: MINUS
55276: PUSH
55277: LD_INT 3
55279: PUSH
55280: EMPTY
55281: LIST
55282: LIST
55283: LIST
55284: PUSH
55285: LD_VAR 0 1
55289: PUSH
55290: LD_INT 3
55292: MINUS
55293: PUSH
55294: LD_VAR 0 2
55298: PUSH
55299: LD_INT 3
55301: MINUS
55302: PUSH
55303: LD_INT 2
55305: PUSH
55306: EMPTY
55307: LIST
55308: LIST
55309: LIST
55310: PUSH
55311: EMPTY
55312: LIST
55313: LIST
55314: LIST
55315: LIST
55316: LIST
55317: ST_TO_ADDR
// end ; 4 :
55318: GO 55599
55320: LD_INT 4
55322: DOUBLE
55323: EQUAL
55324: IFTRUE 55328
55326: GO 55461
55328: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55329: LD_ADDR_VAR 0 5
55333: PUSH
55334: LD_VAR 0 1
55338: PUSH
55339: LD_VAR 0 2
55343: PUSH
55344: LD_INT 4
55346: PLUS
55347: PUSH
55348: LD_INT 0
55350: PUSH
55351: EMPTY
55352: LIST
55353: LIST
55354: LIST
55355: PUSH
55356: LD_VAR 0 1
55360: PUSH
55361: LD_INT 3
55363: PLUS
55364: PUSH
55365: LD_VAR 0 2
55369: PUSH
55370: LD_INT 3
55372: PLUS
55373: PUSH
55374: LD_INT 5
55376: PUSH
55377: EMPTY
55378: LIST
55379: LIST
55380: LIST
55381: PUSH
55382: LD_VAR 0 1
55386: PUSH
55387: LD_INT 4
55389: PLUS
55390: PUSH
55391: LD_VAR 0 2
55395: PUSH
55396: LD_INT 4
55398: PUSH
55399: EMPTY
55400: LIST
55401: LIST
55402: LIST
55403: PUSH
55404: LD_VAR 0 1
55408: PUSH
55409: LD_VAR 0 2
55413: PUSH
55414: LD_INT 3
55416: MINUS
55417: PUSH
55418: LD_INT 3
55420: PUSH
55421: EMPTY
55422: LIST
55423: LIST
55424: LIST
55425: PUSH
55426: LD_VAR 0 1
55430: PUSH
55431: LD_INT 4
55433: MINUS
55434: PUSH
55435: LD_VAR 0 2
55439: PUSH
55440: LD_INT 4
55442: MINUS
55443: PUSH
55444: LD_INT 2
55446: PUSH
55447: EMPTY
55448: LIST
55449: LIST
55450: LIST
55451: PUSH
55452: EMPTY
55453: LIST
55454: LIST
55455: LIST
55456: LIST
55457: LIST
55458: ST_TO_ADDR
// end ; 5 :
55459: GO 55599
55461: LD_INT 5
55463: DOUBLE
55464: EQUAL
55465: IFTRUE 55469
55467: GO 55598
55469: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55470: LD_ADDR_VAR 0 5
55474: PUSH
55475: LD_VAR 0 1
55479: PUSH
55480: LD_INT 4
55482: MINUS
55483: PUSH
55484: LD_VAR 0 2
55488: PUSH
55489: LD_INT 1
55491: PUSH
55492: EMPTY
55493: LIST
55494: LIST
55495: LIST
55496: PUSH
55497: LD_VAR 0 1
55501: PUSH
55502: LD_VAR 0 2
55506: PUSH
55507: LD_INT 4
55509: MINUS
55510: PUSH
55511: LD_INT 3
55513: PUSH
55514: EMPTY
55515: LIST
55516: LIST
55517: LIST
55518: PUSH
55519: LD_VAR 0 1
55523: PUSH
55524: LD_INT 4
55526: PLUS
55527: PUSH
55528: LD_VAR 0 2
55532: PUSH
55533: LD_INT 4
55535: PLUS
55536: PUSH
55537: LD_INT 5
55539: PUSH
55540: EMPTY
55541: LIST
55542: LIST
55543: LIST
55544: PUSH
55545: LD_VAR 0 1
55549: PUSH
55550: LD_INT 3
55552: PLUS
55553: PUSH
55554: LD_VAR 0 2
55558: PUSH
55559: LD_INT 4
55561: PUSH
55562: EMPTY
55563: LIST
55564: LIST
55565: LIST
55566: PUSH
55567: LD_VAR 0 1
55571: PUSH
55572: LD_VAR 0 2
55576: PUSH
55577: LD_INT 3
55579: PLUS
55580: PUSH
55581: LD_INT 0
55583: PUSH
55584: EMPTY
55585: LIST
55586: LIST
55587: LIST
55588: PUSH
55589: EMPTY
55590: LIST
55591: LIST
55592: LIST
55593: LIST
55594: LIST
55595: ST_TO_ADDR
// end ; end ;
55596: GO 55599
55598: POP
// result := list ;
55599: LD_ADDR_VAR 0 4
55603: PUSH
55604: LD_VAR 0 5
55608: ST_TO_ADDR
// end ;
55609: LD_VAR 0 4
55613: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55614: LD_INT 0
55616: PPUSH
55617: PPUSH
55618: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55619: LD_VAR 0 1
55623: NOT
55624: PUSH
55625: LD_VAR 0 2
55629: PUSH
55630: LD_INT 1
55632: PUSH
55633: LD_INT 2
55635: PUSH
55636: LD_INT 3
55638: PUSH
55639: LD_INT 4
55641: PUSH
55642: EMPTY
55643: LIST
55644: LIST
55645: LIST
55646: LIST
55647: IN
55648: NOT
55649: OR
55650: IFFALSE 55654
// exit ;
55652: GO 55746
// tmp := [ ] ;
55654: LD_ADDR_VAR 0 5
55658: PUSH
55659: EMPTY
55660: ST_TO_ADDR
// for i in units do
55661: LD_ADDR_VAR 0 4
55665: PUSH
55666: LD_VAR 0 1
55670: PUSH
55671: FOR_IN
55672: IFFALSE 55715
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55674: LD_ADDR_VAR 0 5
55678: PUSH
55679: LD_VAR 0 5
55683: PPUSH
55684: LD_VAR 0 5
55688: PUSH
55689: LD_INT 1
55691: PLUS
55692: PPUSH
55693: LD_VAR 0 4
55697: PPUSH
55698: LD_VAR 0 2
55702: PPUSH
55703: CALL_OW 259
55707: PPUSH
55708: CALL_OW 2
55712: ST_TO_ADDR
55713: GO 55671
55715: POP
55716: POP
// if not tmp then
55717: LD_VAR 0 5
55721: NOT
55722: IFFALSE 55726
// exit ;
55724: GO 55746
// result := SortListByListDesc ( units , tmp ) ;
55726: LD_ADDR_VAR 0 3
55730: PUSH
55731: LD_VAR 0 1
55735: PPUSH
55736: LD_VAR 0 5
55740: PPUSH
55741: CALL_OW 77
55745: ST_TO_ADDR
// end ;
55746: LD_VAR 0 3
55750: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55751: LD_INT 0
55753: PPUSH
55754: PPUSH
55755: PPUSH
// x := GetX ( building ) ;
55756: LD_ADDR_VAR 0 4
55760: PUSH
55761: LD_VAR 0 2
55765: PPUSH
55766: CALL_OW 250
55770: ST_TO_ADDR
// y := GetY ( building ) ;
55771: LD_ADDR_VAR 0 5
55775: PUSH
55776: LD_VAR 0 2
55780: PPUSH
55781: CALL_OW 251
55785: ST_TO_ADDR
// if GetTaskList ( unit ) then
55786: LD_VAR 0 1
55790: PPUSH
55791: CALL_OW 437
55795: IFFALSE 55890
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55797: LD_STRING e
55799: PUSH
55800: LD_VAR 0 1
55804: PPUSH
55805: CALL_OW 437
55809: PUSH
55810: LD_INT 1
55812: ARRAY
55813: PUSH
55814: LD_INT 1
55816: ARRAY
55817: EQUAL
55818: PUSH
55819: LD_VAR 0 4
55823: PUSH
55824: LD_VAR 0 1
55828: PPUSH
55829: CALL_OW 437
55833: PUSH
55834: LD_INT 1
55836: ARRAY
55837: PUSH
55838: LD_INT 2
55840: ARRAY
55841: EQUAL
55842: AND
55843: PUSH
55844: LD_VAR 0 5
55848: PUSH
55849: LD_VAR 0 1
55853: PPUSH
55854: CALL_OW 437
55858: PUSH
55859: LD_INT 1
55861: ARRAY
55862: PUSH
55863: LD_INT 3
55865: ARRAY
55866: EQUAL
55867: AND
55868: IFFALSE 55880
// result := true else
55870: LD_ADDR_VAR 0 3
55874: PUSH
55875: LD_INT 1
55877: ST_TO_ADDR
55878: GO 55888
// result := false ;
55880: LD_ADDR_VAR 0 3
55884: PUSH
55885: LD_INT 0
55887: ST_TO_ADDR
// end else
55888: GO 55898
// result := false ;
55890: LD_ADDR_VAR 0 3
55894: PUSH
55895: LD_INT 0
55897: ST_TO_ADDR
// end ;
55898: LD_VAR 0 3
55902: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55903: LD_INT 0
55905: PPUSH
55906: PPUSH
55907: PPUSH
55908: PPUSH
// if not unit or not area then
55909: LD_VAR 0 1
55913: NOT
55914: PUSH
55915: LD_VAR 0 2
55919: NOT
55920: OR
55921: IFFALSE 55925
// exit ;
55923: GO 56089
// tmp := AreaToList ( area , i ) ;
55925: LD_ADDR_VAR 0 6
55929: PUSH
55930: LD_VAR 0 2
55934: PPUSH
55935: LD_VAR 0 5
55939: PPUSH
55940: CALL_OW 517
55944: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55945: LD_ADDR_VAR 0 5
55949: PUSH
55950: DOUBLE
55951: LD_INT 1
55953: DEC
55954: ST_TO_ADDR
55955: LD_VAR 0 6
55959: PUSH
55960: LD_INT 1
55962: ARRAY
55963: PUSH
55964: FOR_TO
55965: IFFALSE 56087
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55967: LD_ADDR_VAR 0 7
55971: PUSH
55972: LD_VAR 0 6
55976: PUSH
55977: LD_INT 1
55979: ARRAY
55980: PUSH
55981: LD_VAR 0 5
55985: ARRAY
55986: PUSH
55987: LD_VAR 0 6
55991: PUSH
55992: LD_INT 2
55994: ARRAY
55995: PUSH
55996: LD_VAR 0 5
56000: ARRAY
56001: PUSH
56002: EMPTY
56003: LIST
56004: LIST
56005: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
56006: LD_VAR 0 7
56010: PUSH
56011: LD_INT 1
56013: ARRAY
56014: PPUSH
56015: LD_VAR 0 7
56019: PUSH
56020: LD_INT 2
56022: ARRAY
56023: PPUSH
56024: CALL_OW 428
56028: PUSH
56029: LD_INT 0
56031: EQUAL
56032: IFFALSE 56085
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
56034: LD_VAR 0 1
56038: PPUSH
56039: LD_VAR 0 7
56043: PUSH
56044: LD_INT 1
56046: ARRAY
56047: PPUSH
56048: LD_VAR 0 7
56052: PUSH
56053: LD_INT 2
56055: ARRAY
56056: PPUSH
56057: LD_VAR 0 3
56061: PPUSH
56062: CALL_OW 48
// result := IsPlaced ( unit ) ;
56066: LD_ADDR_VAR 0 4
56070: PUSH
56071: LD_VAR 0 1
56075: PPUSH
56076: CALL_OW 305
56080: ST_TO_ADDR
// exit ;
56081: POP
56082: POP
56083: GO 56089
// end ; end ;
56085: GO 55964
56087: POP
56088: POP
// end ;
56089: LD_VAR 0 4
56093: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
56094: LD_INT 0
56096: PPUSH
56097: PPUSH
56098: PPUSH
// if not side or side > 8 then
56099: LD_VAR 0 1
56103: NOT
56104: PUSH
56105: LD_VAR 0 1
56109: PUSH
56110: LD_INT 8
56112: GREATER
56113: OR
56114: IFFALSE 56118
// exit ;
56116: GO 56305
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
56118: LD_ADDR_VAR 0 4
56122: PUSH
56123: LD_INT 22
56125: PUSH
56126: LD_VAR 0 1
56130: PUSH
56131: EMPTY
56132: LIST
56133: LIST
56134: PUSH
56135: LD_INT 21
56137: PUSH
56138: LD_INT 3
56140: PUSH
56141: EMPTY
56142: LIST
56143: LIST
56144: PUSH
56145: EMPTY
56146: LIST
56147: LIST
56148: PPUSH
56149: CALL_OW 69
56153: ST_TO_ADDR
// if not tmp then
56154: LD_VAR 0 4
56158: NOT
56159: IFFALSE 56163
// exit ;
56161: GO 56305
// enable_addtolog := true ;
56163: LD_ADDR_OWVAR 81
56167: PUSH
56168: LD_INT 1
56170: ST_TO_ADDR
// AddToLog ( [ ) ;
56171: LD_STRING [
56173: PPUSH
56174: CALL_OW 561
// for i in tmp do
56178: LD_ADDR_VAR 0 3
56182: PUSH
56183: LD_VAR 0 4
56187: PUSH
56188: FOR_IN
56189: IFFALSE 56296
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
56191: LD_STRING [
56193: PUSH
56194: LD_VAR 0 3
56198: PPUSH
56199: CALL_OW 266
56203: STR
56204: PUSH
56205: LD_STRING , 
56207: STR
56208: PUSH
56209: LD_VAR 0 3
56213: PPUSH
56214: CALL_OW 250
56218: STR
56219: PUSH
56220: LD_STRING , 
56222: STR
56223: PUSH
56224: LD_VAR 0 3
56228: PPUSH
56229: CALL_OW 251
56233: STR
56234: PUSH
56235: LD_STRING , 
56237: STR
56238: PUSH
56239: LD_VAR 0 3
56243: PPUSH
56244: CALL_OW 254
56248: STR
56249: PUSH
56250: LD_STRING , 
56252: STR
56253: PUSH
56254: LD_VAR 0 3
56258: PPUSH
56259: LD_INT 1
56261: PPUSH
56262: CALL_OW 268
56266: STR
56267: PUSH
56268: LD_STRING , 
56270: STR
56271: PUSH
56272: LD_VAR 0 3
56276: PPUSH
56277: LD_INT 2
56279: PPUSH
56280: CALL_OW 268
56284: STR
56285: PUSH
56286: LD_STRING ],
56288: STR
56289: PPUSH
56290: CALL_OW 561
// end ;
56294: GO 56188
56296: POP
56297: POP
// AddToLog ( ]; ) ;
56298: LD_STRING ];
56300: PPUSH
56301: CALL_OW 561
// end ;
56305: LD_VAR 0 2
56309: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56310: LD_INT 0
56312: PPUSH
56313: PPUSH
56314: PPUSH
56315: PPUSH
56316: PPUSH
// if not area or not rate or not max then
56317: LD_VAR 0 1
56321: NOT
56322: PUSH
56323: LD_VAR 0 2
56327: NOT
56328: OR
56329: PUSH
56330: LD_VAR 0 4
56334: NOT
56335: OR
56336: IFFALSE 56340
// exit ;
56338: GO 56532
// while 1 do
56340: LD_INT 1
56342: IFFALSE 56532
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56344: LD_ADDR_VAR 0 9
56348: PUSH
56349: LD_VAR 0 1
56353: PPUSH
56354: LD_INT 1
56356: PPUSH
56357: CALL_OW 287
56361: PUSH
56362: LD_INT 10
56364: MUL
56365: ST_TO_ADDR
// r := rate / 10 ;
56366: LD_ADDR_VAR 0 7
56370: PUSH
56371: LD_VAR 0 2
56375: PUSH
56376: LD_INT 10
56378: DIVREAL
56379: ST_TO_ADDR
// time := 1 1$00 ;
56380: LD_ADDR_VAR 0 8
56384: PUSH
56385: LD_INT 2100
56387: ST_TO_ADDR
// if amount < min then
56388: LD_VAR 0 9
56392: PUSH
56393: LD_VAR 0 3
56397: LESS
56398: IFFALSE 56416
// r := r * 2 else
56400: LD_ADDR_VAR 0 7
56404: PUSH
56405: LD_VAR 0 7
56409: PUSH
56410: LD_INT 2
56412: MUL
56413: ST_TO_ADDR
56414: GO 56442
// if amount > max then
56416: LD_VAR 0 9
56420: PUSH
56421: LD_VAR 0 4
56425: GREATER
56426: IFFALSE 56442
// r := r / 2 ;
56428: LD_ADDR_VAR 0 7
56432: PUSH
56433: LD_VAR 0 7
56437: PUSH
56438: LD_INT 2
56440: DIVREAL
56441: ST_TO_ADDR
// time := time / r ;
56442: LD_ADDR_VAR 0 8
56446: PUSH
56447: LD_VAR 0 8
56451: PUSH
56452: LD_VAR 0 7
56456: DIVREAL
56457: ST_TO_ADDR
// if time < 0 then
56458: LD_VAR 0 8
56462: PUSH
56463: LD_INT 0
56465: LESS
56466: IFFALSE 56483
// time := time * - 1 ;
56468: LD_ADDR_VAR 0 8
56472: PUSH
56473: LD_VAR 0 8
56477: PUSH
56478: LD_INT 1
56480: NEG
56481: MUL
56482: ST_TO_ADDR
// wait ( time ) ;
56483: LD_VAR 0 8
56487: PPUSH
56488: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
56492: LD_INT 35
56494: PPUSH
56495: LD_INT 875
56497: PPUSH
56498: CALL_OW 12
56502: PPUSH
56503: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56507: LD_INT 1
56509: PPUSH
56510: LD_INT 5
56512: PPUSH
56513: CALL_OW 12
56517: PPUSH
56518: LD_VAR 0 1
56522: PPUSH
56523: LD_INT 1
56525: PPUSH
56526: CALL_OW 55
// end ;
56530: GO 56340
// end ;
56532: LD_VAR 0 5
56536: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56537: LD_INT 0
56539: PPUSH
56540: PPUSH
56541: PPUSH
56542: PPUSH
56543: PPUSH
56544: PPUSH
56545: PPUSH
56546: PPUSH
// if not turrets or not factories then
56547: LD_VAR 0 1
56551: NOT
56552: PUSH
56553: LD_VAR 0 2
56557: NOT
56558: OR
56559: IFFALSE 56563
// exit ;
56561: GO 56870
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56563: LD_ADDR_VAR 0 10
56567: PUSH
56568: LD_INT 5
56570: PUSH
56571: LD_INT 6
56573: PUSH
56574: EMPTY
56575: LIST
56576: LIST
56577: PUSH
56578: LD_INT 2
56580: PUSH
56581: LD_INT 4
56583: PUSH
56584: EMPTY
56585: LIST
56586: LIST
56587: PUSH
56588: LD_INT 3
56590: PUSH
56591: LD_INT 5
56593: PUSH
56594: EMPTY
56595: LIST
56596: LIST
56597: PUSH
56598: EMPTY
56599: LIST
56600: LIST
56601: LIST
56602: PUSH
56603: LD_INT 24
56605: PUSH
56606: LD_INT 25
56608: PUSH
56609: EMPTY
56610: LIST
56611: LIST
56612: PUSH
56613: LD_INT 23
56615: PUSH
56616: LD_INT 27
56618: PUSH
56619: EMPTY
56620: LIST
56621: LIST
56622: PUSH
56623: EMPTY
56624: LIST
56625: LIST
56626: PUSH
56627: LD_INT 42
56629: PUSH
56630: LD_INT 43
56632: PUSH
56633: EMPTY
56634: LIST
56635: LIST
56636: PUSH
56637: LD_INT 44
56639: PUSH
56640: LD_INT 46
56642: PUSH
56643: EMPTY
56644: LIST
56645: LIST
56646: PUSH
56647: LD_INT 45
56649: PUSH
56650: LD_INT 47
56652: PUSH
56653: EMPTY
56654: LIST
56655: LIST
56656: PUSH
56657: EMPTY
56658: LIST
56659: LIST
56660: LIST
56661: PUSH
56662: EMPTY
56663: LIST
56664: LIST
56665: LIST
56666: ST_TO_ADDR
// result := [ ] ;
56667: LD_ADDR_VAR 0 3
56671: PUSH
56672: EMPTY
56673: ST_TO_ADDR
// for i in turrets do
56674: LD_ADDR_VAR 0 4
56678: PUSH
56679: LD_VAR 0 1
56683: PUSH
56684: FOR_IN
56685: IFFALSE 56868
// begin nat := GetNation ( i ) ;
56687: LD_ADDR_VAR 0 7
56691: PUSH
56692: LD_VAR 0 4
56696: PPUSH
56697: CALL_OW 248
56701: ST_TO_ADDR
// weapon := 0 ;
56702: LD_ADDR_VAR 0 8
56706: PUSH
56707: LD_INT 0
56709: ST_TO_ADDR
// if not nat then
56710: LD_VAR 0 7
56714: NOT
56715: IFFALSE 56719
// continue ;
56717: GO 56684
// for j in list [ nat ] do
56719: LD_ADDR_VAR 0 5
56723: PUSH
56724: LD_VAR 0 10
56728: PUSH
56729: LD_VAR 0 7
56733: ARRAY
56734: PUSH
56735: FOR_IN
56736: IFFALSE 56777
// if GetBWeapon ( i ) = j [ 1 ] then
56738: LD_VAR 0 4
56742: PPUSH
56743: CALL_OW 269
56747: PUSH
56748: LD_VAR 0 5
56752: PUSH
56753: LD_INT 1
56755: ARRAY
56756: EQUAL
56757: IFFALSE 56775
// begin weapon := j [ 2 ] ;
56759: LD_ADDR_VAR 0 8
56763: PUSH
56764: LD_VAR 0 5
56768: PUSH
56769: LD_INT 2
56771: ARRAY
56772: ST_TO_ADDR
// break ;
56773: GO 56777
// end ;
56775: GO 56735
56777: POP
56778: POP
// if not weapon then
56779: LD_VAR 0 8
56783: NOT
56784: IFFALSE 56788
// continue ;
56786: GO 56684
// for k in factories do
56788: LD_ADDR_VAR 0 6
56792: PUSH
56793: LD_VAR 0 2
56797: PUSH
56798: FOR_IN
56799: IFFALSE 56864
// begin weapons := AvailableWeaponList ( k ) ;
56801: LD_ADDR_VAR 0 9
56805: PUSH
56806: LD_VAR 0 6
56810: PPUSH
56811: CALL_OW 478
56815: ST_TO_ADDR
// if not weapons then
56816: LD_VAR 0 9
56820: NOT
56821: IFFALSE 56825
// continue ;
56823: GO 56798
// if weapon in weapons then
56825: LD_VAR 0 8
56829: PUSH
56830: LD_VAR 0 9
56834: IN
56835: IFFALSE 56862
// begin result := [ i , weapon ] ;
56837: LD_ADDR_VAR 0 3
56841: PUSH
56842: LD_VAR 0 4
56846: PUSH
56847: LD_VAR 0 8
56851: PUSH
56852: EMPTY
56853: LIST
56854: LIST
56855: ST_TO_ADDR
// exit ;
56856: POP
56857: POP
56858: POP
56859: POP
56860: GO 56870
// end ; end ;
56862: GO 56798
56864: POP
56865: POP
// end ;
56866: GO 56684
56868: POP
56869: POP
// end ;
56870: LD_VAR 0 3
56874: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56875: LD_INT 0
56877: PPUSH
// if not side or side > 8 then
56878: LD_VAR 0 3
56882: NOT
56883: PUSH
56884: LD_VAR 0 3
56888: PUSH
56889: LD_INT 8
56891: GREATER
56892: OR
56893: IFFALSE 56897
// exit ;
56895: GO 56956
// if not range then
56897: LD_VAR 0 4
56901: NOT
56902: IFFALSE 56913
// range := - 12 ;
56904: LD_ADDR_VAR 0 4
56908: PUSH
56909: LD_INT 12
56911: NEG
56912: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56913: LD_VAR 0 1
56917: PPUSH
56918: LD_VAR 0 2
56922: PPUSH
56923: LD_VAR 0 3
56927: PPUSH
56928: LD_VAR 0 4
56932: PPUSH
56933: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56937: LD_VAR 0 1
56941: PPUSH
56942: LD_VAR 0 2
56946: PPUSH
56947: LD_VAR 0 3
56951: PPUSH
56952: CALL_OW 331
// end ;
56956: LD_VAR 0 5
56960: RET
// export function Video ( mode ) ; begin
56961: LD_INT 0
56963: PPUSH
// ingame_video = mode ;
56964: LD_ADDR_OWVAR 52
56968: PUSH
56969: LD_VAR 0 1
56973: ST_TO_ADDR
// interface_hidden = mode ;
56974: LD_ADDR_OWVAR 54
56978: PUSH
56979: LD_VAR 0 1
56983: ST_TO_ADDR
// end ;
56984: LD_VAR 0 2
56988: RET
// export function Join ( array , element ) ; begin
56989: LD_INT 0
56991: PPUSH
// result := array ^ element ;
56992: LD_ADDR_VAR 0 3
56996: PUSH
56997: LD_VAR 0 1
57001: PUSH
57002: LD_VAR 0 2
57006: ADD
57007: ST_TO_ADDR
// end ;
57008: LD_VAR 0 3
57012: RET
// export function JoinUnion ( array , element ) ; begin
57013: LD_INT 0
57015: PPUSH
// result := array union element ;
57016: LD_ADDR_VAR 0 3
57020: PUSH
57021: LD_VAR 0 1
57025: PUSH
57026: LD_VAR 0 2
57030: UNION
57031: ST_TO_ADDR
// end ;
57032: LD_VAR 0 3
57036: RET
// export function GetBehemoths ( side ) ; begin
57037: LD_INT 0
57039: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
57040: LD_ADDR_VAR 0 2
57044: PUSH
57045: LD_INT 22
57047: PUSH
57048: LD_VAR 0 1
57052: PUSH
57053: EMPTY
57054: LIST
57055: LIST
57056: PUSH
57057: LD_INT 31
57059: PUSH
57060: LD_INT 25
57062: PUSH
57063: EMPTY
57064: LIST
57065: LIST
57066: PUSH
57067: EMPTY
57068: LIST
57069: LIST
57070: PPUSH
57071: CALL_OW 69
57075: ST_TO_ADDR
// end ;
57076: LD_VAR 0 2
57080: RET
// export function Shuffle ( array ) ; var i , index ; begin
57081: LD_INT 0
57083: PPUSH
57084: PPUSH
57085: PPUSH
// result := [ ] ;
57086: LD_ADDR_VAR 0 2
57090: PUSH
57091: EMPTY
57092: ST_TO_ADDR
// if not array then
57093: LD_VAR 0 1
57097: NOT
57098: IFFALSE 57102
// exit ;
57100: GO 57201
// Randomize ;
57102: CALL_OW 10
// for i = array downto 1 do
57106: LD_ADDR_VAR 0 3
57110: PUSH
57111: DOUBLE
57112: LD_VAR 0 1
57116: INC
57117: ST_TO_ADDR
57118: LD_INT 1
57120: PUSH
57121: FOR_DOWNTO
57122: IFFALSE 57199
// begin index := rand ( 1 , array ) ;
57124: LD_ADDR_VAR 0 4
57128: PUSH
57129: LD_INT 1
57131: PPUSH
57132: LD_VAR 0 1
57136: PPUSH
57137: CALL_OW 12
57141: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
57142: LD_ADDR_VAR 0 2
57146: PUSH
57147: LD_VAR 0 2
57151: PPUSH
57152: LD_VAR 0 2
57156: PUSH
57157: LD_INT 1
57159: PLUS
57160: PPUSH
57161: LD_VAR 0 1
57165: PUSH
57166: LD_VAR 0 4
57170: ARRAY
57171: PPUSH
57172: CALL_OW 2
57176: ST_TO_ADDR
// array := Delete ( array , index ) ;
57177: LD_ADDR_VAR 0 1
57181: PUSH
57182: LD_VAR 0 1
57186: PPUSH
57187: LD_VAR 0 4
57191: PPUSH
57192: CALL_OW 3
57196: ST_TO_ADDR
// end ;
57197: GO 57121
57199: POP
57200: POP
// end ;
57201: LD_VAR 0 2
57205: RET
// export function GetBaseMaterials ( base ) ; begin
57206: LD_INT 0
57208: PPUSH
// result := [ 0 , 0 , 0 ] ;
57209: LD_ADDR_VAR 0 2
57213: PUSH
57214: LD_INT 0
57216: PUSH
57217: LD_INT 0
57219: PUSH
57220: LD_INT 0
57222: PUSH
57223: EMPTY
57224: LIST
57225: LIST
57226: LIST
57227: ST_TO_ADDR
// if not base then
57228: LD_VAR 0 1
57232: NOT
57233: IFFALSE 57237
// exit ;
57235: GO 57286
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57237: LD_ADDR_VAR 0 2
57241: PUSH
57242: LD_VAR 0 1
57246: PPUSH
57247: LD_INT 1
57249: PPUSH
57250: CALL_OW 275
57254: PUSH
57255: LD_VAR 0 1
57259: PPUSH
57260: LD_INT 2
57262: PPUSH
57263: CALL_OW 275
57267: PUSH
57268: LD_VAR 0 1
57272: PPUSH
57273: LD_INT 3
57275: PPUSH
57276: CALL_OW 275
57280: PUSH
57281: EMPTY
57282: LIST
57283: LIST
57284: LIST
57285: ST_TO_ADDR
// end ; end_of_file
57286: LD_VAR 0 2
57290: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
57291: LD_INT 0
57293: PPUSH
57294: PPUSH
// skirmish := false ;
57295: LD_ADDR_EXP 56
57299: PUSH
57300: LD_INT 0
57302: ST_TO_ADDR
// debug_mc := false ;
57303: LD_ADDR_EXP 57
57307: PUSH
57308: LD_INT 0
57310: ST_TO_ADDR
// mc_bases := [ ] ;
57311: LD_ADDR_EXP 58
57315: PUSH
57316: EMPTY
57317: ST_TO_ADDR
// mc_sides := [ ] ;
57318: LD_ADDR_EXP 84
57322: PUSH
57323: EMPTY
57324: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
57325: LD_ADDR_EXP 59
57329: PUSH
57330: EMPTY
57331: ST_TO_ADDR
// mc_building_repairs := [ ] ;
57332: LD_ADDR_EXP 60
57336: PUSH
57337: EMPTY
57338: ST_TO_ADDR
// mc_need_heal := [ ] ;
57339: LD_ADDR_EXP 61
57343: PUSH
57344: EMPTY
57345: ST_TO_ADDR
// mc_healers := [ ] ;
57346: LD_ADDR_EXP 62
57350: PUSH
57351: EMPTY
57352: ST_TO_ADDR
// mc_build_list := [ ] ;
57353: LD_ADDR_EXP 63
57357: PUSH
57358: EMPTY
57359: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
57360: LD_ADDR_EXP 90
57364: PUSH
57365: EMPTY
57366: ST_TO_ADDR
// mc_builders := [ ] ;
57367: LD_ADDR_EXP 64
57371: PUSH
57372: EMPTY
57373: ST_TO_ADDR
// mc_construct_list := [ ] ;
57374: LD_ADDR_EXP 65
57378: PUSH
57379: EMPTY
57380: ST_TO_ADDR
// mc_turret_list := [ ] ;
57381: LD_ADDR_EXP 66
57385: PUSH
57386: EMPTY
57387: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
57388: LD_ADDR_EXP 67
57392: PUSH
57393: EMPTY
57394: ST_TO_ADDR
// mc_miners := [ ] ;
57395: LD_ADDR_EXP 72
57399: PUSH
57400: EMPTY
57401: ST_TO_ADDR
// mc_mines := [ ] ;
57402: LD_ADDR_EXP 71
57406: PUSH
57407: EMPTY
57408: ST_TO_ADDR
// mc_minefields := [ ] ;
57409: LD_ADDR_EXP 73
57413: PUSH
57414: EMPTY
57415: ST_TO_ADDR
// mc_crates := [ ] ;
57416: LD_ADDR_EXP 74
57420: PUSH
57421: EMPTY
57422: ST_TO_ADDR
// mc_crates_collector := [ ] ;
57423: LD_ADDR_EXP 75
57427: PUSH
57428: EMPTY
57429: ST_TO_ADDR
// mc_crates_area := [ ] ;
57430: LD_ADDR_EXP 76
57434: PUSH
57435: EMPTY
57436: ST_TO_ADDR
// mc_vehicles := [ ] ;
57437: LD_ADDR_EXP 77
57441: PUSH
57442: EMPTY
57443: ST_TO_ADDR
// mc_attack := [ ] ;
57444: LD_ADDR_EXP 78
57448: PUSH
57449: EMPTY
57450: ST_TO_ADDR
// mc_produce := [ ] ;
57451: LD_ADDR_EXP 79
57455: PUSH
57456: EMPTY
57457: ST_TO_ADDR
// mc_defender := [ ] ;
57458: LD_ADDR_EXP 80
57462: PUSH
57463: EMPTY
57464: ST_TO_ADDR
// mc_parking := [ ] ;
57465: LD_ADDR_EXP 82
57469: PUSH
57470: EMPTY
57471: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
57472: LD_ADDR_EXP 68
57476: PUSH
57477: EMPTY
57478: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
57479: LD_ADDR_EXP 70
57483: PUSH
57484: EMPTY
57485: ST_TO_ADDR
// mc_scan := [ ] ;
57486: LD_ADDR_EXP 81
57490: PUSH
57491: EMPTY
57492: ST_TO_ADDR
// mc_scan_area := [ ] ;
57493: LD_ADDR_EXP 83
57497: PUSH
57498: EMPTY
57499: ST_TO_ADDR
// mc_tech := [ ] ;
57500: LD_ADDR_EXP 85
57504: PUSH
57505: EMPTY
57506: ST_TO_ADDR
// mc_class := [ ] ;
57507: LD_ADDR_EXP 99
57511: PUSH
57512: EMPTY
57513: ST_TO_ADDR
// mc_class_case_use := [ ] ;
57514: LD_ADDR_EXP 100
57518: PUSH
57519: EMPTY
57520: ST_TO_ADDR
// end ;
57521: LD_VAR 0 1
57525: RET
// export function MC_Kill ( base ) ; begin
57526: LD_INT 0
57528: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
57529: LD_ADDR_EXP 58
57533: PUSH
57534: LD_EXP 58
57538: PPUSH
57539: LD_VAR 0 1
57543: PPUSH
57544: EMPTY
57545: PPUSH
57546: CALL_OW 1
57550: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57551: LD_ADDR_EXP 59
57555: PUSH
57556: LD_EXP 59
57560: PPUSH
57561: LD_VAR 0 1
57565: PPUSH
57566: EMPTY
57567: PPUSH
57568: CALL_OW 1
57572: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57573: LD_ADDR_EXP 60
57577: PUSH
57578: LD_EXP 60
57582: PPUSH
57583: LD_VAR 0 1
57587: PPUSH
57588: EMPTY
57589: PPUSH
57590: CALL_OW 1
57594: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57595: LD_ADDR_EXP 61
57599: PUSH
57600: LD_EXP 61
57604: PPUSH
57605: LD_VAR 0 1
57609: PPUSH
57610: EMPTY
57611: PPUSH
57612: CALL_OW 1
57616: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57617: LD_ADDR_EXP 62
57621: PUSH
57622: LD_EXP 62
57626: PPUSH
57627: LD_VAR 0 1
57631: PPUSH
57632: EMPTY
57633: PPUSH
57634: CALL_OW 1
57638: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57639: LD_ADDR_EXP 63
57643: PUSH
57644: LD_EXP 63
57648: PPUSH
57649: LD_VAR 0 1
57653: PPUSH
57654: EMPTY
57655: PPUSH
57656: CALL_OW 1
57660: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57661: LD_ADDR_EXP 64
57665: PUSH
57666: LD_EXP 64
57670: PPUSH
57671: LD_VAR 0 1
57675: PPUSH
57676: EMPTY
57677: PPUSH
57678: CALL_OW 1
57682: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57683: LD_ADDR_EXP 65
57687: PUSH
57688: LD_EXP 65
57692: PPUSH
57693: LD_VAR 0 1
57697: PPUSH
57698: EMPTY
57699: PPUSH
57700: CALL_OW 1
57704: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57705: LD_ADDR_EXP 66
57709: PUSH
57710: LD_EXP 66
57714: PPUSH
57715: LD_VAR 0 1
57719: PPUSH
57720: EMPTY
57721: PPUSH
57722: CALL_OW 1
57726: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57727: LD_ADDR_EXP 67
57731: PUSH
57732: LD_EXP 67
57736: PPUSH
57737: LD_VAR 0 1
57741: PPUSH
57742: EMPTY
57743: PPUSH
57744: CALL_OW 1
57748: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57749: LD_ADDR_EXP 68
57753: PUSH
57754: LD_EXP 68
57758: PPUSH
57759: LD_VAR 0 1
57763: PPUSH
57764: EMPTY
57765: PPUSH
57766: CALL_OW 1
57770: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57771: LD_ADDR_EXP 69
57775: PUSH
57776: LD_EXP 69
57780: PPUSH
57781: LD_VAR 0 1
57785: PPUSH
57786: LD_INT 0
57788: PPUSH
57789: CALL_OW 1
57793: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57794: LD_ADDR_EXP 70
57798: PUSH
57799: LD_EXP 70
57803: PPUSH
57804: LD_VAR 0 1
57808: PPUSH
57809: EMPTY
57810: PPUSH
57811: CALL_OW 1
57815: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57816: LD_ADDR_EXP 71
57820: PUSH
57821: LD_EXP 71
57825: PPUSH
57826: LD_VAR 0 1
57830: PPUSH
57831: EMPTY
57832: PPUSH
57833: CALL_OW 1
57837: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57838: LD_ADDR_EXP 72
57842: PUSH
57843: LD_EXP 72
57847: PPUSH
57848: LD_VAR 0 1
57852: PPUSH
57853: EMPTY
57854: PPUSH
57855: CALL_OW 1
57859: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57860: LD_ADDR_EXP 73
57864: PUSH
57865: LD_EXP 73
57869: PPUSH
57870: LD_VAR 0 1
57874: PPUSH
57875: EMPTY
57876: PPUSH
57877: CALL_OW 1
57881: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57882: LD_ADDR_EXP 74
57886: PUSH
57887: LD_EXP 74
57891: PPUSH
57892: LD_VAR 0 1
57896: PPUSH
57897: EMPTY
57898: PPUSH
57899: CALL_OW 1
57903: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57904: LD_ADDR_EXP 75
57908: PUSH
57909: LD_EXP 75
57913: PPUSH
57914: LD_VAR 0 1
57918: PPUSH
57919: EMPTY
57920: PPUSH
57921: CALL_OW 1
57925: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57926: LD_ADDR_EXP 76
57930: PUSH
57931: LD_EXP 76
57935: PPUSH
57936: LD_VAR 0 1
57940: PPUSH
57941: EMPTY
57942: PPUSH
57943: CALL_OW 1
57947: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57948: LD_ADDR_EXP 77
57952: PUSH
57953: LD_EXP 77
57957: PPUSH
57958: LD_VAR 0 1
57962: PPUSH
57963: EMPTY
57964: PPUSH
57965: CALL_OW 1
57969: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57970: LD_ADDR_EXP 78
57974: PUSH
57975: LD_EXP 78
57979: PPUSH
57980: LD_VAR 0 1
57984: PPUSH
57985: EMPTY
57986: PPUSH
57987: CALL_OW 1
57991: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57992: LD_ADDR_EXP 79
57996: PUSH
57997: LD_EXP 79
58001: PPUSH
58002: LD_VAR 0 1
58006: PPUSH
58007: EMPTY
58008: PPUSH
58009: CALL_OW 1
58013: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58014: LD_ADDR_EXP 80
58018: PUSH
58019: LD_EXP 80
58023: PPUSH
58024: LD_VAR 0 1
58028: PPUSH
58029: EMPTY
58030: PPUSH
58031: CALL_OW 1
58035: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58036: LD_ADDR_EXP 81
58040: PUSH
58041: LD_EXP 81
58045: PPUSH
58046: LD_VAR 0 1
58050: PPUSH
58051: EMPTY
58052: PPUSH
58053: CALL_OW 1
58057: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58058: LD_ADDR_EXP 82
58062: PUSH
58063: LD_EXP 82
58067: PPUSH
58068: LD_VAR 0 1
58072: PPUSH
58073: EMPTY
58074: PPUSH
58075: CALL_OW 1
58079: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58080: LD_ADDR_EXP 83
58084: PUSH
58085: LD_EXP 83
58089: PPUSH
58090: LD_VAR 0 1
58094: PPUSH
58095: EMPTY
58096: PPUSH
58097: CALL_OW 1
58101: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58102: LD_ADDR_EXP 85
58106: PUSH
58107: LD_EXP 85
58111: PPUSH
58112: LD_VAR 0 1
58116: PPUSH
58117: EMPTY
58118: PPUSH
58119: CALL_OW 1
58123: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58124: LD_ADDR_EXP 87
58128: PUSH
58129: LD_EXP 87
58133: PPUSH
58134: LD_VAR 0 1
58138: PPUSH
58139: EMPTY
58140: PPUSH
58141: CALL_OW 1
58145: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58146: LD_ADDR_EXP 88
58150: PUSH
58151: LD_EXP 88
58155: PPUSH
58156: LD_VAR 0 1
58160: PPUSH
58161: EMPTY
58162: PPUSH
58163: CALL_OW 1
58167: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58168: LD_ADDR_EXP 89
58172: PUSH
58173: LD_EXP 89
58177: PPUSH
58178: LD_VAR 0 1
58182: PPUSH
58183: EMPTY
58184: PPUSH
58185: CALL_OW 1
58189: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58190: LD_ADDR_EXP 90
58194: PUSH
58195: LD_EXP 90
58199: PPUSH
58200: LD_VAR 0 1
58204: PPUSH
58205: EMPTY
58206: PPUSH
58207: CALL_OW 1
58211: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58212: LD_ADDR_EXP 91
58216: PUSH
58217: LD_EXP 91
58221: PPUSH
58222: LD_VAR 0 1
58226: PPUSH
58227: EMPTY
58228: PPUSH
58229: CALL_OW 1
58233: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58234: LD_ADDR_EXP 92
58238: PUSH
58239: LD_EXP 92
58243: PPUSH
58244: LD_VAR 0 1
58248: PPUSH
58249: EMPTY
58250: PPUSH
58251: CALL_OW 1
58255: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58256: LD_ADDR_EXP 93
58260: PUSH
58261: LD_EXP 93
58265: PPUSH
58266: LD_VAR 0 1
58270: PPUSH
58271: EMPTY
58272: PPUSH
58273: CALL_OW 1
58277: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58278: LD_ADDR_EXP 94
58282: PUSH
58283: LD_EXP 94
58287: PPUSH
58288: LD_VAR 0 1
58292: PPUSH
58293: EMPTY
58294: PPUSH
58295: CALL_OW 1
58299: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58300: LD_ADDR_EXP 95
58304: PUSH
58305: LD_EXP 95
58309: PPUSH
58310: LD_VAR 0 1
58314: PPUSH
58315: EMPTY
58316: PPUSH
58317: CALL_OW 1
58321: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58322: LD_ADDR_EXP 96
58326: PUSH
58327: LD_EXP 96
58331: PPUSH
58332: LD_VAR 0 1
58336: PPUSH
58337: EMPTY
58338: PPUSH
58339: CALL_OW 1
58343: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58344: LD_ADDR_EXP 97
58348: PUSH
58349: LD_EXP 97
58353: PPUSH
58354: LD_VAR 0 1
58358: PPUSH
58359: EMPTY
58360: PPUSH
58361: CALL_OW 1
58365: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58366: LD_ADDR_EXP 98
58370: PUSH
58371: LD_EXP 98
58375: PPUSH
58376: LD_VAR 0 1
58380: PPUSH
58381: EMPTY
58382: PPUSH
58383: CALL_OW 1
58387: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58388: LD_ADDR_EXP 99
58392: PUSH
58393: LD_EXP 99
58397: PPUSH
58398: LD_VAR 0 1
58402: PPUSH
58403: EMPTY
58404: PPUSH
58405: CALL_OW 1
58409: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58410: LD_ADDR_EXP 100
58414: PUSH
58415: LD_EXP 100
58419: PPUSH
58420: LD_VAR 0 1
58424: PPUSH
58425: LD_INT 0
58427: PPUSH
58428: CALL_OW 1
58432: ST_TO_ADDR
// end ;
58433: LD_VAR 0 2
58437: RET
// export function MC_Add ( side , units ) ; var base ; begin
58438: LD_INT 0
58440: PPUSH
58441: PPUSH
// base := mc_bases + 1 ;
58442: LD_ADDR_VAR 0 4
58446: PUSH
58447: LD_EXP 58
58451: PUSH
58452: LD_INT 1
58454: PLUS
58455: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
58456: LD_ADDR_EXP 84
58460: PUSH
58461: LD_EXP 84
58465: PPUSH
58466: LD_VAR 0 4
58470: PPUSH
58471: LD_VAR 0 1
58475: PPUSH
58476: CALL_OW 1
58480: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
58481: LD_ADDR_EXP 58
58485: PUSH
58486: LD_EXP 58
58490: PPUSH
58491: LD_VAR 0 4
58495: PPUSH
58496: LD_VAR 0 2
58500: PPUSH
58501: CALL_OW 1
58505: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
58506: LD_ADDR_EXP 59
58510: PUSH
58511: LD_EXP 59
58515: PPUSH
58516: LD_VAR 0 4
58520: PPUSH
58521: EMPTY
58522: PPUSH
58523: CALL_OW 1
58527: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
58528: LD_ADDR_EXP 60
58532: PUSH
58533: LD_EXP 60
58537: PPUSH
58538: LD_VAR 0 4
58542: PPUSH
58543: EMPTY
58544: PPUSH
58545: CALL_OW 1
58549: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
58550: LD_ADDR_EXP 61
58554: PUSH
58555: LD_EXP 61
58559: PPUSH
58560: LD_VAR 0 4
58564: PPUSH
58565: EMPTY
58566: PPUSH
58567: CALL_OW 1
58571: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
58572: LD_ADDR_EXP 62
58576: PUSH
58577: LD_EXP 62
58581: PPUSH
58582: LD_VAR 0 4
58586: PPUSH
58587: EMPTY
58588: PPUSH
58589: CALL_OW 1
58593: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
58594: LD_ADDR_EXP 63
58598: PUSH
58599: LD_EXP 63
58603: PPUSH
58604: LD_VAR 0 4
58608: PPUSH
58609: EMPTY
58610: PPUSH
58611: CALL_OW 1
58615: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
58616: LD_ADDR_EXP 64
58620: PUSH
58621: LD_EXP 64
58625: PPUSH
58626: LD_VAR 0 4
58630: PPUSH
58631: EMPTY
58632: PPUSH
58633: CALL_OW 1
58637: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
58638: LD_ADDR_EXP 65
58642: PUSH
58643: LD_EXP 65
58647: PPUSH
58648: LD_VAR 0 4
58652: PPUSH
58653: EMPTY
58654: PPUSH
58655: CALL_OW 1
58659: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
58660: LD_ADDR_EXP 66
58664: PUSH
58665: LD_EXP 66
58669: PPUSH
58670: LD_VAR 0 4
58674: PPUSH
58675: EMPTY
58676: PPUSH
58677: CALL_OW 1
58681: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58682: LD_ADDR_EXP 67
58686: PUSH
58687: LD_EXP 67
58691: PPUSH
58692: LD_VAR 0 4
58696: PPUSH
58697: EMPTY
58698: PPUSH
58699: CALL_OW 1
58703: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58704: LD_ADDR_EXP 68
58708: PUSH
58709: LD_EXP 68
58713: PPUSH
58714: LD_VAR 0 4
58718: PPUSH
58719: EMPTY
58720: PPUSH
58721: CALL_OW 1
58725: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58726: LD_ADDR_EXP 69
58730: PUSH
58731: LD_EXP 69
58735: PPUSH
58736: LD_VAR 0 4
58740: PPUSH
58741: LD_INT 0
58743: PPUSH
58744: CALL_OW 1
58748: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58749: LD_ADDR_EXP 70
58753: PUSH
58754: LD_EXP 70
58758: PPUSH
58759: LD_VAR 0 4
58763: PPUSH
58764: EMPTY
58765: PPUSH
58766: CALL_OW 1
58770: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
58771: LD_ADDR_EXP 71
58775: PUSH
58776: LD_EXP 71
58780: PPUSH
58781: LD_VAR 0 4
58785: PPUSH
58786: EMPTY
58787: PPUSH
58788: CALL_OW 1
58792: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58793: LD_ADDR_EXP 72
58797: PUSH
58798: LD_EXP 72
58802: PPUSH
58803: LD_VAR 0 4
58807: PPUSH
58808: EMPTY
58809: PPUSH
58810: CALL_OW 1
58814: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58815: LD_ADDR_EXP 73
58819: PUSH
58820: LD_EXP 73
58824: PPUSH
58825: LD_VAR 0 4
58829: PPUSH
58830: EMPTY
58831: PPUSH
58832: CALL_OW 1
58836: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58837: LD_ADDR_EXP 74
58841: PUSH
58842: LD_EXP 74
58846: PPUSH
58847: LD_VAR 0 4
58851: PPUSH
58852: EMPTY
58853: PPUSH
58854: CALL_OW 1
58858: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58859: LD_ADDR_EXP 75
58863: PUSH
58864: LD_EXP 75
58868: PPUSH
58869: LD_VAR 0 4
58873: PPUSH
58874: EMPTY
58875: PPUSH
58876: CALL_OW 1
58880: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58881: LD_ADDR_EXP 76
58885: PUSH
58886: LD_EXP 76
58890: PPUSH
58891: LD_VAR 0 4
58895: PPUSH
58896: EMPTY
58897: PPUSH
58898: CALL_OW 1
58902: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58903: LD_ADDR_EXP 77
58907: PUSH
58908: LD_EXP 77
58912: PPUSH
58913: LD_VAR 0 4
58917: PPUSH
58918: EMPTY
58919: PPUSH
58920: CALL_OW 1
58924: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58925: LD_ADDR_EXP 78
58929: PUSH
58930: LD_EXP 78
58934: PPUSH
58935: LD_VAR 0 4
58939: PPUSH
58940: EMPTY
58941: PPUSH
58942: CALL_OW 1
58946: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58947: LD_ADDR_EXP 79
58951: PUSH
58952: LD_EXP 79
58956: PPUSH
58957: LD_VAR 0 4
58961: PPUSH
58962: EMPTY
58963: PPUSH
58964: CALL_OW 1
58968: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58969: LD_ADDR_EXP 80
58973: PUSH
58974: LD_EXP 80
58978: PPUSH
58979: LD_VAR 0 4
58983: PPUSH
58984: EMPTY
58985: PPUSH
58986: CALL_OW 1
58990: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58991: LD_ADDR_EXP 81
58995: PUSH
58996: LD_EXP 81
59000: PPUSH
59001: LD_VAR 0 4
59005: PPUSH
59006: EMPTY
59007: PPUSH
59008: CALL_OW 1
59012: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
59013: LD_ADDR_EXP 82
59017: PUSH
59018: LD_EXP 82
59022: PPUSH
59023: LD_VAR 0 4
59027: PPUSH
59028: EMPTY
59029: PPUSH
59030: CALL_OW 1
59034: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
59035: LD_ADDR_EXP 83
59039: PUSH
59040: LD_EXP 83
59044: PPUSH
59045: LD_VAR 0 4
59049: PPUSH
59050: EMPTY
59051: PPUSH
59052: CALL_OW 1
59056: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
59057: LD_ADDR_EXP 85
59061: PUSH
59062: LD_EXP 85
59066: PPUSH
59067: LD_VAR 0 4
59071: PPUSH
59072: EMPTY
59073: PPUSH
59074: CALL_OW 1
59078: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
59079: LD_ADDR_EXP 87
59083: PUSH
59084: LD_EXP 87
59088: PPUSH
59089: LD_VAR 0 4
59093: PPUSH
59094: EMPTY
59095: PPUSH
59096: CALL_OW 1
59100: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
59101: LD_ADDR_EXP 88
59105: PUSH
59106: LD_EXP 88
59110: PPUSH
59111: LD_VAR 0 4
59115: PPUSH
59116: EMPTY
59117: PPUSH
59118: CALL_OW 1
59122: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
59123: LD_ADDR_EXP 89
59127: PUSH
59128: LD_EXP 89
59132: PPUSH
59133: LD_VAR 0 4
59137: PPUSH
59138: EMPTY
59139: PPUSH
59140: CALL_OW 1
59144: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
59145: LD_ADDR_EXP 90
59149: PUSH
59150: LD_EXP 90
59154: PPUSH
59155: LD_VAR 0 4
59159: PPUSH
59160: EMPTY
59161: PPUSH
59162: CALL_OW 1
59166: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
59167: LD_ADDR_EXP 91
59171: PUSH
59172: LD_EXP 91
59176: PPUSH
59177: LD_VAR 0 4
59181: PPUSH
59182: EMPTY
59183: PPUSH
59184: CALL_OW 1
59188: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
59189: LD_ADDR_EXP 92
59193: PUSH
59194: LD_EXP 92
59198: PPUSH
59199: LD_VAR 0 4
59203: PPUSH
59204: EMPTY
59205: PPUSH
59206: CALL_OW 1
59210: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
59211: LD_ADDR_EXP 93
59215: PUSH
59216: LD_EXP 93
59220: PPUSH
59221: LD_VAR 0 4
59225: PPUSH
59226: EMPTY
59227: PPUSH
59228: CALL_OW 1
59232: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
59233: LD_ADDR_EXP 94
59237: PUSH
59238: LD_EXP 94
59242: PPUSH
59243: LD_VAR 0 4
59247: PPUSH
59248: EMPTY
59249: PPUSH
59250: CALL_OW 1
59254: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
59255: LD_ADDR_EXP 95
59259: PUSH
59260: LD_EXP 95
59264: PPUSH
59265: LD_VAR 0 4
59269: PPUSH
59270: EMPTY
59271: PPUSH
59272: CALL_OW 1
59276: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
59277: LD_ADDR_EXP 96
59281: PUSH
59282: LD_EXP 96
59286: PPUSH
59287: LD_VAR 0 4
59291: PPUSH
59292: EMPTY
59293: PPUSH
59294: CALL_OW 1
59298: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
59299: LD_ADDR_EXP 97
59303: PUSH
59304: LD_EXP 97
59308: PPUSH
59309: LD_VAR 0 4
59313: PPUSH
59314: EMPTY
59315: PPUSH
59316: CALL_OW 1
59320: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
59321: LD_ADDR_EXP 98
59325: PUSH
59326: LD_EXP 98
59330: PPUSH
59331: LD_VAR 0 4
59335: PPUSH
59336: EMPTY
59337: PPUSH
59338: CALL_OW 1
59342: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
59343: LD_ADDR_EXP 99
59347: PUSH
59348: LD_EXP 99
59352: PPUSH
59353: LD_VAR 0 4
59357: PPUSH
59358: EMPTY
59359: PPUSH
59360: CALL_OW 1
59364: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
59365: LD_ADDR_EXP 100
59369: PUSH
59370: LD_EXP 100
59374: PPUSH
59375: LD_VAR 0 4
59379: PPUSH
59380: LD_INT 0
59382: PPUSH
59383: CALL_OW 1
59387: ST_TO_ADDR
// result := base ;
59388: LD_ADDR_VAR 0 3
59392: PUSH
59393: LD_VAR 0 4
59397: ST_TO_ADDR
// end ;
59398: LD_VAR 0 3
59402: RET
// export function MC_Start ( ) ; var i ; begin
59403: LD_INT 0
59405: PPUSH
59406: PPUSH
// for i = 1 to mc_bases do
59407: LD_ADDR_VAR 0 2
59411: PUSH
59412: DOUBLE
59413: LD_INT 1
59415: DEC
59416: ST_TO_ADDR
59417: LD_EXP 58
59421: PUSH
59422: FOR_TO
59423: IFFALSE 60500
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
59425: LD_ADDR_EXP 58
59429: PUSH
59430: LD_EXP 58
59434: PPUSH
59435: LD_VAR 0 2
59439: PPUSH
59440: LD_EXP 58
59444: PUSH
59445: LD_VAR 0 2
59449: ARRAY
59450: PUSH
59451: LD_INT 0
59453: DIFF
59454: PPUSH
59455: CALL_OW 1
59459: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
59460: LD_ADDR_EXP 59
59464: PUSH
59465: LD_EXP 59
59469: PPUSH
59470: LD_VAR 0 2
59474: PPUSH
59475: EMPTY
59476: PPUSH
59477: CALL_OW 1
59481: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59482: LD_ADDR_EXP 60
59486: PUSH
59487: LD_EXP 60
59491: PPUSH
59492: LD_VAR 0 2
59496: PPUSH
59497: EMPTY
59498: PPUSH
59499: CALL_OW 1
59503: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
59504: LD_ADDR_EXP 61
59508: PUSH
59509: LD_EXP 61
59513: PPUSH
59514: LD_VAR 0 2
59518: PPUSH
59519: EMPTY
59520: PPUSH
59521: CALL_OW 1
59525: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
59526: LD_ADDR_EXP 62
59530: PUSH
59531: LD_EXP 62
59535: PPUSH
59536: LD_VAR 0 2
59540: PPUSH
59541: EMPTY
59542: PUSH
59543: EMPTY
59544: PUSH
59545: EMPTY
59546: LIST
59547: LIST
59548: PPUSH
59549: CALL_OW 1
59553: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
59554: LD_ADDR_EXP 63
59558: PUSH
59559: LD_EXP 63
59563: PPUSH
59564: LD_VAR 0 2
59568: PPUSH
59569: EMPTY
59570: PPUSH
59571: CALL_OW 1
59575: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
59576: LD_ADDR_EXP 90
59580: PUSH
59581: LD_EXP 90
59585: PPUSH
59586: LD_VAR 0 2
59590: PPUSH
59591: EMPTY
59592: PPUSH
59593: CALL_OW 1
59597: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
59598: LD_ADDR_EXP 64
59602: PUSH
59603: LD_EXP 64
59607: PPUSH
59608: LD_VAR 0 2
59612: PPUSH
59613: EMPTY
59614: PPUSH
59615: CALL_OW 1
59619: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
59620: LD_ADDR_EXP 65
59624: PUSH
59625: LD_EXP 65
59629: PPUSH
59630: LD_VAR 0 2
59634: PPUSH
59635: EMPTY
59636: PPUSH
59637: CALL_OW 1
59641: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
59642: LD_ADDR_EXP 66
59646: PUSH
59647: LD_EXP 66
59651: PPUSH
59652: LD_VAR 0 2
59656: PPUSH
59657: LD_EXP 58
59661: PUSH
59662: LD_VAR 0 2
59666: ARRAY
59667: PPUSH
59668: LD_INT 2
59670: PUSH
59671: LD_INT 30
59673: PUSH
59674: LD_INT 32
59676: PUSH
59677: EMPTY
59678: LIST
59679: LIST
59680: PUSH
59681: LD_INT 30
59683: PUSH
59684: LD_INT 33
59686: PUSH
59687: EMPTY
59688: LIST
59689: LIST
59690: PUSH
59691: EMPTY
59692: LIST
59693: LIST
59694: LIST
59695: PPUSH
59696: CALL_OW 72
59700: PPUSH
59701: CALL_OW 1
59705: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
59706: LD_ADDR_EXP 67
59710: PUSH
59711: LD_EXP 67
59715: PPUSH
59716: LD_VAR 0 2
59720: PPUSH
59721: LD_EXP 58
59725: PUSH
59726: LD_VAR 0 2
59730: ARRAY
59731: PPUSH
59732: LD_INT 2
59734: PUSH
59735: LD_INT 30
59737: PUSH
59738: LD_INT 32
59740: PUSH
59741: EMPTY
59742: LIST
59743: LIST
59744: PUSH
59745: LD_INT 30
59747: PUSH
59748: LD_INT 31
59750: PUSH
59751: EMPTY
59752: LIST
59753: LIST
59754: PUSH
59755: EMPTY
59756: LIST
59757: LIST
59758: LIST
59759: PUSH
59760: LD_INT 58
59762: PUSH
59763: EMPTY
59764: LIST
59765: PUSH
59766: EMPTY
59767: LIST
59768: LIST
59769: PPUSH
59770: CALL_OW 72
59774: PPUSH
59775: CALL_OW 1
59779: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
59780: LD_ADDR_EXP 68
59784: PUSH
59785: LD_EXP 68
59789: PPUSH
59790: LD_VAR 0 2
59794: PPUSH
59795: EMPTY
59796: PPUSH
59797: CALL_OW 1
59801: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
59802: LD_ADDR_EXP 72
59806: PUSH
59807: LD_EXP 72
59811: PPUSH
59812: LD_VAR 0 2
59816: PPUSH
59817: EMPTY
59818: PPUSH
59819: CALL_OW 1
59823: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
59824: LD_ADDR_EXP 71
59828: PUSH
59829: LD_EXP 71
59833: PPUSH
59834: LD_VAR 0 2
59838: PPUSH
59839: EMPTY
59840: PPUSH
59841: CALL_OW 1
59845: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
59846: LD_ADDR_EXP 73
59850: PUSH
59851: LD_EXP 73
59855: PPUSH
59856: LD_VAR 0 2
59860: PPUSH
59861: EMPTY
59862: PPUSH
59863: CALL_OW 1
59867: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
59868: LD_ADDR_EXP 74
59872: PUSH
59873: LD_EXP 74
59877: PPUSH
59878: LD_VAR 0 2
59882: PPUSH
59883: EMPTY
59884: PPUSH
59885: CALL_OW 1
59889: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
59890: LD_ADDR_EXP 75
59894: PUSH
59895: LD_EXP 75
59899: PPUSH
59900: LD_VAR 0 2
59904: PPUSH
59905: EMPTY
59906: PPUSH
59907: CALL_OW 1
59911: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
59912: LD_ADDR_EXP 76
59916: PUSH
59917: LD_EXP 76
59921: PPUSH
59922: LD_VAR 0 2
59926: PPUSH
59927: EMPTY
59928: PPUSH
59929: CALL_OW 1
59933: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
59934: LD_ADDR_EXP 77
59938: PUSH
59939: LD_EXP 77
59943: PPUSH
59944: LD_VAR 0 2
59948: PPUSH
59949: EMPTY
59950: PPUSH
59951: CALL_OW 1
59955: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
59956: LD_ADDR_EXP 78
59960: PUSH
59961: LD_EXP 78
59965: PPUSH
59966: LD_VAR 0 2
59970: PPUSH
59971: EMPTY
59972: PPUSH
59973: CALL_OW 1
59977: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
59978: LD_ADDR_EXP 79
59982: PUSH
59983: LD_EXP 79
59987: PPUSH
59988: LD_VAR 0 2
59992: PPUSH
59993: EMPTY
59994: PPUSH
59995: CALL_OW 1
59999: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
60000: LD_ADDR_EXP 80
60004: PUSH
60005: LD_EXP 80
60009: PPUSH
60010: LD_VAR 0 2
60014: PPUSH
60015: EMPTY
60016: PPUSH
60017: CALL_OW 1
60021: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
60022: LD_ADDR_EXP 69
60026: PUSH
60027: LD_EXP 69
60031: PPUSH
60032: LD_VAR 0 2
60036: PPUSH
60037: LD_INT 0
60039: PPUSH
60040: CALL_OW 1
60044: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
60045: LD_ADDR_EXP 82
60049: PUSH
60050: LD_EXP 82
60054: PPUSH
60055: LD_VAR 0 2
60059: PPUSH
60060: LD_INT 0
60062: PPUSH
60063: CALL_OW 1
60067: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
60068: LD_ADDR_EXP 70
60072: PUSH
60073: LD_EXP 70
60077: PPUSH
60078: LD_VAR 0 2
60082: PPUSH
60083: EMPTY
60084: PPUSH
60085: CALL_OW 1
60089: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
60090: LD_ADDR_EXP 81
60094: PUSH
60095: LD_EXP 81
60099: PPUSH
60100: LD_VAR 0 2
60104: PPUSH
60105: LD_INT 0
60107: PPUSH
60108: CALL_OW 1
60112: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
60113: LD_ADDR_EXP 83
60117: PUSH
60118: LD_EXP 83
60122: PPUSH
60123: LD_VAR 0 2
60127: PPUSH
60128: EMPTY
60129: PPUSH
60130: CALL_OW 1
60134: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
60135: LD_ADDR_EXP 86
60139: PUSH
60140: LD_EXP 86
60144: PPUSH
60145: LD_VAR 0 2
60149: PPUSH
60150: LD_INT 0
60152: PPUSH
60153: CALL_OW 1
60157: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
60158: LD_ADDR_EXP 87
60162: PUSH
60163: LD_EXP 87
60167: PPUSH
60168: LD_VAR 0 2
60172: PPUSH
60173: EMPTY
60174: PPUSH
60175: CALL_OW 1
60179: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60180: LD_ADDR_EXP 88
60184: PUSH
60185: LD_EXP 88
60189: PPUSH
60190: LD_VAR 0 2
60194: PPUSH
60195: EMPTY
60196: PPUSH
60197: CALL_OW 1
60201: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60202: LD_ADDR_EXP 89
60206: PUSH
60207: LD_EXP 89
60211: PPUSH
60212: LD_VAR 0 2
60216: PPUSH
60217: EMPTY
60218: PPUSH
60219: CALL_OW 1
60223: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
60224: LD_ADDR_EXP 91
60228: PUSH
60229: LD_EXP 91
60233: PPUSH
60234: LD_VAR 0 2
60238: PPUSH
60239: LD_EXP 58
60243: PUSH
60244: LD_VAR 0 2
60248: ARRAY
60249: PPUSH
60250: LD_INT 2
60252: PUSH
60253: LD_INT 30
60255: PUSH
60256: LD_INT 6
60258: PUSH
60259: EMPTY
60260: LIST
60261: LIST
60262: PUSH
60263: LD_INT 30
60265: PUSH
60266: LD_INT 7
60268: PUSH
60269: EMPTY
60270: LIST
60271: LIST
60272: PUSH
60273: LD_INT 30
60275: PUSH
60276: LD_INT 8
60278: PUSH
60279: EMPTY
60280: LIST
60281: LIST
60282: PUSH
60283: EMPTY
60284: LIST
60285: LIST
60286: LIST
60287: LIST
60288: PPUSH
60289: CALL_OW 72
60293: PPUSH
60294: CALL_OW 1
60298: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
60299: LD_ADDR_EXP 92
60303: PUSH
60304: LD_EXP 92
60308: PPUSH
60309: LD_VAR 0 2
60313: PPUSH
60314: EMPTY
60315: PPUSH
60316: CALL_OW 1
60320: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
60321: LD_ADDR_EXP 93
60325: PUSH
60326: LD_EXP 93
60330: PPUSH
60331: LD_VAR 0 2
60335: PPUSH
60336: EMPTY
60337: PPUSH
60338: CALL_OW 1
60342: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
60343: LD_ADDR_EXP 94
60347: PUSH
60348: LD_EXP 94
60352: PPUSH
60353: LD_VAR 0 2
60357: PPUSH
60358: EMPTY
60359: PPUSH
60360: CALL_OW 1
60364: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
60365: LD_ADDR_EXP 95
60369: PUSH
60370: LD_EXP 95
60374: PPUSH
60375: LD_VAR 0 2
60379: PPUSH
60380: EMPTY
60381: PPUSH
60382: CALL_OW 1
60386: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60387: LD_ADDR_EXP 96
60391: PUSH
60392: LD_EXP 96
60396: PPUSH
60397: LD_VAR 0 2
60401: PPUSH
60402: EMPTY
60403: PPUSH
60404: CALL_OW 1
60408: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
60409: LD_ADDR_EXP 97
60413: PUSH
60414: LD_EXP 97
60418: PPUSH
60419: LD_VAR 0 2
60423: PPUSH
60424: EMPTY
60425: PPUSH
60426: CALL_OW 1
60430: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
60431: LD_ADDR_EXP 98
60435: PUSH
60436: LD_EXP 98
60440: PPUSH
60441: LD_VAR 0 2
60445: PPUSH
60446: EMPTY
60447: PPUSH
60448: CALL_OW 1
60452: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
60453: LD_ADDR_EXP 99
60457: PUSH
60458: LD_EXP 99
60462: PPUSH
60463: LD_VAR 0 2
60467: PPUSH
60468: EMPTY
60469: PPUSH
60470: CALL_OW 1
60474: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
60475: LD_ADDR_EXP 100
60479: PUSH
60480: LD_EXP 100
60484: PPUSH
60485: LD_VAR 0 2
60489: PPUSH
60490: LD_INT 0
60492: PPUSH
60493: CALL_OW 1
60497: ST_TO_ADDR
// end ;
60498: GO 59422
60500: POP
60501: POP
// MC_InitSides ( ) ;
60502: CALL 60788 0 0
// MC_InitResearch ( ) ;
60506: CALL 60527 0 0
// CustomInitMacro ( ) ;
60510: CALL 185 0 0
// skirmish := true ;
60514: LD_ADDR_EXP 56
60518: PUSH
60519: LD_INT 1
60521: ST_TO_ADDR
// end ;
60522: LD_VAR 0 1
60526: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
60527: LD_INT 0
60529: PPUSH
60530: PPUSH
60531: PPUSH
60532: PPUSH
60533: PPUSH
60534: PPUSH
// if not mc_bases then
60535: LD_EXP 58
60539: NOT
60540: IFFALSE 60544
// exit ;
60542: GO 60783
// for i = 1 to 8 do
60544: LD_ADDR_VAR 0 2
60548: PUSH
60549: DOUBLE
60550: LD_INT 1
60552: DEC
60553: ST_TO_ADDR
60554: LD_INT 8
60556: PUSH
60557: FOR_TO
60558: IFFALSE 60584
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
60560: LD_ADDR_EXP 85
60564: PUSH
60565: LD_EXP 85
60569: PPUSH
60570: LD_VAR 0 2
60574: PPUSH
60575: EMPTY
60576: PPUSH
60577: CALL_OW 1
60581: ST_TO_ADDR
60582: GO 60557
60584: POP
60585: POP
// tmp := [ ] ;
60586: LD_ADDR_VAR 0 5
60590: PUSH
60591: EMPTY
60592: ST_TO_ADDR
// for i = 1 to mc_sides do
60593: LD_ADDR_VAR 0 2
60597: PUSH
60598: DOUBLE
60599: LD_INT 1
60601: DEC
60602: ST_TO_ADDR
60603: LD_EXP 84
60607: PUSH
60608: FOR_TO
60609: IFFALSE 60667
// if not mc_sides [ i ] in tmp then
60611: LD_EXP 84
60615: PUSH
60616: LD_VAR 0 2
60620: ARRAY
60621: PUSH
60622: LD_VAR 0 5
60626: IN
60627: NOT
60628: IFFALSE 60665
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
60630: LD_ADDR_VAR 0 5
60634: PUSH
60635: LD_VAR 0 5
60639: PPUSH
60640: LD_VAR 0 5
60644: PUSH
60645: LD_INT 1
60647: PLUS
60648: PPUSH
60649: LD_EXP 84
60653: PUSH
60654: LD_VAR 0 2
60658: ARRAY
60659: PPUSH
60660: CALL_OW 2
60664: ST_TO_ADDR
60665: GO 60608
60667: POP
60668: POP
// if not tmp then
60669: LD_VAR 0 5
60673: NOT
60674: IFFALSE 60678
// exit ;
60676: GO 60783
// for j in tmp do
60678: LD_ADDR_VAR 0 3
60682: PUSH
60683: LD_VAR 0 5
60687: PUSH
60688: FOR_IN
60689: IFFALSE 60781
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
60691: LD_ADDR_VAR 0 6
60695: PUSH
60696: LD_INT 22
60698: PUSH
60699: LD_VAR 0 3
60703: PUSH
60704: EMPTY
60705: LIST
60706: LIST
60707: PPUSH
60708: CALL_OW 69
60712: ST_TO_ADDR
// if not un then
60713: LD_VAR 0 6
60717: NOT
60718: IFFALSE 60722
// continue ;
60720: GO 60688
// nation := GetNation ( un [ 1 ] ) ;
60722: LD_ADDR_VAR 0 4
60726: PUSH
60727: LD_VAR 0 6
60731: PUSH
60732: LD_INT 1
60734: ARRAY
60735: PPUSH
60736: CALL_OW 248
60740: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
60741: LD_ADDR_EXP 85
60745: PUSH
60746: LD_EXP 85
60750: PPUSH
60751: LD_VAR 0 3
60755: PPUSH
60756: LD_VAR 0 3
60760: PPUSH
60761: LD_VAR 0 4
60765: PPUSH
60766: LD_INT 1
60768: PPUSH
60769: CALL 14192 0 3
60773: PPUSH
60774: CALL_OW 1
60778: ST_TO_ADDR
// end ;
60779: GO 60688
60781: POP
60782: POP
// end ;
60783: LD_VAR 0 1
60787: RET
// export function MC_InitSides ( ) ; var i ; begin
60788: LD_INT 0
60790: PPUSH
60791: PPUSH
// if not mc_bases then
60792: LD_EXP 58
60796: NOT
60797: IFFALSE 60801
// exit ;
60799: GO 60875
// for i = 1 to mc_bases do
60801: LD_ADDR_VAR 0 2
60805: PUSH
60806: DOUBLE
60807: LD_INT 1
60809: DEC
60810: ST_TO_ADDR
60811: LD_EXP 58
60815: PUSH
60816: FOR_TO
60817: IFFALSE 60873
// if mc_bases [ i ] then
60819: LD_EXP 58
60823: PUSH
60824: LD_VAR 0 2
60828: ARRAY
60829: IFFALSE 60871
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
60831: LD_ADDR_EXP 84
60835: PUSH
60836: LD_EXP 84
60840: PPUSH
60841: LD_VAR 0 2
60845: PPUSH
60846: LD_EXP 58
60850: PUSH
60851: LD_VAR 0 2
60855: ARRAY
60856: PUSH
60857: LD_INT 1
60859: ARRAY
60860: PPUSH
60861: CALL_OW 255
60865: PPUSH
60866: CALL_OW 1
60870: ST_TO_ADDR
60871: GO 60816
60873: POP
60874: POP
// end ;
60875: LD_VAR 0 1
60879: RET
// every 0 0$01 trigger skirmish do
60880: LD_EXP 56
60884: IFFALSE 61038
60886: GO 60888
60888: DISABLE
// begin enable ;
60889: ENABLE
// MC_CheckBuildings ( ) ;
60890: CALL 65536 0 0
// MC_CheckPeopleLife ( ) ;
60894: CALL 65661 0 0
// RaiseSailEvent ( 100 ) ;
60898: LD_INT 100
60900: PPUSH
60901: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
60905: LD_INT 103
60907: PPUSH
60908: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
60912: LD_INT 104
60914: PPUSH
60915: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
60919: LD_INT 105
60921: PPUSH
60922: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
60926: LD_INT 106
60928: PPUSH
60929: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
60933: LD_INT 107
60935: PPUSH
60936: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
60940: LD_INT 108
60942: PPUSH
60943: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
60947: LD_INT 109
60949: PPUSH
60950: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
60954: LD_INT 110
60956: PPUSH
60957: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
60961: LD_INT 111
60963: PPUSH
60964: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
60968: LD_INT 112
60970: PPUSH
60971: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
60975: LD_INT 113
60977: PPUSH
60978: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
60982: LD_INT 120
60984: PPUSH
60985: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
60989: LD_INT 121
60991: PPUSH
60992: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
60996: LD_INT 122
60998: PPUSH
60999: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
61003: LD_INT 123
61005: PPUSH
61006: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
61010: LD_INT 124
61012: PPUSH
61013: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
61017: LD_INT 125
61019: PPUSH
61020: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
61024: LD_INT 126
61026: PPUSH
61027: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
61031: LD_INT 200
61033: PPUSH
61034: CALL_OW 427
// end ;
61038: END
// on SailEvent ( event ) do begin if event < 100 then
61039: LD_VAR 0 1
61043: PUSH
61044: LD_INT 100
61046: LESS
61047: IFFALSE 61058
// CustomEvent ( event ) ;
61049: LD_VAR 0 1
61053: PPUSH
61054: CALL 12894 0 1
// if event = 100 then
61058: LD_VAR 0 1
61062: PUSH
61063: LD_INT 100
61065: EQUAL
61066: IFFALSE 61072
// MC_ClassManager ( ) ;
61068: CALL 61464 0 0
// if event = 101 then
61072: LD_VAR 0 1
61076: PUSH
61077: LD_INT 101
61079: EQUAL
61080: IFFALSE 61086
// MC_RepairBuildings ( ) ;
61082: CALL 66257 0 0
// if event = 102 then
61086: LD_VAR 0 1
61090: PUSH
61091: LD_INT 102
61093: EQUAL
61094: IFFALSE 61100
// MC_Heal ( ) ;
61096: CALL 66989 0 0
// if event = 103 then
61100: LD_VAR 0 1
61104: PUSH
61105: LD_INT 103
61107: EQUAL
61108: IFFALSE 61114
// MC_Build ( ) ;
61110: CALL 67411 0 0
// if event = 104 then
61114: LD_VAR 0 1
61118: PUSH
61119: LD_INT 104
61121: EQUAL
61122: IFFALSE 61128
// MC_TurretWeapon ( ) ;
61124: CALL 69024 0 0
// if event = 105 then
61128: LD_VAR 0 1
61132: PUSH
61133: LD_INT 105
61135: EQUAL
61136: IFFALSE 61142
// MC_BuildUpgrade ( ) ;
61138: CALL 68575 0 0
// if event = 106 then
61142: LD_VAR 0 1
61146: PUSH
61147: LD_INT 106
61149: EQUAL
61150: IFFALSE 61156
// MC_PlantMines ( ) ;
61152: CALL 69454 0 0
// if event = 107 then
61156: LD_VAR 0 1
61160: PUSH
61161: LD_INT 107
61163: EQUAL
61164: IFFALSE 61170
// MC_CollectCrates ( ) ;
61166: CALL 70488 0 0
// if event = 108 then
61170: LD_VAR 0 1
61174: PUSH
61175: LD_INT 108
61177: EQUAL
61178: IFFALSE 61184
// MC_LinkRemoteControl ( ) ;
61180: CALL 72264 0 0
// if event = 109 then
61184: LD_VAR 0 1
61188: PUSH
61189: LD_INT 109
61191: EQUAL
61192: IFFALSE 61198
// MC_ProduceVehicle ( ) ;
61194: CALL 72445 0 0
// if event = 110 then
61198: LD_VAR 0 1
61202: PUSH
61203: LD_INT 110
61205: EQUAL
61206: IFFALSE 61212
// MC_SendAttack ( ) ;
61208: CALL 72911 0 0
// if event = 111 then
61212: LD_VAR 0 1
61216: PUSH
61217: LD_INT 111
61219: EQUAL
61220: IFFALSE 61226
// MC_Defend ( ) ;
61222: CALL 73019 0 0
// if event = 112 then
61226: LD_VAR 0 1
61230: PUSH
61231: LD_INT 112
61233: EQUAL
61234: IFFALSE 61240
// MC_Research ( ) ;
61236: CALL 73624 0 0
// if event = 113 then
61240: LD_VAR 0 1
61244: PUSH
61245: LD_INT 113
61247: EQUAL
61248: IFFALSE 61254
// MC_MinesTrigger ( ) ;
61250: CALL 74738 0 0
// if event = 120 then
61254: LD_VAR 0 1
61258: PUSH
61259: LD_INT 120
61261: EQUAL
61262: IFFALSE 61268
// MC_RepairVehicle ( ) ;
61264: CALL 74837 0 0
// if event = 121 then
61268: LD_VAR 0 1
61272: PUSH
61273: LD_INT 121
61275: EQUAL
61276: IFFALSE 61282
// MC_TameApe ( ) ;
61278: CALL 75567 0 0
// if event = 122 then
61282: LD_VAR 0 1
61286: PUSH
61287: LD_INT 122
61289: EQUAL
61290: IFFALSE 61296
// MC_ChangeApeClass ( ) ;
61292: CALL 76396 0 0
// if event = 123 then
61296: LD_VAR 0 1
61300: PUSH
61301: LD_INT 123
61303: EQUAL
61304: IFFALSE 61310
// MC_Bazooka ( ) ;
61306: CALL 77046 0 0
// if event = 124 then
61310: LD_VAR 0 1
61314: PUSH
61315: LD_INT 124
61317: EQUAL
61318: IFFALSE 61324
// MC_TeleportExit ( ) ;
61320: CALL 77244 0 0
// if event = 125 then
61324: LD_VAR 0 1
61328: PUSH
61329: LD_INT 125
61331: EQUAL
61332: IFFALSE 61338
// MC_Deposits ( ) ;
61334: CALL 77891 0 0
// if event = 126 then
61338: LD_VAR 0 1
61342: PUSH
61343: LD_INT 126
61345: EQUAL
61346: IFFALSE 61352
// MC_RemoteDriver ( ) ;
61348: CALL 78516 0 0
// if event = 200 then
61352: LD_VAR 0 1
61356: PUSH
61357: LD_INT 200
61359: EQUAL
61360: IFFALSE 61366
// MC_Idle ( ) ;
61362: CALL 80465 0 0
// end ;
61366: PPOPN 1
61368: END
// export function MC_Reset ( base , tag ) ; var i ; begin
61369: LD_INT 0
61371: PPUSH
61372: PPUSH
// if not mc_bases [ base ] or not tag then
61373: LD_EXP 58
61377: PUSH
61378: LD_VAR 0 1
61382: ARRAY
61383: NOT
61384: PUSH
61385: LD_VAR 0 2
61389: NOT
61390: OR
61391: IFFALSE 61395
// exit ;
61393: GO 61459
// for i in mc_bases [ base ] union mc_ape [ base ] do
61395: LD_ADDR_VAR 0 4
61399: PUSH
61400: LD_EXP 58
61404: PUSH
61405: LD_VAR 0 1
61409: ARRAY
61410: PUSH
61411: LD_EXP 87
61415: PUSH
61416: LD_VAR 0 1
61420: ARRAY
61421: UNION
61422: PUSH
61423: FOR_IN
61424: IFFALSE 61457
// if GetTag ( i ) = tag then
61426: LD_VAR 0 4
61430: PPUSH
61431: CALL_OW 110
61435: PUSH
61436: LD_VAR 0 2
61440: EQUAL
61441: IFFALSE 61455
// SetTag ( i , 0 ) ;
61443: LD_VAR 0 4
61447: PPUSH
61448: LD_INT 0
61450: PPUSH
61451: CALL_OW 109
61455: GO 61423
61457: POP
61458: POP
// end ;
61459: LD_VAR 0 3
61463: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
61464: LD_INT 0
61466: PPUSH
61467: PPUSH
61468: PPUSH
61469: PPUSH
61470: PPUSH
61471: PPUSH
61472: PPUSH
61473: PPUSH
// if not mc_bases then
61474: LD_EXP 58
61478: NOT
61479: IFFALSE 61483
// exit ;
61481: GO 61941
// for i = 1 to mc_bases do
61483: LD_ADDR_VAR 0 2
61487: PUSH
61488: DOUBLE
61489: LD_INT 1
61491: DEC
61492: ST_TO_ADDR
61493: LD_EXP 58
61497: PUSH
61498: FOR_TO
61499: IFFALSE 61939
// begin tmp := MC_ClassCheckReq ( i ) ;
61501: LD_ADDR_VAR 0 4
61505: PUSH
61506: LD_VAR 0 2
61510: PPUSH
61511: CALL 61946 0 1
61515: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
61516: LD_ADDR_EXP 99
61520: PUSH
61521: LD_EXP 99
61525: PPUSH
61526: LD_VAR 0 2
61530: PPUSH
61531: LD_VAR 0 4
61535: PPUSH
61536: CALL_OW 1
61540: ST_TO_ADDR
// if not tmp then
61541: LD_VAR 0 4
61545: NOT
61546: IFFALSE 61550
// continue ;
61548: GO 61498
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
61550: LD_ADDR_VAR 0 6
61554: PUSH
61555: LD_EXP 58
61559: PUSH
61560: LD_VAR 0 2
61564: ARRAY
61565: PPUSH
61566: LD_INT 2
61568: PUSH
61569: LD_INT 30
61571: PUSH
61572: LD_INT 4
61574: PUSH
61575: EMPTY
61576: LIST
61577: LIST
61578: PUSH
61579: LD_INT 30
61581: PUSH
61582: LD_INT 5
61584: PUSH
61585: EMPTY
61586: LIST
61587: LIST
61588: PUSH
61589: EMPTY
61590: LIST
61591: LIST
61592: LIST
61593: PPUSH
61594: CALL_OW 72
61598: PUSH
61599: LD_EXP 58
61603: PUSH
61604: LD_VAR 0 2
61608: ARRAY
61609: PPUSH
61610: LD_INT 2
61612: PUSH
61613: LD_INT 30
61615: PUSH
61616: LD_INT 0
61618: PUSH
61619: EMPTY
61620: LIST
61621: LIST
61622: PUSH
61623: LD_INT 30
61625: PUSH
61626: LD_INT 1
61628: PUSH
61629: EMPTY
61630: LIST
61631: LIST
61632: PUSH
61633: EMPTY
61634: LIST
61635: LIST
61636: LIST
61637: PPUSH
61638: CALL_OW 72
61642: PUSH
61643: LD_EXP 58
61647: PUSH
61648: LD_VAR 0 2
61652: ARRAY
61653: PPUSH
61654: LD_INT 30
61656: PUSH
61657: LD_INT 3
61659: PUSH
61660: EMPTY
61661: LIST
61662: LIST
61663: PPUSH
61664: CALL_OW 72
61668: PUSH
61669: LD_EXP 58
61673: PUSH
61674: LD_VAR 0 2
61678: ARRAY
61679: PPUSH
61680: LD_INT 2
61682: PUSH
61683: LD_INT 30
61685: PUSH
61686: LD_INT 6
61688: PUSH
61689: EMPTY
61690: LIST
61691: LIST
61692: PUSH
61693: LD_INT 30
61695: PUSH
61696: LD_INT 7
61698: PUSH
61699: EMPTY
61700: LIST
61701: LIST
61702: PUSH
61703: LD_INT 30
61705: PUSH
61706: LD_INT 8
61708: PUSH
61709: EMPTY
61710: LIST
61711: LIST
61712: PUSH
61713: EMPTY
61714: LIST
61715: LIST
61716: LIST
61717: LIST
61718: PPUSH
61719: CALL_OW 72
61723: PUSH
61724: EMPTY
61725: LIST
61726: LIST
61727: LIST
61728: LIST
61729: ST_TO_ADDR
// for j = 1 to 4 do
61730: LD_ADDR_VAR 0 3
61734: PUSH
61735: DOUBLE
61736: LD_INT 1
61738: DEC
61739: ST_TO_ADDR
61740: LD_INT 4
61742: PUSH
61743: FOR_TO
61744: IFFALSE 61935
// begin if not tmp [ j ] then
61746: LD_VAR 0 4
61750: PUSH
61751: LD_VAR 0 3
61755: ARRAY
61756: NOT
61757: IFFALSE 61761
// continue ;
61759: GO 61743
// for p in tmp [ j ] do
61761: LD_ADDR_VAR 0 5
61765: PUSH
61766: LD_VAR 0 4
61770: PUSH
61771: LD_VAR 0 3
61775: ARRAY
61776: PUSH
61777: FOR_IN
61778: IFFALSE 61931
// begin if not b [ j ] then
61780: LD_VAR 0 6
61784: PUSH
61785: LD_VAR 0 3
61789: ARRAY
61790: NOT
61791: IFFALSE 61795
// break ;
61793: GO 61931
// e := 0 ;
61795: LD_ADDR_VAR 0 7
61799: PUSH
61800: LD_INT 0
61802: ST_TO_ADDR
// for k in b [ j ] do
61803: LD_ADDR_VAR 0 8
61807: PUSH
61808: LD_VAR 0 6
61812: PUSH
61813: LD_VAR 0 3
61817: ARRAY
61818: PUSH
61819: FOR_IN
61820: IFFALSE 61847
// if IsNotFull ( k ) then
61822: LD_VAR 0 8
61826: PPUSH
61827: CALL 18632 0 1
61831: IFFALSE 61845
// begin e := k ;
61833: LD_ADDR_VAR 0 7
61837: PUSH
61838: LD_VAR 0 8
61842: ST_TO_ADDR
// break ;
61843: GO 61847
// end ;
61845: GO 61819
61847: POP
61848: POP
// if e and not UnitGoingToBuilding ( p , e ) then
61849: LD_VAR 0 7
61853: PUSH
61854: LD_VAR 0 5
61858: PPUSH
61859: LD_VAR 0 7
61863: PPUSH
61864: CALL 55751 0 2
61868: NOT
61869: AND
61870: IFFALSE 61929
// begin if IsInUnit ( p ) then
61872: LD_VAR 0 5
61876: PPUSH
61877: CALL_OW 310
61881: IFFALSE 61892
// ComExitBuilding ( p ) ;
61883: LD_VAR 0 5
61887: PPUSH
61888: CALL_OW 122
// ComEnterUnit ( p , e ) ;
61892: LD_VAR 0 5
61896: PPUSH
61897: LD_VAR 0 7
61901: PPUSH
61902: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
61906: LD_VAR 0 5
61910: PPUSH
61911: LD_VAR 0 3
61915: PPUSH
61916: CALL_OW 183
// AddComExitBuilding ( p ) ;
61920: LD_VAR 0 5
61924: PPUSH
61925: CALL_OW 182
// end ; end ;
61929: GO 61777
61931: POP
61932: POP
// end ;
61933: GO 61743
61935: POP
61936: POP
// end ;
61937: GO 61498
61939: POP
61940: POP
// end ;
61941: LD_VAR 0 1
61945: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
61946: LD_INT 0
61948: PPUSH
61949: PPUSH
61950: PPUSH
61951: PPUSH
61952: PPUSH
61953: PPUSH
61954: PPUSH
61955: PPUSH
61956: PPUSH
61957: PPUSH
61958: PPUSH
61959: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61960: LD_VAR 0 1
61964: NOT
61965: PUSH
61966: LD_EXP 58
61970: PUSH
61971: LD_VAR 0 1
61975: ARRAY
61976: NOT
61977: OR
61978: PUSH
61979: LD_EXP 58
61983: PUSH
61984: LD_VAR 0 1
61988: ARRAY
61989: PPUSH
61990: LD_INT 2
61992: PUSH
61993: LD_INT 30
61995: PUSH
61996: LD_INT 0
61998: PUSH
61999: EMPTY
62000: LIST
62001: LIST
62002: PUSH
62003: LD_INT 30
62005: PUSH
62006: LD_INT 1
62008: PUSH
62009: EMPTY
62010: LIST
62011: LIST
62012: PUSH
62013: EMPTY
62014: LIST
62015: LIST
62016: LIST
62017: PPUSH
62018: CALL_OW 72
62022: NOT
62023: OR
62024: IFFALSE 62028
// exit ;
62026: GO 65531
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62028: LD_ADDR_VAR 0 4
62032: PUSH
62033: LD_EXP 58
62037: PUSH
62038: LD_VAR 0 1
62042: ARRAY
62043: PPUSH
62044: LD_INT 2
62046: PUSH
62047: LD_INT 25
62049: PUSH
62050: LD_INT 1
62052: PUSH
62053: EMPTY
62054: LIST
62055: LIST
62056: PUSH
62057: LD_INT 25
62059: PUSH
62060: LD_INT 2
62062: PUSH
62063: EMPTY
62064: LIST
62065: LIST
62066: PUSH
62067: LD_INT 25
62069: PUSH
62070: LD_INT 3
62072: PUSH
62073: EMPTY
62074: LIST
62075: LIST
62076: PUSH
62077: LD_INT 25
62079: PUSH
62080: LD_INT 4
62082: PUSH
62083: EMPTY
62084: LIST
62085: LIST
62086: PUSH
62087: LD_INT 25
62089: PUSH
62090: LD_INT 5
62092: PUSH
62093: EMPTY
62094: LIST
62095: LIST
62096: PUSH
62097: LD_INT 25
62099: PUSH
62100: LD_INT 8
62102: PUSH
62103: EMPTY
62104: LIST
62105: LIST
62106: PUSH
62107: LD_INT 25
62109: PUSH
62110: LD_INT 9
62112: PUSH
62113: EMPTY
62114: LIST
62115: LIST
62116: PUSH
62117: EMPTY
62118: LIST
62119: LIST
62120: LIST
62121: LIST
62122: LIST
62123: LIST
62124: LIST
62125: LIST
62126: PPUSH
62127: CALL_OW 72
62131: ST_TO_ADDR
// if not tmp then
62132: LD_VAR 0 4
62136: NOT
62137: IFFALSE 62141
// exit ;
62139: GO 65531
// for i in tmp do
62141: LD_ADDR_VAR 0 3
62145: PUSH
62146: LD_VAR 0 4
62150: PUSH
62151: FOR_IN
62152: IFFALSE 62183
// if GetTag ( i ) then
62154: LD_VAR 0 3
62158: PPUSH
62159: CALL_OW 110
62163: IFFALSE 62181
// tmp := tmp diff i ;
62165: LD_ADDR_VAR 0 4
62169: PUSH
62170: LD_VAR 0 4
62174: PUSH
62175: LD_VAR 0 3
62179: DIFF
62180: ST_TO_ADDR
62181: GO 62151
62183: POP
62184: POP
// if not tmp then
62185: LD_VAR 0 4
62189: NOT
62190: IFFALSE 62194
// exit ;
62192: GO 65531
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62194: LD_ADDR_VAR 0 5
62198: PUSH
62199: LD_EXP 58
62203: PUSH
62204: LD_VAR 0 1
62208: ARRAY
62209: PPUSH
62210: LD_INT 2
62212: PUSH
62213: LD_INT 25
62215: PUSH
62216: LD_INT 1
62218: PUSH
62219: EMPTY
62220: LIST
62221: LIST
62222: PUSH
62223: LD_INT 25
62225: PUSH
62226: LD_INT 5
62228: PUSH
62229: EMPTY
62230: LIST
62231: LIST
62232: PUSH
62233: LD_INT 25
62235: PUSH
62236: LD_INT 8
62238: PUSH
62239: EMPTY
62240: LIST
62241: LIST
62242: PUSH
62243: LD_INT 25
62245: PUSH
62246: LD_INT 9
62248: PUSH
62249: EMPTY
62250: LIST
62251: LIST
62252: PUSH
62253: EMPTY
62254: LIST
62255: LIST
62256: LIST
62257: LIST
62258: LIST
62259: PPUSH
62260: CALL_OW 72
62264: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
62265: LD_ADDR_VAR 0 6
62269: PUSH
62270: LD_EXP 58
62274: PUSH
62275: LD_VAR 0 1
62279: ARRAY
62280: PPUSH
62281: LD_INT 25
62283: PUSH
62284: LD_INT 2
62286: PUSH
62287: EMPTY
62288: LIST
62289: LIST
62290: PPUSH
62291: CALL_OW 72
62295: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
62296: LD_ADDR_VAR 0 7
62300: PUSH
62301: LD_EXP 58
62305: PUSH
62306: LD_VAR 0 1
62310: ARRAY
62311: PPUSH
62312: LD_INT 25
62314: PUSH
62315: LD_INT 3
62317: PUSH
62318: EMPTY
62319: LIST
62320: LIST
62321: PPUSH
62322: CALL_OW 72
62326: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
62327: LD_ADDR_VAR 0 8
62331: PUSH
62332: LD_EXP 58
62336: PUSH
62337: LD_VAR 0 1
62341: ARRAY
62342: PPUSH
62343: LD_INT 25
62345: PUSH
62346: LD_INT 4
62348: PUSH
62349: EMPTY
62350: LIST
62351: LIST
62352: PUSH
62353: LD_INT 24
62355: PUSH
62356: LD_INT 251
62358: PUSH
62359: EMPTY
62360: LIST
62361: LIST
62362: PUSH
62363: EMPTY
62364: LIST
62365: LIST
62366: PPUSH
62367: CALL_OW 72
62371: ST_TO_ADDR
// if mc_scan [ base ] then
62372: LD_EXP 81
62376: PUSH
62377: LD_VAR 0 1
62381: ARRAY
62382: IFFALSE 62843
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
62384: LD_ADDR_EXP 100
62388: PUSH
62389: LD_EXP 100
62393: PPUSH
62394: LD_VAR 0 1
62398: PPUSH
62399: LD_INT 4
62401: PPUSH
62402: CALL_OW 1
62406: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62407: LD_ADDR_VAR 0 12
62411: PUSH
62412: LD_EXP 58
62416: PUSH
62417: LD_VAR 0 1
62421: ARRAY
62422: PPUSH
62423: LD_INT 2
62425: PUSH
62426: LD_INT 30
62428: PUSH
62429: LD_INT 4
62431: PUSH
62432: EMPTY
62433: LIST
62434: LIST
62435: PUSH
62436: LD_INT 30
62438: PUSH
62439: LD_INT 5
62441: PUSH
62442: EMPTY
62443: LIST
62444: LIST
62445: PUSH
62446: EMPTY
62447: LIST
62448: LIST
62449: LIST
62450: PPUSH
62451: CALL_OW 72
62455: ST_TO_ADDR
// if not b then
62456: LD_VAR 0 12
62460: NOT
62461: IFFALSE 62465
// exit ;
62463: GO 65531
// p := [ ] ;
62465: LD_ADDR_VAR 0 11
62469: PUSH
62470: EMPTY
62471: ST_TO_ADDR
// if sci >= 2 then
62472: LD_VAR 0 8
62476: PUSH
62477: LD_INT 2
62479: GREATEREQUAL
62480: IFFALSE 62511
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
62482: LD_ADDR_VAR 0 8
62486: PUSH
62487: LD_VAR 0 8
62491: PUSH
62492: LD_INT 1
62494: ARRAY
62495: PUSH
62496: LD_VAR 0 8
62500: PUSH
62501: LD_INT 2
62503: ARRAY
62504: PUSH
62505: EMPTY
62506: LIST
62507: LIST
62508: ST_TO_ADDR
62509: GO 62572
// if sci = 1 then
62511: LD_VAR 0 8
62515: PUSH
62516: LD_INT 1
62518: EQUAL
62519: IFFALSE 62540
// sci := [ sci [ 1 ] ] else
62521: LD_ADDR_VAR 0 8
62525: PUSH
62526: LD_VAR 0 8
62530: PUSH
62531: LD_INT 1
62533: ARRAY
62534: PUSH
62535: EMPTY
62536: LIST
62537: ST_TO_ADDR
62538: GO 62572
// if sci = 0 then
62540: LD_VAR 0 8
62544: PUSH
62545: LD_INT 0
62547: EQUAL
62548: IFFALSE 62572
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
62550: LD_ADDR_VAR 0 11
62554: PUSH
62555: LD_VAR 0 4
62559: PPUSH
62560: LD_INT 4
62562: PPUSH
62563: CALL 55614 0 2
62567: PUSH
62568: LD_INT 1
62570: ARRAY
62571: ST_TO_ADDR
// if eng > 4 then
62572: LD_VAR 0 6
62576: PUSH
62577: LD_INT 4
62579: GREATER
62580: IFFALSE 62626
// for i = eng downto 4 do
62582: LD_ADDR_VAR 0 3
62586: PUSH
62587: DOUBLE
62588: LD_VAR 0 6
62592: INC
62593: ST_TO_ADDR
62594: LD_INT 4
62596: PUSH
62597: FOR_DOWNTO
62598: IFFALSE 62624
// eng := eng diff eng [ i ] ;
62600: LD_ADDR_VAR 0 6
62604: PUSH
62605: LD_VAR 0 6
62609: PUSH
62610: LD_VAR 0 6
62614: PUSH
62615: LD_VAR 0 3
62619: ARRAY
62620: DIFF
62621: ST_TO_ADDR
62622: GO 62597
62624: POP
62625: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
62626: LD_ADDR_VAR 0 4
62630: PUSH
62631: LD_VAR 0 4
62635: PUSH
62636: LD_VAR 0 5
62640: PUSH
62641: LD_VAR 0 6
62645: UNION
62646: PUSH
62647: LD_VAR 0 7
62651: UNION
62652: PUSH
62653: LD_VAR 0 8
62657: UNION
62658: DIFF
62659: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
62660: LD_ADDR_VAR 0 13
62664: PUSH
62665: LD_EXP 58
62669: PUSH
62670: LD_VAR 0 1
62674: ARRAY
62675: PPUSH
62676: LD_INT 2
62678: PUSH
62679: LD_INT 30
62681: PUSH
62682: LD_INT 32
62684: PUSH
62685: EMPTY
62686: LIST
62687: LIST
62688: PUSH
62689: LD_INT 30
62691: PUSH
62692: LD_INT 31
62694: PUSH
62695: EMPTY
62696: LIST
62697: LIST
62698: PUSH
62699: EMPTY
62700: LIST
62701: LIST
62702: LIST
62703: PPUSH
62704: CALL_OW 72
62708: PUSH
62709: LD_EXP 58
62713: PUSH
62714: LD_VAR 0 1
62718: ARRAY
62719: PPUSH
62720: LD_INT 2
62722: PUSH
62723: LD_INT 30
62725: PUSH
62726: LD_INT 4
62728: PUSH
62729: EMPTY
62730: LIST
62731: LIST
62732: PUSH
62733: LD_INT 30
62735: PUSH
62736: LD_INT 5
62738: PUSH
62739: EMPTY
62740: LIST
62741: LIST
62742: PUSH
62743: EMPTY
62744: LIST
62745: LIST
62746: LIST
62747: PPUSH
62748: CALL_OW 72
62752: PUSH
62753: LD_INT 6
62755: MUL
62756: PLUS
62757: ST_TO_ADDR
// if bcount < tmp then
62758: LD_VAR 0 13
62762: PUSH
62763: LD_VAR 0 4
62767: LESS
62768: IFFALSE 62814
// for i = tmp downto bcount do
62770: LD_ADDR_VAR 0 3
62774: PUSH
62775: DOUBLE
62776: LD_VAR 0 4
62780: INC
62781: ST_TO_ADDR
62782: LD_VAR 0 13
62786: PUSH
62787: FOR_DOWNTO
62788: IFFALSE 62812
// tmp := Delete ( tmp , tmp ) ;
62790: LD_ADDR_VAR 0 4
62794: PUSH
62795: LD_VAR 0 4
62799: PPUSH
62800: LD_VAR 0 4
62804: PPUSH
62805: CALL_OW 3
62809: ST_TO_ADDR
62810: GO 62787
62812: POP
62813: POP
// result := [ tmp , 0 , 0 , p ] ;
62814: LD_ADDR_VAR 0 2
62818: PUSH
62819: LD_VAR 0 4
62823: PUSH
62824: LD_INT 0
62826: PUSH
62827: LD_INT 0
62829: PUSH
62830: LD_VAR 0 11
62834: PUSH
62835: EMPTY
62836: LIST
62837: LIST
62838: LIST
62839: LIST
62840: ST_TO_ADDR
// exit ;
62841: GO 65531
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62843: LD_EXP 58
62847: PUSH
62848: LD_VAR 0 1
62852: ARRAY
62853: PPUSH
62854: LD_INT 2
62856: PUSH
62857: LD_INT 30
62859: PUSH
62860: LD_INT 6
62862: PUSH
62863: EMPTY
62864: LIST
62865: LIST
62866: PUSH
62867: LD_INT 30
62869: PUSH
62870: LD_INT 7
62872: PUSH
62873: EMPTY
62874: LIST
62875: LIST
62876: PUSH
62877: LD_INT 30
62879: PUSH
62880: LD_INT 8
62882: PUSH
62883: EMPTY
62884: LIST
62885: LIST
62886: PUSH
62887: EMPTY
62888: LIST
62889: LIST
62890: LIST
62891: LIST
62892: PPUSH
62893: CALL_OW 72
62897: NOT
62898: PUSH
62899: LD_EXP 58
62903: PUSH
62904: LD_VAR 0 1
62908: ARRAY
62909: PPUSH
62910: LD_INT 30
62912: PUSH
62913: LD_INT 3
62915: PUSH
62916: EMPTY
62917: LIST
62918: LIST
62919: PPUSH
62920: CALL_OW 72
62924: NOT
62925: AND
62926: IFFALSE 62998
// begin if eng = tmp then
62928: LD_VAR 0 6
62932: PUSH
62933: LD_VAR 0 4
62937: EQUAL
62938: IFFALSE 62942
// exit ;
62940: GO 65531
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
62942: LD_ADDR_EXP 100
62946: PUSH
62947: LD_EXP 100
62951: PPUSH
62952: LD_VAR 0 1
62956: PPUSH
62957: LD_INT 1
62959: PPUSH
62960: CALL_OW 1
62964: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
62965: LD_ADDR_VAR 0 2
62969: PUSH
62970: LD_INT 0
62972: PUSH
62973: LD_VAR 0 4
62977: PUSH
62978: LD_VAR 0 6
62982: DIFF
62983: PUSH
62984: LD_INT 0
62986: PUSH
62987: LD_INT 0
62989: PUSH
62990: EMPTY
62991: LIST
62992: LIST
62993: LIST
62994: LIST
62995: ST_TO_ADDR
// exit ;
62996: GO 65531
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62998: LD_EXP 85
63002: PUSH
63003: LD_EXP 84
63007: PUSH
63008: LD_VAR 0 1
63012: ARRAY
63013: ARRAY
63014: PUSH
63015: LD_EXP 58
63019: PUSH
63020: LD_VAR 0 1
63024: ARRAY
63025: PPUSH
63026: LD_INT 2
63028: PUSH
63029: LD_INT 30
63031: PUSH
63032: LD_INT 6
63034: PUSH
63035: EMPTY
63036: LIST
63037: LIST
63038: PUSH
63039: LD_INT 30
63041: PUSH
63042: LD_INT 7
63044: PUSH
63045: EMPTY
63046: LIST
63047: LIST
63048: PUSH
63049: LD_INT 30
63051: PUSH
63052: LD_INT 8
63054: PUSH
63055: EMPTY
63056: LIST
63057: LIST
63058: PUSH
63059: EMPTY
63060: LIST
63061: LIST
63062: LIST
63063: LIST
63064: PPUSH
63065: CALL_OW 72
63069: AND
63070: PUSH
63071: LD_EXP 58
63075: PUSH
63076: LD_VAR 0 1
63080: ARRAY
63081: PPUSH
63082: LD_INT 30
63084: PUSH
63085: LD_INT 3
63087: PUSH
63088: EMPTY
63089: LIST
63090: LIST
63091: PPUSH
63092: CALL_OW 72
63096: NOT
63097: AND
63098: IFFALSE 63312
// begin if sci >= 6 then
63100: LD_VAR 0 8
63104: PUSH
63105: LD_INT 6
63107: GREATEREQUAL
63108: IFFALSE 63112
// exit ;
63110: GO 65531
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
63112: LD_ADDR_EXP 100
63116: PUSH
63117: LD_EXP 100
63121: PPUSH
63122: LD_VAR 0 1
63126: PPUSH
63127: LD_INT 2
63129: PPUSH
63130: CALL_OW 1
63134: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
63135: LD_ADDR_VAR 0 9
63139: PUSH
63140: LD_VAR 0 4
63144: PUSH
63145: LD_VAR 0 8
63149: DIFF
63150: PPUSH
63151: LD_INT 4
63153: PPUSH
63154: CALL 55614 0 2
63158: ST_TO_ADDR
// p := [ ] ;
63159: LD_ADDR_VAR 0 11
63163: PUSH
63164: EMPTY
63165: ST_TO_ADDR
// if sci < 6 and sort > 6 then
63166: LD_VAR 0 8
63170: PUSH
63171: LD_INT 6
63173: LESS
63174: PUSH
63175: LD_VAR 0 9
63179: PUSH
63180: LD_INT 6
63182: GREATER
63183: AND
63184: IFFALSE 63265
// begin for i = 1 to 6 - sci do
63186: LD_ADDR_VAR 0 3
63190: PUSH
63191: DOUBLE
63192: LD_INT 1
63194: DEC
63195: ST_TO_ADDR
63196: LD_INT 6
63198: PUSH
63199: LD_VAR 0 8
63203: MINUS
63204: PUSH
63205: FOR_TO
63206: IFFALSE 63261
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
63208: LD_ADDR_VAR 0 11
63212: PUSH
63213: LD_VAR 0 11
63217: PPUSH
63218: LD_VAR 0 11
63222: PUSH
63223: LD_INT 1
63225: PLUS
63226: PPUSH
63227: LD_VAR 0 9
63231: PUSH
63232: LD_INT 1
63234: ARRAY
63235: PPUSH
63236: CALL_OW 2
63240: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
63241: LD_ADDR_VAR 0 9
63245: PUSH
63246: LD_VAR 0 9
63250: PPUSH
63251: LD_INT 1
63253: PPUSH
63254: CALL_OW 3
63258: ST_TO_ADDR
// end ;
63259: GO 63205
63261: POP
63262: POP
// end else
63263: GO 63285
// if sort then
63265: LD_VAR 0 9
63269: IFFALSE 63285
// p := sort [ 1 ] ;
63271: LD_ADDR_VAR 0 11
63275: PUSH
63276: LD_VAR 0 9
63280: PUSH
63281: LD_INT 1
63283: ARRAY
63284: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
63285: LD_ADDR_VAR 0 2
63289: PUSH
63290: LD_INT 0
63292: PUSH
63293: LD_INT 0
63295: PUSH
63296: LD_INT 0
63298: PUSH
63299: LD_VAR 0 11
63303: PUSH
63304: EMPTY
63305: LIST
63306: LIST
63307: LIST
63308: LIST
63309: ST_TO_ADDR
// exit ;
63310: GO 65531
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63312: LD_EXP 85
63316: PUSH
63317: LD_EXP 84
63321: PUSH
63322: LD_VAR 0 1
63326: ARRAY
63327: ARRAY
63328: PUSH
63329: LD_EXP 58
63333: PUSH
63334: LD_VAR 0 1
63338: ARRAY
63339: PPUSH
63340: LD_INT 2
63342: PUSH
63343: LD_INT 30
63345: PUSH
63346: LD_INT 6
63348: PUSH
63349: EMPTY
63350: LIST
63351: LIST
63352: PUSH
63353: LD_INT 30
63355: PUSH
63356: LD_INT 7
63358: PUSH
63359: EMPTY
63360: LIST
63361: LIST
63362: PUSH
63363: LD_INT 30
63365: PUSH
63366: LD_INT 8
63368: PUSH
63369: EMPTY
63370: LIST
63371: LIST
63372: PUSH
63373: EMPTY
63374: LIST
63375: LIST
63376: LIST
63377: LIST
63378: PPUSH
63379: CALL_OW 72
63383: AND
63384: PUSH
63385: LD_EXP 58
63389: PUSH
63390: LD_VAR 0 1
63394: ARRAY
63395: PPUSH
63396: LD_INT 30
63398: PUSH
63399: LD_INT 3
63401: PUSH
63402: EMPTY
63403: LIST
63404: LIST
63405: PPUSH
63406: CALL_OW 72
63410: AND
63411: IFFALSE 64145
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
63413: LD_ADDR_EXP 100
63417: PUSH
63418: LD_EXP 100
63422: PPUSH
63423: LD_VAR 0 1
63427: PPUSH
63428: LD_INT 3
63430: PPUSH
63431: CALL_OW 1
63435: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63436: LD_ADDR_VAR 0 2
63440: PUSH
63441: LD_INT 0
63443: PUSH
63444: LD_INT 0
63446: PUSH
63447: LD_INT 0
63449: PUSH
63450: LD_INT 0
63452: PUSH
63453: EMPTY
63454: LIST
63455: LIST
63456: LIST
63457: LIST
63458: ST_TO_ADDR
// if not eng then
63459: LD_VAR 0 6
63463: NOT
63464: IFFALSE 63527
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
63466: LD_ADDR_VAR 0 11
63470: PUSH
63471: LD_VAR 0 4
63475: PPUSH
63476: LD_INT 2
63478: PPUSH
63479: CALL 55614 0 2
63483: PUSH
63484: LD_INT 1
63486: ARRAY
63487: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
63488: LD_ADDR_VAR 0 2
63492: PUSH
63493: LD_VAR 0 2
63497: PPUSH
63498: LD_INT 2
63500: PPUSH
63501: LD_VAR 0 11
63505: PPUSH
63506: CALL_OW 1
63510: ST_TO_ADDR
// tmp := tmp diff p ;
63511: LD_ADDR_VAR 0 4
63515: PUSH
63516: LD_VAR 0 4
63520: PUSH
63521: LD_VAR 0 11
63525: DIFF
63526: ST_TO_ADDR
// end ; if tmp and sci < 6 then
63527: LD_VAR 0 4
63531: PUSH
63532: LD_VAR 0 8
63536: PUSH
63537: LD_INT 6
63539: LESS
63540: AND
63541: IFFALSE 63729
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
63543: LD_ADDR_VAR 0 9
63547: PUSH
63548: LD_VAR 0 4
63552: PUSH
63553: LD_VAR 0 8
63557: PUSH
63558: LD_VAR 0 7
63562: UNION
63563: DIFF
63564: PPUSH
63565: LD_INT 4
63567: PPUSH
63568: CALL 55614 0 2
63572: ST_TO_ADDR
// p := [ ] ;
63573: LD_ADDR_VAR 0 11
63577: PUSH
63578: EMPTY
63579: ST_TO_ADDR
// if sort then
63580: LD_VAR 0 9
63584: IFFALSE 63700
// for i = 1 to 6 - sci do
63586: LD_ADDR_VAR 0 3
63590: PUSH
63591: DOUBLE
63592: LD_INT 1
63594: DEC
63595: ST_TO_ADDR
63596: LD_INT 6
63598: PUSH
63599: LD_VAR 0 8
63603: MINUS
63604: PUSH
63605: FOR_TO
63606: IFFALSE 63698
// begin if i = sort then
63608: LD_VAR 0 3
63612: PUSH
63613: LD_VAR 0 9
63617: EQUAL
63618: IFFALSE 63622
// break ;
63620: GO 63698
// if GetClass ( i ) = 4 then
63622: LD_VAR 0 3
63626: PPUSH
63627: CALL_OW 257
63631: PUSH
63632: LD_INT 4
63634: EQUAL
63635: IFFALSE 63639
// continue ;
63637: GO 63605
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63639: LD_ADDR_VAR 0 11
63643: PUSH
63644: LD_VAR 0 11
63648: PPUSH
63649: LD_VAR 0 11
63653: PUSH
63654: LD_INT 1
63656: PLUS
63657: PPUSH
63658: LD_VAR 0 9
63662: PUSH
63663: LD_VAR 0 3
63667: ARRAY
63668: PPUSH
63669: CALL_OW 2
63673: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63674: LD_ADDR_VAR 0 4
63678: PUSH
63679: LD_VAR 0 4
63683: PUSH
63684: LD_VAR 0 9
63688: PUSH
63689: LD_VAR 0 3
63693: ARRAY
63694: DIFF
63695: ST_TO_ADDR
// end ;
63696: GO 63605
63698: POP
63699: POP
// if p then
63700: LD_VAR 0 11
63704: IFFALSE 63729
// result := Replace ( result , 4 , p ) ;
63706: LD_ADDR_VAR 0 2
63710: PUSH
63711: LD_VAR 0 2
63715: PPUSH
63716: LD_INT 4
63718: PPUSH
63719: LD_VAR 0 11
63723: PPUSH
63724: CALL_OW 1
63728: ST_TO_ADDR
// end ; if tmp and mech < 6 then
63729: LD_VAR 0 4
63733: PUSH
63734: LD_VAR 0 7
63738: PUSH
63739: LD_INT 6
63741: LESS
63742: AND
63743: IFFALSE 63931
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63745: LD_ADDR_VAR 0 9
63749: PUSH
63750: LD_VAR 0 4
63754: PUSH
63755: LD_VAR 0 8
63759: PUSH
63760: LD_VAR 0 7
63764: UNION
63765: DIFF
63766: PPUSH
63767: LD_INT 3
63769: PPUSH
63770: CALL 55614 0 2
63774: ST_TO_ADDR
// p := [ ] ;
63775: LD_ADDR_VAR 0 11
63779: PUSH
63780: EMPTY
63781: ST_TO_ADDR
// if sort then
63782: LD_VAR 0 9
63786: IFFALSE 63902
// for i = 1 to 6 - mech do
63788: LD_ADDR_VAR 0 3
63792: PUSH
63793: DOUBLE
63794: LD_INT 1
63796: DEC
63797: ST_TO_ADDR
63798: LD_INT 6
63800: PUSH
63801: LD_VAR 0 7
63805: MINUS
63806: PUSH
63807: FOR_TO
63808: IFFALSE 63900
// begin if i = sort then
63810: LD_VAR 0 3
63814: PUSH
63815: LD_VAR 0 9
63819: EQUAL
63820: IFFALSE 63824
// break ;
63822: GO 63900
// if GetClass ( i ) = 3 then
63824: LD_VAR 0 3
63828: PPUSH
63829: CALL_OW 257
63833: PUSH
63834: LD_INT 3
63836: EQUAL
63837: IFFALSE 63841
// continue ;
63839: GO 63807
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63841: LD_ADDR_VAR 0 11
63845: PUSH
63846: LD_VAR 0 11
63850: PPUSH
63851: LD_VAR 0 11
63855: PUSH
63856: LD_INT 1
63858: PLUS
63859: PPUSH
63860: LD_VAR 0 9
63864: PUSH
63865: LD_VAR 0 3
63869: ARRAY
63870: PPUSH
63871: CALL_OW 2
63875: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63876: LD_ADDR_VAR 0 4
63880: PUSH
63881: LD_VAR 0 4
63885: PUSH
63886: LD_VAR 0 9
63890: PUSH
63891: LD_VAR 0 3
63895: ARRAY
63896: DIFF
63897: ST_TO_ADDR
// end ;
63898: GO 63807
63900: POP
63901: POP
// if p then
63902: LD_VAR 0 11
63906: IFFALSE 63931
// result := Replace ( result , 3 , p ) ;
63908: LD_ADDR_VAR 0 2
63912: PUSH
63913: LD_VAR 0 2
63917: PPUSH
63918: LD_INT 3
63920: PPUSH
63921: LD_VAR 0 11
63925: PPUSH
63926: CALL_OW 1
63930: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
63931: LD_VAR 0 4
63935: PUSH
63936: LD_INT 6
63938: GREATER
63939: PUSH
63940: LD_VAR 0 6
63944: PUSH
63945: LD_INT 6
63947: LESS
63948: AND
63949: IFFALSE 64143
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63951: LD_ADDR_VAR 0 9
63955: PUSH
63956: LD_VAR 0 4
63960: PUSH
63961: LD_VAR 0 8
63965: PUSH
63966: LD_VAR 0 7
63970: UNION
63971: PUSH
63972: LD_VAR 0 6
63976: UNION
63977: DIFF
63978: PPUSH
63979: LD_INT 2
63981: PPUSH
63982: CALL 55614 0 2
63986: ST_TO_ADDR
// p := [ ] ;
63987: LD_ADDR_VAR 0 11
63991: PUSH
63992: EMPTY
63993: ST_TO_ADDR
// if sort then
63994: LD_VAR 0 9
63998: IFFALSE 64114
// for i = 1 to 6 - eng do
64000: LD_ADDR_VAR 0 3
64004: PUSH
64005: DOUBLE
64006: LD_INT 1
64008: DEC
64009: ST_TO_ADDR
64010: LD_INT 6
64012: PUSH
64013: LD_VAR 0 6
64017: MINUS
64018: PUSH
64019: FOR_TO
64020: IFFALSE 64112
// begin if i = sort then
64022: LD_VAR 0 3
64026: PUSH
64027: LD_VAR 0 9
64031: EQUAL
64032: IFFALSE 64036
// break ;
64034: GO 64112
// if GetClass ( i ) = 2 then
64036: LD_VAR 0 3
64040: PPUSH
64041: CALL_OW 257
64045: PUSH
64046: LD_INT 2
64048: EQUAL
64049: IFFALSE 64053
// continue ;
64051: GO 64019
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64053: LD_ADDR_VAR 0 11
64057: PUSH
64058: LD_VAR 0 11
64062: PPUSH
64063: LD_VAR 0 11
64067: PUSH
64068: LD_INT 1
64070: PLUS
64071: PPUSH
64072: LD_VAR 0 9
64076: PUSH
64077: LD_VAR 0 3
64081: ARRAY
64082: PPUSH
64083: CALL_OW 2
64087: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64088: LD_ADDR_VAR 0 4
64092: PUSH
64093: LD_VAR 0 4
64097: PUSH
64098: LD_VAR 0 9
64102: PUSH
64103: LD_VAR 0 3
64107: ARRAY
64108: DIFF
64109: ST_TO_ADDR
// end ;
64110: GO 64019
64112: POP
64113: POP
// if p then
64114: LD_VAR 0 11
64118: IFFALSE 64143
// result := Replace ( result , 2 , p ) ;
64120: LD_ADDR_VAR 0 2
64124: PUSH
64125: LD_VAR 0 2
64129: PPUSH
64130: LD_INT 2
64132: PPUSH
64133: LD_VAR 0 11
64137: PPUSH
64138: CALL_OW 1
64142: ST_TO_ADDR
// end ; exit ;
64143: GO 65531
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
64145: LD_EXP 85
64149: PUSH
64150: LD_EXP 84
64154: PUSH
64155: LD_VAR 0 1
64159: ARRAY
64160: ARRAY
64161: NOT
64162: PUSH
64163: LD_EXP 58
64167: PUSH
64168: LD_VAR 0 1
64172: ARRAY
64173: PPUSH
64174: LD_INT 30
64176: PUSH
64177: LD_INT 3
64179: PUSH
64180: EMPTY
64181: LIST
64182: LIST
64183: PPUSH
64184: CALL_OW 72
64188: AND
64189: PUSH
64190: LD_EXP 63
64194: PUSH
64195: LD_VAR 0 1
64199: ARRAY
64200: AND
64201: IFFALSE 64809
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
64203: LD_ADDR_EXP 100
64207: PUSH
64208: LD_EXP 100
64212: PPUSH
64213: LD_VAR 0 1
64217: PPUSH
64218: LD_INT 5
64220: PPUSH
64221: CALL_OW 1
64225: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64226: LD_ADDR_VAR 0 2
64230: PUSH
64231: LD_INT 0
64233: PUSH
64234: LD_INT 0
64236: PUSH
64237: LD_INT 0
64239: PUSH
64240: LD_INT 0
64242: PUSH
64243: EMPTY
64244: LIST
64245: LIST
64246: LIST
64247: LIST
64248: ST_TO_ADDR
// if sci > 1 then
64249: LD_VAR 0 8
64253: PUSH
64254: LD_INT 1
64256: GREATER
64257: IFFALSE 64285
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
64259: LD_ADDR_VAR 0 4
64263: PUSH
64264: LD_VAR 0 4
64268: PUSH
64269: LD_VAR 0 8
64273: PUSH
64274: LD_VAR 0 8
64278: PUSH
64279: LD_INT 1
64281: ARRAY
64282: DIFF
64283: DIFF
64284: ST_TO_ADDR
// if tmp and not sci then
64285: LD_VAR 0 4
64289: PUSH
64290: LD_VAR 0 8
64294: NOT
64295: AND
64296: IFFALSE 64365
// begin sort := SortBySkill ( tmp , 4 ) ;
64298: LD_ADDR_VAR 0 9
64302: PUSH
64303: LD_VAR 0 4
64307: PPUSH
64308: LD_INT 4
64310: PPUSH
64311: CALL 55614 0 2
64315: ST_TO_ADDR
// if sort then
64316: LD_VAR 0 9
64320: IFFALSE 64336
// p := sort [ 1 ] ;
64322: LD_ADDR_VAR 0 11
64326: PUSH
64327: LD_VAR 0 9
64331: PUSH
64332: LD_INT 1
64334: ARRAY
64335: ST_TO_ADDR
// if p then
64336: LD_VAR 0 11
64340: IFFALSE 64365
// result := Replace ( result , 4 , p ) ;
64342: LD_ADDR_VAR 0 2
64346: PUSH
64347: LD_VAR 0 2
64351: PPUSH
64352: LD_INT 4
64354: PPUSH
64355: LD_VAR 0 11
64359: PPUSH
64360: CALL_OW 1
64364: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64365: LD_ADDR_VAR 0 4
64369: PUSH
64370: LD_VAR 0 4
64374: PUSH
64375: LD_VAR 0 7
64379: DIFF
64380: ST_TO_ADDR
// if tmp and mech < 6 then
64381: LD_VAR 0 4
64385: PUSH
64386: LD_VAR 0 7
64390: PUSH
64391: LD_INT 6
64393: LESS
64394: AND
64395: IFFALSE 64583
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
64397: LD_ADDR_VAR 0 9
64401: PUSH
64402: LD_VAR 0 4
64406: PUSH
64407: LD_VAR 0 8
64411: PUSH
64412: LD_VAR 0 7
64416: UNION
64417: DIFF
64418: PPUSH
64419: LD_INT 3
64421: PPUSH
64422: CALL 55614 0 2
64426: ST_TO_ADDR
// p := [ ] ;
64427: LD_ADDR_VAR 0 11
64431: PUSH
64432: EMPTY
64433: ST_TO_ADDR
// if sort then
64434: LD_VAR 0 9
64438: IFFALSE 64554
// for i = 1 to 6 - mech do
64440: LD_ADDR_VAR 0 3
64444: PUSH
64445: DOUBLE
64446: LD_INT 1
64448: DEC
64449: ST_TO_ADDR
64450: LD_INT 6
64452: PUSH
64453: LD_VAR 0 7
64457: MINUS
64458: PUSH
64459: FOR_TO
64460: IFFALSE 64552
// begin if i = sort then
64462: LD_VAR 0 3
64466: PUSH
64467: LD_VAR 0 9
64471: EQUAL
64472: IFFALSE 64476
// break ;
64474: GO 64552
// if GetClass ( i ) = 3 then
64476: LD_VAR 0 3
64480: PPUSH
64481: CALL_OW 257
64485: PUSH
64486: LD_INT 3
64488: EQUAL
64489: IFFALSE 64493
// continue ;
64491: GO 64459
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64493: LD_ADDR_VAR 0 11
64497: PUSH
64498: LD_VAR 0 11
64502: PPUSH
64503: LD_VAR 0 11
64507: PUSH
64508: LD_INT 1
64510: PLUS
64511: PPUSH
64512: LD_VAR 0 9
64516: PUSH
64517: LD_VAR 0 3
64521: ARRAY
64522: PPUSH
64523: CALL_OW 2
64527: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64528: LD_ADDR_VAR 0 4
64532: PUSH
64533: LD_VAR 0 4
64537: PUSH
64538: LD_VAR 0 9
64542: PUSH
64543: LD_VAR 0 3
64547: ARRAY
64548: DIFF
64549: ST_TO_ADDR
// end ;
64550: GO 64459
64552: POP
64553: POP
// if p then
64554: LD_VAR 0 11
64558: IFFALSE 64583
// result := Replace ( result , 3 , p ) ;
64560: LD_ADDR_VAR 0 2
64564: PUSH
64565: LD_VAR 0 2
64569: PPUSH
64570: LD_INT 3
64572: PPUSH
64573: LD_VAR 0 11
64577: PPUSH
64578: CALL_OW 1
64582: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64583: LD_ADDR_VAR 0 4
64587: PUSH
64588: LD_VAR 0 4
64592: PUSH
64593: LD_VAR 0 6
64597: DIFF
64598: ST_TO_ADDR
// if tmp and eng < 6 then
64599: LD_VAR 0 4
64603: PUSH
64604: LD_VAR 0 6
64608: PUSH
64609: LD_INT 6
64611: LESS
64612: AND
64613: IFFALSE 64807
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64615: LD_ADDR_VAR 0 9
64619: PUSH
64620: LD_VAR 0 4
64624: PUSH
64625: LD_VAR 0 8
64629: PUSH
64630: LD_VAR 0 7
64634: UNION
64635: PUSH
64636: LD_VAR 0 6
64640: UNION
64641: DIFF
64642: PPUSH
64643: LD_INT 2
64645: PPUSH
64646: CALL 55614 0 2
64650: ST_TO_ADDR
// p := [ ] ;
64651: LD_ADDR_VAR 0 11
64655: PUSH
64656: EMPTY
64657: ST_TO_ADDR
// if sort then
64658: LD_VAR 0 9
64662: IFFALSE 64778
// for i = 1 to 6 - eng do
64664: LD_ADDR_VAR 0 3
64668: PUSH
64669: DOUBLE
64670: LD_INT 1
64672: DEC
64673: ST_TO_ADDR
64674: LD_INT 6
64676: PUSH
64677: LD_VAR 0 6
64681: MINUS
64682: PUSH
64683: FOR_TO
64684: IFFALSE 64776
// begin if i = sort then
64686: LD_VAR 0 3
64690: PUSH
64691: LD_VAR 0 9
64695: EQUAL
64696: IFFALSE 64700
// break ;
64698: GO 64776
// if GetClass ( i ) = 2 then
64700: LD_VAR 0 3
64704: PPUSH
64705: CALL_OW 257
64709: PUSH
64710: LD_INT 2
64712: EQUAL
64713: IFFALSE 64717
// continue ;
64715: GO 64683
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64717: LD_ADDR_VAR 0 11
64721: PUSH
64722: LD_VAR 0 11
64726: PPUSH
64727: LD_VAR 0 11
64731: PUSH
64732: LD_INT 1
64734: PLUS
64735: PPUSH
64736: LD_VAR 0 9
64740: PUSH
64741: LD_VAR 0 3
64745: ARRAY
64746: PPUSH
64747: CALL_OW 2
64751: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64752: LD_ADDR_VAR 0 4
64756: PUSH
64757: LD_VAR 0 4
64761: PUSH
64762: LD_VAR 0 9
64766: PUSH
64767: LD_VAR 0 3
64771: ARRAY
64772: DIFF
64773: ST_TO_ADDR
// end ;
64774: GO 64683
64776: POP
64777: POP
// if p then
64778: LD_VAR 0 11
64782: IFFALSE 64807
// result := Replace ( result , 2 , p ) ;
64784: LD_ADDR_VAR 0 2
64788: PUSH
64789: LD_VAR 0 2
64793: PPUSH
64794: LD_INT 2
64796: PPUSH
64797: LD_VAR 0 11
64801: PPUSH
64802: CALL_OW 1
64806: ST_TO_ADDR
// end ; exit ;
64807: GO 65531
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
64809: LD_EXP 85
64813: PUSH
64814: LD_EXP 84
64818: PUSH
64819: LD_VAR 0 1
64823: ARRAY
64824: ARRAY
64825: NOT
64826: PUSH
64827: LD_EXP 58
64831: PUSH
64832: LD_VAR 0 1
64836: ARRAY
64837: PPUSH
64838: LD_INT 30
64840: PUSH
64841: LD_INT 3
64843: PUSH
64844: EMPTY
64845: LIST
64846: LIST
64847: PPUSH
64848: CALL_OW 72
64852: AND
64853: PUSH
64854: LD_EXP 63
64858: PUSH
64859: LD_VAR 0 1
64863: ARRAY
64864: NOT
64865: AND
64866: IFFALSE 65531
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
64868: LD_ADDR_EXP 100
64872: PUSH
64873: LD_EXP 100
64877: PPUSH
64878: LD_VAR 0 1
64882: PPUSH
64883: LD_INT 6
64885: PPUSH
64886: CALL_OW 1
64890: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64891: LD_ADDR_VAR 0 2
64895: PUSH
64896: LD_INT 0
64898: PUSH
64899: LD_INT 0
64901: PUSH
64902: LD_INT 0
64904: PUSH
64905: LD_INT 0
64907: PUSH
64908: EMPTY
64909: LIST
64910: LIST
64911: LIST
64912: LIST
64913: ST_TO_ADDR
// if sci >= 1 then
64914: LD_VAR 0 8
64918: PUSH
64919: LD_INT 1
64921: GREATEREQUAL
64922: IFFALSE 64944
// tmp := tmp diff sci [ 1 ] ;
64924: LD_ADDR_VAR 0 4
64928: PUSH
64929: LD_VAR 0 4
64933: PUSH
64934: LD_VAR 0 8
64938: PUSH
64939: LD_INT 1
64941: ARRAY
64942: DIFF
64943: ST_TO_ADDR
// if tmp and not sci then
64944: LD_VAR 0 4
64948: PUSH
64949: LD_VAR 0 8
64953: NOT
64954: AND
64955: IFFALSE 65024
// begin sort := SortBySkill ( tmp , 4 ) ;
64957: LD_ADDR_VAR 0 9
64961: PUSH
64962: LD_VAR 0 4
64966: PPUSH
64967: LD_INT 4
64969: PPUSH
64970: CALL 55614 0 2
64974: ST_TO_ADDR
// if sort then
64975: LD_VAR 0 9
64979: IFFALSE 64995
// p := sort [ 1 ] ;
64981: LD_ADDR_VAR 0 11
64985: PUSH
64986: LD_VAR 0 9
64990: PUSH
64991: LD_INT 1
64993: ARRAY
64994: ST_TO_ADDR
// if p then
64995: LD_VAR 0 11
64999: IFFALSE 65024
// result := Replace ( result , 4 , p ) ;
65001: LD_ADDR_VAR 0 2
65005: PUSH
65006: LD_VAR 0 2
65010: PPUSH
65011: LD_INT 4
65013: PPUSH
65014: LD_VAR 0 11
65018: PPUSH
65019: CALL_OW 1
65023: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
65024: LD_ADDR_VAR 0 4
65028: PUSH
65029: LD_VAR 0 4
65033: PUSH
65034: LD_VAR 0 7
65038: DIFF
65039: ST_TO_ADDR
// if tmp and mech < 6 then
65040: LD_VAR 0 4
65044: PUSH
65045: LD_VAR 0 7
65049: PUSH
65050: LD_INT 6
65052: LESS
65053: AND
65054: IFFALSE 65236
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
65056: LD_ADDR_VAR 0 9
65060: PUSH
65061: LD_VAR 0 4
65065: PUSH
65066: LD_VAR 0 7
65070: DIFF
65071: PPUSH
65072: LD_INT 3
65074: PPUSH
65075: CALL 55614 0 2
65079: ST_TO_ADDR
// p := [ ] ;
65080: LD_ADDR_VAR 0 11
65084: PUSH
65085: EMPTY
65086: ST_TO_ADDR
// if sort then
65087: LD_VAR 0 9
65091: IFFALSE 65207
// for i = 1 to 6 - mech do
65093: LD_ADDR_VAR 0 3
65097: PUSH
65098: DOUBLE
65099: LD_INT 1
65101: DEC
65102: ST_TO_ADDR
65103: LD_INT 6
65105: PUSH
65106: LD_VAR 0 7
65110: MINUS
65111: PUSH
65112: FOR_TO
65113: IFFALSE 65205
// begin if i = sort then
65115: LD_VAR 0 3
65119: PUSH
65120: LD_VAR 0 9
65124: EQUAL
65125: IFFALSE 65129
// break ;
65127: GO 65205
// if GetClass ( i ) = 3 then
65129: LD_VAR 0 3
65133: PPUSH
65134: CALL_OW 257
65138: PUSH
65139: LD_INT 3
65141: EQUAL
65142: IFFALSE 65146
// continue ;
65144: GO 65112
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65146: LD_ADDR_VAR 0 11
65150: PUSH
65151: LD_VAR 0 11
65155: PPUSH
65156: LD_VAR 0 11
65160: PUSH
65161: LD_INT 1
65163: PLUS
65164: PPUSH
65165: LD_VAR 0 9
65169: PUSH
65170: LD_VAR 0 3
65174: ARRAY
65175: PPUSH
65176: CALL_OW 2
65180: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65181: LD_ADDR_VAR 0 4
65185: PUSH
65186: LD_VAR 0 4
65190: PUSH
65191: LD_VAR 0 9
65195: PUSH
65196: LD_VAR 0 3
65200: ARRAY
65201: DIFF
65202: ST_TO_ADDR
// end ;
65203: GO 65112
65205: POP
65206: POP
// if p then
65207: LD_VAR 0 11
65211: IFFALSE 65236
// result := Replace ( result , 3 , p ) ;
65213: LD_ADDR_VAR 0 2
65217: PUSH
65218: LD_VAR 0 2
65222: PPUSH
65223: LD_INT 3
65225: PPUSH
65226: LD_VAR 0 11
65230: PPUSH
65231: CALL_OW 1
65235: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
65236: LD_ADDR_VAR 0 4
65240: PUSH
65241: LD_VAR 0 4
65245: PUSH
65246: LD_VAR 0 6
65250: DIFF
65251: ST_TO_ADDR
// if tmp and eng < 4 then
65252: LD_VAR 0 4
65256: PUSH
65257: LD_VAR 0 6
65261: PUSH
65262: LD_INT 4
65264: LESS
65265: AND
65266: IFFALSE 65456
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
65268: LD_ADDR_VAR 0 9
65272: PUSH
65273: LD_VAR 0 4
65277: PUSH
65278: LD_VAR 0 7
65282: PUSH
65283: LD_VAR 0 6
65287: UNION
65288: DIFF
65289: PPUSH
65290: LD_INT 2
65292: PPUSH
65293: CALL 55614 0 2
65297: ST_TO_ADDR
// p := [ ] ;
65298: LD_ADDR_VAR 0 11
65302: PUSH
65303: EMPTY
65304: ST_TO_ADDR
// if sort then
65305: LD_VAR 0 9
65309: IFFALSE 65425
// for i = 1 to 4 - eng do
65311: LD_ADDR_VAR 0 3
65315: PUSH
65316: DOUBLE
65317: LD_INT 1
65319: DEC
65320: ST_TO_ADDR
65321: LD_INT 4
65323: PUSH
65324: LD_VAR 0 6
65328: MINUS
65329: PUSH
65330: FOR_TO
65331: IFFALSE 65423
// begin if i = sort then
65333: LD_VAR 0 3
65337: PUSH
65338: LD_VAR 0 9
65342: EQUAL
65343: IFFALSE 65347
// break ;
65345: GO 65423
// if GetClass ( i ) = 2 then
65347: LD_VAR 0 3
65351: PPUSH
65352: CALL_OW 257
65356: PUSH
65357: LD_INT 2
65359: EQUAL
65360: IFFALSE 65364
// continue ;
65362: GO 65330
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65364: LD_ADDR_VAR 0 11
65368: PUSH
65369: LD_VAR 0 11
65373: PPUSH
65374: LD_VAR 0 11
65378: PUSH
65379: LD_INT 1
65381: PLUS
65382: PPUSH
65383: LD_VAR 0 9
65387: PUSH
65388: LD_VAR 0 3
65392: ARRAY
65393: PPUSH
65394: CALL_OW 2
65398: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65399: LD_ADDR_VAR 0 4
65403: PUSH
65404: LD_VAR 0 4
65408: PUSH
65409: LD_VAR 0 9
65413: PUSH
65414: LD_VAR 0 3
65418: ARRAY
65419: DIFF
65420: ST_TO_ADDR
// end ;
65421: GO 65330
65423: POP
65424: POP
// if p then
65425: LD_VAR 0 11
65429: IFFALSE 65454
// result := Replace ( result , 2 , p ) ;
65431: LD_ADDR_VAR 0 2
65435: PUSH
65436: LD_VAR 0 2
65440: PPUSH
65441: LD_INT 2
65443: PPUSH
65444: LD_VAR 0 11
65448: PPUSH
65449: CALL_OW 1
65453: ST_TO_ADDR
// end else
65454: GO 65500
// for i = eng downto 5 do
65456: LD_ADDR_VAR 0 3
65460: PUSH
65461: DOUBLE
65462: LD_VAR 0 6
65466: INC
65467: ST_TO_ADDR
65468: LD_INT 5
65470: PUSH
65471: FOR_DOWNTO
65472: IFFALSE 65498
// tmp := tmp union eng [ i ] ;
65474: LD_ADDR_VAR 0 4
65478: PUSH
65479: LD_VAR 0 4
65483: PUSH
65484: LD_VAR 0 6
65488: PUSH
65489: LD_VAR 0 3
65493: ARRAY
65494: UNION
65495: ST_TO_ADDR
65496: GO 65471
65498: POP
65499: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
65500: LD_ADDR_VAR 0 2
65504: PUSH
65505: LD_VAR 0 2
65509: PPUSH
65510: LD_INT 1
65512: PPUSH
65513: LD_VAR 0 4
65517: PUSH
65518: LD_VAR 0 5
65522: DIFF
65523: PPUSH
65524: CALL_OW 1
65528: ST_TO_ADDR
// exit ;
65529: GO 65531
// end ; end ;
65531: LD_VAR 0 2
65535: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
65536: LD_INT 0
65538: PPUSH
65539: PPUSH
65540: PPUSH
// if not mc_bases then
65541: LD_EXP 58
65545: NOT
65546: IFFALSE 65550
// exit ;
65548: GO 65656
// for i = 1 to mc_bases do
65550: LD_ADDR_VAR 0 2
65554: PUSH
65555: DOUBLE
65556: LD_INT 1
65558: DEC
65559: ST_TO_ADDR
65560: LD_EXP 58
65564: PUSH
65565: FOR_TO
65566: IFFALSE 65647
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65568: LD_ADDR_VAR 0 3
65572: PUSH
65573: LD_EXP 58
65577: PUSH
65578: LD_VAR 0 2
65582: ARRAY
65583: PPUSH
65584: LD_INT 21
65586: PUSH
65587: LD_INT 3
65589: PUSH
65590: EMPTY
65591: LIST
65592: LIST
65593: PUSH
65594: LD_INT 3
65596: PUSH
65597: LD_INT 24
65599: PUSH
65600: LD_INT 1000
65602: PUSH
65603: EMPTY
65604: LIST
65605: LIST
65606: PUSH
65607: EMPTY
65608: LIST
65609: LIST
65610: PUSH
65611: EMPTY
65612: LIST
65613: LIST
65614: PPUSH
65615: CALL_OW 72
65619: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
65620: LD_ADDR_EXP 59
65624: PUSH
65625: LD_EXP 59
65629: PPUSH
65630: LD_VAR 0 2
65634: PPUSH
65635: LD_VAR 0 3
65639: PPUSH
65640: CALL_OW 1
65644: ST_TO_ADDR
// end ;
65645: GO 65565
65647: POP
65648: POP
// RaiseSailEvent ( 101 ) ;
65649: LD_INT 101
65651: PPUSH
65652: CALL_OW 427
// end ;
65656: LD_VAR 0 1
65660: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
65661: LD_INT 0
65663: PPUSH
65664: PPUSH
65665: PPUSH
65666: PPUSH
65667: PPUSH
65668: PPUSH
65669: PPUSH
// if not mc_bases then
65670: LD_EXP 58
65674: NOT
65675: IFFALSE 65679
// exit ;
65677: GO 66252
// for i = 1 to mc_bases do
65679: LD_ADDR_VAR 0 2
65683: PUSH
65684: DOUBLE
65685: LD_INT 1
65687: DEC
65688: ST_TO_ADDR
65689: LD_EXP 58
65693: PUSH
65694: FOR_TO
65695: IFFALSE 66243
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
65697: LD_ADDR_VAR 0 5
65701: PUSH
65702: LD_EXP 58
65706: PUSH
65707: LD_VAR 0 2
65711: ARRAY
65712: PUSH
65713: LD_EXP 87
65717: PUSH
65718: LD_VAR 0 2
65722: ARRAY
65723: UNION
65724: PPUSH
65725: LD_INT 21
65727: PUSH
65728: LD_INT 1
65730: PUSH
65731: EMPTY
65732: LIST
65733: LIST
65734: PUSH
65735: LD_INT 1
65737: PUSH
65738: LD_INT 3
65740: PUSH
65741: LD_INT 54
65743: PUSH
65744: EMPTY
65745: LIST
65746: PUSH
65747: EMPTY
65748: LIST
65749: LIST
65750: PUSH
65751: LD_INT 3
65753: PUSH
65754: LD_INT 24
65756: PUSH
65757: LD_INT 800
65759: PUSH
65760: EMPTY
65761: LIST
65762: LIST
65763: PUSH
65764: EMPTY
65765: LIST
65766: LIST
65767: PUSH
65768: EMPTY
65769: LIST
65770: LIST
65771: LIST
65772: PUSH
65773: EMPTY
65774: LIST
65775: LIST
65776: PPUSH
65777: CALL_OW 72
65781: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
65782: LD_ADDR_VAR 0 6
65786: PUSH
65787: LD_EXP 58
65791: PUSH
65792: LD_VAR 0 2
65796: ARRAY
65797: PPUSH
65798: LD_INT 21
65800: PUSH
65801: LD_INT 1
65803: PUSH
65804: EMPTY
65805: LIST
65806: LIST
65807: PUSH
65808: LD_INT 1
65810: PUSH
65811: LD_INT 3
65813: PUSH
65814: LD_INT 54
65816: PUSH
65817: EMPTY
65818: LIST
65819: PUSH
65820: EMPTY
65821: LIST
65822: LIST
65823: PUSH
65824: LD_INT 3
65826: PUSH
65827: LD_INT 24
65829: PUSH
65830: LD_INT 250
65832: PUSH
65833: EMPTY
65834: LIST
65835: LIST
65836: PUSH
65837: EMPTY
65838: LIST
65839: LIST
65840: PUSH
65841: EMPTY
65842: LIST
65843: LIST
65844: LIST
65845: PUSH
65846: EMPTY
65847: LIST
65848: LIST
65849: PPUSH
65850: CALL_OW 72
65854: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
65855: LD_ADDR_VAR 0 7
65859: PUSH
65860: LD_VAR 0 5
65864: PUSH
65865: LD_VAR 0 6
65869: DIFF
65870: ST_TO_ADDR
// if not need_heal_1 then
65871: LD_VAR 0 6
65875: NOT
65876: IFFALSE 65909
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
65878: LD_ADDR_EXP 61
65882: PUSH
65883: LD_EXP 61
65887: PPUSH
65888: LD_VAR 0 2
65892: PUSH
65893: LD_INT 1
65895: PUSH
65896: EMPTY
65897: LIST
65898: LIST
65899: PPUSH
65900: EMPTY
65901: PPUSH
65902: CALL 21366 0 3
65906: ST_TO_ADDR
65907: GO 65979
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
65909: LD_ADDR_EXP 61
65913: PUSH
65914: LD_EXP 61
65918: PPUSH
65919: LD_VAR 0 2
65923: PUSH
65924: LD_INT 1
65926: PUSH
65927: EMPTY
65928: LIST
65929: LIST
65930: PPUSH
65931: LD_EXP 61
65935: PUSH
65936: LD_VAR 0 2
65940: ARRAY
65941: PUSH
65942: LD_INT 1
65944: ARRAY
65945: PPUSH
65946: LD_INT 3
65948: PUSH
65949: LD_INT 24
65951: PUSH
65952: LD_INT 1000
65954: PUSH
65955: EMPTY
65956: LIST
65957: LIST
65958: PUSH
65959: EMPTY
65960: LIST
65961: LIST
65962: PPUSH
65963: CALL_OW 72
65967: PUSH
65968: LD_VAR 0 6
65972: UNION
65973: PPUSH
65974: CALL 21366 0 3
65978: ST_TO_ADDR
// if not need_heal_2 then
65979: LD_VAR 0 7
65983: NOT
65984: IFFALSE 66017
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
65986: LD_ADDR_EXP 61
65990: PUSH
65991: LD_EXP 61
65995: PPUSH
65996: LD_VAR 0 2
66000: PUSH
66001: LD_INT 2
66003: PUSH
66004: EMPTY
66005: LIST
66006: LIST
66007: PPUSH
66008: EMPTY
66009: PPUSH
66010: CALL 21366 0 3
66014: ST_TO_ADDR
66015: GO 66049
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
66017: LD_ADDR_EXP 61
66021: PUSH
66022: LD_EXP 61
66026: PPUSH
66027: LD_VAR 0 2
66031: PUSH
66032: LD_INT 2
66034: PUSH
66035: EMPTY
66036: LIST
66037: LIST
66038: PPUSH
66039: LD_VAR 0 7
66043: PPUSH
66044: CALL 21366 0 3
66048: ST_TO_ADDR
// if need_heal_2 then
66049: LD_VAR 0 7
66053: IFFALSE 66225
// for j in need_heal_2 do
66055: LD_ADDR_VAR 0 3
66059: PUSH
66060: LD_VAR 0 7
66064: PUSH
66065: FOR_IN
66066: IFFALSE 66223
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
66068: LD_ADDR_VAR 0 5
66072: PUSH
66073: LD_EXP 58
66077: PUSH
66078: LD_VAR 0 2
66082: ARRAY
66083: PPUSH
66084: LD_INT 2
66086: PUSH
66087: LD_INT 30
66089: PUSH
66090: LD_INT 6
66092: PUSH
66093: EMPTY
66094: LIST
66095: LIST
66096: PUSH
66097: LD_INT 30
66099: PUSH
66100: LD_INT 7
66102: PUSH
66103: EMPTY
66104: LIST
66105: LIST
66106: PUSH
66107: LD_INT 30
66109: PUSH
66110: LD_INT 8
66112: PUSH
66113: EMPTY
66114: LIST
66115: LIST
66116: PUSH
66117: LD_INT 30
66119: PUSH
66120: LD_INT 0
66122: PUSH
66123: EMPTY
66124: LIST
66125: LIST
66126: PUSH
66127: LD_INT 30
66129: PUSH
66130: LD_INT 1
66132: PUSH
66133: EMPTY
66134: LIST
66135: LIST
66136: PUSH
66137: LD_INT 25
66139: PUSH
66140: LD_INT 4
66142: PUSH
66143: EMPTY
66144: LIST
66145: LIST
66146: PUSH
66147: EMPTY
66148: LIST
66149: LIST
66150: LIST
66151: LIST
66152: LIST
66153: LIST
66154: LIST
66155: PPUSH
66156: CALL_OW 72
66160: ST_TO_ADDR
// if tmp then
66161: LD_VAR 0 5
66165: IFFALSE 66221
// begin k := NearestUnitToUnit ( tmp , j ) ;
66167: LD_ADDR_VAR 0 4
66171: PUSH
66172: LD_VAR 0 5
66176: PPUSH
66177: LD_VAR 0 3
66181: PPUSH
66182: CALL_OW 74
66186: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
66187: LD_VAR 0 3
66191: PPUSH
66192: LD_VAR 0 4
66196: PPUSH
66197: CALL_OW 296
66201: PUSH
66202: LD_INT 7
66204: GREATER
66205: IFFALSE 66221
// ComMoveUnit ( j , k ) ;
66207: LD_VAR 0 3
66211: PPUSH
66212: LD_VAR 0 4
66216: PPUSH
66217: CALL_OW 112
// end ; end ;
66221: GO 66065
66223: POP
66224: POP
// if not need_heal_1 and not need_heal_2 then
66225: LD_VAR 0 6
66229: NOT
66230: PUSH
66231: LD_VAR 0 7
66235: NOT
66236: AND
66237: IFFALSE 66241
// continue ;
66239: GO 65694
// end ;
66241: GO 65694
66243: POP
66244: POP
// RaiseSailEvent ( 102 ) ;
66245: LD_INT 102
66247: PPUSH
66248: CALL_OW 427
// end ;
66252: LD_VAR 0 1
66256: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
66257: LD_INT 0
66259: PPUSH
66260: PPUSH
66261: PPUSH
66262: PPUSH
66263: PPUSH
66264: PPUSH
// if not mc_bases then
66265: LD_EXP 58
66269: NOT
66270: IFFALSE 66274
// exit ;
66272: GO 66984
// for i = 1 to mc_bases do
66274: LD_ADDR_VAR 0 2
66278: PUSH
66279: DOUBLE
66280: LD_INT 1
66282: DEC
66283: ST_TO_ADDR
66284: LD_EXP 58
66288: PUSH
66289: FOR_TO
66290: IFFALSE 66982
// begin if not mc_building_need_repair [ i ] then
66292: LD_EXP 59
66296: PUSH
66297: LD_VAR 0 2
66301: ARRAY
66302: NOT
66303: IFFALSE 66477
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
66305: LD_ADDR_VAR 0 6
66309: PUSH
66310: LD_EXP 77
66314: PUSH
66315: LD_VAR 0 2
66319: ARRAY
66320: PPUSH
66321: LD_INT 3
66323: PUSH
66324: LD_INT 24
66326: PUSH
66327: LD_INT 1000
66329: PUSH
66330: EMPTY
66331: LIST
66332: LIST
66333: PUSH
66334: EMPTY
66335: LIST
66336: LIST
66337: PUSH
66338: LD_INT 2
66340: PUSH
66341: LD_INT 34
66343: PUSH
66344: LD_INT 13
66346: PUSH
66347: EMPTY
66348: LIST
66349: LIST
66350: PUSH
66351: LD_INT 34
66353: PUSH
66354: LD_INT 52
66356: PUSH
66357: EMPTY
66358: LIST
66359: LIST
66360: PUSH
66361: EMPTY
66362: LIST
66363: LIST
66364: LIST
66365: PUSH
66366: EMPTY
66367: LIST
66368: LIST
66369: PPUSH
66370: CALL_OW 72
66374: ST_TO_ADDR
// if cranes then
66375: LD_VAR 0 6
66379: IFFALSE 66441
// for j in cranes do
66381: LD_ADDR_VAR 0 3
66385: PUSH
66386: LD_VAR 0 6
66390: PUSH
66391: FOR_IN
66392: IFFALSE 66439
// if not IsInArea ( j , mc_parking [ i ] ) then
66394: LD_VAR 0 3
66398: PPUSH
66399: LD_EXP 82
66403: PUSH
66404: LD_VAR 0 2
66408: ARRAY
66409: PPUSH
66410: CALL_OW 308
66414: NOT
66415: IFFALSE 66437
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66417: LD_VAR 0 3
66421: PPUSH
66422: LD_EXP 82
66426: PUSH
66427: LD_VAR 0 2
66431: ARRAY
66432: PPUSH
66433: CALL_OW 113
66437: GO 66391
66439: POP
66440: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
66441: LD_ADDR_EXP 60
66445: PUSH
66446: LD_EXP 60
66450: PPUSH
66451: LD_VAR 0 2
66455: PPUSH
66456: EMPTY
66457: PPUSH
66458: CALL_OW 1
66462: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
66463: LD_VAR 0 2
66467: PPUSH
66468: LD_INT 101
66470: PPUSH
66471: CALL 61369 0 2
// continue ;
66475: GO 66289
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
66477: LD_ADDR_EXP 64
66481: PUSH
66482: LD_EXP 64
66486: PPUSH
66487: LD_VAR 0 2
66491: PPUSH
66492: EMPTY
66493: PPUSH
66494: CALL_OW 1
66498: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66499: LD_VAR 0 2
66503: PPUSH
66504: LD_INT 103
66506: PPUSH
66507: CALL 61369 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
66511: LD_ADDR_VAR 0 5
66515: PUSH
66516: LD_EXP 58
66520: PUSH
66521: LD_VAR 0 2
66525: ARRAY
66526: PUSH
66527: LD_EXP 87
66531: PUSH
66532: LD_VAR 0 2
66536: ARRAY
66537: UNION
66538: PPUSH
66539: LD_INT 2
66541: PUSH
66542: LD_INT 25
66544: PUSH
66545: LD_INT 2
66547: PUSH
66548: EMPTY
66549: LIST
66550: LIST
66551: PUSH
66552: LD_INT 25
66554: PUSH
66555: LD_INT 16
66557: PUSH
66558: EMPTY
66559: LIST
66560: LIST
66561: PUSH
66562: EMPTY
66563: LIST
66564: LIST
66565: LIST
66566: PUSH
66567: EMPTY
66568: LIST
66569: PPUSH
66570: CALL_OW 72
66574: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
66575: LD_ADDR_VAR 0 6
66579: PUSH
66580: LD_EXP 77
66584: PUSH
66585: LD_VAR 0 2
66589: ARRAY
66590: PPUSH
66591: LD_INT 2
66593: PUSH
66594: LD_INT 34
66596: PUSH
66597: LD_INT 13
66599: PUSH
66600: EMPTY
66601: LIST
66602: LIST
66603: PUSH
66604: LD_INT 34
66606: PUSH
66607: LD_INT 52
66609: PUSH
66610: EMPTY
66611: LIST
66612: LIST
66613: PUSH
66614: EMPTY
66615: LIST
66616: LIST
66617: LIST
66618: PPUSH
66619: CALL_OW 72
66623: ST_TO_ADDR
// if cranes then
66624: LD_VAR 0 6
66628: IFFALSE 66764
// begin for j in cranes do
66630: LD_ADDR_VAR 0 3
66634: PUSH
66635: LD_VAR 0 6
66639: PUSH
66640: FOR_IN
66641: IFFALSE 66762
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
66643: LD_VAR 0 3
66647: PPUSH
66648: CALL_OW 256
66652: PUSH
66653: LD_INT 500
66655: GREATEREQUAL
66656: PUSH
66657: LD_VAR 0 3
66661: PPUSH
66662: CALL_OW 314
66666: NOT
66667: AND
66668: IFFALSE 66702
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
66670: LD_VAR 0 3
66674: PPUSH
66675: LD_EXP 59
66679: PUSH
66680: LD_VAR 0 2
66684: ARRAY
66685: PPUSH
66686: LD_VAR 0 3
66690: PPUSH
66691: CALL_OW 74
66695: PPUSH
66696: CALL_OW 130
66700: GO 66760
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
66702: LD_VAR 0 3
66706: PPUSH
66707: CALL_OW 256
66711: PUSH
66712: LD_INT 500
66714: LESS
66715: PUSH
66716: LD_VAR 0 3
66720: PPUSH
66721: LD_EXP 82
66725: PUSH
66726: LD_VAR 0 2
66730: ARRAY
66731: PPUSH
66732: CALL_OW 308
66736: NOT
66737: AND
66738: IFFALSE 66760
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66740: LD_VAR 0 3
66744: PPUSH
66745: LD_EXP 82
66749: PUSH
66750: LD_VAR 0 2
66754: ARRAY
66755: PPUSH
66756: CALL_OW 113
66760: GO 66640
66762: POP
66763: POP
// end ; if not tmp then
66764: LD_VAR 0 5
66768: NOT
66769: IFFALSE 66773
// continue ;
66771: GO 66289
// for j in tmp do
66773: LD_ADDR_VAR 0 3
66777: PUSH
66778: LD_VAR 0 5
66782: PUSH
66783: FOR_IN
66784: IFFALSE 66978
// begin if mc_need_heal [ i ] then
66786: LD_EXP 61
66790: PUSH
66791: LD_VAR 0 2
66795: ARRAY
66796: IFFALSE 66844
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
66798: LD_VAR 0 3
66802: PUSH
66803: LD_EXP 61
66807: PUSH
66808: LD_VAR 0 2
66812: ARRAY
66813: PUSH
66814: LD_INT 1
66816: ARRAY
66817: IN
66818: PUSH
66819: LD_VAR 0 3
66823: PUSH
66824: LD_EXP 61
66828: PUSH
66829: LD_VAR 0 2
66833: ARRAY
66834: PUSH
66835: LD_INT 2
66837: ARRAY
66838: IN
66839: OR
66840: IFFALSE 66844
// continue ;
66842: GO 66783
// if IsInUnit ( j ) then
66844: LD_VAR 0 3
66848: PPUSH
66849: CALL_OW 310
66853: IFFALSE 66864
// ComExitBuilding ( j ) ;
66855: LD_VAR 0 3
66859: PPUSH
66860: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
66864: LD_VAR 0 3
66868: PUSH
66869: LD_EXP 60
66873: PUSH
66874: LD_VAR 0 2
66878: ARRAY
66879: IN
66880: NOT
66881: IFFALSE 66939
// begin SetTag ( j , 101 ) ;
66883: LD_VAR 0 3
66887: PPUSH
66888: LD_INT 101
66890: PPUSH
66891: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
66895: LD_ADDR_EXP 60
66899: PUSH
66900: LD_EXP 60
66904: PPUSH
66905: LD_VAR 0 2
66909: PUSH
66910: LD_EXP 60
66914: PUSH
66915: LD_VAR 0 2
66919: ARRAY
66920: PUSH
66921: LD_INT 1
66923: PLUS
66924: PUSH
66925: EMPTY
66926: LIST
66927: LIST
66928: PPUSH
66929: LD_VAR 0 3
66933: PPUSH
66934: CALL 21366 0 3
66938: ST_TO_ADDR
// end ; wait ( 1 ) ;
66939: LD_INT 1
66941: PPUSH
66942: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
66946: LD_VAR 0 3
66950: PPUSH
66951: LD_EXP 59
66955: PUSH
66956: LD_VAR 0 2
66960: ARRAY
66961: PPUSH
66962: LD_VAR 0 3
66966: PPUSH
66967: CALL_OW 74
66971: PPUSH
66972: CALL_OW 130
// end ;
66976: GO 66783
66978: POP
66979: POP
// end ;
66980: GO 66289
66982: POP
66983: POP
// end ;
66984: LD_VAR 0 1
66988: RET
// export function MC_Heal ; var i , j , tmp ; begin
66989: LD_INT 0
66991: PPUSH
66992: PPUSH
66993: PPUSH
66994: PPUSH
// if not mc_bases then
66995: LD_EXP 58
66999: NOT
67000: IFFALSE 67004
// exit ;
67002: GO 67406
// for i = 1 to mc_bases do
67004: LD_ADDR_VAR 0 2
67008: PUSH
67009: DOUBLE
67010: LD_INT 1
67012: DEC
67013: ST_TO_ADDR
67014: LD_EXP 58
67018: PUSH
67019: FOR_TO
67020: IFFALSE 67404
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
67022: LD_EXP 61
67026: PUSH
67027: LD_VAR 0 2
67031: ARRAY
67032: PUSH
67033: LD_INT 1
67035: ARRAY
67036: NOT
67037: PUSH
67038: LD_EXP 61
67042: PUSH
67043: LD_VAR 0 2
67047: ARRAY
67048: PUSH
67049: LD_INT 2
67051: ARRAY
67052: NOT
67053: AND
67054: IFFALSE 67092
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
67056: LD_ADDR_EXP 62
67060: PUSH
67061: LD_EXP 62
67065: PPUSH
67066: LD_VAR 0 2
67070: PPUSH
67071: EMPTY
67072: PPUSH
67073: CALL_OW 1
67077: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
67078: LD_VAR 0 2
67082: PPUSH
67083: LD_INT 102
67085: PPUSH
67086: CALL 61369 0 2
// continue ;
67090: GO 67019
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
67092: LD_ADDR_VAR 0 4
67096: PUSH
67097: LD_EXP 58
67101: PUSH
67102: LD_VAR 0 2
67106: ARRAY
67107: PPUSH
67108: LD_INT 25
67110: PUSH
67111: LD_INT 4
67113: PUSH
67114: EMPTY
67115: LIST
67116: LIST
67117: PPUSH
67118: CALL_OW 72
67122: ST_TO_ADDR
// if not tmp then
67123: LD_VAR 0 4
67127: NOT
67128: IFFALSE 67132
// continue ;
67130: GO 67019
// if mc_taming [ i ] then
67132: LD_EXP 89
67136: PUSH
67137: LD_VAR 0 2
67141: ARRAY
67142: IFFALSE 67166
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
67144: LD_ADDR_EXP 89
67148: PUSH
67149: LD_EXP 89
67153: PPUSH
67154: LD_VAR 0 2
67158: PPUSH
67159: EMPTY
67160: PPUSH
67161: CALL_OW 1
67165: ST_TO_ADDR
// for j in tmp do
67166: LD_ADDR_VAR 0 3
67170: PUSH
67171: LD_VAR 0 4
67175: PUSH
67176: FOR_IN
67177: IFFALSE 67400
// begin if IsInUnit ( j ) then
67179: LD_VAR 0 3
67183: PPUSH
67184: CALL_OW 310
67188: IFFALSE 67199
// ComExitBuilding ( j ) ;
67190: LD_VAR 0 3
67194: PPUSH
67195: CALL_OW 122
// if not j in mc_healers [ i ] then
67199: LD_VAR 0 3
67203: PUSH
67204: LD_EXP 62
67208: PUSH
67209: LD_VAR 0 2
67213: ARRAY
67214: IN
67215: NOT
67216: IFFALSE 67262
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
67218: LD_ADDR_EXP 62
67222: PUSH
67223: LD_EXP 62
67227: PPUSH
67228: LD_VAR 0 2
67232: PUSH
67233: LD_EXP 62
67237: PUSH
67238: LD_VAR 0 2
67242: ARRAY
67243: PUSH
67244: LD_INT 1
67246: PLUS
67247: PUSH
67248: EMPTY
67249: LIST
67250: LIST
67251: PPUSH
67252: LD_VAR 0 3
67256: PPUSH
67257: CALL 21366 0 3
67261: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
67262: LD_VAR 0 3
67266: PPUSH
67267: CALL_OW 110
67271: PUSH
67272: LD_INT 102
67274: NONEQUAL
67275: IFFALSE 67289
// SetTag ( j , 102 ) ;
67277: LD_VAR 0 3
67281: PPUSH
67282: LD_INT 102
67284: PPUSH
67285: CALL_OW 109
// Wait ( 3 ) ;
67289: LD_INT 3
67291: PPUSH
67292: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
67296: LD_EXP 61
67300: PUSH
67301: LD_VAR 0 2
67305: ARRAY
67306: PUSH
67307: LD_INT 1
67309: ARRAY
67310: IFFALSE 67342
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
67312: LD_VAR 0 3
67316: PPUSH
67317: LD_EXP 61
67321: PUSH
67322: LD_VAR 0 2
67326: ARRAY
67327: PUSH
67328: LD_INT 1
67330: ARRAY
67331: PUSH
67332: LD_INT 1
67334: ARRAY
67335: PPUSH
67336: CALL_OW 128
67340: GO 67398
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
67342: LD_VAR 0 3
67346: PPUSH
67347: CALL_OW 314
67351: NOT
67352: PUSH
67353: LD_EXP 61
67357: PUSH
67358: LD_VAR 0 2
67362: ARRAY
67363: PUSH
67364: LD_INT 2
67366: ARRAY
67367: AND
67368: IFFALSE 67398
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
67370: LD_VAR 0 3
67374: PPUSH
67375: LD_EXP 61
67379: PUSH
67380: LD_VAR 0 2
67384: ARRAY
67385: PUSH
67386: LD_INT 2
67388: ARRAY
67389: PUSH
67390: LD_INT 1
67392: ARRAY
67393: PPUSH
67394: CALL_OW 128
// end ;
67398: GO 67176
67400: POP
67401: POP
// end ;
67402: GO 67019
67404: POP
67405: POP
// end ;
67406: LD_VAR 0 1
67410: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
67411: LD_INT 0
67413: PPUSH
67414: PPUSH
67415: PPUSH
67416: PPUSH
67417: PPUSH
// if not mc_bases then
67418: LD_EXP 58
67422: NOT
67423: IFFALSE 67427
// exit ;
67425: GO 68570
// for i = 1 to mc_bases do
67427: LD_ADDR_VAR 0 2
67431: PUSH
67432: DOUBLE
67433: LD_INT 1
67435: DEC
67436: ST_TO_ADDR
67437: LD_EXP 58
67441: PUSH
67442: FOR_TO
67443: IFFALSE 68568
// begin if mc_scan [ i ] then
67445: LD_EXP 81
67449: PUSH
67450: LD_VAR 0 2
67454: ARRAY
67455: IFFALSE 67459
// continue ;
67457: GO 67442
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
67459: LD_EXP 63
67463: PUSH
67464: LD_VAR 0 2
67468: ARRAY
67469: NOT
67470: PUSH
67471: LD_EXP 65
67475: PUSH
67476: LD_VAR 0 2
67480: ARRAY
67481: NOT
67482: AND
67483: PUSH
67484: LD_EXP 64
67488: PUSH
67489: LD_VAR 0 2
67493: ARRAY
67494: AND
67495: IFFALSE 67533
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
67497: LD_ADDR_EXP 64
67501: PUSH
67502: LD_EXP 64
67506: PPUSH
67507: LD_VAR 0 2
67511: PPUSH
67512: EMPTY
67513: PPUSH
67514: CALL_OW 1
67518: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
67519: LD_VAR 0 2
67523: PPUSH
67524: LD_INT 103
67526: PPUSH
67527: CALL 61369 0 2
// continue ;
67531: GO 67442
// end ; if mc_construct_list [ i ] then
67533: LD_EXP 65
67537: PUSH
67538: LD_VAR 0 2
67542: ARRAY
67543: IFFALSE 67763
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67545: LD_ADDR_VAR 0 4
67549: PUSH
67550: LD_EXP 58
67554: PUSH
67555: LD_VAR 0 2
67559: ARRAY
67560: PPUSH
67561: LD_INT 25
67563: PUSH
67564: LD_INT 2
67566: PUSH
67567: EMPTY
67568: LIST
67569: LIST
67570: PPUSH
67571: CALL_OW 72
67575: PUSH
67576: LD_EXP 60
67580: PUSH
67581: LD_VAR 0 2
67585: ARRAY
67586: DIFF
67587: ST_TO_ADDR
// if not tmp then
67588: LD_VAR 0 4
67592: NOT
67593: IFFALSE 67597
// continue ;
67595: GO 67442
// for j in tmp do
67597: LD_ADDR_VAR 0 3
67601: PUSH
67602: LD_VAR 0 4
67606: PUSH
67607: FOR_IN
67608: IFFALSE 67759
// begin if not mc_builders [ i ] then
67610: LD_EXP 64
67614: PUSH
67615: LD_VAR 0 2
67619: ARRAY
67620: NOT
67621: IFFALSE 67679
// begin SetTag ( j , 103 ) ;
67623: LD_VAR 0 3
67627: PPUSH
67628: LD_INT 103
67630: PPUSH
67631: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67635: LD_ADDR_EXP 64
67639: PUSH
67640: LD_EXP 64
67644: PPUSH
67645: LD_VAR 0 2
67649: PUSH
67650: LD_EXP 64
67654: PUSH
67655: LD_VAR 0 2
67659: ARRAY
67660: PUSH
67661: LD_INT 1
67663: PLUS
67664: PUSH
67665: EMPTY
67666: LIST
67667: LIST
67668: PPUSH
67669: LD_VAR 0 3
67673: PPUSH
67674: CALL 21366 0 3
67678: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67679: LD_VAR 0 3
67683: PPUSH
67684: CALL_OW 310
67688: IFFALSE 67699
// ComExitBuilding ( j ) ;
67690: LD_VAR 0 3
67694: PPUSH
67695: CALL_OW 122
// wait ( 3 ) ;
67699: LD_INT 3
67701: PPUSH
67702: CALL_OW 67
// if not mc_construct_list [ i ] then
67706: LD_EXP 65
67710: PUSH
67711: LD_VAR 0 2
67715: ARRAY
67716: NOT
67717: IFFALSE 67721
// break ;
67719: GO 67759
// if not HasTask ( j ) then
67721: LD_VAR 0 3
67725: PPUSH
67726: CALL_OW 314
67730: NOT
67731: IFFALSE 67757
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
67733: LD_VAR 0 3
67737: PPUSH
67738: LD_EXP 65
67742: PUSH
67743: LD_VAR 0 2
67747: ARRAY
67748: PUSH
67749: LD_INT 1
67751: ARRAY
67752: PPUSH
67753: CALL 24217 0 2
// end ;
67757: GO 67607
67759: POP
67760: POP
// end else
67761: GO 68566
// if mc_build_list [ i ] then
67763: LD_EXP 63
67767: PUSH
67768: LD_VAR 0 2
67772: ARRAY
67773: IFFALSE 68566
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67775: LD_ADDR_VAR 0 5
67779: PUSH
67780: LD_EXP 58
67784: PUSH
67785: LD_VAR 0 2
67789: ARRAY
67790: PPUSH
67791: LD_INT 2
67793: PUSH
67794: LD_INT 30
67796: PUSH
67797: LD_INT 0
67799: PUSH
67800: EMPTY
67801: LIST
67802: LIST
67803: PUSH
67804: LD_INT 30
67806: PUSH
67807: LD_INT 1
67809: PUSH
67810: EMPTY
67811: LIST
67812: LIST
67813: PUSH
67814: EMPTY
67815: LIST
67816: LIST
67817: LIST
67818: PPUSH
67819: CALL_OW 72
67823: ST_TO_ADDR
// if depot then
67824: LD_VAR 0 5
67828: IFFALSE 67846
// depot := depot [ 1 ] else
67830: LD_ADDR_VAR 0 5
67834: PUSH
67835: LD_VAR 0 5
67839: PUSH
67840: LD_INT 1
67842: ARRAY
67843: ST_TO_ADDR
67844: GO 67854
// depot := 0 ;
67846: LD_ADDR_VAR 0 5
67850: PUSH
67851: LD_INT 0
67853: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
67854: LD_EXP 63
67858: PUSH
67859: LD_VAR 0 2
67863: ARRAY
67864: PUSH
67865: LD_INT 1
67867: ARRAY
67868: PUSH
67869: LD_INT 1
67871: ARRAY
67872: PPUSH
67873: CALL 24047 0 1
67877: PUSH
67878: LD_EXP 58
67882: PUSH
67883: LD_VAR 0 2
67887: ARRAY
67888: PPUSH
67889: LD_INT 2
67891: PUSH
67892: LD_INT 30
67894: PUSH
67895: LD_INT 2
67897: PUSH
67898: EMPTY
67899: LIST
67900: LIST
67901: PUSH
67902: LD_INT 30
67904: PUSH
67905: LD_INT 3
67907: PUSH
67908: EMPTY
67909: LIST
67910: LIST
67911: PUSH
67912: EMPTY
67913: LIST
67914: LIST
67915: LIST
67916: PPUSH
67917: CALL_OW 72
67921: NOT
67922: AND
67923: IFFALSE 68028
// begin for j = 1 to mc_build_list [ i ] do
67925: LD_ADDR_VAR 0 3
67929: PUSH
67930: DOUBLE
67931: LD_INT 1
67933: DEC
67934: ST_TO_ADDR
67935: LD_EXP 63
67939: PUSH
67940: LD_VAR 0 2
67944: ARRAY
67945: PUSH
67946: FOR_TO
67947: IFFALSE 68026
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
67949: LD_EXP 63
67953: PUSH
67954: LD_VAR 0 2
67958: ARRAY
67959: PUSH
67960: LD_VAR 0 3
67964: ARRAY
67965: PUSH
67966: LD_INT 1
67968: ARRAY
67969: PUSH
67970: LD_INT 2
67972: EQUAL
67973: IFFALSE 68024
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
67975: LD_ADDR_EXP 63
67979: PUSH
67980: LD_EXP 63
67984: PPUSH
67985: LD_VAR 0 2
67989: PPUSH
67990: LD_EXP 63
67994: PUSH
67995: LD_VAR 0 2
67999: ARRAY
68000: PPUSH
68001: LD_VAR 0 3
68005: PPUSH
68006: LD_INT 1
68008: PPUSH
68009: LD_INT 0
68011: PPUSH
68012: CALL 20784 0 4
68016: PPUSH
68017: CALL_OW 1
68021: ST_TO_ADDR
// break ;
68022: GO 68026
// end ;
68024: GO 67946
68026: POP
68027: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
68028: LD_EXP 63
68032: PUSH
68033: LD_VAR 0 2
68037: ARRAY
68038: PUSH
68039: LD_INT 1
68041: ARRAY
68042: PUSH
68043: LD_INT 1
68045: ARRAY
68046: PUSH
68047: LD_INT 0
68049: EQUAL
68050: PUSH
68051: LD_VAR 0 5
68055: PUSH
68056: LD_VAR 0 5
68060: PPUSH
68061: LD_EXP 63
68065: PUSH
68066: LD_VAR 0 2
68070: ARRAY
68071: PUSH
68072: LD_INT 1
68074: ARRAY
68075: PUSH
68076: LD_INT 1
68078: ARRAY
68079: PPUSH
68080: LD_EXP 63
68084: PUSH
68085: LD_VAR 0 2
68089: ARRAY
68090: PUSH
68091: LD_INT 1
68093: ARRAY
68094: PUSH
68095: LD_INT 2
68097: ARRAY
68098: PPUSH
68099: LD_EXP 63
68103: PUSH
68104: LD_VAR 0 2
68108: ARRAY
68109: PUSH
68110: LD_INT 1
68112: ARRAY
68113: PUSH
68114: LD_INT 3
68116: ARRAY
68117: PPUSH
68118: LD_EXP 63
68122: PUSH
68123: LD_VAR 0 2
68127: ARRAY
68128: PUSH
68129: LD_INT 1
68131: ARRAY
68132: PUSH
68133: LD_INT 4
68135: ARRAY
68136: PPUSH
68137: CALL 28781 0 5
68141: AND
68142: OR
68143: IFFALSE 68424
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
68145: LD_ADDR_VAR 0 4
68149: PUSH
68150: LD_EXP 58
68154: PUSH
68155: LD_VAR 0 2
68159: ARRAY
68160: PPUSH
68161: LD_INT 25
68163: PUSH
68164: LD_INT 2
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: PPUSH
68171: CALL_OW 72
68175: PUSH
68176: LD_EXP 60
68180: PUSH
68181: LD_VAR 0 2
68185: ARRAY
68186: DIFF
68187: ST_TO_ADDR
// if not tmp then
68188: LD_VAR 0 4
68192: NOT
68193: IFFALSE 68197
// continue ;
68195: GO 67442
// for j in tmp do
68197: LD_ADDR_VAR 0 3
68201: PUSH
68202: LD_VAR 0 4
68206: PUSH
68207: FOR_IN
68208: IFFALSE 68420
// begin if not mc_builders [ i ] then
68210: LD_EXP 64
68214: PUSH
68215: LD_VAR 0 2
68219: ARRAY
68220: NOT
68221: IFFALSE 68279
// begin SetTag ( j , 103 ) ;
68223: LD_VAR 0 3
68227: PPUSH
68228: LD_INT 103
68230: PPUSH
68231: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
68235: LD_ADDR_EXP 64
68239: PUSH
68240: LD_EXP 64
68244: PPUSH
68245: LD_VAR 0 2
68249: PUSH
68250: LD_EXP 64
68254: PUSH
68255: LD_VAR 0 2
68259: ARRAY
68260: PUSH
68261: LD_INT 1
68263: PLUS
68264: PUSH
68265: EMPTY
68266: LIST
68267: LIST
68268: PPUSH
68269: LD_VAR 0 3
68273: PPUSH
68274: CALL 21366 0 3
68278: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
68279: LD_VAR 0 3
68283: PPUSH
68284: CALL_OW 310
68288: IFFALSE 68299
// ComExitBuilding ( j ) ;
68290: LD_VAR 0 3
68294: PPUSH
68295: CALL_OW 122
// wait ( 3 ) ;
68299: LD_INT 3
68301: PPUSH
68302: CALL_OW 67
// if not mc_build_list [ i ] then
68306: LD_EXP 63
68310: PUSH
68311: LD_VAR 0 2
68315: ARRAY
68316: NOT
68317: IFFALSE 68321
// break ;
68319: GO 68420
// if not HasTask ( j ) then
68321: LD_VAR 0 3
68325: PPUSH
68326: CALL_OW 314
68330: NOT
68331: IFFALSE 68418
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
68333: LD_VAR 0 3
68337: PPUSH
68338: LD_EXP 63
68342: PUSH
68343: LD_VAR 0 2
68347: ARRAY
68348: PUSH
68349: LD_INT 1
68351: ARRAY
68352: PUSH
68353: LD_INT 1
68355: ARRAY
68356: PPUSH
68357: LD_EXP 63
68361: PUSH
68362: LD_VAR 0 2
68366: ARRAY
68367: PUSH
68368: LD_INT 1
68370: ARRAY
68371: PUSH
68372: LD_INT 2
68374: ARRAY
68375: PPUSH
68376: LD_EXP 63
68380: PUSH
68381: LD_VAR 0 2
68385: ARRAY
68386: PUSH
68387: LD_INT 1
68389: ARRAY
68390: PUSH
68391: LD_INT 3
68393: ARRAY
68394: PPUSH
68395: LD_EXP 63
68399: PUSH
68400: LD_VAR 0 2
68404: ARRAY
68405: PUSH
68406: LD_INT 1
68408: ARRAY
68409: PUSH
68410: LD_INT 4
68412: ARRAY
68413: PPUSH
68414: CALL_OW 145
// end ;
68418: GO 68207
68420: POP
68421: POP
// end else
68422: GO 68566
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
68424: LD_EXP 58
68428: PUSH
68429: LD_VAR 0 2
68433: ARRAY
68434: PPUSH
68435: LD_EXP 63
68439: PUSH
68440: LD_VAR 0 2
68444: ARRAY
68445: PUSH
68446: LD_INT 1
68448: ARRAY
68449: PUSH
68450: LD_INT 1
68452: ARRAY
68453: PPUSH
68454: LD_EXP 63
68458: PUSH
68459: LD_VAR 0 2
68463: ARRAY
68464: PUSH
68465: LD_INT 1
68467: ARRAY
68468: PUSH
68469: LD_INT 2
68471: ARRAY
68472: PPUSH
68473: LD_EXP 63
68477: PUSH
68478: LD_VAR 0 2
68482: ARRAY
68483: PUSH
68484: LD_INT 1
68486: ARRAY
68487: PUSH
68488: LD_INT 3
68490: ARRAY
68491: PPUSH
68492: LD_EXP 63
68496: PUSH
68497: LD_VAR 0 2
68501: ARRAY
68502: PUSH
68503: LD_INT 1
68505: ARRAY
68506: PUSH
68507: LD_INT 4
68509: ARRAY
68510: PPUSH
68511: CALL 28117 0 5
68515: NOT
68516: IFFALSE 68566
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
68518: LD_ADDR_EXP 63
68522: PUSH
68523: LD_EXP 63
68527: PPUSH
68528: LD_VAR 0 2
68532: PPUSH
68533: LD_EXP 63
68537: PUSH
68538: LD_VAR 0 2
68542: ARRAY
68543: PPUSH
68544: LD_INT 1
68546: PPUSH
68547: LD_INT 1
68549: NEG
68550: PPUSH
68551: LD_INT 0
68553: PPUSH
68554: CALL 20784 0 4
68558: PPUSH
68559: CALL_OW 1
68563: ST_TO_ADDR
// continue ;
68564: GO 67442
// end ; end ; end ;
68566: GO 67442
68568: POP
68569: POP
// end ;
68570: LD_VAR 0 1
68574: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
68575: LD_INT 0
68577: PPUSH
68578: PPUSH
68579: PPUSH
68580: PPUSH
68581: PPUSH
68582: PPUSH
// if not mc_bases then
68583: LD_EXP 58
68587: NOT
68588: IFFALSE 68592
// exit ;
68590: GO 69019
// for i = 1 to mc_bases do
68592: LD_ADDR_VAR 0 2
68596: PUSH
68597: DOUBLE
68598: LD_INT 1
68600: DEC
68601: ST_TO_ADDR
68602: LD_EXP 58
68606: PUSH
68607: FOR_TO
68608: IFFALSE 69017
// begin tmp := mc_build_upgrade [ i ] ;
68610: LD_ADDR_VAR 0 4
68614: PUSH
68615: LD_EXP 90
68619: PUSH
68620: LD_VAR 0 2
68624: ARRAY
68625: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
68626: LD_ADDR_VAR 0 6
68630: PUSH
68631: LD_EXP 91
68635: PUSH
68636: LD_VAR 0 2
68640: ARRAY
68641: PPUSH
68642: LD_INT 2
68644: PUSH
68645: LD_INT 30
68647: PUSH
68648: LD_INT 6
68650: PUSH
68651: EMPTY
68652: LIST
68653: LIST
68654: PUSH
68655: LD_INT 30
68657: PUSH
68658: LD_INT 7
68660: PUSH
68661: EMPTY
68662: LIST
68663: LIST
68664: PUSH
68665: EMPTY
68666: LIST
68667: LIST
68668: LIST
68669: PPUSH
68670: CALL_OW 72
68674: ST_TO_ADDR
// if not tmp and not lab then
68675: LD_VAR 0 4
68679: NOT
68680: PUSH
68681: LD_VAR 0 6
68685: NOT
68686: AND
68687: IFFALSE 68691
// continue ;
68689: GO 68607
// if tmp then
68691: LD_VAR 0 4
68695: IFFALSE 68815
// for j in tmp do
68697: LD_ADDR_VAR 0 3
68701: PUSH
68702: LD_VAR 0 4
68706: PUSH
68707: FOR_IN
68708: IFFALSE 68813
// begin if UpgradeCost ( j ) then
68710: LD_VAR 0 3
68714: PPUSH
68715: CALL 27777 0 1
68719: IFFALSE 68811
// begin ComUpgrade ( j ) ;
68721: LD_VAR 0 3
68725: PPUSH
68726: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
68730: LD_ADDR_EXP 90
68734: PUSH
68735: LD_EXP 90
68739: PPUSH
68740: LD_VAR 0 2
68744: PPUSH
68745: LD_EXP 90
68749: PUSH
68750: LD_VAR 0 2
68754: ARRAY
68755: PUSH
68756: LD_VAR 0 3
68760: DIFF
68761: PPUSH
68762: CALL_OW 1
68766: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68767: LD_ADDR_EXP 65
68771: PUSH
68772: LD_EXP 65
68776: PPUSH
68777: LD_VAR 0 2
68781: PUSH
68782: LD_EXP 65
68786: PUSH
68787: LD_VAR 0 2
68791: ARRAY
68792: PUSH
68793: LD_INT 1
68795: PLUS
68796: PUSH
68797: EMPTY
68798: LIST
68799: LIST
68800: PPUSH
68801: LD_VAR 0 3
68805: PPUSH
68806: CALL 21366 0 3
68810: ST_TO_ADDR
// end ; end ;
68811: GO 68707
68813: POP
68814: POP
// if not lab or not mc_lab_upgrade [ i ] then
68815: LD_VAR 0 6
68819: NOT
68820: PUSH
68821: LD_EXP 92
68825: PUSH
68826: LD_VAR 0 2
68830: ARRAY
68831: NOT
68832: OR
68833: IFFALSE 68837
// continue ;
68835: GO 68607
// for j in lab do
68837: LD_ADDR_VAR 0 3
68841: PUSH
68842: LD_VAR 0 6
68846: PUSH
68847: FOR_IN
68848: IFFALSE 69013
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
68850: LD_VAR 0 3
68854: PPUSH
68855: CALL_OW 266
68859: PUSH
68860: LD_INT 6
68862: PUSH
68863: LD_INT 7
68865: PUSH
68866: EMPTY
68867: LIST
68868: LIST
68869: IN
68870: PUSH
68871: LD_VAR 0 3
68875: PPUSH
68876: CALL_OW 461
68880: PUSH
68881: LD_INT 1
68883: NONEQUAL
68884: AND
68885: IFFALSE 69011
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
68887: LD_VAR 0 3
68891: PPUSH
68892: LD_EXP 92
68896: PUSH
68897: LD_VAR 0 2
68901: ARRAY
68902: PUSH
68903: LD_INT 1
68905: ARRAY
68906: PPUSH
68907: CALL 27982 0 2
68911: IFFALSE 69011
// begin ComCancel ( j ) ;
68913: LD_VAR 0 3
68917: PPUSH
68918: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
68922: LD_VAR 0 3
68926: PPUSH
68927: LD_EXP 92
68931: PUSH
68932: LD_VAR 0 2
68936: ARRAY
68937: PUSH
68938: LD_INT 1
68940: ARRAY
68941: PPUSH
68942: CALL_OW 207
// if not j in mc_construct_list [ i ] then
68946: LD_VAR 0 3
68950: PUSH
68951: LD_EXP 65
68955: PUSH
68956: LD_VAR 0 2
68960: ARRAY
68961: IN
68962: NOT
68963: IFFALSE 69009
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68965: LD_ADDR_EXP 65
68969: PUSH
68970: LD_EXP 65
68974: PPUSH
68975: LD_VAR 0 2
68979: PUSH
68980: LD_EXP 65
68984: PUSH
68985: LD_VAR 0 2
68989: ARRAY
68990: PUSH
68991: LD_INT 1
68993: PLUS
68994: PUSH
68995: EMPTY
68996: LIST
68997: LIST
68998: PPUSH
68999: LD_VAR 0 3
69003: PPUSH
69004: CALL 21366 0 3
69008: ST_TO_ADDR
// break ;
69009: GO 69013
// end ; end ; end ;
69011: GO 68847
69013: POP
69014: POP
// end ;
69015: GO 68607
69017: POP
69018: POP
// end ;
69019: LD_VAR 0 1
69023: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
69024: LD_INT 0
69026: PPUSH
69027: PPUSH
69028: PPUSH
69029: PPUSH
69030: PPUSH
69031: PPUSH
69032: PPUSH
69033: PPUSH
69034: PPUSH
// if not mc_bases then
69035: LD_EXP 58
69039: NOT
69040: IFFALSE 69044
// exit ;
69042: GO 69449
// for i = 1 to mc_bases do
69044: LD_ADDR_VAR 0 2
69048: PUSH
69049: DOUBLE
69050: LD_INT 1
69052: DEC
69053: ST_TO_ADDR
69054: LD_EXP 58
69058: PUSH
69059: FOR_TO
69060: IFFALSE 69447
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
69062: LD_EXP 66
69066: PUSH
69067: LD_VAR 0 2
69071: ARRAY
69072: NOT
69073: PUSH
69074: LD_EXP 58
69078: PUSH
69079: LD_VAR 0 2
69083: ARRAY
69084: PPUSH
69085: LD_INT 30
69087: PUSH
69088: LD_INT 3
69090: PUSH
69091: EMPTY
69092: LIST
69093: LIST
69094: PPUSH
69095: CALL_OW 72
69099: NOT
69100: OR
69101: IFFALSE 69105
// continue ;
69103: GO 69059
// busy := false ;
69105: LD_ADDR_VAR 0 8
69109: PUSH
69110: LD_INT 0
69112: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69113: LD_ADDR_VAR 0 4
69117: PUSH
69118: LD_EXP 58
69122: PUSH
69123: LD_VAR 0 2
69127: ARRAY
69128: PPUSH
69129: LD_INT 30
69131: PUSH
69132: LD_INT 3
69134: PUSH
69135: EMPTY
69136: LIST
69137: LIST
69138: PPUSH
69139: CALL_OW 72
69143: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
69144: LD_ADDR_VAR 0 6
69148: PUSH
69149: LD_EXP 66
69153: PUSH
69154: LD_VAR 0 2
69158: ARRAY
69159: PPUSH
69160: LD_INT 2
69162: PUSH
69163: LD_INT 30
69165: PUSH
69166: LD_INT 32
69168: PUSH
69169: EMPTY
69170: LIST
69171: LIST
69172: PUSH
69173: LD_INT 30
69175: PUSH
69176: LD_INT 33
69178: PUSH
69179: EMPTY
69180: LIST
69181: LIST
69182: PUSH
69183: EMPTY
69184: LIST
69185: LIST
69186: LIST
69187: PPUSH
69188: CALL_OW 72
69192: ST_TO_ADDR
// if not t then
69193: LD_VAR 0 6
69197: NOT
69198: IFFALSE 69202
// continue ;
69200: GO 69059
// for j in tmp do
69202: LD_ADDR_VAR 0 3
69206: PUSH
69207: LD_VAR 0 4
69211: PUSH
69212: FOR_IN
69213: IFFALSE 69243
// if not BuildingStatus ( j ) = bs_idle then
69215: LD_VAR 0 3
69219: PPUSH
69220: CALL_OW 461
69224: PUSH
69225: LD_INT 2
69227: EQUAL
69228: NOT
69229: IFFALSE 69241
// begin busy := true ;
69231: LD_ADDR_VAR 0 8
69235: PUSH
69236: LD_INT 1
69238: ST_TO_ADDR
// break ;
69239: GO 69243
// end ;
69241: GO 69212
69243: POP
69244: POP
// if busy then
69245: LD_VAR 0 8
69249: IFFALSE 69253
// continue ;
69251: GO 69059
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
69253: LD_ADDR_VAR 0 7
69257: PUSH
69258: LD_VAR 0 6
69262: PPUSH
69263: LD_INT 35
69265: PUSH
69266: LD_INT 0
69268: PUSH
69269: EMPTY
69270: LIST
69271: LIST
69272: PPUSH
69273: CALL_OW 72
69277: ST_TO_ADDR
// if tw then
69278: LD_VAR 0 7
69282: IFFALSE 69359
// begin tw := tw [ 1 ] ;
69284: LD_ADDR_VAR 0 7
69288: PUSH
69289: LD_VAR 0 7
69293: PUSH
69294: LD_INT 1
69296: ARRAY
69297: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
69298: LD_ADDR_VAR 0 9
69302: PUSH
69303: LD_VAR 0 7
69307: PPUSH
69308: LD_EXP 83
69312: PUSH
69313: LD_VAR 0 2
69317: ARRAY
69318: PPUSH
69319: CALL 26336 0 2
69323: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
69324: LD_EXP 97
69328: PUSH
69329: LD_VAR 0 2
69333: ARRAY
69334: IFFALSE 69357
// if not weapon in mc_allowed_tower_weapons [ i ] then
69336: LD_VAR 0 9
69340: PUSH
69341: LD_EXP 97
69345: PUSH
69346: LD_VAR 0 2
69350: ARRAY
69351: IN
69352: NOT
69353: IFFALSE 69357
// continue ;
69355: GO 69059
// end else
69357: GO 69422
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
69359: LD_ADDR_VAR 0 5
69363: PUSH
69364: LD_EXP 66
69368: PUSH
69369: LD_VAR 0 2
69373: ARRAY
69374: PPUSH
69375: LD_VAR 0 4
69379: PPUSH
69380: CALL 56537 0 2
69384: ST_TO_ADDR
// if not tmp2 then
69385: LD_VAR 0 5
69389: NOT
69390: IFFALSE 69394
// continue ;
69392: GO 69059
// tw := tmp2 [ 1 ] ;
69394: LD_ADDR_VAR 0 7
69398: PUSH
69399: LD_VAR 0 5
69403: PUSH
69404: LD_INT 1
69406: ARRAY
69407: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
69408: LD_ADDR_VAR 0 9
69412: PUSH
69413: LD_VAR 0 5
69417: PUSH
69418: LD_INT 2
69420: ARRAY
69421: ST_TO_ADDR
// end ; if not weapon then
69422: LD_VAR 0 9
69426: NOT
69427: IFFALSE 69431
// continue ;
69429: GO 69059
// ComPlaceWeapon ( tw , weapon ) ;
69431: LD_VAR 0 7
69435: PPUSH
69436: LD_VAR 0 9
69440: PPUSH
69441: CALL_OW 148
// end ;
69445: GO 69059
69447: POP
69448: POP
// end ;
69449: LD_VAR 0 1
69453: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
69454: LD_INT 0
69456: PPUSH
69457: PPUSH
69458: PPUSH
69459: PPUSH
69460: PPUSH
69461: PPUSH
// if not mc_bases then
69462: LD_EXP 58
69466: NOT
69467: IFFALSE 69471
// exit ;
69469: GO 70483
// for i = 1 to mc_bases do
69471: LD_ADDR_VAR 0 2
69475: PUSH
69476: DOUBLE
69477: LD_INT 1
69479: DEC
69480: ST_TO_ADDR
69481: LD_EXP 58
69485: PUSH
69486: FOR_TO
69487: IFFALSE 70481
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
69489: LD_EXP 71
69493: PUSH
69494: LD_VAR 0 2
69498: ARRAY
69499: NOT
69500: PUSH
69501: LD_EXP 71
69505: PUSH
69506: LD_VAR 0 2
69510: ARRAY
69511: PUSH
69512: LD_EXP 72
69516: PUSH
69517: LD_VAR 0 2
69521: ARRAY
69522: EQUAL
69523: OR
69524: IFFALSE 69528
// continue ;
69526: GO 69486
// if mc_miners [ i ] then
69528: LD_EXP 72
69532: PUSH
69533: LD_VAR 0 2
69537: ARRAY
69538: IFFALSE 70168
// begin k := 1 ;
69540: LD_ADDR_VAR 0 4
69544: PUSH
69545: LD_INT 1
69547: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
69548: LD_ADDR_VAR 0 3
69552: PUSH
69553: DOUBLE
69554: LD_EXP 72
69558: PUSH
69559: LD_VAR 0 2
69563: ARRAY
69564: INC
69565: ST_TO_ADDR
69566: LD_INT 1
69568: PUSH
69569: FOR_DOWNTO
69570: IFFALSE 70166
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
69572: LD_EXP 72
69576: PUSH
69577: LD_VAR 0 2
69581: ARRAY
69582: PUSH
69583: LD_VAR 0 3
69587: ARRAY
69588: PPUSH
69589: CALL_OW 301
69593: PUSH
69594: LD_EXP 72
69598: PUSH
69599: LD_VAR 0 2
69603: ARRAY
69604: PUSH
69605: LD_VAR 0 3
69609: ARRAY
69610: PPUSH
69611: CALL_OW 257
69615: PUSH
69616: LD_INT 1
69618: NONEQUAL
69619: OR
69620: IFFALSE 69683
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
69622: LD_ADDR_VAR 0 5
69626: PUSH
69627: LD_EXP 72
69631: PUSH
69632: LD_VAR 0 2
69636: ARRAY
69637: PUSH
69638: LD_EXP 72
69642: PUSH
69643: LD_VAR 0 2
69647: ARRAY
69648: PUSH
69649: LD_VAR 0 3
69653: ARRAY
69654: DIFF
69655: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
69656: LD_ADDR_EXP 72
69660: PUSH
69661: LD_EXP 72
69665: PPUSH
69666: LD_VAR 0 2
69670: PPUSH
69671: LD_VAR 0 5
69675: PPUSH
69676: CALL_OW 1
69680: ST_TO_ADDR
// continue ;
69681: GO 69569
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
69683: LD_EXP 72
69687: PUSH
69688: LD_VAR 0 2
69692: ARRAY
69693: PUSH
69694: LD_VAR 0 3
69698: ARRAY
69699: PPUSH
69700: CALL 21302 0 1
69704: PUSH
69705: LD_EXP 72
69709: PUSH
69710: LD_VAR 0 2
69714: ARRAY
69715: PUSH
69716: LD_VAR 0 3
69720: ARRAY
69721: PPUSH
69722: CALL_OW 255
69726: PPUSH
69727: LD_EXP 71
69731: PUSH
69732: LD_VAR 0 2
69736: ARRAY
69737: PUSH
69738: LD_VAR 0 4
69742: ARRAY
69743: PUSH
69744: LD_INT 1
69746: ARRAY
69747: PPUSH
69748: LD_EXP 71
69752: PUSH
69753: LD_VAR 0 2
69757: ARRAY
69758: PUSH
69759: LD_VAR 0 4
69763: ARRAY
69764: PUSH
69765: LD_INT 2
69767: ARRAY
69768: PPUSH
69769: LD_INT 15
69771: PPUSH
69772: CALL 22262 0 4
69776: PUSH
69777: LD_INT 4
69779: ARRAY
69780: PUSH
69781: LD_EXP 72
69785: PUSH
69786: LD_VAR 0 2
69790: ARRAY
69791: PUSH
69792: LD_VAR 0 3
69796: ARRAY
69797: PPUSH
69798: LD_INT 10
69800: PPUSH
69801: CALL 23959 0 2
69805: PUSH
69806: LD_INT 4
69808: ARRAY
69809: OR
69810: AND
69811: IFFALSE 69834
// ComStop ( mc_miners [ i ] [ j ] ) ;
69813: LD_EXP 72
69817: PUSH
69818: LD_VAR 0 2
69822: ARRAY
69823: PUSH
69824: LD_VAR 0 3
69828: ARRAY
69829: PPUSH
69830: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
69834: LD_EXP 72
69838: PUSH
69839: LD_VAR 0 2
69843: ARRAY
69844: PUSH
69845: LD_VAR 0 3
69849: ARRAY
69850: PPUSH
69851: CALL_OW 257
69855: PUSH
69856: LD_INT 1
69858: EQUAL
69859: PUSH
69860: LD_EXP 72
69864: PUSH
69865: LD_VAR 0 2
69869: ARRAY
69870: PUSH
69871: LD_VAR 0 3
69875: ARRAY
69876: PPUSH
69877: CALL_OW 459
69881: NOT
69882: AND
69883: PUSH
69884: LD_EXP 72
69888: PUSH
69889: LD_VAR 0 2
69893: ARRAY
69894: PUSH
69895: LD_VAR 0 3
69899: ARRAY
69900: PPUSH
69901: CALL_OW 255
69905: PPUSH
69906: LD_EXP 71
69910: PUSH
69911: LD_VAR 0 2
69915: ARRAY
69916: PUSH
69917: LD_VAR 0 4
69921: ARRAY
69922: PUSH
69923: LD_INT 1
69925: ARRAY
69926: PPUSH
69927: LD_EXP 71
69931: PUSH
69932: LD_VAR 0 2
69936: ARRAY
69937: PUSH
69938: LD_VAR 0 4
69942: ARRAY
69943: PUSH
69944: LD_INT 2
69946: ARRAY
69947: PPUSH
69948: LD_INT 15
69950: PPUSH
69951: CALL 22262 0 4
69955: PUSH
69956: LD_INT 4
69958: ARRAY
69959: PUSH
69960: LD_INT 0
69962: EQUAL
69963: AND
69964: PUSH
69965: LD_EXP 72
69969: PUSH
69970: LD_VAR 0 2
69974: ARRAY
69975: PUSH
69976: LD_VAR 0 3
69980: ARRAY
69981: PPUSH
69982: CALL_OW 314
69986: NOT
69987: AND
69988: IFFALSE 70164
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
69990: LD_EXP 72
69994: PUSH
69995: LD_VAR 0 2
69999: ARRAY
70000: PUSH
70001: LD_VAR 0 3
70005: ARRAY
70006: PPUSH
70007: CALL_OW 310
70011: IFFALSE 70034
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
70013: LD_EXP 72
70017: PUSH
70018: LD_VAR 0 2
70022: ARRAY
70023: PUSH
70024: LD_VAR 0 3
70028: ARRAY
70029: PPUSH
70030: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
70034: LD_EXP 72
70038: PUSH
70039: LD_VAR 0 2
70043: ARRAY
70044: PUSH
70045: LD_VAR 0 3
70049: ARRAY
70050: PPUSH
70051: CALL_OW 314
70055: NOT
70056: IFFALSE 70124
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
70058: LD_EXP 72
70062: PUSH
70063: LD_VAR 0 2
70067: ARRAY
70068: PUSH
70069: LD_VAR 0 3
70073: ARRAY
70074: PPUSH
70075: LD_EXP 71
70079: PUSH
70080: LD_VAR 0 2
70084: ARRAY
70085: PUSH
70086: LD_VAR 0 4
70090: ARRAY
70091: PUSH
70092: LD_INT 1
70094: ARRAY
70095: PPUSH
70096: LD_EXP 71
70100: PUSH
70101: LD_VAR 0 2
70105: ARRAY
70106: PUSH
70107: LD_VAR 0 4
70111: ARRAY
70112: PUSH
70113: LD_INT 2
70115: ARRAY
70116: PPUSH
70117: LD_INT 0
70119: PPUSH
70120: CALL_OW 193
// k := k + 1 ;
70124: LD_ADDR_VAR 0 4
70128: PUSH
70129: LD_VAR 0 4
70133: PUSH
70134: LD_INT 1
70136: PLUS
70137: ST_TO_ADDR
// if k > mc_mines [ i ] then
70138: LD_VAR 0 4
70142: PUSH
70143: LD_EXP 71
70147: PUSH
70148: LD_VAR 0 2
70152: ARRAY
70153: GREATER
70154: IFFALSE 70164
// k := 1 ;
70156: LD_ADDR_VAR 0 4
70160: PUSH
70161: LD_INT 1
70163: ST_TO_ADDR
// end ; end ;
70164: GO 69569
70166: POP
70167: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
70168: LD_ADDR_VAR 0 5
70172: PUSH
70173: LD_EXP 58
70177: PUSH
70178: LD_VAR 0 2
70182: ARRAY
70183: PPUSH
70184: LD_INT 2
70186: PUSH
70187: LD_INT 30
70189: PUSH
70190: LD_INT 4
70192: PUSH
70193: EMPTY
70194: LIST
70195: LIST
70196: PUSH
70197: LD_INT 30
70199: PUSH
70200: LD_INT 5
70202: PUSH
70203: EMPTY
70204: LIST
70205: LIST
70206: PUSH
70207: LD_INT 30
70209: PUSH
70210: LD_INT 32
70212: PUSH
70213: EMPTY
70214: LIST
70215: LIST
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: LIST
70221: LIST
70222: PPUSH
70223: CALL_OW 72
70227: ST_TO_ADDR
// if not tmp then
70228: LD_VAR 0 5
70232: NOT
70233: IFFALSE 70237
// continue ;
70235: GO 69486
// list := [ ] ;
70237: LD_ADDR_VAR 0 6
70241: PUSH
70242: EMPTY
70243: ST_TO_ADDR
// for j in tmp do
70244: LD_ADDR_VAR 0 3
70248: PUSH
70249: LD_VAR 0 5
70253: PUSH
70254: FOR_IN
70255: IFFALSE 70324
// begin for k in UnitsInside ( j ) do
70257: LD_ADDR_VAR 0 4
70261: PUSH
70262: LD_VAR 0 3
70266: PPUSH
70267: CALL_OW 313
70271: PUSH
70272: FOR_IN
70273: IFFALSE 70320
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
70275: LD_VAR 0 4
70279: PPUSH
70280: CALL_OW 257
70284: PUSH
70285: LD_INT 1
70287: EQUAL
70288: PUSH
70289: LD_VAR 0 4
70293: PPUSH
70294: CALL_OW 459
70298: NOT
70299: AND
70300: IFFALSE 70318
// list := list ^ k ;
70302: LD_ADDR_VAR 0 6
70306: PUSH
70307: LD_VAR 0 6
70311: PUSH
70312: LD_VAR 0 4
70316: ADD
70317: ST_TO_ADDR
70318: GO 70272
70320: POP
70321: POP
// end ;
70322: GO 70254
70324: POP
70325: POP
// list := list diff mc_miners [ i ] ;
70326: LD_ADDR_VAR 0 6
70330: PUSH
70331: LD_VAR 0 6
70335: PUSH
70336: LD_EXP 72
70340: PUSH
70341: LD_VAR 0 2
70345: ARRAY
70346: DIFF
70347: ST_TO_ADDR
// if not list then
70348: LD_VAR 0 6
70352: NOT
70353: IFFALSE 70357
// continue ;
70355: GO 69486
// k := mc_mines [ i ] - mc_miners [ i ] ;
70357: LD_ADDR_VAR 0 4
70361: PUSH
70362: LD_EXP 71
70366: PUSH
70367: LD_VAR 0 2
70371: ARRAY
70372: PUSH
70373: LD_EXP 72
70377: PUSH
70378: LD_VAR 0 2
70382: ARRAY
70383: MINUS
70384: ST_TO_ADDR
// if k > list then
70385: LD_VAR 0 4
70389: PUSH
70390: LD_VAR 0 6
70394: GREATER
70395: IFFALSE 70407
// k := list ;
70397: LD_ADDR_VAR 0 4
70401: PUSH
70402: LD_VAR 0 6
70406: ST_TO_ADDR
// for j = 1 to k do
70407: LD_ADDR_VAR 0 3
70411: PUSH
70412: DOUBLE
70413: LD_INT 1
70415: DEC
70416: ST_TO_ADDR
70417: LD_VAR 0 4
70421: PUSH
70422: FOR_TO
70423: IFFALSE 70477
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
70425: LD_ADDR_EXP 72
70429: PUSH
70430: LD_EXP 72
70434: PPUSH
70435: LD_VAR 0 2
70439: PUSH
70440: LD_EXP 72
70444: PUSH
70445: LD_VAR 0 2
70449: ARRAY
70450: PUSH
70451: LD_INT 1
70453: PLUS
70454: PUSH
70455: EMPTY
70456: LIST
70457: LIST
70458: PPUSH
70459: LD_VAR 0 6
70463: PUSH
70464: LD_VAR 0 3
70468: ARRAY
70469: PPUSH
70470: CALL 21366 0 3
70474: ST_TO_ADDR
70475: GO 70422
70477: POP
70478: POP
// end ;
70479: GO 69486
70481: POP
70482: POP
// end ;
70483: LD_VAR 0 1
70487: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
70488: LD_INT 0
70490: PPUSH
70491: PPUSH
70492: PPUSH
70493: PPUSH
70494: PPUSH
70495: PPUSH
70496: PPUSH
70497: PPUSH
70498: PPUSH
70499: PPUSH
// if not mc_bases then
70500: LD_EXP 58
70504: NOT
70505: IFFALSE 70509
// exit ;
70507: GO 72259
// for i = 1 to mc_bases do
70509: LD_ADDR_VAR 0 2
70513: PUSH
70514: DOUBLE
70515: LD_INT 1
70517: DEC
70518: ST_TO_ADDR
70519: LD_EXP 58
70523: PUSH
70524: FOR_TO
70525: IFFALSE 72257
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
70527: LD_EXP 58
70531: PUSH
70532: LD_VAR 0 2
70536: ARRAY
70537: NOT
70538: PUSH
70539: LD_EXP 65
70543: PUSH
70544: LD_VAR 0 2
70548: ARRAY
70549: OR
70550: IFFALSE 70554
// continue ;
70552: GO 70524
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
70554: LD_EXP 74
70558: PUSH
70559: LD_VAR 0 2
70563: ARRAY
70564: NOT
70565: PUSH
70566: LD_EXP 75
70570: PUSH
70571: LD_VAR 0 2
70575: ARRAY
70576: AND
70577: IFFALSE 70615
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
70579: LD_ADDR_EXP 75
70583: PUSH
70584: LD_EXP 75
70588: PPUSH
70589: LD_VAR 0 2
70593: PPUSH
70594: EMPTY
70595: PPUSH
70596: CALL_OW 1
70600: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
70601: LD_VAR 0 2
70605: PPUSH
70606: LD_INT 107
70608: PPUSH
70609: CALL 61369 0 2
// continue ;
70613: GO 70524
// end ; target := [ ] ;
70615: LD_ADDR_VAR 0 6
70619: PUSH
70620: EMPTY
70621: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
70622: LD_ADDR_VAR 0 3
70626: PUSH
70627: DOUBLE
70628: LD_EXP 74
70632: PUSH
70633: LD_VAR 0 2
70637: ARRAY
70638: INC
70639: ST_TO_ADDR
70640: LD_INT 1
70642: PUSH
70643: FOR_DOWNTO
70644: IFFALSE 70904
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
70646: LD_EXP 74
70650: PUSH
70651: LD_VAR 0 2
70655: ARRAY
70656: PUSH
70657: LD_VAR 0 3
70661: ARRAY
70662: PUSH
70663: LD_INT 2
70665: ARRAY
70666: PPUSH
70667: LD_EXP 74
70671: PUSH
70672: LD_VAR 0 2
70676: ARRAY
70677: PUSH
70678: LD_VAR 0 3
70682: ARRAY
70683: PUSH
70684: LD_INT 3
70686: ARRAY
70687: PPUSH
70688: CALL_OW 488
70692: PUSH
70693: LD_EXP 74
70697: PUSH
70698: LD_VAR 0 2
70702: ARRAY
70703: PUSH
70704: LD_VAR 0 3
70708: ARRAY
70709: PUSH
70710: LD_INT 2
70712: ARRAY
70713: PPUSH
70714: LD_EXP 74
70718: PUSH
70719: LD_VAR 0 2
70723: ARRAY
70724: PUSH
70725: LD_VAR 0 3
70729: ARRAY
70730: PUSH
70731: LD_INT 3
70733: ARRAY
70734: PPUSH
70735: CALL_OW 284
70739: PUSH
70740: LD_INT 0
70742: EQUAL
70743: AND
70744: IFFALSE 70799
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
70746: LD_ADDR_VAR 0 5
70750: PUSH
70751: LD_EXP 74
70755: PUSH
70756: LD_VAR 0 2
70760: ARRAY
70761: PPUSH
70762: LD_VAR 0 3
70766: PPUSH
70767: CALL_OW 3
70771: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
70772: LD_ADDR_EXP 74
70776: PUSH
70777: LD_EXP 74
70781: PPUSH
70782: LD_VAR 0 2
70786: PPUSH
70787: LD_VAR 0 5
70791: PPUSH
70792: CALL_OW 1
70796: ST_TO_ADDR
// continue ;
70797: GO 70643
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70799: LD_EXP 58
70803: PUSH
70804: LD_VAR 0 2
70808: ARRAY
70809: PUSH
70810: LD_INT 1
70812: ARRAY
70813: PPUSH
70814: CALL_OW 255
70818: PPUSH
70819: LD_EXP 74
70823: PUSH
70824: LD_VAR 0 2
70828: ARRAY
70829: PUSH
70830: LD_VAR 0 3
70834: ARRAY
70835: PUSH
70836: LD_INT 2
70838: ARRAY
70839: PPUSH
70840: LD_EXP 74
70844: PUSH
70845: LD_VAR 0 2
70849: ARRAY
70850: PUSH
70851: LD_VAR 0 3
70855: ARRAY
70856: PUSH
70857: LD_INT 3
70859: ARRAY
70860: PPUSH
70861: LD_INT 30
70863: PPUSH
70864: CALL 22262 0 4
70868: PUSH
70869: LD_INT 4
70871: ARRAY
70872: PUSH
70873: LD_INT 0
70875: EQUAL
70876: IFFALSE 70902
// begin target := mc_crates [ i ] [ j ] ;
70878: LD_ADDR_VAR 0 6
70882: PUSH
70883: LD_EXP 74
70887: PUSH
70888: LD_VAR 0 2
70892: ARRAY
70893: PUSH
70894: LD_VAR 0 3
70898: ARRAY
70899: ST_TO_ADDR
// break ;
70900: GO 70904
// end ; end ;
70902: GO 70643
70904: POP
70905: POP
// if not target then
70906: LD_VAR 0 6
70910: NOT
70911: IFFALSE 70915
// continue ;
70913: GO 70524
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
70915: LD_ADDR_VAR 0 7
70919: PUSH
70920: LD_EXP 77
70924: PUSH
70925: LD_VAR 0 2
70929: ARRAY
70930: PPUSH
70931: LD_INT 2
70933: PUSH
70934: LD_INT 3
70936: PUSH
70937: LD_INT 58
70939: PUSH
70940: EMPTY
70941: LIST
70942: PUSH
70943: EMPTY
70944: LIST
70945: LIST
70946: PUSH
70947: LD_INT 61
70949: PUSH
70950: EMPTY
70951: LIST
70952: PUSH
70953: LD_INT 33
70955: PUSH
70956: LD_INT 5
70958: PUSH
70959: EMPTY
70960: LIST
70961: LIST
70962: PUSH
70963: LD_INT 33
70965: PUSH
70966: LD_INT 3
70968: PUSH
70969: EMPTY
70970: LIST
70971: LIST
70972: PUSH
70973: EMPTY
70974: LIST
70975: LIST
70976: LIST
70977: LIST
70978: LIST
70979: PUSH
70980: LD_INT 2
70982: PUSH
70983: LD_INT 34
70985: PUSH
70986: LD_INT 32
70988: PUSH
70989: EMPTY
70990: LIST
70991: LIST
70992: PUSH
70993: LD_INT 34
70995: PUSH
70996: LD_INT 51
70998: PUSH
70999: EMPTY
71000: LIST
71001: LIST
71002: PUSH
71003: LD_INT 34
71005: PUSH
71006: LD_INT 12
71008: PUSH
71009: EMPTY
71010: LIST
71011: LIST
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: LIST
71017: LIST
71018: PUSH
71019: EMPTY
71020: LIST
71021: LIST
71022: PPUSH
71023: CALL_OW 72
71027: ST_TO_ADDR
// if not cargo then
71028: LD_VAR 0 7
71032: NOT
71033: IFFALSE 71676
// begin if mc_crates_collector [ i ] < 5 then
71035: LD_EXP 75
71039: PUSH
71040: LD_VAR 0 2
71044: ARRAY
71045: PUSH
71046: LD_INT 5
71048: LESS
71049: IFFALSE 71415
// begin if mc_ape [ i ] then
71051: LD_EXP 87
71055: PUSH
71056: LD_VAR 0 2
71060: ARRAY
71061: IFFALSE 71108
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
71063: LD_ADDR_VAR 0 5
71067: PUSH
71068: LD_EXP 87
71072: PUSH
71073: LD_VAR 0 2
71077: ARRAY
71078: PPUSH
71079: LD_INT 25
71081: PUSH
71082: LD_INT 16
71084: PUSH
71085: EMPTY
71086: LIST
71087: LIST
71088: PUSH
71089: LD_INT 24
71091: PUSH
71092: LD_INT 750
71094: PUSH
71095: EMPTY
71096: LIST
71097: LIST
71098: PUSH
71099: EMPTY
71100: LIST
71101: LIST
71102: PPUSH
71103: CALL_OW 72
71107: ST_TO_ADDR
// if not tmp then
71108: LD_VAR 0 5
71112: NOT
71113: IFFALSE 71160
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
71115: LD_ADDR_VAR 0 5
71119: PUSH
71120: LD_EXP 58
71124: PUSH
71125: LD_VAR 0 2
71129: ARRAY
71130: PPUSH
71131: LD_INT 25
71133: PUSH
71134: LD_INT 2
71136: PUSH
71137: EMPTY
71138: LIST
71139: LIST
71140: PUSH
71141: LD_INT 24
71143: PUSH
71144: LD_INT 750
71146: PUSH
71147: EMPTY
71148: LIST
71149: LIST
71150: PUSH
71151: EMPTY
71152: LIST
71153: LIST
71154: PPUSH
71155: CALL_OW 72
71159: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
71160: LD_EXP 87
71164: PUSH
71165: LD_VAR 0 2
71169: ARRAY
71170: PUSH
71171: LD_EXP 58
71175: PUSH
71176: LD_VAR 0 2
71180: ARRAY
71181: PPUSH
71182: LD_INT 25
71184: PUSH
71185: LD_INT 2
71187: PUSH
71188: EMPTY
71189: LIST
71190: LIST
71191: PUSH
71192: LD_INT 24
71194: PUSH
71195: LD_INT 750
71197: PUSH
71198: EMPTY
71199: LIST
71200: LIST
71201: PUSH
71202: EMPTY
71203: LIST
71204: LIST
71205: PPUSH
71206: CALL_OW 72
71210: AND
71211: PUSH
71212: LD_VAR 0 5
71216: PUSH
71217: LD_INT 5
71219: LESS
71220: AND
71221: IFFALSE 71303
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
71223: LD_ADDR_VAR 0 3
71227: PUSH
71228: LD_EXP 58
71232: PUSH
71233: LD_VAR 0 2
71237: ARRAY
71238: PPUSH
71239: LD_INT 25
71241: PUSH
71242: LD_INT 2
71244: PUSH
71245: EMPTY
71246: LIST
71247: LIST
71248: PUSH
71249: LD_INT 24
71251: PUSH
71252: LD_INT 750
71254: PUSH
71255: EMPTY
71256: LIST
71257: LIST
71258: PUSH
71259: EMPTY
71260: LIST
71261: LIST
71262: PPUSH
71263: CALL_OW 72
71267: PUSH
71268: FOR_IN
71269: IFFALSE 71301
// begin tmp := tmp union j ;
71271: LD_ADDR_VAR 0 5
71275: PUSH
71276: LD_VAR 0 5
71280: PUSH
71281: LD_VAR 0 3
71285: UNION
71286: ST_TO_ADDR
// if tmp >= 5 then
71287: LD_VAR 0 5
71291: PUSH
71292: LD_INT 5
71294: GREATEREQUAL
71295: IFFALSE 71299
// break ;
71297: GO 71301
// end ;
71299: GO 71268
71301: POP
71302: POP
// end ; if not tmp then
71303: LD_VAR 0 5
71307: NOT
71308: IFFALSE 71312
// continue ;
71310: GO 70524
// for j in tmp do
71312: LD_ADDR_VAR 0 3
71316: PUSH
71317: LD_VAR 0 5
71321: PUSH
71322: FOR_IN
71323: IFFALSE 71413
// if not GetTag ( j ) then
71325: LD_VAR 0 3
71329: PPUSH
71330: CALL_OW 110
71334: NOT
71335: IFFALSE 71411
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
71337: LD_ADDR_EXP 75
71341: PUSH
71342: LD_EXP 75
71346: PPUSH
71347: LD_VAR 0 2
71351: PUSH
71352: LD_EXP 75
71356: PUSH
71357: LD_VAR 0 2
71361: ARRAY
71362: PUSH
71363: LD_INT 1
71365: PLUS
71366: PUSH
71367: EMPTY
71368: LIST
71369: LIST
71370: PPUSH
71371: LD_VAR 0 3
71375: PPUSH
71376: CALL 21366 0 3
71380: ST_TO_ADDR
// SetTag ( j , 107 ) ;
71381: LD_VAR 0 3
71385: PPUSH
71386: LD_INT 107
71388: PPUSH
71389: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
71393: LD_EXP 75
71397: PUSH
71398: LD_VAR 0 2
71402: ARRAY
71403: PUSH
71404: LD_INT 5
71406: GREATEREQUAL
71407: IFFALSE 71411
// break ;
71409: GO 71413
// end ;
71411: GO 71322
71413: POP
71414: POP
// end ; if mc_crates_collector [ i ] and target then
71415: LD_EXP 75
71419: PUSH
71420: LD_VAR 0 2
71424: ARRAY
71425: PUSH
71426: LD_VAR 0 6
71430: AND
71431: IFFALSE 71674
// begin if mc_crates_collector [ i ] < target [ 1 ] then
71433: LD_EXP 75
71437: PUSH
71438: LD_VAR 0 2
71442: ARRAY
71443: PUSH
71444: LD_VAR 0 6
71448: PUSH
71449: LD_INT 1
71451: ARRAY
71452: LESS
71453: IFFALSE 71473
// tmp := mc_crates_collector [ i ] else
71455: LD_ADDR_VAR 0 5
71459: PUSH
71460: LD_EXP 75
71464: PUSH
71465: LD_VAR 0 2
71469: ARRAY
71470: ST_TO_ADDR
71471: GO 71487
// tmp := target [ 1 ] ;
71473: LD_ADDR_VAR 0 5
71477: PUSH
71478: LD_VAR 0 6
71482: PUSH
71483: LD_INT 1
71485: ARRAY
71486: ST_TO_ADDR
// k := 0 ;
71487: LD_ADDR_VAR 0 4
71491: PUSH
71492: LD_INT 0
71494: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
71495: LD_ADDR_VAR 0 3
71499: PUSH
71500: LD_EXP 75
71504: PUSH
71505: LD_VAR 0 2
71509: ARRAY
71510: PUSH
71511: FOR_IN
71512: IFFALSE 71672
// begin k := k + 1 ;
71514: LD_ADDR_VAR 0 4
71518: PUSH
71519: LD_VAR 0 4
71523: PUSH
71524: LD_INT 1
71526: PLUS
71527: ST_TO_ADDR
// if k > tmp then
71528: LD_VAR 0 4
71532: PUSH
71533: LD_VAR 0 5
71537: GREATER
71538: IFFALSE 71542
// break ;
71540: GO 71672
// if not GetClass ( j ) in [ 2 , 16 ] then
71542: LD_VAR 0 3
71546: PPUSH
71547: CALL_OW 257
71551: PUSH
71552: LD_INT 2
71554: PUSH
71555: LD_INT 16
71557: PUSH
71558: EMPTY
71559: LIST
71560: LIST
71561: IN
71562: NOT
71563: IFFALSE 71616
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
71565: LD_ADDR_EXP 75
71569: PUSH
71570: LD_EXP 75
71574: PPUSH
71575: LD_VAR 0 2
71579: PPUSH
71580: LD_EXP 75
71584: PUSH
71585: LD_VAR 0 2
71589: ARRAY
71590: PUSH
71591: LD_VAR 0 3
71595: DIFF
71596: PPUSH
71597: CALL_OW 1
71601: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71602: LD_VAR 0 3
71606: PPUSH
71607: LD_INT 0
71609: PPUSH
71610: CALL_OW 109
// continue ;
71614: GO 71511
// end ; if IsInUnit ( j ) then
71616: LD_VAR 0 3
71620: PPUSH
71621: CALL_OW 310
71625: IFFALSE 71636
// ComExitBuilding ( j ) ;
71627: LD_VAR 0 3
71631: PPUSH
71632: CALL_OW 122
// wait ( 3 ) ;
71636: LD_INT 3
71638: PPUSH
71639: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71643: LD_VAR 0 3
71647: PPUSH
71648: LD_VAR 0 6
71652: PUSH
71653: LD_INT 2
71655: ARRAY
71656: PPUSH
71657: LD_VAR 0 6
71661: PUSH
71662: LD_INT 3
71664: ARRAY
71665: PPUSH
71666: CALL_OW 117
// end ;
71670: GO 71511
71672: POP
71673: POP
// end ; end else
71674: GO 72255
// begin for j in cargo do
71676: LD_ADDR_VAR 0 3
71680: PUSH
71681: LD_VAR 0 7
71685: PUSH
71686: FOR_IN
71687: IFFALSE 72253
// begin if GetTag ( j ) <> 0 then
71689: LD_VAR 0 3
71693: PPUSH
71694: CALL_OW 110
71698: PUSH
71699: LD_INT 0
71701: NONEQUAL
71702: IFFALSE 71706
// continue ;
71704: GO 71686
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
71706: LD_VAR 0 3
71710: PPUSH
71711: CALL_OW 256
71715: PUSH
71716: LD_INT 1000
71718: LESS
71719: PUSH
71720: LD_VAR 0 3
71724: PPUSH
71725: LD_EXP 82
71729: PUSH
71730: LD_VAR 0 2
71734: ARRAY
71735: PPUSH
71736: CALL_OW 308
71740: NOT
71741: AND
71742: IFFALSE 71764
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71744: LD_VAR 0 3
71748: PPUSH
71749: LD_EXP 82
71753: PUSH
71754: LD_VAR 0 2
71758: ARRAY
71759: PPUSH
71760: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71764: LD_VAR 0 3
71768: PPUSH
71769: CALL_OW 256
71773: PUSH
71774: LD_INT 1000
71776: LESS
71777: PUSH
71778: LD_VAR 0 3
71782: PPUSH
71783: LD_EXP 82
71787: PUSH
71788: LD_VAR 0 2
71792: ARRAY
71793: PPUSH
71794: CALL_OW 308
71798: AND
71799: IFFALSE 71803
// continue ;
71801: GO 71686
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71803: LD_VAR 0 3
71807: PPUSH
71808: CALL_OW 262
71812: PUSH
71813: LD_INT 2
71815: EQUAL
71816: PUSH
71817: LD_VAR 0 3
71821: PPUSH
71822: CALL_OW 261
71826: PUSH
71827: LD_INT 15
71829: LESS
71830: AND
71831: IFFALSE 71835
// continue ;
71833: GO 71686
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71835: LD_VAR 0 3
71839: PPUSH
71840: CALL_OW 262
71844: PUSH
71845: LD_INT 1
71847: EQUAL
71848: PUSH
71849: LD_VAR 0 3
71853: PPUSH
71854: CALL_OW 261
71858: PUSH
71859: LD_INT 10
71861: LESS
71862: AND
71863: IFFALSE 72192
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71865: LD_ADDR_VAR 0 8
71869: PUSH
71870: LD_EXP 58
71874: PUSH
71875: LD_VAR 0 2
71879: ARRAY
71880: PPUSH
71881: LD_INT 2
71883: PUSH
71884: LD_INT 30
71886: PUSH
71887: LD_INT 0
71889: PUSH
71890: EMPTY
71891: LIST
71892: LIST
71893: PUSH
71894: LD_INT 30
71896: PUSH
71897: LD_INT 1
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: PUSH
71904: EMPTY
71905: LIST
71906: LIST
71907: LIST
71908: PPUSH
71909: CALL_OW 72
71913: ST_TO_ADDR
// if not depot then
71914: LD_VAR 0 8
71918: NOT
71919: IFFALSE 71923
// continue ;
71921: GO 71686
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
71923: LD_VAR 0 3
71927: PPUSH
71928: LD_VAR 0 8
71932: PPUSH
71933: LD_VAR 0 3
71937: PPUSH
71938: CALL_OW 74
71942: PPUSH
71943: CALL_OW 296
71947: PUSH
71948: LD_INT 6
71950: LESS
71951: IFFALSE 71967
// SetFuel ( j , 100 ) else
71953: LD_VAR 0 3
71957: PPUSH
71958: LD_INT 100
71960: PPUSH
71961: CALL_OW 240
71965: GO 72192
// if GetFuel ( j ) = 0 then
71967: LD_VAR 0 3
71971: PPUSH
71972: CALL_OW 261
71976: PUSH
71977: LD_INT 0
71979: EQUAL
71980: IFFALSE 72192
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
71982: LD_ADDR_EXP 77
71986: PUSH
71987: LD_EXP 77
71991: PPUSH
71992: LD_VAR 0 2
71996: PPUSH
71997: LD_EXP 77
72001: PUSH
72002: LD_VAR 0 2
72006: ARRAY
72007: PUSH
72008: LD_VAR 0 3
72012: DIFF
72013: PPUSH
72014: CALL_OW 1
72018: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
72019: LD_VAR 0 3
72023: PPUSH
72024: CALL_OW 263
72028: PUSH
72029: LD_INT 1
72031: EQUAL
72032: IFFALSE 72048
// ComExitVehicle ( IsInUnit ( j ) ) ;
72034: LD_VAR 0 3
72038: PPUSH
72039: CALL_OW 310
72043: PPUSH
72044: CALL_OW 121
// if GetControl ( j ) = control_remote then
72048: LD_VAR 0 3
72052: PPUSH
72053: CALL_OW 263
72057: PUSH
72058: LD_INT 2
72060: EQUAL
72061: IFFALSE 72072
// ComUnlink ( j ) ;
72063: LD_VAR 0 3
72067: PPUSH
72068: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
72072: LD_ADDR_VAR 0 9
72076: PUSH
72077: LD_VAR 0 2
72081: PPUSH
72082: LD_INT 3
72084: PPUSH
72085: CALL 81545 0 2
72089: ST_TO_ADDR
// if fac then
72090: LD_VAR 0 9
72094: IFFALSE 72190
// begin for k in fac do
72096: LD_ADDR_VAR 0 4
72100: PUSH
72101: LD_VAR 0 9
72105: PUSH
72106: FOR_IN
72107: IFFALSE 72188
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
72109: LD_ADDR_VAR 0 10
72113: PUSH
72114: LD_VAR 0 9
72118: PPUSH
72119: LD_VAR 0 3
72123: PPUSH
72124: CALL_OW 265
72128: PPUSH
72129: LD_VAR 0 3
72133: PPUSH
72134: CALL_OW 262
72138: PPUSH
72139: LD_VAR 0 3
72143: PPUSH
72144: CALL_OW 263
72148: PPUSH
72149: LD_VAR 0 3
72153: PPUSH
72154: CALL_OW 264
72158: PPUSH
72159: CALL 18898 0 5
72163: ST_TO_ADDR
// if components then
72164: LD_VAR 0 10
72168: IFFALSE 72186
// begin MC_InsertProduceList ( i , components ) ;
72170: LD_VAR 0 2
72174: PPUSH
72175: LD_VAR 0 10
72179: PPUSH
72180: CALL 81090 0 2
// break ;
72184: GO 72188
// end ; end ;
72186: GO 72106
72188: POP
72189: POP
// end ; continue ;
72190: GO 71686
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
72192: LD_VAR 0 3
72196: PPUSH
72197: LD_INT 1
72199: PPUSH
72200: CALL_OW 289
72204: PUSH
72205: LD_INT 100
72207: LESS
72208: PUSH
72209: LD_VAR 0 3
72213: PPUSH
72214: CALL_OW 314
72218: NOT
72219: AND
72220: IFFALSE 72249
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
72222: LD_VAR 0 3
72226: PPUSH
72227: LD_VAR 0 6
72231: PUSH
72232: LD_INT 2
72234: ARRAY
72235: PPUSH
72236: LD_VAR 0 6
72240: PUSH
72241: LD_INT 3
72243: ARRAY
72244: PPUSH
72245: CALL_OW 117
// break ;
72249: GO 72253
// end ;
72251: GO 71686
72253: POP
72254: POP
// end ; end ;
72255: GO 70524
72257: POP
72258: POP
// end ;
72259: LD_VAR 0 1
72263: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
72264: LD_INT 0
72266: PPUSH
72267: PPUSH
72268: PPUSH
72269: PPUSH
// if not mc_bases then
72270: LD_EXP 58
72274: NOT
72275: IFFALSE 72279
// exit ;
72277: GO 72440
// for i = 1 to mc_bases do
72279: LD_ADDR_VAR 0 2
72283: PUSH
72284: DOUBLE
72285: LD_INT 1
72287: DEC
72288: ST_TO_ADDR
72289: LD_EXP 58
72293: PUSH
72294: FOR_TO
72295: IFFALSE 72438
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
72297: LD_ADDR_VAR 0 4
72301: PUSH
72302: LD_EXP 77
72306: PUSH
72307: LD_VAR 0 2
72311: ARRAY
72312: PUSH
72313: LD_EXP 80
72317: PUSH
72318: LD_VAR 0 2
72322: ARRAY
72323: UNION
72324: PPUSH
72325: LD_INT 33
72327: PUSH
72328: LD_INT 2
72330: PUSH
72331: EMPTY
72332: LIST
72333: LIST
72334: PPUSH
72335: CALL_OW 72
72339: ST_TO_ADDR
// if tmp then
72340: LD_VAR 0 4
72344: IFFALSE 72436
// for j in tmp do
72346: LD_ADDR_VAR 0 3
72350: PUSH
72351: LD_VAR 0 4
72355: PUSH
72356: FOR_IN
72357: IFFALSE 72434
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
72359: LD_VAR 0 3
72363: PPUSH
72364: CALL_OW 312
72368: NOT
72369: PUSH
72370: LD_VAR 0 3
72374: PPUSH
72375: CALL_OW 256
72379: PUSH
72380: LD_INT 250
72382: GREATEREQUAL
72383: AND
72384: IFFALSE 72397
// Connect ( j ) else
72386: LD_VAR 0 3
72390: PPUSH
72391: CALL 24299 0 1
72395: GO 72432
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
72397: LD_VAR 0 3
72401: PPUSH
72402: CALL_OW 256
72406: PUSH
72407: LD_INT 250
72409: LESS
72410: PUSH
72411: LD_VAR 0 3
72415: PPUSH
72416: CALL_OW 312
72420: AND
72421: IFFALSE 72432
// ComUnlink ( j ) ;
72423: LD_VAR 0 3
72427: PPUSH
72428: CALL_OW 136
72432: GO 72356
72434: POP
72435: POP
// end ;
72436: GO 72294
72438: POP
72439: POP
// end ;
72440: LD_VAR 0 1
72444: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
72445: LD_INT 0
72447: PPUSH
72448: PPUSH
72449: PPUSH
72450: PPUSH
72451: PPUSH
// if not mc_bases then
72452: LD_EXP 58
72456: NOT
72457: IFFALSE 72461
// exit ;
72459: GO 72906
// for i = 1 to mc_bases do
72461: LD_ADDR_VAR 0 2
72465: PUSH
72466: DOUBLE
72467: LD_INT 1
72469: DEC
72470: ST_TO_ADDR
72471: LD_EXP 58
72475: PUSH
72476: FOR_TO
72477: IFFALSE 72904
// begin if not mc_produce [ i ] then
72479: LD_EXP 79
72483: PUSH
72484: LD_VAR 0 2
72488: ARRAY
72489: NOT
72490: IFFALSE 72494
// continue ;
72492: GO 72476
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72494: LD_ADDR_VAR 0 5
72498: PUSH
72499: LD_EXP 58
72503: PUSH
72504: LD_VAR 0 2
72508: ARRAY
72509: PPUSH
72510: LD_INT 30
72512: PUSH
72513: LD_INT 3
72515: PUSH
72516: EMPTY
72517: LIST
72518: LIST
72519: PPUSH
72520: CALL_OW 72
72524: ST_TO_ADDR
// if not fac then
72525: LD_VAR 0 5
72529: NOT
72530: IFFALSE 72534
// continue ;
72532: GO 72476
// for j in fac do
72534: LD_ADDR_VAR 0 3
72538: PUSH
72539: LD_VAR 0 5
72543: PUSH
72544: FOR_IN
72545: IFFALSE 72900
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
72547: LD_VAR 0 3
72551: PPUSH
72552: CALL_OW 461
72556: PUSH
72557: LD_INT 2
72559: NONEQUAL
72560: PUSH
72561: LD_VAR 0 3
72565: PPUSH
72566: LD_INT 15
72568: PPUSH
72569: CALL 23959 0 2
72573: PUSH
72574: LD_INT 4
72576: ARRAY
72577: OR
72578: IFFALSE 72582
// continue ;
72580: GO 72544
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
72582: LD_VAR 0 3
72586: PPUSH
72587: LD_EXP 79
72591: PUSH
72592: LD_VAR 0 2
72596: ARRAY
72597: PUSH
72598: LD_INT 1
72600: ARRAY
72601: PUSH
72602: LD_INT 1
72604: ARRAY
72605: PPUSH
72606: LD_EXP 79
72610: PUSH
72611: LD_VAR 0 2
72615: ARRAY
72616: PUSH
72617: LD_INT 1
72619: ARRAY
72620: PUSH
72621: LD_INT 2
72623: ARRAY
72624: PPUSH
72625: LD_EXP 79
72629: PUSH
72630: LD_VAR 0 2
72634: ARRAY
72635: PUSH
72636: LD_INT 1
72638: ARRAY
72639: PUSH
72640: LD_INT 3
72642: ARRAY
72643: PPUSH
72644: LD_EXP 79
72648: PUSH
72649: LD_VAR 0 2
72653: ARRAY
72654: PUSH
72655: LD_INT 1
72657: ARRAY
72658: PUSH
72659: LD_INT 4
72661: ARRAY
72662: PPUSH
72663: CALL_OW 448
72667: PUSH
72668: LD_VAR 0 3
72672: PPUSH
72673: LD_EXP 79
72677: PUSH
72678: LD_VAR 0 2
72682: ARRAY
72683: PUSH
72684: LD_INT 1
72686: ARRAY
72687: PUSH
72688: LD_INT 1
72690: ARRAY
72691: PUSH
72692: LD_EXP 79
72696: PUSH
72697: LD_VAR 0 2
72701: ARRAY
72702: PUSH
72703: LD_INT 1
72705: ARRAY
72706: PUSH
72707: LD_INT 2
72709: ARRAY
72710: PUSH
72711: LD_EXP 79
72715: PUSH
72716: LD_VAR 0 2
72720: ARRAY
72721: PUSH
72722: LD_INT 1
72724: ARRAY
72725: PUSH
72726: LD_INT 3
72728: ARRAY
72729: PUSH
72730: LD_EXP 79
72734: PUSH
72735: LD_VAR 0 2
72739: ARRAY
72740: PUSH
72741: LD_INT 1
72743: ARRAY
72744: PUSH
72745: LD_INT 4
72747: ARRAY
72748: PUSH
72749: EMPTY
72750: LIST
72751: LIST
72752: LIST
72753: LIST
72754: PPUSH
72755: CALL 27630 0 2
72759: AND
72760: IFFALSE 72898
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
72762: LD_VAR 0 3
72766: PPUSH
72767: LD_EXP 79
72771: PUSH
72772: LD_VAR 0 2
72776: ARRAY
72777: PUSH
72778: LD_INT 1
72780: ARRAY
72781: PUSH
72782: LD_INT 1
72784: ARRAY
72785: PPUSH
72786: LD_EXP 79
72790: PUSH
72791: LD_VAR 0 2
72795: ARRAY
72796: PUSH
72797: LD_INT 1
72799: ARRAY
72800: PUSH
72801: LD_INT 2
72803: ARRAY
72804: PPUSH
72805: LD_EXP 79
72809: PUSH
72810: LD_VAR 0 2
72814: ARRAY
72815: PUSH
72816: LD_INT 1
72818: ARRAY
72819: PUSH
72820: LD_INT 3
72822: ARRAY
72823: PPUSH
72824: LD_EXP 79
72828: PUSH
72829: LD_VAR 0 2
72833: ARRAY
72834: PUSH
72835: LD_INT 1
72837: ARRAY
72838: PUSH
72839: LD_INT 4
72841: ARRAY
72842: PPUSH
72843: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
72847: LD_ADDR_VAR 0 4
72851: PUSH
72852: LD_EXP 79
72856: PUSH
72857: LD_VAR 0 2
72861: ARRAY
72862: PPUSH
72863: LD_INT 1
72865: PPUSH
72866: CALL_OW 3
72870: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
72871: LD_ADDR_EXP 79
72875: PUSH
72876: LD_EXP 79
72880: PPUSH
72881: LD_VAR 0 2
72885: PPUSH
72886: LD_VAR 0 4
72890: PPUSH
72891: CALL_OW 1
72895: ST_TO_ADDR
// break ;
72896: GO 72900
// end ; end ;
72898: GO 72544
72900: POP
72901: POP
// end ;
72902: GO 72476
72904: POP
72905: POP
// end ;
72906: LD_VAR 0 1
72910: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
72911: LD_INT 0
72913: PPUSH
72914: PPUSH
72915: PPUSH
// if not mc_bases then
72916: LD_EXP 58
72920: NOT
72921: IFFALSE 72925
// exit ;
72923: GO 73014
// for i = 1 to mc_bases do
72925: LD_ADDR_VAR 0 2
72929: PUSH
72930: DOUBLE
72931: LD_INT 1
72933: DEC
72934: ST_TO_ADDR
72935: LD_EXP 58
72939: PUSH
72940: FOR_TO
72941: IFFALSE 73012
// begin if mc_attack [ i ] then
72943: LD_EXP 78
72947: PUSH
72948: LD_VAR 0 2
72952: ARRAY
72953: IFFALSE 73010
// begin tmp := mc_attack [ i ] [ 1 ] ;
72955: LD_ADDR_VAR 0 3
72959: PUSH
72960: LD_EXP 78
72964: PUSH
72965: LD_VAR 0 2
72969: ARRAY
72970: PUSH
72971: LD_INT 1
72973: ARRAY
72974: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
72975: LD_ADDR_EXP 78
72979: PUSH
72980: LD_EXP 78
72984: PPUSH
72985: LD_VAR 0 2
72989: PPUSH
72990: EMPTY
72991: PPUSH
72992: CALL_OW 1
72996: ST_TO_ADDR
// Attack ( tmp ) ;
72997: LD_VAR 0 3
73001: PPUSH
73002: CALL 49843 0 1
// exit ;
73006: POP
73007: POP
73008: GO 73014
// end ; end ;
73010: GO 72940
73012: POP
73013: POP
// end ;
73014: LD_VAR 0 1
73018: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
73019: LD_INT 0
73021: PPUSH
73022: PPUSH
73023: PPUSH
73024: PPUSH
73025: PPUSH
73026: PPUSH
73027: PPUSH
// if not mc_bases then
73028: LD_EXP 58
73032: NOT
73033: IFFALSE 73037
// exit ;
73035: GO 73619
// for i = 1 to mc_bases do
73037: LD_ADDR_VAR 0 2
73041: PUSH
73042: DOUBLE
73043: LD_INT 1
73045: DEC
73046: ST_TO_ADDR
73047: LD_EXP 58
73051: PUSH
73052: FOR_TO
73053: IFFALSE 73617
// begin if not mc_bases [ i ] then
73055: LD_EXP 58
73059: PUSH
73060: LD_VAR 0 2
73064: ARRAY
73065: NOT
73066: IFFALSE 73070
// continue ;
73068: GO 73052
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
73070: LD_ADDR_VAR 0 7
73074: PUSH
73075: LD_EXP 58
73079: PUSH
73080: LD_VAR 0 2
73084: ARRAY
73085: PUSH
73086: LD_INT 1
73088: ARRAY
73089: PPUSH
73090: CALL 18202 0 1
73094: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
73095: LD_ADDR_EXP 81
73099: PUSH
73100: LD_EXP 81
73104: PPUSH
73105: LD_VAR 0 2
73109: PPUSH
73110: LD_EXP 58
73114: PUSH
73115: LD_VAR 0 2
73119: ARRAY
73120: PUSH
73121: LD_INT 1
73123: ARRAY
73124: PPUSH
73125: CALL_OW 255
73129: PPUSH
73130: LD_EXP 83
73134: PUSH
73135: LD_VAR 0 2
73139: ARRAY
73140: PPUSH
73141: CALL 15756 0 2
73145: PPUSH
73146: CALL_OW 1
73150: ST_TO_ADDR
// if not mc_scan [ i ] then
73151: LD_EXP 81
73155: PUSH
73156: LD_VAR 0 2
73160: ARRAY
73161: NOT
73162: IFFALSE 73317
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73164: LD_ADDR_VAR 0 4
73168: PUSH
73169: LD_EXP 58
73173: PUSH
73174: LD_VAR 0 2
73178: ARRAY
73179: PPUSH
73180: LD_INT 2
73182: PUSH
73183: LD_INT 25
73185: PUSH
73186: LD_INT 5
73188: PUSH
73189: EMPTY
73190: LIST
73191: LIST
73192: PUSH
73193: LD_INT 25
73195: PUSH
73196: LD_INT 8
73198: PUSH
73199: EMPTY
73200: LIST
73201: LIST
73202: PUSH
73203: LD_INT 25
73205: PUSH
73206: LD_INT 9
73208: PUSH
73209: EMPTY
73210: LIST
73211: LIST
73212: PUSH
73213: EMPTY
73214: LIST
73215: LIST
73216: LIST
73217: LIST
73218: PPUSH
73219: CALL_OW 72
73223: ST_TO_ADDR
// if not tmp then
73224: LD_VAR 0 4
73228: NOT
73229: IFFALSE 73233
// continue ;
73231: GO 73052
// for j in tmp do
73233: LD_ADDR_VAR 0 3
73237: PUSH
73238: LD_VAR 0 4
73242: PUSH
73243: FOR_IN
73244: IFFALSE 73315
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
73246: LD_VAR 0 3
73250: PPUSH
73251: CALL_OW 310
73255: PPUSH
73256: CALL_OW 266
73260: PUSH
73261: LD_INT 5
73263: EQUAL
73264: PUSH
73265: LD_VAR 0 3
73269: PPUSH
73270: CALL_OW 257
73274: PUSH
73275: LD_INT 1
73277: EQUAL
73278: AND
73279: PUSH
73280: LD_VAR 0 3
73284: PPUSH
73285: CALL_OW 459
73289: NOT
73290: AND
73291: PUSH
73292: LD_VAR 0 7
73296: AND
73297: IFFALSE 73313
// ComChangeProfession ( j , class ) ;
73299: LD_VAR 0 3
73303: PPUSH
73304: LD_VAR 0 7
73308: PPUSH
73309: CALL_OW 123
73313: GO 73243
73315: POP
73316: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
73317: LD_EXP 81
73321: PUSH
73322: LD_VAR 0 2
73326: ARRAY
73327: PUSH
73328: LD_EXP 80
73332: PUSH
73333: LD_VAR 0 2
73337: ARRAY
73338: NOT
73339: AND
73340: PUSH
73341: LD_EXP 58
73345: PUSH
73346: LD_VAR 0 2
73350: ARRAY
73351: PPUSH
73352: LD_INT 30
73354: PUSH
73355: LD_INT 32
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: PPUSH
73362: CALL_OW 72
73366: NOT
73367: AND
73368: PUSH
73369: LD_EXP 58
73373: PUSH
73374: LD_VAR 0 2
73378: ARRAY
73379: PPUSH
73380: LD_INT 2
73382: PUSH
73383: LD_INT 30
73385: PUSH
73386: LD_INT 4
73388: PUSH
73389: EMPTY
73390: LIST
73391: LIST
73392: PUSH
73393: LD_INT 30
73395: PUSH
73396: LD_INT 5
73398: PUSH
73399: EMPTY
73400: LIST
73401: LIST
73402: PUSH
73403: EMPTY
73404: LIST
73405: LIST
73406: LIST
73407: PPUSH
73408: CALL_OW 72
73412: NOT
73413: AND
73414: IFFALSE 73546
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73416: LD_ADDR_VAR 0 4
73420: PUSH
73421: LD_EXP 58
73425: PUSH
73426: LD_VAR 0 2
73430: ARRAY
73431: PPUSH
73432: LD_INT 2
73434: PUSH
73435: LD_INT 25
73437: PUSH
73438: LD_INT 1
73440: PUSH
73441: EMPTY
73442: LIST
73443: LIST
73444: PUSH
73445: LD_INT 25
73447: PUSH
73448: LD_INT 5
73450: PUSH
73451: EMPTY
73452: LIST
73453: LIST
73454: PUSH
73455: LD_INT 25
73457: PUSH
73458: LD_INT 8
73460: PUSH
73461: EMPTY
73462: LIST
73463: LIST
73464: PUSH
73465: LD_INT 25
73467: PUSH
73468: LD_INT 9
73470: PUSH
73471: EMPTY
73472: LIST
73473: LIST
73474: PUSH
73475: EMPTY
73476: LIST
73477: LIST
73478: LIST
73479: LIST
73480: LIST
73481: PPUSH
73482: CALL_OW 72
73486: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
73487: LD_ADDR_VAR 0 4
73491: PUSH
73492: LD_VAR 0 4
73496: PUSH
73497: LD_VAR 0 4
73501: PPUSH
73502: LD_INT 18
73504: PPUSH
73505: CALL 54626 0 2
73509: DIFF
73510: ST_TO_ADDR
// if tmp then
73511: LD_VAR 0 4
73515: IFFALSE 73546
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
73517: LD_VAR 0 2
73521: PPUSH
73522: LD_VAR 0 4
73526: PPUSH
73527: LD_EXP 83
73531: PUSH
73532: LD_VAR 0 2
73536: ARRAY
73537: PPUSH
73538: CALL 15791 0 3
// exit ;
73542: POP
73543: POP
73544: GO 73619
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
73546: LD_EXP 81
73550: PUSH
73551: LD_VAR 0 2
73555: ARRAY
73556: PUSH
73557: LD_EXP 80
73561: PUSH
73562: LD_VAR 0 2
73566: ARRAY
73567: AND
73568: IFFALSE 73615
// begin tmp := mc_defender [ i ] ;
73570: LD_ADDR_VAR 0 4
73574: PUSH
73575: LD_EXP 80
73579: PUSH
73580: LD_VAR 0 2
73584: ARRAY
73585: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
73586: LD_VAR 0 2
73590: PPUSH
73591: LD_VAR 0 4
73595: PPUSH
73596: LD_EXP 81
73600: PUSH
73601: LD_VAR 0 2
73605: ARRAY
73606: PPUSH
73607: CALL 16352 0 3
// exit ;
73611: POP
73612: POP
73613: GO 73619
// end ; end ;
73615: GO 73052
73617: POP
73618: POP
// end ;
73619: LD_VAR 0 1
73623: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73624: LD_INT 0
73626: PPUSH
73627: PPUSH
73628: PPUSH
73629: PPUSH
73630: PPUSH
73631: PPUSH
73632: PPUSH
73633: PPUSH
73634: PPUSH
73635: PPUSH
73636: PPUSH
// if not mc_bases then
73637: LD_EXP 58
73641: NOT
73642: IFFALSE 73646
// exit ;
73644: GO 74733
// for i = 1 to mc_bases do
73646: LD_ADDR_VAR 0 2
73650: PUSH
73651: DOUBLE
73652: LD_INT 1
73654: DEC
73655: ST_TO_ADDR
73656: LD_EXP 58
73660: PUSH
73661: FOR_TO
73662: IFFALSE 74731
// begin tmp := mc_lab [ i ] ;
73664: LD_ADDR_VAR 0 6
73668: PUSH
73669: LD_EXP 91
73673: PUSH
73674: LD_VAR 0 2
73678: ARRAY
73679: ST_TO_ADDR
// if not tmp then
73680: LD_VAR 0 6
73684: NOT
73685: IFFALSE 73689
// continue ;
73687: GO 73661
// idle_lab := 0 ;
73689: LD_ADDR_VAR 0 11
73693: PUSH
73694: LD_INT 0
73696: ST_TO_ADDR
// for j in tmp do
73697: LD_ADDR_VAR 0 3
73701: PUSH
73702: LD_VAR 0 6
73706: PUSH
73707: FOR_IN
73708: IFFALSE 74727
// begin researching := false ;
73710: LD_ADDR_VAR 0 10
73714: PUSH
73715: LD_INT 0
73717: ST_TO_ADDR
// side := GetSide ( j ) ;
73718: LD_ADDR_VAR 0 4
73722: PUSH
73723: LD_VAR 0 3
73727: PPUSH
73728: CALL_OW 255
73732: ST_TO_ADDR
// if not mc_tech [ side ] then
73733: LD_EXP 85
73737: PUSH
73738: LD_VAR 0 4
73742: ARRAY
73743: NOT
73744: IFFALSE 73748
// continue ;
73746: GO 73707
// if BuildingStatus ( j ) = bs_idle then
73748: LD_VAR 0 3
73752: PPUSH
73753: CALL_OW 461
73757: PUSH
73758: LD_INT 2
73760: EQUAL
73761: IFFALSE 73949
// begin if idle_lab and UnitsInside ( j ) < 6 then
73763: LD_VAR 0 11
73767: PUSH
73768: LD_VAR 0 3
73772: PPUSH
73773: CALL_OW 313
73777: PUSH
73778: LD_INT 6
73780: LESS
73781: AND
73782: IFFALSE 73853
// begin tmp2 := UnitsInside ( idle_lab ) ;
73784: LD_ADDR_VAR 0 9
73788: PUSH
73789: LD_VAR 0 11
73793: PPUSH
73794: CALL_OW 313
73798: ST_TO_ADDR
// if tmp2 then
73799: LD_VAR 0 9
73803: IFFALSE 73845
// for x in tmp2 do
73805: LD_ADDR_VAR 0 7
73809: PUSH
73810: LD_VAR 0 9
73814: PUSH
73815: FOR_IN
73816: IFFALSE 73843
// begin ComExitBuilding ( x ) ;
73818: LD_VAR 0 7
73822: PPUSH
73823: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73827: LD_VAR 0 7
73831: PPUSH
73832: LD_VAR 0 3
73836: PPUSH
73837: CALL_OW 180
// end ;
73841: GO 73815
73843: POP
73844: POP
// idle_lab := 0 ;
73845: LD_ADDR_VAR 0 11
73849: PUSH
73850: LD_INT 0
73852: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
73853: LD_ADDR_VAR 0 5
73857: PUSH
73858: LD_EXP 85
73862: PUSH
73863: LD_VAR 0 4
73867: ARRAY
73868: PUSH
73869: FOR_IN
73870: IFFALSE 73930
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
73872: LD_VAR 0 3
73876: PPUSH
73877: LD_VAR 0 5
73881: PPUSH
73882: CALL_OW 430
73886: PUSH
73887: LD_VAR 0 4
73891: PPUSH
73892: LD_VAR 0 5
73896: PPUSH
73897: CALL 14861 0 2
73901: AND
73902: IFFALSE 73928
// begin researching := true ;
73904: LD_ADDR_VAR 0 10
73908: PUSH
73909: LD_INT 1
73911: ST_TO_ADDR
// ComResearch ( j , t ) ;
73912: LD_VAR 0 3
73916: PPUSH
73917: LD_VAR 0 5
73921: PPUSH
73922: CALL_OW 124
// break ;
73926: GO 73930
// end ;
73928: GO 73869
73930: POP
73931: POP
// if not researching then
73932: LD_VAR 0 10
73936: NOT
73937: IFFALSE 73949
// idle_lab := j ;
73939: LD_ADDR_VAR 0 11
73943: PUSH
73944: LD_VAR 0 3
73948: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
73949: LD_VAR 0 3
73953: PPUSH
73954: CALL_OW 461
73958: PUSH
73959: LD_INT 10
73961: EQUAL
73962: IFFALSE 74550
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
73964: LD_EXP 87
73968: PUSH
73969: LD_VAR 0 2
73973: ARRAY
73974: NOT
73975: PUSH
73976: LD_EXP 88
73980: PUSH
73981: LD_VAR 0 2
73985: ARRAY
73986: NOT
73987: AND
73988: PUSH
73989: LD_EXP 85
73993: PUSH
73994: LD_VAR 0 4
73998: ARRAY
73999: PUSH
74000: LD_INT 1
74002: GREATER
74003: AND
74004: IFFALSE 74135
// begin ComCancel ( j ) ;
74006: LD_VAR 0 3
74010: PPUSH
74011: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
74015: LD_ADDR_EXP 85
74019: PUSH
74020: LD_EXP 85
74024: PPUSH
74025: LD_VAR 0 4
74029: PPUSH
74030: LD_EXP 85
74034: PUSH
74035: LD_VAR 0 4
74039: ARRAY
74040: PPUSH
74041: LD_EXP 85
74045: PUSH
74046: LD_VAR 0 4
74050: ARRAY
74051: PUSH
74052: LD_INT 1
74054: MINUS
74055: PPUSH
74056: LD_EXP 85
74060: PUSH
74061: LD_VAR 0 4
74065: ARRAY
74066: PPUSH
74067: LD_INT 0
74069: PPUSH
74070: CALL 20784 0 4
74074: PPUSH
74075: CALL_OW 1
74079: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
74080: LD_ADDR_EXP 85
74084: PUSH
74085: LD_EXP 85
74089: PPUSH
74090: LD_VAR 0 4
74094: PPUSH
74095: LD_EXP 85
74099: PUSH
74100: LD_VAR 0 4
74104: ARRAY
74105: PPUSH
74106: LD_EXP 85
74110: PUSH
74111: LD_VAR 0 4
74115: ARRAY
74116: PPUSH
74117: LD_INT 1
74119: PPUSH
74120: LD_INT 0
74122: PPUSH
74123: CALL 20784 0 4
74127: PPUSH
74128: CALL_OW 1
74132: ST_TO_ADDR
// continue ;
74133: GO 73707
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
74135: LD_EXP 87
74139: PUSH
74140: LD_VAR 0 2
74144: ARRAY
74145: PUSH
74146: LD_EXP 88
74150: PUSH
74151: LD_VAR 0 2
74155: ARRAY
74156: NOT
74157: AND
74158: IFFALSE 74285
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
74160: LD_ADDR_EXP 88
74164: PUSH
74165: LD_EXP 88
74169: PPUSH
74170: LD_VAR 0 2
74174: PUSH
74175: LD_EXP 88
74179: PUSH
74180: LD_VAR 0 2
74184: ARRAY
74185: PUSH
74186: LD_INT 1
74188: PLUS
74189: PUSH
74190: EMPTY
74191: LIST
74192: LIST
74193: PPUSH
74194: LD_EXP 87
74198: PUSH
74199: LD_VAR 0 2
74203: ARRAY
74204: PUSH
74205: LD_INT 1
74207: ARRAY
74208: PPUSH
74209: CALL 21366 0 3
74213: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
74214: LD_EXP 87
74218: PUSH
74219: LD_VAR 0 2
74223: ARRAY
74224: PUSH
74225: LD_INT 1
74227: ARRAY
74228: PPUSH
74229: LD_INT 112
74231: PPUSH
74232: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
74236: LD_ADDR_VAR 0 9
74240: PUSH
74241: LD_EXP 87
74245: PUSH
74246: LD_VAR 0 2
74250: ARRAY
74251: PPUSH
74252: LD_INT 1
74254: PPUSH
74255: CALL_OW 3
74259: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
74260: LD_ADDR_EXP 87
74264: PUSH
74265: LD_EXP 87
74269: PPUSH
74270: LD_VAR 0 2
74274: PPUSH
74275: LD_VAR 0 9
74279: PPUSH
74280: CALL_OW 1
74284: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
74285: LD_EXP 87
74289: PUSH
74290: LD_VAR 0 2
74294: ARRAY
74295: PUSH
74296: LD_EXP 88
74300: PUSH
74301: LD_VAR 0 2
74305: ARRAY
74306: AND
74307: PUSH
74308: LD_EXP 88
74312: PUSH
74313: LD_VAR 0 2
74317: ARRAY
74318: PUSH
74319: LD_INT 1
74321: ARRAY
74322: PPUSH
74323: CALL_OW 310
74327: NOT
74328: AND
74329: PUSH
74330: LD_VAR 0 3
74334: PPUSH
74335: CALL_OW 313
74339: PUSH
74340: LD_INT 6
74342: EQUAL
74343: AND
74344: IFFALSE 74400
// begin tmp2 := UnitsInside ( j ) ;
74346: LD_ADDR_VAR 0 9
74350: PUSH
74351: LD_VAR 0 3
74355: PPUSH
74356: CALL_OW 313
74360: ST_TO_ADDR
// if tmp2 = 6 then
74361: LD_VAR 0 9
74365: PUSH
74366: LD_INT 6
74368: EQUAL
74369: IFFALSE 74400
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
74371: LD_VAR 0 9
74375: PUSH
74376: LD_INT 1
74378: ARRAY
74379: PPUSH
74380: LD_INT 112
74382: PPUSH
74383: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
74387: LD_VAR 0 9
74391: PUSH
74392: LD_INT 1
74394: ARRAY
74395: PPUSH
74396: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
74400: LD_EXP 88
74404: PUSH
74405: LD_VAR 0 2
74409: ARRAY
74410: PUSH
74411: LD_EXP 88
74415: PUSH
74416: LD_VAR 0 2
74420: ARRAY
74421: PUSH
74422: LD_INT 1
74424: ARRAY
74425: PPUSH
74426: CALL_OW 314
74430: NOT
74431: AND
74432: PUSH
74433: LD_EXP 88
74437: PUSH
74438: LD_VAR 0 2
74442: ARRAY
74443: PUSH
74444: LD_INT 1
74446: ARRAY
74447: PPUSH
74448: CALL_OW 310
74452: NOT
74453: AND
74454: IFFALSE 74480
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
74456: LD_EXP 88
74460: PUSH
74461: LD_VAR 0 2
74465: ARRAY
74466: PUSH
74467: LD_INT 1
74469: ARRAY
74470: PPUSH
74471: LD_VAR 0 3
74475: PPUSH
74476: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
74480: LD_EXP 88
74484: PUSH
74485: LD_VAR 0 2
74489: ARRAY
74490: PUSH
74491: LD_INT 1
74493: ARRAY
74494: PPUSH
74495: CALL_OW 310
74499: PUSH
74500: LD_EXP 88
74504: PUSH
74505: LD_VAR 0 2
74509: ARRAY
74510: PUSH
74511: LD_INT 1
74513: ARRAY
74514: PPUSH
74515: CALL_OW 310
74519: PPUSH
74520: CALL_OW 461
74524: PUSH
74525: LD_INT 3
74527: NONEQUAL
74528: AND
74529: IFFALSE 74550
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74531: LD_EXP 88
74535: PUSH
74536: LD_VAR 0 2
74540: ARRAY
74541: PUSH
74542: LD_INT 1
74544: ARRAY
74545: PPUSH
74546: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74550: LD_VAR 0 3
74554: PPUSH
74555: CALL_OW 461
74559: PUSH
74560: LD_INT 6
74562: EQUAL
74563: PUSH
74564: LD_VAR 0 6
74568: PUSH
74569: LD_INT 1
74571: GREATER
74572: AND
74573: IFFALSE 74725
// begin sci := [ ] ;
74575: LD_ADDR_VAR 0 8
74579: PUSH
74580: EMPTY
74581: ST_TO_ADDR
// for x in ( tmp diff j ) do
74582: LD_ADDR_VAR 0 7
74586: PUSH
74587: LD_VAR 0 6
74591: PUSH
74592: LD_VAR 0 3
74596: DIFF
74597: PUSH
74598: FOR_IN
74599: IFFALSE 74651
// begin if sci = 6 then
74601: LD_VAR 0 8
74605: PUSH
74606: LD_INT 6
74608: EQUAL
74609: IFFALSE 74613
// break ;
74611: GO 74651
// if BuildingStatus ( x ) = bs_idle then
74613: LD_VAR 0 7
74617: PPUSH
74618: CALL_OW 461
74622: PUSH
74623: LD_INT 2
74625: EQUAL
74626: IFFALSE 74649
// sci := sci ^ UnitsInside ( x ) ;
74628: LD_ADDR_VAR 0 8
74632: PUSH
74633: LD_VAR 0 8
74637: PUSH
74638: LD_VAR 0 7
74642: PPUSH
74643: CALL_OW 313
74647: ADD
74648: ST_TO_ADDR
// end ;
74649: GO 74598
74651: POP
74652: POP
// if not sci then
74653: LD_VAR 0 8
74657: NOT
74658: IFFALSE 74662
// continue ;
74660: GO 73707
// for x in sci do
74662: LD_ADDR_VAR 0 7
74666: PUSH
74667: LD_VAR 0 8
74671: PUSH
74672: FOR_IN
74673: IFFALSE 74723
// if IsInUnit ( x ) and not HasTask ( x ) then
74675: LD_VAR 0 7
74679: PPUSH
74680: CALL_OW 310
74684: PUSH
74685: LD_VAR 0 7
74689: PPUSH
74690: CALL_OW 314
74694: NOT
74695: AND
74696: IFFALSE 74721
// begin ComExitBuilding ( x ) ;
74698: LD_VAR 0 7
74702: PPUSH
74703: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74707: LD_VAR 0 7
74711: PPUSH
74712: LD_VAR 0 3
74716: PPUSH
74717: CALL_OW 180
// end ;
74721: GO 74672
74723: POP
74724: POP
// end ; end ;
74725: GO 73707
74727: POP
74728: POP
// end ;
74729: GO 73661
74731: POP
74732: POP
// end ;
74733: LD_VAR 0 1
74737: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74738: LD_INT 0
74740: PPUSH
74741: PPUSH
// if not mc_bases then
74742: LD_EXP 58
74746: NOT
74747: IFFALSE 74751
// exit ;
74749: GO 74832
// for i = 1 to mc_bases do
74751: LD_ADDR_VAR 0 2
74755: PUSH
74756: DOUBLE
74757: LD_INT 1
74759: DEC
74760: ST_TO_ADDR
74761: LD_EXP 58
74765: PUSH
74766: FOR_TO
74767: IFFALSE 74830
// if mc_mines [ i ] and mc_miners [ i ] then
74769: LD_EXP 71
74773: PUSH
74774: LD_VAR 0 2
74778: ARRAY
74779: PUSH
74780: LD_EXP 72
74784: PUSH
74785: LD_VAR 0 2
74789: ARRAY
74790: AND
74791: IFFALSE 74828
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74793: LD_EXP 72
74797: PUSH
74798: LD_VAR 0 2
74802: ARRAY
74803: PUSH
74804: LD_INT 1
74806: ARRAY
74807: PPUSH
74808: CALL_OW 255
74812: PPUSH
74813: LD_EXP 71
74817: PUSH
74818: LD_VAR 0 2
74822: ARRAY
74823: PPUSH
74824: CALL 18355 0 2
74828: GO 74766
74830: POP
74831: POP
// end ;
74832: LD_VAR 0 1
74836: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
74837: LD_INT 0
74839: PPUSH
74840: PPUSH
74841: PPUSH
74842: PPUSH
74843: PPUSH
74844: PPUSH
74845: PPUSH
74846: PPUSH
// if not mc_bases or not mc_parking then
74847: LD_EXP 58
74851: NOT
74852: PUSH
74853: LD_EXP 82
74857: NOT
74858: OR
74859: IFFALSE 74863
// exit ;
74861: GO 75562
// for i = 1 to mc_bases do
74863: LD_ADDR_VAR 0 2
74867: PUSH
74868: DOUBLE
74869: LD_INT 1
74871: DEC
74872: ST_TO_ADDR
74873: LD_EXP 58
74877: PUSH
74878: FOR_TO
74879: IFFALSE 75560
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
74881: LD_EXP 58
74885: PUSH
74886: LD_VAR 0 2
74890: ARRAY
74891: NOT
74892: PUSH
74893: LD_EXP 82
74897: PUSH
74898: LD_VAR 0 2
74902: ARRAY
74903: NOT
74904: OR
74905: IFFALSE 74909
// continue ;
74907: GO 74878
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74909: LD_ADDR_VAR 0 5
74913: PUSH
74914: LD_EXP 58
74918: PUSH
74919: LD_VAR 0 2
74923: ARRAY
74924: PUSH
74925: LD_INT 1
74927: ARRAY
74928: PPUSH
74929: CALL_OW 255
74933: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74934: LD_ADDR_VAR 0 6
74938: PUSH
74939: LD_EXP 58
74943: PUSH
74944: LD_VAR 0 2
74948: ARRAY
74949: PPUSH
74950: LD_INT 30
74952: PUSH
74953: LD_INT 3
74955: PUSH
74956: EMPTY
74957: LIST
74958: LIST
74959: PPUSH
74960: CALL_OW 72
74964: ST_TO_ADDR
// if not fac then
74965: LD_VAR 0 6
74969: NOT
74970: IFFALSE 75021
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74972: LD_ADDR_VAR 0 6
74976: PUSH
74977: LD_EXP 58
74981: PUSH
74982: LD_VAR 0 2
74986: ARRAY
74987: PPUSH
74988: LD_INT 2
74990: PUSH
74991: LD_INT 30
74993: PUSH
74994: LD_INT 0
74996: PUSH
74997: EMPTY
74998: LIST
74999: LIST
75000: PUSH
75001: LD_INT 30
75003: PUSH
75004: LD_INT 1
75006: PUSH
75007: EMPTY
75008: LIST
75009: LIST
75010: PUSH
75011: EMPTY
75012: LIST
75013: LIST
75014: LIST
75015: PPUSH
75016: CALL_OW 72
75020: ST_TO_ADDR
// if not fac then
75021: LD_VAR 0 6
75025: NOT
75026: IFFALSE 75030
// continue ;
75028: GO 74878
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75030: LD_ADDR_VAR 0 7
75034: PUSH
75035: LD_EXP 82
75039: PUSH
75040: LD_VAR 0 2
75044: ARRAY
75045: PPUSH
75046: LD_INT 22
75048: PUSH
75049: LD_VAR 0 5
75053: PUSH
75054: EMPTY
75055: LIST
75056: LIST
75057: PUSH
75058: LD_INT 21
75060: PUSH
75061: LD_INT 2
75063: PUSH
75064: EMPTY
75065: LIST
75066: LIST
75067: PUSH
75068: LD_INT 3
75070: PUSH
75071: LD_INT 24
75073: PUSH
75074: LD_INT 1000
75076: PUSH
75077: EMPTY
75078: LIST
75079: LIST
75080: PUSH
75081: EMPTY
75082: LIST
75083: LIST
75084: PUSH
75085: EMPTY
75086: LIST
75087: LIST
75088: LIST
75089: PPUSH
75090: CALL_OW 70
75094: ST_TO_ADDR
// for j in fac do
75095: LD_ADDR_VAR 0 3
75099: PUSH
75100: LD_VAR 0 6
75104: PUSH
75105: FOR_IN
75106: IFFALSE 75187
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75108: LD_ADDR_VAR 0 7
75112: PUSH
75113: LD_VAR 0 7
75117: PUSH
75118: LD_INT 22
75120: PUSH
75121: LD_VAR 0 5
75125: PUSH
75126: EMPTY
75127: LIST
75128: LIST
75129: PUSH
75130: LD_INT 91
75132: PUSH
75133: LD_VAR 0 3
75137: PUSH
75138: LD_INT 15
75140: PUSH
75141: EMPTY
75142: LIST
75143: LIST
75144: LIST
75145: PUSH
75146: LD_INT 21
75148: PUSH
75149: LD_INT 2
75151: PUSH
75152: EMPTY
75153: LIST
75154: LIST
75155: PUSH
75156: LD_INT 3
75158: PUSH
75159: LD_INT 24
75161: PUSH
75162: LD_INT 1000
75164: PUSH
75165: EMPTY
75166: LIST
75167: LIST
75168: PUSH
75169: EMPTY
75170: LIST
75171: LIST
75172: PUSH
75173: EMPTY
75174: LIST
75175: LIST
75176: LIST
75177: LIST
75178: PPUSH
75179: CALL_OW 69
75183: UNION
75184: ST_TO_ADDR
75185: GO 75105
75187: POP
75188: POP
// if not vehs then
75189: LD_VAR 0 7
75193: NOT
75194: IFFALSE 75220
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
75196: LD_ADDR_EXP 70
75200: PUSH
75201: LD_EXP 70
75205: PPUSH
75206: LD_VAR 0 2
75210: PPUSH
75211: EMPTY
75212: PPUSH
75213: CALL_OW 1
75217: ST_TO_ADDR
// continue ;
75218: GO 74878
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75220: LD_ADDR_VAR 0 8
75224: PUSH
75225: LD_EXP 58
75229: PUSH
75230: LD_VAR 0 2
75234: ARRAY
75235: PPUSH
75236: LD_INT 30
75238: PUSH
75239: LD_INT 3
75241: PUSH
75242: EMPTY
75243: LIST
75244: LIST
75245: PPUSH
75246: CALL_OW 72
75250: ST_TO_ADDR
// if tmp then
75251: LD_VAR 0 8
75255: IFFALSE 75358
// begin for j in tmp do
75257: LD_ADDR_VAR 0 3
75261: PUSH
75262: LD_VAR 0 8
75266: PUSH
75267: FOR_IN
75268: IFFALSE 75356
// for k in UnitsInside ( j ) do
75270: LD_ADDR_VAR 0 4
75274: PUSH
75275: LD_VAR 0 3
75279: PPUSH
75280: CALL_OW 313
75284: PUSH
75285: FOR_IN
75286: IFFALSE 75352
// if k then
75288: LD_VAR 0 4
75292: IFFALSE 75350
// if not k in mc_repair_vehicle [ i ] then
75294: LD_VAR 0 4
75298: PUSH
75299: LD_EXP 70
75303: PUSH
75304: LD_VAR 0 2
75308: ARRAY
75309: IN
75310: NOT
75311: IFFALSE 75350
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
75313: LD_ADDR_EXP 70
75317: PUSH
75318: LD_EXP 70
75322: PPUSH
75323: LD_VAR 0 2
75327: PPUSH
75328: LD_EXP 70
75332: PUSH
75333: LD_VAR 0 2
75337: ARRAY
75338: PUSH
75339: LD_VAR 0 4
75343: UNION
75344: PPUSH
75345: CALL_OW 1
75349: ST_TO_ADDR
75350: GO 75285
75352: POP
75353: POP
75354: GO 75267
75356: POP
75357: POP
// end ; if not mc_repair_vehicle [ i ] then
75358: LD_EXP 70
75362: PUSH
75363: LD_VAR 0 2
75367: ARRAY
75368: NOT
75369: IFFALSE 75373
// continue ;
75371: GO 74878
// for j in mc_repair_vehicle [ i ] do
75373: LD_ADDR_VAR 0 3
75377: PUSH
75378: LD_EXP 70
75382: PUSH
75383: LD_VAR 0 2
75387: ARRAY
75388: PUSH
75389: FOR_IN
75390: IFFALSE 75556
// begin if GetClass ( j ) <> 3 then
75392: LD_VAR 0 3
75396: PPUSH
75397: CALL_OW 257
75401: PUSH
75402: LD_INT 3
75404: NONEQUAL
75405: IFFALSE 75446
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
75407: LD_ADDR_EXP 70
75411: PUSH
75412: LD_EXP 70
75416: PPUSH
75417: LD_VAR 0 2
75421: PPUSH
75422: LD_EXP 70
75426: PUSH
75427: LD_VAR 0 2
75431: ARRAY
75432: PUSH
75433: LD_VAR 0 3
75437: DIFF
75438: PPUSH
75439: CALL_OW 1
75443: ST_TO_ADDR
// continue ;
75444: GO 75389
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75446: LD_VAR 0 3
75450: PPUSH
75451: CALL_OW 311
75455: NOT
75456: PUSH
75457: LD_VAR 0 3
75461: PUSH
75462: LD_EXP 61
75466: PUSH
75467: LD_VAR 0 2
75471: ARRAY
75472: PUSH
75473: LD_INT 1
75475: ARRAY
75476: IN
75477: NOT
75478: AND
75479: PUSH
75480: LD_VAR 0 3
75484: PUSH
75485: LD_EXP 61
75489: PUSH
75490: LD_VAR 0 2
75494: ARRAY
75495: PUSH
75496: LD_INT 2
75498: ARRAY
75499: IN
75500: NOT
75501: AND
75502: IFFALSE 75554
// begin if IsInUnit ( j ) then
75504: LD_VAR 0 3
75508: PPUSH
75509: CALL_OW 310
75513: IFFALSE 75524
// ComExitBuilding ( j ) ;
75515: LD_VAR 0 3
75519: PPUSH
75520: CALL_OW 122
// if not HasTask ( j ) then
75524: LD_VAR 0 3
75528: PPUSH
75529: CALL_OW 314
75533: NOT
75534: IFFALSE 75554
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
75536: LD_VAR 0 3
75540: PPUSH
75541: LD_VAR 0 7
75545: PUSH
75546: LD_INT 1
75548: ARRAY
75549: PPUSH
75550: CALL_OW 189
// end ; end ;
75554: GO 75389
75556: POP
75557: POP
// end ;
75558: GO 74878
75560: POP
75561: POP
// end ;
75562: LD_VAR 0 1
75566: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75567: LD_INT 0
75569: PPUSH
75570: PPUSH
75571: PPUSH
75572: PPUSH
75573: PPUSH
75574: PPUSH
75575: PPUSH
75576: PPUSH
75577: PPUSH
75578: PPUSH
75579: PPUSH
// if not mc_bases then
75580: LD_EXP 58
75584: NOT
75585: IFFALSE 75589
// exit ;
75587: GO 76391
// for i = 1 to mc_bases do
75589: LD_ADDR_VAR 0 2
75593: PUSH
75594: DOUBLE
75595: LD_INT 1
75597: DEC
75598: ST_TO_ADDR
75599: LD_EXP 58
75603: PUSH
75604: FOR_TO
75605: IFFALSE 76389
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75607: LD_EXP 86
75611: PUSH
75612: LD_VAR 0 2
75616: ARRAY
75617: NOT
75618: PUSH
75619: LD_EXP 61
75623: PUSH
75624: LD_VAR 0 2
75628: ARRAY
75629: PUSH
75630: LD_INT 1
75632: ARRAY
75633: OR
75634: PUSH
75635: LD_EXP 61
75639: PUSH
75640: LD_VAR 0 2
75644: ARRAY
75645: PUSH
75646: LD_INT 2
75648: ARRAY
75649: OR
75650: PUSH
75651: LD_EXP 84
75655: PUSH
75656: LD_VAR 0 2
75660: ARRAY
75661: PPUSH
75662: LD_INT 1
75664: PPUSH
75665: CALL_OW 325
75669: NOT
75670: OR
75671: PUSH
75672: LD_EXP 81
75676: PUSH
75677: LD_VAR 0 2
75681: ARRAY
75682: OR
75683: IFFALSE 75687
// continue ;
75685: GO 75604
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75687: LD_ADDR_VAR 0 8
75691: PUSH
75692: LD_EXP 58
75696: PUSH
75697: LD_VAR 0 2
75701: ARRAY
75702: PPUSH
75703: LD_INT 25
75705: PUSH
75706: LD_INT 4
75708: PUSH
75709: EMPTY
75710: LIST
75711: LIST
75712: PUSH
75713: LD_INT 50
75715: PUSH
75716: EMPTY
75717: LIST
75718: PUSH
75719: LD_INT 3
75721: PUSH
75722: LD_INT 60
75724: PUSH
75725: EMPTY
75726: LIST
75727: PUSH
75728: EMPTY
75729: LIST
75730: LIST
75731: PUSH
75732: EMPTY
75733: LIST
75734: LIST
75735: LIST
75736: PPUSH
75737: CALL_OW 72
75741: PUSH
75742: LD_EXP 62
75746: PUSH
75747: LD_VAR 0 2
75751: ARRAY
75752: DIFF
75753: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75754: LD_ADDR_VAR 0 9
75758: PUSH
75759: LD_EXP 58
75763: PUSH
75764: LD_VAR 0 2
75768: ARRAY
75769: PPUSH
75770: LD_INT 2
75772: PUSH
75773: LD_INT 30
75775: PUSH
75776: LD_INT 0
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: PUSH
75783: LD_INT 30
75785: PUSH
75786: LD_INT 1
75788: PUSH
75789: EMPTY
75790: LIST
75791: LIST
75792: PUSH
75793: EMPTY
75794: LIST
75795: LIST
75796: LIST
75797: PPUSH
75798: CALL_OW 72
75802: ST_TO_ADDR
// if not tmp or not dep then
75803: LD_VAR 0 8
75807: NOT
75808: PUSH
75809: LD_VAR 0 9
75813: NOT
75814: OR
75815: IFFALSE 75819
// continue ;
75817: GO 75604
// side := GetSide ( tmp [ 1 ] ) ;
75819: LD_ADDR_VAR 0 11
75823: PUSH
75824: LD_VAR 0 8
75828: PUSH
75829: LD_INT 1
75831: ARRAY
75832: PPUSH
75833: CALL_OW 255
75837: ST_TO_ADDR
// dep := dep [ 1 ] ;
75838: LD_ADDR_VAR 0 9
75842: PUSH
75843: LD_VAR 0 9
75847: PUSH
75848: LD_INT 1
75850: ARRAY
75851: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
75852: LD_ADDR_VAR 0 7
75856: PUSH
75857: LD_EXP 86
75861: PUSH
75862: LD_VAR 0 2
75866: ARRAY
75867: PPUSH
75868: LD_INT 22
75870: PUSH
75871: LD_INT 0
75873: PUSH
75874: EMPTY
75875: LIST
75876: LIST
75877: PUSH
75878: LD_INT 25
75880: PUSH
75881: LD_INT 12
75883: PUSH
75884: EMPTY
75885: LIST
75886: LIST
75887: PUSH
75888: EMPTY
75889: LIST
75890: LIST
75891: PPUSH
75892: CALL_OW 70
75896: PUSH
75897: LD_INT 22
75899: PUSH
75900: LD_INT 0
75902: PUSH
75903: EMPTY
75904: LIST
75905: LIST
75906: PUSH
75907: LD_INT 25
75909: PUSH
75910: LD_INT 12
75912: PUSH
75913: EMPTY
75914: LIST
75915: LIST
75916: PUSH
75917: LD_INT 91
75919: PUSH
75920: LD_VAR 0 9
75924: PUSH
75925: LD_INT 20
75927: PUSH
75928: EMPTY
75929: LIST
75930: LIST
75931: LIST
75932: PUSH
75933: EMPTY
75934: LIST
75935: LIST
75936: LIST
75937: PPUSH
75938: CALL_OW 69
75942: UNION
75943: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
75944: LD_ADDR_VAR 0 10
75948: PUSH
75949: LD_EXP 86
75953: PUSH
75954: LD_VAR 0 2
75958: ARRAY
75959: PPUSH
75960: LD_INT 81
75962: PUSH
75963: LD_VAR 0 11
75967: PUSH
75968: EMPTY
75969: LIST
75970: LIST
75971: PPUSH
75972: CALL_OW 70
75976: ST_TO_ADDR
// if not apes or danger_at_area then
75977: LD_VAR 0 7
75981: NOT
75982: PUSH
75983: LD_VAR 0 10
75987: OR
75988: IFFALSE 76038
// begin if mc_taming [ i ] then
75990: LD_EXP 89
75994: PUSH
75995: LD_VAR 0 2
75999: ARRAY
76000: IFFALSE 76036
// begin MC_Reset ( i , 121 ) ;
76002: LD_VAR 0 2
76006: PPUSH
76007: LD_INT 121
76009: PPUSH
76010: CALL 61369 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
76014: LD_ADDR_EXP 89
76018: PUSH
76019: LD_EXP 89
76023: PPUSH
76024: LD_VAR 0 2
76028: PPUSH
76029: EMPTY
76030: PPUSH
76031: CALL_OW 1
76035: ST_TO_ADDR
// end ; continue ;
76036: GO 75604
// end ; for j in tmp do
76038: LD_ADDR_VAR 0 3
76042: PUSH
76043: LD_VAR 0 8
76047: PUSH
76048: FOR_IN
76049: IFFALSE 76385
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
76051: LD_VAR 0 3
76055: PUSH
76056: LD_EXP 89
76060: PUSH
76061: LD_VAR 0 2
76065: ARRAY
76066: IN
76067: NOT
76068: PUSH
76069: LD_EXP 89
76073: PUSH
76074: LD_VAR 0 2
76078: ARRAY
76079: PUSH
76080: LD_INT 3
76082: LESS
76083: AND
76084: IFFALSE 76142
// begin SetTag ( j , 121 ) ;
76086: LD_VAR 0 3
76090: PPUSH
76091: LD_INT 121
76093: PPUSH
76094: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
76098: LD_ADDR_EXP 89
76102: PUSH
76103: LD_EXP 89
76107: PPUSH
76108: LD_VAR 0 2
76112: PUSH
76113: LD_EXP 89
76117: PUSH
76118: LD_VAR 0 2
76122: ARRAY
76123: PUSH
76124: LD_INT 1
76126: PLUS
76127: PUSH
76128: EMPTY
76129: LIST
76130: LIST
76131: PPUSH
76132: LD_VAR 0 3
76136: PPUSH
76137: CALL 21366 0 3
76141: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
76142: LD_VAR 0 3
76146: PUSH
76147: LD_EXP 89
76151: PUSH
76152: LD_VAR 0 2
76156: ARRAY
76157: IN
76158: IFFALSE 76383
// begin if GetClass ( j ) <> 4 then
76160: LD_VAR 0 3
76164: PPUSH
76165: CALL_OW 257
76169: PUSH
76170: LD_INT 4
76172: NONEQUAL
76173: IFFALSE 76226
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
76175: LD_ADDR_EXP 89
76179: PUSH
76180: LD_EXP 89
76184: PPUSH
76185: LD_VAR 0 2
76189: PPUSH
76190: LD_EXP 89
76194: PUSH
76195: LD_VAR 0 2
76199: ARRAY
76200: PUSH
76201: LD_VAR 0 3
76205: DIFF
76206: PPUSH
76207: CALL_OW 1
76211: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76212: LD_VAR 0 3
76216: PPUSH
76217: LD_INT 0
76219: PPUSH
76220: CALL_OW 109
// continue ;
76224: GO 76048
// end ; if IsInUnit ( j ) then
76226: LD_VAR 0 3
76230: PPUSH
76231: CALL_OW 310
76235: IFFALSE 76246
// ComExitBuilding ( j ) ;
76237: LD_VAR 0 3
76241: PPUSH
76242: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
76246: LD_ADDR_VAR 0 6
76250: PUSH
76251: LD_VAR 0 7
76255: PPUSH
76256: LD_VAR 0 3
76260: PPUSH
76261: CALL_OW 74
76265: ST_TO_ADDR
// if not ape then
76266: LD_VAR 0 6
76270: NOT
76271: IFFALSE 76275
// break ;
76273: GO 76385
// x := GetX ( ape ) ;
76275: LD_ADDR_VAR 0 4
76279: PUSH
76280: LD_VAR 0 6
76284: PPUSH
76285: CALL_OW 250
76289: ST_TO_ADDR
// y := GetY ( ape ) ;
76290: LD_ADDR_VAR 0 5
76294: PUSH
76295: LD_VAR 0 6
76299: PPUSH
76300: CALL_OW 251
76304: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76305: LD_VAR 0 4
76309: PPUSH
76310: LD_VAR 0 5
76314: PPUSH
76315: CALL_OW 488
76319: NOT
76320: PUSH
76321: LD_VAR 0 11
76325: PPUSH
76326: LD_VAR 0 4
76330: PPUSH
76331: LD_VAR 0 5
76335: PPUSH
76336: LD_INT 20
76338: PPUSH
76339: CALL 22262 0 4
76343: PUSH
76344: LD_INT 4
76346: ARRAY
76347: OR
76348: IFFALSE 76352
// break ;
76350: GO 76385
// if not HasTask ( j ) then
76352: LD_VAR 0 3
76356: PPUSH
76357: CALL_OW 314
76361: NOT
76362: IFFALSE 76383
// ComTameXY ( j , x , y ) ;
76364: LD_VAR 0 3
76368: PPUSH
76369: LD_VAR 0 4
76373: PPUSH
76374: LD_VAR 0 5
76378: PPUSH
76379: CALL_OW 131
// end ; end ;
76383: GO 76048
76385: POP
76386: POP
// end ;
76387: GO 75604
76389: POP
76390: POP
// end ;
76391: LD_VAR 0 1
76395: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
76396: LD_INT 0
76398: PPUSH
76399: PPUSH
76400: PPUSH
76401: PPUSH
76402: PPUSH
76403: PPUSH
76404: PPUSH
76405: PPUSH
// if not mc_bases then
76406: LD_EXP 58
76410: NOT
76411: IFFALSE 76415
// exit ;
76413: GO 77041
// for i = 1 to mc_bases do
76415: LD_ADDR_VAR 0 2
76419: PUSH
76420: DOUBLE
76421: LD_INT 1
76423: DEC
76424: ST_TO_ADDR
76425: LD_EXP 58
76429: PUSH
76430: FOR_TO
76431: IFFALSE 77039
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
76433: LD_EXP 87
76437: PUSH
76438: LD_VAR 0 2
76442: ARRAY
76443: NOT
76444: PUSH
76445: LD_EXP 87
76449: PUSH
76450: LD_VAR 0 2
76454: ARRAY
76455: PPUSH
76456: LD_INT 25
76458: PUSH
76459: LD_INT 12
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: PPUSH
76466: CALL_OW 72
76470: NOT
76471: OR
76472: IFFALSE 76476
// continue ;
76474: GO 76430
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
76476: LD_ADDR_VAR 0 5
76480: PUSH
76481: LD_EXP 87
76485: PUSH
76486: LD_VAR 0 2
76490: ARRAY
76491: PUSH
76492: LD_INT 1
76494: ARRAY
76495: PPUSH
76496: CALL_OW 255
76500: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
76501: LD_VAR 0 5
76505: PPUSH
76506: LD_INT 2
76508: PPUSH
76509: CALL_OW 325
76513: IFFALSE 76766
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76515: LD_ADDR_VAR 0 4
76519: PUSH
76520: LD_EXP 87
76524: PUSH
76525: LD_VAR 0 2
76529: ARRAY
76530: PPUSH
76531: LD_INT 25
76533: PUSH
76534: LD_INT 16
76536: PUSH
76537: EMPTY
76538: LIST
76539: LIST
76540: PPUSH
76541: CALL_OW 72
76545: ST_TO_ADDR
// if tmp < 6 then
76546: LD_VAR 0 4
76550: PUSH
76551: LD_INT 6
76553: LESS
76554: IFFALSE 76766
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76556: LD_ADDR_VAR 0 6
76560: PUSH
76561: LD_EXP 58
76565: PUSH
76566: LD_VAR 0 2
76570: ARRAY
76571: PPUSH
76572: LD_INT 2
76574: PUSH
76575: LD_INT 30
76577: PUSH
76578: LD_INT 0
76580: PUSH
76581: EMPTY
76582: LIST
76583: LIST
76584: PUSH
76585: LD_INT 30
76587: PUSH
76588: LD_INT 1
76590: PUSH
76591: EMPTY
76592: LIST
76593: LIST
76594: PUSH
76595: EMPTY
76596: LIST
76597: LIST
76598: LIST
76599: PPUSH
76600: CALL_OW 72
76604: ST_TO_ADDR
// if depot then
76605: LD_VAR 0 6
76609: IFFALSE 76766
// begin selected := 0 ;
76611: LD_ADDR_VAR 0 7
76615: PUSH
76616: LD_INT 0
76618: ST_TO_ADDR
// for j in depot do
76619: LD_ADDR_VAR 0 3
76623: PUSH
76624: LD_VAR 0 6
76628: PUSH
76629: FOR_IN
76630: IFFALSE 76661
// begin if UnitsInside ( j ) < 6 then
76632: LD_VAR 0 3
76636: PPUSH
76637: CALL_OW 313
76641: PUSH
76642: LD_INT 6
76644: LESS
76645: IFFALSE 76659
// begin selected := j ;
76647: LD_ADDR_VAR 0 7
76651: PUSH
76652: LD_VAR 0 3
76656: ST_TO_ADDR
// break ;
76657: GO 76661
// end ; end ;
76659: GO 76629
76661: POP
76662: POP
// if selected then
76663: LD_VAR 0 7
76667: IFFALSE 76766
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76669: LD_ADDR_VAR 0 3
76673: PUSH
76674: LD_EXP 87
76678: PUSH
76679: LD_VAR 0 2
76683: ARRAY
76684: PPUSH
76685: LD_INT 25
76687: PUSH
76688: LD_INT 12
76690: PUSH
76691: EMPTY
76692: LIST
76693: LIST
76694: PPUSH
76695: CALL_OW 72
76699: PUSH
76700: FOR_IN
76701: IFFALSE 76764
// if not HasTask ( j ) then
76703: LD_VAR 0 3
76707: PPUSH
76708: CALL_OW 314
76712: NOT
76713: IFFALSE 76762
// begin if not IsInUnit ( j ) then
76715: LD_VAR 0 3
76719: PPUSH
76720: CALL_OW 310
76724: NOT
76725: IFFALSE 76741
// ComEnterUnit ( j , selected ) ;
76727: LD_VAR 0 3
76731: PPUSH
76732: LD_VAR 0 7
76736: PPUSH
76737: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76741: LD_VAR 0 3
76745: PPUSH
76746: LD_INT 16
76748: PPUSH
76749: CALL_OW 183
// AddComExitBuilding ( j ) ;
76753: LD_VAR 0 3
76757: PPUSH
76758: CALL_OW 182
// end ;
76762: GO 76700
76764: POP
76765: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76766: LD_VAR 0 5
76770: PPUSH
76771: LD_INT 11
76773: PPUSH
76774: CALL_OW 325
76778: IFFALSE 77037
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76780: LD_ADDR_VAR 0 4
76784: PUSH
76785: LD_EXP 87
76789: PUSH
76790: LD_VAR 0 2
76794: ARRAY
76795: PPUSH
76796: LD_INT 25
76798: PUSH
76799: LD_INT 16
76801: PUSH
76802: EMPTY
76803: LIST
76804: LIST
76805: PPUSH
76806: CALL_OW 72
76810: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
76811: LD_VAR 0 4
76815: PUSH
76816: LD_INT 6
76818: GREATEREQUAL
76819: PUSH
76820: LD_VAR 0 5
76824: PPUSH
76825: LD_INT 2
76827: PPUSH
76828: CALL_OW 325
76832: NOT
76833: OR
76834: IFFALSE 77037
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76836: LD_ADDR_VAR 0 8
76840: PUSH
76841: LD_EXP 58
76845: PUSH
76846: LD_VAR 0 2
76850: ARRAY
76851: PPUSH
76852: LD_INT 2
76854: PUSH
76855: LD_INT 30
76857: PUSH
76858: LD_INT 4
76860: PUSH
76861: EMPTY
76862: LIST
76863: LIST
76864: PUSH
76865: LD_INT 30
76867: PUSH
76868: LD_INT 5
76870: PUSH
76871: EMPTY
76872: LIST
76873: LIST
76874: PUSH
76875: EMPTY
76876: LIST
76877: LIST
76878: LIST
76879: PPUSH
76880: CALL_OW 72
76884: ST_TO_ADDR
// if barracks then
76885: LD_VAR 0 8
76889: IFFALSE 77037
// begin selected := 0 ;
76891: LD_ADDR_VAR 0 7
76895: PUSH
76896: LD_INT 0
76898: ST_TO_ADDR
// for j in barracks do
76899: LD_ADDR_VAR 0 3
76903: PUSH
76904: LD_VAR 0 8
76908: PUSH
76909: FOR_IN
76910: IFFALSE 76941
// begin if UnitsInside ( j ) < 6 then
76912: LD_VAR 0 3
76916: PPUSH
76917: CALL_OW 313
76921: PUSH
76922: LD_INT 6
76924: LESS
76925: IFFALSE 76939
// begin selected := j ;
76927: LD_ADDR_VAR 0 7
76931: PUSH
76932: LD_VAR 0 3
76936: ST_TO_ADDR
// break ;
76937: GO 76941
// end ; end ;
76939: GO 76909
76941: POP
76942: POP
// if selected then
76943: LD_VAR 0 7
76947: IFFALSE 77037
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76949: LD_ADDR_VAR 0 3
76953: PUSH
76954: LD_EXP 87
76958: PUSH
76959: LD_VAR 0 2
76963: ARRAY
76964: PPUSH
76965: LD_INT 25
76967: PUSH
76968: LD_INT 12
76970: PUSH
76971: EMPTY
76972: LIST
76973: LIST
76974: PPUSH
76975: CALL_OW 72
76979: PUSH
76980: FOR_IN
76981: IFFALSE 77035
// if not IsInUnit ( j ) and not HasTask ( j ) then
76983: LD_VAR 0 3
76987: PPUSH
76988: CALL_OW 310
76992: NOT
76993: PUSH
76994: LD_VAR 0 3
76998: PPUSH
76999: CALL_OW 314
77003: NOT
77004: AND
77005: IFFALSE 77033
// begin ComEnterUnit ( j , selected ) ;
77007: LD_VAR 0 3
77011: PPUSH
77012: LD_VAR 0 7
77016: PPUSH
77017: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
77021: LD_VAR 0 3
77025: PPUSH
77026: LD_INT 15
77028: PPUSH
77029: CALL_OW 183
// end ;
77033: GO 76980
77035: POP
77036: POP
// end ; end ; end ; end ; end ;
77037: GO 76430
77039: POP
77040: POP
// end ;
77041: LD_VAR 0 1
77045: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
77046: LD_INT 0
77048: PPUSH
77049: PPUSH
77050: PPUSH
77051: PPUSH
// if not mc_bases then
77052: LD_EXP 58
77056: NOT
77057: IFFALSE 77061
// exit ;
77059: GO 77239
// for i = 1 to mc_bases do
77061: LD_ADDR_VAR 0 2
77065: PUSH
77066: DOUBLE
77067: LD_INT 1
77069: DEC
77070: ST_TO_ADDR
77071: LD_EXP 58
77075: PUSH
77076: FOR_TO
77077: IFFALSE 77237
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
77079: LD_ADDR_VAR 0 4
77083: PUSH
77084: LD_EXP 58
77088: PUSH
77089: LD_VAR 0 2
77093: ARRAY
77094: PPUSH
77095: LD_INT 25
77097: PUSH
77098: LD_INT 9
77100: PUSH
77101: EMPTY
77102: LIST
77103: LIST
77104: PPUSH
77105: CALL_OW 72
77109: ST_TO_ADDR
// if not tmp then
77110: LD_VAR 0 4
77114: NOT
77115: IFFALSE 77119
// continue ;
77117: GO 77076
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
77119: LD_EXP 84
77123: PUSH
77124: LD_VAR 0 2
77128: ARRAY
77129: PPUSH
77130: LD_INT 29
77132: PPUSH
77133: CALL_OW 325
77137: NOT
77138: PUSH
77139: LD_EXP 84
77143: PUSH
77144: LD_VAR 0 2
77148: ARRAY
77149: PPUSH
77150: LD_INT 28
77152: PPUSH
77153: CALL_OW 325
77157: NOT
77158: AND
77159: IFFALSE 77163
// continue ;
77161: GO 77076
// for j in tmp do
77163: LD_ADDR_VAR 0 3
77167: PUSH
77168: LD_VAR 0 4
77172: PUSH
77173: FOR_IN
77174: IFFALSE 77233
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
77176: LD_VAR 0 3
77180: PUSH
77181: LD_EXP 61
77185: PUSH
77186: LD_VAR 0 2
77190: ARRAY
77191: PUSH
77192: LD_INT 1
77194: ARRAY
77195: IN
77196: NOT
77197: PUSH
77198: LD_VAR 0 3
77202: PUSH
77203: LD_EXP 61
77207: PUSH
77208: LD_VAR 0 2
77212: ARRAY
77213: PUSH
77214: LD_INT 2
77216: ARRAY
77217: IN
77218: NOT
77219: AND
77220: IFFALSE 77231
// ComSpaceTimeShoot ( j ) ;
77222: LD_VAR 0 3
77226: PPUSH
77227: CALL 14952 0 1
77231: GO 77173
77233: POP
77234: POP
// end ;
77235: GO 77076
77237: POP
77238: POP
// end ;
77239: LD_VAR 0 1
77243: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
77244: LD_INT 0
77246: PPUSH
77247: PPUSH
77248: PPUSH
77249: PPUSH
77250: PPUSH
77251: PPUSH
77252: PPUSH
77253: PPUSH
77254: PPUSH
// if not mc_bases then
77255: LD_EXP 58
77259: NOT
77260: IFFALSE 77264
// exit ;
77262: GO 77886
// for i = 1 to mc_bases do
77264: LD_ADDR_VAR 0 2
77268: PUSH
77269: DOUBLE
77270: LD_INT 1
77272: DEC
77273: ST_TO_ADDR
77274: LD_EXP 58
77278: PUSH
77279: FOR_TO
77280: IFFALSE 77884
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
77282: LD_EXP 93
77286: PUSH
77287: LD_VAR 0 2
77291: ARRAY
77292: NOT
77293: PUSH
77294: LD_INT 38
77296: PPUSH
77297: LD_EXP 84
77301: PUSH
77302: LD_VAR 0 2
77306: ARRAY
77307: PPUSH
77308: CALL_OW 321
77312: PUSH
77313: LD_INT 2
77315: NONEQUAL
77316: OR
77317: IFFALSE 77321
// continue ;
77319: GO 77279
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
77321: LD_ADDR_VAR 0 8
77325: PUSH
77326: LD_EXP 58
77330: PUSH
77331: LD_VAR 0 2
77335: ARRAY
77336: PPUSH
77337: LD_INT 30
77339: PUSH
77340: LD_INT 34
77342: PUSH
77343: EMPTY
77344: LIST
77345: LIST
77346: PPUSH
77347: CALL_OW 72
77351: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
77352: LD_ADDR_VAR 0 9
77356: PUSH
77357: LD_EXP 58
77361: PUSH
77362: LD_VAR 0 2
77366: ARRAY
77367: PPUSH
77368: LD_INT 25
77370: PUSH
77371: LD_INT 4
77373: PUSH
77374: EMPTY
77375: LIST
77376: LIST
77377: PPUSH
77378: CALL_OW 72
77382: PPUSH
77383: LD_INT 0
77385: PPUSH
77386: CALL 54626 0 2
77390: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
77391: LD_VAR 0 9
77395: NOT
77396: PUSH
77397: LD_VAR 0 8
77401: NOT
77402: OR
77403: PUSH
77404: LD_EXP 58
77408: PUSH
77409: LD_VAR 0 2
77413: ARRAY
77414: PPUSH
77415: LD_INT 124
77417: PPUSH
77418: CALL 54626 0 2
77422: OR
77423: IFFALSE 77427
// continue ;
77425: GO 77279
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
77427: LD_EXP 94
77431: PUSH
77432: LD_VAR 0 2
77436: ARRAY
77437: PUSH
77438: LD_EXP 93
77442: PUSH
77443: LD_VAR 0 2
77447: ARRAY
77448: LESS
77449: PUSH
77450: LD_EXP 94
77454: PUSH
77455: LD_VAR 0 2
77459: ARRAY
77460: PUSH
77461: LD_VAR 0 8
77465: LESS
77466: AND
77467: IFFALSE 77882
// begin tmp := sci [ 1 ] ;
77469: LD_ADDR_VAR 0 7
77473: PUSH
77474: LD_VAR 0 9
77478: PUSH
77479: LD_INT 1
77481: ARRAY
77482: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
77483: LD_VAR 0 7
77487: PPUSH
77488: LD_INT 124
77490: PPUSH
77491: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
77495: LD_ADDR_VAR 0 3
77499: PUSH
77500: DOUBLE
77501: LD_EXP 93
77505: PUSH
77506: LD_VAR 0 2
77510: ARRAY
77511: INC
77512: ST_TO_ADDR
77513: LD_EXP 93
77517: PUSH
77518: LD_VAR 0 2
77522: ARRAY
77523: PUSH
77524: FOR_DOWNTO
77525: IFFALSE 77868
// begin if IsInUnit ( tmp ) then
77527: LD_VAR 0 7
77531: PPUSH
77532: CALL_OW 310
77536: IFFALSE 77547
// ComExitBuilding ( tmp ) ;
77538: LD_VAR 0 7
77542: PPUSH
77543: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77547: LD_INT 35
77549: PPUSH
77550: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77554: LD_VAR 0 7
77558: PPUSH
77559: CALL_OW 310
77563: NOT
77564: PUSH
77565: LD_VAR 0 7
77569: PPUSH
77570: CALL_OW 314
77574: NOT
77575: AND
77576: IFFALSE 77547
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77578: LD_ADDR_VAR 0 6
77582: PUSH
77583: LD_VAR 0 7
77587: PPUSH
77588: CALL_OW 250
77592: PUSH
77593: LD_VAR 0 7
77597: PPUSH
77598: CALL_OW 251
77602: PUSH
77603: EMPTY
77604: LIST
77605: LIST
77606: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77607: LD_INT 35
77609: PPUSH
77610: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77614: LD_ADDR_VAR 0 4
77618: PUSH
77619: LD_EXP 93
77623: PUSH
77624: LD_VAR 0 2
77628: ARRAY
77629: PUSH
77630: LD_VAR 0 3
77634: ARRAY
77635: PUSH
77636: LD_INT 1
77638: ARRAY
77639: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77640: LD_ADDR_VAR 0 5
77644: PUSH
77645: LD_EXP 93
77649: PUSH
77650: LD_VAR 0 2
77654: ARRAY
77655: PUSH
77656: LD_VAR 0 3
77660: ARRAY
77661: PUSH
77662: LD_INT 2
77664: ARRAY
77665: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77666: LD_VAR 0 7
77670: PPUSH
77671: LD_INT 10
77673: PPUSH
77674: CALL 23959 0 2
77678: PUSH
77679: LD_INT 4
77681: ARRAY
77682: IFFALSE 77720
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77684: LD_VAR 0 7
77688: PPUSH
77689: LD_VAR 0 6
77693: PUSH
77694: LD_INT 1
77696: ARRAY
77697: PPUSH
77698: LD_VAR 0 6
77702: PUSH
77703: LD_INT 2
77705: ARRAY
77706: PPUSH
77707: CALL_OW 111
// wait ( 0 0$10 ) ;
77711: LD_INT 350
77713: PPUSH
77714: CALL_OW 67
// end else
77718: GO 77746
// begin ComMoveXY ( tmp , x , y ) ;
77720: LD_VAR 0 7
77724: PPUSH
77725: LD_VAR 0 4
77729: PPUSH
77730: LD_VAR 0 5
77734: PPUSH
77735: CALL_OW 111
// wait ( 0 0$3 ) ;
77739: LD_INT 105
77741: PPUSH
77742: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77746: LD_VAR 0 7
77750: PPUSH
77751: LD_VAR 0 4
77755: PPUSH
77756: LD_VAR 0 5
77760: PPUSH
77761: CALL_OW 307
77765: IFFALSE 77607
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77767: LD_VAR 0 7
77771: PPUSH
77772: LD_VAR 0 4
77776: PPUSH
77777: LD_VAR 0 5
77781: PPUSH
77782: LD_VAR 0 8
77786: PUSH
77787: LD_VAR 0 3
77791: ARRAY
77792: PPUSH
77793: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77797: LD_INT 35
77799: PPUSH
77800: CALL_OW 67
// until not HasTask ( tmp ) ;
77804: LD_VAR 0 7
77808: PPUSH
77809: CALL_OW 314
77813: NOT
77814: IFFALSE 77797
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
77816: LD_ADDR_EXP 94
77820: PUSH
77821: LD_EXP 94
77825: PPUSH
77826: LD_VAR 0 2
77830: PUSH
77831: LD_EXP 94
77835: PUSH
77836: LD_VAR 0 2
77840: ARRAY
77841: PUSH
77842: LD_INT 1
77844: PLUS
77845: PUSH
77846: EMPTY
77847: LIST
77848: LIST
77849: PPUSH
77850: LD_VAR 0 8
77854: PUSH
77855: LD_VAR 0 3
77859: ARRAY
77860: PPUSH
77861: CALL 21366 0 3
77865: ST_TO_ADDR
// end ;
77866: GO 77524
77868: POP
77869: POP
// MC_Reset ( i , 124 ) ;
77870: LD_VAR 0 2
77874: PPUSH
77875: LD_INT 124
77877: PPUSH
77878: CALL 61369 0 2
// end ; end ;
77882: GO 77279
77884: POP
77885: POP
// end ;
77886: LD_VAR 0 1
77890: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
77891: LD_INT 0
77893: PPUSH
77894: PPUSH
77895: PPUSH
// if not mc_bases then
77896: LD_EXP 58
77900: NOT
77901: IFFALSE 77905
// exit ;
77903: GO 78511
// for i = 1 to mc_bases do
77905: LD_ADDR_VAR 0 2
77909: PUSH
77910: DOUBLE
77911: LD_INT 1
77913: DEC
77914: ST_TO_ADDR
77915: LD_EXP 58
77919: PUSH
77920: FOR_TO
77921: IFFALSE 78509
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
77923: LD_ADDR_VAR 0 3
77927: PUSH
77928: LD_EXP 58
77932: PUSH
77933: LD_VAR 0 2
77937: ARRAY
77938: PPUSH
77939: LD_INT 25
77941: PUSH
77942: LD_INT 4
77944: PUSH
77945: EMPTY
77946: LIST
77947: LIST
77948: PPUSH
77949: CALL_OW 72
77953: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
77954: LD_VAR 0 3
77958: NOT
77959: PUSH
77960: LD_EXP 95
77964: PUSH
77965: LD_VAR 0 2
77969: ARRAY
77970: NOT
77971: OR
77972: PUSH
77973: LD_EXP 58
77977: PUSH
77978: LD_VAR 0 2
77982: ARRAY
77983: PPUSH
77984: LD_INT 2
77986: PUSH
77987: LD_INT 30
77989: PUSH
77990: LD_INT 0
77992: PUSH
77993: EMPTY
77994: LIST
77995: LIST
77996: PUSH
77997: LD_INT 30
77999: PUSH
78000: LD_INT 1
78002: PUSH
78003: EMPTY
78004: LIST
78005: LIST
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: LIST
78011: PPUSH
78012: CALL_OW 72
78016: NOT
78017: OR
78018: IFFALSE 78068
// begin if mc_deposits_finder [ i ] then
78020: LD_EXP 96
78024: PUSH
78025: LD_VAR 0 2
78029: ARRAY
78030: IFFALSE 78066
// begin MC_Reset ( i , 125 ) ;
78032: LD_VAR 0 2
78036: PPUSH
78037: LD_INT 125
78039: PPUSH
78040: CALL 61369 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78044: LD_ADDR_EXP 96
78048: PUSH
78049: LD_EXP 96
78053: PPUSH
78054: LD_VAR 0 2
78058: PPUSH
78059: EMPTY
78060: PPUSH
78061: CALL_OW 1
78065: ST_TO_ADDR
// end ; continue ;
78066: GO 77920
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
78068: LD_EXP 95
78072: PUSH
78073: LD_VAR 0 2
78077: ARRAY
78078: PUSH
78079: LD_INT 1
78081: ARRAY
78082: PUSH
78083: LD_INT 3
78085: ARRAY
78086: PUSH
78087: LD_INT 1
78089: EQUAL
78090: PUSH
78091: LD_INT 20
78093: PPUSH
78094: LD_EXP 84
78098: PUSH
78099: LD_VAR 0 2
78103: ARRAY
78104: PPUSH
78105: CALL_OW 321
78109: PUSH
78110: LD_INT 2
78112: NONEQUAL
78113: AND
78114: IFFALSE 78164
// begin if mc_deposits_finder [ i ] then
78116: LD_EXP 96
78120: PUSH
78121: LD_VAR 0 2
78125: ARRAY
78126: IFFALSE 78162
// begin MC_Reset ( i , 125 ) ;
78128: LD_VAR 0 2
78132: PPUSH
78133: LD_INT 125
78135: PPUSH
78136: CALL 61369 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78140: LD_ADDR_EXP 96
78144: PUSH
78145: LD_EXP 96
78149: PPUSH
78150: LD_VAR 0 2
78154: PPUSH
78155: EMPTY
78156: PPUSH
78157: CALL_OW 1
78161: ST_TO_ADDR
// end ; continue ;
78162: GO 77920
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
78164: LD_EXP 95
78168: PUSH
78169: LD_VAR 0 2
78173: ARRAY
78174: PUSH
78175: LD_INT 1
78177: ARRAY
78178: PUSH
78179: LD_INT 1
78181: ARRAY
78182: PPUSH
78183: LD_EXP 95
78187: PUSH
78188: LD_VAR 0 2
78192: ARRAY
78193: PUSH
78194: LD_INT 1
78196: ARRAY
78197: PUSH
78198: LD_INT 2
78200: ARRAY
78201: PPUSH
78202: LD_EXP 84
78206: PUSH
78207: LD_VAR 0 2
78211: ARRAY
78212: PPUSH
78213: CALL_OW 440
78217: IFFALSE 78260
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
78219: LD_ADDR_EXP 95
78223: PUSH
78224: LD_EXP 95
78228: PPUSH
78229: LD_VAR 0 2
78233: PPUSH
78234: LD_EXP 95
78238: PUSH
78239: LD_VAR 0 2
78243: ARRAY
78244: PPUSH
78245: LD_INT 1
78247: PPUSH
78248: CALL_OW 3
78252: PPUSH
78253: CALL_OW 1
78257: ST_TO_ADDR
78258: GO 78507
// begin if not mc_deposits_finder [ i ] then
78260: LD_EXP 96
78264: PUSH
78265: LD_VAR 0 2
78269: ARRAY
78270: NOT
78271: IFFALSE 78323
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
78273: LD_ADDR_EXP 96
78277: PUSH
78278: LD_EXP 96
78282: PPUSH
78283: LD_VAR 0 2
78287: PPUSH
78288: LD_VAR 0 3
78292: PUSH
78293: LD_INT 1
78295: ARRAY
78296: PUSH
78297: EMPTY
78298: LIST
78299: PPUSH
78300: CALL_OW 1
78304: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
78305: LD_VAR 0 3
78309: PUSH
78310: LD_INT 1
78312: ARRAY
78313: PPUSH
78314: LD_INT 125
78316: PPUSH
78317: CALL_OW 109
// end else
78321: GO 78507
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
78323: LD_EXP 96
78327: PUSH
78328: LD_VAR 0 2
78332: ARRAY
78333: PUSH
78334: LD_INT 1
78336: ARRAY
78337: PPUSH
78338: CALL_OW 310
78342: IFFALSE 78365
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
78344: LD_EXP 96
78348: PUSH
78349: LD_VAR 0 2
78353: ARRAY
78354: PUSH
78355: LD_INT 1
78357: ARRAY
78358: PPUSH
78359: CALL_OW 122
78363: GO 78507
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
78365: LD_EXP 96
78369: PUSH
78370: LD_VAR 0 2
78374: ARRAY
78375: PUSH
78376: LD_INT 1
78378: ARRAY
78379: PPUSH
78380: CALL_OW 314
78384: NOT
78385: PUSH
78386: LD_EXP 96
78390: PUSH
78391: LD_VAR 0 2
78395: ARRAY
78396: PUSH
78397: LD_INT 1
78399: ARRAY
78400: PPUSH
78401: LD_EXP 95
78405: PUSH
78406: LD_VAR 0 2
78410: ARRAY
78411: PUSH
78412: LD_INT 1
78414: ARRAY
78415: PUSH
78416: LD_INT 1
78418: ARRAY
78419: PPUSH
78420: LD_EXP 95
78424: PUSH
78425: LD_VAR 0 2
78429: ARRAY
78430: PUSH
78431: LD_INT 1
78433: ARRAY
78434: PUSH
78435: LD_INT 2
78437: ARRAY
78438: PPUSH
78439: CALL_OW 297
78443: PUSH
78444: LD_INT 6
78446: GREATER
78447: AND
78448: IFFALSE 78507
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
78450: LD_EXP 96
78454: PUSH
78455: LD_VAR 0 2
78459: ARRAY
78460: PUSH
78461: LD_INT 1
78463: ARRAY
78464: PPUSH
78465: LD_EXP 95
78469: PUSH
78470: LD_VAR 0 2
78474: ARRAY
78475: PUSH
78476: LD_INT 1
78478: ARRAY
78479: PUSH
78480: LD_INT 1
78482: ARRAY
78483: PPUSH
78484: LD_EXP 95
78488: PUSH
78489: LD_VAR 0 2
78493: ARRAY
78494: PUSH
78495: LD_INT 1
78497: ARRAY
78498: PUSH
78499: LD_INT 2
78501: ARRAY
78502: PPUSH
78503: CALL_OW 111
// end ; end ; end ;
78507: GO 77920
78509: POP
78510: POP
// end ;
78511: LD_VAR 0 1
78515: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
78516: LD_INT 0
78518: PPUSH
78519: PPUSH
78520: PPUSH
78521: PPUSH
78522: PPUSH
78523: PPUSH
78524: PPUSH
78525: PPUSH
78526: PPUSH
78527: PPUSH
78528: PPUSH
// if not mc_bases then
78529: LD_EXP 58
78533: NOT
78534: IFFALSE 78538
// exit ;
78536: GO 79478
// for i = 1 to mc_bases do
78538: LD_ADDR_VAR 0 2
78542: PUSH
78543: DOUBLE
78544: LD_INT 1
78546: DEC
78547: ST_TO_ADDR
78548: LD_EXP 58
78552: PUSH
78553: FOR_TO
78554: IFFALSE 79476
// begin if not mc_bases [ i ] or mc_scan [ i ] then
78556: LD_EXP 58
78560: PUSH
78561: LD_VAR 0 2
78565: ARRAY
78566: NOT
78567: PUSH
78568: LD_EXP 81
78572: PUSH
78573: LD_VAR 0 2
78577: ARRAY
78578: OR
78579: IFFALSE 78583
// continue ;
78581: GO 78553
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78583: LD_ADDR_VAR 0 7
78587: PUSH
78588: LD_EXP 58
78592: PUSH
78593: LD_VAR 0 2
78597: ARRAY
78598: PUSH
78599: LD_INT 1
78601: ARRAY
78602: PPUSH
78603: CALL_OW 248
78607: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78608: LD_VAR 0 7
78612: PUSH
78613: LD_INT 3
78615: EQUAL
78616: PUSH
78617: LD_EXP 77
78621: PUSH
78622: LD_VAR 0 2
78626: ARRAY
78627: PUSH
78628: LD_EXP 80
78632: PUSH
78633: LD_VAR 0 2
78637: ARRAY
78638: UNION
78639: PPUSH
78640: LD_INT 33
78642: PUSH
78643: LD_INT 2
78645: PUSH
78646: EMPTY
78647: LIST
78648: LIST
78649: PPUSH
78650: CALL_OW 72
78654: NOT
78655: OR
78656: IFFALSE 78660
// continue ;
78658: GO 78553
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78660: LD_ADDR_VAR 0 9
78664: PUSH
78665: LD_EXP 58
78669: PUSH
78670: LD_VAR 0 2
78674: ARRAY
78675: PPUSH
78676: LD_INT 30
78678: PUSH
78679: LD_INT 36
78681: PUSH
78682: EMPTY
78683: LIST
78684: LIST
78685: PPUSH
78686: CALL_OW 72
78690: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78691: LD_ADDR_VAR 0 10
78695: PUSH
78696: LD_EXP 77
78700: PUSH
78701: LD_VAR 0 2
78705: ARRAY
78706: PPUSH
78707: LD_INT 34
78709: PUSH
78710: LD_INT 31
78712: PUSH
78713: EMPTY
78714: LIST
78715: LIST
78716: PPUSH
78717: CALL_OW 72
78721: ST_TO_ADDR
// if not cts and not mcts then
78722: LD_VAR 0 9
78726: NOT
78727: PUSH
78728: LD_VAR 0 10
78732: NOT
78733: AND
78734: IFFALSE 78738
// continue ;
78736: GO 78553
// x := cts ;
78738: LD_ADDR_VAR 0 11
78742: PUSH
78743: LD_VAR 0 9
78747: ST_TO_ADDR
// if not x then
78748: LD_VAR 0 11
78752: NOT
78753: IFFALSE 78765
// x := mcts ;
78755: LD_ADDR_VAR 0 11
78759: PUSH
78760: LD_VAR 0 10
78764: ST_TO_ADDR
// if not x then
78765: LD_VAR 0 11
78769: NOT
78770: IFFALSE 78774
// continue ;
78772: GO 78553
// if mc_remote_driver [ i ] then
78774: LD_EXP 98
78778: PUSH
78779: LD_VAR 0 2
78783: ARRAY
78784: IFFALSE 79171
// for j in mc_remote_driver [ i ] do
78786: LD_ADDR_VAR 0 3
78790: PUSH
78791: LD_EXP 98
78795: PUSH
78796: LD_VAR 0 2
78800: ARRAY
78801: PUSH
78802: FOR_IN
78803: IFFALSE 79169
// begin if GetClass ( j ) <> 3 then
78805: LD_VAR 0 3
78809: PPUSH
78810: CALL_OW 257
78814: PUSH
78815: LD_INT 3
78817: NONEQUAL
78818: IFFALSE 78871
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
78820: LD_ADDR_EXP 98
78824: PUSH
78825: LD_EXP 98
78829: PPUSH
78830: LD_VAR 0 2
78834: PPUSH
78835: LD_EXP 98
78839: PUSH
78840: LD_VAR 0 2
78844: ARRAY
78845: PUSH
78846: LD_VAR 0 3
78850: DIFF
78851: PPUSH
78852: CALL_OW 1
78856: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78857: LD_VAR 0 3
78861: PPUSH
78862: LD_INT 0
78864: PPUSH
78865: CALL_OW 109
// continue ;
78869: GO 78802
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
78871: LD_EXP 77
78875: PUSH
78876: LD_VAR 0 2
78880: ARRAY
78881: PPUSH
78882: LD_INT 34
78884: PUSH
78885: LD_INT 31
78887: PUSH
78888: EMPTY
78889: LIST
78890: LIST
78891: PUSH
78892: LD_INT 58
78894: PUSH
78895: EMPTY
78896: LIST
78897: PUSH
78898: EMPTY
78899: LIST
78900: LIST
78901: PPUSH
78902: CALL_OW 72
78906: PUSH
78907: LD_VAR 0 3
78911: PPUSH
78912: CALL 54714 0 1
78916: NOT
78917: AND
78918: IFFALSE 78989
// begin if IsInUnit ( j ) then
78920: LD_VAR 0 3
78924: PPUSH
78925: CALL_OW 310
78929: IFFALSE 78940
// ComExitBuilding ( j ) ;
78931: LD_VAR 0 3
78935: PPUSH
78936: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
78940: LD_VAR 0 3
78944: PPUSH
78945: LD_EXP 77
78949: PUSH
78950: LD_VAR 0 2
78954: ARRAY
78955: PPUSH
78956: LD_INT 34
78958: PUSH
78959: LD_INT 31
78961: PUSH
78962: EMPTY
78963: LIST
78964: LIST
78965: PUSH
78966: LD_INT 58
78968: PUSH
78969: EMPTY
78970: LIST
78971: PUSH
78972: EMPTY
78973: LIST
78974: LIST
78975: PPUSH
78976: CALL_OW 72
78980: PUSH
78981: LD_INT 1
78983: ARRAY
78984: PPUSH
78985: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
78989: LD_VAR 0 3
78993: PPUSH
78994: CALL_OW 310
78998: NOT
78999: PUSH
79000: LD_VAR 0 3
79004: PPUSH
79005: CALL_OW 310
79009: PPUSH
79010: CALL_OW 266
79014: PUSH
79015: LD_INT 36
79017: NONEQUAL
79018: PUSH
79019: LD_VAR 0 3
79023: PPUSH
79024: CALL 54714 0 1
79028: NOT
79029: AND
79030: OR
79031: IFFALSE 79167
// begin if IsInUnit ( j ) then
79033: LD_VAR 0 3
79037: PPUSH
79038: CALL_OW 310
79042: IFFALSE 79053
// ComExitBuilding ( j ) ;
79044: LD_VAR 0 3
79048: PPUSH
79049: CALL_OW 122
// ct := 0 ;
79053: LD_ADDR_VAR 0 8
79057: PUSH
79058: LD_INT 0
79060: ST_TO_ADDR
// for k in x do
79061: LD_ADDR_VAR 0 4
79065: PUSH
79066: LD_VAR 0 11
79070: PUSH
79071: FOR_IN
79072: IFFALSE 79145
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
79074: LD_VAR 0 4
79078: PPUSH
79079: CALL_OW 264
79083: PUSH
79084: LD_INT 31
79086: EQUAL
79087: PUSH
79088: LD_VAR 0 4
79092: PPUSH
79093: CALL_OW 311
79097: NOT
79098: AND
79099: PUSH
79100: LD_VAR 0 4
79104: PPUSH
79105: CALL_OW 266
79109: PUSH
79110: LD_INT 36
79112: EQUAL
79113: PUSH
79114: LD_VAR 0 4
79118: PPUSH
79119: CALL_OW 313
79123: PUSH
79124: LD_INT 3
79126: LESS
79127: AND
79128: OR
79129: IFFALSE 79143
// begin ct := k ;
79131: LD_ADDR_VAR 0 8
79135: PUSH
79136: LD_VAR 0 4
79140: ST_TO_ADDR
// break ;
79141: GO 79145
// end ;
79143: GO 79071
79145: POP
79146: POP
// if ct then
79147: LD_VAR 0 8
79151: IFFALSE 79167
// ComEnterUnit ( j , ct ) ;
79153: LD_VAR 0 3
79157: PPUSH
79158: LD_VAR 0 8
79162: PPUSH
79163: CALL_OW 120
// end ; end ;
79167: GO 78802
79169: POP
79170: POP
// places := 0 ;
79171: LD_ADDR_VAR 0 5
79175: PUSH
79176: LD_INT 0
79178: ST_TO_ADDR
// for j = 1 to x do
79179: LD_ADDR_VAR 0 3
79183: PUSH
79184: DOUBLE
79185: LD_INT 1
79187: DEC
79188: ST_TO_ADDR
79189: LD_VAR 0 11
79193: PUSH
79194: FOR_TO
79195: IFFALSE 79271
// if GetWeapon ( x [ j ] ) = ar_control_tower then
79197: LD_VAR 0 11
79201: PUSH
79202: LD_VAR 0 3
79206: ARRAY
79207: PPUSH
79208: CALL_OW 264
79212: PUSH
79213: LD_INT 31
79215: EQUAL
79216: IFFALSE 79234
// places := places + 1 else
79218: LD_ADDR_VAR 0 5
79222: PUSH
79223: LD_VAR 0 5
79227: PUSH
79228: LD_INT 1
79230: PLUS
79231: ST_TO_ADDR
79232: GO 79269
// if GetBType ( x [ j ] ) = b_control_tower then
79234: LD_VAR 0 11
79238: PUSH
79239: LD_VAR 0 3
79243: ARRAY
79244: PPUSH
79245: CALL_OW 266
79249: PUSH
79250: LD_INT 36
79252: EQUAL
79253: IFFALSE 79269
// places := places + 3 ;
79255: LD_ADDR_VAR 0 5
79259: PUSH
79260: LD_VAR 0 5
79264: PUSH
79265: LD_INT 3
79267: PLUS
79268: ST_TO_ADDR
79269: GO 79194
79271: POP
79272: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
79273: LD_VAR 0 5
79277: PUSH
79278: LD_INT 0
79280: EQUAL
79281: PUSH
79282: LD_VAR 0 5
79286: PUSH
79287: LD_EXP 98
79291: PUSH
79292: LD_VAR 0 2
79296: ARRAY
79297: LESSEQUAL
79298: OR
79299: IFFALSE 79303
// continue ;
79301: GO 78553
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
79303: LD_ADDR_VAR 0 6
79307: PUSH
79308: LD_EXP 58
79312: PUSH
79313: LD_VAR 0 2
79317: ARRAY
79318: PPUSH
79319: LD_INT 25
79321: PUSH
79322: LD_INT 3
79324: PUSH
79325: EMPTY
79326: LIST
79327: LIST
79328: PPUSH
79329: CALL_OW 72
79333: PUSH
79334: LD_EXP 98
79338: PUSH
79339: LD_VAR 0 2
79343: ARRAY
79344: DIFF
79345: PPUSH
79346: LD_INT 3
79348: PPUSH
79349: CALL 55614 0 2
79353: ST_TO_ADDR
// for j in tmp do
79354: LD_ADDR_VAR 0 3
79358: PUSH
79359: LD_VAR 0 6
79363: PUSH
79364: FOR_IN
79365: IFFALSE 79400
// if GetTag ( j ) > 0 then
79367: LD_VAR 0 3
79371: PPUSH
79372: CALL_OW 110
79376: PUSH
79377: LD_INT 0
79379: GREATER
79380: IFFALSE 79398
// tmp := tmp diff j ;
79382: LD_ADDR_VAR 0 6
79386: PUSH
79387: LD_VAR 0 6
79391: PUSH
79392: LD_VAR 0 3
79396: DIFF
79397: ST_TO_ADDR
79398: GO 79364
79400: POP
79401: POP
// if not tmp then
79402: LD_VAR 0 6
79406: NOT
79407: IFFALSE 79411
// continue ;
79409: GO 78553
// if places then
79411: LD_VAR 0 5
79415: IFFALSE 79474
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
79417: LD_ADDR_EXP 98
79421: PUSH
79422: LD_EXP 98
79426: PPUSH
79427: LD_VAR 0 2
79431: PPUSH
79432: LD_EXP 98
79436: PUSH
79437: LD_VAR 0 2
79441: ARRAY
79442: PUSH
79443: LD_VAR 0 6
79447: PUSH
79448: LD_INT 1
79450: ARRAY
79451: UNION
79452: PPUSH
79453: CALL_OW 1
79457: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
79458: LD_VAR 0 6
79462: PUSH
79463: LD_INT 1
79465: ARRAY
79466: PPUSH
79467: LD_INT 126
79469: PPUSH
79470: CALL_OW 109
// end ; end ;
79474: GO 78553
79476: POP
79477: POP
// end ;
79478: LD_VAR 0 1
79482: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
79483: LD_INT 0
79485: PPUSH
79486: PPUSH
79487: PPUSH
79488: PPUSH
79489: PPUSH
79490: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
79491: LD_VAR 0 1
79495: NOT
79496: PUSH
79497: LD_VAR 0 2
79501: NOT
79502: OR
79503: PUSH
79504: LD_VAR 0 3
79508: NOT
79509: OR
79510: PUSH
79511: LD_VAR 0 4
79515: PUSH
79516: LD_INT 1
79518: PUSH
79519: LD_INT 2
79521: PUSH
79522: LD_INT 3
79524: PUSH
79525: LD_INT 4
79527: PUSH
79528: LD_INT 5
79530: PUSH
79531: LD_INT 8
79533: PUSH
79534: LD_INT 9
79536: PUSH
79537: LD_INT 15
79539: PUSH
79540: LD_INT 16
79542: PUSH
79543: EMPTY
79544: LIST
79545: LIST
79546: LIST
79547: LIST
79548: LIST
79549: LIST
79550: LIST
79551: LIST
79552: LIST
79553: IN
79554: NOT
79555: OR
79556: IFFALSE 79560
// exit ;
79558: GO 80460
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
79560: LD_ADDR_VAR 0 2
79564: PUSH
79565: LD_VAR 0 2
79569: PPUSH
79570: LD_INT 21
79572: PUSH
79573: LD_INT 3
79575: PUSH
79576: EMPTY
79577: LIST
79578: LIST
79579: PUSH
79580: LD_INT 24
79582: PUSH
79583: LD_INT 250
79585: PUSH
79586: EMPTY
79587: LIST
79588: LIST
79589: PUSH
79590: EMPTY
79591: LIST
79592: LIST
79593: PPUSH
79594: CALL_OW 72
79598: ST_TO_ADDR
// case class of 1 , 15 :
79599: LD_VAR 0 4
79603: PUSH
79604: LD_INT 1
79606: DOUBLE
79607: EQUAL
79608: IFTRUE 79618
79610: LD_INT 15
79612: DOUBLE
79613: EQUAL
79614: IFTRUE 79618
79616: GO 79703
79618: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
79619: LD_ADDR_VAR 0 8
79623: PUSH
79624: LD_VAR 0 2
79628: PPUSH
79629: LD_INT 2
79631: PUSH
79632: LD_INT 30
79634: PUSH
79635: LD_INT 32
79637: PUSH
79638: EMPTY
79639: LIST
79640: LIST
79641: PUSH
79642: LD_INT 30
79644: PUSH
79645: LD_INT 31
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: EMPTY
79653: LIST
79654: LIST
79655: LIST
79656: PPUSH
79657: CALL_OW 72
79661: PUSH
79662: LD_VAR 0 2
79666: PPUSH
79667: LD_INT 2
79669: PUSH
79670: LD_INT 30
79672: PUSH
79673: LD_INT 4
79675: PUSH
79676: EMPTY
79677: LIST
79678: LIST
79679: PUSH
79680: LD_INT 30
79682: PUSH
79683: LD_INT 5
79685: PUSH
79686: EMPTY
79687: LIST
79688: LIST
79689: PUSH
79690: EMPTY
79691: LIST
79692: LIST
79693: LIST
79694: PPUSH
79695: CALL_OW 72
79699: ADD
79700: ST_TO_ADDR
79701: GO 79949
79703: LD_INT 2
79705: DOUBLE
79706: EQUAL
79707: IFTRUE 79717
79709: LD_INT 16
79711: DOUBLE
79712: EQUAL
79713: IFTRUE 79717
79715: GO 79763
79717: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
79718: LD_ADDR_VAR 0 8
79722: PUSH
79723: LD_VAR 0 2
79727: PPUSH
79728: LD_INT 2
79730: PUSH
79731: LD_INT 30
79733: PUSH
79734: LD_INT 0
79736: PUSH
79737: EMPTY
79738: LIST
79739: LIST
79740: PUSH
79741: LD_INT 30
79743: PUSH
79744: LD_INT 1
79746: PUSH
79747: EMPTY
79748: LIST
79749: LIST
79750: PUSH
79751: EMPTY
79752: LIST
79753: LIST
79754: LIST
79755: PPUSH
79756: CALL_OW 72
79760: ST_TO_ADDR
79761: GO 79949
79763: LD_INT 3
79765: DOUBLE
79766: EQUAL
79767: IFTRUE 79771
79769: GO 79817
79771: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
79772: LD_ADDR_VAR 0 8
79776: PUSH
79777: LD_VAR 0 2
79781: PPUSH
79782: LD_INT 2
79784: PUSH
79785: LD_INT 30
79787: PUSH
79788: LD_INT 2
79790: PUSH
79791: EMPTY
79792: LIST
79793: LIST
79794: PUSH
79795: LD_INT 30
79797: PUSH
79798: LD_INT 3
79800: PUSH
79801: EMPTY
79802: LIST
79803: LIST
79804: PUSH
79805: EMPTY
79806: LIST
79807: LIST
79808: LIST
79809: PPUSH
79810: CALL_OW 72
79814: ST_TO_ADDR
79815: GO 79949
79817: LD_INT 4
79819: DOUBLE
79820: EQUAL
79821: IFTRUE 79825
79823: GO 79882
79825: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
79826: LD_ADDR_VAR 0 8
79830: PUSH
79831: LD_VAR 0 2
79835: PPUSH
79836: LD_INT 2
79838: PUSH
79839: LD_INT 30
79841: PUSH
79842: LD_INT 6
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: LD_INT 30
79851: PUSH
79852: LD_INT 7
79854: PUSH
79855: EMPTY
79856: LIST
79857: LIST
79858: PUSH
79859: LD_INT 30
79861: PUSH
79862: LD_INT 8
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: PUSH
79869: EMPTY
79870: LIST
79871: LIST
79872: LIST
79873: LIST
79874: PPUSH
79875: CALL_OW 72
79879: ST_TO_ADDR
79880: GO 79949
79882: LD_INT 5
79884: DOUBLE
79885: EQUAL
79886: IFTRUE 79902
79888: LD_INT 8
79890: DOUBLE
79891: EQUAL
79892: IFTRUE 79902
79894: LD_INT 9
79896: DOUBLE
79897: EQUAL
79898: IFTRUE 79902
79900: GO 79948
79902: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
79903: LD_ADDR_VAR 0 8
79907: PUSH
79908: LD_VAR 0 2
79912: PPUSH
79913: LD_INT 2
79915: PUSH
79916: LD_INT 30
79918: PUSH
79919: LD_INT 4
79921: PUSH
79922: EMPTY
79923: LIST
79924: LIST
79925: PUSH
79926: LD_INT 30
79928: PUSH
79929: LD_INT 5
79931: PUSH
79932: EMPTY
79933: LIST
79934: LIST
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: LIST
79940: PPUSH
79941: CALL_OW 72
79945: ST_TO_ADDR
79946: GO 79949
79948: POP
// if not tmp then
79949: LD_VAR 0 8
79953: NOT
79954: IFFALSE 79958
// exit ;
79956: GO 80460
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
79958: LD_VAR 0 4
79962: PUSH
79963: LD_INT 1
79965: PUSH
79966: LD_INT 15
79968: PUSH
79969: EMPTY
79970: LIST
79971: LIST
79972: IN
79973: PUSH
79974: LD_EXP 67
79978: PUSH
79979: LD_VAR 0 1
79983: ARRAY
79984: AND
79985: IFFALSE 80141
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
79987: LD_ADDR_VAR 0 9
79991: PUSH
79992: LD_EXP 67
79996: PUSH
79997: LD_VAR 0 1
80001: ARRAY
80002: PUSH
80003: LD_INT 1
80005: ARRAY
80006: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
80007: LD_VAR 0 9
80011: PUSH
80012: LD_EXP 68
80016: PUSH
80017: LD_VAR 0 1
80021: ARRAY
80022: IN
80023: NOT
80024: IFFALSE 80139
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
80026: LD_ADDR_EXP 68
80030: PUSH
80031: LD_EXP 68
80035: PPUSH
80036: LD_VAR 0 1
80040: PUSH
80041: LD_EXP 68
80045: PUSH
80046: LD_VAR 0 1
80050: ARRAY
80051: PUSH
80052: LD_INT 1
80054: PLUS
80055: PUSH
80056: EMPTY
80057: LIST
80058: LIST
80059: PPUSH
80060: LD_VAR 0 9
80064: PPUSH
80065: CALL 21366 0 3
80069: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
80070: LD_ADDR_EXP 67
80074: PUSH
80075: LD_EXP 67
80079: PPUSH
80080: LD_VAR 0 1
80084: PPUSH
80085: LD_EXP 67
80089: PUSH
80090: LD_VAR 0 1
80094: ARRAY
80095: PUSH
80096: LD_VAR 0 9
80100: DIFF
80101: PPUSH
80102: CALL_OW 1
80106: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
80107: LD_VAR 0 3
80111: PPUSH
80112: LD_EXP 68
80116: PUSH
80117: LD_VAR 0 1
80121: ARRAY
80122: PUSH
80123: LD_EXP 68
80127: PUSH
80128: LD_VAR 0 1
80132: ARRAY
80133: ARRAY
80134: PPUSH
80135: CALL_OW 120
// end ; exit ;
80139: GO 80460
// end ; if tmp > 1 then
80141: LD_VAR 0 8
80145: PUSH
80146: LD_INT 1
80148: GREATER
80149: IFFALSE 80253
// for i = 2 to tmp do
80151: LD_ADDR_VAR 0 6
80155: PUSH
80156: DOUBLE
80157: LD_INT 2
80159: DEC
80160: ST_TO_ADDR
80161: LD_VAR 0 8
80165: PUSH
80166: FOR_TO
80167: IFFALSE 80251
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
80169: LD_VAR 0 8
80173: PUSH
80174: LD_VAR 0 6
80178: ARRAY
80179: PPUSH
80180: CALL_OW 461
80184: PUSH
80185: LD_INT 6
80187: EQUAL
80188: IFFALSE 80249
// begin x := tmp [ i ] ;
80190: LD_ADDR_VAR 0 9
80194: PUSH
80195: LD_VAR 0 8
80199: PUSH
80200: LD_VAR 0 6
80204: ARRAY
80205: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
80206: LD_ADDR_VAR 0 8
80210: PUSH
80211: LD_VAR 0 8
80215: PPUSH
80216: LD_VAR 0 6
80220: PPUSH
80221: CALL_OW 3
80225: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
80226: LD_ADDR_VAR 0 8
80230: PUSH
80231: LD_VAR 0 8
80235: PPUSH
80236: LD_INT 1
80238: PPUSH
80239: LD_VAR 0 9
80243: PPUSH
80244: CALL_OW 2
80248: ST_TO_ADDR
// end ;
80249: GO 80166
80251: POP
80252: POP
// for i in tmp do
80253: LD_ADDR_VAR 0 6
80257: PUSH
80258: LD_VAR 0 8
80262: PUSH
80263: FOR_IN
80264: IFFALSE 80333
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
80266: LD_VAR 0 6
80270: PPUSH
80271: CALL_OW 313
80275: PUSH
80276: LD_INT 6
80278: LESS
80279: PUSH
80280: LD_VAR 0 6
80284: PPUSH
80285: CALL_OW 266
80289: PUSH
80290: LD_INT 31
80292: PUSH
80293: LD_INT 32
80295: PUSH
80296: EMPTY
80297: LIST
80298: LIST
80299: IN
80300: NOT
80301: AND
80302: PUSH
80303: LD_VAR 0 6
80307: PPUSH
80308: CALL_OW 313
80312: PUSH
80313: LD_INT 0
80315: EQUAL
80316: OR
80317: IFFALSE 80331
// begin j := i ;
80319: LD_ADDR_VAR 0 7
80323: PUSH
80324: LD_VAR 0 6
80328: ST_TO_ADDR
// break ;
80329: GO 80333
// end ; end ;
80331: GO 80263
80333: POP
80334: POP
// if j then
80335: LD_VAR 0 7
80339: IFFALSE 80357
// ComEnterUnit ( unit , j ) else
80341: LD_VAR 0 3
80345: PPUSH
80346: LD_VAR 0 7
80350: PPUSH
80351: CALL_OW 120
80355: GO 80460
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80357: LD_ADDR_VAR 0 10
80361: PUSH
80362: LD_VAR 0 2
80366: PPUSH
80367: LD_INT 2
80369: PUSH
80370: LD_INT 30
80372: PUSH
80373: LD_INT 0
80375: PUSH
80376: EMPTY
80377: LIST
80378: LIST
80379: PUSH
80380: LD_INT 30
80382: PUSH
80383: LD_INT 1
80385: PUSH
80386: EMPTY
80387: LIST
80388: LIST
80389: PUSH
80390: EMPTY
80391: LIST
80392: LIST
80393: LIST
80394: PPUSH
80395: CALL_OW 72
80399: ST_TO_ADDR
// if depot then
80400: LD_VAR 0 10
80404: IFFALSE 80460
// begin depot := NearestUnitToUnit ( depot , unit ) ;
80406: LD_ADDR_VAR 0 10
80410: PUSH
80411: LD_VAR 0 10
80415: PPUSH
80416: LD_VAR 0 3
80420: PPUSH
80421: CALL_OW 74
80425: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
80426: LD_VAR 0 3
80430: PPUSH
80431: LD_VAR 0 10
80435: PPUSH
80436: CALL_OW 296
80440: PUSH
80441: LD_INT 10
80443: GREATER
80444: IFFALSE 80460
// ComStandNearbyBuilding ( unit , depot ) ;
80446: LD_VAR 0 3
80450: PPUSH
80451: LD_VAR 0 10
80455: PPUSH
80456: CALL 15569 0 2
// end ; end ; end ;
80460: LD_VAR 0 5
80464: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
80465: LD_INT 0
80467: PPUSH
80468: PPUSH
80469: PPUSH
80470: PPUSH
// if not mc_bases then
80471: LD_EXP 58
80475: NOT
80476: IFFALSE 80480
// exit ;
80478: GO 80719
// for i = 1 to mc_bases do
80480: LD_ADDR_VAR 0 2
80484: PUSH
80485: DOUBLE
80486: LD_INT 1
80488: DEC
80489: ST_TO_ADDR
80490: LD_EXP 58
80494: PUSH
80495: FOR_TO
80496: IFFALSE 80717
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
80498: LD_ADDR_VAR 0 4
80502: PUSH
80503: LD_EXP 58
80507: PUSH
80508: LD_VAR 0 2
80512: ARRAY
80513: PPUSH
80514: LD_INT 21
80516: PUSH
80517: LD_INT 1
80519: PUSH
80520: EMPTY
80521: LIST
80522: LIST
80523: PPUSH
80524: CALL_OW 72
80528: PUSH
80529: LD_EXP 87
80533: PUSH
80534: LD_VAR 0 2
80538: ARRAY
80539: UNION
80540: ST_TO_ADDR
// if not tmp then
80541: LD_VAR 0 4
80545: NOT
80546: IFFALSE 80550
// continue ;
80548: GO 80495
// for j in tmp do
80550: LD_ADDR_VAR 0 3
80554: PUSH
80555: LD_VAR 0 4
80559: PUSH
80560: FOR_IN
80561: IFFALSE 80713
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
80563: LD_VAR 0 3
80567: PPUSH
80568: CALL_OW 110
80572: NOT
80573: PUSH
80574: LD_VAR 0 3
80578: PPUSH
80579: CALL_OW 314
80583: NOT
80584: AND
80585: PUSH
80586: LD_VAR 0 3
80590: PPUSH
80591: CALL_OW 311
80595: NOT
80596: AND
80597: PUSH
80598: LD_VAR 0 3
80602: PPUSH
80603: CALL_OW 310
80607: NOT
80608: AND
80609: PUSH
80610: LD_VAR 0 3
80614: PUSH
80615: LD_EXP 61
80619: PUSH
80620: LD_VAR 0 2
80624: ARRAY
80625: PUSH
80626: LD_INT 1
80628: ARRAY
80629: IN
80630: NOT
80631: AND
80632: PUSH
80633: LD_VAR 0 3
80637: PUSH
80638: LD_EXP 61
80642: PUSH
80643: LD_VAR 0 2
80647: ARRAY
80648: PUSH
80649: LD_INT 2
80651: ARRAY
80652: IN
80653: NOT
80654: AND
80655: PUSH
80656: LD_VAR 0 3
80660: PUSH
80661: LD_EXP 70
80665: PUSH
80666: LD_VAR 0 2
80670: ARRAY
80671: IN
80672: NOT
80673: AND
80674: IFFALSE 80711
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
80676: LD_VAR 0 2
80680: PPUSH
80681: LD_EXP 58
80685: PUSH
80686: LD_VAR 0 2
80690: ARRAY
80691: PPUSH
80692: LD_VAR 0 3
80696: PPUSH
80697: LD_VAR 0 3
80701: PPUSH
80702: CALL_OW 257
80706: PPUSH
80707: CALL 79483 0 4
// end ;
80711: GO 80560
80713: POP
80714: POP
// end ;
80715: GO 80495
80717: POP
80718: POP
// end ;
80719: LD_VAR 0 1
80723: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
80724: LD_INT 0
80726: PPUSH
80727: PPUSH
80728: PPUSH
80729: PPUSH
80730: PPUSH
80731: PPUSH
// if not mc_bases [ base ] then
80732: LD_EXP 58
80736: PUSH
80737: LD_VAR 0 1
80741: ARRAY
80742: NOT
80743: IFFALSE 80747
// exit ;
80745: GO 80929
// tmp := [ ] ;
80747: LD_ADDR_VAR 0 6
80751: PUSH
80752: EMPTY
80753: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80754: LD_ADDR_VAR 0 7
80758: PUSH
80759: LD_VAR 0 3
80763: PPUSH
80764: LD_INT 0
80766: PPUSH
80767: CALL_OW 517
80771: ST_TO_ADDR
// if not list then
80772: LD_VAR 0 7
80776: NOT
80777: IFFALSE 80781
// exit ;
80779: GO 80929
// for i = 1 to amount do
80781: LD_ADDR_VAR 0 5
80785: PUSH
80786: DOUBLE
80787: LD_INT 1
80789: DEC
80790: ST_TO_ADDR
80791: LD_VAR 0 2
80795: PUSH
80796: FOR_TO
80797: IFFALSE 80877
// begin x := rand ( 1 , list [ 1 ] ) ;
80799: LD_ADDR_VAR 0 8
80803: PUSH
80804: LD_INT 1
80806: PPUSH
80807: LD_VAR 0 7
80811: PUSH
80812: LD_INT 1
80814: ARRAY
80815: PPUSH
80816: CALL_OW 12
80820: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
80821: LD_ADDR_VAR 0 6
80825: PUSH
80826: LD_VAR 0 6
80830: PPUSH
80831: LD_VAR 0 5
80835: PPUSH
80836: LD_VAR 0 7
80840: PUSH
80841: LD_INT 1
80843: ARRAY
80844: PUSH
80845: LD_VAR 0 8
80849: ARRAY
80850: PUSH
80851: LD_VAR 0 7
80855: PUSH
80856: LD_INT 2
80858: ARRAY
80859: PUSH
80860: LD_VAR 0 8
80864: ARRAY
80865: PUSH
80866: EMPTY
80867: LIST
80868: LIST
80869: PPUSH
80870: CALL_OW 1
80874: ST_TO_ADDR
// end ;
80875: GO 80796
80877: POP
80878: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
80879: LD_ADDR_EXP 71
80883: PUSH
80884: LD_EXP 71
80888: PPUSH
80889: LD_VAR 0 1
80893: PPUSH
80894: LD_VAR 0 6
80898: PPUSH
80899: CALL_OW 1
80903: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
80904: LD_ADDR_EXP 73
80908: PUSH
80909: LD_EXP 73
80913: PPUSH
80914: LD_VAR 0 1
80918: PPUSH
80919: LD_VAR 0 3
80923: PPUSH
80924: CALL_OW 1
80928: ST_TO_ADDR
// end ;
80929: LD_VAR 0 4
80933: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
80934: LD_INT 0
80936: PPUSH
// if not mc_bases [ base ] then
80937: LD_EXP 58
80941: PUSH
80942: LD_VAR 0 1
80946: ARRAY
80947: NOT
80948: IFFALSE 80952
// exit ;
80950: GO 80977
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
80952: LD_ADDR_EXP 63
80956: PUSH
80957: LD_EXP 63
80961: PPUSH
80962: LD_VAR 0 1
80966: PPUSH
80967: LD_VAR 0 2
80971: PPUSH
80972: CALL_OW 1
80976: ST_TO_ADDR
// end ;
80977: LD_VAR 0 3
80981: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
80982: LD_INT 0
80984: PPUSH
// if not mc_bases [ base ] then
80985: LD_EXP 58
80989: PUSH
80990: LD_VAR 0 1
80994: ARRAY
80995: NOT
80996: IFFALSE 81000
// exit ;
80998: GO 81037
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
81000: LD_ADDR_EXP 63
81004: PUSH
81005: LD_EXP 63
81009: PPUSH
81010: LD_VAR 0 1
81014: PPUSH
81015: LD_EXP 63
81019: PUSH
81020: LD_VAR 0 1
81024: ARRAY
81025: PUSH
81026: LD_VAR 0 2
81030: UNION
81031: PPUSH
81032: CALL_OW 1
81036: ST_TO_ADDR
// end ;
81037: LD_VAR 0 3
81041: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
81042: LD_INT 0
81044: PPUSH
// if not mc_bases [ base ] then
81045: LD_EXP 58
81049: PUSH
81050: LD_VAR 0 1
81054: ARRAY
81055: NOT
81056: IFFALSE 81060
// exit ;
81058: GO 81085
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
81060: LD_ADDR_EXP 79
81064: PUSH
81065: LD_EXP 79
81069: PPUSH
81070: LD_VAR 0 1
81074: PPUSH
81075: LD_VAR 0 2
81079: PPUSH
81080: CALL_OW 1
81084: ST_TO_ADDR
// end ;
81085: LD_VAR 0 3
81089: RET
// export function MC_InsertProduceList ( base , components ) ; begin
81090: LD_INT 0
81092: PPUSH
// if not mc_bases [ base ] then
81093: LD_EXP 58
81097: PUSH
81098: LD_VAR 0 1
81102: ARRAY
81103: NOT
81104: IFFALSE 81108
// exit ;
81106: GO 81145
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
81108: LD_ADDR_EXP 79
81112: PUSH
81113: LD_EXP 79
81117: PPUSH
81118: LD_VAR 0 1
81122: PPUSH
81123: LD_EXP 79
81127: PUSH
81128: LD_VAR 0 1
81132: ARRAY
81133: PUSH
81134: LD_VAR 0 2
81138: ADD
81139: PPUSH
81140: CALL_OW 1
81144: ST_TO_ADDR
// end ;
81145: LD_VAR 0 3
81149: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
81150: LD_INT 0
81152: PPUSH
// if not mc_bases [ base ] then
81153: LD_EXP 58
81157: PUSH
81158: LD_VAR 0 1
81162: ARRAY
81163: NOT
81164: IFFALSE 81168
// exit ;
81166: GO 81222
// mc_defender := Replace ( mc_defender , base , deflist ) ;
81168: LD_ADDR_EXP 80
81172: PUSH
81173: LD_EXP 80
81177: PPUSH
81178: LD_VAR 0 1
81182: PPUSH
81183: LD_VAR 0 2
81187: PPUSH
81188: CALL_OW 1
81192: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
81193: LD_ADDR_EXP 69
81197: PUSH
81198: LD_EXP 69
81202: PPUSH
81203: LD_VAR 0 1
81207: PPUSH
81208: LD_VAR 0 2
81212: PUSH
81213: LD_INT 0
81215: PLUS
81216: PPUSH
81217: CALL_OW 1
81221: ST_TO_ADDR
// end ;
81222: LD_VAR 0 3
81226: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
81227: LD_INT 0
81229: PPUSH
// if not mc_bases [ base ] then
81230: LD_EXP 58
81234: PUSH
81235: LD_VAR 0 1
81239: ARRAY
81240: NOT
81241: IFFALSE 81245
// exit ;
81243: GO 81270
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
81245: LD_ADDR_EXP 69
81249: PUSH
81250: LD_EXP 69
81254: PPUSH
81255: LD_VAR 0 1
81259: PPUSH
81260: LD_VAR 0 2
81264: PPUSH
81265: CALL_OW 1
81269: ST_TO_ADDR
// end ;
81270: LD_VAR 0 3
81274: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
81275: LD_INT 0
81277: PPUSH
81278: PPUSH
81279: PPUSH
81280: PPUSH
// if not mc_bases [ base ] then
81281: LD_EXP 58
81285: PUSH
81286: LD_VAR 0 1
81290: ARRAY
81291: NOT
81292: IFFALSE 81296
// exit ;
81294: GO 81361
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
81296: LD_ADDR_EXP 78
81300: PUSH
81301: LD_EXP 78
81305: PPUSH
81306: LD_VAR 0 1
81310: PUSH
81311: LD_EXP 78
81315: PUSH
81316: LD_VAR 0 1
81320: ARRAY
81321: PUSH
81322: LD_INT 1
81324: PLUS
81325: PUSH
81326: EMPTY
81327: LIST
81328: LIST
81329: PPUSH
81330: LD_VAR 0 1
81334: PUSH
81335: LD_VAR 0 2
81339: PUSH
81340: LD_VAR 0 3
81344: PUSH
81345: LD_VAR 0 4
81349: PUSH
81350: EMPTY
81351: LIST
81352: LIST
81353: LIST
81354: LIST
81355: PPUSH
81356: CALL 21366 0 3
81360: ST_TO_ADDR
// end ;
81361: LD_VAR 0 5
81365: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
81366: LD_INT 0
81368: PPUSH
// if not mc_bases [ base ] then
81369: LD_EXP 58
81373: PUSH
81374: LD_VAR 0 1
81378: ARRAY
81379: NOT
81380: IFFALSE 81384
// exit ;
81382: GO 81409
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
81384: LD_ADDR_EXP 95
81388: PUSH
81389: LD_EXP 95
81393: PPUSH
81394: LD_VAR 0 1
81398: PPUSH
81399: LD_VAR 0 2
81403: PPUSH
81404: CALL_OW 1
81408: ST_TO_ADDR
// end ;
81409: LD_VAR 0 3
81413: RET
// export function MC_GetMinesField ( base ) ; begin
81414: LD_INT 0
81416: PPUSH
// result := mc_mines [ base ] ;
81417: LD_ADDR_VAR 0 2
81421: PUSH
81422: LD_EXP 71
81426: PUSH
81427: LD_VAR 0 1
81431: ARRAY
81432: ST_TO_ADDR
// end ;
81433: LD_VAR 0 2
81437: RET
// export function MC_GetProduceList ( base ) ; begin
81438: LD_INT 0
81440: PPUSH
// result := mc_produce [ base ] ;
81441: LD_ADDR_VAR 0 2
81445: PUSH
81446: LD_EXP 79
81450: PUSH
81451: LD_VAR 0 1
81455: ARRAY
81456: ST_TO_ADDR
// end ;
81457: LD_VAR 0 2
81461: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
81462: LD_INT 0
81464: PPUSH
81465: PPUSH
// if not mc_bases then
81466: LD_EXP 58
81470: NOT
81471: IFFALSE 81475
// exit ;
81473: GO 81540
// if mc_bases [ base ] then
81475: LD_EXP 58
81479: PUSH
81480: LD_VAR 0 1
81484: ARRAY
81485: IFFALSE 81540
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81487: LD_ADDR_VAR 0 3
81491: PUSH
81492: LD_EXP 58
81496: PUSH
81497: LD_VAR 0 1
81501: ARRAY
81502: PPUSH
81503: LD_INT 30
81505: PUSH
81506: LD_VAR 0 2
81510: PUSH
81511: EMPTY
81512: LIST
81513: LIST
81514: PPUSH
81515: CALL_OW 72
81519: ST_TO_ADDR
// if result then
81520: LD_VAR 0 3
81524: IFFALSE 81540
// result := result [ 1 ] ;
81526: LD_ADDR_VAR 0 3
81530: PUSH
81531: LD_VAR 0 3
81535: PUSH
81536: LD_INT 1
81538: ARRAY
81539: ST_TO_ADDR
// end ; end ;
81540: LD_VAR 0 3
81544: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
81545: LD_INT 0
81547: PPUSH
81548: PPUSH
// if not mc_bases then
81549: LD_EXP 58
81553: NOT
81554: IFFALSE 81558
// exit ;
81556: GO 81603
// if mc_bases [ base ] then
81558: LD_EXP 58
81562: PUSH
81563: LD_VAR 0 1
81567: ARRAY
81568: IFFALSE 81603
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81570: LD_ADDR_VAR 0 3
81574: PUSH
81575: LD_EXP 58
81579: PUSH
81580: LD_VAR 0 1
81584: ARRAY
81585: PPUSH
81586: LD_INT 30
81588: PUSH
81589: LD_VAR 0 2
81593: PUSH
81594: EMPTY
81595: LIST
81596: LIST
81597: PPUSH
81598: CALL_OW 72
81602: ST_TO_ADDR
// end ;
81603: LD_VAR 0 3
81607: RET
// export function MC_SetTame ( base , area ) ; begin
81608: LD_INT 0
81610: PPUSH
// if not mc_bases or not base then
81611: LD_EXP 58
81615: NOT
81616: PUSH
81617: LD_VAR 0 1
81621: NOT
81622: OR
81623: IFFALSE 81627
// exit ;
81625: GO 81652
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
81627: LD_ADDR_EXP 86
81631: PUSH
81632: LD_EXP 86
81636: PPUSH
81637: LD_VAR 0 1
81641: PPUSH
81642: LD_VAR 0 2
81646: PPUSH
81647: CALL_OW 1
81651: ST_TO_ADDR
// end ;
81652: LD_VAR 0 3
81656: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
81657: LD_INT 0
81659: PPUSH
81660: PPUSH
// if not mc_bases or not base then
81661: LD_EXP 58
81665: NOT
81666: PUSH
81667: LD_VAR 0 1
81671: NOT
81672: OR
81673: IFFALSE 81677
// exit ;
81675: GO 81779
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81677: LD_ADDR_VAR 0 4
81681: PUSH
81682: LD_EXP 58
81686: PUSH
81687: LD_VAR 0 1
81691: ARRAY
81692: PPUSH
81693: LD_INT 30
81695: PUSH
81696: LD_VAR 0 2
81700: PUSH
81701: EMPTY
81702: LIST
81703: LIST
81704: PPUSH
81705: CALL_OW 72
81709: ST_TO_ADDR
// if not tmp then
81710: LD_VAR 0 4
81714: NOT
81715: IFFALSE 81719
// exit ;
81717: GO 81779
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
81719: LD_ADDR_EXP 90
81723: PUSH
81724: LD_EXP 90
81728: PPUSH
81729: LD_VAR 0 1
81733: PPUSH
81734: LD_EXP 90
81738: PUSH
81739: LD_VAR 0 1
81743: ARRAY
81744: PPUSH
81745: LD_EXP 90
81749: PUSH
81750: LD_VAR 0 1
81754: ARRAY
81755: PUSH
81756: LD_INT 1
81758: PLUS
81759: PPUSH
81760: LD_VAR 0 4
81764: PUSH
81765: LD_INT 1
81767: ARRAY
81768: PPUSH
81769: CALL_OW 2
81773: PPUSH
81774: CALL_OW 1
81778: ST_TO_ADDR
// end ;
81779: LD_VAR 0 3
81783: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
81784: LD_INT 0
81786: PPUSH
81787: PPUSH
// if not mc_bases or not base or not kinds then
81788: LD_EXP 58
81792: NOT
81793: PUSH
81794: LD_VAR 0 1
81798: NOT
81799: OR
81800: PUSH
81801: LD_VAR 0 2
81805: NOT
81806: OR
81807: IFFALSE 81811
// exit ;
81809: GO 81872
// for i in kinds do
81811: LD_ADDR_VAR 0 4
81815: PUSH
81816: LD_VAR 0 2
81820: PUSH
81821: FOR_IN
81822: IFFALSE 81870
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
81824: LD_ADDR_EXP 92
81828: PUSH
81829: LD_EXP 92
81833: PPUSH
81834: LD_VAR 0 1
81838: PUSH
81839: LD_EXP 92
81843: PUSH
81844: LD_VAR 0 1
81848: ARRAY
81849: PUSH
81850: LD_INT 1
81852: PLUS
81853: PUSH
81854: EMPTY
81855: LIST
81856: LIST
81857: PPUSH
81858: LD_VAR 0 4
81862: PPUSH
81863: CALL 21366 0 3
81867: ST_TO_ADDR
81868: GO 81821
81870: POP
81871: POP
// end ;
81872: LD_VAR 0 3
81876: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
81877: LD_INT 0
81879: PPUSH
// if not mc_bases or not base or not areas then
81880: LD_EXP 58
81884: NOT
81885: PUSH
81886: LD_VAR 0 1
81890: NOT
81891: OR
81892: PUSH
81893: LD_VAR 0 2
81897: NOT
81898: OR
81899: IFFALSE 81903
// exit ;
81901: GO 81928
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
81903: LD_ADDR_EXP 76
81907: PUSH
81908: LD_EXP 76
81912: PPUSH
81913: LD_VAR 0 1
81917: PPUSH
81918: LD_VAR 0 2
81922: PPUSH
81923: CALL_OW 1
81927: ST_TO_ADDR
// end ;
81928: LD_VAR 0 3
81932: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
81933: LD_INT 0
81935: PPUSH
// if not mc_bases or not base or not teleports_exit then
81936: LD_EXP 58
81940: NOT
81941: PUSH
81942: LD_VAR 0 1
81946: NOT
81947: OR
81948: PUSH
81949: LD_VAR 0 2
81953: NOT
81954: OR
81955: IFFALSE 81959
// exit ;
81957: GO 81984
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
81959: LD_ADDR_EXP 93
81963: PUSH
81964: LD_EXP 93
81968: PPUSH
81969: LD_VAR 0 1
81973: PPUSH
81974: LD_VAR 0 2
81978: PPUSH
81979: CALL_OW 1
81983: ST_TO_ADDR
// end ;
81984: LD_VAR 0 3
81988: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
81989: LD_INT 0
81991: PPUSH
81992: PPUSH
81993: PPUSH
// if not mc_bases or not base or not ext_list then
81994: LD_EXP 58
81998: NOT
81999: PUSH
82000: LD_VAR 0 1
82004: NOT
82005: OR
82006: PUSH
82007: LD_VAR 0 5
82011: NOT
82012: OR
82013: IFFALSE 82017
// exit ;
82015: GO 82190
// tmp := GetFacExtXYD ( x , y , d ) ;
82017: LD_ADDR_VAR 0 8
82021: PUSH
82022: LD_VAR 0 2
82026: PPUSH
82027: LD_VAR 0 3
82031: PPUSH
82032: LD_VAR 0 4
82036: PPUSH
82037: CALL 54744 0 3
82041: ST_TO_ADDR
// if not tmp then
82042: LD_VAR 0 8
82046: NOT
82047: IFFALSE 82051
// exit ;
82049: GO 82190
// for i in tmp do
82051: LD_ADDR_VAR 0 7
82055: PUSH
82056: LD_VAR 0 8
82060: PUSH
82061: FOR_IN
82062: IFFALSE 82188
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
82064: LD_ADDR_EXP 63
82068: PUSH
82069: LD_EXP 63
82073: PPUSH
82074: LD_VAR 0 1
82078: PPUSH
82079: LD_EXP 63
82083: PUSH
82084: LD_VAR 0 1
82088: ARRAY
82089: PPUSH
82090: LD_EXP 63
82094: PUSH
82095: LD_VAR 0 1
82099: ARRAY
82100: PUSH
82101: LD_INT 1
82103: PLUS
82104: PPUSH
82105: LD_VAR 0 5
82109: PUSH
82110: LD_INT 1
82112: ARRAY
82113: PUSH
82114: LD_VAR 0 7
82118: PUSH
82119: LD_INT 1
82121: ARRAY
82122: PUSH
82123: LD_VAR 0 7
82127: PUSH
82128: LD_INT 2
82130: ARRAY
82131: PUSH
82132: LD_VAR 0 7
82136: PUSH
82137: LD_INT 3
82139: ARRAY
82140: PUSH
82141: EMPTY
82142: LIST
82143: LIST
82144: LIST
82145: LIST
82146: PPUSH
82147: CALL_OW 2
82151: PPUSH
82152: CALL_OW 1
82156: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
82157: LD_ADDR_VAR 0 5
82161: PUSH
82162: LD_VAR 0 5
82166: PPUSH
82167: LD_INT 1
82169: PPUSH
82170: CALL_OW 3
82174: ST_TO_ADDR
// if not ext_list then
82175: LD_VAR 0 5
82179: NOT
82180: IFFALSE 82186
// exit ;
82182: POP
82183: POP
82184: GO 82190
// end ;
82186: GO 82061
82188: POP
82189: POP
// end ;
82190: LD_VAR 0 6
82194: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
82195: LD_INT 0
82197: PPUSH
// if not mc_bases or not base or not weapon_list then
82198: LD_EXP 58
82202: NOT
82203: PUSH
82204: LD_VAR 0 1
82208: NOT
82209: OR
82210: PUSH
82211: LD_VAR 0 2
82215: NOT
82216: OR
82217: IFFALSE 82221
// exit ;
82219: GO 82246
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
82221: LD_ADDR_EXP 97
82225: PUSH
82226: LD_EXP 97
82230: PPUSH
82231: LD_VAR 0 1
82235: PPUSH
82236: LD_VAR 0 2
82240: PPUSH
82241: CALL_OW 1
82245: ST_TO_ADDR
// end ;
82246: LD_VAR 0 3
82250: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
82251: LD_INT 0
82253: PPUSH
// if not mc_bases or not base or not tech_list then
82254: LD_EXP 58
82258: NOT
82259: PUSH
82260: LD_VAR 0 1
82264: NOT
82265: OR
82266: PUSH
82267: LD_VAR 0 2
82271: NOT
82272: OR
82273: IFFALSE 82277
// exit ;
82275: GO 82302
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
82277: LD_ADDR_EXP 85
82281: PUSH
82282: LD_EXP 85
82286: PPUSH
82287: LD_VAR 0 1
82291: PPUSH
82292: LD_VAR 0 2
82296: PPUSH
82297: CALL_OW 1
82301: ST_TO_ADDR
// end ;
82302: LD_VAR 0 3
82306: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
82307: LD_INT 0
82309: PPUSH
// if not mc_bases or not parking_area or not base then
82310: LD_EXP 58
82314: NOT
82315: PUSH
82316: LD_VAR 0 2
82320: NOT
82321: OR
82322: PUSH
82323: LD_VAR 0 1
82327: NOT
82328: OR
82329: IFFALSE 82333
// exit ;
82331: GO 82358
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
82333: LD_ADDR_EXP 82
82337: PUSH
82338: LD_EXP 82
82342: PPUSH
82343: LD_VAR 0 1
82347: PPUSH
82348: LD_VAR 0 2
82352: PPUSH
82353: CALL_OW 1
82357: ST_TO_ADDR
// end ;
82358: LD_VAR 0 3
82362: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
82363: LD_INT 0
82365: PPUSH
// if not mc_bases or not base or not scan_area then
82366: LD_EXP 58
82370: NOT
82371: PUSH
82372: LD_VAR 0 1
82376: NOT
82377: OR
82378: PUSH
82379: LD_VAR 0 2
82383: NOT
82384: OR
82385: IFFALSE 82389
// exit ;
82387: GO 82414
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
82389: LD_ADDR_EXP 83
82393: PUSH
82394: LD_EXP 83
82398: PPUSH
82399: LD_VAR 0 1
82403: PPUSH
82404: LD_VAR 0 2
82408: PPUSH
82409: CALL_OW 1
82413: ST_TO_ADDR
// end ;
82414: LD_VAR 0 3
82418: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
82419: LD_INT 0
82421: PPUSH
82422: PPUSH
// if not mc_bases or not base then
82423: LD_EXP 58
82427: NOT
82428: PUSH
82429: LD_VAR 0 1
82433: NOT
82434: OR
82435: IFFALSE 82439
// exit ;
82437: GO 82503
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
82439: LD_ADDR_VAR 0 3
82443: PUSH
82444: LD_INT 1
82446: PUSH
82447: LD_INT 2
82449: PUSH
82450: LD_INT 3
82452: PUSH
82453: LD_INT 4
82455: PUSH
82456: LD_INT 11
82458: PUSH
82459: EMPTY
82460: LIST
82461: LIST
82462: LIST
82463: LIST
82464: LIST
82465: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
82466: LD_ADDR_EXP 85
82470: PUSH
82471: LD_EXP 85
82475: PPUSH
82476: LD_VAR 0 1
82480: PPUSH
82481: LD_EXP 85
82485: PUSH
82486: LD_VAR 0 1
82490: ARRAY
82491: PUSH
82492: LD_VAR 0 3
82496: DIFF
82497: PPUSH
82498: CALL_OW 1
82502: ST_TO_ADDR
// end ;
82503: LD_VAR 0 2
82507: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
82508: LD_INT 0
82510: PPUSH
// result := mc_vehicles [ base ] ;
82511: LD_ADDR_VAR 0 3
82515: PUSH
82516: LD_EXP 77
82520: PUSH
82521: LD_VAR 0 1
82525: ARRAY
82526: ST_TO_ADDR
// if onlyCombat then
82527: LD_VAR 0 2
82531: IFFALSE 82696
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
82533: LD_ADDR_VAR 0 3
82537: PUSH
82538: LD_VAR 0 3
82542: PUSH
82543: LD_VAR 0 3
82547: PPUSH
82548: LD_INT 2
82550: PUSH
82551: LD_INT 34
82553: PUSH
82554: LD_INT 12
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: PUSH
82561: LD_INT 34
82563: PUSH
82564: LD_INT 51
82566: PUSH
82567: EMPTY
82568: LIST
82569: LIST
82570: PUSH
82571: LD_INT 34
82573: PUSH
82574: LD_EXP 102
82578: PUSH
82579: EMPTY
82580: LIST
82581: LIST
82582: PUSH
82583: LD_INT 34
82585: PUSH
82586: LD_INT 32
82588: PUSH
82589: EMPTY
82590: LIST
82591: LIST
82592: PUSH
82593: LD_INT 34
82595: PUSH
82596: LD_INT 13
82598: PUSH
82599: EMPTY
82600: LIST
82601: LIST
82602: PUSH
82603: LD_INT 34
82605: PUSH
82606: LD_INT 52
82608: PUSH
82609: EMPTY
82610: LIST
82611: LIST
82612: PUSH
82613: LD_INT 34
82615: PUSH
82616: LD_INT 14
82618: PUSH
82619: EMPTY
82620: LIST
82621: LIST
82622: PUSH
82623: LD_INT 34
82625: PUSH
82626: LD_INT 53
82628: PUSH
82629: EMPTY
82630: LIST
82631: LIST
82632: PUSH
82633: LD_INT 34
82635: PUSH
82636: LD_EXP 101
82640: PUSH
82641: EMPTY
82642: LIST
82643: LIST
82644: PUSH
82645: LD_INT 34
82647: PUSH
82648: LD_INT 31
82650: PUSH
82651: EMPTY
82652: LIST
82653: LIST
82654: PUSH
82655: LD_INT 34
82657: PUSH
82658: LD_INT 48
82660: PUSH
82661: EMPTY
82662: LIST
82663: LIST
82664: PUSH
82665: LD_INT 34
82667: PUSH
82668: LD_INT 8
82670: PUSH
82671: EMPTY
82672: LIST
82673: LIST
82674: PUSH
82675: EMPTY
82676: LIST
82677: LIST
82678: LIST
82679: LIST
82680: LIST
82681: LIST
82682: LIST
82683: LIST
82684: LIST
82685: LIST
82686: LIST
82687: LIST
82688: LIST
82689: PPUSH
82690: CALL_OW 72
82694: DIFF
82695: ST_TO_ADDR
// end ; end_of_file
82696: LD_VAR 0 3
82700: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
82701: LD_INT 0
82703: PPUSH
82704: PPUSH
82705: PPUSH
// if not mc_bases or not skirmish then
82706: LD_EXP 58
82710: NOT
82711: PUSH
82712: LD_EXP 56
82716: NOT
82717: OR
82718: IFFALSE 82722
// exit ;
82720: GO 82887
// for i = 1 to mc_bases do
82722: LD_ADDR_VAR 0 4
82726: PUSH
82727: DOUBLE
82728: LD_INT 1
82730: DEC
82731: ST_TO_ADDR
82732: LD_EXP 58
82736: PUSH
82737: FOR_TO
82738: IFFALSE 82885
// begin if sci in mc_bases [ i ] then
82740: LD_VAR 0 2
82744: PUSH
82745: LD_EXP 58
82749: PUSH
82750: LD_VAR 0 4
82754: ARRAY
82755: IN
82756: IFFALSE 82883
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
82758: LD_ADDR_EXP 87
82762: PUSH
82763: LD_EXP 87
82767: PPUSH
82768: LD_VAR 0 4
82772: PUSH
82773: LD_EXP 87
82777: PUSH
82778: LD_VAR 0 4
82782: ARRAY
82783: PUSH
82784: LD_INT 1
82786: PLUS
82787: PUSH
82788: EMPTY
82789: LIST
82790: LIST
82791: PPUSH
82792: LD_VAR 0 1
82796: PPUSH
82797: CALL 21366 0 3
82801: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
82802: LD_ADDR_VAR 0 5
82806: PUSH
82807: LD_EXP 58
82811: PUSH
82812: LD_VAR 0 4
82816: ARRAY
82817: PPUSH
82818: LD_INT 2
82820: PUSH
82821: LD_INT 30
82823: PUSH
82824: LD_INT 0
82826: PUSH
82827: EMPTY
82828: LIST
82829: LIST
82830: PUSH
82831: LD_INT 30
82833: PUSH
82834: LD_INT 1
82836: PUSH
82837: EMPTY
82838: LIST
82839: LIST
82840: PUSH
82841: EMPTY
82842: LIST
82843: LIST
82844: LIST
82845: PPUSH
82846: CALL_OW 72
82850: PPUSH
82851: LD_VAR 0 1
82855: PPUSH
82856: CALL_OW 74
82860: ST_TO_ADDR
// if tmp then
82861: LD_VAR 0 5
82865: IFFALSE 82881
// ComStandNearbyBuilding ( ape , tmp ) ;
82867: LD_VAR 0 1
82871: PPUSH
82872: LD_VAR 0 5
82876: PPUSH
82877: CALL 15569 0 2
// break ;
82881: GO 82885
// end ; end ;
82883: GO 82737
82885: POP
82886: POP
// end ;
82887: LD_VAR 0 3
82891: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
82892: LD_INT 0
82894: PPUSH
82895: PPUSH
82896: PPUSH
// if not mc_bases or not skirmish then
82897: LD_EXP 58
82901: NOT
82902: PUSH
82903: LD_EXP 56
82907: NOT
82908: OR
82909: IFFALSE 82913
// exit ;
82911: GO 83002
// for i = 1 to mc_bases do
82913: LD_ADDR_VAR 0 4
82917: PUSH
82918: DOUBLE
82919: LD_INT 1
82921: DEC
82922: ST_TO_ADDR
82923: LD_EXP 58
82927: PUSH
82928: FOR_TO
82929: IFFALSE 83000
// begin if building in mc_busy_turret_list [ i ] then
82931: LD_VAR 0 1
82935: PUSH
82936: LD_EXP 68
82940: PUSH
82941: LD_VAR 0 4
82945: ARRAY
82946: IN
82947: IFFALSE 82998
// begin tmp := mc_busy_turret_list [ i ] diff building ;
82949: LD_ADDR_VAR 0 5
82953: PUSH
82954: LD_EXP 68
82958: PUSH
82959: LD_VAR 0 4
82963: ARRAY
82964: PUSH
82965: LD_VAR 0 1
82969: DIFF
82970: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
82971: LD_ADDR_EXP 68
82975: PUSH
82976: LD_EXP 68
82980: PPUSH
82981: LD_VAR 0 4
82985: PPUSH
82986: LD_VAR 0 5
82990: PPUSH
82991: CALL_OW 1
82995: ST_TO_ADDR
// break ;
82996: GO 83000
// end ; end ;
82998: GO 82928
83000: POP
83001: POP
// end ;
83002: LD_VAR 0 3
83006: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
83007: LD_INT 0
83009: PPUSH
83010: PPUSH
83011: PPUSH
// if not mc_bases or not skirmish then
83012: LD_EXP 58
83016: NOT
83017: PUSH
83018: LD_EXP 56
83022: NOT
83023: OR
83024: IFFALSE 83028
// exit ;
83026: GO 83227
// for i = 1 to mc_bases do
83028: LD_ADDR_VAR 0 5
83032: PUSH
83033: DOUBLE
83034: LD_INT 1
83036: DEC
83037: ST_TO_ADDR
83038: LD_EXP 58
83042: PUSH
83043: FOR_TO
83044: IFFALSE 83225
// if building in mc_bases [ i ] then
83046: LD_VAR 0 1
83050: PUSH
83051: LD_EXP 58
83055: PUSH
83056: LD_VAR 0 5
83060: ARRAY
83061: IN
83062: IFFALSE 83223
// begin tmp := mc_bases [ i ] diff building ;
83064: LD_ADDR_VAR 0 6
83068: PUSH
83069: LD_EXP 58
83073: PUSH
83074: LD_VAR 0 5
83078: ARRAY
83079: PUSH
83080: LD_VAR 0 1
83084: DIFF
83085: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
83086: LD_ADDR_EXP 58
83090: PUSH
83091: LD_EXP 58
83095: PPUSH
83096: LD_VAR 0 5
83100: PPUSH
83101: LD_VAR 0 6
83105: PPUSH
83106: CALL_OW 1
83110: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
83111: LD_VAR 0 1
83115: PUSH
83116: LD_EXP 66
83120: PUSH
83121: LD_VAR 0 5
83125: ARRAY
83126: IN
83127: IFFALSE 83166
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
83129: LD_ADDR_EXP 66
83133: PUSH
83134: LD_EXP 66
83138: PPUSH
83139: LD_VAR 0 5
83143: PPUSH
83144: LD_EXP 66
83148: PUSH
83149: LD_VAR 0 5
83153: ARRAY
83154: PUSH
83155: LD_VAR 0 1
83159: DIFF
83160: PPUSH
83161: CALL_OW 1
83165: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
83166: LD_VAR 0 1
83170: PUSH
83171: LD_EXP 67
83175: PUSH
83176: LD_VAR 0 5
83180: ARRAY
83181: IN
83182: IFFALSE 83221
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
83184: LD_ADDR_EXP 67
83188: PUSH
83189: LD_EXP 67
83193: PPUSH
83194: LD_VAR 0 5
83198: PPUSH
83199: LD_EXP 67
83203: PUSH
83204: LD_VAR 0 5
83208: ARRAY
83209: PUSH
83210: LD_VAR 0 1
83214: DIFF
83215: PPUSH
83216: CALL_OW 1
83220: ST_TO_ADDR
// break ;
83221: GO 83225
// end ;
83223: GO 83043
83225: POP
83226: POP
// end ;
83227: LD_VAR 0 4
83231: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
83232: LD_INT 0
83234: PPUSH
83235: PPUSH
83236: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
83237: LD_EXP 58
83241: NOT
83242: PUSH
83243: LD_EXP 56
83247: NOT
83248: OR
83249: PUSH
83250: LD_VAR 0 3
83254: PUSH
83255: LD_EXP 84
83259: IN
83260: NOT
83261: OR
83262: IFFALSE 83266
// exit ;
83264: GO 83389
// for i = 1 to mc_vehicles do
83266: LD_ADDR_VAR 0 6
83270: PUSH
83271: DOUBLE
83272: LD_INT 1
83274: DEC
83275: ST_TO_ADDR
83276: LD_EXP 77
83280: PUSH
83281: FOR_TO
83282: IFFALSE 83387
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
83284: LD_VAR 0 2
83288: PUSH
83289: LD_EXP 77
83293: PUSH
83294: LD_VAR 0 6
83298: ARRAY
83299: IN
83300: PUSH
83301: LD_VAR 0 1
83305: PUSH
83306: LD_EXP 77
83310: PUSH
83311: LD_VAR 0 6
83315: ARRAY
83316: IN
83317: OR
83318: IFFALSE 83385
// begin tmp := mc_vehicles [ i ] diff old ;
83320: LD_ADDR_VAR 0 7
83324: PUSH
83325: LD_EXP 77
83329: PUSH
83330: LD_VAR 0 6
83334: ARRAY
83335: PUSH
83336: LD_VAR 0 2
83340: DIFF
83341: ST_TO_ADDR
// tmp := tmp diff new ;
83342: LD_ADDR_VAR 0 7
83346: PUSH
83347: LD_VAR 0 7
83351: PUSH
83352: LD_VAR 0 1
83356: DIFF
83357: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
83358: LD_ADDR_EXP 77
83362: PUSH
83363: LD_EXP 77
83367: PPUSH
83368: LD_VAR 0 6
83372: PPUSH
83373: LD_VAR 0 7
83377: PPUSH
83378: CALL_OW 1
83382: ST_TO_ADDR
// break ;
83383: GO 83387
// end ;
83385: GO 83281
83387: POP
83388: POP
// end ;
83389: LD_VAR 0 5
83393: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
83394: LD_INT 0
83396: PPUSH
83397: PPUSH
83398: PPUSH
83399: PPUSH
// if not mc_bases or not skirmish then
83400: LD_EXP 58
83404: NOT
83405: PUSH
83406: LD_EXP 56
83410: NOT
83411: OR
83412: IFFALSE 83416
// exit ;
83414: GO 83793
// side := GetSide ( vehicle ) ;
83416: LD_ADDR_VAR 0 5
83420: PUSH
83421: LD_VAR 0 1
83425: PPUSH
83426: CALL_OW 255
83430: ST_TO_ADDR
// for i = 1 to mc_bases do
83431: LD_ADDR_VAR 0 4
83435: PUSH
83436: DOUBLE
83437: LD_INT 1
83439: DEC
83440: ST_TO_ADDR
83441: LD_EXP 58
83445: PUSH
83446: FOR_TO
83447: IFFALSE 83791
// begin if factory in mc_bases [ i ] then
83449: LD_VAR 0 2
83453: PUSH
83454: LD_EXP 58
83458: PUSH
83459: LD_VAR 0 4
83463: ARRAY
83464: IN
83465: IFFALSE 83789
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
83467: LD_EXP 80
83471: PUSH
83472: LD_VAR 0 4
83476: ARRAY
83477: PUSH
83478: LD_EXP 69
83482: PUSH
83483: LD_VAR 0 4
83487: ARRAY
83488: LESS
83489: PUSH
83490: LD_VAR 0 1
83494: PPUSH
83495: CALL_OW 264
83499: PUSH
83500: LD_INT 31
83502: PUSH
83503: LD_INT 32
83505: PUSH
83506: LD_INT 51
83508: PUSH
83509: LD_EXP 102
83513: PUSH
83514: LD_INT 12
83516: PUSH
83517: LD_INT 30
83519: PUSH
83520: LD_EXP 101
83524: PUSH
83525: LD_INT 11
83527: PUSH
83528: LD_INT 53
83530: PUSH
83531: LD_INT 14
83533: PUSH
83534: LD_EXP 105
83538: PUSH
83539: LD_INT 29
83541: PUSH
83542: LD_EXP 103
83546: PUSH
83547: LD_INT 13
83549: PUSH
83550: LD_INT 52
83552: PUSH
83553: LD_INT 48
83555: PUSH
83556: LD_INT 8
83558: PUSH
83559: EMPTY
83560: LIST
83561: LIST
83562: LIST
83563: LIST
83564: LIST
83565: LIST
83566: LIST
83567: LIST
83568: LIST
83569: LIST
83570: LIST
83571: LIST
83572: LIST
83573: LIST
83574: LIST
83575: LIST
83576: LIST
83577: IN
83578: NOT
83579: AND
83580: IFFALSE 83628
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
83582: LD_ADDR_EXP 80
83586: PUSH
83587: LD_EXP 80
83591: PPUSH
83592: LD_VAR 0 4
83596: PUSH
83597: LD_EXP 80
83601: PUSH
83602: LD_VAR 0 4
83606: ARRAY
83607: PUSH
83608: LD_INT 1
83610: PLUS
83611: PUSH
83612: EMPTY
83613: LIST
83614: LIST
83615: PPUSH
83616: LD_VAR 0 1
83620: PPUSH
83621: CALL 21366 0 3
83625: ST_TO_ADDR
83626: GO 83672
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
83628: LD_ADDR_EXP 77
83632: PUSH
83633: LD_EXP 77
83637: PPUSH
83638: LD_VAR 0 4
83642: PUSH
83643: LD_EXP 77
83647: PUSH
83648: LD_VAR 0 4
83652: ARRAY
83653: PUSH
83654: LD_INT 1
83656: PLUS
83657: PUSH
83658: EMPTY
83659: LIST
83660: LIST
83661: PPUSH
83662: LD_VAR 0 1
83666: PPUSH
83667: CALL 21366 0 3
83671: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
83672: LD_VAR 0 1
83676: PPUSH
83677: CALL_OW 263
83681: PUSH
83682: LD_INT 2
83684: EQUAL
83685: IFFALSE 83705
// begin repeat wait ( 0 0$1 ) ;
83687: LD_INT 35
83689: PPUSH
83690: CALL_OW 67
// until IsControledBy ( vehicle ) ;
83694: LD_VAR 0 1
83698: PPUSH
83699: CALL_OW 312
83703: IFFALSE 83687
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
83705: LD_VAR 0 1
83709: PPUSH
83710: LD_EXP 82
83714: PUSH
83715: LD_VAR 0 4
83719: ARRAY
83720: PPUSH
83721: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
83725: LD_VAR 0 1
83729: PPUSH
83730: CALL_OW 263
83734: PUSH
83735: LD_INT 1
83737: NONEQUAL
83738: IFFALSE 83742
// break ;
83740: GO 83791
// repeat wait ( 0 0$1 ) ;
83742: LD_INT 35
83744: PPUSH
83745: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
83749: LD_VAR 0 1
83753: PPUSH
83754: LD_EXP 82
83758: PUSH
83759: LD_VAR 0 4
83763: ARRAY
83764: PPUSH
83765: CALL_OW 308
83769: IFFALSE 83742
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
83771: LD_VAR 0 1
83775: PPUSH
83776: CALL_OW 311
83780: PPUSH
83781: CALL_OW 121
// exit ;
83785: POP
83786: POP
83787: GO 83793
// end ; end ;
83789: GO 83446
83791: POP
83792: POP
// end ;
83793: LD_VAR 0 3
83797: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
83798: LD_INT 0
83800: PPUSH
83801: PPUSH
83802: PPUSH
83803: PPUSH
// if not mc_bases or not skirmish then
83804: LD_EXP 58
83808: NOT
83809: PUSH
83810: LD_EXP 56
83814: NOT
83815: OR
83816: IFFALSE 83820
// exit ;
83818: GO 84173
// repeat wait ( 0 0$1 ) ;
83820: LD_INT 35
83822: PPUSH
83823: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
83827: LD_VAR 0 2
83831: PPUSH
83832: LD_VAR 0 3
83836: PPUSH
83837: CALL_OW 284
83841: IFFALSE 83820
// if GetResourceTypeXY ( x , y ) = mat_artefact then
83843: LD_VAR 0 2
83847: PPUSH
83848: LD_VAR 0 3
83852: PPUSH
83853: CALL_OW 283
83857: PUSH
83858: LD_INT 4
83860: EQUAL
83861: IFFALSE 83865
// exit ;
83863: GO 84173
// for i = 1 to mc_bases do
83865: LD_ADDR_VAR 0 7
83869: PUSH
83870: DOUBLE
83871: LD_INT 1
83873: DEC
83874: ST_TO_ADDR
83875: LD_EXP 58
83879: PUSH
83880: FOR_TO
83881: IFFALSE 84171
// begin if mc_crates_area [ i ] then
83883: LD_EXP 76
83887: PUSH
83888: LD_VAR 0 7
83892: ARRAY
83893: IFFALSE 84004
// for j in mc_crates_area [ i ] do
83895: LD_ADDR_VAR 0 8
83899: PUSH
83900: LD_EXP 76
83904: PUSH
83905: LD_VAR 0 7
83909: ARRAY
83910: PUSH
83911: FOR_IN
83912: IFFALSE 84002
// if InArea ( x , y , j ) then
83914: LD_VAR 0 2
83918: PPUSH
83919: LD_VAR 0 3
83923: PPUSH
83924: LD_VAR 0 8
83928: PPUSH
83929: CALL_OW 309
83933: IFFALSE 84000
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83935: LD_ADDR_EXP 74
83939: PUSH
83940: LD_EXP 74
83944: PPUSH
83945: LD_VAR 0 7
83949: PUSH
83950: LD_EXP 74
83954: PUSH
83955: LD_VAR 0 7
83959: ARRAY
83960: PUSH
83961: LD_INT 1
83963: PLUS
83964: PUSH
83965: EMPTY
83966: LIST
83967: LIST
83968: PPUSH
83969: LD_VAR 0 4
83973: PUSH
83974: LD_VAR 0 2
83978: PUSH
83979: LD_VAR 0 3
83983: PUSH
83984: EMPTY
83985: LIST
83986: LIST
83987: LIST
83988: PPUSH
83989: CALL 21366 0 3
83993: ST_TO_ADDR
// exit ;
83994: POP
83995: POP
83996: POP
83997: POP
83998: GO 84173
// end ;
84000: GO 83911
84002: POP
84003: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84004: LD_ADDR_VAR 0 9
84008: PUSH
84009: LD_EXP 58
84013: PUSH
84014: LD_VAR 0 7
84018: ARRAY
84019: PPUSH
84020: LD_INT 2
84022: PUSH
84023: LD_INT 30
84025: PUSH
84026: LD_INT 0
84028: PUSH
84029: EMPTY
84030: LIST
84031: LIST
84032: PUSH
84033: LD_INT 30
84035: PUSH
84036: LD_INT 1
84038: PUSH
84039: EMPTY
84040: LIST
84041: LIST
84042: PUSH
84043: EMPTY
84044: LIST
84045: LIST
84046: LIST
84047: PPUSH
84048: CALL_OW 72
84052: ST_TO_ADDR
// if not depot then
84053: LD_VAR 0 9
84057: NOT
84058: IFFALSE 84062
// continue ;
84060: GO 83880
// for j in depot do
84062: LD_ADDR_VAR 0 8
84066: PUSH
84067: LD_VAR 0 9
84071: PUSH
84072: FOR_IN
84073: IFFALSE 84167
// if GetDistUnitXY ( j , x , y ) < 30 then
84075: LD_VAR 0 8
84079: PPUSH
84080: LD_VAR 0 2
84084: PPUSH
84085: LD_VAR 0 3
84089: PPUSH
84090: CALL_OW 297
84094: PUSH
84095: LD_INT 30
84097: LESS
84098: IFFALSE 84165
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84100: LD_ADDR_EXP 74
84104: PUSH
84105: LD_EXP 74
84109: PPUSH
84110: LD_VAR 0 7
84114: PUSH
84115: LD_EXP 74
84119: PUSH
84120: LD_VAR 0 7
84124: ARRAY
84125: PUSH
84126: LD_INT 1
84128: PLUS
84129: PUSH
84130: EMPTY
84131: LIST
84132: LIST
84133: PPUSH
84134: LD_VAR 0 4
84138: PUSH
84139: LD_VAR 0 2
84143: PUSH
84144: LD_VAR 0 3
84148: PUSH
84149: EMPTY
84150: LIST
84151: LIST
84152: LIST
84153: PPUSH
84154: CALL 21366 0 3
84158: ST_TO_ADDR
// exit ;
84159: POP
84160: POP
84161: POP
84162: POP
84163: GO 84173
// end ;
84165: GO 84072
84167: POP
84168: POP
// end ;
84169: GO 83880
84171: POP
84172: POP
// end ;
84173: LD_VAR 0 6
84177: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
84178: LD_INT 0
84180: PPUSH
84181: PPUSH
84182: PPUSH
84183: PPUSH
// if not mc_bases or not skirmish then
84184: LD_EXP 58
84188: NOT
84189: PUSH
84190: LD_EXP 56
84194: NOT
84195: OR
84196: IFFALSE 84200
// exit ;
84198: GO 84477
// side := GetSide ( lab ) ;
84200: LD_ADDR_VAR 0 4
84204: PUSH
84205: LD_VAR 0 2
84209: PPUSH
84210: CALL_OW 255
84214: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
84215: LD_VAR 0 4
84219: PUSH
84220: LD_EXP 84
84224: IN
84225: NOT
84226: PUSH
84227: LD_EXP 85
84231: NOT
84232: OR
84233: PUSH
84234: LD_EXP 58
84238: NOT
84239: OR
84240: IFFALSE 84244
// exit ;
84242: GO 84477
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
84244: LD_ADDR_EXP 85
84248: PUSH
84249: LD_EXP 85
84253: PPUSH
84254: LD_VAR 0 4
84258: PPUSH
84259: LD_EXP 85
84263: PUSH
84264: LD_VAR 0 4
84268: ARRAY
84269: PUSH
84270: LD_VAR 0 1
84274: DIFF
84275: PPUSH
84276: CALL_OW 1
84280: ST_TO_ADDR
// for i = 1 to mc_bases do
84281: LD_ADDR_VAR 0 5
84285: PUSH
84286: DOUBLE
84287: LD_INT 1
84289: DEC
84290: ST_TO_ADDR
84291: LD_EXP 58
84295: PUSH
84296: FOR_TO
84297: IFFALSE 84475
// begin if lab in mc_bases [ i ] then
84299: LD_VAR 0 2
84303: PUSH
84304: LD_EXP 58
84308: PUSH
84309: LD_VAR 0 5
84313: ARRAY
84314: IN
84315: IFFALSE 84473
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
84317: LD_VAR 0 1
84321: PUSH
84322: LD_INT 11
84324: PUSH
84325: LD_INT 4
84327: PUSH
84328: LD_INT 3
84330: PUSH
84331: LD_INT 2
84333: PUSH
84334: EMPTY
84335: LIST
84336: LIST
84337: LIST
84338: LIST
84339: IN
84340: PUSH
84341: LD_EXP 88
84345: PUSH
84346: LD_VAR 0 5
84350: ARRAY
84351: AND
84352: IFFALSE 84473
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
84354: LD_ADDR_VAR 0 6
84358: PUSH
84359: LD_EXP 88
84363: PUSH
84364: LD_VAR 0 5
84368: ARRAY
84369: PUSH
84370: LD_INT 1
84372: ARRAY
84373: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84374: LD_ADDR_EXP 88
84378: PUSH
84379: LD_EXP 88
84383: PPUSH
84384: LD_VAR 0 5
84388: PPUSH
84389: EMPTY
84390: PPUSH
84391: CALL_OW 1
84395: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
84396: LD_VAR 0 6
84400: PPUSH
84401: LD_INT 0
84403: PPUSH
84404: CALL_OW 109
// ComExitBuilding ( tmp ) ;
84408: LD_VAR 0 6
84412: PPUSH
84413: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
84417: LD_ADDR_EXP 87
84421: PUSH
84422: LD_EXP 87
84426: PPUSH
84427: LD_VAR 0 5
84431: PPUSH
84432: LD_EXP 87
84436: PUSH
84437: LD_VAR 0 5
84441: ARRAY
84442: PPUSH
84443: LD_INT 1
84445: PPUSH
84446: LD_VAR 0 6
84450: PPUSH
84451: CALL_OW 2
84455: PPUSH
84456: CALL_OW 1
84460: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
84461: LD_VAR 0 5
84465: PPUSH
84466: LD_INT 112
84468: PPUSH
84469: CALL 61369 0 2
// end ; end ; end ;
84473: GO 84296
84475: POP
84476: POP
// end ;
84477: LD_VAR 0 3
84481: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
84482: LD_INT 0
84484: PPUSH
84485: PPUSH
84486: PPUSH
84487: PPUSH
84488: PPUSH
84489: PPUSH
84490: PPUSH
84491: PPUSH
// if not mc_bases or not skirmish then
84492: LD_EXP 58
84496: NOT
84497: PUSH
84498: LD_EXP 56
84502: NOT
84503: OR
84504: IFFALSE 84508
// exit ;
84506: GO 85879
// for i = 1 to mc_bases do
84508: LD_ADDR_VAR 0 3
84512: PUSH
84513: DOUBLE
84514: LD_INT 1
84516: DEC
84517: ST_TO_ADDR
84518: LD_EXP 58
84522: PUSH
84523: FOR_TO
84524: IFFALSE 85877
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
84526: LD_VAR 0 1
84530: PUSH
84531: LD_EXP 58
84535: PUSH
84536: LD_VAR 0 3
84540: ARRAY
84541: IN
84542: PUSH
84543: LD_VAR 0 1
84547: PUSH
84548: LD_EXP 65
84552: PUSH
84553: LD_VAR 0 3
84557: ARRAY
84558: IN
84559: OR
84560: PUSH
84561: LD_VAR 0 1
84565: PUSH
84566: LD_EXP 80
84570: PUSH
84571: LD_VAR 0 3
84575: ARRAY
84576: IN
84577: OR
84578: PUSH
84579: LD_VAR 0 1
84583: PUSH
84584: LD_EXP 77
84588: PUSH
84589: LD_VAR 0 3
84593: ARRAY
84594: IN
84595: OR
84596: PUSH
84597: LD_VAR 0 1
84601: PUSH
84602: LD_EXP 87
84606: PUSH
84607: LD_VAR 0 3
84611: ARRAY
84612: IN
84613: OR
84614: PUSH
84615: LD_VAR 0 1
84619: PUSH
84620: LD_EXP 88
84624: PUSH
84625: LD_VAR 0 3
84629: ARRAY
84630: IN
84631: OR
84632: IFFALSE 85875
// begin if un in mc_ape [ i ] then
84634: LD_VAR 0 1
84638: PUSH
84639: LD_EXP 87
84643: PUSH
84644: LD_VAR 0 3
84648: ARRAY
84649: IN
84650: IFFALSE 84689
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
84652: LD_ADDR_EXP 87
84656: PUSH
84657: LD_EXP 87
84661: PPUSH
84662: LD_VAR 0 3
84666: PPUSH
84667: LD_EXP 87
84671: PUSH
84672: LD_VAR 0 3
84676: ARRAY
84677: PUSH
84678: LD_VAR 0 1
84682: DIFF
84683: PPUSH
84684: CALL_OW 1
84688: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
84689: LD_VAR 0 1
84693: PUSH
84694: LD_EXP 88
84698: PUSH
84699: LD_VAR 0 3
84703: ARRAY
84704: IN
84705: IFFALSE 84729
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84707: LD_ADDR_EXP 88
84711: PUSH
84712: LD_EXP 88
84716: PPUSH
84717: LD_VAR 0 3
84721: PPUSH
84722: EMPTY
84723: PPUSH
84724: CALL_OW 1
84728: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
84729: LD_VAR 0 1
84733: PPUSH
84734: CALL_OW 247
84738: PUSH
84739: LD_INT 2
84741: EQUAL
84742: PUSH
84743: LD_VAR 0 1
84747: PPUSH
84748: CALL_OW 110
84752: PUSH
84753: LD_INT 20
84755: EQUAL
84756: PUSH
84757: LD_VAR 0 1
84761: PUSH
84762: LD_EXP 80
84766: PUSH
84767: LD_VAR 0 3
84771: ARRAY
84772: IN
84773: OR
84774: PUSH
84775: LD_VAR 0 1
84779: PPUSH
84780: CALL_OW 264
84784: PUSH
84785: LD_INT 12
84787: PUSH
84788: LD_INT 51
84790: PUSH
84791: LD_EXP 102
84795: PUSH
84796: LD_INT 32
84798: PUSH
84799: LD_INT 13
84801: PUSH
84802: LD_INT 52
84804: PUSH
84805: LD_INT 31
84807: PUSH
84808: EMPTY
84809: LIST
84810: LIST
84811: LIST
84812: LIST
84813: LIST
84814: LIST
84815: LIST
84816: IN
84817: OR
84818: AND
84819: IFFALSE 85127
// begin if un in mc_defender [ i ] then
84821: LD_VAR 0 1
84825: PUSH
84826: LD_EXP 80
84830: PUSH
84831: LD_VAR 0 3
84835: ARRAY
84836: IN
84837: IFFALSE 84876
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84839: LD_ADDR_EXP 80
84843: PUSH
84844: LD_EXP 80
84848: PPUSH
84849: LD_VAR 0 3
84853: PPUSH
84854: LD_EXP 80
84858: PUSH
84859: LD_VAR 0 3
84863: ARRAY
84864: PUSH
84865: LD_VAR 0 1
84869: DIFF
84870: PPUSH
84871: CALL_OW 1
84875: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
84876: LD_ADDR_VAR 0 8
84880: PUSH
84881: LD_VAR 0 3
84885: PPUSH
84886: LD_INT 3
84888: PPUSH
84889: CALL 81545 0 2
84893: ST_TO_ADDR
// if fac then
84894: LD_VAR 0 8
84898: IFFALSE 85127
// begin for j in fac do
84900: LD_ADDR_VAR 0 4
84904: PUSH
84905: LD_VAR 0 8
84909: PUSH
84910: FOR_IN
84911: IFFALSE 85125
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
84913: LD_ADDR_VAR 0 9
84917: PUSH
84918: LD_VAR 0 8
84922: PPUSH
84923: LD_VAR 0 1
84927: PPUSH
84928: CALL_OW 265
84932: PPUSH
84933: LD_VAR 0 1
84937: PPUSH
84938: CALL_OW 262
84942: PPUSH
84943: LD_VAR 0 1
84947: PPUSH
84948: CALL_OW 263
84952: PPUSH
84953: LD_VAR 0 1
84957: PPUSH
84958: CALL_OW 264
84962: PPUSH
84963: CALL 18898 0 5
84967: ST_TO_ADDR
// if components then
84968: LD_VAR 0 9
84972: IFFALSE 85123
// begin if GetWeapon ( un ) = ar_control_tower then
84974: LD_VAR 0 1
84978: PPUSH
84979: CALL_OW 264
84983: PUSH
84984: LD_INT 31
84986: EQUAL
84987: IFFALSE 85104
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
84989: LD_VAR 0 1
84993: PPUSH
84994: CALL_OW 311
84998: PPUSH
84999: LD_INT 0
85001: PPUSH
85002: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
85006: LD_ADDR_EXP 98
85010: PUSH
85011: LD_EXP 98
85015: PPUSH
85016: LD_VAR 0 3
85020: PPUSH
85021: LD_EXP 98
85025: PUSH
85026: LD_VAR 0 3
85030: ARRAY
85031: PUSH
85032: LD_VAR 0 1
85036: PPUSH
85037: CALL_OW 311
85041: DIFF
85042: PPUSH
85043: CALL_OW 1
85047: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
85048: LD_ADDR_VAR 0 7
85052: PUSH
85053: LD_EXP 79
85057: PUSH
85058: LD_VAR 0 3
85062: ARRAY
85063: PPUSH
85064: LD_INT 1
85066: PPUSH
85067: LD_VAR 0 9
85071: PPUSH
85072: CALL_OW 2
85076: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
85077: LD_ADDR_EXP 79
85081: PUSH
85082: LD_EXP 79
85086: PPUSH
85087: LD_VAR 0 3
85091: PPUSH
85092: LD_VAR 0 7
85096: PPUSH
85097: CALL_OW 1
85101: ST_TO_ADDR
// end else
85102: GO 85121
// MC_InsertProduceList ( i , [ components ] ) ;
85104: LD_VAR 0 3
85108: PPUSH
85109: LD_VAR 0 9
85113: PUSH
85114: EMPTY
85115: LIST
85116: PPUSH
85117: CALL 81090 0 2
// break ;
85121: GO 85125
// end ; end ;
85123: GO 84910
85125: POP
85126: POP
// end ; end ; if GetType ( un ) = unit_building then
85127: LD_VAR 0 1
85131: PPUSH
85132: CALL_OW 247
85136: PUSH
85137: LD_INT 3
85139: EQUAL
85140: IFFALSE 85543
// begin btype := GetBType ( un ) ;
85142: LD_ADDR_VAR 0 5
85146: PUSH
85147: LD_VAR 0 1
85151: PPUSH
85152: CALL_OW 266
85156: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
85157: LD_VAR 0 5
85161: PUSH
85162: LD_INT 29
85164: PUSH
85165: LD_INT 30
85167: PUSH
85168: EMPTY
85169: LIST
85170: LIST
85171: IN
85172: IFFALSE 85245
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
85174: LD_VAR 0 1
85178: PPUSH
85179: CALL_OW 250
85183: PPUSH
85184: LD_VAR 0 1
85188: PPUSH
85189: CALL_OW 251
85193: PPUSH
85194: LD_VAR 0 1
85198: PPUSH
85199: CALL_OW 255
85203: PPUSH
85204: CALL_OW 440
85208: NOT
85209: IFFALSE 85245
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
85211: LD_VAR 0 1
85215: PPUSH
85216: CALL_OW 250
85220: PPUSH
85221: LD_VAR 0 1
85225: PPUSH
85226: CALL_OW 251
85230: PPUSH
85231: LD_VAR 0 1
85235: PPUSH
85236: CALL_OW 255
85240: PPUSH
85241: CALL_OW 441
// end ; if btype = b_warehouse then
85245: LD_VAR 0 5
85249: PUSH
85250: LD_INT 1
85252: EQUAL
85253: IFFALSE 85271
// begin btype := b_depot ;
85255: LD_ADDR_VAR 0 5
85259: PUSH
85260: LD_INT 0
85262: ST_TO_ADDR
// pos := 1 ;
85263: LD_ADDR_VAR 0 6
85267: PUSH
85268: LD_INT 1
85270: ST_TO_ADDR
// end ; if btype = b_factory then
85271: LD_VAR 0 5
85275: PUSH
85276: LD_INT 3
85278: EQUAL
85279: IFFALSE 85297
// begin btype := b_workshop ;
85281: LD_ADDR_VAR 0 5
85285: PUSH
85286: LD_INT 2
85288: ST_TO_ADDR
// pos := 1 ;
85289: LD_ADDR_VAR 0 6
85293: PUSH
85294: LD_INT 1
85296: ST_TO_ADDR
// end ; if btype = b_barracks then
85297: LD_VAR 0 5
85301: PUSH
85302: LD_INT 5
85304: EQUAL
85305: IFFALSE 85315
// btype := b_armoury ;
85307: LD_ADDR_VAR 0 5
85311: PUSH
85312: LD_INT 4
85314: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
85315: LD_VAR 0 5
85319: PUSH
85320: LD_INT 7
85322: PUSH
85323: LD_INT 8
85325: PUSH
85326: EMPTY
85327: LIST
85328: LIST
85329: IN
85330: IFFALSE 85340
// btype := b_lab ;
85332: LD_ADDR_VAR 0 5
85336: PUSH
85337: LD_INT 6
85339: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
85340: LD_ADDR_EXP 63
85344: PUSH
85345: LD_EXP 63
85349: PPUSH
85350: LD_VAR 0 3
85354: PUSH
85355: LD_EXP 63
85359: PUSH
85360: LD_VAR 0 3
85364: ARRAY
85365: PUSH
85366: LD_INT 1
85368: PLUS
85369: PUSH
85370: EMPTY
85371: LIST
85372: LIST
85373: PPUSH
85374: LD_VAR 0 5
85378: PUSH
85379: LD_VAR 0 1
85383: PPUSH
85384: CALL_OW 250
85388: PUSH
85389: LD_VAR 0 1
85393: PPUSH
85394: CALL_OW 251
85398: PUSH
85399: LD_VAR 0 1
85403: PPUSH
85404: CALL_OW 254
85408: PUSH
85409: EMPTY
85410: LIST
85411: LIST
85412: LIST
85413: LIST
85414: PPUSH
85415: CALL 21366 0 3
85419: ST_TO_ADDR
// if pos = 1 then
85420: LD_VAR 0 6
85424: PUSH
85425: LD_INT 1
85427: EQUAL
85428: IFFALSE 85543
// begin tmp := mc_build_list [ i ] ;
85430: LD_ADDR_VAR 0 7
85434: PUSH
85435: LD_EXP 63
85439: PUSH
85440: LD_VAR 0 3
85444: ARRAY
85445: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
85446: LD_VAR 0 7
85450: PPUSH
85451: LD_INT 2
85453: PUSH
85454: LD_INT 30
85456: PUSH
85457: LD_INT 0
85459: PUSH
85460: EMPTY
85461: LIST
85462: LIST
85463: PUSH
85464: LD_INT 30
85466: PUSH
85467: LD_INT 1
85469: PUSH
85470: EMPTY
85471: LIST
85472: LIST
85473: PUSH
85474: EMPTY
85475: LIST
85476: LIST
85477: LIST
85478: PPUSH
85479: CALL_OW 72
85483: IFFALSE 85493
// pos := 2 ;
85485: LD_ADDR_VAR 0 6
85489: PUSH
85490: LD_INT 2
85492: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
85493: LD_ADDR_VAR 0 7
85497: PUSH
85498: LD_VAR 0 7
85502: PPUSH
85503: LD_VAR 0 6
85507: PPUSH
85508: LD_VAR 0 7
85512: PPUSH
85513: CALL 21692 0 3
85517: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
85518: LD_ADDR_EXP 63
85522: PUSH
85523: LD_EXP 63
85527: PPUSH
85528: LD_VAR 0 3
85532: PPUSH
85533: LD_VAR 0 7
85537: PPUSH
85538: CALL_OW 1
85542: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
85543: LD_VAR 0 1
85547: PUSH
85548: LD_EXP 58
85552: PUSH
85553: LD_VAR 0 3
85557: ARRAY
85558: IN
85559: IFFALSE 85598
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
85561: LD_ADDR_EXP 58
85565: PUSH
85566: LD_EXP 58
85570: PPUSH
85571: LD_VAR 0 3
85575: PPUSH
85576: LD_EXP 58
85580: PUSH
85581: LD_VAR 0 3
85585: ARRAY
85586: PUSH
85587: LD_VAR 0 1
85591: DIFF
85592: PPUSH
85593: CALL_OW 1
85597: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
85598: LD_VAR 0 1
85602: PUSH
85603: LD_EXP 65
85607: PUSH
85608: LD_VAR 0 3
85612: ARRAY
85613: IN
85614: IFFALSE 85653
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
85616: LD_ADDR_EXP 65
85620: PUSH
85621: LD_EXP 65
85625: PPUSH
85626: LD_VAR 0 3
85630: PPUSH
85631: LD_EXP 65
85635: PUSH
85636: LD_VAR 0 3
85640: ARRAY
85641: PUSH
85642: LD_VAR 0 1
85646: DIFF
85647: PPUSH
85648: CALL_OW 1
85652: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
85653: LD_VAR 0 1
85657: PUSH
85658: LD_EXP 77
85662: PUSH
85663: LD_VAR 0 3
85667: ARRAY
85668: IN
85669: IFFALSE 85708
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
85671: LD_ADDR_EXP 77
85675: PUSH
85676: LD_EXP 77
85680: PPUSH
85681: LD_VAR 0 3
85685: PPUSH
85686: LD_EXP 77
85690: PUSH
85691: LD_VAR 0 3
85695: ARRAY
85696: PUSH
85697: LD_VAR 0 1
85701: DIFF
85702: PPUSH
85703: CALL_OW 1
85707: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
85708: LD_VAR 0 1
85712: PUSH
85713: LD_EXP 80
85717: PUSH
85718: LD_VAR 0 3
85722: ARRAY
85723: IN
85724: IFFALSE 85763
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85726: LD_ADDR_EXP 80
85730: PUSH
85731: LD_EXP 80
85735: PPUSH
85736: LD_VAR 0 3
85740: PPUSH
85741: LD_EXP 80
85745: PUSH
85746: LD_VAR 0 3
85750: ARRAY
85751: PUSH
85752: LD_VAR 0 1
85756: DIFF
85757: PPUSH
85758: CALL_OW 1
85762: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
85763: LD_VAR 0 1
85767: PUSH
85768: LD_EXP 67
85772: PUSH
85773: LD_VAR 0 3
85777: ARRAY
85778: IN
85779: IFFALSE 85818
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
85781: LD_ADDR_EXP 67
85785: PUSH
85786: LD_EXP 67
85790: PPUSH
85791: LD_VAR 0 3
85795: PPUSH
85796: LD_EXP 67
85800: PUSH
85801: LD_VAR 0 3
85805: ARRAY
85806: PUSH
85807: LD_VAR 0 1
85811: DIFF
85812: PPUSH
85813: CALL_OW 1
85817: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
85818: LD_VAR 0 1
85822: PUSH
85823: LD_EXP 66
85827: PUSH
85828: LD_VAR 0 3
85832: ARRAY
85833: IN
85834: IFFALSE 85873
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
85836: LD_ADDR_EXP 66
85840: PUSH
85841: LD_EXP 66
85845: PPUSH
85846: LD_VAR 0 3
85850: PPUSH
85851: LD_EXP 66
85855: PUSH
85856: LD_VAR 0 3
85860: ARRAY
85861: PUSH
85862: LD_VAR 0 1
85866: DIFF
85867: PPUSH
85868: CALL_OW 1
85872: ST_TO_ADDR
// end ; break ;
85873: GO 85877
// end ;
85875: GO 84523
85877: POP
85878: POP
// end ;
85879: LD_VAR 0 2
85883: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
85884: LD_INT 0
85886: PPUSH
85887: PPUSH
85888: PPUSH
// if not mc_bases or not skirmish then
85889: LD_EXP 58
85893: NOT
85894: PUSH
85895: LD_EXP 56
85899: NOT
85900: OR
85901: IFFALSE 85905
// exit ;
85903: GO 86120
// for i = 1 to mc_bases do
85905: LD_ADDR_VAR 0 3
85909: PUSH
85910: DOUBLE
85911: LD_INT 1
85913: DEC
85914: ST_TO_ADDR
85915: LD_EXP 58
85919: PUSH
85920: FOR_TO
85921: IFFALSE 86118
// begin if building in mc_construct_list [ i ] then
85923: LD_VAR 0 1
85927: PUSH
85928: LD_EXP 65
85932: PUSH
85933: LD_VAR 0 3
85937: ARRAY
85938: IN
85939: IFFALSE 86116
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85941: LD_ADDR_EXP 65
85945: PUSH
85946: LD_EXP 65
85950: PPUSH
85951: LD_VAR 0 3
85955: PPUSH
85956: LD_EXP 65
85960: PUSH
85961: LD_VAR 0 3
85965: ARRAY
85966: PUSH
85967: LD_VAR 0 1
85971: DIFF
85972: PPUSH
85973: CALL_OW 1
85977: ST_TO_ADDR
// if building in mc_lab [ i ] then
85978: LD_VAR 0 1
85982: PUSH
85983: LD_EXP 91
85987: PUSH
85988: LD_VAR 0 3
85992: ARRAY
85993: IN
85994: IFFALSE 86049
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
85996: LD_ADDR_EXP 92
86000: PUSH
86001: LD_EXP 92
86005: PPUSH
86006: LD_VAR 0 3
86010: PPUSH
86011: LD_EXP 92
86015: PUSH
86016: LD_VAR 0 3
86020: ARRAY
86021: PPUSH
86022: LD_INT 1
86024: PPUSH
86025: LD_EXP 92
86029: PUSH
86030: LD_VAR 0 3
86034: ARRAY
86035: PPUSH
86036: LD_INT 0
86038: PPUSH
86039: CALL 20784 0 4
86043: PPUSH
86044: CALL_OW 1
86048: ST_TO_ADDR
// if not building in mc_bases [ i ] then
86049: LD_VAR 0 1
86053: PUSH
86054: LD_EXP 58
86058: PUSH
86059: LD_VAR 0 3
86063: ARRAY
86064: IN
86065: NOT
86066: IFFALSE 86112
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86068: LD_ADDR_EXP 58
86072: PUSH
86073: LD_EXP 58
86077: PPUSH
86078: LD_VAR 0 3
86082: PUSH
86083: LD_EXP 58
86087: PUSH
86088: LD_VAR 0 3
86092: ARRAY
86093: PUSH
86094: LD_INT 1
86096: PLUS
86097: PUSH
86098: EMPTY
86099: LIST
86100: LIST
86101: PPUSH
86102: LD_VAR 0 1
86106: PPUSH
86107: CALL 21366 0 3
86111: ST_TO_ADDR
// exit ;
86112: POP
86113: POP
86114: GO 86120
// end ; end ;
86116: GO 85920
86118: POP
86119: POP
// end ;
86120: LD_VAR 0 2
86124: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
86125: LD_INT 0
86127: PPUSH
86128: PPUSH
86129: PPUSH
86130: PPUSH
86131: PPUSH
86132: PPUSH
86133: PPUSH
// if not mc_bases or not skirmish then
86134: LD_EXP 58
86138: NOT
86139: PUSH
86140: LD_EXP 56
86144: NOT
86145: OR
86146: IFFALSE 86150
// exit ;
86148: GO 86811
// for i = 1 to mc_bases do
86150: LD_ADDR_VAR 0 3
86154: PUSH
86155: DOUBLE
86156: LD_INT 1
86158: DEC
86159: ST_TO_ADDR
86160: LD_EXP 58
86164: PUSH
86165: FOR_TO
86166: IFFALSE 86809
// begin if building in mc_construct_list [ i ] then
86168: LD_VAR 0 1
86172: PUSH
86173: LD_EXP 65
86177: PUSH
86178: LD_VAR 0 3
86182: ARRAY
86183: IN
86184: IFFALSE 86807
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86186: LD_ADDR_EXP 65
86190: PUSH
86191: LD_EXP 65
86195: PPUSH
86196: LD_VAR 0 3
86200: PPUSH
86201: LD_EXP 65
86205: PUSH
86206: LD_VAR 0 3
86210: ARRAY
86211: PUSH
86212: LD_VAR 0 1
86216: DIFF
86217: PPUSH
86218: CALL_OW 1
86222: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86223: LD_ADDR_EXP 58
86227: PUSH
86228: LD_EXP 58
86232: PPUSH
86233: LD_VAR 0 3
86237: PUSH
86238: LD_EXP 58
86242: PUSH
86243: LD_VAR 0 3
86247: ARRAY
86248: PUSH
86249: LD_INT 1
86251: PLUS
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: PPUSH
86257: LD_VAR 0 1
86261: PPUSH
86262: CALL 21366 0 3
86266: ST_TO_ADDR
// btype := GetBType ( building ) ;
86267: LD_ADDR_VAR 0 5
86271: PUSH
86272: LD_VAR 0 1
86276: PPUSH
86277: CALL_OW 266
86281: ST_TO_ADDR
// side := GetSide ( building ) ;
86282: LD_ADDR_VAR 0 8
86286: PUSH
86287: LD_VAR 0 1
86291: PPUSH
86292: CALL_OW 255
86296: ST_TO_ADDR
// if btype = b_lab then
86297: LD_VAR 0 5
86301: PUSH
86302: LD_INT 6
86304: EQUAL
86305: IFFALSE 86355
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
86307: LD_ADDR_EXP 91
86311: PUSH
86312: LD_EXP 91
86316: PPUSH
86317: LD_VAR 0 3
86321: PUSH
86322: LD_EXP 91
86326: PUSH
86327: LD_VAR 0 3
86331: ARRAY
86332: PUSH
86333: LD_INT 1
86335: PLUS
86336: PUSH
86337: EMPTY
86338: LIST
86339: LIST
86340: PPUSH
86341: LD_VAR 0 1
86345: PPUSH
86346: CALL 21366 0 3
86350: ST_TO_ADDR
// exit ;
86351: POP
86352: POP
86353: GO 86811
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
86355: LD_VAR 0 5
86359: PUSH
86360: LD_INT 0
86362: PUSH
86363: LD_INT 2
86365: PUSH
86366: LD_INT 4
86368: PUSH
86369: EMPTY
86370: LIST
86371: LIST
86372: LIST
86373: IN
86374: IFFALSE 86498
// begin if btype = b_armoury then
86376: LD_VAR 0 5
86380: PUSH
86381: LD_INT 4
86383: EQUAL
86384: IFFALSE 86394
// btype := b_barracks ;
86386: LD_ADDR_VAR 0 5
86390: PUSH
86391: LD_INT 5
86393: ST_TO_ADDR
// if btype = b_depot then
86394: LD_VAR 0 5
86398: PUSH
86399: LD_INT 0
86401: EQUAL
86402: IFFALSE 86412
// btype := b_warehouse ;
86404: LD_ADDR_VAR 0 5
86408: PUSH
86409: LD_INT 1
86411: ST_TO_ADDR
// if btype = b_workshop then
86412: LD_VAR 0 5
86416: PUSH
86417: LD_INT 2
86419: EQUAL
86420: IFFALSE 86430
// btype := b_factory ;
86422: LD_ADDR_VAR 0 5
86426: PUSH
86427: LD_INT 3
86429: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
86430: LD_VAR 0 5
86434: PPUSH
86435: LD_VAR 0 8
86439: PPUSH
86440: CALL_OW 323
86444: PUSH
86445: LD_INT 1
86447: EQUAL
86448: IFFALSE 86494
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
86450: LD_ADDR_EXP 90
86454: PUSH
86455: LD_EXP 90
86459: PPUSH
86460: LD_VAR 0 3
86464: PUSH
86465: LD_EXP 90
86469: PUSH
86470: LD_VAR 0 3
86474: ARRAY
86475: PUSH
86476: LD_INT 1
86478: PLUS
86479: PUSH
86480: EMPTY
86481: LIST
86482: LIST
86483: PPUSH
86484: LD_VAR 0 1
86488: PPUSH
86489: CALL 21366 0 3
86493: ST_TO_ADDR
// exit ;
86494: POP
86495: POP
86496: GO 86811
// end ; if btype in [ b_bunker , b_turret ] then
86498: LD_VAR 0 5
86502: PUSH
86503: LD_INT 32
86505: PUSH
86506: LD_INT 33
86508: PUSH
86509: EMPTY
86510: LIST
86511: LIST
86512: IN
86513: IFFALSE 86803
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
86515: LD_ADDR_EXP 66
86519: PUSH
86520: LD_EXP 66
86524: PPUSH
86525: LD_VAR 0 3
86529: PUSH
86530: LD_EXP 66
86534: PUSH
86535: LD_VAR 0 3
86539: ARRAY
86540: PUSH
86541: LD_INT 1
86543: PLUS
86544: PUSH
86545: EMPTY
86546: LIST
86547: LIST
86548: PPUSH
86549: LD_VAR 0 1
86553: PPUSH
86554: CALL 21366 0 3
86558: ST_TO_ADDR
// if btype = b_bunker then
86559: LD_VAR 0 5
86563: PUSH
86564: LD_INT 32
86566: EQUAL
86567: IFFALSE 86803
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86569: LD_ADDR_EXP 67
86573: PUSH
86574: LD_EXP 67
86578: PPUSH
86579: LD_VAR 0 3
86583: PUSH
86584: LD_EXP 67
86588: PUSH
86589: LD_VAR 0 3
86593: ARRAY
86594: PUSH
86595: LD_INT 1
86597: PLUS
86598: PUSH
86599: EMPTY
86600: LIST
86601: LIST
86602: PPUSH
86603: LD_VAR 0 1
86607: PPUSH
86608: CALL 21366 0 3
86612: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
86613: LD_ADDR_VAR 0 6
86617: PUSH
86618: LD_EXP 58
86622: PUSH
86623: LD_VAR 0 3
86627: ARRAY
86628: PPUSH
86629: LD_INT 25
86631: PUSH
86632: LD_INT 1
86634: PUSH
86635: EMPTY
86636: LIST
86637: LIST
86638: PUSH
86639: LD_INT 3
86641: PUSH
86642: LD_INT 54
86644: PUSH
86645: EMPTY
86646: LIST
86647: PUSH
86648: EMPTY
86649: LIST
86650: LIST
86651: PUSH
86652: EMPTY
86653: LIST
86654: LIST
86655: PPUSH
86656: CALL_OW 72
86660: ST_TO_ADDR
// if tmp then
86661: LD_VAR 0 6
86665: IFFALSE 86671
// exit ;
86667: POP
86668: POP
86669: GO 86811
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86671: LD_ADDR_VAR 0 6
86675: PUSH
86676: LD_EXP 58
86680: PUSH
86681: LD_VAR 0 3
86685: ARRAY
86686: PPUSH
86687: LD_INT 2
86689: PUSH
86690: LD_INT 30
86692: PUSH
86693: LD_INT 4
86695: PUSH
86696: EMPTY
86697: LIST
86698: LIST
86699: PUSH
86700: LD_INT 30
86702: PUSH
86703: LD_INT 5
86705: PUSH
86706: EMPTY
86707: LIST
86708: LIST
86709: PUSH
86710: EMPTY
86711: LIST
86712: LIST
86713: LIST
86714: PPUSH
86715: CALL_OW 72
86719: ST_TO_ADDR
// if not tmp then
86720: LD_VAR 0 6
86724: NOT
86725: IFFALSE 86731
// exit ;
86727: POP
86728: POP
86729: GO 86811
// for j in tmp do
86731: LD_ADDR_VAR 0 4
86735: PUSH
86736: LD_VAR 0 6
86740: PUSH
86741: FOR_IN
86742: IFFALSE 86801
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
86744: LD_ADDR_VAR 0 7
86748: PUSH
86749: LD_VAR 0 4
86753: PPUSH
86754: CALL_OW 313
86758: PPUSH
86759: LD_INT 25
86761: PUSH
86762: LD_INT 1
86764: PUSH
86765: EMPTY
86766: LIST
86767: LIST
86768: PPUSH
86769: CALL_OW 72
86773: ST_TO_ADDR
// if units then
86774: LD_VAR 0 7
86778: IFFALSE 86799
// begin ComExitBuilding ( units [ 1 ] ) ;
86780: LD_VAR 0 7
86784: PUSH
86785: LD_INT 1
86787: ARRAY
86788: PPUSH
86789: CALL_OW 122
// exit ;
86793: POP
86794: POP
86795: POP
86796: POP
86797: GO 86811
// end ; end ;
86799: GO 86741
86801: POP
86802: POP
// end ; end ; exit ;
86803: POP
86804: POP
86805: GO 86811
// end ; end ;
86807: GO 86165
86809: POP
86810: POP
// end ;
86811: LD_VAR 0 2
86815: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
86816: LD_INT 0
86818: PPUSH
86819: PPUSH
86820: PPUSH
86821: PPUSH
86822: PPUSH
86823: PPUSH
86824: PPUSH
// if not mc_bases or not skirmish then
86825: LD_EXP 58
86829: NOT
86830: PUSH
86831: LD_EXP 56
86835: NOT
86836: OR
86837: IFFALSE 86841
// exit ;
86839: GO 87072
// btype := GetBType ( building ) ;
86841: LD_ADDR_VAR 0 6
86845: PUSH
86846: LD_VAR 0 1
86850: PPUSH
86851: CALL_OW 266
86855: ST_TO_ADDR
// x := GetX ( building ) ;
86856: LD_ADDR_VAR 0 7
86860: PUSH
86861: LD_VAR 0 1
86865: PPUSH
86866: CALL_OW 250
86870: ST_TO_ADDR
// y := GetY ( building ) ;
86871: LD_ADDR_VAR 0 8
86875: PUSH
86876: LD_VAR 0 1
86880: PPUSH
86881: CALL_OW 251
86885: ST_TO_ADDR
// d := GetDir ( building ) ;
86886: LD_ADDR_VAR 0 9
86890: PUSH
86891: LD_VAR 0 1
86895: PPUSH
86896: CALL_OW 254
86900: ST_TO_ADDR
// for i = 1 to mc_bases do
86901: LD_ADDR_VAR 0 4
86905: PUSH
86906: DOUBLE
86907: LD_INT 1
86909: DEC
86910: ST_TO_ADDR
86911: LD_EXP 58
86915: PUSH
86916: FOR_TO
86917: IFFALSE 87070
// begin if not mc_build_list [ i ] then
86919: LD_EXP 63
86923: PUSH
86924: LD_VAR 0 4
86928: ARRAY
86929: NOT
86930: IFFALSE 86934
// continue ;
86932: GO 86916
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
86934: LD_VAR 0 6
86938: PUSH
86939: LD_VAR 0 7
86943: PUSH
86944: LD_VAR 0 8
86948: PUSH
86949: LD_VAR 0 9
86953: PUSH
86954: EMPTY
86955: LIST
86956: LIST
86957: LIST
86958: LIST
86959: PPUSH
86960: LD_EXP 63
86964: PUSH
86965: LD_VAR 0 4
86969: ARRAY
86970: PUSH
86971: LD_INT 1
86973: ARRAY
86974: PPUSH
86975: CALL 27535 0 2
86979: IFFALSE 87068
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
86981: LD_ADDR_EXP 63
86985: PUSH
86986: LD_EXP 63
86990: PPUSH
86991: LD_VAR 0 4
86995: PPUSH
86996: LD_EXP 63
87000: PUSH
87001: LD_VAR 0 4
87005: ARRAY
87006: PPUSH
87007: LD_INT 1
87009: PPUSH
87010: CALL_OW 3
87014: PPUSH
87015: CALL_OW 1
87019: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
87020: LD_ADDR_EXP 65
87024: PUSH
87025: LD_EXP 65
87029: PPUSH
87030: LD_VAR 0 4
87034: PUSH
87035: LD_EXP 65
87039: PUSH
87040: LD_VAR 0 4
87044: ARRAY
87045: PUSH
87046: LD_INT 1
87048: PLUS
87049: PUSH
87050: EMPTY
87051: LIST
87052: LIST
87053: PPUSH
87054: LD_VAR 0 1
87058: PPUSH
87059: CALL 21366 0 3
87063: ST_TO_ADDR
// exit ;
87064: POP
87065: POP
87066: GO 87072
// end ; end ;
87068: GO 86916
87070: POP
87071: POP
// end ;
87072: LD_VAR 0 3
87076: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
87077: LD_INT 0
87079: PPUSH
87080: PPUSH
87081: PPUSH
// if not mc_bases or not skirmish then
87082: LD_EXP 58
87086: NOT
87087: PUSH
87088: LD_EXP 56
87092: NOT
87093: OR
87094: IFFALSE 87098
// exit ;
87096: GO 87288
// for i = 1 to mc_bases do
87098: LD_ADDR_VAR 0 4
87102: PUSH
87103: DOUBLE
87104: LD_INT 1
87106: DEC
87107: ST_TO_ADDR
87108: LD_EXP 58
87112: PUSH
87113: FOR_TO
87114: IFFALSE 87201
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
87116: LD_VAR 0 1
87120: PUSH
87121: LD_EXP 66
87125: PUSH
87126: LD_VAR 0 4
87130: ARRAY
87131: IN
87132: PUSH
87133: LD_VAR 0 1
87137: PUSH
87138: LD_EXP 67
87142: PUSH
87143: LD_VAR 0 4
87147: ARRAY
87148: IN
87149: NOT
87150: AND
87151: IFFALSE 87199
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
87153: LD_ADDR_EXP 67
87157: PUSH
87158: LD_EXP 67
87162: PPUSH
87163: LD_VAR 0 4
87167: PUSH
87168: LD_EXP 67
87172: PUSH
87173: LD_VAR 0 4
87177: ARRAY
87178: PUSH
87179: LD_INT 1
87181: PLUS
87182: PUSH
87183: EMPTY
87184: LIST
87185: LIST
87186: PPUSH
87187: LD_VAR 0 1
87191: PPUSH
87192: CALL 21366 0 3
87196: ST_TO_ADDR
// break ;
87197: GO 87201
// end ; end ;
87199: GO 87113
87201: POP
87202: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
87203: LD_VAR 0 1
87207: PPUSH
87208: CALL_OW 257
87212: PUSH
87213: LD_EXP 84
87217: IN
87218: PUSH
87219: LD_VAR 0 1
87223: PPUSH
87224: CALL_OW 266
87228: PUSH
87229: LD_INT 5
87231: EQUAL
87232: AND
87233: PUSH
87234: LD_VAR 0 2
87238: PPUSH
87239: CALL_OW 110
87243: PUSH
87244: LD_INT 18
87246: NONEQUAL
87247: AND
87248: IFFALSE 87288
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
87250: LD_VAR 0 2
87254: PPUSH
87255: CALL_OW 257
87259: PUSH
87260: LD_INT 5
87262: PUSH
87263: LD_INT 8
87265: PUSH
87266: LD_INT 9
87268: PUSH
87269: EMPTY
87270: LIST
87271: LIST
87272: LIST
87273: IN
87274: IFFALSE 87288
// SetClass ( unit , 1 ) ;
87276: LD_VAR 0 2
87280: PPUSH
87281: LD_INT 1
87283: PPUSH
87284: CALL_OW 336
// end ;
87288: LD_VAR 0 3
87292: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
87293: LD_INT 0
87295: PPUSH
87296: PPUSH
// if not mc_bases or not skirmish then
87297: LD_EXP 58
87301: NOT
87302: PUSH
87303: LD_EXP 56
87307: NOT
87308: OR
87309: IFFALSE 87313
// exit ;
87311: GO 87429
// if GetLives ( abandoned_vehicle ) > 250 then
87313: LD_VAR 0 2
87317: PPUSH
87318: CALL_OW 256
87322: PUSH
87323: LD_INT 250
87325: GREATER
87326: IFFALSE 87330
// exit ;
87328: GO 87429
// for i = 1 to mc_bases do
87330: LD_ADDR_VAR 0 6
87334: PUSH
87335: DOUBLE
87336: LD_INT 1
87338: DEC
87339: ST_TO_ADDR
87340: LD_EXP 58
87344: PUSH
87345: FOR_TO
87346: IFFALSE 87427
// begin if driver in mc_bases [ i ] then
87348: LD_VAR 0 1
87352: PUSH
87353: LD_EXP 58
87357: PUSH
87358: LD_VAR 0 6
87362: ARRAY
87363: IN
87364: IFFALSE 87425
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
87366: LD_VAR 0 1
87370: PPUSH
87371: LD_EXP 58
87375: PUSH
87376: LD_VAR 0 6
87380: ARRAY
87381: PPUSH
87382: LD_INT 2
87384: PUSH
87385: LD_INT 30
87387: PUSH
87388: LD_INT 0
87390: PUSH
87391: EMPTY
87392: LIST
87393: LIST
87394: PUSH
87395: LD_INT 30
87397: PUSH
87398: LD_INT 1
87400: PUSH
87401: EMPTY
87402: LIST
87403: LIST
87404: PUSH
87405: EMPTY
87406: LIST
87407: LIST
87408: LIST
87409: PPUSH
87410: CALL_OW 72
87414: PUSH
87415: LD_INT 1
87417: ARRAY
87418: PPUSH
87419: CALL_OW 112
// break ;
87423: GO 87427
// end ; end ;
87425: GO 87345
87427: POP
87428: POP
// end ; end_of_file
87429: LD_VAR 0 5
87433: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
87434: GO 87436
87436: DISABLE
// begin ru_radar := 98 ;
87437: LD_ADDR_EXP 101
87441: PUSH
87442: LD_INT 98
87444: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
87445: LD_ADDR_EXP 102
87449: PUSH
87450: LD_INT 89
87452: ST_TO_ADDR
// us_hack := 99 ;
87453: LD_ADDR_EXP 103
87457: PUSH
87458: LD_INT 99
87460: ST_TO_ADDR
// us_artillery := 97 ;
87461: LD_ADDR_EXP 104
87465: PUSH
87466: LD_INT 97
87468: ST_TO_ADDR
// ar_bio_bomb := 91 ;
87469: LD_ADDR_EXP 105
87473: PUSH
87474: LD_INT 91
87476: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
87477: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
87478: LD_INT 0
87480: PPUSH
87481: PPUSH
87482: PPUSH
87483: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
87484: LD_VAR 0 1
87488: PPUSH
87489: CALL_OW 264
87493: PUSH
87494: LD_EXP 105
87498: EQUAL
87499: IFFALSE 87571
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
87501: LD_INT 68
87503: PPUSH
87504: LD_VAR 0 1
87508: PPUSH
87509: CALL_OW 255
87513: PPUSH
87514: CALL_OW 321
87518: PUSH
87519: LD_INT 2
87521: EQUAL
87522: IFFALSE 87534
// eff := 70 else
87524: LD_ADDR_VAR 0 6
87528: PUSH
87529: LD_INT 70
87531: ST_TO_ADDR
87532: GO 87542
// eff := 30 ;
87534: LD_ADDR_VAR 0 6
87538: PUSH
87539: LD_INT 30
87541: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
87542: LD_VAR 0 1
87546: PPUSH
87547: CALL_OW 250
87551: PPUSH
87552: LD_VAR 0 1
87556: PPUSH
87557: CALL_OW 251
87561: PPUSH
87562: LD_VAR 0 6
87566: PPUSH
87567: CALL_OW 495
// end ; end ;
87571: LD_VAR 0 4
87575: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
87576: LD_INT 0
87578: PPUSH
87579: PPUSH
87580: PPUSH
87581: PPUSH
87582: PPUSH
87583: PPUSH
// if cmd = 124 then
87584: LD_VAR 0 1
87588: PUSH
87589: LD_INT 124
87591: EQUAL
87592: IFFALSE 87798
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
87594: LD_ADDR_VAR 0 5
87598: PUSH
87599: LD_INT 2
87601: PUSH
87602: LD_INT 34
87604: PUSH
87605: LD_INT 53
87607: PUSH
87608: EMPTY
87609: LIST
87610: LIST
87611: PUSH
87612: LD_INT 34
87614: PUSH
87615: LD_INT 14
87617: PUSH
87618: EMPTY
87619: LIST
87620: LIST
87621: PUSH
87622: EMPTY
87623: LIST
87624: LIST
87625: LIST
87626: PPUSH
87627: CALL_OW 69
87631: ST_TO_ADDR
// if not tmp then
87632: LD_VAR 0 5
87636: NOT
87637: IFFALSE 87641
// exit ;
87639: GO 87798
// for i in tmp do
87641: LD_ADDR_VAR 0 3
87645: PUSH
87646: LD_VAR 0 5
87650: PUSH
87651: FOR_IN
87652: IFFALSE 87796
// begin taskList := GetTaskList ( i ) ;
87654: LD_ADDR_VAR 0 6
87658: PUSH
87659: LD_VAR 0 3
87663: PPUSH
87664: CALL_OW 437
87668: ST_TO_ADDR
// if not taskList then
87669: LD_VAR 0 6
87673: NOT
87674: IFFALSE 87678
// continue ;
87676: GO 87651
// for j = 1 to taskList do
87678: LD_ADDR_VAR 0 4
87682: PUSH
87683: DOUBLE
87684: LD_INT 1
87686: DEC
87687: ST_TO_ADDR
87688: LD_VAR 0 6
87692: PUSH
87693: FOR_TO
87694: IFFALSE 87792
// if taskList [ j ] [ 1 ] = | then
87696: LD_VAR 0 6
87700: PUSH
87701: LD_VAR 0 4
87705: ARRAY
87706: PUSH
87707: LD_INT 1
87709: ARRAY
87710: PUSH
87711: LD_STRING |
87713: EQUAL
87714: IFFALSE 87790
// begin _taskList := Delete ( taskList , 1 ) ;
87716: LD_ADDR_VAR 0 7
87720: PUSH
87721: LD_VAR 0 6
87725: PPUSH
87726: LD_INT 1
87728: PPUSH
87729: CALL_OW 3
87733: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
87734: LD_VAR 0 3
87738: PPUSH
87739: LD_VAR 0 7
87743: PPUSH
87744: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
87748: LD_VAR 0 3
87752: PPUSH
87753: LD_VAR 0 6
87757: PUSH
87758: LD_VAR 0 4
87762: ARRAY
87763: PUSH
87764: LD_INT 2
87766: ARRAY
87767: PPUSH
87768: LD_VAR 0 6
87772: PUSH
87773: LD_VAR 0 4
87777: ARRAY
87778: PUSH
87779: LD_INT 3
87781: ARRAY
87782: PPUSH
87783: LD_INT 8
87785: PPUSH
87786: CALL 87803 0 4
// end ;
87790: GO 87693
87792: POP
87793: POP
// end ;
87794: GO 87651
87796: POP
87797: POP
// end ; end ;
87798: LD_VAR 0 2
87802: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
87803: LD_INT 0
87805: PPUSH
87806: PPUSH
87807: PPUSH
87808: PPUSH
87809: PPUSH
87810: PPUSH
87811: PPUSH
87812: PPUSH
87813: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
87814: LD_VAR 0 1
87818: NOT
87819: PUSH
87820: LD_VAR 0 2
87824: PPUSH
87825: LD_VAR 0 3
87829: PPUSH
87830: CALL_OW 488
87834: NOT
87835: OR
87836: PUSH
87837: LD_VAR 0 4
87841: NOT
87842: OR
87843: IFFALSE 87847
// exit ;
87845: GO 88187
// list := [ ] ;
87847: LD_ADDR_VAR 0 13
87851: PUSH
87852: EMPTY
87853: ST_TO_ADDR
// if x - r < 0 then
87854: LD_VAR 0 2
87858: PUSH
87859: LD_VAR 0 4
87863: MINUS
87864: PUSH
87865: LD_INT 0
87867: LESS
87868: IFFALSE 87880
// min_x := 0 else
87870: LD_ADDR_VAR 0 7
87874: PUSH
87875: LD_INT 0
87877: ST_TO_ADDR
87878: GO 87896
// min_x := x - r ;
87880: LD_ADDR_VAR 0 7
87884: PUSH
87885: LD_VAR 0 2
87889: PUSH
87890: LD_VAR 0 4
87894: MINUS
87895: ST_TO_ADDR
// if y - r < 0 then
87896: LD_VAR 0 3
87900: PUSH
87901: LD_VAR 0 4
87905: MINUS
87906: PUSH
87907: LD_INT 0
87909: LESS
87910: IFFALSE 87922
// min_y := 0 else
87912: LD_ADDR_VAR 0 8
87916: PUSH
87917: LD_INT 0
87919: ST_TO_ADDR
87920: GO 87938
// min_y := y - r ;
87922: LD_ADDR_VAR 0 8
87926: PUSH
87927: LD_VAR 0 3
87931: PUSH
87932: LD_VAR 0 4
87936: MINUS
87937: ST_TO_ADDR
// max_x := x + r ;
87938: LD_ADDR_VAR 0 9
87942: PUSH
87943: LD_VAR 0 2
87947: PUSH
87948: LD_VAR 0 4
87952: PLUS
87953: ST_TO_ADDR
// max_y := y + r ;
87954: LD_ADDR_VAR 0 10
87958: PUSH
87959: LD_VAR 0 3
87963: PUSH
87964: LD_VAR 0 4
87968: PLUS
87969: ST_TO_ADDR
// for _x = min_x to max_x do
87970: LD_ADDR_VAR 0 11
87974: PUSH
87975: DOUBLE
87976: LD_VAR 0 7
87980: DEC
87981: ST_TO_ADDR
87982: LD_VAR 0 9
87986: PUSH
87987: FOR_TO
87988: IFFALSE 88105
// for _y = min_y to max_y do
87990: LD_ADDR_VAR 0 12
87994: PUSH
87995: DOUBLE
87996: LD_VAR 0 8
88000: DEC
88001: ST_TO_ADDR
88002: LD_VAR 0 10
88006: PUSH
88007: FOR_TO
88008: IFFALSE 88101
// begin if not ValidHex ( _x , _y ) then
88010: LD_VAR 0 11
88014: PPUSH
88015: LD_VAR 0 12
88019: PPUSH
88020: CALL_OW 488
88024: NOT
88025: IFFALSE 88029
// continue ;
88027: GO 88007
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
88029: LD_VAR 0 11
88033: PPUSH
88034: LD_VAR 0 12
88038: PPUSH
88039: CALL_OW 351
88043: PUSH
88044: LD_VAR 0 11
88048: PPUSH
88049: LD_VAR 0 12
88053: PPUSH
88054: CALL_OW 554
88058: AND
88059: IFFALSE 88099
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
88061: LD_ADDR_VAR 0 13
88065: PUSH
88066: LD_VAR 0 13
88070: PPUSH
88071: LD_VAR 0 13
88075: PUSH
88076: LD_INT 1
88078: PLUS
88079: PPUSH
88080: LD_VAR 0 11
88084: PUSH
88085: LD_VAR 0 12
88089: PUSH
88090: EMPTY
88091: LIST
88092: LIST
88093: PPUSH
88094: CALL_OW 2
88098: ST_TO_ADDR
// end ;
88099: GO 88007
88101: POP
88102: POP
88103: GO 87987
88105: POP
88106: POP
// if not list then
88107: LD_VAR 0 13
88111: NOT
88112: IFFALSE 88116
// exit ;
88114: GO 88187
// for i in list do
88116: LD_ADDR_VAR 0 6
88120: PUSH
88121: LD_VAR 0 13
88125: PUSH
88126: FOR_IN
88127: IFFALSE 88185
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
88129: LD_VAR 0 1
88133: PPUSH
88134: LD_STRING M
88136: PUSH
88137: LD_VAR 0 6
88141: PUSH
88142: LD_INT 1
88144: ARRAY
88145: PUSH
88146: LD_VAR 0 6
88150: PUSH
88151: LD_INT 2
88153: ARRAY
88154: PUSH
88155: LD_INT 0
88157: PUSH
88158: LD_INT 0
88160: PUSH
88161: LD_INT 0
88163: PUSH
88164: LD_INT 0
88166: PUSH
88167: EMPTY
88168: LIST
88169: LIST
88170: LIST
88171: LIST
88172: LIST
88173: LIST
88174: LIST
88175: PUSH
88176: EMPTY
88177: LIST
88178: PPUSH
88179: CALL_OW 447
88183: GO 88126
88185: POP
88186: POP
// end ;
88187: LD_VAR 0 5
88191: RET
