// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 701 0 0
// InitMacro ;
  19: CALL 59061 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 50803 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 50803 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 50803 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 50803 0 9
// if Difficulty < 4 then
 168: LD_OWVAR 67
 172: PUSH
 173: LD_INT 4
 175: LESS
 176: IFFALSE 185
// RemoveEnvironmentArea ( oilBlockArea ) ;
 178: LD_INT 24
 180: PPUSH
 181: CALL_OW 355
// PrepareArabian ;
 185: CALL 4551 0 0
// PrepareRussian ;
 189: CALL 2989 0 0
// PrepareAlliance ;
 193: CALL 911 0 0
// MC_Start ( ) ;
 197: CALL 61241 0 0
// if debug then
 201: LD_EXP 1
 205: IFFALSE 214
// FogOff ( 1 ) ;
 207: LD_INT 1
 209: PPUSH
 210: CALL_OW 344
// Action ;
 214: CALL 8507 0 0
// end ;
 218: END
// export function CustomInitMacro ; var i ; begin
 219: LD_INT 0
 221: PPUSH
 222: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 223: LD_ADDR_EXP 85
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 2
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 238: LD_ADDR_EXP 86
 242: PUSH
 243: LD_INT 3
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 12
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 18
 264: PUSH
 265: LD_INT 20
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: PUSH
 274: LD_OWVAR 67
 278: ARRAY
 279: PPUSH
 280: LD_INT 7
 282: PPUSH
 283: CALL 82958 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 287: LD_INT 1
 289: PPUSH
 290: LD_EXP 56
 294: PPUSH
 295: CALL 83403 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 6
 304: PPUSH
 305: CALL 83861 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 9
 314: PUSH
 315: EMPTY
 316: LIST
 317: PPUSH
 318: CALL 84130 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 322: LD_INT 1
 324: PPUSH
 325: LD_INT 13
 327: PUSH
 328: LD_INT 1
 330: PUSH
 331: LD_INT 2
 333: PUSH
 334: LD_INT 32
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: PUSH
 343: LD_INT 13
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 2
 351: PUSH
 352: LD_INT 88
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: PPUSH
 365: CALL 83343 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 369: LD_INT 2
 371: PPUSH
 372: LD_INT 12
 374: PUSH
 375: LD_INT 14
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL 84037 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 394: LD_INT 2
 396: PPUSH
 397: LD_EXP 53
 401: PPUSH
 402: CALL 83403 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 406: LD_INT 2
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: CALL 83861 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 416: LD_INT 2
 418: PPUSH
 419: LD_INT 10
 421: PUSH
 422: EMPTY
 423: LIST
 424: PPUSH
 425: CALL 84130 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 429: LD_INT 2
 431: PPUSH
 432: LD_INT 6
 434: PUSH
 435: LD_INT 71
 437: PUSH
 438: LD_INT 116
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: LD_INT 85
 455: PUSH
 456: LD_INT 116
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 32
 470: PUSH
 471: LD_INT 83
 473: PUSH
 474: LD_INT 111
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 87
 491: PUSH
 492: LD_INT 121
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 88
 509: PUSH
 510: LD_INT 128
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 32
 524: PUSH
 525: LD_INT 59
 527: PUSH
 528: LD_INT 89
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 69
 545: PUSH
 546: LD_INT 98
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 77
 563: PUSH
 564: LD_INT 103
 566: PUSH
 567: LD_INT 3
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 33
 578: PUSH
 579: LD_INT 83
 581: PUSH
 582: LD_INT 105
 584: PUSH
 585: LD_INT 3
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 33
 596: PUSH
 597: LD_INT 71
 599: PUSH
 600: LD_INT 125
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 83187 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 628: LD_INT 2
 630: PPUSH
 631: LD_INT 43
 633: PUSH
 634: LD_INT 47
 636: PUSH
 637: LD_INT 46
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL 84448 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 649: LD_INT 2
 651: PPUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 51
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 22
 672: PUSH
 673: LD_INT 1
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 52
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL 83343 0 2
// end ;
 696: LD_VAR 0 1
 700: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 701: LD_INT 0
 703: PPUSH
// debug := false ;
 704: LD_ADDR_EXP 1
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// game := true ;
 712: LD_ADDR_EXP 2
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// gossudarov_arrive := false ;
 720: LD_ADDR_EXP 4
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// ru_lab_builded := false ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_INT 0
 735: ST_TO_ADDR
// player_spotted := false ;
 736: LD_ADDR_EXP 6
 740: PUSH
 741: LD_INT 0
 743: ST_TO_ADDR
// first_attack := false ;
 744: LD_ADDR_EXP 7
 748: PUSH
 749: LD_INT 0
 751: ST_TO_ADDR
// ru_attackers := [ ] ;
 752: LD_ADDR_EXP 54
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// ar_base_spotted := false ;
 759: LD_ADDR_EXP 8
 763: PUSH
 764: LD_INT 0
 766: ST_TO_ADDR
// ar_active_attack := false ;
 767: LD_ADDR_EXP 9
 771: PUSH
 772: LD_INT 0
 774: ST_TO_ADDR
// ar_attackers := [ ] ;
 775: LD_ADDR_EXP 11
 779: PUSH
 780: EMPTY
 781: ST_TO_ADDR
// first_powell_attack := false ;
 782: LD_ADDR_EXP 12
 786: PUSH
 787: LD_INT 0
 789: ST_TO_ADDR
// masha_killed := false ;
 790: LD_ADDR_EXP 10
 794: PUSH
 795: LD_INT 0
 797: ST_TO_ADDR
// abdul_escaped := true ;
 798: LD_ADDR_EXP 13
 802: PUSH
 803: LD_INT 1
 805: ST_TO_ADDR
// loss_counter := 0 ;
 806: LD_ADDR_EXP 14
 810: PUSH
 811: LD_INT 0
 813: ST_TO_ADDR
// hack_counter := 0 ;
 814: LD_ADDR_EXP 15
 818: PUSH
 819: LD_INT 0
 821: ST_TO_ADDR
// end ;
 822: LD_VAR 0 1
 826: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 827: LD_EXP 50
 831: PPUSH
 832: CALL_OW 255
 836: PUSH
 837: LD_INT 7
 839: EQUAL
 840: PUSH
 841: LD_EXP 49
 845: PPUSH
 846: CALL_OW 255
 850: PUSH
 851: LD_INT 7
 853: EQUAL
 854: AND
 855: PUSH
 856: LD_EXP 50
 860: PPUSH
 861: CALL_OW 302
 865: AND
 866: PUSH
 867: LD_EXP 49
 871: PPUSH
 872: CALL_OW 302
 876: AND
 877: IFFALSE 889
 879: GO 881
 881: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 882: LD_STRING ACH_COMRADE
 884: PPUSH
 885: CALL_OW 543
 889: END
// every 0 0$1 trigger hack_counter >= 10 do
 890: LD_EXP 15
 894: PUSH
 895: LD_INT 10
 897: GREATEREQUAL
 898: IFFALSE 910
 900: GO 902
 902: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 903: LD_STRING ACH_HACK
 905: PPUSH
 906: CALL_OW 543
 910: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 911: LD_INT 0
 913: PPUSH
 914: PPUSH
 915: PPUSH
 916: PPUSH
// uc_side := 7 ;
 917: LD_ADDR_OWVAR 20
 921: PUSH
 922: LD_INT 7
 924: ST_TO_ADDR
// uc_nation := 1 ;
 925: LD_ADDR_OWVAR 21
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 933: LD_ADDR_EXP 16
 937: PUSH
 938: LD_STRING JMM
 940: PPUSH
 941: LD_EXP 1
 945: NOT
 946: PPUSH
 947: LD_STRING 12a_
 949: PPUSH
 950: CALL 16435 0 3
 954: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 955: LD_EXP 16
 959: PPUSH
 960: LD_INT 71
 962: PPUSH
 963: LD_INT 23
 965: PPUSH
 966: LD_INT 0
 968: PPUSH
 969: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 973: LD_EXP 16
 977: PPUSH
 978: LD_INT 2
 980: PPUSH
 981: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 985: LD_ADDR_EXP 17
 989: PUSH
 990: LD_STRING Roth
 992: PPUSH
 993: LD_EXP 1
 997: NOT
 998: PPUSH
 999: LD_STRING 12a_
1001: PPUSH
1002: CALL 16435 0 3
1006: ST_TO_ADDR
// if Roth then
1007: LD_EXP 17
1011: IFFALSE 1031
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1013: LD_EXP 17
1017: PPUSH
1018: LD_INT 71
1020: PPUSH
1021: LD_INT 21
1023: PPUSH
1024: LD_INT 0
1026: PPUSH
1027: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1031: LD_ADDR_EXP 33
1035: PUSH
1036: LD_STRING Mike
1038: PPUSH
1039: LD_EXP 1
1043: NOT
1044: PPUSH
1045: LD_STRING 12a_
1047: PPUSH
1048: CALL 16435 0 3
1052: ST_TO_ADDR
// if Mike then
1053: LD_EXP 33
1057: IFFALSE 1074
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1059: LD_EXP 33
1063: PPUSH
1064: LD_INT 13
1066: PPUSH
1067: LD_INT 0
1069: PPUSH
1070: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1074: LD_ADDR_EXP 18
1078: PUSH
1079: LD_STRING Lisa
1081: PPUSH
1082: LD_EXP 1
1086: NOT
1087: PPUSH
1088: LD_STRING 12a_
1090: PPUSH
1091: CALL 16435 0 3
1095: ST_TO_ADDR
// if Lisa then
1096: LD_EXP 18
1100: IFFALSE 1117
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1102: LD_EXP 18
1106: PPUSH
1107: LD_INT 13
1109: PPUSH
1110: LD_INT 0
1112: PPUSH
1113: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1117: LD_ADDR_EXP 19
1121: PUSH
1122: LD_STRING Donaldson
1124: PPUSH
1125: LD_EXP 1
1129: NOT
1130: PPUSH
1131: LD_STRING 12a_
1133: PPUSH
1134: CALL 16435 0 3
1138: ST_TO_ADDR
// if Donaldson then
1139: LD_EXP 19
1143: IFFALSE 1160
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1145: LD_EXP 19
1149: PPUSH
1150: LD_INT 13
1152: PPUSH
1153: LD_INT 0
1155: PPUSH
1156: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1160: LD_ADDR_EXP 20
1164: PUSH
1165: LD_STRING Bobby
1167: PPUSH
1168: LD_EXP 1
1172: NOT
1173: PPUSH
1174: LD_STRING 12a_
1176: PPUSH
1177: CALL 16435 0 3
1181: ST_TO_ADDR
// if Bobby then
1182: LD_EXP 20
1186: IFFALSE 1203
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1188: LD_EXP 20
1192: PPUSH
1193: LD_INT 13
1195: PPUSH
1196: LD_INT 0
1198: PPUSH
1199: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1203: LD_ADDR_EXP 21
1207: PUSH
1208: LD_STRING Cyrus
1210: PPUSH
1211: LD_EXP 1
1215: NOT
1216: PPUSH
1217: LD_STRING 12a_
1219: PPUSH
1220: CALL 16435 0 3
1224: ST_TO_ADDR
// if Cyrus then
1225: LD_EXP 21
1229: IFFALSE 1246
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1231: LD_EXP 21
1235: PPUSH
1236: LD_INT 13
1238: PPUSH
1239: LD_INT 0
1241: PPUSH
1242: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1246: LD_ADDR_EXP 22
1250: PUSH
1251: LD_STRING Denis
1253: PPUSH
1254: LD_EXP 1
1258: NOT
1259: PPUSH
1260: LD_STRING 12a_
1262: PPUSH
1263: CALL 16435 0 3
1267: ST_TO_ADDR
// if Denis then
1268: LD_EXP 22
1272: IFFALSE 1289
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1274: LD_EXP 22
1278: PPUSH
1279: LD_INT 13
1281: PPUSH
1282: LD_INT 0
1284: PPUSH
1285: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1289: LD_ADDR_EXP 23
1293: PUSH
1294: LD_STRING Brown
1296: PPUSH
1297: LD_EXP 1
1301: NOT
1302: PPUSH
1303: LD_STRING 12a_
1305: PPUSH
1306: CALL 16435 0 3
1310: ST_TO_ADDR
// if Brown then
1311: LD_EXP 23
1315: IFFALSE 1332
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1317: LD_EXP 23
1321: PPUSH
1322: LD_INT 13
1324: PPUSH
1325: LD_INT 0
1327: PPUSH
1328: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1332: LD_ADDR_EXP 24
1336: PUSH
1337: LD_STRING Gladstone
1339: PPUSH
1340: LD_EXP 1
1344: NOT
1345: PPUSH
1346: LD_STRING 12a_
1348: PPUSH
1349: CALL 16435 0 3
1353: ST_TO_ADDR
// if Gladstone then
1354: LD_EXP 24
1358: IFFALSE 1375
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1360: LD_EXP 24
1364: PPUSH
1365: LD_INT 13
1367: PPUSH
1368: LD_INT 0
1370: PPUSH
1371: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1375: LD_ADDR_EXP 25
1379: PUSH
1380: LD_STRING Houten
1382: PPUSH
1383: LD_EXP 1
1387: NOT
1388: PPUSH
1389: LD_STRING 12a_
1391: PPUSH
1392: CALL 16435 0 3
1396: ST_TO_ADDR
// if Houten then
1397: LD_EXP 25
1401: IFFALSE 1418
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1403: LD_EXP 25
1407: PPUSH
1408: LD_INT 13
1410: PPUSH
1411: LD_INT 0
1413: PPUSH
1414: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1418: LD_ADDR_EXP 26
1422: PUSH
1423: LD_STRING Cornell
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: LD_STRING 12a_
1434: PPUSH
1435: CALL 16435 0 3
1439: ST_TO_ADDR
// if Cornel then
1440: LD_EXP 26
1444: IFFALSE 1461
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1446: LD_EXP 26
1450: PPUSH
1451: LD_INT 13
1453: PPUSH
1454: LD_INT 0
1456: PPUSH
1457: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1461: LD_ADDR_EXP 27
1465: PUSH
1466: LD_STRING Gary
1468: PPUSH
1469: LD_EXP 1
1473: NOT
1474: PPUSH
1475: LD_STRING 12a_
1477: PPUSH
1478: CALL 16435 0 3
1482: ST_TO_ADDR
// if Gary then
1483: LD_EXP 27
1487: IFFALSE 1504
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1489: LD_EXP 27
1493: PPUSH
1494: LD_INT 13
1496: PPUSH
1497: LD_INT 0
1499: PPUSH
1500: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1504: LD_ADDR_EXP 28
1508: PUSH
1509: LD_STRING Frank
1511: PPUSH
1512: LD_EXP 1
1516: NOT
1517: PPUSH
1518: LD_STRING 12a_
1520: PPUSH
1521: CALL 16435 0 3
1525: ST_TO_ADDR
// if Frank then
1526: LD_EXP 28
1530: IFFALSE 1547
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1532: LD_EXP 28
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: LD_INT 0
1542: PPUSH
1543: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1547: LD_ADDR_EXP 29
1551: PUSH
1552: LD_STRING Kikuchi
1554: PPUSH
1555: LD_EXP 1
1559: NOT
1560: PPUSH
1561: LD_STRING 12a_
1563: PPUSH
1564: CALL 16435 0 3
1568: ST_TO_ADDR
// if Kikuchi then
1569: LD_EXP 29
1573: IFFALSE 1590
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1575: LD_EXP 29
1579: PPUSH
1580: LD_INT 13
1582: PPUSH
1583: LD_INT 0
1585: PPUSH
1586: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1590: LD_ADDR_EXP 30
1594: PUSH
1595: LD_STRING Simms
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 12a_
1606: PPUSH
1607: CALL 16435 0 3
1611: ST_TO_ADDR
// if Simms then
1612: LD_EXP 30
1616: IFFALSE 1633
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1618: LD_EXP 30
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1633: LD_ADDR_EXP 31
1637: PUSH
1638: LD_STRING Joan
1640: PPUSH
1641: LD_EXP 1
1645: NOT
1646: PPUSH
1647: LD_STRING 12a_
1649: PPUSH
1650: CALL 16435 0 3
1654: ST_TO_ADDR
// if Joan then
1655: LD_EXP 31
1659: IFFALSE 1676
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1661: LD_EXP 31
1665: PPUSH
1666: LD_INT 13
1668: PPUSH
1669: LD_INT 0
1671: PPUSH
1672: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1676: LD_ADDR_EXP 32
1680: PUSH
1681: LD_STRING DeltaDoctor
1683: PPUSH
1684: LD_EXP 1
1688: NOT
1689: PPUSH
1690: LD_STRING 12a_
1692: PPUSH
1693: CALL 16435 0 3
1697: ST_TO_ADDR
// if DeltaDoctor then
1698: LD_EXP 32
1702: IFFALSE 1719
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1704: LD_EXP 32
1708: PPUSH
1709: LD_INT 13
1711: PPUSH
1712: LD_INT 0
1714: PPUSH
1715: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1719: LD_ADDR_VAR 0 4
1723: PUSH
1724: LD_STRING 12a_others
1726: PPUSH
1727: CALL_OW 31
1731: ST_TO_ADDR
// if tmp then
1732: LD_VAR 0 4
1736: IFFALSE 1770
// for i in tmp do
1738: LD_ADDR_VAR 0 3
1742: PUSH
1743: LD_VAR 0 4
1747: PUSH
1748: FOR_IN
1749: IFFALSE 1768
// PlaceUnitArea ( i , alliance_start , false ) ;
1751: LD_VAR 0 3
1755: PPUSH
1756: LD_INT 13
1758: PPUSH
1759: LD_INT 0
1761: PPUSH
1762: CALL_OW 49
1766: GO 1748
1768: POP
1769: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1770: LD_INT 3
1772: PPUSH
1773: LD_INT 3
1775: PPUSH
1776: LD_INT 3
1778: PPUSH
1779: LD_INT 12
1781: PPUSH
1782: LD_INT 100
1784: PPUSH
1785: CALL 21275 0 5
// veh := CreateVehicle ;
1789: LD_ADDR_VAR 0 2
1793: PUSH
1794: CALL_OW 45
1798: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1799: LD_VAR 0 2
1803: PPUSH
1804: LD_INT 2
1806: PPUSH
1807: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1811: LD_VAR 0 2
1815: PPUSH
1816: LD_INT 60
1818: PPUSH
1819: LD_INT 6
1821: PPUSH
1822: LD_INT 0
1824: PPUSH
1825: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1829: LD_VAR 0 2
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: LD_INT 30
1839: PPUSH
1840: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1844: LD_STRING 11_artifact_captured
1846: PPUSH
1847: LD_INT 0
1849: PPUSH
1850: CALL_OW 30
1854: IFFALSE 1930
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1856: LD_INT 3
1858: PPUSH
1859: LD_INT 3
1861: PPUSH
1862: LD_INT 3
1864: PPUSH
1865: LD_INT 12
1867: PPUSH
1868: LD_INT 100
1870: PPUSH
1871: CALL 21275 0 5
// veh := CreateVehicle ;
1875: LD_ADDR_VAR 0 2
1879: PUSH
1880: CALL_OW 45
1884: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1885: LD_VAR 0 2
1889: PPUSH
1890: LD_INT 3
1892: PPUSH
1893: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1897: LD_VAR 0 2
1901: PPUSH
1902: LD_INT 75
1904: PPUSH
1905: LD_INT 6
1907: PPUSH
1908: LD_INT 0
1910: PPUSH
1911: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1915: LD_VAR 0 2
1919: PPUSH
1920: LD_INT 4
1922: PPUSH
1923: LD_INT 50
1925: PPUSH
1926: CALL_OW 290
// end ; end ;
1930: LD_VAR 0 1
1934: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1935: LD_INT 0
1937: PPUSH
1938: PPUSH
1939: PPUSH
1940: PPUSH
// uc_side := 6 ;
1941: LD_ADDR_OWVAR 20
1945: PUSH
1946: LD_INT 6
1948: ST_TO_ADDR
// uc_nation := 3 ;
1949: LD_ADDR_OWVAR 21
1953: PUSH
1954: LD_INT 3
1956: ST_TO_ADDR
// InitHc ;
1957: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1961: LD_ADDR_EXP 34
1965: PUSH
1966: LD_STRING Gossudarov
1968: PPUSH
1969: CALL_OW 25
1973: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1974: LD_ADDR_EXP 35
1978: PUSH
1979: LD_STRING Kirilenkova
1981: PPUSH
1982: CALL_OW 25
1986: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1987: LD_ADDR_EXP 36
1991: PUSH
1992: LD_STRING Titov
1994: PPUSH
1995: CALL_OW 25
1999: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
2000: LD_ADDR_EXP 41
2004: PUSH
2005: LD_STRING Oblukov
2007: PPUSH
2008: CALL_OW 25
2012: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
2013: LD_ADDR_EXP 38
2017: PUSH
2018: LD_STRING Dolgov
2020: PPUSH
2021: CALL_OW 25
2025: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2026: LD_ADDR_EXP 39
2030: PUSH
2031: LD_STRING Petrosyan
2033: PPUSH
2034: CALL_OW 25
2038: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2039: LD_ADDR_EXP 40
2043: PUSH
2044: LD_STRING Scholtze
2046: PPUSH
2047: CALL_OW 25
2051: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2052: LD_ADDR_EXP 42
2056: PUSH
2057: LD_STRING Kapitsova
2059: PPUSH
2060: CALL_OW 25
2064: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2065: LD_ADDR_VAR 0 2
2069: PUSH
2070: LD_EXP 34
2074: PUSH
2075: LD_EXP 35
2079: PUSH
2080: LD_EXP 36
2084: PUSH
2085: LD_EXP 41
2089: PUSH
2090: LD_EXP 38
2094: PUSH
2095: LD_EXP 39
2099: PUSH
2100: LD_EXP 40
2104: PUSH
2105: LD_EXP 42
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: LIST
2116: LIST
2117: LIST
2118: LIST
2119: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2120: LD_INT 1
2122: PPUSH
2123: LD_INT 4
2125: PPUSH
2126: LD_INT 8
2128: PPUSH
2129: CALL_OW 380
// un := CreateHuman ;
2133: LD_ADDR_VAR 0 4
2137: PUSH
2138: CALL_OW 44
2142: ST_TO_ADDR
// tmp := tmp ^ un ;
2143: LD_ADDR_VAR 0 2
2147: PUSH
2148: LD_VAR 0 2
2152: PUSH
2153: LD_VAR 0 4
2157: ADD
2158: ST_TO_ADDR
// for i in tmp do
2159: LD_ADDR_VAR 0 3
2163: PUSH
2164: LD_VAR 0 2
2168: PUSH
2169: FOR_IN
2170: IFFALSE 2189
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2172: LD_VAR 0 3
2176: PPUSH
2177: LD_INT 14
2179: PPUSH
2180: LD_INT 0
2182: PPUSH
2183: CALL_OW 49
2187: GO 2169
2189: POP
2190: POP
// if freedom then
2191: LD_EXP 3
2195: IFFALSE 2228
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2197: LD_VAR 0 2
2201: PPUSH
2202: LD_EXP 3
2206: PPUSH
2207: CALL_OW 250
2211: PPUSH
2212: LD_EXP 3
2216: PPUSH
2217: CALL_OW 251
2221: PPUSH
2222: CALL_OW 111
2226: GO 2243
// ComMoveXY ( tmp , 70 , 48 ) ;
2228: LD_VAR 0 2
2232: PPUSH
2233: LD_INT 70
2235: PPUSH
2236: LD_INT 48
2238: PPUSH
2239: CALL_OW 111
// end ;
2243: LD_VAR 0 1
2247: RET
// export function PrepareBelkov ; begin
2248: LD_INT 0
2250: PPUSH
// uc_side := 4 ;
2251: LD_ADDR_OWVAR 20
2255: PUSH
2256: LD_INT 4
2258: ST_TO_ADDR
// uc_nation := 3 ;
2259: LD_ADDR_OWVAR 21
2263: PUSH
2264: LD_INT 3
2266: ST_TO_ADDR
// InitHc ;
2267: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2271: LD_ADDR_EXP 49
2275: PUSH
2276: LD_STRING Belkov
2278: PPUSH
2279: CALL_OW 25
2283: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2284: LD_EXP 49
2288: PPUSH
2289: LD_INT 14
2291: PPUSH
2292: LD_INT 0
2294: PPUSH
2295: CALL_OW 49
// end ;
2299: LD_VAR 0 1
2303: RET
// export function PrepareGnyevko ; begin
2304: LD_INT 0
2306: PPUSH
// uc_side := 4 ;
2307: LD_ADDR_OWVAR 20
2311: PUSH
2312: LD_INT 4
2314: ST_TO_ADDR
// uc_nation := 3 ;
2315: LD_ADDR_OWVAR 21
2319: PUSH
2320: LD_INT 3
2322: ST_TO_ADDR
// InitHc ;
2323: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2327: LD_ADDR_EXP 50
2331: PUSH
2332: LD_STRING Gnyevko
2334: PPUSH
2335: CALL_OW 25
2339: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2340: LD_EXP 50
2344: PPUSH
2345: LD_INT 14
2347: PPUSH
2348: LD_INT 0
2350: PPUSH
2351: CALL_OW 49
// end ;
2355: LD_VAR 0 1
2359: RET
// export function PrepareBurlak ; var i , tmp ; begin
2360: LD_INT 0
2362: PPUSH
2363: PPUSH
2364: PPUSH
// uc_side := 4 ;
2365: LD_ADDR_OWVAR 20
2369: PUSH
2370: LD_INT 4
2372: ST_TO_ADDR
// uc_nation := 3 ;
2373: LD_ADDR_OWVAR 21
2377: PUSH
2378: LD_INT 3
2380: ST_TO_ADDR
// InitHc ;
2381: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2385: LD_ADDR_EXP 48
2389: PUSH
2390: LD_STRING Burlak
2392: PPUSH
2393: CALL_OW 25
2397: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2398: LD_INT 24
2400: PUSH
2401: LD_INT 23
2403: PUSH
2404: LD_INT 22
2406: PUSH
2407: LD_INT 22
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: LIST
2414: LIST
2415: PUSH
2416: LD_OWVAR 67
2420: ARRAY
2421: PPUSH
2422: LD_INT 1
2424: PPUSH
2425: LD_INT 1
2427: PPUSH
2428: LD_INT 45
2430: PUSH
2431: LD_INT 44
2433: PUSH
2434: LD_INT 43
2436: PUSH
2437: LD_INT 42
2439: PUSH
2440: EMPTY
2441: LIST
2442: LIST
2443: LIST
2444: LIST
2445: PUSH
2446: LD_OWVAR 67
2450: ARRAY
2451: PPUSH
2452: LD_INT 0
2454: PPUSH
2455: CALL 21275 0 5
// Masha := CreateVehicle ;
2459: LD_ADDR_EXP 51
2463: PUSH
2464: CALL_OW 45
2468: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2469: LD_EXP 51
2473: PUSH
2474: LD_EXP 48
2478: PUSH
2479: EMPTY
2480: LIST
2481: LIST
2482: PPUSH
2483: LD_INT 499
2485: PPUSH
2486: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2490: LD_EXP 51
2494: PPUSH
2495: LD_INT 3
2497: PPUSH
2498: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2502: LD_EXP 51
2506: PPUSH
2507: LD_INT 1
2509: PPUSH
2510: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2514: LD_INT 1
2516: PPUSH
2517: LD_INT 18
2519: PPUSH
2520: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2524: LD_INT 35
2526: PPUSH
2527: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2531: LD_ADDR_VAR 0 3
2535: PUSH
2536: LD_INT 18
2538: PPUSH
2539: EMPTY
2540: PPUSH
2541: CALL_OW 70
2545: ST_TO_ADDR
// if tmp then
2546: LD_VAR 0 3
2550: IFFALSE 2584
// for i in tmp do
2552: LD_ADDR_VAR 0 2
2556: PUSH
2557: LD_VAR 0 3
2561: PUSH
2562: FOR_IN
2563: IFFALSE 2582
// ComMoveXY ( i , 114 , 9 ) ;
2565: LD_VAR 0 2
2569: PPUSH
2570: LD_INT 114
2572: PPUSH
2573: LD_INT 9
2575: PPUSH
2576: CALL_OW 111
2580: GO 2562
2582: POP
2583: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2584: LD_INT 18
2586: PPUSH
2587: EMPTY
2588: PPUSH
2589: CALL_OW 70
2593: NOT
2594: PUSH
2595: LD_INT 123
2597: PPUSH
2598: LD_INT 3
2600: PPUSH
2601: CALL_OW 428
2605: PUSH
2606: LD_INT 0
2608: EQUAL
2609: AND
2610: IFFALSE 2524
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2612: LD_EXP 51
2616: PPUSH
2617: LD_INT 123
2619: PPUSH
2620: LD_INT 3
2622: PPUSH
2623: LD_INT 0
2625: PPUSH
2626: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2630: LD_EXP 48
2634: PPUSH
2635: LD_INT 125
2637: PPUSH
2638: LD_INT 1
2640: PPUSH
2641: LD_INT 0
2643: PPUSH
2644: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2648: LD_EXP 48
2652: PPUSH
2653: LD_EXP 51
2657: PPUSH
2658: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2662: LD_INT 10
2664: PPUSH
2665: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2669: LD_EXP 51
2673: PPUSH
2674: LD_INT 110
2676: PPUSH
2677: LD_INT 10
2679: PPUSH
2680: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2684: LD_ADDR_EXP 44
2688: PUSH
2689: LD_STRING Petrovova
2691: PPUSH
2692: CALL_OW 25
2696: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2697: LD_ADDR_EXP 46
2701: PUSH
2702: LD_STRING Kuzmov
2704: PPUSH
2705: CALL_OW 25
2709: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2710: LD_ADDR_EXP 45
2714: PUSH
2715: LD_STRING Kovalyuk
2717: PPUSH
2718: CALL_OW 25
2722: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2723: LD_ADDR_EXP 43
2727: PUSH
2728: LD_STRING Lipshchin
2730: PPUSH
2731: CALL_OW 25
2735: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2736: LD_ADDR_EXP 47
2740: PUSH
2741: LD_STRING Karamazov
2743: PPUSH
2744: CALL_OW 25
2748: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2749: LD_ADDR_VAR 0 3
2753: PUSH
2754: LD_EXP 44
2758: PUSH
2759: LD_EXP 46
2763: PUSH
2764: LD_EXP 45
2768: PUSH
2769: LD_EXP 43
2773: PUSH
2774: LD_EXP 47
2778: PUSH
2779: EMPTY
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: LIST
2785: ST_TO_ADDR
// for i in tmp do
2786: LD_ADDR_VAR 0 2
2790: PUSH
2791: LD_VAR 0 3
2795: PUSH
2796: FOR_IN
2797: IFFALSE 2836
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2799: LD_VAR 0 2
2803: PPUSH
2804: LD_INT 399
2806: PPUSH
2807: LD_INT 799
2809: PPUSH
2810: CALL_OW 12
2814: PPUSH
2815: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2819: LD_VAR 0 2
2823: PPUSH
2824: LD_INT 19
2826: PPUSH
2827: LD_INT 0
2829: PPUSH
2830: CALL_OW 49
// end ;
2834: GO 2796
2836: POP
2837: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2838: LD_VAR 0 3
2842: PPUSH
2843: LD_INT 112
2845: PPUSH
2846: LD_INT 5
2848: PPUSH
2849: CALL_OW 111
// AddComHold ( tmp ) ;
2853: LD_VAR 0 3
2857: PPUSH
2858: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2862: LD_ADDR_VAR 0 2
2866: PUSH
2867: LD_VAR 0 3
2871: PPUSH
2872: LD_INT 25
2874: PUSH
2875: LD_INT 1
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: PPUSH
2882: CALL_OW 72
2886: PUSH
2887: FOR_IN
2888: IFFALSE 2928
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2890: LD_VAR 0 2
2894: PPUSH
2895: LD_INT 20
2897: PPUSH
2898: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2902: LD_VAR 0 2
2906: PPUSH
2907: LD_INT 147
2909: PPUSH
2910: LD_INT 45
2912: PPUSH
2913: CALL_OW 178
// AddComCrawl ( i ) ;
2917: LD_VAR 0 2
2921: PPUSH
2922: CALL_OW 197
// end ;
2926: GO 2887
2928: POP
2929: POP
// repeat wait ( 0 0$1 ) ;
2930: LD_INT 35
2932: PPUSH
2933: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2937: LD_EXP 51
2941: PPUSH
2942: LD_INT 110
2944: PPUSH
2945: LD_INT 10
2947: PPUSH
2948: CALL_OW 307
2952: PUSH
2953: LD_EXP 51
2957: PPUSH
2958: CALL_OW 305
2962: NOT
2963: OR
2964: IFFALSE 2930
// ComStop ( Burlak ) ;
2966: LD_EXP 48
2970: PPUSH
2971: CALL_OW 141
// AddComHold ( Burlak ) ;
2975: LD_EXP 48
2979: PPUSH
2980: CALL_OW 200
// end ; end_of_file
2984: LD_VAR 0 1
2988: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2989: LD_INT 0
2991: PPUSH
2992: PPUSH
2993: PPUSH
2994: PPUSH
2995: PPUSH
// uc_side := 3 ;
2996: LD_ADDR_OWVAR 20
3000: PUSH
3001: LD_INT 3
3003: ST_TO_ADDR
// uc_nation := 3 ;
3004: LD_ADDR_OWVAR 21
3008: PUSH
3009: LD_INT 3
3011: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
3012: LD_ADDR_EXP 52
3016: PUSH
3017: LD_INT 47
3019: PPUSH
3020: LD_INT 4
3022: PPUSH
3023: LD_STRING 
3025: PPUSH
3026: LD_INT 7
3028: PUSH
3029: LD_INT 8
3031: PUSH
3032: LD_INT 9
3034: PUSH
3035: LD_INT 10
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: PUSH
3044: LD_OWVAR 67
3048: ARRAY
3049: PPUSH
3050: LD_INT 10000
3052: PUSH
3053: LD_INT 3000
3055: PUSH
3056: LD_INT 300
3058: PUSH
3059: EMPTY
3060: LIST
3061: LIST
3062: LIST
3063: PPUSH
3064: LD_INT 9
3066: PUSH
3067: LD_INT 5
3069: PUSH
3070: LD_INT 6
3072: PUSH
3073: LD_INT 6
3075: PUSH
3076: EMPTY
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PPUSH
3082: CALL 25096 0 6
3086: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3087: LD_ADDR_EXP 61
3091: PUSH
3092: LD_EXP 61
3096: PPUSH
3097: LD_INT 2
3099: PPUSH
3100: LD_EXP 52
3104: PPUSH
3105: CALL_OW 1
3109: ST_TO_ADDR
// tmp := [ ] ;
3110: LD_ADDR_VAR 0 4
3114: PUSH
3115: EMPTY
3116: ST_TO_ADDR
// for i = 1 to 4 do
3117: LD_ADDR_VAR 0 2
3121: PUSH
3122: DOUBLE
3123: LD_INT 1
3125: DEC
3126: ST_TO_ADDR
3127: LD_INT 4
3129: PUSH
3130: FOR_TO
3131: IFFALSE 3224
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3133: LD_INT 22
3135: PPUSH
3136: LD_INT 3
3138: PPUSH
3139: LD_INT 3
3141: PPUSH
3142: LD_INT 43
3144: PUSH
3145: LD_INT 45
3147: PUSH
3148: LD_INT 45
3150: PUSH
3151: LD_INT 44
3153: PUSH
3154: EMPTY
3155: LIST
3156: LIST
3157: LIST
3158: LIST
3159: PUSH
3160: LD_VAR 0 2
3164: PUSH
3165: LD_INT 4
3167: MOD
3168: PUSH
3169: LD_INT 1
3171: PLUS
3172: ARRAY
3173: PPUSH
3174: LD_INT 100
3176: PPUSH
3177: CALL 21275 0 5
// veh := CreateVehicle ;
3181: LD_ADDR_VAR 0 3
3185: PUSH
3186: CALL_OW 45
3190: ST_TO_ADDR
// tmp := tmp ^ veh ;
3191: LD_ADDR_VAR 0 4
3195: PUSH
3196: LD_VAR 0 4
3200: PUSH
3201: LD_VAR 0 3
3205: ADD
3206: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3207: LD_VAR 0 3
3211: PPUSH
3212: LD_INT 2
3214: PPUSH
3215: LD_INT 0
3217: PPUSH
3218: CALL_OW 49
// end ;
3222: GO 3130
3224: POP
3225: POP
// russian_guard := tmp ;
3226: LD_ADDR_EXP 53
3230: PUSH
3231: LD_VAR 0 4
3235: ST_TO_ADDR
// if Difficulty >= 3 then
3236: LD_OWVAR 67
3240: PUSH
3241: LD_INT 3
3243: GREATEREQUAL
3244: IFFALSE 3308
// begin bc_type := b_breastwork ;
3246: LD_ADDR_OWVAR 42
3250: PUSH
3251: LD_INT 31
3253: ST_TO_ADDR
// bc_level := 10 ;
3254: LD_ADDR_OWVAR 43
3258: PUSH
3259: LD_INT 10
3261: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3262: LD_ADDR_VAR 0 5
3266: PUSH
3267: LD_INT 96
3269: PPUSH
3270: LD_INT 105
3272: PPUSH
3273: LD_INT 3
3275: PPUSH
3276: CALL_OW 47
3280: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3281: LD_INT 0
3283: PPUSH
3284: LD_INT 9
3286: PPUSH
3287: LD_INT 10
3289: PPUSH
3290: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3294: CALL_OW 44
3298: PPUSH
3299: LD_VAR 0 5
3303: PPUSH
3304: CALL_OW 52
// end ; end ;
3308: LD_VAR 0 1
3312: RET
// every 5 5$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , p , base , tmp , _target , attackers , amount ;
3313: LD_INT 47
3315: PPUSH
3316: CALL_OW 302
3320: PUSH
3321: LD_EXP 6
3325: AND
3326: IFFALSE 4073
3328: GO 3330
3330: DISABLE
3331: LD_INT 0
3333: PPUSH
3334: PPUSH
3335: PPUSH
3336: PPUSH
3337: PPUSH
3338: PPUSH
3339: PPUSH
// begin enable ;
3340: ENABLE
// base := 2 ;
3341: LD_ADDR_VAR 0 3
3345: PUSH
3346: LD_INT 2
3348: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3349: LD_ADDR_VAR 0 4
3353: PUSH
3354: LD_INT 22
3356: PUSH
3357: LD_INT 1
3359: PUSH
3360: LD_INT 3
3362: PUSH
3363: LD_INT 45
3365: PUSH
3366: EMPTY
3367: LIST
3368: LIST
3369: LIST
3370: LIST
3371: PUSH
3372: LD_INT 21
3374: PUSH
3375: LD_INT 1
3377: PUSH
3378: LD_INT 3
3380: PUSH
3381: LD_INT 45
3383: PUSH
3384: EMPTY
3385: LIST
3386: LIST
3387: LIST
3388: LIST
3389: PUSH
3390: LD_INT 22
3392: PUSH
3393: LD_INT 1
3395: PUSH
3396: LD_INT 3
3398: PUSH
3399: LD_INT 45
3401: PUSH
3402: EMPTY
3403: LIST
3404: LIST
3405: LIST
3406: LIST
3407: PUSH
3408: LD_INT 23
3410: PUSH
3411: LD_INT 1
3413: PUSH
3414: LD_INT 3
3416: PUSH
3417: LD_INT 46
3419: PUSH
3420: EMPTY
3421: LIST
3422: LIST
3423: LIST
3424: LIST
3425: PUSH
3426: EMPTY
3427: LIST
3428: LIST
3429: LIST
3430: LIST
3431: ST_TO_ADDR
// amount := Difficulty ;
3432: LD_ADDR_VAR 0 7
3436: PUSH
3437: LD_OWVAR 67
3441: ST_TO_ADDR
// if tick > 30 30$00 then
3442: LD_OWVAR 1
3446: PUSH
3447: LD_INT 63000
3449: GREATER
3450: IFFALSE 3487
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3452: LD_ADDR_VAR 0 7
3456: PUSH
3457: LD_VAR 0 7
3461: PUSH
3462: LD_INT 2
3464: PUSH
3465: LD_INT 3
3467: PUSH
3468: LD_INT 4
3470: PUSH
3471: LD_INT 4
3473: PUSH
3474: EMPTY
3475: LIST
3476: LIST
3477: LIST
3478: LIST
3479: PUSH
3480: LD_OWVAR 67
3484: ARRAY
3485: PLUS
3486: ST_TO_ADDR
// for i = 1 to amount do
3487: LD_ADDR_VAR 0 1
3491: PUSH
3492: DOUBLE
3493: LD_INT 1
3495: DEC
3496: ST_TO_ADDR
3497: LD_VAR 0 7
3501: PUSH
3502: FOR_TO
3503: IFFALSE 3591
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3505: LD_ADDR_VAR 0 4
3509: PUSH
3510: LD_VAR 0 4
3514: PPUSH
3515: LD_VAR 0 4
3519: PUSH
3520: LD_INT 1
3522: PLUS
3523: PPUSH
3524: LD_INT 23
3526: PUSH
3527: LD_INT 24
3529: PUSH
3530: EMPTY
3531: LIST
3532: LIST
3533: PUSH
3534: LD_INT 1
3536: PPUSH
3537: LD_INT 2
3539: PPUSH
3540: CALL_OW 12
3544: ARRAY
3545: PUSH
3546: LD_INT 1
3548: PUSH
3549: LD_INT 3
3551: PUSH
3552: LD_INT 46
3554: PUSH
3555: LD_INT 47
3557: PUSH
3558: LD_INT 45
3560: PUSH
3561: EMPTY
3562: LIST
3563: LIST
3564: LIST
3565: PUSH
3566: LD_INT 1
3568: PPUSH
3569: LD_INT 3
3571: PPUSH
3572: CALL_OW 12
3576: ARRAY
3577: PUSH
3578: EMPTY
3579: LIST
3580: LIST
3581: LIST
3582: LIST
3583: PPUSH
3584: CALL_OW 2
3588: ST_TO_ADDR
3589: GO 3502
3591: POP
3592: POP
// p := 1 ;
3593: LD_ADDR_VAR 0 2
3597: PUSH
3598: LD_INT 1
3600: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
3601: LD_VAR 0 3
3605: PPUSH
3606: LD_VAR 0 4
3610: PPUSH
3611: CALL 83343 0 2
// repeat wait ( 0 0$1 ) ;
3615: LD_INT 35
3617: PPUSH
3618: CALL_OW 67
// p := Inc ( p ) ;
3622: LD_ADDR_VAR 0 2
3626: PUSH
3627: LD_VAR 0 2
3631: PPUSH
3632: CALL 55487 0 1
3636: ST_TO_ADDR
// until MC_GetVehicles ( base , true ) >= amount or p >= 60 ;
3637: LD_VAR 0 3
3641: PPUSH
3642: LD_INT 1
3644: PPUSH
3645: CALL 84761 0 2
3649: PUSH
3650: LD_VAR 0 7
3654: GREATEREQUAL
3655: PUSH
3656: LD_VAR 0 2
3660: PUSH
3661: LD_INT 60
3663: GREATEREQUAL
3664: OR
3665: IFFALSE 3615
// wait ( 0 0$30 ) ;
3667: LD_INT 1050
3669: PPUSH
3670: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3674: LD_ADDR_VAR 0 5
3678: PUSH
3679: LD_INT 71
3681: PUSH
3682: LD_INT 19
3684: PUSH
3685: EMPTY
3686: LIST
3687: LIST
3688: PUSH
3689: LD_INT 91
3691: PUSH
3692: LD_INT 67
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: PUSH
3699: LD_INT 52
3701: PUSH
3702: LD_INT 44
3704: PUSH
3705: EMPTY
3706: LIST
3707: LIST
3708: PUSH
3709: LD_INT 68
3711: PUSH
3712: LD_INT 48
3714: PUSH
3715: EMPTY
3716: LIST
3717: LIST
3718: PUSH
3719: EMPTY
3720: LIST
3721: LIST
3722: LIST
3723: LIST
3724: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] ] ] ) diff mc_defender [ base ] ;
3725: LD_ADDR_VAR 0 6
3729: PUSH
3730: LD_INT 22
3732: PUSH
3733: LD_INT 3
3735: PUSH
3736: EMPTY
3737: LIST
3738: LIST
3739: PUSH
3740: LD_INT 21
3742: PUSH
3743: LD_INT 2
3745: PUSH
3746: EMPTY
3747: LIST
3748: LIST
3749: PUSH
3750: LD_INT 3
3752: PUSH
3753: LD_INT 34
3755: PUSH
3756: LD_INT 52
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: PUSH
3763: LD_INT 34
3765: PUSH
3766: LD_INT 51
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: LIST
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: LIST
3782: PPUSH
3783: CALL_OW 69
3787: PUSH
3788: LD_EXP 83
3792: PUSH
3793: LD_VAR 0 3
3797: ARRAY
3798: DIFF
3799: ST_TO_ADDR
// if not attackers then
3800: LD_VAR 0 6
3804: NOT
3805: IFFALSE 3809
// exit ;
3807: GO 4073
// ru_attackers := attackers ;
3809: LD_ADDR_EXP 54
3813: PUSH
3814: LD_VAR 0 6
3818: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3819: LD_ADDR_EXP 80
3823: PUSH
3824: LD_EXP 80
3828: PPUSH
3829: LD_VAR 0 3
3833: PPUSH
3834: LD_EXP 80
3838: PUSH
3839: LD_VAR 0 3
3843: ARRAY
3844: PUSH
3845: LD_VAR 0 6
3849: DIFF
3850: PPUSH
3851: CALL_OW 1
3855: ST_TO_ADDR
// for i = 1 to attackers do
3856: LD_ADDR_VAR 0 1
3860: PUSH
3861: DOUBLE
3862: LD_INT 1
3864: DEC
3865: ST_TO_ADDR
3866: LD_VAR 0 6
3870: PUSH
3871: FOR_TO
3872: IFFALSE 3949
// begin case i mod 3 of 0 :
3874: LD_VAR 0 1
3878: PUSH
3879: LD_INT 3
3881: MOD
3882: PUSH
3883: LD_INT 0
3885: DOUBLE
3886: EQUAL
3887: IFTRUE 3891
3889: GO 3894
3891: POP
// ; 1 :
3892: GO 3947
3894: LD_INT 1
3896: DOUBLE
3897: EQUAL
3898: IFTRUE 3902
3900: GO 3920
3902: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3903: LD_VAR 0 1
3907: PPUSH
3908: LD_INT 32
3910: PPUSH
3911: LD_INT 49
3913: PPUSH
3914: CALL_OW 114
3918: GO 3947
3920: LD_INT 2
3922: DOUBLE
3923: EQUAL
3924: IFTRUE 3928
3926: GO 3946
3928: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3929: LD_VAR 0 1
3933: PPUSH
3934: LD_INT 117
3936: PPUSH
3937: LD_INT 107
3939: PPUSH
3940: CALL_OW 114
3944: GO 3947
3946: POP
// end ;
3947: GO 3871
3949: POP
3950: POP
// p := 0 ;
3951: LD_ADDR_VAR 0 2
3955: PUSH
3956: LD_INT 0
3958: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3959: LD_INT 35
3961: PPUSH
3962: CALL_OW 67
// p := Inc ( p ) ;
3966: LD_ADDR_VAR 0 2
3970: PUSH
3971: LD_VAR 0 2
3975: PPUSH
3976: CALL 55487 0 1
3980: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
3981: LD_VAR 0 6
3985: PPUSH
3986: LD_INT 60
3988: PUSH
3989: EMPTY
3990: LIST
3991: PPUSH
3992: CALL_OW 72
3996: NOT
3997: PUSH
3998: LD_VAR 0 2
4002: PUSH
4003: LD_INT 30
4005: GREATER
4006: OR
4007: IFFALSE 3959
// if not first_attack then
4009: LD_EXP 7
4013: NOT
4014: IFFALSE 4024
// first_attack := true ;
4016: LD_ADDR_EXP 7
4020: PUSH
4021: LD_INT 1
4023: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4024: LD_INT 35
4026: PPUSH
4027: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
4031: LD_ADDR_VAR 0 6
4035: PUSH
4036: LD_VAR 0 6
4040: PPUSH
4041: LD_INT 50
4043: PUSH
4044: EMPTY
4045: LIST
4046: PPUSH
4047: CALL_OW 72
4051: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
4052: LD_VAR 0 6
4056: PPUSH
4057: LD_VAR 0 5
4061: PPUSH
4062: CALL 56730 0 2
// until not attackers ;
4066: LD_VAR 0 6
4070: NOT
4071: IFFALSE 4024
// end ;
4073: PPOPN 7
4075: END
// export function PrepareRussianAttack ; var i , tmp , veh , chassis , weapon ; begin
4076: LD_INT 0
4078: PPUSH
4079: PPUSH
4080: PPUSH
4081: PPUSH
4082: PPUSH
4083: PPUSH
// uc_side := 6 ;
4084: LD_ADDR_OWVAR 20
4088: PUSH
4089: LD_INT 6
4091: ST_TO_ADDR
// uc_nation := 3 ;
4092: LD_ADDR_OWVAR 21
4096: PUSH
4097: LD_INT 3
4099: ST_TO_ADDR
// InitHc ;
4100: CALL_OW 19
// InitVc ;
4104: CALL_OW 20
// tmp := [ ] ;
4108: LD_ADDR_VAR 0 3
4112: PUSH
4113: EMPTY
4114: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
4115: LD_ADDR_VAR 0 2
4119: PUSH
4120: DOUBLE
4121: LD_INT 1
4123: DEC
4124: ST_TO_ADDR
4125: LD_INT 4
4127: PUSH
4128: LD_INT 5
4130: PUSH
4131: LD_INT 6
4133: PUSH
4134: LD_INT 7
4136: PUSH
4137: EMPTY
4138: LIST
4139: LIST
4140: LIST
4141: LIST
4142: PUSH
4143: LD_OWVAR 67
4147: ARRAY
4148: PUSH
4149: FOR_TO
4150: IFFALSE 4404
// begin chassis := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 3 ) ] ;
4152: LD_ADDR_VAR 0 5
4156: PUSH
4157: LD_INT 21
4159: PUSH
4160: LD_INT 22
4162: PUSH
4163: LD_INT 24
4165: PUSH
4166: EMPTY
4167: LIST
4168: LIST
4169: LIST
4170: PUSH
4171: LD_INT 1
4173: PPUSH
4174: LD_INT 3
4176: PPUSH
4177: CALL_OW 12
4181: ARRAY
4182: ST_TO_ADDR
// case chassis of ru_medium_wheeled , ru_medium_tracked :
4183: LD_VAR 0 5
4187: PUSH
4188: LD_INT 21
4190: DOUBLE
4191: EQUAL
4192: IFTRUE 4202
4194: LD_INT 22
4196: DOUBLE
4197: EQUAL
4198: IFTRUE 4202
4200: GO 4236
4202: POP
// weapon := [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ rand ( 1 , 3 ) ] ; ru_heavy_tracked :
4203: LD_ADDR_VAR 0 6
4207: PUSH
4208: LD_INT 45
4210: PUSH
4211: LD_INT 44
4213: PUSH
4214: LD_INT 43
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: LIST
4221: PUSH
4222: LD_INT 1
4224: PPUSH
4225: LD_INT 3
4227: PPUSH
4228: CALL_OW 12
4232: ARRAY
4233: ST_TO_ADDR
4234: GO 4283
4236: LD_INT 24
4238: DOUBLE
4239: EQUAL
4240: IFTRUE 4244
4242: GO 4282
4244: POP
// weapon := [ ru_heavy_gun , ru_rocket , ru_rocket_launcher , ru_heavy_gun ] [ rand ( 1 , 4 ) ] ; end ;
4245: LD_ADDR_VAR 0 6
4249: PUSH
4250: LD_INT 46
4252: PUSH
4253: LD_INT 47
4255: PUSH
4256: LD_INT 45
4258: PUSH
4259: LD_INT 46
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: LIST
4266: LIST
4267: PUSH
4268: LD_INT 1
4270: PPUSH
4271: LD_INT 4
4273: PPUSH
4274: CALL_OW 12
4278: ARRAY
4279: ST_TO_ADDR
4280: GO 4283
4282: POP
// uc_side := 6 ;
4283: LD_ADDR_OWVAR 20
4287: PUSH
4288: LD_INT 6
4290: ST_TO_ADDR
// uc_nation := 3 ;
4291: LD_ADDR_OWVAR 21
4295: PUSH
4296: LD_INT 3
4298: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
4299: LD_VAR 0 5
4303: PPUSH
4304: LD_INT 1
4306: PUSH
4307: LD_INT 3
4309: PUSH
4310: EMPTY
4311: LIST
4312: LIST
4313: PUSH
4314: LD_INT 1
4316: PPUSH
4317: LD_INT 2
4319: PPUSH
4320: CALL_OW 12
4324: ARRAY
4325: PPUSH
4326: LD_INT 3
4328: PPUSH
4329: LD_VAR 0 6
4333: PPUSH
4334: LD_INT 70
4336: PPUSH
4337: LD_INT 90
4339: PPUSH
4340: CALL_OW 12
4344: PPUSH
4345: CALL 21275 0 5
// veh := CreateVehicle ;
4349: LD_ADDR_VAR 0 4
4353: PUSH
4354: CALL_OW 45
4358: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
4359: LD_VAR 0 4
4363: PPUSH
4364: LD_INT 5
4366: PPUSH
4367: CALL_OW 233
// PlaceUnitArea ( veh , south_spawn , false ) ;
4371: LD_VAR 0 4
4375: PPUSH
4376: LD_INT 16
4378: PPUSH
4379: LD_INT 0
4381: PPUSH
4382: CALL_OW 49
// tmp := tmp ^ veh ;
4386: LD_ADDR_VAR 0 3
4390: PUSH
4391: LD_VAR 0 3
4395: PUSH
4396: LD_VAR 0 4
4400: ADD
4401: ST_TO_ADDR
// end ;
4402: GO 4149
4404: POP
4405: POP
// if not tmp then
4406: LD_VAR 0 3
4410: NOT
4411: IFFALSE 4415
// exit ;
4413: GO 4509
// repeat wait ( 0 0$2 ) ;
4415: LD_INT 70
4417: PPUSH
4418: CALL_OW 67
// for i in tmp do
4422: LD_ADDR_VAR 0 2
4426: PUSH
4427: LD_VAR 0 3
4431: PUSH
4432: FOR_IN
4433: IFFALSE 4500
// if IsOk ( i ) then
4435: LD_VAR 0 2
4439: PPUSH
4440: CALL_OW 302
4444: IFFALSE 4482
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) else
4446: LD_VAR 0 2
4450: PPUSH
4451: LD_INT 22
4453: PUSH
4454: LD_INT 7
4456: PUSH
4457: EMPTY
4458: LIST
4459: LIST
4460: PPUSH
4461: CALL_OW 69
4465: PPUSH
4466: LD_VAR 0 2
4470: PPUSH
4471: CALL_OW 74
4475: PPUSH
4476: CALL_OW 115
4480: GO 4498
// tmp := tmp diff i ;
4482: LD_ADDR_VAR 0 3
4486: PUSH
4487: LD_VAR 0 3
4491: PUSH
4492: LD_VAR 0 2
4496: DIFF
4497: ST_TO_ADDR
4498: GO 4432
4500: POP
4501: POP
// until not tmp ;
4502: LD_VAR 0 3
4506: NOT
4507: IFFALSE 4415
// end ;
4509: LD_VAR 0 1
4513: RET
// every 10 10$00 + 3 3$00 trigger first_attack and IsOk ( ru_depot ) and GetSide ( ru_depot ) = 3 do
4514: LD_EXP 7
4518: PUSH
4519: LD_INT 47
4521: PPUSH
4522: CALL_OW 302
4526: AND
4527: PUSH
4528: LD_INT 47
4530: PPUSH
4531: CALL_OW 255
4535: PUSH
4536: LD_INT 3
4538: EQUAL
4539: AND
4540: IFFALSE 4550
4542: GO 4544
4544: DISABLE
// begin enable ;
4545: ENABLE
// PrepareRussianAttack ;
4546: CALL 4076 0 0
// end ; end_of_file
4550: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
4551: LD_INT 0
4553: PPUSH
4554: PPUSH
4555: PPUSH
4556: PPUSH
4557: PPUSH
4558: PPUSH
4559: PPUSH
// uc_side := 2 ;
4560: LD_ADDR_OWVAR 20
4564: PUSH
4565: LD_INT 2
4567: ST_TO_ADDR
// uc_nation := 2 ;
4568: LD_ADDR_OWVAR 21
4572: PUSH
4573: LD_INT 2
4575: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
4576: LD_ADDR_EXP 57
4580: PUSH
4581: LD_STRING Abdul
4583: PPUSH
4584: CALL_OW 25
4588: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4589: LD_EXP 57
4593: PPUSH
4594: LD_INT 11
4596: PPUSH
4597: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4601: LD_EXP 57
4605: PPUSH
4606: LD_INT 1
4608: PPUSH
4609: CALL_OW 52
// vc_chassis := 31 ;
4613: LD_ADDR_OWVAR 37
4617: PUSH
4618: LD_INT 31
4620: ST_TO_ADDR
// vc_control := control_rider ;
4621: LD_ADDR_OWVAR 38
4625: PUSH
4626: LD_INT 4
4628: ST_TO_ADDR
// mastodont := CreateVehicle ;
4629: LD_ADDR_EXP 58
4633: PUSH
4634: CALL_OW 45
4638: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4639: LD_EXP 58
4643: PPUSH
4644: LD_INT 153
4646: PPUSH
4647: LD_INT 71
4649: PPUSH
4650: LD_INT 0
4652: PPUSH
4653: CALL_OW 48
// InitVc ;
4657: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian , kaba , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 11 , 5 , 6 , 7 ] ) ;
4661: LD_ADDR_EXP 55
4665: PUSH
4666: LD_INT 1
4668: PPUSH
4669: LD_INT 3
4671: PPUSH
4672: LD_STRING kaba
4674: PPUSH
4675: LD_INT 7
4677: PUSH
4678: LD_INT 8
4680: PUSH
4681: LD_INT 9
4683: PUSH
4684: LD_INT 10
4686: PUSH
4687: EMPTY
4688: LIST
4689: LIST
4690: LIST
4691: LIST
4692: PUSH
4693: LD_OWVAR 67
4697: ARRAY
4698: PPUSH
4699: LD_INT 5000
4701: PUSH
4702: LD_INT 1000
4704: PUSH
4705: LD_INT 300
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: LIST
4712: PPUSH
4713: LD_INT 11
4715: PUSH
4716: LD_INT 5
4718: PUSH
4719: LD_INT 6
4721: PUSH
4722: LD_INT 7
4724: PUSH
4725: EMPTY
4726: LIST
4727: LIST
4728: LIST
4729: LIST
4730: PPUSH
4731: CALL 25096 0 6
4735: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4736: LD_ADDR_EXP 61
4740: PUSH
4741: LD_EXP 61
4745: PPUSH
4746: LD_INT 1
4748: PPUSH
4749: LD_EXP 55
4753: PPUSH
4754: CALL_OW 1
4758: ST_TO_ADDR
// tmp := [ ] ;
4759: LD_ADDR_VAR 0 4
4763: PUSH
4764: EMPTY
4765: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
4766: LD_ADDR_OWVAR 37
4770: PUSH
4771: LD_INT 13
4773: ST_TO_ADDR
// vc_engine := engine_siberite ;
4774: LD_ADDR_OWVAR 39
4778: PUSH
4779: LD_INT 3
4781: ST_TO_ADDR
// vc_control := control_manual ;
4782: LD_ADDR_OWVAR 38
4786: PUSH
4787: LD_INT 1
4789: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4790: LD_ADDR_OWVAR 40
4794: PUSH
4795: LD_INT 31
4797: ST_TO_ADDR
// for i = 1 to 3 do
4798: LD_ADDR_VAR 0 2
4802: PUSH
4803: DOUBLE
4804: LD_INT 1
4806: DEC
4807: ST_TO_ADDR
4808: LD_INT 3
4810: PUSH
4811: FOR_TO
4812: IFFALSE 5060
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4814: LD_ADDR_VAR 0 5
4818: PUSH
4819: LD_INT 153
4821: PUSH
4822: LD_INT 71
4824: PUSH
4825: EMPTY
4826: LIST
4827: LIST
4828: PUSH
4829: LD_INT 155
4831: PUSH
4832: LD_INT 81
4834: PUSH
4835: EMPTY
4836: LIST
4837: LIST
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: LD_VAR 0 2
4847: PUSH
4848: LD_INT 2
4850: MOD
4851: PUSH
4852: LD_INT 1
4854: PLUS
4855: ARRAY
4856: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4857: LD_INT 0
4859: PPUSH
4860: LD_INT 3
4862: PPUSH
4863: LD_INT 7
4865: PUSH
4866: LD_INT 8
4868: PUSH
4869: LD_INT 10
4871: PUSH
4872: LD_INT 10
4874: PUSH
4875: EMPTY
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: PUSH
4881: LD_OWVAR 67
4885: ARRAY
4886: PPUSH
4887: CALL_OW 380
// un := CreateVehicle ;
4891: LD_ADDR_VAR 0 6
4895: PUSH
4896: CALL_OW 45
4900: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4901: LD_VAR 0 6
4905: PPUSH
4906: LD_INT 0
4908: PPUSH
4909: LD_INT 5
4911: PPUSH
4912: CALL_OW 12
4916: PPUSH
4917: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4921: LD_VAR 0 6
4925: PPUSH
4926: LD_VAR 0 5
4930: PUSH
4931: LD_INT 1
4933: ARRAY
4934: PPUSH
4935: LD_VAR 0 5
4939: PUSH
4940: LD_INT 2
4942: ARRAY
4943: PPUSH
4944: LD_INT 6
4946: PPUSH
4947: LD_INT 0
4949: PPUSH
4950: CALL_OW 50
// un2 := CreateHuman ;
4954: LD_ADDR_VAR 0 7
4958: PUSH
4959: CALL_OW 44
4963: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4964: LD_VAR 0 7
4968: PPUSH
4969: LD_VAR 0 6
4973: PPUSH
4974: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4978: LD_ADDR_EXP 61
4982: PUSH
4983: LD_EXP 61
4987: PPUSH
4988: LD_INT 1
4990: PUSH
4991: LD_EXP 61
4995: PUSH
4996: LD_INT 1
4998: ARRAY
4999: PUSH
5000: LD_INT 1
5002: PLUS
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PPUSH
5008: LD_VAR 0 6
5012: PPUSH
5013: CALL 21397 0 3
5017: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
5018: LD_ADDR_EXP 61
5022: PUSH
5023: LD_EXP 61
5027: PPUSH
5028: LD_INT 1
5030: PUSH
5031: LD_EXP 61
5035: PUSH
5036: LD_INT 1
5038: ARRAY
5039: PUSH
5040: LD_INT 1
5042: PLUS
5043: PUSH
5044: EMPTY
5045: LIST
5046: LIST
5047: PPUSH
5048: LD_VAR 0 7
5052: PPUSH
5053: CALL 21397 0 3
5057: ST_TO_ADDR
// end ;
5058: GO 4811
5060: POP
5061: POP
// for i = 1 to 5 do
5062: LD_ADDR_VAR 0 2
5066: PUSH
5067: DOUBLE
5068: LD_INT 1
5070: DEC
5071: ST_TO_ADDR
5072: LD_INT 5
5074: PUSH
5075: FOR_TO
5076: IFFALSE 5169
// begin PrepareVehicle ( ar_medium_trike , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
5078: LD_INT 13
5080: PPUSH
5081: LD_INT 3
5083: PPUSH
5084: LD_INT 1
5086: PPUSH
5087: LD_INT 25
5089: PUSH
5090: LD_INT 28
5092: PUSH
5093: LD_INT 28
5095: PUSH
5096: LD_INT 26
5098: PUSH
5099: EMPTY
5100: LIST
5101: LIST
5102: LIST
5103: LIST
5104: PUSH
5105: LD_VAR 0 2
5109: PUSH
5110: LD_INT 4
5112: MOD
5113: PUSH
5114: LD_INT 1
5116: PLUS
5117: ARRAY
5118: PPUSH
5119: LD_INT 100
5121: PPUSH
5122: CALL 21275 0 5
// veh := CreateVehicle ;
5126: LD_ADDR_VAR 0 3
5130: PUSH
5131: CALL_OW 45
5135: ST_TO_ADDR
// tmp := tmp ^ veh ;
5136: LD_ADDR_VAR 0 4
5140: PUSH
5141: LD_VAR 0 4
5145: PUSH
5146: LD_VAR 0 3
5150: ADD
5151: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
5152: LD_VAR 0 3
5156: PPUSH
5157: LD_INT 1
5159: PPUSH
5160: LD_INT 0
5162: PPUSH
5163: CALL_OW 49
// end ;
5167: GO 5075
5169: POP
5170: POP
// arabian_guard := tmp ;
5171: LD_ADDR_EXP 56
5175: PUSH
5176: LD_VAR 0 4
5180: ST_TO_ADDR
// end ;
5181: LD_VAR 0 1
5185: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
5186: LD_INT 22
5188: PUSH
5189: LD_INT 7
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: PUSH
5196: LD_INT 91
5198: PUSH
5199: LD_INT 1
5201: PUSH
5202: LD_INT 12
5204: PUSH
5205: EMPTY
5206: LIST
5207: LIST
5208: LIST
5209: PUSH
5210: EMPTY
5211: LIST
5212: LIST
5213: PPUSH
5214: CALL_OW 69
5218: PUSH
5219: LD_EXP 58
5223: PPUSH
5224: CALL_OW 256
5228: PUSH
5229: LD_INT 990
5231: LESS
5232: OR
5233: PUSH
5234: LD_EXP 57
5238: PPUSH
5239: CALL_OW 256
5243: PUSH
5244: LD_INT 990
5246: LESS
5247: OR
5248: IFFALSE 5391
5250: GO 5252
5252: DISABLE
// begin if IsInUnit ( Abdul ) then
5253: LD_EXP 57
5257: PPUSH
5258: CALL_OW 310
5262: IFFALSE 5273
// ComExitBuilding ( Abdul ) ;
5264: LD_EXP 57
5268: PPUSH
5269: CALL_OW 122
// if Mastodont then
5273: LD_EXP 58
5277: IFFALSE 5294
// ComMoveXY ( Mastodont , 205 , 132 ) ;
5279: LD_EXP 58
5283: PPUSH
5284: LD_INT 205
5286: PPUSH
5287: LD_INT 132
5289: PPUSH
5290: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
5294: LD_EXP 57
5298: PPUSH
5299: LD_INT 205
5301: PPUSH
5302: LD_INT 132
5304: PPUSH
5305: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
5309: LD_INT 35
5311: PPUSH
5312: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
5316: LD_EXP 57
5320: PPUSH
5321: LD_INT 21
5323: PPUSH
5324: CALL_OW 308
5328: IFFALSE 5309
// RemoveUnit ( Abdul ) ;
5330: LD_EXP 57
5334: PPUSH
5335: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
5339: LD_INT 35
5341: PPUSH
5342: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
5346: LD_EXP 58
5350: PPUSH
5351: LD_INT 21
5353: PPUSH
5354: CALL_OW 308
5358: PUSH
5359: LD_EXP 58
5363: PPUSH
5364: CALL_OW 301
5368: OR
5369: IFFALSE 5339
// if IsOk ( Mastodont ) then
5371: LD_EXP 58
5375: PPUSH
5376: CALL_OW 302
5380: IFFALSE 5391
// RemoveUnit ( Mastodont ) ;
5382: LD_EXP 58
5386: PPUSH
5387: CALL_OW 64
// end ;
5391: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
5392: LD_EXP 57
5396: PPUSH
5397: CALL_OW 301
5401: PUSH
5402: LD_INT 22
5404: PUSH
5405: LD_INT 2
5407: PUSH
5408: EMPTY
5409: LIST
5410: LIST
5411: PUSH
5412: LD_INT 2
5414: PUSH
5415: LD_INT 25
5417: PUSH
5418: LD_INT 1
5420: PUSH
5421: EMPTY
5422: LIST
5423: LIST
5424: PUSH
5425: LD_INT 25
5427: PUSH
5428: LD_INT 2
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: PUSH
5435: LD_INT 25
5437: PUSH
5438: LD_INT 3
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PUSH
5445: LD_INT 25
5447: PUSH
5448: LD_INT 4
5450: PUSH
5451: EMPTY
5452: LIST
5453: LIST
5454: PUSH
5455: LD_INT 25
5457: PUSH
5458: LD_INT 8
5460: PUSH
5461: EMPTY
5462: LIST
5463: LIST
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: LIST
5469: LIST
5470: LIST
5471: LIST
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: PPUSH
5477: CALL_OW 69
5481: PUSH
5482: LD_INT 16
5484: PUSH
5485: LD_INT 19
5487: PUSH
5488: LD_INT 22
5490: PUSH
5491: LD_INT 22
5493: PUSH
5494: EMPTY
5495: LIST
5496: LIST
5497: LIST
5498: LIST
5499: PUSH
5500: LD_OWVAR 67
5504: ARRAY
5505: LESS
5506: OR
5507: IFFALSE 6180
5509: GO 5511
5511: DISABLE
5512: LD_INT 0
5514: PPUSH
5515: PPUSH
5516: PPUSH
5517: PPUSH
5518: PPUSH
5519: PPUSH
// begin MC_Kill ( 1 ) ;
5520: LD_INT 1
5522: PPUSH
5523: CALL 59318 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
5527: LD_ADDR_VAR 0 2
5531: PUSH
5532: LD_INT 22
5534: PUSH
5535: LD_INT 2
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: PUSH
5542: LD_INT 2
5544: PUSH
5545: LD_INT 25
5547: PUSH
5548: LD_INT 1
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: PUSH
5555: LD_INT 25
5557: PUSH
5558: LD_INT 2
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: PUSH
5565: LD_INT 25
5567: PUSH
5568: LD_INT 3
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: PUSH
5575: LD_INT 25
5577: PUSH
5578: LD_INT 4
5580: PUSH
5581: EMPTY
5582: LIST
5583: LIST
5584: PUSH
5585: LD_INT 25
5587: PUSH
5588: LD_INT 8
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: EMPTY
5596: LIST
5597: LIST
5598: LIST
5599: LIST
5600: LIST
5601: LIST
5602: PUSH
5603: EMPTY
5604: LIST
5605: LIST
5606: PPUSH
5607: CALL_OW 69
5611: ST_TO_ADDR
// for i in tmp do
5612: LD_ADDR_VAR 0 5
5616: PUSH
5617: LD_VAR 0 2
5621: PUSH
5622: FOR_IN
5623: IFFALSE 5639
// SetTag ( i , 10 ) ;
5625: LD_VAR 0 5
5629: PPUSH
5630: LD_INT 10
5632: PPUSH
5633: CALL_OW 109
5637: GO 5622
5639: POP
5640: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5641: LD_ADDR_VAR 0 3
5645: PUSH
5646: LD_INT 22
5648: PUSH
5649: LD_INT 2
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: PUSH
5656: LD_INT 21
5658: PUSH
5659: LD_INT 1
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: PUSH
5666: EMPTY
5667: LIST
5668: LIST
5669: PPUSH
5670: CALL_OW 69
5674: PUSH
5675: LD_VAR 0 2
5679: DIFF
5680: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5681: LD_ADDR_VAR 0 1
5685: PUSH
5686: LD_INT 22
5688: PUSH
5689: LD_INT 2
5691: PUSH
5692: EMPTY
5693: LIST
5694: LIST
5695: PUSH
5696: LD_INT 21
5698: PUSH
5699: LD_INT 2
5701: PUSH
5702: EMPTY
5703: LIST
5704: LIST
5705: PUSH
5706: LD_INT 24
5708: PUSH
5709: LD_INT 300
5711: PUSH
5712: EMPTY
5713: LIST
5714: LIST
5715: PUSH
5716: EMPTY
5717: LIST
5718: LIST
5719: LIST
5720: PPUSH
5721: CALL_OW 69
5725: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5726: LD_ADDR_VAR 0 4
5730: PUSH
5731: LD_VAR 0 1
5735: PPUSH
5736: LD_INT 33
5738: PUSH
5739: LD_INT 1
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: PUSH
5746: LD_INT 58
5748: PUSH
5749: EMPTY
5750: LIST
5751: PUSH
5752: EMPTY
5753: LIST
5754: LIST
5755: PPUSH
5756: CALL_OW 72
5760: ST_TO_ADDR
// for i in tmp do
5761: LD_ADDR_VAR 0 5
5765: PUSH
5766: LD_VAR 0 2
5770: PUSH
5771: FOR_IN
5772: IFFALSE 5956
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5774: LD_VAR 0 5
5778: PUSH
5779: LD_INT 55
5781: PUSH
5782: EMPTY
5783: LIST
5784: PPUSH
5785: CALL_OW 69
5789: IN
5790: IFFALSE 5809
// begin AddComMoveXY ( i , 209 , 132 ) ;
5792: LD_VAR 0 5
5796: PPUSH
5797: LD_INT 209
5799: PPUSH
5800: LD_INT 132
5802: PPUSH
5803: CALL_OW 171
// continue ;
5807: GO 5771
// end ; if IsInUnit ( i ) then
5809: LD_VAR 0 5
5813: PPUSH
5814: CALL_OW 310
5818: IFFALSE 5836
// begin ComExitBuilding ( i ) ;
5820: LD_VAR 0 5
5824: PPUSH
5825: CALL_OW 122
// wait ( 3 ) ;
5829: LD_INT 3
5831: PPUSH
5832: CALL_OW 67
// end ; if tmp_empty then
5836: LD_VAR 0 4
5840: IFFALSE 5939
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5842: LD_VAR 0 5
5846: PPUSH
5847: LD_VAR 0 4
5851: PPUSH
5852: LD_VAR 0 5
5856: PPUSH
5857: CALL_OW 74
5861: PPUSH
5862: CALL_OW 296
5866: PUSH
5867: LD_INT 25
5869: LESS
5870: IFFALSE 5939
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5872: LD_ADDR_VAR 0 6
5876: PUSH
5877: LD_VAR 0 4
5881: PPUSH
5882: LD_VAR 0 5
5886: PPUSH
5887: CALL_OW 74
5891: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5892: LD_VAR 0 5
5896: PPUSH
5897: LD_VAR 0 6
5901: PPUSH
5902: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5906: LD_VAR 0 5
5910: PPUSH
5911: LD_INT 209
5913: PPUSH
5914: LD_INT 132
5916: PPUSH
5917: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5921: LD_ADDR_VAR 0 4
5925: PUSH
5926: LD_VAR 0 4
5930: PUSH
5931: LD_VAR 0 6
5935: DIFF
5936: ST_TO_ADDR
// continue ;
5937: GO 5771
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5939: LD_VAR 0 5
5943: PPUSH
5944: LD_INT 201
5946: PPUSH
5947: LD_INT 132
5949: PPUSH
5950: CALL_OW 171
// end ;
5954: GO 5771
5956: POP
5957: POP
// for i in tmp_ape do
5958: LD_ADDR_VAR 0 5
5962: PUSH
5963: LD_VAR 0 3
5967: PUSH
5968: FOR_IN
5969: IFFALSE 6008
// begin if IsInUnit ( i ) then
5971: LD_VAR 0 5
5975: PPUSH
5976: CALL_OW 310
5980: IFFALSE 5991
// ComExitBuilding ( i ) ;
5982: LD_VAR 0 5
5986: PPUSH
5987: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5991: LD_VAR 0 5
5995: PPUSH
5996: LD_INT 201
5998: PPUSH
5999: LD_INT 132
6001: PPUSH
6002: CALL_OW 171
// end ;
6006: GO 5968
6008: POP
6009: POP
// repeat wait ( 0 0$1 ) ;
6010: LD_INT 35
6012: PPUSH
6013: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
6017: LD_ADDR_VAR 0 5
6021: PUSH
6022: LD_VAR 0 2
6026: PUSH
6027: LD_VAR 0 3
6031: UNION
6032: PUSH
6033: LD_VAR 0 1
6037: UNION
6038: PUSH
6039: FOR_IN
6040: IFFALSE 6071
// if not HasTask ( i ) then
6042: LD_VAR 0 5
6046: PPUSH
6047: CALL_OW 314
6051: NOT
6052: IFFALSE 6069
// ComMoveXY ( i , 201 , 132 ) ;
6054: LD_VAR 0 5
6058: PPUSH
6059: LD_INT 201
6061: PPUSH
6062: LD_INT 132
6064: PPUSH
6065: CALL_OW 111
6069: GO 6039
6071: POP
6072: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
6073: LD_INT 21
6075: PPUSH
6076: LD_INT 22
6078: PUSH
6079: LD_INT 2
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PPUSH
6086: CALL_OW 70
6090: IFFALSE 6131
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
6092: LD_ADDR_VAR 0 5
6096: PUSH
6097: LD_INT 21
6099: PPUSH
6100: LD_INT 22
6102: PUSH
6103: LD_INT 2
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: PPUSH
6110: CALL_OW 70
6114: PUSH
6115: FOR_IN
6116: IFFALSE 6129
// RemoveUnit ( i ) ;
6118: LD_VAR 0 5
6122: PPUSH
6123: CALL_OW 64
6127: GO 6115
6129: POP
6130: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
6131: LD_INT 22
6133: PUSH
6134: LD_INT 2
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: PUSH
6141: LD_INT 2
6143: PUSH
6144: LD_INT 21
6146: PUSH
6147: LD_INT 1
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: PUSH
6154: LD_INT 21
6156: PUSH
6157: LD_INT 2
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: LIST
6168: PUSH
6169: EMPTY
6170: LIST
6171: LIST
6172: PPUSH
6173: CALL_OW 69
6177: NOT
6178: IFFALSE 6010
// end ;
6180: PPOPN 6
6182: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
6183: LD_EXP 9
6187: PUSH
6188: LD_INT 92
6190: PPUSH
6191: LD_INT 40
6193: PPUSH
6194: CALL_OW 428
6198: PPUSH
6199: CALL_OW 266
6203: PUSH
6204: LD_INT 30
6206: EQUAL
6207: AND
6208: IFFALSE 6404
6210: GO 6212
6212: DISABLE
6213: LD_INT 0
6215: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
6216: LD_ADDR_VAR 0 1
6220: PUSH
6221: LD_EXP 61
6225: PUSH
6226: LD_INT 1
6228: ARRAY
6229: PPUSH
6230: LD_INT 25
6232: PUSH
6233: LD_INT 4
6235: PUSH
6236: EMPTY
6237: LIST
6238: LIST
6239: PPUSH
6240: CALL_OW 72
6244: ST_TO_ADDR
// if not sci then
6245: LD_VAR 0 1
6249: NOT
6250: IFFALSE 6254
// exit ;
6252: GO 6404
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
6254: LD_ADDR_EXP 61
6258: PUSH
6259: LD_EXP 61
6263: PPUSH
6264: LD_INT 1
6266: PPUSH
6267: LD_EXP 61
6271: PUSH
6272: LD_INT 1
6274: ARRAY
6275: PUSH
6276: LD_VAR 0 1
6280: PUSH
6281: LD_INT 1
6283: ARRAY
6284: DIFF
6285: PPUSH
6286: CALL_OW 1
6290: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
6291: LD_VAR 0 1
6295: PUSH
6296: LD_INT 1
6298: ARRAY
6299: PPUSH
6300: CALL_OW 310
6304: IFFALSE 6319
// ComExitBuilding ( sci [ 1 ] ) ;
6306: LD_VAR 0 1
6310: PUSH
6311: LD_INT 1
6313: ARRAY
6314: PPUSH
6315: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
6319: LD_INT 2
6321: PPUSH
6322: LD_INT 105
6324: PPUSH
6325: LD_INT 14
6327: PPUSH
6328: LD_INT 20
6330: PPUSH
6331: CALL 22661 0 4
6335: PUSH
6336: LD_INT 4
6338: ARRAY
6339: PUSH
6340: LD_INT 10
6342: LESS
6343: IFFALSE 6366
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
6345: LD_VAR 0 1
6349: PUSH
6350: LD_INT 1
6352: ARRAY
6353: PPUSH
6354: LD_INT 105
6356: PPUSH
6357: LD_INT 14
6359: PPUSH
6360: CALL_OW 171
6364: GO 6385
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
6366: LD_VAR 0 1
6370: PUSH
6371: LD_INT 1
6373: ARRAY
6374: PPUSH
6375: LD_INT 118
6377: PPUSH
6378: LD_INT 77
6380: PPUSH
6381: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
6385: LD_VAR 0 1
6389: PUSH
6390: LD_INT 1
6392: ARRAY
6393: PPUSH
6394: LD_INT 92
6396: PPUSH
6397: LD_INT 40
6399: PPUSH
6400: CALL_OW 218
// end ;
6404: PPOPN 1
6406: END
// every 6 6$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , un , base , tmp , flags , _target , attackers , p ;
6407: LD_INT 1
6409: PPUSH
6410: CALL_OW 302
6414: PUSH
6415: LD_EXP 9
6419: AND
6420: IFFALSE 7291
6422: GO 6424
6424: DISABLE
6425: LD_INT 0
6427: PPUSH
6428: PPUSH
6429: PPUSH
6430: PPUSH
6431: PPUSH
6432: PPUSH
6433: PPUSH
6434: PPUSH
// begin enable ;
6435: ENABLE
// base := 1 ;
6436: LD_ADDR_VAR 0 3
6440: PUSH
6441: LD_INT 1
6443: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6444: LD_ADDR_VAR 0 5
6448: PUSH
6449: LD_INT 0
6451: PUSH
6452: LD_INT 0
6454: PUSH
6455: LD_INT 0
6457: PUSH
6458: LD_INT 0
6460: PUSH
6461: LD_INT 0
6463: PUSH
6464: LD_INT 0
6466: PUSH
6467: LD_INT 0
6469: PUSH
6470: LD_INT 0
6472: PUSH
6473: LD_INT 1
6475: PUSH
6476: LD_INT 0
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: LIST
6490: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
6491: LD_ADDR_VAR 0 4
6495: PUSH
6496: LD_INT 13
6498: PUSH
6499: LD_INT 1
6501: PUSH
6502: LD_INT 2
6504: PUSH
6505: LD_INT 26
6507: PUSH
6508: EMPTY
6509: LIST
6510: LIST
6511: LIST
6512: LIST
6513: PUSH
6514: LD_INT 13
6516: PUSH
6517: LD_INT 1
6519: PUSH
6520: LD_INT 2
6522: PUSH
6523: LD_INT 28
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: LIST
6530: LIST
6531: PUSH
6532: LD_INT 13
6534: PUSH
6535: LD_INT 1
6537: PUSH
6538: LD_INT 2
6540: PUSH
6541: LD_INT 29
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: LIST
6548: LIST
6549: PUSH
6550: EMPTY
6551: LIST
6552: LIST
6553: LIST
6554: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6555: LD_ADDR_VAR 0 1
6559: PUSH
6560: DOUBLE
6561: LD_INT 1
6563: DEC
6564: ST_TO_ADDR
6565: LD_OWVAR 67
6569: PUSH
6570: LD_OWVAR 1
6574: PUSH
6575: LD_INT 21000
6577: DIV
6578: PLUS
6579: PUSH
6580: FOR_TO
6581: IFFALSE 6654
// tmp := Insert ( tmp , tmp + 1 , [ ar_medium_trike , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6583: LD_ADDR_VAR 0 4
6587: PUSH
6588: LD_VAR 0 4
6592: PPUSH
6593: LD_VAR 0 4
6597: PUSH
6598: LD_INT 1
6600: PLUS
6601: PPUSH
6602: LD_INT 13
6604: PUSH
6605: LD_INT 1
6607: PUSH
6608: LD_INT 2
6610: PUSH
6611: LD_INT 28
6613: PUSH
6614: LD_INT 29
6616: PUSH
6617: LD_INT 25
6619: PUSH
6620: LD_INT 26
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: LIST
6627: LIST
6628: PUSH
6629: LD_INT 1
6631: PPUSH
6632: LD_INT 4
6634: PPUSH
6635: CALL_OW 12
6639: ARRAY
6640: PUSH
6641: EMPTY
6642: LIST
6643: LIST
6644: LIST
6645: LIST
6646: PPUSH
6647: CALL_OW 2
6651: ST_TO_ADDR
6652: GO 6580
6654: POP
6655: POP
// MC_InsertProduceList ( base , tmp ) ;
6656: LD_VAR 0 3
6660: PPUSH
6661: LD_VAR 0 4
6665: PPUSH
6666: CALL 83343 0 2
// wait ( 3 3$20 ) ;
6670: LD_INT 7000
6672: PPUSH
6673: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6677: LD_ADDR_VAR 0 6
6681: PUSH
6682: LD_INT 124
6684: PUSH
6685: LD_INT 85
6687: PUSH
6688: EMPTY
6689: LIST
6690: LIST
6691: PUSH
6692: LD_INT 90
6694: PUSH
6695: LD_INT 61
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PUSH
6702: LD_INT 69
6704: PUSH
6705: LD_INT 48
6707: PUSH
6708: EMPTY
6709: LIST
6710: LIST
6711: PUSH
6712: LD_INT 68
6714: PUSH
6715: LD_INT 48
6717: PUSH
6718: EMPTY
6719: LIST
6720: LIST
6721: PUSH
6722: EMPTY
6723: LIST
6724: LIST
6725: LIST
6726: LIST
6727: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ] ) diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6728: LD_ADDR_VAR 0 7
6732: PUSH
6733: LD_INT 22
6735: PUSH
6736: LD_INT 2
6738: PUSH
6739: EMPTY
6740: LIST
6741: LIST
6742: PUSH
6743: LD_INT 21
6745: PUSH
6746: LD_INT 2
6748: PUSH
6749: EMPTY
6750: LIST
6751: LIST
6752: PUSH
6753: LD_INT 3
6755: PUSH
6756: LD_INT 34
6758: PUSH
6759: LD_INT 31
6761: PUSH
6762: EMPTY
6763: LIST
6764: LIST
6765: PUSH
6766: LD_INT 34
6768: PUSH
6769: LD_INT 88
6771: PUSH
6772: EMPTY
6773: LIST
6774: LIST
6775: PUSH
6776: LD_INT 34
6778: PUSH
6779: LD_INT 32
6781: PUSH
6782: EMPTY
6783: LIST
6784: LIST
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: LIST
6790: LIST
6791: PUSH
6792: EMPTY
6793: LIST
6794: LIST
6795: LIST
6796: PPUSH
6797: CALL_OW 69
6801: PUSH
6802: LD_EXP 80
6806: PUSH
6807: LD_VAR 0 3
6811: ARRAY
6812: PPUSH
6813: LD_INT 2
6815: PUSH
6816: LD_INT 34
6818: PUSH
6819: LD_INT 32
6821: PUSH
6822: EMPTY
6823: LIST
6824: LIST
6825: PUSH
6826: LD_INT 34
6828: PUSH
6829: LD_INT 88
6831: PUSH
6832: EMPTY
6833: LIST
6834: LIST
6835: PUSH
6836: EMPTY
6837: LIST
6838: LIST
6839: LIST
6840: PPUSH
6841: CALL_OW 72
6845: DIFF
6846: ST_TO_ADDR
// if rand ( 0 , 1 ) then
6847: LD_INT 0
6849: PPUSH
6850: LD_INT 1
6852: PPUSH
6853: CALL_OW 12
6857: IFFALSE 7007
// begin for i := 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
6859: LD_ADDR_VAR 0 1
6863: PUSH
6864: DOUBLE
6865: LD_INT 1
6867: DEC
6868: ST_TO_ADDR
6869: LD_INT 3
6871: PUSH
6872: LD_INT 4
6874: PUSH
6875: LD_INT 5
6877: PUSH
6878: LD_INT 6
6880: PUSH
6881: EMPTY
6882: LIST
6883: LIST
6884: LIST
6885: LIST
6886: PUSH
6887: LD_OWVAR 67
6891: ARRAY
6892: PUSH
6893: FOR_TO
6894: IFFALSE 7003
// begin uc_side := 2 ;
6896: LD_ADDR_OWVAR 20
6900: PUSH
6901: LD_INT 2
6903: ST_TO_ADDR
// uc_nation := 2 ;
6904: LD_ADDR_OWVAR 21
6908: PUSH
6909: LD_INT 2
6911: ST_TO_ADDR
// InitHc ;
6912: CALL_OW 19
// PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6916: LD_INT 0
6918: PPUSH
6919: LD_INT 15
6921: PUSH
6922: LD_INT 17
6924: PUSH
6925: EMPTY
6926: LIST
6927: LIST
6928: PUSH
6929: LD_INT 1
6931: PPUSH
6932: LD_INT 2
6934: PPUSH
6935: CALL_OW 12
6939: ARRAY
6940: PPUSH
6941: LD_INT 8
6943: PPUSH
6944: CALL_OW 380
// un := CreateHuman ;
6948: LD_ADDR_VAR 0 2
6952: PUSH
6953: CALL_OW 44
6957: ST_TO_ADDR
// SetDir ( un , 4 ) ;
6958: LD_VAR 0 2
6962: PPUSH
6963: LD_INT 4
6965: PPUSH
6966: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
6970: LD_VAR 0 2
6974: PPUSH
6975: LD_INT 23
6977: PPUSH
6978: LD_INT 0
6980: PPUSH
6981: CALL_OW 49
// attackers := attackers union un ;
6985: LD_ADDR_VAR 0 7
6989: PUSH
6990: LD_VAR 0 7
6994: PUSH
6995: LD_VAR 0 2
6999: UNION
7000: ST_TO_ADDR
// end ;
7001: GO 6893
7003: POP
7004: POP
// end else
7005: GO 7165
// begin for i := 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
7007: LD_ADDR_VAR 0 1
7011: PUSH
7012: DOUBLE
7013: LD_INT 1
7015: DEC
7016: ST_TO_ADDR
7017: LD_INT 2
7019: PUSH
7020: LD_INT 3
7022: PUSH
7023: LD_INT 4
7025: PUSH
7026: LD_INT 5
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: LIST
7033: LIST
7034: PUSH
7035: LD_OWVAR 67
7039: ARRAY
7040: PUSH
7041: FOR_TO
7042: IFFALSE 7163
// begin uc_side := 2 ;
7044: LD_ADDR_OWVAR 20
7048: PUSH
7049: LD_INT 2
7051: ST_TO_ADDR
// uc_nation := 2 ;
7052: LD_ADDR_OWVAR 21
7056: PUSH
7057: LD_INT 2
7059: ST_TO_ADDR
// InitHc ;
7060: CALL_OW 19
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_flame_thrower ] [ i mod 3 + 1 ] , 100 ) ;
7064: LD_INT 14
7066: PPUSH
7067: LD_INT 3
7069: PPUSH
7070: LD_INT 5
7072: PPUSH
7073: LD_INT 29
7075: PUSH
7076: LD_INT 29
7078: PUSH
7079: LD_INT 26
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: LIST
7086: PUSH
7087: LD_VAR 0 1
7091: PUSH
7092: LD_INT 3
7094: MOD
7095: PUSH
7096: LD_INT 1
7098: PLUS
7099: ARRAY
7100: PPUSH
7101: LD_INT 100
7103: PPUSH
7104: CALL 21275 0 5
// un := CreateVehicle ;
7108: LD_ADDR_VAR 0 2
7112: PUSH
7113: CALL_OW 45
7117: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7118: LD_VAR 0 2
7122: PPUSH
7123: LD_INT 4
7125: PPUSH
7126: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
7130: LD_VAR 0 2
7134: PPUSH
7135: LD_INT 23
7137: PPUSH
7138: LD_INT 0
7140: PPUSH
7141: CALL_OW 49
// attackers := attackers union un ;
7145: LD_ADDR_VAR 0 7
7149: PUSH
7150: LD_VAR 0 7
7154: PUSH
7155: LD_VAR 0 2
7159: UNION
7160: ST_TO_ADDR
// end ;
7161: GO 7041
7163: POP
7164: POP
// end ; if not attackers then
7165: LD_VAR 0 7
7169: NOT
7170: IFFALSE 7174
// exit ;
7172: GO 7291
// ar_attackers := attackers ;
7174: LD_ADDR_EXP 11
7178: PUSH
7179: LD_VAR 0 7
7183: ST_TO_ADDR
// p := 0 ;
7184: LD_ADDR_VAR 0 8
7188: PUSH
7189: LD_INT 0
7191: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7192: LD_INT 35
7194: PPUSH
7195: CALL_OW 67
// p := Inc ( p ) ;
7199: LD_ADDR_VAR 0 8
7203: PUSH
7204: LD_VAR 0 8
7208: PPUSH
7209: CALL 55487 0 1
7213: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7214: LD_VAR 0 7
7218: PPUSH
7219: LD_INT 60
7221: PUSH
7222: EMPTY
7223: LIST
7224: PPUSH
7225: CALL_OW 72
7229: NOT
7230: PUSH
7231: LD_VAR 0 8
7235: PUSH
7236: LD_INT 30
7238: GREATER
7239: OR
7240: IFFALSE 7192
// repeat wait ( 0 0$1 ) ;
7242: LD_INT 35
7244: PPUSH
7245: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
7249: LD_ADDR_VAR 0 7
7253: PUSH
7254: LD_VAR 0 7
7258: PPUSH
7259: LD_INT 50
7261: PUSH
7262: EMPTY
7263: LIST
7264: PPUSH
7265: CALL_OW 72
7269: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
7270: LD_VAR 0 7
7274: PPUSH
7275: LD_VAR 0 6
7279: PPUSH
7280: CALL 56730 0 2
// until not attackers ;
7284: LD_VAR 0 7
7288: NOT
7289: IFFALSE 7242
// end ;
7291: PPOPN 8
7293: END
// every 5 5$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) do var i , base , tmp , flags , _target , attackers , un , p ;
7294: LD_INT 1
7296: PPUSH
7297: CALL_OW 302
7301: PUSH
7302: LD_EXP 9
7306: AND
7307: PUSH
7308: LD_EXP 51
7312: PPUSH
7313: LD_INT 22
7315: PPUSH
7316: CALL_OW 308
7320: AND
7321: IFFALSE 7809
7323: GO 7325
7325: DISABLE
7326: LD_INT 0
7328: PPUSH
7329: PPUSH
7330: PPUSH
7331: PPUSH
7332: PPUSH
7333: PPUSH
7334: PPUSH
7335: PPUSH
// begin base := 1 ;
7336: LD_ADDR_VAR 0 2
7340: PUSH
7341: LD_INT 1
7343: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7344: LD_ADDR_VAR 0 4
7348: PUSH
7349: LD_INT 0
7351: PUSH
7352: LD_INT 0
7354: PUSH
7355: LD_INT 0
7357: PUSH
7358: LD_INT 0
7360: PUSH
7361: LD_INT 0
7363: PUSH
7364: LD_INT 0
7366: PUSH
7367: LD_INT 0
7369: PUSH
7370: LD_INT 0
7372: PUSH
7373: LD_INT 1
7375: PUSH
7376: LD_INT 0
7378: PUSH
7379: EMPTY
7380: LIST
7381: LIST
7382: LIST
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: LIST
7388: LIST
7389: LIST
7390: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
7391: LD_ADDR_VAR 0 3
7395: PUSH
7396: LD_INT 13
7398: PUSH
7399: LD_INT 1
7401: PUSH
7402: LD_INT 2
7404: PUSH
7405: LD_INT 28
7407: PUSH
7408: EMPTY
7409: LIST
7410: LIST
7411: LIST
7412: LIST
7413: PUSH
7414: LD_INT 13
7416: PUSH
7417: LD_INT 1
7419: PUSH
7420: LD_INT 2
7422: PUSH
7423: LD_INT 27
7425: PUSH
7426: EMPTY
7427: LIST
7428: LIST
7429: LIST
7430: LIST
7431: PUSH
7432: LD_INT 13
7434: PUSH
7435: LD_INT 1
7437: PUSH
7438: LD_INT 2
7440: PUSH
7441: LD_INT 25
7443: PUSH
7444: EMPTY
7445: LIST
7446: LIST
7447: LIST
7448: LIST
7449: PUSH
7450: LD_INT 11
7452: PUSH
7453: LD_INT 2
7455: PUSH
7456: LD_INT 2
7458: PUSH
7459: LD_INT 24
7461: PUSH
7462: EMPTY
7463: LIST
7464: LIST
7465: LIST
7466: LIST
7467: PUSH
7468: LD_INT 11
7470: PUSH
7471: LD_INT 2
7473: PUSH
7474: LD_INT 2
7476: PUSH
7477: LD_INT 24
7479: PUSH
7480: EMPTY
7481: LIST
7482: LIST
7483: LIST
7484: LIST
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: LIST
7490: LIST
7491: LIST
7492: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7493: LD_VAR 0 2
7497: PPUSH
7498: LD_VAR 0 3
7502: PPUSH
7503: CALL 83343 0 2
// wait ( 4 4$20 ) ;
7507: LD_INT 9100
7509: PPUSH
7510: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
7514: LD_ADDR_VAR 0 5
7518: PUSH
7519: LD_INT 119
7521: PUSH
7522: LD_INT 9
7524: PUSH
7525: EMPTY
7526: LIST
7527: LIST
7528: PUSH
7529: EMPTY
7530: LIST
7531: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7532: LD_ADDR_VAR 0 6
7536: PUSH
7537: LD_EXP 80
7541: PUSH
7542: LD_VAR 0 2
7546: ARRAY
7547: PUSH
7548: LD_EXP 80
7552: PUSH
7553: LD_VAR 0 2
7557: ARRAY
7558: PPUSH
7559: LD_INT 2
7561: PUSH
7562: LD_INT 34
7564: PUSH
7565: LD_INT 32
7567: PUSH
7568: EMPTY
7569: LIST
7570: LIST
7571: PUSH
7572: LD_INT 34
7574: PUSH
7575: LD_INT 88
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: LIST
7586: PPUSH
7587: CALL_OW 72
7591: DIFF
7592: ST_TO_ADDR
// uc_side := 2 ;
7593: LD_ADDR_OWVAR 20
7597: PUSH
7598: LD_INT 2
7600: ST_TO_ADDR
// uc_nation := 2 ;
7601: LD_ADDR_OWVAR 21
7605: PUSH
7606: LD_INT 2
7608: ST_TO_ADDR
// InitHc ;
7609: CALL_OW 19
// for i := 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
7613: LD_ADDR_VAR 0 1
7617: PUSH
7618: DOUBLE
7619: LD_INT 1
7621: DEC
7622: ST_TO_ADDR
7623: LD_INT 4
7625: PUSH
7626: LD_INT 5
7628: PUSH
7629: LD_INT 6
7631: PUSH
7632: LD_INT 6
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: LIST
7639: LIST
7640: PUSH
7641: LD_OWVAR 67
7645: ARRAY
7646: PUSH
7647: FOR_TO
7648: IFFALSE 7725
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7650: LD_INT 0
7652: PPUSH
7653: LD_INT 15
7655: PUSH
7656: LD_INT 17
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: PUSH
7663: LD_INT 1
7665: PPUSH
7666: LD_INT 2
7668: PPUSH
7669: CALL_OW 12
7673: ARRAY
7674: PPUSH
7675: LD_INT 8
7677: PPUSH
7678: CALL_OW 380
// un := CreateHuman ;
7682: LD_ADDR_VAR 0 7
7686: PUSH
7687: CALL_OW 44
7691: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
7692: LD_VAR 0 7
7696: PPUSH
7697: LD_INT 23
7699: PPUSH
7700: LD_INT 0
7702: PPUSH
7703: CALL_OW 49
// attackers := attackers union un ;
7707: LD_ADDR_VAR 0 6
7711: PUSH
7712: LD_VAR 0 6
7716: PUSH
7717: LD_VAR 0 7
7721: UNION
7722: ST_TO_ADDR
// end ;
7723: GO 7647
7725: POP
7726: POP
// p := 0 ;
7727: LD_ADDR_VAR 0 8
7731: PUSH
7732: LD_INT 0
7734: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7735: LD_INT 35
7737: PPUSH
7738: CALL_OW 67
// p := Inc ( p ) ;
7742: LD_ADDR_VAR 0 8
7746: PUSH
7747: LD_VAR 0 8
7751: PPUSH
7752: CALL 55487 0 1
7756: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7757: LD_VAR 0 6
7761: PPUSH
7762: LD_INT 60
7764: PUSH
7765: EMPTY
7766: LIST
7767: PPUSH
7768: CALL_OW 72
7772: NOT
7773: PUSH
7774: LD_VAR 0 8
7778: PUSH
7779: LD_INT 30
7781: GREATER
7782: OR
7783: IFFALSE 7735
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
7785: LD_VAR 0 2
7789: PPUSH
7790: LD_VAR 0 6
7794: PPUSH
7795: LD_VAR 0 5
7799: PPUSH
7800: LD_VAR 0 4
7804: PPUSH
7805: CALL 83528 0 4
// end ; end_of_file
7809: PPOPN 8
7811: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
7812: LD_INT 0
7814: PPUSH
7815: PPUSH
7816: PPUSH
7817: PPUSH
7818: PPUSH
7819: PPUSH
// uc_side := 1 ;
7820: LD_ADDR_OWVAR 20
7824: PUSH
7825: LD_INT 1
7827: ST_TO_ADDR
// uc_nation := 1 ;
7828: LD_ADDR_OWVAR 21
7832: PUSH
7833: LD_INT 1
7835: ST_TO_ADDR
// InitHc ;
7836: CALL_OW 19
// InitVc ;
7840: CALL_OW 20
// tmp := [ ] ;
7844: LD_ADDR_VAR 0 3
7848: PUSH
7849: EMPTY
7850: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
7851: LD_ADDR_VAR 0 2
7855: PUSH
7856: DOUBLE
7857: LD_INT 1
7859: DEC
7860: ST_TO_ADDR
7861: LD_INT 6
7863: PUSH
7864: LD_INT 8
7866: PUSH
7867: LD_INT 10
7869: PUSH
7870: LD_INT 10
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: LIST
7877: LIST
7878: PUSH
7879: LD_OWVAR 67
7883: ARRAY
7884: PUSH
7885: FOR_TO
7886: IFFALSE 8176
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
7888: LD_ADDR_VAR 0 5
7892: PUSH
7893: LD_INT 2
7895: PUSH
7896: LD_INT 4
7898: PUSH
7899: LD_INT 5
7901: PUSH
7902: EMPTY
7903: LIST
7904: LIST
7905: LIST
7906: PUSH
7907: LD_INT 1
7909: PPUSH
7910: LD_INT 3
7912: PPUSH
7913: CALL_OW 12
7917: ARRAY
7918: ST_TO_ADDR
// case chassis of us_medium_wheeled :
7919: LD_VAR 0 5
7923: PUSH
7924: LD_INT 2
7926: DOUBLE
7927: EQUAL
7928: IFTRUE 7932
7930: GO 7966
7932: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
7933: LD_ADDR_VAR 0 6
7937: PUSH
7938: LD_INT 9
7940: PUSH
7941: LD_INT 5
7943: PUSH
7944: LD_INT 7
7946: PUSH
7947: EMPTY
7948: LIST
7949: LIST
7950: LIST
7951: PUSH
7952: LD_INT 1
7954: PPUSH
7955: LD_INT 3
7957: PPUSH
7958: CALL_OW 12
7962: ARRAY
7963: ST_TO_ADDR
7964: GO 8055
7966: LD_INT 4
7968: DOUBLE
7969: EQUAL
7970: IFTRUE 7974
7972: GO 8012
7974: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7975: LD_ADDR_VAR 0 6
7979: PUSH
7980: LD_INT 9
7982: PUSH
7983: LD_INT 6
7985: PUSH
7986: LD_INT 6
7988: PUSH
7989: LD_INT 7
7991: PUSH
7992: EMPTY
7993: LIST
7994: LIST
7995: LIST
7996: LIST
7997: PUSH
7998: LD_INT 1
8000: PPUSH
8001: LD_INT 4
8003: PPUSH
8004: CALL_OW 12
8008: ARRAY
8009: ST_TO_ADDR
8010: GO 8055
8012: LD_INT 5
8014: DOUBLE
8015: EQUAL
8016: IFTRUE 8020
8018: GO 8054
8020: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
8021: LD_ADDR_VAR 0 6
8025: PUSH
8026: LD_INT 9
8028: PUSH
8029: LD_INT 6
8031: PUSH
8032: LD_INT 7
8034: PUSH
8035: EMPTY
8036: LIST
8037: LIST
8038: LIST
8039: PUSH
8040: LD_INT 1
8042: PPUSH
8043: LD_INT 3
8045: PPUSH
8046: CALL_OW 12
8050: ARRAY
8051: ST_TO_ADDR
8052: GO 8055
8054: POP
// uc_side := 1 ;
8055: LD_ADDR_OWVAR 20
8059: PUSH
8060: LD_INT 1
8062: ST_TO_ADDR
// uc_nation := 1 ;
8063: LD_ADDR_OWVAR 21
8067: PUSH
8068: LD_INT 1
8070: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
8071: LD_VAR 0 5
8075: PPUSH
8076: LD_INT 1
8078: PUSH
8079: LD_INT 3
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: PUSH
8086: LD_INT 1
8088: PPUSH
8089: LD_INT 2
8091: PPUSH
8092: CALL_OW 12
8096: ARRAY
8097: PPUSH
8098: LD_INT 3
8100: PPUSH
8101: LD_VAR 0 6
8105: PPUSH
8106: LD_INT 70
8108: PPUSH
8109: LD_INT 90
8111: PPUSH
8112: CALL_OW 12
8116: PPUSH
8117: CALL 21275 0 5
// veh := CreateVehicle ;
8121: LD_ADDR_VAR 0 4
8125: PUSH
8126: CALL_OW 45
8130: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
8131: LD_VAR 0 4
8135: PPUSH
8136: LD_INT 2
8138: PPUSH
8139: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
8143: LD_VAR 0 4
8147: PPUSH
8148: LD_INT 17
8150: PPUSH
8151: LD_INT 0
8153: PPUSH
8154: CALL_OW 49
// tmp := tmp ^ veh ;
8158: LD_ADDR_VAR 0 3
8162: PUSH
8163: LD_VAR 0 3
8167: PUSH
8168: LD_VAR 0 4
8172: ADD
8173: ST_TO_ADDR
// end ;
8174: GO 7885
8176: POP
8177: POP
// if not tmp then
8178: LD_VAR 0 3
8182: NOT
8183: IFFALSE 8187
// exit ;
8185: GO 8296
// if not first_powell_attack then
8187: LD_EXP 12
8191: NOT
8192: IFFALSE 8202
// first_powell_attack := true ;
8194: LD_ADDR_EXP 12
8198: PUSH
8199: LD_INT 1
8201: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
8202: LD_INT 70
8204: PPUSH
8205: CALL_OW 67
// for i in tmp do
8209: LD_ADDR_VAR 0 2
8213: PUSH
8214: LD_VAR 0 3
8218: PUSH
8219: FOR_IN
8220: IFFALSE 8287
// if IsOk ( i ) then
8222: LD_VAR 0 2
8226: PPUSH
8227: CALL_OW 302
8231: IFFALSE 8269
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
8233: LD_VAR 0 2
8237: PPUSH
8238: LD_INT 81
8240: PUSH
8241: LD_INT 1
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: PPUSH
8248: CALL_OW 69
8252: PPUSH
8253: LD_VAR 0 2
8257: PPUSH
8258: CALL_OW 74
8262: PPUSH
8263: CALL_OW 115
8267: GO 8285
// tmp := tmp diff i ;
8269: LD_ADDR_VAR 0 3
8273: PUSH
8274: LD_VAR 0 3
8278: PUSH
8279: LD_VAR 0 2
8283: DIFF
8284: ST_TO_ADDR
8285: GO 8219
8287: POP
8288: POP
// until not tmp ;
8289: LD_VAR 0 3
8293: NOT
8294: IFFALSE 8202
// end ;
8296: LD_VAR 0 1
8300: RET
// export function TryToStoleArtifact ( artifact ) ; var veh ; begin
8301: LD_INT 0
8303: PPUSH
8304: PPUSH
// uc_side := 1 ;
8305: LD_ADDR_OWVAR 20
8309: PUSH
8310: LD_INT 1
8312: ST_TO_ADDR
// uc_nation := 1 ;
8313: LD_ADDR_OWVAR 21
8317: PUSH
8318: LD_INT 1
8320: ST_TO_ADDR
// InitHc ;
8321: CALL_OW 19
// InitVc ;
8325: CALL_OW 20
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
8329: LD_INT 5
8331: PPUSH
8332: LD_INT 3
8334: PPUSH
8335: LD_INT 3
8337: PPUSH
8338: LD_INT 12
8340: PPUSH
8341: LD_INT 100
8343: PPUSH
8344: CALL 21275 0 5
// veh := CreateVehicle ;
8348: LD_ADDR_VAR 0 3
8352: PUSH
8353: CALL_OW 45
8357: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
8358: LD_VAR 0 3
8362: PPUSH
8363: LD_INT 2
8365: PPUSH
8366: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
8370: LD_VAR 0 3
8374: PPUSH
8375: LD_INT 17
8377: PPUSH
8378: LD_INT 0
8380: PPUSH
8381: CALL_OW 49
// ComGet ( veh , artifact [ 1 ] , artifact [ 2 ] ) ;
8385: LD_VAR 0 3
8389: PPUSH
8390: LD_VAR 0 1
8394: PUSH
8395: LD_INT 1
8397: ARRAY
8398: PPUSH
8399: LD_VAR 0 1
8403: PUSH
8404: LD_INT 2
8406: ARRAY
8407: PPUSH
8408: CALL_OW 160
// AddComMoveXY ( veh , 59 , 2 ) ;
8412: LD_VAR 0 3
8416: PPUSH
8417: LD_INT 59
8419: PPUSH
8420: LD_INT 2
8422: PPUSH
8423: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8427: LD_INT 35
8429: PPUSH
8430: CALL_OW 67
// if not IsOk ( veh ) then
8434: LD_VAR 0 3
8438: PPUSH
8439: CALL_OW 302
8443: NOT
8444: IFFALSE 8448
// exit ;
8446: GO 8502
// until IsAt ( veh , 59 , 2 ) ;
8448: LD_VAR 0 3
8452: PPUSH
8453: LD_INT 59
8455: PPUSH
8456: LD_INT 2
8458: PPUSH
8459: CALL_OW 307
8463: IFFALSE 8427
// RemoveUnit ( veh ) ;
8465: LD_VAR 0 3
8469: PPUSH
8470: CALL_OW 64
// if GetCargo ( veh , mat_artifact ) then
8474: LD_VAR 0 3
8478: PPUSH
8479: LD_INT 4
8481: PPUSH
8482: CALL_OW 289
8486: IFFALSE 8502
// begin wait ( 0 0$2 ) ;
8488: LD_INT 70
8490: PPUSH
8491: CALL_OW 67
// YouLost ( Artifact ) ;
8495: LD_STRING Artifact
8497: PPUSH
8498: CALL_OW 104
// end ; end ; end_of_file
8502: LD_VAR 0 2
8506: RET
// export function Action ; var tmp , i , un ; begin
8507: LD_INT 0
8509: PPUSH
8510: PPUSH
8511: PPUSH
8512: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
8513: LD_INT 68
8515: PPUSH
8516: LD_INT 39
8518: PPUSH
8519: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
8523: LD_ADDR_VAR 0 2
8527: PUSH
8528: LD_INT 22
8530: PUSH
8531: LD_INT 7
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: PPUSH
8538: CALL_OW 69
8542: ST_TO_ADDR
// InGameOn ;
8543: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
8547: LD_VAR 0 2
8551: PPUSH
8552: LD_INT 71
8554: PPUSH
8555: LD_INT 49
8557: PPUSH
8558: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8562: LD_INT 35
8564: PPUSH
8565: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
8569: LD_INT 7
8571: PPUSH
8572: LD_INT 71
8574: PPUSH
8575: LD_INT 51
8577: PPUSH
8578: CALL_OW 293
8582: IFFALSE 8562
// DialogueOn ;
8584: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
8588: LD_EXP 16
8592: PPUSH
8593: LD_STRING D1-JMM-1
8595: PPUSH
8596: CALL_OW 88
// if Joan then
8600: LD_EXP 31
8604: IFFALSE 8618
// Say ( Joan , D1-Joan-1 ) ;
8606: LD_EXP 31
8610: PPUSH
8611: LD_STRING D1-Joan-1
8613: PPUSH
8614: CALL_OW 88
// if Lisa then
8618: LD_EXP 18
8622: IFFALSE 8636
// Say ( Lisa , D1-Lisa-1 ) ;
8624: LD_EXP 18
8628: PPUSH
8629: LD_STRING D1-Lisa-1
8631: PPUSH
8632: CALL_OW 88
// if Joan or Lisa then
8636: LD_EXP 31
8640: PUSH
8641: LD_EXP 18
8645: OR
8646: IFFALSE 8660
// Say ( JMM , D1-JMM-2 ) ;
8648: LD_EXP 16
8652: PPUSH
8653: LD_STRING D1-JMM-2
8655: PPUSH
8656: CALL_OW 88
// DialogueOff ;
8660: CALL_OW 7
// InGameOff ;
8664: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
8668: LD_INT 71
8670: PPUSH
8671: LD_INT 50
8673: PPUSH
8674: LD_INT 7
8676: PPUSH
8677: LD_INT 30
8679: NEG
8680: PPUSH
8681: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
8685: LD_INT 71
8687: PPUSH
8688: LD_INT 50
8690: PPUSH
8691: LD_INT 7
8693: PPUSH
8694: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
8698: LD_STRING M1
8700: PPUSH
8701: CALL_OW 337
// SaveForQuickRestart ;
8705: CALL_OW 22
// repeat wait ( 0 0$1 ) ;
8709: LD_INT 35
8711: PPUSH
8712: CALL_OW 67
// until freedom or tick > 1 1$00 ;
8716: LD_EXP 3
8720: PUSH
8721: LD_OWVAR 1
8725: PUSH
8726: LD_INT 2100
8728: GREATER
8729: OR
8730: IFFALSE 8709
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
8732: LD_INT 350
8734: PPUSH
8735: LD_INT 700
8737: PPUSH
8738: CALL_OW 12
8742: PPUSH
8743: CALL_OW 67
// PrepareGossudarov ;
8747: CALL 1935 0 0
// repeat wait ( 0 0$1 ) ;
8751: LD_INT 35
8753: PPUSH
8754: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
8758: LD_INT 22
8760: PUSH
8761: LD_INT 6
8763: PUSH
8764: EMPTY
8765: LIST
8766: LIST
8767: PUSH
8768: LD_INT 3
8770: PUSH
8771: LD_INT 24
8773: PUSH
8774: LD_INT 1000
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: EMPTY
8782: LIST
8783: LIST
8784: PUSH
8785: EMPTY
8786: LIST
8787: LIST
8788: PPUSH
8789: CALL_OW 69
8793: PUSH
8794: LD_INT 7
8796: PPUSH
8797: LD_EXP 34
8801: PPUSH
8802: CALL_OW 292
8806: OR
8807: IFFALSE 8751
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
8809: LD_ADDR_VAR 0 2
8813: PUSH
8814: LD_INT 22
8816: PUSH
8817: LD_INT 6
8819: PUSH
8820: EMPTY
8821: LIST
8822: LIST
8823: PPUSH
8824: CALL_OW 69
8828: ST_TO_ADDR
// for i in tmp do
8829: LD_ADDR_VAR 0 3
8833: PUSH
8834: LD_VAR 0 2
8838: PUSH
8839: FOR_IN
8840: IFFALSE 8856
// SetSide ( i , 7 ) ;
8842: LD_VAR 0 3
8846: PPUSH
8847: LD_INT 7
8849: PPUSH
8850: CALL_OW 235
8854: GO 8839
8856: POP
8857: POP
// DialogueOn ;
8858: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
8862: LD_EXP 16
8866: PUSH
8867: LD_EXP 17
8871: PUSH
8872: EMPTY
8873: LIST
8874: LIST
8875: PPUSH
8876: LD_EXP 34
8880: PPUSH
8881: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
8885: LD_EXP 34
8889: PPUSH
8890: CALL_OW 87
// if not Roth then
8894: LD_EXP 17
8898: NOT
8899: IFFALSE 8991
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8901: LD_VAR 0 2
8905: PPUSH
8906: LD_INT 3
8908: PUSH
8909: LD_INT 24
8911: PUSH
8912: LD_INT 1000
8914: PUSH
8915: EMPTY
8916: LIST
8917: LIST
8918: PUSH
8919: EMPTY
8920: LIST
8921: LIST
8922: PPUSH
8923: CALL_OW 72
8927: IFFALSE 8941
// Say ( JMM , D2-JMM-1 ) ;
8929: LD_EXP 16
8933: PPUSH
8934: LD_STRING D2-JMM-1
8936: PPUSH
8937: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
8941: LD_EXP 16
8945: PPUSH
8946: LD_STRING D2-JMM-1b
8948: PPUSH
8949: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
8953: LD_EXP 34
8957: PPUSH
8958: LD_STRING D2-Gos-1
8960: PPUSH
8961: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
8965: LD_EXP 16
8969: PPUSH
8970: LD_STRING D2-JMM-2
8972: PPUSH
8973: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
8977: LD_EXP 34
8981: PPUSH
8982: LD_STRING D2-Gos-2
8984: PPUSH
8985: CALL_OW 88
// end else
8989: GO 9143
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8991: LD_VAR 0 2
8995: PPUSH
8996: LD_INT 3
8998: PUSH
8999: LD_INT 24
9001: PUSH
9002: LD_INT 1000
9004: PUSH
9005: EMPTY
9006: LIST
9007: LIST
9008: PUSH
9009: EMPTY
9010: LIST
9011: LIST
9012: PPUSH
9013: CALL_OW 72
9017: IFFALSE 9043
// begin Say ( Roth , D2-Roth-2 ) ;
9019: LD_EXP 17
9023: PPUSH
9024: LD_STRING D2-Roth-2
9026: PPUSH
9027: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
9031: LD_EXP 16
9035: PPUSH
9036: LD_STRING D2-JMM-1a
9038: PPUSH
9039: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
9043: LD_EXP 17
9047: PPUSH
9048: LD_STRING D2-Roth-2a
9050: PPUSH
9051: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
9055: LD_EXP 17
9059: PPUSH
9060: LD_STRING D2-Roth-2b
9062: PPUSH
9063: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
9067: LD_EXP 16
9071: PPUSH
9072: LD_STRING D2-JMM-3
9074: PPUSH
9075: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9079: LD_VAR 0 2
9083: PPUSH
9084: LD_INT 3
9086: PUSH
9087: LD_INT 24
9089: PUSH
9090: LD_INT 1000
9092: PUSH
9093: EMPTY
9094: LIST
9095: LIST
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: PPUSH
9101: CALL_OW 72
9105: IFFALSE 9143
// begin Say ( Gossudarov , D2-Gos-3 ) ;
9107: LD_EXP 34
9111: PPUSH
9112: LD_STRING D2-Gos-3
9114: PPUSH
9115: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
9119: LD_EXP 16
9123: PPUSH
9124: LD_STRING D2-JMM-4
9126: PPUSH
9127: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
9131: LD_EXP 34
9135: PPUSH
9136: LD_STRING D2-Gos-4
9138: PPUSH
9139: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
9143: LD_EXP 16
9147: PPUSH
9148: LD_STRING D2-JMM-5
9150: PPUSH
9151: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
9155: LD_EXP 34
9159: PPUSH
9160: LD_STRING D2-Gos-5
9162: PPUSH
9163: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
9167: LD_EXP 16
9171: PPUSH
9172: LD_STRING D2-JMM-6
9174: PPUSH
9175: CALL_OW 88
// DialogueOff ;
9179: CALL_OW 7
// wait ( 0 0$2 ) ;
9183: LD_INT 70
9185: PPUSH
9186: CALL_OW 67
// if Kirilenkova then
9190: LD_EXP 35
9194: IFFALSE 9208
// Say ( Kirilenkova , D3-Kir-1 ) ;
9196: LD_EXP 35
9200: PPUSH
9201: LD_STRING D3-Kir-1
9203: PPUSH
9204: CALL_OW 88
// gossudarov_arrive := true ;
9208: LD_ADDR_EXP 4
9212: PUSH
9213: LD_INT 1
9215: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9216: LD_INT 35
9218: PPUSH
9219: CALL_OW 67
// until ru_lab_builded ;
9223: LD_EXP 5
9227: IFFALSE 9216
// DialogueOn ;
9229: CALL_OW 6
// if Kirilenkova then
9233: LD_EXP 35
9237: IFFALSE 9253
// Say ( Kirilenkova , D3a-Kir-1 ) else
9239: LD_EXP 35
9243: PPUSH
9244: LD_STRING D3a-Kir-1
9246: PPUSH
9247: CALL_OW 88
9251: GO 9275
// begin un := SciRu ;
9253: LD_ADDR_VAR 0 4
9257: PUSH
9258: CALL 14789 0 0
9262: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
9263: LD_VAR 0 4
9267: PPUSH
9268: LD_STRING D3a-Sci1-1
9270: PPUSH
9271: CALL_OW 88
// end ; if Kirilenkova or un then
9275: LD_EXP 35
9279: PUSH
9280: LD_VAR 0 4
9284: OR
9285: IFFALSE 9299
// Say ( JMM , D3a-JMM-1 ) ;
9287: LD_EXP 16
9291: PPUSH
9292: LD_STRING D3a-JMM-1
9294: PPUSH
9295: CALL_OW 88
// DialogueOff ;
9299: CALL_OW 7
// end ;
9303: LD_VAR 0 1
9307: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
9308: LD_EXP 4
9312: PUSH
9313: LD_INT 22
9315: PUSH
9316: LD_INT 7
9318: PUSH
9319: EMPTY
9320: LIST
9321: LIST
9322: PUSH
9323: LD_INT 2
9325: PUSH
9326: LD_INT 25
9328: PUSH
9329: LD_INT 1
9331: PUSH
9332: EMPTY
9333: LIST
9334: LIST
9335: PUSH
9336: LD_INT 25
9338: PUSH
9339: LD_INT 2
9341: PUSH
9342: EMPTY
9343: LIST
9344: LIST
9345: PUSH
9346: LD_INT 25
9348: PUSH
9349: LD_INT 3
9351: PUSH
9352: EMPTY
9353: LIST
9354: LIST
9355: PUSH
9356: LD_INT 25
9358: PUSH
9359: LD_INT 4
9361: PUSH
9362: EMPTY
9363: LIST
9364: LIST
9365: PUSH
9366: LD_INT 25
9368: PUSH
9369: LD_INT 5
9371: PUSH
9372: EMPTY
9373: LIST
9374: LIST
9375: PUSH
9376: LD_INT 25
9378: PUSH
9379: LD_INT 8
9381: PUSH
9382: EMPTY
9383: LIST
9384: LIST
9385: PUSH
9386: LD_INT 25
9388: PUSH
9389: LD_INT 9
9391: PUSH
9392: EMPTY
9393: LIST
9394: LIST
9395: PUSH
9396: EMPTY
9397: LIST
9398: LIST
9399: LIST
9400: LIST
9401: LIST
9402: LIST
9403: LIST
9404: LIST
9405: PUSH
9406: EMPTY
9407: LIST
9408: LIST
9409: PPUSH
9410: CALL_OW 69
9414: PUSH
9415: LD_INT 7
9417: LESS
9418: AND
9419: IFFALSE 9431
9421: GO 9423
9423: DISABLE
// YouLost ( TooMany ) ;
9424: LD_STRING TooMany
9426: PPUSH
9427: CALL_OW 104
9431: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
9432: LD_EXP 34
9436: PPUSH
9437: CALL_OW 255
9441: PUSH
9442: LD_INT 7
9444: EQUAL
9445: IFFALSE 9662
9447: GO 9449
9449: DISABLE
9450: LD_INT 0
9452: PPUSH
9453: PPUSH
9454: PPUSH
// begin uc_side := 3 ;
9455: LD_ADDR_OWVAR 20
9459: PUSH
9460: LD_INT 3
9462: ST_TO_ADDR
// uc_nation := 3 ;
9463: LD_ADDR_OWVAR 21
9467: PUSH
9468: LD_INT 3
9470: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
9471: LD_INT 21
9473: PPUSH
9474: LD_INT 3
9476: PPUSH
9477: LD_INT 3
9479: PPUSH
9480: LD_INT 42
9482: PPUSH
9483: LD_INT 100
9485: PPUSH
9486: CALL 21275 0 5
// un := CreateVehicle ;
9490: LD_ADDR_VAR 0 3
9494: PUSH
9495: CALL_OW 45
9499: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
9500: LD_VAR 0 3
9504: PPUSH
9505: LD_INT 15
9507: PPUSH
9508: LD_INT 0
9510: PPUSH
9511: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
9515: LD_VAR 0 3
9519: PPUSH
9520: LD_INT 67
9522: PPUSH
9523: LD_INT 45
9525: PPUSH
9526: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
9530: LD_VAR 0 3
9534: PPUSH
9535: LD_INT 70
9537: PPUSH
9538: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
9542: LD_VAR 0 3
9546: PPUSH
9547: LD_INT 69
9549: PPUSH
9550: LD_INT 18
9552: PPUSH
9553: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
9557: LD_VAR 0 3
9561: PPUSH
9562: LD_INT 60
9564: PPUSH
9565: LD_INT 3
9567: PPUSH
9568: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
9572: LD_INT 35
9574: PPUSH
9575: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
9579: LD_VAR 0 3
9583: PPUSH
9584: CALL_OW 302
9588: NOT
9589: PUSH
9590: LD_VAR 0 3
9594: PPUSH
9595: LD_INT 17
9597: PPUSH
9598: CALL_OW 308
9602: OR
9603: PUSH
9604: LD_VAR 0 3
9608: PPUSH
9609: LD_INT 60
9611: PPUSH
9612: LD_INT 3
9614: PPUSH
9615: CALL_OW 307
9619: OR
9620: IFFALSE 9572
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
9622: LD_VAR 0 3
9626: PPUSH
9627: LD_INT 17
9629: PPUSH
9630: CALL_OW 308
9634: PUSH
9635: LD_VAR 0 3
9639: PPUSH
9640: LD_INT 60
9642: PPUSH
9643: LD_INT 3
9645: PPUSH
9646: CALL_OW 307
9650: OR
9651: IFFALSE 9662
// RemoveUnit ( un ) ;
9653: LD_VAR 0 3
9657: PPUSH
9658: CALL_OW 64
// end ;
9662: PPOPN 3
9664: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
9665: LD_EXP 4
9669: IFFALSE 9911
9671: GO 9673
9673: DISABLE
9674: LD_INT 0
9676: PPUSH
9677: PPUSH
9678: PPUSH
// begin repeat wait ( 0 0$2 ) ;
9679: LD_INT 70
9681: PPUSH
9682: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
9686: LD_ADDR_VAR 0 3
9690: PUSH
9691: LD_INT 22
9693: PUSH
9694: LD_INT 7
9696: PUSH
9697: EMPTY
9698: LIST
9699: LIST
9700: PUSH
9701: LD_INT 101
9703: PUSH
9704: LD_INT 3
9706: PUSH
9707: EMPTY
9708: LIST
9709: LIST
9710: PUSH
9711: EMPTY
9712: LIST
9713: LIST
9714: PPUSH
9715: CALL_OW 69
9719: ST_TO_ADDR
// until tmp ;
9720: LD_VAR 0 3
9724: IFFALSE 9679
// un := NearestUnitToUnit ( tmp , JMM ) ;
9726: LD_ADDR_VAR 0 2
9730: PUSH
9731: LD_VAR 0 3
9735: PPUSH
9736: LD_EXP 16
9740: PPUSH
9741: CALL_OW 74
9745: ST_TO_ADDR
// player_spotted := true ;
9746: LD_ADDR_EXP 6
9750: PUSH
9751: LD_INT 1
9753: ST_TO_ADDR
// tmp := SciRu ;
9754: LD_ADDR_VAR 0 3
9758: PUSH
9759: CALL 14789 0 0
9763: ST_TO_ADDR
// if not tmp then
9764: LD_VAR 0 3
9768: NOT
9769: IFFALSE 9781
// tmp := SolRu ;
9771: LD_ADDR_VAR 0 3
9775: PUSH
9776: CALL 14936 0 0
9780: ST_TO_ADDR
// DialogueOn ;
9781: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
9785: LD_VAR 0 2
9789: PPUSH
9790: CALL_OW 250
9794: PPUSH
9795: LD_VAR 0 2
9799: PPUSH
9800: CALL_OW 251
9804: PPUSH
9805: LD_INT 7
9807: PPUSH
9808: LD_INT 8
9810: NEG
9811: PPUSH
9812: CALL_OW 330
// CenterNowOnUnits ( un ) ;
9816: LD_VAR 0 2
9820: PPUSH
9821: CALL_OW 87
// if tmp then
9825: LD_VAR 0 3
9829: IFFALSE 9843
// Say ( tmp , D4-RSci1-1 ) ;
9831: LD_VAR 0 3
9835: PPUSH
9836: LD_STRING D4-RSci1-1
9838: PPUSH
9839: CALL_OW 88
// if Gossudarov then
9843: LD_EXP 34
9847: IFFALSE 9873
// begin Say ( Gossudarov , D4-Gos-1 ) ;
9849: LD_EXP 34
9853: PPUSH
9854: LD_STRING D4-Gos-1
9856: PPUSH
9857: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
9861: LD_EXP 16
9865: PPUSH
9866: LD_STRING D4-JMM-1
9868: PPUSH
9869: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
9873: LD_VAR 0 2
9877: PPUSH
9878: CALL_OW 250
9882: PPUSH
9883: LD_VAR 0 2
9887: PPUSH
9888: CALL_OW 251
9892: PPUSH
9893: LD_INT 7
9895: PPUSH
9896: CALL_OW 331
// DialogueOff ;
9900: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
9904: LD_STRING M5
9906: PPUSH
9907: CALL_OW 337
// end ;
9911: PPOPN 3
9913: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
9914: LD_EXP 6
9918: IFFALSE 10511
9920: GO 9922
9922: DISABLE
9923: LD_INT 0
9925: PPUSH
9926: PPUSH
9927: PPUSH
// begin PrepareBelkov ;
9928: CALL 2248 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
9932: LD_EXP 49
9936: PPUSH
9937: LD_INT 118
9939: PPUSH
9940: LD_INT 106
9942: PPUSH
9943: CALL_OW 111
// AddComHold ( Belkov ) ;
9947: LD_EXP 49
9951: PPUSH
9952: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
9956: LD_INT 35
9958: PPUSH
9959: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
9963: LD_EXP 49
9967: PPUSH
9968: LD_INT 118
9970: PPUSH
9971: LD_INT 106
9973: PPUSH
9974: CALL_OW 307
9978: IFFALSE 9956
// ChangeSideFog ( 4 , 7 ) ;
9980: LD_INT 4
9982: PPUSH
9983: LD_INT 7
9985: PPUSH
9986: CALL_OW 343
// if IsOk ( Belkov ) then
9990: LD_EXP 49
9994: PPUSH
9995: CALL_OW 302
9999: IFFALSE 10083
// begin InGameOn ;
10001: CALL_OW 8
// DialogueOn ;
10005: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
10009: LD_EXP 49
10013: PPUSH
10014: LD_STRING D5-Bel-1
10016: PPUSH
10017: CALL_OW 94
// if Gossudarov then
10021: LD_EXP 34
10025: IFFALSE 10075
// begin Say ( Gossudarov , D5-Gos-1 ) ;
10027: LD_EXP 34
10031: PPUSH
10032: LD_STRING D5-Gos-1
10034: PPUSH
10035: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
10039: LD_EXP 16
10043: PPUSH
10044: LD_STRING D5-JMM-1
10046: PPUSH
10047: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
10051: LD_EXP 34
10055: PPUSH
10056: LD_STRING D5-Gos-2
10058: PPUSH
10059: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
10063: LD_EXP 16
10067: PPUSH
10068: LD_STRING D5-JMM-2
10070: PPUSH
10071: CALL_OW 88
// end ; DialogueOff ;
10075: CALL_OW 7
// InGameOff ;
10079: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
10083: LD_STRING QSaveBelkov
10085: PPUSH
10086: CALL_OW 97
10090: PUSH
10091: LD_INT 1
10093: DOUBLE
10094: EQUAL
10095: IFTRUE 10099
10097: GO 10149
10099: POP
// begin DialogueOn ;
10100: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
10104: LD_EXP 16
10108: PPUSH
10109: LD_STRING D5a-JMM-1
10111: PPUSH
10112: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
10116: LD_EXP 49
10120: PPUSH
10121: LD_STRING D5a-Bel-1
10123: PPUSH
10124: CALL_OW 94
// DialogueOff ;
10128: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
10132: LD_EXP 49
10136: PPUSH
10137: LD_INT 83
10139: PPUSH
10140: LD_INT 49
10142: PPUSH
10143: CALL_OW 111
// end ; 2 :
10147: GO 10182
10149: LD_INT 2
10151: DOUBLE
10152: EQUAL
10153: IFTRUE 10157
10155: GO 10181
10157: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
10158: LD_EXP 16
10162: PPUSH
10163: LD_STRING D5a-JMM-2
10165: PPUSH
10166: CALL_OW 88
// ComHold ( Belkov ) ;
10170: LD_EXP 49
10174: PPUSH
10175: CALL_OW 140
// end ; end ;
10179: GO 10182
10181: POP
// time := 0 0$00 ;
10182: LD_ADDR_VAR 0 1
10186: PUSH
10187: LD_INT 0
10189: ST_TO_ADDR
// vehSpawned := false ;
10190: LD_ADDR_VAR 0 3
10194: PUSH
10195: LD_INT 0
10197: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10198: LD_INT 35
10200: PPUSH
10201: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
10205: LD_VAR 0 1
10209: PUSH
10210: LD_INT 350
10212: PUSH
10213: LD_INT 175
10215: PUSH
10216: LD_INT 105
10218: PUSH
10219: LD_INT 70
10221: PUSH
10222: EMPTY
10223: LIST
10224: LIST
10225: LIST
10226: LIST
10227: PUSH
10228: LD_OWVAR 67
10232: ARRAY
10233: GREATEREQUAL
10234: PUSH
10235: LD_VAR 0 3
10239: NOT
10240: AND
10241: IFFALSE 10331
// begin vehSpawned := true ;
10243: LD_ADDR_VAR 0 3
10247: PUSH
10248: LD_INT 1
10250: ST_TO_ADDR
// uc_side := 3 ;
10251: LD_ADDR_OWVAR 20
10255: PUSH
10256: LD_INT 3
10258: ST_TO_ADDR
// uc_nation := 3 ;
10259: LD_ADDR_OWVAR 21
10263: PUSH
10264: LD_INT 3
10266: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
10267: LD_INT 22
10269: PPUSH
10270: LD_INT 3
10272: PPUSH
10273: LD_INT 3
10275: PPUSH
10276: LD_INT 43
10278: PPUSH
10279: LD_INT 100
10281: PPUSH
10282: CALL 21275 0 5
// veh := CreateVehicle ;
10286: LD_ADDR_VAR 0 2
10290: PUSH
10291: CALL_OW 45
10295: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
10296: LD_VAR 0 2
10300: PPUSH
10301: LD_INT 130
10303: PPUSH
10304: LD_INT 131
10306: PPUSH
10307: LD_INT 0
10309: PPUSH
10310: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
10314: LD_VAR 0 2
10318: PPUSH
10319: LD_INT 100
10321: PPUSH
10322: LD_INT 82
10324: PPUSH
10325: CALL_OW 114
// end else
10329: GO 10345
// time := time + 0 0$1 ;
10331: LD_ADDR_VAR 0 1
10335: PUSH
10336: LD_VAR 0 1
10340: PUSH
10341: LD_INT 35
10343: PLUS
10344: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
10345: LD_EXP 49
10349: PPUSH
10350: CALL_OW 301
10354: PUSH
10355: LD_EXP 49
10359: PPUSH
10360: CALL_OW 255
10364: PUSH
10365: LD_INT 4
10367: EQUAL
10368: AND
10369: PUSH
10370: LD_INT 22
10372: PUSH
10373: LD_INT 7
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: PPUSH
10380: CALL_OW 69
10384: PPUSH
10385: LD_EXP 49
10389: PPUSH
10390: CALL_OW 74
10394: PPUSH
10395: LD_EXP 49
10399: PPUSH
10400: CALL_OW 296
10404: PUSH
10405: LD_INT 10
10407: LESS
10408: OR
10409: IFFALSE 10198
// if IsDead ( Belkov ) then
10411: LD_EXP 49
10415: PPUSH
10416: CALL_OW 301
10420: IFFALSE 10445
// begin CenterNowOnUnits ( Belkov ) ;
10422: LD_EXP 49
10426: PPUSH
10427: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
10431: LD_EXP 16
10435: PPUSH
10436: LD_STRING D5a-JMM-2a
10438: PPUSH
10439: CALL_OW 88
// exit ;
10443: GO 10511
// end ; if See ( 7 , Belkov ) then
10445: LD_INT 7
10447: PPUSH
10448: LD_EXP 49
10452: PPUSH
10453: CALL_OW 292
10457: IFFALSE 10471
// SetSide ( Belkov , 7 ) ;
10459: LD_EXP 49
10463: PPUSH
10464: LD_INT 7
10466: PPUSH
10467: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
10471: LD_INT 35
10473: PPUSH
10474: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
10478: LD_EXP 49
10482: PPUSH
10483: LD_INT 66
10485: PPUSH
10486: LD_INT 45
10488: PPUSH
10489: CALL_OW 297
10493: PUSH
10494: LD_INT 30
10496: LESS
10497: IFFALSE 10471
// Say ( Belkov , D6-Bel-1 ) ;
10499: LD_EXP 49
10503: PPUSH
10504: LD_STRING D6-Bel-1
10506: PPUSH
10507: CALL_OW 88
// end ;
10511: PPOPN 3
10513: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
10514: LD_EXP 49
10518: PPUSH
10519: CALL_OW 302
10523: PUSH
10524: LD_EXP 49
10528: PPUSH
10529: CALL_OW 504
10533: PUSH
10534: LD_INT 2
10536: PUSH
10537: LD_INT 34
10539: PUSH
10540: LD_INT 47
10542: PUSH
10543: EMPTY
10544: LIST
10545: LIST
10546: PUSH
10547: LD_INT 34
10549: PUSH
10550: LD_INT 45
10552: PUSH
10553: EMPTY
10554: LIST
10555: LIST
10556: PUSH
10557: EMPTY
10558: LIST
10559: LIST
10560: LIST
10561: PPUSH
10562: CALL_OW 69
10566: IN
10567: AND
10568: IFFALSE 10585
10570: GO 10572
10572: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
10573: LD_EXP 49
10577: PPUSH
10578: LD_STRING D7-Bel-1
10580: PPUSH
10581: CALL_OW 88
10585: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
10586: LD_INT 22
10588: PUSH
10589: LD_INT 7
10591: PUSH
10592: EMPTY
10593: LIST
10594: LIST
10595: PUSH
10596: LD_INT 101
10598: PUSH
10599: LD_INT 2
10601: PUSH
10602: EMPTY
10603: LIST
10604: LIST
10605: PUSH
10606: EMPTY
10607: LIST
10608: LIST
10609: PPUSH
10610: CALL_OW 69
10614: PUSH
10615: LD_EXP 8
10619: NOT
10620: AND
10621: PUSH
10622: LD_EXP 48
10626: PPUSH
10627: CALL_OW 305
10631: NOT
10632: AND
10633: IFFALSE 11118
10635: GO 10637
10637: DISABLE
10638: LD_INT 0
10640: PPUSH
// begin ar_base_spotted := true ;
10641: LD_ADDR_EXP 8
10645: PUSH
10646: LD_INT 1
10648: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
10649: LD_ADDR_VAR 0 1
10653: PUSH
10654: LD_INT 22
10656: PUSH
10657: LD_INT 2
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: PUSH
10664: LD_INT 21
10666: PUSH
10667: LD_INT 3
10669: PUSH
10670: EMPTY
10671: LIST
10672: LIST
10673: PUSH
10674: EMPTY
10675: LIST
10676: LIST
10677: PPUSH
10678: CALL_OW 69
10682: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
10683: LD_ADDR_VAR 0 1
10687: PUSH
10688: LD_VAR 0 1
10692: PPUSH
10693: LD_EXP 16
10697: PPUSH
10698: CALL_OW 74
10702: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
10703: LD_INT 7
10705: PPUSH
10706: LD_INT 3
10708: PPUSH
10709: CALL_OW 332
// DialogueOn ;
10713: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
10717: LD_VAR 0 1
10721: PPUSH
10722: CALL_OW 250
10726: PPUSH
10727: LD_VAR 0 1
10731: PPUSH
10732: CALL_OW 251
10736: PPUSH
10737: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
10741: LD_ADDR_VAR 0 1
10745: PUSH
10746: LD_INT 22
10748: PUSH
10749: LD_INT 7
10751: PUSH
10752: EMPTY
10753: LIST
10754: LIST
10755: PUSH
10756: LD_INT 23
10758: PUSH
10759: LD_INT 1
10761: PUSH
10762: EMPTY
10763: LIST
10764: LIST
10765: PUSH
10766: LD_INT 26
10768: PUSH
10769: LD_INT 1
10771: PUSH
10772: EMPTY
10773: LIST
10774: LIST
10775: PUSH
10776: EMPTY
10777: LIST
10778: LIST
10779: LIST
10780: PPUSH
10781: CALL_OW 69
10785: PUSH
10786: LD_EXP 16
10790: PUSH
10791: LD_EXP 20
10795: PUSH
10796: LD_EXP 21
10800: PUSH
10801: LD_EXP 28
10805: PUSH
10806: LD_EXP 17
10810: PUSH
10811: LD_EXP 26
10815: PUSH
10816: LD_EXP 22
10820: PUSH
10821: LD_EXP 24
10825: PUSH
10826: EMPTY
10827: LIST
10828: LIST
10829: LIST
10830: LIST
10831: LIST
10832: LIST
10833: LIST
10834: LIST
10835: DIFF
10836: ST_TO_ADDR
// if not tmp then
10837: LD_VAR 0 1
10841: NOT
10842: IFFALSE 10916
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
10844: LD_ADDR_VAR 0 1
10848: PUSH
10849: LD_INT 22
10851: PUSH
10852: LD_INT 7
10854: PUSH
10855: EMPTY
10856: LIST
10857: LIST
10858: PUSH
10859: LD_INT 23
10861: PUSH
10862: LD_INT 1
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: PUSH
10869: LD_INT 26
10871: PUSH
10872: LD_INT 2
10874: PUSH
10875: EMPTY
10876: LIST
10877: LIST
10878: PUSH
10879: EMPTY
10880: LIST
10881: LIST
10882: LIST
10883: PPUSH
10884: CALL_OW 69
10888: PUSH
10889: LD_EXP 31
10893: PUSH
10894: LD_EXP 18
10898: PUSH
10899: LD_EXP 29
10903: PUSH
10904: LD_EXP 30
10908: PUSH
10909: EMPTY
10910: LIST
10911: LIST
10912: LIST
10913: LIST
10914: DIFF
10915: ST_TO_ADDR
// if tmp then
10916: LD_VAR 0 1
10920: IFFALSE 10991
// case GetSex ( tmp [ 1 ] ) of sex_male :
10922: LD_VAR 0 1
10926: PUSH
10927: LD_INT 1
10929: ARRAY
10930: PPUSH
10931: CALL_OW 258
10935: PUSH
10936: LD_INT 1
10938: DOUBLE
10939: EQUAL
10940: IFTRUE 10944
10942: GO 10963
10944: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
10945: LD_VAR 0 1
10949: PUSH
10950: LD_INT 1
10952: ARRAY
10953: PPUSH
10954: LD_STRING D9-Sol1-1
10956: PPUSH
10957: CALL_OW 88
10961: GO 10991
10963: LD_INT 2
10965: DOUBLE
10966: EQUAL
10967: IFTRUE 10971
10969: GO 10990
10971: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
10972: LD_VAR 0 1
10976: PUSH
10977: LD_INT 1
10979: ARRAY
10980: PPUSH
10981: LD_STRING D9-FSol1-1
10983: PPUSH
10984: CALL_OW 88
10988: GO 10991
10990: POP
// if Frank then
10991: LD_EXP 28
10995: IFFALSE 11099
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
10997: LD_EXP 58
11001: PPUSH
11002: CALL_OW 250
11006: PPUSH
11007: LD_EXP 58
11011: PPUSH
11012: CALL_OW 251
11016: PPUSH
11017: LD_INT 7
11019: PPUSH
11020: LD_INT 8
11022: PPUSH
11023: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
11027: LD_EXP 58
11031: PPUSH
11032: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
11036: LD_EXP 28
11040: PPUSH
11041: LD_STRING D9-Frank-1
11043: PPUSH
11044: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
11048: LD_EXP 16
11052: PPUSH
11053: LD_STRING D9-JMM-1
11055: PPUSH
11056: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
11060: LD_EXP 28
11064: PPUSH
11065: LD_STRING D9-Frank-2
11067: PPUSH
11068: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
11072: LD_EXP 58
11076: PPUSH
11077: CALL_OW 250
11081: PPUSH
11082: LD_EXP 58
11086: PPUSH
11087: CALL_OW 251
11091: PPUSH
11092: LD_INT 7
11094: PPUSH
11095: CALL_OW 331
// end ; DialogueOff ;
11099: CALL_OW 7
// wait ( 1 1$00 ) ;
11103: LD_INT 2100
11105: PPUSH
11106: CALL_OW 67
// ar_active_attack := true ;
11110: LD_ADDR_EXP 9
11114: PUSH
11115: LD_INT 1
11117: ST_TO_ADDR
// end ;
11118: PPOPN 1
11120: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
11121: LD_EXP 7
11125: PUSH
11126: LD_OWVAR 1
11130: PUSH
11131: LD_INT 42000
11133: GREATEREQUAL
11134: OR
11135: IFFALSE 12187
11137: GO 11139
11139: DISABLE
11140: LD_INT 0
11142: PPUSH
11143: PPUSH
// begin selected_option := 1 ;
11144: LD_ADDR_VAR 0 2
11148: PUSH
11149: LD_INT 1
11151: ST_TO_ADDR
// wait ( 5 5$00 ) ;
11152: LD_INT 10500
11154: PPUSH
11155: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11159: LD_INT 35
11161: PPUSH
11162: CALL_OW 67
// until not ru_attackers ;
11166: LD_EXP 54
11170: NOT
11171: IFFALSE 11159
// PrepareBurlak ;
11173: CALL 2360 0 0
// repeat wait ( 0 0$2 ) ;
11177: LD_INT 70
11179: PPUSH
11180: CALL_OW 67
// until not HasTask ( Burlak ) ;
11184: LD_EXP 48
11188: PPUSH
11189: CALL_OW 314
11193: NOT
11194: IFFALSE 11177
// InGameOn ;
11196: CALL_OW 8
// DialogueOn ;
11200: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
11204: LD_EXP 51
11208: PPUSH
11209: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
11213: LD_EXP 48
11217: PPUSH
11218: LD_STRING D10-Bur-1
11220: PPUSH
11221: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
11225: LD_EXP 49
11229: PUSH
11230: LD_EXP 49
11234: PPUSH
11235: CALL_OW 255
11239: PUSH
11240: LD_INT 7
11242: EQUAL
11243: AND
11244: IFFALSE 11258
// Say ( Belkov , D10-Bel-1 ) ;
11246: LD_EXP 49
11250: PPUSH
11251: LD_STRING D10-Bel-1
11253: PPUSH
11254: CALL_OW 88
// if Gossudarov then
11258: LD_EXP 34
11262: IFFALSE 11276
// Say ( Gossudarov , D10-Gos-1 ) ;
11264: LD_EXP 34
11268: PPUSH
11269: LD_STRING D10-Gos-1
11271: PPUSH
11272: CALL_OW 88
// if Kirilenkova then
11276: LD_EXP 35
11280: IFFALSE 11294
// Say ( Kirilenkova , D10-Kir-1 ) ;
11282: LD_EXP 35
11286: PPUSH
11287: LD_STRING D10-Kir-1
11289: PPUSH
11290: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
11294: CALL 14936 0 0
11298: PPUSH
11299: LD_STRING D10-RSol1-1
11301: PPUSH
11302: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
11306: LD_EXP 48
11310: PPUSH
11311: LD_STRING D10-Bur-2
11313: PPUSH
11314: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
11318: LD_EXP 16
11322: PPUSH
11323: LD_STRING D10-JMM-2
11325: PPUSH
11326: CALL_OW 88
// if Kirilenkova then
11330: LD_EXP 35
11334: IFFALSE 11350
// Say ( Kirilenkova , D10-Kir-2 ) else
11336: LD_EXP 35
11340: PPUSH
11341: LD_STRING D10-Kir-2
11343: PPUSH
11344: CALL_OW 88
11348: GO 11362
// Say ( SolRu , D10-RSol1-2 ) ;
11350: CALL 14936 0 0
11354: PPUSH
11355: LD_STRING D10-RSol1-2
11357: PPUSH
11358: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
11362: LD_EXP 16
11366: PPUSH
11367: LD_STRING D10-JMM-3
11369: PPUSH
11370: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
11374: LD_EXP 48
11378: PPUSH
11379: LD_STRING D10-Bur-3
11381: PPUSH
11382: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
11386: LD_EXP 16
11390: PPUSH
11391: LD_STRING D10-JMM-4
11393: PPUSH
11394: CALL_OW 88
// DialogueOff ;
11398: CALL_OW 7
// InGameOff ;
11402: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
11406: LD_STRING M2
11408: PPUSH
11409: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
11413: LD_INT 35
11415: PPUSH
11416: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
11420: LD_INT 22
11422: PUSH
11423: LD_INT 7
11425: PUSH
11426: EMPTY
11427: LIST
11428: LIST
11429: PUSH
11430: LD_INT 91
11432: PUSH
11433: LD_EXP 48
11437: PUSH
11438: LD_INT 8
11440: PUSH
11441: EMPTY
11442: LIST
11443: LIST
11444: LIST
11445: PUSH
11446: EMPTY
11447: LIST
11448: LIST
11449: PPUSH
11450: CALL_OW 69
11454: IFFALSE 11413
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
11456: LD_ADDR_VAR 0 1
11460: PUSH
11461: LD_INT 22
11463: PUSH
11464: LD_INT 4
11466: PUSH
11467: EMPTY
11468: LIST
11469: LIST
11470: PPUSH
11471: CALL_OW 69
11475: PUSH
11476: FOR_IN
11477: IFFALSE 11493
// SetSide ( i , 7 ) ;
11479: LD_VAR 0 1
11483: PPUSH
11484: LD_INT 7
11486: PPUSH
11487: CALL_OW 235
11491: GO 11476
11493: POP
11494: POP
// ChangeMissionObjectives ( M3 ) ;
11495: LD_STRING M3
11497: PPUSH
11498: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
11502: LD_INT 35
11504: PPUSH
11505: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
11509: LD_EXP 16
11513: PPUSH
11514: LD_EXP 48
11518: PPUSH
11519: CALL_OW 296
11523: PUSH
11524: LD_INT 8
11526: LESS
11527: IFFALSE 11502
// ComTurnUnit ( JMM , Burlak ) ;
11529: LD_EXP 16
11533: PPUSH
11534: LD_EXP 48
11538: PPUSH
11539: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
11543: LD_EXP 48
11547: PPUSH
11548: LD_EXP 16
11552: PPUSH
11553: CALL_OW 119
// wait ( 0 0$0.3 ) ;
11557: LD_INT 10
11559: PPUSH
11560: CALL_OW 67
// DialogueOn ;
11564: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
11568: LD_EXP 16
11572: PPUSH
11573: LD_STRING D11-JMM-1
11575: PPUSH
11576: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
11580: LD_EXP 48
11584: PPUSH
11585: LD_STRING D11-Bur-1
11587: PPUSH
11588: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
11592: LD_EXP 16
11596: PPUSH
11597: LD_STRING D11-JMM-2
11599: PPUSH
11600: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
11604: LD_EXP 48
11608: PPUSH
11609: LD_STRING D11-Bur-2
11611: PPUSH
11612: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
11616: LD_EXP 16
11620: PPUSH
11621: LD_STRING D11-JMM-3
11623: PPUSH
11624: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
11628: LD_EXP 48
11632: PPUSH
11633: LD_STRING D11-Bur-3
11635: PPUSH
11636: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
11640: LD_EXP 16
11644: PPUSH
11645: LD_STRING D11-JMM-4
11647: PPUSH
11648: CALL_OW 88
// if ar_base_spotted then
11652: LD_EXP 8
11656: IFFALSE 11672
// Say ( Burlak , D12-Bur-1 ) else
11658: LD_EXP 48
11662: PPUSH
11663: LD_STRING D12-Bur-1
11665: PPUSH
11666: CALL_OW 88
11670: GO 11711
// begin RevealFogArea ( 7 , area_base_arabian ) ;
11672: LD_INT 7
11674: PPUSH
11675: LD_INT 3
11677: PPUSH
11678: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
11682: LD_INT 127
11684: PPUSH
11685: LD_INT 45
11687: PPUSH
11688: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
11692: LD_EXP 48
11696: PPUSH
11697: LD_STRING D12-Bur-1a
11699: PPUSH
11700: CALL_OW 88
// dwait ( 0 0$2 ) ;
11704: LD_INT 70
11706: PPUSH
11707: CALL_OW 68
// end ; if not IsOk ( Abdul ) then
11711: LD_EXP 57
11715: PPUSH
11716: CALL_OW 302
11720: NOT
11721: IFFALSE 11729
// begin DialogueOff ;
11723: CALL_OW 7
// exit ;
11727: GO 12187
// end ; Say ( Burlak , D12-Bur-1b ) ;
11729: LD_EXP 48
11733: PPUSH
11734: LD_STRING D12-Bur-1b
11736: PPUSH
11737: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
11741: LD_EXP 16
11745: PPUSH
11746: LD_STRING D12-JMM-1
11748: PPUSH
11749: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
11753: LD_EXP 48
11757: PPUSH
11758: LD_STRING D12-Bur-2
11760: PPUSH
11761: CALL_OW 88
// if Roth then
11765: LD_EXP 17
11769: IFFALSE 11785
// Say ( Roth , D12-Roth-2 ) else
11771: LD_EXP 17
11775: PPUSH
11776: LD_STRING D12-Roth-2
11778: PPUSH
11779: CALL_OW 88
11783: GO 11797
// Say ( SciRu , D12-RSci1-2 ) ;
11785: CALL 14789 0 0
11789: PPUSH
11790: LD_STRING D12-RSci1-2
11792: PPUSH
11793: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
11797: LD_EXP 16
11801: PPUSH
11802: LD_STRING D12-JMM-2
11804: PPUSH
11805: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
11809: LD_EXP 48
11813: PPUSH
11814: LD_STRING D12-Bur-3
11816: PPUSH
11817: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
11821: LD_EXP 16
11825: PPUSH
11826: LD_STRING D12-JMM-3
11828: PPUSH
11829: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
11833: LD_EXP 48
11837: PPUSH
11838: LD_STRING D12-Bur-4
11840: PPUSH
11841: CALL_OW 88
// case Query ( QBase ) of 1 :
11845: LD_STRING QBase
11847: PPUSH
11848: CALL_OW 97
11852: PUSH
11853: LD_INT 1
11855: DOUBLE
11856: EQUAL
11857: IFTRUE 11861
11859: GO 11979
11861: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
11862: LD_EXP 16
11866: PPUSH
11867: LD_STRING D13a-JMM-1
11869: PPUSH
11870: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
11874: LD_EXP 48
11878: PPUSH
11879: LD_STRING D13a-Bur-1
11881: PPUSH
11882: CALL_OW 88
// if Roth then
11886: LD_EXP 17
11890: IFFALSE 11906
// Say ( Roth , D13a-Roth-1 ) else
11892: LD_EXP 17
11896: PPUSH
11897: LD_STRING D13a-Roth-1
11899: PPUSH
11900: CALL_OW 88
11904: GO 11918
// Say ( SciRu , D13a-RSci1-1 ) ;
11906: CALL 14789 0 0
11910: PPUSH
11911: LD_STRING D13a-RSci1-1
11913: PPUSH
11914: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
11918: LD_EXP 16
11922: PPUSH
11923: LD_STRING D13a-JMM-2
11925: PPUSH
11926: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
11930: LD_STRING QBaseAgain
11932: PPUSH
11933: CALL_OW 97
11937: PUSH
11938: LD_INT 1
11940: DOUBLE
11941: EQUAL
11942: IFTRUE 11946
11944: GO 11957
11946: POP
// selected_option := 2 ; 2 :
11947: LD_ADDR_VAR 0 2
11951: PUSH
11952: LD_INT 2
11954: ST_TO_ADDR
11955: GO 11977
11957: LD_INT 2
11959: DOUBLE
11960: EQUAL
11961: IFTRUE 11965
11963: GO 11976
11965: POP
// selected_option := 3 ; end ;
11966: LD_ADDR_VAR 0 2
11970: PUSH
11971: LD_INT 3
11973: ST_TO_ADDR
11974: GO 11977
11976: POP
// end ; 2 :
11977: GO 12018
11979: LD_INT 2
11981: DOUBLE
11982: EQUAL
11983: IFTRUE 11987
11985: GO 11998
11987: POP
// selected_option := 2 ; 3 :
11988: LD_ADDR_VAR 0 2
11992: PUSH
11993: LD_INT 2
11995: ST_TO_ADDR
11996: GO 12018
11998: LD_INT 3
12000: DOUBLE
12001: EQUAL
12002: IFTRUE 12006
12004: GO 12017
12006: POP
// selected_option := 3 ; end ;
12007: LD_ADDR_VAR 0 2
12011: PUSH
12012: LD_INT 3
12014: ST_TO_ADDR
12015: GO 12018
12017: POP
// if selected_option = 2 then
12018: LD_VAR 0 2
12022: PUSH
12023: LD_INT 2
12025: EQUAL
12026: IFFALSE 12120
// begin Say ( JMM , D13b-JMM-1 ) ;
12028: LD_EXP 16
12032: PPUSH
12033: LD_STRING D13b-JMM-1
12035: PPUSH
12036: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
12040: LD_EXP 48
12044: PPUSH
12045: LD_STRING D13b-Bur-1
12047: PPUSH
12048: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
12052: LD_EXP 16
12056: PPUSH
12057: LD_STRING D13b-JMM-2
12059: PPUSH
12060: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
12064: LD_EXP 57
12068: PPUSH
12069: LD_STRING D13b-Abd-2
12071: PPUSH
12072: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
12076: LD_EXP 16
12080: PPUSH
12081: LD_STRING D13b-JMM-3
12083: PPUSH
12084: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
12088: LD_EXP 57
12092: PPUSH
12093: LD_STRING D13b-Abd-3
12095: PPUSH
12096: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
12100: LD_EXP 16
12104: PPUSH
12105: LD_STRING D13b-JMM-4
12107: PPUSH
12108: CALL_OW 88
// ar_active_attack := true ;
12112: LD_ADDR_EXP 9
12116: PUSH
12117: LD_INT 1
12119: ST_TO_ADDR
// end ; if selected_option = 3 then
12120: LD_VAR 0 2
12124: PUSH
12125: LD_INT 3
12127: EQUAL
12128: IFFALSE 12154
// begin Say ( JMM , D13c-JMM-1 ) ;
12130: LD_EXP 16
12134: PPUSH
12135: LD_STRING D13c-JMM-1
12137: PPUSH
12138: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
12142: LD_EXP 48
12146: PPUSH
12147: LD_STRING D13c-Bur-1
12149: PPUSH
12150: CALL_OW 88
// end ; DialogueOff ;
12154: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
12158: LD_STRING M4
12160: PPUSH
12161: CALL_OW 337
// if not ar_active_attack then
12165: LD_EXP 9
12169: NOT
12170: IFFALSE 12187
// begin wait ( 6 6$00 ) ;
12172: LD_INT 12600
12174: PPUSH
12175: CALL_OW 67
// ar_active_attack := true ;
12179: LD_ADDR_EXP 9
12183: PUSH
12184: LD_INT 1
12186: ST_TO_ADDR
// end ; end ;
12187: PPOPN 2
12189: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
12190: LD_EXP 48
12194: PPUSH
12195: CALL_OW 305
12199: PUSH
12200: LD_EXP 48
12204: PPUSH
12205: CALL_OW 255
12209: PUSH
12210: LD_INT 7
12212: EQUAL
12213: AND
12214: IFFALSE 12437
12216: GO 12218
12218: DISABLE
12219: LD_INT 0
12221: PPUSH
// begin wait ( 4 4$40 ) ;
12222: LD_INT 9800
12224: PPUSH
12225: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
12229: LD_INT 35
12231: PPUSH
12232: CALL_OW 67
// until not ru_attackers and not FilterAllUnits ( [ [ f_side , 6 ] , [ f_ok ] ] ) ;
12236: LD_EXP 54
12240: NOT
12241: PUSH
12242: LD_INT 22
12244: PUSH
12245: LD_INT 6
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: PUSH
12252: LD_INT 50
12254: PUSH
12255: EMPTY
12256: LIST
12257: PUSH
12258: EMPTY
12259: LIST
12260: LIST
12261: PPUSH
12262: CALL_OW 69
12266: NOT
12267: AND
12268: IFFALSE 12229
// PrepareGnyevko ;
12270: CALL 2304 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
12274: LD_EXP 50
12278: PPUSH
12279: LD_INT 124
12281: PPUSH
12282: LD_INT 118
12284: PPUSH
12285: CALL_OW 111
// AddComHold ( Gnyevko ) ;
12289: LD_EXP 50
12293: PPUSH
12294: CALL_OW 200
// time := 0 0$00 ;
12298: LD_ADDR_VAR 0 1
12302: PUSH
12303: LD_INT 0
12305: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
12306: LD_INT 35
12308: PPUSH
12309: CALL_OW 67
// time := time + 0 0$1 ;
12313: LD_ADDR_VAR 0 1
12317: PUSH
12318: LD_VAR 0 1
12322: PUSH
12323: LD_INT 35
12325: PLUS
12326: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
12327: LD_EXP 50
12331: PPUSH
12332: LD_INT 124
12334: PPUSH
12335: LD_INT 118
12337: PPUSH
12338: CALL_OW 307
12342: PUSH
12343: LD_VAR 0 1
12347: PUSH
12348: LD_INT 1050
12350: GREATEREQUAL
12351: OR
12352: IFFALSE 12306
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
12354: LD_EXP 50
12358: PPUSH
12359: LD_STRING DBelkov-Gny-1
12361: PPUSH
12362: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
12366: LD_EXP 48
12370: PPUSH
12371: LD_STRING DBelkov-Bur-1a
12373: PPUSH
12374: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
12378: LD_INT 35
12380: PPUSH
12381: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
12385: LD_EXP 50
12389: PPUSH
12390: LD_INT 22
12392: PUSH
12393: LD_INT 7
12395: PUSH
12396: EMPTY
12397: LIST
12398: LIST
12399: PPUSH
12400: CALL_OW 69
12404: PPUSH
12405: LD_EXP 50
12409: PPUSH
12410: CALL_OW 74
12414: PPUSH
12415: CALL_OW 296
12419: PUSH
12420: LD_INT 8
12422: LESS
12423: IFFALSE 12378
// SetSide ( Gnyevko , 7 ) ;
12425: LD_EXP 50
12429: PPUSH
12430: LD_INT 7
12432: PPUSH
12433: CALL_OW 235
// end ;
12437: PPOPN 1
12439: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
12440: LD_EXP 48
12444: PPUSH
12445: CALL_OW 255
12449: PUSH
12450: LD_INT 7
12452: EQUAL
12453: IFFALSE 12463
12455: GO 12457
12457: DISABLE
// begin enable ;
12458: ENABLE
// PrepareAmericanAttack ;
12459: CALL 7812 0 0
// end ;
12463: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
12464: LD_INT 22
12466: PUSH
12467: LD_INT 1
12469: PUSH
12470: EMPTY
12471: LIST
12472: LIST
12473: PPUSH
12474: CALL_OW 69
12478: IFFALSE 12662
12480: GO 12482
12482: DISABLE
12483: LD_INT 0
12485: PPUSH
12486: PPUSH
// begin while true do
12487: LD_INT 1
12489: IFFALSE 12546
// begin wait ( 0 0$1 ) ;
12491: LD_INT 35
12493: PPUSH
12494: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
12498: LD_ADDR_VAR 0 2
12502: PUSH
12503: LD_INT 22
12505: PUSH
12506: LD_INT 1
12508: PUSH
12509: EMPTY
12510: LIST
12511: LIST
12512: PPUSH
12513: CALL_OW 69
12517: PPUSH
12518: LD_EXP 16
12522: PPUSH
12523: CALL_OW 74
12527: ST_TO_ADDR
// if See ( 7 , tmp ) then
12528: LD_INT 7
12530: PPUSH
12531: LD_VAR 0 2
12535: PPUSH
12536: CALL_OW 292
12540: IFFALSE 12544
// break ;
12542: GO 12546
// end ;
12544: GO 12487
// DialogueOn ;
12546: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
12550: LD_VAR 0 2
12554: PPUSH
12555: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
12559: LD_VAR 0 2
12563: PPUSH
12564: CALL_OW 250
12568: PPUSH
12569: LD_VAR 0 2
12573: PPUSH
12574: CALL_OW 251
12578: PPUSH
12579: LD_INT 7
12581: PPUSH
12582: LD_INT 8
12584: PPUSH
12585: CALL_OW 330
// if Denis then
12589: LD_EXP 22
12593: IFFALSE 12607
// Say ( Denis , DAmerAttack-Pet-1 ) ;
12595: LD_EXP 22
12599: PPUSH
12600: LD_STRING DAmerAttack-Pet-1
12602: PPUSH
12603: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
12607: LD_EXP 16
12611: PPUSH
12612: LD_STRING DAmerAttack-JMM-1
12614: PPUSH
12615: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
12619: LD_EXP 48
12623: PPUSH
12624: LD_STRING DStop-Bur-1
12626: PPUSH
12627: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
12631: LD_VAR 0 2
12635: PPUSH
12636: CALL_OW 250
12640: PPUSH
12641: LD_VAR 0 2
12645: PPUSH
12646: CALL_OW 251
12650: PPUSH
12651: LD_INT 7
12653: PPUSH
12654: CALL_OW 331
// DialogueOff ;
12658: CALL_OW 7
// end ;
12662: PPOPN 2
12664: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
12665: LD_INT 22
12667: PUSH
12668: LD_INT 3
12670: PUSH
12671: EMPTY
12672: LIST
12673: LIST
12674: PUSH
12675: LD_INT 21
12677: PUSH
12678: LD_INT 1
12680: PUSH
12681: EMPTY
12682: LIST
12683: LIST
12684: PUSH
12685: EMPTY
12686: LIST
12687: LIST
12688: PPUSH
12689: CALL_OW 69
12693: PUSH
12694: LD_INT 0
12696: EQUAL
12697: IFFALSE 12739
12699: GO 12701
12701: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
12702: LD_STRING M5a
12704: PPUSH
12705: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
12709: LD_EXP 16
12713: PPUSH
12714: LD_STRING D8-JMM-1
12716: PPUSH
12717: CALL_OW 88
// if Gossudarov then
12721: LD_EXP 34
12725: IFFALSE 12739
// Say ( Gossudarov , D8-Gos-1 ) ;
12727: LD_EXP 34
12731: PPUSH
12732: LD_STRING D8-Gos-1
12734: PPUSH
12735: CALL_OW 88
// end ;
12739: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
12740: LD_INT 22
12742: PUSH
12743: LD_INT 2
12745: PUSH
12746: EMPTY
12747: LIST
12748: LIST
12749: PUSH
12750: LD_INT 21
12752: PUSH
12753: LD_INT 1
12755: PUSH
12756: EMPTY
12757: LIST
12758: LIST
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PPUSH
12764: CALL_OW 69
12768: PUSH
12769: LD_INT 0
12771: EQUAL
12772: IFFALSE 12822
12774: GO 12776
12776: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
12777: LD_STRING M4c
12779: PPUSH
12780: CALL_OW 337
// if Roth then
12784: LD_EXP 17
12788: IFFALSE 12804
// Say ( Roth , DStop-Roth-1 ) else
12790: LD_EXP 17
12794: PPUSH
12795: LD_STRING DStop-Roth-1
12797: PPUSH
12798: CALL_OW 88
12802: GO 12822
// if Gossudarov then
12804: LD_EXP 34
12808: IFFALSE 12822
// Say ( Gossudarov , D8-Gos-1a ) ;
12810: LD_EXP 34
12814: PPUSH
12815: LD_STRING D8-Gos-1a
12817: PPUSH
12818: CALL_OW 88
// end ;
12822: END
// every 1 1$00 trigger FindArtifact ( 3 ) and first_powell_attack do
12823: LD_INT 3
12825: PPUSH
12826: CALL_OW 469
12830: PUSH
12831: LD_EXP 12
12835: AND
12836: IFFALSE 12891
12838: GO 12840
12840: DISABLE
// begin TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
12841: LD_INT 3
12843: PPUSH
12844: CALL_OW 469
12848: PPUSH
12849: CALL 8301 0 1
// if Difficulty > 2 then
12853: LD_OWVAR 67
12857: PUSH
12858: LD_INT 2
12860: GREATER
12861: IFFALSE 12891
// begin wait ( 5 5$00 ) ;
12863: LD_INT 10500
12865: PPUSH
12866: CALL_OW 67
// if FindArtifact ( 3 ) then
12870: LD_INT 3
12872: PPUSH
12873: CALL_OW 469
12877: IFFALSE 12891
// TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
12879: LD_INT 3
12881: PPUSH
12882: CALL_OW 469
12886: PPUSH
12887: CALL 8301 0 1
// end ; end ;
12891: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
12892: LD_INT 7
12894: PPUSH
12895: LD_INT 1
12897: PPUSH
12898: LD_INT 1
12900: PPUSH
12901: CALL 16498 0 3
12905: PUSH
12906: LD_INT 0
12908: EQUAL
12909: PUSH
12910: LD_INT 7
12912: PPUSH
12913: LD_INT 3
12915: PPUSH
12916: LD_INT 1
12918: PPUSH
12919: CALL 16498 0 3
12923: PUSH
12924: LD_INT 0
12926: EQUAL
12927: AND
12928: IFFALSE 12940
12930: GO 12932
12932: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
12933: LD_STRING M1a
12935: PPUSH
12936: CALL_OW 337
// end ;
12940: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , nation_arabian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
12941: LD_INT 22
12943: PUSH
12944: LD_INT 2
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: PUSH
12951: LD_INT 23
12953: PUSH
12954: LD_INT 2
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: PUSH
12961: LD_INT 21
12963: PUSH
12964: LD_INT 1
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: PUSH
12971: EMPTY
12972: LIST
12973: LIST
12974: LIST
12975: PPUSH
12976: CALL_OW 69
12980: PUSH
12981: LD_INT 0
12983: EQUAL
12984: PUSH
12985: LD_INT 22
12987: PUSH
12988: LD_INT 3
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: PUSH
12995: LD_INT 23
12997: PUSH
12998: LD_INT 3
13000: PUSH
13001: EMPTY
13002: LIST
13003: LIST
13004: PUSH
13005: LD_INT 21
13007: PUSH
13008: LD_INT 1
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: PUSH
13015: EMPTY
13016: LIST
13017: LIST
13018: LIST
13019: PPUSH
13020: CALL_OW 69
13024: PUSH
13025: LD_INT 0
13027: EQUAL
13028: AND
13029: PUSH
13030: LD_INT 22
13032: PUSH
13033: LD_INT 1
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: PPUSH
13040: CALL_OW 69
13044: PUSH
13045: LD_INT 0
13047: EQUAL
13048: AND
13049: PUSH
13050: LD_INT 7
13052: PPUSH
13053: LD_INT 1
13055: PPUSH
13056: LD_INT 1
13058: PPUSH
13059: CALL 16498 0 3
13063: PUSH
13064: LD_INT 0
13066: EQUAL
13067: AND
13068: PUSH
13069: LD_INT 7
13071: PPUSH
13072: LD_INT 3
13074: PPUSH
13075: LD_INT 1
13077: PPUSH
13078: CALL 16498 0 3
13082: PUSH
13083: LD_INT 0
13085: EQUAL
13086: AND
13087: PUSH
13088: LD_EXP 48
13092: PPUSH
13093: CALL_OW 255
13097: PUSH
13098: LD_INT 7
13100: EQUAL
13101: AND
13102: PUSH
13103: LD_EXP 48
13107: PPUSH
13108: CALL_OW 302
13112: AND
13113: IFFALSE 14786
13115: GO 13117
13117: DISABLE
13118: LD_INT 0
13120: PPUSH
13121: PPUSH
13122: PPUSH
13123: PPUSH
13124: PPUSH
13125: PPUSH
// begin m1 := false ;
13126: LD_ADDR_VAR 0 4
13130: PUSH
13131: LD_INT 0
13133: ST_TO_ADDR
// m2 := false ;
13134: LD_ADDR_VAR 0 5
13138: PUSH
13139: LD_INT 0
13141: ST_TO_ADDR
// m3 := false ;
13142: LD_ADDR_VAR 0 6
13146: PUSH
13147: LD_INT 0
13149: ST_TO_ADDR
// if tick < 40 40$00 then
13150: LD_OWVAR 1
13154: PUSH
13155: LD_INT 84000
13157: LESS
13158: IFFALSE 13167
// SetAchievement ( ACH_ASPEED_17 ) ;
13160: LD_STRING ACH_ASPEED_17
13162: PPUSH
13163: CALL_OW 543
// wait ( 0 0$5 ) ;
13167: LD_INT 175
13169: PPUSH
13170: CALL_OW 67
// if not masha_killed then
13174: LD_EXP 10
13178: NOT
13179: IFFALSE 13201
// begin m1 := true ;
13181: LD_ADDR_VAR 0 4
13185: PUSH
13186: LD_INT 1
13188: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
13189: LD_STRING Masha
13191: PPUSH
13192: LD_INT 1
13194: PPUSH
13195: CALL_OW 101
// end else
13199: GO 13212
// AddMedal ( Masha , - 1 ) ;
13201: LD_STRING Masha
13203: PPUSH
13204: LD_INT 1
13206: NEG
13207: PPUSH
13208: CALL_OW 101
// if abdul_escaped then
13212: LD_EXP 13
13216: IFFALSE 13231
// AddMedal ( Abdul , - 1 ) else
13218: LD_STRING Abdul
13220: PPUSH
13221: LD_INT 1
13223: NEG
13224: PPUSH
13225: CALL_OW 101
13229: GO 13249
// begin m2 := true ;
13231: LD_ADDR_VAR 0 5
13235: PUSH
13236: LD_INT 1
13238: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
13239: LD_STRING Abdul
13241: PPUSH
13242: LD_INT 1
13244: PPUSH
13245: CALL_OW 101
// end ; if loss_counter = 0 then
13249: LD_EXP 14
13253: PUSH
13254: LD_INT 0
13256: EQUAL
13257: IFFALSE 13279
// begin m3 := true ;
13259: LD_ADDR_VAR 0 6
13263: PUSH
13264: LD_INT 1
13266: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
13267: LD_STRING People
13269: PPUSH
13270: LD_INT 2
13272: PPUSH
13273: CALL_OW 101
// end else
13277: GO 13341
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
13279: LD_EXP 14
13283: PUSH
13284: LD_INT 3
13286: PUSH
13287: LD_INT 2
13289: PUSH
13290: LD_INT 2
13292: PUSH
13293: LD_INT 1
13295: PUSH
13296: EMPTY
13297: LIST
13298: LIST
13299: LIST
13300: LIST
13301: PUSH
13302: LD_OWVAR 67
13306: ARRAY
13307: LESSEQUAL
13308: IFFALSE 13330
// begin AddMedal ( People , 1 ) ;
13310: LD_STRING People
13312: PPUSH
13313: LD_INT 1
13315: PPUSH
13316: CALL_OW 101
// m3 := true ;
13320: LD_ADDR_VAR 0 6
13324: PUSH
13325: LD_INT 1
13327: ST_TO_ADDR
// end else
13328: GO 13341
// AddMedal ( People , - 1 ) ;
13330: LD_STRING People
13332: PPUSH
13333: LD_INT 1
13335: NEG
13336: PPUSH
13337: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
13341: LD_OWVAR 67
13345: PUSH
13346: LD_INT 3
13348: GREATEREQUAL
13349: PUSH
13350: LD_VAR 0 4
13354: AND
13355: PUSH
13356: LD_VAR 0 5
13360: AND
13361: PUSH
13362: LD_VAR 0 6
13366: AND
13367: IFFALSE 13379
// SetAchievementEX ( ACH_AMER , 17 ) ;
13369: LD_STRING ACH_AMER
13371: PPUSH
13372: LD_INT 17
13374: PPUSH
13375: CALL_OW 564
// GiveMedals ( MAIN ) ;
13379: LD_STRING MAIN
13381: PPUSH
13382: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
13386: LD_ADDR_VAR 0 2
13390: PUSH
13391: LD_INT 22
13393: PUSH
13394: LD_INT 7
13396: PUSH
13397: EMPTY
13398: LIST
13399: LIST
13400: PUSH
13401: LD_INT 50
13403: PUSH
13404: EMPTY
13405: LIST
13406: PUSH
13407: LD_INT 2
13409: PUSH
13410: LD_INT 25
13412: PUSH
13413: LD_INT 1
13415: PUSH
13416: EMPTY
13417: LIST
13418: LIST
13419: PUSH
13420: LD_INT 25
13422: PUSH
13423: LD_INT 2
13425: PUSH
13426: EMPTY
13427: LIST
13428: LIST
13429: PUSH
13430: LD_INT 25
13432: PUSH
13433: LD_INT 3
13435: PUSH
13436: EMPTY
13437: LIST
13438: LIST
13439: PUSH
13440: LD_INT 25
13442: PUSH
13443: LD_INT 4
13445: PUSH
13446: EMPTY
13447: LIST
13448: LIST
13449: PUSH
13450: LD_INT 25
13452: PUSH
13453: LD_INT 5
13455: PUSH
13456: EMPTY
13457: LIST
13458: LIST
13459: PUSH
13460: LD_INT 25
13462: PUSH
13463: LD_INT 8
13465: PUSH
13466: EMPTY
13467: LIST
13468: LIST
13469: PUSH
13470: LD_INT 25
13472: PUSH
13473: LD_INT 9
13475: PUSH
13476: EMPTY
13477: LIST
13478: LIST
13479: PUSH
13480: EMPTY
13481: LIST
13482: LIST
13483: LIST
13484: LIST
13485: LIST
13486: LIST
13487: LIST
13488: LIST
13489: PUSH
13490: EMPTY
13491: LIST
13492: LIST
13493: LIST
13494: PPUSH
13495: CALL_OW 69
13499: ST_TO_ADDR
// RewardPeople ( tmp ) ;
13500: LD_VAR 0 2
13504: PPUSH
13505: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
13509: LD_ADDR_VAR 0 3
13513: PUSH
13514: LD_EXP 16
13518: PUSH
13519: LD_EXP 17
13523: PUSH
13524: LD_EXP 18
13528: PUSH
13529: LD_EXP 19
13533: PUSH
13534: LD_EXP 20
13538: PUSH
13539: LD_EXP 21
13543: PUSH
13544: LD_EXP 22
13548: PUSH
13549: LD_EXP 23
13553: PUSH
13554: LD_EXP 24
13558: PUSH
13559: LD_EXP 25
13563: PUSH
13564: LD_EXP 26
13568: PUSH
13569: LD_EXP 27
13573: PUSH
13574: LD_EXP 28
13578: PUSH
13579: LD_EXP 29
13583: PUSH
13584: LD_EXP 30
13588: PUSH
13589: LD_EXP 31
13593: PUSH
13594: LD_EXP 32
13598: PUSH
13599: LD_EXP 34
13603: PUSH
13604: LD_EXP 35
13608: PUSH
13609: LD_EXP 36
13613: PUSH
13614: LD_EXP 38
13618: PUSH
13619: LD_EXP 39
13623: PUSH
13624: LD_EXP 40
13628: PUSH
13629: LD_EXP 41
13633: PUSH
13634: LD_EXP 42
13638: PUSH
13639: LD_EXP 43
13643: PUSH
13644: LD_EXP 44
13648: PUSH
13649: LD_EXP 45
13653: PUSH
13654: LD_EXP 46
13658: PUSH
13659: LD_EXP 47
13663: PUSH
13664: LD_EXP 48
13668: PUSH
13669: LD_EXP 49
13673: PUSH
13674: LD_EXP 50
13678: PUSH
13679: LD_EXP 33
13683: PUSH
13684: EMPTY
13685: LIST
13686: LIST
13687: LIST
13688: LIST
13689: LIST
13690: LIST
13691: LIST
13692: LIST
13693: LIST
13694: LIST
13695: LIST
13696: LIST
13697: LIST
13698: LIST
13699: LIST
13700: LIST
13701: LIST
13702: LIST
13703: LIST
13704: LIST
13705: LIST
13706: LIST
13707: LIST
13708: LIST
13709: LIST
13710: LIST
13711: LIST
13712: LIST
13713: LIST
13714: LIST
13715: LIST
13716: LIST
13717: LIST
13718: LIST
13719: ST_TO_ADDR
// if tmp diff tmp2 then
13720: LD_VAR 0 2
13724: PUSH
13725: LD_VAR 0 3
13729: DIFF
13730: IFFALSE 13750
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
13732: LD_VAR 0 2
13736: PUSH
13737: LD_VAR 0 3
13741: DIFF
13742: PPUSH
13743: LD_STRING 13a_others
13745: PPUSH
13746: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
13750: LD_EXP 16
13754: PPUSH
13755: LD_STRING 13a_JMM
13757: PPUSH
13758: CALL_OW 38
// if IsOk ( Mike ) then
13762: LD_EXP 33
13766: PPUSH
13767: CALL_OW 302
13771: IFFALSE 13785
// SaveCharacters ( Mike , 13a_Mike ) ;
13773: LD_EXP 33
13777: PPUSH
13778: LD_STRING 13a_Mike
13780: PPUSH
13781: CALL_OW 38
// if IsOk ( Titov ) then
13785: LD_EXP 36
13789: PPUSH
13790: CALL_OW 302
13794: IFFALSE 13808
// SaveCharacters ( Titov , 13a_Titov ) ;
13796: LD_EXP 36
13800: PPUSH
13801: LD_STRING 13a_Titov
13803: PPUSH
13804: CALL_OW 38
// if IsOk ( Dolgov ) then
13808: LD_EXP 38
13812: PPUSH
13813: CALL_OW 302
13817: IFFALSE 13831
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
13819: LD_EXP 38
13823: PPUSH
13824: LD_STRING 13a_Dolgov
13826: PPUSH
13827: CALL_OW 38
// if IsOk ( Petrosyan ) then
13831: LD_EXP 39
13835: PPUSH
13836: CALL_OW 302
13840: IFFALSE 13854
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
13842: LD_EXP 39
13846: PPUSH
13847: LD_STRING 13a_Petrosyan
13849: PPUSH
13850: CALL_OW 38
// if IsOk ( Scholtze ) then
13854: LD_EXP 40
13858: PPUSH
13859: CALL_OW 302
13863: IFFALSE 13877
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
13865: LD_EXP 40
13869: PPUSH
13870: LD_STRING 13a_Scholtze
13872: PPUSH
13873: CALL_OW 38
// if IsOk ( Oblukov ) then
13877: LD_EXP 41
13881: PPUSH
13882: CALL_OW 302
13886: IFFALSE 13900
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
13888: LD_EXP 41
13892: PPUSH
13893: LD_STRING 13a_Oblukov
13895: PPUSH
13896: CALL_OW 38
// if IsOk ( Kapitsova ) then
13900: LD_EXP 42
13904: PPUSH
13905: CALL_OW 302
13909: IFFALSE 13923
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
13911: LD_EXP 42
13915: PPUSH
13916: LD_STRING 13a_Kapitsova
13918: PPUSH
13919: CALL_OW 38
// if IsOk ( Lipshchin ) then
13923: LD_EXP 43
13927: PPUSH
13928: CALL_OW 302
13932: IFFALSE 13946
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
13934: LD_EXP 43
13938: PPUSH
13939: LD_STRING 13a_Lipshchin
13941: PPUSH
13942: CALL_OW 38
// if IsOk ( Petrovova ) then
13946: LD_EXP 44
13950: PPUSH
13951: CALL_OW 302
13955: IFFALSE 13969
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
13957: LD_EXP 44
13961: PPUSH
13962: LD_STRING 13a_Petrovova
13964: PPUSH
13965: CALL_OW 38
// if IsOk ( Kovalyuk ) then
13969: LD_EXP 45
13973: PPUSH
13974: CALL_OW 302
13978: IFFALSE 13992
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
13980: LD_EXP 45
13984: PPUSH
13985: LD_STRING 13a_Kovalyuk
13987: PPUSH
13988: CALL_OW 38
// if IsOk ( Kuzmov ) then
13992: LD_EXP 46
13996: PPUSH
13997: CALL_OW 302
14001: IFFALSE 14015
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
14003: LD_EXP 46
14007: PPUSH
14008: LD_STRING 13a_Kuzmov
14010: PPUSH
14011: CALL_OW 38
// if IsOk ( Karamazov ) then
14015: LD_EXP 47
14019: PPUSH
14020: CALL_OW 302
14024: IFFALSE 14038
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
14026: LD_EXP 47
14030: PPUSH
14031: LD_STRING 13a_Karamazov
14033: PPUSH
14034: CALL_OW 38
// if Burlak then
14038: LD_EXP 48
14042: IFFALSE 14063
// begin ToLua ( enableBioCharacter(BIO_GORKI) ) ;
14044: LD_STRING enableBioCharacter(BIO_GORKI)
14046: PPUSH
14047: CALL_OW 559
// SaveCharacters ( Burlak , 13a_Burlak ) ;
14051: LD_EXP 48
14055: PPUSH
14056: LD_STRING 13a_Burlak
14058: PPUSH
14059: CALL_OW 38
// end ; if IsOk ( Belkov ) then
14063: LD_EXP 49
14067: PPUSH
14068: CALL_OW 302
14072: IFFALSE 14086
// SaveCharacters ( Belkov , 13a_Belkov ) ;
14074: LD_EXP 49
14078: PPUSH
14079: LD_STRING 13a_Belkov
14081: PPUSH
14082: CALL_OW 38
// if IsOk ( Gnyevko ) then
14086: LD_EXP 50
14090: PPUSH
14091: CALL_OW 302
14095: IFFALSE 14109
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
14097: LD_EXP 50
14101: PPUSH
14102: LD_STRING 13a_Gnyevko
14104: PPUSH
14105: CALL_OW 38
// if IsOk ( Lisa ) then
14109: LD_EXP 18
14113: PPUSH
14114: CALL_OW 302
14118: IFFALSE 14132
// SaveCharacters ( Lisa , 13a_Lisa ) ;
14120: LD_EXP 18
14124: PPUSH
14125: LD_STRING 13a_Lisa
14127: PPUSH
14128: CALL_OW 38
// if IsOk ( Donaldson ) then
14132: LD_EXP 19
14136: PPUSH
14137: CALL_OW 302
14141: IFFALSE 14155
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
14143: LD_EXP 19
14147: PPUSH
14148: LD_STRING 13a_Donaldson
14150: PPUSH
14151: CALL_OW 38
// if IsOk ( Bobby ) then
14155: LD_EXP 20
14159: PPUSH
14160: CALL_OW 302
14164: IFFALSE 14178
// SaveCharacters ( Bobby , 13a_Bobby ) ;
14166: LD_EXP 20
14170: PPUSH
14171: LD_STRING 13a_Bobby
14173: PPUSH
14174: CALL_OW 38
// if IsOk ( Cyrus ) then
14178: LD_EXP 21
14182: PPUSH
14183: CALL_OW 302
14187: IFFALSE 14201
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
14189: LD_EXP 21
14193: PPUSH
14194: LD_STRING 13a_Cyrus
14196: PPUSH
14197: CALL_OW 38
// if IsOk ( Denis ) then
14201: LD_EXP 22
14205: PPUSH
14206: CALL_OW 302
14210: IFFALSE 14224
// SaveCharacters ( Denis , 13a_Denis ) ;
14212: LD_EXP 22
14216: PPUSH
14217: LD_STRING 13a_Denis
14219: PPUSH
14220: CALL_OW 38
// if IsOk ( Brown ) then
14224: LD_EXP 23
14228: PPUSH
14229: CALL_OW 302
14233: IFFALSE 14247
// SaveCharacters ( Brown , 13a_Brown ) ;
14235: LD_EXP 23
14239: PPUSH
14240: LD_STRING 13a_Brown
14242: PPUSH
14243: CALL_OW 38
// if IsOk ( Gladstone ) then
14247: LD_EXP 24
14251: PPUSH
14252: CALL_OW 302
14256: IFFALSE 14270
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
14258: LD_EXP 24
14262: PPUSH
14263: LD_STRING 13a_Gladstone
14265: PPUSH
14266: CALL_OW 38
// if IsOk ( Houten ) then
14270: LD_EXP 25
14274: PPUSH
14275: CALL_OW 302
14279: IFFALSE 14293
// SaveCharacters ( Houten , 13a_Houten ) ;
14281: LD_EXP 25
14285: PPUSH
14286: LD_STRING 13a_Houten
14288: PPUSH
14289: CALL_OW 38
// if IsOk ( Cornel ) then
14293: LD_EXP 26
14297: PPUSH
14298: CALL_OW 302
14302: IFFALSE 14316
// SaveCharacters ( Cornel , 13a_Cornel ) ;
14304: LD_EXP 26
14308: PPUSH
14309: LD_STRING 13a_Cornel
14311: PPUSH
14312: CALL_OW 38
// if IsOk ( Gary ) then
14316: LD_EXP 27
14320: PPUSH
14321: CALL_OW 302
14325: IFFALSE 14339
// SaveCharacters ( Gary , 13a_Gary ) ;
14327: LD_EXP 27
14331: PPUSH
14332: LD_STRING 13a_Gary
14334: PPUSH
14335: CALL_OW 38
// if IsOk ( Frank ) then
14339: LD_EXP 28
14343: PPUSH
14344: CALL_OW 302
14348: IFFALSE 14362
// SaveCharacters ( Frank , 13a_Frank ) ;
14350: LD_EXP 28
14354: PPUSH
14355: LD_STRING 13a_Frank
14357: PPUSH
14358: CALL_OW 38
// if IsOk ( Kikuchi ) then
14362: LD_EXP 29
14366: PPUSH
14367: CALL_OW 302
14371: IFFALSE 14385
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
14373: LD_EXP 29
14377: PPUSH
14378: LD_STRING 13a_Kikuchi
14380: PPUSH
14381: CALL_OW 38
// if IsOk ( Simms ) then
14385: LD_EXP 30
14389: PPUSH
14390: CALL_OW 302
14394: IFFALSE 14408
// SaveCharacters ( Simms , 13a_Simms ) ;
14396: LD_EXP 30
14400: PPUSH
14401: LD_STRING 13a_Simms
14403: PPUSH
14404: CALL_OW 38
// if IsOk ( Joan ) then
14408: LD_EXP 31
14412: PPUSH
14413: CALL_OW 302
14417: IFFALSE 14431
// SaveCharacters ( Joan , 13a_Joan ) ;
14419: LD_EXP 31
14423: PPUSH
14424: LD_STRING 13a_Joan
14426: PPUSH
14427: CALL_OW 38
// if IsOk ( DeltaDoctor ) then
14431: LD_EXP 32
14435: PPUSH
14436: CALL_OW 302
14440: IFFALSE 14454
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
14442: LD_EXP 32
14446: PPUSH
14447: LD_STRING 13a_DeltaDoctor
14449: PPUSH
14450: CALL_OW 38
// if IsOk ( Gossudarov ) then
14454: LD_EXP 34
14458: PPUSH
14459: CALL_OW 302
14463: IFFALSE 14477
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
14465: LD_EXP 34
14469: PPUSH
14470: LD_STRING 13a_Gossudarov
14472: PPUSH
14473: CALL_OW 38
// if IsOk ( Kirilenkova ) then
14477: LD_EXP 35
14481: PPUSH
14482: CALL_OW 302
14486: IFFALSE 14500
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
14488: LD_EXP 35
14492: PPUSH
14493: LD_STRING 13a_Kirilenkova
14495: PPUSH
14496: CALL_OW 38
// if IsOk ( Roth ) then
14500: LD_EXP 17
14504: PPUSH
14505: CALL_OW 302
14509: IFFALSE 14523
// SaveCharacters ( Roth , 13a_Roth ) ;
14511: LD_EXP 17
14515: PPUSH
14516: LD_STRING 13a_Roth
14518: PPUSH
14519: CALL_OW 38
// if Masha then
14523: LD_EXP 51
14527: IFFALSE 14582
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
14529: LD_EXP 51
14533: PPUSH
14534: CALL_OW 265
14538: PUSH
14539: LD_EXP 51
14543: PPUSH
14544: CALL_OW 262
14548: PUSH
14549: LD_EXP 51
14553: PPUSH
14554: CALL_OW 263
14558: PUSH
14559: LD_EXP 51
14563: PPUSH
14564: CALL_OW 264
14568: PUSH
14569: EMPTY
14570: LIST
14571: LIST
14572: LIST
14573: LIST
14574: PPUSH
14575: LD_STRING 13a_Masha
14577: PPUSH
14578: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
14582: LD_ADDR_VAR 0 2
14586: PUSH
14587: LD_INT 21
14589: PUSH
14590: LD_INT 3
14592: PUSH
14593: EMPTY
14594: LIST
14595: LIST
14596: PPUSH
14597: CALL_OW 69
14601: ST_TO_ADDR
// tmp2 := [ ] ;
14602: LD_ADDR_VAR 0 3
14606: PUSH
14607: EMPTY
14608: ST_TO_ADDR
// if tmp then
14609: LD_VAR 0 2
14613: IFFALSE 14764
// for i in tmp do
14615: LD_ADDR_VAR 0 1
14619: PUSH
14620: LD_VAR 0 2
14624: PUSH
14625: FOR_IN
14626: IFFALSE 14762
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
14628: LD_ADDR_VAR 0 3
14632: PUSH
14633: LD_VAR 0 3
14637: PUSH
14638: LD_VAR 0 1
14642: PPUSH
14643: CALL_OW 255
14647: PUSH
14648: LD_VAR 0 1
14652: PPUSH
14653: CALL_OW 248
14657: PUSH
14658: LD_VAR 0 1
14662: PPUSH
14663: CALL_OW 266
14667: PUSH
14668: LD_VAR 0 1
14672: PPUSH
14673: CALL_OW 250
14677: PUSH
14678: LD_VAR 0 1
14682: PPUSH
14683: CALL_OW 251
14687: PUSH
14688: LD_VAR 0 1
14692: PPUSH
14693: CALL_OW 254
14697: PUSH
14698: LD_VAR 0 1
14702: PPUSH
14703: CALL_OW 267
14707: PUSH
14708: LD_VAR 0 1
14712: PPUSH
14713: LD_INT 1
14715: PPUSH
14716: CALL_OW 268
14720: PUSH
14721: LD_VAR 0 1
14725: PPUSH
14726: LD_INT 2
14728: PPUSH
14729: CALL_OW 268
14733: PUSH
14734: LD_VAR 0 1
14738: PPUSH
14739: CALL_OW 269
14743: PUSH
14744: EMPTY
14745: LIST
14746: LIST
14747: LIST
14748: LIST
14749: LIST
14750: LIST
14751: LIST
14752: LIST
14753: LIST
14754: LIST
14755: PUSH
14756: EMPTY
14757: LIST
14758: ADD
14759: ST_TO_ADDR
14760: GO 14625
14762: POP
14763: POP
// if tmp2 then
14764: LD_VAR 0 3
14768: IFFALSE 14782
// SaveVariable ( tmp2 , 13a_buildings ) ;
14770: LD_VAR 0 3
14774: PPUSH
14775: LD_STRING 13a_buildings
14777: PPUSH
14778: CALL_OW 39
// YouWin ;
14782: CALL_OW 103
// end ;
14786: PPOPN 6
14788: END
// export function SciRu ; var tmp , t ; begin
14789: LD_INT 0
14791: PPUSH
14792: PPUSH
14793: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
14794: LD_ADDR_VAR 0 3
14798: PUSH
14799: LD_EXP 34
14803: PUSH
14804: LD_EXP 48
14808: PUSH
14809: LD_EXP 36
14813: PUSH
14814: LD_EXP 49
14818: PUSH
14819: LD_EXP 50
14823: PUSH
14824: LD_EXP 39
14828: PUSH
14829: LD_EXP 40
14833: PUSH
14834: LD_EXP 38
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: LIST
14843: LIST
14844: LIST
14845: LIST
14846: LIST
14847: LIST
14848: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
14849: LD_ADDR_VAR 0 2
14853: PUSH
14854: LD_INT 22
14856: PUSH
14857: LD_INT 7
14859: PUSH
14860: EMPTY
14861: LIST
14862: LIST
14863: PUSH
14864: LD_INT 23
14866: PUSH
14867: LD_INT 3
14869: PUSH
14870: EMPTY
14871: LIST
14872: LIST
14873: PUSH
14874: LD_INT 25
14876: PUSH
14877: LD_INT 4
14879: PUSH
14880: EMPTY
14881: LIST
14882: LIST
14883: PUSH
14884: LD_INT 26
14886: PUSH
14887: LD_INT 1
14889: PUSH
14890: EMPTY
14891: LIST
14892: LIST
14893: PUSH
14894: EMPTY
14895: LIST
14896: LIST
14897: LIST
14898: LIST
14899: PPUSH
14900: CALL_OW 69
14904: PUSH
14905: LD_VAR 0 3
14909: DIFF
14910: ST_TO_ADDR
// if tmp then
14911: LD_VAR 0 2
14915: IFFALSE 14931
// result := tmp [ 1 ] ;
14917: LD_ADDR_VAR 0 1
14921: PUSH
14922: LD_VAR 0 2
14926: PUSH
14927: LD_INT 1
14929: ARRAY
14930: ST_TO_ADDR
// end ;
14931: LD_VAR 0 1
14935: RET
// export function SolRu ; var tmp , t ; begin
14936: LD_INT 0
14938: PPUSH
14939: PPUSH
14940: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
14941: LD_ADDR_VAR 0 3
14945: PUSH
14946: LD_EXP 34
14950: PUSH
14951: LD_EXP 48
14955: PUSH
14956: LD_EXP 36
14960: PUSH
14961: LD_EXP 49
14965: PUSH
14966: LD_EXP 50
14970: PUSH
14971: LD_EXP 39
14975: PUSH
14976: LD_EXP 40
14980: PUSH
14981: LD_EXP 38
14985: PUSH
14986: EMPTY
14987: LIST
14988: LIST
14989: LIST
14990: LIST
14991: LIST
14992: LIST
14993: LIST
14994: LIST
14995: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
14996: LD_ADDR_VAR 0 2
15000: PUSH
15001: LD_INT 22
15003: PUSH
15004: LD_INT 7
15006: PUSH
15007: EMPTY
15008: LIST
15009: LIST
15010: PUSH
15011: LD_INT 23
15013: PUSH
15014: LD_INT 3
15016: PUSH
15017: EMPTY
15018: LIST
15019: LIST
15020: PUSH
15021: LD_INT 25
15023: PUSH
15024: LD_INT 1
15026: PUSH
15027: EMPTY
15028: LIST
15029: LIST
15030: PUSH
15031: LD_INT 26
15033: PUSH
15034: LD_INT 1
15036: PUSH
15037: EMPTY
15038: LIST
15039: LIST
15040: PUSH
15041: EMPTY
15042: LIST
15043: LIST
15044: LIST
15045: LIST
15046: PPUSH
15047: CALL_OW 69
15051: PUSH
15052: LD_VAR 0 3
15056: DIFF
15057: ST_TO_ADDR
// if tmp then
15058: LD_VAR 0 2
15062: IFFALSE 15078
// result := tmp [ 1 ] ;
15064: LD_ADDR_VAR 0 1
15068: PUSH
15069: LD_VAR 0 2
15073: PUSH
15074: LD_INT 1
15076: ARRAY
15077: ST_TO_ADDR
// end ; end_of_file
15078: LD_VAR 0 1
15082: RET
// export function CustomEvent ( event ) ; begin
15083: LD_INT 0
15085: PPUSH
// end ;
15086: LD_VAR 0 2
15090: RET
// on UnitDestroyed ( un ) do var i , side ;
15091: LD_INT 0
15093: PPUSH
15094: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
15095: LD_VAR 0 1
15099: PPUSH
15100: CALL 105571 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
15104: LD_VAR 0 1
15108: PUSH
15109: LD_INT 22
15111: PUSH
15112: LD_INT 7
15114: PUSH
15115: EMPTY
15116: LIST
15117: LIST
15118: PUSH
15119: LD_INT 2
15121: PUSH
15122: LD_INT 25
15124: PUSH
15125: LD_INT 1
15127: PUSH
15128: EMPTY
15129: LIST
15130: LIST
15131: PUSH
15132: LD_INT 25
15134: PUSH
15135: LD_INT 2
15137: PUSH
15138: EMPTY
15139: LIST
15140: LIST
15141: PUSH
15142: LD_INT 25
15144: PUSH
15145: LD_INT 3
15147: PUSH
15148: EMPTY
15149: LIST
15150: LIST
15151: PUSH
15152: LD_INT 25
15154: PUSH
15155: LD_INT 4
15157: PUSH
15158: EMPTY
15159: LIST
15160: LIST
15161: PUSH
15162: LD_INT 25
15164: PUSH
15165: LD_INT 5
15167: PUSH
15168: EMPTY
15169: LIST
15170: LIST
15171: PUSH
15172: LD_INT 25
15174: PUSH
15175: LD_INT 8
15177: PUSH
15178: EMPTY
15179: LIST
15180: LIST
15181: PUSH
15182: LD_INT 25
15184: PUSH
15185: LD_INT 9
15187: PUSH
15188: EMPTY
15189: LIST
15190: LIST
15191: PUSH
15192: EMPTY
15193: LIST
15194: LIST
15195: LIST
15196: LIST
15197: LIST
15198: LIST
15199: LIST
15200: LIST
15201: PUSH
15202: EMPTY
15203: LIST
15204: LIST
15205: PPUSH
15206: CALL_OW 69
15210: IN
15211: IFFALSE 15227
// loss_counter := loss_counter + 1 ;
15213: LD_ADDR_EXP 14
15217: PUSH
15218: LD_EXP 14
15222: PUSH
15223: LD_INT 1
15225: PLUS
15226: ST_TO_ADDR
// if un = Abdul then
15227: LD_VAR 0 1
15231: PUSH
15232: LD_EXP 57
15236: EQUAL
15237: IFFALSE 15247
// abdul_escaped := false ;
15239: LD_ADDR_EXP 13
15243: PUSH
15244: LD_INT 0
15246: ST_TO_ADDR
// if un in ru_attackers then
15247: LD_VAR 0 1
15251: PUSH
15252: LD_EXP 54
15256: IN
15257: IFFALSE 15275
// ru_attackers := ru_attackers diff un ;
15259: LD_ADDR_EXP 54
15263: PUSH
15264: LD_EXP 54
15268: PUSH
15269: LD_VAR 0 1
15273: DIFF
15274: ST_TO_ADDR
// if un in ar_attackers then
15275: LD_VAR 0 1
15279: PUSH
15280: LD_EXP 11
15284: IN
15285: IFFALSE 15303
// ar_attackers := ar_attackers diff un ;
15287: LD_ADDR_EXP 11
15291: PUSH
15292: LD_EXP 11
15296: PUSH
15297: LD_VAR 0 1
15301: DIFF
15302: ST_TO_ADDR
// if un = JMM then
15303: LD_VAR 0 1
15307: PUSH
15308: LD_EXP 16
15312: EQUAL
15313: IFFALSE 15324
// begin YouLost ( JMM ) ;
15315: LD_STRING JMM
15317: PPUSH
15318: CALL_OW 104
// exit ;
15322: GO 15421
// end ; if un = Burlak then
15324: LD_VAR 0 1
15328: PUSH
15329: LD_EXP 48
15333: EQUAL
15334: IFFALSE 15345
// begin YouLost ( Burlak ) ;
15336: LD_STRING Burlak
15338: PPUSH
15339: CALL_OW 104
// exit ;
15343: GO 15421
// end ; if un = freedom then
15345: LD_VAR 0 1
15349: PUSH
15350: LD_EXP 3
15354: EQUAL
15355: IFFALSE 15366
// begin YouLost ( Destroyed ) ;
15357: LD_STRING Destroyed
15359: PPUSH
15360: CALL_OW 104
// exit ;
15364: GO 15421
// end ; if un = Masha then
15366: LD_VAR 0 1
15370: PUSH
15371: LD_EXP 51
15375: EQUAL
15376: IFFALSE 15393
// begin ChangeMissionObjectives ( M4b ) ;
15378: LD_STRING M4b
15380: PPUSH
15381: CALL_OW 337
// masha_killed := true ;
15385: LD_ADDR_EXP 10
15389: PUSH
15390: LD_INT 1
15392: ST_TO_ADDR
// end ; if un = Mastodont then
15393: LD_VAR 0 1
15397: PUSH
15398: LD_EXP 58
15402: EQUAL
15403: IFFALSE 15412
// ChangeMissionObjectives ( M4a ) ;
15405: LD_STRING M4a
15407: PPUSH
15408: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
15412: LD_VAR 0 1
15416: PPUSH
15417: CALL 86785 0 1
// end ;
15421: PPOPN 3
15423: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
15424: LD_VAR 0 1
15428: PPUSH
15429: LD_VAR 0 2
15433: PPUSH
15434: CALL 89117 0 2
// end ;
15438: PPOPN 2
15440: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
15441: LD_VAR 0 1
15445: PPUSH
15446: CALL 88185 0 1
// end ;
15450: PPOPN 1
15452: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
15453: LD_VAR 0 1
15457: PUSH
15458: LD_INT 22
15460: PUSH
15461: LD_INT 7
15463: PUSH
15464: EMPTY
15465: LIST
15466: LIST
15467: PUSH
15468: LD_INT 30
15470: PUSH
15471: LD_INT 0
15473: PUSH
15474: EMPTY
15475: LIST
15476: LIST
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PPUSH
15482: CALL_OW 69
15486: IN
15487: IFFALSE 15526
// begin SetBName ( building , freedom ) ;
15489: LD_VAR 0 1
15493: PPUSH
15494: LD_STRING freedom
15496: PPUSH
15497: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
15501: LD_INT 0
15503: PPUSH
15504: LD_INT 7
15506: PPUSH
15507: LD_INT 0
15509: PPUSH
15510: CALL_OW 324
// freedom := building ;
15514: LD_ADDR_EXP 3
15518: PUSH
15519: LD_VAR 0 1
15523: ST_TO_ADDR
// exit ;
15524: GO 15592
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
15526: LD_VAR 0 1
15530: PUSH
15531: LD_INT 22
15533: PUSH
15534: LD_INT 7
15536: PUSH
15537: EMPTY
15538: LIST
15539: LIST
15540: PUSH
15541: LD_INT 23
15543: PUSH
15544: LD_INT 3
15546: PUSH
15547: EMPTY
15548: LIST
15549: LIST
15550: PUSH
15551: LD_INT 30
15553: PUSH
15554: LD_INT 6
15556: PUSH
15557: EMPTY
15558: LIST
15559: LIST
15560: PUSH
15561: EMPTY
15562: LIST
15563: LIST
15564: LIST
15565: PPUSH
15566: CALL_OW 69
15570: IN
15571: IFFALSE 15583
// begin ru_lab_builded := true ;
15573: LD_ADDR_EXP 5
15577: PUSH
15578: LD_INT 1
15580: ST_TO_ADDR
// exit ;
15581: GO 15592
// end ; MCE_BuildingComplete ( building ) ;
15583: LD_VAR 0 1
15587: PPUSH
15588: CALL 88426 0 1
// end ;
15592: PPOPN 1
15594: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
15595: LD_VAR 0 1
15599: PPUSH
15600: LD_VAR 0 2
15604: PPUSH
15605: CALL 86481 0 2
// end ;
15609: PPOPN 2
15611: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
15612: LD_VAR 0 1
15616: PPUSH
15617: LD_VAR 0 2
15621: PPUSH
15622: LD_VAR 0 3
15626: PPUSH
15627: LD_VAR 0 4
15631: PPUSH
15632: LD_VAR 0 5
15636: PPUSH
15637: CALL 86101 0 5
// end ;
15641: PPOPN 5
15643: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
15644: LD_VAR 0 1
15648: PPUSH
15649: LD_VAR 0 2
15653: PPUSH
15654: CALL 105691 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
15658: LD_VAR 0 1
15662: PPUSH
15663: LD_VAR 0 2
15667: PPUSH
15668: CALL 85654 0 2
// end ;
15672: PPOPN 2
15674: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
15675: LD_VAR 0 1
15679: PPUSH
15680: CALL_OW 263
15684: PUSH
15685: LD_INT 3
15687: EQUAL
15688: PUSH
15689: LD_VAR 0 2
15693: PPUSH
15694: CALL_OW 263
15698: PUSH
15699: LD_INT 3
15701: EQUAL
15702: OR
15703: IFFALSE 15719
// hack_counter := hack_counter + 1 ;
15705: LD_ADDR_EXP 15
15709: PUSH
15710: LD_EXP 15
15714: PUSH
15715: LD_INT 1
15717: PLUS
15718: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
15719: LD_VAR 0 1
15723: PPUSH
15724: LD_VAR 0 2
15728: PPUSH
15729: LD_VAR 0 3
15733: PPUSH
15734: LD_VAR 0 4
15738: PPUSH
15739: CALL 85492 0 4
// end ;
15743: PPOPN 4
15745: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin if building = ru_depot then
15746: LD_VAR 0 1
15750: PUSH
15751: LD_INT 47
15753: EQUAL
15754: IFFALSE 15776
// SetResourceType ( GetBase ( building ) , mat_cans , 600 ) ;
15756: LD_VAR 0 1
15760: PPUSH
15761: CALL_OW 274
15765: PPUSH
15766: LD_INT 1
15768: PPUSH
15769: LD_INT 600
15771: PPUSH
15772: CALL_OW 277
// MCE_BuildingCaptured ( building , side , capturning_unit ) ;
15776: LD_VAR 0 1
15780: PPUSH
15781: LD_VAR 0 2
15785: PPUSH
15786: LD_VAR 0 3
15790: PPUSH
15791: CALL 85267 0 3
// end ;
15795: PPOPN 3
15797: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
15798: LD_VAR 0 1
15802: PPUSH
15803: LD_VAR 0 2
15807: PPUSH
15808: CALL 85152 0 2
// end ;
15812: PPOPN 2
15814: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
15815: LD_VAR 0 1
15819: PPUSH
15820: LD_VAR 0 2
15824: PPUSH
15825: CALL 89412 0 2
// end ;
15829: PPOPN 2
15831: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
15832: LD_VAR 0 1
15836: PPUSH
15837: LD_VAR 0 2
15841: PPUSH
15842: LD_VAR 0 3
15846: PPUSH
15847: LD_VAR 0 4
15851: PPUSH
15852: CALL 89628 0 4
// end ;
15856: PPOPN 4
15858: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
15859: LD_VAR 0 1
15863: PPUSH
15864: LD_VAR 0 2
15868: PPUSH
15869: CALL 84961 0 2
// end ;
15873: PPOPN 2
15875: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
15876: LD_VAR 0 1
15880: PPUSH
15881: CALL 105675 0 1
// end ; end_of_file
15885: PPOPN 1
15887: END
// every 0 0$30 do var cr , time ;
15888: GO 15890
15890: DISABLE
15891: LD_INT 0
15893: PPUSH
15894: PPUSH
// begin time := 0 0$20 ;
15895: LD_ADDR_VAR 0 2
15899: PUSH
15900: LD_INT 700
15902: ST_TO_ADDR
// while game do
15903: LD_EXP 2
15907: IFFALSE 16010
// begin wait ( time ) ;
15909: LD_VAR 0 2
15913: PPUSH
15914: CALL_OW 67
// if tick > 2 2$00 then
15918: LD_OWVAR 1
15922: PUSH
15923: LD_INT 4200
15925: GREATER
15926: IFFALSE 15963
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
15928: LD_ADDR_VAR 0 2
15932: PUSH
15933: LD_VAR 0 2
15937: PUSH
15938: LD_INT 140
15940: PUSH
15941: LD_INT 140
15943: PUSH
15944: LD_INT 210
15946: PUSH
15947: LD_INT 280
15949: PUSH
15950: EMPTY
15951: LIST
15952: LIST
15953: LIST
15954: LIST
15955: PUSH
15956: LD_OWVAR 67
15960: ARRAY
15961: PLUS
15962: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
15963: LD_INT 1
15965: PPUSH
15966: LD_INT 5
15968: PPUSH
15969: CALL_OW 12
15973: PPUSH
15974: LD_INT 70
15976: PPUSH
15977: LD_INT 49
15979: PPUSH
15980: LD_INT 25
15982: PPUSH
15983: LD_INT 1
15985: PPUSH
15986: CALL_OW 56
// if time > 3 3$00 then
15990: LD_VAR 0 2
15994: PUSH
15995: LD_INT 6300
15997: GREATER
15998: IFFALSE 16008
// time := 0 0$30 ;
16000: LD_ADDR_VAR 0 2
16004: PUSH
16005: LD_INT 1050
16007: ST_TO_ADDR
// end ;
16008: GO 15903
// end ;
16010: PPOPN 2
16012: END
// every 0 0$30 do var cr , time ;
16013: GO 16015
16015: DISABLE
16016: LD_INT 0
16018: PPUSH
16019: PPUSH
// begin time := 0 0$20 ;
16020: LD_ADDR_VAR 0 2
16024: PUSH
16025: LD_INT 700
16027: ST_TO_ADDR
// while game do
16028: LD_EXP 2
16032: IFFALSE 16125
// begin wait ( time ) ;
16034: LD_VAR 0 2
16038: PPUSH
16039: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
16043: LD_ADDR_VAR 0 2
16047: PUSH
16048: LD_VAR 0 2
16052: PUSH
16053: LD_INT 140
16055: PUSH
16056: LD_INT 175
16058: PUSH
16059: LD_INT 210
16061: PUSH
16062: LD_INT 280
16064: PUSH
16065: EMPTY
16066: LIST
16067: LIST
16068: LIST
16069: LIST
16070: PUSH
16071: LD_OWVAR 67
16075: ARRAY
16076: PLUS
16077: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
16078: LD_INT 3
16080: PPUSH
16081: LD_INT 5
16083: PPUSH
16084: CALL_OW 12
16088: PPUSH
16089: LD_INT 26
16091: PPUSH
16092: LD_INT 9
16094: PPUSH
16095: LD_INT 30
16097: PPUSH
16098: LD_INT 1
16100: PPUSH
16101: CALL_OW 56
// if time > 3 3$00 then
16105: LD_VAR 0 2
16109: PUSH
16110: LD_INT 6300
16112: GREATER
16113: IFFALSE 16123
// time := 0 0$20 ;
16115: LD_ADDR_VAR 0 2
16119: PUSH
16120: LD_INT 700
16122: ST_TO_ADDR
// end ;
16123: GO 16028
// end ;
16125: PPOPN 2
16127: END
// every 0 0$30 do var cr , time ;
16128: GO 16130
16130: DISABLE
16131: LD_INT 0
16133: PPUSH
16134: PPUSH
// begin time := 0 0$20 ;
16135: LD_ADDR_VAR 0 2
16139: PUSH
16140: LD_INT 700
16142: ST_TO_ADDR
// while game do
16143: LD_EXP 2
16147: IFFALSE 16276
// begin wait ( time ) ;
16149: LD_VAR 0 2
16153: PPUSH
16154: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
16158: LD_ADDR_VAR 0 2
16162: PUSH
16163: LD_VAR 0 2
16167: PUSH
16168: LD_INT 175
16170: PUSH
16171: LD_INT 210
16173: PUSH
16174: LD_INT 280
16176: PUSH
16177: LD_INT 350
16179: PUSH
16180: EMPTY
16181: LIST
16182: LIST
16183: LIST
16184: LIST
16185: PUSH
16186: LD_OWVAR 67
16190: ARRAY
16191: PLUS
16192: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
16193: LD_INT 1
16195: PPUSH
16196: LD_INT 5
16198: PPUSH
16199: CALL_OW 12
16203: PPUSH
16204: LD_INT 179
16206: PPUSH
16207: LD_INT 101
16209: PPUSH
16210: LD_INT 20
16212: PPUSH
16213: LD_INT 1
16215: PPUSH
16216: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
16220: LD_INT 350
16222: PPUSH
16223: LD_INT 525
16225: PPUSH
16226: CALL_OW 12
16230: PPUSH
16231: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
16235: LD_INT 1
16237: PPUSH
16238: LD_INT 5
16240: PPUSH
16241: CALL_OW 12
16245: PPUSH
16246: LD_INT 9
16248: PPUSH
16249: LD_INT 1
16251: PPUSH
16252: CALL_OW 55
// if time > 4 4$00 then
16256: LD_VAR 0 2
16260: PUSH
16261: LD_INT 8400
16263: GREATER
16264: IFFALSE 16274
// time := 0 0$30 ;
16266: LD_ADDR_VAR 0 2
16270: PUSH
16271: LD_INT 1050
16273: ST_TO_ADDR
// end ;
16274: GO 16143
// end ;
16276: PPOPN 2
16278: END
// every 0 0$30 do var cr , time ;
16279: GO 16281
16281: DISABLE
16282: LD_INT 0
16284: PPUSH
16285: PPUSH
// begin time := 0 0$10 ;
16286: LD_ADDR_VAR 0 2
16290: PUSH
16291: LD_INT 350
16293: ST_TO_ADDR
// while game do
16294: LD_EXP 2
16298: IFFALSE 16432
// begin wait ( time ) ;
16300: LD_VAR 0 2
16304: PPUSH
16305: CALL_OW 67
// time := time + 0 0$10 ;
16309: LD_ADDR_VAR 0 2
16313: PUSH
16314: LD_VAR 0 2
16318: PUSH
16319: LD_INT 350
16321: PLUS
16322: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
16323: LD_INT 1
16325: PPUSH
16326: LD_INT 5
16328: PPUSH
16329: CALL_OW 12
16333: PPUSH
16334: LD_INT 11
16336: PPUSH
16337: LD_INT 1
16339: PPUSH
16340: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
16344: LD_ADDR_VAR 0 1
16348: PUSH
16349: LD_INT 1
16351: PPUSH
16352: LD_INT 3
16354: PPUSH
16355: CALL_OW 12
16359: ST_TO_ADDR
// if cr = 1 then
16360: LD_VAR 0 1
16364: PUSH
16365: LD_INT 1
16367: EQUAL
16368: IFFALSE 16412
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
16370: LD_INT 700
16372: PPUSH
16373: LD_INT 1575
16375: PPUSH
16376: CALL_OW 12
16380: PPUSH
16381: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
16385: LD_INT 1
16387: PPUSH
16388: LD_INT 5
16390: PPUSH
16391: CALL_OW 12
16395: PPUSH
16396: LD_INT 34
16398: PPUSH
16399: LD_INT 50
16401: PPUSH
16402: LD_INT 7
16404: PPUSH
16405: LD_INT 1
16407: PPUSH
16408: CALL_OW 56
// end ; if time > 4 4$00 then
16412: LD_VAR 0 2
16416: PUSH
16417: LD_INT 8400
16419: GREATER
16420: IFFALSE 16430
// time := 0 0$40 ;
16422: LD_ADDR_VAR 0 2
16426: PUSH
16427: LD_INT 1400
16429: ST_TO_ADDR
// end ;
16430: GO 16294
// end ; end_of_file
16432: PPOPN 2
16434: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
16435: LD_INT 0
16437: PPUSH
16438: PPUSH
// if exist_mode then
16439: LD_VAR 0 2
16443: IFFALSE 16468
// unit := CreateCharacter ( prefix & ident ) else
16445: LD_ADDR_VAR 0 5
16449: PUSH
16450: LD_VAR 0 3
16454: PUSH
16455: LD_VAR 0 1
16459: STR
16460: PPUSH
16461: CALL_OW 34
16465: ST_TO_ADDR
16466: GO 16483
// unit := NewCharacter ( ident ) ;
16468: LD_ADDR_VAR 0 5
16472: PUSH
16473: LD_VAR 0 1
16477: PPUSH
16478: CALL_OW 25
16482: ST_TO_ADDR
// result := unit ;
16483: LD_ADDR_VAR 0 4
16487: PUSH
16488: LD_VAR 0 5
16492: ST_TO_ADDR
// end ;
16493: LD_VAR 0 4
16497: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
16498: LD_INT 0
16500: PPUSH
16501: PPUSH
// if not side or not nation then
16502: LD_VAR 0 1
16506: NOT
16507: PUSH
16508: LD_VAR 0 2
16512: NOT
16513: OR
16514: IFFALSE 16518
// exit ;
16516: GO 17286
// case nation of nation_american :
16518: LD_VAR 0 2
16522: PUSH
16523: LD_INT 1
16525: DOUBLE
16526: EQUAL
16527: IFTRUE 16531
16529: GO 16745
16531: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
16532: LD_ADDR_VAR 0 4
16536: PUSH
16537: LD_INT 35
16539: PUSH
16540: LD_INT 45
16542: PUSH
16543: LD_INT 46
16545: PUSH
16546: LD_INT 47
16548: PUSH
16549: LD_INT 82
16551: PUSH
16552: LD_INT 83
16554: PUSH
16555: LD_INT 84
16557: PUSH
16558: LD_INT 85
16560: PUSH
16561: LD_INT 86
16563: PUSH
16564: LD_INT 1
16566: PUSH
16567: LD_INT 2
16569: PUSH
16570: LD_INT 6
16572: PUSH
16573: LD_INT 15
16575: PUSH
16576: LD_INT 16
16578: PUSH
16579: LD_INT 7
16581: PUSH
16582: LD_INT 12
16584: PUSH
16585: LD_INT 13
16587: PUSH
16588: LD_INT 10
16590: PUSH
16591: LD_INT 14
16593: PUSH
16594: LD_INT 20
16596: PUSH
16597: LD_INT 21
16599: PUSH
16600: LD_INT 22
16602: PUSH
16603: LD_INT 25
16605: PUSH
16606: LD_INT 32
16608: PUSH
16609: LD_INT 27
16611: PUSH
16612: LD_INT 36
16614: PUSH
16615: LD_INT 69
16617: PUSH
16618: LD_INT 39
16620: PUSH
16621: LD_INT 34
16623: PUSH
16624: LD_INT 40
16626: PUSH
16627: LD_INT 48
16629: PUSH
16630: LD_INT 49
16632: PUSH
16633: LD_INT 50
16635: PUSH
16636: LD_INT 51
16638: PUSH
16639: LD_INT 52
16641: PUSH
16642: LD_INT 53
16644: PUSH
16645: LD_INT 54
16647: PUSH
16648: LD_INT 55
16650: PUSH
16651: LD_INT 56
16653: PUSH
16654: LD_INT 57
16656: PUSH
16657: LD_INT 58
16659: PUSH
16660: LD_INT 59
16662: PUSH
16663: LD_INT 60
16665: PUSH
16666: LD_INT 61
16668: PUSH
16669: LD_INT 62
16671: PUSH
16672: LD_INT 80
16674: PUSH
16675: LD_INT 82
16677: PUSH
16678: LD_INT 83
16680: PUSH
16681: LD_INT 84
16683: PUSH
16684: LD_INT 85
16686: PUSH
16687: LD_INT 86
16689: PUSH
16690: EMPTY
16691: LIST
16692: LIST
16693: LIST
16694: LIST
16695: LIST
16696: LIST
16697: LIST
16698: LIST
16699: LIST
16700: LIST
16701: LIST
16702: LIST
16703: LIST
16704: LIST
16705: LIST
16706: LIST
16707: LIST
16708: LIST
16709: LIST
16710: LIST
16711: LIST
16712: LIST
16713: LIST
16714: LIST
16715: LIST
16716: LIST
16717: LIST
16718: LIST
16719: LIST
16720: LIST
16721: LIST
16722: LIST
16723: LIST
16724: LIST
16725: LIST
16726: LIST
16727: LIST
16728: LIST
16729: LIST
16730: LIST
16731: LIST
16732: LIST
16733: LIST
16734: LIST
16735: LIST
16736: LIST
16737: LIST
16738: LIST
16739: LIST
16740: LIST
16741: LIST
16742: ST_TO_ADDR
16743: GO 17210
16745: LD_INT 2
16747: DOUBLE
16748: EQUAL
16749: IFTRUE 16753
16751: GO 16979
16753: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
16754: LD_ADDR_VAR 0 4
16758: PUSH
16759: LD_INT 35
16761: PUSH
16762: LD_INT 45
16764: PUSH
16765: LD_INT 46
16767: PUSH
16768: LD_INT 47
16770: PUSH
16771: LD_INT 82
16773: PUSH
16774: LD_INT 83
16776: PUSH
16777: LD_INT 84
16779: PUSH
16780: LD_INT 85
16782: PUSH
16783: LD_INT 87
16785: PUSH
16786: LD_INT 70
16788: PUSH
16789: LD_INT 1
16791: PUSH
16792: LD_INT 11
16794: PUSH
16795: LD_INT 3
16797: PUSH
16798: LD_INT 4
16800: PUSH
16801: LD_INT 5
16803: PUSH
16804: LD_INT 6
16806: PUSH
16807: LD_INT 15
16809: PUSH
16810: LD_INT 18
16812: PUSH
16813: LD_INT 7
16815: PUSH
16816: LD_INT 17
16818: PUSH
16819: LD_INT 8
16821: PUSH
16822: LD_INT 20
16824: PUSH
16825: LD_INT 21
16827: PUSH
16828: LD_INT 22
16830: PUSH
16831: LD_INT 72
16833: PUSH
16834: LD_INT 26
16836: PUSH
16837: LD_INT 69
16839: PUSH
16840: LD_INT 39
16842: PUSH
16843: LD_INT 40
16845: PUSH
16846: LD_INT 41
16848: PUSH
16849: LD_INT 42
16851: PUSH
16852: LD_INT 43
16854: PUSH
16855: LD_INT 48
16857: PUSH
16858: LD_INT 49
16860: PUSH
16861: LD_INT 50
16863: PUSH
16864: LD_INT 51
16866: PUSH
16867: LD_INT 52
16869: PUSH
16870: LD_INT 53
16872: PUSH
16873: LD_INT 54
16875: PUSH
16876: LD_INT 55
16878: PUSH
16879: LD_INT 56
16881: PUSH
16882: LD_INT 60
16884: PUSH
16885: LD_INT 61
16887: PUSH
16888: LD_INT 62
16890: PUSH
16891: LD_INT 66
16893: PUSH
16894: LD_INT 67
16896: PUSH
16897: LD_INT 68
16899: PUSH
16900: LD_INT 81
16902: PUSH
16903: LD_INT 82
16905: PUSH
16906: LD_INT 83
16908: PUSH
16909: LD_INT 84
16911: PUSH
16912: LD_INT 85
16914: PUSH
16915: LD_INT 87
16917: PUSH
16918: LD_INT 88
16920: PUSH
16921: EMPTY
16922: LIST
16923: LIST
16924: LIST
16925: LIST
16926: LIST
16927: LIST
16928: LIST
16929: LIST
16930: LIST
16931: LIST
16932: LIST
16933: LIST
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: LIST
16939: LIST
16940: LIST
16941: LIST
16942: LIST
16943: LIST
16944: LIST
16945: LIST
16946: LIST
16947: LIST
16948: LIST
16949: LIST
16950: LIST
16951: LIST
16952: LIST
16953: LIST
16954: LIST
16955: LIST
16956: LIST
16957: LIST
16958: LIST
16959: LIST
16960: LIST
16961: LIST
16962: LIST
16963: LIST
16964: LIST
16965: LIST
16966: LIST
16967: LIST
16968: LIST
16969: LIST
16970: LIST
16971: LIST
16972: LIST
16973: LIST
16974: LIST
16975: LIST
16976: ST_TO_ADDR
16977: GO 17210
16979: LD_INT 3
16981: DOUBLE
16982: EQUAL
16983: IFTRUE 16987
16985: GO 17209
16987: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
16988: LD_ADDR_VAR 0 4
16992: PUSH
16993: LD_INT 46
16995: PUSH
16996: LD_INT 47
16998: PUSH
16999: LD_INT 1
17001: PUSH
17002: LD_INT 2
17004: PUSH
17005: LD_INT 82
17007: PUSH
17008: LD_INT 83
17010: PUSH
17011: LD_INT 84
17013: PUSH
17014: LD_INT 85
17016: PUSH
17017: LD_INT 86
17019: PUSH
17020: LD_INT 11
17022: PUSH
17023: LD_INT 9
17025: PUSH
17026: LD_INT 20
17028: PUSH
17029: LD_INT 19
17031: PUSH
17032: LD_INT 21
17034: PUSH
17035: LD_INT 24
17037: PUSH
17038: LD_INT 22
17040: PUSH
17041: LD_INT 25
17043: PUSH
17044: LD_INT 28
17046: PUSH
17047: LD_INT 29
17049: PUSH
17050: LD_INT 30
17052: PUSH
17053: LD_INT 31
17055: PUSH
17056: LD_INT 37
17058: PUSH
17059: LD_INT 38
17061: PUSH
17062: LD_INT 32
17064: PUSH
17065: LD_INT 27
17067: PUSH
17068: LD_INT 33
17070: PUSH
17071: LD_INT 69
17073: PUSH
17074: LD_INT 39
17076: PUSH
17077: LD_INT 34
17079: PUSH
17080: LD_INT 40
17082: PUSH
17083: LD_INT 71
17085: PUSH
17086: LD_INT 23
17088: PUSH
17089: LD_INT 44
17091: PUSH
17092: LD_INT 48
17094: PUSH
17095: LD_INT 49
17097: PUSH
17098: LD_INT 50
17100: PUSH
17101: LD_INT 51
17103: PUSH
17104: LD_INT 52
17106: PUSH
17107: LD_INT 53
17109: PUSH
17110: LD_INT 54
17112: PUSH
17113: LD_INT 55
17115: PUSH
17116: LD_INT 56
17118: PUSH
17119: LD_INT 57
17121: PUSH
17122: LD_INT 58
17124: PUSH
17125: LD_INT 59
17127: PUSH
17128: LD_INT 63
17130: PUSH
17131: LD_INT 64
17133: PUSH
17134: LD_INT 65
17136: PUSH
17137: LD_INT 82
17139: PUSH
17140: LD_INT 83
17142: PUSH
17143: LD_INT 84
17145: PUSH
17146: LD_INT 85
17148: PUSH
17149: LD_INT 86
17151: PUSH
17152: EMPTY
17153: LIST
17154: LIST
17155: LIST
17156: LIST
17157: LIST
17158: LIST
17159: LIST
17160: LIST
17161: LIST
17162: LIST
17163: LIST
17164: LIST
17165: LIST
17166: LIST
17167: LIST
17168: LIST
17169: LIST
17170: LIST
17171: LIST
17172: LIST
17173: LIST
17174: LIST
17175: LIST
17176: LIST
17177: LIST
17178: LIST
17179: LIST
17180: LIST
17181: LIST
17182: LIST
17183: LIST
17184: LIST
17185: LIST
17186: LIST
17187: LIST
17188: LIST
17189: LIST
17190: LIST
17191: LIST
17192: LIST
17193: LIST
17194: LIST
17195: LIST
17196: LIST
17197: LIST
17198: LIST
17199: LIST
17200: LIST
17201: LIST
17202: LIST
17203: LIST
17204: LIST
17205: LIST
17206: ST_TO_ADDR
17207: GO 17210
17209: POP
// if state > - 1 and state < 3 then
17210: LD_VAR 0 3
17214: PUSH
17215: LD_INT 1
17217: NEG
17218: GREATER
17219: PUSH
17220: LD_VAR 0 3
17224: PUSH
17225: LD_INT 3
17227: LESS
17228: AND
17229: IFFALSE 17286
// for i in result do
17231: LD_ADDR_VAR 0 5
17235: PUSH
17236: LD_VAR 0 4
17240: PUSH
17241: FOR_IN
17242: IFFALSE 17284
// if GetTech ( i , side ) <> state then
17244: LD_VAR 0 5
17248: PPUSH
17249: LD_VAR 0 1
17253: PPUSH
17254: CALL_OW 321
17258: PUSH
17259: LD_VAR 0 3
17263: NONEQUAL
17264: IFFALSE 17282
// result := result diff i ;
17266: LD_ADDR_VAR 0 4
17270: PUSH
17271: LD_VAR 0 4
17275: PUSH
17276: LD_VAR 0 5
17280: DIFF
17281: ST_TO_ADDR
17282: GO 17241
17284: POP
17285: POP
// end ;
17286: LD_VAR 0 4
17290: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
17291: LD_INT 0
17293: PPUSH
17294: PPUSH
17295: PPUSH
// result := true ;
17296: LD_ADDR_VAR 0 3
17300: PUSH
17301: LD_INT 1
17303: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
17304: LD_ADDR_VAR 0 5
17308: PUSH
17309: LD_VAR 0 2
17313: PPUSH
17314: CALL_OW 480
17318: ST_TO_ADDR
// if not tmp then
17319: LD_VAR 0 5
17323: NOT
17324: IFFALSE 17328
// exit ;
17326: GO 17377
// for i in tmp do
17328: LD_ADDR_VAR 0 4
17332: PUSH
17333: LD_VAR 0 5
17337: PUSH
17338: FOR_IN
17339: IFFALSE 17375
// if GetTech ( i , side ) <> state_researched then
17341: LD_VAR 0 4
17345: PPUSH
17346: LD_VAR 0 1
17350: PPUSH
17351: CALL_OW 321
17355: PUSH
17356: LD_INT 2
17358: NONEQUAL
17359: IFFALSE 17373
// begin result := false ;
17361: LD_ADDR_VAR 0 3
17365: PUSH
17366: LD_INT 0
17368: ST_TO_ADDR
// exit ;
17369: POP
17370: POP
17371: GO 17377
// end ;
17373: GO 17338
17375: POP
17376: POP
// end ;
17377: LD_VAR 0 3
17381: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
17382: LD_INT 0
17384: PPUSH
17385: PPUSH
17386: PPUSH
17387: PPUSH
17388: PPUSH
17389: PPUSH
17390: PPUSH
17391: PPUSH
17392: PPUSH
17393: PPUSH
17394: PPUSH
17395: PPUSH
17396: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
17397: LD_VAR 0 1
17401: NOT
17402: PUSH
17403: LD_VAR 0 1
17407: PPUSH
17408: CALL_OW 257
17412: PUSH
17413: LD_INT 9
17415: NONEQUAL
17416: OR
17417: IFFALSE 17421
// exit ;
17419: GO 17994
// side := GetSide ( unit ) ;
17421: LD_ADDR_VAR 0 9
17425: PUSH
17426: LD_VAR 0 1
17430: PPUSH
17431: CALL_OW 255
17435: ST_TO_ADDR
// tech_space := tech_spacanom ;
17436: LD_ADDR_VAR 0 12
17440: PUSH
17441: LD_INT 29
17443: ST_TO_ADDR
// tech_time := tech_taurad ;
17444: LD_ADDR_VAR 0 13
17448: PUSH
17449: LD_INT 28
17451: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
17452: LD_ADDR_VAR 0 11
17456: PUSH
17457: LD_VAR 0 1
17461: PPUSH
17462: CALL_OW 310
17466: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
17467: LD_VAR 0 11
17471: PPUSH
17472: CALL_OW 247
17476: PUSH
17477: LD_INT 2
17479: EQUAL
17480: IFFALSE 17484
// exit ;
17482: GO 17994
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17484: LD_ADDR_VAR 0 8
17488: PUSH
17489: LD_INT 81
17491: PUSH
17492: LD_VAR 0 9
17496: PUSH
17497: EMPTY
17498: LIST
17499: LIST
17500: PUSH
17501: LD_INT 3
17503: PUSH
17504: LD_INT 21
17506: PUSH
17507: LD_INT 3
17509: PUSH
17510: EMPTY
17511: LIST
17512: LIST
17513: PUSH
17514: EMPTY
17515: LIST
17516: LIST
17517: PUSH
17518: EMPTY
17519: LIST
17520: LIST
17521: PPUSH
17522: CALL_OW 69
17526: ST_TO_ADDR
// if not tmp then
17527: LD_VAR 0 8
17531: NOT
17532: IFFALSE 17536
// exit ;
17534: GO 17994
// if in_unit then
17536: LD_VAR 0 11
17540: IFFALSE 17564
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
17542: LD_ADDR_VAR 0 10
17546: PUSH
17547: LD_VAR 0 8
17551: PPUSH
17552: LD_VAR 0 11
17556: PPUSH
17557: CALL_OW 74
17561: ST_TO_ADDR
17562: GO 17584
// enemy := NearestUnitToUnit ( tmp , unit ) ;
17564: LD_ADDR_VAR 0 10
17568: PUSH
17569: LD_VAR 0 8
17573: PPUSH
17574: LD_VAR 0 1
17578: PPUSH
17579: CALL_OW 74
17583: ST_TO_ADDR
// if not enemy then
17584: LD_VAR 0 10
17588: NOT
17589: IFFALSE 17593
// exit ;
17591: GO 17994
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
17593: LD_VAR 0 11
17597: PUSH
17598: LD_VAR 0 11
17602: PPUSH
17603: LD_VAR 0 10
17607: PPUSH
17608: CALL_OW 296
17612: PUSH
17613: LD_INT 13
17615: GREATER
17616: AND
17617: PUSH
17618: LD_VAR 0 1
17622: PPUSH
17623: LD_VAR 0 10
17627: PPUSH
17628: CALL_OW 296
17632: PUSH
17633: LD_INT 12
17635: GREATER
17636: OR
17637: IFFALSE 17641
// exit ;
17639: GO 17994
// missile := [ 1 ] ;
17641: LD_ADDR_VAR 0 14
17645: PUSH
17646: LD_INT 1
17648: PUSH
17649: EMPTY
17650: LIST
17651: ST_TO_ADDR
// if Researched ( side , tech_space ) then
17652: LD_VAR 0 9
17656: PPUSH
17657: LD_VAR 0 12
17661: PPUSH
17662: CALL_OW 325
17666: IFFALSE 17695
// missile := Replace ( missile , missile + 1 , 2 ) ;
17668: LD_ADDR_VAR 0 14
17672: PUSH
17673: LD_VAR 0 14
17677: PPUSH
17678: LD_VAR 0 14
17682: PUSH
17683: LD_INT 1
17685: PLUS
17686: PPUSH
17687: LD_INT 2
17689: PPUSH
17690: CALL_OW 1
17694: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
17695: LD_VAR 0 9
17699: PPUSH
17700: LD_VAR 0 13
17704: PPUSH
17705: CALL_OW 325
17709: PUSH
17710: LD_VAR 0 10
17714: PPUSH
17715: CALL_OW 255
17719: PPUSH
17720: LD_VAR 0 13
17724: PPUSH
17725: CALL_OW 325
17729: NOT
17730: AND
17731: IFFALSE 17760
// missile := Replace ( missile , missile + 1 , 3 ) ;
17733: LD_ADDR_VAR 0 14
17737: PUSH
17738: LD_VAR 0 14
17742: PPUSH
17743: LD_VAR 0 14
17747: PUSH
17748: LD_INT 1
17750: PLUS
17751: PPUSH
17752: LD_INT 3
17754: PPUSH
17755: CALL_OW 1
17759: ST_TO_ADDR
// if missile < 2 then
17760: LD_VAR 0 14
17764: PUSH
17765: LD_INT 2
17767: LESS
17768: IFFALSE 17772
// exit ;
17770: GO 17994
// x := GetX ( enemy ) ;
17772: LD_ADDR_VAR 0 4
17776: PUSH
17777: LD_VAR 0 10
17781: PPUSH
17782: CALL_OW 250
17786: ST_TO_ADDR
// y := GetY ( enemy ) ;
17787: LD_ADDR_VAR 0 5
17791: PUSH
17792: LD_VAR 0 10
17796: PPUSH
17797: CALL_OW 251
17801: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
17802: LD_ADDR_VAR 0 6
17806: PUSH
17807: LD_VAR 0 4
17811: PUSH
17812: LD_INT 1
17814: NEG
17815: PPUSH
17816: LD_INT 1
17818: PPUSH
17819: CALL_OW 12
17823: PLUS
17824: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
17825: LD_ADDR_VAR 0 7
17829: PUSH
17830: LD_VAR 0 5
17834: PUSH
17835: LD_INT 1
17837: NEG
17838: PPUSH
17839: LD_INT 1
17841: PPUSH
17842: CALL_OW 12
17846: PLUS
17847: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
17848: LD_VAR 0 6
17852: PPUSH
17853: LD_VAR 0 7
17857: PPUSH
17858: CALL_OW 488
17862: NOT
17863: IFFALSE 17885
// begin _x := x ;
17865: LD_ADDR_VAR 0 6
17869: PUSH
17870: LD_VAR 0 4
17874: ST_TO_ADDR
// _y := y ;
17875: LD_ADDR_VAR 0 7
17879: PUSH
17880: LD_VAR 0 5
17884: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
17885: LD_ADDR_VAR 0 3
17889: PUSH
17890: LD_INT 1
17892: PPUSH
17893: LD_VAR 0 14
17897: PPUSH
17898: CALL_OW 12
17902: ST_TO_ADDR
// case i of 1 :
17903: LD_VAR 0 3
17907: PUSH
17908: LD_INT 1
17910: DOUBLE
17911: EQUAL
17912: IFTRUE 17916
17914: GO 17933
17916: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
17917: LD_VAR 0 1
17921: PPUSH
17922: LD_VAR 0 10
17926: PPUSH
17927: CALL_OW 115
17931: GO 17994
17933: LD_INT 2
17935: DOUBLE
17936: EQUAL
17937: IFTRUE 17941
17939: GO 17963
17941: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
17942: LD_VAR 0 1
17946: PPUSH
17947: LD_VAR 0 6
17951: PPUSH
17952: LD_VAR 0 7
17956: PPUSH
17957: CALL_OW 153
17961: GO 17994
17963: LD_INT 3
17965: DOUBLE
17966: EQUAL
17967: IFTRUE 17971
17969: GO 17993
17971: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
17972: LD_VAR 0 1
17976: PPUSH
17977: LD_VAR 0 6
17981: PPUSH
17982: LD_VAR 0 7
17986: PPUSH
17987: CALL_OW 154
17991: GO 17994
17993: POP
// end ;
17994: LD_VAR 0 2
17998: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
17999: LD_INT 0
18001: PPUSH
18002: PPUSH
18003: PPUSH
18004: PPUSH
18005: PPUSH
18006: PPUSH
// if not unit or not building then
18007: LD_VAR 0 1
18011: NOT
18012: PUSH
18013: LD_VAR 0 2
18017: NOT
18018: OR
18019: IFFALSE 18023
// exit ;
18021: GO 18181
// x := GetX ( building ) ;
18023: LD_ADDR_VAR 0 5
18027: PUSH
18028: LD_VAR 0 2
18032: PPUSH
18033: CALL_OW 250
18037: ST_TO_ADDR
// y := GetY ( building ) ;
18038: LD_ADDR_VAR 0 6
18042: PUSH
18043: LD_VAR 0 2
18047: PPUSH
18048: CALL_OW 251
18052: ST_TO_ADDR
// for i = 0 to 5 do
18053: LD_ADDR_VAR 0 4
18057: PUSH
18058: DOUBLE
18059: LD_INT 0
18061: DEC
18062: ST_TO_ADDR
18063: LD_INT 5
18065: PUSH
18066: FOR_TO
18067: IFFALSE 18179
// begin _x := ShiftX ( x , i , 3 ) ;
18069: LD_ADDR_VAR 0 7
18073: PUSH
18074: LD_VAR 0 5
18078: PPUSH
18079: LD_VAR 0 4
18083: PPUSH
18084: LD_INT 3
18086: PPUSH
18087: CALL_OW 272
18091: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
18092: LD_ADDR_VAR 0 8
18096: PUSH
18097: LD_VAR 0 6
18101: PPUSH
18102: LD_VAR 0 4
18106: PPUSH
18107: LD_INT 3
18109: PPUSH
18110: CALL_OW 273
18114: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
18115: LD_VAR 0 7
18119: PPUSH
18120: LD_VAR 0 8
18124: PPUSH
18125: CALL_OW 488
18129: NOT
18130: IFFALSE 18134
// continue ;
18132: GO 18066
// if HexInfo ( _x , _y ) = 0 then
18134: LD_VAR 0 7
18138: PPUSH
18139: LD_VAR 0 8
18143: PPUSH
18144: CALL_OW 428
18148: PUSH
18149: LD_INT 0
18151: EQUAL
18152: IFFALSE 18177
// begin ComMoveXY ( unit , _x , _y ) ;
18154: LD_VAR 0 1
18158: PPUSH
18159: LD_VAR 0 7
18163: PPUSH
18164: LD_VAR 0 8
18168: PPUSH
18169: CALL_OW 111
// exit ;
18173: POP
18174: POP
18175: GO 18181
// end ; end ;
18177: GO 18066
18179: POP
18180: POP
// end ;
18181: LD_VAR 0 3
18185: RET
// export function ScanBase ( side , base_area ) ; begin
18186: LD_INT 0
18188: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
18189: LD_ADDR_VAR 0 3
18193: PUSH
18194: LD_VAR 0 2
18198: PPUSH
18199: LD_INT 81
18201: PUSH
18202: LD_VAR 0 1
18206: PUSH
18207: EMPTY
18208: LIST
18209: LIST
18210: PPUSH
18211: CALL_OW 70
18215: ST_TO_ADDR
// end ;
18216: LD_VAR 0 3
18220: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
18221: LD_INT 0
18223: PPUSH
18224: PPUSH
18225: PPUSH
18226: PPUSH
// result := false ;
18227: LD_ADDR_VAR 0 2
18231: PUSH
18232: LD_INT 0
18234: ST_TO_ADDR
// side := GetSide ( unit ) ;
18235: LD_ADDR_VAR 0 3
18239: PUSH
18240: LD_VAR 0 1
18244: PPUSH
18245: CALL_OW 255
18249: ST_TO_ADDR
// nat := GetNation ( unit ) ;
18250: LD_ADDR_VAR 0 4
18254: PUSH
18255: LD_VAR 0 1
18259: PPUSH
18260: CALL_OW 248
18264: ST_TO_ADDR
// case nat of 1 :
18265: LD_VAR 0 4
18269: PUSH
18270: LD_INT 1
18272: DOUBLE
18273: EQUAL
18274: IFTRUE 18278
18276: GO 18289
18278: POP
// tech := tech_lassight ; 2 :
18279: LD_ADDR_VAR 0 5
18283: PUSH
18284: LD_INT 12
18286: ST_TO_ADDR
18287: GO 18328
18289: LD_INT 2
18291: DOUBLE
18292: EQUAL
18293: IFTRUE 18297
18295: GO 18308
18297: POP
// tech := tech_mortar ; 3 :
18298: LD_ADDR_VAR 0 5
18302: PUSH
18303: LD_INT 41
18305: ST_TO_ADDR
18306: GO 18328
18308: LD_INT 3
18310: DOUBLE
18311: EQUAL
18312: IFTRUE 18316
18314: GO 18327
18316: POP
// tech := tech_bazooka ; end ;
18317: LD_ADDR_VAR 0 5
18321: PUSH
18322: LD_INT 44
18324: ST_TO_ADDR
18325: GO 18328
18327: POP
// if Researched ( side , tech ) then
18328: LD_VAR 0 3
18332: PPUSH
18333: LD_VAR 0 5
18337: PPUSH
18338: CALL_OW 325
18342: IFFALSE 18369
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
18344: LD_ADDR_VAR 0 2
18348: PUSH
18349: LD_INT 5
18351: PUSH
18352: LD_INT 8
18354: PUSH
18355: LD_INT 9
18357: PUSH
18358: EMPTY
18359: LIST
18360: LIST
18361: LIST
18362: PUSH
18363: LD_VAR 0 4
18367: ARRAY
18368: ST_TO_ADDR
// end ;
18369: LD_VAR 0 2
18373: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
18374: LD_INT 0
18376: PPUSH
18377: PPUSH
18378: PPUSH
// if not mines then
18379: LD_VAR 0 2
18383: NOT
18384: IFFALSE 18388
// exit ;
18386: GO 18532
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18388: LD_ADDR_VAR 0 5
18392: PUSH
18393: LD_INT 81
18395: PUSH
18396: LD_VAR 0 1
18400: PUSH
18401: EMPTY
18402: LIST
18403: LIST
18404: PUSH
18405: LD_INT 3
18407: PUSH
18408: LD_INT 21
18410: PUSH
18411: LD_INT 3
18413: PUSH
18414: EMPTY
18415: LIST
18416: LIST
18417: PUSH
18418: EMPTY
18419: LIST
18420: LIST
18421: PUSH
18422: EMPTY
18423: LIST
18424: LIST
18425: PPUSH
18426: CALL_OW 69
18430: ST_TO_ADDR
// for i in mines do
18431: LD_ADDR_VAR 0 4
18435: PUSH
18436: LD_VAR 0 2
18440: PUSH
18441: FOR_IN
18442: IFFALSE 18530
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
18444: LD_VAR 0 4
18448: PUSH
18449: LD_INT 1
18451: ARRAY
18452: PPUSH
18453: LD_VAR 0 4
18457: PUSH
18458: LD_INT 2
18460: ARRAY
18461: PPUSH
18462: CALL_OW 458
18466: NOT
18467: IFFALSE 18471
// continue ;
18469: GO 18441
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
18471: LD_VAR 0 4
18475: PUSH
18476: LD_INT 1
18478: ARRAY
18479: PPUSH
18480: LD_VAR 0 4
18484: PUSH
18485: LD_INT 2
18487: ARRAY
18488: PPUSH
18489: CALL_OW 428
18493: PUSH
18494: LD_VAR 0 5
18498: IN
18499: IFFALSE 18528
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
18501: LD_VAR 0 4
18505: PUSH
18506: LD_INT 1
18508: ARRAY
18509: PPUSH
18510: LD_VAR 0 4
18514: PUSH
18515: LD_INT 2
18517: ARRAY
18518: PPUSH
18519: LD_VAR 0 1
18523: PPUSH
18524: CALL_OW 456
// end ;
18528: GO 18441
18530: POP
18531: POP
// end ;
18532: LD_VAR 0 3
18536: RET
// export function Count ( array ) ; begin
18537: LD_INT 0
18539: PPUSH
// result := array + 0 ;
18540: LD_ADDR_VAR 0 2
18544: PUSH
18545: LD_VAR 0 1
18549: PUSH
18550: LD_INT 0
18552: PLUS
18553: ST_TO_ADDR
// end ;
18554: LD_VAR 0 2
18558: RET
// export function IsEmpty ( building ) ; begin
18559: LD_INT 0
18561: PPUSH
// if not building then
18562: LD_VAR 0 1
18566: NOT
18567: IFFALSE 18571
// exit ;
18569: GO 18614
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18571: LD_ADDR_VAR 0 2
18575: PUSH
18576: LD_VAR 0 1
18580: PUSH
18581: LD_INT 22
18583: PUSH
18584: LD_VAR 0 1
18588: PPUSH
18589: CALL_OW 255
18593: PUSH
18594: EMPTY
18595: LIST
18596: LIST
18597: PUSH
18598: LD_INT 58
18600: PUSH
18601: EMPTY
18602: LIST
18603: PUSH
18604: EMPTY
18605: LIST
18606: LIST
18607: PPUSH
18608: CALL_OW 69
18612: IN
18613: ST_TO_ADDR
// end ;
18614: LD_VAR 0 2
18618: RET
// export function IsNotFull ( building ) ; var places ; begin
18619: LD_INT 0
18621: PPUSH
18622: PPUSH
// if not building then
18623: LD_VAR 0 1
18627: NOT
18628: IFFALSE 18632
// exit ;
18630: GO 18660
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
18632: LD_ADDR_VAR 0 2
18636: PUSH
18637: LD_VAR 0 1
18641: PPUSH
18642: LD_INT 3
18644: PUSH
18645: LD_INT 62
18647: PUSH
18648: EMPTY
18649: LIST
18650: PUSH
18651: EMPTY
18652: LIST
18653: LIST
18654: PPUSH
18655: CALL_OW 72
18659: ST_TO_ADDR
// end ;
18660: LD_VAR 0 2
18664: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18665: LD_INT 0
18667: PPUSH
18668: PPUSH
18669: PPUSH
18670: PPUSH
// tmp := [ ] ;
18671: LD_ADDR_VAR 0 3
18675: PUSH
18676: EMPTY
18677: ST_TO_ADDR
// list := [ ] ;
18678: LD_ADDR_VAR 0 5
18682: PUSH
18683: EMPTY
18684: ST_TO_ADDR
// for i = 16 to 25 do
18685: LD_ADDR_VAR 0 4
18689: PUSH
18690: DOUBLE
18691: LD_INT 16
18693: DEC
18694: ST_TO_ADDR
18695: LD_INT 25
18697: PUSH
18698: FOR_TO
18699: IFFALSE 18772
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18701: LD_ADDR_VAR 0 3
18705: PUSH
18706: LD_VAR 0 3
18710: PUSH
18711: LD_INT 22
18713: PUSH
18714: LD_VAR 0 1
18718: PPUSH
18719: CALL_OW 255
18723: PUSH
18724: EMPTY
18725: LIST
18726: LIST
18727: PUSH
18728: LD_INT 91
18730: PUSH
18731: LD_VAR 0 1
18735: PUSH
18736: LD_INT 6
18738: PUSH
18739: EMPTY
18740: LIST
18741: LIST
18742: LIST
18743: PUSH
18744: LD_INT 30
18746: PUSH
18747: LD_VAR 0 4
18751: PUSH
18752: EMPTY
18753: LIST
18754: LIST
18755: PUSH
18756: EMPTY
18757: LIST
18758: LIST
18759: LIST
18760: PUSH
18761: EMPTY
18762: LIST
18763: PPUSH
18764: CALL_OW 69
18768: ADD
18769: ST_TO_ADDR
18770: GO 18698
18772: POP
18773: POP
// for i = 1 to tmp do
18774: LD_ADDR_VAR 0 4
18778: PUSH
18779: DOUBLE
18780: LD_INT 1
18782: DEC
18783: ST_TO_ADDR
18784: LD_VAR 0 3
18788: PUSH
18789: FOR_TO
18790: IFFALSE 18878
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18792: LD_ADDR_VAR 0 5
18796: PUSH
18797: LD_VAR 0 5
18801: PUSH
18802: LD_VAR 0 3
18806: PUSH
18807: LD_VAR 0 4
18811: ARRAY
18812: PPUSH
18813: CALL_OW 266
18817: PUSH
18818: LD_VAR 0 3
18822: PUSH
18823: LD_VAR 0 4
18827: ARRAY
18828: PPUSH
18829: CALL_OW 250
18833: PUSH
18834: LD_VAR 0 3
18838: PUSH
18839: LD_VAR 0 4
18843: ARRAY
18844: PPUSH
18845: CALL_OW 251
18849: PUSH
18850: LD_VAR 0 3
18854: PUSH
18855: LD_VAR 0 4
18859: ARRAY
18860: PPUSH
18861: CALL_OW 254
18865: PUSH
18866: EMPTY
18867: LIST
18868: LIST
18869: LIST
18870: LIST
18871: PUSH
18872: EMPTY
18873: LIST
18874: ADD
18875: ST_TO_ADDR
18876: GO 18789
18878: POP
18879: POP
// result := list ;
18880: LD_ADDR_VAR 0 2
18884: PUSH
18885: LD_VAR 0 5
18889: ST_TO_ADDR
// end ;
18890: LD_VAR 0 2
18894: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18895: LD_INT 0
18897: PPUSH
18898: PPUSH
18899: PPUSH
18900: PPUSH
18901: PPUSH
18902: PPUSH
18903: PPUSH
// if not factory then
18904: LD_VAR 0 1
18908: NOT
18909: IFFALSE 18913
// exit ;
18911: GO 19506
// if control = control_apeman then
18913: LD_VAR 0 4
18917: PUSH
18918: LD_INT 5
18920: EQUAL
18921: IFFALSE 19030
// begin tmp := UnitsInside ( factory ) ;
18923: LD_ADDR_VAR 0 8
18927: PUSH
18928: LD_VAR 0 1
18932: PPUSH
18933: CALL_OW 313
18937: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18938: LD_VAR 0 8
18942: PPUSH
18943: LD_INT 25
18945: PUSH
18946: LD_INT 12
18948: PUSH
18949: EMPTY
18950: LIST
18951: LIST
18952: PPUSH
18953: CALL_OW 72
18957: NOT
18958: IFFALSE 18968
// control := control_manual ;
18960: LD_ADDR_VAR 0 4
18964: PUSH
18965: LD_INT 1
18967: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18968: LD_ADDR_VAR 0 8
18972: PUSH
18973: LD_VAR 0 1
18977: PPUSH
18978: CALL 18665 0 1
18982: ST_TO_ADDR
// if tmp then
18983: LD_VAR 0 8
18987: IFFALSE 19030
// begin for i in tmp do
18989: LD_ADDR_VAR 0 7
18993: PUSH
18994: LD_VAR 0 8
18998: PUSH
18999: FOR_IN
19000: IFFALSE 19028
// if i [ 1 ] = b_ext_radio then
19002: LD_VAR 0 7
19006: PUSH
19007: LD_INT 1
19009: ARRAY
19010: PUSH
19011: LD_INT 22
19013: EQUAL
19014: IFFALSE 19026
// begin control := control_remote ;
19016: LD_ADDR_VAR 0 4
19020: PUSH
19021: LD_INT 2
19023: ST_TO_ADDR
// break ;
19024: GO 19028
// end ;
19026: GO 18999
19028: POP
19029: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19030: LD_VAR 0 1
19034: PPUSH
19035: LD_VAR 0 2
19039: PPUSH
19040: LD_VAR 0 3
19044: PPUSH
19045: LD_VAR 0 4
19049: PPUSH
19050: LD_VAR 0 5
19054: PPUSH
19055: CALL_OW 448
19059: IFFALSE 19094
// begin result := [ chassis , engine , control , weapon ] ;
19061: LD_ADDR_VAR 0 6
19065: PUSH
19066: LD_VAR 0 2
19070: PUSH
19071: LD_VAR 0 3
19075: PUSH
19076: LD_VAR 0 4
19080: PUSH
19081: LD_VAR 0 5
19085: PUSH
19086: EMPTY
19087: LIST
19088: LIST
19089: LIST
19090: LIST
19091: ST_TO_ADDR
// exit ;
19092: GO 19506
// end ; _chassis := AvailableChassisList ( factory ) ;
19094: LD_ADDR_VAR 0 9
19098: PUSH
19099: LD_VAR 0 1
19103: PPUSH
19104: CALL_OW 475
19108: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
19109: LD_ADDR_VAR 0 11
19113: PUSH
19114: LD_VAR 0 1
19118: PPUSH
19119: CALL_OW 476
19123: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
19124: LD_ADDR_VAR 0 12
19128: PUSH
19129: LD_VAR 0 1
19133: PPUSH
19134: CALL_OW 477
19138: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
19139: LD_ADDR_VAR 0 10
19143: PUSH
19144: LD_VAR 0 1
19148: PPUSH
19149: CALL_OW 478
19153: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
19154: LD_VAR 0 9
19158: NOT
19159: PUSH
19160: LD_VAR 0 11
19164: NOT
19165: OR
19166: PUSH
19167: LD_VAR 0 12
19171: NOT
19172: OR
19173: PUSH
19174: LD_VAR 0 10
19178: NOT
19179: OR
19180: IFFALSE 19215
// begin result := [ chassis , engine , control , weapon ] ;
19182: LD_ADDR_VAR 0 6
19186: PUSH
19187: LD_VAR 0 2
19191: PUSH
19192: LD_VAR 0 3
19196: PUSH
19197: LD_VAR 0 4
19201: PUSH
19202: LD_VAR 0 5
19206: PUSH
19207: EMPTY
19208: LIST
19209: LIST
19210: LIST
19211: LIST
19212: ST_TO_ADDR
// exit ;
19213: GO 19506
// end ; if not chassis in _chassis then
19215: LD_VAR 0 2
19219: PUSH
19220: LD_VAR 0 9
19224: IN
19225: NOT
19226: IFFALSE 19252
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
19228: LD_ADDR_VAR 0 2
19232: PUSH
19233: LD_VAR 0 9
19237: PUSH
19238: LD_INT 1
19240: PPUSH
19241: LD_VAR 0 9
19245: PPUSH
19246: CALL_OW 12
19250: ARRAY
19251: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
19252: LD_VAR 0 2
19256: PPUSH
19257: LD_VAR 0 3
19261: PPUSH
19262: CALL 19511 0 2
19266: NOT
19267: IFFALSE 19326
// repeat engine := _engine [ 1 ] ;
19269: LD_ADDR_VAR 0 3
19273: PUSH
19274: LD_VAR 0 11
19278: PUSH
19279: LD_INT 1
19281: ARRAY
19282: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
19283: LD_ADDR_VAR 0 11
19287: PUSH
19288: LD_VAR 0 11
19292: PPUSH
19293: LD_INT 1
19295: PPUSH
19296: CALL_OW 3
19300: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
19301: LD_VAR 0 2
19305: PPUSH
19306: LD_VAR 0 3
19310: PPUSH
19311: CALL 19511 0 2
19315: PUSH
19316: LD_VAR 0 11
19320: PUSH
19321: EMPTY
19322: EQUAL
19323: OR
19324: IFFALSE 19269
// if not control in _control then
19326: LD_VAR 0 4
19330: PUSH
19331: LD_VAR 0 12
19335: IN
19336: NOT
19337: IFFALSE 19363
// control := _control [ rand ( 1 , _control ) ] ;
19339: LD_ADDR_VAR 0 4
19343: PUSH
19344: LD_VAR 0 12
19348: PUSH
19349: LD_INT 1
19351: PPUSH
19352: LD_VAR 0 12
19356: PPUSH
19357: CALL_OW 12
19361: ARRAY
19362: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
19363: LD_VAR 0 2
19367: PPUSH
19368: LD_VAR 0 5
19372: PPUSH
19373: CALL 19731 0 2
19377: NOT
19378: IFFALSE 19437
// repeat weapon := _weapon [ 1 ] ;
19380: LD_ADDR_VAR 0 5
19384: PUSH
19385: LD_VAR 0 10
19389: PUSH
19390: LD_INT 1
19392: ARRAY
19393: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
19394: LD_ADDR_VAR 0 10
19398: PUSH
19399: LD_VAR 0 10
19403: PPUSH
19404: LD_INT 1
19406: PPUSH
19407: CALL_OW 3
19411: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
19412: LD_VAR 0 2
19416: PPUSH
19417: LD_VAR 0 5
19421: PPUSH
19422: CALL 19731 0 2
19426: PUSH
19427: LD_VAR 0 10
19431: PUSH
19432: EMPTY
19433: EQUAL
19434: OR
19435: IFFALSE 19380
// result := [ ] ;
19437: LD_ADDR_VAR 0 6
19441: PUSH
19442: EMPTY
19443: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19444: LD_VAR 0 1
19448: PPUSH
19449: LD_VAR 0 2
19453: PPUSH
19454: LD_VAR 0 3
19458: PPUSH
19459: LD_VAR 0 4
19463: PPUSH
19464: LD_VAR 0 5
19468: PPUSH
19469: CALL_OW 448
19473: IFFALSE 19506
// result := [ chassis , engine , control , weapon ] ;
19475: LD_ADDR_VAR 0 6
19479: PUSH
19480: LD_VAR 0 2
19484: PUSH
19485: LD_VAR 0 3
19489: PUSH
19490: LD_VAR 0 4
19494: PUSH
19495: LD_VAR 0 5
19499: PUSH
19500: EMPTY
19501: LIST
19502: LIST
19503: LIST
19504: LIST
19505: ST_TO_ADDR
// end ;
19506: LD_VAR 0 6
19510: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
19511: LD_INT 0
19513: PPUSH
// if not chassis or not engine then
19514: LD_VAR 0 1
19518: NOT
19519: PUSH
19520: LD_VAR 0 2
19524: NOT
19525: OR
19526: IFFALSE 19530
// exit ;
19528: GO 19726
// case engine of engine_solar :
19530: LD_VAR 0 2
19534: PUSH
19535: LD_INT 2
19537: DOUBLE
19538: EQUAL
19539: IFTRUE 19543
19541: GO 19581
19543: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19544: LD_ADDR_VAR 0 3
19548: PUSH
19549: LD_INT 11
19551: PUSH
19552: LD_INT 12
19554: PUSH
19555: LD_INT 13
19557: PUSH
19558: LD_INT 14
19560: PUSH
19561: LD_INT 1
19563: PUSH
19564: LD_INT 2
19566: PUSH
19567: LD_INT 3
19569: PUSH
19570: EMPTY
19571: LIST
19572: LIST
19573: LIST
19574: LIST
19575: LIST
19576: LIST
19577: LIST
19578: ST_TO_ADDR
19579: GO 19710
19581: LD_INT 1
19583: DOUBLE
19584: EQUAL
19585: IFTRUE 19589
19587: GO 19651
19589: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19590: LD_ADDR_VAR 0 3
19594: PUSH
19595: LD_INT 11
19597: PUSH
19598: LD_INT 12
19600: PUSH
19601: LD_INT 13
19603: PUSH
19604: LD_INT 14
19606: PUSH
19607: LD_INT 1
19609: PUSH
19610: LD_INT 2
19612: PUSH
19613: LD_INT 3
19615: PUSH
19616: LD_INT 4
19618: PUSH
19619: LD_INT 5
19621: PUSH
19622: LD_INT 21
19624: PUSH
19625: LD_INT 23
19627: PUSH
19628: LD_INT 22
19630: PUSH
19631: LD_INT 24
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: LIST
19638: LIST
19639: LIST
19640: LIST
19641: LIST
19642: LIST
19643: LIST
19644: LIST
19645: LIST
19646: LIST
19647: LIST
19648: ST_TO_ADDR
19649: GO 19710
19651: LD_INT 3
19653: DOUBLE
19654: EQUAL
19655: IFTRUE 19659
19657: GO 19709
19659: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19660: LD_ADDR_VAR 0 3
19664: PUSH
19665: LD_INT 13
19667: PUSH
19668: LD_INT 14
19670: PUSH
19671: LD_INT 2
19673: PUSH
19674: LD_INT 3
19676: PUSH
19677: LD_INT 4
19679: PUSH
19680: LD_INT 5
19682: PUSH
19683: LD_INT 21
19685: PUSH
19686: LD_INT 22
19688: PUSH
19689: LD_INT 23
19691: PUSH
19692: LD_INT 24
19694: PUSH
19695: EMPTY
19696: LIST
19697: LIST
19698: LIST
19699: LIST
19700: LIST
19701: LIST
19702: LIST
19703: LIST
19704: LIST
19705: LIST
19706: ST_TO_ADDR
19707: GO 19710
19709: POP
// result := ( chassis in result ) ;
19710: LD_ADDR_VAR 0 3
19714: PUSH
19715: LD_VAR 0 1
19719: PUSH
19720: LD_VAR 0 3
19724: IN
19725: ST_TO_ADDR
// end ;
19726: LD_VAR 0 3
19730: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19731: LD_INT 0
19733: PPUSH
// if not chassis or not weapon then
19734: LD_VAR 0 1
19738: NOT
19739: PUSH
19740: LD_VAR 0 2
19744: NOT
19745: OR
19746: IFFALSE 19750
// exit ;
19748: GO 20810
// case weapon of us_machine_gun :
19750: LD_VAR 0 2
19754: PUSH
19755: LD_INT 2
19757: DOUBLE
19758: EQUAL
19759: IFTRUE 19763
19761: GO 19793
19763: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19764: LD_ADDR_VAR 0 3
19768: PUSH
19769: LD_INT 1
19771: PUSH
19772: LD_INT 2
19774: PUSH
19775: LD_INT 3
19777: PUSH
19778: LD_INT 4
19780: PUSH
19781: LD_INT 5
19783: PUSH
19784: EMPTY
19785: LIST
19786: LIST
19787: LIST
19788: LIST
19789: LIST
19790: ST_TO_ADDR
19791: GO 20794
19793: LD_INT 3
19795: DOUBLE
19796: EQUAL
19797: IFTRUE 19801
19799: GO 19831
19801: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19802: LD_ADDR_VAR 0 3
19806: PUSH
19807: LD_INT 1
19809: PUSH
19810: LD_INT 2
19812: PUSH
19813: LD_INT 3
19815: PUSH
19816: LD_INT 4
19818: PUSH
19819: LD_INT 5
19821: PUSH
19822: EMPTY
19823: LIST
19824: LIST
19825: LIST
19826: LIST
19827: LIST
19828: ST_TO_ADDR
19829: GO 20794
19831: LD_INT 11
19833: DOUBLE
19834: EQUAL
19835: IFTRUE 19839
19837: GO 19869
19839: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19840: LD_ADDR_VAR 0 3
19844: PUSH
19845: LD_INT 1
19847: PUSH
19848: LD_INT 2
19850: PUSH
19851: LD_INT 3
19853: PUSH
19854: LD_INT 4
19856: PUSH
19857: LD_INT 5
19859: PUSH
19860: EMPTY
19861: LIST
19862: LIST
19863: LIST
19864: LIST
19865: LIST
19866: ST_TO_ADDR
19867: GO 20794
19869: LD_INT 4
19871: DOUBLE
19872: EQUAL
19873: IFTRUE 19877
19875: GO 19903
19877: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19878: LD_ADDR_VAR 0 3
19882: PUSH
19883: LD_INT 2
19885: PUSH
19886: LD_INT 3
19888: PUSH
19889: LD_INT 4
19891: PUSH
19892: LD_INT 5
19894: PUSH
19895: EMPTY
19896: LIST
19897: LIST
19898: LIST
19899: LIST
19900: ST_TO_ADDR
19901: GO 20794
19903: LD_INT 5
19905: DOUBLE
19906: EQUAL
19907: IFTRUE 19911
19909: GO 19937
19911: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19912: LD_ADDR_VAR 0 3
19916: PUSH
19917: LD_INT 2
19919: PUSH
19920: LD_INT 3
19922: PUSH
19923: LD_INT 4
19925: PUSH
19926: LD_INT 5
19928: PUSH
19929: EMPTY
19930: LIST
19931: LIST
19932: LIST
19933: LIST
19934: ST_TO_ADDR
19935: GO 20794
19937: LD_INT 9
19939: DOUBLE
19940: EQUAL
19941: IFTRUE 19945
19943: GO 19971
19945: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19946: LD_ADDR_VAR 0 3
19950: PUSH
19951: LD_INT 2
19953: PUSH
19954: LD_INT 3
19956: PUSH
19957: LD_INT 4
19959: PUSH
19960: LD_INT 5
19962: PUSH
19963: EMPTY
19964: LIST
19965: LIST
19966: LIST
19967: LIST
19968: ST_TO_ADDR
19969: GO 20794
19971: LD_INT 7
19973: DOUBLE
19974: EQUAL
19975: IFTRUE 19979
19977: GO 20005
19979: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19980: LD_ADDR_VAR 0 3
19984: PUSH
19985: LD_INT 2
19987: PUSH
19988: LD_INT 3
19990: PUSH
19991: LD_INT 4
19993: PUSH
19994: LD_INT 5
19996: PUSH
19997: EMPTY
19998: LIST
19999: LIST
20000: LIST
20001: LIST
20002: ST_TO_ADDR
20003: GO 20794
20005: LD_INT 12
20007: DOUBLE
20008: EQUAL
20009: IFTRUE 20013
20011: GO 20039
20013: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
20014: LD_ADDR_VAR 0 3
20018: PUSH
20019: LD_INT 2
20021: PUSH
20022: LD_INT 3
20024: PUSH
20025: LD_INT 4
20027: PUSH
20028: LD_INT 5
20030: PUSH
20031: EMPTY
20032: LIST
20033: LIST
20034: LIST
20035: LIST
20036: ST_TO_ADDR
20037: GO 20794
20039: LD_INT 13
20041: DOUBLE
20042: EQUAL
20043: IFTRUE 20047
20045: GO 20073
20047: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
20048: LD_ADDR_VAR 0 3
20052: PUSH
20053: LD_INT 2
20055: PUSH
20056: LD_INT 3
20058: PUSH
20059: LD_INT 4
20061: PUSH
20062: LD_INT 5
20064: PUSH
20065: EMPTY
20066: LIST
20067: LIST
20068: LIST
20069: LIST
20070: ST_TO_ADDR
20071: GO 20794
20073: LD_INT 14
20075: DOUBLE
20076: EQUAL
20077: IFTRUE 20081
20079: GO 20099
20081: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
20082: LD_ADDR_VAR 0 3
20086: PUSH
20087: LD_INT 4
20089: PUSH
20090: LD_INT 5
20092: PUSH
20093: EMPTY
20094: LIST
20095: LIST
20096: ST_TO_ADDR
20097: GO 20794
20099: LD_INT 6
20101: DOUBLE
20102: EQUAL
20103: IFTRUE 20107
20105: GO 20125
20107: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
20108: LD_ADDR_VAR 0 3
20112: PUSH
20113: LD_INT 4
20115: PUSH
20116: LD_INT 5
20118: PUSH
20119: EMPTY
20120: LIST
20121: LIST
20122: ST_TO_ADDR
20123: GO 20794
20125: LD_INT 10
20127: DOUBLE
20128: EQUAL
20129: IFTRUE 20133
20131: GO 20151
20133: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
20134: LD_ADDR_VAR 0 3
20138: PUSH
20139: LD_INT 4
20141: PUSH
20142: LD_INT 5
20144: PUSH
20145: EMPTY
20146: LIST
20147: LIST
20148: ST_TO_ADDR
20149: GO 20794
20151: LD_INT 22
20153: DOUBLE
20154: EQUAL
20155: IFTRUE 20159
20157: GO 20185
20159: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
20160: LD_ADDR_VAR 0 3
20164: PUSH
20165: LD_INT 11
20167: PUSH
20168: LD_INT 12
20170: PUSH
20171: LD_INT 13
20173: PUSH
20174: LD_INT 14
20176: PUSH
20177: EMPTY
20178: LIST
20179: LIST
20180: LIST
20181: LIST
20182: ST_TO_ADDR
20183: GO 20794
20185: LD_INT 23
20187: DOUBLE
20188: EQUAL
20189: IFTRUE 20193
20191: GO 20219
20193: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
20194: LD_ADDR_VAR 0 3
20198: PUSH
20199: LD_INT 11
20201: PUSH
20202: LD_INT 12
20204: PUSH
20205: LD_INT 13
20207: PUSH
20208: LD_INT 14
20210: PUSH
20211: EMPTY
20212: LIST
20213: LIST
20214: LIST
20215: LIST
20216: ST_TO_ADDR
20217: GO 20794
20219: LD_INT 24
20221: DOUBLE
20222: EQUAL
20223: IFTRUE 20227
20225: GO 20253
20227: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
20228: LD_ADDR_VAR 0 3
20232: PUSH
20233: LD_INT 11
20235: PUSH
20236: LD_INT 12
20238: PUSH
20239: LD_INT 13
20241: PUSH
20242: LD_INT 14
20244: PUSH
20245: EMPTY
20246: LIST
20247: LIST
20248: LIST
20249: LIST
20250: ST_TO_ADDR
20251: GO 20794
20253: LD_INT 30
20255: DOUBLE
20256: EQUAL
20257: IFTRUE 20261
20259: GO 20287
20261: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
20262: LD_ADDR_VAR 0 3
20266: PUSH
20267: LD_INT 11
20269: PUSH
20270: LD_INT 12
20272: PUSH
20273: LD_INT 13
20275: PUSH
20276: LD_INT 14
20278: PUSH
20279: EMPTY
20280: LIST
20281: LIST
20282: LIST
20283: LIST
20284: ST_TO_ADDR
20285: GO 20794
20287: LD_INT 25
20289: DOUBLE
20290: EQUAL
20291: IFTRUE 20295
20293: GO 20313
20295: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
20296: LD_ADDR_VAR 0 3
20300: PUSH
20301: LD_INT 13
20303: PUSH
20304: LD_INT 14
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: ST_TO_ADDR
20311: GO 20794
20313: LD_INT 27
20315: DOUBLE
20316: EQUAL
20317: IFTRUE 20321
20319: GO 20339
20321: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
20322: LD_ADDR_VAR 0 3
20326: PUSH
20327: LD_INT 13
20329: PUSH
20330: LD_INT 14
20332: PUSH
20333: EMPTY
20334: LIST
20335: LIST
20336: ST_TO_ADDR
20337: GO 20794
20339: LD_INT 92
20341: DOUBLE
20342: EQUAL
20343: IFTRUE 20347
20345: GO 20373
20347: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
20348: LD_ADDR_VAR 0 3
20352: PUSH
20353: LD_INT 11
20355: PUSH
20356: LD_INT 12
20358: PUSH
20359: LD_INT 13
20361: PUSH
20362: LD_INT 14
20364: PUSH
20365: EMPTY
20366: LIST
20367: LIST
20368: LIST
20369: LIST
20370: ST_TO_ADDR
20371: GO 20794
20373: LD_INT 28
20375: DOUBLE
20376: EQUAL
20377: IFTRUE 20381
20379: GO 20399
20381: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
20382: LD_ADDR_VAR 0 3
20386: PUSH
20387: LD_INT 13
20389: PUSH
20390: LD_INT 14
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: ST_TO_ADDR
20397: GO 20794
20399: LD_INT 29
20401: DOUBLE
20402: EQUAL
20403: IFTRUE 20407
20405: GO 20425
20407: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
20408: LD_ADDR_VAR 0 3
20412: PUSH
20413: LD_INT 13
20415: PUSH
20416: LD_INT 14
20418: PUSH
20419: EMPTY
20420: LIST
20421: LIST
20422: ST_TO_ADDR
20423: GO 20794
20425: LD_INT 31
20427: DOUBLE
20428: EQUAL
20429: IFTRUE 20433
20431: GO 20451
20433: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
20434: LD_ADDR_VAR 0 3
20438: PUSH
20439: LD_INT 13
20441: PUSH
20442: LD_INT 14
20444: PUSH
20445: EMPTY
20446: LIST
20447: LIST
20448: ST_TO_ADDR
20449: GO 20794
20451: LD_INT 26
20453: DOUBLE
20454: EQUAL
20455: IFTRUE 20459
20457: GO 20477
20459: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
20460: LD_ADDR_VAR 0 3
20464: PUSH
20465: LD_INT 13
20467: PUSH
20468: LD_INT 14
20470: PUSH
20471: EMPTY
20472: LIST
20473: LIST
20474: ST_TO_ADDR
20475: GO 20794
20477: LD_INT 42
20479: DOUBLE
20480: EQUAL
20481: IFTRUE 20485
20483: GO 20511
20485: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
20486: LD_ADDR_VAR 0 3
20490: PUSH
20491: LD_INT 21
20493: PUSH
20494: LD_INT 22
20496: PUSH
20497: LD_INT 23
20499: PUSH
20500: LD_INT 24
20502: PUSH
20503: EMPTY
20504: LIST
20505: LIST
20506: LIST
20507: LIST
20508: ST_TO_ADDR
20509: GO 20794
20511: LD_INT 43
20513: DOUBLE
20514: EQUAL
20515: IFTRUE 20519
20517: GO 20545
20519: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
20520: LD_ADDR_VAR 0 3
20524: PUSH
20525: LD_INT 21
20527: PUSH
20528: LD_INT 22
20530: PUSH
20531: LD_INT 23
20533: PUSH
20534: LD_INT 24
20536: PUSH
20537: EMPTY
20538: LIST
20539: LIST
20540: LIST
20541: LIST
20542: ST_TO_ADDR
20543: GO 20794
20545: LD_INT 44
20547: DOUBLE
20548: EQUAL
20549: IFTRUE 20553
20551: GO 20579
20553: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
20554: LD_ADDR_VAR 0 3
20558: PUSH
20559: LD_INT 21
20561: PUSH
20562: LD_INT 22
20564: PUSH
20565: LD_INT 23
20567: PUSH
20568: LD_INT 24
20570: PUSH
20571: EMPTY
20572: LIST
20573: LIST
20574: LIST
20575: LIST
20576: ST_TO_ADDR
20577: GO 20794
20579: LD_INT 45
20581: DOUBLE
20582: EQUAL
20583: IFTRUE 20587
20585: GO 20613
20587: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20588: LD_ADDR_VAR 0 3
20592: PUSH
20593: LD_INT 21
20595: PUSH
20596: LD_INT 22
20598: PUSH
20599: LD_INT 23
20601: PUSH
20602: LD_INT 24
20604: PUSH
20605: EMPTY
20606: LIST
20607: LIST
20608: LIST
20609: LIST
20610: ST_TO_ADDR
20611: GO 20794
20613: LD_INT 49
20615: DOUBLE
20616: EQUAL
20617: IFTRUE 20621
20619: GO 20647
20621: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20622: LD_ADDR_VAR 0 3
20626: PUSH
20627: LD_INT 21
20629: PUSH
20630: LD_INT 22
20632: PUSH
20633: LD_INT 23
20635: PUSH
20636: LD_INT 24
20638: PUSH
20639: EMPTY
20640: LIST
20641: LIST
20642: LIST
20643: LIST
20644: ST_TO_ADDR
20645: GO 20794
20647: LD_INT 51
20649: DOUBLE
20650: EQUAL
20651: IFTRUE 20655
20653: GO 20681
20655: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20656: LD_ADDR_VAR 0 3
20660: PUSH
20661: LD_INT 21
20663: PUSH
20664: LD_INT 22
20666: PUSH
20667: LD_INT 23
20669: PUSH
20670: LD_INT 24
20672: PUSH
20673: EMPTY
20674: LIST
20675: LIST
20676: LIST
20677: LIST
20678: ST_TO_ADDR
20679: GO 20794
20681: LD_INT 52
20683: DOUBLE
20684: EQUAL
20685: IFTRUE 20689
20687: GO 20715
20689: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20690: LD_ADDR_VAR 0 3
20694: PUSH
20695: LD_INT 21
20697: PUSH
20698: LD_INT 22
20700: PUSH
20701: LD_INT 23
20703: PUSH
20704: LD_INT 24
20706: PUSH
20707: EMPTY
20708: LIST
20709: LIST
20710: LIST
20711: LIST
20712: ST_TO_ADDR
20713: GO 20794
20715: LD_INT 53
20717: DOUBLE
20718: EQUAL
20719: IFTRUE 20723
20721: GO 20741
20723: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20724: LD_ADDR_VAR 0 3
20728: PUSH
20729: LD_INT 23
20731: PUSH
20732: LD_INT 24
20734: PUSH
20735: EMPTY
20736: LIST
20737: LIST
20738: ST_TO_ADDR
20739: GO 20794
20741: LD_INT 46
20743: DOUBLE
20744: EQUAL
20745: IFTRUE 20749
20747: GO 20767
20749: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20750: LD_ADDR_VAR 0 3
20754: PUSH
20755: LD_INT 23
20757: PUSH
20758: LD_INT 24
20760: PUSH
20761: EMPTY
20762: LIST
20763: LIST
20764: ST_TO_ADDR
20765: GO 20794
20767: LD_INT 47
20769: DOUBLE
20770: EQUAL
20771: IFTRUE 20775
20773: GO 20793
20775: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20776: LD_ADDR_VAR 0 3
20780: PUSH
20781: LD_INT 23
20783: PUSH
20784: LD_INT 24
20786: PUSH
20787: EMPTY
20788: LIST
20789: LIST
20790: ST_TO_ADDR
20791: GO 20794
20793: POP
// result := ( chassis in result ) ;
20794: LD_ADDR_VAR 0 3
20798: PUSH
20799: LD_VAR 0 1
20803: PUSH
20804: LD_VAR 0 3
20808: IN
20809: ST_TO_ADDR
// end ;
20810: LD_VAR 0 3
20814: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20815: LD_INT 0
20817: PPUSH
20818: PPUSH
20819: PPUSH
20820: PPUSH
20821: PPUSH
20822: PPUSH
20823: PPUSH
// result := array ;
20824: LD_ADDR_VAR 0 5
20828: PUSH
20829: LD_VAR 0 1
20833: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20834: LD_VAR 0 1
20838: NOT
20839: PUSH
20840: LD_VAR 0 2
20844: NOT
20845: OR
20846: PUSH
20847: LD_VAR 0 3
20851: NOT
20852: OR
20853: PUSH
20854: LD_VAR 0 2
20858: PUSH
20859: LD_VAR 0 1
20863: GREATER
20864: OR
20865: PUSH
20866: LD_VAR 0 3
20870: PUSH
20871: LD_VAR 0 1
20875: GREATER
20876: OR
20877: IFFALSE 20881
// exit ;
20879: GO 21177
// if direction then
20881: LD_VAR 0 4
20885: IFFALSE 20949
// begin d := 1 ;
20887: LD_ADDR_VAR 0 9
20891: PUSH
20892: LD_INT 1
20894: ST_TO_ADDR
// if i_from > i_to then
20895: LD_VAR 0 2
20899: PUSH
20900: LD_VAR 0 3
20904: GREATER
20905: IFFALSE 20931
// length := ( array - i_from ) + i_to else
20907: LD_ADDR_VAR 0 11
20911: PUSH
20912: LD_VAR 0 1
20916: PUSH
20917: LD_VAR 0 2
20921: MINUS
20922: PUSH
20923: LD_VAR 0 3
20927: PLUS
20928: ST_TO_ADDR
20929: GO 20947
// length := i_to - i_from ;
20931: LD_ADDR_VAR 0 11
20935: PUSH
20936: LD_VAR 0 3
20940: PUSH
20941: LD_VAR 0 2
20945: MINUS
20946: ST_TO_ADDR
// end else
20947: GO 21010
// begin d := - 1 ;
20949: LD_ADDR_VAR 0 9
20953: PUSH
20954: LD_INT 1
20956: NEG
20957: ST_TO_ADDR
// if i_from > i_to then
20958: LD_VAR 0 2
20962: PUSH
20963: LD_VAR 0 3
20967: GREATER
20968: IFFALSE 20988
// length := i_from - i_to else
20970: LD_ADDR_VAR 0 11
20974: PUSH
20975: LD_VAR 0 2
20979: PUSH
20980: LD_VAR 0 3
20984: MINUS
20985: ST_TO_ADDR
20986: GO 21010
// length := ( array - i_to ) + i_from ;
20988: LD_ADDR_VAR 0 11
20992: PUSH
20993: LD_VAR 0 1
20997: PUSH
20998: LD_VAR 0 3
21002: MINUS
21003: PUSH
21004: LD_VAR 0 2
21008: PLUS
21009: ST_TO_ADDR
// end ; if not length then
21010: LD_VAR 0 11
21014: NOT
21015: IFFALSE 21019
// exit ;
21017: GO 21177
// tmp := array ;
21019: LD_ADDR_VAR 0 10
21023: PUSH
21024: LD_VAR 0 1
21028: ST_TO_ADDR
// for i = 1 to length do
21029: LD_ADDR_VAR 0 6
21033: PUSH
21034: DOUBLE
21035: LD_INT 1
21037: DEC
21038: ST_TO_ADDR
21039: LD_VAR 0 11
21043: PUSH
21044: FOR_TO
21045: IFFALSE 21165
// begin for j = 1 to array do
21047: LD_ADDR_VAR 0 7
21051: PUSH
21052: DOUBLE
21053: LD_INT 1
21055: DEC
21056: ST_TO_ADDR
21057: LD_VAR 0 1
21061: PUSH
21062: FOR_TO
21063: IFFALSE 21151
// begin k := j + d ;
21065: LD_ADDR_VAR 0 8
21069: PUSH
21070: LD_VAR 0 7
21074: PUSH
21075: LD_VAR 0 9
21079: PLUS
21080: ST_TO_ADDR
// if k > array then
21081: LD_VAR 0 8
21085: PUSH
21086: LD_VAR 0 1
21090: GREATER
21091: IFFALSE 21101
// k := 1 ;
21093: LD_ADDR_VAR 0 8
21097: PUSH
21098: LD_INT 1
21100: ST_TO_ADDR
// if not k then
21101: LD_VAR 0 8
21105: NOT
21106: IFFALSE 21118
// k := array ;
21108: LD_ADDR_VAR 0 8
21112: PUSH
21113: LD_VAR 0 1
21117: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
21118: LD_ADDR_VAR 0 10
21122: PUSH
21123: LD_VAR 0 10
21127: PPUSH
21128: LD_VAR 0 8
21132: PPUSH
21133: LD_VAR 0 1
21137: PUSH
21138: LD_VAR 0 7
21142: ARRAY
21143: PPUSH
21144: CALL_OW 1
21148: ST_TO_ADDR
// end ;
21149: GO 21062
21151: POP
21152: POP
// array := tmp ;
21153: LD_ADDR_VAR 0 1
21157: PUSH
21158: LD_VAR 0 10
21162: ST_TO_ADDR
// end ;
21163: GO 21044
21165: POP
21166: POP
// result := array ;
21167: LD_ADDR_VAR 0 5
21171: PUSH
21172: LD_VAR 0 1
21176: ST_TO_ADDR
// end ;
21177: LD_VAR 0 5
21181: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
21182: LD_INT 0
21184: PPUSH
21185: PPUSH
// result := 0 ;
21186: LD_ADDR_VAR 0 3
21190: PUSH
21191: LD_INT 0
21193: ST_TO_ADDR
// if not array or not value in array then
21194: LD_VAR 0 1
21198: NOT
21199: PUSH
21200: LD_VAR 0 2
21204: PUSH
21205: LD_VAR 0 1
21209: IN
21210: NOT
21211: OR
21212: IFFALSE 21216
// exit ;
21214: GO 21270
// for i = 1 to array do
21216: LD_ADDR_VAR 0 4
21220: PUSH
21221: DOUBLE
21222: LD_INT 1
21224: DEC
21225: ST_TO_ADDR
21226: LD_VAR 0 1
21230: PUSH
21231: FOR_TO
21232: IFFALSE 21268
// if value = array [ i ] then
21234: LD_VAR 0 2
21238: PUSH
21239: LD_VAR 0 1
21243: PUSH
21244: LD_VAR 0 4
21248: ARRAY
21249: EQUAL
21250: IFFALSE 21266
// begin result := i ;
21252: LD_ADDR_VAR 0 3
21256: PUSH
21257: LD_VAR 0 4
21261: ST_TO_ADDR
// exit ;
21262: POP
21263: POP
21264: GO 21270
// end ;
21266: GO 21231
21268: POP
21269: POP
// end ;
21270: LD_VAR 0 3
21274: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
21275: LD_INT 0
21277: PPUSH
// vc_chassis := chassis ;
21278: LD_ADDR_OWVAR 37
21282: PUSH
21283: LD_VAR 0 1
21287: ST_TO_ADDR
// vc_engine := engine ;
21288: LD_ADDR_OWVAR 39
21292: PUSH
21293: LD_VAR 0 2
21297: ST_TO_ADDR
// vc_control := control ;
21298: LD_ADDR_OWVAR 38
21302: PUSH
21303: LD_VAR 0 3
21307: ST_TO_ADDR
// vc_weapon := weapon ;
21308: LD_ADDR_OWVAR 40
21312: PUSH
21313: LD_VAR 0 4
21317: ST_TO_ADDR
// vc_fuel_battery := fuel ;
21318: LD_ADDR_OWVAR 41
21322: PUSH
21323: LD_VAR 0 5
21327: ST_TO_ADDR
// end ;
21328: LD_VAR 0 6
21332: RET
// export function WantPlant ( unit ) ; var task ; begin
21333: LD_INT 0
21335: PPUSH
21336: PPUSH
// result := false ;
21337: LD_ADDR_VAR 0 2
21341: PUSH
21342: LD_INT 0
21344: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
21345: LD_ADDR_VAR 0 3
21349: PUSH
21350: LD_VAR 0 1
21354: PPUSH
21355: CALL_OW 437
21359: ST_TO_ADDR
// if task then
21360: LD_VAR 0 3
21364: IFFALSE 21392
// if task [ 1 ] [ 1 ] = p then
21366: LD_VAR 0 3
21370: PUSH
21371: LD_INT 1
21373: ARRAY
21374: PUSH
21375: LD_INT 1
21377: ARRAY
21378: PUSH
21379: LD_STRING p
21381: EQUAL
21382: IFFALSE 21392
// result := true ;
21384: LD_ADDR_VAR 0 2
21388: PUSH
21389: LD_INT 1
21391: ST_TO_ADDR
// end ;
21392: LD_VAR 0 2
21396: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
21397: LD_INT 0
21399: PPUSH
21400: PPUSH
21401: PPUSH
21402: PPUSH
// if pos < 1 then
21403: LD_VAR 0 2
21407: PUSH
21408: LD_INT 1
21410: LESS
21411: IFFALSE 21415
// exit ;
21413: GO 21718
// if pos = 1 then
21415: LD_VAR 0 2
21419: PUSH
21420: LD_INT 1
21422: EQUAL
21423: IFFALSE 21456
// result := Replace ( arr , pos [ 1 ] , value ) else
21425: LD_ADDR_VAR 0 4
21429: PUSH
21430: LD_VAR 0 1
21434: PPUSH
21435: LD_VAR 0 2
21439: PUSH
21440: LD_INT 1
21442: ARRAY
21443: PPUSH
21444: LD_VAR 0 3
21448: PPUSH
21449: CALL_OW 1
21453: ST_TO_ADDR
21454: GO 21718
// begin tmp := arr ;
21456: LD_ADDR_VAR 0 6
21460: PUSH
21461: LD_VAR 0 1
21465: ST_TO_ADDR
// s_arr := [ tmp ] ;
21466: LD_ADDR_VAR 0 7
21470: PUSH
21471: LD_VAR 0 6
21475: PUSH
21476: EMPTY
21477: LIST
21478: ST_TO_ADDR
// for i = 1 to pos - 1 do
21479: LD_ADDR_VAR 0 5
21483: PUSH
21484: DOUBLE
21485: LD_INT 1
21487: DEC
21488: ST_TO_ADDR
21489: LD_VAR 0 2
21493: PUSH
21494: LD_INT 1
21496: MINUS
21497: PUSH
21498: FOR_TO
21499: IFFALSE 21544
// begin tmp := tmp [ pos [ i ] ] ;
21501: LD_ADDR_VAR 0 6
21505: PUSH
21506: LD_VAR 0 6
21510: PUSH
21511: LD_VAR 0 2
21515: PUSH
21516: LD_VAR 0 5
21520: ARRAY
21521: ARRAY
21522: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
21523: LD_ADDR_VAR 0 7
21527: PUSH
21528: LD_VAR 0 7
21532: PUSH
21533: LD_VAR 0 6
21537: PUSH
21538: EMPTY
21539: LIST
21540: ADD
21541: ST_TO_ADDR
// end ;
21542: GO 21498
21544: POP
21545: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
21546: LD_ADDR_VAR 0 6
21550: PUSH
21551: LD_VAR 0 6
21555: PPUSH
21556: LD_VAR 0 2
21560: PUSH
21561: LD_VAR 0 2
21565: ARRAY
21566: PPUSH
21567: LD_VAR 0 3
21571: PPUSH
21572: CALL_OW 1
21576: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21577: LD_ADDR_VAR 0 7
21581: PUSH
21582: LD_VAR 0 7
21586: PPUSH
21587: LD_VAR 0 7
21591: PPUSH
21592: LD_VAR 0 6
21596: PPUSH
21597: CALL_OW 1
21601: ST_TO_ADDR
// for i = s_arr downto 2 do
21602: LD_ADDR_VAR 0 5
21606: PUSH
21607: DOUBLE
21608: LD_VAR 0 7
21612: INC
21613: ST_TO_ADDR
21614: LD_INT 2
21616: PUSH
21617: FOR_DOWNTO
21618: IFFALSE 21702
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21620: LD_ADDR_VAR 0 6
21624: PUSH
21625: LD_VAR 0 7
21629: PUSH
21630: LD_VAR 0 5
21634: PUSH
21635: LD_INT 1
21637: MINUS
21638: ARRAY
21639: PPUSH
21640: LD_VAR 0 2
21644: PUSH
21645: LD_VAR 0 5
21649: PUSH
21650: LD_INT 1
21652: MINUS
21653: ARRAY
21654: PPUSH
21655: LD_VAR 0 7
21659: PUSH
21660: LD_VAR 0 5
21664: ARRAY
21665: PPUSH
21666: CALL_OW 1
21670: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21671: LD_ADDR_VAR 0 7
21675: PUSH
21676: LD_VAR 0 7
21680: PPUSH
21681: LD_VAR 0 5
21685: PUSH
21686: LD_INT 1
21688: MINUS
21689: PPUSH
21690: LD_VAR 0 6
21694: PPUSH
21695: CALL_OW 1
21699: ST_TO_ADDR
// end ;
21700: GO 21617
21702: POP
21703: POP
// result := s_arr [ 1 ] ;
21704: LD_ADDR_VAR 0 4
21708: PUSH
21709: LD_VAR 0 7
21713: PUSH
21714: LD_INT 1
21716: ARRAY
21717: ST_TO_ADDR
// end ; end ;
21718: LD_VAR 0 4
21722: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21723: LD_INT 0
21725: PPUSH
21726: PPUSH
// if not list then
21727: LD_VAR 0 1
21731: NOT
21732: IFFALSE 21736
// exit ;
21734: GO 21827
// i := list [ pos1 ] ;
21736: LD_ADDR_VAR 0 5
21740: PUSH
21741: LD_VAR 0 1
21745: PUSH
21746: LD_VAR 0 2
21750: ARRAY
21751: ST_TO_ADDR
// if not i then
21752: LD_VAR 0 5
21756: NOT
21757: IFFALSE 21761
// exit ;
21759: GO 21827
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21761: LD_ADDR_VAR 0 1
21765: PUSH
21766: LD_VAR 0 1
21770: PPUSH
21771: LD_VAR 0 2
21775: PPUSH
21776: LD_VAR 0 1
21780: PUSH
21781: LD_VAR 0 3
21785: ARRAY
21786: PPUSH
21787: CALL_OW 1
21791: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21792: LD_ADDR_VAR 0 1
21796: PUSH
21797: LD_VAR 0 1
21801: PPUSH
21802: LD_VAR 0 3
21806: PPUSH
21807: LD_VAR 0 5
21811: PPUSH
21812: CALL_OW 1
21816: ST_TO_ADDR
// result := list ;
21817: LD_ADDR_VAR 0 4
21821: PUSH
21822: LD_VAR 0 1
21826: ST_TO_ADDR
// end ;
21827: LD_VAR 0 4
21831: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21832: LD_INT 0
21834: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21835: LD_ADDR_VAR 0 5
21839: PUSH
21840: LD_VAR 0 1
21844: PPUSH
21845: CALL_OW 250
21849: PPUSH
21850: LD_VAR 0 1
21854: PPUSH
21855: CALL_OW 251
21859: PPUSH
21860: LD_VAR 0 2
21864: PPUSH
21865: LD_VAR 0 3
21869: PPUSH
21870: LD_VAR 0 4
21874: PPUSH
21875: CALL 22253 0 5
21879: ST_TO_ADDR
// end ;
21880: LD_VAR 0 5
21884: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
21885: LD_INT 0
21887: PPUSH
21888: PPUSH
21889: PPUSH
21890: PPUSH
// if not list or not unit then
21891: LD_VAR 0 2
21895: NOT
21896: PUSH
21897: LD_VAR 0 1
21901: NOT
21902: OR
21903: IFFALSE 21907
// exit ;
21905: GO 22248
// result := [ ] ;
21907: LD_ADDR_VAR 0 5
21911: PUSH
21912: EMPTY
21913: ST_TO_ADDR
// for i in list do
21914: LD_ADDR_VAR 0 6
21918: PUSH
21919: LD_VAR 0 2
21923: PUSH
21924: FOR_IN
21925: IFFALSE 22143
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
21927: LD_ADDR_VAR 0 8
21931: PUSH
21932: LD_VAR 0 1
21936: PPUSH
21937: LD_VAR 0 6
21941: PUSH
21942: LD_INT 1
21944: ARRAY
21945: PPUSH
21946: LD_VAR 0 6
21950: PUSH
21951: LD_INT 2
21953: ARRAY
21954: PPUSH
21955: CALL_OW 297
21959: ST_TO_ADDR
// if not Count ( result ) then
21960: LD_VAR 0 5
21964: PPUSH
21965: CALL 18537 0 1
21969: NOT
21970: IFFALSE 22003
// begin result := Join ( result , [ i , tmp ] ) ;
21972: LD_ADDR_VAR 0 5
21976: PUSH
21977: LD_VAR 0 5
21981: PPUSH
21982: LD_VAR 0 6
21986: PUSH
21987: LD_VAR 0 8
21991: PUSH
21992: EMPTY
21993: LIST
21994: LIST
21995: PPUSH
21996: CALL 54126 0 2
22000: ST_TO_ADDR
// continue ;
22001: GO 21924
// end ; if result [ result ] [ 2 ] <= tmp then
22003: LD_VAR 0 5
22007: PUSH
22008: LD_VAR 0 5
22012: ARRAY
22013: PUSH
22014: LD_INT 2
22016: ARRAY
22017: PUSH
22018: LD_VAR 0 8
22022: LESSEQUAL
22023: IFFALSE 22056
// result := Join ( result , [ i , tmp ] ) else
22025: LD_ADDR_VAR 0 5
22029: PUSH
22030: LD_VAR 0 5
22034: PPUSH
22035: LD_VAR 0 6
22039: PUSH
22040: LD_VAR 0 8
22044: PUSH
22045: EMPTY
22046: LIST
22047: LIST
22048: PPUSH
22049: CALL 54126 0 2
22053: ST_TO_ADDR
22054: GO 22141
// begin for j := 1 to Count ( result ) do
22056: LD_ADDR_VAR 0 7
22060: PUSH
22061: DOUBLE
22062: LD_INT 1
22064: DEC
22065: ST_TO_ADDR
22066: LD_VAR 0 5
22070: PPUSH
22071: CALL 18537 0 1
22075: PUSH
22076: FOR_TO
22077: IFFALSE 22139
// begin if tmp < result [ j ] [ 2 ] then
22079: LD_VAR 0 8
22083: PUSH
22084: LD_VAR 0 5
22088: PUSH
22089: LD_VAR 0 7
22093: ARRAY
22094: PUSH
22095: LD_INT 2
22097: ARRAY
22098: LESS
22099: IFFALSE 22137
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22101: LD_ADDR_VAR 0 5
22105: PUSH
22106: LD_VAR 0 5
22110: PPUSH
22111: LD_VAR 0 7
22115: PPUSH
22116: LD_VAR 0 6
22120: PUSH
22121: LD_VAR 0 8
22125: PUSH
22126: EMPTY
22127: LIST
22128: LIST
22129: PPUSH
22130: CALL_OW 2
22134: ST_TO_ADDR
// break ;
22135: GO 22139
// end ; end ;
22137: GO 22076
22139: POP
22140: POP
// end ; end ;
22141: GO 21924
22143: POP
22144: POP
// if result and not asc then
22145: LD_VAR 0 5
22149: PUSH
22150: LD_VAR 0 3
22154: NOT
22155: AND
22156: IFFALSE 22173
// result := ReverseArray ( result ) ;
22158: LD_ADDR_VAR 0 5
22162: PUSH
22163: LD_VAR 0 5
22167: PPUSH
22168: CALL 49413 0 1
22172: ST_TO_ADDR
// tmp := [ ] ;
22173: LD_ADDR_VAR 0 8
22177: PUSH
22178: EMPTY
22179: ST_TO_ADDR
// if mode then
22180: LD_VAR 0 4
22184: IFFALSE 22248
// begin for i := 1 to result do
22186: LD_ADDR_VAR 0 6
22190: PUSH
22191: DOUBLE
22192: LD_INT 1
22194: DEC
22195: ST_TO_ADDR
22196: LD_VAR 0 5
22200: PUSH
22201: FOR_TO
22202: IFFALSE 22236
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
22204: LD_ADDR_VAR 0 8
22208: PUSH
22209: LD_VAR 0 8
22213: PPUSH
22214: LD_VAR 0 5
22218: PUSH
22219: LD_VAR 0 6
22223: ARRAY
22224: PUSH
22225: LD_INT 1
22227: ARRAY
22228: PPUSH
22229: CALL 54126 0 2
22233: ST_TO_ADDR
22234: GO 22201
22236: POP
22237: POP
// result := tmp ;
22238: LD_ADDR_VAR 0 5
22242: PUSH
22243: LD_VAR 0 8
22247: ST_TO_ADDR
// end ; end ;
22248: LD_VAR 0 5
22252: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
22253: LD_INT 0
22255: PPUSH
22256: PPUSH
22257: PPUSH
22258: PPUSH
// if not list then
22259: LD_VAR 0 3
22263: NOT
22264: IFFALSE 22268
// exit ;
22266: GO 22656
// result := [ ] ;
22268: LD_ADDR_VAR 0 6
22272: PUSH
22273: EMPTY
22274: ST_TO_ADDR
// for i in list do
22275: LD_ADDR_VAR 0 7
22279: PUSH
22280: LD_VAR 0 3
22284: PUSH
22285: FOR_IN
22286: IFFALSE 22488
// begin tmp := GetDistUnitXY ( i , x , y ) ;
22288: LD_ADDR_VAR 0 9
22292: PUSH
22293: LD_VAR 0 7
22297: PPUSH
22298: LD_VAR 0 1
22302: PPUSH
22303: LD_VAR 0 2
22307: PPUSH
22308: CALL_OW 297
22312: ST_TO_ADDR
// if not result then
22313: LD_VAR 0 6
22317: NOT
22318: IFFALSE 22344
// result := [ [ i , tmp ] ] else
22320: LD_ADDR_VAR 0 6
22324: PUSH
22325: LD_VAR 0 7
22329: PUSH
22330: LD_VAR 0 9
22334: PUSH
22335: EMPTY
22336: LIST
22337: LIST
22338: PUSH
22339: EMPTY
22340: LIST
22341: ST_TO_ADDR
22342: GO 22486
// begin if result [ result ] [ 2 ] < tmp then
22344: LD_VAR 0 6
22348: PUSH
22349: LD_VAR 0 6
22353: ARRAY
22354: PUSH
22355: LD_INT 2
22357: ARRAY
22358: PUSH
22359: LD_VAR 0 9
22363: LESS
22364: IFFALSE 22406
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
22366: LD_ADDR_VAR 0 6
22370: PUSH
22371: LD_VAR 0 6
22375: PPUSH
22376: LD_VAR 0 6
22380: PUSH
22381: LD_INT 1
22383: PLUS
22384: PPUSH
22385: LD_VAR 0 7
22389: PUSH
22390: LD_VAR 0 9
22394: PUSH
22395: EMPTY
22396: LIST
22397: LIST
22398: PPUSH
22399: CALL_OW 2
22403: ST_TO_ADDR
22404: GO 22486
// for j = 1 to result do
22406: LD_ADDR_VAR 0 8
22410: PUSH
22411: DOUBLE
22412: LD_INT 1
22414: DEC
22415: ST_TO_ADDR
22416: LD_VAR 0 6
22420: PUSH
22421: FOR_TO
22422: IFFALSE 22484
// begin if tmp < result [ j ] [ 2 ] then
22424: LD_VAR 0 9
22428: PUSH
22429: LD_VAR 0 6
22433: PUSH
22434: LD_VAR 0 8
22438: ARRAY
22439: PUSH
22440: LD_INT 2
22442: ARRAY
22443: LESS
22444: IFFALSE 22482
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22446: LD_ADDR_VAR 0 6
22450: PUSH
22451: LD_VAR 0 6
22455: PPUSH
22456: LD_VAR 0 8
22460: PPUSH
22461: LD_VAR 0 7
22465: PUSH
22466: LD_VAR 0 9
22470: PUSH
22471: EMPTY
22472: LIST
22473: LIST
22474: PPUSH
22475: CALL_OW 2
22479: ST_TO_ADDR
// break ;
22480: GO 22484
// end ; end ;
22482: GO 22421
22484: POP
22485: POP
// end ; end ;
22486: GO 22285
22488: POP
22489: POP
// if result and not asc then
22490: LD_VAR 0 6
22494: PUSH
22495: LD_VAR 0 4
22499: NOT
22500: AND
22501: IFFALSE 22576
// begin tmp := result ;
22503: LD_ADDR_VAR 0 9
22507: PUSH
22508: LD_VAR 0 6
22512: ST_TO_ADDR
// for i = tmp downto 1 do
22513: LD_ADDR_VAR 0 7
22517: PUSH
22518: DOUBLE
22519: LD_VAR 0 9
22523: INC
22524: ST_TO_ADDR
22525: LD_INT 1
22527: PUSH
22528: FOR_DOWNTO
22529: IFFALSE 22574
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
22531: LD_ADDR_VAR 0 6
22535: PUSH
22536: LD_VAR 0 6
22540: PPUSH
22541: LD_VAR 0 9
22545: PUSH
22546: LD_VAR 0 7
22550: MINUS
22551: PUSH
22552: LD_INT 1
22554: PLUS
22555: PPUSH
22556: LD_VAR 0 9
22560: PUSH
22561: LD_VAR 0 7
22565: ARRAY
22566: PPUSH
22567: CALL_OW 1
22571: ST_TO_ADDR
22572: GO 22528
22574: POP
22575: POP
// end ; tmp := [ ] ;
22576: LD_ADDR_VAR 0 9
22580: PUSH
22581: EMPTY
22582: ST_TO_ADDR
// if mode then
22583: LD_VAR 0 5
22587: IFFALSE 22656
// begin for i = 1 to result do
22589: LD_ADDR_VAR 0 7
22593: PUSH
22594: DOUBLE
22595: LD_INT 1
22597: DEC
22598: ST_TO_ADDR
22599: LD_VAR 0 6
22603: PUSH
22604: FOR_TO
22605: IFFALSE 22644
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
22607: LD_ADDR_VAR 0 9
22611: PUSH
22612: LD_VAR 0 9
22616: PPUSH
22617: LD_VAR 0 7
22621: PPUSH
22622: LD_VAR 0 6
22626: PUSH
22627: LD_VAR 0 7
22631: ARRAY
22632: PUSH
22633: LD_INT 1
22635: ARRAY
22636: PPUSH
22637: CALL_OW 1
22641: ST_TO_ADDR
22642: GO 22604
22644: POP
22645: POP
// result := tmp ;
22646: LD_ADDR_VAR 0 6
22650: PUSH
22651: LD_VAR 0 9
22655: ST_TO_ADDR
// end ; end ;
22656: LD_VAR 0 6
22660: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
22661: LD_INT 0
22663: PPUSH
22664: PPUSH
22665: PPUSH
22666: PPUSH
22667: PPUSH
22668: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
22669: LD_ADDR_VAR 0 5
22673: PUSH
22674: LD_INT 0
22676: PUSH
22677: LD_INT 0
22679: PUSH
22680: LD_INT 0
22682: PUSH
22683: EMPTY
22684: PUSH
22685: EMPTY
22686: LIST
22687: LIST
22688: LIST
22689: LIST
22690: ST_TO_ADDR
// if not x or not y then
22691: LD_VAR 0 2
22695: NOT
22696: PUSH
22697: LD_VAR 0 3
22701: NOT
22702: OR
22703: IFFALSE 22707
// exit ;
22705: GO 24357
// if not range then
22707: LD_VAR 0 4
22711: NOT
22712: IFFALSE 22722
// range := 10 ;
22714: LD_ADDR_VAR 0 4
22718: PUSH
22719: LD_INT 10
22721: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22722: LD_ADDR_VAR 0 8
22726: PUSH
22727: LD_INT 81
22729: PUSH
22730: LD_VAR 0 1
22734: PUSH
22735: EMPTY
22736: LIST
22737: LIST
22738: PUSH
22739: LD_INT 92
22741: PUSH
22742: LD_VAR 0 2
22746: PUSH
22747: LD_VAR 0 3
22751: PUSH
22752: LD_VAR 0 4
22756: PUSH
22757: EMPTY
22758: LIST
22759: LIST
22760: LIST
22761: LIST
22762: PUSH
22763: LD_INT 3
22765: PUSH
22766: LD_INT 21
22768: PUSH
22769: LD_INT 3
22771: PUSH
22772: EMPTY
22773: LIST
22774: LIST
22775: PUSH
22776: EMPTY
22777: LIST
22778: LIST
22779: PUSH
22780: EMPTY
22781: LIST
22782: LIST
22783: LIST
22784: PPUSH
22785: CALL_OW 69
22789: ST_TO_ADDR
// if not tmp then
22790: LD_VAR 0 8
22794: NOT
22795: IFFALSE 22799
// exit ;
22797: GO 24357
// for i in tmp do
22799: LD_ADDR_VAR 0 6
22803: PUSH
22804: LD_VAR 0 8
22808: PUSH
22809: FOR_IN
22810: IFFALSE 24332
// begin points := [ 0 , 0 , 0 ] ;
22812: LD_ADDR_VAR 0 9
22816: PUSH
22817: LD_INT 0
22819: PUSH
22820: LD_INT 0
22822: PUSH
22823: LD_INT 0
22825: PUSH
22826: EMPTY
22827: LIST
22828: LIST
22829: LIST
22830: ST_TO_ADDR
// bpoints := 1 ;
22831: LD_ADDR_VAR 0 10
22835: PUSH
22836: LD_INT 1
22838: ST_TO_ADDR
// case GetType ( i ) of unit_human :
22839: LD_VAR 0 6
22843: PPUSH
22844: CALL_OW 247
22848: PUSH
22849: LD_INT 1
22851: DOUBLE
22852: EQUAL
22853: IFTRUE 22857
22855: GO 23435
22857: POP
// begin if GetClass ( i ) = 1 then
22858: LD_VAR 0 6
22862: PPUSH
22863: CALL_OW 257
22867: PUSH
22868: LD_INT 1
22870: EQUAL
22871: IFFALSE 22892
// points := [ 10 , 5 , 3 ] ;
22873: LD_ADDR_VAR 0 9
22877: PUSH
22878: LD_INT 10
22880: PUSH
22881: LD_INT 5
22883: PUSH
22884: LD_INT 3
22886: PUSH
22887: EMPTY
22888: LIST
22889: LIST
22890: LIST
22891: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
22892: LD_VAR 0 6
22896: PPUSH
22897: CALL_OW 257
22901: PUSH
22902: LD_INT 2
22904: PUSH
22905: LD_INT 3
22907: PUSH
22908: LD_INT 4
22910: PUSH
22911: EMPTY
22912: LIST
22913: LIST
22914: LIST
22915: IN
22916: IFFALSE 22937
// points := [ 3 , 2 , 1 ] ;
22918: LD_ADDR_VAR 0 9
22922: PUSH
22923: LD_INT 3
22925: PUSH
22926: LD_INT 2
22928: PUSH
22929: LD_INT 1
22931: PUSH
22932: EMPTY
22933: LIST
22934: LIST
22935: LIST
22936: ST_TO_ADDR
// if GetClass ( i ) = 5 then
22937: LD_VAR 0 6
22941: PPUSH
22942: CALL_OW 257
22946: PUSH
22947: LD_INT 5
22949: EQUAL
22950: IFFALSE 22971
// points := [ 130 , 5 , 2 ] ;
22952: LD_ADDR_VAR 0 9
22956: PUSH
22957: LD_INT 130
22959: PUSH
22960: LD_INT 5
22962: PUSH
22963: LD_INT 2
22965: PUSH
22966: EMPTY
22967: LIST
22968: LIST
22969: LIST
22970: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22971: LD_VAR 0 6
22975: PPUSH
22976: CALL_OW 257
22980: PUSH
22981: LD_INT 8
22983: EQUAL
22984: IFFALSE 23005
// points := [ 35 , 35 , 30 ] ;
22986: LD_ADDR_VAR 0 9
22990: PUSH
22991: LD_INT 35
22993: PUSH
22994: LD_INT 35
22996: PUSH
22997: LD_INT 30
22999: PUSH
23000: EMPTY
23001: LIST
23002: LIST
23003: LIST
23004: ST_TO_ADDR
// if GetClass ( i ) = 9 then
23005: LD_VAR 0 6
23009: PPUSH
23010: CALL_OW 257
23014: PUSH
23015: LD_INT 9
23017: EQUAL
23018: IFFALSE 23039
// points := [ 20 , 55 , 40 ] ;
23020: LD_ADDR_VAR 0 9
23024: PUSH
23025: LD_INT 20
23027: PUSH
23028: LD_INT 55
23030: PUSH
23031: LD_INT 40
23033: PUSH
23034: EMPTY
23035: LIST
23036: LIST
23037: LIST
23038: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
23039: LD_VAR 0 6
23043: PPUSH
23044: CALL_OW 257
23048: PUSH
23049: LD_INT 12
23051: PUSH
23052: LD_INT 16
23054: PUSH
23055: EMPTY
23056: LIST
23057: LIST
23058: IN
23059: IFFALSE 23080
// points := [ 5 , 3 , 2 ] ;
23061: LD_ADDR_VAR 0 9
23065: PUSH
23066: LD_INT 5
23068: PUSH
23069: LD_INT 3
23071: PUSH
23072: LD_INT 2
23074: PUSH
23075: EMPTY
23076: LIST
23077: LIST
23078: LIST
23079: ST_TO_ADDR
// if GetClass ( i ) = 17 then
23080: LD_VAR 0 6
23084: PPUSH
23085: CALL_OW 257
23089: PUSH
23090: LD_INT 17
23092: EQUAL
23093: IFFALSE 23114
// points := [ 100 , 50 , 75 ] ;
23095: LD_ADDR_VAR 0 9
23099: PUSH
23100: LD_INT 100
23102: PUSH
23103: LD_INT 50
23105: PUSH
23106: LD_INT 75
23108: PUSH
23109: EMPTY
23110: LIST
23111: LIST
23112: LIST
23113: ST_TO_ADDR
// if GetClass ( i ) = 15 then
23114: LD_VAR 0 6
23118: PPUSH
23119: CALL_OW 257
23123: PUSH
23124: LD_INT 15
23126: EQUAL
23127: IFFALSE 23148
// points := [ 10 , 5 , 3 ] ;
23129: LD_ADDR_VAR 0 9
23133: PUSH
23134: LD_INT 10
23136: PUSH
23137: LD_INT 5
23139: PUSH
23140: LD_INT 3
23142: PUSH
23143: EMPTY
23144: LIST
23145: LIST
23146: LIST
23147: ST_TO_ADDR
// if GetClass ( i ) = 14 then
23148: LD_VAR 0 6
23152: PPUSH
23153: CALL_OW 257
23157: PUSH
23158: LD_INT 14
23160: EQUAL
23161: IFFALSE 23182
// points := [ 10 , 0 , 0 ] ;
23163: LD_ADDR_VAR 0 9
23167: PUSH
23168: LD_INT 10
23170: PUSH
23171: LD_INT 0
23173: PUSH
23174: LD_INT 0
23176: PUSH
23177: EMPTY
23178: LIST
23179: LIST
23180: LIST
23181: ST_TO_ADDR
// if GetClass ( i ) = 11 then
23182: LD_VAR 0 6
23186: PPUSH
23187: CALL_OW 257
23191: PUSH
23192: LD_INT 11
23194: EQUAL
23195: IFFALSE 23216
// points := [ 30 , 10 , 5 ] ;
23197: LD_ADDR_VAR 0 9
23201: PUSH
23202: LD_INT 30
23204: PUSH
23205: LD_INT 10
23207: PUSH
23208: LD_INT 5
23210: PUSH
23211: EMPTY
23212: LIST
23213: LIST
23214: LIST
23215: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
23216: LD_VAR 0 1
23220: PPUSH
23221: LD_INT 5
23223: PPUSH
23224: CALL_OW 321
23228: PUSH
23229: LD_INT 2
23231: EQUAL
23232: IFFALSE 23249
// bpoints := bpoints * 1.8 ;
23234: LD_ADDR_VAR 0 10
23238: PUSH
23239: LD_VAR 0 10
23243: PUSH
23244: LD_REAL  1.80000000000000E+0000
23247: MUL
23248: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
23249: LD_VAR 0 6
23253: PPUSH
23254: CALL_OW 257
23258: PUSH
23259: LD_INT 1
23261: PUSH
23262: LD_INT 2
23264: PUSH
23265: LD_INT 3
23267: PUSH
23268: LD_INT 4
23270: PUSH
23271: EMPTY
23272: LIST
23273: LIST
23274: LIST
23275: LIST
23276: IN
23277: PUSH
23278: LD_VAR 0 1
23282: PPUSH
23283: LD_INT 51
23285: PPUSH
23286: CALL_OW 321
23290: PUSH
23291: LD_INT 2
23293: EQUAL
23294: AND
23295: IFFALSE 23312
// bpoints := bpoints * 1.2 ;
23297: LD_ADDR_VAR 0 10
23301: PUSH
23302: LD_VAR 0 10
23306: PUSH
23307: LD_REAL  1.20000000000000E+0000
23310: MUL
23311: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
23312: LD_VAR 0 6
23316: PPUSH
23317: CALL_OW 257
23321: PUSH
23322: LD_INT 5
23324: PUSH
23325: LD_INT 7
23327: PUSH
23328: LD_INT 9
23330: PUSH
23331: EMPTY
23332: LIST
23333: LIST
23334: LIST
23335: IN
23336: PUSH
23337: LD_VAR 0 1
23341: PPUSH
23342: LD_INT 52
23344: PPUSH
23345: CALL_OW 321
23349: PUSH
23350: LD_INT 2
23352: EQUAL
23353: AND
23354: IFFALSE 23371
// bpoints := bpoints * 1.5 ;
23356: LD_ADDR_VAR 0 10
23360: PUSH
23361: LD_VAR 0 10
23365: PUSH
23366: LD_REAL  1.50000000000000E+0000
23369: MUL
23370: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
23371: LD_VAR 0 1
23375: PPUSH
23376: LD_INT 66
23378: PPUSH
23379: CALL_OW 321
23383: PUSH
23384: LD_INT 2
23386: EQUAL
23387: IFFALSE 23404
// bpoints := bpoints * 1.1 ;
23389: LD_ADDR_VAR 0 10
23393: PUSH
23394: LD_VAR 0 10
23398: PUSH
23399: LD_REAL  1.10000000000000E+0000
23402: MUL
23403: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
23404: LD_ADDR_VAR 0 10
23408: PUSH
23409: LD_VAR 0 10
23413: PUSH
23414: LD_VAR 0 6
23418: PPUSH
23419: LD_INT 1
23421: PPUSH
23422: CALL_OW 259
23426: PUSH
23427: LD_REAL  1.15000000000000E+0000
23430: MUL
23431: MUL
23432: ST_TO_ADDR
// end ; unit_vehicle :
23433: GO 24261
23435: LD_INT 2
23437: DOUBLE
23438: EQUAL
23439: IFTRUE 23443
23441: GO 24249
23443: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
23444: LD_VAR 0 6
23448: PPUSH
23449: CALL_OW 264
23453: PUSH
23454: LD_INT 2
23456: PUSH
23457: LD_INT 42
23459: PUSH
23460: LD_INT 24
23462: PUSH
23463: EMPTY
23464: LIST
23465: LIST
23466: LIST
23467: IN
23468: IFFALSE 23489
// points := [ 25 , 5 , 3 ] ;
23470: LD_ADDR_VAR 0 9
23474: PUSH
23475: LD_INT 25
23477: PUSH
23478: LD_INT 5
23480: PUSH
23481: LD_INT 3
23483: PUSH
23484: EMPTY
23485: LIST
23486: LIST
23487: LIST
23488: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
23489: LD_VAR 0 6
23493: PPUSH
23494: CALL_OW 264
23498: PUSH
23499: LD_INT 4
23501: PUSH
23502: LD_INT 43
23504: PUSH
23505: LD_INT 25
23507: PUSH
23508: EMPTY
23509: LIST
23510: LIST
23511: LIST
23512: IN
23513: IFFALSE 23534
// points := [ 40 , 15 , 5 ] ;
23515: LD_ADDR_VAR 0 9
23519: PUSH
23520: LD_INT 40
23522: PUSH
23523: LD_INT 15
23525: PUSH
23526: LD_INT 5
23528: PUSH
23529: EMPTY
23530: LIST
23531: LIST
23532: LIST
23533: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
23534: LD_VAR 0 6
23538: PPUSH
23539: CALL_OW 264
23543: PUSH
23544: LD_INT 3
23546: PUSH
23547: LD_INT 23
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: IN
23554: IFFALSE 23575
// points := [ 7 , 25 , 8 ] ;
23556: LD_ADDR_VAR 0 9
23560: PUSH
23561: LD_INT 7
23563: PUSH
23564: LD_INT 25
23566: PUSH
23567: LD_INT 8
23569: PUSH
23570: EMPTY
23571: LIST
23572: LIST
23573: LIST
23574: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
23575: LD_VAR 0 6
23579: PPUSH
23580: CALL_OW 264
23584: PUSH
23585: LD_INT 5
23587: PUSH
23588: LD_INT 27
23590: PUSH
23591: LD_INT 44
23593: PUSH
23594: EMPTY
23595: LIST
23596: LIST
23597: LIST
23598: IN
23599: IFFALSE 23620
// points := [ 14 , 50 , 16 ] ;
23601: LD_ADDR_VAR 0 9
23605: PUSH
23606: LD_INT 14
23608: PUSH
23609: LD_INT 50
23611: PUSH
23612: LD_INT 16
23614: PUSH
23615: EMPTY
23616: LIST
23617: LIST
23618: LIST
23619: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
23620: LD_VAR 0 6
23624: PPUSH
23625: CALL_OW 264
23629: PUSH
23630: LD_INT 6
23632: PUSH
23633: LD_INT 46
23635: PUSH
23636: EMPTY
23637: LIST
23638: LIST
23639: IN
23640: IFFALSE 23661
// points := [ 32 , 120 , 70 ] ;
23642: LD_ADDR_VAR 0 9
23646: PUSH
23647: LD_INT 32
23649: PUSH
23650: LD_INT 120
23652: PUSH
23653: LD_INT 70
23655: PUSH
23656: EMPTY
23657: LIST
23658: LIST
23659: LIST
23660: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
23661: LD_VAR 0 6
23665: PPUSH
23666: CALL_OW 264
23670: PUSH
23671: LD_INT 7
23673: PUSH
23674: LD_INT 28
23676: PUSH
23677: LD_INT 45
23679: PUSH
23680: LD_INT 92
23682: PUSH
23683: EMPTY
23684: LIST
23685: LIST
23686: LIST
23687: LIST
23688: IN
23689: IFFALSE 23710
// points := [ 35 , 20 , 45 ] ;
23691: LD_ADDR_VAR 0 9
23695: PUSH
23696: LD_INT 35
23698: PUSH
23699: LD_INT 20
23701: PUSH
23702: LD_INT 45
23704: PUSH
23705: EMPTY
23706: LIST
23707: LIST
23708: LIST
23709: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
23710: LD_VAR 0 6
23714: PPUSH
23715: CALL_OW 264
23719: PUSH
23720: LD_INT 47
23722: PUSH
23723: EMPTY
23724: LIST
23725: IN
23726: IFFALSE 23747
// points := [ 67 , 45 , 75 ] ;
23728: LD_ADDR_VAR 0 9
23732: PUSH
23733: LD_INT 67
23735: PUSH
23736: LD_INT 45
23738: PUSH
23739: LD_INT 75
23741: PUSH
23742: EMPTY
23743: LIST
23744: LIST
23745: LIST
23746: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
23747: LD_VAR 0 6
23751: PPUSH
23752: CALL_OW 264
23756: PUSH
23757: LD_INT 26
23759: PUSH
23760: EMPTY
23761: LIST
23762: IN
23763: IFFALSE 23784
// points := [ 120 , 30 , 80 ] ;
23765: LD_ADDR_VAR 0 9
23769: PUSH
23770: LD_INT 120
23772: PUSH
23773: LD_INT 30
23775: PUSH
23776: LD_INT 80
23778: PUSH
23779: EMPTY
23780: LIST
23781: LIST
23782: LIST
23783: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
23784: LD_VAR 0 6
23788: PPUSH
23789: CALL_OW 264
23793: PUSH
23794: LD_INT 22
23796: PUSH
23797: EMPTY
23798: LIST
23799: IN
23800: IFFALSE 23821
// points := [ 40 , 1 , 1 ] ;
23802: LD_ADDR_VAR 0 9
23806: PUSH
23807: LD_INT 40
23809: PUSH
23810: LD_INT 1
23812: PUSH
23813: LD_INT 1
23815: PUSH
23816: EMPTY
23817: LIST
23818: LIST
23819: LIST
23820: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
23821: LD_VAR 0 6
23825: PPUSH
23826: CALL_OW 264
23830: PUSH
23831: LD_INT 29
23833: PUSH
23834: EMPTY
23835: LIST
23836: IN
23837: IFFALSE 23858
// points := [ 70 , 200 , 400 ] ;
23839: LD_ADDR_VAR 0 9
23843: PUSH
23844: LD_INT 70
23846: PUSH
23847: LD_INT 200
23849: PUSH
23850: LD_INT 400
23852: PUSH
23853: EMPTY
23854: LIST
23855: LIST
23856: LIST
23857: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
23858: LD_VAR 0 6
23862: PPUSH
23863: CALL_OW 264
23867: PUSH
23868: LD_INT 14
23870: PUSH
23871: LD_INT 53
23873: PUSH
23874: EMPTY
23875: LIST
23876: LIST
23877: IN
23878: IFFALSE 23899
// points := [ 40 , 10 , 20 ] ;
23880: LD_ADDR_VAR 0 9
23884: PUSH
23885: LD_INT 40
23887: PUSH
23888: LD_INT 10
23890: PUSH
23891: LD_INT 20
23893: PUSH
23894: EMPTY
23895: LIST
23896: LIST
23897: LIST
23898: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
23899: LD_VAR 0 6
23903: PPUSH
23904: CALL_OW 264
23908: PUSH
23909: LD_INT 9
23911: PUSH
23912: EMPTY
23913: LIST
23914: IN
23915: IFFALSE 23936
// points := [ 5 , 70 , 20 ] ;
23917: LD_ADDR_VAR 0 9
23921: PUSH
23922: LD_INT 5
23924: PUSH
23925: LD_INT 70
23927: PUSH
23928: LD_INT 20
23930: PUSH
23931: EMPTY
23932: LIST
23933: LIST
23934: LIST
23935: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
23936: LD_VAR 0 6
23940: PPUSH
23941: CALL_OW 264
23945: PUSH
23946: LD_INT 10
23948: PUSH
23949: EMPTY
23950: LIST
23951: IN
23952: IFFALSE 23973
// points := [ 35 , 110 , 70 ] ;
23954: LD_ADDR_VAR 0 9
23958: PUSH
23959: LD_INT 35
23961: PUSH
23962: LD_INT 110
23964: PUSH
23965: LD_INT 70
23967: PUSH
23968: EMPTY
23969: LIST
23970: LIST
23971: LIST
23972: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23973: LD_VAR 0 6
23977: PPUSH
23978: CALL_OW 265
23982: PUSH
23983: LD_INT 25
23985: EQUAL
23986: IFFALSE 24007
// points := [ 80 , 65 , 100 ] ;
23988: LD_ADDR_VAR 0 9
23992: PUSH
23993: LD_INT 80
23995: PUSH
23996: LD_INT 65
23998: PUSH
23999: LD_INT 100
24001: PUSH
24002: EMPTY
24003: LIST
24004: LIST
24005: LIST
24006: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
24007: LD_VAR 0 6
24011: PPUSH
24012: CALL_OW 263
24016: PUSH
24017: LD_INT 1
24019: EQUAL
24020: IFFALSE 24055
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
24022: LD_ADDR_VAR 0 10
24026: PUSH
24027: LD_VAR 0 10
24031: PUSH
24032: LD_VAR 0 6
24036: PPUSH
24037: CALL_OW 311
24041: PPUSH
24042: LD_INT 3
24044: PPUSH
24045: CALL_OW 259
24049: PUSH
24050: LD_INT 4
24052: MUL
24053: MUL
24054: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
24055: LD_VAR 0 6
24059: PPUSH
24060: CALL_OW 263
24064: PUSH
24065: LD_INT 2
24067: EQUAL
24068: IFFALSE 24119
// begin j := IsControledBy ( i ) ;
24070: LD_ADDR_VAR 0 7
24074: PUSH
24075: LD_VAR 0 6
24079: PPUSH
24080: CALL_OW 312
24084: ST_TO_ADDR
// if j then
24085: LD_VAR 0 7
24089: IFFALSE 24119
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
24091: LD_ADDR_VAR 0 10
24095: PUSH
24096: LD_VAR 0 10
24100: PUSH
24101: LD_VAR 0 7
24105: PPUSH
24106: LD_INT 3
24108: PPUSH
24109: CALL_OW 259
24113: PUSH
24114: LD_INT 3
24116: MUL
24117: MUL
24118: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
24119: LD_VAR 0 6
24123: PPUSH
24124: CALL_OW 264
24128: PUSH
24129: LD_INT 5
24131: PUSH
24132: LD_INT 6
24134: PUSH
24135: LD_INT 46
24137: PUSH
24138: LD_INT 44
24140: PUSH
24141: LD_INT 47
24143: PUSH
24144: LD_INT 45
24146: PUSH
24147: LD_INT 28
24149: PUSH
24150: LD_INT 7
24152: PUSH
24153: LD_INT 27
24155: PUSH
24156: LD_INT 29
24158: PUSH
24159: EMPTY
24160: LIST
24161: LIST
24162: LIST
24163: LIST
24164: LIST
24165: LIST
24166: LIST
24167: LIST
24168: LIST
24169: LIST
24170: IN
24171: PUSH
24172: LD_VAR 0 1
24176: PPUSH
24177: LD_INT 52
24179: PPUSH
24180: CALL_OW 321
24184: PUSH
24185: LD_INT 2
24187: EQUAL
24188: AND
24189: IFFALSE 24206
// bpoints := bpoints * 1.2 ;
24191: LD_ADDR_VAR 0 10
24195: PUSH
24196: LD_VAR 0 10
24200: PUSH
24201: LD_REAL  1.20000000000000E+0000
24204: MUL
24205: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
24206: LD_VAR 0 6
24210: PPUSH
24211: CALL_OW 264
24215: PUSH
24216: LD_INT 6
24218: PUSH
24219: LD_INT 46
24221: PUSH
24222: LD_INT 47
24224: PUSH
24225: EMPTY
24226: LIST
24227: LIST
24228: LIST
24229: IN
24230: IFFALSE 24247
// bpoints := bpoints * 1.2 ;
24232: LD_ADDR_VAR 0 10
24236: PUSH
24237: LD_VAR 0 10
24241: PUSH
24242: LD_REAL  1.20000000000000E+0000
24245: MUL
24246: ST_TO_ADDR
// end ; unit_building :
24247: GO 24261
24249: LD_INT 3
24251: DOUBLE
24252: EQUAL
24253: IFTRUE 24257
24255: GO 24260
24257: POP
// ; end ;
24258: GO 24261
24260: POP
// for j = 1 to 3 do
24261: LD_ADDR_VAR 0 7
24265: PUSH
24266: DOUBLE
24267: LD_INT 1
24269: DEC
24270: ST_TO_ADDR
24271: LD_INT 3
24273: PUSH
24274: FOR_TO
24275: IFFALSE 24328
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
24277: LD_ADDR_VAR 0 5
24281: PUSH
24282: LD_VAR 0 5
24286: PPUSH
24287: LD_VAR 0 7
24291: PPUSH
24292: LD_VAR 0 5
24296: PUSH
24297: LD_VAR 0 7
24301: ARRAY
24302: PUSH
24303: LD_VAR 0 9
24307: PUSH
24308: LD_VAR 0 7
24312: ARRAY
24313: PUSH
24314: LD_VAR 0 10
24318: MUL
24319: PLUS
24320: PPUSH
24321: CALL_OW 1
24325: ST_TO_ADDR
24326: GO 24274
24328: POP
24329: POP
// end ;
24330: GO 22809
24332: POP
24333: POP
// result := Replace ( result , 4 , tmp ) ;
24334: LD_ADDR_VAR 0 5
24338: PUSH
24339: LD_VAR 0 5
24343: PPUSH
24344: LD_INT 4
24346: PPUSH
24347: LD_VAR 0 8
24351: PPUSH
24352: CALL_OW 1
24356: ST_TO_ADDR
// end ;
24357: LD_VAR 0 5
24361: RET
// export function DangerAtRange ( unit , range ) ; begin
24362: LD_INT 0
24364: PPUSH
// if not unit then
24365: LD_VAR 0 1
24369: NOT
24370: IFFALSE 24374
// exit ;
24372: GO 24419
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
24374: LD_ADDR_VAR 0 3
24378: PUSH
24379: LD_VAR 0 1
24383: PPUSH
24384: CALL_OW 255
24388: PPUSH
24389: LD_VAR 0 1
24393: PPUSH
24394: CALL_OW 250
24398: PPUSH
24399: LD_VAR 0 1
24403: PPUSH
24404: CALL_OW 251
24408: PPUSH
24409: LD_VAR 0 2
24413: PPUSH
24414: CALL 22661 0 4
24418: ST_TO_ADDR
// end ;
24419: LD_VAR 0 3
24423: RET
// export function DangerInArea ( side , area ) ; begin
24424: LD_INT 0
24426: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
24427: LD_ADDR_VAR 0 3
24431: PUSH
24432: LD_VAR 0 2
24436: PPUSH
24437: LD_INT 81
24439: PUSH
24440: LD_VAR 0 1
24444: PUSH
24445: EMPTY
24446: LIST
24447: LIST
24448: PPUSH
24449: CALL_OW 70
24453: ST_TO_ADDR
// end ;
24454: LD_VAR 0 3
24458: RET
// export function IsExtension ( b ) ; begin
24459: LD_INT 0
24461: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
24462: LD_ADDR_VAR 0 2
24466: PUSH
24467: LD_VAR 0 1
24471: PUSH
24472: LD_INT 23
24474: PUSH
24475: LD_INT 20
24477: PUSH
24478: LD_INT 22
24480: PUSH
24481: LD_INT 17
24483: PUSH
24484: LD_INT 24
24486: PUSH
24487: LD_INT 21
24489: PUSH
24490: LD_INT 19
24492: PUSH
24493: LD_INT 16
24495: PUSH
24496: LD_INT 25
24498: PUSH
24499: LD_INT 18
24501: PUSH
24502: EMPTY
24503: LIST
24504: LIST
24505: LIST
24506: LIST
24507: LIST
24508: LIST
24509: LIST
24510: LIST
24511: LIST
24512: LIST
24513: IN
24514: ST_TO_ADDR
// end ;
24515: LD_VAR 0 2
24519: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
24520: LD_INT 0
24522: PPUSH
24523: PPUSH
24524: PPUSH
// result := [ ] ;
24525: LD_ADDR_VAR 0 4
24529: PUSH
24530: EMPTY
24531: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
24532: LD_ADDR_VAR 0 5
24536: PUSH
24537: LD_VAR 0 2
24541: PPUSH
24542: LD_INT 21
24544: PUSH
24545: LD_INT 3
24547: PUSH
24548: EMPTY
24549: LIST
24550: LIST
24551: PPUSH
24552: CALL_OW 70
24556: ST_TO_ADDR
// if not tmp then
24557: LD_VAR 0 5
24561: NOT
24562: IFFALSE 24566
// exit ;
24564: GO 24630
// if checkLink then
24566: LD_VAR 0 3
24570: IFFALSE 24620
// begin for i in tmp do
24572: LD_ADDR_VAR 0 6
24576: PUSH
24577: LD_VAR 0 5
24581: PUSH
24582: FOR_IN
24583: IFFALSE 24618
// if GetBase ( i ) <> base then
24585: LD_VAR 0 6
24589: PPUSH
24590: CALL_OW 274
24594: PUSH
24595: LD_VAR 0 1
24599: NONEQUAL
24600: IFFALSE 24616
// ComLinkToBase ( base , i ) ;
24602: LD_VAR 0 1
24606: PPUSH
24607: LD_VAR 0 6
24611: PPUSH
24612: CALL_OW 169
24616: GO 24582
24618: POP
24619: POP
// end ; result := tmp ;
24620: LD_ADDR_VAR 0 4
24624: PUSH
24625: LD_VAR 0 5
24629: ST_TO_ADDR
// end ;
24630: LD_VAR 0 4
24634: RET
// export function ComComplete ( units , b ) ; var i ; begin
24635: LD_INT 0
24637: PPUSH
24638: PPUSH
// if not units then
24639: LD_VAR 0 1
24643: NOT
24644: IFFALSE 24648
// exit ;
24646: GO 24738
// for i in units do
24648: LD_ADDR_VAR 0 4
24652: PUSH
24653: LD_VAR 0 1
24657: PUSH
24658: FOR_IN
24659: IFFALSE 24736
// if BuildingStatus ( b ) = bs_build then
24661: LD_VAR 0 2
24665: PPUSH
24666: CALL_OW 461
24670: PUSH
24671: LD_INT 1
24673: EQUAL
24674: IFFALSE 24734
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
24676: LD_VAR 0 4
24680: PPUSH
24681: LD_STRING h
24683: PUSH
24684: LD_VAR 0 2
24688: PPUSH
24689: CALL_OW 250
24693: PUSH
24694: LD_VAR 0 2
24698: PPUSH
24699: CALL_OW 251
24703: PUSH
24704: LD_VAR 0 2
24708: PUSH
24709: LD_INT 0
24711: PUSH
24712: LD_INT 0
24714: PUSH
24715: LD_INT 0
24717: PUSH
24718: EMPTY
24719: LIST
24720: LIST
24721: LIST
24722: LIST
24723: LIST
24724: LIST
24725: LIST
24726: PUSH
24727: EMPTY
24728: LIST
24729: PPUSH
24730: CALL_OW 446
24734: GO 24658
24736: POP
24737: POP
// end ;
24738: LD_VAR 0 3
24742: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
24743: LD_INT 0
24745: PPUSH
24746: PPUSH
24747: PPUSH
24748: PPUSH
24749: PPUSH
24750: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
24751: LD_VAR 0 1
24755: NOT
24756: PUSH
24757: LD_VAR 0 1
24761: PPUSH
24762: CALL_OW 263
24766: PUSH
24767: LD_INT 2
24769: NONEQUAL
24770: OR
24771: IFFALSE 24775
// exit ;
24773: GO 25091
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
24775: LD_ADDR_VAR 0 6
24779: PUSH
24780: LD_INT 22
24782: PUSH
24783: LD_VAR 0 1
24787: PPUSH
24788: CALL_OW 255
24792: PUSH
24793: EMPTY
24794: LIST
24795: LIST
24796: PUSH
24797: LD_INT 2
24799: PUSH
24800: LD_INT 30
24802: PUSH
24803: LD_INT 36
24805: PUSH
24806: EMPTY
24807: LIST
24808: LIST
24809: PUSH
24810: LD_INT 34
24812: PUSH
24813: LD_INT 31
24815: PUSH
24816: EMPTY
24817: LIST
24818: LIST
24819: PUSH
24820: EMPTY
24821: LIST
24822: LIST
24823: LIST
24824: PUSH
24825: EMPTY
24826: LIST
24827: LIST
24828: PPUSH
24829: CALL_OW 69
24833: ST_TO_ADDR
// if not tmp then
24834: LD_VAR 0 6
24838: NOT
24839: IFFALSE 24843
// exit ;
24841: GO 25091
// result := [ ] ;
24843: LD_ADDR_VAR 0 2
24847: PUSH
24848: EMPTY
24849: ST_TO_ADDR
// for i in tmp do
24850: LD_ADDR_VAR 0 3
24854: PUSH
24855: LD_VAR 0 6
24859: PUSH
24860: FOR_IN
24861: IFFALSE 24932
// begin t := UnitsInside ( i ) ;
24863: LD_ADDR_VAR 0 4
24867: PUSH
24868: LD_VAR 0 3
24872: PPUSH
24873: CALL_OW 313
24877: ST_TO_ADDR
// if t then
24878: LD_VAR 0 4
24882: IFFALSE 24930
// for j in t do
24884: LD_ADDR_VAR 0 7
24888: PUSH
24889: LD_VAR 0 4
24893: PUSH
24894: FOR_IN
24895: IFFALSE 24928
// result := Replace ( result , result + 1 , j ) ;
24897: LD_ADDR_VAR 0 2
24901: PUSH
24902: LD_VAR 0 2
24906: PPUSH
24907: LD_VAR 0 2
24911: PUSH
24912: LD_INT 1
24914: PLUS
24915: PPUSH
24916: LD_VAR 0 7
24920: PPUSH
24921: CALL_OW 1
24925: ST_TO_ADDR
24926: GO 24894
24928: POP
24929: POP
// end ;
24930: GO 24860
24932: POP
24933: POP
// if not result then
24934: LD_VAR 0 2
24938: NOT
24939: IFFALSE 24943
// exit ;
24941: GO 25091
// mech := result [ 1 ] ;
24943: LD_ADDR_VAR 0 5
24947: PUSH
24948: LD_VAR 0 2
24952: PUSH
24953: LD_INT 1
24955: ARRAY
24956: ST_TO_ADDR
// if result > 1 then
24957: LD_VAR 0 2
24961: PUSH
24962: LD_INT 1
24964: GREATER
24965: IFFALSE 25077
// begin for i = 2 to result do
24967: LD_ADDR_VAR 0 3
24971: PUSH
24972: DOUBLE
24973: LD_INT 2
24975: DEC
24976: ST_TO_ADDR
24977: LD_VAR 0 2
24981: PUSH
24982: FOR_TO
24983: IFFALSE 25075
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
24985: LD_ADDR_VAR 0 4
24989: PUSH
24990: LD_VAR 0 2
24994: PUSH
24995: LD_VAR 0 3
24999: ARRAY
25000: PPUSH
25001: LD_INT 3
25003: PPUSH
25004: CALL_OW 259
25008: PUSH
25009: LD_VAR 0 2
25013: PUSH
25014: LD_VAR 0 3
25018: ARRAY
25019: PPUSH
25020: CALL_OW 432
25024: MINUS
25025: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
25026: LD_VAR 0 4
25030: PUSH
25031: LD_VAR 0 5
25035: PPUSH
25036: LD_INT 3
25038: PPUSH
25039: CALL_OW 259
25043: PUSH
25044: LD_VAR 0 5
25048: PPUSH
25049: CALL_OW 432
25053: MINUS
25054: GREATEREQUAL
25055: IFFALSE 25073
// mech := result [ i ] ;
25057: LD_ADDR_VAR 0 5
25061: PUSH
25062: LD_VAR 0 2
25066: PUSH
25067: LD_VAR 0 3
25071: ARRAY
25072: ST_TO_ADDR
// end ;
25073: GO 24982
25075: POP
25076: POP
// end ; ComLinkTo ( vehicle , mech ) ;
25077: LD_VAR 0 1
25081: PPUSH
25082: LD_VAR 0 5
25086: PPUSH
25087: CALL_OW 135
// end ;
25091: LD_VAR 0 2
25095: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
25096: LD_INT 0
25098: PPUSH
25099: PPUSH
25100: PPUSH
25101: PPUSH
25102: PPUSH
25103: PPUSH
25104: PPUSH
25105: PPUSH
25106: PPUSH
25107: PPUSH
25108: PPUSH
25109: PPUSH
25110: PPUSH
// result := [ ] ;
25111: LD_ADDR_VAR 0 7
25115: PUSH
25116: EMPTY
25117: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
25118: LD_VAR 0 1
25122: PPUSH
25123: CALL_OW 266
25127: PUSH
25128: LD_INT 0
25130: PUSH
25131: LD_INT 1
25133: PUSH
25134: EMPTY
25135: LIST
25136: LIST
25137: IN
25138: NOT
25139: IFFALSE 25143
// exit ;
25141: GO 26777
// if name then
25143: LD_VAR 0 3
25147: IFFALSE 25163
// SetBName ( base_dep , name ) ;
25149: LD_VAR 0 1
25153: PPUSH
25154: LD_VAR 0 3
25158: PPUSH
25159: CALL_OW 500
// base := GetBase ( base_dep ) ;
25163: LD_ADDR_VAR 0 15
25167: PUSH
25168: LD_VAR 0 1
25172: PPUSH
25173: CALL_OW 274
25177: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
25178: LD_ADDR_VAR 0 16
25182: PUSH
25183: LD_VAR 0 1
25187: PPUSH
25188: CALL_OW 255
25192: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
25193: LD_ADDR_VAR 0 17
25197: PUSH
25198: LD_VAR 0 1
25202: PPUSH
25203: CALL_OW 248
25207: ST_TO_ADDR
// if sources then
25208: LD_VAR 0 5
25212: IFFALSE 25259
// for i = 1 to 3 do
25214: LD_ADDR_VAR 0 8
25218: PUSH
25219: DOUBLE
25220: LD_INT 1
25222: DEC
25223: ST_TO_ADDR
25224: LD_INT 3
25226: PUSH
25227: FOR_TO
25228: IFFALSE 25257
// AddResourceType ( base , i , sources [ i ] ) ;
25230: LD_VAR 0 15
25234: PPUSH
25235: LD_VAR 0 8
25239: PPUSH
25240: LD_VAR 0 5
25244: PUSH
25245: LD_VAR 0 8
25249: ARRAY
25250: PPUSH
25251: CALL_OW 276
25255: GO 25227
25257: POP
25258: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
25259: LD_ADDR_VAR 0 18
25263: PUSH
25264: LD_VAR 0 15
25268: PPUSH
25269: LD_VAR 0 2
25273: PPUSH
25274: LD_INT 1
25276: PPUSH
25277: CALL 24520 0 3
25281: ST_TO_ADDR
// InitHc ;
25282: CALL_OW 19
// InitUc ;
25286: CALL_OW 18
// uc_side := side ;
25290: LD_ADDR_OWVAR 20
25294: PUSH
25295: LD_VAR 0 16
25299: ST_TO_ADDR
// uc_nation := nation ;
25300: LD_ADDR_OWVAR 21
25304: PUSH
25305: LD_VAR 0 17
25309: ST_TO_ADDR
// if buildings then
25310: LD_VAR 0 18
25314: IFFALSE 26636
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
25316: LD_ADDR_VAR 0 19
25320: PUSH
25321: LD_VAR 0 18
25325: PPUSH
25326: LD_INT 2
25328: PUSH
25329: LD_INT 30
25331: PUSH
25332: LD_INT 29
25334: PUSH
25335: EMPTY
25336: LIST
25337: LIST
25338: PUSH
25339: LD_INT 30
25341: PUSH
25342: LD_INT 30
25344: PUSH
25345: EMPTY
25346: LIST
25347: LIST
25348: PUSH
25349: EMPTY
25350: LIST
25351: LIST
25352: LIST
25353: PPUSH
25354: CALL_OW 72
25358: ST_TO_ADDR
// if tmp then
25359: LD_VAR 0 19
25363: IFFALSE 25411
// for i in tmp do
25365: LD_ADDR_VAR 0 8
25369: PUSH
25370: LD_VAR 0 19
25374: PUSH
25375: FOR_IN
25376: IFFALSE 25409
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
25378: LD_VAR 0 8
25382: PPUSH
25383: CALL_OW 250
25387: PPUSH
25388: LD_VAR 0 8
25392: PPUSH
25393: CALL_OW 251
25397: PPUSH
25398: LD_VAR 0 16
25402: PPUSH
25403: CALL_OW 441
25407: GO 25375
25409: POP
25410: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
25411: LD_VAR 0 18
25415: PPUSH
25416: LD_INT 2
25418: PUSH
25419: LD_INT 30
25421: PUSH
25422: LD_INT 32
25424: PUSH
25425: EMPTY
25426: LIST
25427: LIST
25428: PUSH
25429: LD_INT 30
25431: PUSH
25432: LD_INT 33
25434: PUSH
25435: EMPTY
25436: LIST
25437: LIST
25438: PUSH
25439: EMPTY
25440: LIST
25441: LIST
25442: LIST
25443: PPUSH
25444: CALL_OW 72
25448: IFFALSE 25536
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
25450: LD_ADDR_VAR 0 8
25454: PUSH
25455: LD_VAR 0 18
25459: PPUSH
25460: LD_INT 2
25462: PUSH
25463: LD_INT 30
25465: PUSH
25466: LD_INT 32
25468: PUSH
25469: EMPTY
25470: LIST
25471: LIST
25472: PUSH
25473: LD_INT 30
25475: PUSH
25476: LD_INT 33
25478: PUSH
25479: EMPTY
25480: LIST
25481: LIST
25482: PUSH
25483: EMPTY
25484: LIST
25485: LIST
25486: LIST
25487: PPUSH
25488: CALL_OW 72
25492: PUSH
25493: FOR_IN
25494: IFFALSE 25534
// begin if not GetBWeapon ( i ) then
25496: LD_VAR 0 8
25500: PPUSH
25501: CALL_OW 269
25505: NOT
25506: IFFALSE 25532
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
25508: LD_VAR 0 8
25512: PPUSH
25513: LD_VAR 0 8
25517: PPUSH
25518: LD_VAR 0 2
25522: PPUSH
25523: CALL 26782 0 2
25527: PPUSH
25528: CALL_OW 431
// end ;
25532: GO 25493
25534: POP
25535: POP
// end ; for i = 1 to personel do
25536: LD_ADDR_VAR 0 8
25540: PUSH
25541: DOUBLE
25542: LD_INT 1
25544: DEC
25545: ST_TO_ADDR
25546: LD_VAR 0 6
25550: PUSH
25551: FOR_TO
25552: IFFALSE 26616
// begin if i > 4 then
25554: LD_VAR 0 8
25558: PUSH
25559: LD_INT 4
25561: GREATER
25562: IFFALSE 25566
// break ;
25564: GO 26616
// case i of 1 :
25566: LD_VAR 0 8
25570: PUSH
25571: LD_INT 1
25573: DOUBLE
25574: EQUAL
25575: IFTRUE 25579
25577: GO 25659
25579: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
25580: LD_ADDR_VAR 0 12
25584: PUSH
25585: LD_VAR 0 18
25589: PPUSH
25590: LD_INT 22
25592: PUSH
25593: LD_VAR 0 16
25597: PUSH
25598: EMPTY
25599: LIST
25600: LIST
25601: PUSH
25602: LD_INT 58
25604: PUSH
25605: EMPTY
25606: LIST
25607: PUSH
25608: LD_INT 2
25610: PUSH
25611: LD_INT 30
25613: PUSH
25614: LD_INT 32
25616: PUSH
25617: EMPTY
25618: LIST
25619: LIST
25620: PUSH
25621: LD_INT 30
25623: PUSH
25624: LD_INT 4
25626: PUSH
25627: EMPTY
25628: LIST
25629: LIST
25630: PUSH
25631: LD_INT 30
25633: PUSH
25634: LD_INT 5
25636: PUSH
25637: EMPTY
25638: LIST
25639: LIST
25640: PUSH
25641: EMPTY
25642: LIST
25643: LIST
25644: LIST
25645: LIST
25646: PUSH
25647: EMPTY
25648: LIST
25649: LIST
25650: LIST
25651: PPUSH
25652: CALL_OW 72
25656: ST_TO_ADDR
25657: GO 25881
25659: LD_INT 2
25661: DOUBLE
25662: EQUAL
25663: IFTRUE 25667
25665: GO 25729
25667: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
25668: LD_ADDR_VAR 0 12
25672: PUSH
25673: LD_VAR 0 18
25677: PPUSH
25678: LD_INT 22
25680: PUSH
25681: LD_VAR 0 16
25685: PUSH
25686: EMPTY
25687: LIST
25688: LIST
25689: PUSH
25690: LD_INT 2
25692: PUSH
25693: LD_INT 30
25695: PUSH
25696: LD_INT 0
25698: PUSH
25699: EMPTY
25700: LIST
25701: LIST
25702: PUSH
25703: LD_INT 30
25705: PUSH
25706: LD_INT 1
25708: PUSH
25709: EMPTY
25710: LIST
25711: LIST
25712: PUSH
25713: EMPTY
25714: LIST
25715: LIST
25716: LIST
25717: PUSH
25718: EMPTY
25719: LIST
25720: LIST
25721: PPUSH
25722: CALL_OW 72
25726: ST_TO_ADDR
25727: GO 25881
25729: LD_INT 3
25731: DOUBLE
25732: EQUAL
25733: IFTRUE 25737
25735: GO 25799
25737: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
25738: LD_ADDR_VAR 0 12
25742: PUSH
25743: LD_VAR 0 18
25747: PPUSH
25748: LD_INT 22
25750: PUSH
25751: LD_VAR 0 16
25755: PUSH
25756: EMPTY
25757: LIST
25758: LIST
25759: PUSH
25760: LD_INT 2
25762: PUSH
25763: LD_INT 30
25765: PUSH
25766: LD_INT 2
25768: PUSH
25769: EMPTY
25770: LIST
25771: LIST
25772: PUSH
25773: LD_INT 30
25775: PUSH
25776: LD_INT 3
25778: PUSH
25779: EMPTY
25780: LIST
25781: LIST
25782: PUSH
25783: EMPTY
25784: LIST
25785: LIST
25786: LIST
25787: PUSH
25788: EMPTY
25789: LIST
25790: LIST
25791: PPUSH
25792: CALL_OW 72
25796: ST_TO_ADDR
25797: GO 25881
25799: LD_INT 4
25801: DOUBLE
25802: EQUAL
25803: IFTRUE 25807
25805: GO 25880
25807: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
25808: LD_ADDR_VAR 0 12
25812: PUSH
25813: LD_VAR 0 18
25817: PPUSH
25818: LD_INT 22
25820: PUSH
25821: LD_VAR 0 16
25825: PUSH
25826: EMPTY
25827: LIST
25828: LIST
25829: PUSH
25830: LD_INT 2
25832: PUSH
25833: LD_INT 30
25835: PUSH
25836: LD_INT 6
25838: PUSH
25839: EMPTY
25840: LIST
25841: LIST
25842: PUSH
25843: LD_INT 30
25845: PUSH
25846: LD_INT 7
25848: PUSH
25849: EMPTY
25850: LIST
25851: LIST
25852: PUSH
25853: LD_INT 30
25855: PUSH
25856: LD_INT 8
25858: PUSH
25859: EMPTY
25860: LIST
25861: LIST
25862: PUSH
25863: EMPTY
25864: LIST
25865: LIST
25866: LIST
25867: LIST
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: PPUSH
25873: CALL_OW 72
25877: ST_TO_ADDR
25878: GO 25881
25880: POP
// if i = 1 then
25881: LD_VAR 0 8
25885: PUSH
25886: LD_INT 1
25888: EQUAL
25889: IFFALSE 26000
// begin tmp := [ ] ;
25891: LD_ADDR_VAR 0 19
25895: PUSH
25896: EMPTY
25897: ST_TO_ADDR
// for j in f do
25898: LD_ADDR_VAR 0 9
25902: PUSH
25903: LD_VAR 0 12
25907: PUSH
25908: FOR_IN
25909: IFFALSE 25982
// if GetBType ( j ) = b_bunker then
25911: LD_VAR 0 9
25915: PPUSH
25916: CALL_OW 266
25920: PUSH
25921: LD_INT 32
25923: EQUAL
25924: IFFALSE 25951
// tmp := Insert ( tmp , 1 , j ) else
25926: LD_ADDR_VAR 0 19
25930: PUSH
25931: LD_VAR 0 19
25935: PPUSH
25936: LD_INT 1
25938: PPUSH
25939: LD_VAR 0 9
25943: PPUSH
25944: CALL_OW 2
25948: ST_TO_ADDR
25949: GO 25980
// tmp := Insert ( tmp , tmp + 1 , j ) ;
25951: LD_ADDR_VAR 0 19
25955: PUSH
25956: LD_VAR 0 19
25960: PPUSH
25961: LD_VAR 0 19
25965: PUSH
25966: LD_INT 1
25968: PLUS
25969: PPUSH
25970: LD_VAR 0 9
25974: PPUSH
25975: CALL_OW 2
25979: ST_TO_ADDR
25980: GO 25908
25982: POP
25983: POP
// if tmp then
25984: LD_VAR 0 19
25988: IFFALSE 26000
// f := tmp ;
25990: LD_ADDR_VAR 0 12
25994: PUSH
25995: LD_VAR 0 19
25999: ST_TO_ADDR
// end ; x := personel [ i ] ;
26000: LD_ADDR_VAR 0 13
26004: PUSH
26005: LD_VAR 0 6
26009: PUSH
26010: LD_VAR 0 8
26014: ARRAY
26015: ST_TO_ADDR
// if x = - 1 then
26016: LD_VAR 0 13
26020: PUSH
26021: LD_INT 1
26023: NEG
26024: EQUAL
26025: IFFALSE 26234
// begin for j in f do
26027: LD_ADDR_VAR 0 9
26031: PUSH
26032: LD_VAR 0 12
26036: PUSH
26037: FOR_IN
26038: IFFALSE 26230
// repeat InitHc ;
26040: CALL_OW 19
// if GetBType ( j ) = b_barracks then
26044: LD_VAR 0 9
26048: PPUSH
26049: CALL_OW 266
26053: PUSH
26054: LD_INT 5
26056: EQUAL
26057: IFFALSE 26127
// begin if UnitsInside ( j ) < 3 then
26059: LD_VAR 0 9
26063: PPUSH
26064: CALL_OW 313
26068: PUSH
26069: LD_INT 3
26071: LESS
26072: IFFALSE 26108
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26074: LD_INT 0
26076: PPUSH
26077: LD_INT 5
26079: PUSH
26080: LD_INT 8
26082: PUSH
26083: LD_INT 9
26085: PUSH
26086: EMPTY
26087: LIST
26088: LIST
26089: LIST
26090: PUSH
26091: LD_VAR 0 17
26095: ARRAY
26096: PPUSH
26097: LD_VAR 0 4
26101: PPUSH
26102: CALL_OW 380
26106: GO 26125
// PrepareHuman ( false , i , skill ) ;
26108: LD_INT 0
26110: PPUSH
26111: LD_VAR 0 8
26115: PPUSH
26116: LD_VAR 0 4
26120: PPUSH
26121: CALL_OW 380
// end else
26125: GO 26144
// PrepareHuman ( false , i , skill ) ;
26127: LD_INT 0
26129: PPUSH
26130: LD_VAR 0 8
26134: PPUSH
26135: LD_VAR 0 4
26139: PPUSH
26140: CALL_OW 380
// un := CreateHuman ;
26144: LD_ADDR_VAR 0 14
26148: PUSH
26149: CALL_OW 44
26153: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26154: LD_ADDR_VAR 0 7
26158: PUSH
26159: LD_VAR 0 7
26163: PPUSH
26164: LD_INT 1
26166: PPUSH
26167: LD_VAR 0 14
26171: PPUSH
26172: CALL_OW 2
26176: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
26177: LD_VAR 0 14
26181: PPUSH
26182: LD_VAR 0 9
26186: PPUSH
26187: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
26191: LD_VAR 0 9
26195: PPUSH
26196: CALL_OW 313
26200: PUSH
26201: LD_INT 6
26203: EQUAL
26204: PUSH
26205: LD_VAR 0 9
26209: PPUSH
26210: CALL_OW 266
26214: PUSH
26215: LD_INT 32
26217: PUSH
26218: LD_INT 31
26220: PUSH
26221: EMPTY
26222: LIST
26223: LIST
26224: IN
26225: OR
26226: IFFALSE 26040
26228: GO 26037
26230: POP
26231: POP
// end else
26232: GO 26614
// for j = 1 to x do
26234: LD_ADDR_VAR 0 9
26238: PUSH
26239: DOUBLE
26240: LD_INT 1
26242: DEC
26243: ST_TO_ADDR
26244: LD_VAR 0 13
26248: PUSH
26249: FOR_TO
26250: IFFALSE 26612
// begin InitHc ;
26252: CALL_OW 19
// if not f then
26256: LD_VAR 0 12
26260: NOT
26261: IFFALSE 26350
// begin PrepareHuman ( false , i , skill ) ;
26263: LD_INT 0
26265: PPUSH
26266: LD_VAR 0 8
26270: PPUSH
26271: LD_VAR 0 4
26275: PPUSH
26276: CALL_OW 380
// un := CreateHuman ;
26280: LD_ADDR_VAR 0 14
26284: PUSH
26285: CALL_OW 44
26289: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26290: LD_ADDR_VAR 0 7
26294: PUSH
26295: LD_VAR 0 7
26299: PPUSH
26300: LD_INT 1
26302: PPUSH
26303: LD_VAR 0 14
26307: PPUSH
26308: CALL_OW 2
26312: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26313: LD_VAR 0 14
26317: PPUSH
26318: LD_VAR 0 1
26322: PPUSH
26323: CALL_OW 250
26327: PPUSH
26328: LD_VAR 0 1
26332: PPUSH
26333: CALL_OW 251
26337: PPUSH
26338: LD_INT 10
26340: PPUSH
26341: LD_INT 0
26343: PPUSH
26344: CALL_OW 50
// continue ;
26348: GO 26249
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
26350: LD_VAR 0 12
26354: PUSH
26355: LD_INT 1
26357: ARRAY
26358: PPUSH
26359: CALL_OW 313
26363: PUSH
26364: LD_VAR 0 12
26368: PUSH
26369: LD_INT 1
26371: ARRAY
26372: PPUSH
26373: CALL_OW 266
26377: PUSH
26378: LD_INT 32
26380: PUSH
26381: LD_INT 31
26383: PUSH
26384: EMPTY
26385: LIST
26386: LIST
26387: IN
26388: AND
26389: PUSH
26390: LD_VAR 0 12
26394: PUSH
26395: LD_INT 1
26397: ARRAY
26398: PPUSH
26399: CALL_OW 313
26403: PUSH
26404: LD_INT 6
26406: EQUAL
26407: OR
26408: IFFALSE 26428
// f := Delete ( f , 1 ) ;
26410: LD_ADDR_VAR 0 12
26414: PUSH
26415: LD_VAR 0 12
26419: PPUSH
26420: LD_INT 1
26422: PPUSH
26423: CALL_OW 3
26427: ST_TO_ADDR
// if not f then
26428: LD_VAR 0 12
26432: NOT
26433: IFFALSE 26451
// begin x := x + 2 ;
26435: LD_ADDR_VAR 0 13
26439: PUSH
26440: LD_VAR 0 13
26444: PUSH
26445: LD_INT 2
26447: PLUS
26448: ST_TO_ADDR
// continue ;
26449: GO 26249
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
26451: LD_VAR 0 12
26455: PUSH
26456: LD_INT 1
26458: ARRAY
26459: PPUSH
26460: CALL_OW 266
26464: PUSH
26465: LD_INT 5
26467: EQUAL
26468: IFFALSE 26542
// begin if UnitsInside ( f [ 1 ] ) < 3 then
26470: LD_VAR 0 12
26474: PUSH
26475: LD_INT 1
26477: ARRAY
26478: PPUSH
26479: CALL_OW 313
26483: PUSH
26484: LD_INT 3
26486: LESS
26487: IFFALSE 26523
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26489: LD_INT 0
26491: PPUSH
26492: LD_INT 5
26494: PUSH
26495: LD_INT 8
26497: PUSH
26498: LD_INT 9
26500: PUSH
26501: EMPTY
26502: LIST
26503: LIST
26504: LIST
26505: PUSH
26506: LD_VAR 0 17
26510: ARRAY
26511: PPUSH
26512: LD_VAR 0 4
26516: PPUSH
26517: CALL_OW 380
26521: GO 26540
// PrepareHuman ( false , i , skill ) ;
26523: LD_INT 0
26525: PPUSH
26526: LD_VAR 0 8
26530: PPUSH
26531: LD_VAR 0 4
26535: PPUSH
26536: CALL_OW 380
// end else
26540: GO 26559
// PrepareHuman ( false , i , skill ) ;
26542: LD_INT 0
26544: PPUSH
26545: LD_VAR 0 8
26549: PPUSH
26550: LD_VAR 0 4
26554: PPUSH
26555: CALL_OW 380
// un := CreateHuman ;
26559: LD_ADDR_VAR 0 14
26563: PUSH
26564: CALL_OW 44
26568: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26569: LD_ADDR_VAR 0 7
26573: PUSH
26574: LD_VAR 0 7
26578: PPUSH
26579: LD_INT 1
26581: PPUSH
26582: LD_VAR 0 14
26586: PPUSH
26587: CALL_OW 2
26591: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
26592: LD_VAR 0 14
26596: PPUSH
26597: LD_VAR 0 12
26601: PUSH
26602: LD_INT 1
26604: ARRAY
26605: PPUSH
26606: CALL_OW 52
// end ;
26610: GO 26249
26612: POP
26613: POP
// end ;
26614: GO 25551
26616: POP
26617: POP
// result := result ^ buildings ;
26618: LD_ADDR_VAR 0 7
26622: PUSH
26623: LD_VAR 0 7
26627: PUSH
26628: LD_VAR 0 18
26632: ADD
26633: ST_TO_ADDR
// end else
26634: GO 26777
// begin for i = 1 to personel do
26636: LD_ADDR_VAR 0 8
26640: PUSH
26641: DOUBLE
26642: LD_INT 1
26644: DEC
26645: ST_TO_ADDR
26646: LD_VAR 0 6
26650: PUSH
26651: FOR_TO
26652: IFFALSE 26775
// begin if i > 4 then
26654: LD_VAR 0 8
26658: PUSH
26659: LD_INT 4
26661: GREATER
26662: IFFALSE 26666
// break ;
26664: GO 26775
// x := personel [ i ] ;
26666: LD_ADDR_VAR 0 13
26670: PUSH
26671: LD_VAR 0 6
26675: PUSH
26676: LD_VAR 0 8
26680: ARRAY
26681: ST_TO_ADDR
// if x = - 1 then
26682: LD_VAR 0 13
26686: PUSH
26687: LD_INT 1
26689: NEG
26690: EQUAL
26691: IFFALSE 26695
// continue ;
26693: GO 26651
// PrepareHuman ( false , i , skill ) ;
26695: LD_INT 0
26697: PPUSH
26698: LD_VAR 0 8
26702: PPUSH
26703: LD_VAR 0 4
26707: PPUSH
26708: CALL_OW 380
// un := CreateHuman ;
26712: LD_ADDR_VAR 0 14
26716: PUSH
26717: CALL_OW 44
26721: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26722: LD_VAR 0 14
26726: PPUSH
26727: LD_VAR 0 1
26731: PPUSH
26732: CALL_OW 250
26736: PPUSH
26737: LD_VAR 0 1
26741: PPUSH
26742: CALL_OW 251
26746: PPUSH
26747: LD_INT 10
26749: PPUSH
26750: LD_INT 0
26752: PPUSH
26753: CALL_OW 50
// result := result ^ un ;
26757: LD_ADDR_VAR 0 7
26761: PUSH
26762: LD_VAR 0 7
26766: PUSH
26767: LD_VAR 0 14
26771: ADD
26772: ST_TO_ADDR
// end ;
26773: GO 26651
26775: POP
26776: POP
// end ; end ;
26777: LD_VAR 0 7
26781: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
26782: LD_INT 0
26784: PPUSH
26785: PPUSH
26786: PPUSH
26787: PPUSH
26788: PPUSH
26789: PPUSH
26790: PPUSH
26791: PPUSH
26792: PPUSH
26793: PPUSH
26794: PPUSH
26795: PPUSH
26796: PPUSH
26797: PPUSH
26798: PPUSH
26799: PPUSH
// result := false ;
26800: LD_ADDR_VAR 0 3
26804: PUSH
26805: LD_INT 0
26807: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
26808: LD_VAR 0 1
26812: NOT
26813: PUSH
26814: LD_VAR 0 1
26818: PPUSH
26819: CALL_OW 266
26823: PUSH
26824: LD_INT 32
26826: PUSH
26827: LD_INT 33
26829: PUSH
26830: EMPTY
26831: LIST
26832: LIST
26833: IN
26834: NOT
26835: OR
26836: IFFALSE 26840
// exit ;
26838: GO 27949
// nat := GetNation ( tower ) ;
26840: LD_ADDR_VAR 0 12
26844: PUSH
26845: LD_VAR 0 1
26849: PPUSH
26850: CALL_OW 248
26854: ST_TO_ADDR
// side := GetSide ( tower ) ;
26855: LD_ADDR_VAR 0 16
26859: PUSH
26860: LD_VAR 0 1
26864: PPUSH
26865: CALL_OW 255
26869: ST_TO_ADDR
// x := GetX ( tower ) ;
26870: LD_ADDR_VAR 0 10
26874: PUSH
26875: LD_VAR 0 1
26879: PPUSH
26880: CALL_OW 250
26884: ST_TO_ADDR
// y := GetY ( tower ) ;
26885: LD_ADDR_VAR 0 11
26889: PUSH
26890: LD_VAR 0 1
26894: PPUSH
26895: CALL_OW 251
26899: ST_TO_ADDR
// if not x or not y then
26900: LD_VAR 0 10
26904: NOT
26905: PUSH
26906: LD_VAR 0 11
26910: NOT
26911: OR
26912: IFFALSE 26916
// exit ;
26914: GO 27949
// weapon := 0 ;
26916: LD_ADDR_VAR 0 18
26920: PUSH
26921: LD_INT 0
26923: ST_TO_ADDR
// fac_list := [ ] ;
26924: LD_ADDR_VAR 0 17
26928: PUSH
26929: EMPTY
26930: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
26931: LD_ADDR_VAR 0 6
26935: PUSH
26936: LD_VAR 0 1
26940: PPUSH
26941: CALL_OW 274
26945: PPUSH
26946: LD_VAR 0 2
26950: PPUSH
26951: LD_INT 0
26953: PPUSH
26954: CALL 24520 0 3
26958: PPUSH
26959: LD_INT 30
26961: PUSH
26962: LD_INT 3
26964: PUSH
26965: EMPTY
26966: LIST
26967: LIST
26968: PPUSH
26969: CALL_OW 72
26973: ST_TO_ADDR
// if not factories then
26974: LD_VAR 0 6
26978: NOT
26979: IFFALSE 26983
// exit ;
26981: GO 27949
// for i in factories do
26983: LD_ADDR_VAR 0 8
26987: PUSH
26988: LD_VAR 0 6
26992: PUSH
26993: FOR_IN
26994: IFFALSE 27019
// fac_list := fac_list union AvailableWeaponList ( i ) ;
26996: LD_ADDR_VAR 0 17
27000: PUSH
27001: LD_VAR 0 17
27005: PUSH
27006: LD_VAR 0 8
27010: PPUSH
27011: CALL_OW 478
27015: UNION
27016: ST_TO_ADDR
27017: GO 26993
27019: POP
27020: POP
// if not fac_list then
27021: LD_VAR 0 17
27025: NOT
27026: IFFALSE 27030
// exit ;
27028: GO 27949
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
27030: LD_ADDR_VAR 0 5
27034: PUSH
27035: LD_INT 4
27037: PUSH
27038: LD_INT 5
27040: PUSH
27041: LD_INT 9
27043: PUSH
27044: LD_INT 10
27046: PUSH
27047: LD_INT 6
27049: PUSH
27050: LD_INT 7
27052: PUSH
27053: LD_INT 11
27055: PUSH
27056: EMPTY
27057: LIST
27058: LIST
27059: LIST
27060: LIST
27061: LIST
27062: LIST
27063: LIST
27064: PUSH
27065: LD_INT 27
27067: PUSH
27068: LD_INT 28
27070: PUSH
27071: LD_INT 26
27073: PUSH
27074: LD_INT 30
27076: PUSH
27077: EMPTY
27078: LIST
27079: LIST
27080: LIST
27081: LIST
27082: PUSH
27083: LD_INT 43
27085: PUSH
27086: LD_INT 44
27088: PUSH
27089: LD_INT 46
27091: PUSH
27092: LD_INT 45
27094: PUSH
27095: LD_INT 47
27097: PUSH
27098: LD_INT 49
27100: PUSH
27101: EMPTY
27102: LIST
27103: LIST
27104: LIST
27105: LIST
27106: LIST
27107: LIST
27108: PUSH
27109: EMPTY
27110: LIST
27111: LIST
27112: LIST
27113: PUSH
27114: LD_VAR 0 12
27118: ARRAY
27119: ST_TO_ADDR
// list := list isect fac_list ;
27120: LD_ADDR_VAR 0 5
27124: PUSH
27125: LD_VAR 0 5
27129: PUSH
27130: LD_VAR 0 17
27134: ISECT
27135: ST_TO_ADDR
// if not list then
27136: LD_VAR 0 5
27140: NOT
27141: IFFALSE 27145
// exit ;
27143: GO 27949
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
27145: LD_VAR 0 12
27149: PUSH
27150: LD_INT 3
27152: EQUAL
27153: PUSH
27154: LD_INT 49
27156: PUSH
27157: LD_VAR 0 5
27161: IN
27162: AND
27163: PUSH
27164: LD_INT 31
27166: PPUSH
27167: LD_VAR 0 16
27171: PPUSH
27172: CALL_OW 321
27176: PUSH
27177: LD_INT 2
27179: EQUAL
27180: AND
27181: IFFALSE 27241
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
27183: LD_INT 22
27185: PUSH
27186: LD_VAR 0 16
27190: PUSH
27191: EMPTY
27192: LIST
27193: LIST
27194: PUSH
27195: LD_INT 35
27197: PUSH
27198: LD_INT 49
27200: PUSH
27201: EMPTY
27202: LIST
27203: LIST
27204: PUSH
27205: LD_INT 91
27207: PUSH
27208: LD_VAR 0 1
27212: PUSH
27213: LD_INT 10
27215: PUSH
27216: EMPTY
27217: LIST
27218: LIST
27219: LIST
27220: PUSH
27221: EMPTY
27222: LIST
27223: LIST
27224: LIST
27225: PPUSH
27226: CALL_OW 69
27230: NOT
27231: IFFALSE 27241
// weapon := ru_time_lapser ;
27233: LD_ADDR_VAR 0 18
27237: PUSH
27238: LD_INT 49
27240: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
27241: LD_VAR 0 12
27245: PUSH
27246: LD_INT 1
27248: PUSH
27249: LD_INT 2
27251: PUSH
27252: EMPTY
27253: LIST
27254: LIST
27255: IN
27256: PUSH
27257: LD_INT 11
27259: PUSH
27260: LD_VAR 0 5
27264: IN
27265: PUSH
27266: LD_INT 30
27268: PUSH
27269: LD_VAR 0 5
27273: IN
27274: OR
27275: AND
27276: PUSH
27277: LD_INT 6
27279: PPUSH
27280: LD_VAR 0 16
27284: PPUSH
27285: CALL_OW 321
27289: PUSH
27290: LD_INT 2
27292: EQUAL
27293: AND
27294: IFFALSE 27459
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
27296: LD_INT 22
27298: PUSH
27299: LD_VAR 0 16
27303: PUSH
27304: EMPTY
27305: LIST
27306: LIST
27307: PUSH
27308: LD_INT 2
27310: PUSH
27311: LD_INT 35
27313: PUSH
27314: LD_INT 11
27316: PUSH
27317: EMPTY
27318: LIST
27319: LIST
27320: PUSH
27321: LD_INT 35
27323: PUSH
27324: LD_INT 30
27326: PUSH
27327: EMPTY
27328: LIST
27329: LIST
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: LIST
27335: PUSH
27336: LD_INT 91
27338: PUSH
27339: LD_VAR 0 1
27343: PUSH
27344: LD_INT 18
27346: PUSH
27347: EMPTY
27348: LIST
27349: LIST
27350: LIST
27351: PUSH
27352: EMPTY
27353: LIST
27354: LIST
27355: LIST
27356: PPUSH
27357: CALL_OW 69
27361: NOT
27362: PUSH
27363: LD_INT 22
27365: PUSH
27366: LD_VAR 0 16
27370: PUSH
27371: EMPTY
27372: LIST
27373: LIST
27374: PUSH
27375: LD_INT 2
27377: PUSH
27378: LD_INT 30
27380: PUSH
27381: LD_INT 32
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: PUSH
27388: LD_INT 30
27390: PUSH
27391: LD_INT 33
27393: PUSH
27394: EMPTY
27395: LIST
27396: LIST
27397: PUSH
27398: EMPTY
27399: LIST
27400: LIST
27401: LIST
27402: PUSH
27403: LD_INT 91
27405: PUSH
27406: LD_VAR 0 1
27410: PUSH
27411: LD_INT 12
27413: PUSH
27414: EMPTY
27415: LIST
27416: LIST
27417: LIST
27418: PUSH
27419: EMPTY
27420: LIST
27421: LIST
27422: LIST
27423: PUSH
27424: EMPTY
27425: LIST
27426: PPUSH
27427: CALL_OW 69
27431: PUSH
27432: LD_INT 2
27434: GREATER
27435: AND
27436: IFFALSE 27459
// weapon := [ us_radar , ar_radar ] [ nat ] ;
27438: LD_ADDR_VAR 0 18
27442: PUSH
27443: LD_INT 11
27445: PUSH
27446: LD_INT 30
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: PUSH
27453: LD_VAR 0 12
27457: ARRAY
27458: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
27459: LD_VAR 0 18
27463: NOT
27464: PUSH
27465: LD_INT 40
27467: PPUSH
27468: LD_VAR 0 16
27472: PPUSH
27473: CALL_OW 321
27477: PUSH
27478: LD_INT 2
27480: EQUAL
27481: AND
27482: PUSH
27483: LD_INT 7
27485: PUSH
27486: LD_VAR 0 5
27490: IN
27491: PUSH
27492: LD_INT 28
27494: PUSH
27495: LD_VAR 0 5
27499: IN
27500: OR
27501: PUSH
27502: LD_INT 45
27504: PUSH
27505: LD_VAR 0 5
27509: IN
27510: OR
27511: AND
27512: IFFALSE 27766
// begin hex := GetHexInfo ( x , y ) ;
27514: LD_ADDR_VAR 0 4
27518: PUSH
27519: LD_VAR 0 10
27523: PPUSH
27524: LD_VAR 0 11
27528: PPUSH
27529: CALL_OW 546
27533: ST_TO_ADDR
// if hex [ 1 ] then
27534: LD_VAR 0 4
27538: PUSH
27539: LD_INT 1
27541: ARRAY
27542: IFFALSE 27546
// exit ;
27544: GO 27949
// height := hex [ 2 ] ;
27546: LD_ADDR_VAR 0 15
27550: PUSH
27551: LD_VAR 0 4
27555: PUSH
27556: LD_INT 2
27558: ARRAY
27559: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
27560: LD_ADDR_VAR 0 14
27564: PUSH
27565: LD_INT 0
27567: PUSH
27568: LD_INT 2
27570: PUSH
27571: LD_INT 3
27573: PUSH
27574: LD_INT 5
27576: PUSH
27577: EMPTY
27578: LIST
27579: LIST
27580: LIST
27581: LIST
27582: ST_TO_ADDR
// for i in tmp do
27583: LD_ADDR_VAR 0 8
27587: PUSH
27588: LD_VAR 0 14
27592: PUSH
27593: FOR_IN
27594: IFFALSE 27764
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
27596: LD_ADDR_VAR 0 9
27600: PUSH
27601: LD_VAR 0 10
27605: PPUSH
27606: LD_VAR 0 8
27610: PPUSH
27611: LD_INT 5
27613: PPUSH
27614: CALL_OW 272
27618: PUSH
27619: LD_VAR 0 11
27623: PPUSH
27624: LD_VAR 0 8
27628: PPUSH
27629: LD_INT 5
27631: PPUSH
27632: CALL_OW 273
27636: PUSH
27637: EMPTY
27638: LIST
27639: LIST
27640: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
27641: LD_VAR 0 9
27645: PUSH
27646: LD_INT 1
27648: ARRAY
27649: PPUSH
27650: LD_VAR 0 9
27654: PUSH
27655: LD_INT 2
27657: ARRAY
27658: PPUSH
27659: CALL_OW 488
27663: IFFALSE 27762
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
27665: LD_ADDR_VAR 0 4
27669: PUSH
27670: LD_VAR 0 9
27674: PUSH
27675: LD_INT 1
27677: ARRAY
27678: PPUSH
27679: LD_VAR 0 9
27683: PUSH
27684: LD_INT 2
27686: ARRAY
27687: PPUSH
27688: CALL_OW 546
27692: ST_TO_ADDR
// if hex [ 1 ] then
27693: LD_VAR 0 4
27697: PUSH
27698: LD_INT 1
27700: ARRAY
27701: IFFALSE 27705
// continue ;
27703: GO 27593
// h := hex [ 2 ] ;
27705: LD_ADDR_VAR 0 13
27709: PUSH
27710: LD_VAR 0 4
27714: PUSH
27715: LD_INT 2
27717: ARRAY
27718: ST_TO_ADDR
// if h + 7 < height then
27719: LD_VAR 0 13
27723: PUSH
27724: LD_INT 7
27726: PLUS
27727: PUSH
27728: LD_VAR 0 15
27732: LESS
27733: IFFALSE 27762
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
27735: LD_ADDR_VAR 0 18
27739: PUSH
27740: LD_INT 7
27742: PUSH
27743: LD_INT 28
27745: PUSH
27746: LD_INT 45
27748: PUSH
27749: EMPTY
27750: LIST
27751: LIST
27752: LIST
27753: PUSH
27754: LD_VAR 0 12
27758: ARRAY
27759: ST_TO_ADDR
// break ;
27760: GO 27764
// end ; end ; end ;
27762: GO 27593
27764: POP
27765: POP
// end ; if not weapon then
27766: LD_VAR 0 18
27770: NOT
27771: IFFALSE 27831
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
27773: LD_ADDR_VAR 0 5
27777: PUSH
27778: LD_VAR 0 5
27782: PUSH
27783: LD_INT 11
27785: PUSH
27786: LD_INT 30
27788: PUSH
27789: LD_INT 49
27791: PUSH
27792: EMPTY
27793: LIST
27794: LIST
27795: LIST
27796: DIFF
27797: ST_TO_ADDR
// if not list then
27798: LD_VAR 0 5
27802: NOT
27803: IFFALSE 27807
// exit ;
27805: GO 27949
// weapon := list [ rand ( 1 , list ) ] ;
27807: LD_ADDR_VAR 0 18
27811: PUSH
27812: LD_VAR 0 5
27816: PUSH
27817: LD_INT 1
27819: PPUSH
27820: LD_VAR 0 5
27824: PPUSH
27825: CALL_OW 12
27829: ARRAY
27830: ST_TO_ADDR
// end ; if weapon then
27831: LD_VAR 0 18
27835: IFFALSE 27949
// begin tmp := CostOfWeapon ( weapon ) ;
27837: LD_ADDR_VAR 0 14
27841: PUSH
27842: LD_VAR 0 18
27846: PPUSH
27847: CALL_OW 451
27851: ST_TO_ADDR
// j := GetBase ( tower ) ;
27852: LD_ADDR_VAR 0 9
27856: PUSH
27857: LD_VAR 0 1
27861: PPUSH
27862: CALL_OW 274
27866: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
27867: LD_VAR 0 9
27871: PPUSH
27872: LD_INT 1
27874: PPUSH
27875: CALL_OW 275
27879: PUSH
27880: LD_VAR 0 14
27884: PUSH
27885: LD_INT 1
27887: ARRAY
27888: GREATEREQUAL
27889: PUSH
27890: LD_VAR 0 9
27894: PPUSH
27895: LD_INT 2
27897: PPUSH
27898: CALL_OW 275
27902: PUSH
27903: LD_VAR 0 14
27907: PUSH
27908: LD_INT 2
27910: ARRAY
27911: GREATEREQUAL
27912: AND
27913: PUSH
27914: LD_VAR 0 9
27918: PPUSH
27919: LD_INT 3
27921: PPUSH
27922: CALL_OW 275
27926: PUSH
27927: LD_VAR 0 14
27931: PUSH
27932: LD_INT 3
27934: ARRAY
27935: GREATEREQUAL
27936: AND
27937: IFFALSE 27949
// result := weapon ;
27939: LD_ADDR_VAR 0 3
27943: PUSH
27944: LD_VAR 0 18
27948: ST_TO_ADDR
// end ; end ;
27949: LD_VAR 0 3
27953: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
27954: LD_INT 0
27956: PPUSH
27957: PPUSH
// result := true ;
27958: LD_ADDR_VAR 0 3
27962: PUSH
27963: LD_INT 1
27965: ST_TO_ADDR
// if array1 = array2 then
27966: LD_VAR 0 1
27970: PUSH
27971: LD_VAR 0 2
27975: EQUAL
27976: IFFALSE 28036
// begin for i = 1 to array1 do
27978: LD_ADDR_VAR 0 4
27982: PUSH
27983: DOUBLE
27984: LD_INT 1
27986: DEC
27987: ST_TO_ADDR
27988: LD_VAR 0 1
27992: PUSH
27993: FOR_TO
27994: IFFALSE 28032
// if array1 [ i ] <> array2 [ i ] then
27996: LD_VAR 0 1
28000: PUSH
28001: LD_VAR 0 4
28005: ARRAY
28006: PUSH
28007: LD_VAR 0 2
28011: PUSH
28012: LD_VAR 0 4
28016: ARRAY
28017: NONEQUAL
28018: IFFALSE 28030
// begin result := false ;
28020: LD_ADDR_VAR 0 3
28024: PUSH
28025: LD_INT 0
28027: ST_TO_ADDR
// break ;
28028: GO 28032
// end ;
28030: GO 27993
28032: POP
28033: POP
// end else
28034: GO 28044
// result := false ;
28036: LD_ADDR_VAR 0 3
28040: PUSH
28041: LD_INT 0
28043: ST_TO_ADDR
// end ;
28044: LD_VAR 0 3
28048: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
28049: LD_INT 0
28051: PPUSH
28052: PPUSH
// if not array1 or not array2 then
28053: LD_VAR 0 1
28057: NOT
28058: PUSH
28059: LD_VAR 0 2
28063: NOT
28064: OR
28065: IFFALSE 28069
// exit ;
28067: GO 28133
// result := true ;
28069: LD_ADDR_VAR 0 3
28073: PUSH
28074: LD_INT 1
28076: ST_TO_ADDR
// for i = 1 to array1 do
28077: LD_ADDR_VAR 0 4
28081: PUSH
28082: DOUBLE
28083: LD_INT 1
28085: DEC
28086: ST_TO_ADDR
28087: LD_VAR 0 1
28091: PUSH
28092: FOR_TO
28093: IFFALSE 28131
// if array1 [ i ] <> array2 [ i ] then
28095: LD_VAR 0 1
28099: PUSH
28100: LD_VAR 0 4
28104: ARRAY
28105: PUSH
28106: LD_VAR 0 2
28110: PUSH
28111: LD_VAR 0 4
28115: ARRAY
28116: NONEQUAL
28117: IFFALSE 28129
// begin result := false ;
28119: LD_ADDR_VAR 0 3
28123: PUSH
28124: LD_INT 0
28126: ST_TO_ADDR
// break ;
28127: GO 28131
// end ;
28129: GO 28092
28131: POP
28132: POP
// end ;
28133: LD_VAR 0 3
28137: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
28138: LD_INT 0
28140: PPUSH
28141: PPUSH
28142: PPUSH
// pom := GetBase ( fac ) ;
28143: LD_ADDR_VAR 0 5
28147: PUSH
28148: LD_VAR 0 1
28152: PPUSH
28153: CALL_OW 274
28157: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
28158: LD_ADDR_VAR 0 4
28162: PUSH
28163: LD_VAR 0 2
28167: PUSH
28168: LD_INT 1
28170: ARRAY
28171: PPUSH
28172: LD_VAR 0 2
28176: PUSH
28177: LD_INT 2
28179: ARRAY
28180: PPUSH
28181: LD_VAR 0 2
28185: PUSH
28186: LD_INT 3
28188: ARRAY
28189: PPUSH
28190: LD_VAR 0 2
28194: PUSH
28195: LD_INT 4
28197: ARRAY
28198: PPUSH
28199: CALL_OW 449
28203: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28204: LD_ADDR_VAR 0 3
28208: PUSH
28209: LD_VAR 0 5
28213: PPUSH
28214: LD_INT 1
28216: PPUSH
28217: CALL_OW 275
28221: PUSH
28222: LD_VAR 0 4
28226: PUSH
28227: LD_INT 1
28229: ARRAY
28230: GREATEREQUAL
28231: PUSH
28232: LD_VAR 0 5
28236: PPUSH
28237: LD_INT 2
28239: PPUSH
28240: CALL_OW 275
28244: PUSH
28245: LD_VAR 0 4
28249: PUSH
28250: LD_INT 2
28252: ARRAY
28253: GREATEREQUAL
28254: AND
28255: PUSH
28256: LD_VAR 0 5
28260: PPUSH
28261: LD_INT 3
28263: PPUSH
28264: CALL_OW 275
28268: PUSH
28269: LD_VAR 0 4
28273: PUSH
28274: LD_INT 3
28276: ARRAY
28277: GREATEREQUAL
28278: AND
28279: ST_TO_ADDR
// end ;
28280: LD_VAR 0 3
28284: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
28285: LD_INT 0
28287: PPUSH
28288: PPUSH
28289: PPUSH
28290: PPUSH
// pom := GetBase ( building ) ;
28291: LD_ADDR_VAR 0 3
28295: PUSH
28296: LD_VAR 0 1
28300: PPUSH
28301: CALL_OW 274
28305: ST_TO_ADDR
// if not pom then
28306: LD_VAR 0 3
28310: NOT
28311: IFFALSE 28315
// exit ;
28313: GO 28485
// btype := GetBType ( building ) ;
28315: LD_ADDR_VAR 0 5
28319: PUSH
28320: LD_VAR 0 1
28324: PPUSH
28325: CALL_OW 266
28329: ST_TO_ADDR
// if btype = b_armoury then
28330: LD_VAR 0 5
28334: PUSH
28335: LD_INT 4
28337: EQUAL
28338: IFFALSE 28348
// btype := b_barracks ;
28340: LD_ADDR_VAR 0 5
28344: PUSH
28345: LD_INT 5
28347: ST_TO_ADDR
// if btype = b_depot then
28348: LD_VAR 0 5
28352: PUSH
28353: LD_INT 0
28355: EQUAL
28356: IFFALSE 28366
// btype := b_warehouse ;
28358: LD_ADDR_VAR 0 5
28362: PUSH
28363: LD_INT 1
28365: ST_TO_ADDR
// if btype = b_workshop then
28366: LD_VAR 0 5
28370: PUSH
28371: LD_INT 2
28373: EQUAL
28374: IFFALSE 28384
// btype := b_factory ;
28376: LD_ADDR_VAR 0 5
28380: PUSH
28381: LD_INT 3
28383: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28384: LD_ADDR_VAR 0 4
28388: PUSH
28389: LD_VAR 0 5
28393: PPUSH
28394: LD_VAR 0 1
28398: PPUSH
28399: CALL_OW 248
28403: PPUSH
28404: CALL_OW 450
28408: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28409: LD_ADDR_VAR 0 2
28413: PUSH
28414: LD_VAR 0 3
28418: PPUSH
28419: LD_INT 1
28421: PPUSH
28422: CALL_OW 275
28426: PUSH
28427: LD_VAR 0 4
28431: PUSH
28432: LD_INT 1
28434: ARRAY
28435: GREATEREQUAL
28436: PUSH
28437: LD_VAR 0 3
28441: PPUSH
28442: LD_INT 2
28444: PPUSH
28445: CALL_OW 275
28449: PUSH
28450: LD_VAR 0 4
28454: PUSH
28455: LD_INT 2
28457: ARRAY
28458: GREATEREQUAL
28459: AND
28460: PUSH
28461: LD_VAR 0 3
28465: PPUSH
28466: LD_INT 3
28468: PPUSH
28469: CALL_OW 275
28473: PUSH
28474: LD_VAR 0 4
28478: PUSH
28479: LD_INT 3
28481: ARRAY
28482: GREATEREQUAL
28483: AND
28484: ST_TO_ADDR
// end ;
28485: LD_VAR 0 2
28489: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
28490: LD_INT 0
28492: PPUSH
28493: PPUSH
28494: PPUSH
// pom := GetBase ( building ) ;
28495: LD_ADDR_VAR 0 4
28499: PUSH
28500: LD_VAR 0 1
28504: PPUSH
28505: CALL_OW 274
28509: ST_TO_ADDR
// if not pom then
28510: LD_VAR 0 4
28514: NOT
28515: IFFALSE 28519
// exit ;
28517: GO 28620
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28519: LD_ADDR_VAR 0 5
28523: PUSH
28524: LD_VAR 0 2
28528: PPUSH
28529: LD_VAR 0 1
28533: PPUSH
28534: CALL_OW 248
28538: PPUSH
28539: CALL_OW 450
28543: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28544: LD_ADDR_VAR 0 3
28548: PUSH
28549: LD_VAR 0 4
28553: PPUSH
28554: LD_INT 1
28556: PPUSH
28557: CALL_OW 275
28561: PUSH
28562: LD_VAR 0 5
28566: PUSH
28567: LD_INT 1
28569: ARRAY
28570: GREATEREQUAL
28571: PUSH
28572: LD_VAR 0 4
28576: PPUSH
28577: LD_INT 2
28579: PPUSH
28580: CALL_OW 275
28584: PUSH
28585: LD_VAR 0 5
28589: PUSH
28590: LD_INT 2
28592: ARRAY
28593: GREATEREQUAL
28594: AND
28595: PUSH
28596: LD_VAR 0 4
28600: PPUSH
28601: LD_INT 3
28603: PPUSH
28604: CALL_OW 275
28608: PUSH
28609: LD_VAR 0 5
28613: PUSH
28614: LD_INT 3
28616: ARRAY
28617: GREATEREQUAL
28618: AND
28619: ST_TO_ADDR
// end ;
28620: LD_VAR 0 3
28624: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
28625: LD_INT 0
28627: PPUSH
28628: PPUSH
28629: PPUSH
28630: PPUSH
28631: PPUSH
28632: PPUSH
28633: PPUSH
28634: PPUSH
28635: PPUSH
28636: PPUSH
28637: PPUSH
// result := false ;
28638: LD_ADDR_VAR 0 8
28642: PUSH
28643: LD_INT 0
28645: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
28646: LD_VAR 0 5
28650: NOT
28651: PUSH
28652: LD_VAR 0 1
28656: NOT
28657: OR
28658: PUSH
28659: LD_VAR 0 2
28663: NOT
28664: OR
28665: PUSH
28666: LD_VAR 0 3
28670: NOT
28671: OR
28672: IFFALSE 28676
// exit ;
28674: GO 29490
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
28676: LD_ADDR_VAR 0 14
28680: PUSH
28681: LD_VAR 0 1
28685: PPUSH
28686: LD_VAR 0 2
28690: PPUSH
28691: LD_VAR 0 3
28695: PPUSH
28696: LD_VAR 0 4
28700: PPUSH
28701: LD_VAR 0 5
28705: PUSH
28706: LD_INT 1
28708: ARRAY
28709: PPUSH
28710: CALL_OW 248
28714: PPUSH
28715: LD_INT 0
28717: PPUSH
28718: CALL 30743 0 6
28722: ST_TO_ADDR
// if not hexes then
28723: LD_VAR 0 14
28727: NOT
28728: IFFALSE 28732
// exit ;
28730: GO 29490
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28732: LD_ADDR_VAR 0 17
28736: PUSH
28737: LD_VAR 0 5
28741: PPUSH
28742: LD_INT 22
28744: PUSH
28745: LD_VAR 0 13
28749: PPUSH
28750: CALL_OW 255
28754: PUSH
28755: EMPTY
28756: LIST
28757: LIST
28758: PUSH
28759: LD_INT 2
28761: PUSH
28762: LD_INT 30
28764: PUSH
28765: LD_INT 0
28767: PUSH
28768: EMPTY
28769: LIST
28770: LIST
28771: PUSH
28772: LD_INT 30
28774: PUSH
28775: LD_INT 1
28777: PUSH
28778: EMPTY
28779: LIST
28780: LIST
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: LIST
28786: PUSH
28787: EMPTY
28788: LIST
28789: LIST
28790: PPUSH
28791: CALL_OW 72
28795: ST_TO_ADDR
// for i = 1 to hexes do
28796: LD_ADDR_VAR 0 9
28800: PUSH
28801: DOUBLE
28802: LD_INT 1
28804: DEC
28805: ST_TO_ADDR
28806: LD_VAR 0 14
28810: PUSH
28811: FOR_TO
28812: IFFALSE 29488
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28814: LD_ADDR_VAR 0 13
28818: PUSH
28819: LD_VAR 0 14
28823: PUSH
28824: LD_VAR 0 9
28828: ARRAY
28829: PUSH
28830: LD_INT 1
28832: ARRAY
28833: PPUSH
28834: LD_VAR 0 14
28838: PUSH
28839: LD_VAR 0 9
28843: ARRAY
28844: PUSH
28845: LD_INT 2
28847: ARRAY
28848: PPUSH
28849: CALL_OW 428
28853: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
28854: LD_VAR 0 14
28858: PUSH
28859: LD_VAR 0 9
28863: ARRAY
28864: PUSH
28865: LD_INT 1
28867: ARRAY
28868: PPUSH
28869: LD_VAR 0 14
28873: PUSH
28874: LD_VAR 0 9
28878: ARRAY
28879: PUSH
28880: LD_INT 2
28882: ARRAY
28883: PPUSH
28884: CALL_OW 351
28888: PUSH
28889: LD_VAR 0 14
28893: PUSH
28894: LD_VAR 0 9
28898: ARRAY
28899: PUSH
28900: LD_INT 1
28902: ARRAY
28903: PPUSH
28904: LD_VAR 0 14
28908: PUSH
28909: LD_VAR 0 9
28913: ARRAY
28914: PUSH
28915: LD_INT 2
28917: ARRAY
28918: PPUSH
28919: CALL_OW 488
28923: NOT
28924: OR
28925: PUSH
28926: LD_VAR 0 13
28930: PPUSH
28931: CALL_OW 247
28935: PUSH
28936: LD_INT 3
28938: EQUAL
28939: OR
28940: IFFALSE 28946
// exit ;
28942: POP
28943: POP
28944: GO 29490
// if not tmp then
28946: LD_VAR 0 13
28950: NOT
28951: IFFALSE 28955
// continue ;
28953: GO 28811
// result := true ;
28955: LD_ADDR_VAR 0 8
28959: PUSH
28960: LD_INT 1
28962: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
28963: LD_VAR 0 6
28967: PUSH
28968: LD_VAR 0 13
28972: PPUSH
28973: CALL_OW 247
28977: PUSH
28978: LD_INT 2
28980: EQUAL
28981: AND
28982: PUSH
28983: LD_VAR 0 13
28987: PPUSH
28988: CALL_OW 263
28992: PUSH
28993: LD_INT 1
28995: EQUAL
28996: AND
28997: IFFALSE 29161
// begin if IsDrivenBy ( tmp ) then
28999: LD_VAR 0 13
29003: PPUSH
29004: CALL_OW 311
29008: IFFALSE 29012
// continue ;
29010: GO 28811
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
29012: LD_VAR 0 6
29016: PPUSH
29017: LD_INT 3
29019: PUSH
29020: LD_INT 60
29022: PUSH
29023: EMPTY
29024: LIST
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: PUSH
29030: LD_INT 3
29032: PUSH
29033: LD_INT 55
29035: PUSH
29036: EMPTY
29037: LIST
29038: PUSH
29039: EMPTY
29040: LIST
29041: LIST
29042: PUSH
29043: EMPTY
29044: LIST
29045: LIST
29046: PPUSH
29047: CALL_OW 72
29051: IFFALSE 29159
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
29053: LD_ADDR_VAR 0 18
29057: PUSH
29058: LD_VAR 0 6
29062: PPUSH
29063: LD_INT 3
29065: PUSH
29066: LD_INT 60
29068: PUSH
29069: EMPTY
29070: LIST
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 3
29078: PUSH
29079: LD_INT 55
29081: PUSH
29082: EMPTY
29083: LIST
29084: PUSH
29085: EMPTY
29086: LIST
29087: LIST
29088: PUSH
29089: EMPTY
29090: LIST
29091: LIST
29092: PPUSH
29093: CALL_OW 72
29097: PUSH
29098: LD_INT 1
29100: ARRAY
29101: ST_TO_ADDR
// if IsInUnit ( driver ) then
29102: LD_VAR 0 18
29106: PPUSH
29107: CALL_OW 310
29111: IFFALSE 29122
// ComExit ( driver ) ;
29113: LD_VAR 0 18
29117: PPUSH
29118: CALL 54524 0 1
// AddComEnterUnit ( driver , tmp ) ;
29122: LD_VAR 0 18
29126: PPUSH
29127: LD_VAR 0 13
29131: PPUSH
29132: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
29136: LD_VAR 0 18
29140: PPUSH
29141: LD_VAR 0 7
29145: PPUSH
29146: CALL_OW 173
// AddComExitVehicle ( driver ) ;
29150: LD_VAR 0 18
29154: PPUSH
29155: CALL_OW 181
// end ; continue ;
29159: GO 28811
// end ; if not cleaners or not tmp in cleaners then
29161: LD_VAR 0 6
29165: NOT
29166: PUSH
29167: LD_VAR 0 13
29171: PUSH
29172: LD_VAR 0 6
29176: IN
29177: NOT
29178: OR
29179: IFFALSE 29486
// begin if dep then
29181: LD_VAR 0 17
29185: IFFALSE 29321
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
29187: LD_ADDR_VAR 0 16
29191: PUSH
29192: LD_VAR 0 17
29196: PUSH
29197: LD_INT 1
29199: ARRAY
29200: PPUSH
29201: CALL_OW 250
29205: PPUSH
29206: LD_VAR 0 17
29210: PUSH
29211: LD_INT 1
29213: ARRAY
29214: PPUSH
29215: CALL_OW 254
29219: PPUSH
29220: LD_INT 5
29222: PPUSH
29223: CALL_OW 272
29227: PUSH
29228: LD_VAR 0 17
29232: PUSH
29233: LD_INT 1
29235: ARRAY
29236: PPUSH
29237: CALL_OW 251
29241: PPUSH
29242: LD_VAR 0 17
29246: PUSH
29247: LD_INT 1
29249: ARRAY
29250: PPUSH
29251: CALL_OW 254
29255: PPUSH
29256: LD_INT 5
29258: PPUSH
29259: CALL_OW 273
29263: PUSH
29264: EMPTY
29265: LIST
29266: LIST
29267: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
29268: LD_VAR 0 16
29272: PUSH
29273: LD_INT 1
29275: ARRAY
29276: PPUSH
29277: LD_VAR 0 16
29281: PUSH
29282: LD_INT 2
29284: ARRAY
29285: PPUSH
29286: CALL_OW 488
29290: IFFALSE 29321
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
29292: LD_VAR 0 13
29296: PPUSH
29297: LD_VAR 0 16
29301: PUSH
29302: LD_INT 1
29304: ARRAY
29305: PPUSH
29306: LD_VAR 0 16
29310: PUSH
29311: LD_INT 2
29313: ARRAY
29314: PPUSH
29315: CALL_OW 111
// continue ;
29319: GO 28811
// end ; end ; r := GetDir ( tmp ) ;
29321: LD_ADDR_VAR 0 15
29325: PUSH
29326: LD_VAR 0 13
29330: PPUSH
29331: CALL_OW 254
29335: ST_TO_ADDR
// if r = 5 then
29336: LD_VAR 0 15
29340: PUSH
29341: LD_INT 5
29343: EQUAL
29344: IFFALSE 29354
// r := 0 ;
29346: LD_ADDR_VAR 0 15
29350: PUSH
29351: LD_INT 0
29353: ST_TO_ADDR
// for j = r to 5 do
29354: LD_ADDR_VAR 0 10
29358: PUSH
29359: DOUBLE
29360: LD_VAR 0 15
29364: DEC
29365: ST_TO_ADDR
29366: LD_INT 5
29368: PUSH
29369: FOR_TO
29370: IFFALSE 29484
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
29372: LD_ADDR_VAR 0 11
29376: PUSH
29377: LD_VAR 0 13
29381: PPUSH
29382: CALL_OW 250
29386: PPUSH
29387: LD_VAR 0 10
29391: PPUSH
29392: LD_INT 2
29394: PPUSH
29395: CALL_OW 272
29399: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
29400: LD_ADDR_VAR 0 12
29404: PUSH
29405: LD_VAR 0 13
29409: PPUSH
29410: CALL_OW 251
29414: PPUSH
29415: LD_VAR 0 10
29419: PPUSH
29420: LD_INT 2
29422: PPUSH
29423: CALL_OW 273
29427: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
29428: LD_VAR 0 11
29432: PPUSH
29433: LD_VAR 0 12
29437: PPUSH
29438: CALL_OW 488
29442: PUSH
29443: LD_VAR 0 11
29447: PPUSH
29448: LD_VAR 0 12
29452: PPUSH
29453: CALL_OW 428
29457: NOT
29458: AND
29459: IFFALSE 29482
// begin ComMoveXY ( tmp , _x , _y ) ;
29461: LD_VAR 0 13
29465: PPUSH
29466: LD_VAR 0 11
29470: PPUSH
29471: LD_VAR 0 12
29475: PPUSH
29476: CALL_OW 111
// break ;
29480: GO 29484
// end ; end ;
29482: GO 29369
29484: POP
29485: POP
// end ; end ;
29486: GO 28811
29488: POP
29489: POP
// end ;
29490: LD_VAR 0 8
29494: RET
// export function BuildingTechInvented ( side , btype ) ; begin
29495: LD_INT 0
29497: PPUSH
// result := true ;
29498: LD_ADDR_VAR 0 3
29502: PUSH
29503: LD_INT 1
29505: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
29506: LD_VAR 0 2
29510: PUSH
29511: LD_INT 24
29513: DOUBLE
29514: EQUAL
29515: IFTRUE 29525
29517: LD_INT 33
29519: DOUBLE
29520: EQUAL
29521: IFTRUE 29525
29523: GO 29550
29525: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
29526: LD_ADDR_VAR 0 3
29530: PUSH
29531: LD_INT 32
29533: PPUSH
29534: LD_VAR 0 1
29538: PPUSH
29539: CALL_OW 321
29543: PUSH
29544: LD_INT 2
29546: EQUAL
29547: ST_TO_ADDR
29548: GO 29866
29550: LD_INT 20
29552: DOUBLE
29553: EQUAL
29554: IFTRUE 29558
29556: GO 29583
29558: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
29559: LD_ADDR_VAR 0 3
29563: PUSH
29564: LD_INT 6
29566: PPUSH
29567: LD_VAR 0 1
29571: PPUSH
29572: CALL_OW 321
29576: PUSH
29577: LD_INT 2
29579: EQUAL
29580: ST_TO_ADDR
29581: GO 29866
29583: LD_INT 22
29585: DOUBLE
29586: EQUAL
29587: IFTRUE 29597
29589: LD_INT 36
29591: DOUBLE
29592: EQUAL
29593: IFTRUE 29597
29595: GO 29622
29597: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
29598: LD_ADDR_VAR 0 3
29602: PUSH
29603: LD_INT 15
29605: PPUSH
29606: LD_VAR 0 1
29610: PPUSH
29611: CALL_OW 321
29615: PUSH
29616: LD_INT 2
29618: EQUAL
29619: ST_TO_ADDR
29620: GO 29866
29622: LD_INT 30
29624: DOUBLE
29625: EQUAL
29626: IFTRUE 29630
29628: GO 29655
29630: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
29631: LD_ADDR_VAR 0 3
29635: PUSH
29636: LD_INT 20
29638: PPUSH
29639: LD_VAR 0 1
29643: PPUSH
29644: CALL_OW 321
29648: PUSH
29649: LD_INT 2
29651: EQUAL
29652: ST_TO_ADDR
29653: GO 29866
29655: LD_INT 28
29657: DOUBLE
29658: EQUAL
29659: IFTRUE 29669
29661: LD_INT 21
29663: DOUBLE
29664: EQUAL
29665: IFTRUE 29669
29667: GO 29694
29669: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
29670: LD_ADDR_VAR 0 3
29674: PUSH
29675: LD_INT 21
29677: PPUSH
29678: LD_VAR 0 1
29682: PPUSH
29683: CALL_OW 321
29687: PUSH
29688: LD_INT 2
29690: EQUAL
29691: ST_TO_ADDR
29692: GO 29866
29694: LD_INT 16
29696: DOUBLE
29697: EQUAL
29698: IFTRUE 29702
29700: GO 29727
29702: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
29703: LD_ADDR_VAR 0 3
29707: PUSH
29708: LD_INT 84
29710: PPUSH
29711: LD_VAR 0 1
29715: PPUSH
29716: CALL_OW 321
29720: PUSH
29721: LD_INT 2
29723: EQUAL
29724: ST_TO_ADDR
29725: GO 29866
29727: LD_INT 19
29729: DOUBLE
29730: EQUAL
29731: IFTRUE 29741
29733: LD_INT 23
29735: DOUBLE
29736: EQUAL
29737: IFTRUE 29741
29739: GO 29766
29741: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
29742: LD_ADDR_VAR 0 3
29746: PUSH
29747: LD_INT 83
29749: PPUSH
29750: LD_VAR 0 1
29754: PPUSH
29755: CALL_OW 321
29759: PUSH
29760: LD_INT 2
29762: EQUAL
29763: ST_TO_ADDR
29764: GO 29866
29766: LD_INT 17
29768: DOUBLE
29769: EQUAL
29770: IFTRUE 29774
29772: GO 29799
29774: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
29775: LD_ADDR_VAR 0 3
29779: PUSH
29780: LD_INT 39
29782: PPUSH
29783: LD_VAR 0 1
29787: PPUSH
29788: CALL_OW 321
29792: PUSH
29793: LD_INT 2
29795: EQUAL
29796: ST_TO_ADDR
29797: GO 29866
29799: LD_INT 18
29801: DOUBLE
29802: EQUAL
29803: IFTRUE 29807
29805: GO 29832
29807: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
29808: LD_ADDR_VAR 0 3
29812: PUSH
29813: LD_INT 40
29815: PPUSH
29816: LD_VAR 0 1
29820: PPUSH
29821: CALL_OW 321
29825: PUSH
29826: LD_INT 2
29828: EQUAL
29829: ST_TO_ADDR
29830: GO 29866
29832: LD_INT 27
29834: DOUBLE
29835: EQUAL
29836: IFTRUE 29840
29838: GO 29865
29840: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
29841: LD_ADDR_VAR 0 3
29845: PUSH
29846: LD_INT 35
29848: PPUSH
29849: LD_VAR 0 1
29853: PPUSH
29854: CALL_OW 321
29858: PUSH
29859: LD_INT 2
29861: EQUAL
29862: ST_TO_ADDR
29863: GO 29866
29865: POP
// end ;
29866: LD_VAR 0 3
29870: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
29871: LD_INT 0
29873: PPUSH
29874: PPUSH
29875: PPUSH
29876: PPUSH
29877: PPUSH
29878: PPUSH
29879: PPUSH
29880: PPUSH
29881: PPUSH
29882: PPUSH
29883: PPUSH
// result := false ;
29884: LD_ADDR_VAR 0 6
29888: PUSH
29889: LD_INT 0
29891: ST_TO_ADDR
// if btype = b_depot then
29892: LD_VAR 0 2
29896: PUSH
29897: LD_INT 0
29899: EQUAL
29900: IFFALSE 29912
// begin result := true ;
29902: LD_ADDR_VAR 0 6
29906: PUSH
29907: LD_INT 1
29909: ST_TO_ADDR
// exit ;
29910: GO 30738
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
29912: LD_VAR 0 1
29916: NOT
29917: PUSH
29918: LD_VAR 0 1
29922: PPUSH
29923: CALL_OW 266
29927: PUSH
29928: LD_INT 0
29930: PUSH
29931: LD_INT 1
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: IN
29938: NOT
29939: OR
29940: PUSH
29941: LD_VAR 0 2
29945: NOT
29946: OR
29947: PUSH
29948: LD_VAR 0 5
29952: PUSH
29953: LD_INT 0
29955: PUSH
29956: LD_INT 1
29958: PUSH
29959: LD_INT 2
29961: PUSH
29962: LD_INT 3
29964: PUSH
29965: LD_INT 4
29967: PUSH
29968: LD_INT 5
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: LIST
29975: LIST
29976: LIST
29977: LIST
29978: IN
29979: NOT
29980: OR
29981: PUSH
29982: LD_VAR 0 3
29986: PPUSH
29987: LD_VAR 0 4
29991: PPUSH
29992: CALL_OW 488
29996: NOT
29997: OR
29998: IFFALSE 30002
// exit ;
30000: GO 30738
// side := GetSide ( depot ) ;
30002: LD_ADDR_VAR 0 9
30006: PUSH
30007: LD_VAR 0 1
30011: PPUSH
30012: CALL_OW 255
30016: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
30017: LD_VAR 0 9
30021: PPUSH
30022: LD_VAR 0 2
30026: PPUSH
30027: CALL 29495 0 2
30031: NOT
30032: IFFALSE 30036
// exit ;
30034: GO 30738
// pom := GetBase ( depot ) ;
30036: LD_ADDR_VAR 0 10
30040: PUSH
30041: LD_VAR 0 1
30045: PPUSH
30046: CALL_OW 274
30050: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
30051: LD_ADDR_VAR 0 11
30055: PUSH
30056: LD_VAR 0 2
30060: PPUSH
30061: LD_VAR 0 1
30065: PPUSH
30066: CALL_OW 248
30070: PPUSH
30071: CALL_OW 450
30075: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
30076: LD_VAR 0 10
30080: PPUSH
30081: LD_INT 1
30083: PPUSH
30084: CALL_OW 275
30088: PUSH
30089: LD_VAR 0 11
30093: PUSH
30094: LD_INT 1
30096: ARRAY
30097: GREATEREQUAL
30098: PUSH
30099: LD_VAR 0 10
30103: PPUSH
30104: LD_INT 2
30106: PPUSH
30107: CALL_OW 275
30111: PUSH
30112: LD_VAR 0 11
30116: PUSH
30117: LD_INT 2
30119: ARRAY
30120: GREATEREQUAL
30121: AND
30122: PUSH
30123: LD_VAR 0 10
30127: PPUSH
30128: LD_INT 3
30130: PPUSH
30131: CALL_OW 275
30135: PUSH
30136: LD_VAR 0 11
30140: PUSH
30141: LD_INT 3
30143: ARRAY
30144: GREATEREQUAL
30145: AND
30146: NOT
30147: IFFALSE 30151
// exit ;
30149: GO 30738
// if GetBType ( depot ) = b_depot then
30151: LD_VAR 0 1
30155: PPUSH
30156: CALL_OW 266
30160: PUSH
30161: LD_INT 0
30163: EQUAL
30164: IFFALSE 30176
// dist := 28 else
30166: LD_ADDR_VAR 0 14
30170: PUSH
30171: LD_INT 28
30173: ST_TO_ADDR
30174: GO 30184
// dist := 36 ;
30176: LD_ADDR_VAR 0 14
30180: PUSH
30181: LD_INT 36
30183: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
30184: LD_VAR 0 1
30188: PPUSH
30189: LD_VAR 0 3
30193: PPUSH
30194: LD_VAR 0 4
30198: PPUSH
30199: CALL_OW 297
30203: PUSH
30204: LD_VAR 0 14
30208: GREATER
30209: IFFALSE 30213
// exit ;
30211: GO 30738
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
30213: LD_ADDR_VAR 0 12
30217: PUSH
30218: LD_VAR 0 2
30222: PPUSH
30223: LD_VAR 0 3
30227: PPUSH
30228: LD_VAR 0 4
30232: PPUSH
30233: LD_VAR 0 5
30237: PPUSH
30238: LD_VAR 0 1
30242: PPUSH
30243: CALL_OW 248
30247: PPUSH
30248: LD_INT 0
30250: PPUSH
30251: CALL 30743 0 6
30255: ST_TO_ADDR
// if not hexes then
30256: LD_VAR 0 12
30260: NOT
30261: IFFALSE 30265
// exit ;
30263: GO 30738
// hex := GetHexInfo ( x , y ) ;
30265: LD_ADDR_VAR 0 15
30269: PUSH
30270: LD_VAR 0 3
30274: PPUSH
30275: LD_VAR 0 4
30279: PPUSH
30280: CALL_OW 546
30284: ST_TO_ADDR
// if hex [ 1 ] then
30285: LD_VAR 0 15
30289: PUSH
30290: LD_INT 1
30292: ARRAY
30293: IFFALSE 30297
// exit ;
30295: GO 30738
// height := hex [ 2 ] ;
30297: LD_ADDR_VAR 0 13
30301: PUSH
30302: LD_VAR 0 15
30306: PUSH
30307: LD_INT 2
30309: ARRAY
30310: ST_TO_ADDR
// for i = 1 to hexes do
30311: LD_ADDR_VAR 0 7
30315: PUSH
30316: DOUBLE
30317: LD_INT 1
30319: DEC
30320: ST_TO_ADDR
30321: LD_VAR 0 12
30325: PUSH
30326: FOR_TO
30327: IFFALSE 30657
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
30329: LD_VAR 0 12
30333: PUSH
30334: LD_VAR 0 7
30338: ARRAY
30339: PUSH
30340: LD_INT 1
30342: ARRAY
30343: PPUSH
30344: LD_VAR 0 12
30348: PUSH
30349: LD_VAR 0 7
30353: ARRAY
30354: PUSH
30355: LD_INT 2
30357: ARRAY
30358: PPUSH
30359: CALL_OW 488
30363: NOT
30364: PUSH
30365: LD_VAR 0 12
30369: PUSH
30370: LD_VAR 0 7
30374: ARRAY
30375: PUSH
30376: LD_INT 1
30378: ARRAY
30379: PPUSH
30380: LD_VAR 0 12
30384: PUSH
30385: LD_VAR 0 7
30389: ARRAY
30390: PUSH
30391: LD_INT 2
30393: ARRAY
30394: PPUSH
30395: CALL_OW 428
30399: PUSH
30400: LD_INT 0
30402: GREATER
30403: OR
30404: PUSH
30405: LD_VAR 0 12
30409: PUSH
30410: LD_VAR 0 7
30414: ARRAY
30415: PUSH
30416: LD_INT 1
30418: ARRAY
30419: PPUSH
30420: LD_VAR 0 12
30424: PUSH
30425: LD_VAR 0 7
30429: ARRAY
30430: PUSH
30431: LD_INT 2
30433: ARRAY
30434: PPUSH
30435: CALL_OW 351
30439: OR
30440: IFFALSE 30446
// exit ;
30442: POP
30443: POP
30444: GO 30738
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
30446: LD_ADDR_VAR 0 8
30450: PUSH
30451: LD_VAR 0 12
30455: PUSH
30456: LD_VAR 0 7
30460: ARRAY
30461: PUSH
30462: LD_INT 1
30464: ARRAY
30465: PPUSH
30466: LD_VAR 0 12
30470: PUSH
30471: LD_VAR 0 7
30475: ARRAY
30476: PUSH
30477: LD_INT 2
30479: ARRAY
30480: PPUSH
30481: CALL_OW 546
30485: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
30486: LD_VAR 0 8
30490: PUSH
30491: LD_INT 1
30493: ARRAY
30494: PUSH
30495: LD_VAR 0 8
30499: PUSH
30500: LD_INT 2
30502: ARRAY
30503: PUSH
30504: LD_VAR 0 13
30508: PUSH
30509: LD_INT 2
30511: PLUS
30512: GREATER
30513: OR
30514: PUSH
30515: LD_VAR 0 8
30519: PUSH
30520: LD_INT 2
30522: ARRAY
30523: PUSH
30524: LD_VAR 0 13
30528: PUSH
30529: LD_INT 2
30531: MINUS
30532: LESS
30533: OR
30534: PUSH
30535: LD_VAR 0 8
30539: PUSH
30540: LD_INT 3
30542: ARRAY
30543: PUSH
30544: LD_INT 0
30546: PUSH
30547: LD_INT 8
30549: PUSH
30550: LD_INT 9
30552: PUSH
30553: LD_INT 10
30555: PUSH
30556: LD_INT 11
30558: PUSH
30559: LD_INT 12
30561: PUSH
30562: LD_INT 13
30564: PUSH
30565: LD_INT 16
30567: PUSH
30568: LD_INT 17
30570: PUSH
30571: LD_INT 18
30573: PUSH
30574: LD_INT 19
30576: PUSH
30577: LD_INT 20
30579: PUSH
30580: LD_INT 21
30582: PUSH
30583: EMPTY
30584: LIST
30585: LIST
30586: LIST
30587: LIST
30588: LIST
30589: LIST
30590: LIST
30591: LIST
30592: LIST
30593: LIST
30594: LIST
30595: LIST
30596: LIST
30597: IN
30598: NOT
30599: OR
30600: PUSH
30601: LD_VAR 0 8
30605: PUSH
30606: LD_INT 5
30608: ARRAY
30609: NOT
30610: OR
30611: PUSH
30612: LD_VAR 0 8
30616: PUSH
30617: LD_INT 6
30619: ARRAY
30620: PUSH
30621: LD_INT 1
30623: PUSH
30624: LD_INT 2
30626: PUSH
30627: LD_INT 7
30629: PUSH
30630: LD_INT 9
30632: PUSH
30633: LD_INT 10
30635: PUSH
30636: LD_INT 11
30638: PUSH
30639: EMPTY
30640: LIST
30641: LIST
30642: LIST
30643: LIST
30644: LIST
30645: LIST
30646: IN
30647: NOT
30648: OR
30649: IFFALSE 30655
// exit ;
30651: POP
30652: POP
30653: GO 30738
// end ;
30655: GO 30326
30657: POP
30658: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
30659: LD_VAR 0 9
30663: PPUSH
30664: LD_VAR 0 3
30668: PPUSH
30669: LD_VAR 0 4
30673: PPUSH
30674: LD_INT 20
30676: PPUSH
30677: CALL 22661 0 4
30681: PUSH
30682: LD_INT 4
30684: ARRAY
30685: IFFALSE 30689
// exit ;
30687: GO 30738
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
30689: LD_VAR 0 2
30693: PUSH
30694: LD_INT 29
30696: PUSH
30697: LD_INT 30
30699: PUSH
30700: EMPTY
30701: LIST
30702: LIST
30703: IN
30704: PUSH
30705: LD_VAR 0 3
30709: PPUSH
30710: LD_VAR 0 4
30714: PPUSH
30715: LD_VAR 0 9
30719: PPUSH
30720: CALL_OW 440
30724: NOT
30725: AND
30726: IFFALSE 30730
// exit ;
30728: GO 30738
// result := true ;
30730: LD_ADDR_VAR 0 6
30734: PUSH
30735: LD_INT 1
30737: ST_TO_ADDR
// end ;
30738: LD_VAR 0 6
30742: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
30743: LD_INT 0
30745: PPUSH
30746: PPUSH
30747: PPUSH
30748: PPUSH
30749: PPUSH
30750: PPUSH
30751: PPUSH
30752: PPUSH
30753: PPUSH
30754: PPUSH
30755: PPUSH
30756: PPUSH
30757: PPUSH
30758: PPUSH
30759: PPUSH
30760: PPUSH
30761: PPUSH
30762: PPUSH
30763: PPUSH
30764: PPUSH
30765: PPUSH
30766: PPUSH
30767: PPUSH
30768: PPUSH
30769: PPUSH
30770: PPUSH
30771: PPUSH
30772: PPUSH
30773: PPUSH
30774: PPUSH
30775: PPUSH
30776: PPUSH
30777: PPUSH
30778: PPUSH
30779: PPUSH
30780: PPUSH
30781: PPUSH
30782: PPUSH
30783: PPUSH
30784: PPUSH
30785: PPUSH
30786: PPUSH
30787: PPUSH
30788: PPUSH
30789: PPUSH
30790: PPUSH
30791: PPUSH
30792: PPUSH
30793: PPUSH
30794: PPUSH
30795: PPUSH
30796: PPUSH
30797: PPUSH
30798: PPUSH
30799: PPUSH
30800: PPUSH
30801: PPUSH
30802: PPUSH
// result = [ ] ;
30803: LD_ADDR_VAR 0 7
30807: PUSH
30808: EMPTY
30809: ST_TO_ADDR
// temp_list = [ ] ;
30810: LD_ADDR_VAR 0 9
30814: PUSH
30815: EMPTY
30816: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
30817: LD_VAR 0 4
30821: PUSH
30822: LD_INT 0
30824: PUSH
30825: LD_INT 1
30827: PUSH
30828: LD_INT 2
30830: PUSH
30831: LD_INT 3
30833: PUSH
30834: LD_INT 4
30836: PUSH
30837: LD_INT 5
30839: PUSH
30840: EMPTY
30841: LIST
30842: LIST
30843: LIST
30844: LIST
30845: LIST
30846: LIST
30847: IN
30848: NOT
30849: PUSH
30850: LD_VAR 0 1
30854: PUSH
30855: LD_INT 0
30857: PUSH
30858: LD_INT 1
30860: PUSH
30861: EMPTY
30862: LIST
30863: LIST
30864: IN
30865: PUSH
30866: LD_VAR 0 5
30870: PUSH
30871: LD_INT 1
30873: PUSH
30874: LD_INT 2
30876: PUSH
30877: LD_INT 3
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: LIST
30884: IN
30885: NOT
30886: AND
30887: OR
30888: IFFALSE 30892
// exit ;
30890: GO 49283
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
30892: LD_VAR 0 1
30896: PUSH
30897: LD_INT 6
30899: PUSH
30900: LD_INT 7
30902: PUSH
30903: LD_INT 8
30905: PUSH
30906: LD_INT 13
30908: PUSH
30909: LD_INT 12
30911: PUSH
30912: LD_INT 15
30914: PUSH
30915: LD_INT 11
30917: PUSH
30918: LD_INT 14
30920: PUSH
30921: LD_INT 10
30923: PUSH
30924: EMPTY
30925: LIST
30926: LIST
30927: LIST
30928: LIST
30929: LIST
30930: LIST
30931: LIST
30932: LIST
30933: LIST
30934: IN
30935: IFFALSE 30945
// btype = b_lab ;
30937: LD_ADDR_VAR 0 1
30941: PUSH
30942: LD_INT 6
30944: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
30945: LD_VAR 0 6
30949: PUSH
30950: LD_INT 0
30952: PUSH
30953: LD_INT 1
30955: PUSH
30956: LD_INT 2
30958: PUSH
30959: EMPTY
30960: LIST
30961: LIST
30962: LIST
30963: IN
30964: NOT
30965: PUSH
30966: LD_VAR 0 1
30970: PUSH
30971: LD_INT 0
30973: PUSH
30974: LD_INT 1
30976: PUSH
30977: LD_INT 2
30979: PUSH
30980: LD_INT 3
30982: PUSH
30983: LD_INT 6
30985: PUSH
30986: LD_INT 36
30988: PUSH
30989: LD_INT 4
30991: PUSH
30992: LD_INT 5
30994: PUSH
30995: LD_INT 31
30997: PUSH
30998: LD_INT 32
31000: PUSH
31001: LD_INT 33
31003: PUSH
31004: EMPTY
31005: LIST
31006: LIST
31007: LIST
31008: LIST
31009: LIST
31010: LIST
31011: LIST
31012: LIST
31013: LIST
31014: LIST
31015: LIST
31016: IN
31017: NOT
31018: PUSH
31019: LD_VAR 0 6
31023: PUSH
31024: LD_INT 1
31026: EQUAL
31027: AND
31028: OR
31029: PUSH
31030: LD_VAR 0 1
31034: PUSH
31035: LD_INT 2
31037: PUSH
31038: LD_INT 3
31040: PUSH
31041: EMPTY
31042: LIST
31043: LIST
31044: IN
31045: NOT
31046: PUSH
31047: LD_VAR 0 6
31051: PUSH
31052: LD_INT 2
31054: EQUAL
31055: AND
31056: OR
31057: IFFALSE 31067
// mode = 0 ;
31059: LD_ADDR_VAR 0 6
31063: PUSH
31064: LD_INT 0
31066: ST_TO_ADDR
// case mode of 0 :
31067: LD_VAR 0 6
31071: PUSH
31072: LD_INT 0
31074: DOUBLE
31075: EQUAL
31076: IFTRUE 31080
31078: GO 42533
31080: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
31081: LD_ADDR_VAR 0 11
31085: PUSH
31086: LD_INT 0
31088: PUSH
31089: LD_INT 0
31091: PUSH
31092: EMPTY
31093: LIST
31094: LIST
31095: PUSH
31096: LD_INT 0
31098: PUSH
31099: LD_INT 1
31101: NEG
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PUSH
31107: LD_INT 1
31109: PUSH
31110: LD_INT 0
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 1
31119: PUSH
31120: LD_INT 1
31122: PUSH
31123: EMPTY
31124: LIST
31125: LIST
31126: PUSH
31127: LD_INT 0
31129: PUSH
31130: LD_INT 1
31132: PUSH
31133: EMPTY
31134: LIST
31135: LIST
31136: PUSH
31137: LD_INT 1
31139: NEG
31140: PUSH
31141: LD_INT 0
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 1
31150: NEG
31151: PUSH
31152: LD_INT 1
31154: NEG
31155: PUSH
31156: EMPTY
31157: LIST
31158: LIST
31159: PUSH
31160: LD_INT 1
31162: NEG
31163: PUSH
31164: LD_INT 2
31166: NEG
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 0
31174: PUSH
31175: LD_INT 2
31177: NEG
31178: PUSH
31179: EMPTY
31180: LIST
31181: LIST
31182: PUSH
31183: LD_INT 1
31185: PUSH
31186: LD_INT 1
31188: NEG
31189: PUSH
31190: EMPTY
31191: LIST
31192: LIST
31193: PUSH
31194: LD_INT 1
31196: PUSH
31197: LD_INT 2
31199: PUSH
31200: EMPTY
31201: LIST
31202: LIST
31203: PUSH
31204: LD_INT 0
31206: PUSH
31207: LD_INT 2
31209: PUSH
31210: EMPTY
31211: LIST
31212: LIST
31213: PUSH
31214: LD_INT 1
31216: NEG
31217: PUSH
31218: LD_INT 1
31220: PUSH
31221: EMPTY
31222: LIST
31223: LIST
31224: PUSH
31225: LD_INT 1
31227: PUSH
31228: LD_INT 3
31230: PUSH
31231: EMPTY
31232: LIST
31233: LIST
31234: PUSH
31235: LD_INT 0
31237: PUSH
31238: LD_INT 3
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: PUSH
31245: LD_INT 1
31247: NEG
31248: PUSH
31249: LD_INT 2
31251: PUSH
31252: EMPTY
31253: LIST
31254: LIST
31255: PUSH
31256: EMPTY
31257: LIST
31258: LIST
31259: LIST
31260: LIST
31261: LIST
31262: LIST
31263: LIST
31264: LIST
31265: LIST
31266: LIST
31267: LIST
31268: LIST
31269: LIST
31270: LIST
31271: LIST
31272: LIST
31273: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31274: LD_ADDR_VAR 0 12
31278: PUSH
31279: LD_INT 0
31281: PUSH
31282: LD_INT 0
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: PUSH
31289: LD_INT 0
31291: PUSH
31292: LD_INT 1
31294: NEG
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: PUSH
31300: LD_INT 1
31302: PUSH
31303: LD_INT 0
31305: PUSH
31306: EMPTY
31307: LIST
31308: LIST
31309: PUSH
31310: LD_INT 1
31312: PUSH
31313: LD_INT 1
31315: PUSH
31316: EMPTY
31317: LIST
31318: LIST
31319: PUSH
31320: LD_INT 0
31322: PUSH
31323: LD_INT 1
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: LD_INT 1
31332: NEG
31333: PUSH
31334: LD_INT 0
31336: PUSH
31337: EMPTY
31338: LIST
31339: LIST
31340: PUSH
31341: LD_INT 1
31343: NEG
31344: PUSH
31345: LD_INT 1
31347: NEG
31348: PUSH
31349: EMPTY
31350: LIST
31351: LIST
31352: PUSH
31353: LD_INT 1
31355: PUSH
31356: LD_INT 1
31358: NEG
31359: PUSH
31360: EMPTY
31361: LIST
31362: LIST
31363: PUSH
31364: LD_INT 2
31366: PUSH
31367: LD_INT 0
31369: PUSH
31370: EMPTY
31371: LIST
31372: LIST
31373: PUSH
31374: LD_INT 2
31376: PUSH
31377: LD_INT 1
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: PUSH
31384: LD_INT 1
31386: NEG
31387: PUSH
31388: LD_INT 1
31390: PUSH
31391: EMPTY
31392: LIST
31393: LIST
31394: PUSH
31395: LD_INT 2
31397: NEG
31398: PUSH
31399: LD_INT 0
31401: PUSH
31402: EMPTY
31403: LIST
31404: LIST
31405: PUSH
31406: LD_INT 2
31408: NEG
31409: PUSH
31410: LD_INT 1
31412: NEG
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 2
31420: NEG
31421: PUSH
31422: LD_INT 1
31424: PUSH
31425: EMPTY
31426: LIST
31427: LIST
31428: PUSH
31429: LD_INT 3
31431: NEG
31432: PUSH
31433: LD_INT 0
31435: PUSH
31436: EMPTY
31437: LIST
31438: LIST
31439: PUSH
31440: LD_INT 3
31442: NEG
31443: PUSH
31444: LD_INT 1
31446: NEG
31447: PUSH
31448: EMPTY
31449: LIST
31450: LIST
31451: PUSH
31452: EMPTY
31453: LIST
31454: LIST
31455: LIST
31456: LIST
31457: LIST
31458: LIST
31459: LIST
31460: LIST
31461: LIST
31462: LIST
31463: LIST
31464: LIST
31465: LIST
31466: LIST
31467: LIST
31468: LIST
31469: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31470: LD_ADDR_VAR 0 13
31474: PUSH
31475: LD_INT 0
31477: PUSH
31478: LD_INT 0
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: PUSH
31485: LD_INT 0
31487: PUSH
31488: LD_INT 1
31490: NEG
31491: PUSH
31492: EMPTY
31493: LIST
31494: LIST
31495: PUSH
31496: LD_INT 1
31498: PUSH
31499: LD_INT 0
31501: PUSH
31502: EMPTY
31503: LIST
31504: LIST
31505: PUSH
31506: LD_INT 1
31508: PUSH
31509: LD_INT 1
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: PUSH
31516: LD_INT 0
31518: PUSH
31519: LD_INT 1
31521: PUSH
31522: EMPTY
31523: LIST
31524: LIST
31525: PUSH
31526: LD_INT 1
31528: NEG
31529: PUSH
31530: LD_INT 0
31532: PUSH
31533: EMPTY
31534: LIST
31535: LIST
31536: PUSH
31537: LD_INT 1
31539: NEG
31540: PUSH
31541: LD_INT 1
31543: NEG
31544: PUSH
31545: EMPTY
31546: LIST
31547: LIST
31548: PUSH
31549: LD_INT 1
31551: NEG
31552: PUSH
31553: LD_INT 2
31555: NEG
31556: PUSH
31557: EMPTY
31558: LIST
31559: LIST
31560: PUSH
31561: LD_INT 2
31563: PUSH
31564: LD_INT 1
31566: PUSH
31567: EMPTY
31568: LIST
31569: LIST
31570: PUSH
31571: LD_INT 2
31573: PUSH
31574: LD_INT 2
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PUSH
31581: LD_INT 1
31583: PUSH
31584: LD_INT 2
31586: PUSH
31587: EMPTY
31588: LIST
31589: LIST
31590: PUSH
31591: LD_INT 2
31593: NEG
31594: PUSH
31595: LD_INT 1
31597: NEG
31598: PUSH
31599: EMPTY
31600: LIST
31601: LIST
31602: PUSH
31603: LD_INT 2
31605: NEG
31606: PUSH
31607: LD_INT 2
31609: NEG
31610: PUSH
31611: EMPTY
31612: LIST
31613: LIST
31614: PUSH
31615: LD_INT 2
31617: NEG
31618: PUSH
31619: LD_INT 3
31621: NEG
31622: PUSH
31623: EMPTY
31624: LIST
31625: LIST
31626: PUSH
31627: LD_INT 3
31629: NEG
31630: PUSH
31631: LD_INT 2
31633: NEG
31634: PUSH
31635: EMPTY
31636: LIST
31637: LIST
31638: PUSH
31639: LD_INT 3
31641: NEG
31642: PUSH
31643: LD_INT 3
31645: NEG
31646: PUSH
31647: EMPTY
31648: LIST
31649: LIST
31650: PUSH
31651: EMPTY
31652: LIST
31653: LIST
31654: LIST
31655: LIST
31656: LIST
31657: LIST
31658: LIST
31659: LIST
31660: LIST
31661: LIST
31662: LIST
31663: LIST
31664: LIST
31665: LIST
31666: LIST
31667: LIST
31668: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
31669: LD_ADDR_VAR 0 14
31673: PUSH
31674: LD_INT 0
31676: PUSH
31677: LD_INT 0
31679: PUSH
31680: EMPTY
31681: LIST
31682: LIST
31683: PUSH
31684: LD_INT 0
31686: PUSH
31687: LD_INT 1
31689: NEG
31690: PUSH
31691: EMPTY
31692: LIST
31693: LIST
31694: PUSH
31695: LD_INT 1
31697: PUSH
31698: LD_INT 0
31700: PUSH
31701: EMPTY
31702: LIST
31703: LIST
31704: PUSH
31705: LD_INT 1
31707: PUSH
31708: LD_INT 1
31710: PUSH
31711: EMPTY
31712: LIST
31713: LIST
31714: PUSH
31715: LD_INT 0
31717: PUSH
31718: LD_INT 1
31720: PUSH
31721: EMPTY
31722: LIST
31723: LIST
31724: PUSH
31725: LD_INT 1
31727: NEG
31728: PUSH
31729: LD_INT 0
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: PUSH
31736: LD_INT 1
31738: NEG
31739: PUSH
31740: LD_INT 1
31742: NEG
31743: PUSH
31744: EMPTY
31745: LIST
31746: LIST
31747: PUSH
31748: LD_INT 1
31750: NEG
31751: PUSH
31752: LD_INT 2
31754: NEG
31755: PUSH
31756: EMPTY
31757: LIST
31758: LIST
31759: PUSH
31760: LD_INT 0
31762: PUSH
31763: LD_INT 2
31765: NEG
31766: PUSH
31767: EMPTY
31768: LIST
31769: LIST
31770: PUSH
31771: LD_INT 1
31773: PUSH
31774: LD_INT 1
31776: NEG
31777: PUSH
31778: EMPTY
31779: LIST
31780: LIST
31781: PUSH
31782: LD_INT 1
31784: PUSH
31785: LD_INT 2
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: PUSH
31792: LD_INT 0
31794: PUSH
31795: LD_INT 2
31797: PUSH
31798: EMPTY
31799: LIST
31800: LIST
31801: PUSH
31802: LD_INT 1
31804: NEG
31805: PUSH
31806: LD_INT 1
31808: PUSH
31809: EMPTY
31810: LIST
31811: LIST
31812: PUSH
31813: LD_INT 1
31815: NEG
31816: PUSH
31817: LD_INT 3
31819: NEG
31820: PUSH
31821: EMPTY
31822: LIST
31823: LIST
31824: PUSH
31825: LD_INT 0
31827: PUSH
31828: LD_INT 3
31830: NEG
31831: PUSH
31832: EMPTY
31833: LIST
31834: LIST
31835: PUSH
31836: LD_INT 1
31838: PUSH
31839: LD_INT 2
31841: NEG
31842: PUSH
31843: EMPTY
31844: LIST
31845: LIST
31846: PUSH
31847: EMPTY
31848: LIST
31849: LIST
31850: LIST
31851: LIST
31852: LIST
31853: LIST
31854: LIST
31855: LIST
31856: LIST
31857: LIST
31858: LIST
31859: LIST
31860: LIST
31861: LIST
31862: LIST
31863: LIST
31864: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
31865: LD_ADDR_VAR 0 15
31869: PUSH
31870: LD_INT 0
31872: PUSH
31873: LD_INT 0
31875: PUSH
31876: EMPTY
31877: LIST
31878: LIST
31879: PUSH
31880: LD_INT 0
31882: PUSH
31883: LD_INT 1
31885: NEG
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 1
31893: PUSH
31894: LD_INT 0
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 1
31903: PUSH
31904: LD_INT 1
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: LD_INT 0
31913: PUSH
31914: LD_INT 1
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: PUSH
31921: LD_INT 1
31923: NEG
31924: PUSH
31925: LD_INT 0
31927: PUSH
31928: EMPTY
31929: LIST
31930: LIST
31931: PUSH
31932: LD_INT 1
31934: NEG
31935: PUSH
31936: LD_INT 1
31938: NEG
31939: PUSH
31940: EMPTY
31941: LIST
31942: LIST
31943: PUSH
31944: LD_INT 1
31946: PUSH
31947: LD_INT 1
31949: NEG
31950: PUSH
31951: EMPTY
31952: LIST
31953: LIST
31954: PUSH
31955: LD_INT 2
31957: PUSH
31958: LD_INT 0
31960: PUSH
31961: EMPTY
31962: LIST
31963: LIST
31964: PUSH
31965: LD_INT 2
31967: PUSH
31968: LD_INT 1
31970: PUSH
31971: EMPTY
31972: LIST
31973: LIST
31974: PUSH
31975: LD_INT 1
31977: NEG
31978: PUSH
31979: LD_INT 1
31981: PUSH
31982: EMPTY
31983: LIST
31984: LIST
31985: PUSH
31986: LD_INT 2
31988: NEG
31989: PUSH
31990: LD_INT 0
31992: PUSH
31993: EMPTY
31994: LIST
31995: LIST
31996: PUSH
31997: LD_INT 2
31999: NEG
32000: PUSH
32001: LD_INT 1
32003: NEG
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 2
32011: PUSH
32012: LD_INT 1
32014: NEG
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: LD_INT 3
32022: PUSH
32023: LD_INT 0
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 3
32032: PUSH
32033: LD_INT 1
32035: PUSH
32036: EMPTY
32037: LIST
32038: LIST
32039: PUSH
32040: EMPTY
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: LIST
32056: LIST
32057: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
32058: LD_ADDR_VAR 0 16
32062: PUSH
32063: LD_INT 0
32065: PUSH
32066: LD_INT 0
32068: PUSH
32069: EMPTY
32070: LIST
32071: LIST
32072: PUSH
32073: LD_INT 0
32075: PUSH
32076: LD_INT 1
32078: NEG
32079: PUSH
32080: EMPTY
32081: LIST
32082: LIST
32083: PUSH
32084: LD_INT 1
32086: PUSH
32087: LD_INT 0
32089: PUSH
32090: EMPTY
32091: LIST
32092: LIST
32093: PUSH
32094: LD_INT 1
32096: PUSH
32097: LD_INT 1
32099: PUSH
32100: EMPTY
32101: LIST
32102: LIST
32103: PUSH
32104: LD_INT 0
32106: PUSH
32107: LD_INT 1
32109: PUSH
32110: EMPTY
32111: LIST
32112: LIST
32113: PUSH
32114: LD_INT 1
32116: NEG
32117: PUSH
32118: LD_INT 0
32120: PUSH
32121: EMPTY
32122: LIST
32123: LIST
32124: PUSH
32125: LD_INT 1
32127: NEG
32128: PUSH
32129: LD_INT 1
32131: NEG
32132: PUSH
32133: EMPTY
32134: LIST
32135: LIST
32136: PUSH
32137: LD_INT 1
32139: NEG
32140: PUSH
32141: LD_INT 2
32143: NEG
32144: PUSH
32145: EMPTY
32146: LIST
32147: LIST
32148: PUSH
32149: LD_INT 2
32151: PUSH
32152: LD_INT 1
32154: PUSH
32155: EMPTY
32156: LIST
32157: LIST
32158: PUSH
32159: LD_INT 2
32161: PUSH
32162: LD_INT 2
32164: PUSH
32165: EMPTY
32166: LIST
32167: LIST
32168: PUSH
32169: LD_INT 1
32171: PUSH
32172: LD_INT 2
32174: PUSH
32175: EMPTY
32176: LIST
32177: LIST
32178: PUSH
32179: LD_INT 2
32181: NEG
32182: PUSH
32183: LD_INT 1
32185: NEG
32186: PUSH
32187: EMPTY
32188: LIST
32189: LIST
32190: PUSH
32191: LD_INT 2
32193: NEG
32194: PUSH
32195: LD_INT 2
32197: NEG
32198: PUSH
32199: EMPTY
32200: LIST
32201: LIST
32202: PUSH
32203: LD_INT 3
32205: PUSH
32206: LD_INT 2
32208: PUSH
32209: EMPTY
32210: LIST
32211: LIST
32212: PUSH
32213: LD_INT 3
32215: PUSH
32216: LD_INT 3
32218: PUSH
32219: EMPTY
32220: LIST
32221: LIST
32222: PUSH
32223: LD_INT 2
32225: PUSH
32226: LD_INT 3
32228: PUSH
32229: EMPTY
32230: LIST
32231: LIST
32232: PUSH
32233: EMPTY
32234: LIST
32235: LIST
32236: LIST
32237: LIST
32238: LIST
32239: LIST
32240: LIST
32241: LIST
32242: LIST
32243: LIST
32244: LIST
32245: LIST
32246: LIST
32247: LIST
32248: LIST
32249: LIST
32250: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32251: LD_ADDR_VAR 0 17
32255: PUSH
32256: LD_INT 0
32258: PUSH
32259: LD_INT 0
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: LD_INT 0
32268: PUSH
32269: LD_INT 1
32271: NEG
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 1
32279: PUSH
32280: LD_INT 0
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 1
32289: PUSH
32290: LD_INT 1
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 0
32299: PUSH
32300: LD_INT 1
32302: PUSH
32303: EMPTY
32304: LIST
32305: LIST
32306: PUSH
32307: LD_INT 1
32309: NEG
32310: PUSH
32311: LD_INT 0
32313: PUSH
32314: EMPTY
32315: LIST
32316: LIST
32317: PUSH
32318: LD_INT 1
32320: NEG
32321: PUSH
32322: LD_INT 1
32324: NEG
32325: PUSH
32326: EMPTY
32327: LIST
32328: LIST
32329: PUSH
32330: LD_INT 1
32332: NEG
32333: PUSH
32334: LD_INT 2
32336: NEG
32337: PUSH
32338: EMPTY
32339: LIST
32340: LIST
32341: PUSH
32342: LD_INT 0
32344: PUSH
32345: LD_INT 2
32347: NEG
32348: PUSH
32349: EMPTY
32350: LIST
32351: LIST
32352: PUSH
32353: LD_INT 1
32355: PUSH
32356: LD_INT 1
32358: NEG
32359: PUSH
32360: EMPTY
32361: LIST
32362: LIST
32363: PUSH
32364: LD_INT 2
32366: PUSH
32367: LD_INT 0
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 2
32376: PUSH
32377: LD_INT 1
32379: PUSH
32380: EMPTY
32381: LIST
32382: LIST
32383: PUSH
32384: LD_INT 2
32386: PUSH
32387: LD_INT 2
32389: PUSH
32390: EMPTY
32391: LIST
32392: LIST
32393: PUSH
32394: LD_INT 1
32396: PUSH
32397: LD_INT 2
32399: PUSH
32400: EMPTY
32401: LIST
32402: LIST
32403: PUSH
32404: LD_INT 0
32406: PUSH
32407: LD_INT 2
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 1
32416: NEG
32417: PUSH
32418: LD_INT 1
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: PUSH
32425: LD_INT 2
32427: NEG
32428: PUSH
32429: LD_INT 0
32431: PUSH
32432: EMPTY
32433: LIST
32434: LIST
32435: PUSH
32436: LD_INT 2
32438: NEG
32439: PUSH
32440: LD_INT 1
32442: NEG
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PUSH
32448: LD_INT 2
32450: NEG
32451: PUSH
32452: LD_INT 2
32454: NEG
32455: PUSH
32456: EMPTY
32457: LIST
32458: LIST
32459: PUSH
32460: EMPTY
32461: LIST
32462: LIST
32463: LIST
32464: LIST
32465: LIST
32466: LIST
32467: LIST
32468: LIST
32469: LIST
32470: LIST
32471: LIST
32472: LIST
32473: LIST
32474: LIST
32475: LIST
32476: LIST
32477: LIST
32478: LIST
32479: LIST
32480: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32481: LD_ADDR_VAR 0 18
32485: PUSH
32486: LD_INT 0
32488: PUSH
32489: LD_INT 0
32491: PUSH
32492: EMPTY
32493: LIST
32494: LIST
32495: PUSH
32496: LD_INT 0
32498: PUSH
32499: LD_INT 1
32501: NEG
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PUSH
32507: LD_INT 1
32509: PUSH
32510: LD_INT 0
32512: PUSH
32513: EMPTY
32514: LIST
32515: LIST
32516: PUSH
32517: LD_INT 1
32519: PUSH
32520: LD_INT 1
32522: PUSH
32523: EMPTY
32524: LIST
32525: LIST
32526: PUSH
32527: LD_INT 0
32529: PUSH
32530: LD_INT 1
32532: PUSH
32533: EMPTY
32534: LIST
32535: LIST
32536: PUSH
32537: LD_INT 1
32539: NEG
32540: PUSH
32541: LD_INT 0
32543: PUSH
32544: EMPTY
32545: LIST
32546: LIST
32547: PUSH
32548: LD_INT 1
32550: NEG
32551: PUSH
32552: LD_INT 1
32554: NEG
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: PUSH
32560: LD_INT 1
32562: NEG
32563: PUSH
32564: LD_INT 2
32566: NEG
32567: PUSH
32568: EMPTY
32569: LIST
32570: LIST
32571: PUSH
32572: LD_INT 0
32574: PUSH
32575: LD_INT 2
32577: NEG
32578: PUSH
32579: EMPTY
32580: LIST
32581: LIST
32582: PUSH
32583: LD_INT 1
32585: PUSH
32586: LD_INT 1
32588: NEG
32589: PUSH
32590: EMPTY
32591: LIST
32592: LIST
32593: PUSH
32594: LD_INT 2
32596: PUSH
32597: LD_INT 0
32599: PUSH
32600: EMPTY
32601: LIST
32602: LIST
32603: PUSH
32604: LD_INT 2
32606: PUSH
32607: LD_INT 1
32609: PUSH
32610: EMPTY
32611: LIST
32612: LIST
32613: PUSH
32614: LD_INT 2
32616: PUSH
32617: LD_INT 2
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: LD_INT 1
32626: PUSH
32627: LD_INT 2
32629: PUSH
32630: EMPTY
32631: LIST
32632: LIST
32633: PUSH
32634: LD_INT 0
32636: PUSH
32637: LD_INT 2
32639: PUSH
32640: EMPTY
32641: LIST
32642: LIST
32643: PUSH
32644: LD_INT 1
32646: NEG
32647: PUSH
32648: LD_INT 1
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: PUSH
32655: LD_INT 2
32657: NEG
32658: PUSH
32659: LD_INT 0
32661: PUSH
32662: EMPTY
32663: LIST
32664: LIST
32665: PUSH
32666: LD_INT 2
32668: NEG
32669: PUSH
32670: LD_INT 1
32672: NEG
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PUSH
32678: LD_INT 2
32680: NEG
32681: PUSH
32682: LD_INT 2
32684: NEG
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PUSH
32690: EMPTY
32691: LIST
32692: LIST
32693: LIST
32694: LIST
32695: LIST
32696: LIST
32697: LIST
32698: LIST
32699: LIST
32700: LIST
32701: LIST
32702: LIST
32703: LIST
32704: LIST
32705: LIST
32706: LIST
32707: LIST
32708: LIST
32709: LIST
32710: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32711: LD_ADDR_VAR 0 19
32715: PUSH
32716: LD_INT 0
32718: PUSH
32719: LD_INT 0
32721: PUSH
32722: EMPTY
32723: LIST
32724: LIST
32725: PUSH
32726: LD_INT 0
32728: PUSH
32729: LD_INT 1
32731: NEG
32732: PUSH
32733: EMPTY
32734: LIST
32735: LIST
32736: PUSH
32737: LD_INT 1
32739: PUSH
32740: LD_INT 0
32742: PUSH
32743: EMPTY
32744: LIST
32745: LIST
32746: PUSH
32747: LD_INT 1
32749: PUSH
32750: LD_INT 1
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PUSH
32757: LD_INT 0
32759: PUSH
32760: LD_INT 1
32762: PUSH
32763: EMPTY
32764: LIST
32765: LIST
32766: PUSH
32767: LD_INT 1
32769: NEG
32770: PUSH
32771: LD_INT 0
32773: PUSH
32774: EMPTY
32775: LIST
32776: LIST
32777: PUSH
32778: LD_INT 1
32780: NEG
32781: PUSH
32782: LD_INT 1
32784: NEG
32785: PUSH
32786: EMPTY
32787: LIST
32788: LIST
32789: PUSH
32790: LD_INT 1
32792: NEG
32793: PUSH
32794: LD_INT 2
32796: NEG
32797: PUSH
32798: EMPTY
32799: LIST
32800: LIST
32801: PUSH
32802: LD_INT 0
32804: PUSH
32805: LD_INT 2
32807: NEG
32808: PUSH
32809: EMPTY
32810: LIST
32811: LIST
32812: PUSH
32813: LD_INT 1
32815: PUSH
32816: LD_INT 1
32818: NEG
32819: PUSH
32820: EMPTY
32821: LIST
32822: LIST
32823: PUSH
32824: LD_INT 2
32826: PUSH
32827: LD_INT 0
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 2
32836: PUSH
32837: LD_INT 1
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: LD_INT 2
32846: PUSH
32847: LD_INT 2
32849: PUSH
32850: EMPTY
32851: LIST
32852: LIST
32853: PUSH
32854: LD_INT 1
32856: PUSH
32857: LD_INT 2
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 0
32866: PUSH
32867: LD_INT 2
32869: PUSH
32870: EMPTY
32871: LIST
32872: LIST
32873: PUSH
32874: LD_INT 1
32876: NEG
32877: PUSH
32878: LD_INT 1
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: PUSH
32885: LD_INT 2
32887: NEG
32888: PUSH
32889: LD_INT 0
32891: PUSH
32892: EMPTY
32893: LIST
32894: LIST
32895: PUSH
32896: LD_INT 2
32898: NEG
32899: PUSH
32900: LD_INT 1
32902: NEG
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 2
32910: NEG
32911: PUSH
32912: LD_INT 2
32914: NEG
32915: PUSH
32916: EMPTY
32917: LIST
32918: LIST
32919: PUSH
32920: EMPTY
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: LIST
32939: LIST
32940: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32941: LD_ADDR_VAR 0 20
32945: PUSH
32946: LD_INT 0
32948: PUSH
32949: LD_INT 0
32951: PUSH
32952: EMPTY
32953: LIST
32954: LIST
32955: PUSH
32956: LD_INT 0
32958: PUSH
32959: LD_INT 1
32961: NEG
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 1
32969: PUSH
32970: LD_INT 0
32972: PUSH
32973: EMPTY
32974: LIST
32975: LIST
32976: PUSH
32977: LD_INT 1
32979: PUSH
32980: LD_INT 1
32982: PUSH
32983: EMPTY
32984: LIST
32985: LIST
32986: PUSH
32987: LD_INT 0
32989: PUSH
32990: LD_INT 1
32992: PUSH
32993: EMPTY
32994: LIST
32995: LIST
32996: PUSH
32997: LD_INT 1
32999: NEG
33000: PUSH
33001: LD_INT 0
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: PUSH
33008: LD_INT 1
33010: NEG
33011: PUSH
33012: LD_INT 1
33014: NEG
33015: PUSH
33016: EMPTY
33017: LIST
33018: LIST
33019: PUSH
33020: LD_INT 1
33022: NEG
33023: PUSH
33024: LD_INT 2
33026: NEG
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: PUSH
33032: LD_INT 0
33034: PUSH
33035: LD_INT 2
33037: NEG
33038: PUSH
33039: EMPTY
33040: LIST
33041: LIST
33042: PUSH
33043: LD_INT 1
33045: PUSH
33046: LD_INT 1
33048: NEG
33049: PUSH
33050: EMPTY
33051: LIST
33052: LIST
33053: PUSH
33054: LD_INT 2
33056: PUSH
33057: LD_INT 0
33059: PUSH
33060: EMPTY
33061: LIST
33062: LIST
33063: PUSH
33064: LD_INT 2
33066: PUSH
33067: LD_INT 1
33069: PUSH
33070: EMPTY
33071: LIST
33072: LIST
33073: PUSH
33074: LD_INT 2
33076: PUSH
33077: LD_INT 2
33079: PUSH
33080: EMPTY
33081: LIST
33082: LIST
33083: PUSH
33084: LD_INT 1
33086: PUSH
33087: LD_INT 2
33089: PUSH
33090: EMPTY
33091: LIST
33092: LIST
33093: PUSH
33094: LD_INT 0
33096: PUSH
33097: LD_INT 2
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 1
33106: NEG
33107: PUSH
33108: LD_INT 1
33110: PUSH
33111: EMPTY
33112: LIST
33113: LIST
33114: PUSH
33115: LD_INT 2
33117: NEG
33118: PUSH
33119: LD_INT 0
33121: PUSH
33122: EMPTY
33123: LIST
33124: LIST
33125: PUSH
33126: LD_INT 2
33128: NEG
33129: PUSH
33130: LD_INT 1
33132: NEG
33133: PUSH
33134: EMPTY
33135: LIST
33136: LIST
33137: PUSH
33138: LD_INT 2
33140: NEG
33141: PUSH
33142: LD_INT 2
33144: NEG
33145: PUSH
33146: EMPTY
33147: LIST
33148: LIST
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: LIST
33168: LIST
33169: LIST
33170: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33171: LD_ADDR_VAR 0 21
33175: PUSH
33176: LD_INT 0
33178: PUSH
33179: LD_INT 0
33181: PUSH
33182: EMPTY
33183: LIST
33184: LIST
33185: PUSH
33186: LD_INT 0
33188: PUSH
33189: LD_INT 1
33191: NEG
33192: PUSH
33193: EMPTY
33194: LIST
33195: LIST
33196: PUSH
33197: LD_INT 1
33199: PUSH
33200: LD_INT 0
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: PUSH
33207: LD_INT 1
33209: PUSH
33210: LD_INT 1
33212: PUSH
33213: EMPTY
33214: LIST
33215: LIST
33216: PUSH
33217: LD_INT 0
33219: PUSH
33220: LD_INT 1
33222: PUSH
33223: EMPTY
33224: LIST
33225: LIST
33226: PUSH
33227: LD_INT 1
33229: NEG
33230: PUSH
33231: LD_INT 0
33233: PUSH
33234: EMPTY
33235: LIST
33236: LIST
33237: PUSH
33238: LD_INT 1
33240: NEG
33241: PUSH
33242: LD_INT 1
33244: NEG
33245: PUSH
33246: EMPTY
33247: LIST
33248: LIST
33249: PUSH
33250: LD_INT 1
33252: NEG
33253: PUSH
33254: LD_INT 2
33256: NEG
33257: PUSH
33258: EMPTY
33259: LIST
33260: LIST
33261: PUSH
33262: LD_INT 0
33264: PUSH
33265: LD_INT 2
33267: NEG
33268: PUSH
33269: EMPTY
33270: LIST
33271: LIST
33272: PUSH
33273: LD_INT 1
33275: PUSH
33276: LD_INT 1
33278: NEG
33279: PUSH
33280: EMPTY
33281: LIST
33282: LIST
33283: PUSH
33284: LD_INT 2
33286: PUSH
33287: LD_INT 0
33289: PUSH
33290: EMPTY
33291: LIST
33292: LIST
33293: PUSH
33294: LD_INT 2
33296: PUSH
33297: LD_INT 1
33299: PUSH
33300: EMPTY
33301: LIST
33302: LIST
33303: PUSH
33304: LD_INT 2
33306: PUSH
33307: LD_INT 2
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PUSH
33314: LD_INT 1
33316: PUSH
33317: LD_INT 2
33319: PUSH
33320: EMPTY
33321: LIST
33322: LIST
33323: PUSH
33324: LD_INT 0
33326: PUSH
33327: LD_INT 2
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PUSH
33334: LD_INT 1
33336: NEG
33337: PUSH
33338: LD_INT 1
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: PUSH
33345: LD_INT 2
33347: NEG
33348: PUSH
33349: LD_INT 0
33351: PUSH
33352: EMPTY
33353: LIST
33354: LIST
33355: PUSH
33356: LD_INT 2
33358: NEG
33359: PUSH
33360: LD_INT 1
33362: NEG
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: LD_INT 2
33370: NEG
33371: PUSH
33372: LD_INT 2
33374: NEG
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: EMPTY
33381: LIST
33382: LIST
33383: LIST
33384: LIST
33385: LIST
33386: LIST
33387: LIST
33388: LIST
33389: LIST
33390: LIST
33391: LIST
33392: LIST
33393: LIST
33394: LIST
33395: LIST
33396: LIST
33397: LIST
33398: LIST
33399: LIST
33400: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33401: LD_ADDR_VAR 0 22
33405: PUSH
33406: LD_INT 0
33408: PUSH
33409: LD_INT 0
33411: PUSH
33412: EMPTY
33413: LIST
33414: LIST
33415: PUSH
33416: LD_INT 0
33418: PUSH
33419: LD_INT 1
33421: NEG
33422: PUSH
33423: EMPTY
33424: LIST
33425: LIST
33426: PUSH
33427: LD_INT 1
33429: PUSH
33430: LD_INT 0
33432: PUSH
33433: EMPTY
33434: LIST
33435: LIST
33436: PUSH
33437: LD_INT 1
33439: PUSH
33440: LD_INT 1
33442: PUSH
33443: EMPTY
33444: LIST
33445: LIST
33446: PUSH
33447: LD_INT 0
33449: PUSH
33450: LD_INT 1
33452: PUSH
33453: EMPTY
33454: LIST
33455: LIST
33456: PUSH
33457: LD_INT 1
33459: NEG
33460: PUSH
33461: LD_INT 0
33463: PUSH
33464: EMPTY
33465: LIST
33466: LIST
33467: PUSH
33468: LD_INT 1
33470: NEG
33471: PUSH
33472: LD_INT 1
33474: NEG
33475: PUSH
33476: EMPTY
33477: LIST
33478: LIST
33479: PUSH
33480: LD_INT 1
33482: NEG
33483: PUSH
33484: LD_INT 2
33486: NEG
33487: PUSH
33488: EMPTY
33489: LIST
33490: LIST
33491: PUSH
33492: LD_INT 0
33494: PUSH
33495: LD_INT 2
33497: NEG
33498: PUSH
33499: EMPTY
33500: LIST
33501: LIST
33502: PUSH
33503: LD_INT 1
33505: PUSH
33506: LD_INT 1
33508: NEG
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PUSH
33514: LD_INT 2
33516: PUSH
33517: LD_INT 0
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 2
33526: PUSH
33527: LD_INT 1
33529: PUSH
33530: EMPTY
33531: LIST
33532: LIST
33533: PUSH
33534: LD_INT 2
33536: PUSH
33537: LD_INT 2
33539: PUSH
33540: EMPTY
33541: LIST
33542: LIST
33543: PUSH
33544: LD_INT 1
33546: PUSH
33547: LD_INT 2
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: PUSH
33554: LD_INT 0
33556: PUSH
33557: LD_INT 2
33559: PUSH
33560: EMPTY
33561: LIST
33562: LIST
33563: PUSH
33564: LD_INT 1
33566: NEG
33567: PUSH
33568: LD_INT 1
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: PUSH
33575: LD_INT 2
33577: NEG
33578: PUSH
33579: LD_INT 0
33581: PUSH
33582: EMPTY
33583: LIST
33584: LIST
33585: PUSH
33586: LD_INT 2
33588: NEG
33589: PUSH
33590: LD_INT 1
33592: NEG
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PUSH
33598: LD_INT 2
33600: NEG
33601: PUSH
33602: LD_INT 2
33604: NEG
33605: PUSH
33606: EMPTY
33607: LIST
33608: LIST
33609: PUSH
33610: EMPTY
33611: LIST
33612: LIST
33613: LIST
33614: LIST
33615: LIST
33616: LIST
33617: LIST
33618: LIST
33619: LIST
33620: LIST
33621: LIST
33622: LIST
33623: LIST
33624: LIST
33625: LIST
33626: LIST
33627: LIST
33628: LIST
33629: LIST
33630: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
33631: LD_ADDR_VAR 0 23
33635: PUSH
33636: LD_INT 0
33638: PUSH
33639: LD_INT 0
33641: PUSH
33642: EMPTY
33643: LIST
33644: LIST
33645: PUSH
33646: LD_INT 0
33648: PUSH
33649: LD_INT 1
33651: NEG
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: PUSH
33657: LD_INT 1
33659: PUSH
33660: LD_INT 0
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PUSH
33667: LD_INT 1
33669: PUSH
33670: LD_INT 1
33672: PUSH
33673: EMPTY
33674: LIST
33675: LIST
33676: PUSH
33677: LD_INT 0
33679: PUSH
33680: LD_INT 1
33682: PUSH
33683: EMPTY
33684: LIST
33685: LIST
33686: PUSH
33687: LD_INT 1
33689: NEG
33690: PUSH
33691: LD_INT 0
33693: PUSH
33694: EMPTY
33695: LIST
33696: LIST
33697: PUSH
33698: LD_INT 1
33700: NEG
33701: PUSH
33702: LD_INT 1
33704: NEG
33705: PUSH
33706: EMPTY
33707: LIST
33708: LIST
33709: PUSH
33710: LD_INT 1
33712: NEG
33713: PUSH
33714: LD_INT 2
33716: NEG
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 0
33724: PUSH
33725: LD_INT 2
33727: NEG
33728: PUSH
33729: EMPTY
33730: LIST
33731: LIST
33732: PUSH
33733: LD_INT 1
33735: PUSH
33736: LD_INT 1
33738: NEG
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 2
33746: PUSH
33747: LD_INT 0
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: LD_INT 2
33756: PUSH
33757: LD_INT 1
33759: PUSH
33760: EMPTY
33761: LIST
33762: LIST
33763: PUSH
33764: LD_INT 2
33766: PUSH
33767: LD_INT 2
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 1
33776: PUSH
33777: LD_INT 2
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PUSH
33784: LD_INT 0
33786: PUSH
33787: LD_INT 2
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: LD_INT 1
33796: NEG
33797: PUSH
33798: LD_INT 1
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: PUSH
33805: LD_INT 2
33807: NEG
33808: PUSH
33809: LD_INT 0
33811: PUSH
33812: EMPTY
33813: LIST
33814: LIST
33815: PUSH
33816: LD_INT 2
33818: NEG
33819: PUSH
33820: LD_INT 1
33822: NEG
33823: PUSH
33824: EMPTY
33825: LIST
33826: LIST
33827: PUSH
33828: LD_INT 2
33830: NEG
33831: PUSH
33832: LD_INT 2
33834: NEG
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 2
33842: NEG
33843: PUSH
33844: LD_INT 3
33846: NEG
33847: PUSH
33848: EMPTY
33849: LIST
33850: LIST
33851: PUSH
33852: LD_INT 1
33854: NEG
33855: PUSH
33856: LD_INT 3
33858: NEG
33859: PUSH
33860: EMPTY
33861: LIST
33862: LIST
33863: PUSH
33864: LD_INT 1
33866: PUSH
33867: LD_INT 2
33869: NEG
33870: PUSH
33871: EMPTY
33872: LIST
33873: LIST
33874: PUSH
33875: LD_INT 2
33877: PUSH
33878: LD_INT 1
33880: NEG
33881: PUSH
33882: EMPTY
33883: LIST
33884: LIST
33885: PUSH
33886: EMPTY
33887: LIST
33888: LIST
33889: LIST
33890: LIST
33891: LIST
33892: LIST
33893: LIST
33894: LIST
33895: LIST
33896: LIST
33897: LIST
33898: LIST
33899: LIST
33900: LIST
33901: LIST
33902: LIST
33903: LIST
33904: LIST
33905: LIST
33906: LIST
33907: LIST
33908: LIST
33909: LIST
33910: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
33911: LD_ADDR_VAR 0 24
33915: PUSH
33916: LD_INT 0
33918: PUSH
33919: LD_INT 0
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: LD_INT 0
33928: PUSH
33929: LD_INT 1
33931: NEG
33932: PUSH
33933: EMPTY
33934: LIST
33935: LIST
33936: PUSH
33937: LD_INT 1
33939: PUSH
33940: LD_INT 0
33942: PUSH
33943: EMPTY
33944: LIST
33945: LIST
33946: PUSH
33947: LD_INT 1
33949: PUSH
33950: LD_INT 1
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 0
33959: PUSH
33960: LD_INT 1
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 1
33969: NEG
33970: PUSH
33971: LD_INT 0
33973: PUSH
33974: EMPTY
33975: LIST
33976: LIST
33977: PUSH
33978: LD_INT 1
33980: NEG
33981: PUSH
33982: LD_INT 1
33984: NEG
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: LD_INT 1
33992: NEG
33993: PUSH
33994: LD_INT 2
33996: NEG
33997: PUSH
33998: EMPTY
33999: LIST
34000: LIST
34001: PUSH
34002: LD_INT 0
34004: PUSH
34005: LD_INT 2
34007: NEG
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 1
34015: PUSH
34016: LD_INT 1
34018: NEG
34019: PUSH
34020: EMPTY
34021: LIST
34022: LIST
34023: PUSH
34024: LD_INT 2
34026: PUSH
34027: LD_INT 0
34029: PUSH
34030: EMPTY
34031: LIST
34032: LIST
34033: PUSH
34034: LD_INT 2
34036: PUSH
34037: LD_INT 1
34039: PUSH
34040: EMPTY
34041: LIST
34042: LIST
34043: PUSH
34044: LD_INT 2
34046: PUSH
34047: LD_INT 2
34049: PUSH
34050: EMPTY
34051: LIST
34052: LIST
34053: PUSH
34054: LD_INT 1
34056: PUSH
34057: LD_INT 2
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: LD_INT 0
34066: PUSH
34067: LD_INT 2
34069: PUSH
34070: EMPTY
34071: LIST
34072: LIST
34073: PUSH
34074: LD_INT 1
34076: NEG
34077: PUSH
34078: LD_INT 1
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: LD_INT 2
34087: NEG
34088: PUSH
34089: LD_INT 0
34091: PUSH
34092: EMPTY
34093: LIST
34094: LIST
34095: PUSH
34096: LD_INT 2
34098: NEG
34099: PUSH
34100: LD_INT 1
34102: NEG
34103: PUSH
34104: EMPTY
34105: LIST
34106: LIST
34107: PUSH
34108: LD_INT 2
34110: NEG
34111: PUSH
34112: LD_INT 2
34114: NEG
34115: PUSH
34116: EMPTY
34117: LIST
34118: LIST
34119: PUSH
34120: LD_INT 1
34122: PUSH
34123: LD_INT 2
34125: NEG
34126: PUSH
34127: EMPTY
34128: LIST
34129: LIST
34130: PUSH
34131: LD_INT 2
34133: PUSH
34134: LD_INT 1
34136: NEG
34137: PUSH
34138: EMPTY
34139: LIST
34140: LIST
34141: PUSH
34142: LD_INT 3
34144: PUSH
34145: LD_INT 1
34147: PUSH
34148: EMPTY
34149: LIST
34150: LIST
34151: PUSH
34152: LD_INT 3
34154: PUSH
34155: LD_INT 2
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: EMPTY
34163: LIST
34164: LIST
34165: LIST
34166: LIST
34167: LIST
34168: LIST
34169: LIST
34170: LIST
34171: LIST
34172: LIST
34173: LIST
34174: LIST
34175: LIST
34176: LIST
34177: LIST
34178: LIST
34179: LIST
34180: LIST
34181: LIST
34182: LIST
34183: LIST
34184: LIST
34185: LIST
34186: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
34187: LD_ADDR_VAR 0 25
34191: PUSH
34192: LD_INT 0
34194: PUSH
34195: LD_INT 0
34197: PUSH
34198: EMPTY
34199: LIST
34200: LIST
34201: PUSH
34202: LD_INT 0
34204: PUSH
34205: LD_INT 1
34207: NEG
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 1
34215: PUSH
34216: LD_INT 0
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 1
34225: PUSH
34226: LD_INT 1
34228: PUSH
34229: EMPTY
34230: LIST
34231: LIST
34232: PUSH
34233: LD_INT 0
34235: PUSH
34236: LD_INT 1
34238: PUSH
34239: EMPTY
34240: LIST
34241: LIST
34242: PUSH
34243: LD_INT 1
34245: NEG
34246: PUSH
34247: LD_INT 0
34249: PUSH
34250: EMPTY
34251: LIST
34252: LIST
34253: PUSH
34254: LD_INT 1
34256: NEG
34257: PUSH
34258: LD_INT 1
34260: NEG
34261: PUSH
34262: EMPTY
34263: LIST
34264: LIST
34265: PUSH
34266: LD_INT 1
34268: NEG
34269: PUSH
34270: LD_INT 2
34272: NEG
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: PUSH
34278: LD_INT 0
34280: PUSH
34281: LD_INT 2
34283: NEG
34284: PUSH
34285: EMPTY
34286: LIST
34287: LIST
34288: PUSH
34289: LD_INT 1
34291: PUSH
34292: LD_INT 1
34294: NEG
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 2
34302: PUSH
34303: LD_INT 0
34305: PUSH
34306: EMPTY
34307: LIST
34308: LIST
34309: PUSH
34310: LD_INT 2
34312: PUSH
34313: LD_INT 1
34315: PUSH
34316: EMPTY
34317: LIST
34318: LIST
34319: PUSH
34320: LD_INT 2
34322: PUSH
34323: LD_INT 2
34325: PUSH
34326: EMPTY
34327: LIST
34328: LIST
34329: PUSH
34330: LD_INT 1
34332: PUSH
34333: LD_INT 2
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 0
34342: PUSH
34343: LD_INT 2
34345: PUSH
34346: EMPTY
34347: LIST
34348: LIST
34349: PUSH
34350: LD_INT 1
34352: NEG
34353: PUSH
34354: LD_INT 1
34356: PUSH
34357: EMPTY
34358: LIST
34359: LIST
34360: PUSH
34361: LD_INT 2
34363: NEG
34364: PUSH
34365: LD_INT 0
34367: PUSH
34368: EMPTY
34369: LIST
34370: LIST
34371: PUSH
34372: LD_INT 2
34374: NEG
34375: PUSH
34376: LD_INT 1
34378: NEG
34379: PUSH
34380: EMPTY
34381: LIST
34382: LIST
34383: PUSH
34384: LD_INT 2
34386: NEG
34387: PUSH
34388: LD_INT 2
34390: NEG
34391: PUSH
34392: EMPTY
34393: LIST
34394: LIST
34395: PUSH
34396: LD_INT 3
34398: PUSH
34399: LD_INT 1
34401: PUSH
34402: EMPTY
34403: LIST
34404: LIST
34405: PUSH
34406: LD_INT 3
34408: PUSH
34409: LD_INT 2
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PUSH
34416: LD_INT 2
34418: PUSH
34419: LD_INT 3
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: PUSH
34426: LD_INT 1
34428: PUSH
34429: LD_INT 3
34431: PUSH
34432: EMPTY
34433: LIST
34434: LIST
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: LIST
34440: LIST
34441: LIST
34442: LIST
34443: LIST
34444: LIST
34445: LIST
34446: LIST
34447: LIST
34448: LIST
34449: LIST
34450: LIST
34451: LIST
34452: LIST
34453: LIST
34454: LIST
34455: LIST
34456: LIST
34457: LIST
34458: LIST
34459: LIST
34460: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
34461: LD_ADDR_VAR 0 26
34465: PUSH
34466: LD_INT 0
34468: PUSH
34469: LD_INT 0
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: PUSH
34476: LD_INT 0
34478: PUSH
34479: LD_INT 1
34481: NEG
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: PUSH
34487: LD_INT 1
34489: PUSH
34490: LD_INT 0
34492: PUSH
34493: EMPTY
34494: LIST
34495: LIST
34496: PUSH
34497: LD_INT 1
34499: PUSH
34500: LD_INT 1
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 0
34509: PUSH
34510: LD_INT 1
34512: PUSH
34513: EMPTY
34514: LIST
34515: LIST
34516: PUSH
34517: LD_INT 1
34519: NEG
34520: PUSH
34521: LD_INT 0
34523: PUSH
34524: EMPTY
34525: LIST
34526: LIST
34527: PUSH
34528: LD_INT 1
34530: NEG
34531: PUSH
34532: LD_INT 1
34534: NEG
34535: PUSH
34536: EMPTY
34537: LIST
34538: LIST
34539: PUSH
34540: LD_INT 1
34542: NEG
34543: PUSH
34544: LD_INT 2
34546: NEG
34547: PUSH
34548: EMPTY
34549: LIST
34550: LIST
34551: PUSH
34552: LD_INT 0
34554: PUSH
34555: LD_INT 2
34557: NEG
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 1
34565: PUSH
34566: LD_INT 1
34568: NEG
34569: PUSH
34570: EMPTY
34571: LIST
34572: LIST
34573: PUSH
34574: LD_INT 2
34576: PUSH
34577: LD_INT 0
34579: PUSH
34580: EMPTY
34581: LIST
34582: LIST
34583: PUSH
34584: LD_INT 2
34586: PUSH
34587: LD_INT 1
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 2
34596: PUSH
34597: LD_INT 2
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: PUSH
34604: LD_INT 1
34606: PUSH
34607: LD_INT 2
34609: PUSH
34610: EMPTY
34611: LIST
34612: LIST
34613: PUSH
34614: LD_INT 0
34616: PUSH
34617: LD_INT 2
34619: PUSH
34620: EMPTY
34621: LIST
34622: LIST
34623: PUSH
34624: LD_INT 1
34626: NEG
34627: PUSH
34628: LD_INT 1
34630: PUSH
34631: EMPTY
34632: LIST
34633: LIST
34634: PUSH
34635: LD_INT 2
34637: NEG
34638: PUSH
34639: LD_INT 0
34641: PUSH
34642: EMPTY
34643: LIST
34644: LIST
34645: PUSH
34646: LD_INT 2
34648: NEG
34649: PUSH
34650: LD_INT 1
34652: NEG
34653: PUSH
34654: EMPTY
34655: LIST
34656: LIST
34657: PUSH
34658: LD_INT 2
34660: NEG
34661: PUSH
34662: LD_INT 2
34664: NEG
34665: PUSH
34666: EMPTY
34667: LIST
34668: LIST
34669: PUSH
34670: LD_INT 2
34672: PUSH
34673: LD_INT 3
34675: PUSH
34676: EMPTY
34677: LIST
34678: LIST
34679: PUSH
34680: LD_INT 1
34682: PUSH
34683: LD_INT 3
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PUSH
34690: LD_INT 1
34692: NEG
34693: PUSH
34694: LD_INT 2
34696: PUSH
34697: EMPTY
34698: LIST
34699: LIST
34700: PUSH
34701: LD_INT 2
34703: NEG
34704: PUSH
34705: LD_INT 1
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: LIST
34735: LIST
34736: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
34737: LD_ADDR_VAR 0 27
34741: PUSH
34742: LD_INT 0
34744: PUSH
34745: LD_INT 0
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: PUSH
34752: LD_INT 0
34754: PUSH
34755: LD_INT 1
34757: NEG
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 1
34765: PUSH
34766: LD_INT 0
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: LD_INT 1
34775: PUSH
34776: LD_INT 1
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 0
34785: PUSH
34786: LD_INT 1
34788: PUSH
34789: EMPTY
34790: LIST
34791: LIST
34792: PUSH
34793: LD_INT 1
34795: NEG
34796: PUSH
34797: LD_INT 0
34799: PUSH
34800: EMPTY
34801: LIST
34802: LIST
34803: PUSH
34804: LD_INT 1
34806: NEG
34807: PUSH
34808: LD_INT 1
34810: NEG
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 1
34818: NEG
34819: PUSH
34820: LD_INT 2
34822: NEG
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: LD_INT 0
34830: PUSH
34831: LD_INT 2
34833: NEG
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: PUSH
34839: LD_INT 1
34841: PUSH
34842: LD_INT 1
34844: NEG
34845: PUSH
34846: EMPTY
34847: LIST
34848: LIST
34849: PUSH
34850: LD_INT 2
34852: PUSH
34853: LD_INT 0
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: PUSH
34860: LD_INT 2
34862: PUSH
34863: LD_INT 1
34865: PUSH
34866: EMPTY
34867: LIST
34868: LIST
34869: PUSH
34870: LD_INT 2
34872: PUSH
34873: LD_INT 2
34875: PUSH
34876: EMPTY
34877: LIST
34878: LIST
34879: PUSH
34880: LD_INT 1
34882: PUSH
34883: LD_INT 2
34885: PUSH
34886: EMPTY
34887: LIST
34888: LIST
34889: PUSH
34890: LD_INT 0
34892: PUSH
34893: LD_INT 2
34895: PUSH
34896: EMPTY
34897: LIST
34898: LIST
34899: PUSH
34900: LD_INT 1
34902: NEG
34903: PUSH
34904: LD_INT 1
34906: PUSH
34907: EMPTY
34908: LIST
34909: LIST
34910: PUSH
34911: LD_INT 2
34913: NEG
34914: PUSH
34915: LD_INT 0
34917: PUSH
34918: EMPTY
34919: LIST
34920: LIST
34921: PUSH
34922: LD_INT 2
34924: NEG
34925: PUSH
34926: LD_INT 1
34928: NEG
34929: PUSH
34930: EMPTY
34931: LIST
34932: LIST
34933: PUSH
34934: LD_INT 2
34936: NEG
34937: PUSH
34938: LD_INT 2
34940: NEG
34941: PUSH
34942: EMPTY
34943: LIST
34944: LIST
34945: PUSH
34946: LD_INT 1
34948: NEG
34949: PUSH
34950: LD_INT 2
34952: PUSH
34953: EMPTY
34954: LIST
34955: LIST
34956: PUSH
34957: LD_INT 2
34959: NEG
34960: PUSH
34961: LD_INT 1
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: LD_INT 3
34970: NEG
34971: PUSH
34972: LD_INT 1
34974: NEG
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: PUSH
34980: LD_INT 3
34982: NEG
34983: PUSH
34984: LD_INT 2
34986: NEG
34987: PUSH
34988: EMPTY
34989: LIST
34990: LIST
34991: PUSH
34992: EMPTY
34993: LIST
34994: LIST
34995: LIST
34996: LIST
34997: LIST
34998: LIST
34999: LIST
35000: LIST
35001: LIST
35002: LIST
35003: LIST
35004: LIST
35005: LIST
35006: LIST
35007: LIST
35008: LIST
35009: LIST
35010: LIST
35011: LIST
35012: LIST
35013: LIST
35014: LIST
35015: LIST
35016: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
35017: LD_ADDR_VAR 0 28
35021: PUSH
35022: LD_INT 0
35024: PUSH
35025: LD_INT 0
35027: PUSH
35028: EMPTY
35029: LIST
35030: LIST
35031: PUSH
35032: LD_INT 0
35034: PUSH
35035: LD_INT 1
35037: NEG
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: LD_INT 1
35045: PUSH
35046: LD_INT 0
35048: PUSH
35049: EMPTY
35050: LIST
35051: LIST
35052: PUSH
35053: LD_INT 1
35055: PUSH
35056: LD_INT 1
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PUSH
35063: LD_INT 0
35065: PUSH
35066: LD_INT 1
35068: PUSH
35069: EMPTY
35070: LIST
35071: LIST
35072: PUSH
35073: LD_INT 1
35075: NEG
35076: PUSH
35077: LD_INT 0
35079: PUSH
35080: EMPTY
35081: LIST
35082: LIST
35083: PUSH
35084: LD_INT 1
35086: NEG
35087: PUSH
35088: LD_INT 1
35090: NEG
35091: PUSH
35092: EMPTY
35093: LIST
35094: LIST
35095: PUSH
35096: LD_INT 1
35098: NEG
35099: PUSH
35100: LD_INT 2
35102: NEG
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: PUSH
35108: LD_INT 0
35110: PUSH
35111: LD_INT 2
35113: NEG
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 1
35121: PUSH
35122: LD_INT 1
35124: NEG
35125: PUSH
35126: EMPTY
35127: LIST
35128: LIST
35129: PUSH
35130: LD_INT 2
35132: PUSH
35133: LD_INT 0
35135: PUSH
35136: EMPTY
35137: LIST
35138: LIST
35139: PUSH
35140: LD_INT 2
35142: PUSH
35143: LD_INT 1
35145: PUSH
35146: EMPTY
35147: LIST
35148: LIST
35149: PUSH
35150: LD_INT 2
35152: PUSH
35153: LD_INT 2
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: PUSH
35160: LD_INT 1
35162: PUSH
35163: LD_INT 2
35165: PUSH
35166: EMPTY
35167: LIST
35168: LIST
35169: PUSH
35170: LD_INT 0
35172: PUSH
35173: LD_INT 2
35175: PUSH
35176: EMPTY
35177: LIST
35178: LIST
35179: PUSH
35180: LD_INT 1
35182: NEG
35183: PUSH
35184: LD_INT 1
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PUSH
35191: LD_INT 2
35193: NEG
35194: PUSH
35195: LD_INT 0
35197: PUSH
35198: EMPTY
35199: LIST
35200: LIST
35201: PUSH
35202: LD_INT 2
35204: NEG
35205: PUSH
35206: LD_INT 1
35208: NEG
35209: PUSH
35210: EMPTY
35211: LIST
35212: LIST
35213: PUSH
35214: LD_INT 2
35216: NEG
35217: PUSH
35218: LD_INT 2
35220: NEG
35221: PUSH
35222: EMPTY
35223: LIST
35224: LIST
35225: PUSH
35226: LD_INT 2
35228: NEG
35229: PUSH
35230: LD_INT 3
35232: NEG
35233: PUSH
35234: EMPTY
35235: LIST
35236: LIST
35237: PUSH
35238: LD_INT 1
35240: NEG
35241: PUSH
35242: LD_INT 3
35244: NEG
35245: PUSH
35246: EMPTY
35247: LIST
35248: LIST
35249: PUSH
35250: LD_INT 3
35252: NEG
35253: PUSH
35254: LD_INT 1
35256: NEG
35257: PUSH
35258: EMPTY
35259: LIST
35260: LIST
35261: PUSH
35262: LD_INT 3
35264: NEG
35265: PUSH
35266: LD_INT 2
35268: NEG
35269: PUSH
35270: EMPTY
35271: LIST
35272: LIST
35273: PUSH
35274: EMPTY
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: LIST
35285: LIST
35286: LIST
35287: LIST
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: LIST
35297: LIST
35298: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35299: LD_ADDR_VAR 0 29
35303: PUSH
35304: LD_INT 0
35306: PUSH
35307: LD_INT 0
35309: PUSH
35310: EMPTY
35311: LIST
35312: LIST
35313: PUSH
35314: LD_INT 0
35316: PUSH
35317: LD_INT 1
35319: NEG
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: PUSH
35325: LD_INT 1
35327: PUSH
35328: LD_INT 0
35330: PUSH
35331: EMPTY
35332: LIST
35333: LIST
35334: PUSH
35335: LD_INT 1
35337: PUSH
35338: LD_INT 1
35340: PUSH
35341: EMPTY
35342: LIST
35343: LIST
35344: PUSH
35345: LD_INT 0
35347: PUSH
35348: LD_INT 1
35350: PUSH
35351: EMPTY
35352: LIST
35353: LIST
35354: PUSH
35355: LD_INT 1
35357: NEG
35358: PUSH
35359: LD_INT 0
35361: PUSH
35362: EMPTY
35363: LIST
35364: LIST
35365: PUSH
35366: LD_INT 1
35368: NEG
35369: PUSH
35370: LD_INT 1
35372: NEG
35373: PUSH
35374: EMPTY
35375: LIST
35376: LIST
35377: PUSH
35378: LD_INT 1
35380: NEG
35381: PUSH
35382: LD_INT 2
35384: NEG
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PUSH
35390: LD_INT 0
35392: PUSH
35393: LD_INT 2
35395: NEG
35396: PUSH
35397: EMPTY
35398: LIST
35399: LIST
35400: PUSH
35401: LD_INT 1
35403: PUSH
35404: LD_INT 1
35406: NEG
35407: PUSH
35408: EMPTY
35409: LIST
35410: LIST
35411: PUSH
35412: LD_INT 2
35414: PUSH
35415: LD_INT 0
35417: PUSH
35418: EMPTY
35419: LIST
35420: LIST
35421: PUSH
35422: LD_INT 2
35424: PUSH
35425: LD_INT 1
35427: PUSH
35428: EMPTY
35429: LIST
35430: LIST
35431: PUSH
35432: LD_INT 1
35434: PUSH
35435: LD_INT 2
35437: PUSH
35438: EMPTY
35439: LIST
35440: LIST
35441: PUSH
35442: LD_INT 0
35444: PUSH
35445: LD_INT 2
35447: PUSH
35448: EMPTY
35449: LIST
35450: LIST
35451: PUSH
35452: LD_INT 1
35454: NEG
35455: PUSH
35456: LD_INT 1
35458: PUSH
35459: EMPTY
35460: LIST
35461: LIST
35462: PUSH
35463: LD_INT 2
35465: NEG
35466: PUSH
35467: LD_INT 1
35469: NEG
35470: PUSH
35471: EMPTY
35472: LIST
35473: LIST
35474: PUSH
35475: LD_INT 2
35477: NEG
35478: PUSH
35479: LD_INT 2
35481: NEG
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: LD_INT 2
35489: NEG
35490: PUSH
35491: LD_INT 3
35493: NEG
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: PUSH
35499: LD_INT 2
35501: PUSH
35502: LD_INT 1
35504: NEG
35505: PUSH
35506: EMPTY
35507: LIST
35508: LIST
35509: PUSH
35510: LD_INT 3
35512: PUSH
35513: LD_INT 1
35515: PUSH
35516: EMPTY
35517: LIST
35518: LIST
35519: PUSH
35520: LD_INT 1
35522: PUSH
35523: LD_INT 3
35525: PUSH
35526: EMPTY
35527: LIST
35528: LIST
35529: PUSH
35530: LD_INT 1
35532: NEG
35533: PUSH
35534: LD_INT 2
35536: PUSH
35537: EMPTY
35538: LIST
35539: LIST
35540: PUSH
35541: LD_INT 3
35543: NEG
35544: PUSH
35545: LD_INT 2
35547: NEG
35548: PUSH
35549: EMPTY
35550: LIST
35551: LIST
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: LIST
35557: LIST
35558: LIST
35559: LIST
35560: LIST
35561: LIST
35562: LIST
35563: LIST
35564: LIST
35565: LIST
35566: LIST
35567: LIST
35568: LIST
35569: LIST
35570: LIST
35571: LIST
35572: LIST
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35578: LD_ADDR_VAR 0 30
35582: PUSH
35583: LD_INT 0
35585: PUSH
35586: LD_INT 0
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: PUSH
35593: LD_INT 0
35595: PUSH
35596: LD_INT 1
35598: NEG
35599: PUSH
35600: EMPTY
35601: LIST
35602: LIST
35603: PUSH
35604: LD_INT 1
35606: PUSH
35607: LD_INT 0
35609: PUSH
35610: EMPTY
35611: LIST
35612: LIST
35613: PUSH
35614: LD_INT 1
35616: PUSH
35617: LD_INT 1
35619: PUSH
35620: EMPTY
35621: LIST
35622: LIST
35623: PUSH
35624: LD_INT 0
35626: PUSH
35627: LD_INT 1
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: PUSH
35634: LD_INT 1
35636: NEG
35637: PUSH
35638: LD_INT 0
35640: PUSH
35641: EMPTY
35642: LIST
35643: LIST
35644: PUSH
35645: LD_INT 1
35647: NEG
35648: PUSH
35649: LD_INT 1
35651: NEG
35652: PUSH
35653: EMPTY
35654: LIST
35655: LIST
35656: PUSH
35657: LD_INT 1
35659: NEG
35660: PUSH
35661: LD_INT 2
35663: NEG
35664: PUSH
35665: EMPTY
35666: LIST
35667: LIST
35668: PUSH
35669: LD_INT 0
35671: PUSH
35672: LD_INT 2
35674: NEG
35675: PUSH
35676: EMPTY
35677: LIST
35678: LIST
35679: PUSH
35680: LD_INT 1
35682: PUSH
35683: LD_INT 1
35685: NEG
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 2
35693: PUSH
35694: LD_INT 0
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 2
35703: PUSH
35704: LD_INT 1
35706: PUSH
35707: EMPTY
35708: LIST
35709: LIST
35710: PUSH
35711: LD_INT 2
35713: PUSH
35714: LD_INT 2
35716: PUSH
35717: EMPTY
35718: LIST
35719: LIST
35720: PUSH
35721: LD_INT 1
35723: PUSH
35724: LD_INT 2
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: PUSH
35731: LD_INT 1
35733: NEG
35734: PUSH
35735: LD_INT 1
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: LD_INT 2
35744: NEG
35745: PUSH
35746: LD_INT 0
35748: PUSH
35749: EMPTY
35750: LIST
35751: LIST
35752: PUSH
35753: LD_INT 2
35755: NEG
35756: PUSH
35757: LD_INT 1
35759: NEG
35760: PUSH
35761: EMPTY
35762: LIST
35763: LIST
35764: PUSH
35765: LD_INT 1
35767: NEG
35768: PUSH
35769: LD_INT 3
35771: NEG
35772: PUSH
35773: EMPTY
35774: LIST
35775: LIST
35776: PUSH
35777: LD_INT 1
35779: PUSH
35780: LD_INT 2
35782: NEG
35783: PUSH
35784: EMPTY
35785: LIST
35786: LIST
35787: PUSH
35788: LD_INT 3
35790: PUSH
35791: LD_INT 2
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 2
35800: PUSH
35801: LD_INT 3
35803: PUSH
35804: EMPTY
35805: LIST
35806: LIST
35807: PUSH
35808: LD_INT 2
35810: NEG
35811: PUSH
35812: LD_INT 1
35814: PUSH
35815: EMPTY
35816: LIST
35817: LIST
35818: PUSH
35819: LD_INT 3
35821: NEG
35822: PUSH
35823: LD_INT 1
35825: NEG
35826: PUSH
35827: EMPTY
35828: LIST
35829: LIST
35830: PUSH
35831: EMPTY
35832: LIST
35833: LIST
35834: LIST
35835: LIST
35836: LIST
35837: LIST
35838: LIST
35839: LIST
35840: LIST
35841: LIST
35842: LIST
35843: LIST
35844: LIST
35845: LIST
35846: LIST
35847: LIST
35848: LIST
35849: LIST
35850: LIST
35851: LIST
35852: LIST
35853: LIST
35854: LIST
35855: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35856: LD_ADDR_VAR 0 31
35860: PUSH
35861: LD_INT 0
35863: PUSH
35864: LD_INT 0
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: PUSH
35871: LD_INT 0
35873: PUSH
35874: LD_INT 1
35876: NEG
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 1
35884: PUSH
35885: LD_INT 0
35887: PUSH
35888: EMPTY
35889: LIST
35890: LIST
35891: PUSH
35892: LD_INT 1
35894: PUSH
35895: LD_INT 1
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: LD_INT 0
35904: PUSH
35905: LD_INT 1
35907: PUSH
35908: EMPTY
35909: LIST
35910: LIST
35911: PUSH
35912: LD_INT 1
35914: NEG
35915: PUSH
35916: LD_INT 0
35918: PUSH
35919: EMPTY
35920: LIST
35921: LIST
35922: PUSH
35923: LD_INT 1
35925: NEG
35926: PUSH
35927: LD_INT 1
35929: NEG
35930: PUSH
35931: EMPTY
35932: LIST
35933: LIST
35934: PUSH
35935: LD_INT 1
35937: NEG
35938: PUSH
35939: LD_INT 2
35941: NEG
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 1
35949: PUSH
35950: LD_INT 1
35952: NEG
35953: PUSH
35954: EMPTY
35955: LIST
35956: LIST
35957: PUSH
35958: LD_INT 2
35960: PUSH
35961: LD_INT 0
35963: PUSH
35964: EMPTY
35965: LIST
35966: LIST
35967: PUSH
35968: LD_INT 2
35970: PUSH
35971: LD_INT 1
35973: PUSH
35974: EMPTY
35975: LIST
35976: LIST
35977: PUSH
35978: LD_INT 2
35980: PUSH
35981: LD_INT 2
35983: PUSH
35984: EMPTY
35985: LIST
35986: LIST
35987: PUSH
35988: LD_INT 1
35990: PUSH
35991: LD_INT 2
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: PUSH
35998: LD_INT 0
36000: PUSH
36001: LD_INT 2
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: LD_INT 1
36010: NEG
36011: PUSH
36012: LD_INT 1
36014: PUSH
36015: EMPTY
36016: LIST
36017: LIST
36018: PUSH
36019: LD_INT 2
36021: NEG
36022: PUSH
36023: LD_INT 1
36025: NEG
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: LD_INT 2
36033: NEG
36034: PUSH
36035: LD_INT 2
36037: NEG
36038: PUSH
36039: EMPTY
36040: LIST
36041: LIST
36042: PUSH
36043: LD_INT 2
36045: NEG
36046: PUSH
36047: LD_INT 3
36049: NEG
36050: PUSH
36051: EMPTY
36052: LIST
36053: LIST
36054: PUSH
36055: LD_INT 2
36057: PUSH
36058: LD_INT 1
36060: NEG
36061: PUSH
36062: EMPTY
36063: LIST
36064: LIST
36065: PUSH
36066: LD_INT 3
36068: PUSH
36069: LD_INT 1
36071: PUSH
36072: EMPTY
36073: LIST
36074: LIST
36075: PUSH
36076: LD_INT 1
36078: PUSH
36079: LD_INT 3
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: PUSH
36086: LD_INT 1
36088: NEG
36089: PUSH
36090: LD_INT 2
36092: PUSH
36093: EMPTY
36094: LIST
36095: LIST
36096: PUSH
36097: LD_INT 3
36099: NEG
36100: PUSH
36101: LD_INT 2
36103: NEG
36104: PUSH
36105: EMPTY
36106: LIST
36107: LIST
36108: PUSH
36109: EMPTY
36110: LIST
36111: LIST
36112: LIST
36113: LIST
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: LIST
36122: LIST
36123: LIST
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: LIST
36133: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36134: LD_ADDR_VAR 0 32
36138: PUSH
36139: LD_INT 0
36141: PUSH
36142: LD_INT 0
36144: PUSH
36145: EMPTY
36146: LIST
36147: LIST
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: LD_INT 1
36154: NEG
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: LD_INT 1
36162: PUSH
36163: LD_INT 0
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: PUSH
36170: LD_INT 1
36172: PUSH
36173: LD_INT 1
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PUSH
36180: LD_INT 0
36182: PUSH
36183: LD_INT 1
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: LD_INT 1
36192: NEG
36193: PUSH
36194: LD_INT 0
36196: PUSH
36197: EMPTY
36198: LIST
36199: LIST
36200: PUSH
36201: LD_INT 1
36203: NEG
36204: PUSH
36205: LD_INT 1
36207: NEG
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: PUSH
36213: LD_INT 1
36215: NEG
36216: PUSH
36217: LD_INT 2
36219: NEG
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: PUSH
36225: LD_INT 0
36227: PUSH
36228: LD_INT 2
36230: NEG
36231: PUSH
36232: EMPTY
36233: LIST
36234: LIST
36235: PUSH
36236: LD_INT 1
36238: PUSH
36239: LD_INT 1
36241: NEG
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PUSH
36247: LD_INT 2
36249: PUSH
36250: LD_INT 1
36252: PUSH
36253: EMPTY
36254: LIST
36255: LIST
36256: PUSH
36257: LD_INT 2
36259: PUSH
36260: LD_INT 2
36262: PUSH
36263: EMPTY
36264: LIST
36265: LIST
36266: PUSH
36267: LD_INT 1
36269: PUSH
36270: LD_INT 2
36272: PUSH
36273: EMPTY
36274: LIST
36275: LIST
36276: PUSH
36277: LD_INT 0
36279: PUSH
36280: LD_INT 2
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 1
36289: NEG
36290: PUSH
36291: LD_INT 1
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PUSH
36298: LD_INT 2
36300: NEG
36301: PUSH
36302: LD_INT 0
36304: PUSH
36305: EMPTY
36306: LIST
36307: LIST
36308: PUSH
36309: LD_INT 2
36311: NEG
36312: PUSH
36313: LD_INT 1
36315: NEG
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: LD_INT 1
36323: NEG
36324: PUSH
36325: LD_INT 3
36327: NEG
36328: PUSH
36329: EMPTY
36330: LIST
36331: LIST
36332: PUSH
36333: LD_INT 1
36335: PUSH
36336: LD_INT 2
36338: NEG
36339: PUSH
36340: EMPTY
36341: LIST
36342: LIST
36343: PUSH
36344: LD_INT 3
36346: PUSH
36347: LD_INT 2
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: LD_INT 2
36356: PUSH
36357: LD_INT 3
36359: PUSH
36360: EMPTY
36361: LIST
36362: LIST
36363: PUSH
36364: LD_INT 2
36366: NEG
36367: PUSH
36368: LD_INT 1
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: PUSH
36375: LD_INT 3
36377: NEG
36378: PUSH
36379: LD_INT 1
36381: NEG
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PUSH
36387: EMPTY
36388: LIST
36389: LIST
36390: LIST
36391: LIST
36392: LIST
36393: LIST
36394: LIST
36395: LIST
36396: LIST
36397: LIST
36398: LIST
36399: LIST
36400: LIST
36401: LIST
36402: LIST
36403: LIST
36404: LIST
36405: LIST
36406: LIST
36407: LIST
36408: LIST
36409: LIST
36410: LIST
36411: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
36412: LD_ADDR_VAR 0 33
36416: PUSH
36417: LD_INT 0
36419: PUSH
36420: LD_INT 0
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: LD_INT 1
36432: NEG
36433: PUSH
36434: EMPTY
36435: LIST
36436: LIST
36437: PUSH
36438: LD_INT 1
36440: PUSH
36441: LD_INT 0
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: PUSH
36448: LD_INT 1
36450: PUSH
36451: LD_INT 1
36453: PUSH
36454: EMPTY
36455: LIST
36456: LIST
36457: PUSH
36458: LD_INT 0
36460: PUSH
36461: LD_INT 1
36463: PUSH
36464: EMPTY
36465: LIST
36466: LIST
36467: PUSH
36468: LD_INT 1
36470: NEG
36471: PUSH
36472: LD_INT 0
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: PUSH
36479: LD_INT 1
36481: NEG
36482: PUSH
36483: LD_INT 1
36485: NEG
36486: PUSH
36487: EMPTY
36488: LIST
36489: LIST
36490: PUSH
36491: LD_INT 1
36493: NEG
36494: PUSH
36495: LD_INT 2
36497: NEG
36498: PUSH
36499: EMPTY
36500: LIST
36501: LIST
36502: PUSH
36503: LD_INT 1
36505: PUSH
36506: LD_INT 1
36508: NEG
36509: PUSH
36510: EMPTY
36511: LIST
36512: LIST
36513: PUSH
36514: LD_INT 2
36516: PUSH
36517: LD_INT 0
36519: PUSH
36520: EMPTY
36521: LIST
36522: LIST
36523: PUSH
36524: LD_INT 2
36526: PUSH
36527: LD_INT 1
36529: PUSH
36530: EMPTY
36531: LIST
36532: LIST
36533: PUSH
36534: LD_INT 1
36536: PUSH
36537: LD_INT 2
36539: PUSH
36540: EMPTY
36541: LIST
36542: LIST
36543: PUSH
36544: LD_INT 0
36546: PUSH
36547: LD_INT 2
36549: PUSH
36550: EMPTY
36551: LIST
36552: LIST
36553: PUSH
36554: LD_INT 1
36556: NEG
36557: PUSH
36558: LD_INT 1
36560: PUSH
36561: EMPTY
36562: LIST
36563: LIST
36564: PUSH
36565: LD_INT 2
36567: NEG
36568: PUSH
36569: LD_INT 0
36571: PUSH
36572: EMPTY
36573: LIST
36574: LIST
36575: PUSH
36576: LD_INT 2
36578: NEG
36579: PUSH
36580: LD_INT 1
36582: NEG
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: PUSH
36588: LD_INT 2
36590: NEG
36591: PUSH
36592: LD_INT 2
36594: NEG
36595: PUSH
36596: EMPTY
36597: LIST
36598: LIST
36599: PUSH
36600: LD_INT 2
36602: NEG
36603: PUSH
36604: LD_INT 3
36606: NEG
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: LD_INT 2
36614: PUSH
36615: LD_INT 1
36617: NEG
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: PUSH
36623: LD_INT 3
36625: PUSH
36626: LD_INT 1
36628: PUSH
36629: EMPTY
36630: LIST
36631: LIST
36632: PUSH
36633: LD_INT 1
36635: PUSH
36636: LD_INT 3
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: LD_INT 1
36645: NEG
36646: PUSH
36647: LD_INT 2
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 3
36656: NEG
36657: PUSH
36658: LD_INT 2
36660: NEG
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: PUSH
36666: EMPTY
36667: LIST
36668: LIST
36669: LIST
36670: LIST
36671: LIST
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: LIST
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: LIST
36687: LIST
36688: LIST
36689: LIST
36690: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36691: LD_ADDR_VAR 0 34
36695: PUSH
36696: LD_INT 0
36698: PUSH
36699: LD_INT 0
36701: PUSH
36702: EMPTY
36703: LIST
36704: LIST
36705: PUSH
36706: LD_INT 0
36708: PUSH
36709: LD_INT 1
36711: NEG
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: PUSH
36717: LD_INT 1
36719: PUSH
36720: LD_INT 0
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 1
36729: PUSH
36730: LD_INT 1
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: PUSH
36737: LD_INT 0
36739: PUSH
36740: LD_INT 1
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PUSH
36747: LD_INT 1
36749: NEG
36750: PUSH
36751: LD_INT 0
36753: PUSH
36754: EMPTY
36755: LIST
36756: LIST
36757: PUSH
36758: LD_INT 1
36760: NEG
36761: PUSH
36762: LD_INT 1
36764: NEG
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: PUSH
36770: LD_INT 1
36772: NEG
36773: PUSH
36774: LD_INT 2
36776: NEG
36777: PUSH
36778: EMPTY
36779: LIST
36780: LIST
36781: PUSH
36782: LD_INT 0
36784: PUSH
36785: LD_INT 2
36787: NEG
36788: PUSH
36789: EMPTY
36790: LIST
36791: LIST
36792: PUSH
36793: LD_INT 1
36795: PUSH
36796: LD_INT 1
36798: NEG
36799: PUSH
36800: EMPTY
36801: LIST
36802: LIST
36803: PUSH
36804: LD_INT 2
36806: PUSH
36807: LD_INT 1
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PUSH
36814: LD_INT 2
36816: PUSH
36817: LD_INT 2
36819: PUSH
36820: EMPTY
36821: LIST
36822: LIST
36823: PUSH
36824: LD_INT 1
36826: PUSH
36827: LD_INT 2
36829: PUSH
36830: EMPTY
36831: LIST
36832: LIST
36833: PUSH
36834: LD_INT 1
36836: NEG
36837: PUSH
36838: LD_INT 1
36840: PUSH
36841: EMPTY
36842: LIST
36843: LIST
36844: PUSH
36845: LD_INT 2
36847: NEG
36848: PUSH
36849: LD_INT 0
36851: PUSH
36852: EMPTY
36853: LIST
36854: LIST
36855: PUSH
36856: LD_INT 2
36858: NEG
36859: PUSH
36860: LD_INT 1
36862: NEG
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: LD_INT 2
36870: NEG
36871: PUSH
36872: LD_INT 2
36874: NEG
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: LD_INT 1
36882: NEG
36883: PUSH
36884: LD_INT 3
36886: NEG
36887: PUSH
36888: EMPTY
36889: LIST
36890: LIST
36891: PUSH
36892: LD_INT 1
36894: PUSH
36895: LD_INT 2
36897: NEG
36898: PUSH
36899: EMPTY
36900: LIST
36901: LIST
36902: PUSH
36903: LD_INT 3
36905: PUSH
36906: LD_INT 2
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: PUSH
36913: LD_INT 2
36915: PUSH
36916: LD_INT 3
36918: PUSH
36919: EMPTY
36920: LIST
36921: LIST
36922: PUSH
36923: LD_INT 2
36925: NEG
36926: PUSH
36927: LD_INT 1
36929: PUSH
36930: EMPTY
36931: LIST
36932: LIST
36933: PUSH
36934: LD_INT 3
36936: NEG
36937: PUSH
36938: LD_INT 1
36940: NEG
36941: PUSH
36942: EMPTY
36943: LIST
36944: LIST
36945: PUSH
36946: EMPTY
36947: LIST
36948: LIST
36949: LIST
36950: LIST
36951: LIST
36952: LIST
36953: LIST
36954: LIST
36955: LIST
36956: LIST
36957: LIST
36958: LIST
36959: LIST
36960: LIST
36961: LIST
36962: LIST
36963: LIST
36964: LIST
36965: LIST
36966: LIST
36967: LIST
36968: LIST
36969: LIST
36970: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36971: LD_ADDR_VAR 0 35
36975: PUSH
36976: LD_INT 0
36978: PUSH
36979: LD_INT 0
36981: PUSH
36982: EMPTY
36983: LIST
36984: LIST
36985: PUSH
36986: LD_INT 0
36988: PUSH
36989: LD_INT 1
36991: NEG
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: PUSH
36997: LD_INT 1
36999: PUSH
37000: LD_INT 0
37002: PUSH
37003: EMPTY
37004: LIST
37005: LIST
37006: PUSH
37007: LD_INT 1
37009: PUSH
37010: LD_INT 1
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: PUSH
37017: LD_INT 0
37019: PUSH
37020: LD_INT 1
37022: PUSH
37023: EMPTY
37024: LIST
37025: LIST
37026: PUSH
37027: LD_INT 1
37029: NEG
37030: PUSH
37031: LD_INT 0
37033: PUSH
37034: EMPTY
37035: LIST
37036: LIST
37037: PUSH
37038: LD_INT 1
37040: NEG
37041: PUSH
37042: LD_INT 1
37044: NEG
37045: PUSH
37046: EMPTY
37047: LIST
37048: LIST
37049: PUSH
37050: LD_INT 2
37052: PUSH
37053: LD_INT 1
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 2
37062: NEG
37063: PUSH
37064: LD_INT 1
37066: NEG
37067: PUSH
37068: EMPTY
37069: LIST
37070: LIST
37071: PUSH
37072: EMPTY
37073: LIST
37074: LIST
37075: LIST
37076: LIST
37077: LIST
37078: LIST
37079: LIST
37080: LIST
37081: LIST
37082: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
37083: LD_ADDR_VAR 0 36
37087: PUSH
37088: LD_INT 0
37090: PUSH
37091: LD_INT 0
37093: PUSH
37094: EMPTY
37095: LIST
37096: LIST
37097: PUSH
37098: LD_INT 0
37100: PUSH
37101: LD_INT 1
37103: NEG
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: LD_INT 1
37111: PUSH
37112: LD_INT 0
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: LD_INT 1
37121: PUSH
37122: LD_INT 1
37124: PUSH
37125: EMPTY
37126: LIST
37127: LIST
37128: PUSH
37129: LD_INT 0
37131: PUSH
37132: LD_INT 1
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: PUSH
37139: LD_INT 1
37141: NEG
37142: PUSH
37143: LD_INT 0
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PUSH
37150: LD_INT 1
37152: NEG
37153: PUSH
37154: LD_INT 1
37156: NEG
37157: PUSH
37158: EMPTY
37159: LIST
37160: LIST
37161: PUSH
37162: LD_INT 1
37164: NEG
37165: PUSH
37166: LD_INT 2
37168: NEG
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 1
37176: PUSH
37177: LD_INT 2
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: EMPTY
37185: LIST
37186: LIST
37187: LIST
37188: LIST
37189: LIST
37190: LIST
37191: LIST
37192: LIST
37193: LIST
37194: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
37195: LD_ADDR_VAR 0 37
37199: PUSH
37200: LD_INT 0
37202: PUSH
37203: LD_INT 0
37205: PUSH
37206: EMPTY
37207: LIST
37208: LIST
37209: PUSH
37210: LD_INT 0
37212: PUSH
37213: LD_INT 1
37215: NEG
37216: PUSH
37217: EMPTY
37218: LIST
37219: LIST
37220: PUSH
37221: LD_INT 1
37223: PUSH
37224: LD_INT 0
37226: PUSH
37227: EMPTY
37228: LIST
37229: LIST
37230: PUSH
37231: LD_INT 1
37233: PUSH
37234: LD_INT 1
37236: PUSH
37237: EMPTY
37238: LIST
37239: LIST
37240: PUSH
37241: LD_INT 0
37243: PUSH
37244: LD_INT 1
37246: PUSH
37247: EMPTY
37248: LIST
37249: LIST
37250: PUSH
37251: LD_INT 1
37253: NEG
37254: PUSH
37255: LD_INT 0
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PUSH
37262: LD_INT 1
37264: NEG
37265: PUSH
37266: LD_INT 1
37268: NEG
37269: PUSH
37270: EMPTY
37271: LIST
37272: LIST
37273: PUSH
37274: LD_INT 1
37276: PUSH
37277: LD_INT 1
37279: NEG
37280: PUSH
37281: EMPTY
37282: LIST
37283: LIST
37284: PUSH
37285: LD_INT 1
37287: NEG
37288: PUSH
37289: LD_INT 1
37291: PUSH
37292: EMPTY
37293: LIST
37294: LIST
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: LIST
37300: LIST
37301: LIST
37302: LIST
37303: LIST
37304: LIST
37305: LIST
37306: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
37307: LD_ADDR_VAR 0 38
37311: PUSH
37312: LD_INT 0
37314: PUSH
37315: LD_INT 0
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 0
37324: PUSH
37325: LD_INT 1
37327: NEG
37328: PUSH
37329: EMPTY
37330: LIST
37331: LIST
37332: PUSH
37333: LD_INT 1
37335: PUSH
37336: LD_INT 0
37338: PUSH
37339: EMPTY
37340: LIST
37341: LIST
37342: PUSH
37343: LD_INT 1
37345: PUSH
37346: LD_INT 1
37348: PUSH
37349: EMPTY
37350: LIST
37351: LIST
37352: PUSH
37353: LD_INT 0
37355: PUSH
37356: LD_INT 1
37358: PUSH
37359: EMPTY
37360: LIST
37361: LIST
37362: PUSH
37363: LD_INT 1
37365: NEG
37366: PUSH
37367: LD_INT 0
37369: PUSH
37370: EMPTY
37371: LIST
37372: LIST
37373: PUSH
37374: LD_INT 1
37376: NEG
37377: PUSH
37378: LD_INT 1
37380: NEG
37381: PUSH
37382: EMPTY
37383: LIST
37384: LIST
37385: PUSH
37386: LD_INT 2
37388: PUSH
37389: LD_INT 1
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: LD_INT 2
37398: NEG
37399: PUSH
37400: LD_INT 1
37402: NEG
37403: PUSH
37404: EMPTY
37405: LIST
37406: LIST
37407: PUSH
37408: EMPTY
37409: LIST
37410: LIST
37411: LIST
37412: LIST
37413: LIST
37414: LIST
37415: LIST
37416: LIST
37417: LIST
37418: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
37419: LD_ADDR_VAR 0 39
37423: PUSH
37424: LD_INT 0
37426: PUSH
37427: LD_INT 0
37429: PUSH
37430: EMPTY
37431: LIST
37432: LIST
37433: PUSH
37434: LD_INT 0
37436: PUSH
37437: LD_INT 1
37439: NEG
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: PUSH
37445: LD_INT 1
37447: PUSH
37448: LD_INT 0
37450: PUSH
37451: EMPTY
37452: LIST
37453: LIST
37454: PUSH
37455: LD_INT 1
37457: PUSH
37458: LD_INT 1
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: PUSH
37465: LD_INT 0
37467: PUSH
37468: LD_INT 1
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PUSH
37475: LD_INT 1
37477: NEG
37478: PUSH
37479: LD_INT 0
37481: PUSH
37482: EMPTY
37483: LIST
37484: LIST
37485: PUSH
37486: LD_INT 1
37488: NEG
37489: PUSH
37490: LD_INT 1
37492: NEG
37493: PUSH
37494: EMPTY
37495: LIST
37496: LIST
37497: PUSH
37498: LD_INT 1
37500: NEG
37501: PUSH
37502: LD_INT 2
37504: NEG
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 1
37512: PUSH
37513: LD_INT 2
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: PUSH
37520: EMPTY
37521: LIST
37522: LIST
37523: LIST
37524: LIST
37525: LIST
37526: LIST
37527: LIST
37528: LIST
37529: LIST
37530: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
37531: LD_ADDR_VAR 0 40
37535: PUSH
37536: LD_INT 0
37538: PUSH
37539: LD_INT 0
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: PUSH
37546: LD_INT 0
37548: PUSH
37549: LD_INT 1
37551: NEG
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 1
37559: PUSH
37560: LD_INT 0
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: PUSH
37567: LD_INT 1
37569: PUSH
37570: LD_INT 1
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: PUSH
37577: LD_INT 0
37579: PUSH
37580: LD_INT 1
37582: PUSH
37583: EMPTY
37584: LIST
37585: LIST
37586: PUSH
37587: LD_INT 1
37589: NEG
37590: PUSH
37591: LD_INT 0
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: PUSH
37598: LD_INT 1
37600: NEG
37601: PUSH
37602: LD_INT 1
37604: NEG
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 1
37612: PUSH
37613: LD_INT 1
37615: NEG
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 1
37623: NEG
37624: PUSH
37625: LD_INT 1
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: LIST
37636: LIST
37637: LIST
37638: LIST
37639: LIST
37640: LIST
37641: LIST
37642: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37643: LD_ADDR_VAR 0 41
37647: PUSH
37648: LD_INT 0
37650: PUSH
37651: LD_INT 0
37653: PUSH
37654: EMPTY
37655: LIST
37656: LIST
37657: PUSH
37658: LD_INT 0
37660: PUSH
37661: LD_INT 1
37663: NEG
37664: PUSH
37665: EMPTY
37666: LIST
37667: LIST
37668: PUSH
37669: LD_INT 1
37671: PUSH
37672: LD_INT 0
37674: PUSH
37675: EMPTY
37676: LIST
37677: LIST
37678: PUSH
37679: LD_INT 1
37681: PUSH
37682: LD_INT 1
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: PUSH
37689: LD_INT 0
37691: PUSH
37692: LD_INT 1
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PUSH
37699: LD_INT 1
37701: NEG
37702: PUSH
37703: LD_INT 0
37705: PUSH
37706: EMPTY
37707: LIST
37708: LIST
37709: PUSH
37710: LD_INT 1
37712: NEG
37713: PUSH
37714: LD_INT 1
37716: NEG
37717: PUSH
37718: EMPTY
37719: LIST
37720: LIST
37721: PUSH
37722: LD_INT 1
37724: NEG
37725: PUSH
37726: LD_INT 2
37728: NEG
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 1
37736: PUSH
37737: LD_INT 1
37739: NEG
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: LD_INT 2
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 2
37757: PUSH
37758: LD_INT 1
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: PUSH
37765: LD_INT 2
37767: PUSH
37768: LD_INT 2
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 1
37777: PUSH
37778: LD_INT 2
37780: PUSH
37781: EMPTY
37782: LIST
37783: LIST
37784: PUSH
37785: LD_INT 1
37787: NEG
37788: PUSH
37789: LD_INT 1
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: PUSH
37796: LD_INT 2
37798: NEG
37799: PUSH
37800: LD_INT 0
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: LD_INT 2
37809: NEG
37810: PUSH
37811: LD_INT 1
37813: NEG
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: LD_INT 2
37821: NEG
37822: PUSH
37823: LD_INT 2
37825: NEG
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 2
37833: NEG
37834: PUSH
37835: LD_INT 3
37837: NEG
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 2
37845: PUSH
37846: LD_INT 1
37848: NEG
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 3
37856: PUSH
37857: LD_INT 0
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: PUSH
37864: LD_INT 3
37866: PUSH
37867: LD_INT 1
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 3
37876: PUSH
37877: LD_INT 2
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 3
37886: PUSH
37887: LD_INT 3
37889: PUSH
37890: EMPTY
37891: LIST
37892: LIST
37893: PUSH
37894: LD_INT 2
37896: PUSH
37897: LD_INT 3
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: LD_INT 2
37906: NEG
37907: PUSH
37908: LD_INT 1
37910: PUSH
37911: EMPTY
37912: LIST
37913: LIST
37914: PUSH
37915: LD_INT 3
37917: NEG
37918: PUSH
37919: LD_INT 0
37921: PUSH
37922: EMPTY
37923: LIST
37924: LIST
37925: PUSH
37926: LD_INT 3
37928: NEG
37929: PUSH
37930: LD_INT 1
37932: NEG
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PUSH
37938: LD_INT 3
37940: NEG
37941: PUSH
37942: LD_INT 2
37944: NEG
37945: PUSH
37946: EMPTY
37947: LIST
37948: LIST
37949: PUSH
37950: LD_INT 3
37952: NEG
37953: PUSH
37954: LD_INT 3
37956: NEG
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: PUSH
37962: EMPTY
37963: LIST
37964: LIST
37965: LIST
37966: LIST
37967: LIST
37968: LIST
37969: LIST
37970: LIST
37971: LIST
37972: LIST
37973: LIST
37974: LIST
37975: LIST
37976: LIST
37977: LIST
37978: LIST
37979: LIST
37980: LIST
37981: LIST
37982: LIST
37983: LIST
37984: LIST
37985: LIST
37986: LIST
37987: LIST
37988: LIST
37989: LIST
37990: LIST
37991: LIST
37992: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37993: LD_ADDR_VAR 0 42
37997: PUSH
37998: LD_INT 0
38000: PUSH
38001: LD_INT 0
38003: PUSH
38004: EMPTY
38005: LIST
38006: LIST
38007: PUSH
38008: LD_INT 0
38010: PUSH
38011: LD_INT 1
38013: NEG
38014: PUSH
38015: EMPTY
38016: LIST
38017: LIST
38018: PUSH
38019: LD_INT 1
38021: PUSH
38022: LD_INT 0
38024: PUSH
38025: EMPTY
38026: LIST
38027: LIST
38028: PUSH
38029: LD_INT 1
38031: PUSH
38032: LD_INT 1
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: LD_INT 0
38041: PUSH
38042: LD_INT 1
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: PUSH
38049: LD_INT 1
38051: NEG
38052: PUSH
38053: LD_INT 0
38055: PUSH
38056: EMPTY
38057: LIST
38058: LIST
38059: PUSH
38060: LD_INT 1
38062: NEG
38063: PUSH
38064: LD_INT 1
38066: NEG
38067: PUSH
38068: EMPTY
38069: LIST
38070: LIST
38071: PUSH
38072: LD_INT 1
38074: NEG
38075: PUSH
38076: LD_INT 2
38078: NEG
38079: PUSH
38080: EMPTY
38081: LIST
38082: LIST
38083: PUSH
38084: LD_INT 0
38086: PUSH
38087: LD_INT 2
38089: NEG
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: LD_INT 1
38097: PUSH
38098: LD_INT 1
38100: NEG
38101: PUSH
38102: EMPTY
38103: LIST
38104: LIST
38105: PUSH
38106: LD_INT 2
38108: PUSH
38109: LD_INT 1
38111: PUSH
38112: EMPTY
38113: LIST
38114: LIST
38115: PUSH
38116: LD_INT 2
38118: PUSH
38119: LD_INT 2
38121: PUSH
38122: EMPTY
38123: LIST
38124: LIST
38125: PUSH
38126: LD_INT 1
38128: PUSH
38129: LD_INT 2
38131: PUSH
38132: EMPTY
38133: LIST
38134: LIST
38135: PUSH
38136: LD_INT 0
38138: PUSH
38139: LD_INT 2
38141: PUSH
38142: EMPTY
38143: LIST
38144: LIST
38145: PUSH
38146: LD_INT 1
38148: NEG
38149: PUSH
38150: LD_INT 1
38152: PUSH
38153: EMPTY
38154: LIST
38155: LIST
38156: PUSH
38157: LD_INT 2
38159: NEG
38160: PUSH
38161: LD_INT 1
38163: NEG
38164: PUSH
38165: EMPTY
38166: LIST
38167: LIST
38168: PUSH
38169: LD_INT 2
38171: NEG
38172: PUSH
38173: LD_INT 2
38175: NEG
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: LD_INT 2
38183: NEG
38184: PUSH
38185: LD_INT 3
38187: NEG
38188: PUSH
38189: EMPTY
38190: LIST
38191: LIST
38192: PUSH
38193: LD_INT 1
38195: NEG
38196: PUSH
38197: LD_INT 3
38199: NEG
38200: PUSH
38201: EMPTY
38202: LIST
38203: LIST
38204: PUSH
38205: LD_INT 0
38207: PUSH
38208: LD_INT 3
38210: NEG
38211: PUSH
38212: EMPTY
38213: LIST
38214: LIST
38215: PUSH
38216: LD_INT 1
38218: PUSH
38219: LD_INT 2
38221: NEG
38222: PUSH
38223: EMPTY
38224: LIST
38225: LIST
38226: PUSH
38227: LD_INT 3
38229: PUSH
38230: LD_INT 2
38232: PUSH
38233: EMPTY
38234: LIST
38235: LIST
38236: PUSH
38237: LD_INT 3
38239: PUSH
38240: LD_INT 3
38242: PUSH
38243: EMPTY
38244: LIST
38245: LIST
38246: PUSH
38247: LD_INT 2
38249: PUSH
38250: LD_INT 3
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: PUSH
38257: LD_INT 1
38259: PUSH
38260: LD_INT 3
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 0
38269: PUSH
38270: LD_INT 3
38272: PUSH
38273: EMPTY
38274: LIST
38275: LIST
38276: PUSH
38277: LD_INT 1
38279: NEG
38280: PUSH
38281: LD_INT 2
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 3
38290: NEG
38291: PUSH
38292: LD_INT 2
38294: NEG
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 3
38302: NEG
38303: PUSH
38304: LD_INT 3
38306: NEG
38307: PUSH
38308: EMPTY
38309: LIST
38310: LIST
38311: PUSH
38312: EMPTY
38313: LIST
38314: LIST
38315: LIST
38316: LIST
38317: LIST
38318: LIST
38319: LIST
38320: LIST
38321: LIST
38322: LIST
38323: LIST
38324: LIST
38325: LIST
38326: LIST
38327: LIST
38328: LIST
38329: LIST
38330: LIST
38331: LIST
38332: LIST
38333: LIST
38334: LIST
38335: LIST
38336: LIST
38337: LIST
38338: LIST
38339: LIST
38340: LIST
38341: LIST
38342: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38343: LD_ADDR_VAR 0 43
38347: PUSH
38348: LD_INT 0
38350: PUSH
38351: LD_INT 0
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PUSH
38358: LD_INT 0
38360: PUSH
38361: LD_INT 1
38363: NEG
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: PUSH
38369: LD_INT 1
38371: PUSH
38372: LD_INT 0
38374: PUSH
38375: EMPTY
38376: LIST
38377: LIST
38378: PUSH
38379: LD_INT 1
38381: PUSH
38382: LD_INT 1
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PUSH
38389: LD_INT 0
38391: PUSH
38392: LD_INT 1
38394: PUSH
38395: EMPTY
38396: LIST
38397: LIST
38398: PUSH
38399: LD_INT 1
38401: NEG
38402: PUSH
38403: LD_INT 0
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 1
38412: NEG
38413: PUSH
38414: LD_INT 1
38416: NEG
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: LD_INT 1
38424: NEG
38425: PUSH
38426: LD_INT 2
38428: NEG
38429: PUSH
38430: EMPTY
38431: LIST
38432: LIST
38433: PUSH
38434: LD_INT 0
38436: PUSH
38437: LD_INT 2
38439: NEG
38440: PUSH
38441: EMPTY
38442: LIST
38443: LIST
38444: PUSH
38445: LD_INT 1
38447: PUSH
38448: LD_INT 1
38450: NEG
38451: PUSH
38452: EMPTY
38453: LIST
38454: LIST
38455: PUSH
38456: LD_INT 2
38458: PUSH
38459: LD_INT 0
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: PUSH
38466: LD_INT 2
38468: PUSH
38469: LD_INT 1
38471: PUSH
38472: EMPTY
38473: LIST
38474: LIST
38475: PUSH
38476: LD_INT 1
38478: PUSH
38479: LD_INT 2
38481: PUSH
38482: EMPTY
38483: LIST
38484: LIST
38485: PUSH
38486: LD_INT 0
38488: PUSH
38489: LD_INT 2
38491: PUSH
38492: EMPTY
38493: LIST
38494: LIST
38495: PUSH
38496: LD_INT 1
38498: NEG
38499: PUSH
38500: LD_INT 1
38502: PUSH
38503: EMPTY
38504: LIST
38505: LIST
38506: PUSH
38507: LD_INT 2
38509: NEG
38510: PUSH
38511: LD_INT 0
38513: PUSH
38514: EMPTY
38515: LIST
38516: LIST
38517: PUSH
38518: LD_INT 2
38520: NEG
38521: PUSH
38522: LD_INT 1
38524: NEG
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: LD_INT 1
38532: NEG
38533: PUSH
38534: LD_INT 3
38536: NEG
38537: PUSH
38538: EMPTY
38539: LIST
38540: LIST
38541: PUSH
38542: LD_INT 0
38544: PUSH
38545: LD_INT 3
38547: NEG
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: LD_INT 1
38555: PUSH
38556: LD_INT 2
38558: NEG
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: LD_INT 2
38566: PUSH
38567: LD_INT 1
38569: NEG
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: PUSH
38575: LD_INT 3
38577: PUSH
38578: LD_INT 0
38580: PUSH
38581: EMPTY
38582: LIST
38583: LIST
38584: PUSH
38585: LD_INT 3
38587: PUSH
38588: LD_INT 1
38590: PUSH
38591: EMPTY
38592: LIST
38593: LIST
38594: PUSH
38595: LD_INT 1
38597: PUSH
38598: LD_INT 3
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 0
38607: PUSH
38608: LD_INT 3
38610: PUSH
38611: EMPTY
38612: LIST
38613: LIST
38614: PUSH
38615: LD_INT 1
38617: NEG
38618: PUSH
38619: LD_INT 2
38621: PUSH
38622: EMPTY
38623: LIST
38624: LIST
38625: PUSH
38626: LD_INT 2
38628: NEG
38629: PUSH
38630: LD_INT 1
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 3
38639: NEG
38640: PUSH
38641: LD_INT 0
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: LD_INT 3
38650: NEG
38651: PUSH
38652: LD_INT 1
38654: NEG
38655: PUSH
38656: EMPTY
38657: LIST
38658: LIST
38659: PUSH
38660: EMPTY
38661: LIST
38662: LIST
38663: LIST
38664: LIST
38665: LIST
38666: LIST
38667: LIST
38668: LIST
38669: LIST
38670: LIST
38671: LIST
38672: LIST
38673: LIST
38674: LIST
38675: LIST
38676: LIST
38677: LIST
38678: LIST
38679: LIST
38680: LIST
38681: LIST
38682: LIST
38683: LIST
38684: LIST
38685: LIST
38686: LIST
38687: LIST
38688: LIST
38689: LIST
38690: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38691: LD_ADDR_VAR 0 44
38695: PUSH
38696: LD_INT 0
38698: PUSH
38699: LD_INT 0
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: LD_INT 0
38708: PUSH
38709: LD_INT 1
38711: NEG
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: PUSH
38717: LD_INT 1
38719: PUSH
38720: LD_INT 0
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: LD_INT 1
38729: PUSH
38730: LD_INT 1
38732: PUSH
38733: EMPTY
38734: LIST
38735: LIST
38736: PUSH
38737: LD_INT 0
38739: PUSH
38740: LD_INT 1
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 1
38749: NEG
38750: PUSH
38751: LD_INT 0
38753: PUSH
38754: EMPTY
38755: LIST
38756: LIST
38757: PUSH
38758: LD_INT 1
38760: NEG
38761: PUSH
38762: LD_INT 1
38764: NEG
38765: PUSH
38766: EMPTY
38767: LIST
38768: LIST
38769: PUSH
38770: LD_INT 1
38772: NEG
38773: PUSH
38774: LD_INT 2
38776: NEG
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: PUSH
38782: LD_INT 1
38784: PUSH
38785: LD_INT 1
38787: NEG
38788: PUSH
38789: EMPTY
38790: LIST
38791: LIST
38792: PUSH
38793: LD_INT 2
38795: PUSH
38796: LD_INT 0
38798: PUSH
38799: EMPTY
38800: LIST
38801: LIST
38802: PUSH
38803: LD_INT 2
38805: PUSH
38806: LD_INT 1
38808: PUSH
38809: EMPTY
38810: LIST
38811: LIST
38812: PUSH
38813: LD_INT 2
38815: PUSH
38816: LD_INT 2
38818: PUSH
38819: EMPTY
38820: LIST
38821: LIST
38822: PUSH
38823: LD_INT 1
38825: PUSH
38826: LD_INT 2
38828: PUSH
38829: EMPTY
38830: LIST
38831: LIST
38832: PUSH
38833: LD_INT 1
38835: NEG
38836: PUSH
38837: LD_INT 1
38839: PUSH
38840: EMPTY
38841: LIST
38842: LIST
38843: PUSH
38844: LD_INT 2
38846: NEG
38847: PUSH
38848: LD_INT 0
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: PUSH
38855: LD_INT 2
38857: NEG
38858: PUSH
38859: LD_INT 1
38861: NEG
38862: PUSH
38863: EMPTY
38864: LIST
38865: LIST
38866: PUSH
38867: LD_INT 2
38869: NEG
38870: PUSH
38871: LD_INT 2
38873: NEG
38874: PUSH
38875: EMPTY
38876: LIST
38877: LIST
38878: PUSH
38879: LD_INT 2
38881: NEG
38882: PUSH
38883: LD_INT 3
38885: NEG
38886: PUSH
38887: EMPTY
38888: LIST
38889: LIST
38890: PUSH
38891: LD_INT 2
38893: PUSH
38894: LD_INT 1
38896: NEG
38897: PUSH
38898: EMPTY
38899: LIST
38900: LIST
38901: PUSH
38902: LD_INT 3
38904: PUSH
38905: LD_INT 0
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: LD_INT 3
38914: PUSH
38915: LD_INT 1
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 3
38924: PUSH
38925: LD_INT 2
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: LD_INT 3
38934: PUSH
38935: LD_INT 3
38937: PUSH
38938: EMPTY
38939: LIST
38940: LIST
38941: PUSH
38942: LD_INT 2
38944: PUSH
38945: LD_INT 3
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 2
38954: NEG
38955: PUSH
38956: LD_INT 1
38958: PUSH
38959: EMPTY
38960: LIST
38961: LIST
38962: PUSH
38963: LD_INT 3
38965: NEG
38966: PUSH
38967: LD_INT 0
38969: PUSH
38970: EMPTY
38971: LIST
38972: LIST
38973: PUSH
38974: LD_INT 3
38976: NEG
38977: PUSH
38978: LD_INT 1
38980: NEG
38981: PUSH
38982: EMPTY
38983: LIST
38984: LIST
38985: PUSH
38986: LD_INT 3
38988: NEG
38989: PUSH
38990: LD_INT 2
38992: NEG
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 3
39000: NEG
39001: PUSH
39002: LD_INT 3
39004: NEG
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: PUSH
39010: EMPTY
39011: LIST
39012: LIST
39013: LIST
39014: LIST
39015: LIST
39016: LIST
39017: LIST
39018: LIST
39019: LIST
39020: LIST
39021: LIST
39022: LIST
39023: LIST
39024: LIST
39025: LIST
39026: LIST
39027: LIST
39028: LIST
39029: LIST
39030: LIST
39031: LIST
39032: LIST
39033: LIST
39034: LIST
39035: LIST
39036: LIST
39037: LIST
39038: LIST
39039: LIST
39040: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39041: LD_ADDR_VAR 0 45
39045: PUSH
39046: LD_INT 0
39048: PUSH
39049: LD_INT 0
39051: PUSH
39052: EMPTY
39053: LIST
39054: LIST
39055: PUSH
39056: LD_INT 0
39058: PUSH
39059: LD_INT 1
39061: NEG
39062: PUSH
39063: EMPTY
39064: LIST
39065: LIST
39066: PUSH
39067: LD_INT 1
39069: PUSH
39070: LD_INT 0
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: PUSH
39077: LD_INT 1
39079: PUSH
39080: LD_INT 1
39082: PUSH
39083: EMPTY
39084: LIST
39085: LIST
39086: PUSH
39087: LD_INT 0
39089: PUSH
39090: LD_INT 1
39092: PUSH
39093: EMPTY
39094: LIST
39095: LIST
39096: PUSH
39097: LD_INT 1
39099: NEG
39100: PUSH
39101: LD_INT 0
39103: PUSH
39104: EMPTY
39105: LIST
39106: LIST
39107: PUSH
39108: LD_INT 1
39110: NEG
39111: PUSH
39112: LD_INT 1
39114: NEG
39115: PUSH
39116: EMPTY
39117: LIST
39118: LIST
39119: PUSH
39120: LD_INT 1
39122: NEG
39123: PUSH
39124: LD_INT 2
39126: NEG
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: LD_INT 0
39134: PUSH
39135: LD_INT 2
39137: NEG
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PUSH
39143: LD_INT 1
39145: PUSH
39146: LD_INT 1
39148: NEG
39149: PUSH
39150: EMPTY
39151: LIST
39152: LIST
39153: PUSH
39154: LD_INT 2
39156: PUSH
39157: LD_INT 1
39159: PUSH
39160: EMPTY
39161: LIST
39162: LIST
39163: PUSH
39164: LD_INT 2
39166: PUSH
39167: LD_INT 2
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: PUSH
39174: LD_INT 1
39176: PUSH
39177: LD_INT 2
39179: PUSH
39180: EMPTY
39181: LIST
39182: LIST
39183: PUSH
39184: LD_INT 0
39186: PUSH
39187: LD_INT 2
39189: PUSH
39190: EMPTY
39191: LIST
39192: LIST
39193: PUSH
39194: LD_INT 1
39196: NEG
39197: PUSH
39198: LD_INT 1
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: PUSH
39205: LD_INT 2
39207: NEG
39208: PUSH
39209: LD_INT 1
39211: NEG
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: PUSH
39217: LD_INT 2
39219: NEG
39220: PUSH
39221: LD_INT 2
39223: NEG
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PUSH
39229: LD_INT 2
39231: NEG
39232: PUSH
39233: LD_INT 3
39235: NEG
39236: PUSH
39237: EMPTY
39238: LIST
39239: LIST
39240: PUSH
39241: LD_INT 1
39243: NEG
39244: PUSH
39245: LD_INT 3
39247: NEG
39248: PUSH
39249: EMPTY
39250: LIST
39251: LIST
39252: PUSH
39253: LD_INT 0
39255: PUSH
39256: LD_INT 3
39258: NEG
39259: PUSH
39260: EMPTY
39261: LIST
39262: LIST
39263: PUSH
39264: LD_INT 1
39266: PUSH
39267: LD_INT 2
39269: NEG
39270: PUSH
39271: EMPTY
39272: LIST
39273: LIST
39274: PUSH
39275: LD_INT 3
39277: PUSH
39278: LD_INT 2
39280: PUSH
39281: EMPTY
39282: LIST
39283: LIST
39284: PUSH
39285: LD_INT 3
39287: PUSH
39288: LD_INT 3
39290: PUSH
39291: EMPTY
39292: LIST
39293: LIST
39294: PUSH
39295: LD_INT 2
39297: PUSH
39298: LD_INT 3
39300: PUSH
39301: EMPTY
39302: LIST
39303: LIST
39304: PUSH
39305: LD_INT 1
39307: PUSH
39308: LD_INT 3
39310: PUSH
39311: EMPTY
39312: LIST
39313: LIST
39314: PUSH
39315: LD_INT 0
39317: PUSH
39318: LD_INT 3
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 1
39327: NEG
39328: PUSH
39329: LD_INT 2
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: PUSH
39336: LD_INT 3
39338: NEG
39339: PUSH
39340: LD_INT 2
39342: NEG
39343: PUSH
39344: EMPTY
39345: LIST
39346: LIST
39347: PUSH
39348: LD_INT 3
39350: NEG
39351: PUSH
39352: LD_INT 3
39354: NEG
39355: PUSH
39356: EMPTY
39357: LIST
39358: LIST
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: LIST
39364: LIST
39365: LIST
39366: LIST
39367: LIST
39368: LIST
39369: LIST
39370: LIST
39371: LIST
39372: LIST
39373: LIST
39374: LIST
39375: LIST
39376: LIST
39377: LIST
39378: LIST
39379: LIST
39380: LIST
39381: LIST
39382: LIST
39383: LIST
39384: LIST
39385: LIST
39386: LIST
39387: LIST
39388: LIST
39389: LIST
39390: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39391: LD_ADDR_VAR 0 46
39395: PUSH
39396: LD_INT 0
39398: PUSH
39399: LD_INT 0
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: PUSH
39406: LD_INT 0
39408: PUSH
39409: LD_INT 1
39411: NEG
39412: PUSH
39413: EMPTY
39414: LIST
39415: LIST
39416: PUSH
39417: LD_INT 1
39419: PUSH
39420: LD_INT 0
39422: PUSH
39423: EMPTY
39424: LIST
39425: LIST
39426: PUSH
39427: LD_INT 1
39429: PUSH
39430: LD_INT 1
39432: PUSH
39433: EMPTY
39434: LIST
39435: LIST
39436: PUSH
39437: LD_INT 0
39439: PUSH
39440: LD_INT 1
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 1
39449: NEG
39450: PUSH
39451: LD_INT 0
39453: PUSH
39454: EMPTY
39455: LIST
39456: LIST
39457: PUSH
39458: LD_INT 1
39460: NEG
39461: PUSH
39462: LD_INT 1
39464: NEG
39465: PUSH
39466: EMPTY
39467: LIST
39468: LIST
39469: PUSH
39470: LD_INT 1
39472: NEG
39473: PUSH
39474: LD_INT 2
39476: NEG
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PUSH
39482: LD_INT 0
39484: PUSH
39485: LD_INT 2
39487: NEG
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: PUSH
39493: LD_INT 1
39495: PUSH
39496: LD_INT 1
39498: NEG
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: PUSH
39504: LD_INT 2
39506: PUSH
39507: LD_INT 0
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PUSH
39514: LD_INT 2
39516: PUSH
39517: LD_INT 1
39519: PUSH
39520: EMPTY
39521: LIST
39522: LIST
39523: PUSH
39524: LD_INT 1
39526: PUSH
39527: LD_INT 2
39529: PUSH
39530: EMPTY
39531: LIST
39532: LIST
39533: PUSH
39534: LD_INT 0
39536: PUSH
39537: LD_INT 2
39539: PUSH
39540: EMPTY
39541: LIST
39542: LIST
39543: PUSH
39544: LD_INT 1
39546: NEG
39547: PUSH
39548: LD_INT 1
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: PUSH
39555: LD_INT 2
39557: NEG
39558: PUSH
39559: LD_INT 0
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: PUSH
39566: LD_INT 2
39568: NEG
39569: PUSH
39570: LD_INT 1
39572: NEG
39573: PUSH
39574: EMPTY
39575: LIST
39576: LIST
39577: PUSH
39578: LD_INT 1
39580: NEG
39581: PUSH
39582: LD_INT 3
39584: NEG
39585: PUSH
39586: EMPTY
39587: LIST
39588: LIST
39589: PUSH
39590: LD_INT 0
39592: PUSH
39593: LD_INT 3
39595: NEG
39596: PUSH
39597: EMPTY
39598: LIST
39599: LIST
39600: PUSH
39601: LD_INT 1
39603: PUSH
39604: LD_INT 2
39606: NEG
39607: PUSH
39608: EMPTY
39609: LIST
39610: LIST
39611: PUSH
39612: LD_INT 2
39614: PUSH
39615: LD_INT 1
39617: NEG
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 3
39625: PUSH
39626: LD_INT 0
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: LD_INT 3
39635: PUSH
39636: LD_INT 1
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 1
39645: PUSH
39646: LD_INT 3
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 0
39655: PUSH
39656: LD_INT 3
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: LD_INT 1
39665: NEG
39666: PUSH
39667: LD_INT 2
39669: PUSH
39670: EMPTY
39671: LIST
39672: LIST
39673: PUSH
39674: LD_INT 2
39676: NEG
39677: PUSH
39678: LD_INT 1
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 3
39687: NEG
39688: PUSH
39689: LD_INT 0
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: PUSH
39696: LD_INT 3
39698: NEG
39699: PUSH
39700: LD_INT 1
39702: NEG
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: LIST
39712: LIST
39713: LIST
39714: LIST
39715: LIST
39716: LIST
39717: LIST
39718: LIST
39719: LIST
39720: LIST
39721: LIST
39722: LIST
39723: LIST
39724: LIST
39725: LIST
39726: LIST
39727: LIST
39728: LIST
39729: LIST
39730: LIST
39731: LIST
39732: LIST
39733: LIST
39734: LIST
39735: LIST
39736: LIST
39737: LIST
39738: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39739: LD_ADDR_VAR 0 47
39743: PUSH
39744: LD_INT 0
39746: PUSH
39747: LD_INT 0
39749: PUSH
39750: EMPTY
39751: LIST
39752: LIST
39753: PUSH
39754: LD_INT 0
39756: PUSH
39757: LD_INT 1
39759: NEG
39760: PUSH
39761: EMPTY
39762: LIST
39763: LIST
39764: PUSH
39765: LD_INT 1
39767: PUSH
39768: LD_INT 0
39770: PUSH
39771: EMPTY
39772: LIST
39773: LIST
39774: PUSH
39775: LD_INT 1
39777: PUSH
39778: LD_INT 1
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 0
39787: PUSH
39788: LD_INT 1
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: PUSH
39795: LD_INT 1
39797: NEG
39798: PUSH
39799: LD_INT 0
39801: PUSH
39802: EMPTY
39803: LIST
39804: LIST
39805: PUSH
39806: LD_INT 1
39808: NEG
39809: PUSH
39810: LD_INT 1
39812: NEG
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: LD_INT 1
39820: NEG
39821: PUSH
39822: LD_INT 2
39824: NEG
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: LD_INT 0
39832: PUSH
39833: LD_INT 2
39835: NEG
39836: PUSH
39837: EMPTY
39838: LIST
39839: LIST
39840: PUSH
39841: LD_INT 1
39843: PUSH
39844: LD_INT 1
39846: NEG
39847: PUSH
39848: EMPTY
39849: LIST
39850: LIST
39851: PUSH
39852: LD_INT 2
39854: NEG
39855: PUSH
39856: LD_INT 1
39858: NEG
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: PUSH
39864: LD_INT 2
39866: NEG
39867: PUSH
39868: LD_INT 2
39870: NEG
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: LIST
39880: LIST
39881: LIST
39882: LIST
39883: LIST
39884: LIST
39885: LIST
39886: LIST
39887: LIST
39888: LIST
39889: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39890: LD_ADDR_VAR 0 48
39894: PUSH
39895: LD_INT 0
39897: PUSH
39898: LD_INT 0
39900: PUSH
39901: EMPTY
39902: LIST
39903: LIST
39904: PUSH
39905: LD_INT 0
39907: PUSH
39908: LD_INT 1
39910: NEG
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PUSH
39916: LD_INT 1
39918: PUSH
39919: LD_INT 0
39921: PUSH
39922: EMPTY
39923: LIST
39924: LIST
39925: PUSH
39926: LD_INT 1
39928: PUSH
39929: LD_INT 1
39931: PUSH
39932: EMPTY
39933: LIST
39934: LIST
39935: PUSH
39936: LD_INT 0
39938: PUSH
39939: LD_INT 1
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PUSH
39946: LD_INT 1
39948: NEG
39949: PUSH
39950: LD_INT 0
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: PUSH
39957: LD_INT 1
39959: NEG
39960: PUSH
39961: LD_INT 1
39963: NEG
39964: PUSH
39965: EMPTY
39966: LIST
39967: LIST
39968: PUSH
39969: LD_INT 1
39971: NEG
39972: PUSH
39973: LD_INT 2
39975: NEG
39976: PUSH
39977: EMPTY
39978: LIST
39979: LIST
39980: PUSH
39981: LD_INT 0
39983: PUSH
39984: LD_INT 2
39986: NEG
39987: PUSH
39988: EMPTY
39989: LIST
39990: LIST
39991: PUSH
39992: LD_INT 1
39994: PUSH
39995: LD_INT 1
39997: NEG
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 2
40005: PUSH
40006: LD_INT 0
40008: PUSH
40009: EMPTY
40010: LIST
40011: LIST
40012: PUSH
40013: LD_INT 2
40015: PUSH
40016: LD_INT 1
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PUSH
40023: EMPTY
40024: LIST
40025: LIST
40026: LIST
40027: LIST
40028: LIST
40029: LIST
40030: LIST
40031: LIST
40032: LIST
40033: LIST
40034: LIST
40035: LIST
40036: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
40037: LD_ADDR_VAR 0 49
40041: PUSH
40042: LD_INT 0
40044: PUSH
40045: LD_INT 0
40047: PUSH
40048: EMPTY
40049: LIST
40050: LIST
40051: PUSH
40052: LD_INT 0
40054: PUSH
40055: LD_INT 1
40057: NEG
40058: PUSH
40059: EMPTY
40060: LIST
40061: LIST
40062: PUSH
40063: LD_INT 1
40065: PUSH
40066: LD_INT 0
40068: PUSH
40069: EMPTY
40070: LIST
40071: LIST
40072: PUSH
40073: LD_INT 1
40075: PUSH
40076: LD_INT 1
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 0
40085: PUSH
40086: LD_INT 1
40088: PUSH
40089: EMPTY
40090: LIST
40091: LIST
40092: PUSH
40093: LD_INT 1
40095: NEG
40096: PUSH
40097: LD_INT 0
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: PUSH
40104: LD_INT 1
40106: NEG
40107: PUSH
40108: LD_INT 1
40110: NEG
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 1
40118: PUSH
40119: LD_INT 1
40121: NEG
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PUSH
40127: LD_INT 2
40129: PUSH
40130: LD_INT 0
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: PUSH
40137: LD_INT 2
40139: PUSH
40140: LD_INT 1
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: LD_INT 2
40149: PUSH
40150: LD_INT 2
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 1
40159: PUSH
40160: LD_INT 2
40162: PUSH
40163: EMPTY
40164: LIST
40165: LIST
40166: PUSH
40167: EMPTY
40168: LIST
40169: LIST
40170: LIST
40171: LIST
40172: LIST
40173: LIST
40174: LIST
40175: LIST
40176: LIST
40177: LIST
40178: LIST
40179: LIST
40180: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
40181: LD_ADDR_VAR 0 50
40185: PUSH
40186: LD_INT 0
40188: PUSH
40189: LD_INT 0
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: PUSH
40196: LD_INT 0
40198: PUSH
40199: LD_INT 1
40201: NEG
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 1
40209: PUSH
40210: LD_INT 0
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: LD_INT 1
40219: PUSH
40220: LD_INT 1
40222: PUSH
40223: EMPTY
40224: LIST
40225: LIST
40226: PUSH
40227: LD_INT 0
40229: PUSH
40230: LD_INT 1
40232: PUSH
40233: EMPTY
40234: LIST
40235: LIST
40236: PUSH
40237: LD_INT 1
40239: NEG
40240: PUSH
40241: LD_INT 0
40243: PUSH
40244: EMPTY
40245: LIST
40246: LIST
40247: PUSH
40248: LD_INT 1
40250: NEG
40251: PUSH
40252: LD_INT 1
40254: NEG
40255: PUSH
40256: EMPTY
40257: LIST
40258: LIST
40259: PUSH
40260: LD_INT 2
40262: PUSH
40263: LD_INT 1
40265: PUSH
40266: EMPTY
40267: LIST
40268: LIST
40269: PUSH
40270: LD_INT 2
40272: PUSH
40273: LD_INT 2
40275: PUSH
40276: EMPTY
40277: LIST
40278: LIST
40279: PUSH
40280: LD_INT 1
40282: PUSH
40283: LD_INT 2
40285: PUSH
40286: EMPTY
40287: LIST
40288: LIST
40289: PUSH
40290: LD_INT 0
40292: PUSH
40293: LD_INT 2
40295: PUSH
40296: EMPTY
40297: LIST
40298: LIST
40299: PUSH
40300: LD_INT 1
40302: NEG
40303: PUSH
40304: LD_INT 1
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: LIST
40315: LIST
40316: LIST
40317: LIST
40318: LIST
40319: LIST
40320: LIST
40321: LIST
40322: LIST
40323: LIST
40324: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
40325: LD_ADDR_VAR 0 51
40329: PUSH
40330: LD_INT 0
40332: PUSH
40333: LD_INT 0
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: PUSH
40340: LD_INT 0
40342: PUSH
40343: LD_INT 1
40345: NEG
40346: PUSH
40347: EMPTY
40348: LIST
40349: LIST
40350: PUSH
40351: LD_INT 1
40353: PUSH
40354: LD_INT 0
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 1
40363: PUSH
40364: LD_INT 1
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: PUSH
40371: LD_INT 0
40373: PUSH
40374: LD_INT 1
40376: PUSH
40377: EMPTY
40378: LIST
40379: LIST
40380: PUSH
40381: LD_INT 1
40383: NEG
40384: PUSH
40385: LD_INT 0
40387: PUSH
40388: EMPTY
40389: LIST
40390: LIST
40391: PUSH
40392: LD_INT 1
40394: NEG
40395: PUSH
40396: LD_INT 1
40398: NEG
40399: PUSH
40400: EMPTY
40401: LIST
40402: LIST
40403: PUSH
40404: LD_INT 1
40406: PUSH
40407: LD_INT 2
40409: PUSH
40410: EMPTY
40411: LIST
40412: LIST
40413: PUSH
40414: LD_INT 0
40416: PUSH
40417: LD_INT 2
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: LD_INT 1
40426: NEG
40427: PUSH
40428: LD_INT 1
40430: PUSH
40431: EMPTY
40432: LIST
40433: LIST
40434: PUSH
40435: LD_INT 2
40437: NEG
40438: PUSH
40439: LD_INT 0
40441: PUSH
40442: EMPTY
40443: LIST
40444: LIST
40445: PUSH
40446: LD_INT 2
40448: NEG
40449: PUSH
40450: LD_INT 1
40452: NEG
40453: PUSH
40454: EMPTY
40455: LIST
40456: LIST
40457: PUSH
40458: EMPTY
40459: LIST
40460: LIST
40461: LIST
40462: LIST
40463: LIST
40464: LIST
40465: LIST
40466: LIST
40467: LIST
40468: LIST
40469: LIST
40470: LIST
40471: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40472: LD_ADDR_VAR 0 52
40476: PUSH
40477: LD_INT 0
40479: PUSH
40480: LD_INT 0
40482: PUSH
40483: EMPTY
40484: LIST
40485: LIST
40486: PUSH
40487: LD_INT 0
40489: PUSH
40490: LD_INT 1
40492: NEG
40493: PUSH
40494: EMPTY
40495: LIST
40496: LIST
40497: PUSH
40498: LD_INT 1
40500: PUSH
40501: LD_INT 0
40503: PUSH
40504: EMPTY
40505: LIST
40506: LIST
40507: PUSH
40508: LD_INT 1
40510: PUSH
40511: LD_INT 1
40513: PUSH
40514: EMPTY
40515: LIST
40516: LIST
40517: PUSH
40518: LD_INT 0
40520: PUSH
40521: LD_INT 1
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 1
40530: NEG
40531: PUSH
40532: LD_INT 0
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: PUSH
40539: LD_INT 1
40541: NEG
40542: PUSH
40543: LD_INT 1
40545: NEG
40546: PUSH
40547: EMPTY
40548: LIST
40549: LIST
40550: PUSH
40551: LD_INT 1
40553: NEG
40554: PUSH
40555: LD_INT 2
40557: NEG
40558: PUSH
40559: EMPTY
40560: LIST
40561: LIST
40562: PUSH
40563: LD_INT 1
40565: NEG
40566: PUSH
40567: LD_INT 1
40569: PUSH
40570: EMPTY
40571: LIST
40572: LIST
40573: PUSH
40574: LD_INT 2
40576: NEG
40577: PUSH
40578: LD_INT 0
40580: PUSH
40581: EMPTY
40582: LIST
40583: LIST
40584: PUSH
40585: LD_INT 2
40587: NEG
40588: PUSH
40589: LD_INT 1
40591: NEG
40592: PUSH
40593: EMPTY
40594: LIST
40595: LIST
40596: PUSH
40597: LD_INT 2
40599: NEG
40600: PUSH
40601: LD_INT 2
40603: NEG
40604: PUSH
40605: EMPTY
40606: LIST
40607: LIST
40608: PUSH
40609: EMPTY
40610: LIST
40611: LIST
40612: LIST
40613: LIST
40614: LIST
40615: LIST
40616: LIST
40617: LIST
40618: LIST
40619: LIST
40620: LIST
40621: LIST
40622: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40623: LD_ADDR_VAR 0 53
40627: PUSH
40628: LD_INT 0
40630: PUSH
40631: LD_INT 0
40633: PUSH
40634: EMPTY
40635: LIST
40636: LIST
40637: PUSH
40638: LD_INT 0
40640: PUSH
40641: LD_INT 1
40643: NEG
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: PUSH
40649: LD_INT 1
40651: PUSH
40652: LD_INT 0
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 1
40661: PUSH
40662: LD_INT 1
40664: PUSH
40665: EMPTY
40666: LIST
40667: LIST
40668: PUSH
40669: LD_INT 0
40671: PUSH
40672: LD_INT 1
40674: PUSH
40675: EMPTY
40676: LIST
40677: LIST
40678: PUSH
40679: LD_INT 1
40681: NEG
40682: PUSH
40683: LD_INT 0
40685: PUSH
40686: EMPTY
40687: LIST
40688: LIST
40689: PUSH
40690: LD_INT 1
40692: NEG
40693: PUSH
40694: LD_INT 1
40696: NEG
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PUSH
40702: LD_INT 1
40704: NEG
40705: PUSH
40706: LD_INT 2
40708: NEG
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: PUSH
40714: LD_INT 0
40716: PUSH
40717: LD_INT 2
40719: NEG
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 1
40727: PUSH
40728: LD_INT 1
40730: NEG
40731: PUSH
40732: EMPTY
40733: LIST
40734: LIST
40735: PUSH
40736: LD_INT 2
40738: PUSH
40739: LD_INT 0
40741: PUSH
40742: EMPTY
40743: LIST
40744: LIST
40745: PUSH
40746: LD_INT 2
40748: PUSH
40749: LD_INT 1
40751: PUSH
40752: EMPTY
40753: LIST
40754: LIST
40755: PUSH
40756: LD_INT 2
40758: PUSH
40759: LD_INT 2
40761: PUSH
40762: EMPTY
40763: LIST
40764: LIST
40765: PUSH
40766: LD_INT 1
40768: PUSH
40769: LD_INT 2
40771: PUSH
40772: EMPTY
40773: LIST
40774: LIST
40775: PUSH
40776: LD_INT 0
40778: PUSH
40779: LD_INT 2
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 1
40788: NEG
40789: PUSH
40790: LD_INT 1
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: LD_INT 2
40799: NEG
40800: PUSH
40801: LD_INT 0
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 2
40810: NEG
40811: PUSH
40812: LD_INT 1
40814: NEG
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: PUSH
40820: LD_INT 2
40822: NEG
40823: PUSH
40824: LD_INT 2
40826: NEG
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: EMPTY
40833: LIST
40834: LIST
40835: LIST
40836: LIST
40837: LIST
40838: LIST
40839: LIST
40840: LIST
40841: LIST
40842: LIST
40843: LIST
40844: LIST
40845: LIST
40846: LIST
40847: LIST
40848: LIST
40849: LIST
40850: LIST
40851: LIST
40852: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40853: LD_ADDR_VAR 0 54
40857: PUSH
40858: LD_INT 0
40860: PUSH
40861: LD_INT 0
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: PUSH
40868: LD_INT 0
40870: PUSH
40871: LD_INT 1
40873: NEG
40874: PUSH
40875: EMPTY
40876: LIST
40877: LIST
40878: PUSH
40879: LD_INT 1
40881: PUSH
40882: LD_INT 0
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: PUSH
40889: LD_INT 1
40891: PUSH
40892: LD_INT 1
40894: PUSH
40895: EMPTY
40896: LIST
40897: LIST
40898: PUSH
40899: LD_INT 0
40901: PUSH
40902: LD_INT 1
40904: PUSH
40905: EMPTY
40906: LIST
40907: LIST
40908: PUSH
40909: LD_INT 1
40911: NEG
40912: PUSH
40913: LD_INT 0
40915: PUSH
40916: EMPTY
40917: LIST
40918: LIST
40919: PUSH
40920: LD_INT 1
40922: NEG
40923: PUSH
40924: LD_INT 1
40926: NEG
40927: PUSH
40928: EMPTY
40929: LIST
40930: LIST
40931: PUSH
40932: LD_INT 1
40934: NEG
40935: PUSH
40936: LD_INT 2
40938: NEG
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: LD_INT 0
40946: PUSH
40947: LD_INT 2
40949: NEG
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: PUSH
40955: LD_INT 1
40957: PUSH
40958: LD_INT 1
40960: NEG
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: LD_INT 2
40968: PUSH
40969: LD_INT 0
40971: PUSH
40972: EMPTY
40973: LIST
40974: LIST
40975: PUSH
40976: LD_INT 2
40978: PUSH
40979: LD_INT 1
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: PUSH
40986: LD_INT 2
40988: PUSH
40989: LD_INT 2
40991: PUSH
40992: EMPTY
40993: LIST
40994: LIST
40995: PUSH
40996: LD_INT 1
40998: PUSH
40999: LD_INT 2
41001: PUSH
41002: EMPTY
41003: LIST
41004: LIST
41005: PUSH
41006: LD_INT 0
41008: PUSH
41009: LD_INT 2
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PUSH
41016: LD_INT 1
41018: NEG
41019: PUSH
41020: LD_INT 1
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: PUSH
41027: LD_INT 2
41029: NEG
41030: PUSH
41031: LD_INT 0
41033: PUSH
41034: EMPTY
41035: LIST
41036: LIST
41037: PUSH
41038: LD_INT 2
41040: NEG
41041: PUSH
41042: LD_INT 1
41044: NEG
41045: PUSH
41046: EMPTY
41047: LIST
41048: LIST
41049: PUSH
41050: LD_INT 2
41052: NEG
41053: PUSH
41054: LD_INT 2
41056: NEG
41057: PUSH
41058: EMPTY
41059: LIST
41060: LIST
41061: PUSH
41062: EMPTY
41063: LIST
41064: LIST
41065: LIST
41066: LIST
41067: LIST
41068: LIST
41069: LIST
41070: LIST
41071: LIST
41072: LIST
41073: LIST
41074: LIST
41075: LIST
41076: LIST
41077: LIST
41078: LIST
41079: LIST
41080: LIST
41081: LIST
41082: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41083: LD_ADDR_VAR 0 55
41087: PUSH
41088: LD_INT 0
41090: PUSH
41091: LD_INT 0
41093: PUSH
41094: EMPTY
41095: LIST
41096: LIST
41097: PUSH
41098: LD_INT 0
41100: PUSH
41101: LD_INT 1
41103: NEG
41104: PUSH
41105: EMPTY
41106: LIST
41107: LIST
41108: PUSH
41109: LD_INT 1
41111: PUSH
41112: LD_INT 0
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: PUSH
41119: LD_INT 1
41121: PUSH
41122: LD_INT 1
41124: PUSH
41125: EMPTY
41126: LIST
41127: LIST
41128: PUSH
41129: LD_INT 0
41131: PUSH
41132: LD_INT 1
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: LD_INT 1
41141: NEG
41142: PUSH
41143: LD_INT 0
41145: PUSH
41146: EMPTY
41147: LIST
41148: LIST
41149: PUSH
41150: LD_INT 1
41152: NEG
41153: PUSH
41154: LD_INT 1
41156: NEG
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 1
41164: NEG
41165: PUSH
41166: LD_INT 2
41168: NEG
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: PUSH
41174: LD_INT 0
41176: PUSH
41177: LD_INT 2
41179: NEG
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: PUSH
41185: LD_INT 1
41187: PUSH
41188: LD_INT 1
41190: NEG
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: LD_INT 2
41198: PUSH
41199: LD_INT 0
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PUSH
41206: LD_INT 2
41208: PUSH
41209: LD_INT 1
41211: PUSH
41212: EMPTY
41213: LIST
41214: LIST
41215: PUSH
41216: LD_INT 2
41218: PUSH
41219: LD_INT 2
41221: PUSH
41222: EMPTY
41223: LIST
41224: LIST
41225: PUSH
41226: LD_INT 1
41228: PUSH
41229: LD_INT 2
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PUSH
41236: LD_INT 0
41238: PUSH
41239: LD_INT 2
41241: PUSH
41242: EMPTY
41243: LIST
41244: LIST
41245: PUSH
41246: LD_INT 1
41248: NEG
41249: PUSH
41250: LD_INT 1
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: PUSH
41257: LD_INT 2
41259: NEG
41260: PUSH
41261: LD_INT 0
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: PUSH
41268: LD_INT 2
41270: NEG
41271: PUSH
41272: LD_INT 1
41274: NEG
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: PUSH
41280: LD_INT 2
41282: NEG
41283: PUSH
41284: LD_INT 2
41286: NEG
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: EMPTY
41293: LIST
41294: LIST
41295: LIST
41296: LIST
41297: LIST
41298: LIST
41299: LIST
41300: LIST
41301: LIST
41302: LIST
41303: LIST
41304: LIST
41305: LIST
41306: LIST
41307: LIST
41308: LIST
41309: LIST
41310: LIST
41311: LIST
41312: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41313: LD_ADDR_VAR 0 56
41317: PUSH
41318: LD_INT 0
41320: PUSH
41321: LD_INT 0
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: PUSH
41328: LD_INT 0
41330: PUSH
41331: LD_INT 1
41333: NEG
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PUSH
41339: LD_INT 1
41341: PUSH
41342: LD_INT 0
41344: PUSH
41345: EMPTY
41346: LIST
41347: LIST
41348: PUSH
41349: LD_INT 1
41351: PUSH
41352: LD_INT 1
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: PUSH
41359: LD_INT 0
41361: PUSH
41362: LD_INT 1
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: LD_INT 1
41371: NEG
41372: PUSH
41373: LD_INT 0
41375: PUSH
41376: EMPTY
41377: LIST
41378: LIST
41379: PUSH
41380: LD_INT 1
41382: NEG
41383: PUSH
41384: LD_INT 1
41386: NEG
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: PUSH
41392: LD_INT 1
41394: NEG
41395: PUSH
41396: LD_INT 2
41398: NEG
41399: PUSH
41400: EMPTY
41401: LIST
41402: LIST
41403: PUSH
41404: LD_INT 0
41406: PUSH
41407: LD_INT 2
41409: NEG
41410: PUSH
41411: EMPTY
41412: LIST
41413: LIST
41414: PUSH
41415: LD_INT 1
41417: PUSH
41418: LD_INT 1
41420: NEG
41421: PUSH
41422: EMPTY
41423: LIST
41424: LIST
41425: PUSH
41426: LD_INT 2
41428: PUSH
41429: LD_INT 0
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: PUSH
41436: LD_INT 2
41438: PUSH
41439: LD_INT 1
41441: PUSH
41442: EMPTY
41443: LIST
41444: LIST
41445: PUSH
41446: LD_INT 2
41448: PUSH
41449: LD_INT 2
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PUSH
41456: LD_INT 1
41458: PUSH
41459: LD_INT 2
41461: PUSH
41462: EMPTY
41463: LIST
41464: LIST
41465: PUSH
41466: LD_INT 0
41468: PUSH
41469: LD_INT 2
41471: PUSH
41472: EMPTY
41473: LIST
41474: LIST
41475: PUSH
41476: LD_INT 1
41478: NEG
41479: PUSH
41480: LD_INT 1
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PUSH
41487: LD_INT 2
41489: NEG
41490: PUSH
41491: LD_INT 0
41493: PUSH
41494: EMPTY
41495: LIST
41496: LIST
41497: PUSH
41498: LD_INT 2
41500: NEG
41501: PUSH
41502: LD_INT 1
41504: NEG
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PUSH
41510: LD_INT 2
41512: NEG
41513: PUSH
41514: LD_INT 2
41516: NEG
41517: PUSH
41518: EMPTY
41519: LIST
41520: LIST
41521: PUSH
41522: EMPTY
41523: LIST
41524: LIST
41525: LIST
41526: LIST
41527: LIST
41528: LIST
41529: LIST
41530: LIST
41531: LIST
41532: LIST
41533: LIST
41534: LIST
41535: LIST
41536: LIST
41537: LIST
41538: LIST
41539: LIST
41540: LIST
41541: LIST
41542: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41543: LD_ADDR_VAR 0 57
41547: PUSH
41548: LD_INT 0
41550: PUSH
41551: LD_INT 0
41553: PUSH
41554: EMPTY
41555: LIST
41556: LIST
41557: PUSH
41558: LD_INT 0
41560: PUSH
41561: LD_INT 1
41563: NEG
41564: PUSH
41565: EMPTY
41566: LIST
41567: LIST
41568: PUSH
41569: LD_INT 1
41571: PUSH
41572: LD_INT 0
41574: PUSH
41575: EMPTY
41576: LIST
41577: LIST
41578: PUSH
41579: LD_INT 1
41581: PUSH
41582: LD_INT 1
41584: PUSH
41585: EMPTY
41586: LIST
41587: LIST
41588: PUSH
41589: LD_INT 0
41591: PUSH
41592: LD_INT 1
41594: PUSH
41595: EMPTY
41596: LIST
41597: LIST
41598: PUSH
41599: LD_INT 1
41601: NEG
41602: PUSH
41603: LD_INT 0
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: PUSH
41610: LD_INT 1
41612: NEG
41613: PUSH
41614: LD_INT 1
41616: NEG
41617: PUSH
41618: EMPTY
41619: LIST
41620: LIST
41621: PUSH
41622: LD_INT 1
41624: NEG
41625: PUSH
41626: LD_INT 2
41628: NEG
41629: PUSH
41630: EMPTY
41631: LIST
41632: LIST
41633: PUSH
41634: LD_INT 0
41636: PUSH
41637: LD_INT 2
41639: NEG
41640: PUSH
41641: EMPTY
41642: LIST
41643: LIST
41644: PUSH
41645: LD_INT 1
41647: PUSH
41648: LD_INT 1
41650: NEG
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: PUSH
41656: LD_INT 2
41658: PUSH
41659: LD_INT 0
41661: PUSH
41662: EMPTY
41663: LIST
41664: LIST
41665: PUSH
41666: LD_INT 2
41668: PUSH
41669: LD_INT 1
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 2
41678: PUSH
41679: LD_INT 2
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 1
41688: PUSH
41689: LD_INT 2
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 0
41698: PUSH
41699: LD_INT 2
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: PUSH
41706: LD_INT 1
41708: NEG
41709: PUSH
41710: LD_INT 1
41712: PUSH
41713: EMPTY
41714: LIST
41715: LIST
41716: PUSH
41717: LD_INT 2
41719: NEG
41720: PUSH
41721: LD_INT 0
41723: PUSH
41724: EMPTY
41725: LIST
41726: LIST
41727: PUSH
41728: LD_INT 2
41730: NEG
41731: PUSH
41732: LD_INT 1
41734: NEG
41735: PUSH
41736: EMPTY
41737: LIST
41738: LIST
41739: PUSH
41740: LD_INT 2
41742: NEG
41743: PUSH
41744: LD_INT 2
41746: NEG
41747: PUSH
41748: EMPTY
41749: LIST
41750: LIST
41751: PUSH
41752: EMPTY
41753: LIST
41754: LIST
41755: LIST
41756: LIST
41757: LIST
41758: LIST
41759: LIST
41760: LIST
41761: LIST
41762: LIST
41763: LIST
41764: LIST
41765: LIST
41766: LIST
41767: LIST
41768: LIST
41769: LIST
41770: LIST
41771: LIST
41772: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41773: LD_ADDR_VAR 0 58
41777: PUSH
41778: LD_INT 0
41780: PUSH
41781: LD_INT 0
41783: PUSH
41784: EMPTY
41785: LIST
41786: LIST
41787: PUSH
41788: LD_INT 0
41790: PUSH
41791: LD_INT 1
41793: NEG
41794: PUSH
41795: EMPTY
41796: LIST
41797: LIST
41798: PUSH
41799: LD_INT 1
41801: PUSH
41802: LD_INT 0
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: PUSH
41809: LD_INT 1
41811: PUSH
41812: LD_INT 1
41814: PUSH
41815: EMPTY
41816: LIST
41817: LIST
41818: PUSH
41819: LD_INT 0
41821: PUSH
41822: LD_INT 1
41824: PUSH
41825: EMPTY
41826: LIST
41827: LIST
41828: PUSH
41829: LD_INT 1
41831: NEG
41832: PUSH
41833: LD_INT 0
41835: PUSH
41836: EMPTY
41837: LIST
41838: LIST
41839: PUSH
41840: LD_INT 1
41842: NEG
41843: PUSH
41844: LD_INT 1
41846: NEG
41847: PUSH
41848: EMPTY
41849: LIST
41850: LIST
41851: PUSH
41852: LD_INT 1
41854: NEG
41855: PUSH
41856: LD_INT 2
41858: NEG
41859: PUSH
41860: EMPTY
41861: LIST
41862: LIST
41863: PUSH
41864: LD_INT 0
41866: PUSH
41867: LD_INT 2
41869: NEG
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PUSH
41875: LD_INT 1
41877: PUSH
41878: LD_INT 1
41880: NEG
41881: PUSH
41882: EMPTY
41883: LIST
41884: LIST
41885: PUSH
41886: LD_INT 2
41888: PUSH
41889: LD_INT 0
41891: PUSH
41892: EMPTY
41893: LIST
41894: LIST
41895: PUSH
41896: LD_INT 2
41898: PUSH
41899: LD_INT 1
41901: PUSH
41902: EMPTY
41903: LIST
41904: LIST
41905: PUSH
41906: LD_INT 2
41908: PUSH
41909: LD_INT 2
41911: PUSH
41912: EMPTY
41913: LIST
41914: LIST
41915: PUSH
41916: LD_INT 1
41918: PUSH
41919: LD_INT 2
41921: PUSH
41922: EMPTY
41923: LIST
41924: LIST
41925: PUSH
41926: LD_INT 0
41928: PUSH
41929: LD_INT 2
41931: PUSH
41932: EMPTY
41933: LIST
41934: LIST
41935: PUSH
41936: LD_INT 1
41938: NEG
41939: PUSH
41940: LD_INT 1
41942: PUSH
41943: EMPTY
41944: LIST
41945: LIST
41946: PUSH
41947: LD_INT 2
41949: NEG
41950: PUSH
41951: LD_INT 0
41953: PUSH
41954: EMPTY
41955: LIST
41956: LIST
41957: PUSH
41958: LD_INT 2
41960: NEG
41961: PUSH
41962: LD_INT 1
41964: NEG
41965: PUSH
41966: EMPTY
41967: LIST
41968: LIST
41969: PUSH
41970: LD_INT 2
41972: NEG
41973: PUSH
41974: LD_INT 2
41976: NEG
41977: PUSH
41978: EMPTY
41979: LIST
41980: LIST
41981: PUSH
41982: EMPTY
41983: LIST
41984: LIST
41985: LIST
41986: LIST
41987: LIST
41988: LIST
41989: LIST
41990: LIST
41991: LIST
41992: LIST
41993: LIST
41994: LIST
41995: LIST
41996: LIST
41997: LIST
41998: LIST
41999: LIST
42000: LIST
42001: LIST
42002: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42003: LD_ADDR_VAR 0 59
42007: PUSH
42008: LD_INT 0
42010: PUSH
42011: LD_INT 0
42013: PUSH
42014: EMPTY
42015: LIST
42016: LIST
42017: PUSH
42018: LD_INT 0
42020: PUSH
42021: LD_INT 1
42023: NEG
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: PUSH
42029: LD_INT 1
42031: PUSH
42032: LD_INT 0
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PUSH
42039: LD_INT 1
42041: PUSH
42042: LD_INT 1
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: LD_INT 0
42051: PUSH
42052: LD_INT 1
42054: PUSH
42055: EMPTY
42056: LIST
42057: LIST
42058: PUSH
42059: LD_INT 1
42061: NEG
42062: PUSH
42063: LD_INT 0
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: PUSH
42070: LD_INT 1
42072: NEG
42073: PUSH
42074: LD_INT 1
42076: NEG
42077: PUSH
42078: EMPTY
42079: LIST
42080: LIST
42081: PUSH
42082: EMPTY
42083: LIST
42084: LIST
42085: LIST
42086: LIST
42087: LIST
42088: LIST
42089: LIST
42090: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42091: LD_ADDR_VAR 0 60
42095: PUSH
42096: LD_INT 0
42098: PUSH
42099: LD_INT 0
42101: PUSH
42102: EMPTY
42103: LIST
42104: LIST
42105: PUSH
42106: LD_INT 0
42108: PUSH
42109: LD_INT 1
42111: NEG
42112: PUSH
42113: EMPTY
42114: LIST
42115: LIST
42116: PUSH
42117: LD_INT 1
42119: PUSH
42120: LD_INT 0
42122: PUSH
42123: EMPTY
42124: LIST
42125: LIST
42126: PUSH
42127: LD_INT 1
42129: PUSH
42130: LD_INT 1
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: PUSH
42137: LD_INT 0
42139: PUSH
42140: LD_INT 1
42142: PUSH
42143: EMPTY
42144: LIST
42145: LIST
42146: PUSH
42147: LD_INT 1
42149: NEG
42150: PUSH
42151: LD_INT 0
42153: PUSH
42154: EMPTY
42155: LIST
42156: LIST
42157: PUSH
42158: LD_INT 1
42160: NEG
42161: PUSH
42162: LD_INT 1
42164: NEG
42165: PUSH
42166: EMPTY
42167: LIST
42168: LIST
42169: PUSH
42170: EMPTY
42171: LIST
42172: LIST
42173: LIST
42174: LIST
42175: LIST
42176: LIST
42177: LIST
42178: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42179: LD_ADDR_VAR 0 61
42183: PUSH
42184: LD_INT 0
42186: PUSH
42187: LD_INT 0
42189: PUSH
42190: EMPTY
42191: LIST
42192: LIST
42193: PUSH
42194: LD_INT 0
42196: PUSH
42197: LD_INT 1
42199: NEG
42200: PUSH
42201: EMPTY
42202: LIST
42203: LIST
42204: PUSH
42205: LD_INT 1
42207: PUSH
42208: LD_INT 0
42210: PUSH
42211: EMPTY
42212: LIST
42213: LIST
42214: PUSH
42215: LD_INT 1
42217: PUSH
42218: LD_INT 1
42220: PUSH
42221: EMPTY
42222: LIST
42223: LIST
42224: PUSH
42225: LD_INT 0
42227: PUSH
42228: LD_INT 1
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: PUSH
42235: LD_INT 1
42237: NEG
42238: PUSH
42239: LD_INT 0
42241: PUSH
42242: EMPTY
42243: LIST
42244: LIST
42245: PUSH
42246: LD_INT 1
42248: NEG
42249: PUSH
42250: LD_INT 1
42252: NEG
42253: PUSH
42254: EMPTY
42255: LIST
42256: LIST
42257: PUSH
42258: EMPTY
42259: LIST
42260: LIST
42261: LIST
42262: LIST
42263: LIST
42264: LIST
42265: LIST
42266: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42267: LD_ADDR_VAR 0 62
42271: PUSH
42272: LD_INT 0
42274: PUSH
42275: LD_INT 0
42277: PUSH
42278: EMPTY
42279: LIST
42280: LIST
42281: PUSH
42282: LD_INT 0
42284: PUSH
42285: LD_INT 1
42287: NEG
42288: PUSH
42289: EMPTY
42290: LIST
42291: LIST
42292: PUSH
42293: LD_INT 1
42295: PUSH
42296: LD_INT 0
42298: PUSH
42299: EMPTY
42300: LIST
42301: LIST
42302: PUSH
42303: LD_INT 1
42305: PUSH
42306: LD_INT 1
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: PUSH
42313: LD_INT 0
42315: PUSH
42316: LD_INT 1
42318: PUSH
42319: EMPTY
42320: LIST
42321: LIST
42322: PUSH
42323: LD_INT 1
42325: NEG
42326: PUSH
42327: LD_INT 0
42329: PUSH
42330: EMPTY
42331: LIST
42332: LIST
42333: PUSH
42334: LD_INT 1
42336: NEG
42337: PUSH
42338: LD_INT 1
42340: NEG
42341: PUSH
42342: EMPTY
42343: LIST
42344: LIST
42345: PUSH
42346: EMPTY
42347: LIST
42348: LIST
42349: LIST
42350: LIST
42351: LIST
42352: LIST
42353: LIST
42354: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42355: LD_ADDR_VAR 0 63
42359: PUSH
42360: LD_INT 0
42362: PUSH
42363: LD_INT 0
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: LD_INT 0
42372: PUSH
42373: LD_INT 1
42375: NEG
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: LD_INT 1
42383: PUSH
42384: LD_INT 0
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: LD_INT 1
42393: PUSH
42394: LD_INT 1
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PUSH
42401: LD_INT 0
42403: PUSH
42404: LD_INT 1
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: PUSH
42411: LD_INT 1
42413: NEG
42414: PUSH
42415: LD_INT 0
42417: PUSH
42418: EMPTY
42419: LIST
42420: LIST
42421: PUSH
42422: LD_INT 1
42424: NEG
42425: PUSH
42426: LD_INT 1
42428: NEG
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: EMPTY
42435: LIST
42436: LIST
42437: LIST
42438: LIST
42439: LIST
42440: LIST
42441: LIST
42442: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42443: LD_ADDR_VAR 0 64
42447: PUSH
42448: LD_INT 0
42450: PUSH
42451: LD_INT 0
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: PUSH
42458: LD_INT 0
42460: PUSH
42461: LD_INT 1
42463: NEG
42464: PUSH
42465: EMPTY
42466: LIST
42467: LIST
42468: PUSH
42469: LD_INT 1
42471: PUSH
42472: LD_INT 0
42474: PUSH
42475: EMPTY
42476: LIST
42477: LIST
42478: PUSH
42479: LD_INT 1
42481: PUSH
42482: LD_INT 1
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: PUSH
42489: LD_INT 0
42491: PUSH
42492: LD_INT 1
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: LD_INT 1
42501: NEG
42502: PUSH
42503: LD_INT 0
42505: PUSH
42506: EMPTY
42507: LIST
42508: LIST
42509: PUSH
42510: LD_INT 1
42512: NEG
42513: PUSH
42514: LD_INT 1
42516: NEG
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: LIST
42526: LIST
42527: LIST
42528: LIST
42529: LIST
42530: ST_TO_ADDR
// end ; 1 :
42531: GO 48428
42533: LD_INT 1
42535: DOUBLE
42536: EQUAL
42537: IFTRUE 42541
42539: GO 45164
42541: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42542: LD_ADDR_VAR 0 11
42546: PUSH
42547: LD_INT 1
42549: NEG
42550: PUSH
42551: LD_INT 3
42553: NEG
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: LD_INT 0
42561: PUSH
42562: LD_INT 3
42564: NEG
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 1
42572: PUSH
42573: LD_INT 2
42575: NEG
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: PUSH
42581: EMPTY
42582: LIST
42583: LIST
42584: LIST
42585: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42586: LD_ADDR_VAR 0 12
42590: PUSH
42591: LD_INT 2
42593: PUSH
42594: LD_INT 1
42596: NEG
42597: PUSH
42598: EMPTY
42599: LIST
42600: LIST
42601: PUSH
42602: LD_INT 3
42604: PUSH
42605: LD_INT 0
42607: PUSH
42608: EMPTY
42609: LIST
42610: LIST
42611: PUSH
42612: LD_INT 3
42614: PUSH
42615: LD_INT 1
42617: PUSH
42618: EMPTY
42619: LIST
42620: LIST
42621: PUSH
42622: EMPTY
42623: LIST
42624: LIST
42625: LIST
42626: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42627: LD_ADDR_VAR 0 13
42631: PUSH
42632: LD_INT 3
42634: PUSH
42635: LD_INT 2
42637: PUSH
42638: EMPTY
42639: LIST
42640: LIST
42641: PUSH
42642: LD_INT 3
42644: PUSH
42645: LD_INT 3
42647: PUSH
42648: EMPTY
42649: LIST
42650: LIST
42651: PUSH
42652: LD_INT 2
42654: PUSH
42655: LD_INT 3
42657: PUSH
42658: EMPTY
42659: LIST
42660: LIST
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: LIST
42666: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42667: LD_ADDR_VAR 0 14
42671: PUSH
42672: LD_INT 1
42674: PUSH
42675: LD_INT 3
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: PUSH
42682: LD_INT 0
42684: PUSH
42685: LD_INT 3
42687: PUSH
42688: EMPTY
42689: LIST
42690: LIST
42691: PUSH
42692: LD_INT 1
42694: NEG
42695: PUSH
42696: LD_INT 2
42698: PUSH
42699: EMPTY
42700: LIST
42701: LIST
42702: PUSH
42703: EMPTY
42704: LIST
42705: LIST
42706: LIST
42707: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42708: LD_ADDR_VAR 0 15
42712: PUSH
42713: LD_INT 2
42715: NEG
42716: PUSH
42717: LD_INT 1
42719: PUSH
42720: EMPTY
42721: LIST
42722: LIST
42723: PUSH
42724: LD_INT 3
42726: NEG
42727: PUSH
42728: LD_INT 0
42730: PUSH
42731: EMPTY
42732: LIST
42733: LIST
42734: PUSH
42735: LD_INT 3
42737: NEG
42738: PUSH
42739: LD_INT 1
42741: NEG
42742: PUSH
42743: EMPTY
42744: LIST
42745: LIST
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: LIST
42751: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42752: LD_ADDR_VAR 0 16
42756: PUSH
42757: LD_INT 2
42759: NEG
42760: PUSH
42761: LD_INT 3
42763: NEG
42764: PUSH
42765: EMPTY
42766: LIST
42767: LIST
42768: PUSH
42769: LD_INT 3
42771: NEG
42772: PUSH
42773: LD_INT 2
42775: NEG
42776: PUSH
42777: EMPTY
42778: LIST
42779: LIST
42780: PUSH
42781: LD_INT 3
42783: NEG
42784: PUSH
42785: LD_INT 3
42787: NEG
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: PUSH
42793: EMPTY
42794: LIST
42795: LIST
42796: LIST
42797: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42798: LD_ADDR_VAR 0 17
42802: PUSH
42803: LD_INT 1
42805: NEG
42806: PUSH
42807: LD_INT 3
42809: NEG
42810: PUSH
42811: EMPTY
42812: LIST
42813: LIST
42814: PUSH
42815: LD_INT 0
42817: PUSH
42818: LD_INT 3
42820: NEG
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: PUSH
42826: LD_INT 1
42828: PUSH
42829: LD_INT 2
42831: NEG
42832: PUSH
42833: EMPTY
42834: LIST
42835: LIST
42836: PUSH
42837: EMPTY
42838: LIST
42839: LIST
42840: LIST
42841: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42842: LD_ADDR_VAR 0 18
42846: PUSH
42847: LD_INT 2
42849: PUSH
42850: LD_INT 1
42852: NEG
42853: PUSH
42854: EMPTY
42855: LIST
42856: LIST
42857: PUSH
42858: LD_INT 3
42860: PUSH
42861: LD_INT 0
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: PUSH
42868: LD_INT 3
42870: PUSH
42871: LD_INT 1
42873: PUSH
42874: EMPTY
42875: LIST
42876: LIST
42877: PUSH
42878: EMPTY
42879: LIST
42880: LIST
42881: LIST
42882: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42883: LD_ADDR_VAR 0 19
42887: PUSH
42888: LD_INT 3
42890: PUSH
42891: LD_INT 2
42893: PUSH
42894: EMPTY
42895: LIST
42896: LIST
42897: PUSH
42898: LD_INT 3
42900: PUSH
42901: LD_INT 3
42903: PUSH
42904: EMPTY
42905: LIST
42906: LIST
42907: PUSH
42908: LD_INT 2
42910: PUSH
42911: LD_INT 3
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: PUSH
42918: EMPTY
42919: LIST
42920: LIST
42921: LIST
42922: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42923: LD_ADDR_VAR 0 20
42927: PUSH
42928: LD_INT 1
42930: PUSH
42931: LD_INT 3
42933: PUSH
42934: EMPTY
42935: LIST
42936: LIST
42937: PUSH
42938: LD_INT 0
42940: PUSH
42941: LD_INT 3
42943: PUSH
42944: EMPTY
42945: LIST
42946: LIST
42947: PUSH
42948: LD_INT 1
42950: NEG
42951: PUSH
42952: LD_INT 2
42954: PUSH
42955: EMPTY
42956: LIST
42957: LIST
42958: PUSH
42959: EMPTY
42960: LIST
42961: LIST
42962: LIST
42963: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42964: LD_ADDR_VAR 0 21
42968: PUSH
42969: LD_INT 2
42971: NEG
42972: PUSH
42973: LD_INT 1
42975: PUSH
42976: EMPTY
42977: LIST
42978: LIST
42979: PUSH
42980: LD_INT 3
42982: NEG
42983: PUSH
42984: LD_INT 0
42986: PUSH
42987: EMPTY
42988: LIST
42989: LIST
42990: PUSH
42991: LD_INT 3
42993: NEG
42994: PUSH
42995: LD_INT 1
42997: NEG
42998: PUSH
42999: EMPTY
43000: LIST
43001: LIST
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: LIST
43007: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43008: LD_ADDR_VAR 0 22
43012: PUSH
43013: LD_INT 2
43015: NEG
43016: PUSH
43017: LD_INT 3
43019: NEG
43020: PUSH
43021: EMPTY
43022: LIST
43023: LIST
43024: PUSH
43025: LD_INT 3
43027: NEG
43028: PUSH
43029: LD_INT 2
43031: NEG
43032: PUSH
43033: EMPTY
43034: LIST
43035: LIST
43036: PUSH
43037: LD_INT 3
43039: NEG
43040: PUSH
43041: LD_INT 3
43043: NEG
43044: PUSH
43045: EMPTY
43046: LIST
43047: LIST
43048: PUSH
43049: EMPTY
43050: LIST
43051: LIST
43052: LIST
43053: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
43054: LD_ADDR_VAR 0 23
43058: PUSH
43059: LD_INT 0
43061: PUSH
43062: LD_INT 3
43064: NEG
43065: PUSH
43066: EMPTY
43067: LIST
43068: LIST
43069: PUSH
43070: LD_INT 1
43072: NEG
43073: PUSH
43074: LD_INT 4
43076: NEG
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: PUSH
43082: LD_INT 1
43084: PUSH
43085: LD_INT 3
43087: NEG
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: EMPTY
43094: LIST
43095: LIST
43096: LIST
43097: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
43098: LD_ADDR_VAR 0 24
43102: PUSH
43103: LD_INT 3
43105: PUSH
43106: LD_INT 0
43108: PUSH
43109: EMPTY
43110: LIST
43111: LIST
43112: PUSH
43113: LD_INT 3
43115: PUSH
43116: LD_INT 1
43118: NEG
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: PUSH
43124: LD_INT 4
43126: PUSH
43127: LD_INT 1
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: PUSH
43134: EMPTY
43135: LIST
43136: LIST
43137: LIST
43138: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
43139: LD_ADDR_VAR 0 25
43143: PUSH
43144: LD_INT 3
43146: PUSH
43147: LD_INT 3
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PUSH
43154: LD_INT 4
43156: PUSH
43157: LD_INT 3
43159: PUSH
43160: EMPTY
43161: LIST
43162: LIST
43163: PUSH
43164: LD_INT 3
43166: PUSH
43167: LD_INT 4
43169: PUSH
43170: EMPTY
43171: LIST
43172: LIST
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: LIST
43178: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
43179: LD_ADDR_VAR 0 26
43183: PUSH
43184: LD_INT 0
43186: PUSH
43187: LD_INT 3
43189: PUSH
43190: EMPTY
43191: LIST
43192: LIST
43193: PUSH
43194: LD_INT 1
43196: PUSH
43197: LD_INT 4
43199: PUSH
43200: EMPTY
43201: LIST
43202: LIST
43203: PUSH
43204: LD_INT 1
43206: NEG
43207: PUSH
43208: LD_INT 3
43210: PUSH
43211: EMPTY
43212: LIST
43213: LIST
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: LIST
43219: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
43220: LD_ADDR_VAR 0 27
43224: PUSH
43225: LD_INT 3
43227: NEG
43228: PUSH
43229: LD_INT 0
43231: PUSH
43232: EMPTY
43233: LIST
43234: LIST
43235: PUSH
43236: LD_INT 3
43238: NEG
43239: PUSH
43240: LD_INT 1
43242: PUSH
43243: EMPTY
43244: LIST
43245: LIST
43246: PUSH
43247: LD_INT 4
43249: NEG
43250: PUSH
43251: LD_INT 1
43253: NEG
43254: PUSH
43255: EMPTY
43256: LIST
43257: LIST
43258: PUSH
43259: EMPTY
43260: LIST
43261: LIST
43262: LIST
43263: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
43264: LD_ADDR_VAR 0 28
43268: PUSH
43269: LD_INT 3
43271: NEG
43272: PUSH
43273: LD_INT 3
43275: NEG
43276: PUSH
43277: EMPTY
43278: LIST
43279: LIST
43280: PUSH
43281: LD_INT 3
43283: NEG
43284: PUSH
43285: LD_INT 4
43287: NEG
43288: PUSH
43289: EMPTY
43290: LIST
43291: LIST
43292: PUSH
43293: LD_INT 4
43295: NEG
43296: PUSH
43297: LD_INT 3
43299: NEG
43300: PUSH
43301: EMPTY
43302: LIST
43303: LIST
43304: PUSH
43305: EMPTY
43306: LIST
43307: LIST
43308: LIST
43309: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
43310: LD_ADDR_VAR 0 29
43314: PUSH
43315: LD_INT 1
43317: NEG
43318: PUSH
43319: LD_INT 3
43321: NEG
43322: PUSH
43323: EMPTY
43324: LIST
43325: LIST
43326: PUSH
43327: LD_INT 0
43329: PUSH
43330: LD_INT 3
43332: NEG
43333: PUSH
43334: EMPTY
43335: LIST
43336: LIST
43337: PUSH
43338: LD_INT 1
43340: PUSH
43341: LD_INT 2
43343: NEG
43344: PUSH
43345: EMPTY
43346: LIST
43347: LIST
43348: PUSH
43349: LD_INT 1
43351: NEG
43352: PUSH
43353: LD_INT 4
43355: NEG
43356: PUSH
43357: EMPTY
43358: LIST
43359: LIST
43360: PUSH
43361: LD_INT 0
43363: PUSH
43364: LD_INT 4
43366: NEG
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PUSH
43372: LD_INT 1
43374: PUSH
43375: LD_INT 3
43377: NEG
43378: PUSH
43379: EMPTY
43380: LIST
43381: LIST
43382: PUSH
43383: LD_INT 1
43385: NEG
43386: PUSH
43387: LD_INT 5
43389: NEG
43390: PUSH
43391: EMPTY
43392: LIST
43393: LIST
43394: PUSH
43395: LD_INT 0
43397: PUSH
43398: LD_INT 5
43400: NEG
43401: PUSH
43402: EMPTY
43403: LIST
43404: LIST
43405: PUSH
43406: LD_INT 1
43408: PUSH
43409: LD_INT 4
43411: NEG
43412: PUSH
43413: EMPTY
43414: LIST
43415: LIST
43416: PUSH
43417: LD_INT 1
43419: NEG
43420: PUSH
43421: LD_INT 6
43423: NEG
43424: PUSH
43425: EMPTY
43426: LIST
43427: LIST
43428: PUSH
43429: LD_INT 0
43431: PUSH
43432: LD_INT 6
43434: NEG
43435: PUSH
43436: EMPTY
43437: LIST
43438: LIST
43439: PUSH
43440: LD_INT 1
43442: PUSH
43443: LD_INT 5
43445: NEG
43446: PUSH
43447: EMPTY
43448: LIST
43449: LIST
43450: PUSH
43451: EMPTY
43452: LIST
43453: LIST
43454: LIST
43455: LIST
43456: LIST
43457: LIST
43458: LIST
43459: LIST
43460: LIST
43461: LIST
43462: LIST
43463: LIST
43464: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
43465: LD_ADDR_VAR 0 30
43469: PUSH
43470: LD_INT 2
43472: PUSH
43473: LD_INT 1
43475: NEG
43476: PUSH
43477: EMPTY
43478: LIST
43479: LIST
43480: PUSH
43481: LD_INT 3
43483: PUSH
43484: LD_INT 0
43486: PUSH
43487: EMPTY
43488: LIST
43489: LIST
43490: PUSH
43491: LD_INT 3
43493: PUSH
43494: LD_INT 1
43496: PUSH
43497: EMPTY
43498: LIST
43499: LIST
43500: PUSH
43501: LD_INT 3
43503: PUSH
43504: LD_INT 1
43506: NEG
43507: PUSH
43508: EMPTY
43509: LIST
43510: LIST
43511: PUSH
43512: LD_INT 4
43514: PUSH
43515: LD_INT 0
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: LD_INT 4
43524: PUSH
43525: LD_INT 1
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: PUSH
43532: LD_INT 4
43534: PUSH
43535: LD_INT 1
43537: NEG
43538: PUSH
43539: EMPTY
43540: LIST
43541: LIST
43542: PUSH
43543: LD_INT 5
43545: PUSH
43546: LD_INT 0
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: PUSH
43553: LD_INT 5
43555: PUSH
43556: LD_INT 1
43558: PUSH
43559: EMPTY
43560: LIST
43561: LIST
43562: PUSH
43563: LD_INT 5
43565: PUSH
43566: LD_INT 1
43568: NEG
43569: PUSH
43570: EMPTY
43571: LIST
43572: LIST
43573: PUSH
43574: LD_INT 6
43576: PUSH
43577: LD_INT 0
43579: PUSH
43580: EMPTY
43581: LIST
43582: LIST
43583: PUSH
43584: LD_INT 6
43586: PUSH
43587: LD_INT 1
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: PUSH
43594: EMPTY
43595: LIST
43596: LIST
43597: LIST
43598: LIST
43599: LIST
43600: LIST
43601: LIST
43602: LIST
43603: LIST
43604: LIST
43605: LIST
43606: LIST
43607: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
43608: LD_ADDR_VAR 0 31
43612: PUSH
43613: LD_INT 3
43615: PUSH
43616: LD_INT 2
43618: PUSH
43619: EMPTY
43620: LIST
43621: LIST
43622: PUSH
43623: LD_INT 3
43625: PUSH
43626: LD_INT 3
43628: PUSH
43629: EMPTY
43630: LIST
43631: LIST
43632: PUSH
43633: LD_INT 2
43635: PUSH
43636: LD_INT 3
43638: PUSH
43639: EMPTY
43640: LIST
43641: LIST
43642: PUSH
43643: LD_INT 4
43645: PUSH
43646: LD_INT 3
43648: PUSH
43649: EMPTY
43650: LIST
43651: LIST
43652: PUSH
43653: LD_INT 4
43655: PUSH
43656: LD_INT 4
43658: PUSH
43659: EMPTY
43660: LIST
43661: LIST
43662: PUSH
43663: LD_INT 3
43665: PUSH
43666: LD_INT 4
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: LD_INT 5
43675: PUSH
43676: LD_INT 4
43678: PUSH
43679: EMPTY
43680: LIST
43681: LIST
43682: PUSH
43683: LD_INT 5
43685: PUSH
43686: LD_INT 5
43688: PUSH
43689: EMPTY
43690: LIST
43691: LIST
43692: PUSH
43693: LD_INT 4
43695: PUSH
43696: LD_INT 5
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: PUSH
43703: LD_INT 6
43705: PUSH
43706: LD_INT 5
43708: PUSH
43709: EMPTY
43710: LIST
43711: LIST
43712: PUSH
43713: LD_INT 6
43715: PUSH
43716: LD_INT 6
43718: PUSH
43719: EMPTY
43720: LIST
43721: LIST
43722: PUSH
43723: LD_INT 5
43725: PUSH
43726: LD_INT 6
43728: PUSH
43729: EMPTY
43730: LIST
43731: LIST
43732: PUSH
43733: EMPTY
43734: LIST
43735: LIST
43736: LIST
43737: LIST
43738: LIST
43739: LIST
43740: LIST
43741: LIST
43742: LIST
43743: LIST
43744: LIST
43745: LIST
43746: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
43747: LD_ADDR_VAR 0 32
43751: PUSH
43752: LD_INT 1
43754: PUSH
43755: LD_INT 3
43757: PUSH
43758: EMPTY
43759: LIST
43760: LIST
43761: PUSH
43762: LD_INT 0
43764: PUSH
43765: LD_INT 3
43767: PUSH
43768: EMPTY
43769: LIST
43770: LIST
43771: PUSH
43772: LD_INT 1
43774: NEG
43775: PUSH
43776: LD_INT 2
43778: PUSH
43779: EMPTY
43780: LIST
43781: LIST
43782: PUSH
43783: LD_INT 1
43785: PUSH
43786: LD_INT 4
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PUSH
43793: LD_INT 0
43795: PUSH
43796: LD_INT 4
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: PUSH
43803: LD_INT 1
43805: NEG
43806: PUSH
43807: LD_INT 3
43809: PUSH
43810: EMPTY
43811: LIST
43812: LIST
43813: PUSH
43814: LD_INT 1
43816: PUSH
43817: LD_INT 5
43819: PUSH
43820: EMPTY
43821: LIST
43822: LIST
43823: PUSH
43824: LD_INT 0
43826: PUSH
43827: LD_INT 5
43829: PUSH
43830: EMPTY
43831: LIST
43832: LIST
43833: PUSH
43834: LD_INT 1
43836: NEG
43837: PUSH
43838: LD_INT 4
43840: PUSH
43841: EMPTY
43842: LIST
43843: LIST
43844: PUSH
43845: LD_INT 1
43847: PUSH
43848: LD_INT 6
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: PUSH
43855: LD_INT 0
43857: PUSH
43858: LD_INT 6
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: PUSH
43865: LD_INT 1
43867: NEG
43868: PUSH
43869: LD_INT 5
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: PUSH
43876: EMPTY
43877: LIST
43878: LIST
43879: LIST
43880: LIST
43881: LIST
43882: LIST
43883: LIST
43884: LIST
43885: LIST
43886: LIST
43887: LIST
43888: LIST
43889: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
43890: LD_ADDR_VAR 0 33
43894: PUSH
43895: LD_INT 2
43897: NEG
43898: PUSH
43899: LD_INT 1
43901: PUSH
43902: EMPTY
43903: LIST
43904: LIST
43905: PUSH
43906: LD_INT 3
43908: NEG
43909: PUSH
43910: LD_INT 0
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 3
43919: NEG
43920: PUSH
43921: LD_INT 1
43923: NEG
43924: PUSH
43925: EMPTY
43926: LIST
43927: LIST
43928: PUSH
43929: LD_INT 3
43931: NEG
43932: PUSH
43933: LD_INT 1
43935: PUSH
43936: EMPTY
43937: LIST
43938: LIST
43939: PUSH
43940: LD_INT 4
43942: NEG
43943: PUSH
43944: LD_INT 0
43946: PUSH
43947: EMPTY
43948: LIST
43949: LIST
43950: PUSH
43951: LD_INT 4
43953: NEG
43954: PUSH
43955: LD_INT 1
43957: NEG
43958: PUSH
43959: EMPTY
43960: LIST
43961: LIST
43962: PUSH
43963: LD_INT 4
43965: NEG
43966: PUSH
43967: LD_INT 1
43969: PUSH
43970: EMPTY
43971: LIST
43972: LIST
43973: PUSH
43974: LD_INT 5
43976: NEG
43977: PUSH
43978: LD_INT 0
43980: PUSH
43981: EMPTY
43982: LIST
43983: LIST
43984: PUSH
43985: LD_INT 5
43987: NEG
43988: PUSH
43989: LD_INT 1
43991: NEG
43992: PUSH
43993: EMPTY
43994: LIST
43995: LIST
43996: PUSH
43997: LD_INT 5
43999: NEG
44000: PUSH
44001: LD_INT 1
44003: PUSH
44004: EMPTY
44005: LIST
44006: LIST
44007: PUSH
44008: LD_INT 6
44010: NEG
44011: PUSH
44012: LD_INT 0
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: PUSH
44019: LD_INT 6
44021: NEG
44022: PUSH
44023: LD_INT 1
44025: NEG
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: LIST
44035: LIST
44036: LIST
44037: LIST
44038: LIST
44039: LIST
44040: LIST
44041: LIST
44042: LIST
44043: LIST
44044: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
44045: LD_ADDR_VAR 0 34
44049: PUSH
44050: LD_INT 2
44052: NEG
44053: PUSH
44054: LD_INT 3
44056: NEG
44057: PUSH
44058: EMPTY
44059: LIST
44060: LIST
44061: PUSH
44062: LD_INT 3
44064: NEG
44065: PUSH
44066: LD_INT 2
44068: NEG
44069: PUSH
44070: EMPTY
44071: LIST
44072: LIST
44073: PUSH
44074: LD_INT 3
44076: NEG
44077: PUSH
44078: LD_INT 3
44080: NEG
44081: PUSH
44082: EMPTY
44083: LIST
44084: LIST
44085: PUSH
44086: LD_INT 3
44088: NEG
44089: PUSH
44090: LD_INT 4
44092: NEG
44093: PUSH
44094: EMPTY
44095: LIST
44096: LIST
44097: PUSH
44098: LD_INT 4
44100: NEG
44101: PUSH
44102: LD_INT 3
44104: NEG
44105: PUSH
44106: EMPTY
44107: LIST
44108: LIST
44109: PUSH
44110: LD_INT 4
44112: NEG
44113: PUSH
44114: LD_INT 4
44116: NEG
44117: PUSH
44118: EMPTY
44119: LIST
44120: LIST
44121: PUSH
44122: LD_INT 4
44124: NEG
44125: PUSH
44126: LD_INT 5
44128: NEG
44129: PUSH
44130: EMPTY
44131: LIST
44132: LIST
44133: PUSH
44134: LD_INT 5
44136: NEG
44137: PUSH
44138: LD_INT 4
44140: NEG
44141: PUSH
44142: EMPTY
44143: LIST
44144: LIST
44145: PUSH
44146: LD_INT 5
44148: NEG
44149: PUSH
44150: LD_INT 5
44152: NEG
44153: PUSH
44154: EMPTY
44155: LIST
44156: LIST
44157: PUSH
44158: LD_INT 5
44160: NEG
44161: PUSH
44162: LD_INT 6
44164: NEG
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: PUSH
44170: LD_INT 6
44172: NEG
44173: PUSH
44174: LD_INT 5
44176: NEG
44177: PUSH
44178: EMPTY
44179: LIST
44180: LIST
44181: PUSH
44182: LD_INT 6
44184: NEG
44185: PUSH
44186: LD_INT 6
44188: NEG
44189: PUSH
44190: EMPTY
44191: LIST
44192: LIST
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: LIST
44198: LIST
44199: LIST
44200: LIST
44201: LIST
44202: LIST
44203: LIST
44204: LIST
44205: LIST
44206: LIST
44207: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
44208: LD_ADDR_VAR 0 41
44212: PUSH
44213: LD_INT 0
44215: PUSH
44216: LD_INT 2
44218: NEG
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: PUSH
44224: LD_INT 1
44226: NEG
44227: PUSH
44228: LD_INT 3
44230: NEG
44231: PUSH
44232: EMPTY
44233: LIST
44234: LIST
44235: PUSH
44236: LD_INT 1
44238: PUSH
44239: LD_INT 2
44241: NEG
44242: PUSH
44243: EMPTY
44244: LIST
44245: LIST
44246: PUSH
44247: EMPTY
44248: LIST
44249: LIST
44250: LIST
44251: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
44252: LD_ADDR_VAR 0 42
44256: PUSH
44257: LD_INT 2
44259: PUSH
44260: LD_INT 0
44262: PUSH
44263: EMPTY
44264: LIST
44265: LIST
44266: PUSH
44267: LD_INT 2
44269: PUSH
44270: LD_INT 1
44272: NEG
44273: PUSH
44274: EMPTY
44275: LIST
44276: LIST
44277: PUSH
44278: LD_INT 3
44280: PUSH
44281: LD_INT 1
44283: PUSH
44284: EMPTY
44285: LIST
44286: LIST
44287: PUSH
44288: EMPTY
44289: LIST
44290: LIST
44291: LIST
44292: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
44293: LD_ADDR_VAR 0 43
44297: PUSH
44298: LD_INT 2
44300: PUSH
44301: LD_INT 2
44303: PUSH
44304: EMPTY
44305: LIST
44306: LIST
44307: PUSH
44308: LD_INT 3
44310: PUSH
44311: LD_INT 2
44313: PUSH
44314: EMPTY
44315: LIST
44316: LIST
44317: PUSH
44318: LD_INT 2
44320: PUSH
44321: LD_INT 3
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: EMPTY
44329: LIST
44330: LIST
44331: LIST
44332: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
44333: LD_ADDR_VAR 0 44
44337: PUSH
44338: LD_INT 0
44340: PUSH
44341: LD_INT 2
44343: PUSH
44344: EMPTY
44345: LIST
44346: LIST
44347: PUSH
44348: LD_INT 1
44350: PUSH
44351: LD_INT 3
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 1
44360: NEG
44361: PUSH
44362: LD_INT 2
44364: PUSH
44365: EMPTY
44366: LIST
44367: LIST
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: LIST
44373: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
44374: LD_ADDR_VAR 0 45
44378: PUSH
44379: LD_INT 2
44381: NEG
44382: PUSH
44383: LD_INT 0
44385: PUSH
44386: EMPTY
44387: LIST
44388: LIST
44389: PUSH
44390: LD_INT 2
44392: NEG
44393: PUSH
44394: LD_INT 1
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 3
44403: NEG
44404: PUSH
44405: LD_INT 1
44407: NEG
44408: PUSH
44409: EMPTY
44410: LIST
44411: LIST
44412: PUSH
44413: EMPTY
44414: LIST
44415: LIST
44416: LIST
44417: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
44418: LD_ADDR_VAR 0 46
44422: PUSH
44423: LD_INT 2
44425: NEG
44426: PUSH
44427: LD_INT 2
44429: NEG
44430: PUSH
44431: EMPTY
44432: LIST
44433: LIST
44434: PUSH
44435: LD_INT 2
44437: NEG
44438: PUSH
44439: LD_INT 3
44441: NEG
44442: PUSH
44443: EMPTY
44444: LIST
44445: LIST
44446: PUSH
44447: LD_INT 3
44449: NEG
44450: PUSH
44451: LD_INT 2
44453: NEG
44454: PUSH
44455: EMPTY
44456: LIST
44457: LIST
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: LIST
44463: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
44464: LD_ADDR_VAR 0 47
44468: PUSH
44469: LD_INT 2
44471: NEG
44472: PUSH
44473: LD_INT 3
44475: NEG
44476: PUSH
44477: EMPTY
44478: LIST
44479: LIST
44480: PUSH
44481: LD_INT 1
44483: NEG
44484: PUSH
44485: LD_INT 3
44487: NEG
44488: PUSH
44489: EMPTY
44490: LIST
44491: LIST
44492: PUSH
44493: EMPTY
44494: LIST
44495: LIST
44496: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
44497: LD_ADDR_VAR 0 48
44501: PUSH
44502: LD_INT 1
44504: PUSH
44505: LD_INT 2
44507: NEG
44508: PUSH
44509: EMPTY
44510: LIST
44511: LIST
44512: PUSH
44513: LD_INT 2
44515: PUSH
44516: LD_INT 1
44518: NEG
44519: PUSH
44520: EMPTY
44521: LIST
44522: LIST
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
44528: LD_ADDR_VAR 0 49
44532: PUSH
44533: LD_INT 3
44535: PUSH
44536: LD_INT 1
44538: PUSH
44539: EMPTY
44540: LIST
44541: LIST
44542: PUSH
44543: LD_INT 3
44545: PUSH
44546: LD_INT 2
44548: PUSH
44549: EMPTY
44550: LIST
44551: LIST
44552: PUSH
44553: EMPTY
44554: LIST
44555: LIST
44556: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
44557: LD_ADDR_VAR 0 50
44561: PUSH
44562: LD_INT 2
44564: PUSH
44565: LD_INT 3
44567: PUSH
44568: EMPTY
44569: LIST
44570: LIST
44571: PUSH
44572: LD_INT 1
44574: PUSH
44575: LD_INT 3
44577: PUSH
44578: EMPTY
44579: LIST
44580: LIST
44581: PUSH
44582: EMPTY
44583: LIST
44584: LIST
44585: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
44586: LD_ADDR_VAR 0 51
44590: PUSH
44591: LD_INT 1
44593: NEG
44594: PUSH
44595: LD_INT 2
44597: PUSH
44598: EMPTY
44599: LIST
44600: LIST
44601: PUSH
44602: LD_INT 2
44604: NEG
44605: PUSH
44606: LD_INT 1
44608: PUSH
44609: EMPTY
44610: LIST
44611: LIST
44612: PUSH
44613: EMPTY
44614: LIST
44615: LIST
44616: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
44617: LD_ADDR_VAR 0 52
44621: PUSH
44622: LD_INT 3
44624: NEG
44625: PUSH
44626: LD_INT 1
44628: NEG
44629: PUSH
44630: EMPTY
44631: LIST
44632: LIST
44633: PUSH
44634: LD_INT 3
44636: NEG
44637: PUSH
44638: LD_INT 2
44640: NEG
44641: PUSH
44642: EMPTY
44643: LIST
44644: LIST
44645: PUSH
44646: EMPTY
44647: LIST
44648: LIST
44649: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44650: LD_ADDR_VAR 0 53
44654: PUSH
44655: LD_INT 1
44657: NEG
44658: PUSH
44659: LD_INT 3
44661: NEG
44662: PUSH
44663: EMPTY
44664: LIST
44665: LIST
44666: PUSH
44667: LD_INT 0
44669: PUSH
44670: LD_INT 3
44672: NEG
44673: PUSH
44674: EMPTY
44675: LIST
44676: LIST
44677: PUSH
44678: LD_INT 1
44680: PUSH
44681: LD_INT 2
44683: NEG
44684: PUSH
44685: EMPTY
44686: LIST
44687: LIST
44688: PUSH
44689: EMPTY
44690: LIST
44691: LIST
44692: LIST
44693: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
44694: LD_ADDR_VAR 0 54
44698: PUSH
44699: LD_INT 2
44701: PUSH
44702: LD_INT 1
44704: NEG
44705: PUSH
44706: EMPTY
44707: LIST
44708: LIST
44709: PUSH
44710: LD_INT 3
44712: PUSH
44713: LD_INT 0
44715: PUSH
44716: EMPTY
44717: LIST
44718: LIST
44719: PUSH
44720: LD_INT 3
44722: PUSH
44723: LD_INT 1
44725: PUSH
44726: EMPTY
44727: LIST
44728: LIST
44729: PUSH
44730: EMPTY
44731: LIST
44732: LIST
44733: LIST
44734: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
44735: LD_ADDR_VAR 0 55
44739: PUSH
44740: LD_INT 3
44742: PUSH
44743: LD_INT 2
44745: PUSH
44746: EMPTY
44747: LIST
44748: LIST
44749: PUSH
44750: LD_INT 3
44752: PUSH
44753: LD_INT 3
44755: PUSH
44756: EMPTY
44757: LIST
44758: LIST
44759: PUSH
44760: LD_INT 2
44762: PUSH
44763: LD_INT 3
44765: PUSH
44766: EMPTY
44767: LIST
44768: LIST
44769: PUSH
44770: EMPTY
44771: LIST
44772: LIST
44773: LIST
44774: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
44775: LD_ADDR_VAR 0 56
44779: PUSH
44780: LD_INT 1
44782: PUSH
44783: LD_INT 3
44785: PUSH
44786: EMPTY
44787: LIST
44788: LIST
44789: PUSH
44790: LD_INT 0
44792: PUSH
44793: LD_INT 3
44795: PUSH
44796: EMPTY
44797: LIST
44798: LIST
44799: PUSH
44800: LD_INT 1
44802: NEG
44803: PUSH
44804: LD_INT 2
44806: PUSH
44807: EMPTY
44808: LIST
44809: LIST
44810: PUSH
44811: EMPTY
44812: LIST
44813: LIST
44814: LIST
44815: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
44816: LD_ADDR_VAR 0 57
44820: PUSH
44821: LD_INT 2
44823: NEG
44824: PUSH
44825: LD_INT 1
44827: PUSH
44828: EMPTY
44829: LIST
44830: LIST
44831: PUSH
44832: LD_INT 3
44834: NEG
44835: PUSH
44836: LD_INT 0
44838: PUSH
44839: EMPTY
44840: LIST
44841: LIST
44842: PUSH
44843: LD_INT 3
44845: NEG
44846: PUSH
44847: LD_INT 1
44849: NEG
44850: PUSH
44851: EMPTY
44852: LIST
44853: LIST
44854: PUSH
44855: EMPTY
44856: LIST
44857: LIST
44858: LIST
44859: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
44860: LD_ADDR_VAR 0 58
44864: PUSH
44865: LD_INT 2
44867: NEG
44868: PUSH
44869: LD_INT 3
44871: NEG
44872: PUSH
44873: EMPTY
44874: LIST
44875: LIST
44876: PUSH
44877: LD_INT 3
44879: NEG
44880: PUSH
44881: LD_INT 2
44883: NEG
44884: PUSH
44885: EMPTY
44886: LIST
44887: LIST
44888: PUSH
44889: LD_INT 3
44891: NEG
44892: PUSH
44893: LD_INT 3
44895: NEG
44896: PUSH
44897: EMPTY
44898: LIST
44899: LIST
44900: PUSH
44901: EMPTY
44902: LIST
44903: LIST
44904: LIST
44905: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
44906: LD_ADDR_VAR 0 59
44910: PUSH
44911: LD_INT 1
44913: NEG
44914: PUSH
44915: LD_INT 2
44917: NEG
44918: PUSH
44919: EMPTY
44920: LIST
44921: LIST
44922: PUSH
44923: LD_INT 0
44925: PUSH
44926: LD_INT 2
44928: NEG
44929: PUSH
44930: EMPTY
44931: LIST
44932: LIST
44933: PUSH
44934: LD_INT 1
44936: PUSH
44937: LD_INT 1
44939: NEG
44940: PUSH
44941: EMPTY
44942: LIST
44943: LIST
44944: PUSH
44945: EMPTY
44946: LIST
44947: LIST
44948: LIST
44949: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
44950: LD_ADDR_VAR 0 60
44954: PUSH
44955: LD_INT 1
44957: PUSH
44958: LD_INT 1
44960: NEG
44961: PUSH
44962: EMPTY
44963: LIST
44964: LIST
44965: PUSH
44966: LD_INT 2
44968: PUSH
44969: LD_INT 0
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: PUSH
44976: LD_INT 2
44978: PUSH
44979: LD_INT 1
44981: PUSH
44982: EMPTY
44983: LIST
44984: LIST
44985: PUSH
44986: EMPTY
44987: LIST
44988: LIST
44989: LIST
44990: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
44991: LD_ADDR_VAR 0 61
44995: PUSH
44996: LD_INT 2
44998: PUSH
44999: LD_INT 1
45001: PUSH
45002: EMPTY
45003: LIST
45004: LIST
45005: PUSH
45006: LD_INT 2
45008: PUSH
45009: LD_INT 2
45011: PUSH
45012: EMPTY
45013: LIST
45014: LIST
45015: PUSH
45016: LD_INT 1
45018: PUSH
45019: LD_INT 2
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PUSH
45026: EMPTY
45027: LIST
45028: LIST
45029: LIST
45030: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
45031: LD_ADDR_VAR 0 62
45035: PUSH
45036: LD_INT 1
45038: PUSH
45039: LD_INT 2
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: PUSH
45046: LD_INT 0
45048: PUSH
45049: LD_INT 2
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: PUSH
45056: LD_INT 1
45058: NEG
45059: PUSH
45060: LD_INT 1
45062: PUSH
45063: EMPTY
45064: LIST
45065: LIST
45066: PUSH
45067: EMPTY
45068: LIST
45069: LIST
45070: LIST
45071: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
45072: LD_ADDR_VAR 0 63
45076: PUSH
45077: LD_INT 1
45079: NEG
45080: PUSH
45081: LD_INT 1
45083: PUSH
45084: EMPTY
45085: LIST
45086: LIST
45087: PUSH
45088: LD_INT 2
45090: NEG
45091: PUSH
45092: LD_INT 0
45094: PUSH
45095: EMPTY
45096: LIST
45097: LIST
45098: PUSH
45099: LD_INT 2
45101: NEG
45102: PUSH
45103: LD_INT 1
45105: NEG
45106: PUSH
45107: EMPTY
45108: LIST
45109: LIST
45110: PUSH
45111: EMPTY
45112: LIST
45113: LIST
45114: LIST
45115: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45116: LD_ADDR_VAR 0 64
45120: PUSH
45121: LD_INT 1
45123: NEG
45124: PUSH
45125: LD_INT 2
45127: NEG
45128: PUSH
45129: EMPTY
45130: LIST
45131: LIST
45132: PUSH
45133: LD_INT 2
45135: NEG
45136: PUSH
45137: LD_INT 1
45139: NEG
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: LD_INT 2
45147: NEG
45148: PUSH
45149: LD_INT 2
45151: NEG
45152: PUSH
45153: EMPTY
45154: LIST
45155: LIST
45156: PUSH
45157: EMPTY
45158: LIST
45159: LIST
45160: LIST
45161: ST_TO_ADDR
// end ; 2 :
45162: GO 48428
45164: LD_INT 2
45166: DOUBLE
45167: EQUAL
45168: IFTRUE 45172
45170: GO 48427
45172: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
45173: LD_ADDR_VAR 0 29
45177: PUSH
45178: LD_INT 4
45180: PUSH
45181: LD_INT 0
45183: PUSH
45184: EMPTY
45185: LIST
45186: LIST
45187: PUSH
45188: LD_INT 4
45190: PUSH
45191: LD_INT 1
45193: NEG
45194: PUSH
45195: EMPTY
45196: LIST
45197: LIST
45198: PUSH
45199: LD_INT 5
45201: PUSH
45202: LD_INT 0
45204: PUSH
45205: EMPTY
45206: LIST
45207: LIST
45208: PUSH
45209: LD_INT 5
45211: PUSH
45212: LD_INT 1
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: PUSH
45219: LD_INT 4
45221: PUSH
45222: LD_INT 1
45224: PUSH
45225: EMPTY
45226: LIST
45227: LIST
45228: PUSH
45229: LD_INT 3
45231: PUSH
45232: LD_INT 0
45234: PUSH
45235: EMPTY
45236: LIST
45237: LIST
45238: PUSH
45239: LD_INT 3
45241: PUSH
45242: LD_INT 1
45244: NEG
45245: PUSH
45246: EMPTY
45247: LIST
45248: LIST
45249: PUSH
45250: LD_INT 3
45252: PUSH
45253: LD_INT 2
45255: NEG
45256: PUSH
45257: EMPTY
45258: LIST
45259: LIST
45260: PUSH
45261: LD_INT 5
45263: PUSH
45264: LD_INT 2
45266: PUSH
45267: EMPTY
45268: LIST
45269: LIST
45270: PUSH
45271: LD_INT 3
45273: PUSH
45274: LD_INT 3
45276: PUSH
45277: EMPTY
45278: LIST
45279: LIST
45280: PUSH
45281: LD_INT 3
45283: PUSH
45284: LD_INT 2
45286: PUSH
45287: EMPTY
45288: LIST
45289: LIST
45290: PUSH
45291: LD_INT 4
45293: PUSH
45294: LD_INT 3
45296: PUSH
45297: EMPTY
45298: LIST
45299: LIST
45300: PUSH
45301: LD_INT 4
45303: PUSH
45304: LD_INT 4
45306: PUSH
45307: EMPTY
45308: LIST
45309: LIST
45310: PUSH
45311: LD_INT 3
45313: PUSH
45314: LD_INT 4
45316: PUSH
45317: EMPTY
45318: LIST
45319: LIST
45320: PUSH
45321: LD_INT 2
45323: PUSH
45324: LD_INT 3
45326: PUSH
45327: EMPTY
45328: LIST
45329: LIST
45330: PUSH
45331: LD_INT 2
45333: PUSH
45334: LD_INT 2
45336: PUSH
45337: EMPTY
45338: LIST
45339: LIST
45340: PUSH
45341: LD_INT 4
45343: PUSH
45344: LD_INT 2
45346: PUSH
45347: EMPTY
45348: LIST
45349: LIST
45350: PUSH
45351: LD_INT 2
45353: PUSH
45354: LD_INT 4
45356: PUSH
45357: EMPTY
45358: LIST
45359: LIST
45360: PUSH
45361: LD_INT 0
45363: PUSH
45364: LD_INT 4
45366: PUSH
45367: EMPTY
45368: LIST
45369: LIST
45370: PUSH
45371: LD_INT 0
45373: PUSH
45374: LD_INT 3
45376: PUSH
45377: EMPTY
45378: LIST
45379: LIST
45380: PUSH
45381: LD_INT 1
45383: PUSH
45384: LD_INT 4
45386: PUSH
45387: EMPTY
45388: LIST
45389: LIST
45390: PUSH
45391: LD_INT 1
45393: PUSH
45394: LD_INT 5
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: PUSH
45401: LD_INT 0
45403: PUSH
45404: LD_INT 5
45406: PUSH
45407: EMPTY
45408: LIST
45409: LIST
45410: PUSH
45411: LD_INT 1
45413: NEG
45414: PUSH
45415: LD_INT 4
45417: PUSH
45418: EMPTY
45419: LIST
45420: LIST
45421: PUSH
45422: LD_INT 1
45424: NEG
45425: PUSH
45426: LD_INT 3
45428: PUSH
45429: EMPTY
45430: LIST
45431: LIST
45432: PUSH
45433: LD_INT 2
45435: PUSH
45436: LD_INT 5
45438: PUSH
45439: EMPTY
45440: LIST
45441: LIST
45442: PUSH
45443: LD_INT 2
45445: NEG
45446: PUSH
45447: LD_INT 3
45449: PUSH
45450: EMPTY
45451: LIST
45452: LIST
45453: PUSH
45454: LD_INT 3
45456: NEG
45457: PUSH
45458: LD_INT 0
45460: PUSH
45461: EMPTY
45462: LIST
45463: LIST
45464: PUSH
45465: LD_INT 3
45467: NEG
45468: PUSH
45469: LD_INT 1
45471: NEG
45472: PUSH
45473: EMPTY
45474: LIST
45475: LIST
45476: PUSH
45477: LD_INT 2
45479: NEG
45480: PUSH
45481: LD_INT 0
45483: PUSH
45484: EMPTY
45485: LIST
45486: LIST
45487: PUSH
45488: LD_INT 2
45490: NEG
45491: PUSH
45492: LD_INT 1
45494: PUSH
45495: EMPTY
45496: LIST
45497: LIST
45498: PUSH
45499: LD_INT 3
45501: NEG
45502: PUSH
45503: LD_INT 1
45505: PUSH
45506: EMPTY
45507: LIST
45508: LIST
45509: PUSH
45510: LD_INT 4
45512: NEG
45513: PUSH
45514: LD_INT 0
45516: PUSH
45517: EMPTY
45518: LIST
45519: LIST
45520: PUSH
45521: LD_INT 4
45523: NEG
45524: PUSH
45525: LD_INT 1
45527: NEG
45528: PUSH
45529: EMPTY
45530: LIST
45531: LIST
45532: PUSH
45533: LD_INT 4
45535: NEG
45536: PUSH
45537: LD_INT 2
45539: NEG
45540: PUSH
45541: EMPTY
45542: LIST
45543: LIST
45544: PUSH
45545: LD_INT 2
45547: NEG
45548: PUSH
45549: LD_INT 2
45551: PUSH
45552: EMPTY
45553: LIST
45554: LIST
45555: PUSH
45556: LD_INT 4
45558: NEG
45559: PUSH
45560: LD_INT 4
45562: NEG
45563: PUSH
45564: EMPTY
45565: LIST
45566: LIST
45567: PUSH
45568: LD_INT 4
45570: NEG
45571: PUSH
45572: LD_INT 5
45574: NEG
45575: PUSH
45576: EMPTY
45577: LIST
45578: LIST
45579: PUSH
45580: LD_INT 3
45582: NEG
45583: PUSH
45584: LD_INT 4
45586: NEG
45587: PUSH
45588: EMPTY
45589: LIST
45590: LIST
45591: PUSH
45592: LD_INT 3
45594: NEG
45595: PUSH
45596: LD_INT 3
45598: NEG
45599: PUSH
45600: EMPTY
45601: LIST
45602: LIST
45603: PUSH
45604: LD_INT 4
45606: NEG
45607: PUSH
45608: LD_INT 3
45610: NEG
45611: PUSH
45612: EMPTY
45613: LIST
45614: LIST
45615: PUSH
45616: LD_INT 5
45618: NEG
45619: PUSH
45620: LD_INT 4
45622: NEG
45623: PUSH
45624: EMPTY
45625: LIST
45626: LIST
45627: PUSH
45628: LD_INT 5
45630: NEG
45631: PUSH
45632: LD_INT 5
45634: NEG
45635: PUSH
45636: EMPTY
45637: LIST
45638: LIST
45639: PUSH
45640: LD_INT 3
45642: NEG
45643: PUSH
45644: LD_INT 5
45646: NEG
45647: PUSH
45648: EMPTY
45649: LIST
45650: LIST
45651: PUSH
45652: LD_INT 5
45654: NEG
45655: PUSH
45656: LD_INT 3
45658: NEG
45659: PUSH
45660: EMPTY
45661: LIST
45662: LIST
45663: PUSH
45664: EMPTY
45665: LIST
45666: LIST
45667: LIST
45668: LIST
45669: LIST
45670: LIST
45671: LIST
45672: LIST
45673: LIST
45674: LIST
45675: LIST
45676: LIST
45677: LIST
45678: LIST
45679: LIST
45680: LIST
45681: LIST
45682: LIST
45683: LIST
45684: LIST
45685: LIST
45686: LIST
45687: LIST
45688: LIST
45689: LIST
45690: LIST
45691: LIST
45692: LIST
45693: LIST
45694: LIST
45695: LIST
45696: LIST
45697: LIST
45698: LIST
45699: LIST
45700: LIST
45701: LIST
45702: LIST
45703: LIST
45704: LIST
45705: LIST
45706: LIST
45707: LIST
45708: LIST
45709: LIST
45710: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
45711: LD_ADDR_VAR 0 30
45715: PUSH
45716: LD_INT 4
45718: PUSH
45719: LD_INT 4
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 4
45728: PUSH
45729: LD_INT 3
45731: PUSH
45732: EMPTY
45733: LIST
45734: LIST
45735: PUSH
45736: LD_INT 5
45738: PUSH
45739: LD_INT 4
45741: PUSH
45742: EMPTY
45743: LIST
45744: LIST
45745: PUSH
45746: LD_INT 5
45748: PUSH
45749: LD_INT 5
45751: PUSH
45752: EMPTY
45753: LIST
45754: LIST
45755: PUSH
45756: LD_INT 4
45758: PUSH
45759: LD_INT 5
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: PUSH
45766: LD_INT 3
45768: PUSH
45769: LD_INT 4
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: PUSH
45776: LD_INT 3
45778: PUSH
45779: LD_INT 3
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PUSH
45786: LD_INT 5
45788: PUSH
45789: LD_INT 3
45791: PUSH
45792: EMPTY
45793: LIST
45794: LIST
45795: PUSH
45796: LD_INT 3
45798: PUSH
45799: LD_INT 5
45801: PUSH
45802: EMPTY
45803: LIST
45804: LIST
45805: PUSH
45806: LD_INT 0
45808: PUSH
45809: LD_INT 3
45811: PUSH
45812: EMPTY
45813: LIST
45814: LIST
45815: PUSH
45816: LD_INT 0
45818: PUSH
45819: LD_INT 2
45821: PUSH
45822: EMPTY
45823: LIST
45824: LIST
45825: PUSH
45826: LD_INT 1
45828: PUSH
45829: LD_INT 3
45831: PUSH
45832: EMPTY
45833: LIST
45834: LIST
45835: PUSH
45836: LD_INT 1
45838: PUSH
45839: LD_INT 4
45841: PUSH
45842: EMPTY
45843: LIST
45844: LIST
45845: PUSH
45846: LD_INT 0
45848: PUSH
45849: LD_INT 4
45851: PUSH
45852: EMPTY
45853: LIST
45854: LIST
45855: PUSH
45856: LD_INT 1
45858: NEG
45859: PUSH
45860: LD_INT 3
45862: PUSH
45863: EMPTY
45864: LIST
45865: LIST
45866: PUSH
45867: LD_INT 1
45869: NEG
45870: PUSH
45871: LD_INT 2
45873: PUSH
45874: EMPTY
45875: LIST
45876: LIST
45877: PUSH
45878: LD_INT 2
45880: PUSH
45881: LD_INT 4
45883: PUSH
45884: EMPTY
45885: LIST
45886: LIST
45887: PUSH
45888: LD_INT 2
45890: NEG
45891: PUSH
45892: LD_INT 2
45894: PUSH
45895: EMPTY
45896: LIST
45897: LIST
45898: PUSH
45899: LD_INT 4
45901: NEG
45902: PUSH
45903: LD_INT 0
45905: PUSH
45906: EMPTY
45907: LIST
45908: LIST
45909: PUSH
45910: LD_INT 4
45912: NEG
45913: PUSH
45914: LD_INT 1
45916: NEG
45917: PUSH
45918: EMPTY
45919: LIST
45920: LIST
45921: PUSH
45922: LD_INT 3
45924: NEG
45925: PUSH
45926: LD_INT 0
45928: PUSH
45929: EMPTY
45930: LIST
45931: LIST
45932: PUSH
45933: LD_INT 3
45935: NEG
45936: PUSH
45937: LD_INT 1
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: PUSH
45944: LD_INT 4
45946: NEG
45947: PUSH
45948: LD_INT 1
45950: PUSH
45951: EMPTY
45952: LIST
45953: LIST
45954: PUSH
45955: LD_INT 5
45957: NEG
45958: PUSH
45959: LD_INT 0
45961: PUSH
45962: EMPTY
45963: LIST
45964: LIST
45965: PUSH
45966: LD_INT 5
45968: NEG
45969: PUSH
45970: LD_INT 1
45972: NEG
45973: PUSH
45974: EMPTY
45975: LIST
45976: LIST
45977: PUSH
45978: LD_INT 5
45980: NEG
45981: PUSH
45982: LD_INT 2
45984: NEG
45985: PUSH
45986: EMPTY
45987: LIST
45988: LIST
45989: PUSH
45990: LD_INT 3
45992: NEG
45993: PUSH
45994: LD_INT 2
45996: PUSH
45997: EMPTY
45998: LIST
45999: LIST
46000: PUSH
46001: LD_INT 3
46003: NEG
46004: PUSH
46005: LD_INT 3
46007: NEG
46008: PUSH
46009: EMPTY
46010: LIST
46011: LIST
46012: PUSH
46013: LD_INT 3
46015: NEG
46016: PUSH
46017: LD_INT 4
46019: NEG
46020: PUSH
46021: EMPTY
46022: LIST
46023: LIST
46024: PUSH
46025: LD_INT 2
46027: NEG
46028: PUSH
46029: LD_INT 3
46031: NEG
46032: PUSH
46033: EMPTY
46034: LIST
46035: LIST
46036: PUSH
46037: LD_INT 2
46039: NEG
46040: PUSH
46041: LD_INT 2
46043: NEG
46044: PUSH
46045: EMPTY
46046: LIST
46047: LIST
46048: PUSH
46049: LD_INT 3
46051: NEG
46052: PUSH
46053: LD_INT 2
46055: NEG
46056: PUSH
46057: EMPTY
46058: LIST
46059: LIST
46060: PUSH
46061: LD_INT 4
46063: NEG
46064: PUSH
46065: LD_INT 3
46067: NEG
46068: PUSH
46069: EMPTY
46070: LIST
46071: LIST
46072: PUSH
46073: LD_INT 4
46075: NEG
46076: PUSH
46077: LD_INT 4
46079: NEG
46080: PUSH
46081: EMPTY
46082: LIST
46083: LIST
46084: PUSH
46085: LD_INT 2
46087: NEG
46088: PUSH
46089: LD_INT 4
46091: NEG
46092: PUSH
46093: EMPTY
46094: LIST
46095: LIST
46096: PUSH
46097: LD_INT 4
46099: NEG
46100: PUSH
46101: LD_INT 2
46103: NEG
46104: PUSH
46105: EMPTY
46106: LIST
46107: LIST
46108: PUSH
46109: LD_INT 0
46111: PUSH
46112: LD_INT 4
46114: NEG
46115: PUSH
46116: EMPTY
46117: LIST
46118: LIST
46119: PUSH
46120: LD_INT 0
46122: PUSH
46123: LD_INT 5
46125: NEG
46126: PUSH
46127: EMPTY
46128: LIST
46129: LIST
46130: PUSH
46131: LD_INT 1
46133: PUSH
46134: LD_INT 4
46136: NEG
46137: PUSH
46138: EMPTY
46139: LIST
46140: LIST
46141: PUSH
46142: LD_INT 1
46144: PUSH
46145: LD_INT 3
46147: NEG
46148: PUSH
46149: EMPTY
46150: LIST
46151: LIST
46152: PUSH
46153: LD_INT 0
46155: PUSH
46156: LD_INT 3
46158: NEG
46159: PUSH
46160: EMPTY
46161: LIST
46162: LIST
46163: PUSH
46164: LD_INT 1
46166: NEG
46167: PUSH
46168: LD_INT 4
46170: NEG
46171: PUSH
46172: EMPTY
46173: LIST
46174: LIST
46175: PUSH
46176: LD_INT 1
46178: NEG
46179: PUSH
46180: LD_INT 5
46182: NEG
46183: PUSH
46184: EMPTY
46185: LIST
46186: LIST
46187: PUSH
46188: LD_INT 2
46190: PUSH
46191: LD_INT 3
46193: NEG
46194: PUSH
46195: EMPTY
46196: LIST
46197: LIST
46198: PUSH
46199: LD_INT 2
46201: NEG
46202: PUSH
46203: LD_INT 5
46205: NEG
46206: PUSH
46207: EMPTY
46208: LIST
46209: LIST
46210: PUSH
46211: EMPTY
46212: LIST
46213: LIST
46214: LIST
46215: LIST
46216: LIST
46217: LIST
46218: LIST
46219: LIST
46220: LIST
46221: LIST
46222: LIST
46223: LIST
46224: LIST
46225: LIST
46226: LIST
46227: LIST
46228: LIST
46229: LIST
46230: LIST
46231: LIST
46232: LIST
46233: LIST
46234: LIST
46235: LIST
46236: LIST
46237: LIST
46238: LIST
46239: LIST
46240: LIST
46241: LIST
46242: LIST
46243: LIST
46244: LIST
46245: LIST
46246: LIST
46247: LIST
46248: LIST
46249: LIST
46250: LIST
46251: LIST
46252: LIST
46253: LIST
46254: LIST
46255: LIST
46256: LIST
46257: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
46258: LD_ADDR_VAR 0 31
46262: PUSH
46263: LD_INT 0
46265: PUSH
46266: LD_INT 4
46268: PUSH
46269: EMPTY
46270: LIST
46271: LIST
46272: PUSH
46273: LD_INT 0
46275: PUSH
46276: LD_INT 3
46278: PUSH
46279: EMPTY
46280: LIST
46281: LIST
46282: PUSH
46283: LD_INT 1
46285: PUSH
46286: LD_INT 4
46288: PUSH
46289: EMPTY
46290: LIST
46291: LIST
46292: PUSH
46293: LD_INT 1
46295: PUSH
46296: LD_INT 5
46298: PUSH
46299: EMPTY
46300: LIST
46301: LIST
46302: PUSH
46303: LD_INT 0
46305: PUSH
46306: LD_INT 5
46308: PUSH
46309: EMPTY
46310: LIST
46311: LIST
46312: PUSH
46313: LD_INT 1
46315: NEG
46316: PUSH
46317: LD_INT 4
46319: PUSH
46320: EMPTY
46321: LIST
46322: LIST
46323: PUSH
46324: LD_INT 1
46326: NEG
46327: PUSH
46328: LD_INT 3
46330: PUSH
46331: EMPTY
46332: LIST
46333: LIST
46334: PUSH
46335: LD_INT 2
46337: PUSH
46338: LD_INT 5
46340: PUSH
46341: EMPTY
46342: LIST
46343: LIST
46344: PUSH
46345: LD_INT 2
46347: NEG
46348: PUSH
46349: LD_INT 3
46351: PUSH
46352: EMPTY
46353: LIST
46354: LIST
46355: PUSH
46356: LD_INT 3
46358: NEG
46359: PUSH
46360: LD_INT 0
46362: PUSH
46363: EMPTY
46364: LIST
46365: LIST
46366: PUSH
46367: LD_INT 3
46369: NEG
46370: PUSH
46371: LD_INT 1
46373: NEG
46374: PUSH
46375: EMPTY
46376: LIST
46377: LIST
46378: PUSH
46379: LD_INT 2
46381: NEG
46382: PUSH
46383: LD_INT 0
46385: PUSH
46386: EMPTY
46387: LIST
46388: LIST
46389: PUSH
46390: LD_INT 2
46392: NEG
46393: PUSH
46394: LD_INT 1
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PUSH
46401: LD_INT 3
46403: NEG
46404: PUSH
46405: LD_INT 1
46407: PUSH
46408: EMPTY
46409: LIST
46410: LIST
46411: PUSH
46412: LD_INT 4
46414: NEG
46415: PUSH
46416: LD_INT 0
46418: PUSH
46419: EMPTY
46420: LIST
46421: LIST
46422: PUSH
46423: LD_INT 4
46425: NEG
46426: PUSH
46427: LD_INT 1
46429: NEG
46430: PUSH
46431: EMPTY
46432: LIST
46433: LIST
46434: PUSH
46435: LD_INT 4
46437: NEG
46438: PUSH
46439: LD_INT 2
46441: NEG
46442: PUSH
46443: EMPTY
46444: LIST
46445: LIST
46446: PUSH
46447: LD_INT 2
46449: NEG
46450: PUSH
46451: LD_INT 2
46453: PUSH
46454: EMPTY
46455: LIST
46456: LIST
46457: PUSH
46458: LD_INT 4
46460: NEG
46461: PUSH
46462: LD_INT 4
46464: NEG
46465: PUSH
46466: EMPTY
46467: LIST
46468: LIST
46469: PUSH
46470: LD_INT 4
46472: NEG
46473: PUSH
46474: LD_INT 5
46476: NEG
46477: PUSH
46478: EMPTY
46479: LIST
46480: LIST
46481: PUSH
46482: LD_INT 3
46484: NEG
46485: PUSH
46486: LD_INT 4
46488: NEG
46489: PUSH
46490: EMPTY
46491: LIST
46492: LIST
46493: PUSH
46494: LD_INT 3
46496: NEG
46497: PUSH
46498: LD_INT 3
46500: NEG
46501: PUSH
46502: EMPTY
46503: LIST
46504: LIST
46505: PUSH
46506: LD_INT 4
46508: NEG
46509: PUSH
46510: LD_INT 3
46512: NEG
46513: PUSH
46514: EMPTY
46515: LIST
46516: LIST
46517: PUSH
46518: LD_INT 5
46520: NEG
46521: PUSH
46522: LD_INT 4
46524: NEG
46525: PUSH
46526: EMPTY
46527: LIST
46528: LIST
46529: PUSH
46530: LD_INT 5
46532: NEG
46533: PUSH
46534: LD_INT 5
46536: NEG
46537: PUSH
46538: EMPTY
46539: LIST
46540: LIST
46541: PUSH
46542: LD_INT 3
46544: NEG
46545: PUSH
46546: LD_INT 5
46548: NEG
46549: PUSH
46550: EMPTY
46551: LIST
46552: LIST
46553: PUSH
46554: LD_INT 5
46556: NEG
46557: PUSH
46558: LD_INT 3
46560: NEG
46561: PUSH
46562: EMPTY
46563: LIST
46564: LIST
46565: PUSH
46566: LD_INT 0
46568: PUSH
46569: LD_INT 3
46571: NEG
46572: PUSH
46573: EMPTY
46574: LIST
46575: LIST
46576: PUSH
46577: LD_INT 0
46579: PUSH
46580: LD_INT 4
46582: NEG
46583: PUSH
46584: EMPTY
46585: LIST
46586: LIST
46587: PUSH
46588: LD_INT 1
46590: PUSH
46591: LD_INT 3
46593: NEG
46594: PUSH
46595: EMPTY
46596: LIST
46597: LIST
46598: PUSH
46599: LD_INT 1
46601: PUSH
46602: LD_INT 2
46604: NEG
46605: PUSH
46606: EMPTY
46607: LIST
46608: LIST
46609: PUSH
46610: LD_INT 0
46612: PUSH
46613: LD_INT 2
46615: NEG
46616: PUSH
46617: EMPTY
46618: LIST
46619: LIST
46620: PUSH
46621: LD_INT 1
46623: NEG
46624: PUSH
46625: LD_INT 3
46627: NEG
46628: PUSH
46629: EMPTY
46630: LIST
46631: LIST
46632: PUSH
46633: LD_INT 1
46635: NEG
46636: PUSH
46637: LD_INT 4
46639: NEG
46640: PUSH
46641: EMPTY
46642: LIST
46643: LIST
46644: PUSH
46645: LD_INT 2
46647: PUSH
46648: LD_INT 2
46650: NEG
46651: PUSH
46652: EMPTY
46653: LIST
46654: LIST
46655: PUSH
46656: LD_INT 2
46658: NEG
46659: PUSH
46660: LD_INT 4
46662: NEG
46663: PUSH
46664: EMPTY
46665: LIST
46666: LIST
46667: PUSH
46668: LD_INT 4
46670: PUSH
46671: LD_INT 0
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: PUSH
46678: LD_INT 4
46680: PUSH
46681: LD_INT 1
46683: NEG
46684: PUSH
46685: EMPTY
46686: LIST
46687: LIST
46688: PUSH
46689: LD_INT 5
46691: PUSH
46692: LD_INT 0
46694: PUSH
46695: EMPTY
46696: LIST
46697: LIST
46698: PUSH
46699: LD_INT 5
46701: PUSH
46702: LD_INT 1
46704: PUSH
46705: EMPTY
46706: LIST
46707: LIST
46708: PUSH
46709: LD_INT 4
46711: PUSH
46712: LD_INT 1
46714: PUSH
46715: EMPTY
46716: LIST
46717: LIST
46718: PUSH
46719: LD_INT 3
46721: PUSH
46722: LD_INT 0
46724: PUSH
46725: EMPTY
46726: LIST
46727: LIST
46728: PUSH
46729: LD_INT 3
46731: PUSH
46732: LD_INT 1
46734: NEG
46735: PUSH
46736: EMPTY
46737: LIST
46738: LIST
46739: PUSH
46740: LD_INT 3
46742: PUSH
46743: LD_INT 2
46745: NEG
46746: PUSH
46747: EMPTY
46748: LIST
46749: LIST
46750: PUSH
46751: LD_INT 5
46753: PUSH
46754: LD_INT 2
46756: PUSH
46757: EMPTY
46758: LIST
46759: LIST
46760: PUSH
46761: EMPTY
46762: LIST
46763: LIST
46764: LIST
46765: LIST
46766: LIST
46767: LIST
46768: LIST
46769: LIST
46770: LIST
46771: LIST
46772: LIST
46773: LIST
46774: LIST
46775: LIST
46776: LIST
46777: LIST
46778: LIST
46779: LIST
46780: LIST
46781: LIST
46782: LIST
46783: LIST
46784: LIST
46785: LIST
46786: LIST
46787: LIST
46788: LIST
46789: LIST
46790: LIST
46791: LIST
46792: LIST
46793: LIST
46794: LIST
46795: LIST
46796: LIST
46797: LIST
46798: LIST
46799: LIST
46800: LIST
46801: LIST
46802: LIST
46803: LIST
46804: LIST
46805: LIST
46806: LIST
46807: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
46808: LD_ADDR_VAR 0 32
46812: PUSH
46813: LD_INT 4
46815: NEG
46816: PUSH
46817: LD_INT 0
46819: PUSH
46820: EMPTY
46821: LIST
46822: LIST
46823: PUSH
46824: LD_INT 4
46826: NEG
46827: PUSH
46828: LD_INT 1
46830: NEG
46831: PUSH
46832: EMPTY
46833: LIST
46834: LIST
46835: PUSH
46836: LD_INT 3
46838: NEG
46839: PUSH
46840: LD_INT 0
46842: PUSH
46843: EMPTY
46844: LIST
46845: LIST
46846: PUSH
46847: LD_INT 3
46849: NEG
46850: PUSH
46851: LD_INT 1
46853: PUSH
46854: EMPTY
46855: LIST
46856: LIST
46857: PUSH
46858: LD_INT 4
46860: NEG
46861: PUSH
46862: LD_INT 1
46864: PUSH
46865: EMPTY
46866: LIST
46867: LIST
46868: PUSH
46869: LD_INT 5
46871: NEG
46872: PUSH
46873: LD_INT 0
46875: PUSH
46876: EMPTY
46877: LIST
46878: LIST
46879: PUSH
46880: LD_INT 5
46882: NEG
46883: PUSH
46884: LD_INT 1
46886: NEG
46887: PUSH
46888: EMPTY
46889: LIST
46890: LIST
46891: PUSH
46892: LD_INT 5
46894: NEG
46895: PUSH
46896: LD_INT 2
46898: NEG
46899: PUSH
46900: EMPTY
46901: LIST
46902: LIST
46903: PUSH
46904: LD_INT 3
46906: NEG
46907: PUSH
46908: LD_INT 2
46910: PUSH
46911: EMPTY
46912: LIST
46913: LIST
46914: PUSH
46915: LD_INT 3
46917: NEG
46918: PUSH
46919: LD_INT 3
46921: NEG
46922: PUSH
46923: EMPTY
46924: LIST
46925: LIST
46926: PUSH
46927: LD_INT 3
46929: NEG
46930: PUSH
46931: LD_INT 4
46933: NEG
46934: PUSH
46935: EMPTY
46936: LIST
46937: LIST
46938: PUSH
46939: LD_INT 2
46941: NEG
46942: PUSH
46943: LD_INT 3
46945: NEG
46946: PUSH
46947: EMPTY
46948: LIST
46949: LIST
46950: PUSH
46951: LD_INT 2
46953: NEG
46954: PUSH
46955: LD_INT 2
46957: NEG
46958: PUSH
46959: EMPTY
46960: LIST
46961: LIST
46962: PUSH
46963: LD_INT 3
46965: NEG
46966: PUSH
46967: LD_INT 2
46969: NEG
46970: PUSH
46971: EMPTY
46972: LIST
46973: LIST
46974: PUSH
46975: LD_INT 4
46977: NEG
46978: PUSH
46979: LD_INT 3
46981: NEG
46982: PUSH
46983: EMPTY
46984: LIST
46985: LIST
46986: PUSH
46987: LD_INT 4
46989: NEG
46990: PUSH
46991: LD_INT 4
46993: NEG
46994: PUSH
46995: EMPTY
46996: LIST
46997: LIST
46998: PUSH
46999: LD_INT 2
47001: NEG
47002: PUSH
47003: LD_INT 4
47005: NEG
47006: PUSH
47007: EMPTY
47008: LIST
47009: LIST
47010: PUSH
47011: LD_INT 4
47013: NEG
47014: PUSH
47015: LD_INT 2
47017: NEG
47018: PUSH
47019: EMPTY
47020: LIST
47021: LIST
47022: PUSH
47023: LD_INT 0
47025: PUSH
47026: LD_INT 4
47028: NEG
47029: PUSH
47030: EMPTY
47031: LIST
47032: LIST
47033: PUSH
47034: LD_INT 0
47036: PUSH
47037: LD_INT 5
47039: NEG
47040: PUSH
47041: EMPTY
47042: LIST
47043: LIST
47044: PUSH
47045: LD_INT 1
47047: PUSH
47048: LD_INT 4
47050: NEG
47051: PUSH
47052: EMPTY
47053: LIST
47054: LIST
47055: PUSH
47056: LD_INT 1
47058: PUSH
47059: LD_INT 3
47061: NEG
47062: PUSH
47063: EMPTY
47064: LIST
47065: LIST
47066: PUSH
47067: LD_INT 0
47069: PUSH
47070: LD_INT 3
47072: NEG
47073: PUSH
47074: EMPTY
47075: LIST
47076: LIST
47077: PUSH
47078: LD_INT 1
47080: NEG
47081: PUSH
47082: LD_INT 4
47084: NEG
47085: PUSH
47086: EMPTY
47087: LIST
47088: LIST
47089: PUSH
47090: LD_INT 1
47092: NEG
47093: PUSH
47094: LD_INT 5
47096: NEG
47097: PUSH
47098: EMPTY
47099: LIST
47100: LIST
47101: PUSH
47102: LD_INT 2
47104: PUSH
47105: LD_INT 3
47107: NEG
47108: PUSH
47109: EMPTY
47110: LIST
47111: LIST
47112: PUSH
47113: LD_INT 2
47115: NEG
47116: PUSH
47117: LD_INT 5
47119: NEG
47120: PUSH
47121: EMPTY
47122: LIST
47123: LIST
47124: PUSH
47125: LD_INT 3
47127: PUSH
47128: LD_INT 0
47130: PUSH
47131: EMPTY
47132: LIST
47133: LIST
47134: PUSH
47135: LD_INT 3
47137: PUSH
47138: LD_INT 1
47140: NEG
47141: PUSH
47142: EMPTY
47143: LIST
47144: LIST
47145: PUSH
47146: LD_INT 4
47148: PUSH
47149: LD_INT 0
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: PUSH
47156: LD_INT 4
47158: PUSH
47159: LD_INT 1
47161: PUSH
47162: EMPTY
47163: LIST
47164: LIST
47165: PUSH
47166: LD_INT 3
47168: PUSH
47169: LD_INT 1
47171: PUSH
47172: EMPTY
47173: LIST
47174: LIST
47175: PUSH
47176: LD_INT 2
47178: PUSH
47179: LD_INT 0
47181: PUSH
47182: EMPTY
47183: LIST
47184: LIST
47185: PUSH
47186: LD_INT 2
47188: PUSH
47189: LD_INT 1
47191: NEG
47192: PUSH
47193: EMPTY
47194: LIST
47195: LIST
47196: PUSH
47197: LD_INT 2
47199: PUSH
47200: LD_INT 2
47202: NEG
47203: PUSH
47204: EMPTY
47205: LIST
47206: LIST
47207: PUSH
47208: LD_INT 4
47210: PUSH
47211: LD_INT 2
47213: PUSH
47214: EMPTY
47215: LIST
47216: LIST
47217: PUSH
47218: LD_INT 4
47220: PUSH
47221: LD_INT 4
47223: PUSH
47224: EMPTY
47225: LIST
47226: LIST
47227: PUSH
47228: LD_INT 4
47230: PUSH
47231: LD_INT 3
47233: PUSH
47234: EMPTY
47235: LIST
47236: LIST
47237: PUSH
47238: LD_INT 5
47240: PUSH
47241: LD_INT 4
47243: PUSH
47244: EMPTY
47245: LIST
47246: LIST
47247: PUSH
47248: LD_INT 5
47250: PUSH
47251: LD_INT 5
47253: PUSH
47254: EMPTY
47255: LIST
47256: LIST
47257: PUSH
47258: LD_INT 4
47260: PUSH
47261: LD_INT 5
47263: PUSH
47264: EMPTY
47265: LIST
47266: LIST
47267: PUSH
47268: LD_INT 3
47270: PUSH
47271: LD_INT 4
47273: PUSH
47274: EMPTY
47275: LIST
47276: LIST
47277: PUSH
47278: LD_INT 3
47280: PUSH
47281: LD_INT 3
47283: PUSH
47284: EMPTY
47285: LIST
47286: LIST
47287: PUSH
47288: LD_INT 5
47290: PUSH
47291: LD_INT 3
47293: PUSH
47294: EMPTY
47295: LIST
47296: LIST
47297: PUSH
47298: LD_INT 3
47300: PUSH
47301: LD_INT 5
47303: PUSH
47304: EMPTY
47305: LIST
47306: LIST
47307: PUSH
47308: EMPTY
47309: LIST
47310: LIST
47311: LIST
47312: LIST
47313: LIST
47314: LIST
47315: LIST
47316: LIST
47317: LIST
47318: LIST
47319: LIST
47320: LIST
47321: LIST
47322: LIST
47323: LIST
47324: LIST
47325: LIST
47326: LIST
47327: LIST
47328: LIST
47329: LIST
47330: LIST
47331: LIST
47332: LIST
47333: LIST
47334: LIST
47335: LIST
47336: LIST
47337: LIST
47338: LIST
47339: LIST
47340: LIST
47341: LIST
47342: LIST
47343: LIST
47344: LIST
47345: LIST
47346: LIST
47347: LIST
47348: LIST
47349: LIST
47350: LIST
47351: LIST
47352: LIST
47353: LIST
47354: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
47355: LD_ADDR_VAR 0 33
47359: PUSH
47360: LD_INT 4
47362: NEG
47363: PUSH
47364: LD_INT 4
47366: NEG
47367: PUSH
47368: EMPTY
47369: LIST
47370: LIST
47371: PUSH
47372: LD_INT 4
47374: NEG
47375: PUSH
47376: LD_INT 5
47378: NEG
47379: PUSH
47380: EMPTY
47381: LIST
47382: LIST
47383: PUSH
47384: LD_INT 3
47386: NEG
47387: PUSH
47388: LD_INT 4
47390: NEG
47391: PUSH
47392: EMPTY
47393: LIST
47394: LIST
47395: PUSH
47396: LD_INT 3
47398: NEG
47399: PUSH
47400: LD_INT 3
47402: NEG
47403: PUSH
47404: EMPTY
47405: LIST
47406: LIST
47407: PUSH
47408: LD_INT 4
47410: NEG
47411: PUSH
47412: LD_INT 3
47414: NEG
47415: PUSH
47416: EMPTY
47417: LIST
47418: LIST
47419: PUSH
47420: LD_INT 5
47422: NEG
47423: PUSH
47424: LD_INT 4
47426: NEG
47427: PUSH
47428: EMPTY
47429: LIST
47430: LIST
47431: PUSH
47432: LD_INT 5
47434: NEG
47435: PUSH
47436: LD_INT 5
47438: NEG
47439: PUSH
47440: EMPTY
47441: LIST
47442: LIST
47443: PUSH
47444: LD_INT 3
47446: NEG
47447: PUSH
47448: LD_INT 5
47450: NEG
47451: PUSH
47452: EMPTY
47453: LIST
47454: LIST
47455: PUSH
47456: LD_INT 5
47458: NEG
47459: PUSH
47460: LD_INT 3
47462: NEG
47463: PUSH
47464: EMPTY
47465: LIST
47466: LIST
47467: PUSH
47468: LD_INT 0
47470: PUSH
47471: LD_INT 3
47473: NEG
47474: PUSH
47475: EMPTY
47476: LIST
47477: LIST
47478: PUSH
47479: LD_INT 0
47481: PUSH
47482: LD_INT 4
47484: NEG
47485: PUSH
47486: EMPTY
47487: LIST
47488: LIST
47489: PUSH
47490: LD_INT 1
47492: PUSH
47493: LD_INT 3
47495: NEG
47496: PUSH
47497: EMPTY
47498: LIST
47499: LIST
47500: PUSH
47501: LD_INT 1
47503: PUSH
47504: LD_INT 2
47506: NEG
47507: PUSH
47508: EMPTY
47509: LIST
47510: LIST
47511: PUSH
47512: LD_INT 0
47514: PUSH
47515: LD_INT 2
47517: NEG
47518: PUSH
47519: EMPTY
47520: LIST
47521: LIST
47522: PUSH
47523: LD_INT 1
47525: NEG
47526: PUSH
47527: LD_INT 3
47529: NEG
47530: PUSH
47531: EMPTY
47532: LIST
47533: LIST
47534: PUSH
47535: LD_INT 1
47537: NEG
47538: PUSH
47539: LD_INT 4
47541: NEG
47542: PUSH
47543: EMPTY
47544: LIST
47545: LIST
47546: PUSH
47547: LD_INT 2
47549: PUSH
47550: LD_INT 2
47552: NEG
47553: PUSH
47554: EMPTY
47555: LIST
47556: LIST
47557: PUSH
47558: LD_INT 2
47560: NEG
47561: PUSH
47562: LD_INT 4
47564: NEG
47565: PUSH
47566: EMPTY
47567: LIST
47568: LIST
47569: PUSH
47570: LD_INT 4
47572: PUSH
47573: LD_INT 0
47575: PUSH
47576: EMPTY
47577: LIST
47578: LIST
47579: PUSH
47580: LD_INT 4
47582: PUSH
47583: LD_INT 1
47585: NEG
47586: PUSH
47587: EMPTY
47588: LIST
47589: LIST
47590: PUSH
47591: LD_INT 5
47593: PUSH
47594: LD_INT 0
47596: PUSH
47597: EMPTY
47598: LIST
47599: LIST
47600: PUSH
47601: LD_INT 5
47603: PUSH
47604: LD_INT 1
47606: PUSH
47607: EMPTY
47608: LIST
47609: LIST
47610: PUSH
47611: LD_INT 4
47613: PUSH
47614: LD_INT 1
47616: PUSH
47617: EMPTY
47618: LIST
47619: LIST
47620: PUSH
47621: LD_INT 3
47623: PUSH
47624: LD_INT 0
47626: PUSH
47627: EMPTY
47628: LIST
47629: LIST
47630: PUSH
47631: LD_INT 3
47633: PUSH
47634: LD_INT 1
47636: NEG
47637: PUSH
47638: EMPTY
47639: LIST
47640: LIST
47641: PUSH
47642: LD_INT 3
47644: PUSH
47645: LD_INT 2
47647: NEG
47648: PUSH
47649: EMPTY
47650: LIST
47651: LIST
47652: PUSH
47653: LD_INT 5
47655: PUSH
47656: LD_INT 2
47658: PUSH
47659: EMPTY
47660: LIST
47661: LIST
47662: PUSH
47663: LD_INT 3
47665: PUSH
47666: LD_INT 3
47668: PUSH
47669: EMPTY
47670: LIST
47671: LIST
47672: PUSH
47673: LD_INT 3
47675: PUSH
47676: LD_INT 2
47678: PUSH
47679: EMPTY
47680: LIST
47681: LIST
47682: PUSH
47683: LD_INT 4
47685: PUSH
47686: LD_INT 3
47688: PUSH
47689: EMPTY
47690: LIST
47691: LIST
47692: PUSH
47693: LD_INT 4
47695: PUSH
47696: LD_INT 4
47698: PUSH
47699: EMPTY
47700: LIST
47701: LIST
47702: PUSH
47703: LD_INT 3
47705: PUSH
47706: LD_INT 4
47708: PUSH
47709: EMPTY
47710: LIST
47711: LIST
47712: PUSH
47713: LD_INT 2
47715: PUSH
47716: LD_INT 3
47718: PUSH
47719: EMPTY
47720: LIST
47721: LIST
47722: PUSH
47723: LD_INT 2
47725: PUSH
47726: LD_INT 2
47728: PUSH
47729: EMPTY
47730: LIST
47731: LIST
47732: PUSH
47733: LD_INT 4
47735: PUSH
47736: LD_INT 2
47738: PUSH
47739: EMPTY
47740: LIST
47741: LIST
47742: PUSH
47743: LD_INT 2
47745: PUSH
47746: LD_INT 4
47748: PUSH
47749: EMPTY
47750: LIST
47751: LIST
47752: PUSH
47753: LD_INT 0
47755: PUSH
47756: LD_INT 4
47758: PUSH
47759: EMPTY
47760: LIST
47761: LIST
47762: PUSH
47763: LD_INT 0
47765: PUSH
47766: LD_INT 3
47768: PUSH
47769: EMPTY
47770: LIST
47771: LIST
47772: PUSH
47773: LD_INT 1
47775: PUSH
47776: LD_INT 4
47778: PUSH
47779: EMPTY
47780: LIST
47781: LIST
47782: PUSH
47783: LD_INT 1
47785: PUSH
47786: LD_INT 5
47788: PUSH
47789: EMPTY
47790: LIST
47791: LIST
47792: PUSH
47793: LD_INT 0
47795: PUSH
47796: LD_INT 5
47798: PUSH
47799: EMPTY
47800: LIST
47801: LIST
47802: PUSH
47803: LD_INT 1
47805: NEG
47806: PUSH
47807: LD_INT 4
47809: PUSH
47810: EMPTY
47811: LIST
47812: LIST
47813: PUSH
47814: LD_INT 1
47816: NEG
47817: PUSH
47818: LD_INT 3
47820: PUSH
47821: EMPTY
47822: LIST
47823: LIST
47824: PUSH
47825: LD_INT 2
47827: PUSH
47828: LD_INT 5
47830: PUSH
47831: EMPTY
47832: LIST
47833: LIST
47834: PUSH
47835: LD_INT 2
47837: NEG
47838: PUSH
47839: LD_INT 3
47841: PUSH
47842: EMPTY
47843: LIST
47844: LIST
47845: PUSH
47846: EMPTY
47847: LIST
47848: LIST
47849: LIST
47850: LIST
47851: LIST
47852: LIST
47853: LIST
47854: LIST
47855: LIST
47856: LIST
47857: LIST
47858: LIST
47859: LIST
47860: LIST
47861: LIST
47862: LIST
47863: LIST
47864: LIST
47865: LIST
47866: LIST
47867: LIST
47868: LIST
47869: LIST
47870: LIST
47871: LIST
47872: LIST
47873: LIST
47874: LIST
47875: LIST
47876: LIST
47877: LIST
47878: LIST
47879: LIST
47880: LIST
47881: LIST
47882: LIST
47883: LIST
47884: LIST
47885: LIST
47886: LIST
47887: LIST
47888: LIST
47889: LIST
47890: LIST
47891: LIST
47892: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
47893: LD_ADDR_VAR 0 34
47897: PUSH
47898: LD_INT 0
47900: PUSH
47901: LD_INT 4
47903: NEG
47904: PUSH
47905: EMPTY
47906: LIST
47907: LIST
47908: PUSH
47909: LD_INT 0
47911: PUSH
47912: LD_INT 5
47914: NEG
47915: PUSH
47916: EMPTY
47917: LIST
47918: LIST
47919: PUSH
47920: LD_INT 1
47922: PUSH
47923: LD_INT 4
47925: NEG
47926: PUSH
47927: EMPTY
47928: LIST
47929: LIST
47930: PUSH
47931: LD_INT 1
47933: PUSH
47934: LD_INT 3
47936: NEG
47937: PUSH
47938: EMPTY
47939: LIST
47940: LIST
47941: PUSH
47942: LD_INT 0
47944: PUSH
47945: LD_INT 3
47947: NEG
47948: PUSH
47949: EMPTY
47950: LIST
47951: LIST
47952: PUSH
47953: LD_INT 1
47955: NEG
47956: PUSH
47957: LD_INT 4
47959: NEG
47960: PUSH
47961: EMPTY
47962: LIST
47963: LIST
47964: PUSH
47965: LD_INT 1
47967: NEG
47968: PUSH
47969: LD_INT 5
47971: NEG
47972: PUSH
47973: EMPTY
47974: LIST
47975: LIST
47976: PUSH
47977: LD_INT 2
47979: PUSH
47980: LD_INT 3
47982: NEG
47983: PUSH
47984: EMPTY
47985: LIST
47986: LIST
47987: PUSH
47988: LD_INT 2
47990: NEG
47991: PUSH
47992: LD_INT 5
47994: NEG
47995: PUSH
47996: EMPTY
47997: LIST
47998: LIST
47999: PUSH
48000: LD_INT 3
48002: PUSH
48003: LD_INT 0
48005: PUSH
48006: EMPTY
48007: LIST
48008: LIST
48009: PUSH
48010: LD_INT 3
48012: PUSH
48013: LD_INT 1
48015: NEG
48016: PUSH
48017: EMPTY
48018: LIST
48019: LIST
48020: PUSH
48021: LD_INT 4
48023: PUSH
48024: LD_INT 0
48026: PUSH
48027: EMPTY
48028: LIST
48029: LIST
48030: PUSH
48031: LD_INT 4
48033: PUSH
48034: LD_INT 1
48036: PUSH
48037: EMPTY
48038: LIST
48039: LIST
48040: PUSH
48041: LD_INT 3
48043: PUSH
48044: LD_INT 1
48046: PUSH
48047: EMPTY
48048: LIST
48049: LIST
48050: PUSH
48051: LD_INT 2
48053: PUSH
48054: LD_INT 0
48056: PUSH
48057: EMPTY
48058: LIST
48059: LIST
48060: PUSH
48061: LD_INT 2
48063: PUSH
48064: LD_INT 1
48066: NEG
48067: PUSH
48068: EMPTY
48069: LIST
48070: LIST
48071: PUSH
48072: LD_INT 2
48074: PUSH
48075: LD_INT 2
48077: NEG
48078: PUSH
48079: EMPTY
48080: LIST
48081: LIST
48082: PUSH
48083: LD_INT 4
48085: PUSH
48086: LD_INT 2
48088: PUSH
48089: EMPTY
48090: LIST
48091: LIST
48092: PUSH
48093: LD_INT 4
48095: PUSH
48096: LD_INT 4
48098: PUSH
48099: EMPTY
48100: LIST
48101: LIST
48102: PUSH
48103: LD_INT 4
48105: PUSH
48106: LD_INT 3
48108: PUSH
48109: EMPTY
48110: LIST
48111: LIST
48112: PUSH
48113: LD_INT 5
48115: PUSH
48116: LD_INT 4
48118: PUSH
48119: EMPTY
48120: LIST
48121: LIST
48122: PUSH
48123: LD_INT 5
48125: PUSH
48126: LD_INT 5
48128: PUSH
48129: EMPTY
48130: LIST
48131: LIST
48132: PUSH
48133: LD_INT 4
48135: PUSH
48136: LD_INT 5
48138: PUSH
48139: EMPTY
48140: LIST
48141: LIST
48142: PUSH
48143: LD_INT 3
48145: PUSH
48146: LD_INT 4
48148: PUSH
48149: EMPTY
48150: LIST
48151: LIST
48152: PUSH
48153: LD_INT 3
48155: PUSH
48156: LD_INT 3
48158: PUSH
48159: EMPTY
48160: LIST
48161: LIST
48162: PUSH
48163: LD_INT 5
48165: PUSH
48166: LD_INT 3
48168: PUSH
48169: EMPTY
48170: LIST
48171: LIST
48172: PUSH
48173: LD_INT 3
48175: PUSH
48176: LD_INT 5
48178: PUSH
48179: EMPTY
48180: LIST
48181: LIST
48182: PUSH
48183: LD_INT 0
48185: PUSH
48186: LD_INT 3
48188: PUSH
48189: EMPTY
48190: LIST
48191: LIST
48192: PUSH
48193: LD_INT 0
48195: PUSH
48196: LD_INT 2
48198: PUSH
48199: EMPTY
48200: LIST
48201: LIST
48202: PUSH
48203: LD_INT 1
48205: PUSH
48206: LD_INT 3
48208: PUSH
48209: EMPTY
48210: LIST
48211: LIST
48212: PUSH
48213: LD_INT 1
48215: PUSH
48216: LD_INT 4
48218: PUSH
48219: EMPTY
48220: LIST
48221: LIST
48222: PUSH
48223: LD_INT 0
48225: PUSH
48226: LD_INT 4
48228: PUSH
48229: EMPTY
48230: LIST
48231: LIST
48232: PUSH
48233: LD_INT 1
48235: NEG
48236: PUSH
48237: LD_INT 3
48239: PUSH
48240: EMPTY
48241: LIST
48242: LIST
48243: PUSH
48244: LD_INT 1
48246: NEG
48247: PUSH
48248: LD_INT 2
48250: PUSH
48251: EMPTY
48252: LIST
48253: LIST
48254: PUSH
48255: LD_INT 2
48257: PUSH
48258: LD_INT 4
48260: PUSH
48261: EMPTY
48262: LIST
48263: LIST
48264: PUSH
48265: LD_INT 2
48267: NEG
48268: PUSH
48269: LD_INT 2
48271: PUSH
48272: EMPTY
48273: LIST
48274: LIST
48275: PUSH
48276: LD_INT 4
48278: NEG
48279: PUSH
48280: LD_INT 0
48282: PUSH
48283: EMPTY
48284: LIST
48285: LIST
48286: PUSH
48287: LD_INT 4
48289: NEG
48290: PUSH
48291: LD_INT 1
48293: NEG
48294: PUSH
48295: EMPTY
48296: LIST
48297: LIST
48298: PUSH
48299: LD_INT 3
48301: NEG
48302: PUSH
48303: LD_INT 0
48305: PUSH
48306: EMPTY
48307: LIST
48308: LIST
48309: PUSH
48310: LD_INT 3
48312: NEG
48313: PUSH
48314: LD_INT 1
48316: PUSH
48317: EMPTY
48318: LIST
48319: LIST
48320: PUSH
48321: LD_INT 4
48323: NEG
48324: PUSH
48325: LD_INT 1
48327: PUSH
48328: EMPTY
48329: LIST
48330: LIST
48331: PUSH
48332: LD_INT 5
48334: NEG
48335: PUSH
48336: LD_INT 0
48338: PUSH
48339: EMPTY
48340: LIST
48341: LIST
48342: PUSH
48343: LD_INT 5
48345: NEG
48346: PUSH
48347: LD_INT 1
48349: NEG
48350: PUSH
48351: EMPTY
48352: LIST
48353: LIST
48354: PUSH
48355: LD_INT 5
48357: NEG
48358: PUSH
48359: LD_INT 2
48361: NEG
48362: PUSH
48363: EMPTY
48364: LIST
48365: LIST
48366: PUSH
48367: LD_INT 3
48369: NEG
48370: PUSH
48371: LD_INT 2
48373: PUSH
48374: EMPTY
48375: LIST
48376: LIST
48377: PUSH
48378: EMPTY
48379: LIST
48380: LIST
48381: LIST
48382: LIST
48383: LIST
48384: LIST
48385: LIST
48386: LIST
48387: LIST
48388: LIST
48389: LIST
48390: LIST
48391: LIST
48392: LIST
48393: LIST
48394: LIST
48395: LIST
48396: LIST
48397: LIST
48398: LIST
48399: LIST
48400: LIST
48401: LIST
48402: LIST
48403: LIST
48404: LIST
48405: LIST
48406: LIST
48407: LIST
48408: LIST
48409: LIST
48410: LIST
48411: LIST
48412: LIST
48413: LIST
48414: LIST
48415: LIST
48416: LIST
48417: LIST
48418: LIST
48419: LIST
48420: LIST
48421: LIST
48422: LIST
48423: LIST
48424: ST_TO_ADDR
// end ; end ;
48425: GO 48428
48427: POP
// case btype of b_depot , b_warehouse :
48428: LD_VAR 0 1
48432: PUSH
48433: LD_INT 0
48435: DOUBLE
48436: EQUAL
48437: IFTRUE 48447
48439: LD_INT 1
48441: DOUBLE
48442: EQUAL
48443: IFTRUE 48447
48445: GO 48648
48447: POP
// case nation of nation_american :
48448: LD_VAR 0 5
48452: PUSH
48453: LD_INT 1
48455: DOUBLE
48456: EQUAL
48457: IFTRUE 48461
48459: GO 48517
48461: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
48462: LD_ADDR_VAR 0 9
48466: PUSH
48467: LD_VAR 0 11
48471: PUSH
48472: LD_VAR 0 12
48476: PUSH
48477: LD_VAR 0 13
48481: PUSH
48482: LD_VAR 0 14
48486: PUSH
48487: LD_VAR 0 15
48491: PUSH
48492: LD_VAR 0 16
48496: PUSH
48497: EMPTY
48498: LIST
48499: LIST
48500: LIST
48501: LIST
48502: LIST
48503: LIST
48504: PUSH
48505: LD_VAR 0 4
48509: PUSH
48510: LD_INT 1
48512: PLUS
48513: ARRAY
48514: ST_TO_ADDR
48515: GO 48646
48517: LD_INT 2
48519: DOUBLE
48520: EQUAL
48521: IFTRUE 48525
48523: GO 48581
48525: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
48526: LD_ADDR_VAR 0 9
48530: PUSH
48531: LD_VAR 0 17
48535: PUSH
48536: LD_VAR 0 18
48540: PUSH
48541: LD_VAR 0 19
48545: PUSH
48546: LD_VAR 0 20
48550: PUSH
48551: LD_VAR 0 21
48555: PUSH
48556: LD_VAR 0 22
48560: PUSH
48561: EMPTY
48562: LIST
48563: LIST
48564: LIST
48565: LIST
48566: LIST
48567: LIST
48568: PUSH
48569: LD_VAR 0 4
48573: PUSH
48574: LD_INT 1
48576: PLUS
48577: ARRAY
48578: ST_TO_ADDR
48579: GO 48646
48581: LD_INT 3
48583: DOUBLE
48584: EQUAL
48585: IFTRUE 48589
48587: GO 48645
48589: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
48590: LD_ADDR_VAR 0 9
48594: PUSH
48595: LD_VAR 0 23
48599: PUSH
48600: LD_VAR 0 24
48604: PUSH
48605: LD_VAR 0 25
48609: PUSH
48610: LD_VAR 0 26
48614: PUSH
48615: LD_VAR 0 27
48619: PUSH
48620: LD_VAR 0 28
48624: PUSH
48625: EMPTY
48626: LIST
48627: LIST
48628: LIST
48629: LIST
48630: LIST
48631: LIST
48632: PUSH
48633: LD_VAR 0 4
48637: PUSH
48638: LD_INT 1
48640: PLUS
48641: ARRAY
48642: ST_TO_ADDR
48643: GO 48646
48645: POP
48646: GO 49201
48648: LD_INT 2
48650: DOUBLE
48651: EQUAL
48652: IFTRUE 48662
48654: LD_INT 3
48656: DOUBLE
48657: EQUAL
48658: IFTRUE 48662
48660: GO 48718
48662: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
48663: LD_ADDR_VAR 0 9
48667: PUSH
48668: LD_VAR 0 29
48672: PUSH
48673: LD_VAR 0 30
48677: PUSH
48678: LD_VAR 0 31
48682: PUSH
48683: LD_VAR 0 32
48687: PUSH
48688: LD_VAR 0 33
48692: PUSH
48693: LD_VAR 0 34
48697: PUSH
48698: EMPTY
48699: LIST
48700: LIST
48701: LIST
48702: LIST
48703: LIST
48704: LIST
48705: PUSH
48706: LD_VAR 0 4
48710: PUSH
48711: LD_INT 1
48713: PLUS
48714: ARRAY
48715: ST_TO_ADDR
48716: GO 49201
48718: LD_INT 16
48720: DOUBLE
48721: EQUAL
48722: IFTRUE 48780
48724: LD_INT 17
48726: DOUBLE
48727: EQUAL
48728: IFTRUE 48780
48730: LD_INT 18
48732: DOUBLE
48733: EQUAL
48734: IFTRUE 48780
48736: LD_INT 19
48738: DOUBLE
48739: EQUAL
48740: IFTRUE 48780
48742: LD_INT 22
48744: DOUBLE
48745: EQUAL
48746: IFTRUE 48780
48748: LD_INT 20
48750: DOUBLE
48751: EQUAL
48752: IFTRUE 48780
48754: LD_INT 21
48756: DOUBLE
48757: EQUAL
48758: IFTRUE 48780
48760: LD_INT 23
48762: DOUBLE
48763: EQUAL
48764: IFTRUE 48780
48766: LD_INT 24
48768: DOUBLE
48769: EQUAL
48770: IFTRUE 48780
48772: LD_INT 25
48774: DOUBLE
48775: EQUAL
48776: IFTRUE 48780
48778: GO 48836
48780: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
48781: LD_ADDR_VAR 0 9
48785: PUSH
48786: LD_VAR 0 35
48790: PUSH
48791: LD_VAR 0 36
48795: PUSH
48796: LD_VAR 0 37
48800: PUSH
48801: LD_VAR 0 38
48805: PUSH
48806: LD_VAR 0 39
48810: PUSH
48811: LD_VAR 0 40
48815: PUSH
48816: EMPTY
48817: LIST
48818: LIST
48819: LIST
48820: LIST
48821: LIST
48822: LIST
48823: PUSH
48824: LD_VAR 0 4
48828: PUSH
48829: LD_INT 1
48831: PLUS
48832: ARRAY
48833: ST_TO_ADDR
48834: GO 49201
48836: LD_INT 6
48838: DOUBLE
48839: EQUAL
48840: IFTRUE 48892
48842: LD_INT 7
48844: DOUBLE
48845: EQUAL
48846: IFTRUE 48892
48848: LD_INT 8
48850: DOUBLE
48851: EQUAL
48852: IFTRUE 48892
48854: LD_INT 13
48856: DOUBLE
48857: EQUAL
48858: IFTRUE 48892
48860: LD_INT 12
48862: DOUBLE
48863: EQUAL
48864: IFTRUE 48892
48866: LD_INT 15
48868: DOUBLE
48869: EQUAL
48870: IFTRUE 48892
48872: LD_INT 11
48874: DOUBLE
48875: EQUAL
48876: IFTRUE 48892
48878: LD_INT 14
48880: DOUBLE
48881: EQUAL
48882: IFTRUE 48892
48884: LD_INT 10
48886: DOUBLE
48887: EQUAL
48888: IFTRUE 48892
48890: GO 48948
48892: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
48893: LD_ADDR_VAR 0 9
48897: PUSH
48898: LD_VAR 0 41
48902: PUSH
48903: LD_VAR 0 42
48907: PUSH
48908: LD_VAR 0 43
48912: PUSH
48913: LD_VAR 0 44
48917: PUSH
48918: LD_VAR 0 45
48922: PUSH
48923: LD_VAR 0 46
48927: PUSH
48928: EMPTY
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: PUSH
48936: LD_VAR 0 4
48940: PUSH
48941: LD_INT 1
48943: PLUS
48944: ARRAY
48945: ST_TO_ADDR
48946: GO 49201
48948: LD_INT 36
48950: DOUBLE
48951: EQUAL
48952: IFTRUE 48956
48954: GO 49012
48956: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
48957: LD_ADDR_VAR 0 9
48961: PUSH
48962: LD_VAR 0 47
48966: PUSH
48967: LD_VAR 0 48
48971: PUSH
48972: LD_VAR 0 49
48976: PUSH
48977: LD_VAR 0 50
48981: PUSH
48982: LD_VAR 0 51
48986: PUSH
48987: LD_VAR 0 52
48991: PUSH
48992: EMPTY
48993: LIST
48994: LIST
48995: LIST
48996: LIST
48997: LIST
48998: LIST
48999: PUSH
49000: LD_VAR 0 4
49004: PUSH
49005: LD_INT 1
49007: PLUS
49008: ARRAY
49009: ST_TO_ADDR
49010: GO 49201
49012: LD_INT 4
49014: DOUBLE
49015: EQUAL
49016: IFTRUE 49038
49018: LD_INT 5
49020: DOUBLE
49021: EQUAL
49022: IFTRUE 49038
49024: LD_INT 34
49026: DOUBLE
49027: EQUAL
49028: IFTRUE 49038
49030: LD_INT 37
49032: DOUBLE
49033: EQUAL
49034: IFTRUE 49038
49036: GO 49094
49038: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
49039: LD_ADDR_VAR 0 9
49043: PUSH
49044: LD_VAR 0 53
49048: PUSH
49049: LD_VAR 0 54
49053: PUSH
49054: LD_VAR 0 55
49058: PUSH
49059: LD_VAR 0 56
49063: PUSH
49064: LD_VAR 0 57
49068: PUSH
49069: LD_VAR 0 58
49073: PUSH
49074: EMPTY
49075: LIST
49076: LIST
49077: LIST
49078: LIST
49079: LIST
49080: LIST
49081: PUSH
49082: LD_VAR 0 4
49086: PUSH
49087: LD_INT 1
49089: PLUS
49090: ARRAY
49091: ST_TO_ADDR
49092: GO 49201
49094: LD_INT 31
49096: DOUBLE
49097: EQUAL
49098: IFTRUE 49144
49100: LD_INT 32
49102: DOUBLE
49103: EQUAL
49104: IFTRUE 49144
49106: LD_INT 33
49108: DOUBLE
49109: EQUAL
49110: IFTRUE 49144
49112: LD_INT 27
49114: DOUBLE
49115: EQUAL
49116: IFTRUE 49144
49118: LD_INT 26
49120: DOUBLE
49121: EQUAL
49122: IFTRUE 49144
49124: LD_INT 28
49126: DOUBLE
49127: EQUAL
49128: IFTRUE 49144
49130: LD_INT 29
49132: DOUBLE
49133: EQUAL
49134: IFTRUE 49144
49136: LD_INT 30
49138: DOUBLE
49139: EQUAL
49140: IFTRUE 49144
49142: GO 49200
49144: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
49145: LD_ADDR_VAR 0 9
49149: PUSH
49150: LD_VAR 0 59
49154: PUSH
49155: LD_VAR 0 60
49159: PUSH
49160: LD_VAR 0 61
49164: PUSH
49165: LD_VAR 0 62
49169: PUSH
49170: LD_VAR 0 63
49174: PUSH
49175: LD_VAR 0 64
49179: PUSH
49180: EMPTY
49181: LIST
49182: LIST
49183: LIST
49184: LIST
49185: LIST
49186: LIST
49187: PUSH
49188: LD_VAR 0 4
49192: PUSH
49193: LD_INT 1
49195: PLUS
49196: ARRAY
49197: ST_TO_ADDR
49198: GO 49201
49200: POP
// temp_list2 = [ ] ;
49201: LD_ADDR_VAR 0 10
49205: PUSH
49206: EMPTY
49207: ST_TO_ADDR
// for i in temp_list do
49208: LD_ADDR_VAR 0 8
49212: PUSH
49213: LD_VAR 0 9
49217: PUSH
49218: FOR_IN
49219: IFFALSE 49271
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
49221: LD_ADDR_VAR 0 10
49225: PUSH
49226: LD_VAR 0 10
49230: PUSH
49231: LD_VAR 0 8
49235: PUSH
49236: LD_INT 1
49238: ARRAY
49239: PUSH
49240: LD_VAR 0 2
49244: PLUS
49245: PUSH
49246: LD_VAR 0 8
49250: PUSH
49251: LD_INT 2
49253: ARRAY
49254: PUSH
49255: LD_VAR 0 3
49259: PLUS
49260: PUSH
49261: EMPTY
49262: LIST
49263: LIST
49264: PUSH
49265: EMPTY
49266: LIST
49267: ADD
49268: ST_TO_ADDR
49269: GO 49218
49271: POP
49272: POP
// result = temp_list2 ;
49273: LD_ADDR_VAR 0 7
49277: PUSH
49278: LD_VAR 0 10
49282: ST_TO_ADDR
// end ;
49283: LD_VAR 0 7
49287: RET
// export function EnemyInRange ( unit , dist ) ; begin
49288: LD_INT 0
49290: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
49291: LD_ADDR_VAR 0 3
49295: PUSH
49296: LD_VAR 0 1
49300: PPUSH
49301: CALL_OW 255
49305: PPUSH
49306: LD_VAR 0 1
49310: PPUSH
49311: CALL_OW 250
49315: PPUSH
49316: LD_VAR 0 1
49320: PPUSH
49321: CALL_OW 251
49325: PPUSH
49326: LD_VAR 0 2
49330: PPUSH
49331: CALL 22661 0 4
49335: PUSH
49336: LD_INT 4
49338: ARRAY
49339: ST_TO_ADDR
// end ;
49340: LD_VAR 0 3
49344: RET
// export function PlayerSeeMe ( unit ) ; begin
49345: LD_INT 0
49347: PPUSH
// result := See ( your_side , unit ) ;
49348: LD_ADDR_VAR 0 2
49352: PUSH
49353: LD_OWVAR 2
49357: PPUSH
49358: LD_VAR 0 1
49362: PPUSH
49363: CALL_OW 292
49367: ST_TO_ADDR
// end ;
49368: LD_VAR 0 2
49372: RET
// export function ReverseDir ( unit ) ; begin
49373: LD_INT 0
49375: PPUSH
// if not unit then
49376: LD_VAR 0 1
49380: NOT
49381: IFFALSE 49385
// exit ;
49383: GO 49408
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
49385: LD_ADDR_VAR 0 2
49389: PUSH
49390: LD_VAR 0 1
49394: PPUSH
49395: CALL_OW 254
49399: PUSH
49400: LD_INT 3
49402: PLUS
49403: PUSH
49404: LD_INT 6
49406: MOD
49407: ST_TO_ADDR
// end ;
49408: LD_VAR 0 2
49412: RET
// export function ReverseArray ( array ) ; var i ; begin
49413: LD_INT 0
49415: PPUSH
49416: PPUSH
// if not array then
49417: LD_VAR 0 1
49421: NOT
49422: IFFALSE 49426
// exit ;
49424: GO 49481
// result := [ ] ;
49426: LD_ADDR_VAR 0 2
49430: PUSH
49431: EMPTY
49432: ST_TO_ADDR
// for i := array downto 1 do
49433: LD_ADDR_VAR 0 3
49437: PUSH
49438: DOUBLE
49439: LD_VAR 0 1
49443: INC
49444: ST_TO_ADDR
49445: LD_INT 1
49447: PUSH
49448: FOR_DOWNTO
49449: IFFALSE 49479
// result := Join ( result , array [ i ] ) ;
49451: LD_ADDR_VAR 0 2
49455: PUSH
49456: LD_VAR 0 2
49460: PPUSH
49461: LD_VAR 0 1
49465: PUSH
49466: LD_VAR 0 3
49470: ARRAY
49471: PPUSH
49472: CALL 54126 0 2
49476: ST_TO_ADDR
49477: GO 49448
49479: POP
49480: POP
// end ;
49481: LD_VAR 0 2
49485: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
49486: LD_INT 0
49488: PPUSH
49489: PPUSH
49490: PPUSH
49491: PPUSH
49492: PPUSH
49493: PPUSH
// if not unit or not hexes then
49494: LD_VAR 0 1
49498: NOT
49499: PUSH
49500: LD_VAR 0 2
49504: NOT
49505: OR
49506: IFFALSE 49510
// exit ;
49508: GO 49633
// dist := 9999 ;
49510: LD_ADDR_VAR 0 5
49514: PUSH
49515: LD_INT 9999
49517: ST_TO_ADDR
// for i = 1 to hexes do
49518: LD_ADDR_VAR 0 4
49522: PUSH
49523: DOUBLE
49524: LD_INT 1
49526: DEC
49527: ST_TO_ADDR
49528: LD_VAR 0 2
49532: PUSH
49533: FOR_TO
49534: IFFALSE 49621
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
49536: LD_ADDR_VAR 0 6
49540: PUSH
49541: LD_VAR 0 1
49545: PPUSH
49546: LD_VAR 0 2
49550: PUSH
49551: LD_VAR 0 4
49555: ARRAY
49556: PUSH
49557: LD_INT 1
49559: ARRAY
49560: PPUSH
49561: LD_VAR 0 2
49565: PUSH
49566: LD_VAR 0 4
49570: ARRAY
49571: PUSH
49572: LD_INT 2
49574: ARRAY
49575: PPUSH
49576: CALL_OW 297
49580: ST_TO_ADDR
// if tdist < dist then
49581: LD_VAR 0 6
49585: PUSH
49586: LD_VAR 0 5
49590: LESS
49591: IFFALSE 49619
// begin hex := hexes [ i ] ;
49593: LD_ADDR_VAR 0 8
49597: PUSH
49598: LD_VAR 0 2
49602: PUSH
49603: LD_VAR 0 4
49607: ARRAY
49608: ST_TO_ADDR
// dist := tdist ;
49609: LD_ADDR_VAR 0 5
49613: PUSH
49614: LD_VAR 0 6
49618: ST_TO_ADDR
// end ; end ;
49619: GO 49533
49621: POP
49622: POP
// result := hex ;
49623: LD_ADDR_VAR 0 3
49627: PUSH
49628: LD_VAR 0 8
49632: ST_TO_ADDR
// end ;
49633: LD_VAR 0 3
49637: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
49638: LD_INT 0
49640: PPUSH
49641: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
49642: LD_VAR 0 1
49646: NOT
49647: PUSH
49648: LD_VAR 0 1
49652: PUSH
49653: LD_INT 21
49655: PUSH
49656: LD_INT 2
49658: PUSH
49659: EMPTY
49660: LIST
49661: LIST
49662: PUSH
49663: LD_INT 23
49665: PUSH
49666: LD_INT 2
49668: PUSH
49669: EMPTY
49670: LIST
49671: LIST
49672: PUSH
49673: EMPTY
49674: LIST
49675: LIST
49676: PPUSH
49677: CALL_OW 69
49681: IN
49682: NOT
49683: OR
49684: IFFALSE 49688
// exit ;
49686: GO 49735
// for i = 1 to 3 do
49688: LD_ADDR_VAR 0 3
49692: PUSH
49693: DOUBLE
49694: LD_INT 1
49696: DEC
49697: ST_TO_ADDR
49698: LD_INT 3
49700: PUSH
49701: FOR_TO
49702: IFFALSE 49733
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
49704: LD_VAR 0 1
49708: PPUSH
49709: CALL_OW 250
49713: PPUSH
49714: LD_VAR 0 1
49718: PPUSH
49719: CALL_OW 251
49723: PPUSH
49724: LD_INT 1
49726: PPUSH
49727: CALL_OW 453
49731: GO 49701
49733: POP
49734: POP
// end ;
49735: LD_VAR 0 2
49739: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
49740: LD_INT 0
49742: PPUSH
49743: PPUSH
49744: PPUSH
49745: PPUSH
49746: PPUSH
49747: PPUSH
// if not unit or not enemy_unit then
49748: LD_VAR 0 1
49752: NOT
49753: PUSH
49754: LD_VAR 0 2
49758: NOT
49759: OR
49760: IFFALSE 49764
// exit ;
49762: GO 50231
// if GetLives ( i ) < 250 then
49764: LD_VAR 0 4
49768: PPUSH
49769: CALL_OW 256
49773: PUSH
49774: LD_INT 250
49776: LESS
49777: IFFALSE 49790
// begin ComAutodestruct ( i ) ;
49779: LD_VAR 0 4
49783: PPUSH
49784: CALL 49638 0 1
// exit ;
49788: GO 50231
// end ; x := GetX ( enemy_unit ) ;
49790: LD_ADDR_VAR 0 7
49794: PUSH
49795: LD_VAR 0 2
49799: PPUSH
49800: CALL_OW 250
49804: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
49805: LD_ADDR_VAR 0 8
49809: PUSH
49810: LD_VAR 0 2
49814: PPUSH
49815: CALL_OW 251
49819: ST_TO_ADDR
// if not x or not y then
49820: LD_VAR 0 7
49824: NOT
49825: PUSH
49826: LD_VAR 0 8
49830: NOT
49831: OR
49832: IFFALSE 49836
// exit ;
49834: GO 50231
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
49836: LD_ADDR_VAR 0 6
49840: PUSH
49841: LD_VAR 0 7
49845: PPUSH
49846: LD_INT 0
49848: PPUSH
49849: LD_INT 4
49851: PPUSH
49852: CALL_OW 272
49856: PUSH
49857: LD_VAR 0 8
49861: PPUSH
49862: LD_INT 0
49864: PPUSH
49865: LD_INT 4
49867: PPUSH
49868: CALL_OW 273
49872: PUSH
49873: EMPTY
49874: LIST
49875: LIST
49876: PUSH
49877: LD_VAR 0 7
49881: PPUSH
49882: LD_INT 1
49884: PPUSH
49885: LD_INT 4
49887: PPUSH
49888: CALL_OW 272
49892: PUSH
49893: LD_VAR 0 8
49897: PPUSH
49898: LD_INT 1
49900: PPUSH
49901: LD_INT 4
49903: PPUSH
49904: CALL_OW 273
49908: PUSH
49909: EMPTY
49910: LIST
49911: LIST
49912: PUSH
49913: LD_VAR 0 7
49917: PPUSH
49918: LD_INT 2
49920: PPUSH
49921: LD_INT 4
49923: PPUSH
49924: CALL_OW 272
49928: PUSH
49929: LD_VAR 0 8
49933: PPUSH
49934: LD_INT 2
49936: PPUSH
49937: LD_INT 4
49939: PPUSH
49940: CALL_OW 273
49944: PUSH
49945: EMPTY
49946: LIST
49947: LIST
49948: PUSH
49949: LD_VAR 0 7
49953: PPUSH
49954: LD_INT 3
49956: PPUSH
49957: LD_INT 4
49959: PPUSH
49960: CALL_OW 272
49964: PUSH
49965: LD_VAR 0 8
49969: PPUSH
49970: LD_INT 3
49972: PPUSH
49973: LD_INT 4
49975: PPUSH
49976: CALL_OW 273
49980: PUSH
49981: EMPTY
49982: LIST
49983: LIST
49984: PUSH
49985: LD_VAR 0 7
49989: PPUSH
49990: LD_INT 4
49992: PPUSH
49993: LD_INT 4
49995: PPUSH
49996: CALL_OW 272
50000: PUSH
50001: LD_VAR 0 8
50005: PPUSH
50006: LD_INT 4
50008: PPUSH
50009: LD_INT 4
50011: PPUSH
50012: CALL_OW 273
50016: PUSH
50017: EMPTY
50018: LIST
50019: LIST
50020: PUSH
50021: LD_VAR 0 7
50025: PPUSH
50026: LD_INT 5
50028: PPUSH
50029: LD_INT 4
50031: PPUSH
50032: CALL_OW 272
50036: PUSH
50037: LD_VAR 0 8
50041: PPUSH
50042: LD_INT 5
50044: PPUSH
50045: LD_INT 4
50047: PPUSH
50048: CALL_OW 273
50052: PUSH
50053: EMPTY
50054: LIST
50055: LIST
50056: PUSH
50057: EMPTY
50058: LIST
50059: LIST
50060: LIST
50061: LIST
50062: LIST
50063: LIST
50064: ST_TO_ADDR
// for i = tmp downto 1 do
50065: LD_ADDR_VAR 0 4
50069: PUSH
50070: DOUBLE
50071: LD_VAR 0 6
50075: INC
50076: ST_TO_ADDR
50077: LD_INT 1
50079: PUSH
50080: FOR_DOWNTO
50081: IFFALSE 50182
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
50083: LD_VAR 0 6
50087: PUSH
50088: LD_VAR 0 4
50092: ARRAY
50093: PUSH
50094: LD_INT 1
50096: ARRAY
50097: PPUSH
50098: LD_VAR 0 6
50102: PUSH
50103: LD_VAR 0 4
50107: ARRAY
50108: PUSH
50109: LD_INT 2
50111: ARRAY
50112: PPUSH
50113: CALL_OW 488
50117: NOT
50118: PUSH
50119: LD_VAR 0 6
50123: PUSH
50124: LD_VAR 0 4
50128: ARRAY
50129: PUSH
50130: LD_INT 1
50132: ARRAY
50133: PPUSH
50134: LD_VAR 0 6
50138: PUSH
50139: LD_VAR 0 4
50143: ARRAY
50144: PUSH
50145: LD_INT 2
50147: ARRAY
50148: PPUSH
50149: CALL_OW 428
50153: PUSH
50154: LD_INT 0
50156: NONEQUAL
50157: OR
50158: IFFALSE 50180
// tmp := Delete ( tmp , i ) ;
50160: LD_ADDR_VAR 0 6
50164: PUSH
50165: LD_VAR 0 6
50169: PPUSH
50170: LD_VAR 0 4
50174: PPUSH
50175: CALL_OW 3
50179: ST_TO_ADDR
50180: GO 50080
50182: POP
50183: POP
// j := GetClosestHex ( unit , tmp ) ;
50184: LD_ADDR_VAR 0 5
50188: PUSH
50189: LD_VAR 0 1
50193: PPUSH
50194: LD_VAR 0 6
50198: PPUSH
50199: CALL 49486 0 2
50203: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
50204: LD_VAR 0 1
50208: PPUSH
50209: LD_VAR 0 5
50213: PUSH
50214: LD_INT 1
50216: ARRAY
50217: PPUSH
50218: LD_VAR 0 5
50222: PUSH
50223: LD_INT 2
50225: ARRAY
50226: PPUSH
50227: CALL_OW 111
// end ;
50231: LD_VAR 0 3
50235: RET
// export function PrepareApemanSoldier ( ) ; begin
50236: LD_INT 0
50238: PPUSH
// uc_nation := 0 ;
50239: LD_ADDR_OWVAR 21
50243: PUSH
50244: LD_INT 0
50246: ST_TO_ADDR
// hc_sex := sex_male ;
50247: LD_ADDR_OWVAR 27
50251: PUSH
50252: LD_INT 1
50254: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
50255: LD_ADDR_OWVAR 28
50259: PUSH
50260: LD_INT 15
50262: ST_TO_ADDR
// hc_gallery :=  ;
50263: LD_ADDR_OWVAR 33
50267: PUSH
50268: LD_STRING 
50270: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
50271: LD_ADDR_OWVAR 31
50275: PUSH
50276: LD_INT 0
50278: PPUSH
50279: LD_INT 3
50281: PPUSH
50282: CALL_OW 12
50286: PUSH
50287: LD_INT 0
50289: PPUSH
50290: LD_INT 3
50292: PPUSH
50293: CALL_OW 12
50297: PUSH
50298: LD_INT 0
50300: PUSH
50301: LD_INT 0
50303: PUSH
50304: EMPTY
50305: LIST
50306: LIST
50307: LIST
50308: LIST
50309: ST_TO_ADDR
// end ;
50310: LD_VAR 0 1
50314: RET
// export function PrepareApemanEngineer ( ) ; begin
50315: LD_INT 0
50317: PPUSH
// uc_nation := 0 ;
50318: LD_ADDR_OWVAR 21
50322: PUSH
50323: LD_INT 0
50325: ST_TO_ADDR
// hc_sex := sex_male ;
50326: LD_ADDR_OWVAR 27
50330: PUSH
50331: LD_INT 1
50333: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
50334: LD_ADDR_OWVAR 28
50338: PUSH
50339: LD_INT 16
50341: ST_TO_ADDR
// hc_gallery :=  ;
50342: LD_ADDR_OWVAR 33
50346: PUSH
50347: LD_STRING 
50349: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
50350: LD_ADDR_OWVAR 31
50354: PUSH
50355: LD_INT 0
50357: PPUSH
50358: LD_INT 3
50360: PPUSH
50361: CALL_OW 12
50365: PUSH
50366: LD_INT 0
50368: PPUSH
50369: LD_INT 3
50371: PPUSH
50372: CALL_OW 12
50376: PUSH
50377: LD_INT 0
50379: PUSH
50380: LD_INT 0
50382: PUSH
50383: EMPTY
50384: LIST
50385: LIST
50386: LIST
50387: LIST
50388: ST_TO_ADDR
// end ;
50389: LD_VAR 0 1
50393: RET
// export function PrepareApeman ( agressivity ) ; begin
50394: LD_INT 0
50396: PPUSH
// uc_side := 0 ;
50397: LD_ADDR_OWVAR 20
50401: PUSH
50402: LD_INT 0
50404: ST_TO_ADDR
// uc_nation := 0 ;
50405: LD_ADDR_OWVAR 21
50409: PUSH
50410: LD_INT 0
50412: ST_TO_ADDR
// hc_sex := sex_male ;
50413: LD_ADDR_OWVAR 27
50417: PUSH
50418: LD_INT 1
50420: ST_TO_ADDR
// hc_class := class_apeman ;
50421: LD_ADDR_OWVAR 28
50425: PUSH
50426: LD_INT 12
50428: ST_TO_ADDR
// hc_gallery :=  ;
50429: LD_ADDR_OWVAR 33
50433: PUSH
50434: LD_STRING 
50436: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
50437: LD_ADDR_OWVAR 35
50441: PUSH
50442: LD_VAR 0 1
50446: NEG
50447: PPUSH
50448: LD_VAR 0 1
50452: PPUSH
50453: CALL_OW 12
50457: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
50458: LD_ADDR_OWVAR 31
50462: PUSH
50463: LD_INT 0
50465: PPUSH
50466: LD_INT 3
50468: PPUSH
50469: CALL_OW 12
50473: PUSH
50474: LD_INT 0
50476: PPUSH
50477: LD_INT 3
50479: PPUSH
50480: CALL_OW 12
50484: PUSH
50485: LD_INT 0
50487: PUSH
50488: LD_INT 0
50490: PUSH
50491: EMPTY
50492: LIST
50493: LIST
50494: LIST
50495: LIST
50496: ST_TO_ADDR
// end ;
50497: LD_VAR 0 2
50501: RET
// export function PrepareTiger ( agressivity ) ; begin
50502: LD_INT 0
50504: PPUSH
// uc_side := 0 ;
50505: LD_ADDR_OWVAR 20
50509: PUSH
50510: LD_INT 0
50512: ST_TO_ADDR
// uc_nation := 0 ;
50513: LD_ADDR_OWVAR 21
50517: PUSH
50518: LD_INT 0
50520: ST_TO_ADDR
// hc_class := class_tiger ;
50521: LD_ADDR_OWVAR 28
50525: PUSH
50526: LD_INT 14
50528: ST_TO_ADDR
// hc_gallery :=  ;
50529: LD_ADDR_OWVAR 33
50533: PUSH
50534: LD_STRING 
50536: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
50537: LD_ADDR_OWVAR 35
50541: PUSH
50542: LD_VAR 0 1
50546: NEG
50547: PPUSH
50548: LD_VAR 0 1
50552: PPUSH
50553: CALL_OW 12
50557: ST_TO_ADDR
// end ;
50558: LD_VAR 0 2
50562: RET
// export function PrepareEnchidna ( ) ; begin
50563: LD_INT 0
50565: PPUSH
// uc_side := 0 ;
50566: LD_ADDR_OWVAR 20
50570: PUSH
50571: LD_INT 0
50573: ST_TO_ADDR
// uc_nation := 0 ;
50574: LD_ADDR_OWVAR 21
50578: PUSH
50579: LD_INT 0
50581: ST_TO_ADDR
// hc_class := class_baggie ;
50582: LD_ADDR_OWVAR 28
50586: PUSH
50587: LD_INT 13
50589: ST_TO_ADDR
// hc_gallery :=  ;
50590: LD_ADDR_OWVAR 33
50594: PUSH
50595: LD_STRING 
50597: ST_TO_ADDR
// end ;
50598: LD_VAR 0 1
50602: RET
// export function PrepareFrog ( ) ; begin
50603: LD_INT 0
50605: PPUSH
// uc_side := 0 ;
50606: LD_ADDR_OWVAR 20
50610: PUSH
50611: LD_INT 0
50613: ST_TO_ADDR
// uc_nation := 0 ;
50614: LD_ADDR_OWVAR 21
50618: PUSH
50619: LD_INT 0
50621: ST_TO_ADDR
// hc_class := class_frog ;
50622: LD_ADDR_OWVAR 28
50626: PUSH
50627: LD_INT 19
50629: ST_TO_ADDR
// hc_gallery :=  ;
50630: LD_ADDR_OWVAR 33
50634: PUSH
50635: LD_STRING 
50637: ST_TO_ADDR
// end ;
50638: LD_VAR 0 1
50642: RET
// export function PrepareFish ( ) ; begin
50643: LD_INT 0
50645: PPUSH
// uc_side := 0 ;
50646: LD_ADDR_OWVAR 20
50650: PUSH
50651: LD_INT 0
50653: ST_TO_ADDR
// uc_nation := 0 ;
50654: LD_ADDR_OWVAR 21
50658: PUSH
50659: LD_INT 0
50661: ST_TO_ADDR
// hc_class := class_fish ;
50662: LD_ADDR_OWVAR 28
50666: PUSH
50667: LD_INT 20
50669: ST_TO_ADDR
// hc_gallery :=  ;
50670: LD_ADDR_OWVAR 33
50674: PUSH
50675: LD_STRING 
50677: ST_TO_ADDR
// end ;
50678: LD_VAR 0 1
50682: RET
// export function PrepareBird ( ) ; begin
50683: LD_INT 0
50685: PPUSH
// uc_side := 0 ;
50686: LD_ADDR_OWVAR 20
50690: PUSH
50691: LD_INT 0
50693: ST_TO_ADDR
// uc_nation := 0 ;
50694: LD_ADDR_OWVAR 21
50698: PUSH
50699: LD_INT 0
50701: ST_TO_ADDR
// hc_class := class_phororhacos ;
50702: LD_ADDR_OWVAR 28
50706: PUSH
50707: LD_INT 18
50709: ST_TO_ADDR
// hc_gallery :=  ;
50710: LD_ADDR_OWVAR 33
50714: PUSH
50715: LD_STRING 
50717: ST_TO_ADDR
// end ;
50718: LD_VAR 0 1
50722: RET
// export function PrepareHorse ( ) ; begin
50723: LD_INT 0
50725: PPUSH
// uc_side := 0 ;
50726: LD_ADDR_OWVAR 20
50730: PUSH
50731: LD_INT 0
50733: ST_TO_ADDR
// uc_nation := 0 ;
50734: LD_ADDR_OWVAR 21
50738: PUSH
50739: LD_INT 0
50741: ST_TO_ADDR
// hc_class := class_horse ;
50742: LD_ADDR_OWVAR 28
50746: PUSH
50747: LD_INT 21
50749: ST_TO_ADDR
// hc_gallery :=  ;
50750: LD_ADDR_OWVAR 33
50754: PUSH
50755: LD_STRING 
50757: ST_TO_ADDR
// end ;
50758: LD_VAR 0 1
50762: RET
// export function PrepareMastodont ( ) ; begin
50763: LD_INT 0
50765: PPUSH
// uc_side := 0 ;
50766: LD_ADDR_OWVAR 20
50770: PUSH
50771: LD_INT 0
50773: ST_TO_ADDR
// uc_nation := 0 ;
50774: LD_ADDR_OWVAR 21
50778: PUSH
50779: LD_INT 0
50781: ST_TO_ADDR
// vc_chassis := class_mastodont ;
50782: LD_ADDR_OWVAR 37
50786: PUSH
50787: LD_INT 31
50789: ST_TO_ADDR
// vc_control := control_rider ;
50790: LD_ADDR_OWVAR 38
50794: PUSH
50795: LD_INT 4
50797: ST_TO_ADDR
// end ;
50798: LD_VAR 0 1
50802: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
50803: LD_INT 0
50805: PPUSH
50806: PPUSH
50807: PPUSH
// uc_side = 0 ;
50808: LD_ADDR_OWVAR 20
50812: PUSH
50813: LD_INT 0
50815: ST_TO_ADDR
// uc_nation = 0 ;
50816: LD_ADDR_OWVAR 21
50820: PUSH
50821: LD_INT 0
50823: ST_TO_ADDR
// InitHc_All ( ) ;
50824: CALL_OW 584
// InitVc ;
50828: CALL_OW 20
// if mastodonts then
50832: LD_VAR 0 6
50836: IFFALSE 50903
// for i = 1 to mastodonts do
50838: LD_ADDR_VAR 0 11
50842: PUSH
50843: DOUBLE
50844: LD_INT 1
50846: DEC
50847: ST_TO_ADDR
50848: LD_VAR 0 6
50852: PUSH
50853: FOR_TO
50854: IFFALSE 50901
// begin vc_chassis := 31 ;
50856: LD_ADDR_OWVAR 37
50860: PUSH
50861: LD_INT 31
50863: ST_TO_ADDR
// vc_control := control_rider ;
50864: LD_ADDR_OWVAR 38
50868: PUSH
50869: LD_INT 4
50871: ST_TO_ADDR
// animal := CreateVehicle ;
50872: LD_ADDR_VAR 0 12
50876: PUSH
50877: CALL_OW 45
50881: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50882: LD_VAR 0 12
50886: PPUSH
50887: LD_VAR 0 8
50891: PPUSH
50892: LD_INT 0
50894: PPUSH
50895: CALL 53031 0 3
// end ;
50899: GO 50853
50901: POP
50902: POP
// if horses then
50903: LD_VAR 0 5
50907: IFFALSE 50974
// for i = 1 to horses do
50909: LD_ADDR_VAR 0 11
50913: PUSH
50914: DOUBLE
50915: LD_INT 1
50917: DEC
50918: ST_TO_ADDR
50919: LD_VAR 0 5
50923: PUSH
50924: FOR_TO
50925: IFFALSE 50972
// begin hc_class := 21 ;
50927: LD_ADDR_OWVAR 28
50931: PUSH
50932: LD_INT 21
50934: ST_TO_ADDR
// hc_gallery :=  ;
50935: LD_ADDR_OWVAR 33
50939: PUSH
50940: LD_STRING 
50942: ST_TO_ADDR
// animal := CreateHuman ;
50943: LD_ADDR_VAR 0 12
50947: PUSH
50948: CALL_OW 44
50952: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50953: LD_VAR 0 12
50957: PPUSH
50958: LD_VAR 0 8
50962: PPUSH
50963: LD_INT 0
50965: PPUSH
50966: CALL 53031 0 3
// end ;
50970: GO 50924
50972: POP
50973: POP
// if birds then
50974: LD_VAR 0 1
50978: IFFALSE 51045
// for i = 1 to birds do
50980: LD_ADDR_VAR 0 11
50984: PUSH
50985: DOUBLE
50986: LD_INT 1
50988: DEC
50989: ST_TO_ADDR
50990: LD_VAR 0 1
50994: PUSH
50995: FOR_TO
50996: IFFALSE 51043
// begin hc_class := 18 ;
50998: LD_ADDR_OWVAR 28
51002: PUSH
51003: LD_INT 18
51005: ST_TO_ADDR
// hc_gallery =  ;
51006: LD_ADDR_OWVAR 33
51010: PUSH
51011: LD_STRING 
51013: ST_TO_ADDR
// animal := CreateHuman ;
51014: LD_ADDR_VAR 0 12
51018: PUSH
51019: CALL_OW 44
51023: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51024: LD_VAR 0 12
51028: PPUSH
51029: LD_VAR 0 8
51033: PPUSH
51034: LD_INT 0
51036: PPUSH
51037: CALL 53031 0 3
// end ;
51041: GO 50995
51043: POP
51044: POP
// if tigers then
51045: LD_VAR 0 2
51049: IFFALSE 51133
// for i = 1 to tigers do
51051: LD_ADDR_VAR 0 11
51055: PUSH
51056: DOUBLE
51057: LD_INT 1
51059: DEC
51060: ST_TO_ADDR
51061: LD_VAR 0 2
51065: PUSH
51066: FOR_TO
51067: IFFALSE 51131
// begin hc_class = class_tiger ;
51069: LD_ADDR_OWVAR 28
51073: PUSH
51074: LD_INT 14
51076: ST_TO_ADDR
// hc_gallery =  ;
51077: LD_ADDR_OWVAR 33
51081: PUSH
51082: LD_STRING 
51084: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
51085: LD_ADDR_OWVAR 35
51089: PUSH
51090: LD_INT 7
51092: NEG
51093: PPUSH
51094: LD_INT 7
51096: PPUSH
51097: CALL_OW 12
51101: ST_TO_ADDR
// animal := CreateHuman ;
51102: LD_ADDR_VAR 0 12
51106: PUSH
51107: CALL_OW 44
51111: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51112: LD_VAR 0 12
51116: PPUSH
51117: LD_VAR 0 8
51121: PPUSH
51122: LD_INT 0
51124: PPUSH
51125: CALL 53031 0 3
// end ;
51129: GO 51066
51131: POP
51132: POP
// if apemans then
51133: LD_VAR 0 3
51137: IFFALSE 51260
// for i = 1 to apemans do
51139: LD_ADDR_VAR 0 11
51143: PUSH
51144: DOUBLE
51145: LD_INT 1
51147: DEC
51148: ST_TO_ADDR
51149: LD_VAR 0 3
51153: PUSH
51154: FOR_TO
51155: IFFALSE 51258
// begin hc_class = class_apeman ;
51157: LD_ADDR_OWVAR 28
51161: PUSH
51162: LD_INT 12
51164: ST_TO_ADDR
// hc_gallery =  ;
51165: LD_ADDR_OWVAR 33
51169: PUSH
51170: LD_STRING 
51172: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
51173: LD_ADDR_OWVAR 35
51177: PUSH
51178: LD_INT 2
51180: NEG
51181: PPUSH
51182: LD_INT 2
51184: PPUSH
51185: CALL_OW 12
51189: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
51190: LD_ADDR_OWVAR 31
51194: PUSH
51195: LD_INT 1
51197: PPUSH
51198: LD_INT 3
51200: PPUSH
51201: CALL_OW 12
51205: PUSH
51206: LD_INT 1
51208: PPUSH
51209: LD_INT 3
51211: PPUSH
51212: CALL_OW 12
51216: PUSH
51217: LD_INT 0
51219: PUSH
51220: LD_INT 0
51222: PUSH
51223: EMPTY
51224: LIST
51225: LIST
51226: LIST
51227: LIST
51228: ST_TO_ADDR
// animal := CreateHuman ;
51229: LD_ADDR_VAR 0 12
51233: PUSH
51234: CALL_OW 44
51238: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51239: LD_VAR 0 12
51243: PPUSH
51244: LD_VAR 0 8
51248: PPUSH
51249: LD_INT 0
51251: PPUSH
51252: CALL 53031 0 3
// end ;
51256: GO 51154
51258: POP
51259: POP
// if enchidnas then
51260: LD_VAR 0 4
51264: IFFALSE 51331
// for i = 1 to enchidnas do
51266: LD_ADDR_VAR 0 11
51270: PUSH
51271: DOUBLE
51272: LD_INT 1
51274: DEC
51275: ST_TO_ADDR
51276: LD_VAR 0 4
51280: PUSH
51281: FOR_TO
51282: IFFALSE 51329
// begin hc_class = 13 ;
51284: LD_ADDR_OWVAR 28
51288: PUSH
51289: LD_INT 13
51291: ST_TO_ADDR
// hc_gallery =  ;
51292: LD_ADDR_OWVAR 33
51296: PUSH
51297: LD_STRING 
51299: ST_TO_ADDR
// animal := CreateHuman ;
51300: LD_ADDR_VAR 0 12
51304: PUSH
51305: CALL_OW 44
51309: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51310: LD_VAR 0 12
51314: PPUSH
51315: LD_VAR 0 8
51319: PPUSH
51320: LD_INT 0
51322: PPUSH
51323: CALL 53031 0 3
// end ;
51327: GO 51281
51329: POP
51330: POP
// if fishes then
51331: LD_VAR 0 7
51335: IFFALSE 51402
// for i = 1 to fishes do
51337: LD_ADDR_VAR 0 11
51341: PUSH
51342: DOUBLE
51343: LD_INT 1
51345: DEC
51346: ST_TO_ADDR
51347: LD_VAR 0 7
51351: PUSH
51352: FOR_TO
51353: IFFALSE 51400
// begin hc_class = 20 ;
51355: LD_ADDR_OWVAR 28
51359: PUSH
51360: LD_INT 20
51362: ST_TO_ADDR
// hc_gallery =  ;
51363: LD_ADDR_OWVAR 33
51367: PUSH
51368: LD_STRING 
51370: ST_TO_ADDR
// animal := CreateHuman ;
51371: LD_ADDR_VAR 0 12
51375: PUSH
51376: CALL_OW 44
51380: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
51381: LD_VAR 0 12
51385: PPUSH
51386: LD_VAR 0 9
51390: PPUSH
51391: LD_INT 0
51393: PPUSH
51394: CALL 53031 0 3
// end ;
51398: GO 51352
51400: POP
51401: POP
// end ;
51402: LD_VAR 0 10
51406: RET
// export function WantHeal ( sci , unit ) ; begin
51407: LD_INT 0
51409: PPUSH
// if GetTaskList ( sci ) > 0 then
51410: LD_VAR 0 1
51414: PPUSH
51415: CALL_OW 437
51419: PUSH
51420: LD_INT 0
51422: GREATER
51423: IFFALSE 51493
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
51425: LD_VAR 0 1
51429: PPUSH
51430: CALL_OW 437
51434: PUSH
51435: LD_INT 1
51437: ARRAY
51438: PUSH
51439: LD_INT 1
51441: ARRAY
51442: PUSH
51443: LD_STRING l
51445: EQUAL
51446: PUSH
51447: LD_VAR 0 1
51451: PPUSH
51452: CALL_OW 437
51456: PUSH
51457: LD_INT 1
51459: ARRAY
51460: PUSH
51461: LD_INT 4
51463: ARRAY
51464: PUSH
51465: LD_VAR 0 2
51469: EQUAL
51470: AND
51471: IFFALSE 51483
// result := true else
51473: LD_ADDR_VAR 0 3
51477: PUSH
51478: LD_INT 1
51480: ST_TO_ADDR
51481: GO 51491
// result := false ;
51483: LD_ADDR_VAR 0 3
51487: PUSH
51488: LD_INT 0
51490: ST_TO_ADDR
// end else
51491: GO 51501
// result := false ;
51493: LD_ADDR_VAR 0 3
51497: PUSH
51498: LD_INT 0
51500: ST_TO_ADDR
// end ;
51501: LD_VAR 0 3
51505: RET
// export function HealTarget ( sci ) ; begin
51506: LD_INT 0
51508: PPUSH
// if not sci then
51509: LD_VAR 0 1
51513: NOT
51514: IFFALSE 51518
// exit ;
51516: GO 51583
// result := 0 ;
51518: LD_ADDR_VAR 0 2
51522: PUSH
51523: LD_INT 0
51525: ST_TO_ADDR
// if GetTaskList ( sci ) then
51526: LD_VAR 0 1
51530: PPUSH
51531: CALL_OW 437
51535: IFFALSE 51583
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
51537: LD_VAR 0 1
51541: PPUSH
51542: CALL_OW 437
51546: PUSH
51547: LD_INT 1
51549: ARRAY
51550: PUSH
51551: LD_INT 1
51553: ARRAY
51554: PUSH
51555: LD_STRING l
51557: EQUAL
51558: IFFALSE 51583
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
51560: LD_ADDR_VAR 0 2
51564: PUSH
51565: LD_VAR 0 1
51569: PPUSH
51570: CALL_OW 437
51574: PUSH
51575: LD_INT 1
51577: ARRAY
51578: PUSH
51579: LD_INT 4
51581: ARRAY
51582: ST_TO_ADDR
// end ;
51583: LD_VAR 0 2
51587: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
51588: LD_INT 0
51590: PPUSH
51591: PPUSH
51592: PPUSH
51593: PPUSH
// if not base_units then
51594: LD_VAR 0 1
51598: NOT
51599: IFFALSE 51603
// exit ;
51601: GO 51690
// result := false ;
51603: LD_ADDR_VAR 0 2
51607: PUSH
51608: LD_INT 0
51610: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
51611: LD_ADDR_VAR 0 5
51615: PUSH
51616: LD_VAR 0 1
51620: PPUSH
51621: LD_INT 21
51623: PUSH
51624: LD_INT 3
51626: PUSH
51627: EMPTY
51628: LIST
51629: LIST
51630: PPUSH
51631: CALL_OW 72
51635: ST_TO_ADDR
// if not tmp then
51636: LD_VAR 0 5
51640: NOT
51641: IFFALSE 51645
// exit ;
51643: GO 51690
// for i in tmp do
51645: LD_ADDR_VAR 0 3
51649: PUSH
51650: LD_VAR 0 5
51654: PUSH
51655: FOR_IN
51656: IFFALSE 51688
// begin result := EnemyInRange ( i , 22 ) ;
51658: LD_ADDR_VAR 0 2
51662: PUSH
51663: LD_VAR 0 3
51667: PPUSH
51668: LD_INT 22
51670: PPUSH
51671: CALL 49288 0 2
51675: ST_TO_ADDR
// if result then
51676: LD_VAR 0 2
51680: IFFALSE 51686
// exit ;
51682: POP
51683: POP
51684: GO 51690
// end ;
51686: GO 51655
51688: POP
51689: POP
// end ;
51690: LD_VAR 0 2
51694: RET
// export function FilterByTag ( units , tag ) ; begin
51695: LD_INT 0
51697: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
51698: LD_ADDR_VAR 0 3
51702: PUSH
51703: LD_VAR 0 1
51707: PPUSH
51708: LD_INT 120
51710: PUSH
51711: LD_VAR 0 2
51715: PUSH
51716: EMPTY
51717: LIST
51718: LIST
51719: PPUSH
51720: CALL_OW 72
51724: ST_TO_ADDR
// end ;
51725: LD_VAR 0 3
51729: RET
// export function IsDriver ( un ) ; begin
51730: LD_INT 0
51732: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
51733: LD_ADDR_VAR 0 2
51737: PUSH
51738: LD_VAR 0 1
51742: PUSH
51743: LD_INT 55
51745: PUSH
51746: EMPTY
51747: LIST
51748: PPUSH
51749: CALL_OW 69
51753: IN
51754: ST_TO_ADDR
// end ;
51755: LD_VAR 0 2
51759: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
51760: LD_INT 0
51762: PPUSH
51763: PPUSH
// list := [ ] ;
51764: LD_ADDR_VAR 0 5
51768: PUSH
51769: EMPTY
51770: ST_TO_ADDR
// case d of 0 :
51771: LD_VAR 0 3
51775: PUSH
51776: LD_INT 0
51778: DOUBLE
51779: EQUAL
51780: IFTRUE 51784
51782: GO 51917
51784: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
51785: LD_ADDR_VAR 0 5
51789: PUSH
51790: LD_VAR 0 1
51794: PUSH
51795: LD_INT 4
51797: MINUS
51798: PUSH
51799: LD_VAR 0 2
51803: PUSH
51804: LD_INT 4
51806: MINUS
51807: PUSH
51808: LD_INT 2
51810: PUSH
51811: EMPTY
51812: LIST
51813: LIST
51814: LIST
51815: PUSH
51816: LD_VAR 0 1
51820: PUSH
51821: LD_INT 3
51823: MINUS
51824: PUSH
51825: LD_VAR 0 2
51829: PUSH
51830: LD_INT 1
51832: PUSH
51833: EMPTY
51834: LIST
51835: LIST
51836: LIST
51837: PUSH
51838: LD_VAR 0 1
51842: PUSH
51843: LD_INT 4
51845: PLUS
51846: PUSH
51847: LD_VAR 0 2
51851: PUSH
51852: LD_INT 4
51854: PUSH
51855: EMPTY
51856: LIST
51857: LIST
51858: LIST
51859: PUSH
51860: LD_VAR 0 1
51864: PUSH
51865: LD_INT 3
51867: PLUS
51868: PUSH
51869: LD_VAR 0 2
51873: PUSH
51874: LD_INT 3
51876: PLUS
51877: PUSH
51878: LD_INT 5
51880: PUSH
51881: EMPTY
51882: LIST
51883: LIST
51884: LIST
51885: PUSH
51886: LD_VAR 0 1
51890: PUSH
51891: LD_VAR 0 2
51895: PUSH
51896: LD_INT 4
51898: PLUS
51899: PUSH
51900: LD_INT 0
51902: PUSH
51903: EMPTY
51904: LIST
51905: LIST
51906: LIST
51907: PUSH
51908: EMPTY
51909: LIST
51910: LIST
51911: LIST
51912: LIST
51913: LIST
51914: ST_TO_ADDR
// end ; 1 :
51915: GO 52615
51917: LD_INT 1
51919: DOUBLE
51920: EQUAL
51921: IFTRUE 51925
51923: GO 52058
51925: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
51926: LD_ADDR_VAR 0 5
51930: PUSH
51931: LD_VAR 0 1
51935: PUSH
51936: LD_VAR 0 2
51940: PUSH
51941: LD_INT 4
51943: MINUS
51944: PUSH
51945: LD_INT 3
51947: PUSH
51948: EMPTY
51949: LIST
51950: LIST
51951: LIST
51952: PUSH
51953: LD_VAR 0 1
51957: PUSH
51958: LD_INT 3
51960: MINUS
51961: PUSH
51962: LD_VAR 0 2
51966: PUSH
51967: LD_INT 3
51969: MINUS
51970: PUSH
51971: LD_INT 2
51973: PUSH
51974: EMPTY
51975: LIST
51976: LIST
51977: LIST
51978: PUSH
51979: LD_VAR 0 1
51983: PUSH
51984: LD_INT 4
51986: MINUS
51987: PUSH
51988: LD_VAR 0 2
51992: PUSH
51993: LD_INT 1
51995: PUSH
51996: EMPTY
51997: LIST
51998: LIST
51999: LIST
52000: PUSH
52001: LD_VAR 0 1
52005: PUSH
52006: LD_VAR 0 2
52010: PUSH
52011: LD_INT 3
52013: PLUS
52014: PUSH
52015: LD_INT 0
52017: PUSH
52018: EMPTY
52019: LIST
52020: LIST
52021: LIST
52022: PUSH
52023: LD_VAR 0 1
52027: PUSH
52028: LD_INT 4
52030: PLUS
52031: PUSH
52032: LD_VAR 0 2
52036: PUSH
52037: LD_INT 4
52039: PLUS
52040: PUSH
52041: LD_INT 5
52043: PUSH
52044: EMPTY
52045: LIST
52046: LIST
52047: LIST
52048: PUSH
52049: EMPTY
52050: LIST
52051: LIST
52052: LIST
52053: LIST
52054: LIST
52055: ST_TO_ADDR
// end ; 2 :
52056: GO 52615
52058: LD_INT 2
52060: DOUBLE
52061: EQUAL
52062: IFTRUE 52066
52064: GO 52195
52066: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
52067: LD_ADDR_VAR 0 5
52071: PUSH
52072: LD_VAR 0 1
52076: PUSH
52077: LD_VAR 0 2
52081: PUSH
52082: LD_INT 3
52084: MINUS
52085: PUSH
52086: LD_INT 3
52088: PUSH
52089: EMPTY
52090: LIST
52091: LIST
52092: LIST
52093: PUSH
52094: LD_VAR 0 1
52098: PUSH
52099: LD_INT 4
52101: PLUS
52102: PUSH
52103: LD_VAR 0 2
52107: PUSH
52108: LD_INT 4
52110: PUSH
52111: EMPTY
52112: LIST
52113: LIST
52114: LIST
52115: PUSH
52116: LD_VAR 0 1
52120: PUSH
52121: LD_VAR 0 2
52125: PUSH
52126: LD_INT 4
52128: PLUS
52129: PUSH
52130: LD_INT 0
52132: PUSH
52133: EMPTY
52134: LIST
52135: LIST
52136: LIST
52137: PUSH
52138: LD_VAR 0 1
52142: PUSH
52143: LD_INT 3
52145: MINUS
52146: PUSH
52147: LD_VAR 0 2
52151: PUSH
52152: LD_INT 1
52154: PUSH
52155: EMPTY
52156: LIST
52157: LIST
52158: LIST
52159: PUSH
52160: LD_VAR 0 1
52164: PUSH
52165: LD_INT 4
52167: MINUS
52168: PUSH
52169: LD_VAR 0 2
52173: PUSH
52174: LD_INT 4
52176: MINUS
52177: PUSH
52178: LD_INT 2
52180: PUSH
52181: EMPTY
52182: LIST
52183: LIST
52184: LIST
52185: PUSH
52186: EMPTY
52187: LIST
52188: LIST
52189: LIST
52190: LIST
52191: LIST
52192: ST_TO_ADDR
// end ; 3 :
52193: GO 52615
52195: LD_INT 3
52197: DOUBLE
52198: EQUAL
52199: IFTRUE 52203
52201: GO 52336
52203: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
52204: LD_ADDR_VAR 0 5
52208: PUSH
52209: LD_VAR 0 1
52213: PUSH
52214: LD_INT 3
52216: PLUS
52217: PUSH
52218: LD_VAR 0 2
52222: PUSH
52223: LD_INT 4
52225: PUSH
52226: EMPTY
52227: LIST
52228: LIST
52229: LIST
52230: PUSH
52231: LD_VAR 0 1
52235: PUSH
52236: LD_INT 4
52238: PLUS
52239: PUSH
52240: LD_VAR 0 2
52244: PUSH
52245: LD_INT 4
52247: PLUS
52248: PUSH
52249: LD_INT 5
52251: PUSH
52252: EMPTY
52253: LIST
52254: LIST
52255: LIST
52256: PUSH
52257: LD_VAR 0 1
52261: PUSH
52262: LD_INT 4
52264: MINUS
52265: PUSH
52266: LD_VAR 0 2
52270: PUSH
52271: LD_INT 1
52273: PUSH
52274: EMPTY
52275: LIST
52276: LIST
52277: LIST
52278: PUSH
52279: LD_VAR 0 1
52283: PUSH
52284: LD_VAR 0 2
52288: PUSH
52289: LD_INT 4
52291: MINUS
52292: PUSH
52293: LD_INT 3
52295: PUSH
52296: EMPTY
52297: LIST
52298: LIST
52299: LIST
52300: PUSH
52301: LD_VAR 0 1
52305: PUSH
52306: LD_INT 3
52308: MINUS
52309: PUSH
52310: LD_VAR 0 2
52314: PUSH
52315: LD_INT 3
52317: MINUS
52318: PUSH
52319: LD_INT 2
52321: PUSH
52322: EMPTY
52323: LIST
52324: LIST
52325: LIST
52326: PUSH
52327: EMPTY
52328: LIST
52329: LIST
52330: LIST
52331: LIST
52332: LIST
52333: ST_TO_ADDR
// end ; 4 :
52334: GO 52615
52336: LD_INT 4
52338: DOUBLE
52339: EQUAL
52340: IFTRUE 52344
52342: GO 52477
52344: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
52345: LD_ADDR_VAR 0 5
52349: PUSH
52350: LD_VAR 0 1
52354: PUSH
52355: LD_VAR 0 2
52359: PUSH
52360: LD_INT 4
52362: PLUS
52363: PUSH
52364: LD_INT 0
52366: PUSH
52367: EMPTY
52368: LIST
52369: LIST
52370: LIST
52371: PUSH
52372: LD_VAR 0 1
52376: PUSH
52377: LD_INT 3
52379: PLUS
52380: PUSH
52381: LD_VAR 0 2
52385: PUSH
52386: LD_INT 3
52388: PLUS
52389: PUSH
52390: LD_INT 5
52392: PUSH
52393: EMPTY
52394: LIST
52395: LIST
52396: LIST
52397: PUSH
52398: LD_VAR 0 1
52402: PUSH
52403: LD_INT 4
52405: PLUS
52406: PUSH
52407: LD_VAR 0 2
52411: PUSH
52412: LD_INT 4
52414: PUSH
52415: EMPTY
52416: LIST
52417: LIST
52418: LIST
52419: PUSH
52420: LD_VAR 0 1
52424: PUSH
52425: LD_VAR 0 2
52429: PUSH
52430: LD_INT 3
52432: MINUS
52433: PUSH
52434: LD_INT 3
52436: PUSH
52437: EMPTY
52438: LIST
52439: LIST
52440: LIST
52441: PUSH
52442: LD_VAR 0 1
52446: PUSH
52447: LD_INT 4
52449: MINUS
52450: PUSH
52451: LD_VAR 0 2
52455: PUSH
52456: LD_INT 4
52458: MINUS
52459: PUSH
52460: LD_INT 2
52462: PUSH
52463: EMPTY
52464: LIST
52465: LIST
52466: LIST
52467: PUSH
52468: EMPTY
52469: LIST
52470: LIST
52471: LIST
52472: LIST
52473: LIST
52474: ST_TO_ADDR
// end ; 5 :
52475: GO 52615
52477: LD_INT 5
52479: DOUBLE
52480: EQUAL
52481: IFTRUE 52485
52483: GO 52614
52485: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
52486: LD_ADDR_VAR 0 5
52490: PUSH
52491: LD_VAR 0 1
52495: PUSH
52496: LD_INT 4
52498: MINUS
52499: PUSH
52500: LD_VAR 0 2
52504: PUSH
52505: LD_INT 1
52507: PUSH
52508: EMPTY
52509: LIST
52510: LIST
52511: LIST
52512: PUSH
52513: LD_VAR 0 1
52517: PUSH
52518: LD_VAR 0 2
52522: PUSH
52523: LD_INT 4
52525: MINUS
52526: PUSH
52527: LD_INT 3
52529: PUSH
52530: EMPTY
52531: LIST
52532: LIST
52533: LIST
52534: PUSH
52535: LD_VAR 0 1
52539: PUSH
52540: LD_INT 4
52542: PLUS
52543: PUSH
52544: LD_VAR 0 2
52548: PUSH
52549: LD_INT 4
52551: PLUS
52552: PUSH
52553: LD_INT 5
52555: PUSH
52556: EMPTY
52557: LIST
52558: LIST
52559: LIST
52560: PUSH
52561: LD_VAR 0 1
52565: PUSH
52566: LD_INT 3
52568: PLUS
52569: PUSH
52570: LD_VAR 0 2
52574: PUSH
52575: LD_INT 4
52577: PUSH
52578: EMPTY
52579: LIST
52580: LIST
52581: LIST
52582: PUSH
52583: LD_VAR 0 1
52587: PUSH
52588: LD_VAR 0 2
52592: PUSH
52593: LD_INT 3
52595: PLUS
52596: PUSH
52597: LD_INT 0
52599: PUSH
52600: EMPTY
52601: LIST
52602: LIST
52603: LIST
52604: PUSH
52605: EMPTY
52606: LIST
52607: LIST
52608: LIST
52609: LIST
52610: LIST
52611: ST_TO_ADDR
// end ; end ;
52612: GO 52615
52614: POP
// result := list ;
52615: LD_ADDR_VAR 0 4
52619: PUSH
52620: LD_VAR 0 5
52624: ST_TO_ADDR
// end ;
52625: LD_VAR 0 4
52629: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
52630: LD_INT 0
52632: PPUSH
52633: PPUSH
52634: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
52635: LD_VAR 0 1
52639: NOT
52640: PUSH
52641: LD_VAR 0 2
52645: PUSH
52646: LD_INT 1
52648: PUSH
52649: LD_INT 2
52651: PUSH
52652: LD_INT 3
52654: PUSH
52655: LD_INT 4
52657: PUSH
52658: EMPTY
52659: LIST
52660: LIST
52661: LIST
52662: LIST
52663: IN
52664: NOT
52665: OR
52666: IFFALSE 52670
// exit ;
52668: GO 52753
// tmp := [ ] ;
52670: LD_ADDR_VAR 0 5
52674: PUSH
52675: EMPTY
52676: ST_TO_ADDR
// for i in units do
52677: LD_ADDR_VAR 0 4
52681: PUSH
52682: LD_VAR 0 1
52686: PUSH
52687: FOR_IN
52688: IFFALSE 52722
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
52690: LD_ADDR_VAR 0 5
52694: PUSH
52695: LD_VAR 0 5
52699: PPUSH
52700: LD_VAR 0 4
52704: PPUSH
52705: LD_VAR 0 2
52709: PPUSH
52710: CALL_OW 259
52714: PPUSH
52715: CALL 54126 0 2
52719: ST_TO_ADDR
52720: GO 52687
52722: POP
52723: POP
// if not tmp then
52724: LD_VAR 0 5
52728: NOT
52729: IFFALSE 52733
// exit ;
52731: GO 52753
// result := SortListByListDesc ( units , tmp ) ;
52733: LD_ADDR_VAR 0 3
52737: PUSH
52738: LD_VAR 0 1
52742: PPUSH
52743: LD_VAR 0 5
52747: PPUSH
52748: CALL_OW 77
52752: ST_TO_ADDR
// end ;
52753: LD_VAR 0 3
52757: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
52758: LD_INT 0
52760: PPUSH
52761: PPUSH
52762: PPUSH
// result := false ;
52763: LD_ADDR_VAR 0 3
52767: PUSH
52768: LD_INT 0
52770: ST_TO_ADDR
// if not building then
52771: LD_VAR 0 2
52775: NOT
52776: IFFALSE 52780
// exit ;
52778: GO 52918
// x := GetX ( building ) ;
52780: LD_ADDR_VAR 0 4
52784: PUSH
52785: LD_VAR 0 2
52789: PPUSH
52790: CALL_OW 250
52794: ST_TO_ADDR
// y := GetY ( building ) ;
52795: LD_ADDR_VAR 0 5
52799: PUSH
52800: LD_VAR 0 2
52804: PPUSH
52805: CALL_OW 251
52809: ST_TO_ADDR
// if not x or not y then
52810: LD_VAR 0 4
52814: NOT
52815: PUSH
52816: LD_VAR 0 5
52820: NOT
52821: OR
52822: IFFALSE 52826
// exit ;
52824: GO 52918
// if GetTaskList ( unit ) then
52826: LD_VAR 0 1
52830: PPUSH
52831: CALL_OW 437
52835: IFFALSE 52918
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52837: LD_STRING e
52839: PUSH
52840: LD_VAR 0 1
52844: PPUSH
52845: CALL_OW 437
52849: PUSH
52850: LD_INT 1
52852: ARRAY
52853: PUSH
52854: LD_INT 1
52856: ARRAY
52857: EQUAL
52858: PUSH
52859: LD_VAR 0 4
52863: PUSH
52864: LD_VAR 0 1
52868: PPUSH
52869: CALL_OW 437
52873: PUSH
52874: LD_INT 1
52876: ARRAY
52877: PUSH
52878: LD_INT 2
52880: ARRAY
52881: EQUAL
52882: AND
52883: PUSH
52884: LD_VAR 0 5
52888: PUSH
52889: LD_VAR 0 1
52893: PPUSH
52894: CALL_OW 437
52898: PUSH
52899: LD_INT 1
52901: ARRAY
52902: PUSH
52903: LD_INT 3
52905: ARRAY
52906: EQUAL
52907: AND
52908: IFFALSE 52918
// result := true end ;
52910: LD_ADDR_VAR 0 3
52914: PUSH
52915: LD_INT 1
52917: ST_TO_ADDR
// end ;
52918: LD_VAR 0 3
52922: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
52923: LD_INT 0
52925: PPUSH
// result := false ;
52926: LD_ADDR_VAR 0 4
52930: PUSH
52931: LD_INT 0
52933: ST_TO_ADDR
// if GetTaskList ( unit ) then
52934: LD_VAR 0 1
52938: PPUSH
52939: CALL_OW 437
52943: IFFALSE 53026
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52945: LD_STRING M
52947: PUSH
52948: LD_VAR 0 1
52952: PPUSH
52953: CALL_OW 437
52957: PUSH
52958: LD_INT 1
52960: ARRAY
52961: PUSH
52962: LD_INT 1
52964: ARRAY
52965: EQUAL
52966: PUSH
52967: LD_VAR 0 2
52971: PUSH
52972: LD_VAR 0 1
52976: PPUSH
52977: CALL_OW 437
52981: PUSH
52982: LD_INT 1
52984: ARRAY
52985: PUSH
52986: LD_INT 2
52988: ARRAY
52989: EQUAL
52990: AND
52991: PUSH
52992: LD_VAR 0 3
52996: PUSH
52997: LD_VAR 0 1
53001: PPUSH
53002: CALL_OW 437
53006: PUSH
53007: LD_INT 1
53009: ARRAY
53010: PUSH
53011: LD_INT 3
53013: ARRAY
53014: EQUAL
53015: AND
53016: IFFALSE 53026
// result := true ;
53018: LD_ADDR_VAR 0 4
53022: PUSH
53023: LD_INT 1
53025: ST_TO_ADDR
// end ; end ;
53026: LD_VAR 0 4
53030: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
53031: LD_INT 0
53033: PPUSH
53034: PPUSH
53035: PPUSH
53036: PPUSH
// if not unit or not area then
53037: LD_VAR 0 1
53041: NOT
53042: PUSH
53043: LD_VAR 0 2
53047: NOT
53048: OR
53049: IFFALSE 53053
// exit ;
53051: GO 53229
// tmp := AreaToList ( area , i ) ;
53053: LD_ADDR_VAR 0 6
53057: PUSH
53058: LD_VAR 0 2
53062: PPUSH
53063: LD_VAR 0 5
53067: PPUSH
53068: CALL_OW 517
53072: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
53073: LD_ADDR_VAR 0 5
53077: PUSH
53078: DOUBLE
53079: LD_INT 1
53081: DEC
53082: ST_TO_ADDR
53083: LD_VAR 0 6
53087: PUSH
53088: LD_INT 1
53090: ARRAY
53091: PUSH
53092: FOR_TO
53093: IFFALSE 53227
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
53095: LD_ADDR_VAR 0 7
53099: PUSH
53100: LD_VAR 0 6
53104: PUSH
53105: LD_INT 1
53107: ARRAY
53108: PUSH
53109: LD_VAR 0 5
53113: ARRAY
53114: PUSH
53115: LD_VAR 0 6
53119: PUSH
53120: LD_INT 2
53122: ARRAY
53123: PUSH
53124: LD_VAR 0 5
53128: ARRAY
53129: PUSH
53130: EMPTY
53131: LIST
53132: LIST
53133: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
53134: LD_INT 92
53136: PUSH
53137: LD_VAR 0 7
53141: PUSH
53142: LD_INT 1
53144: ARRAY
53145: PUSH
53146: LD_VAR 0 7
53150: PUSH
53151: LD_INT 2
53153: ARRAY
53154: PUSH
53155: LD_INT 2
53157: PUSH
53158: EMPTY
53159: LIST
53160: LIST
53161: LIST
53162: LIST
53163: PPUSH
53164: CALL_OW 69
53168: PUSH
53169: LD_INT 0
53171: EQUAL
53172: IFFALSE 53225
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
53174: LD_VAR 0 1
53178: PPUSH
53179: LD_VAR 0 7
53183: PUSH
53184: LD_INT 1
53186: ARRAY
53187: PPUSH
53188: LD_VAR 0 7
53192: PUSH
53193: LD_INT 2
53195: ARRAY
53196: PPUSH
53197: LD_VAR 0 3
53201: PPUSH
53202: CALL_OW 48
// result := IsPlaced ( unit ) ;
53206: LD_ADDR_VAR 0 4
53210: PUSH
53211: LD_VAR 0 1
53215: PPUSH
53216: CALL_OW 305
53220: ST_TO_ADDR
// exit ;
53221: POP
53222: POP
53223: GO 53229
// end ; end ;
53225: GO 53092
53227: POP
53228: POP
// end ;
53229: LD_VAR 0 4
53233: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
53234: LD_INT 0
53236: PPUSH
53237: PPUSH
53238: PPUSH
// if not side or side > 8 then
53239: LD_VAR 0 1
53243: NOT
53244: PUSH
53245: LD_VAR 0 1
53249: PUSH
53250: LD_INT 8
53252: GREATER
53253: OR
53254: IFFALSE 53258
// exit ;
53256: GO 53445
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
53258: LD_ADDR_VAR 0 4
53262: PUSH
53263: LD_INT 22
53265: PUSH
53266: LD_VAR 0 1
53270: PUSH
53271: EMPTY
53272: LIST
53273: LIST
53274: PUSH
53275: LD_INT 21
53277: PUSH
53278: LD_INT 3
53280: PUSH
53281: EMPTY
53282: LIST
53283: LIST
53284: PUSH
53285: EMPTY
53286: LIST
53287: LIST
53288: PPUSH
53289: CALL_OW 69
53293: ST_TO_ADDR
// if not tmp then
53294: LD_VAR 0 4
53298: NOT
53299: IFFALSE 53303
// exit ;
53301: GO 53445
// enable_addtolog := true ;
53303: LD_ADDR_OWVAR 81
53307: PUSH
53308: LD_INT 1
53310: ST_TO_ADDR
// AddToLog ( [ ) ;
53311: LD_STRING [
53313: PPUSH
53314: CALL_OW 561
// for i in tmp do
53318: LD_ADDR_VAR 0 3
53322: PUSH
53323: LD_VAR 0 4
53327: PUSH
53328: FOR_IN
53329: IFFALSE 53436
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
53331: LD_STRING [
53333: PUSH
53334: LD_VAR 0 3
53338: PPUSH
53339: CALL_OW 266
53343: STR
53344: PUSH
53345: LD_STRING , 
53347: STR
53348: PUSH
53349: LD_VAR 0 3
53353: PPUSH
53354: CALL_OW 250
53358: STR
53359: PUSH
53360: LD_STRING , 
53362: STR
53363: PUSH
53364: LD_VAR 0 3
53368: PPUSH
53369: CALL_OW 251
53373: STR
53374: PUSH
53375: LD_STRING , 
53377: STR
53378: PUSH
53379: LD_VAR 0 3
53383: PPUSH
53384: CALL_OW 254
53388: STR
53389: PUSH
53390: LD_STRING , 
53392: STR
53393: PUSH
53394: LD_VAR 0 3
53398: PPUSH
53399: LD_INT 1
53401: PPUSH
53402: CALL_OW 268
53406: STR
53407: PUSH
53408: LD_STRING , 
53410: STR
53411: PUSH
53412: LD_VAR 0 3
53416: PPUSH
53417: LD_INT 2
53419: PPUSH
53420: CALL_OW 268
53424: STR
53425: PUSH
53426: LD_STRING ],
53428: STR
53429: PPUSH
53430: CALL_OW 561
// end ;
53434: GO 53328
53436: POP
53437: POP
// AddToLog ( ]; ) ;
53438: LD_STRING ];
53440: PPUSH
53441: CALL_OW 561
// end ;
53445: LD_VAR 0 2
53449: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
53450: LD_INT 0
53452: PPUSH
53453: PPUSH
53454: PPUSH
53455: PPUSH
53456: PPUSH
// if not area or not rate or not max then
53457: LD_VAR 0 1
53461: NOT
53462: PUSH
53463: LD_VAR 0 2
53467: NOT
53468: OR
53469: PUSH
53470: LD_VAR 0 4
53474: NOT
53475: OR
53476: IFFALSE 53480
// exit ;
53478: GO 53669
// while 1 do
53480: LD_INT 1
53482: IFFALSE 53669
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
53484: LD_ADDR_VAR 0 9
53488: PUSH
53489: LD_VAR 0 1
53493: PPUSH
53494: LD_INT 1
53496: PPUSH
53497: CALL_OW 287
53501: PUSH
53502: LD_INT 10
53504: MUL
53505: ST_TO_ADDR
// r := rate / 10 ;
53506: LD_ADDR_VAR 0 7
53510: PUSH
53511: LD_VAR 0 2
53515: PUSH
53516: LD_INT 10
53518: DIVREAL
53519: ST_TO_ADDR
// time := 1 1$00 ;
53520: LD_ADDR_VAR 0 8
53524: PUSH
53525: LD_INT 2100
53527: ST_TO_ADDR
// if amount < min then
53528: LD_VAR 0 9
53532: PUSH
53533: LD_VAR 0 3
53537: LESS
53538: IFFALSE 53556
// r := r * 2 else
53540: LD_ADDR_VAR 0 7
53544: PUSH
53545: LD_VAR 0 7
53549: PUSH
53550: LD_INT 2
53552: MUL
53553: ST_TO_ADDR
53554: GO 53582
// if amount > max then
53556: LD_VAR 0 9
53560: PUSH
53561: LD_VAR 0 4
53565: GREATER
53566: IFFALSE 53582
// r := r / 2 ;
53568: LD_ADDR_VAR 0 7
53572: PUSH
53573: LD_VAR 0 7
53577: PUSH
53578: LD_INT 2
53580: DIVREAL
53581: ST_TO_ADDR
// time := time / r ;
53582: LD_ADDR_VAR 0 8
53586: PUSH
53587: LD_VAR 0 8
53591: PUSH
53592: LD_VAR 0 7
53596: DIVREAL
53597: ST_TO_ADDR
// if time < 0 then
53598: LD_VAR 0 8
53602: PUSH
53603: LD_INT 0
53605: LESS
53606: IFFALSE 53623
// time := time * - 1 ;
53608: LD_ADDR_VAR 0 8
53612: PUSH
53613: LD_VAR 0 8
53617: PUSH
53618: LD_INT 1
53620: NEG
53621: MUL
53622: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
53623: LD_VAR 0 8
53627: PUSH
53628: LD_INT 35
53630: PPUSH
53631: LD_INT 875
53633: PPUSH
53634: CALL_OW 12
53638: PLUS
53639: PPUSH
53640: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
53644: LD_INT 1
53646: PPUSH
53647: LD_INT 5
53649: PPUSH
53650: CALL_OW 12
53654: PPUSH
53655: LD_VAR 0 1
53659: PPUSH
53660: LD_INT 1
53662: PPUSH
53663: CALL_OW 55
// end ;
53667: GO 53480
// end ;
53669: LD_VAR 0 5
53673: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
53674: LD_INT 0
53676: PPUSH
53677: PPUSH
53678: PPUSH
53679: PPUSH
53680: PPUSH
53681: PPUSH
53682: PPUSH
53683: PPUSH
// if not turrets or not factories then
53684: LD_VAR 0 1
53688: NOT
53689: PUSH
53690: LD_VAR 0 2
53694: NOT
53695: OR
53696: IFFALSE 53700
// exit ;
53698: GO 54007
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
53700: LD_ADDR_VAR 0 10
53704: PUSH
53705: LD_INT 5
53707: PUSH
53708: LD_INT 6
53710: PUSH
53711: EMPTY
53712: LIST
53713: LIST
53714: PUSH
53715: LD_INT 2
53717: PUSH
53718: LD_INT 4
53720: PUSH
53721: EMPTY
53722: LIST
53723: LIST
53724: PUSH
53725: LD_INT 3
53727: PUSH
53728: LD_INT 5
53730: PUSH
53731: EMPTY
53732: LIST
53733: LIST
53734: PUSH
53735: EMPTY
53736: LIST
53737: LIST
53738: LIST
53739: PUSH
53740: LD_INT 24
53742: PUSH
53743: LD_INT 25
53745: PUSH
53746: EMPTY
53747: LIST
53748: LIST
53749: PUSH
53750: LD_INT 23
53752: PUSH
53753: LD_INT 27
53755: PUSH
53756: EMPTY
53757: LIST
53758: LIST
53759: PUSH
53760: EMPTY
53761: LIST
53762: LIST
53763: PUSH
53764: LD_INT 42
53766: PUSH
53767: LD_INT 43
53769: PUSH
53770: EMPTY
53771: LIST
53772: LIST
53773: PUSH
53774: LD_INT 44
53776: PUSH
53777: LD_INT 46
53779: PUSH
53780: EMPTY
53781: LIST
53782: LIST
53783: PUSH
53784: LD_INT 45
53786: PUSH
53787: LD_INT 47
53789: PUSH
53790: EMPTY
53791: LIST
53792: LIST
53793: PUSH
53794: EMPTY
53795: LIST
53796: LIST
53797: LIST
53798: PUSH
53799: EMPTY
53800: LIST
53801: LIST
53802: LIST
53803: ST_TO_ADDR
// result := [ ] ;
53804: LD_ADDR_VAR 0 3
53808: PUSH
53809: EMPTY
53810: ST_TO_ADDR
// for i in turrets do
53811: LD_ADDR_VAR 0 4
53815: PUSH
53816: LD_VAR 0 1
53820: PUSH
53821: FOR_IN
53822: IFFALSE 54005
// begin nat := GetNation ( i ) ;
53824: LD_ADDR_VAR 0 7
53828: PUSH
53829: LD_VAR 0 4
53833: PPUSH
53834: CALL_OW 248
53838: ST_TO_ADDR
// weapon := 0 ;
53839: LD_ADDR_VAR 0 8
53843: PUSH
53844: LD_INT 0
53846: ST_TO_ADDR
// if not nat then
53847: LD_VAR 0 7
53851: NOT
53852: IFFALSE 53856
// continue ;
53854: GO 53821
// for j in list [ nat ] do
53856: LD_ADDR_VAR 0 5
53860: PUSH
53861: LD_VAR 0 10
53865: PUSH
53866: LD_VAR 0 7
53870: ARRAY
53871: PUSH
53872: FOR_IN
53873: IFFALSE 53914
// if GetBWeapon ( i ) = j [ 1 ] then
53875: LD_VAR 0 4
53879: PPUSH
53880: CALL_OW 269
53884: PUSH
53885: LD_VAR 0 5
53889: PUSH
53890: LD_INT 1
53892: ARRAY
53893: EQUAL
53894: IFFALSE 53912
// begin weapon := j [ 2 ] ;
53896: LD_ADDR_VAR 0 8
53900: PUSH
53901: LD_VAR 0 5
53905: PUSH
53906: LD_INT 2
53908: ARRAY
53909: ST_TO_ADDR
// break ;
53910: GO 53914
// end ;
53912: GO 53872
53914: POP
53915: POP
// if not weapon then
53916: LD_VAR 0 8
53920: NOT
53921: IFFALSE 53925
// continue ;
53923: GO 53821
// for k in factories do
53925: LD_ADDR_VAR 0 6
53929: PUSH
53930: LD_VAR 0 2
53934: PUSH
53935: FOR_IN
53936: IFFALSE 54001
// begin weapons := AvailableWeaponList ( k ) ;
53938: LD_ADDR_VAR 0 9
53942: PUSH
53943: LD_VAR 0 6
53947: PPUSH
53948: CALL_OW 478
53952: ST_TO_ADDR
// if not weapons then
53953: LD_VAR 0 9
53957: NOT
53958: IFFALSE 53962
// continue ;
53960: GO 53935
// if weapon in weapons then
53962: LD_VAR 0 8
53966: PUSH
53967: LD_VAR 0 9
53971: IN
53972: IFFALSE 53999
// begin result := [ i , weapon ] ;
53974: LD_ADDR_VAR 0 3
53978: PUSH
53979: LD_VAR 0 4
53983: PUSH
53984: LD_VAR 0 8
53988: PUSH
53989: EMPTY
53990: LIST
53991: LIST
53992: ST_TO_ADDR
// exit ;
53993: POP
53994: POP
53995: POP
53996: POP
53997: GO 54007
// end ; end ;
53999: GO 53935
54001: POP
54002: POP
// end ;
54003: GO 53821
54005: POP
54006: POP
// end ;
54007: LD_VAR 0 3
54011: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
54012: LD_INT 0
54014: PPUSH
// if not side or side > 8 then
54015: LD_VAR 0 3
54019: NOT
54020: PUSH
54021: LD_VAR 0 3
54025: PUSH
54026: LD_INT 8
54028: GREATER
54029: OR
54030: IFFALSE 54034
// exit ;
54032: GO 54093
// if not range then
54034: LD_VAR 0 4
54038: NOT
54039: IFFALSE 54050
// range := - 12 ;
54041: LD_ADDR_VAR 0 4
54045: PUSH
54046: LD_INT 12
54048: NEG
54049: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
54050: LD_VAR 0 1
54054: PPUSH
54055: LD_VAR 0 2
54059: PPUSH
54060: LD_VAR 0 3
54064: PPUSH
54065: LD_VAR 0 4
54069: PPUSH
54070: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
54074: LD_VAR 0 1
54078: PPUSH
54079: LD_VAR 0 2
54083: PPUSH
54084: LD_VAR 0 3
54088: PPUSH
54089: CALL_OW 331
// end ;
54093: LD_VAR 0 5
54097: RET
// export function Video ( mode ) ; begin
54098: LD_INT 0
54100: PPUSH
// ingame_video = mode ;
54101: LD_ADDR_OWVAR 52
54105: PUSH
54106: LD_VAR 0 1
54110: ST_TO_ADDR
// interface_hidden = mode ;
54111: LD_ADDR_OWVAR 54
54115: PUSH
54116: LD_VAR 0 1
54120: ST_TO_ADDR
// end ;
54121: LD_VAR 0 2
54125: RET
// export function Join ( array , element ) ; begin
54126: LD_INT 0
54128: PPUSH
// result := Replace ( array , array + 1 , element ) ;
54129: LD_ADDR_VAR 0 3
54133: PUSH
54134: LD_VAR 0 1
54138: PPUSH
54139: LD_VAR 0 1
54143: PUSH
54144: LD_INT 1
54146: PLUS
54147: PPUSH
54148: LD_VAR 0 2
54152: PPUSH
54153: CALL_OW 1
54157: ST_TO_ADDR
// end ;
54158: LD_VAR 0 3
54162: RET
// export function JoinUnion ( array , element ) ; begin
54163: LD_INT 0
54165: PPUSH
// result := array union element ;
54166: LD_ADDR_VAR 0 3
54170: PUSH
54171: LD_VAR 0 1
54175: PUSH
54176: LD_VAR 0 2
54180: UNION
54181: ST_TO_ADDR
// end ;
54182: LD_VAR 0 3
54186: RET
// export function GetBehemoths ( side ) ; begin
54187: LD_INT 0
54189: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
54190: LD_ADDR_VAR 0 2
54194: PUSH
54195: LD_INT 22
54197: PUSH
54198: LD_VAR 0 1
54202: PUSH
54203: EMPTY
54204: LIST
54205: LIST
54206: PUSH
54207: LD_INT 31
54209: PUSH
54210: LD_INT 25
54212: PUSH
54213: EMPTY
54214: LIST
54215: LIST
54216: PUSH
54217: EMPTY
54218: LIST
54219: LIST
54220: PPUSH
54221: CALL_OW 69
54225: ST_TO_ADDR
// end ;
54226: LD_VAR 0 2
54230: RET
// export function Shuffle ( array ) ; var i , index ; begin
54231: LD_INT 0
54233: PPUSH
54234: PPUSH
54235: PPUSH
// result := [ ] ;
54236: LD_ADDR_VAR 0 2
54240: PUSH
54241: EMPTY
54242: ST_TO_ADDR
// if not array then
54243: LD_VAR 0 1
54247: NOT
54248: IFFALSE 54252
// exit ;
54250: GO 54351
// Randomize ;
54252: CALL_OW 10
// for i = array downto 1 do
54256: LD_ADDR_VAR 0 3
54260: PUSH
54261: DOUBLE
54262: LD_VAR 0 1
54266: INC
54267: ST_TO_ADDR
54268: LD_INT 1
54270: PUSH
54271: FOR_DOWNTO
54272: IFFALSE 54349
// begin index := rand ( 1 , array ) ;
54274: LD_ADDR_VAR 0 4
54278: PUSH
54279: LD_INT 1
54281: PPUSH
54282: LD_VAR 0 1
54286: PPUSH
54287: CALL_OW 12
54291: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
54292: LD_ADDR_VAR 0 2
54296: PUSH
54297: LD_VAR 0 2
54301: PPUSH
54302: LD_VAR 0 2
54306: PUSH
54307: LD_INT 1
54309: PLUS
54310: PPUSH
54311: LD_VAR 0 1
54315: PUSH
54316: LD_VAR 0 4
54320: ARRAY
54321: PPUSH
54322: CALL_OW 2
54326: ST_TO_ADDR
// array := Delete ( array , index ) ;
54327: LD_ADDR_VAR 0 1
54331: PUSH
54332: LD_VAR 0 1
54336: PPUSH
54337: LD_VAR 0 4
54341: PPUSH
54342: CALL_OW 3
54346: ST_TO_ADDR
// end ;
54347: GO 54271
54349: POP
54350: POP
// end ;
54351: LD_VAR 0 2
54355: RET
// export function GetBaseMaterials ( base ) ; begin
54356: LD_INT 0
54358: PPUSH
// result := [ 0 , 0 , 0 ] ;
54359: LD_ADDR_VAR 0 2
54363: PUSH
54364: LD_INT 0
54366: PUSH
54367: LD_INT 0
54369: PUSH
54370: LD_INT 0
54372: PUSH
54373: EMPTY
54374: LIST
54375: LIST
54376: LIST
54377: ST_TO_ADDR
// if not base then
54378: LD_VAR 0 1
54382: NOT
54383: IFFALSE 54387
// exit ;
54385: GO 54436
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
54387: LD_ADDR_VAR 0 2
54391: PUSH
54392: LD_VAR 0 1
54396: PPUSH
54397: LD_INT 1
54399: PPUSH
54400: CALL_OW 275
54404: PUSH
54405: LD_VAR 0 1
54409: PPUSH
54410: LD_INT 2
54412: PPUSH
54413: CALL_OW 275
54417: PUSH
54418: LD_VAR 0 1
54422: PPUSH
54423: LD_INT 3
54425: PPUSH
54426: CALL_OW 275
54430: PUSH
54431: EMPTY
54432: LIST
54433: LIST
54434: LIST
54435: ST_TO_ADDR
// end ;
54436: LD_VAR 0 2
54440: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
54441: LD_INT 0
54443: PPUSH
54444: PPUSH
// result := array ;
54445: LD_ADDR_VAR 0 3
54449: PUSH
54450: LD_VAR 0 1
54454: ST_TO_ADDR
// if size >= result then
54455: LD_VAR 0 2
54459: PUSH
54460: LD_VAR 0 3
54464: GREATEREQUAL
54465: IFFALSE 54469
// exit ;
54467: GO 54519
// if size then
54469: LD_VAR 0 2
54473: IFFALSE 54519
// for i := array downto size do
54475: LD_ADDR_VAR 0 4
54479: PUSH
54480: DOUBLE
54481: LD_VAR 0 1
54485: INC
54486: ST_TO_ADDR
54487: LD_VAR 0 2
54491: PUSH
54492: FOR_DOWNTO
54493: IFFALSE 54517
// result := Delete ( result , result ) ;
54495: LD_ADDR_VAR 0 3
54499: PUSH
54500: LD_VAR 0 3
54504: PPUSH
54505: LD_VAR 0 3
54509: PPUSH
54510: CALL_OW 3
54514: ST_TO_ADDR
54515: GO 54492
54517: POP
54518: POP
// end ;
54519: LD_VAR 0 3
54523: RET
// export function ComExit ( unit ) ; var tmp ; begin
54524: LD_INT 0
54526: PPUSH
54527: PPUSH
// if not IsInUnit ( unit ) then
54528: LD_VAR 0 1
54532: PPUSH
54533: CALL_OW 310
54537: NOT
54538: IFFALSE 54542
// exit ;
54540: GO 54602
// tmp := IsInUnit ( unit ) ;
54542: LD_ADDR_VAR 0 3
54546: PUSH
54547: LD_VAR 0 1
54551: PPUSH
54552: CALL_OW 310
54556: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
54557: LD_VAR 0 3
54561: PPUSH
54562: CALL_OW 247
54566: PUSH
54567: LD_INT 2
54569: EQUAL
54570: IFFALSE 54583
// ComExitVehicle ( unit ) else
54572: LD_VAR 0 1
54576: PPUSH
54577: CALL_OW 121
54581: GO 54592
// ComExitBuilding ( unit ) ;
54583: LD_VAR 0 1
54587: PPUSH
54588: CALL_OW 122
// result := tmp ;
54592: LD_ADDR_VAR 0 2
54596: PUSH
54597: LD_VAR 0 3
54601: ST_TO_ADDR
// end ;
54602: LD_VAR 0 2
54606: RET
// export function ComExitAll ( units ) ; var i ; begin
54607: LD_INT 0
54609: PPUSH
54610: PPUSH
// if not units then
54611: LD_VAR 0 1
54615: NOT
54616: IFFALSE 54620
// exit ;
54618: GO 54646
// for i in units do
54620: LD_ADDR_VAR 0 3
54624: PUSH
54625: LD_VAR 0 1
54629: PUSH
54630: FOR_IN
54631: IFFALSE 54644
// ComExit ( i ) ;
54633: LD_VAR 0 3
54637: PPUSH
54638: CALL 54524 0 1
54642: GO 54630
54644: POP
54645: POP
// end ;
54646: LD_VAR 0 2
54650: RET
// export function ResetHc ; begin
54651: LD_INT 0
54653: PPUSH
// InitHc ;
54654: CALL_OW 19
// hc_importance := 0 ;
54658: LD_ADDR_OWVAR 32
54662: PUSH
54663: LD_INT 0
54665: ST_TO_ADDR
// end ;
54666: LD_VAR 0 1
54670: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
54671: LD_INT 0
54673: PPUSH
54674: PPUSH
54675: PPUSH
// _x := ( x1 + x2 ) div 2 ;
54676: LD_ADDR_VAR 0 6
54680: PUSH
54681: LD_VAR 0 1
54685: PUSH
54686: LD_VAR 0 3
54690: PLUS
54691: PUSH
54692: LD_INT 2
54694: DIV
54695: ST_TO_ADDR
// if _x < 0 then
54696: LD_VAR 0 6
54700: PUSH
54701: LD_INT 0
54703: LESS
54704: IFFALSE 54721
// _x := _x * - 1 ;
54706: LD_ADDR_VAR 0 6
54710: PUSH
54711: LD_VAR 0 6
54715: PUSH
54716: LD_INT 1
54718: NEG
54719: MUL
54720: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
54721: LD_ADDR_VAR 0 7
54725: PUSH
54726: LD_VAR 0 2
54730: PUSH
54731: LD_VAR 0 4
54735: PLUS
54736: PUSH
54737: LD_INT 2
54739: DIV
54740: ST_TO_ADDR
// if _y < 0 then
54741: LD_VAR 0 7
54745: PUSH
54746: LD_INT 0
54748: LESS
54749: IFFALSE 54766
// _y := _y * - 1 ;
54751: LD_ADDR_VAR 0 7
54755: PUSH
54756: LD_VAR 0 7
54760: PUSH
54761: LD_INT 1
54763: NEG
54764: MUL
54765: ST_TO_ADDR
// result := [ _x , _y ] ;
54766: LD_ADDR_VAR 0 5
54770: PUSH
54771: LD_VAR 0 6
54775: PUSH
54776: LD_VAR 0 7
54780: PUSH
54781: EMPTY
54782: LIST
54783: LIST
54784: ST_TO_ADDR
// end ;
54785: LD_VAR 0 5
54789: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
54790: LD_INT 0
54792: PPUSH
54793: PPUSH
54794: PPUSH
54795: PPUSH
// task := GetTaskList ( unit ) ;
54796: LD_ADDR_VAR 0 7
54800: PUSH
54801: LD_VAR 0 1
54805: PPUSH
54806: CALL_OW 437
54810: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
54811: LD_VAR 0 7
54815: NOT
54816: PUSH
54817: LD_VAR 0 1
54821: PPUSH
54822: LD_VAR 0 2
54826: PPUSH
54827: CALL_OW 308
54831: NOT
54832: AND
54833: IFFALSE 54837
// exit ;
54835: GO 54955
// if IsInArea ( unit , area ) then
54837: LD_VAR 0 1
54841: PPUSH
54842: LD_VAR 0 2
54846: PPUSH
54847: CALL_OW 308
54851: IFFALSE 54869
// begin ComMoveToArea ( unit , goAway ) ;
54853: LD_VAR 0 1
54857: PPUSH
54858: LD_VAR 0 3
54862: PPUSH
54863: CALL_OW 113
// exit ;
54867: GO 54955
// end ; if task [ 1 ] [ 1 ] <> M then
54869: LD_VAR 0 7
54873: PUSH
54874: LD_INT 1
54876: ARRAY
54877: PUSH
54878: LD_INT 1
54880: ARRAY
54881: PUSH
54882: LD_STRING M
54884: NONEQUAL
54885: IFFALSE 54889
// exit ;
54887: GO 54955
// x := task [ 1 ] [ 2 ] ;
54889: LD_ADDR_VAR 0 5
54893: PUSH
54894: LD_VAR 0 7
54898: PUSH
54899: LD_INT 1
54901: ARRAY
54902: PUSH
54903: LD_INT 2
54905: ARRAY
54906: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
54907: LD_ADDR_VAR 0 6
54911: PUSH
54912: LD_VAR 0 7
54916: PUSH
54917: LD_INT 1
54919: ARRAY
54920: PUSH
54921: LD_INT 3
54923: ARRAY
54924: ST_TO_ADDR
// if InArea ( x , y , area ) then
54925: LD_VAR 0 5
54929: PPUSH
54930: LD_VAR 0 6
54934: PPUSH
54935: LD_VAR 0 2
54939: PPUSH
54940: CALL_OW 309
54944: IFFALSE 54955
// ComStop ( unit ) ;
54946: LD_VAR 0 1
54950: PPUSH
54951: CALL_OW 141
// end ;
54955: LD_VAR 0 4
54959: RET
// export function Abs ( value ) ; begin
54960: LD_INT 0
54962: PPUSH
// result := value ;
54963: LD_ADDR_VAR 0 2
54967: PUSH
54968: LD_VAR 0 1
54972: ST_TO_ADDR
// if value < 0 then
54973: LD_VAR 0 1
54977: PUSH
54978: LD_INT 0
54980: LESS
54981: IFFALSE 54998
// result := value * - 1 ;
54983: LD_ADDR_VAR 0 2
54987: PUSH
54988: LD_VAR 0 1
54992: PUSH
54993: LD_INT 1
54995: NEG
54996: MUL
54997: ST_TO_ADDR
// end ;
54998: LD_VAR 0 2
55002: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
55003: LD_INT 0
55005: PPUSH
55006: PPUSH
55007: PPUSH
55008: PPUSH
55009: PPUSH
55010: PPUSH
55011: PPUSH
55012: PPUSH
// if not unit or not building then
55013: LD_VAR 0 1
55017: NOT
55018: PUSH
55019: LD_VAR 0 2
55023: NOT
55024: OR
55025: IFFALSE 55029
// exit ;
55027: GO 55255
// x := GetX ( building ) ;
55029: LD_ADDR_VAR 0 4
55033: PUSH
55034: LD_VAR 0 2
55038: PPUSH
55039: CALL_OW 250
55043: ST_TO_ADDR
// y := GetY ( building ) ;
55044: LD_ADDR_VAR 0 6
55048: PUSH
55049: LD_VAR 0 2
55053: PPUSH
55054: CALL_OW 251
55058: ST_TO_ADDR
// d := GetDir ( building ) ;
55059: LD_ADDR_VAR 0 8
55063: PUSH
55064: LD_VAR 0 2
55068: PPUSH
55069: CALL_OW 254
55073: ST_TO_ADDR
// r := 4 ;
55074: LD_ADDR_VAR 0 9
55078: PUSH
55079: LD_INT 4
55081: ST_TO_ADDR
// for i := 1 to 5 do
55082: LD_ADDR_VAR 0 10
55086: PUSH
55087: DOUBLE
55088: LD_INT 1
55090: DEC
55091: ST_TO_ADDR
55092: LD_INT 5
55094: PUSH
55095: FOR_TO
55096: IFFALSE 55253
// begin _x := ShiftX ( x , d , r + i ) ;
55098: LD_ADDR_VAR 0 5
55102: PUSH
55103: LD_VAR 0 4
55107: PPUSH
55108: LD_VAR 0 8
55112: PPUSH
55113: LD_VAR 0 9
55117: PUSH
55118: LD_VAR 0 10
55122: PLUS
55123: PPUSH
55124: CALL_OW 272
55128: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
55129: LD_ADDR_VAR 0 7
55133: PUSH
55134: LD_VAR 0 6
55138: PPUSH
55139: LD_VAR 0 8
55143: PPUSH
55144: LD_VAR 0 9
55148: PUSH
55149: LD_VAR 0 10
55153: PLUS
55154: PPUSH
55155: CALL_OW 273
55159: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
55160: LD_VAR 0 5
55164: PPUSH
55165: LD_VAR 0 7
55169: PPUSH
55170: CALL_OW 488
55174: PUSH
55175: LD_VAR 0 5
55179: PPUSH
55180: LD_VAR 0 7
55184: PPUSH
55185: CALL_OW 428
55189: PPUSH
55190: CALL_OW 247
55194: PUSH
55195: LD_INT 3
55197: PUSH
55198: LD_INT 2
55200: PUSH
55201: EMPTY
55202: LIST
55203: LIST
55204: IN
55205: NOT
55206: AND
55207: IFFALSE 55251
// begin ComMoveXY ( unit , _x , _y ) ;
55209: LD_VAR 0 1
55213: PPUSH
55214: LD_VAR 0 5
55218: PPUSH
55219: LD_VAR 0 7
55223: PPUSH
55224: CALL_OW 111
// result := [ _x , _y ] ;
55228: LD_ADDR_VAR 0 3
55232: PUSH
55233: LD_VAR 0 5
55237: PUSH
55238: LD_VAR 0 7
55242: PUSH
55243: EMPTY
55244: LIST
55245: LIST
55246: ST_TO_ADDR
// exit ;
55247: POP
55248: POP
55249: GO 55255
// end ; end ;
55251: GO 55095
55253: POP
55254: POP
// end ;
55255: LD_VAR 0 3
55259: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
55260: LD_INT 0
55262: PPUSH
55263: PPUSH
55264: PPUSH
// result := 0 ;
55265: LD_ADDR_VAR 0 3
55269: PUSH
55270: LD_INT 0
55272: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
55273: LD_VAR 0 1
55277: PUSH
55278: LD_INT 0
55280: LESS
55281: PUSH
55282: LD_VAR 0 1
55286: PUSH
55287: LD_INT 8
55289: GREATER
55290: OR
55291: PUSH
55292: LD_VAR 0 2
55296: PUSH
55297: LD_INT 0
55299: LESS
55300: OR
55301: PUSH
55302: LD_VAR 0 2
55306: PUSH
55307: LD_INT 8
55309: GREATER
55310: OR
55311: IFFALSE 55315
// exit ;
55313: GO 55390
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
55315: LD_ADDR_VAR 0 4
55319: PUSH
55320: LD_INT 22
55322: PUSH
55323: LD_VAR 0 2
55327: PUSH
55328: EMPTY
55329: LIST
55330: LIST
55331: PPUSH
55332: CALL_OW 69
55336: PUSH
55337: FOR_IN
55338: IFFALSE 55388
// begin un := UnitShoot ( i ) ;
55340: LD_ADDR_VAR 0 5
55344: PUSH
55345: LD_VAR 0 4
55349: PPUSH
55350: CALL_OW 504
55354: ST_TO_ADDR
// if GetSide ( un ) = side1 then
55355: LD_VAR 0 5
55359: PPUSH
55360: CALL_OW 255
55364: PUSH
55365: LD_VAR 0 1
55369: EQUAL
55370: IFFALSE 55386
// begin result := un ;
55372: LD_ADDR_VAR 0 3
55376: PUSH
55377: LD_VAR 0 5
55381: ST_TO_ADDR
// exit ;
55382: POP
55383: POP
55384: GO 55390
// end ; end ;
55386: GO 55337
55388: POP
55389: POP
// end ;
55390: LD_VAR 0 3
55394: RET
// export function GetCargoBay ( units ) ; begin
55395: LD_INT 0
55397: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
55398: LD_ADDR_VAR 0 2
55402: PUSH
55403: LD_VAR 0 1
55407: PPUSH
55408: LD_INT 2
55410: PUSH
55411: LD_INT 34
55413: PUSH
55414: LD_INT 12
55416: PUSH
55417: EMPTY
55418: LIST
55419: LIST
55420: PUSH
55421: LD_INT 34
55423: PUSH
55424: LD_INT 51
55426: PUSH
55427: EMPTY
55428: LIST
55429: LIST
55430: PUSH
55431: LD_INT 34
55433: PUSH
55434: LD_INT 32
55436: PUSH
55437: EMPTY
55438: LIST
55439: LIST
55440: PUSH
55441: LD_INT 34
55443: PUSH
55444: LD_INT 89
55446: PUSH
55447: EMPTY
55448: LIST
55449: LIST
55450: PUSH
55451: EMPTY
55452: LIST
55453: LIST
55454: LIST
55455: LIST
55456: LIST
55457: PPUSH
55458: CALL_OW 72
55462: ST_TO_ADDR
// end ;
55463: LD_VAR 0 2
55467: RET
// export function Negate ( value ) ; begin
55468: LD_INT 0
55470: PPUSH
// result := not value ;
55471: LD_ADDR_VAR 0 2
55475: PUSH
55476: LD_VAR 0 1
55480: NOT
55481: ST_TO_ADDR
// end ;
55482: LD_VAR 0 2
55486: RET
// export function Inc ( value ) ; begin
55487: LD_INT 0
55489: PPUSH
// result := value + 1 ;
55490: LD_ADDR_VAR 0 2
55494: PUSH
55495: LD_VAR 0 1
55499: PUSH
55500: LD_INT 1
55502: PLUS
55503: ST_TO_ADDR
// end ;
55504: LD_VAR 0 2
55508: RET
// export function Dec ( value ) ; begin
55509: LD_INT 0
55511: PPUSH
// result := value - 1 ;
55512: LD_ADDR_VAR 0 2
55516: PUSH
55517: LD_VAR 0 1
55521: PUSH
55522: LD_INT 1
55524: MINUS
55525: ST_TO_ADDR
// end ;
55526: LD_VAR 0 2
55530: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
55531: LD_INT 0
55533: PPUSH
55534: PPUSH
55535: PPUSH
55536: PPUSH
55537: PPUSH
55538: PPUSH
55539: PPUSH
55540: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
55541: LD_VAR 0 1
55545: PPUSH
55546: LD_VAR 0 2
55550: PPUSH
55551: CALL_OW 488
55555: NOT
55556: PUSH
55557: LD_VAR 0 3
55561: PPUSH
55562: LD_VAR 0 4
55566: PPUSH
55567: CALL_OW 488
55571: NOT
55572: OR
55573: IFFALSE 55586
// begin result := - 1 ;
55575: LD_ADDR_VAR 0 5
55579: PUSH
55580: LD_INT 1
55582: NEG
55583: ST_TO_ADDR
// exit ;
55584: GO 55821
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
55586: LD_ADDR_VAR 0 12
55590: PUSH
55591: LD_VAR 0 1
55595: PPUSH
55596: LD_VAR 0 2
55600: PPUSH
55601: LD_VAR 0 3
55605: PPUSH
55606: LD_VAR 0 4
55610: PPUSH
55611: CALL 54671 0 4
55615: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
55616: LD_ADDR_VAR 0 11
55620: PUSH
55621: LD_VAR 0 1
55625: PPUSH
55626: LD_VAR 0 2
55630: PPUSH
55631: LD_VAR 0 12
55635: PUSH
55636: LD_INT 1
55638: ARRAY
55639: PPUSH
55640: LD_VAR 0 12
55644: PUSH
55645: LD_INT 2
55647: ARRAY
55648: PPUSH
55649: CALL_OW 298
55653: ST_TO_ADDR
// distance := 9999 ;
55654: LD_ADDR_VAR 0 10
55658: PUSH
55659: LD_INT 9999
55661: ST_TO_ADDR
// for i := 0 to 5 do
55662: LD_ADDR_VAR 0 6
55666: PUSH
55667: DOUBLE
55668: LD_INT 0
55670: DEC
55671: ST_TO_ADDR
55672: LD_INT 5
55674: PUSH
55675: FOR_TO
55676: IFFALSE 55819
// begin _x := ShiftX ( x1 , i , centerDist ) ;
55678: LD_ADDR_VAR 0 7
55682: PUSH
55683: LD_VAR 0 1
55687: PPUSH
55688: LD_VAR 0 6
55692: PPUSH
55693: LD_VAR 0 11
55697: PPUSH
55698: CALL_OW 272
55702: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
55703: LD_ADDR_VAR 0 8
55707: PUSH
55708: LD_VAR 0 2
55712: PPUSH
55713: LD_VAR 0 6
55717: PPUSH
55718: LD_VAR 0 11
55722: PPUSH
55723: CALL_OW 273
55727: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
55728: LD_VAR 0 7
55732: PPUSH
55733: LD_VAR 0 8
55737: PPUSH
55738: CALL_OW 488
55742: NOT
55743: IFFALSE 55747
// continue ;
55745: GO 55675
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
55747: LD_ADDR_VAR 0 9
55751: PUSH
55752: LD_VAR 0 12
55756: PUSH
55757: LD_INT 1
55759: ARRAY
55760: PPUSH
55761: LD_VAR 0 12
55765: PUSH
55766: LD_INT 2
55768: ARRAY
55769: PPUSH
55770: LD_VAR 0 7
55774: PPUSH
55775: LD_VAR 0 8
55779: PPUSH
55780: CALL_OW 298
55784: ST_TO_ADDR
// if tmp < distance then
55785: LD_VAR 0 9
55789: PUSH
55790: LD_VAR 0 10
55794: LESS
55795: IFFALSE 55817
// begin result := i ;
55797: LD_ADDR_VAR 0 5
55801: PUSH
55802: LD_VAR 0 6
55806: ST_TO_ADDR
// distance := tmp ;
55807: LD_ADDR_VAR 0 10
55811: PUSH
55812: LD_VAR 0 9
55816: ST_TO_ADDR
// end ; end ;
55817: GO 55675
55819: POP
55820: POP
// end ;
55821: LD_VAR 0 5
55825: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
55826: LD_INT 0
55828: PPUSH
55829: PPUSH
// if not driver or not IsInUnit ( driver ) then
55830: LD_VAR 0 1
55834: NOT
55835: PUSH
55836: LD_VAR 0 1
55840: PPUSH
55841: CALL_OW 310
55845: NOT
55846: OR
55847: IFFALSE 55851
// exit ;
55849: GO 55941
// vehicle := IsInUnit ( driver ) ;
55851: LD_ADDR_VAR 0 3
55855: PUSH
55856: LD_VAR 0 1
55860: PPUSH
55861: CALL_OW 310
55865: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
55866: LD_VAR 0 1
55870: PPUSH
55871: LD_STRING \
55873: PUSH
55874: LD_INT 0
55876: PUSH
55877: LD_INT 0
55879: PUSH
55880: LD_INT 0
55882: PUSH
55883: LD_INT 0
55885: PUSH
55886: LD_INT 0
55888: PUSH
55889: LD_INT 0
55891: PUSH
55892: EMPTY
55893: LIST
55894: LIST
55895: LIST
55896: LIST
55897: LIST
55898: LIST
55899: LIST
55900: PUSH
55901: LD_STRING E
55903: PUSH
55904: LD_INT 0
55906: PUSH
55907: LD_INT 0
55909: PUSH
55910: LD_VAR 0 3
55914: PUSH
55915: LD_INT 0
55917: PUSH
55918: LD_INT 0
55920: PUSH
55921: LD_INT 0
55923: PUSH
55924: EMPTY
55925: LIST
55926: LIST
55927: LIST
55928: LIST
55929: LIST
55930: LIST
55931: LIST
55932: PUSH
55933: EMPTY
55934: LIST
55935: LIST
55936: PPUSH
55937: CALL_OW 446
// end ;
55941: LD_VAR 0 2
55945: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
55946: LD_INT 0
55948: PPUSH
55949: PPUSH
// if not driver or not IsInUnit ( driver ) then
55950: LD_VAR 0 1
55954: NOT
55955: PUSH
55956: LD_VAR 0 1
55960: PPUSH
55961: CALL_OW 310
55965: NOT
55966: OR
55967: IFFALSE 55971
// exit ;
55969: GO 56061
// vehicle := IsInUnit ( driver ) ;
55971: LD_ADDR_VAR 0 3
55975: PUSH
55976: LD_VAR 0 1
55980: PPUSH
55981: CALL_OW 310
55985: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
55986: LD_VAR 0 1
55990: PPUSH
55991: LD_STRING \
55993: PUSH
55994: LD_INT 0
55996: PUSH
55997: LD_INT 0
55999: PUSH
56000: LD_INT 0
56002: PUSH
56003: LD_INT 0
56005: PUSH
56006: LD_INT 0
56008: PUSH
56009: LD_INT 0
56011: PUSH
56012: EMPTY
56013: LIST
56014: LIST
56015: LIST
56016: LIST
56017: LIST
56018: LIST
56019: LIST
56020: PUSH
56021: LD_STRING E
56023: PUSH
56024: LD_INT 0
56026: PUSH
56027: LD_INT 0
56029: PUSH
56030: LD_VAR 0 3
56034: PUSH
56035: LD_INT 0
56037: PUSH
56038: LD_INT 0
56040: PUSH
56041: LD_INT 0
56043: PUSH
56044: EMPTY
56045: LIST
56046: LIST
56047: LIST
56048: LIST
56049: LIST
56050: LIST
56051: LIST
56052: PUSH
56053: EMPTY
56054: LIST
56055: LIST
56056: PPUSH
56057: CALL_OW 447
// end ;
56061: LD_VAR 0 2
56065: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
56066: LD_INT 0
56068: PPUSH
56069: PPUSH
56070: PPUSH
// tmp := [ ] ;
56071: LD_ADDR_VAR 0 5
56075: PUSH
56076: EMPTY
56077: ST_TO_ADDR
// for i in units do
56078: LD_ADDR_VAR 0 4
56082: PUSH
56083: LD_VAR 0 1
56087: PUSH
56088: FOR_IN
56089: IFFALSE 56127
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
56091: LD_ADDR_VAR 0 5
56095: PUSH
56096: LD_VAR 0 5
56100: PPUSH
56101: LD_VAR 0 5
56105: PUSH
56106: LD_INT 1
56108: PLUS
56109: PPUSH
56110: LD_VAR 0 4
56114: PPUSH
56115: CALL_OW 256
56119: PPUSH
56120: CALL_OW 2
56124: ST_TO_ADDR
56125: GO 56088
56127: POP
56128: POP
// if not tmp then
56129: LD_VAR 0 5
56133: NOT
56134: IFFALSE 56138
// exit ;
56136: GO 56186
// if asc then
56138: LD_VAR 0 2
56142: IFFALSE 56166
// result := SortListByListAsc ( units , tmp ) else
56144: LD_ADDR_VAR 0 3
56148: PUSH
56149: LD_VAR 0 1
56153: PPUSH
56154: LD_VAR 0 5
56158: PPUSH
56159: CALL_OW 76
56163: ST_TO_ADDR
56164: GO 56186
// result := SortListByListDesc ( units , tmp ) ;
56166: LD_ADDR_VAR 0 3
56170: PUSH
56171: LD_VAR 0 1
56175: PPUSH
56176: LD_VAR 0 5
56180: PPUSH
56181: CALL_OW 77
56185: ST_TO_ADDR
// end ;
56186: LD_VAR 0 3
56190: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
56191: LD_INT 0
56193: PPUSH
56194: PPUSH
// task := GetTaskList ( mech ) ;
56195: LD_ADDR_VAR 0 4
56199: PUSH
56200: LD_VAR 0 1
56204: PPUSH
56205: CALL_OW 437
56209: ST_TO_ADDR
// if not task then
56210: LD_VAR 0 4
56214: NOT
56215: IFFALSE 56219
// exit ;
56217: GO 56261
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
56219: LD_ADDR_VAR 0 3
56223: PUSH
56224: LD_VAR 0 4
56228: PUSH
56229: LD_INT 1
56231: ARRAY
56232: PUSH
56233: LD_INT 1
56235: ARRAY
56236: PUSH
56237: LD_STRING r
56239: EQUAL
56240: PUSH
56241: LD_VAR 0 4
56245: PUSH
56246: LD_INT 1
56248: ARRAY
56249: PUSH
56250: LD_INT 4
56252: ARRAY
56253: PUSH
56254: LD_VAR 0 2
56258: EQUAL
56259: AND
56260: ST_TO_ADDR
// end ;
56261: LD_VAR 0 3
56265: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
56266: LD_INT 0
56268: PPUSH
// SetDir ( unit , d ) ;
56269: LD_VAR 0 1
56273: PPUSH
56274: LD_VAR 0 4
56278: PPUSH
56279: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
56283: LD_VAR 0 1
56287: PPUSH
56288: LD_VAR 0 2
56292: PPUSH
56293: LD_VAR 0 3
56297: PPUSH
56298: LD_VAR 0 5
56302: PPUSH
56303: CALL_OW 48
// end ;
56307: LD_VAR 0 6
56311: RET
// export function ToNaturalNumber ( number ) ; begin
56312: LD_INT 0
56314: PPUSH
// result := number div 1 ;
56315: LD_ADDR_VAR 0 2
56319: PUSH
56320: LD_VAR 0 1
56324: PUSH
56325: LD_INT 1
56327: DIV
56328: ST_TO_ADDR
// if number < 0 then
56329: LD_VAR 0 1
56333: PUSH
56334: LD_INT 0
56336: LESS
56337: IFFALSE 56347
// result := 0 ;
56339: LD_ADDR_VAR 0 2
56343: PUSH
56344: LD_INT 0
56346: ST_TO_ADDR
// end ;
56347: LD_VAR 0 2
56351: RET
// export function SortByClass ( units , class ) ; var un ; begin
56352: LD_INT 0
56354: PPUSH
56355: PPUSH
// if not units or not class then
56356: LD_VAR 0 1
56360: NOT
56361: PUSH
56362: LD_VAR 0 2
56366: NOT
56367: OR
56368: IFFALSE 56372
// exit ;
56370: GO 56467
// result := [ ] ;
56372: LD_ADDR_VAR 0 3
56376: PUSH
56377: EMPTY
56378: ST_TO_ADDR
// for un in units do
56379: LD_ADDR_VAR 0 4
56383: PUSH
56384: LD_VAR 0 1
56388: PUSH
56389: FOR_IN
56390: IFFALSE 56465
// if GetClass ( un ) = class then
56392: LD_VAR 0 4
56396: PPUSH
56397: CALL_OW 257
56401: PUSH
56402: LD_VAR 0 2
56406: EQUAL
56407: IFFALSE 56434
// result := Insert ( result , 1 , un ) else
56409: LD_ADDR_VAR 0 3
56413: PUSH
56414: LD_VAR 0 3
56418: PPUSH
56419: LD_INT 1
56421: PPUSH
56422: LD_VAR 0 4
56426: PPUSH
56427: CALL_OW 2
56431: ST_TO_ADDR
56432: GO 56463
// result := Replace ( result , result + 1 , un ) ;
56434: LD_ADDR_VAR 0 3
56438: PUSH
56439: LD_VAR 0 3
56443: PPUSH
56444: LD_VAR 0 3
56448: PUSH
56449: LD_INT 1
56451: PLUS
56452: PPUSH
56453: LD_VAR 0 4
56457: PPUSH
56458: CALL_OW 1
56462: ST_TO_ADDR
56463: GO 56389
56465: POP
56466: POP
// end ;
56467: LD_VAR 0 3
56471: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
56472: LD_INT 0
56474: PPUSH
56475: PPUSH
56476: PPUSH
56477: PPUSH
56478: PPUSH
56479: PPUSH
56480: PPUSH
// result := [ ] ;
56481: LD_ADDR_VAR 0 4
56485: PUSH
56486: EMPTY
56487: ST_TO_ADDR
// if x - r < 0 then
56488: LD_VAR 0 1
56492: PUSH
56493: LD_VAR 0 3
56497: MINUS
56498: PUSH
56499: LD_INT 0
56501: LESS
56502: IFFALSE 56514
// min_x := 0 else
56504: LD_ADDR_VAR 0 8
56508: PUSH
56509: LD_INT 0
56511: ST_TO_ADDR
56512: GO 56530
// min_x := x - r ;
56514: LD_ADDR_VAR 0 8
56518: PUSH
56519: LD_VAR 0 1
56523: PUSH
56524: LD_VAR 0 3
56528: MINUS
56529: ST_TO_ADDR
// if y - r < 0 then
56530: LD_VAR 0 2
56534: PUSH
56535: LD_VAR 0 3
56539: MINUS
56540: PUSH
56541: LD_INT 0
56543: LESS
56544: IFFALSE 56556
// min_y := 0 else
56546: LD_ADDR_VAR 0 7
56550: PUSH
56551: LD_INT 0
56553: ST_TO_ADDR
56554: GO 56572
// min_y := y - r ;
56556: LD_ADDR_VAR 0 7
56560: PUSH
56561: LD_VAR 0 2
56565: PUSH
56566: LD_VAR 0 3
56570: MINUS
56571: ST_TO_ADDR
// max_x := x + r ;
56572: LD_ADDR_VAR 0 9
56576: PUSH
56577: LD_VAR 0 1
56581: PUSH
56582: LD_VAR 0 3
56586: PLUS
56587: ST_TO_ADDR
// max_y := y + r ;
56588: LD_ADDR_VAR 0 10
56592: PUSH
56593: LD_VAR 0 2
56597: PUSH
56598: LD_VAR 0 3
56602: PLUS
56603: ST_TO_ADDR
// for _x = min_x to max_x do
56604: LD_ADDR_VAR 0 5
56608: PUSH
56609: DOUBLE
56610: LD_VAR 0 8
56614: DEC
56615: ST_TO_ADDR
56616: LD_VAR 0 9
56620: PUSH
56621: FOR_TO
56622: IFFALSE 56723
// for _y = min_y to max_y do
56624: LD_ADDR_VAR 0 6
56628: PUSH
56629: DOUBLE
56630: LD_VAR 0 7
56634: DEC
56635: ST_TO_ADDR
56636: LD_VAR 0 10
56640: PUSH
56641: FOR_TO
56642: IFFALSE 56719
// begin if not ValidHex ( _x , _y ) then
56644: LD_VAR 0 5
56648: PPUSH
56649: LD_VAR 0 6
56653: PPUSH
56654: CALL_OW 488
56658: NOT
56659: IFFALSE 56663
// continue ;
56661: GO 56641
// if GetResourceTypeXY ( _x , _y ) then
56663: LD_VAR 0 5
56667: PPUSH
56668: LD_VAR 0 6
56672: PPUSH
56673: CALL_OW 283
56677: IFFALSE 56717
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
56679: LD_ADDR_VAR 0 4
56683: PUSH
56684: LD_VAR 0 4
56688: PPUSH
56689: LD_VAR 0 4
56693: PUSH
56694: LD_INT 1
56696: PLUS
56697: PPUSH
56698: LD_VAR 0 5
56702: PUSH
56703: LD_VAR 0 6
56707: PUSH
56708: EMPTY
56709: LIST
56710: LIST
56711: PPUSH
56712: CALL_OW 1
56716: ST_TO_ADDR
// end ;
56717: GO 56641
56719: POP
56720: POP
56721: GO 56621
56723: POP
56724: POP
// end ;
56725: LD_VAR 0 4
56729: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
56730: LD_INT 0
56732: PPUSH
56733: PPUSH
56734: PPUSH
56735: PPUSH
56736: PPUSH
56737: PPUSH
56738: PPUSH
56739: PPUSH
// if not units then
56740: LD_VAR 0 1
56744: NOT
56745: IFFALSE 56749
// exit ;
56747: GO 57273
// result := UnitFilter ( units , [ f_ok ] ) ;
56749: LD_ADDR_VAR 0 3
56753: PUSH
56754: LD_VAR 0 1
56758: PPUSH
56759: LD_INT 50
56761: PUSH
56762: EMPTY
56763: LIST
56764: PPUSH
56765: CALL_OW 72
56769: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
56770: LD_ADDR_VAR 0 8
56774: PUSH
56775: LD_VAR 0 1
56779: PUSH
56780: LD_INT 1
56782: ARRAY
56783: PPUSH
56784: CALL_OW 255
56788: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
56789: LD_ADDR_VAR 0 10
56793: PUSH
56794: LD_INT 29
56796: PUSH
56797: LD_INT 91
56799: PUSH
56800: LD_INT 49
56802: PUSH
56803: EMPTY
56804: LIST
56805: LIST
56806: LIST
56807: ST_TO_ADDR
// if not result then
56808: LD_VAR 0 3
56812: NOT
56813: IFFALSE 56817
// exit ;
56815: GO 57273
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
56817: LD_ADDR_VAR 0 5
56821: PUSH
56822: LD_INT 81
56824: PUSH
56825: LD_VAR 0 8
56829: PUSH
56830: EMPTY
56831: LIST
56832: LIST
56833: PPUSH
56834: CALL_OW 69
56838: ST_TO_ADDR
// for i in result do
56839: LD_ADDR_VAR 0 4
56843: PUSH
56844: LD_VAR 0 3
56848: PUSH
56849: FOR_IN
56850: IFFALSE 57271
// begin tag := GetTag ( i ) + 1 ;
56852: LD_ADDR_VAR 0 9
56856: PUSH
56857: LD_VAR 0 4
56861: PPUSH
56862: CALL_OW 110
56866: PUSH
56867: LD_INT 1
56869: PLUS
56870: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
56871: LD_ADDR_VAR 0 7
56875: PUSH
56876: LD_VAR 0 4
56880: PPUSH
56881: CALL_OW 250
56885: PPUSH
56886: LD_VAR 0 4
56890: PPUSH
56891: CALL_OW 251
56895: PPUSH
56896: LD_INT 6
56898: PPUSH
56899: CALL 56472 0 3
56903: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
56904: LD_VAR 0 4
56908: PPUSH
56909: CALL_OW 247
56913: PUSH
56914: LD_INT 2
56916: EQUAL
56917: PUSH
56918: LD_VAR 0 7
56922: AND
56923: PUSH
56924: LD_VAR 0 4
56928: PPUSH
56929: CALL_OW 264
56933: PUSH
56934: LD_VAR 0 10
56938: IN
56939: NOT
56940: AND
56941: IFFALSE 56980
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
56943: LD_VAR 0 4
56947: PPUSH
56948: LD_VAR 0 7
56952: PUSH
56953: LD_INT 1
56955: ARRAY
56956: PUSH
56957: LD_INT 1
56959: ARRAY
56960: PPUSH
56961: LD_VAR 0 7
56965: PUSH
56966: LD_INT 1
56968: ARRAY
56969: PUSH
56970: LD_INT 2
56972: ARRAY
56973: PPUSH
56974: CALL_OW 116
56978: GO 57269
// if path > tag then
56980: LD_VAR 0 2
56984: PUSH
56985: LD_VAR 0 9
56989: GREATER
56990: IFFALSE 57198
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
56992: LD_ADDR_VAR 0 6
56996: PUSH
56997: LD_VAR 0 5
57001: PPUSH
57002: LD_INT 91
57004: PUSH
57005: LD_VAR 0 4
57009: PUSH
57010: LD_INT 8
57012: PUSH
57013: EMPTY
57014: LIST
57015: LIST
57016: LIST
57017: PPUSH
57018: CALL_OW 72
57022: ST_TO_ADDR
// if nearEnemy then
57023: LD_VAR 0 6
57027: IFFALSE 57096
// begin if GetWeapon ( i ) = ru_time_lapser then
57029: LD_VAR 0 4
57033: PPUSH
57034: CALL_OW 264
57038: PUSH
57039: LD_INT 49
57041: EQUAL
57042: IFFALSE 57070
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
57044: LD_VAR 0 4
57048: PPUSH
57049: LD_VAR 0 6
57053: PPUSH
57054: LD_VAR 0 4
57058: PPUSH
57059: CALL_OW 74
57063: PPUSH
57064: CALL_OW 112
57068: GO 57094
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
57070: LD_VAR 0 4
57074: PPUSH
57075: LD_VAR 0 6
57079: PPUSH
57080: LD_VAR 0 4
57084: PPUSH
57085: CALL_OW 74
57089: PPUSH
57090: CALL 58198 0 2
// end else
57094: GO 57196
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
57096: LD_VAR 0 4
57100: PPUSH
57101: LD_VAR 0 2
57105: PUSH
57106: LD_VAR 0 9
57110: ARRAY
57111: PUSH
57112: LD_INT 1
57114: ARRAY
57115: PPUSH
57116: LD_VAR 0 2
57120: PUSH
57121: LD_VAR 0 9
57125: ARRAY
57126: PUSH
57127: LD_INT 2
57129: ARRAY
57130: PPUSH
57131: CALL_OW 297
57135: PUSH
57136: LD_INT 6
57138: GREATER
57139: IFFALSE 57182
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
57141: LD_VAR 0 4
57145: PPUSH
57146: LD_VAR 0 2
57150: PUSH
57151: LD_VAR 0 9
57155: ARRAY
57156: PUSH
57157: LD_INT 1
57159: ARRAY
57160: PPUSH
57161: LD_VAR 0 2
57165: PUSH
57166: LD_VAR 0 9
57170: ARRAY
57171: PUSH
57172: LD_INT 2
57174: ARRAY
57175: PPUSH
57176: CALL_OW 114
57180: GO 57196
// SetTag ( i , tag ) ;
57182: LD_VAR 0 4
57186: PPUSH
57187: LD_VAR 0 9
57191: PPUSH
57192: CALL_OW 109
// end else
57196: GO 57269
// if enemy then
57198: LD_VAR 0 5
57202: IFFALSE 57269
// begin if GetWeapon ( i ) = ru_time_lapser then
57204: LD_VAR 0 4
57208: PPUSH
57209: CALL_OW 264
57213: PUSH
57214: LD_INT 49
57216: EQUAL
57217: IFFALSE 57245
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
57219: LD_VAR 0 4
57223: PPUSH
57224: LD_VAR 0 5
57228: PPUSH
57229: LD_VAR 0 4
57233: PPUSH
57234: CALL_OW 74
57238: PPUSH
57239: CALL_OW 112
57243: GO 57269
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
57245: LD_VAR 0 4
57249: PPUSH
57250: LD_VAR 0 5
57254: PPUSH
57255: LD_VAR 0 4
57259: PPUSH
57260: CALL_OW 74
57264: PPUSH
57265: CALL 58198 0 2
// end ; end ;
57269: GO 56849
57271: POP
57272: POP
// end ;
57273: LD_VAR 0 3
57277: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
57278: LD_INT 0
57280: PPUSH
57281: PPUSH
57282: PPUSH
// if not unit or IsInUnit ( unit ) then
57283: LD_VAR 0 1
57287: NOT
57288: PUSH
57289: LD_VAR 0 1
57293: PPUSH
57294: CALL_OW 310
57298: OR
57299: IFFALSE 57303
// exit ;
57301: GO 57394
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
57303: LD_ADDR_VAR 0 4
57307: PUSH
57308: LD_VAR 0 1
57312: PPUSH
57313: CALL_OW 250
57317: PPUSH
57318: LD_VAR 0 2
57322: PPUSH
57323: LD_INT 1
57325: PPUSH
57326: CALL_OW 272
57330: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
57331: LD_ADDR_VAR 0 5
57335: PUSH
57336: LD_VAR 0 1
57340: PPUSH
57341: CALL_OW 251
57345: PPUSH
57346: LD_VAR 0 2
57350: PPUSH
57351: LD_INT 1
57353: PPUSH
57354: CALL_OW 273
57358: ST_TO_ADDR
// if ValidHex ( x , y ) then
57359: LD_VAR 0 4
57363: PPUSH
57364: LD_VAR 0 5
57368: PPUSH
57369: CALL_OW 488
57373: IFFALSE 57394
// ComTurnXY ( unit , x , y ) ;
57375: LD_VAR 0 1
57379: PPUSH
57380: LD_VAR 0 4
57384: PPUSH
57385: LD_VAR 0 5
57389: PPUSH
57390: CALL_OW 118
// end ;
57394: LD_VAR 0 3
57398: RET
// export function SeeUnits ( side , units ) ; var i ; begin
57399: LD_INT 0
57401: PPUSH
57402: PPUSH
// result := false ;
57403: LD_ADDR_VAR 0 3
57407: PUSH
57408: LD_INT 0
57410: ST_TO_ADDR
// if not units then
57411: LD_VAR 0 2
57415: NOT
57416: IFFALSE 57420
// exit ;
57418: GO 57465
// for i in units do
57420: LD_ADDR_VAR 0 4
57424: PUSH
57425: LD_VAR 0 2
57429: PUSH
57430: FOR_IN
57431: IFFALSE 57463
// if See ( side , i ) then
57433: LD_VAR 0 1
57437: PPUSH
57438: LD_VAR 0 4
57442: PPUSH
57443: CALL_OW 292
57447: IFFALSE 57461
// begin result := true ;
57449: LD_ADDR_VAR 0 3
57453: PUSH
57454: LD_INT 1
57456: ST_TO_ADDR
// exit ;
57457: POP
57458: POP
57459: GO 57465
// end ;
57461: GO 57430
57463: POP
57464: POP
// end ;
57465: LD_VAR 0 3
57469: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
57470: LD_INT 0
57472: PPUSH
57473: PPUSH
57474: PPUSH
57475: PPUSH
// if not unit or not points then
57476: LD_VAR 0 1
57480: NOT
57481: PUSH
57482: LD_VAR 0 2
57486: NOT
57487: OR
57488: IFFALSE 57492
// exit ;
57490: GO 57582
// dist := 99999 ;
57492: LD_ADDR_VAR 0 5
57496: PUSH
57497: LD_INT 99999
57499: ST_TO_ADDR
// for i in points do
57500: LD_ADDR_VAR 0 4
57504: PUSH
57505: LD_VAR 0 2
57509: PUSH
57510: FOR_IN
57511: IFFALSE 57580
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
57513: LD_ADDR_VAR 0 6
57517: PUSH
57518: LD_VAR 0 1
57522: PPUSH
57523: LD_VAR 0 4
57527: PUSH
57528: LD_INT 1
57530: ARRAY
57531: PPUSH
57532: LD_VAR 0 4
57536: PUSH
57537: LD_INT 2
57539: ARRAY
57540: PPUSH
57541: CALL_OW 297
57545: ST_TO_ADDR
// if tmpDist < dist then
57546: LD_VAR 0 6
57550: PUSH
57551: LD_VAR 0 5
57555: LESS
57556: IFFALSE 57578
// begin result := i ;
57558: LD_ADDR_VAR 0 3
57562: PUSH
57563: LD_VAR 0 4
57567: ST_TO_ADDR
// dist := tmpDist ;
57568: LD_ADDR_VAR 0 5
57572: PUSH
57573: LD_VAR 0 6
57577: ST_TO_ADDR
// end ; end ;
57578: GO 57510
57580: POP
57581: POP
// end ;
57582: LD_VAR 0 3
57586: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
57587: LD_INT 0
57589: PPUSH
// uc_side := side ;
57590: LD_ADDR_OWVAR 20
57594: PUSH
57595: LD_VAR 0 1
57599: ST_TO_ADDR
// uc_nation := 3 ;
57600: LD_ADDR_OWVAR 21
57604: PUSH
57605: LD_INT 3
57607: ST_TO_ADDR
// vc_chassis := 25 ;
57608: LD_ADDR_OWVAR 37
57612: PUSH
57613: LD_INT 25
57615: ST_TO_ADDR
// vc_engine := engine_siberite ;
57616: LD_ADDR_OWVAR 39
57620: PUSH
57621: LD_INT 3
57623: ST_TO_ADDR
// vc_control := control_computer ;
57624: LD_ADDR_OWVAR 38
57628: PUSH
57629: LD_INT 3
57631: ST_TO_ADDR
// vc_weapon := 59 ;
57632: LD_ADDR_OWVAR 40
57636: PUSH
57637: LD_INT 59
57639: ST_TO_ADDR
// result := CreateVehicle ;
57640: LD_ADDR_VAR 0 5
57644: PUSH
57645: CALL_OW 45
57649: ST_TO_ADDR
// SetDir ( result , d ) ;
57650: LD_VAR 0 5
57654: PPUSH
57655: LD_VAR 0 4
57659: PPUSH
57660: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
57664: LD_VAR 0 5
57668: PPUSH
57669: LD_VAR 0 2
57673: PPUSH
57674: LD_VAR 0 3
57678: PPUSH
57679: LD_INT 0
57681: PPUSH
57682: CALL_OW 48
// end ;
57686: LD_VAR 0 5
57690: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
57691: LD_INT 0
57693: PPUSH
57694: PPUSH
57695: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
57696: LD_ADDR_VAR 0 2
57700: PUSH
57701: LD_INT 0
57703: PUSH
57704: LD_INT 0
57706: PUSH
57707: LD_INT 0
57709: PUSH
57710: LD_INT 0
57712: PUSH
57713: EMPTY
57714: LIST
57715: LIST
57716: LIST
57717: LIST
57718: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
57719: LD_VAR 0 1
57723: NOT
57724: PUSH
57725: LD_VAR 0 1
57729: PPUSH
57730: CALL_OW 264
57734: PUSH
57735: LD_INT 12
57737: PUSH
57738: LD_INT 51
57740: PUSH
57741: LD_INT 32
57743: PUSH
57744: LD_INT 89
57746: PUSH
57747: EMPTY
57748: LIST
57749: LIST
57750: LIST
57751: LIST
57752: IN
57753: NOT
57754: OR
57755: IFFALSE 57759
// exit ;
57757: GO 57857
// for i := 1 to 3 do
57759: LD_ADDR_VAR 0 3
57763: PUSH
57764: DOUBLE
57765: LD_INT 1
57767: DEC
57768: ST_TO_ADDR
57769: LD_INT 3
57771: PUSH
57772: FOR_TO
57773: IFFALSE 57855
// begin tmp := GetCargo ( cargo , i ) ;
57775: LD_ADDR_VAR 0 4
57779: PUSH
57780: LD_VAR 0 1
57784: PPUSH
57785: LD_VAR 0 3
57789: PPUSH
57790: CALL_OW 289
57794: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
57795: LD_ADDR_VAR 0 2
57799: PUSH
57800: LD_VAR 0 2
57804: PPUSH
57805: LD_VAR 0 3
57809: PPUSH
57810: LD_VAR 0 4
57814: PPUSH
57815: CALL_OW 1
57819: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
57820: LD_ADDR_VAR 0 2
57824: PUSH
57825: LD_VAR 0 2
57829: PPUSH
57830: LD_INT 4
57832: PPUSH
57833: LD_VAR 0 2
57837: PUSH
57838: LD_INT 4
57840: ARRAY
57841: PUSH
57842: LD_VAR 0 4
57846: PLUS
57847: PPUSH
57848: CALL_OW 1
57852: ST_TO_ADDR
// end ;
57853: GO 57772
57855: POP
57856: POP
// end ;
57857: LD_VAR 0 2
57861: RET
// export function Length ( array ) ; begin
57862: LD_INT 0
57864: PPUSH
// result := array + 0 ;
57865: LD_ADDR_VAR 0 2
57869: PUSH
57870: LD_VAR 0 1
57874: PUSH
57875: LD_INT 0
57877: PLUS
57878: ST_TO_ADDR
// end ;
57879: LD_VAR 0 2
57883: RET
// export function PrepareArray ( array ) ; begin
57884: LD_INT 0
57886: PPUSH
// result := array diff 0 ;
57887: LD_ADDR_VAR 0 2
57891: PUSH
57892: LD_VAR 0 1
57896: PUSH
57897: LD_INT 0
57899: DIFF
57900: ST_TO_ADDR
// if not result [ 1 ] then
57901: LD_VAR 0 2
57905: PUSH
57906: LD_INT 1
57908: ARRAY
57909: NOT
57910: IFFALSE 57930
// result := Delete ( result , 1 ) ;
57912: LD_ADDR_VAR 0 2
57916: PUSH
57917: LD_VAR 0 2
57921: PPUSH
57922: LD_INT 1
57924: PPUSH
57925: CALL_OW 3
57929: ST_TO_ADDR
// end ;
57930: LD_VAR 0 2
57934: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
57935: LD_INT 0
57937: PPUSH
57938: PPUSH
57939: PPUSH
57940: PPUSH
// sibRocketRange := 25 ;
57941: LD_ADDR_VAR 0 6
57945: PUSH
57946: LD_INT 25
57948: ST_TO_ADDR
// result := false ;
57949: LD_ADDR_VAR 0 4
57953: PUSH
57954: LD_INT 0
57956: ST_TO_ADDR
// for i := 0 to 5 do
57957: LD_ADDR_VAR 0 5
57961: PUSH
57962: DOUBLE
57963: LD_INT 0
57965: DEC
57966: ST_TO_ADDR
57967: LD_INT 5
57969: PUSH
57970: FOR_TO
57971: IFFALSE 58038
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
57973: LD_VAR 0 1
57977: PPUSH
57978: LD_VAR 0 5
57982: PPUSH
57983: LD_VAR 0 6
57987: PPUSH
57988: CALL_OW 272
57992: PPUSH
57993: LD_VAR 0 2
57997: PPUSH
57998: LD_VAR 0 5
58002: PPUSH
58003: LD_VAR 0 6
58007: PPUSH
58008: CALL_OW 273
58012: PPUSH
58013: LD_VAR 0 3
58017: PPUSH
58018: CALL_OW 309
58022: IFFALSE 58036
// begin result := true ;
58024: LD_ADDR_VAR 0 4
58028: PUSH
58029: LD_INT 1
58031: ST_TO_ADDR
// exit ;
58032: POP
58033: POP
58034: GO 58040
// end ;
58036: GO 57970
58038: POP
58039: POP
// end ;
58040: LD_VAR 0 4
58044: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
58045: LD_INT 0
58047: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
58048: LD_VAR 0 1
58052: PPUSH
58053: LD_VAR 0 2
58057: PPUSH
58058: LD_INT 0
58060: PPUSH
58061: LD_INT 0
58063: PPUSH
58064: LD_INT 1
58066: PPUSH
58067: LD_INT 0
58069: PPUSH
58070: CALL_OW 587
// end ;
58074: LD_VAR 0 3
58078: RET
// export function CenterOnNow ( unit ) ; begin
58079: LD_INT 0
58081: PPUSH
// result := IsInUnit ( unit ) ;
58082: LD_ADDR_VAR 0 2
58086: PUSH
58087: LD_VAR 0 1
58091: PPUSH
58092: CALL_OW 310
58096: ST_TO_ADDR
// if not result then
58097: LD_VAR 0 2
58101: NOT
58102: IFFALSE 58114
// result := unit ;
58104: LD_ADDR_VAR 0 2
58108: PUSH
58109: LD_VAR 0 1
58113: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
58114: LD_VAR 0 1
58118: PPUSH
58119: CALL_OW 87
// end ;
58123: LD_VAR 0 2
58127: RET
// export function ComMoveHex ( unit , hex ) ; begin
58128: LD_INT 0
58130: PPUSH
// if not hex then
58131: LD_VAR 0 2
58135: NOT
58136: IFFALSE 58140
// exit ;
58138: GO 58193
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
58140: LD_VAR 0 2
58144: PUSH
58145: LD_INT 1
58147: ARRAY
58148: PPUSH
58149: LD_VAR 0 2
58153: PUSH
58154: LD_INT 2
58156: ARRAY
58157: PPUSH
58158: CALL_OW 428
58162: IFFALSE 58166
// exit ;
58164: GO 58193
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
58166: LD_VAR 0 1
58170: PPUSH
58171: LD_VAR 0 2
58175: PUSH
58176: LD_INT 1
58178: ARRAY
58179: PPUSH
58180: LD_VAR 0 2
58184: PUSH
58185: LD_INT 2
58187: ARRAY
58188: PPUSH
58189: CALL_OW 111
// end ;
58193: LD_VAR 0 3
58197: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
58198: LD_INT 0
58200: PPUSH
58201: PPUSH
58202: PPUSH
// if not unit or not enemy then
58203: LD_VAR 0 1
58207: NOT
58208: PUSH
58209: LD_VAR 0 2
58213: NOT
58214: OR
58215: IFFALSE 58219
// exit ;
58217: GO 58343
// x := GetX ( enemy ) ;
58219: LD_ADDR_VAR 0 4
58223: PUSH
58224: LD_VAR 0 2
58228: PPUSH
58229: CALL_OW 250
58233: ST_TO_ADDR
// y := GetY ( enemy ) ;
58234: LD_ADDR_VAR 0 5
58238: PUSH
58239: LD_VAR 0 2
58243: PPUSH
58244: CALL_OW 251
58248: ST_TO_ADDR
// if ValidHex ( x , y ) then
58249: LD_VAR 0 4
58253: PPUSH
58254: LD_VAR 0 5
58258: PPUSH
58259: CALL_OW 488
58263: IFFALSE 58343
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
58265: LD_VAR 0 2
58269: PPUSH
58270: CALL_OW 247
58274: PUSH
58275: LD_INT 3
58277: PUSH
58278: LD_INT 2
58280: PUSH
58281: EMPTY
58282: LIST
58283: LIST
58284: IN
58285: PUSH
58286: LD_VAR 0 1
58290: PPUSH
58291: CALL_OW 255
58295: PPUSH
58296: LD_VAR 0 2
58300: PPUSH
58301: CALL_OW 292
58305: AND
58306: IFFALSE 58324
// ComAttackUnit ( unit , enemy ) else
58308: LD_VAR 0 1
58312: PPUSH
58313: LD_VAR 0 2
58317: PPUSH
58318: CALL_OW 115
58322: GO 58343
// ComAgressiveMove ( unit , x , y ) ;
58324: LD_VAR 0 1
58328: PPUSH
58329: LD_VAR 0 4
58333: PPUSH
58334: LD_VAR 0 5
58338: PPUSH
58339: CALL_OW 114
// end ;
58343: LD_VAR 0 3
58347: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
58348: LD_INT 0
58350: PPUSH
58351: PPUSH
58352: PPUSH
// list := AreaToList ( area , 0 ) ;
58353: LD_ADDR_VAR 0 5
58357: PUSH
58358: LD_VAR 0 1
58362: PPUSH
58363: LD_INT 0
58365: PPUSH
58366: CALL_OW 517
58370: ST_TO_ADDR
// if not list then
58371: LD_VAR 0 5
58375: NOT
58376: IFFALSE 58380
// exit ;
58378: GO 58510
// if all then
58380: LD_VAR 0 2
58384: IFFALSE 58472
// begin for i := 1 to list [ 1 ] do
58386: LD_ADDR_VAR 0 4
58390: PUSH
58391: DOUBLE
58392: LD_INT 1
58394: DEC
58395: ST_TO_ADDR
58396: LD_VAR 0 5
58400: PUSH
58401: LD_INT 1
58403: ARRAY
58404: PUSH
58405: FOR_TO
58406: IFFALSE 58468
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
58408: LD_ADDR_VAR 0 3
58412: PUSH
58413: LD_VAR 0 3
58417: PPUSH
58418: LD_VAR 0 3
58422: PUSH
58423: LD_INT 1
58425: PLUS
58426: PPUSH
58427: LD_VAR 0 5
58431: PUSH
58432: LD_INT 1
58434: ARRAY
58435: PUSH
58436: LD_VAR 0 4
58440: ARRAY
58441: PUSH
58442: LD_VAR 0 5
58446: PUSH
58447: LD_INT 2
58449: ARRAY
58450: PUSH
58451: LD_VAR 0 4
58455: ARRAY
58456: PUSH
58457: EMPTY
58458: LIST
58459: LIST
58460: PPUSH
58461: CALL_OW 1
58465: ST_TO_ADDR
58466: GO 58405
58468: POP
58469: POP
// exit ;
58470: GO 58510
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
58472: LD_ADDR_VAR 0 3
58476: PUSH
58477: LD_VAR 0 5
58481: PUSH
58482: LD_INT 1
58484: ARRAY
58485: PUSH
58486: LD_INT 1
58488: ARRAY
58489: PUSH
58490: LD_VAR 0 5
58494: PUSH
58495: LD_INT 2
58497: ARRAY
58498: PUSH
58499: LD_INT 1
58501: ARRAY
58502: PUSH
58503: EMPTY
58504: LIST
58505: LIST
58506: PUSH
58507: EMPTY
58508: LIST
58509: ST_TO_ADDR
// end ;
58510: LD_VAR 0 3
58514: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
58515: LD_INT 0
58517: PPUSH
58518: PPUSH
// list := AreaToList ( area , 0 ) ;
58519: LD_ADDR_VAR 0 4
58523: PUSH
58524: LD_VAR 0 1
58528: PPUSH
58529: LD_INT 0
58531: PPUSH
58532: CALL_OW 517
58536: ST_TO_ADDR
// if not list then
58537: LD_VAR 0 4
58541: NOT
58542: IFFALSE 58546
// exit ;
58544: GO 58587
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
58546: LD_ADDR_VAR 0 3
58550: PUSH
58551: LD_VAR 0 4
58555: PUSH
58556: LD_INT 1
58558: ARRAY
58559: PUSH
58560: LD_INT 1
58562: ARRAY
58563: PUSH
58564: LD_VAR 0 4
58568: PUSH
58569: LD_INT 2
58571: ARRAY
58572: PUSH
58573: LD_INT 1
58575: ARRAY
58576: PUSH
58577: LD_VAR 0 2
58581: PUSH
58582: EMPTY
58583: LIST
58584: LIST
58585: LIST
58586: ST_TO_ADDR
// end ;
58587: LD_VAR 0 3
58591: RET
// export function First ( array ) ; begin
58592: LD_INT 0
58594: PPUSH
// if not array then
58595: LD_VAR 0 1
58599: NOT
58600: IFFALSE 58604
// exit ;
58602: GO 58618
// result := array [ 1 ] ;
58604: LD_ADDR_VAR 0 2
58608: PUSH
58609: LD_VAR 0 1
58613: PUSH
58614: LD_INT 1
58616: ARRAY
58617: ST_TO_ADDR
// end ;
58618: LD_VAR 0 2
58622: RET
// export function Last ( array ) ; begin
58623: LD_INT 0
58625: PPUSH
// if not array then
58626: LD_VAR 0 1
58630: NOT
58631: IFFALSE 58635
// exit ;
58633: GO 58651
// result := array [ array ] ;
58635: LD_ADDR_VAR 0 2
58639: PUSH
58640: LD_VAR 0 1
58644: PUSH
58645: LD_VAR 0 1
58649: ARRAY
58650: ST_TO_ADDR
// end ;
58651: LD_VAR 0 2
58655: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
58656: LD_INT 0
58658: PPUSH
58659: PPUSH
// result := [ ] ;
58660: LD_ADDR_VAR 0 5
58664: PUSH
58665: EMPTY
58666: ST_TO_ADDR
// if not array then
58667: LD_VAR 0 1
58671: NOT
58672: IFFALSE 58676
// exit ;
58674: GO 58788
// for i := 1 to array do
58676: LD_ADDR_VAR 0 6
58680: PUSH
58681: DOUBLE
58682: LD_INT 1
58684: DEC
58685: ST_TO_ADDR
58686: LD_VAR 0 1
58690: PUSH
58691: FOR_TO
58692: IFFALSE 58786
// if array [ i ] [ index ] = value then
58694: LD_VAR 0 1
58698: PUSH
58699: LD_VAR 0 6
58703: ARRAY
58704: PUSH
58705: LD_VAR 0 2
58709: ARRAY
58710: PUSH
58711: LD_VAR 0 3
58715: EQUAL
58716: IFFALSE 58784
// begin if indexColumn then
58718: LD_VAR 0 4
58722: IFFALSE 58758
// result := Join ( result , array [ i ] [ indexColumn ] ) else
58724: LD_ADDR_VAR 0 5
58728: PUSH
58729: LD_VAR 0 5
58733: PPUSH
58734: LD_VAR 0 1
58738: PUSH
58739: LD_VAR 0 6
58743: ARRAY
58744: PUSH
58745: LD_VAR 0 4
58749: ARRAY
58750: PPUSH
58751: CALL 54126 0 2
58755: ST_TO_ADDR
58756: GO 58784
// result := Join ( result , array [ i ] ) ;
58758: LD_ADDR_VAR 0 5
58762: PUSH
58763: LD_VAR 0 5
58767: PPUSH
58768: LD_VAR 0 1
58772: PUSH
58773: LD_VAR 0 6
58777: ARRAY
58778: PPUSH
58779: CALL 54126 0 2
58783: ST_TO_ADDR
// end ;
58784: GO 58691
58786: POP
58787: POP
// end ;
58788: LD_VAR 0 5
58792: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
58793: LD_INT 0
58795: PPUSH
58796: PPUSH
58797: PPUSH
// if btype = b_depot then
58798: LD_VAR 0 2
58802: PUSH
58803: LD_INT 0
58805: EQUAL
58806: IFFALSE 58818
// begin result := true ;
58808: LD_ADDR_VAR 0 3
58812: PUSH
58813: LD_INT 1
58815: ST_TO_ADDR
// exit ;
58816: GO 58934
// end ; pom := GetBase ( depot ) ;
58818: LD_ADDR_VAR 0 4
58822: PUSH
58823: LD_VAR 0 1
58827: PPUSH
58828: CALL_OW 274
58832: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
58833: LD_ADDR_VAR 0 5
58837: PUSH
58838: LD_VAR 0 2
58842: PPUSH
58843: LD_VAR 0 1
58847: PPUSH
58848: CALL_OW 248
58852: PPUSH
58853: CALL_OW 450
58857: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
58858: LD_ADDR_VAR 0 3
58862: PUSH
58863: LD_VAR 0 4
58867: PPUSH
58868: LD_INT 1
58870: PPUSH
58871: CALL_OW 275
58875: PUSH
58876: LD_VAR 0 5
58880: PUSH
58881: LD_INT 1
58883: ARRAY
58884: GREATEREQUAL
58885: PUSH
58886: LD_VAR 0 4
58890: PPUSH
58891: LD_INT 2
58893: PPUSH
58894: CALL_OW 275
58898: PUSH
58899: LD_VAR 0 5
58903: PUSH
58904: LD_INT 2
58906: ARRAY
58907: GREATEREQUAL
58908: AND
58909: PUSH
58910: LD_VAR 0 4
58914: PPUSH
58915: LD_INT 3
58917: PPUSH
58918: CALL_OW 275
58922: PUSH
58923: LD_VAR 0 5
58927: PUSH
58928: LD_INT 3
58930: ARRAY
58931: GREATEREQUAL
58932: AND
58933: ST_TO_ADDR
// end ;
58934: LD_VAR 0 3
58938: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
58939: LD_INT 0
58941: PPUSH
// if not vehicles or not parkingPoint then
58942: LD_VAR 0 1
58946: NOT
58947: PUSH
58948: LD_VAR 0 2
58952: NOT
58953: OR
58954: IFFALSE 58958
// exit ;
58956: GO 59056
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
58958: LD_ADDR_VAR 0 1
58962: PUSH
58963: LD_VAR 0 1
58967: PPUSH
58968: LD_INT 50
58970: PUSH
58971: EMPTY
58972: LIST
58973: PUSH
58974: LD_INT 3
58976: PUSH
58977: LD_INT 92
58979: PUSH
58980: LD_VAR 0 2
58984: PUSH
58985: LD_INT 1
58987: ARRAY
58988: PUSH
58989: LD_VAR 0 2
58993: PUSH
58994: LD_INT 2
58996: ARRAY
58997: PUSH
58998: LD_INT 8
59000: PUSH
59001: EMPTY
59002: LIST
59003: LIST
59004: LIST
59005: LIST
59006: PUSH
59007: EMPTY
59008: LIST
59009: LIST
59010: PUSH
59011: EMPTY
59012: LIST
59013: LIST
59014: PPUSH
59015: CALL_OW 72
59019: ST_TO_ADDR
// if not vehicles then
59020: LD_VAR 0 1
59024: NOT
59025: IFFALSE 59029
// exit ;
59027: GO 59056
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
59029: LD_VAR 0 1
59033: PPUSH
59034: LD_VAR 0 2
59038: PUSH
59039: LD_INT 1
59041: ARRAY
59042: PPUSH
59043: LD_VAR 0 2
59047: PUSH
59048: LD_INT 2
59050: ARRAY
59051: PPUSH
59052: CALL_OW 111
// end ; end_of_file
59056: LD_VAR 0 3
59060: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
59061: LD_INT 0
59063: PPUSH
59064: PPUSH
// skirmish := false ;
59065: LD_ADDR_EXP 59
59069: PUSH
59070: LD_INT 0
59072: ST_TO_ADDR
// debug_mc := false ;
59073: LD_ADDR_EXP 60
59077: PUSH
59078: LD_INT 0
59080: ST_TO_ADDR
// mc_bases := [ ] ;
59081: LD_ADDR_EXP 61
59085: PUSH
59086: EMPTY
59087: ST_TO_ADDR
// mc_sides := [ ] ;
59088: LD_ADDR_EXP 87
59092: PUSH
59093: EMPTY
59094: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
59095: LD_ADDR_EXP 62
59099: PUSH
59100: EMPTY
59101: ST_TO_ADDR
// mc_building_repairs := [ ] ;
59102: LD_ADDR_EXP 63
59106: PUSH
59107: EMPTY
59108: ST_TO_ADDR
// mc_need_heal := [ ] ;
59109: LD_ADDR_EXP 64
59113: PUSH
59114: EMPTY
59115: ST_TO_ADDR
// mc_healers := [ ] ;
59116: LD_ADDR_EXP 65
59120: PUSH
59121: EMPTY
59122: ST_TO_ADDR
// mc_build_list := [ ] ;
59123: LD_ADDR_EXP 66
59127: PUSH
59128: EMPTY
59129: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
59130: LD_ADDR_EXP 93
59134: PUSH
59135: EMPTY
59136: ST_TO_ADDR
// mc_builders := [ ] ;
59137: LD_ADDR_EXP 67
59141: PUSH
59142: EMPTY
59143: ST_TO_ADDR
// mc_construct_list := [ ] ;
59144: LD_ADDR_EXP 68
59148: PUSH
59149: EMPTY
59150: ST_TO_ADDR
// mc_turret_list := [ ] ;
59151: LD_ADDR_EXP 69
59155: PUSH
59156: EMPTY
59157: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
59158: LD_ADDR_EXP 70
59162: PUSH
59163: EMPTY
59164: ST_TO_ADDR
// mc_miners := [ ] ;
59165: LD_ADDR_EXP 75
59169: PUSH
59170: EMPTY
59171: ST_TO_ADDR
// mc_mines := [ ] ;
59172: LD_ADDR_EXP 74
59176: PUSH
59177: EMPTY
59178: ST_TO_ADDR
// mc_minefields := [ ] ;
59179: LD_ADDR_EXP 76
59183: PUSH
59184: EMPTY
59185: ST_TO_ADDR
// mc_crates := [ ] ;
59186: LD_ADDR_EXP 77
59190: PUSH
59191: EMPTY
59192: ST_TO_ADDR
// mc_crates_collector := [ ] ;
59193: LD_ADDR_EXP 78
59197: PUSH
59198: EMPTY
59199: ST_TO_ADDR
// mc_crates_area := [ ] ;
59200: LD_ADDR_EXP 79
59204: PUSH
59205: EMPTY
59206: ST_TO_ADDR
// mc_vehicles := [ ] ;
59207: LD_ADDR_EXP 80
59211: PUSH
59212: EMPTY
59213: ST_TO_ADDR
// mc_attack := [ ] ;
59214: LD_ADDR_EXP 81
59218: PUSH
59219: EMPTY
59220: ST_TO_ADDR
// mc_produce := [ ] ;
59221: LD_ADDR_EXP 82
59225: PUSH
59226: EMPTY
59227: ST_TO_ADDR
// mc_defender := [ ] ;
59228: LD_ADDR_EXP 83
59232: PUSH
59233: EMPTY
59234: ST_TO_ADDR
// mc_parking := [ ] ;
59235: LD_ADDR_EXP 85
59239: PUSH
59240: EMPTY
59241: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
59242: LD_ADDR_EXP 71
59246: PUSH
59247: EMPTY
59248: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
59249: LD_ADDR_EXP 73
59253: PUSH
59254: EMPTY
59255: ST_TO_ADDR
// mc_scan := [ ] ;
59256: LD_ADDR_EXP 84
59260: PUSH
59261: EMPTY
59262: ST_TO_ADDR
// mc_scan_area := [ ] ;
59263: LD_ADDR_EXP 86
59267: PUSH
59268: EMPTY
59269: ST_TO_ADDR
// mc_tech := [ ] ;
59270: LD_ADDR_EXP 88
59274: PUSH
59275: EMPTY
59276: ST_TO_ADDR
// mc_class := [ ] ;
59277: LD_ADDR_EXP 102
59281: PUSH
59282: EMPTY
59283: ST_TO_ADDR
// mc_class_case_use := [ ] ;
59284: LD_ADDR_EXP 103
59288: PUSH
59289: EMPTY
59290: ST_TO_ADDR
// mc_is_defending := [ ] ;
59291: LD_ADDR_EXP 104
59295: PUSH
59296: EMPTY
59297: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
59298: LD_ADDR_EXP 95
59302: PUSH
59303: EMPTY
59304: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
59305: LD_ADDR_EXP 105
59309: PUSH
59310: LD_INT 0
59312: ST_TO_ADDR
// end ;
59313: LD_VAR 0 1
59317: RET
// export function MC_Kill ( base ) ; begin
59318: LD_INT 0
59320: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
59321: LD_ADDR_EXP 61
59325: PUSH
59326: LD_EXP 61
59330: PPUSH
59331: LD_VAR 0 1
59335: PPUSH
59336: EMPTY
59337: PPUSH
59338: CALL_OW 1
59342: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
59343: LD_ADDR_EXP 62
59347: PUSH
59348: LD_EXP 62
59352: PPUSH
59353: LD_VAR 0 1
59357: PPUSH
59358: EMPTY
59359: PPUSH
59360: CALL_OW 1
59364: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
59365: LD_ADDR_EXP 63
59369: PUSH
59370: LD_EXP 63
59374: PPUSH
59375: LD_VAR 0 1
59379: PPUSH
59380: EMPTY
59381: PPUSH
59382: CALL_OW 1
59386: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
59387: LD_ADDR_EXP 64
59391: PUSH
59392: LD_EXP 64
59396: PPUSH
59397: LD_VAR 0 1
59401: PPUSH
59402: EMPTY
59403: PPUSH
59404: CALL_OW 1
59408: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
59409: LD_ADDR_EXP 65
59413: PUSH
59414: LD_EXP 65
59418: PPUSH
59419: LD_VAR 0 1
59423: PPUSH
59424: EMPTY
59425: PPUSH
59426: CALL_OW 1
59430: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
59431: LD_ADDR_EXP 66
59435: PUSH
59436: LD_EXP 66
59440: PPUSH
59441: LD_VAR 0 1
59445: PPUSH
59446: EMPTY
59447: PPUSH
59448: CALL_OW 1
59452: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
59453: LD_ADDR_EXP 67
59457: PUSH
59458: LD_EXP 67
59462: PPUSH
59463: LD_VAR 0 1
59467: PPUSH
59468: EMPTY
59469: PPUSH
59470: CALL_OW 1
59474: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
59475: LD_ADDR_EXP 68
59479: PUSH
59480: LD_EXP 68
59484: PPUSH
59485: LD_VAR 0 1
59489: PPUSH
59490: EMPTY
59491: PPUSH
59492: CALL_OW 1
59496: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
59497: LD_ADDR_EXP 69
59501: PUSH
59502: LD_EXP 69
59506: PPUSH
59507: LD_VAR 0 1
59511: PPUSH
59512: EMPTY
59513: PPUSH
59514: CALL_OW 1
59518: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
59519: LD_ADDR_EXP 70
59523: PUSH
59524: LD_EXP 70
59528: PPUSH
59529: LD_VAR 0 1
59533: PPUSH
59534: EMPTY
59535: PPUSH
59536: CALL_OW 1
59540: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
59541: LD_ADDR_EXP 71
59545: PUSH
59546: LD_EXP 71
59550: PPUSH
59551: LD_VAR 0 1
59555: PPUSH
59556: EMPTY
59557: PPUSH
59558: CALL_OW 1
59562: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
59563: LD_ADDR_EXP 72
59567: PUSH
59568: LD_EXP 72
59572: PPUSH
59573: LD_VAR 0 1
59577: PPUSH
59578: LD_INT 0
59580: PPUSH
59581: CALL_OW 1
59585: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
59586: LD_ADDR_EXP 73
59590: PUSH
59591: LD_EXP 73
59595: PPUSH
59596: LD_VAR 0 1
59600: PPUSH
59601: EMPTY
59602: PPUSH
59603: CALL_OW 1
59607: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
59608: LD_ADDR_EXP 74
59612: PUSH
59613: LD_EXP 74
59617: PPUSH
59618: LD_VAR 0 1
59622: PPUSH
59623: EMPTY
59624: PPUSH
59625: CALL_OW 1
59629: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
59630: LD_ADDR_EXP 75
59634: PUSH
59635: LD_EXP 75
59639: PPUSH
59640: LD_VAR 0 1
59644: PPUSH
59645: EMPTY
59646: PPUSH
59647: CALL_OW 1
59651: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
59652: LD_ADDR_EXP 76
59656: PUSH
59657: LD_EXP 76
59661: PPUSH
59662: LD_VAR 0 1
59666: PPUSH
59667: EMPTY
59668: PPUSH
59669: CALL_OW 1
59673: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
59674: LD_ADDR_EXP 77
59678: PUSH
59679: LD_EXP 77
59683: PPUSH
59684: LD_VAR 0 1
59688: PPUSH
59689: EMPTY
59690: PPUSH
59691: CALL_OW 1
59695: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
59696: LD_ADDR_EXP 78
59700: PUSH
59701: LD_EXP 78
59705: PPUSH
59706: LD_VAR 0 1
59710: PPUSH
59711: EMPTY
59712: PPUSH
59713: CALL_OW 1
59717: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
59718: LD_ADDR_EXP 79
59722: PUSH
59723: LD_EXP 79
59727: PPUSH
59728: LD_VAR 0 1
59732: PPUSH
59733: EMPTY
59734: PPUSH
59735: CALL_OW 1
59739: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
59740: LD_ADDR_EXP 80
59744: PUSH
59745: LD_EXP 80
59749: PPUSH
59750: LD_VAR 0 1
59754: PPUSH
59755: EMPTY
59756: PPUSH
59757: CALL_OW 1
59761: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
59762: LD_ADDR_EXP 81
59766: PUSH
59767: LD_EXP 81
59771: PPUSH
59772: LD_VAR 0 1
59776: PPUSH
59777: EMPTY
59778: PPUSH
59779: CALL_OW 1
59783: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
59784: LD_ADDR_EXP 82
59788: PUSH
59789: LD_EXP 82
59793: PPUSH
59794: LD_VAR 0 1
59798: PPUSH
59799: EMPTY
59800: PPUSH
59801: CALL_OW 1
59805: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
59806: LD_ADDR_EXP 83
59810: PUSH
59811: LD_EXP 83
59815: PPUSH
59816: LD_VAR 0 1
59820: PPUSH
59821: EMPTY
59822: PPUSH
59823: CALL_OW 1
59827: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
59828: LD_ADDR_EXP 84
59832: PUSH
59833: LD_EXP 84
59837: PPUSH
59838: LD_VAR 0 1
59842: PPUSH
59843: EMPTY
59844: PPUSH
59845: CALL_OW 1
59849: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
59850: LD_ADDR_EXP 85
59854: PUSH
59855: LD_EXP 85
59859: PPUSH
59860: LD_VAR 0 1
59864: PPUSH
59865: EMPTY
59866: PPUSH
59867: CALL_OW 1
59871: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
59872: LD_ADDR_EXP 86
59876: PUSH
59877: LD_EXP 86
59881: PPUSH
59882: LD_VAR 0 1
59886: PPUSH
59887: EMPTY
59888: PPUSH
59889: CALL_OW 1
59893: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
59894: LD_ADDR_EXP 88
59898: PUSH
59899: LD_EXP 88
59903: PPUSH
59904: LD_VAR 0 1
59908: PPUSH
59909: EMPTY
59910: PPUSH
59911: CALL_OW 1
59915: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
59916: LD_ADDR_EXP 90
59920: PUSH
59921: LD_EXP 90
59925: PPUSH
59926: LD_VAR 0 1
59930: PPUSH
59931: EMPTY
59932: PPUSH
59933: CALL_OW 1
59937: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
59938: LD_ADDR_EXP 91
59942: PUSH
59943: LD_EXP 91
59947: PPUSH
59948: LD_VAR 0 1
59952: PPUSH
59953: EMPTY
59954: PPUSH
59955: CALL_OW 1
59959: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
59960: LD_ADDR_EXP 92
59964: PUSH
59965: LD_EXP 92
59969: PPUSH
59970: LD_VAR 0 1
59974: PPUSH
59975: EMPTY
59976: PPUSH
59977: CALL_OW 1
59981: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
59982: LD_ADDR_EXP 93
59986: PUSH
59987: LD_EXP 93
59991: PPUSH
59992: LD_VAR 0 1
59996: PPUSH
59997: EMPTY
59998: PPUSH
59999: CALL_OW 1
60003: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
60004: LD_ADDR_EXP 94
60008: PUSH
60009: LD_EXP 94
60013: PPUSH
60014: LD_VAR 0 1
60018: PPUSH
60019: EMPTY
60020: PPUSH
60021: CALL_OW 1
60025: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
60026: LD_ADDR_EXP 95
60030: PUSH
60031: LD_EXP 95
60035: PPUSH
60036: LD_VAR 0 1
60040: PPUSH
60041: EMPTY
60042: PPUSH
60043: CALL_OW 1
60047: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
60048: LD_ADDR_EXP 96
60052: PUSH
60053: LD_EXP 96
60057: PPUSH
60058: LD_VAR 0 1
60062: PPUSH
60063: EMPTY
60064: PPUSH
60065: CALL_OW 1
60069: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
60070: LD_ADDR_EXP 97
60074: PUSH
60075: LD_EXP 97
60079: PPUSH
60080: LD_VAR 0 1
60084: PPUSH
60085: EMPTY
60086: PPUSH
60087: CALL_OW 1
60091: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
60092: LD_ADDR_EXP 98
60096: PUSH
60097: LD_EXP 98
60101: PPUSH
60102: LD_VAR 0 1
60106: PPUSH
60107: EMPTY
60108: PPUSH
60109: CALL_OW 1
60113: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
60114: LD_ADDR_EXP 99
60118: PUSH
60119: LD_EXP 99
60123: PPUSH
60124: LD_VAR 0 1
60128: PPUSH
60129: EMPTY
60130: PPUSH
60131: CALL_OW 1
60135: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
60136: LD_ADDR_EXP 100
60140: PUSH
60141: LD_EXP 100
60145: PPUSH
60146: LD_VAR 0 1
60150: PPUSH
60151: EMPTY
60152: PPUSH
60153: CALL_OW 1
60157: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
60158: LD_ADDR_EXP 101
60162: PUSH
60163: LD_EXP 101
60167: PPUSH
60168: LD_VAR 0 1
60172: PPUSH
60173: EMPTY
60174: PPUSH
60175: CALL_OW 1
60179: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
60180: LD_ADDR_EXP 102
60184: PUSH
60185: LD_EXP 102
60189: PPUSH
60190: LD_VAR 0 1
60194: PPUSH
60195: EMPTY
60196: PPUSH
60197: CALL_OW 1
60201: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
60202: LD_ADDR_EXP 103
60206: PUSH
60207: LD_EXP 103
60211: PPUSH
60212: LD_VAR 0 1
60216: PPUSH
60217: LD_INT 0
60219: PPUSH
60220: CALL_OW 1
60224: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
60225: LD_ADDR_EXP 104
60229: PUSH
60230: LD_EXP 104
60234: PPUSH
60235: LD_VAR 0 1
60239: PPUSH
60240: LD_INT 0
60242: PPUSH
60243: CALL_OW 1
60247: ST_TO_ADDR
// end ;
60248: LD_VAR 0 2
60252: RET
// export function MC_Add ( side , units ) ; var base ; begin
60253: LD_INT 0
60255: PPUSH
60256: PPUSH
// base := mc_bases + 1 ;
60257: LD_ADDR_VAR 0 4
60261: PUSH
60262: LD_EXP 61
60266: PUSH
60267: LD_INT 1
60269: PLUS
60270: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
60271: LD_ADDR_EXP 87
60275: PUSH
60276: LD_EXP 87
60280: PPUSH
60281: LD_VAR 0 4
60285: PPUSH
60286: LD_VAR 0 1
60290: PPUSH
60291: CALL_OW 1
60295: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
60296: LD_ADDR_EXP 61
60300: PUSH
60301: LD_EXP 61
60305: PPUSH
60306: LD_VAR 0 4
60310: PPUSH
60311: LD_VAR 0 2
60315: PPUSH
60316: CALL_OW 1
60320: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
60321: LD_ADDR_EXP 62
60325: PUSH
60326: LD_EXP 62
60330: PPUSH
60331: LD_VAR 0 4
60335: PPUSH
60336: EMPTY
60337: PPUSH
60338: CALL_OW 1
60342: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
60343: LD_ADDR_EXP 63
60347: PUSH
60348: LD_EXP 63
60352: PPUSH
60353: LD_VAR 0 4
60357: PPUSH
60358: EMPTY
60359: PPUSH
60360: CALL_OW 1
60364: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
60365: LD_ADDR_EXP 64
60369: PUSH
60370: LD_EXP 64
60374: PPUSH
60375: LD_VAR 0 4
60379: PPUSH
60380: EMPTY
60381: PPUSH
60382: CALL_OW 1
60386: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
60387: LD_ADDR_EXP 65
60391: PUSH
60392: LD_EXP 65
60396: PPUSH
60397: LD_VAR 0 4
60401: PPUSH
60402: EMPTY
60403: PPUSH
60404: CALL_OW 1
60408: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
60409: LD_ADDR_EXP 66
60413: PUSH
60414: LD_EXP 66
60418: PPUSH
60419: LD_VAR 0 4
60423: PPUSH
60424: EMPTY
60425: PPUSH
60426: CALL_OW 1
60430: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
60431: LD_ADDR_EXP 67
60435: PUSH
60436: LD_EXP 67
60440: PPUSH
60441: LD_VAR 0 4
60445: PPUSH
60446: EMPTY
60447: PPUSH
60448: CALL_OW 1
60452: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
60453: LD_ADDR_EXP 68
60457: PUSH
60458: LD_EXP 68
60462: PPUSH
60463: LD_VAR 0 4
60467: PPUSH
60468: EMPTY
60469: PPUSH
60470: CALL_OW 1
60474: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
60475: LD_ADDR_EXP 69
60479: PUSH
60480: LD_EXP 69
60484: PPUSH
60485: LD_VAR 0 4
60489: PPUSH
60490: EMPTY
60491: PPUSH
60492: CALL_OW 1
60496: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
60497: LD_ADDR_EXP 70
60501: PUSH
60502: LD_EXP 70
60506: PPUSH
60507: LD_VAR 0 4
60511: PPUSH
60512: EMPTY
60513: PPUSH
60514: CALL_OW 1
60518: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
60519: LD_ADDR_EXP 71
60523: PUSH
60524: LD_EXP 71
60528: PPUSH
60529: LD_VAR 0 4
60533: PPUSH
60534: EMPTY
60535: PPUSH
60536: CALL_OW 1
60540: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
60541: LD_ADDR_EXP 72
60545: PUSH
60546: LD_EXP 72
60550: PPUSH
60551: LD_VAR 0 4
60555: PPUSH
60556: LD_INT 0
60558: PPUSH
60559: CALL_OW 1
60563: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
60564: LD_ADDR_EXP 73
60568: PUSH
60569: LD_EXP 73
60573: PPUSH
60574: LD_VAR 0 4
60578: PPUSH
60579: EMPTY
60580: PPUSH
60581: CALL_OW 1
60585: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
60586: LD_ADDR_EXP 74
60590: PUSH
60591: LD_EXP 74
60595: PPUSH
60596: LD_VAR 0 4
60600: PPUSH
60601: EMPTY
60602: PPUSH
60603: CALL_OW 1
60607: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
60608: LD_ADDR_EXP 75
60612: PUSH
60613: LD_EXP 75
60617: PPUSH
60618: LD_VAR 0 4
60622: PPUSH
60623: EMPTY
60624: PPUSH
60625: CALL_OW 1
60629: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
60630: LD_ADDR_EXP 76
60634: PUSH
60635: LD_EXP 76
60639: PPUSH
60640: LD_VAR 0 4
60644: PPUSH
60645: EMPTY
60646: PPUSH
60647: CALL_OW 1
60651: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
60652: LD_ADDR_EXP 77
60656: PUSH
60657: LD_EXP 77
60661: PPUSH
60662: LD_VAR 0 4
60666: PPUSH
60667: EMPTY
60668: PPUSH
60669: CALL_OW 1
60673: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
60674: LD_ADDR_EXP 78
60678: PUSH
60679: LD_EXP 78
60683: PPUSH
60684: LD_VAR 0 4
60688: PPUSH
60689: EMPTY
60690: PPUSH
60691: CALL_OW 1
60695: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
60696: LD_ADDR_EXP 79
60700: PUSH
60701: LD_EXP 79
60705: PPUSH
60706: LD_VAR 0 4
60710: PPUSH
60711: EMPTY
60712: PPUSH
60713: CALL_OW 1
60717: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
60718: LD_ADDR_EXP 80
60722: PUSH
60723: LD_EXP 80
60727: PPUSH
60728: LD_VAR 0 4
60732: PPUSH
60733: EMPTY
60734: PPUSH
60735: CALL_OW 1
60739: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
60740: LD_ADDR_EXP 81
60744: PUSH
60745: LD_EXP 81
60749: PPUSH
60750: LD_VAR 0 4
60754: PPUSH
60755: EMPTY
60756: PPUSH
60757: CALL_OW 1
60761: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
60762: LD_ADDR_EXP 82
60766: PUSH
60767: LD_EXP 82
60771: PPUSH
60772: LD_VAR 0 4
60776: PPUSH
60777: EMPTY
60778: PPUSH
60779: CALL_OW 1
60783: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
60784: LD_ADDR_EXP 83
60788: PUSH
60789: LD_EXP 83
60793: PPUSH
60794: LD_VAR 0 4
60798: PPUSH
60799: EMPTY
60800: PPUSH
60801: CALL_OW 1
60805: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
60806: LD_ADDR_EXP 84
60810: PUSH
60811: LD_EXP 84
60815: PPUSH
60816: LD_VAR 0 4
60820: PPUSH
60821: EMPTY
60822: PPUSH
60823: CALL_OW 1
60827: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
60828: LD_ADDR_EXP 85
60832: PUSH
60833: LD_EXP 85
60837: PPUSH
60838: LD_VAR 0 4
60842: PPUSH
60843: EMPTY
60844: PPUSH
60845: CALL_OW 1
60849: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
60850: LD_ADDR_EXP 86
60854: PUSH
60855: LD_EXP 86
60859: PPUSH
60860: LD_VAR 0 4
60864: PPUSH
60865: EMPTY
60866: PPUSH
60867: CALL_OW 1
60871: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
60872: LD_ADDR_EXP 88
60876: PUSH
60877: LD_EXP 88
60881: PPUSH
60882: LD_VAR 0 4
60886: PPUSH
60887: EMPTY
60888: PPUSH
60889: CALL_OW 1
60893: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
60894: LD_ADDR_EXP 90
60898: PUSH
60899: LD_EXP 90
60903: PPUSH
60904: LD_VAR 0 4
60908: PPUSH
60909: EMPTY
60910: PPUSH
60911: CALL_OW 1
60915: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
60916: LD_ADDR_EXP 91
60920: PUSH
60921: LD_EXP 91
60925: PPUSH
60926: LD_VAR 0 4
60930: PPUSH
60931: EMPTY
60932: PPUSH
60933: CALL_OW 1
60937: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
60938: LD_ADDR_EXP 92
60942: PUSH
60943: LD_EXP 92
60947: PPUSH
60948: LD_VAR 0 4
60952: PPUSH
60953: EMPTY
60954: PPUSH
60955: CALL_OW 1
60959: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
60960: LD_ADDR_EXP 93
60964: PUSH
60965: LD_EXP 93
60969: PPUSH
60970: LD_VAR 0 4
60974: PPUSH
60975: EMPTY
60976: PPUSH
60977: CALL_OW 1
60981: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
60982: LD_ADDR_EXP 94
60986: PUSH
60987: LD_EXP 94
60991: PPUSH
60992: LD_VAR 0 4
60996: PPUSH
60997: EMPTY
60998: PPUSH
60999: CALL_OW 1
61003: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
61004: LD_ADDR_EXP 95
61008: PUSH
61009: LD_EXP 95
61013: PPUSH
61014: LD_VAR 0 4
61018: PPUSH
61019: EMPTY
61020: PPUSH
61021: CALL_OW 1
61025: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
61026: LD_ADDR_EXP 96
61030: PUSH
61031: LD_EXP 96
61035: PPUSH
61036: LD_VAR 0 4
61040: PPUSH
61041: EMPTY
61042: PPUSH
61043: CALL_OW 1
61047: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
61048: LD_ADDR_EXP 97
61052: PUSH
61053: LD_EXP 97
61057: PPUSH
61058: LD_VAR 0 4
61062: PPUSH
61063: EMPTY
61064: PPUSH
61065: CALL_OW 1
61069: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
61070: LD_ADDR_EXP 98
61074: PUSH
61075: LD_EXP 98
61079: PPUSH
61080: LD_VAR 0 4
61084: PPUSH
61085: EMPTY
61086: PPUSH
61087: CALL_OW 1
61091: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
61092: LD_ADDR_EXP 99
61096: PUSH
61097: LD_EXP 99
61101: PPUSH
61102: LD_VAR 0 4
61106: PPUSH
61107: EMPTY
61108: PPUSH
61109: CALL_OW 1
61113: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
61114: LD_ADDR_EXP 100
61118: PUSH
61119: LD_EXP 100
61123: PPUSH
61124: LD_VAR 0 4
61128: PPUSH
61129: EMPTY
61130: PPUSH
61131: CALL_OW 1
61135: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
61136: LD_ADDR_EXP 101
61140: PUSH
61141: LD_EXP 101
61145: PPUSH
61146: LD_VAR 0 4
61150: PPUSH
61151: EMPTY
61152: PPUSH
61153: CALL_OW 1
61157: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
61158: LD_ADDR_EXP 102
61162: PUSH
61163: LD_EXP 102
61167: PPUSH
61168: LD_VAR 0 4
61172: PPUSH
61173: EMPTY
61174: PPUSH
61175: CALL_OW 1
61179: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
61180: LD_ADDR_EXP 103
61184: PUSH
61185: LD_EXP 103
61189: PPUSH
61190: LD_VAR 0 4
61194: PPUSH
61195: LD_INT 0
61197: PPUSH
61198: CALL_OW 1
61202: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
61203: LD_ADDR_EXP 104
61207: PUSH
61208: LD_EXP 104
61212: PPUSH
61213: LD_VAR 0 4
61217: PPUSH
61218: LD_INT 0
61220: PPUSH
61221: CALL_OW 1
61225: ST_TO_ADDR
// result := base ;
61226: LD_ADDR_VAR 0 3
61230: PUSH
61231: LD_VAR 0 4
61235: ST_TO_ADDR
// end ;
61236: LD_VAR 0 3
61240: RET
// export function MC_Start ( ) ; var i ; begin
61241: LD_INT 0
61243: PPUSH
61244: PPUSH
// for i = 1 to mc_bases do
61245: LD_ADDR_VAR 0 2
61249: PUSH
61250: DOUBLE
61251: LD_INT 1
61253: DEC
61254: ST_TO_ADDR
61255: LD_EXP 61
61259: PUSH
61260: FOR_TO
61261: IFFALSE 62361
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
61263: LD_ADDR_EXP 61
61267: PUSH
61268: LD_EXP 61
61272: PPUSH
61273: LD_VAR 0 2
61277: PPUSH
61278: LD_EXP 61
61282: PUSH
61283: LD_VAR 0 2
61287: ARRAY
61288: PUSH
61289: LD_INT 0
61291: DIFF
61292: PPUSH
61293: CALL_OW 1
61297: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
61298: LD_ADDR_EXP 62
61302: PUSH
61303: LD_EXP 62
61307: PPUSH
61308: LD_VAR 0 2
61312: PPUSH
61313: EMPTY
61314: PPUSH
61315: CALL_OW 1
61319: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
61320: LD_ADDR_EXP 63
61324: PUSH
61325: LD_EXP 63
61329: PPUSH
61330: LD_VAR 0 2
61334: PPUSH
61335: EMPTY
61336: PPUSH
61337: CALL_OW 1
61341: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
61342: LD_ADDR_EXP 64
61346: PUSH
61347: LD_EXP 64
61351: PPUSH
61352: LD_VAR 0 2
61356: PPUSH
61357: EMPTY
61358: PPUSH
61359: CALL_OW 1
61363: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
61364: LD_ADDR_EXP 65
61368: PUSH
61369: LD_EXP 65
61373: PPUSH
61374: LD_VAR 0 2
61378: PPUSH
61379: EMPTY
61380: PUSH
61381: EMPTY
61382: PUSH
61383: EMPTY
61384: LIST
61385: LIST
61386: PPUSH
61387: CALL_OW 1
61391: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
61392: LD_ADDR_EXP 66
61396: PUSH
61397: LD_EXP 66
61401: PPUSH
61402: LD_VAR 0 2
61406: PPUSH
61407: EMPTY
61408: PPUSH
61409: CALL_OW 1
61413: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
61414: LD_ADDR_EXP 93
61418: PUSH
61419: LD_EXP 93
61423: PPUSH
61424: LD_VAR 0 2
61428: PPUSH
61429: EMPTY
61430: PPUSH
61431: CALL_OW 1
61435: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
61436: LD_ADDR_EXP 67
61440: PUSH
61441: LD_EXP 67
61445: PPUSH
61446: LD_VAR 0 2
61450: PPUSH
61451: EMPTY
61452: PPUSH
61453: CALL_OW 1
61457: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
61458: LD_ADDR_EXP 68
61462: PUSH
61463: LD_EXP 68
61467: PPUSH
61468: LD_VAR 0 2
61472: PPUSH
61473: EMPTY
61474: PPUSH
61475: CALL_OW 1
61479: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
61480: LD_ADDR_EXP 69
61484: PUSH
61485: LD_EXP 69
61489: PPUSH
61490: LD_VAR 0 2
61494: PPUSH
61495: LD_EXP 61
61499: PUSH
61500: LD_VAR 0 2
61504: ARRAY
61505: PPUSH
61506: LD_INT 2
61508: PUSH
61509: LD_INT 30
61511: PUSH
61512: LD_INT 32
61514: PUSH
61515: EMPTY
61516: LIST
61517: LIST
61518: PUSH
61519: LD_INT 30
61521: PUSH
61522: LD_INT 33
61524: PUSH
61525: EMPTY
61526: LIST
61527: LIST
61528: PUSH
61529: EMPTY
61530: LIST
61531: LIST
61532: LIST
61533: PPUSH
61534: CALL_OW 72
61538: PPUSH
61539: CALL_OW 1
61543: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
61544: LD_ADDR_EXP 70
61548: PUSH
61549: LD_EXP 70
61553: PPUSH
61554: LD_VAR 0 2
61558: PPUSH
61559: LD_EXP 61
61563: PUSH
61564: LD_VAR 0 2
61568: ARRAY
61569: PPUSH
61570: LD_INT 2
61572: PUSH
61573: LD_INT 30
61575: PUSH
61576: LD_INT 32
61578: PUSH
61579: EMPTY
61580: LIST
61581: LIST
61582: PUSH
61583: LD_INT 30
61585: PUSH
61586: LD_INT 31
61588: PUSH
61589: EMPTY
61590: LIST
61591: LIST
61592: PUSH
61593: EMPTY
61594: LIST
61595: LIST
61596: LIST
61597: PUSH
61598: LD_INT 58
61600: PUSH
61601: EMPTY
61602: LIST
61603: PUSH
61604: EMPTY
61605: LIST
61606: LIST
61607: PPUSH
61608: CALL_OW 72
61612: PPUSH
61613: CALL_OW 1
61617: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
61618: LD_ADDR_EXP 71
61622: PUSH
61623: LD_EXP 71
61627: PPUSH
61628: LD_VAR 0 2
61632: PPUSH
61633: EMPTY
61634: PPUSH
61635: CALL_OW 1
61639: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
61640: LD_ADDR_EXP 75
61644: PUSH
61645: LD_EXP 75
61649: PPUSH
61650: LD_VAR 0 2
61654: PPUSH
61655: EMPTY
61656: PPUSH
61657: CALL_OW 1
61661: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
61662: LD_ADDR_EXP 74
61666: PUSH
61667: LD_EXP 74
61671: PPUSH
61672: LD_VAR 0 2
61676: PPUSH
61677: EMPTY
61678: PPUSH
61679: CALL_OW 1
61683: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
61684: LD_ADDR_EXP 76
61688: PUSH
61689: LD_EXP 76
61693: PPUSH
61694: LD_VAR 0 2
61698: PPUSH
61699: EMPTY
61700: PPUSH
61701: CALL_OW 1
61705: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
61706: LD_ADDR_EXP 77
61710: PUSH
61711: LD_EXP 77
61715: PPUSH
61716: LD_VAR 0 2
61720: PPUSH
61721: EMPTY
61722: PPUSH
61723: CALL_OW 1
61727: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
61728: LD_ADDR_EXP 78
61732: PUSH
61733: LD_EXP 78
61737: PPUSH
61738: LD_VAR 0 2
61742: PPUSH
61743: EMPTY
61744: PPUSH
61745: CALL_OW 1
61749: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
61750: LD_ADDR_EXP 79
61754: PUSH
61755: LD_EXP 79
61759: PPUSH
61760: LD_VAR 0 2
61764: PPUSH
61765: EMPTY
61766: PPUSH
61767: CALL_OW 1
61771: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
61772: LD_ADDR_EXP 80
61776: PUSH
61777: LD_EXP 80
61781: PPUSH
61782: LD_VAR 0 2
61786: PPUSH
61787: EMPTY
61788: PPUSH
61789: CALL_OW 1
61793: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
61794: LD_ADDR_EXP 81
61798: PUSH
61799: LD_EXP 81
61803: PPUSH
61804: LD_VAR 0 2
61808: PPUSH
61809: EMPTY
61810: PPUSH
61811: CALL_OW 1
61815: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
61816: LD_ADDR_EXP 82
61820: PUSH
61821: LD_EXP 82
61825: PPUSH
61826: LD_VAR 0 2
61830: PPUSH
61831: EMPTY
61832: PPUSH
61833: CALL_OW 1
61837: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
61838: LD_ADDR_EXP 83
61842: PUSH
61843: LD_EXP 83
61847: PPUSH
61848: LD_VAR 0 2
61852: PPUSH
61853: EMPTY
61854: PPUSH
61855: CALL_OW 1
61859: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
61860: LD_ADDR_EXP 72
61864: PUSH
61865: LD_EXP 72
61869: PPUSH
61870: LD_VAR 0 2
61874: PPUSH
61875: LD_INT 0
61877: PPUSH
61878: CALL_OW 1
61882: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
61883: LD_ADDR_EXP 85
61887: PUSH
61888: LD_EXP 85
61892: PPUSH
61893: LD_VAR 0 2
61897: PPUSH
61898: LD_INT 0
61900: PPUSH
61901: CALL_OW 1
61905: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
61906: LD_ADDR_EXP 73
61910: PUSH
61911: LD_EXP 73
61915: PPUSH
61916: LD_VAR 0 2
61920: PPUSH
61921: EMPTY
61922: PPUSH
61923: CALL_OW 1
61927: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
61928: LD_ADDR_EXP 84
61932: PUSH
61933: LD_EXP 84
61937: PPUSH
61938: LD_VAR 0 2
61942: PPUSH
61943: LD_INT 0
61945: PPUSH
61946: CALL_OW 1
61950: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
61951: LD_ADDR_EXP 86
61955: PUSH
61956: LD_EXP 86
61960: PPUSH
61961: LD_VAR 0 2
61965: PPUSH
61966: EMPTY
61967: PPUSH
61968: CALL_OW 1
61972: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
61973: LD_ADDR_EXP 89
61977: PUSH
61978: LD_EXP 89
61982: PPUSH
61983: LD_VAR 0 2
61987: PPUSH
61988: LD_INT 0
61990: PPUSH
61991: CALL_OW 1
61995: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
61996: LD_ADDR_EXP 90
62000: PUSH
62001: LD_EXP 90
62005: PPUSH
62006: LD_VAR 0 2
62010: PPUSH
62011: EMPTY
62012: PPUSH
62013: CALL_OW 1
62017: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62018: LD_ADDR_EXP 91
62022: PUSH
62023: LD_EXP 91
62027: PPUSH
62028: LD_VAR 0 2
62032: PPUSH
62033: EMPTY
62034: PPUSH
62035: CALL_OW 1
62039: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
62040: LD_ADDR_EXP 92
62044: PUSH
62045: LD_EXP 92
62049: PPUSH
62050: LD_VAR 0 2
62054: PPUSH
62055: EMPTY
62056: PPUSH
62057: CALL_OW 1
62061: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
62062: LD_ADDR_EXP 94
62066: PUSH
62067: LD_EXP 94
62071: PPUSH
62072: LD_VAR 0 2
62076: PPUSH
62077: LD_EXP 61
62081: PUSH
62082: LD_VAR 0 2
62086: ARRAY
62087: PPUSH
62088: LD_INT 2
62090: PUSH
62091: LD_INT 30
62093: PUSH
62094: LD_INT 6
62096: PUSH
62097: EMPTY
62098: LIST
62099: LIST
62100: PUSH
62101: LD_INT 30
62103: PUSH
62104: LD_INT 7
62106: PUSH
62107: EMPTY
62108: LIST
62109: LIST
62110: PUSH
62111: LD_INT 30
62113: PUSH
62114: LD_INT 8
62116: PUSH
62117: EMPTY
62118: LIST
62119: LIST
62120: PUSH
62121: EMPTY
62122: LIST
62123: LIST
62124: LIST
62125: LIST
62126: PPUSH
62127: CALL_OW 72
62131: PPUSH
62132: CALL_OW 1
62136: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
62137: LD_ADDR_EXP 95
62141: PUSH
62142: LD_EXP 95
62146: PPUSH
62147: LD_VAR 0 2
62151: PPUSH
62152: EMPTY
62153: PPUSH
62154: CALL_OW 1
62158: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
62159: LD_ADDR_EXP 96
62163: PUSH
62164: LD_EXP 96
62168: PPUSH
62169: LD_VAR 0 2
62173: PPUSH
62174: EMPTY
62175: PPUSH
62176: CALL_OW 1
62180: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
62181: LD_ADDR_EXP 97
62185: PUSH
62186: LD_EXP 97
62190: PPUSH
62191: LD_VAR 0 2
62195: PPUSH
62196: EMPTY
62197: PPUSH
62198: CALL_OW 1
62202: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
62203: LD_ADDR_EXP 98
62207: PUSH
62208: LD_EXP 98
62212: PPUSH
62213: LD_VAR 0 2
62217: PPUSH
62218: EMPTY
62219: PPUSH
62220: CALL_OW 1
62224: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
62225: LD_ADDR_EXP 99
62229: PUSH
62230: LD_EXP 99
62234: PPUSH
62235: LD_VAR 0 2
62239: PPUSH
62240: EMPTY
62241: PPUSH
62242: CALL_OW 1
62246: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
62247: LD_ADDR_EXP 100
62251: PUSH
62252: LD_EXP 100
62256: PPUSH
62257: LD_VAR 0 2
62261: PPUSH
62262: EMPTY
62263: PPUSH
62264: CALL_OW 1
62268: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
62269: LD_ADDR_EXP 101
62273: PUSH
62274: LD_EXP 101
62278: PPUSH
62279: LD_VAR 0 2
62283: PPUSH
62284: EMPTY
62285: PPUSH
62286: CALL_OW 1
62290: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
62291: LD_ADDR_EXP 102
62295: PUSH
62296: LD_EXP 102
62300: PPUSH
62301: LD_VAR 0 2
62305: PPUSH
62306: EMPTY
62307: PPUSH
62308: CALL_OW 1
62312: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
62313: LD_ADDR_EXP 103
62317: PUSH
62318: LD_EXP 103
62322: PPUSH
62323: LD_VAR 0 2
62327: PPUSH
62328: LD_INT 0
62330: PPUSH
62331: CALL_OW 1
62335: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
62336: LD_ADDR_EXP 104
62340: PUSH
62341: LD_EXP 104
62345: PPUSH
62346: LD_VAR 0 2
62350: PPUSH
62351: LD_INT 0
62353: PPUSH
62354: CALL_OW 1
62358: ST_TO_ADDR
// end ;
62359: GO 61260
62361: POP
62362: POP
// MC_InitSides ( ) ;
62363: CALL 62649 0 0
// MC_InitResearch ( ) ;
62367: CALL 62388 0 0
// CustomInitMacro ( ) ;
62371: CALL 219 0 0
// skirmish := true ;
62375: LD_ADDR_EXP 59
62379: PUSH
62380: LD_INT 1
62382: ST_TO_ADDR
// end ;
62383: LD_VAR 0 1
62387: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
62388: LD_INT 0
62390: PPUSH
62391: PPUSH
62392: PPUSH
62393: PPUSH
62394: PPUSH
62395: PPUSH
// if not mc_bases then
62396: LD_EXP 61
62400: NOT
62401: IFFALSE 62405
// exit ;
62403: GO 62644
// for i = 1 to 8 do
62405: LD_ADDR_VAR 0 2
62409: PUSH
62410: DOUBLE
62411: LD_INT 1
62413: DEC
62414: ST_TO_ADDR
62415: LD_INT 8
62417: PUSH
62418: FOR_TO
62419: IFFALSE 62445
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
62421: LD_ADDR_EXP 88
62425: PUSH
62426: LD_EXP 88
62430: PPUSH
62431: LD_VAR 0 2
62435: PPUSH
62436: EMPTY
62437: PPUSH
62438: CALL_OW 1
62442: ST_TO_ADDR
62443: GO 62418
62445: POP
62446: POP
// tmp := [ ] ;
62447: LD_ADDR_VAR 0 5
62451: PUSH
62452: EMPTY
62453: ST_TO_ADDR
// for i = 1 to mc_sides do
62454: LD_ADDR_VAR 0 2
62458: PUSH
62459: DOUBLE
62460: LD_INT 1
62462: DEC
62463: ST_TO_ADDR
62464: LD_EXP 87
62468: PUSH
62469: FOR_TO
62470: IFFALSE 62528
// if not mc_sides [ i ] in tmp then
62472: LD_EXP 87
62476: PUSH
62477: LD_VAR 0 2
62481: ARRAY
62482: PUSH
62483: LD_VAR 0 5
62487: IN
62488: NOT
62489: IFFALSE 62526
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
62491: LD_ADDR_VAR 0 5
62495: PUSH
62496: LD_VAR 0 5
62500: PPUSH
62501: LD_VAR 0 5
62505: PUSH
62506: LD_INT 1
62508: PLUS
62509: PPUSH
62510: LD_EXP 87
62514: PUSH
62515: LD_VAR 0 2
62519: ARRAY
62520: PPUSH
62521: CALL_OW 2
62525: ST_TO_ADDR
62526: GO 62469
62528: POP
62529: POP
// if not tmp then
62530: LD_VAR 0 5
62534: NOT
62535: IFFALSE 62539
// exit ;
62537: GO 62644
// for j in tmp do
62539: LD_ADDR_VAR 0 3
62543: PUSH
62544: LD_VAR 0 5
62548: PUSH
62549: FOR_IN
62550: IFFALSE 62642
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
62552: LD_ADDR_VAR 0 6
62556: PUSH
62557: LD_INT 22
62559: PUSH
62560: LD_VAR 0 3
62564: PUSH
62565: EMPTY
62566: LIST
62567: LIST
62568: PPUSH
62569: CALL_OW 69
62573: ST_TO_ADDR
// if not un then
62574: LD_VAR 0 6
62578: NOT
62579: IFFALSE 62583
// continue ;
62581: GO 62549
// nation := GetNation ( un [ 1 ] ) ;
62583: LD_ADDR_VAR 0 4
62587: PUSH
62588: LD_VAR 0 6
62592: PUSH
62593: LD_INT 1
62595: ARRAY
62596: PPUSH
62597: CALL_OW 248
62601: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
62602: LD_ADDR_EXP 88
62606: PUSH
62607: LD_EXP 88
62611: PPUSH
62612: LD_VAR 0 3
62616: PPUSH
62617: LD_VAR 0 3
62621: PPUSH
62622: LD_VAR 0 4
62626: PPUSH
62627: LD_INT 1
62629: PPUSH
62630: CALL 16498 0 3
62634: PPUSH
62635: CALL_OW 1
62639: ST_TO_ADDR
// end ;
62640: GO 62549
62642: POP
62643: POP
// end ;
62644: LD_VAR 0 1
62648: RET
// export function MC_InitSides ( ) ; var i ; begin
62649: LD_INT 0
62651: PPUSH
62652: PPUSH
// if not mc_bases then
62653: LD_EXP 61
62657: NOT
62658: IFFALSE 62662
// exit ;
62660: GO 62736
// for i = 1 to mc_bases do
62662: LD_ADDR_VAR 0 2
62666: PUSH
62667: DOUBLE
62668: LD_INT 1
62670: DEC
62671: ST_TO_ADDR
62672: LD_EXP 61
62676: PUSH
62677: FOR_TO
62678: IFFALSE 62734
// if mc_bases [ i ] then
62680: LD_EXP 61
62684: PUSH
62685: LD_VAR 0 2
62689: ARRAY
62690: IFFALSE 62732
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
62692: LD_ADDR_EXP 87
62696: PUSH
62697: LD_EXP 87
62701: PPUSH
62702: LD_VAR 0 2
62706: PPUSH
62707: LD_EXP 61
62711: PUSH
62712: LD_VAR 0 2
62716: ARRAY
62717: PUSH
62718: LD_INT 1
62720: ARRAY
62721: PPUSH
62722: CALL_OW 255
62726: PPUSH
62727: CALL_OW 1
62731: ST_TO_ADDR
62732: GO 62677
62734: POP
62735: POP
// end ;
62736: LD_VAR 0 1
62740: RET
// every 0 0$03 trigger skirmish do
62741: LD_EXP 59
62745: IFFALSE 62899
62747: GO 62749
62749: DISABLE
// begin enable ;
62750: ENABLE
// MC_CheckBuildings ( ) ;
62751: CALL 67411 0 0
// MC_CheckPeopleLife ( ) ;
62755: CALL 67572 0 0
// RaiseSailEvent ( 100 ) ;
62759: LD_INT 100
62761: PPUSH
62762: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
62766: LD_INT 103
62768: PPUSH
62769: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
62773: LD_INT 104
62775: PPUSH
62776: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
62780: LD_INT 105
62782: PPUSH
62783: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
62787: LD_INT 106
62789: PPUSH
62790: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
62794: LD_INT 107
62796: PPUSH
62797: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
62801: LD_INT 108
62803: PPUSH
62804: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
62808: LD_INT 109
62810: PPUSH
62811: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
62815: LD_INT 110
62817: PPUSH
62818: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
62822: LD_INT 111
62824: PPUSH
62825: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
62829: LD_INT 112
62831: PPUSH
62832: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
62836: LD_INT 113
62838: PPUSH
62839: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
62843: LD_INT 120
62845: PPUSH
62846: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
62850: LD_INT 121
62852: PPUSH
62853: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
62857: LD_INT 122
62859: PPUSH
62860: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
62864: LD_INT 123
62866: PPUSH
62867: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
62871: LD_INT 124
62873: PPUSH
62874: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
62878: LD_INT 125
62880: PPUSH
62881: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
62885: LD_INT 126
62887: PPUSH
62888: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
62892: LD_INT 200
62894: PPUSH
62895: CALL_OW 427
// end ;
62899: END
// on SailEvent ( event ) do begin if event < 100 then
62900: LD_VAR 0 1
62904: PUSH
62905: LD_INT 100
62907: LESS
62908: IFFALSE 62919
// CustomEvent ( event ) ;
62910: LD_VAR 0 1
62914: PPUSH
62915: CALL 15083 0 1
// if event = 100 then
62919: LD_VAR 0 1
62923: PUSH
62924: LD_INT 100
62926: EQUAL
62927: IFFALSE 62933
// MC_ClassManager ( ) ;
62929: CALL 63325 0 0
// if event = 101 then
62933: LD_VAR 0 1
62937: PUSH
62938: LD_INT 101
62940: EQUAL
62941: IFFALSE 62947
// MC_RepairBuildings ( ) ;
62943: CALL 68157 0 0
// if event = 102 then
62947: LD_VAR 0 1
62951: PUSH
62952: LD_INT 102
62954: EQUAL
62955: IFFALSE 62961
// MC_Heal ( ) ;
62957: CALL 69092 0 0
// if event = 103 then
62961: LD_VAR 0 1
62965: PUSH
62966: LD_INT 103
62968: EQUAL
62969: IFFALSE 62975
// MC_Build ( ) ;
62971: CALL 69514 0 0
// if event = 104 then
62975: LD_VAR 0 1
62979: PUSH
62980: LD_INT 104
62982: EQUAL
62983: IFFALSE 62989
// MC_TurretWeapon ( ) ;
62985: CALL 71148 0 0
// if event = 105 then
62989: LD_VAR 0 1
62993: PUSH
62994: LD_INT 105
62996: EQUAL
62997: IFFALSE 63003
// MC_BuildUpgrade ( ) ;
62999: CALL 70699 0 0
// if event = 106 then
63003: LD_VAR 0 1
63007: PUSH
63008: LD_INT 106
63010: EQUAL
63011: IFFALSE 63017
// MC_PlantMines ( ) ;
63013: CALL 71578 0 0
// if event = 107 then
63017: LD_VAR 0 1
63021: PUSH
63022: LD_INT 107
63024: EQUAL
63025: IFFALSE 63031
// MC_CollectCrates ( ) ;
63027: CALL 72376 0 0
// if event = 108 then
63031: LD_VAR 0 1
63035: PUSH
63036: LD_INT 108
63038: EQUAL
63039: IFFALSE 63045
// MC_LinkRemoteControl ( ) ;
63041: CALL 74226 0 0
// if event = 109 then
63045: LD_VAR 0 1
63049: PUSH
63050: LD_INT 109
63052: EQUAL
63053: IFFALSE 63059
// MC_ProduceVehicle ( ) ;
63055: CALL 74407 0 0
// if event = 110 then
63059: LD_VAR 0 1
63063: PUSH
63064: LD_INT 110
63066: EQUAL
63067: IFFALSE 63073
// MC_SendAttack ( ) ;
63069: CALL 74873 0 0
// if event = 111 then
63073: LD_VAR 0 1
63077: PUSH
63078: LD_INT 111
63080: EQUAL
63081: IFFALSE 63087
// MC_Defend ( ) ;
63083: CALL 74981 0 0
// if event = 112 then
63087: LD_VAR 0 1
63091: PUSH
63092: LD_INT 112
63094: EQUAL
63095: IFFALSE 63101
// MC_Research ( ) ;
63097: CALL 75861 0 0
// if event = 113 then
63101: LD_VAR 0 1
63105: PUSH
63106: LD_INT 113
63108: EQUAL
63109: IFFALSE 63115
// MC_MinesTrigger ( ) ;
63111: CALL 76975 0 0
// if event = 120 then
63115: LD_VAR 0 1
63119: PUSH
63120: LD_INT 120
63122: EQUAL
63123: IFFALSE 63129
// MC_RepairVehicle ( ) ;
63125: CALL 77074 0 0
// if event = 121 then
63129: LD_VAR 0 1
63133: PUSH
63134: LD_INT 121
63136: EQUAL
63137: IFFALSE 63143
// MC_TameApe ( ) ;
63139: CALL 77843 0 0
// if event = 122 then
63143: LD_VAR 0 1
63147: PUSH
63148: LD_INT 122
63150: EQUAL
63151: IFFALSE 63157
// MC_ChangeApeClass ( ) ;
63153: CALL 78672 0 0
// if event = 123 then
63157: LD_VAR 0 1
63161: PUSH
63162: LD_INT 123
63164: EQUAL
63165: IFFALSE 63171
// MC_Bazooka ( ) ;
63167: CALL 79322 0 0
// if event = 124 then
63171: LD_VAR 0 1
63175: PUSH
63176: LD_INT 124
63178: EQUAL
63179: IFFALSE 63185
// MC_TeleportExit ( ) ;
63181: CALL 79520 0 0
// if event = 125 then
63185: LD_VAR 0 1
63189: PUSH
63190: LD_INT 125
63192: EQUAL
63193: IFFALSE 63199
// MC_Deposits ( ) ;
63195: CALL 80167 0 0
// if event = 126 then
63199: LD_VAR 0 1
63203: PUSH
63204: LD_INT 126
63206: EQUAL
63207: IFFALSE 63213
// MC_RemoteDriver ( ) ;
63209: CALL 80792 0 0
// if event = 200 then
63213: LD_VAR 0 1
63217: PUSH
63218: LD_INT 200
63220: EQUAL
63221: IFFALSE 63227
// MC_Idle ( ) ;
63223: CALL 82699 0 0
// end ;
63227: PPOPN 1
63229: END
// export function MC_Reset ( base , tag ) ; var i ; begin
63230: LD_INT 0
63232: PPUSH
63233: PPUSH
// if not mc_bases [ base ] or not tag then
63234: LD_EXP 61
63238: PUSH
63239: LD_VAR 0 1
63243: ARRAY
63244: NOT
63245: PUSH
63246: LD_VAR 0 2
63250: NOT
63251: OR
63252: IFFALSE 63256
// exit ;
63254: GO 63320
// for i in mc_bases [ base ] union mc_ape [ base ] do
63256: LD_ADDR_VAR 0 4
63260: PUSH
63261: LD_EXP 61
63265: PUSH
63266: LD_VAR 0 1
63270: ARRAY
63271: PUSH
63272: LD_EXP 90
63276: PUSH
63277: LD_VAR 0 1
63281: ARRAY
63282: UNION
63283: PUSH
63284: FOR_IN
63285: IFFALSE 63318
// if GetTag ( i ) = tag then
63287: LD_VAR 0 4
63291: PPUSH
63292: CALL_OW 110
63296: PUSH
63297: LD_VAR 0 2
63301: EQUAL
63302: IFFALSE 63316
// SetTag ( i , 0 ) ;
63304: LD_VAR 0 4
63308: PPUSH
63309: LD_INT 0
63311: PPUSH
63312: CALL_OW 109
63316: GO 63284
63318: POP
63319: POP
// end ;
63320: LD_VAR 0 3
63324: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
63325: LD_INT 0
63327: PPUSH
63328: PPUSH
63329: PPUSH
63330: PPUSH
63331: PPUSH
63332: PPUSH
63333: PPUSH
63334: PPUSH
// if not mc_bases then
63335: LD_EXP 61
63339: NOT
63340: IFFALSE 63344
// exit ;
63342: GO 63793
// for i = 1 to mc_bases do
63344: LD_ADDR_VAR 0 2
63348: PUSH
63349: DOUBLE
63350: LD_INT 1
63352: DEC
63353: ST_TO_ADDR
63354: LD_EXP 61
63358: PUSH
63359: FOR_TO
63360: IFFALSE 63791
// begin tmp := MC_ClassCheckReq ( i ) ;
63362: LD_ADDR_VAR 0 4
63366: PUSH
63367: LD_VAR 0 2
63371: PPUSH
63372: CALL 63798 0 1
63376: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
63377: LD_ADDR_EXP 102
63381: PUSH
63382: LD_EXP 102
63386: PPUSH
63387: LD_VAR 0 2
63391: PPUSH
63392: LD_VAR 0 4
63396: PPUSH
63397: CALL_OW 1
63401: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
63402: LD_ADDR_VAR 0 6
63406: PUSH
63407: LD_EXP 61
63411: PUSH
63412: LD_VAR 0 2
63416: ARRAY
63417: PPUSH
63418: LD_INT 2
63420: PUSH
63421: LD_INT 30
63423: PUSH
63424: LD_INT 4
63426: PUSH
63427: EMPTY
63428: LIST
63429: LIST
63430: PUSH
63431: LD_INT 30
63433: PUSH
63434: LD_INT 5
63436: PUSH
63437: EMPTY
63438: LIST
63439: LIST
63440: PUSH
63441: EMPTY
63442: LIST
63443: LIST
63444: LIST
63445: PPUSH
63446: CALL_OW 72
63450: PUSH
63451: LD_EXP 61
63455: PUSH
63456: LD_VAR 0 2
63460: ARRAY
63461: PPUSH
63462: LD_INT 2
63464: PUSH
63465: LD_INT 30
63467: PUSH
63468: LD_INT 0
63470: PUSH
63471: EMPTY
63472: LIST
63473: LIST
63474: PUSH
63475: LD_INT 30
63477: PUSH
63478: LD_INT 1
63480: PUSH
63481: EMPTY
63482: LIST
63483: LIST
63484: PUSH
63485: EMPTY
63486: LIST
63487: LIST
63488: LIST
63489: PPUSH
63490: CALL_OW 72
63494: PUSH
63495: LD_EXP 61
63499: PUSH
63500: LD_VAR 0 2
63504: ARRAY
63505: PPUSH
63506: LD_INT 30
63508: PUSH
63509: LD_INT 3
63511: PUSH
63512: EMPTY
63513: LIST
63514: LIST
63515: PPUSH
63516: CALL_OW 72
63520: PUSH
63521: LD_EXP 61
63525: PUSH
63526: LD_VAR 0 2
63530: ARRAY
63531: PPUSH
63532: LD_INT 2
63534: PUSH
63535: LD_INT 30
63537: PUSH
63538: LD_INT 6
63540: PUSH
63541: EMPTY
63542: LIST
63543: LIST
63544: PUSH
63545: LD_INT 30
63547: PUSH
63548: LD_INT 7
63550: PUSH
63551: EMPTY
63552: LIST
63553: LIST
63554: PUSH
63555: LD_INT 30
63557: PUSH
63558: LD_INT 8
63560: PUSH
63561: EMPTY
63562: LIST
63563: LIST
63564: PUSH
63565: EMPTY
63566: LIST
63567: LIST
63568: LIST
63569: LIST
63570: PPUSH
63571: CALL_OW 72
63575: PUSH
63576: EMPTY
63577: LIST
63578: LIST
63579: LIST
63580: LIST
63581: ST_TO_ADDR
// for j := 1 to 4 do
63582: LD_ADDR_VAR 0 3
63586: PUSH
63587: DOUBLE
63588: LD_INT 1
63590: DEC
63591: ST_TO_ADDR
63592: LD_INT 4
63594: PUSH
63595: FOR_TO
63596: IFFALSE 63787
// begin if not tmp [ j ] then
63598: LD_VAR 0 4
63602: PUSH
63603: LD_VAR 0 3
63607: ARRAY
63608: NOT
63609: IFFALSE 63613
// continue ;
63611: GO 63595
// for p in tmp [ j ] do
63613: LD_ADDR_VAR 0 5
63617: PUSH
63618: LD_VAR 0 4
63622: PUSH
63623: LD_VAR 0 3
63627: ARRAY
63628: PUSH
63629: FOR_IN
63630: IFFALSE 63783
// begin if not b [ j ] then
63632: LD_VAR 0 6
63636: PUSH
63637: LD_VAR 0 3
63641: ARRAY
63642: NOT
63643: IFFALSE 63647
// break ;
63645: GO 63783
// e := 0 ;
63647: LD_ADDR_VAR 0 7
63651: PUSH
63652: LD_INT 0
63654: ST_TO_ADDR
// for k in b [ j ] do
63655: LD_ADDR_VAR 0 8
63659: PUSH
63660: LD_VAR 0 6
63664: PUSH
63665: LD_VAR 0 3
63669: ARRAY
63670: PUSH
63671: FOR_IN
63672: IFFALSE 63699
// if IsNotFull ( k ) then
63674: LD_VAR 0 8
63678: PPUSH
63679: CALL 18619 0 1
63683: IFFALSE 63697
// begin e := k ;
63685: LD_ADDR_VAR 0 7
63689: PUSH
63690: LD_VAR 0 8
63694: ST_TO_ADDR
// break ;
63695: GO 63699
// end ;
63697: GO 63671
63699: POP
63700: POP
// if e and not UnitGoingToBuilding ( p , e ) then
63701: LD_VAR 0 7
63705: PUSH
63706: LD_VAR 0 5
63710: PPUSH
63711: LD_VAR 0 7
63715: PPUSH
63716: CALL 52758 0 2
63720: NOT
63721: AND
63722: IFFALSE 63781
// begin if IsInUnit ( p ) then
63724: LD_VAR 0 5
63728: PPUSH
63729: CALL_OW 310
63733: IFFALSE 63744
// ComExitBuilding ( p ) ;
63735: LD_VAR 0 5
63739: PPUSH
63740: CALL_OW 122
// ComEnterUnit ( p , e ) ;
63744: LD_VAR 0 5
63748: PPUSH
63749: LD_VAR 0 7
63753: PPUSH
63754: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
63758: LD_VAR 0 5
63762: PPUSH
63763: LD_VAR 0 3
63767: PPUSH
63768: CALL_OW 183
// AddComExitBuilding ( p ) ;
63772: LD_VAR 0 5
63776: PPUSH
63777: CALL_OW 182
// end ; end ;
63781: GO 63629
63783: POP
63784: POP
// end ;
63785: GO 63595
63787: POP
63788: POP
// end ;
63789: GO 63359
63791: POP
63792: POP
// end ;
63793: LD_VAR 0 1
63797: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
63798: LD_INT 0
63800: PPUSH
63801: PPUSH
63802: PPUSH
63803: PPUSH
63804: PPUSH
63805: PPUSH
63806: PPUSH
63807: PPUSH
63808: PPUSH
63809: PPUSH
63810: PPUSH
63811: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
63812: LD_ADDR_VAR 0 2
63816: PUSH
63817: LD_INT 0
63819: PUSH
63820: LD_INT 0
63822: PUSH
63823: LD_INT 0
63825: PUSH
63826: LD_INT 0
63828: PUSH
63829: EMPTY
63830: LIST
63831: LIST
63832: LIST
63833: LIST
63834: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63835: LD_VAR 0 1
63839: NOT
63840: PUSH
63841: LD_EXP 61
63845: PUSH
63846: LD_VAR 0 1
63850: ARRAY
63851: NOT
63852: OR
63853: PUSH
63854: LD_EXP 61
63858: PUSH
63859: LD_VAR 0 1
63863: ARRAY
63864: PPUSH
63865: LD_INT 2
63867: PUSH
63868: LD_INT 30
63870: PUSH
63871: LD_INT 0
63873: PUSH
63874: EMPTY
63875: LIST
63876: LIST
63877: PUSH
63878: LD_INT 30
63880: PUSH
63881: LD_INT 1
63883: PUSH
63884: EMPTY
63885: LIST
63886: LIST
63887: PUSH
63888: EMPTY
63889: LIST
63890: LIST
63891: LIST
63892: PPUSH
63893: CALL_OW 72
63897: NOT
63898: OR
63899: IFFALSE 63903
// exit ;
63901: GO 67406
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
63903: LD_ADDR_VAR 0 4
63907: PUSH
63908: LD_EXP 61
63912: PUSH
63913: LD_VAR 0 1
63917: ARRAY
63918: PPUSH
63919: LD_INT 2
63921: PUSH
63922: LD_INT 25
63924: PUSH
63925: LD_INT 1
63927: PUSH
63928: EMPTY
63929: LIST
63930: LIST
63931: PUSH
63932: LD_INT 25
63934: PUSH
63935: LD_INT 2
63937: PUSH
63938: EMPTY
63939: LIST
63940: LIST
63941: PUSH
63942: LD_INT 25
63944: PUSH
63945: LD_INT 3
63947: PUSH
63948: EMPTY
63949: LIST
63950: LIST
63951: PUSH
63952: LD_INT 25
63954: PUSH
63955: LD_INT 4
63957: PUSH
63958: EMPTY
63959: LIST
63960: LIST
63961: PUSH
63962: LD_INT 25
63964: PUSH
63965: LD_INT 5
63967: PUSH
63968: EMPTY
63969: LIST
63970: LIST
63971: PUSH
63972: LD_INT 25
63974: PUSH
63975: LD_INT 8
63977: PUSH
63978: EMPTY
63979: LIST
63980: LIST
63981: PUSH
63982: LD_INT 25
63984: PUSH
63985: LD_INT 9
63987: PUSH
63988: EMPTY
63989: LIST
63990: LIST
63991: PUSH
63992: EMPTY
63993: LIST
63994: LIST
63995: LIST
63996: LIST
63997: LIST
63998: LIST
63999: LIST
64000: LIST
64001: PPUSH
64002: CALL_OW 72
64006: ST_TO_ADDR
// if not tmp then
64007: LD_VAR 0 4
64011: NOT
64012: IFFALSE 64016
// exit ;
64014: GO 67406
// for i in tmp do
64016: LD_ADDR_VAR 0 3
64020: PUSH
64021: LD_VAR 0 4
64025: PUSH
64026: FOR_IN
64027: IFFALSE 64058
// if GetTag ( i ) then
64029: LD_VAR 0 3
64033: PPUSH
64034: CALL_OW 110
64038: IFFALSE 64056
// tmp := tmp diff i ;
64040: LD_ADDR_VAR 0 4
64044: PUSH
64045: LD_VAR 0 4
64049: PUSH
64050: LD_VAR 0 3
64054: DIFF
64055: ST_TO_ADDR
64056: GO 64026
64058: POP
64059: POP
// if not tmp then
64060: LD_VAR 0 4
64064: NOT
64065: IFFALSE 64069
// exit ;
64067: GO 67406
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
64069: LD_ADDR_VAR 0 5
64073: PUSH
64074: LD_EXP 61
64078: PUSH
64079: LD_VAR 0 1
64083: ARRAY
64084: PPUSH
64085: LD_INT 2
64087: PUSH
64088: LD_INT 25
64090: PUSH
64091: LD_INT 1
64093: PUSH
64094: EMPTY
64095: LIST
64096: LIST
64097: PUSH
64098: LD_INT 25
64100: PUSH
64101: LD_INT 5
64103: PUSH
64104: EMPTY
64105: LIST
64106: LIST
64107: PUSH
64108: LD_INT 25
64110: PUSH
64111: LD_INT 8
64113: PUSH
64114: EMPTY
64115: LIST
64116: LIST
64117: PUSH
64118: LD_INT 25
64120: PUSH
64121: LD_INT 9
64123: PUSH
64124: EMPTY
64125: LIST
64126: LIST
64127: PUSH
64128: EMPTY
64129: LIST
64130: LIST
64131: LIST
64132: LIST
64133: LIST
64134: PPUSH
64135: CALL_OW 72
64139: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
64140: LD_ADDR_VAR 0 6
64144: PUSH
64145: LD_EXP 61
64149: PUSH
64150: LD_VAR 0 1
64154: ARRAY
64155: PPUSH
64156: LD_INT 25
64158: PUSH
64159: LD_INT 2
64161: PUSH
64162: EMPTY
64163: LIST
64164: LIST
64165: PPUSH
64166: CALL_OW 72
64170: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
64171: LD_ADDR_VAR 0 7
64175: PUSH
64176: LD_EXP 61
64180: PUSH
64181: LD_VAR 0 1
64185: ARRAY
64186: PPUSH
64187: LD_INT 25
64189: PUSH
64190: LD_INT 3
64192: PUSH
64193: EMPTY
64194: LIST
64195: LIST
64196: PPUSH
64197: CALL_OW 72
64201: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
64202: LD_ADDR_VAR 0 8
64206: PUSH
64207: LD_EXP 61
64211: PUSH
64212: LD_VAR 0 1
64216: ARRAY
64217: PPUSH
64218: LD_INT 25
64220: PUSH
64221: LD_INT 4
64223: PUSH
64224: EMPTY
64225: LIST
64226: LIST
64227: PUSH
64228: LD_INT 24
64230: PUSH
64231: LD_INT 251
64233: PUSH
64234: EMPTY
64235: LIST
64236: LIST
64237: PUSH
64238: EMPTY
64239: LIST
64240: LIST
64241: PPUSH
64242: CALL_OW 72
64246: ST_TO_ADDR
// if mc_is_defending [ base ] then
64247: LD_EXP 104
64251: PUSH
64252: LD_VAR 0 1
64256: ARRAY
64257: IFFALSE 64718
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
64259: LD_ADDR_EXP 103
64263: PUSH
64264: LD_EXP 103
64268: PPUSH
64269: LD_VAR 0 1
64273: PPUSH
64274: LD_INT 4
64276: PPUSH
64277: CALL_OW 1
64281: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64282: LD_ADDR_VAR 0 12
64286: PUSH
64287: LD_EXP 61
64291: PUSH
64292: LD_VAR 0 1
64296: ARRAY
64297: PPUSH
64298: LD_INT 2
64300: PUSH
64301: LD_INT 30
64303: PUSH
64304: LD_INT 4
64306: PUSH
64307: EMPTY
64308: LIST
64309: LIST
64310: PUSH
64311: LD_INT 30
64313: PUSH
64314: LD_INT 5
64316: PUSH
64317: EMPTY
64318: LIST
64319: LIST
64320: PUSH
64321: EMPTY
64322: LIST
64323: LIST
64324: LIST
64325: PPUSH
64326: CALL_OW 72
64330: ST_TO_ADDR
// if not b then
64331: LD_VAR 0 12
64335: NOT
64336: IFFALSE 64340
// exit ;
64338: GO 67406
// p := [ ] ;
64340: LD_ADDR_VAR 0 11
64344: PUSH
64345: EMPTY
64346: ST_TO_ADDR
// if sci >= 2 then
64347: LD_VAR 0 8
64351: PUSH
64352: LD_INT 2
64354: GREATEREQUAL
64355: IFFALSE 64386
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
64357: LD_ADDR_VAR 0 8
64361: PUSH
64362: LD_VAR 0 8
64366: PUSH
64367: LD_INT 1
64369: ARRAY
64370: PUSH
64371: LD_VAR 0 8
64375: PUSH
64376: LD_INT 2
64378: ARRAY
64379: PUSH
64380: EMPTY
64381: LIST
64382: LIST
64383: ST_TO_ADDR
64384: GO 64447
// if sci = 1 then
64386: LD_VAR 0 8
64390: PUSH
64391: LD_INT 1
64393: EQUAL
64394: IFFALSE 64415
// sci := [ sci [ 1 ] ] else
64396: LD_ADDR_VAR 0 8
64400: PUSH
64401: LD_VAR 0 8
64405: PUSH
64406: LD_INT 1
64408: ARRAY
64409: PUSH
64410: EMPTY
64411: LIST
64412: ST_TO_ADDR
64413: GO 64447
// if sci = 0 then
64415: LD_VAR 0 8
64419: PUSH
64420: LD_INT 0
64422: EQUAL
64423: IFFALSE 64447
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
64425: LD_ADDR_VAR 0 11
64429: PUSH
64430: LD_VAR 0 4
64434: PPUSH
64435: LD_INT 4
64437: PPUSH
64438: CALL 52630 0 2
64442: PUSH
64443: LD_INT 1
64445: ARRAY
64446: ST_TO_ADDR
// if eng > 4 then
64447: LD_VAR 0 6
64451: PUSH
64452: LD_INT 4
64454: GREATER
64455: IFFALSE 64501
// for i = eng downto 4 do
64457: LD_ADDR_VAR 0 3
64461: PUSH
64462: DOUBLE
64463: LD_VAR 0 6
64467: INC
64468: ST_TO_ADDR
64469: LD_INT 4
64471: PUSH
64472: FOR_DOWNTO
64473: IFFALSE 64499
// eng := eng diff eng [ i ] ;
64475: LD_ADDR_VAR 0 6
64479: PUSH
64480: LD_VAR 0 6
64484: PUSH
64485: LD_VAR 0 6
64489: PUSH
64490: LD_VAR 0 3
64494: ARRAY
64495: DIFF
64496: ST_TO_ADDR
64497: GO 64472
64499: POP
64500: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
64501: LD_ADDR_VAR 0 4
64505: PUSH
64506: LD_VAR 0 4
64510: PUSH
64511: LD_VAR 0 5
64515: PUSH
64516: LD_VAR 0 6
64520: UNION
64521: PUSH
64522: LD_VAR 0 7
64526: UNION
64527: PUSH
64528: LD_VAR 0 8
64532: UNION
64533: DIFF
64534: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
64535: LD_ADDR_VAR 0 13
64539: PUSH
64540: LD_EXP 61
64544: PUSH
64545: LD_VAR 0 1
64549: ARRAY
64550: PPUSH
64551: LD_INT 2
64553: PUSH
64554: LD_INT 30
64556: PUSH
64557: LD_INT 32
64559: PUSH
64560: EMPTY
64561: LIST
64562: LIST
64563: PUSH
64564: LD_INT 30
64566: PUSH
64567: LD_INT 31
64569: PUSH
64570: EMPTY
64571: LIST
64572: LIST
64573: PUSH
64574: EMPTY
64575: LIST
64576: LIST
64577: LIST
64578: PPUSH
64579: CALL_OW 72
64583: PUSH
64584: LD_EXP 61
64588: PUSH
64589: LD_VAR 0 1
64593: ARRAY
64594: PPUSH
64595: LD_INT 2
64597: PUSH
64598: LD_INT 30
64600: PUSH
64601: LD_INT 4
64603: PUSH
64604: EMPTY
64605: LIST
64606: LIST
64607: PUSH
64608: LD_INT 30
64610: PUSH
64611: LD_INT 5
64613: PUSH
64614: EMPTY
64615: LIST
64616: LIST
64617: PUSH
64618: EMPTY
64619: LIST
64620: LIST
64621: LIST
64622: PPUSH
64623: CALL_OW 72
64627: PUSH
64628: LD_INT 6
64630: MUL
64631: PLUS
64632: ST_TO_ADDR
// if bcount < tmp then
64633: LD_VAR 0 13
64637: PUSH
64638: LD_VAR 0 4
64642: LESS
64643: IFFALSE 64689
// for i = tmp downto bcount do
64645: LD_ADDR_VAR 0 3
64649: PUSH
64650: DOUBLE
64651: LD_VAR 0 4
64655: INC
64656: ST_TO_ADDR
64657: LD_VAR 0 13
64661: PUSH
64662: FOR_DOWNTO
64663: IFFALSE 64687
// tmp := Delete ( tmp , tmp ) ;
64665: LD_ADDR_VAR 0 4
64669: PUSH
64670: LD_VAR 0 4
64674: PPUSH
64675: LD_VAR 0 4
64679: PPUSH
64680: CALL_OW 3
64684: ST_TO_ADDR
64685: GO 64662
64687: POP
64688: POP
// result := [ tmp , 0 , 0 , p ] ;
64689: LD_ADDR_VAR 0 2
64693: PUSH
64694: LD_VAR 0 4
64698: PUSH
64699: LD_INT 0
64701: PUSH
64702: LD_INT 0
64704: PUSH
64705: LD_VAR 0 11
64709: PUSH
64710: EMPTY
64711: LIST
64712: LIST
64713: LIST
64714: LIST
64715: ST_TO_ADDR
// exit ;
64716: GO 67406
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
64718: LD_EXP 61
64722: PUSH
64723: LD_VAR 0 1
64727: ARRAY
64728: PPUSH
64729: LD_INT 2
64731: PUSH
64732: LD_INT 30
64734: PUSH
64735: LD_INT 6
64737: PUSH
64738: EMPTY
64739: LIST
64740: LIST
64741: PUSH
64742: LD_INT 30
64744: PUSH
64745: LD_INT 7
64747: PUSH
64748: EMPTY
64749: LIST
64750: LIST
64751: PUSH
64752: LD_INT 30
64754: PUSH
64755: LD_INT 8
64757: PUSH
64758: EMPTY
64759: LIST
64760: LIST
64761: PUSH
64762: EMPTY
64763: LIST
64764: LIST
64765: LIST
64766: LIST
64767: PPUSH
64768: CALL_OW 72
64772: NOT
64773: PUSH
64774: LD_EXP 61
64778: PUSH
64779: LD_VAR 0 1
64783: ARRAY
64784: PPUSH
64785: LD_INT 30
64787: PUSH
64788: LD_INT 3
64790: PUSH
64791: EMPTY
64792: LIST
64793: LIST
64794: PPUSH
64795: CALL_OW 72
64799: NOT
64800: AND
64801: IFFALSE 64873
// begin if eng = tmp then
64803: LD_VAR 0 6
64807: PUSH
64808: LD_VAR 0 4
64812: EQUAL
64813: IFFALSE 64817
// exit ;
64815: GO 67406
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
64817: LD_ADDR_EXP 103
64821: PUSH
64822: LD_EXP 103
64826: PPUSH
64827: LD_VAR 0 1
64831: PPUSH
64832: LD_INT 1
64834: PPUSH
64835: CALL_OW 1
64839: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
64840: LD_ADDR_VAR 0 2
64844: PUSH
64845: LD_INT 0
64847: PUSH
64848: LD_VAR 0 4
64852: PUSH
64853: LD_VAR 0 6
64857: DIFF
64858: PUSH
64859: LD_INT 0
64861: PUSH
64862: LD_INT 0
64864: PUSH
64865: EMPTY
64866: LIST
64867: LIST
64868: LIST
64869: LIST
64870: ST_TO_ADDR
// exit ;
64871: GO 67406
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
64873: LD_EXP 88
64877: PUSH
64878: LD_EXP 87
64882: PUSH
64883: LD_VAR 0 1
64887: ARRAY
64888: ARRAY
64889: PUSH
64890: LD_EXP 61
64894: PUSH
64895: LD_VAR 0 1
64899: ARRAY
64900: PPUSH
64901: LD_INT 2
64903: PUSH
64904: LD_INT 30
64906: PUSH
64907: LD_INT 6
64909: PUSH
64910: EMPTY
64911: LIST
64912: LIST
64913: PUSH
64914: LD_INT 30
64916: PUSH
64917: LD_INT 7
64919: PUSH
64920: EMPTY
64921: LIST
64922: LIST
64923: PUSH
64924: LD_INT 30
64926: PUSH
64927: LD_INT 8
64929: PUSH
64930: EMPTY
64931: LIST
64932: LIST
64933: PUSH
64934: EMPTY
64935: LIST
64936: LIST
64937: LIST
64938: LIST
64939: PPUSH
64940: CALL_OW 72
64944: AND
64945: PUSH
64946: LD_EXP 61
64950: PUSH
64951: LD_VAR 0 1
64955: ARRAY
64956: PPUSH
64957: LD_INT 30
64959: PUSH
64960: LD_INT 3
64962: PUSH
64963: EMPTY
64964: LIST
64965: LIST
64966: PPUSH
64967: CALL_OW 72
64971: NOT
64972: AND
64973: IFFALSE 65187
// begin if sci >= 6 then
64975: LD_VAR 0 8
64979: PUSH
64980: LD_INT 6
64982: GREATEREQUAL
64983: IFFALSE 64987
// exit ;
64985: GO 67406
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
64987: LD_ADDR_EXP 103
64991: PUSH
64992: LD_EXP 103
64996: PPUSH
64997: LD_VAR 0 1
65001: PPUSH
65002: LD_INT 2
65004: PPUSH
65005: CALL_OW 1
65009: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
65010: LD_ADDR_VAR 0 9
65014: PUSH
65015: LD_VAR 0 4
65019: PUSH
65020: LD_VAR 0 8
65024: DIFF
65025: PPUSH
65026: LD_INT 4
65028: PPUSH
65029: CALL 52630 0 2
65033: ST_TO_ADDR
// p := [ ] ;
65034: LD_ADDR_VAR 0 11
65038: PUSH
65039: EMPTY
65040: ST_TO_ADDR
// if sci < 6 and sort > 6 then
65041: LD_VAR 0 8
65045: PUSH
65046: LD_INT 6
65048: LESS
65049: PUSH
65050: LD_VAR 0 9
65054: PUSH
65055: LD_INT 6
65057: GREATER
65058: AND
65059: IFFALSE 65140
// begin for i = 1 to 6 - sci do
65061: LD_ADDR_VAR 0 3
65065: PUSH
65066: DOUBLE
65067: LD_INT 1
65069: DEC
65070: ST_TO_ADDR
65071: LD_INT 6
65073: PUSH
65074: LD_VAR 0 8
65078: MINUS
65079: PUSH
65080: FOR_TO
65081: IFFALSE 65136
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
65083: LD_ADDR_VAR 0 11
65087: PUSH
65088: LD_VAR 0 11
65092: PPUSH
65093: LD_VAR 0 11
65097: PUSH
65098: LD_INT 1
65100: PLUS
65101: PPUSH
65102: LD_VAR 0 9
65106: PUSH
65107: LD_INT 1
65109: ARRAY
65110: PPUSH
65111: CALL_OW 2
65115: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
65116: LD_ADDR_VAR 0 9
65120: PUSH
65121: LD_VAR 0 9
65125: PPUSH
65126: LD_INT 1
65128: PPUSH
65129: CALL_OW 3
65133: ST_TO_ADDR
// end ;
65134: GO 65080
65136: POP
65137: POP
// end else
65138: GO 65160
// if sort then
65140: LD_VAR 0 9
65144: IFFALSE 65160
// p := sort [ 1 ] ;
65146: LD_ADDR_VAR 0 11
65150: PUSH
65151: LD_VAR 0 9
65155: PUSH
65156: LD_INT 1
65158: ARRAY
65159: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
65160: LD_ADDR_VAR 0 2
65164: PUSH
65165: LD_INT 0
65167: PUSH
65168: LD_INT 0
65170: PUSH
65171: LD_INT 0
65173: PUSH
65174: LD_VAR 0 11
65178: PUSH
65179: EMPTY
65180: LIST
65181: LIST
65182: LIST
65183: LIST
65184: ST_TO_ADDR
// exit ;
65185: GO 67406
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
65187: LD_EXP 88
65191: PUSH
65192: LD_EXP 87
65196: PUSH
65197: LD_VAR 0 1
65201: ARRAY
65202: ARRAY
65203: PUSH
65204: LD_EXP 61
65208: PUSH
65209: LD_VAR 0 1
65213: ARRAY
65214: PPUSH
65215: LD_INT 2
65217: PUSH
65218: LD_INT 30
65220: PUSH
65221: LD_INT 6
65223: PUSH
65224: EMPTY
65225: LIST
65226: LIST
65227: PUSH
65228: LD_INT 30
65230: PUSH
65231: LD_INT 7
65233: PUSH
65234: EMPTY
65235: LIST
65236: LIST
65237: PUSH
65238: LD_INT 30
65240: PUSH
65241: LD_INT 8
65243: PUSH
65244: EMPTY
65245: LIST
65246: LIST
65247: PUSH
65248: EMPTY
65249: LIST
65250: LIST
65251: LIST
65252: LIST
65253: PPUSH
65254: CALL_OW 72
65258: AND
65259: PUSH
65260: LD_EXP 61
65264: PUSH
65265: LD_VAR 0 1
65269: ARRAY
65270: PPUSH
65271: LD_INT 30
65273: PUSH
65274: LD_INT 3
65276: PUSH
65277: EMPTY
65278: LIST
65279: LIST
65280: PPUSH
65281: CALL_OW 72
65285: AND
65286: IFFALSE 66020
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
65288: LD_ADDR_EXP 103
65292: PUSH
65293: LD_EXP 103
65297: PPUSH
65298: LD_VAR 0 1
65302: PPUSH
65303: LD_INT 3
65305: PPUSH
65306: CALL_OW 1
65310: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
65311: LD_ADDR_VAR 0 2
65315: PUSH
65316: LD_INT 0
65318: PUSH
65319: LD_INT 0
65321: PUSH
65322: LD_INT 0
65324: PUSH
65325: LD_INT 0
65327: PUSH
65328: EMPTY
65329: LIST
65330: LIST
65331: LIST
65332: LIST
65333: ST_TO_ADDR
// if not eng then
65334: LD_VAR 0 6
65338: NOT
65339: IFFALSE 65402
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
65341: LD_ADDR_VAR 0 11
65345: PUSH
65346: LD_VAR 0 4
65350: PPUSH
65351: LD_INT 2
65353: PPUSH
65354: CALL 52630 0 2
65358: PUSH
65359: LD_INT 1
65361: ARRAY
65362: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
65363: LD_ADDR_VAR 0 2
65367: PUSH
65368: LD_VAR 0 2
65372: PPUSH
65373: LD_INT 2
65375: PPUSH
65376: LD_VAR 0 11
65380: PPUSH
65381: CALL_OW 1
65385: ST_TO_ADDR
// tmp := tmp diff p ;
65386: LD_ADDR_VAR 0 4
65390: PUSH
65391: LD_VAR 0 4
65395: PUSH
65396: LD_VAR 0 11
65400: DIFF
65401: ST_TO_ADDR
// end ; if tmp and sci < 6 then
65402: LD_VAR 0 4
65406: PUSH
65407: LD_VAR 0 8
65411: PUSH
65412: LD_INT 6
65414: LESS
65415: AND
65416: IFFALSE 65604
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
65418: LD_ADDR_VAR 0 9
65422: PUSH
65423: LD_VAR 0 4
65427: PUSH
65428: LD_VAR 0 8
65432: PUSH
65433: LD_VAR 0 7
65437: UNION
65438: DIFF
65439: PPUSH
65440: LD_INT 4
65442: PPUSH
65443: CALL 52630 0 2
65447: ST_TO_ADDR
// p := [ ] ;
65448: LD_ADDR_VAR 0 11
65452: PUSH
65453: EMPTY
65454: ST_TO_ADDR
// if sort then
65455: LD_VAR 0 9
65459: IFFALSE 65575
// for i = 1 to 6 - sci do
65461: LD_ADDR_VAR 0 3
65465: PUSH
65466: DOUBLE
65467: LD_INT 1
65469: DEC
65470: ST_TO_ADDR
65471: LD_INT 6
65473: PUSH
65474: LD_VAR 0 8
65478: MINUS
65479: PUSH
65480: FOR_TO
65481: IFFALSE 65573
// begin if i = sort then
65483: LD_VAR 0 3
65487: PUSH
65488: LD_VAR 0 9
65492: EQUAL
65493: IFFALSE 65497
// break ;
65495: GO 65573
// if GetClass ( i ) = 4 then
65497: LD_VAR 0 3
65501: PPUSH
65502: CALL_OW 257
65506: PUSH
65507: LD_INT 4
65509: EQUAL
65510: IFFALSE 65514
// continue ;
65512: GO 65480
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65514: LD_ADDR_VAR 0 11
65518: PUSH
65519: LD_VAR 0 11
65523: PPUSH
65524: LD_VAR 0 11
65528: PUSH
65529: LD_INT 1
65531: PLUS
65532: PPUSH
65533: LD_VAR 0 9
65537: PUSH
65538: LD_VAR 0 3
65542: ARRAY
65543: PPUSH
65544: CALL_OW 2
65548: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65549: LD_ADDR_VAR 0 4
65553: PUSH
65554: LD_VAR 0 4
65558: PUSH
65559: LD_VAR 0 9
65563: PUSH
65564: LD_VAR 0 3
65568: ARRAY
65569: DIFF
65570: ST_TO_ADDR
// end ;
65571: GO 65480
65573: POP
65574: POP
// if p then
65575: LD_VAR 0 11
65579: IFFALSE 65604
// result := Replace ( result , 4 , p ) ;
65581: LD_ADDR_VAR 0 2
65585: PUSH
65586: LD_VAR 0 2
65590: PPUSH
65591: LD_INT 4
65593: PPUSH
65594: LD_VAR 0 11
65598: PPUSH
65599: CALL_OW 1
65603: ST_TO_ADDR
// end ; if tmp and mech < 6 then
65604: LD_VAR 0 4
65608: PUSH
65609: LD_VAR 0 7
65613: PUSH
65614: LD_INT 6
65616: LESS
65617: AND
65618: IFFALSE 65806
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
65620: LD_ADDR_VAR 0 9
65624: PUSH
65625: LD_VAR 0 4
65629: PUSH
65630: LD_VAR 0 8
65634: PUSH
65635: LD_VAR 0 7
65639: UNION
65640: DIFF
65641: PPUSH
65642: LD_INT 3
65644: PPUSH
65645: CALL 52630 0 2
65649: ST_TO_ADDR
// p := [ ] ;
65650: LD_ADDR_VAR 0 11
65654: PUSH
65655: EMPTY
65656: ST_TO_ADDR
// if sort then
65657: LD_VAR 0 9
65661: IFFALSE 65777
// for i = 1 to 6 - mech do
65663: LD_ADDR_VAR 0 3
65667: PUSH
65668: DOUBLE
65669: LD_INT 1
65671: DEC
65672: ST_TO_ADDR
65673: LD_INT 6
65675: PUSH
65676: LD_VAR 0 7
65680: MINUS
65681: PUSH
65682: FOR_TO
65683: IFFALSE 65775
// begin if i = sort then
65685: LD_VAR 0 3
65689: PUSH
65690: LD_VAR 0 9
65694: EQUAL
65695: IFFALSE 65699
// break ;
65697: GO 65775
// if GetClass ( i ) = 3 then
65699: LD_VAR 0 3
65703: PPUSH
65704: CALL_OW 257
65708: PUSH
65709: LD_INT 3
65711: EQUAL
65712: IFFALSE 65716
// continue ;
65714: GO 65682
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65716: LD_ADDR_VAR 0 11
65720: PUSH
65721: LD_VAR 0 11
65725: PPUSH
65726: LD_VAR 0 11
65730: PUSH
65731: LD_INT 1
65733: PLUS
65734: PPUSH
65735: LD_VAR 0 9
65739: PUSH
65740: LD_VAR 0 3
65744: ARRAY
65745: PPUSH
65746: CALL_OW 2
65750: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65751: LD_ADDR_VAR 0 4
65755: PUSH
65756: LD_VAR 0 4
65760: PUSH
65761: LD_VAR 0 9
65765: PUSH
65766: LD_VAR 0 3
65770: ARRAY
65771: DIFF
65772: ST_TO_ADDR
// end ;
65773: GO 65682
65775: POP
65776: POP
// if p then
65777: LD_VAR 0 11
65781: IFFALSE 65806
// result := Replace ( result , 3 , p ) ;
65783: LD_ADDR_VAR 0 2
65787: PUSH
65788: LD_VAR 0 2
65792: PPUSH
65793: LD_INT 3
65795: PPUSH
65796: LD_VAR 0 11
65800: PPUSH
65801: CALL_OW 1
65805: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
65806: LD_VAR 0 4
65810: PUSH
65811: LD_INT 6
65813: GREATER
65814: PUSH
65815: LD_VAR 0 6
65819: PUSH
65820: LD_INT 6
65822: LESS
65823: AND
65824: IFFALSE 66018
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
65826: LD_ADDR_VAR 0 9
65830: PUSH
65831: LD_VAR 0 4
65835: PUSH
65836: LD_VAR 0 8
65840: PUSH
65841: LD_VAR 0 7
65845: UNION
65846: PUSH
65847: LD_VAR 0 6
65851: UNION
65852: DIFF
65853: PPUSH
65854: LD_INT 2
65856: PPUSH
65857: CALL 52630 0 2
65861: ST_TO_ADDR
// p := [ ] ;
65862: LD_ADDR_VAR 0 11
65866: PUSH
65867: EMPTY
65868: ST_TO_ADDR
// if sort then
65869: LD_VAR 0 9
65873: IFFALSE 65989
// for i = 1 to 6 - eng do
65875: LD_ADDR_VAR 0 3
65879: PUSH
65880: DOUBLE
65881: LD_INT 1
65883: DEC
65884: ST_TO_ADDR
65885: LD_INT 6
65887: PUSH
65888: LD_VAR 0 6
65892: MINUS
65893: PUSH
65894: FOR_TO
65895: IFFALSE 65987
// begin if i = sort then
65897: LD_VAR 0 3
65901: PUSH
65902: LD_VAR 0 9
65906: EQUAL
65907: IFFALSE 65911
// break ;
65909: GO 65987
// if GetClass ( i ) = 2 then
65911: LD_VAR 0 3
65915: PPUSH
65916: CALL_OW 257
65920: PUSH
65921: LD_INT 2
65923: EQUAL
65924: IFFALSE 65928
// continue ;
65926: GO 65894
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65928: LD_ADDR_VAR 0 11
65932: PUSH
65933: LD_VAR 0 11
65937: PPUSH
65938: LD_VAR 0 11
65942: PUSH
65943: LD_INT 1
65945: PLUS
65946: PPUSH
65947: LD_VAR 0 9
65951: PUSH
65952: LD_VAR 0 3
65956: ARRAY
65957: PPUSH
65958: CALL_OW 2
65962: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65963: LD_ADDR_VAR 0 4
65967: PUSH
65968: LD_VAR 0 4
65972: PUSH
65973: LD_VAR 0 9
65977: PUSH
65978: LD_VAR 0 3
65982: ARRAY
65983: DIFF
65984: ST_TO_ADDR
// end ;
65985: GO 65894
65987: POP
65988: POP
// if p then
65989: LD_VAR 0 11
65993: IFFALSE 66018
// result := Replace ( result , 2 , p ) ;
65995: LD_ADDR_VAR 0 2
65999: PUSH
66000: LD_VAR 0 2
66004: PPUSH
66005: LD_INT 2
66007: PPUSH
66008: LD_VAR 0 11
66012: PPUSH
66013: CALL_OW 1
66017: ST_TO_ADDR
// end ; exit ;
66018: GO 67406
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
66020: LD_EXP 88
66024: PUSH
66025: LD_EXP 87
66029: PUSH
66030: LD_VAR 0 1
66034: ARRAY
66035: ARRAY
66036: NOT
66037: PUSH
66038: LD_EXP 61
66042: PUSH
66043: LD_VAR 0 1
66047: ARRAY
66048: PPUSH
66049: LD_INT 30
66051: PUSH
66052: LD_INT 3
66054: PUSH
66055: EMPTY
66056: LIST
66057: LIST
66058: PPUSH
66059: CALL_OW 72
66063: AND
66064: PUSH
66065: LD_EXP 66
66069: PUSH
66070: LD_VAR 0 1
66074: ARRAY
66075: AND
66076: IFFALSE 66684
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
66078: LD_ADDR_EXP 103
66082: PUSH
66083: LD_EXP 103
66087: PPUSH
66088: LD_VAR 0 1
66092: PPUSH
66093: LD_INT 5
66095: PPUSH
66096: CALL_OW 1
66100: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
66101: LD_ADDR_VAR 0 2
66105: PUSH
66106: LD_INT 0
66108: PUSH
66109: LD_INT 0
66111: PUSH
66112: LD_INT 0
66114: PUSH
66115: LD_INT 0
66117: PUSH
66118: EMPTY
66119: LIST
66120: LIST
66121: LIST
66122: LIST
66123: ST_TO_ADDR
// if sci > 1 then
66124: LD_VAR 0 8
66128: PUSH
66129: LD_INT 1
66131: GREATER
66132: IFFALSE 66160
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
66134: LD_ADDR_VAR 0 4
66138: PUSH
66139: LD_VAR 0 4
66143: PUSH
66144: LD_VAR 0 8
66148: PUSH
66149: LD_VAR 0 8
66153: PUSH
66154: LD_INT 1
66156: ARRAY
66157: DIFF
66158: DIFF
66159: ST_TO_ADDR
// if tmp and not sci then
66160: LD_VAR 0 4
66164: PUSH
66165: LD_VAR 0 8
66169: NOT
66170: AND
66171: IFFALSE 66240
// begin sort := SortBySkill ( tmp , 4 ) ;
66173: LD_ADDR_VAR 0 9
66177: PUSH
66178: LD_VAR 0 4
66182: PPUSH
66183: LD_INT 4
66185: PPUSH
66186: CALL 52630 0 2
66190: ST_TO_ADDR
// if sort then
66191: LD_VAR 0 9
66195: IFFALSE 66211
// p := sort [ 1 ] ;
66197: LD_ADDR_VAR 0 11
66201: PUSH
66202: LD_VAR 0 9
66206: PUSH
66207: LD_INT 1
66209: ARRAY
66210: ST_TO_ADDR
// if p then
66211: LD_VAR 0 11
66215: IFFALSE 66240
// result := Replace ( result , 4 , p ) ;
66217: LD_ADDR_VAR 0 2
66221: PUSH
66222: LD_VAR 0 2
66226: PPUSH
66227: LD_INT 4
66229: PPUSH
66230: LD_VAR 0 11
66234: PPUSH
66235: CALL_OW 1
66239: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
66240: LD_ADDR_VAR 0 4
66244: PUSH
66245: LD_VAR 0 4
66249: PUSH
66250: LD_VAR 0 7
66254: DIFF
66255: ST_TO_ADDR
// if tmp and mech < 6 then
66256: LD_VAR 0 4
66260: PUSH
66261: LD_VAR 0 7
66265: PUSH
66266: LD_INT 6
66268: LESS
66269: AND
66270: IFFALSE 66458
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
66272: LD_ADDR_VAR 0 9
66276: PUSH
66277: LD_VAR 0 4
66281: PUSH
66282: LD_VAR 0 8
66286: PUSH
66287: LD_VAR 0 7
66291: UNION
66292: DIFF
66293: PPUSH
66294: LD_INT 3
66296: PPUSH
66297: CALL 52630 0 2
66301: ST_TO_ADDR
// p := [ ] ;
66302: LD_ADDR_VAR 0 11
66306: PUSH
66307: EMPTY
66308: ST_TO_ADDR
// if sort then
66309: LD_VAR 0 9
66313: IFFALSE 66429
// for i = 1 to 6 - mech do
66315: LD_ADDR_VAR 0 3
66319: PUSH
66320: DOUBLE
66321: LD_INT 1
66323: DEC
66324: ST_TO_ADDR
66325: LD_INT 6
66327: PUSH
66328: LD_VAR 0 7
66332: MINUS
66333: PUSH
66334: FOR_TO
66335: IFFALSE 66427
// begin if i = sort then
66337: LD_VAR 0 3
66341: PUSH
66342: LD_VAR 0 9
66346: EQUAL
66347: IFFALSE 66351
// break ;
66349: GO 66427
// if GetClass ( i ) = 3 then
66351: LD_VAR 0 3
66355: PPUSH
66356: CALL_OW 257
66360: PUSH
66361: LD_INT 3
66363: EQUAL
66364: IFFALSE 66368
// continue ;
66366: GO 66334
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66368: LD_ADDR_VAR 0 11
66372: PUSH
66373: LD_VAR 0 11
66377: PPUSH
66378: LD_VAR 0 11
66382: PUSH
66383: LD_INT 1
66385: PLUS
66386: PPUSH
66387: LD_VAR 0 9
66391: PUSH
66392: LD_VAR 0 3
66396: ARRAY
66397: PPUSH
66398: CALL_OW 2
66402: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66403: LD_ADDR_VAR 0 4
66407: PUSH
66408: LD_VAR 0 4
66412: PUSH
66413: LD_VAR 0 9
66417: PUSH
66418: LD_VAR 0 3
66422: ARRAY
66423: DIFF
66424: ST_TO_ADDR
// end ;
66425: GO 66334
66427: POP
66428: POP
// if p then
66429: LD_VAR 0 11
66433: IFFALSE 66458
// result := Replace ( result , 3 , p ) ;
66435: LD_ADDR_VAR 0 2
66439: PUSH
66440: LD_VAR 0 2
66444: PPUSH
66445: LD_INT 3
66447: PPUSH
66448: LD_VAR 0 11
66452: PPUSH
66453: CALL_OW 1
66457: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
66458: LD_ADDR_VAR 0 4
66462: PUSH
66463: LD_VAR 0 4
66467: PUSH
66468: LD_VAR 0 6
66472: DIFF
66473: ST_TO_ADDR
// if tmp and eng < 6 then
66474: LD_VAR 0 4
66478: PUSH
66479: LD_VAR 0 6
66483: PUSH
66484: LD_INT 6
66486: LESS
66487: AND
66488: IFFALSE 66682
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
66490: LD_ADDR_VAR 0 9
66494: PUSH
66495: LD_VAR 0 4
66499: PUSH
66500: LD_VAR 0 8
66504: PUSH
66505: LD_VAR 0 7
66509: UNION
66510: PUSH
66511: LD_VAR 0 6
66515: UNION
66516: DIFF
66517: PPUSH
66518: LD_INT 2
66520: PPUSH
66521: CALL 52630 0 2
66525: ST_TO_ADDR
// p := [ ] ;
66526: LD_ADDR_VAR 0 11
66530: PUSH
66531: EMPTY
66532: ST_TO_ADDR
// if sort then
66533: LD_VAR 0 9
66537: IFFALSE 66653
// for i = 1 to 6 - eng do
66539: LD_ADDR_VAR 0 3
66543: PUSH
66544: DOUBLE
66545: LD_INT 1
66547: DEC
66548: ST_TO_ADDR
66549: LD_INT 6
66551: PUSH
66552: LD_VAR 0 6
66556: MINUS
66557: PUSH
66558: FOR_TO
66559: IFFALSE 66651
// begin if i = sort then
66561: LD_VAR 0 3
66565: PUSH
66566: LD_VAR 0 9
66570: EQUAL
66571: IFFALSE 66575
// break ;
66573: GO 66651
// if GetClass ( i ) = 2 then
66575: LD_VAR 0 3
66579: PPUSH
66580: CALL_OW 257
66584: PUSH
66585: LD_INT 2
66587: EQUAL
66588: IFFALSE 66592
// continue ;
66590: GO 66558
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66592: LD_ADDR_VAR 0 11
66596: PUSH
66597: LD_VAR 0 11
66601: PPUSH
66602: LD_VAR 0 11
66606: PUSH
66607: LD_INT 1
66609: PLUS
66610: PPUSH
66611: LD_VAR 0 9
66615: PUSH
66616: LD_VAR 0 3
66620: ARRAY
66621: PPUSH
66622: CALL_OW 2
66626: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66627: LD_ADDR_VAR 0 4
66631: PUSH
66632: LD_VAR 0 4
66636: PUSH
66637: LD_VAR 0 9
66641: PUSH
66642: LD_VAR 0 3
66646: ARRAY
66647: DIFF
66648: ST_TO_ADDR
// end ;
66649: GO 66558
66651: POP
66652: POP
// if p then
66653: LD_VAR 0 11
66657: IFFALSE 66682
// result := Replace ( result , 2 , p ) ;
66659: LD_ADDR_VAR 0 2
66663: PUSH
66664: LD_VAR 0 2
66668: PPUSH
66669: LD_INT 2
66671: PPUSH
66672: LD_VAR 0 11
66676: PPUSH
66677: CALL_OW 1
66681: ST_TO_ADDR
// end ; exit ;
66682: GO 67406
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
66684: LD_EXP 88
66688: PUSH
66689: LD_EXP 87
66693: PUSH
66694: LD_VAR 0 1
66698: ARRAY
66699: ARRAY
66700: NOT
66701: PUSH
66702: LD_EXP 61
66706: PUSH
66707: LD_VAR 0 1
66711: ARRAY
66712: PPUSH
66713: LD_INT 30
66715: PUSH
66716: LD_INT 3
66718: PUSH
66719: EMPTY
66720: LIST
66721: LIST
66722: PPUSH
66723: CALL_OW 72
66727: AND
66728: PUSH
66729: LD_EXP 66
66733: PUSH
66734: LD_VAR 0 1
66738: ARRAY
66739: NOT
66740: AND
66741: IFFALSE 67406
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
66743: LD_ADDR_EXP 103
66747: PUSH
66748: LD_EXP 103
66752: PPUSH
66753: LD_VAR 0 1
66757: PPUSH
66758: LD_INT 6
66760: PPUSH
66761: CALL_OW 1
66765: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
66766: LD_ADDR_VAR 0 2
66770: PUSH
66771: LD_INT 0
66773: PUSH
66774: LD_INT 0
66776: PUSH
66777: LD_INT 0
66779: PUSH
66780: LD_INT 0
66782: PUSH
66783: EMPTY
66784: LIST
66785: LIST
66786: LIST
66787: LIST
66788: ST_TO_ADDR
// if sci >= 1 then
66789: LD_VAR 0 8
66793: PUSH
66794: LD_INT 1
66796: GREATEREQUAL
66797: IFFALSE 66819
// tmp := tmp diff sci [ 1 ] ;
66799: LD_ADDR_VAR 0 4
66803: PUSH
66804: LD_VAR 0 4
66808: PUSH
66809: LD_VAR 0 8
66813: PUSH
66814: LD_INT 1
66816: ARRAY
66817: DIFF
66818: ST_TO_ADDR
// if tmp and not sci then
66819: LD_VAR 0 4
66823: PUSH
66824: LD_VAR 0 8
66828: NOT
66829: AND
66830: IFFALSE 66899
// begin sort := SortBySkill ( tmp , 4 ) ;
66832: LD_ADDR_VAR 0 9
66836: PUSH
66837: LD_VAR 0 4
66841: PPUSH
66842: LD_INT 4
66844: PPUSH
66845: CALL 52630 0 2
66849: ST_TO_ADDR
// if sort then
66850: LD_VAR 0 9
66854: IFFALSE 66870
// p := sort [ 1 ] ;
66856: LD_ADDR_VAR 0 11
66860: PUSH
66861: LD_VAR 0 9
66865: PUSH
66866: LD_INT 1
66868: ARRAY
66869: ST_TO_ADDR
// if p then
66870: LD_VAR 0 11
66874: IFFALSE 66899
// result := Replace ( result , 4 , p ) ;
66876: LD_ADDR_VAR 0 2
66880: PUSH
66881: LD_VAR 0 2
66885: PPUSH
66886: LD_INT 4
66888: PPUSH
66889: LD_VAR 0 11
66893: PPUSH
66894: CALL_OW 1
66898: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
66899: LD_ADDR_VAR 0 4
66903: PUSH
66904: LD_VAR 0 4
66908: PUSH
66909: LD_VAR 0 7
66913: DIFF
66914: ST_TO_ADDR
// if tmp and mech < 6 then
66915: LD_VAR 0 4
66919: PUSH
66920: LD_VAR 0 7
66924: PUSH
66925: LD_INT 6
66927: LESS
66928: AND
66929: IFFALSE 67111
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
66931: LD_ADDR_VAR 0 9
66935: PUSH
66936: LD_VAR 0 4
66940: PUSH
66941: LD_VAR 0 7
66945: DIFF
66946: PPUSH
66947: LD_INT 3
66949: PPUSH
66950: CALL 52630 0 2
66954: ST_TO_ADDR
// p := [ ] ;
66955: LD_ADDR_VAR 0 11
66959: PUSH
66960: EMPTY
66961: ST_TO_ADDR
// if sort then
66962: LD_VAR 0 9
66966: IFFALSE 67082
// for i = 1 to 6 - mech do
66968: LD_ADDR_VAR 0 3
66972: PUSH
66973: DOUBLE
66974: LD_INT 1
66976: DEC
66977: ST_TO_ADDR
66978: LD_INT 6
66980: PUSH
66981: LD_VAR 0 7
66985: MINUS
66986: PUSH
66987: FOR_TO
66988: IFFALSE 67080
// begin if i = sort then
66990: LD_VAR 0 3
66994: PUSH
66995: LD_VAR 0 9
66999: EQUAL
67000: IFFALSE 67004
// break ;
67002: GO 67080
// if GetClass ( i ) = 3 then
67004: LD_VAR 0 3
67008: PPUSH
67009: CALL_OW 257
67013: PUSH
67014: LD_INT 3
67016: EQUAL
67017: IFFALSE 67021
// continue ;
67019: GO 66987
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67021: LD_ADDR_VAR 0 11
67025: PUSH
67026: LD_VAR 0 11
67030: PPUSH
67031: LD_VAR 0 11
67035: PUSH
67036: LD_INT 1
67038: PLUS
67039: PPUSH
67040: LD_VAR 0 9
67044: PUSH
67045: LD_VAR 0 3
67049: ARRAY
67050: PPUSH
67051: CALL_OW 2
67055: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67056: LD_ADDR_VAR 0 4
67060: PUSH
67061: LD_VAR 0 4
67065: PUSH
67066: LD_VAR 0 9
67070: PUSH
67071: LD_VAR 0 3
67075: ARRAY
67076: DIFF
67077: ST_TO_ADDR
// end ;
67078: GO 66987
67080: POP
67081: POP
// if p then
67082: LD_VAR 0 11
67086: IFFALSE 67111
// result := Replace ( result , 3 , p ) ;
67088: LD_ADDR_VAR 0 2
67092: PUSH
67093: LD_VAR 0 2
67097: PPUSH
67098: LD_INT 3
67100: PPUSH
67101: LD_VAR 0 11
67105: PPUSH
67106: CALL_OW 1
67110: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
67111: LD_ADDR_VAR 0 4
67115: PUSH
67116: LD_VAR 0 4
67120: PUSH
67121: LD_VAR 0 6
67125: DIFF
67126: ST_TO_ADDR
// if tmp and eng < 4 then
67127: LD_VAR 0 4
67131: PUSH
67132: LD_VAR 0 6
67136: PUSH
67137: LD_INT 4
67139: LESS
67140: AND
67141: IFFALSE 67331
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
67143: LD_ADDR_VAR 0 9
67147: PUSH
67148: LD_VAR 0 4
67152: PUSH
67153: LD_VAR 0 7
67157: PUSH
67158: LD_VAR 0 6
67162: UNION
67163: DIFF
67164: PPUSH
67165: LD_INT 2
67167: PPUSH
67168: CALL 52630 0 2
67172: ST_TO_ADDR
// p := [ ] ;
67173: LD_ADDR_VAR 0 11
67177: PUSH
67178: EMPTY
67179: ST_TO_ADDR
// if sort then
67180: LD_VAR 0 9
67184: IFFALSE 67300
// for i = 1 to 4 - eng do
67186: LD_ADDR_VAR 0 3
67190: PUSH
67191: DOUBLE
67192: LD_INT 1
67194: DEC
67195: ST_TO_ADDR
67196: LD_INT 4
67198: PUSH
67199: LD_VAR 0 6
67203: MINUS
67204: PUSH
67205: FOR_TO
67206: IFFALSE 67298
// begin if i = sort then
67208: LD_VAR 0 3
67212: PUSH
67213: LD_VAR 0 9
67217: EQUAL
67218: IFFALSE 67222
// break ;
67220: GO 67298
// if GetClass ( i ) = 2 then
67222: LD_VAR 0 3
67226: PPUSH
67227: CALL_OW 257
67231: PUSH
67232: LD_INT 2
67234: EQUAL
67235: IFFALSE 67239
// continue ;
67237: GO 67205
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67239: LD_ADDR_VAR 0 11
67243: PUSH
67244: LD_VAR 0 11
67248: PPUSH
67249: LD_VAR 0 11
67253: PUSH
67254: LD_INT 1
67256: PLUS
67257: PPUSH
67258: LD_VAR 0 9
67262: PUSH
67263: LD_VAR 0 3
67267: ARRAY
67268: PPUSH
67269: CALL_OW 2
67273: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67274: LD_ADDR_VAR 0 4
67278: PUSH
67279: LD_VAR 0 4
67283: PUSH
67284: LD_VAR 0 9
67288: PUSH
67289: LD_VAR 0 3
67293: ARRAY
67294: DIFF
67295: ST_TO_ADDR
// end ;
67296: GO 67205
67298: POP
67299: POP
// if p then
67300: LD_VAR 0 11
67304: IFFALSE 67329
// result := Replace ( result , 2 , p ) ;
67306: LD_ADDR_VAR 0 2
67310: PUSH
67311: LD_VAR 0 2
67315: PPUSH
67316: LD_INT 2
67318: PPUSH
67319: LD_VAR 0 11
67323: PPUSH
67324: CALL_OW 1
67328: ST_TO_ADDR
// end else
67329: GO 67375
// for i = eng downto 5 do
67331: LD_ADDR_VAR 0 3
67335: PUSH
67336: DOUBLE
67337: LD_VAR 0 6
67341: INC
67342: ST_TO_ADDR
67343: LD_INT 5
67345: PUSH
67346: FOR_DOWNTO
67347: IFFALSE 67373
// tmp := tmp union eng [ i ] ;
67349: LD_ADDR_VAR 0 4
67353: PUSH
67354: LD_VAR 0 4
67358: PUSH
67359: LD_VAR 0 6
67363: PUSH
67364: LD_VAR 0 3
67368: ARRAY
67369: UNION
67370: ST_TO_ADDR
67371: GO 67346
67373: POP
67374: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
67375: LD_ADDR_VAR 0 2
67379: PUSH
67380: LD_VAR 0 2
67384: PPUSH
67385: LD_INT 1
67387: PPUSH
67388: LD_VAR 0 4
67392: PUSH
67393: LD_VAR 0 5
67397: DIFF
67398: PPUSH
67399: CALL_OW 1
67403: ST_TO_ADDR
// exit ;
67404: GO 67406
// end ; end ;
67406: LD_VAR 0 2
67410: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
67411: LD_INT 0
67413: PPUSH
67414: PPUSH
67415: PPUSH
// if not mc_bases then
67416: LD_EXP 61
67420: NOT
67421: IFFALSE 67425
// exit ;
67423: GO 67567
// for i = 1 to mc_bases do
67425: LD_ADDR_VAR 0 2
67429: PUSH
67430: DOUBLE
67431: LD_INT 1
67433: DEC
67434: ST_TO_ADDR
67435: LD_EXP 61
67439: PUSH
67440: FOR_TO
67441: IFFALSE 67558
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
67443: LD_ADDR_VAR 0 3
67447: PUSH
67448: LD_EXP 61
67452: PUSH
67453: LD_VAR 0 2
67457: ARRAY
67458: PPUSH
67459: LD_INT 21
67461: PUSH
67462: LD_INT 3
67464: PUSH
67465: EMPTY
67466: LIST
67467: LIST
67468: PUSH
67469: LD_INT 3
67471: PUSH
67472: LD_INT 2
67474: PUSH
67475: LD_INT 30
67477: PUSH
67478: LD_INT 29
67480: PUSH
67481: EMPTY
67482: LIST
67483: LIST
67484: PUSH
67485: LD_INT 30
67487: PUSH
67488: LD_INT 30
67490: PUSH
67491: EMPTY
67492: LIST
67493: LIST
67494: PUSH
67495: EMPTY
67496: LIST
67497: LIST
67498: LIST
67499: PUSH
67500: EMPTY
67501: LIST
67502: LIST
67503: PUSH
67504: LD_INT 3
67506: PUSH
67507: LD_INT 24
67509: PUSH
67510: LD_INT 1000
67512: PUSH
67513: EMPTY
67514: LIST
67515: LIST
67516: PUSH
67517: EMPTY
67518: LIST
67519: LIST
67520: PUSH
67521: EMPTY
67522: LIST
67523: LIST
67524: LIST
67525: PPUSH
67526: CALL_OW 72
67530: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
67531: LD_ADDR_EXP 62
67535: PUSH
67536: LD_EXP 62
67540: PPUSH
67541: LD_VAR 0 2
67545: PPUSH
67546: LD_VAR 0 3
67550: PPUSH
67551: CALL_OW 1
67555: ST_TO_ADDR
// end ;
67556: GO 67440
67558: POP
67559: POP
// RaiseSailEvent ( 101 ) ;
67560: LD_INT 101
67562: PPUSH
67563: CALL_OW 427
// end ;
67567: LD_VAR 0 1
67571: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
67572: LD_INT 0
67574: PPUSH
67575: PPUSH
67576: PPUSH
67577: PPUSH
67578: PPUSH
67579: PPUSH
67580: PPUSH
// if not mc_bases then
67581: LD_EXP 61
67585: NOT
67586: IFFALSE 67590
// exit ;
67588: GO 68152
// for i = 1 to mc_bases do
67590: LD_ADDR_VAR 0 2
67594: PUSH
67595: DOUBLE
67596: LD_INT 1
67598: DEC
67599: ST_TO_ADDR
67600: LD_EXP 61
67604: PUSH
67605: FOR_TO
67606: IFFALSE 68143
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
67608: LD_ADDR_VAR 0 5
67612: PUSH
67613: LD_EXP 61
67617: PUSH
67618: LD_VAR 0 2
67622: ARRAY
67623: PUSH
67624: LD_EXP 90
67628: PUSH
67629: LD_VAR 0 2
67633: ARRAY
67634: UNION
67635: PPUSH
67636: LD_INT 21
67638: PUSH
67639: LD_INT 1
67641: PUSH
67642: EMPTY
67643: LIST
67644: LIST
67645: PUSH
67646: LD_INT 1
67648: PUSH
67649: LD_INT 3
67651: PUSH
67652: LD_INT 54
67654: PUSH
67655: EMPTY
67656: LIST
67657: PUSH
67658: EMPTY
67659: LIST
67660: LIST
67661: PUSH
67662: LD_INT 3
67664: PUSH
67665: LD_INT 24
67667: PUSH
67668: LD_INT 1000
67670: PUSH
67671: EMPTY
67672: LIST
67673: LIST
67674: PUSH
67675: EMPTY
67676: LIST
67677: LIST
67678: PUSH
67679: EMPTY
67680: LIST
67681: LIST
67682: LIST
67683: PUSH
67684: EMPTY
67685: LIST
67686: LIST
67687: PPUSH
67688: CALL_OW 72
67692: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
67693: LD_ADDR_VAR 0 6
67697: PUSH
67698: LD_EXP 61
67702: PUSH
67703: LD_VAR 0 2
67707: ARRAY
67708: PPUSH
67709: LD_INT 21
67711: PUSH
67712: LD_INT 1
67714: PUSH
67715: EMPTY
67716: LIST
67717: LIST
67718: PUSH
67719: LD_INT 1
67721: PUSH
67722: LD_INT 3
67724: PUSH
67725: LD_INT 54
67727: PUSH
67728: EMPTY
67729: LIST
67730: PUSH
67731: EMPTY
67732: LIST
67733: LIST
67734: PUSH
67735: LD_INT 3
67737: PUSH
67738: LD_INT 24
67740: PUSH
67741: LD_INT 250
67743: PUSH
67744: EMPTY
67745: LIST
67746: LIST
67747: PUSH
67748: EMPTY
67749: LIST
67750: LIST
67751: PUSH
67752: EMPTY
67753: LIST
67754: LIST
67755: LIST
67756: PUSH
67757: EMPTY
67758: LIST
67759: LIST
67760: PPUSH
67761: CALL_OW 72
67765: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
67766: LD_ADDR_VAR 0 7
67770: PUSH
67771: LD_VAR 0 5
67775: PUSH
67776: LD_VAR 0 6
67780: DIFF
67781: ST_TO_ADDR
// if not need_heal_1 then
67782: LD_VAR 0 6
67786: NOT
67787: IFFALSE 67820
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
67789: LD_ADDR_EXP 64
67793: PUSH
67794: LD_EXP 64
67798: PPUSH
67799: LD_VAR 0 2
67803: PUSH
67804: LD_INT 1
67806: PUSH
67807: EMPTY
67808: LIST
67809: LIST
67810: PPUSH
67811: EMPTY
67812: PPUSH
67813: CALL 21397 0 3
67817: ST_TO_ADDR
67818: GO 67890
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
67820: LD_ADDR_EXP 64
67824: PUSH
67825: LD_EXP 64
67829: PPUSH
67830: LD_VAR 0 2
67834: PUSH
67835: LD_INT 1
67837: PUSH
67838: EMPTY
67839: LIST
67840: LIST
67841: PPUSH
67842: LD_EXP 64
67846: PUSH
67847: LD_VAR 0 2
67851: ARRAY
67852: PUSH
67853: LD_INT 1
67855: ARRAY
67856: PPUSH
67857: LD_INT 3
67859: PUSH
67860: LD_INT 24
67862: PUSH
67863: LD_INT 1000
67865: PUSH
67866: EMPTY
67867: LIST
67868: LIST
67869: PUSH
67870: EMPTY
67871: LIST
67872: LIST
67873: PPUSH
67874: CALL_OW 72
67878: PUSH
67879: LD_VAR 0 6
67883: UNION
67884: PPUSH
67885: CALL 21397 0 3
67889: ST_TO_ADDR
// if not need_heal_2 then
67890: LD_VAR 0 7
67894: NOT
67895: IFFALSE 67928
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
67897: LD_ADDR_EXP 64
67901: PUSH
67902: LD_EXP 64
67906: PPUSH
67907: LD_VAR 0 2
67911: PUSH
67912: LD_INT 2
67914: PUSH
67915: EMPTY
67916: LIST
67917: LIST
67918: PPUSH
67919: EMPTY
67920: PPUSH
67921: CALL 21397 0 3
67925: ST_TO_ADDR
67926: GO 67960
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
67928: LD_ADDR_EXP 64
67932: PUSH
67933: LD_EXP 64
67937: PPUSH
67938: LD_VAR 0 2
67942: PUSH
67943: LD_INT 2
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: PPUSH
67950: LD_VAR 0 7
67954: PPUSH
67955: CALL 21397 0 3
67959: ST_TO_ADDR
// if need_heal_2 then
67960: LD_VAR 0 7
67964: IFFALSE 68125
// for j in need_heal_2 do
67966: LD_ADDR_VAR 0 3
67970: PUSH
67971: LD_VAR 0 7
67975: PUSH
67976: FOR_IN
67977: IFFALSE 68123
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67979: LD_ADDR_VAR 0 5
67983: PUSH
67984: LD_EXP 61
67988: PUSH
67989: LD_VAR 0 2
67993: ARRAY
67994: PPUSH
67995: LD_INT 2
67997: PUSH
67998: LD_INT 30
68000: PUSH
68001: LD_INT 6
68003: PUSH
68004: EMPTY
68005: LIST
68006: LIST
68007: PUSH
68008: LD_INT 30
68010: PUSH
68011: LD_INT 7
68013: PUSH
68014: EMPTY
68015: LIST
68016: LIST
68017: PUSH
68018: LD_INT 30
68020: PUSH
68021: LD_INT 8
68023: PUSH
68024: EMPTY
68025: LIST
68026: LIST
68027: PUSH
68028: LD_INT 30
68030: PUSH
68031: LD_INT 0
68033: PUSH
68034: EMPTY
68035: LIST
68036: LIST
68037: PUSH
68038: LD_INT 30
68040: PUSH
68041: LD_INT 1
68043: PUSH
68044: EMPTY
68045: LIST
68046: LIST
68047: PUSH
68048: EMPTY
68049: LIST
68050: LIST
68051: LIST
68052: LIST
68053: LIST
68054: LIST
68055: PPUSH
68056: CALL_OW 72
68060: ST_TO_ADDR
// if tmp then
68061: LD_VAR 0 5
68065: IFFALSE 68121
// begin k := NearestUnitToUnit ( tmp , j ) ;
68067: LD_ADDR_VAR 0 4
68071: PUSH
68072: LD_VAR 0 5
68076: PPUSH
68077: LD_VAR 0 3
68081: PPUSH
68082: CALL_OW 74
68086: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
68087: LD_VAR 0 3
68091: PPUSH
68092: LD_VAR 0 4
68096: PPUSH
68097: CALL_OW 296
68101: PUSH
68102: LD_INT 5
68104: GREATER
68105: IFFALSE 68121
// ComMoveToNearbyEntrance ( j , k ) ;
68107: LD_VAR 0 3
68111: PPUSH
68112: LD_VAR 0 4
68116: PPUSH
68117: CALL 55003 0 2
// end ; end ;
68121: GO 67976
68123: POP
68124: POP
// if not need_heal_1 and not need_heal_2 then
68125: LD_VAR 0 6
68129: NOT
68130: PUSH
68131: LD_VAR 0 7
68135: NOT
68136: AND
68137: IFFALSE 68141
// continue ;
68139: GO 67605
// end ;
68141: GO 67605
68143: POP
68144: POP
// RaiseSailEvent ( 102 ) ;
68145: LD_INT 102
68147: PPUSH
68148: CALL_OW 427
// end ;
68152: LD_VAR 0 1
68156: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
68157: LD_INT 0
68159: PPUSH
68160: PPUSH
68161: PPUSH
68162: PPUSH
68163: PPUSH
68164: PPUSH
68165: PPUSH
68166: PPUSH
// if not mc_bases then
68167: LD_EXP 61
68171: NOT
68172: IFFALSE 68176
// exit ;
68174: GO 69087
// for i = 1 to mc_bases do
68176: LD_ADDR_VAR 0 2
68180: PUSH
68181: DOUBLE
68182: LD_INT 1
68184: DEC
68185: ST_TO_ADDR
68186: LD_EXP 61
68190: PUSH
68191: FOR_TO
68192: IFFALSE 69085
// begin if not mc_building_need_repair [ i ] then
68194: LD_EXP 62
68198: PUSH
68199: LD_VAR 0 2
68203: ARRAY
68204: NOT
68205: IFFALSE 68390
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
68207: LD_ADDR_VAR 0 6
68211: PUSH
68212: LD_EXP 80
68216: PUSH
68217: LD_VAR 0 2
68221: ARRAY
68222: PPUSH
68223: LD_INT 3
68225: PUSH
68226: LD_INT 24
68228: PUSH
68229: LD_INT 1000
68231: PUSH
68232: EMPTY
68233: LIST
68234: LIST
68235: PUSH
68236: EMPTY
68237: LIST
68238: LIST
68239: PUSH
68240: LD_INT 2
68242: PUSH
68243: LD_INT 34
68245: PUSH
68246: LD_INT 13
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: PUSH
68253: LD_INT 34
68255: PUSH
68256: LD_INT 52
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: PUSH
68263: LD_INT 34
68265: PUSH
68266: LD_INT 88
68268: PUSH
68269: EMPTY
68270: LIST
68271: LIST
68272: PUSH
68273: EMPTY
68274: LIST
68275: LIST
68276: LIST
68277: LIST
68278: PUSH
68279: EMPTY
68280: LIST
68281: LIST
68282: PPUSH
68283: CALL_OW 72
68287: ST_TO_ADDR
// if cranes then
68288: LD_VAR 0 6
68292: IFFALSE 68354
// for j in cranes do
68294: LD_ADDR_VAR 0 3
68298: PUSH
68299: LD_VAR 0 6
68303: PUSH
68304: FOR_IN
68305: IFFALSE 68352
// if not IsInArea ( j , mc_parking [ i ] ) then
68307: LD_VAR 0 3
68311: PPUSH
68312: LD_EXP 85
68316: PUSH
68317: LD_VAR 0 2
68321: ARRAY
68322: PPUSH
68323: CALL_OW 308
68327: NOT
68328: IFFALSE 68350
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68330: LD_VAR 0 3
68334: PPUSH
68335: LD_EXP 85
68339: PUSH
68340: LD_VAR 0 2
68344: ARRAY
68345: PPUSH
68346: CALL_OW 113
68350: GO 68304
68352: POP
68353: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
68354: LD_ADDR_EXP 63
68358: PUSH
68359: LD_EXP 63
68363: PPUSH
68364: LD_VAR 0 2
68368: PPUSH
68369: EMPTY
68370: PPUSH
68371: CALL_OW 1
68375: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
68376: LD_VAR 0 2
68380: PPUSH
68381: LD_INT 101
68383: PPUSH
68384: CALL 63230 0 2
// continue ;
68388: GO 68191
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
68390: LD_ADDR_EXP 67
68394: PUSH
68395: LD_EXP 67
68399: PPUSH
68400: LD_VAR 0 2
68404: PPUSH
68405: EMPTY
68406: PPUSH
68407: CALL_OW 1
68411: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
68412: LD_VAR 0 2
68416: PPUSH
68417: LD_INT 103
68419: PPUSH
68420: CALL 63230 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
68424: LD_ADDR_VAR 0 5
68428: PUSH
68429: LD_EXP 61
68433: PUSH
68434: LD_VAR 0 2
68438: ARRAY
68439: PUSH
68440: LD_EXP 90
68444: PUSH
68445: LD_VAR 0 2
68449: ARRAY
68450: UNION
68451: PPUSH
68452: LD_INT 2
68454: PUSH
68455: LD_INT 25
68457: PUSH
68458: LD_INT 2
68460: PUSH
68461: EMPTY
68462: LIST
68463: LIST
68464: PUSH
68465: LD_INT 25
68467: PUSH
68468: LD_INT 16
68470: PUSH
68471: EMPTY
68472: LIST
68473: LIST
68474: PUSH
68475: EMPTY
68476: LIST
68477: LIST
68478: LIST
68479: PUSH
68480: EMPTY
68481: LIST
68482: PPUSH
68483: CALL_OW 72
68487: ST_TO_ADDR
// if mc_need_heal [ i ] then
68488: LD_EXP 64
68492: PUSH
68493: LD_VAR 0 2
68497: ARRAY
68498: IFFALSE 68542
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
68500: LD_ADDR_VAR 0 5
68504: PUSH
68505: LD_VAR 0 5
68509: PUSH
68510: LD_EXP 64
68514: PUSH
68515: LD_VAR 0 2
68519: ARRAY
68520: PUSH
68521: LD_INT 1
68523: ARRAY
68524: PUSH
68525: LD_EXP 64
68529: PUSH
68530: LD_VAR 0 2
68534: ARRAY
68535: PUSH
68536: LD_INT 2
68538: ARRAY
68539: UNION
68540: DIFF
68541: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
68542: LD_ADDR_VAR 0 6
68546: PUSH
68547: LD_EXP 80
68551: PUSH
68552: LD_VAR 0 2
68556: ARRAY
68557: PPUSH
68558: LD_INT 2
68560: PUSH
68561: LD_INT 34
68563: PUSH
68564: LD_INT 13
68566: PUSH
68567: EMPTY
68568: LIST
68569: LIST
68570: PUSH
68571: LD_INT 34
68573: PUSH
68574: LD_INT 52
68576: PUSH
68577: EMPTY
68578: LIST
68579: LIST
68580: PUSH
68581: LD_INT 34
68583: PUSH
68584: LD_INT 88
68586: PUSH
68587: EMPTY
68588: LIST
68589: LIST
68590: PUSH
68591: EMPTY
68592: LIST
68593: LIST
68594: LIST
68595: LIST
68596: PPUSH
68597: CALL_OW 72
68601: ST_TO_ADDR
// if cranes then
68602: LD_VAR 0 6
68606: IFFALSE 68774
// begin for j in cranes do
68608: LD_ADDR_VAR 0 3
68612: PUSH
68613: LD_VAR 0 6
68617: PUSH
68618: FOR_IN
68619: IFFALSE 68772
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
68621: LD_VAR 0 3
68625: PPUSH
68626: CALL_OW 256
68630: PUSH
68631: LD_INT 1000
68633: EQUAL
68634: PUSH
68635: LD_VAR 0 3
68639: PPUSH
68640: CALL_OW 314
68644: NOT
68645: AND
68646: IFFALSE 68712
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
68648: LD_ADDR_VAR 0 8
68652: PUSH
68653: LD_EXP 62
68657: PUSH
68658: LD_VAR 0 2
68662: ARRAY
68663: PPUSH
68664: LD_VAR 0 3
68668: PPUSH
68669: CALL_OW 74
68673: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
68674: LD_VAR 0 8
68678: PPUSH
68679: LD_INT 16
68681: PPUSH
68682: CALL 24362 0 2
68686: PUSH
68687: LD_INT 4
68689: ARRAY
68690: PUSH
68691: LD_INT 10
68693: LESS
68694: IFFALSE 68710
// ComRepairBuilding ( j , to_repair ) ;
68696: LD_VAR 0 3
68700: PPUSH
68701: LD_VAR 0 8
68705: PPUSH
68706: CALL_OW 130
// end else
68710: GO 68770
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
68712: LD_VAR 0 3
68716: PPUSH
68717: CALL_OW 256
68721: PUSH
68722: LD_INT 500
68724: LESS
68725: PUSH
68726: LD_VAR 0 3
68730: PPUSH
68731: LD_EXP 85
68735: PUSH
68736: LD_VAR 0 2
68740: ARRAY
68741: PPUSH
68742: CALL_OW 308
68746: NOT
68747: AND
68748: IFFALSE 68770
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68750: LD_VAR 0 3
68754: PPUSH
68755: LD_EXP 85
68759: PUSH
68760: LD_VAR 0 2
68764: ARRAY
68765: PPUSH
68766: CALL_OW 113
// end ;
68770: GO 68618
68772: POP
68773: POP
// end ; if tmp > 3 then
68774: LD_VAR 0 5
68778: PUSH
68779: LD_INT 3
68781: GREATER
68782: IFFALSE 68802
// tmp := ShrinkArray ( tmp , 4 ) ;
68784: LD_ADDR_VAR 0 5
68788: PUSH
68789: LD_VAR 0 5
68793: PPUSH
68794: LD_INT 4
68796: PPUSH
68797: CALL 54441 0 2
68801: ST_TO_ADDR
// if not tmp then
68802: LD_VAR 0 5
68806: NOT
68807: IFFALSE 68811
// continue ;
68809: GO 68191
// for j in tmp do
68811: LD_ADDR_VAR 0 3
68815: PUSH
68816: LD_VAR 0 5
68820: PUSH
68821: FOR_IN
68822: IFFALSE 69081
// begin if IsInUnit ( j ) then
68824: LD_VAR 0 3
68828: PPUSH
68829: CALL_OW 310
68833: IFFALSE 68844
// ComExitBuilding ( j ) ;
68835: LD_VAR 0 3
68839: PPUSH
68840: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
68844: LD_VAR 0 3
68848: PUSH
68849: LD_EXP 63
68853: PUSH
68854: LD_VAR 0 2
68858: ARRAY
68859: IN
68860: NOT
68861: IFFALSE 68919
// begin SetTag ( j , 101 ) ;
68863: LD_VAR 0 3
68867: PPUSH
68868: LD_INT 101
68870: PPUSH
68871: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
68875: LD_ADDR_EXP 63
68879: PUSH
68880: LD_EXP 63
68884: PPUSH
68885: LD_VAR 0 2
68889: PUSH
68890: LD_EXP 63
68894: PUSH
68895: LD_VAR 0 2
68899: ARRAY
68900: PUSH
68901: LD_INT 1
68903: PLUS
68904: PUSH
68905: EMPTY
68906: LIST
68907: LIST
68908: PPUSH
68909: LD_VAR 0 3
68913: PPUSH
68914: CALL 21397 0 3
68918: ST_TO_ADDR
// end ; wait ( 1 ) ;
68919: LD_INT 1
68921: PPUSH
68922: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
68926: LD_ADDR_VAR 0 7
68930: PUSH
68931: LD_EXP 62
68935: PUSH
68936: LD_VAR 0 2
68940: ARRAY
68941: ST_TO_ADDR
// if mc_scan [ i ] then
68942: LD_EXP 84
68946: PUSH
68947: LD_VAR 0 2
68951: ARRAY
68952: IFFALSE 69014
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
68954: LD_ADDR_VAR 0 7
68958: PUSH
68959: LD_EXP 62
68963: PUSH
68964: LD_VAR 0 2
68968: ARRAY
68969: PPUSH
68970: LD_INT 3
68972: PUSH
68973: LD_INT 30
68975: PUSH
68976: LD_INT 32
68978: PUSH
68979: EMPTY
68980: LIST
68981: LIST
68982: PUSH
68983: LD_INT 30
68985: PUSH
68986: LD_INT 33
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PUSH
68993: LD_INT 30
68995: PUSH
68996: LD_INT 31
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: PUSH
69003: EMPTY
69004: LIST
69005: LIST
69006: LIST
69007: LIST
69008: PPUSH
69009: CALL_OW 72
69013: ST_TO_ADDR
// if not to_repair_tmp then
69014: LD_VAR 0 7
69018: NOT
69019: IFFALSE 69023
// continue ;
69021: GO 68821
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
69023: LD_ADDR_VAR 0 8
69027: PUSH
69028: LD_VAR 0 7
69032: PPUSH
69033: LD_VAR 0 3
69037: PPUSH
69038: CALL_OW 74
69042: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
69043: LD_VAR 0 8
69047: PPUSH
69048: LD_INT 16
69050: PPUSH
69051: CALL 24362 0 2
69055: PUSH
69056: LD_INT 4
69058: ARRAY
69059: PUSH
69060: LD_INT 14
69062: LESS
69063: IFFALSE 69079
// ComRepairBuilding ( j , to_repair ) ;
69065: LD_VAR 0 3
69069: PPUSH
69070: LD_VAR 0 8
69074: PPUSH
69075: CALL_OW 130
// end ;
69079: GO 68821
69081: POP
69082: POP
// end ;
69083: GO 68191
69085: POP
69086: POP
// end ;
69087: LD_VAR 0 1
69091: RET
// export function MC_Heal ; var i , j , tmp ; begin
69092: LD_INT 0
69094: PPUSH
69095: PPUSH
69096: PPUSH
69097: PPUSH
// if not mc_bases then
69098: LD_EXP 61
69102: NOT
69103: IFFALSE 69107
// exit ;
69105: GO 69509
// for i = 1 to mc_bases do
69107: LD_ADDR_VAR 0 2
69111: PUSH
69112: DOUBLE
69113: LD_INT 1
69115: DEC
69116: ST_TO_ADDR
69117: LD_EXP 61
69121: PUSH
69122: FOR_TO
69123: IFFALSE 69507
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
69125: LD_EXP 64
69129: PUSH
69130: LD_VAR 0 2
69134: ARRAY
69135: PUSH
69136: LD_INT 1
69138: ARRAY
69139: NOT
69140: PUSH
69141: LD_EXP 64
69145: PUSH
69146: LD_VAR 0 2
69150: ARRAY
69151: PUSH
69152: LD_INT 2
69154: ARRAY
69155: NOT
69156: AND
69157: IFFALSE 69195
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
69159: LD_ADDR_EXP 65
69163: PUSH
69164: LD_EXP 65
69168: PPUSH
69169: LD_VAR 0 2
69173: PPUSH
69174: EMPTY
69175: PPUSH
69176: CALL_OW 1
69180: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
69181: LD_VAR 0 2
69185: PPUSH
69186: LD_INT 102
69188: PPUSH
69189: CALL 63230 0 2
// continue ;
69193: GO 69122
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
69195: LD_ADDR_VAR 0 4
69199: PUSH
69200: LD_EXP 61
69204: PUSH
69205: LD_VAR 0 2
69209: ARRAY
69210: PPUSH
69211: LD_INT 25
69213: PUSH
69214: LD_INT 4
69216: PUSH
69217: EMPTY
69218: LIST
69219: LIST
69220: PPUSH
69221: CALL_OW 72
69225: ST_TO_ADDR
// if not tmp then
69226: LD_VAR 0 4
69230: NOT
69231: IFFALSE 69235
// continue ;
69233: GO 69122
// if mc_taming [ i ] then
69235: LD_EXP 92
69239: PUSH
69240: LD_VAR 0 2
69244: ARRAY
69245: IFFALSE 69269
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
69247: LD_ADDR_EXP 92
69251: PUSH
69252: LD_EXP 92
69256: PPUSH
69257: LD_VAR 0 2
69261: PPUSH
69262: EMPTY
69263: PPUSH
69264: CALL_OW 1
69268: ST_TO_ADDR
// for j in tmp do
69269: LD_ADDR_VAR 0 3
69273: PUSH
69274: LD_VAR 0 4
69278: PUSH
69279: FOR_IN
69280: IFFALSE 69503
// begin if IsInUnit ( j ) then
69282: LD_VAR 0 3
69286: PPUSH
69287: CALL_OW 310
69291: IFFALSE 69302
// ComExitBuilding ( j ) ;
69293: LD_VAR 0 3
69297: PPUSH
69298: CALL_OW 122
// if not j in mc_healers [ i ] then
69302: LD_VAR 0 3
69306: PUSH
69307: LD_EXP 65
69311: PUSH
69312: LD_VAR 0 2
69316: ARRAY
69317: IN
69318: NOT
69319: IFFALSE 69365
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
69321: LD_ADDR_EXP 65
69325: PUSH
69326: LD_EXP 65
69330: PPUSH
69331: LD_VAR 0 2
69335: PUSH
69336: LD_EXP 65
69340: PUSH
69341: LD_VAR 0 2
69345: ARRAY
69346: PUSH
69347: LD_INT 1
69349: PLUS
69350: PUSH
69351: EMPTY
69352: LIST
69353: LIST
69354: PPUSH
69355: LD_VAR 0 3
69359: PPUSH
69360: CALL 21397 0 3
69364: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
69365: LD_VAR 0 3
69369: PPUSH
69370: CALL_OW 110
69374: PUSH
69375: LD_INT 102
69377: NONEQUAL
69378: IFFALSE 69392
// SetTag ( j , 102 ) ;
69380: LD_VAR 0 3
69384: PPUSH
69385: LD_INT 102
69387: PPUSH
69388: CALL_OW 109
// Wait ( 3 ) ;
69392: LD_INT 3
69394: PPUSH
69395: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
69399: LD_EXP 64
69403: PUSH
69404: LD_VAR 0 2
69408: ARRAY
69409: PUSH
69410: LD_INT 1
69412: ARRAY
69413: IFFALSE 69445
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
69415: LD_VAR 0 3
69419: PPUSH
69420: LD_EXP 64
69424: PUSH
69425: LD_VAR 0 2
69429: ARRAY
69430: PUSH
69431: LD_INT 1
69433: ARRAY
69434: PUSH
69435: LD_INT 1
69437: ARRAY
69438: PPUSH
69439: CALL_OW 128
69443: GO 69501
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
69445: LD_VAR 0 3
69449: PPUSH
69450: CALL_OW 314
69454: NOT
69455: PUSH
69456: LD_EXP 64
69460: PUSH
69461: LD_VAR 0 2
69465: ARRAY
69466: PUSH
69467: LD_INT 2
69469: ARRAY
69470: AND
69471: IFFALSE 69501
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
69473: LD_VAR 0 3
69477: PPUSH
69478: LD_EXP 64
69482: PUSH
69483: LD_VAR 0 2
69487: ARRAY
69488: PUSH
69489: LD_INT 2
69491: ARRAY
69492: PUSH
69493: LD_INT 1
69495: ARRAY
69496: PPUSH
69497: CALL_OW 128
// end ;
69501: GO 69279
69503: POP
69504: POP
// end ;
69505: GO 69122
69507: POP
69508: POP
// end ;
69509: LD_VAR 0 1
69513: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
69514: LD_INT 0
69516: PPUSH
69517: PPUSH
69518: PPUSH
69519: PPUSH
69520: PPUSH
69521: PPUSH
// if not mc_bases then
69522: LD_EXP 61
69526: NOT
69527: IFFALSE 69531
// exit ;
69529: GO 70694
// for i = 1 to mc_bases do
69531: LD_ADDR_VAR 0 2
69535: PUSH
69536: DOUBLE
69537: LD_INT 1
69539: DEC
69540: ST_TO_ADDR
69541: LD_EXP 61
69545: PUSH
69546: FOR_TO
69547: IFFALSE 70692
// begin if mc_scan [ i ] then
69549: LD_EXP 84
69553: PUSH
69554: LD_VAR 0 2
69558: ARRAY
69559: IFFALSE 69563
// continue ;
69561: GO 69546
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
69563: LD_EXP 66
69567: PUSH
69568: LD_VAR 0 2
69572: ARRAY
69573: NOT
69574: PUSH
69575: LD_EXP 68
69579: PUSH
69580: LD_VAR 0 2
69584: ARRAY
69585: NOT
69586: AND
69587: PUSH
69588: LD_EXP 67
69592: PUSH
69593: LD_VAR 0 2
69597: ARRAY
69598: AND
69599: IFFALSE 69637
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
69601: LD_ADDR_EXP 67
69605: PUSH
69606: LD_EXP 67
69610: PPUSH
69611: LD_VAR 0 2
69615: PPUSH
69616: EMPTY
69617: PPUSH
69618: CALL_OW 1
69622: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
69623: LD_VAR 0 2
69627: PPUSH
69628: LD_INT 103
69630: PPUSH
69631: CALL 63230 0 2
// continue ;
69635: GO 69546
// end ; if mc_construct_list [ i ] then
69637: LD_EXP 68
69641: PUSH
69642: LD_VAR 0 2
69646: ARRAY
69647: IFFALSE 69867
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
69649: LD_ADDR_VAR 0 5
69653: PUSH
69654: LD_EXP 61
69658: PUSH
69659: LD_VAR 0 2
69663: ARRAY
69664: PPUSH
69665: LD_INT 25
69667: PUSH
69668: LD_INT 2
69670: PUSH
69671: EMPTY
69672: LIST
69673: LIST
69674: PPUSH
69675: CALL_OW 72
69679: PUSH
69680: LD_EXP 63
69684: PUSH
69685: LD_VAR 0 2
69689: ARRAY
69690: DIFF
69691: ST_TO_ADDR
// if not tmp then
69692: LD_VAR 0 5
69696: NOT
69697: IFFALSE 69701
// continue ;
69699: GO 69546
// for j in tmp do
69701: LD_ADDR_VAR 0 3
69705: PUSH
69706: LD_VAR 0 5
69710: PUSH
69711: FOR_IN
69712: IFFALSE 69863
// begin if not mc_builders [ i ] then
69714: LD_EXP 67
69718: PUSH
69719: LD_VAR 0 2
69723: ARRAY
69724: NOT
69725: IFFALSE 69783
// begin SetTag ( j , 103 ) ;
69727: LD_VAR 0 3
69731: PPUSH
69732: LD_INT 103
69734: PPUSH
69735: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
69739: LD_ADDR_EXP 67
69743: PUSH
69744: LD_EXP 67
69748: PPUSH
69749: LD_VAR 0 2
69753: PUSH
69754: LD_EXP 67
69758: PUSH
69759: LD_VAR 0 2
69763: ARRAY
69764: PUSH
69765: LD_INT 1
69767: PLUS
69768: PUSH
69769: EMPTY
69770: LIST
69771: LIST
69772: PPUSH
69773: LD_VAR 0 3
69777: PPUSH
69778: CALL 21397 0 3
69782: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
69783: LD_VAR 0 3
69787: PPUSH
69788: CALL_OW 310
69792: IFFALSE 69803
// ComExitBuilding ( j ) ;
69794: LD_VAR 0 3
69798: PPUSH
69799: CALL_OW 122
// wait ( 3 ) ;
69803: LD_INT 3
69805: PPUSH
69806: CALL_OW 67
// if not mc_construct_list [ i ] then
69810: LD_EXP 68
69814: PUSH
69815: LD_VAR 0 2
69819: ARRAY
69820: NOT
69821: IFFALSE 69825
// break ;
69823: GO 69863
// if not HasTask ( j ) then
69825: LD_VAR 0 3
69829: PPUSH
69830: CALL_OW 314
69834: NOT
69835: IFFALSE 69861
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
69837: LD_VAR 0 3
69841: PPUSH
69842: LD_EXP 68
69846: PUSH
69847: LD_VAR 0 2
69851: ARRAY
69852: PUSH
69853: LD_INT 1
69855: ARRAY
69856: PPUSH
69857: CALL 24635 0 2
// end ;
69861: GO 69711
69863: POP
69864: POP
// end else
69865: GO 70690
// if mc_build_list [ i ] then
69867: LD_EXP 66
69871: PUSH
69872: LD_VAR 0 2
69876: ARRAY
69877: IFFALSE 70690
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
69879: LD_EXP 66
69883: PUSH
69884: LD_VAR 0 2
69888: ARRAY
69889: PUSH
69890: LD_INT 1
69892: ARRAY
69893: PUSH
69894: LD_INT 1
69896: ARRAY
69897: PPUSH
69898: CALL 24459 0 1
69902: PUSH
69903: LD_EXP 61
69907: PUSH
69908: LD_VAR 0 2
69912: ARRAY
69913: PPUSH
69914: LD_INT 2
69916: PUSH
69917: LD_INT 30
69919: PUSH
69920: LD_INT 2
69922: PUSH
69923: EMPTY
69924: LIST
69925: LIST
69926: PUSH
69927: LD_INT 30
69929: PUSH
69930: LD_INT 3
69932: PUSH
69933: EMPTY
69934: LIST
69935: LIST
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: LIST
69941: PPUSH
69942: CALL_OW 72
69946: NOT
69947: AND
69948: IFFALSE 70053
// begin for j = 1 to mc_build_list [ i ] do
69950: LD_ADDR_VAR 0 3
69954: PUSH
69955: DOUBLE
69956: LD_INT 1
69958: DEC
69959: ST_TO_ADDR
69960: LD_EXP 66
69964: PUSH
69965: LD_VAR 0 2
69969: ARRAY
69970: PUSH
69971: FOR_TO
69972: IFFALSE 70051
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
69974: LD_EXP 66
69978: PUSH
69979: LD_VAR 0 2
69983: ARRAY
69984: PUSH
69985: LD_VAR 0 3
69989: ARRAY
69990: PUSH
69991: LD_INT 1
69993: ARRAY
69994: PUSH
69995: LD_INT 2
69997: EQUAL
69998: IFFALSE 70049
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
70000: LD_ADDR_EXP 66
70004: PUSH
70005: LD_EXP 66
70009: PPUSH
70010: LD_VAR 0 2
70014: PPUSH
70015: LD_EXP 66
70019: PUSH
70020: LD_VAR 0 2
70024: ARRAY
70025: PPUSH
70026: LD_VAR 0 3
70030: PPUSH
70031: LD_INT 1
70033: PPUSH
70034: LD_INT 0
70036: PPUSH
70037: CALL 20815 0 4
70041: PPUSH
70042: CALL_OW 1
70046: ST_TO_ADDR
// break ;
70047: GO 70051
// end ;
70049: GO 69971
70051: POP
70052: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70053: LD_ADDR_VAR 0 6
70057: PUSH
70058: LD_EXP 61
70062: PUSH
70063: LD_VAR 0 2
70067: ARRAY
70068: PPUSH
70069: LD_INT 2
70071: PUSH
70072: LD_INT 30
70074: PUSH
70075: LD_INT 0
70077: PUSH
70078: EMPTY
70079: LIST
70080: LIST
70081: PUSH
70082: LD_INT 30
70084: PUSH
70085: LD_INT 1
70087: PUSH
70088: EMPTY
70089: LIST
70090: LIST
70091: PUSH
70092: EMPTY
70093: LIST
70094: LIST
70095: LIST
70096: PPUSH
70097: CALL_OW 72
70101: ST_TO_ADDR
// for k := 1 to depot do
70102: LD_ADDR_VAR 0 4
70106: PUSH
70107: DOUBLE
70108: LD_INT 1
70110: DEC
70111: ST_TO_ADDR
70112: LD_VAR 0 6
70116: PUSH
70117: FOR_TO
70118: IFFALSE 70688
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
70120: LD_EXP 66
70124: PUSH
70125: LD_VAR 0 2
70129: ARRAY
70130: PUSH
70131: LD_INT 1
70133: ARRAY
70134: PUSH
70135: LD_INT 1
70137: ARRAY
70138: PUSH
70139: LD_INT 0
70141: EQUAL
70142: PUSH
70143: LD_VAR 0 6
70147: PUSH
70148: LD_VAR 0 4
70152: ARRAY
70153: PPUSH
70154: LD_EXP 66
70158: PUSH
70159: LD_VAR 0 2
70163: ARRAY
70164: PUSH
70165: LD_INT 1
70167: ARRAY
70168: PUSH
70169: LD_INT 1
70171: ARRAY
70172: PPUSH
70173: LD_EXP 66
70177: PUSH
70178: LD_VAR 0 2
70182: ARRAY
70183: PUSH
70184: LD_INT 1
70186: ARRAY
70187: PUSH
70188: LD_INT 2
70190: ARRAY
70191: PPUSH
70192: LD_EXP 66
70196: PUSH
70197: LD_VAR 0 2
70201: ARRAY
70202: PUSH
70203: LD_INT 1
70205: ARRAY
70206: PUSH
70207: LD_INT 3
70209: ARRAY
70210: PPUSH
70211: LD_EXP 66
70215: PUSH
70216: LD_VAR 0 2
70220: ARRAY
70221: PUSH
70222: LD_INT 1
70224: ARRAY
70225: PUSH
70226: LD_INT 4
70228: ARRAY
70229: PPUSH
70230: CALL 29871 0 5
70234: OR
70235: IFFALSE 70516
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
70237: LD_ADDR_VAR 0 5
70241: PUSH
70242: LD_EXP 61
70246: PUSH
70247: LD_VAR 0 2
70251: ARRAY
70252: PPUSH
70253: LD_INT 25
70255: PUSH
70256: LD_INT 2
70258: PUSH
70259: EMPTY
70260: LIST
70261: LIST
70262: PPUSH
70263: CALL_OW 72
70267: PUSH
70268: LD_EXP 63
70272: PUSH
70273: LD_VAR 0 2
70277: ARRAY
70278: DIFF
70279: ST_TO_ADDR
// if not tmp then
70280: LD_VAR 0 5
70284: NOT
70285: IFFALSE 70289
// continue ;
70287: GO 70117
// for j in tmp do
70289: LD_ADDR_VAR 0 3
70293: PUSH
70294: LD_VAR 0 5
70298: PUSH
70299: FOR_IN
70300: IFFALSE 70512
// begin if not mc_builders [ i ] then
70302: LD_EXP 67
70306: PUSH
70307: LD_VAR 0 2
70311: ARRAY
70312: NOT
70313: IFFALSE 70371
// begin SetTag ( j , 103 ) ;
70315: LD_VAR 0 3
70319: PPUSH
70320: LD_INT 103
70322: PPUSH
70323: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
70327: LD_ADDR_EXP 67
70331: PUSH
70332: LD_EXP 67
70336: PPUSH
70337: LD_VAR 0 2
70341: PUSH
70342: LD_EXP 67
70346: PUSH
70347: LD_VAR 0 2
70351: ARRAY
70352: PUSH
70353: LD_INT 1
70355: PLUS
70356: PUSH
70357: EMPTY
70358: LIST
70359: LIST
70360: PPUSH
70361: LD_VAR 0 3
70365: PPUSH
70366: CALL 21397 0 3
70370: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
70371: LD_VAR 0 3
70375: PPUSH
70376: CALL_OW 310
70380: IFFALSE 70391
// ComExitBuilding ( j ) ;
70382: LD_VAR 0 3
70386: PPUSH
70387: CALL_OW 122
// wait ( 3 ) ;
70391: LD_INT 3
70393: PPUSH
70394: CALL_OW 67
// if not mc_build_list [ i ] then
70398: LD_EXP 66
70402: PUSH
70403: LD_VAR 0 2
70407: ARRAY
70408: NOT
70409: IFFALSE 70413
// break ;
70411: GO 70512
// if not HasTask ( j ) then
70413: LD_VAR 0 3
70417: PPUSH
70418: CALL_OW 314
70422: NOT
70423: IFFALSE 70510
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
70425: LD_VAR 0 3
70429: PPUSH
70430: LD_EXP 66
70434: PUSH
70435: LD_VAR 0 2
70439: ARRAY
70440: PUSH
70441: LD_INT 1
70443: ARRAY
70444: PUSH
70445: LD_INT 1
70447: ARRAY
70448: PPUSH
70449: LD_EXP 66
70453: PUSH
70454: LD_VAR 0 2
70458: ARRAY
70459: PUSH
70460: LD_INT 1
70462: ARRAY
70463: PUSH
70464: LD_INT 2
70466: ARRAY
70467: PPUSH
70468: LD_EXP 66
70472: PUSH
70473: LD_VAR 0 2
70477: ARRAY
70478: PUSH
70479: LD_INT 1
70481: ARRAY
70482: PUSH
70483: LD_INT 3
70485: ARRAY
70486: PPUSH
70487: LD_EXP 66
70491: PUSH
70492: LD_VAR 0 2
70496: ARRAY
70497: PUSH
70498: LD_INT 1
70500: ARRAY
70501: PUSH
70502: LD_INT 4
70504: ARRAY
70505: PPUSH
70506: CALL_OW 145
// end ;
70510: GO 70299
70512: POP
70513: POP
// end else
70514: GO 70686
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
70516: LD_EXP 61
70520: PUSH
70521: LD_VAR 0 2
70525: ARRAY
70526: PPUSH
70527: LD_EXP 66
70531: PUSH
70532: LD_VAR 0 2
70536: ARRAY
70537: PUSH
70538: LD_INT 1
70540: ARRAY
70541: PUSH
70542: LD_INT 1
70544: ARRAY
70545: PPUSH
70546: LD_EXP 66
70550: PUSH
70551: LD_VAR 0 2
70555: ARRAY
70556: PUSH
70557: LD_INT 1
70559: ARRAY
70560: PUSH
70561: LD_INT 2
70563: ARRAY
70564: PPUSH
70565: LD_EXP 66
70569: PUSH
70570: LD_VAR 0 2
70574: ARRAY
70575: PUSH
70576: LD_INT 1
70578: ARRAY
70579: PUSH
70580: LD_INT 3
70582: ARRAY
70583: PPUSH
70584: LD_EXP 66
70588: PUSH
70589: LD_VAR 0 2
70593: ARRAY
70594: PUSH
70595: LD_INT 1
70597: ARRAY
70598: PUSH
70599: LD_INT 4
70601: ARRAY
70602: PPUSH
70603: LD_EXP 61
70607: PUSH
70608: LD_VAR 0 2
70612: ARRAY
70613: PPUSH
70614: LD_INT 21
70616: PUSH
70617: LD_INT 3
70619: PUSH
70620: EMPTY
70621: LIST
70622: LIST
70623: PPUSH
70624: CALL_OW 72
70628: PPUSH
70629: EMPTY
70630: PPUSH
70631: CALL 28625 0 7
70635: NOT
70636: IFFALSE 70686
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
70638: LD_ADDR_EXP 66
70642: PUSH
70643: LD_EXP 66
70647: PPUSH
70648: LD_VAR 0 2
70652: PPUSH
70653: LD_EXP 66
70657: PUSH
70658: LD_VAR 0 2
70662: ARRAY
70663: PPUSH
70664: LD_INT 1
70666: PPUSH
70667: LD_INT 1
70669: NEG
70670: PPUSH
70671: LD_INT 0
70673: PPUSH
70674: CALL 20815 0 4
70678: PPUSH
70679: CALL_OW 1
70683: ST_TO_ADDR
// continue ;
70684: GO 70117
// end ; end ;
70686: GO 70117
70688: POP
70689: POP
// end ; end ;
70690: GO 69546
70692: POP
70693: POP
// end ;
70694: LD_VAR 0 1
70698: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
70699: LD_INT 0
70701: PPUSH
70702: PPUSH
70703: PPUSH
70704: PPUSH
70705: PPUSH
70706: PPUSH
// if not mc_bases then
70707: LD_EXP 61
70711: NOT
70712: IFFALSE 70716
// exit ;
70714: GO 71143
// for i = 1 to mc_bases do
70716: LD_ADDR_VAR 0 2
70720: PUSH
70721: DOUBLE
70722: LD_INT 1
70724: DEC
70725: ST_TO_ADDR
70726: LD_EXP 61
70730: PUSH
70731: FOR_TO
70732: IFFALSE 71141
// begin tmp := mc_build_upgrade [ i ] ;
70734: LD_ADDR_VAR 0 4
70738: PUSH
70739: LD_EXP 93
70743: PUSH
70744: LD_VAR 0 2
70748: ARRAY
70749: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
70750: LD_ADDR_VAR 0 6
70754: PUSH
70755: LD_EXP 94
70759: PUSH
70760: LD_VAR 0 2
70764: ARRAY
70765: PPUSH
70766: LD_INT 2
70768: PUSH
70769: LD_INT 30
70771: PUSH
70772: LD_INT 6
70774: PUSH
70775: EMPTY
70776: LIST
70777: LIST
70778: PUSH
70779: LD_INT 30
70781: PUSH
70782: LD_INT 7
70784: PUSH
70785: EMPTY
70786: LIST
70787: LIST
70788: PUSH
70789: EMPTY
70790: LIST
70791: LIST
70792: LIST
70793: PPUSH
70794: CALL_OW 72
70798: ST_TO_ADDR
// if not tmp and not lab then
70799: LD_VAR 0 4
70803: NOT
70804: PUSH
70805: LD_VAR 0 6
70809: NOT
70810: AND
70811: IFFALSE 70815
// continue ;
70813: GO 70731
// if tmp then
70815: LD_VAR 0 4
70819: IFFALSE 70939
// for j in tmp do
70821: LD_ADDR_VAR 0 3
70825: PUSH
70826: LD_VAR 0 4
70830: PUSH
70831: FOR_IN
70832: IFFALSE 70937
// begin if UpgradeCost ( j ) then
70834: LD_VAR 0 3
70838: PPUSH
70839: CALL 28285 0 1
70843: IFFALSE 70935
// begin ComUpgrade ( j ) ;
70845: LD_VAR 0 3
70849: PPUSH
70850: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
70854: LD_ADDR_EXP 93
70858: PUSH
70859: LD_EXP 93
70863: PPUSH
70864: LD_VAR 0 2
70868: PPUSH
70869: LD_EXP 93
70873: PUSH
70874: LD_VAR 0 2
70878: ARRAY
70879: PUSH
70880: LD_VAR 0 3
70884: DIFF
70885: PPUSH
70886: CALL_OW 1
70890: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
70891: LD_ADDR_EXP 68
70895: PUSH
70896: LD_EXP 68
70900: PPUSH
70901: LD_VAR 0 2
70905: PUSH
70906: LD_EXP 68
70910: PUSH
70911: LD_VAR 0 2
70915: ARRAY
70916: PUSH
70917: LD_INT 1
70919: PLUS
70920: PUSH
70921: EMPTY
70922: LIST
70923: LIST
70924: PPUSH
70925: LD_VAR 0 3
70929: PPUSH
70930: CALL 21397 0 3
70934: ST_TO_ADDR
// end ; end ;
70935: GO 70831
70937: POP
70938: POP
// if not lab or not mc_lab_upgrade [ i ] then
70939: LD_VAR 0 6
70943: NOT
70944: PUSH
70945: LD_EXP 95
70949: PUSH
70950: LD_VAR 0 2
70954: ARRAY
70955: NOT
70956: OR
70957: IFFALSE 70961
// continue ;
70959: GO 70731
// for j in lab do
70961: LD_ADDR_VAR 0 3
70965: PUSH
70966: LD_VAR 0 6
70970: PUSH
70971: FOR_IN
70972: IFFALSE 71137
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
70974: LD_VAR 0 3
70978: PPUSH
70979: CALL_OW 266
70983: PUSH
70984: LD_INT 6
70986: PUSH
70987: LD_INT 7
70989: PUSH
70990: EMPTY
70991: LIST
70992: LIST
70993: IN
70994: PUSH
70995: LD_VAR 0 3
70999: PPUSH
71000: CALL_OW 461
71004: PUSH
71005: LD_INT 1
71007: NONEQUAL
71008: AND
71009: IFFALSE 71135
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
71011: LD_VAR 0 3
71015: PPUSH
71016: LD_EXP 95
71020: PUSH
71021: LD_VAR 0 2
71025: ARRAY
71026: PUSH
71027: LD_INT 1
71029: ARRAY
71030: PPUSH
71031: CALL 28490 0 2
71035: IFFALSE 71135
// begin ComCancel ( j ) ;
71037: LD_VAR 0 3
71041: PPUSH
71042: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
71046: LD_VAR 0 3
71050: PPUSH
71051: LD_EXP 95
71055: PUSH
71056: LD_VAR 0 2
71060: ARRAY
71061: PUSH
71062: LD_INT 1
71064: ARRAY
71065: PPUSH
71066: CALL_OW 207
// if not j in mc_construct_list [ i ] then
71070: LD_VAR 0 3
71074: PUSH
71075: LD_EXP 68
71079: PUSH
71080: LD_VAR 0 2
71084: ARRAY
71085: IN
71086: NOT
71087: IFFALSE 71133
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
71089: LD_ADDR_EXP 68
71093: PUSH
71094: LD_EXP 68
71098: PPUSH
71099: LD_VAR 0 2
71103: PUSH
71104: LD_EXP 68
71108: PUSH
71109: LD_VAR 0 2
71113: ARRAY
71114: PUSH
71115: LD_INT 1
71117: PLUS
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: PPUSH
71123: LD_VAR 0 3
71127: PPUSH
71128: CALL 21397 0 3
71132: ST_TO_ADDR
// break ;
71133: GO 71137
// end ; end ; end ;
71135: GO 70971
71137: POP
71138: POP
// end ;
71139: GO 70731
71141: POP
71142: POP
// end ;
71143: LD_VAR 0 1
71147: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
71148: LD_INT 0
71150: PPUSH
71151: PPUSH
71152: PPUSH
71153: PPUSH
71154: PPUSH
71155: PPUSH
71156: PPUSH
71157: PPUSH
71158: PPUSH
// if not mc_bases then
71159: LD_EXP 61
71163: NOT
71164: IFFALSE 71168
// exit ;
71166: GO 71573
// for i = 1 to mc_bases do
71168: LD_ADDR_VAR 0 2
71172: PUSH
71173: DOUBLE
71174: LD_INT 1
71176: DEC
71177: ST_TO_ADDR
71178: LD_EXP 61
71182: PUSH
71183: FOR_TO
71184: IFFALSE 71571
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
71186: LD_EXP 69
71190: PUSH
71191: LD_VAR 0 2
71195: ARRAY
71196: NOT
71197: PUSH
71198: LD_EXP 61
71202: PUSH
71203: LD_VAR 0 2
71207: ARRAY
71208: PPUSH
71209: LD_INT 30
71211: PUSH
71212: LD_INT 3
71214: PUSH
71215: EMPTY
71216: LIST
71217: LIST
71218: PPUSH
71219: CALL_OW 72
71223: NOT
71224: OR
71225: IFFALSE 71229
// continue ;
71227: GO 71183
// busy := false ;
71229: LD_ADDR_VAR 0 8
71233: PUSH
71234: LD_INT 0
71236: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71237: LD_ADDR_VAR 0 4
71241: PUSH
71242: LD_EXP 61
71246: PUSH
71247: LD_VAR 0 2
71251: ARRAY
71252: PPUSH
71253: LD_INT 30
71255: PUSH
71256: LD_INT 3
71258: PUSH
71259: EMPTY
71260: LIST
71261: LIST
71262: PPUSH
71263: CALL_OW 72
71267: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
71268: LD_ADDR_VAR 0 6
71272: PUSH
71273: LD_EXP 69
71277: PUSH
71278: LD_VAR 0 2
71282: ARRAY
71283: PPUSH
71284: LD_INT 2
71286: PUSH
71287: LD_INT 30
71289: PUSH
71290: LD_INT 32
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: PUSH
71297: LD_INT 30
71299: PUSH
71300: LD_INT 33
71302: PUSH
71303: EMPTY
71304: LIST
71305: LIST
71306: PUSH
71307: EMPTY
71308: LIST
71309: LIST
71310: LIST
71311: PPUSH
71312: CALL_OW 72
71316: ST_TO_ADDR
// if not t then
71317: LD_VAR 0 6
71321: NOT
71322: IFFALSE 71326
// continue ;
71324: GO 71183
// for j in tmp do
71326: LD_ADDR_VAR 0 3
71330: PUSH
71331: LD_VAR 0 4
71335: PUSH
71336: FOR_IN
71337: IFFALSE 71367
// if not BuildingStatus ( j ) = bs_idle then
71339: LD_VAR 0 3
71343: PPUSH
71344: CALL_OW 461
71348: PUSH
71349: LD_INT 2
71351: EQUAL
71352: NOT
71353: IFFALSE 71365
// begin busy := true ;
71355: LD_ADDR_VAR 0 8
71359: PUSH
71360: LD_INT 1
71362: ST_TO_ADDR
// break ;
71363: GO 71367
// end ;
71365: GO 71336
71367: POP
71368: POP
// if busy then
71369: LD_VAR 0 8
71373: IFFALSE 71377
// continue ;
71375: GO 71183
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
71377: LD_ADDR_VAR 0 7
71381: PUSH
71382: LD_VAR 0 6
71386: PPUSH
71387: LD_INT 35
71389: PUSH
71390: LD_INT 0
71392: PUSH
71393: EMPTY
71394: LIST
71395: LIST
71396: PPUSH
71397: CALL_OW 72
71401: ST_TO_ADDR
// if tw then
71402: LD_VAR 0 7
71406: IFFALSE 71483
// begin tw := tw [ 1 ] ;
71408: LD_ADDR_VAR 0 7
71412: PUSH
71413: LD_VAR 0 7
71417: PUSH
71418: LD_INT 1
71420: ARRAY
71421: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
71422: LD_ADDR_VAR 0 9
71426: PUSH
71427: LD_VAR 0 7
71431: PPUSH
71432: LD_EXP 86
71436: PUSH
71437: LD_VAR 0 2
71441: ARRAY
71442: PPUSH
71443: CALL 26782 0 2
71447: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
71448: LD_EXP 100
71452: PUSH
71453: LD_VAR 0 2
71457: ARRAY
71458: IFFALSE 71481
// if not weapon in mc_allowed_tower_weapons [ i ] then
71460: LD_VAR 0 9
71464: PUSH
71465: LD_EXP 100
71469: PUSH
71470: LD_VAR 0 2
71474: ARRAY
71475: IN
71476: NOT
71477: IFFALSE 71481
// continue ;
71479: GO 71183
// end else
71481: GO 71546
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
71483: LD_ADDR_VAR 0 5
71487: PUSH
71488: LD_EXP 69
71492: PUSH
71493: LD_VAR 0 2
71497: ARRAY
71498: PPUSH
71499: LD_VAR 0 4
71503: PPUSH
71504: CALL 53674 0 2
71508: ST_TO_ADDR
// if not tmp2 then
71509: LD_VAR 0 5
71513: NOT
71514: IFFALSE 71518
// continue ;
71516: GO 71183
// tw := tmp2 [ 1 ] ;
71518: LD_ADDR_VAR 0 7
71522: PUSH
71523: LD_VAR 0 5
71527: PUSH
71528: LD_INT 1
71530: ARRAY
71531: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
71532: LD_ADDR_VAR 0 9
71536: PUSH
71537: LD_VAR 0 5
71541: PUSH
71542: LD_INT 2
71544: ARRAY
71545: ST_TO_ADDR
// end ; if not weapon then
71546: LD_VAR 0 9
71550: NOT
71551: IFFALSE 71555
// continue ;
71553: GO 71183
// ComPlaceWeapon ( tw , weapon ) ;
71555: LD_VAR 0 7
71559: PPUSH
71560: LD_VAR 0 9
71564: PPUSH
71565: CALL_OW 148
// end ;
71569: GO 71183
71571: POP
71572: POP
// end ;
71573: LD_VAR 0 1
71577: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
71578: LD_INT 0
71580: PPUSH
71581: PPUSH
71582: PPUSH
71583: PPUSH
71584: PPUSH
71585: PPUSH
71586: PPUSH
// if not mc_bases then
71587: LD_EXP 61
71591: NOT
71592: IFFALSE 71596
// exit ;
71594: GO 72371
// for i = 1 to mc_bases do
71596: LD_ADDR_VAR 0 2
71600: PUSH
71601: DOUBLE
71602: LD_INT 1
71604: DEC
71605: ST_TO_ADDR
71606: LD_EXP 61
71610: PUSH
71611: FOR_TO
71612: IFFALSE 72369
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
71614: LD_EXP 74
71618: PUSH
71619: LD_VAR 0 2
71623: ARRAY
71624: NOT
71625: PUSH
71626: LD_EXP 74
71630: PUSH
71631: LD_VAR 0 2
71635: ARRAY
71636: PUSH
71637: LD_EXP 75
71641: PUSH
71642: LD_VAR 0 2
71646: ARRAY
71647: EQUAL
71648: OR
71649: PUSH
71650: LD_EXP 84
71654: PUSH
71655: LD_VAR 0 2
71659: ARRAY
71660: OR
71661: IFFALSE 71665
// continue ;
71663: GO 71611
// if mc_miners [ i ] then
71665: LD_EXP 75
71669: PUSH
71670: LD_VAR 0 2
71674: ARRAY
71675: IFFALSE 72056
// begin for j = mc_miners [ i ] downto 1 do
71677: LD_ADDR_VAR 0 3
71681: PUSH
71682: DOUBLE
71683: LD_EXP 75
71687: PUSH
71688: LD_VAR 0 2
71692: ARRAY
71693: INC
71694: ST_TO_ADDR
71695: LD_INT 1
71697: PUSH
71698: FOR_DOWNTO
71699: IFFALSE 72054
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
71701: LD_EXP 75
71705: PUSH
71706: LD_VAR 0 2
71710: ARRAY
71711: PUSH
71712: LD_VAR 0 3
71716: ARRAY
71717: PPUSH
71718: CALL_OW 301
71722: PUSH
71723: LD_EXP 75
71727: PUSH
71728: LD_VAR 0 2
71732: ARRAY
71733: PUSH
71734: LD_VAR 0 3
71738: ARRAY
71739: PPUSH
71740: CALL_OW 257
71744: PUSH
71745: LD_INT 1
71747: NONEQUAL
71748: OR
71749: IFFALSE 71812
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
71751: LD_ADDR_VAR 0 5
71755: PUSH
71756: LD_EXP 75
71760: PUSH
71761: LD_VAR 0 2
71765: ARRAY
71766: PUSH
71767: LD_EXP 75
71771: PUSH
71772: LD_VAR 0 2
71776: ARRAY
71777: PUSH
71778: LD_VAR 0 3
71782: ARRAY
71783: DIFF
71784: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
71785: LD_ADDR_EXP 75
71789: PUSH
71790: LD_EXP 75
71794: PPUSH
71795: LD_VAR 0 2
71799: PPUSH
71800: LD_VAR 0 5
71804: PPUSH
71805: CALL_OW 1
71809: ST_TO_ADDR
// continue ;
71810: GO 71698
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
71812: LD_EXP 75
71816: PUSH
71817: LD_VAR 0 2
71821: ARRAY
71822: PUSH
71823: LD_VAR 0 3
71827: ARRAY
71828: PPUSH
71829: CALL_OW 257
71833: PUSH
71834: LD_INT 1
71836: EQUAL
71837: PUSH
71838: LD_EXP 75
71842: PUSH
71843: LD_VAR 0 2
71847: ARRAY
71848: PUSH
71849: LD_VAR 0 3
71853: ARRAY
71854: PPUSH
71855: CALL_OW 459
71859: NOT
71860: AND
71861: PUSH
71862: LD_EXP 75
71866: PUSH
71867: LD_VAR 0 2
71871: ARRAY
71872: PUSH
71873: LD_VAR 0 3
71877: ARRAY
71878: PPUSH
71879: CALL_OW 314
71883: NOT
71884: AND
71885: IFFALSE 72052
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
71887: LD_EXP 75
71891: PUSH
71892: LD_VAR 0 2
71896: ARRAY
71897: PUSH
71898: LD_VAR 0 3
71902: ARRAY
71903: PPUSH
71904: CALL_OW 310
71908: IFFALSE 71931
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
71910: LD_EXP 75
71914: PUSH
71915: LD_VAR 0 2
71919: ARRAY
71920: PUSH
71921: LD_VAR 0 3
71925: ARRAY
71926: PPUSH
71927: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
71931: LD_EXP 75
71935: PUSH
71936: LD_VAR 0 2
71940: ARRAY
71941: PUSH
71942: LD_VAR 0 3
71946: ARRAY
71947: PPUSH
71948: CALL_OW 314
71952: NOT
71953: IFFALSE 72052
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
71955: LD_ADDR_VAR 0 7
71959: PUSH
71960: LD_VAR 0 3
71964: PUSH
71965: LD_EXP 74
71969: PUSH
71970: LD_VAR 0 2
71974: ARRAY
71975: PPUSH
71976: CALL 18537 0 1
71980: MOD
71981: PUSH
71982: LD_INT 1
71984: PLUS
71985: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
71986: LD_EXP 75
71990: PUSH
71991: LD_VAR 0 2
71995: ARRAY
71996: PUSH
71997: LD_VAR 0 3
72001: ARRAY
72002: PPUSH
72003: LD_EXP 74
72007: PUSH
72008: LD_VAR 0 2
72012: ARRAY
72013: PUSH
72014: LD_VAR 0 7
72018: ARRAY
72019: PUSH
72020: LD_INT 1
72022: ARRAY
72023: PPUSH
72024: LD_EXP 74
72028: PUSH
72029: LD_VAR 0 2
72033: ARRAY
72034: PUSH
72035: LD_VAR 0 7
72039: ARRAY
72040: PUSH
72041: LD_INT 2
72043: ARRAY
72044: PPUSH
72045: LD_INT 0
72047: PPUSH
72048: CALL_OW 193
// end ; end ; end ;
72052: GO 71698
72054: POP
72055: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
72056: LD_ADDR_VAR 0 5
72060: PUSH
72061: LD_EXP 61
72065: PUSH
72066: LD_VAR 0 2
72070: ARRAY
72071: PPUSH
72072: LD_INT 2
72074: PUSH
72075: LD_INT 30
72077: PUSH
72078: LD_INT 4
72080: PUSH
72081: EMPTY
72082: LIST
72083: LIST
72084: PUSH
72085: LD_INT 30
72087: PUSH
72088: LD_INT 5
72090: PUSH
72091: EMPTY
72092: LIST
72093: LIST
72094: PUSH
72095: LD_INT 30
72097: PUSH
72098: LD_INT 32
72100: PUSH
72101: EMPTY
72102: LIST
72103: LIST
72104: PUSH
72105: EMPTY
72106: LIST
72107: LIST
72108: LIST
72109: LIST
72110: PPUSH
72111: CALL_OW 72
72115: ST_TO_ADDR
// if not tmp then
72116: LD_VAR 0 5
72120: NOT
72121: IFFALSE 72125
// continue ;
72123: GO 71611
// list := [ ] ;
72125: LD_ADDR_VAR 0 6
72129: PUSH
72130: EMPTY
72131: ST_TO_ADDR
// for j in tmp do
72132: LD_ADDR_VAR 0 3
72136: PUSH
72137: LD_VAR 0 5
72141: PUSH
72142: FOR_IN
72143: IFFALSE 72212
// begin for k in UnitsInside ( j ) do
72145: LD_ADDR_VAR 0 4
72149: PUSH
72150: LD_VAR 0 3
72154: PPUSH
72155: CALL_OW 313
72159: PUSH
72160: FOR_IN
72161: IFFALSE 72208
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
72163: LD_VAR 0 4
72167: PPUSH
72168: CALL_OW 257
72172: PUSH
72173: LD_INT 1
72175: EQUAL
72176: PUSH
72177: LD_VAR 0 4
72181: PPUSH
72182: CALL_OW 459
72186: NOT
72187: AND
72188: IFFALSE 72206
// list := list ^ k ;
72190: LD_ADDR_VAR 0 6
72194: PUSH
72195: LD_VAR 0 6
72199: PUSH
72200: LD_VAR 0 4
72204: ADD
72205: ST_TO_ADDR
72206: GO 72160
72208: POP
72209: POP
// end ;
72210: GO 72142
72212: POP
72213: POP
// list := list diff mc_miners [ i ] ;
72214: LD_ADDR_VAR 0 6
72218: PUSH
72219: LD_VAR 0 6
72223: PUSH
72224: LD_EXP 75
72228: PUSH
72229: LD_VAR 0 2
72233: ARRAY
72234: DIFF
72235: ST_TO_ADDR
// if not list then
72236: LD_VAR 0 6
72240: NOT
72241: IFFALSE 72245
// continue ;
72243: GO 71611
// k := mc_mines [ i ] - mc_miners [ i ] ;
72245: LD_ADDR_VAR 0 4
72249: PUSH
72250: LD_EXP 74
72254: PUSH
72255: LD_VAR 0 2
72259: ARRAY
72260: PUSH
72261: LD_EXP 75
72265: PUSH
72266: LD_VAR 0 2
72270: ARRAY
72271: MINUS
72272: ST_TO_ADDR
// if k > list then
72273: LD_VAR 0 4
72277: PUSH
72278: LD_VAR 0 6
72282: GREATER
72283: IFFALSE 72295
// k := list ;
72285: LD_ADDR_VAR 0 4
72289: PUSH
72290: LD_VAR 0 6
72294: ST_TO_ADDR
// for j = 1 to k do
72295: LD_ADDR_VAR 0 3
72299: PUSH
72300: DOUBLE
72301: LD_INT 1
72303: DEC
72304: ST_TO_ADDR
72305: LD_VAR 0 4
72309: PUSH
72310: FOR_TO
72311: IFFALSE 72365
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
72313: LD_ADDR_EXP 75
72317: PUSH
72318: LD_EXP 75
72322: PPUSH
72323: LD_VAR 0 2
72327: PUSH
72328: LD_EXP 75
72332: PUSH
72333: LD_VAR 0 2
72337: ARRAY
72338: PUSH
72339: LD_INT 1
72341: PLUS
72342: PUSH
72343: EMPTY
72344: LIST
72345: LIST
72346: PPUSH
72347: LD_VAR 0 6
72351: PUSH
72352: LD_VAR 0 3
72356: ARRAY
72357: PPUSH
72358: CALL 21397 0 3
72362: ST_TO_ADDR
72363: GO 72310
72365: POP
72366: POP
// end ;
72367: GO 71611
72369: POP
72370: POP
// end ;
72371: LD_VAR 0 1
72375: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
72376: LD_INT 0
72378: PPUSH
72379: PPUSH
72380: PPUSH
72381: PPUSH
72382: PPUSH
72383: PPUSH
72384: PPUSH
72385: PPUSH
72386: PPUSH
72387: PPUSH
72388: PPUSH
// if not mc_bases then
72389: LD_EXP 61
72393: NOT
72394: IFFALSE 72398
// exit ;
72396: GO 74221
// for i = 1 to mc_bases do
72398: LD_ADDR_VAR 0 2
72402: PUSH
72403: DOUBLE
72404: LD_INT 1
72406: DEC
72407: ST_TO_ADDR
72408: LD_EXP 61
72412: PUSH
72413: FOR_TO
72414: IFFALSE 74219
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
72416: LD_EXP 61
72420: PUSH
72421: LD_VAR 0 2
72425: ARRAY
72426: NOT
72427: PUSH
72428: LD_EXP 68
72432: PUSH
72433: LD_VAR 0 2
72437: ARRAY
72438: OR
72439: IFFALSE 72443
// continue ;
72441: GO 72413
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
72443: LD_EXP 77
72447: PUSH
72448: LD_VAR 0 2
72452: ARRAY
72453: NOT
72454: PUSH
72455: LD_EXP 78
72459: PUSH
72460: LD_VAR 0 2
72464: ARRAY
72465: AND
72466: IFFALSE 72504
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
72468: LD_ADDR_EXP 78
72472: PUSH
72473: LD_EXP 78
72477: PPUSH
72478: LD_VAR 0 2
72482: PPUSH
72483: EMPTY
72484: PPUSH
72485: CALL_OW 1
72489: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
72490: LD_VAR 0 2
72494: PPUSH
72495: LD_INT 107
72497: PPUSH
72498: CALL 63230 0 2
// continue ;
72502: GO 72413
// end ; target := [ ] ;
72504: LD_ADDR_VAR 0 7
72508: PUSH
72509: EMPTY
72510: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
72511: LD_ADDR_VAR 0 6
72515: PUSH
72516: LD_EXP 61
72520: PUSH
72521: LD_VAR 0 2
72525: ARRAY
72526: PUSH
72527: LD_INT 1
72529: ARRAY
72530: PPUSH
72531: CALL_OW 255
72535: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72536: LD_ADDR_VAR 0 9
72540: PUSH
72541: LD_EXP 61
72545: PUSH
72546: LD_VAR 0 2
72550: ARRAY
72551: PPUSH
72552: LD_INT 2
72554: PUSH
72555: LD_INT 30
72557: PUSH
72558: LD_INT 0
72560: PUSH
72561: EMPTY
72562: LIST
72563: LIST
72564: PUSH
72565: LD_INT 30
72567: PUSH
72568: LD_INT 1
72570: PUSH
72571: EMPTY
72572: LIST
72573: LIST
72574: PUSH
72575: EMPTY
72576: LIST
72577: LIST
72578: LIST
72579: PPUSH
72580: CALL_OW 72
72584: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
72585: LD_ADDR_VAR 0 3
72589: PUSH
72590: DOUBLE
72591: LD_EXP 77
72595: PUSH
72596: LD_VAR 0 2
72600: ARRAY
72601: INC
72602: ST_TO_ADDR
72603: LD_INT 1
72605: PUSH
72606: FOR_DOWNTO
72607: IFFALSE 72852
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
72609: LD_EXP 77
72613: PUSH
72614: LD_VAR 0 2
72618: ARRAY
72619: PUSH
72620: LD_VAR 0 3
72624: ARRAY
72625: PUSH
72626: LD_INT 2
72628: ARRAY
72629: PPUSH
72630: LD_EXP 77
72634: PUSH
72635: LD_VAR 0 2
72639: ARRAY
72640: PUSH
72641: LD_VAR 0 3
72645: ARRAY
72646: PUSH
72647: LD_INT 3
72649: ARRAY
72650: PPUSH
72651: CALL_OW 488
72655: PUSH
72656: LD_EXP 77
72660: PUSH
72661: LD_VAR 0 2
72665: ARRAY
72666: PUSH
72667: LD_VAR 0 3
72671: ARRAY
72672: PUSH
72673: LD_INT 2
72675: ARRAY
72676: PPUSH
72677: LD_EXP 77
72681: PUSH
72682: LD_VAR 0 2
72686: ARRAY
72687: PUSH
72688: LD_VAR 0 3
72692: ARRAY
72693: PUSH
72694: LD_INT 3
72696: ARRAY
72697: PPUSH
72698: CALL_OW 284
72702: PUSH
72703: LD_INT 0
72705: EQUAL
72706: AND
72707: IFFALSE 72762
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
72709: LD_ADDR_VAR 0 5
72713: PUSH
72714: LD_EXP 77
72718: PUSH
72719: LD_VAR 0 2
72723: ARRAY
72724: PPUSH
72725: LD_VAR 0 3
72729: PPUSH
72730: CALL_OW 3
72734: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
72735: LD_ADDR_EXP 77
72739: PUSH
72740: LD_EXP 77
72744: PPUSH
72745: LD_VAR 0 2
72749: PPUSH
72750: LD_VAR 0 5
72754: PPUSH
72755: CALL_OW 1
72759: ST_TO_ADDR
// continue ;
72760: GO 72606
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
72762: LD_VAR 0 6
72766: PPUSH
72767: LD_EXP 77
72771: PUSH
72772: LD_VAR 0 2
72776: ARRAY
72777: PUSH
72778: LD_VAR 0 3
72782: ARRAY
72783: PUSH
72784: LD_INT 2
72786: ARRAY
72787: PPUSH
72788: LD_EXP 77
72792: PUSH
72793: LD_VAR 0 2
72797: ARRAY
72798: PUSH
72799: LD_VAR 0 3
72803: ARRAY
72804: PUSH
72805: LD_INT 3
72807: ARRAY
72808: PPUSH
72809: LD_INT 30
72811: PPUSH
72812: CALL 22661 0 4
72816: PUSH
72817: LD_INT 4
72819: ARRAY
72820: PUSH
72821: LD_INT 0
72823: EQUAL
72824: IFFALSE 72850
// begin target := mc_crates [ i ] [ j ] ;
72826: LD_ADDR_VAR 0 7
72830: PUSH
72831: LD_EXP 77
72835: PUSH
72836: LD_VAR 0 2
72840: ARRAY
72841: PUSH
72842: LD_VAR 0 3
72846: ARRAY
72847: ST_TO_ADDR
// break ;
72848: GO 72852
// end ; end ;
72850: GO 72606
72852: POP
72853: POP
// if not target then
72854: LD_VAR 0 7
72858: NOT
72859: IFFALSE 72863
// continue ;
72861: GO 72413
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
72863: LD_ADDR_VAR 0 8
72867: PUSH
72868: LD_EXP 80
72872: PUSH
72873: LD_VAR 0 2
72877: ARRAY
72878: PPUSH
72879: LD_INT 2
72881: PUSH
72882: LD_INT 3
72884: PUSH
72885: LD_INT 58
72887: PUSH
72888: EMPTY
72889: LIST
72890: PUSH
72891: EMPTY
72892: LIST
72893: LIST
72894: PUSH
72895: LD_INT 61
72897: PUSH
72898: EMPTY
72899: LIST
72900: PUSH
72901: LD_INT 33
72903: PUSH
72904: LD_INT 5
72906: PUSH
72907: EMPTY
72908: LIST
72909: LIST
72910: PUSH
72911: LD_INT 33
72913: PUSH
72914: LD_INT 3
72916: PUSH
72917: EMPTY
72918: LIST
72919: LIST
72920: PUSH
72921: EMPTY
72922: LIST
72923: LIST
72924: LIST
72925: LIST
72926: LIST
72927: PUSH
72928: LD_INT 2
72930: PUSH
72931: LD_INT 34
72933: PUSH
72934: LD_INT 32
72936: PUSH
72937: EMPTY
72938: LIST
72939: LIST
72940: PUSH
72941: LD_INT 34
72943: PUSH
72944: LD_INT 51
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 34
72953: PUSH
72954: LD_INT 12
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: EMPTY
72962: LIST
72963: LIST
72964: LIST
72965: LIST
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PPUSH
72971: CALL_OW 72
72975: ST_TO_ADDR
// if not cargo then
72976: LD_VAR 0 8
72980: NOT
72981: IFFALSE 73687
// begin if mc_crates_collector [ i ] < 5 then
72983: LD_EXP 78
72987: PUSH
72988: LD_VAR 0 2
72992: ARRAY
72993: PUSH
72994: LD_INT 5
72996: LESS
72997: IFFALSE 73363
// begin if mc_ape [ i ] then
72999: LD_EXP 90
73003: PUSH
73004: LD_VAR 0 2
73008: ARRAY
73009: IFFALSE 73056
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
73011: LD_ADDR_VAR 0 5
73015: PUSH
73016: LD_EXP 90
73020: PUSH
73021: LD_VAR 0 2
73025: ARRAY
73026: PPUSH
73027: LD_INT 25
73029: PUSH
73030: LD_INT 16
73032: PUSH
73033: EMPTY
73034: LIST
73035: LIST
73036: PUSH
73037: LD_INT 24
73039: PUSH
73040: LD_INT 750
73042: PUSH
73043: EMPTY
73044: LIST
73045: LIST
73046: PUSH
73047: EMPTY
73048: LIST
73049: LIST
73050: PPUSH
73051: CALL_OW 72
73055: ST_TO_ADDR
// if not tmp then
73056: LD_VAR 0 5
73060: NOT
73061: IFFALSE 73108
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
73063: LD_ADDR_VAR 0 5
73067: PUSH
73068: LD_EXP 61
73072: PUSH
73073: LD_VAR 0 2
73077: ARRAY
73078: PPUSH
73079: LD_INT 25
73081: PUSH
73082: LD_INT 2
73084: PUSH
73085: EMPTY
73086: LIST
73087: LIST
73088: PUSH
73089: LD_INT 24
73091: PUSH
73092: LD_INT 750
73094: PUSH
73095: EMPTY
73096: LIST
73097: LIST
73098: PUSH
73099: EMPTY
73100: LIST
73101: LIST
73102: PPUSH
73103: CALL_OW 72
73107: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
73108: LD_EXP 90
73112: PUSH
73113: LD_VAR 0 2
73117: ARRAY
73118: PUSH
73119: LD_EXP 61
73123: PUSH
73124: LD_VAR 0 2
73128: ARRAY
73129: PPUSH
73130: LD_INT 25
73132: PUSH
73133: LD_INT 2
73135: PUSH
73136: EMPTY
73137: LIST
73138: LIST
73139: PUSH
73140: LD_INT 24
73142: PUSH
73143: LD_INT 750
73145: PUSH
73146: EMPTY
73147: LIST
73148: LIST
73149: PUSH
73150: EMPTY
73151: LIST
73152: LIST
73153: PPUSH
73154: CALL_OW 72
73158: AND
73159: PUSH
73160: LD_VAR 0 5
73164: PUSH
73165: LD_INT 5
73167: LESS
73168: AND
73169: IFFALSE 73251
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
73171: LD_ADDR_VAR 0 3
73175: PUSH
73176: LD_EXP 61
73180: PUSH
73181: LD_VAR 0 2
73185: ARRAY
73186: PPUSH
73187: LD_INT 25
73189: PUSH
73190: LD_INT 2
73192: PUSH
73193: EMPTY
73194: LIST
73195: LIST
73196: PUSH
73197: LD_INT 24
73199: PUSH
73200: LD_INT 750
73202: PUSH
73203: EMPTY
73204: LIST
73205: LIST
73206: PUSH
73207: EMPTY
73208: LIST
73209: LIST
73210: PPUSH
73211: CALL_OW 72
73215: PUSH
73216: FOR_IN
73217: IFFALSE 73249
// begin tmp := tmp union j ;
73219: LD_ADDR_VAR 0 5
73223: PUSH
73224: LD_VAR 0 5
73228: PUSH
73229: LD_VAR 0 3
73233: UNION
73234: ST_TO_ADDR
// if tmp >= 5 then
73235: LD_VAR 0 5
73239: PUSH
73240: LD_INT 5
73242: GREATEREQUAL
73243: IFFALSE 73247
// break ;
73245: GO 73249
// end ;
73247: GO 73216
73249: POP
73250: POP
// end ; if not tmp then
73251: LD_VAR 0 5
73255: NOT
73256: IFFALSE 73260
// continue ;
73258: GO 72413
// for j in tmp do
73260: LD_ADDR_VAR 0 3
73264: PUSH
73265: LD_VAR 0 5
73269: PUSH
73270: FOR_IN
73271: IFFALSE 73361
// if not GetTag ( j ) then
73273: LD_VAR 0 3
73277: PPUSH
73278: CALL_OW 110
73282: NOT
73283: IFFALSE 73359
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
73285: LD_ADDR_EXP 78
73289: PUSH
73290: LD_EXP 78
73294: PPUSH
73295: LD_VAR 0 2
73299: PUSH
73300: LD_EXP 78
73304: PUSH
73305: LD_VAR 0 2
73309: ARRAY
73310: PUSH
73311: LD_INT 1
73313: PLUS
73314: PUSH
73315: EMPTY
73316: LIST
73317: LIST
73318: PPUSH
73319: LD_VAR 0 3
73323: PPUSH
73324: CALL 21397 0 3
73328: ST_TO_ADDR
// SetTag ( j , 107 ) ;
73329: LD_VAR 0 3
73333: PPUSH
73334: LD_INT 107
73336: PPUSH
73337: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
73341: LD_EXP 78
73345: PUSH
73346: LD_VAR 0 2
73350: ARRAY
73351: PUSH
73352: LD_INT 5
73354: GREATEREQUAL
73355: IFFALSE 73359
// break ;
73357: GO 73361
// end ;
73359: GO 73270
73361: POP
73362: POP
// end ; if mc_crates_collector [ i ] and target then
73363: LD_EXP 78
73367: PUSH
73368: LD_VAR 0 2
73372: ARRAY
73373: PUSH
73374: LD_VAR 0 7
73378: AND
73379: IFFALSE 73685
// begin if mc_crates_collector [ i ] < target [ 1 ] then
73381: LD_EXP 78
73385: PUSH
73386: LD_VAR 0 2
73390: ARRAY
73391: PUSH
73392: LD_VAR 0 7
73396: PUSH
73397: LD_INT 1
73399: ARRAY
73400: LESS
73401: IFFALSE 73421
// tmp := mc_crates_collector [ i ] else
73403: LD_ADDR_VAR 0 5
73407: PUSH
73408: LD_EXP 78
73412: PUSH
73413: LD_VAR 0 2
73417: ARRAY
73418: ST_TO_ADDR
73419: GO 73435
// tmp := target [ 1 ] ;
73421: LD_ADDR_VAR 0 5
73425: PUSH
73426: LD_VAR 0 7
73430: PUSH
73431: LD_INT 1
73433: ARRAY
73434: ST_TO_ADDR
// k := 0 ;
73435: LD_ADDR_VAR 0 4
73439: PUSH
73440: LD_INT 0
73442: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
73443: LD_ADDR_VAR 0 3
73447: PUSH
73448: LD_EXP 78
73452: PUSH
73453: LD_VAR 0 2
73457: ARRAY
73458: PUSH
73459: FOR_IN
73460: IFFALSE 73683
// begin k := k + 1 ;
73462: LD_ADDR_VAR 0 4
73466: PUSH
73467: LD_VAR 0 4
73471: PUSH
73472: LD_INT 1
73474: PLUS
73475: ST_TO_ADDR
// if k > tmp then
73476: LD_VAR 0 4
73480: PUSH
73481: LD_VAR 0 5
73485: GREATER
73486: IFFALSE 73490
// break ;
73488: GO 73683
// if not GetClass ( j ) in [ 2 , 16 ] then
73490: LD_VAR 0 3
73494: PPUSH
73495: CALL_OW 257
73499: PUSH
73500: LD_INT 2
73502: PUSH
73503: LD_INT 16
73505: PUSH
73506: EMPTY
73507: LIST
73508: LIST
73509: IN
73510: NOT
73511: IFFALSE 73564
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
73513: LD_ADDR_EXP 78
73517: PUSH
73518: LD_EXP 78
73522: PPUSH
73523: LD_VAR 0 2
73527: PPUSH
73528: LD_EXP 78
73532: PUSH
73533: LD_VAR 0 2
73537: ARRAY
73538: PUSH
73539: LD_VAR 0 3
73543: DIFF
73544: PPUSH
73545: CALL_OW 1
73549: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73550: LD_VAR 0 3
73554: PPUSH
73555: LD_INT 0
73557: PPUSH
73558: CALL_OW 109
// continue ;
73562: GO 73459
// end ; if IsInUnit ( j ) then
73564: LD_VAR 0 3
73568: PPUSH
73569: CALL_OW 310
73573: IFFALSE 73584
// ComExitBuilding ( j ) ;
73575: LD_VAR 0 3
73579: PPUSH
73580: CALL_OW 122
// wait ( 3 ) ;
73584: LD_INT 3
73586: PPUSH
73587: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
73591: LD_VAR 0 3
73595: PPUSH
73596: CALL_OW 314
73600: PUSH
73601: LD_VAR 0 6
73605: PPUSH
73606: LD_VAR 0 7
73610: PUSH
73611: LD_INT 2
73613: ARRAY
73614: PPUSH
73615: LD_VAR 0 7
73619: PUSH
73620: LD_INT 3
73622: ARRAY
73623: PPUSH
73624: LD_INT 30
73626: PPUSH
73627: CALL 22661 0 4
73631: PUSH
73632: LD_INT 4
73634: ARRAY
73635: AND
73636: IFFALSE 73654
// ComStandNearbyBuilding ( j , depot ) else
73638: LD_VAR 0 3
73642: PPUSH
73643: LD_VAR 0 9
73647: PPUSH
73648: CALL 17999 0 2
73652: GO 73681
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
73654: LD_VAR 0 3
73658: PPUSH
73659: LD_VAR 0 7
73663: PUSH
73664: LD_INT 2
73666: ARRAY
73667: PPUSH
73668: LD_VAR 0 7
73672: PUSH
73673: LD_INT 3
73675: ARRAY
73676: PPUSH
73677: CALL_OW 117
// end ;
73681: GO 73459
73683: POP
73684: POP
// end ; end else
73685: GO 74217
// begin for j in cargo do
73687: LD_ADDR_VAR 0 3
73691: PUSH
73692: LD_VAR 0 8
73696: PUSH
73697: FOR_IN
73698: IFFALSE 74215
// begin if GetTag ( j ) <> 0 then
73700: LD_VAR 0 3
73704: PPUSH
73705: CALL_OW 110
73709: PUSH
73710: LD_INT 0
73712: NONEQUAL
73713: IFFALSE 73717
// continue ;
73715: GO 73697
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
73717: LD_VAR 0 3
73721: PPUSH
73722: CALL_OW 256
73726: PUSH
73727: LD_INT 1000
73729: LESS
73730: PUSH
73731: LD_VAR 0 3
73735: PPUSH
73736: LD_EXP 85
73740: PUSH
73741: LD_VAR 0 2
73745: ARRAY
73746: PPUSH
73747: CALL_OW 308
73751: NOT
73752: AND
73753: IFFALSE 73775
// ComMoveToArea ( j , mc_parking [ i ] ) ;
73755: LD_VAR 0 3
73759: PPUSH
73760: LD_EXP 85
73764: PUSH
73765: LD_VAR 0 2
73769: ARRAY
73770: PPUSH
73771: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
73775: LD_VAR 0 3
73779: PPUSH
73780: CALL_OW 256
73784: PUSH
73785: LD_INT 1000
73787: LESS
73788: PUSH
73789: LD_VAR 0 3
73793: PPUSH
73794: LD_EXP 85
73798: PUSH
73799: LD_VAR 0 2
73803: ARRAY
73804: PPUSH
73805: CALL_OW 308
73809: AND
73810: IFFALSE 73814
// continue ;
73812: GO 73697
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
73814: LD_VAR 0 3
73818: PPUSH
73819: CALL_OW 262
73823: PUSH
73824: LD_INT 2
73826: EQUAL
73827: PUSH
73828: LD_VAR 0 3
73832: PPUSH
73833: CALL_OW 261
73837: PUSH
73838: LD_INT 15
73840: LESS
73841: AND
73842: IFFALSE 73846
// continue ;
73844: GO 73697
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
73846: LD_VAR 0 3
73850: PPUSH
73851: CALL_OW 262
73855: PUSH
73856: LD_INT 1
73858: EQUAL
73859: PUSH
73860: LD_VAR 0 3
73864: PPUSH
73865: CALL_OW 261
73869: PUSH
73870: LD_INT 10
73872: LESS
73873: AND
73874: IFFALSE 74154
// begin if not depot then
73876: LD_VAR 0 9
73880: NOT
73881: IFFALSE 73885
// continue ;
73883: GO 73697
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
73885: LD_VAR 0 3
73889: PPUSH
73890: LD_VAR 0 9
73894: PPUSH
73895: LD_VAR 0 3
73899: PPUSH
73900: CALL_OW 74
73904: PPUSH
73905: CALL_OW 296
73909: PUSH
73910: LD_INT 6
73912: LESS
73913: IFFALSE 73929
// SetFuel ( j , 100 ) else
73915: LD_VAR 0 3
73919: PPUSH
73920: LD_INT 100
73922: PPUSH
73923: CALL_OW 240
73927: GO 74154
// if GetFuel ( j ) = 0 then
73929: LD_VAR 0 3
73933: PPUSH
73934: CALL_OW 261
73938: PUSH
73939: LD_INT 0
73941: EQUAL
73942: IFFALSE 74154
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
73944: LD_ADDR_EXP 80
73948: PUSH
73949: LD_EXP 80
73953: PPUSH
73954: LD_VAR 0 2
73958: PPUSH
73959: LD_EXP 80
73963: PUSH
73964: LD_VAR 0 2
73968: ARRAY
73969: PUSH
73970: LD_VAR 0 3
73974: DIFF
73975: PPUSH
73976: CALL_OW 1
73980: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
73981: LD_VAR 0 3
73985: PPUSH
73986: CALL_OW 263
73990: PUSH
73991: LD_INT 1
73993: EQUAL
73994: IFFALSE 74010
// ComExitVehicle ( IsInUnit ( j ) ) ;
73996: LD_VAR 0 3
74000: PPUSH
74001: CALL_OW 310
74005: PPUSH
74006: CALL_OW 121
// if GetControl ( j ) = control_remote then
74010: LD_VAR 0 3
74014: PPUSH
74015: CALL_OW 263
74019: PUSH
74020: LD_INT 2
74022: EQUAL
74023: IFFALSE 74034
// ComUnlink ( j ) ;
74025: LD_VAR 0 3
74029: PPUSH
74030: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
74034: LD_ADDR_VAR 0 10
74038: PUSH
74039: LD_VAR 0 2
74043: PPUSH
74044: LD_INT 3
74046: PPUSH
74047: CALL 83798 0 2
74051: ST_TO_ADDR
// if fac then
74052: LD_VAR 0 10
74056: IFFALSE 74152
// begin for k in fac do
74058: LD_ADDR_VAR 0 4
74062: PUSH
74063: LD_VAR 0 10
74067: PUSH
74068: FOR_IN
74069: IFFALSE 74150
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
74071: LD_ADDR_VAR 0 11
74075: PUSH
74076: LD_VAR 0 10
74080: PPUSH
74081: LD_VAR 0 3
74085: PPUSH
74086: CALL_OW 265
74090: PPUSH
74091: LD_VAR 0 3
74095: PPUSH
74096: CALL_OW 262
74100: PPUSH
74101: LD_VAR 0 3
74105: PPUSH
74106: CALL_OW 263
74110: PPUSH
74111: LD_VAR 0 3
74115: PPUSH
74116: CALL_OW 264
74120: PPUSH
74121: CALL 18895 0 5
74125: ST_TO_ADDR
// if components then
74126: LD_VAR 0 11
74130: IFFALSE 74148
// begin MC_InsertProduceList ( i , components ) ;
74132: LD_VAR 0 2
74136: PPUSH
74137: LD_VAR 0 11
74141: PPUSH
74142: CALL 83343 0 2
// break ;
74146: GO 74150
// end ; end ;
74148: GO 74068
74150: POP
74151: POP
// end ; continue ;
74152: GO 73697
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
74154: LD_VAR 0 3
74158: PPUSH
74159: LD_INT 1
74161: PPUSH
74162: CALL_OW 289
74166: PUSH
74167: LD_INT 100
74169: LESS
74170: PUSH
74171: LD_VAR 0 3
74175: PPUSH
74176: CALL_OW 314
74180: NOT
74181: AND
74182: IFFALSE 74211
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
74184: LD_VAR 0 3
74188: PPUSH
74189: LD_VAR 0 7
74193: PUSH
74194: LD_INT 2
74196: ARRAY
74197: PPUSH
74198: LD_VAR 0 7
74202: PUSH
74203: LD_INT 3
74205: ARRAY
74206: PPUSH
74207: CALL_OW 117
// break ;
74211: GO 74215
// end ;
74213: GO 73697
74215: POP
74216: POP
// end ; end ;
74217: GO 72413
74219: POP
74220: POP
// end ;
74221: LD_VAR 0 1
74225: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
74226: LD_INT 0
74228: PPUSH
74229: PPUSH
74230: PPUSH
74231: PPUSH
// if not mc_bases then
74232: LD_EXP 61
74236: NOT
74237: IFFALSE 74241
// exit ;
74239: GO 74402
// for i = 1 to mc_bases do
74241: LD_ADDR_VAR 0 2
74245: PUSH
74246: DOUBLE
74247: LD_INT 1
74249: DEC
74250: ST_TO_ADDR
74251: LD_EXP 61
74255: PUSH
74256: FOR_TO
74257: IFFALSE 74400
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
74259: LD_ADDR_VAR 0 4
74263: PUSH
74264: LD_EXP 80
74268: PUSH
74269: LD_VAR 0 2
74273: ARRAY
74274: PUSH
74275: LD_EXP 83
74279: PUSH
74280: LD_VAR 0 2
74284: ARRAY
74285: UNION
74286: PPUSH
74287: LD_INT 33
74289: PUSH
74290: LD_INT 2
74292: PUSH
74293: EMPTY
74294: LIST
74295: LIST
74296: PPUSH
74297: CALL_OW 72
74301: ST_TO_ADDR
// if tmp then
74302: LD_VAR 0 4
74306: IFFALSE 74398
// for j in tmp do
74308: LD_ADDR_VAR 0 3
74312: PUSH
74313: LD_VAR 0 4
74317: PUSH
74318: FOR_IN
74319: IFFALSE 74396
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
74321: LD_VAR 0 3
74325: PPUSH
74326: CALL_OW 312
74330: NOT
74331: PUSH
74332: LD_VAR 0 3
74336: PPUSH
74337: CALL_OW 256
74341: PUSH
74342: LD_INT 250
74344: GREATEREQUAL
74345: AND
74346: IFFALSE 74359
// Connect ( j ) else
74348: LD_VAR 0 3
74352: PPUSH
74353: CALL 24743 0 1
74357: GO 74394
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
74359: LD_VAR 0 3
74363: PPUSH
74364: CALL_OW 256
74368: PUSH
74369: LD_INT 250
74371: LESS
74372: PUSH
74373: LD_VAR 0 3
74377: PPUSH
74378: CALL_OW 312
74382: AND
74383: IFFALSE 74394
// ComUnlink ( j ) ;
74385: LD_VAR 0 3
74389: PPUSH
74390: CALL_OW 136
74394: GO 74318
74396: POP
74397: POP
// end ;
74398: GO 74256
74400: POP
74401: POP
// end ;
74402: LD_VAR 0 1
74406: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
74407: LD_INT 0
74409: PPUSH
74410: PPUSH
74411: PPUSH
74412: PPUSH
74413: PPUSH
// if not mc_bases then
74414: LD_EXP 61
74418: NOT
74419: IFFALSE 74423
// exit ;
74421: GO 74868
// for i = 1 to mc_bases do
74423: LD_ADDR_VAR 0 2
74427: PUSH
74428: DOUBLE
74429: LD_INT 1
74431: DEC
74432: ST_TO_ADDR
74433: LD_EXP 61
74437: PUSH
74438: FOR_TO
74439: IFFALSE 74866
// begin if not mc_produce [ i ] then
74441: LD_EXP 82
74445: PUSH
74446: LD_VAR 0 2
74450: ARRAY
74451: NOT
74452: IFFALSE 74456
// continue ;
74454: GO 74438
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74456: LD_ADDR_VAR 0 5
74460: PUSH
74461: LD_EXP 61
74465: PUSH
74466: LD_VAR 0 2
74470: ARRAY
74471: PPUSH
74472: LD_INT 30
74474: PUSH
74475: LD_INT 3
74477: PUSH
74478: EMPTY
74479: LIST
74480: LIST
74481: PPUSH
74482: CALL_OW 72
74486: ST_TO_ADDR
// if not fac then
74487: LD_VAR 0 5
74491: NOT
74492: IFFALSE 74496
// continue ;
74494: GO 74438
// for j in fac do
74496: LD_ADDR_VAR 0 3
74500: PUSH
74501: LD_VAR 0 5
74505: PUSH
74506: FOR_IN
74507: IFFALSE 74862
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
74509: LD_VAR 0 3
74513: PPUSH
74514: CALL_OW 461
74518: PUSH
74519: LD_INT 2
74521: NONEQUAL
74522: PUSH
74523: LD_VAR 0 3
74527: PPUSH
74528: LD_INT 15
74530: PPUSH
74531: CALL 24362 0 2
74535: PUSH
74536: LD_INT 4
74538: ARRAY
74539: OR
74540: IFFALSE 74544
// continue ;
74542: GO 74506
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
74544: LD_VAR 0 3
74548: PPUSH
74549: LD_EXP 82
74553: PUSH
74554: LD_VAR 0 2
74558: ARRAY
74559: PUSH
74560: LD_INT 1
74562: ARRAY
74563: PUSH
74564: LD_INT 1
74566: ARRAY
74567: PPUSH
74568: LD_EXP 82
74572: PUSH
74573: LD_VAR 0 2
74577: ARRAY
74578: PUSH
74579: LD_INT 1
74581: ARRAY
74582: PUSH
74583: LD_INT 2
74585: ARRAY
74586: PPUSH
74587: LD_EXP 82
74591: PUSH
74592: LD_VAR 0 2
74596: ARRAY
74597: PUSH
74598: LD_INT 1
74600: ARRAY
74601: PUSH
74602: LD_INT 3
74604: ARRAY
74605: PPUSH
74606: LD_EXP 82
74610: PUSH
74611: LD_VAR 0 2
74615: ARRAY
74616: PUSH
74617: LD_INT 1
74619: ARRAY
74620: PUSH
74621: LD_INT 4
74623: ARRAY
74624: PPUSH
74625: CALL_OW 448
74629: PUSH
74630: LD_VAR 0 3
74634: PPUSH
74635: LD_EXP 82
74639: PUSH
74640: LD_VAR 0 2
74644: ARRAY
74645: PUSH
74646: LD_INT 1
74648: ARRAY
74649: PUSH
74650: LD_INT 1
74652: ARRAY
74653: PUSH
74654: LD_EXP 82
74658: PUSH
74659: LD_VAR 0 2
74663: ARRAY
74664: PUSH
74665: LD_INT 1
74667: ARRAY
74668: PUSH
74669: LD_INT 2
74671: ARRAY
74672: PUSH
74673: LD_EXP 82
74677: PUSH
74678: LD_VAR 0 2
74682: ARRAY
74683: PUSH
74684: LD_INT 1
74686: ARRAY
74687: PUSH
74688: LD_INT 3
74690: ARRAY
74691: PUSH
74692: LD_EXP 82
74696: PUSH
74697: LD_VAR 0 2
74701: ARRAY
74702: PUSH
74703: LD_INT 1
74705: ARRAY
74706: PUSH
74707: LD_INT 4
74709: ARRAY
74710: PUSH
74711: EMPTY
74712: LIST
74713: LIST
74714: LIST
74715: LIST
74716: PPUSH
74717: CALL 28138 0 2
74721: AND
74722: IFFALSE 74860
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
74724: LD_VAR 0 3
74728: PPUSH
74729: LD_EXP 82
74733: PUSH
74734: LD_VAR 0 2
74738: ARRAY
74739: PUSH
74740: LD_INT 1
74742: ARRAY
74743: PUSH
74744: LD_INT 1
74746: ARRAY
74747: PPUSH
74748: LD_EXP 82
74752: PUSH
74753: LD_VAR 0 2
74757: ARRAY
74758: PUSH
74759: LD_INT 1
74761: ARRAY
74762: PUSH
74763: LD_INT 2
74765: ARRAY
74766: PPUSH
74767: LD_EXP 82
74771: PUSH
74772: LD_VAR 0 2
74776: ARRAY
74777: PUSH
74778: LD_INT 1
74780: ARRAY
74781: PUSH
74782: LD_INT 3
74784: ARRAY
74785: PPUSH
74786: LD_EXP 82
74790: PUSH
74791: LD_VAR 0 2
74795: ARRAY
74796: PUSH
74797: LD_INT 1
74799: ARRAY
74800: PUSH
74801: LD_INT 4
74803: ARRAY
74804: PPUSH
74805: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
74809: LD_ADDR_VAR 0 4
74813: PUSH
74814: LD_EXP 82
74818: PUSH
74819: LD_VAR 0 2
74823: ARRAY
74824: PPUSH
74825: LD_INT 1
74827: PPUSH
74828: CALL_OW 3
74832: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
74833: LD_ADDR_EXP 82
74837: PUSH
74838: LD_EXP 82
74842: PPUSH
74843: LD_VAR 0 2
74847: PPUSH
74848: LD_VAR 0 4
74852: PPUSH
74853: CALL_OW 1
74857: ST_TO_ADDR
// break ;
74858: GO 74862
// end ; end ;
74860: GO 74506
74862: POP
74863: POP
// end ;
74864: GO 74438
74866: POP
74867: POP
// end ;
74868: LD_VAR 0 1
74872: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
74873: LD_INT 0
74875: PPUSH
74876: PPUSH
74877: PPUSH
// if not mc_bases then
74878: LD_EXP 61
74882: NOT
74883: IFFALSE 74887
// exit ;
74885: GO 74976
// for i = 1 to mc_bases do
74887: LD_ADDR_VAR 0 2
74891: PUSH
74892: DOUBLE
74893: LD_INT 1
74895: DEC
74896: ST_TO_ADDR
74897: LD_EXP 61
74901: PUSH
74902: FOR_TO
74903: IFFALSE 74974
// begin if mc_attack [ i ] then
74905: LD_EXP 81
74909: PUSH
74910: LD_VAR 0 2
74914: ARRAY
74915: IFFALSE 74972
// begin tmp := mc_attack [ i ] [ 1 ] ;
74917: LD_ADDR_VAR 0 3
74921: PUSH
74922: LD_EXP 81
74926: PUSH
74927: LD_VAR 0 2
74931: ARRAY
74932: PUSH
74933: LD_INT 1
74935: ARRAY
74936: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
74937: LD_ADDR_EXP 81
74941: PUSH
74942: LD_EXP 81
74946: PPUSH
74947: LD_VAR 0 2
74951: PPUSH
74952: EMPTY
74953: PPUSH
74954: CALL_OW 1
74958: ST_TO_ADDR
// Attack ( tmp ) ;
74959: LD_VAR 0 3
74963: PPUSH
74964: CALL 110465 0 1
// exit ;
74968: POP
74969: POP
74970: GO 74976
// end ; end ;
74972: GO 74902
74974: POP
74975: POP
// end ;
74976: LD_VAR 0 1
74980: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
74981: LD_INT 0
74983: PPUSH
74984: PPUSH
74985: PPUSH
74986: PPUSH
74987: PPUSH
74988: PPUSH
74989: PPUSH
// if not mc_bases then
74990: LD_EXP 61
74994: NOT
74995: IFFALSE 74999
// exit ;
74997: GO 75856
// for i = 1 to mc_bases do
74999: LD_ADDR_VAR 0 2
75003: PUSH
75004: DOUBLE
75005: LD_INT 1
75007: DEC
75008: ST_TO_ADDR
75009: LD_EXP 61
75013: PUSH
75014: FOR_TO
75015: IFFALSE 75854
// begin if not mc_bases [ i ] then
75017: LD_EXP 61
75021: PUSH
75022: LD_VAR 0 2
75026: ARRAY
75027: NOT
75028: IFFALSE 75032
// continue ;
75030: GO 75014
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
75032: LD_ADDR_VAR 0 7
75036: PUSH
75037: LD_EXP 61
75041: PUSH
75042: LD_VAR 0 2
75046: ARRAY
75047: PUSH
75048: LD_INT 1
75050: ARRAY
75051: PPUSH
75052: CALL 18221 0 1
75056: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
75057: LD_ADDR_EXP 84
75061: PUSH
75062: LD_EXP 84
75066: PPUSH
75067: LD_VAR 0 2
75071: PPUSH
75072: LD_EXP 61
75076: PUSH
75077: LD_VAR 0 2
75081: ARRAY
75082: PUSH
75083: LD_INT 1
75085: ARRAY
75086: PPUSH
75087: CALL_OW 255
75091: PPUSH
75092: LD_EXP 86
75096: PUSH
75097: LD_VAR 0 2
75101: ARRAY
75102: PPUSH
75103: CALL 18186 0 2
75107: PPUSH
75108: CALL_OW 1
75112: ST_TO_ADDR
// if not mc_scan [ i ] then
75113: LD_EXP 84
75117: PUSH
75118: LD_VAR 0 2
75122: ARRAY
75123: NOT
75124: IFFALSE 75302
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
75126: LD_ADDR_EXP 104
75130: PUSH
75131: LD_EXP 104
75135: PPUSH
75136: LD_VAR 0 2
75140: PPUSH
75141: LD_INT 0
75143: PPUSH
75144: CALL_OW 1
75148: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
75149: LD_ADDR_VAR 0 4
75153: PUSH
75154: LD_EXP 61
75158: PUSH
75159: LD_VAR 0 2
75163: ARRAY
75164: PPUSH
75165: LD_INT 2
75167: PUSH
75168: LD_INT 25
75170: PUSH
75171: LD_INT 5
75173: PUSH
75174: EMPTY
75175: LIST
75176: LIST
75177: PUSH
75178: LD_INT 25
75180: PUSH
75181: LD_INT 8
75183: PUSH
75184: EMPTY
75185: LIST
75186: LIST
75187: PUSH
75188: LD_INT 25
75190: PUSH
75191: LD_INT 9
75193: PUSH
75194: EMPTY
75195: LIST
75196: LIST
75197: PUSH
75198: EMPTY
75199: LIST
75200: LIST
75201: LIST
75202: LIST
75203: PPUSH
75204: CALL_OW 72
75208: ST_TO_ADDR
// if not tmp then
75209: LD_VAR 0 4
75213: NOT
75214: IFFALSE 75218
// continue ;
75216: GO 75014
// for j in tmp do
75218: LD_ADDR_VAR 0 3
75222: PUSH
75223: LD_VAR 0 4
75227: PUSH
75228: FOR_IN
75229: IFFALSE 75300
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
75231: LD_VAR 0 3
75235: PPUSH
75236: CALL_OW 310
75240: PPUSH
75241: CALL_OW 266
75245: PUSH
75246: LD_INT 5
75248: EQUAL
75249: PUSH
75250: LD_VAR 0 3
75254: PPUSH
75255: CALL_OW 257
75259: PUSH
75260: LD_INT 1
75262: EQUAL
75263: AND
75264: PUSH
75265: LD_VAR 0 3
75269: PPUSH
75270: CALL_OW 459
75274: NOT
75275: AND
75276: PUSH
75277: LD_VAR 0 7
75281: AND
75282: IFFALSE 75298
// ComChangeProfession ( j , class ) ;
75284: LD_VAR 0 3
75288: PPUSH
75289: LD_VAR 0 7
75293: PPUSH
75294: CALL_OW 123
75298: GO 75228
75300: POP
75301: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
75302: LD_EXP 84
75306: PUSH
75307: LD_VAR 0 2
75311: ARRAY
75312: PUSH
75313: LD_EXP 104
75317: PUSH
75318: LD_VAR 0 2
75322: ARRAY
75323: NOT
75324: AND
75325: PUSH
75326: LD_EXP 83
75330: PUSH
75331: LD_VAR 0 2
75335: ARRAY
75336: NOT
75337: AND
75338: PUSH
75339: LD_EXP 61
75343: PUSH
75344: LD_VAR 0 2
75348: ARRAY
75349: PPUSH
75350: LD_INT 50
75352: PUSH
75353: EMPTY
75354: LIST
75355: PUSH
75356: LD_INT 2
75358: PUSH
75359: LD_INT 30
75361: PUSH
75362: LD_INT 32
75364: PUSH
75365: EMPTY
75366: LIST
75367: LIST
75368: PUSH
75369: LD_INT 30
75371: PUSH
75372: LD_INT 33
75374: PUSH
75375: EMPTY
75376: LIST
75377: LIST
75378: PUSH
75379: LD_INT 30
75381: PUSH
75382: LD_INT 4
75384: PUSH
75385: EMPTY
75386: LIST
75387: LIST
75388: PUSH
75389: LD_INT 30
75391: PUSH
75392: LD_INT 5
75394: PUSH
75395: EMPTY
75396: LIST
75397: LIST
75398: PUSH
75399: EMPTY
75400: LIST
75401: LIST
75402: LIST
75403: LIST
75404: LIST
75405: PUSH
75406: EMPTY
75407: LIST
75408: LIST
75409: PPUSH
75410: CALL_OW 72
75414: PUSH
75415: LD_INT 4
75417: LESS
75418: PUSH
75419: LD_EXP 61
75423: PUSH
75424: LD_VAR 0 2
75428: ARRAY
75429: PPUSH
75430: LD_INT 3
75432: PUSH
75433: LD_INT 24
75435: PUSH
75436: LD_INT 1000
75438: PUSH
75439: EMPTY
75440: LIST
75441: LIST
75442: PUSH
75443: EMPTY
75444: LIST
75445: LIST
75446: PUSH
75447: LD_INT 2
75449: PUSH
75450: LD_INT 30
75452: PUSH
75453: LD_INT 0
75455: PUSH
75456: EMPTY
75457: LIST
75458: LIST
75459: PUSH
75460: LD_INT 30
75462: PUSH
75463: LD_INT 1
75465: PUSH
75466: EMPTY
75467: LIST
75468: LIST
75469: PUSH
75470: EMPTY
75471: LIST
75472: LIST
75473: LIST
75474: PUSH
75475: EMPTY
75476: LIST
75477: LIST
75478: PPUSH
75479: CALL_OW 72
75483: OR
75484: AND
75485: IFFALSE 75736
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
75487: LD_ADDR_EXP 104
75491: PUSH
75492: LD_EXP 104
75496: PPUSH
75497: LD_VAR 0 2
75501: PPUSH
75502: LD_INT 1
75504: PPUSH
75505: CALL_OW 1
75509: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
75510: LD_ADDR_VAR 0 4
75514: PUSH
75515: LD_EXP 61
75519: PUSH
75520: LD_VAR 0 2
75524: ARRAY
75525: PPUSH
75526: LD_INT 2
75528: PUSH
75529: LD_INT 25
75531: PUSH
75532: LD_INT 1
75534: PUSH
75535: EMPTY
75536: LIST
75537: LIST
75538: PUSH
75539: LD_INT 25
75541: PUSH
75542: LD_INT 5
75544: PUSH
75545: EMPTY
75546: LIST
75547: LIST
75548: PUSH
75549: LD_INT 25
75551: PUSH
75552: LD_INT 8
75554: PUSH
75555: EMPTY
75556: LIST
75557: LIST
75558: PUSH
75559: LD_INT 25
75561: PUSH
75562: LD_INT 9
75564: PUSH
75565: EMPTY
75566: LIST
75567: LIST
75568: PUSH
75569: EMPTY
75570: LIST
75571: LIST
75572: LIST
75573: LIST
75574: LIST
75575: PPUSH
75576: CALL_OW 72
75580: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
75581: LD_ADDR_VAR 0 4
75585: PUSH
75586: LD_VAR 0 4
75590: PUSH
75591: LD_VAR 0 4
75595: PPUSH
75596: LD_INT 18
75598: PPUSH
75599: CALL 51695 0 2
75603: DIFF
75604: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
75605: LD_VAR 0 4
75609: NOT
75610: PUSH
75611: LD_EXP 61
75615: PUSH
75616: LD_VAR 0 2
75620: ARRAY
75621: PPUSH
75622: LD_INT 2
75624: PUSH
75625: LD_INT 30
75627: PUSH
75628: LD_INT 4
75630: PUSH
75631: EMPTY
75632: LIST
75633: LIST
75634: PUSH
75635: LD_INT 30
75637: PUSH
75638: LD_INT 5
75640: PUSH
75641: EMPTY
75642: LIST
75643: LIST
75644: PUSH
75645: EMPTY
75646: LIST
75647: LIST
75648: LIST
75649: PPUSH
75650: CALL_OW 72
75654: NOT
75655: AND
75656: IFFALSE 75718
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
75658: LD_ADDR_VAR 0 4
75662: PUSH
75663: LD_EXP 61
75667: PUSH
75668: LD_VAR 0 2
75672: ARRAY
75673: PPUSH
75674: LD_INT 2
75676: PUSH
75677: LD_INT 25
75679: PUSH
75680: LD_INT 2
75682: PUSH
75683: EMPTY
75684: LIST
75685: LIST
75686: PUSH
75687: LD_INT 25
75689: PUSH
75690: LD_INT 3
75692: PUSH
75693: EMPTY
75694: LIST
75695: LIST
75696: PUSH
75697: LD_INT 25
75699: PUSH
75700: LD_INT 4
75702: PUSH
75703: EMPTY
75704: LIST
75705: LIST
75706: PUSH
75707: EMPTY
75708: LIST
75709: LIST
75710: LIST
75711: LIST
75712: PPUSH
75713: CALL_OW 72
75717: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
75718: LD_VAR 0 2
75722: PPUSH
75723: LD_VAR 0 4
75727: PPUSH
75728: CALL 115174 0 2
// exit ;
75732: POP
75733: POP
75734: GO 75856
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
75736: LD_EXP 84
75740: PUSH
75741: LD_VAR 0 2
75745: ARRAY
75746: PUSH
75747: LD_EXP 104
75751: PUSH
75752: LD_VAR 0 2
75756: ARRAY
75757: NOT
75758: AND
75759: PUSH
75760: LD_EXP 83
75764: PUSH
75765: LD_VAR 0 2
75769: ARRAY
75770: AND
75771: IFFALSE 75852
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
75773: LD_ADDR_EXP 104
75777: PUSH
75778: LD_EXP 104
75782: PPUSH
75783: LD_VAR 0 2
75787: PPUSH
75788: LD_INT 1
75790: PPUSH
75791: CALL_OW 1
75795: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
75796: LD_ADDR_VAR 0 4
75800: PUSH
75801: LD_EXP 83
75805: PUSH
75806: LD_VAR 0 2
75810: ARRAY
75811: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
75812: LD_ADDR_EXP 83
75816: PUSH
75817: LD_EXP 83
75821: PPUSH
75822: LD_VAR 0 2
75826: PPUSH
75827: EMPTY
75828: PPUSH
75829: CALL_OW 1
75833: ST_TO_ADDR
// Defend ( i , tmp ) ;
75834: LD_VAR 0 2
75838: PPUSH
75839: LD_VAR 0 4
75843: PPUSH
75844: CALL 115770 0 2
// exit ;
75848: POP
75849: POP
75850: GO 75856
// end ; end ;
75852: GO 75014
75854: POP
75855: POP
// end ;
75856: LD_VAR 0 1
75860: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
75861: LD_INT 0
75863: PPUSH
75864: PPUSH
75865: PPUSH
75866: PPUSH
75867: PPUSH
75868: PPUSH
75869: PPUSH
75870: PPUSH
75871: PPUSH
75872: PPUSH
75873: PPUSH
// if not mc_bases then
75874: LD_EXP 61
75878: NOT
75879: IFFALSE 75883
// exit ;
75881: GO 76970
// for i = 1 to mc_bases do
75883: LD_ADDR_VAR 0 2
75887: PUSH
75888: DOUBLE
75889: LD_INT 1
75891: DEC
75892: ST_TO_ADDR
75893: LD_EXP 61
75897: PUSH
75898: FOR_TO
75899: IFFALSE 76968
// begin tmp := mc_lab [ i ] ;
75901: LD_ADDR_VAR 0 6
75905: PUSH
75906: LD_EXP 94
75910: PUSH
75911: LD_VAR 0 2
75915: ARRAY
75916: ST_TO_ADDR
// if not tmp then
75917: LD_VAR 0 6
75921: NOT
75922: IFFALSE 75926
// continue ;
75924: GO 75898
// idle_lab := 0 ;
75926: LD_ADDR_VAR 0 11
75930: PUSH
75931: LD_INT 0
75933: ST_TO_ADDR
// for j in tmp do
75934: LD_ADDR_VAR 0 3
75938: PUSH
75939: LD_VAR 0 6
75943: PUSH
75944: FOR_IN
75945: IFFALSE 76964
// begin researching := false ;
75947: LD_ADDR_VAR 0 10
75951: PUSH
75952: LD_INT 0
75954: ST_TO_ADDR
// side := GetSide ( j ) ;
75955: LD_ADDR_VAR 0 4
75959: PUSH
75960: LD_VAR 0 3
75964: PPUSH
75965: CALL_OW 255
75969: ST_TO_ADDR
// if not mc_tech [ side ] then
75970: LD_EXP 88
75974: PUSH
75975: LD_VAR 0 4
75979: ARRAY
75980: NOT
75981: IFFALSE 75985
// continue ;
75983: GO 75944
// if BuildingStatus ( j ) = bs_idle then
75985: LD_VAR 0 3
75989: PPUSH
75990: CALL_OW 461
75994: PUSH
75995: LD_INT 2
75997: EQUAL
75998: IFFALSE 76186
// begin if idle_lab and UnitsInside ( j ) < 6 then
76000: LD_VAR 0 11
76004: PUSH
76005: LD_VAR 0 3
76009: PPUSH
76010: CALL_OW 313
76014: PUSH
76015: LD_INT 6
76017: LESS
76018: AND
76019: IFFALSE 76090
// begin tmp2 := UnitsInside ( idle_lab ) ;
76021: LD_ADDR_VAR 0 9
76025: PUSH
76026: LD_VAR 0 11
76030: PPUSH
76031: CALL_OW 313
76035: ST_TO_ADDR
// if tmp2 then
76036: LD_VAR 0 9
76040: IFFALSE 76082
// for x in tmp2 do
76042: LD_ADDR_VAR 0 7
76046: PUSH
76047: LD_VAR 0 9
76051: PUSH
76052: FOR_IN
76053: IFFALSE 76080
// begin ComExitBuilding ( x ) ;
76055: LD_VAR 0 7
76059: PPUSH
76060: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
76064: LD_VAR 0 7
76068: PPUSH
76069: LD_VAR 0 3
76073: PPUSH
76074: CALL_OW 180
// end ;
76078: GO 76052
76080: POP
76081: POP
// idle_lab := 0 ;
76082: LD_ADDR_VAR 0 11
76086: PUSH
76087: LD_INT 0
76089: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
76090: LD_ADDR_VAR 0 5
76094: PUSH
76095: LD_EXP 88
76099: PUSH
76100: LD_VAR 0 4
76104: ARRAY
76105: PUSH
76106: FOR_IN
76107: IFFALSE 76167
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
76109: LD_VAR 0 3
76113: PPUSH
76114: LD_VAR 0 5
76118: PPUSH
76119: CALL_OW 430
76123: PUSH
76124: LD_VAR 0 4
76128: PPUSH
76129: LD_VAR 0 5
76133: PPUSH
76134: CALL 17291 0 2
76138: AND
76139: IFFALSE 76165
// begin researching := true ;
76141: LD_ADDR_VAR 0 10
76145: PUSH
76146: LD_INT 1
76148: ST_TO_ADDR
// ComResearch ( j , t ) ;
76149: LD_VAR 0 3
76153: PPUSH
76154: LD_VAR 0 5
76158: PPUSH
76159: CALL_OW 124
// break ;
76163: GO 76167
// end ;
76165: GO 76106
76167: POP
76168: POP
// if not researching then
76169: LD_VAR 0 10
76173: NOT
76174: IFFALSE 76186
// idle_lab := j ;
76176: LD_ADDR_VAR 0 11
76180: PUSH
76181: LD_VAR 0 3
76185: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
76186: LD_VAR 0 3
76190: PPUSH
76191: CALL_OW 461
76195: PUSH
76196: LD_INT 10
76198: EQUAL
76199: IFFALSE 76787
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
76201: LD_EXP 90
76205: PUSH
76206: LD_VAR 0 2
76210: ARRAY
76211: NOT
76212: PUSH
76213: LD_EXP 91
76217: PUSH
76218: LD_VAR 0 2
76222: ARRAY
76223: NOT
76224: AND
76225: PUSH
76226: LD_EXP 88
76230: PUSH
76231: LD_VAR 0 4
76235: ARRAY
76236: PUSH
76237: LD_INT 1
76239: GREATER
76240: AND
76241: IFFALSE 76372
// begin ComCancel ( j ) ;
76243: LD_VAR 0 3
76247: PPUSH
76248: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
76252: LD_ADDR_EXP 88
76256: PUSH
76257: LD_EXP 88
76261: PPUSH
76262: LD_VAR 0 4
76266: PPUSH
76267: LD_EXP 88
76271: PUSH
76272: LD_VAR 0 4
76276: ARRAY
76277: PPUSH
76278: LD_EXP 88
76282: PUSH
76283: LD_VAR 0 4
76287: ARRAY
76288: PUSH
76289: LD_INT 1
76291: MINUS
76292: PPUSH
76293: LD_EXP 88
76297: PUSH
76298: LD_VAR 0 4
76302: ARRAY
76303: PPUSH
76304: LD_INT 0
76306: PPUSH
76307: CALL 20815 0 4
76311: PPUSH
76312: CALL_OW 1
76316: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
76317: LD_ADDR_EXP 88
76321: PUSH
76322: LD_EXP 88
76326: PPUSH
76327: LD_VAR 0 4
76331: PPUSH
76332: LD_EXP 88
76336: PUSH
76337: LD_VAR 0 4
76341: ARRAY
76342: PPUSH
76343: LD_EXP 88
76347: PUSH
76348: LD_VAR 0 4
76352: ARRAY
76353: PPUSH
76354: LD_INT 1
76356: PPUSH
76357: LD_INT 0
76359: PPUSH
76360: CALL 20815 0 4
76364: PPUSH
76365: CALL_OW 1
76369: ST_TO_ADDR
// continue ;
76370: GO 75944
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
76372: LD_EXP 90
76376: PUSH
76377: LD_VAR 0 2
76381: ARRAY
76382: PUSH
76383: LD_EXP 91
76387: PUSH
76388: LD_VAR 0 2
76392: ARRAY
76393: NOT
76394: AND
76395: IFFALSE 76522
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
76397: LD_ADDR_EXP 91
76401: PUSH
76402: LD_EXP 91
76406: PPUSH
76407: LD_VAR 0 2
76411: PUSH
76412: LD_EXP 91
76416: PUSH
76417: LD_VAR 0 2
76421: ARRAY
76422: PUSH
76423: LD_INT 1
76425: PLUS
76426: PUSH
76427: EMPTY
76428: LIST
76429: LIST
76430: PPUSH
76431: LD_EXP 90
76435: PUSH
76436: LD_VAR 0 2
76440: ARRAY
76441: PUSH
76442: LD_INT 1
76444: ARRAY
76445: PPUSH
76446: CALL 21397 0 3
76450: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
76451: LD_EXP 90
76455: PUSH
76456: LD_VAR 0 2
76460: ARRAY
76461: PUSH
76462: LD_INT 1
76464: ARRAY
76465: PPUSH
76466: LD_INT 112
76468: PPUSH
76469: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
76473: LD_ADDR_VAR 0 9
76477: PUSH
76478: LD_EXP 90
76482: PUSH
76483: LD_VAR 0 2
76487: ARRAY
76488: PPUSH
76489: LD_INT 1
76491: PPUSH
76492: CALL_OW 3
76496: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
76497: LD_ADDR_EXP 90
76501: PUSH
76502: LD_EXP 90
76506: PPUSH
76507: LD_VAR 0 2
76511: PPUSH
76512: LD_VAR 0 9
76516: PPUSH
76517: CALL_OW 1
76521: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
76522: LD_EXP 90
76526: PUSH
76527: LD_VAR 0 2
76531: ARRAY
76532: PUSH
76533: LD_EXP 91
76537: PUSH
76538: LD_VAR 0 2
76542: ARRAY
76543: AND
76544: PUSH
76545: LD_EXP 91
76549: PUSH
76550: LD_VAR 0 2
76554: ARRAY
76555: PUSH
76556: LD_INT 1
76558: ARRAY
76559: PPUSH
76560: CALL_OW 310
76564: NOT
76565: AND
76566: PUSH
76567: LD_VAR 0 3
76571: PPUSH
76572: CALL_OW 313
76576: PUSH
76577: LD_INT 6
76579: EQUAL
76580: AND
76581: IFFALSE 76637
// begin tmp2 := UnitsInside ( j ) ;
76583: LD_ADDR_VAR 0 9
76587: PUSH
76588: LD_VAR 0 3
76592: PPUSH
76593: CALL_OW 313
76597: ST_TO_ADDR
// if tmp2 = 6 then
76598: LD_VAR 0 9
76602: PUSH
76603: LD_INT 6
76605: EQUAL
76606: IFFALSE 76637
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
76608: LD_VAR 0 9
76612: PUSH
76613: LD_INT 1
76615: ARRAY
76616: PPUSH
76617: LD_INT 112
76619: PPUSH
76620: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
76624: LD_VAR 0 9
76628: PUSH
76629: LD_INT 1
76631: ARRAY
76632: PPUSH
76633: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
76637: LD_EXP 91
76641: PUSH
76642: LD_VAR 0 2
76646: ARRAY
76647: PUSH
76648: LD_EXP 91
76652: PUSH
76653: LD_VAR 0 2
76657: ARRAY
76658: PUSH
76659: LD_INT 1
76661: ARRAY
76662: PPUSH
76663: CALL_OW 314
76667: NOT
76668: AND
76669: PUSH
76670: LD_EXP 91
76674: PUSH
76675: LD_VAR 0 2
76679: ARRAY
76680: PUSH
76681: LD_INT 1
76683: ARRAY
76684: PPUSH
76685: CALL_OW 310
76689: NOT
76690: AND
76691: IFFALSE 76717
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
76693: LD_EXP 91
76697: PUSH
76698: LD_VAR 0 2
76702: ARRAY
76703: PUSH
76704: LD_INT 1
76706: ARRAY
76707: PPUSH
76708: LD_VAR 0 3
76712: PPUSH
76713: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
76717: LD_EXP 91
76721: PUSH
76722: LD_VAR 0 2
76726: ARRAY
76727: PUSH
76728: LD_INT 1
76730: ARRAY
76731: PPUSH
76732: CALL_OW 310
76736: PUSH
76737: LD_EXP 91
76741: PUSH
76742: LD_VAR 0 2
76746: ARRAY
76747: PUSH
76748: LD_INT 1
76750: ARRAY
76751: PPUSH
76752: CALL_OW 310
76756: PPUSH
76757: CALL_OW 461
76761: PUSH
76762: LD_INT 3
76764: NONEQUAL
76765: AND
76766: IFFALSE 76787
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
76768: LD_EXP 91
76772: PUSH
76773: LD_VAR 0 2
76777: ARRAY
76778: PUSH
76779: LD_INT 1
76781: ARRAY
76782: PPUSH
76783: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
76787: LD_VAR 0 3
76791: PPUSH
76792: CALL_OW 461
76796: PUSH
76797: LD_INT 6
76799: EQUAL
76800: PUSH
76801: LD_VAR 0 6
76805: PUSH
76806: LD_INT 1
76808: GREATER
76809: AND
76810: IFFALSE 76962
// begin sci := [ ] ;
76812: LD_ADDR_VAR 0 8
76816: PUSH
76817: EMPTY
76818: ST_TO_ADDR
// for x in ( tmp diff j ) do
76819: LD_ADDR_VAR 0 7
76823: PUSH
76824: LD_VAR 0 6
76828: PUSH
76829: LD_VAR 0 3
76833: DIFF
76834: PUSH
76835: FOR_IN
76836: IFFALSE 76888
// begin if sci = 6 then
76838: LD_VAR 0 8
76842: PUSH
76843: LD_INT 6
76845: EQUAL
76846: IFFALSE 76850
// break ;
76848: GO 76888
// if BuildingStatus ( x ) = bs_idle then
76850: LD_VAR 0 7
76854: PPUSH
76855: CALL_OW 461
76859: PUSH
76860: LD_INT 2
76862: EQUAL
76863: IFFALSE 76886
// sci := sci ^ UnitsInside ( x ) ;
76865: LD_ADDR_VAR 0 8
76869: PUSH
76870: LD_VAR 0 8
76874: PUSH
76875: LD_VAR 0 7
76879: PPUSH
76880: CALL_OW 313
76884: ADD
76885: ST_TO_ADDR
// end ;
76886: GO 76835
76888: POP
76889: POP
// if not sci then
76890: LD_VAR 0 8
76894: NOT
76895: IFFALSE 76899
// continue ;
76897: GO 75944
// for x in sci do
76899: LD_ADDR_VAR 0 7
76903: PUSH
76904: LD_VAR 0 8
76908: PUSH
76909: FOR_IN
76910: IFFALSE 76960
// if IsInUnit ( x ) and not HasTask ( x ) then
76912: LD_VAR 0 7
76916: PPUSH
76917: CALL_OW 310
76921: PUSH
76922: LD_VAR 0 7
76926: PPUSH
76927: CALL_OW 314
76931: NOT
76932: AND
76933: IFFALSE 76958
// begin ComExitBuilding ( x ) ;
76935: LD_VAR 0 7
76939: PPUSH
76940: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
76944: LD_VAR 0 7
76948: PPUSH
76949: LD_VAR 0 3
76953: PPUSH
76954: CALL_OW 180
// end ;
76958: GO 76909
76960: POP
76961: POP
// end ; end ;
76962: GO 75944
76964: POP
76965: POP
// end ;
76966: GO 75898
76968: POP
76969: POP
// end ;
76970: LD_VAR 0 1
76974: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
76975: LD_INT 0
76977: PPUSH
76978: PPUSH
// if not mc_bases then
76979: LD_EXP 61
76983: NOT
76984: IFFALSE 76988
// exit ;
76986: GO 77069
// for i = 1 to mc_bases do
76988: LD_ADDR_VAR 0 2
76992: PUSH
76993: DOUBLE
76994: LD_INT 1
76996: DEC
76997: ST_TO_ADDR
76998: LD_EXP 61
77002: PUSH
77003: FOR_TO
77004: IFFALSE 77067
// if mc_mines [ i ] and mc_miners [ i ] then
77006: LD_EXP 74
77010: PUSH
77011: LD_VAR 0 2
77015: ARRAY
77016: PUSH
77017: LD_EXP 75
77021: PUSH
77022: LD_VAR 0 2
77026: ARRAY
77027: AND
77028: IFFALSE 77065
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
77030: LD_EXP 75
77034: PUSH
77035: LD_VAR 0 2
77039: ARRAY
77040: PUSH
77041: LD_INT 1
77043: ARRAY
77044: PPUSH
77045: CALL_OW 255
77049: PPUSH
77050: LD_EXP 74
77054: PUSH
77055: LD_VAR 0 2
77059: ARRAY
77060: PPUSH
77061: CALL 18374 0 2
77065: GO 77003
77067: POP
77068: POP
// end ;
77069: LD_VAR 0 1
77073: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
77074: LD_INT 0
77076: PPUSH
77077: PPUSH
77078: PPUSH
77079: PPUSH
77080: PPUSH
77081: PPUSH
77082: PPUSH
77083: PPUSH
// if not mc_bases or not mc_parking then
77084: LD_EXP 61
77088: NOT
77089: PUSH
77090: LD_EXP 85
77094: NOT
77095: OR
77096: IFFALSE 77100
// exit ;
77098: GO 77838
// for i = 1 to mc_bases do
77100: LD_ADDR_VAR 0 2
77104: PUSH
77105: DOUBLE
77106: LD_INT 1
77108: DEC
77109: ST_TO_ADDR
77110: LD_EXP 61
77114: PUSH
77115: FOR_TO
77116: IFFALSE 77836
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
77118: LD_EXP 61
77122: PUSH
77123: LD_VAR 0 2
77127: ARRAY
77128: NOT
77129: PUSH
77130: LD_EXP 85
77134: PUSH
77135: LD_VAR 0 2
77139: ARRAY
77140: NOT
77141: OR
77142: IFFALSE 77146
// continue ;
77144: GO 77115
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
77146: LD_ADDR_VAR 0 5
77150: PUSH
77151: LD_EXP 61
77155: PUSH
77156: LD_VAR 0 2
77160: ARRAY
77161: PUSH
77162: LD_INT 1
77164: ARRAY
77165: PPUSH
77166: CALL_OW 255
77170: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
77171: LD_ADDR_VAR 0 6
77175: PUSH
77176: LD_EXP 61
77180: PUSH
77181: LD_VAR 0 2
77185: ARRAY
77186: PPUSH
77187: LD_INT 30
77189: PUSH
77190: LD_INT 3
77192: PUSH
77193: EMPTY
77194: LIST
77195: LIST
77196: PPUSH
77197: CALL_OW 72
77201: ST_TO_ADDR
// if not fac then
77202: LD_VAR 0 6
77206: NOT
77207: IFFALSE 77258
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77209: LD_ADDR_VAR 0 6
77213: PUSH
77214: LD_EXP 61
77218: PUSH
77219: LD_VAR 0 2
77223: ARRAY
77224: PPUSH
77225: LD_INT 2
77227: PUSH
77228: LD_INT 30
77230: PUSH
77231: LD_INT 0
77233: PUSH
77234: EMPTY
77235: LIST
77236: LIST
77237: PUSH
77238: LD_INT 30
77240: PUSH
77241: LD_INT 1
77243: PUSH
77244: EMPTY
77245: LIST
77246: LIST
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: LIST
77252: PPUSH
77253: CALL_OW 72
77257: ST_TO_ADDR
// if not fac then
77258: LD_VAR 0 6
77262: NOT
77263: IFFALSE 77267
// continue ;
77265: GO 77115
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
77267: LD_ADDR_VAR 0 7
77271: PUSH
77272: LD_EXP 85
77276: PUSH
77277: LD_VAR 0 2
77281: ARRAY
77282: PPUSH
77283: LD_INT 22
77285: PUSH
77286: LD_VAR 0 5
77290: PUSH
77291: EMPTY
77292: LIST
77293: LIST
77294: PUSH
77295: LD_INT 21
77297: PUSH
77298: LD_INT 2
77300: PUSH
77301: EMPTY
77302: LIST
77303: LIST
77304: PUSH
77305: LD_INT 3
77307: PUSH
77308: LD_INT 60
77310: PUSH
77311: EMPTY
77312: LIST
77313: PUSH
77314: EMPTY
77315: LIST
77316: LIST
77317: PUSH
77318: LD_INT 3
77320: PUSH
77321: LD_INT 24
77323: PUSH
77324: LD_INT 1000
77326: PUSH
77327: EMPTY
77328: LIST
77329: LIST
77330: PUSH
77331: EMPTY
77332: LIST
77333: LIST
77334: PUSH
77335: EMPTY
77336: LIST
77337: LIST
77338: LIST
77339: LIST
77340: PPUSH
77341: CALL_OW 70
77345: ST_TO_ADDR
// for j in fac do
77346: LD_ADDR_VAR 0 3
77350: PUSH
77351: LD_VAR 0 6
77355: PUSH
77356: FOR_IN
77357: IFFALSE 77452
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
77359: LD_ADDR_VAR 0 7
77363: PUSH
77364: LD_VAR 0 7
77368: PUSH
77369: LD_INT 22
77371: PUSH
77372: LD_VAR 0 5
77376: PUSH
77377: EMPTY
77378: LIST
77379: LIST
77380: PUSH
77381: LD_INT 91
77383: PUSH
77384: LD_VAR 0 3
77388: PUSH
77389: LD_INT 15
77391: PUSH
77392: EMPTY
77393: LIST
77394: LIST
77395: LIST
77396: PUSH
77397: LD_INT 21
77399: PUSH
77400: LD_INT 2
77402: PUSH
77403: EMPTY
77404: LIST
77405: LIST
77406: PUSH
77407: LD_INT 3
77409: PUSH
77410: LD_INT 60
77412: PUSH
77413: EMPTY
77414: LIST
77415: PUSH
77416: EMPTY
77417: LIST
77418: LIST
77419: PUSH
77420: LD_INT 3
77422: PUSH
77423: LD_INT 24
77425: PUSH
77426: LD_INT 1000
77428: PUSH
77429: EMPTY
77430: LIST
77431: LIST
77432: PUSH
77433: EMPTY
77434: LIST
77435: LIST
77436: PUSH
77437: EMPTY
77438: LIST
77439: LIST
77440: LIST
77441: LIST
77442: LIST
77443: PPUSH
77444: CALL_OW 69
77448: UNION
77449: ST_TO_ADDR
77450: GO 77356
77452: POP
77453: POP
// if not vehs then
77454: LD_VAR 0 7
77458: NOT
77459: IFFALSE 77485
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
77461: LD_ADDR_EXP 73
77465: PUSH
77466: LD_EXP 73
77470: PPUSH
77471: LD_VAR 0 2
77475: PPUSH
77476: EMPTY
77477: PPUSH
77478: CALL_OW 1
77482: ST_TO_ADDR
// continue ;
77483: GO 77115
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
77485: LD_ADDR_VAR 0 8
77489: PUSH
77490: LD_EXP 61
77494: PUSH
77495: LD_VAR 0 2
77499: ARRAY
77500: PPUSH
77501: LD_INT 30
77503: PUSH
77504: LD_INT 3
77506: PUSH
77507: EMPTY
77508: LIST
77509: LIST
77510: PPUSH
77511: CALL_OW 72
77515: ST_TO_ADDR
// if tmp then
77516: LD_VAR 0 8
77520: IFFALSE 77623
// begin for j in tmp do
77522: LD_ADDR_VAR 0 3
77526: PUSH
77527: LD_VAR 0 8
77531: PUSH
77532: FOR_IN
77533: IFFALSE 77621
// for k in UnitsInside ( j ) do
77535: LD_ADDR_VAR 0 4
77539: PUSH
77540: LD_VAR 0 3
77544: PPUSH
77545: CALL_OW 313
77549: PUSH
77550: FOR_IN
77551: IFFALSE 77617
// if k then
77553: LD_VAR 0 4
77557: IFFALSE 77615
// if not k in mc_repair_vehicle [ i ] then
77559: LD_VAR 0 4
77563: PUSH
77564: LD_EXP 73
77568: PUSH
77569: LD_VAR 0 2
77573: ARRAY
77574: IN
77575: NOT
77576: IFFALSE 77615
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
77578: LD_ADDR_EXP 73
77582: PUSH
77583: LD_EXP 73
77587: PPUSH
77588: LD_VAR 0 2
77592: PPUSH
77593: LD_EXP 73
77597: PUSH
77598: LD_VAR 0 2
77602: ARRAY
77603: PUSH
77604: LD_VAR 0 4
77608: UNION
77609: PPUSH
77610: CALL_OW 1
77614: ST_TO_ADDR
77615: GO 77550
77617: POP
77618: POP
77619: GO 77532
77621: POP
77622: POP
// end ; if not mc_repair_vehicle [ i ] then
77623: LD_EXP 73
77627: PUSH
77628: LD_VAR 0 2
77632: ARRAY
77633: NOT
77634: IFFALSE 77638
// continue ;
77636: GO 77115
// for j in mc_repair_vehicle [ i ] do
77638: LD_ADDR_VAR 0 3
77642: PUSH
77643: LD_EXP 73
77647: PUSH
77648: LD_VAR 0 2
77652: ARRAY
77653: PUSH
77654: FOR_IN
77655: IFFALSE 77832
// begin if GetClass ( j ) <> 3 then
77657: LD_VAR 0 3
77661: PPUSH
77662: CALL_OW 257
77666: PUSH
77667: LD_INT 3
77669: NONEQUAL
77670: IFFALSE 77711
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
77672: LD_ADDR_EXP 73
77676: PUSH
77677: LD_EXP 73
77681: PPUSH
77682: LD_VAR 0 2
77686: PPUSH
77687: LD_EXP 73
77691: PUSH
77692: LD_VAR 0 2
77696: ARRAY
77697: PUSH
77698: LD_VAR 0 3
77702: DIFF
77703: PPUSH
77704: CALL_OW 1
77708: ST_TO_ADDR
// continue ;
77709: GO 77654
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
77711: LD_VAR 0 3
77715: PPUSH
77716: CALL_OW 311
77720: NOT
77721: PUSH
77722: LD_VAR 0 3
77726: PUSH
77727: LD_EXP 64
77731: PUSH
77732: LD_VAR 0 2
77736: ARRAY
77737: PUSH
77738: LD_INT 1
77740: ARRAY
77741: IN
77742: NOT
77743: AND
77744: PUSH
77745: LD_VAR 0 3
77749: PUSH
77750: LD_EXP 64
77754: PUSH
77755: LD_VAR 0 2
77759: ARRAY
77760: PUSH
77761: LD_INT 2
77763: ARRAY
77764: IN
77765: NOT
77766: AND
77767: IFFALSE 77830
// begin if IsInUnit ( j ) then
77769: LD_VAR 0 3
77773: PPUSH
77774: CALL_OW 310
77778: IFFALSE 77791
// ComExitBuilding ( j ) else
77780: LD_VAR 0 3
77784: PPUSH
77785: CALL_OW 122
77789: GO 77830
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
77791: LD_VAR 0 3
77795: PPUSH
77796: LD_VAR 0 7
77800: PUSH
77801: LD_INT 1
77803: ARRAY
77804: PPUSH
77805: CALL 56191 0 2
77809: NOT
77810: IFFALSE 77830
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
77812: LD_VAR 0 3
77816: PPUSH
77817: LD_VAR 0 7
77821: PUSH
77822: LD_INT 1
77824: ARRAY
77825: PPUSH
77826: CALL_OW 129
// end ; end ;
77830: GO 77654
77832: POP
77833: POP
// end ;
77834: GO 77115
77836: POP
77837: POP
// end ;
77838: LD_VAR 0 1
77842: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
77843: LD_INT 0
77845: PPUSH
77846: PPUSH
77847: PPUSH
77848: PPUSH
77849: PPUSH
77850: PPUSH
77851: PPUSH
77852: PPUSH
77853: PPUSH
77854: PPUSH
77855: PPUSH
// if not mc_bases then
77856: LD_EXP 61
77860: NOT
77861: IFFALSE 77865
// exit ;
77863: GO 78667
// for i = 1 to mc_bases do
77865: LD_ADDR_VAR 0 2
77869: PUSH
77870: DOUBLE
77871: LD_INT 1
77873: DEC
77874: ST_TO_ADDR
77875: LD_EXP 61
77879: PUSH
77880: FOR_TO
77881: IFFALSE 78665
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
77883: LD_EXP 89
77887: PUSH
77888: LD_VAR 0 2
77892: ARRAY
77893: NOT
77894: PUSH
77895: LD_EXP 64
77899: PUSH
77900: LD_VAR 0 2
77904: ARRAY
77905: PUSH
77906: LD_INT 1
77908: ARRAY
77909: OR
77910: PUSH
77911: LD_EXP 64
77915: PUSH
77916: LD_VAR 0 2
77920: ARRAY
77921: PUSH
77922: LD_INT 2
77924: ARRAY
77925: OR
77926: PUSH
77927: LD_EXP 87
77931: PUSH
77932: LD_VAR 0 2
77936: ARRAY
77937: PPUSH
77938: LD_INT 1
77940: PPUSH
77941: CALL_OW 325
77945: NOT
77946: OR
77947: PUSH
77948: LD_EXP 84
77952: PUSH
77953: LD_VAR 0 2
77957: ARRAY
77958: OR
77959: IFFALSE 77963
// continue ;
77961: GO 77880
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
77963: LD_ADDR_VAR 0 8
77967: PUSH
77968: LD_EXP 61
77972: PUSH
77973: LD_VAR 0 2
77977: ARRAY
77978: PPUSH
77979: LD_INT 25
77981: PUSH
77982: LD_INT 4
77984: PUSH
77985: EMPTY
77986: LIST
77987: LIST
77988: PUSH
77989: LD_INT 50
77991: PUSH
77992: EMPTY
77993: LIST
77994: PUSH
77995: LD_INT 3
77997: PUSH
77998: LD_INT 60
78000: PUSH
78001: EMPTY
78002: LIST
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: PUSH
78008: EMPTY
78009: LIST
78010: LIST
78011: LIST
78012: PPUSH
78013: CALL_OW 72
78017: PUSH
78018: LD_EXP 65
78022: PUSH
78023: LD_VAR 0 2
78027: ARRAY
78028: DIFF
78029: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78030: LD_ADDR_VAR 0 9
78034: PUSH
78035: LD_EXP 61
78039: PUSH
78040: LD_VAR 0 2
78044: ARRAY
78045: PPUSH
78046: LD_INT 2
78048: PUSH
78049: LD_INT 30
78051: PUSH
78052: LD_INT 0
78054: PUSH
78055: EMPTY
78056: LIST
78057: LIST
78058: PUSH
78059: LD_INT 30
78061: PUSH
78062: LD_INT 1
78064: PUSH
78065: EMPTY
78066: LIST
78067: LIST
78068: PUSH
78069: EMPTY
78070: LIST
78071: LIST
78072: LIST
78073: PPUSH
78074: CALL_OW 72
78078: ST_TO_ADDR
// if not tmp or not dep then
78079: LD_VAR 0 8
78083: NOT
78084: PUSH
78085: LD_VAR 0 9
78089: NOT
78090: OR
78091: IFFALSE 78095
// continue ;
78093: GO 77880
// side := GetSide ( tmp [ 1 ] ) ;
78095: LD_ADDR_VAR 0 11
78099: PUSH
78100: LD_VAR 0 8
78104: PUSH
78105: LD_INT 1
78107: ARRAY
78108: PPUSH
78109: CALL_OW 255
78113: ST_TO_ADDR
// dep := dep [ 1 ] ;
78114: LD_ADDR_VAR 0 9
78118: PUSH
78119: LD_VAR 0 9
78123: PUSH
78124: LD_INT 1
78126: ARRAY
78127: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
78128: LD_ADDR_VAR 0 7
78132: PUSH
78133: LD_EXP 89
78137: PUSH
78138: LD_VAR 0 2
78142: ARRAY
78143: PPUSH
78144: LD_INT 22
78146: PUSH
78147: LD_INT 0
78149: PUSH
78150: EMPTY
78151: LIST
78152: LIST
78153: PUSH
78154: LD_INT 25
78156: PUSH
78157: LD_INT 12
78159: PUSH
78160: EMPTY
78161: LIST
78162: LIST
78163: PUSH
78164: EMPTY
78165: LIST
78166: LIST
78167: PPUSH
78168: CALL_OW 70
78172: PUSH
78173: LD_INT 22
78175: PUSH
78176: LD_INT 0
78178: PUSH
78179: EMPTY
78180: LIST
78181: LIST
78182: PUSH
78183: LD_INT 25
78185: PUSH
78186: LD_INT 12
78188: PUSH
78189: EMPTY
78190: LIST
78191: LIST
78192: PUSH
78193: LD_INT 91
78195: PUSH
78196: LD_VAR 0 9
78200: PUSH
78201: LD_INT 20
78203: PUSH
78204: EMPTY
78205: LIST
78206: LIST
78207: LIST
78208: PUSH
78209: EMPTY
78210: LIST
78211: LIST
78212: LIST
78213: PPUSH
78214: CALL_OW 69
78218: UNION
78219: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
78220: LD_ADDR_VAR 0 10
78224: PUSH
78225: LD_EXP 89
78229: PUSH
78230: LD_VAR 0 2
78234: ARRAY
78235: PPUSH
78236: LD_INT 81
78238: PUSH
78239: LD_VAR 0 11
78243: PUSH
78244: EMPTY
78245: LIST
78246: LIST
78247: PPUSH
78248: CALL_OW 70
78252: ST_TO_ADDR
// if not apes or danger_at_area then
78253: LD_VAR 0 7
78257: NOT
78258: PUSH
78259: LD_VAR 0 10
78263: OR
78264: IFFALSE 78314
// begin if mc_taming [ i ] then
78266: LD_EXP 92
78270: PUSH
78271: LD_VAR 0 2
78275: ARRAY
78276: IFFALSE 78312
// begin MC_Reset ( i , 121 ) ;
78278: LD_VAR 0 2
78282: PPUSH
78283: LD_INT 121
78285: PPUSH
78286: CALL 63230 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
78290: LD_ADDR_EXP 92
78294: PUSH
78295: LD_EXP 92
78299: PPUSH
78300: LD_VAR 0 2
78304: PPUSH
78305: EMPTY
78306: PPUSH
78307: CALL_OW 1
78311: ST_TO_ADDR
// end ; continue ;
78312: GO 77880
// end ; for j in tmp do
78314: LD_ADDR_VAR 0 3
78318: PUSH
78319: LD_VAR 0 8
78323: PUSH
78324: FOR_IN
78325: IFFALSE 78661
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
78327: LD_VAR 0 3
78331: PUSH
78332: LD_EXP 92
78336: PUSH
78337: LD_VAR 0 2
78341: ARRAY
78342: IN
78343: NOT
78344: PUSH
78345: LD_EXP 92
78349: PUSH
78350: LD_VAR 0 2
78354: ARRAY
78355: PUSH
78356: LD_INT 3
78358: LESS
78359: AND
78360: IFFALSE 78418
// begin SetTag ( j , 121 ) ;
78362: LD_VAR 0 3
78366: PPUSH
78367: LD_INT 121
78369: PPUSH
78370: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
78374: LD_ADDR_EXP 92
78378: PUSH
78379: LD_EXP 92
78383: PPUSH
78384: LD_VAR 0 2
78388: PUSH
78389: LD_EXP 92
78393: PUSH
78394: LD_VAR 0 2
78398: ARRAY
78399: PUSH
78400: LD_INT 1
78402: PLUS
78403: PUSH
78404: EMPTY
78405: LIST
78406: LIST
78407: PPUSH
78408: LD_VAR 0 3
78412: PPUSH
78413: CALL 21397 0 3
78417: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
78418: LD_VAR 0 3
78422: PUSH
78423: LD_EXP 92
78427: PUSH
78428: LD_VAR 0 2
78432: ARRAY
78433: IN
78434: IFFALSE 78659
// begin if GetClass ( j ) <> 4 then
78436: LD_VAR 0 3
78440: PPUSH
78441: CALL_OW 257
78445: PUSH
78446: LD_INT 4
78448: NONEQUAL
78449: IFFALSE 78502
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
78451: LD_ADDR_EXP 92
78455: PUSH
78456: LD_EXP 92
78460: PPUSH
78461: LD_VAR 0 2
78465: PPUSH
78466: LD_EXP 92
78470: PUSH
78471: LD_VAR 0 2
78475: ARRAY
78476: PUSH
78477: LD_VAR 0 3
78481: DIFF
78482: PPUSH
78483: CALL_OW 1
78487: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78488: LD_VAR 0 3
78492: PPUSH
78493: LD_INT 0
78495: PPUSH
78496: CALL_OW 109
// continue ;
78500: GO 78324
// end ; if IsInUnit ( j ) then
78502: LD_VAR 0 3
78506: PPUSH
78507: CALL_OW 310
78511: IFFALSE 78522
// ComExitBuilding ( j ) ;
78513: LD_VAR 0 3
78517: PPUSH
78518: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
78522: LD_ADDR_VAR 0 6
78526: PUSH
78527: LD_VAR 0 7
78531: PPUSH
78532: LD_VAR 0 3
78536: PPUSH
78537: CALL_OW 74
78541: ST_TO_ADDR
// if not ape then
78542: LD_VAR 0 6
78546: NOT
78547: IFFALSE 78551
// break ;
78549: GO 78661
// x := GetX ( ape ) ;
78551: LD_ADDR_VAR 0 4
78555: PUSH
78556: LD_VAR 0 6
78560: PPUSH
78561: CALL_OW 250
78565: ST_TO_ADDR
// y := GetY ( ape ) ;
78566: LD_ADDR_VAR 0 5
78570: PUSH
78571: LD_VAR 0 6
78575: PPUSH
78576: CALL_OW 251
78580: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78581: LD_VAR 0 4
78585: PPUSH
78586: LD_VAR 0 5
78590: PPUSH
78591: CALL_OW 488
78595: NOT
78596: PUSH
78597: LD_VAR 0 11
78601: PPUSH
78602: LD_VAR 0 4
78606: PPUSH
78607: LD_VAR 0 5
78611: PPUSH
78612: LD_INT 20
78614: PPUSH
78615: CALL 22661 0 4
78619: PUSH
78620: LD_INT 4
78622: ARRAY
78623: OR
78624: IFFALSE 78628
// break ;
78626: GO 78661
// if not HasTask ( j ) then
78628: LD_VAR 0 3
78632: PPUSH
78633: CALL_OW 314
78637: NOT
78638: IFFALSE 78659
// ComTameXY ( j , x , y ) ;
78640: LD_VAR 0 3
78644: PPUSH
78645: LD_VAR 0 4
78649: PPUSH
78650: LD_VAR 0 5
78654: PPUSH
78655: CALL_OW 131
// end ; end ;
78659: GO 78324
78661: POP
78662: POP
// end ;
78663: GO 77880
78665: POP
78666: POP
// end ;
78667: LD_VAR 0 1
78671: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
78672: LD_INT 0
78674: PPUSH
78675: PPUSH
78676: PPUSH
78677: PPUSH
78678: PPUSH
78679: PPUSH
78680: PPUSH
78681: PPUSH
// if not mc_bases then
78682: LD_EXP 61
78686: NOT
78687: IFFALSE 78691
// exit ;
78689: GO 79317
// for i = 1 to mc_bases do
78691: LD_ADDR_VAR 0 2
78695: PUSH
78696: DOUBLE
78697: LD_INT 1
78699: DEC
78700: ST_TO_ADDR
78701: LD_EXP 61
78705: PUSH
78706: FOR_TO
78707: IFFALSE 79315
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
78709: LD_EXP 90
78713: PUSH
78714: LD_VAR 0 2
78718: ARRAY
78719: NOT
78720: PUSH
78721: LD_EXP 90
78725: PUSH
78726: LD_VAR 0 2
78730: ARRAY
78731: PPUSH
78732: LD_INT 25
78734: PUSH
78735: LD_INT 12
78737: PUSH
78738: EMPTY
78739: LIST
78740: LIST
78741: PPUSH
78742: CALL_OW 72
78746: NOT
78747: OR
78748: IFFALSE 78752
// continue ;
78750: GO 78706
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
78752: LD_ADDR_VAR 0 5
78756: PUSH
78757: LD_EXP 90
78761: PUSH
78762: LD_VAR 0 2
78766: ARRAY
78767: PUSH
78768: LD_INT 1
78770: ARRAY
78771: PPUSH
78772: CALL_OW 255
78776: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
78777: LD_VAR 0 5
78781: PPUSH
78782: LD_INT 2
78784: PPUSH
78785: CALL_OW 325
78789: IFFALSE 79042
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
78791: LD_ADDR_VAR 0 4
78795: PUSH
78796: LD_EXP 90
78800: PUSH
78801: LD_VAR 0 2
78805: ARRAY
78806: PPUSH
78807: LD_INT 25
78809: PUSH
78810: LD_INT 16
78812: PUSH
78813: EMPTY
78814: LIST
78815: LIST
78816: PPUSH
78817: CALL_OW 72
78821: ST_TO_ADDR
// if tmp < 6 then
78822: LD_VAR 0 4
78826: PUSH
78827: LD_INT 6
78829: LESS
78830: IFFALSE 79042
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78832: LD_ADDR_VAR 0 6
78836: PUSH
78837: LD_EXP 61
78841: PUSH
78842: LD_VAR 0 2
78846: ARRAY
78847: PPUSH
78848: LD_INT 2
78850: PUSH
78851: LD_INT 30
78853: PUSH
78854: LD_INT 0
78856: PUSH
78857: EMPTY
78858: LIST
78859: LIST
78860: PUSH
78861: LD_INT 30
78863: PUSH
78864: LD_INT 1
78866: PUSH
78867: EMPTY
78868: LIST
78869: LIST
78870: PUSH
78871: EMPTY
78872: LIST
78873: LIST
78874: LIST
78875: PPUSH
78876: CALL_OW 72
78880: ST_TO_ADDR
// if depot then
78881: LD_VAR 0 6
78885: IFFALSE 79042
// begin selected := 0 ;
78887: LD_ADDR_VAR 0 7
78891: PUSH
78892: LD_INT 0
78894: ST_TO_ADDR
// for j in depot do
78895: LD_ADDR_VAR 0 3
78899: PUSH
78900: LD_VAR 0 6
78904: PUSH
78905: FOR_IN
78906: IFFALSE 78937
// begin if UnitsInside ( j ) < 6 then
78908: LD_VAR 0 3
78912: PPUSH
78913: CALL_OW 313
78917: PUSH
78918: LD_INT 6
78920: LESS
78921: IFFALSE 78935
// begin selected := j ;
78923: LD_ADDR_VAR 0 7
78927: PUSH
78928: LD_VAR 0 3
78932: ST_TO_ADDR
// break ;
78933: GO 78937
// end ; end ;
78935: GO 78905
78937: POP
78938: POP
// if selected then
78939: LD_VAR 0 7
78943: IFFALSE 79042
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
78945: LD_ADDR_VAR 0 3
78949: PUSH
78950: LD_EXP 90
78954: PUSH
78955: LD_VAR 0 2
78959: ARRAY
78960: PPUSH
78961: LD_INT 25
78963: PUSH
78964: LD_INT 12
78966: PUSH
78967: EMPTY
78968: LIST
78969: LIST
78970: PPUSH
78971: CALL_OW 72
78975: PUSH
78976: FOR_IN
78977: IFFALSE 79040
// if not HasTask ( j ) then
78979: LD_VAR 0 3
78983: PPUSH
78984: CALL_OW 314
78988: NOT
78989: IFFALSE 79038
// begin if not IsInUnit ( j ) then
78991: LD_VAR 0 3
78995: PPUSH
78996: CALL_OW 310
79000: NOT
79001: IFFALSE 79017
// ComEnterUnit ( j , selected ) ;
79003: LD_VAR 0 3
79007: PPUSH
79008: LD_VAR 0 7
79012: PPUSH
79013: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
79017: LD_VAR 0 3
79021: PPUSH
79022: LD_INT 16
79024: PPUSH
79025: CALL_OW 183
// AddComExitBuilding ( j ) ;
79029: LD_VAR 0 3
79033: PPUSH
79034: CALL_OW 182
// end ;
79038: GO 78976
79040: POP
79041: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
79042: LD_VAR 0 5
79046: PPUSH
79047: LD_INT 11
79049: PPUSH
79050: CALL_OW 325
79054: IFFALSE 79313
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
79056: LD_ADDR_VAR 0 4
79060: PUSH
79061: LD_EXP 90
79065: PUSH
79066: LD_VAR 0 2
79070: ARRAY
79071: PPUSH
79072: LD_INT 25
79074: PUSH
79075: LD_INT 16
79077: PUSH
79078: EMPTY
79079: LIST
79080: LIST
79081: PPUSH
79082: CALL_OW 72
79086: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
79087: LD_VAR 0 4
79091: PUSH
79092: LD_INT 6
79094: GREATEREQUAL
79095: PUSH
79096: LD_VAR 0 5
79100: PPUSH
79101: LD_INT 2
79103: PPUSH
79104: CALL_OW 325
79108: NOT
79109: OR
79110: IFFALSE 79313
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
79112: LD_ADDR_VAR 0 8
79116: PUSH
79117: LD_EXP 61
79121: PUSH
79122: LD_VAR 0 2
79126: ARRAY
79127: PPUSH
79128: LD_INT 2
79130: PUSH
79131: LD_INT 30
79133: PUSH
79134: LD_INT 4
79136: PUSH
79137: EMPTY
79138: LIST
79139: LIST
79140: PUSH
79141: LD_INT 30
79143: PUSH
79144: LD_INT 5
79146: PUSH
79147: EMPTY
79148: LIST
79149: LIST
79150: PUSH
79151: EMPTY
79152: LIST
79153: LIST
79154: LIST
79155: PPUSH
79156: CALL_OW 72
79160: ST_TO_ADDR
// if barracks then
79161: LD_VAR 0 8
79165: IFFALSE 79313
// begin selected := 0 ;
79167: LD_ADDR_VAR 0 7
79171: PUSH
79172: LD_INT 0
79174: ST_TO_ADDR
// for j in barracks do
79175: LD_ADDR_VAR 0 3
79179: PUSH
79180: LD_VAR 0 8
79184: PUSH
79185: FOR_IN
79186: IFFALSE 79217
// begin if UnitsInside ( j ) < 6 then
79188: LD_VAR 0 3
79192: PPUSH
79193: CALL_OW 313
79197: PUSH
79198: LD_INT 6
79200: LESS
79201: IFFALSE 79215
// begin selected := j ;
79203: LD_ADDR_VAR 0 7
79207: PUSH
79208: LD_VAR 0 3
79212: ST_TO_ADDR
// break ;
79213: GO 79217
// end ; end ;
79215: GO 79185
79217: POP
79218: POP
// if selected then
79219: LD_VAR 0 7
79223: IFFALSE 79313
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
79225: LD_ADDR_VAR 0 3
79229: PUSH
79230: LD_EXP 90
79234: PUSH
79235: LD_VAR 0 2
79239: ARRAY
79240: PPUSH
79241: LD_INT 25
79243: PUSH
79244: LD_INT 12
79246: PUSH
79247: EMPTY
79248: LIST
79249: LIST
79250: PPUSH
79251: CALL_OW 72
79255: PUSH
79256: FOR_IN
79257: IFFALSE 79311
// if not IsInUnit ( j ) and not HasTask ( j ) then
79259: LD_VAR 0 3
79263: PPUSH
79264: CALL_OW 310
79268: NOT
79269: PUSH
79270: LD_VAR 0 3
79274: PPUSH
79275: CALL_OW 314
79279: NOT
79280: AND
79281: IFFALSE 79309
// begin ComEnterUnit ( j , selected ) ;
79283: LD_VAR 0 3
79287: PPUSH
79288: LD_VAR 0 7
79292: PPUSH
79293: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
79297: LD_VAR 0 3
79301: PPUSH
79302: LD_INT 15
79304: PPUSH
79305: CALL_OW 183
// end ;
79309: GO 79256
79311: POP
79312: POP
// end ; end ; end ; end ; end ;
79313: GO 78706
79315: POP
79316: POP
// end ;
79317: LD_VAR 0 1
79321: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
79322: LD_INT 0
79324: PPUSH
79325: PPUSH
79326: PPUSH
79327: PPUSH
// if not mc_bases then
79328: LD_EXP 61
79332: NOT
79333: IFFALSE 79337
// exit ;
79335: GO 79515
// for i = 1 to mc_bases do
79337: LD_ADDR_VAR 0 2
79341: PUSH
79342: DOUBLE
79343: LD_INT 1
79345: DEC
79346: ST_TO_ADDR
79347: LD_EXP 61
79351: PUSH
79352: FOR_TO
79353: IFFALSE 79513
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
79355: LD_ADDR_VAR 0 4
79359: PUSH
79360: LD_EXP 61
79364: PUSH
79365: LD_VAR 0 2
79369: ARRAY
79370: PPUSH
79371: LD_INT 25
79373: PUSH
79374: LD_INT 9
79376: PUSH
79377: EMPTY
79378: LIST
79379: LIST
79380: PPUSH
79381: CALL_OW 72
79385: ST_TO_ADDR
// if not tmp then
79386: LD_VAR 0 4
79390: NOT
79391: IFFALSE 79395
// continue ;
79393: GO 79352
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
79395: LD_EXP 87
79399: PUSH
79400: LD_VAR 0 2
79404: ARRAY
79405: PPUSH
79406: LD_INT 29
79408: PPUSH
79409: CALL_OW 325
79413: NOT
79414: PUSH
79415: LD_EXP 87
79419: PUSH
79420: LD_VAR 0 2
79424: ARRAY
79425: PPUSH
79426: LD_INT 28
79428: PPUSH
79429: CALL_OW 325
79433: NOT
79434: AND
79435: IFFALSE 79439
// continue ;
79437: GO 79352
// for j in tmp do
79439: LD_ADDR_VAR 0 3
79443: PUSH
79444: LD_VAR 0 4
79448: PUSH
79449: FOR_IN
79450: IFFALSE 79509
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
79452: LD_VAR 0 3
79456: PUSH
79457: LD_EXP 64
79461: PUSH
79462: LD_VAR 0 2
79466: ARRAY
79467: PUSH
79468: LD_INT 1
79470: ARRAY
79471: IN
79472: NOT
79473: PUSH
79474: LD_VAR 0 3
79478: PUSH
79479: LD_EXP 64
79483: PUSH
79484: LD_VAR 0 2
79488: ARRAY
79489: PUSH
79490: LD_INT 2
79492: ARRAY
79493: IN
79494: NOT
79495: AND
79496: IFFALSE 79507
// ComSpaceTimeShoot ( j ) ;
79498: LD_VAR 0 3
79502: PPUSH
79503: CALL 17382 0 1
79507: GO 79449
79509: POP
79510: POP
// end ;
79511: GO 79352
79513: POP
79514: POP
// end ;
79515: LD_VAR 0 1
79519: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
79520: LD_INT 0
79522: PPUSH
79523: PPUSH
79524: PPUSH
79525: PPUSH
79526: PPUSH
79527: PPUSH
79528: PPUSH
79529: PPUSH
79530: PPUSH
// if not mc_bases then
79531: LD_EXP 61
79535: NOT
79536: IFFALSE 79540
// exit ;
79538: GO 80162
// for i = 1 to mc_bases do
79540: LD_ADDR_VAR 0 2
79544: PUSH
79545: DOUBLE
79546: LD_INT 1
79548: DEC
79549: ST_TO_ADDR
79550: LD_EXP 61
79554: PUSH
79555: FOR_TO
79556: IFFALSE 80160
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
79558: LD_EXP 96
79562: PUSH
79563: LD_VAR 0 2
79567: ARRAY
79568: NOT
79569: PUSH
79570: LD_INT 38
79572: PPUSH
79573: LD_EXP 87
79577: PUSH
79578: LD_VAR 0 2
79582: ARRAY
79583: PPUSH
79584: CALL_OW 321
79588: PUSH
79589: LD_INT 2
79591: NONEQUAL
79592: OR
79593: IFFALSE 79597
// continue ;
79595: GO 79555
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
79597: LD_ADDR_VAR 0 8
79601: PUSH
79602: LD_EXP 61
79606: PUSH
79607: LD_VAR 0 2
79611: ARRAY
79612: PPUSH
79613: LD_INT 30
79615: PUSH
79616: LD_INT 34
79618: PUSH
79619: EMPTY
79620: LIST
79621: LIST
79622: PPUSH
79623: CALL_OW 72
79627: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
79628: LD_ADDR_VAR 0 9
79632: PUSH
79633: LD_EXP 61
79637: PUSH
79638: LD_VAR 0 2
79642: ARRAY
79643: PPUSH
79644: LD_INT 25
79646: PUSH
79647: LD_INT 4
79649: PUSH
79650: EMPTY
79651: LIST
79652: LIST
79653: PPUSH
79654: CALL_OW 72
79658: PPUSH
79659: LD_INT 0
79661: PPUSH
79662: CALL 51695 0 2
79666: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
79667: LD_VAR 0 9
79671: NOT
79672: PUSH
79673: LD_VAR 0 8
79677: NOT
79678: OR
79679: PUSH
79680: LD_EXP 61
79684: PUSH
79685: LD_VAR 0 2
79689: ARRAY
79690: PPUSH
79691: LD_INT 124
79693: PPUSH
79694: CALL 51695 0 2
79698: OR
79699: IFFALSE 79703
// continue ;
79701: GO 79555
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
79703: LD_EXP 97
79707: PUSH
79708: LD_VAR 0 2
79712: ARRAY
79713: PUSH
79714: LD_EXP 96
79718: PUSH
79719: LD_VAR 0 2
79723: ARRAY
79724: LESS
79725: PUSH
79726: LD_EXP 97
79730: PUSH
79731: LD_VAR 0 2
79735: ARRAY
79736: PUSH
79737: LD_VAR 0 8
79741: LESS
79742: AND
79743: IFFALSE 80158
// begin tmp := sci [ 1 ] ;
79745: LD_ADDR_VAR 0 7
79749: PUSH
79750: LD_VAR 0 9
79754: PUSH
79755: LD_INT 1
79757: ARRAY
79758: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
79759: LD_VAR 0 7
79763: PPUSH
79764: LD_INT 124
79766: PPUSH
79767: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
79771: LD_ADDR_VAR 0 3
79775: PUSH
79776: DOUBLE
79777: LD_EXP 96
79781: PUSH
79782: LD_VAR 0 2
79786: ARRAY
79787: INC
79788: ST_TO_ADDR
79789: LD_EXP 96
79793: PUSH
79794: LD_VAR 0 2
79798: ARRAY
79799: PUSH
79800: FOR_DOWNTO
79801: IFFALSE 80144
// begin if IsInUnit ( tmp ) then
79803: LD_VAR 0 7
79807: PPUSH
79808: CALL_OW 310
79812: IFFALSE 79823
// ComExitBuilding ( tmp ) ;
79814: LD_VAR 0 7
79818: PPUSH
79819: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
79823: LD_INT 35
79825: PPUSH
79826: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
79830: LD_VAR 0 7
79834: PPUSH
79835: CALL_OW 310
79839: NOT
79840: PUSH
79841: LD_VAR 0 7
79845: PPUSH
79846: CALL_OW 314
79850: NOT
79851: AND
79852: IFFALSE 79823
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
79854: LD_ADDR_VAR 0 6
79858: PUSH
79859: LD_VAR 0 7
79863: PPUSH
79864: CALL_OW 250
79868: PUSH
79869: LD_VAR 0 7
79873: PPUSH
79874: CALL_OW 251
79878: PUSH
79879: EMPTY
79880: LIST
79881: LIST
79882: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
79883: LD_INT 35
79885: PPUSH
79886: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
79890: LD_ADDR_VAR 0 4
79894: PUSH
79895: LD_EXP 96
79899: PUSH
79900: LD_VAR 0 2
79904: ARRAY
79905: PUSH
79906: LD_VAR 0 3
79910: ARRAY
79911: PUSH
79912: LD_INT 1
79914: ARRAY
79915: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
79916: LD_ADDR_VAR 0 5
79920: PUSH
79921: LD_EXP 96
79925: PUSH
79926: LD_VAR 0 2
79930: ARRAY
79931: PUSH
79932: LD_VAR 0 3
79936: ARRAY
79937: PUSH
79938: LD_INT 2
79940: ARRAY
79941: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
79942: LD_VAR 0 7
79946: PPUSH
79947: LD_INT 10
79949: PPUSH
79950: CALL 24362 0 2
79954: PUSH
79955: LD_INT 4
79957: ARRAY
79958: IFFALSE 79996
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
79960: LD_VAR 0 7
79964: PPUSH
79965: LD_VAR 0 6
79969: PUSH
79970: LD_INT 1
79972: ARRAY
79973: PPUSH
79974: LD_VAR 0 6
79978: PUSH
79979: LD_INT 2
79981: ARRAY
79982: PPUSH
79983: CALL_OW 111
// wait ( 0 0$10 ) ;
79987: LD_INT 350
79989: PPUSH
79990: CALL_OW 67
// end else
79994: GO 80022
// begin ComMoveXY ( tmp , x , y ) ;
79996: LD_VAR 0 7
80000: PPUSH
80001: LD_VAR 0 4
80005: PPUSH
80006: LD_VAR 0 5
80010: PPUSH
80011: CALL_OW 111
// wait ( 0 0$3 ) ;
80015: LD_INT 105
80017: PPUSH
80018: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
80022: LD_VAR 0 7
80026: PPUSH
80027: LD_VAR 0 4
80031: PPUSH
80032: LD_VAR 0 5
80036: PPUSH
80037: CALL_OW 307
80041: IFFALSE 79883
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
80043: LD_VAR 0 7
80047: PPUSH
80048: LD_VAR 0 4
80052: PPUSH
80053: LD_VAR 0 5
80057: PPUSH
80058: LD_VAR 0 8
80062: PUSH
80063: LD_VAR 0 3
80067: ARRAY
80068: PPUSH
80069: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
80073: LD_INT 35
80075: PPUSH
80076: CALL_OW 67
// until not HasTask ( tmp ) ;
80080: LD_VAR 0 7
80084: PPUSH
80085: CALL_OW 314
80089: NOT
80090: IFFALSE 80073
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
80092: LD_ADDR_EXP 97
80096: PUSH
80097: LD_EXP 97
80101: PPUSH
80102: LD_VAR 0 2
80106: PUSH
80107: LD_EXP 97
80111: PUSH
80112: LD_VAR 0 2
80116: ARRAY
80117: PUSH
80118: LD_INT 1
80120: PLUS
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: PPUSH
80126: LD_VAR 0 8
80130: PUSH
80131: LD_VAR 0 3
80135: ARRAY
80136: PPUSH
80137: CALL 21397 0 3
80141: ST_TO_ADDR
// end ;
80142: GO 79800
80144: POP
80145: POP
// MC_Reset ( i , 124 ) ;
80146: LD_VAR 0 2
80150: PPUSH
80151: LD_INT 124
80153: PPUSH
80154: CALL 63230 0 2
// end ; end ;
80158: GO 79555
80160: POP
80161: POP
// end ;
80162: LD_VAR 0 1
80166: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
80167: LD_INT 0
80169: PPUSH
80170: PPUSH
80171: PPUSH
// if not mc_bases then
80172: LD_EXP 61
80176: NOT
80177: IFFALSE 80181
// exit ;
80179: GO 80787
// for i = 1 to mc_bases do
80181: LD_ADDR_VAR 0 2
80185: PUSH
80186: DOUBLE
80187: LD_INT 1
80189: DEC
80190: ST_TO_ADDR
80191: LD_EXP 61
80195: PUSH
80196: FOR_TO
80197: IFFALSE 80785
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
80199: LD_ADDR_VAR 0 3
80203: PUSH
80204: LD_EXP 61
80208: PUSH
80209: LD_VAR 0 2
80213: ARRAY
80214: PPUSH
80215: LD_INT 25
80217: PUSH
80218: LD_INT 4
80220: PUSH
80221: EMPTY
80222: LIST
80223: LIST
80224: PPUSH
80225: CALL_OW 72
80229: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
80230: LD_VAR 0 3
80234: NOT
80235: PUSH
80236: LD_EXP 98
80240: PUSH
80241: LD_VAR 0 2
80245: ARRAY
80246: NOT
80247: OR
80248: PUSH
80249: LD_EXP 61
80253: PUSH
80254: LD_VAR 0 2
80258: ARRAY
80259: PPUSH
80260: LD_INT 2
80262: PUSH
80263: LD_INT 30
80265: PUSH
80266: LD_INT 0
80268: PUSH
80269: EMPTY
80270: LIST
80271: LIST
80272: PUSH
80273: LD_INT 30
80275: PUSH
80276: LD_INT 1
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: LIST
80287: PPUSH
80288: CALL_OW 72
80292: NOT
80293: OR
80294: IFFALSE 80344
// begin if mc_deposits_finder [ i ] then
80296: LD_EXP 99
80300: PUSH
80301: LD_VAR 0 2
80305: ARRAY
80306: IFFALSE 80342
// begin MC_Reset ( i , 125 ) ;
80308: LD_VAR 0 2
80312: PPUSH
80313: LD_INT 125
80315: PPUSH
80316: CALL 63230 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
80320: LD_ADDR_EXP 99
80324: PUSH
80325: LD_EXP 99
80329: PPUSH
80330: LD_VAR 0 2
80334: PPUSH
80335: EMPTY
80336: PPUSH
80337: CALL_OW 1
80341: ST_TO_ADDR
// end ; continue ;
80342: GO 80196
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
80344: LD_EXP 98
80348: PUSH
80349: LD_VAR 0 2
80353: ARRAY
80354: PUSH
80355: LD_INT 1
80357: ARRAY
80358: PUSH
80359: LD_INT 3
80361: ARRAY
80362: PUSH
80363: LD_INT 1
80365: EQUAL
80366: PUSH
80367: LD_INT 20
80369: PPUSH
80370: LD_EXP 87
80374: PUSH
80375: LD_VAR 0 2
80379: ARRAY
80380: PPUSH
80381: CALL_OW 321
80385: PUSH
80386: LD_INT 2
80388: NONEQUAL
80389: AND
80390: IFFALSE 80440
// begin if mc_deposits_finder [ i ] then
80392: LD_EXP 99
80396: PUSH
80397: LD_VAR 0 2
80401: ARRAY
80402: IFFALSE 80438
// begin MC_Reset ( i , 125 ) ;
80404: LD_VAR 0 2
80408: PPUSH
80409: LD_INT 125
80411: PPUSH
80412: CALL 63230 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
80416: LD_ADDR_EXP 99
80420: PUSH
80421: LD_EXP 99
80425: PPUSH
80426: LD_VAR 0 2
80430: PPUSH
80431: EMPTY
80432: PPUSH
80433: CALL_OW 1
80437: ST_TO_ADDR
// end ; continue ;
80438: GO 80196
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
80440: LD_EXP 98
80444: PUSH
80445: LD_VAR 0 2
80449: ARRAY
80450: PUSH
80451: LD_INT 1
80453: ARRAY
80454: PUSH
80455: LD_INT 1
80457: ARRAY
80458: PPUSH
80459: LD_EXP 98
80463: PUSH
80464: LD_VAR 0 2
80468: ARRAY
80469: PUSH
80470: LD_INT 1
80472: ARRAY
80473: PUSH
80474: LD_INT 2
80476: ARRAY
80477: PPUSH
80478: LD_EXP 87
80482: PUSH
80483: LD_VAR 0 2
80487: ARRAY
80488: PPUSH
80489: CALL_OW 440
80493: IFFALSE 80536
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
80495: LD_ADDR_EXP 98
80499: PUSH
80500: LD_EXP 98
80504: PPUSH
80505: LD_VAR 0 2
80509: PPUSH
80510: LD_EXP 98
80514: PUSH
80515: LD_VAR 0 2
80519: ARRAY
80520: PPUSH
80521: LD_INT 1
80523: PPUSH
80524: CALL_OW 3
80528: PPUSH
80529: CALL_OW 1
80533: ST_TO_ADDR
80534: GO 80783
// begin if not mc_deposits_finder [ i ] then
80536: LD_EXP 99
80540: PUSH
80541: LD_VAR 0 2
80545: ARRAY
80546: NOT
80547: IFFALSE 80599
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
80549: LD_ADDR_EXP 99
80553: PUSH
80554: LD_EXP 99
80558: PPUSH
80559: LD_VAR 0 2
80563: PPUSH
80564: LD_VAR 0 3
80568: PUSH
80569: LD_INT 1
80571: ARRAY
80572: PUSH
80573: EMPTY
80574: LIST
80575: PPUSH
80576: CALL_OW 1
80580: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
80581: LD_VAR 0 3
80585: PUSH
80586: LD_INT 1
80588: ARRAY
80589: PPUSH
80590: LD_INT 125
80592: PPUSH
80593: CALL_OW 109
// end else
80597: GO 80783
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
80599: LD_EXP 99
80603: PUSH
80604: LD_VAR 0 2
80608: ARRAY
80609: PUSH
80610: LD_INT 1
80612: ARRAY
80613: PPUSH
80614: CALL_OW 310
80618: IFFALSE 80641
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
80620: LD_EXP 99
80624: PUSH
80625: LD_VAR 0 2
80629: ARRAY
80630: PUSH
80631: LD_INT 1
80633: ARRAY
80634: PPUSH
80635: CALL_OW 122
80639: GO 80783
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
80641: LD_EXP 99
80645: PUSH
80646: LD_VAR 0 2
80650: ARRAY
80651: PUSH
80652: LD_INT 1
80654: ARRAY
80655: PPUSH
80656: CALL_OW 314
80660: NOT
80661: PUSH
80662: LD_EXP 99
80666: PUSH
80667: LD_VAR 0 2
80671: ARRAY
80672: PUSH
80673: LD_INT 1
80675: ARRAY
80676: PPUSH
80677: LD_EXP 98
80681: PUSH
80682: LD_VAR 0 2
80686: ARRAY
80687: PUSH
80688: LD_INT 1
80690: ARRAY
80691: PUSH
80692: LD_INT 1
80694: ARRAY
80695: PPUSH
80696: LD_EXP 98
80700: PUSH
80701: LD_VAR 0 2
80705: ARRAY
80706: PUSH
80707: LD_INT 1
80709: ARRAY
80710: PUSH
80711: LD_INT 2
80713: ARRAY
80714: PPUSH
80715: CALL_OW 297
80719: PUSH
80720: LD_INT 6
80722: GREATER
80723: AND
80724: IFFALSE 80783
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
80726: LD_EXP 99
80730: PUSH
80731: LD_VAR 0 2
80735: ARRAY
80736: PUSH
80737: LD_INT 1
80739: ARRAY
80740: PPUSH
80741: LD_EXP 98
80745: PUSH
80746: LD_VAR 0 2
80750: ARRAY
80751: PUSH
80752: LD_INT 1
80754: ARRAY
80755: PUSH
80756: LD_INT 1
80758: ARRAY
80759: PPUSH
80760: LD_EXP 98
80764: PUSH
80765: LD_VAR 0 2
80769: ARRAY
80770: PUSH
80771: LD_INT 1
80773: ARRAY
80774: PUSH
80775: LD_INT 2
80777: ARRAY
80778: PPUSH
80779: CALL_OW 111
// end ; end ; end ;
80783: GO 80196
80785: POP
80786: POP
// end ;
80787: LD_VAR 0 1
80791: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
80792: LD_INT 0
80794: PPUSH
80795: PPUSH
80796: PPUSH
80797: PPUSH
80798: PPUSH
80799: PPUSH
80800: PPUSH
80801: PPUSH
80802: PPUSH
80803: PPUSH
80804: PPUSH
// if not mc_bases then
80805: LD_EXP 61
80809: NOT
80810: IFFALSE 80814
// exit ;
80812: GO 81754
// for i = 1 to mc_bases do
80814: LD_ADDR_VAR 0 2
80818: PUSH
80819: DOUBLE
80820: LD_INT 1
80822: DEC
80823: ST_TO_ADDR
80824: LD_EXP 61
80828: PUSH
80829: FOR_TO
80830: IFFALSE 81752
// begin if not mc_bases [ i ] or mc_scan [ i ] then
80832: LD_EXP 61
80836: PUSH
80837: LD_VAR 0 2
80841: ARRAY
80842: NOT
80843: PUSH
80844: LD_EXP 84
80848: PUSH
80849: LD_VAR 0 2
80853: ARRAY
80854: OR
80855: IFFALSE 80859
// continue ;
80857: GO 80829
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
80859: LD_ADDR_VAR 0 7
80863: PUSH
80864: LD_EXP 61
80868: PUSH
80869: LD_VAR 0 2
80873: ARRAY
80874: PUSH
80875: LD_INT 1
80877: ARRAY
80878: PPUSH
80879: CALL_OW 248
80883: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
80884: LD_VAR 0 7
80888: PUSH
80889: LD_INT 3
80891: EQUAL
80892: PUSH
80893: LD_EXP 80
80897: PUSH
80898: LD_VAR 0 2
80902: ARRAY
80903: PUSH
80904: LD_EXP 83
80908: PUSH
80909: LD_VAR 0 2
80913: ARRAY
80914: UNION
80915: PPUSH
80916: LD_INT 33
80918: PUSH
80919: LD_INT 2
80921: PUSH
80922: EMPTY
80923: LIST
80924: LIST
80925: PPUSH
80926: CALL_OW 72
80930: NOT
80931: OR
80932: IFFALSE 80936
// continue ;
80934: GO 80829
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
80936: LD_ADDR_VAR 0 9
80940: PUSH
80941: LD_EXP 61
80945: PUSH
80946: LD_VAR 0 2
80950: ARRAY
80951: PPUSH
80952: LD_INT 30
80954: PUSH
80955: LD_INT 36
80957: PUSH
80958: EMPTY
80959: LIST
80960: LIST
80961: PPUSH
80962: CALL_OW 72
80966: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
80967: LD_ADDR_VAR 0 10
80971: PUSH
80972: LD_EXP 80
80976: PUSH
80977: LD_VAR 0 2
80981: ARRAY
80982: PPUSH
80983: LD_INT 34
80985: PUSH
80986: LD_INT 31
80988: PUSH
80989: EMPTY
80990: LIST
80991: LIST
80992: PPUSH
80993: CALL_OW 72
80997: ST_TO_ADDR
// if not cts and not mcts then
80998: LD_VAR 0 9
81002: NOT
81003: PUSH
81004: LD_VAR 0 10
81008: NOT
81009: AND
81010: IFFALSE 81014
// continue ;
81012: GO 80829
// x := cts ;
81014: LD_ADDR_VAR 0 11
81018: PUSH
81019: LD_VAR 0 9
81023: ST_TO_ADDR
// if not x then
81024: LD_VAR 0 11
81028: NOT
81029: IFFALSE 81041
// x := mcts ;
81031: LD_ADDR_VAR 0 11
81035: PUSH
81036: LD_VAR 0 10
81040: ST_TO_ADDR
// if not x then
81041: LD_VAR 0 11
81045: NOT
81046: IFFALSE 81050
// continue ;
81048: GO 80829
// if mc_remote_driver [ i ] then
81050: LD_EXP 101
81054: PUSH
81055: LD_VAR 0 2
81059: ARRAY
81060: IFFALSE 81447
// for j in mc_remote_driver [ i ] do
81062: LD_ADDR_VAR 0 3
81066: PUSH
81067: LD_EXP 101
81071: PUSH
81072: LD_VAR 0 2
81076: ARRAY
81077: PUSH
81078: FOR_IN
81079: IFFALSE 81445
// begin if GetClass ( j ) <> 3 then
81081: LD_VAR 0 3
81085: PPUSH
81086: CALL_OW 257
81090: PUSH
81091: LD_INT 3
81093: NONEQUAL
81094: IFFALSE 81147
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
81096: LD_ADDR_EXP 101
81100: PUSH
81101: LD_EXP 101
81105: PPUSH
81106: LD_VAR 0 2
81110: PPUSH
81111: LD_EXP 101
81115: PUSH
81116: LD_VAR 0 2
81120: ARRAY
81121: PUSH
81122: LD_VAR 0 3
81126: DIFF
81127: PPUSH
81128: CALL_OW 1
81132: ST_TO_ADDR
// SetTag ( j , 0 ) ;
81133: LD_VAR 0 3
81137: PPUSH
81138: LD_INT 0
81140: PPUSH
81141: CALL_OW 109
// continue ;
81145: GO 81078
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
81147: LD_EXP 80
81151: PUSH
81152: LD_VAR 0 2
81156: ARRAY
81157: PPUSH
81158: LD_INT 34
81160: PUSH
81161: LD_INT 31
81163: PUSH
81164: EMPTY
81165: LIST
81166: LIST
81167: PUSH
81168: LD_INT 58
81170: PUSH
81171: EMPTY
81172: LIST
81173: PUSH
81174: EMPTY
81175: LIST
81176: LIST
81177: PPUSH
81178: CALL_OW 72
81182: PUSH
81183: LD_VAR 0 3
81187: PPUSH
81188: CALL 51730 0 1
81192: NOT
81193: AND
81194: IFFALSE 81265
// begin if IsInUnit ( j ) then
81196: LD_VAR 0 3
81200: PPUSH
81201: CALL_OW 310
81205: IFFALSE 81216
// ComExitBuilding ( j ) ;
81207: LD_VAR 0 3
81211: PPUSH
81212: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
81216: LD_VAR 0 3
81220: PPUSH
81221: LD_EXP 80
81225: PUSH
81226: LD_VAR 0 2
81230: ARRAY
81231: PPUSH
81232: LD_INT 34
81234: PUSH
81235: LD_INT 31
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PUSH
81242: LD_INT 58
81244: PUSH
81245: EMPTY
81246: LIST
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: PPUSH
81252: CALL_OW 72
81256: PUSH
81257: LD_INT 1
81259: ARRAY
81260: PPUSH
81261: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
81265: LD_VAR 0 3
81269: PPUSH
81270: CALL_OW 310
81274: NOT
81275: PUSH
81276: LD_VAR 0 3
81280: PPUSH
81281: CALL_OW 310
81285: PPUSH
81286: CALL_OW 266
81290: PUSH
81291: LD_INT 36
81293: NONEQUAL
81294: PUSH
81295: LD_VAR 0 3
81299: PPUSH
81300: CALL 51730 0 1
81304: NOT
81305: AND
81306: OR
81307: IFFALSE 81443
// begin if IsInUnit ( j ) then
81309: LD_VAR 0 3
81313: PPUSH
81314: CALL_OW 310
81318: IFFALSE 81329
// ComExitBuilding ( j ) ;
81320: LD_VAR 0 3
81324: PPUSH
81325: CALL_OW 122
// ct := 0 ;
81329: LD_ADDR_VAR 0 8
81333: PUSH
81334: LD_INT 0
81336: ST_TO_ADDR
// for k in x do
81337: LD_ADDR_VAR 0 4
81341: PUSH
81342: LD_VAR 0 11
81346: PUSH
81347: FOR_IN
81348: IFFALSE 81421
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
81350: LD_VAR 0 4
81354: PPUSH
81355: CALL_OW 264
81359: PUSH
81360: LD_INT 31
81362: EQUAL
81363: PUSH
81364: LD_VAR 0 4
81368: PPUSH
81369: CALL_OW 311
81373: NOT
81374: AND
81375: PUSH
81376: LD_VAR 0 4
81380: PPUSH
81381: CALL_OW 266
81385: PUSH
81386: LD_INT 36
81388: EQUAL
81389: PUSH
81390: LD_VAR 0 4
81394: PPUSH
81395: CALL_OW 313
81399: PUSH
81400: LD_INT 3
81402: LESS
81403: AND
81404: OR
81405: IFFALSE 81419
// begin ct := k ;
81407: LD_ADDR_VAR 0 8
81411: PUSH
81412: LD_VAR 0 4
81416: ST_TO_ADDR
// break ;
81417: GO 81421
// end ;
81419: GO 81347
81421: POP
81422: POP
// if ct then
81423: LD_VAR 0 8
81427: IFFALSE 81443
// ComEnterUnit ( j , ct ) ;
81429: LD_VAR 0 3
81433: PPUSH
81434: LD_VAR 0 8
81438: PPUSH
81439: CALL_OW 120
// end ; end ;
81443: GO 81078
81445: POP
81446: POP
// places := 0 ;
81447: LD_ADDR_VAR 0 5
81451: PUSH
81452: LD_INT 0
81454: ST_TO_ADDR
// for j = 1 to x do
81455: LD_ADDR_VAR 0 3
81459: PUSH
81460: DOUBLE
81461: LD_INT 1
81463: DEC
81464: ST_TO_ADDR
81465: LD_VAR 0 11
81469: PUSH
81470: FOR_TO
81471: IFFALSE 81547
// if GetWeapon ( x [ j ] ) = ar_control_tower then
81473: LD_VAR 0 11
81477: PUSH
81478: LD_VAR 0 3
81482: ARRAY
81483: PPUSH
81484: CALL_OW 264
81488: PUSH
81489: LD_INT 31
81491: EQUAL
81492: IFFALSE 81510
// places := places + 1 else
81494: LD_ADDR_VAR 0 5
81498: PUSH
81499: LD_VAR 0 5
81503: PUSH
81504: LD_INT 1
81506: PLUS
81507: ST_TO_ADDR
81508: GO 81545
// if GetBType ( x [ j ] ) = b_control_tower then
81510: LD_VAR 0 11
81514: PUSH
81515: LD_VAR 0 3
81519: ARRAY
81520: PPUSH
81521: CALL_OW 266
81525: PUSH
81526: LD_INT 36
81528: EQUAL
81529: IFFALSE 81545
// places := places + 3 ;
81531: LD_ADDR_VAR 0 5
81535: PUSH
81536: LD_VAR 0 5
81540: PUSH
81541: LD_INT 3
81543: PLUS
81544: ST_TO_ADDR
81545: GO 81470
81547: POP
81548: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
81549: LD_VAR 0 5
81553: PUSH
81554: LD_INT 0
81556: EQUAL
81557: PUSH
81558: LD_VAR 0 5
81562: PUSH
81563: LD_EXP 101
81567: PUSH
81568: LD_VAR 0 2
81572: ARRAY
81573: LESSEQUAL
81574: OR
81575: IFFALSE 81579
// continue ;
81577: GO 80829
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
81579: LD_ADDR_VAR 0 6
81583: PUSH
81584: LD_EXP 61
81588: PUSH
81589: LD_VAR 0 2
81593: ARRAY
81594: PPUSH
81595: LD_INT 25
81597: PUSH
81598: LD_INT 3
81600: PUSH
81601: EMPTY
81602: LIST
81603: LIST
81604: PPUSH
81605: CALL_OW 72
81609: PUSH
81610: LD_EXP 101
81614: PUSH
81615: LD_VAR 0 2
81619: ARRAY
81620: DIFF
81621: PPUSH
81622: LD_INT 3
81624: PPUSH
81625: CALL 52630 0 2
81629: ST_TO_ADDR
// for j in tmp do
81630: LD_ADDR_VAR 0 3
81634: PUSH
81635: LD_VAR 0 6
81639: PUSH
81640: FOR_IN
81641: IFFALSE 81676
// if GetTag ( j ) > 0 then
81643: LD_VAR 0 3
81647: PPUSH
81648: CALL_OW 110
81652: PUSH
81653: LD_INT 0
81655: GREATER
81656: IFFALSE 81674
// tmp := tmp diff j ;
81658: LD_ADDR_VAR 0 6
81662: PUSH
81663: LD_VAR 0 6
81667: PUSH
81668: LD_VAR 0 3
81672: DIFF
81673: ST_TO_ADDR
81674: GO 81640
81676: POP
81677: POP
// if not tmp then
81678: LD_VAR 0 6
81682: NOT
81683: IFFALSE 81687
// continue ;
81685: GO 80829
// if places then
81687: LD_VAR 0 5
81691: IFFALSE 81750
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
81693: LD_ADDR_EXP 101
81697: PUSH
81698: LD_EXP 101
81702: PPUSH
81703: LD_VAR 0 2
81707: PPUSH
81708: LD_EXP 101
81712: PUSH
81713: LD_VAR 0 2
81717: ARRAY
81718: PUSH
81719: LD_VAR 0 6
81723: PUSH
81724: LD_INT 1
81726: ARRAY
81727: UNION
81728: PPUSH
81729: CALL_OW 1
81733: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
81734: LD_VAR 0 6
81738: PUSH
81739: LD_INT 1
81741: ARRAY
81742: PPUSH
81743: LD_INT 126
81745: PPUSH
81746: CALL_OW 109
// end ; end ;
81750: GO 80829
81752: POP
81753: POP
// end ;
81754: LD_VAR 0 1
81758: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
81759: LD_INT 0
81761: PPUSH
81762: PPUSH
81763: PPUSH
81764: PPUSH
81765: PPUSH
81766: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
81767: LD_VAR 0 1
81771: NOT
81772: PUSH
81773: LD_VAR 0 2
81777: NOT
81778: OR
81779: PUSH
81780: LD_VAR 0 3
81784: NOT
81785: OR
81786: PUSH
81787: LD_VAR 0 4
81791: PUSH
81792: LD_INT 1
81794: PUSH
81795: LD_INT 2
81797: PUSH
81798: LD_INT 3
81800: PUSH
81801: LD_INT 4
81803: PUSH
81804: LD_INT 5
81806: PUSH
81807: LD_INT 8
81809: PUSH
81810: LD_INT 9
81812: PUSH
81813: LD_INT 15
81815: PUSH
81816: LD_INT 16
81818: PUSH
81819: EMPTY
81820: LIST
81821: LIST
81822: LIST
81823: LIST
81824: LIST
81825: LIST
81826: LIST
81827: LIST
81828: LIST
81829: IN
81830: NOT
81831: OR
81832: IFFALSE 81836
// exit ;
81834: GO 82694
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
81836: LD_ADDR_VAR 0 2
81840: PUSH
81841: LD_VAR 0 2
81845: PPUSH
81846: LD_INT 21
81848: PUSH
81849: LD_INT 3
81851: PUSH
81852: EMPTY
81853: LIST
81854: LIST
81855: PUSH
81856: LD_INT 24
81858: PUSH
81859: LD_INT 250
81861: PUSH
81862: EMPTY
81863: LIST
81864: LIST
81865: PUSH
81866: EMPTY
81867: LIST
81868: LIST
81869: PPUSH
81870: CALL_OW 72
81874: ST_TO_ADDR
// case class of 1 , 15 :
81875: LD_VAR 0 4
81879: PUSH
81880: LD_INT 1
81882: DOUBLE
81883: EQUAL
81884: IFTRUE 81894
81886: LD_INT 15
81888: DOUBLE
81889: EQUAL
81890: IFTRUE 81894
81892: GO 81979
81894: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
81895: LD_ADDR_VAR 0 8
81899: PUSH
81900: LD_VAR 0 2
81904: PPUSH
81905: LD_INT 2
81907: PUSH
81908: LD_INT 30
81910: PUSH
81911: LD_INT 32
81913: PUSH
81914: EMPTY
81915: LIST
81916: LIST
81917: PUSH
81918: LD_INT 30
81920: PUSH
81921: LD_INT 31
81923: PUSH
81924: EMPTY
81925: LIST
81926: LIST
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: LIST
81932: PPUSH
81933: CALL_OW 72
81937: PUSH
81938: LD_VAR 0 2
81942: PPUSH
81943: LD_INT 2
81945: PUSH
81946: LD_INT 30
81948: PUSH
81949: LD_INT 4
81951: PUSH
81952: EMPTY
81953: LIST
81954: LIST
81955: PUSH
81956: LD_INT 30
81958: PUSH
81959: LD_INT 5
81961: PUSH
81962: EMPTY
81963: LIST
81964: LIST
81965: PUSH
81966: EMPTY
81967: LIST
81968: LIST
81969: LIST
81970: PPUSH
81971: CALL_OW 72
81975: ADD
81976: ST_TO_ADDR
81977: GO 82225
81979: LD_INT 2
81981: DOUBLE
81982: EQUAL
81983: IFTRUE 81993
81985: LD_INT 16
81987: DOUBLE
81988: EQUAL
81989: IFTRUE 81993
81991: GO 82039
81993: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
81994: LD_ADDR_VAR 0 8
81998: PUSH
81999: LD_VAR 0 2
82003: PPUSH
82004: LD_INT 2
82006: PUSH
82007: LD_INT 30
82009: PUSH
82010: LD_INT 0
82012: PUSH
82013: EMPTY
82014: LIST
82015: LIST
82016: PUSH
82017: LD_INT 30
82019: PUSH
82020: LD_INT 1
82022: PUSH
82023: EMPTY
82024: LIST
82025: LIST
82026: PUSH
82027: EMPTY
82028: LIST
82029: LIST
82030: LIST
82031: PPUSH
82032: CALL_OW 72
82036: ST_TO_ADDR
82037: GO 82225
82039: LD_INT 3
82041: DOUBLE
82042: EQUAL
82043: IFTRUE 82047
82045: GO 82093
82047: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
82048: LD_ADDR_VAR 0 8
82052: PUSH
82053: LD_VAR 0 2
82057: PPUSH
82058: LD_INT 2
82060: PUSH
82061: LD_INT 30
82063: PUSH
82064: LD_INT 2
82066: PUSH
82067: EMPTY
82068: LIST
82069: LIST
82070: PUSH
82071: LD_INT 30
82073: PUSH
82074: LD_INT 3
82076: PUSH
82077: EMPTY
82078: LIST
82079: LIST
82080: PUSH
82081: EMPTY
82082: LIST
82083: LIST
82084: LIST
82085: PPUSH
82086: CALL_OW 72
82090: ST_TO_ADDR
82091: GO 82225
82093: LD_INT 4
82095: DOUBLE
82096: EQUAL
82097: IFTRUE 82101
82099: GO 82158
82101: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
82102: LD_ADDR_VAR 0 8
82106: PUSH
82107: LD_VAR 0 2
82111: PPUSH
82112: LD_INT 2
82114: PUSH
82115: LD_INT 30
82117: PUSH
82118: LD_INT 6
82120: PUSH
82121: EMPTY
82122: LIST
82123: LIST
82124: PUSH
82125: LD_INT 30
82127: PUSH
82128: LD_INT 7
82130: PUSH
82131: EMPTY
82132: LIST
82133: LIST
82134: PUSH
82135: LD_INT 30
82137: PUSH
82138: LD_INT 8
82140: PUSH
82141: EMPTY
82142: LIST
82143: LIST
82144: PUSH
82145: EMPTY
82146: LIST
82147: LIST
82148: LIST
82149: LIST
82150: PPUSH
82151: CALL_OW 72
82155: ST_TO_ADDR
82156: GO 82225
82158: LD_INT 5
82160: DOUBLE
82161: EQUAL
82162: IFTRUE 82178
82164: LD_INT 8
82166: DOUBLE
82167: EQUAL
82168: IFTRUE 82178
82170: LD_INT 9
82172: DOUBLE
82173: EQUAL
82174: IFTRUE 82178
82176: GO 82224
82178: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
82179: LD_ADDR_VAR 0 8
82183: PUSH
82184: LD_VAR 0 2
82188: PPUSH
82189: LD_INT 2
82191: PUSH
82192: LD_INT 30
82194: PUSH
82195: LD_INT 4
82197: PUSH
82198: EMPTY
82199: LIST
82200: LIST
82201: PUSH
82202: LD_INT 30
82204: PUSH
82205: LD_INT 5
82207: PUSH
82208: EMPTY
82209: LIST
82210: LIST
82211: PUSH
82212: EMPTY
82213: LIST
82214: LIST
82215: LIST
82216: PPUSH
82217: CALL_OW 72
82221: ST_TO_ADDR
82222: GO 82225
82224: POP
// if not tmp then
82225: LD_VAR 0 8
82229: NOT
82230: IFFALSE 82234
// exit ;
82232: GO 82694
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
82234: LD_VAR 0 4
82238: PUSH
82239: LD_INT 1
82241: PUSH
82242: LD_INT 15
82244: PUSH
82245: EMPTY
82246: LIST
82247: LIST
82248: IN
82249: PUSH
82250: LD_EXP 70
82254: PUSH
82255: LD_VAR 0 1
82259: ARRAY
82260: AND
82261: IFFALSE 82417
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
82263: LD_ADDR_VAR 0 9
82267: PUSH
82268: LD_EXP 70
82272: PUSH
82273: LD_VAR 0 1
82277: ARRAY
82278: PUSH
82279: LD_INT 1
82281: ARRAY
82282: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
82283: LD_VAR 0 9
82287: PUSH
82288: LD_EXP 71
82292: PUSH
82293: LD_VAR 0 1
82297: ARRAY
82298: IN
82299: NOT
82300: IFFALSE 82415
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
82302: LD_ADDR_EXP 71
82306: PUSH
82307: LD_EXP 71
82311: PPUSH
82312: LD_VAR 0 1
82316: PUSH
82317: LD_EXP 71
82321: PUSH
82322: LD_VAR 0 1
82326: ARRAY
82327: PUSH
82328: LD_INT 1
82330: PLUS
82331: PUSH
82332: EMPTY
82333: LIST
82334: LIST
82335: PPUSH
82336: LD_VAR 0 9
82340: PPUSH
82341: CALL 21397 0 3
82345: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
82346: LD_ADDR_EXP 70
82350: PUSH
82351: LD_EXP 70
82355: PPUSH
82356: LD_VAR 0 1
82360: PPUSH
82361: LD_EXP 70
82365: PUSH
82366: LD_VAR 0 1
82370: ARRAY
82371: PUSH
82372: LD_VAR 0 9
82376: DIFF
82377: PPUSH
82378: CALL_OW 1
82382: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
82383: LD_VAR 0 3
82387: PPUSH
82388: LD_EXP 71
82392: PUSH
82393: LD_VAR 0 1
82397: ARRAY
82398: PUSH
82399: LD_EXP 71
82403: PUSH
82404: LD_VAR 0 1
82408: ARRAY
82409: ARRAY
82410: PPUSH
82411: CALL_OW 120
// end ; exit ;
82415: GO 82694
// end ; if tmp > 1 then
82417: LD_VAR 0 8
82421: PUSH
82422: LD_INT 1
82424: GREATER
82425: IFFALSE 82529
// for i = 2 to tmp do
82427: LD_ADDR_VAR 0 6
82431: PUSH
82432: DOUBLE
82433: LD_INT 2
82435: DEC
82436: ST_TO_ADDR
82437: LD_VAR 0 8
82441: PUSH
82442: FOR_TO
82443: IFFALSE 82527
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
82445: LD_VAR 0 8
82449: PUSH
82450: LD_VAR 0 6
82454: ARRAY
82455: PPUSH
82456: CALL_OW 461
82460: PUSH
82461: LD_INT 6
82463: EQUAL
82464: IFFALSE 82525
// begin x := tmp [ i ] ;
82466: LD_ADDR_VAR 0 9
82470: PUSH
82471: LD_VAR 0 8
82475: PUSH
82476: LD_VAR 0 6
82480: ARRAY
82481: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
82482: LD_ADDR_VAR 0 8
82486: PUSH
82487: LD_VAR 0 8
82491: PPUSH
82492: LD_VAR 0 6
82496: PPUSH
82497: CALL_OW 3
82501: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
82502: LD_ADDR_VAR 0 8
82506: PUSH
82507: LD_VAR 0 8
82511: PPUSH
82512: LD_INT 1
82514: PPUSH
82515: LD_VAR 0 9
82519: PPUSH
82520: CALL_OW 2
82524: ST_TO_ADDR
// end ;
82525: GO 82442
82527: POP
82528: POP
// for i in tmp do
82529: LD_ADDR_VAR 0 6
82533: PUSH
82534: LD_VAR 0 8
82538: PUSH
82539: FOR_IN
82540: IFFALSE 82567
// begin if IsNotFull ( i ) then
82542: LD_VAR 0 6
82546: PPUSH
82547: CALL 18619 0 1
82551: IFFALSE 82565
// begin j := i ;
82553: LD_ADDR_VAR 0 7
82557: PUSH
82558: LD_VAR 0 6
82562: ST_TO_ADDR
// break ;
82563: GO 82567
// end ; end ;
82565: GO 82539
82567: POP
82568: POP
// if j then
82569: LD_VAR 0 7
82573: IFFALSE 82591
// ComEnterUnit ( unit , j ) else
82575: LD_VAR 0 3
82579: PPUSH
82580: LD_VAR 0 7
82584: PPUSH
82585: CALL_OW 120
82589: GO 82694
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82591: LD_ADDR_VAR 0 10
82595: PUSH
82596: LD_VAR 0 2
82600: PPUSH
82601: LD_INT 2
82603: PUSH
82604: LD_INT 30
82606: PUSH
82607: LD_INT 0
82609: PUSH
82610: EMPTY
82611: LIST
82612: LIST
82613: PUSH
82614: LD_INT 30
82616: PUSH
82617: LD_INT 1
82619: PUSH
82620: EMPTY
82621: LIST
82622: LIST
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: LIST
82628: PPUSH
82629: CALL_OW 72
82633: ST_TO_ADDR
// if depot then
82634: LD_VAR 0 10
82638: IFFALSE 82694
// begin depot := NearestUnitToUnit ( depot , unit ) ;
82640: LD_ADDR_VAR 0 10
82644: PUSH
82645: LD_VAR 0 10
82649: PPUSH
82650: LD_VAR 0 3
82654: PPUSH
82655: CALL_OW 74
82659: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
82660: LD_VAR 0 3
82664: PPUSH
82665: LD_VAR 0 10
82669: PPUSH
82670: CALL_OW 296
82674: PUSH
82675: LD_INT 10
82677: GREATER
82678: IFFALSE 82694
// ComStandNearbyBuilding ( unit , depot ) ;
82680: LD_VAR 0 3
82684: PPUSH
82685: LD_VAR 0 10
82689: PPUSH
82690: CALL 17999 0 2
// end ; end ; end ;
82694: LD_VAR 0 5
82698: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
82699: LD_INT 0
82701: PPUSH
82702: PPUSH
82703: PPUSH
82704: PPUSH
// if not mc_bases then
82705: LD_EXP 61
82709: NOT
82710: IFFALSE 82714
// exit ;
82712: GO 82953
// for i = 1 to mc_bases do
82714: LD_ADDR_VAR 0 2
82718: PUSH
82719: DOUBLE
82720: LD_INT 1
82722: DEC
82723: ST_TO_ADDR
82724: LD_EXP 61
82728: PUSH
82729: FOR_TO
82730: IFFALSE 82951
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
82732: LD_ADDR_VAR 0 4
82736: PUSH
82737: LD_EXP 61
82741: PUSH
82742: LD_VAR 0 2
82746: ARRAY
82747: PPUSH
82748: LD_INT 21
82750: PUSH
82751: LD_INT 1
82753: PUSH
82754: EMPTY
82755: LIST
82756: LIST
82757: PPUSH
82758: CALL_OW 72
82762: PUSH
82763: LD_EXP 90
82767: PUSH
82768: LD_VAR 0 2
82772: ARRAY
82773: UNION
82774: ST_TO_ADDR
// if not tmp then
82775: LD_VAR 0 4
82779: NOT
82780: IFFALSE 82784
// continue ;
82782: GO 82729
// for j in tmp do
82784: LD_ADDR_VAR 0 3
82788: PUSH
82789: LD_VAR 0 4
82793: PUSH
82794: FOR_IN
82795: IFFALSE 82947
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
82797: LD_VAR 0 3
82801: PPUSH
82802: CALL_OW 110
82806: NOT
82807: PUSH
82808: LD_VAR 0 3
82812: PPUSH
82813: CALL_OW 314
82817: NOT
82818: AND
82819: PUSH
82820: LD_VAR 0 3
82824: PPUSH
82825: CALL_OW 311
82829: NOT
82830: AND
82831: PUSH
82832: LD_VAR 0 3
82836: PPUSH
82837: CALL_OW 310
82841: NOT
82842: AND
82843: PUSH
82844: LD_VAR 0 3
82848: PUSH
82849: LD_EXP 64
82853: PUSH
82854: LD_VAR 0 2
82858: ARRAY
82859: PUSH
82860: LD_INT 1
82862: ARRAY
82863: IN
82864: NOT
82865: AND
82866: PUSH
82867: LD_VAR 0 3
82871: PUSH
82872: LD_EXP 64
82876: PUSH
82877: LD_VAR 0 2
82881: ARRAY
82882: PUSH
82883: LD_INT 2
82885: ARRAY
82886: IN
82887: NOT
82888: AND
82889: PUSH
82890: LD_VAR 0 3
82894: PUSH
82895: LD_EXP 73
82899: PUSH
82900: LD_VAR 0 2
82904: ARRAY
82905: IN
82906: NOT
82907: AND
82908: IFFALSE 82945
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
82910: LD_VAR 0 2
82914: PPUSH
82915: LD_EXP 61
82919: PUSH
82920: LD_VAR 0 2
82924: ARRAY
82925: PPUSH
82926: LD_VAR 0 3
82930: PPUSH
82931: LD_VAR 0 3
82935: PPUSH
82936: CALL_OW 257
82940: PPUSH
82941: CALL 81759 0 4
// end ;
82945: GO 82794
82947: POP
82948: POP
// end ;
82949: GO 82729
82951: POP
82952: POP
// end ;
82953: LD_VAR 0 1
82957: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
82958: LD_INT 0
82960: PPUSH
82961: PPUSH
82962: PPUSH
82963: PPUSH
82964: PPUSH
82965: PPUSH
// if not mc_bases [ base ] then
82966: LD_EXP 61
82970: PUSH
82971: LD_VAR 0 1
82975: ARRAY
82976: NOT
82977: IFFALSE 82981
// exit ;
82979: GO 83182
// tmp := [ ] ;
82981: LD_ADDR_VAR 0 6
82985: PUSH
82986: EMPTY
82987: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
82988: LD_ADDR_VAR 0 7
82992: PUSH
82993: LD_VAR 0 3
82997: PPUSH
82998: LD_INT 0
83000: PPUSH
83001: CALL_OW 517
83005: ST_TO_ADDR
// if not list then
83006: LD_VAR 0 7
83010: NOT
83011: IFFALSE 83015
// exit ;
83013: GO 83182
// c := Count ( list [ 1 ] ) ;
83015: LD_ADDR_VAR 0 9
83019: PUSH
83020: LD_VAR 0 7
83024: PUSH
83025: LD_INT 1
83027: ARRAY
83028: PPUSH
83029: CALL 18537 0 1
83033: ST_TO_ADDR
// if amount > c then
83034: LD_VAR 0 2
83038: PUSH
83039: LD_VAR 0 9
83043: GREATER
83044: IFFALSE 83056
// amount := c ;
83046: LD_ADDR_VAR 0 2
83050: PUSH
83051: LD_VAR 0 9
83055: ST_TO_ADDR
// for i := 1 to amount do
83056: LD_ADDR_VAR 0 5
83060: PUSH
83061: DOUBLE
83062: LD_INT 1
83064: DEC
83065: ST_TO_ADDR
83066: LD_VAR 0 2
83070: PUSH
83071: FOR_TO
83072: IFFALSE 83130
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
83074: LD_ADDR_VAR 0 6
83078: PUSH
83079: LD_VAR 0 6
83083: PPUSH
83084: LD_VAR 0 5
83088: PPUSH
83089: LD_VAR 0 7
83093: PUSH
83094: LD_INT 1
83096: ARRAY
83097: PUSH
83098: LD_VAR 0 5
83102: ARRAY
83103: PUSH
83104: LD_VAR 0 7
83108: PUSH
83109: LD_INT 2
83111: ARRAY
83112: PUSH
83113: LD_VAR 0 5
83117: ARRAY
83118: PUSH
83119: EMPTY
83120: LIST
83121: LIST
83122: PPUSH
83123: CALL_OW 1
83127: ST_TO_ADDR
83128: GO 83071
83130: POP
83131: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
83132: LD_ADDR_EXP 74
83136: PUSH
83137: LD_EXP 74
83141: PPUSH
83142: LD_VAR 0 1
83146: PPUSH
83147: LD_VAR 0 6
83151: PPUSH
83152: CALL_OW 1
83156: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
83157: LD_ADDR_EXP 76
83161: PUSH
83162: LD_EXP 76
83166: PPUSH
83167: LD_VAR 0 1
83171: PPUSH
83172: LD_VAR 0 3
83176: PPUSH
83177: CALL_OW 1
83181: ST_TO_ADDR
// end ;
83182: LD_VAR 0 4
83186: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
83187: LD_INT 0
83189: PPUSH
// if not mc_bases [ base ] then
83190: LD_EXP 61
83194: PUSH
83195: LD_VAR 0 1
83199: ARRAY
83200: NOT
83201: IFFALSE 83205
// exit ;
83203: GO 83230
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
83205: LD_ADDR_EXP 66
83209: PUSH
83210: LD_EXP 66
83214: PPUSH
83215: LD_VAR 0 1
83219: PPUSH
83220: LD_VAR 0 2
83224: PPUSH
83225: CALL_OW 1
83229: ST_TO_ADDR
// end ;
83230: LD_VAR 0 3
83234: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
83235: LD_INT 0
83237: PPUSH
// if not mc_bases [ base ] then
83238: LD_EXP 61
83242: PUSH
83243: LD_VAR 0 1
83247: ARRAY
83248: NOT
83249: IFFALSE 83253
// exit ;
83251: GO 83290
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
83253: LD_ADDR_EXP 66
83257: PUSH
83258: LD_EXP 66
83262: PPUSH
83263: LD_VAR 0 1
83267: PPUSH
83268: LD_EXP 66
83272: PUSH
83273: LD_VAR 0 1
83277: ARRAY
83278: PUSH
83279: LD_VAR 0 2
83283: UNION
83284: PPUSH
83285: CALL_OW 1
83289: ST_TO_ADDR
// end ;
83290: LD_VAR 0 3
83294: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
83295: LD_INT 0
83297: PPUSH
// if not mc_bases [ base ] then
83298: LD_EXP 61
83302: PUSH
83303: LD_VAR 0 1
83307: ARRAY
83308: NOT
83309: IFFALSE 83313
// exit ;
83311: GO 83338
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
83313: LD_ADDR_EXP 82
83317: PUSH
83318: LD_EXP 82
83322: PPUSH
83323: LD_VAR 0 1
83327: PPUSH
83328: LD_VAR 0 2
83332: PPUSH
83333: CALL_OW 1
83337: ST_TO_ADDR
// end ;
83338: LD_VAR 0 3
83342: RET
// export function MC_InsertProduceList ( base , components ) ; begin
83343: LD_INT 0
83345: PPUSH
// if not mc_bases [ base ] then
83346: LD_EXP 61
83350: PUSH
83351: LD_VAR 0 1
83355: ARRAY
83356: NOT
83357: IFFALSE 83361
// exit ;
83359: GO 83398
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
83361: LD_ADDR_EXP 82
83365: PUSH
83366: LD_EXP 82
83370: PPUSH
83371: LD_VAR 0 1
83375: PPUSH
83376: LD_EXP 82
83380: PUSH
83381: LD_VAR 0 1
83385: ARRAY
83386: PUSH
83387: LD_VAR 0 2
83391: ADD
83392: PPUSH
83393: CALL_OW 1
83397: ST_TO_ADDR
// end ;
83398: LD_VAR 0 3
83402: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
83403: LD_INT 0
83405: PPUSH
// if not mc_bases [ base ] then
83406: LD_EXP 61
83410: PUSH
83411: LD_VAR 0 1
83415: ARRAY
83416: NOT
83417: IFFALSE 83421
// exit ;
83419: GO 83475
// mc_defender := Replace ( mc_defender , base , deflist ) ;
83421: LD_ADDR_EXP 83
83425: PUSH
83426: LD_EXP 83
83430: PPUSH
83431: LD_VAR 0 1
83435: PPUSH
83436: LD_VAR 0 2
83440: PPUSH
83441: CALL_OW 1
83445: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
83446: LD_ADDR_EXP 72
83450: PUSH
83451: LD_EXP 72
83455: PPUSH
83456: LD_VAR 0 1
83460: PPUSH
83461: LD_VAR 0 2
83465: PUSH
83466: LD_INT 0
83468: PLUS
83469: PPUSH
83470: CALL_OW 1
83474: ST_TO_ADDR
// end ;
83475: LD_VAR 0 3
83479: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
83480: LD_INT 0
83482: PPUSH
// if not mc_bases [ base ] then
83483: LD_EXP 61
83487: PUSH
83488: LD_VAR 0 1
83492: ARRAY
83493: NOT
83494: IFFALSE 83498
// exit ;
83496: GO 83523
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
83498: LD_ADDR_EXP 72
83502: PUSH
83503: LD_EXP 72
83507: PPUSH
83508: LD_VAR 0 1
83512: PPUSH
83513: LD_VAR 0 2
83517: PPUSH
83518: CALL_OW 1
83522: ST_TO_ADDR
// end ;
83523: LD_VAR 0 3
83527: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
83528: LD_INT 0
83530: PPUSH
83531: PPUSH
83532: PPUSH
83533: PPUSH
// if not mc_bases [ base ] then
83534: LD_EXP 61
83538: PUSH
83539: LD_VAR 0 1
83543: ARRAY
83544: NOT
83545: IFFALSE 83549
// exit ;
83547: GO 83614
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
83549: LD_ADDR_EXP 81
83553: PUSH
83554: LD_EXP 81
83558: PPUSH
83559: LD_VAR 0 1
83563: PUSH
83564: LD_EXP 81
83568: PUSH
83569: LD_VAR 0 1
83573: ARRAY
83574: PUSH
83575: LD_INT 1
83577: PLUS
83578: PUSH
83579: EMPTY
83580: LIST
83581: LIST
83582: PPUSH
83583: LD_VAR 0 1
83587: PUSH
83588: LD_VAR 0 2
83592: PUSH
83593: LD_VAR 0 3
83597: PUSH
83598: LD_VAR 0 4
83602: PUSH
83603: EMPTY
83604: LIST
83605: LIST
83606: LIST
83607: LIST
83608: PPUSH
83609: CALL 21397 0 3
83613: ST_TO_ADDR
// end ;
83614: LD_VAR 0 5
83618: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
83619: LD_INT 0
83621: PPUSH
// if not mc_bases [ base ] then
83622: LD_EXP 61
83626: PUSH
83627: LD_VAR 0 1
83631: ARRAY
83632: NOT
83633: IFFALSE 83637
// exit ;
83635: GO 83662
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
83637: LD_ADDR_EXP 98
83641: PUSH
83642: LD_EXP 98
83646: PPUSH
83647: LD_VAR 0 1
83651: PPUSH
83652: LD_VAR 0 2
83656: PPUSH
83657: CALL_OW 1
83661: ST_TO_ADDR
// end ;
83662: LD_VAR 0 3
83666: RET
// export function MC_GetMinesField ( base ) ; begin
83667: LD_INT 0
83669: PPUSH
// result := mc_mines [ base ] ;
83670: LD_ADDR_VAR 0 2
83674: PUSH
83675: LD_EXP 74
83679: PUSH
83680: LD_VAR 0 1
83684: ARRAY
83685: ST_TO_ADDR
// end ;
83686: LD_VAR 0 2
83690: RET
// export function MC_GetProduceList ( base ) ; begin
83691: LD_INT 0
83693: PPUSH
// result := mc_produce [ base ] ;
83694: LD_ADDR_VAR 0 2
83698: PUSH
83699: LD_EXP 82
83703: PUSH
83704: LD_VAR 0 1
83708: ARRAY
83709: ST_TO_ADDR
// end ;
83710: LD_VAR 0 2
83714: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
83715: LD_INT 0
83717: PPUSH
83718: PPUSH
// if not mc_bases then
83719: LD_EXP 61
83723: NOT
83724: IFFALSE 83728
// exit ;
83726: GO 83793
// if mc_bases [ base ] then
83728: LD_EXP 61
83732: PUSH
83733: LD_VAR 0 1
83737: ARRAY
83738: IFFALSE 83793
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
83740: LD_ADDR_VAR 0 3
83744: PUSH
83745: LD_EXP 61
83749: PUSH
83750: LD_VAR 0 1
83754: ARRAY
83755: PPUSH
83756: LD_INT 30
83758: PUSH
83759: LD_VAR 0 2
83763: PUSH
83764: EMPTY
83765: LIST
83766: LIST
83767: PPUSH
83768: CALL_OW 72
83772: ST_TO_ADDR
// if result then
83773: LD_VAR 0 3
83777: IFFALSE 83793
// result := result [ 1 ] ;
83779: LD_ADDR_VAR 0 3
83783: PUSH
83784: LD_VAR 0 3
83788: PUSH
83789: LD_INT 1
83791: ARRAY
83792: ST_TO_ADDR
// end ; end ;
83793: LD_VAR 0 3
83797: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
83798: LD_INT 0
83800: PPUSH
83801: PPUSH
// if not mc_bases then
83802: LD_EXP 61
83806: NOT
83807: IFFALSE 83811
// exit ;
83809: GO 83856
// if mc_bases [ base ] then
83811: LD_EXP 61
83815: PUSH
83816: LD_VAR 0 1
83820: ARRAY
83821: IFFALSE 83856
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
83823: LD_ADDR_VAR 0 3
83827: PUSH
83828: LD_EXP 61
83832: PUSH
83833: LD_VAR 0 1
83837: ARRAY
83838: PPUSH
83839: LD_INT 30
83841: PUSH
83842: LD_VAR 0 2
83846: PUSH
83847: EMPTY
83848: LIST
83849: LIST
83850: PPUSH
83851: CALL_OW 72
83855: ST_TO_ADDR
// end ;
83856: LD_VAR 0 3
83860: RET
// export function MC_SetTame ( base , area ) ; begin
83861: LD_INT 0
83863: PPUSH
// if not mc_bases or not base then
83864: LD_EXP 61
83868: NOT
83869: PUSH
83870: LD_VAR 0 1
83874: NOT
83875: OR
83876: IFFALSE 83880
// exit ;
83878: GO 83905
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
83880: LD_ADDR_EXP 89
83884: PUSH
83885: LD_EXP 89
83889: PPUSH
83890: LD_VAR 0 1
83894: PPUSH
83895: LD_VAR 0 2
83899: PPUSH
83900: CALL_OW 1
83904: ST_TO_ADDR
// end ;
83905: LD_VAR 0 3
83909: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
83910: LD_INT 0
83912: PPUSH
83913: PPUSH
// if not mc_bases or not base then
83914: LD_EXP 61
83918: NOT
83919: PUSH
83920: LD_VAR 0 1
83924: NOT
83925: OR
83926: IFFALSE 83930
// exit ;
83928: GO 84032
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
83930: LD_ADDR_VAR 0 4
83934: PUSH
83935: LD_EXP 61
83939: PUSH
83940: LD_VAR 0 1
83944: ARRAY
83945: PPUSH
83946: LD_INT 30
83948: PUSH
83949: LD_VAR 0 2
83953: PUSH
83954: EMPTY
83955: LIST
83956: LIST
83957: PPUSH
83958: CALL_OW 72
83962: ST_TO_ADDR
// if not tmp then
83963: LD_VAR 0 4
83967: NOT
83968: IFFALSE 83972
// exit ;
83970: GO 84032
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
83972: LD_ADDR_EXP 93
83976: PUSH
83977: LD_EXP 93
83981: PPUSH
83982: LD_VAR 0 1
83986: PPUSH
83987: LD_EXP 93
83991: PUSH
83992: LD_VAR 0 1
83996: ARRAY
83997: PPUSH
83998: LD_EXP 93
84002: PUSH
84003: LD_VAR 0 1
84007: ARRAY
84008: PUSH
84009: LD_INT 1
84011: PLUS
84012: PPUSH
84013: LD_VAR 0 4
84017: PUSH
84018: LD_INT 1
84020: ARRAY
84021: PPUSH
84022: CALL_OW 2
84026: PPUSH
84027: CALL_OW 1
84031: ST_TO_ADDR
// end ;
84032: LD_VAR 0 3
84036: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
84037: LD_INT 0
84039: PPUSH
84040: PPUSH
// if not mc_bases or not base or not kinds then
84041: LD_EXP 61
84045: NOT
84046: PUSH
84047: LD_VAR 0 1
84051: NOT
84052: OR
84053: PUSH
84054: LD_VAR 0 2
84058: NOT
84059: OR
84060: IFFALSE 84064
// exit ;
84062: GO 84125
// for i in kinds do
84064: LD_ADDR_VAR 0 4
84068: PUSH
84069: LD_VAR 0 2
84073: PUSH
84074: FOR_IN
84075: IFFALSE 84123
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
84077: LD_ADDR_EXP 95
84081: PUSH
84082: LD_EXP 95
84086: PPUSH
84087: LD_VAR 0 1
84091: PUSH
84092: LD_EXP 95
84096: PUSH
84097: LD_VAR 0 1
84101: ARRAY
84102: PUSH
84103: LD_INT 1
84105: PLUS
84106: PUSH
84107: EMPTY
84108: LIST
84109: LIST
84110: PPUSH
84111: LD_VAR 0 4
84115: PPUSH
84116: CALL 21397 0 3
84120: ST_TO_ADDR
84121: GO 84074
84123: POP
84124: POP
// end ;
84125: LD_VAR 0 3
84129: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
84130: LD_INT 0
84132: PPUSH
// if not mc_bases or not base or not areas then
84133: LD_EXP 61
84137: NOT
84138: PUSH
84139: LD_VAR 0 1
84143: NOT
84144: OR
84145: PUSH
84146: LD_VAR 0 2
84150: NOT
84151: OR
84152: IFFALSE 84156
// exit ;
84154: GO 84181
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
84156: LD_ADDR_EXP 79
84160: PUSH
84161: LD_EXP 79
84165: PPUSH
84166: LD_VAR 0 1
84170: PPUSH
84171: LD_VAR 0 2
84175: PPUSH
84176: CALL_OW 1
84180: ST_TO_ADDR
// end ;
84181: LD_VAR 0 3
84185: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
84186: LD_INT 0
84188: PPUSH
// if not mc_bases or not base or not teleports_exit then
84189: LD_EXP 61
84193: NOT
84194: PUSH
84195: LD_VAR 0 1
84199: NOT
84200: OR
84201: PUSH
84202: LD_VAR 0 2
84206: NOT
84207: OR
84208: IFFALSE 84212
// exit ;
84210: GO 84237
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
84212: LD_ADDR_EXP 96
84216: PUSH
84217: LD_EXP 96
84221: PPUSH
84222: LD_VAR 0 1
84226: PPUSH
84227: LD_VAR 0 2
84231: PPUSH
84232: CALL_OW 1
84236: ST_TO_ADDR
// end ;
84237: LD_VAR 0 3
84241: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
84242: LD_INT 0
84244: PPUSH
84245: PPUSH
84246: PPUSH
// if not mc_bases or not base or not ext_list then
84247: LD_EXP 61
84251: NOT
84252: PUSH
84253: LD_VAR 0 1
84257: NOT
84258: OR
84259: PUSH
84260: LD_VAR 0 5
84264: NOT
84265: OR
84266: IFFALSE 84270
// exit ;
84268: GO 84443
// tmp := GetFacExtXYD ( x , y , d ) ;
84270: LD_ADDR_VAR 0 8
84274: PUSH
84275: LD_VAR 0 2
84279: PPUSH
84280: LD_VAR 0 3
84284: PPUSH
84285: LD_VAR 0 4
84289: PPUSH
84290: CALL 51760 0 3
84294: ST_TO_ADDR
// if not tmp then
84295: LD_VAR 0 8
84299: NOT
84300: IFFALSE 84304
// exit ;
84302: GO 84443
// for i in tmp do
84304: LD_ADDR_VAR 0 7
84308: PUSH
84309: LD_VAR 0 8
84313: PUSH
84314: FOR_IN
84315: IFFALSE 84441
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
84317: LD_ADDR_EXP 66
84321: PUSH
84322: LD_EXP 66
84326: PPUSH
84327: LD_VAR 0 1
84331: PPUSH
84332: LD_EXP 66
84336: PUSH
84337: LD_VAR 0 1
84341: ARRAY
84342: PPUSH
84343: LD_EXP 66
84347: PUSH
84348: LD_VAR 0 1
84352: ARRAY
84353: PUSH
84354: LD_INT 1
84356: PLUS
84357: PPUSH
84358: LD_VAR 0 5
84362: PUSH
84363: LD_INT 1
84365: ARRAY
84366: PUSH
84367: LD_VAR 0 7
84371: PUSH
84372: LD_INT 1
84374: ARRAY
84375: PUSH
84376: LD_VAR 0 7
84380: PUSH
84381: LD_INT 2
84383: ARRAY
84384: PUSH
84385: LD_VAR 0 7
84389: PUSH
84390: LD_INT 3
84392: ARRAY
84393: PUSH
84394: EMPTY
84395: LIST
84396: LIST
84397: LIST
84398: LIST
84399: PPUSH
84400: CALL_OW 2
84404: PPUSH
84405: CALL_OW 1
84409: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
84410: LD_ADDR_VAR 0 5
84414: PUSH
84415: LD_VAR 0 5
84419: PPUSH
84420: LD_INT 1
84422: PPUSH
84423: CALL_OW 3
84427: ST_TO_ADDR
// if not ext_list then
84428: LD_VAR 0 5
84432: NOT
84433: IFFALSE 84439
// exit ;
84435: POP
84436: POP
84437: GO 84443
// end ;
84439: GO 84314
84441: POP
84442: POP
// end ;
84443: LD_VAR 0 6
84447: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
84448: LD_INT 0
84450: PPUSH
// if not mc_bases or not base or not weapon_list then
84451: LD_EXP 61
84455: NOT
84456: PUSH
84457: LD_VAR 0 1
84461: NOT
84462: OR
84463: PUSH
84464: LD_VAR 0 2
84468: NOT
84469: OR
84470: IFFALSE 84474
// exit ;
84472: GO 84499
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
84474: LD_ADDR_EXP 100
84478: PUSH
84479: LD_EXP 100
84483: PPUSH
84484: LD_VAR 0 1
84488: PPUSH
84489: LD_VAR 0 2
84493: PPUSH
84494: CALL_OW 1
84498: ST_TO_ADDR
// end ;
84499: LD_VAR 0 3
84503: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
84504: LD_INT 0
84506: PPUSH
// if not mc_bases or not base or not tech_list then
84507: LD_EXP 61
84511: NOT
84512: PUSH
84513: LD_VAR 0 1
84517: NOT
84518: OR
84519: PUSH
84520: LD_VAR 0 2
84524: NOT
84525: OR
84526: IFFALSE 84530
// exit ;
84528: GO 84555
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
84530: LD_ADDR_EXP 88
84534: PUSH
84535: LD_EXP 88
84539: PPUSH
84540: LD_VAR 0 1
84544: PPUSH
84545: LD_VAR 0 2
84549: PPUSH
84550: CALL_OW 1
84554: ST_TO_ADDR
// end ;
84555: LD_VAR 0 3
84559: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
84560: LD_INT 0
84562: PPUSH
// if not mc_bases or not parking_area or not base then
84563: LD_EXP 61
84567: NOT
84568: PUSH
84569: LD_VAR 0 2
84573: NOT
84574: OR
84575: PUSH
84576: LD_VAR 0 1
84580: NOT
84581: OR
84582: IFFALSE 84586
// exit ;
84584: GO 84611
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
84586: LD_ADDR_EXP 85
84590: PUSH
84591: LD_EXP 85
84595: PPUSH
84596: LD_VAR 0 1
84600: PPUSH
84601: LD_VAR 0 2
84605: PPUSH
84606: CALL_OW 1
84610: ST_TO_ADDR
// end ;
84611: LD_VAR 0 3
84615: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
84616: LD_INT 0
84618: PPUSH
// if not mc_bases or not base or not scan_area then
84619: LD_EXP 61
84623: NOT
84624: PUSH
84625: LD_VAR 0 1
84629: NOT
84630: OR
84631: PUSH
84632: LD_VAR 0 2
84636: NOT
84637: OR
84638: IFFALSE 84642
// exit ;
84640: GO 84667
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
84642: LD_ADDR_EXP 86
84646: PUSH
84647: LD_EXP 86
84651: PPUSH
84652: LD_VAR 0 1
84656: PPUSH
84657: LD_VAR 0 2
84661: PPUSH
84662: CALL_OW 1
84666: ST_TO_ADDR
// end ;
84667: LD_VAR 0 3
84671: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
84672: LD_INT 0
84674: PPUSH
84675: PPUSH
// if not mc_bases or not base then
84676: LD_EXP 61
84680: NOT
84681: PUSH
84682: LD_VAR 0 1
84686: NOT
84687: OR
84688: IFFALSE 84692
// exit ;
84690: GO 84756
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
84692: LD_ADDR_VAR 0 3
84696: PUSH
84697: LD_INT 1
84699: PUSH
84700: LD_INT 2
84702: PUSH
84703: LD_INT 3
84705: PUSH
84706: LD_INT 4
84708: PUSH
84709: LD_INT 11
84711: PUSH
84712: EMPTY
84713: LIST
84714: LIST
84715: LIST
84716: LIST
84717: LIST
84718: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
84719: LD_ADDR_EXP 88
84723: PUSH
84724: LD_EXP 88
84728: PPUSH
84729: LD_VAR 0 1
84733: PPUSH
84734: LD_EXP 88
84738: PUSH
84739: LD_VAR 0 1
84743: ARRAY
84744: PUSH
84745: LD_VAR 0 3
84749: DIFF
84750: PPUSH
84751: CALL_OW 1
84755: ST_TO_ADDR
// end ;
84756: LD_VAR 0 2
84760: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
84761: LD_INT 0
84763: PPUSH
// result := mc_vehicles [ base ] ;
84764: LD_ADDR_VAR 0 3
84768: PUSH
84769: LD_EXP 80
84773: PUSH
84774: LD_VAR 0 1
84778: ARRAY
84779: ST_TO_ADDR
// if onlyCombat then
84780: LD_VAR 0 2
84784: IFFALSE 84956
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
84786: LD_ADDR_VAR 0 3
84790: PUSH
84791: LD_VAR 0 3
84795: PUSH
84796: LD_VAR 0 3
84800: PPUSH
84801: LD_INT 2
84803: PUSH
84804: LD_INT 34
84806: PUSH
84807: LD_INT 12
84809: PUSH
84810: EMPTY
84811: LIST
84812: LIST
84813: PUSH
84814: LD_INT 34
84816: PUSH
84817: LD_INT 51
84819: PUSH
84820: EMPTY
84821: LIST
84822: LIST
84823: PUSH
84824: LD_INT 34
84826: PUSH
84827: LD_INT 89
84829: PUSH
84830: EMPTY
84831: LIST
84832: LIST
84833: PUSH
84834: LD_INT 34
84836: PUSH
84837: LD_INT 32
84839: PUSH
84840: EMPTY
84841: LIST
84842: LIST
84843: PUSH
84844: LD_INT 34
84846: PUSH
84847: LD_INT 13
84849: PUSH
84850: EMPTY
84851: LIST
84852: LIST
84853: PUSH
84854: LD_INT 34
84856: PUSH
84857: LD_INT 52
84859: PUSH
84860: EMPTY
84861: LIST
84862: LIST
84863: PUSH
84864: LD_INT 34
84866: PUSH
84867: LD_INT 88
84869: PUSH
84870: EMPTY
84871: LIST
84872: LIST
84873: PUSH
84874: LD_INT 34
84876: PUSH
84877: LD_INT 14
84879: PUSH
84880: EMPTY
84881: LIST
84882: LIST
84883: PUSH
84884: LD_INT 34
84886: PUSH
84887: LD_INT 53
84889: PUSH
84890: EMPTY
84891: LIST
84892: LIST
84893: PUSH
84894: LD_INT 34
84896: PUSH
84897: LD_INT 98
84899: PUSH
84900: EMPTY
84901: LIST
84902: LIST
84903: PUSH
84904: LD_INT 34
84906: PUSH
84907: LD_INT 31
84909: PUSH
84910: EMPTY
84911: LIST
84912: LIST
84913: PUSH
84914: LD_INT 34
84916: PUSH
84917: LD_INT 48
84919: PUSH
84920: EMPTY
84921: LIST
84922: LIST
84923: PUSH
84924: LD_INT 34
84926: PUSH
84927: LD_INT 8
84929: PUSH
84930: EMPTY
84931: LIST
84932: LIST
84933: PUSH
84934: EMPTY
84935: LIST
84936: LIST
84937: LIST
84938: LIST
84939: LIST
84940: LIST
84941: LIST
84942: LIST
84943: LIST
84944: LIST
84945: LIST
84946: LIST
84947: LIST
84948: LIST
84949: PPUSH
84950: CALL_OW 72
84954: DIFF
84955: ST_TO_ADDR
// end ; end_of_file
84956: LD_VAR 0 3
84960: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
84961: LD_INT 0
84963: PPUSH
84964: PPUSH
84965: PPUSH
// if not mc_bases or not skirmish then
84966: LD_EXP 61
84970: NOT
84971: PUSH
84972: LD_EXP 59
84976: NOT
84977: OR
84978: IFFALSE 84982
// exit ;
84980: GO 85147
// for i = 1 to mc_bases do
84982: LD_ADDR_VAR 0 4
84986: PUSH
84987: DOUBLE
84988: LD_INT 1
84990: DEC
84991: ST_TO_ADDR
84992: LD_EXP 61
84996: PUSH
84997: FOR_TO
84998: IFFALSE 85145
// begin if sci in mc_bases [ i ] then
85000: LD_VAR 0 2
85004: PUSH
85005: LD_EXP 61
85009: PUSH
85010: LD_VAR 0 4
85014: ARRAY
85015: IN
85016: IFFALSE 85143
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
85018: LD_ADDR_EXP 90
85022: PUSH
85023: LD_EXP 90
85027: PPUSH
85028: LD_VAR 0 4
85032: PUSH
85033: LD_EXP 90
85037: PUSH
85038: LD_VAR 0 4
85042: ARRAY
85043: PUSH
85044: LD_INT 1
85046: PLUS
85047: PUSH
85048: EMPTY
85049: LIST
85050: LIST
85051: PPUSH
85052: LD_VAR 0 1
85056: PPUSH
85057: CALL 21397 0 3
85061: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
85062: LD_ADDR_VAR 0 5
85066: PUSH
85067: LD_EXP 61
85071: PUSH
85072: LD_VAR 0 4
85076: ARRAY
85077: PPUSH
85078: LD_INT 2
85080: PUSH
85081: LD_INT 30
85083: PUSH
85084: LD_INT 0
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: PUSH
85091: LD_INT 30
85093: PUSH
85094: LD_INT 1
85096: PUSH
85097: EMPTY
85098: LIST
85099: LIST
85100: PUSH
85101: EMPTY
85102: LIST
85103: LIST
85104: LIST
85105: PPUSH
85106: CALL_OW 72
85110: PPUSH
85111: LD_VAR 0 1
85115: PPUSH
85116: CALL_OW 74
85120: ST_TO_ADDR
// if tmp then
85121: LD_VAR 0 5
85125: IFFALSE 85141
// ComStandNearbyBuilding ( ape , tmp ) ;
85127: LD_VAR 0 1
85131: PPUSH
85132: LD_VAR 0 5
85136: PPUSH
85137: CALL 17999 0 2
// break ;
85141: GO 85145
// end ; end ;
85143: GO 84997
85145: POP
85146: POP
// end ;
85147: LD_VAR 0 3
85151: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
85152: LD_INT 0
85154: PPUSH
85155: PPUSH
85156: PPUSH
// if not mc_bases or not skirmish then
85157: LD_EXP 61
85161: NOT
85162: PUSH
85163: LD_EXP 59
85167: NOT
85168: OR
85169: IFFALSE 85173
// exit ;
85171: GO 85262
// for i = 1 to mc_bases do
85173: LD_ADDR_VAR 0 4
85177: PUSH
85178: DOUBLE
85179: LD_INT 1
85181: DEC
85182: ST_TO_ADDR
85183: LD_EXP 61
85187: PUSH
85188: FOR_TO
85189: IFFALSE 85260
// begin if building in mc_busy_turret_list [ i ] then
85191: LD_VAR 0 1
85195: PUSH
85196: LD_EXP 71
85200: PUSH
85201: LD_VAR 0 4
85205: ARRAY
85206: IN
85207: IFFALSE 85258
// begin tmp := mc_busy_turret_list [ i ] diff building ;
85209: LD_ADDR_VAR 0 5
85213: PUSH
85214: LD_EXP 71
85218: PUSH
85219: LD_VAR 0 4
85223: ARRAY
85224: PUSH
85225: LD_VAR 0 1
85229: DIFF
85230: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
85231: LD_ADDR_EXP 71
85235: PUSH
85236: LD_EXP 71
85240: PPUSH
85241: LD_VAR 0 4
85245: PPUSH
85246: LD_VAR 0 5
85250: PPUSH
85251: CALL_OW 1
85255: ST_TO_ADDR
// break ;
85256: GO 85260
// end ; end ;
85258: GO 85188
85260: POP
85261: POP
// end ;
85262: LD_VAR 0 3
85266: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
85267: LD_INT 0
85269: PPUSH
85270: PPUSH
85271: PPUSH
// if not mc_bases or not skirmish then
85272: LD_EXP 61
85276: NOT
85277: PUSH
85278: LD_EXP 59
85282: NOT
85283: OR
85284: IFFALSE 85288
// exit ;
85286: GO 85487
// for i = 1 to mc_bases do
85288: LD_ADDR_VAR 0 5
85292: PUSH
85293: DOUBLE
85294: LD_INT 1
85296: DEC
85297: ST_TO_ADDR
85298: LD_EXP 61
85302: PUSH
85303: FOR_TO
85304: IFFALSE 85485
// if building in mc_bases [ i ] then
85306: LD_VAR 0 1
85310: PUSH
85311: LD_EXP 61
85315: PUSH
85316: LD_VAR 0 5
85320: ARRAY
85321: IN
85322: IFFALSE 85483
// begin tmp := mc_bases [ i ] diff building ;
85324: LD_ADDR_VAR 0 6
85328: PUSH
85329: LD_EXP 61
85333: PUSH
85334: LD_VAR 0 5
85338: ARRAY
85339: PUSH
85340: LD_VAR 0 1
85344: DIFF
85345: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
85346: LD_ADDR_EXP 61
85350: PUSH
85351: LD_EXP 61
85355: PPUSH
85356: LD_VAR 0 5
85360: PPUSH
85361: LD_VAR 0 6
85365: PPUSH
85366: CALL_OW 1
85370: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
85371: LD_VAR 0 1
85375: PUSH
85376: LD_EXP 69
85380: PUSH
85381: LD_VAR 0 5
85385: ARRAY
85386: IN
85387: IFFALSE 85426
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
85389: LD_ADDR_EXP 69
85393: PUSH
85394: LD_EXP 69
85398: PPUSH
85399: LD_VAR 0 5
85403: PPUSH
85404: LD_EXP 69
85408: PUSH
85409: LD_VAR 0 5
85413: ARRAY
85414: PUSH
85415: LD_VAR 0 1
85419: DIFF
85420: PPUSH
85421: CALL_OW 1
85425: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
85426: LD_VAR 0 1
85430: PUSH
85431: LD_EXP 70
85435: PUSH
85436: LD_VAR 0 5
85440: ARRAY
85441: IN
85442: IFFALSE 85481
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
85444: LD_ADDR_EXP 70
85448: PUSH
85449: LD_EXP 70
85453: PPUSH
85454: LD_VAR 0 5
85458: PPUSH
85459: LD_EXP 70
85463: PUSH
85464: LD_VAR 0 5
85468: ARRAY
85469: PUSH
85470: LD_VAR 0 1
85474: DIFF
85475: PPUSH
85476: CALL_OW 1
85480: ST_TO_ADDR
// break ;
85481: GO 85485
// end ;
85483: GO 85303
85485: POP
85486: POP
// end ;
85487: LD_VAR 0 4
85491: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
85492: LD_INT 0
85494: PPUSH
85495: PPUSH
85496: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
85497: LD_EXP 61
85501: NOT
85502: PUSH
85503: LD_EXP 59
85507: NOT
85508: OR
85509: PUSH
85510: LD_VAR 0 3
85514: PUSH
85515: LD_EXP 87
85519: IN
85520: NOT
85521: OR
85522: IFFALSE 85526
// exit ;
85524: GO 85649
// for i = 1 to mc_vehicles do
85526: LD_ADDR_VAR 0 6
85530: PUSH
85531: DOUBLE
85532: LD_INT 1
85534: DEC
85535: ST_TO_ADDR
85536: LD_EXP 80
85540: PUSH
85541: FOR_TO
85542: IFFALSE 85647
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
85544: LD_VAR 0 2
85548: PUSH
85549: LD_EXP 80
85553: PUSH
85554: LD_VAR 0 6
85558: ARRAY
85559: IN
85560: PUSH
85561: LD_VAR 0 1
85565: PUSH
85566: LD_EXP 80
85570: PUSH
85571: LD_VAR 0 6
85575: ARRAY
85576: IN
85577: OR
85578: IFFALSE 85645
// begin tmp := mc_vehicles [ i ] diff old ;
85580: LD_ADDR_VAR 0 7
85584: PUSH
85585: LD_EXP 80
85589: PUSH
85590: LD_VAR 0 6
85594: ARRAY
85595: PUSH
85596: LD_VAR 0 2
85600: DIFF
85601: ST_TO_ADDR
// tmp := tmp diff new ;
85602: LD_ADDR_VAR 0 7
85606: PUSH
85607: LD_VAR 0 7
85611: PUSH
85612: LD_VAR 0 1
85616: DIFF
85617: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
85618: LD_ADDR_EXP 80
85622: PUSH
85623: LD_EXP 80
85627: PPUSH
85628: LD_VAR 0 6
85632: PPUSH
85633: LD_VAR 0 7
85637: PPUSH
85638: CALL_OW 1
85642: ST_TO_ADDR
// break ;
85643: GO 85647
// end ;
85645: GO 85541
85647: POP
85648: POP
// end ;
85649: LD_VAR 0 5
85653: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
85654: LD_INT 0
85656: PPUSH
85657: PPUSH
85658: PPUSH
85659: PPUSH
// if not mc_bases or not skirmish then
85660: LD_EXP 61
85664: NOT
85665: PUSH
85666: LD_EXP 59
85670: NOT
85671: OR
85672: IFFALSE 85676
// exit ;
85674: GO 86096
// repeat wait ( 0 0$1 ) ;
85676: LD_INT 35
85678: PPUSH
85679: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
85683: LD_EXP 105
85687: NOT
85688: IFFALSE 85676
// mc_block_vehicle_constructed_thread := true ;
85690: LD_ADDR_EXP 105
85694: PUSH
85695: LD_INT 1
85697: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
85698: LD_ADDR_VAR 0 5
85702: PUSH
85703: LD_VAR 0 1
85707: PPUSH
85708: CALL_OW 255
85712: ST_TO_ADDR
// for i = 1 to mc_bases do
85713: LD_ADDR_VAR 0 4
85717: PUSH
85718: DOUBLE
85719: LD_INT 1
85721: DEC
85722: ST_TO_ADDR
85723: LD_EXP 61
85727: PUSH
85728: FOR_TO
85729: IFFALSE 86086
// begin if factory in mc_bases [ i ] then
85731: LD_VAR 0 2
85735: PUSH
85736: LD_EXP 61
85740: PUSH
85741: LD_VAR 0 4
85745: ARRAY
85746: IN
85747: IFFALSE 86084
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
85749: LD_EXP 83
85753: PUSH
85754: LD_VAR 0 4
85758: ARRAY
85759: PUSH
85760: LD_EXP 72
85764: PUSH
85765: LD_VAR 0 4
85769: ARRAY
85770: LESS
85771: PUSH
85772: LD_VAR 0 1
85776: PPUSH
85777: CALL_OW 264
85781: PUSH
85782: LD_INT 31
85784: PUSH
85785: LD_INT 32
85787: PUSH
85788: LD_INT 51
85790: PUSH
85791: LD_INT 89
85793: PUSH
85794: LD_INT 12
85796: PUSH
85797: LD_INT 30
85799: PUSH
85800: LD_INT 98
85802: PUSH
85803: LD_INT 11
85805: PUSH
85806: LD_INT 53
85808: PUSH
85809: LD_INT 14
85811: PUSH
85812: LD_INT 91
85814: PUSH
85815: LD_INT 29
85817: PUSH
85818: LD_INT 99
85820: PUSH
85821: LD_INT 13
85823: PUSH
85824: LD_INT 52
85826: PUSH
85827: LD_INT 88
85829: PUSH
85830: LD_INT 48
85832: PUSH
85833: LD_INT 8
85835: PUSH
85836: EMPTY
85837: LIST
85838: LIST
85839: LIST
85840: LIST
85841: LIST
85842: LIST
85843: LIST
85844: LIST
85845: LIST
85846: LIST
85847: LIST
85848: LIST
85849: LIST
85850: LIST
85851: LIST
85852: LIST
85853: LIST
85854: LIST
85855: IN
85856: NOT
85857: AND
85858: IFFALSE 85906
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
85860: LD_ADDR_EXP 83
85864: PUSH
85865: LD_EXP 83
85869: PPUSH
85870: LD_VAR 0 4
85874: PUSH
85875: LD_EXP 83
85879: PUSH
85880: LD_VAR 0 4
85884: ARRAY
85885: PUSH
85886: LD_INT 1
85888: PLUS
85889: PUSH
85890: EMPTY
85891: LIST
85892: LIST
85893: PPUSH
85894: LD_VAR 0 1
85898: PPUSH
85899: CALL 21397 0 3
85903: ST_TO_ADDR
85904: GO 85950
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
85906: LD_ADDR_EXP 80
85910: PUSH
85911: LD_EXP 80
85915: PPUSH
85916: LD_VAR 0 4
85920: PUSH
85921: LD_EXP 80
85925: PUSH
85926: LD_VAR 0 4
85930: ARRAY
85931: PUSH
85932: LD_INT 1
85934: PLUS
85935: PUSH
85936: EMPTY
85937: LIST
85938: LIST
85939: PPUSH
85940: LD_VAR 0 1
85944: PPUSH
85945: CALL 21397 0 3
85949: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
85950: LD_ADDR_EXP 105
85954: PUSH
85955: LD_INT 0
85957: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
85958: LD_VAR 0 1
85962: PPUSH
85963: CALL_OW 263
85967: PUSH
85968: LD_INT 2
85970: EQUAL
85971: IFFALSE 86000
// begin repeat wait ( 0 0$3 ) ;
85973: LD_INT 105
85975: PPUSH
85976: CALL_OW 67
// Connect ( vehicle ) ;
85980: LD_VAR 0 1
85984: PPUSH
85985: CALL 24743 0 1
// until IsControledBy ( vehicle ) ;
85989: LD_VAR 0 1
85993: PPUSH
85994: CALL_OW 312
85998: IFFALSE 85973
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
86000: LD_VAR 0 1
86004: PPUSH
86005: LD_EXP 85
86009: PUSH
86010: LD_VAR 0 4
86014: ARRAY
86015: PPUSH
86016: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
86020: LD_VAR 0 1
86024: PPUSH
86025: CALL_OW 263
86029: PUSH
86030: LD_INT 1
86032: NONEQUAL
86033: IFFALSE 86037
// break ;
86035: GO 86086
// repeat wait ( 0 0$1 ) ;
86037: LD_INT 35
86039: PPUSH
86040: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
86044: LD_VAR 0 1
86048: PPUSH
86049: LD_EXP 85
86053: PUSH
86054: LD_VAR 0 4
86058: ARRAY
86059: PPUSH
86060: CALL_OW 308
86064: IFFALSE 86037
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
86066: LD_VAR 0 1
86070: PPUSH
86071: CALL_OW 311
86075: PPUSH
86076: CALL_OW 121
// exit ;
86080: POP
86081: POP
86082: GO 86096
// end ; end ;
86084: GO 85728
86086: POP
86087: POP
// mc_block_vehicle_constructed_thread := false ;
86088: LD_ADDR_EXP 105
86092: PUSH
86093: LD_INT 0
86095: ST_TO_ADDR
// end ;
86096: LD_VAR 0 3
86100: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
86101: LD_INT 0
86103: PPUSH
86104: PPUSH
86105: PPUSH
86106: PPUSH
// if not mc_bases or not skirmish then
86107: LD_EXP 61
86111: NOT
86112: PUSH
86113: LD_EXP 59
86117: NOT
86118: OR
86119: IFFALSE 86123
// exit ;
86121: GO 86476
// repeat wait ( 0 0$1 ) ;
86123: LD_INT 35
86125: PPUSH
86126: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
86130: LD_VAR 0 2
86134: PPUSH
86135: LD_VAR 0 3
86139: PPUSH
86140: CALL_OW 284
86144: IFFALSE 86123
// if GetResourceTypeXY ( x , y ) = mat_artefact then
86146: LD_VAR 0 2
86150: PPUSH
86151: LD_VAR 0 3
86155: PPUSH
86156: CALL_OW 283
86160: PUSH
86161: LD_INT 4
86163: EQUAL
86164: IFFALSE 86168
// exit ;
86166: GO 86476
// for i = 1 to mc_bases do
86168: LD_ADDR_VAR 0 7
86172: PUSH
86173: DOUBLE
86174: LD_INT 1
86176: DEC
86177: ST_TO_ADDR
86178: LD_EXP 61
86182: PUSH
86183: FOR_TO
86184: IFFALSE 86474
// begin if mc_crates_area [ i ] then
86186: LD_EXP 79
86190: PUSH
86191: LD_VAR 0 7
86195: ARRAY
86196: IFFALSE 86307
// for j in mc_crates_area [ i ] do
86198: LD_ADDR_VAR 0 8
86202: PUSH
86203: LD_EXP 79
86207: PUSH
86208: LD_VAR 0 7
86212: ARRAY
86213: PUSH
86214: FOR_IN
86215: IFFALSE 86305
// if InArea ( x , y , j ) then
86217: LD_VAR 0 2
86221: PPUSH
86222: LD_VAR 0 3
86226: PPUSH
86227: LD_VAR 0 8
86231: PPUSH
86232: CALL_OW 309
86236: IFFALSE 86303
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
86238: LD_ADDR_EXP 77
86242: PUSH
86243: LD_EXP 77
86247: PPUSH
86248: LD_VAR 0 7
86252: PUSH
86253: LD_EXP 77
86257: PUSH
86258: LD_VAR 0 7
86262: ARRAY
86263: PUSH
86264: LD_INT 1
86266: PLUS
86267: PUSH
86268: EMPTY
86269: LIST
86270: LIST
86271: PPUSH
86272: LD_VAR 0 4
86276: PUSH
86277: LD_VAR 0 2
86281: PUSH
86282: LD_VAR 0 3
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: LIST
86291: PPUSH
86292: CALL 21397 0 3
86296: ST_TO_ADDR
// exit ;
86297: POP
86298: POP
86299: POP
86300: POP
86301: GO 86476
// end ;
86303: GO 86214
86305: POP
86306: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86307: LD_ADDR_VAR 0 9
86311: PUSH
86312: LD_EXP 61
86316: PUSH
86317: LD_VAR 0 7
86321: ARRAY
86322: PPUSH
86323: LD_INT 2
86325: PUSH
86326: LD_INT 30
86328: PUSH
86329: LD_INT 0
86331: PUSH
86332: EMPTY
86333: LIST
86334: LIST
86335: PUSH
86336: LD_INT 30
86338: PUSH
86339: LD_INT 1
86341: PUSH
86342: EMPTY
86343: LIST
86344: LIST
86345: PUSH
86346: EMPTY
86347: LIST
86348: LIST
86349: LIST
86350: PPUSH
86351: CALL_OW 72
86355: ST_TO_ADDR
// if not depot then
86356: LD_VAR 0 9
86360: NOT
86361: IFFALSE 86365
// continue ;
86363: GO 86183
// for j in depot do
86365: LD_ADDR_VAR 0 8
86369: PUSH
86370: LD_VAR 0 9
86374: PUSH
86375: FOR_IN
86376: IFFALSE 86470
// if GetDistUnitXY ( j , x , y ) < 30 then
86378: LD_VAR 0 8
86382: PPUSH
86383: LD_VAR 0 2
86387: PPUSH
86388: LD_VAR 0 3
86392: PPUSH
86393: CALL_OW 297
86397: PUSH
86398: LD_INT 30
86400: LESS
86401: IFFALSE 86468
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
86403: LD_ADDR_EXP 77
86407: PUSH
86408: LD_EXP 77
86412: PPUSH
86413: LD_VAR 0 7
86417: PUSH
86418: LD_EXP 77
86422: PUSH
86423: LD_VAR 0 7
86427: ARRAY
86428: PUSH
86429: LD_INT 1
86431: PLUS
86432: PUSH
86433: EMPTY
86434: LIST
86435: LIST
86436: PPUSH
86437: LD_VAR 0 4
86441: PUSH
86442: LD_VAR 0 2
86446: PUSH
86447: LD_VAR 0 3
86451: PUSH
86452: EMPTY
86453: LIST
86454: LIST
86455: LIST
86456: PPUSH
86457: CALL 21397 0 3
86461: ST_TO_ADDR
// exit ;
86462: POP
86463: POP
86464: POP
86465: POP
86466: GO 86476
// end ;
86468: GO 86375
86470: POP
86471: POP
// end ;
86472: GO 86183
86474: POP
86475: POP
// end ;
86476: LD_VAR 0 6
86480: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
86481: LD_INT 0
86483: PPUSH
86484: PPUSH
86485: PPUSH
86486: PPUSH
// if not mc_bases or not skirmish then
86487: LD_EXP 61
86491: NOT
86492: PUSH
86493: LD_EXP 59
86497: NOT
86498: OR
86499: IFFALSE 86503
// exit ;
86501: GO 86780
// side := GetSide ( lab ) ;
86503: LD_ADDR_VAR 0 4
86507: PUSH
86508: LD_VAR 0 2
86512: PPUSH
86513: CALL_OW 255
86517: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
86518: LD_VAR 0 4
86522: PUSH
86523: LD_EXP 87
86527: IN
86528: NOT
86529: PUSH
86530: LD_EXP 88
86534: NOT
86535: OR
86536: PUSH
86537: LD_EXP 61
86541: NOT
86542: OR
86543: IFFALSE 86547
// exit ;
86545: GO 86780
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
86547: LD_ADDR_EXP 88
86551: PUSH
86552: LD_EXP 88
86556: PPUSH
86557: LD_VAR 0 4
86561: PPUSH
86562: LD_EXP 88
86566: PUSH
86567: LD_VAR 0 4
86571: ARRAY
86572: PUSH
86573: LD_VAR 0 1
86577: DIFF
86578: PPUSH
86579: CALL_OW 1
86583: ST_TO_ADDR
// for i = 1 to mc_bases do
86584: LD_ADDR_VAR 0 5
86588: PUSH
86589: DOUBLE
86590: LD_INT 1
86592: DEC
86593: ST_TO_ADDR
86594: LD_EXP 61
86598: PUSH
86599: FOR_TO
86600: IFFALSE 86778
// begin if lab in mc_bases [ i ] then
86602: LD_VAR 0 2
86606: PUSH
86607: LD_EXP 61
86611: PUSH
86612: LD_VAR 0 5
86616: ARRAY
86617: IN
86618: IFFALSE 86776
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
86620: LD_VAR 0 1
86624: PUSH
86625: LD_INT 11
86627: PUSH
86628: LD_INT 4
86630: PUSH
86631: LD_INT 3
86633: PUSH
86634: LD_INT 2
86636: PUSH
86637: EMPTY
86638: LIST
86639: LIST
86640: LIST
86641: LIST
86642: IN
86643: PUSH
86644: LD_EXP 91
86648: PUSH
86649: LD_VAR 0 5
86653: ARRAY
86654: AND
86655: IFFALSE 86776
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
86657: LD_ADDR_VAR 0 6
86661: PUSH
86662: LD_EXP 91
86666: PUSH
86667: LD_VAR 0 5
86671: ARRAY
86672: PUSH
86673: LD_INT 1
86675: ARRAY
86676: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
86677: LD_ADDR_EXP 91
86681: PUSH
86682: LD_EXP 91
86686: PPUSH
86687: LD_VAR 0 5
86691: PPUSH
86692: EMPTY
86693: PPUSH
86694: CALL_OW 1
86698: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
86699: LD_VAR 0 6
86703: PPUSH
86704: LD_INT 0
86706: PPUSH
86707: CALL_OW 109
// ComExitBuilding ( tmp ) ;
86711: LD_VAR 0 6
86715: PPUSH
86716: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
86720: LD_ADDR_EXP 90
86724: PUSH
86725: LD_EXP 90
86729: PPUSH
86730: LD_VAR 0 5
86734: PPUSH
86735: LD_EXP 90
86739: PUSH
86740: LD_VAR 0 5
86744: ARRAY
86745: PPUSH
86746: LD_INT 1
86748: PPUSH
86749: LD_VAR 0 6
86753: PPUSH
86754: CALL_OW 2
86758: PPUSH
86759: CALL_OW 1
86763: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
86764: LD_VAR 0 5
86768: PPUSH
86769: LD_INT 112
86771: PPUSH
86772: CALL 63230 0 2
// end ; end ; end ;
86776: GO 86599
86778: POP
86779: POP
// end ;
86780: LD_VAR 0 3
86784: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
86785: LD_INT 0
86787: PPUSH
86788: PPUSH
86789: PPUSH
86790: PPUSH
86791: PPUSH
86792: PPUSH
86793: PPUSH
86794: PPUSH
// if not mc_bases or not skirmish then
86795: LD_EXP 61
86799: NOT
86800: PUSH
86801: LD_EXP 59
86805: NOT
86806: OR
86807: IFFALSE 86811
// exit ;
86809: GO 88180
// for i = 1 to mc_bases do
86811: LD_ADDR_VAR 0 3
86815: PUSH
86816: DOUBLE
86817: LD_INT 1
86819: DEC
86820: ST_TO_ADDR
86821: LD_EXP 61
86825: PUSH
86826: FOR_TO
86827: IFFALSE 88178
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
86829: LD_VAR 0 1
86833: PUSH
86834: LD_EXP 61
86838: PUSH
86839: LD_VAR 0 3
86843: ARRAY
86844: IN
86845: PUSH
86846: LD_VAR 0 1
86850: PUSH
86851: LD_EXP 68
86855: PUSH
86856: LD_VAR 0 3
86860: ARRAY
86861: IN
86862: OR
86863: PUSH
86864: LD_VAR 0 1
86868: PUSH
86869: LD_EXP 83
86873: PUSH
86874: LD_VAR 0 3
86878: ARRAY
86879: IN
86880: OR
86881: PUSH
86882: LD_VAR 0 1
86886: PUSH
86887: LD_EXP 80
86891: PUSH
86892: LD_VAR 0 3
86896: ARRAY
86897: IN
86898: OR
86899: PUSH
86900: LD_VAR 0 1
86904: PUSH
86905: LD_EXP 90
86909: PUSH
86910: LD_VAR 0 3
86914: ARRAY
86915: IN
86916: OR
86917: PUSH
86918: LD_VAR 0 1
86922: PUSH
86923: LD_EXP 91
86927: PUSH
86928: LD_VAR 0 3
86932: ARRAY
86933: IN
86934: OR
86935: IFFALSE 88176
// begin if un in mc_ape [ i ] then
86937: LD_VAR 0 1
86941: PUSH
86942: LD_EXP 90
86946: PUSH
86947: LD_VAR 0 3
86951: ARRAY
86952: IN
86953: IFFALSE 86992
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
86955: LD_ADDR_EXP 90
86959: PUSH
86960: LD_EXP 90
86964: PPUSH
86965: LD_VAR 0 3
86969: PPUSH
86970: LD_EXP 90
86974: PUSH
86975: LD_VAR 0 3
86979: ARRAY
86980: PUSH
86981: LD_VAR 0 1
86985: DIFF
86986: PPUSH
86987: CALL_OW 1
86991: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
86992: LD_VAR 0 1
86996: PUSH
86997: LD_EXP 91
87001: PUSH
87002: LD_VAR 0 3
87006: ARRAY
87007: IN
87008: IFFALSE 87032
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
87010: LD_ADDR_EXP 91
87014: PUSH
87015: LD_EXP 91
87019: PPUSH
87020: LD_VAR 0 3
87024: PPUSH
87025: EMPTY
87026: PPUSH
87027: CALL_OW 1
87031: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
87032: LD_VAR 0 1
87036: PPUSH
87037: CALL_OW 247
87041: PUSH
87042: LD_INT 2
87044: EQUAL
87045: PUSH
87046: LD_VAR 0 1
87050: PPUSH
87051: CALL_OW 110
87055: PUSH
87056: LD_INT 20
87058: EQUAL
87059: PUSH
87060: LD_VAR 0 1
87064: PUSH
87065: LD_EXP 83
87069: PUSH
87070: LD_VAR 0 3
87074: ARRAY
87075: IN
87076: OR
87077: PUSH
87078: LD_VAR 0 1
87082: PPUSH
87083: CALL_OW 264
87087: PUSH
87088: LD_INT 12
87090: PUSH
87091: LD_INT 51
87093: PUSH
87094: LD_INT 89
87096: PUSH
87097: LD_INT 32
87099: PUSH
87100: LD_INT 13
87102: PUSH
87103: LD_INT 52
87105: PUSH
87106: LD_INT 31
87108: PUSH
87109: EMPTY
87110: LIST
87111: LIST
87112: LIST
87113: LIST
87114: LIST
87115: LIST
87116: LIST
87117: IN
87118: OR
87119: AND
87120: IFFALSE 87428
// begin if un in mc_defender [ i ] then
87122: LD_VAR 0 1
87126: PUSH
87127: LD_EXP 83
87131: PUSH
87132: LD_VAR 0 3
87136: ARRAY
87137: IN
87138: IFFALSE 87177
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
87140: LD_ADDR_EXP 83
87144: PUSH
87145: LD_EXP 83
87149: PPUSH
87150: LD_VAR 0 3
87154: PPUSH
87155: LD_EXP 83
87159: PUSH
87160: LD_VAR 0 3
87164: ARRAY
87165: PUSH
87166: LD_VAR 0 1
87170: DIFF
87171: PPUSH
87172: CALL_OW 1
87176: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
87177: LD_ADDR_VAR 0 8
87181: PUSH
87182: LD_VAR 0 3
87186: PPUSH
87187: LD_INT 3
87189: PPUSH
87190: CALL 83798 0 2
87194: ST_TO_ADDR
// if fac then
87195: LD_VAR 0 8
87199: IFFALSE 87428
// begin for j in fac do
87201: LD_ADDR_VAR 0 4
87205: PUSH
87206: LD_VAR 0 8
87210: PUSH
87211: FOR_IN
87212: IFFALSE 87426
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
87214: LD_ADDR_VAR 0 9
87218: PUSH
87219: LD_VAR 0 8
87223: PPUSH
87224: LD_VAR 0 1
87228: PPUSH
87229: CALL_OW 265
87233: PPUSH
87234: LD_VAR 0 1
87238: PPUSH
87239: CALL_OW 262
87243: PPUSH
87244: LD_VAR 0 1
87248: PPUSH
87249: CALL_OW 263
87253: PPUSH
87254: LD_VAR 0 1
87258: PPUSH
87259: CALL_OW 264
87263: PPUSH
87264: CALL 18895 0 5
87268: ST_TO_ADDR
// if components then
87269: LD_VAR 0 9
87273: IFFALSE 87424
// begin if GetWeapon ( un ) = ar_control_tower then
87275: LD_VAR 0 1
87279: PPUSH
87280: CALL_OW 264
87284: PUSH
87285: LD_INT 31
87287: EQUAL
87288: IFFALSE 87405
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
87290: LD_VAR 0 1
87294: PPUSH
87295: CALL_OW 311
87299: PPUSH
87300: LD_INT 0
87302: PPUSH
87303: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
87307: LD_ADDR_EXP 101
87311: PUSH
87312: LD_EXP 101
87316: PPUSH
87317: LD_VAR 0 3
87321: PPUSH
87322: LD_EXP 101
87326: PUSH
87327: LD_VAR 0 3
87331: ARRAY
87332: PUSH
87333: LD_VAR 0 1
87337: PPUSH
87338: CALL_OW 311
87342: DIFF
87343: PPUSH
87344: CALL_OW 1
87348: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
87349: LD_ADDR_VAR 0 7
87353: PUSH
87354: LD_EXP 82
87358: PUSH
87359: LD_VAR 0 3
87363: ARRAY
87364: PPUSH
87365: LD_INT 1
87367: PPUSH
87368: LD_VAR 0 9
87372: PPUSH
87373: CALL_OW 2
87377: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
87378: LD_ADDR_EXP 82
87382: PUSH
87383: LD_EXP 82
87387: PPUSH
87388: LD_VAR 0 3
87392: PPUSH
87393: LD_VAR 0 7
87397: PPUSH
87398: CALL_OW 1
87402: ST_TO_ADDR
// end else
87403: GO 87422
// MC_InsertProduceList ( i , [ components ] ) ;
87405: LD_VAR 0 3
87409: PPUSH
87410: LD_VAR 0 9
87414: PUSH
87415: EMPTY
87416: LIST
87417: PPUSH
87418: CALL 83343 0 2
// break ;
87422: GO 87426
// end ; end ;
87424: GO 87211
87426: POP
87427: POP
// end ; end ; if GetType ( un ) = unit_building then
87428: LD_VAR 0 1
87432: PPUSH
87433: CALL_OW 247
87437: PUSH
87438: LD_INT 3
87440: EQUAL
87441: IFFALSE 87844
// begin btype := GetBType ( un ) ;
87443: LD_ADDR_VAR 0 5
87447: PUSH
87448: LD_VAR 0 1
87452: PPUSH
87453: CALL_OW 266
87457: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
87458: LD_VAR 0 5
87462: PUSH
87463: LD_INT 29
87465: PUSH
87466: LD_INT 30
87468: PUSH
87469: EMPTY
87470: LIST
87471: LIST
87472: IN
87473: IFFALSE 87546
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
87475: LD_VAR 0 1
87479: PPUSH
87480: CALL_OW 250
87484: PPUSH
87485: LD_VAR 0 1
87489: PPUSH
87490: CALL_OW 251
87494: PPUSH
87495: LD_VAR 0 1
87499: PPUSH
87500: CALL_OW 255
87504: PPUSH
87505: CALL_OW 440
87509: NOT
87510: IFFALSE 87546
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
87512: LD_VAR 0 1
87516: PPUSH
87517: CALL_OW 250
87521: PPUSH
87522: LD_VAR 0 1
87526: PPUSH
87527: CALL_OW 251
87531: PPUSH
87532: LD_VAR 0 1
87536: PPUSH
87537: CALL_OW 255
87541: PPUSH
87542: CALL_OW 441
// end ; if btype = b_warehouse then
87546: LD_VAR 0 5
87550: PUSH
87551: LD_INT 1
87553: EQUAL
87554: IFFALSE 87572
// begin btype := b_depot ;
87556: LD_ADDR_VAR 0 5
87560: PUSH
87561: LD_INT 0
87563: ST_TO_ADDR
// pos := 1 ;
87564: LD_ADDR_VAR 0 6
87568: PUSH
87569: LD_INT 1
87571: ST_TO_ADDR
// end ; if btype = b_factory then
87572: LD_VAR 0 5
87576: PUSH
87577: LD_INT 3
87579: EQUAL
87580: IFFALSE 87598
// begin btype := b_workshop ;
87582: LD_ADDR_VAR 0 5
87586: PUSH
87587: LD_INT 2
87589: ST_TO_ADDR
// pos := 1 ;
87590: LD_ADDR_VAR 0 6
87594: PUSH
87595: LD_INT 1
87597: ST_TO_ADDR
// end ; if btype = b_barracks then
87598: LD_VAR 0 5
87602: PUSH
87603: LD_INT 5
87605: EQUAL
87606: IFFALSE 87616
// btype := b_armoury ;
87608: LD_ADDR_VAR 0 5
87612: PUSH
87613: LD_INT 4
87615: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
87616: LD_VAR 0 5
87620: PUSH
87621: LD_INT 7
87623: PUSH
87624: LD_INT 8
87626: PUSH
87627: EMPTY
87628: LIST
87629: LIST
87630: IN
87631: IFFALSE 87641
// btype := b_lab ;
87633: LD_ADDR_VAR 0 5
87637: PUSH
87638: LD_INT 6
87640: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
87641: LD_ADDR_EXP 66
87645: PUSH
87646: LD_EXP 66
87650: PPUSH
87651: LD_VAR 0 3
87655: PUSH
87656: LD_EXP 66
87660: PUSH
87661: LD_VAR 0 3
87665: ARRAY
87666: PUSH
87667: LD_INT 1
87669: PLUS
87670: PUSH
87671: EMPTY
87672: LIST
87673: LIST
87674: PPUSH
87675: LD_VAR 0 5
87679: PUSH
87680: LD_VAR 0 1
87684: PPUSH
87685: CALL_OW 250
87689: PUSH
87690: LD_VAR 0 1
87694: PPUSH
87695: CALL_OW 251
87699: PUSH
87700: LD_VAR 0 1
87704: PPUSH
87705: CALL_OW 254
87709: PUSH
87710: EMPTY
87711: LIST
87712: LIST
87713: LIST
87714: LIST
87715: PPUSH
87716: CALL 21397 0 3
87720: ST_TO_ADDR
// if pos = 1 then
87721: LD_VAR 0 6
87725: PUSH
87726: LD_INT 1
87728: EQUAL
87729: IFFALSE 87844
// begin tmp := mc_build_list [ i ] ;
87731: LD_ADDR_VAR 0 7
87735: PUSH
87736: LD_EXP 66
87740: PUSH
87741: LD_VAR 0 3
87745: ARRAY
87746: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
87747: LD_VAR 0 7
87751: PPUSH
87752: LD_INT 2
87754: PUSH
87755: LD_INT 30
87757: PUSH
87758: LD_INT 0
87760: PUSH
87761: EMPTY
87762: LIST
87763: LIST
87764: PUSH
87765: LD_INT 30
87767: PUSH
87768: LD_INT 1
87770: PUSH
87771: EMPTY
87772: LIST
87773: LIST
87774: PUSH
87775: EMPTY
87776: LIST
87777: LIST
87778: LIST
87779: PPUSH
87780: CALL_OW 72
87784: IFFALSE 87794
// pos := 2 ;
87786: LD_ADDR_VAR 0 6
87790: PUSH
87791: LD_INT 2
87793: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
87794: LD_ADDR_VAR 0 7
87798: PUSH
87799: LD_VAR 0 7
87803: PPUSH
87804: LD_VAR 0 6
87808: PPUSH
87809: LD_VAR 0 7
87813: PPUSH
87814: CALL 21723 0 3
87818: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
87819: LD_ADDR_EXP 66
87823: PUSH
87824: LD_EXP 66
87828: PPUSH
87829: LD_VAR 0 3
87833: PPUSH
87834: LD_VAR 0 7
87838: PPUSH
87839: CALL_OW 1
87843: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
87844: LD_VAR 0 1
87848: PUSH
87849: LD_EXP 61
87853: PUSH
87854: LD_VAR 0 3
87858: ARRAY
87859: IN
87860: IFFALSE 87899
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
87862: LD_ADDR_EXP 61
87866: PUSH
87867: LD_EXP 61
87871: PPUSH
87872: LD_VAR 0 3
87876: PPUSH
87877: LD_EXP 61
87881: PUSH
87882: LD_VAR 0 3
87886: ARRAY
87887: PUSH
87888: LD_VAR 0 1
87892: DIFF
87893: PPUSH
87894: CALL_OW 1
87898: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
87899: LD_VAR 0 1
87903: PUSH
87904: LD_EXP 68
87908: PUSH
87909: LD_VAR 0 3
87913: ARRAY
87914: IN
87915: IFFALSE 87954
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
87917: LD_ADDR_EXP 68
87921: PUSH
87922: LD_EXP 68
87926: PPUSH
87927: LD_VAR 0 3
87931: PPUSH
87932: LD_EXP 68
87936: PUSH
87937: LD_VAR 0 3
87941: ARRAY
87942: PUSH
87943: LD_VAR 0 1
87947: DIFF
87948: PPUSH
87949: CALL_OW 1
87953: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
87954: LD_VAR 0 1
87958: PUSH
87959: LD_EXP 80
87963: PUSH
87964: LD_VAR 0 3
87968: ARRAY
87969: IN
87970: IFFALSE 88009
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
87972: LD_ADDR_EXP 80
87976: PUSH
87977: LD_EXP 80
87981: PPUSH
87982: LD_VAR 0 3
87986: PPUSH
87987: LD_EXP 80
87991: PUSH
87992: LD_VAR 0 3
87996: ARRAY
87997: PUSH
87998: LD_VAR 0 1
88002: DIFF
88003: PPUSH
88004: CALL_OW 1
88008: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
88009: LD_VAR 0 1
88013: PUSH
88014: LD_EXP 83
88018: PUSH
88019: LD_VAR 0 3
88023: ARRAY
88024: IN
88025: IFFALSE 88064
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
88027: LD_ADDR_EXP 83
88031: PUSH
88032: LD_EXP 83
88036: PPUSH
88037: LD_VAR 0 3
88041: PPUSH
88042: LD_EXP 83
88046: PUSH
88047: LD_VAR 0 3
88051: ARRAY
88052: PUSH
88053: LD_VAR 0 1
88057: DIFF
88058: PPUSH
88059: CALL_OW 1
88063: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
88064: LD_VAR 0 1
88068: PUSH
88069: LD_EXP 70
88073: PUSH
88074: LD_VAR 0 3
88078: ARRAY
88079: IN
88080: IFFALSE 88119
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
88082: LD_ADDR_EXP 70
88086: PUSH
88087: LD_EXP 70
88091: PPUSH
88092: LD_VAR 0 3
88096: PPUSH
88097: LD_EXP 70
88101: PUSH
88102: LD_VAR 0 3
88106: ARRAY
88107: PUSH
88108: LD_VAR 0 1
88112: DIFF
88113: PPUSH
88114: CALL_OW 1
88118: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
88119: LD_VAR 0 1
88123: PUSH
88124: LD_EXP 69
88128: PUSH
88129: LD_VAR 0 3
88133: ARRAY
88134: IN
88135: IFFALSE 88174
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
88137: LD_ADDR_EXP 69
88141: PUSH
88142: LD_EXP 69
88146: PPUSH
88147: LD_VAR 0 3
88151: PPUSH
88152: LD_EXP 69
88156: PUSH
88157: LD_VAR 0 3
88161: ARRAY
88162: PUSH
88163: LD_VAR 0 1
88167: DIFF
88168: PPUSH
88169: CALL_OW 1
88173: ST_TO_ADDR
// end ; break ;
88174: GO 88178
// end ;
88176: GO 86826
88178: POP
88179: POP
// end ;
88180: LD_VAR 0 2
88184: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
88185: LD_INT 0
88187: PPUSH
88188: PPUSH
88189: PPUSH
// if not mc_bases or not skirmish then
88190: LD_EXP 61
88194: NOT
88195: PUSH
88196: LD_EXP 59
88200: NOT
88201: OR
88202: IFFALSE 88206
// exit ;
88204: GO 88421
// for i = 1 to mc_bases do
88206: LD_ADDR_VAR 0 3
88210: PUSH
88211: DOUBLE
88212: LD_INT 1
88214: DEC
88215: ST_TO_ADDR
88216: LD_EXP 61
88220: PUSH
88221: FOR_TO
88222: IFFALSE 88419
// begin if building in mc_construct_list [ i ] then
88224: LD_VAR 0 1
88228: PUSH
88229: LD_EXP 68
88233: PUSH
88234: LD_VAR 0 3
88238: ARRAY
88239: IN
88240: IFFALSE 88417
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
88242: LD_ADDR_EXP 68
88246: PUSH
88247: LD_EXP 68
88251: PPUSH
88252: LD_VAR 0 3
88256: PPUSH
88257: LD_EXP 68
88261: PUSH
88262: LD_VAR 0 3
88266: ARRAY
88267: PUSH
88268: LD_VAR 0 1
88272: DIFF
88273: PPUSH
88274: CALL_OW 1
88278: ST_TO_ADDR
// if building in mc_lab [ i ] then
88279: LD_VAR 0 1
88283: PUSH
88284: LD_EXP 94
88288: PUSH
88289: LD_VAR 0 3
88293: ARRAY
88294: IN
88295: IFFALSE 88350
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
88297: LD_ADDR_EXP 95
88301: PUSH
88302: LD_EXP 95
88306: PPUSH
88307: LD_VAR 0 3
88311: PPUSH
88312: LD_EXP 95
88316: PUSH
88317: LD_VAR 0 3
88321: ARRAY
88322: PPUSH
88323: LD_INT 1
88325: PPUSH
88326: LD_EXP 95
88330: PUSH
88331: LD_VAR 0 3
88335: ARRAY
88336: PPUSH
88337: LD_INT 0
88339: PPUSH
88340: CALL 20815 0 4
88344: PPUSH
88345: CALL_OW 1
88349: ST_TO_ADDR
// if not building in mc_bases [ i ] then
88350: LD_VAR 0 1
88354: PUSH
88355: LD_EXP 61
88359: PUSH
88360: LD_VAR 0 3
88364: ARRAY
88365: IN
88366: NOT
88367: IFFALSE 88413
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
88369: LD_ADDR_EXP 61
88373: PUSH
88374: LD_EXP 61
88378: PPUSH
88379: LD_VAR 0 3
88383: PUSH
88384: LD_EXP 61
88388: PUSH
88389: LD_VAR 0 3
88393: ARRAY
88394: PUSH
88395: LD_INT 1
88397: PLUS
88398: PUSH
88399: EMPTY
88400: LIST
88401: LIST
88402: PPUSH
88403: LD_VAR 0 1
88407: PPUSH
88408: CALL 21397 0 3
88412: ST_TO_ADDR
// exit ;
88413: POP
88414: POP
88415: GO 88421
// end ; end ;
88417: GO 88221
88419: POP
88420: POP
// end ;
88421: LD_VAR 0 2
88425: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
88426: LD_INT 0
88428: PPUSH
88429: PPUSH
88430: PPUSH
88431: PPUSH
88432: PPUSH
88433: PPUSH
88434: PPUSH
// if not mc_bases or not skirmish then
88435: LD_EXP 61
88439: NOT
88440: PUSH
88441: LD_EXP 59
88445: NOT
88446: OR
88447: IFFALSE 88451
// exit ;
88449: GO 89112
// for i = 1 to mc_bases do
88451: LD_ADDR_VAR 0 3
88455: PUSH
88456: DOUBLE
88457: LD_INT 1
88459: DEC
88460: ST_TO_ADDR
88461: LD_EXP 61
88465: PUSH
88466: FOR_TO
88467: IFFALSE 89110
// begin if building in mc_construct_list [ i ] then
88469: LD_VAR 0 1
88473: PUSH
88474: LD_EXP 68
88478: PUSH
88479: LD_VAR 0 3
88483: ARRAY
88484: IN
88485: IFFALSE 89108
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
88487: LD_ADDR_EXP 68
88491: PUSH
88492: LD_EXP 68
88496: PPUSH
88497: LD_VAR 0 3
88501: PPUSH
88502: LD_EXP 68
88506: PUSH
88507: LD_VAR 0 3
88511: ARRAY
88512: PUSH
88513: LD_VAR 0 1
88517: DIFF
88518: PPUSH
88519: CALL_OW 1
88523: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
88524: LD_ADDR_EXP 61
88528: PUSH
88529: LD_EXP 61
88533: PPUSH
88534: LD_VAR 0 3
88538: PUSH
88539: LD_EXP 61
88543: PUSH
88544: LD_VAR 0 3
88548: ARRAY
88549: PUSH
88550: LD_INT 1
88552: PLUS
88553: PUSH
88554: EMPTY
88555: LIST
88556: LIST
88557: PPUSH
88558: LD_VAR 0 1
88562: PPUSH
88563: CALL 21397 0 3
88567: ST_TO_ADDR
// btype := GetBType ( building ) ;
88568: LD_ADDR_VAR 0 5
88572: PUSH
88573: LD_VAR 0 1
88577: PPUSH
88578: CALL_OW 266
88582: ST_TO_ADDR
// side := GetSide ( building ) ;
88583: LD_ADDR_VAR 0 8
88587: PUSH
88588: LD_VAR 0 1
88592: PPUSH
88593: CALL_OW 255
88597: ST_TO_ADDR
// if btype = b_lab then
88598: LD_VAR 0 5
88602: PUSH
88603: LD_INT 6
88605: EQUAL
88606: IFFALSE 88656
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
88608: LD_ADDR_EXP 94
88612: PUSH
88613: LD_EXP 94
88617: PPUSH
88618: LD_VAR 0 3
88622: PUSH
88623: LD_EXP 94
88627: PUSH
88628: LD_VAR 0 3
88632: ARRAY
88633: PUSH
88634: LD_INT 1
88636: PLUS
88637: PUSH
88638: EMPTY
88639: LIST
88640: LIST
88641: PPUSH
88642: LD_VAR 0 1
88646: PPUSH
88647: CALL 21397 0 3
88651: ST_TO_ADDR
// exit ;
88652: POP
88653: POP
88654: GO 89112
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
88656: LD_VAR 0 5
88660: PUSH
88661: LD_INT 0
88663: PUSH
88664: LD_INT 2
88666: PUSH
88667: LD_INT 4
88669: PUSH
88670: EMPTY
88671: LIST
88672: LIST
88673: LIST
88674: IN
88675: IFFALSE 88799
// begin if btype = b_armoury then
88677: LD_VAR 0 5
88681: PUSH
88682: LD_INT 4
88684: EQUAL
88685: IFFALSE 88695
// btype := b_barracks ;
88687: LD_ADDR_VAR 0 5
88691: PUSH
88692: LD_INT 5
88694: ST_TO_ADDR
// if btype = b_depot then
88695: LD_VAR 0 5
88699: PUSH
88700: LD_INT 0
88702: EQUAL
88703: IFFALSE 88713
// btype := b_warehouse ;
88705: LD_ADDR_VAR 0 5
88709: PUSH
88710: LD_INT 1
88712: ST_TO_ADDR
// if btype = b_workshop then
88713: LD_VAR 0 5
88717: PUSH
88718: LD_INT 2
88720: EQUAL
88721: IFFALSE 88731
// btype := b_factory ;
88723: LD_ADDR_VAR 0 5
88727: PUSH
88728: LD_INT 3
88730: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
88731: LD_VAR 0 5
88735: PPUSH
88736: LD_VAR 0 8
88740: PPUSH
88741: CALL_OW 323
88745: PUSH
88746: LD_INT 1
88748: EQUAL
88749: IFFALSE 88795
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
88751: LD_ADDR_EXP 93
88755: PUSH
88756: LD_EXP 93
88760: PPUSH
88761: LD_VAR 0 3
88765: PUSH
88766: LD_EXP 93
88770: PUSH
88771: LD_VAR 0 3
88775: ARRAY
88776: PUSH
88777: LD_INT 1
88779: PLUS
88780: PUSH
88781: EMPTY
88782: LIST
88783: LIST
88784: PPUSH
88785: LD_VAR 0 1
88789: PPUSH
88790: CALL 21397 0 3
88794: ST_TO_ADDR
// exit ;
88795: POP
88796: POP
88797: GO 89112
// end ; if btype in [ b_bunker , b_turret ] then
88799: LD_VAR 0 5
88803: PUSH
88804: LD_INT 32
88806: PUSH
88807: LD_INT 33
88809: PUSH
88810: EMPTY
88811: LIST
88812: LIST
88813: IN
88814: IFFALSE 89104
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
88816: LD_ADDR_EXP 69
88820: PUSH
88821: LD_EXP 69
88825: PPUSH
88826: LD_VAR 0 3
88830: PUSH
88831: LD_EXP 69
88835: PUSH
88836: LD_VAR 0 3
88840: ARRAY
88841: PUSH
88842: LD_INT 1
88844: PLUS
88845: PUSH
88846: EMPTY
88847: LIST
88848: LIST
88849: PPUSH
88850: LD_VAR 0 1
88854: PPUSH
88855: CALL 21397 0 3
88859: ST_TO_ADDR
// if btype = b_bunker then
88860: LD_VAR 0 5
88864: PUSH
88865: LD_INT 32
88867: EQUAL
88868: IFFALSE 89104
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
88870: LD_ADDR_EXP 70
88874: PUSH
88875: LD_EXP 70
88879: PPUSH
88880: LD_VAR 0 3
88884: PUSH
88885: LD_EXP 70
88889: PUSH
88890: LD_VAR 0 3
88894: ARRAY
88895: PUSH
88896: LD_INT 1
88898: PLUS
88899: PUSH
88900: EMPTY
88901: LIST
88902: LIST
88903: PPUSH
88904: LD_VAR 0 1
88908: PPUSH
88909: CALL 21397 0 3
88913: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
88914: LD_ADDR_VAR 0 6
88918: PUSH
88919: LD_EXP 61
88923: PUSH
88924: LD_VAR 0 3
88928: ARRAY
88929: PPUSH
88930: LD_INT 25
88932: PUSH
88933: LD_INT 1
88935: PUSH
88936: EMPTY
88937: LIST
88938: LIST
88939: PUSH
88940: LD_INT 3
88942: PUSH
88943: LD_INT 54
88945: PUSH
88946: EMPTY
88947: LIST
88948: PUSH
88949: EMPTY
88950: LIST
88951: LIST
88952: PUSH
88953: EMPTY
88954: LIST
88955: LIST
88956: PPUSH
88957: CALL_OW 72
88961: ST_TO_ADDR
// if tmp then
88962: LD_VAR 0 6
88966: IFFALSE 88972
// exit ;
88968: POP
88969: POP
88970: GO 89112
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
88972: LD_ADDR_VAR 0 6
88976: PUSH
88977: LD_EXP 61
88981: PUSH
88982: LD_VAR 0 3
88986: ARRAY
88987: PPUSH
88988: LD_INT 2
88990: PUSH
88991: LD_INT 30
88993: PUSH
88994: LD_INT 4
88996: PUSH
88997: EMPTY
88998: LIST
88999: LIST
89000: PUSH
89001: LD_INT 30
89003: PUSH
89004: LD_INT 5
89006: PUSH
89007: EMPTY
89008: LIST
89009: LIST
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: LIST
89015: PPUSH
89016: CALL_OW 72
89020: ST_TO_ADDR
// if not tmp then
89021: LD_VAR 0 6
89025: NOT
89026: IFFALSE 89032
// exit ;
89028: POP
89029: POP
89030: GO 89112
// for j in tmp do
89032: LD_ADDR_VAR 0 4
89036: PUSH
89037: LD_VAR 0 6
89041: PUSH
89042: FOR_IN
89043: IFFALSE 89102
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
89045: LD_ADDR_VAR 0 7
89049: PUSH
89050: LD_VAR 0 4
89054: PPUSH
89055: CALL_OW 313
89059: PPUSH
89060: LD_INT 25
89062: PUSH
89063: LD_INT 1
89065: PUSH
89066: EMPTY
89067: LIST
89068: LIST
89069: PPUSH
89070: CALL_OW 72
89074: ST_TO_ADDR
// if units then
89075: LD_VAR 0 7
89079: IFFALSE 89100
// begin ComExitBuilding ( units [ 1 ] ) ;
89081: LD_VAR 0 7
89085: PUSH
89086: LD_INT 1
89088: ARRAY
89089: PPUSH
89090: CALL_OW 122
// exit ;
89094: POP
89095: POP
89096: POP
89097: POP
89098: GO 89112
// end ; end ;
89100: GO 89042
89102: POP
89103: POP
// end ; end ; exit ;
89104: POP
89105: POP
89106: GO 89112
// end ; end ;
89108: GO 88466
89110: POP
89111: POP
// end ;
89112: LD_VAR 0 2
89116: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
89117: LD_INT 0
89119: PPUSH
89120: PPUSH
89121: PPUSH
89122: PPUSH
89123: PPUSH
89124: PPUSH
89125: PPUSH
// if not mc_bases or not skirmish then
89126: LD_EXP 61
89130: NOT
89131: PUSH
89132: LD_EXP 59
89136: NOT
89137: OR
89138: IFFALSE 89142
// exit ;
89140: GO 89407
// btype := GetBType ( building ) ;
89142: LD_ADDR_VAR 0 6
89146: PUSH
89147: LD_VAR 0 1
89151: PPUSH
89152: CALL_OW 266
89156: ST_TO_ADDR
// x := GetX ( building ) ;
89157: LD_ADDR_VAR 0 7
89161: PUSH
89162: LD_VAR 0 1
89166: PPUSH
89167: CALL_OW 250
89171: ST_TO_ADDR
// y := GetY ( building ) ;
89172: LD_ADDR_VAR 0 8
89176: PUSH
89177: LD_VAR 0 1
89181: PPUSH
89182: CALL_OW 251
89186: ST_TO_ADDR
// d := GetDir ( building ) ;
89187: LD_ADDR_VAR 0 9
89191: PUSH
89192: LD_VAR 0 1
89196: PPUSH
89197: CALL_OW 254
89201: ST_TO_ADDR
// for i = 1 to mc_bases do
89202: LD_ADDR_VAR 0 4
89206: PUSH
89207: DOUBLE
89208: LD_INT 1
89210: DEC
89211: ST_TO_ADDR
89212: LD_EXP 61
89216: PUSH
89217: FOR_TO
89218: IFFALSE 89405
// begin if not mc_build_list [ i ] then
89220: LD_EXP 66
89224: PUSH
89225: LD_VAR 0 4
89229: ARRAY
89230: NOT
89231: IFFALSE 89235
// continue ;
89233: GO 89217
// for j := 1 to mc_build_list [ i ] do
89235: LD_ADDR_VAR 0 5
89239: PUSH
89240: DOUBLE
89241: LD_INT 1
89243: DEC
89244: ST_TO_ADDR
89245: LD_EXP 66
89249: PUSH
89250: LD_VAR 0 4
89254: ARRAY
89255: PUSH
89256: FOR_TO
89257: IFFALSE 89401
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
89259: LD_VAR 0 6
89263: PUSH
89264: LD_VAR 0 7
89268: PUSH
89269: LD_VAR 0 8
89273: PUSH
89274: LD_VAR 0 9
89278: PUSH
89279: EMPTY
89280: LIST
89281: LIST
89282: LIST
89283: LIST
89284: PPUSH
89285: LD_EXP 66
89289: PUSH
89290: LD_VAR 0 4
89294: ARRAY
89295: PUSH
89296: LD_VAR 0 5
89300: ARRAY
89301: PPUSH
89302: CALL 27954 0 2
89306: IFFALSE 89399
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
89308: LD_ADDR_EXP 66
89312: PUSH
89313: LD_EXP 66
89317: PPUSH
89318: LD_VAR 0 4
89322: PPUSH
89323: LD_EXP 66
89327: PUSH
89328: LD_VAR 0 4
89332: ARRAY
89333: PPUSH
89334: LD_VAR 0 5
89338: PPUSH
89339: CALL_OW 3
89343: PPUSH
89344: CALL_OW 1
89348: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
89349: LD_ADDR_EXP 68
89353: PUSH
89354: LD_EXP 68
89358: PPUSH
89359: LD_VAR 0 4
89363: PUSH
89364: LD_EXP 68
89368: PUSH
89369: LD_VAR 0 4
89373: ARRAY
89374: PUSH
89375: LD_INT 1
89377: PLUS
89378: PUSH
89379: EMPTY
89380: LIST
89381: LIST
89382: PPUSH
89383: LD_VAR 0 1
89387: PPUSH
89388: CALL 21397 0 3
89392: ST_TO_ADDR
// exit ;
89393: POP
89394: POP
89395: POP
89396: POP
89397: GO 89407
// end ;
89399: GO 89256
89401: POP
89402: POP
// end ;
89403: GO 89217
89405: POP
89406: POP
// end ;
89407: LD_VAR 0 3
89411: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
89412: LD_INT 0
89414: PPUSH
89415: PPUSH
89416: PPUSH
// if not mc_bases or not skirmish then
89417: LD_EXP 61
89421: NOT
89422: PUSH
89423: LD_EXP 59
89427: NOT
89428: OR
89429: IFFALSE 89433
// exit ;
89431: GO 89623
// for i = 1 to mc_bases do
89433: LD_ADDR_VAR 0 4
89437: PUSH
89438: DOUBLE
89439: LD_INT 1
89441: DEC
89442: ST_TO_ADDR
89443: LD_EXP 61
89447: PUSH
89448: FOR_TO
89449: IFFALSE 89536
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
89451: LD_VAR 0 1
89455: PUSH
89456: LD_EXP 69
89460: PUSH
89461: LD_VAR 0 4
89465: ARRAY
89466: IN
89467: PUSH
89468: LD_VAR 0 1
89472: PUSH
89473: LD_EXP 70
89477: PUSH
89478: LD_VAR 0 4
89482: ARRAY
89483: IN
89484: NOT
89485: AND
89486: IFFALSE 89534
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
89488: LD_ADDR_EXP 70
89492: PUSH
89493: LD_EXP 70
89497: PPUSH
89498: LD_VAR 0 4
89502: PUSH
89503: LD_EXP 70
89507: PUSH
89508: LD_VAR 0 4
89512: ARRAY
89513: PUSH
89514: LD_INT 1
89516: PLUS
89517: PUSH
89518: EMPTY
89519: LIST
89520: LIST
89521: PPUSH
89522: LD_VAR 0 1
89526: PPUSH
89527: CALL 21397 0 3
89531: ST_TO_ADDR
// break ;
89532: GO 89536
// end ; end ;
89534: GO 89448
89536: POP
89537: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
89538: LD_VAR 0 1
89542: PPUSH
89543: CALL_OW 257
89547: PUSH
89548: LD_EXP 87
89552: IN
89553: PUSH
89554: LD_VAR 0 1
89558: PPUSH
89559: CALL_OW 266
89563: PUSH
89564: LD_INT 5
89566: EQUAL
89567: AND
89568: PUSH
89569: LD_VAR 0 2
89573: PPUSH
89574: CALL_OW 110
89578: PUSH
89579: LD_INT 18
89581: NONEQUAL
89582: AND
89583: IFFALSE 89623
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
89585: LD_VAR 0 2
89589: PPUSH
89590: CALL_OW 257
89594: PUSH
89595: LD_INT 5
89597: PUSH
89598: LD_INT 8
89600: PUSH
89601: LD_INT 9
89603: PUSH
89604: EMPTY
89605: LIST
89606: LIST
89607: LIST
89608: IN
89609: IFFALSE 89623
// SetClass ( unit , 1 ) ;
89611: LD_VAR 0 2
89615: PPUSH
89616: LD_INT 1
89618: PPUSH
89619: CALL_OW 336
// end ;
89623: LD_VAR 0 3
89627: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
89628: LD_INT 0
89630: PPUSH
89631: PPUSH
// if not mc_bases or not skirmish then
89632: LD_EXP 61
89636: NOT
89637: PUSH
89638: LD_EXP 59
89642: NOT
89643: OR
89644: IFFALSE 89648
// exit ;
89646: GO 89764
// if GetLives ( abandoned_vehicle ) > 250 then
89648: LD_VAR 0 2
89652: PPUSH
89653: CALL_OW 256
89657: PUSH
89658: LD_INT 250
89660: GREATER
89661: IFFALSE 89665
// exit ;
89663: GO 89764
// for i = 1 to mc_bases do
89665: LD_ADDR_VAR 0 6
89669: PUSH
89670: DOUBLE
89671: LD_INT 1
89673: DEC
89674: ST_TO_ADDR
89675: LD_EXP 61
89679: PUSH
89680: FOR_TO
89681: IFFALSE 89762
// begin if driver in mc_bases [ i ] then
89683: LD_VAR 0 1
89687: PUSH
89688: LD_EXP 61
89692: PUSH
89693: LD_VAR 0 6
89697: ARRAY
89698: IN
89699: IFFALSE 89760
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
89701: LD_VAR 0 1
89705: PPUSH
89706: LD_EXP 61
89710: PUSH
89711: LD_VAR 0 6
89715: ARRAY
89716: PPUSH
89717: LD_INT 2
89719: PUSH
89720: LD_INT 30
89722: PUSH
89723: LD_INT 0
89725: PUSH
89726: EMPTY
89727: LIST
89728: LIST
89729: PUSH
89730: LD_INT 30
89732: PUSH
89733: LD_INT 1
89735: PUSH
89736: EMPTY
89737: LIST
89738: LIST
89739: PUSH
89740: EMPTY
89741: LIST
89742: LIST
89743: LIST
89744: PPUSH
89745: CALL_OW 72
89749: PUSH
89750: LD_INT 1
89752: ARRAY
89753: PPUSH
89754: CALL 55003 0 2
// break ;
89758: GO 89762
// end ; end ;
89760: GO 89680
89762: POP
89763: POP
// end ; end_of_file end_of_file
89764: LD_VAR 0 5
89768: RET
// export globalGameSaveCounter ; every 0 0$1 do
89769: GO 89771
89771: DISABLE
// begin enable ;
89772: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
89773: LD_STRING updateTimer(
89775: PUSH
89776: LD_OWVAR 1
89780: STR
89781: PUSH
89782: LD_STRING );
89784: STR
89785: PPUSH
89786: CALL_OW 559
// end ;
89790: END
// every 0 0$1 do
89791: GO 89793
89793: DISABLE
// begin globalGameSaveCounter := 0 ;
89794: LD_ADDR_EXP 106
89798: PUSH
89799: LD_INT 0
89801: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
89802: LD_STRING setGameSaveCounter(0)
89804: PPUSH
89805: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
89809: LD_STRING initStreamRollete();
89811: PPUSH
89812: CALL_OW 559
// InitStreamMode ;
89816: CALL 91142 0 0
// DefineStreamItems ( false ) ;
89820: LD_INT 0
89822: PPUSH
89823: CALL 91606 0 1
// end ;
89827: END
// export function SOS_MapStart ( ) ; begin
89828: LD_INT 0
89830: PPUSH
// if streamModeActive then
89831: LD_EXP 107
89835: IFFALSE 89844
// DefineStreamItems ( true ) ;
89837: LD_INT 1
89839: PPUSH
89840: CALL 91606 0 1
// UpdateLuaVariables ( ) ;
89844: CALL 89861 0 0
// UpdateFactoryWaypoints ( ) ;
89848: CALL 104475 0 0
// UpdateWarehouseGatheringPoints ( ) ;
89852: CALL 104732 0 0
// end ;
89856: LD_VAR 0 1
89860: RET
// function UpdateLuaVariables ( ) ; begin
89861: LD_INT 0
89863: PPUSH
// if globalGameSaveCounter then
89864: LD_EXP 106
89868: IFFALSE 89902
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
89870: LD_ADDR_EXP 106
89874: PUSH
89875: LD_EXP 106
89879: PPUSH
89880: CALL 55487 0 1
89884: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
89885: LD_STRING setGameSaveCounter(
89887: PUSH
89888: LD_EXP 106
89892: STR
89893: PUSH
89894: LD_STRING )
89896: STR
89897: PPUSH
89898: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
89902: LD_STRING setGameDifficulty(
89904: PUSH
89905: LD_OWVAR 67
89909: STR
89910: PUSH
89911: LD_STRING )
89913: STR
89914: PPUSH
89915: CALL_OW 559
// end ;
89919: LD_VAR 0 1
89923: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
89924: LD_INT 0
89926: PPUSH
// if p2 = stream_mode then
89927: LD_VAR 0 2
89931: PUSH
89932: LD_INT 100
89934: EQUAL
89935: IFFALSE 90938
// begin if not StreamModeActive then
89937: LD_EXP 107
89941: NOT
89942: IFFALSE 89952
// StreamModeActive := true ;
89944: LD_ADDR_EXP 107
89948: PUSH
89949: LD_INT 1
89951: ST_TO_ADDR
// if p3 = 0 then
89952: LD_VAR 0 3
89956: PUSH
89957: LD_INT 0
89959: EQUAL
89960: IFFALSE 89966
// InitStreamMode ;
89962: CALL 91142 0 0
// if p3 = 1 then
89966: LD_VAR 0 3
89970: PUSH
89971: LD_INT 1
89973: EQUAL
89974: IFFALSE 89984
// sRocket := true ;
89976: LD_ADDR_EXP 112
89980: PUSH
89981: LD_INT 1
89983: ST_TO_ADDR
// if p3 = 2 then
89984: LD_VAR 0 3
89988: PUSH
89989: LD_INT 2
89991: EQUAL
89992: IFFALSE 90002
// sSpeed := true ;
89994: LD_ADDR_EXP 111
89998: PUSH
89999: LD_INT 1
90001: ST_TO_ADDR
// if p3 = 3 then
90002: LD_VAR 0 3
90006: PUSH
90007: LD_INT 3
90009: EQUAL
90010: IFFALSE 90020
// sEngine := true ;
90012: LD_ADDR_EXP 113
90016: PUSH
90017: LD_INT 1
90019: ST_TO_ADDR
// if p3 = 4 then
90020: LD_VAR 0 3
90024: PUSH
90025: LD_INT 4
90027: EQUAL
90028: IFFALSE 90038
// sSpec := true ;
90030: LD_ADDR_EXP 110
90034: PUSH
90035: LD_INT 1
90037: ST_TO_ADDR
// if p3 = 5 then
90038: LD_VAR 0 3
90042: PUSH
90043: LD_INT 5
90045: EQUAL
90046: IFFALSE 90056
// sLevel := true ;
90048: LD_ADDR_EXP 114
90052: PUSH
90053: LD_INT 1
90055: ST_TO_ADDR
// if p3 = 6 then
90056: LD_VAR 0 3
90060: PUSH
90061: LD_INT 6
90063: EQUAL
90064: IFFALSE 90074
// sArmoury := true ;
90066: LD_ADDR_EXP 115
90070: PUSH
90071: LD_INT 1
90073: ST_TO_ADDR
// if p3 = 7 then
90074: LD_VAR 0 3
90078: PUSH
90079: LD_INT 7
90081: EQUAL
90082: IFFALSE 90092
// sRadar := true ;
90084: LD_ADDR_EXP 116
90088: PUSH
90089: LD_INT 1
90091: ST_TO_ADDR
// if p3 = 8 then
90092: LD_VAR 0 3
90096: PUSH
90097: LD_INT 8
90099: EQUAL
90100: IFFALSE 90110
// sBunker := true ;
90102: LD_ADDR_EXP 117
90106: PUSH
90107: LD_INT 1
90109: ST_TO_ADDR
// if p3 = 9 then
90110: LD_VAR 0 3
90114: PUSH
90115: LD_INT 9
90117: EQUAL
90118: IFFALSE 90128
// sHack := true ;
90120: LD_ADDR_EXP 118
90124: PUSH
90125: LD_INT 1
90127: ST_TO_ADDR
// if p3 = 10 then
90128: LD_VAR 0 3
90132: PUSH
90133: LD_INT 10
90135: EQUAL
90136: IFFALSE 90146
// sFire := true ;
90138: LD_ADDR_EXP 119
90142: PUSH
90143: LD_INT 1
90145: ST_TO_ADDR
// if p3 = 11 then
90146: LD_VAR 0 3
90150: PUSH
90151: LD_INT 11
90153: EQUAL
90154: IFFALSE 90164
// sRefresh := true ;
90156: LD_ADDR_EXP 120
90160: PUSH
90161: LD_INT 1
90163: ST_TO_ADDR
// if p3 = 12 then
90164: LD_VAR 0 3
90168: PUSH
90169: LD_INT 12
90171: EQUAL
90172: IFFALSE 90182
// sExp := true ;
90174: LD_ADDR_EXP 121
90178: PUSH
90179: LD_INT 1
90181: ST_TO_ADDR
// if p3 = 13 then
90182: LD_VAR 0 3
90186: PUSH
90187: LD_INT 13
90189: EQUAL
90190: IFFALSE 90200
// sDepot := true ;
90192: LD_ADDR_EXP 122
90196: PUSH
90197: LD_INT 1
90199: ST_TO_ADDR
// if p3 = 14 then
90200: LD_VAR 0 3
90204: PUSH
90205: LD_INT 14
90207: EQUAL
90208: IFFALSE 90218
// sFlag := true ;
90210: LD_ADDR_EXP 123
90214: PUSH
90215: LD_INT 1
90217: ST_TO_ADDR
// if p3 = 15 then
90218: LD_VAR 0 3
90222: PUSH
90223: LD_INT 15
90225: EQUAL
90226: IFFALSE 90236
// sKamikadze := true ;
90228: LD_ADDR_EXP 131
90232: PUSH
90233: LD_INT 1
90235: ST_TO_ADDR
// if p3 = 16 then
90236: LD_VAR 0 3
90240: PUSH
90241: LD_INT 16
90243: EQUAL
90244: IFFALSE 90254
// sTroll := true ;
90246: LD_ADDR_EXP 132
90250: PUSH
90251: LD_INT 1
90253: ST_TO_ADDR
// if p3 = 17 then
90254: LD_VAR 0 3
90258: PUSH
90259: LD_INT 17
90261: EQUAL
90262: IFFALSE 90272
// sSlow := true ;
90264: LD_ADDR_EXP 133
90268: PUSH
90269: LD_INT 1
90271: ST_TO_ADDR
// if p3 = 18 then
90272: LD_VAR 0 3
90276: PUSH
90277: LD_INT 18
90279: EQUAL
90280: IFFALSE 90290
// sLack := true ;
90282: LD_ADDR_EXP 134
90286: PUSH
90287: LD_INT 1
90289: ST_TO_ADDR
// if p3 = 19 then
90290: LD_VAR 0 3
90294: PUSH
90295: LD_INT 19
90297: EQUAL
90298: IFFALSE 90308
// sTank := true ;
90300: LD_ADDR_EXP 136
90304: PUSH
90305: LD_INT 1
90307: ST_TO_ADDR
// if p3 = 20 then
90308: LD_VAR 0 3
90312: PUSH
90313: LD_INT 20
90315: EQUAL
90316: IFFALSE 90326
// sRemote := true ;
90318: LD_ADDR_EXP 137
90322: PUSH
90323: LD_INT 1
90325: ST_TO_ADDR
// if p3 = 21 then
90326: LD_VAR 0 3
90330: PUSH
90331: LD_INT 21
90333: EQUAL
90334: IFFALSE 90344
// sPowell := true ;
90336: LD_ADDR_EXP 138
90340: PUSH
90341: LD_INT 1
90343: ST_TO_ADDR
// if p3 = 22 then
90344: LD_VAR 0 3
90348: PUSH
90349: LD_INT 22
90351: EQUAL
90352: IFFALSE 90362
// sTeleport := true ;
90354: LD_ADDR_EXP 141
90358: PUSH
90359: LD_INT 1
90361: ST_TO_ADDR
// if p3 = 23 then
90362: LD_VAR 0 3
90366: PUSH
90367: LD_INT 23
90369: EQUAL
90370: IFFALSE 90380
// sOilTower := true ;
90372: LD_ADDR_EXP 143
90376: PUSH
90377: LD_INT 1
90379: ST_TO_ADDR
// if p3 = 24 then
90380: LD_VAR 0 3
90384: PUSH
90385: LD_INT 24
90387: EQUAL
90388: IFFALSE 90398
// sShovel := true ;
90390: LD_ADDR_EXP 144
90394: PUSH
90395: LD_INT 1
90397: ST_TO_ADDR
// if p3 = 25 then
90398: LD_VAR 0 3
90402: PUSH
90403: LD_INT 25
90405: EQUAL
90406: IFFALSE 90416
// sSheik := true ;
90408: LD_ADDR_EXP 145
90412: PUSH
90413: LD_INT 1
90415: ST_TO_ADDR
// if p3 = 26 then
90416: LD_VAR 0 3
90420: PUSH
90421: LD_INT 26
90423: EQUAL
90424: IFFALSE 90434
// sEarthquake := true ;
90426: LD_ADDR_EXP 147
90430: PUSH
90431: LD_INT 1
90433: ST_TO_ADDR
// if p3 = 27 then
90434: LD_VAR 0 3
90438: PUSH
90439: LD_INT 27
90441: EQUAL
90442: IFFALSE 90452
// sAI := true ;
90444: LD_ADDR_EXP 148
90448: PUSH
90449: LD_INT 1
90451: ST_TO_ADDR
// if p3 = 28 then
90452: LD_VAR 0 3
90456: PUSH
90457: LD_INT 28
90459: EQUAL
90460: IFFALSE 90470
// sCargo := true ;
90462: LD_ADDR_EXP 151
90466: PUSH
90467: LD_INT 1
90469: ST_TO_ADDR
// if p3 = 29 then
90470: LD_VAR 0 3
90474: PUSH
90475: LD_INT 29
90477: EQUAL
90478: IFFALSE 90488
// sDLaser := true ;
90480: LD_ADDR_EXP 152
90484: PUSH
90485: LD_INT 1
90487: ST_TO_ADDR
// if p3 = 30 then
90488: LD_VAR 0 3
90492: PUSH
90493: LD_INT 30
90495: EQUAL
90496: IFFALSE 90506
// sExchange := true ;
90498: LD_ADDR_EXP 153
90502: PUSH
90503: LD_INT 1
90505: ST_TO_ADDR
// if p3 = 31 then
90506: LD_VAR 0 3
90510: PUSH
90511: LD_INT 31
90513: EQUAL
90514: IFFALSE 90524
// sFac := true ;
90516: LD_ADDR_EXP 154
90520: PUSH
90521: LD_INT 1
90523: ST_TO_ADDR
// if p3 = 32 then
90524: LD_VAR 0 3
90528: PUSH
90529: LD_INT 32
90531: EQUAL
90532: IFFALSE 90542
// sPower := true ;
90534: LD_ADDR_EXP 155
90538: PUSH
90539: LD_INT 1
90541: ST_TO_ADDR
// if p3 = 33 then
90542: LD_VAR 0 3
90546: PUSH
90547: LD_INT 33
90549: EQUAL
90550: IFFALSE 90560
// sRandom := true ;
90552: LD_ADDR_EXP 156
90556: PUSH
90557: LD_INT 1
90559: ST_TO_ADDR
// if p3 = 34 then
90560: LD_VAR 0 3
90564: PUSH
90565: LD_INT 34
90567: EQUAL
90568: IFFALSE 90578
// sShield := true ;
90570: LD_ADDR_EXP 157
90574: PUSH
90575: LD_INT 1
90577: ST_TO_ADDR
// if p3 = 35 then
90578: LD_VAR 0 3
90582: PUSH
90583: LD_INT 35
90585: EQUAL
90586: IFFALSE 90596
// sTime := true ;
90588: LD_ADDR_EXP 158
90592: PUSH
90593: LD_INT 1
90595: ST_TO_ADDR
// if p3 = 36 then
90596: LD_VAR 0 3
90600: PUSH
90601: LD_INT 36
90603: EQUAL
90604: IFFALSE 90614
// sTools := true ;
90606: LD_ADDR_EXP 159
90610: PUSH
90611: LD_INT 1
90613: ST_TO_ADDR
// if p3 = 101 then
90614: LD_VAR 0 3
90618: PUSH
90619: LD_INT 101
90621: EQUAL
90622: IFFALSE 90632
// sSold := true ;
90624: LD_ADDR_EXP 124
90628: PUSH
90629: LD_INT 1
90631: ST_TO_ADDR
// if p3 = 102 then
90632: LD_VAR 0 3
90636: PUSH
90637: LD_INT 102
90639: EQUAL
90640: IFFALSE 90650
// sDiff := true ;
90642: LD_ADDR_EXP 125
90646: PUSH
90647: LD_INT 1
90649: ST_TO_ADDR
// if p3 = 103 then
90650: LD_VAR 0 3
90654: PUSH
90655: LD_INT 103
90657: EQUAL
90658: IFFALSE 90668
// sFog := true ;
90660: LD_ADDR_EXP 128
90664: PUSH
90665: LD_INT 1
90667: ST_TO_ADDR
// if p3 = 104 then
90668: LD_VAR 0 3
90672: PUSH
90673: LD_INT 104
90675: EQUAL
90676: IFFALSE 90686
// sReset := true ;
90678: LD_ADDR_EXP 129
90682: PUSH
90683: LD_INT 1
90685: ST_TO_ADDR
// if p3 = 105 then
90686: LD_VAR 0 3
90690: PUSH
90691: LD_INT 105
90693: EQUAL
90694: IFFALSE 90704
// sSun := true ;
90696: LD_ADDR_EXP 130
90700: PUSH
90701: LD_INT 1
90703: ST_TO_ADDR
// if p3 = 106 then
90704: LD_VAR 0 3
90708: PUSH
90709: LD_INT 106
90711: EQUAL
90712: IFFALSE 90722
// sTiger := true ;
90714: LD_ADDR_EXP 126
90718: PUSH
90719: LD_INT 1
90721: ST_TO_ADDR
// if p3 = 107 then
90722: LD_VAR 0 3
90726: PUSH
90727: LD_INT 107
90729: EQUAL
90730: IFFALSE 90740
// sBomb := true ;
90732: LD_ADDR_EXP 127
90736: PUSH
90737: LD_INT 1
90739: ST_TO_ADDR
// if p3 = 108 then
90740: LD_VAR 0 3
90744: PUSH
90745: LD_INT 108
90747: EQUAL
90748: IFFALSE 90758
// sWound := true ;
90750: LD_ADDR_EXP 135
90754: PUSH
90755: LD_INT 1
90757: ST_TO_ADDR
// if p3 = 109 then
90758: LD_VAR 0 3
90762: PUSH
90763: LD_INT 109
90765: EQUAL
90766: IFFALSE 90776
// sBetray := true ;
90768: LD_ADDR_EXP 139
90772: PUSH
90773: LD_INT 1
90775: ST_TO_ADDR
// if p3 = 110 then
90776: LD_VAR 0 3
90780: PUSH
90781: LD_INT 110
90783: EQUAL
90784: IFFALSE 90794
// sContamin := true ;
90786: LD_ADDR_EXP 140
90790: PUSH
90791: LD_INT 1
90793: ST_TO_ADDR
// if p3 = 111 then
90794: LD_VAR 0 3
90798: PUSH
90799: LD_INT 111
90801: EQUAL
90802: IFFALSE 90812
// sOil := true ;
90804: LD_ADDR_EXP 142
90808: PUSH
90809: LD_INT 1
90811: ST_TO_ADDR
// if p3 = 112 then
90812: LD_VAR 0 3
90816: PUSH
90817: LD_INT 112
90819: EQUAL
90820: IFFALSE 90830
// sStu := true ;
90822: LD_ADDR_EXP 146
90826: PUSH
90827: LD_INT 1
90829: ST_TO_ADDR
// if p3 = 113 then
90830: LD_VAR 0 3
90834: PUSH
90835: LD_INT 113
90837: EQUAL
90838: IFFALSE 90848
// sBazooka := true ;
90840: LD_ADDR_EXP 149
90844: PUSH
90845: LD_INT 1
90847: ST_TO_ADDR
// if p3 = 114 then
90848: LD_VAR 0 3
90852: PUSH
90853: LD_INT 114
90855: EQUAL
90856: IFFALSE 90866
// sMortar := true ;
90858: LD_ADDR_EXP 150
90862: PUSH
90863: LD_INT 1
90865: ST_TO_ADDR
// if p3 = 115 then
90866: LD_VAR 0 3
90870: PUSH
90871: LD_INT 115
90873: EQUAL
90874: IFFALSE 90884
// sRanger := true ;
90876: LD_ADDR_EXP 160
90880: PUSH
90881: LD_INT 1
90883: ST_TO_ADDR
// if p3 = 116 then
90884: LD_VAR 0 3
90888: PUSH
90889: LD_INT 116
90891: EQUAL
90892: IFFALSE 90902
// sComputer := true ;
90894: LD_ADDR_EXP 161
90898: PUSH
90899: LD_INT 1
90901: ST_TO_ADDR
// if p3 = 117 then
90902: LD_VAR 0 3
90906: PUSH
90907: LD_INT 117
90909: EQUAL
90910: IFFALSE 90920
// s30 := true ;
90912: LD_ADDR_EXP 162
90916: PUSH
90917: LD_INT 1
90919: ST_TO_ADDR
// if p3 = 118 then
90920: LD_VAR 0 3
90924: PUSH
90925: LD_INT 118
90927: EQUAL
90928: IFFALSE 90938
// s60 := true ;
90930: LD_ADDR_EXP 163
90934: PUSH
90935: LD_INT 1
90937: ST_TO_ADDR
// end ; if p2 = hack_mode then
90938: LD_VAR 0 2
90942: PUSH
90943: LD_INT 101
90945: EQUAL
90946: IFFALSE 91074
// begin case p3 of 1 :
90948: LD_VAR 0 3
90952: PUSH
90953: LD_INT 1
90955: DOUBLE
90956: EQUAL
90957: IFTRUE 90961
90959: GO 90968
90961: POP
// hHackUnlimitedResources ; 2 :
90962: CALL 103221 0 0
90966: GO 91074
90968: LD_INT 2
90970: DOUBLE
90971: EQUAL
90972: IFTRUE 90976
90974: GO 90983
90976: POP
// hHackSetLevel10 ; 3 :
90977: CALL 103354 0 0
90981: GO 91074
90983: LD_INT 3
90985: DOUBLE
90986: EQUAL
90987: IFTRUE 90991
90989: GO 90998
90991: POP
// hHackSetLevel10YourUnits ; 4 :
90992: CALL 103439 0 0
90996: GO 91074
90998: LD_INT 4
91000: DOUBLE
91001: EQUAL
91002: IFTRUE 91006
91004: GO 91013
91006: POP
// hHackInvincible ; 5 :
91007: CALL 103887 0 0
91011: GO 91074
91013: LD_INT 5
91015: DOUBLE
91016: EQUAL
91017: IFTRUE 91021
91019: GO 91028
91021: POP
// hHackInvisible ; 6 :
91022: CALL 103998 0 0
91026: GO 91074
91028: LD_INT 6
91030: DOUBLE
91031: EQUAL
91032: IFTRUE 91036
91034: GO 91043
91036: POP
// hHackChangeYourSide ; 7 :
91037: CALL 104055 0 0
91041: GO 91074
91043: LD_INT 7
91045: DOUBLE
91046: EQUAL
91047: IFTRUE 91051
91049: GO 91058
91051: POP
// hHackChangeUnitSide ; 8 :
91052: CALL 104097 0 0
91056: GO 91074
91058: LD_INT 8
91060: DOUBLE
91061: EQUAL
91062: IFTRUE 91066
91064: GO 91073
91066: POP
// hHackFog ; end ;
91067: CALL 104198 0 0
91071: GO 91074
91073: POP
// end ; if p2 = game_save_mode then
91074: LD_VAR 0 2
91078: PUSH
91079: LD_INT 102
91081: EQUAL
91082: IFFALSE 91137
// begin if p3 = 1 then
91084: LD_VAR 0 3
91088: PUSH
91089: LD_INT 1
91091: EQUAL
91092: IFFALSE 91104
// globalGameSaveCounter := p4 ;
91094: LD_ADDR_EXP 106
91098: PUSH
91099: LD_VAR 0 4
91103: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
91104: LD_VAR 0 3
91108: PUSH
91109: LD_INT 2
91111: EQUAL
91112: PUSH
91113: LD_EXP 106
91117: AND
91118: IFFALSE 91137
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
91120: LD_STRING setGameSaveCounter(
91122: PUSH
91123: LD_EXP 106
91127: STR
91128: PUSH
91129: LD_STRING )
91131: STR
91132: PPUSH
91133: CALL_OW 559
// end ; end ;
91137: LD_VAR 0 7
91141: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
91142: LD_INT 0
91144: PPUSH
// streamModeActive := false ;
91145: LD_ADDR_EXP 107
91149: PUSH
91150: LD_INT 0
91152: ST_TO_ADDR
// normalCounter := 36 ;
91153: LD_ADDR_EXP 108
91157: PUSH
91158: LD_INT 36
91160: ST_TO_ADDR
// hardcoreCounter := 18 ;
91161: LD_ADDR_EXP 109
91165: PUSH
91166: LD_INT 18
91168: ST_TO_ADDR
// sRocket := false ;
91169: LD_ADDR_EXP 112
91173: PUSH
91174: LD_INT 0
91176: ST_TO_ADDR
// sSpeed := false ;
91177: LD_ADDR_EXP 111
91181: PUSH
91182: LD_INT 0
91184: ST_TO_ADDR
// sEngine := false ;
91185: LD_ADDR_EXP 113
91189: PUSH
91190: LD_INT 0
91192: ST_TO_ADDR
// sSpec := false ;
91193: LD_ADDR_EXP 110
91197: PUSH
91198: LD_INT 0
91200: ST_TO_ADDR
// sLevel := false ;
91201: LD_ADDR_EXP 114
91205: PUSH
91206: LD_INT 0
91208: ST_TO_ADDR
// sArmoury := false ;
91209: LD_ADDR_EXP 115
91213: PUSH
91214: LD_INT 0
91216: ST_TO_ADDR
// sRadar := false ;
91217: LD_ADDR_EXP 116
91221: PUSH
91222: LD_INT 0
91224: ST_TO_ADDR
// sBunker := false ;
91225: LD_ADDR_EXP 117
91229: PUSH
91230: LD_INT 0
91232: ST_TO_ADDR
// sHack := false ;
91233: LD_ADDR_EXP 118
91237: PUSH
91238: LD_INT 0
91240: ST_TO_ADDR
// sFire := false ;
91241: LD_ADDR_EXP 119
91245: PUSH
91246: LD_INT 0
91248: ST_TO_ADDR
// sRefresh := false ;
91249: LD_ADDR_EXP 120
91253: PUSH
91254: LD_INT 0
91256: ST_TO_ADDR
// sExp := false ;
91257: LD_ADDR_EXP 121
91261: PUSH
91262: LD_INT 0
91264: ST_TO_ADDR
// sDepot := false ;
91265: LD_ADDR_EXP 122
91269: PUSH
91270: LD_INT 0
91272: ST_TO_ADDR
// sFlag := false ;
91273: LD_ADDR_EXP 123
91277: PUSH
91278: LD_INT 0
91280: ST_TO_ADDR
// sKamikadze := false ;
91281: LD_ADDR_EXP 131
91285: PUSH
91286: LD_INT 0
91288: ST_TO_ADDR
// sTroll := false ;
91289: LD_ADDR_EXP 132
91293: PUSH
91294: LD_INT 0
91296: ST_TO_ADDR
// sSlow := false ;
91297: LD_ADDR_EXP 133
91301: PUSH
91302: LD_INT 0
91304: ST_TO_ADDR
// sLack := false ;
91305: LD_ADDR_EXP 134
91309: PUSH
91310: LD_INT 0
91312: ST_TO_ADDR
// sTank := false ;
91313: LD_ADDR_EXP 136
91317: PUSH
91318: LD_INT 0
91320: ST_TO_ADDR
// sRemote := false ;
91321: LD_ADDR_EXP 137
91325: PUSH
91326: LD_INT 0
91328: ST_TO_ADDR
// sPowell := false ;
91329: LD_ADDR_EXP 138
91333: PUSH
91334: LD_INT 0
91336: ST_TO_ADDR
// sTeleport := false ;
91337: LD_ADDR_EXP 141
91341: PUSH
91342: LD_INT 0
91344: ST_TO_ADDR
// sOilTower := false ;
91345: LD_ADDR_EXP 143
91349: PUSH
91350: LD_INT 0
91352: ST_TO_ADDR
// sShovel := false ;
91353: LD_ADDR_EXP 144
91357: PUSH
91358: LD_INT 0
91360: ST_TO_ADDR
// sSheik := false ;
91361: LD_ADDR_EXP 145
91365: PUSH
91366: LD_INT 0
91368: ST_TO_ADDR
// sEarthquake := false ;
91369: LD_ADDR_EXP 147
91373: PUSH
91374: LD_INT 0
91376: ST_TO_ADDR
// sAI := false ;
91377: LD_ADDR_EXP 148
91381: PUSH
91382: LD_INT 0
91384: ST_TO_ADDR
// sCargo := false ;
91385: LD_ADDR_EXP 151
91389: PUSH
91390: LD_INT 0
91392: ST_TO_ADDR
// sDLaser := false ;
91393: LD_ADDR_EXP 152
91397: PUSH
91398: LD_INT 0
91400: ST_TO_ADDR
// sExchange := false ;
91401: LD_ADDR_EXP 153
91405: PUSH
91406: LD_INT 0
91408: ST_TO_ADDR
// sFac := false ;
91409: LD_ADDR_EXP 154
91413: PUSH
91414: LD_INT 0
91416: ST_TO_ADDR
// sPower := false ;
91417: LD_ADDR_EXP 155
91421: PUSH
91422: LD_INT 0
91424: ST_TO_ADDR
// sRandom := false ;
91425: LD_ADDR_EXP 156
91429: PUSH
91430: LD_INT 0
91432: ST_TO_ADDR
// sShield := false ;
91433: LD_ADDR_EXP 157
91437: PUSH
91438: LD_INT 0
91440: ST_TO_ADDR
// sTime := false ;
91441: LD_ADDR_EXP 158
91445: PUSH
91446: LD_INT 0
91448: ST_TO_ADDR
// sTools := false ;
91449: LD_ADDR_EXP 159
91453: PUSH
91454: LD_INT 0
91456: ST_TO_ADDR
// sSold := false ;
91457: LD_ADDR_EXP 124
91461: PUSH
91462: LD_INT 0
91464: ST_TO_ADDR
// sDiff := false ;
91465: LD_ADDR_EXP 125
91469: PUSH
91470: LD_INT 0
91472: ST_TO_ADDR
// sFog := false ;
91473: LD_ADDR_EXP 128
91477: PUSH
91478: LD_INT 0
91480: ST_TO_ADDR
// sReset := false ;
91481: LD_ADDR_EXP 129
91485: PUSH
91486: LD_INT 0
91488: ST_TO_ADDR
// sSun := false ;
91489: LD_ADDR_EXP 130
91493: PUSH
91494: LD_INT 0
91496: ST_TO_ADDR
// sTiger := false ;
91497: LD_ADDR_EXP 126
91501: PUSH
91502: LD_INT 0
91504: ST_TO_ADDR
// sBomb := false ;
91505: LD_ADDR_EXP 127
91509: PUSH
91510: LD_INT 0
91512: ST_TO_ADDR
// sWound := false ;
91513: LD_ADDR_EXP 135
91517: PUSH
91518: LD_INT 0
91520: ST_TO_ADDR
// sBetray := false ;
91521: LD_ADDR_EXP 139
91525: PUSH
91526: LD_INT 0
91528: ST_TO_ADDR
// sContamin := false ;
91529: LD_ADDR_EXP 140
91533: PUSH
91534: LD_INT 0
91536: ST_TO_ADDR
// sOil := false ;
91537: LD_ADDR_EXP 142
91541: PUSH
91542: LD_INT 0
91544: ST_TO_ADDR
// sStu := false ;
91545: LD_ADDR_EXP 146
91549: PUSH
91550: LD_INT 0
91552: ST_TO_ADDR
// sBazooka := false ;
91553: LD_ADDR_EXP 149
91557: PUSH
91558: LD_INT 0
91560: ST_TO_ADDR
// sMortar := false ;
91561: LD_ADDR_EXP 150
91565: PUSH
91566: LD_INT 0
91568: ST_TO_ADDR
// sRanger := false ;
91569: LD_ADDR_EXP 160
91573: PUSH
91574: LD_INT 0
91576: ST_TO_ADDR
// sComputer := false ;
91577: LD_ADDR_EXP 161
91581: PUSH
91582: LD_INT 0
91584: ST_TO_ADDR
// s30 := false ;
91585: LD_ADDR_EXP 162
91589: PUSH
91590: LD_INT 0
91592: ST_TO_ADDR
// s60 := false ;
91593: LD_ADDR_EXP 163
91597: PUSH
91598: LD_INT 0
91600: ST_TO_ADDR
// end ;
91601: LD_VAR 0 1
91605: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
91606: LD_INT 0
91608: PPUSH
91609: PPUSH
91610: PPUSH
91611: PPUSH
91612: PPUSH
91613: PPUSH
91614: PPUSH
// result := [ ] ;
91615: LD_ADDR_VAR 0 2
91619: PUSH
91620: EMPTY
91621: ST_TO_ADDR
// if campaign_id = 1 then
91622: LD_OWVAR 69
91626: PUSH
91627: LD_INT 1
91629: EQUAL
91630: IFFALSE 94796
// begin case mission_number of 1 :
91632: LD_OWVAR 70
91636: PUSH
91637: LD_INT 1
91639: DOUBLE
91640: EQUAL
91641: IFTRUE 91645
91643: GO 91721
91645: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
91646: LD_ADDR_VAR 0 2
91650: PUSH
91651: LD_INT 2
91653: PUSH
91654: LD_INT 4
91656: PUSH
91657: LD_INT 11
91659: PUSH
91660: LD_INT 12
91662: PUSH
91663: LD_INT 15
91665: PUSH
91666: LD_INT 16
91668: PUSH
91669: LD_INT 22
91671: PUSH
91672: LD_INT 23
91674: PUSH
91675: LD_INT 26
91677: PUSH
91678: EMPTY
91679: LIST
91680: LIST
91681: LIST
91682: LIST
91683: LIST
91684: LIST
91685: LIST
91686: LIST
91687: LIST
91688: PUSH
91689: LD_INT 101
91691: PUSH
91692: LD_INT 102
91694: PUSH
91695: LD_INT 106
91697: PUSH
91698: LD_INT 116
91700: PUSH
91701: LD_INT 117
91703: PUSH
91704: LD_INT 118
91706: PUSH
91707: EMPTY
91708: LIST
91709: LIST
91710: LIST
91711: LIST
91712: LIST
91713: LIST
91714: PUSH
91715: EMPTY
91716: LIST
91717: LIST
91718: ST_TO_ADDR
91719: GO 94794
91721: LD_INT 2
91723: DOUBLE
91724: EQUAL
91725: IFTRUE 91729
91727: GO 91813
91729: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
91730: LD_ADDR_VAR 0 2
91734: PUSH
91735: LD_INT 2
91737: PUSH
91738: LD_INT 4
91740: PUSH
91741: LD_INT 11
91743: PUSH
91744: LD_INT 12
91746: PUSH
91747: LD_INT 15
91749: PUSH
91750: LD_INT 16
91752: PUSH
91753: LD_INT 22
91755: PUSH
91756: LD_INT 23
91758: PUSH
91759: LD_INT 26
91761: PUSH
91762: EMPTY
91763: LIST
91764: LIST
91765: LIST
91766: LIST
91767: LIST
91768: LIST
91769: LIST
91770: LIST
91771: LIST
91772: PUSH
91773: LD_INT 101
91775: PUSH
91776: LD_INT 102
91778: PUSH
91779: LD_INT 105
91781: PUSH
91782: LD_INT 106
91784: PUSH
91785: LD_INT 108
91787: PUSH
91788: LD_INT 116
91790: PUSH
91791: LD_INT 117
91793: PUSH
91794: LD_INT 118
91796: PUSH
91797: EMPTY
91798: LIST
91799: LIST
91800: LIST
91801: LIST
91802: LIST
91803: LIST
91804: LIST
91805: LIST
91806: PUSH
91807: EMPTY
91808: LIST
91809: LIST
91810: ST_TO_ADDR
91811: GO 94794
91813: LD_INT 3
91815: DOUBLE
91816: EQUAL
91817: IFTRUE 91821
91819: GO 91909
91821: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
91822: LD_ADDR_VAR 0 2
91826: PUSH
91827: LD_INT 2
91829: PUSH
91830: LD_INT 4
91832: PUSH
91833: LD_INT 5
91835: PUSH
91836: LD_INT 11
91838: PUSH
91839: LD_INT 12
91841: PUSH
91842: LD_INT 15
91844: PUSH
91845: LD_INT 16
91847: PUSH
91848: LD_INT 22
91850: PUSH
91851: LD_INT 26
91853: PUSH
91854: LD_INT 36
91856: PUSH
91857: EMPTY
91858: LIST
91859: LIST
91860: LIST
91861: LIST
91862: LIST
91863: LIST
91864: LIST
91865: LIST
91866: LIST
91867: LIST
91868: PUSH
91869: LD_INT 101
91871: PUSH
91872: LD_INT 102
91874: PUSH
91875: LD_INT 105
91877: PUSH
91878: LD_INT 106
91880: PUSH
91881: LD_INT 108
91883: PUSH
91884: LD_INT 116
91886: PUSH
91887: LD_INT 117
91889: PUSH
91890: LD_INT 118
91892: PUSH
91893: EMPTY
91894: LIST
91895: LIST
91896: LIST
91897: LIST
91898: LIST
91899: LIST
91900: LIST
91901: LIST
91902: PUSH
91903: EMPTY
91904: LIST
91905: LIST
91906: ST_TO_ADDR
91907: GO 94794
91909: LD_INT 4
91911: DOUBLE
91912: EQUAL
91913: IFTRUE 91917
91915: GO 92013
91917: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
91918: LD_ADDR_VAR 0 2
91922: PUSH
91923: LD_INT 2
91925: PUSH
91926: LD_INT 4
91928: PUSH
91929: LD_INT 5
91931: PUSH
91932: LD_INT 8
91934: PUSH
91935: LD_INT 11
91937: PUSH
91938: LD_INT 12
91940: PUSH
91941: LD_INT 15
91943: PUSH
91944: LD_INT 16
91946: PUSH
91947: LD_INT 22
91949: PUSH
91950: LD_INT 23
91952: PUSH
91953: LD_INT 26
91955: PUSH
91956: LD_INT 36
91958: PUSH
91959: EMPTY
91960: LIST
91961: LIST
91962: LIST
91963: LIST
91964: LIST
91965: LIST
91966: LIST
91967: LIST
91968: LIST
91969: LIST
91970: LIST
91971: LIST
91972: PUSH
91973: LD_INT 101
91975: PUSH
91976: LD_INT 102
91978: PUSH
91979: LD_INT 105
91981: PUSH
91982: LD_INT 106
91984: PUSH
91985: LD_INT 108
91987: PUSH
91988: LD_INT 116
91990: PUSH
91991: LD_INT 117
91993: PUSH
91994: LD_INT 118
91996: PUSH
91997: EMPTY
91998: LIST
91999: LIST
92000: LIST
92001: LIST
92002: LIST
92003: LIST
92004: LIST
92005: LIST
92006: PUSH
92007: EMPTY
92008: LIST
92009: LIST
92010: ST_TO_ADDR
92011: GO 94794
92013: LD_INT 5
92015: DOUBLE
92016: EQUAL
92017: IFTRUE 92021
92019: GO 92133
92021: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
92022: LD_ADDR_VAR 0 2
92026: PUSH
92027: LD_INT 2
92029: PUSH
92030: LD_INT 4
92032: PUSH
92033: LD_INT 5
92035: PUSH
92036: LD_INT 6
92038: PUSH
92039: LD_INT 8
92041: PUSH
92042: LD_INT 11
92044: PUSH
92045: LD_INT 12
92047: PUSH
92048: LD_INT 15
92050: PUSH
92051: LD_INT 16
92053: PUSH
92054: LD_INT 22
92056: PUSH
92057: LD_INT 23
92059: PUSH
92060: LD_INT 25
92062: PUSH
92063: LD_INT 26
92065: PUSH
92066: LD_INT 36
92068: PUSH
92069: EMPTY
92070: LIST
92071: LIST
92072: LIST
92073: LIST
92074: LIST
92075: LIST
92076: LIST
92077: LIST
92078: LIST
92079: LIST
92080: LIST
92081: LIST
92082: LIST
92083: LIST
92084: PUSH
92085: LD_INT 101
92087: PUSH
92088: LD_INT 102
92090: PUSH
92091: LD_INT 105
92093: PUSH
92094: LD_INT 106
92096: PUSH
92097: LD_INT 108
92099: PUSH
92100: LD_INT 109
92102: PUSH
92103: LD_INT 112
92105: PUSH
92106: LD_INT 116
92108: PUSH
92109: LD_INT 117
92111: PUSH
92112: LD_INT 118
92114: PUSH
92115: EMPTY
92116: LIST
92117: LIST
92118: LIST
92119: LIST
92120: LIST
92121: LIST
92122: LIST
92123: LIST
92124: LIST
92125: LIST
92126: PUSH
92127: EMPTY
92128: LIST
92129: LIST
92130: ST_TO_ADDR
92131: GO 94794
92133: LD_INT 6
92135: DOUBLE
92136: EQUAL
92137: IFTRUE 92141
92139: GO 92273
92141: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
92142: LD_ADDR_VAR 0 2
92146: PUSH
92147: LD_INT 2
92149: PUSH
92150: LD_INT 4
92152: PUSH
92153: LD_INT 5
92155: PUSH
92156: LD_INT 6
92158: PUSH
92159: LD_INT 8
92161: PUSH
92162: LD_INT 11
92164: PUSH
92165: LD_INT 12
92167: PUSH
92168: LD_INT 15
92170: PUSH
92171: LD_INT 16
92173: PUSH
92174: LD_INT 20
92176: PUSH
92177: LD_INT 21
92179: PUSH
92180: LD_INT 22
92182: PUSH
92183: LD_INT 23
92185: PUSH
92186: LD_INT 25
92188: PUSH
92189: LD_INT 26
92191: PUSH
92192: LD_INT 30
92194: PUSH
92195: LD_INT 31
92197: PUSH
92198: LD_INT 32
92200: PUSH
92201: LD_INT 36
92203: PUSH
92204: EMPTY
92205: LIST
92206: LIST
92207: LIST
92208: LIST
92209: LIST
92210: LIST
92211: LIST
92212: LIST
92213: LIST
92214: LIST
92215: LIST
92216: LIST
92217: LIST
92218: LIST
92219: LIST
92220: LIST
92221: LIST
92222: LIST
92223: LIST
92224: PUSH
92225: LD_INT 101
92227: PUSH
92228: LD_INT 102
92230: PUSH
92231: LD_INT 105
92233: PUSH
92234: LD_INT 106
92236: PUSH
92237: LD_INT 108
92239: PUSH
92240: LD_INT 109
92242: PUSH
92243: LD_INT 112
92245: PUSH
92246: LD_INT 116
92248: PUSH
92249: LD_INT 117
92251: PUSH
92252: LD_INT 118
92254: PUSH
92255: EMPTY
92256: LIST
92257: LIST
92258: LIST
92259: LIST
92260: LIST
92261: LIST
92262: LIST
92263: LIST
92264: LIST
92265: LIST
92266: PUSH
92267: EMPTY
92268: LIST
92269: LIST
92270: ST_TO_ADDR
92271: GO 94794
92273: LD_INT 7
92275: DOUBLE
92276: EQUAL
92277: IFTRUE 92281
92279: GO 92393
92281: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
92282: LD_ADDR_VAR 0 2
92286: PUSH
92287: LD_INT 2
92289: PUSH
92290: LD_INT 4
92292: PUSH
92293: LD_INT 5
92295: PUSH
92296: LD_INT 7
92298: PUSH
92299: LD_INT 11
92301: PUSH
92302: LD_INT 12
92304: PUSH
92305: LD_INT 15
92307: PUSH
92308: LD_INT 16
92310: PUSH
92311: LD_INT 20
92313: PUSH
92314: LD_INT 21
92316: PUSH
92317: LD_INT 22
92319: PUSH
92320: LD_INT 23
92322: PUSH
92323: LD_INT 25
92325: PUSH
92326: LD_INT 26
92328: PUSH
92329: EMPTY
92330: LIST
92331: LIST
92332: LIST
92333: LIST
92334: LIST
92335: LIST
92336: LIST
92337: LIST
92338: LIST
92339: LIST
92340: LIST
92341: LIST
92342: LIST
92343: LIST
92344: PUSH
92345: LD_INT 101
92347: PUSH
92348: LD_INT 102
92350: PUSH
92351: LD_INT 103
92353: PUSH
92354: LD_INT 105
92356: PUSH
92357: LD_INT 106
92359: PUSH
92360: LD_INT 108
92362: PUSH
92363: LD_INT 112
92365: PUSH
92366: LD_INT 116
92368: PUSH
92369: LD_INT 117
92371: PUSH
92372: LD_INT 118
92374: PUSH
92375: EMPTY
92376: LIST
92377: LIST
92378: LIST
92379: LIST
92380: LIST
92381: LIST
92382: LIST
92383: LIST
92384: LIST
92385: LIST
92386: PUSH
92387: EMPTY
92388: LIST
92389: LIST
92390: ST_TO_ADDR
92391: GO 94794
92393: LD_INT 8
92395: DOUBLE
92396: EQUAL
92397: IFTRUE 92401
92399: GO 92541
92401: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
92402: LD_ADDR_VAR 0 2
92406: PUSH
92407: LD_INT 2
92409: PUSH
92410: LD_INT 4
92412: PUSH
92413: LD_INT 5
92415: PUSH
92416: LD_INT 6
92418: PUSH
92419: LD_INT 7
92421: PUSH
92422: LD_INT 8
92424: PUSH
92425: LD_INT 11
92427: PUSH
92428: LD_INT 12
92430: PUSH
92431: LD_INT 15
92433: PUSH
92434: LD_INT 16
92436: PUSH
92437: LD_INT 20
92439: PUSH
92440: LD_INT 21
92442: PUSH
92443: LD_INT 22
92445: PUSH
92446: LD_INT 23
92448: PUSH
92449: LD_INT 25
92451: PUSH
92452: LD_INT 26
92454: PUSH
92455: LD_INT 30
92457: PUSH
92458: LD_INT 31
92460: PUSH
92461: LD_INT 32
92463: PUSH
92464: LD_INT 36
92466: PUSH
92467: EMPTY
92468: LIST
92469: LIST
92470: LIST
92471: LIST
92472: LIST
92473: LIST
92474: LIST
92475: LIST
92476: LIST
92477: LIST
92478: LIST
92479: LIST
92480: LIST
92481: LIST
92482: LIST
92483: LIST
92484: LIST
92485: LIST
92486: LIST
92487: LIST
92488: PUSH
92489: LD_INT 101
92491: PUSH
92492: LD_INT 102
92494: PUSH
92495: LD_INT 103
92497: PUSH
92498: LD_INT 105
92500: PUSH
92501: LD_INT 106
92503: PUSH
92504: LD_INT 108
92506: PUSH
92507: LD_INT 109
92509: PUSH
92510: LD_INT 112
92512: PUSH
92513: LD_INT 116
92515: PUSH
92516: LD_INT 117
92518: PUSH
92519: LD_INT 118
92521: PUSH
92522: EMPTY
92523: LIST
92524: LIST
92525: LIST
92526: LIST
92527: LIST
92528: LIST
92529: LIST
92530: LIST
92531: LIST
92532: LIST
92533: LIST
92534: PUSH
92535: EMPTY
92536: LIST
92537: LIST
92538: ST_TO_ADDR
92539: GO 94794
92541: LD_INT 9
92543: DOUBLE
92544: EQUAL
92545: IFTRUE 92549
92547: GO 92697
92549: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
92550: LD_ADDR_VAR 0 2
92554: PUSH
92555: LD_INT 2
92557: PUSH
92558: LD_INT 4
92560: PUSH
92561: LD_INT 5
92563: PUSH
92564: LD_INT 6
92566: PUSH
92567: LD_INT 7
92569: PUSH
92570: LD_INT 8
92572: PUSH
92573: LD_INT 11
92575: PUSH
92576: LD_INT 12
92578: PUSH
92579: LD_INT 15
92581: PUSH
92582: LD_INT 16
92584: PUSH
92585: LD_INT 20
92587: PUSH
92588: LD_INT 21
92590: PUSH
92591: LD_INT 22
92593: PUSH
92594: LD_INT 23
92596: PUSH
92597: LD_INT 25
92599: PUSH
92600: LD_INT 26
92602: PUSH
92603: LD_INT 28
92605: PUSH
92606: LD_INT 30
92608: PUSH
92609: LD_INT 31
92611: PUSH
92612: LD_INT 32
92614: PUSH
92615: LD_INT 36
92617: PUSH
92618: EMPTY
92619: LIST
92620: LIST
92621: LIST
92622: LIST
92623: LIST
92624: LIST
92625: LIST
92626: LIST
92627: LIST
92628: LIST
92629: LIST
92630: LIST
92631: LIST
92632: LIST
92633: LIST
92634: LIST
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: PUSH
92641: LD_INT 101
92643: PUSH
92644: LD_INT 102
92646: PUSH
92647: LD_INT 103
92649: PUSH
92650: LD_INT 105
92652: PUSH
92653: LD_INT 106
92655: PUSH
92656: LD_INT 108
92658: PUSH
92659: LD_INT 109
92661: PUSH
92662: LD_INT 112
92664: PUSH
92665: LD_INT 114
92667: PUSH
92668: LD_INT 116
92670: PUSH
92671: LD_INT 117
92673: PUSH
92674: LD_INT 118
92676: PUSH
92677: EMPTY
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: LIST
92683: LIST
92684: LIST
92685: LIST
92686: LIST
92687: LIST
92688: LIST
92689: LIST
92690: PUSH
92691: EMPTY
92692: LIST
92693: LIST
92694: ST_TO_ADDR
92695: GO 94794
92697: LD_INT 10
92699: DOUBLE
92700: EQUAL
92701: IFTRUE 92705
92703: GO 92901
92705: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
92706: LD_ADDR_VAR 0 2
92710: PUSH
92711: LD_INT 2
92713: PUSH
92714: LD_INT 4
92716: PUSH
92717: LD_INT 5
92719: PUSH
92720: LD_INT 6
92722: PUSH
92723: LD_INT 7
92725: PUSH
92726: LD_INT 8
92728: PUSH
92729: LD_INT 9
92731: PUSH
92732: LD_INT 10
92734: PUSH
92735: LD_INT 11
92737: PUSH
92738: LD_INT 12
92740: PUSH
92741: LD_INT 13
92743: PUSH
92744: LD_INT 14
92746: PUSH
92747: LD_INT 15
92749: PUSH
92750: LD_INT 16
92752: PUSH
92753: LD_INT 17
92755: PUSH
92756: LD_INT 18
92758: PUSH
92759: LD_INT 19
92761: PUSH
92762: LD_INT 20
92764: PUSH
92765: LD_INT 21
92767: PUSH
92768: LD_INT 22
92770: PUSH
92771: LD_INT 23
92773: PUSH
92774: LD_INT 24
92776: PUSH
92777: LD_INT 25
92779: PUSH
92780: LD_INT 26
92782: PUSH
92783: LD_INT 28
92785: PUSH
92786: LD_INT 30
92788: PUSH
92789: LD_INT 31
92791: PUSH
92792: LD_INT 32
92794: PUSH
92795: LD_INT 36
92797: PUSH
92798: EMPTY
92799: LIST
92800: LIST
92801: LIST
92802: LIST
92803: LIST
92804: LIST
92805: LIST
92806: LIST
92807: LIST
92808: LIST
92809: LIST
92810: LIST
92811: LIST
92812: LIST
92813: LIST
92814: LIST
92815: LIST
92816: LIST
92817: LIST
92818: LIST
92819: LIST
92820: LIST
92821: LIST
92822: LIST
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: LIST
92828: PUSH
92829: LD_INT 101
92831: PUSH
92832: LD_INT 102
92834: PUSH
92835: LD_INT 103
92837: PUSH
92838: LD_INT 104
92840: PUSH
92841: LD_INT 105
92843: PUSH
92844: LD_INT 106
92846: PUSH
92847: LD_INT 107
92849: PUSH
92850: LD_INT 108
92852: PUSH
92853: LD_INT 109
92855: PUSH
92856: LD_INT 110
92858: PUSH
92859: LD_INT 111
92861: PUSH
92862: LD_INT 112
92864: PUSH
92865: LD_INT 114
92867: PUSH
92868: LD_INT 116
92870: PUSH
92871: LD_INT 117
92873: PUSH
92874: LD_INT 118
92876: PUSH
92877: EMPTY
92878: LIST
92879: LIST
92880: LIST
92881: LIST
92882: LIST
92883: LIST
92884: LIST
92885: LIST
92886: LIST
92887: LIST
92888: LIST
92889: LIST
92890: LIST
92891: LIST
92892: LIST
92893: LIST
92894: PUSH
92895: EMPTY
92896: LIST
92897: LIST
92898: ST_TO_ADDR
92899: GO 94794
92901: LD_INT 11
92903: DOUBLE
92904: EQUAL
92905: IFTRUE 92909
92907: GO 93113
92909: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
92910: LD_ADDR_VAR 0 2
92914: PUSH
92915: LD_INT 2
92917: PUSH
92918: LD_INT 3
92920: PUSH
92921: LD_INT 4
92923: PUSH
92924: LD_INT 5
92926: PUSH
92927: LD_INT 6
92929: PUSH
92930: LD_INT 7
92932: PUSH
92933: LD_INT 8
92935: PUSH
92936: LD_INT 9
92938: PUSH
92939: LD_INT 10
92941: PUSH
92942: LD_INT 11
92944: PUSH
92945: LD_INT 12
92947: PUSH
92948: LD_INT 13
92950: PUSH
92951: LD_INT 14
92953: PUSH
92954: LD_INT 15
92956: PUSH
92957: LD_INT 16
92959: PUSH
92960: LD_INT 17
92962: PUSH
92963: LD_INT 18
92965: PUSH
92966: LD_INT 19
92968: PUSH
92969: LD_INT 20
92971: PUSH
92972: LD_INT 21
92974: PUSH
92975: LD_INT 22
92977: PUSH
92978: LD_INT 23
92980: PUSH
92981: LD_INT 24
92983: PUSH
92984: LD_INT 25
92986: PUSH
92987: LD_INT 26
92989: PUSH
92990: LD_INT 28
92992: PUSH
92993: LD_INT 30
92995: PUSH
92996: LD_INT 31
92998: PUSH
92999: LD_INT 32
93001: PUSH
93002: LD_INT 34
93004: PUSH
93005: LD_INT 36
93007: PUSH
93008: EMPTY
93009: LIST
93010: LIST
93011: LIST
93012: LIST
93013: LIST
93014: LIST
93015: LIST
93016: LIST
93017: LIST
93018: LIST
93019: LIST
93020: LIST
93021: LIST
93022: LIST
93023: LIST
93024: LIST
93025: LIST
93026: LIST
93027: LIST
93028: LIST
93029: LIST
93030: LIST
93031: LIST
93032: LIST
93033: LIST
93034: LIST
93035: LIST
93036: LIST
93037: LIST
93038: LIST
93039: LIST
93040: PUSH
93041: LD_INT 101
93043: PUSH
93044: LD_INT 102
93046: PUSH
93047: LD_INT 103
93049: PUSH
93050: LD_INT 104
93052: PUSH
93053: LD_INT 105
93055: PUSH
93056: LD_INT 106
93058: PUSH
93059: LD_INT 107
93061: PUSH
93062: LD_INT 108
93064: PUSH
93065: LD_INT 109
93067: PUSH
93068: LD_INT 110
93070: PUSH
93071: LD_INT 111
93073: PUSH
93074: LD_INT 112
93076: PUSH
93077: LD_INT 114
93079: PUSH
93080: LD_INT 116
93082: PUSH
93083: LD_INT 117
93085: PUSH
93086: LD_INT 118
93088: PUSH
93089: EMPTY
93090: LIST
93091: LIST
93092: LIST
93093: LIST
93094: LIST
93095: LIST
93096: LIST
93097: LIST
93098: LIST
93099: LIST
93100: LIST
93101: LIST
93102: LIST
93103: LIST
93104: LIST
93105: LIST
93106: PUSH
93107: EMPTY
93108: LIST
93109: LIST
93110: ST_TO_ADDR
93111: GO 94794
93113: LD_INT 12
93115: DOUBLE
93116: EQUAL
93117: IFTRUE 93121
93119: GO 93341
93121: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
93122: LD_ADDR_VAR 0 2
93126: PUSH
93127: LD_INT 1
93129: PUSH
93130: LD_INT 2
93132: PUSH
93133: LD_INT 3
93135: PUSH
93136: LD_INT 4
93138: PUSH
93139: LD_INT 5
93141: PUSH
93142: LD_INT 6
93144: PUSH
93145: LD_INT 7
93147: PUSH
93148: LD_INT 8
93150: PUSH
93151: LD_INT 9
93153: PUSH
93154: LD_INT 10
93156: PUSH
93157: LD_INT 11
93159: PUSH
93160: LD_INT 12
93162: PUSH
93163: LD_INT 13
93165: PUSH
93166: LD_INT 14
93168: PUSH
93169: LD_INT 15
93171: PUSH
93172: LD_INT 16
93174: PUSH
93175: LD_INT 17
93177: PUSH
93178: LD_INT 18
93180: PUSH
93181: LD_INT 19
93183: PUSH
93184: LD_INT 20
93186: PUSH
93187: LD_INT 21
93189: PUSH
93190: LD_INT 22
93192: PUSH
93193: LD_INT 23
93195: PUSH
93196: LD_INT 24
93198: PUSH
93199: LD_INT 25
93201: PUSH
93202: LD_INT 26
93204: PUSH
93205: LD_INT 27
93207: PUSH
93208: LD_INT 28
93210: PUSH
93211: LD_INT 30
93213: PUSH
93214: LD_INT 31
93216: PUSH
93217: LD_INT 32
93219: PUSH
93220: LD_INT 33
93222: PUSH
93223: LD_INT 34
93225: PUSH
93226: LD_INT 36
93228: PUSH
93229: EMPTY
93230: LIST
93231: LIST
93232: LIST
93233: LIST
93234: LIST
93235: LIST
93236: LIST
93237: LIST
93238: LIST
93239: LIST
93240: LIST
93241: LIST
93242: LIST
93243: LIST
93244: LIST
93245: LIST
93246: LIST
93247: LIST
93248: LIST
93249: LIST
93250: LIST
93251: LIST
93252: LIST
93253: LIST
93254: LIST
93255: LIST
93256: LIST
93257: LIST
93258: LIST
93259: LIST
93260: LIST
93261: LIST
93262: LIST
93263: LIST
93264: PUSH
93265: LD_INT 101
93267: PUSH
93268: LD_INT 102
93270: PUSH
93271: LD_INT 103
93273: PUSH
93274: LD_INT 104
93276: PUSH
93277: LD_INT 105
93279: PUSH
93280: LD_INT 106
93282: PUSH
93283: LD_INT 107
93285: PUSH
93286: LD_INT 108
93288: PUSH
93289: LD_INT 109
93291: PUSH
93292: LD_INT 110
93294: PUSH
93295: LD_INT 111
93297: PUSH
93298: LD_INT 112
93300: PUSH
93301: LD_INT 113
93303: PUSH
93304: LD_INT 114
93306: PUSH
93307: LD_INT 116
93309: PUSH
93310: LD_INT 117
93312: PUSH
93313: LD_INT 118
93315: PUSH
93316: EMPTY
93317: LIST
93318: LIST
93319: LIST
93320: LIST
93321: LIST
93322: LIST
93323: LIST
93324: LIST
93325: LIST
93326: LIST
93327: LIST
93328: LIST
93329: LIST
93330: LIST
93331: LIST
93332: LIST
93333: LIST
93334: PUSH
93335: EMPTY
93336: LIST
93337: LIST
93338: ST_TO_ADDR
93339: GO 94794
93341: LD_INT 13
93343: DOUBLE
93344: EQUAL
93345: IFTRUE 93349
93347: GO 93557
93349: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
93350: LD_ADDR_VAR 0 2
93354: PUSH
93355: LD_INT 1
93357: PUSH
93358: LD_INT 2
93360: PUSH
93361: LD_INT 3
93363: PUSH
93364: LD_INT 4
93366: PUSH
93367: LD_INT 5
93369: PUSH
93370: LD_INT 8
93372: PUSH
93373: LD_INT 9
93375: PUSH
93376: LD_INT 10
93378: PUSH
93379: LD_INT 11
93381: PUSH
93382: LD_INT 12
93384: PUSH
93385: LD_INT 14
93387: PUSH
93388: LD_INT 15
93390: PUSH
93391: LD_INT 16
93393: PUSH
93394: LD_INT 17
93396: PUSH
93397: LD_INT 18
93399: PUSH
93400: LD_INT 19
93402: PUSH
93403: LD_INT 20
93405: PUSH
93406: LD_INT 21
93408: PUSH
93409: LD_INT 22
93411: PUSH
93412: LD_INT 23
93414: PUSH
93415: LD_INT 24
93417: PUSH
93418: LD_INT 25
93420: PUSH
93421: LD_INT 26
93423: PUSH
93424: LD_INT 27
93426: PUSH
93427: LD_INT 28
93429: PUSH
93430: LD_INT 30
93432: PUSH
93433: LD_INT 31
93435: PUSH
93436: LD_INT 32
93438: PUSH
93439: LD_INT 33
93441: PUSH
93442: LD_INT 34
93444: PUSH
93445: LD_INT 36
93447: PUSH
93448: EMPTY
93449: LIST
93450: LIST
93451: LIST
93452: LIST
93453: LIST
93454: LIST
93455: LIST
93456: LIST
93457: LIST
93458: LIST
93459: LIST
93460: LIST
93461: LIST
93462: LIST
93463: LIST
93464: LIST
93465: LIST
93466: LIST
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: LIST
93474: LIST
93475: LIST
93476: LIST
93477: LIST
93478: LIST
93479: LIST
93480: PUSH
93481: LD_INT 101
93483: PUSH
93484: LD_INT 102
93486: PUSH
93487: LD_INT 103
93489: PUSH
93490: LD_INT 104
93492: PUSH
93493: LD_INT 105
93495: PUSH
93496: LD_INT 106
93498: PUSH
93499: LD_INT 107
93501: PUSH
93502: LD_INT 108
93504: PUSH
93505: LD_INT 109
93507: PUSH
93508: LD_INT 110
93510: PUSH
93511: LD_INT 111
93513: PUSH
93514: LD_INT 112
93516: PUSH
93517: LD_INT 113
93519: PUSH
93520: LD_INT 114
93522: PUSH
93523: LD_INT 116
93525: PUSH
93526: LD_INT 117
93528: PUSH
93529: LD_INT 118
93531: PUSH
93532: EMPTY
93533: LIST
93534: LIST
93535: LIST
93536: LIST
93537: LIST
93538: LIST
93539: LIST
93540: LIST
93541: LIST
93542: LIST
93543: LIST
93544: LIST
93545: LIST
93546: LIST
93547: LIST
93548: LIST
93549: LIST
93550: PUSH
93551: EMPTY
93552: LIST
93553: LIST
93554: ST_TO_ADDR
93555: GO 94794
93557: LD_INT 14
93559: DOUBLE
93560: EQUAL
93561: IFTRUE 93565
93563: GO 93789
93565: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
93566: LD_ADDR_VAR 0 2
93570: PUSH
93571: LD_INT 1
93573: PUSH
93574: LD_INT 2
93576: PUSH
93577: LD_INT 3
93579: PUSH
93580: LD_INT 4
93582: PUSH
93583: LD_INT 5
93585: PUSH
93586: LD_INT 6
93588: PUSH
93589: LD_INT 7
93591: PUSH
93592: LD_INT 8
93594: PUSH
93595: LD_INT 9
93597: PUSH
93598: LD_INT 10
93600: PUSH
93601: LD_INT 11
93603: PUSH
93604: LD_INT 12
93606: PUSH
93607: LD_INT 13
93609: PUSH
93610: LD_INT 14
93612: PUSH
93613: LD_INT 15
93615: PUSH
93616: LD_INT 16
93618: PUSH
93619: LD_INT 17
93621: PUSH
93622: LD_INT 18
93624: PUSH
93625: LD_INT 19
93627: PUSH
93628: LD_INT 20
93630: PUSH
93631: LD_INT 21
93633: PUSH
93634: LD_INT 22
93636: PUSH
93637: LD_INT 23
93639: PUSH
93640: LD_INT 24
93642: PUSH
93643: LD_INT 25
93645: PUSH
93646: LD_INT 26
93648: PUSH
93649: LD_INT 27
93651: PUSH
93652: LD_INT 28
93654: PUSH
93655: LD_INT 29
93657: PUSH
93658: LD_INT 30
93660: PUSH
93661: LD_INT 31
93663: PUSH
93664: LD_INT 32
93666: PUSH
93667: LD_INT 33
93669: PUSH
93670: LD_INT 34
93672: PUSH
93673: LD_INT 36
93675: PUSH
93676: EMPTY
93677: LIST
93678: LIST
93679: LIST
93680: LIST
93681: LIST
93682: LIST
93683: LIST
93684: LIST
93685: LIST
93686: LIST
93687: LIST
93688: LIST
93689: LIST
93690: LIST
93691: LIST
93692: LIST
93693: LIST
93694: LIST
93695: LIST
93696: LIST
93697: LIST
93698: LIST
93699: LIST
93700: LIST
93701: LIST
93702: LIST
93703: LIST
93704: LIST
93705: LIST
93706: LIST
93707: LIST
93708: LIST
93709: LIST
93710: LIST
93711: LIST
93712: PUSH
93713: LD_INT 101
93715: PUSH
93716: LD_INT 102
93718: PUSH
93719: LD_INT 103
93721: PUSH
93722: LD_INT 104
93724: PUSH
93725: LD_INT 105
93727: PUSH
93728: LD_INT 106
93730: PUSH
93731: LD_INT 107
93733: PUSH
93734: LD_INT 108
93736: PUSH
93737: LD_INT 109
93739: PUSH
93740: LD_INT 110
93742: PUSH
93743: LD_INT 111
93745: PUSH
93746: LD_INT 112
93748: PUSH
93749: LD_INT 113
93751: PUSH
93752: LD_INT 114
93754: PUSH
93755: LD_INT 116
93757: PUSH
93758: LD_INT 117
93760: PUSH
93761: LD_INT 118
93763: PUSH
93764: EMPTY
93765: LIST
93766: LIST
93767: LIST
93768: LIST
93769: LIST
93770: LIST
93771: LIST
93772: LIST
93773: LIST
93774: LIST
93775: LIST
93776: LIST
93777: LIST
93778: LIST
93779: LIST
93780: LIST
93781: LIST
93782: PUSH
93783: EMPTY
93784: LIST
93785: LIST
93786: ST_TO_ADDR
93787: GO 94794
93789: LD_INT 15
93791: DOUBLE
93792: EQUAL
93793: IFTRUE 93797
93795: GO 94021
93797: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
93798: LD_ADDR_VAR 0 2
93802: PUSH
93803: LD_INT 1
93805: PUSH
93806: LD_INT 2
93808: PUSH
93809: LD_INT 3
93811: PUSH
93812: LD_INT 4
93814: PUSH
93815: LD_INT 5
93817: PUSH
93818: LD_INT 6
93820: PUSH
93821: LD_INT 7
93823: PUSH
93824: LD_INT 8
93826: PUSH
93827: LD_INT 9
93829: PUSH
93830: LD_INT 10
93832: PUSH
93833: LD_INT 11
93835: PUSH
93836: LD_INT 12
93838: PUSH
93839: LD_INT 13
93841: PUSH
93842: LD_INT 14
93844: PUSH
93845: LD_INT 15
93847: PUSH
93848: LD_INT 16
93850: PUSH
93851: LD_INT 17
93853: PUSH
93854: LD_INT 18
93856: PUSH
93857: LD_INT 19
93859: PUSH
93860: LD_INT 20
93862: PUSH
93863: LD_INT 21
93865: PUSH
93866: LD_INT 22
93868: PUSH
93869: LD_INT 23
93871: PUSH
93872: LD_INT 24
93874: PUSH
93875: LD_INT 25
93877: PUSH
93878: LD_INT 26
93880: PUSH
93881: LD_INT 27
93883: PUSH
93884: LD_INT 28
93886: PUSH
93887: LD_INT 29
93889: PUSH
93890: LD_INT 30
93892: PUSH
93893: LD_INT 31
93895: PUSH
93896: LD_INT 32
93898: PUSH
93899: LD_INT 33
93901: PUSH
93902: LD_INT 34
93904: PUSH
93905: LD_INT 36
93907: PUSH
93908: EMPTY
93909: LIST
93910: LIST
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: LIST
93918: LIST
93919: LIST
93920: LIST
93921: LIST
93922: LIST
93923: LIST
93924: LIST
93925: LIST
93926: LIST
93927: LIST
93928: LIST
93929: LIST
93930: LIST
93931: LIST
93932: LIST
93933: LIST
93934: LIST
93935: LIST
93936: LIST
93937: LIST
93938: LIST
93939: LIST
93940: LIST
93941: LIST
93942: LIST
93943: LIST
93944: PUSH
93945: LD_INT 101
93947: PUSH
93948: LD_INT 102
93950: PUSH
93951: LD_INT 103
93953: PUSH
93954: LD_INT 104
93956: PUSH
93957: LD_INT 105
93959: PUSH
93960: LD_INT 106
93962: PUSH
93963: LD_INT 107
93965: PUSH
93966: LD_INT 108
93968: PUSH
93969: LD_INT 109
93971: PUSH
93972: LD_INT 110
93974: PUSH
93975: LD_INT 111
93977: PUSH
93978: LD_INT 112
93980: PUSH
93981: LD_INT 113
93983: PUSH
93984: LD_INT 114
93986: PUSH
93987: LD_INT 116
93989: PUSH
93990: LD_INT 117
93992: PUSH
93993: LD_INT 118
93995: PUSH
93996: EMPTY
93997: LIST
93998: LIST
93999: LIST
94000: LIST
94001: LIST
94002: LIST
94003: LIST
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: LIST
94009: LIST
94010: LIST
94011: LIST
94012: LIST
94013: LIST
94014: PUSH
94015: EMPTY
94016: LIST
94017: LIST
94018: ST_TO_ADDR
94019: GO 94794
94021: LD_INT 16
94023: DOUBLE
94024: EQUAL
94025: IFTRUE 94029
94027: GO 94165
94029: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
94030: LD_ADDR_VAR 0 2
94034: PUSH
94035: LD_INT 2
94037: PUSH
94038: LD_INT 4
94040: PUSH
94041: LD_INT 5
94043: PUSH
94044: LD_INT 7
94046: PUSH
94047: LD_INT 11
94049: PUSH
94050: LD_INT 12
94052: PUSH
94053: LD_INT 15
94055: PUSH
94056: LD_INT 16
94058: PUSH
94059: LD_INT 20
94061: PUSH
94062: LD_INT 21
94064: PUSH
94065: LD_INT 22
94067: PUSH
94068: LD_INT 23
94070: PUSH
94071: LD_INT 25
94073: PUSH
94074: LD_INT 26
94076: PUSH
94077: LD_INT 30
94079: PUSH
94080: LD_INT 31
94082: PUSH
94083: LD_INT 32
94085: PUSH
94086: LD_INT 33
94088: PUSH
94089: LD_INT 34
94091: PUSH
94092: EMPTY
94093: LIST
94094: LIST
94095: LIST
94096: LIST
94097: LIST
94098: LIST
94099: LIST
94100: LIST
94101: LIST
94102: LIST
94103: LIST
94104: LIST
94105: LIST
94106: LIST
94107: LIST
94108: LIST
94109: LIST
94110: LIST
94111: LIST
94112: PUSH
94113: LD_INT 101
94115: PUSH
94116: LD_INT 102
94118: PUSH
94119: LD_INT 103
94121: PUSH
94122: LD_INT 106
94124: PUSH
94125: LD_INT 108
94127: PUSH
94128: LD_INT 112
94130: PUSH
94131: LD_INT 113
94133: PUSH
94134: LD_INT 114
94136: PUSH
94137: LD_INT 116
94139: PUSH
94140: LD_INT 117
94142: PUSH
94143: LD_INT 118
94145: PUSH
94146: EMPTY
94147: LIST
94148: LIST
94149: LIST
94150: LIST
94151: LIST
94152: LIST
94153: LIST
94154: LIST
94155: LIST
94156: LIST
94157: LIST
94158: PUSH
94159: EMPTY
94160: LIST
94161: LIST
94162: ST_TO_ADDR
94163: GO 94794
94165: LD_INT 17
94167: DOUBLE
94168: EQUAL
94169: IFTRUE 94173
94171: GO 94397
94173: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
94174: LD_ADDR_VAR 0 2
94178: PUSH
94179: LD_INT 1
94181: PUSH
94182: LD_INT 2
94184: PUSH
94185: LD_INT 3
94187: PUSH
94188: LD_INT 4
94190: PUSH
94191: LD_INT 5
94193: PUSH
94194: LD_INT 6
94196: PUSH
94197: LD_INT 7
94199: PUSH
94200: LD_INT 8
94202: PUSH
94203: LD_INT 9
94205: PUSH
94206: LD_INT 10
94208: PUSH
94209: LD_INT 11
94211: PUSH
94212: LD_INT 12
94214: PUSH
94215: LD_INT 13
94217: PUSH
94218: LD_INT 14
94220: PUSH
94221: LD_INT 15
94223: PUSH
94224: LD_INT 16
94226: PUSH
94227: LD_INT 17
94229: PUSH
94230: LD_INT 18
94232: PUSH
94233: LD_INT 19
94235: PUSH
94236: LD_INT 20
94238: PUSH
94239: LD_INT 21
94241: PUSH
94242: LD_INT 22
94244: PUSH
94245: LD_INT 23
94247: PUSH
94248: LD_INT 24
94250: PUSH
94251: LD_INT 25
94253: PUSH
94254: LD_INT 26
94256: PUSH
94257: LD_INT 27
94259: PUSH
94260: LD_INT 28
94262: PUSH
94263: LD_INT 29
94265: PUSH
94266: LD_INT 30
94268: PUSH
94269: LD_INT 31
94271: PUSH
94272: LD_INT 32
94274: PUSH
94275: LD_INT 33
94277: PUSH
94278: LD_INT 34
94280: PUSH
94281: LD_INT 36
94283: PUSH
94284: EMPTY
94285: LIST
94286: LIST
94287: LIST
94288: LIST
94289: LIST
94290: LIST
94291: LIST
94292: LIST
94293: LIST
94294: LIST
94295: LIST
94296: LIST
94297: LIST
94298: LIST
94299: LIST
94300: LIST
94301: LIST
94302: LIST
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: LIST
94319: LIST
94320: PUSH
94321: LD_INT 101
94323: PUSH
94324: LD_INT 102
94326: PUSH
94327: LD_INT 103
94329: PUSH
94330: LD_INT 104
94332: PUSH
94333: LD_INT 105
94335: PUSH
94336: LD_INT 106
94338: PUSH
94339: LD_INT 107
94341: PUSH
94342: LD_INT 108
94344: PUSH
94345: LD_INT 109
94347: PUSH
94348: LD_INT 110
94350: PUSH
94351: LD_INT 111
94353: PUSH
94354: LD_INT 112
94356: PUSH
94357: LD_INT 113
94359: PUSH
94360: LD_INT 114
94362: PUSH
94363: LD_INT 116
94365: PUSH
94366: LD_INT 117
94368: PUSH
94369: LD_INT 118
94371: PUSH
94372: EMPTY
94373: LIST
94374: LIST
94375: LIST
94376: LIST
94377: LIST
94378: LIST
94379: LIST
94380: LIST
94381: LIST
94382: LIST
94383: LIST
94384: LIST
94385: LIST
94386: LIST
94387: LIST
94388: LIST
94389: LIST
94390: PUSH
94391: EMPTY
94392: LIST
94393: LIST
94394: ST_TO_ADDR
94395: GO 94794
94397: LD_INT 18
94399: DOUBLE
94400: EQUAL
94401: IFTRUE 94405
94403: GO 94553
94405: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
94406: LD_ADDR_VAR 0 2
94410: PUSH
94411: LD_INT 2
94413: PUSH
94414: LD_INT 4
94416: PUSH
94417: LD_INT 5
94419: PUSH
94420: LD_INT 7
94422: PUSH
94423: LD_INT 11
94425: PUSH
94426: LD_INT 12
94428: PUSH
94429: LD_INT 15
94431: PUSH
94432: LD_INT 16
94434: PUSH
94435: LD_INT 20
94437: PUSH
94438: LD_INT 21
94440: PUSH
94441: LD_INT 22
94443: PUSH
94444: LD_INT 23
94446: PUSH
94447: LD_INT 25
94449: PUSH
94450: LD_INT 26
94452: PUSH
94453: LD_INT 30
94455: PUSH
94456: LD_INT 31
94458: PUSH
94459: LD_INT 32
94461: PUSH
94462: LD_INT 33
94464: PUSH
94465: LD_INT 34
94467: PUSH
94468: LD_INT 35
94470: PUSH
94471: LD_INT 36
94473: PUSH
94474: EMPTY
94475: LIST
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: LIST
94487: LIST
94488: LIST
94489: LIST
94490: LIST
94491: LIST
94492: LIST
94493: LIST
94494: LIST
94495: LIST
94496: PUSH
94497: LD_INT 101
94499: PUSH
94500: LD_INT 102
94502: PUSH
94503: LD_INT 103
94505: PUSH
94506: LD_INT 106
94508: PUSH
94509: LD_INT 108
94511: PUSH
94512: LD_INT 112
94514: PUSH
94515: LD_INT 113
94517: PUSH
94518: LD_INT 114
94520: PUSH
94521: LD_INT 115
94523: PUSH
94524: LD_INT 116
94526: PUSH
94527: LD_INT 117
94529: PUSH
94530: LD_INT 118
94532: PUSH
94533: EMPTY
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: PUSH
94547: EMPTY
94548: LIST
94549: LIST
94550: ST_TO_ADDR
94551: GO 94794
94553: LD_INT 19
94555: DOUBLE
94556: EQUAL
94557: IFTRUE 94561
94559: GO 94793
94561: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
94562: LD_ADDR_VAR 0 2
94566: PUSH
94567: LD_INT 1
94569: PUSH
94570: LD_INT 2
94572: PUSH
94573: LD_INT 3
94575: PUSH
94576: LD_INT 4
94578: PUSH
94579: LD_INT 5
94581: PUSH
94582: LD_INT 6
94584: PUSH
94585: LD_INT 7
94587: PUSH
94588: LD_INT 8
94590: PUSH
94591: LD_INT 9
94593: PUSH
94594: LD_INT 10
94596: PUSH
94597: LD_INT 11
94599: PUSH
94600: LD_INT 12
94602: PUSH
94603: LD_INT 13
94605: PUSH
94606: LD_INT 14
94608: PUSH
94609: LD_INT 15
94611: PUSH
94612: LD_INT 16
94614: PUSH
94615: LD_INT 17
94617: PUSH
94618: LD_INT 18
94620: PUSH
94621: LD_INT 19
94623: PUSH
94624: LD_INT 20
94626: PUSH
94627: LD_INT 21
94629: PUSH
94630: LD_INT 22
94632: PUSH
94633: LD_INT 23
94635: PUSH
94636: LD_INT 24
94638: PUSH
94639: LD_INT 25
94641: PUSH
94642: LD_INT 26
94644: PUSH
94645: LD_INT 27
94647: PUSH
94648: LD_INT 28
94650: PUSH
94651: LD_INT 29
94653: PUSH
94654: LD_INT 30
94656: PUSH
94657: LD_INT 31
94659: PUSH
94660: LD_INT 32
94662: PUSH
94663: LD_INT 33
94665: PUSH
94666: LD_INT 34
94668: PUSH
94669: LD_INT 35
94671: PUSH
94672: LD_INT 36
94674: PUSH
94675: EMPTY
94676: LIST
94677: LIST
94678: LIST
94679: LIST
94680: LIST
94681: LIST
94682: LIST
94683: LIST
94684: LIST
94685: LIST
94686: LIST
94687: LIST
94688: LIST
94689: LIST
94690: LIST
94691: LIST
94692: LIST
94693: LIST
94694: LIST
94695: LIST
94696: LIST
94697: LIST
94698: LIST
94699: LIST
94700: LIST
94701: LIST
94702: LIST
94703: LIST
94704: LIST
94705: LIST
94706: LIST
94707: LIST
94708: LIST
94709: LIST
94710: LIST
94711: LIST
94712: PUSH
94713: LD_INT 101
94715: PUSH
94716: LD_INT 102
94718: PUSH
94719: LD_INT 103
94721: PUSH
94722: LD_INT 104
94724: PUSH
94725: LD_INT 105
94727: PUSH
94728: LD_INT 106
94730: PUSH
94731: LD_INT 107
94733: PUSH
94734: LD_INT 108
94736: PUSH
94737: LD_INT 109
94739: PUSH
94740: LD_INT 110
94742: PUSH
94743: LD_INT 111
94745: PUSH
94746: LD_INT 112
94748: PUSH
94749: LD_INT 113
94751: PUSH
94752: LD_INT 114
94754: PUSH
94755: LD_INT 115
94757: PUSH
94758: LD_INT 116
94760: PUSH
94761: LD_INT 117
94763: PUSH
94764: LD_INT 118
94766: PUSH
94767: EMPTY
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: PUSH
94787: EMPTY
94788: LIST
94789: LIST
94790: ST_TO_ADDR
94791: GO 94794
94793: POP
// end else
94794: GO 95025
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
94796: LD_ADDR_VAR 0 2
94800: PUSH
94801: LD_INT 1
94803: PUSH
94804: LD_INT 2
94806: PUSH
94807: LD_INT 3
94809: PUSH
94810: LD_INT 4
94812: PUSH
94813: LD_INT 5
94815: PUSH
94816: LD_INT 6
94818: PUSH
94819: LD_INT 7
94821: PUSH
94822: LD_INT 8
94824: PUSH
94825: LD_INT 9
94827: PUSH
94828: LD_INT 10
94830: PUSH
94831: LD_INT 11
94833: PUSH
94834: LD_INT 12
94836: PUSH
94837: LD_INT 13
94839: PUSH
94840: LD_INT 14
94842: PUSH
94843: LD_INT 15
94845: PUSH
94846: LD_INT 16
94848: PUSH
94849: LD_INT 17
94851: PUSH
94852: LD_INT 18
94854: PUSH
94855: LD_INT 19
94857: PUSH
94858: LD_INT 20
94860: PUSH
94861: LD_INT 21
94863: PUSH
94864: LD_INT 22
94866: PUSH
94867: LD_INT 23
94869: PUSH
94870: LD_INT 24
94872: PUSH
94873: LD_INT 25
94875: PUSH
94876: LD_INT 26
94878: PUSH
94879: LD_INT 27
94881: PUSH
94882: LD_INT 28
94884: PUSH
94885: LD_INT 29
94887: PUSH
94888: LD_INT 30
94890: PUSH
94891: LD_INT 31
94893: PUSH
94894: LD_INT 32
94896: PUSH
94897: LD_INT 33
94899: PUSH
94900: LD_INT 34
94902: PUSH
94903: LD_INT 35
94905: PUSH
94906: LD_INT 36
94908: PUSH
94909: EMPTY
94910: LIST
94911: LIST
94912: LIST
94913: LIST
94914: LIST
94915: LIST
94916: LIST
94917: LIST
94918: LIST
94919: LIST
94920: LIST
94921: LIST
94922: LIST
94923: LIST
94924: LIST
94925: LIST
94926: LIST
94927: LIST
94928: LIST
94929: LIST
94930: LIST
94931: LIST
94932: LIST
94933: LIST
94934: LIST
94935: LIST
94936: LIST
94937: LIST
94938: LIST
94939: LIST
94940: LIST
94941: LIST
94942: LIST
94943: LIST
94944: LIST
94945: LIST
94946: PUSH
94947: LD_INT 101
94949: PUSH
94950: LD_INT 102
94952: PUSH
94953: LD_INT 103
94955: PUSH
94956: LD_INT 104
94958: PUSH
94959: LD_INT 105
94961: PUSH
94962: LD_INT 106
94964: PUSH
94965: LD_INT 107
94967: PUSH
94968: LD_INT 108
94970: PUSH
94971: LD_INT 109
94973: PUSH
94974: LD_INT 110
94976: PUSH
94977: LD_INT 111
94979: PUSH
94980: LD_INT 112
94982: PUSH
94983: LD_INT 113
94985: PUSH
94986: LD_INT 114
94988: PUSH
94989: LD_INT 115
94991: PUSH
94992: LD_INT 116
94994: PUSH
94995: LD_INT 117
94997: PUSH
94998: LD_INT 118
95000: PUSH
95001: EMPTY
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: LIST
95013: LIST
95014: LIST
95015: LIST
95016: LIST
95017: LIST
95018: LIST
95019: LIST
95020: PUSH
95021: EMPTY
95022: LIST
95023: LIST
95024: ST_TO_ADDR
// if result then
95025: LD_VAR 0 2
95029: IFFALSE 95815
// begin normal :=  ;
95031: LD_ADDR_VAR 0 5
95035: PUSH
95036: LD_STRING 
95038: ST_TO_ADDR
// hardcore :=  ;
95039: LD_ADDR_VAR 0 6
95043: PUSH
95044: LD_STRING 
95046: ST_TO_ADDR
// active :=  ;
95047: LD_ADDR_VAR 0 7
95051: PUSH
95052: LD_STRING 
95054: ST_TO_ADDR
// for i = 1 to normalCounter do
95055: LD_ADDR_VAR 0 8
95059: PUSH
95060: DOUBLE
95061: LD_INT 1
95063: DEC
95064: ST_TO_ADDR
95065: LD_EXP 108
95069: PUSH
95070: FOR_TO
95071: IFFALSE 95172
// begin tmp := 0 ;
95073: LD_ADDR_VAR 0 3
95077: PUSH
95078: LD_STRING 0
95080: ST_TO_ADDR
// if result [ 1 ] then
95081: LD_VAR 0 2
95085: PUSH
95086: LD_INT 1
95088: ARRAY
95089: IFFALSE 95154
// if result [ 1 ] [ 1 ] = i then
95091: LD_VAR 0 2
95095: PUSH
95096: LD_INT 1
95098: ARRAY
95099: PUSH
95100: LD_INT 1
95102: ARRAY
95103: PUSH
95104: LD_VAR 0 8
95108: EQUAL
95109: IFFALSE 95154
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
95111: LD_ADDR_VAR 0 2
95115: PUSH
95116: LD_VAR 0 2
95120: PPUSH
95121: LD_INT 1
95123: PPUSH
95124: LD_VAR 0 2
95128: PUSH
95129: LD_INT 1
95131: ARRAY
95132: PPUSH
95133: LD_INT 1
95135: PPUSH
95136: CALL_OW 3
95140: PPUSH
95141: CALL_OW 1
95145: ST_TO_ADDR
// tmp := 1 ;
95146: LD_ADDR_VAR 0 3
95150: PUSH
95151: LD_STRING 1
95153: ST_TO_ADDR
// end ; normal := normal & tmp ;
95154: LD_ADDR_VAR 0 5
95158: PUSH
95159: LD_VAR 0 5
95163: PUSH
95164: LD_VAR 0 3
95168: STR
95169: ST_TO_ADDR
// end ;
95170: GO 95070
95172: POP
95173: POP
// for i = 1 to hardcoreCounter do
95174: LD_ADDR_VAR 0 8
95178: PUSH
95179: DOUBLE
95180: LD_INT 1
95182: DEC
95183: ST_TO_ADDR
95184: LD_EXP 109
95188: PUSH
95189: FOR_TO
95190: IFFALSE 95295
// begin tmp := 0 ;
95192: LD_ADDR_VAR 0 3
95196: PUSH
95197: LD_STRING 0
95199: ST_TO_ADDR
// if result [ 2 ] then
95200: LD_VAR 0 2
95204: PUSH
95205: LD_INT 2
95207: ARRAY
95208: IFFALSE 95277
// if result [ 2 ] [ 1 ] = 100 + i then
95210: LD_VAR 0 2
95214: PUSH
95215: LD_INT 2
95217: ARRAY
95218: PUSH
95219: LD_INT 1
95221: ARRAY
95222: PUSH
95223: LD_INT 100
95225: PUSH
95226: LD_VAR 0 8
95230: PLUS
95231: EQUAL
95232: IFFALSE 95277
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
95234: LD_ADDR_VAR 0 2
95238: PUSH
95239: LD_VAR 0 2
95243: PPUSH
95244: LD_INT 2
95246: PPUSH
95247: LD_VAR 0 2
95251: PUSH
95252: LD_INT 2
95254: ARRAY
95255: PPUSH
95256: LD_INT 1
95258: PPUSH
95259: CALL_OW 3
95263: PPUSH
95264: CALL_OW 1
95268: ST_TO_ADDR
// tmp := 1 ;
95269: LD_ADDR_VAR 0 3
95273: PUSH
95274: LD_STRING 1
95276: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
95277: LD_ADDR_VAR 0 6
95281: PUSH
95282: LD_VAR 0 6
95286: PUSH
95287: LD_VAR 0 3
95291: STR
95292: ST_TO_ADDR
// end ;
95293: GO 95189
95295: POP
95296: POP
// if isGameLoad then
95297: LD_VAR 0 1
95301: IFFALSE 95776
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
95303: LD_ADDR_VAR 0 4
95307: PUSH
95308: LD_EXP 112
95312: PUSH
95313: LD_EXP 111
95317: PUSH
95318: LD_EXP 113
95322: PUSH
95323: LD_EXP 110
95327: PUSH
95328: LD_EXP 114
95332: PUSH
95333: LD_EXP 115
95337: PUSH
95338: LD_EXP 116
95342: PUSH
95343: LD_EXP 117
95347: PUSH
95348: LD_EXP 118
95352: PUSH
95353: LD_EXP 119
95357: PUSH
95358: LD_EXP 120
95362: PUSH
95363: LD_EXP 121
95367: PUSH
95368: LD_EXP 122
95372: PUSH
95373: LD_EXP 123
95377: PUSH
95378: LD_EXP 131
95382: PUSH
95383: LD_EXP 132
95387: PUSH
95388: LD_EXP 133
95392: PUSH
95393: LD_EXP 134
95397: PUSH
95398: LD_EXP 136
95402: PUSH
95403: LD_EXP 137
95407: PUSH
95408: LD_EXP 138
95412: PUSH
95413: LD_EXP 141
95417: PUSH
95418: LD_EXP 143
95422: PUSH
95423: LD_EXP 144
95427: PUSH
95428: LD_EXP 145
95432: PUSH
95433: LD_EXP 147
95437: PUSH
95438: LD_EXP 148
95442: PUSH
95443: LD_EXP 151
95447: PUSH
95448: LD_EXP 152
95452: PUSH
95453: LD_EXP 153
95457: PUSH
95458: LD_EXP 154
95462: PUSH
95463: LD_EXP 155
95467: PUSH
95468: LD_EXP 156
95472: PUSH
95473: LD_EXP 157
95477: PUSH
95478: LD_EXP 158
95482: PUSH
95483: LD_EXP 159
95487: PUSH
95488: LD_EXP 124
95492: PUSH
95493: LD_EXP 125
95497: PUSH
95498: LD_EXP 128
95502: PUSH
95503: LD_EXP 129
95507: PUSH
95508: LD_EXP 130
95512: PUSH
95513: LD_EXP 126
95517: PUSH
95518: LD_EXP 127
95522: PUSH
95523: LD_EXP 135
95527: PUSH
95528: LD_EXP 139
95532: PUSH
95533: LD_EXP 140
95537: PUSH
95538: LD_EXP 142
95542: PUSH
95543: LD_EXP 146
95547: PUSH
95548: LD_EXP 149
95552: PUSH
95553: LD_EXP 150
95557: PUSH
95558: LD_EXP 160
95562: PUSH
95563: LD_EXP 161
95567: PUSH
95568: LD_EXP 162
95572: PUSH
95573: LD_EXP 163
95577: PUSH
95578: EMPTY
95579: LIST
95580: LIST
95581: LIST
95582: LIST
95583: LIST
95584: LIST
95585: LIST
95586: LIST
95587: LIST
95588: LIST
95589: LIST
95590: LIST
95591: LIST
95592: LIST
95593: LIST
95594: LIST
95595: LIST
95596: LIST
95597: LIST
95598: LIST
95599: LIST
95600: LIST
95601: LIST
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: LIST
95616: LIST
95617: LIST
95618: LIST
95619: LIST
95620: LIST
95621: LIST
95622: LIST
95623: LIST
95624: LIST
95625: LIST
95626: LIST
95627: LIST
95628: LIST
95629: LIST
95630: LIST
95631: LIST
95632: LIST
95633: ST_TO_ADDR
// tmp :=  ;
95634: LD_ADDR_VAR 0 3
95638: PUSH
95639: LD_STRING 
95641: ST_TO_ADDR
// for i = 1 to normalCounter do
95642: LD_ADDR_VAR 0 8
95646: PUSH
95647: DOUBLE
95648: LD_INT 1
95650: DEC
95651: ST_TO_ADDR
95652: LD_EXP 108
95656: PUSH
95657: FOR_TO
95658: IFFALSE 95694
// begin if flags [ i ] then
95660: LD_VAR 0 4
95664: PUSH
95665: LD_VAR 0 8
95669: ARRAY
95670: IFFALSE 95692
// tmp := tmp & i & ; ;
95672: LD_ADDR_VAR 0 3
95676: PUSH
95677: LD_VAR 0 3
95681: PUSH
95682: LD_VAR 0 8
95686: STR
95687: PUSH
95688: LD_STRING ;
95690: STR
95691: ST_TO_ADDR
// end ;
95692: GO 95657
95694: POP
95695: POP
// for i = 1 to hardcoreCounter do
95696: LD_ADDR_VAR 0 8
95700: PUSH
95701: DOUBLE
95702: LD_INT 1
95704: DEC
95705: ST_TO_ADDR
95706: LD_EXP 109
95710: PUSH
95711: FOR_TO
95712: IFFALSE 95758
// begin if flags [ normalCounter + i ] then
95714: LD_VAR 0 4
95718: PUSH
95719: LD_EXP 108
95723: PUSH
95724: LD_VAR 0 8
95728: PLUS
95729: ARRAY
95730: IFFALSE 95756
// tmp := tmp & ( 100 + i ) & ; ;
95732: LD_ADDR_VAR 0 3
95736: PUSH
95737: LD_VAR 0 3
95741: PUSH
95742: LD_INT 100
95744: PUSH
95745: LD_VAR 0 8
95749: PLUS
95750: STR
95751: PUSH
95752: LD_STRING ;
95754: STR
95755: ST_TO_ADDR
// end ;
95756: GO 95711
95758: POP
95759: POP
// if tmp then
95760: LD_VAR 0 3
95764: IFFALSE 95776
// active := tmp ;
95766: LD_ADDR_VAR 0 7
95770: PUSH
95771: LD_VAR 0 3
95775: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
95776: LD_STRING getStreamItemsFromMission("
95778: PUSH
95779: LD_VAR 0 5
95783: STR
95784: PUSH
95785: LD_STRING ","
95787: STR
95788: PUSH
95789: LD_VAR 0 6
95793: STR
95794: PUSH
95795: LD_STRING ","
95797: STR
95798: PUSH
95799: LD_VAR 0 7
95803: STR
95804: PUSH
95805: LD_STRING ")
95807: STR
95808: PPUSH
95809: CALL_OW 559
// end else
95813: GO 95822
// ToLua ( getStreamItemsFromMission("","","") ) ;
95815: LD_STRING getStreamItemsFromMission("","","")
95817: PPUSH
95818: CALL_OW 559
// end ;
95822: LD_VAR 0 2
95826: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
95827: LD_EXP 107
95831: PUSH
95832: LD_EXP 112
95836: AND
95837: IFFALSE 95961
95839: GO 95841
95841: DISABLE
95842: LD_INT 0
95844: PPUSH
95845: PPUSH
// begin enable ;
95846: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
95847: LD_ADDR_VAR 0 2
95851: PUSH
95852: LD_INT 22
95854: PUSH
95855: LD_OWVAR 2
95859: PUSH
95860: EMPTY
95861: LIST
95862: LIST
95863: PUSH
95864: LD_INT 2
95866: PUSH
95867: LD_INT 34
95869: PUSH
95870: LD_INT 7
95872: PUSH
95873: EMPTY
95874: LIST
95875: LIST
95876: PUSH
95877: LD_INT 34
95879: PUSH
95880: LD_INT 45
95882: PUSH
95883: EMPTY
95884: LIST
95885: LIST
95886: PUSH
95887: LD_INT 34
95889: PUSH
95890: LD_INT 28
95892: PUSH
95893: EMPTY
95894: LIST
95895: LIST
95896: PUSH
95897: LD_INT 34
95899: PUSH
95900: LD_INT 47
95902: PUSH
95903: EMPTY
95904: LIST
95905: LIST
95906: PUSH
95907: EMPTY
95908: LIST
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: PUSH
95914: EMPTY
95915: LIST
95916: LIST
95917: PPUSH
95918: CALL_OW 69
95922: ST_TO_ADDR
// if not tmp then
95923: LD_VAR 0 2
95927: NOT
95928: IFFALSE 95932
// exit ;
95930: GO 95961
// for i in tmp do
95932: LD_ADDR_VAR 0 1
95936: PUSH
95937: LD_VAR 0 2
95941: PUSH
95942: FOR_IN
95943: IFFALSE 95959
// begin SetLives ( i , 0 ) ;
95945: LD_VAR 0 1
95949: PPUSH
95950: LD_INT 0
95952: PPUSH
95953: CALL_OW 234
// end ;
95957: GO 95942
95959: POP
95960: POP
// end ;
95961: PPOPN 2
95963: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
95964: LD_EXP 107
95968: PUSH
95969: LD_EXP 113
95973: AND
95974: IFFALSE 96058
95976: GO 95978
95978: DISABLE
95979: LD_INT 0
95981: PPUSH
95982: PPUSH
// begin enable ;
95983: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
95984: LD_ADDR_VAR 0 2
95988: PUSH
95989: LD_INT 22
95991: PUSH
95992: LD_OWVAR 2
95996: PUSH
95997: EMPTY
95998: LIST
95999: LIST
96000: PUSH
96001: LD_INT 32
96003: PUSH
96004: LD_INT 3
96006: PUSH
96007: EMPTY
96008: LIST
96009: LIST
96010: PUSH
96011: EMPTY
96012: LIST
96013: LIST
96014: PPUSH
96015: CALL_OW 69
96019: ST_TO_ADDR
// if not tmp then
96020: LD_VAR 0 2
96024: NOT
96025: IFFALSE 96029
// exit ;
96027: GO 96058
// for i in tmp do
96029: LD_ADDR_VAR 0 1
96033: PUSH
96034: LD_VAR 0 2
96038: PUSH
96039: FOR_IN
96040: IFFALSE 96056
// begin SetLives ( i , 0 ) ;
96042: LD_VAR 0 1
96046: PPUSH
96047: LD_INT 0
96049: PPUSH
96050: CALL_OW 234
// end ;
96054: GO 96039
96056: POP
96057: POP
// end ;
96058: PPOPN 2
96060: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96061: LD_EXP 107
96065: PUSH
96066: LD_EXP 110
96070: AND
96071: IFFALSE 96164
96073: GO 96075
96075: DISABLE
96076: LD_INT 0
96078: PPUSH
// begin enable ;
96079: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96080: LD_ADDR_VAR 0 1
96084: PUSH
96085: LD_INT 22
96087: PUSH
96088: LD_OWVAR 2
96092: PUSH
96093: EMPTY
96094: LIST
96095: LIST
96096: PUSH
96097: LD_INT 2
96099: PUSH
96100: LD_INT 25
96102: PUSH
96103: LD_INT 5
96105: PUSH
96106: EMPTY
96107: LIST
96108: LIST
96109: PUSH
96110: LD_INT 25
96112: PUSH
96113: LD_INT 9
96115: PUSH
96116: EMPTY
96117: LIST
96118: LIST
96119: PUSH
96120: LD_INT 25
96122: PUSH
96123: LD_INT 8
96125: PUSH
96126: EMPTY
96127: LIST
96128: LIST
96129: PUSH
96130: EMPTY
96131: LIST
96132: LIST
96133: LIST
96134: LIST
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: PPUSH
96140: CALL_OW 69
96144: PUSH
96145: FOR_IN
96146: IFFALSE 96162
// begin SetClass ( i , 1 ) ;
96148: LD_VAR 0 1
96152: PPUSH
96153: LD_INT 1
96155: PPUSH
96156: CALL_OW 336
// end ;
96160: GO 96145
96162: POP
96163: POP
// end ;
96164: PPOPN 1
96166: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
96167: LD_EXP 107
96171: PUSH
96172: LD_EXP 111
96176: AND
96177: PUSH
96178: LD_OWVAR 65
96182: PUSH
96183: LD_INT 7
96185: LESS
96186: AND
96187: IFFALSE 96201
96189: GO 96191
96191: DISABLE
// begin enable ;
96192: ENABLE
// game_speed := 7 ;
96193: LD_ADDR_OWVAR 65
96197: PUSH
96198: LD_INT 7
96200: ST_TO_ADDR
// end ;
96201: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
96202: LD_EXP 107
96206: PUSH
96207: LD_EXP 114
96211: AND
96212: IFFALSE 96414
96214: GO 96216
96216: DISABLE
96217: LD_INT 0
96219: PPUSH
96220: PPUSH
96221: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96222: LD_ADDR_VAR 0 3
96226: PUSH
96227: LD_INT 81
96229: PUSH
96230: LD_OWVAR 2
96234: PUSH
96235: EMPTY
96236: LIST
96237: LIST
96238: PUSH
96239: LD_INT 21
96241: PUSH
96242: LD_INT 1
96244: PUSH
96245: EMPTY
96246: LIST
96247: LIST
96248: PUSH
96249: EMPTY
96250: LIST
96251: LIST
96252: PPUSH
96253: CALL_OW 69
96257: ST_TO_ADDR
// if not tmp then
96258: LD_VAR 0 3
96262: NOT
96263: IFFALSE 96267
// exit ;
96265: GO 96414
// if tmp > 5 then
96267: LD_VAR 0 3
96271: PUSH
96272: LD_INT 5
96274: GREATER
96275: IFFALSE 96287
// k := 5 else
96277: LD_ADDR_VAR 0 2
96281: PUSH
96282: LD_INT 5
96284: ST_TO_ADDR
96285: GO 96297
// k := tmp ;
96287: LD_ADDR_VAR 0 2
96291: PUSH
96292: LD_VAR 0 3
96296: ST_TO_ADDR
// for i := 1 to k do
96297: LD_ADDR_VAR 0 1
96301: PUSH
96302: DOUBLE
96303: LD_INT 1
96305: DEC
96306: ST_TO_ADDR
96307: LD_VAR 0 2
96311: PUSH
96312: FOR_TO
96313: IFFALSE 96412
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
96315: LD_VAR 0 3
96319: PUSH
96320: LD_VAR 0 1
96324: ARRAY
96325: PPUSH
96326: LD_VAR 0 1
96330: PUSH
96331: LD_INT 4
96333: MOD
96334: PUSH
96335: LD_INT 1
96337: PLUS
96338: PPUSH
96339: CALL_OW 259
96343: PUSH
96344: LD_INT 10
96346: LESS
96347: IFFALSE 96410
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
96349: LD_VAR 0 3
96353: PUSH
96354: LD_VAR 0 1
96358: ARRAY
96359: PPUSH
96360: LD_VAR 0 1
96364: PUSH
96365: LD_INT 4
96367: MOD
96368: PUSH
96369: LD_INT 1
96371: PLUS
96372: PPUSH
96373: LD_VAR 0 3
96377: PUSH
96378: LD_VAR 0 1
96382: ARRAY
96383: PPUSH
96384: LD_VAR 0 1
96388: PUSH
96389: LD_INT 4
96391: MOD
96392: PUSH
96393: LD_INT 1
96395: PLUS
96396: PPUSH
96397: CALL_OW 259
96401: PUSH
96402: LD_INT 1
96404: PLUS
96405: PPUSH
96406: CALL_OW 237
96410: GO 96312
96412: POP
96413: POP
// end ;
96414: PPOPN 3
96416: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
96417: LD_EXP 107
96421: PUSH
96422: LD_EXP 115
96426: AND
96427: IFFALSE 96447
96429: GO 96431
96431: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
96432: LD_INT 4
96434: PPUSH
96435: LD_OWVAR 2
96439: PPUSH
96440: LD_INT 0
96442: PPUSH
96443: CALL_OW 324
96447: END
// every 0 0$1 trigger StreamModeActive and sShovel do
96448: LD_EXP 107
96452: PUSH
96453: LD_EXP 144
96457: AND
96458: IFFALSE 96478
96460: GO 96462
96462: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
96463: LD_INT 19
96465: PPUSH
96466: LD_OWVAR 2
96470: PPUSH
96471: LD_INT 0
96473: PPUSH
96474: CALL_OW 324
96478: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
96479: LD_EXP 107
96483: PUSH
96484: LD_EXP 116
96488: AND
96489: IFFALSE 96591
96491: GO 96493
96493: DISABLE
96494: LD_INT 0
96496: PPUSH
96497: PPUSH
// begin enable ;
96498: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
96499: LD_ADDR_VAR 0 2
96503: PUSH
96504: LD_INT 22
96506: PUSH
96507: LD_OWVAR 2
96511: PUSH
96512: EMPTY
96513: LIST
96514: LIST
96515: PUSH
96516: LD_INT 2
96518: PUSH
96519: LD_INT 34
96521: PUSH
96522: LD_INT 11
96524: PUSH
96525: EMPTY
96526: LIST
96527: LIST
96528: PUSH
96529: LD_INT 34
96531: PUSH
96532: LD_INT 30
96534: PUSH
96535: EMPTY
96536: LIST
96537: LIST
96538: PUSH
96539: EMPTY
96540: LIST
96541: LIST
96542: LIST
96543: PUSH
96544: EMPTY
96545: LIST
96546: LIST
96547: PPUSH
96548: CALL_OW 69
96552: ST_TO_ADDR
// if not tmp then
96553: LD_VAR 0 2
96557: NOT
96558: IFFALSE 96562
// exit ;
96560: GO 96591
// for i in tmp do
96562: LD_ADDR_VAR 0 1
96566: PUSH
96567: LD_VAR 0 2
96571: PUSH
96572: FOR_IN
96573: IFFALSE 96589
// begin SetLives ( i , 0 ) ;
96575: LD_VAR 0 1
96579: PPUSH
96580: LD_INT 0
96582: PPUSH
96583: CALL_OW 234
// end ;
96587: GO 96572
96589: POP
96590: POP
// end ;
96591: PPOPN 2
96593: END
// every 0 0$1 trigger StreamModeActive and sBunker do
96594: LD_EXP 107
96598: PUSH
96599: LD_EXP 117
96603: AND
96604: IFFALSE 96624
96606: GO 96608
96608: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
96609: LD_INT 32
96611: PPUSH
96612: LD_OWVAR 2
96616: PPUSH
96617: LD_INT 0
96619: PPUSH
96620: CALL_OW 324
96624: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
96625: LD_EXP 107
96629: PUSH
96630: LD_EXP 118
96634: AND
96635: IFFALSE 96816
96637: GO 96639
96639: DISABLE
96640: LD_INT 0
96642: PPUSH
96643: PPUSH
96644: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
96645: LD_ADDR_VAR 0 2
96649: PUSH
96650: LD_INT 22
96652: PUSH
96653: LD_OWVAR 2
96657: PUSH
96658: EMPTY
96659: LIST
96660: LIST
96661: PUSH
96662: LD_INT 33
96664: PUSH
96665: LD_INT 3
96667: PUSH
96668: EMPTY
96669: LIST
96670: LIST
96671: PUSH
96672: EMPTY
96673: LIST
96674: LIST
96675: PPUSH
96676: CALL_OW 69
96680: ST_TO_ADDR
// if not tmp then
96681: LD_VAR 0 2
96685: NOT
96686: IFFALSE 96690
// exit ;
96688: GO 96816
// side := 0 ;
96690: LD_ADDR_VAR 0 3
96694: PUSH
96695: LD_INT 0
96697: ST_TO_ADDR
// for i := 1 to 8 do
96698: LD_ADDR_VAR 0 1
96702: PUSH
96703: DOUBLE
96704: LD_INT 1
96706: DEC
96707: ST_TO_ADDR
96708: LD_INT 8
96710: PUSH
96711: FOR_TO
96712: IFFALSE 96760
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
96714: LD_OWVAR 2
96718: PUSH
96719: LD_VAR 0 1
96723: NONEQUAL
96724: PUSH
96725: LD_OWVAR 2
96729: PPUSH
96730: LD_VAR 0 1
96734: PPUSH
96735: CALL_OW 81
96739: PUSH
96740: LD_INT 2
96742: EQUAL
96743: AND
96744: IFFALSE 96758
// begin side := i ;
96746: LD_ADDR_VAR 0 3
96750: PUSH
96751: LD_VAR 0 1
96755: ST_TO_ADDR
// break ;
96756: GO 96760
// end ;
96758: GO 96711
96760: POP
96761: POP
// if not side then
96762: LD_VAR 0 3
96766: NOT
96767: IFFALSE 96771
// exit ;
96769: GO 96816
// for i := 1 to tmp do
96771: LD_ADDR_VAR 0 1
96775: PUSH
96776: DOUBLE
96777: LD_INT 1
96779: DEC
96780: ST_TO_ADDR
96781: LD_VAR 0 2
96785: PUSH
96786: FOR_TO
96787: IFFALSE 96814
// if Prob ( 60 ) then
96789: LD_INT 60
96791: PPUSH
96792: CALL_OW 13
96796: IFFALSE 96812
// SetSide ( i , side ) ;
96798: LD_VAR 0 1
96802: PPUSH
96803: LD_VAR 0 3
96807: PPUSH
96808: CALL_OW 235
96812: GO 96786
96814: POP
96815: POP
// end ;
96816: PPOPN 3
96818: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
96819: LD_EXP 107
96823: PUSH
96824: LD_EXP 120
96828: AND
96829: IFFALSE 96948
96831: GO 96833
96833: DISABLE
96834: LD_INT 0
96836: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
96837: LD_ADDR_VAR 0 1
96841: PUSH
96842: LD_INT 22
96844: PUSH
96845: LD_OWVAR 2
96849: PUSH
96850: EMPTY
96851: LIST
96852: LIST
96853: PUSH
96854: LD_INT 21
96856: PUSH
96857: LD_INT 1
96859: PUSH
96860: EMPTY
96861: LIST
96862: LIST
96863: PUSH
96864: LD_INT 3
96866: PUSH
96867: LD_INT 23
96869: PUSH
96870: LD_INT 0
96872: PUSH
96873: EMPTY
96874: LIST
96875: LIST
96876: PUSH
96877: EMPTY
96878: LIST
96879: LIST
96880: PUSH
96881: EMPTY
96882: LIST
96883: LIST
96884: LIST
96885: PPUSH
96886: CALL_OW 69
96890: PUSH
96891: FOR_IN
96892: IFFALSE 96946
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
96894: LD_VAR 0 1
96898: PPUSH
96899: CALL_OW 257
96903: PUSH
96904: LD_INT 1
96906: PUSH
96907: LD_INT 2
96909: PUSH
96910: LD_INT 3
96912: PUSH
96913: LD_INT 4
96915: PUSH
96916: EMPTY
96917: LIST
96918: LIST
96919: LIST
96920: LIST
96921: IN
96922: IFFALSE 96944
// SetClass ( un , rand ( 1 , 4 ) ) ;
96924: LD_VAR 0 1
96928: PPUSH
96929: LD_INT 1
96931: PPUSH
96932: LD_INT 4
96934: PPUSH
96935: CALL_OW 12
96939: PPUSH
96940: CALL_OW 336
96944: GO 96891
96946: POP
96947: POP
// end ;
96948: PPOPN 1
96950: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
96951: LD_EXP 107
96955: PUSH
96956: LD_EXP 119
96960: AND
96961: IFFALSE 97040
96963: GO 96965
96965: DISABLE
96966: LD_INT 0
96968: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
96969: LD_ADDR_VAR 0 1
96973: PUSH
96974: LD_INT 22
96976: PUSH
96977: LD_OWVAR 2
96981: PUSH
96982: EMPTY
96983: LIST
96984: LIST
96985: PUSH
96986: LD_INT 21
96988: PUSH
96989: LD_INT 3
96991: PUSH
96992: EMPTY
96993: LIST
96994: LIST
96995: PUSH
96996: EMPTY
96997: LIST
96998: LIST
96999: PPUSH
97000: CALL_OW 69
97004: ST_TO_ADDR
// if not tmp then
97005: LD_VAR 0 1
97009: NOT
97010: IFFALSE 97014
// exit ;
97012: GO 97040
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97014: LD_VAR 0 1
97018: PUSH
97019: LD_INT 1
97021: PPUSH
97022: LD_VAR 0 1
97026: PPUSH
97027: CALL_OW 12
97031: ARRAY
97032: PPUSH
97033: LD_INT 100
97035: PPUSH
97036: CALL_OW 234
// end ;
97040: PPOPN 1
97042: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97043: LD_EXP 107
97047: PUSH
97048: LD_EXP 121
97052: AND
97053: IFFALSE 97151
97055: GO 97057
97057: DISABLE
97058: LD_INT 0
97060: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97061: LD_ADDR_VAR 0 1
97065: PUSH
97066: LD_INT 22
97068: PUSH
97069: LD_OWVAR 2
97073: PUSH
97074: EMPTY
97075: LIST
97076: LIST
97077: PUSH
97078: LD_INT 21
97080: PUSH
97081: LD_INT 1
97083: PUSH
97084: EMPTY
97085: LIST
97086: LIST
97087: PUSH
97088: EMPTY
97089: LIST
97090: LIST
97091: PPUSH
97092: CALL_OW 69
97096: ST_TO_ADDR
// if not tmp then
97097: LD_VAR 0 1
97101: NOT
97102: IFFALSE 97106
// exit ;
97104: GO 97151
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
97106: LD_VAR 0 1
97110: PUSH
97111: LD_INT 1
97113: PPUSH
97114: LD_VAR 0 1
97118: PPUSH
97119: CALL_OW 12
97123: ARRAY
97124: PPUSH
97125: LD_INT 1
97127: PPUSH
97128: LD_INT 4
97130: PPUSH
97131: CALL_OW 12
97135: PPUSH
97136: LD_INT 3000
97138: PPUSH
97139: LD_INT 9000
97141: PPUSH
97142: CALL_OW 12
97146: PPUSH
97147: CALL_OW 492
// end ;
97151: PPOPN 1
97153: END
// every 0 0$1 trigger StreamModeActive and sDepot do
97154: LD_EXP 107
97158: PUSH
97159: LD_EXP 122
97163: AND
97164: IFFALSE 97184
97166: GO 97168
97168: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
97169: LD_INT 1
97171: PPUSH
97172: LD_OWVAR 2
97176: PPUSH
97177: LD_INT 0
97179: PPUSH
97180: CALL_OW 324
97184: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
97185: LD_EXP 107
97189: PUSH
97190: LD_EXP 123
97194: AND
97195: IFFALSE 97278
97197: GO 97199
97199: DISABLE
97200: LD_INT 0
97202: PPUSH
97203: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97204: LD_ADDR_VAR 0 2
97208: PUSH
97209: LD_INT 22
97211: PUSH
97212: LD_OWVAR 2
97216: PUSH
97217: EMPTY
97218: LIST
97219: LIST
97220: PUSH
97221: LD_INT 21
97223: PUSH
97224: LD_INT 3
97226: PUSH
97227: EMPTY
97228: LIST
97229: LIST
97230: PUSH
97231: EMPTY
97232: LIST
97233: LIST
97234: PPUSH
97235: CALL_OW 69
97239: ST_TO_ADDR
// if not tmp then
97240: LD_VAR 0 2
97244: NOT
97245: IFFALSE 97249
// exit ;
97247: GO 97278
// for i in tmp do
97249: LD_ADDR_VAR 0 1
97253: PUSH
97254: LD_VAR 0 2
97258: PUSH
97259: FOR_IN
97260: IFFALSE 97276
// SetBLevel ( i , 10 ) ;
97262: LD_VAR 0 1
97266: PPUSH
97267: LD_INT 10
97269: PPUSH
97270: CALL_OW 241
97274: GO 97259
97276: POP
97277: POP
// end ;
97278: PPOPN 2
97280: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
97281: LD_EXP 107
97285: PUSH
97286: LD_EXP 124
97290: AND
97291: IFFALSE 97402
97293: GO 97295
97295: DISABLE
97296: LD_INT 0
97298: PPUSH
97299: PPUSH
97300: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97301: LD_ADDR_VAR 0 3
97305: PUSH
97306: LD_INT 22
97308: PUSH
97309: LD_OWVAR 2
97313: PUSH
97314: EMPTY
97315: LIST
97316: LIST
97317: PUSH
97318: LD_INT 25
97320: PUSH
97321: LD_INT 1
97323: PUSH
97324: EMPTY
97325: LIST
97326: LIST
97327: PUSH
97328: EMPTY
97329: LIST
97330: LIST
97331: PPUSH
97332: CALL_OW 69
97336: ST_TO_ADDR
// if not tmp then
97337: LD_VAR 0 3
97341: NOT
97342: IFFALSE 97346
// exit ;
97344: GO 97402
// un := tmp [ rand ( 1 , tmp ) ] ;
97346: LD_ADDR_VAR 0 2
97350: PUSH
97351: LD_VAR 0 3
97355: PUSH
97356: LD_INT 1
97358: PPUSH
97359: LD_VAR 0 3
97363: PPUSH
97364: CALL_OW 12
97368: ARRAY
97369: ST_TO_ADDR
// if Crawls ( un ) then
97370: LD_VAR 0 2
97374: PPUSH
97375: CALL_OW 318
97379: IFFALSE 97390
// ComWalk ( un ) ;
97381: LD_VAR 0 2
97385: PPUSH
97386: CALL_OW 138
// SetClass ( un , class_sniper ) ;
97390: LD_VAR 0 2
97394: PPUSH
97395: LD_INT 5
97397: PPUSH
97398: CALL_OW 336
// end ;
97402: PPOPN 3
97404: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
97405: LD_EXP 107
97409: PUSH
97410: LD_EXP 125
97414: AND
97415: PUSH
97416: LD_OWVAR 67
97420: PUSH
97421: LD_INT 4
97423: LESS
97424: AND
97425: IFFALSE 97444
97427: GO 97429
97429: DISABLE
// begin Difficulty := Difficulty + 1 ;
97430: LD_ADDR_OWVAR 67
97434: PUSH
97435: LD_OWVAR 67
97439: PUSH
97440: LD_INT 1
97442: PLUS
97443: ST_TO_ADDR
// end ;
97444: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
97445: LD_EXP 107
97449: PUSH
97450: LD_EXP 126
97454: AND
97455: IFFALSE 97558
97457: GO 97459
97459: DISABLE
97460: LD_INT 0
97462: PPUSH
// begin for i := 1 to 5 do
97463: LD_ADDR_VAR 0 1
97467: PUSH
97468: DOUBLE
97469: LD_INT 1
97471: DEC
97472: ST_TO_ADDR
97473: LD_INT 5
97475: PUSH
97476: FOR_TO
97477: IFFALSE 97556
// begin uc_nation := nation_nature ;
97479: LD_ADDR_OWVAR 21
97483: PUSH
97484: LD_INT 0
97486: ST_TO_ADDR
// uc_side := 0 ;
97487: LD_ADDR_OWVAR 20
97491: PUSH
97492: LD_INT 0
97494: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97495: LD_ADDR_OWVAR 29
97499: PUSH
97500: LD_INT 12
97502: PUSH
97503: LD_INT 12
97505: PUSH
97506: EMPTY
97507: LIST
97508: LIST
97509: ST_TO_ADDR
// hc_agressivity := 20 ;
97510: LD_ADDR_OWVAR 35
97514: PUSH
97515: LD_INT 20
97517: ST_TO_ADDR
// hc_class := class_tiger ;
97518: LD_ADDR_OWVAR 28
97522: PUSH
97523: LD_INT 14
97525: ST_TO_ADDR
// hc_gallery :=  ;
97526: LD_ADDR_OWVAR 33
97530: PUSH
97531: LD_STRING 
97533: ST_TO_ADDR
// hc_name :=  ;
97534: LD_ADDR_OWVAR 26
97538: PUSH
97539: LD_STRING 
97541: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
97542: CALL_OW 44
97546: PPUSH
97547: LD_INT 0
97549: PPUSH
97550: CALL_OW 51
// end ;
97554: GO 97476
97556: POP
97557: POP
// end ;
97558: PPOPN 1
97560: END
// every 0 0$1 trigger StreamModeActive and sBomb do
97561: LD_EXP 107
97565: PUSH
97566: LD_EXP 127
97570: AND
97571: IFFALSE 97580
97573: GO 97575
97575: DISABLE
// StreamSibBomb ;
97576: CALL 97581 0 0
97580: END
// export function StreamSibBomb ; var i , x , y ; begin
97581: LD_INT 0
97583: PPUSH
97584: PPUSH
97585: PPUSH
97586: PPUSH
// result := false ;
97587: LD_ADDR_VAR 0 1
97591: PUSH
97592: LD_INT 0
97594: ST_TO_ADDR
// for i := 1 to 16 do
97595: LD_ADDR_VAR 0 2
97599: PUSH
97600: DOUBLE
97601: LD_INT 1
97603: DEC
97604: ST_TO_ADDR
97605: LD_INT 16
97607: PUSH
97608: FOR_TO
97609: IFFALSE 97808
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97611: LD_ADDR_VAR 0 3
97615: PUSH
97616: LD_INT 10
97618: PUSH
97619: LD_INT 20
97621: PUSH
97622: LD_INT 30
97624: PUSH
97625: LD_INT 40
97627: PUSH
97628: LD_INT 50
97630: PUSH
97631: LD_INT 60
97633: PUSH
97634: LD_INT 70
97636: PUSH
97637: LD_INT 80
97639: PUSH
97640: LD_INT 90
97642: PUSH
97643: LD_INT 100
97645: PUSH
97646: LD_INT 110
97648: PUSH
97649: LD_INT 120
97651: PUSH
97652: LD_INT 130
97654: PUSH
97655: LD_INT 140
97657: PUSH
97658: LD_INT 150
97660: PUSH
97661: EMPTY
97662: LIST
97663: LIST
97664: LIST
97665: LIST
97666: LIST
97667: LIST
97668: LIST
97669: LIST
97670: LIST
97671: LIST
97672: LIST
97673: LIST
97674: LIST
97675: LIST
97676: LIST
97677: PUSH
97678: LD_INT 1
97680: PPUSH
97681: LD_INT 15
97683: PPUSH
97684: CALL_OW 12
97688: ARRAY
97689: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97690: LD_ADDR_VAR 0 4
97694: PUSH
97695: LD_INT 10
97697: PUSH
97698: LD_INT 20
97700: PUSH
97701: LD_INT 30
97703: PUSH
97704: LD_INT 40
97706: PUSH
97707: LD_INT 50
97709: PUSH
97710: LD_INT 60
97712: PUSH
97713: LD_INT 70
97715: PUSH
97716: LD_INT 80
97718: PUSH
97719: LD_INT 90
97721: PUSH
97722: LD_INT 100
97724: PUSH
97725: LD_INT 110
97727: PUSH
97728: LD_INT 120
97730: PUSH
97731: LD_INT 130
97733: PUSH
97734: LD_INT 140
97736: PUSH
97737: LD_INT 150
97739: PUSH
97740: EMPTY
97741: LIST
97742: LIST
97743: LIST
97744: LIST
97745: LIST
97746: LIST
97747: LIST
97748: LIST
97749: LIST
97750: LIST
97751: LIST
97752: LIST
97753: LIST
97754: LIST
97755: LIST
97756: PUSH
97757: LD_INT 1
97759: PPUSH
97760: LD_INT 15
97762: PPUSH
97763: CALL_OW 12
97767: ARRAY
97768: ST_TO_ADDR
// if ValidHex ( x , y ) then
97769: LD_VAR 0 3
97773: PPUSH
97774: LD_VAR 0 4
97778: PPUSH
97779: CALL_OW 488
97783: IFFALSE 97806
// begin result := [ x , y ] ;
97785: LD_ADDR_VAR 0 1
97789: PUSH
97790: LD_VAR 0 3
97794: PUSH
97795: LD_VAR 0 4
97799: PUSH
97800: EMPTY
97801: LIST
97802: LIST
97803: ST_TO_ADDR
// break ;
97804: GO 97808
// end ; end ;
97806: GO 97608
97808: POP
97809: POP
// if result then
97810: LD_VAR 0 1
97814: IFFALSE 97874
// begin ToLua ( playSibBomb() ) ;
97816: LD_STRING playSibBomb()
97818: PPUSH
97819: CALL_OW 559
// wait ( 0 0$14 ) ;
97823: LD_INT 490
97825: PPUSH
97826: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
97830: LD_VAR 0 1
97834: PUSH
97835: LD_INT 1
97837: ARRAY
97838: PPUSH
97839: LD_VAR 0 1
97843: PUSH
97844: LD_INT 2
97846: ARRAY
97847: PPUSH
97848: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
97852: LD_VAR 0 1
97856: PUSH
97857: LD_INT 1
97859: ARRAY
97860: PPUSH
97861: LD_VAR 0 1
97865: PUSH
97866: LD_INT 2
97868: ARRAY
97869: PPUSH
97870: CALL_OW 429
// end ; end ;
97874: LD_VAR 0 1
97878: RET
// every 0 0$1 trigger StreamModeActive and sReset do
97879: LD_EXP 107
97883: PUSH
97884: LD_EXP 129
97888: AND
97889: IFFALSE 97901
97891: GO 97893
97893: DISABLE
// YouLost (  ) ;
97894: LD_STRING 
97896: PPUSH
97897: CALL_OW 104
97901: END
// every 0 0$1 trigger StreamModeActive and sFog do
97902: LD_EXP 107
97906: PUSH
97907: LD_EXP 128
97911: AND
97912: IFFALSE 97926
97914: GO 97916
97916: DISABLE
// FogOff ( your_side ) ;
97917: LD_OWVAR 2
97921: PPUSH
97922: CALL_OW 344
97926: END
// every 0 0$1 trigger StreamModeActive and sSun do
97927: LD_EXP 107
97931: PUSH
97932: LD_EXP 130
97936: AND
97937: IFFALSE 97965
97939: GO 97941
97941: DISABLE
// begin solar_recharge_percent := 0 ;
97942: LD_ADDR_OWVAR 79
97946: PUSH
97947: LD_INT 0
97949: ST_TO_ADDR
// wait ( 5 5$00 ) ;
97950: LD_INT 10500
97952: PPUSH
97953: CALL_OW 67
// solar_recharge_percent := 100 ;
97957: LD_ADDR_OWVAR 79
97961: PUSH
97962: LD_INT 100
97964: ST_TO_ADDR
// end ;
97965: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
97966: LD_EXP 107
97970: PUSH
97971: LD_EXP 131
97975: AND
97976: IFFALSE 98215
97978: GO 97980
97980: DISABLE
97981: LD_INT 0
97983: PPUSH
97984: PPUSH
97985: PPUSH
// begin tmp := [ ] ;
97986: LD_ADDR_VAR 0 3
97990: PUSH
97991: EMPTY
97992: ST_TO_ADDR
// for i := 1 to 6 do
97993: LD_ADDR_VAR 0 1
97997: PUSH
97998: DOUBLE
97999: LD_INT 1
98001: DEC
98002: ST_TO_ADDR
98003: LD_INT 6
98005: PUSH
98006: FOR_TO
98007: IFFALSE 98112
// begin uc_nation := nation_nature ;
98009: LD_ADDR_OWVAR 21
98013: PUSH
98014: LD_INT 0
98016: ST_TO_ADDR
// uc_side := 0 ;
98017: LD_ADDR_OWVAR 20
98021: PUSH
98022: LD_INT 0
98024: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98025: LD_ADDR_OWVAR 29
98029: PUSH
98030: LD_INT 12
98032: PUSH
98033: LD_INT 12
98035: PUSH
98036: EMPTY
98037: LIST
98038: LIST
98039: ST_TO_ADDR
// hc_agressivity := 20 ;
98040: LD_ADDR_OWVAR 35
98044: PUSH
98045: LD_INT 20
98047: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98048: LD_ADDR_OWVAR 28
98052: PUSH
98053: LD_INT 17
98055: ST_TO_ADDR
// hc_gallery :=  ;
98056: LD_ADDR_OWVAR 33
98060: PUSH
98061: LD_STRING 
98063: ST_TO_ADDR
// hc_name :=  ;
98064: LD_ADDR_OWVAR 26
98068: PUSH
98069: LD_STRING 
98071: ST_TO_ADDR
// un := CreateHuman ;
98072: LD_ADDR_VAR 0 2
98076: PUSH
98077: CALL_OW 44
98081: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98082: LD_VAR 0 2
98086: PPUSH
98087: LD_INT 1
98089: PPUSH
98090: CALL_OW 51
// tmp := tmp ^ un ;
98094: LD_ADDR_VAR 0 3
98098: PUSH
98099: LD_VAR 0 3
98103: PUSH
98104: LD_VAR 0 2
98108: ADD
98109: ST_TO_ADDR
// end ;
98110: GO 98006
98112: POP
98113: POP
// repeat wait ( 0 0$1 ) ;
98114: LD_INT 35
98116: PPUSH
98117: CALL_OW 67
// for un in tmp do
98121: LD_ADDR_VAR 0 2
98125: PUSH
98126: LD_VAR 0 3
98130: PUSH
98131: FOR_IN
98132: IFFALSE 98206
// begin if IsDead ( un ) then
98134: LD_VAR 0 2
98138: PPUSH
98139: CALL_OW 301
98143: IFFALSE 98163
// begin tmp := tmp diff un ;
98145: LD_ADDR_VAR 0 3
98149: PUSH
98150: LD_VAR 0 3
98154: PUSH
98155: LD_VAR 0 2
98159: DIFF
98160: ST_TO_ADDR
// continue ;
98161: GO 98131
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
98163: LD_VAR 0 2
98167: PPUSH
98168: LD_INT 3
98170: PUSH
98171: LD_INT 22
98173: PUSH
98174: LD_INT 0
98176: PUSH
98177: EMPTY
98178: LIST
98179: LIST
98180: PUSH
98181: EMPTY
98182: LIST
98183: LIST
98184: PPUSH
98185: CALL_OW 69
98189: PPUSH
98190: LD_VAR 0 2
98194: PPUSH
98195: CALL_OW 74
98199: PPUSH
98200: CALL_OW 115
// end ;
98204: GO 98131
98206: POP
98207: POP
// until not tmp ;
98208: LD_VAR 0 3
98212: NOT
98213: IFFALSE 98114
// end ;
98215: PPOPN 3
98217: END
// every 0 0$1 trigger StreamModeActive and sTroll do
98218: LD_EXP 107
98222: PUSH
98223: LD_EXP 132
98227: AND
98228: IFFALSE 98282
98230: GO 98232
98232: DISABLE
// begin ToLua ( displayTroll(); ) ;
98233: LD_STRING displayTroll();
98235: PPUSH
98236: CALL_OW 559
// wait ( 3 3$00 ) ;
98240: LD_INT 6300
98242: PPUSH
98243: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98247: LD_STRING hideTroll();
98249: PPUSH
98250: CALL_OW 559
// wait ( 1 1$00 ) ;
98254: LD_INT 2100
98256: PPUSH
98257: CALL_OW 67
// ToLua ( displayTroll(); ) ;
98261: LD_STRING displayTroll();
98263: PPUSH
98264: CALL_OW 559
// wait ( 1 1$00 ) ;
98268: LD_INT 2100
98270: PPUSH
98271: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98275: LD_STRING hideTroll();
98277: PPUSH
98278: CALL_OW 559
// end ;
98282: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
98283: LD_EXP 107
98287: PUSH
98288: LD_EXP 133
98292: AND
98293: IFFALSE 98356
98295: GO 98297
98297: DISABLE
98298: LD_INT 0
98300: PPUSH
// begin p := 0 ;
98301: LD_ADDR_VAR 0 1
98305: PUSH
98306: LD_INT 0
98308: ST_TO_ADDR
// repeat game_speed := 1 ;
98309: LD_ADDR_OWVAR 65
98313: PUSH
98314: LD_INT 1
98316: ST_TO_ADDR
// wait ( 0 0$1 ) ;
98317: LD_INT 35
98319: PPUSH
98320: CALL_OW 67
// p := p + 1 ;
98324: LD_ADDR_VAR 0 1
98328: PUSH
98329: LD_VAR 0 1
98333: PUSH
98334: LD_INT 1
98336: PLUS
98337: ST_TO_ADDR
// until p >= 60 ;
98338: LD_VAR 0 1
98342: PUSH
98343: LD_INT 60
98345: GREATEREQUAL
98346: IFFALSE 98309
// game_speed := 4 ;
98348: LD_ADDR_OWVAR 65
98352: PUSH
98353: LD_INT 4
98355: ST_TO_ADDR
// end ;
98356: PPOPN 1
98358: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
98359: LD_EXP 107
98363: PUSH
98364: LD_EXP 134
98368: AND
98369: IFFALSE 98515
98371: GO 98373
98373: DISABLE
98374: LD_INT 0
98376: PPUSH
98377: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98378: LD_ADDR_VAR 0 1
98382: PUSH
98383: LD_INT 22
98385: PUSH
98386: LD_OWVAR 2
98390: PUSH
98391: EMPTY
98392: LIST
98393: LIST
98394: PUSH
98395: LD_INT 2
98397: PUSH
98398: LD_INT 30
98400: PUSH
98401: LD_INT 0
98403: PUSH
98404: EMPTY
98405: LIST
98406: LIST
98407: PUSH
98408: LD_INT 30
98410: PUSH
98411: LD_INT 1
98413: PUSH
98414: EMPTY
98415: LIST
98416: LIST
98417: PUSH
98418: EMPTY
98419: LIST
98420: LIST
98421: LIST
98422: PUSH
98423: EMPTY
98424: LIST
98425: LIST
98426: PPUSH
98427: CALL_OW 69
98431: ST_TO_ADDR
// if not depot then
98432: LD_VAR 0 1
98436: NOT
98437: IFFALSE 98441
// exit ;
98439: GO 98515
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
98441: LD_ADDR_VAR 0 2
98445: PUSH
98446: LD_VAR 0 1
98450: PUSH
98451: LD_INT 1
98453: PPUSH
98454: LD_VAR 0 1
98458: PPUSH
98459: CALL_OW 12
98463: ARRAY
98464: PPUSH
98465: CALL_OW 274
98469: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
98470: LD_VAR 0 2
98474: PPUSH
98475: LD_INT 1
98477: PPUSH
98478: LD_INT 0
98480: PPUSH
98481: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
98485: LD_VAR 0 2
98489: PPUSH
98490: LD_INT 2
98492: PPUSH
98493: LD_INT 0
98495: PPUSH
98496: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
98500: LD_VAR 0 2
98504: PPUSH
98505: LD_INT 3
98507: PPUSH
98508: LD_INT 0
98510: PPUSH
98511: CALL_OW 277
// end ;
98515: PPOPN 2
98517: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
98518: LD_EXP 107
98522: PUSH
98523: LD_EXP 135
98527: AND
98528: IFFALSE 98625
98530: GO 98532
98532: DISABLE
98533: LD_INT 0
98535: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98536: LD_ADDR_VAR 0 1
98540: PUSH
98541: LD_INT 22
98543: PUSH
98544: LD_OWVAR 2
98548: PUSH
98549: EMPTY
98550: LIST
98551: LIST
98552: PUSH
98553: LD_INT 21
98555: PUSH
98556: LD_INT 1
98558: PUSH
98559: EMPTY
98560: LIST
98561: LIST
98562: PUSH
98563: LD_INT 3
98565: PUSH
98566: LD_INT 23
98568: PUSH
98569: LD_INT 0
98571: PUSH
98572: EMPTY
98573: LIST
98574: LIST
98575: PUSH
98576: EMPTY
98577: LIST
98578: LIST
98579: PUSH
98580: EMPTY
98581: LIST
98582: LIST
98583: LIST
98584: PPUSH
98585: CALL_OW 69
98589: ST_TO_ADDR
// if not tmp then
98590: LD_VAR 0 1
98594: NOT
98595: IFFALSE 98599
// exit ;
98597: GO 98625
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
98599: LD_VAR 0 1
98603: PUSH
98604: LD_INT 1
98606: PPUSH
98607: LD_VAR 0 1
98611: PPUSH
98612: CALL_OW 12
98616: ARRAY
98617: PPUSH
98618: LD_INT 200
98620: PPUSH
98621: CALL_OW 234
// end ;
98625: PPOPN 1
98627: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
98628: LD_EXP 107
98632: PUSH
98633: LD_EXP 136
98637: AND
98638: IFFALSE 98717
98640: GO 98642
98642: DISABLE
98643: LD_INT 0
98645: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
98646: LD_ADDR_VAR 0 1
98650: PUSH
98651: LD_INT 22
98653: PUSH
98654: LD_OWVAR 2
98658: PUSH
98659: EMPTY
98660: LIST
98661: LIST
98662: PUSH
98663: LD_INT 21
98665: PUSH
98666: LD_INT 2
98668: PUSH
98669: EMPTY
98670: LIST
98671: LIST
98672: PUSH
98673: EMPTY
98674: LIST
98675: LIST
98676: PPUSH
98677: CALL_OW 69
98681: ST_TO_ADDR
// if not tmp then
98682: LD_VAR 0 1
98686: NOT
98687: IFFALSE 98691
// exit ;
98689: GO 98717
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
98691: LD_VAR 0 1
98695: PUSH
98696: LD_INT 1
98698: PPUSH
98699: LD_VAR 0 1
98703: PPUSH
98704: CALL_OW 12
98708: ARRAY
98709: PPUSH
98710: LD_INT 60
98712: PPUSH
98713: CALL_OW 234
// end ;
98717: PPOPN 1
98719: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
98720: LD_EXP 107
98724: PUSH
98725: LD_EXP 137
98729: AND
98730: IFFALSE 98829
98732: GO 98734
98734: DISABLE
98735: LD_INT 0
98737: PPUSH
98738: PPUSH
// begin enable ;
98739: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
98740: LD_ADDR_VAR 0 1
98744: PUSH
98745: LD_INT 22
98747: PUSH
98748: LD_OWVAR 2
98752: PUSH
98753: EMPTY
98754: LIST
98755: LIST
98756: PUSH
98757: LD_INT 61
98759: PUSH
98760: EMPTY
98761: LIST
98762: PUSH
98763: LD_INT 33
98765: PUSH
98766: LD_INT 2
98768: PUSH
98769: EMPTY
98770: LIST
98771: LIST
98772: PUSH
98773: EMPTY
98774: LIST
98775: LIST
98776: LIST
98777: PPUSH
98778: CALL_OW 69
98782: ST_TO_ADDR
// if not tmp then
98783: LD_VAR 0 1
98787: NOT
98788: IFFALSE 98792
// exit ;
98790: GO 98829
// for i in tmp do
98792: LD_ADDR_VAR 0 2
98796: PUSH
98797: LD_VAR 0 1
98801: PUSH
98802: FOR_IN
98803: IFFALSE 98827
// if IsControledBy ( i ) then
98805: LD_VAR 0 2
98809: PPUSH
98810: CALL_OW 312
98814: IFFALSE 98825
// ComUnlink ( i ) ;
98816: LD_VAR 0 2
98820: PPUSH
98821: CALL_OW 136
98825: GO 98802
98827: POP
98828: POP
// end ;
98829: PPOPN 2
98831: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
98832: LD_EXP 107
98836: PUSH
98837: LD_EXP 138
98841: AND
98842: IFFALSE 98982
98844: GO 98846
98846: DISABLE
98847: LD_INT 0
98849: PPUSH
98850: PPUSH
// begin ToLua ( displayPowell(); ) ;
98851: LD_STRING displayPowell();
98853: PPUSH
98854: CALL_OW 559
// uc_side := 0 ;
98858: LD_ADDR_OWVAR 20
98862: PUSH
98863: LD_INT 0
98865: ST_TO_ADDR
// uc_nation := 2 ;
98866: LD_ADDR_OWVAR 21
98870: PUSH
98871: LD_INT 2
98873: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
98874: LD_ADDR_OWVAR 37
98878: PUSH
98879: LD_INT 14
98881: ST_TO_ADDR
// vc_engine := engine_siberite ;
98882: LD_ADDR_OWVAR 39
98886: PUSH
98887: LD_INT 3
98889: ST_TO_ADDR
// vc_control := control_apeman ;
98890: LD_ADDR_OWVAR 38
98894: PUSH
98895: LD_INT 5
98897: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
98898: LD_ADDR_OWVAR 40
98902: PUSH
98903: LD_INT 29
98905: ST_TO_ADDR
// un := CreateVehicle ;
98906: LD_ADDR_VAR 0 2
98910: PUSH
98911: CALL_OW 45
98915: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98916: LD_VAR 0 2
98920: PPUSH
98921: LD_INT 1
98923: PPUSH
98924: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
98928: LD_INT 35
98930: PPUSH
98931: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
98935: LD_VAR 0 2
98939: PPUSH
98940: LD_INT 22
98942: PUSH
98943: LD_OWVAR 2
98947: PUSH
98948: EMPTY
98949: LIST
98950: LIST
98951: PPUSH
98952: CALL_OW 69
98956: PPUSH
98957: LD_VAR 0 2
98961: PPUSH
98962: CALL_OW 74
98966: PPUSH
98967: CALL_OW 115
// until IsDead ( un ) ;
98971: LD_VAR 0 2
98975: PPUSH
98976: CALL_OW 301
98980: IFFALSE 98928
// end ;
98982: PPOPN 2
98984: END
// every 0 0$1 trigger StreamModeActive and sStu do
98985: LD_EXP 107
98989: PUSH
98990: LD_EXP 146
98994: AND
98995: IFFALSE 99011
98997: GO 98999
98999: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99000: LD_STRING displayStucuk();
99002: PPUSH
99003: CALL_OW 559
// ResetFog ;
99007: CALL_OW 335
// end ;
99011: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99012: LD_EXP 107
99016: PUSH
99017: LD_EXP 139
99021: AND
99022: IFFALSE 99163
99024: GO 99026
99026: DISABLE
99027: LD_INT 0
99029: PPUSH
99030: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99031: LD_ADDR_VAR 0 2
99035: PUSH
99036: LD_INT 22
99038: PUSH
99039: LD_OWVAR 2
99043: PUSH
99044: EMPTY
99045: LIST
99046: LIST
99047: PUSH
99048: LD_INT 21
99050: PUSH
99051: LD_INT 1
99053: PUSH
99054: EMPTY
99055: LIST
99056: LIST
99057: PUSH
99058: EMPTY
99059: LIST
99060: LIST
99061: PPUSH
99062: CALL_OW 69
99066: ST_TO_ADDR
// if not tmp then
99067: LD_VAR 0 2
99071: NOT
99072: IFFALSE 99076
// exit ;
99074: GO 99163
// un := tmp [ rand ( 1 , tmp ) ] ;
99076: LD_ADDR_VAR 0 1
99080: PUSH
99081: LD_VAR 0 2
99085: PUSH
99086: LD_INT 1
99088: PPUSH
99089: LD_VAR 0 2
99093: PPUSH
99094: CALL_OW 12
99098: ARRAY
99099: ST_TO_ADDR
// SetSide ( un , 0 ) ;
99100: LD_VAR 0 1
99104: PPUSH
99105: LD_INT 0
99107: PPUSH
99108: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
99112: LD_VAR 0 1
99116: PPUSH
99117: LD_OWVAR 3
99121: PUSH
99122: LD_VAR 0 1
99126: DIFF
99127: PPUSH
99128: LD_VAR 0 1
99132: PPUSH
99133: CALL_OW 74
99137: PPUSH
99138: CALL_OW 115
// wait ( 0 0$20 ) ;
99142: LD_INT 700
99144: PPUSH
99145: CALL_OW 67
// SetSide ( un , your_side ) ;
99149: LD_VAR 0 1
99153: PPUSH
99154: LD_OWVAR 2
99158: PPUSH
99159: CALL_OW 235
// end ;
99163: PPOPN 2
99165: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
99166: LD_EXP 107
99170: PUSH
99171: LD_EXP 140
99175: AND
99176: IFFALSE 99282
99178: GO 99180
99180: DISABLE
99181: LD_INT 0
99183: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99184: LD_ADDR_VAR 0 1
99188: PUSH
99189: LD_INT 22
99191: PUSH
99192: LD_OWVAR 2
99196: PUSH
99197: EMPTY
99198: LIST
99199: LIST
99200: PUSH
99201: LD_INT 2
99203: PUSH
99204: LD_INT 30
99206: PUSH
99207: LD_INT 0
99209: PUSH
99210: EMPTY
99211: LIST
99212: LIST
99213: PUSH
99214: LD_INT 30
99216: PUSH
99217: LD_INT 1
99219: PUSH
99220: EMPTY
99221: LIST
99222: LIST
99223: PUSH
99224: EMPTY
99225: LIST
99226: LIST
99227: LIST
99228: PUSH
99229: EMPTY
99230: LIST
99231: LIST
99232: PPUSH
99233: CALL_OW 69
99237: ST_TO_ADDR
// if not depot then
99238: LD_VAR 0 1
99242: NOT
99243: IFFALSE 99247
// exit ;
99245: GO 99282
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
99247: LD_VAR 0 1
99251: PUSH
99252: LD_INT 1
99254: ARRAY
99255: PPUSH
99256: CALL_OW 250
99260: PPUSH
99261: LD_VAR 0 1
99265: PUSH
99266: LD_INT 1
99268: ARRAY
99269: PPUSH
99270: CALL_OW 251
99274: PPUSH
99275: LD_INT 70
99277: PPUSH
99278: CALL_OW 495
// end ;
99282: PPOPN 1
99284: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
99285: LD_EXP 107
99289: PUSH
99290: LD_EXP 141
99294: AND
99295: IFFALSE 99506
99297: GO 99299
99299: DISABLE
99300: LD_INT 0
99302: PPUSH
99303: PPUSH
99304: PPUSH
99305: PPUSH
99306: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99307: LD_ADDR_VAR 0 5
99311: PUSH
99312: LD_INT 22
99314: PUSH
99315: LD_OWVAR 2
99319: PUSH
99320: EMPTY
99321: LIST
99322: LIST
99323: PUSH
99324: LD_INT 21
99326: PUSH
99327: LD_INT 1
99329: PUSH
99330: EMPTY
99331: LIST
99332: LIST
99333: PUSH
99334: EMPTY
99335: LIST
99336: LIST
99337: PPUSH
99338: CALL_OW 69
99342: ST_TO_ADDR
// if not tmp then
99343: LD_VAR 0 5
99347: NOT
99348: IFFALSE 99352
// exit ;
99350: GO 99506
// for i in tmp do
99352: LD_ADDR_VAR 0 1
99356: PUSH
99357: LD_VAR 0 5
99361: PUSH
99362: FOR_IN
99363: IFFALSE 99504
// begin d := rand ( 0 , 5 ) ;
99365: LD_ADDR_VAR 0 4
99369: PUSH
99370: LD_INT 0
99372: PPUSH
99373: LD_INT 5
99375: PPUSH
99376: CALL_OW 12
99380: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
99381: LD_ADDR_VAR 0 2
99385: PUSH
99386: LD_VAR 0 1
99390: PPUSH
99391: CALL_OW 250
99395: PPUSH
99396: LD_VAR 0 4
99400: PPUSH
99401: LD_INT 3
99403: PPUSH
99404: LD_INT 12
99406: PPUSH
99407: CALL_OW 12
99411: PPUSH
99412: CALL_OW 272
99416: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
99417: LD_ADDR_VAR 0 3
99421: PUSH
99422: LD_VAR 0 1
99426: PPUSH
99427: CALL_OW 251
99431: PPUSH
99432: LD_VAR 0 4
99436: PPUSH
99437: LD_INT 3
99439: PPUSH
99440: LD_INT 12
99442: PPUSH
99443: CALL_OW 12
99447: PPUSH
99448: CALL_OW 273
99452: ST_TO_ADDR
// if ValidHex ( x , y ) then
99453: LD_VAR 0 2
99457: PPUSH
99458: LD_VAR 0 3
99462: PPUSH
99463: CALL_OW 488
99467: IFFALSE 99502
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
99469: LD_VAR 0 1
99473: PPUSH
99474: LD_VAR 0 2
99478: PPUSH
99479: LD_VAR 0 3
99483: PPUSH
99484: LD_INT 3
99486: PPUSH
99487: LD_INT 6
99489: PPUSH
99490: CALL_OW 12
99494: PPUSH
99495: LD_INT 1
99497: PPUSH
99498: CALL_OW 483
// end ;
99502: GO 99362
99504: POP
99505: POP
// end ;
99506: PPOPN 5
99508: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
99509: LD_EXP 107
99513: PUSH
99514: LD_EXP 142
99518: AND
99519: IFFALSE 99613
99521: GO 99523
99523: DISABLE
99524: LD_INT 0
99526: PPUSH
99527: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
99528: LD_ADDR_VAR 0 2
99532: PUSH
99533: LD_INT 22
99535: PUSH
99536: LD_OWVAR 2
99540: PUSH
99541: EMPTY
99542: LIST
99543: LIST
99544: PUSH
99545: LD_INT 32
99547: PUSH
99548: LD_INT 1
99550: PUSH
99551: EMPTY
99552: LIST
99553: LIST
99554: PUSH
99555: LD_INT 21
99557: PUSH
99558: LD_INT 2
99560: PUSH
99561: EMPTY
99562: LIST
99563: LIST
99564: PUSH
99565: EMPTY
99566: LIST
99567: LIST
99568: LIST
99569: PPUSH
99570: CALL_OW 69
99574: ST_TO_ADDR
// if not tmp then
99575: LD_VAR 0 2
99579: NOT
99580: IFFALSE 99584
// exit ;
99582: GO 99613
// for i in tmp do
99584: LD_ADDR_VAR 0 1
99588: PUSH
99589: LD_VAR 0 2
99593: PUSH
99594: FOR_IN
99595: IFFALSE 99611
// SetFuel ( i , 0 ) ;
99597: LD_VAR 0 1
99601: PPUSH
99602: LD_INT 0
99604: PPUSH
99605: CALL_OW 240
99609: GO 99594
99611: POP
99612: POP
// end ;
99613: PPOPN 2
99615: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
99616: LD_EXP 107
99620: PUSH
99621: LD_EXP 143
99625: AND
99626: IFFALSE 99692
99628: GO 99630
99630: DISABLE
99631: LD_INT 0
99633: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99634: LD_ADDR_VAR 0 1
99638: PUSH
99639: LD_INT 22
99641: PUSH
99642: LD_OWVAR 2
99646: PUSH
99647: EMPTY
99648: LIST
99649: LIST
99650: PUSH
99651: LD_INT 30
99653: PUSH
99654: LD_INT 29
99656: PUSH
99657: EMPTY
99658: LIST
99659: LIST
99660: PUSH
99661: EMPTY
99662: LIST
99663: LIST
99664: PPUSH
99665: CALL_OW 69
99669: ST_TO_ADDR
// if not tmp then
99670: LD_VAR 0 1
99674: NOT
99675: IFFALSE 99679
// exit ;
99677: GO 99692
// DestroyUnit ( tmp [ 1 ] ) ;
99679: LD_VAR 0 1
99683: PUSH
99684: LD_INT 1
99686: ARRAY
99687: PPUSH
99688: CALL_OW 65
// end ;
99692: PPOPN 1
99694: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
99695: LD_EXP 107
99699: PUSH
99700: LD_EXP 145
99704: AND
99705: IFFALSE 99834
99707: GO 99709
99709: DISABLE
99710: LD_INT 0
99712: PPUSH
// begin uc_side := 0 ;
99713: LD_ADDR_OWVAR 20
99717: PUSH
99718: LD_INT 0
99720: ST_TO_ADDR
// uc_nation := nation_arabian ;
99721: LD_ADDR_OWVAR 21
99725: PUSH
99726: LD_INT 2
99728: ST_TO_ADDR
// hc_gallery :=  ;
99729: LD_ADDR_OWVAR 33
99733: PUSH
99734: LD_STRING 
99736: ST_TO_ADDR
// hc_name :=  ;
99737: LD_ADDR_OWVAR 26
99741: PUSH
99742: LD_STRING 
99744: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
99745: LD_INT 1
99747: PPUSH
99748: LD_INT 11
99750: PPUSH
99751: LD_INT 10
99753: PPUSH
99754: CALL_OW 380
// un := CreateHuman ;
99758: LD_ADDR_VAR 0 1
99762: PUSH
99763: CALL_OW 44
99767: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99768: LD_VAR 0 1
99772: PPUSH
99773: LD_INT 1
99775: PPUSH
99776: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99780: LD_INT 35
99782: PPUSH
99783: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99787: LD_VAR 0 1
99791: PPUSH
99792: LD_INT 22
99794: PUSH
99795: LD_OWVAR 2
99799: PUSH
99800: EMPTY
99801: LIST
99802: LIST
99803: PPUSH
99804: CALL_OW 69
99808: PPUSH
99809: LD_VAR 0 1
99813: PPUSH
99814: CALL_OW 74
99818: PPUSH
99819: CALL_OW 115
// until IsDead ( un ) ;
99823: LD_VAR 0 1
99827: PPUSH
99828: CALL_OW 301
99832: IFFALSE 99780
// end ;
99834: PPOPN 1
99836: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
99837: LD_EXP 107
99841: PUSH
99842: LD_EXP 147
99846: AND
99847: IFFALSE 99859
99849: GO 99851
99851: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
99852: LD_STRING earthquake(getX(game), 0, 32)
99854: PPUSH
99855: CALL_OW 559
99859: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
99860: LD_EXP 107
99864: PUSH
99865: LD_EXP 148
99869: AND
99870: IFFALSE 99961
99872: GO 99874
99874: DISABLE
99875: LD_INT 0
99877: PPUSH
// begin enable ;
99878: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
99879: LD_ADDR_VAR 0 1
99883: PUSH
99884: LD_INT 22
99886: PUSH
99887: LD_OWVAR 2
99891: PUSH
99892: EMPTY
99893: LIST
99894: LIST
99895: PUSH
99896: LD_INT 21
99898: PUSH
99899: LD_INT 2
99901: PUSH
99902: EMPTY
99903: LIST
99904: LIST
99905: PUSH
99906: LD_INT 33
99908: PUSH
99909: LD_INT 3
99911: PUSH
99912: EMPTY
99913: LIST
99914: LIST
99915: PUSH
99916: EMPTY
99917: LIST
99918: LIST
99919: LIST
99920: PPUSH
99921: CALL_OW 69
99925: ST_TO_ADDR
// if not tmp then
99926: LD_VAR 0 1
99930: NOT
99931: IFFALSE 99935
// exit ;
99933: GO 99961
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
99935: LD_VAR 0 1
99939: PUSH
99940: LD_INT 1
99942: PPUSH
99943: LD_VAR 0 1
99947: PPUSH
99948: CALL_OW 12
99952: ARRAY
99953: PPUSH
99954: LD_INT 1
99956: PPUSH
99957: CALL_OW 234
// end ;
99961: PPOPN 1
99963: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
99964: LD_EXP 107
99968: PUSH
99969: LD_EXP 149
99973: AND
99974: IFFALSE 100115
99976: GO 99978
99978: DISABLE
99979: LD_INT 0
99981: PPUSH
99982: PPUSH
99983: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99984: LD_ADDR_VAR 0 3
99988: PUSH
99989: LD_INT 22
99991: PUSH
99992: LD_OWVAR 2
99996: PUSH
99997: EMPTY
99998: LIST
99999: LIST
100000: PUSH
100001: LD_INT 25
100003: PUSH
100004: LD_INT 1
100006: PUSH
100007: EMPTY
100008: LIST
100009: LIST
100010: PUSH
100011: EMPTY
100012: LIST
100013: LIST
100014: PPUSH
100015: CALL_OW 69
100019: ST_TO_ADDR
// if not tmp then
100020: LD_VAR 0 3
100024: NOT
100025: IFFALSE 100029
// exit ;
100027: GO 100115
// un := tmp [ rand ( 1 , tmp ) ] ;
100029: LD_ADDR_VAR 0 2
100033: PUSH
100034: LD_VAR 0 3
100038: PUSH
100039: LD_INT 1
100041: PPUSH
100042: LD_VAR 0 3
100046: PPUSH
100047: CALL_OW 12
100051: ARRAY
100052: ST_TO_ADDR
// if Crawls ( un ) then
100053: LD_VAR 0 2
100057: PPUSH
100058: CALL_OW 318
100062: IFFALSE 100073
// ComWalk ( un ) ;
100064: LD_VAR 0 2
100068: PPUSH
100069: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100073: LD_VAR 0 2
100077: PPUSH
100078: LD_INT 9
100080: PPUSH
100081: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100085: LD_INT 28
100087: PPUSH
100088: LD_OWVAR 2
100092: PPUSH
100093: LD_INT 2
100095: PPUSH
100096: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
100100: LD_INT 29
100102: PPUSH
100103: LD_OWVAR 2
100107: PPUSH
100108: LD_INT 2
100110: PPUSH
100111: CALL_OW 322
// end ;
100115: PPOPN 3
100117: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
100118: LD_EXP 107
100122: PUSH
100123: LD_EXP 150
100127: AND
100128: IFFALSE 100239
100130: GO 100132
100132: DISABLE
100133: LD_INT 0
100135: PPUSH
100136: PPUSH
100137: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100138: LD_ADDR_VAR 0 3
100142: PUSH
100143: LD_INT 22
100145: PUSH
100146: LD_OWVAR 2
100150: PUSH
100151: EMPTY
100152: LIST
100153: LIST
100154: PUSH
100155: LD_INT 25
100157: PUSH
100158: LD_INT 1
100160: PUSH
100161: EMPTY
100162: LIST
100163: LIST
100164: PUSH
100165: EMPTY
100166: LIST
100167: LIST
100168: PPUSH
100169: CALL_OW 69
100173: ST_TO_ADDR
// if not tmp then
100174: LD_VAR 0 3
100178: NOT
100179: IFFALSE 100183
// exit ;
100181: GO 100239
// un := tmp [ rand ( 1 , tmp ) ] ;
100183: LD_ADDR_VAR 0 2
100187: PUSH
100188: LD_VAR 0 3
100192: PUSH
100193: LD_INT 1
100195: PPUSH
100196: LD_VAR 0 3
100200: PPUSH
100201: CALL_OW 12
100205: ARRAY
100206: ST_TO_ADDR
// if Crawls ( un ) then
100207: LD_VAR 0 2
100211: PPUSH
100212: CALL_OW 318
100216: IFFALSE 100227
// ComWalk ( un ) ;
100218: LD_VAR 0 2
100222: PPUSH
100223: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100227: LD_VAR 0 2
100231: PPUSH
100232: LD_INT 8
100234: PPUSH
100235: CALL_OW 336
// end ;
100239: PPOPN 3
100241: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
100242: LD_EXP 107
100246: PUSH
100247: LD_EXP 151
100251: AND
100252: IFFALSE 100396
100254: GO 100256
100256: DISABLE
100257: LD_INT 0
100259: PPUSH
100260: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
100261: LD_ADDR_VAR 0 2
100265: PUSH
100266: LD_INT 22
100268: PUSH
100269: LD_OWVAR 2
100273: PUSH
100274: EMPTY
100275: LIST
100276: LIST
100277: PUSH
100278: LD_INT 21
100280: PUSH
100281: LD_INT 2
100283: PUSH
100284: EMPTY
100285: LIST
100286: LIST
100287: PUSH
100288: LD_INT 2
100290: PUSH
100291: LD_INT 34
100293: PUSH
100294: LD_INT 12
100296: PUSH
100297: EMPTY
100298: LIST
100299: LIST
100300: PUSH
100301: LD_INT 34
100303: PUSH
100304: LD_INT 51
100306: PUSH
100307: EMPTY
100308: LIST
100309: LIST
100310: PUSH
100311: LD_INT 34
100313: PUSH
100314: LD_INT 32
100316: PUSH
100317: EMPTY
100318: LIST
100319: LIST
100320: PUSH
100321: EMPTY
100322: LIST
100323: LIST
100324: LIST
100325: LIST
100326: PUSH
100327: EMPTY
100328: LIST
100329: LIST
100330: LIST
100331: PPUSH
100332: CALL_OW 69
100336: ST_TO_ADDR
// if not tmp then
100337: LD_VAR 0 2
100341: NOT
100342: IFFALSE 100346
// exit ;
100344: GO 100396
// for i in tmp do
100346: LD_ADDR_VAR 0 1
100350: PUSH
100351: LD_VAR 0 2
100355: PUSH
100356: FOR_IN
100357: IFFALSE 100394
// if GetCargo ( i , mat_artifact ) = 0 then
100359: LD_VAR 0 1
100363: PPUSH
100364: LD_INT 4
100366: PPUSH
100367: CALL_OW 289
100371: PUSH
100372: LD_INT 0
100374: EQUAL
100375: IFFALSE 100392
// SetCargo ( i , mat_siberit , 100 ) ;
100377: LD_VAR 0 1
100381: PPUSH
100382: LD_INT 3
100384: PPUSH
100385: LD_INT 100
100387: PPUSH
100388: CALL_OW 290
100392: GO 100356
100394: POP
100395: POP
// end ;
100396: PPOPN 2
100398: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
100399: LD_EXP 107
100403: PUSH
100404: LD_EXP 152
100408: AND
100409: IFFALSE 100592
100411: GO 100413
100413: DISABLE
100414: LD_INT 0
100416: PPUSH
100417: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100418: LD_ADDR_VAR 0 2
100422: PUSH
100423: LD_INT 22
100425: PUSH
100426: LD_OWVAR 2
100430: PUSH
100431: EMPTY
100432: LIST
100433: LIST
100434: PPUSH
100435: CALL_OW 69
100439: ST_TO_ADDR
// if not tmp then
100440: LD_VAR 0 2
100444: NOT
100445: IFFALSE 100449
// exit ;
100447: GO 100592
// for i := 1 to 2 do
100449: LD_ADDR_VAR 0 1
100453: PUSH
100454: DOUBLE
100455: LD_INT 1
100457: DEC
100458: ST_TO_ADDR
100459: LD_INT 2
100461: PUSH
100462: FOR_TO
100463: IFFALSE 100590
// begin uc_side := your_side ;
100465: LD_ADDR_OWVAR 20
100469: PUSH
100470: LD_OWVAR 2
100474: ST_TO_ADDR
// uc_nation := nation_american ;
100475: LD_ADDR_OWVAR 21
100479: PUSH
100480: LD_INT 1
100482: ST_TO_ADDR
// vc_chassis := us_morphling ;
100483: LD_ADDR_OWVAR 37
100487: PUSH
100488: LD_INT 5
100490: ST_TO_ADDR
// vc_engine := engine_siberite ;
100491: LD_ADDR_OWVAR 39
100495: PUSH
100496: LD_INT 3
100498: ST_TO_ADDR
// vc_control := control_computer ;
100499: LD_ADDR_OWVAR 38
100503: PUSH
100504: LD_INT 3
100506: ST_TO_ADDR
// vc_weapon := us_double_laser ;
100507: LD_ADDR_OWVAR 40
100511: PUSH
100512: LD_INT 10
100514: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
100515: LD_VAR 0 2
100519: PUSH
100520: LD_INT 1
100522: ARRAY
100523: PPUSH
100524: CALL_OW 310
100528: NOT
100529: IFFALSE 100576
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
100531: CALL_OW 45
100535: PPUSH
100536: LD_VAR 0 2
100540: PUSH
100541: LD_INT 1
100543: ARRAY
100544: PPUSH
100545: CALL_OW 250
100549: PPUSH
100550: LD_VAR 0 2
100554: PUSH
100555: LD_INT 1
100557: ARRAY
100558: PPUSH
100559: CALL_OW 251
100563: PPUSH
100564: LD_INT 12
100566: PPUSH
100567: LD_INT 1
100569: PPUSH
100570: CALL_OW 50
100574: GO 100588
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
100576: CALL_OW 45
100580: PPUSH
100581: LD_INT 1
100583: PPUSH
100584: CALL_OW 51
// end ;
100588: GO 100462
100590: POP
100591: POP
// end ;
100592: PPOPN 2
100594: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
100595: LD_EXP 107
100599: PUSH
100600: LD_EXP 153
100604: AND
100605: IFFALSE 100827
100607: GO 100609
100609: DISABLE
100610: LD_INT 0
100612: PPUSH
100613: PPUSH
100614: PPUSH
100615: PPUSH
100616: PPUSH
100617: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100618: LD_ADDR_VAR 0 6
100622: PUSH
100623: LD_INT 22
100625: PUSH
100626: LD_OWVAR 2
100630: PUSH
100631: EMPTY
100632: LIST
100633: LIST
100634: PUSH
100635: LD_INT 21
100637: PUSH
100638: LD_INT 1
100640: PUSH
100641: EMPTY
100642: LIST
100643: LIST
100644: PUSH
100645: LD_INT 3
100647: PUSH
100648: LD_INT 23
100650: PUSH
100651: LD_INT 0
100653: PUSH
100654: EMPTY
100655: LIST
100656: LIST
100657: PUSH
100658: EMPTY
100659: LIST
100660: LIST
100661: PUSH
100662: EMPTY
100663: LIST
100664: LIST
100665: LIST
100666: PPUSH
100667: CALL_OW 69
100671: ST_TO_ADDR
// if not tmp then
100672: LD_VAR 0 6
100676: NOT
100677: IFFALSE 100681
// exit ;
100679: GO 100827
// s1 := rand ( 1 , 4 ) ;
100681: LD_ADDR_VAR 0 2
100685: PUSH
100686: LD_INT 1
100688: PPUSH
100689: LD_INT 4
100691: PPUSH
100692: CALL_OW 12
100696: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
100697: LD_ADDR_VAR 0 4
100701: PUSH
100702: LD_VAR 0 6
100706: PUSH
100707: LD_INT 1
100709: ARRAY
100710: PPUSH
100711: LD_VAR 0 2
100715: PPUSH
100716: CALL_OW 259
100720: ST_TO_ADDR
// if s1 = 1 then
100721: LD_VAR 0 2
100725: PUSH
100726: LD_INT 1
100728: EQUAL
100729: IFFALSE 100749
// s2 := rand ( 2 , 4 ) else
100731: LD_ADDR_VAR 0 3
100735: PUSH
100736: LD_INT 2
100738: PPUSH
100739: LD_INT 4
100741: PPUSH
100742: CALL_OW 12
100746: ST_TO_ADDR
100747: GO 100757
// s2 := 1 ;
100749: LD_ADDR_VAR 0 3
100753: PUSH
100754: LD_INT 1
100756: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
100757: LD_ADDR_VAR 0 5
100761: PUSH
100762: LD_VAR 0 6
100766: PUSH
100767: LD_INT 1
100769: ARRAY
100770: PPUSH
100771: LD_VAR 0 3
100775: PPUSH
100776: CALL_OW 259
100780: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
100781: LD_VAR 0 6
100785: PUSH
100786: LD_INT 1
100788: ARRAY
100789: PPUSH
100790: LD_VAR 0 2
100794: PPUSH
100795: LD_VAR 0 5
100799: PPUSH
100800: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
100804: LD_VAR 0 6
100808: PUSH
100809: LD_INT 1
100811: ARRAY
100812: PPUSH
100813: LD_VAR 0 3
100817: PPUSH
100818: LD_VAR 0 4
100822: PPUSH
100823: CALL_OW 237
// end ;
100827: PPOPN 6
100829: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
100830: LD_EXP 107
100834: PUSH
100835: LD_EXP 154
100839: AND
100840: IFFALSE 100919
100842: GO 100844
100844: DISABLE
100845: LD_INT 0
100847: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
100848: LD_ADDR_VAR 0 1
100852: PUSH
100853: LD_INT 22
100855: PUSH
100856: LD_OWVAR 2
100860: PUSH
100861: EMPTY
100862: LIST
100863: LIST
100864: PUSH
100865: LD_INT 30
100867: PUSH
100868: LD_INT 3
100870: PUSH
100871: EMPTY
100872: LIST
100873: LIST
100874: PUSH
100875: EMPTY
100876: LIST
100877: LIST
100878: PPUSH
100879: CALL_OW 69
100883: ST_TO_ADDR
// if not tmp then
100884: LD_VAR 0 1
100888: NOT
100889: IFFALSE 100893
// exit ;
100891: GO 100919
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100893: LD_VAR 0 1
100897: PUSH
100898: LD_INT 1
100900: PPUSH
100901: LD_VAR 0 1
100905: PPUSH
100906: CALL_OW 12
100910: ARRAY
100911: PPUSH
100912: LD_INT 1
100914: PPUSH
100915: CALL_OW 234
// end ;
100919: PPOPN 1
100921: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
100922: LD_EXP 107
100926: PUSH
100927: LD_EXP 155
100931: AND
100932: IFFALSE 101044
100934: GO 100936
100936: DISABLE
100937: LD_INT 0
100939: PPUSH
100940: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
100941: LD_ADDR_VAR 0 2
100945: PUSH
100946: LD_INT 22
100948: PUSH
100949: LD_OWVAR 2
100953: PUSH
100954: EMPTY
100955: LIST
100956: LIST
100957: PUSH
100958: LD_INT 2
100960: PUSH
100961: LD_INT 30
100963: PUSH
100964: LD_INT 27
100966: PUSH
100967: EMPTY
100968: LIST
100969: LIST
100970: PUSH
100971: LD_INT 30
100973: PUSH
100974: LD_INT 26
100976: PUSH
100977: EMPTY
100978: LIST
100979: LIST
100980: PUSH
100981: LD_INT 30
100983: PUSH
100984: LD_INT 28
100986: PUSH
100987: EMPTY
100988: LIST
100989: LIST
100990: PUSH
100991: EMPTY
100992: LIST
100993: LIST
100994: LIST
100995: LIST
100996: PUSH
100997: EMPTY
100998: LIST
100999: LIST
101000: PPUSH
101001: CALL_OW 69
101005: ST_TO_ADDR
// if not tmp then
101006: LD_VAR 0 2
101010: NOT
101011: IFFALSE 101015
// exit ;
101013: GO 101044
// for i in tmp do
101015: LD_ADDR_VAR 0 1
101019: PUSH
101020: LD_VAR 0 2
101024: PUSH
101025: FOR_IN
101026: IFFALSE 101042
// SetLives ( i , 1 ) ;
101028: LD_VAR 0 1
101032: PPUSH
101033: LD_INT 1
101035: PPUSH
101036: CALL_OW 234
101040: GO 101025
101042: POP
101043: POP
// end ;
101044: PPOPN 2
101046: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101047: LD_EXP 107
101051: PUSH
101052: LD_EXP 156
101056: AND
101057: IFFALSE 101344
101059: GO 101061
101061: DISABLE
101062: LD_INT 0
101064: PPUSH
101065: PPUSH
101066: PPUSH
// begin i := rand ( 1 , 7 ) ;
101067: LD_ADDR_VAR 0 1
101071: PUSH
101072: LD_INT 1
101074: PPUSH
101075: LD_INT 7
101077: PPUSH
101078: CALL_OW 12
101082: ST_TO_ADDR
// case i of 1 :
101083: LD_VAR 0 1
101087: PUSH
101088: LD_INT 1
101090: DOUBLE
101091: EQUAL
101092: IFTRUE 101096
101094: GO 101106
101096: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
101097: LD_STRING earthquake(getX(game), 0, 32)
101099: PPUSH
101100: CALL_OW 559
101104: GO 101344
101106: LD_INT 2
101108: DOUBLE
101109: EQUAL
101110: IFTRUE 101114
101112: GO 101128
101114: POP
// begin ToLua ( displayStucuk(); ) ;
101115: LD_STRING displayStucuk();
101117: PPUSH
101118: CALL_OW 559
// ResetFog ;
101122: CALL_OW 335
// end ; 3 :
101126: GO 101344
101128: LD_INT 3
101130: DOUBLE
101131: EQUAL
101132: IFTRUE 101136
101134: GO 101240
101136: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101137: LD_ADDR_VAR 0 2
101141: PUSH
101142: LD_INT 22
101144: PUSH
101145: LD_OWVAR 2
101149: PUSH
101150: EMPTY
101151: LIST
101152: LIST
101153: PUSH
101154: LD_INT 25
101156: PUSH
101157: LD_INT 1
101159: PUSH
101160: EMPTY
101161: LIST
101162: LIST
101163: PUSH
101164: EMPTY
101165: LIST
101166: LIST
101167: PPUSH
101168: CALL_OW 69
101172: ST_TO_ADDR
// if not tmp then
101173: LD_VAR 0 2
101177: NOT
101178: IFFALSE 101182
// exit ;
101180: GO 101344
// un := tmp [ rand ( 1 , tmp ) ] ;
101182: LD_ADDR_VAR 0 3
101186: PUSH
101187: LD_VAR 0 2
101191: PUSH
101192: LD_INT 1
101194: PPUSH
101195: LD_VAR 0 2
101199: PPUSH
101200: CALL_OW 12
101204: ARRAY
101205: ST_TO_ADDR
// if Crawls ( un ) then
101206: LD_VAR 0 3
101210: PPUSH
101211: CALL_OW 318
101215: IFFALSE 101226
// ComWalk ( un ) ;
101217: LD_VAR 0 3
101221: PPUSH
101222: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101226: LD_VAR 0 3
101230: PPUSH
101231: LD_INT 8
101233: PPUSH
101234: CALL_OW 336
// end ; 4 :
101238: GO 101344
101240: LD_INT 4
101242: DOUBLE
101243: EQUAL
101244: IFTRUE 101248
101246: GO 101322
101248: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101249: LD_ADDR_VAR 0 2
101253: PUSH
101254: LD_INT 22
101256: PUSH
101257: LD_OWVAR 2
101261: PUSH
101262: EMPTY
101263: LIST
101264: LIST
101265: PUSH
101266: LD_INT 30
101268: PUSH
101269: LD_INT 29
101271: PUSH
101272: EMPTY
101273: LIST
101274: LIST
101275: PUSH
101276: EMPTY
101277: LIST
101278: LIST
101279: PPUSH
101280: CALL_OW 69
101284: ST_TO_ADDR
// if not tmp then
101285: LD_VAR 0 2
101289: NOT
101290: IFFALSE 101294
// exit ;
101292: GO 101344
// CenterNowOnUnits ( tmp [ 1 ] ) ;
101294: LD_VAR 0 2
101298: PUSH
101299: LD_INT 1
101301: ARRAY
101302: PPUSH
101303: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
101307: LD_VAR 0 2
101311: PUSH
101312: LD_INT 1
101314: ARRAY
101315: PPUSH
101316: CALL_OW 65
// end ; 5 .. 7 :
101320: GO 101344
101322: LD_INT 5
101324: DOUBLE
101325: GREATEREQUAL
101326: IFFALSE 101334
101328: LD_INT 7
101330: DOUBLE
101331: LESSEQUAL
101332: IFTRUE 101336
101334: GO 101343
101336: POP
// StreamSibBomb ; end ;
101337: CALL 97581 0 0
101341: GO 101344
101343: POP
// end ;
101344: PPOPN 3
101346: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
101347: LD_EXP 107
101351: PUSH
101352: LD_EXP 157
101356: AND
101357: IFFALSE 101513
101359: GO 101361
101361: DISABLE
101362: LD_INT 0
101364: PPUSH
101365: PPUSH
101366: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
101367: LD_ADDR_VAR 0 2
101371: PUSH
101372: LD_INT 81
101374: PUSH
101375: LD_OWVAR 2
101379: PUSH
101380: EMPTY
101381: LIST
101382: LIST
101383: PUSH
101384: LD_INT 2
101386: PUSH
101387: LD_INT 21
101389: PUSH
101390: LD_INT 1
101392: PUSH
101393: EMPTY
101394: LIST
101395: LIST
101396: PUSH
101397: LD_INT 21
101399: PUSH
101400: LD_INT 2
101402: PUSH
101403: EMPTY
101404: LIST
101405: LIST
101406: PUSH
101407: EMPTY
101408: LIST
101409: LIST
101410: LIST
101411: PUSH
101412: EMPTY
101413: LIST
101414: LIST
101415: PPUSH
101416: CALL_OW 69
101420: ST_TO_ADDR
// if not tmp then
101421: LD_VAR 0 2
101425: NOT
101426: IFFALSE 101430
// exit ;
101428: GO 101513
// p := 0 ;
101430: LD_ADDR_VAR 0 3
101434: PUSH
101435: LD_INT 0
101437: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101438: LD_INT 35
101440: PPUSH
101441: CALL_OW 67
// p := p + 1 ;
101445: LD_ADDR_VAR 0 3
101449: PUSH
101450: LD_VAR 0 3
101454: PUSH
101455: LD_INT 1
101457: PLUS
101458: ST_TO_ADDR
// for i in tmp do
101459: LD_ADDR_VAR 0 1
101463: PUSH
101464: LD_VAR 0 2
101468: PUSH
101469: FOR_IN
101470: IFFALSE 101501
// if GetLives ( i ) < 1000 then
101472: LD_VAR 0 1
101476: PPUSH
101477: CALL_OW 256
101481: PUSH
101482: LD_INT 1000
101484: LESS
101485: IFFALSE 101499
// SetLives ( i , 1000 ) ;
101487: LD_VAR 0 1
101491: PPUSH
101492: LD_INT 1000
101494: PPUSH
101495: CALL_OW 234
101499: GO 101469
101501: POP
101502: POP
// until p > 20 ;
101503: LD_VAR 0 3
101507: PUSH
101508: LD_INT 20
101510: GREATER
101511: IFFALSE 101438
// end ;
101513: PPOPN 3
101515: END
// every 0 0$1 trigger StreamModeActive and sTime do
101516: LD_EXP 107
101520: PUSH
101521: LD_EXP 158
101525: AND
101526: IFFALSE 101561
101528: GO 101530
101530: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
101531: LD_INT 28
101533: PPUSH
101534: LD_OWVAR 2
101538: PPUSH
101539: LD_INT 2
101541: PPUSH
101542: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
101546: LD_INT 30
101548: PPUSH
101549: LD_OWVAR 2
101553: PPUSH
101554: LD_INT 2
101556: PPUSH
101557: CALL_OW 322
// end ;
101561: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
101562: LD_EXP 107
101566: PUSH
101567: LD_EXP 159
101571: AND
101572: IFFALSE 101693
101574: GO 101576
101576: DISABLE
101577: LD_INT 0
101579: PPUSH
101580: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101581: LD_ADDR_VAR 0 2
101585: PUSH
101586: LD_INT 22
101588: PUSH
101589: LD_OWVAR 2
101593: PUSH
101594: EMPTY
101595: LIST
101596: LIST
101597: PUSH
101598: LD_INT 21
101600: PUSH
101601: LD_INT 1
101603: PUSH
101604: EMPTY
101605: LIST
101606: LIST
101607: PUSH
101608: LD_INT 3
101610: PUSH
101611: LD_INT 23
101613: PUSH
101614: LD_INT 0
101616: PUSH
101617: EMPTY
101618: LIST
101619: LIST
101620: PUSH
101621: EMPTY
101622: LIST
101623: LIST
101624: PUSH
101625: EMPTY
101626: LIST
101627: LIST
101628: LIST
101629: PPUSH
101630: CALL_OW 69
101634: ST_TO_ADDR
// if not tmp then
101635: LD_VAR 0 2
101639: NOT
101640: IFFALSE 101644
// exit ;
101642: GO 101693
// for i in tmp do
101644: LD_ADDR_VAR 0 1
101648: PUSH
101649: LD_VAR 0 2
101653: PUSH
101654: FOR_IN
101655: IFFALSE 101691
// begin if Crawls ( i ) then
101657: LD_VAR 0 1
101661: PPUSH
101662: CALL_OW 318
101666: IFFALSE 101677
// ComWalk ( i ) ;
101668: LD_VAR 0 1
101672: PPUSH
101673: CALL_OW 138
// SetClass ( i , 2 ) ;
101677: LD_VAR 0 1
101681: PPUSH
101682: LD_INT 2
101684: PPUSH
101685: CALL_OW 336
// end ;
101689: GO 101654
101691: POP
101692: POP
// end ;
101693: PPOPN 2
101695: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
101696: LD_EXP 107
101700: PUSH
101701: LD_EXP 160
101705: AND
101706: IFFALSE 101994
101708: GO 101710
101710: DISABLE
101711: LD_INT 0
101713: PPUSH
101714: PPUSH
101715: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
101716: LD_OWVAR 2
101720: PPUSH
101721: LD_INT 9
101723: PPUSH
101724: LD_INT 1
101726: PPUSH
101727: LD_INT 1
101729: PPUSH
101730: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
101734: LD_INT 9
101736: PPUSH
101737: LD_OWVAR 2
101741: PPUSH
101742: CALL_OW 343
// uc_side := 9 ;
101746: LD_ADDR_OWVAR 20
101750: PUSH
101751: LD_INT 9
101753: ST_TO_ADDR
// uc_nation := 2 ;
101754: LD_ADDR_OWVAR 21
101758: PUSH
101759: LD_INT 2
101761: ST_TO_ADDR
// hc_name := Dark Warrior ;
101762: LD_ADDR_OWVAR 26
101766: PUSH
101767: LD_STRING Dark Warrior
101769: ST_TO_ADDR
// hc_gallery :=  ;
101770: LD_ADDR_OWVAR 33
101774: PUSH
101775: LD_STRING 
101777: ST_TO_ADDR
// hc_noskilllimit := true ;
101778: LD_ADDR_OWVAR 76
101782: PUSH
101783: LD_INT 1
101785: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
101786: LD_ADDR_OWVAR 31
101790: PUSH
101791: LD_INT 30
101793: PUSH
101794: LD_INT 30
101796: PUSH
101797: LD_INT 30
101799: PUSH
101800: LD_INT 30
101802: PUSH
101803: EMPTY
101804: LIST
101805: LIST
101806: LIST
101807: LIST
101808: ST_TO_ADDR
// un := CreateHuman ;
101809: LD_ADDR_VAR 0 3
101813: PUSH
101814: CALL_OW 44
101818: ST_TO_ADDR
// hc_noskilllimit := false ;
101819: LD_ADDR_OWVAR 76
101823: PUSH
101824: LD_INT 0
101826: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101827: LD_VAR 0 3
101831: PPUSH
101832: LD_INT 1
101834: PPUSH
101835: CALL_OW 51
// ToLua ( playRanger() ) ;
101839: LD_STRING playRanger()
101841: PPUSH
101842: CALL_OW 559
// p := 0 ;
101846: LD_ADDR_VAR 0 2
101850: PUSH
101851: LD_INT 0
101853: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101854: LD_INT 35
101856: PPUSH
101857: CALL_OW 67
// p := p + 1 ;
101861: LD_ADDR_VAR 0 2
101865: PUSH
101866: LD_VAR 0 2
101870: PUSH
101871: LD_INT 1
101873: PLUS
101874: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
101875: LD_VAR 0 3
101879: PPUSH
101880: CALL_OW 256
101884: PUSH
101885: LD_INT 1000
101887: LESS
101888: IFFALSE 101902
// SetLives ( un , 1000 ) ;
101890: LD_VAR 0 3
101894: PPUSH
101895: LD_INT 1000
101897: PPUSH
101898: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
101902: LD_VAR 0 3
101906: PPUSH
101907: LD_INT 81
101909: PUSH
101910: LD_OWVAR 2
101914: PUSH
101915: EMPTY
101916: LIST
101917: LIST
101918: PUSH
101919: LD_INT 91
101921: PUSH
101922: LD_VAR 0 3
101926: PUSH
101927: LD_INT 30
101929: PUSH
101930: EMPTY
101931: LIST
101932: LIST
101933: LIST
101934: PUSH
101935: EMPTY
101936: LIST
101937: LIST
101938: PPUSH
101939: CALL_OW 69
101943: PPUSH
101944: LD_VAR 0 3
101948: PPUSH
101949: CALL_OW 74
101953: PPUSH
101954: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
101958: LD_VAR 0 2
101962: PUSH
101963: LD_INT 80
101965: GREATER
101966: PUSH
101967: LD_VAR 0 3
101971: PPUSH
101972: CALL_OW 301
101976: OR
101977: IFFALSE 101854
// if un then
101979: LD_VAR 0 3
101983: IFFALSE 101994
// RemoveUnit ( un ) ;
101985: LD_VAR 0 3
101989: PPUSH
101990: CALL_OW 64
// end ;
101994: PPOPN 3
101996: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
101997: LD_EXP 161
102001: IFFALSE 102117
102003: GO 102005
102005: DISABLE
102006: LD_INT 0
102008: PPUSH
102009: PPUSH
102010: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102011: LD_ADDR_VAR 0 2
102015: PUSH
102016: LD_INT 81
102018: PUSH
102019: LD_OWVAR 2
102023: PUSH
102024: EMPTY
102025: LIST
102026: LIST
102027: PUSH
102028: LD_INT 21
102030: PUSH
102031: LD_INT 1
102033: PUSH
102034: EMPTY
102035: LIST
102036: LIST
102037: PUSH
102038: EMPTY
102039: LIST
102040: LIST
102041: PPUSH
102042: CALL_OW 69
102046: ST_TO_ADDR
// ToLua ( playComputer() ) ;
102047: LD_STRING playComputer()
102049: PPUSH
102050: CALL_OW 559
// if not tmp then
102054: LD_VAR 0 2
102058: NOT
102059: IFFALSE 102063
// exit ;
102061: GO 102117
// for i in tmp do
102063: LD_ADDR_VAR 0 1
102067: PUSH
102068: LD_VAR 0 2
102072: PUSH
102073: FOR_IN
102074: IFFALSE 102115
// for j := 1 to 4 do
102076: LD_ADDR_VAR 0 3
102080: PUSH
102081: DOUBLE
102082: LD_INT 1
102084: DEC
102085: ST_TO_ADDR
102086: LD_INT 4
102088: PUSH
102089: FOR_TO
102090: IFFALSE 102111
// SetSkill ( i , j , 10 ) ;
102092: LD_VAR 0 1
102096: PPUSH
102097: LD_VAR 0 3
102101: PPUSH
102102: LD_INT 10
102104: PPUSH
102105: CALL_OW 237
102109: GO 102089
102111: POP
102112: POP
102113: GO 102073
102115: POP
102116: POP
// end ;
102117: PPOPN 3
102119: END
// every 0 0$1 trigger s30 do var i , tmp ;
102120: LD_EXP 162
102124: IFFALSE 102193
102126: GO 102128
102128: DISABLE
102129: LD_INT 0
102131: PPUSH
102132: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102133: LD_ADDR_VAR 0 2
102137: PUSH
102138: LD_INT 22
102140: PUSH
102141: LD_OWVAR 2
102145: PUSH
102146: EMPTY
102147: LIST
102148: LIST
102149: PPUSH
102150: CALL_OW 69
102154: ST_TO_ADDR
// if not tmp then
102155: LD_VAR 0 2
102159: NOT
102160: IFFALSE 102164
// exit ;
102162: GO 102193
// for i in tmp do
102164: LD_ADDR_VAR 0 1
102168: PUSH
102169: LD_VAR 0 2
102173: PUSH
102174: FOR_IN
102175: IFFALSE 102191
// SetLives ( i , 300 ) ;
102177: LD_VAR 0 1
102181: PPUSH
102182: LD_INT 300
102184: PPUSH
102185: CALL_OW 234
102189: GO 102174
102191: POP
102192: POP
// end ;
102193: PPOPN 2
102195: END
// every 0 0$1 trigger s60 do var i , tmp ;
102196: LD_EXP 163
102200: IFFALSE 102269
102202: GO 102204
102204: DISABLE
102205: LD_INT 0
102207: PPUSH
102208: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102209: LD_ADDR_VAR 0 2
102213: PUSH
102214: LD_INT 22
102216: PUSH
102217: LD_OWVAR 2
102221: PUSH
102222: EMPTY
102223: LIST
102224: LIST
102225: PPUSH
102226: CALL_OW 69
102230: ST_TO_ADDR
// if not tmp then
102231: LD_VAR 0 2
102235: NOT
102236: IFFALSE 102240
// exit ;
102238: GO 102269
// for i in tmp do
102240: LD_ADDR_VAR 0 1
102244: PUSH
102245: LD_VAR 0 2
102249: PUSH
102250: FOR_IN
102251: IFFALSE 102267
// SetLives ( i , 600 ) ;
102253: LD_VAR 0 1
102257: PPUSH
102258: LD_INT 600
102260: PPUSH
102261: CALL_OW 234
102265: GO 102250
102267: POP
102268: POP
// end ;
102269: PPOPN 2
102271: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
102272: LD_INT 0
102274: PPUSH
// case cmd of 301 :
102275: LD_VAR 0 1
102279: PUSH
102280: LD_INT 301
102282: DOUBLE
102283: EQUAL
102284: IFTRUE 102288
102286: GO 102320
102288: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
102289: LD_VAR 0 6
102293: PPUSH
102294: LD_VAR 0 7
102298: PPUSH
102299: LD_VAR 0 8
102303: PPUSH
102304: LD_VAR 0 4
102308: PPUSH
102309: LD_VAR 0 5
102313: PPUSH
102314: CALL 103529 0 5
102318: GO 102441
102320: LD_INT 302
102322: DOUBLE
102323: EQUAL
102324: IFTRUE 102328
102326: GO 102365
102328: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
102329: LD_VAR 0 6
102333: PPUSH
102334: LD_VAR 0 7
102338: PPUSH
102339: LD_VAR 0 8
102343: PPUSH
102344: LD_VAR 0 9
102348: PPUSH
102349: LD_VAR 0 4
102353: PPUSH
102354: LD_VAR 0 5
102358: PPUSH
102359: CALL 103620 0 6
102363: GO 102441
102365: LD_INT 303
102367: DOUBLE
102368: EQUAL
102369: IFTRUE 102373
102371: GO 102410
102373: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
102374: LD_VAR 0 6
102378: PPUSH
102379: LD_VAR 0 7
102383: PPUSH
102384: LD_VAR 0 8
102388: PPUSH
102389: LD_VAR 0 9
102393: PPUSH
102394: LD_VAR 0 4
102398: PPUSH
102399: LD_VAR 0 5
102403: PPUSH
102404: CALL 102446 0 6
102408: GO 102441
102410: LD_INT 304
102412: DOUBLE
102413: EQUAL
102414: IFTRUE 102418
102416: GO 102440
102418: POP
// hHackTeleport ( unit , x , y ) ; end ;
102419: LD_VAR 0 2
102423: PPUSH
102424: LD_VAR 0 4
102428: PPUSH
102429: LD_VAR 0 5
102433: PPUSH
102434: CALL 104213 0 3
102438: GO 102441
102440: POP
// end ;
102441: LD_VAR 0 12
102445: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
102446: LD_INT 0
102448: PPUSH
102449: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
102450: LD_VAR 0 1
102454: PUSH
102455: LD_INT 1
102457: LESS
102458: PUSH
102459: LD_VAR 0 1
102463: PUSH
102464: LD_INT 3
102466: GREATER
102467: OR
102468: PUSH
102469: LD_VAR 0 5
102473: PPUSH
102474: LD_VAR 0 6
102478: PPUSH
102479: CALL_OW 428
102483: OR
102484: IFFALSE 102488
// exit ;
102486: GO 103216
// uc_side := your_side ;
102488: LD_ADDR_OWVAR 20
102492: PUSH
102493: LD_OWVAR 2
102497: ST_TO_ADDR
// uc_nation := nation ;
102498: LD_ADDR_OWVAR 21
102502: PUSH
102503: LD_VAR 0 1
102507: ST_TO_ADDR
// bc_level = 1 ;
102508: LD_ADDR_OWVAR 43
102512: PUSH
102513: LD_INT 1
102515: ST_TO_ADDR
// case btype of 1 :
102516: LD_VAR 0 2
102520: PUSH
102521: LD_INT 1
102523: DOUBLE
102524: EQUAL
102525: IFTRUE 102529
102527: GO 102540
102529: POP
// bc_type := b_depot ; 2 :
102530: LD_ADDR_OWVAR 42
102534: PUSH
102535: LD_INT 0
102537: ST_TO_ADDR
102538: GO 103160
102540: LD_INT 2
102542: DOUBLE
102543: EQUAL
102544: IFTRUE 102548
102546: GO 102559
102548: POP
// bc_type := b_warehouse ; 3 :
102549: LD_ADDR_OWVAR 42
102553: PUSH
102554: LD_INT 1
102556: ST_TO_ADDR
102557: GO 103160
102559: LD_INT 3
102561: DOUBLE
102562: EQUAL
102563: IFTRUE 102567
102565: GO 102578
102567: POP
// bc_type := b_lab ; 4 .. 9 :
102568: LD_ADDR_OWVAR 42
102572: PUSH
102573: LD_INT 6
102575: ST_TO_ADDR
102576: GO 103160
102578: LD_INT 4
102580: DOUBLE
102581: GREATEREQUAL
102582: IFFALSE 102590
102584: LD_INT 9
102586: DOUBLE
102587: LESSEQUAL
102588: IFTRUE 102592
102590: GO 102652
102592: POP
// begin bc_type := b_lab_half ;
102593: LD_ADDR_OWVAR 42
102597: PUSH
102598: LD_INT 7
102600: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
102601: LD_ADDR_OWVAR 44
102605: PUSH
102606: LD_INT 10
102608: PUSH
102609: LD_INT 11
102611: PUSH
102612: LD_INT 12
102614: PUSH
102615: LD_INT 15
102617: PUSH
102618: LD_INT 14
102620: PUSH
102621: LD_INT 13
102623: PUSH
102624: EMPTY
102625: LIST
102626: LIST
102627: LIST
102628: LIST
102629: LIST
102630: LIST
102631: PUSH
102632: LD_VAR 0 2
102636: PUSH
102637: LD_INT 3
102639: MINUS
102640: ARRAY
102641: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
102642: LD_ADDR_OWVAR 45
102646: PUSH
102647: LD_INT 9
102649: ST_TO_ADDR
// end ; 10 .. 13 :
102650: GO 103160
102652: LD_INT 10
102654: DOUBLE
102655: GREATEREQUAL
102656: IFFALSE 102664
102658: LD_INT 13
102660: DOUBLE
102661: LESSEQUAL
102662: IFTRUE 102666
102664: GO 102743
102666: POP
// begin bc_type := b_lab_full ;
102667: LD_ADDR_OWVAR 42
102671: PUSH
102672: LD_INT 8
102674: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
102675: LD_ADDR_OWVAR 44
102679: PUSH
102680: LD_INT 10
102682: PUSH
102683: LD_INT 12
102685: PUSH
102686: LD_INT 14
102688: PUSH
102689: LD_INT 13
102691: PUSH
102692: EMPTY
102693: LIST
102694: LIST
102695: LIST
102696: LIST
102697: PUSH
102698: LD_VAR 0 2
102702: PUSH
102703: LD_INT 9
102705: MINUS
102706: ARRAY
102707: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
102708: LD_ADDR_OWVAR 45
102712: PUSH
102713: LD_INT 11
102715: PUSH
102716: LD_INT 15
102718: PUSH
102719: LD_INT 12
102721: PUSH
102722: LD_INT 15
102724: PUSH
102725: EMPTY
102726: LIST
102727: LIST
102728: LIST
102729: LIST
102730: PUSH
102731: LD_VAR 0 2
102735: PUSH
102736: LD_INT 9
102738: MINUS
102739: ARRAY
102740: ST_TO_ADDR
// end ; 14 :
102741: GO 103160
102743: LD_INT 14
102745: DOUBLE
102746: EQUAL
102747: IFTRUE 102751
102749: GO 102762
102751: POP
// bc_type := b_workshop ; 15 :
102752: LD_ADDR_OWVAR 42
102756: PUSH
102757: LD_INT 2
102759: ST_TO_ADDR
102760: GO 103160
102762: LD_INT 15
102764: DOUBLE
102765: EQUAL
102766: IFTRUE 102770
102768: GO 102781
102770: POP
// bc_type := b_factory ; 16 :
102771: LD_ADDR_OWVAR 42
102775: PUSH
102776: LD_INT 3
102778: ST_TO_ADDR
102779: GO 103160
102781: LD_INT 16
102783: DOUBLE
102784: EQUAL
102785: IFTRUE 102789
102787: GO 102800
102789: POP
// bc_type := b_ext_gun ; 17 :
102790: LD_ADDR_OWVAR 42
102794: PUSH
102795: LD_INT 17
102797: ST_TO_ADDR
102798: GO 103160
102800: LD_INT 17
102802: DOUBLE
102803: EQUAL
102804: IFTRUE 102808
102806: GO 102836
102808: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
102809: LD_ADDR_OWVAR 42
102813: PUSH
102814: LD_INT 19
102816: PUSH
102817: LD_INT 23
102819: PUSH
102820: LD_INT 19
102822: PUSH
102823: EMPTY
102824: LIST
102825: LIST
102826: LIST
102827: PUSH
102828: LD_VAR 0 1
102832: ARRAY
102833: ST_TO_ADDR
102834: GO 103160
102836: LD_INT 18
102838: DOUBLE
102839: EQUAL
102840: IFTRUE 102844
102842: GO 102855
102844: POP
// bc_type := b_ext_radar ; 19 :
102845: LD_ADDR_OWVAR 42
102849: PUSH
102850: LD_INT 20
102852: ST_TO_ADDR
102853: GO 103160
102855: LD_INT 19
102857: DOUBLE
102858: EQUAL
102859: IFTRUE 102863
102861: GO 102874
102863: POP
// bc_type := b_ext_radio ; 20 :
102864: LD_ADDR_OWVAR 42
102868: PUSH
102869: LD_INT 22
102871: ST_TO_ADDR
102872: GO 103160
102874: LD_INT 20
102876: DOUBLE
102877: EQUAL
102878: IFTRUE 102882
102880: GO 102893
102882: POP
// bc_type := b_ext_siberium ; 21 :
102883: LD_ADDR_OWVAR 42
102887: PUSH
102888: LD_INT 21
102890: ST_TO_ADDR
102891: GO 103160
102893: LD_INT 21
102895: DOUBLE
102896: EQUAL
102897: IFTRUE 102901
102899: GO 102912
102901: POP
// bc_type := b_ext_computer ; 22 :
102902: LD_ADDR_OWVAR 42
102906: PUSH
102907: LD_INT 24
102909: ST_TO_ADDR
102910: GO 103160
102912: LD_INT 22
102914: DOUBLE
102915: EQUAL
102916: IFTRUE 102920
102918: GO 102931
102920: POP
// bc_type := b_ext_track ; 23 :
102921: LD_ADDR_OWVAR 42
102925: PUSH
102926: LD_INT 16
102928: ST_TO_ADDR
102929: GO 103160
102931: LD_INT 23
102933: DOUBLE
102934: EQUAL
102935: IFTRUE 102939
102937: GO 102950
102939: POP
// bc_type := b_ext_laser ; 24 :
102940: LD_ADDR_OWVAR 42
102944: PUSH
102945: LD_INT 25
102947: ST_TO_ADDR
102948: GO 103160
102950: LD_INT 24
102952: DOUBLE
102953: EQUAL
102954: IFTRUE 102958
102956: GO 102969
102958: POP
// bc_type := b_control_tower ; 25 :
102959: LD_ADDR_OWVAR 42
102963: PUSH
102964: LD_INT 36
102966: ST_TO_ADDR
102967: GO 103160
102969: LD_INT 25
102971: DOUBLE
102972: EQUAL
102973: IFTRUE 102977
102975: GO 102988
102977: POP
// bc_type := b_breastwork ; 26 :
102978: LD_ADDR_OWVAR 42
102982: PUSH
102983: LD_INT 31
102985: ST_TO_ADDR
102986: GO 103160
102988: LD_INT 26
102990: DOUBLE
102991: EQUAL
102992: IFTRUE 102996
102994: GO 103007
102996: POP
// bc_type := b_bunker ; 27 :
102997: LD_ADDR_OWVAR 42
103001: PUSH
103002: LD_INT 32
103004: ST_TO_ADDR
103005: GO 103160
103007: LD_INT 27
103009: DOUBLE
103010: EQUAL
103011: IFTRUE 103015
103013: GO 103026
103015: POP
// bc_type := b_turret ; 28 :
103016: LD_ADDR_OWVAR 42
103020: PUSH
103021: LD_INT 33
103023: ST_TO_ADDR
103024: GO 103160
103026: LD_INT 28
103028: DOUBLE
103029: EQUAL
103030: IFTRUE 103034
103032: GO 103045
103034: POP
// bc_type := b_armoury ; 29 :
103035: LD_ADDR_OWVAR 42
103039: PUSH
103040: LD_INT 4
103042: ST_TO_ADDR
103043: GO 103160
103045: LD_INT 29
103047: DOUBLE
103048: EQUAL
103049: IFTRUE 103053
103051: GO 103064
103053: POP
// bc_type := b_barracks ; 30 :
103054: LD_ADDR_OWVAR 42
103058: PUSH
103059: LD_INT 5
103061: ST_TO_ADDR
103062: GO 103160
103064: LD_INT 30
103066: DOUBLE
103067: EQUAL
103068: IFTRUE 103072
103070: GO 103083
103072: POP
// bc_type := b_solar_power ; 31 :
103073: LD_ADDR_OWVAR 42
103077: PUSH
103078: LD_INT 27
103080: ST_TO_ADDR
103081: GO 103160
103083: LD_INT 31
103085: DOUBLE
103086: EQUAL
103087: IFTRUE 103091
103089: GO 103102
103091: POP
// bc_type := b_oil_power ; 32 :
103092: LD_ADDR_OWVAR 42
103096: PUSH
103097: LD_INT 26
103099: ST_TO_ADDR
103100: GO 103160
103102: LD_INT 32
103104: DOUBLE
103105: EQUAL
103106: IFTRUE 103110
103108: GO 103121
103110: POP
// bc_type := b_siberite_power ; 33 :
103111: LD_ADDR_OWVAR 42
103115: PUSH
103116: LD_INT 28
103118: ST_TO_ADDR
103119: GO 103160
103121: LD_INT 33
103123: DOUBLE
103124: EQUAL
103125: IFTRUE 103129
103127: GO 103140
103129: POP
// bc_type := b_oil_mine ; 34 :
103130: LD_ADDR_OWVAR 42
103134: PUSH
103135: LD_INT 29
103137: ST_TO_ADDR
103138: GO 103160
103140: LD_INT 34
103142: DOUBLE
103143: EQUAL
103144: IFTRUE 103148
103146: GO 103159
103148: POP
// bc_type := b_siberite_mine ; end ;
103149: LD_ADDR_OWVAR 42
103153: PUSH
103154: LD_INT 30
103156: ST_TO_ADDR
103157: GO 103160
103159: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
103160: LD_ADDR_VAR 0 8
103164: PUSH
103165: LD_VAR 0 5
103169: PPUSH
103170: LD_VAR 0 6
103174: PPUSH
103175: LD_VAR 0 3
103179: PPUSH
103180: CALL_OW 47
103184: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
103185: LD_OWVAR 42
103189: PUSH
103190: LD_INT 32
103192: PUSH
103193: LD_INT 33
103195: PUSH
103196: EMPTY
103197: LIST
103198: LIST
103199: IN
103200: IFFALSE 103216
// PlaceWeaponTurret ( b , weapon ) ;
103202: LD_VAR 0 8
103206: PPUSH
103207: LD_VAR 0 4
103211: PPUSH
103212: CALL_OW 431
// end ;
103216: LD_VAR 0 7
103220: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
103221: LD_INT 0
103223: PPUSH
103224: PPUSH
103225: PPUSH
103226: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103227: LD_ADDR_VAR 0 4
103231: PUSH
103232: LD_INT 22
103234: PUSH
103235: LD_OWVAR 2
103239: PUSH
103240: EMPTY
103241: LIST
103242: LIST
103243: PUSH
103244: LD_INT 2
103246: PUSH
103247: LD_INT 30
103249: PUSH
103250: LD_INT 0
103252: PUSH
103253: EMPTY
103254: LIST
103255: LIST
103256: PUSH
103257: LD_INT 30
103259: PUSH
103260: LD_INT 1
103262: PUSH
103263: EMPTY
103264: LIST
103265: LIST
103266: PUSH
103267: EMPTY
103268: LIST
103269: LIST
103270: LIST
103271: PUSH
103272: EMPTY
103273: LIST
103274: LIST
103275: PPUSH
103276: CALL_OW 69
103280: ST_TO_ADDR
// if not tmp then
103281: LD_VAR 0 4
103285: NOT
103286: IFFALSE 103290
// exit ;
103288: GO 103349
// for i in tmp do
103290: LD_ADDR_VAR 0 2
103294: PUSH
103295: LD_VAR 0 4
103299: PUSH
103300: FOR_IN
103301: IFFALSE 103347
// for j = 1 to 3 do
103303: LD_ADDR_VAR 0 3
103307: PUSH
103308: DOUBLE
103309: LD_INT 1
103311: DEC
103312: ST_TO_ADDR
103313: LD_INT 3
103315: PUSH
103316: FOR_TO
103317: IFFALSE 103343
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
103319: LD_VAR 0 2
103323: PPUSH
103324: CALL_OW 274
103328: PPUSH
103329: LD_VAR 0 3
103333: PPUSH
103334: LD_INT 99999
103336: PPUSH
103337: CALL_OW 277
103341: GO 103316
103343: POP
103344: POP
103345: GO 103300
103347: POP
103348: POP
// end ;
103349: LD_VAR 0 1
103353: RET
// export function hHackSetLevel10 ; var i , j ; begin
103354: LD_INT 0
103356: PPUSH
103357: PPUSH
103358: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103359: LD_ADDR_VAR 0 2
103363: PUSH
103364: LD_INT 21
103366: PUSH
103367: LD_INT 1
103369: PUSH
103370: EMPTY
103371: LIST
103372: LIST
103373: PPUSH
103374: CALL_OW 69
103378: PUSH
103379: FOR_IN
103380: IFFALSE 103432
// if IsSelected ( i ) then
103382: LD_VAR 0 2
103386: PPUSH
103387: CALL_OW 306
103391: IFFALSE 103430
// begin for j := 1 to 4 do
103393: LD_ADDR_VAR 0 3
103397: PUSH
103398: DOUBLE
103399: LD_INT 1
103401: DEC
103402: ST_TO_ADDR
103403: LD_INT 4
103405: PUSH
103406: FOR_TO
103407: IFFALSE 103428
// SetSkill ( i , j , 10 ) ;
103409: LD_VAR 0 2
103413: PPUSH
103414: LD_VAR 0 3
103418: PPUSH
103419: LD_INT 10
103421: PPUSH
103422: CALL_OW 237
103426: GO 103406
103428: POP
103429: POP
// end ;
103430: GO 103379
103432: POP
103433: POP
// end ;
103434: LD_VAR 0 1
103438: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
103439: LD_INT 0
103441: PPUSH
103442: PPUSH
103443: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
103444: LD_ADDR_VAR 0 2
103448: PUSH
103449: LD_INT 22
103451: PUSH
103452: LD_OWVAR 2
103456: PUSH
103457: EMPTY
103458: LIST
103459: LIST
103460: PUSH
103461: LD_INT 21
103463: PUSH
103464: LD_INT 1
103466: PUSH
103467: EMPTY
103468: LIST
103469: LIST
103470: PUSH
103471: EMPTY
103472: LIST
103473: LIST
103474: PPUSH
103475: CALL_OW 69
103479: PUSH
103480: FOR_IN
103481: IFFALSE 103522
// begin for j := 1 to 4 do
103483: LD_ADDR_VAR 0 3
103487: PUSH
103488: DOUBLE
103489: LD_INT 1
103491: DEC
103492: ST_TO_ADDR
103493: LD_INT 4
103495: PUSH
103496: FOR_TO
103497: IFFALSE 103518
// SetSkill ( i , j , 10 ) ;
103499: LD_VAR 0 2
103503: PPUSH
103504: LD_VAR 0 3
103508: PPUSH
103509: LD_INT 10
103511: PPUSH
103512: CALL_OW 237
103516: GO 103496
103518: POP
103519: POP
// end ;
103520: GO 103480
103522: POP
103523: POP
// end ;
103524: LD_VAR 0 1
103528: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
103529: LD_INT 0
103531: PPUSH
// uc_side := your_side ;
103532: LD_ADDR_OWVAR 20
103536: PUSH
103537: LD_OWVAR 2
103541: ST_TO_ADDR
// uc_nation := nation ;
103542: LD_ADDR_OWVAR 21
103546: PUSH
103547: LD_VAR 0 1
103551: ST_TO_ADDR
// InitHc ;
103552: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
103556: LD_INT 0
103558: PPUSH
103559: LD_VAR 0 2
103563: PPUSH
103564: LD_VAR 0 3
103568: PPUSH
103569: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
103573: LD_VAR 0 4
103577: PPUSH
103578: LD_VAR 0 5
103582: PPUSH
103583: CALL_OW 428
103587: PUSH
103588: LD_INT 0
103590: EQUAL
103591: IFFALSE 103615
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
103593: CALL_OW 44
103597: PPUSH
103598: LD_VAR 0 4
103602: PPUSH
103603: LD_VAR 0 5
103607: PPUSH
103608: LD_INT 1
103610: PPUSH
103611: CALL_OW 48
// end ;
103615: LD_VAR 0 6
103619: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
103620: LD_INT 0
103622: PPUSH
103623: PPUSH
// uc_side := your_side ;
103624: LD_ADDR_OWVAR 20
103628: PUSH
103629: LD_OWVAR 2
103633: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
103634: LD_VAR 0 1
103638: PUSH
103639: LD_INT 1
103641: PUSH
103642: LD_INT 2
103644: PUSH
103645: LD_INT 3
103647: PUSH
103648: LD_INT 4
103650: PUSH
103651: LD_INT 5
103653: PUSH
103654: EMPTY
103655: LIST
103656: LIST
103657: LIST
103658: LIST
103659: LIST
103660: IN
103661: IFFALSE 103673
// uc_nation := nation_american else
103663: LD_ADDR_OWVAR 21
103667: PUSH
103668: LD_INT 1
103670: ST_TO_ADDR
103671: GO 103716
// if chassis in [ 11 , 12 , 13 , 14 ] then
103673: LD_VAR 0 1
103677: PUSH
103678: LD_INT 11
103680: PUSH
103681: LD_INT 12
103683: PUSH
103684: LD_INT 13
103686: PUSH
103687: LD_INT 14
103689: PUSH
103690: EMPTY
103691: LIST
103692: LIST
103693: LIST
103694: LIST
103695: IN
103696: IFFALSE 103708
// uc_nation := nation_arabian else
103698: LD_ADDR_OWVAR 21
103702: PUSH
103703: LD_INT 2
103705: ST_TO_ADDR
103706: GO 103716
// uc_nation := nation_russian ;
103708: LD_ADDR_OWVAR 21
103712: PUSH
103713: LD_INT 3
103715: ST_TO_ADDR
// vc_chassis := chassis ;
103716: LD_ADDR_OWVAR 37
103720: PUSH
103721: LD_VAR 0 1
103725: ST_TO_ADDR
// vc_engine := engine ;
103726: LD_ADDR_OWVAR 39
103730: PUSH
103731: LD_VAR 0 2
103735: ST_TO_ADDR
// vc_control := control ;
103736: LD_ADDR_OWVAR 38
103740: PUSH
103741: LD_VAR 0 3
103745: ST_TO_ADDR
// vc_weapon := weapon ;
103746: LD_ADDR_OWVAR 40
103750: PUSH
103751: LD_VAR 0 4
103755: ST_TO_ADDR
// un := CreateVehicle ;
103756: LD_ADDR_VAR 0 8
103760: PUSH
103761: CALL_OW 45
103765: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
103766: LD_VAR 0 8
103770: PPUSH
103771: LD_INT 0
103773: PPUSH
103774: LD_INT 5
103776: PPUSH
103777: CALL_OW 12
103781: PPUSH
103782: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
103786: LD_VAR 0 8
103790: PPUSH
103791: LD_VAR 0 5
103795: PPUSH
103796: LD_VAR 0 6
103800: PPUSH
103801: LD_INT 1
103803: PPUSH
103804: CALL_OW 48
// end ;
103808: LD_VAR 0 7
103812: RET
// export hInvincible ; every 1 do
103813: GO 103815
103815: DISABLE
// hInvincible := [ ] ;
103816: LD_ADDR_EXP 164
103820: PUSH
103821: EMPTY
103822: ST_TO_ADDR
103823: END
// every 10 do var i ;
103824: GO 103826
103826: DISABLE
103827: LD_INT 0
103829: PPUSH
// begin enable ;
103830: ENABLE
// if not hInvincible then
103831: LD_EXP 164
103835: NOT
103836: IFFALSE 103840
// exit ;
103838: GO 103884
// for i in hInvincible do
103840: LD_ADDR_VAR 0 1
103844: PUSH
103845: LD_EXP 164
103849: PUSH
103850: FOR_IN
103851: IFFALSE 103882
// if GetLives ( i ) < 1000 then
103853: LD_VAR 0 1
103857: PPUSH
103858: CALL_OW 256
103862: PUSH
103863: LD_INT 1000
103865: LESS
103866: IFFALSE 103880
// SetLives ( i , 1000 ) ;
103868: LD_VAR 0 1
103872: PPUSH
103873: LD_INT 1000
103875: PPUSH
103876: CALL_OW 234
103880: GO 103850
103882: POP
103883: POP
// end ;
103884: PPOPN 1
103886: END
// export function hHackInvincible ; var i ; begin
103887: LD_INT 0
103889: PPUSH
103890: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
103891: LD_ADDR_VAR 0 2
103895: PUSH
103896: LD_INT 2
103898: PUSH
103899: LD_INT 21
103901: PUSH
103902: LD_INT 1
103904: PUSH
103905: EMPTY
103906: LIST
103907: LIST
103908: PUSH
103909: LD_INT 21
103911: PUSH
103912: LD_INT 2
103914: PUSH
103915: EMPTY
103916: LIST
103917: LIST
103918: PUSH
103919: EMPTY
103920: LIST
103921: LIST
103922: LIST
103923: PPUSH
103924: CALL_OW 69
103928: PUSH
103929: FOR_IN
103930: IFFALSE 103991
// if IsSelected ( i ) then
103932: LD_VAR 0 2
103936: PPUSH
103937: CALL_OW 306
103941: IFFALSE 103989
// begin if i in hInvincible then
103943: LD_VAR 0 2
103947: PUSH
103948: LD_EXP 164
103952: IN
103953: IFFALSE 103973
// hInvincible := hInvincible diff i else
103955: LD_ADDR_EXP 164
103959: PUSH
103960: LD_EXP 164
103964: PUSH
103965: LD_VAR 0 2
103969: DIFF
103970: ST_TO_ADDR
103971: GO 103989
// hInvincible := hInvincible union i ;
103973: LD_ADDR_EXP 164
103977: PUSH
103978: LD_EXP 164
103982: PUSH
103983: LD_VAR 0 2
103987: UNION
103988: ST_TO_ADDR
// end ;
103989: GO 103929
103991: POP
103992: POP
// end ;
103993: LD_VAR 0 1
103997: RET
// export function hHackInvisible ; var i , j ; begin
103998: LD_INT 0
104000: PPUSH
104001: PPUSH
104002: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104003: LD_ADDR_VAR 0 2
104007: PUSH
104008: LD_INT 21
104010: PUSH
104011: LD_INT 1
104013: PUSH
104014: EMPTY
104015: LIST
104016: LIST
104017: PPUSH
104018: CALL_OW 69
104022: PUSH
104023: FOR_IN
104024: IFFALSE 104048
// if IsSelected ( i ) then
104026: LD_VAR 0 2
104030: PPUSH
104031: CALL_OW 306
104035: IFFALSE 104046
// ComForceInvisible ( i ) ;
104037: LD_VAR 0 2
104041: PPUSH
104042: CALL_OW 496
104046: GO 104023
104048: POP
104049: POP
// end ;
104050: LD_VAR 0 1
104054: RET
// export function hHackChangeYourSide ; begin
104055: LD_INT 0
104057: PPUSH
// if your_side = 8 then
104058: LD_OWVAR 2
104062: PUSH
104063: LD_INT 8
104065: EQUAL
104066: IFFALSE 104078
// your_side := 0 else
104068: LD_ADDR_OWVAR 2
104072: PUSH
104073: LD_INT 0
104075: ST_TO_ADDR
104076: GO 104092
// your_side := your_side + 1 ;
104078: LD_ADDR_OWVAR 2
104082: PUSH
104083: LD_OWVAR 2
104087: PUSH
104088: LD_INT 1
104090: PLUS
104091: ST_TO_ADDR
// end ;
104092: LD_VAR 0 1
104096: RET
// export function hHackChangeUnitSide ; var i , j ; begin
104097: LD_INT 0
104099: PPUSH
104100: PPUSH
104101: PPUSH
// for i in all_units do
104102: LD_ADDR_VAR 0 2
104106: PUSH
104107: LD_OWVAR 3
104111: PUSH
104112: FOR_IN
104113: IFFALSE 104191
// if IsSelected ( i ) then
104115: LD_VAR 0 2
104119: PPUSH
104120: CALL_OW 306
104124: IFFALSE 104189
// begin j := GetSide ( i ) ;
104126: LD_ADDR_VAR 0 3
104130: PUSH
104131: LD_VAR 0 2
104135: PPUSH
104136: CALL_OW 255
104140: ST_TO_ADDR
// if j = 8 then
104141: LD_VAR 0 3
104145: PUSH
104146: LD_INT 8
104148: EQUAL
104149: IFFALSE 104161
// j := 0 else
104151: LD_ADDR_VAR 0 3
104155: PUSH
104156: LD_INT 0
104158: ST_TO_ADDR
104159: GO 104175
// j := j + 1 ;
104161: LD_ADDR_VAR 0 3
104165: PUSH
104166: LD_VAR 0 3
104170: PUSH
104171: LD_INT 1
104173: PLUS
104174: ST_TO_ADDR
// SetSide ( i , j ) ;
104175: LD_VAR 0 2
104179: PPUSH
104180: LD_VAR 0 3
104184: PPUSH
104185: CALL_OW 235
// end ;
104189: GO 104112
104191: POP
104192: POP
// end ;
104193: LD_VAR 0 1
104197: RET
// export function hHackFog ; begin
104198: LD_INT 0
104200: PPUSH
// FogOff ( true ) ;
104201: LD_INT 1
104203: PPUSH
104204: CALL_OW 344
// end ;
104208: LD_VAR 0 1
104212: RET
// export function hHackTeleport ( unit , x , y ) ; begin
104213: LD_INT 0
104215: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
104216: LD_VAR 0 1
104220: PPUSH
104221: LD_VAR 0 2
104225: PPUSH
104226: LD_VAR 0 3
104230: PPUSH
104231: LD_INT 1
104233: PPUSH
104234: LD_INT 1
104236: PPUSH
104237: CALL_OW 483
// CenterOnXY ( x , y ) ;
104241: LD_VAR 0 2
104245: PPUSH
104246: LD_VAR 0 3
104250: PPUSH
104251: CALL_OW 84
// end ;
104255: LD_VAR 0 4
104259: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
104260: LD_INT 0
104262: PPUSH
104263: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
104264: LD_VAR 0 1
104268: NOT
104269: PUSH
104270: LD_VAR 0 2
104274: PPUSH
104275: LD_VAR 0 3
104279: PPUSH
104280: CALL_OW 488
104284: NOT
104285: OR
104286: PUSH
104287: LD_VAR 0 1
104291: PPUSH
104292: CALL_OW 266
104296: PUSH
104297: LD_INT 3
104299: NONEQUAL
104300: PUSH
104301: LD_VAR 0 1
104305: PPUSH
104306: CALL_OW 247
104310: PUSH
104311: LD_INT 1
104313: EQUAL
104314: NOT
104315: AND
104316: OR
104317: IFFALSE 104321
// exit ;
104319: GO 104470
// if GetType ( factory ) = unit_human then
104321: LD_VAR 0 1
104325: PPUSH
104326: CALL_OW 247
104330: PUSH
104331: LD_INT 1
104333: EQUAL
104334: IFFALSE 104351
// factory := IsInUnit ( factory ) ;
104336: LD_ADDR_VAR 0 1
104340: PUSH
104341: LD_VAR 0 1
104345: PPUSH
104346: CALL_OW 310
104350: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
104351: LD_VAR 0 1
104355: PPUSH
104356: CALL_OW 266
104360: PUSH
104361: LD_INT 3
104363: NONEQUAL
104364: IFFALSE 104368
// exit ;
104366: GO 104470
// if HexInfo ( x , y ) = factory then
104368: LD_VAR 0 2
104372: PPUSH
104373: LD_VAR 0 3
104377: PPUSH
104378: CALL_OW 428
104382: PUSH
104383: LD_VAR 0 1
104387: EQUAL
104388: IFFALSE 104415
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
104390: LD_ADDR_EXP 165
104394: PUSH
104395: LD_EXP 165
104399: PPUSH
104400: LD_VAR 0 1
104404: PPUSH
104405: LD_INT 0
104407: PPUSH
104408: CALL_OW 1
104412: ST_TO_ADDR
104413: GO 104466
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
104415: LD_ADDR_EXP 165
104419: PUSH
104420: LD_EXP 165
104424: PPUSH
104425: LD_VAR 0 1
104429: PPUSH
104430: LD_VAR 0 1
104434: PPUSH
104435: CALL_OW 255
104439: PUSH
104440: LD_VAR 0 1
104444: PUSH
104445: LD_VAR 0 2
104449: PUSH
104450: LD_VAR 0 3
104454: PUSH
104455: EMPTY
104456: LIST
104457: LIST
104458: LIST
104459: LIST
104460: PPUSH
104461: CALL_OW 1
104465: ST_TO_ADDR
// UpdateFactoryWaypoints ;
104466: CALL 104475 0 0
// end ;
104470: LD_VAR 0 4
104474: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
104475: LD_INT 0
104477: PPUSH
104478: PPUSH
104479: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
104480: LD_STRING resetFactoryWaypoint();
104482: PPUSH
104483: CALL_OW 559
// if factoryWaypoints then
104487: LD_EXP 165
104491: IFFALSE 104617
// begin list := PrepareArray ( factoryWaypoints ) ;
104493: LD_ADDR_VAR 0 3
104497: PUSH
104498: LD_EXP 165
104502: PPUSH
104503: CALL 57884 0 1
104507: ST_TO_ADDR
// for i := 1 to list do
104508: LD_ADDR_VAR 0 2
104512: PUSH
104513: DOUBLE
104514: LD_INT 1
104516: DEC
104517: ST_TO_ADDR
104518: LD_VAR 0 3
104522: PUSH
104523: FOR_TO
104524: IFFALSE 104615
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104526: LD_STRING setFactoryWaypointXY(
104528: PUSH
104529: LD_VAR 0 3
104533: PUSH
104534: LD_VAR 0 2
104538: ARRAY
104539: PUSH
104540: LD_INT 1
104542: ARRAY
104543: STR
104544: PUSH
104545: LD_STRING ,
104547: STR
104548: PUSH
104549: LD_VAR 0 3
104553: PUSH
104554: LD_VAR 0 2
104558: ARRAY
104559: PUSH
104560: LD_INT 2
104562: ARRAY
104563: STR
104564: PUSH
104565: LD_STRING ,
104567: STR
104568: PUSH
104569: LD_VAR 0 3
104573: PUSH
104574: LD_VAR 0 2
104578: ARRAY
104579: PUSH
104580: LD_INT 3
104582: ARRAY
104583: STR
104584: PUSH
104585: LD_STRING ,
104587: STR
104588: PUSH
104589: LD_VAR 0 3
104593: PUSH
104594: LD_VAR 0 2
104598: ARRAY
104599: PUSH
104600: LD_INT 4
104602: ARRAY
104603: STR
104604: PUSH
104605: LD_STRING )
104607: STR
104608: PPUSH
104609: CALL_OW 559
104613: GO 104523
104615: POP
104616: POP
// end ; end ;
104617: LD_VAR 0 1
104621: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
104622: LD_INT 0
104624: PPUSH
// if HexInfo ( x , y ) = warehouse then
104625: LD_VAR 0 2
104629: PPUSH
104630: LD_VAR 0 3
104634: PPUSH
104635: CALL_OW 428
104639: PUSH
104640: LD_VAR 0 1
104644: EQUAL
104645: IFFALSE 104672
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
104647: LD_ADDR_EXP 166
104651: PUSH
104652: LD_EXP 166
104656: PPUSH
104657: LD_VAR 0 1
104661: PPUSH
104662: LD_INT 0
104664: PPUSH
104665: CALL_OW 1
104669: ST_TO_ADDR
104670: GO 104723
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
104672: LD_ADDR_EXP 166
104676: PUSH
104677: LD_EXP 166
104681: PPUSH
104682: LD_VAR 0 1
104686: PPUSH
104687: LD_VAR 0 1
104691: PPUSH
104692: CALL_OW 255
104696: PUSH
104697: LD_VAR 0 1
104701: PUSH
104702: LD_VAR 0 2
104706: PUSH
104707: LD_VAR 0 3
104711: PUSH
104712: EMPTY
104713: LIST
104714: LIST
104715: LIST
104716: LIST
104717: PPUSH
104718: CALL_OW 1
104722: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
104723: CALL 104732 0 0
// end ;
104727: LD_VAR 0 4
104731: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
104732: LD_INT 0
104734: PPUSH
104735: PPUSH
104736: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
104737: LD_STRING resetWarehouseGatheringPoints();
104739: PPUSH
104740: CALL_OW 559
// if warehouseGatheringPoints then
104744: LD_EXP 166
104748: IFFALSE 104874
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
104750: LD_ADDR_VAR 0 3
104754: PUSH
104755: LD_EXP 166
104759: PPUSH
104760: CALL 57884 0 1
104764: ST_TO_ADDR
// for i := 1 to list do
104765: LD_ADDR_VAR 0 2
104769: PUSH
104770: DOUBLE
104771: LD_INT 1
104773: DEC
104774: ST_TO_ADDR
104775: LD_VAR 0 3
104779: PUSH
104780: FOR_TO
104781: IFFALSE 104872
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104783: LD_STRING setWarehouseGatheringPointXY(
104785: PUSH
104786: LD_VAR 0 3
104790: PUSH
104791: LD_VAR 0 2
104795: ARRAY
104796: PUSH
104797: LD_INT 1
104799: ARRAY
104800: STR
104801: PUSH
104802: LD_STRING ,
104804: STR
104805: PUSH
104806: LD_VAR 0 3
104810: PUSH
104811: LD_VAR 0 2
104815: ARRAY
104816: PUSH
104817: LD_INT 2
104819: ARRAY
104820: STR
104821: PUSH
104822: LD_STRING ,
104824: STR
104825: PUSH
104826: LD_VAR 0 3
104830: PUSH
104831: LD_VAR 0 2
104835: ARRAY
104836: PUSH
104837: LD_INT 3
104839: ARRAY
104840: STR
104841: PUSH
104842: LD_STRING ,
104844: STR
104845: PUSH
104846: LD_VAR 0 3
104850: PUSH
104851: LD_VAR 0 2
104855: ARRAY
104856: PUSH
104857: LD_INT 4
104859: ARRAY
104860: STR
104861: PUSH
104862: LD_STRING )
104864: STR
104865: PPUSH
104866: CALL_OW 559
104870: GO 104780
104872: POP
104873: POP
// end ; end ;
104874: LD_VAR 0 1
104878: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
104879: LD_EXP 166
104883: IFFALSE 105568
104885: GO 104887
104887: DISABLE
104888: LD_INT 0
104890: PPUSH
104891: PPUSH
104892: PPUSH
104893: PPUSH
104894: PPUSH
104895: PPUSH
104896: PPUSH
104897: PPUSH
104898: PPUSH
// begin enable ;
104899: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
104900: LD_ADDR_VAR 0 3
104904: PUSH
104905: LD_EXP 166
104909: PPUSH
104910: CALL 57884 0 1
104914: ST_TO_ADDR
// if not list then
104915: LD_VAR 0 3
104919: NOT
104920: IFFALSE 104924
// exit ;
104922: GO 105568
// for i := 1 to list do
104924: LD_ADDR_VAR 0 1
104928: PUSH
104929: DOUBLE
104930: LD_INT 1
104932: DEC
104933: ST_TO_ADDR
104934: LD_VAR 0 3
104938: PUSH
104939: FOR_TO
104940: IFFALSE 105566
// begin depot := list [ i ] [ 2 ] ;
104942: LD_ADDR_VAR 0 8
104946: PUSH
104947: LD_VAR 0 3
104951: PUSH
104952: LD_VAR 0 1
104956: ARRAY
104957: PUSH
104958: LD_INT 2
104960: ARRAY
104961: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
104962: LD_ADDR_VAR 0 5
104966: PUSH
104967: LD_VAR 0 3
104971: PUSH
104972: LD_VAR 0 1
104976: ARRAY
104977: PUSH
104978: LD_INT 1
104980: ARRAY
104981: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
104982: LD_VAR 0 8
104986: PPUSH
104987: CALL_OW 301
104991: PUSH
104992: LD_VAR 0 5
104996: PUSH
104997: LD_VAR 0 8
105001: PPUSH
105002: CALL_OW 255
105006: NONEQUAL
105007: OR
105008: IFFALSE 105037
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
105010: LD_ADDR_EXP 166
105014: PUSH
105015: LD_EXP 166
105019: PPUSH
105020: LD_VAR 0 8
105024: PPUSH
105025: LD_INT 0
105027: PPUSH
105028: CALL_OW 1
105032: ST_TO_ADDR
// exit ;
105033: POP
105034: POP
105035: GO 105568
// end ; x := list [ i ] [ 3 ] ;
105037: LD_ADDR_VAR 0 6
105041: PUSH
105042: LD_VAR 0 3
105046: PUSH
105047: LD_VAR 0 1
105051: ARRAY
105052: PUSH
105053: LD_INT 3
105055: ARRAY
105056: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
105057: LD_ADDR_VAR 0 7
105061: PUSH
105062: LD_VAR 0 3
105066: PUSH
105067: LD_VAR 0 1
105071: ARRAY
105072: PUSH
105073: LD_INT 4
105075: ARRAY
105076: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
105077: LD_ADDR_VAR 0 9
105081: PUSH
105082: LD_VAR 0 6
105086: PPUSH
105087: LD_VAR 0 7
105091: PPUSH
105092: LD_INT 16
105094: PPUSH
105095: CALL 56472 0 3
105099: ST_TO_ADDR
// if not cratesNearbyPoint then
105100: LD_VAR 0 9
105104: NOT
105105: IFFALSE 105111
// exit ;
105107: POP
105108: POP
105109: GO 105568
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
105111: LD_ADDR_VAR 0 4
105115: PUSH
105116: LD_INT 22
105118: PUSH
105119: LD_VAR 0 5
105123: PUSH
105124: EMPTY
105125: LIST
105126: LIST
105127: PUSH
105128: LD_INT 3
105130: PUSH
105131: LD_INT 60
105133: PUSH
105134: EMPTY
105135: LIST
105136: PUSH
105137: EMPTY
105138: LIST
105139: LIST
105140: PUSH
105141: LD_INT 91
105143: PUSH
105144: LD_VAR 0 8
105148: PUSH
105149: LD_INT 6
105151: PUSH
105152: EMPTY
105153: LIST
105154: LIST
105155: LIST
105156: PUSH
105157: LD_INT 2
105159: PUSH
105160: LD_INT 25
105162: PUSH
105163: LD_INT 2
105165: PUSH
105166: EMPTY
105167: LIST
105168: LIST
105169: PUSH
105170: LD_INT 25
105172: PUSH
105173: LD_INT 16
105175: PUSH
105176: EMPTY
105177: LIST
105178: LIST
105179: PUSH
105180: EMPTY
105181: LIST
105182: LIST
105183: LIST
105184: PUSH
105185: EMPTY
105186: LIST
105187: LIST
105188: LIST
105189: LIST
105190: PPUSH
105191: CALL_OW 69
105195: PUSH
105196: LD_VAR 0 8
105200: PPUSH
105201: CALL_OW 313
105205: PPUSH
105206: LD_INT 3
105208: PUSH
105209: LD_INT 60
105211: PUSH
105212: EMPTY
105213: LIST
105214: PUSH
105215: EMPTY
105216: LIST
105217: LIST
105218: PUSH
105219: LD_INT 2
105221: PUSH
105222: LD_INT 25
105224: PUSH
105225: LD_INT 2
105227: PUSH
105228: EMPTY
105229: LIST
105230: LIST
105231: PUSH
105232: LD_INT 25
105234: PUSH
105235: LD_INT 16
105237: PUSH
105238: EMPTY
105239: LIST
105240: LIST
105241: PUSH
105242: EMPTY
105243: LIST
105244: LIST
105245: LIST
105246: PUSH
105247: EMPTY
105248: LIST
105249: LIST
105250: PPUSH
105251: CALL_OW 72
105255: UNION
105256: ST_TO_ADDR
// if tmp then
105257: LD_VAR 0 4
105261: IFFALSE 105341
// begin tmp := ShrinkArray ( tmp , 3 ) ;
105263: LD_ADDR_VAR 0 4
105267: PUSH
105268: LD_VAR 0 4
105272: PPUSH
105273: LD_INT 3
105275: PPUSH
105276: CALL 54441 0 2
105280: ST_TO_ADDR
// for j in tmp do
105281: LD_ADDR_VAR 0 2
105285: PUSH
105286: LD_VAR 0 4
105290: PUSH
105291: FOR_IN
105292: IFFALSE 105335
// begin if IsInUnit ( j ) then
105294: LD_VAR 0 2
105298: PPUSH
105299: CALL_OW 310
105303: IFFALSE 105314
// ComExit ( j ) ;
105305: LD_VAR 0 2
105309: PPUSH
105310: CALL 54524 0 1
// AddComCollect ( j , x , y ) ;
105314: LD_VAR 0 2
105318: PPUSH
105319: LD_VAR 0 6
105323: PPUSH
105324: LD_VAR 0 7
105328: PPUSH
105329: CALL_OW 177
// end ;
105333: GO 105291
105335: POP
105336: POP
// exit ;
105337: POP
105338: POP
105339: GO 105568
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
105341: LD_ADDR_VAR 0 4
105345: PUSH
105346: LD_INT 22
105348: PUSH
105349: LD_VAR 0 5
105353: PUSH
105354: EMPTY
105355: LIST
105356: LIST
105357: PUSH
105358: LD_INT 91
105360: PUSH
105361: LD_VAR 0 8
105365: PUSH
105366: LD_INT 8
105368: PUSH
105369: EMPTY
105370: LIST
105371: LIST
105372: LIST
105373: PUSH
105374: LD_INT 2
105376: PUSH
105377: LD_INT 34
105379: PUSH
105380: LD_INT 12
105382: PUSH
105383: EMPTY
105384: LIST
105385: LIST
105386: PUSH
105387: LD_INT 34
105389: PUSH
105390: LD_INT 51
105392: PUSH
105393: EMPTY
105394: LIST
105395: LIST
105396: PUSH
105397: LD_INT 34
105399: PUSH
105400: LD_INT 32
105402: PUSH
105403: EMPTY
105404: LIST
105405: LIST
105406: PUSH
105407: LD_INT 34
105409: PUSH
105410: LD_INT 89
105412: PUSH
105413: EMPTY
105414: LIST
105415: LIST
105416: PUSH
105417: EMPTY
105418: LIST
105419: LIST
105420: LIST
105421: LIST
105422: LIST
105423: PUSH
105424: EMPTY
105425: LIST
105426: LIST
105427: LIST
105428: PPUSH
105429: CALL_OW 69
105433: ST_TO_ADDR
// if tmp then
105434: LD_VAR 0 4
105438: IFFALSE 105564
// begin for j in tmp do
105440: LD_ADDR_VAR 0 2
105444: PUSH
105445: LD_VAR 0 4
105449: PUSH
105450: FOR_IN
105451: IFFALSE 105562
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
105453: LD_VAR 0 2
105457: PPUSH
105458: CALL_OW 262
105462: PUSH
105463: LD_INT 3
105465: EQUAL
105466: PUSH
105467: LD_VAR 0 2
105471: PPUSH
105472: CALL_OW 261
105476: PUSH
105477: LD_INT 20
105479: GREATER
105480: OR
105481: PUSH
105482: LD_VAR 0 2
105486: PPUSH
105487: CALL_OW 314
105491: NOT
105492: AND
105493: PUSH
105494: LD_VAR 0 2
105498: PPUSH
105499: CALL_OW 263
105503: PUSH
105504: LD_INT 1
105506: NONEQUAL
105507: PUSH
105508: LD_VAR 0 2
105512: PPUSH
105513: CALL_OW 311
105517: OR
105518: AND
105519: IFFALSE 105560
// begin ComCollect ( j , x , y ) ;
105521: LD_VAR 0 2
105525: PPUSH
105526: LD_VAR 0 6
105530: PPUSH
105531: LD_VAR 0 7
105535: PPUSH
105536: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
105540: LD_VAR 0 2
105544: PPUSH
105545: LD_VAR 0 8
105549: PPUSH
105550: CALL_OW 172
// exit ;
105554: POP
105555: POP
105556: POP
105557: POP
105558: GO 105568
// end ;
105560: GO 105450
105562: POP
105563: POP
// end ; end ;
105564: GO 104939
105566: POP
105567: POP
// end ; end_of_file
105568: PPOPN 9
105570: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
105571: LD_INT 0
105573: PPUSH
105574: PPUSH
105575: PPUSH
105576: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
105577: LD_VAR 0 1
105581: PPUSH
105582: CALL_OW 264
105586: PUSH
105587: LD_INT 91
105589: EQUAL
105590: IFFALSE 105662
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
105592: LD_INT 68
105594: PPUSH
105595: LD_VAR 0 1
105599: PPUSH
105600: CALL_OW 255
105604: PPUSH
105605: CALL_OW 321
105609: PUSH
105610: LD_INT 2
105612: EQUAL
105613: IFFALSE 105625
// eff := 70 else
105615: LD_ADDR_VAR 0 4
105619: PUSH
105620: LD_INT 70
105622: ST_TO_ADDR
105623: GO 105633
// eff := 30 ;
105625: LD_ADDR_VAR 0 4
105629: PUSH
105630: LD_INT 30
105632: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
105633: LD_VAR 0 1
105637: PPUSH
105638: CALL_OW 250
105642: PPUSH
105643: LD_VAR 0 1
105647: PPUSH
105648: CALL_OW 251
105652: PPUSH
105653: LD_VAR 0 4
105657: PPUSH
105658: CALL_OW 495
// end ; end ;
105662: LD_VAR 0 2
105666: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
105667: LD_INT 0
105669: PPUSH
// end ;
105670: LD_VAR 0 4
105674: RET
// export function SOS_Command ( cmd ) ; begin
105675: LD_INT 0
105677: PPUSH
// end ;
105678: LD_VAR 0 2
105682: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
105683: LD_INT 0
105685: PPUSH
// end ;
105686: LD_VAR 0 6
105690: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
105691: LD_INT 0
105693: PPUSH
105694: PPUSH
// if not vehicle or not factory then
105695: LD_VAR 0 1
105699: NOT
105700: PUSH
105701: LD_VAR 0 2
105705: NOT
105706: OR
105707: IFFALSE 105711
// exit ;
105709: GO 105942
// if factoryWaypoints >= factory then
105711: LD_EXP 165
105715: PUSH
105716: LD_VAR 0 2
105720: GREATEREQUAL
105721: IFFALSE 105942
// if factoryWaypoints [ factory ] then
105723: LD_EXP 165
105727: PUSH
105728: LD_VAR 0 2
105732: ARRAY
105733: IFFALSE 105942
// begin if GetControl ( vehicle ) = control_manual then
105735: LD_VAR 0 1
105739: PPUSH
105740: CALL_OW 263
105744: PUSH
105745: LD_INT 1
105747: EQUAL
105748: IFFALSE 105829
// begin driver := IsDrivenBy ( vehicle ) ;
105750: LD_ADDR_VAR 0 4
105754: PUSH
105755: LD_VAR 0 1
105759: PPUSH
105760: CALL_OW 311
105764: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105765: LD_VAR 0 4
105769: PPUSH
105770: LD_EXP 165
105774: PUSH
105775: LD_VAR 0 2
105779: ARRAY
105780: PUSH
105781: LD_INT 3
105783: ARRAY
105784: PPUSH
105785: LD_EXP 165
105789: PUSH
105790: LD_VAR 0 2
105794: ARRAY
105795: PUSH
105796: LD_INT 4
105798: ARRAY
105799: PPUSH
105800: CALL_OW 171
// AddComExitVehicle ( driver ) ;
105804: LD_VAR 0 4
105808: PPUSH
105809: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
105813: LD_VAR 0 4
105817: PPUSH
105818: LD_VAR 0 2
105822: PPUSH
105823: CALL_OW 180
// end else
105827: GO 105942
// if GetControl ( vehicle ) = control_remote then
105829: LD_VAR 0 1
105833: PPUSH
105834: CALL_OW 263
105838: PUSH
105839: LD_INT 2
105841: EQUAL
105842: IFFALSE 105903
// begin wait ( 0 0$2 ) ;
105844: LD_INT 70
105846: PPUSH
105847: CALL_OW 67
// if Connect ( vehicle ) then
105851: LD_VAR 0 1
105855: PPUSH
105856: CALL 24743 0 1
105860: IFFALSE 105901
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105862: LD_VAR 0 1
105866: PPUSH
105867: LD_EXP 165
105871: PUSH
105872: LD_VAR 0 2
105876: ARRAY
105877: PUSH
105878: LD_INT 3
105880: ARRAY
105881: PPUSH
105882: LD_EXP 165
105886: PUSH
105887: LD_VAR 0 2
105891: ARRAY
105892: PUSH
105893: LD_INT 4
105895: ARRAY
105896: PPUSH
105897: CALL_OW 171
// end else
105901: GO 105942
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105903: LD_VAR 0 1
105907: PPUSH
105908: LD_EXP 165
105912: PUSH
105913: LD_VAR 0 2
105917: ARRAY
105918: PUSH
105919: LD_INT 3
105921: ARRAY
105922: PPUSH
105923: LD_EXP 165
105927: PUSH
105928: LD_VAR 0 2
105932: ARRAY
105933: PUSH
105934: LD_INT 4
105936: ARRAY
105937: PPUSH
105938: CALL_OW 171
// end ; end ;
105942: LD_VAR 0 3
105946: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
105947: LD_INT 0
105949: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
105950: LD_VAR 0 1
105954: PUSH
105955: LD_INT 250
105957: EQUAL
105958: PUSH
105959: LD_VAR 0 2
105963: PPUSH
105964: CALL_OW 264
105968: PUSH
105969: LD_INT 81
105971: EQUAL
105972: AND
105973: IFFALSE 105994
// MinerPlaceMine ( unit , x , y ) ;
105975: LD_VAR 0 2
105979: PPUSH
105980: LD_VAR 0 4
105984: PPUSH
105985: LD_VAR 0 5
105989: PPUSH
105990: CALL 108984 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
105994: LD_VAR 0 1
105998: PUSH
105999: LD_INT 251
106001: EQUAL
106002: PUSH
106003: LD_VAR 0 2
106007: PPUSH
106008: CALL_OW 264
106012: PUSH
106013: LD_INT 81
106015: EQUAL
106016: AND
106017: IFFALSE 106038
// MinerDetonateMine ( unit , x , y ) ;
106019: LD_VAR 0 2
106023: PPUSH
106024: LD_VAR 0 4
106028: PPUSH
106029: LD_VAR 0 5
106033: PPUSH
106034: CALL 109259 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
106038: LD_VAR 0 1
106042: PUSH
106043: LD_INT 252
106045: EQUAL
106046: PUSH
106047: LD_VAR 0 2
106051: PPUSH
106052: CALL_OW 264
106056: PUSH
106057: LD_INT 81
106059: EQUAL
106060: AND
106061: IFFALSE 106082
// MinerCreateMinefield ( unit , x , y ) ;
106063: LD_VAR 0 2
106067: PPUSH
106068: LD_VAR 0 4
106072: PPUSH
106073: LD_VAR 0 5
106077: PPUSH
106078: CALL 109676 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
106082: LD_VAR 0 1
106086: PUSH
106087: LD_INT 253
106089: EQUAL
106090: PUSH
106091: LD_VAR 0 2
106095: PPUSH
106096: CALL_OW 257
106100: PUSH
106101: LD_INT 5
106103: EQUAL
106104: AND
106105: IFFALSE 106126
// ComBinocular ( unit , x , y ) ;
106107: LD_VAR 0 2
106111: PPUSH
106112: LD_VAR 0 4
106116: PPUSH
106117: LD_VAR 0 5
106121: PPUSH
106122: CALL 110045 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
106126: LD_VAR 0 1
106130: PUSH
106131: LD_INT 254
106133: EQUAL
106134: PUSH
106135: LD_VAR 0 2
106139: PPUSH
106140: CALL_OW 264
106144: PUSH
106145: LD_INT 99
106147: EQUAL
106148: AND
106149: PUSH
106150: LD_VAR 0 3
106154: PPUSH
106155: CALL_OW 263
106159: PUSH
106160: LD_INT 3
106162: EQUAL
106163: AND
106164: IFFALSE 106180
// HackDestroyVehicle ( unit , selectedUnit ) ;
106166: LD_VAR 0 2
106170: PPUSH
106171: LD_VAR 0 3
106175: PPUSH
106176: CALL 108348 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
106180: LD_VAR 0 1
106184: PUSH
106185: LD_INT 255
106187: EQUAL
106188: PUSH
106189: LD_VAR 0 2
106193: PPUSH
106194: CALL_OW 264
106198: PUSH
106199: LD_INT 14
106201: PUSH
106202: LD_INT 53
106204: PUSH
106205: EMPTY
106206: LIST
106207: LIST
106208: IN
106209: AND
106210: PUSH
106211: LD_VAR 0 4
106215: PPUSH
106216: LD_VAR 0 5
106220: PPUSH
106221: CALL_OW 488
106225: AND
106226: IFFALSE 106250
// CutTreeXYR ( unit , x , y , 12 ) ;
106228: LD_VAR 0 2
106232: PPUSH
106233: LD_VAR 0 4
106237: PPUSH
106238: LD_VAR 0 5
106242: PPUSH
106243: LD_INT 12
106245: PPUSH
106246: CALL 106345 0 4
// if cmd = 256 then
106250: LD_VAR 0 1
106254: PUSH
106255: LD_INT 256
106257: EQUAL
106258: IFFALSE 106279
// SetFactoryWaypoint ( unit , x , y ) ;
106260: LD_VAR 0 2
106264: PPUSH
106265: LD_VAR 0 4
106269: PPUSH
106270: LD_VAR 0 5
106274: PPUSH
106275: CALL 104260 0 3
// if cmd = 257 then
106279: LD_VAR 0 1
106283: PUSH
106284: LD_INT 257
106286: EQUAL
106287: IFFALSE 106308
// SetWarehouseGatheringPoint ( unit , x , y ) ;
106289: LD_VAR 0 2
106293: PPUSH
106294: LD_VAR 0 4
106298: PPUSH
106299: LD_VAR 0 5
106303: PPUSH
106304: CALL 104622 0 3
// if cmd = 258 then
106308: LD_VAR 0 1
106312: PUSH
106313: LD_INT 258
106315: EQUAL
106316: IFFALSE 106340
// BurnTreeXYR ( unit , x , y , 8 ) ;
106318: LD_VAR 0 2
106322: PPUSH
106323: LD_VAR 0 4
106327: PPUSH
106328: LD_VAR 0 5
106332: PPUSH
106333: LD_INT 8
106335: PPUSH
106336: CALL 106739 0 4
// end ;
106340: LD_VAR 0 6
106344: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
106345: LD_INT 0
106347: PPUSH
106348: PPUSH
106349: PPUSH
106350: PPUSH
106351: PPUSH
106352: PPUSH
106353: PPUSH
106354: PPUSH
106355: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
106356: LD_VAR 0 1
106360: PPUSH
106361: CALL_OW 302
106365: NOT
106366: PUSH
106367: LD_VAR 0 2
106371: PPUSH
106372: LD_VAR 0 3
106376: PPUSH
106377: CALL_OW 488
106381: NOT
106382: OR
106383: PUSH
106384: LD_VAR 0 4
106388: NOT
106389: OR
106390: IFFALSE 106394
// exit ;
106392: GO 106734
// list := [ ] ;
106394: LD_ADDR_VAR 0 13
106398: PUSH
106399: EMPTY
106400: ST_TO_ADDR
// if x - r < 0 then
106401: LD_VAR 0 2
106405: PUSH
106406: LD_VAR 0 4
106410: MINUS
106411: PUSH
106412: LD_INT 0
106414: LESS
106415: IFFALSE 106427
// min_x := 0 else
106417: LD_ADDR_VAR 0 7
106421: PUSH
106422: LD_INT 0
106424: ST_TO_ADDR
106425: GO 106443
// min_x := x - r ;
106427: LD_ADDR_VAR 0 7
106431: PUSH
106432: LD_VAR 0 2
106436: PUSH
106437: LD_VAR 0 4
106441: MINUS
106442: ST_TO_ADDR
// if y - r < 0 then
106443: LD_VAR 0 3
106447: PUSH
106448: LD_VAR 0 4
106452: MINUS
106453: PUSH
106454: LD_INT 0
106456: LESS
106457: IFFALSE 106469
// min_y := 0 else
106459: LD_ADDR_VAR 0 8
106463: PUSH
106464: LD_INT 0
106466: ST_TO_ADDR
106467: GO 106485
// min_y := y - r ;
106469: LD_ADDR_VAR 0 8
106473: PUSH
106474: LD_VAR 0 3
106478: PUSH
106479: LD_VAR 0 4
106483: MINUS
106484: ST_TO_ADDR
// max_x := x + r ;
106485: LD_ADDR_VAR 0 9
106489: PUSH
106490: LD_VAR 0 2
106494: PUSH
106495: LD_VAR 0 4
106499: PLUS
106500: ST_TO_ADDR
// max_y := y + r ;
106501: LD_ADDR_VAR 0 10
106505: PUSH
106506: LD_VAR 0 3
106510: PUSH
106511: LD_VAR 0 4
106515: PLUS
106516: ST_TO_ADDR
// for _x = min_x to max_x do
106517: LD_ADDR_VAR 0 11
106521: PUSH
106522: DOUBLE
106523: LD_VAR 0 7
106527: DEC
106528: ST_TO_ADDR
106529: LD_VAR 0 9
106533: PUSH
106534: FOR_TO
106535: IFFALSE 106652
// for _y = min_y to max_y do
106537: LD_ADDR_VAR 0 12
106541: PUSH
106542: DOUBLE
106543: LD_VAR 0 8
106547: DEC
106548: ST_TO_ADDR
106549: LD_VAR 0 10
106553: PUSH
106554: FOR_TO
106555: IFFALSE 106648
// begin if not ValidHex ( _x , _y ) then
106557: LD_VAR 0 11
106561: PPUSH
106562: LD_VAR 0 12
106566: PPUSH
106567: CALL_OW 488
106571: NOT
106572: IFFALSE 106576
// continue ;
106574: GO 106554
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106576: LD_VAR 0 11
106580: PPUSH
106581: LD_VAR 0 12
106585: PPUSH
106586: CALL_OW 351
106590: PUSH
106591: LD_VAR 0 11
106595: PPUSH
106596: LD_VAR 0 12
106600: PPUSH
106601: CALL_OW 554
106605: AND
106606: IFFALSE 106646
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106608: LD_ADDR_VAR 0 13
106612: PUSH
106613: LD_VAR 0 13
106617: PPUSH
106618: LD_VAR 0 13
106622: PUSH
106623: LD_INT 1
106625: PLUS
106626: PPUSH
106627: LD_VAR 0 11
106631: PUSH
106632: LD_VAR 0 12
106636: PUSH
106637: EMPTY
106638: LIST
106639: LIST
106640: PPUSH
106641: CALL_OW 2
106645: ST_TO_ADDR
// end ;
106646: GO 106554
106648: POP
106649: POP
106650: GO 106534
106652: POP
106653: POP
// if not list then
106654: LD_VAR 0 13
106658: NOT
106659: IFFALSE 106663
// exit ;
106661: GO 106734
// for i in list do
106663: LD_ADDR_VAR 0 6
106667: PUSH
106668: LD_VAR 0 13
106672: PUSH
106673: FOR_IN
106674: IFFALSE 106732
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
106676: LD_VAR 0 1
106680: PPUSH
106681: LD_STRING M
106683: PUSH
106684: LD_VAR 0 6
106688: PUSH
106689: LD_INT 1
106691: ARRAY
106692: PUSH
106693: LD_VAR 0 6
106697: PUSH
106698: LD_INT 2
106700: ARRAY
106701: PUSH
106702: LD_INT 0
106704: PUSH
106705: LD_INT 0
106707: PUSH
106708: LD_INT 0
106710: PUSH
106711: LD_INT 0
106713: PUSH
106714: EMPTY
106715: LIST
106716: LIST
106717: LIST
106718: LIST
106719: LIST
106720: LIST
106721: LIST
106722: PUSH
106723: EMPTY
106724: LIST
106725: PPUSH
106726: CALL_OW 447
106730: GO 106673
106732: POP
106733: POP
// end ;
106734: LD_VAR 0 5
106738: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
106739: LD_INT 0
106741: PPUSH
106742: PPUSH
106743: PPUSH
106744: PPUSH
106745: PPUSH
106746: PPUSH
106747: PPUSH
106748: PPUSH
106749: PPUSH
106750: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
106751: LD_VAR 0 1
106755: PPUSH
106756: CALL_OW 302
106760: NOT
106761: PUSH
106762: LD_VAR 0 2
106766: PPUSH
106767: LD_VAR 0 3
106771: PPUSH
106772: CALL_OW 488
106776: NOT
106777: OR
106778: PUSH
106779: LD_VAR 0 4
106783: NOT
106784: OR
106785: IFFALSE 106789
// exit ;
106787: GO 107302
// list := [ ] ;
106789: LD_ADDR_VAR 0 13
106793: PUSH
106794: EMPTY
106795: ST_TO_ADDR
// if x - r < 0 then
106796: LD_VAR 0 2
106800: PUSH
106801: LD_VAR 0 4
106805: MINUS
106806: PUSH
106807: LD_INT 0
106809: LESS
106810: IFFALSE 106822
// min_x := 0 else
106812: LD_ADDR_VAR 0 7
106816: PUSH
106817: LD_INT 0
106819: ST_TO_ADDR
106820: GO 106838
// min_x := x - r ;
106822: LD_ADDR_VAR 0 7
106826: PUSH
106827: LD_VAR 0 2
106831: PUSH
106832: LD_VAR 0 4
106836: MINUS
106837: ST_TO_ADDR
// if y - r < 0 then
106838: LD_VAR 0 3
106842: PUSH
106843: LD_VAR 0 4
106847: MINUS
106848: PUSH
106849: LD_INT 0
106851: LESS
106852: IFFALSE 106864
// min_y := 0 else
106854: LD_ADDR_VAR 0 8
106858: PUSH
106859: LD_INT 0
106861: ST_TO_ADDR
106862: GO 106880
// min_y := y - r ;
106864: LD_ADDR_VAR 0 8
106868: PUSH
106869: LD_VAR 0 3
106873: PUSH
106874: LD_VAR 0 4
106878: MINUS
106879: ST_TO_ADDR
// max_x := x + r ;
106880: LD_ADDR_VAR 0 9
106884: PUSH
106885: LD_VAR 0 2
106889: PUSH
106890: LD_VAR 0 4
106894: PLUS
106895: ST_TO_ADDR
// max_y := y + r ;
106896: LD_ADDR_VAR 0 10
106900: PUSH
106901: LD_VAR 0 3
106905: PUSH
106906: LD_VAR 0 4
106910: PLUS
106911: ST_TO_ADDR
// for _x = min_x to max_x do
106912: LD_ADDR_VAR 0 11
106916: PUSH
106917: DOUBLE
106918: LD_VAR 0 7
106922: DEC
106923: ST_TO_ADDR
106924: LD_VAR 0 9
106928: PUSH
106929: FOR_TO
106930: IFFALSE 107047
// for _y = min_y to max_y do
106932: LD_ADDR_VAR 0 12
106936: PUSH
106937: DOUBLE
106938: LD_VAR 0 8
106942: DEC
106943: ST_TO_ADDR
106944: LD_VAR 0 10
106948: PUSH
106949: FOR_TO
106950: IFFALSE 107043
// begin if not ValidHex ( _x , _y ) then
106952: LD_VAR 0 11
106956: PPUSH
106957: LD_VAR 0 12
106961: PPUSH
106962: CALL_OW 488
106966: NOT
106967: IFFALSE 106971
// continue ;
106969: GO 106949
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106971: LD_VAR 0 11
106975: PPUSH
106976: LD_VAR 0 12
106980: PPUSH
106981: CALL_OW 351
106985: PUSH
106986: LD_VAR 0 11
106990: PPUSH
106991: LD_VAR 0 12
106995: PPUSH
106996: CALL_OW 554
107000: AND
107001: IFFALSE 107041
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
107003: LD_ADDR_VAR 0 13
107007: PUSH
107008: LD_VAR 0 13
107012: PPUSH
107013: LD_VAR 0 13
107017: PUSH
107018: LD_INT 1
107020: PLUS
107021: PPUSH
107022: LD_VAR 0 11
107026: PUSH
107027: LD_VAR 0 12
107031: PUSH
107032: EMPTY
107033: LIST
107034: LIST
107035: PPUSH
107036: CALL_OW 2
107040: ST_TO_ADDR
// end ;
107041: GO 106949
107043: POP
107044: POP
107045: GO 106929
107047: POP
107048: POP
// if not list then
107049: LD_VAR 0 13
107053: NOT
107054: IFFALSE 107058
// exit ;
107056: GO 107302
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
107058: LD_ADDR_VAR 0 13
107062: PUSH
107063: LD_VAR 0 1
107067: PPUSH
107068: LD_VAR 0 13
107072: PPUSH
107073: LD_INT 1
107075: PPUSH
107076: LD_INT 1
107078: PPUSH
107079: CALL 21885 0 4
107083: ST_TO_ADDR
// ComStop ( flame ) ;
107084: LD_VAR 0 1
107088: PPUSH
107089: CALL_OW 141
// for i in list do
107093: LD_ADDR_VAR 0 6
107097: PUSH
107098: LD_VAR 0 13
107102: PUSH
107103: FOR_IN
107104: IFFALSE 107135
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
107106: LD_VAR 0 1
107110: PPUSH
107111: LD_VAR 0 6
107115: PUSH
107116: LD_INT 1
107118: ARRAY
107119: PPUSH
107120: LD_VAR 0 6
107124: PUSH
107125: LD_INT 2
107127: ARRAY
107128: PPUSH
107129: CALL_OW 176
107133: GO 107103
107135: POP
107136: POP
// repeat wait ( 0 0$1 ) ;
107137: LD_INT 35
107139: PPUSH
107140: CALL_OW 67
// task := GetTaskList ( flame ) ;
107144: LD_ADDR_VAR 0 14
107148: PUSH
107149: LD_VAR 0 1
107153: PPUSH
107154: CALL_OW 437
107158: ST_TO_ADDR
// if not task then
107159: LD_VAR 0 14
107163: NOT
107164: IFFALSE 107168
// exit ;
107166: GO 107302
// if task [ 1 ] [ 1 ] <> | then
107168: LD_VAR 0 14
107172: PUSH
107173: LD_INT 1
107175: ARRAY
107176: PUSH
107177: LD_INT 1
107179: ARRAY
107180: PUSH
107181: LD_STRING |
107183: NONEQUAL
107184: IFFALSE 107188
// exit ;
107186: GO 107302
// _x := task [ 1 ] [ 2 ] ;
107188: LD_ADDR_VAR 0 11
107192: PUSH
107193: LD_VAR 0 14
107197: PUSH
107198: LD_INT 1
107200: ARRAY
107201: PUSH
107202: LD_INT 2
107204: ARRAY
107205: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
107206: LD_ADDR_VAR 0 12
107210: PUSH
107211: LD_VAR 0 14
107215: PUSH
107216: LD_INT 1
107218: ARRAY
107219: PUSH
107220: LD_INT 3
107222: ARRAY
107223: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
107224: LD_VAR 0 11
107228: PPUSH
107229: LD_VAR 0 12
107233: PPUSH
107234: CALL_OW 351
107238: NOT
107239: PUSH
107240: LD_VAR 0 11
107244: PPUSH
107245: LD_VAR 0 12
107249: PPUSH
107250: CALL_OW 554
107254: NOT
107255: OR
107256: IFFALSE 107290
// begin task := Delete ( task , 1 ) ;
107258: LD_ADDR_VAR 0 14
107262: PUSH
107263: LD_VAR 0 14
107267: PPUSH
107268: LD_INT 1
107270: PPUSH
107271: CALL_OW 3
107275: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
107276: LD_VAR 0 1
107280: PPUSH
107281: LD_VAR 0 14
107285: PPUSH
107286: CALL_OW 446
// end ; until not HasTask ( flame ) ;
107290: LD_VAR 0 1
107294: PPUSH
107295: CALL_OW 314
107299: NOT
107300: IFFALSE 107137
// end ;
107302: LD_VAR 0 5
107306: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
107307: LD_EXP 168
107311: NOT
107312: IFFALSE 107362
107314: GO 107316
107316: DISABLE
// begin initHack := true ;
107317: LD_ADDR_EXP 168
107321: PUSH
107322: LD_INT 1
107324: ST_TO_ADDR
// hackTanks := [ ] ;
107325: LD_ADDR_EXP 169
107329: PUSH
107330: EMPTY
107331: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
107332: LD_ADDR_EXP 170
107336: PUSH
107337: EMPTY
107338: ST_TO_ADDR
// hackLimit := 3 ;
107339: LD_ADDR_EXP 171
107343: PUSH
107344: LD_INT 3
107346: ST_TO_ADDR
// hackDist := 12 ;
107347: LD_ADDR_EXP 172
107351: PUSH
107352: LD_INT 12
107354: ST_TO_ADDR
// hackCounter := [ ] ;
107355: LD_ADDR_EXP 173
107359: PUSH
107360: EMPTY
107361: ST_TO_ADDR
// end ;
107362: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
107363: LD_EXP 168
107367: PUSH
107368: LD_INT 34
107370: PUSH
107371: LD_INT 99
107373: PUSH
107374: EMPTY
107375: LIST
107376: LIST
107377: PPUSH
107378: CALL_OW 69
107382: AND
107383: IFFALSE 107636
107385: GO 107387
107387: DISABLE
107388: LD_INT 0
107390: PPUSH
107391: PPUSH
// begin enable ;
107392: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
107393: LD_ADDR_VAR 0 1
107397: PUSH
107398: LD_INT 34
107400: PUSH
107401: LD_INT 99
107403: PUSH
107404: EMPTY
107405: LIST
107406: LIST
107407: PPUSH
107408: CALL_OW 69
107412: PUSH
107413: FOR_IN
107414: IFFALSE 107634
// begin if not i in hackTanks then
107416: LD_VAR 0 1
107420: PUSH
107421: LD_EXP 169
107425: IN
107426: NOT
107427: IFFALSE 107510
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
107429: LD_ADDR_EXP 169
107433: PUSH
107434: LD_EXP 169
107438: PPUSH
107439: LD_EXP 169
107443: PUSH
107444: LD_INT 1
107446: PLUS
107447: PPUSH
107448: LD_VAR 0 1
107452: PPUSH
107453: CALL_OW 1
107457: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
107458: LD_ADDR_EXP 170
107462: PUSH
107463: LD_EXP 170
107467: PPUSH
107468: LD_EXP 170
107472: PUSH
107473: LD_INT 1
107475: PLUS
107476: PPUSH
107477: EMPTY
107478: PPUSH
107479: CALL_OW 1
107483: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
107484: LD_ADDR_EXP 173
107488: PUSH
107489: LD_EXP 173
107493: PPUSH
107494: LD_EXP 173
107498: PUSH
107499: LD_INT 1
107501: PLUS
107502: PPUSH
107503: EMPTY
107504: PPUSH
107505: CALL_OW 1
107509: ST_TO_ADDR
// end ; if not IsOk ( i ) then
107510: LD_VAR 0 1
107514: PPUSH
107515: CALL_OW 302
107519: NOT
107520: IFFALSE 107533
// begin HackUnlinkAll ( i ) ;
107522: LD_VAR 0 1
107526: PPUSH
107527: CALL 107639 0 1
// continue ;
107531: GO 107413
// end ; HackCheckCapturedStatus ( i ) ;
107533: LD_VAR 0 1
107537: PPUSH
107538: CALL 108082 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
107542: LD_ADDR_VAR 0 2
107546: PUSH
107547: LD_INT 81
107549: PUSH
107550: LD_VAR 0 1
107554: PPUSH
107555: CALL_OW 255
107559: PUSH
107560: EMPTY
107561: LIST
107562: LIST
107563: PUSH
107564: LD_INT 33
107566: PUSH
107567: LD_INT 3
107569: PUSH
107570: EMPTY
107571: LIST
107572: LIST
107573: PUSH
107574: LD_INT 91
107576: PUSH
107577: LD_VAR 0 1
107581: PUSH
107582: LD_EXP 172
107586: PUSH
107587: EMPTY
107588: LIST
107589: LIST
107590: LIST
107591: PUSH
107592: LD_INT 50
107594: PUSH
107595: EMPTY
107596: LIST
107597: PUSH
107598: EMPTY
107599: LIST
107600: LIST
107601: LIST
107602: LIST
107603: PPUSH
107604: CALL_OW 69
107608: ST_TO_ADDR
// if not tmp then
107609: LD_VAR 0 2
107613: NOT
107614: IFFALSE 107618
// continue ;
107616: GO 107413
// HackLink ( i , tmp ) ;
107618: LD_VAR 0 1
107622: PPUSH
107623: LD_VAR 0 2
107627: PPUSH
107628: CALL 107775 0 2
// end ;
107632: GO 107413
107634: POP
107635: POP
// end ;
107636: PPOPN 2
107638: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
107639: LD_INT 0
107641: PPUSH
107642: PPUSH
107643: PPUSH
// if not hack in hackTanks then
107644: LD_VAR 0 1
107648: PUSH
107649: LD_EXP 169
107653: IN
107654: NOT
107655: IFFALSE 107659
// exit ;
107657: GO 107770
// index := GetElementIndex ( hackTanks , hack ) ;
107659: LD_ADDR_VAR 0 4
107663: PUSH
107664: LD_EXP 169
107668: PPUSH
107669: LD_VAR 0 1
107673: PPUSH
107674: CALL 21182 0 2
107678: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
107679: LD_EXP 170
107683: PUSH
107684: LD_VAR 0 4
107688: ARRAY
107689: IFFALSE 107770
// begin for i in hackTanksCaptured [ index ] do
107691: LD_ADDR_VAR 0 3
107695: PUSH
107696: LD_EXP 170
107700: PUSH
107701: LD_VAR 0 4
107705: ARRAY
107706: PUSH
107707: FOR_IN
107708: IFFALSE 107734
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
107710: LD_VAR 0 3
107714: PUSH
107715: LD_INT 1
107717: ARRAY
107718: PPUSH
107719: LD_VAR 0 3
107723: PUSH
107724: LD_INT 2
107726: ARRAY
107727: PPUSH
107728: CALL_OW 235
107732: GO 107707
107734: POP
107735: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
107736: LD_ADDR_EXP 170
107740: PUSH
107741: LD_EXP 170
107745: PPUSH
107746: LD_VAR 0 4
107750: PPUSH
107751: EMPTY
107752: PPUSH
107753: CALL_OW 1
107757: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
107758: LD_VAR 0 1
107762: PPUSH
107763: LD_INT 0
107765: PPUSH
107766: CALL_OW 505
// end ; end ;
107770: LD_VAR 0 2
107774: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
107775: LD_INT 0
107777: PPUSH
107778: PPUSH
107779: PPUSH
// if not hack in hackTanks or not vehicles then
107780: LD_VAR 0 1
107784: PUSH
107785: LD_EXP 169
107789: IN
107790: NOT
107791: PUSH
107792: LD_VAR 0 2
107796: NOT
107797: OR
107798: IFFALSE 107802
// exit ;
107800: GO 108077
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
107802: LD_ADDR_VAR 0 2
107806: PUSH
107807: LD_VAR 0 1
107811: PPUSH
107812: LD_VAR 0 2
107816: PPUSH
107817: LD_INT 1
107819: PPUSH
107820: LD_INT 1
107822: PPUSH
107823: CALL 21832 0 4
107827: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
107828: LD_ADDR_VAR 0 5
107832: PUSH
107833: LD_EXP 169
107837: PPUSH
107838: LD_VAR 0 1
107842: PPUSH
107843: CALL 21182 0 2
107847: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
107848: LD_EXP 170
107852: PUSH
107853: LD_VAR 0 5
107857: ARRAY
107858: PUSH
107859: LD_EXP 171
107863: LESS
107864: IFFALSE 108053
// begin for i := 1 to vehicles do
107866: LD_ADDR_VAR 0 4
107870: PUSH
107871: DOUBLE
107872: LD_INT 1
107874: DEC
107875: ST_TO_ADDR
107876: LD_VAR 0 2
107880: PUSH
107881: FOR_TO
107882: IFFALSE 108051
// begin if hackTanksCaptured [ index ] = hackLimit then
107884: LD_EXP 170
107888: PUSH
107889: LD_VAR 0 5
107893: ARRAY
107894: PUSH
107895: LD_EXP 171
107899: EQUAL
107900: IFFALSE 107904
// break ;
107902: GO 108051
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
107904: LD_ADDR_EXP 173
107908: PUSH
107909: LD_EXP 173
107913: PPUSH
107914: LD_VAR 0 5
107918: PPUSH
107919: LD_EXP 173
107923: PUSH
107924: LD_VAR 0 5
107928: ARRAY
107929: PUSH
107930: LD_INT 1
107932: PLUS
107933: PPUSH
107934: CALL_OW 1
107938: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
107939: LD_ADDR_EXP 170
107943: PUSH
107944: LD_EXP 170
107948: PPUSH
107949: LD_VAR 0 5
107953: PUSH
107954: LD_EXP 170
107958: PUSH
107959: LD_VAR 0 5
107963: ARRAY
107964: PUSH
107965: LD_INT 1
107967: PLUS
107968: PUSH
107969: EMPTY
107970: LIST
107971: LIST
107972: PPUSH
107973: LD_VAR 0 2
107977: PUSH
107978: LD_VAR 0 4
107982: ARRAY
107983: PUSH
107984: LD_VAR 0 2
107988: PUSH
107989: LD_VAR 0 4
107993: ARRAY
107994: PPUSH
107995: CALL_OW 255
107999: PUSH
108000: EMPTY
108001: LIST
108002: LIST
108003: PPUSH
108004: CALL 21397 0 3
108008: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
108009: LD_VAR 0 2
108013: PUSH
108014: LD_VAR 0 4
108018: ARRAY
108019: PPUSH
108020: LD_VAR 0 1
108024: PPUSH
108025: CALL_OW 255
108029: PPUSH
108030: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
108034: LD_VAR 0 2
108038: PUSH
108039: LD_VAR 0 4
108043: ARRAY
108044: PPUSH
108045: CALL_OW 141
// end ;
108049: GO 107881
108051: POP
108052: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108053: LD_VAR 0 1
108057: PPUSH
108058: LD_EXP 170
108062: PUSH
108063: LD_VAR 0 5
108067: ARRAY
108068: PUSH
108069: LD_INT 0
108071: PLUS
108072: PPUSH
108073: CALL_OW 505
// end ;
108077: LD_VAR 0 3
108081: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
108082: LD_INT 0
108084: PPUSH
108085: PPUSH
108086: PPUSH
108087: PPUSH
// if not hack in hackTanks then
108088: LD_VAR 0 1
108092: PUSH
108093: LD_EXP 169
108097: IN
108098: NOT
108099: IFFALSE 108103
// exit ;
108101: GO 108343
// index := GetElementIndex ( hackTanks , hack ) ;
108103: LD_ADDR_VAR 0 4
108107: PUSH
108108: LD_EXP 169
108112: PPUSH
108113: LD_VAR 0 1
108117: PPUSH
108118: CALL 21182 0 2
108122: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
108123: LD_ADDR_VAR 0 3
108127: PUSH
108128: DOUBLE
108129: LD_EXP 170
108133: PUSH
108134: LD_VAR 0 4
108138: ARRAY
108139: INC
108140: ST_TO_ADDR
108141: LD_INT 1
108143: PUSH
108144: FOR_DOWNTO
108145: IFFALSE 108317
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
108147: LD_ADDR_VAR 0 5
108151: PUSH
108152: LD_EXP 170
108156: PUSH
108157: LD_VAR 0 4
108161: ARRAY
108162: PUSH
108163: LD_VAR 0 3
108167: ARRAY
108168: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
108169: LD_VAR 0 5
108173: PUSH
108174: LD_INT 1
108176: ARRAY
108177: PPUSH
108178: CALL_OW 302
108182: NOT
108183: PUSH
108184: LD_VAR 0 5
108188: PUSH
108189: LD_INT 1
108191: ARRAY
108192: PPUSH
108193: CALL_OW 255
108197: PUSH
108198: LD_VAR 0 1
108202: PPUSH
108203: CALL_OW 255
108207: NONEQUAL
108208: OR
108209: IFFALSE 108315
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
108211: LD_VAR 0 5
108215: PUSH
108216: LD_INT 1
108218: ARRAY
108219: PPUSH
108220: CALL_OW 305
108224: PUSH
108225: LD_VAR 0 5
108229: PUSH
108230: LD_INT 1
108232: ARRAY
108233: PPUSH
108234: CALL_OW 255
108238: PUSH
108239: LD_VAR 0 1
108243: PPUSH
108244: CALL_OW 255
108248: EQUAL
108249: AND
108250: IFFALSE 108274
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
108252: LD_VAR 0 5
108256: PUSH
108257: LD_INT 1
108259: ARRAY
108260: PPUSH
108261: LD_VAR 0 5
108265: PUSH
108266: LD_INT 2
108268: ARRAY
108269: PPUSH
108270: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
108274: LD_ADDR_EXP 170
108278: PUSH
108279: LD_EXP 170
108283: PPUSH
108284: LD_VAR 0 4
108288: PPUSH
108289: LD_EXP 170
108293: PUSH
108294: LD_VAR 0 4
108298: ARRAY
108299: PPUSH
108300: LD_VAR 0 3
108304: PPUSH
108305: CALL_OW 3
108309: PPUSH
108310: CALL_OW 1
108314: ST_TO_ADDR
// end ; end ;
108315: GO 108144
108317: POP
108318: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108319: LD_VAR 0 1
108323: PPUSH
108324: LD_EXP 170
108328: PUSH
108329: LD_VAR 0 4
108333: ARRAY
108334: PUSH
108335: LD_INT 0
108337: PLUS
108338: PPUSH
108339: CALL_OW 505
// end ;
108343: LD_VAR 0 2
108347: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
108348: LD_INT 0
108350: PPUSH
108351: PPUSH
108352: PPUSH
108353: PPUSH
// if not hack in hackTanks then
108354: LD_VAR 0 1
108358: PUSH
108359: LD_EXP 169
108363: IN
108364: NOT
108365: IFFALSE 108369
// exit ;
108367: GO 108454
// index := GetElementIndex ( hackTanks , hack ) ;
108369: LD_ADDR_VAR 0 5
108373: PUSH
108374: LD_EXP 169
108378: PPUSH
108379: LD_VAR 0 1
108383: PPUSH
108384: CALL 21182 0 2
108388: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
108389: LD_ADDR_VAR 0 4
108393: PUSH
108394: DOUBLE
108395: LD_INT 1
108397: DEC
108398: ST_TO_ADDR
108399: LD_EXP 170
108403: PUSH
108404: LD_VAR 0 5
108408: ARRAY
108409: PUSH
108410: FOR_TO
108411: IFFALSE 108452
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
108413: LD_EXP 170
108417: PUSH
108418: LD_VAR 0 5
108422: ARRAY
108423: PUSH
108424: LD_VAR 0 4
108428: ARRAY
108429: PUSH
108430: LD_INT 1
108432: ARRAY
108433: PUSH
108434: LD_VAR 0 2
108438: EQUAL
108439: IFFALSE 108450
// KillUnit ( vehicle ) ;
108441: LD_VAR 0 2
108445: PPUSH
108446: CALL_OW 66
108450: GO 108410
108452: POP
108453: POP
// end ;
108454: LD_VAR 0 3
108458: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
108459: LD_EXP 174
108463: NOT
108464: IFFALSE 108499
108466: GO 108468
108468: DISABLE
// begin initMiner := true ;
108469: LD_ADDR_EXP 174
108473: PUSH
108474: LD_INT 1
108476: ST_TO_ADDR
// minersList := [ ] ;
108477: LD_ADDR_EXP 175
108481: PUSH
108482: EMPTY
108483: ST_TO_ADDR
// minerMinesList := [ ] ;
108484: LD_ADDR_EXP 176
108488: PUSH
108489: EMPTY
108490: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
108491: LD_ADDR_EXP 177
108495: PUSH
108496: LD_INT 5
108498: ST_TO_ADDR
// end ;
108499: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
108500: LD_EXP 174
108504: PUSH
108505: LD_INT 34
108507: PUSH
108508: LD_INT 81
108510: PUSH
108511: EMPTY
108512: LIST
108513: LIST
108514: PPUSH
108515: CALL_OW 69
108519: AND
108520: IFFALSE 108981
108522: GO 108524
108524: DISABLE
108525: LD_INT 0
108527: PPUSH
108528: PPUSH
108529: PPUSH
108530: PPUSH
// begin enable ;
108531: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
108532: LD_ADDR_VAR 0 1
108536: PUSH
108537: LD_INT 34
108539: PUSH
108540: LD_INT 81
108542: PUSH
108543: EMPTY
108544: LIST
108545: LIST
108546: PPUSH
108547: CALL_OW 69
108551: PUSH
108552: FOR_IN
108553: IFFALSE 108625
// begin if not i in minersList then
108555: LD_VAR 0 1
108559: PUSH
108560: LD_EXP 175
108564: IN
108565: NOT
108566: IFFALSE 108623
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
108568: LD_ADDR_EXP 175
108572: PUSH
108573: LD_EXP 175
108577: PPUSH
108578: LD_EXP 175
108582: PUSH
108583: LD_INT 1
108585: PLUS
108586: PPUSH
108587: LD_VAR 0 1
108591: PPUSH
108592: CALL_OW 1
108596: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
108597: LD_ADDR_EXP 176
108601: PUSH
108602: LD_EXP 176
108606: PPUSH
108607: LD_EXP 176
108611: PUSH
108612: LD_INT 1
108614: PLUS
108615: PPUSH
108616: EMPTY
108617: PPUSH
108618: CALL_OW 1
108622: ST_TO_ADDR
// end end ;
108623: GO 108552
108625: POP
108626: POP
// for i := minerMinesList downto 1 do
108627: LD_ADDR_VAR 0 1
108631: PUSH
108632: DOUBLE
108633: LD_EXP 176
108637: INC
108638: ST_TO_ADDR
108639: LD_INT 1
108641: PUSH
108642: FOR_DOWNTO
108643: IFFALSE 108979
// begin if IsLive ( minersList [ i ] ) then
108645: LD_EXP 175
108649: PUSH
108650: LD_VAR 0 1
108654: ARRAY
108655: PPUSH
108656: CALL_OW 300
108660: IFFALSE 108688
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
108662: LD_EXP 175
108666: PUSH
108667: LD_VAR 0 1
108671: ARRAY
108672: PPUSH
108673: LD_EXP 176
108677: PUSH
108678: LD_VAR 0 1
108682: ARRAY
108683: PPUSH
108684: CALL_OW 505
// if not minerMinesList [ i ] then
108688: LD_EXP 176
108692: PUSH
108693: LD_VAR 0 1
108697: ARRAY
108698: NOT
108699: IFFALSE 108703
// continue ;
108701: GO 108642
// for j := minerMinesList [ i ] downto 1 do
108703: LD_ADDR_VAR 0 2
108707: PUSH
108708: DOUBLE
108709: LD_EXP 176
108713: PUSH
108714: LD_VAR 0 1
108718: ARRAY
108719: INC
108720: ST_TO_ADDR
108721: LD_INT 1
108723: PUSH
108724: FOR_DOWNTO
108725: IFFALSE 108975
// begin side := GetSide ( minersList [ i ] ) ;
108727: LD_ADDR_VAR 0 3
108731: PUSH
108732: LD_EXP 175
108736: PUSH
108737: LD_VAR 0 1
108741: ARRAY
108742: PPUSH
108743: CALL_OW 255
108747: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
108748: LD_ADDR_VAR 0 4
108752: PUSH
108753: LD_EXP 176
108757: PUSH
108758: LD_VAR 0 1
108762: ARRAY
108763: PUSH
108764: LD_VAR 0 2
108768: ARRAY
108769: PUSH
108770: LD_INT 1
108772: ARRAY
108773: PPUSH
108774: LD_EXP 176
108778: PUSH
108779: LD_VAR 0 1
108783: ARRAY
108784: PUSH
108785: LD_VAR 0 2
108789: ARRAY
108790: PUSH
108791: LD_INT 2
108793: ARRAY
108794: PPUSH
108795: CALL_OW 428
108799: ST_TO_ADDR
// if not tmp then
108800: LD_VAR 0 4
108804: NOT
108805: IFFALSE 108809
// continue ;
108807: GO 108724
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
108809: LD_VAR 0 4
108813: PUSH
108814: LD_INT 81
108816: PUSH
108817: LD_VAR 0 3
108821: PUSH
108822: EMPTY
108823: LIST
108824: LIST
108825: PPUSH
108826: CALL_OW 69
108830: IN
108831: PUSH
108832: LD_EXP 176
108836: PUSH
108837: LD_VAR 0 1
108841: ARRAY
108842: PUSH
108843: LD_VAR 0 2
108847: ARRAY
108848: PUSH
108849: LD_INT 1
108851: ARRAY
108852: PPUSH
108853: LD_EXP 176
108857: PUSH
108858: LD_VAR 0 1
108862: ARRAY
108863: PUSH
108864: LD_VAR 0 2
108868: ARRAY
108869: PUSH
108870: LD_INT 2
108872: ARRAY
108873: PPUSH
108874: CALL_OW 458
108878: AND
108879: IFFALSE 108973
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
108881: LD_EXP 176
108885: PUSH
108886: LD_VAR 0 1
108890: ARRAY
108891: PUSH
108892: LD_VAR 0 2
108896: ARRAY
108897: PUSH
108898: LD_INT 1
108900: ARRAY
108901: PPUSH
108902: LD_EXP 176
108906: PUSH
108907: LD_VAR 0 1
108911: ARRAY
108912: PUSH
108913: LD_VAR 0 2
108917: ARRAY
108918: PUSH
108919: LD_INT 2
108921: ARRAY
108922: PPUSH
108923: LD_VAR 0 3
108927: PPUSH
108928: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
108932: LD_ADDR_EXP 176
108936: PUSH
108937: LD_EXP 176
108941: PPUSH
108942: LD_VAR 0 1
108946: PPUSH
108947: LD_EXP 176
108951: PUSH
108952: LD_VAR 0 1
108956: ARRAY
108957: PPUSH
108958: LD_VAR 0 2
108962: PPUSH
108963: CALL_OW 3
108967: PPUSH
108968: CALL_OW 1
108972: ST_TO_ADDR
// end ; end ;
108973: GO 108724
108975: POP
108976: POP
// end ;
108977: GO 108642
108979: POP
108980: POP
// end ;
108981: PPOPN 4
108983: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
108984: LD_INT 0
108986: PPUSH
108987: PPUSH
// result := false ;
108988: LD_ADDR_VAR 0 4
108992: PUSH
108993: LD_INT 0
108995: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
108996: LD_VAR 0 1
109000: PPUSH
109001: CALL_OW 264
109005: PUSH
109006: LD_INT 81
109008: EQUAL
109009: NOT
109010: IFFALSE 109014
// exit ;
109012: GO 109254
// index := GetElementIndex ( minersList , unit ) ;
109014: LD_ADDR_VAR 0 5
109018: PUSH
109019: LD_EXP 175
109023: PPUSH
109024: LD_VAR 0 1
109028: PPUSH
109029: CALL 21182 0 2
109033: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
109034: LD_EXP 176
109038: PUSH
109039: LD_VAR 0 5
109043: ARRAY
109044: PUSH
109045: LD_EXP 177
109049: GREATEREQUAL
109050: IFFALSE 109054
// exit ;
109052: GO 109254
// ComMoveXY ( unit , x , y ) ;
109054: LD_VAR 0 1
109058: PPUSH
109059: LD_VAR 0 2
109063: PPUSH
109064: LD_VAR 0 3
109068: PPUSH
109069: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109073: LD_INT 35
109075: PPUSH
109076: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
109080: LD_VAR 0 1
109084: PPUSH
109085: LD_VAR 0 2
109089: PPUSH
109090: LD_VAR 0 3
109094: PPUSH
109095: CALL 52923 0 3
109099: NOT
109100: PUSH
109101: LD_VAR 0 1
109105: PPUSH
109106: CALL_OW 314
109110: AND
109111: IFFALSE 109115
// exit ;
109113: GO 109254
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
109115: LD_VAR 0 2
109119: PPUSH
109120: LD_VAR 0 3
109124: PPUSH
109125: CALL_OW 428
109129: PUSH
109130: LD_VAR 0 1
109134: EQUAL
109135: PUSH
109136: LD_VAR 0 1
109140: PPUSH
109141: CALL_OW 314
109145: NOT
109146: AND
109147: IFFALSE 109073
// PlaySoundXY ( x , y , PlantMine ) ;
109149: LD_VAR 0 2
109153: PPUSH
109154: LD_VAR 0 3
109158: PPUSH
109159: LD_STRING PlantMine
109161: PPUSH
109162: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
109166: LD_VAR 0 2
109170: PPUSH
109171: LD_VAR 0 3
109175: PPUSH
109176: LD_VAR 0 1
109180: PPUSH
109181: CALL_OW 255
109185: PPUSH
109186: LD_INT 0
109188: PPUSH
109189: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
109193: LD_ADDR_EXP 176
109197: PUSH
109198: LD_EXP 176
109202: PPUSH
109203: LD_VAR 0 5
109207: PUSH
109208: LD_EXP 176
109212: PUSH
109213: LD_VAR 0 5
109217: ARRAY
109218: PUSH
109219: LD_INT 1
109221: PLUS
109222: PUSH
109223: EMPTY
109224: LIST
109225: LIST
109226: PPUSH
109227: LD_VAR 0 2
109231: PUSH
109232: LD_VAR 0 3
109236: PUSH
109237: EMPTY
109238: LIST
109239: LIST
109240: PPUSH
109241: CALL 21397 0 3
109245: ST_TO_ADDR
// result := true ;
109246: LD_ADDR_VAR 0 4
109250: PUSH
109251: LD_INT 1
109253: ST_TO_ADDR
// end ;
109254: LD_VAR 0 4
109258: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
109259: LD_INT 0
109261: PPUSH
109262: PPUSH
109263: PPUSH
// if not unit in minersList then
109264: LD_VAR 0 1
109268: PUSH
109269: LD_EXP 175
109273: IN
109274: NOT
109275: IFFALSE 109279
// exit ;
109277: GO 109671
// index := GetElementIndex ( minersList , unit ) ;
109279: LD_ADDR_VAR 0 6
109283: PUSH
109284: LD_EXP 175
109288: PPUSH
109289: LD_VAR 0 1
109293: PPUSH
109294: CALL 21182 0 2
109298: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
109299: LD_ADDR_VAR 0 5
109303: PUSH
109304: DOUBLE
109305: LD_EXP 176
109309: PUSH
109310: LD_VAR 0 6
109314: ARRAY
109315: INC
109316: ST_TO_ADDR
109317: LD_INT 1
109319: PUSH
109320: FOR_DOWNTO
109321: IFFALSE 109482
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
109323: LD_EXP 176
109327: PUSH
109328: LD_VAR 0 6
109332: ARRAY
109333: PUSH
109334: LD_VAR 0 5
109338: ARRAY
109339: PUSH
109340: LD_INT 1
109342: ARRAY
109343: PUSH
109344: LD_VAR 0 2
109348: EQUAL
109349: PUSH
109350: LD_EXP 176
109354: PUSH
109355: LD_VAR 0 6
109359: ARRAY
109360: PUSH
109361: LD_VAR 0 5
109365: ARRAY
109366: PUSH
109367: LD_INT 2
109369: ARRAY
109370: PUSH
109371: LD_VAR 0 3
109375: EQUAL
109376: AND
109377: IFFALSE 109480
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109379: LD_EXP 176
109383: PUSH
109384: LD_VAR 0 6
109388: ARRAY
109389: PUSH
109390: LD_VAR 0 5
109394: ARRAY
109395: PUSH
109396: LD_INT 1
109398: ARRAY
109399: PPUSH
109400: LD_EXP 176
109404: PUSH
109405: LD_VAR 0 6
109409: ARRAY
109410: PUSH
109411: LD_VAR 0 5
109415: ARRAY
109416: PUSH
109417: LD_INT 2
109419: ARRAY
109420: PPUSH
109421: LD_VAR 0 1
109425: PPUSH
109426: CALL_OW 255
109430: PPUSH
109431: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109435: LD_ADDR_EXP 176
109439: PUSH
109440: LD_EXP 176
109444: PPUSH
109445: LD_VAR 0 6
109449: PPUSH
109450: LD_EXP 176
109454: PUSH
109455: LD_VAR 0 6
109459: ARRAY
109460: PPUSH
109461: LD_VAR 0 5
109465: PPUSH
109466: CALL_OW 3
109470: PPUSH
109471: CALL_OW 1
109475: ST_TO_ADDR
// exit ;
109476: POP
109477: POP
109478: GO 109671
// end ; end ;
109480: GO 109320
109482: POP
109483: POP
// for i := minerMinesList [ index ] downto 1 do
109484: LD_ADDR_VAR 0 5
109488: PUSH
109489: DOUBLE
109490: LD_EXP 176
109494: PUSH
109495: LD_VAR 0 6
109499: ARRAY
109500: INC
109501: ST_TO_ADDR
109502: LD_INT 1
109504: PUSH
109505: FOR_DOWNTO
109506: IFFALSE 109669
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
109508: LD_EXP 176
109512: PUSH
109513: LD_VAR 0 6
109517: ARRAY
109518: PUSH
109519: LD_VAR 0 5
109523: ARRAY
109524: PUSH
109525: LD_INT 1
109527: ARRAY
109528: PPUSH
109529: LD_EXP 176
109533: PUSH
109534: LD_VAR 0 6
109538: ARRAY
109539: PUSH
109540: LD_VAR 0 5
109544: ARRAY
109545: PUSH
109546: LD_INT 2
109548: ARRAY
109549: PPUSH
109550: LD_VAR 0 2
109554: PPUSH
109555: LD_VAR 0 3
109559: PPUSH
109560: CALL_OW 298
109564: PUSH
109565: LD_INT 6
109567: LESS
109568: IFFALSE 109667
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109570: LD_EXP 176
109574: PUSH
109575: LD_VAR 0 6
109579: ARRAY
109580: PUSH
109581: LD_VAR 0 5
109585: ARRAY
109586: PUSH
109587: LD_INT 1
109589: ARRAY
109590: PPUSH
109591: LD_EXP 176
109595: PUSH
109596: LD_VAR 0 6
109600: ARRAY
109601: PUSH
109602: LD_VAR 0 5
109606: ARRAY
109607: PUSH
109608: LD_INT 2
109610: ARRAY
109611: PPUSH
109612: LD_VAR 0 1
109616: PPUSH
109617: CALL_OW 255
109621: PPUSH
109622: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109626: LD_ADDR_EXP 176
109630: PUSH
109631: LD_EXP 176
109635: PPUSH
109636: LD_VAR 0 6
109640: PPUSH
109641: LD_EXP 176
109645: PUSH
109646: LD_VAR 0 6
109650: ARRAY
109651: PPUSH
109652: LD_VAR 0 5
109656: PPUSH
109657: CALL_OW 3
109661: PPUSH
109662: CALL_OW 1
109666: ST_TO_ADDR
// end ; end ;
109667: GO 109505
109669: POP
109670: POP
// end ;
109671: LD_VAR 0 4
109675: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
109676: LD_INT 0
109678: PPUSH
109679: PPUSH
109680: PPUSH
109681: PPUSH
109682: PPUSH
109683: PPUSH
109684: PPUSH
109685: PPUSH
109686: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
109687: LD_VAR 0 1
109691: PPUSH
109692: CALL_OW 264
109696: PUSH
109697: LD_INT 81
109699: EQUAL
109700: NOT
109701: PUSH
109702: LD_VAR 0 1
109706: PUSH
109707: LD_EXP 175
109711: IN
109712: NOT
109713: OR
109714: IFFALSE 109718
// exit ;
109716: GO 110040
// index := GetElementIndex ( minersList , unit ) ;
109718: LD_ADDR_VAR 0 6
109722: PUSH
109723: LD_EXP 175
109727: PPUSH
109728: LD_VAR 0 1
109732: PPUSH
109733: CALL 21182 0 2
109737: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
109738: LD_ADDR_VAR 0 8
109742: PUSH
109743: LD_EXP 177
109747: PUSH
109748: LD_EXP 176
109752: PUSH
109753: LD_VAR 0 6
109757: ARRAY
109758: MINUS
109759: ST_TO_ADDR
// if not minesFreeAmount then
109760: LD_VAR 0 8
109764: NOT
109765: IFFALSE 109769
// exit ;
109767: GO 110040
// tmp := [ ] ;
109769: LD_ADDR_VAR 0 7
109773: PUSH
109774: EMPTY
109775: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
109776: LD_ADDR_VAR 0 5
109780: PUSH
109781: DOUBLE
109782: LD_INT 1
109784: DEC
109785: ST_TO_ADDR
109786: LD_VAR 0 8
109790: PUSH
109791: FOR_TO
109792: IFFALSE 109987
// begin _d := rand ( 0 , 5 ) ;
109794: LD_ADDR_VAR 0 11
109798: PUSH
109799: LD_INT 0
109801: PPUSH
109802: LD_INT 5
109804: PPUSH
109805: CALL_OW 12
109809: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
109810: LD_ADDR_VAR 0 12
109814: PUSH
109815: LD_INT 2
109817: PPUSH
109818: LD_INT 6
109820: PPUSH
109821: CALL_OW 12
109825: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
109826: LD_ADDR_VAR 0 9
109830: PUSH
109831: LD_VAR 0 2
109835: PPUSH
109836: LD_VAR 0 11
109840: PPUSH
109841: LD_VAR 0 12
109845: PPUSH
109846: CALL_OW 272
109850: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
109851: LD_ADDR_VAR 0 10
109855: PUSH
109856: LD_VAR 0 3
109860: PPUSH
109861: LD_VAR 0 11
109865: PPUSH
109866: LD_VAR 0 12
109870: PPUSH
109871: CALL_OW 273
109875: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
109876: LD_VAR 0 9
109880: PPUSH
109881: LD_VAR 0 10
109885: PPUSH
109886: CALL_OW 488
109890: PUSH
109891: LD_VAR 0 9
109895: PUSH
109896: LD_VAR 0 10
109900: PUSH
109901: EMPTY
109902: LIST
109903: LIST
109904: PUSH
109905: LD_VAR 0 7
109909: IN
109910: NOT
109911: AND
109912: PUSH
109913: LD_VAR 0 9
109917: PPUSH
109918: LD_VAR 0 10
109922: PPUSH
109923: CALL_OW 458
109927: NOT
109928: AND
109929: IFFALSE 109971
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
109931: LD_ADDR_VAR 0 7
109935: PUSH
109936: LD_VAR 0 7
109940: PPUSH
109941: LD_VAR 0 7
109945: PUSH
109946: LD_INT 1
109948: PLUS
109949: PPUSH
109950: LD_VAR 0 9
109954: PUSH
109955: LD_VAR 0 10
109959: PUSH
109960: EMPTY
109961: LIST
109962: LIST
109963: PPUSH
109964: CALL_OW 1
109968: ST_TO_ADDR
109969: GO 109985
// i := i - 1 ;
109971: LD_ADDR_VAR 0 5
109975: PUSH
109976: LD_VAR 0 5
109980: PUSH
109981: LD_INT 1
109983: MINUS
109984: ST_TO_ADDR
// end ;
109985: GO 109791
109987: POP
109988: POP
// for i in tmp do
109989: LD_ADDR_VAR 0 5
109993: PUSH
109994: LD_VAR 0 7
109998: PUSH
109999: FOR_IN
110000: IFFALSE 110038
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
110002: LD_VAR 0 1
110006: PPUSH
110007: LD_VAR 0 5
110011: PUSH
110012: LD_INT 1
110014: ARRAY
110015: PPUSH
110016: LD_VAR 0 5
110020: PUSH
110021: LD_INT 2
110023: ARRAY
110024: PPUSH
110025: CALL 108984 0 3
110029: NOT
110030: IFFALSE 110036
// exit ;
110032: POP
110033: POP
110034: GO 110040
110036: GO 109999
110038: POP
110039: POP
// end ;
110040: LD_VAR 0 4
110044: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
110045: LD_INT 0
110047: PPUSH
110048: PPUSH
110049: PPUSH
110050: PPUSH
110051: PPUSH
110052: PPUSH
110053: PPUSH
// if not GetClass ( unit ) = class_sniper then
110054: LD_VAR 0 1
110058: PPUSH
110059: CALL_OW 257
110063: PUSH
110064: LD_INT 5
110066: EQUAL
110067: NOT
110068: IFFALSE 110072
// exit ;
110070: GO 110460
// dist := 8 ;
110072: LD_ADDR_VAR 0 5
110076: PUSH
110077: LD_INT 8
110079: ST_TO_ADDR
// viewRange := 12 ;
110080: LD_ADDR_VAR 0 7
110084: PUSH
110085: LD_INT 12
110087: ST_TO_ADDR
// side := GetSide ( unit ) ;
110088: LD_ADDR_VAR 0 6
110092: PUSH
110093: LD_VAR 0 1
110097: PPUSH
110098: CALL_OW 255
110102: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
110103: LD_INT 61
110105: PPUSH
110106: LD_VAR 0 6
110110: PPUSH
110111: CALL_OW 321
110115: PUSH
110116: LD_INT 2
110118: EQUAL
110119: IFFALSE 110129
// viewRange := 16 ;
110121: LD_ADDR_VAR 0 7
110125: PUSH
110126: LD_INT 16
110128: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
110129: LD_VAR 0 1
110133: PPUSH
110134: LD_VAR 0 2
110138: PPUSH
110139: LD_VAR 0 3
110143: PPUSH
110144: CALL_OW 297
110148: PUSH
110149: LD_VAR 0 5
110153: GREATER
110154: IFFALSE 110233
// begin ComMoveXY ( unit , x , y ) ;
110156: LD_VAR 0 1
110160: PPUSH
110161: LD_VAR 0 2
110165: PPUSH
110166: LD_VAR 0 3
110170: PPUSH
110171: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110175: LD_INT 35
110177: PPUSH
110178: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
110182: LD_VAR 0 1
110186: PPUSH
110187: LD_VAR 0 2
110191: PPUSH
110192: LD_VAR 0 3
110196: PPUSH
110197: CALL 52923 0 3
110201: NOT
110202: IFFALSE 110206
// exit ;
110204: GO 110460
// until GetDistUnitXY ( unit , x , y ) < dist ;
110206: LD_VAR 0 1
110210: PPUSH
110211: LD_VAR 0 2
110215: PPUSH
110216: LD_VAR 0 3
110220: PPUSH
110221: CALL_OW 297
110225: PUSH
110226: LD_VAR 0 5
110230: LESS
110231: IFFALSE 110175
// end ; ComTurnXY ( unit , x , y ) ;
110233: LD_VAR 0 1
110237: PPUSH
110238: LD_VAR 0 2
110242: PPUSH
110243: LD_VAR 0 3
110247: PPUSH
110248: CALL_OW 118
// wait ( 5 ) ;
110252: LD_INT 5
110254: PPUSH
110255: CALL_OW 67
// _d := GetDir ( unit ) ;
110259: LD_ADDR_VAR 0 10
110263: PUSH
110264: LD_VAR 0 1
110268: PPUSH
110269: CALL_OW 254
110273: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
110274: LD_ADDR_VAR 0 8
110278: PUSH
110279: LD_VAR 0 1
110283: PPUSH
110284: CALL_OW 250
110288: PPUSH
110289: LD_VAR 0 10
110293: PPUSH
110294: LD_VAR 0 5
110298: PPUSH
110299: CALL_OW 272
110303: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
110304: LD_ADDR_VAR 0 9
110308: PUSH
110309: LD_VAR 0 1
110313: PPUSH
110314: CALL_OW 251
110318: PPUSH
110319: LD_VAR 0 10
110323: PPUSH
110324: LD_VAR 0 5
110328: PPUSH
110329: CALL_OW 273
110333: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
110334: LD_VAR 0 8
110338: PPUSH
110339: LD_VAR 0 9
110343: PPUSH
110344: CALL_OW 488
110348: NOT
110349: IFFALSE 110353
// exit ;
110351: GO 110460
// ComAnimCustom ( unit , 1 ) ;
110353: LD_VAR 0 1
110357: PPUSH
110358: LD_INT 1
110360: PPUSH
110361: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
110365: LD_VAR 0 8
110369: PPUSH
110370: LD_VAR 0 9
110374: PPUSH
110375: LD_VAR 0 6
110379: PPUSH
110380: LD_VAR 0 7
110384: PPUSH
110385: CALL_OW 330
// repeat wait ( 1 ) ;
110389: LD_INT 1
110391: PPUSH
110392: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
110396: LD_VAR 0 1
110400: PPUSH
110401: CALL_OW 316
110405: PUSH
110406: LD_VAR 0 1
110410: PPUSH
110411: CALL_OW 314
110415: OR
110416: PUSH
110417: LD_VAR 0 1
110421: PPUSH
110422: CALL_OW 302
110426: NOT
110427: OR
110428: PUSH
110429: LD_VAR 0 1
110433: PPUSH
110434: CALL_OW 301
110438: OR
110439: IFFALSE 110389
// RemoveSeeing ( _x , _y , side ) ;
110441: LD_VAR 0 8
110445: PPUSH
110446: LD_VAR 0 9
110450: PPUSH
110451: LD_VAR 0 6
110455: PPUSH
110456: CALL_OW 331
// end ; end_of_file
110460: LD_VAR 0 4
110464: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
110465: LD_INT 0
110467: PPUSH
110468: PPUSH
110469: PPUSH
110470: PPUSH
110471: PPUSH
110472: PPUSH
110473: PPUSH
110474: PPUSH
110475: PPUSH
110476: PPUSH
110477: PPUSH
110478: PPUSH
110479: PPUSH
110480: PPUSH
110481: PPUSH
110482: PPUSH
110483: PPUSH
110484: PPUSH
110485: PPUSH
110486: PPUSH
110487: PPUSH
110488: PPUSH
110489: PPUSH
110490: PPUSH
110491: PPUSH
110492: PPUSH
110493: PPUSH
110494: PPUSH
110495: PPUSH
110496: PPUSH
110497: PPUSH
110498: PPUSH
110499: PPUSH
110500: PPUSH
// if not list then
110501: LD_VAR 0 1
110505: NOT
110506: IFFALSE 110510
// exit ;
110508: GO 115169
// base := list [ 1 ] ;
110510: LD_ADDR_VAR 0 3
110514: PUSH
110515: LD_VAR 0 1
110519: PUSH
110520: LD_INT 1
110522: ARRAY
110523: ST_TO_ADDR
// group := list [ 2 ] ;
110524: LD_ADDR_VAR 0 4
110528: PUSH
110529: LD_VAR 0 1
110533: PUSH
110534: LD_INT 2
110536: ARRAY
110537: ST_TO_ADDR
// path := list [ 3 ] ;
110538: LD_ADDR_VAR 0 5
110542: PUSH
110543: LD_VAR 0 1
110547: PUSH
110548: LD_INT 3
110550: ARRAY
110551: ST_TO_ADDR
// flags := list [ 4 ] ;
110552: LD_ADDR_VAR 0 6
110556: PUSH
110557: LD_VAR 0 1
110561: PUSH
110562: LD_INT 4
110564: ARRAY
110565: ST_TO_ADDR
// mined := [ ] ;
110566: LD_ADDR_VAR 0 27
110570: PUSH
110571: EMPTY
110572: ST_TO_ADDR
// bombed := [ ] ;
110573: LD_ADDR_VAR 0 28
110577: PUSH
110578: EMPTY
110579: ST_TO_ADDR
// healers := [ ] ;
110580: LD_ADDR_VAR 0 31
110584: PUSH
110585: EMPTY
110586: ST_TO_ADDR
// to_heal := [ ] ;
110587: LD_ADDR_VAR 0 30
110591: PUSH
110592: EMPTY
110593: ST_TO_ADDR
// repairs := [ ] ;
110594: LD_ADDR_VAR 0 33
110598: PUSH
110599: EMPTY
110600: ST_TO_ADDR
// to_repair := [ ] ;
110601: LD_ADDR_VAR 0 32
110605: PUSH
110606: EMPTY
110607: ST_TO_ADDR
// if not group or not path then
110608: LD_VAR 0 4
110612: NOT
110613: PUSH
110614: LD_VAR 0 5
110618: NOT
110619: OR
110620: IFFALSE 110624
// exit ;
110622: GO 115169
// side := GetSide ( group [ 1 ] ) ;
110624: LD_ADDR_VAR 0 35
110628: PUSH
110629: LD_VAR 0 4
110633: PUSH
110634: LD_INT 1
110636: ARRAY
110637: PPUSH
110638: CALL_OW 255
110642: ST_TO_ADDR
// if flags then
110643: LD_VAR 0 6
110647: IFFALSE 110791
// begin f_ignore_area := flags [ 1 ] ;
110649: LD_ADDR_VAR 0 17
110653: PUSH
110654: LD_VAR 0 6
110658: PUSH
110659: LD_INT 1
110661: ARRAY
110662: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
110663: LD_ADDR_VAR 0 18
110667: PUSH
110668: LD_VAR 0 6
110672: PUSH
110673: LD_INT 2
110675: ARRAY
110676: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
110677: LD_ADDR_VAR 0 19
110681: PUSH
110682: LD_VAR 0 6
110686: PUSH
110687: LD_INT 3
110689: ARRAY
110690: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
110691: LD_ADDR_VAR 0 20
110695: PUSH
110696: LD_VAR 0 6
110700: PUSH
110701: LD_INT 4
110703: ARRAY
110704: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
110705: LD_ADDR_VAR 0 21
110709: PUSH
110710: LD_VAR 0 6
110714: PUSH
110715: LD_INT 5
110717: ARRAY
110718: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
110719: LD_ADDR_VAR 0 22
110723: PUSH
110724: LD_VAR 0 6
110728: PUSH
110729: LD_INT 6
110731: ARRAY
110732: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
110733: LD_ADDR_VAR 0 23
110737: PUSH
110738: LD_VAR 0 6
110742: PUSH
110743: LD_INT 7
110745: ARRAY
110746: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
110747: LD_ADDR_VAR 0 24
110751: PUSH
110752: LD_VAR 0 6
110756: PUSH
110757: LD_INT 8
110759: ARRAY
110760: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
110761: LD_ADDR_VAR 0 25
110765: PUSH
110766: LD_VAR 0 6
110770: PUSH
110771: LD_INT 9
110773: ARRAY
110774: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
110775: LD_ADDR_VAR 0 26
110779: PUSH
110780: LD_VAR 0 6
110784: PUSH
110785: LD_INT 10
110787: ARRAY
110788: ST_TO_ADDR
// end else
110789: GO 110871
// begin f_ignore_area := false ;
110791: LD_ADDR_VAR 0 17
110795: PUSH
110796: LD_INT 0
110798: ST_TO_ADDR
// f_capture := false ;
110799: LD_ADDR_VAR 0 18
110803: PUSH
110804: LD_INT 0
110806: ST_TO_ADDR
// f_ignore_civ := false ;
110807: LD_ADDR_VAR 0 19
110811: PUSH
110812: LD_INT 0
110814: ST_TO_ADDR
// f_murder := false ;
110815: LD_ADDR_VAR 0 20
110819: PUSH
110820: LD_INT 0
110822: ST_TO_ADDR
// f_mines := false ;
110823: LD_ADDR_VAR 0 21
110827: PUSH
110828: LD_INT 0
110830: ST_TO_ADDR
// f_repair := false ;
110831: LD_ADDR_VAR 0 22
110835: PUSH
110836: LD_INT 0
110838: ST_TO_ADDR
// f_heal := false ;
110839: LD_ADDR_VAR 0 23
110843: PUSH
110844: LD_INT 0
110846: ST_TO_ADDR
// f_spacetime := false ;
110847: LD_ADDR_VAR 0 24
110851: PUSH
110852: LD_INT 0
110854: ST_TO_ADDR
// f_attack_depot := false ;
110855: LD_ADDR_VAR 0 25
110859: PUSH
110860: LD_INT 0
110862: ST_TO_ADDR
// f_crawl := false ;
110863: LD_ADDR_VAR 0 26
110867: PUSH
110868: LD_INT 0
110870: ST_TO_ADDR
// end ; if f_heal then
110871: LD_VAR 0 23
110875: IFFALSE 110902
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
110877: LD_ADDR_VAR 0 31
110881: PUSH
110882: LD_VAR 0 4
110886: PPUSH
110887: LD_INT 25
110889: PUSH
110890: LD_INT 4
110892: PUSH
110893: EMPTY
110894: LIST
110895: LIST
110896: PPUSH
110897: CALL_OW 72
110901: ST_TO_ADDR
// if f_repair then
110902: LD_VAR 0 22
110906: IFFALSE 110933
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
110908: LD_ADDR_VAR 0 33
110912: PUSH
110913: LD_VAR 0 4
110917: PPUSH
110918: LD_INT 25
110920: PUSH
110921: LD_INT 3
110923: PUSH
110924: EMPTY
110925: LIST
110926: LIST
110927: PPUSH
110928: CALL_OW 72
110932: ST_TO_ADDR
// units_path := [ ] ;
110933: LD_ADDR_VAR 0 16
110937: PUSH
110938: EMPTY
110939: ST_TO_ADDR
// for i = 1 to group do
110940: LD_ADDR_VAR 0 7
110944: PUSH
110945: DOUBLE
110946: LD_INT 1
110948: DEC
110949: ST_TO_ADDR
110950: LD_VAR 0 4
110954: PUSH
110955: FOR_TO
110956: IFFALSE 110985
// units_path := Replace ( units_path , i , path ) ;
110958: LD_ADDR_VAR 0 16
110962: PUSH
110963: LD_VAR 0 16
110967: PPUSH
110968: LD_VAR 0 7
110972: PPUSH
110973: LD_VAR 0 5
110977: PPUSH
110978: CALL_OW 1
110982: ST_TO_ADDR
110983: GO 110955
110985: POP
110986: POP
// repeat for i = group downto 1 do
110987: LD_ADDR_VAR 0 7
110991: PUSH
110992: DOUBLE
110993: LD_VAR 0 4
110997: INC
110998: ST_TO_ADDR
110999: LD_INT 1
111001: PUSH
111002: FOR_DOWNTO
111003: IFFALSE 115125
// begin wait ( 5 ) ;
111005: LD_INT 5
111007: PPUSH
111008: CALL_OW 67
// tmp := [ ] ;
111012: LD_ADDR_VAR 0 14
111016: PUSH
111017: EMPTY
111018: ST_TO_ADDR
// attacking := false ;
111019: LD_ADDR_VAR 0 29
111023: PUSH
111024: LD_INT 0
111026: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
111027: LD_VAR 0 4
111031: PUSH
111032: LD_VAR 0 7
111036: ARRAY
111037: PPUSH
111038: CALL_OW 301
111042: PUSH
111043: LD_VAR 0 4
111047: PUSH
111048: LD_VAR 0 7
111052: ARRAY
111053: NOT
111054: OR
111055: IFFALSE 111164
// begin if GetType ( group [ i ] ) = unit_human then
111057: LD_VAR 0 4
111061: PUSH
111062: LD_VAR 0 7
111066: ARRAY
111067: PPUSH
111068: CALL_OW 247
111072: PUSH
111073: LD_INT 1
111075: EQUAL
111076: IFFALSE 111122
// begin to_heal := to_heal diff group [ i ] ;
111078: LD_ADDR_VAR 0 30
111082: PUSH
111083: LD_VAR 0 30
111087: PUSH
111088: LD_VAR 0 4
111092: PUSH
111093: LD_VAR 0 7
111097: ARRAY
111098: DIFF
111099: ST_TO_ADDR
// healers := healers diff group [ i ] ;
111100: LD_ADDR_VAR 0 31
111104: PUSH
111105: LD_VAR 0 31
111109: PUSH
111110: LD_VAR 0 4
111114: PUSH
111115: LD_VAR 0 7
111119: ARRAY
111120: DIFF
111121: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
111122: LD_ADDR_VAR 0 4
111126: PUSH
111127: LD_VAR 0 4
111131: PPUSH
111132: LD_VAR 0 7
111136: PPUSH
111137: CALL_OW 3
111141: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
111142: LD_ADDR_VAR 0 16
111146: PUSH
111147: LD_VAR 0 16
111151: PPUSH
111152: LD_VAR 0 7
111156: PPUSH
111157: CALL_OW 3
111161: ST_TO_ADDR
// continue ;
111162: GO 111002
// end ; if f_repair then
111164: LD_VAR 0 22
111168: IFFALSE 111657
// begin if GetType ( group [ i ] ) = unit_vehicle then
111170: LD_VAR 0 4
111174: PUSH
111175: LD_VAR 0 7
111179: ARRAY
111180: PPUSH
111181: CALL_OW 247
111185: PUSH
111186: LD_INT 2
111188: EQUAL
111189: IFFALSE 111379
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
111191: LD_VAR 0 4
111195: PUSH
111196: LD_VAR 0 7
111200: ARRAY
111201: PPUSH
111202: CALL_OW 256
111206: PUSH
111207: LD_INT 700
111209: LESS
111210: PUSH
111211: LD_VAR 0 4
111215: PUSH
111216: LD_VAR 0 7
111220: ARRAY
111221: PUSH
111222: LD_VAR 0 32
111226: IN
111227: NOT
111228: AND
111229: IFFALSE 111253
// to_repair := to_repair union group [ i ] ;
111231: LD_ADDR_VAR 0 32
111235: PUSH
111236: LD_VAR 0 32
111240: PUSH
111241: LD_VAR 0 4
111245: PUSH
111246: LD_VAR 0 7
111250: ARRAY
111251: UNION
111252: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
111253: LD_VAR 0 4
111257: PUSH
111258: LD_VAR 0 7
111262: ARRAY
111263: PPUSH
111264: CALL_OW 256
111268: PUSH
111269: LD_INT 1000
111271: EQUAL
111272: PUSH
111273: LD_VAR 0 4
111277: PUSH
111278: LD_VAR 0 7
111282: ARRAY
111283: PUSH
111284: LD_VAR 0 32
111288: IN
111289: AND
111290: IFFALSE 111314
// to_repair := to_repair diff group [ i ] ;
111292: LD_ADDR_VAR 0 32
111296: PUSH
111297: LD_VAR 0 32
111301: PUSH
111302: LD_VAR 0 4
111306: PUSH
111307: LD_VAR 0 7
111311: ARRAY
111312: DIFF
111313: ST_TO_ADDR
// if group [ i ] in to_repair then
111314: LD_VAR 0 4
111318: PUSH
111319: LD_VAR 0 7
111323: ARRAY
111324: PUSH
111325: LD_VAR 0 32
111329: IN
111330: IFFALSE 111377
// begin if not IsInArea ( group [ i ] , f_repair ) then
111332: LD_VAR 0 4
111336: PUSH
111337: LD_VAR 0 7
111341: ARRAY
111342: PPUSH
111343: LD_VAR 0 22
111347: PPUSH
111348: CALL_OW 308
111352: NOT
111353: IFFALSE 111375
// ComMoveToArea ( group [ i ] , f_repair ) ;
111355: LD_VAR 0 4
111359: PUSH
111360: LD_VAR 0 7
111364: ARRAY
111365: PPUSH
111366: LD_VAR 0 22
111370: PPUSH
111371: CALL_OW 113
// continue ;
111375: GO 111002
// end ; end else
111377: GO 111657
// if group [ i ] in repairs then
111379: LD_VAR 0 4
111383: PUSH
111384: LD_VAR 0 7
111388: ARRAY
111389: PUSH
111390: LD_VAR 0 33
111394: IN
111395: IFFALSE 111657
// begin if IsInUnit ( group [ i ] ) then
111397: LD_VAR 0 4
111401: PUSH
111402: LD_VAR 0 7
111406: ARRAY
111407: PPUSH
111408: CALL_OW 310
111412: IFFALSE 111480
// begin z := IsInUnit ( group [ i ] ) ;
111414: LD_ADDR_VAR 0 13
111418: PUSH
111419: LD_VAR 0 4
111423: PUSH
111424: LD_VAR 0 7
111428: ARRAY
111429: PPUSH
111430: CALL_OW 310
111434: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
111435: LD_VAR 0 13
111439: PUSH
111440: LD_VAR 0 32
111444: IN
111445: PUSH
111446: LD_VAR 0 13
111450: PPUSH
111451: LD_VAR 0 22
111455: PPUSH
111456: CALL_OW 308
111460: AND
111461: IFFALSE 111478
// ComExitVehicle ( group [ i ] ) ;
111463: LD_VAR 0 4
111467: PUSH
111468: LD_VAR 0 7
111472: ARRAY
111473: PPUSH
111474: CALL_OW 121
// end else
111478: GO 111657
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
111480: LD_ADDR_VAR 0 13
111484: PUSH
111485: LD_VAR 0 4
111489: PPUSH
111490: LD_INT 95
111492: PUSH
111493: LD_VAR 0 22
111497: PUSH
111498: EMPTY
111499: LIST
111500: LIST
111501: PUSH
111502: LD_INT 58
111504: PUSH
111505: EMPTY
111506: LIST
111507: PUSH
111508: EMPTY
111509: LIST
111510: LIST
111511: PPUSH
111512: CALL_OW 72
111516: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
111517: LD_VAR 0 4
111521: PUSH
111522: LD_VAR 0 7
111526: ARRAY
111527: PPUSH
111528: CALL_OW 314
111532: NOT
111533: IFFALSE 111655
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
111535: LD_ADDR_VAR 0 10
111539: PUSH
111540: LD_VAR 0 13
111544: PPUSH
111545: LD_VAR 0 4
111549: PUSH
111550: LD_VAR 0 7
111554: ARRAY
111555: PPUSH
111556: CALL_OW 74
111560: ST_TO_ADDR
// if not x then
111561: LD_VAR 0 10
111565: NOT
111566: IFFALSE 111570
// continue ;
111568: GO 111002
// if GetLives ( x ) < 1000 then
111570: LD_VAR 0 10
111574: PPUSH
111575: CALL_OW 256
111579: PUSH
111580: LD_INT 1000
111582: LESS
111583: IFFALSE 111607
// ComRepairVehicle ( group [ i ] , x ) else
111585: LD_VAR 0 4
111589: PUSH
111590: LD_VAR 0 7
111594: ARRAY
111595: PPUSH
111596: LD_VAR 0 10
111600: PPUSH
111601: CALL_OW 129
111605: GO 111655
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
111607: LD_VAR 0 23
111611: PUSH
111612: LD_VAR 0 4
111616: PUSH
111617: LD_VAR 0 7
111621: ARRAY
111622: PPUSH
111623: CALL_OW 256
111627: PUSH
111628: LD_INT 1000
111630: LESS
111631: AND
111632: NOT
111633: IFFALSE 111655
// ComEnterUnit ( group [ i ] , x ) ;
111635: LD_VAR 0 4
111639: PUSH
111640: LD_VAR 0 7
111644: ARRAY
111645: PPUSH
111646: LD_VAR 0 10
111650: PPUSH
111651: CALL_OW 120
// end ; continue ;
111655: GO 111002
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
111657: LD_VAR 0 23
111661: PUSH
111662: LD_VAR 0 4
111666: PUSH
111667: LD_VAR 0 7
111671: ARRAY
111672: PPUSH
111673: CALL_OW 247
111677: PUSH
111678: LD_INT 1
111680: EQUAL
111681: AND
111682: IFFALSE 112160
// begin if group [ i ] in healers then
111684: LD_VAR 0 4
111688: PUSH
111689: LD_VAR 0 7
111693: ARRAY
111694: PUSH
111695: LD_VAR 0 31
111699: IN
111700: IFFALSE 111973
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
111702: LD_VAR 0 4
111706: PUSH
111707: LD_VAR 0 7
111711: ARRAY
111712: PPUSH
111713: LD_VAR 0 23
111717: PPUSH
111718: CALL_OW 308
111722: NOT
111723: PUSH
111724: LD_VAR 0 4
111728: PUSH
111729: LD_VAR 0 7
111733: ARRAY
111734: PPUSH
111735: CALL_OW 314
111739: NOT
111740: AND
111741: IFFALSE 111765
// ComMoveToArea ( group [ i ] , f_heal ) else
111743: LD_VAR 0 4
111747: PUSH
111748: LD_VAR 0 7
111752: ARRAY
111753: PPUSH
111754: LD_VAR 0 23
111758: PPUSH
111759: CALL_OW 113
111763: GO 111971
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
111765: LD_VAR 0 4
111769: PUSH
111770: LD_VAR 0 7
111774: ARRAY
111775: PPUSH
111776: CALL 51506 0 1
111780: PPUSH
111781: CALL_OW 256
111785: PUSH
111786: LD_INT 1000
111788: EQUAL
111789: IFFALSE 111808
// ComStop ( group [ i ] ) else
111791: LD_VAR 0 4
111795: PUSH
111796: LD_VAR 0 7
111800: ARRAY
111801: PPUSH
111802: CALL_OW 141
111806: GO 111971
// if not HasTask ( group [ i ] ) and to_heal then
111808: LD_VAR 0 4
111812: PUSH
111813: LD_VAR 0 7
111817: ARRAY
111818: PPUSH
111819: CALL_OW 314
111823: NOT
111824: PUSH
111825: LD_VAR 0 30
111829: AND
111830: IFFALSE 111971
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
111832: LD_ADDR_VAR 0 13
111836: PUSH
111837: LD_VAR 0 30
111841: PPUSH
111842: LD_INT 3
111844: PUSH
111845: LD_INT 54
111847: PUSH
111848: EMPTY
111849: LIST
111850: PUSH
111851: EMPTY
111852: LIST
111853: LIST
111854: PPUSH
111855: CALL_OW 72
111859: PPUSH
111860: LD_VAR 0 4
111864: PUSH
111865: LD_VAR 0 7
111869: ARRAY
111870: PPUSH
111871: CALL_OW 74
111875: ST_TO_ADDR
// if z then
111876: LD_VAR 0 13
111880: IFFALSE 111971
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
111882: LD_INT 91
111884: PUSH
111885: LD_VAR 0 13
111889: PUSH
111890: LD_INT 10
111892: PUSH
111893: EMPTY
111894: LIST
111895: LIST
111896: LIST
111897: PUSH
111898: LD_INT 81
111900: PUSH
111901: LD_VAR 0 13
111905: PPUSH
111906: CALL_OW 255
111910: PUSH
111911: EMPTY
111912: LIST
111913: LIST
111914: PUSH
111915: EMPTY
111916: LIST
111917: LIST
111918: PPUSH
111919: CALL_OW 69
111923: PUSH
111924: LD_INT 0
111926: EQUAL
111927: IFFALSE 111951
// ComHeal ( group [ i ] , z ) else
111929: LD_VAR 0 4
111933: PUSH
111934: LD_VAR 0 7
111938: ARRAY
111939: PPUSH
111940: LD_VAR 0 13
111944: PPUSH
111945: CALL_OW 128
111949: GO 111971
// ComMoveToArea ( group [ i ] , f_heal ) ;
111951: LD_VAR 0 4
111955: PUSH
111956: LD_VAR 0 7
111960: ARRAY
111961: PPUSH
111962: LD_VAR 0 23
111966: PPUSH
111967: CALL_OW 113
// end ; continue ;
111971: GO 111002
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
111973: LD_VAR 0 4
111977: PUSH
111978: LD_VAR 0 7
111982: ARRAY
111983: PPUSH
111984: CALL_OW 256
111988: PUSH
111989: LD_INT 700
111991: LESS
111992: PUSH
111993: LD_VAR 0 4
111997: PUSH
111998: LD_VAR 0 7
112002: ARRAY
112003: PUSH
112004: LD_VAR 0 30
112008: IN
112009: NOT
112010: AND
112011: IFFALSE 112035
// to_heal := to_heal union group [ i ] ;
112013: LD_ADDR_VAR 0 30
112017: PUSH
112018: LD_VAR 0 30
112022: PUSH
112023: LD_VAR 0 4
112027: PUSH
112028: LD_VAR 0 7
112032: ARRAY
112033: UNION
112034: ST_TO_ADDR
// if group [ i ] in to_heal then
112035: LD_VAR 0 4
112039: PUSH
112040: LD_VAR 0 7
112044: ARRAY
112045: PUSH
112046: LD_VAR 0 30
112050: IN
112051: IFFALSE 112160
// begin if GetLives ( group [ i ] ) = 1000 then
112053: LD_VAR 0 4
112057: PUSH
112058: LD_VAR 0 7
112062: ARRAY
112063: PPUSH
112064: CALL_OW 256
112068: PUSH
112069: LD_INT 1000
112071: EQUAL
112072: IFFALSE 112098
// to_heal := to_heal diff group [ i ] else
112074: LD_ADDR_VAR 0 30
112078: PUSH
112079: LD_VAR 0 30
112083: PUSH
112084: LD_VAR 0 4
112088: PUSH
112089: LD_VAR 0 7
112093: ARRAY
112094: DIFF
112095: ST_TO_ADDR
112096: GO 112160
// begin if not IsInArea ( group [ i ] , to_heal ) then
112098: LD_VAR 0 4
112102: PUSH
112103: LD_VAR 0 7
112107: ARRAY
112108: PPUSH
112109: LD_VAR 0 30
112113: PPUSH
112114: CALL_OW 308
112118: NOT
112119: IFFALSE 112143
// ComMoveToArea ( group [ i ] , f_heal ) else
112121: LD_VAR 0 4
112125: PUSH
112126: LD_VAR 0 7
112130: ARRAY
112131: PPUSH
112132: LD_VAR 0 23
112136: PPUSH
112137: CALL_OW 113
112141: GO 112158
// ComHold ( group [ i ] ) ;
112143: LD_VAR 0 4
112147: PUSH
112148: LD_VAR 0 7
112152: ARRAY
112153: PPUSH
112154: CALL_OW 140
// continue ;
112158: GO 111002
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
112160: LD_VAR 0 4
112164: PUSH
112165: LD_VAR 0 7
112169: ARRAY
112170: PPUSH
112171: LD_INT 10
112173: PPUSH
112174: CALL 49288 0 2
112178: NOT
112179: PUSH
112180: LD_VAR 0 16
112184: PUSH
112185: LD_VAR 0 7
112189: ARRAY
112190: PUSH
112191: EMPTY
112192: EQUAL
112193: NOT
112194: AND
112195: IFFALSE 112461
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
112197: LD_VAR 0 4
112201: PUSH
112202: LD_VAR 0 7
112206: ARRAY
112207: PPUSH
112208: CALL_OW 262
112212: PUSH
112213: LD_INT 1
112215: PUSH
112216: LD_INT 2
112218: PUSH
112219: EMPTY
112220: LIST
112221: LIST
112222: IN
112223: IFFALSE 112264
// if GetFuel ( group [ i ] ) < 10 then
112225: LD_VAR 0 4
112229: PUSH
112230: LD_VAR 0 7
112234: ARRAY
112235: PPUSH
112236: CALL_OW 261
112240: PUSH
112241: LD_INT 10
112243: LESS
112244: IFFALSE 112264
// SetFuel ( group [ i ] , 12 ) ;
112246: LD_VAR 0 4
112250: PUSH
112251: LD_VAR 0 7
112255: ARRAY
112256: PPUSH
112257: LD_INT 12
112259: PPUSH
112260: CALL_OW 240
// if units_path [ i ] then
112264: LD_VAR 0 16
112268: PUSH
112269: LD_VAR 0 7
112273: ARRAY
112274: IFFALSE 112459
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
112276: LD_VAR 0 4
112280: PUSH
112281: LD_VAR 0 7
112285: ARRAY
112286: PPUSH
112287: LD_VAR 0 16
112291: PUSH
112292: LD_VAR 0 7
112296: ARRAY
112297: PUSH
112298: LD_INT 1
112300: ARRAY
112301: PUSH
112302: LD_INT 1
112304: ARRAY
112305: PPUSH
112306: LD_VAR 0 16
112310: PUSH
112311: LD_VAR 0 7
112315: ARRAY
112316: PUSH
112317: LD_INT 1
112319: ARRAY
112320: PUSH
112321: LD_INT 2
112323: ARRAY
112324: PPUSH
112325: CALL_OW 297
112329: PUSH
112330: LD_INT 6
112332: GREATER
112333: IFFALSE 112408
// begin if not HasTask ( group [ i ] ) then
112335: LD_VAR 0 4
112339: PUSH
112340: LD_VAR 0 7
112344: ARRAY
112345: PPUSH
112346: CALL_OW 314
112350: NOT
112351: IFFALSE 112406
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
112353: LD_VAR 0 4
112357: PUSH
112358: LD_VAR 0 7
112362: ARRAY
112363: PPUSH
112364: LD_VAR 0 16
112368: PUSH
112369: LD_VAR 0 7
112373: ARRAY
112374: PUSH
112375: LD_INT 1
112377: ARRAY
112378: PUSH
112379: LD_INT 1
112381: ARRAY
112382: PPUSH
112383: LD_VAR 0 16
112387: PUSH
112388: LD_VAR 0 7
112392: ARRAY
112393: PUSH
112394: LD_INT 1
112396: ARRAY
112397: PUSH
112398: LD_INT 2
112400: ARRAY
112401: PPUSH
112402: CALL_OW 114
// end else
112406: GO 112459
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
112408: LD_ADDR_VAR 0 15
112412: PUSH
112413: LD_VAR 0 16
112417: PUSH
112418: LD_VAR 0 7
112422: ARRAY
112423: PPUSH
112424: LD_INT 1
112426: PPUSH
112427: CALL_OW 3
112431: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
112432: LD_ADDR_VAR 0 16
112436: PUSH
112437: LD_VAR 0 16
112441: PPUSH
112442: LD_VAR 0 7
112446: PPUSH
112447: LD_VAR 0 15
112451: PPUSH
112452: CALL_OW 1
112456: ST_TO_ADDR
// continue ;
112457: GO 111002
// end ; end ; end else
112459: GO 115123
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
112461: LD_ADDR_VAR 0 14
112465: PUSH
112466: LD_INT 81
112468: PUSH
112469: LD_VAR 0 4
112473: PUSH
112474: LD_VAR 0 7
112478: ARRAY
112479: PPUSH
112480: CALL_OW 255
112484: PUSH
112485: EMPTY
112486: LIST
112487: LIST
112488: PPUSH
112489: CALL_OW 69
112493: ST_TO_ADDR
// if not tmp then
112494: LD_VAR 0 14
112498: NOT
112499: IFFALSE 112503
// continue ;
112501: GO 111002
// if f_ignore_area then
112503: LD_VAR 0 17
112507: IFFALSE 112595
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
112509: LD_ADDR_VAR 0 15
112513: PUSH
112514: LD_VAR 0 14
112518: PPUSH
112519: LD_INT 3
112521: PUSH
112522: LD_INT 92
112524: PUSH
112525: LD_VAR 0 17
112529: PUSH
112530: LD_INT 1
112532: ARRAY
112533: PUSH
112534: LD_VAR 0 17
112538: PUSH
112539: LD_INT 2
112541: ARRAY
112542: PUSH
112543: LD_VAR 0 17
112547: PUSH
112548: LD_INT 3
112550: ARRAY
112551: PUSH
112552: EMPTY
112553: LIST
112554: LIST
112555: LIST
112556: LIST
112557: PUSH
112558: EMPTY
112559: LIST
112560: LIST
112561: PPUSH
112562: CALL_OW 72
112566: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112567: LD_VAR 0 14
112571: PUSH
112572: LD_VAR 0 15
112576: DIFF
112577: IFFALSE 112595
// tmp := tmp diff tmp2 ;
112579: LD_ADDR_VAR 0 14
112583: PUSH
112584: LD_VAR 0 14
112588: PUSH
112589: LD_VAR 0 15
112593: DIFF
112594: ST_TO_ADDR
// end ; if not f_murder then
112595: LD_VAR 0 20
112599: NOT
112600: IFFALSE 112658
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
112602: LD_ADDR_VAR 0 15
112606: PUSH
112607: LD_VAR 0 14
112611: PPUSH
112612: LD_INT 3
112614: PUSH
112615: LD_INT 50
112617: PUSH
112618: EMPTY
112619: LIST
112620: PUSH
112621: EMPTY
112622: LIST
112623: LIST
112624: PPUSH
112625: CALL_OW 72
112629: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112630: LD_VAR 0 14
112634: PUSH
112635: LD_VAR 0 15
112639: DIFF
112640: IFFALSE 112658
// tmp := tmp diff tmp2 ;
112642: LD_ADDR_VAR 0 14
112646: PUSH
112647: LD_VAR 0 14
112651: PUSH
112652: LD_VAR 0 15
112656: DIFF
112657: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
112658: LD_ADDR_VAR 0 14
112662: PUSH
112663: LD_VAR 0 4
112667: PUSH
112668: LD_VAR 0 7
112672: ARRAY
112673: PPUSH
112674: LD_VAR 0 14
112678: PPUSH
112679: LD_INT 1
112681: PPUSH
112682: LD_INT 1
112684: PPUSH
112685: CALL 21832 0 4
112689: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
112690: LD_VAR 0 4
112694: PUSH
112695: LD_VAR 0 7
112699: ARRAY
112700: PPUSH
112701: CALL_OW 257
112705: PUSH
112706: LD_INT 1
112708: EQUAL
112709: IFFALSE 113157
// begin if WantPlant ( group [ i ] ) then
112711: LD_VAR 0 4
112715: PUSH
112716: LD_VAR 0 7
112720: ARRAY
112721: PPUSH
112722: CALL 21333 0 1
112726: IFFALSE 112730
// continue ;
112728: GO 111002
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
112730: LD_VAR 0 18
112734: PUSH
112735: LD_VAR 0 4
112739: PUSH
112740: LD_VAR 0 7
112744: ARRAY
112745: PPUSH
112746: CALL_OW 310
112750: NOT
112751: AND
112752: PUSH
112753: LD_VAR 0 14
112757: PUSH
112758: LD_INT 1
112760: ARRAY
112761: PUSH
112762: LD_VAR 0 14
112766: PPUSH
112767: LD_INT 21
112769: PUSH
112770: LD_INT 2
112772: PUSH
112773: EMPTY
112774: LIST
112775: LIST
112776: PUSH
112777: LD_INT 58
112779: PUSH
112780: EMPTY
112781: LIST
112782: PUSH
112783: EMPTY
112784: LIST
112785: LIST
112786: PPUSH
112787: CALL_OW 72
112791: IN
112792: AND
112793: IFFALSE 112829
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
112795: LD_VAR 0 4
112799: PUSH
112800: LD_VAR 0 7
112804: ARRAY
112805: PPUSH
112806: LD_VAR 0 14
112810: PUSH
112811: LD_INT 1
112813: ARRAY
112814: PPUSH
112815: CALL_OW 120
// attacking := true ;
112819: LD_ADDR_VAR 0 29
112823: PUSH
112824: LD_INT 1
112826: ST_TO_ADDR
// continue ;
112827: GO 111002
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
112829: LD_VAR 0 26
112833: PUSH
112834: LD_VAR 0 4
112838: PUSH
112839: LD_VAR 0 7
112843: ARRAY
112844: PPUSH
112845: CALL_OW 257
112849: PUSH
112850: LD_INT 1
112852: EQUAL
112853: AND
112854: PUSH
112855: LD_VAR 0 4
112859: PUSH
112860: LD_VAR 0 7
112864: ARRAY
112865: PPUSH
112866: CALL_OW 256
112870: PUSH
112871: LD_INT 800
112873: LESS
112874: AND
112875: PUSH
112876: LD_VAR 0 4
112880: PUSH
112881: LD_VAR 0 7
112885: ARRAY
112886: PPUSH
112887: CALL_OW 318
112891: NOT
112892: AND
112893: IFFALSE 112910
// ComCrawl ( group [ i ] ) ;
112895: LD_VAR 0 4
112899: PUSH
112900: LD_VAR 0 7
112904: ARRAY
112905: PPUSH
112906: CALL_OW 137
// if f_mines then
112910: LD_VAR 0 21
112914: IFFALSE 113157
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
112916: LD_VAR 0 14
112920: PUSH
112921: LD_INT 1
112923: ARRAY
112924: PPUSH
112925: CALL_OW 247
112929: PUSH
112930: LD_INT 3
112932: EQUAL
112933: PUSH
112934: LD_VAR 0 14
112938: PUSH
112939: LD_INT 1
112941: ARRAY
112942: PUSH
112943: LD_VAR 0 27
112947: IN
112948: NOT
112949: AND
112950: IFFALSE 113157
// begin x := GetX ( tmp [ 1 ] ) ;
112952: LD_ADDR_VAR 0 10
112956: PUSH
112957: LD_VAR 0 14
112961: PUSH
112962: LD_INT 1
112964: ARRAY
112965: PPUSH
112966: CALL_OW 250
112970: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
112971: LD_ADDR_VAR 0 11
112975: PUSH
112976: LD_VAR 0 14
112980: PUSH
112981: LD_INT 1
112983: ARRAY
112984: PPUSH
112985: CALL_OW 251
112989: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
112990: LD_ADDR_VAR 0 12
112994: PUSH
112995: LD_VAR 0 4
112999: PUSH
113000: LD_VAR 0 7
113004: ARRAY
113005: PPUSH
113006: CALL 49373 0 1
113010: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
113011: LD_VAR 0 4
113015: PUSH
113016: LD_VAR 0 7
113020: ARRAY
113021: PPUSH
113022: LD_VAR 0 10
113026: PPUSH
113027: LD_VAR 0 11
113031: PPUSH
113032: LD_VAR 0 14
113036: PUSH
113037: LD_INT 1
113039: ARRAY
113040: PPUSH
113041: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
113045: LD_VAR 0 4
113049: PUSH
113050: LD_VAR 0 7
113054: ARRAY
113055: PPUSH
113056: LD_VAR 0 10
113060: PPUSH
113061: LD_VAR 0 12
113065: PPUSH
113066: LD_INT 7
113068: PPUSH
113069: CALL_OW 272
113073: PPUSH
113074: LD_VAR 0 11
113078: PPUSH
113079: LD_VAR 0 12
113083: PPUSH
113084: LD_INT 7
113086: PPUSH
113087: CALL_OW 273
113091: PPUSH
113092: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
113096: LD_VAR 0 4
113100: PUSH
113101: LD_VAR 0 7
113105: ARRAY
113106: PPUSH
113107: LD_INT 71
113109: PPUSH
113110: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
113114: LD_ADDR_VAR 0 27
113118: PUSH
113119: LD_VAR 0 27
113123: PPUSH
113124: LD_VAR 0 27
113128: PUSH
113129: LD_INT 1
113131: PLUS
113132: PPUSH
113133: LD_VAR 0 14
113137: PUSH
113138: LD_INT 1
113140: ARRAY
113141: PPUSH
113142: CALL_OW 1
113146: ST_TO_ADDR
// attacking := true ;
113147: LD_ADDR_VAR 0 29
113151: PUSH
113152: LD_INT 1
113154: ST_TO_ADDR
// continue ;
113155: GO 111002
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
113157: LD_VAR 0 4
113161: PUSH
113162: LD_VAR 0 7
113166: ARRAY
113167: PPUSH
113168: CALL_OW 257
113172: PUSH
113173: LD_INT 17
113175: EQUAL
113176: PUSH
113177: LD_VAR 0 4
113181: PUSH
113182: LD_VAR 0 7
113186: ARRAY
113187: PPUSH
113188: CALL_OW 110
113192: PUSH
113193: LD_INT 71
113195: EQUAL
113196: NOT
113197: AND
113198: IFFALSE 113344
// begin attacking := false ;
113200: LD_ADDR_VAR 0 29
113204: PUSH
113205: LD_INT 0
113207: ST_TO_ADDR
// k := 5 ;
113208: LD_ADDR_VAR 0 9
113212: PUSH
113213: LD_INT 5
113215: ST_TO_ADDR
// if tmp < k then
113216: LD_VAR 0 14
113220: PUSH
113221: LD_VAR 0 9
113225: LESS
113226: IFFALSE 113238
// k := tmp ;
113228: LD_ADDR_VAR 0 9
113232: PUSH
113233: LD_VAR 0 14
113237: ST_TO_ADDR
// for j = 1 to k do
113238: LD_ADDR_VAR 0 8
113242: PUSH
113243: DOUBLE
113244: LD_INT 1
113246: DEC
113247: ST_TO_ADDR
113248: LD_VAR 0 9
113252: PUSH
113253: FOR_TO
113254: IFFALSE 113342
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
113256: LD_VAR 0 14
113260: PUSH
113261: LD_VAR 0 8
113265: ARRAY
113266: PUSH
113267: LD_VAR 0 14
113271: PPUSH
113272: LD_INT 58
113274: PUSH
113275: EMPTY
113276: LIST
113277: PPUSH
113278: CALL_OW 72
113282: IN
113283: NOT
113284: IFFALSE 113340
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113286: LD_VAR 0 4
113290: PUSH
113291: LD_VAR 0 7
113295: ARRAY
113296: PPUSH
113297: LD_VAR 0 14
113301: PUSH
113302: LD_VAR 0 8
113306: ARRAY
113307: PPUSH
113308: CALL_OW 115
// attacking := true ;
113312: LD_ADDR_VAR 0 29
113316: PUSH
113317: LD_INT 1
113319: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
113320: LD_VAR 0 4
113324: PUSH
113325: LD_VAR 0 7
113329: ARRAY
113330: PPUSH
113331: LD_INT 71
113333: PPUSH
113334: CALL_OW 109
// continue ;
113338: GO 113253
// end ; end ;
113340: GO 113253
113342: POP
113343: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
113344: LD_VAR 0 4
113348: PUSH
113349: LD_VAR 0 7
113353: ARRAY
113354: PPUSH
113355: CALL_OW 257
113359: PUSH
113360: LD_INT 8
113362: EQUAL
113363: PUSH
113364: LD_VAR 0 4
113368: PUSH
113369: LD_VAR 0 7
113373: ARRAY
113374: PPUSH
113375: CALL_OW 264
113379: PUSH
113380: LD_INT 28
113382: PUSH
113383: LD_INT 45
113385: PUSH
113386: LD_INT 7
113388: PUSH
113389: LD_INT 47
113391: PUSH
113392: EMPTY
113393: LIST
113394: LIST
113395: LIST
113396: LIST
113397: IN
113398: OR
113399: IFFALSE 113655
// begin attacking := false ;
113401: LD_ADDR_VAR 0 29
113405: PUSH
113406: LD_INT 0
113408: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
113409: LD_VAR 0 14
113413: PUSH
113414: LD_INT 1
113416: ARRAY
113417: PPUSH
113418: CALL_OW 266
113422: PUSH
113423: LD_INT 32
113425: PUSH
113426: LD_INT 31
113428: PUSH
113429: LD_INT 33
113431: PUSH
113432: LD_INT 4
113434: PUSH
113435: LD_INT 5
113437: PUSH
113438: EMPTY
113439: LIST
113440: LIST
113441: LIST
113442: LIST
113443: LIST
113444: IN
113445: IFFALSE 113631
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
113447: LD_ADDR_VAR 0 9
113451: PUSH
113452: LD_VAR 0 14
113456: PUSH
113457: LD_INT 1
113459: ARRAY
113460: PPUSH
113461: CALL_OW 266
113465: PPUSH
113466: LD_VAR 0 14
113470: PUSH
113471: LD_INT 1
113473: ARRAY
113474: PPUSH
113475: CALL_OW 250
113479: PPUSH
113480: LD_VAR 0 14
113484: PUSH
113485: LD_INT 1
113487: ARRAY
113488: PPUSH
113489: CALL_OW 251
113493: PPUSH
113494: LD_VAR 0 14
113498: PUSH
113499: LD_INT 1
113501: ARRAY
113502: PPUSH
113503: CALL_OW 254
113507: PPUSH
113508: LD_VAR 0 14
113512: PUSH
113513: LD_INT 1
113515: ARRAY
113516: PPUSH
113517: CALL_OW 248
113521: PPUSH
113522: LD_INT 0
113524: PPUSH
113525: CALL 30743 0 6
113529: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
113530: LD_ADDR_VAR 0 8
113534: PUSH
113535: LD_VAR 0 4
113539: PUSH
113540: LD_VAR 0 7
113544: ARRAY
113545: PPUSH
113546: LD_VAR 0 9
113550: PPUSH
113551: CALL 49486 0 2
113555: ST_TO_ADDR
// if j then
113556: LD_VAR 0 8
113560: IFFALSE 113629
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
113562: LD_VAR 0 8
113566: PUSH
113567: LD_INT 1
113569: ARRAY
113570: PPUSH
113571: LD_VAR 0 8
113575: PUSH
113576: LD_INT 2
113578: ARRAY
113579: PPUSH
113580: CALL_OW 488
113584: IFFALSE 113629
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
113586: LD_VAR 0 4
113590: PUSH
113591: LD_VAR 0 7
113595: ARRAY
113596: PPUSH
113597: LD_VAR 0 8
113601: PUSH
113602: LD_INT 1
113604: ARRAY
113605: PPUSH
113606: LD_VAR 0 8
113610: PUSH
113611: LD_INT 2
113613: ARRAY
113614: PPUSH
113615: CALL_OW 116
// attacking := true ;
113619: LD_ADDR_VAR 0 29
113623: PUSH
113624: LD_INT 1
113626: ST_TO_ADDR
// continue ;
113627: GO 111002
// end ; end else
113629: GO 113655
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113631: LD_VAR 0 4
113635: PUSH
113636: LD_VAR 0 7
113640: ARRAY
113641: PPUSH
113642: LD_VAR 0 14
113646: PUSH
113647: LD_INT 1
113649: ARRAY
113650: PPUSH
113651: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
113655: LD_VAR 0 4
113659: PUSH
113660: LD_VAR 0 7
113664: ARRAY
113665: PPUSH
113666: CALL_OW 265
113670: PUSH
113671: LD_INT 11
113673: EQUAL
113674: IFFALSE 113952
// begin k := 10 ;
113676: LD_ADDR_VAR 0 9
113680: PUSH
113681: LD_INT 10
113683: ST_TO_ADDR
// x := 0 ;
113684: LD_ADDR_VAR 0 10
113688: PUSH
113689: LD_INT 0
113691: ST_TO_ADDR
// if tmp < k then
113692: LD_VAR 0 14
113696: PUSH
113697: LD_VAR 0 9
113701: LESS
113702: IFFALSE 113714
// k := tmp ;
113704: LD_ADDR_VAR 0 9
113708: PUSH
113709: LD_VAR 0 14
113713: ST_TO_ADDR
// for j = k downto 1 do
113714: LD_ADDR_VAR 0 8
113718: PUSH
113719: DOUBLE
113720: LD_VAR 0 9
113724: INC
113725: ST_TO_ADDR
113726: LD_INT 1
113728: PUSH
113729: FOR_DOWNTO
113730: IFFALSE 113805
// begin if GetType ( tmp [ j ] ) = unit_human then
113732: LD_VAR 0 14
113736: PUSH
113737: LD_VAR 0 8
113741: ARRAY
113742: PPUSH
113743: CALL_OW 247
113747: PUSH
113748: LD_INT 1
113750: EQUAL
113751: IFFALSE 113803
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
113753: LD_VAR 0 4
113757: PUSH
113758: LD_VAR 0 7
113762: ARRAY
113763: PPUSH
113764: LD_VAR 0 14
113768: PUSH
113769: LD_VAR 0 8
113773: ARRAY
113774: PPUSH
113775: CALL 49740 0 2
// x := tmp [ j ] ;
113779: LD_ADDR_VAR 0 10
113783: PUSH
113784: LD_VAR 0 14
113788: PUSH
113789: LD_VAR 0 8
113793: ARRAY
113794: ST_TO_ADDR
// attacking := true ;
113795: LD_ADDR_VAR 0 29
113799: PUSH
113800: LD_INT 1
113802: ST_TO_ADDR
// end ; end ;
113803: GO 113729
113805: POP
113806: POP
// if not x then
113807: LD_VAR 0 10
113811: NOT
113812: IFFALSE 113952
// begin attacking := true ;
113814: LD_ADDR_VAR 0 29
113818: PUSH
113819: LD_INT 1
113821: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
113822: LD_VAR 0 4
113826: PUSH
113827: LD_VAR 0 7
113831: ARRAY
113832: PPUSH
113833: CALL_OW 250
113837: PPUSH
113838: LD_VAR 0 4
113842: PUSH
113843: LD_VAR 0 7
113847: ARRAY
113848: PPUSH
113849: CALL_OW 251
113853: PPUSH
113854: CALL_OW 546
113858: PUSH
113859: LD_INT 2
113861: ARRAY
113862: PUSH
113863: LD_VAR 0 14
113867: PUSH
113868: LD_INT 1
113870: ARRAY
113871: PPUSH
113872: CALL_OW 250
113876: PPUSH
113877: LD_VAR 0 14
113881: PUSH
113882: LD_INT 1
113884: ARRAY
113885: PPUSH
113886: CALL_OW 251
113890: PPUSH
113891: CALL_OW 546
113895: PUSH
113896: LD_INT 2
113898: ARRAY
113899: EQUAL
113900: IFFALSE 113928
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
113902: LD_VAR 0 4
113906: PUSH
113907: LD_VAR 0 7
113911: ARRAY
113912: PPUSH
113913: LD_VAR 0 14
113917: PUSH
113918: LD_INT 1
113920: ARRAY
113921: PPUSH
113922: CALL 49740 0 2
113926: GO 113952
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113928: LD_VAR 0 4
113932: PUSH
113933: LD_VAR 0 7
113937: ARRAY
113938: PPUSH
113939: LD_VAR 0 14
113943: PUSH
113944: LD_INT 1
113946: ARRAY
113947: PPUSH
113948: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
113952: LD_VAR 0 4
113956: PUSH
113957: LD_VAR 0 7
113961: ARRAY
113962: PPUSH
113963: CALL_OW 264
113967: PUSH
113968: LD_INT 29
113970: EQUAL
113971: IFFALSE 114337
// begin if WantsToAttack ( group [ i ] ) in bombed then
113973: LD_VAR 0 4
113977: PUSH
113978: LD_VAR 0 7
113982: ARRAY
113983: PPUSH
113984: CALL_OW 319
113988: PUSH
113989: LD_VAR 0 28
113993: IN
113994: IFFALSE 113998
// continue ;
113996: GO 111002
// k := 8 ;
113998: LD_ADDR_VAR 0 9
114002: PUSH
114003: LD_INT 8
114005: ST_TO_ADDR
// x := 0 ;
114006: LD_ADDR_VAR 0 10
114010: PUSH
114011: LD_INT 0
114013: ST_TO_ADDR
// if tmp < k then
114014: LD_VAR 0 14
114018: PUSH
114019: LD_VAR 0 9
114023: LESS
114024: IFFALSE 114036
// k := tmp ;
114026: LD_ADDR_VAR 0 9
114030: PUSH
114031: LD_VAR 0 14
114035: ST_TO_ADDR
// for j = 1 to k do
114036: LD_ADDR_VAR 0 8
114040: PUSH
114041: DOUBLE
114042: LD_INT 1
114044: DEC
114045: ST_TO_ADDR
114046: LD_VAR 0 9
114050: PUSH
114051: FOR_TO
114052: IFFALSE 114184
// begin if GetType ( tmp [ j ] ) = unit_building then
114054: LD_VAR 0 14
114058: PUSH
114059: LD_VAR 0 8
114063: ARRAY
114064: PPUSH
114065: CALL_OW 247
114069: PUSH
114070: LD_INT 3
114072: EQUAL
114073: IFFALSE 114182
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
114075: LD_VAR 0 14
114079: PUSH
114080: LD_VAR 0 8
114084: ARRAY
114085: PUSH
114086: LD_VAR 0 28
114090: IN
114091: NOT
114092: PUSH
114093: LD_VAR 0 14
114097: PUSH
114098: LD_VAR 0 8
114102: ARRAY
114103: PPUSH
114104: CALL_OW 313
114108: AND
114109: IFFALSE 114182
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114111: LD_VAR 0 4
114115: PUSH
114116: LD_VAR 0 7
114120: ARRAY
114121: PPUSH
114122: LD_VAR 0 14
114126: PUSH
114127: LD_VAR 0 8
114131: ARRAY
114132: PPUSH
114133: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
114137: LD_ADDR_VAR 0 28
114141: PUSH
114142: LD_VAR 0 28
114146: PPUSH
114147: LD_VAR 0 28
114151: PUSH
114152: LD_INT 1
114154: PLUS
114155: PPUSH
114156: LD_VAR 0 14
114160: PUSH
114161: LD_VAR 0 8
114165: ARRAY
114166: PPUSH
114167: CALL_OW 1
114171: ST_TO_ADDR
// attacking := true ;
114172: LD_ADDR_VAR 0 29
114176: PUSH
114177: LD_INT 1
114179: ST_TO_ADDR
// break ;
114180: GO 114184
// end ; end ;
114182: GO 114051
114184: POP
114185: POP
// if not attacking and f_attack_depot then
114186: LD_VAR 0 29
114190: NOT
114191: PUSH
114192: LD_VAR 0 25
114196: AND
114197: IFFALSE 114292
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
114199: LD_ADDR_VAR 0 13
114203: PUSH
114204: LD_VAR 0 14
114208: PPUSH
114209: LD_INT 2
114211: PUSH
114212: LD_INT 30
114214: PUSH
114215: LD_INT 0
114217: PUSH
114218: EMPTY
114219: LIST
114220: LIST
114221: PUSH
114222: LD_INT 30
114224: PUSH
114225: LD_INT 1
114227: PUSH
114228: EMPTY
114229: LIST
114230: LIST
114231: PUSH
114232: EMPTY
114233: LIST
114234: LIST
114235: LIST
114236: PPUSH
114237: CALL_OW 72
114241: ST_TO_ADDR
// if z then
114242: LD_VAR 0 13
114246: IFFALSE 114292
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
114248: LD_VAR 0 4
114252: PUSH
114253: LD_VAR 0 7
114257: ARRAY
114258: PPUSH
114259: LD_VAR 0 13
114263: PPUSH
114264: LD_VAR 0 4
114268: PUSH
114269: LD_VAR 0 7
114273: ARRAY
114274: PPUSH
114275: CALL_OW 74
114279: PPUSH
114280: CALL_OW 115
// attacking := true ;
114284: LD_ADDR_VAR 0 29
114288: PUSH
114289: LD_INT 1
114291: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
114292: LD_VAR 0 4
114296: PUSH
114297: LD_VAR 0 7
114301: ARRAY
114302: PPUSH
114303: CALL_OW 256
114307: PUSH
114308: LD_INT 500
114310: LESS
114311: IFFALSE 114337
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114313: LD_VAR 0 4
114317: PUSH
114318: LD_VAR 0 7
114322: ARRAY
114323: PPUSH
114324: LD_VAR 0 14
114328: PUSH
114329: LD_INT 1
114331: ARRAY
114332: PPUSH
114333: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
114337: LD_VAR 0 4
114341: PUSH
114342: LD_VAR 0 7
114346: ARRAY
114347: PPUSH
114348: CALL_OW 264
114352: PUSH
114353: LD_INT 49
114355: EQUAL
114356: IFFALSE 114477
// begin if not HasTask ( group [ i ] ) then
114358: LD_VAR 0 4
114362: PUSH
114363: LD_VAR 0 7
114367: ARRAY
114368: PPUSH
114369: CALL_OW 314
114373: NOT
114374: IFFALSE 114477
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
114376: LD_ADDR_VAR 0 9
114380: PUSH
114381: LD_INT 81
114383: PUSH
114384: LD_VAR 0 4
114388: PUSH
114389: LD_VAR 0 7
114393: ARRAY
114394: PPUSH
114395: CALL_OW 255
114399: PUSH
114400: EMPTY
114401: LIST
114402: LIST
114403: PPUSH
114404: CALL_OW 69
114408: PPUSH
114409: LD_VAR 0 4
114413: PUSH
114414: LD_VAR 0 7
114418: ARRAY
114419: PPUSH
114420: CALL_OW 74
114424: ST_TO_ADDR
// if k then
114425: LD_VAR 0 9
114429: IFFALSE 114477
// if GetDistUnits ( group [ i ] , k ) > 10 then
114431: LD_VAR 0 4
114435: PUSH
114436: LD_VAR 0 7
114440: ARRAY
114441: PPUSH
114442: LD_VAR 0 9
114446: PPUSH
114447: CALL_OW 296
114451: PUSH
114452: LD_INT 10
114454: GREATER
114455: IFFALSE 114477
// ComMoveUnit ( group [ i ] , k ) ;
114457: LD_VAR 0 4
114461: PUSH
114462: LD_VAR 0 7
114466: ARRAY
114467: PPUSH
114468: LD_VAR 0 9
114472: PPUSH
114473: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
114477: LD_VAR 0 4
114481: PUSH
114482: LD_VAR 0 7
114486: ARRAY
114487: PPUSH
114488: CALL_OW 256
114492: PUSH
114493: LD_INT 250
114495: LESS
114496: PUSH
114497: LD_VAR 0 4
114501: PUSH
114502: LD_VAR 0 7
114506: ARRAY
114507: PUSH
114508: LD_INT 21
114510: PUSH
114511: LD_INT 2
114513: PUSH
114514: EMPTY
114515: LIST
114516: LIST
114517: PUSH
114518: LD_INT 23
114520: PUSH
114521: LD_INT 2
114523: PUSH
114524: EMPTY
114525: LIST
114526: LIST
114527: PUSH
114528: EMPTY
114529: LIST
114530: LIST
114531: PPUSH
114532: CALL_OW 69
114536: IN
114537: AND
114538: IFFALSE 114663
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
114540: LD_ADDR_VAR 0 9
114544: PUSH
114545: LD_OWVAR 3
114549: PUSH
114550: LD_VAR 0 4
114554: PUSH
114555: LD_VAR 0 7
114559: ARRAY
114560: DIFF
114561: PPUSH
114562: LD_VAR 0 4
114566: PUSH
114567: LD_VAR 0 7
114571: ARRAY
114572: PPUSH
114573: CALL_OW 74
114577: ST_TO_ADDR
// if not k then
114578: LD_VAR 0 9
114582: NOT
114583: IFFALSE 114587
// continue ;
114585: GO 111002
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
114587: LD_VAR 0 9
114591: PUSH
114592: LD_INT 81
114594: PUSH
114595: LD_VAR 0 4
114599: PUSH
114600: LD_VAR 0 7
114604: ARRAY
114605: PPUSH
114606: CALL_OW 255
114610: PUSH
114611: EMPTY
114612: LIST
114613: LIST
114614: PPUSH
114615: CALL_OW 69
114619: IN
114620: PUSH
114621: LD_VAR 0 9
114625: PPUSH
114626: LD_VAR 0 4
114630: PUSH
114631: LD_VAR 0 7
114635: ARRAY
114636: PPUSH
114637: CALL_OW 296
114641: PUSH
114642: LD_INT 5
114644: LESS
114645: AND
114646: IFFALSE 114663
// ComAutodestruct ( group [ i ] ) ;
114648: LD_VAR 0 4
114652: PUSH
114653: LD_VAR 0 7
114657: ARRAY
114658: PPUSH
114659: CALL 49638 0 1
// end ; if f_attack_depot then
114663: LD_VAR 0 25
114667: IFFALSE 114779
// begin k := 6 ;
114669: LD_ADDR_VAR 0 9
114673: PUSH
114674: LD_INT 6
114676: ST_TO_ADDR
// if tmp < k then
114677: LD_VAR 0 14
114681: PUSH
114682: LD_VAR 0 9
114686: LESS
114687: IFFALSE 114699
// k := tmp ;
114689: LD_ADDR_VAR 0 9
114693: PUSH
114694: LD_VAR 0 14
114698: ST_TO_ADDR
// for j = 1 to k do
114699: LD_ADDR_VAR 0 8
114703: PUSH
114704: DOUBLE
114705: LD_INT 1
114707: DEC
114708: ST_TO_ADDR
114709: LD_VAR 0 9
114713: PUSH
114714: FOR_TO
114715: IFFALSE 114777
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
114717: LD_VAR 0 8
114721: PPUSH
114722: CALL_OW 266
114726: PUSH
114727: LD_INT 0
114729: PUSH
114730: LD_INT 1
114732: PUSH
114733: EMPTY
114734: LIST
114735: LIST
114736: IN
114737: IFFALSE 114775
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114739: LD_VAR 0 4
114743: PUSH
114744: LD_VAR 0 7
114748: ARRAY
114749: PPUSH
114750: LD_VAR 0 14
114754: PUSH
114755: LD_VAR 0 8
114759: ARRAY
114760: PPUSH
114761: CALL_OW 115
// attacking := true ;
114765: LD_ADDR_VAR 0 29
114769: PUSH
114770: LD_INT 1
114772: ST_TO_ADDR
// break ;
114773: GO 114777
// end ;
114775: GO 114714
114777: POP
114778: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
114779: LD_VAR 0 4
114783: PUSH
114784: LD_VAR 0 7
114788: ARRAY
114789: PPUSH
114790: CALL_OW 302
114794: PUSH
114795: LD_VAR 0 29
114799: NOT
114800: AND
114801: IFFALSE 115123
// begin if GetTag ( group [ i ] ) = 71 then
114803: LD_VAR 0 4
114807: PUSH
114808: LD_VAR 0 7
114812: ARRAY
114813: PPUSH
114814: CALL_OW 110
114818: PUSH
114819: LD_INT 71
114821: EQUAL
114822: IFFALSE 114863
// begin if HasTask ( group [ i ] ) then
114824: LD_VAR 0 4
114828: PUSH
114829: LD_VAR 0 7
114833: ARRAY
114834: PPUSH
114835: CALL_OW 314
114839: IFFALSE 114845
// continue else
114841: GO 111002
114843: GO 114863
// SetTag ( group [ i ] , 0 ) ;
114845: LD_VAR 0 4
114849: PUSH
114850: LD_VAR 0 7
114854: ARRAY
114855: PPUSH
114856: LD_INT 0
114858: PPUSH
114859: CALL_OW 109
// end ; k := 8 ;
114863: LD_ADDR_VAR 0 9
114867: PUSH
114868: LD_INT 8
114870: ST_TO_ADDR
// x := 0 ;
114871: LD_ADDR_VAR 0 10
114875: PUSH
114876: LD_INT 0
114878: ST_TO_ADDR
// if tmp < k then
114879: LD_VAR 0 14
114883: PUSH
114884: LD_VAR 0 9
114888: LESS
114889: IFFALSE 114901
// k := tmp ;
114891: LD_ADDR_VAR 0 9
114895: PUSH
114896: LD_VAR 0 14
114900: ST_TO_ADDR
// for j = 1 to k do
114901: LD_ADDR_VAR 0 8
114905: PUSH
114906: DOUBLE
114907: LD_INT 1
114909: DEC
114910: ST_TO_ADDR
114911: LD_VAR 0 9
114915: PUSH
114916: FOR_TO
114917: IFFALSE 115015
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
114919: LD_VAR 0 14
114923: PUSH
114924: LD_VAR 0 8
114928: ARRAY
114929: PPUSH
114930: CALL_OW 247
114934: PUSH
114935: LD_INT 1
114937: EQUAL
114938: PUSH
114939: LD_VAR 0 14
114943: PUSH
114944: LD_VAR 0 8
114948: ARRAY
114949: PPUSH
114950: CALL_OW 256
114954: PUSH
114955: LD_INT 250
114957: LESS
114958: PUSH
114959: LD_VAR 0 20
114963: AND
114964: PUSH
114965: LD_VAR 0 20
114969: NOT
114970: PUSH
114971: LD_VAR 0 14
114975: PUSH
114976: LD_VAR 0 8
114980: ARRAY
114981: PPUSH
114982: CALL_OW 256
114986: PUSH
114987: LD_INT 250
114989: GREATEREQUAL
114990: AND
114991: OR
114992: AND
114993: IFFALSE 115013
// begin x := tmp [ j ] ;
114995: LD_ADDR_VAR 0 10
114999: PUSH
115000: LD_VAR 0 14
115004: PUSH
115005: LD_VAR 0 8
115009: ARRAY
115010: ST_TO_ADDR
// break ;
115011: GO 115015
// end ;
115013: GO 114916
115015: POP
115016: POP
// if x then
115017: LD_VAR 0 10
115021: IFFALSE 115045
// ComAttackUnit ( group [ i ] , x ) else
115023: LD_VAR 0 4
115027: PUSH
115028: LD_VAR 0 7
115032: ARRAY
115033: PPUSH
115034: LD_VAR 0 10
115038: PPUSH
115039: CALL_OW 115
115043: GO 115069
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115045: LD_VAR 0 4
115049: PUSH
115050: LD_VAR 0 7
115054: ARRAY
115055: PPUSH
115056: LD_VAR 0 14
115060: PUSH
115061: LD_INT 1
115063: ARRAY
115064: PPUSH
115065: CALL_OW 115
// if not HasTask ( group [ i ] ) then
115069: LD_VAR 0 4
115073: PUSH
115074: LD_VAR 0 7
115078: ARRAY
115079: PPUSH
115080: CALL_OW 314
115084: NOT
115085: IFFALSE 115123
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
115087: LD_VAR 0 4
115091: PUSH
115092: LD_VAR 0 7
115096: ARRAY
115097: PPUSH
115098: LD_VAR 0 14
115102: PPUSH
115103: LD_VAR 0 4
115107: PUSH
115108: LD_VAR 0 7
115112: ARRAY
115113: PPUSH
115114: CALL_OW 74
115118: PPUSH
115119: CALL_OW 115
// end ; end ; end ;
115123: GO 111002
115125: POP
115126: POP
// wait ( 0 0$2 ) ;
115127: LD_INT 70
115129: PPUSH
115130: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
115134: LD_VAR 0 4
115138: NOT
115139: PUSH
115140: LD_VAR 0 4
115144: PUSH
115145: EMPTY
115146: EQUAL
115147: OR
115148: PUSH
115149: LD_INT 81
115151: PUSH
115152: LD_VAR 0 35
115156: PUSH
115157: EMPTY
115158: LIST
115159: LIST
115160: PPUSH
115161: CALL_OW 69
115165: NOT
115166: OR
115167: IFFALSE 110987
// end ;
115169: LD_VAR 0 2
115173: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
115174: LD_INT 0
115176: PPUSH
115177: PPUSH
115178: PPUSH
115179: PPUSH
115180: PPUSH
115181: PPUSH
// if not base or not mc_bases [ base ] or not solds then
115182: LD_VAR 0 1
115186: NOT
115187: PUSH
115188: LD_EXP 61
115192: PUSH
115193: LD_VAR 0 1
115197: ARRAY
115198: NOT
115199: OR
115200: PUSH
115201: LD_VAR 0 2
115205: NOT
115206: OR
115207: IFFALSE 115211
// exit ;
115209: GO 115765
// side := mc_sides [ base ] ;
115211: LD_ADDR_VAR 0 6
115215: PUSH
115216: LD_EXP 87
115220: PUSH
115221: LD_VAR 0 1
115225: ARRAY
115226: ST_TO_ADDR
// if not side then
115227: LD_VAR 0 6
115231: NOT
115232: IFFALSE 115236
// exit ;
115234: GO 115765
// for i in solds do
115236: LD_ADDR_VAR 0 7
115240: PUSH
115241: LD_VAR 0 2
115245: PUSH
115246: FOR_IN
115247: IFFALSE 115308
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
115249: LD_VAR 0 7
115253: PPUSH
115254: CALL_OW 310
115258: PPUSH
115259: CALL_OW 266
115263: PUSH
115264: LD_INT 32
115266: PUSH
115267: LD_INT 31
115269: PUSH
115270: EMPTY
115271: LIST
115272: LIST
115273: IN
115274: IFFALSE 115294
// solds := solds diff i else
115276: LD_ADDR_VAR 0 2
115280: PUSH
115281: LD_VAR 0 2
115285: PUSH
115286: LD_VAR 0 7
115290: DIFF
115291: ST_TO_ADDR
115292: GO 115306
// SetTag ( i , 18 ) ;
115294: LD_VAR 0 7
115298: PPUSH
115299: LD_INT 18
115301: PPUSH
115302: CALL_OW 109
115306: GO 115246
115308: POP
115309: POP
// if not solds then
115310: LD_VAR 0 2
115314: NOT
115315: IFFALSE 115319
// exit ;
115317: GO 115765
// repeat wait ( 0 0$2 ) ;
115319: LD_INT 70
115321: PPUSH
115322: CALL_OW 67
// enemy := mc_scan [ base ] ;
115326: LD_ADDR_VAR 0 4
115330: PUSH
115331: LD_EXP 84
115335: PUSH
115336: LD_VAR 0 1
115340: ARRAY
115341: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115342: LD_EXP 61
115346: PUSH
115347: LD_VAR 0 1
115351: ARRAY
115352: NOT
115353: PUSH
115354: LD_EXP 61
115358: PUSH
115359: LD_VAR 0 1
115363: ARRAY
115364: PUSH
115365: EMPTY
115366: EQUAL
115367: OR
115368: IFFALSE 115405
// begin for i in solds do
115370: LD_ADDR_VAR 0 7
115374: PUSH
115375: LD_VAR 0 2
115379: PUSH
115380: FOR_IN
115381: IFFALSE 115394
// ComStop ( i ) ;
115383: LD_VAR 0 7
115387: PPUSH
115388: CALL_OW 141
115392: GO 115380
115394: POP
115395: POP
// solds := [ ] ;
115396: LD_ADDR_VAR 0 2
115400: PUSH
115401: EMPTY
115402: ST_TO_ADDR
// exit ;
115403: GO 115765
// end ; for i in solds do
115405: LD_ADDR_VAR 0 7
115409: PUSH
115410: LD_VAR 0 2
115414: PUSH
115415: FOR_IN
115416: IFFALSE 115737
// begin if IsInUnit ( i ) then
115418: LD_VAR 0 7
115422: PPUSH
115423: CALL_OW 310
115427: IFFALSE 115438
// ComExitBuilding ( i ) ;
115429: LD_VAR 0 7
115433: PPUSH
115434: CALL_OW 122
// if GetLives ( i ) > 500 then
115438: LD_VAR 0 7
115442: PPUSH
115443: CALL_OW 256
115447: PUSH
115448: LD_INT 500
115450: GREATER
115451: IFFALSE 115504
// begin e := NearestUnitToUnit ( enemy , i ) ;
115453: LD_ADDR_VAR 0 5
115457: PUSH
115458: LD_VAR 0 4
115462: PPUSH
115463: LD_VAR 0 7
115467: PPUSH
115468: CALL_OW 74
115472: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
115473: LD_VAR 0 7
115477: PPUSH
115478: LD_VAR 0 5
115482: PPUSH
115483: CALL_OW 250
115487: PPUSH
115488: LD_VAR 0 5
115492: PPUSH
115493: CALL_OW 251
115497: PPUSH
115498: CALL_OW 114
// end else
115502: GO 115735
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
115504: LD_VAR 0 7
115508: PPUSH
115509: LD_EXP 61
115513: PUSH
115514: LD_VAR 0 1
115518: ARRAY
115519: PPUSH
115520: LD_INT 2
115522: PUSH
115523: LD_INT 30
115525: PUSH
115526: LD_INT 0
115528: PUSH
115529: EMPTY
115530: LIST
115531: LIST
115532: PUSH
115533: LD_INT 30
115535: PUSH
115536: LD_INT 1
115538: PUSH
115539: EMPTY
115540: LIST
115541: LIST
115542: PUSH
115543: LD_INT 30
115545: PUSH
115546: LD_INT 6
115548: PUSH
115549: EMPTY
115550: LIST
115551: LIST
115552: PUSH
115553: EMPTY
115554: LIST
115555: LIST
115556: LIST
115557: LIST
115558: PPUSH
115559: CALL_OW 72
115563: PPUSH
115564: LD_VAR 0 7
115568: PPUSH
115569: CALL_OW 74
115573: PPUSH
115574: CALL_OW 296
115578: PUSH
115579: LD_INT 10
115581: GREATER
115582: IFFALSE 115735
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
115584: LD_ADDR_VAR 0 8
115588: PUSH
115589: LD_EXP 61
115593: PUSH
115594: LD_VAR 0 1
115598: ARRAY
115599: PPUSH
115600: LD_INT 2
115602: PUSH
115603: LD_INT 30
115605: PUSH
115606: LD_INT 0
115608: PUSH
115609: EMPTY
115610: LIST
115611: LIST
115612: PUSH
115613: LD_INT 30
115615: PUSH
115616: LD_INT 1
115618: PUSH
115619: EMPTY
115620: LIST
115621: LIST
115622: PUSH
115623: LD_INT 30
115625: PUSH
115626: LD_INT 6
115628: PUSH
115629: EMPTY
115630: LIST
115631: LIST
115632: PUSH
115633: EMPTY
115634: LIST
115635: LIST
115636: LIST
115637: LIST
115638: PPUSH
115639: CALL_OW 72
115643: PPUSH
115644: LD_VAR 0 7
115648: PPUSH
115649: CALL_OW 74
115653: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
115654: LD_VAR 0 7
115658: PPUSH
115659: LD_VAR 0 8
115663: PPUSH
115664: CALL_OW 250
115668: PPUSH
115669: LD_INT 3
115671: PPUSH
115672: LD_INT 5
115674: PPUSH
115675: CALL_OW 272
115679: PPUSH
115680: LD_VAR 0 8
115684: PPUSH
115685: CALL_OW 251
115689: PPUSH
115690: LD_INT 3
115692: PPUSH
115693: LD_INT 5
115695: PPUSH
115696: CALL_OW 273
115700: PPUSH
115701: CALL_OW 111
// SetTag ( i , 0 ) ;
115705: LD_VAR 0 7
115709: PPUSH
115710: LD_INT 0
115712: PPUSH
115713: CALL_OW 109
// solds := solds diff i ;
115717: LD_ADDR_VAR 0 2
115721: PUSH
115722: LD_VAR 0 2
115726: PUSH
115727: LD_VAR 0 7
115731: DIFF
115732: ST_TO_ADDR
// continue ;
115733: GO 115415
// end ; end ;
115735: GO 115415
115737: POP
115738: POP
// until not solds or not enemy ;
115739: LD_VAR 0 2
115743: NOT
115744: PUSH
115745: LD_VAR 0 4
115749: NOT
115750: OR
115751: IFFALSE 115319
// MC_Reset ( base , 18 ) ;
115753: LD_VAR 0 1
115757: PPUSH
115758: LD_INT 18
115760: PPUSH
115761: CALL 63230 0 2
// end ;
115765: LD_VAR 0 3
115769: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
115770: LD_INT 0
115772: PPUSH
115773: PPUSH
115774: PPUSH
115775: PPUSH
115776: PPUSH
115777: PPUSH
115778: PPUSH
115779: PPUSH
115780: PPUSH
115781: PPUSH
115782: PPUSH
115783: PPUSH
115784: PPUSH
115785: PPUSH
115786: PPUSH
115787: PPUSH
115788: PPUSH
115789: PPUSH
115790: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
115791: LD_ADDR_VAR 0 12
115795: PUSH
115796: LD_EXP 61
115800: PUSH
115801: LD_VAR 0 1
115805: ARRAY
115806: PPUSH
115807: LD_INT 25
115809: PUSH
115810: LD_INT 3
115812: PUSH
115813: EMPTY
115814: LIST
115815: LIST
115816: PPUSH
115817: CALL_OW 72
115821: ST_TO_ADDR
// if mc_remote_driver [ base ] then
115822: LD_EXP 101
115826: PUSH
115827: LD_VAR 0 1
115831: ARRAY
115832: IFFALSE 115856
// mechs := mechs diff mc_remote_driver [ base ] ;
115834: LD_ADDR_VAR 0 12
115838: PUSH
115839: LD_VAR 0 12
115843: PUSH
115844: LD_EXP 101
115848: PUSH
115849: LD_VAR 0 1
115853: ARRAY
115854: DIFF
115855: ST_TO_ADDR
// for i in mechs do
115856: LD_ADDR_VAR 0 4
115860: PUSH
115861: LD_VAR 0 12
115865: PUSH
115866: FOR_IN
115867: IFFALSE 115902
// if GetTag ( i ) > 0 then
115869: LD_VAR 0 4
115873: PPUSH
115874: CALL_OW 110
115878: PUSH
115879: LD_INT 0
115881: GREATER
115882: IFFALSE 115900
// mechs := mechs diff i ;
115884: LD_ADDR_VAR 0 12
115888: PUSH
115889: LD_VAR 0 12
115893: PUSH
115894: LD_VAR 0 4
115898: DIFF
115899: ST_TO_ADDR
115900: GO 115866
115902: POP
115903: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
115904: LD_ADDR_VAR 0 8
115908: PUSH
115909: LD_EXP 61
115913: PUSH
115914: LD_VAR 0 1
115918: ARRAY
115919: PPUSH
115920: LD_INT 2
115922: PUSH
115923: LD_INT 25
115925: PUSH
115926: LD_INT 1
115928: PUSH
115929: EMPTY
115930: LIST
115931: LIST
115932: PUSH
115933: LD_INT 25
115935: PUSH
115936: LD_INT 5
115938: PUSH
115939: EMPTY
115940: LIST
115941: LIST
115942: PUSH
115943: LD_INT 25
115945: PUSH
115946: LD_INT 8
115948: PUSH
115949: EMPTY
115950: LIST
115951: LIST
115952: PUSH
115953: LD_INT 25
115955: PUSH
115956: LD_INT 9
115958: PUSH
115959: EMPTY
115960: LIST
115961: LIST
115962: PUSH
115963: EMPTY
115964: LIST
115965: LIST
115966: LIST
115967: LIST
115968: LIST
115969: PPUSH
115970: CALL_OW 72
115974: ST_TO_ADDR
// if not defenders and not solds then
115975: LD_VAR 0 2
115979: NOT
115980: PUSH
115981: LD_VAR 0 8
115985: NOT
115986: AND
115987: IFFALSE 115991
// exit ;
115989: GO 117761
// depot_under_attack := false ;
115991: LD_ADDR_VAR 0 16
115995: PUSH
115996: LD_INT 0
115998: ST_TO_ADDR
// sold_defenders := [ ] ;
115999: LD_ADDR_VAR 0 17
116003: PUSH
116004: EMPTY
116005: ST_TO_ADDR
// if mechs then
116006: LD_VAR 0 12
116010: IFFALSE 116163
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
116012: LD_ADDR_VAR 0 4
116016: PUSH
116017: LD_VAR 0 2
116021: PPUSH
116022: LD_INT 21
116024: PUSH
116025: LD_INT 2
116027: PUSH
116028: EMPTY
116029: LIST
116030: LIST
116031: PPUSH
116032: CALL_OW 72
116036: PUSH
116037: FOR_IN
116038: IFFALSE 116161
// begin if GetTag ( i ) <> 20 then
116040: LD_VAR 0 4
116044: PPUSH
116045: CALL_OW 110
116049: PUSH
116050: LD_INT 20
116052: NONEQUAL
116053: IFFALSE 116067
// SetTag ( i , 20 ) ;
116055: LD_VAR 0 4
116059: PPUSH
116060: LD_INT 20
116062: PPUSH
116063: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
116067: LD_VAR 0 4
116071: PPUSH
116072: CALL_OW 263
116076: PUSH
116077: LD_INT 1
116079: EQUAL
116080: PUSH
116081: LD_VAR 0 4
116085: PPUSH
116086: CALL_OW 311
116090: NOT
116091: AND
116092: IFFALSE 116159
// begin un := mechs [ 1 ] ;
116094: LD_ADDR_VAR 0 10
116098: PUSH
116099: LD_VAR 0 12
116103: PUSH
116104: LD_INT 1
116106: ARRAY
116107: ST_TO_ADDR
// ComExit ( un ) ;
116108: LD_VAR 0 10
116112: PPUSH
116113: CALL 54524 0 1
// AddComEnterUnit ( un , i ) ;
116117: LD_VAR 0 10
116121: PPUSH
116122: LD_VAR 0 4
116126: PPUSH
116127: CALL_OW 180
// SetTag ( un , 19 ) ;
116131: LD_VAR 0 10
116135: PPUSH
116136: LD_INT 19
116138: PPUSH
116139: CALL_OW 109
// mechs := mechs diff un ;
116143: LD_ADDR_VAR 0 12
116147: PUSH
116148: LD_VAR 0 12
116152: PUSH
116153: LD_VAR 0 10
116157: DIFF
116158: ST_TO_ADDR
// end ; end ;
116159: GO 116037
116161: POP
116162: POP
// if solds then
116163: LD_VAR 0 8
116167: IFFALSE 116226
// for i in solds do
116169: LD_ADDR_VAR 0 4
116173: PUSH
116174: LD_VAR 0 8
116178: PUSH
116179: FOR_IN
116180: IFFALSE 116224
// if not GetTag ( i ) then
116182: LD_VAR 0 4
116186: PPUSH
116187: CALL_OW 110
116191: NOT
116192: IFFALSE 116222
// begin defenders := defenders union i ;
116194: LD_ADDR_VAR 0 2
116198: PUSH
116199: LD_VAR 0 2
116203: PUSH
116204: LD_VAR 0 4
116208: UNION
116209: ST_TO_ADDR
// SetTag ( i , 18 ) ;
116210: LD_VAR 0 4
116214: PPUSH
116215: LD_INT 18
116217: PPUSH
116218: CALL_OW 109
// end ;
116222: GO 116179
116224: POP
116225: POP
// repeat wait ( 0 0$2 ) ;
116226: LD_INT 70
116228: PPUSH
116229: CALL_OW 67
// enemy := mc_scan [ base ] ;
116233: LD_ADDR_VAR 0 21
116237: PUSH
116238: LD_EXP 84
116242: PUSH
116243: LD_VAR 0 1
116247: ARRAY
116248: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116249: LD_EXP 61
116253: PUSH
116254: LD_VAR 0 1
116258: ARRAY
116259: NOT
116260: PUSH
116261: LD_EXP 61
116265: PUSH
116266: LD_VAR 0 1
116270: ARRAY
116271: PUSH
116272: EMPTY
116273: EQUAL
116274: OR
116275: IFFALSE 116312
// begin for i in defenders do
116277: LD_ADDR_VAR 0 4
116281: PUSH
116282: LD_VAR 0 2
116286: PUSH
116287: FOR_IN
116288: IFFALSE 116301
// ComStop ( i ) ;
116290: LD_VAR 0 4
116294: PPUSH
116295: CALL_OW 141
116299: GO 116287
116301: POP
116302: POP
// defenders := [ ] ;
116303: LD_ADDR_VAR 0 2
116307: PUSH
116308: EMPTY
116309: ST_TO_ADDR
// exit ;
116310: GO 117761
// end ; for i in defenders do
116312: LD_ADDR_VAR 0 4
116316: PUSH
116317: LD_VAR 0 2
116321: PUSH
116322: FOR_IN
116323: IFFALSE 117221
// begin e := NearestUnitToUnit ( enemy , i ) ;
116325: LD_ADDR_VAR 0 13
116329: PUSH
116330: LD_VAR 0 21
116334: PPUSH
116335: LD_VAR 0 4
116339: PPUSH
116340: CALL_OW 74
116344: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116345: LD_ADDR_VAR 0 7
116349: PUSH
116350: LD_EXP 61
116354: PUSH
116355: LD_VAR 0 1
116359: ARRAY
116360: PPUSH
116361: LD_INT 2
116363: PUSH
116364: LD_INT 30
116366: PUSH
116367: LD_INT 0
116369: PUSH
116370: EMPTY
116371: LIST
116372: LIST
116373: PUSH
116374: LD_INT 30
116376: PUSH
116377: LD_INT 1
116379: PUSH
116380: EMPTY
116381: LIST
116382: LIST
116383: PUSH
116384: EMPTY
116385: LIST
116386: LIST
116387: LIST
116388: PPUSH
116389: CALL_OW 72
116393: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
116394: LD_ADDR_VAR 0 16
116398: PUSH
116399: LD_VAR 0 7
116403: NOT
116404: PUSH
116405: LD_VAR 0 7
116409: PPUSH
116410: LD_INT 3
116412: PUSH
116413: LD_INT 24
116415: PUSH
116416: LD_INT 600
116418: PUSH
116419: EMPTY
116420: LIST
116421: LIST
116422: PUSH
116423: EMPTY
116424: LIST
116425: LIST
116426: PPUSH
116427: CALL_OW 72
116431: OR
116432: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
116433: LD_VAR 0 4
116437: PPUSH
116438: CALL_OW 247
116442: PUSH
116443: LD_INT 2
116445: DOUBLE
116446: EQUAL
116447: IFTRUE 116451
116449: GO 116847
116451: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
116452: LD_VAR 0 4
116456: PPUSH
116457: CALL_OW 256
116461: PUSH
116462: LD_INT 1000
116464: EQUAL
116465: PUSH
116466: LD_VAR 0 4
116470: PPUSH
116471: LD_VAR 0 13
116475: PPUSH
116476: CALL_OW 296
116480: PUSH
116481: LD_INT 40
116483: LESS
116484: PUSH
116485: LD_VAR 0 13
116489: PPUSH
116490: LD_EXP 86
116494: PUSH
116495: LD_VAR 0 1
116499: ARRAY
116500: PPUSH
116501: CALL_OW 308
116505: OR
116506: AND
116507: IFFALSE 116629
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
116509: LD_VAR 0 4
116513: PPUSH
116514: CALL_OW 262
116518: PUSH
116519: LD_INT 1
116521: EQUAL
116522: PUSH
116523: LD_VAR 0 4
116527: PPUSH
116528: CALL_OW 261
116532: PUSH
116533: LD_INT 30
116535: LESS
116536: AND
116537: PUSH
116538: LD_VAR 0 7
116542: AND
116543: IFFALSE 116613
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
116545: LD_VAR 0 4
116549: PPUSH
116550: LD_VAR 0 7
116554: PPUSH
116555: LD_VAR 0 4
116559: PPUSH
116560: CALL_OW 74
116564: PPUSH
116565: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
116569: LD_VAR 0 4
116573: PPUSH
116574: LD_VAR 0 7
116578: PPUSH
116579: LD_VAR 0 4
116583: PPUSH
116584: CALL_OW 74
116588: PPUSH
116589: CALL_OW 296
116593: PUSH
116594: LD_INT 6
116596: LESS
116597: IFFALSE 116611
// SetFuel ( i , 100 ) ;
116599: LD_VAR 0 4
116603: PPUSH
116604: LD_INT 100
116606: PPUSH
116607: CALL_OW 240
// end else
116611: GO 116627
// ComAttackUnit ( i , e ) ;
116613: LD_VAR 0 4
116617: PPUSH
116618: LD_VAR 0 13
116622: PPUSH
116623: CALL_OW 115
// end else
116627: GO 116730
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
116629: LD_VAR 0 13
116633: PPUSH
116634: LD_EXP 86
116638: PUSH
116639: LD_VAR 0 1
116643: ARRAY
116644: PPUSH
116645: CALL_OW 308
116649: NOT
116650: PUSH
116651: LD_VAR 0 4
116655: PPUSH
116656: LD_VAR 0 13
116660: PPUSH
116661: CALL_OW 296
116665: PUSH
116666: LD_INT 40
116668: GREATEREQUAL
116669: AND
116670: PUSH
116671: LD_VAR 0 4
116675: PPUSH
116676: CALL_OW 256
116680: PUSH
116681: LD_INT 650
116683: LESSEQUAL
116684: OR
116685: PUSH
116686: LD_VAR 0 4
116690: PPUSH
116691: LD_EXP 85
116695: PUSH
116696: LD_VAR 0 1
116700: ARRAY
116701: PPUSH
116702: CALL_OW 308
116706: NOT
116707: AND
116708: IFFALSE 116730
// ComMoveToArea ( i , mc_parking [ base ] ) ;
116710: LD_VAR 0 4
116714: PPUSH
116715: LD_EXP 85
116719: PUSH
116720: LD_VAR 0 1
116724: ARRAY
116725: PPUSH
116726: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
116730: LD_VAR 0 4
116734: PPUSH
116735: CALL_OW 256
116739: PUSH
116740: LD_INT 1000
116742: LESS
116743: PUSH
116744: LD_VAR 0 4
116748: PPUSH
116749: CALL_OW 263
116753: PUSH
116754: LD_INT 1
116756: EQUAL
116757: AND
116758: PUSH
116759: LD_VAR 0 4
116763: PPUSH
116764: CALL_OW 311
116768: AND
116769: PUSH
116770: LD_VAR 0 4
116774: PPUSH
116775: LD_EXP 85
116779: PUSH
116780: LD_VAR 0 1
116784: ARRAY
116785: PPUSH
116786: CALL_OW 308
116790: AND
116791: IFFALSE 116845
// begin mech := IsDrivenBy ( i ) ;
116793: LD_ADDR_VAR 0 9
116797: PUSH
116798: LD_VAR 0 4
116802: PPUSH
116803: CALL_OW 311
116807: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
116808: LD_VAR 0 9
116812: PPUSH
116813: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
116817: LD_VAR 0 9
116821: PPUSH
116822: LD_VAR 0 4
116826: PPUSH
116827: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
116831: LD_VAR 0 9
116835: PPUSH
116836: LD_VAR 0 4
116840: PPUSH
116841: CALL_OW 180
// end ; end ; unit_human :
116845: GO 117192
116847: LD_INT 1
116849: DOUBLE
116850: EQUAL
116851: IFTRUE 116855
116853: GO 117191
116855: POP
// begin b := IsInUnit ( i ) ;
116856: LD_ADDR_VAR 0 18
116860: PUSH
116861: LD_VAR 0 4
116865: PPUSH
116866: CALL_OW 310
116870: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
116871: LD_ADDR_VAR 0 19
116875: PUSH
116876: LD_VAR 0 18
116880: NOT
116881: PUSH
116882: LD_VAR 0 18
116886: PPUSH
116887: CALL_OW 266
116891: PUSH
116892: LD_INT 32
116894: PUSH
116895: LD_INT 31
116897: PUSH
116898: EMPTY
116899: LIST
116900: LIST
116901: IN
116902: OR
116903: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
116904: LD_VAR 0 18
116908: PPUSH
116909: CALL_OW 266
116913: PUSH
116914: LD_INT 5
116916: EQUAL
116917: PUSH
116918: LD_VAR 0 4
116922: PPUSH
116923: CALL_OW 257
116927: PUSH
116928: LD_INT 1
116930: PUSH
116931: LD_INT 2
116933: PUSH
116934: LD_INT 3
116936: PUSH
116937: LD_INT 4
116939: PUSH
116940: EMPTY
116941: LIST
116942: LIST
116943: LIST
116944: LIST
116945: IN
116946: AND
116947: IFFALSE 116984
// begin class := AllowSpecClass ( i ) ;
116949: LD_ADDR_VAR 0 20
116953: PUSH
116954: LD_VAR 0 4
116958: PPUSH
116959: CALL 18221 0 1
116963: ST_TO_ADDR
// if class then
116964: LD_VAR 0 20
116968: IFFALSE 116984
// ComChangeProfession ( i , class ) ;
116970: LD_VAR 0 4
116974: PPUSH
116975: LD_VAR 0 20
116979: PPUSH
116980: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
116984: LD_VAR 0 16
116988: PUSH
116989: LD_VAR 0 2
116993: PPUSH
116994: LD_INT 21
116996: PUSH
116997: LD_INT 2
116999: PUSH
117000: EMPTY
117001: LIST
117002: LIST
117003: PPUSH
117004: CALL_OW 72
117008: PUSH
117009: LD_INT 1
117011: LESSEQUAL
117012: OR
117013: PUSH
117014: LD_VAR 0 19
117018: AND
117019: PUSH
117020: LD_VAR 0 4
117024: PUSH
117025: LD_VAR 0 17
117029: IN
117030: NOT
117031: AND
117032: IFFALSE 117125
// begin if b then
117034: LD_VAR 0 18
117038: IFFALSE 117087
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
117040: LD_VAR 0 18
117044: PPUSH
117045: LD_VAR 0 21
117049: PPUSH
117050: LD_VAR 0 18
117054: PPUSH
117055: CALL_OW 74
117059: PPUSH
117060: CALL_OW 296
117064: PUSH
117065: LD_INT 10
117067: LESS
117068: PUSH
117069: LD_VAR 0 18
117073: PPUSH
117074: CALL_OW 461
117078: PUSH
117079: LD_INT 7
117081: NONEQUAL
117082: AND
117083: IFFALSE 117087
// continue ;
117085: GO 116322
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
117087: LD_ADDR_VAR 0 17
117091: PUSH
117092: LD_VAR 0 17
117096: PPUSH
117097: LD_VAR 0 17
117101: PUSH
117102: LD_INT 1
117104: PLUS
117105: PPUSH
117106: LD_VAR 0 4
117110: PPUSH
117111: CALL_OW 1
117115: ST_TO_ADDR
// ComExitBuilding ( i ) ;
117116: LD_VAR 0 4
117120: PPUSH
117121: CALL_OW 122
// end ; if sold_defenders then
117125: LD_VAR 0 17
117129: IFFALSE 117189
// if i in sold_defenders then
117131: LD_VAR 0 4
117135: PUSH
117136: LD_VAR 0 17
117140: IN
117141: IFFALSE 117189
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
117143: LD_VAR 0 4
117147: PPUSH
117148: CALL_OW 314
117152: NOT
117153: PUSH
117154: LD_VAR 0 4
117158: PPUSH
117159: LD_VAR 0 13
117163: PPUSH
117164: CALL_OW 296
117168: PUSH
117169: LD_INT 30
117171: LESS
117172: AND
117173: IFFALSE 117189
// ComAttackUnit ( i , e ) ;
117175: LD_VAR 0 4
117179: PPUSH
117180: LD_VAR 0 13
117184: PPUSH
117185: CALL_OW 115
// end ; end ; end ;
117189: GO 117192
117191: POP
// if IsDead ( i ) then
117192: LD_VAR 0 4
117196: PPUSH
117197: CALL_OW 301
117201: IFFALSE 117219
// defenders := defenders diff i ;
117203: LD_ADDR_VAR 0 2
117207: PUSH
117208: LD_VAR 0 2
117212: PUSH
117213: LD_VAR 0 4
117217: DIFF
117218: ST_TO_ADDR
// end ;
117219: GO 116322
117221: POP
117222: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
117223: LD_VAR 0 21
117227: NOT
117228: PUSH
117229: LD_VAR 0 2
117233: NOT
117234: OR
117235: PUSH
117236: LD_EXP 61
117240: PUSH
117241: LD_VAR 0 1
117245: ARRAY
117246: NOT
117247: OR
117248: IFFALSE 116226
// MC_Reset ( base , 18 ) ;
117250: LD_VAR 0 1
117254: PPUSH
117255: LD_INT 18
117257: PPUSH
117258: CALL 63230 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117262: LD_ADDR_VAR 0 2
117266: PUSH
117267: LD_VAR 0 2
117271: PUSH
117272: LD_VAR 0 2
117276: PPUSH
117277: LD_INT 2
117279: PUSH
117280: LD_INT 25
117282: PUSH
117283: LD_INT 1
117285: PUSH
117286: EMPTY
117287: LIST
117288: LIST
117289: PUSH
117290: LD_INT 25
117292: PUSH
117293: LD_INT 5
117295: PUSH
117296: EMPTY
117297: LIST
117298: LIST
117299: PUSH
117300: LD_INT 25
117302: PUSH
117303: LD_INT 8
117305: PUSH
117306: EMPTY
117307: LIST
117308: LIST
117309: PUSH
117310: LD_INT 25
117312: PUSH
117313: LD_INT 9
117315: PUSH
117316: EMPTY
117317: LIST
117318: LIST
117319: PUSH
117320: EMPTY
117321: LIST
117322: LIST
117323: LIST
117324: LIST
117325: LIST
117326: PPUSH
117327: CALL_OW 72
117331: DIFF
117332: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
117333: LD_VAR 0 21
117337: NOT
117338: PUSH
117339: LD_VAR 0 2
117343: PPUSH
117344: LD_INT 21
117346: PUSH
117347: LD_INT 2
117349: PUSH
117350: EMPTY
117351: LIST
117352: LIST
117353: PPUSH
117354: CALL_OW 72
117358: AND
117359: IFFALSE 117697
// begin tmp := FilterByTag ( defenders , 19 ) ;
117361: LD_ADDR_VAR 0 11
117365: PUSH
117366: LD_VAR 0 2
117370: PPUSH
117371: LD_INT 19
117373: PPUSH
117374: CALL 51695 0 2
117378: ST_TO_ADDR
// if tmp then
117379: LD_VAR 0 11
117383: IFFALSE 117453
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
117385: LD_ADDR_VAR 0 11
117389: PUSH
117390: LD_VAR 0 11
117394: PPUSH
117395: LD_INT 25
117397: PUSH
117398: LD_INT 3
117400: PUSH
117401: EMPTY
117402: LIST
117403: LIST
117404: PPUSH
117405: CALL_OW 72
117409: ST_TO_ADDR
// if tmp then
117410: LD_VAR 0 11
117414: IFFALSE 117453
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
117416: LD_ADDR_EXP 73
117420: PUSH
117421: LD_EXP 73
117425: PPUSH
117426: LD_VAR 0 1
117430: PPUSH
117431: LD_EXP 73
117435: PUSH
117436: LD_VAR 0 1
117440: ARRAY
117441: PUSH
117442: LD_VAR 0 11
117446: UNION
117447: PPUSH
117448: CALL_OW 1
117452: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
117453: LD_VAR 0 1
117457: PPUSH
117458: LD_INT 19
117460: PPUSH
117461: CALL 63230 0 2
// repeat wait ( 0 0$1 ) ;
117465: LD_INT 35
117467: PPUSH
117468: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117472: LD_EXP 61
117476: PUSH
117477: LD_VAR 0 1
117481: ARRAY
117482: NOT
117483: PUSH
117484: LD_EXP 61
117488: PUSH
117489: LD_VAR 0 1
117493: ARRAY
117494: PUSH
117495: EMPTY
117496: EQUAL
117497: OR
117498: IFFALSE 117535
// begin for i in defenders do
117500: LD_ADDR_VAR 0 4
117504: PUSH
117505: LD_VAR 0 2
117509: PUSH
117510: FOR_IN
117511: IFFALSE 117524
// ComStop ( i ) ;
117513: LD_VAR 0 4
117517: PPUSH
117518: CALL_OW 141
117522: GO 117510
117524: POP
117525: POP
// defenders := [ ] ;
117526: LD_ADDR_VAR 0 2
117530: PUSH
117531: EMPTY
117532: ST_TO_ADDR
// exit ;
117533: GO 117761
// end ; for i in defenders do
117535: LD_ADDR_VAR 0 4
117539: PUSH
117540: LD_VAR 0 2
117544: PUSH
117545: FOR_IN
117546: IFFALSE 117635
// begin if not IsInArea ( i , mc_parking [ base ] ) then
117548: LD_VAR 0 4
117552: PPUSH
117553: LD_EXP 85
117557: PUSH
117558: LD_VAR 0 1
117562: ARRAY
117563: PPUSH
117564: CALL_OW 308
117568: NOT
117569: IFFALSE 117593
// ComMoveToArea ( i , mc_parking [ base ] ) else
117571: LD_VAR 0 4
117575: PPUSH
117576: LD_EXP 85
117580: PUSH
117581: LD_VAR 0 1
117585: ARRAY
117586: PPUSH
117587: CALL_OW 113
117591: GO 117633
// if GetControl ( i ) = control_manual then
117593: LD_VAR 0 4
117597: PPUSH
117598: CALL_OW 263
117602: PUSH
117603: LD_INT 1
117605: EQUAL
117606: IFFALSE 117633
// if IsDrivenBy ( i ) then
117608: LD_VAR 0 4
117612: PPUSH
117613: CALL_OW 311
117617: IFFALSE 117633
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
117619: LD_VAR 0 4
117623: PPUSH
117624: CALL_OW 311
117628: PPUSH
117629: CALL_OW 121
// end ;
117633: GO 117545
117635: POP
117636: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
117637: LD_VAR 0 2
117641: PPUSH
117642: LD_INT 95
117644: PUSH
117645: LD_EXP 85
117649: PUSH
117650: LD_VAR 0 1
117654: ARRAY
117655: PUSH
117656: EMPTY
117657: LIST
117658: LIST
117659: PPUSH
117660: CALL_OW 72
117664: PUSH
117665: LD_VAR 0 2
117669: EQUAL
117670: PUSH
117671: LD_EXP 84
117675: PUSH
117676: LD_VAR 0 1
117680: ARRAY
117681: OR
117682: PUSH
117683: LD_EXP 61
117687: PUSH
117688: LD_VAR 0 1
117692: ARRAY
117693: NOT
117694: OR
117695: IFFALSE 117465
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
117697: LD_ADDR_EXP 83
117701: PUSH
117702: LD_EXP 83
117706: PPUSH
117707: LD_VAR 0 1
117711: PPUSH
117712: LD_VAR 0 2
117716: PPUSH
117717: LD_INT 21
117719: PUSH
117720: LD_INT 2
117722: PUSH
117723: EMPTY
117724: LIST
117725: LIST
117726: PPUSH
117727: CALL_OW 72
117731: PPUSH
117732: CALL_OW 1
117736: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
117737: LD_VAR 0 1
117741: PPUSH
117742: LD_INT 19
117744: PPUSH
117745: CALL 63230 0 2
// MC_Reset ( base , 20 ) ;
117749: LD_VAR 0 1
117753: PPUSH
117754: LD_INT 20
117756: PPUSH
117757: CALL 63230 0 2
// end ; end_of_file
117761: LD_VAR 0 3
117765: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
117766: LD_VAR 0 1
117770: PUSH
117771: LD_INT 200
117773: DOUBLE
117774: GREATEREQUAL
117775: IFFALSE 117783
117777: LD_INT 299
117779: DOUBLE
117780: LESSEQUAL
117781: IFTRUE 117785
117783: GO 117817
117785: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
117786: LD_VAR 0 1
117790: PPUSH
117791: LD_VAR 0 2
117795: PPUSH
117796: LD_VAR 0 3
117800: PPUSH
117801: LD_VAR 0 4
117805: PPUSH
117806: LD_VAR 0 5
117810: PPUSH
117811: CALL 105947 0 5
117815: GO 117894
117817: LD_INT 300
117819: DOUBLE
117820: GREATEREQUAL
117821: IFFALSE 117829
117823: LD_INT 399
117825: DOUBLE
117826: LESSEQUAL
117827: IFTRUE 117831
117829: GO 117893
117831: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
117832: LD_VAR 0 1
117836: PPUSH
117837: LD_VAR 0 2
117841: PPUSH
117842: LD_VAR 0 3
117846: PPUSH
117847: LD_VAR 0 4
117851: PPUSH
117852: LD_VAR 0 5
117856: PPUSH
117857: LD_VAR 0 6
117861: PPUSH
117862: LD_VAR 0 7
117866: PPUSH
117867: LD_VAR 0 8
117871: PPUSH
117872: LD_VAR 0 9
117876: PPUSH
117877: LD_VAR 0 10
117881: PPUSH
117882: LD_VAR 0 11
117886: PPUSH
117887: CALL 102272 0 11
117891: GO 117894
117893: POP
// end ;
117894: PPOPN 11
117896: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
117897: LD_VAR 0 1
117901: PPUSH
117902: LD_VAR 0 2
117906: PPUSH
117907: LD_VAR 0 3
117911: PPUSH
117912: LD_VAR 0 4
117916: PPUSH
117917: LD_VAR 0 5
117921: PPUSH
117922: CALL 105683 0 5
// end ; end_of_file
117926: PPOPN 5
117928: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
117929: LD_VAR 0 1
117933: PPUSH
117934: LD_VAR 0 2
117938: PPUSH
117939: LD_VAR 0 3
117943: PPUSH
117944: LD_VAR 0 4
117948: PPUSH
117949: LD_VAR 0 5
117953: PPUSH
117954: LD_VAR 0 6
117958: PPUSH
117959: CALL 89924 0 6
// end ;
117963: PPOPN 6
117965: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
117966: LD_INT 0
117968: PPUSH
// begin if not units then
117969: LD_VAR 0 1
117973: NOT
117974: IFFALSE 117978
// exit ;
117976: GO 117978
// end ;
117978: PPOPN 7
117980: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
117981: CALL 89828 0 0
// end ;
117985: PPOPN 1
117987: END
