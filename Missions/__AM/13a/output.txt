// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 619 0 0
// InitMacro ;
  19: CALL 56661 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 48513 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 48513 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 48513 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 48513 0 9
// PrepareArabian ;
 147: CALL 3529 0 0
// PrepareRussian ;
 151: CALL 2664 0 0
// PrepareAlliance ;
 155: CALL 729 0 0
// MC_Start ( ) ;
 159: CALL 58773 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6692 0 0
// end ;
 180: END
// export function CustomInitMacro ; var i ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 185: LD_ADDR_EXP 82
 189: PUSH
 190: LD_INT 1
 192: PUSH
 193: LD_INT 2
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 200: LD_ADDR_EXP 83
 204: PUSH
 205: LD_INT 3
 207: PUSH
 208: LD_INT 4
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 215: LD_INT 1
 217: PPUSH
 218: LD_INT 12
 220: PUSH
 221: LD_INT 15
 223: PUSH
 224: LD_INT 18
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: PUSH
 232: LD_OWVAR 67
 236: ARRAY
 237: PPUSH
 238: LD_INT 7
 240: PPUSH
 241: CALL 79878 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 245: LD_INT 1
 247: PPUSH
 248: LD_EXP 53
 252: PPUSH
 253: CALL 80304 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 257: LD_INT 1
 259: PPUSH
 260: LD_INT 6
 262: PPUSH
 263: CALL 80762 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 267: LD_INT 1
 269: PPUSH
 270: LD_INT 9
 272: PUSH
 273: EMPTY
 274: LIST
 275: PPUSH
 276: CALL 81031 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 13
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 2
 291: PUSH
 292: LD_INT 32
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: PUSH
 301: EMPTY
 302: LIST
 303: PPUSH
 304: CALL 80244 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 308: LD_INT 2
 310: PPUSH
 311: LD_INT 12
 313: PUSH
 314: LD_INT 14
 316: PUSH
 317: LD_INT 10
 319: PUSH
 320: LD_INT 11
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 80938 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_EXP 50
 340: PPUSH
 341: CALL 80304 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 345: LD_INT 2
 347: PPUSH
 348: LD_INT 8
 350: PPUSH
 351: CALL 80762 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 355: LD_INT 2
 357: PPUSH
 358: LD_INT 10
 360: PUSH
 361: EMPTY
 362: LIST
 363: PPUSH
 364: CALL 81031 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 368: LD_INT 2
 370: PPUSH
 371: LD_INT 6
 373: PUSH
 374: LD_INT 71
 376: PUSH
 377: LD_INT 116
 379: PUSH
 380: LD_INT 4
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_INT 4
 391: PUSH
 392: LD_INT 85
 394: PUSH
 395: LD_INT 116
 397: PUSH
 398: LD_INT 4
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: LD_INT 32
 409: PUSH
 410: LD_INT 83
 412: PUSH
 413: LD_INT 111
 415: PUSH
 416: LD_INT 4
 418: PUSH
 419: EMPTY
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: PUSH
 425: LD_INT 32
 427: PUSH
 428: LD_INT 87
 430: PUSH
 431: LD_INT 121
 433: PUSH
 434: LD_INT 4
 436: PUSH
 437: EMPTY
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 88
 448: PUSH
 449: LD_INT 128
 451: PUSH
 452: LD_INT 4
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: PUSH
 461: LD_INT 32
 463: PUSH
 464: LD_INT 59
 466: PUSH
 467: LD_INT 89
 469: PUSH
 470: LD_INT 3
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_INT 33
 481: PUSH
 482: LD_INT 69
 484: PUSH
 485: LD_INT 98
 487: PUSH
 488: LD_INT 3
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: PUSH
 497: LD_INT 33
 499: PUSH
 500: LD_INT 77
 502: PUSH
 503: LD_INT 103
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 33
 517: PUSH
 518: LD_INT 83
 520: PUSH
 521: LD_INT 105
 523: PUSH
 524: LD_INT 3
 526: PUSH
 527: EMPTY
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 33
 535: PUSH
 536: LD_INT 71
 538: PUSH
 539: LD_INT 125
 541: PUSH
 542: LD_INT 5
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PPUSH
 563: CALL 80088 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 567: LD_INT 2
 569: PPUSH
 570: LD_INT 21
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 3
 578: PUSH
 579: LD_INT 51
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PUSH
 588: LD_INT 22
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 3
 596: PUSH
 597: LD_INT 52
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: PPUSH
 610: CALL 80244 0 2
// end ;
 614: LD_VAR 0 1
 618: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 619: LD_INT 0
 621: PPUSH
// debug := false ;
 622: LD_ADDR_EXP 1
 626: PUSH
 627: LD_INT 0
 629: ST_TO_ADDR
// game := true ;
 630: LD_ADDR_EXP 2
 634: PUSH
 635: LD_INT 1
 637: ST_TO_ADDR
// gossudarov_arrive := false ;
 638: LD_ADDR_EXP 4
 642: PUSH
 643: LD_INT 0
 645: ST_TO_ADDR
// ru_lab_builded := false ;
 646: LD_ADDR_EXP 5
 650: PUSH
 651: LD_INT 0
 653: ST_TO_ADDR
// player_spotted := false ;
 654: LD_ADDR_EXP 6
 658: PUSH
 659: LD_INT 0
 661: ST_TO_ADDR
// first_attack := false ;
 662: LD_ADDR_EXP 7
 666: PUSH
 667: LD_INT 0
 669: ST_TO_ADDR
// ru_attackers := [ ] ;
 670: LD_ADDR_EXP 51
 674: PUSH
 675: EMPTY
 676: ST_TO_ADDR
// ar_base_spotted := false ;
 677: LD_ADDR_EXP 8
 681: PUSH
 682: LD_INT 0
 684: ST_TO_ADDR
// ar_active_attack := false ;
 685: LD_ADDR_EXP 9
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// ar_attackers := [ ] ;
 693: LD_ADDR_EXP 10
 697: PUSH
 698: EMPTY
 699: ST_TO_ADDR
// first_powell_attack := false ;
 700: LD_ADDR_EXP 11
 704: PUSH
 705: LD_INT 0
 707: ST_TO_ADDR
// abdul_escaped := true ;
 708: LD_ADDR_EXP 12
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// loss_counter := 0 ;
 716: LD_ADDR_EXP 13
 720: PUSH
 721: LD_INT 0
 723: ST_TO_ADDR
// end ; end_of_file
 724: LD_VAR 0 1
 728: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 729: LD_INT 0
 731: PPUSH
 732: PPUSH
 733: PPUSH
 734: PPUSH
// uc_side := 7 ;
 735: LD_ADDR_OWVAR 20
 739: PUSH
 740: LD_INT 7
 742: ST_TO_ADDR
// uc_nation := 1 ;
 743: LD_ADDR_OWVAR 21
 747: PUSH
 748: LD_INT 1
 750: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 751: LD_ADDR_EXP 14
 755: PUSH
 756: LD_STRING JMM
 758: PPUSH
 759: LD_EXP 1
 763: NOT
 764: PPUSH
 765: LD_STRING 12a_
 767: PPUSH
 768: CALL 13948 0 3
 772: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 773: LD_EXP 14
 777: PPUSH
 778: LD_INT 71
 780: PPUSH
 781: LD_INT 23
 783: PPUSH
 784: LD_INT 0
 786: PPUSH
 787: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 791: LD_EXP 14
 795: PPUSH
 796: LD_INT 2
 798: PPUSH
 799: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 803: LD_ADDR_EXP 15
 807: PUSH
 808: LD_STRING Roth
 810: PPUSH
 811: LD_EXP 1
 815: NOT
 816: PPUSH
 817: LD_STRING 12a_
 819: PPUSH
 820: CALL 13948 0 3
 824: ST_TO_ADDR
// if Roth then
 825: LD_EXP 15
 829: IFFALSE 849
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 831: LD_EXP 15
 835: PPUSH
 836: LD_INT 71
 838: PPUSH
 839: LD_INT 21
 841: PPUSH
 842: LD_INT 0
 844: PPUSH
 845: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 849: LD_ADDR_EXP 16
 853: PUSH
 854: LD_STRING Lisa
 856: PPUSH
 857: LD_EXP 1
 861: NOT
 862: PPUSH
 863: LD_STRING 12a_
 865: PPUSH
 866: CALL 13948 0 3
 870: ST_TO_ADDR
// if Lisa then
 871: LD_EXP 16
 875: IFFALSE 892
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 877: LD_EXP 16
 881: PPUSH
 882: LD_INT 13
 884: PPUSH
 885: LD_INT 0
 887: PPUSH
 888: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 892: LD_ADDR_EXP 17
 896: PUSH
 897: LD_STRING Donaldson
 899: PPUSH
 900: LD_EXP 1
 904: NOT
 905: PPUSH
 906: LD_STRING 12a_
 908: PPUSH
 909: CALL 13948 0 3
 913: ST_TO_ADDR
// if Donaldson then
 914: LD_EXP 17
 918: IFFALSE 935
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 920: LD_EXP 17
 924: PPUSH
 925: LD_INT 13
 927: PPUSH
 928: LD_INT 0
 930: PPUSH
 931: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 935: LD_ADDR_EXP 18
 939: PUSH
 940: LD_STRING Bobby
 942: PPUSH
 943: LD_EXP 1
 947: NOT
 948: PPUSH
 949: LD_STRING 12a_
 951: PPUSH
 952: CALL 13948 0 3
 956: ST_TO_ADDR
// if Bobby then
 957: LD_EXP 18
 961: IFFALSE 978
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 963: LD_EXP 18
 967: PPUSH
 968: LD_INT 13
 970: PPUSH
 971: LD_INT 0
 973: PPUSH
 974: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 978: LD_ADDR_EXP 19
 982: PUSH
 983: LD_STRING Cyrus
 985: PPUSH
 986: LD_EXP 1
 990: NOT
 991: PPUSH
 992: LD_STRING 12a_
 994: PPUSH
 995: CALL 13948 0 3
 999: ST_TO_ADDR
// if Cyrus then
1000: LD_EXP 19
1004: IFFALSE 1021
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1006: LD_EXP 19
1010: PPUSH
1011: LD_INT 13
1013: PPUSH
1014: LD_INT 0
1016: PPUSH
1017: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1021: LD_ADDR_EXP 20
1025: PUSH
1026: LD_STRING Denis
1028: PPUSH
1029: LD_EXP 1
1033: NOT
1034: PPUSH
1035: LD_STRING 12a_
1037: PPUSH
1038: CALL 13948 0 3
1042: ST_TO_ADDR
// if Denis then
1043: LD_EXP 20
1047: IFFALSE 1064
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1049: LD_EXP 20
1053: PPUSH
1054: LD_INT 13
1056: PPUSH
1057: LD_INT 0
1059: PPUSH
1060: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1064: LD_ADDR_EXP 21
1068: PUSH
1069: LD_STRING Brown
1071: PPUSH
1072: LD_EXP 1
1076: NOT
1077: PPUSH
1078: LD_STRING 12a_
1080: PPUSH
1081: CALL 13948 0 3
1085: ST_TO_ADDR
// if Brown then
1086: LD_EXP 21
1090: IFFALSE 1107
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1092: LD_EXP 21
1096: PPUSH
1097: LD_INT 13
1099: PPUSH
1100: LD_INT 0
1102: PPUSH
1103: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1107: LD_ADDR_EXP 22
1111: PUSH
1112: LD_STRING Gladstone
1114: PPUSH
1115: LD_EXP 1
1119: NOT
1120: PPUSH
1121: LD_STRING 12a_
1123: PPUSH
1124: CALL 13948 0 3
1128: ST_TO_ADDR
// if Gladstone then
1129: LD_EXP 22
1133: IFFALSE 1150
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1135: LD_EXP 22
1139: PPUSH
1140: LD_INT 13
1142: PPUSH
1143: LD_INT 0
1145: PPUSH
1146: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1150: LD_ADDR_EXP 23
1154: PUSH
1155: LD_STRING Houten
1157: PPUSH
1158: LD_EXP 1
1162: NOT
1163: PPUSH
1164: LD_STRING 12a_
1166: PPUSH
1167: CALL 13948 0 3
1171: ST_TO_ADDR
// if Houten then
1172: LD_EXP 23
1176: IFFALSE 1193
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1178: LD_EXP 23
1182: PPUSH
1183: LD_INT 13
1185: PPUSH
1186: LD_INT 0
1188: PPUSH
1189: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1193: LD_ADDR_EXP 24
1197: PUSH
1198: LD_STRING Cornell
1200: PPUSH
1201: LD_EXP 1
1205: NOT
1206: PPUSH
1207: LD_STRING 12a_
1209: PPUSH
1210: CALL 13948 0 3
1214: ST_TO_ADDR
// if Cornel then
1215: LD_EXP 24
1219: IFFALSE 1236
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1221: LD_EXP 24
1225: PPUSH
1226: LD_INT 13
1228: PPUSH
1229: LD_INT 0
1231: PPUSH
1232: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1236: LD_ADDR_EXP 25
1240: PUSH
1241: LD_STRING Gary
1243: PPUSH
1244: LD_EXP 1
1248: NOT
1249: PPUSH
1250: LD_STRING 12a_
1252: PPUSH
1253: CALL 13948 0 3
1257: ST_TO_ADDR
// if Gary then
1258: LD_EXP 25
1262: IFFALSE 1279
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1264: LD_EXP 25
1268: PPUSH
1269: LD_INT 13
1271: PPUSH
1272: LD_INT 0
1274: PPUSH
1275: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1279: LD_ADDR_EXP 26
1283: PUSH
1284: LD_STRING Frank
1286: PPUSH
1287: LD_EXP 1
1291: NOT
1292: PPUSH
1293: LD_STRING 12a_
1295: PPUSH
1296: CALL 13948 0 3
1300: ST_TO_ADDR
// if Frank then
1301: LD_EXP 26
1305: IFFALSE 1322
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1307: LD_EXP 26
1311: PPUSH
1312: LD_INT 13
1314: PPUSH
1315: LD_INT 0
1317: PPUSH
1318: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1322: LD_ADDR_EXP 27
1326: PUSH
1327: LD_STRING Kikuchi
1329: PPUSH
1330: LD_EXP 1
1334: NOT
1335: PPUSH
1336: LD_STRING 12a_
1338: PPUSH
1339: CALL 13948 0 3
1343: ST_TO_ADDR
// if Kikuchi then
1344: LD_EXP 27
1348: IFFALSE 1365
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1350: LD_EXP 27
1354: PPUSH
1355: LD_INT 13
1357: PPUSH
1358: LD_INT 0
1360: PPUSH
1361: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1365: LD_ADDR_EXP 28
1369: PUSH
1370: LD_STRING Simms
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_STRING 12a_
1381: PPUSH
1382: CALL 13948 0 3
1386: ST_TO_ADDR
// if Simms then
1387: LD_EXP 28
1391: IFFALSE 1408
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1393: LD_EXP 28
1397: PPUSH
1398: LD_INT 13
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1408: LD_ADDR_EXP 29
1412: PUSH
1413: LD_STRING Joan
1415: PPUSH
1416: LD_EXP 1
1420: NOT
1421: PPUSH
1422: LD_STRING 12a_
1424: PPUSH
1425: CALL 13948 0 3
1429: ST_TO_ADDR
// if Joan then
1430: LD_EXP 29
1434: IFFALSE 1451
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1436: LD_EXP 29
1440: PPUSH
1441: LD_INT 13
1443: PPUSH
1444: LD_INT 0
1446: PPUSH
1447: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1451: LD_ADDR_EXP 30
1455: PUSH
1456: LD_STRING DeltaDoctor
1458: PPUSH
1459: LD_EXP 1
1463: NOT
1464: PPUSH
1465: LD_STRING 12a_
1467: PPUSH
1468: CALL 13948 0 3
1472: ST_TO_ADDR
// if DeltaDoctor then
1473: LD_EXP 30
1477: IFFALSE 1494
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1479: LD_EXP 30
1483: PPUSH
1484: LD_INT 13
1486: PPUSH
1487: LD_INT 0
1489: PPUSH
1490: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1494: LD_ADDR_VAR 0 4
1498: PUSH
1499: LD_STRING 12a_others
1501: PPUSH
1502: CALL_OW 31
1506: ST_TO_ADDR
// if tmp then
1507: LD_VAR 0 4
1511: IFFALSE 1545
// for i in tmp do
1513: LD_ADDR_VAR 0 3
1517: PUSH
1518: LD_VAR 0 4
1522: PUSH
1523: FOR_IN
1524: IFFALSE 1543
// PlaceUnitArea ( i , alliance_start , false ) ;
1526: LD_VAR 0 3
1530: PPUSH
1531: LD_INT 13
1533: PPUSH
1534: LD_INT 0
1536: PPUSH
1537: CALL_OW 49
1541: GO 1523
1543: POP
1544: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1545: LD_INT 3
1547: PPUSH
1548: LD_INT 3
1550: PPUSH
1551: LD_INT 3
1553: PPUSH
1554: LD_INT 12
1556: PPUSH
1557: LD_INT 100
1559: PPUSH
1560: CALL 20699 0 5
// veh := CreateVehicle ;
1564: LD_ADDR_VAR 0 2
1568: PUSH
1569: CALL_OW 45
1573: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1574: LD_VAR 0 2
1578: PPUSH
1579: LD_INT 2
1581: PPUSH
1582: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1586: LD_VAR 0 2
1590: PPUSH
1591: LD_INT 60
1593: PPUSH
1594: LD_INT 6
1596: PPUSH
1597: LD_INT 0
1599: PPUSH
1600: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1604: LD_VAR 0 2
1608: PPUSH
1609: LD_INT 4
1611: PPUSH
1612: LD_INT 30
1614: PPUSH
1615: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1619: LD_STRING 11_artifact_captured
1621: PPUSH
1622: LD_INT 0
1624: PPUSH
1625: CALL_OW 30
1629: IFFALSE 1705
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1631: LD_INT 3
1633: PPUSH
1634: LD_INT 3
1636: PPUSH
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 12
1642: PPUSH
1643: LD_INT 100
1645: PPUSH
1646: CALL 20699 0 5
// veh := CreateVehicle ;
1650: LD_ADDR_VAR 0 2
1654: PUSH
1655: CALL_OW 45
1659: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1660: LD_VAR 0 2
1664: PPUSH
1665: LD_INT 3
1667: PPUSH
1668: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1672: LD_VAR 0 2
1676: PPUSH
1677: LD_INT 75
1679: PPUSH
1680: LD_INT 6
1682: PPUSH
1683: LD_INT 0
1685: PPUSH
1686: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1690: LD_VAR 0 2
1694: PPUSH
1695: LD_INT 4
1697: PPUSH
1698: LD_INT 50
1700: PPUSH
1701: CALL_OW 290
// end ; end ;
1705: LD_VAR 0 1
1709: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1710: LD_INT 0
1712: PPUSH
1713: PPUSH
1714: PPUSH
1715: PPUSH
// uc_side := 6 ;
1716: LD_ADDR_OWVAR 20
1720: PUSH
1721: LD_INT 6
1723: ST_TO_ADDR
// uc_nation := 3 ;
1724: LD_ADDR_OWVAR 21
1728: PUSH
1729: LD_INT 3
1731: ST_TO_ADDR
// InitHc ;
1732: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1736: LD_ADDR_EXP 31
1740: PUSH
1741: LD_STRING Gossudarov
1743: PPUSH
1744: CALL_OW 25
1748: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1749: LD_ADDR_EXP 32
1753: PUSH
1754: LD_STRING Kirilenkova
1756: PPUSH
1757: CALL_OW 25
1761: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1762: LD_ADDR_EXP 33
1766: PUSH
1767: LD_STRING Titov
1769: PPUSH
1770: CALL_OW 25
1774: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1775: LD_ADDR_EXP 38
1779: PUSH
1780: LD_STRING Oblukov
1782: PPUSH
1783: CALL_OW 25
1787: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1788: LD_ADDR_EXP 35
1792: PUSH
1793: LD_STRING Dolgov
1795: PPUSH
1796: CALL_OW 25
1800: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1801: LD_ADDR_EXP 36
1805: PUSH
1806: LD_STRING Petrosyan
1808: PPUSH
1809: CALL_OW 25
1813: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1814: LD_ADDR_EXP 37
1818: PUSH
1819: LD_STRING Scholtze
1821: PPUSH
1822: CALL_OW 25
1826: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1827: LD_ADDR_EXP 39
1831: PUSH
1832: LD_STRING Kapitsova
1834: PPUSH
1835: CALL_OW 25
1839: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1840: LD_ADDR_VAR 0 2
1844: PUSH
1845: LD_EXP 31
1849: PUSH
1850: LD_EXP 32
1854: PUSH
1855: LD_EXP 33
1859: PUSH
1860: LD_EXP 38
1864: PUSH
1865: LD_EXP 35
1869: PUSH
1870: LD_EXP 36
1874: PUSH
1875: LD_EXP 37
1879: PUSH
1880: LD_EXP 39
1884: PUSH
1885: EMPTY
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1895: LD_INT 1
1897: PPUSH
1898: LD_INT 4
1900: PPUSH
1901: LD_INT 8
1903: PPUSH
1904: CALL_OW 380
// un := CreateHuman ;
1908: LD_ADDR_VAR 0 4
1912: PUSH
1913: CALL_OW 44
1917: ST_TO_ADDR
// tmp := tmp ^ un ;
1918: LD_ADDR_VAR 0 2
1922: PUSH
1923: LD_VAR 0 2
1927: PUSH
1928: LD_VAR 0 4
1932: ADD
1933: ST_TO_ADDR
// for i in tmp do
1934: LD_ADDR_VAR 0 3
1938: PUSH
1939: LD_VAR 0 2
1943: PUSH
1944: FOR_IN
1945: IFFALSE 1964
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1947: LD_VAR 0 3
1951: PPUSH
1952: LD_INT 14
1954: PPUSH
1955: LD_INT 0
1957: PPUSH
1958: CALL_OW 49
1962: GO 1944
1964: POP
1965: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1966: LD_VAR 0 2
1970: PPUSH
1971: LD_EXP 3
1975: PPUSH
1976: CALL_OW 250
1980: PPUSH
1981: LD_EXP 3
1985: PPUSH
1986: CALL_OW 251
1990: PPUSH
1991: CALL_OW 111
// end ;
1995: LD_VAR 0 1
1999: RET
// export function PrepareBelkov ; begin
2000: LD_INT 0
2002: PPUSH
// uc_side := 4 ;
2003: LD_ADDR_OWVAR 20
2007: PUSH
2008: LD_INT 4
2010: ST_TO_ADDR
// uc_nation := 3 ;
2011: LD_ADDR_OWVAR 21
2015: PUSH
2016: LD_INT 3
2018: ST_TO_ADDR
// InitHc ;
2019: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2023: LD_ADDR_EXP 46
2027: PUSH
2028: LD_STRING Belkov
2030: PPUSH
2031: CALL_OW 25
2035: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2036: LD_EXP 46
2040: PPUSH
2041: LD_INT 14
2043: PPUSH
2044: LD_INT 0
2046: PPUSH
2047: CALL_OW 49
// end ;
2051: LD_VAR 0 1
2055: RET
// export function PrepareGnyevko ; begin
2056: LD_INT 0
2058: PPUSH
// uc_side := 4 ;
2059: LD_ADDR_OWVAR 20
2063: PUSH
2064: LD_INT 4
2066: ST_TO_ADDR
// uc_nation := 3 ;
2067: LD_ADDR_OWVAR 21
2071: PUSH
2072: LD_INT 3
2074: ST_TO_ADDR
// InitHc ;
2075: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2079: LD_ADDR_EXP 47
2083: PUSH
2084: LD_STRING Gnyevko
2086: PPUSH
2087: CALL_OW 25
2091: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2092: LD_EXP 47
2096: PPUSH
2097: LD_INT 14
2099: PPUSH
2100: LD_INT 0
2102: PPUSH
2103: CALL_OW 49
// end ;
2107: LD_VAR 0 1
2111: RET
// export function PrepareBurlak ; var i , tmp ; begin
2112: LD_INT 0
2114: PPUSH
2115: PPUSH
2116: PPUSH
// uc_side := 4 ;
2117: LD_ADDR_OWVAR 20
2121: PUSH
2122: LD_INT 4
2124: ST_TO_ADDR
// uc_nation := 3 ;
2125: LD_ADDR_OWVAR 21
2129: PUSH
2130: LD_INT 3
2132: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
2133: LD_INT 35
2135: PPUSH
2136: CALL_OW 67
// until not FilterAllUnits ( [ f_distxy , 123 , 3 , 3 ] ) ;
2140: LD_INT 92
2142: PUSH
2143: LD_INT 123
2145: PUSH
2146: LD_INT 3
2148: PUSH
2149: LD_INT 3
2151: PUSH
2152: EMPTY
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: PPUSH
2158: CALL_OW 69
2162: NOT
2163: IFFALSE 2133
// InitHc ;
2165: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2169: LD_ADDR_EXP 45
2173: PUSH
2174: LD_STRING Burlak
2176: PPUSH
2177: CALL_OW 25
2181: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2182: LD_INT 24
2184: PUSH
2185: LD_INT 23
2187: PUSH
2188: LD_INT 22
2190: PUSH
2191: EMPTY
2192: LIST
2193: LIST
2194: LIST
2195: PUSH
2196: LD_OWVAR 67
2200: ARRAY
2201: PPUSH
2202: LD_INT 1
2204: PPUSH
2205: LD_INT 1
2207: PPUSH
2208: LD_INT 45
2210: PUSH
2211: LD_INT 44
2213: PUSH
2214: LD_INT 43
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: LIST
2221: PUSH
2222: LD_OWVAR 67
2226: ARRAY
2227: PPUSH
2228: LD_INT 0
2230: PPUSH
2231: CALL 20699 0 5
// Masha := CreateVehicle ;
2235: LD_ADDR_EXP 48
2239: PUSH
2240: CALL_OW 45
2244: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2245: LD_EXP 48
2249: PUSH
2250: LD_EXP 45
2254: PUSH
2255: EMPTY
2256: LIST
2257: LIST
2258: PPUSH
2259: LD_INT 499
2261: PPUSH
2262: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2266: LD_EXP 48
2270: PPUSH
2271: LD_INT 3
2273: PPUSH
2274: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2278: LD_EXP 48
2282: PPUSH
2283: LD_INT 1
2285: PPUSH
2286: CALL_OW 242
// PlaceUnitArea ( Masha , burlak_spawn , false ) ;
2290: LD_EXP 48
2294: PPUSH
2295: LD_INT 18
2297: PPUSH
2298: LD_INT 0
2300: PPUSH
2301: CALL_OW 49
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2305: LD_EXP 45
2309: PPUSH
2310: LD_INT 125
2312: PPUSH
2313: LD_INT 1
2315: PPUSH
2316: LD_INT 0
2318: PPUSH
2319: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2323: LD_EXP 45
2327: PPUSH
2328: LD_EXP 48
2332: PPUSH
2333: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2337: LD_INT 10
2339: PPUSH
2340: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2344: LD_EXP 48
2348: PPUSH
2349: LD_INT 110
2351: PPUSH
2352: LD_INT 10
2354: PPUSH
2355: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2359: LD_ADDR_EXP 41
2363: PUSH
2364: LD_STRING Petrovova
2366: PPUSH
2367: CALL_OW 25
2371: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2372: LD_ADDR_EXP 43
2376: PUSH
2377: LD_STRING Kuzmov
2379: PPUSH
2380: CALL_OW 25
2384: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2385: LD_ADDR_EXP 42
2389: PUSH
2390: LD_STRING Kovalyuk
2392: PPUSH
2393: CALL_OW 25
2397: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2398: LD_ADDR_EXP 40
2402: PUSH
2403: LD_STRING Lipshchin
2405: PPUSH
2406: CALL_OW 25
2410: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2411: LD_ADDR_EXP 44
2415: PUSH
2416: LD_STRING Karamazov
2418: PPUSH
2419: CALL_OW 25
2423: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2424: LD_ADDR_VAR 0 3
2428: PUSH
2429: LD_EXP 41
2433: PUSH
2434: LD_EXP 43
2438: PUSH
2439: LD_EXP 42
2443: PUSH
2444: LD_EXP 40
2448: PUSH
2449: LD_EXP 44
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: LIST
2458: LIST
2459: LIST
2460: ST_TO_ADDR
// for i in tmp do
2461: LD_ADDR_VAR 0 2
2465: PUSH
2466: LD_VAR 0 3
2470: PUSH
2471: FOR_IN
2472: IFFALSE 2511
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2474: LD_VAR 0 2
2478: PPUSH
2479: LD_INT 399
2481: PPUSH
2482: LD_INT 799
2484: PPUSH
2485: CALL_OW 12
2489: PPUSH
2490: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2494: LD_VAR 0 2
2498: PPUSH
2499: LD_INT 19
2501: PPUSH
2502: LD_INT 0
2504: PPUSH
2505: CALL_OW 49
// end ;
2509: GO 2471
2511: POP
2512: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2513: LD_VAR 0 3
2517: PPUSH
2518: LD_INT 116
2520: PPUSH
2521: LD_INT 8
2523: PPUSH
2524: CALL_OW 111
// AddComHold ( tmp ) ;
2528: LD_VAR 0 3
2532: PPUSH
2533: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2537: LD_ADDR_VAR 0 2
2541: PUSH
2542: LD_VAR 0 3
2546: PPUSH
2547: LD_INT 25
2549: PUSH
2550: LD_INT 1
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: PPUSH
2557: CALL_OW 72
2561: PUSH
2562: FOR_IN
2563: IFFALSE 2603
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2565: LD_VAR 0 2
2569: PPUSH
2570: LD_INT 20
2572: PPUSH
2573: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2577: LD_VAR 0 2
2581: PPUSH
2582: LD_INT 147
2584: PPUSH
2585: LD_INT 45
2587: PPUSH
2588: CALL_OW 178
// AddComCrawl ( i ) ;
2592: LD_VAR 0 2
2596: PPUSH
2597: CALL_OW 197
// end ;
2601: GO 2562
2603: POP
2604: POP
// repeat wait ( 0 0$1 ) ;
2605: LD_INT 35
2607: PPUSH
2608: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2612: LD_EXP 48
2616: PPUSH
2617: LD_INT 110
2619: PPUSH
2620: LD_INT 10
2622: PPUSH
2623: CALL_OW 307
2627: PUSH
2628: LD_EXP 48
2632: PPUSH
2633: CALL_OW 305
2637: NOT
2638: OR
2639: IFFALSE 2605
// ComStop ( Burlak ) ;
2641: LD_EXP 45
2645: PPUSH
2646: CALL_OW 141
// AddComHold ( Burlak ) ;
2650: LD_EXP 45
2654: PPUSH
2655: CALL_OW 200
// end ; end_of_file
2659: LD_VAR 0 1
2663: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2664: LD_INT 0
2666: PPUSH
2667: PPUSH
2668: PPUSH
2669: PPUSH
// uc_side := 3 ;
2670: LD_ADDR_OWVAR 20
2674: PUSH
2675: LD_INT 3
2677: ST_TO_ADDR
// uc_nation := 3 ;
2678: LD_ADDR_OWVAR 21
2682: PUSH
2683: LD_INT 3
2685: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2686: LD_ADDR_EXP 49
2690: PUSH
2691: LD_INT 47
2693: PPUSH
2694: LD_INT 4
2696: PPUSH
2697: LD_STRING 
2699: PPUSH
2700: LD_INT 7
2702: PUSH
2703: LD_INT 8
2705: PUSH
2706: LD_INT 9
2708: PUSH
2709: EMPTY
2710: LIST
2711: LIST
2712: LIST
2713: PUSH
2714: LD_OWVAR 67
2718: ARRAY
2719: PPUSH
2720: LD_INT 10000
2722: PUSH
2723: LD_INT 3000
2725: PUSH
2726: LD_INT 300
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: LIST
2733: PPUSH
2734: LD_INT 9
2736: PUSH
2737: LD_INT 5
2739: PUSH
2740: LD_INT 6
2742: PUSH
2743: LD_INT 6
2745: PUSH
2746: EMPTY
2747: LIST
2748: LIST
2749: LIST
2750: LIST
2751: PPUSH
2752: CALL 24108 0 6
2756: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2757: LD_ADDR_EXP 58
2761: PUSH
2762: LD_EXP 58
2766: PPUSH
2767: LD_INT 2
2769: PPUSH
2770: LD_EXP 49
2774: PPUSH
2775: CALL_OW 1
2779: ST_TO_ADDR
// tmp := [ ] ;
2780: LD_ADDR_VAR 0 4
2784: PUSH
2785: EMPTY
2786: ST_TO_ADDR
// for i = 1 to 4 do
2787: LD_ADDR_VAR 0 2
2791: PUSH
2792: DOUBLE
2793: LD_INT 1
2795: DEC
2796: ST_TO_ADDR
2797: LD_INT 4
2799: PUSH
2800: FOR_TO
2801: IFFALSE 2894
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2803: LD_INT 22
2805: PPUSH
2806: LD_INT 3
2808: PPUSH
2809: LD_INT 3
2811: PPUSH
2812: LD_INT 43
2814: PUSH
2815: LD_INT 45
2817: PUSH
2818: LD_INT 45
2820: PUSH
2821: LD_INT 44
2823: PUSH
2824: EMPTY
2825: LIST
2826: LIST
2827: LIST
2828: LIST
2829: PUSH
2830: LD_VAR 0 2
2834: PUSH
2835: LD_INT 4
2837: MOD
2838: PUSH
2839: LD_INT 1
2841: PLUS
2842: ARRAY
2843: PPUSH
2844: LD_INT 100
2846: PPUSH
2847: CALL 20699 0 5
// veh := CreateVehicle ;
2851: LD_ADDR_VAR 0 3
2855: PUSH
2856: CALL_OW 45
2860: ST_TO_ADDR
// tmp := tmp ^ veh ;
2861: LD_ADDR_VAR 0 4
2865: PUSH
2866: LD_VAR 0 4
2870: PUSH
2871: LD_VAR 0 3
2875: ADD
2876: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2877: LD_VAR 0 3
2881: PPUSH
2882: LD_INT 2
2884: PPUSH
2885: LD_INT 0
2887: PPUSH
2888: CALL_OW 49
// end ;
2892: GO 2800
2894: POP
2895: POP
// russian_guard := tmp ;
2896: LD_ADDR_EXP 50
2900: PUSH
2901: LD_VAR 0 4
2905: ST_TO_ADDR
// end ;
2906: LD_VAR 0 1
2910: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2911: LD_INT 47
2913: PPUSH
2914: CALL_OW 302
2918: PUSH
2919: LD_EXP 6
2923: AND
2924: IFFALSE 3526
2926: GO 2928
2928: DISABLE
2929: LD_INT 0
2931: PPUSH
2932: PPUSH
2933: PPUSH
2934: PPUSH
2935: PPUSH
2936: PPUSH
// begin enable ;
2937: ENABLE
// base := 2 ;
2938: LD_ADDR_VAR 0 2
2942: PUSH
2943: LD_INT 2
2945: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
2946: LD_ADDR_VAR 0 4
2950: PUSH
2951: LD_INT 0
2953: PUSH
2954: LD_INT 0
2956: PUSH
2957: LD_INT 0
2959: PUSH
2960: LD_INT 0
2962: PUSH
2963: LD_INT 0
2965: PUSH
2966: LD_INT 0
2968: PUSH
2969: LD_INT 0
2971: PUSH
2972: LD_INT 0
2974: PUSH
2975: LD_INT 1
2977: PUSH
2978: LD_INT 0
2980: PUSH
2981: EMPTY
2982: LIST
2983: LIST
2984: LIST
2985: LIST
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
2993: LD_ADDR_VAR 0 3
2997: PUSH
2998: LD_INT 22
3000: PUSH
3001: LD_INT 1
3003: PUSH
3004: LD_INT 3
3006: PUSH
3007: LD_INT 45
3009: PUSH
3010: EMPTY
3011: LIST
3012: LIST
3013: LIST
3014: LIST
3015: PUSH
3016: LD_INT 21
3018: PUSH
3019: LD_INT 1
3021: PUSH
3022: LD_INT 3
3024: PUSH
3025: LD_INT 45
3027: PUSH
3028: EMPTY
3029: LIST
3030: LIST
3031: LIST
3032: LIST
3033: PUSH
3034: LD_INT 22
3036: PUSH
3037: LD_INT 1
3039: PUSH
3040: LD_INT 3
3042: PUSH
3043: LD_INT 45
3045: PUSH
3046: EMPTY
3047: LIST
3048: LIST
3049: LIST
3050: LIST
3051: PUSH
3052: LD_INT 23
3054: PUSH
3055: LD_INT 1
3057: PUSH
3058: LD_INT 3
3060: PUSH
3061: LD_INT 46
3063: PUSH
3064: EMPTY
3065: LIST
3066: LIST
3067: LIST
3068: LIST
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: LIST
3074: LIST
3075: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3076: LD_ADDR_VAR 0 1
3080: PUSH
3081: DOUBLE
3082: LD_INT 1
3084: DEC
3085: ST_TO_ADDR
3086: LD_OWVAR 67
3090: PUSH
3091: LD_OWVAR 1
3095: PUSH
3096: LD_INT 21000
3098: DIV
3099: PLUS
3100: PUSH
3101: FOR_TO
3102: IFFALSE 3190
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3104: LD_ADDR_VAR 0 3
3108: PUSH
3109: LD_VAR 0 3
3113: PPUSH
3114: LD_VAR 0 3
3118: PUSH
3119: LD_INT 1
3121: PLUS
3122: PPUSH
3123: LD_INT 23
3125: PUSH
3126: LD_INT 24
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: PUSH
3133: LD_INT 1
3135: PPUSH
3136: LD_INT 2
3138: PPUSH
3139: CALL_OW 12
3143: ARRAY
3144: PUSH
3145: LD_INT 1
3147: PUSH
3148: LD_INT 3
3150: PUSH
3151: LD_INT 46
3153: PUSH
3154: LD_INT 47
3156: PUSH
3157: LD_INT 45
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: LIST
3164: PUSH
3165: LD_INT 1
3167: PPUSH
3168: LD_INT 3
3170: PPUSH
3171: CALL_OW 12
3175: ARRAY
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: LIST
3181: LIST
3182: PPUSH
3183: CALL_OW 2
3187: ST_TO_ADDR
3188: GO 3101
3190: POP
3191: POP
// MC_InsertProduceList ( base , tmp ) ;
3192: LD_VAR 0 2
3196: PPUSH
3197: LD_VAR 0 3
3201: PPUSH
3202: CALL 80244 0 2
// repeat wait ( 0 0$1 ) ;
3206: LD_INT 35
3208: PPUSH
3209: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3213: LD_EXP 77
3217: PUSH
3218: LD_VAR 0 2
3222: ARRAY
3223: PUSH
3224: LD_INT 6
3226: GREATER
3227: IFFALSE 3206
// wait ( 0 0$20 ) ;
3229: LD_INT 700
3231: PPUSH
3232: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3236: LD_ADDR_VAR 0 5
3240: PUSH
3241: LD_INT 71
3243: PUSH
3244: LD_INT 19
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: PUSH
3251: LD_INT 91
3253: PUSH
3254: LD_INT 67
3256: PUSH
3257: EMPTY
3258: LIST
3259: LIST
3260: PUSH
3261: LD_INT 52
3263: PUSH
3264: LD_INT 44
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: PUSH
3271: LD_INT 68
3273: PUSH
3274: LD_INT 48
3276: PUSH
3277: EMPTY
3278: LIST
3279: LIST
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3287: LD_ADDR_VAR 0 6
3291: PUSH
3292: LD_EXP 77
3296: PUSH
3297: LD_VAR 0 2
3301: ARRAY
3302: PUSH
3303: LD_EXP 77
3307: PUSH
3308: LD_VAR 0 2
3312: ARRAY
3313: PPUSH
3314: LD_INT 2
3316: PUSH
3317: LD_INT 34
3319: PUSH
3320: LD_INT 51
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: PUSH
3327: LD_INT 34
3329: PUSH
3330: LD_INT 52
3332: PUSH
3333: EMPTY
3334: LIST
3335: LIST
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: PPUSH
3342: CALL_OW 72
3346: DIFF
3347: ST_TO_ADDR
// if not attackers then
3348: LD_VAR 0 6
3352: NOT
3353: IFFALSE 3357
// exit ;
3355: GO 3526
// ru_attackers := attackers ;
3357: LD_ADDR_EXP 51
3361: PUSH
3362: LD_VAR 0 6
3366: ST_TO_ADDR
// for i = 1 to attackers do
3367: LD_ADDR_VAR 0 1
3371: PUSH
3372: DOUBLE
3373: LD_INT 1
3375: DEC
3376: ST_TO_ADDR
3377: LD_VAR 0 6
3381: PUSH
3382: FOR_TO
3383: IFFALSE 3460
// begin case i mod 3 of 0 :
3385: LD_VAR 0 1
3389: PUSH
3390: LD_INT 3
3392: MOD
3393: PUSH
3394: LD_INT 0
3396: DOUBLE
3397: EQUAL
3398: IFTRUE 3402
3400: GO 3405
3402: POP
// ; 1 :
3403: GO 3458
3405: LD_INT 1
3407: DOUBLE
3408: EQUAL
3409: IFTRUE 3413
3411: GO 3431
3413: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3414: LD_VAR 0 1
3418: PPUSH
3419: LD_INT 32
3421: PPUSH
3422: LD_INT 49
3424: PPUSH
3425: CALL_OW 114
3429: GO 3458
3431: LD_INT 2
3433: DOUBLE
3434: EQUAL
3435: IFTRUE 3439
3437: GO 3457
3439: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3440: LD_VAR 0 1
3444: PPUSH
3445: LD_INT 117
3447: PPUSH
3448: LD_INT 107
3450: PPUSH
3451: CALL_OW 114
3455: GO 3458
3457: POP
// end ;
3458: GO 3382
3460: POP
3461: POP
// repeat wait ( 0 0$1 ) ;
3462: LD_INT 35
3464: PPUSH
3465: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3469: LD_VAR 0 6
3473: PPUSH
3474: LD_INT 60
3476: PUSH
3477: EMPTY
3478: LIST
3479: PPUSH
3480: CALL_OW 72
3484: NOT
3485: IFFALSE 3462
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3487: LD_VAR 0 2
3491: PPUSH
3492: LD_VAR 0 6
3496: PPUSH
3497: LD_VAR 0 5
3501: PPUSH
3502: LD_VAR 0 4
3506: PPUSH
3507: CALL 80429 0 4
// if not first_attack then
3511: LD_EXP 7
3515: NOT
3516: IFFALSE 3526
// first_attack := true ;
3518: LD_ADDR_EXP 7
3522: PUSH
3523: LD_INT 1
3525: ST_TO_ADDR
// end ; end_of_file
3526: PPOPN 6
3528: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3529: LD_INT 0
3531: PPUSH
3532: PPUSH
3533: PPUSH
3534: PPUSH
3535: PPUSH
3536: PPUSH
3537: PPUSH
// uc_side := 2 ;
3538: LD_ADDR_OWVAR 20
3542: PUSH
3543: LD_INT 2
3545: ST_TO_ADDR
// uc_nation := 2 ;
3546: LD_ADDR_OWVAR 21
3550: PUSH
3551: LD_INT 2
3553: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3554: LD_ADDR_EXP 54
3558: PUSH
3559: LD_STRING Abdul
3561: PPUSH
3562: CALL_OW 25
3566: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3567: LD_EXP 54
3571: PPUSH
3572: LD_INT 11
3574: PPUSH
3575: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3579: LD_EXP 54
3583: PPUSH
3584: LD_INT 1
3586: PPUSH
3587: CALL_OW 52
// vc_chassis := 31 ;
3591: LD_ADDR_OWVAR 37
3595: PUSH
3596: LD_INT 31
3598: ST_TO_ADDR
// vc_control := control_rider ;
3599: LD_ADDR_OWVAR 38
3603: PUSH
3604: LD_INT 4
3606: ST_TO_ADDR
// mastodont := CreateVehicle ;
3607: LD_ADDR_EXP 55
3611: PUSH
3612: CALL_OW 45
3616: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3617: LD_EXP 55
3621: PPUSH
3622: LD_INT 153
3624: PPUSH
3625: LD_INT 71
3627: PPUSH
3628: LD_INT 0
3630: PPUSH
3631: CALL_OW 48
// InitVc ;
3635: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3639: LD_ADDR_EXP 52
3643: PUSH
3644: LD_INT 1
3646: PPUSH
3647: LD_INT 3
3649: PPUSH
3650: LD_STRING 
3652: PPUSH
3653: LD_INT 7
3655: PUSH
3656: LD_INT 8
3658: PUSH
3659: LD_INT 9
3661: PUSH
3662: EMPTY
3663: LIST
3664: LIST
3665: LIST
3666: PUSH
3667: LD_OWVAR 67
3671: ARRAY
3672: PPUSH
3673: LD_INT 5000
3675: PUSH
3676: LD_INT 1000
3678: PUSH
3679: LD_INT 300
3681: PUSH
3682: EMPTY
3683: LIST
3684: LIST
3685: LIST
3686: PPUSH
3687: LD_INT 22
3689: PUSH
3690: LD_INT 5
3692: PUSH
3693: LD_INT 6
3695: PUSH
3696: LD_INT 9
3698: PUSH
3699: EMPTY
3700: LIST
3701: LIST
3702: LIST
3703: LIST
3704: PPUSH
3705: CALL 24108 0 6
3709: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3710: LD_ADDR_EXP 58
3714: PUSH
3715: LD_EXP 58
3719: PPUSH
3720: LD_INT 1
3722: PPUSH
3723: LD_EXP 52
3727: PPUSH
3728: CALL_OW 1
3732: ST_TO_ADDR
// tmp := [ ] ;
3733: LD_ADDR_VAR 0 4
3737: PUSH
3738: EMPTY
3739: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3740: LD_ADDR_OWVAR 37
3744: PUSH
3745: LD_INT 14
3747: ST_TO_ADDR
// vc_engine := engine_siberite ;
3748: LD_ADDR_OWVAR 39
3752: PUSH
3753: LD_INT 3
3755: ST_TO_ADDR
// vc_control := control_manual ;
3756: LD_ADDR_OWVAR 38
3760: PUSH
3761: LD_INT 1
3763: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3764: LD_ADDR_OWVAR 40
3768: PUSH
3769: LD_INT 31
3771: ST_TO_ADDR
// for i = 1 to 3 do
3772: LD_ADDR_VAR 0 2
3776: PUSH
3777: DOUBLE
3778: LD_INT 1
3780: DEC
3781: ST_TO_ADDR
3782: LD_INT 3
3784: PUSH
3785: FOR_TO
3786: IFFALSE 4030
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3788: LD_ADDR_VAR 0 5
3792: PUSH
3793: LD_INT 153
3795: PUSH
3796: LD_INT 71
3798: PUSH
3799: EMPTY
3800: LIST
3801: LIST
3802: PUSH
3803: LD_INT 155
3805: PUSH
3806: LD_INT 81
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: PUSH
3813: EMPTY
3814: LIST
3815: LIST
3816: PUSH
3817: LD_VAR 0 2
3821: PUSH
3822: LD_INT 2
3824: MOD
3825: PUSH
3826: LD_INT 1
3828: PLUS
3829: ARRAY
3830: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3831: LD_INT 0
3833: PPUSH
3834: LD_INT 3
3836: PPUSH
3837: LD_INT 7
3839: PUSH
3840: LD_INT 8
3842: PUSH
3843: LD_INT 9
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: LIST
3850: PUSH
3851: LD_OWVAR 67
3855: ARRAY
3856: PPUSH
3857: CALL_OW 380
// un := CreateVehicle ;
3861: LD_ADDR_VAR 0 6
3865: PUSH
3866: CALL_OW 45
3870: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3871: LD_VAR 0 6
3875: PPUSH
3876: LD_INT 0
3878: PPUSH
3879: LD_INT 5
3881: PPUSH
3882: CALL_OW 12
3886: PPUSH
3887: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3891: LD_VAR 0 6
3895: PPUSH
3896: LD_VAR 0 5
3900: PUSH
3901: LD_INT 1
3903: ARRAY
3904: PPUSH
3905: LD_VAR 0 5
3909: PUSH
3910: LD_INT 2
3912: ARRAY
3913: PPUSH
3914: LD_INT 6
3916: PPUSH
3917: LD_INT 0
3919: PPUSH
3920: CALL_OW 50
// un2 := CreateHuman ;
3924: LD_ADDR_VAR 0 7
3928: PUSH
3929: CALL_OW 44
3933: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
3934: LD_VAR 0 7
3938: PPUSH
3939: LD_VAR 0 6
3943: PPUSH
3944: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
3948: LD_ADDR_EXP 58
3952: PUSH
3953: LD_EXP 58
3957: PPUSH
3958: LD_INT 1
3960: PUSH
3961: LD_EXP 58
3965: PUSH
3966: LD_INT 1
3968: ARRAY
3969: PUSH
3970: LD_INT 1
3972: PLUS
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PPUSH
3978: LD_VAR 0 6
3982: PPUSH
3983: CALL 20821 0 3
3987: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
3988: LD_ADDR_EXP 58
3992: PUSH
3993: LD_EXP 58
3997: PPUSH
3998: LD_INT 1
4000: PUSH
4001: LD_EXP 58
4005: PUSH
4006: LD_INT 1
4008: ARRAY
4009: PUSH
4010: LD_INT 1
4012: PLUS
4013: PUSH
4014: EMPTY
4015: LIST
4016: LIST
4017: PPUSH
4018: LD_VAR 0 7
4022: PPUSH
4023: CALL 20821 0 3
4027: ST_TO_ADDR
// end ;
4028: GO 3785
4030: POP
4031: POP
// for i = 1 to 5 do
4032: LD_ADDR_VAR 0 2
4036: PUSH
4037: DOUBLE
4038: LD_INT 1
4040: DEC
4041: ST_TO_ADDR
4042: LD_INT 5
4044: PUSH
4045: FOR_TO
4046: IFFALSE 4139
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4048: LD_INT 14
4050: PPUSH
4051: LD_INT 3
4053: PPUSH
4054: LD_INT 1
4056: PPUSH
4057: LD_INT 25
4059: PUSH
4060: LD_INT 28
4062: PUSH
4063: LD_INT 28
4065: PUSH
4066: LD_INT 26
4068: PUSH
4069: EMPTY
4070: LIST
4071: LIST
4072: LIST
4073: LIST
4074: PUSH
4075: LD_VAR 0 2
4079: PUSH
4080: LD_INT 4
4082: MOD
4083: PUSH
4084: LD_INT 1
4086: PLUS
4087: ARRAY
4088: PPUSH
4089: LD_INT 100
4091: PPUSH
4092: CALL 20699 0 5
// veh := CreateVehicle ;
4096: LD_ADDR_VAR 0 3
4100: PUSH
4101: CALL_OW 45
4105: ST_TO_ADDR
// tmp := tmp ^ veh ;
4106: LD_ADDR_VAR 0 4
4110: PUSH
4111: LD_VAR 0 4
4115: PUSH
4116: LD_VAR 0 3
4120: ADD
4121: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4122: LD_VAR 0 3
4126: PPUSH
4127: LD_INT 1
4129: PPUSH
4130: LD_INT 0
4132: PPUSH
4133: CALL_OW 49
// end ;
4137: GO 4045
4139: POP
4140: POP
// arabian_guard := tmp ;
4141: LD_ADDR_EXP 53
4145: PUSH
4146: LD_VAR 0 4
4150: ST_TO_ADDR
// end ;
4151: LD_VAR 0 1
4155: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4156: LD_INT 22
4158: PUSH
4159: LD_INT 7
4161: PUSH
4162: EMPTY
4163: LIST
4164: LIST
4165: PUSH
4166: LD_INT 91
4168: PUSH
4169: LD_INT 1
4171: PUSH
4172: LD_INT 12
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: LIST
4179: PUSH
4180: EMPTY
4181: LIST
4182: LIST
4183: PPUSH
4184: CALL_OW 69
4188: PUSH
4189: LD_EXP 55
4193: PPUSH
4194: CALL_OW 256
4198: PUSH
4199: LD_INT 990
4201: LESS
4202: OR
4203: PUSH
4204: LD_EXP 54
4208: PPUSH
4209: CALL_OW 256
4213: PUSH
4214: LD_INT 990
4216: LESS
4217: OR
4218: IFFALSE 4361
4220: GO 4222
4222: DISABLE
// begin if IsInUnit ( Abdul ) then
4223: LD_EXP 54
4227: PPUSH
4228: CALL_OW 310
4232: IFFALSE 4243
// ComExitBuilding ( Abdul ) ;
4234: LD_EXP 54
4238: PPUSH
4239: CALL_OW 122
// if Mastodont then
4243: LD_EXP 55
4247: IFFALSE 4264
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4249: LD_EXP 55
4253: PPUSH
4254: LD_INT 205
4256: PPUSH
4257: LD_INT 132
4259: PPUSH
4260: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4264: LD_EXP 54
4268: PPUSH
4269: LD_INT 205
4271: PPUSH
4272: LD_INT 132
4274: PPUSH
4275: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4279: LD_INT 35
4281: PPUSH
4282: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4286: LD_EXP 54
4290: PPUSH
4291: LD_INT 21
4293: PPUSH
4294: CALL_OW 308
4298: IFFALSE 4279
// RemoveUnit ( Abdul ) ;
4300: LD_EXP 54
4304: PPUSH
4305: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4309: LD_INT 35
4311: PPUSH
4312: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4316: LD_EXP 55
4320: PPUSH
4321: LD_INT 21
4323: PPUSH
4324: CALL_OW 308
4328: PUSH
4329: LD_EXP 55
4333: PPUSH
4334: CALL_OW 301
4338: OR
4339: IFFALSE 4309
// if IsOk ( Mastodont ) then
4341: LD_EXP 55
4345: PPUSH
4346: CALL_OW 302
4350: IFFALSE 4361
// RemoveUnit ( Mastodont ) ;
4352: LD_EXP 55
4356: PPUSH
4357: CALL_OW 64
// end ;
4361: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4362: LD_EXP 54
4366: PPUSH
4367: CALL_OW 301
4371: PUSH
4372: LD_INT 22
4374: PUSH
4375: LD_INT 2
4377: PUSH
4378: EMPTY
4379: LIST
4380: LIST
4381: PUSH
4382: LD_INT 2
4384: PUSH
4385: LD_INT 25
4387: PUSH
4388: LD_INT 1
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 25
4397: PUSH
4398: LD_INT 2
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: LD_INT 25
4407: PUSH
4408: LD_INT 3
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: LD_INT 25
4417: PUSH
4418: LD_INT 4
4420: PUSH
4421: EMPTY
4422: LIST
4423: LIST
4424: PUSH
4425: LD_INT 25
4427: PUSH
4428: LD_INT 8
4430: PUSH
4431: EMPTY
4432: LIST
4433: LIST
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: LIST
4440: LIST
4441: LIST
4442: PUSH
4443: EMPTY
4444: LIST
4445: LIST
4446: PPUSH
4447: CALL_OW 69
4451: PUSH
4452: LD_INT 16
4454: PUSH
4455: LD_INT 19
4457: PUSH
4458: LD_INT 22
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: LIST
4465: PUSH
4466: LD_OWVAR 67
4470: ARRAY
4471: LESS
4472: OR
4473: IFFALSE 5146
4475: GO 4477
4477: DISABLE
4478: LD_INT 0
4480: PPUSH
4481: PPUSH
4482: PPUSH
4483: PPUSH
4484: PPUSH
4485: PPUSH
// begin MC_Kill ( 1 ) ;
4486: LD_INT 1
4488: PPUSH
4489: CALL 56896 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4493: LD_ADDR_VAR 0 2
4497: PUSH
4498: LD_INT 22
4500: PUSH
4501: LD_INT 2
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: PUSH
4508: LD_INT 2
4510: PUSH
4511: LD_INT 25
4513: PUSH
4514: LD_INT 1
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: PUSH
4521: LD_INT 25
4523: PUSH
4524: LD_INT 2
4526: PUSH
4527: EMPTY
4528: LIST
4529: LIST
4530: PUSH
4531: LD_INT 25
4533: PUSH
4534: LD_INT 3
4536: PUSH
4537: EMPTY
4538: LIST
4539: LIST
4540: PUSH
4541: LD_INT 25
4543: PUSH
4544: LD_INT 4
4546: PUSH
4547: EMPTY
4548: LIST
4549: LIST
4550: PUSH
4551: LD_INT 25
4553: PUSH
4554: LD_INT 8
4556: PUSH
4557: EMPTY
4558: LIST
4559: LIST
4560: PUSH
4561: EMPTY
4562: LIST
4563: LIST
4564: LIST
4565: LIST
4566: LIST
4567: LIST
4568: PUSH
4569: EMPTY
4570: LIST
4571: LIST
4572: PPUSH
4573: CALL_OW 69
4577: ST_TO_ADDR
// for i in tmp do
4578: LD_ADDR_VAR 0 5
4582: PUSH
4583: LD_VAR 0 2
4587: PUSH
4588: FOR_IN
4589: IFFALSE 4605
// SetTag ( i , 10 ) ;
4591: LD_VAR 0 5
4595: PPUSH
4596: LD_INT 10
4598: PPUSH
4599: CALL_OW 109
4603: GO 4588
4605: POP
4606: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4607: LD_ADDR_VAR 0 3
4611: PUSH
4612: LD_INT 22
4614: PUSH
4615: LD_INT 2
4617: PUSH
4618: EMPTY
4619: LIST
4620: LIST
4621: PUSH
4622: LD_INT 21
4624: PUSH
4625: LD_INT 1
4627: PUSH
4628: EMPTY
4629: LIST
4630: LIST
4631: PUSH
4632: EMPTY
4633: LIST
4634: LIST
4635: PPUSH
4636: CALL_OW 69
4640: PUSH
4641: LD_VAR 0 2
4645: DIFF
4646: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4647: LD_ADDR_VAR 0 1
4651: PUSH
4652: LD_INT 22
4654: PUSH
4655: LD_INT 2
4657: PUSH
4658: EMPTY
4659: LIST
4660: LIST
4661: PUSH
4662: LD_INT 21
4664: PUSH
4665: LD_INT 2
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: PUSH
4672: LD_INT 24
4674: PUSH
4675: LD_INT 300
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: LIST
4686: PPUSH
4687: CALL_OW 69
4691: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4692: LD_ADDR_VAR 0 4
4696: PUSH
4697: LD_VAR 0 1
4701: PPUSH
4702: LD_INT 33
4704: PUSH
4705: LD_INT 1
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: LD_INT 58
4714: PUSH
4715: EMPTY
4716: LIST
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PPUSH
4722: CALL_OW 72
4726: ST_TO_ADDR
// for i in tmp do
4727: LD_ADDR_VAR 0 5
4731: PUSH
4732: LD_VAR 0 2
4736: PUSH
4737: FOR_IN
4738: IFFALSE 4922
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4740: LD_VAR 0 5
4744: PUSH
4745: LD_INT 55
4747: PUSH
4748: EMPTY
4749: LIST
4750: PPUSH
4751: CALL_OW 69
4755: IN
4756: IFFALSE 4775
// begin AddComMoveXY ( i , 209 , 132 ) ;
4758: LD_VAR 0 5
4762: PPUSH
4763: LD_INT 209
4765: PPUSH
4766: LD_INT 132
4768: PPUSH
4769: CALL_OW 171
// continue ;
4773: GO 4737
// end ; if IsInUnit ( i ) then
4775: LD_VAR 0 5
4779: PPUSH
4780: CALL_OW 310
4784: IFFALSE 4802
// begin ComExitBuilding ( i ) ;
4786: LD_VAR 0 5
4790: PPUSH
4791: CALL_OW 122
// wait ( 3 ) ;
4795: LD_INT 3
4797: PPUSH
4798: CALL_OW 67
// end ; if tmp_empty then
4802: LD_VAR 0 4
4806: IFFALSE 4905
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4808: LD_VAR 0 5
4812: PPUSH
4813: LD_VAR 0 4
4817: PPUSH
4818: LD_VAR 0 5
4822: PPUSH
4823: CALL_OW 74
4827: PPUSH
4828: CALL_OW 296
4832: PUSH
4833: LD_INT 25
4835: LESS
4836: IFFALSE 4905
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4838: LD_ADDR_VAR 0 6
4842: PUSH
4843: LD_VAR 0 4
4847: PPUSH
4848: LD_VAR 0 5
4852: PPUSH
4853: CALL_OW 74
4857: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4858: LD_VAR 0 5
4862: PPUSH
4863: LD_VAR 0 6
4867: PPUSH
4868: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4872: LD_VAR 0 5
4876: PPUSH
4877: LD_INT 209
4879: PPUSH
4880: LD_INT 132
4882: PPUSH
4883: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4887: LD_ADDR_VAR 0 4
4891: PUSH
4892: LD_VAR 0 4
4896: PUSH
4897: LD_VAR 0 6
4901: DIFF
4902: ST_TO_ADDR
// continue ;
4903: GO 4737
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4905: LD_VAR 0 5
4909: PPUSH
4910: LD_INT 201
4912: PPUSH
4913: LD_INT 132
4915: PPUSH
4916: CALL_OW 171
// end ;
4920: GO 4737
4922: POP
4923: POP
// for i in tmp_ape do
4924: LD_ADDR_VAR 0 5
4928: PUSH
4929: LD_VAR 0 3
4933: PUSH
4934: FOR_IN
4935: IFFALSE 4974
// begin if IsInUnit ( i ) then
4937: LD_VAR 0 5
4941: PPUSH
4942: CALL_OW 310
4946: IFFALSE 4957
// ComExitBuilding ( i ) ;
4948: LD_VAR 0 5
4952: PPUSH
4953: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
4957: LD_VAR 0 5
4961: PPUSH
4962: LD_INT 201
4964: PPUSH
4965: LD_INT 132
4967: PPUSH
4968: CALL_OW 171
// end ;
4972: GO 4934
4974: POP
4975: POP
// repeat wait ( 0 0$1 ) ;
4976: LD_INT 35
4978: PPUSH
4979: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
4983: LD_ADDR_VAR 0 5
4987: PUSH
4988: LD_VAR 0 2
4992: PUSH
4993: LD_VAR 0 3
4997: UNION
4998: PUSH
4999: LD_VAR 0 1
5003: UNION
5004: PUSH
5005: FOR_IN
5006: IFFALSE 5037
// if not HasTask ( i ) then
5008: LD_VAR 0 5
5012: PPUSH
5013: CALL_OW 314
5017: NOT
5018: IFFALSE 5035
// ComMoveXY ( i , 201 , 132 ) ;
5020: LD_VAR 0 5
5024: PPUSH
5025: LD_INT 201
5027: PPUSH
5028: LD_INT 132
5030: PPUSH
5031: CALL_OW 111
5035: GO 5005
5037: POP
5038: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5039: LD_INT 21
5041: PPUSH
5042: LD_INT 22
5044: PUSH
5045: LD_INT 2
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PPUSH
5052: CALL_OW 70
5056: IFFALSE 5097
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5058: LD_ADDR_VAR 0 5
5062: PUSH
5063: LD_INT 21
5065: PPUSH
5066: LD_INT 22
5068: PUSH
5069: LD_INT 2
5071: PUSH
5072: EMPTY
5073: LIST
5074: LIST
5075: PPUSH
5076: CALL_OW 70
5080: PUSH
5081: FOR_IN
5082: IFFALSE 5095
// RemoveUnit ( i ) ;
5084: LD_VAR 0 5
5088: PPUSH
5089: CALL_OW 64
5093: GO 5081
5095: POP
5096: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5097: LD_INT 22
5099: PUSH
5100: LD_INT 2
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 2
5109: PUSH
5110: LD_INT 21
5112: PUSH
5113: LD_INT 1
5115: PUSH
5116: EMPTY
5117: LIST
5118: LIST
5119: PUSH
5120: LD_INT 21
5122: PUSH
5123: LD_INT 2
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: PUSH
5130: EMPTY
5131: LIST
5132: LIST
5133: LIST
5134: PUSH
5135: EMPTY
5136: LIST
5137: LIST
5138: PPUSH
5139: CALL_OW 69
5143: NOT
5144: IFFALSE 4976
// end ;
5146: PPOPN 6
5148: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5149: LD_EXP 9
5153: PUSH
5154: LD_INT 92
5156: PPUSH
5157: LD_INT 40
5159: PPUSH
5160: CALL_OW 428
5164: PPUSH
5165: CALL_OW 266
5169: PUSH
5170: LD_INT 30
5172: EQUAL
5173: AND
5174: IFFALSE 5370
5176: GO 5178
5178: DISABLE
5179: LD_INT 0
5181: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5182: LD_ADDR_VAR 0 1
5186: PUSH
5187: LD_EXP 58
5191: PUSH
5192: LD_INT 1
5194: ARRAY
5195: PPUSH
5196: LD_INT 25
5198: PUSH
5199: LD_INT 4
5201: PUSH
5202: EMPTY
5203: LIST
5204: LIST
5205: PPUSH
5206: CALL_OW 72
5210: ST_TO_ADDR
// if not sci then
5211: LD_VAR 0 1
5215: NOT
5216: IFFALSE 5220
// exit ;
5218: GO 5370
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5220: LD_ADDR_EXP 58
5224: PUSH
5225: LD_EXP 58
5229: PPUSH
5230: LD_INT 1
5232: PPUSH
5233: LD_EXP 58
5237: PUSH
5238: LD_INT 1
5240: ARRAY
5241: PUSH
5242: LD_VAR 0 1
5246: PUSH
5247: LD_INT 1
5249: ARRAY
5250: DIFF
5251: PPUSH
5252: CALL_OW 1
5256: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5257: LD_VAR 0 1
5261: PUSH
5262: LD_INT 1
5264: ARRAY
5265: PPUSH
5266: CALL_OW 310
5270: IFFALSE 5285
// ComExitBuilding ( sci [ 1 ] ) ;
5272: LD_VAR 0 1
5276: PUSH
5277: LD_INT 1
5279: ARRAY
5280: PPUSH
5281: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5285: LD_INT 2
5287: PPUSH
5288: LD_INT 105
5290: PPUSH
5291: LD_INT 14
5293: PPUSH
5294: LD_INT 20
5296: PPUSH
5297: CALL 21717 0 4
5301: PUSH
5302: LD_INT 4
5304: ARRAY
5305: PUSH
5306: LD_INT 10
5308: LESS
5309: IFFALSE 5332
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5311: LD_VAR 0 1
5315: PUSH
5316: LD_INT 1
5318: ARRAY
5319: PPUSH
5320: LD_INT 105
5322: PPUSH
5323: LD_INT 14
5325: PPUSH
5326: CALL_OW 171
5330: GO 5351
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5332: LD_VAR 0 1
5336: PUSH
5337: LD_INT 1
5339: ARRAY
5340: PPUSH
5341: LD_INT 118
5343: PPUSH
5344: LD_INT 77
5346: PPUSH
5347: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5351: LD_VAR 0 1
5355: PUSH
5356: LD_INT 1
5358: ARRAY
5359: PPUSH
5360: LD_INT 92
5362: PPUSH
5363: LD_INT 40
5365: PPUSH
5366: CALL_OW 218
// end ;
5370: PPOPN 1
5372: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5373: LD_INT 1
5375: PPUSH
5376: CALL_OW 302
5380: PUSH
5381: LD_EXP 9
5385: AND
5386: IFFALSE 5845
5388: GO 5390
5390: DISABLE
5391: LD_INT 0
5393: PPUSH
5394: PPUSH
5395: PPUSH
5396: PPUSH
5397: PPUSH
5398: PPUSH
// begin enable ;
5399: ENABLE
// base := 1 ;
5400: LD_ADDR_VAR 0 2
5404: PUSH
5405: LD_INT 1
5407: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5408: LD_ADDR_VAR 0 4
5412: PUSH
5413: LD_INT 0
5415: PUSH
5416: LD_INT 0
5418: PUSH
5419: LD_INT 0
5421: PUSH
5422: LD_INT 0
5424: PUSH
5425: LD_INT 0
5427: PUSH
5428: LD_INT 0
5430: PUSH
5431: LD_INT 0
5433: PUSH
5434: LD_INT 0
5436: PUSH
5437: LD_INT 1
5439: PUSH
5440: LD_INT 0
5442: PUSH
5443: EMPTY
5444: LIST
5445: LIST
5446: LIST
5447: LIST
5448: LIST
5449: LIST
5450: LIST
5451: LIST
5452: LIST
5453: LIST
5454: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5455: LD_ADDR_VAR 0 3
5459: PUSH
5460: LD_INT 14
5462: PUSH
5463: LD_INT 1
5465: PUSH
5466: LD_INT 2
5468: PUSH
5469: LD_INT 26
5471: PUSH
5472: EMPTY
5473: LIST
5474: LIST
5475: LIST
5476: LIST
5477: PUSH
5478: LD_INT 14
5480: PUSH
5481: LD_INT 1
5483: PUSH
5484: LD_INT 2
5486: PUSH
5487: LD_INT 28
5489: PUSH
5490: EMPTY
5491: LIST
5492: LIST
5493: LIST
5494: LIST
5495: PUSH
5496: LD_INT 13
5498: PUSH
5499: LD_INT 1
5501: PUSH
5502: LD_INT 2
5504: PUSH
5505: LD_INT 29
5507: PUSH
5508: EMPTY
5509: LIST
5510: LIST
5511: LIST
5512: LIST
5513: PUSH
5514: EMPTY
5515: LIST
5516: LIST
5517: LIST
5518: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5519: LD_ADDR_VAR 0 1
5523: PUSH
5524: DOUBLE
5525: LD_INT 1
5527: DEC
5528: ST_TO_ADDR
5529: LD_OWVAR 67
5533: PUSH
5534: LD_OWVAR 1
5538: PUSH
5539: LD_INT 21000
5541: DIV
5542: PLUS
5543: PUSH
5544: FOR_TO
5545: IFFALSE 5637
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5547: LD_ADDR_VAR 0 3
5551: PUSH
5552: LD_VAR 0 3
5556: PPUSH
5557: LD_VAR 0 3
5561: PUSH
5562: LD_INT 1
5564: PLUS
5565: PPUSH
5566: LD_INT 13
5568: PUSH
5569: LD_INT 14
5571: PUSH
5572: EMPTY
5573: LIST
5574: LIST
5575: PUSH
5576: LD_INT 1
5578: PPUSH
5579: LD_INT 2
5581: PPUSH
5582: CALL_OW 12
5586: ARRAY
5587: PUSH
5588: LD_INT 1
5590: PUSH
5591: LD_INT 2
5593: PUSH
5594: LD_INT 28
5596: PUSH
5597: LD_INT 29
5599: PUSH
5600: LD_INT 25
5602: PUSH
5603: LD_INT 26
5605: PUSH
5606: EMPTY
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: PUSH
5612: LD_INT 1
5614: PPUSH
5615: LD_INT 4
5617: PPUSH
5618: CALL_OW 12
5622: ARRAY
5623: PUSH
5624: EMPTY
5625: LIST
5626: LIST
5627: LIST
5628: LIST
5629: PPUSH
5630: CALL_OW 2
5634: ST_TO_ADDR
5635: GO 5544
5637: POP
5638: POP
// MC_InsertProduceList ( base , tmp ) ;
5639: LD_VAR 0 2
5643: PPUSH
5644: LD_VAR 0 3
5648: PPUSH
5649: CALL 80244 0 2
// repeat wait ( 0 0$1 ) ;
5653: LD_INT 35
5655: PPUSH
5656: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5660: LD_EXP 77
5664: PUSH
5665: LD_VAR 0 2
5669: ARRAY
5670: PUSH
5671: LD_INT 6
5673: GREATER
5674: IFFALSE 5653
// wait ( 0 0$20 ) ;
5676: LD_INT 700
5678: PPUSH
5679: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5683: LD_ADDR_VAR 0 5
5687: PUSH
5688: LD_INT 124
5690: PUSH
5691: LD_INT 85
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: PUSH
5698: LD_INT 90
5700: PUSH
5701: LD_INT 61
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: PUSH
5708: LD_INT 69
5710: PUSH
5711: LD_INT 48
5713: PUSH
5714: EMPTY
5715: LIST
5716: LIST
5717: PUSH
5718: LD_INT 68
5720: PUSH
5721: LD_INT 48
5723: PUSH
5724: EMPTY
5725: LIST
5726: LIST
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: LIST
5732: LIST
5733: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5734: LD_ADDR_VAR 0 6
5738: PUSH
5739: LD_EXP 77
5743: PUSH
5744: LD_VAR 0 2
5748: ARRAY
5749: PUSH
5750: LD_EXP 77
5754: PUSH
5755: LD_VAR 0 2
5759: ARRAY
5760: PPUSH
5761: LD_INT 34
5763: PUSH
5764: LD_INT 32
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: PPUSH
5771: CALL_OW 72
5775: DIFF
5776: ST_TO_ADDR
// if not attackers then
5777: LD_VAR 0 6
5781: NOT
5782: IFFALSE 5786
// exit ;
5784: GO 5845
// ar_attackers := attackers ;
5786: LD_ADDR_EXP 10
5790: PUSH
5791: LD_VAR 0 6
5795: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5796: LD_INT 35
5798: PPUSH
5799: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5803: LD_VAR 0 6
5807: PPUSH
5808: LD_INT 60
5810: PUSH
5811: EMPTY
5812: LIST
5813: PPUSH
5814: CALL_OW 72
5818: NOT
5819: IFFALSE 5796
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5821: LD_VAR 0 2
5825: PPUSH
5826: LD_VAR 0 6
5830: PPUSH
5831: LD_VAR 0 5
5835: PPUSH
5836: LD_VAR 0 4
5840: PPUSH
5841: CALL 80429 0 4
// end ;
5845: PPOPN 6
5847: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5848: LD_INT 1
5850: PPUSH
5851: CALL_OW 302
5855: PUSH
5856: LD_EXP 9
5860: AND
5861: PUSH
5862: LD_EXP 48
5866: PPUSH
5867: LD_INT 22
5869: PPUSH
5870: CALL_OW 308
5874: AND
5875: PUSH
5876: LD_INT 1
5878: PPUSH
5879: CALL 80592 0 1
5883: PUSH
5884: LD_INT 0
5886: EQUAL
5887: AND
5888: PUSH
5889: LD_EXP 10
5893: NOT
5894: AND
5895: IFFALSE 6359
5897: GO 5899
5899: DISABLE
5900: LD_INT 0
5902: PPUSH
5903: PPUSH
5904: PPUSH
5905: PPUSH
5906: PPUSH
5907: PPUSH
5908: PPUSH
// begin base := 1 ;
5909: LD_ADDR_VAR 0 2
5913: PUSH
5914: LD_INT 1
5916: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5917: LD_ADDR_VAR 0 4
5921: PUSH
5922: LD_INT 0
5924: PUSH
5925: LD_INT 0
5927: PUSH
5928: LD_INT 0
5930: PUSH
5931: LD_INT 0
5933: PUSH
5934: LD_INT 0
5936: PUSH
5937: LD_INT 0
5939: PUSH
5940: LD_INT 0
5942: PUSH
5943: LD_INT 0
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 0
5951: PUSH
5952: EMPTY
5953: LIST
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: LIST
5961: LIST
5962: LIST
5963: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
5964: LD_ADDR_VAR 0 3
5968: PUSH
5969: LD_INT 13
5971: PUSH
5972: LD_INT 1
5974: PUSH
5975: LD_INT 2
5977: PUSH
5978: LD_INT 28
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: LIST
5985: LIST
5986: PUSH
5987: LD_INT 13
5989: PUSH
5990: LD_INT 1
5992: PUSH
5993: LD_INT 2
5995: PUSH
5996: LD_INT 27
5998: PUSH
5999: EMPTY
6000: LIST
6001: LIST
6002: LIST
6003: LIST
6004: PUSH
6005: LD_INT 13
6007: PUSH
6008: LD_INT 1
6010: PUSH
6011: LD_INT 2
6013: PUSH
6014: LD_INT 25
6016: PUSH
6017: EMPTY
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: PUSH
6023: LD_INT 11
6025: PUSH
6026: LD_INT 2
6028: PUSH
6029: LD_INT 2
6031: PUSH
6032: LD_INT 24
6034: PUSH
6035: EMPTY
6036: LIST
6037: LIST
6038: LIST
6039: LIST
6040: PUSH
6041: LD_INT 11
6043: PUSH
6044: LD_INT 2
6046: PUSH
6047: LD_INT 2
6049: PUSH
6050: LD_INT 24
6052: PUSH
6053: EMPTY
6054: LIST
6055: LIST
6056: LIST
6057: LIST
6058: PUSH
6059: EMPTY
6060: LIST
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6066: LD_VAR 0 2
6070: PPUSH
6071: LD_VAR 0 3
6075: PPUSH
6076: CALL 80244 0 2
// repeat wait ( 0 0$1 ) ;
6080: LD_INT 35
6082: PPUSH
6083: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6087: LD_EXP 77
6091: PUSH
6092: LD_VAR 0 2
6096: ARRAY
6097: PUSH
6098: LD_INT 6
6100: GREATEREQUAL
6101: IFFALSE 6080
// wait ( 0 0$20 ) ;
6103: LD_INT 700
6105: PPUSH
6106: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6110: LD_ADDR_VAR 0 5
6114: PUSH
6115: LD_INT 119
6117: PUSH
6118: LD_INT 9
6120: PUSH
6121: EMPTY
6122: LIST
6123: LIST
6124: PUSH
6125: EMPTY
6126: LIST
6127: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6128: LD_ADDR_VAR 0 6
6132: PUSH
6133: LD_EXP 77
6137: PUSH
6138: LD_VAR 0 2
6142: ARRAY
6143: PUSH
6144: LD_EXP 77
6148: PUSH
6149: LD_VAR 0 2
6153: ARRAY
6154: PPUSH
6155: LD_INT 34
6157: PUSH
6158: LD_INT 32
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: PPUSH
6165: CALL_OW 72
6169: DIFF
6170: ST_TO_ADDR
// if not attackers then
6171: LD_VAR 0 6
6175: NOT
6176: IFFALSE 6180
// exit ;
6178: GO 6359
// uc_side := 2 ;
6180: LD_ADDR_OWVAR 20
6184: PUSH
6185: LD_INT 2
6187: ST_TO_ADDR
// uc_nation := 2 ;
6188: LD_ADDR_OWVAR 21
6192: PUSH
6193: LD_INT 2
6195: ST_TO_ADDR
// InitHc ;
6196: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6200: LD_ADDR_VAR 0 1
6204: PUSH
6205: DOUBLE
6206: LD_INT 1
6208: DEC
6209: ST_TO_ADDR
6210: LD_INT 4
6212: PUSH
6213: LD_INT 5
6215: PUSH
6216: LD_INT 6
6218: PUSH
6219: EMPTY
6220: LIST
6221: LIST
6222: LIST
6223: PUSH
6224: LD_OWVAR 67
6228: ARRAY
6229: PUSH
6230: FOR_TO
6231: IFFALSE 6308
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6233: LD_INT 0
6235: PPUSH
6236: LD_INT 15
6238: PUSH
6239: LD_INT 17
6241: PUSH
6242: EMPTY
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 1
6248: PPUSH
6249: LD_INT 2
6251: PPUSH
6252: CALL_OW 12
6256: ARRAY
6257: PPUSH
6258: LD_INT 8
6260: PPUSH
6261: CALL_OW 380
// un := CreateHuman ;
6265: LD_ADDR_VAR 0 7
6269: PUSH
6270: CALL_OW 44
6274: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6275: LD_VAR 0 7
6279: PPUSH
6280: LD_INT 23
6282: PPUSH
6283: LD_INT 0
6285: PPUSH
6286: CALL_OW 49
// attackers := attackers union un ;
6290: LD_ADDR_VAR 0 6
6294: PUSH
6295: LD_VAR 0 6
6299: PUSH
6300: LD_VAR 0 7
6304: UNION
6305: ST_TO_ADDR
// end ;
6306: GO 6230
6308: POP
6309: POP
// repeat wait ( 0 0$1 ) ;
6310: LD_INT 35
6312: PPUSH
6313: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6317: LD_VAR 0 6
6321: PPUSH
6322: LD_INT 60
6324: PUSH
6325: EMPTY
6326: LIST
6327: PPUSH
6328: CALL_OW 72
6332: NOT
6333: IFFALSE 6310
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6335: LD_VAR 0 2
6339: PPUSH
6340: LD_VAR 0 6
6344: PPUSH
6345: LD_VAR 0 5
6349: PPUSH
6350: LD_VAR 0 4
6354: PPUSH
6355: CALL 80429 0 4
// end ; end_of_file
6359: PPOPN 7
6361: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6362: LD_INT 0
6364: PPUSH
6365: PPUSH
6366: PPUSH
6367: PPUSH
// uc_side := 1 ;
6368: LD_ADDR_OWVAR 20
6372: PUSH
6373: LD_INT 1
6375: ST_TO_ADDR
// uc_nation := 1 ;
6376: LD_ADDR_OWVAR 21
6380: PUSH
6381: LD_INT 1
6383: ST_TO_ADDR
// InitHc ;
6384: CALL_OW 19
// InitVc ;
6388: CALL_OW 20
// tmp := [ ] ;
6392: LD_ADDR_VAR 0 3
6396: PUSH
6397: EMPTY
6398: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6399: LD_ADDR_VAR 0 2
6403: PUSH
6404: DOUBLE
6405: LD_INT 1
6407: DEC
6408: ST_TO_ADDR
6409: LD_INT 5
6411: PUSH
6412: LD_INT 6
6414: PUSH
6415: LD_INT 6
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: LIST
6422: PUSH
6423: LD_OWVAR 67
6427: ARRAY
6428: PUSH
6429: FOR_TO
6430: IFFALSE 6567
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6432: LD_INT 2
6434: PUSH
6435: LD_INT 4
6437: PUSH
6438: LD_INT 5
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 1
6448: PPUSH
6449: LD_INT 3
6451: PPUSH
6452: CALL_OW 12
6456: ARRAY
6457: PPUSH
6458: LD_INT 1
6460: PUSH
6461: LD_INT 3
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: PUSH
6468: LD_INT 1
6470: PPUSH
6471: LD_INT 2
6473: PPUSH
6474: CALL_OW 12
6478: ARRAY
6479: PPUSH
6480: LD_INT 3
6482: PPUSH
6483: LD_INT 9
6485: PUSH
6486: LD_INT 7
6488: PUSH
6489: EMPTY
6490: LIST
6491: LIST
6492: PUSH
6493: LD_INT 1
6495: PPUSH
6496: LD_INT 2
6498: PPUSH
6499: CALL_OW 12
6503: ARRAY
6504: PPUSH
6505: LD_INT 78
6507: PPUSH
6508: CALL 20699 0 5
// veh := CreateVehicle ;
6512: LD_ADDR_VAR 0 4
6516: PUSH
6517: CALL_OW 45
6521: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6522: LD_VAR 0 4
6526: PPUSH
6527: LD_INT 2
6529: PPUSH
6530: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6534: LD_VAR 0 4
6538: PPUSH
6539: LD_INT 17
6541: PPUSH
6542: LD_INT 0
6544: PPUSH
6545: CALL_OW 49
// tmp := tmp ^ veh ;
6549: LD_ADDR_VAR 0 3
6553: PUSH
6554: LD_VAR 0 3
6558: PUSH
6559: LD_VAR 0 4
6563: ADD
6564: ST_TO_ADDR
// end ;
6565: GO 6429
6567: POP
6568: POP
// if not tmp then
6569: LD_VAR 0 3
6573: NOT
6574: IFFALSE 6578
// exit ;
6576: GO 6687
// if not first_powell_attack then
6578: LD_EXP 11
6582: NOT
6583: IFFALSE 6593
// first_powell_attack := true ;
6585: LD_ADDR_EXP 11
6589: PUSH
6590: LD_INT 1
6592: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6593: LD_INT 70
6595: PPUSH
6596: CALL_OW 67
// for i in tmp do
6600: LD_ADDR_VAR 0 2
6604: PUSH
6605: LD_VAR 0 3
6609: PUSH
6610: FOR_IN
6611: IFFALSE 6678
// if IsOk ( i ) then
6613: LD_VAR 0 2
6617: PPUSH
6618: CALL_OW 302
6622: IFFALSE 6660
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6624: LD_VAR 0 2
6628: PPUSH
6629: LD_INT 81
6631: PUSH
6632: LD_INT 1
6634: PUSH
6635: EMPTY
6636: LIST
6637: LIST
6638: PPUSH
6639: CALL_OW 69
6643: PPUSH
6644: LD_VAR 0 2
6648: PPUSH
6649: CALL_OW 74
6653: PPUSH
6654: CALL_OW 115
6658: GO 6676
// tmp := tmp diff i ;
6660: LD_ADDR_VAR 0 3
6664: PUSH
6665: LD_VAR 0 3
6669: PUSH
6670: LD_VAR 0 2
6674: DIFF
6675: ST_TO_ADDR
6676: GO 6610
6678: POP
6679: POP
// until not tmp ;
6680: LD_VAR 0 3
6684: NOT
6685: IFFALSE 6593
// end ; end_of_file
6687: LD_VAR 0 1
6691: RET
// export function Action ; var tmp , i , un ; begin
6692: LD_INT 0
6694: PPUSH
6695: PPUSH
6696: PPUSH
6697: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6698: LD_INT 68
6700: PPUSH
6701: LD_INT 39
6703: PPUSH
6704: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6708: LD_ADDR_VAR 0 2
6712: PUSH
6713: LD_INT 22
6715: PUSH
6716: LD_INT 7
6718: PUSH
6719: EMPTY
6720: LIST
6721: LIST
6722: PPUSH
6723: CALL_OW 69
6727: ST_TO_ADDR
// InGameOn ;
6728: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6732: LD_VAR 0 2
6736: PPUSH
6737: LD_INT 71
6739: PPUSH
6740: LD_INT 49
6742: PPUSH
6743: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6747: LD_INT 35
6749: PPUSH
6750: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6754: LD_INT 7
6756: PPUSH
6757: LD_INT 71
6759: PPUSH
6760: LD_INT 51
6762: PPUSH
6763: CALL_OW 293
6767: IFFALSE 6747
// DialogueOn ;
6769: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6773: LD_EXP 14
6777: PPUSH
6778: LD_STRING D1-JMM-1
6780: PPUSH
6781: CALL_OW 88
// if Joan then
6785: LD_EXP 29
6789: IFFALSE 6803
// Say ( Joan , D1-Joan-1 ) ;
6791: LD_EXP 29
6795: PPUSH
6796: LD_STRING D1-Joan-1
6798: PPUSH
6799: CALL_OW 88
// if Lisa then
6803: LD_EXP 16
6807: IFFALSE 6821
// Say ( Lisa , D1-Lisa-1 ) ;
6809: LD_EXP 16
6813: PPUSH
6814: LD_STRING D1-Lisa-1
6816: PPUSH
6817: CALL_OW 88
// if Joan or Lisa then
6821: LD_EXP 29
6825: PUSH
6826: LD_EXP 16
6830: OR
6831: IFFALSE 6845
// Say ( JMM , D1-JMM-2 ) ;
6833: LD_EXP 14
6837: PPUSH
6838: LD_STRING D1-JMM-2
6840: PPUSH
6841: CALL_OW 88
// DialogueOff ;
6845: CALL_OW 7
// InGameOff ;
6849: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6853: LD_INT 71
6855: PPUSH
6856: LD_INT 50
6858: PPUSH
6859: LD_INT 7
6861: PPUSH
6862: LD_INT 30
6864: NEG
6865: PPUSH
6866: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6870: LD_INT 71
6872: PPUSH
6873: LD_INT 50
6875: PPUSH
6876: LD_INT 7
6878: PPUSH
6879: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6883: LD_STRING M1
6885: PPUSH
6886: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6890: LD_INT 35
6892: PPUSH
6893: CALL_OW 67
// until freedom ;
6897: LD_EXP 3
6901: IFFALSE 6890
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6903: LD_INT 350
6905: PPUSH
6906: LD_INT 700
6908: PPUSH
6909: CALL_OW 12
6913: PPUSH
6914: CALL_OW 67
// PrepareGossudarov ;
6918: CALL 1710 0 0
// repeat wait ( 0 0$1 ) ;
6922: LD_INT 35
6924: PPUSH
6925: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
6929: LD_INT 22
6931: PUSH
6932: LD_INT 6
6934: PUSH
6935: EMPTY
6936: LIST
6937: LIST
6938: PUSH
6939: LD_INT 3
6941: PUSH
6942: LD_INT 24
6944: PUSH
6945: LD_INT 1000
6947: PUSH
6948: EMPTY
6949: LIST
6950: LIST
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PUSH
6956: EMPTY
6957: LIST
6958: LIST
6959: PPUSH
6960: CALL_OW 69
6964: PUSH
6965: LD_INT 7
6967: PPUSH
6968: LD_EXP 31
6972: PPUSH
6973: CALL_OW 292
6977: OR
6978: IFFALSE 6922
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
6980: LD_ADDR_VAR 0 2
6984: PUSH
6985: LD_INT 22
6987: PUSH
6988: LD_INT 6
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PPUSH
6995: CALL_OW 69
6999: ST_TO_ADDR
// for i in tmp do
7000: LD_ADDR_VAR 0 3
7004: PUSH
7005: LD_VAR 0 2
7009: PUSH
7010: FOR_IN
7011: IFFALSE 7027
// SetSide ( i , 7 ) ;
7013: LD_VAR 0 3
7017: PPUSH
7018: LD_INT 7
7020: PPUSH
7021: CALL_OW 235
7025: GO 7010
7027: POP
7028: POP
// DialogueOn ;
7029: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7033: LD_EXP 14
7037: PUSH
7038: LD_EXP 15
7042: PUSH
7043: EMPTY
7044: LIST
7045: LIST
7046: PPUSH
7047: LD_EXP 31
7051: PPUSH
7052: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7056: LD_EXP 31
7060: PPUSH
7061: CALL_OW 87
// if not Roth then
7065: LD_EXP 15
7069: NOT
7070: IFFALSE 7162
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7072: LD_VAR 0 2
7076: PPUSH
7077: LD_INT 3
7079: PUSH
7080: LD_INT 24
7082: PUSH
7083: LD_INT 1000
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PUSH
7090: EMPTY
7091: LIST
7092: LIST
7093: PPUSH
7094: CALL_OW 72
7098: IFFALSE 7112
// Say ( JMM , D2-JMM-1 ) ;
7100: LD_EXP 14
7104: PPUSH
7105: LD_STRING D2-JMM-1
7107: PPUSH
7108: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7112: LD_EXP 14
7116: PPUSH
7117: LD_STRING D2-JMM-1b
7119: PPUSH
7120: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7124: LD_EXP 31
7128: PPUSH
7129: LD_STRING D2-Gos-1
7131: PPUSH
7132: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7136: LD_EXP 14
7140: PPUSH
7141: LD_STRING D2-JMM-2
7143: PPUSH
7144: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7148: LD_EXP 31
7152: PPUSH
7153: LD_STRING D2-Gos-2
7155: PPUSH
7156: CALL_OW 88
// end else
7160: GO 7314
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7162: LD_VAR 0 2
7166: PPUSH
7167: LD_INT 3
7169: PUSH
7170: LD_INT 24
7172: PUSH
7173: LD_INT 1000
7175: PUSH
7176: EMPTY
7177: LIST
7178: LIST
7179: PUSH
7180: EMPTY
7181: LIST
7182: LIST
7183: PPUSH
7184: CALL_OW 72
7188: IFFALSE 7214
// begin Say ( Roth , D2-Roth-2 ) ;
7190: LD_EXP 15
7194: PPUSH
7195: LD_STRING D2-Roth-2
7197: PPUSH
7198: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7202: LD_EXP 14
7206: PPUSH
7207: LD_STRING D2-JMM-1a
7209: PPUSH
7210: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7214: LD_EXP 15
7218: PPUSH
7219: LD_STRING D2-Roth-2a
7221: PPUSH
7222: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7226: LD_EXP 15
7230: PPUSH
7231: LD_STRING D2-Roth-2b
7233: PPUSH
7234: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7238: LD_EXP 14
7242: PPUSH
7243: LD_STRING D2-JMM-3
7245: PPUSH
7246: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7250: LD_VAR 0 2
7254: PPUSH
7255: LD_INT 3
7257: PUSH
7258: LD_INT 24
7260: PUSH
7261: LD_INT 1000
7263: PUSH
7264: EMPTY
7265: LIST
7266: LIST
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: PPUSH
7272: CALL_OW 72
7276: IFFALSE 7314
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7278: LD_EXP 31
7282: PPUSH
7283: LD_STRING D2-Gos-3
7285: PPUSH
7286: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7290: LD_EXP 14
7294: PPUSH
7295: LD_STRING D2-JMM-4
7297: PPUSH
7298: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7302: LD_EXP 31
7306: PPUSH
7307: LD_STRING D2-Gos-4
7309: PPUSH
7310: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7314: LD_EXP 14
7318: PPUSH
7319: LD_STRING D2-JMM-5
7321: PPUSH
7322: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7326: LD_EXP 31
7330: PPUSH
7331: LD_STRING D2-Gos-5
7333: PPUSH
7334: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7338: LD_EXP 14
7342: PPUSH
7343: LD_STRING D2-JMM-6
7345: PPUSH
7346: CALL_OW 88
// DialogueOff ;
7350: CALL_OW 7
// wait ( 0 0$2 ) ;
7354: LD_INT 70
7356: PPUSH
7357: CALL_OW 67
// if Kirilenkova then
7361: LD_EXP 32
7365: IFFALSE 7379
// Say ( Kirilenkova , D3-Kir-1 ) ;
7367: LD_EXP 32
7371: PPUSH
7372: LD_STRING D3-Kir-1
7374: PPUSH
7375: CALL_OW 88
// gossudarov_arrive := true ;
7379: LD_ADDR_EXP 4
7383: PUSH
7384: LD_INT 1
7386: ST_TO_ADDR
// Hint ( CombinedForces ) ;
7387: LD_STRING CombinedForces
7389: PPUSH
7390: CALL_OW 339
// repeat wait ( 0 0$1 ) ;
7394: LD_INT 35
7396: PPUSH
7397: CALL_OW 67
// until ru_lab_builded ;
7401: LD_EXP 5
7405: IFFALSE 7394
// if Kirilenkova then
7407: LD_EXP 32
7411: IFFALSE 7427
// Say ( Kirilenkova , D3a-Kir-1 ) else
7413: LD_EXP 32
7417: PPUSH
7418: LD_STRING D3a-Kir-1
7420: PPUSH
7421: CALL_OW 88
7425: GO 7449
// begin un := SciRu ;
7427: LD_ADDR_VAR 0 4
7431: PUSH
7432: CALL 12419 0 0
7436: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7437: LD_VAR 0 4
7441: PPUSH
7442: LD_STRING D3a-Sci1-1
7444: PPUSH
7445: CALL_OW 88
// end ; if Kirilenkova or un then
7449: LD_EXP 32
7453: PUSH
7454: LD_VAR 0 4
7458: OR
7459: IFFALSE 7473
// Say ( JMM , D3a-JMM-1 ) ;
7461: LD_EXP 14
7465: PPUSH
7466: LD_STRING D3a-JMM-1
7468: PPUSH
7469: CALL_OW 88
// end ;
7473: LD_VAR 0 1
7477: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7478: LD_EXP 4
7482: PUSH
7483: LD_INT 22
7485: PUSH
7486: LD_INT 7
7488: PUSH
7489: EMPTY
7490: LIST
7491: LIST
7492: PUSH
7493: LD_INT 2
7495: PUSH
7496: LD_INT 25
7498: PUSH
7499: LD_INT 1
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: PUSH
7506: LD_INT 25
7508: PUSH
7509: LD_INT 2
7511: PUSH
7512: EMPTY
7513: LIST
7514: LIST
7515: PUSH
7516: LD_INT 25
7518: PUSH
7519: LD_INT 3
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: LD_INT 25
7528: PUSH
7529: LD_INT 4
7531: PUSH
7532: EMPTY
7533: LIST
7534: LIST
7535: PUSH
7536: LD_INT 25
7538: PUSH
7539: LD_INT 5
7541: PUSH
7542: EMPTY
7543: LIST
7544: LIST
7545: PUSH
7546: LD_INT 25
7548: PUSH
7549: LD_INT 8
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: PUSH
7556: LD_INT 25
7558: PUSH
7559: LD_INT 9
7561: PUSH
7562: EMPTY
7563: LIST
7564: LIST
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: LIST
7570: LIST
7571: LIST
7572: LIST
7573: LIST
7574: LIST
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: PPUSH
7580: CALL_OW 69
7584: PUSH
7585: LD_INT 7
7587: LESS
7588: AND
7589: IFFALSE 7601
7591: GO 7593
7593: DISABLE
// YouLost ( TooMany ) ;
7594: LD_STRING TooMany
7596: PPUSH
7597: CALL_OW 104
7601: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7602: LD_EXP 31
7606: PPUSH
7607: CALL_OW 255
7611: PUSH
7612: LD_INT 7
7614: EQUAL
7615: IFFALSE 7815
7617: GO 7619
7619: DISABLE
7620: LD_INT 0
7622: PPUSH
7623: PPUSH
7624: PPUSH
// begin uc_side := 3 ;
7625: LD_ADDR_OWVAR 20
7629: PUSH
7630: LD_INT 3
7632: ST_TO_ADDR
// uc_nation := 3 ;
7633: LD_ADDR_OWVAR 21
7637: PUSH
7638: LD_INT 3
7640: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7641: LD_INT 21
7643: PPUSH
7644: LD_INT 3
7646: PPUSH
7647: LD_INT 3
7649: PPUSH
7650: LD_INT 42
7652: PPUSH
7653: LD_INT 100
7655: PPUSH
7656: CALL 20699 0 5
// un := CreateVehicle ;
7660: LD_ADDR_VAR 0 3
7664: PUSH
7665: CALL_OW 45
7669: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7670: LD_VAR 0 3
7674: PPUSH
7675: LD_INT 15
7677: PPUSH
7678: LD_INT 0
7680: PPUSH
7681: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7685: LD_VAR 0 3
7689: PPUSH
7690: LD_INT 67
7692: PPUSH
7693: LD_INT 45
7695: PPUSH
7696: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7700: LD_VAR 0 3
7704: PPUSH
7705: LD_INT 70
7707: PPUSH
7708: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7712: LD_VAR 0 3
7716: PPUSH
7717: LD_INT 69
7719: PPUSH
7720: LD_INT 18
7722: PPUSH
7723: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7727: LD_VAR 0 3
7731: PPUSH
7732: LD_INT 60
7734: PPUSH
7735: LD_INT 2
7737: PPUSH
7738: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7742: LD_INT 35
7744: PPUSH
7745: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7749: LD_VAR 0 3
7753: PPUSH
7754: CALL_OW 302
7758: NOT
7759: PUSH
7760: LD_VAR 0 3
7764: PPUSH
7765: LD_INT 17
7767: PPUSH
7768: CALL_OW 308
7772: OR
7773: IFFALSE 7742
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7775: LD_VAR 0 3
7779: PPUSH
7780: LD_INT 17
7782: PPUSH
7783: CALL_OW 308
7787: PUSH
7788: LD_VAR 0 3
7792: PPUSH
7793: LD_INT 60
7795: PPUSH
7796: LD_INT 2
7798: PPUSH
7799: CALL_OW 307
7803: OR
7804: IFFALSE 7815
// RemoveUnit ( un ) ;
7806: LD_VAR 0 3
7810: PPUSH
7811: CALL_OW 64
// end ;
7815: PPOPN 3
7817: END
// every 0 0$2 do var i , un , tmp ;
7818: GO 7820
7820: DISABLE
7821: LD_INT 0
7823: PPUSH
7824: PPUSH
7825: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7826: LD_INT 70
7828: PPUSH
7829: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7833: LD_ADDR_VAR 0 3
7837: PUSH
7838: LD_INT 22
7840: PUSH
7841: LD_INT 7
7843: PUSH
7844: EMPTY
7845: LIST
7846: LIST
7847: PUSH
7848: LD_INT 101
7850: PUSH
7851: LD_INT 3
7853: PUSH
7854: EMPTY
7855: LIST
7856: LIST
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: PPUSH
7862: CALL_OW 69
7866: ST_TO_ADDR
// until tmp ;
7867: LD_VAR 0 3
7871: IFFALSE 7826
// un := NearestUnitToUnit ( tmp , JMM ) ;
7873: LD_ADDR_VAR 0 2
7877: PUSH
7878: LD_VAR 0 3
7882: PPUSH
7883: LD_EXP 14
7887: PPUSH
7888: CALL_OW 74
7892: ST_TO_ADDR
// player_spotted := true ;
7893: LD_ADDR_EXP 6
7897: PUSH
7898: LD_INT 1
7900: ST_TO_ADDR
// tmp := SciRu ;
7901: LD_ADDR_VAR 0 3
7905: PUSH
7906: CALL 12419 0 0
7910: ST_TO_ADDR
// if not tmp then
7911: LD_VAR 0 3
7915: NOT
7916: IFFALSE 7928
// tmp := SolRu ;
7918: LD_ADDR_VAR 0 3
7922: PUSH
7923: CALL 12566 0 0
7927: ST_TO_ADDR
// DialogueOn ;
7928: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7932: LD_VAR 0 2
7936: PPUSH
7937: CALL_OW 250
7941: PPUSH
7942: LD_VAR 0 2
7946: PPUSH
7947: CALL_OW 251
7951: PPUSH
7952: LD_INT 7
7954: PPUSH
7955: LD_INT 8
7957: NEG
7958: PPUSH
7959: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7963: LD_VAR 0 2
7967: PPUSH
7968: CALL_OW 87
// if tmp then
7972: LD_VAR 0 3
7976: IFFALSE 7990
// Say ( tmp , D4-RSci1-1 ) ;
7978: LD_VAR 0 3
7982: PPUSH
7983: LD_STRING D4-RSci1-1
7985: PPUSH
7986: CALL_OW 88
// if Gossudarov then
7990: LD_EXP 31
7994: IFFALSE 8020
// begin Say ( Gossudarov , D4-Gos-1 ) ;
7996: LD_EXP 31
8000: PPUSH
8001: LD_STRING D4-Gos-1
8003: PPUSH
8004: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8008: LD_EXP 14
8012: PPUSH
8013: LD_STRING D4-JMM-1
8015: PPUSH
8016: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8020: LD_VAR 0 2
8024: PPUSH
8025: CALL_OW 250
8029: PPUSH
8030: LD_VAR 0 2
8034: PPUSH
8035: CALL_OW 251
8039: PPUSH
8040: LD_INT 7
8042: PPUSH
8043: CALL_OW 331
// DialogueOff ;
8047: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8051: LD_STRING M5
8053: PPUSH
8054: CALL_OW 337
// end ;
8058: PPOPN 3
8060: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8061: LD_EXP 6
8065: IFFALSE 8654
8067: GO 8069
8069: DISABLE
8070: LD_INT 0
8072: PPUSH
8073: PPUSH
8074: PPUSH
// begin PrepareBelkov ;
8075: CALL 2000 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8079: LD_EXP 46
8083: PPUSH
8084: LD_INT 118
8086: PPUSH
8087: LD_INT 106
8089: PPUSH
8090: CALL_OW 111
// AddComHold ( Belkov ) ;
8094: LD_EXP 46
8098: PPUSH
8099: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8103: LD_INT 35
8105: PPUSH
8106: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8110: LD_EXP 46
8114: PPUSH
8115: LD_INT 118
8117: PPUSH
8118: LD_INT 106
8120: PPUSH
8121: CALL_OW 307
8125: IFFALSE 8103
// ChangeSideFog ( 4 , 7 ) ;
8127: LD_INT 4
8129: PPUSH
8130: LD_INT 7
8132: PPUSH
8133: CALL_OW 343
// if IsOk ( Belkov ) then
8137: LD_EXP 46
8141: PPUSH
8142: CALL_OW 302
8146: IFFALSE 8230
// begin InGameOn ;
8148: CALL_OW 8
// DialogueOn ;
8152: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8156: LD_EXP 46
8160: PPUSH
8161: LD_STRING D5-Bel-1
8163: PPUSH
8164: CALL_OW 94
// if Gossudarov then
8168: LD_EXP 31
8172: IFFALSE 8222
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8174: LD_EXP 31
8178: PPUSH
8179: LD_STRING D5-Gos-1
8181: PPUSH
8182: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8186: LD_EXP 14
8190: PPUSH
8191: LD_STRING D5-JMM-1
8193: PPUSH
8194: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8198: LD_EXP 31
8202: PPUSH
8203: LD_STRING D5-Gos-2
8205: PPUSH
8206: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8210: LD_EXP 14
8214: PPUSH
8215: LD_STRING D5-JMM-2
8217: PPUSH
8218: CALL_OW 88
// end ; DialogueOff ;
8222: CALL_OW 7
// InGameOff ;
8226: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8230: LD_STRING QSaveBelkov
8232: PPUSH
8233: CALL_OW 97
8237: PUSH
8238: LD_INT 1
8240: DOUBLE
8241: EQUAL
8242: IFTRUE 8246
8244: GO 8296
8246: POP
// begin DialogueOn ;
8247: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8251: LD_EXP 14
8255: PPUSH
8256: LD_STRING D5a-JMM-1
8258: PPUSH
8259: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8263: LD_EXP 46
8267: PPUSH
8268: LD_STRING D5a-Bel-1
8270: PPUSH
8271: CALL_OW 94
// DialogueOff ;
8275: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8279: LD_EXP 46
8283: PPUSH
8284: LD_INT 83
8286: PPUSH
8287: LD_INT 49
8289: PPUSH
8290: CALL_OW 111
// end ; 2 :
8294: GO 8329
8296: LD_INT 2
8298: DOUBLE
8299: EQUAL
8300: IFTRUE 8304
8302: GO 8328
8304: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8305: LD_EXP 14
8309: PPUSH
8310: LD_STRING D5a-JMM-2
8312: PPUSH
8313: CALL_OW 88
// ComHold ( Belkov ) ;
8317: LD_EXP 46
8321: PPUSH
8322: CALL_OW 140
// end ; end ;
8326: GO 8329
8328: POP
// time := 0 0$00 ;
8329: LD_ADDR_VAR 0 1
8333: PUSH
8334: LD_INT 0
8336: ST_TO_ADDR
// vehSpawned := false ;
8337: LD_ADDR_VAR 0 3
8341: PUSH
8342: LD_INT 0
8344: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8345: LD_INT 35
8347: PPUSH
8348: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8352: LD_VAR 0 1
8356: PUSH
8357: LD_INT 350
8359: PUSH
8360: LD_INT 175
8362: PUSH
8363: LD_INT 70
8365: PUSH
8366: EMPTY
8367: LIST
8368: LIST
8369: LIST
8370: PUSH
8371: LD_OWVAR 67
8375: ARRAY
8376: GREATEREQUAL
8377: PUSH
8378: LD_VAR 0 3
8382: NOT
8383: AND
8384: IFFALSE 8474
// begin vehSpawned := true ;
8386: LD_ADDR_VAR 0 3
8390: PUSH
8391: LD_INT 1
8393: ST_TO_ADDR
// uc_side := 3 ;
8394: LD_ADDR_OWVAR 20
8398: PUSH
8399: LD_INT 3
8401: ST_TO_ADDR
// uc_nation := 3 ;
8402: LD_ADDR_OWVAR 21
8406: PUSH
8407: LD_INT 3
8409: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8410: LD_INT 22
8412: PPUSH
8413: LD_INT 3
8415: PPUSH
8416: LD_INT 3
8418: PPUSH
8419: LD_INT 43
8421: PPUSH
8422: LD_INT 100
8424: PPUSH
8425: CALL 20699 0 5
// veh := CreateVehicle ;
8429: LD_ADDR_VAR 0 2
8433: PUSH
8434: CALL_OW 45
8438: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8439: LD_VAR 0 2
8443: PPUSH
8444: LD_INT 130
8446: PPUSH
8447: LD_INT 131
8449: PPUSH
8450: LD_INT 0
8452: PPUSH
8453: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8457: LD_VAR 0 2
8461: PPUSH
8462: LD_INT 100
8464: PPUSH
8465: LD_INT 82
8467: PPUSH
8468: CALL_OW 114
// end else
8472: GO 8488
// time := time + 0 0$1 ;
8474: LD_ADDR_VAR 0 1
8478: PUSH
8479: LD_VAR 0 1
8483: PUSH
8484: LD_INT 35
8486: PLUS
8487: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8488: LD_EXP 46
8492: PPUSH
8493: CALL_OW 301
8497: PUSH
8498: LD_EXP 46
8502: PPUSH
8503: CALL_OW 255
8507: PUSH
8508: LD_INT 4
8510: EQUAL
8511: AND
8512: PUSH
8513: LD_INT 22
8515: PUSH
8516: LD_INT 7
8518: PUSH
8519: EMPTY
8520: LIST
8521: LIST
8522: PPUSH
8523: CALL_OW 69
8527: PPUSH
8528: LD_EXP 46
8532: PPUSH
8533: CALL_OW 74
8537: PPUSH
8538: LD_EXP 46
8542: PPUSH
8543: CALL_OW 296
8547: PUSH
8548: LD_INT 10
8550: LESS
8551: OR
8552: IFFALSE 8345
// if IsDead ( Belkov ) then
8554: LD_EXP 46
8558: PPUSH
8559: CALL_OW 301
8563: IFFALSE 8588
// begin CenterNowOnUnits ( Belkov ) ;
8565: LD_EXP 46
8569: PPUSH
8570: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8574: LD_EXP 14
8578: PPUSH
8579: LD_STRING D5a-JMM-2a
8581: PPUSH
8582: CALL_OW 88
// exit ;
8586: GO 8654
// end ; if See ( 7 , Belkov ) then
8588: LD_INT 7
8590: PPUSH
8591: LD_EXP 46
8595: PPUSH
8596: CALL_OW 292
8600: IFFALSE 8614
// SetSide ( Belkov , 7 ) ;
8602: LD_EXP 46
8606: PPUSH
8607: LD_INT 7
8609: PPUSH
8610: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8614: LD_INT 35
8616: PPUSH
8617: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8621: LD_EXP 46
8625: PPUSH
8626: LD_INT 66
8628: PPUSH
8629: LD_INT 45
8631: PPUSH
8632: CALL_OW 297
8636: PUSH
8637: LD_INT 30
8639: LESS
8640: IFFALSE 8614
// Say ( Belkov , D6-Bel-1 ) ;
8642: LD_EXP 46
8646: PPUSH
8647: LD_STRING D6-Bel-1
8649: PPUSH
8650: CALL_OW 88
// end ;
8654: PPOPN 3
8656: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8657: LD_EXP 46
8661: PPUSH
8662: CALL_OW 302
8666: PUSH
8667: LD_EXP 46
8671: PPUSH
8672: CALL_OW 504
8676: PUSH
8677: LD_INT 2
8679: PUSH
8680: LD_INT 34
8682: PUSH
8683: LD_INT 47
8685: PUSH
8686: EMPTY
8687: LIST
8688: LIST
8689: PUSH
8690: LD_INT 34
8692: PUSH
8693: LD_INT 45
8695: PUSH
8696: EMPTY
8697: LIST
8698: LIST
8699: PUSH
8700: EMPTY
8701: LIST
8702: LIST
8703: LIST
8704: PPUSH
8705: CALL_OW 69
8709: IN
8710: AND
8711: IFFALSE 8728
8713: GO 8715
8715: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8716: LD_EXP 46
8720: PPUSH
8721: LD_STRING D7-Bel-1
8723: PPUSH
8724: CALL_OW 88
8728: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8729: LD_INT 22
8731: PUSH
8732: LD_INT 7
8734: PUSH
8735: EMPTY
8736: LIST
8737: LIST
8738: PUSH
8739: LD_INT 101
8741: PUSH
8742: LD_INT 2
8744: PUSH
8745: EMPTY
8746: LIST
8747: LIST
8748: PUSH
8749: EMPTY
8750: LIST
8751: LIST
8752: PPUSH
8753: CALL_OW 69
8757: PUSH
8758: LD_EXP 8
8762: NOT
8763: AND
8764: PUSH
8765: LD_EXP 45
8769: PPUSH
8770: CALL_OW 305
8774: NOT
8775: AND
8776: IFFALSE 9246
8778: GO 8780
8780: DISABLE
8781: LD_INT 0
8783: PPUSH
// begin ar_base_spotted := true ;
8784: LD_ADDR_EXP 8
8788: PUSH
8789: LD_INT 1
8791: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8792: LD_ADDR_VAR 0 1
8796: PUSH
8797: LD_INT 22
8799: PUSH
8800: LD_INT 2
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: LD_INT 21
8809: PUSH
8810: LD_INT 3
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PPUSH
8821: CALL_OW 69
8825: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8826: LD_ADDR_VAR 0 1
8830: PUSH
8831: LD_VAR 0 1
8835: PPUSH
8836: LD_EXP 14
8840: PPUSH
8841: CALL_OW 74
8845: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8846: LD_INT 7
8848: PPUSH
8849: LD_INT 3
8851: PPUSH
8852: CALL_OW 332
// DialogueOn ;
8856: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8860: LD_VAR 0 1
8864: PPUSH
8865: CALL_OW 250
8869: PPUSH
8870: LD_VAR 0 1
8874: PPUSH
8875: CALL_OW 251
8879: PPUSH
8880: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8884: LD_ADDR_VAR 0 1
8888: PUSH
8889: LD_INT 22
8891: PUSH
8892: LD_INT 7
8894: PUSH
8895: EMPTY
8896: LIST
8897: LIST
8898: PUSH
8899: LD_INT 23
8901: PUSH
8902: LD_INT 1
8904: PUSH
8905: EMPTY
8906: LIST
8907: LIST
8908: PUSH
8909: LD_INT 26
8911: PUSH
8912: LD_INT 1
8914: PUSH
8915: EMPTY
8916: LIST
8917: LIST
8918: PUSH
8919: EMPTY
8920: LIST
8921: LIST
8922: LIST
8923: PPUSH
8924: CALL_OW 69
8928: PUSH
8929: LD_EXP 14
8933: PUSH
8934: LD_EXP 18
8938: PUSH
8939: LD_EXP 19
8943: PUSH
8944: LD_EXP 26
8948: PUSH
8949: LD_EXP 15
8953: PUSH
8954: LD_EXP 24
8958: PUSH
8959: LD_EXP 20
8963: PUSH
8964: LD_EXP 22
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: LIST
8973: LIST
8974: LIST
8975: LIST
8976: LIST
8977: LIST
8978: DIFF
8979: ST_TO_ADDR
// if not tmp then
8980: LD_VAR 0 1
8984: NOT
8985: IFFALSE 9059
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
8987: LD_ADDR_VAR 0 1
8991: PUSH
8992: LD_INT 22
8994: PUSH
8995: LD_INT 7
8997: PUSH
8998: EMPTY
8999: LIST
9000: LIST
9001: PUSH
9002: LD_INT 23
9004: PUSH
9005: LD_INT 1
9007: PUSH
9008: EMPTY
9009: LIST
9010: LIST
9011: PUSH
9012: LD_INT 26
9014: PUSH
9015: LD_INT 2
9017: PUSH
9018: EMPTY
9019: LIST
9020: LIST
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: LIST
9026: PPUSH
9027: CALL_OW 69
9031: PUSH
9032: LD_EXP 29
9036: PUSH
9037: LD_EXP 16
9041: PUSH
9042: LD_EXP 27
9046: PUSH
9047: LD_EXP 28
9051: PUSH
9052: EMPTY
9053: LIST
9054: LIST
9055: LIST
9056: LIST
9057: DIFF
9058: ST_TO_ADDR
// if tmp then
9059: LD_VAR 0 1
9063: IFFALSE 9134
// case GetSex ( tmp [ 1 ] ) of sex_male :
9065: LD_VAR 0 1
9069: PUSH
9070: LD_INT 1
9072: ARRAY
9073: PPUSH
9074: CALL_OW 258
9078: PUSH
9079: LD_INT 1
9081: DOUBLE
9082: EQUAL
9083: IFTRUE 9087
9085: GO 9106
9087: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9088: LD_VAR 0 1
9092: PUSH
9093: LD_INT 1
9095: ARRAY
9096: PPUSH
9097: LD_STRING D9-Sol1-1
9099: PPUSH
9100: CALL_OW 88
9104: GO 9134
9106: LD_INT 2
9108: DOUBLE
9109: EQUAL
9110: IFTRUE 9114
9112: GO 9133
9114: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9115: LD_VAR 0 1
9119: PUSH
9120: LD_INT 1
9122: ARRAY
9123: PPUSH
9124: LD_STRING D9-FSol1-1
9126: PPUSH
9127: CALL_OW 88
9131: GO 9134
9133: POP
// if Frank then
9134: LD_EXP 26
9138: IFFALSE 9242
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9140: LD_EXP 55
9144: PPUSH
9145: CALL_OW 250
9149: PPUSH
9150: LD_EXP 55
9154: PPUSH
9155: CALL_OW 251
9159: PPUSH
9160: LD_INT 7
9162: PPUSH
9163: LD_INT 8
9165: PPUSH
9166: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9170: LD_EXP 55
9174: PPUSH
9175: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9179: LD_EXP 26
9183: PPUSH
9184: LD_STRING D9-Frank-1
9186: PPUSH
9187: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9191: LD_EXP 14
9195: PPUSH
9196: LD_STRING D9-JMM-1
9198: PPUSH
9199: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9203: LD_EXP 26
9207: PPUSH
9208: LD_STRING D9-Frank-2
9210: PPUSH
9211: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9215: LD_EXP 55
9219: PPUSH
9220: CALL_OW 250
9224: PPUSH
9225: LD_EXP 55
9229: PPUSH
9230: CALL_OW 251
9234: PPUSH
9235: LD_INT 7
9237: PPUSH
9238: CALL_OW 331
// end ; DialogueOff ;
9242: CALL_OW 7
// end ;
9246: PPOPN 1
9248: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9249: LD_EXP 7
9253: PUSH
9254: LD_OWVAR 1
9258: PUSH
9259: LD_INT 42000
9261: GREATEREQUAL
9262: OR
9263: IFFALSE 10290
9265: GO 9267
9267: DISABLE
9268: LD_INT 0
9270: PPUSH
9271: PPUSH
// begin selected_option := 1 ;
9272: LD_ADDR_VAR 0 2
9276: PUSH
9277: LD_INT 1
9279: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9280: LD_INT 10500
9282: PPUSH
9283: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9287: LD_INT 35
9289: PPUSH
9290: CALL_OW 67
// until not ru_attackers ;
9294: LD_EXP 51
9298: NOT
9299: IFFALSE 9287
// PrepareBurlak ;
9301: CALL 2112 0 0
// repeat wait ( 0 0$2 ) ;
9305: LD_INT 70
9307: PPUSH
9308: CALL_OW 67
// until not HasTask ( Burlak ) ;
9312: LD_EXP 45
9316: PPUSH
9317: CALL_OW 314
9321: NOT
9322: IFFALSE 9305
// InGameOn ;
9324: CALL_OW 8
// DialogueOn ;
9328: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9332: LD_EXP 48
9336: PPUSH
9337: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9341: LD_EXP 45
9345: PPUSH
9346: LD_STRING D10-Bur-1
9348: PPUSH
9349: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9353: LD_EXP 46
9357: PUSH
9358: LD_EXP 46
9362: PPUSH
9363: CALL_OW 255
9367: PUSH
9368: LD_INT 7
9370: EQUAL
9371: AND
9372: IFFALSE 9386
// Say ( Belkov , D10-Bel-1 ) ;
9374: LD_EXP 46
9378: PPUSH
9379: LD_STRING D10-Bel-1
9381: PPUSH
9382: CALL_OW 88
// if Gossudarov then
9386: LD_EXP 31
9390: IFFALSE 9404
// Say ( Gossudarov , D10-Gos-1 ) ;
9392: LD_EXP 31
9396: PPUSH
9397: LD_STRING D10-Gos-1
9399: PPUSH
9400: CALL_OW 88
// if Kirilenkova then
9404: LD_EXP 32
9408: IFFALSE 9422
// Say ( Kirilenkova , D10-Kir-1 ) ;
9410: LD_EXP 32
9414: PPUSH
9415: LD_STRING D10-Kir-1
9417: PPUSH
9418: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9422: CALL 12566 0 0
9426: PPUSH
9427: LD_STRING D10-RSol1-1
9429: PPUSH
9430: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9434: LD_EXP 45
9438: PPUSH
9439: LD_STRING D10-Bur-2
9441: PPUSH
9442: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9446: LD_EXP 14
9450: PPUSH
9451: LD_STRING D10-JMM-2
9453: PPUSH
9454: CALL_OW 88
// if Kirilenkova then
9458: LD_EXP 32
9462: IFFALSE 9478
// Say ( Kirilenkova , D10-Kir-2 ) else
9464: LD_EXP 32
9468: PPUSH
9469: LD_STRING D10-Kir-2
9471: PPUSH
9472: CALL_OW 88
9476: GO 9490
// Say ( SolRu , D10-RSol1-2 ) ;
9478: CALL 12566 0 0
9482: PPUSH
9483: LD_STRING D10-RSol1-2
9485: PPUSH
9486: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9490: LD_EXP 14
9494: PPUSH
9495: LD_STRING D10-JMM-3
9497: PPUSH
9498: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9502: LD_EXP 45
9506: PPUSH
9507: LD_STRING D10-Bur-3
9509: PPUSH
9510: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9514: LD_EXP 14
9518: PPUSH
9519: LD_STRING D10-JMM-4
9521: PPUSH
9522: CALL_OW 88
// DialogueOff ;
9526: CALL_OW 7
// InGameOff ;
9530: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9534: LD_STRING M2
9536: PPUSH
9537: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9541: LD_INT 35
9543: PPUSH
9544: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9548: LD_INT 22
9550: PUSH
9551: LD_INT 7
9553: PUSH
9554: EMPTY
9555: LIST
9556: LIST
9557: PUSH
9558: LD_INT 91
9560: PUSH
9561: LD_EXP 45
9565: PUSH
9566: LD_INT 8
9568: PUSH
9569: EMPTY
9570: LIST
9571: LIST
9572: LIST
9573: PUSH
9574: EMPTY
9575: LIST
9576: LIST
9577: PPUSH
9578: CALL_OW 69
9582: IFFALSE 9541
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9584: LD_ADDR_VAR 0 1
9588: PUSH
9589: LD_INT 22
9591: PUSH
9592: LD_INT 4
9594: PUSH
9595: EMPTY
9596: LIST
9597: LIST
9598: PPUSH
9599: CALL_OW 69
9603: PUSH
9604: FOR_IN
9605: IFFALSE 9621
// SetSide ( i , 7 ) ;
9607: LD_VAR 0 1
9611: PPUSH
9612: LD_INT 7
9614: PPUSH
9615: CALL_OW 235
9619: GO 9604
9621: POP
9622: POP
// ChangeMissionObjectives ( M3 ) ;
9623: LD_STRING M3
9625: PPUSH
9626: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9630: LD_INT 35
9632: PPUSH
9633: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9637: LD_EXP 14
9641: PPUSH
9642: LD_EXP 45
9646: PPUSH
9647: CALL_OW 296
9651: PUSH
9652: LD_INT 8
9654: LESS
9655: IFFALSE 9630
// ComTurnUnit ( JMM , Burlak ) ;
9657: LD_EXP 14
9661: PPUSH
9662: LD_EXP 45
9666: PPUSH
9667: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9671: LD_EXP 45
9675: PPUSH
9676: LD_EXP 14
9680: PPUSH
9681: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9685: LD_INT 10
9687: PPUSH
9688: CALL_OW 67
// DialogueOn ;
9692: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9696: LD_EXP 14
9700: PPUSH
9701: LD_STRING D11-JMM-1
9703: PPUSH
9704: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9708: LD_EXP 45
9712: PPUSH
9713: LD_STRING D11-Bur-1
9715: PPUSH
9716: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9720: LD_EXP 14
9724: PPUSH
9725: LD_STRING D11-JMM-2
9727: PPUSH
9728: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9732: LD_EXP 45
9736: PPUSH
9737: LD_STRING D11-Bur-2
9739: PPUSH
9740: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9744: LD_EXP 14
9748: PPUSH
9749: LD_STRING D11-JMM-3
9751: PPUSH
9752: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9756: LD_EXP 45
9760: PPUSH
9761: LD_STRING D11-Bur-3
9763: PPUSH
9764: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9768: LD_EXP 14
9772: PPUSH
9773: LD_STRING D11-JMM-4
9775: PPUSH
9776: CALL_OW 88
// if ar_base_spotted then
9780: LD_EXP 8
9784: IFFALSE 9800
// Say ( Burlak , D12-Bur-1 ) else
9786: LD_EXP 45
9790: PPUSH
9791: LD_STRING D12-Bur-1
9793: PPUSH
9794: CALL_OW 88
9798: GO 9839
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9800: LD_INT 7
9802: PPUSH
9803: LD_INT 3
9805: PPUSH
9806: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9810: LD_INT 127
9812: PPUSH
9813: LD_INT 45
9815: PPUSH
9816: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9820: LD_EXP 45
9824: PPUSH
9825: LD_STRING D12-Bur-1a
9827: PPUSH
9828: CALL_OW 88
// dwait ( 0 0$2 ) ;
9832: LD_INT 70
9834: PPUSH
9835: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9839: LD_EXP 45
9843: PPUSH
9844: LD_STRING D12-Bur-1b
9846: PPUSH
9847: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9851: LD_EXP 14
9855: PPUSH
9856: LD_STRING D12-JMM-1
9858: PPUSH
9859: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9863: LD_EXP 45
9867: PPUSH
9868: LD_STRING D12-Bur-2
9870: PPUSH
9871: CALL_OW 88
// if Roth then
9875: LD_EXP 15
9879: IFFALSE 9895
// Say ( Roth , D12-Roth-2 ) else
9881: LD_EXP 15
9885: PPUSH
9886: LD_STRING D12-Roth-2
9888: PPUSH
9889: CALL_OW 88
9893: GO 9907
// Say ( SciRu , D12-RSci1-2 ) ;
9895: CALL 12419 0 0
9899: PPUSH
9900: LD_STRING D12-RSci1-2
9902: PPUSH
9903: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9907: LD_EXP 14
9911: PPUSH
9912: LD_STRING D12-JMM-2
9914: PPUSH
9915: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9919: LD_EXP 45
9923: PPUSH
9924: LD_STRING D12-Bur-3
9926: PPUSH
9927: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9931: LD_EXP 14
9935: PPUSH
9936: LD_STRING D12-JMM-3
9938: PPUSH
9939: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
9943: LD_EXP 45
9947: PPUSH
9948: LD_STRING D12-Bur-4
9950: PPUSH
9951: CALL_OW 88
// case Query ( QBase ) of 1 :
9955: LD_STRING QBase
9957: PPUSH
9958: CALL_OW 97
9962: PUSH
9963: LD_INT 1
9965: DOUBLE
9966: EQUAL
9967: IFTRUE 9971
9969: GO 10089
9971: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
9972: LD_EXP 14
9976: PPUSH
9977: LD_STRING D13a-JMM-1
9979: PPUSH
9980: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
9984: LD_EXP 45
9988: PPUSH
9989: LD_STRING D13a-Bur-1
9991: PPUSH
9992: CALL_OW 88
// if Roth then
9996: LD_EXP 15
10000: IFFALSE 10016
// Say ( Roth , D13a-Roth-1 ) else
10002: LD_EXP 15
10006: PPUSH
10007: LD_STRING D13a-Roth-1
10009: PPUSH
10010: CALL_OW 88
10014: GO 10028
// Say ( SciRu , D13a-RSci1-1 ) ;
10016: CALL 12419 0 0
10020: PPUSH
10021: LD_STRING D13a-RSci1-1
10023: PPUSH
10024: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10028: LD_EXP 14
10032: PPUSH
10033: LD_STRING D13a-JMM-2
10035: PPUSH
10036: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10040: LD_STRING QBaseAgain
10042: PPUSH
10043: CALL_OW 97
10047: PUSH
10048: LD_INT 1
10050: DOUBLE
10051: EQUAL
10052: IFTRUE 10056
10054: GO 10067
10056: POP
// selected_option := 2 ; 2 :
10057: LD_ADDR_VAR 0 2
10061: PUSH
10062: LD_INT 2
10064: ST_TO_ADDR
10065: GO 10087
10067: LD_INT 2
10069: DOUBLE
10070: EQUAL
10071: IFTRUE 10075
10073: GO 10086
10075: POP
// selected_option := 3 ; end ;
10076: LD_ADDR_VAR 0 2
10080: PUSH
10081: LD_INT 3
10083: ST_TO_ADDR
10084: GO 10087
10086: POP
// end ; 2 :
10087: GO 10128
10089: LD_INT 2
10091: DOUBLE
10092: EQUAL
10093: IFTRUE 10097
10095: GO 10108
10097: POP
// selected_option := 2 ; 3 :
10098: LD_ADDR_VAR 0 2
10102: PUSH
10103: LD_INT 2
10105: ST_TO_ADDR
10106: GO 10128
10108: LD_INT 3
10110: DOUBLE
10111: EQUAL
10112: IFTRUE 10116
10114: GO 10127
10116: POP
// selected_option := 3 ; end ;
10117: LD_ADDR_VAR 0 2
10121: PUSH
10122: LD_INT 3
10124: ST_TO_ADDR
10125: GO 10128
10127: POP
// if selected_option = 2 then
10128: LD_VAR 0 2
10132: PUSH
10133: LD_INT 2
10135: EQUAL
10136: IFFALSE 10230
// begin Say ( JMM , D13b-JMM-1 ) ;
10138: LD_EXP 14
10142: PPUSH
10143: LD_STRING D13b-JMM-1
10145: PPUSH
10146: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10150: LD_EXP 45
10154: PPUSH
10155: LD_STRING D13b-Bur-1
10157: PPUSH
10158: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10162: LD_EXP 14
10166: PPUSH
10167: LD_STRING D13b-JMM-2
10169: PPUSH
10170: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10174: LD_EXP 54
10178: PPUSH
10179: LD_STRING D13b-Abd-2
10181: PPUSH
10182: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10186: LD_EXP 14
10190: PPUSH
10191: LD_STRING D13b-JMM-3
10193: PPUSH
10194: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10198: LD_EXP 54
10202: PPUSH
10203: LD_STRING D13b-Abd-3
10205: PPUSH
10206: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10210: LD_EXP 14
10214: PPUSH
10215: LD_STRING D13b-JMM-4
10217: PPUSH
10218: CALL_OW 88
// ar_active_attack := true ;
10222: LD_ADDR_EXP 9
10226: PUSH
10227: LD_INT 1
10229: ST_TO_ADDR
// end ; if selected_option = 3 then
10230: LD_VAR 0 2
10234: PUSH
10235: LD_INT 3
10237: EQUAL
10238: IFFALSE 10264
// begin Say ( JMM , D13c-JMM-1 ) ;
10240: LD_EXP 14
10244: PPUSH
10245: LD_STRING D13c-JMM-1
10247: PPUSH
10248: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10252: LD_EXP 45
10256: PPUSH
10257: LD_STRING D13c-Bur-1
10259: PPUSH
10260: CALL_OW 88
// end ; DialogueOff ;
10264: CALL_OW 7
// if not ar_active_attack then
10268: LD_EXP 9
10272: NOT
10273: IFFALSE 10290
// begin wait ( 6 6$00 ) ;
10275: LD_INT 12600
10277: PPUSH
10278: CALL_OW 67
// ar_active_attack := true ;
10282: LD_ADDR_EXP 9
10286: PUSH
10287: LD_INT 1
10289: ST_TO_ADDR
// end ; end ;
10290: PPOPN 2
10292: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10293: LD_EXP 45
10297: PPUSH
10298: CALL_OW 305
10302: PUSH
10303: LD_EXP 45
10307: PPUSH
10308: CALL_OW 255
10312: PUSH
10313: LD_INT 7
10315: EQUAL
10316: AND
10317: IFFALSE 10513
10319: GO 10321
10321: DISABLE
10322: LD_INT 0
10324: PPUSH
// begin wait ( 4 4$40 ) ;
10325: LD_INT 9800
10327: PPUSH
10328: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10332: LD_INT 35
10334: PPUSH
10335: CALL_OW 67
// until not ru_attackers ;
10339: LD_EXP 51
10343: NOT
10344: IFFALSE 10332
// PrepareGnyevko ;
10346: CALL 2056 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10350: LD_EXP 47
10354: PPUSH
10355: LD_INT 124
10357: PPUSH
10358: LD_INT 118
10360: PPUSH
10361: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10365: LD_EXP 47
10369: PPUSH
10370: CALL_OW 200
// time := 0 0$00 ;
10374: LD_ADDR_VAR 0 1
10378: PUSH
10379: LD_INT 0
10381: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10382: LD_INT 35
10384: PPUSH
10385: CALL_OW 67
// time := time + 0 0$1 ;
10389: LD_ADDR_VAR 0 1
10393: PUSH
10394: LD_VAR 0 1
10398: PUSH
10399: LD_INT 35
10401: PLUS
10402: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10403: LD_EXP 47
10407: PPUSH
10408: LD_INT 124
10410: PPUSH
10411: LD_INT 118
10413: PPUSH
10414: CALL_OW 307
10418: PUSH
10419: LD_VAR 0 1
10423: PUSH
10424: LD_INT 1050
10426: GREATEREQUAL
10427: OR
10428: IFFALSE 10382
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10430: LD_EXP 47
10434: PPUSH
10435: LD_STRING DBelkov-Gny-1
10437: PPUSH
10438: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10442: LD_EXP 45
10446: PPUSH
10447: LD_STRING DBelkov-Bur-1a
10449: PPUSH
10450: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10454: LD_INT 35
10456: PPUSH
10457: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10461: LD_EXP 47
10465: PPUSH
10466: LD_INT 22
10468: PUSH
10469: LD_INT 7
10471: PUSH
10472: EMPTY
10473: LIST
10474: LIST
10475: PPUSH
10476: CALL_OW 69
10480: PPUSH
10481: LD_EXP 47
10485: PPUSH
10486: CALL_OW 74
10490: PPUSH
10491: CALL_OW 296
10495: PUSH
10496: LD_INT 8
10498: LESS
10499: IFFALSE 10454
// SetSide ( Gnyevko , 7 ) ;
10501: LD_EXP 47
10505: PPUSH
10506: LD_INT 7
10508: PPUSH
10509: CALL_OW 235
// end ;
10513: PPOPN 1
10515: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10516: LD_EXP 45
10520: PPUSH
10521: CALL_OW 255
10525: PUSH
10526: LD_INT 7
10528: EQUAL
10529: IFFALSE 10539
10531: GO 10533
10533: DISABLE
// begin enable ;
10534: ENABLE
// PrepareAmericanAttack ;
10535: CALL 6362 0 0
// end ;
10539: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10540: LD_INT 22
10542: PUSH
10543: LD_INT 1
10545: PUSH
10546: EMPTY
10547: LIST
10548: LIST
10549: PPUSH
10550: CALL_OW 69
10554: IFFALSE 10738
10556: GO 10558
10558: DISABLE
10559: LD_INT 0
10561: PPUSH
10562: PPUSH
// begin while true do
10563: LD_INT 1
10565: IFFALSE 10622
// begin wait ( 0 0$1 ) ;
10567: LD_INT 35
10569: PPUSH
10570: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10574: LD_ADDR_VAR 0 2
10578: PUSH
10579: LD_INT 22
10581: PUSH
10582: LD_INT 1
10584: PUSH
10585: EMPTY
10586: LIST
10587: LIST
10588: PPUSH
10589: CALL_OW 69
10593: PPUSH
10594: LD_EXP 14
10598: PPUSH
10599: CALL_OW 74
10603: ST_TO_ADDR
// if See ( 7 , tmp ) then
10604: LD_INT 7
10606: PPUSH
10607: LD_VAR 0 2
10611: PPUSH
10612: CALL_OW 292
10616: IFFALSE 10620
// break ;
10618: GO 10622
// end ;
10620: GO 10563
// DialogueOn ;
10622: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10626: LD_VAR 0 2
10630: PPUSH
10631: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10635: LD_VAR 0 2
10639: PPUSH
10640: CALL_OW 250
10644: PPUSH
10645: LD_VAR 0 2
10649: PPUSH
10650: CALL_OW 251
10654: PPUSH
10655: LD_INT 7
10657: PPUSH
10658: LD_INT 8
10660: PPUSH
10661: CALL_OW 330
// if Denis then
10665: LD_EXP 20
10669: IFFALSE 10683
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10671: LD_EXP 20
10675: PPUSH
10676: LD_STRING DAmerAttack-Pet-1
10678: PPUSH
10679: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10683: LD_EXP 14
10687: PPUSH
10688: LD_STRING DAmerAttack-JMM-1
10690: PPUSH
10691: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10695: LD_EXP 45
10699: PPUSH
10700: LD_STRING DStop-Bur-1
10702: PPUSH
10703: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10707: LD_VAR 0 2
10711: PPUSH
10712: CALL_OW 250
10716: PPUSH
10717: LD_VAR 0 2
10721: PPUSH
10722: CALL_OW 251
10726: PPUSH
10727: LD_INT 7
10729: PPUSH
10730: CALL_OW 331
// DialogueOff ;
10734: CALL_OW 7
// end ;
10738: PPOPN 2
10740: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10741: LD_INT 22
10743: PUSH
10744: LD_INT 3
10746: PUSH
10747: EMPTY
10748: LIST
10749: LIST
10750: PUSH
10751: LD_INT 21
10753: PUSH
10754: LD_INT 1
10756: PUSH
10757: EMPTY
10758: LIST
10759: LIST
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: PPUSH
10765: CALL_OW 69
10769: PUSH
10770: LD_INT 0
10772: EQUAL
10773: IFFALSE 10815
10775: GO 10777
10777: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10778: LD_STRING M5a
10780: PPUSH
10781: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10785: LD_EXP 14
10789: PPUSH
10790: LD_STRING D8-JMM-1
10792: PPUSH
10793: CALL_OW 88
// if Gossudarov then
10797: LD_EXP 31
10801: IFFALSE 10815
// Say ( Gossudarov , D8-Gos-1 ) ;
10803: LD_EXP 31
10807: PPUSH
10808: LD_STRING D8-Gos-1
10810: PPUSH
10811: CALL_OW 88
// end ;
10815: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10816: LD_INT 22
10818: PUSH
10819: LD_INT 2
10821: PUSH
10822: EMPTY
10823: LIST
10824: LIST
10825: PUSH
10826: LD_INT 21
10828: PUSH
10829: LD_INT 1
10831: PUSH
10832: EMPTY
10833: LIST
10834: LIST
10835: PUSH
10836: EMPTY
10837: LIST
10838: LIST
10839: PPUSH
10840: CALL_OW 69
10844: PUSH
10845: LD_INT 0
10847: EQUAL
10848: IFFALSE 10898
10850: GO 10852
10852: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10853: LD_STRING M4c
10855: PPUSH
10856: CALL_OW 337
// if Roth then
10860: LD_EXP 15
10864: IFFALSE 10880
// Say ( Roth , DStop-Roth-1 ) else
10866: LD_EXP 15
10870: PPUSH
10871: LD_STRING DStop-Roth-1
10873: PPUSH
10874: CALL_OW 88
10878: GO 10898
// if Gossudarov then
10880: LD_EXP 31
10884: IFFALSE 10898
// Say ( Gossudarov , D8-Gos-1a ) ;
10886: LD_EXP 31
10890: PPUSH
10891: LD_STRING D8-Gos-1a
10893: PPUSH
10894: CALL_OW 88
// end ;
10898: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10899: LD_INT 7
10901: PPUSH
10902: LD_INT 1
10904: PPUSH
10905: LD_INT 1
10907: PPUSH
10908: CALL 14011 0 3
10912: PUSH
10913: LD_INT 0
10915: EQUAL
10916: PUSH
10917: LD_INT 7
10919: PPUSH
10920: LD_INT 3
10922: PPUSH
10923: LD_INT 1
10925: PPUSH
10926: CALL 14011 0 3
10930: PUSH
10931: LD_INT 0
10933: EQUAL
10934: AND
10935: IFFALSE 10947
10937: GO 10939
10939: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
10940: LD_STRING M1a
10942: PPUSH
10943: CALL_OW 337
// end ;
10947: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 ;
10948: LD_INT 22
10950: PUSH
10951: LD_INT 2
10953: PUSH
10954: EMPTY
10955: LIST
10956: LIST
10957: PUSH
10958: LD_INT 21
10960: PUSH
10961: LD_INT 1
10963: PUSH
10964: EMPTY
10965: LIST
10966: LIST
10967: PUSH
10968: EMPTY
10969: LIST
10970: LIST
10971: PPUSH
10972: CALL_OW 69
10976: PUSH
10977: LD_INT 0
10979: EQUAL
10980: PUSH
10981: LD_INT 22
10983: PUSH
10984: LD_INT 3
10986: PUSH
10987: EMPTY
10988: LIST
10989: LIST
10990: PUSH
10991: LD_INT 21
10993: PUSH
10994: LD_INT 1
10996: PUSH
10997: EMPTY
10998: LIST
10999: LIST
11000: PUSH
11001: EMPTY
11002: LIST
11003: LIST
11004: PPUSH
11005: CALL_OW 69
11009: PUSH
11010: LD_INT 0
11012: EQUAL
11013: AND
11014: PUSH
11015: LD_INT 22
11017: PUSH
11018: LD_INT 1
11020: PUSH
11021: EMPTY
11022: LIST
11023: LIST
11024: PPUSH
11025: CALL_OW 69
11029: PUSH
11030: LD_INT 0
11032: EQUAL
11033: AND
11034: PUSH
11035: LD_INT 7
11037: PPUSH
11038: LD_INT 1
11040: PPUSH
11041: LD_INT 1
11043: PPUSH
11044: CALL 14011 0 3
11048: PUSH
11049: LD_INT 0
11051: EQUAL
11052: AND
11053: PUSH
11054: LD_INT 7
11056: PPUSH
11057: LD_INT 3
11059: PPUSH
11060: LD_INT 1
11062: PPUSH
11063: CALL 14011 0 3
11067: PUSH
11068: LD_INT 0
11070: EQUAL
11071: AND
11072: IFFALSE 12416
11074: GO 11076
11076: DISABLE
11077: LD_INT 0
11079: PPUSH
11080: PPUSH
11081: PPUSH
// begin wait ( 0 0$3 ) ;
11082: LD_INT 105
11084: PPUSH
11085: CALL_OW 67
// if not IsDead ( Masha ) then
11089: LD_EXP 48
11093: PPUSH
11094: CALL_OW 301
11098: NOT
11099: IFFALSE 11113
// AddMedal ( Masha , 1 ) else
11101: LD_STRING Masha
11103: PPUSH
11104: LD_INT 1
11106: PPUSH
11107: CALL_OW 101
11111: GO 11124
// AddMedal ( Masha , - 1 ) ;
11113: LD_STRING Masha
11115: PPUSH
11116: LD_INT 1
11118: NEG
11119: PPUSH
11120: CALL_OW 101
// if abdul_escaped then
11124: LD_EXP 12
11128: IFFALSE 11143
// AddMedal ( Abdul , - 1 ) else
11130: LD_STRING Abdul
11132: PPUSH
11133: LD_INT 1
11135: NEG
11136: PPUSH
11137: CALL_OW 101
11141: GO 11153
// AddMedal ( Abdul , 1 ) ;
11143: LD_STRING Abdul
11145: PPUSH
11146: LD_INT 1
11148: PPUSH
11149: CALL_OW 101
// if loss_counter = 0 then
11153: LD_EXP 13
11157: PUSH
11158: LD_INT 0
11160: EQUAL
11161: IFFALSE 11175
// AddMedal ( People , 2 ) else
11163: LD_STRING People
11165: PPUSH
11166: LD_INT 2
11168: PPUSH
11169: CALL_OW 101
11173: GO 11225
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11175: LD_EXP 13
11179: PUSH
11180: LD_INT 3
11182: PUSH
11183: LD_INT 2
11185: PUSH
11186: LD_INT 2
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: LIST
11193: PUSH
11194: LD_OWVAR 67
11198: ARRAY
11199: LESSEQUAL
11200: IFFALSE 11214
// AddMedal ( People , 1 ) else
11202: LD_STRING People
11204: PPUSH
11205: LD_INT 1
11207: PPUSH
11208: CALL_OW 101
11212: GO 11225
// AddMedal ( People , - 1 ) ;
11214: LD_STRING People
11216: PPUSH
11217: LD_INT 1
11219: NEG
11220: PPUSH
11221: CALL_OW 101
// GiveMedals ( MAIN ) ;
11225: LD_STRING MAIN
11227: PPUSH
11228: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11232: LD_ADDR_VAR 0 2
11236: PUSH
11237: LD_INT 22
11239: PUSH
11240: LD_INT 7
11242: PUSH
11243: EMPTY
11244: LIST
11245: LIST
11246: PUSH
11247: LD_INT 2
11249: PUSH
11250: LD_INT 25
11252: PUSH
11253: LD_INT 1
11255: PUSH
11256: EMPTY
11257: LIST
11258: LIST
11259: PUSH
11260: LD_INT 25
11262: PUSH
11263: LD_INT 2
11265: PUSH
11266: EMPTY
11267: LIST
11268: LIST
11269: PUSH
11270: LD_INT 25
11272: PUSH
11273: LD_INT 3
11275: PUSH
11276: EMPTY
11277: LIST
11278: LIST
11279: PUSH
11280: LD_INT 25
11282: PUSH
11283: LD_INT 4
11285: PUSH
11286: EMPTY
11287: LIST
11288: LIST
11289: PUSH
11290: LD_INT 25
11292: PUSH
11293: LD_INT 5
11295: PUSH
11296: EMPTY
11297: LIST
11298: LIST
11299: PUSH
11300: LD_INT 25
11302: PUSH
11303: LD_INT 8
11305: PUSH
11306: EMPTY
11307: LIST
11308: LIST
11309: PUSH
11310: LD_INT 25
11312: PUSH
11313: LD_INT 9
11315: PUSH
11316: EMPTY
11317: LIST
11318: LIST
11319: PUSH
11320: EMPTY
11321: LIST
11322: LIST
11323: LIST
11324: LIST
11325: LIST
11326: LIST
11327: LIST
11328: LIST
11329: PUSH
11330: EMPTY
11331: LIST
11332: LIST
11333: PPUSH
11334: CALL_OW 69
11338: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11339: LD_VAR 0 2
11343: PPUSH
11344: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11348: LD_ADDR_VAR 0 3
11352: PUSH
11353: LD_EXP 14
11357: PUSH
11358: LD_EXP 15
11362: PUSH
11363: LD_EXP 16
11367: PUSH
11368: LD_EXP 17
11372: PUSH
11373: LD_EXP 18
11377: PUSH
11378: LD_EXP 19
11382: PUSH
11383: LD_EXP 20
11387: PUSH
11388: LD_EXP 21
11392: PUSH
11393: LD_EXP 22
11397: PUSH
11398: LD_EXP 23
11402: PUSH
11403: LD_EXP 24
11407: PUSH
11408: LD_EXP 25
11412: PUSH
11413: LD_EXP 26
11417: PUSH
11418: LD_EXP 27
11422: PUSH
11423: LD_EXP 28
11427: PUSH
11428: LD_EXP 29
11432: PUSH
11433: LD_EXP 30
11437: PUSH
11438: LD_EXP 31
11442: PUSH
11443: LD_EXP 32
11447: PUSH
11448: LD_EXP 33
11452: PUSH
11453: LD_EXP 35
11457: PUSH
11458: LD_EXP 36
11462: PUSH
11463: LD_EXP 37
11467: PUSH
11468: LD_EXP 38
11472: PUSH
11473: LD_EXP 39
11477: PUSH
11478: LD_EXP 40
11482: PUSH
11483: LD_EXP 41
11487: PUSH
11488: LD_EXP 42
11492: PUSH
11493: LD_EXP 43
11497: PUSH
11498: LD_EXP 44
11502: PUSH
11503: LD_EXP 45
11507: PUSH
11508: LD_EXP 46
11512: PUSH
11513: LD_EXP 47
11517: PUSH
11518: EMPTY
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: LIST
11546: LIST
11547: LIST
11548: LIST
11549: LIST
11550: LIST
11551: LIST
11552: ST_TO_ADDR
// if tmp diff tmp2 then
11553: LD_VAR 0 2
11557: PUSH
11558: LD_VAR 0 3
11562: DIFF
11563: IFFALSE 11583
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11565: LD_VAR 0 2
11569: PUSH
11570: LD_VAR 0 3
11574: DIFF
11575: PPUSH
11576: LD_STRING 13a_others
11578: PPUSH
11579: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11583: LD_EXP 14
11587: PPUSH
11588: LD_STRING 13a_JMM
11590: PPUSH
11591: CALL_OW 38
// if Titov then
11595: LD_EXP 33
11599: IFFALSE 11613
// SaveCharacters ( Titov , 13a_Titov ) ;
11601: LD_EXP 33
11605: PPUSH
11606: LD_STRING 13a_Titov
11608: PPUSH
11609: CALL_OW 38
// if Dolgov then
11613: LD_EXP 35
11617: IFFALSE 11631
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11619: LD_EXP 35
11623: PPUSH
11624: LD_STRING 13a_Dolgov
11626: PPUSH
11627: CALL_OW 38
// if Petrosyan then
11631: LD_EXP 36
11635: IFFALSE 11649
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11637: LD_EXP 36
11641: PPUSH
11642: LD_STRING 13a_Petrosyan
11644: PPUSH
11645: CALL_OW 38
// if Scholtze then
11649: LD_EXP 37
11653: IFFALSE 11667
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11655: LD_EXP 37
11659: PPUSH
11660: LD_STRING 13a_Scholtze
11662: PPUSH
11663: CALL_OW 38
// if Oblukov then
11667: LD_EXP 38
11671: IFFALSE 11685
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11673: LD_EXP 38
11677: PPUSH
11678: LD_STRING 13a_Oblukov
11680: PPUSH
11681: CALL_OW 38
// if Kapitsova then
11685: LD_EXP 39
11689: IFFALSE 11703
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11691: LD_EXP 39
11695: PPUSH
11696: LD_STRING 13a_Kapitsova
11698: PPUSH
11699: CALL_OW 38
// if Lipshchin then
11703: LD_EXP 40
11707: IFFALSE 11721
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11709: LD_EXP 40
11713: PPUSH
11714: LD_STRING 13a_Lipshchin
11716: PPUSH
11717: CALL_OW 38
// if Petrovova then
11721: LD_EXP 41
11725: IFFALSE 11739
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11727: LD_EXP 41
11731: PPUSH
11732: LD_STRING 13a_Petrovova
11734: PPUSH
11735: CALL_OW 38
// if Kovalyuk then
11739: LD_EXP 42
11743: IFFALSE 11757
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11745: LD_EXP 42
11749: PPUSH
11750: LD_STRING 13a_Kovalyuk
11752: PPUSH
11753: CALL_OW 38
// if Kuzmov then
11757: LD_EXP 43
11761: IFFALSE 11775
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11763: LD_EXP 43
11767: PPUSH
11768: LD_STRING 13a_Kuzmov
11770: PPUSH
11771: CALL_OW 38
// if Karamazov then
11775: LD_EXP 44
11779: IFFALSE 11793
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11781: LD_EXP 44
11785: PPUSH
11786: LD_STRING 13a_Karamazov
11788: PPUSH
11789: CALL_OW 38
// if Burlak then
11793: LD_EXP 45
11797: IFFALSE 11811
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11799: LD_EXP 45
11803: PPUSH
11804: LD_STRING 13a_Burlak
11806: PPUSH
11807: CALL_OW 38
// if Belkov then
11811: LD_EXP 46
11815: IFFALSE 11829
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11817: LD_EXP 46
11821: PPUSH
11822: LD_STRING 13a_Belkov
11824: PPUSH
11825: CALL_OW 38
// if Gnyevko then
11829: LD_EXP 47
11833: IFFALSE 11847
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11835: LD_EXP 47
11839: PPUSH
11840: LD_STRING 13a_Gnyevko
11842: PPUSH
11843: CALL_OW 38
// if Lisa then
11847: LD_EXP 16
11851: IFFALSE 11865
// SaveCharacters ( Lisa , 13a_Lisa ) ;
11853: LD_EXP 16
11857: PPUSH
11858: LD_STRING 13a_Lisa
11860: PPUSH
11861: CALL_OW 38
// if Donaldson then
11865: LD_EXP 17
11869: IFFALSE 11883
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
11871: LD_EXP 17
11875: PPUSH
11876: LD_STRING 13a_Donaldson
11878: PPUSH
11879: CALL_OW 38
// if Bobby then
11883: LD_EXP 18
11887: IFFALSE 11901
// SaveCharacters ( Bobby , 13a_Bobby ) ;
11889: LD_EXP 18
11893: PPUSH
11894: LD_STRING 13a_Bobby
11896: PPUSH
11897: CALL_OW 38
// if Cyrus then
11901: LD_EXP 19
11905: IFFALSE 11919
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
11907: LD_EXP 19
11911: PPUSH
11912: LD_STRING 13a_Cyrus
11914: PPUSH
11915: CALL_OW 38
// if Denis then
11919: LD_EXP 20
11923: IFFALSE 11937
// SaveCharacters ( Denis , 13a_Denis ) ;
11925: LD_EXP 20
11929: PPUSH
11930: LD_STRING 13a_Denis
11932: PPUSH
11933: CALL_OW 38
// if Brown then
11937: LD_EXP 21
11941: IFFALSE 11955
// SaveCharacters ( Brown , 13a_Brown ) ;
11943: LD_EXP 21
11947: PPUSH
11948: LD_STRING 13a_Brown
11950: PPUSH
11951: CALL_OW 38
// if Gladstone then
11955: LD_EXP 22
11959: IFFALSE 11973
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
11961: LD_EXP 22
11965: PPUSH
11966: LD_STRING 13a_Gladstone
11968: PPUSH
11969: CALL_OW 38
// if Houten then
11973: LD_EXP 23
11977: IFFALSE 11991
// SaveCharacters ( Houten , 13a_Houten ) ;
11979: LD_EXP 23
11983: PPUSH
11984: LD_STRING 13a_Houten
11986: PPUSH
11987: CALL_OW 38
// if Cornel then
11991: LD_EXP 24
11995: IFFALSE 12009
// SaveCharacters ( Cornel , 13a_Cornel ) ;
11997: LD_EXP 24
12001: PPUSH
12002: LD_STRING 13a_Cornel
12004: PPUSH
12005: CALL_OW 38
// if Gary then
12009: LD_EXP 25
12013: IFFALSE 12027
// SaveCharacters ( Gary , 13a_Gary ) ;
12015: LD_EXP 25
12019: PPUSH
12020: LD_STRING 13a_Gary
12022: PPUSH
12023: CALL_OW 38
// if Frank then
12027: LD_EXP 26
12031: IFFALSE 12045
// SaveCharacters ( Frank , 13a_Frank ) ;
12033: LD_EXP 26
12037: PPUSH
12038: LD_STRING 13a_Frank
12040: PPUSH
12041: CALL_OW 38
// if Kikuchi then
12045: LD_EXP 27
12049: IFFALSE 12063
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12051: LD_EXP 27
12055: PPUSH
12056: LD_STRING 13a_Kikuchi
12058: PPUSH
12059: CALL_OW 38
// if Simms then
12063: LD_EXP 28
12067: IFFALSE 12081
// SaveCharacters ( Simms , 13a_Simms ) ;
12069: LD_EXP 28
12073: PPUSH
12074: LD_STRING 13a_Simms
12076: PPUSH
12077: CALL_OW 38
// if Joan then
12081: LD_EXP 29
12085: IFFALSE 12099
// SaveCharacters ( Joan , 13a_Joan ) ;
12087: LD_EXP 29
12091: PPUSH
12092: LD_STRING 13a_Joan
12094: PPUSH
12095: CALL_OW 38
// if DeltaDoctor then
12099: LD_EXP 30
12103: IFFALSE 12117
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12105: LD_EXP 30
12109: PPUSH
12110: LD_STRING 13a_DeltaDoctor
12112: PPUSH
12113: CALL_OW 38
// if Gossudarov then
12117: LD_EXP 31
12121: IFFALSE 12135
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12123: LD_EXP 31
12127: PPUSH
12128: LD_STRING 13a_Gossudarov
12130: PPUSH
12131: CALL_OW 38
// if Kirilenkova then
12135: LD_EXP 32
12139: IFFALSE 12153
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12141: LD_EXP 32
12145: PPUSH
12146: LD_STRING 13a_Kirilenkova
12148: PPUSH
12149: CALL_OW 38
// if Masha then
12153: LD_EXP 48
12157: IFFALSE 12212
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12159: LD_EXP 48
12163: PPUSH
12164: CALL_OW 265
12168: PUSH
12169: LD_EXP 48
12173: PPUSH
12174: CALL_OW 262
12178: PUSH
12179: LD_EXP 48
12183: PPUSH
12184: CALL_OW 263
12188: PUSH
12189: LD_EXP 48
12193: PPUSH
12194: CALL_OW 264
12198: PUSH
12199: EMPTY
12200: LIST
12201: LIST
12202: LIST
12203: LIST
12204: PPUSH
12205: LD_STRING 13a_Masha
12207: PPUSH
12208: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12212: LD_ADDR_VAR 0 2
12216: PUSH
12217: LD_INT 21
12219: PUSH
12220: LD_INT 3
12222: PUSH
12223: EMPTY
12224: LIST
12225: LIST
12226: PPUSH
12227: CALL_OW 69
12231: ST_TO_ADDR
// tmp2 := [ ] ;
12232: LD_ADDR_VAR 0 3
12236: PUSH
12237: EMPTY
12238: ST_TO_ADDR
// if tmp then
12239: LD_VAR 0 2
12243: IFFALSE 12394
// for i in tmp do
12245: LD_ADDR_VAR 0 1
12249: PUSH
12250: LD_VAR 0 2
12254: PUSH
12255: FOR_IN
12256: IFFALSE 12392
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12258: LD_ADDR_VAR 0 3
12262: PUSH
12263: LD_VAR 0 3
12267: PUSH
12268: LD_VAR 0 1
12272: PPUSH
12273: CALL_OW 255
12277: PUSH
12278: LD_VAR 0 1
12282: PPUSH
12283: CALL_OW 248
12287: PUSH
12288: LD_VAR 0 1
12292: PPUSH
12293: CALL_OW 266
12297: PUSH
12298: LD_VAR 0 1
12302: PPUSH
12303: CALL_OW 250
12307: PUSH
12308: LD_VAR 0 1
12312: PPUSH
12313: CALL_OW 251
12317: PUSH
12318: LD_VAR 0 1
12322: PPUSH
12323: CALL_OW 254
12327: PUSH
12328: LD_VAR 0 1
12332: PPUSH
12333: CALL_OW 267
12337: PUSH
12338: LD_VAR 0 1
12342: PPUSH
12343: LD_INT 1
12345: PPUSH
12346: CALL_OW 268
12350: PUSH
12351: LD_VAR 0 1
12355: PPUSH
12356: LD_INT 2
12358: PPUSH
12359: CALL_OW 268
12363: PUSH
12364: LD_VAR 0 1
12368: PPUSH
12369: CALL_OW 269
12373: PUSH
12374: EMPTY
12375: LIST
12376: LIST
12377: LIST
12378: LIST
12379: LIST
12380: LIST
12381: LIST
12382: LIST
12383: LIST
12384: LIST
12385: PUSH
12386: EMPTY
12387: LIST
12388: ADD
12389: ST_TO_ADDR
12390: GO 12255
12392: POP
12393: POP
// if tmp2 then
12394: LD_VAR 0 3
12398: IFFALSE 12412
// SaveVariable ( tmp2 , 13a_buildings ) ;
12400: LD_VAR 0 3
12404: PPUSH
12405: LD_STRING 13a_buildings
12407: PPUSH
12408: CALL_OW 39
// YouWin ;
12412: CALL_OW 103
// end ;
12416: PPOPN 3
12418: END
// export function SciRu ; var tmp , t ; begin
12419: LD_INT 0
12421: PPUSH
12422: PPUSH
12423: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12424: LD_ADDR_VAR 0 3
12428: PUSH
12429: LD_EXP 31
12433: PUSH
12434: LD_EXP 45
12438: PUSH
12439: LD_EXP 33
12443: PUSH
12444: LD_EXP 46
12448: PUSH
12449: LD_EXP 47
12453: PUSH
12454: LD_EXP 36
12458: PUSH
12459: LD_EXP 37
12463: PUSH
12464: LD_EXP 35
12468: PUSH
12469: EMPTY
12470: LIST
12471: LIST
12472: LIST
12473: LIST
12474: LIST
12475: LIST
12476: LIST
12477: LIST
12478: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12479: LD_ADDR_VAR 0 2
12483: PUSH
12484: LD_INT 22
12486: PUSH
12487: LD_INT 7
12489: PUSH
12490: EMPTY
12491: LIST
12492: LIST
12493: PUSH
12494: LD_INT 23
12496: PUSH
12497: LD_INT 3
12499: PUSH
12500: EMPTY
12501: LIST
12502: LIST
12503: PUSH
12504: LD_INT 25
12506: PUSH
12507: LD_INT 4
12509: PUSH
12510: EMPTY
12511: LIST
12512: LIST
12513: PUSH
12514: LD_INT 26
12516: PUSH
12517: LD_INT 1
12519: PUSH
12520: EMPTY
12521: LIST
12522: LIST
12523: PUSH
12524: EMPTY
12525: LIST
12526: LIST
12527: LIST
12528: LIST
12529: PPUSH
12530: CALL_OW 69
12534: PUSH
12535: LD_VAR 0 3
12539: DIFF
12540: ST_TO_ADDR
// if tmp then
12541: LD_VAR 0 2
12545: IFFALSE 12561
// result := tmp [ 1 ] ;
12547: LD_ADDR_VAR 0 1
12551: PUSH
12552: LD_VAR 0 2
12556: PUSH
12557: LD_INT 1
12559: ARRAY
12560: ST_TO_ADDR
// end ;
12561: LD_VAR 0 1
12565: RET
// export function SolRu ; var tmp , t ; begin
12566: LD_INT 0
12568: PPUSH
12569: PPUSH
12570: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12571: LD_ADDR_VAR 0 3
12575: PUSH
12576: LD_EXP 31
12580: PUSH
12581: LD_EXP 45
12585: PUSH
12586: LD_EXP 33
12590: PUSH
12591: LD_EXP 46
12595: PUSH
12596: LD_EXP 47
12600: PUSH
12601: LD_EXP 36
12605: PUSH
12606: LD_EXP 37
12610: PUSH
12611: LD_EXP 35
12615: PUSH
12616: EMPTY
12617: LIST
12618: LIST
12619: LIST
12620: LIST
12621: LIST
12622: LIST
12623: LIST
12624: LIST
12625: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12626: LD_ADDR_VAR 0 2
12630: PUSH
12631: LD_INT 22
12633: PUSH
12634: LD_INT 7
12636: PUSH
12637: EMPTY
12638: LIST
12639: LIST
12640: PUSH
12641: LD_INT 23
12643: PUSH
12644: LD_INT 3
12646: PUSH
12647: EMPTY
12648: LIST
12649: LIST
12650: PUSH
12651: LD_INT 25
12653: PUSH
12654: LD_INT 1
12656: PUSH
12657: EMPTY
12658: LIST
12659: LIST
12660: PUSH
12661: LD_INT 26
12663: PUSH
12664: LD_INT 1
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: PUSH
12671: EMPTY
12672: LIST
12673: LIST
12674: LIST
12675: LIST
12676: PPUSH
12677: CALL_OW 69
12681: PUSH
12682: LD_VAR 0 3
12686: DIFF
12687: ST_TO_ADDR
// if tmp then
12688: LD_VAR 0 2
12692: IFFALSE 12708
// result := tmp [ 1 ] ;
12694: LD_ADDR_VAR 0 1
12698: PUSH
12699: LD_VAR 0 2
12703: PUSH
12704: LD_INT 1
12706: ARRAY
12707: ST_TO_ADDR
// end ; end_of_file
12708: LD_VAR 0 1
12712: RET
// export function CustomEvent ( event ) ; begin
12713: LD_INT 0
12715: PPUSH
// end ;
12716: LD_VAR 0 2
12720: RET
// on UnitDestroyed ( un ) do var i , side ;
12721: LD_INT 0
12723: PPUSH
12724: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12725: LD_VAR 0 1
12729: PUSH
12730: LD_INT 22
12732: PUSH
12733: LD_INT 7
12735: PUSH
12736: EMPTY
12737: LIST
12738: LIST
12739: PUSH
12740: LD_INT 2
12742: PUSH
12743: LD_INT 25
12745: PUSH
12746: LD_INT 1
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: PUSH
12753: LD_INT 25
12755: PUSH
12756: LD_INT 2
12758: PUSH
12759: EMPTY
12760: LIST
12761: LIST
12762: PUSH
12763: LD_INT 25
12765: PUSH
12766: LD_INT 3
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: PUSH
12773: LD_INT 25
12775: PUSH
12776: LD_INT 4
12778: PUSH
12779: EMPTY
12780: LIST
12781: LIST
12782: PUSH
12783: LD_INT 25
12785: PUSH
12786: LD_INT 5
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: PUSH
12793: LD_INT 25
12795: PUSH
12796: LD_INT 8
12798: PUSH
12799: EMPTY
12800: LIST
12801: LIST
12802: PUSH
12803: LD_INT 25
12805: PUSH
12806: LD_INT 9
12808: PUSH
12809: EMPTY
12810: LIST
12811: LIST
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: LIST
12822: PUSH
12823: EMPTY
12824: LIST
12825: LIST
12826: PPUSH
12827: CALL_OW 69
12831: IN
12832: IFFALSE 12848
// loss_counter := loss_counter + 1 ;
12834: LD_ADDR_EXP 13
12838: PUSH
12839: LD_EXP 13
12843: PUSH
12844: LD_INT 1
12846: PLUS
12847: ST_TO_ADDR
// if un = Abdul then
12848: LD_VAR 0 1
12852: PUSH
12853: LD_EXP 54
12857: EQUAL
12858: IFFALSE 12868
// abdul_escaped := false ;
12860: LD_ADDR_EXP 12
12864: PUSH
12865: LD_INT 0
12867: ST_TO_ADDR
// if un in ru_attackers then
12868: LD_VAR 0 1
12872: PUSH
12873: LD_EXP 51
12877: IN
12878: IFFALSE 12896
// ru_attackers := ru_attackers diff un ;
12880: LD_ADDR_EXP 51
12884: PUSH
12885: LD_EXP 51
12889: PUSH
12890: LD_VAR 0 1
12894: DIFF
12895: ST_TO_ADDR
// if un in ar_attackers then
12896: LD_VAR 0 1
12900: PUSH
12901: LD_EXP 10
12905: IN
12906: IFFALSE 12924
// ar_attackers := ar_attackers diff un ;
12908: LD_ADDR_EXP 10
12912: PUSH
12913: LD_EXP 10
12917: PUSH
12918: LD_VAR 0 1
12922: DIFF
12923: ST_TO_ADDR
// if un = JMM then
12924: LD_VAR 0 1
12928: PUSH
12929: LD_EXP 14
12933: EQUAL
12934: IFFALSE 12945
// begin YouLost ( JMM ) ;
12936: LD_STRING JMM
12938: PPUSH
12939: CALL_OW 104
// exit ;
12943: GO 13034
// end ; if un = Burlak then
12945: LD_VAR 0 1
12949: PUSH
12950: LD_EXP 45
12954: EQUAL
12955: IFFALSE 12966
// begin YouLost ( Burlak ) ;
12957: LD_STRING Burlak
12959: PPUSH
12960: CALL_OW 104
// exit ;
12964: GO 13034
// end ; if un = freedom then
12966: LD_VAR 0 1
12970: PUSH
12971: LD_EXP 3
12975: EQUAL
12976: IFFALSE 12987
// begin YouLost ( Destroyed ) ;
12978: LD_STRING Destroyed
12980: PPUSH
12981: CALL_OW 104
// exit ;
12985: GO 13034
// end ; if un = Masha then
12987: LD_VAR 0 1
12991: PUSH
12992: LD_EXP 48
12996: EQUAL
12997: IFFALSE 13006
// ChangeMissionObjectives ( M4b ) ;
12999: LD_STRING M4b
13001: PPUSH
13002: CALL_OW 337
// if un = Mastodont then
13006: LD_VAR 0 1
13010: PUSH
13011: LD_EXP 55
13015: EQUAL
13016: IFFALSE 13025
// ChangeMissionObjectives ( M4a ) ;
13018: LD_STRING M4a
13020: PPUSH
13021: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13025: LD_VAR 0 1
13029: PPUSH
13030: CALL 83636 0 1
// end ;
13034: PPOPN 3
13036: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13037: LD_VAR 0 1
13041: PPUSH
13042: LD_VAR 0 2
13046: PPUSH
13047: CALL 85748 0 2
// end ;
13051: PPOPN 2
13053: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13054: LD_VAR 0 1
13058: PPUSH
13059: CALL 84816 0 1
// end ;
13063: PPOPN 1
13065: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13066: LD_VAR 0 1
13070: PUSH
13071: LD_INT 22
13073: PUSH
13074: LD_INT 7
13076: PUSH
13077: EMPTY
13078: LIST
13079: LIST
13080: PUSH
13081: LD_INT 30
13083: PUSH
13084: LD_INT 0
13086: PUSH
13087: EMPTY
13088: LIST
13089: LIST
13090: PUSH
13091: EMPTY
13092: LIST
13093: LIST
13094: PPUSH
13095: CALL_OW 69
13099: IN
13100: IFFALSE 13139
// begin SetBName ( building , freedom ) ;
13102: LD_VAR 0 1
13106: PPUSH
13107: LD_STRING freedom
13109: PPUSH
13110: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13114: LD_INT 0
13116: PPUSH
13117: LD_INT 7
13119: PPUSH
13120: LD_INT 0
13122: PPUSH
13123: CALL_OW 324
// freedom := building ;
13127: LD_ADDR_EXP 3
13131: PUSH
13132: LD_VAR 0 1
13136: ST_TO_ADDR
// exit ;
13137: GO 13205
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13139: LD_VAR 0 1
13143: PUSH
13144: LD_INT 22
13146: PUSH
13147: LD_INT 7
13149: PUSH
13150: EMPTY
13151: LIST
13152: LIST
13153: PUSH
13154: LD_INT 23
13156: PUSH
13157: LD_INT 3
13159: PUSH
13160: EMPTY
13161: LIST
13162: LIST
13163: PUSH
13164: LD_INT 30
13166: PUSH
13167: LD_INT 6
13169: PUSH
13170: EMPTY
13171: LIST
13172: LIST
13173: PUSH
13174: EMPTY
13175: LIST
13176: LIST
13177: LIST
13178: PPUSH
13179: CALL_OW 69
13183: IN
13184: IFFALSE 13196
// begin ru_lab_builded := true ;
13186: LD_ADDR_EXP 5
13190: PUSH
13191: LD_INT 1
13193: ST_TO_ADDR
// exit ;
13194: GO 13205
// end ; MCE_BuildingComplete ( building ) ;
13196: LD_VAR 0 1
13200: PPUSH
13201: CALL 85057 0 1
// end ;
13205: PPOPN 1
13207: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13208: LD_VAR 0 1
13212: PPUSH
13213: LD_VAR 0 2
13217: PPUSH
13218: CALL 83332 0 2
// end ;
13222: PPOPN 2
13224: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13225: LD_VAR 0 1
13229: PPUSH
13230: LD_VAR 0 2
13234: PPUSH
13235: LD_VAR 0 3
13239: PPUSH
13240: LD_VAR 0 4
13244: PPUSH
13245: LD_VAR 0 5
13249: PPUSH
13250: CALL 82952 0 5
// end ;
13254: PPOPN 5
13256: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13257: LD_VAR 0 1
13261: PPUSH
13262: LD_VAR 0 2
13266: PPUSH
13267: CALL 82548 0 2
// end ;
13271: PPOPN 2
13273: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13274: LD_VAR 0 1
13278: PPUSH
13279: LD_VAR 0 2
13283: PPUSH
13284: LD_VAR 0 3
13288: PPUSH
13289: LD_VAR 0 4
13293: PPUSH
13294: CALL 82386 0 4
// end ;
13298: PPOPN 4
13300: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13301: LD_VAR 0 1
13305: PPUSH
13306: LD_VAR 0 2
13310: PPUSH
13311: LD_VAR 0 3
13315: PPUSH
13316: CALL 82161 0 3
// end ;
13320: PPOPN 3
13322: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13323: LD_VAR 0 1
13327: PPUSH
13328: LD_VAR 0 2
13332: PPUSH
13333: CALL 82046 0 2
// end ;
13337: PPOPN 2
13339: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13340: LD_VAR 0 1
13344: PPUSH
13345: LD_VAR 0 2
13349: PPUSH
13350: CALL 86009 0 2
// end ;
13354: PPOPN 2
13356: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13357: LD_VAR 0 1
13361: PPUSH
13362: LD_VAR 0 2
13366: PPUSH
13367: LD_VAR 0 3
13371: PPUSH
13372: LD_VAR 0 4
13376: PPUSH
13377: CALL 86225 0 4
// end ;
13381: PPOPN 4
13383: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13384: LD_VAR 0 1
13388: PPUSH
13389: LD_VAR 0 2
13393: PPUSH
13394: CALL 81855 0 2
// end ;
13398: PPOPN 2
13400: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13401: LD_VAR 0 1
13405: PPUSH
13406: CALL 86508 0 1
// end ; end_of_file
13410: PPOPN 1
13412: END
// every 0 0$30 do var cr , time ;
13413: GO 13415
13415: DISABLE
13416: LD_INT 0
13418: PPUSH
13419: PPUSH
// begin time := 0 0$30 ;
13420: LD_ADDR_VAR 0 2
13424: PUSH
13425: LD_INT 1050
13427: ST_TO_ADDR
// while game do
13428: LD_EXP 2
13432: IFFALSE 13531
// begin wait ( time ) ;
13434: LD_VAR 0 2
13438: PPUSH
13439: CALL_OW 67
// if tick > 2 2$00 then
13443: LD_OWVAR 1
13447: PUSH
13448: LD_INT 4200
13450: GREATER
13451: IFFALSE 13484
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13453: LD_ADDR_VAR 0 2
13457: PUSH
13458: LD_VAR 0 2
13462: PUSH
13463: LD_INT 280
13465: PUSH
13466: LD_INT 420
13468: PUSH
13469: LD_INT 630
13471: PUSH
13472: EMPTY
13473: LIST
13474: LIST
13475: LIST
13476: PUSH
13477: LD_OWVAR 67
13481: ARRAY
13482: PLUS
13483: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13484: LD_INT 1
13486: PPUSH
13487: LD_INT 5
13489: PPUSH
13490: CALL_OW 12
13494: PPUSH
13495: LD_INT 70
13497: PPUSH
13498: LD_INT 49
13500: PPUSH
13501: LD_INT 25
13503: PPUSH
13504: LD_INT 1
13506: PPUSH
13507: CALL_OW 56
// if time > 5 5$00 then
13511: LD_VAR 0 2
13515: PUSH
13516: LD_INT 10500
13518: GREATER
13519: IFFALSE 13529
// time := 0 0$30 ;
13521: LD_ADDR_VAR 0 2
13525: PUSH
13526: LD_INT 1050
13528: ST_TO_ADDR
// end ;
13529: GO 13428
// end ;
13531: PPOPN 2
13533: END
// every 0 0$30 do var cr , time ;
13534: GO 13536
13536: DISABLE
13537: LD_INT 0
13539: PPUSH
13540: PPUSH
// begin time := 0 0$20 ;
13541: LD_ADDR_VAR 0 2
13545: PUSH
13546: LD_INT 700
13548: ST_TO_ADDR
// while game do
13549: LD_EXP 2
13553: IFFALSE 13642
// begin wait ( time ) ;
13555: LD_VAR 0 2
13559: PPUSH
13560: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13564: LD_ADDR_VAR 0 2
13568: PUSH
13569: LD_VAR 0 2
13573: PUSH
13574: LD_INT 490
13576: PUSH
13577: LD_INT 525
13579: PUSH
13580: LD_INT 560
13582: PUSH
13583: EMPTY
13584: LIST
13585: LIST
13586: LIST
13587: PUSH
13588: LD_OWVAR 67
13592: ARRAY
13593: PLUS
13594: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13595: LD_INT 3
13597: PPUSH
13598: LD_INT 5
13600: PPUSH
13601: CALL_OW 12
13605: PPUSH
13606: LD_INT 26
13608: PPUSH
13609: LD_INT 9
13611: PPUSH
13612: LD_INT 30
13614: PPUSH
13615: LD_INT 1
13617: PPUSH
13618: CALL_OW 56
// if time > 3 3$00 then
13622: LD_VAR 0 2
13626: PUSH
13627: LD_INT 6300
13629: GREATER
13630: IFFALSE 13640
// time := 0 0$20 ;
13632: LD_ADDR_VAR 0 2
13636: PUSH
13637: LD_INT 700
13639: ST_TO_ADDR
// end ;
13640: GO 13549
// end ;
13642: PPOPN 2
13644: END
// every 0 0$30 do var cr , time ;
13645: GO 13647
13647: DISABLE
13648: LD_INT 0
13650: PPUSH
13651: PPUSH
// begin time := 0 0$20 ;
13652: LD_ADDR_VAR 0 2
13656: PUSH
13657: LD_INT 700
13659: ST_TO_ADDR
// while game do
13660: LD_EXP 2
13664: IFFALSE 13789
// begin wait ( time ) ;
13666: LD_VAR 0 2
13670: PPUSH
13671: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13675: LD_ADDR_VAR 0 2
13679: PUSH
13680: LD_VAR 0 2
13684: PUSH
13685: LD_INT 175
13687: PUSH
13688: LD_INT 210
13690: PUSH
13691: LD_INT 280
13693: PUSH
13694: EMPTY
13695: LIST
13696: LIST
13697: LIST
13698: PUSH
13699: LD_OWVAR 67
13703: ARRAY
13704: PLUS
13705: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13706: LD_INT 1
13708: PPUSH
13709: LD_INT 5
13711: PPUSH
13712: CALL_OW 12
13716: PPUSH
13717: LD_INT 179
13719: PPUSH
13720: LD_INT 101
13722: PPUSH
13723: LD_INT 20
13725: PPUSH
13726: LD_INT 1
13728: PPUSH
13729: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13733: LD_INT 350
13735: PPUSH
13736: LD_INT 525
13738: PPUSH
13739: CALL_OW 12
13743: PPUSH
13744: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13748: LD_INT 1
13750: PPUSH
13751: LD_INT 5
13753: PPUSH
13754: CALL_OW 12
13758: PPUSH
13759: LD_INT 9
13761: PPUSH
13762: LD_INT 1
13764: PPUSH
13765: CALL_OW 55
// if time > 4 4$00 then
13769: LD_VAR 0 2
13773: PUSH
13774: LD_INT 8400
13776: GREATER
13777: IFFALSE 13787
// time := 0 0$30 ;
13779: LD_ADDR_VAR 0 2
13783: PUSH
13784: LD_INT 1050
13786: ST_TO_ADDR
// end ;
13787: GO 13660
// end ;
13789: PPOPN 2
13791: END
// every 0 0$30 do var cr , time ;
13792: GO 13794
13794: DISABLE
13795: LD_INT 0
13797: PPUSH
13798: PPUSH
// begin time := 0 0$10 ;
13799: LD_ADDR_VAR 0 2
13803: PUSH
13804: LD_INT 350
13806: ST_TO_ADDR
// while game do
13807: LD_EXP 2
13811: IFFALSE 13945
// begin wait ( time ) ;
13813: LD_VAR 0 2
13817: PPUSH
13818: CALL_OW 67
// time := time + 0 0$10 ;
13822: LD_ADDR_VAR 0 2
13826: PUSH
13827: LD_VAR 0 2
13831: PUSH
13832: LD_INT 350
13834: PLUS
13835: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
13836: LD_INT 1
13838: PPUSH
13839: LD_INT 5
13841: PPUSH
13842: CALL_OW 12
13846: PPUSH
13847: LD_INT 11
13849: PPUSH
13850: LD_INT 1
13852: PPUSH
13853: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
13857: LD_ADDR_VAR 0 1
13861: PUSH
13862: LD_INT 1
13864: PPUSH
13865: LD_INT 3
13867: PPUSH
13868: CALL_OW 12
13872: ST_TO_ADDR
// if cr = 1 then
13873: LD_VAR 0 1
13877: PUSH
13878: LD_INT 1
13880: EQUAL
13881: IFFALSE 13925
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
13883: LD_INT 700
13885: PPUSH
13886: LD_INT 1575
13888: PPUSH
13889: CALL_OW 12
13893: PPUSH
13894: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
13898: LD_INT 1
13900: PPUSH
13901: LD_INT 5
13903: PPUSH
13904: CALL_OW 12
13908: PPUSH
13909: LD_INT 34
13911: PPUSH
13912: LD_INT 50
13914: PPUSH
13915: LD_INT 7
13917: PPUSH
13918: LD_INT 1
13920: PPUSH
13921: CALL_OW 56
// end ; if time > 8 8$00 then
13925: LD_VAR 0 2
13929: PUSH
13930: LD_INT 16800
13932: GREATER
13933: IFFALSE 13943
// time := 0 0$40 ;
13935: LD_ADDR_VAR 0 2
13939: PUSH
13940: LD_INT 1400
13942: ST_TO_ADDR
// end ;
13943: GO 13807
// end ; end_of_file
13945: PPOPN 2
13947: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13948: LD_INT 0
13950: PPUSH
13951: PPUSH
// if exist_mode then
13952: LD_VAR 0 2
13956: IFFALSE 13981
// unit := CreateCharacter ( prefix & ident ) else
13958: LD_ADDR_VAR 0 5
13962: PUSH
13963: LD_VAR 0 3
13967: PUSH
13968: LD_VAR 0 1
13972: STR
13973: PPUSH
13974: CALL_OW 34
13978: ST_TO_ADDR
13979: GO 13996
// unit := NewCharacter ( ident ) ;
13981: LD_ADDR_VAR 0 5
13985: PUSH
13986: LD_VAR 0 1
13990: PPUSH
13991: CALL_OW 25
13995: ST_TO_ADDR
// result := unit ;
13996: LD_ADDR_VAR 0 4
14000: PUSH
14001: LD_VAR 0 5
14005: ST_TO_ADDR
// end ;
14006: LD_VAR 0 4
14010: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14011: LD_INT 0
14013: PPUSH
14014: PPUSH
// if not side or not nation then
14015: LD_VAR 0 1
14019: NOT
14020: PUSH
14021: LD_VAR 0 2
14025: NOT
14026: OR
14027: IFFALSE 14031
// exit ;
14029: GO 14675
// case nation of nation_american :
14031: LD_VAR 0 2
14035: PUSH
14036: LD_INT 1
14038: DOUBLE
14039: EQUAL
14040: IFTRUE 14044
14042: GO 14218
14044: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
14045: LD_ADDR_VAR 0 4
14049: PUSH
14050: LD_INT 35
14052: PUSH
14053: LD_INT 45
14055: PUSH
14056: LD_INT 46
14058: PUSH
14059: LD_INT 47
14061: PUSH
14062: LD_INT 1
14064: PUSH
14065: LD_INT 2
14067: PUSH
14068: LD_INT 6
14070: PUSH
14071: LD_INT 15
14073: PUSH
14074: LD_INT 16
14076: PUSH
14077: LD_INT 7
14079: PUSH
14080: LD_INT 12
14082: PUSH
14083: LD_INT 13
14085: PUSH
14086: LD_INT 10
14088: PUSH
14089: LD_INT 14
14091: PUSH
14092: LD_INT 20
14094: PUSH
14095: LD_INT 21
14097: PUSH
14098: LD_INT 22
14100: PUSH
14101: LD_INT 25
14103: PUSH
14104: LD_INT 32
14106: PUSH
14107: LD_INT 27
14109: PUSH
14110: LD_INT 36
14112: PUSH
14113: LD_INT 69
14115: PUSH
14116: LD_INT 39
14118: PUSH
14119: LD_INT 34
14121: PUSH
14122: LD_INT 40
14124: PUSH
14125: LD_INT 48
14127: PUSH
14128: LD_INT 49
14130: PUSH
14131: LD_INT 50
14133: PUSH
14134: LD_INT 51
14136: PUSH
14137: LD_INT 52
14139: PUSH
14140: LD_INT 53
14142: PUSH
14143: LD_INT 54
14145: PUSH
14146: LD_INT 55
14148: PUSH
14149: LD_INT 56
14151: PUSH
14152: LD_INT 57
14154: PUSH
14155: LD_INT 58
14157: PUSH
14158: LD_INT 59
14160: PUSH
14161: LD_INT 60
14163: PUSH
14164: LD_INT 61
14166: PUSH
14167: LD_INT 62
14169: PUSH
14170: LD_INT 80
14172: PUSH
14173: EMPTY
14174: LIST
14175: LIST
14176: LIST
14177: LIST
14178: LIST
14179: LIST
14180: LIST
14181: LIST
14182: LIST
14183: LIST
14184: LIST
14185: LIST
14186: LIST
14187: LIST
14188: LIST
14189: LIST
14190: LIST
14191: LIST
14192: LIST
14193: LIST
14194: LIST
14195: LIST
14196: LIST
14197: LIST
14198: LIST
14199: LIST
14200: LIST
14201: LIST
14202: LIST
14203: LIST
14204: LIST
14205: LIST
14206: LIST
14207: LIST
14208: LIST
14209: LIST
14210: LIST
14211: LIST
14212: LIST
14213: LIST
14214: LIST
14215: ST_TO_ADDR
14216: GO 14599
14218: LD_INT 2
14220: DOUBLE
14221: EQUAL
14222: IFTRUE 14226
14224: GO 14408
14226: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
14227: LD_ADDR_VAR 0 4
14231: PUSH
14232: LD_INT 35
14234: PUSH
14235: LD_INT 45
14237: PUSH
14238: LD_INT 46
14240: PUSH
14241: LD_INT 47
14243: PUSH
14244: LD_INT 70
14246: PUSH
14247: LD_INT 1
14249: PUSH
14250: LD_INT 11
14252: PUSH
14253: LD_INT 3
14255: PUSH
14256: LD_INT 4
14258: PUSH
14259: LD_INT 5
14261: PUSH
14262: LD_INT 6
14264: PUSH
14265: LD_INT 15
14267: PUSH
14268: LD_INT 18
14270: PUSH
14271: LD_INT 7
14273: PUSH
14274: LD_INT 17
14276: PUSH
14277: LD_INT 8
14279: PUSH
14280: LD_INT 20
14282: PUSH
14283: LD_INT 21
14285: PUSH
14286: LD_INT 22
14288: PUSH
14289: LD_INT 72
14291: PUSH
14292: LD_INT 26
14294: PUSH
14295: LD_INT 69
14297: PUSH
14298: LD_INT 39
14300: PUSH
14301: LD_INT 40
14303: PUSH
14304: LD_INT 41
14306: PUSH
14307: LD_INT 42
14309: PUSH
14310: LD_INT 43
14312: PUSH
14313: LD_INT 48
14315: PUSH
14316: LD_INT 49
14318: PUSH
14319: LD_INT 50
14321: PUSH
14322: LD_INT 51
14324: PUSH
14325: LD_INT 52
14327: PUSH
14328: LD_INT 53
14330: PUSH
14331: LD_INT 54
14333: PUSH
14334: LD_INT 55
14336: PUSH
14337: LD_INT 56
14339: PUSH
14340: LD_INT 60
14342: PUSH
14343: LD_INT 61
14345: PUSH
14346: LD_INT 62
14348: PUSH
14349: LD_INT 66
14351: PUSH
14352: LD_INT 67
14354: PUSH
14355: LD_INT 68
14357: PUSH
14358: LD_INT 81
14360: PUSH
14361: EMPTY
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: LIST
14371: LIST
14372: LIST
14373: LIST
14374: LIST
14375: LIST
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: LIST
14382: LIST
14383: LIST
14384: LIST
14385: LIST
14386: LIST
14387: LIST
14388: LIST
14389: LIST
14390: LIST
14391: LIST
14392: LIST
14393: LIST
14394: LIST
14395: LIST
14396: LIST
14397: LIST
14398: LIST
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: LIST
14405: ST_TO_ADDR
14406: GO 14599
14408: LD_INT 3
14410: DOUBLE
14411: EQUAL
14412: IFTRUE 14416
14414: GO 14598
14416: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14417: LD_ADDR_VAR 0 4
14421: PUSH
14422: LD_INT 46
14424: PUSH
14425: LD_INT 47
14427: PUSH
14428: LD_INT 1
14430: PUSH
14431: LD_INT 2
14433: PUSH
14434: LD_INT 11
14436: PUSH
14437: LD_INT 9
14439: PUSH
14440: LD_INT 20
14442: PUSH
14443: LD_INT 19
14445: PUSH
14446: LD_INT 21
14448: PUSH
14449: LD_INT 24
14451: PUSH
14452: LD_INT 22
14454: PUSH
14455: LD_INT 25
14457: PUSH
14458: LD_INT 28
14460: PUSH
14461: LD_INT 29
14463: PUSH
14464: LD_INT 30
14466: PUSH
14467: LD_INT 31
14469: PUSH
14470: LD_INT 37
14472: PUSH
14473: LD_INT 38
14475: PUSH
14476: LD_INT 32
14478: PUSH
14479: LD_INT 27
14481: PUSH
14482: LD_INT 33
14484: PUSH
14485: LD_INT 69
14487: PUSH
14488: LD_INT 39
14490: PUSH
14491: LD_INT 34
14493: PUSH
14494: LD_INT 40
14496: PUSH
14497: LD_INT 71
14499: PUSH
14500: LD_INT 23
14502: PUSH
14503: LD_INT 44
14505: PUSH
14506: LD_INT 48
14508: PUSH
14509: LD_INT 49
14511: PUSH
14512: LD_INT 50
14514: PUSH
14515: LD_INT 51
14517: PUSH
14518: LD_INT 52
14520: PUSH
14521: LD_INT 53
14523: PUSH
14524: LD_INT 54
14526: PUSH
14527: LD_INT 55
14529: PUSH
14530: LD_INT 56
14532: PUSH
14533: LD_INT 57
14535: PUSH
14536: LD_INT 58
14538: PUSH
14539: LD_INT 59
14541: PUSH
14542: LD_INT 63
14544: PUSH
14545: LD_INT 64
14547: PUSH
14548: LD_INT 65
14550: PUSH
14551: EMPTY
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: LIST
14560: LIST
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: LIST
14573: LIST
14574: LIST
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: LIST
14591: LIST
14592: LIST
14593: LIST
14594: LIST
14595: ST_TO_ADDR
14596: GO 14599
14598: POP
// if state > - 1 and state < 3 then
14599: LD_VAR 0 3
14603: PUSH
14604: LD_INT 1
14606: NEG
14607: GREATER
14608: PUSH
14609: LD_VAR 0 3
14613: PUSH
14614: LD_INT 3
14616: LESS
14617: AND
14618: IFFALSE 14675
// for i in result do
14620: LD_ADDR_VAR 0 5
14624: PUSH
14625: LD_VAR 0 4
14629: PUSH
14630: FOR_IN
14631: IFFALSE 14673
// if GetTech ( i , side ) <> state then
14633: LD_VAR 0 5
14637: PPUSH
14638: LD_VAR 0 1
14642: PPUSH
14643: CALL_OW 321
14647: PUSH
14648: LD_VAR 0 3
14652: NONEQUAL
14653: IFFALSE 14671
// result := result diff i ;
14655: LD_ADDR_VAR 0 4
14659: PUSH
14660: LD_VAR 0 4
14664: PUSH
14665: LD_VAR 0 5
14669: DIFF
14670: ST_TO_ADDR
14671: GO 14630
14673: POP
14674: POP
// end ;
14675: LD_VAR 0 4
14679: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14680: LD_INT 0
14682: PPUSH
14683: PPUSH
14684: PPUSH
// result := true ;
14685: LD_ADDR_VAR 0 3
14689: PUSH
14690: LD_INT 1
14692: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14693: LD_ADDR_VAR 0 5
14697: PUSH
14698: LD_VAR 0 2
14702: PPUSH
14703: CALL_OW 480
14707: ST_TO_ADDR
// if not tmp then
14708: LD_VAR 0 5
14712: NOT
14713: IFFALSE 14717
// exit ;
14715: GO 14766
// for i in tmp do
14717: LD_ADDR_VAR 0 4
14721: PUSH
14722: LD_VAR 0 5
14726: PUSH
14727: FOR_IN
14728: IFFALSE 14764
// if GetTech ( i , side ) <> state_researched then
14730: LD_VAR 0 4
14734: PPUSH
14735: LD_VAR 0 1
14739: PPUSH
14740: CALL_OW 321
14744: PUSH
14745: LD_INT 2
14747: NONEQUAL
14748: IFFALSE 14762
// begin result := false ;
14750: LD_ADDR_VAR 0 3
14754: PUSH
14755: LD_INT 0
14757: ST_TO_ADDR
// exit ;
14758: POP
14759: POP
14760: GO 14766
// end ;
14762: GO 14727
14764: POP
14765: POP
// end ;
14766: LD_VAR 0 3
14770: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14771: LD_INT 0
14773: PPUSH
14774: PPUSH
14775: PPUSH
14776: PPUSH
14777: PPUSH
14778: PPUSH
14779: PPUSH
14780: PPUSH
14781: PPUSH
14782: PPUSH
14783: PPUSH
14784: PPUSH
14785: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14786: LD_VAR 0 1
14790: NOT
14791: PUSH
14792: LD_VAR 0 1
14796: PPUSH
14797: CALL_OW 257
14801: PUSH
14802: LD_INT 9
14804: NONEQUAL
14805: OR
14806: IFFALSE 14810
// exit ;
14808: GO 15383
// side := GetSide ( unit ) ;
14810: LD_ADDR_VAR 0 9
14814: PUSH
14815: LD_VAR 0 1
14819: PPUSH
14820: CALL_OW 255
14824: ST_TO_ADDR
// tech_space := tech_spacanom ;
14825: LD_ADDR_VAR 0 12
14829: PUSH
14830: LD_INT 29
14832: ST_TO_ADDR
// tech_time := tech_taurad ;
14833: LD_ADDR_VAR 0 13
14837: PUSH
14838: LD_INT 28
14840: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14841: LD_ADDR_VAR 0 11
14845: PUSH
14846: LD_VAR 0 1
14850: PPUSH
14851: CALL_OW 310
14855: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14856: LD_VAR 0 11
14860: PPUSH
14861: CALL_OW 247
14865: PUSH
14866: LD_INT 2
14868: EQUAL
14869: IFFALSE 14873
// exit ;
14871: GO 15383
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14873: LD_ADDR_VAR 0 8
14877: PUSH
14878: LD_INT 81
14880: PUSH
14881: LD_VAR 0 9
14885: PUSH
14886: EMPTY
14887: LIST
14888: LIST
14889: PUSH
14890: LD_INT 3
14892: PUSH
14893: LD_INT 21
14895: PUSH
14896: LD_INT 3
14898: PUSH
14899: EMPTY
14900: LIST
14901: LIST
14902: PUSH
14903: EMPTY
14904: LIST
14905: LIST
14906: PUSH
14907: EMPTY
14908: LIST
14909: LIST
14910: PPUSH
14911: CALL_OW 69
14915: ST_TO_ADDR
// if not tmp then
14916: LD_VAR 0 8
14920: NOT
14921: IFFALSE 14925
// exit ;
14923: GO 15383
// if in_unit then
14925: LD_VAR 0 11
14929: IFFALSE 14953
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14931: LD_ADDR_VAR 0 10
14935: PUSH
14936: LD_VAR 0 8
14940: PPUSH
14941: LD_VAR 0 11
14945: PPUSH
14946: CALL_OW 74
14950: ST_TO_ADDR
14951: GO 14973
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14953: LD_ADDR_VAR 0 10
14957: PUSH
14958: LD_VAR 0 8
14962: PPUSH
14963: LD_VAR 0 1
14967: PPUSH
14968: CALL_OW 74
14972: ST_TO_ADDR
// if not enemy then
14973: LD_VAR 0 10
14977: NOT
14978: IFFALSE 14982
// exit ;
14980: GO 15383
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14982: LD_VAR 0 11
14986: PUSH
14987: LD_VAR 0 11
14991: PPUSH
14992: LD_VAR 0 10
14996: PPUSH
14997: CALL_OW 296
15001: PUSH
15002: LD_INT 13
15004: GREATER
15005: AND
15006: PUSH
15007: LD_VAR 0 1
15011: PPUSH
15012: LD_VAR 0 10
15016: PPUSH
15017: CALL_OW 296
15021: PUSH
15022: LD_INT 12
15024: GREATER
15025: OR
15026: IFFALSE 15030
// exit ;
15028: GO 15383
// missile := [ 1 ] ;
15030: LD_ADDR_VAR 0 14
15034: PUSH
15035: LD_INT 1
15037: PUSH
15038: EMPTY
15039: LIST
15040: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15041: LD_VAR 0 9
15045: PPUSH
15046: LD_VAR 0 12
15050: PPUSH
15051: CALL_OW 325
15055: IFFALSE 15084
// missile := Insert ( missile , missile + 1 , 2 ) ;
15057: LD_ADDR_VAR 0 14
15061: PUSH
15062: LD_VAR 0 14
15066: PPUSH
15067: LD_VAR 0 14
15071: PUSH
15072: LD_INT 1
15074: PLUS
15075: PPUSH
15076: LD_INT 2
15078: PPUSH
15079: CALL_OW 2
15083: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15084: LD_VAR 0 9
15088: PPUSH
15089: LD_VAR 0 13
15093: PPUSH
15094: CALL_OW 325
15098: PUSH
15099: LD_VAR 0 10
15103: PPUSH
15104: CALL_OW 255
15108: PPUSH
15109: LD_VAR 0 13
15113: PPUSH
15114: CALL_OW 325
15118: NOT
15119: AND
15120: IFFALSE 15149
// missile := Insert ( missile , missile + 1 , 3 ) ;
15122: LD_ADDR_VAR 0 14
15126: PUSH
15127: LD_VAR 0 14
15131: PPUSH
15132: LD_VAR 0 14
15136: PUSH
15137: LD_INT 1
15139: PLUS
15140: PPUSH
15141: LD_INT 3
15143: PPUSH
15144: CALL_OW 2
15148: ST_TO_ADDR
// if missile < 2 then
15149: LD_VAR 0 14
15153: PUSH
15154: LD_INT 2
15156: LESS
15157: IFFALSE 15161
// exit ;
15159: GO 15383
// x := GetX ( enemy ) ;
15161: LD_ADDR_VAR 0 4
15165: PUSH
15166: LD_VAR 0 10
15170: PPUSH
15171: CALL_OW 250
15175: ST_TO_ADDR
// y := GetY ( enemy ) ;
15176: LD_ADDR_VAR 0 5
15180: PUSH
15181: LD_VAR 0 10
15185: PPUSH
15186: CALL_OW 251
15190: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15191: LD_ADDR_VAR 0 6
15195: PUSH
15196: LD_VAR 0 4
15200: PUSH
15201: LD_INT 1
15203: NEG
15204: PPUSH
15205: LD_INT 1
15207: PPUSH
15208: CALL_OW 12
15212: PLUS
15213: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15214: LD_ADDR_VAR 0 7
15218: PUSH
15219: LD_VAR 0 5
15223: PUSH
15224: LD_INT 1
15226: NEG
15227: PPUSH
15228: LD_INT 1
15230: PPUSH
15231: CALL_OW 12
15235: PLUS
15236: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15237: LD_VAR 0 6
15241: PPUSH
15242: LD_VAR 0 7
15246: PPUSH
15247: CALL_OW 488
15251: NOT
15252: IFFALSE 15274
// begin _x := x ;
15254: LD_ADDR_VAR 0 6
15258: PUSH
15259: LD_VAR 0 4
15263: ST_TO_ADDR
// _y := y ;
15264: LD_ADDR_VAR 0 7
15268: PUSH
15269: LD_VAR 0 5
15273: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15274: LD_ADDR_VAR 0 3
15278: PUSH
15279: LD_INT 1
15281: PPUSH
15282: LD_VAR 0 14
15286: PPUSH
15287: CALL_OW 12
15291: ST_TO_ADDR
// case i of 1 :
15292: LD_VAR 0 3
15296: PUSH
15297: LD_INT 1
15299: DOUBLE
15300: EQUAL
15301: IFTRUE 15305
15303: GO 15322
15305: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15306: LD_VAR 0 1
15310: PPUSH
15311: LD_VAR 0 10
15315: PPUSH
15316: CALL_OW 115
15320: GO 15383
15322: LD_INT 2
15324: DOUBLE
15325: EQUAL
15326: IFTRUE 15330
15328: GO 15352
15330: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15331: LD_VAR 0 1
15335: PPUSH
15336: LD_VAR 0 6
15340: PPUSH
15341: LD_VAR 0 7
15345: PPUSH
15346: CALL_OW 153
15350: GO 15383
15352: LD_INT 3
15354: DOUBLE
15355: EQUAL
15356: IFTRUE 15360
15358: GO 15382
15360: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15361: LD_VAR 0 1
15365: PPUSH
15366: LD_VAR 0 6
15370: PPUSH
15371: LD_VAR 0 7
15375: PPUSH
15376: CALL_OW 154
15380: GO 15383
15382: POP
// end ;
15383: LD_VAR 0 2
15387: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15388: LD_INT 0
15390: PPUSH
15391: PPUSH
15392: PPUSH
15393: PPUSH
15394: PPUSH
15395: PPUSH
// if not unit or not building then
15396: LD_VAR 0 1
15400: NOT
15401: PUSH
15402: LD_VAR 0 2
15406: NOT
15407: OR
15408: IFFALSE 15412
// exit ;
15410: GO 15570
// x := GetX ( building ) ;
15412: LD_ADDR_VAR 0 5
15416: PUSH
15417: LD_VAR 0 2
15421: PPUSH
15422: CALL_OW 250
15426: ST_TO_ADDR
// y := GetY ( building ) ;
15427: LD_ADDR_VAR 0 6
15431: PUSH
15432: LD_VAR 0 2
15436: PPUSH
15437: CALL_OW 251
15441: ST_TO_ADDR
// for i = 0 to 5 do
15442: LD_ADDR_VAR 0 4
15446: PUSH
15447: DOUBLE
15448: LD_INT 0
15450: DEC
15451: ST_TO_ADDR
15452: LD_INT 5
15454: PUSH
15455: FOR_TO
15456: IFFALSE 15568
// begin _x := ShiftX ( x , i , 3 ) ;
15458: LD_ADDR_VAR 0 7
15462: PUSH
15463: LD_VAR 0 5
15467: PPUSH
15468: LD_VAR 0 4
15472: PPUSH
15473: LD_INT 3
15475: PPUSH
15476: CALL_OW 272
15480: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15481: LD_ADDR_VAR 0 8
15485: PUSH
15486: LD_VAR 0 6
15490: PPUSH
15491: LD_VAR 0 4
15495: PPUSH
15496: LD_INT 3
15498: PPUSH
15499: CALL_OW 273
15503: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15504: LD_VAR 0 7
15508: PPUSH
15509: LD_VAR 0 8
15513: PPUSH
15514: CALL_OW 488
15518: NOT
15519: IFFALSE 15523
// continue ;
15521: GO 15455
// if HexInfo ( _x , _y ) = 0 then
15523: LD_VAR 0 7
15527: PPUSH
15528: LD_VAR 0 8
15532: PPUSH
15533: CALL_OW 428
15537: PUSH
15538: LD_INT 0
15540: EQUAL
15541: IFFALSE 15566
// begin ComMoveXY ( unit , _x , _y ) ;
15543: LD_VAR 0 1
15547: PPUSH
15548: LD_VAR 0 7
15552: PPUSH
15553: LD_VAR 0 8
15557: PPUSH
15558: CALL_OW 111
// exit ;
15562: POP
15563: POP
15564: GO 15570
// end ; end ;
15566: GO 15455
15568: POP
15569: POP
// end ;
15570: LD_VAR 0 3
15574: RET
// export function ScanBase ( side , base_area ) ; begin
15575: LD_INT 0
15577: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15578: LD_ADDR_VAR 0 3
15582: PUSH
15583: LD_VAR 0 2
15587: PPUSH
15588: LD_INT 81
15590: PUSH
15591: LD_VAR 0 1
15595: PUSH
15596: EMPTY
15597: LIST
15598: LIST
15599: PPUSH
15600: CALL_OW 70
15604: ST_TO_ADDR
// end ;
15605: LD_VAR 0 3
15609: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15610: LD_INT 0
15612: PPUSH
15613: PPUSH
15614: PPUSH
15615: PPUSH
15616: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15617: LD_VAR 0 1
15621: NOT
15622: PUSH
15623: LD_EXP 58
15627: PUSH
15628: LD_VAR 0 1
15632: ARRAY
15633: NOT
15634: OR
15635: PUSH
15636: LD_VAR 0 2
15640: NOT
15641: OR
15642: PUSH
15643: LD_VAR 0 3
15647: NOT
15648: OR
15649: IFFALSE 15653
// exit ;
15651: GO 16103
// side := mc_sides [ base ] ;
15653: LD_ADDR_VAR 0 6
15657: PUSH
15658: LD_EXP 84
15662: PUSH
15663: LD_VAR 0 1
15667: ARRAY
15668: ST_TO_ADDR
// if not side then
15669: LD_VAR 0 6
15673: NOT
15674: IFFALSE 15678
// exit ;
15676: GO 16103
// for i in solds do
15678: LD_ADDR_VAR 0 7
15682: PUSH
15683: LD_VAR 0 2
15687: PUSH
15688: FOR_IN
15689: IFFALSE 15750
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15691: LD_VAR 0 7
15695: PPUSH
15696: CALL_OW 310
15700: PPUSH
15701: CALL_OW 266
15705: PUSH
15706: LD_INT 32
15708: PUSH
15709: LD_INT 31
15711: PUSH
15712: EMPTY
15713: LIST
15714: LIST
15715: IN
15716: IFFALSE 15736
// solds := solds diff i else
15718: LD_ADDR_VAR 0 2
15722: PUSH
15723: LD_VAR 0 2
15727: PUSH
15728: LD_VAR 0 7
15732: DIFF
15733: ST_TO_ADDR
15734: GO 15748
// SetTag ( i , 18 ) ;
15736: LD_VAR 0 7
15740: PPUSH
15741: LD_INT 18
15743: PPUSH
15744: CALL_OW 109
15748: GO 15688
15750: POP
15751: POP
// if not solds then
15752: LD_VAR 0 2
15756: NOT
15757: IFFALSE 15761
// exit ;
15759: GO 16103
// repeat wait ( 0 0$1 ) ;
15761: LD_INT 35
15763: PPUSH
15764: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15768: LD_ADDR_VAR 0 5
15772: PUSH
15773: LD_VAR 0 6
15777: PPUSH
15778: LD_VAR 0 3
15782: PPUSH
15783: CALL 15575 0 2
15787: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
15788: LD_VAR 0 5
15792: NOT
15793: PUSH
15794: LD_VAR 0 5
15798: PUSH
15799: LD_INT 3
15801: GREATER
15802: OR
15803: PUSH
15804: LD_EXP 80
15808: PUSH
15809: LD_VAR 0 1
15813: ARRAY
15814: OR
15815: IFFALSE 15856
// begin for i in solds do
15817: LD_ADDR_VAR 0 7
15821: PUSH
15822: LD_VAR 0 2
15826: PUSH
15827: FOR_IN
15828: IFFALSE 15852
// if HasTask ( i ) then
15830: LD_VAR 0 7
15834: PPUSH
15835: CALL_OW 314
15839: IFFALSE 15850
// ComStop ( i ) ;
15841: LD_VAR 0 7
15845: PPUSH
15846: CALL_OW 141
15850: GO 15827
15852: POP
15853: POP
// break ;
15854: GO 16091
// end ; for i in solds do
15856: LD_ADDR_VAR 0 7
15860: PUSH
15861: LD_VAR 0 2
15865: PUSH
15866: FOR_IN
15867: IFFALSE 16083
// begin if IsInUnit ( i ) then
15869: LD_VAR 0 7
15873: PPUSH
15874: CALL_OW 310
15878: IFFALSE 15889
// ComExitBuilding ( i ) ;
15880: LD_VAR 0 7
15884: PPUSH
15885: CALL_OW 122
// if GetLives ( i ) > 333 then
15889: LD_VAR 0 7
15893: PPUSH
15894: CALL_OW 256
15898: PUSH
15899: LD_INT 333
15901: GREATER
15902: IFFALSE 15930
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15904: LD_VAR 0 7
15908: PPUSH
15909: LD_VAR 0 5
15913: PPUSH
15914: LD_VAR 0 7
15918: PPUSH
15919: CALL_OW 74
15923: PPUSH
15924: CALL_OW 115
15928: GO 16081
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
15930: LD_ADDR_VAR 0 8
15934: PUSH
15935: LD_EXP 58
15939: PUSH
15940: LD_VAR 0 1
15944: ARRAY
15945: PPUSH
15946: LD_INT 2
15948: PUSH
15949: LD_INT 30
15951: PUSH
15952: LD_INT 0
15954: PUSH
15955: EMPTY
15956: LIST
15957: LIST
15958: PUSH
15959: LD_INT 30
15961: PUSH
15962: LD_INT 1
15964: PUSH
15965: EMPTY
15966: LIST
15967: LIST
15968: PUSH
15969: LD_INT 30
15971: PUSH
15972: LD_INT 6
15974: PUSH
15975: EMPTY
15976: LIST
15977: LIST
15978: PUSH
15979: EMPTY
15980: LIST
15981: LIST
15982: LIST
15983: LIST
15984: PPUSH
15985: CALL_OW 72
15989: PPUSH
15990: LD_VAR 0 7
15994: PPUSH
15995: CALL_OW 74
15999: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
16000: LD_VAR 0 7
16004: PPUSH
16005: LD_VAR 0 8
16009: PPUSH
16010: CALL_OW 250
16014: PPUSH
16015: LD_INT 3
16017: PPUSH
16018: LD_INT 5
16020: PPUSH
16021: CALL_OW 272
16025: PPUSH
16026: LD_VAR 0 8
16030: PPUSH
16031: CALL_OW 251
16035: PPUSH
16036: LD_INT 3
16038: PPUSH
16039: LD_INT 5
16041: PPUSH
16042: CALL_OW 273
16046: PPUSH
16047: CALL_OW 111
// SetTag ( i , 0 ) ;
16051: LD_VAR 0 7
16055: PPUSH
16056: LD_INT 0
16058: PPUSH
16059: CALL_OW 109
// solds := solds diff i ;
16063: LD_ADDR_VAR 0 2
16067: PUSH
16068: LD_VAR 0 2
16072: PUSH
16073: LD_VAR 0 7
16077: DIFF
16078: ST_TO_ADDR
// continue ;
16079: GO 15866
// end ; end ;
16081: GO 15866
16083: POP
16084: POP
// until solds ;
16085: LD_VAR 0 2
16089: IFFALSE 15761
// MC_Reset ( base , 18 ) ;
16091: LD_VAR 0 1
16095: PPUSH
16096: LD_INT 18
16098: PPUSH
16099: CALL 60739 0 2
// end ;
16103: LD_VAR 0 4
16107: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16108: LD_INT 0
16110: PPUSH
16111: PPUSH
16112: PPUSH
16113: PPUSH
16114: PPUSH
16115: PPUSH
16116: PPUSH
16117: PPUSH
16118: PPUSH
16119: PPUSH
16120: PPUSH
16121: PPUSH
16122: PPUSH
16123: PPUSH
16124: PPUSH
16125: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16126: LD_ADDR_VAR 0 12
16130: PUSH
16131: LD_EXP 58
16135: PUSH
16136: LD_VAR 0 1
16140: ARRAY
16141: PPUSH
16142: LD_INT 25
16144: PUSH
16145: LD_INT 3
16147: PUSH
16148: EMPTY
16149: LIST
16150: LIST
16151: PPUSH
16152: CALL_OW 72
16156: ST_TO_ADDR
// if mc_remote_driver [ base ] then
16157: LD_EXP 98
16161: PUSH
16162: LD_VAR 0 1
16166: ARRAY
16167: IFFALSE 16191
// mechs := mechs diff mc_remote_driver [ base ] ;
16169: LD_ADDR_VAR 0 12
16173: PUSH
16174: LD_VAR 0 12
16178: PUSH
16179: LD_EXP 98
16183: PUSH
16184: LD_VAR 0 1
16188: ARRAY
16189: DIFF
16190: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16191: LD_ADDR_VAR 0 8
16195: PUSH
16196: LD_EXP 58
16200: PUSH
16201: LD_VAR 0 1
16205: ARRAY
16206: PPUSH
16207: LD_INT 2
16209: PUSH
16210: LD_INT 25
16212: PUSH
16213: LD_INT 1
16215: PUSH
16216: EMPTY
16217: LIST
16218: LIST
16219: PUSH
16220: LD_INT 25
16222: PUSH
16223: LD_INT 5
16225: PUSH
16226: EMPTY
16227: LIST
16228: LIST
16229: PUSH
16230: LD_INT 25
16232: PUSH
16233: LD_INT 8
16235: PUSH
16236: EMPTY
16237: LIST
16238: LIST
16239: PUSH
16240: LD_INT 25
16242: PUSH
16243: LD_INT 9
16245: PUSH
16246: EMPTY
16247: LIST
16248: LIST
16249: PUSH
16250: EMPTY
16251: LIST
16252: LIST
16253: LIST
16254: LIST
16255: LIST
16256: PPUSH
16257: CALL_OW 72
16261: ST_TO_ADDR
// if not defenders and not solds then
16262: LD_VAR 0 2
16266: NOT
16267: PUSH
16268: LD_VAR 0 8
16272: NOT
16273: AND
16274: IFFALSE 16278
// exit ;
16276: GO 17652
// depot_under_attack := false ;
16278: LD_ADDR_VAR 0 16
16282: PUSH
16283: LD_INT 0
16285: ST_TO_ADDR
// sold_defenders := [ ] ;
16286: LD_ADDR_VAR 0 17
16290: PUSH
16291: EMPTY
16292: ST_TO_ADDR
// if mechs then
16293: LD_VAR 0 12
16297: IFFALSE 16426
// for i in defenders do
16299: LD_ADDR_VAR 0 5
16303: PUSH
16304: LD_VAR 0 2
16308: PUSH
16309: FOR_IN
16310: IFFALSE 16424
// begin SetTag ( i , 20 ) ;
16312: LD_VAR 0 5
16316: PPUSH
16317: LD_INT 20
16319: PPUSH
16320: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16324: LD_VAR 0 5
16328: PPUSH
16329: CALL_OW 263
16333: PUSH
16334: LD_INT 1
16336: EQUAL
16337: PUSH
16338: LD_VAR 0 5
16342: PPUSH
16343: CALL_OW 311
16347: NOT
16348: AND
16349: PUSH
16350: LD_VAR 0 12
16354: AND
16355: IFFALSE 16422
// begin un := mechs [ 1 ] ;
16357: LD_ADDR_VAR 0 10
16361: PUSH
16362: LD_VAR 0 12
16366: PUSH
16367: LD_INT 1
16369: ARRAY
16370: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16371: LD_VAR 0 10
16375: PPUSH
16376: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16380: LD_VAR 0 10
16384: PPUSH
16385: LD_VAR 0 5
16389: PPUSH
16390: CALL_OW 180
// SetTag ( un , 19 ) ;
16394: LD_VAR 0 10
16398: PPUSH
16399: LD_INT 19
16401: PPUSH
16402: CALL_OW 109
// mechs := mechs diff un ;
16406: LD_ADDR_VAR 0 12
16410: PUSH
16411: LD_VAR 0 12
16415: PUSH
16416: LD_VAR 0 10
16420: DIFF
16421: ST_TO_ADDR
// end ; end ;
16422: GO 16309
16424: POP
16425: POP
// if solds then
16426: LD_VAR 0 8
16430: IFFALSE 16489
// for i in solds do
16432: LD_ADDR_VAR 0 5
16436: PUSH
16437: LD_VAR 0 8
16441: PUSH
16442: FOR_IN
16443: IFFALSE 16487
// if not GetTag ( i ) then
16445: LD_VAR 0 5
16449: PPUSH
16450: CALL_OW 110
16454: NOT
16455: IFFALSE 16485
// begin defenders := defenders union i ;
16457: LD_ADDR_VAR 0 2
16461: PUSH
16462: LD_VAR 0 2
16466: PUSH
16467: LD_VAR 0 5
16471: UNION
16472: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16473: LD_VAR 0 5
16477: PPUSH
16478: LD_INT 18
16480: PPUSH
16481: CALL_OW 109
// end ;
16485: GO 16442
16487: POP
16488: POP
// repeat wait ( 0 0$1 ) ;
16489: LD_INT 35
16491: PPUSH
16492: CALL_OW 67
// enemy := mc_scan [ base ] ;
16496: LD_ADDR_VAR 0 3
16500: PUSH
16501: LD_EXP 81
16505: PUSH
16506: LD_VAR 0 1
16510: ARRAY
16511: ST_TO_ADDR
// for i in defenders do
16512: LD_ADDR_VAR 0 5
16516: PUSH
16517: LD_VAR 0 2
16521: PUSH
16522: FOR_IN
16523: IFFALSE 17253
// begin e := NearestUnitToUnit ( enemy , i ) ;
16525: LD_ADDR_VAR 0 13
16529: PUSH
16530: LD_VAR 0 3
16534: PPUSH
16535: LD_VAR 0 5
16539: PPUSH
16540: CALL_OW 74
16544: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
16545: LD_ADDR_VAR 0 16
16549: PUSH
16550: LD_EXP 58
16554: PUSH
16555: LD_VAR 0 1
16559: ARRAY
16560: PPUSH
16561: LD_INT 2
16563: PUSH
16564: LD_INT 30
16566: PUSH
16567: LD_INT 0
16569: PUSH
16570: EMPTY
16571: LIST
16572: LIST
16573: PUSH
16574: LD_INT 30
16576: PUSH
16577: LD_INT 1
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: PUSH
16584: EMPTY
16585: LIST
16586: LIST
16587: LIST
16588: PPUSH
16589: CALL_OW 72
16593: NOT
16594: PUSH
16595: LD_EXP 58
16599: PUSH
16600: LD_VAR 0 1
16604: ARRAY
16605: PPUSH
16606: LD_INT 2
16608: PUSH
16609: LD_INT 30
16611: PUSH
16612: LD_INT 0
16614: PUSH
16615: EMPTY
16616: LIST
16617: LIST
16618: PUSH
16619: LD_INT 30
16621: PUSH
16622: LD_INT 1
16624: PUSH
16625: EMPTY
16626: LIST
16627: LIST
16628: PUSH
16629: EMPTY
16630: LIST
16631: LIST
16632: LIST
16633: PPUSH
16634: CALL_OW 72
16638: PPUSH
16639: CALL_OW 256
16643: PUSH
16644: LD_INT 600
16646: LESS
16647: OR
16648: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
16649: LD_VAR 0 5
16653: PPUSH
16654: CALL_OW 247
16658: PUSH
16659: LD_INT 2
16661: DOUBLE
16662: EQUAL
16663: IFTRUE 16667
16665: GO 16959
16667: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
16668: LD_VAR 0 5
16672: PPUSH
16673: CALL_OW 256
16677: PUSH
16678: LD_INT 650
16680: GREATER
16681: PUSH
16682: LD_VAR 0 5
16686: PPUSH
16687: LD_VAR 0 13
16691: PPUSH
16692: CALL_OW 296
16696: PUSH
16697: LD_INT 40
16699: LESS
16700: PUSH
16701: LD_VAR 0 13
16705: PPUSH
16706: LD_EXP 83
16710: PUSH
16711: LD_VAR 0 1
16715: ARRAY
16716: PPUSH
16717: CALL_OW 308
16721: OR
16722: AND
16723: IFFALSE 16741
// ComAttackUnit ( i , e ) else
16725: LD_VAR 0 5
16729: PPUSH
16730: LD_VAR 0 13
16734: PPUSH
16735: CALL_OW 115
16739: GO 16842
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
16741: LD_VAR 0 13
16745: PPUSH
16746: LD_EXP 83
16750: PUSH
16751: LD_VAR 0 1
16755: ARRAY
16756: PPUSH
16757: CALL_OW 308
16761: NOT
16762: PUSH
16763: LD_VAR 0 5
16767: PPUSH
16768: LD_VAR 0 13
16772: PPUSH
16773: CALL_OW 296
16777: PUSH
16778: LD_INT 40
16780: GREATEREQUAL
16781: AND
16782: PUSH
16783: LD_VAR 0 5
16787: PPUSH
16788: CALL_OW 256
16792: PUSH
16793: LD_INT 650
16795: LESSEQUAL
16796: OR
16797: PUSH
16798: LD_VAR 0 5
16802: PPUSH
16803: LD_EXP 82
16807: PUSH
16808: LD_VAR 0 1
16812: ARRAY
16813: PPUSH
16814: CALL_OW 308
16818: NOT
16819: AND
16820: IFFALSE 16842
// ComMoveToArea ( i , mc_parking [ base ] ) ;
16822: LD_VAR 0 5
16826: PPUSH
16827: LD_EXP 82
16831: PUSH
16832: LD_VAR 0 1
16836: ARRAY
16837: PPUSH
16838: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
16842: LD_VAR 0 5
16846: PPUSH
16847: CALL_OW 256
16851: PUSH
16852: LD_INT 998
16854: LESS
16855: PUSH
16856: LD_VAR 0 5
16860: PPUSH
16861: CALL_OW 263
16865: PUSH
16866: LD_INT 1
16868: EQUAL
16869: AND
16870: PUSH
16871: LD_VAR 0 5
16875: PPUSH
16876: CALL_OW 311
16880: AND
16881: PUSH
16882: LD_VAR 0 5
16886: PPUSH
16887: LD_EXP 82
16891: PUSH
16892: LD_VAR 0 1
16896: ARRAY
16897: PPUSH
16898: CALL_OW 308
16902: AND
16903: IFFALSE 16957
// begin mech := IsDrivenBy ( i ) ;
16905: LD_ADDR_VAR 0 9
16909: PUSH
16910: LD_VAR 0 5
16914: PPUSH
16915: CALL_OW 311
16919: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
16920: LD_VAR 0 9
16924: PPUSH
16925: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
16929: LD_VAR 0 9
16933: PPUSH
16934: LD_VAR 0 5
16938: PPUSH
16939: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
16943: LD_VAR 0 9
16947: PPUSH
16948: LD_VAR 0 5
16952: PPUSH
16953: CALL_OW 180
// end ; end ; unit_human :
16957: GO 17224
16959: LD_INT 1
16961: DOUBLE
16962: EQUAL
16963: IFTRUE 16967
16965: GO 17223
16967: POP
// begin b := IsInUnit ( i ) ;
16968: LD_ADDR_VAR 0 18
16972: PUSH
16973: LD_VAR 0 5
16977: PPUSH
16978: CALL_OW 310
16982: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
16983: LD_ADDR_VAR 0 19
16987: PUSH
16988: LD_VAR 0 18
16992: NOT
16993: PUSH
16994: LD_VAR 0 18
16998: PPUSH
16999: CALL_OW 266
17003: PUSH
17004: LD_INT 32
17006: PUSH
17007: LD_INT 31
17009: PUSH
17010: EMPTY
17011: LIST
17012: LIST
17013: IN
17014: OR
17015: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
17016: LD_VAR 0 16
17020: PUSH
17021: LD_VAR 0 2
17025: PPUSH
17026: LD_INT 21
17028: PUSH
17029: LD_INT 2
17031: PUSH
17032: EMPTY
17033: LIST
17034: LIST
17035: PPUSH
17036: CALL_OW 72
17040: PUSH
17041: LD_INT 1
17043: LESSEQUAL
17044: OR
17045: PUSH
17046: LD_VAR 0 19
17050: AND
17051: PUSH
17052: LD_VAR 0 5
17056: PUSH
17057: LD_VAR 0 17
17061: IN
17062: NOT
17063: AND
17064: IFFALSE 17157
// begin if b then
17066: LD_VAR 0 18
17070: IFFALSE 17119
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
17072: LD_VAR 0 18
17076: PPUSH
17077: LD_VAR 0 3
17081: PPUSH
17082: LD_VAR 0 18
17086: PPUSH
17087: CALL_OW 74
17091: PPUSH
17092: CALL_OW 296
17096: PUSH
17097: LD_INT 10
17099: LESS
17100: PUSH
17101: LD_VAR 0 18
17105: PPUSH
17106: CALL_OW 461
17110: PUSH
17111: LD_INT 7
17113: NONEQUAL
17114: AND
17115: IFFALSE 17119
// continue ;
17117: GO 16522
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
17119: LD_ADDR_VAR 0 17
17123: PUSH
17124: LD_VAR 0 17
17128: PPUSH
17129: LD_VAR 0 17
17133: PUSH
17134: LD_INT 1
17136: PLUS
17137: PPUSH
17138: LD_VAR 0 5
17142: PPUSH
17143: CALL_OW 1
17147: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17148: LD_VAR 0 5
17152: PPUSH
17153: CALL_OW 122
// end ; if sold_defenders then
17157: LD_VAR 0 17
17161: IFFALSE 17221
// if i in sold_defenders then
17163: LD_VAR 0 5
17167: PUSH
17168: LD_VAR 0 17
17172: IN
17173: IFFALSE 17221
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17175: LD_VAR 0 5
17179: PPUSH
17180: CALL_OW 314
17184: NOT
17185: PUSH
17186: LD_VAR 0 5
17190: PPUSH
17191: LD_VAR 0 13
17195: PPUSH
17196: CALL_OW 296
17200: PUSH
17201: LD_INT 30
17203: LESS
17204: AND
17205: IFFALSE 17221
// ComAttackUnit ( i , e ) ;
17207: LD_VAR 0 5
17211: PPUSH
17212: LD_VAR 0 13
17216: PPUSH
17217: CALL_OW 115
// end ; end ; end ;
17221: GO 17224
17223: POP
// if IsDead ( i ) then
17224: LD_VAR 0 5
17228: PPUSH
17229: CALL_OW 301
17233: IFFALSE 17251
// defenders := defenders diff i ;
17235: LD_ADDR_VAR 0 2
17239: PUSH
17240: LD_VAR 0 2
17244: PUSH
17245: LD_VAR 0 5
17249: DIFF
17250: ST_TO_ADDR
// end ;
17251: GO 16522
17253: POP
17254: POP
// until not enemy or not defenders ;
17255: LD_VAR 0 3
17259: NOT
17260: PUSH
17261: LD_VAR 0 2
17265: NOT
17266: OR
17267: IFFALSE 16489
// MC_Reset ( base , 18 ) ;
17269: LD_VAR 0 1
17273: PPUSH
17274: LD_INT 18
17276: PPUSH
17277: CALL 60739 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17281: LD_ADDR_VAR 0 2
17285: PUSH
17286: LD_VAR 0 2
17290: PUSH
17291: LD_VAR 0 2
17295: PPUSH
17296: LD_INT 2
17298: PUSH
17299: LD_INT 25
17301: PUSH
17302: LD_INT 1
17304: PUSH
17305: EMPTY
17306: LIST
17307: LIST
17308: PUSH
17309: LD_INT 25
17311: PUSH
17312: LD_INT 5
17314: PUSH
17315: EMPTY
17316: LIST
17317: LIST
17318: PUSH
17319: LD_INT 25
17321: PUSH
17322: LD_INT 8
17324: PUSH
17325: EMPTY
17326: LIST
17327: LIST
17328: PUSH
17329: LD_INT 25
17331: PUSH
17332: LD_INT 9
17334: PUSH
17335: EMPTY
17336: LIST
17337: LIST
17338: PUSH
17339: EMPTY
17340: LIST
17341: LIST
17342: LIST
17343: LIST
17344: LIST
17345: PPUSH
17346: CALL_OW 72
17350: DIFF
17351: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17352: LD_VAR 0 3
17356: NOT
17357: PUSH
17358: LD_VAR 0 2
17362: PPUSH
17363: LD_INT 21
17365: PUSH
17366: LD_INT 2
17368: PUSH
17369: EMPTY
17370: LIST
17371: LIST
17372: PPUSH
17373: CALL_OW 72
17377: AND
17378: IFFALSE 17640
// begin tmp := FilterByTag ( defenders , 19 ) ;
17380: LD_ADDR_VAR 0 11
17384: PUSH
17385: LD_VAR 0 2
17389: PPUSH
17390: LD_INT 19
17392: PPUSH
17393: CALL 54081 0 2
17397: ST_TO_ADDR
// if tmp then
17398: LD_VAR 0 11
17402: IFFALSE 17472
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
17404: LD_ADDR_VAR 0 11
17408: PUSH
17409: LD_VAR 0 11
17413: PPUSH
17414: LD_INT 25
17416: PUSH
17417: LD_INT 3
17419: PUSH
17420: EMPTY
17421: LIST
17422: LIST
17423: PPUSH
17424: CALL_OW 72
17428: ST_TO_ADDR
// if tmp then
17429: LD_VAR 0 11
17433: IFFALSE 17472
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
17435: LD_ADDR_EXP 70
17439: PUSH
17440: LD_EXP 70
17444: PPUSH
17445: LD_VAR 0 1
17449: PPUSH
17450: LD_EXP 70
17454: PUSH
17455: LD_VAR 0 1
17459: ARRAY
17460: PUSH
17461: LD_VAR 0 11
17465: UNION
17466: PPUSH
17467: CALL_OW 1
17471: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
17472: LD_VAR 0 1
17476: PPUSH
17477: LD_INT 19
17479: PPUSH
17480: CALL 60739 0 2
// repeat wait ( 0 0$1 ) ;
17484: LD_INT 35
17486: PPUSH
17487: CALL_OW 67
// for i in defenders do
17491: LD_ADDR_VAR 0 5
17495: PUSH
17496: LD_VAR 0 2
17500: PUSH
17501: FOR_IN
17502: IFFALSE 17591
// begin if not IsInArea ( i , mc_parking [ base ] ) then
17504: LD_VAR 0 5
17508: PPUSH
17509: LD_EXP 82
17513: PUSH
17514: LD_VAR 0 1
17518: ARRAY
17519: PPUSH
17520: CALL_OW 308
17524: NOT
17525: IFFALSE 17549
// ComMoveToArea ( i , mc_parking [ base ] ) else
17527: LD_VAR 0 5
17531: PPUSH
17532: LD_EXP 82
17536: PUSH
17537: LD_VAR 0 1
17541: ARRAY
17542: PPUSH
17543: CALL_OW 113
17547: GO 17589
// if GetControl ( i ) = control_manual then
17549: LD_VAR 0 5
17553: PPUSH
17554: CALL_OW 263
17558: PUSH
17559: LD_INT 1
17561: EQUAL
17562: IFFALSE 17589
// if IsDrivenBy ( i ) then
17564: LD_VAR 0 5
17568: PPUSH
17569: CALL_OW 311
17573: IFFALSE 17589
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
17575: LD_VAR 0 5
17579: PPUSH
17580: CALL_OW 311
17584: PPUSH
17585: CALL_OW 121
// end ;
17589: GO 17501
17591: POP
17592: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
17593: LD_VAR 0 2
17597: PPUSH
17598: LD_INT 95
17600: PUSH
17601: LD_EXP 82
17605: PUSH
17606: LD_VAR 0 1
17610: ARRAY
17611: PUSH
17612: EMPTY
17613: LIST
17614: LIST
17615: PPUSH
17616: CALL_OW 72
17620: PUSH
17621: LD_VAR 0 2
17625: EQUAL
17626: PUSH
17627: LD_EXP 81
17631: PUSH
17632: LD_VAR 0 1
17636: ARRAY
17637: OR
17638: IFFALSE 17484
// end ; MC_Reset ( base , 20 ) ;
17640: LD_VAR 0 1
17644: PPUSH
17645: LD_INT 20
17647: PPUSH
17648: CALL 60739 0 2
// end ;
17652: LD_VAR 0 4
17656: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17657: LD_INT 0
17659: PPUSH
17660: PPUSH
17661: PPUSH
17662: PPUSH
// result := false ;
17663: LD_ADDR_VAR 0 2
17667: PUSH
17668: LD_INT 0
17670: ST_TO_ADDR
// side := GetSide ( unit ) ;
17671: LD_ADDR_VAR 0 3
17675: PUSH
17676: LD_VAR 0 1
17680: PPUSH
17681: CALL_OW 255
17685: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17686: LD_ADDR_VAR 0 4
17690: PUSH
17691: LD_VAR 0 1
17695: PPUSH
17696: CALL_OW 248
17700: ST_TO_ADDR
// case nat of 1 :
17701: LD_VAR 0 4
17705: PUSH
17706: LD_INT 1
17708: DOUBLE
17709: EQUAL
17710: IFTRUE 17714
17712: GO 17725
17714: POP
// tech := tech_lassight ; 2 :
17715: LD_ADDR_VAR 0 5
17719: PUSH
17720: LD_INT 12
17722: ST_TO_ADDR
17723: GO 17764
17725: LD_INT 2
17727: DOUBLE
17728: EQUAL
17729: IFTRUE 17733
17731: GO 17744
17733: POP
// tech := tech_mortar ; 3 :
17734: LD_ADDR_VAR 0 5
17738: PUSH
17739: LD_INT 41
17741: ST_TO_ADDR
17742: GO 17764
17744: LD_INT 3
17746: DOUBLE
17747: EQUAL
17748: IFTRUE 17752
17750: GO 17763
17752: POP
// tech := tech_bazooka ; end ;
17753: LD_ADDR_VAR 0 5
17757: PUSH
17758: LD_INT 44
17760: ST_TO_ADDR
17761: GO 17764
17763: POP
// if Researched ( side , tech ) then
17764: LD_VAR 0 3
17768: PPUSH
17769: LD_VAR 0 5
17773: PPUSH
17774: CALL_OW 325
17778: IFFALSE 17805
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17780: LD_ADDR_VAR 0 2
17784: PUSH
17785: LD_INT 5
17787: PUSH
17788: LD_INT 8
17790: PUSH
17791: LD_INT 9
17793: PUSH
17794: EMPTY
17795: LIST
17796: LIST
17797: LIST
17798: PUSH
17799: LD_VAR 0 4
17803: ARRAY
17804: ST_TO_ADDR
// end ;
17805: LD_VAR 0 2
17809: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17810: LD_INT 0
17812: PPUSH
17813: PPUSH
17814: PPUSH
// if not mines then
17815: LD_VAR 0 2
17819: NOT
17820: IFFALSE 17824
// exit ;
17822: GO 17968
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17824: LD_ADDR_VAR 0 5
17828: PUSH
17829: LD_INT 81
17831: PUSH
17832: LD_VAR 0 1
17836: PUSH
17837: EMPTY
17838: LIST
17839: LIST
17840: PUSH
17841: LD_INT 3
17843: PUSH
17844: LD_INT 21
17846: PUSH
17847: LD_INT 3
17849: PUSH
17850: EMPTY
17851: LIST
17852: LIST
17853: PUSH
17854: EMPTY
17855: LIST
17856: LIST
17857: PUSH
17858: EMPTY
17859: LIST
17860: LIST
17861: PPUSH
17862: CALL_OW 69
17866: ST_TO_ADDR
// for i in mines do
17867: LD_ADDR_VAR 0 4
17871: PUSH
17872: LD_VAR 0 2
17876: PUSH
17877: FOR_IN
17878: IFFALSE 17966
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
17880: LD_VAR 0 4
17884: PUSH
17885: LD_INT 1
17887: ARRAY
17888: PPUSH
17889: LD_VAR 0 4
17893: PUSH
17894: LD_INT 2
17896: ARRAY
17897: PPUSH
17898: CALL_OW 458
17902: NOT
17903: IFFALSE 17907
// continue ;
17905: GO 17877
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
17907: LD_VAR 0 4
17911: PUSH
17912: LD_INT 1
17914: ARRAY
17915: PPUSH
17916: LD_VAR 0 4
17920: PUSH
17921: LD_INT 2
17923: ARRAY
17924: PPUSH
17925: CALL_OW 428
17929: PUSH
17930: LD_VAR 0 5
17934: IN
17935: IFFALSE 17964
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17937: LD_VAR 0 4
17941: PUSH
17942: LD_INT 1
17944: ARRAY
17945: PPUSH
17946: LD_VAR 0 4
17950: PUSH
17951: LD_INT 2
17953: ARRAY
17954: PPUSH
17955: LD_VAR 0 1
17959: PPUSH
17960: CALL_OW 456
// end ;
17964: GO 17877
17966: POP
17967: POP
// end ;
17968: LD_VAR 0 3
17972: RET
// export function Count ( array ) ; var i ; begin
17973: LD_INT 0
17975: PPUSH
17976: PPUSH
// result := 0 ;
17977: LD_ADDR_VAR 0 2
17981: PUSH
17982: LD_INT 0
17984: ST_TO_ADDR
// for i in array do
17985: LD_ADDR_VAR 0 3
17989: PUSH
17990: LD_VAR 0 1
17994: PUSH
17995: FOR_IN
17996: IFFALSE 18020
// if i then
17998: LD_VAR 0 3
18002: IFFALSE 18018
// result := result + 1 ;
18004: LD_ADDR_VAR 0 2
18008: PUSH
18009: LD_VAR 0 2
18013: PUSH
18014: LD_INT 1
18016: PLUS
18017: ST_TO_ADDR
18018: GO 17995
18020: POP
18021: POP
// end ;
18022: LD_VAR 0 2
18026: RET
// export function IsEmpty ( building ) ; begin
18027: LD_INT 0
18029: PPUSH
// if not building then
18030: LD_VAR 0 1
18034: NOT
18035: IFFALSE 18039
// exit ;
18037: GO 18082
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18039: LD_ADDR_VAR 0 2
18043: PUSH
18044: LD_VAR 0 1
18048: PUSH
18049: LD_INT 22
18051: PUSH
18052: LD_VAR 0 1
18056: PPUSH
18057: CALL_OW 255
18061: PUSH
18062: EMPTY
18063: LIST
18064: LIST
18065: PUSH
18066: LD_INT 58
18068: PUSH
18069: EMPTY
18070: LIST
18071: PUSH
18072: EMPTY
18073: LIST
18074: LIST
18075: PPUSH
18076: CALL_OW 69
18080: IN
18081: ST_TO_ADDR
// end ;
18082: LD_VAR 0 2
18086: RET
// export function IsNotFull ( building ) ; begin
18087: LD_INT 0
18089: PPUSH
// if not building then
18090: LD_VAR 0 1
18094: NOT
18095: IFFALSE 18099
// exit ;
18097: GO 18118
// result := UnitsInside ( building ) < 6 ;
18099: LD_ADDR_VAR 0 2
18103: PUSH
18104: LD_VAR 0 1
18108: PPUSH
18109: CALL_OW 313
18113: PUSH
18114: LD_INT 6
18116: LESS
18117: ST_TO_ADDR
// end ;
18118: LD_VAR 0 2
18122: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18123: LD_INT 0
18125: PPUSH
18126: PPUSH
18127: PPUSH
18128: PPUSH
// tmp := [ ] ;
18129: LD_ADDR_VAR 0 3
18133: PUSH
18134: EMPTY
18135: ST_TO_ADDR
// list := [ ] ;
18136: LD_ADDR_VAR 0 5
18140: PUSH
18141: EMPTY
18142: ST_TO_ADDR
// for i = 16 to 25 do
18143: LD_ADDR_VAR 0 4
18147: PUSH
18148: DOUBLE
18149: LD_INT 16
18151: DEC
18152: ST_TO_ADDR
18153: LD_INT 25
18155: PUSH
18156: FOR_TO
18157: IFFALSE 18230
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18159: LD_ADDR_VAR 0 3
18163: PUSH
18164: LD_VAR 0 3
18168: PUSH
18169: LD_INT 22
18171: PUSH
18172: LD_VAR 0 1
18176: PPUSH
18177: CALL_OW 255
18181: PUSH
18182: EMPTY
18183: LIST
18184: LIST
18185: PUSH
18186: LD_INT 91
18188: PUSH
18189: LD_VAR 0 1
18193: PUSH
18194: LD_INT 6
18196: PUSH
18197: EMPTY
18198: LIST
18199: LIST
18200: LIST
18201: PUSH
18202: LD_INT 30
18204: PUSH
18205: LD_VAR 0 4
18209: PUSH
18210: EMPTY
18211: LIST
18212: LIST
18213: PUSH
18214: EMPTY
18215: LIST
18216: LIST
18217: LIST
18218: PUSH
18219: EMPTY
18220: LIST
18221: PPUSH
18222: CALL_OW 69
18226: ADD
18227: ST_TO_ADDR
18228: GO 18156
18230: POP
18231: POP
// for i = 1 to tmp do
18232: LD_ADDR_VAR 0 4
18236: PUSH
18237: DOUBLE
18238: LD_INT 1
18240: DEC
18241: ST_TO_ADDR
18242: LD_VAR 0 3
18246: PUSH
18247: FOR_TO
18248: IFFALSE 18336
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18250: LD_ADDR_VAR 0 5
18254: PUSH
18255: LD_VAR 0 5
18259: PUSH
18260: LD_VAR 0 3
18264: PUSH
18265: LD_VAR 0 4
18269: ARRAY
18270: PPUSH
18271: CALL_OW 266
18275: PUSH
18276: LD_VAR 0 3
18280: PUSH
18281: LD_VAR 0 4
18285: ARRAY
18286: PPUSH
18287: CALL_OW 250
18291: PUSH
18292: LD_VAR 0 3
18296: PUSH
18297: LD_VAR 0 4
18301: ARRAY
18302: PPUSH
18303: CALL_OW 251
18307: PUSH
18308: LD_VAR 0 3
18312: PUSH
18313: LD_VAR 0 4
18317: ARRAY
18318: PPUSH
18319: CALL_OW 254
18323: PUSH
18324: EMPTY
18325: LIST
18326: LIST
18327: LIST
18328: LIST
18329: PUSH
18330: EMPTY
18331: LIST
18332: ADD
18333: ST_TO_ADDR
18334: GO 18247
18336: POP
18337: POP
// result := list ;
18338: LD_ADDR_VAR 0 2
18342: PUSH
18343: LD_VAR 0 5
18347: ST_TO_ADDR
// end ;
18348: LD_VAR 0 2
18352: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18353: LD_INT 0
18355: PPUSH
18356: PPUSH
18357: PPUSH
18358: PPUSH
18359: PPUSH
18360: PPUSH
18361: PPUSH
// if not factory then
18362: LD_VAR 0 1
18366: NOT
18367: IFFALSE 18371
// exit ;
18369: GO 18964
// if control = control_apeman then
18371: LD_VAR 0 4
18375: PUSH
18376: LD_INT 5
18378: EQUAL
18379: IFFALSE 18488
// begin tmp := UnitsInside ( factory ) ;
18381: LD_ADDR_VAR 0 8
18385: PUSH
18386: LD_VAR 0 1
18390: PPUSH
18391: CALL_OW 313
18395: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18396: LD_VAR 0 8
18400: PPUSH
18401: LD_INT 25
18403: PUSH
18404: LD_INT 12
18406: PUSH
18407: EMPTY
18408: LIST
18409: LIST
18410: PPUSH
18411: CALL_OW 72
18415: NOT
18416: IFFALSE 18426
// control := control_manual ;
18418: LD_ADDR_VAR 0 4
18422: PUSH
18423: LD_INT 1
18425: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18426: LD_ADDR_VAR 0 8
18430: PUSH
18431: LD_VAR 0 1
18435: PPUSH
18436: CALL 18123 0 1
18440: ST_TO_ADDR
// if tmp then
18441: LD_VAR 0 8
18445: IFFALSE 18488
// begin for i in tmp do
18447: LD_ADDR_VAR 0 7
18451: PUSH
18452: LD_VAR 0 8
18456: PUSH
18457: FOR_IN
18458: IFFALSE 18486
// if i [ 1 ] = b_ext_radio then
18460: LD_VAR 0 7
18464: PUSH
18465: LD_INT 1
18467: ARRAY
18468: PUSH
18469: LD_INT 22
18471: EQUAL
18472: IFFALSE 18484
// begin control := control_remote ;
18474: LD_ADDR_VAR 0 4
18478: PUSH
18479: LD_INT 2
18481: ST_TO_ADDR
// break ;
18482: GO 18486
// end ;
18484: GO 18457
18486: POP
18487: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18488: LD_VAR 0 1
18492: PPUSH
18493: LD_VAR 0 2
18497: PPUSH
18498: LD_VAR 0 3
18502: PPUSH
18503: LD_VAR 0 4
18507: PPUSH
18508: LD_VAR 0 5
18512: PPUSH
18513: CALL_OW 448
18517: IFFALSE 18552
// begin result := [ chassis , engine , control , weapon ] ;
18519: LD_ADDR_VAR 0 6
18523: PUSH
18524: LD_VAR 0 2
18528: PUSH
18529: LD_VAR 0 3
18533: PUSH
18534: LD_VAR 0 4
18538: PUSH
18539: LD_VAR 0 5
18543: PUSH
18544: EMPTY
18545: LIST
18546: LIST
18547: LIST
18548: LIST
18549: ST_TO_ADDR
// exit ;
18550: GO 18964
// end ; _chassis := AvailableChassisList ( factory ) ;
18552: LD_ADDR_VAR 0 9
18556: PUSH
18557: LD_VAR 0 1
18561: PPUSH
18562: CALL_OW 475
18566: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18567: LD_ADDR_VAR 0 11
18571: PUSH
18572: LD_VAR 0 1
18576: PPUSH
18577: CALL_OW 476
18581: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18582: LD_ADDR_VAR 0 12
18586: PUSH
18587: LD_VAR 0 1
18591: PPUSH
18592: CALL_OW 477
18596: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18597: LD_ADDR_VAR 0 10
18601: PUSH
18602: LD_VAR 0 1
18606: PPUSH
18607: CALL_OW 478
18611: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
18612: LD_VAR 0 9
18616: NOT
18617: PUSH
18618: LD_VAR 0 11
18622: NOT
18623: OR
18624: PUSH
18625: LD_VAR 0 12
18629: NOT
18630: OR
18631: PUSH
18632: LD_VAR 0 10
18636: NOT
18637: OR
18638: IFFALSE 18673
// begin result := [ chassis , engine , control , weapon ] ;
18640: LD_ADDR_VAR 0 6
18644: PUSH
18645: LD_VAR 0 2
18649: PUSH
18650: LD_VAR 0 3
18654: PUSH
18655: LD_VAR 0 4
18659: PUSH
18660: LD_VAR 0 5
18664: PUSH
18665: EMPTY
18666: LIST
18667: LIST
18668: LIST
18669: LIST
18670: ST_TO_ADDR
// exit ;
18671: GO 18964
// end ; if not chassis in _chassis then
18673: LD_VAR 0 2
18677: PUSH
18678: LD_VAR 0 9
18682: IN
18683: NOT
18684: IFFALSE 18710
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18686: LD_ADDR_VAR 0 2
18690: PUSH
18691: LD_VAR 0 9
18695: PUSH
18696: LD_INT 1
18698: PPUSH
18699: LD_VAR 0 9
18703: PPUSH
18704: CALL_OW 12
18708: ARRAY
18709: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18710: LD_VAR 0 2
18714: PPUSH
18715: LD_VAR 0 3
18719: PPUSH
18720: CALL 18969 0 2
18724: NOT
18725: IFFALSE 18784
// repeat engine := _engine [ 1 ] ;
18727: LD_ADDR_VAR 0 3
18731: PUSH
18732: LD_VAR 0 11
18736: PUSH
18737: LD_INT 1
18739: ARRAY
18740: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18741: LD_ADDR_VAR 0 11
18745: PUSH
18746: LD_VAR 0 11
18750: PPUSH
18751: LD_INT 1
18753: PPUSH
18754: CALL_OW 3
18758: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18759: LD_VAR 0 2
18763: PPUSH
18764: LD_VAR 0 3
18768: PPUSH
18769: CALL 18969 0 2
18773: PUSH
18774: LD_VAR 0 11
18778: PUSH
18779: EMPTY
18780: EQUAL
18781: OR
18782: IFFALSE 18727
// if not control in _control then
18784: LD_VAR 0 4
18788: PUSH
18789: LD_VAR 0 12
18793: IN
18794: NOT
18795: IFFALSE 18821
// control := _control [ rand ( 1 , _control ) ] ;
18797: LD_ADDR_VAR 0 4
18801: PUSH
18802: LD_VAR 0 12
18806: PUSH
18807: LD_INT 1
18809: PPUSH
18810: LD_VAR 0 12
18814: PPUSH
18815: CALL_OW 12
18819: ARRAY
18820: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18821: LD_VAR 0 2
18825: PPUSH
18826: LD_VAR 0 5
18830: PPUSH
18831: CALL 19189 0 2
18835: NOT
18836: IFFALSE 18895
// repeat weapon := _weapon [ 1 ] ;
18838: LD_ADDR_VAR 0 5
18842: PUSH
18843: LD_VAR 0 10
18847: PUSH
18848: LD_INT 1
18850: ARRAY
18851: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18852: LD_ADDR_VAR 0 10
18856: PUSH
18857: LD_VAR 0 10
18861: PPUSH
18862: LD_INT 1
18864: PPUSH
18865: CALL_OW 3
18869: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18870: LD_VAR 0 2
18874: PPUSH
18875: LD_VAR 0 5
18879: PPUSH
18880: CALL 19189 0 2
18884: PUSH
18885: LD_VAR 0 10
18889: PUSH
18890: EMPTY
18891: EQUAL
18892: OR
18893: IFFALSE 18838
// result := [ ] ;
18895: LD_ADDR_VAR 0 6
18899: PUSH
18900: EMPTY
18901: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18902: LD_VAR 0 1
18906: PPUSH
18907: LD_VAR 0 2
18911: PPUSH
18912: LD_VAR 0 3
18916: PPUSH
18917: LD_VAR 0 4
18921: PPUSH
18922: LD_VAR 0 5
18926: PPUSH
18927: CALL_OW 448
18931: IFFALSE 18964
// result := [ chassis , engine , control , weapon ] ;
18933: LD_ADDR_VAR 0 6
18937: PUSH
18938: LD_VAR 0 2
18942: PUSH
18943: LD_VAR 0 3
18947: PUSH
18948: LD_VAR 0 4
18952: PUSH
18953: LD_VAR 0 5
18957: PUSH
18958: EMPTY
18959: LIST
18960: LIST
18961: LIST
18962: LIST
18963: ST_TO_ADDR
// end ;
18964: LD_VAR 0 6
18968: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18969: LD_INT 0
18971: PPUSH
// if not chassis or not engine then
18972: LD_VAR 0 1
18976: NOT
18977: PUSH
18978: LD_VAR 0 2
18982: NOT
18983: OR
18984: IFFALSE 18988
// exit ;
18986: GO 19184
// case engine of engine_solar :
18988: LD_VAR 0 2
18992: PUSH
18993: LD_INT 2
18995: DOUBLE
18996: EQUAL
18997: IFTRUE 19001
18999: GO 19039
19001: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19002: LD_ADDR_VAR 0 3
19006: PUSH
19007: LD_INT 11
19009: PUSH
19010: LD_INT 12
19012: PUSH
19013: LD_INT 13
19015: PUSH
19016: LD_INT 14
19018: PUSH
19019: LD_INT 1
19021: PUSH
19022: LD_INT 2
19024: PUSH
19025: LD_INT 3
19027: PUSH
19028: EMPTY
19029: LIST
19030: LIST
19031: LIST
19032: LIST
19033: LIST
19034: LIST
19035: LIST
19036: ST_TO_ADDR
19037: GO 19168
19039: LD_INT 1
19041: DOUBLE
19042: EQUAL
19043: IFTRUE 19047
19045: GO 19109
19047: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19048: LD_ADDR_VAR 0 3
19052: PUSH
19053: LD_INT 11
19055: PUSH
19056: LD_INT 12
19058: PUSH
19059: LD_INT 13
19061: PUSH
19062: LD_INT 14
19064: PUSH
19065: LD_INT 1
19067: PUSH
19068: LD_INT 2
19070: PUSH
19071: LD_INT 3
19073: PUSH
19074: LD_INT 4
19076: PUSH
19077: LD_INT 5
19079: PUSH
19080: LD_INT 21
19082: PUSH
19083: LD_INT 23
19085: PUSH
19086: LD_INT 22
19088: PUSH
19089: LD_INT 24
19091: PUSH
19092: EMPTY
19093: LIST
19094: LIST
19095: LIST
19096: LIST
19097: LIST
19098: LIST
19099: LIST
19100: LIST
19101: LIST
19102: LIST
19103: LIST
19104: LIST
19105: LIST
19106: ST_TO_ADDR
19107: GO 19168
19109: LD_INT 3
19111: DOUBLE
19112: EQUAL
19113: IFTRUE 19117
19115: GO 19167
19117: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19118: LD_ADDR_VAR 0 3
19122: PUSH
19123: LD_INT 13
19125: PUSH
19126: LD_INT 14
19128: PUSH
19129: LD_INT 2
19131: PUSH
19132: LD_INT 3
19134: PUSH
19135: LD_INT 4
19137: PUSH
19138: LD_INT 5
19140: PUSH
19141: LD_INT 21
19143: PUSH
19144: LD_INT 22
19146: PUSH
19147: LD_INT 23
19149: PUSH
19150: LD_INT 24
19152: PUSH
19153: EMPTY
19154: LIST
19155: LIST
19156: LIST
19157: LIST
19158: LIST
19159: LIST
19160: LIST
19161: LIST
19162: LIST
19163: LIST
19164: ST_TO_ADDR
19165: GO 19168
19167: POP
// result := ( chassis in result ) ;
19168: LD_ADDR_VAR 0 3
19172: PUSH
19173: LD_VAR 0 1
19177: PUSH
19178: LD_VAR 0 3
19182: IN
19183: ST_TO_ADDR
// end ;
19184: LD_VAR 0 3
19188: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19189: LD_INT 0
19191: PPUSH
// if not chassis or not weapon then
19192: LD_VAR 0 1
19196: NOT
19197: PUSH
19198: LD_VAR 0 2
19202: NOT
19203: OR
19204: IFFALSE 19208
// exit ;
19206: GO 20234
// case weapon of us_machine_gun :
19208: LD_VAR 0 2
19212: PUSH
19213: LD_INT 2
19215: DOUBLE
19216: EQUAL
19217: IFTRUE 19221
19219: GO 19251
19221: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19222: LD_ADDR_VAR 0 3
19226: PUSH
19227: LD_INT 1
19229: PUSH
19230: LD_INT 2
19232: PUSH
19233: LD_INT 3
19235: PUSH
19236: LD_INT 4
19238: PUSH
19239: LD_INT 5
19241: PUSH
19242: EMPTY
19243: LIST
19244: LIST
19245: LIST
19246: LIST
19247: LIST
19248: ST_TO_ADDR
19249: GO 20218
19251: LD_INT 3
19253: DOUBLE
19254: EQUAL
19255: IFTRUE 19259
19257: GO 19289
19259: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19260: LD_ADDR_VAR 0 3
19264: PUSH
19265: LD_INT 1
19267: PUSH
19268: LD_INT 2
19270: PUSH
19271: LD_INT 3
19273: PUSH
19274: LD_INT 4
19276: PUSH
19277: LD_INT 5
19279: PUSH
19280: EMPTY
19281: LIST
19282: LIST
19283: LIST
19284: LIST
19285: LIST
19286: ST_TO_ADDR
19287: GO 20218
19289: LD_INT 11
19291: DOUBLE
19292: EQUAL
19293: IFTRUE 19297
19295: GO 19327
19297: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19298: LD_ADDR_VAR 0 3
19302: PUSH
19303: LD_INT 1
19305: PUSH
19306: LD_INT 2
19308: PUSH
19309: LD_INT 3
19311: PUSH
19312: LD_INT 4
19314: PUSH
19315: LD_INT 5
19317: PUSH
19318: EMPTY
19319: LIST
19320: LIST
19321: LIST
19322: LIST
19323: LIST
19324: ST_TO_ADDR
19325: GO 20218
19327: LD_INT 4
19329: DOUBLE
19330: EQUAL
19331: IFTRUE 19335
19333: GO 19361
19335: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19336: LD_ADDR_VAR 0 3
19340: PUSH
19341: LD_INT 2
19343: PUSH
19344: LD_INT 3
19346: PUSH
19347: LD_INT 4
19349: PUSH
19350: LD_INT 5
19352: PUSH
19353: EMPTY
19354: LIST
19355: LIST
19356: LIST
19357: LIST
19358: ST_TO_ADDR
19359: GO 20218
19361: LD_INT 5
19363: DOUBLE
19364: EQUAL
19365: IFTRUE 19369
19367: GO 19395
19369: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19370: LD_ADDR_VAR 0 3
19374: PUSH
19375: LD_INT 2
19377: PUSH
19378: LD_INT 3
19380: PUSH
19381: LD_INT 4
19383: PUSH
19384: LD_INT 5
19386: PUSH
19387: EMPTY
19388: LIST
19389: LIST
19390: LIST
19391: LIST
19392: ST_TO_ADDR
19393: GO 20218
19395: LD_INT 9
19397: DOUBLE
19398: EQUAL
19399: IFTRUE 19403
19401: GO 19429
19403: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19404: LD_ADDR_VAR 0 3
19408: PUSH
19409: LD_INT 2
19411: PUSH
19412: LD_INT 3
19414: PUSH
19415: LD_INT 4
19417: PUSH
19418: LD_INT 5
19420: PUSH
19421: EMPTY
19422: LIST
19423: LIST
19424: LIST
19425: LIST
19426: ST_TO_ADDR
19427: GO 20218
19429: LD_INT 7
19431: DOUBLE
19432: EQUAL
19433: IFTRUE 19437
19435: GO 19463
19437: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19438: LD_ADDR_VAR 0 3
19442: PUSH
19443: LD_INT 2
19445: PUSH
19446: LD_INT 3
19448: PUSH
19449: LD_INT 4
19451: PUSH
19452: LD_INT 5
19454: PUSH
19455: EMPTY
19456: LIST
19457: LIST
19458: LIST
19459: LIST
19460: ST_TO_ADDR
19461: GO 20218
19463: LD_INT 12
19465: DOUBLE
19466: EQUAL
19467: IFTRUE 19471
19469: GO 19497
19471: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
19472: LD_ADDR_VAR 0 3
19476: PUSH
19477: LD_INT 2
19479: PUSH
19480: LD_INT 3
19482: PUSH
19483: LD_INT 4
19485: PUSH
19486: LD_INT 5
19488: PUSH
19489: EMPTY
19490: LIST
19491: LIST
19492: LIST
19493: LIST
19494: ST_TO_ADDR
19495: GO 20218
19497: LD_INT 13
19499: DOUBLE
19500: EQUAL
19501: IFTRUE 19505
19503: GO 19531
19505: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
19506: LD_ADDR_VAR 0 3
19510: PUSH
19511: LD_INT 2
19513: PUSH
19514: LD_INT 3
19516: PUSH
19517: LD_INT 4
19519: PUSH
19520: LD_INT 5
19522: PUSH
19523: EMPTY
19524: LIST
19525: LIST
19526: LIST
19527: LIST
19528: ST_TO_ADDR
19529: GO 20218
19531: LD_INT 14
19533: DOUBLE
19534: EQUAL
19535: IFTRUE 19539
19537: GO 19557
19539: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
19540: LD_ADDR_VAR 0 3
19544: PUSH
19545: LD_INT 4
19547: PUSH
19548: LD_INT 5
19550: PUSH
19551: EMPTY
19552: LIST
19553: LIST
19554: ST_TO_ADDR
19555: GO 20218
19557: LD_INT 6
19559: DOUBLE
19560: EQUAL
19561: IFTRUE 19565
19563: GO 19583
19565: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19566: LD_ADDR_VAR 0 3
19570: PUSH
19571: LD_INT 4
19573: PUSH
19574: LD_INT 5
19576: PUSH
19577: EMPTY
19578: LIST
19579: LIST
19580: ST_TO_ADDR
19581: GO 20218
19583: LD_INT 10
19585: DOUBLE
19586: EQUAL
19587: IFTRUE 19591
19589: GO 19609
19591: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19592: LD_ADDR_VAR 0 3
19596: PUSH
19597: LD_INT 4
19599: PUSH
19600: LD_INT 5
19602: PUSH
19603: EMPTY
19604: LIST
19605: LIST
19606: ST_TO_ADDR
19607: GO 20218
19609: LD_INT 22
19611: DOUBLE
19612: EQUAL
19613: IFTRUE 19617
19615: GO 19643
19617: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19618: LD_ADDR_VAR 0 3
19622: PUSH
19623: LD_INT 11
19625: PUSH
19626: LD_INT 12
19628: PUSH
19629: LD_INT 13
19631: PUSH
19632: LD_INT 14
19634: PUSH
19635: EMPTY
19636: LIST
19637: LIST
19638: LIST
19639: LIST
19640: ST_TO_ADDR
19641: GO 20218
19643: LD_INT 23
19645: DOUBLE
19646: EQUAL
19647: IFTRUE 19651
19649: GO 19677
19651: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19652: LD_ADDR_VAR 0 3
19656: PUSH
19657: LD_INT 11
19659: PUSH
19660: LD_INT 12
19662: PUSH
19663: LD_INT 13
19665: PUSH
19666: LD_INT 14
19668: PUSH
19669: EMPTY
19670: LIST
19671: LIST
19672: LIST
19673: LIST
19674: ST_TO_ADDR
19675: GO 20218
19677: LD_INT 24
19679: DOUBLE
19680: EQUAL
19681: IFTRUE 19685
19683: GO 19711
19685: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19686: LD_ADDR_VAR 0 3
19690: PUSH
19691: LD_INT 11
19693: PUSH
19694: LD_INT 12
19696: PUSH
19697: LD_INT 13
19699: PUSH
19700: LD_INT 14
19702: PUSH
19703: EMPTY
19704: LIST
19705: LIST
19706: LIST
19707: LIST
19708: ST_TO_ADDR
19709: GO 20218
19711: LD_INT 30
19713: DOUBLE
19714: EQUAL
19715: IFTRUE 19719
19717: GO 19745
19719: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19720: LD_ADDR_VAR 0 3
19724: PUSH
19725: LD_INT 11
19727: PUSH
19728: LD_INT 12
19730: PUSH
19731: LD_INT 13
19733: PUSH
19734: LD_INT 14
19736: PUSH
19737: EMPTY
19738: LIST
19739: LIST
19740: LIST
19741: LIST
19742: ST_TO_ADDR
19743: GO 20218
19745: LD_INT 25
19747: DOUBLE
19748: EQUAL
19749: IFTRUE 19753
19751: GO 19771
19753: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19754: LD_ADDR_VAR 0 3
19758: PUSH
19759: LD_INT 13
19761: PUSH
19762: LD_INT 14
19764: PUSH
19765: EMPTY
19766: LIST
19767: LIST
19768: ST_TO_ADDR
19769: GO 20218
19771: LD_INT 27
19773: DOUBLE
19774: EQUAL
19775: IFTRUE 19779
19777: GO 19797
19779: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19780: LD_ADDR_VAR 0 3
19784: PUSH
19785: LD_INT 13
19787: PUSH
19788: LD_INT 14
19790: PUSH
19791: EMPTY
19792: LIST
19793: LIST
19794: ST_TO_ADDR
19795: GO 20218
19797: LD_INT 28
19799: DOUBLE
19800: EQUAL
19801: IFTRUE 19805
19803: GO 19823
19805: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19806: LD_ADDR_VAR 0 3
19810: PUSH
19811: LD_INT 13
19813: PUSH
19814: LD_INT 14
19816: PUSH
19817: EMPTY
19818: LIST
19819: LIST
19820: ST_TO_ADDR
19821: GO 20218
19823: LD_INT 29
19825: DOUBLE
19826: EQUAL
19827: IFTRUE 19831
19829: GO 19849
19831: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19832: LD_ADDR_VAR 0 3
19836: PUSH
19837: LD_INT 13
19839: PUSH
19840: LD_INT 14
19842: PUSH
19843: EMPTY
19844: LIST
19845: LIST
19846: ST_TO_ADDR
19847: GO 20218
19849: LD_INT 31
19851: DOUBLE
19852: EQUAL
19853: IFTRUE 19857
19855: GO 19875
19857: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19858: LD_ADDR_VAR 0 3
19862: PUSH
19863: LD_INT 13
19865: PUSH
19866: LD_INT 14
19868: PUSH
19869: EMPTY
19870: LIST
19871: LIST
19872: ST_TO_ADDR
19873: GO 20218
19875: LD_INT 26
19877: DOUBLE
19878: EQUAL
19879: IFTRUE 19883
19881: GO 19901
19883: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19884: LD_ADDR_VAR 0 3
19888: PUSH
19889: LD_INT 13
19891: PUSH
19892: LD_INT 14
19894: PUSH
19895: EMPTY
19896: LIST
19897: LIST
19898: ST_TO_ADDR
19899: GO 20218
19901: LD_INT 42
19903: DOUBLE
19904: EQUAL
19905: IFTRUE 19909
19907: GO 19935
19909: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19910: LD_ADDR_VAR 0 3
19914: PUSH
19915: LD_INT 21
19917: PUSH
19918: LD_INT 22
19920: PUSH
19921: LD_INT 23
19923: PUSH
19924: LD_INT 24
19926: PUSH
19927: EMPTY
19928: LIST
19929: LIST
19930: LIST
19931: LIST
19932: ST_TO_ADDR
19933: GO 20218
19935: LD_INT 43
19937: DOUBLE
19938: EQUAL
19939: IFTRUE 19943
19941: GO 19969
19943: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19944: LD_ADDR_VAR 0 3
19948: PUSH
19949: LD_INT 21
19951: PUSH
19952: LD_INT 22
19954: PUSH
19955: LD_INT 23
19957: PUSH
19958: LD_INT 24
19960: PUSH
19961: EMPTY
19962: LIST
19963: LIST
19964: LIST
19965: LIST
19966: ST_TO_ADDR
19967: GO 20218
19969: LD_INT 44
19971: DOUBLE
19972: EQUAL
19973: IFTRUE 19977
19975: GO 20003
19977: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19978: LD_ADDR_VAR 0 3
19982: PUSH
19983: LD_INT 21
19985: PUSH
19986: LD_INT 22
19988: PUSH
19989: LD_INT 23
19991: PUSH
19992: LD_INT 24
19994: PUSH
19995: EMPTY
19996: LIST
19997: LIST
19998: LIST
19999: LIST
20000: ST_TO_ADDR
20001: GO 20218
20003: LD_INT 45
20005: DOUBLE
20006: EQUAL
20007: IFTRUE 20011
20009: GO 20037
20011: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20012: LD_ADDR_VAR 0 3
20016: PUSH
20017: LD_INT 21
20019: PUSH
20020: LD_INT 22
20022: PUSH
20023: LD_INT 23
20025: PUSH
20026: LD_INT 24
20028: PUSH
20029: EMPTY
20030: LIST
20031: LIST
20032: LIST
20033: LIST
20034: ST_TO_ADDR
20035: GO 20218
20037: LD_INT 49
20039: DOUBLE
20040: EQUAL
20041: IFTRUE 20045
20043: GO 20071
20045: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20046: LD_ADDR_VAR 0 3
20050: PUSH
20051: LD_INT 21
20053: PUSH
20054: LD_INT 22
20056: PUSH
20057: LD_INT 23
20059: PUSH
20060: LD_INT 24
20062: PUSH
20063: EMPTY
20064: LIST
20065: LIST
20066: LIST
20067: LIST
20068: ST_TO_ADDR
20069: GO 20218
20071: LD_INT 51
20073: DOUBLE
20074: EQUAL
20075: IFTRUE 20079
20077: GO 20105
20079: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20080: LD_ADDR_VAR 0 3
20084: PUSH
20085: LD_INT 21
20087: PUSH
20088: LD_INT 22
20090: PUSH
20091: LD_INT 23
20093: PUSH
20094: LD_INT 24
20096: PUSH
20097: EMPTY
20098: LIST
20099: LIST
20100: LIST
20101: LIST
20102: ST_TO_ADDR
20103: GO 20218
20105: LD_INT 52
20107: DOUBLE
20108: EQUAL
20109: IFTRUE 20113
20111: GO 20139
20113: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20114: LD_ADDR_VAR 0 3
20118: PUSH
20119: LD_INT 21
20121: PUSH
20122: LD_INT 22
20124: PUSH
20125: LD_INT 23
20127: PUSH
20128: LD_INT 24
20130: PUSH
20131: EMPTY
20132: LIST
20133: LIST
20134: LIST
20135: LIST
20136: ST_TO_ADDR
20137: GO 20218
20139: LD_INT 53
20141: DOUBLE
20142: EQUAL
20143: IFTRUE 20147
20145: GO 20165
20147: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20148: LD_ADDR_VAR 0 3
20152: PUSH
20153: LD_INT 23
20155: PUSH
20156: LD_INT 24
20158: PUSH
20159: EMPTY
20160: LIST
20161: LIST
20162: ST_TO_ADDR
20163: GO 20218
20165: LD_INT 46
20167: DOUBLE
20168: EQUAL
20169: IFTRUE 20173
20171: GO 20191
20173: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20174: LD_ADDR_VAR 0 3
20178: PUSH
20179: LD_INT 23
20181: PUSH
20182: LD_INT 24
20184: PUSH
20185: EMPTY
20186: LIST
20187: LIST
20188: ST_TO_ADDR
20189: GO 20218
20191: LD_INT 47
20193: DOUBLE
20194: EQUAL
20195: IFTRUE 20199
20197: GO 20217
20199: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20200: LD_ADDR_VAR 0 3
20204: PUSH
20205: LD_INT 23
20207: PUSH
20208: LD_INT 24
20210: PUSH
20211: EMPTY
20212: LIST
20213: LIST
20214: ST_TO_ADDR
20215: GO 20218
20217: POP
// result := ( chassis in result ) ;
20218: LD_ADDR_VAR 0 3
20222: PUSH
20223: LD_VAR 0 1
20227: PUSH
20228: LD_VAR 0 3
20232: IN
20233: ST_TO_ADDR
// end ;
20234: LD_VAR 0 3
20238: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20239: LD_INT 0
20241: PPUSH
20242: PPUSH
20243: PPUSH
20244: PPUSH
20245: PPUSH
20246: PPUSH
20247: PPUSH
// result := array ;
20248: LD_ADDR_VAR 0 5
20252: PUSH
20253: LD_VAR 0 1
20257: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20258: LD_VAR 0 1
20262: NOT
20263: PUSH
20264: LD_VAR 0 2
20268: NOT
20269: OR
20270: PUSH
20271: LD_VAR 0 3
20275: NOT
20276: OR
20277: PUSH
20278: LD_VAR 0 2
20282: PUSH
20283: LD_VAR 0 1
20287: GREATER
20288: OR
20289: PUSH
20290: LD_VAR 0 3
20294: PUSH
20295: LD_VAR 0 1
20299: GREATER
20300: OR
20301: IFFALSE 20305
// exit ;
20303: GO 20601
// if direction then
20305: LD_VAR 0 4
20309: IFFALSE 20373
// begin d := 1 ;
20311: LD_ADDR_VAR 0 9
20315: PUSH
20316: LD_INT 1
20318: ST_TO_ADDR
// if i_from > i_to then
20319: LD_VAR 0 2
20323: PUSH
20324: LD_VAR 0 3
20328: GREATER
20329: IFFALSE 20355
// length := ( array - i_from ) + i_to else
20331: LD_ADDR_VAR 0 11
20335: PUSH
20336: LD_VAR 0 1
20340: PUSH
20341: LD_VAR 0 2
20345: MINUS
20346: PUSH
20347: LD_VAR 0 3
20351: PLUS
20352: ST_TO_ADDR
20353: GO 20371
// length := i_to - i_from ;
20355: LD_ADDR_VAR 0 11
20359: PUSH
20360: LD_VAR 0 3
20364: PUSH
20365: LD_VAR 0 2
20369: MINUS
20370: ST_TO_ADDR
// end else
20371: GO 20434
// begin d := - 1 ;
20373: LD_ADDR_VAR 0 9
20377: PUSH
20378: LD_INT 1
20380: NEG
20381: ST_TO_ADDR
// if i_from > i_to then
20382: LD_VAR 0 2
20386: PUSH
20387: LD_VAR 0 3
20391: GREATER
20392: IFFALSE 20412
// length := i_from - i_to else
20394: LD_ADDR_VAR 0 11
20398: PUSH
20399: LD_VAR 0 2
20403: PUSH
20404: LD_VAR 0 3
20408: MINUS
20409: ST_TO_ADDR
20410: GO 20434
// length := ( array - i_to ) + i_from ;
20412: LD_ADDR_VAR 0 11
20416: PUSH
20417: LD_VAR 0 1
20421: PUSH
20422: LD_VAR 0 3
20426: MINUS
20427: PUSH
20428: LD_VAR 0 2
20432: PLUS
20433: ST_TO_ADDR
// end ; if not length then
20434: LD_VAR 0 11
20438: NOT
20439: IFFALSE 20443
// exit ;
20441: GO 20601
// tmp := array ;
20443: LD_ADDR_VAR 0 10
20447: PUSH
20448: LD_VAR 0 1
20452: ST_TO_ADDR
// for i = 1 to length do
20453: LD_ADDR_VAR 0 6
20457: PUSH
20458: DOUBLE
20459: LD_INT 1
20461: DEC
20462: ST_TO_ADDR
20463: LD_VAR 0 11
20467: PUSH
20468: FOR_TO
20469: IFFALSE 20589
// begin for j = 1 to array do
20471: LD_ADDR_VAR 0 7
20475: PUSH
20476: DOUBLE
20477: LD_INT 1
20479: DEC
20480: ST_TO_ADDR
20481: LD_VAR 0 1
20485: PUSH
20486: FOR_TO
20487: IFFALSE 20575
// begin k := j + d ;
20489: LD_ADDR_VAR 0 8
20493: PUSH
20494: LD_VAR 0 7
20498: PUSH
20499: LD_VAR 0 9
20503: PLUS
20504: ST_TO_ADDR
// if k > array then
20505: LD_VAR 0 8
20509: PUSH
20510: LD_VAR 0 1
20514: GREATER
20515: IFFALSE 20525
// k := 1 ;
20517: LD_ADDR_VAR 0 8
20521: PUSH
20522: LD_INT 1
20524: ST_TO_ADDR
// if not k then
20525: LD_VAR 0 8
20529: NOT
20530: IFFALSE 20542
// k := array ;
20532: LD_ADDR_VAR 0 8
20536: PUSH
20537: LD_VAR 0 1
20541: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
20542: LD_ADDR_VAR 0 10
20546: PUSH
20547: LD_VAR 0 10
20551: PPUSH
20552: LD_VAR 0 8
20556: PPUSH
20557: LD_VAR 0 1
20561: PUSH
20562: LD_VAR 0 7
20566: ARRAY
20567: PPUSH
20568: CALL_OW 1
20572: ST_TO_ADDR
// end ;
20573: GO 20486
20575: POP
20576: POP
// array := tmp ;
20577: LD_ADDR_VAR 0 1
20581: PUSH
20582: LD_VAR 0 10
20586: ST_TO_ADDR
// end ;
20587: GO 20468
20589: POP
20590: POP
// result := array ;
20591: LD_ADDR_VAR 0 5
20595: PUSH
20596: LD_VAR 0 1
20600: ST_TO_ADDR
// end ;
20601: LD_VAR 0 5
20605: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20606: LD_INT 0
20608: PPUSH
20609: PPUSH
// result := 0 ;
20610: LD_ADDR_VAR 0 3
20614: PUSH
20615: LD_INT 0
20617: ST_TO_ADDR
// if not array or not value in array then
20618: LD_VAR 0 1
20622: NOT
20623: PUSH
20624: LD_VAR 0 2
20628: PUSH
20629: LD_VAR 0 1
20633: IN
20634: NOT
20635: OR
20636: IFFALSE 20640
// exit ;
20638: GO 20694
// for i = 1 to array do
20640: LD_ADDR_VAR 0 4
20644: PUSH
20645: DOUBLE
20646: LD_INT 1
20648: DEC
20649: ST_TO_ADDR
20650: LD_VAR 0 1
20654: PUSH
20655: FOR_TO
20656: IFFALSE 20692
// if value = array [ i ] then
20658: LD_VAR 0 2
20662: PUSH
20663: LD_VAR 0 1
20667: PUSH
20668: LD_VAR 0 4
20672: ARRAY
20673: EQUAL
20674: IFFALSE 20690
// begin result := i ;
20676: LD_ADDR_VAR 0 3
20680: PUSH
20681: LD_VAR 0 4
20685: ST_TO_ADDR
// exit ;
20686: POP
20687: POP
20688: GO 20694
// end ;
20690: GO 20655
20692: POP
20693: POP
// end ;
20694: LD_VAR 0 3
20698: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20699: LD_INT 0
20701: PPUSH
// vc_chassis := chassis ;
20702: LD_ADDR_OWVAR 37
20706: PUSH
20707: LD_VAR 0 1
20711: ST_TO_ADDR
// vc_engine := engine ;
20712: LD_ADDR_OWVAR 39
20716: PUSH
20717: LD_VAR 0 2
20721: ST_TO_ADDR
// vc_control := control ;
20722: LD_ADDR_OWVAR 38
20726: PUSH
20727: LD_VAR 0 3
20731: ST_TO_ADDR
// vc_weapon := weapon ;
20732: LD_ADDR_OWVAR 40
20736: PUSH
20737: LD_VAR 0 4
20741: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20742: LD_ADDR_OWVAR 41
20746: PUSH
20747: LD_VAR 0 5
20751: ST_TO_ADDR
// end ;
20752: LD_VAR 0 6
20756: RET
// export function WantPlant ( unit ) ; var task ; begin
20757: LD_INT 0
20759: PPUSH
20760: PPUSH
// result := false ;
20761: LD_ADDR_VAR 0 2
20765: PUSH
20766: LD_INT 0
20768: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20769: LD_ADDR_VAR 0 3
20773: PUSH
20774: LD_VAR 0 1
20778: PPUSH
20779: CALL_OW 437
20783: ST_TO_ADDR
// if task then
20784: LD_VAR 0 3
20788: IFFALSE 20816
// if task [ 1 ] [ 1 ] = p then
20790: LD_VAR 0 3
20794: PUSH
20795: LD_INT 1
20797: ARRAY
20798: PUSH
20799: LD_INT 1
20801: ARRAY
20802: PUSH
20803: LD_STRING p
20805: EQUAL
20806: IFFALSE 20816
// result := true ;
20808: LD_ADDR_VAR 0 2
20812: PUSH
20813: LD_INT 1
20815: ST_TO_ADDR
// end ;
20816: LD_VAR 0 2
20820: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20821: LD_INT 0
20823: PPUSH
20824: PPUSH
20825: PPUSH
20826: PPUSH
// if pos < 1 then
20827: LD_VAR 0 2
20831: PUSH
20832: LD_INT 1
20834: LESS
20835: IFFALSE 20839
// exit ;
20837: GO 21142
// if pos = 1 then
20839: LD_VAR 0 2
20843: PUSH
20844: LD_INT 1
20846: EQUAL
20847: IFFALSE 20880
// result := Replace ( arr , pos [ 1 ] , value ) else
20849: LD_ADDR_VAR 0 4
20853: PUSH
20854: LD_VAR 0 1
20858: PPUSH
20859: LD_VAR 0 2
20863: PUSH
20864: LD_INT 1
20866: ARRAY
20867: PPUSH
20868: LD_VAR 0 3
20872: PPUSH
20873: CALL_OW 1
20877: ST_TO_ADDR
20878: GO 21142
// begin tmp := arr ;
20880: LD_ADDR_VAR 0 6
20884: PUSH
20885: LD_VAR 0 1
20889: ST_TO_ADDR
// s_arr := [ tmp ] ;
20890: LD_ADDR_VAR 0 7
20894: PUSH
20895: LD_VAR 0 6
20899: PUSH
20900: EMPTY
20901: LIST
20902: ST_TO_ADDR
// for i = 1 to pos - 1 do
20903: LD_ADDR_VAR 0 5
20907: PUSH
20908: DOUBLE
20909: LD_INT 1
20911: DEC
20912: ST_TO_ADDR
20913: LD_VAR 0 2
20917: PUSH
20918: LD_INT 1
20920: MINUS
20921: PUSH
20922: FOR_TO
20923: IFFALSE 20968
// begin tmp := tmp [ pos [ i ] ] ;
20925: LD_ADDR_VAR 0 6
20929: PUSH
20930: LD_VAR 0 6
20934: PUSH
20935: LD_VAR 0 2
20939: PUSH
20940: LD_VAR 0 5
20944: ARRAY
20945: ARRAY
20946: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20947: LD_ADDR_VAR 0 7
20951: PUSH
20952: LD_VAR 0 7
20956: PUSH
20957: LD_VAR 0 6
20961: PUSH
20962: EMPTY
20963: LIST
20964: ADD
20965: ST_TO_ADDR
// end ;
20966: GO 20922
20968: POP
20969: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20970: LD_ADDR_VAR 0 6
20974: PUSH
20975: LD_VAR 0 6
20979: PPUSH
20980: LD_VAR 0 2
20984: PUSH
20985: LD_VAR 0 2
20989: ARRAY
20990: PPUSH
20991: LD_VAR 0 3
20995: PPUSH
20996: CALL_OW 1
21000: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21001: LD_ADDR_VAR 0 7
21005: PUSH
21006: LD_VAR 0 7
21010: PPUSH
21011: LD_VAR 0 7
21015: PPUSH
21016: LD_VAR 0 6
21020: PPUSH
21021: CALL_OW 1
21025: ST_TO_ADDR
// for i = s_arr downto 2 do
21026: LD_ADDR_VAR 0 5
21030: PUSH
21031: DOUBLE
21032: LD_VAR 0 7
21036: INC
21037: ST_TO_ADDR
21038: LD_INT 2
21040: PUSH
21041: FOR_DOWNTO
21042: IFFALSE 21126
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21044: LD_ADDR_VAR 0 6
21048: PUSH
21049: LD_VAR 0 7
21053: PUSH
21054: LD_VAR 0 5
21058: PUSH
21059: LD_INT 1
21061: MINUS
21062: ARRAY
21063: PPUSH
21064: LD_VAR 0 2
21068: PUSH
21069: LD_VAR 0 5
21073: PUSH
21074: LD_INT 1
21076: MINUS
21077: ARRAY
21078: PPUSH
21079: LD_VAR 0 7
21083: PUSH
21084: LD_VAR 0 5
21088: ARRAY
21089: PPUSH
21090: CALL_OW 1
21094: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21095: LD_ADDR_VAR 0 7
21099: PUSH
21100: LD_VAR 0 7
21104: PPUSH
21105: LD_VAR 0 5
21109: PUSH
21110: LD_INT 1
21112: MINUS
21113: PPUSH
21114: LD_VAR 0 6
21118: PPUSH
21119: CALL_OW 1
21123: ST_TO_ADDR
// end ;
21124: GO 21041
21126: POP
21127: POP
// result := s_arr [ 1 ] ;
21128: LD_ADDR_VAR 0 4
21132: PUSH
21133: LD_VAR 0 7
21137: PUSH
21138: LD_INT 1
21140: ARRAY
21141: ST_TO_ADDR
// end ; end ;
21142: LD_VAR 0 4
21146: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21147: LD_INT 0
21149: PPUSH
21150: PPUSH
// if not list then
21151: LD_VAR 0 1
21155: NOT
21156: IFFALSE 21160
// exit ;
21158: GO 21251
// i := list [ pos1 ] ;
21160: LD_ADDR_VAR 0 5
21164: PUSH
21165: LD_VAR 0 1
21169: PUSH
21170: LD_VAR 0 2
21174: ARRAY
21175: ST_TO_ADDR
// if not i then
21176: LD_VAR 0 5
21180: NOT
21181: IFFALSE 21185
// exit ;
21183: GO 21251
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21185: LD_ADDR_VAR 0 1
21189: PUSH
21190: LD_VAR 0 1
21194: PPUSH
21195: LD_VAR 0 2
21199: PPUSH
21200: LD_VAR 0 1
21204: PUSH
21205: LD_VAR 0 3
21209: ARRAY
21210: PPUSH
21211: CALL_OW 1
21215: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21216: LD_ADDR_VAR 0 1
21220: PUSH
21221: LD_VAR 0 1
21225: PPUSH
21226: LD_VAR 0 3
21230: PPUSH
21231: LD_VAR 0 5
21235: PPUSH
21236: CALL_OW 1
21240: ST_TO_ADDR
// result := list ;
21241: LD_ADDR_VAR 0 4
21245: PUSH
21246: LD_VAR 0 1
21250: ST_TO_ADDR
// end ;
21251: LD_VAR 0 4
21255: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21256: LD_INT 0
21258: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21259: LD_ADDR_VAR 0 5
21263: PUSH
21264: LD_VAR 0 1
21268: PPUSH
21269: CALL_OW 250
21273: PPUSH
21274: LD_VAR 0 1
21278: PPUSH
21279: CALL_OW 251
21283: PPUSH
21284: LD_VAR 0 2
21288: PPUSH
21289: LD_VAR 0 3
21293: PPUSH
21294: LD_VAR 0 4
21298: PPUSH
21299: CALL 21309 0 5
21303: ST_TO_ADDR
// end ;
21304: LD_VAR 0 5
21308: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
21309: LD_INT 0
21311: PPUSH
21312: PPUSH
21313: PPUSH
21314: PPUSH
// if not list then
21315: LD_VAR 0 3
21319: NOT
21320: IFFALSE 21324
// exit ;
21322: GO 21712
// result := [ ] ;
21324: LD_ADDR_VAR 0 6
21328: PUSH
21329: EMPTY
21330: ST_TO_ADDR
// for i in list do
21331: LD_ADDR_VAR 0 7
21335: PUSH
21336: LD_VAR 0 3
21340: PUSH
21341: FOR_IN
21342: IFFALSE 21544
// begin tmp := GetDistUnitXY ( i , x , y ) ;
21344: LD_ADDR_VAR 0 9
21348: PUSH
21349: LD_VAR 0 7
21353: PPUSH
21354: LD_VAR 0 1
21358: PPUSH
21359: LD_VAR 0 2
21363: PPUSH
21364: CALL_OW 297
21368: ST_TO_ADDR
// if not result then
21369: LD_VAR 0 6
21373: NOT
21374: IFFALSE 21400
// result := [ [ i , tmp ] ] else
21376: LD_ADDR_VAR 0 6
21380: PUSH
21381: LD_VAR 0 7
21385: PUSH
21386: LD_VAR 0 9
21390: PUSH
21391: EMPTY
21392: LIST
21393: LIST
21394: PUSH
21395: EMPTY
21396: LIST
21397: ST_TO_ADDR
21398: GO 21542
// begin if result [ result ] [ 2 ] < tmp then
21400: LD_VAR 0 6
21404: PUSH
21405: LD_VAR 0 6
21409: ARRAY
21410: PUSH
21411: LD_INT 2
21413: ARRAY
21414: PUSH
21415: LD_VAR 0 9
21419: LESS
21420: IFFALSE 21462
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21422: LD_ADDR_VAR 0 6
21426: PUSH
21427: LD_VAR 0 6
21431: PPUSH
21432: LD_VAR 0 6
21436: PUSH
21437: LD_INT 1
21439: PLUS
21440: PPUSH
21441: LD_VAR 0 7
21445: PUSH
21446: LD_VAR 0 9
21450: PUSH
21451: EMPTY
21452: LIST
21453: LIST
21454: PPUSH
21455: CALL_OW 2
21459: ST_TO_ADDR
21460: GO 21542
// for j = 1 to result do
21462: LD_ADDR_VAR 0 8
21466: PUSH
21467: DOUBLE
21468: LD_INT 1
21470: DEC
21471: ST_TO_ADDR
21472: LD_VAR 0 6
21476: PUSH
21477: FOR_TO
21478: IFFALSE 21540
// begin if tmp < result [ j ] [ 2 ] then
21480: LD_VAR 0 9
21484: PUSH
21485: LD_VAR 0 6
21489: PUSH
21490: LD_VAR 0 8
21494: ARRAY
21495: PUSH
21496: LD_INT 2
21498: ARRAY
21499: LESS
21500: IFFALSE 21538
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21502: LD_ADDR_VAR 0 6
21506: PUSH
21507: LD_VAR 0 6
21511: PPUSH
21512: LD_VAR 0 8
21516: PPUSH
21517: LD_VAR 0 7
21521: PUSH
21522: LD_VAR 0 9
21526: PUSH
21527: EMPTY
21528: LIST
21529: LIST
21530: PPUSH
21531: CALL_OW 2
21535: ST_TO_ADDR
// break ;
21536: GO 21540
// end ; end ;
21538: GO 21477
21540: POP
21541: POP
// end ; end ;
21542: GO 21341
21544: POP
21545: POP
// if result and not asc then
21546: LD_VAR 0 6
21550: PUSH
21551: LD_VAR 0 4
21555: NOT
21556: AND
21557: IFFALSE 21632
// begin tmp := result ;
21559: LD_ADDR_VAR 0 9
21563: PUSH
21564: LD_VAR 0 6
21568: ST_TO_ADDR
// for i = tmp downto 1 do
21569: LD_ADDR_VAR 0 7
21573: PUSH
21574: DOUBLE
21575: LD_VAR 0 9
21579: INC
21580: ST_TO_ADDR
21581: LD_INT 1
21583: PUSH
21584: FOR_DOWNTO
21585: IFFALSE 21630
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21587: LD_ADDR_VAR 0 6
21591: PUSH
21592: LD_VAR 0 6
21596: PPUSH
21597: LD_VAR 0 9
21601: PUSH
21602: LD_VAR 0 7
21606: MINUS
21607: PUSH
21608: LD_INT 1
21610: PLUS
21611: PPUSH
21612: LD_VAR 0 9
21616: PUSH
21617: LD_VAR 0 7
21621: ARRAY
21622: PPUSH
21623: CALL_OW 1
21627: ST_TO_ADDR
21628: GO 21584
21630: POP
21631: POP
// end ; tmp := [ ] ;
21632: LD_ADDR_VAR 0 9
21636: PUSH
21637: EMPTY
21638: ST_TO_ADDR
// if mode then
21639: LD_VAR 0 5
21643: IFFALSE 21712
// begin for i = 1 to result do
21645: LD_ADDR_VAR 0 7
21649: PUSH
21650: DOUBLE
21651: LD_INT 1
21653: DEC
21654: ST_TO_ADDR
21655: LD_VAR 0 6
21659: PUSH
21660: FOR_TO
21661: IFFALSE 21700
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21663: LD_ADDR_VAR 0 9
21667: PUSH
21668: LD_VAR 0 9
21672: PPUSH
21673: LD_VAR 0 7
21677: PPUSH
21678: LD_VAR 0 6
21682: PUSH
21683: LD_VAR 0 7
21687: ARRAY
21688: PUSH
21689: LD_INT 1
21691: ARRAY
21692: PPUSH
21693: CALL_OW 1
21697: ST_TO_ADDR
21698: GO 21660
21700: POP
21701: POP
// result := tmp ;
21702: LD_ADDR_VAR 0 6
21706: PUSH
21707: LD_VAR 0 9
21711: ST_TO_ADDR
// end ; end ;
21712: LD_VAR 0 6
21716: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21717: LD_INT 0
21719: PPUSH
21720: PPUSH
21721: PPUSH
21722: PPUSH
21723: PPUSH
21724: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21725: LD_ADDR_VAR 0 5
21729: PUSH
21730: LD_INT 0
21732: PUSH
21733: LD_INT 0
21735: PUSH
21736: LD_INT 0
21738: PUSH
21739: EMPTY
21740: PUSH
21741: EMPTY
21742: LIST
21743: LIST
21744: LIST
21745: LIST
21746: ST_TO_ADDR
// if not x or not y then
21747: LD_VAR 0 2
21751: NOT
21752: PUSH
21753: LD_VAR 0 3
21757: NOT
21758: OR
21759: IFFALSE 21763
// exit ;
21761: GO 23409
// if not range then
21763: LD_VAR 0 4
21767: NOT
21768: IFFALSE 21778
// range := 10 ;
21770: LD_ADDR_VAR 0 4
21774: PUSH
21775: LD_INT 10
21777: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21778: LD_ADDR_VAR 0 8
21782: PUSH
21783: LD_INT 81
21785: PUSH
21786: LD_VAR 0 1
21790: PUSH
21791: EMPTY
21792: LIST
21793: LIST
21794: PUSH
21795: LD_INT 92
21797: PUSH
21798: LD_VAR 0 2
21802: PUSH
21803: LD_VAR 0 3
21807: PUSH
21808: LD_VAR 0 4
21812: PUSH
21813: EMPTY
21814: LIST
21815: LIST
21816: LIST
21817: LIST
21818: PUSH
21819: LD_INT 3
21821: PUSH
21822: LD_INT 21
21824: PUSH
21825: LD_INT 3
21827: PUSH
21828: EMPTY
21829: LIST
21830: LIST
21831: PUSH
21832: EMPTY
21833: LIST
21834: LIST
21835: PUSH
21836: EMPTY
21837: LIST
21838: LIST
21839: LIST
21840: PPUSH
21841: CALL_OW 69
21845: ST_TO_ADDR
// if not tmp then
21846: LD_VAR 0 8
21850: NOT
21851: IFFALSE 21855
// exit ;
21853: GO 23409
// for i in tmp do
21855: LD_ADDR_VAR 0 6
21859: PUSH
21860: LD_VAR 0 8
21864: PUSH
21865: FOR_IN
21866: IFFALSE 23384
// begin points := [ 0 , 0 , 0 ] ;
21868: LD_ADDR_VAR 0 9
21872: PUSH
21873: LD_INT 0
21875: PUSH
21876: LD_INT 0
21878: PUSH
21879: LD_INT 0
21881: PUSH
21882: EMPTY
21883: LIST
21884: LIST
21885: LIST
21886: ST_TO_ADDR
// bpoints := 1 ;
21887: LD_ADDR_VAR 0 10
21891: PUSH
21892: LD_INT 1
21894: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21895: LD_VAR 0 6
21899: PPUSH
21900: CALL_OW 247
21904: PUSH
21905: LD_INT 1
21907: DOUBLE
21908: EQUAL
21909: IFTRUE 21913
21911: GO 22491
21913: POP
// begin if GetClass ( i ) = 1 then
21914: LD_VAR 0 6
21918: PPUSH
21919: CALL_OW 257
21923: PUSH
21924: LD_INT 1
21926: EQUAL
21927: IFFALSE 21948
// points := [ 10 , 5 , 3 ] ;
21929: LD_ADDR_VAR 0 9
21933: PUSH
21934: LD_INT 10
21936: PUSH
21937: LD_INT 5
21939: PUSH
21940: LD_INT 3
21942: PUSH
21943: EMPTY
21944: LIST
21945: LIST
21946: LIST
21947: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21948: LD_VAR 0 6
21952: PPUSH
21953: CALL_OW 257
21957: PUSH
21958: LD_INT 2
21960: PUSH
21961: LD_INT 3
21963: PUSH
21964: LD_INT 4
21966: PUSH
21967: EMPTY
21968: LIST
21969: LIST
21970: LIST
21971: IN
21972: IFFALSE 21993
// points := [ 3 , 2 , 1 ] ;
21974: LD_ADDR_VAR 0 9
21978: PUSH
21979: LD_INT 3
21981: PUSH
21982: LD_INT 2
21984: PUSH
21985: LD_INT 1
21987: PUSH
21988: EMPTY
21989: LIST
21990: LIST
21991: LIST
21992: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21993: LD_VAR 0 6
21997: PPUSH
21998: CALL_OW 257
22002: PUSH
22003: LD_INT 5
22005: EQUAL
22006: IFFALSE 22027
// points := [ 130 , 5 , 2 ] ;
22008: LD_ADDR_VAR 0 9
22012: PUSH
22013: LD_INT 130
22015: PUSH
22016: LD_INT 5
22018: PUSH
22019: LD_INT 2
22021: PUSH
22022: EMPTY
22023: LIST
22024: LIST
22025: LIST
22026: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22027: LD_VAR 0 6
22031: PPUSH
22032: CALL_OW 257
22036: PUSH
22037: LD_INT 8
22039: EQUAL
22040: IFFALSE 22061
// points := [ 35 , 35 , 30 ] ;
22042: LD_ADDR_VAR 0 9
22046: PUSH
22047: LD_INT 35
22049: PUSH
22050: LD_INT 35
22052: PUSH
22053: LD_INT 30
22055: PUSH
22056: EMPTY
22057: LIST
22058: LIST
22059: LIST
22060: ST_TO_ADDR
// if GetClass ( i ) = 9 then
22061: LD_VAR 0 6
22065: PPUSH
22066: CALL_OW 257
22070: PUSH
22071: LD_INT 9
22073: EQUAL
22074: IFFALSE 22095
// points := [ 20 , 55 , 40 ] ;
22076: LD_ADDR_VAR 0 9
22080: PUSH
22081: LD_INT 20
22083: PUSH
22084: LD_INT 55
22086: PUSH
22087: LD_INT 40
22089: PUSH
22090: EMPTY
22091: LIST
22092: LIST
22093: LIST
22094: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
22095: LD_VAR 0 6
22099: PPUSH
22100: CALL_OW 257
22104: PUSH
22105: LD_INT 12
22107: PUSH
22108: LD_INT 16
22110: PUSH
22111: EMPTY
22112: LIST
22113: LIST
22114: IN
22115: IFFALSE 22136
// points := [ 5 , 3 , 2 ] ;
22117: LD_ADDR_VAR 0 9
22121: PUSH
22122: LD_INT 5
22124: PUSH
22125: LD_INT 3
22127: PUSH
22128: LD_INT 2
22130: PUSH
22131: EMPTY
22132: LIST
22133: LIST
22134: LIST
22135: ST_TO_ADDR
// if GetClass ( i ) = 17 then
22136: LD_VAR 0 6
22140: PPUSH
22141: CALL_OW 257
22145: PUSH
22146: LD_INT 17
22148: EQUAL
22149: IFFALSE 22170
// points := [ 100 , 50 , 75 ] ;
22151: LD_ADDR_VAR 0 9
22155: PUSH
22156: LD_INT 100
22158: PUSH
22159: LD_INT 50
22161: PUSH
22162: LD_INT 75
22164: PUSH
22165: EMPTY
22166: LIST
22167: LIST
22168: LIST
22169: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22170: LD_VAR 0 6
22174: PPUSH
22175: CALL_OW 257
22179: PUSH
22180: LD_INT 15
22182: EQUAL
22183: IFFALSE 22204
// points := [ 10 , 5 , 3 ] ;
22185: LD_ADDR_VAR 0 9
22189: PUSH
22190: LD_INT 10
22192: PUSH
22193: LD_INT 5
22195: PUSH
22196: LD_INT 3
22198: PUSH
22199: EMPTY
22200: LIST
22201: LIST
22202: LIST
22203: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22204: LD_VAR 0 6
22208: PPUSH
22209: CALL_OW 257
22213: PUSH
22214: LD_INT 14
22216: EQUAL
22217: IFFALSE 22238
// points := [ 10 , 0 , 0 ] ;
22219: LD_ADDR_VAR 0 9
22223: PUSH
22224: LD_INT 10
22226: PUSH
22227: LD_INT 0
22229: PUSH
22230: LD_INT 0
22232: PUSH
22233: EMPTY
22234: LIST
22235: LIST
22236: LIST
22237: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22238: LD_VAR 0 6
22242: PPUSH
22243: CALL_OW 257
22247: PUSH
22248: LD_INT 11
22250: EQUAL
22251: IFFALSE 22272
// points := [ 30 , 10 , 5 ] ;
22253: LD_ADDR_VAR 0 9
22257: PUSH
22258: LD_INT 30
22260: PUSH
22261: LD_INT 10
22263: PUSH
22264: LD_INT 5
22266: PUSH
22267: EMPTY
22268: LIST
22269: LIST
22270: LIST
22271: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22272: LD_VAR 0 1
22276: PPUSH
22277: LD_INT 5
22279: PPUSH
22280: CALL_OW 321
22284: PUSH
22285: LD_INT 2
22287: EQUAL
22288: IFFALSE 22305
// bpoints := bpoints * 1.8 ;
22290: LD_ADDR_VAR 0 10
22294: PUSH
22295: LD_VAR 0 10
22299: PUSH
22300: LD_REAL  1.80000000000000E+0000
22303: MUL
22304: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
22305: LD_VAR 0 6
22309: PPUSH
22310: CALL_OW 257
22314: PUSH
22315: LD_INT 1
22317: PUSH
22318: LD_INT 2
22320: PUSH
22321: LD_INT 3
22323: PUSH
22324: LD_INT 4
22326: PUSH
22327: EMPTY
22328: LIST
22329: LIST
22330: LIST
22331: LIST
22332: IN
22333: PUSH
22334: LD_VAR 0 1
22338: PPUSH
22339: LD_INT 51
22341: PPUSH
22342: CALL_OW 321
22346: PUSH
22347: LD_INT 2
22349: EQUAL
22350: AND
22351: IFFALSE 22368
// bpoints := bpoints * 1.2 ;
22353: LD_ADDR_VAR 0 10
22357: PUSH
22358: LD_VAR 0 10
22362: PUSH
22363: LD_REAL  1.20000000000000E+0000
22366: MUL
22367: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
22368: LD_VAR 0 6
22372: PPUSH
22373: CALL_OW 257
22377: PUSH
22378: LD_INT 5
22380: PUSH
22381: LD_INT 7
22383: PUSH
22384: LD_INT 9
22386: PUSH
22387: EMPTY
22388: LIST
22389: LIST
22390: LIST
22391: IN
22392: PUSH
22393: LD_VAR 0 1
22397: PPUSH
22398: LD_INT 52
22400: PPUSH
22401: CALL_OW 321
22405: PUSH
22406: LD_INT 2
22408: EQUAL
22409: AND
22410: IFFALSE 22427
// bpoints := bpoints * 1.5 ;
22412: LD_ADDR_VAR 0 10
22416: PUSH
22417: LD_VAR 0 10
22421: PUSH
22422: LD_REAL  1.50000000000000E+0000
22425: MUL
22426: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22427: LD_VAR 0 1
22431: PPUSH
22432: LD_INT 66
22434: PPUSH
22435: CALL_OW 321
22439: PUSH
22440: LD_INT 2
22442: EQUAL
22443: IFFALSE 22460
// bpoints := bpoints * 1.1 ;
22445: LD_ADDR_VAR 0 10
22449: PUSH
22450: LD_VAR 0 10
22454: PUSH
22455: LD_REAL  1.10000000000000E+0000
22458: MUL
22459: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
22460: LD_ADDR_VAR 0 10
22464: PUSH
22465: LD_VAR 0 10
22469: PUSH
22470: LD_VAR 0 6
22474: PPUSH
22475: LD_INT 1
22477: PPUSH
22478: CALL_OW 259
22482: PUSH
22483: LD_REAL  1.15000000000000E+0000
22486: MUL
22487: MUL
22488: ST_TO_ADDR
// end ; unit_vehicle :
22489: GO 23313
22491: LD_INT 2
22493: DOUBLE
22494: EQUAL
22495: IFTRUE 22499
22497: GO 23301
22499: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
22500: LD_VAR 0 6
22504: PPUSH
22505: CALL_OW 264
22509: PUSH
22510: LD_INT 2
22512: PUSH
22513: LD_INT 42
22515: PUSH
22516: LD_INT 24
22518: PUSH
22519: EMPTY
22520: LIST
22521: LIST
22522: LIST
22523: IN
22524: IFFALSE 22545
// points := [ 25 , 5 , 3 ] ;
22526: LD_ADDR_VAR 0 9
22530: PUSH
22531: LD_INT 25
22533: PUSH
22534: LD_INT 5
22536: PUSH
22537: LD_INT 3
22539: PUSH
22540: EMPTY
22541: LIST
22542: LIST
22543: LIST
22544: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
22545: LD_VAR 0 6
22549: PPUSH
22550: CALL_OW 264
22554: PUSH
22555: LD_INT 4
22557: PUSH
22558: LD_INT 43
22560: PUSH
22561: LD_INT 25
22563: PUSH
22564: EMPTY
22565: LIST
22566: LIST
22567: LIST
22568: IN
22569: IFFALSE 22590
// points := [ 40 , 15 , 5 ] ;
22571: LD_ADDR_VAR 0 9
22575: PUSH
22576: LD_INT 40
22578: PUSH
22579: LD_INT 15
22581: PUSH
22582: LD_INT 5
22584: PUSH
22585: EMPTY
22586: LIST
22587: LIST
22588: LIST
22589: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22590: LD_VAR 0 6
22594: PPUSH
22595: CALL_OW 264
22599: PUSH
22600: LD_INT 3
22602: PUSH
22603: LD_INT 23
22605: PUSH
22606: EMPTY
22607: LIST
22608: LIST
22609: IN
22610: IFFALSE 22631
// points := [ 7 , 25 , 8 ] ;
22612: LD_ADDR_VAR 0 9
22616: PUSH
22617: LD_INT 7
22619: PUSH
22620: LD_INT 25
22622: PUSH
22623: LD_INT 8
22625: PUSH
22626: EMPTY
22627: LIST
22628: LIST
22629: LIST
22630: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22631: LD_VAR 0 6
22635: PPUSH
22636: CALL_OW 264
22640: PUSH
22641: LD_INT 5
22643: PUSH
22644: LD_INT 27
22646: PUSH
22647: LD_INT 44
22649: PUSH
22650: EMPTY
22651: LIST
22652: LIST
22653: LIST
22654: IN
22655: IFFALSE 22676
// points := [ 14 , 50 , 16 ] ;
22657: LD_ADDR_VAR 0 9
22661: PUSH
22662: LD_INT 14
22664: PUSH
22665: LD_INT 50
22667: PUSH
22668: LD_INT 16
22670: PUSH
22671: EMPTY
22672: LIST
22673: LIST
22674: LIST
22675: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22676: LD_VAR 0 6
22680: PPUSH
22681: CALL_OW 264
22685: PUSH
22686: LD_INT 6
22688: PUSH
22689: LD_INT 46
22691: PUSH
22692: EMPTY
22693: LIST
22694: LIST
22695: IN
22696: IFFALSE 22717
// points := [ 32 , 120 , 70 ] ;
22698: LD_ADDR_VAR 0 9
22702: PUSH
22703: LD_INT 32
22705: PUSH
22706: LD_INT 120
22708: PUSH
22709: LD_INT 70
22711: PUSH
22712: EMPTY
22713: LIST
22714: LIST
22715: LIST
22716: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
22717: LD_VAR 0 6
22721: PPUSH
22722: CALL_OW 264
22726: PUSH
22727: LD_INT 7
22729: PUSH
22730: LD_INT 28
22732: PUSH
22733: LD_INT 45
22735: PUSH
22736: EMPTY
22737: LIST
22738: LIST
22739: LIST
22740: IN
22741: IFFALSE 22762
// points := [ 35 , 20 , 45 ] ;
22743: LD_ADDR_VAR 0 9
22747: PUSH
22748: LD_INT 35
22750: PUSH
22751: LD_INT 20
22753: PUSH
22754: LD_INT 45
22756: PUSH
22757: EMPTY
22758: LIST
22759: LIST
22760: LIST
22761: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22762: LD_VAR 0 6
22766: PPUSH
22767: CALL_OW 264
22771: PUSH
22772: LD_INT 47
22774: PUSH
22775: EMPTY
22776: LIST
22777: IN
22778: IFFALSE 22799
// points := [ 67 , 45 , 75 ] ;
22780: LD_ADDR_VAR 0 9
22784: PUSH
22785: LD_INT 67
22787: PUSH
22788: LD_INT 45
22790: PUSH
22791: LD_INT 75
22793: PUSH
22794: EMPTY
22795: LIST
22796: LIST
22797: LIST
22798: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22799: LD_VAR 0 6
22803: PPUSH
22804: CALL_OW 264
22808: PUSH
22809: LD_INT 26
22811: PUSH
22812: EMPTY
22813: LIST
22814: IN
22815: IFFALSE 22836
// points := [ 120 , 30 , 80 ] ;
22817: LD_ADDR_VAR 0 9
22821: PUSH
22822: LD_INT 120
22824: PUSH
22825: LD_INT 30
22827: PUSH
22828: LD_INT 80
22830: PUSH
22831: EMPTY
22832: LIST
22833: LIST
22834: LIST
22835: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22836: LD_VAR 0 6
22840: PPUSH
22841: CALL_OW 264
22845: PUSH
22846: LD_INT 22
22848: PUSH
22849: EMPTY
22850: LIST
22851: IN
22852: IFFALSE 22873
// points := [ 40 , 1 , 1 ] ;
22854: LD_ADDR_VAR 0 9
22858: PUSH
22859: LD_INT 40
22861: PUSH
22862: LD_INT 1
22864: PUSH
22865: LD_INT 1
22867: PUSH
22868: EMPTY
22869: LIST
22870: LIST
22871: LIST
22872: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22873: LD_VAR 0 6
22877: PPUSH
22878: CALL_OW 264
22882: PUSH
22883: LD_INT 29
22885: PUSH
22886: EMPTY
22887: LIST
22888: IN
22889: IFFALSE 22910
// points := [ 70 , 200 , 400 ] ;
22891: LD_ADDR_VAR 0 9
22895: PUSH
22896: LD_INT 70
22898: PUSH
22899: LD_INT 200
22901: PUSH
22902: LD_INT 400
22904: PUSH
22905: EMPTY
22906: LIST
22907: LIST
22908: LIST
22909: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22910: LD_VAR 0 6
22914: PPUSH
22915: CALL_OW 264
22919: PUSH
22920: LD_INT 14
22922: PUSH
22923: LD_INT 53
22925: PUSH
22926: EMPTY
22927: LIST
22928: LIST
22929: IN
22930: IFFALSE 22951
// points := [ 40 , 10 , 20 ] ;
22932: LD_ADDR_VAR 0 9
22936: PUSH
22937: LD_INT 40
22939: PUSH
22940: LD_INT 10
22942: PUSH
22943: LD_INT 20
22945: PUSH
22946: EMPTY
22947: LIST
22948: LIST
22949: LIST
22950: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22951: LD_VAR 0 6
22955: PPUSH
22956: CALL_OW 264
22960: PUSH
22961: LD_INT 9
22963: PUSH
22964: EMPTY
22965: LIST
22966: IN
22967: IFFALSE 22988
// points := [ 5 , 70 , 20 ] ;
22969: LD_ADDR_VAR 0 9
22973: PUSH
22974: LD_INT 5
22976: PUSH
22977: LD_INT 70
22979: PUSH
22980: LD_INT 20
22982: PUSH
22983: EMPTY
22984: LIST
22985: LIST
22986: LIST
22987: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22988: LD_VAR 0 6
22992: PPUSH
22993: CALL_OW 264
22997: PUSH
22998: LD_INT 10
23000: PUSH
23001: EMPTY
23002: LIST
23003: IN
23004: IFFALSE 23025
// points := [ 35 , 110 , 70 ] ;
23006: LD_ADDR_VAR 0 9
23010: PUSH
23011: LD_INT 35
23013: PUSH
23014: LD_INT 110
23016: PUSH
23017: LD_INT 70
23019: PUSH
23020: EMPTY
23021: LIST
23022: LIST
23023: LIST
23024: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23025: LD_VAR 0 6
23029: PPUSH
23030: CALL_OW 265
23034: PUSH
23035: LD_INT 25
23037: EQUAL
23038: IFFALSE 23059
// points := [ 80 , 65 , 100 ] ;
23040: LD_ADDR_VAR 0 9
23044: PUSH
23045: LD_INT 80
23047: PUSH
23048: LD_INT 65
23050: PUSH
23051: LD_INT 100
23053: PUSH
23054: EMPTY
23055: LIST
23056: LIST
23057: LIST
23058: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
23059: LD_VAR 0 6
23063: PPUSH
23064: CALL_OW 263
23068: PUSH
23069: LD_INT 1
23071: EQUAL
23072: IFFALSE 23107
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
23074: LD_ADDR_VAR 0 10
23078: PUSH
23079: LD_VAR 0 10
23083: PUSH
23084: LD_VAR 0 6
23088: PPUSH
23089: CALL_OW 311
23093: PPUSH
23094: LD_INT 3
23096: PPUSH
23097: CALL_OW 259
23101: PUSH
23102: LD_INT 4
23104: MUL
23105: MUL
23106: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
23107: LD_VAR 0 6
23111: PPUSH
23112: CALL_OW 263
23116: PUSH
23117: LD_INT 2
23119: EQUAL
23120: IFFALSE 23171
// begin j := IsControledBy ( i ) ;
23122: LD_ADDR_VAR 0 7
23126: PUSH
23127: LD_VAR 0 6
23131: PPUSH
23132: CALL_OW 312
23136: ST_TO_ADDR
// if j then
23137: LD_VAR 0 7
23141: IFFALSE 23171
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
23143: LD_ADDR_VAR 0 10
23147: PUSH
23148: LD_VAR 0 10
23152: PUSH
23153: LD_VAR 0 7
23157: PPUSH
23158: LD_INT 3
23160: PPUSH
23161: CALL_OW 259
23165: PUSH
23166: LD_INT 3
23168: MUL
23169: MUL
23170: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23171: LD_VAR 0 6
23175: PPUSH
23176: CALL_OW 264
23180: PUSH
23181: LD_INT 5
23183: PUSH
23184: LD_INT 6
23186: PUSH
23187: LD_INT 46
23189: PUSH
23190: LD_INT 44
23192: PUSH
23193: LD_INT 47
23195: PUSH
23196: LD_INT 45
23198: PUSH
23199: LD_INT 28
23201: PUSH
23202: LD_INT 7
23204: PUSH
23205: LD_INT 27
23207: PUSH
23208: LD_INT 29
23210: PUSH
23211: EMPTY
23212: LIST
23213: LIST
23214: LIST
23215: LIST
23216: LIST
23217: LIST
23218: LIST
23219: LIST
23220: LIST
23221: LIST
23222: IN
23223: PUSH
23224: LD_VAR 0 1
23228: PPUSH
23229: LD_INT 52
23231: PPUSH
23232: CALL_OW 321
23236: PUSH
23237: LD_INT 2
23239: EQUAL
23240: AND
23241: IFFALSE 23258
// bpoints := bpoints * 1.2 ;
23243: LD_ADDR_VAR 0 10
23247: PUSH
23248: LD_VAR 0 10
23252: PUSH
23253: LD_REAL  1.20000000000000E+0000
23256: MUL
23257: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23258: LD_VAR 0 6
23262: PPUSH
23263: CALL_OW 264
23267: PUSH
23268: LD_INT 6
23270: PUSH
23271: LD_INT 46
23273: PUSH
23274: LD_INT 47
23276: PUSH
23277: EMPTY
23278: LIST
23279: LIST
23280: LIST
23281: IN
23282: IFFALSE 23299
// bpoints := bpoints * 1.2 ;
23284: LD_ADDR_VAR 0 10
23288: PUSH
23289: LD_VAR 0 10
23293: PUSH
23294: LD_REAL  1.20000000000000E+0000
23297: MUL
23298: ST_TO_ADDR
// end ; unit_building :
23299: GO 23313
23301: LD_INT 3
23303: DOUBLE
23304: EQUAL
23305: IFTRUE 23309
23307: GO 23312
23309: POP
// ; end ;
23310: GO 23313
23312: POP
// for j = 1 to 3 do
23313: LD_ADDR_VAR 0 7
23317: PUSH
23318: DOUBLE
23319: LD_INT 1
23321: DEC
23322: ST_TO_ADDR
23323: LD_INT 3
23325: PUSH
23326: FOR_TO
23327: IFFALSE 23380
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
23329: LD_ADDR_VAR 0 5
23333: PUSH
23334: LD_VAR 0 5
23338: PPUSH
23339: LD_VAR 0 7
23343: PPUSH
23344: LD_VAR 0 5
23348: PUSH
23349: LD_VAR 0 7
23353: ARRAY
23354: PUSH
23355: LD_VAR 0 9
23359: PUSH
23360: LD_VAR 0 7
23364: ARRAY
23365: PUSH
23366: LD_VAR 0 10
23370: MUL
23371: PLUS
23372: PPUSH
23373: CALL_OW 1
23377: ST_TO_ADDR
23378: GO 23326
23380: POP
23381: POP
// end ;
23382: GO 21865
23384: POP
23385: POP
// result := Replace ( result , 4 , tmp ) ;
23386: LD_ADDR_VAR 0 5
23390: PUSH
23391: LD_VAR 0 5
23395: PPUSH
23396: LD_INT 4
23398: PPUSH
23399: LD_VAR 0 8
23403: PPUSH
23404: CALL_OW 1
23408: ST_TO_ADDR
// end ;
23409: LD_VAR 0 5
23413: RET
// export function DangerAtRange ( unit , range ) ; begin
23414: LD_INT 0
23416: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23417: LD_ADDR_VAR 0 3
23421: PUSH
23422: LD_VAR 0 1
23426: PPUSH
23427: CALL_OW 255
23431: PPUSH
23432: LD_VAR 0 1
23436: PPUSH
23437: CALL_OW 250
23441: PPUSH
23442: LD_VAR 0 1
23446: PPUSH
23447: CALL_OW 251
23451: PPUSH
23452: LD_VAR 0 2
23456: PPUSH
23457: CALL 21717 0 4
23461: ST_TO_ADDR
// end ;
23462: LD_VAR 0 3
23466: RET
// export function DangerInArea ( side , area ) ; begin
23467: LD_INT 0
23469: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
23470: LD_ADDR_VAR 0 3
23474: PUSH
23475: LD_VAR 0 2
23479: PPUSH
23480: LD_INT 81
23482: PUSH
23483: LD_VAR 0 1
23487: PUSH
23488: EMPTY
23489: LIST
23490: LIST
23491: PPUSH
23492: CALL_OW 70
23496: ST_TO_ADDR
// end ;
23497: LD_VAR 0 3
23501: RET
// export function IsExtension ( b ) ; begin
23502: LD_INT 0
23504: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
23505: LD_ADDR_VAR 0 2
23509: PUSH
23510: LD_VAR 0 1
23514: PUSH
23515: LD_INT 23
23517: PUSH
23518: LD_INT 20
23520: PUSH
23521: LD_INT 22
23523: PUSH
23524: LD_INT 17
23526: PUSH
23527: LD_INT 24
23529: PUSH
23530: LD_INT 21
23532: PUSH
23533: LD_INT 19
23535: PUSH
23536: LD_INT 16
23538: PUSH
23539: LD_INT 25
23541: PUSH
23542: LD_INT 18
23544: PUSH
23545: EMPTY
23546: LIST
23547: LIST
23548: LIST
23549: LIST
23550: LIST
23551: LIST
23552: LIST
23553: LIST
23554: LIST
23555: LIST
23556: IN
23557: ST_TO_ADDR
// end ;
23558: LD_VAR 0 2
23562: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
23563: LD_INT 0
23565: PPUSH
23566: PPUSH
23567: PPUSH
// result := [ ] ;
23568: LD_ADDR_VAR 0 3
23572: PUSH
23573: EMPTY
23574: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23575: LD_ADDR_VAR 0 4
23579: PUSH
23580: LD_VAR 0 2
23584: PPUSH
23585: LD_INT 21
23587: PUSH
23588: LD_INT 3
23590: PUSH
23591: EMPTY
23592: LIST
23593: LIST
23594: PPUSH
23595: CALL_OW 70
23599: ST_TO_ADDR
// if not tmp then
23600: LD_VAR 0 4
23604: NOT
23605: IFFALSE 23609
// exit ;
23607: GO 23667
// for i in tmp do
23609: LD_ADDR_VAR 0 5
23613: PUSH
23614: LD_VAR 0 4
23618: PUSH
23619: FOR_IN
23620: IFFALSE 23655
// if GetBase ( i ) <> base then
23622: LD_VAR 0 5
23626: PPUSH
23627: CALL_OW 274
23631: PUSH
23632: LD_VAR 0 1
23636: NONEQUAL
23637: IFFALSE 23653
// ComLinkToBase ( base , i ) ;
23639: LD_VAR 0 1
23643: PPUSH
23644: LD_VAR 0 5
23648: PPUSH
23649: CALL_OW 169
23653: GO 23619
23655: POP
23656: POP
// result := tmp ;
23657: LD_ADDR_VAR 0 3
23661: PUSH
23662: LD_VAR 0 4
23666: ST_TO_ADDR
// end ;
23667: LD_VAR 0 3
23671: RET
// export function ComComplete ( unit , b ) ; var i ; begin
23672: LD_INT 0
23674: PPUSH
23675: PPUSH
// if BuildingStatus ( b ) = bs_build then
23676: LD_VAR 0 2
23680: PPUSH
23681: CALL_OW 461
23685: PUSH
23686: LD_INT 1
23688: EQUAL
23689: IFFALSE 23749
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23691: LD_VAR 0 1
23695: PPUSH
23696: LD_STRING h
23698: PUSH
23699: LD_VAR 0 2
23703: PPUSH
23704: CALL_OW 250
23708: PUSH
23709: LD_VAR 0 2
23713: PPUSH
23714: CALL_OW 251
23718: PUSH
23719: LD_VAR 0 2
23723: PUSH
23724: LD_INT 0
23726: PUSH
23727: LD_INT 0
23729: PUSH
23730: LD_INT 0
23732: PUSH
23733: EMPTY
23734: LIST
23735: LIST
23736: LIST
23737: LIST
23738: LIST
23739: LIST
23740: LIST
23741: PUSH
23742: EMPTY
23743: LIST
23744: PPUSH
23745: CALL_OW 446
// end ;
23749: LD_VAR 0 3
23753: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23754: LD_INT 0
23756: PPUSH
23757: PPUSH
23758: PPUSH
23759: PPUSH
23760: PPUSH
23761: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
23762: LD_VAR 0 1
23766: NOT
23767: PUSH
23768: LD_VAR 0 1
23772: PPUSH
23773: CALL_OW 263
23777: PUSH
23778: LD_INT 2
23780: EQUAL
23781: NOT
23782: OR
23783: IFFALSE 23787
// exit ;
23785: GO 24103
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23787: LD_ADDR_VAR 0 6
23791: PUSH
23792: LD_INT 22
23794: PUSH
23795: LD_VAR 0 1
23799: PPUSH
23800: CALL_OW 255
23804: PUSH
23805: EMPTY
23806: LIST
23807: LIST
23808: PUSH
23809: LD_INT 2
23811: PUSH
23812: LD_INT 30
23814: PUSH
23815: LD_INT 36
23817: PUSH
23818: EMPTY
23819: LIST
23820: LIST
23821: PUSH
23822: LD_INT 34
23824: PUSH
23825: LD_INT 31
23827: PUSH
23828: EMPTY
23829: LIST
23830: LIST
23831: PUSH
23832: EMPTY
23833: LIST
23834: LIST
23835: LIST
23836: PUSH
23837: EMPTY
23838: LIST
23839: LIST
23840: PPUSH
23841: CALL_OW 69
23845: ST_TO_ADDR
// if not tmp then
23846: LD_VAR 0 6
23850: NOT
23851: IFFALSE 23855
// exit ;
23853: GO 24103
// result := [ ] ;
23855: LD_ADDR_VAR 0 2
23859: PUSH
23860: EMPTY
23861: ST_TO_ADDR
// for i in tmp do
23862: LD_ADDR_VAR 0 3
23866: PUSH
23867: LD_VAR 0 6
23871: PUSH
23872: FOR_IN
23873: IFFALSE 23944
// begin t := UnitsInside ( i ) ;
23875: LD_ADDR_VAR 0 4
23879: PUSH
23880: LD_VAR 0 3
23884: PPUSH
23885: CALL_OW 313
23889: ST_TO_ADDR
// if t then
23890: LD_VAR 0 4
23894: IFFALSE 23942
// for j in t do
23896: LD_ADDR_VAR 0 7
23900: PUSH
23901: LD_VAR 0 4
23905: PUSH
23906: FOR_IN
23907: IFFALSE 23940
// result := Insert ( result , result + 1 , j ) ;
23909: LD_ADDR_VAR 0 2
23913: PUSH
23914: LD_VAR 0 2
23918: PPUSH
23919: LD_VAR 0 2
23923: PUSH
23924: LD_INT 1
23926: PLUS
23927: PPUSH
23928: LD_VAR 0 7
23932: PPUSH
23933: CALL_OW 2
23937: ST_TO_ADDR
23938: GO 23906
23940: POP
23941: POP
// end ;
23942: GO 23872
23944: POP
23945: POP
// if not result then
23946: LD_VAR 0 2
23950: NOT
23951: IFFALSE 23955
// exit ;
23953: GO 24103
// mech := result [ 1 ] ;
23955: LD_ADDR_VAR 0 5
23959: PUSH
23960: LD_VAR 0 2
23964: PUSH
23965: LD_INT 1
23967: ARRAY
23968: ST_TO_ADDR
// if result > 1 then
23969: LD_VAR 0 2
23973: PUSH
23974: LD_INT 1
23976: GREATER
23977: IFFALSE 24089
// for i = 2 to result do
23979: LD_ADDR_VAR 0 3
23983: PUSH
23984: DOUBLE
23985: LD_INT 2
23987: DEC
23988: ST_TO_ADDR
23989: LD_VAR 0 2
23993: PUSH
23994: FOR_TO
23995: IFFALSE 24087
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23997: LD_ADDR_VAR 0 4
24001: PUSH
24002: LD_VAR 0 2
24006: PUSH
24007: LD_VAR 0 3
24011: ARRAY
24012: PPUSH
24013: LD_INT 3
24015: PPUSH
24016: CALL_OW 259
24020: PUSH
24021: LD_VAR 0 2
24025: PUSH
24026: LD_VAR 0 3
24030: ARRAY
24031: PPUSH
24032: CALL_OW 432
24036: MINUS
24037: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
24038: LD_VAR 0 4
24042: PUSH
24043: LD_VAR 0 5
24047: PPUSH
24048: LD_INT 3
24050: PPUSH
24051: CALL_OW 259
24055: PUSH
24056: LD_VAR 0 5
24060: PPUSH
24061: CALL_OW 432
24065: MINUS
24066: GREATEREQUAL
24067: IFFALSE 24085
// mech := result [ i ] ;
24069: LD_ADDR_VAR 0 5
24073: PUSH
24074: LD_VAR 0 2
24078: PUSH
24079: LD_VAR 0 3
24083: ARRAY
24084: ST_TO_ADDR
// end ;
24085: GO 23994
24087: POP
24088: POP
// ComLinkTo ( vehicle , mech ) ;
24089: LD_VAR 0 1
24093: PPUSH
24094: LD_VAR 0 5
24098: PPUSH
24099: CALL_OW 135
// end ;
24103: LD_VAR 0 2
24107: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
24108: LD_INT 0
24110: PPUSH
24111: PPUSH
24112: PPUSH
24113: PPUSH
24114: PPUSH
24115: PPUSH
24116: PPUSH
24117: PPUSH
24118: PPUSH
24119: PPUSH
24120: PPUSH
24121: PPUSH
24122: PPUSH
// result := [ ] ;
24123: LD_ADDR_VAR 0 7
24127: PUSH
24128: EMPTY
24129: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
24130: LD_VAR 0 1
24134: PPUSH
24135: CALL_OW 266
24139: PUSH
24140: LD_INT 0
24142: PUSH
24143: LD_INT 1
24145: PUSH
24146: EMPTY
24147: LIST
24148: LIST
24149: IN
24150: NOT
24151: IFFALSE 24155
// exit ;
24153: GO 25786
// if name then
24155: LD_VAR 0 3
24159: IFFALSE 24175
// SetBName ( base_dep , name ) ;
24161: LD_VAR 0 1
24165: PPUSH
24166: LD_VAR 0 3
24170: PPUSH
24171: CALL_OW 500
// base := GetBase ( base_dep ) ;
24175: LD_ADDR_VAR 0 15
24179: PUSH
24180: LD_VAR 0 1
24184: PPUSH
24185: CALL_OW 274
24189: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24190: LD_ADDR_VAR 0 16
24194: PUSH
24195: LD_VAR 0 1
24199: PPUSH
24200: CALL_OW 255
24204: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24205: LD_ADDR_VAR 0 17
24209: PUSH
24210: LD_VAR 0 1
24214: PPUSH
24215: CALL_OW 248
24219: ST_TO_ADDR
// if sources then
24220: LD_VAR 0 5
24224: IFFALSE 24271
// for i = 1 to 3 do
24226: LD_ADDR_VAR 0 8
24230: PUSH
24231: DOUBLE
24232: LD_INT 1
24234: DEC
24235: ST_TO_ADDR
24236: LD_INT 3
24238: PUSH
24239: FOR_TO
24240: IFFALSE 24269
// AddResourceType ( base , i , sources [ i ] ) ;
24242: LD_VAR 0 15
24246: PPUSH
24247: LD_VAR 0 8
24251: PPUSH
24252: LD_VAR 0 5
24256: PUSH
24257: LD_VAR 0 8
24261: ARRAY
24262: PPUSH
24263: CALL_OW 276
24267: GO 24239
24269: POP
24270: POP
// buildings := GetBaseBuildings ( base , area ) ;
24271: LD_ADDR_VAR 0 18
24275: PUSH
24276: LD_VAR 0 15
24280: PPUSH
24281: LD_VAR 0 2
24285: PPUSH
24286: CALL 23563 0 2
24290: ST_TO_ADDR
// InitHc ;
24291: CALL_OW 19
// InitUc ;
24295: CALL_OW 18
// uc_side := side ;
24299: LD_ADDR_OWVAR 20
24303: PUSH
24304: LD_VAR 0 16
24308: ST_TO_ADDR
// uc_nation := nation ;
24309: LD_ADDR_OWVAR 21
24313: PUSH
24314: LD_VAR 0 17
24318: ST_TO_ADDR
// if buildings then
24319: LD_VAR 0 18
24323: IFFALSE 25645
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
24325: LD_ADDR_VAR 0 19
24329: PUSH
24330: LD_VAR 0 18
24334: PPUSH
24335: LD_INT 2
24337: PUSH
24338: LD_INT 30
24340: PUSH
24341: LD_INT 29
24343: PUSH
24344: EMPTY
24345: LIST
24346: LIST
24347: PUSH
24348: LD_INT 30
24350: PUSH
24351: LD_INT 30
24353: PUSH
24354: EMPTY
24355: LIST
24356: LIST
24357: PUSH
24358: EMPTY
24359: LIST
24360: LIST
24361: LIST
24362: PPUSH
24363: CALL_OW 72
24367: ST_TO_ADDR
// if tmp then
24368: LD_VAR 0 19
24372: IFFALSE 24420
// for i in tmp do
24374: LD_ADDR_VAR 0 8
24378: PUSH
24379: LD_VAR 0 19
24383: PUSH
24384: FOR_IN
24385: IFFALSE 24418
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24387: LD_VAR 0 8
24391: PPUSH
24392: CALL_OW 250
24396: PPUSH
24397: LD_VAR 0 8
24401: PPUSH
24402: CALL_OW 251
24406: PPUSH
24407: LD_VAR 0 16
24411: PPUSH
24412: CALL_OW 441
24416: GO 24384
24418: POP
24419: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24420: LD_VAR 0 18
24424: PPUSH
24425: LD_INT 2
24427: PUSH
24428: LD_INT 30
24430: PUSH
24431: LD_INT 32
24433: PUSH
24434: EMPTY
24435: LIST
24436: LIST
24437: PUSH
24438: LD_INT 30
24440: PUSH
24441: LD_INT 33
24443: PUSH
24444: EMPTY
24445: LIST
24446: LIST
24447: PUSH
24448: EMPTY
24449: LIST
24450: LIST
24451: LIST
24452: PPUSH
24453: CALL_OW 72
24457: IFFALSE 24545
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
24459: LD_ADDR_VAR 0 8
24463: PUSH
24464: LD_VAR 0 18
24468: PPUSH
24469: LD_INT 2
24471: PUSH
24472: LD_INT 30
24474: PUSH
24475: LD_INT 32
24477: PUSH
24478: EMPTY
24479: LIST
24480: LIST
24481: PUSH
24482: LD_INT 30
24484: PUSH
24485: LD_INT 33
24487: PUSH
24488: EMPTY
24489: LIST
24490: LIST
24491: PUSH
24492: EMPTY
24493: LIST
24494: LIST
24495: LIST
24496: PPUSH
24497: CALL_OW 72
24501: PUSH
24502: FOR_IN
24503: IFFALSE 24543
// begin if not GetBWeapon ( i ) then
24505: LD_VAR 0 8
24509: PPUSH
24510: CALL_OW 269
24514: NOT
24515: IFFALSE 24541
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
24517: LD_VAR 0 8
24521: PPUSH
24522: LD_VAR 0 8
24526: PPUSH
24527: LD_VAR 0 2
24531: PPUSH
24532: CALL 25791 0 2
24536: PPUSH
24537: CALL_OW 431
// end ;
24541: GO 24502
24543: POP
24544: POP
// end ; for i = 1 to personel do
24545: LD_ADDR_VAR 0 8
24549: PUSH
24550: DOUBLE
24551: LD_INT 1
24553: DEC
24554: ST_TO_ADDR
24555: LD_VAR 0 6
24559: PUSH
24560: FOR_TO
24561: IFFALSE 25625
// begin if i > 4 then
24563: LD_VAR 0 8
24567: PUSH
24568: LD_INT 4
24570: GREATER
24571: IFFALSE 24575
// break ;
24573: GO 25625
// case i of 1 :
24575: LD_VAR 0 8
24579: PUSH
24580: LD_INT 1
24582: DOUBLE
24583: EQUAL
24584: IFTRUE 24588
24586: GO 24668
24588: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24589: LD_ADDR_VAR 0 12
24593: PUSH
24594: LD_VAR 0 18
24598: PPUSH
24599: LD_INT 22
24601: PUSH
24602: LD_VAR 0 16
24606: PUSH
24607: EMPTY
24608: LIST
24609: LIST
24610: PUSH
24611: LD_INT 58
24613: PUSH
24614: EMPTY
24615: LIST
24616: PUSH
24617: LD_INT 2
24619: PUSH
24620: LD_INT 30
24622: PUSH
24623: LD_INT 32
24625: PUSH
24626: EMPTY
24627: LIST
24628: LIST
24629: PUSH
24630: LD_INT 30
24632: PUSH
24633: LD_INT 4
24635: PUSH
24636: EMPTY
24637: LIST
24638: LIST
24639: PUSH
24640: LD_INT 30
24642: PUSH
24643: LD_INT 5
24645: PUSH
24646: EMPTY
24647: LIST
24648: LIST
24649: PUSH
24650: EMPTY
24651: LIST
24652: LIST
24653: LIST
24654: LIST
24655: PUSH
24656: EMPTY
24657: LIST
24658: LIST
24659: LIST
24660: PPUSH
24661: CALL_OW 72
24665: ST_TO_ADDR
24666: GO 24890
24668: LD_INT 2
24670: DOUBLE
24671: EQUAL
24672: IFTRUE 24676
24674: GO 24738
24676: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24677: LD_ADDR_VAR 0 12
24681: PUSH
24682: LD_VAR 0 18
24686: PPUSH
24687: LD_INT 22
24689: PUSH
24690: LD_VAR 0 16
24694: PUSH
24695: EMPTY
24696: LIST
24697: LIST
24698: PUSH
24699: LD_INT 2
24701: PUSH
24702: LD_INT 30
24704: PUSH
24705: LD_INT 0
24707: PUSH
24708: EMPTY
24709: LIST
24710: LIST
24711: PUSH
24712: LD_INT 30
24714: PUSH
24715: LD_INT 1
24717: PUSH
24718: EMPTY
24719: LIST
24720: LIST
24721: PUSH
24722: EMPTY
24723: LIST
24724: LIST
24725: LIST
24726: PUSH
24727: EMPTY
24728: LIST
24729: LIST
24730: PPUSH
24731: CALL_OW 72
24735: ST_TO_ADDR
24736: GO 24890
24738: LD_INT 3
24740: DOUBLE
24741: EQUAL
24742: IFTRUE 24746
24744: GO 24808
24746: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24747: LD_ADDR_VAR 0 12
24751: PUSH
24752: LD_VAR 0 18
24756: PPUSH
24757: LD_INT 22
24759: PUSH
24760: LD_VAR 0 16
24764: PUSH
24765: EMPTY
24766: LIST
24767: LIST
24768: PUSH
24769: LD_INT 2
24771: PUSH
24772: LD_INT 30
24774: PUSH
24775: LD_INT 2
24777: PUSH
24778: EMPTY
24779: LIST
24780: LIST
24781: PUSH
24782: LD_INT 30
24784: PUSH
24785: LD_INT 3
24787: PUSH
24788: EMPTY
24789: LIST
24790: LIST
24791: PUSH
24792: EMPTY
24793: LIST
24794: LIST
24795: LIST
24796: PUSH
24797: EMPTY
24798: LIST
24799: LIST
24800: PPUSH
24801: CALL_OW 72
24805: ST_TO_ADDR
24806: GO 24890
24808: LD_INT 4
24810: DOUBLE
24811: EQUAL
24812: IFTRUE 24816
24814: GO 24889
24816: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24817: LD_ADDR_VAR 0 12
24821: PUSH
24822: LD_VAR 0 18
24826: PPUSH
24827: LD_INT 22
24829: PUSH
24830: LD_VAR 0 16
24834: PUSH
24835: EMPTY
24836: LIST
24837: LIST
24838: PUSH
24839: LD_INT 2
24841: PUSH
24842: LD_INT 30
24844: PUSH
24845: LD_INT 6
24847: PUSH
24848: EMPTY
24849: LIST
24850: LIST
24851: PUSH
24852: LD_INT 30
24854: PUSH
24855: LD_INT 7
24857: PUSH
24858: EMPTY
24859: LIST
24860: LIST
24861: PUSH
24862: LD_INT 30
24864: PUSH
24865: LD_INT 8
24867: PUSH
24868: EMPTY
24869: LIST
24870: LIST
24871: PUSH
24872: EMPTY
24873: LIST
24874: LIST
24875: LIST
24876: LIST
24877: PUSH
24878: EMPTY
24879: LIST
24880: LIST
24881: PPUSH
24882: CALL_OW 72
24886: ST_TO_ADDR
24887: GO 24890
24889: POP
// if i = 1 then
24890: LD_VAR 0 8
24894: PUSH
24895: LD_INT 1
24897: EQUAL
24898: IFFALSE 25009
// begin tmp := [ ] ;
24900: LD_ADDR_VAR 0 19
24904: PUSH
24905: EMPTY
24906: ST_TO_ADDR
// for j in f do
24907: LD_ADDR_VAR 0 9
24911: PUSH
24912: LD_VAR 0 12
24916: PUSH
24917: FOR_IN
24918: IFFALSE 24991
// if GetBType ( j ) = b_bunker then
24920: LD_VAR 0 9
24924: PPUSH
24925: CALL_OW 266
24929: PUSH
24930: LD_INT 32
24932: EQUAL
24933: IFFALSE 24960
// tmp := Insert ( tmp , 1 , j ) else
24935: LD_ADDR_VAR 0 19
24939: PUSH
24940: LD_VAR 0 19
24944: PPUSH
24945: LD_INT 1
24947: PPUSH
24948: LD_VAR 0 9
24952: PPUSH
24953: CALL_OW 2
24957: ST_TO_ADDR
24958: GO 24989
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24960: LD_ADDR_VAR 0 19
24964: PUSH
24965: LD_VAR 0 19
24969: PPUSH
24970: LD_VAR 0 19
24974: PUSH
24975: LD_INT 1
24977: PLUS
24978: PPUSH
24979: LD_VAR 0 9
24983: PPUSH
24984: CALL_OW 2
24988: ST_TO_ADDR
24989: GO 24917
24991: POP
24992: POP
// if tmp then
24993: LD_VAR 0 19
24997: IFFALSE 25009
// f := tmp ;
24999: LD_ADDR_VAR 0 12
25003: PUSH
25004: LD_VAR 0 19
25008: ST_TO_ADDR
// end ; x := personel [ i ] ;
25009: LD_ADDR_VAR 0 13
25013: PUSH
25014: LD_VAR 0 6
25018: PUSH
25019: LD_VAR 0 8
25023: ARRAY
25024: ST_TO_ADDR
// if x = - 1 then
25025: LD_VAR 0 13
25029: PUSH
25030: LD_INT 1
25032: NEG
25033: EQUAL
25034: IFFALSE 25243
// begin for j in f do
25036: LD_ADDR_VAR 0 9
25040: PUSH
25041: LD_VAR 0 12
25045: PUSH
25046: FOR_IN
25047: IFFALSE 25239
// repeat InitHc ;
25049: CALL_OW 19
// if GetBType ( j ) = b_barracks then
25053: LD_VAR 0 9
25057: PPUSH
25058: CALL_OW 266
25062: PUSH
25063: LD_INT 5
25065: EQUAL
25066: IFFALSE 25136
// begin if UnitsInside ( j ) < 3 then
25068: LD_VAR 0 9
25072: PPUSH
25073: CALL_OW 313
25077: PUSH
25078: LD_INT 3
25080: LESS
25081: IFFALSE 25117
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25083: LD_INT 0
25085: PPUSH
25086: LD_INT 5
25088: PUSH
25089: LD_INT 8
25091: PUSH
25092: LD_INT 9
25094: PUSH
25095: EMPTY
25096: LIST
25097: LIST
25098: LIST
25099: PUSH
25100: LD_VAR 0 17
25104: ARRAY
25105: PPUSH
25106: LD_VAR 0 4
25110: PPUSH
25111: CALL_OW 380
25115: GO 25134
// PrepareHuman ( false , i , skill ) ;
25117: LD_INT 0
25119: PPUSH
25120: LD_VAR 0 8
25124: PPUSH
25125: LD_VAR 0 4
25129: PPUSH
25130: CALL_OW 380
// end else
25134: GO 25153
// PrepareHuman ( false , i , skill ) ;
25136: LD_INT 0
25138: PPUSH
25139: LD_VAR 0 8
25143: PPUSH
25144: LD_VAR 0 4
25148: PPUSH
25149: CALL_OW 380
// un := CreateHuman ;
25153: LD_ADDR_VAR 0 14
25157: PUSH
25158: CALL_OW 44
25162: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25163: LD_ADDR_VAR 0 7
25167: PUSH
25168: LD_VAR 0 7
25172: PPUSH
25173: LD_INT 1
25175: PPUSH
25176: LD_VAR 0 14
25180: PPUSH
25181: CALL_OW 2
25185: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25186: LD_VAR 0 14
25190: PPUSH
25191: LD_VAR 0 9
25195: PPUSH
25196: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25200: LD_VAR 0 9
25204: PPUSH
25205: CALL_OW 313
25209: PUSH
25210: LD_INT 6
25212: EQUAL
25213: PUSH
25214: LD_VAR 0 9
25218: PPUSH
25219: CALL_OW 266
25223: PUSH
25224: LD_INT 32
25226: PUSH
25227: LD_INT 31
25229: PUSH
25230: EMPTY
25231: LIST
25232: LIST
25233: IN
25234: OR
25235: IFFALSE 25049
25237: GO 25046
25239: POP
25240: POP
// end else
25241: GO 25623
// for j = 1 to x do
25243: LD_ADDR_VAR 0 9
25247: PUSH
25248: DOUBLE
25249: LD_INT 1
25251: DEC
25252: ST_TO_ADDR
25253: LD_VAR 0 13
25257: PUSH
25258: FOR_TO
25259: IFFALSE 25621
// begin InitHc ;
25261: CALL_OW 19
// if not f then
25265: LD_VAR 0 12
25269: NOT
25270: IFFALSE 25359
// begin PrepareHuman ( false , i , skill ) ;
25272: LD_INT 0
25274: PPUSH
25275: LD_VAR 0 8
25279: PPUSH
25280: LD_VAR 0 4
25284: PPUSH
25285: CALL_OW 380
// un := CreateHuman ;
25289: LD_ADDR_VAR 0 14
25293: PUSH
25294: CALL_OW 44
25298: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25299: LD_ADDR_VAR 0 7
25303: PUSH
25304: LD_VAR 0 7
25308: PPUSH
25309: LD_INT 1
25311: PPUSH
25312: LD_VAR 0 14
25316: PPUSH
25317: CALL_OW 2
25321: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25322: LD_VAR 0 14
25326: PPUSH
25327: LD_VAR 0 1
25331: PPUSH
25332: CALL_OW 250
25336: PPUSH
25337: LD_VAR 0 1
25341: PPUSH
25342: CALL_OW 251
25346: PPUSH
25347: LD_INT 10
25349: PPUSH
25350: LD_INT 0
25352: PPUSH
25353: CALL_OW 50
// continue ;
25357: GO 25258
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25359: LD_VAR 0 12
25363: PUSH
25364: LD_INT 1
25366: ARRAY
25367: PPUSH
25368: CALL_OW 313
25372: PUSH
25373: LD_VAR 0 12
25377: PUSH
25378: LD_INT 1
25380: ARRAY
25381: PPUSH
25382: CALL_OW 266
25386: PUSH
25387: LD_INT 32
25389: PUSH
25390: LD_INT 31
25392: PUSH
25393: EMPTY
25394: LIST
25395: LIST
25396: IN
25397: AND
25398: PUSH
25399: LD_VAR 0 12
25403: PUSH
25404: LD_INT 1
25406: ARRAY
25407: PPUSH
25408: CALL_OW 313
25412: PUSH
25413: LD_INT 6
25415: EQUAL
25416: OR
25417: IFFALSE 25437
// f := Delete ( f , 1 ) ;
25419: LD_ADDR_VAR 0 12
25423: PUSH
25424: LD_VAR 0 12
25428: PPUSH
25429: LD_INT 1
25431: PPUSH
25432: CALL_OW 3
25436: ST_TO_ADDR
// if not f then
25437: LD_VAR 0 12
25441: NOT
25442: IFFALSE 25460
// begin x := x + 2 ;
25444: LD_ADDR_VAR 0 13
25448: PUSH
25449: LD_VAR 0 13
25453: PUSH
25454: LD_INT 2
25456: PLUS
25457: ST_TO_ADDR
// continue ;
25458: GO 25258
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
25460: LD_VAR 0 12
25464: PUSH
25465: LD_INT 1
25467: ARRAY
25468: PPUSH
25469: CALL_OW 266
25473: PUSH
25474: LD_INT 5
25476: EQUAL
25477: IFFALSE 25551
// begin if UnitsInside ( f [ 1 ] ) < 3 then
25479: LD_VAR 0 12
25483: PUSH
25484: LD_INT 1
25486: ARRAY
25487: PPUSH
25488: CALL_OW 313
25492: PUSH
25493: LD_INT 3
25495: LESS
25496: IFFALSE 25532
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25498: LD_INT 0
25500: PPUSH
25501: LD_INT 5
25503: PUSH
25504: LD_INT 8
25506: PUSH
25507: LD_INT 9
25509: PUSH
25510: EMPTY
25511: LIST
25512: LIST
25513: LIST
25514: PUSH
25515: LD_VAR 0 17
25519: ARRAY
25520: PPUSH
25521: LD_VAR 0 4
25525: PPUSH
25526: CALL_OW 380
25530: GO 25549
// PrepareHuman ( false , i , skill ) ;
25532: LD_INT 0
25534: PPUSH
25535: LD_VAR 0 8
25539: PPUSH
25540: LD_VAR 0 4
25544: PPUSH
25545: CALL_OW 380
// end else
25549: GO 25568
// PrepareHuman ( false , i , skill ) ;
25551: LD_INT 0
25553: PPUSH
25554: LD_VAR 0 8
25558: PPUSH
25559: LD_VAR 0 4
25563: PPUSH
25564: CALL_OW 380
// un := CreateHuman ;
25568: LD_ADDR_VAR 0 14
25572: PUSH
25573: CALL_OW 44
25577: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25578: LD_ADDR_VAR 0 7
25582: PUSH
25583: LD_VAR 0 7
25587: PPUSH
25588: LD_INT 1
25590: PPUSH
25591: LD_VAR 0 14
25595: PPUSH
25596: CALL_OW 2
25600: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25601: LD_VAR 0 14
25605: PPUSH
25606: LD_VAR 0 12
25610: PUSH
25611: LD_INT 1
25613: ARRAY
25614: PPUSH
25615: CALL_OW 52
// end ;
25619: GO 25258
25621: POP
25622: POP
// end ;
25623: GO 24560
25625: POP
25626: POP
// result := result ^ buildings ;
25627: LD_ADDR_VAR 0 7
25631: PUSH
25632: LD_VAR 0 7
25636: PUSH
25637: LD_VAR 0 18
25641: ADD
25642: ST_TO_ADDR
// end else
25643: GO 25786
// begin for i = 1 to personel do
25645: LD_ADDR_VAR 0 8
25649: PUSH
25650: DOUBLE
25651: LD_INT 1
25653: DEC
25654: ST_TO_ADDR
25655: LD_VAR 0 6
25659: PUSH
25660: FOR_TO
25661: IFFALSE 25784
// begin if i > 4 then
25663: LD_VAR 0 8
25667: PUSH
25668: LD_INT 4
25670: GREATER
25671: IFFALSE 25675
// break ;
25673: GO 25784
// x := personel [ i ] ;
25675: LD_ADDR_VAR 0 13
25679: PUSH
25680: LD_VAR 0 6
25684: PUSH
25685: LD_VAR 0 8
25689: ARRAY
25690: ST_TO_ADDR
// if x = - 1 then
25691: LD_VAR 0 13
25695: PUSH
25696: LD_INT 1
25698: NEG
25699: EQUAL
25700: IFFALSE 25704
// continue ;
25702: GO 25660
// PrepareHuman ( false , i , skill ) ;
25704: LD_INT 0
25706: PPUSH
25707: LD_VAR 0 8
25711: PPUSH
25712: LD_VAR 0 4
25716: PPUSH
25717: CALL_OW 380
// un := CreateHuman ;
25721: LD_ADDR_VAR 0 14
25725: PUSH
25726: CALL_OW 44
25730: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25731: LD_VAR 0 14
25735: PPUSH
25736: LD_VAR 0 1
25740: PPUSH
25741: CALL_OW 250
25745: PPUSH
25746: LD_VAR 0 1
25750: PPUSH
25751: CALL_OW 251
25755: PPUSH
25756: LD_INT 10
25758: PPUSH
25759: LD_INT 0
25761: PPUSH
25762: CALL_OW 50
// result := result ^ un ;
25766: LD_ADDR_VAR 0 7
25770: PUSH
25771: LD_VAR 0 7
25775: PUSH
25776: LD_VAR 0 14
25780: ADD
25781: ST_TO_ADDR
// end ;
25782: GO 25660
25784: POP
25785: POP
// end ; end ;
25786: LD_VAR 0 7
25790: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25791: LD_INT 0
25793: PPUSH
25794: PPUSH
25795: PPUSH
25796: PPUSH
25797: PPUSH
25798: PPUSH
25799: PPUSH
25800: PPUSH
25801: PPUSH
25802: PPUSH
25803: PPUSH
25804: PPUSH
25805: PPUSH
25806: PPUSH
25807: PPUSH
25808: PPUSH
// result := false ;
25809: LD_ADDR_VAR 0 3
25813: PUSH
25814: LD_INT 0
25816: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25817: LD_VAR 0 1
25821: NOT
25822: PUSH
25823: LD_VAR 0 1
25827: PPUSH
25828: CALL_OW 266
25832: PUSH
25833: LD_INT 32
25835: PUSH
25836: LD_INT 33
25838: PUSH
25839: EMPTY
25840: LIST
25841: LIST
25842: IN
25843: NOT
25844: OR
25845: IFFALSE 25849
// exit ;
25847: GO 26985
// nat := GetNation ( tower ) ;
25849: LD_ADDR_VAR 0 12
25853: PUSH
25854: LD_VAR 0 1
25858: PPUSH
25859: CALL_OW 248
25863: ST_TO_ADDR
// side := GetSide ( tower ) ;
25864: LD_ADDR_VAR 0 16
25868: PUSH
25869: LD_VAR 0 1
25873: PPUSH
25874: CALL_OW 255
25878: ST_TO_ADDR
// x := GetX ( tower ) ;
25879: LD_ADDR_VAR 0 10
25883: PUSH
25884: LD_VAR 0 1
25888: PPUSH
25889: CALL_OW 250
25893: ST_TO_ADDR
// y := GetY ( tower ) ;
25894: LD_ADDR_VAR 0 11
25898: PUSH
25899: LD_VAR 0 1
25903: PPUSH
25904: CALL_OW 251
25908: ST_TO_ADDR
// if not x or not y then
25909: LD_VAR 0 10
25913: NOT
25914: PUSH
25915: LD_VAR 0 11
25919: NOT
25920: OR
25921: IFFALSE 25925
// exit ;
25923: GO 26985
// weapon := 0 ;
25925: LD_ADDR_VAR 0 18
25929: PUSH
25930: LD_INT 0
25932: ST_TO_ADDR
// fac_list := [ ] ;
25933: LD_ADDR_VAR 0 17
25937: PUSH
25938: EMPTY
25939: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
25940: LD_ADDR_VAR 0 6
25944: PUSH
25945: LD_VAR 0 1
25949: PPUSH
25950: CALL_OW 274
25954: PPUSH
25955: LD_VAR 0 2
25959: PPUSH
25960: CALL 23563 0 2
25964: PPUSH
25965: LD_INT 30
25967: PUSH
25968: LD_INT 3
25970: PUSH
25971: EMPTY
25972: LIST
25973: LIST
25974: PPUSH
25975: CALL_OW 72
25979: ST_TO_ADDR
// if not factories then
25980: LD_VAR 0 6
25984: NOT
25985: IFFALSE 25989
// exit ;
25987: GO 26985
// for i in factories do
25989: LD_ADDR_VAR 0 8
25993: PUSH
25994: LD_VAR 0 6
25998: PUSH
25999: FOR_IN
26000: IFFALSE 26025
// fac_list := fac_list union AvailableWeaponList ( i ) ;
26002: LD_ADDR_VAR 0 17
26006: PUSH
26007: LD_VAR 0 17
26011: PUSH
26012: LD_VAR 0 8
26016: PPUSH
26017: CALL_OW 478
26021: UNION
26022: ST_TO_ADDR
26023: GO 25999
26025: POP
26026: POP
// if not fac_list then
26027: LD_VAR 0 17
26031: NOT
26032: IFFALSE 26036
// exit ;
26034: GO 26985
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
26036: LD_ADDR_VAR 0 5
26040: PUSH
26041: LD_INT 4
26043: PUSH
26044: LD_INT 5
26046: PUSH
26047: LD_INT 9
26049: PUSH
26050: LD_INT 10
26052: PUSH
26053: LD_INT 6
26055: PUSH
26056: LD_INT 7
26058: PUSH
26059: LD_INT 11
26061: PUSH
26062: EMPTY
26063: LIST
26064: LIST
26065: LIST
26066: LIST
26067: LIST
26068: LIST
26069: LIST
26070: PUSH
26071: LD_INT 27
26073: PUSH
26074: LD_INT 28
26076: PUSH
26077: LD_INT 26
26079: PUSH
26080: LD_INT 30
26082: PUSH
26083: EMPTY
26084: LIST
26085: LIST
26086: LIST
26087: LIST
26088: PUSH
26089: LD_INT 43
26091: PUSH
26092: LD_INT 44
26094: PUSH
26095: LD_INT 46
26097: PUSH
26098: LD_INT 45
26100: PUSH
26101: LD_INT 47
26103: PUSH
26104: LD_INT 49
26106: PUSH
26107: EMPTY
26108: LIST
26109: LIST
26110: LIST
26111: LIST
26112: LIST
26113: LIST
26114: PUSH
26115: EMPTY
26116: LIST
26117: LIST
26118: LIST
26119: PUSH
26120: LD_VAR 0 12
26124: ARRAY
26125: ST_TO_ADDR
// for i in list do
26126: LD_ADDR_VAR 0 8
26130: PUSH
26131: LD_VAR 0 5
26135: PUSH
26136: FOR_IN
26137: IFFALSE 26170
// if not i in fac_list then
26139: LD_VAR 0 8
26143: PUSH
26144: LD_VAR 0 17
26148: IN
26149: NOT
26150: IFFALSE 26168
// list := list diff i ;
26152: LD_ADDR_VAR 0 5
26156: PUSH
26157: LD_VAR 0 5
26161: PUSH
26162: LD_VAR 0 8
26166: DIFF
26167: ST_TO_ADDR
26168: GO 26136
26170: POP
26171: POP
// if not list then
26172: LD_VAR 0 5
26176: NOT
26177: IFFALSE 26181
// exit ;
26179: GO 26985
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26181: LD_VAR 0 12
26185: PUSH
26186: LD_INT 3
26188: EQUAL
26189: PUSH
26190: LD_INT 49
26192: PUSH
26193: LD_VAR 0 5
26197: IN
26198: AND
26199: PUSH
26200: LD_INT 31
26202: PPUSH
26203: LD_VAR 0 16
26207: PPUSH
26208: CALL_OW 321
26212: PUSH
26213: LD_INT 2
26215: EQUAL
26216: AND
26217: IFFALSE 26277
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26219: LD_INT 22
26221: PUSH
26222: LD_VAR 0 16
26226: PUSH
26227: EMPTY
26228: LIST
26229: LIST
26230: PUSH
26231: LD_INT 35
26233: PUSH
26234: LD_INT 49
26236: PUSH
26237: EMPTY
26238: LIST
26239: LIST
26240: PUSH
26241: LD_INT 91
26243: PUSH
26244: LD_VAR 0 1
26248: PUSH
26249: LD_INT 10
26251: PUSH
26252: EMPTY
26253: LIST
26254: LIST
26255: LIST
26256: PUSH
26257: EMPTY
26258: LIST
26259: LIST
26260: LIST
26261: PPUSH
26262: CALL_OW 69
26266: NOT
26267: IFFALSE 26277
// weapon := ru_time_lapser ;
26269: LD_ADDR_VAR 0 18
26273: PUSH
26274: LD_INT 49
26276: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26277: LD_VAR 0 12
26281: PUSH
26282: LD_INT 1
26284: PUSH
26285: LD_INT 2
26287: PUSH
26288: EMPTY
26289: LIST
26290: LIST
26291: IN
26292: PUSH
26293: LD_INT 11
26295: PUSH
26296: LD_VAR 0 5
26300: IN
26301: PUSH
26302: LD_INT 30
26304: PUSH
26305: LD_VAR 0 5
26309: IN
26310: OR
26311: AND
26312: PUSH
26313: LD_INT 6
26315: PPUSH
26316: LD_VAR 0 16
26320: PPUSH
26321: CALL_OW 321
26325: PUSH
26326: LD_INT 2
26328: EQUAL
26329: AND
26330: IFFALSE 26495
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
26332: LD_INT 22
26334: PUSH
26335: LD_VAR 0 16
26339: PUSH
26340: EMPTY
26341: LIST
26342: LIST
26343: PUSH
26344: LD_INT 2
26346: PUSH
26347: LD_INT 35
26349: PUSH
26350: LD_INT 11
26352: PUSH
26353: EMPTY
26354: LIST
26355: LIST
26356: PUSH
26357: LD_INT 35
26359: PUSH
26360: LD_INT 30
26362: PUSH
26363: EMPTY
26364: LIST
26365: LIST
26366: PUSH
26367: EMPTY
26368: LIST
26369: LIST
26370: LIST
26371: PUSH
26372: LD_INT 91
26374: PUSH
26375: LD_VAR 0 1
26379: PUSH
26380: LD_INT 18
26382: PUSH
26383: EMPTY
26384: LIST
26385: LIST
26386: LIST
26387: PUSH
26388: EMPTY
26389: LIST
26390: LIST
26391: LIST
26392: PPUSH
26393: CALL_OW 69
26397: NOT
26398: PUSH
26399: LD_INT 22
26401: PUSH
26402: LD_VAR 0 16
26406: PUSH
26407: EMPTY
26408: LIST
26409: LIST
26410: PUSH
26411: LD_INT 2
26413: PUSH
26414: LD_INT 30
26416: PUSH
26417: LD_INT 32
26419: PUSH
26420: EMPTY
26421: LIST
26422: LIST
26423: PUSH
26424: LD_INT 30
26426: PUSH
26427: LD_INT 33
26429: PUSH
26430: EMPTY
26431: LIST
26432: LIST
26433: PUSH
26434: EMPTY
26435: LIST
26436: LIST
26437: LIST
26438: PUSH
26439: LD_INT 91
26441: PUSH
26442: LD_VAR 0 1
26446: PUSH
26447: LD_INT 12
26449: PUSH
26450: EMPTY
26451: LIST
26452: LIST
26453: LIST
26454: PUSH
26455: EMPTY
26456: LIST
26457: LIST
26458: LIST
26459: PUSH
26460: EMPTY
26461: LIST
26462: PPUSH
26463: CALL_OW 69
26467: PUSH
26468: LD_INT 2
26470: GREATER
26471: AND
26472: IFFALSE 26495
// weapon := [ us_radar , ar_radar ] [ nat ] ;
26474: LD_ADDR_VAR 0 18
26478: PUSH
26479: LD_INT 11
26481: PUSH
26482: LD_INT 30
26484: PUSH
26485: EMPTY
26486: LIST
26487: LIST
26488: PUSH
26489: LD_VAR 0 12
26493: ARRAY
26494: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
26495: LD_VAR 0 18
26499: NOT
26500: PUSH
26501: LD_INT 40
26503: PPUSH
26504: LD_VAR 0 16
26508: PPUSH
26509: CALL_OW 321
26513: PUSH
26514: LD_INT 2
26516: EQUAL
26517: AND
26518: PUSH
26519: LD_INT 7
26521: PUSH
26522: LD_VAR 0 5
26526: IN
26527: PUSH
26528: LD_INT 28
26530: PUSH
26531: LD_VAR 0 5
26535: IN
26536: OR
26537: PUSH
26538: LD_INT 45
26540: PUSH
26541: LD_VAR 0 5
26545: IN
26546: OR
26547: AND
26548: IFFALSE 26802
// begin hex := GetHexInfo ( x , y ) ;
26550: LD_ADDR_VAR 0 4
26554: PUSH
26555: LD_VAR 0 10
26559: PPUSH
26560: LD_VAR 0 11
26564: PPUSH
26565: CALL_OW 546
26569: ST_TO_ADDR
// if hex [ 1 ] then
26570: LD_VAR 0 4
26574: PUSH
26575: LD_INT 1
26577: ARRAY
26578: IFFALSE 26582
// exit ;
26580: GO 26985
// height := hex [ 2 ] ;
26582: LD_ADDR_VAR 0 15
26586: PUSH
26587: LD_VAR 0 4
26591: PUSH
26592: LD_INT 2
26594: ARRAY
26595: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26596: LD_ADDR_VAR 0 14
26600: PUSH
26601: LD_INT 0
26603: PUSH
26604: LD_INT 2
26606: PUSH
26607: LD_INT 3
26609: PUSH
26610: LD_INT 5
26612: PUSH
26613: EMPTY
26614: LIST
26615: LIST
26616: LIST
26617: LIST
26618: ST_TO_ADDR
// for i in tmp do
26619: LD_ADDR_VAR 0 8
26623: PUSH
26624: LD_VAR 0 14
26628: PUSH
26629: FOR_IN
26630: IFFALSE 26800
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26632: LD_ADDR_VAR 0 9
26636: PUSH
26637: LD_VAR 0 10
26641: PPUSH
26642: LD_VAR 0 8
26646: PPUSH
26647: LD_INT 5
26649: PPUSH
26650: CALL_OW 272
26654: PUSH
26655: LD_VAR 0 11
26659: PPUSH
26660: LD_VAR 0 8
26664: PPUSH
26665: LD_INT 5
26667: PPUSH
26668: CALL_OW 273
26672: PUSH
26673: EMPTY
26674: LIST
26675: LIST
26676: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26677: LD_VAR 0 9
26681: PUSH
26682: LD_INT 1
26684: ARRAY
26685: PPUSH
26686: LD_VAR 0 9
26690: PUSH
26691: LD_INT 2
26693: ARRAY
26694: PPUSH
26695: CALL_OW 488
26699: IFFALSE 26798
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26701: LD_ADDR_VAR 0 4
26705: PUSH
26706: LD_VAR 0 9
26710: PUSH
26711: LD_INT 1
26713: ARRAY
26714: PPUSH
26715: LD_VAR 0 9
26719: PUSH
26720: LD_INT 2
26722: ARRAY
26723: PPUSH
26724: CALL_OW 546
26728: ST_TO_ADDR
// if hex [ 1 ] then
26729: LD_VAR 0 4
26733: PUSH
26734: LD_INT 1
26736: ARRAY
26737: IFFALSE 26741
// continue ;
26739: GO 26629
// h := hex [ 2 ] ;
26741: LD_ADDR_VAR 0 13
26745: PUSH
26746: LD_VAR 0 4
26750: PUSH
26751: LD_INT 2
26753: ARRAY
26754: ST_TO_ADDR
// if h + 7 < height then
26755: LD_VAR 0 13
26759: PUSH
26760: LD_INT 7
26762: PLUS
26763: PUSH
26764: LD_VAR 0 15
26768: LESS
26769: IFFALSE 26798
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26771: LD_ADDR_VAR 0 18
26775: PUSH
26776: LD_INT 7
26778: PUSH
26779: LD_INT 28
26781: PUSH
26782: LD_INT 45
26784: PUSH
26785: EMPTY
26786: LIST
26787: LIST
26788: LIST
26789: PUSH
26790: LD_VAR 0 12
26794: ARRAY
26795: ST_TO_ADDR
// break ;
26796: GO 26800
// end ; end ; end ;
26798: GO 26629
26800: POP
26801: POP
// end ; if not weapon then
26802: LD_VAR 0 18
26806: NOT
26807: IFFALSE 26867
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26809: LD_ADDR_VAR 0 5
26813: PUSH
26814: LD_VAR 0 5
26818: PUSH
26819: LD_INT 11
26821: PUSH
26822: LD_INT 30
26824: PUSH
26825: LD_INT 49
26827: PUSH
26828: EMPTY
26829: LIST
26830: LIST
26831: LIST
26832: DIFF
26833: ST_TO_ADDR
// if not list then
26834: LD_VAR 0 5
26838: NOT
26839: IFFALSE 26843
// exit ;
26841: GO 26985
// weapon := list [ rand ( 1 , list ) ] ;
26843: LD_ADDR_VAR 0 18
26847: PUSH
26848: LD_VAR 0 5
26852: PUSH
26853: LD_INT 1
26855: PPUSH
26856: LD_VAR 0 5
26860: PPUSH
26861: CALL_OW 12
26865: ARRAY
26866: ST_TO_ADDR
// end ; if weapon then
26867: LD_VAR 0 18
26871: IFFALSE 26985
// begin tmp := CostOfWeapon ( weapon ) ;
26873: LD_ADDR_VAR 0 14
26877: PUSH
26878: LD_VAR 0 18
26882: PPUSH
26883: CALL_OW 451
26887: ST_TO_ADDR
// j := GetBase ( tower ) ;
26888: LD_ADDR_VAR 0 9
26892: PUSH
26893: LD_VAR 0 1
26897: PPUSH
26898: CALL_OW 274
26902: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26903: LD_VAR 0 9
26907: PPUSH
26908: LD_INT 1
26910: PPUSH
26911: CALL_OW 275
26915: PUSH
26916: LD_VAR 0 14
26920: PUSH
26921: LD_INT 1
26923: ARRAY
26924: GREATEREQUAL
26925: PUSH
26926: LD_VAR 0 9
26930: PPUSH
26931: LD_INT 2
26933: PPUSH
26934: CALL_OW 275
26938: PUSH
26939: LD_VAR 0 14
26943: PUSH
26944: LD_INT 2
26946: ARRAY
26947: GREATEREQUAL
26948: AND
26949: PUSH
26950: LD_VAR 0 9
26954: PPUSH
26955: LD_INT 3
26957: PPUSH
26958: CALL_OW 275
26962: PUSH
26963: LD_VAR 0 14
26967: PUSH
26968: LD_INT 3
26970: ARRAY
26971: GREATEREQUAL
26972: AND
26973: IFFALSE 26985
// result := weapon ;
26975: LD_ADDR_VAR 0 3
26979: PUSH
26980: LD_VAR 0 18
26984: ST_TO_ADDR
// end ; end ;
26985: LD_VAR 0 3
26989: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26990: LD_INT 0
26992: PPUSH
26993: PPUSH
// result := true ;
26994: LD_ADDR_VAR 0 3
26998: PUSH
26999: LD_INT 1
27001: ST_TO_ADDR
// if array1 = array2 then
27002: LD_VAR 0 1
27006: PUSH
27007: LD_VAR 0 2
27011: EQUAL
27012: IFFALSE 27072
// begin for i = 1 to array1 do
27014: LD_ADDR_VAR 0 4
27018: PUSH
27019: DOUBLE
27020: LD_INT 1
27022: DEC
27023: ST_TO_ADDR
27024: LD_VAR 0 1
27028: PUSH
27029: FOR_TO
27030: IFFALSE 27068
// if array1 [ i ] <> array2 [ i ] then
27032: LD_VAR 0 1
27036: PUSH
27037: LD_VAR 0 4
27041: ARRAY
27042: PUSH
27043: LD_VAR 0 2
27047: PUSH
27048: LD_VAR 0 4
27052: ARRAY
27053: NONEQUAL
27054: IFFALSE 27066
// begin result := false ;
27056: LD_ADDR_VAR 0 3
27060: PUSH
27061: LD_INT 0
27063: ST_TO_ADDR
// break ;
27064: GO 27068
// end ;
27066: GO 27029
27068: POP
27069: POP
// end else
27070: GO 27080
// result := false ;
27072: LD_ADDR_VAR 0 3
27076: PUSH
27077: LD_INT 0
27079: ST_TO_ADDR
// end ;
27080: LD_VAR 0 3
27084: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
27085: LD_INT 0
27087: PPUSH
27088: PPUSH
27089: PPUSH
// pom := GetBase ( fac ) ;
27090: LD_ADDR_VAR 0 5
27094: PUSH
27095: LD_VAR 0 1
27099: PPUSH
27100: CALL_OW 274
27104: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
27105: LD_ADDR_VAR 0 4
27109: PUSH
27110: LD_VAR 0 2
27114: PUSH
27115: LD_INT 1
27117: ARRAY
27118: PPUSH
27119: LD_VAR 0 2
27123: PUSH
27124: LD_INT 2
27126: ARRAY
27127: PPUSH
27128: LD_VAR 0 2
27132: PUSH
27133: LD_INT 3
27135: ARRAY
27136: PPUSH
27137: LD_VAR 0 2
27141: PUSH
27142: LD_INT 4
27144: ARRAY
27145: PPUSH
27146: CALL_OW 449
27150: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27151: LD_ADDR_VAR 0 3
27155: PUSH
27156: LD_VAR 0 5
27160: PPUSH
27161: LD_INT 1
27163: PPUSH
27164: CALL_OW 275
27168: PUSH
27169: LD_VAR 0 4
27173: PUSH
27174: LD_INT 1
27176: ARRAY
27177: GREATEREQUAL
27178: PUSH
27179: LD_VAR 0 5
27183: PPUSH
27184: LD_INT 2
27186: PPUSH
27187: CALL_OW 275
27191: PUSH
27192: LD_VAR 0 4
27196: PUSH
27197: LD_INT 2
27199: ARRAY
27200: GREATEREQUAL
27201: AND
27202: PUSH
27203: LD_VAR 0 5
27207: PPUSH
27208: LD_INT 3
27210: PPUSH
27211: CALL_OW 275
27215: PUSH
27216: LD_VAR 0 4
27220: PUSH
27221: LD_INT 3
27223: ARRAY
27224: GREATEREQUAL
27225: AND
27226: ST_TO_ADDR
// end ;
27227: LD_VAR 0 3
27231: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27232: LD_INT 0
27234: PPUSH
27235: PPUSH
27236: PPUSH
27237: PPUSH
// pom := GetBase ( building ) ;
27238: LD_ADDR_VAR 0 3
27242: PUSH
27243: LD_VAR 0 1
27247: PPUSH
27248: CALL_OW 274
27252: ST_TO_ADDR
// if not pom then
27253: LD_VAR 0 3
27257: NOT
27258: IFFALSE 27262
// exit ;
27260: GO 27432
// btype := GetBType ( building ) ;
27262: LD_ADDR_VAR 0 5
27266: PUSH
27267: LD_VAR 0 1
27271: PPUSH
27272: CALL_OW 266
27276: ST_TO_ADDR
// if btype = b_armoury then
27277: LD_VAR 0 5
27281: PUSH
27282: LD_INT 4
27284: EQUAL
27285: IFFALSE 27295
// btype := b_barracks ;
27287: LD_ADDR_VAR 0 5
27291: PUSH
27292: LD_INT 5
27294: ST_TO_ADDR
// if btype = b_depot then
27295: LD_VAR 0 5
27299: PUSH
27300: LD_INT 0
27302: EQUAL
27303: IFFALSE 27313
// btype := b_warehouse ;
27305: LD_ADDR_VAR 0 5
27309: PUSH
27310: LD_INT 1
27312: ST_TO_ADDR
// if btype = b_workshop then
27313: LD_VAR 0 5
27317: PUSH
27318: LD_INT 2
27320: EQUAL
27321: IFFALSE 27331
// btype := b_factory ;
27323: LD_ADDR_VAR 0 5
27327: PUSH
27328: LD_INT 3
27330: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27331: LD_ADDR_VAR 0 4
27335: PUSH
27336: LD_VAR 0 5
27340: PPUSH
27341: LD_VAR 0 1
27345: PPUSH
27346: CALL_OW 248
27350: PPUSH
27351: CALL_OW 450
27355: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27356: LD_ADDR_VAR 0 2
27360: PUSH
27361: LD_VAR 0 3
27365: PPUSH
27366: LD_INT 1
27368: PPUSH
27369: CALL_OW 275
27373: PUSH
27374: LD_VAR 0 4
27378: PUSH
27379: LD_INT 1
27381: ARRAY
27382: GREATEREQUAL
27383: PUSH
27384: LD_VAR 0 3
27388: PPUSH
27389: LD_INT 2
27391: PPUSH
27392: CALL_OW 275
27396: PUSH
27397: LD_VAR 0 4
27401: PUSH
27402: LD_INT 2
27404: ARRAY
27405: GREATEREQUAL
27406: AND
27407: PUSH
27408: LD_VAR 0 3
27412: PPUSH
27413: LD_INT 3
27415: PPUSH
27416: CALL_OW 275
27420: PUSH
27421: LD_VAR 0 4
27425: PUSH
27426: LD_INT 3
27428: ARRAY
27429: GREATEREQUAL
27430: AND
27431: ST_TO_ADDR
// end ;
27432: LD_VAR 0 2
27436: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
27437: LD_INT 0
27439: PPUSH
27440: PPUSH
27441: PPUSH
// pom := GetBase ( building ) ;
27442: LD_ADDR_VAR 0 4
27446: PUSH
27447: LD_VAR 0 1
27451: PPUSH
27452: CALL_OW 274
27456: ST_TO_ADDR
// if not pom then
27457: LD_VAR 0 4
27461: NOT
27462: IFFALSE 27466
// exit ;
27464: GO 27567
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27466: LD_ADDR_VAR 0 5
27470: PUSH
27471: LD_VAR 0 2
27475: PPUSH
27476: LD_VAR 0 1
27480: PPUSH
27481: CALL_OW 248
27485: PPUSH
27486: CALL_OW 450
27490: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27491: LD_ADDR_VAR 0 3
27495: PUSH
27496: LD_VAR 0 4
27500: PPUSH
27501: LD_INT 1
27503: PPUSH
27504: CALL_OW 275
27508: PUSH
27509: LD_VAR 0 5
27513: PUSH
27514: LD_INT 1
27516: ARRAY
27517: GREATEREQUAL
27518: PUSH
27519: LD_VAR 0 4
27523: PPUSH
27524: LD_INT 2
27526: PPUSH
27527: CALL_OW 275
27531: PUSH
27532: LD_VAR 0 5
27536: PUSH
27537: LD_INT 2
27539: ARRAY
27540: GREATEREQUAL
27541: AND
27542: PUSH
27543: LD_VAR 0 4
27547: PPUSH
27548: LD_INT 3
27550: PPUSH
27551: CALL_OW 275
27555: PUSH
27556: LD_VAR 0 5
27560: PUSH
27561: LD_INT 3
27563: ARRAY
27564: GREATEREQUAL
27565: AND
27566: ST_TO_ADDR
// end ;
27567: LD_VAR 0 3
27571: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
27572: LD_INT 0
27574: PPUSH
27575: PPUSH
27576: PPUSH
27577: PPUSH
27578: PPUSH
27579: PPUSH
27580: PPUSH
27581: PPUSH
27582: PPUSH
27583: PPUSH
// result := false ;
27584: LD_ADDR_VAR 0 6
27588: PUSH
27589: LD_INT 0
27591: ST_TO_ADDR
// if not base or not btype or not x or not y then
27592: LD_VAR 0 1
27596: NOT
27597: PUSH
27598: LD_VAR 0 2
27602: NOT
27603: OR
27604: PUSH
27605: LD_VAR 0 3
27609: NOT
27610: OR
27611: PUSH
27612: LD_VAR 0 4
27616: NOT
27617: OR
27618: IFFALSE 27622
// exit ;
27620: GO 28231
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
27622: LD_ADDR_VAR 0 12
27626: PUSH
27627: LD_VAR 0 2
27631: PPUSH
27632: LD_VAR 0 3
27636: PPUSH
27637: LD_VAR 0 4
27641: PPUSH
27642: LD_VAR 0 5
27646: PPUSH
27647: LD_VAR 0 1
27651: PUSH
27652: LD_INT 1
27654: ARRAY
27655: PPUSH
27656: CALL_OW 248
27660: PPUSH
27661: LD_INT 0
27663: PPUSH
27664: CALL 29068 0 6
27668: ST_TO_ADDR
// if not hexes then
27669: LD_VAR 0 12
27673: NOT
27674: IFFALSE 27678
// exit ;
27676: GO 28231
// for i = 1 to hexes do
27678: LD_ADDR_VAR 0 7
27682: PUSH
27683: DOUBLE
27684: LD_INT 1
27686: DEC
27687: ST_TO_ADDR
27688: LD_VAR 0 12
27692: PUSH
27693: FOR_TO
27694: IFFALSE 28229
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27696: LD_ADDR_VAR 0 11
27700: PUSH
27701: LD_VAR 0 12
27705: PUSH
27706: LD_VAR 0 7
27710: ARRAY
27711: PUSH
27712: LD_INT 1
27714: ARRAY
27715: PPUSH
27716: LD_VAR 0 12
27720: PUSH
27721: LD_VAR 0 7
27725: ARRAY
27726: PUSH
27727: LD_INT 2
27729: ARRAY
27730: PPUSH
27731: CALL_OW 428
27735: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27736: LD_VAR 0 12
27740: PUSH
27741: LD_VAR 0 7
27745: ARRAY
27746: PUSH
27747: LD_INT 1
27749: ARRAY
27750: PPUSH
27751: LD_VAR 0 12
27755: PUSH
27756: LD_VAR 0 7
27760: ARRAY
27761: PUSH
27762: LD_INT 2
27764: ARRAY
27765: PPUSH
27766: CALL_OW 351
27770: PUSH
27771: LD_VAR 0 12
27775: PUSH
27776: LD_VAR 0 7
27780: ARRAY
27781: PUSH
27782: LD_INT 1
27784: ARRAY
27785: PPUSH
27786: LD_VAR 0 12
27790: PUSH
27791: LD_VAR 0 7
27795: ARRAY
27796: PUSH
27797: LD_INT 2
27799: ARRAY
27800: PPUSH
27801: CALL_OW 488
27805: NOT
27806: OR
27807: PUSH
27808: LD_VAR 0 11
27812: PPUSH
27813: CALL_OW 247
27817: PUSH
27818: LD_INT 3
27820: EQUAL
27821: OR
27822: IFFALSE 27828
// exit ;
27824: POP
27825: POP
27826: GO 28231
// if not tmp or not tmp in base then
27828: LD_VAR 0 11
27832: NOT
27833: PUSH
27834: LD_VAR 0 11
27838: PUSH
27839: LD_VAR 0 1
27843: IN
27844: NOT
27845: OR
27846: IFFALSE 27850
// continue ;
27848: GO 27693
// result := true ;
27850: LD_ADDR_VAR 0 6
27854: PUSH
27855: LD_INT 1
27857: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27858: LD_ADDR_VAR 0 15
27862: PUSH
27863: LD_VAR 0 1
27867: PPUSH
27868: LD_INT 22
27870: PUSH
27871: LD_VAR 0 11
27875: PPUSH
27876: CALL_OW 255
27880: PUSH
27881: EMPTY
27882: LIST
27883: LIST
27884: PUSH
27885: LD_INT 2
27887: PUSH
27888: LD_INT 30
27890: PUSH
27891: LD_INT 0
27893: PUSH
27894: EMPTY
27895: LIST
27896: LIST
27897: PUSH
27898: LD_INT 30
27900: PUSH
27901: LD_INT 1
27903: PUSH
27904: EMPTY
27905: LIST
27906: LIST
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: LIST
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: PPUSH
27917: CALL_OW 72
27921: ST_TO_ADDR
// if dep then
27922: LD_VAR 0 15
27926: IFFALSE 28062
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27928: LD_ADDR_VAR 0 14
27932: PUSH
27933: LD_VAR 0 15
27937: PUSH
27938: LD_INT 1
27940: ARRAY
27941: PPUSH
27942: CALL_OW 250
27946: PPUSH
27947: LD_VAR 0 15
27951: PUSH
27952: LD_INT 1
27954: ARRAY
27955: PPUSH
27956: CALL_OW 254
27960: PPUSH
27961: LD_INT 5
27963: PPUSH
27964: CALL_OW 272
27968: PUSH
27969: LD_VAR 0 15
27973: PUSH
27974: LD_INT 1
27976: ARRAY
27977: PPUSH
27978: CALL_OW 251
27982: PPUSH
27983: LD_VAR 0 15
27987: PUSH
27988: LD_INT 1
27990: ARRAY
27991: PPUSH
27992: CALL_OW 254
27996: PPUSH
27997: LD_INT 5
27999: PPUSH
28000: CALL_OW 273
28004: PUSH
28005: EMPTY
28006: LIST
28007: LIST
28008: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
28009: LD_VAR 0 14
28013: PUSH
28014: LD_INT 1
28016: ARRAY
28017: PPUSH
28018: LD_VAR 0 14
28022: PUSH
28023: LD_INT 2
28025: ARRAY
28026: PPUSH
28027: CALL_OW 488
28031: IFFALSE 28062
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
28033: LD_VAR 0 11
28037: PPUSH
28038: LD_VAR 0 14
28042: PUSH
28043: LD_INT 1
28045: ARRAY
28046: PPUSH
28047: LD_VAR 0 14
28051: PUSH
28052: LD_INT 2
28054: ARRAY
28055: PPUSH
28056: CALL_OW 111
// continue ;
28060: GO 27693
// end ; end ; r := GetDir ( tmp ) ;
28062: LD_ADDR_VAR 0 13
28066: PUSH
28067: LD_VAR 0 11
28071: PPUSH
28072: CALL_OW 254
28076: ST_TO_ADDR
// if r = 5 then
28077: LD_VAR 0 13
28081: PUSH
28082: LD_INT 5
28084: EQUAL
28085: IFFALSE 28095
// r := 0 ;
28087: LD_ADDR_VAR 0 13
28091: PUSH
28092: LD_INT 0
28094: ST_TO_ADDR
// for j = r to 5 do
28095: LD_ADDR_VAR 0 8
28099: PUSH
28100: DOUBLE
28101: LD_VAR 0 13
28105: DEC
28106: ST_TO_ADDR
28107: LD_INT 5
28109: PUSH
28110: FOR_TO
28111: IFFALSE 28225
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
28113: LD_ADDR_VAR 0 9
28117: PUSH
28118: LD_VAR 0 11
28122: PPUSH
28123: CALL_OW 250
28127: PPUSH
28128: LD_VAR 0 8
28132: PPUSH
28133: LD_INT 2
28135: PPUSH
28136: CALL_OW 272
28140: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
28141: LD_ADDR_VAR 0 10
28145: PUSH
28146: LD_VAR 0 11
28150: PPUSH
28151: CALL_OW 251
28155: PPUSH
28156: LD_VAR 0 8
28160: PPUSH
28161: LD_INT 2
28163: PPUSH
28164: CALL_OW 273
28168: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28169: LD_VAR 0 9
28173: PPUSH
28174: LD_VAR 0 10
28178: PPUSH
28179: CALL_OW 488
28183: PUSH
28184: LD_VAR 0 9
28188: PPUSH
28189: LD_VAR 0 10
28193: PPUSH
28194: CALL_OW 428
28198: NOT
28199: AND
28200: IFFALSE 28223
// begin ComMoveXY ( tmp , _x , _y ) ;
28202: LD_VAR 0 11
28206: PPUSH
28207: LD_VAR 0 9
28211: PPUSH
28212: LD_VAR 0 10
28216: PPUSH
28217: CALL_OW 111
// break ;
28221: GO 28225
// end ; end ;
28223: GO 28110
28225: POP
28226: POP
// end ;
28227: GO 27693
28229: POP
28230: POP
// end ;
28231: LD_VAR 0 6
28235: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
28236: LD_INT 0
28238: PPUSH
28239: PPUSH
28240: PPUSH
28241: PPUSH
28242: PPUSH
28243: PPUSH
28244: PPUSH
28245: PPUSH
28246: PPUSH
28247: PPUSH
// result := false ;
28248: LD_ADDR_VAR 0 6
28252: PUSH
28253: LD_INT 0
28255: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28256: LD_VAR 0 1
28260: NOT
28261: PUSH
28262: LD_VAR 0 1
28266: PPUSH
28267: CALL_OW 266
28271: PUSH
28272: LD_INT 0
28274: PUSH
28275: LD_INT 1
28277: PUSH
28278: EMPTY
28279: LIST
28280: LIST
28281: IN
28282: NOT
28283: OR
28284: PUSH
28285: LD_VAR 0 2
28289: NOT
28290: OR
28291: PUSH
28292: LD_VAR 0 5
28296: PUSH
28297: LD_INT 0
28299: PUSH
28300: LD_INT 1
28302: PUSH
28303: LD_INT 2
28305: PUSH
28306: LD_INT 3
28308: PUSH
28309: LD_INT 4
28311: PUSH
28312: LD_INT 5
28314: PUSH
28315: EMPTY
28316: LIST
28317: LIST
28318: LIST
28319: LIST
28320: LIST
28321: LIST
28322: IN
28323: NOT
28324: OR
28325: PUSH
28326: LD_VAR 0 3
28330: PPUSH
28331: LD_VAR 0 4
28335: PPUSH
28336: CALL_OW 488
28340: NOT
28341: OR
28342: IFFALSE 28346
// exit ;
28344: GO 29063
// pom := GetBase ( depot ) ;
28346: LD_ADDR_VAR 0 10
28350: PUSH
28351: LD_VAR 0 1
28355: PPUSH
28356: CALL_OW 274
28360: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28361: LD_ADDR_VAR 0 11
28365: PUSH
28366: LD_VAR 0 2
28370: PPUSH
28371: LD_VAR 0 1
28375: PPUSH
28376: CALL_OW 248
28380: PPUSH
28381: CALL_OW 450
28385: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28386: LD_VAR 0 10
28390: PPUSH
28391: LD_INT 1
28393: PPUSH
28394: CALL_OW 275
28398: PUSH
28399: LD_VAR 0 11
28403: PUSH
28404: LD_INT 1
28406: ARRAY
28407: GREATEREQUAL
28408: PUSH
28409: LD_VAR 0 10
28413: PPUSH
28414: LD_INT 2
28416: PPUSH
28417: CALL_OW 275
28421: PUSH
28422: LD_VAR 0 11
28426: PUSH
28427: LD_INT 2
28429: ARRAY
28430: GREATEREQUAL
28431: AND
28432: PUSH
28433: LD_VAR 0 10
28437: PPUSH
28438: LD_INT 3
28440: PPUSH
28441: CALL_OW 275
28445: PUSH
28446: LD_VAR 0 11
28450: PUSH
28451: LD_INT 3
28453: ARRAY
28454: GREATEREQUAL
28455: AND
28456: NOT
28457: IFFALSE 28461
// exit ;
28459: GO 29063
// if GetBType ( depot ) = b_depot then
28461: LD_VAR 0 1
28465: PPUSH
28466: CALL_OW 266
28470: PUSH
28471: LD_INT 0
28473: EQUAL
28474: IFFALSE 28486
// dist := 28 else
28476: LD_ADDR_VAR 0 14
28480: PUSH
28481: LD_INT 28
28483: ST_TO_ADDR
28484: GO 28494
// dist := 36 ;
28486: LD_ADDR_VAR 0 14
28490: PUSH
28491: LD_INT 36
28493: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28494: LD_VAR 0 1
28498: PPUSH
28499: LD_VAR 0 3
28503: PPUSH
28504: LD_VAR 0 4
28508: PPUSH
28509: CALL_OW 297
28513: PUSH
28514: LD_VAR 0 14
28518: GREATER
28519: IFFALSE 28523
// exit ;
28521: GO 29063
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28523: LD_ADDR_VAR 0 12
28527: PUSH
28528: LD_VAR 0 2
28532: PPUSH
28533: LD_VAR 0 3
28537: PPUSH
28538: LD_VAR 0 4
28542: PPUSH
28543: LD_VAR 0 5
28547: PPUSH
28548: LD_VAR 0 1
28552: PPUSH
28553: CALL_OW 248
28557: PPUSH
28558: LD_INT 0
28560: PPUSH
28561: CALL 29068 0 6
28565: ST_TO_ADDR
// if not hexes then
28566: LD_VAR 0 12
28570: NOT
28571: IFFALSE 28575
// exit ;
28573: GO 29063
// hex := GetHexInfo ( x , y ) ;
28575: LD_ADDR_VAR 0 15
28579: PUSH
28580: LD_VAR 0 3
28584: PPUSH
28585: LD_VAR 0 4
28589: PPUSH
28590: CALL_OW 546
28594: ST_TO_ADDR
// if hex [ 1 ] then
28595: LD_VAR 0 15
28599: PUSH
28600: LD_INT 1
28602: ARRAY
28603: IFFALSE 28607
// exit ;
28605: GO 29063
// height := hex [ 2 ] ;
28607: LD_ADDR_VAR 0 13
28611: PUSH
28612: LD_VAR 0 15
28616: PUSH
28617: LD_INT 2
28619: ARRAY
28620: ST_TO_ADDR
// for i = 1 to hexes do
28621: LD_ADDR_VAR 0 7
28625: PUSH
28626: DOUBLE
28627: LD_INT 1
28629: DEC
28630: ST_TO_ADDR
28631: LD_VAR 0 12
28635: PUSH
28636: FOR_TO
28637: IFFALSE 28967
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28639: LD_VAR 0 12
28643: PUSH
28644: LD_VAR 0 7
28648: ARRAY
28649: PUSH
28650: LD_INT 1
28652: ARRAY
28653: PPUSH
28654: LD_VAR 0 12
28658: PUSH
28659: LD_VAR 0 7
28663: ARRAY
28664: PUSH
28665: LD_INT 2
28667: ARRAY
28668: PPUSH
28669: CALL_OW 488
28673: NOT
28674: PUSH
28675: LD_VAR 0 12
28679: PUSH
28680: LD_VAR 0 7
28684: ARRAY
28685: PUSH
28686: LD_INT 1
28688: ARRAY
28689: PPUSH
28690: LD_VAR 0 12
28694: PUSH
28695: LD_VAR 0 7
28699: ARRAY
28700: PUSH
28701: LD_INT 2
28703: ARRAY
28704: PPUSH
28705: CALL_OW 428
28709: PUSH
28710: LD_INT 0
28712: GREATER
28713: OR
28714: PUSH
28715: LD_VAR 0 12
28719: PUSH
28720: LD_VAR 0 7
28724: ARRAY
28725: PUSH
28726: LD_INT 1
28728: ARRAY
28729: PPUSH
28730: LD_VAR 0 12
28734: PUSH
28735: LD_VAR 0 7
28739: ARRAY
28740: PUSH
28741: LD_INT 2
28743: ARRAY
28744: PPUSH
28745: CALL_OW 351
28749: OR
28750: IFFALSE 28756
// exit ;
28752: POP
28753: POP
28754: GO 29063
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28756: LD_ADDR_VAR 0 8
28760: PUSH
28761: LD_VAR 0 12
28765: PUSH
28766: LD_VAR 0 7
28770: ARRAY
28771: PUSH
28772: LD_INT 1
28774: ARRAY
28775: PPUSH
28776: LD_VAR 0 12
28780: PUSH
28781: LD_VAR 0 7
28785: ARRAY
28786: PUSH
28787: LD_INT 2
28789: ARRAY
28790: PPUSH
28791: CALL_OW 546
28795: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28796: LD_VAR 0 8
28800: PUSH
28801: LD_INT 1
28803: ARRAY
28804: PUSH
28805: LD_VAR 0 8
28809: PUSH
28810: LD_INT 2
28812: ARRAY
28813: PUSH
28814: LD_VAR 0 13
28818: PUSH
28819: LD_INT 2
28821: PLUS
28822: GREATER
28823: OR
28824: PUSH
28825: LD_VAR 0 8
28829: PUSH
28830: LD_INT 2
28832: ARRAY
28833: PUSH
28834: LD_VAR 0 13
28838: PUSH
28839: LD_INT 2
28841: MINUS
28842: LESS
28843: OR
28844: PUSH
28845: LD_VAR 0 8
28849: PUSH
28850: LD_INT 3
28852: ARRAY
28853: PUSH
28854: LD_INT 0
28856: PUSH
28857: LD_INT 8
28859: PUSH
28860: LD_INT 9
28862: PUSH
28863: LD_INT 10
28865: PUSH
28866: LD_INT 11
28868: PUSH
28869: LD_INT 12
28871: PUSH
28872: LD_INT 13
28874: PUSH
28875: LD_INT 16
28877: PUSH
28878: LD_INT 17
28880: PUSH
28881: LD_INT 18
28883: PUSH
28884: LD_INT 19
28886: PUSH
28887: LD_INT 20
28889: PUSH
28890: LD_INT 21
28892: PUSH
28893: EMPTY
28894: LIST
28895: LIST
28896: LIST
28897: LIST
28898: LIST
28899: LIST
28900: LIST
28901: LIST
28902: LIST
28903: LIST
28904: LIST
28905: LIST
28906: LIST
28907: IN
28908: NOT
28909: OR
28910: PUSH
28911: LD_VAR 0 8
28915: PUSH
28916: LD_INT 5
28918: ARRAY
28919: NOT
28920: OR
28921: PUSH
28922: LD_VAR 0 8
28926: PUSH
28927: LD_INT 6
28929: ARRAY
28930: PUSH
28931: LD_INT 1
28933: PUSH
28934: LD_INT 2
28936: PUSH
28937: LD_INT 7
28939: PUSH
28940: LD_INT 9
28942: PUSH
28943: LD_INT 10
28945: PUSH
28946: LD_INT 11
28948: PUSH
28949: EMPTY
28950: LIST
28951: LIST
28952: LIST
28953: LIST
28954: LIST
28955: LIST
28956: IN
28957: NOT
28958: OR
28959: IFFALSE 28965
// exit ;
28961: POP
28962: POP
28963: GO 29063
// end ;
28965: GO 28636
28967: POP
28968: POP
// side := GetSide ( depot ) ;
28969: LD_ADDR_VAR 0 9
28973: PUSH
28974: LD_VAR 0 1
28978: PPUSH
28979: CALL_OW 255
28983: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28984: LD_VAR 0 9
28988: PPUSH
28989: LD_VAR 0 3
28993: PPUSH
28994: LD_VAR 0 4
28998: PPUSH
28999: LD_INT 20
29001: PPUSH
29002: CALL 21717 0 4
29006: PUSH
29007: LD_INT 4
29009: ARRAY
29010: IFFALSE 29014
// exit ;
29012: GO 29063
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
29014: LD_VAR 0 2
29018: PUSH
29019: LD_INT 29
29021: PUSH
29022: LD_INT 30
29024: PUSH
29025: EMPTY
29026: LIST
29027: LIST
29028: IN
29029: PUSH
29030: LD_VAR 0 3
29034: PPUSH
29035: LD_VAR 0 4
29039: PPUSH
29040: LD_VAR 0 9
29044: PPUSH
29045: CALL_OW 440
29049: NOT
29050: AND
29051: IFFALSE 29055
// exit ;
29053: GO 29063
// result := true ;
29055: LD_ADDR_VAR 0 6
29059: PUSH
29060: LD_INT 1
29062: ST_TO_ADDR
// end ;
29063: LD_VAR 0 6
29067: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
29068: LD_INT 0
29070: PPUSH
29071: PPUSH
29072: PPUSH
29073: PPUSH
29074: PPUSH
29075: PPUSH
29076: PPUSH
29077: PPUSH
29078: PPUSH
29079: PPUSH
29080: PPUSH
29081: PPUSH
29082: PPUSH
29083: PPUSH
29084: PPUSH
29085: PPUSH
29086: PPUSH
29087: PPUSH
29088: PPUSH
29089: PPUSH
29090: PPUSH
29091: PPUSH
29092: PPUSH
29093: PPUSH
29094: PPUSH
29095: PPUSH
29096: PPUSH
29097: PPUSH
29098: PPUSH
29099: PPUSH
29100: PPUSH
29101: PPUSH
29102: PPUSH
29103: PPUSH
29104: PPUSH
29105: PPUSH
29106: PPUSH
29107: PPUSH
29108: PPUSH
29109: PPUSH
29110: PPUSH
29111: PPUSH
29112: PPUSH
29113: PPUSH
29114: PPUSH
29115: PPUSH
29116: PPUSH
29117: PPUSH
29118: PPUSH
29119: PPUSH
29120: PPUSH
29121: PPUSH
29122: PPUSH
29123: PPUSH
29124: PPUSH
29125: PPUSH
29126: PPUSH
29127: PPUSH
// result = [ ] ;
29128: LD_ADDR_VAR 0 7
29132: PUSH
29133: EMPTY
29134: ST_TO_ADDR
// temp_list = [ ] ;
29135: LD_ADDR_VAR 0 9
29139: PUSH
29140: EMPTY
29141: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29142: LD_VAR 0 4
29146: PUSH
29147: LD_INT 0
29149: PUSH
29150: LD_INT 1
29152: PUSH
29153: LD_INT 2
29155: PUSH
29156: LD_INT 3
29158: PUSH
29159: LD_INT 4
29161: PUSH
29162: LD_INT 5
29164: PUSH
29165: EMPTY
29166: LIST
29167: LIST
29168: LIST
29169: LIST
29170: LIST
29171: LIST
29172: IN
29173: NOT
29174: PUSH
29175: LD_VAR 0 1
29179: PUSH
29180: LD_INT 0
29182: PUSH
29183: LD_INT 1
29185: PUSH
29186: EMPTY
29187: LIST
29188: LIST
29189: IN
29190: PUSH
29191: LD_VAR 0 5
29195: PUSH
29196: LD_INT 1
29198: PUSH
29199: LD_INT 2
29201: PUSH
29202: LD_INT 3
29204: PUSH
29205: EMPTY
29206: LIST
29207: LIST
29208: LIST
29209: IN
29210: NOT
29211: AND
29212: OR
29213: IFFALSE 29217
// exit ;
29215: GO 47608
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29217: LD_VAR 0 1
29221: PUSH
29222: LD_INT 6
29224: PUSH
29225: LD_INT 7
29227: PUSH
29228: LD_INT 8
29230: PUSH
29231: LD_INT 13
29233: PUSH
29234: LD_INT 12
29236: PUSH
29237: LD_INT 15
29239: PUSH
29240: LD_INT 11
29242: PUSH
29243: LD_INT 14
29245: PUSH
29246: LD_INT 10
29248: PUSH
29249: EMPTY
29250: LIST
29251: LIST
29252: LIST
29253: LIST
29254: LIST
29255: LIST
29256: LIST
29257: LIST
29258: LIST
29259: IN
29260: IFFALSE 29270
// btype = b_lab ;
29262: LD_ADDR_VAR 0 1
29266: PUSH
29267: LD_INT 6
29269: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29270: LD_VAR 0 6
29274: PUSH
29275: LD_INT 0
29277: PUSH
29278: LD_INT 1
29280: PUSH
29281: LD_INT 2
29283: PUSH
29284: EMPTY
29285: LIST
29286: LIST
29287: LIST
29288: IN
29289: NOT
29290: PUSH
29291: LD_VAR 0 1
29295: PUSH
29296: LD_INT 0
29298: PUSH
29299: LD_INT 1
29301: PUSH
29302: LD_INT 2
29304: PUSH
29305: LD_INT 3
29307: PUSH
29308: LD_INT 6
29310: PUSH
29311: LD_INT 36
29313: PUSH
29314: LD_INT 4
29316: PUSH
29317: LD_INT 5
29319: PUSH
29320: LD_INT 31
29322: PUSH
29323: LD_INT 32
29325: PUSH
29326: LD_INT 33
29328: PUSH
29329: EMPTY
29330: LIST
29331: LIST
29332: LIST
29333: LIST
29334: LIST
29335: LIST
29336: LIST
29337: LIST
29338: LIST
29339: LIST
29340: LIST
29341: IN
29342: NOT
29343: PUSH
29344: LD_VAR 0 6
29348: PUSH
29349: LD_INT 1
29351: EQUAL
29352: AND
29353: OR
29354: PUSH
29355: LD_VAR 0 1
29359: PUSH
29360: LD_INT 2
29362: PUSH
29363: LD_INT 3
29365: PUSH
29366: EMPTY
29367: LIST
29368: LIST
29369: IN
29370: NOT
29371: PUSH
29372: LD_VAR 0 6
29376: PUSH
29377: LD_INT 2
29379: EQUAL
29380: AND
29381: OR
29382: IFFALSE 29392
// mode = 0 ;
29384: LD_ADDR_VAR 0 6
29388: PUSH
29389: LD_INT 0
29391: ST_TO_ADDR
// case mode of 0 :
29392: LD_VAR 0 6
29396: PUSH
29397: LD_INT 0
29399: DOUBLE
29400: EQUAL
29401: IFTRUE 29405
29403: GO 40858
29405: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29406: LD_ADDR_VAR 0 11
29410: PUSH
29411: LD_INT 0
29413: PUSH
29414: LD_INT 0
29416: PUSH
29417: EMPTY
29418: LIST
29419: LIST
29420: PUSH
29421: LD_INT 0
29423: PUSH
29424: LD_INT 1
29426: NEG
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: PUSH
29432: LD_INT 1
29434: PUSH
29435: LD_INT 0
29437: PUSH
29438: EMPTY
29439: LIST
29440: LIST
29441: PUSH
29442: LD_INT 1
29444: PUSH
29445: LD_INT 1
29447: PUSH
29448: EMPTY
29449: LIST
29450: LIST
29451: PUSH
29452: LD_INT 0
29454: PUSH
29455: LD_INT 1
29457: PUSH
29458: EMPTY
29459: LIST
29460: LIST
29461: PUSH
29462: LD_INT 1
29464: NEG
29465: PUSH
29466: LD_INT 0
29468: PUSH
29469: EMPTY
29470: LIST
29471: LIST
29472: PUSH
29473: LD_INT 1
29475: NEG
29476: PUSH
29477: LD_INT 1
29479: NEG
29480: PUSH
29481: EMPTY
29482: LIST
29483: LIST
29484: PUSH
29485: LD_INT 1
29487: NEG
29488: PUSH
29489: LD_INT 2
29491: NEG
29492: PUSH
29493: EMPTY
29494: LIST
29495: LIST
29496: PUSH
29497: LD_INT 0
29499: PUSH
29500: LD_INT 2
29502: NEG
29503: PUSH
29504: EMPTY
29505: LIST
29506: LIST
29507: PUSH
29508: LD_INT 1
29510: PUSH
29511: LD_INT 1
29513: NEG
29514: PUSH
29515: EMPTY
29516: LIST
29517: LIST
29518: PUSH
29519: LD_INT 1
29521: PUSH
29522: LD_INT 2
29524: PUSH
29525: EMPTY
29526: LIST
29527: LIST
29528: PUSH
29529: LD_INT 0
29531: PUSH
29532: LD_INT 2
29534: PUSH
29535: EMPTY
29536: LIST
29537: LIST
29538: PUSH
29539: LD_INT 1
29541: NEG
29542: PUSH
29543: LD_INT 1
29545: PUSH
29546: EMPTY
29547: LIST
29548: LIST
29549: PUSH
29550: LD_INT 1
29552: PUSH
29553: LD_INT 3
29555: PUSH
29556: EMPTY
29557: LIST
29558: LIST
29559: PUSH
29560: LD_INT 0
29562: PUSH
29563: LD_INT 3
29565: PUSH
29566: EMPTY
29567: LIST
29568: LIST
29569: PUSH
29570: LD_INT 1
29572: NEG
29573: PUSH
29574: LD_INT 2
29576: PUSH
29577: EMPTY
29578: LIST
29579: LIST
29580: PUSH
29581: EMPTY
29582: LIST
29583: LIST
29584: LIST
29585: LIST
29586: LIST
29587: LIST
29588: LIST
29589: LIST
29590: LIST
29591: LIST
29592: LIST
29593: LIST
29594: LIST
29595: LIST
29596: LIST
29597: LIST
29598: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29599: LD_ADDR_VAR 0 12
29603: PUSH
29604: LD_INT 0
29606: PUSH
29607: LD_INT 0
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PUSH
29614: LD_INT 0
29616: PUSH
29617: LD_INT 1
29619: NEG
29620: PUSH
29621: EMPTY
29622: LIST
29623: LIST
29624: PUSH
29625: LD_INT 1
29627: PUSH
29628: LD_INT 0
29630: PUSH
29631: EMPTY
29632: LIST
29633: LIST
29634: PUSH
29635: LD_INT 1
29637: PUSH
29638: LD_INT 1
29640: PUSH
29641: EMPTY
29642: LIST
29643: LIST
29644: PUSH
29645: LD_INT 0
29647: PUSH
29648: LD_INT 1
29650: PUSH
29651: EMPTY
29652: LIST
29653: LIST
29654: PUSH
29655: LD_INT 1
29657: NEG
29658: PUSH
29659: LD_INT 0
29661: PUSH
29662: EMPTY
29663: LIST
29664: LIST
29665: PUSH
29666: LD_INT 1
29668: NEG
29669: PUSH
29670: LD_INT 1
29672: NEG
29673: PUSH
29674: EMPTY
29675: LIST
29676: LIST
29677: PUSH
29678: LD_INT 1
29680: PUSH
29681: LD_INT 1
29683: NEG
29684: PUSH
29685: EMPTY
29686: LIST
29687: LIST
29688: PUSH
29689: LD_INT 2
29691: PUSH
29692: LD_INT 0
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: LD_INT 2
29701: PUSH
29702: LD_INT 1
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: LD_INT 1
29711: NEG
29712: PUSH
29713: LD_INT 1
29715: PUSH
29716: EMPTY
29717: LIST
29718: LIST
29719: PUSH
29720: LD_INT 2
29722: NEG
29723: PUSH
29724: LD_INT 0
29726: PUSH
29727: EMPTY
29728: LIST
29729: LIST
29730: PUSH
29731: LD_INT 2
29733: NEG
29734: PUSH
29735: LD_INT 1
29737: NEG
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: LD_INT 2
29745: NEG
29746: PUSH
29747: LD_INT 1
29749: PUSH
29750: EMPTY
29751: LIST
29752: LIST
29753: PUSH
29754: LD_INT 3
29756: NEG
29757: PUSH
29758: LD_INT 0
29760: PUSH
29761: EMPTY
29762: LIST
29763: LIST
29764: PUSH
29765: LD_INT 3
29767: NEG
29768: PUSH
29769: LD_INT 1
29771: NEG
29772: PUSH
29773: EMPTY
29774: LIST
29775: LIST
29776: PUSH
29777: EMPTY
29778: LIST
29779: LIST
29780: LIST
29781: LIST
29782: LIST
29783: LIST
29784: LIST
29785: LIST
29786: LIST
29787: LIST
29788: LIST
29789: LIST
29790: LIST
29791: LIST
29792: LIST
29793: LIST
29794: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29795: LD_ADDR_VAR 0 13
29799: PUSH
29800: LD_INT 0
29802: PUSH
29803: LD_INT 0
29805: PUSH
29806: EMPTY
29807: LIST
29808: LIST
29809: PUSH
29810: LD_INT 0
29812: PUSH
29813: LD_INT 1
29815: NEG
29816: PUSH
29817: EMPTY
29818: LIST
29819: LIST
29820: PUSH
29821: LD_INT 1
29823: PUSH
29824: LD_INT 0
29826: PUSH
29827: EMPTY
29828: LIST
29829: LIST
29830: PUSH
29831: LD_INT 1
29833: PUSH
29834: LD_INT 1
29836: PUSH
29837: EMPTY
29838: LIST
29839: LIST
29840: PUSH
29841: LD_INT 0
29843: PUSH
29844: LD_INT 1
29846: PUSH
29847: EMPTY
29848: LIST
29849: LIST
29850: PUSH
29851: LD_INT 1
29853: NEG
29854: PUSH
29855: LD_INT 0
29857: PUSH
29858: EMPTY
29859: LIST
29860: LIST
29861: PUSH
29862: LD_INT 1
29864: NEG
29865: PUSH
29866: LD_INT 1
29868: NEG
29869: PUSH
29870: EMPTY
29871: LIST
29872: LIST
29873: PUSH
29874: LD_INT 1
29876: NEG
29877: PUSH
29878: LD_INT 2
29880: NEG
29881: PUSH
29882: EMPTY
29883: LIST
29884: LIST
29885: PUSH
29886: LD_INT 2
29888: PUSH
29889: LD_INT 1
29891: PUSH
29892: EMPTY
29893: LIST
29894: LIST
29895: PUSH
29896: LD_INT 2
29898: PUSH
29899: LD_INT 2
29901: PUSH
29902: EMPTY
29903: LIST
29904: LIST
29905: PUSH
29906: LD_INT 1
29908: PUSH
29909: LD_INT 2
29911: PUSH
29912: EMPTY
29913: LIST
29914: LIST
29915: PUSH
29916: LD_INT 2
29918: NEG
29919: PUSH
29920: LD_INT 1
29922: NEG
29923: PUSH
29924: EMPTY
29925: LIST
29926: LIST
29927: PUSH
29928: LD_INT 2
29930: NEG
29931: PUSH
29932: LD_INT 2
29934: NEG
29935: PUSH
29936: EMPTY
29937: LIST
29938: LIST
29939: PUSH
29940: LD_INT 2
29942: NEG
29943: PUSH
29944: LD_INT 3
29946: NEG
29947: PUSH
29948: EMPTY
29949: LIST
29950: LIST
29951: PUSH
29952: LD_INT 3
29954: NEG
29955: PUSH
29956: LD_INT 2
29958: NEG
29959: PUSH
29960: EMPTY
29961: LIST
29962: LIST
29963: PUSH
29964: LD_INT 3
29966: NEG
29967: PUSH
29968: LD_INT 3
29970: NEG
29971: PUSH
29972: EMPTY
29973: LIST
29974: LIST
29975: PUSH
29976: EMPTY
29977: LIST
29978: LIST
29979: LIST
29980: LIST
29981: LIST
29982: LIST
29983: LIST
29984: LIST
29985: LIST
29986: LIST
29987: LIST
29988: LIST
29989: LIST
29990: LIST
29991: LIST
29992: LIST
29993: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29994: LD_ADDR_VAR 0 14
29998: PUSH
29999: LD_INT 0
30001: PUSH
30002: LD_INT 0
30004: PUSH
30005: EMPTY
30006: LIST
30007: LIST
30008: PUSH
30009: LD_INT 0
30011: PUSH
30012: LD_INT 1
30014: NEG
30015: PUSH
30016: EMPTY
30017: LIST
30018: LIST
30019: PUSH
30020: LD_INT 1
30022: PUSH
30023: LD_INT 0
30025: PUSH
30026: EMPTY
30027: LIST
30028: LIST
30029: PUSH
30030: LD_INT 1
30032: PUSH
30033: LD_INT 1
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: PUSH
30040: LD_INT 0
30042: PUSH
30043: LD_INT 1
30045: PUSH
30046: EMPTY
30047: LIST
30048: LIST
30049: PUSH
30050: LD_INT 1
30052: NEG
30053: PUSH
30054: LD_INT 0
30056: PUSH
30057: EMPTY
30058: LIST
30059: LIST
30060: PUSH
30061: LD_INT 1
30063: NEG
30064: PUSH
30065: LD_INT 1
30067: NEG
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PUSH
30073: LD_INT 1
30075: NEG
30076: PUSH
30077: LD_INT 2
30079: NEG
30080: PUSH
30081: EMPTY
30082: LIST
30083: LIST
30084: PUSH
30085: LD_INT 0
30087: PUSH
30088: LD_INT 2
30090: NEG
30091: PUSH
30092: EMPTY
30093: LIST
30094: LIST
30095: PUSH
30096: LD_INT 1
30098: PUSH
30099: LD_INT 1
30101: NEG
30102: PUSH
30103: EMPTY
30104: LIST
30105: LIST
30106: PUSH
30107: LD_INT 1
30109: PUSH
30110: LD_INT 2
30112: PUSH
30113: EMPTY
30114: LIST
30115: LIST
30116: PUSH
30117: LD_INT 0
30119: PUSH
30120: LD_INT 2
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: PUSH
30127: LD_INT 1
30129: NEG
30130: PUSH
30131: LD_INT 1
30133: PUSH
30134: EMPTY
30135: LIST
30136: LIST
30137: PUSH
30138: LD_INT 1
30140: NEG
30141: PUSH
30142: LD_INT 3
30144: NEG
30145: PUSH
30146: EMPTY
30147: LIST
30148: LIST
30149: PUSH
30150: LD_INT 0
30152: PUSH
30153: LD_INT 3
30155: NEG
30156: PUSH
30157: EMPTY
30158: LIST
30159: LIST
30160: PUSH
30161: LD_INT 1
30163: PUSH
30164: LD_INT 2
30166: NEG
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: EMPTY
30173: LIST
30174: LIST
30175: LIST
30176: LIST
30177: LIST
30178: LIST
30179: LIST
30180: LIST
30181: LIST
30182: LIST
30183: LIST
30184: LIST
30185: LIST
30186: LIST
30187: LIST
30188: LIST
30189: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30190: LD_ADDR_VAR 0 15
30194: PUSH
30195: LD_INT 0
30197: PUSH
30198: LD_INT 0
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: LD_INT 0
30207: PUSH
30208: LD_INT 1
30210: NEG
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PUSH
30216: LD_INT 1
30218: PUSH
30219: LD_INT 0
30221: PUSH
30222: EMPTY
30223: LIST
30224: LIST
30225: PUSH
30226: LD_INT 1
30228: PUSH
30229: LD_INT 1
30231: PUSH
30232: EMPTY
30233: LIST
30234: LIST
30235: PUSH
30236: LD_INT 0
30238: PUSH
30239: LD_INT 1
30241: PUSH
30242: EMPTY
30243: LIST
30244: LIST
30245: PUSH
30246: LD_INT 1
30248: NEG
30249: PUSH
30250: LD_INT 0
30252: PUSH
30253: EMPTY
30254: LIST
30255: LIST
30256: PUSH
30257: LD_INT 1
30259: NEG
30260: PUSH
30261: LD_INT 1
30263: NEG
30264: PUSH
30265: EMPTY
30266: LIST
30267: LIST
30268: PUSH
30269: LD_INT 1
30271: PUSH
30272: LD_INT 1
30274: NEG
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 2
30282: PUSH
30283: LD_INT 0
30285: PUSH
30286: EMPTY
30287: LIST
30288: LIST
30289: PUSH
30290: LD_INT 2
30292: PUSH
30293: LD_INT 1
30295: PUSH
30296: EMPTY
30297: LIST
30298: LIST
30299: PUSH
30300: LD_INT 1
30302: NEG
30303: PUSH
30304: LD_INT 1
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: LD_INT 2
30313: NEG
30314: PUSH
30315: LD_INT 0
30317: PUSH
30318: EMPTY
30319: LIST
30320: LIST
30321: PUSH
30322: LD_INT 2
30324: NEG
30325: PUSH
30326: LD_INT 1
30328: NEG
30329: PUSH
30330: EMPTY
30331: LIST
30332: LIST
30333: PUSH
30334: LD_INT 2
30336: PUSH
30337: LD_INT 1
30339: NEG
30340: PUSH
30341: EMPTY
30342: LIST
30343: LIST
30344: PUSH
30345: LD_INT 3
30347: PUSH
30348: LD_INT 0
30350: PUSH
30351: EMPTY
30352: LIST
30353: LIST
30354: PUSH
30355: LD_INT 3
30357: PUSH
30358: LD_INT 1
30360: PUSH
30361: EMPTY
30362: LIST
30363: LIST
30364: PUSH
30365: EMPTY
30366: LIST
30367: LIST
30368: LIST
30369: LIST
30370: LIST
30371: LIST
30372: LIST
30373: LIST
30374: LIST
30375: LIST
30376: LIST
30377: LIST
30378: LIST
30379: LIST
30380: LIST
30381: LIST
30382: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30383: LD_ADDR_VAR 0 16
30387: PUSH
30388: LD_INT 0
30390: PUSH
30391: LD_INT 0
30393: PUSH
30394: EMPTY
30395: LIST
30396: LIST
30397: PUSH
30398: LD_INT 0
30400: PUSH
30401: LD_INT 1
30403: NEG
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: PUSH
30409: LD_INT 1
30411: PUSH
30412: LD_INT 0
30414: PUSH
30415: EMPTY
30416: LIST
30417: LIST
30418: PUSH
30419: LD_INT 1
30421: PUSH
30422: LD_INT 1
30424: PUSH
30425: EMPTY
30426: LIST
30427: LIST
30428: PUSH
30429: LD_INT 0
30431: PUSH
30432: LD_INT 1
30434: PUSH
30435: EMPTY
30436: LIST
30437: LIST
30438: PUSH
30439: LD_INT 1
30441: NEG
30442: PUSH
30443: LD_INT 0
30445: PUSH
30446: EMPTY
30447: LIST
30448: LIST
30449: PUSH
30450: LD_INT 1
30452: NEG
30453: PUSH
30454: LD_INT 1
30456: NEG
30457: PUSH
30458: EMPTY
30459: LIST
30460: LIST
30461: PUSH
30462: LD_INT 1
30464: NEG
30465: PUSH
30466: LD_INT 2
30468: NEG
30469: PUSH
30470: EMPTY
30471: LIST
30472: LIST
30473: PUSH
30474: LD_INT 2
30476: PUSH
30477: LD_INT 1
30479: PUSH
30480: EMPTY
30481: LIST
30482: LIST
30483: PUSH
30484: LD_INT 2
30486: PUSH
30487: LD_INT 2
30489: PUSH
30490: EMPTY
30491: LIST
30492: LIST
30493: PUSH
30494: LD_INT 1
30496: PUSH
30497: LD_INT 2
30499: PUSH
30500: EMPTY
30501: LIST
30502: LIST
30503: PUSH
30504: LD_INT 2
30506: NEG
30507: PUSH
30508: LD_INT 1
30510: NEG
30511: PUSH
30512: EMPTY
30513: LIST
30514: LIST
30515: PUSH
30516: LD_INT 2
30518: NEG
30519: PUSH
30520: LD_INT 2
30522: NEG
30523: PUSH
30524: EMPTY
30525: LIST
30526: LIST
30527: PUSH
30528: LD_INT 3
30530: PUSH
30531: LD_INT 2
30533: PUSH
30534: EMPTY
30535: LIST
30536: LIST
30537: PUSH
30538: LD_INT 3
30540: PUSH
30541: LD_INT 3
30543: PUSH
30544: EMPTY
30545: LIST
30546: LIST
30547: PUSH
30548: LD_INT 2
30550: PUSH
30551: LD_INT 3
30553: PUSH
30554: EMPTY
30555: LIST
30556: LIST
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: LIST
30562: LIST
30563: LIST
30564: LIST
30565: LIST
30566: LIST
30567: LIST
30568: LIST
30569: LIST
30570: LIST
30571: LIST
30572: LIST
30573: LIST
30574: LIST
30575: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30576: LD_ADDR_VAR 0 17
30580: PUSH
30581: LD_INT 0
30583: PUSH
30584: LD_INT 0
30586: PUSH
30587: EMPTY
30588: LIST
30589: LIST
30590: PUSH
30591: LD_INT 0
30593: PUSH
30594: LD_INT 1
30596: NEG
30597: PUSH
30598: EMPTY
30599: LIST
30600: LIST
30601: PUSH
30602: LD_INT 1
30604: PUSH
30605: LD_INT 0
30607: PUSH
30608: EMPTY
30609: LIST
30610: LIST
30611: PUSH
30612: LD_INT 1
30614: PUSH
30615: LD_INT 1
30617: PUSH
30618: EMPTY
30619: LIST
30620: LIST
30621: PUSH
30622: LD_INT 0
30624: PUSH
30625: LD_INT 1
30627: PUSH
30628: EMPTY
30629: LIST
30630: LIST
30631: PUSH
30632: LD_INT 1
30634: NEG
30635: PUSH
30636: LD_INT 0
30638: PUSH
30639: EMPTY
30640: LIST
30641: LIST
30642: PUSH
30643: LD_INT 1
30645: NEG
30646: PUSH
30647: LD_INT 1
30649: NEG
30650: PUSH
30651: EMPTY
30652: LIST
30653: LIST
30654: PUSH
30655: LD_INT 1
30657: NEG
30658: PUSH
30659: LD_INT 2
30661: NEG
30662: PUSH
30663: EMPTY
30664: LIST
30665: LIST
30666: PUSH
30667: LD_INT 0
30669: PUSH
30670: LD_INT 2
30672: NEG
30673: PUSH
30674: EMPTY
30675: LIST
30676: LIST
30677: PUSH
30678: LD_INT 1
30680: PUSH
30681: LD_INT 1
30683: NEG
30684: PUSH
30685: EMPTY
30686: LIST
30687: LIST
30688: PUSH
30689: LD_INT 2
30691: PUSH
30692: LD_INT 0
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: PUSH
30699: LD_INT 2
30701: PUSH
30702: LD_INT 1
30704: PUSH
30705: EMPTY
30706: LIST
30707: LIST
30708: PUSH
30709: LD_INT 2
30711: PUSH
30712: LD_INT 2
30714: PUSH
30715: EMPTY
30716: LIST
30717: LIST
30718: PUSH
30719: LD_INT 1
30721: PUSH
30722: LD_INT 2
30724: PUSH
30725: EMPTY
30726: LIST
30727: LIST
30728: PUSH
30729: LD_INT 0
30731: PUSH
30732: LD_INT 2
30734: PUSH
30735: EMPTY
30736: LIST
30737: LIST
30738: PUSH
30739: LD_INT 1
30741: NEG
30742: PUSH
30743: LD_INT 1
30745: PUSH
30746: EMPTY
30747: LIST
30748: LIST
30749: PUSH
30750: LD_INT 2
30752: NEG
30753: PUSH
30754: LD_INT 0
30756: PUSH
30757: EMPTY
30758: LIST
30759: LIST
30760: PUSH
30761: LD_INT 2
30763: NEG
30764: PUSH
30765: LD_INT 1
30767: NEG
30768: PUSH
30769: EMPTY
30770: LIST
30771: LIST
30772: PUSH
30773: LD_INT 2
30775: NEG
30776: PUSH
30777: LD_INT 2
30779: NEG
30780: PUSH
30781: EMPTY
30782: LIST
30783: LIST
30784: PUSH
30785: EMPTY
30786: LIST
30787: LIST
30788: LIST
30789: LIST
30790: LIST
30791: LIST
30792: LIST
30793: LIST
30794: LIST
30795: LIST
30796: LIST
30797: LIST
30798: LIST
30799: LIST
30800: LIST
30801: LIST
30802: LIST
30803: LIST
30804: LIST
30805: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30806: LD_ADDR_VAR 0 18
30810: PUSH
30811: LD_INT 0
30813: PUSH
30814: LD_INT 0
30816: PUSH
30817: EMPTY
30818: LIST
30819: LIST
30820: PUSH
30821: LD_INT 0
30823: PUSH
30824: LD_INT 1
30826: NEG
30827: PUSH
30828: EMPTY
30829: LIST
30830: LIST
30831: PUSH
30832: LD_INT 1
30834: PUSH
30835: LD_INT 0
30837: PUSH
30838: EMPTY
30839: LIST
30840: LIST
30841: PUSH
30842: LD_INT 1
30844: PUSH
30845: LD_INT 1
30847: PUSH
30848: EMPTY
30849: LIST
30850: LIST
30851: PUSH
30852: LD_INT 0
30854: PUSH
30855: LD_INT 1
30857: PUSH
30858: EMPTY
30859: LIST
30860: LIST
30861: PUSH
30862: LD_INT 1
30864: NEG
30865: PUSH
30866: LD_INT 0
30868: PUSH
30869: EMPTY
30870: LIST
30871: LIST
30872: PUSH
30873: LD_INT 1
30875: NEG
30876: PUSH
30877: LD_INT 1
30879: NEG
30880: PUSH
30881: EMPTY
30882: LIST
30883: LIST
30884: PUSH
30885: LD_INT 1
30887: NEG
30888: PUSH
30889: LD_INT 2
30891: NEG
30892: PUSH
30893: EMPTY
30894: LIST
30895: LIST
30896: PUSH
30897: LD_INT 0
30899: PUSH
30900: LD_INT 2
30902: NEG
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: PUSH
30908: LD_INT 1
30910: PUSH
30911: LD_INT 1
30913: NEG
30914: PUSH
30915: EMPTY
30916: LIST
30917: LIST
30918: PUSH
30919: LD_INT 2
30921: PUSH
30922: LD_INT 0
30924: PUSH
30925: EMPTY
30926: LIST
30927: LIST
30928: PUSH
30929: LD_INT 2
30931: PUSH
30932: LD_INT 1
30934: PUSH
30935: EMPTY
30936: LIST
30937: LIST
30938: PUSH
30939: LD_INT 2
30941: PUSH
30942: LD_INT 2
30944: PUSH
30945: EMPTY
30946: LIST
30947: LIST
30948: PUSH
30949: LD_INT 1
30951: PUSH
30952: LD_INT 2
30954: PUSH
30955: EMPTY
30956: LIST
30957: LIST
30958: PUSH
30959: LD_INT 0
30961: PUSH
30962: LD_INT 2
30964: PUSH
30965: EMPTY
30966: LIST
30967: LIST
30968: PUSH
30969: LD_INT 1
30971: NEG
30972: PUSH
30973: LD_INT 1
30975: PUSH
30976: EMPTY
30977: LIST
30978: LIST
30979: PUSH
30980: LD_INT 2
30982: NEG
30983: PUSH
30984: LD_INT 0
30986: PUSH
30987: EMPTY
30988: LIST
30989: LIST
30990: PUSH
30991: LD_INT 2
30993: NEG
30994: PUSH
30995: LD_INT 1
30997: NEG
30998: PUSH
30999: EMPTY
31000: LIST
31001: LIST
31002: PUSH
31003: LD_INT 2
31005: NEG
31006: PUSH
31007: LD_INT 2
31009: NEG
31010: PUSH
31011: EMPTY
31012: LIST
31013: LIST
31014: PUSH
31015: EMPTY
31016: LIST
31017: LIST
31018: LIST
31019: LIST
31020: LIST
31021: LIST
31022: LIST
31023: LIST
31024: LIST
31025: LIST
31026: LIST
31027: LIST
31028: LIST
31029: LIST
31030: LIST
31031: LIST
31032: LIST
31033: LIST
31034: LIST
31035: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31036: LD_ADDR_VAR 0 19
31040: PUSH
31041: LD_INT 0
31043: PUSH
31044: LD_INT 0
31046: PUSH
31047: EMPTY
31048: LIST
31049: LIST
31050: PUSH
31051: LD_INT 0
31053: PUSH
31054: LD_INT 1
31056: NEG
31057: PUSH
31058: EMPTY
31059: LIST
31060: LIST
31061: PUSH
31062: LD_INT 1
31064: PUSH
31065: LD_INT 0
31067: PUSH
31068: EMPTY
31069: LIST
31070: LIST
31071: PUSH
31072: LD_INT 1
31074: PUSH
31075: LD_INT 1
31077: PUSH
31078: EMPTY
31079: LIST
31080: LIST
31081: PUSH
31082: LD_INT 0
31084: PUSH
31085: LD_INT 1
31087: PUSH
31088: EMPTY
31089: LIST
31090: LIST
31091: PUSH
31092: LD_INT 1
31094: NEG
31095: PUSH
31096: LD_INT 0
31098: PUSH
31099: EMPTY
31100: LIST
31101: LIST
31102: PUSH
31103: LD_INT 1
31105: NEG
31106: PUSH
31107: LD_INT 1
31109: NEG
31110: PUSH
31111: EMPTY
31112: LIST
31113: LIST
31114: PUSH
31115: LD_INT 1
31117: NEG
31118: PUSH
31119: LD_INT 2
31121: NEG
31122: PUSH
31123: EMPTY
31124: LIST
31125: LIST
31126: PUSH
31127: LD_INT 0
31129: PUSH
31130: LD_INT 2
31132: NEG
31133: PUSH
31134: EMPTY
31135: LIST
31136: LIST
31137: PUSH
31138: LD_INT 1
31140: PUSH
31141: LD_INT 1
31143: NEG
31144: PUSH
31145: EMPTY
31146: LIST
31147: LIST
31148: PUSH
31149: LD_INT 2
31151: PUSH
31152: LD_INT 0
31154: PUSH
31155: EMPTY
31156: LIST
31157: LIST
31158: PUSH
31159: LD_INT 2
31161: PUSH
31162: LD_INT 1
31164: PUSH
31165: EMPTY
31166: LIST
31167: LIST
31168: PUSH
31169: LD_INT 2
31171: PUSH
31172: LD_INT 2
31174: PUSH
31175: EMPTY
31176: LIST
31177: LIST
31178: PUSH
31179: LD_INT 1
31181: PUSH
31182: LD_INT 2
31184: PUSH
31185: EMPTY
31186: LIST
31187: LIST
31188: PUSH
31189: LD_INT 0
31191: PUSH
31192: LD_INT 2
31194: PUSH
31195: EMPTY
31196: LIST
31197: LIST
31198: PUSH
31199: LD_INT 1
31201: NEG
31202: PUSH
31203: LD_INT 1
31205: PUSH
31206: EMPTY
31207: LIST
31208: LIST
31209: PUSH
31210: LD_INT 2
31212: NEG
31213: PUSH
31214: LD_INT 0
31216: PUSH
31217: EMPTY
31218: LIST
31219: LIST
31220: PUSH
31221: LD_INT 2
31223: NEG
31224: PUSH
31225: LD_INT 1
31227: NEG
31228: PUSH
31229: EMPTY
31230: LIST
31231: LIST
31232: PUSH
31233: LD_INT 2
31235: NEG
31236: PUSH
31237: LD_INT 2
31239: NEG
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: PUSH
31245: EMPTY
31246: LIST
31247: LIST
31248: LIST
31249: LIST
31250: LIST
31251: LIST
31252: LIST
31253: LIST
31254: LIST
31255: LIST
31256: LIST
31257: LIST
31258: LIST
31259: LIST
31260: LIST
31261: LIST
31262: LIST
31263: LIST
31264: LIST
31265: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31266: LD_ADDR_VAR 0 20
31270: PUSH
31271: LD_INT 0
31273: PUSH
31274: LD_INT 0
31276: PUSH
31277: EMPTY
31278: LIST
31279: LIST
31280: PUSH
31281: LD_INT 0
31283: PUSH
31284: LD_INT 1
31286: NEG
31287: PUSH
31288: EMPTY
31289: LIST
31290: LIST
31291: PUSH
31292: LD_INT 1
31294: PUSH
31295: LD_INT 0
31297: PUSH
31298: EMPTY
31299: LIST
31300: LIST
31301: PUSH
31302: LD_INT 1
31304: PUSH
31305: LD_INT 1
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: LD_INT 0
31314: PUSH
31315: LD_INT 1
31317: PUSH
31318: EMPTY
31319: LIST
31320: LIST
31321: PUSH
31322: LD_INT 1
31324: NEG
31325: PUSH
31326: LD_INT 0
31328: PUSH
31329: EMPTY
31330: LIST
31331: LIST
31332: PUSH
31333: LD_INT 1
31335: NEG
31336: PUSH
31337: LD_INT 1
31339: NEG
31340: PUSH
31341: EMPTY
31342: LIST
31343: LIST
31344: PUSH
31345: LD_INT 1
31347: NEG
31348: PUSH
31349: LD_INT 2
31351: NEG
31352: PUSH
31353: EMPTY
31354: LIST
31355: LIST
31356: PUSH
31357: LD_INT 0
31359: PUSH
31360: LD_INT 2
31362: NEG
31363: PUSH
31364: EMPTY
31365: LIST
31366: LIST
31367: PUSH
31368: LD_INT 1
31370: PUSH
31371: LD_INT 1
31373: NEG
31374: PUSH
31375: EMPTY
31376: LIST
31377: LIST
31378: PUSH
31379: LD_INT 2
31381: PUSH
31382: LD_INT 0
31384: PUSH
31385: EMPTY
31386: LIST
31387: LIST
31388: PUSH
31389: LD_INT 2
31391: PUSH
31392: LD_INT 1
31394: PUSH
31395: EMPTY
31396: LIST
31397: LIST
31398: PUSH
31399: LD_INT 2
31401: PUSH
31402: LD_INT 2
31404: PUSH
31405: EMPTY
31406: LIST
31407: LIST
31408: PUSH
31409: LD_INT 1
31411: PUSH
31412: LD_INT 2
31414: PUSH
31415: EMPTY
31416: LIST
31417: LIST
31418: PUSH
31419: LD_INT 0
31421: PUSH
31422: LD_INT 2
31424: PUSH
31425: EMPTY
31426: LIST
31427: LIST
31428: PUSH
31429: LD_INT 1
31431: NEG
31432: PUSH
31433: LD_INT 1
31435: PUSH
31436: EMPTY
31437: LIST
31438: LIST
31439: PUSH
31440: LD_INT 2
31442: NEG
31443: PUSH
31444: LD_INT 0
31446: PUSH
31447: EMPTY
31448: LIST
31449: LIST
31450: PUSH
31451: LD_INT 2
31453: NEG
31454: PUSH
31455: LD_INT 1
31457: NEG
31458: PUSH
31459: EMPTY
31460: LIST
31461: LIST
31462: PUSH
31463: LD_INT 2
31465: NEG
31466: PUSH
31467: LD_INT 2
31469: NEG
31470: PUSH
31471: EMPTY
31472: LIST
31473: LIST
31474: PUSH
31475: EMPTY
31476: LIST
31477: LIST
31478: LIST
31479: LIST
31480: LIST
31481: LIST
31482: LIST
31483: LIST
31484: LIST
31485: LIST
31486: LIST
31487: LIST
31488: LIST
31489: LIST
31490: LIST
31491: LIST
31492: LIST
31493: LIST
31494: LIST
31495: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31496: LD_ADDR_VAR 0 21
31500: PUSH
31501: LD_INT 0
31503: PUSH
31504: LD_INT 0
31506: PUSH
31507: EMPTY
31508: LIST
31509: LIST
31510: PUSH
31511: LD_INT 0
31513: PUSH
31514: LD_INT 1
31516: NEG
31517: PUSH
31518: EMPTY
31519: LIST
31520: LIST
31521: PUSH
31522: LD_INT 1
31524: PUSH
31525: LD_INT 0
31527: PUSH
31528: EMPTY
31529: LIST
31530: LIST
31531: PUSH
31532: LD_INT 1
31534: PUSH
31535: LD_INT 1
31537: PUSH
31538: EMPTY
31539: LIST
31540: LIST
31541: PUSH
31542: LD_INT 0
31544: PUSH
31545: LD_INT 1
31547: PUSH
31548: EMPTY
31549: LIST
31550: LIST
31551: PUSH
31552: LD_INT 1
31554: NEG
31555: PUSH
31556: LD_INT 0
31558: PUSH
31559: EMPTY
31560: LIST
31561: LIST
31562: PUSH
31563: LD_INT 1
31565: NEG
31566: PUSH
31567: LD_INT 1
31569: NEG
31570: PUSH
31571: EMPTY
31572: LIST
31573: LIST
31574: PUSH
31575: LD_INT 1
31577: NEG
31578: PUSH
31579: LD_INT 2
31581: NEG
31582: PUSH
31583: EMPTY
31584: LIST
31585: LIST
31586: PUSH
31587: LD_INT 0
31589: PUSH
31590: LD_INT 2
31592: NEG
31593: PUSH
31594: EMPTY
31595: LIST
31596: LIST
31597: PUSH
31598: LD_INT 1
31600: PUSH
31601: LD_INT 1
31603: NEG
31604: PUSH
31605: EMPTY
31606: LIST
31607: LIST
31608: PUSH
31609: LD_INT 2
31611: PUSH
31612: LD_INT 0
31614: PUSH
31615: EMPTY
31616: LIST
31617: LIST
31618: PUSH
31619: LD_INT 2
31621: PUSH
31622: LD_INT 1
31624: PUSH
31625: EMPTY
31626: LIST
31627: LIST
31628: PUSH
31629: LD_INT 2
31631: PUSH
31632: LD_INT 2
31634: PUSH
31635: EMPTY
31636: LIST
31637: LIST
31638: PUSH
31639: LD_INT 1
31641: PUSH
31642: LD_INT 2
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: LD_INT 0
31651: PUSH
31652: LD_INT 2
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PUSH
31659: LD_INT 1
31661: NEG
31662: PUSH
31663: LD_INT 1
31665: PUSH
31666: EMPTY
31667: LIST
31668: LIST
31669: PUSH
31670: LD_INT 2
31672: NEG
31673: PUSH
31674: LD_INT 0
31676: PUSH
31677: EMPTY
31678: LIST
31679: LIST
31680: PUSH
31681: LD_INT 2
31683: NEG
31684: PUSH
31685: LD_INT 1
31687: NEG
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: LD_INT 2
31695: NEG
31696: PUSH
31697: LD_INT 2
31699: NEG
31700: PUSH
31701: EMPTY
31702: LIST
31703: LIST
31704: PUSH
31705: EMPTY
31706: LIST
31707: LIST
31708: LIST
31709: LIST
31710: LIST
31711: LIST
31712: LIST
31713: LIST
31714: LIST
31715: LIST
31716: LIST
31717: LIST
31718: LIST
31719: LIST
31720: LIST
31721: LIST
31722: LIST
31723: LIST
31724: LIST
31725: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31726: LD_ADDR_VAR 0 22
31730: PUSH
31731: LD_INT 0
31733: PUSH
31734: LD_INT 0
31736: PUSH
31737: EMPTY
31738: LIST
31739: LIST
31740: PUSH
31741: LD_INT 0
31743: PUSH
31744: LD_INT 1
31746: NEG
31747: PUSH
31748: EMPTY
31749: LIST
31750: LIST
31751: PUSH
31752: LD_INT 1
31754: PUSH
31755: LD_INT 0
31757: PUSH
31758: EMPTY
31759: LIST
31760: LIST
31761: PUSH
31762: LD_INT 1
31764: PUSH
31765: LD_INT 1
31767: PUSH
31768: EMPTY
31769: LIST
31770: LIST
31771: PUSH
31772: LD_INT 0
31774: PUSH
31775: LD_INT 1
31777: PUSH
31778: EMPTY
31779: LIST
31780: LIST
31781: PUSH
31782: LD_INT 1
31784: NEG
31785: PUSH
31786: LD_INT 0
31788: PUSH
31789: EMPTY
31790: LIST
31791: LIST
31792: PUSH
31793: LD_INT 1
31795: NEG
31796: PUSH
31797: LD_INT 1
31799: NEG
31800: PUSH
31801: EMPTY
31802: LIST
31803: LIST
31804: PUSH
31805: LD_INT 1
31807: NEG
31808: PUSH
31809: LD_INT 2
31811: NEG
31812: PUSH
31813: EMPTY
31814: LIST
31815: LIST
31816: PUSH
31817: LD_INT 0
31819: PUSH
31820: LD_INT 2
31822: NEG
31823: PUSH
31824: EMPTY
31825: LIST
31826: LIST
31827: PUSH
31828: LD_INT 1
31830: PUSH
31831: LD_INT 1
31833: NEG
31834: PUSH
31835: EMPTY
31836: LIST
31837: LIST
31838: PUSH
31839: LD_INT 2
31841: PUSH
31842: LD_INT 0
31844: PUSH
31845: EMPTY
31846: LIST
31847: LIST
31848: PUSH
31849: LD_INT 2
31851: PUSH
31852: LD_INT 1
31854: PUSH
31855: EMPTY
31856: LIST
31857: LIST
31858: PUSH
31859: LD_INT 2
31861: PUSH
31862: LD_INT 2
31864: PUSH
31865: EMPTY
31866: LIST
31867: LIST
31868: PUSH
31869: LD_INT 1
31871: PUSH
31872: LD_INT 2
31874: PUSH
31875: EMPTY
31876: LIST
31877: LIST
31878: PUSH
31879: LD_INT 0
31881: PUSH
31882: LD_INT 2
31884: PUSH
31885: EMPTY
31886: LIST
31887: LIST
31888: PUSH
31889: LD_INT 1
31891: NEG
31892: PUSH
31893: LD_INT 1
31895: PUSH
31896: EMPTY
31897: LIST
31898: LIST
31899: PUSH
31900: LD_INT 2
31902: NEG
31903: PUSH
31904: LD_INT 0
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: LD_INT 2
31913: NEG
31914: PUSH
31915: LD_INT 1
31917: NEG
31918: PUSH
31919: EMPTY
31920: LIST
31921: LIST
31922: PUSH
31923: LD_INT 2
31925: NEG
31926: PUSH
31927: LD_INT 2
31929: NEG
31930: PUSH
31931: EMPTY
31932: LIST
31933: LIST
31934: PUSH
31935: EMPTY
31936: LIST
31937: LIST
31938: LIST
31939: LIST
31940: LIST
31941: LIST
31942: LIST
31943: LIST
31944: LIST
31945: LIST
31946: LIST
31947: LIST
31948: LIST
31949: LIST
31950: LIST
31951: LIST
31952: LIST
31953: LIST
31954: LIST
31955: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31956: LD_ADDR_VAR 0 23
31960: PUSH
31961: LD_INT 0
31963: PUSH
31964: LD_INT 0
31966: PUSH
31967: EMPTY
31968: LIST
31969: LIST
31970: PUSH
31971: LD_INT 0
31973: PUSH
31974: LD_INT 1
31976: NEG
31977: PUSH
31978: EMPTY
31979: LIST
31980: LIST
31981: PUSH
31982: LD_INT 1
31984: PUSH
31985: LD_INT 0
31987: PUSH
31988: EMPTY
31989: LIST
31990: LIST
31991: PUSH
31992: LD_INT 1
31994: PUSH
31995: LD_INT 1
31997: PUSH
31998: EMPTY
31999: LIST
32000: LIST
32001: PUSH
32002: LD_INT 0
32004: PUSH
32005: LD_INT 1
32007: PUSH
32008: EMPTY
32009: LIST
32010: LIST
32011: PUSH
32012: LD_INT 1
32014: NEG
32015: PUSH
32016: LD_INT 0
32018: PUSH
32019: EMPTY
32020: LIST
32021: LIST
32022: PUSH
32023: LD_INT 1
32025: NEG
32026: PUSH
32027: LD_INT 1
32029: NEG
32030: PUSH
32031: EMPTY
32032: LIST
32033: LIST
32034: PUSH
32035: LD_INT 1
32037: NEG
32038: PUSH
32039: LD_INT 2
32041: NEG
32042: PUSH
32043: EMPTY
32044: LIST
32045: LIST
32046: PUSH
32047: LD_INT 0
32049: PUSH
32050: LD_INT 2
32052: NEG
32053: PUSH
32054: EMPTY
32055: LIST
32056: LIST
32057: PUSH
32058: LD_INT 1
32060: PUSH
32061: LD_INT 1
32063: NEG
32064: PUSH
32065: EMPTY
32066: LIST
32067: LIST
32068: PUSH
32069: LD_INT 2
32071: PUSH
32072: LD_INT 0
32074: PUSH
32075: EMPTY
32076: LIST
32077: LIST
32078: PUSH
32079: LD_INT 2
32081: PUSH
32082: LD_INT 1
32084: PUSH
32085: EMPTY
32086: LIST
32087: LIST
32088: PUSH
32089: LD_INT 2
32091: PUSH
32092: LD_INT 2
32094: PUSH
32095: EMPTY
32096: LIST
32097: LIST
32098: PUSH
32099: LD_INT 1
32101: PUSH
32102: LD_INT 2
32104: PUSH
32105: EMPTY
32106: LIST
32107: LIST
32108: PUSH
32109: LD_INT 0
32111: PUSH
32112: LD_INT 2
32114: PUSH
32115: EMPTY
32116: LIST
32117: LIST
32118: PUSH
32119: LD_INT 1
32121: NEG
32122: PUSH
32123: LD_INT 1
32125: PUSH
32126: EMPTY
32127: LIST
32128: LIST
32129: PUSH
32130: LD_INT 2
32132: NEG
32133: PUSH
32134: LD_INT 0
32136: PUSH
32137: EMPTY
32138: LIST
32139: LIST
32140: PUSH
32141: LD_INT 2
32143: NEG
32144: PUSH
32145: LD_INT 1
32147: NEG
32148: PUSH
32149: EMPTY
32150: LIST
32151: LIST
32152: PUSH
32153: LD_INT 2
32155: NEG
32156: PUSH
32157: LD_INT 2
32159: NEG
32160: PUSH
32161: EMPTY
32162: LIST
32163: LIST
32164: PUSH
32165: LD_INT 2
32167: NEG
32168: PUSH
32169: LD_INT 3
32171: NEG
32172: PUSH
32173: EMPTY
32174: LIST
32175: LIST
32176: PUSH
32177: LD_INT 1
32179: NEG
32180: PUSH
32181: LD_INT 3
32183: NEG
32184: PUSH
32185: EMPTY
32186: LIST
32187: LIST
32188: PUSH
32189: LD_INT 1
32191: PUSH
32192: LD_INT 2
32194: NEG
32195: PUSH
32196: EMPTY
32197: LIST
32198: LIST
32199: PUSH
32200: LD_INT 2
32202: PUSH
32203: LD_INT 1
32205: NEG
32206: PUSH
32207: EMPTY
32208: LIST
32209: LIST
32210: PUSH
32211: EMPTY
32212: LIST
32213: LIST
32214: LIST
32215: LIST
32216: LIST
32217: LIST
32218: LIST
32219: LIST
32220: LIST
32221: LIST
32222: LIST
32223: LIST
32224: LIST
32225: LIST
32226: LIST
32227: LIST
32228: LIST
32229: LIST
32230: LIST
32231: LIST
32232: LIST
32233: LIST
32234: LIST
32235: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32236: LD_ADDR_VAR 0 24
32240: PUSH
32241: LD_INT 0
32243: PUSH
32244: LD_INT 0
32246: PUSH
32247: EMPTY
32248: LIST
32249: LIST
32250: PUSH
32251: LD_INT 0
32253: PUSH
32254: LD_INT 1
32256: NEG
32257: PUSH
32258: EMPTY
32259: LIST
32260: LIST
32261: PUSH
32262: LD_INT 1
32264: PUSH
32265: LD_INT 0
32267: PUSH
32268: EMPTY
32269: LIST
32270: LIST
32271: PUSH
32272: LD_INT 1
32274: PUSH
32275: LD_INT 1
32277: PUSH
32278: EMPTY
32279: LIST
32280: LIST
32281: PUSH
32282: LD_INT 0
32284: PUSH
32285: LD_INT 1
32287: PUSH
32288: EMPTY
32289: LIST
32290: LIST
32291: PUSH
32292: LD_INT 1
32294: NEG
32295: PUSH
32296: LD_INT 0
32298: PUSH
32299: EMPTY
32300: LIST
32301: LIST
32302: PUSH
32303: LD_INT 1
32305: NEG
32306: PUSH
32307: LD_INT 1
32309: NEG
32310: PUSH
32311: EMPTY
32312: LIST
32313: LIST
32314: PUSH
32315: LD_INT 1
32317: NEG
32318: PUSH
32319: LD_INT 2
32321: NEG
32322: PUSH
32323: EMPTY
32324: LIST
32325: LIST
32326: PUSH
32327: LD_INT 0
32329: PUSH
32330: LD_INT 2
32332: NEG
32333: PUSH
32334: EMPTY
32335: LIST
32336: LIST
32337: PUSH
32338: LD_INT 1
32340: PUSH
32341: LD_INT 1
32343: NEG
32344: PUSH
32345: EMPTY
32346: LIST
32347: LIST
32348: PUSH
32349: LD_INT 2
32351: PUSH
32352: LD_INT 0
32354: PUSH
32355: EMPTY
32356: LIST
32357: LIST
32358: PUSH
32359: LD_INT 2
32361: PUSH
32362: LD_INT 1
32364: PUSH
32365: EMPTY
32366: LIST
32367: LIST
32368: PUSH
32369: LD_INT 2
32371: PUSH
32372: LD_INT 2
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: PUSH
32379: LD_INT 1
32381: PUSH
32382: LD_INT 2
32384: PUSH
32385: EMPTY
32386: LIST
32387: LIST
32388: PUSH
32389: LD_INT 0
32391: PUSH
32392: LD_INT 2
32394: PUSH
32395: EMPTY
32396: LIST
32397: LIST
32398: PUSH
32399: LD_INT 1
32401: NEG
32402: PUSH
32403: LD_INT 1
32405: PUSH
32406: EMPTY
32407: LIST
32408: LIST
32409: PUSH
32410: LD_INT 2
32412: NEG
32413: PUSH
32414: LD_INT 0
32416: PUSH
32417: EMPTY
32418: LIST
32419: LIST
32420: PUSH
32421: LD_INT 2
32423: NEG
32424: PUSH
32425: LD_INT 1
32427: NEG
32428: PUSH
32429: EMPTY
32430: LIST
32431: LIST
32432: PUSH
32433: LD_INT 2
32435: NEG
32436: PUSH
32437: LD_INT 2
32439: NEG
32440: PUSH
32441: EMPTY
32442: LIST
32443: LIST
32444: PUSH
32445: LD_INT 1
32447: PUSH
32448: LD_INT 2
32450: NEG
32451: PUSH
32452: EMPTY
32453: LIST
32454: LIST
32455: PUSH
32456: LD_INT 2
32458: PUSH
32459: LD_INT 1
32461: NEG
32462: PUSH
32463: EMPTY
32464: LIST
32465: LIST
32466: PUSH
32467: LD_INT 3
32469: PUSH
32470: LD_INT 1
32472: PUSH
32473: EMPTY
32474: LIST
32475: LIST
32476: PUSH
32477: LD_INT 3
32479: PUSH
32480: LD_INT 2
32482: PUSH
32483: EMPTY
32484: LIST
32485: LIST
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: LIST
32491: LIST
32492: LIST
32493: LIST
32494: LIST
32495: LIST
32496: LIST
32497: LIST
32498: LIST
32499: LIST
32500: LIST
32501: LIST
32502: LIST
32503: LIST
32504: LIST
32505: LIST
32506: LIST
32507: LIST
32508: LIST
32509: LIST
32510: LIST
32511: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32512: LD_ADDR_VAR 0 25
32516: PUSH
32517: LD_INT 0
32519: PUSH
32520: LD_INT 0
32522: PUSH
32523: EMPTY
32524: LIST
32525: LIST
32526: PUSH
32527: LD_INT 0
32529: PUSH
32530: LD_INT 1
32532: NEG
32533: PUSH
32534: EMPTY
32535: LIST
32536: LIST
32537: PUSH
32538: LD_INT 1
32540: PUSH
32541: LD_INT 0
32543: PUSH
32544: EMPTY
32545: LIST
32546: LIST
32547: PUSH
32548: LD_INT 1
32550: PUSH
32551: LD_INT 1
32553: PUSH
32554: EMPTY
32555: LIST
32556: LIST
32557: PUSH
32558: LD_INT 0
32560: PUSH
32561: LD_INT 1
32563: PUSH
32564: EMPTY
32565: LIST
32566: LIST
32567: PUSH
32568: LD_INT 1
32570: NEG
32571: PUSH
32572: LD_INT 0
32574: PUSH
32575: EMPTY
32576: LIST
32577: LIST
32578: PUSH
32579: LD_INT 1
32581: NEG
32582: PUSH
32583: LD_INT 1
32585: NEG
32586: PUSH
32587: EMPTY
32588: LIST
32589: LIST
32590: PUSH
32591: LD_INT 1
32593: NEG
32594: PUSH
32595: LD_INT 2
32597: NEG
32598: PUSH
32599: EMPTY
32600: LIST
32601: LIST
32602: PUSH
32603: LD_INT 0
32605: PUSH
32606: LD_INT 2
32608: NEG
32609: PUSH
32610: EMPTY
32611: LIST
32612: LIST
32613: PUSH
32614: LD_INT 1
32616: PUSH
32617: LD_INT 1
32619: NEG
32620: PUSH
32621: EMPTY
32622: LIST
32623: LIST
32624: PUSH
32625: LD_INT 2
32627: PUSH
32628: LD_INT 0
32630: PUSH
32631: EMPTY
32632: LIST
32633: LIST
32634: PUSH
32635: LD_INT 2
32637: PUSH
32638: LD_INT 1
32640: PUSH
32641: EMPTY
32642: LIST
32643: LIST
32644: PUSH
32645: LD_INT 2
32647: PUSH
32648: LD_INT 2
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: PUSH
32655: LD_INT 1
32657: PUSH
32658: LD_INT 2
32660: PUSH
32661: EMPTY
32662: LIST
32663: LIST
32664: PUSH
32665: LD_INT 0
32667: PUSH
32668: LD_INT 2
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: PUSH
32675: LD_INT 1
32677: NEG
32678: PUSH
32679: LD_INT 1
32681: PUSH
32682: EMPTY
32683: LIST
32684: LIST
32685: PUSH
32686: LD_INT 2
32688: NEG
32689: PUSH
32690: LD_INT 0
32692: PUSH
32693: EMPTY
32694: LIST
32695: LIST
32696: PUSH
32697: LD_INT 2
32699: NEG
32700: PUSH
32701: LD_INT 1
32703: NEG
32704: PUSH
32705: EMPTY
32706: LIST
32707: LIST
32708: PUSH
32709: LD_INT 2
32711: NEG
32712: PUSH
32713: LD_INT 2
32715: NEG
32716: PUSH
32717: EMPTY
32718: LIST
32719: LIST
32720: PUSH
32721: LD_INT 3
32723: PUSH
32724: LD_INT 1
32726: PUSH
32727: EMPTY
32728: LIST
32729: LIST
32730: PUSH
32731: LD_INT 3
32733: PUSH
32734: LD_INT 2
32736: PUSH
32737: EMPTY
32738: LIST
32739: LIST
32740: PUSH
32741: LD_INT 2
32743: PUSH
32744: LD_INT 3
32746: PUSH
32747: EMPTY
32748: LIST
32749: LIST
32750: PUSH
32751: LD_INT 1
32753: PUSH
32754: LD_INT 3
32756: PUSH
32757: EMPTY
32758: LIST
32759: LIST
32760: PUSH
32761: EMPTY
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: LIST
32767: LIST
32768: LIST
32769: LIST
32770: LIST
32771: LIST
32772: LIST
32773: LIST
32774: LIST
32775: LIST
32776: LIST
32777: LIST
32778: LIST
32779: LIST
32780: LIST
32781: LIST
32782: LIST
32783: LIST
32784: LIST
32785: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32786: LD_ADDR_VAR 0 26
32790: PUSH
32791: LD_INT 0
32793: PUSH
32794: LD_INT 0
32796: PUSH
32797: EMPTY
32798: LIST
32799: LIST
32800: PUSH
32801: LD_INT 0
32803: PUSH
32804: LD_INT 1
32806: NEG
32807: PUSH
32808: EMPTY
32809: LIST
32810: LIST
32811: PUSH
32812: LD_INT 1
32814: PUSH
32815: LD_INT 0
32817: PUSH
32818: EMPTY
32819: LIST
32820: LIST
32821: PUSH
32822: LD_INT 1
32824: PUSH
32825: LD_INT 1
32827: PUSH
32828: EMPTY
32829: LIST
32830: LIST
32831: PUSH
32832: LD_INT 0
32834: PUSH
32835: LD_INT 1
32837: PUSH
32838: EMPTY
32839: LIST
32840: LIST
32841: PUSH
32842: LD_INT 1
32844: NEG
32845: PUSH
32846: LD_INT 0
32848: PUSH
32849: EMPTY
32850: LIST
32851: LIST
32852: PUSH
32853: LD_INT 1
32855: NEG
32856: PUSH
32857: LD_INT 1
32859: NEG
32860: PUSH
32861: EMPTY
32862: LIST
32863: LIST
32864: PUSH
32865: LD_INT 1
32867: NEG
32868: PUSH
32869: LD_INT 2
32871: NEG
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: PUSH
32877: LD_INT 0
32879: PUSH
32880: LD_INT 2
32882: NEG
32883: PUSH
32884: EMPTY
32885: LIST
32886: LIST
32887: PUSH
32888: LD_INT 1
32890: PUSH
32891: LD_INT 1
32893: NEG
32894: PUSH
32895: EMPTY
32896: LIST
32897: LIST
32898: PUSH
32899: LD_INT 2
32901: PUSH
32902: LD_INT 0
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: LD_INT 2
32911: PUSH
32912: LD_INT 1
32914: PUSH
32915: EMPTY
32916: LIST
32917: LIST
32918: PUSH
32919: LD_INT 2
32921: PUSH
32922: LD_INT 2
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: PUSH
32929: LD_INT 1
32931: PUSH
32932: LD_INT 2
32934: PUSH
32935: EMPTY
32936: LIST
32937: LIST
32938: PUSH
32939: LD_INT 0
32941: PUSH
32942: LD_INT 2
32944: PUSH
32945: EMPTY
32946: LIST
32947: LIST
32948: PUSH
32949: LD_INT 1
32951: NEG
32952: PUSH
32953: LD_INT 1
32955: PUSH
32956: EMPTY
32957: LIST
32958: LIST
32959: PUSH
32960: LD_INT 2
32962: NEG
32963: PUSH
32964: LD_INT 0
32966: PUSH
32967: EMPTY
32968: LIST
32969: LIST
32970: PUSH
32971: LD_INT 2
32973: NEG
32974: PUSH
32975: LD_INT 1
32977: NEG
32978: PUSH
32979: EMPTY
32980: LIST
32981: LIST
32982: PUSH
32983: LD_INT 2
32985: NEG
32986: PUSH
32987: LD_INT 2
32989: NEG
32990: PUSH
32991: EMPTY
32992: LIST
32993: LIST
32994: PUSH
32995: LD_INT 2
32997: PUSH
32998: LD_INT 3
33000: PUSH
33001: EMPTY
33002: LIST
33003: LIST
33004: PUSH
33005: LD_INT 1
33007: PUSH
33008: LD_INT 3
33010: PUSH
33011: EMPTY
33012: LIST
33013: LIST
33014: PUSH
33015: LD_INT 1
33017: NEG
33018: PUSH
33019: LD_INT 2
33021: PUSH
33022: EMPTY
33023: LIST
33024: LIST
33025: PUSH
33026: LD_INT 2
33028: NEG
33029: PUSH
33030: LD_INT 1
33032: PUSH
33033: EMPTY
33034: LIST
33035: LIST
33036: PUSH
33037: EMPTY
33038: LIST
33039: LIST
33040: LIST
33041: LIST
33042: LIST
33043: LIST
33044: LIST
33045: LIST
33046: LIST
33047: LIST
33048: LIST
33049: LIST
33050: LIST
33051: LIST
33052: LIST
33053: LIST
33054: LIST
33055: LIST
33056: LIST
33057: LIST
33058: LIST
33059: LIST
33060: LIST
33061: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33062: LD_ADDR_VAR 0 27
33066: PUSH
33067: LD_INT 0
33069: PUSH
33070: LD_INT 0
33072: PUSH
33073: EMPTY
33074: LIST
33075: LIST
33076: PUSH
33077: LD_INT 0
33079: PUSH
33080: LD_INT 1
33082: NEG
33083: PUSH
33084: EMPTY
33085: LIST
33086: LIST
33087: PUSH
33088: LD_INT 1
33090: PUSH
33091: LD_INT 0
33093: PUSH
33094: EMPTY
33095: LIST
33096: LIST
33097: PUSH
33098: LD_INT 1
33100: PUSH
33101: LD_INT 1
33103: PUSH
33104: EMPTY
33105: LIST
33106: LIST
33107: PUSH
33108: LD_INT 0
33110: PUSH
33111: LD_INT 1
33113: PUSH
33114: EMPTY
33115: LIST
33116: LIST
33117: PUSH
33118: LD_INT 1
33120: NEG
33121: PUSH
33122: LD_INT 0
33124: PUSH
33125: EMPTY
33126: LIST
33127: LIST
33128: PUSH
33129: LD_INT 1
33131: NEG
33132: PUSH
33133: LD_INT 1
33135: NEG
33136: PUSH
33137: EMPTY
33138: LIST
33139: LIST
33140: PUSH
33141: LD_INT 1
33143: NEG
33144: PUSH
33145: LD_INT 2
33147: NEG
33148: PUSH
33149: EMPTY
33150: LIST
33151: LIST
33152: PUSH
33153: LD_INT 0
33155: PUSH
33156: LD_INT 2
33158: NEG
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: PUSH
33164: LD_INT 1
33166: PUSH
33167: LD_INT 1
33169: NEG
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 2
33177: PUSH
33178: LD_INT 0
33180: PUSH
33181: EMPTY
33182: LIST
33183: LIST
33184: PUSH
33185: LD_INT 2
33187: PUSH
33188: LD_INT 1
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: PUSH
33195: LD_INT 2
33197: PUSH
33198: LD_INT 2
33200: PUSH
33201: EMPTY
33202: LIST
33203: LIST
33204: PUSH
33205: LD_INT 1
33207: PUSH
33208: LD_INT 2
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PUSH
33215: LD_INT 0
33217: PUSH
33218: LD_INT 2
33220: PUSH
33221: EMPTY
33222: LIST
33223: LIST
33224: PUSH
33225: LD_INT 1
33227: NEG
33228: PUSH
33229: LD_INT 1
33231: PUSH
33232: EMPTY
33233: LIST
33234: LIST
33235: PUSH
33236: LD_INT 2
33238: NEG
33239: PUSH
33240: LD_INT 0
33242: PUSH
33243: EMPTY
33244: LIST
33245: LIST
33246: PUSH
33247: LD_INT 2
33249: NEG
33250: PUSH
33251: LD_INT 1
33253: NEG
33254: PUSH
33255: EMPTY
33256: LIST
33257: LIST
33258: PUSH
33259: LD_INT 2
33261: NEG
33262: PUSH
33263: LD_INT 2
33265: NEG
33266: PUSH
33267: EMPTY
33268: LIST
33269: LIST
33270: PUSH
33271: LD_INT 1
33273: NEG
33274: PUSH
33275: LD_INT 2
33277: PUSH
33278: EMPTY
33279: LIST
33280: LIST
33281: PUSH
33282: LD_INT 2
33284: NEG
33285: PUSH
33286: LD_INT 1
33288: PUSH
33289: EMPTY
33290: LIST
33291: LIST
33292: PUSH
33293: LD_INT 3
33295: NEG
33296: PUSH
33297: LD_INT 1
33299: NEG
33300: PUSH
33301: EMPTY
33302: LIST
33303: LIST
33304: PUSH
33305: LD_INT 3
33307: NEG
33308: PUSH
33309: LD_INT 2
33311: NEG
33312: PUSH
33313: EMPTY
33314: LIST
33315: LIST
33316: PUSH
33317: EMPTY
33318: LIST
33319: LIST
33320: LIST
33321: LIST
33322: LIST
33323: LIST
33324: LIST
33325: LIST
33326: LIST
33327: LIST
33328: LIST
33329: LIST
33330: LIST
33331: LIST
33332: LIST
33333: LIST
33334: LIST
33335: LIST
33336: LIST
33337: LIST
33338: LIST
33339: LIST
33340: LIST
33341: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33342: LD_ADDR_VAR 0 28
33346: PUSH
33347: LD_INT 0
33349: PUSH
33350: LD_INT 0
33352: PUSH
33353: EMPTY
33354: LIST
33355: LIST
33356: PUSH
33357: LD_INT 0
33359: PUSH
33360: LD_INT 1
33362: NEG
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: LD_INT 1
33370: PUSH
33371: LD_INT 0
33373: PUSH
33374: EMPTY
33375: LIST
33376: LIST
33377: PUSH
33378: LD_INT 1
33380: PUSH
33381: LD_INT 1
33383: PUSH
33384: EMPTY
33385: LIST
33386: LIST
33387: PUSH
33388: LD_INT 0
33390: PUSH
33391: LD_INT 1
33393: PUSH
33394: EMPTY
33395: LIST
33396: LIST
33397: PUSH
33398: LD_INT 1
33400: NEG
33401: PUSH
33402: LD_INT 0
33404: PUSH
33405: EMPTY
33406: LIST
33407: LIST
33408: PUSH
33409: LD_INT 1
33411: NEG
33412: PUSH
33413: LD_INT 1
33415: NEG
33416: PUSH
33417: EMPTY
33418: LIST
33419: LIST
33420: PUSH
33421: LD_INT 1
33423: NEG
33424: PUSH
33425: LD_INT 2
33427: NEG
33428: PUSH
33429: EMPTY
33430: LIST
33431: LIST
33432: PUSH
33433: LD_INT 0
33435: PUSH
33436: LD_INT 2
33438: NEG
33439: PUSH
33440: EMPTY
33441: LIST
33442: LIST
33443: PUSH
33444: LD_INT 1
33446: PUSH
33447: LD_INT 1
33449: NEG
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: LD_INT 2
33457: PUSH
33458: LD_INT 0
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: PUSH
33465: LD_INT 2
33467: PUSH
33468: LD_INT 1
33470: PUSH
33471: EMPTY
33472: LIST
33473: LIST
33474: PUSH
33475: LD_INT 2
33477: PUSH
33478: LD_INT 2
33480: PUSH
33481: EMPTY
33482: LIST
33483: LIST
33484: PUSH
33485: LD_INT 1
33487: PUSH
33488: LD_INT 2
33490: PUSH
33491: EMPTY
33492: LIST
33493: LIST
33494: PUSH
33495: LD_INT 0
33497: PUSH
33498: LD_INT 2
33500: PUSH
33501: EMPTY
33502: LIST
33503: LIST
33504: PUSH
33505: LD_INT 1
33507: NEG
33508: PUSH
33509: LD_INT 1
33511: PUSH
33512: EMPTY
33513: LIST
33514: LIST
33515: PUSH
33516: LD_INT 2
33518: NEG
33519: PUSH
33520: LD_INT 0
33522: PUSH
33523: EMPTY
33524: LIST
33525: LIST
33526: PUSH
33527: LD_INT 2
33529: NEG
33530: PUSH
33531: LD_INT 1
33533: NEG
33534: PUSH
33535: EMPTY
33536: LIST
33537: LIST
33538: PUSH
33539: LD_INT 2
33541: NEG
33542: PUSH
33543: LD_INT 2
33545: NEG
33546: PUSH
33547: EMPTY
33548: LIST
33549: LIST
33550: PUSH
33551: LD_INT 2
33553: NEG
33554: PUSH
33555: LD_INT 3
33557: NEG
33558: PUSH
33559: EMPTY
33560: LIST
33561: LIST
33562: PUSH
33563: LD_INT 1
33565: NEG
33566: PUSH
33567: LD_INT 3
33569: NEG
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: PUSH
33575: LD_INT 3
33577: NEG
33578: PUSH
33579: LD_INT 1
33581: NEG
33582: PUSH
33583: EMPTY
33584: LIST
33585: LIST
33586: PUSH
33587: LD_INT 3
33589: NEG
33590: PUSH
33591: LD_INT 2
33593: NEG
33594: PUSH
33595: EMPTY
33596: LIST
33597: LIST
33598: PUSH
33599: EMPTY
33600: LIST
33601: LIST
33602: LIST
33603: LIST
33604: LIST
33605: LIST
33606: LIST
33607: LIST
33608: LIST
33609: LIST
33610: LIST
33611: LIST
33612: LIST
33613: LIST
33614: LIST
33615: LIST
33616: LIST
33617: LIST
33618: LIST
33619: LIST
33620: LIST
33621: LIST
33622: LIST
33623: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33624: LD_ADDR_VAR 0 29
33628: PUSH
33629: LD_INT 0
33631: PUSH
33632: LD_INT 0
33634: PUSH
33635: EMPTY
33636: LIST
33637: LIST
33638: PUSH
33639: LD_INT 0
33641: PUSH
33642: LD_INT 1
33644: NEG
33645: PUSH
33646: EMPTY
33647: LIST
33648: LIST
33649: PUSH
33650: LD_INT 1
33652: PUSH
33653: LD_INT 0
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 1
33662: PUSH
33663: LD_INT 1
33665: PUSH
33666: EMPTY
33667: LIST
33668: LIST
33669: PUSH
33670: LD_INT 0
33672: PUSH
33673: LD_INT 1
33675: PUSH
33676: EMPTY
33677: LIST
33678: LIST
33679: PUSH
33680: LD_INT 1
33682: NEG
33683: PUSH
33684: LD_INT 0
33686: PUSH
33687: EMPTY
33688: LIST
33689: LIST
33690: PUSH
33691: LD_INT 1
33693: NEG
33694: PUSH
33695: LD_INT 1
33697: NEG
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PUSH
33703: LD_INT 1
33705: NEG
33706: PUSH
33707: LD_INT 2
33709: NEG
33710: PUSH
33711: EMPTY
33712: LIST
33713: LIST
33714: PUSH
33715: LD_INT 0
33717: PUSH
33718: LD_INT 2
33720: NEG
33721: PUSH
33722: EMPTY
33723: LIST
33724: LIST
33725: PUSH
33726: LD_INT 1
33728: PUSH
33729: LD_INT 1
33731: NEG
33732: PUSH
33733: EMPTY
33734: LIST
33735: LIST
33736: PUSH
33737: LD_INT 2
33739: PUSH
33740: LD_INT 0
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: PUSH
33747: LD_INT 2
33749: PUSH
33750: LD_INT 1
33752: PUSH
33753: EMPTY
33754: LIST
33755: LIST
33756: PUSH
33757: LD_INT 1
33759: PUSH
33760: LD_INT 2
33762: PUSH
33763: EMPTY
33764: LIST
33765: LIST
33766: PUSH
33767: LD_INT 0
33769: PUSH
33770: LD_INT 2
33772: PUSH
33773: EMPTY
33774: LIST
33775: LIST
33776: PUSH
33777: LD_INT 1
33779: NEG
33780: PUSH
33781: LD_INT 1
33783: PUSH
33784: EMPTY
33785: LIST
33786: LIST
33787: PUSH
33788: LD_INT 2
33790: NEG
33791: PUSH
33792: LD_INT 1
33794: NEG
33795: PUSH
33796: EMPTY
33797: LIST
33798: LIST
33799: PUSH
33800: LD_INT 2
33802: NEG
33803: PUSH
33804: LD_INT 2
33806: NEG
33807: PUSH
33808: EMPTY
33809: LIST
33810: LIST
33811: PUSH
33812: LD_INT 2
33814: NEG
33815: PUSH
33816: LD_INT 3
33818: NEG
33819: PUSH
33820: EMPTY
33821: LIST
33822: LIST
33823: PUSH
33824: LD_INT 2
33826: PUSH
33827: LD_INT 1
33829: NEG
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: PUSH
33835: LD_INT 3
33837: PUSH
33838: LD_INT 1
33840: PUSH
33841: EMPTY
33842: LIST
33843: LIST
33844: PUSH
33845: LD_INT 1
33847: PUSH
33848: LD_INT 3
33850: PUSH
33851: EMPTY
33852: LIST
33853: LIST
33854: PUSH
33855: LD_INT 1
33857: NEG
33858: PUSH
33859: LD_INT 2
33861: PUSH
33862: EMPTY
33863: LIST
33864: LIST
33865: PUSH
33866: LD_INT 3
33868: NEG
33869: PUSH
33870: LD_INT 2
33872: NEG
33873: PUSH
33874: EMPTY
33875: LIST
33876: LIST
33877: PUSH
33878: EMPTY
33879: LIST
33880: LIST
33881: LIST
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: LIST
33890: LIST
33891: LIST
33892: LIST
33893: LIST
33894: LIST
33895: LIST
33896: LIST
33897: LIST
33898: LIST
33899: LIST
33900: LIST
33901: LIST
33902: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33903: LD_ADDR_VAR 0 30
33907: PUSH
33908: LD_INT 0
33910: PUSH
33911: LD_INT 0
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 0
33920: PUSH
33921: LD_INT 1
33923: NEG
33924: PUSH
33925: EMPTY
33926: LIST
33927: LIST
33928: PUSH
33929: LD_INT 1
33931: PUSH
33932: LD_INT 0
33934: PUSH
33935: EMPTY
33936: LIST
33937: LIST
33938: PUSH
33939: LD_INT 1
33941: PUSH
33942: LD_INT 1
33944: PUSH
33945: EMPTY
33946: LIST
33947: LIST
33948: PUSH
33949: LD_INT 0
33951: PUSH
33952: LD_INT 1
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 1
33961: NEG
33962: PUSH
33963: LD_INT 0
33965: PUSH
33966: EMPTY
33967: LIST
33968: LIST
33969: PUSH
33970: LD_INT 1
33972: NEG
33973: PUSH
33974: LD_INT 1
33976: NEG
33977: PUSH
33978: EMPTY
33979: LIST
33980: LIST
33981: PUSH
33982: LD_INT 1
33984: NEG
33985: PUSH
33986: LD_INT 2
33988: NEG
33989: PUSH
33990: EMPTY
33991: LIST
33992: LIST
33993: PUSH
33994: LD_INT 0
33996: PUSH
33997: LD_INT 2
33999: NEG
34000: PUSH
34001: EMPTY
34002: LIST
34003: LIST
34004: PUSH
34005: LD_INT 1
34007: PUSH
34008: LD_INT 1
34010: NEG
34011: PUSH
34012: EMPTY
34013: LIST
34014: LIST
34015: PUSH
34016: LD_INT 2
34018: PUSH
34019: LD_INT 0
34021: PUSH
34022: EMPTY
34023: LIST
34024: LIST
34025: PUSH
34026: LD_INT 2
34028: PUSH
34029: LD_INT 1
34031: PUSH
34032: EMPTY
34033: LIST
34034: LIST
34035: PUSH
34036: LD_INT 2
34038: PUSH
34039: LD_INT 2
34041: PUSH
34042: EMPTY
34043: LIST
34044: LIST
34045: PUSH
34046: LD_INT 1
34048: PUSH
34049: LD_INT 2
34051: PUSH
34052: EMPTY
34053: LIST
34054: LIST
34055: PUSH
34056: LD_INT 1
34058: NEG
34059: PUSH
34060: LD_INT 1
34062: PUSH
34063: EMPTY
34064: LIST
34065: LIST
34066: PUSH
34067: LD_INT 2
34069: NEG
34070: PUSH
34071: LD_INT 0
34073: PUSH
34074: EMPTY
34075: LIST
34076: LIST
34077: PUSH
34078: LD_INT 2
34080: NEG
34081: PUSH
34082: LD_INT 1
34084: NEG
34085: PUSH
34086: EMPTY
34087: LIST
34088: LIST
34089: PUSH
34090: LD_INT 1
34092: NEG
34093: PUSH
34094: LD_INT 3
34096: NEG
34097: PUSH
34098: EMPTY
34099: LIST
34100: LIST
34101: PUSH
34102: LD_INT 1
34104: PUSH
34105: LD_INT 2
34107: NEG
34108: PUSH
34109: EMPTY
34110: LIST
34111: LIST
34112: PUSH
34113: LD_INT 3
34115: PUSH
34116: LD_INT 2
34118: PUSH
34119: EMPTY
34120: LIST
34121: LIST
34122: PUSH
34123: LD_INT 2
34125: PUSH
34126: LD_INT 3
34128: PUSH
34129: EMPTY
34130: LIST
34131: LIST
34132: PUSH
34133: LD_INT 2
34135: NEG
34136: PUSH
34137: LD_INT 1
34139: PUSH
34140: EMPTY
34141: LIST
34142: LIST
34143: PUSH
34144: LD_INT 3
34146: NEG
34147: PUSH
34148: LD_INT 1
34150: NEG
34151: PUSH
34152: EMPTY
34153: LIST
34154: LIST
34155: PUSH
34156: EMPTY
34157: LIST
34158: LIST
34159: LIST
34160: LIST
34161: LIST
34162: LIST
34163: LIST
34164: LIST
34165: LIST
34166: LIST
34167: LIST
34168: LIST
34169: LIST
34170: LIST
34171: LIST
34172: LIST
34173: LIST
34174: LIST
34175: LIST
34176: LIST
34177: LIST
34178: LIST
34179: LIST
34180: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34181: LD_ADDR_VAR 0 31
34185: PUSH
34186: LD_INT 0
34188: PUSH
34189: LD_INT 0
34191: PUSH
34192: EMPTY
34193: LIST
34194: LIST
34195: PUSH
34196: LD_INT 0
34198: PUSH
34199: LD_INT 1
34201: NEG
34202: PUSH
34203: EMPTY
34204: LIST
34205: LIST
34206: PUSH
34207: LD_INT 1
34209: PUSH
34210: LD_INT 0
34212: PUSH
34213: EMPTY
34214: LIST
34215: LIST
34216: PUSH
34217: LD_INT 1
34219: PUSH
34220: LD_INT 1
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: LD_INT 0
34229: PUSH
34230: LD_INT 1
34232: PUSH
34233: EMPTY
34234: LIST
34235: LIST
34236: PUSH
34237: LD_INT 1
34239: NEG
34240: PUSH
34241: LD_INT 0
34243: PUSH
34244: EMPTY
34245: LIST
34246: LIST
34247: PUSH
34248: LD_INT 1
34250: NEG
34251: PUSH
34252: LD_INT 1
34254: NEG
34255: PUSH
34256: EMPTY
34257: LIST
34258: LIST
34259: PUSH
34260: LD_INT 1
34262: NEG
34263: PUSH
34264: LD_INT 2
34266: NEG
34267: PUSH
34268: EMPTY
34269: LIST
34270: LIST
34271: PUSH
34272: LD_INT 1
34274: PUSH
34275: LD_INT 1
34277: NEG
34278: PUSH
34279: EMPTY
34280: LIST
34281: LIST
34282: PUSH
34283: LD_INT 2
34285: PUSH
34286: LD_INT 0
34288: PUSH
34289: EMPTY
34290: LIST
34291: LIST
34292: PUSH
34293: LD_INT 2
34295: PUSH
34296: LD_INT 1
34298: PUSH
34299: EMPTY
34300: LIST
34301: LIST
34302: PUSH
34303: LD_INT 2
34305: PUSH
34306: LD_INT 2
34308: PUSH
34309: EMPTY
34310: LIST
34311: LIST
34312: PUSH
34313: LD_INT 1
34315: PUSH
34316: LD_INT 2
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 0
34325: PUSH
34326: LD_INT 2
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: PUSH
34333: LD_INT 1
34335: NEG
34336: PUSH
34337: LD_INT 1
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PUSH
34344: LD_INT 2
34346: NEG
34347: PUSH
34348: LD_INT 1
34350: NEG
34351: PUSH
34352: EMPTY
34353: LIST
34354: LIST
34355: PUSH
34356: LD_INT 2
34358: NEG
34359: PUSH
34360: LD_INT 2
34362: NEG
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: PUSH
34368: LD_INT 2
34370: NEG
34371: PUSH
34372: LD_INT 3
34374: NEG
34375: PUSH
34376: EMPTY
34377: LIST
34378: LIST
34379: PUSH
34380: LD_INT 2
34382: PUSH
34383: LD_INT 1
34385: NEG
34386: PUSH
34387: EMPTY
34388: LIST
34389: LIST
34390: PUSH
34391: LD_INT 3
34393: PUSH
34394: LD_INT 1
34396: PUSH
34397: EMPTY
34398: LIST
34399: LIST
34400: PUSH
34401: LD_INT 1
34403: PUSH
34404: LD_INT 3
34406: PUSH
34407: EMPTY
34408: LIST
34409: LIST
34410: PUSH
34411: LD_INT 1
34413: NEG
34414: PUSH
34415: LD_INT 2
34417: PUSH
34418: EMPTY
34419: LIST
34420: LIST
34421: PUSH
34422: LD_INT 3
34424: NEG
34425: PUSH
34426: LD_INT 2
34428: NEG
34429: PUSH
34430: EMPTY
34431: LIST
34432: LIST
34433: PUSH
34434: EMPTY
34435: LIST
34436: LIST
34437: LIST
34438: LIST
34439: LIST
34440: LIST
34441: LIST
34442: LIST
34443: LIST
34444: LIST
34445: LIST
34446: LIST
34447: LIST
34448: LIST
34449: LIST
34450: LIST
34451: LIST
34452: LIST
34453: LIST
34454: LIST
34455: LIST
34456: LIST
34457: LIST
34458: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34459: LD_ADDR_VAR 0 32
34463: PUSH
34464: LD_INT 0
34466: PUSH
34467: LD_INT 0
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 0
34476: PUSH
34477: LD_INT 1
34479: NEG
34480: PUSH
34481: EMPTY
34482: LIST
34483: LIST
34484: PUSH
34485: LD_INT 1
34487: PUSH
34488: LD_INT 0
34490: PUSH
34491: EMPTY
34492: LIST
34493: LIST
34494: PUSH
34495: LD_INT 1
34497: PUSH
34498: LD_INT 1
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: PUSH
34505: LD_INT 0
34507: PUSH
34508: LD_INT 1
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: LD_INT 1
34517: NEG
34518: PUSH
34519: LD_INT 0
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: LD_INT 1
34528: NEG
34529: PUSH
34530: LD_INT 1
34532: NEG
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: LD_INT 1
34540: NEG
34541: PUSH
34542: LD_INT 2
34544: NEG
34545: PUSH
34546: EMPTY
34547: LIST
34548: LIST
34549: PUSH
34550: LD_INT 0
34552: PUSH
34553: LD_INT 2
34555: NEG
34556: PUSH
34557: EMPTY
34558: LIST
34559: LIST
34560: PUSH
34561: LD_INT 1
34563: PUSH
34564: LD_INT 1
34566: NEG
34567: PUSH
34568: EMPTY
34569: LIST
34570: LIST
34571: PUSH
34572: LD_INT 2
34574: PUSH
34575: LD_INT 1
34577: PUSH
34578: EMPTY
34579: LIST
34580: LIST
34581: PUSH
34582: LD_INT 2
34584: PUSH
34585: LD_INT 2
34587: PUSH
34588: EMPTY
34589: LIST
34590: LIST
34591: PUSH
34592: LD_INT 1
34594: PUSH
34595: LD_INT 2
34597: PUSH
34598: EMPTY
34599: LIST
34600: LIST
34601: PUSH
34602: LD_INT 0
34604: PUSH
34605: LD_INT 2
34607: PUSH
34608: EMPTY
34609: LIST
34610: LIST
34611: PUSH
34612: LD_INT 1
34614: NEG
34615: PUSH
34616: LD_INT 1
34618: PUSH
34619: EMPTY
34620: LIST
34621: LIST
34622: PUSH
34623: LD_INT 2
34625: NEG
34626: PUSH
34627: LD_INT 0
34629: PUSH
34630: EMPTY
34631: LIST
34632: LIST
34633: PUSH
34634: LD_INT 2
34636: NEG
34637: PUSH
34638: LD_INT 1
34640: NEG
34641: PUSH
34642: EMPTY
34643: LIST
34644: LIST
34645: PUSH
34646: LD_INT 1
34648: NEG
34649: PUSH
34650: LD_INT 3
34652: NEG
34653: PUSH
34654: EMPTY
34655: LIST
34656: LIST
34657: PUSH
34658: LD_INT 1
34660: PUSH
34661: LD_INT 2
34663: NEG
34664: PUSH
34665: EMPTY
34666: LIST
34667: LIST
34668: PUSH
34669: LD_INT 3
34671: PUSH
34672: LD_INT 2
34674: PUSH
34675: EMPTY
34676: LIST
34677: LIST
34678: PUSH
34679: LD_INT 2
34681: PUSH
34682: LD_INT 3
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: PUSH
34689: LD_INT 2
34691: NEG
34692: PUSH
34693: LD_INT 1
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: PUSH
34700: LD_INT 3
34702: NEG
34703: PUSH
34704: LD_INT 1
34706: NEG
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: LIST
34735: LIST
34736: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34737: LD_ADDR_VAR 0 33
34741: PUSH
34742: LD_INT 0
34744: PUSH
34745: LD_INT 0
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: PUSH
34752: LD_INT 0
34754: PUSH
34755: LD_INT 1
34757: NEG
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 1
34765: PUSH
34766: LD_INT 0
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: LD_INT 1
34775: PUSH
34776: LD_INT 1
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 0
34785: PUSH
34786: LD_INT 1
34788: PUSH
34789: EMPTY
34790: LIST
34791: LIST
34792: PUSH
34793: LD_INT 1
34795: NEG
34796: PUSH
34797: LD_INT 0
34799: PUSH
34800: EMPTY
34801: LIST
34802: LIST
34803: PUSH
34804: LD_INT 1
34806: NEG
34807: PUSH
34808: LD_INT 1
34810: NEG
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 1
34818: NEG
34819: PUSH
34820: LD_INT 2
34822: NEG
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: LD_INT 1
34830: PUSH
34831: LD_INT 1
34833: NEG
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: PUSH
34839: LD_INT 2
34841: PUSH
34842: LD_INT 0
34844: PUSH
34845: EMPTY
34846: LIST
34847: LIST
34848: PUSH
34849: LD_INT 2
34851: PUSH
34852: LD_INT 1
34854: PUSH
34855: EMPTY
34856: LIST
34857: LIST
34858: PUSH
34859: LD_INT 1
34861: PUSH
34862: LD_INT 2
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PUSH
34869: LD_INT 0
34871: PUSH
34872: LD_INT 2
34874: PUSH
34875: EMPTY
34876: LIST
34877: LIST
34878: PUSH
34879: LD_INT 1
34881: NEG
34882: PUSH
34883: LD_INT 1
34885: PUSH
34886: EMPTY
34887: LIST
34888: LIST
34889: PUSH
34890: LD_INT 2
34892: NEG
34893: PUSH
34894: LD_INT 0
34896: PUSH
34897: EMPTY
34898: LIST
34899: LIST
34900: PUSH
34901: LD_INT 2
34903: NEG
34904: PUSH
34905: LD_INT 1
34907: NEG
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: LD_INT 2
34915: NEG
34916: PUSH
34917: LD_INT 2
34919: NEG
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: LD_INT 2
34927: NEG
34928: PUSH
34929: LD_INT 3
34931: NEG
34932: PUSH
34933: EMPTY
34934: LIST
34935: LIST
34936: PUSH
34937: LD_INT 2
34939: PUSH
34940: LD_INT 1
34942: NEG
34943: PUSH
34944: EMPTY
34945: LIST
34946: LIST
34947: PUSH
34948: LD_INT 3
34950: PUSH
34951: LD_INT 1
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: PUSH
34958: LD_INT 1
34960: PUSH
34961: LD_INT 3
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: LD_INT 1
34970: NEG
34971: PUSH
34972: LD_INT 2
34974: PUSH
34975: EMPTY
34976: LIST
34977: LIST
34978: PUSH
34979: LD_INT 3
34981: NEG
34982: PUSH
34983: LD_INT 2
34985: NEG
34986: PUSH
34987: EMPTY
34988: LIST
34989: LIST
34990: PUSH
34991: EMPTY
34992: LIST
34993: LIST
34994: LIST
34995: LIST
34996: LIST
34997: LIST
34998: LIST
34999: LIST
35000: LIST
35001: LIST
35002: LIST
35003: LIST
35004: LIST
35005: LIST
35006: LIST
35007: LIST
35008: LIST
35009: LIST
35010: LIST
35011: LIST
35012: LIST
35013: LIST
35014: LIST
35015: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35016: LD_ADDR_VAR 0 34
35020: PUSH
35021: LD_INT 0
35023: PUSH
35024: LD_INT 0
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: PUSH
35031: LD_INT 0
35033: PUSH
35034: LD_INT 1
35036: NEG
35037: PUSH
35038: EMPTY
35039: LIST
35040: LIST
35041: PUSH
35042: LD_INT 1
35044: PUSH
35045: LD_INT 0
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: LD_INT 1
35054: PUSH
35055: LD_INT 1
35057: PUSH
35058: EMPTY
35059: LIST
35060: LIST
35061: PUSH
35062: LD_INT 0
35064: PUSH
35065: LD_INT 1
35067: PUSH
35068: EMPTY
35069: LIST
35070: LIST
35071: PUSH
35072: LD_INT 1
35074: NEG
35075: PUSH
35076: LD_INT 0
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: PUSH
35083: LD_INT 1
35085: NEG
35086: PUSH
35087: LD_INT 1
35089: NEG
35090: PUSH
35091: EMPTY
35092: LIST
35093: LIST
35094: PUSH
35095: LD_INT 1
35097: NEG
35098: PUSH
35099: LD_INT 2
35101: NEG
35102: PUSH
35103: EMPTY
35104: LIST
35105: LIST
35106: PUSH
35107: LD_INT 0
35109: PUSH
35110: LD_INT 2
35112: NEG
35113: PUSH
35114: EMPTY
35115: LIST
35116: LIST
35117: PUSH
35118: LD_INT 1
35120: PUSH
35121: LD_INT 1
35123: NEG
35124: PUSH
35125: EMPTY
35126: LIST
35127: LIST
35128: PUSH
35129: LD_INT 2
35131: PUSH
35132: LD_INT 1
35134: PUSH
35135: EMPTY
35136: LIST
35137: LIST
35138: PUSH
35139: LD_INT 2
35141: PUSH
35142: LD_INT 2
35144: PUSH
35145: EMPTY
35146: LIST
35147: LIST
35148: PUSH
35149: LD_INT 1
35151: PUSH
35152: LD_INT 2
35154: PUSH
35155: EMPTY
35156: LIST
35157: LIST
35158: PUSH
35159: LD_INT 1
35161: NEG
35162: PUSH
35163: LD_INT 1
35165: PUSH
35166: EMPTY
35167: LIST
35168: LIST
35169: PUSH
35170: LD_INT 2
35172: NEG
35173: PUSH
35174: LD_INT 0
35176: PUSH
35177: EMPTY
35178: LIST
35179: LIST
35180: PUSH
35181: LD_INT 2
35183: NEG
35184: PUSH
35185: LD_INT 1
35187: NEG
35188: PUSH
35189: EMPTY
35190: LIST
35191: LIST
35192: PUSH
35193: LD_INT 2
35195: NEG
35196: PUSH
35197: LD_INT 2
35199: NEG
35200: PUSH
35201: EMPTY
35202: LIST
35203: LIST
35204: PUSH
35205: LD_INT 1
35207: NEG
35208: PUSH
35209: LD_INT 3
35211: NEG
35212: PUSH
35213: EMPTY
35214: LIST
35215: LIST
35216: PUSH
35217: LD_INT 1
35219: PUSH
35220: LD_INT 2
35222: NEG
35223: PUSH
35224: EMPTY
35225: LIST
35226: LIST
35227: PUSH
35228: LD_INT 3
35230: PUSH
35231: LD_INT 2
35233: PUSH
35234: EMPTY
35235: LIST
35236: LIST
35237: PUSH
35238: LD_INT 2
35240: PUSH
35241: LD_INT 3
35243: PUSH
35244: EMPTY
35245: LIST
35246: LIST
35247: PUSH
35248: LD_INT 2
35250: NEG
35251: PUSH
35252: LD_INT 1
35254: PUSH
35255: EMPTY
35256: LIST
35257: LIST
35258: PUSH
35259: LD_INT 3
35261: NEG
35262: PUSH
35263: LD_INT 1
35265: NEG
35266: PUSH
35267: EMPTY
35268: LIST
35269: LIST
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: LIST
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: LIST
35285: LIST
35286: LIST
35287: LIST
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35296: LD_ADDR_VAR 0 35
35300: PUSH
35301: LD_INT 0
35303: PUSH
35304: LD_INT 0
35306: PUSH
35307: EMPTY
35308: LIST
35309: LIST
35310: PUSH
35311: LD_INT 0
35313: PUSH
35314: LD_INT 1
35316: NEG
35317: PUSH
35318: EMPTY
35319: LIST
35320: LIST
35321: PUSH
35322: LD_INT 1
35324: PUSH
35325: LD_INT 0
35327: PUSH
35328: EMPTY
35329: LIST
35330: LIST
35331: PUSH
35332: LD_INT 1
35334: PUSH
35335: LD_INT 1
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: LD_INT 0
35344: PUSH
35345: LD_INT 1
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PUSH
35352: LD_INT 1
35354: NEG
35355: PUSH
35356: LD_INT 0
35358: PUSH
35359: EMPTY
35360: LIST
35361: LIST
35362: PUSH
35363: LD_INT 1
35365: NEG
35366: PUSH
35367: LD_INT 1
35369: NEG
35370: PUSH
35371: EMPTY
35372: LIST
35373: LIST
35374: PUSH
35375: LD_INT 2
35377: PUSH
35378: LD_INT 1
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: PUSH
35385: LD_INT 2
35387: NEG
35388: PUSH
35389: LD_INT 1
35391: NEG
35392: PUSH
35393: EMPTY
35394: LIST
35395: LIST
35396: PUSH
35397: EMPTY
35398: LIST
35399: LIST
35400: LIST
35401: LIST
35402: LIST
35403: LIST
35404: LIST
35405: LIST
35406: LIST
35407: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35408: LD_ADDR_VAR 0 36
35412: PUSH
35413: LD_INT 0
35415: PUSH
35416: LD_INT 0
35418: PUSH
35419: EMPTY
35420: LIST
35421: LIST
35422: PUSH
35423: LD_INT 0
35425: PUSH
35426: LD_INT 1
35428: NEG
35429: PUSH
35430: EMPTY
35431: LIST
35432: LIST
35433: PUSH
35434: LD_INT 1
35436: PUSH
35437: LD_INT 0
35439: PUSH
35440: EMPTY
35441: LIST
35442: LIST
35443: PUSH
35444: LD_INT 1
35446: PUSH
35447: LD_INT 1
35449: PUSH
35450: EMPTY
35451: LIST
35452: LIST
35453: PUSH
35454: LD_INT 0
35456: PUSH
35457: LD_INT 1
35459: PUSH
35460: EMPTY
35461: LIST
35462: LIST
35463: PUSH
35464: LD_INT 1
35466: NEG
35467: PUSH
35468: LD_INT 0
35470: PUSH
35471: EMPTY
35472: LIST
35473: LIST
35474: PUSH
35475: LD_INT 1
35477: NEG
35478: PUSH
35479: LD_INT 1
35481: NEG
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: LD_INT 1
35489: NEG
35490: PUSH
35491: LD_INT 2
35493: NEG
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: PUSH
35499: LD_INT 1
35501: PUSH
35502: LD_INT 2
35504: PUSH
35505: EMPTY
35506: LIST
35507: LIST
35508: PUSH
35509: EMPTY
35510: LIST
35511: LIST
35512: LIST
35513: LIST
35514: LIST
35515: LIST
35516: LIST
35517: LIST
35518: LIST
35519: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35520: LD_ADDR_VAR 0 37
35524: PUSH
35525: LD_INT 0
35527: PUSH
35528: LD_INT 0
35530: PUSH
35531: EMPTY
35532: LIST
35533: LIST
35534: PUSH
35535: LD_INT 0
35537: PUSH
35538: LD_INT 1
35540: NEG
35541: PUSH
35542: EMPTY
35543: LIST
35544: LIST
35545: PUSH
35546: LD_INT 1
35548: PUSH
35549: LD_INT 0
35551: PUSH
35552: EMPTY
35553: LIST
35554: LIST
35555: PUSH
35556: LD_INT 1
35558: PUSH
35559: LD_INT 1
35561: PUSH
35562: EMPTY
35563: LIST
35564: LIST
35565: PUSH
35566: LD_INT 0
35568: PUSH
35569: LD_INT 1
35571: PUSH
35572: EMPTY
35573: LIST
35574: LIST
35575: PUSH
35576: LD_INT 1
35578: NEG
35579: PUSH
35580: LD_INT 0
35582: PUSH
35583: EMPTY
35584: LIST
35585: LIST
35586: PUSH
35587: LD_INT 1
35589: NEG
35590: PUSH
35591: LD_INT 1
35593: NEG
35594: PUSH
35595: EMPTY
35596: LIST
35597: LIST
35598: PUSH
35599: LD_INT 1
35601: PUSH
35602: LD_INT 1
35604: NEG
35605: PUSH
35606: EMPTY
35607: LIST
35608: LIST
35609: PUSH
35610: LD_INT 1
35612: NEG
35613: PUSH
35614: LD_INT 1
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: EMPTY
35622: LIST
35623: LIST
35624: LIST
35625: LIST
35626: LIST
35627: LIST
35628: LIST
35629: LIST
35630: LIST
35631: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35632: LD_ADDR_VAR 0 38
35636: PUSH
35637: LD_INT 0
35639: PUSH
35640: LD_INT 0
35642: PUSH
35643: EMPTY
35644: LIST
35645: LIST
35646: PUSH
35647: LD_INT 0
35649: PUSH
35650: LD_INT 1
35652: NEG
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: PUSH
35658: LD_INT 1
35660: PUSH
35661: LD_INT 0
35663: PUSH
35664: EMPTY
35665: LIST
35666: LIST
35667: PUSH
35668: LD_INT 1
35670: PUSH
35671: LD_INT 1
35673: PUSH
35674: EMPTY
35675: LIST
35676: LIST
35677: PUSH
35678: LD_INT 0
35680: PUSH
35681: LD_INT 1
35683: PUSH
35684: EMPTY
35685: LIST
35686: LIST
35687: PUSH
35688: LD_INT 1
35690: NEG
35691: PUSH
35692: LD_INT 0
35694: PUSH
35695: EMPTY
35696: LIST
35697: LIST
35698: PUSH
35699: LD_INT 1
35701: NEG
35702: PUSH
35703: LD_INT 1
35705: NEG
35706: PUSH
35707: EMPTY
35708: LIST
35709: LIST
35710: PUSH
35711: LD_INT 2
35713: PUSH
35714: LD_INT 1
35716: PUSH
35717: EMPTY
35718: LIST
35719: LIST
35720: PUSH
35721: LD_INT 2
35723: NEG
35724: PUSH
35725: LD_INT 1
35727: NEG
35728: PUSH
35729: EMPTY
35730: LIST
35731: LIST
35732: PUSH
35733: EMPTY
35734: LIST
35735: LIST
35736: LIST
35737: LIST
35738: LIST
35739: LIST
35740: LIST
35741: LIST
35742: LIST
35743: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35744: LD_ADDR_VAR 0 39
35748: PUSH
35749: LD_INT 0
35751: PUSH
35752: LD_INT 0
35754: PUSH
35755: EMPTY
35756: LIST
35757: LIST
35758: PUSH
35759: LD_INT 0
35761: PUSH
35762: LD_INT 1
35764: NEG
35765: PUSH
35766: EMPTY
35767: LIST
35768: LIST
35769: PUSH
35770: LD_INT 1
35772: PUSH
35773: LD_INT 0
35775: PUSH
35776: EMPTY
35777: LIST
35778: LIST
35779: PUSH
35780: LD_INT 1
35782: PUSH
35783: LD_INT 1
35785: PUSH
35786: EMPTY
35787: LIST
35788: LIST
35789: PUSH
35790: LD_INT 0
35792: PUSH
35793: LD_INT 1
35795: PUSH
35796: EMPTY
35797: LIST
35798: LIST
35799: PUSH
35800: LD_INT 1
35802: NEG
35803: PUSH
35804: LD_INT 0
35806: PUSH
35807: EMPTY
35808: LIST
35809: LIST
35810: PUSH
35811: LD_INT 1
35813: NEG
35814: PUSH
35815: LD_INT 1
35817: NEG
35818: PUSH
35819: EMPTY
35820: LIST
35821: LIST
35822: PUSH
35823: LD_INT 1
35825: NEG
35826: PUSH
35827: LD_INT 2
35829: NEG
35830: PUSH
35831: EMPTY
35832: LIST
35833: LIST
35834: PUSH
35835: LD_INT 1
35837: PUSH
35838: LD_INT 2
35840: PUSH
35841: EMPTY
35842: LIST
35843: LIST
35844: PUSH
35845: EMPTY
35846: LIST
35847: LIST
35848: LIST
35849: LIST
35850: LIST
35851: LIST
35852: LIST
35853: LIST
35854: LIST
35855: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35856: LD_ADDR_VAR 0 40
35860: PUSH
35861: LD_INT 0
35863: PUSH
35864: LD_INT 0
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: PUSH
35871: LD_INT 0
35873: PUSH
35874: LD_INT 1
35876: NEG
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 1
35884: PUSH
35885: LD_INT 0
35887: PUSH
35888: EMPTY
35889: LIST
35890: LIST
35891: PUSH
35892: LD_INT 1
35894: PUSH
35895: LD_INT 1
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: LD_INT 0
35904: PUSH
35905: LD_INT 1
35907: PUSH
35908: EMPTY
35909: LIST
35910: LIST
35911: PUSH
35912: LD_INT 1
35914: NEG
35915: PUSH
35916: LD_INT 0
35918: PUSH
35919: EMPTY
35920: LIST
35921: LIST
35922: PUSH
35923: LD_INT 1
35925: NEG
35926: PUSH
35927: LD_INT 1
35929: NEG
35930: PUSH
35931: EMPTY
35932: LIST
35933: LIST
35934: PUSH
35935: LD_INT 1
35937: PUSH
35938: LD_INT 1
35940: NEG
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: LD_INT 1
35948: NEG
35949: PUSH
35950: LD_INT 1
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: EMPTY
35958: LIST
35959: LIST
35960: LIST
35961: LIST
35962: LIST
35963: LIST
35964: LIST
35965: LIST
35966: LIST
35967: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35968: LD_ADDR_VAR 0 41
35972: PUSH
35973: LD_INT 0
35975: PUSH
35976: LD_INT 0
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: PUSH
35983: LD_INT 0
35985: PUSH
35986: LD_INT 1
35988: NEG
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: LD_INT 1
35996: PUSH
35997: LD_INT 0
35999: PUSH
36000: EMPTY
36001: LIST
36002: LIST
36003: PUSH
36004: LD_INT 1
36006: PUSH
36007: LD_INT 1
36009: PUSH
36010: EMPTY
36011: LIST
36012: LIST
36013: PUSH
36014: LD_INT 0
36016: PUSH
36017: LD_INT 1
36019: PUSH
36020: EMPTY
36021: LIST
36022: LIST
36023: PUSH
36024: LD_INT 1
36026: NEG
36027: PUSH
36028: LD_INT 0
36030: PUSH
36031: EMPTY
36032: LIST
36033: LIST
36034: PUSH
36035: LD_INT 1
36037: NEG
36038: PUSH
36039: LD_INT 1
36041: NEG
36042: PUSH
36043: EMPTY
36044: LIST
36045: LIST
36046: PUSH
36047: LD_INT 1
36049: NEG
36050: PUSH
36051: LD_INT 2
36053: NEG
36054: PUSH
36055: EMPTY
36056: LIST
36057: LIST
36058: PUSH
36059: LD_INT 1
36061: PUSH
36062: LD_INT 1
36064: NEG
36065: PUSH
36066: EMPTY
36067: LIST
36068: LIST
36069: PUSH
36070: LD_INT 2
36072: PUSH
36073: LD_INT 0
36075: PUSH
36076: EMPTY
36077: LIST
36078: LIST
36079: PUSH
36080: LD_INT 2
36082: PUSH
36083: LD_INT 1
36085: PUSH
36086: EMPTY
36087: LIST
36088: LIST
36089: PUSH
36090: LD_INT 2
36092: PUSH
36093: LD_INT 2
36095: PUSH
36096: EMPTY
36097: LIST
36098: LIST
36099: PUSH
36100: LD_INT 1
36102: PUSH
36103: LD_INT 2
36105: PUSH
36106: EMPTY
36107: LIST
36108: LIST
36109: PUSH
36110: LD_INT 1
36112: NEG
36113: PUSH
36114: LD_INT 1
36116: PUSH
36117: EMPTY
36118: LIST
36119: LIST
36120: PUSH
36121: LD_INT 2
36123: NEG
36124: PUSH
36125: LD_INT 0
36127: PUSH
36128: EMPTY
36129: LIST
36130: LIST
36131: PUSH
36132: LD_INT 2
36134: NEG
36135: PUSH
36136: LD_INT 1
36138: NEG
36139: PUSH
36140: EMPTY
36141: LIST
36142: LIST
36143: PUSH
36144: LD_INT 2
36146: NEG
36147: PUSH
36148: LD_INT 2
36150: NEG
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: PUSH
36156: LD_INT 2
36158: NEG
36159: PUSH
36160: LD_INT 3
36162: NEG
36163: PUSH
36164: EMPTY
36165: LIST
36166: LIST
36167: PUSH
36168: LD_INT 2
36170: PUSH
36171: LD_INT 1
36173: NEG
36174: PUSH
36175: EMPTY
36176: LIST
36177: LIST
36178: PUSH
36179: LD_INT 3
36181: PUSH
36182: LD_INT 0
36184: PUSH
36185: EMPTY
36186: LIST
36187: LIST
36188: PUSH
36189: LD_INT 3
36191: PUSH
36192: LD_INT 1
36194: PUSH
36195: EMPTY
36196: LIST
36197: LIST
36198: PUSH
36199: LD_INT 3
36201: PUSH
36202: LD_INT 2
36204: PUSH
36205: EMPTY
36206: LIST
36207: LIST
36208: PUSH
36209: LD_INT 3
36211: PUSH
36212: LD_INT 3
36214: PUSH
36215: EMPTY
36216: LIST
36217: LIST
36218: PUSH
36219: LD_INT 2
36221: PUSH
36222: LD_INT 3
36224: PUSH
36225: EMPTY
36226: LIST
36227: LIST
36228: PUSH
36229: LD_INT 2
36231: NEG
36232: PUSH
36233: LD_INT 1
36235: PUSH
36236: EMPTY
36237: LIST
36238: LIST
36239: PUSH
36240: LD_INT 3
36242: NEG
36243: PUSH
36244: LD_INT 0
36246: PUSH
36247: EMPTY
36248: LIST
36249: LIST
36250: PUSH
36251: LD_INT 3
36253: NEG
36254: PUSH
36255: LD_INT 1
36257: NEG
36258: PUSH
36259: EMPTY
36260: LIST
36261: LIST
36262: PUSH
36263: LD_INT 3
36265: NEG
36266: PUSH
36267: LD_INT 2
36269: NEG
36270: PUSH
36271: EMPTY
36272: LIST
36273: LIST
36274: PUSH
36275: LD_INT 3
36277: NEG
36278: PUSH
36279: LD_INT 3
36281: NEG
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: LIST
36291: LIST
36292: LIST
36293: LIST
36294: LIST
36295: LIST
36296: LIST
36297: LIST
36298: LIST
36299: LIST
36300: LIST
36301: LIST
36302: LIST
36303: LIST
36304: LIST
36305: LIST
36306: LIST
36307: LIST
36308: LIST
36309: LIST
36310: LIST
36311: LIST
36312: LIST
36313: LIST
36314: LIST
36315: LIST
36316: LIST
36317: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36318: LD_ADDR_VAR 0 42
36322: PUSH
36323: LD_INT 0
36325: PUSH
36326: LD_INT 0
36328: PUSH
36329: EMPTY
36330: LIST
36331: LIST
36332: PUSH
36333: LD_INT 0
36335: PUSH
36336: LD_INT 1
36338: NEG
36339: PUSH
36340: EMPTY
36341: LIST
36342: LIST
36343: PUSH
36344: LD_INT 1
36346: PUSH
36347: LD_INT 0
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: LD_INT 1
36356: PUSH
36357: LD_INT 1
36359: PUSH
36360: EMPTY
36361: LIST
36362: LIST
36363: PUSH
36364: LD_INT 0
36366: PUSH
36367: LD_INT 1
36369: PUSH
36370: EMPTY
36371: LIST
36372: LIST
36373: PUSH
36374: LD_INT 1
36376: NEG
36377: PUSH
36378: LD_INT 0
36380: PUSH
36381: EMPTY
36382: LIST
36383: LIST
36384: PUSH
36385: LD_INT 1
36387: NEG
36388: PUSH
36389: LD_INT 1
36391: NEG
36392: PUSH
36393: EMPTY
36394: LIST
36395: LIST
36396: PUSH
36397: LD_INT 1
36399: NEG
36400: PUSH
36401: LD_INT 2
36403: NEG
36404: PUSH
36405: EMPTY
36406: LIST
36407: LIST
36408: PUSH
36409: LD_INT 0
36411: PUSH
36412: LD_INT 2
36414: NEG
36415: PUSH
36416: EMPTY
36417: LIST
36418: LIST
36419: PUSH
36420: LD_INT 1
36422: PUSH
36423: LD_INT 1
36425: NEG
36426: PUSH
36427: EMPTY
36428: LIST
36429: LIST
36430: PUSH
36431: LD_INT 2
36433: PUSH
36434: LD_INT 1
36436: PUSH
36437: EMPTY
36438: LIST
36439: LIST
36440: PUSH
36441: LD_INT 2
36443: PUSH
36444: LD_INT 2
36446: PUSH
36447: EMPTY
36448: LIST
36449: LIST
36450: PUSH
36451: LD_INT 1
36453: PUSH
36454: LD_INT 2
36456: PUSH
36457: EMPTY
36458: LIST
36459: LIST
36460: PUSH
36461: LD_INT 0
36463: PUSH
36464: LD_INT 2
36466: PUSH
36467: EMPTY
36468: LIST
36469: LIST
36470: PUSH
36471: LD_INT 1
36473: NEG
36474: PUSH
36475: LD_INT 1
36477: PUSH
36478: EMPTY
36479: LIST
36480: LIST
36481: PUSH
36482: LD_INT 2
36484: NEG
36485: PUSH
36486: LD_INT 1
36488: NEG
36489: PUSH
36490: EMPTY
36491: LIST
36492: LIST
36493: PUSH
36494: LD_INT 2
36496: NEG
36497: PUSH
36498: LD_INT 2
36500: NEG
36501: PUSH
36502: EMPTY
36503: LIST
36504: LIST
36505: PUSH
36506: LD_INT 2
36508: NEG
36509: PUSH
36510: LD_INT 3
36512: NEG
36513: PUSH
36514: EMPTY
36515: LIST
36516: LIST
36517: PUSH
36518: LD_INT 1
36520: NEG
36521: PUSH
36522: LD_INT 3
36524: NEG
36525: PUSH
36526: EMPTY
36527: LIST
36528: LIST
36529: PUSH
36530: LD_INT 0
36532: PUSH
36533: LD_INT 3
36535: NEG
36536: PUSH
36537: EMPTY
36538: LIST
36539: LIST
36540: PUSH
36541: LD_INT 1
36543: PUSH
36544: LD_INT 2
36546: NEG
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: LD_INT 3
36554: PUSH
36555: LD_INT 2
36557: PUSH
36558: EMPTY
36559: LIST
36560: LIST
36561: PUSH
36562: LD_INT 3
36564: PUSH
36565: LD_INT 3
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 2
36574: PUSH
36575: LD_INT 3
36577: PUSH
36578: EMPTY
36579: LIST
36580: LIST
36581: PUSH
36582: LD_INT 1
36584: PUSH
36585: LD_INT 3
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PUSH
36592: LD_INT 0
36594: PUSH
36595: LD_INT 3
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: PUSH
36602: LD_INT 1
36604: NEG
36605: PUSH
36606: LD_INT 2
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: PUSH
36613: LD_INT 3
36615: NEG
36616: PUSH
36617: LD_INT 2
36619: NEG
36620: PUSH
36621: EMPTY
36622: LIST
36623: LIST
36624: PUSH
36625: LD_INT 3
36627: NEG
36628: PUSH
36629: LD_INT 3
36631: NEG
36632: PUSH
36633: EMPTY
36634: LIST
36635: LIST
36636: PUSH
36637: EMPTY
36638: LIST
36639: LIST
36640: LIST
36641: LIST
36642: LIST
36643: LIST
36644: LIST
36645: LIST
36646: LIST
36647: LIST
36648: LIST
36649: LIST
36650: LIST
36651: LIST
36652: LIST
36653: LIST
36654: LIST
36655: LIST
36656: LIST
36657: LIST
36658: LIST
36659: LIST
36660: LIST
36661: LIST
36662: LIST
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36668: LD_ADDR_VAR 0 43
36672: PUSH
36673: LD_INT 0
36675: PUSH
36676: LD_INT 0
36678: PUSH
36679: EMPTY
36680: LIST
36681: LIST
36682: PUSH
36683: LD_INT 0
36685: PUSH
36686: LD_INT 1
36688: NEG
36689: PUSH
36690: EMPTY
36691: LIST
36692: LIST
36693: PUSH
36694: LD_INT 1
36696: PUSH
36697: LD_INT 0
36699: PUSH
36700: EMPTY
36701: LIST
36702: LIST
36703: PUSH
36704: LD_INT 1
36706: PUSH
36707: LD_INT 1
36709: PUSH
36710: EMPTY
36711: LIST
36712: LIST
36713: PUSH
36714: LD_INT 0
36716: PUSH
36717: LD_INT 1
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PUSH
36724: LD_INT 1
36726: NEG
36727: PUSH
36728: LD_INT 0
36730: PUSH
36731: EMPTY
36732: LIST
36733: LIST
36734: PUSH
36735: LD_INT 1
36737: NEG
36738: PUSH
36739: LD_INT 1
36741: NEG
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PUSH
36747: LD_INT 1
36749: NEG
36750: PUSH
36751: LD_INT 2
36753: NEG
36754: PUSH
36755: EMPTY
36756: LIST
36757: LIST
36758: PUSH
36759: LD_INT 0
36761: PUSH
36762: LD_INT 2
36764: NEG
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: PUSH
36770: LD_INT 1
36772: PUSH
36773: LD_INT 1
36775: NEG
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: PUSH
36781: LD_INT 2
36783: PUSH
36784: LD_INT 0
36786: PUSH
36787: EMPTY
36788: LIST
36789: LIST
36790: PUSH
36791: LD_INT 2
36793: PUSH
36794: LD_INT 1
36796: PUSH
36797: EMPTY
36798: LIST
36799: LIST
36800: PUSH
36801: LD_INT 1
36803: PUSH
36804: LD_INT 2
36806: PUSH
36807: EMPTY
36808: LIST
36809: LIST
36810: PUSH
36811: LD_INT 0
36813: PUSH
36814: LD_INT 2
36816: PUSH
36817: EMPTY
36818: LIST
36819: LIST
36820: PUSH
36821: LD_INT 1
36823: NEG
36824: PUSH
36825: LD_INT 1
36827: PUSH
36828: EMPTY
36829: LIST
36830: LIST
36831: PUSH
36832: LD_INT 2
36834: NEG
36835: PUSH
36836: LD_INT 0
36838: PUSH
36839: EMPTY
36840: LIST
36841: LIST
36842: PUSH
36843: LD_INT 2
36845: NEG
36846: PUSH
36847: LD_INT 1
36849: NEG
36850: PUSH
36851: EMPTY
36852: LIST
36853: LIST
36854: PUSH
36855: LD_INT 1
36857: NEG
36858: PUSH
36859: LD_INT 3
36861: NEG
36862: PUSH
36863: EMPTY
36864: LIST
36865: LIST
36866: PUSH
36867: LD_INT 0
36869: PUSH
36870: LD_INT 3
36872: NEG
36873: PUSH
36874: EMPTY
36875: LIST
36876: LIST
36877: PUSH
36878: LD_INT 1
36880: PUSH
36881: LD_INT 2
36883: NEG
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: PUSH
36889: LD_INT 2
36891: PUSH
36892: LD_INT 1
36894: NEG
36895: PUSH
36896: EMPTY
36897: LIST
36898: LIST
36899: PUSH
36900: LD_INT 3
36902: PUSH
36903: LD_INT 0
36905: PUSH
36906: EMPTY
36907: LIST
36908: LIST
36909: PUSH
36910: LD_INT 3
36912: PUSH
36913: LD_INT 1
36915: PUSH
36916: EMPTY
36917: LIST
36918: LIST
36919: PUSH
36920: LD_INT 1
36922: PUSH
36923: LD_INT 3
36925: PUSH
36926: EMPTY
36927: LIST
36928: LIST
36929: PUSH
36930: LD_INT 0
36932: PUSH
36933: LD_INT 3
36935: PUSH
36936: EMPTY
36937: LIST
36938: LIST
36939: PUSH
36940: LD_INT 1
36942: NEG
36943: PUSH
36944: LD_INT 2
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PUSH
36951: LD_INT 2
36953: NEG
36954: PUSH
36955: LD_INT 1
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: LD_INT 3
36964: NEG
36965: PUSH
36966: LD_INT 0
36968: PUSH
36969: EMPTY
36970: LIST
36971: LIST
36972: PUSH
36973: LD_INT 3
36975: NEG
36976: PUSH
36977: LD_INT 1
36979: NEG
36980: PUSH
36981: EMPTY
36982: LIST
36983: LIST
36984: PUSH
36985: EMPTY
36986: LIST
36987: LIST
36988: LIST
36989: LIST
36990: LIST
36991: LIST
36992: LIST
36993: LIST
36994: LIST
36995: LIST
36996: LIST
36997: LIST
36998: LIST
36999: LIST
37000: LIST
37001: LIST
37002: LIST
37003: LIST
37004: LIST
37005: LIST
37006: LIST
37007: LIST
37008: LIST
37009: LIST
37010: LIST
37011: LIST
37012: LIST
37013: LIST
37014: LIST
37015: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37016: LD_ADDR_VAR 0 44
37020: PUSH
37021: LD_INT 0
37023: PUSH
37024: LD_INT 0
37026: PUSH
37027: EMPTY
37028: LIST
37029: LIST
37030: PUSH
37031: LD_INT 0
37033: PUSH
37034: LD_INT 1
37036: NEG
37037: PUSH
37038: EMPTY
37039: LIST
37040: LIST
37041: PUSH
37042: LD_INT 1
37044: PUSH
37045: LD_INT 0
37047: PUSH
37048: EMPTY
37049: LIST
37050: LIST
37051: PUSH
37052: LD_INT 1
37054: PUSH
37055: LD_INT 1
37057: PUSH
37058: EMPTY
37059: LIST
37060: LIST
37061: PUSH
37062: LD_INT 0
37064: PUSH
37065: LD_INT 1
37067: PUSH
37068: EMPTY
37069: LIST
37070: LIST
37071: PUSH
37072: LD_INT 1
37074: NEG
37075: PUSH
37076: LD_INT 0
37078: PUSH
37079: EMPTY
37080: LIST
37081: LIST
37082: PUSH
37083: LD_INT 1
37085: NEG
37086: PUSH
37087: LD_INT 1
37089: NEG
37090: PUSH
37091: EMPTY
37092: LIST
37093: LIST
37094: PUSH
37095: LD_INT 1
37097: NEG
37098: PUSH
37099: LD_INT 2
37101: NEG
37102: PUSH
37103: EMPTY
37104: LIST
37105: LIST
37106: PUSH
37107: LD_INT 1
37109: PUSH
37110: LD_INT 1
37112: NEG
37113: PUSH
37114: EMPTY
37115: LIST
37116: LIST
37117: PUSH
37118: LD_INT 2
37120: PUSH
37121: LD_INT 0
37123: PUSH
37124: EMPTY
37125: LIST
37126: LIST
37127: PUSH
37128: LD_INT 2
37130: PUSH
37131: LD_INT 1
37133: PUSH
37134: EMPTY
37135: LIST
37136: LIST
37137: PUSH
37138: LD_INT 2
37140: PUSH
37141: LD_INT 2
37143: PUSH
37144: EMPTY
37145: LIST
37146: LIST
37147: PUSH
37148: LD_INT 1
37150: PUSH
37151: LD_INT 2
37153: PUSH
37154: EMPTY
37155: LIST
37156: LIST
37157: PUSH
37158: LD_INT 1
37160: NEG
37161: PUSH
37162: LD_INT 1
37164: PUSH
37165: EMPTY
37166: LIST
37167: LIST
37168: PUSH
37169: LD_INT 2
37171: NEG
37172: PUSH
37173: LD_INT 0
37175: PUSH
37176: EMPTY
37177: LIST
37178: LIST
37179: PUSH
37180: LD_INT 2
37182: NEG
37183: PUSH
37184: LD_INT 1
37186: NEG
37187: PUSH
37188: EMPTY
37189: LIST
37190: LIST
37191: PUSH
37192: LD_INT 2
37194: NEG
37195: PUSH
37196: LD_INT 2
37198: NEG
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: PUSH
37204: LD_INT 2
37206: NEG
37207: PUSH
37208: LD_INT 3
37210: NEG
37211: PUSH
37212: EMPTY
37213: LIST
37214: LIST
37215: PUSH
37216: LD_INT 2
37218: PUSH
37219: LD_INT 1
37221: NEG
37222: PUSH
37223: EMPTY
37224: LIST
37225: LIST
37226: PUSH
37227: LD_INT 3
37229: PUSH
37230: LD_INT 0
37232: PUSH
37233: EMPTY
37234: LIST
37235: LIST
37236: PUSH
37237: LD_INT 3
37239: PUSH
37240: LD_INT 1
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: PUSH
37247: LD_INT 3
37249: PUSH
37250: LD_INT 2
37252: PUSH
37253: EMPTY
37254: LIST
37255: LIST
37256: PUSH
37257: LD_INT 3
37259: PUSH
37260: LD_INT 3
37262: PUSH
37263: EMPTY
37264: LIST
37265: LIST
37266: PUSH
37267: LD_INT 2
37269: PUSH
37270: LD_INT 3
37272: PUSH
37273: EMPTY
37274: LIST
37275: LIST
37276: PUSH
37277: LD_INT 2
37279: NEG
37280: PUSH
37281: LD_INT 1
37283: PUSH
37284: EMPTY
37285: LIST
37286: LIST
37287: PUSH
37288: LD_INT 3
37290: NEG
37291: PUSH
37292: LD_INT 0
37294: PUSH
37295: EMPTY
37296: LIST
37297: LIST
37298: PUSH
37299: LD_INT 3
37301: NEG
37302: PUSH
37303: LD_INT 1
37305: NEG
37306: PUSH
37307: EMPTY
37308: LIST
37309: LIST
37310: PUSH
37311: LD_INT 3
37313: NEG
37314: PUSH
37315: LD_INT 2
37317: NEG
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: PUSH
37323: LD_INT 3
37325: NEG
37326: PUSH
37327: LD_INT 3
37329: NEG
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PUSH
37335: EMPTY
37336: LIST
37337: LIST
37338: LIST
37339: LIST
37340: LIST
37341: LIST
37342: LIST
37343: LIST
37344: LIST
37345: LIST
37346: LIST
37347: LIST
37348: LIST
37349: LIST
37350: LIST
37351: LIST
37352: LIST
37353: LIST
37354: LIST
37355: LIST
37356: LIST
37357: LIST
37358: LIST
37359: LIST
37360: LIST
37361: LIST
37362: LIST
37363: LIST
37364: LIST
37365: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37366: LD_ADDR_VAR 0 45
37370: PUSH
37371: LD_INT 0
37373: PUSH
37374: LD_INT 0
37376: PUSH
37377: EMPTY
37378: LIST
37379: LIST
37380: PUSH
37381: LD_INT 0
37383: PUSH
37384: LD_INT 1
37386: NEG
37387: PUSH
37388: EMPTY
37389: LIST
37390: LIST
37391: PUSH
37392: LD_INT 1
37394: PUSH
37395: LD_INT 0
37397: PUSH
37398: EMPTY
37399: LIST
37400: LIST
37401: PUSH
37402: LD_INT 1
37404: PUSH
37405: LD_INT 1
37407: PUSH
37408: EMPTY
37409: LIST
37410: LIST
37411: PUSH
37412: LD_INT 0
37414: PUSH
37415: LD_INT 1
37417: PUSH
37418: EMPTY
37419: LIST
37420: LIST
37421: PUSH
37422: LD_INT 1
37424: NEG
37425: PUSH
37426: LD_INT 0
37428: PUSH
37429: EMPTY
37430: LIST
37431: LIST
37432: PUSH
37433: LD_INT 1
37435: NEG
37436: PUSH
37437: LD_INT 1
37439: NEG
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: PUSH
37445: LD_INT 1
37447: NEG
37448: PUSH
37449: LD_INT 2
37451: NEG
37452: PUSH
37453: EMPTY
37454: LIST
37455: LIST
37456: PUSH
37457: LD_INT 0
37459: PUSH
37460: LD_INT 2
37462: NEG
37463: PUSH
37464: EMPTY
37465: LIST
37466: LIST
37467: PUSH
37468: LD_INT 1
37470: PUSH
37471: LD_INT 1
37473: NEG
37474: PUSH
37475: EMPTY
37476: LIST
37477: LIST
37478: PUSH
37479: LD_INT 2
37481: PUSH
37482: LD_INT 1
37484: PUSH
37485: EMPTY
37486: LIST
37487: LIST
37488: PUSH
37489: LD_INT 2
37491: PUSH
37492: LD_INT 2
37494: PUSH
37495: EMPTY
37496: LIST
37497: LIST
37498: PUSH
37499: LD_INT 1
37501: PUSH
37502: LD_INT 2
37504: PUSH
37505: EMPTY
37506: LIST
37507: LIST
37508: PUSH
37509: LD_INT 0
37511: PUSH
37512: LD_INT 2
37514: PUSH
37515: EMPTY
37516: LIST
37517: LIST
37518: PUSH
37519: LD_INT 1
37521: NEG
37522: PUSH
37523: LD_INT 1
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: LD_INT 2
37532: NEG
37533: PUSH
37534: LD_INT 1
37536: NEG
37537: PUSH
37538: EMPTY
37539: LIST
37540: LIST
37541: PUSH
37542: LD_INT 2
37544: NEG
37545: PUSH
37546: LD_INT 2
37548: NEG
37549: PUSH
37550: EMPTY
37551: LIST
37552: LIST
37553: PUSH
37554: LD_INT 2
37556: NEG
37557: PUSH
37558: LD_INT 3
37560: NEG
37561: PUSH
37562: EMPTY
37563: LIST
37564: LIST
37565: PUSH
37566: LD_INT 1
37568: NEG
37569: PUSH
37570: LD_INT 3
37572: NEG
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: LD_INT 0
37580: PUSH
37581: LD_INT 3
37583: NEG
37584: PUSH
37585: EMPTY
37586: LIST
37587: LIST
37588: PUSH
37589: LD_INT 1
37591: PUSH
37592: LD_INT 2
37594: NEG
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: PUSH
37600: LD_INT 3
37602: PUSH
37603: LD_INT 2
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 3
37612: PUSH
37613: LD_INT 3
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: PUSH
37620: LD_INT 2
37622: PUSH
37623: LD_INT 3
37625: PUSH
37626: EMPTY
37627: LIST
37628: LIST
37629: PUSH
37630: LD_INT 1
37632: PUSH
37633: LD_INT 3
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PUSH
37640: LD_INT 0
37642: PUSH
37643: LD_INT 3
37645: PUSH
37646: EMPTY
37647: LIST
37648: LIST
37649: PUSH
37650: LD_INT 1
37652: NEG
37653: PUSH
37654: LD_INT 2
37656: PUSH
37657: EMPTY
37658: LIST
37659: LIST
37660: PUSH
37661: LD_INT 3
37663: NEG
37664: PUSH
37665: LD_INT 2
37667: NEG
37668: PUSH
37669: EMPTY
37670: LIST
37671: LIST
37672: PUSH
37673: LD_INT 3
37675: NEG
37676: PUSH
37677: LD_INT 3
37679: NEG
37680: PUSH
37681: EMPTY
37682: LIST
37683: LIST
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: LIST
37689: LIST
37690: LIST
37691: LIST
37692: LIST
37693: LIST
37694: LIST
37695: LIST
37696: LIST
37697: LIST
37698: LIST
37699: LIST
37700: LIST
37701: LIST
37702: LIST
37703: LIST
37704: LIST
37705: LIST
37706: LIST
37707: LIST
37708: LIST
37709: LIST
37710: LIST
37711: LIST
37712: LIST
37713: LIST
37714: LIST
37715: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37716: LD_ADDR_VAR 0 46
37720: PUSH
37721: LD_INT 0
37723: PUSH
37724: LD_INT 0
37726: PUSH
37727: EMPTY
37728: LIST
37729: LIST
37730: PUSH
37731: LD_INT 0
37733: PUSH
37734: LD_INT 1
37736: NEG
37737: PUSH
37738: EMPTY
37739: LIST
37740: LIST
37741: PUSH
37742: LD_INT 1
37744: PUSH
37745: LD_INT 0
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PUSH
37752: LD_INT 1
37754: PUSH
37755: LD_INT 1
37757: PUSH
37758: EMPTY
37759: LIST
37760: LIST
37761: PUSH
37762: LD_INT 0
37764: PUSH
37765: LD_INT 1
37767: PUSH
37768: EMPTY
37769: LIST
37770: LIST
37771: PUSH
37772: LD_INT 1
37774: NEG
37775: PUSH
37776: LD_INT 0
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: PUSH
37783: LD_INT 1
37785: NEG
37786: PUSH
37787: LD_INT 1
37789: NEG
37790: PUSH
37791: EMPTY
37792: LIST
37793: LIST
37794: PUSH
37795: LD_INT 1
37797: NEG
37798: PUSH
37799: LD_INT 2
37801: NEG
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: LD_INT 0
37809: PUSH
37810: LD_INT 2
37812: NEG
37813: PUSH
37814: EMPTY
37815: LIST
37816: LIST
37817: PUSH
37818: LD_INT 1
37820: PUSH
37821: LD_INT 1
37823: NEG
37824: PUSH
37825: EMPTY
37826: LIST
37827: LIST
37828: PUSH
37829: LD_INT 2
37831: PUSH
37832: LD_INT 0
37834: PUSH
37835: EMPTY
37836: LIST
37837: LIST
37838: PUSH
37839: LD_INT 2
37841: PUSH
37842: LD_INT 1
37844: PUSH
37845: EMPTY
37846: LIST
37847: LIST
37848: PUSH
37849: LD_INT 1
37851: PUSH
37852: LD_INT 2
37854: PUSH
37855: EMPTY
37856: LIST
37857: LIST
37858: PUSH
37859: LD_INT 0
37861: PUSH
37862: LD_INT 2
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PUSH
37869: LD_INT 1
37871: NEG
37872: PUSH
37873: LD_INT 1
37875: PUSH
37876: EMPTY
37877: LIST
37878: LIST
37879: PUSH
37880: LD_INT 2
37882: NEG
37883: PUSH
37884: LD_INT 0
37886: PUSH
37887: EMPTY
37888: LIST
37889: LIST
37890: PUSH
37891: LD_INT 2
37893: NEG
37894: PUSH
37895: LD_INT 1
37897: NEG
37898: PUSH
37899: EMPTY
37900: LIST
37901: LIST
37902: PUSH
37903: LD_INT 1
37905: NEG
37906: PUSH
37907: LD_INT 3
37909: NEG
37910: PUSH
37911: EMPTY
37912: LIST
37913: LIST
37914: PUSH
37915: LD_INT 0
37917: PUSH
37918: LD_INT 3
37920: NEG
37921: PUSH
37922: EMPTY
37923: LIST
37924: LIST
37925: PUSH
37926: LD_INT 1
37928: PUSH
37929: LD_INT 2
37931: NEG
37932: PUSH
37933: EMPTY
37934: LIST
37935: LIST
37936: PUSH
37937: LD_INT 2
37939: PUSH
37940: LD_INT 1
37942: NEG
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 3
37950: PUSH
37951: LD_INT 0
37953: PUSH
37954: EMPTY
37955: LIST
37956: LIST
37957: PUSH
37958: LD_INT 3
37960: PUSH
37961: LD_INT 1
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: PUSH
37968: LD_INT 1
37970: PUSH
37971: LD_INT 3
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: LD_INT 0
37980: PUSH
37981: LD_INT 3
37983: PUSH
37984: EMPTY
37985: LIST
37986: LIST
37987: PUSH
37988: LD_INT 1
37990: NEG
37991: PUSH
37992: LD_INT 2
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: LD_INT 2
38001: NEG
38002: PUSH
38003: LD_INT 1
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 3
38012: NEG
38013: PUSH
38014: LD_INT 0
38016: PUSH
38017: EMPTY
38018: LIST
38019: LIST
38020: PUSH
38021: LD_INT 3
38023: NEG
38024: PUSH
38025: LD_INT 1
38027: NEG
38028: PUSH
38029: EMPTY
38030: LIST
38031: LIST
38032: PUSH
38033: EMPTY
38034: LIST
38035: LIST
38036: LIST
38037: LIST
38038: LIST
38039: LIST
38040: LIST
38041: LIST
38042: LIST
38043: LIST
38044: LIST
38045: LIST
38046: LIST
38047: LIST
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: LIST
38055: LIST
38056: LIST
38057: LIST
38058: LIST
38059: LIST
38060: LIST
38061: LIST
38062: LIST
38063: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38064: LD_ADDR_VAR 0 47
38068: PUSH
38069: LD_INT 0
38071: PUSH
38072: LD_INT 0
38074: PUSH
38075: EMPTY
38076: LIST
38077: LIST
38078: PUSH
38079: LD_INT 0
38081: PUSH
38082: LD_INT 1
38084: NEG
38085: PUSH
38086: EMPTY
38087: LIST
38088: LIST
38089: PUSH
38090: LD_INT 1
38092: PUSH
38093: LD_INT 0
38095: PUSH
38096: EMPTY
38097: LIST
38098: LIST
38099: PUSH
38100: LD_INT 1
38102: PUSH
38103: LD_INT 1
38105: PUSH
38106: EMPTY
38107: LIST
38108: LIST
38109: PUSH
38110: LD_INT 0
38112: PUSH
38113: LD_INT 1
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: PUSH
38120: LD_INT 1
38122: NEG
38123: PUSH
38124: LD_INT 0
38126: PUSH
38127: EMPTY
38128: LIST
38129: LIST
38130: PUSH
38131: LD_INT 1
38133: NEG
38134: PUSH
38135: LD_INT 1
38137: NEG
38138: PUSH
38139: EMPTY
38140: LIST
38141: LIST
38142: PUSH
38143: LD_INT 1
38145: NEG
38146: PUSH
38147: LD_INT 2
38149: NEG
38150: PUSH
38151: EMPTY
38152: LIST
38153: LIST
38154: PUSH
38155: LD_INT 0
38157: PUSH
38158: LD_INT 2
38160: NEG
38161: PUSH
38162: EMPTY
38163: LIST
38164: LIST
38165: PUSH
38166: LD_INT 1
38168: PUSH
38169: LD_INT 1
38171: NEG
38172: PUSH
38173: EMPTY
38174: LIST
38175: LIST
38176: PUSH
38177: LD_INT 2
38179: NEG
38180: PUSH
38181: LD_INT 1
38183: NEG
38184: PUSH
38185: EMPTY
38186: LIST
38187: LIST
38188: PUSH
38189: LD_INT 2
38191: NEG
38192: PUSH
38193: LD_INT 2
38195: NEG
38196: PUSH
38197: EMPTY
38198: LIST
38199: LIST
38200: PUSH
38201: EMPTY
38202: LIST
38203: LIST
38204: LIST
38205: LIST
38206: LIST
38207: LIST
38208: LIST
38209: LIST
38210: LIST
38211: LIST
38212: LIST
38213: LIST
38214: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38215: LD_ADDR_VAR 0 48
38219: PUSH
38220: LD_INT 0
38222: PUSH
38223: LD_INT 0
38225: PUSH
38226: EMPTY
38227: LIST
38228: LIST
38229: PUSH
38230: LD_INT 0
38232: PUSH
38233: LD_INT 1
38235: NEG
38236: PUSH
38237: EMPTY
38238: LIST
38239: LIST
38240: PUSH
38241: LD_INT 1
38243: PUSH
38244: LD_INT 0
38246: PUSH
38247: EMPTY
38248: LIST
38249: LIST
38250: PUSH
38251: LD_INT 1
38253: PUSH
38254: LD_INT 1
38256: PUSH
38257: EMPTY
38258: LIST
38259: LIST
38260: PUSH
38261: LD_INT 0
38263: PUSH
38264: LD_INT 1
38266: PUSH
38267: EMPTY
38268: LIST
38269: LIST
38270: PUSH
38271: LD_INT 1
38273: NEG
38274: PUSH
38275: LD_INT 0
38277: PUSH
38278: EMPTY
38279: LIST
38280: LIST
38281: PUSH
38282: LD_INT 1
38284: NEG
38285: PUSH
38286: LD_INT 1
38288: NEG
38289: PUSH
38290: EMPTY
38291: LIST
38292: LIST
38293: PUSH
38294: LD_INT 1
38296: NEG
38297: PUSH
38298: LD_INT 2
38300: NEG
38301: PUSH
38302: EMPTY
38303: LIST
38304: LIST
38305: PUSH
38306: LD_INT 0
38308: PUSH
38309: LD_INT 2
38311: NEG
38312: PUSH
38313: EMPTY
38314: LIST
38315: LIST
38316: PUSH
38317: LD_INT 1
38319: PUSH
38320: LD_INT 1
38322: NEG
38323: PUSH
38324: EMPTY
38325: LIST
38326: LIST
38327: PUSH
38328: LD_INT 2
38330: PUSH
38331: LD_INT 0
38333: PUSH
38334: EMPTY
38335: LIST
38336: LIST
38337: PUSH
38338: LD_INT 2
38340: PUSH
38341: LD_INT 1
38343: PUSH
38344: EMPTY
38345: LIST
38346: LIST
38347: PUSH
38348: EMPTY
38349: LIST
38350: LIST
38351: LIST
38352: LIST
38353: LIST
38354: LIST
38355: LIST
38356: LIST
38357: LIST
38358: LIST
38359: LIST
38360: LIST
38361: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38362: LD_ADDR_VAR 0 49
38366: PUSH
38367: LD_INT 0
38369: PUSH
38370: LD_INT 0
38372: PUSH
38373: EMPTY
38374: LIST
38375: LIST
38376: PUSH
38377: LD_INT 0
38379: PUSH
38380: LD_INT 1
38382: NEG
38383: PUSH
38384: EMPTY
38385: LIST
38386: LIST
38387: PUSH
38388: LD_INT 1
38390: PUSH
38391: LD_INT 0
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: LD_INT 1
38400: PUSH
38401: LD_INT 1
38403: PUSH
38404: EMPTY
38405: LIST
38406: LIST
38407: PUSH
38408: LD_INT 0
38410: PUSH
38411: LD_INT 1
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 1
38420: NEG
38421: PUSH
38422: LD_INT 0
38424: PUSH
38425: EMPTY
38426: LIST
38427: LIST
38428: PUSH
38429: LD_INT 1
38431: NEG
38432: PUSH
38433: LD_INT 1
38435: NEG
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: LD_INT 1
38443: PUSH
38444: LD_INT 1
38446: NEG
38447: PUSH
38448: EMPTY
38449: LIST
38450: LIST
38451: PUSH
38452: LD_INT 2
38454: PUSH
38455: LD_INT 0
38457: PUSH
38458: EMPTY
38459: LIST
38460: LIST
38461: PUSH
38462: LD_INT 2
38464: PUSH
38465: LD_INT 1
38467: PUSH
38468: EMPTY
38469: LIST
38470: LIST
38471: PUSH
38472: LD_INT 2
38474: PUSH
38475: LD_INT 2
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: LD_INT 1
38484: PUSH
38485: LD_INT 2
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: EMPTY
38493: LIST
38494: LIST
38495: LIST
38496: LIST
38497: LIST
38498: LIST
38499: LIST
38500: LIST
38501: LIST
38502: LIST
38503: LIST
38504: LIST
38505: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38506: LD_ADDR_VAR 0 50
38510: PUSH
38511: LD_INT 0
38513: PUSH
38514: LD_INT 0
38516: PUSH
38517: EMPTY
38518: LIST
38519: LIST
38520: PUSH
38521: LD_INT 0
38523: PUSH
38524: LD_INT 1
38526: NEG
38527: PUSH
38528: EMPTY
38529: LIST
38530: LIST
38531: PUSH
38532: LD_INT 1
38534: PUSH
38535: LD_INT 0
38537: PUSH
38538: EMPTY
38539: LIST
38540: LIST
38541: PUSH
38542: LD_INT 1
38544: PUSH
38545: LD_INT 1
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PUSH
38552: LD_INT 0
38554: PUSH
38555: LD_INT 1
38557: PUSH
38558: EMPTY
38559: LIST
38560: LIST
38561: PUSH
38562: LD_INT 1
38564: NEG
38565: PUSH
38566: LD_INT 0
38568: PUSH
38569: EMPTY
38570: LIST
38571: LIST
38572: PUSH
38573: LD_INT 1
38575: NEG
38576: PUSH
38577: LD_INT 1
38579: NEG
38580: PUSH
38581: EMPTY
38582: LIST
38583: LIST
38584: PUSH
38585: LD_INT 2
38587: PUSH
38588: LD_INT 1
38590: PUSH
38591: EMPTY
38592: LIST
38593: LIST
38594: PUSH
38595: LD_INT 2
38597: PUSH
38598: LD_INT 2
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 1
38607: PUSH
38608: LD_INT 2
38610: PUSH
38611: EMPTY
38612: LIST
38613: LIST
38614: PUSH
38615: LD_INT 0
38617: PUSH
38618: LD_INT 2
38620: PUSH
38621: EMPTY
38622: LIST
38623: LIST
38624: PUSH
38625: LD_INT 1
38627: NEG
38628: PUSH
38629: LD_INT 1
38631: PUSH
38632: EMPTY
38633: LIST
38634: LIST
38635: PUSH
38636: EMPTY
38637: LIST
38638: LIST
38639: LIST
38640: LIST
38641: LIST
38642: LIST
38643: LIST
38644: LIST
38645: LIST
38646: LIST
38647: LIST
38648: LIST
38649: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38650: LD_ADDR_VAR 0 51
38654: PUSH
38655: LD_INT 0
38657: PUSH
38658: LD_INT 0
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: PUSH
38665: LD_INT 0
38667: PUSH
38668: LD_INT 1
38670: NEG
38671: PUSH
38672: EMPTY
38673: LIST
38674: LIST
38675: PUSH
38676: LD_INT 1
38678: PUSH
38679: LD_INT 0
38681: PUSH
38682: EMPTY
38683: LIST
38684: LIST
38685: PUSH
38686: LD_INT 1
38688: PUSH
38689: LD_INT 1
38691: PUSH
38692: EMPTY
38693: LIST
38694: LIST
38695: PUSH
38696: LD_INT 0
38698: PUSH
38699: LD_INT 1
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: LD_INT 1
38708: NEG
38709: PUSH
38710: LD_INT 0
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: PUSH
38717: LD_INT 1
38719: NEG
38720: PUSH
38721: LD_INT 1
38723: NEG
38724: PUSH
38725: EMPTY
38726: LIST
38727: LIST
38728: PUSH
38729: LD_INT 1
38731: PUSH
38732: LD_INT 2
38734: PUSH
38735: EMPTY
38736: LIST
38737: LIST
38738: PUSH
38739: LD_INT 0
38741: PUSH
38742: LD_INT 2
38744: PUSH
38745: EMPTY
38746: LIST
38747: LIST
38748: PUSH
38749: LD_INT 1
38751: NEG
38752: PUSH
38753: LD_INT 1
38755: PUSH
38756: EMPTY
38757: LIST
38758: LIST
38759: PUSH
38760: LD_INT 2
38762: NEG
38763: PUSH
38764: LD_INT 0
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: LD_INT 2
38773: NEG
38774: PUSH
38775: LD_INT 1
38777: NEG
38778: PUSH
38779: EMPTY
38780: LIST
38781: LIST
38782: PUSH
38783: EMPTY
38784: LIST
38785: LIST
38786: LIST
38787: LIST
38788: LIST
38789: LIST
38790: LIST
38791: LIST
38792: LIST
38793: LIST
38794: LIST
38795: LIST
38796: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38797: LD_ADDR_VAR 0 52
38801: PUSH
38802: LD_INT 0
38804: PUSH
38805: LD_INT 0
38807: PUSH
38808: EMPTY
38809: LIST
38810: LIST
38811: PUSH
38812: LD_INT 0
38814: PUSH
38815: LD_INT 1
38817: NEG
38818: PUSH
38819: EMPTY
38820: LIST
38821: LIST
38822: PUSH
38823: LD_INT 1
38825: PUSH
38826: LD_INT 0
38828: PUSH
38829: EMPTY
38830: LIST
38831: LIST
38832: PUSH
38833: LD_INT 1
38835: PUSH
38836: LD_INT 1
38838: PUSH
38839: EMPTY
38840: LIST
38841: LIST
38842: PUSH
38843: LD_INT 0
38845: PUSH
38846: LD_INT 1
38848: PUSH
38849: EMPTY
38850: LIST
38851: LIST
38852: PUSH
38853: LD_INT 1
38855: NEG
38856: PUSH
38857: LD_INT 0
38859: PUSH
38860: EMPTY
38861: LIST
38862: LIST
38863: PUSH
38864: LD_INT 1
38866: NEG
38867: PUSH
38868: LD_INT 1
38870: NEG
38871: PUSH
38872: EMPTY
38873: LIST
38874: LIST
38875: PUSH
38876: LD_INT 1
38878: NEG
38879: PUSH
38880: LD_INT 2
38882: NEG
38883: PUSH
38884: EMPTY
38885: LIST
38886: LIST
38887: PUSH
38888: LD_INT 1
38890: NEG
38891: PUSH
38892: LD_INT 1
38894: PUSH
38895: EMPTY
38896: LIST
38897: LIST
38898: PUSH
38899: LD_INT 2
38901: NEG
38902: PUSH
38903: LD_INT 0
38905: PUSH
38906: EMPTY
38907: LIST
38908: LIST
38909: PUSH
38910: LD_INT 2
38912: NEG
38913: PUSH
38914: LD_INT 1
38916: NEG
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 2
38924: NEG
38925: PUSH
38926: LD_INT 2
38928: NEG
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: PUSH
38934: EMPTY
38935: LIST
38936: LIST
38937: LIST
38938: LIST
38939: LIST
38940: LIST
38941: LIST
38942: LIST
38943: LIST
38944: LIST
38945: LIST
38946: LIST
38947: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38948: LD_ADDR_VAR 0 53
38952: PUSH
38953: LD_INT 0
38955: PUSH
38956: LD_INT 0
38958: PUSH
38959: EMPTY
38960: LIST
38961: LIST
38962: PUSH
38963: LD_INT 0
38965: PUSH
38966: LD_INT 1
38968: NEG
38969: PUSH
38970: EMPTY
38971: LIST
38972: LIST
38973: PUSH
38974: LD_INT 1
38976: PUSH
38977: LD_INT 0
38979: PUSH
38980: EMPTY
38981: LIST
38982: LIST
38983: PUSH
38984: LD_INT 1
38986: PUSH
38987: LD_INT 1
38989: PUSH
38990: EMPTY
38991: LIST
38992: LIST
38993: PUSH
38994: LD_INT 0
38996: PUSH
38997: LD_INT 1
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: PUSH
39004: LD_INT 1
39006: NEG
39007: PUSH
39008: LD_INT 0
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 1
39017: NEG
39018: PUSH
39019: LD_INT 1
39021: NEG
39022: PUSH
39023: EMPTY
39024: LIST
39025: LIST
39026: PUSH
39027: LD_INT 1
39029: NEG
39030: PUSH
39031: LD_INT 2
39033: NEG
39034: PUSH
39035: EMPTY
39036: LIST
39037: LIST
39038: PUSH
39039: LD_INT 0
39041: PUSH
39042: LD_INT 2
39044: NEG
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 1
39052: PUSH
39053: LD_INT 1
39055: NEG
39056: PUSH
39057: EMPTY
39058: LIST
39059: LIST
39060: PUSH
39061: LD_INT 2
39063: PUSH
39064: LD_INT 0
39066: PUSH
39067: EMPTY
39068: LIST
39069: LIST
39070: PUSH
39071: LD_INT 2
39073: PUSH
39074: LD_INT 1
39076: PUSH
39077: EMPTY
39078: LIST
39079: LIST
39080: PUSH
39081: LD_INT 2
39083: PUSH
39084: LD_INT 2
39086: PUSH
39087: EMPTY
39088: LIST
39089: LIST
39090: PUSH
39091: LD_INT 1
39093: PUSH
39094: LD_INT 2
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: LD_INT 0
39103: PUSH
39104: LD_INT 2
39106: PUSH
39107: EMPTY
39108: LIST
39109: LIST
39110: PUSH
39111: LD_INT 1
39113: NEG
39114: PUSH
39115: LD_INT 1
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 2
39124: NEG
39125: PUSH
39126: LD_INT 0
39128: PUSH
39129: EMPTY
39130: LIST
39131: LIST
39132: PUSH
39133: LD_INT 2
39135: NEG
39136: PUSH
39137: LD_INT 1
39139: NEG
39140: PUSH
39141: EMPTY
39142: LIST
39143: LIST
39144: PUSH
39145: LD_INT 2
39147: NEG
39148: PUSH
39149: LD_INT 2
39151: NEG
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: PUSH
39157: EMPTY
39158: LIST
39159: LIST
39160: LIST
39161: LIST
39162: LIST
39163: LIST
39164: LIST
39165: LIST
39166: LIST
39167: LIST
39168: LIST
39169: LIST
39170: LIST
39171: LIST
39172: LIST
39173: LIST
39174: LIST
39175: LIST
39176: LIST
39177: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39178: LD_ADDR_VAR 0 54
39182: PUSH
39183: LD_INT 0
39185: PUSH
39186: LD_INT 0
39188: PUSH
39189: EMPTY
39190: LIST
39191: LIST
39192: PUSH
39193: LD_INT 0
39195: PUSH
39196: LD_INT 1
39198: NEG
39199: PUSH
39200: EMPTY
39201: LIST
39202: LIST
39203: PUSH
39204: LD_INT 1
39206: PUSH
39207: LD_INT 0
39209: PUSH
39210: EMPTY
39211: LIST
39212: LIST
39213: PUSH
39214: LD_INT 1
39216: PUSH
39217: LD_INT 1
39219: PUSH
39220: EMPTY
39221: LIST
39222: LIST
39223: PUSH
39224: LD_INT 0
39226: PUSH
39227: LD_INT 1
39229: PUSH
39230: EMPTY
39231: LIST
39232: LIST
39233: PUSH
39234: LD_INT 1
39236: NEG
39237: PUSH
39238: LD_INT 0
39240: PUSH
39241: EMPTY
39242: LIST
39243: LIST
39244: PUSH
39245: LD_INT 1
39247: NEG
39248: PUSH
39249: LD_INT 1
39251: NEG
39252: PUSH
39253: EMPTY
39254: LIST
39255: LIST
39256: PUSH
39257: LD_INT 1
39259: NEG
39260: PUSH
39261: LD_INT 2
39263: NEG
39264: PUSH
39265: EMPTY
39266: LIST
39267: LIST
39268: PUSH
39269: LD_INT 0
39271: PUSH
39272: LD_INT 2
39274: NEG
39275: PUSH
39276: EMPTY
39277: LIST
39278: LIST
39279: PUSH
39280: LD_INT 1
39282: PUSH
39283: LD_INT 1
39285: NEG
39286: PUSH
39287: EMPTY
39288: LIST
39289: LIST
39290: PUSH
39291: LD_INT 2
39293: PUSH
39294: LD_INT 0
39296: PUSH
39297: EMPTY
39298: LIST
39299: LIST
39300: PUSH
39301: LD_INT 2
39303: PUSH
39304: LD_INT 1
39306: PUSH
39307: EMPTY
39308: LIST
39309: LIST
39310: PUSH
39311: LD_INT 2
39313: PUSH
39314: LD_INT 2
39316: PUSH
39317: EMPTY
39318: LIST
39319: LIST
39320: PUSH
39321: LD_INT 1
39323: PUSH
39324: LD_INT 2
39326: PUSH
39327: EMPTY
39328: LIST
39329: LIST
39330: PUSH
39331: LD_INT 0
39333: PUSH
39334: LD_INT 2
39336: PUSH
39337: EMPTY
39338: LIST
39339: LIST
39340: PUSH
39341: LD_INT 1
39343: NEG
39344: PUSH
39345: LD_INT 1
39347: PUSH
39348: EMPTY
39349: LIST
39350: LIST
39351: PUSH
39352: LD_INT 2
39354: NEG
39355: PUSH
39356: LD_INT 0
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: PUSH
39363: LD_INT 2
39365: NEG
39366: PUSH
39367: LD_INT 1
39369: NEG
39370: PUSH
39371: EMPTY
39372: LIST
39373: LIST
39374: PUSH
39375: LD_INT 2
39377: NEG
39378: PUSH
39379: LD_INT 2
39381: NEG
39382: PUSH
39383: EMPTY
39384: LIST
39385: LIST
39386: PUSH
39387: EMPTY
39388: LIST
39389: LIST
39390: LIST
39391: LIST
39392: LIST
39393: LIST
39394: LIST
39395: LIST
39396: LIST
39397: LIST
39398: LIST
39399: LIST
39400: LIST
39401: LIST
39402: LIST
39403: LIST
39404: LIST
39405: LIST
39406: LIST
39407: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39408: LD_ADDR_VAR 0 55
39412: PUSH
39413: LD_INT 0
39415: PUSH
39416: LD_INT 0
39418: PUSH
39419: EMPTY
39420: LIST
39421: LIST
39422: PUSH
39423: LD_INT 0
39425: PUSH
39426: LD_INT 1
39428: NEG
39429: PUSH
39430: EMPTY
39431: LIST
39432: LIST
39433: PUSH
39434: LD_INT 1
39436: PUSH
39437: LD_INT 0
39439: PUSH
39440: EMPTY
39441: LIST
39442: LIST
39443: PUSH
39444: LD_INT 1
39446: PUSH
39447: LD_INT 1
39449: PUSH
39450: EMPTY
39451: LIST
39452: LIST
39453: PUSH
39454: LD_INT 0
39456: PUSH
39457: LD_INT 1
39459: PUSH
39460: EMPTY
39461: LIST
39462: LIST
39463: PUSH
39464: LD_INT 1
39466: NEG
39467: PUSH
39468: LD_INT 0
39470: PUSH
39471: EMPTY
39472: LIST
39473: LIST
39474: PUSH
39475: LD_INT 1
39477: NEG
39478: PUSH
39479: LD_INT 1
39481: NEG
39482: PUSH
39483: EMPTY
39484: LIST
39485: LIST
39486: PUSH
39487: LD_INT 1
39489: NEG
39490: PUSH
39491: LD_INT 2
39493: NEG
39494: PUSH
39495: EMPTY
39496: LIST
39497: LIST
39498: PUSH
39499: LD_INT 0
39501: PUSH
39502: LD_INT 2
39504: NEG
39505: PUSH
39506: EMPTY
39507: LIST
39508: LIST
39509: PUSH
39510: LD_INT 1
39512: PUSH
39513: LD_INT 1
39515: NEG
39516: PUSH
39517: EMPTY
39518: LIST
39519: LIST
39520: PUSH
39521: LD_INT 2
39523: PUSH
39524: LD_INT 0
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 2
39533: PUSH
39534: LD_INT 1
39536: PUSH
39537: EMPTY
39538: LIST
39539: LIST
39540: PUSH
39541: LD_INT 2
39543: PUSH
39544: LD_INT 2
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: LD_INT 1
39553: PUSH
39554: LD_INT 2
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 0
39563: PUSH
39564: LD_INT 2
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: PUSH
39571: LD_INT 1
39573: NEG
39574: PUSH
39575: LD_INT 1
39577: PUSH
39578: EMPTY
39579: LIST
39580: LIST
39581: PUSH
39582: LD_INT 2
39584: NEG
39585: PUSH
39586: LD_INT 0
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: PUSH
39593: LD_INT 2
39595: NEG
39596: PUSH
39597: LD_INT 1
39599: NEG
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PUSH
39605: LD_INT 2
39607: NEG
39608: PUSH
39609: LD_INT 2
39611: NEG
39612: PUSH
39613: EMPTY
39614: LIST
39615: LIST
39616: PUSH
39617: EMPTY
39618: LIST
39619: LIST
39620: LIST
39621: LIST
39622: LIST
39623: LIST
39624: LIST
39625: LIST
39626: LIST
39627: LIST
39628: LIST
39629: LIST
39630: LIST
39631: LIST
39632: LIST
39633: LIST
39634: LIST
39635: LIST
39636: LIST
39637: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39638: LD_ADDR_VAR 0 56
39642: PUSH
39643: LD_INT 0
39645: PUSH
39646: LD_INT 0
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 0
39655: PUSH
39656: LD_INT 1
39658: NEG
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: PUSH
39664: LD_INT 1
39666: PUSH
39667: LD_INT 0
39669: PUSH
39670: EMPTY
39671: LIST
39672: LIST
39673: PUSH
39674: LD_INT 1
39676: PUSH
39677: LD_INT 1
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: PUSH
39684: LD_INT 0
39686: PUSH
39687: LD_INT 1
39689: PUSH
39690: EMPTY
39691: LIST
39692: LIST
39693: PUSH
39694: LD_INT 1
39696: NEG
39697: PUSH
39698: LD_INT 0
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: PUSH
39705: LD_INT 1
39707: NEG
39708: PUSH
39709: LD_INT 1
39711: NEG
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PUSH
39717: LD_INT 1
39719: NEG
39720: PUSH
39721: LD_INT 2
39723: NEG
39724: PUSH
39725: EMPTY
39726: LIST
39727: LIST
39728: PUSH
39729: LD_INT 0
39731: PUSH
39732: LD_INT 2
39734: NEG
39735: PUSH
39736: EMPTY
39737: LIST
39738: LIST
39739: PUSH
39740: LD_INT 1
39742: PUSH
39743: LD_INT 1
39745: NEG
39746: PUSH
39747: EMPTY
39748: LIST
39749: LIST
39750: PUSH
39751: LD_INT 2
39753: PUSH
39754: LD_INT 0
39756: PUSH
39757: EMPTY
39758: LIST
39759: LIST
39760: PUSH
39761: LD_INT 2
39763: PUSH
39764: LD_INT 1
39766: PUSH
39767: EMPTY
39768: LIST
39769: LIST
39770: PUSH
39771: LD_INT 2
39773: PUSH
39774: LD_INT 2
39776: PUSH
39777: EMPTY
39778: LIST
39779: LIST
39780: PUSH
39781: LD_INT 1
39783: PUSH
39784: LD_INT 2
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 0
39793: PUSH
39794: LD_INT 2
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: PUSH
39801: LD_INT 1
39803: NEG
39804: PUSH
39805: LD_INT 1
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 2
39814: NEG
39815: PUSH
39816: LD_INT 0
39818: PUSH
39819: EMPTY
39820: LIST
39821: LIST
39822: PUSH
39823: LD_INT 2
39825: NEG
39826: PUSH
39827: LD_INT 1
39829: NEG
39830: PUSH
39831: EMPTY
39832: LIST
39833: LIST
39834: PUSH
39835: LD_INT 2
39837: NEG
39838: PUSH
39839: LD_INT 2
39841: NEG
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: PUSH
39847: EMPTY
39848: LIST
39849: LIST
39850: LIST
39851: LIST
39852: LIST
39853: LIST
39854: LIST
39855: LIST
39856: LIST
39857: LIST
39858: LIST
39859: LIST
39860: LIST
39861: LIST
39862: LIST
39863: LIST
39864: LIST
39865: LIST
39866: LIST
39867: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39868: LD_ADDR_VAR 0 57
39872: PUSH
39873: LD_INT 0
39875: PUSH
39876: LD_INT 0
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: PUSH
39883: LD_INT 0
39885: PUSH
39886: LD_INT 1
39888: NEG
39889: PUSH
39890: EMPTY
39891: LIST
39892: LIST
39893: PUSH
39894: LD_INT 1
39896: PUSH
39897: LD_INT 0
39899: PUSH
39900: EMPTY
39901: LIST
39902: LIST
39903: PUSH
39904: LD_INT 1
39906: PUSH
39907: LD_INT 1
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: PUSH
39914: LD_INT 0
39916: PUSH
39917: LD_INT 1
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: PUSH
39924: LD_INT 1
39926: NEG
39927: PUSH
39928: LD_INT 0
39930: PUSH
39931: EMPTY
39932: LIST
39933: LIST
39934: PUSH
39935: LD_INT 1
39937: NEG
39938: PUSH
39939: LD_INT 1
39941: NEG
39942: PUSH
39943: EMPTY
39944: LIST
39945: LIST
39946: PUSH
39947: LD_INT 1
39949: NEG
39950: PUSH
39951: LD_INT 2
39953: NEG
39954: PUSH
39955: EMPTY
39956: LIST
39957: LIST
39958: PUSH
39959: LD_INT 0
39961: PUSH
39962: LD_INT 2
39964: NEG
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: PUSH
39970: LD_INT 1
39972: PUSH
39973: LD_INT 1
39975: NEG
39976: PUSH
39977: EMPTY
39978: LIST
39979: LIST
39980: PUSH
39981: LD_INT 2
39983: PUSH
39984: LD_INT 0
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: PUSH
39991: LD_INT 2
39993: PUSH
39994: LD_INT 1
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: PUSH
40001: LD_INT 2
40003: PUSH
40004: LD_INT 2
40006: PUSH
40007: EMPTY
40008: LIST
40009: LIST
40010: PUSH
40011: LD_INT 1
40013: PUSH
40014: LD_INT 2
40016: PUSH
40017: EMPTY
40018: LIST
40019: LIST
40020: PUSH
40021: LD_INT 0
40023: PUSH
40024: LD_INT 2
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PUSH
40031: LD_INT 1
40033: NEG
40034: PUSH
40035: LD_INT 1
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: LD_INT 2
40044: NEG
40045: PUSH
40046: LD_INT 0
40048: PUSH
40049: EMPTY
40050: LIST
40051: LIST
40052: PUSH
40053: LD_INT 2
40055: NEG
40056: PUSH
40057: LD_INT 1
40059: NEG
40060: PUSH
40061: EMPTY
40062: LIST
40063: LIST
40064: PUSH
40065: LD_INT 2
40067: NEG
40068: PUSH
40069: LD_INT 2
40071: NEG
40072: PUSH
40073: EMPTY
40074: LIST
40075: LIST
40076: PUSH
40077: EMPTY
40078: LIST
40079: LIST
40080: LIST
40081: LIST
40082: LIST
40083: LIST
40084: LIST
40085: LIST
40086: LIST
40087: LIST
40088: LIST
40089: LIST
40090: LIST
40091: LIST
40092: LIST
40093: LIST
40094: LIST
40095: LIST
40096: LIST
40097: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40098: LD_ADDR_VAR 0 58
40102: PUSH
40103: LD_INT 0
40105: PUSH
40106: LD_INT 0
40108: PUSH
40109: EMPTY
40110: LIST
40111: LIST
40112: PUSH
40113: LD_INT 0
40115: PUSH
40116: LD_INT 1
40118: NEG
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PUSH
40124: LD_INT 1
40126: PUSH
40127: LD_INT 0
40129: PUSH
40130: EMPTY
40131: LIST
40132: LIST
40133: PUSH
40134: LD_INT 1
40136: PUSH
40137: LD_INT 1
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: PUSH
40144: LD_INT 0
40146: PUSH
40147: LD_INT 1
40149: PUSH
40150: EMPTY
40151: LIST
40152: LIST
40153: PUSH
40154: LD_INT 1
40156: NEG
40157: PUSH
40158: LD_INT 0
40160: PUSH
40161: EMPTY
40162: LIST
40163: LIST
40164: PUSH
40165: LD_INT 1
40167: NEG
40168: PUSH
40169: LD_INT 1
40171: NEG
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PUSH
40177: LD_INT 1
40179: NEG
40180: PUSH
40181: LD_INT 2
40183: NEG
40184: PUSH
40185: EMPTY
40186: LIST
40187: LIST
40188: PUSH
40189: LD_INT 0
40191: PUSH
40192: LD_INT 2
40194: NEG
40195: PUSH
40196: EMPTY
40197: LIST
40198: LIST
40199: PUSH
40200: LD_INT 1
40202: PUSH
40203: LD_INT 1
40205: NEG
40206: PUSH
40207: EMPTY
40208: LIST
40209: LIST
40210: PUSH
40211: LD_INT 2
40213: PUSH
40214: LD_INT 0
40216: PUSH
40217: EMPTY
40218: LIST
40219: LIST
40220: PUSH
40221: LD_INT 2
40223: PUSH
40224: LD_INT 1
40226: PUSH
40227: EMPTY
40228: LIST
40229: LIST
40230: PUSH
40231: LD_INT 2
40233: PUSH
40234: LD_INT 2
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PUSH
40241: LD_INT 1
40243: PUSH
40244: LD_INT 2
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: LD_INT 0
40253: PUSH
40254: LD_INT 2
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: LD_INT 1
40263: NEG
40264: PUSH
40265: LD_INT 1
40267: PUSH
40268: EMPTY
40269: LIST
40270: LIST
40271: PUSH
40272: LD_INT 2
40274: NEG
40275: PUSH
40276: LD_INT 0
40278: PUSH
40279: EMPTY
40280: LIST
40281: LIST
40282: PUSH
40283: LD_INT 2
40285: NEG
40286: PUSH
40287: LD_INT 1
40289: NEG
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PUSH
40295: LD_INT 2
40297: NEG
40298: PUSH
40299: LD_INT 2
40301: NEG
40302: PUSH
40303: EMPTY
40304: LIST
40305: LIST
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: LIST
40311: LIST
40312: LIST
40313: LIST
40314: LIST
40315: LIST
40316: LIST
40317: LIST
40318: LIST
40319: LIST
40320: LIST
40321: LIST
40322: LIST
40323: LIST
40324: LIST
40325: LIST
40326: LIST
40327: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40328: LD_ADDR_VAR 0 59
40332: PUSH
40333: LD_INT 0
40335: PUSH
40336: LD_INT 0
40338: PUSH
40339: EMPTY
40340: LIST
40341: LIST
40342: PUSH
40343: LD_INT 0
40345: PUSH
40346: LD_INT 1
40348: NEG
40349: PUSH
40350: EMPTY
40351: LIST
40352: LIST
40353: PUSH
40354: LD_INT 1
40356: PUSH
40357: LD_INT 0
40359: PUSH
40360: EMPTY
40361: LIST
40362: LIST
40363: PUSH
40364: LD_INT 1
40366: PUSH
40367: LD_INT 1
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: LD_INT 0
40376: PUSH
40377: LD_INT 1
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: PUSH
40384: LD_INT 1
40386: NEG
40387: PUSH
40388: LD_INT 0
40390: PUSH
40391: EMPTY
40392: LIST
40393: LIST
40394: PUSH
40395: LD_INT 1
40397: NEG
40398: PUSH
40399: LD_INT 1
40401: NEG
40402: PUSH
40403: EMPTY
40404: LIST
40405: LIST
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: LIST
40411: LIST
40412: LIST
40413: LIST
40414: LIST
40415: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40416: LD_ADDR_VAR 0 60
40420: PUSH
40421: LD_INT 0
40423: PUSH
40424: LD_INT 0
40426: PUSH
40427: EMPTY
40428: LIST
40429: LIST
40430: PUSH
40431: LD_INT 0
40433: PUSH
40434: LD_INT 1
40436: NEG
40437: PUSH
40438: EMPTY
40439: LIST
40440: LIST
40441: PUSH
40442: LD_INT 1
40444: PUSH
40445: LD_INT 0
40447: PUSH
40448: EMPTY
40449: LIST
40450: LIST
40451: PUSH
40452: LD_INT 1
40454: PUSH
40455: LD_INT 1
40457: PUSH
40458: EMPTY
40459: LIST
40460: LIST
40461: PUSH
40462: LD_INT 0
40464: PUSH
40465: LD_INT 1
40467: PUSH
40468: EMPTY
40469: LIST
40470: LIST
40471: PUSH
40472: LD_INT 1
40474: NEG
40475: PUSH
40476: LD_INT 0
40478: PUSH
40479: EMPTY
40480: LIST
40481: LIST
40482: PUSH
40483: LD_INT 1
40485: NEG
40486: PUSH
40487: LD_INT 1
40489: NEG
40490: PUSH
40491: EMPTY
40492: LIST
40493: LIST
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: LIST
40499: LIST
40500: LIST
40501: LIST
40502: LIST
40503: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40504: LD_ADDR_VAR 0 61
40508: PUSH
40509: LD_INT 0
40511: PUSH
40512: LD_INT 0
40514: PUSH
40515: EMPTY
40516: LIST
40517: LIST
40518: PUSH
40519: LD_INT 0
40521: PUSH
40522: LD_INT 1
40524: NEG
40525: PUSH
40526: EMPTY
40527: LIST
40528: LIST
40529: PUSH
40530: LD_INT 1
40532: PUSH
40533: LD_INT 0
40535: PUSH
40536: EMPTY
40537: LIST
40538: LIST
40539: PUSH
40540: LD_INT 1
40542: PUSH
40543: LD_INT 1
40545: PUSH
40546: EMPTY
40547: LIST
40548: LIST
40549: PUSH
40550: LD_INT 0
40552: PUSH
40553: LD_INT 1
40555: PUSH
40556: EMPTY
40557: LIST
40558: LIST
40559: PUSH
40560: LD_INT 1
40562: NEG
40563: PUSH
40564: LD_INT 0
40566: PUSH
40567: EMPTY
40568: LIST
40569: LIST
40570: PUSH
40571: LD_INT 1
40573: NEG
40574: PUSH
40575: LD_INT 1
40577: NEG
40578: PUSH
40579: EMPTY
40580: LIST
40581: LIST
40582: PUSH
40583: EMPTY
40584: LIST
40585: LIST
40586: LIST
40587: LIST
40588: LIST
40589: LIST
40590: LIST
40591: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40592: LD_ADDR_VAR 0 62
40596: PUSH
40597: LD_INT 0
40599: PUSH
40600: LD_INT 0
40602: PUSH
40603: EMPTY
40604: LIST
40605: LIST
40606: PUSH
40607: LD_INT 0
40609: PUSH
40610: LD_INT 1
40612: NEG
40613: PUSH
40614: EMPTY
40615: LIST
40616: LIST
40617: PUSH
40618: LD_INT 1
40620: PUSH
40621: LD_INT 0
40623: PUSH
40624: EMPTY
40625: LIST
40626: LIST
40627: PUSH
40628: LD_INT 1
40630: PUSH
40631: LD_INT 1
40633: PUSH
40634: EMPTY
40635: LIST
40636: LIST
40637: PUSH
40638: LD_INT 0
40640: PUSH
40641: LD_INT 1
40643: PUSH
40644: EMPTY
40645: LIST
40646: LIST
40647: PUSH
40648: LD_INT 1
40650: NEG
40651: PUSH
40652: LD_INT 0
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 1
40661: NEG
40662: PUSH
40663: LD_INT 1
40665: NEG
40666: PUSH
40667: EMPTY
40668: LIST
40669: LIST
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: LIST
40675: LIST
40676: LIST
40677: LIST
40678: LIST
40679: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40680: LD_ADDR_VAR 0 63
40684: PUSH
40685: LD_INT 0
40687: PUSH
40688: LD_INT 0
40690: PUSH
40691: EMPTY
40692: LIST
40693: LIST
40694: PUSH
40695: LD_INT 0
40697: PUSH
40698: LD_INT 1
40700: NEG
40701: PUSH
40702: EMPTY
40703: LIST
40704: LIST
40705: PUSH
40706: LD_INT 1
40708: PUSH
40709: LD_INT 0
40711: PUSH
40712: EMPTY
40713: LIST
40714: LIST
40715: PUSH
40716: LD_INT 1
40718: PUSH
40719: LD_INT 1
40721: PUSH
40722: EMPTY
40723: LIST
40724: LIST
40725: PUSH
40726: LD_INT 0
40728: PUSH
40729: LD_INT 1
40731: PUSH
40732: EMPTY
40733: LIST
40734: LIST
40735: PUSH
40736: LD_INT 1
40738: NEG
40739: PUSH
40740: LD_INT 0
40742: PUSH
40743: EMPTY
40744: LIST
40745: LIST
40746: PUSH
40747: LD_INT 1
40749: NEG
40750: PUSH
40751: LD_INT 1
40753: NEG
40754: PUSH
40755: EMPTY
40756: LIST
40757: LIST
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: LIST
40763: LIST
40764: LIST
40765: LIST
40766: LIST
40767: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40768: LD_ADDR_VAR 0 64
40772: PUSH
40773: LD_INT 0
40775: PUSH
40776: LD_INT 0
40778: PUSH
40779: EMPTY
40780: LIST
40781: LIST
40782: PUSH
40783: LD_INT 0
40785: PUSH
40786: LD_INT 1
40788: NEG
40789: PUSH
40790: EMPTY
40791: LIST
40792: LIST
40793: PUSH
40794: LD_INT 1
40796: PUSH
40797: LD_INT 0
40799: PUSH
40800: EMPTY
40801: LIST
40802: LIST
40803: PUSH
40804: LD_INT 1
40806: PUSH
40807: LD_INT 1
40809: PUSH
40810: EMPTY
40811: LIST
40812: LIST
40813: PUSH
40814: LD_INT 0
40816: PUSH
40817: LD_INT 1
40819: PUSH
40820: EMPTY
40821: LIST
40822: LIST
40823: PUSH
40824: LD_INT 1
40826: NEG
40827: PUSH
40828: LD_INT 0
40830: PUSH
40831: EMPTY
40832: LIST
40833: LIST
40834: PUSH
40835: LD_INT 1
40837: NEG
40838: PUSH
40839: LD_INT 1
40841: NEG
40842: PUSH
40843: EMPTY
40844: LIST
40845: LIST
40846: PUSH
40847: EMPTY
40848: LIST
40849: LIST
40850: LIST
40851: LIST
40852: LIST
40853: LIST
40854: LIST
40855: ST_TO_ADDR
// end ; 1 :
40856: GO 46753
40858: LD_INT 1
40860: DOUBLE
40861: EQUAL
40862: IFTRUE 40866
40864: GO 43489
40866: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40867: LD_ADDR_VAR 0 11
40871: PUSH
40872: LD_INT 1
40874: NEG
40875: PUSH
40876: LD_INT 3
40878: NEG
40879: PUSH
40880: EMPTY
40881: LIST
40882: LIST
40883: PUSH
40884: LD_INT 0
40886: PUSH
40887: LD_INT 3
40889: NEG
40890: PUSH
40891: EMPTY
40892: LIST
40893: LIST
40894: PUSH
40895: LD_INT 1
40897: PUSH
40898: LD_INT 2
40900: NEG
40901: PUSH
40902: EMPTY
40903: LIST
40904: LIST
40905: PUSH
40906: EMPTY
40907: LIST
40908: LIST
40909: LIST
40910: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40911: LD_ADDR_VAR 0 12
40915: PUSH
40916: LD_INT 2
40918: PUSH
40919: LD_INT 1
40921: NEG
40922: PUSH
40923: EMPTY
40924: LIST
40925: LIST
40926: PUSH
40927: LD_INT 3
40929: PUSH
40930: LD_INT 0
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: LD_INT 3
40939: PUSH
40940: LD_INT 1
40942: PUSH
40943: EMPTY
40944: LIST
40945: LIST
40946: PUSH
40947: EMPTY
40948: LIST
40949: LIST
40950: LIST
40951: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40952: LD_ADDR_VAR 0 13
40956: PUSH
40957: LD_INT 3
40959: PUSH
40960: LD_INT 2
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: PUSH
40967: LD_INT 3
40969: PUSH
40970: LD_INT 3
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PUSH
40977: LD_INT 2
40979: PUSH
40980: LD_INT 3
40982: PUSH
40983: EMPTY
40984: LIST
40985: LIST
40986: PUSH
40987: EMPTY
40988: LIST
40989: LIST
40990: LIST
40991: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40992: LD_ADDR_VAR 0 14
40996: PUSH
40997: LD_INT 1
40999: PUSH
41000: LD_INT 3
41002: PUSH
41003: EMPTY
41004: LIST
41005: LIST
41006: PUSH
41007: LD_INT 0
41009: PUSH
41010: LD_INT 3
41012: PUSH
41013: EMPTY
41014: LIST
41015: LIST
41016: PUSH
41017: LD_INT 1
41019: NEG
41020: PUSH
41021: LD_INT 2
41023: PUSH
41024: EMPTY
41025: LIST
41026: LIST
41027: PUSH
41028: EMPTY
41029: LIST
41030: LIST
41031: LIST
41032: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41033: LD_ADDR_VAR 0 15
41037: PUSH
41038: LD_INT 2
41040: NEG
41041: PUSH
41042: LD_INT 1
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 3
41051: NEG
41052: PUSH
41053: LD_INT 0
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PUSH
41060: LD_INT 3
41062: NEG
41063: PUSH
41064: LD_INT 1
41066: NEG
41067: PUSH
41068: EMPTY
41069: LIST
41070: LIST
41071: PUSH
41072: EMPTY
41073: LIST
41074: LIST
41075: LIST
41076: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41077: LD_ADDR_VAR 0 16
41081: PUSH
41082: LD_INT 2
41084: NEG
41085: PUSH
41086: LD_INT 3
41088: NEG
41089: PUSH
41090: EMPTY
41091: LIST
41092: LIST
41093: PUSH
41094: LD_INT 3
41096: NEG
41097: PUSH
41098: LD_INT 2
41100: NEG
41101: PUSH
41102: EMPTY
41103: LIST
41104: LIST
41105: PUSH
41106: LD_INT 3
41108: NEG
41109: PUSH
41110: LD_INT 3
41112: NEG
41113: PUSH
41114: EMPTY
41115: LIST
41116: LIST
41117: PUSH
41118: EMPTY
41119: LIST
41120: LIST
41121: LIST
41122: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41123: LD_ADDR_VAR 0 17
41127: PUSH
41128: LD_INT 1
41130: NEG
41131: PUSH
41132: LD_INT 3
41134: NEG
41135: PUSH
41136: EMPTY
41137: LIST
41138: LIST
41139: PUSH
41140: LD_INT 0
41142: PUSH
41143: LD_INT 3
41145: NEG
41146: PUSH
41147: EMPTY
41148: LIST
41149: LIST
41150: PUSH
41151: LD_INT 1
41153: PUSH
41154: LD_INT 2
41156: NEG
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: EMPTY
41163: LIST
41164: LIST
41165: LIST
41166: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41167: LD_ADDR_VAR 0 18
41171: PUSH
41172: LD_INT 2
41174: PUSH
41175: LD_INT 1
41177: NEG
41178: PUSH
41179: EMPTY
41180: LIST
41181: LIST
41182: PUSH
41183: LD_INT 3
41185: PUSH
41186: LD_INT 0
41188: PUSH
41189: EMPTY
41190: LIST
41191: LIST
41192: PUSH
41193: LD_INT 3
41195: PUSH
41196: LD_INT 1
41198: PUSH
41199: EMPTY
41200: LIST
41201: LIST
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: LIST
41207: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41208: LD_ADDR_VAR 0 19
41212: PUSH
41213: LD_INT 3
41215: PUSH
41216: LD_INT 2
41218: PUSH
41219: EMPTY
41220: LIST
41221: LIST
41222: PUSH
41223: LD_INT 3
41225: PUSH
41226: LD_INT 3
41228: PUSH
41229: EMPTY
41230: LIST
41231: LIST
41232: PUSH
41233: LD_INT 2
41235: PUSH
41236: LD_INT 3
41238: PUSH
41239: EMPTY
41240: LIST
41241: LIST
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: LIST
41247: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41248: LD_ADDR_VAR 0 20
41252: PUSH
41253: LD_INT 1
41255: PUSH
41256: LD_INT 3
41258: PUSH
41259: EMPTY
41260: LIST
41261: LIST
41262: PUSH
41263: LD_INT 0
41265: PUSH
41266: LD_INT 3
41268: PUSH
41269: EMPTY
41270: LIST
41271: LIST
41272: PUSH
41273: LD_INT 1
41275: NEG
41276: PUSH
41277: LD_INT 2
41279: PUSH
41280: EMPTY
41281: LIST
41282: LIST
41283: PUSH
41284: EMPTY
41285: LIST
41286: LIST
41287: LIST
41288: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41289: LD_ADDR_VAR 0 21
41293: PUSH
41294: LD_INT 2
41296: NEG
41297: PUSH
41298: LD_INT 1
41300: PUSH
41301: EMPTY
41302: LIST
41303: LIST
41304: PUSH
41305: LD_INT 3
41307: NEG
41308: PUSH
41309: LD_INT 0
41311: PUSH
41312: EMPTY
41313: LIST
41314: LIST
41315: PUSH
41316: LD_INT 3
41318: NEG
41319: PUSH
41320: LD_INT 1
41322: NEG
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: PUSH
41328: EMPTY
41329: LIST
41330: LIST
41331: LIST
41332: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41333: LD_ADDR_VAR 0 22
41337: PUSH
41338: LD_INT 2
41340: NEG
41341: PUSH
41342: LD_INT 3
41344: NEG
41345: PUSH
41346: EMPTY
41347: LIST
41348: LIST
41349: PUSH
41350: LD_INT 3
41352: NEG
41353: PUSH
41354: LD_INT 2
41356: NEG
41357: PUSH
41358: EMPTY
41359: LIST
41360: LIST
41361: PUSH
41362: LD_INT 3
41364: NEG
41365: PUSH
41366: LD_INT 3
41368: NEG
41369: PUSH
41370: EMPTY
41371: LIST
41372: LIST
41373: PUSH
41374: EMPTY
41375: LIST
41376: LIST
41377: LIST
41378: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41379: LD_ADDR_VAR 0 23
41383: PUSH
41384: LD_INT 0
41386: PUSH
41387: LD_INT 3
41389: NEG
41390: PUSH
41391: EMPTY
41392: LIST
41393: LIST
41394: PUSH
41395: LD_INT 1
41397: NEG
41398: PUSH
41399: LD_INT 4
41401: NEG
41402: PUSH
41403: EMPTY
41404: LIST
41405: LIST
41406: PUSH
41407: LD_INT 1
41409: PUSH
41410: LD_INT 3
41412: NEG
41413: PUSH
41414: EMPTY
41415: LIST
41416: LIST
41417: PUSH
41418: EMPTY
41419: LIST
41420: LIST
41421: LIST
41422: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41423: LD_ADDR_VAR 0 24
41427: PUSH
41428: LD_INT 3
41430: PUSH
41431: LD_INT 0
41433: PUSH
41434: EMPTY
41435: LIST
41436: LIST
41437: PUSH
41438: LD_INT 3
41440: PUSH
41441: LD_INT 1
41443: NEG
41444: PUSH
41445: EMPTY
41446: LIST
41447: LIST
41448: PUSH
41449: LD_INT 4
41451: PUSH
41452: LD_INT 1
41454: PUSH
41455: EMPTY
41456: LIST
41457: LIST
41458: PUSH
41459: EMPTY
41460: LIST
41461: LIST
41462: LIST
41463: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41464: LD_ADDR_VAR 0 25
41468: PUSH
41469: LD_INT 3
41471: PUSH
41472: LD_INT 3
41474: PUSH
41475: EMPTY
41476: LIST
41477: LIST
41478: PUSH
41479: LD_INT 4
41481: PUSH
41482: LD_INT 3
41484: PUSH
41485: EMPTY
41486: LIST
41487: LIST
41488: PUSH
41489: LD_INT 3
41491: PUSH
41492: LD_INT 4
41494: PUSH
41495: EMPTY
41496: LIST
41497: LIST
41498: PUSH
41499: EMPTY
41500: LIST
41501: LIST
41502: LIST
41503: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41504: LD_ADDR_VAR 0 26
41508: PUSH
41509: LD_INT 0
41511: PUSH
41512: LD_INT 3
41514: PUSH
41515: EMPTY
41516: LIST
41517: LIST
41518: PUSH
41519: LD_INT 1
41521: PUSH
41522: LD_INT 4
41524: PUSH
41525: EMPTY
41526: LIST
41527: LIST
41528: PUSH
41529: LD_INT 1
41531: NEG
41532: PUSH
41533: LD_INT 3
41535: PUSH
41536: EMPTY
41537: LIST
41538: LIST
41539: PUSH
41540: EMPTY
41541: LIST
41542: LIST
41543: LIST
41544: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41545: LD_ADDR_VAR 0 27
41549: PUSH
41550: LD_INT 3
41552: NEG
41553: PUSH
41554: LD_INT 0
41556: PUSH
41557: EMPTY
41558: LIST
41559: LIST
41560: PUSH
41561: LD_INT 3
41563: NEG
41564: PUSH
41565: LD_INT 1
41567: PUSH
41568: EMPTY
41569: LIST
41570: LIST
41571: PUSH
41572: LD_INT 4
41574: NEG
41575: PUSH
41576: LD_INT 1
41578: NEG
41579: PUSH
41580: EMPTY
41581: LIST
41582: LIST
41583: PUSH
41584: EMPTY
41585: LIST
41586: LIST
41587: LIST
41588: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41589: LD_ADDR_VAR 0 28
41593: PUSH
41594: LD_INT 3
41596: NEG
41597: PUSH
41598: LD_INT 3
41600: NEG
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: LD_INT 3
41608: NEG
41609: PUSH
41610: LD_INT 4
41612: NEG
41613: PUSH
41614: EMPTY
41615: LIST
41616: LIST
41617: PUSH
41618: LD_INT 4
41620: NEG
41621: PUSH
41622: LD_INT 3
41624: NEG
41625: PUSH
41626: EMPTY
41627: LIST
41628: LIST
41629: PUSH
41630: EMPTY
41631: LIST
41632: LIST
41633: LIST
41634: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41635: LD_ADDR_VAR 0 29
41639: PUSH
41640: LD_INT 1
41642: NEG
41643: PUSH
41644: LD_INT 3
41646: NEG
41647: PUSH
41648: EMPTY
41649: LIST
41650: LIST
41651: PUSH
41652: LD_INT 0
41654: PUSH
41655: LD_INT 3
41657: NEG
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: PUSH
41663: LD_INT 1
41665: PUSH
41666: LD_INT 2
41668: NEG
41669: PUSH
41670: EMPTY
41671: LIST
41672: LIST
41673: PUSH
41674: LD_INT 1
41676: NEG
41677: PUSH
41678: LD_INT 4
41680: NEG
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 0
41688: PUSH
41689: LD_INT 4
41691: NEG
41692: PUSH
41693: EMPTY
41694: LIST
41695: LIST
41696: PUSH
41697: LD_INT 1
41699: PUSH
41700: LD_INT 3
41702: NEG
41703: PUSH
41704: EMPTY
41705: LIST
41706: LIST
41707: PUSH
41708: LD_INT 1
41710: NEG
41711: PUSH
41712: LD_INT 5
41714: NEG
41715: PUSH
41716: EMPTY
41717: LIST
41718: LIST
41719: PUSH
41720: LD_INT 0
41722: PUSH
41723: LD_INT 5
41725: NEG
41726: PUSH
41727: EMPTY
41728: LIST
41729: LIST
41730: PUSH
41731: LD_INT 1
41733: PUSH
41734: LD_INT 4
41736: NEG
41737: PUSH
41738: EMPTY
41739: LIST
41740: LIST
41741: PUSH
41742: LD_INT 1
41744: NEG
41745: PUSH
41746: LD_INT 6
41748: NEG
41749: PUSH
41750: EMPTY
41751: LIST
41752: LIST
41753: PUSH
41754: LD_INT 0
41756: PUSH
41757: LD_INT 6
41759: NEG
41760: PUSH
41761: EMPTY
41762: LIST
41763: LIST
41764: PUSH
41765: LD_INT 1
41767: PUSH
41768: LD_INT 5
41770: NEG
41771: PUSH
41772: EMPTY
41773: LIST
41774: LIST
41775: PUSH
41776: EMPTY
41777: LIST
41778: LIST
41779: LIST
41780: LIST
41781: LIST
41782: LIST
41783: LIST
41784: LIST
41785: LIST
41786: LIST
41787: LIST
41788: LIST
41789: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41790: LD_ADDR_VAR 0 30
41794: PUSH
41795: LD_INT 2
41797: PUSH
41798: LD_INT 1
41800: NEG
41801: PUSH
41802: EMPTY
41803: LIST
41804: LIST
41805: PUSH
41806: LD_INT 3
41808: PUSH
41809: LD_INT 0
41811: PUSH
41812: EMPTY
41813: LIST
41814: LIST
41815: PUSH
41816: LD_INT 3
41818: PUSH
41819: LD_INT 1
41821: PUSH
41822: EMPTY
41823: LIST
41824: LIST
41825: PUSH
41826: LD_INT 3
41828: PUSH
41829: LD_INT 1
41831: NEG
41832: PUSH
41833: EMPTY
41834: LIST
41835: LIST
41836: PUSH
41837: LD_INT 4
41839: PUSH
41840: LD_INT 0
41842: PUSH
41843: EMPTY
41844: LIST
41845: LIST
41846: PUSH
41847: LD_INT 4
41849: PUSH
41850: LD_INT 1
41852: PUSH
41853: EMPTY
41854: LIST
41855: LIST
41856: PUSH
41857: LD_INT 4
41859: PUSH
41860: LD_INT 1
41862: NEG
41863: PUSH
41864: EMPTY
41865: LIST
41866: LIST
41867: PUSH
41868: LD_INT 5
41870: PUSH
41871: LD_INT 0
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: PUSH
41878: LD_INT 5
41880: PUSH
41881: LD_INT 1
41883: PUSH
41884: EMPTY
41885: LIST
41886: LIST
41887: PUSH
41888: LD_INT 5
41890: PUSH
41891: LD_INT 1
41893: NEG
41894: PUSH
41895: EMPTY
41896: LIST
41897: LIST
41898: PUSH
41899: LD_INT 6
41901: PUSH
41902: LD_INT 0
41904: PUSH
41905: EMPTY
41906: LIST
41907: LIST
41908: PUSH
41909: LD_INT 6
41911: PUSH
41912: LD_INT 1
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PUSH
41919: EMPTY
41920: LIST
41921: LIST
41922: LIST
41923: LIST
41924: LIST
41925: LIST
41926: LIST
41927: LIST
41928: LIST
41929: LIST
41930: LIST
41931: LIST
41932: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41933: LD_ADDR_VAR 0 31
41937: PUSH
41938: LD_INT 3
41940: PUSH
41941: LD_INT 2
41943: PUSH
41944: EMPTY
41945: LIST
41946: LIST
41947: PUSH
41948: LD_INT 3
41950: PUSH
41951: LD_INT 3
41953: PUSH
41954: EMPTY
41955: LIST
41956: LIST
41957: PUSH
41958: LD_INT 2
41960: PUSH
41961: LD_INT 3
41963: PUSH
41964: EMPTY
41965: LIST
41966: LIST
41967: PUSH
41968: LD_INT 4
41970: PUSH
41971: LD_INT 3
41973: PUSH
41974: EMPTY
41975: LIST
41976: LIST
41977: PUSH
41978: LD_INT 4
41980: PUSH
41981: LD_INT 4
41983: PUSH
41984: EMPTY
41985: LIST
41986: LIST
41987: PUSH
41988: LD_INT 3
41990: PUSH
41991: LD_INT 4
41993: PUSH
41994: EMPTY
41995: LIST
41996: LIST
41997: PUSH
41998: LD_INT 5
42000: PUSH
42001: LD_INT 4
42003: PUSH
42004: EMPTY
42005: LIST
42006: LIST
42007: PUSH
42008: LD_INT 5
42010: PUSH
42011: LD_INT 5
42013: PUSH
42014: EMPTY
42015: LIST
42016: LIST
42017: PUSH
42018: LD_INT 4
42020: PUSH
42021: LD_INT 5
42023: PUSH
42024: EMPTY
42025: LIST
42026: LIST
42027: PUSH
42028: LD_INT 6
42030: PUSH
42031: LD_INT 5
42033: PUSH
42034: EMPTY
42035: LIST
42036: LIST
42037: PUSH
42038: LD_INT 6
42040: PUSH
42041: LD_INT 6
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: PUSH
42048: LD_INT 5
42050: PUSH
42051: LD_INT 6
42053: PUSH
42054: EMPTY
42055: LIST
42056: LIST
42057: PUSH
42058: EMPTY
42059: LIST
42060: LIST
42061: LIST
42062: LIST
42063: LIST
42064: LIST
42065: LIST
42066: LIST
42067: LIST
42068: LIST
42069: LIST
42070: LIST
42071: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42072: LD_ADDR_VAR 0 32
42076: PUSH
42077: LD_INT 1
42079: PUSH
42080: LD_INT 3
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: PUSH
42087: LD_INT 0
42089: PUSH
42090: LD_INT 3
42092: PUSH
42093: EMPTY
42094: LIST
42095: LIST
42096: PUSH
42097: LD_INT 1
42099: NEG
42100: PUSH
42101: LD_INT 2
42103: PUSH
42104: EMPTY
42105: LIST
42106: LIST
42107: PUSH
42108: LD_INT 1
42110: PUSH
42111: LD_INT 4
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: LD_INT 0
42120: PUSH
42121: LD_INT 4
42123: PUSH
42124: EMPTY
42125: LIST
42126: LIST
42127: PUSH
42128: LD_INT 1
42130: NEG
42131: PUSH
42132: LD_INT 3
42134: PUSH
42135: EMPTY
42136: LIST
42137: LIST
42138: PUSH
42139: LD_INT 1
42141: PUSH
42142: LD_INT 5
42144: PUSH
42145: EMPTY
42146: LIST
42147: LIST
42148: PUSH
42149: LD_INT 0
42151: PUSH
42152: LD_INT 5
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: LD_INT 1
42161: NEG
42162: PUSH
42163: LD_INT 4
42165: PUSH
42166: EMPTY
42167: LIST
42168: LIST
42169: PUSH
42170: LD_INT 1
42172: PUSH
42173: LD_INT 6
42175: PUSH
42176: EMPTY
42177: LIST
42178: LIST
42179: PUSH
42180: LD_INT 0
42182: PUSH
42183: LD_INT 6
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 1
42192: NEG
42193: PUSH
42194: LD_INT 5
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: PUSH
42201: EMPTY
42202: LIST
42203: LIST
42204: LIST
42205: LIST
42206: LIST
42207: LIST
42208: LIST
42209: LIST
42210: LIST
42211: LIST
42212: LIST
42213: LIST
42214: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42215: LD_ADDR_VAR 0 33
42219: PUSH
42220: LD_INT 2
42222: NEG
42223: PUSH
42224: LD_INT 1
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: LD_INT 3
42233: NEG
42234: PUSH
42235: LD_INT 0
42237: PUSH
42238: EMPTY
42239: LIST
42240: LIST
42241: PUSH
42242: LD_INT 3
42244: NEG
42245: PUSH
42246: LD_INT 1
42248: NEG
42249: PUSH
42250: EMPTY
42251: LIST
42252: LIST
42253: PUSH
42254: LD_INT 3
42256: NEG
42257: PUSH
42258: LD_INT 1
42260: PUSH
42261: EMPTY
42262: LIST
42263: LIST
42264: PUSH
42265: LD_INT 4
42267: NEG
42268: PUSH
42269: LD_INT 0
42271: PUSH
42272: EMPTY
42273: LIST
42274: LIST
42275: PUSH
42276: LD_INT 4
42278: NEG
42279: PUSH
42280: LD_INT 1
42282: NEG
42283: PUSH
42284: EMPTY
42285: LIST
42286: LIST
42287: PUSH
42288: LD_INT 4
42290: NEG
42291: PUSH
42292: LD_INT 1
42294: PUSH
42295: EMPTY
42296: LIST
42297: LIST
42298: PUSH
42299: LD_INT 5
42301: NEG
42302: PUSH
42303: LD_INT 0
42305: PUSH
42306: EMPTY
42307: LIST
42308: LIST
42309: PUSH
42310: LD_INT 5
42312: NEG
42313: PUSH
42314: LD_INT 1
42316: NEG
42317: PUSH
42318: EMPTY
42319: LIST
42320: LIST
42321: PUSH
42322: LD_INT 5
42324: NEG
42325: PUSH
42326: LD_INT 1
42328: PUSH
42329: EMPTY
42330: LIST
42331: LIST
42332: PUSH
42333: LD_INT 6
42335: NEG
42336: PUSH
42337: LD_INT 0
42339: PUSH
42340: EMPTY
42341: LIST
42342: LIST
42343: PUSH
42344: LD_INT 6
42346: NEG
42347: PUSH
42348: LD_INT 1
42350: NEG
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: PUSH
42356: EMPTY
42357: LIST
42358: LIST
42359: LIST
42360: LIST
42361: LIST
42362: LIST
42363: LIST
42364: LIST
42365: LIST
42366: LIST
42367: LIST
42368: LIST
42369: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42370: LD_ADDR_VAR 0 34
42374: PUSH
42375: LD_INT 2
42377: NEG
42378: PUSH
42379: LD_INT 3
42381: NEG
42382: PUSH
42383: EMPTY
42384: LIST
42385: LIST
42386: PUSH
42387: LD_INT 3
42389: NEG
42390: PUSH
42391: LD_INT 2
42393: NEG
42394: PUSH
42395: EMPTY
42396: LIST
42397: LIST
42398: PUSH
42399: LD_INT 3
42401: NEG
42402: PUSH
42403: LD_INT 3
42405: NEG
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: PUSH
42411: LD_INT 3
42413: NEG
42414: PUSH
42415: LD_INT 4
42417: NEG
42418: PUSH
42419: EMPTY
42420: LIST
42421: LIST
42422: PUSH
42423: LD_INT 4
42425: NEG
42426: PUSH
42427: LD_INT 3
42429: NEG
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PUSH
42435: LD_INT 4
42437: NEG
42438: PUSH
42439: LD_INT 4
42441: NEG
42442: PUSH
42443: EMPTY
42444: LIST
42445: LIST
42446: PUSH
42447: LD_INT 4
42449: NEG
42450: PUSH
42451: LD_INT 5
42453: NEG
42454: PUSH
42455: EMPTY
42456: LIST
42457: LIST
42458: PUSH
42459: LD_INT 5
42461: NEG
42462: PUSH
42463: LD_INT 4
42465: NEG
42466: PUSH
42467: EMPTY
42468: LIST
42469: LIST
42470: PUSH
42471: LD_INT 5
42473: NEG
42474: PUSH
42475: LD_INT 5
42477: NEG
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: PUSH
42483: LD_INT 5
42485: NEG
42486: PUSH
42487: LD_INT 6
42489: NEG
42490: PUSH
42491: EMPTY
42492: LIST
42493: LIST
42494: PUSH
42495: LD_INT 6
42497: NEG
42498: PUSH
42499: LD_INT 5
42501: NEG
42502: PUSH
42503: EMPTY
42504: LIST
42505: LIST
42506: PUSH
42507: LD_INT 6
42509: NEG
42510: PUSH
42511: LD_INT 6
42513: NEG
42514: PUSH
42515: EMPTY
42516: LIST
42517: LIST
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: LIST
42523: LIST
42524: LIST
42525: LIST
42526: LIST
42527: LIST
42528: LIST
42529: LIST
42530: LIST
42531: LIST
42532: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42533: LD_ADDR_VAR 0 41
42537: PUSH
42538: LD_INT 0
42540: PUSH
42541: LD_INT 2
42543: NEG
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: LD_INT 1
42551: NEG
42552: PUSH
42553: LD_INT 3
42555: NEG
42556: PUSH
42557: EMPTY
42558: LIST
42559: LIST
42560: PUSH
42561: LD_INT 1
42563: PUSH
42564: LD_INT 2
42566: NEG
42567: PUSH
42568: EMPTY
42569: LIST
42570: LIST
42571: PUSH
42572: EMPTY
42573: LIST
42574: LIST
42575: LIST
42576: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42577: LD_ADDR_VAR 0 42
42581: PUSH
42582: LD_INT 2
42584: PUSH
42585: LD_INT 0
42587: PUSH
42588: EMPTY
42589: LIST
42590: LIST
42591: PUSH
42592: LD_INT 2
42594: PUSH
42595: LD_INT 1
42597: NEG
42598: PUSH
42599: EMPTY
42600: LIST
42601: LIST
42602: PUSH
42603: LD_INT 3
42605: PUSH
42606: LD_INT 1
42608: PUSH
42609: EMPTY
42610: LIST
42611: LIST
42612: PUSH
42613: EMPTY
42614: LIST
42615: LIST
42616: LIST
42617: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42618: LD_ADDR_VAR 0 43
42622: PUSH
42623: LD_INT 2
42625: PUSH
42626: LD_INT 2
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: PUSH
42633: LD_INT 3
42635: PUSH
42636: LD_INT 2
42638: PUSH
42639: EMPTY
42640: LIST
42641: LIST
42642: PUSH
42643: LD_INT 2
42645: PUSH
42646: LD_INT 3
42648: PUSH
42649: EMPTY
42650: LIST
42651: LIST
42652: PUSH
42653: EMPTY
42654: LIST
42655: LIST
42656: LIST
42657: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42658: LD_ADDR_VAR 0 44
42662: PUSH
42663: LD_INT 0
42665: PUSH
42666: LD_INT 2
42668: PUSH
42669: EMPTY
42670: LIST
42671: LIST
42672: PUSH
42673: LD_INT 1
42675: PUSH
42676: LD_INT 3
42678: PUSH
42679: EMPTY
42680: LIST
42681: LIST
42682: PUSH
42683: LD_INT 1
42685: NEG
42686: PUSH
42687: LD_INT 2
42689: PUSH
42690: EMPTY
42691: LIST
42692: LIST
42693: PUSH
42694: EMPTY
42695: LIST
42696: LIST
42697: LIST
42698: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42699: LD_ADDR_VAR 0 45
42703: PUSH
42704: LD_INT 2
42706: NEG
42707: PUSH
42708: LD_INT 0
42710: PUSH
42711: EMPTY
42712: LIST
42713: LIST
42714: PUSH
42715: LD_INT 2
42717: NEG
42718: PUSH
42719: LD_INT 1
42721: PUSH
42722: EMPTY
42723: LIST
42724: LIST
42725: PUSH
42726: LD_INT 3
42728: NEG
42729: PUSH
42730: LD_INT 1
42732: NEG
42733: PUSH
42734: EMPTY
42735: LIST
42736: LIST
42737: PUSH
42738: EMPTY
42739: LIST
42740: LIST
42741: LIST
42742: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42743: LD_ADDR_VAR 0 46
42747: PUSH
42748: LD_INT 2
42750: NEG
42751: PUSH
42752: LD_INT 2
42754: NEG
42755: PUSH
42756: EMPTY
42757: LIST
42758: LIST
42759: PUSH
42760: LD_INT 2
42762: NEG
42763: PUSH
42764: LD_INT 3
42766: NEG
42767: PUSH
42768: EMPTY
42769: LIST
42770: LIST
42771: PUSH
42772: LD_INT 3
42774: NEG
42775: PUSH
42776: LD_INT 2
42778: NEG
42779: PUSH
42780: EMPTY
42781: LIST
42782: LIST
42783: PUSH
42784: EMPTY
42785: LIST
42786: LIST
42787: LIST
42788: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42789: LD_ADDR_VAR 0 47
42793: PUSH
42794: LD_INT 2
42796: NEG
42797: PUSH
42798: LD_INT 3
42800: NEG
42801: PUSH
42802: EMPTY
42803: LIST
42804: LIST
42805: PUSH
42806: LD_INT 1
42808: NEG
42809: PUSH
42810: LD_INT 3
42812: NEG
42813: PUSH
42814: EMPTY
42815: LIST
42816: LIST
42817: PUSH
42818: EMPTY
42819: LIST
42820: LIST
42821: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42822: LD_ADDR_VAR 0 48
42826: PUSH
42827: LD_INT 1
42829: PUSH
42830: LD_INT 2
42832: NEG
42833: PUSH
42834: EMPTY
42835: LIST
42836: LIST
42837: PUSH
42838: LD_INT 2
42840: PUSH
42841: LD_INT 1
42843: NEG
42844: PUSH
42845: EMPTY
42846: LIST
42847: LIST
42848: PUSH
42849: EMPTY
42850: LIST
42851: LIST
42852: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42853: LD_ADDR_VAR 0 49
42857: PUSH
42858: LD_INT 3
42860: PUSH
42861: LD_INT 1
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: PUSH
42868: LD_INT 3
42870: PUSH
42871: LD_INT 2
42873: PUSH
42874: EMPTY
42875: LIST
42876: LIST
42877: PUSH
42878: EMPTY
42879: LIST
42880: LIST
42881: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42882: LD_ADDR_VAR 0 50
42886: PUSH
42887: LD_INT 2
42889: PUSH
42890: LD_INT 3
42892: PUSH
42893: EMPTY
42894: LIST
42895: LIST
42896: PUSH
42897: LD_INT 1
42899: PUSH
42900: LD_INT 3
42902: PUSH
42903: EMPTY
42904: LIST
42905: LIST
42906: PUSH
42907: EMPTY
42908: LIST
42909: LIST
42910: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42911: LD_ADDR_VAR 0 51
42915: PUSH
42916: LD_INT 1
42918: NEG
42919: PUSH
42920: LD_INT 2
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PUSH
42927: LD_INT 2
42929: NEG
42930: PUSH
42931: LD_INT 1
42933: PUSH
42934: EMPTY
42935: LIST
42936: LIST
42937: PUSH
42938: EMPTY
42939: LIST
42940: LIST
42941: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42942: LD_ADDR_VAR 0 52
42946: PUSH
42947: LD_INT 3
42949: NEG
42950: PUSH
42951: LD_INT 1
42953: NEG
42954: PUSH
42955: EMPTY
42956: LIST
42957: LIST
42958: PUSH
42959: LD_INT 3
42961: NEG
42962: PUSH
42963: LD_INT 2
42965: NEG
42966: PUSH
42967: EMPTY
42968: LIST
42969: LIST
42970: PUSH
42971: EMPTY
42972: LIST
42973: LIST
42974: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42975: LD_ADDR_VAR 0 53
42979: PUSH
42980: LD_INT 1
42982: NEG
42983: PUSH
42984: LD_INT 3
42986: NEG
42987: PUSH
42988: EMPTY
42989: LIST
42990: LIST
42991: PUSH
42992: LD_INT 0
42994: PUSH
42995: LD_INT 3
42997: NEG
42998: PUSH
42999: EMPTY
43000: LIST
43001: LIST
43002: PUSH
43003: LD_INT 1
43005: PUSH
43006: LD_INT 2
43008: NEG
43009: PUSH
43010: EMPTY
43011: LIST
43012: LIST
43013: PUSH
43014: EMPTY
43015: LIST
43016: LIST
43017: LIST
43018: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43019: LD_ADDR_VAR 0 54
43023: PUSH
43024: LD_INT 2
43026: PUSH
43027: LD_INT 1
43029: NEG
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: LD_INT 3
43037: PUSH
43038: LD_INT 0
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: PUSH
43045: LD_INT 3
43047: PUSH
43048: LD_INT 1
43050: PUSH
43051: EMPTY
43052: LIST
43053: LIST
43054: PUSH
43055: EMPTY
43056: LIST
43057: LIST
43058: LIST
43059: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43060: LD_ADDR_VAR 0 55
43064: PUSH
43065: LD_INT 3
43067: PUSH
43068: LD_INT 2
43070: PUSH
43071: EMPTY
43072: LIST
43073: LIST
43074: PUSH
43075: LD_INT 3
43077: PUSH
43078: LD_INT 3
43080: PUSH
43081: EMPTY
43082: LIST
43083: LIST
43084: PUSH
43085: LD_INT 2
43087: PUSH
43088: LD_INT 3
43090: PUSH
43091: EMPTY
43092: LIST
43093: LIST
43094: PUSH
43095: EMPTY
43096: LIST
43097: LIST
43098: LIST
43099: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43100: LD_ADDR_VAR 0 56
43104: PUSH
43105: LD_INT 1
43107: PUSH
43108: LD_INT 3
43110: PUSH
43111: EMPTY
43112: LIST
43113: LIST
43114: PUSH
43115: LD_INT 0
43117: PUSH
43118: LD_INT 3
43120: PUSH
43121: EMPTY
43122: LIST
43123: LIST
43124: PUSH
43125: LD_INT 1
43127: NEG
43128: PUSH
43129: LD_INT 2
43131: PUSH
43132: EMPTY
43133: LIST
43134: LIST
43135: PUSH
43136: EMPTY
43137: LIST
43138: LIST
43139: LIST
43140: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43141: LD_ADDR_VAR 0 57
43145: PUSH
43146: LD_INT 2
43148: NEG
43149: PUSH
43150: LD_INT 1
43152: PUSH
43153: EMPTY
43154: LIST
43155: LIST
43156: PUSH
43157: LD_INT 3
43159: NEG
43160: PUSH
43161: LD_INT 0
43163: PUSH
43164: EMPTY
43165: LIST
43166: LIST
43167: PUSH
43168: LD_INT 3
43170: NEG
43171: PUSH
43172: LD_INT 1
43174: NEG
43175: PUSH
43176: EMPTY
43177: LIST
43178: LIST
43179: PUSH
43180: EMPTY
43181: LIST
43182: LIST
43183: LIST
43184: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43185: LD_ADDR_VAR 0 58
43189: PUSH
43190: LD_INT 2
43192: NEG
43193: PUSH
43194: LD_INT 3
43196: NEG
43197: PUSH
43198: EMPTY
43199: LIST
43200: LIST
43201: PUSH
43202: LD_INT 3
43204: NEG
43205: PUSH
43206: LD_INT 2
43208: NEG
43209: PUSH
43210: EMPTY
43211: LIST
43212: LIST
43213: PUSH
43214: LD_INT 3
43216: NEG
43217: PUSH
43218: LD_INT 3
43220: NEG
43221: PUSH
43222: EMPTY
43223: LIST
43224: LIST
43225: PUSH
43226: EMPTY
43227: LIST
43228: LIST
43229: LIST
43230: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43231: LD_ADDR_VAR 0 59
43235: PUSH
43236: LD_INT 1
43238: NEG
43239: PUSH
43240: LD_INT 2
43242: NEG
43243: PUSH
43244: EMPTY
43245: LIST
43246: LIST
43247: PUSH
43248: LD_INT 0
43250: PUSH
43251: LD_INT 2
43253: NEG
43254: PUSH
43255: EMPTY
43256: LIST
43257: LIST
43258: PUSH
43259: LD_INT 1
43261: PUSH
43262: LD_INT 1
43264: NEG
43265: PUSH
43266: EMPTY
43267: LIST
43268: LIST
43269: PUSH
43270: EMPTY
43271: LIST
43272: LIST
43273: LIST
43274: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43275: LD_ADDR_VAR 0 60
43279: PUSH
43280: LD_INT 1
43282: PUSH
43283: LD_INT 1
43285: NEG
43286: PUSH
43287: EMPTY
43288: LIST
43289: LIST
43290: PUSH
43291: LD_INT 2
43293: PUSH
43294: LD_INT 0
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: PUSH
43301: LD_INT 2
43303: PUSH
43304: LD_INT 1
43306: PUSH
43307: EMPTY
43308: LIST
43309: LIST
43310: PUSH
43311: EMPTY
43312: LIST
43313: LIST
43314: LIST
43315: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43316: LD_ADDR_VAR 0 61
43320: PUSH
43321: LD_INT 2
43323: PUSH
43324: LD_INT 1
43326: PUSH
43327: EMPTY
43328: LIST
43329: LIST
43330: PUSH
43331: LD_INT 2
43333: PUSH
43334: LD_INT 2
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: LD_INT 1
43343: PUSH
43344: LD_INT 2
43346: PUSH
43347: EMPTY
43348: LIST
43349: LIST
43350: PUSH
43351: EMPTY
43352: LIST
43353: LIST
43354: LIST
43355: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43356: LD_ADDR_VAR 0 62
43360: PUSH
43361: LD_INT 1
43363: PUSH
43364: LD_INT 2
43366: PUSH
43367: EMPTY
43368: LIST
43369: LIST
43370: PUSH
43371: LD_INT 0
43373: PUSH
43374: LD_INT 2
43376: PUSH
43377: EMPTY
43378: LIST
43379: LIST
43380: PUSH
43381: LD_INT 1
43383: NEG
43384: PUSH
43385: LD_INT 1
43387: PUSH
43388: EMPTY
43389: LIST
43390: LIST
43391: PUSH
43392: EMPTY
43393: LIST
43394: LIST
43395: LIST
43396: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43397: LD_ADDR_VAR 0 63
43401: PUSH
43402: LD_INT 1
43404: NEG
43405: PUSH
43406: LD_INT 1
43408: PUSH
43409: EMPTY
43410: LIST
43411: LIST
43412: PUSH
43413: LD_INT 2
43415: NEG
43416: PUSH
43417: LD_INT 0
43419: PUSH
43420: EMPTY
43421: LIST
43422: LIST
43423: PUSH
43424: LD_INT 2
43426: NEG
43427: PUSH
43428: LD_INT 1
43430: NEG
43431: PUSH
43432: EMPTY
43433: LIST
43434: LIST
43435: PUSH
43436: EMPTY
43437: LIST
43438: LIST
43439: LIST
43440: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43441: LD_ADDR_VAR 0 64
43445: PUSH
43446: LD_INT 1
43448: NEG
43449: PUSH
43450: LD_INT 2
43452: NEG
43453: PUSH
43454: EMPTY
43455: LIST
43456: LIST
43457: PUSH
43458: LD_INT 2
43460: NEG
43461: PUSH
43462: LD_INT 1
43464: NEG
43465: PUSH
43466: EMPTY
43467: LIST
43468: LIST
43469: PUSH
43470: LD_INT 2
43472: NEG
43473: PUSH
43474: LD_INT 2
43476: NEG
43477: PUSH
43478: EMPTY
43479: LIST
43480: LIST
43481: PUSH
43482: EMPTY
43483: LIST
43484: LIST
43485: LIST
43486: ST_TO_ADDR
// end ; 2 :
43487: GO 46753
43489: LD_INT 2
43491: DOUBLE
43492: EQUAL
43493: IFTRUE 43497
43495: GO 46752
43497: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43498: LD_ADDR_VAR 0 29
43502: PUSH
43503: LD_INT 4
43505: PUSH
43506: LD_INT 0
43508: PUSH
43509: EMPTY
43510: LIST
43511: LIST
43512: PUSH
43513: LD_INT 4
43515: PUSH
43516: LD_INT 1
43518: NEG
43519: PUSH
43520: EMPTY
43521: LIST
43522: LIST
43523: PUSH
43524: LD_INT 5
43526: PUSH
43527: LD_INT 0
43529: PUSH
43530: EMPTY
43531: LIST
43532: LIST
43533: PUSH
43534: LD_INT 5
43536: PUSH
43537: LD_INT 1
43539: PUSH
43540: EMPTY
43541: LIST
43542: LIST
43543: PUSH
43544: LD_INT 4
43546: PUSH
43547: LD_INT 1
43549: PUSH
43550: EMPTY
43551: LIST
43552: LIST
43553: PUSH
43554: LD_INT 3
43556: PUSH
43557: LD_INT 0
43559: PUSH
43560: EMPTY
43561: LIST
43562: LIST
43563: PUSH
43564: LD_INT 3
43566: PUSH
43567: LD_INT 1
43569: NEG
43570: PUSH
43571: EMPTY
43572: LIST
43573: LIST
43574: PUSH
43575: LD_INT 3
43577: PUSH
43578: LD_INT 2
43580: NEG
43581: PUSH
43582: EMPTY
43583: LIST
43584: LIST
43585: PUSH
43586: LD_INT 5
43588: PUSH
43589: LD_INT 2
43591: PUSH
43592: EMPTY
43593: LIST
43594: LIST
43595: PUSH
43596: LD_INT 3
43598: PUSH
43599: LD_INT 3
43601: PUSH
43602: EMPTY
43603: LIST
43604: LIST
43605: PUSH
43606: LD_INT 3
43608: PUSH
43609: LD_INT 2
43611: PUSH
43612: EMPTY
43613: LIST
43614: LIST
43615: PUSH
43616: LD_INT 4
43618: PUSH
43619: LD_INT 3
43621: PUSH
43622: EMPTY
43623: LIST
43624: LIST
43625: PUSH
43626: LD_INT 4
43628: PUSH
43629: LD_INT 4
43631: PUSH
43632: EMPTY
43633: LIST
43634: LIST
43635: PUSH
43636: LD_INT 3
43638: PUSH
43639: LD_INT 4
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: PUSH
43646: LD_INT 2
43648: PUSH
43649: LD_INT 3
43651: PUSH
43652: EMPTY
43653: LIST
43654: LIST
43655: PUSH
43656: LD_INT 2
43658: PUSH
43659: LD_INT 2
43661: PUSH
43662: EMPTY
43663: LIST
43664: LIST
43665: PUSH
43666: LD_INT 4
43668: PUSH
43669: LD_INT 2
43671: PUSH
43672: EMPTY
43673: LIST
43674: LIST
43675: PUSH
43676: LD_INT 2
43678: PUSH
43679: LD_INT 4
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: PUSH
43686: LD_INT 0
43688: PUSH
43689: LD_INT 4
43691: PUSH
43692: EMPTY
43693: LIST
43694: LIST
43695: PUSH
43696: LD_INT 0
43698: PUSH
43699: LD_INT 3
43701: PUSH
43702: EMPTY
43703: LIST
43704: LIST
43705: PUSH
43706: LD_INT 1
43708: PUSH
43709: LD_INT 4
43711: PUSH
43712: EMPTY
43713: LIST
43714: LIST
43715: PUSH
43716: LD_INT 1
43718: PUSH
43719: LD_INT 5
43721: PUSH
43722: EMPTY
43723: LIST
43724: LIST
43725: PUSH
43726: LD_INT 0
43728: PUSH
43729: LD_INT 5
43731: PUSH
43732: EMPTY
43733: LIST
43734: LIST
43735: PUSH
43736: LD_INT 1
43738: NEG
43739: PUSH
43740: LD_INT 4
43742: PUSH
43743: EMPTY
43744: LIST
43745: LIST
43746: PUSH
43747: LD_INT 1
43749: NEG
43750: PUSH
43751: LD_INT 3
43753: PUSH
43754: EMPTY
43755: LIST
43756: LIST
43757: PUSH
43758: LD_INT 2
43760: PUSH
43761: LD_INT 5
43763: PUSH
43764: EMPTY
43765: LIST
43766: LIST
43767: PUSH
43768: LD_INT 2
43770: NEG
43771: PUSH
43772: LD_INT 3
43774: PUSH
43775: EMPTY
43776: LIST
43777: LIST
43778: PUSH
43779: LD_INT 3
43781: NEG
43782: PUSH
43783: LD_INT 0
43785: PUSH
43786: EMPTY
43787: LIST
43788: LIST
43789: PUSH
43790: LD_INT 3
43792: NEG
43793: PUSH
43794: LD_INT 1
43796: NEG
43797: PUSH
43798: EMPTY
43799: LIST
43800: LIST
43801: PUSH
43802: LD_INT 2
43804: NEG
43805: PUSH
43806: LD_INT 0
43808: PUSH
43809: EMPTY
43810: LIST
43811: LIST
43812: PUSH
43813: LD_INT 2
43815: NEG
43816: PUSH
43817: LD_INT 1
43819: PUSH
43820: EMPTY
43821: LIST
43822: LIST
43823: PUSH
43824: LD_INT 3
43826: NEG
43827: PUSH
43828: LD_INT 1
43830: PUSH
43831: EMPTY
43832: LIST
43833: LIST
43834: PUSH
43835: LD_INT 4
43837: NEG
43838: PUSH
43839: LD_INT 0
43841: PUSH
43842: EMPTY
43843: LIST
43844: LIST
43845: PUSH
43846: LD_INT 4
43848: NEG
43849: PUSH
43850: LD_INT 1
43852: NEG
43853: PUSH
43854: EMPTY
43855: LIST
43856: LIST
43857: PUSH
43858: LD_INT 4
43860: NEG
43861: PUSH
43862: LD_INT 2
43864: NEG
43865: PUSH
43866: EMPTY
43867: LIST
43868: LIST
43869: PUSH
43870: LD_INT 2
43872: NEG
43873: PUSH
43874: LD_INT 2
43876: PUSH
43877: EMPTY
43878: LIST
43879: LIST
43880: PUSH
43881: LD_INT 4
43883: NEG
43884: PUSH
43885: LD_INT 4
43887: NEG
43888: PUSH
43889: EMPTY
43890: LIST
43891: LIST
43892: PUSH
43893: LD_INT 4
43895: NEG
43896: PUSH
43897: LD_INT 5
43899: NEG
43900: PUSH
43901: EMPTY
43902: LIST
43903: LIST
43904: PUSH
43905: LD_INT 3
43907: NEG
43908: PUSH
43909: LD_INT 4
43911: NEG
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 3
43919: NEG
43920: PUSH
43921: LD_INT 3
43923: NEG
43924: PUSH
43925: EMPTY
43926: LIST
43927: LIST
43928: PUSH
43929: LD_INT 4
43931: NEG
43932: PUSH
43933: LD_INT 3
43935: NEG
43936: PUSH
43937: EMPTY
43938: LIST
43939: LIST
43940: PUSH
43941: LD_INT 5
43943: NEG
43944: PUSH
43945: LD_INT 4
43947: NEG
43948: PUSH
43949: EMPTY
43950: LIST
43951: LIST
43952: PUSH
43953: LD_INT 5
43955: NEG
43956: PUSH
43957: LD_INT 5
43959: NEG
43960: PUSH
43961: EMPTY
43962: LIST
43963: LIST
43964: PUSH
43965: LD_INT 3
43967: NEG
43968: PUSH
43969: LD_INT 5
43971: NEG
43972: PUSH
43973: EMPTY
43974: LIST
43975: LIST
43976: PUSH
43977: LD_INT 5
43979: NEG
43980: PUSH
43981: LD_INT 3
43983: NEG
43984: PUSH
43985: EMPTY
43986: LIST
43987: LIST
43988: PUSH
43989: EMPTY
43990: LIST
43991: LIST
43992: LIST
43993: LIST
43994: LIST
43995: LIST
43996: LIST
43997: LIST
43998: LIST
43999: LIST
44000: LIST
44001: LIST
44002: LIST
44003: LIST
44004: LIST
44005: LIST
44006: LIST
44007: LIST
44008: LIST
44009: LIST
44010: LIST
44011: LIST
44012: LIST
44013: LIST
44014: LIST
44015: LIST
44016: LIST
44017: LIST
44018: LIST
44019: LIST
44020: LIST
44021: LIST
44022: LIST
44023: LIST
44024: LIST
44025: LIST
44026: LIST
44027: LIST
44028: LIST
44029: LIST
44030: LIST
44031: LIST
44032: LIST
44033: LIST
44034: LIST
44035: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
44036: LD_ADDR_VAR 0 30
44040: PUSH
44041: LD_INT 4
44043: PUSH
44044: LD_INT 4
44046: PUSH
44047: EMPTY
44048: LIST
44049: LIST
44050: PUSH
44051: LD_INT 4
44053: PUSH
44054: LD_INT 3
44056: PUSH
44057: EMPTY
44058: LIST
44059: LIST
44060: PUSH
44061: LD_INT 5
44063: PUSH
44064: LD_INT 4
44066: PUSH
44067: EMPTY
44068: LIST
44069: LIST
44070: PUSH
44071: LD_INT 5
44073: PUSH
44074: LD_INT 5
44076: PUSH
44077: EMPTY
44078: LIST
44079: LIST
44080: PUSH
44081: LD_INT 4
44083: PUSH
44084: LD_INT 5
44086: PUSH
44087: EMPTY
44088: LIST
44089: LIST
44090: PUSH
44091: LD_INT 3
44093: PUSH
44094: LD_INT 4
44096: PUSH
44097: EMPTY
44098: LIST
44099: LIST
44100: PUSH
44101: LD_INT 3
44103: PUSH
44104: LD_INT 3
44106: PUSH
44107: EMPTY
44108: LIST
44109: LIST
44110: PUSH
44111: LD_INT 5
44113: PUSH
44114: LD_INT 3
44116: PUSH
44117: EMPTY
44118: LIST
44119: LIST
44120: PUSH
44121: LD_INT 3
44123: PUSH
44124: LD_INT 5
44126: PUSH
44127: EMPTY
44128: LIST
44129: LIST
44130: PUSH
44131: LD_INT 0
44133: PUSH
44134: LD_INT 3
44136: PUSH
44137: EMPTY
44138: LIST
44139: LIST
44140: PUSH
44141: LD_INT 0
44143: PUSH
44144: LD_INT 2
44146: PUSH
44147: EMPTY
44148: LIST
44149: LIST
44150: PUSH
44151: LD_INT 1
44153: PUSH
44154: LD_INT 3
44156: PUSH
44157: EMPTY
44158: LIST
44159: LIST
44160: PUSH
44161: LD_INT 1
44163: PUSH
44164: LD_INT 4
44166: PUSH
44167: EMPTY
44168: LIST
44169: LIST
44170: PUSH
44171: LD_INT 0
44173: PUSH
44174: LD_INT 4
44176: PUSH
44177: EMPTY
44178: LIST
44179: LIST
44180: PUSH
44181: LD_INT 1
44183: NEG
44184: PUSH
44185: LD_INT 3
44187: PUSH
44188: EMPTY
44189: LIST
44190: LIST
44191: PUSH
44192: LD_INT 1
44194: NEG
44195: PUSH
44196: LD_INT 2
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PUSH
44203: LD_INT 2
44205: PUSH
44206: LD_INT 4
44208: PUSH
44209: EMPTY
44210: LIST
44211: LIST
44212: PUSH
44213: LD_INT 2
44215: NEG
44216: PUSH
44217: LD_INT 2
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: PUSH
44224: LD_INT 4
44226: NEG
44227: PUSH
44228: LD_INT 0
44230: PUSH
44231: EMPTY
44232: LIST
44233: LIST
44234: PUSH
44235: LD_INT 4
44237: NEG
44238: PUSH
44239: LD_INT 1
44241: NEG
44242: PUSH
44243: EMPTY
44244: LIST
44245: LIST
44246: PUSH
44247: LD_INT 3
44249: NEG
44250: PUSH
44251: LD_INT 0
44253: PUSH
44254: EMPTY
44255: LIST
44256: LIST
44257: PUSH
44258: LD_INT 3
44260: NEG
44261: PUSH
44262: LD_INT 1
44264: PUSH
44265: EMPTY
44266: LIST
44267: LIST
44268: PUSH
44269: LD_INT 4
44271: NEG
44272: PUSH
44273: LD_INT 1
44275: PUSH
44276: EMPTY
44277: LIST
44278: LIST
44279: PUSH
44280: LD_INT 5
44282: NEG
44283: PUSH
44284: LD_INT 0
44286: PUSH
44287: EMPTY
44288: LIST
44289: LIST
44290: PUSH
44291: LD_INT 5
44293: NEG
44294: PUSH
44295: LD_INT 1
44297: NEG
44298: PUSH
44299: EMPTY
44300: LIST
44301: LIST
44302: PUSH
44303: LD_INT 5
44305: NEG
44306: PUSH
44307: LD_INT 2
44309: NEG
44310: PUSH
44311: EMPTY
44312: LIST
44313: LIST
44314: PUSH
44315: LD_INT 3
44317: NEG
44318: PUSH
44319: LD_INT 2
44321: PUSH
44322: EMPTY
44323: LIST
44324: LIST
44325: PUSH
44326: LD_INT 3
44328: NEG
44329: PUSH
44330: LD_INT 3
44332: NEG
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: PUSH
44338: LD_INT 3
44340: NEG
44341: PUSH
44342: LD_INT 4
44344: NEG
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: PUSH
44350: LD_INT 2
44352: NEG
44353: PUSH
44354: LD_INT 3
44356: NEG
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: PUSH
44362: LD_INT 2
44364: NEG
44365: PUSH
44366: LD_INT 2
44368: NEG
44369: PUSH
44370: EMPTY
44371: LIST
44372: LIST
44373: PUSH
44374: LD_INT 3
44376: NEG
44377: PUSH
44378: LD_INT 2
44380: NEG
44381: PUSH
44382: EMPTY
44383: LIST
44384: LIST
44385: PUSH
44386: LD_INT 4
44388: NEG
44389: PUSH
44390: LD_INT 3
44392: NEG
44393: PUSH
44394: EMPTY
44395: LIST
44396: LIST
44397: PUSH
44398: LD_INT 4
44400: NEG
44401: PUSH
44402: LD_INT 4
44404: NEG
44405: PUSH
44406: EMPTY
44407: LIST
44408: LIST
44409: PUSH
44410: LD_INT 2
44412: NEG
44413: PUSH
44414: LD_INT 4
44416: NEG
44417: PUSH
44418: EMPTY
44419: LIST
44420: LIST
44421: PUSH
44422: LD_INT 4
44424: NEG
44425: PUSH
44426: LD_INT 2
44428: NEG
44429: PUSH
44430: EMPTY
44431: LIST
44432: LIST
44433: PUSH
44434: LD_INT 0
44436: PUSH
44437: LD_INT 4
44439: NEG
44440: PUSH
44441: EMPTY
44442: LIST
44443: LIST
44444: PUSH
44445: LD_INT 0
44447: PUSH
44448: LD_INT 5
44450: NEG
44451: PUSH
44452: EMPTY
44453: LIST
44454: LIST
44455: PUSH
44456: LD_INT 1
44458: PUSH
44459: LD_INT 4
44461: NEG
44462: PUSH
44463: EMPTY
44464: LIST
44465: LIST
44466: PUSH
44467: LD_INT 1
44469: PUSH
44470: LD_INT 3
44472: NEG
44473: PUSH
44474: EMPTY
44475: LIST
44476: LIST
44477: PUSH
44478: LD_INT 0
44480: PUSH
44481: LD_INT 3
44483: NEG
44484: PUSH
44485: EMPTY
44486: LIST
44487: LIST
44488: PUSH
44489: LD_INT 1
44491: NEG
44492: PUSH
44493: LD_INT 4
44495: NEG
44496: PUSH
44497: EMPTY
44498: LIST
44499: LIST
44500: PUSH
44501: LD_INT 1
44503: NEG
44504: PUSH
44505: LD_INT 5
44507: NEG
44508: PUSH
44509: EMPTY
44510: LIST
44511: LIST
44512: PUSH
44513: LD_INT 2
44515: PUSH
44516: LD_INT 3
44518: NEG
44519: PUSH
44520: EMPTY
44521: LIST
44522: LIST
44523: PUSH
44524: LD_INT 2
44526: NEG
44527: PUSH
44528: LD_INT 5
44530: NEG
44531: PUSH
44532: EMPTY
44533: LIST
44534: LIST
44535: PUSH
44536: EMPTY
44537: LIST
44538: LIST
44539: LIST
44540: LIST
44541: LIST
44542: LIST
44543: LIST
44544: LIST
44545: LIST
44546: LIST
44547: LIST
44548: LIST
44549: LIST
44550: LIST
44551: LIST
44552: LIST
44553: LIST
44554: LIST
44555: LIST
44556: LIST
44557: LIST
44558: LIST
44559: LIST
44560: LIST
44561: LIST
44562: LIST
44563: LIST
44564: LIST
44565: LIST
44566: LIST
44567: LIST
44568: LIST
44569: LIST
44570: LIST
44571: LIST
44572: LIST
44573: LIST
44574: LIST
44575: LIST
44576: LIST
44577: LIST
44578: LIST
44579: LIST
44580: LIST
44581: LIST
44582: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44583: LD_ADDR_VAR 0 31
44587: PUSH
44588: LD_INT 0
44590: PUSH
44591: LD_INT 4
44593: PUSH
44594: EMPTY
44595: LIST
44596: LIST
44597: PUSH
44598: LD_INT 0
44600: PUSH
44601: LD_INT 3
44603: PUSH
44604: EMPTY
44605: LIST
44606: LIST
44607: PUSH
44608: LD_INT 1
44610: PUSH
44611: LD_INT 4
44613: PUSH
44614: EMPTY
44615: LIST
44616: LIST
44617: PUSH
44618: LD_INT 1
44620: PUSH
44621: LD_INT 5
44623: PUSH
44624: EMPTY
44625: LIST
44626: LIST
44627: PUSH
44628: LD_INT 0
44630: PUSH
44631: LD_INT 5
44633: PUSH
44634: EMPTY
44635: LIST
44636: LIST
44637: PUSH
44638: LD_INT 1
44640: NEG
44641: PUSH
44642: LD_INT 4
44644: PUSH
44645: EMPTY
44646: LIST
44647: LIST
44648: PUSH
44649: LD_INT 1
44651: NEG
44652: PUSH
44653: LD_INT 3
44655: PUSH
44656: EMPTY
44657: LIST
44658: LIST
44659: PUSH
44660: LD_INT 2
44662: PUSH
44663: LD_INT 5
44665: PUSH
44666: EMPTY
44667: LIST
44668: LIST
44669: PUSH
44670: LD_INT 2
44672: NEG
44673: PUSH
44674: LD_INT 3
44676: PUSH
44677: EMPTY
44678: LIST
44679: LIST
44680: PUSH
44681: LD_INT 3
44683: NEG
44684: PUSH
44685: LD_INT 0
44687: PUSH
44688: EMPTY
44689: LIST
44690: LIST
44691: PUSH
44692: LD_INT 3
44694: NEG
44695: PUSH
44696: LD_INT 1
44698: NEG
44699: PUSH
44700: EMPTY
44701: LIST
44702: LIST
44703: PUSH
44704: LD_INT 2
44706: NEG
44707: PUSH
44708: LD_INT 0
44710: PUSH
44711: EMPTY
44712: LIST
44713: LIST
44714: PUSH
44715: LD_INT 2
44717: NEG
44718: PUSH
44719: LD_INT 1
44721: PUSH
44722: EMPTY
44723: LIST
44724: LIST
44725: PUSH
44726: LD_INT 3
44728: NEG
44729: PUSH
44730: LD_INT 1
44732: PUSH
44733: EMPTY
44734: LIST
44735: LIST
44736: PUSH
44737: LD_INT 4
44739: NEG
44740: PUSH
44741: LD_INT 0
44743: PUSH
44744: EMPTY
44745: LIST
44746: LIST
44747: PUSH
44748: LD_INT 4
44750: NEG
44751: PUSH
44752: LD_INT 1
44754: NEG
44755: PUSH
44756: EMPTY
44757: LIST
44758: LIST
44759: PUSH
44760: LD_INT 4
44762: NEG
44763: PUSH
44764: LD_INT 2
44766: NEG
44767: PUSH
44768: EMPTY
44769: LIST
44770: LIST
44771: PUSH
44772: LD_INT 2
44774: NEG
44775: PUSH
44776: LD_INT 2
44778: PUSH
44779: EMPTY
44780: LIST
44781: LIST
44782: PUSH
44783: LD_INT 4
44785: NEG
44786: PUSH
44787: LD_INT 4
44789: NEG
44790: PUSH
44791: EMPTY
44792: LIST
44793: LIST
44794: PUSH
44795: LD_INT 4
44797: NEG
44798: PUSH
44799: LD_INT 5
44801: NEG
44802: PUSH
44803: EMPTY
44804: LIST
44805: LIST
44806: PUSH
44807: LD_INT 3
44809: NEG
44810: PUSH
44811: LD_INT 4
44813: NEG
44814: PUSH
44815: EMPTY
44816: LIST
44817: LIST
44818: PUSH
44819: LD_INT 3
44821: NEG
44822: PUSH
44823: LD_INT 3
44825: NEG
44826: PUSH
44827: EMPTY
44828: LIST
44829: LIST
44830: PUSH
44831: LD_INT 4
44833: NEG
44834: PUSH
44835: LD_INT 3
44837: NEG
44838: PUSH
44839: EMPTY
44840: LIST
44841: LIST
44842: PUSH
44843: LD_INT 5
44845: NEG
44846: PUSH
44847: LD_INT 4
44849: NEG
44850: PUSH
44851: EMPTY
44852: LIST
44853: LIST
44854: PUSH
44855: LD_INT 5
44857: NEG
44858: PUSH
44859: LD_INT 5
44861: NEG
44862: PUSH
44863: EMPTY
44864: LIST
44865: LIST
44866: PUSH
44867: LD_INT 3
44869: NEG
44870: PUSH
44871: LD_INT 5
44873: NEG
44874: PUSH
44875: EMPTY
44876: LIST
44877: LIST
44878: PUSH
44879: LD_INT 5
44881: NEG
44882: PUSH
44883: LD_INT 3
44885: NEG
44886: PUSH
44887: EMPTY
44888: LIST
44889: LIST
44890: PUSH
44891: LD_INT 0
44893: PUSH
44894: LD_INT 3
44896: NEG
44897: PUSH
44898: EMPTY
44899: LIST
44900: LIST
44901: PUSH
44902: LD_INT 0
44904: PUSH
44905: LD_INT 4
44907: NEG
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: PUSH
44913: LD_INT 1
44915: PUSH
44916: LD_INT 3
44918: NEG
44919: PUSH
44920: EMPTY
44921: LIST
44922: LIST
44923: PUSH
44924: LD_INT 1
44926: PUSH
44927: LD_INT 2
44929: NEG
44930: PUSH
44931: EMPTY
44932: LIST
44933: LIST
44934: PUSH
44935: LD_INT 0
44937: PUSH
44938: LD_INT 2
44940: NEG
44941: PUSH
44942: EMPTY
44943: LIST
44944: LIST
44945: PUSH
44946: LD_INT 1
44948: NEG
44949: PUSH
44950: LD_INT 3
44952: NEG
44953: PUSH
44954: EMPTY
44955: LIST
44956: LIST
44957: PUSH
44958: LD_INT 1
44960: NEG
44961: PUSH
44962: LD_INT 4
44964: NEG
44965: PUSH
44966: EMPTY
44967: LIST
44968: LIST
44969: PUSH
44970: LD_INT 2
44972: PUSH
44973: LD_INT 2
44975: NEG
44976: PUSH
44977: EMPTY
44978: LIST
44979: LIST
44980: PUSH
44981: LD_INT 2
44983: NEG
44984: PUSH
44985: LD_INT 4
44987: NEG
44988: PUSH
44989: EMPTY
44990: LIST
44991: LIST
44992: PUSH
44993: LD_INT 4
44995: PUSH
44996: LD_INT 0
44998: PUSH
44999: EMPTY
45000: LIST
45001: LIST
45002: PUSH
45003: LD_INT 4
45005: PUSH
45006: LD_INT 1
45008: NEG
45009: PUSH
45010: EMPTY
45011: LIST
45012: LIST
45013: PUSH
45014: LD_INT 5
45016: PUSH
45017: LD_INT 0
45019: PUSH
45020: EMPTY
45021: LIST
45022: LIST
45023: PUSH
45024: LD_INT 5
45026: PUSH
45027: LD_INT 1
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PUSH
45034: LD_INT 4
45036: PUSH
45037: LD_INT 1
45039: PUSH
45040: EMPTY
45041: LIST
45042: LIST
45043: PUSH
45044: LD_INT 3
45046: PUSH
45047: LD_INT 0
45049: PUSH
45050: EMPTY
45051: LIST
45052: LIST
45053: PUSH
45054: LD_INT 3
45056: PUSH
45057: LD_INT 1
45059: NEG
45060: PUSH
45061: EMPTY
45062: LIST
45063: LIST
45064: PUSH
45065: LD_INT 3
45067: PUSH
45068: LD_INT 2
45070: NEG
45071: PUSH
45072: EMPTY
45073: LIST
45074: LIST
45075: PUSH
45076: LD_INT 5
45078: PUSH
45079: LD_INT 2
45081: PUSH
45082: EMPTY
45083: LIST
45084: LIST
45085: PUSH
45086: EMPTY
45087: LIST
45088: LIST
45089: LIST
45090: LIST
45091: LIST
45092: LIST
45093: LIST
45094: LIST
45095: LIST
45096: LIST
45097: LIST
45098: LIST
45099: LIST
45100: LIST
45101: LIST
45102: LIST
45103: LIST
45104: LIST
45105: LIST
45106: LIST
45107: LIST
45108: LIST
45109: LIST
45110: LIST
45111: LIST
45112: LIST
45113: LIST
45114: LIST
45115: LIST
45116: LIST
45117: LIST
45118: LIST
45119: LIST
45120: LIST
45121: LIST
45122: LIST
45123: LIST
45124: LIST
45125: LIST
45126: LIST
45127: LIST
45128: LIST
45129: LIST
45130: LIST
45131: LIST
45132: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45133: LD_ADDR_VAR 0 32
45137: PUSH
45138: LD_INT 4
45140: NEG
45141: PUSH
45142: LD_INT 0
45144: PUSH
45145: EMPTY
45146: LIST
45147: LIST
45148: PUSH
45149: LD_INT 4
45151: NEG
45152: PUSH
45153: LD_INT 1
45155: NEG
45156: PUSH
45157: EMPTY
45158: LIST
45159: LIST
45160: PUSH
45161: LD_INT 3
45163: NEG
45164: PUSH
45165: LD_INT 0
45167: PUSH
45168: EMPTY
45169: LIST
45170: LIST
45171: PUSH
45172: LD_INT 3
45174: NEG
45175: PUSH
45176: LD_INT 1
45178: PUSH
45179: EMPTY
45180: LIST
45181: LIST
45182: PUSH
45183: LD_INT 4
45185: NEG
45186: PUSH
45187: LD_INT 1
45189: PUSH
45190: EMPTY
45191: LIST
45192: LIST
45193: PUSH
45194: LD_INT 5
45196: NEG
45197: PUSH
45198: LD_INT 0
45200: PUSH
45201: EMPTY
45202: LIST
45203: LIST
45204: PUSH
45205: LD_INT 5
45207: NEG
45208: PUSH
45209: LD_INT 1
45211: NEG
45212: PUSH
45213: EMPTY
45214: LIST
45215: LIST
45216: PUSH
45217: LD_INT 5
45219: NEG
45220: PUSH
45221: LD_INT 2
45223: NEG
45224: PUSH
45225: EMPTY
45226: LIST
45227: LIST
45228: PUSH
45229: LD_INT 3
45231: NEG
45232: PUSH
45233: LD_INT 2
45235: PUSH
45236: EMPTY
45237: LIST
45238: LIST
45239: PUSH
45240: LD_INT 3
45242: NEG
45243: PUSH
45244: LD_INT 3
45246: NEG
45247: PUSH
45248: EMPTY
45249: LIST
45250: LIST
45251: PUSH
45252: LD_INT 3
45254: NEG
45255: PUSH
45256: LD_INT 4
45258: NEG
45259: PUSH
45260: EMPTY
45261: LIST
45262: LIST
45263: PUSH
45264: LD_INT 2
45266: NEG
45267: PUSH
45268: LD_INT 3
45270: NEG
45271: PUSH
45272: EMPTY
45273: LIST
45274: LIST
45275: PUSH
45276: LD_INT 2
45278: NEG
45279: PUSH
45280: LD_INT 2
45282: NEG
45283: PUSH
45284: EMPTY
45285: LIST
45286: LIST
45287: PUSH
45288: LD_INT 3
45290: NEG
45291: PUSH
45292: LD_INT 2
45294: NEG
45295: PUSH
45296: EMPTY
45297: LIST
45298: LIST
45299: PUSH
45300: LD_INT 4
45302: NEG
45303: PUSH
45304: LD_INT 3
45306: NEG
45307: PUSH
45308: EMPTY
45309: LIST
45310: LIST
45311: PUSH
45312: LD_INT 4
45314: NEG
45315: PUSH
45316: LD_INT 4
45318: NEG
45319: PUSH
45320: EMPTY
45321: LIST
45322: LIST
45323: PUSH
45324: LD_INT 2
45326: NEG
45327: PUSH
45328: LD_INT 4
45330: NEG
45331: PUSH
45332: EMPTY
45333: LIST
45334: LIST
45335: PUSH
45336: LD_INT 4
45338: NEG
45339: PUSH
45340: LD_INT 2
45342: NEG
45343: PUSH
45344: EMPTY
45345: LIST
45346: LIST
45347: PUSH
45348: LD_INT 0
45350: PUSH
45351: LD_INT 4
45353: NEG
45354: PUSH
45355: EMPTY
45356: LIST
45357: LIST
45358: PUSH
45359: LD_INT 0
45361: PUSH
45362: LD_INT 5
45364: NEG
45365: PUSH
45366: EMPTY
45367: LIST
45368: LIST
45369: PUSH
45370: LD_INT 1
45372: PUSH
45373: LD_INT 4
45375: NEG
45376: PUSH
45377: EMPTY
45378: LIST
45379: LIST
45380: PUSH
45381: LD_INT 1
45383: PUSH
45384: LD_INT 3
45386: NEG
45387: PUSH
45388: EMPTY
45389: LIST
45390: LIST
45391: PUSH
45392: LD_INT 0
45394: PUSH
45395: LD_INT 3
45397: NEG
45398: PUSH
45399: EMPTY
45400: LIST
45401: LIST
45402: PUSH
45403: LD_INT 1
45405: NEG
45406: PUSH
45407: LD_INT 4
45409: NEG
45410: PUSH
45411: EMPTY
45412: LIST
45413: LIST
45414: PUSH
45415: LD_INT 1
45417: NEG
45418: PUSH
45419: LD_INT 5
45421: NEG
45422: PUSH
45423: EMPTY
45424: LIST
45425: LIST
45426: PUSH
45427: LD_INT 2
45429: PUSH
45430: LD_INT 3
45432: NEG
45433: PUSH
45434: EMPTY
45435: LIST
45436: LIST
45437: PUSH
45438: LD_INT 2
45440: NEG
45441: PUSH
45442: LD_INT 5
45444: NEG
45445: PUSH
45446: EMPTY
45447: LIST
45448: LIST
45449: PUSH
45450: LD_INT 3
45452: PUSH
45453: LD_INT 0
45455: PUSH
45456: EMPTY
45457: LIST
45458: LIST
45459: PUSH
45460: LD_INT 3
45462: PUSH
45463: LD_INT 1
45465: NEG
45466: PUSH
45467: EMPTY
45468: LIST
45469: LIST
45470: PUSH
45471: LD_INT 4
45473: PUSH
45474: LD_INT 0
45476: PUSH
45477: EMPTY
45478: LIST
45479: LIST
45480: PUSH
45481: LD_INT 4
45483: PUSH
45484: LD_INT 1
45486: PUSH
45487: EMPTY
45488: LIST
45489: LIST
45490: PUSH
45491: LD_INT 3
45493: PUSH
45494: LD_INT 1
45496: PUSH
45497: EMPTY
45498: LIST
45499: LIST
45500: PUSH
45501: LD_INT 2
45503: PUSH
45504: LD_INT 0
45506: PUSH
45507: EMPTY
45508: LIST
45509: LIST
45510: PUSH
45511: LD_INT 2
45513: PUSH
45514: LD_INT 1
45516: NEG
45517: PUSH
45518: EMPTY
45519: LIST
45520: LIST
45521: PUSH
45522: LD_INT 2
45524: PUSH
45525: LD_INT 2
45527: NEG
45528: PUSH
45529: EMPTY
45530: LIST
45531: LIST
45532: PUSH
45533: LD_INT 4
45535: PUSH
45536: LD_INT 2
45538: PUSH
45539: EMPTY
45540: LIST
45541: LIST
45542: PUSH
45543: LD_INT 4
45545: PUSH
45546: LD_INT 4
45548: PUSH
45549: EMPTY
45550: LIST
45551: LIST
45552: PUSH
45553: LD_INT 4
45555: PUSH
45556: LD_INT 3
45558: PUSH
45559: EMPTY
45560: LIST
45561: LIST
45562: PUSH
45563: LD_INT 5
45565: PUSH
45566: LD_INT 4
45568: PUSH
45569: EMPTY
45570: LIST
45571: LIST
45572: PUSH
45573: LD_INT 5
45575: PUSH
45576: LD_INT 5
45578: PUSH
45579: EMPTY
45580: LIST
45581: LIST
45582: PUSH
45583: LD_INT 4
45585: PUSH
45586: LD_INT 5
45588: PUSH
45589: EMPTY
45590: LIST
45591: LIST
45592: PUSH
45593: LD_INT 3
45595: PUSH
45596: LD_INT 4
45598: PUSH
45599: EMPTY
45600: LIST
45601: LIST
45602: PUSH
45603: LD_INT 3
45605: PUSH
45606: LD_INT 3
45608: PUSH
45609: EMPTY
45610: LIST
45611: LIST
45612: PUSH
45613: LD_INT 5
45615: PUSH
45616: LD_INT 3
45618: PUSH
45619: EMPTY
45620: LIST
45621: LIST
45622: PUSH
45623: LD_INT 3
45625: PUSH
45626: LD_INT 5
45628: PUSH
45629: EMPTY
45630: LIST
45631: LIST
45632: PUSH
45633: EMPTY
45634: LIST
45635: LIST
45636: LIST
45637: LIST
45638: LIST
45639: LIST
45640: LIST
45641: LIST
45642: LIST
45643: LIST
45644: LIST
45645: LIST
45646: LIST
45647: LIST
45648: LIST
45649: LIST
45650: LIST
45651: LIST
45652: LIST
45653: LIST
45654: LIST
45655: LIST
45656: LIST
45657: LIST
45658: LIST
45659: LIST
45660: LIST
45661: LIST
45662: LIST
45663: LIST
45664: LIST
45665: LIST
45666: LIST
45667: LIST
45668: LIST
45669: LIST
45670: LIST
45671: LIST
45672: LIST
45673: LIST
45674: LIST
45675: LIST
45676: LIST
45677: LIST
45678: LIST
45679: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45680: LD_ADDR_VAR 0 33
45684: PUSH
45685: LD_INT 4
45687: NEG
45688: PUSH
45689: LD_INT 4
45691: NEG
45692: PUSH
45693: EMPTY
45694: LIST
45695: LIST
45696: PUSH
45697: LD_INT 4
45699: NEG
45700: PUSH
45701: LD_INT 5
45703: NEG
45704: PUSH
45705: EMPTY
45706: LIST
45707: LIST
45708: PUSH
45709: LD_INT 3
45711: NEG
45712: PUSH
45713: LD_INT 4
45715: NEG
45716: PUSH
45717: EMPTY
45718: LIST
45719: LIST
45720: PUSH
45721: LD_INT 3
45723: NEG
45724: PUSH
45725: LD_INT 3
45727: NEG
45728: PUSH
45729: EMPTY
45730: LIST
45731: LIST
45732: PUSH
45733: LD_INT 4
45735: NEG
45736: PUSH
45737: LD_INT 3
45739: NEG
45740: PUSH
45741: EMPTY
45742: LIST
45743: LIST
45744: PUSH
45745: LD_INT 5
45747: NEG
45748: PUSH
45749: LD_INT 4
45751: NEG
45752: PUSH
45753: EMPTY
45754: LIST
45755: LIST
45756: PUSH
45757: LD_INT 5
45759: NEG
45760: PUSH
45761: LD_INT 5
45763: NEG
45764: PUSH
45765: EMPTY
45766: LIST
45767: LIST
45768: PUSH
45769: LD_INT 3
45771: NEG
45772: PUSH
45773: LD_INT 5
45775: NEG
45776: PUSH
45777: EMPTY
45778: LIST
45779: LIST
45780: PUSH
45781: LD_INT 5
45783: NEG
45784: PUSH
45785: LD_INT 3
45787: NEG
45788: PUSH
45789: EMPTY
45790: LIST
45791: LIST
45792: PUSH
45793: LD_INT 0
45795: PUSH
45796: LD_INT 3
45798: NEG
45799: PUSH
45800: EMPTY
45801: LIST
45802: LIST
45803: PUSH
45804: LD_INT 0
45806: PUSH
45807: LD_INT 4
45809: NEG
45810: PUSH
45811: EMPTY
45812: LIST
45813: LIST
45814: PUSH
45815: LD_INT 1
45817: PUSH
45818: LD_INT 3
45820: NEG
45821: PUSH
45822: EMPTY
45823: LIST
45824: LIST
45825: PUSH
45826: LD_INT 1
45828: PUSH
45829: LD_INT 2
45831: NEG
45832: PUSH
45833: EMPTY
45834: LIST
45835: LIST
45836: PUSH
45837: LD_INT 0
45839: PUSH
45840: LD_INT 2
45842: NEG
45843: PUSH
45844: EMPTY
45845: LIST
45846: LIST
45847: PUSH
45848: LD_INT 1
45850: NEG
45851: PUSH
45852: LD_INT 3
45854: NEG
45855: PUSH
45856: EMPTY
45857: LIST
45858: LIST
45859: PUSH
45860: LD_INT 1
45862: NEG
45863: PUSH
45864: LD_INT 4
45866: NEG
45867: PUSH
45868: EMPTY
45869: LIST
45870: LIST
45871: PUSH
45872: LD_INT 2
45874: PUSH
45875: LD_INT 2
45877: NEG
45878: PUSH
45879: EMPTY
45880: LIST
45881: LIST
45882: PUSH
45883: LD_INT 2
45885: NEG
45886: PUSH
45887: LD_INT 4
45889: NEG
45890: PUSH
45891: EMPTY
45892: LIST
45893: LIST
45894: PUSH
45895: LD_INT 4
45897: PUSH
45898: LD_INT 0
45900: PUSH
45901: EMPTY
45902: LIST
45903: LIST
45904: PUSH
45905: LD_INT 4
45907: PUSH
45908: LD_INT 1
45910: NEG
45911: PUSH
45912: EMPTY
45913: LIST
45914: LIST
45915: PUSH
45916: LD_INT 5
45918: PUSH
45919: LD_INT 0
45921: PUSH
45922: EMPTY
45923: LIST
45924: LIST
45925: PUSH
45926: LD_INT 5
45928: PUSH
45929: LD_INT 1
45931: PUSH
45932: EMPTY
45933: LIST
45934: LIST
45935: PUSH
45936: LD_INT 4
45938: PUSH
45939: LD_INT 1
45941: PUSH
45942: EMPTY
45943: LIST
45944: LIST
45945: PUSH
45946: LD_INT 3
45948: PUSH
45949: LD_INT 0
45951: PUSH
45952: EMPTY
45953: LIST
45954: LIST
45955: PUSH
45956: LD_INT 3
45958: PUSH
45959: LD_INT 1
45961: NEG
45962: PUSH
45963: EMPTY
45964: LIST
45965: LIST
45966: PUSH
45967: LD_INT 3
45969: PUSH
45970: LD_INT 2
45972: NEG
45973: PUSH
45974: EMPTY
45975: LIST
45976: LIST
45977: PUSH
45978: LD_INT 5
45980: PUSH
45981: LD_INT 2
45983: PUSH
45984: EMPTY
45985: LIST
45986: LIST
45987: PUSH
45988: LD_INT 3
45990: PUSH
45991: LD_INT 3
45993: PUSH
45994: EMPTY
45995: LIST
45996: LIST
45997: PUSH
45998: LD_INT 3
46000: PUSH
46001: LD_INT 2
46003: PUSH
46004: EMPTY
46005: LIST
46006: LIST
46007: PUSH
46008: LD_INT 4
46010: PUSH
46011: LD_INT 3
46013: PUSH
46014: EMPTY
46015: LIST
46016: LIST
46017: PUSH
46018: LD_INT 4
46020: PUSH
46021: LD_INT 4
46023: PUSH
46024: EMPTY
46025: LIST
46026: LIST
46027: PUSH
46028: LD_INT 3
46030: PUSH
46031: LD_INT 4
46033: PUSH
46034: EMPTY
46035: LIST
46036: LIST
46037: PUSH
46038: LD_INT 2
46040: PUSH
46041: LD_INT 3
46043: PUSH
46044: EMPTY
46045: LIST
46046: LIST
46047: PUSH
46048: LD_INT 2
46050: PUSH
46051: LD_INT 2
46053: PUSH
46054: EMPTY
46055: LIST
46056: LIST
46057: PUSH
46058: LD_INT 4
46060: PUSH
46061: LD_INT 2
46063: PUSH
46064: EMPTY
46065: LIST
46066: LIST
46067: PUSH
46068: LD_INT 2
46070: PUSH
46071: LD_INT 4
46073: PUSH
46074: EMPTY
46075: LIST
46076: LIST
46077: PUSH
46078: LD_INT 0
46080: PUSH
46081: LD_INT 4
46083: PUSH
46084: EMPTY
46085: LIST
46086: LIST
46087: PUSH
46088: LD_INT 0
46090: PUSH
46091: LD_INT 3
46093: PUSH
46094: EMPTY
46095: LIST
46096: LIST
46097: PUSH
46098: LD_INT 1
46100: PUSH
46101: LD_INT 4
46103: PUSH
46104: EMPTY
46105: LIST
46106: LIST
46107: PUSH
46108: LD_INT 1
46110: PUSH
46111: LD_INT 5
46113: PUSH
46114: EMPTY
46115: LIST
46116: LIST
46117: PUSH
46118: LD_INT 0
46120: PUSH
46121: LD_INT 5
46123: PUSH
46124: EMPTY
46125: LIST
46126: LIST
46127: PUSH
46128: LD_INT 1
46130: NEG
46131: PUSH
46132: LD_INT 4
46134: PUSH
46135: EMPTY
46136: LIST
46137: LIST
46138: PUSH
46139: LD_INT 1
46141: NEG
46142: PUSH
46143: LD_INT 3
46145: PUSH
46146: EMPTY
46147: LIST
46148: LIST
46149: PUSH
46150: LD_INT 2
46152: PUSH
46153: LD_INT 5
46155: PUSH
46156: EMPTY
46157: LIST
46158: LIST
46159: PUSH
46160: LD_INT 2
46162: NEG
46163: PUSH
46164: LD_INT 3
46166: PUSH
46167: EMPTY
46168: LIST
46169: LIST
46170: PUSH
46171: EMPTY
46172: LIST
46173: LIST
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: LIST
46181: LIST
46182: LIST
46183: LIST
46184: LIST
46185: LIST
46186: LIST
46187: LIST
46188: LIST
46189: LIST
46190: LIST
46191: LIST
46192: LIST
46193: LIST
46194: LIST
46195: LIST
46196: LIST
46197: LIST
46198: LIST
46199: LIST
46200: LIST
46201: LIST
46202: LIST
46203: LIST
46204: LIST
46205: LIST
46206: LIST
46207: LIST
46208: LIST
46209: LIST
46210: LIST
46211: LIST
46212: LIST
46213: LIST
46214: LIST
46215: LIST
46216: LIST
46217: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46218: LD_ADDR_VAR 0 34
46222: PUSH
46223: LD_INT 0
46225: PUSH
46226: LD_INT 4
46228: NEG
46229: PUSH
46230: EMPTY
46231: LIST
46232: LIST
46233: PUSH
46234: LD_INT 0
46236: PUSH
46237: LD_INT 5
46239: NEG
46240: PUSH
46241: EMPTY
46242: LIST
46243: LIST
46244: PUSH
46245: LD_INT 1
46247: PUSH
46248: LD_INT 4
46250: NEG
46251: PUSH
46252: EMPTY
46253: LIST
46254: LIST
46255: PUSH
46256: LD_INT 1
46258: PUSH
46259: LD_INT 3
46261: NEG
46262: PUSH
46263: EMPTY
46264: LIST
46265: LIST
46266: PUSH
46267: LD_INT 0
46269: PUSH
46270: LD_INT 3
46272: NEG
46273: PUSH
46274: EMPTY
46275: LIST
46276: LIST
46277: PUSH
46278: LD_INT 1
46280: NEG
46281: PUSH
46282: LD_INT 4
46284: NEG
46285: PUSH
46286: EMPTY
46287: LIST
46288: LIST
46289: PUSH
46290: LD_INT 1
46292: NEG
46293: PUSH
46294: LD_INT 5
46296: NEG
46297: PUSH
46298: EMPTY
46299: LIST
46300: LIST
46301: PUSH
46302: LD_INT 2
46304: PUSH
46305: LD_INT 3
46307: NEG
46308: PUSH
46309: EMPTY
46310: LIST
46311: LIST
46312: PUSH
46313: LD_INT 2
46315: NEG
46316: PUSH
46317: LD_INT 5
46319: NEG
46320: PUSH
46321: EMPTY
46322: LIST
46323: LIST
46324: PUSH
46325: LD_INT 3
46327: PUSH
46328: LD_INT 0
46330: PUSH
46331: EMPTY
46332: LIST
46333: LIST
46334: PUSH
46335: LD_INT 3
46337: PUSH
46338: LD_INT 1
46340: NEG
46341: PUSH
46342: EMPTY
46343: LIST
46344: LIST
46345: PUSH
46346: LD_INT 4
46348: PUSH
46349: LD_INT 0
46351: PUSH
46352: EMPTY
46353: LIST
46354: LIST
46355: PUSH
46356: LD_INT 4
46358: PUSH
46359: LD_INT 1
46361: PUSH
46362: EMPTY
46363: LIST
46364: LIST
46365: PUSH
46366: LD_INT 3
46368: PUSH
46369: LD_INT 1
46371: PUSH
46372: EMPTY
46373: LIST
46374: LIST
46375: PUSH
46376: LD_INT 2
46378: PUSH
46379: LD_INT 0
46381: PUSH
46382: EMPTY
46383: LIST
46384: LIST
46385: PUSH
46386: LD_INT 2
46388: PUSH
46389: LD_INT 1
46391: NEG
46392: PUSH
46393: EMPTY
46394: LIST
46395: LIST
46396: PUSH
46397: LD_INT 2
46399: PUSH
46400: LD_INT 2
46402: NEG
46403: PUSH
46404: EMPTY
46405: LIST
46406: LIST
46407: PUSH
46408: LD_INT 4
46410: PUSH
46411: LD_INT 2
46413: PUSH
46414: EMPTY
46415: LIST
46416: LIST
46417: PUSH
46418: LD_INT 4
46420: PUSH
46421: LD_INT 4
46423: PUSH
46424: EMPTY
46425: LIST
46426: LIST
46427: PUSH
46428: LD_INT 4
46430: PUSH
46431: LD_INT 3
46433: PUSH
46434: EMPTY
46435: LIST
46436: LIST
46437: PUSH
46438: LD_INT 5
46440: PUSH
46441: LD_INT 4
46443: PUSH
46444: EMPTY
46445: LIST
46446: LIST
46447: PUSH
46448: LD_INT 5
46450: PUSH
46451: LD_INT 5
46453: PUSH
46454: EMPTY
46455: LIST
46456: LIST
46457: PUSH
46458: LD_INT 4
46460: PUSH
46461: LD_INT 5
46463: PUSH
46464: EMPTY
46465: LIST
46466: LIST
46467: PUSH
46468: LD_INT 3
46470: PUSH
46471: LD_INT 4
46473: PUSH
46474: EMPTY
46475: LIST
46476: LIST
46477: PUSH
46478: LD_INT 3
46480: PUSH
46481: LD_INT 3
46483: PUSH
46484: EMPTY
46485: LIST
46486: LIST
46487: PUSH
46488: LD_INT 5
46490: PUSH
46491: LD_INT 3
46493: PUSH
46494: EMPTY
46495: LIST
46496: LIST
46497: PUSH
46498: LD_INT 3
46500: PUSH
46501: LD_INT 5
46503: PUSH
46504: EMPTY
46505: LIST
46506: LIST
46507: PUSH
46508: LD_INT 0
46510: PUSH
46511: LD_INT 3
46513: PUSH
46514: EMPTY
46515: LIST
46516: LIST
46517: PUSH
46518: LD_INT 0
46520: PUSH
46521: LD_INT 2
46523: PUSH
46524: EMPTY
46525: LIST
46526: LIST
46527: PUSH
46528: LD_INT 1
46530: PUSH
46531: LD_INT 3
46533: PUSH
46534: EMPTY
46535: LIST
46536: LIST
46537: PUSH
46538: LD_INT 1
46540: PUSH
46541: LD_INT 4
46543: PUSH
46544: EMPTY
46545: LIST
46546: LIST
46547: PUSH
46548: LD_INT 0
46550: PUSH
46551: LD_INT 4
46553: PUSH
46554: EMPTY
46555: LIST
46556: LIST
46557: PUSH
46558: LD_INT 1
46560: NEG
46561: PUSH
46562: LD_INT 3
46564: PUSH
46565: EMPTY
46566: LIST
46567: LIST
46568: PUSH
46569: LD_INT 1
46571: NEG
46572: PUSH
46573: LD_INT 2
46575: PUSH
46576: EMPTY
46577: LIST
46578: LIST
46579: PUSH
46580: LD_INT 2
46582: PUSH
46583: LD_INT 4
46585: PUSH
46586: EMPTY
46587: LIST
46588: LIST
46589: PUSH
46590: LD_INT 2
46592: NEG
46593: PUSH
46594: LD_INT 2
46596: PUSH
46597: EMPTY
46598: LIST
46599: LIST
46600: PUSH
46601: LD_INT 4
46603: NEG
46604: PUSH
46605: LD_INT 0
46607: PUSH
46608: EMPTY
46609: LIST
46610: LIST
46611: PUSH
46612: LD_INT 4
46614: NEG
46615: PUSH
46616: LD_INT 1
46618: NEG
46619: PUSH
46620: EMPTY
46621: LIST
46622: LIST
46623: PUSH
46624: LD_INT 3
46626: NEG
46627: PUSH
46628: LD_INT 0
46630: PUSH
46631: EMPTY
46632: LIST
46633: LIST
46634: PUSH
46635: LD_INT 3
46637: NEG
46638: PUSH
46639: LD_INT 1
46641: PUSH
46642: EMPTY
46643: LIST
46644: LIST
46645: PUSH
46646: LD_INT 4
46648: NEG
46649: PUSH
46650: LD_INT 1
46652: PUSH
46653: EMPTY
46654: LIST
46655: LIST
46656: PUSH
46657: LD_INT 5
46659: NEG
46660: PUSH
46661: LD_INT 0
46663: PUSH
46664: EMPTY
46665: LIST
46666: LIST
46667: PUSH
46668: LD_INT 5
46670: NEG
46671: PUSH
46672: LD_INT 1
46674: NEG
46675: PUSH
46676: EMPTY
46677: LIST
46678: LIST
46679: PUSH
46680: LD_INT 5
46682: NEG
46683: PUSH
46684: LD_INT 2
46686: NEG
46687: PUSH
46688: EMPTY
46689: LIST
46690: LIST
46691: PUSH
46692: LD_INT 3
46694: NEG
46695: PUSH
46696: LD_INT 2
46698: PUSH
46699: EMPTY
46700: LIST
46701: LIST
46702: PUSH
46703: EMPTY
46704: LIST
46705: LIST
46706: LIST
46707: LIST
46708: LIST
46709: LIST
46710: LIST
46711: LIST
46712: LIST
46713: LIST
46714: LIST
46715: LIST
46716: LIST
46717: LIST
46718: LIST
46719: LIST
46720: LIST
46721: LIST
46722: LIST
46723: LIST
46724: LIST
46725: LIST
46726: LIST
46727: LIST
46728: LIST
46729: LIST
46730: LIST
46731: LIST
46732: LIST
46733: LIST
46734: LIST
46735: LIST
46736: LIST
46737: LIST
46738: LIST
46739: LIST
46740: LIST
46741: LIST
46742: LIST
46743: LIST
46744: LIST
46745: LIST
46746: LIST
46747: LIST
46748: LIST
46749: ST_TO_ADDR
// end ; end ;
46750: GO 46753
46752: POP
// case btype of b_depot , b_warehouse :
46753: LD_VAR 0 1
46757: PUSH
46758: LD_INT 0
46760: DOUBLE
46761: EQUAL
46762: IFTRUE 46772
46764: LD_INT 1
46766: DOUBLE
46767: EQUAL
46768: IFTRUE 46772
46770: GO 46973
46772: POP
// case nation of nation_american :
46773: LD_VAR 0 5
46777: PUSH
46778: LD_INT 1
46780: DOUBLE
46781: EQUAL
46782: IFTRUE 46786
46784: GO 46842
46786: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
46787: LD_ADDR_VAR 0 9
46791: PUSH
46792: LD_VAR 0 11
46796: PUSH
46797: LD_VAR 0 12
46801: PUSH
46802: LD_VAR 0 13
46806: PUSH
46807: LD_VAR 0 14
46811: PUSH
46812: LD_VAR 0 15
46816: PUSH
46817: LD_VAR 0 16
46821: PUSH
46822: EMPTY
46823: LIST
46824: LIST
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: PUSH
46830: LD_VAR 0 4
46834: PUSH
46835: LD_INT 1
46837: PLUS
46838: ARRAY
46839: ST_TO_ADDR
46840: GO 46971
46842: LD_INT 2
46844: DOUBLE
46845: EQUAL
46846: IFTRUE 46850
46848: GO 46906
46850: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
46851: LD_ADDR_VAR 0 9
46855: PUSH
46856: LD_VAR 0 17
46860: PUSH
46861: LD_VAR 0 18
46865: PUSH
46866: LD_VAR 0 19
46870: PUSH
46871: LD_VAR 0 20
46875: PUSH
46876: LD_VAR 0 21
46880: PUSH
46881: LD_VAR 0 22
46885: PUSH
46886: EMPTY
46887: LIST
46888: LIST
46889: LIST
46890: LIST
46891: LIST
46892: LIST
46893: PUSH
46894: LD_VAR 0 4
46898: PUSH
46899: LD_INT 1
46901: PLUS
46902: ARRAY
46903: ST_TO_ADDR
46904: GO 46971
46906: LD_INT 3
46908: DOUBLE
46909: EQUAL
46910: IFTRUE 46914
46912: GO 46970
46914: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46915: LD_ADDR_VAR 0 9
46919: PUSH
46920: LD_VAR 0 23
46924: PUSH
46925: LD_VAR 0 24
46929: PUSH
46930: LD_VAR 0 25
46934: PUSH
46935: LD_VAR 0 26
46939: PUSH
46940: LD_VAR 0 27
46944: PUSH
46945: LD_VAR 0 28
46949: PUSH
46950: EMPTY
46951: LIST
46952: LIST
46953: LIST
46954: LIST
46955: LIST
46956: LIST
46957: PUSH
46958: LD_VAR 0 4
46962: PUSH
46963: LD_INT 1
46965: PLUS
46966: ARRAY
46967: ST_TO_ADDR
46968: GO 46971
46970: POP
46971: GO 47526
46973: LD_INT 2
46975: DOUBLE
46976: EQUAL
46977: IFTRUE 46987
46979: LD_INT 3
46981: DOUBLE
46982: EQUAL
46983: IFTRUE 46987
46985: GO 47043
46987: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46988: LD_ADDR_VAR 0 9
46992: PUSH
46993: LD_VAR 0 29
46997: PUSH
46998: LD_VAR 0 30
47002: PUSH
47003: LD_VAR 0 31
47007: PUSH
47008: LD_VAR 0 32
47012: PUSH
47013: LD_VAR 0 33
47017: PUSH
47018: LD_VAR 0 34
47022: PUSH
47023: EMPTY
47024: LIST
47025: LIST
47026: LIST
47027: LIST
47028: LIST
47029: LIST
47030: PUSH
47031: LD_VAR 0 4
47035: PUSH
47036: LD_INT 1
47038: PLUS
47039: ARRAY
47040: ST_TO_ADDR
47041: GO 47526
47043: LD_INT 16
47045: DOUBLE
47046: EQUAL
47047: IFTRUE 47105
47049: LD_INT 17
47051: DOUBLE
47052: EQUAL
47053: IFTRUE 47105
47055: LD_INT 18
47057: DOUBLE
47058: EQUAL
47059: IFTRUE 47105
47061: LD_INT 19
47063: DOUBLE
47064: EQUAL
47065: IFTRUE 47105
47067: LD_INT 22
47069: DOUBLE
47070: EQUAL
47071: IFTRUE 47105
47073: LD_INT 20
47075: DOUBLE
47076: EQUAL
47077: IFTRUE 47105
47079: LD_INT 21
47081: DOUBLE
47082: EQUAL
47083: IFTRUE 47105
47085: LD_INT 23
47087: DOUBLE
47088: EQUAL
47089: IFTRUE 47105
47091: LD_INT 24
47093: DOUBLE
47094: EQUAL
47095: IFTRUE 47105
47097: LD_INT 25
47099: DOUBLE
47100: EQUAL
47101: IFTRUE 47105
47103: GO 47161
47105: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47106: LD_ADDR_VAR 0 9
47110: PUSH
47111: LD_VAR 0 35
47115: PUSH
47116: LD_VAR 0 36
47120: PUSH
47121: LD_VAR 0 37
47125: PUSH
47126: LD_VAR 0 38
47130: PUSH
47131: LD_VAR 0 39
47135: PUSH
47136: LD_VAR 0 40
47140: PUSH
47141: EMPTY
47142: LIST
47143: LIST
47144: LIST
47145: LIST
47146: LIST
47147: LIST
47148: PUSH
47149: LD_VAR 0 4
47153: PUSH
47154: LD_INT 1
47156: PLUS
47157: ARRAY
47158: ST_TO_ADDR
47159: GO 47526
47161: LD_INT 6
47163: DOUBLE
47164: EQUAL
47165: IFTRUE 47217
47167: LD_INT 7
47169: DOUBLE
47170: EQUAL
47171: IFTRUE 47217
47173: LD_INT 8
47175: DOUBLE
47176: EQUAL
47177: IFTRUE 47217
47179: LD_INT 13
47181: DOUBLE
47182: EQUAL
47183: IFTRUE 47217
47185: LD_INT 12
47187: DOUBLE
47188: EQUAL
47189: IFTRUE 47217
47191: LD_INT 15
47193: DOUBLE
47194: EQUAL
47195: IFTRUE 47217
47197: LD_INT 11
47199: DOUBLE
47200: EQUAL
47201: IFTRUE 47217
47203: LD_INT 14
47205: DOUBLE
47206: EQUAL
47207: IFTRUE 47217
47209: LD_INT 10
47211: DOUBLE
47212: EQUAL
47213: IFTRUE 47217
47215: GO 47273
47217: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
47218: LD_ADDR_VAR 0 9
47222: PUSH
47223: LD_VAR 0 41
47227: PUSH
47228: LD_VAR 0 42
47232: PUSH
47233: LD_VAR 0 43
47237: PUSH
47238: LD_VAR 0 44
47242: PUSH
47243: LD_VAR 0 45
47247: PUSH
47248: LD_VAR 0 46
47252: PUSH
47253: EMPTY
47254: LIST
47255: LIST
47256: LIST
47257: LIST
47258: LIST
47259: LIST
47260: PUSH
47261: LD_VAR 0 4
47265: PUSH
47266: LD_INT 1
47268: PLUS
47269: ARRAY
47270: ST_TO_ADDR
47271: GO 47526
47273: LD_INT 36
47275: DOUBLE
47276: EQUAL
47277: IFTRUE 47281
47279: GO 47337
47281: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47282: LD_ADDR_VAR 0 9
47286: PUSH
47287: LD_VAR 0 47
47291: PUSH
47292: LD_VAR 0 48
47296: PUSH
47297: LD_VAR 0 49
47301: PUSH
47302: LD_VAR 0 50
47306: PUSH
47307: LD_VAR 0 51
47311: PUSH
47312: LD_VAR 0 52
47316: PUSH
47317: EMPTY
47318: LIST
47319: LIST
47320: LIST
47321: LIST
47322: LIST
47323: LIST
47324: PUSH
47325: LD_VAR 0 4
47329: PUSH
47330: LD_INT 1
47332: PLUS
47333: ARRAY
47334: ST_TO_ADDR
47335: GO 47526
47337: LD_INT 4
47339: DOUBLE
47340: EQUAL
47341: IFTRUE 47363
47343: LD_INT 5
47345: DOUBLE
47346: EQUAL
47347: IFTRUE 47363
47349: LD_INT 34
47351: DOUBLE
47352: EQUAL
47353: IFTRUE 47363
47355: LD_INT 37
47357: DOUBLE
47358: EQUAL
47359: IFTRUE 47363
47361: GO 47419
47363: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47364: LD_ADDR_VAR 0 9
47368: PUSH
47369: LD_VAR 0 53
47373: PUSH
47374: LD_VAR 0 54
47378: PUSH
47379: LD_VAR 0 55
47383: PUSH
47384: LD_VAR 0 56
47388: PUSH
47389: LD_VAR 0 57
47393: PUSH
47394: LD_VAR 0 58
47398: PUSH
47399: EMPTY
47400: LIST
47401: LIST
47402: LIST
47403: LIST
47404: LIST
47405: LIST
47406: PUSH
47407: LD_VAR 0 4
47411: PUSH
47412: LD_INT 1
47414: PLUS
47415: ARRAY
47416: ST_TO_ADDR
47417: GO 47526
47419: LD_INT 31
47421: DOUBLE
47422: EQUAL
47423: IFTRUE 47469
47425: LD_INT 32
47427: DOUBLE
47428: EQUAL
47429: IFTRUE 47469
47431: LD_INT 33
47433: DOUBLE
47434: EQUAL
47435: IFTRUE 47469
47437: LD_INT 27
47439: DOUBLE
47440: EQUAL
47441: IFTRUE 47469
47443: LD_INT 26
47445: DOUBLE
47446: EQUAL
47447: IFTRUE 47469
47449: LD_INT 28
47451: DOUBLE
47452: EQUAL
47453: IFTRUE 47469
47455: LD_INT 29
47457: DOUBLE
47458: EQUAL
47459: IFTRUE 47469
47461: LD_INT 30
47463: DOUBLE
47464: EQUAL
47465: IFTRUE 47469
47467: GO 47525
47469: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
47470: LD_ADDR_VAR 0 9
47474: PUSH
47475: LD_VAR 0 59
47479: PUSH
47480: LD_VAR 0 60
47484: PUSH
47485: LD_VAR 0 61
47489: PUSH
47490: LD_VAR 0 62
47494: PUSH
47495: LD_VAR 0 63
47499: PUSH
47500: LD_VAR 0 64
47504: PUSH
47505: EMPTY
47506: LIST
47507: LIST
47508: LIST
47509: LIST
47510: LIST
47511: LIST
47512: PUSH
47513: LD_VAR 0 4
47517: PUSH
47518: LD_INT 1
47520: PLUS
47521: ARRAY
47522: ST_TO_ADDR
47523: GO 47526
47525: POP
// temp_list2 = [ ] ;
47526: LD_ADDR_VAR 0 10
47530: PUSH
47531: EMPTY
47532: ST_TO_ADDR
// for i in temp_list do
47533: LD_ADDR_VAR 0 8
47537: PUSH
47538: LD_VAR 0 9
47542: PUSH
47543: FOR_IN
47544: IFFALSE 47596
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47546: LD_ADDR_VAR 0 10
47550: PUSH
47551: LD_VAR 0 10
47555: PUSH
47556: LD_VAR 0 8
47560: PUSH
47561: LD_INT 1
47563: ARRAY
47564: PUSH
47565: LD_VAR 0 2
47569: PLUS
47570: PUSH
47571: LD_VAR 0 8
47575: PUSH
47576: LD_INT 2
47578: ARRAY
47579: PUSH
47580: LD_VAR 0 3
47584: PLUS
47585: PUSH
47586: EMPTY
47587: LIST
47588: LIST
47589: PUSH
47590: EMPTY
47591: LIST
47592: ADD
47593: ST_TO_ADDR
47594: GO 47543
47596: POP
47597: POP
// result = temp_list2 ;
47598: LD_ADDR_VAR 0 7
47602: PUSH
47603: LD_VAR 0 10
47607: ST_TO_ADDR
// end ;
47608: LD_VAR 0 7
47612: RET
// export function EnemyInRange ( unit , dist ) ; begin
47613: LD_INT 0
47615: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47616: LD_ADDR_VAR 0 3
47620: PUSH
47621: LD_VAR 0 1
47625: PPUSH
47626: CALL_OW 255
47630: PPUSH
47631: LD_VAR 0 1
47635: PPUSH
47636: CALL_OW 250
47640: PPUSH
47641: LD_VAR 0 1
47645: PPUSH
47646: CALL_OW 251
47650: PPUSH
47651: LD_VAR 0 2
47655: PPUSH
47656: CALL 21717 0 4
47660: PUSH
47661: LD_INT 4
47663: ARRAY
47664: ST_TO_ADDR
// end ;
47665: LD_VAR 0 3
47669: RET
// export function PlayerSeeMe ( unit ) ; begin
47670: LD_INT 0
47672: PPUSH
// result := See ( your_side , unit ) ;
47673: LD_ADDR_VAR 0 2
47677: PUSH
47678: LD_OWVAR 2
47682: PPUSH
47683: LD_VAR 0 1
47687: PPUSH
47688: CALL_OW 292
47692: ST_TO_ADDR
// end ;
47693: LD_VAR 0 2
47697: RET
// export function ReverseDir ( unit ) ; begin
47698: LD_INT 0
47700: PPUSH
// if not unit then
47701: LD_VAR 0 1
47705: NOT
47706: IFFALSE 47710
// exit ;
47708: GO 47756
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
47710: LD_ADDR_VAR 0 2
47714: PUSH
47715: LD_INT 3
47717: PUSH
47718: LD_INT 4
47720: PUSH
47721: LD_INT 5
47723: PUSH
47724: LD_INT 0
47726: PUSH
47727: LD_INT 1
47729: PUSH
47730: LD_INT 2
47732: PUSH
47733: EMPTY
47734: LIST
47735: LIST
47736: LIST
47737: LIST
47738: LIST
47739: LIST
47740: PUSH
47741: LD_VAR 0 1
47745: PPUSH
47746: CALL_OW 254
47750: PUSH
47751: LD_INT 1
47753: PLUS
47754: ARRAY
47755: ST_TO_ADDR
// end ;
47756: LD_VAR 0 2
47760: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47761: LD_INT 0
47763: PPUSH
47764: PPUSH
47765: PPUSH
47766: PPUSH
47767: PPUSH
// if not hexes then
47768: LD_VAR 0 2
47772: NOT
47773: IFFALSE 47777
// exit ;
47775: GO 47925
// dist := 9999 ;
47777: LD_ADDR_VAR 0 5
47781: PUSH
47782: LD_INT 9999
47784: ST_TO_ADDR
// for i = 1 to hexes do
47785: LD_ADDR_VAR 0 4
47789: PUSH
47790: DOUBLE
47791: LD_INT 1
47793: DEC
47794: ST_TO_ADDR
47795: LD_VAR 0 2
47799: PUSH
47800: FOR_TO
47801: IFFALSE 47913
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47803: LD_VAR 0 1
47807: PPUSH
47808: LD_VAR 0 2
47812: PUSH
47813: LD_VAR 0 4
47817: ARRAY
47818: PUSH
47819: LD_INT 1
47821: ARRAY
47822: PPUSH
47823: LD_VAR 0 2
47827: PUSH
47828: LD_VAR 0 4
47832: ARRAY
47833: PUSH
47834: LD_INT 2
47836: ARRAY
47837: PPUSH
47838: CALL_OW 297
47842: PUSH
47843: LD_VAR 0 5
47847: LESS
47848: IFFALSE 47911
// begin hex := hexes [ i ] ;
47850: LD_ADDR_VAR 0 7
47854: PUSH
47855: LD_VAR 0 2
47859: PUSH
47860: LD_VAR 0 4
47864: ARRAY
47865: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47866: LD_ADDR_VAR 0 5
47870: PUSH
47871: LD_VAR 0 1
47875: PPUSH
47876: LD_VAR 0 2
47880: PUSH
47881: LD_VAR 0 4
47885: ARRAY
47886: PUSH
47887: LD_INT 1
47889: ARRAY
47890: PPUSH
47891: LD_VAR 0 2
47895: PUSH
47896: LD_VAR 0 4
47900: ARRAY
47901: PUSH
47902: LD_INT 2
47904: ARRAY
47905: PPUSH
47906: CALL_OW 297
47910: ST_TO_ADDR
// end ; end ;
47911: GO 47800
47913: POP
47914: POP
// result := hex ;
47915: LD_ADDR_VAR 0 3
47919: PUSH
47920: LD_VAR 0 7
47924: ST_TO_ADDR
// end ;
47925: LD_VAR 0 3
47929: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47930: LD_INT 0
47932: PPUSH
47933: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47934: LD_VAR 0 1
47938: NOT
47939: PUSH
47940: LD_VAR 0 1
47944: PUSH
47945: LD_INT 21
47947: PUSH
47948: LD_INT 2
47950: PUSH
47951: EMPTY
47952: LIST
47953: LIST
47954: PUSH
47955: LD_INT 23
47957: PUSH
47958: LD_INT 2
47960: PUSH
47961: EMPTY
47962: LIST
47963: LIST
47964: PUSH
47965: EMPTY
47966: LIST
47967: LIST
47968: PPUSH
47969: CALL_OW 69
47973: IN
47974: NOT
47975: OR
47976: IFFALSE 47980
// exit ;
47978: GO 48027
// for i = 1 to 3 do
47980: LD_ADDR_VAR 0 3
47984: PUSH
47985: DOUBLE
47986: LD_INT 1
47988: DEC
47989: ST_TO_ADDR
47990: LD_INT 3
47992: PUSH
47993: FOR_TO
47994: IFFALSE 48025
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47996: LD_VAR 0 1
48000: PPUSH
48001: CALL_OW 250
48005: PPUSH
48006: LD_VAR 0 1
48010: PPUSH
48011: CALL_OW 251
48015: PPUSH
48016: LD_INT 1
48018: PPUSH
48019: CALL_OW 453
48023: GO 47993
48025: POP
48026: POP
// end ;
48027: LD_VAR 0 2
48031: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48032: LD_INT 0
48034: PPUSH
48035: PPUSH
48036: PPUSH
48037: PPUSH
48038: PPUSH
48039: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48040: LD_VAR 0 1
48044: NOT
48045: PUSH
48046: LD_VAR 0 2
48050: NOT
48051: OR
48052: PUSH
48053: LD_VAR 0 1
48057: PPUSH
48058: CALL_OW 314
48062: OR
48063: IFFALSE 48067
// exit ;
48065: GO 48508
// x := GetX ( enemy_unit ) ;
48067: LD_ADDR_VAR 0 7
48071: PUSH
48072: LD_VAR 0 2
48076: PPUSH
48077: CALL_OW 250
48081: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48082: LD_ADDR_VAR 0 8
48086: PUSH
48087: LD_VAR 0 2
48091: PPUSH
48092: CALL_OW 251
48096: ST_TO_ADDR
// if not x or not y then
48097: LD_VAR 0 7
48101: NOT
48102: PUSH
48103: LD_VAR 0 8
48107: NOT
48108: OR
48109: IFFALSE 48113
// exit ;
48111: GO 48508
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48113: LD_ADDR_VAR 0 6
48117: PUSH
48118: LD_VAR 0 7
48122: PPUSH
48123: LD_INT 0
48125: PPUSH
48126: LD_INT 4
48128: PPUSH
48129: CALL_OW 272
48133: PUSH
48134: LD_VAR 0 8
48138: PPUSH
48139: LD_INT 0
48141: PPUSH
48142: LD_INT 4
48144: PPUSH
48145: CALL_OW 273
48149: PUSH
48150: EMPTY
48151: LIST
48152: LIST
48153: PUSH
48154: LD_VAR 0 7
48158: PPUSH
48159: LD_INT 1
48161: PPUSH
48162: LD_INT 4
48164: PPUSH
48165: CALL_OW 272
48169: PUSH
48170: LD_VAR 0 8
48174: PPUSH
48175: LD_INT 1
48177: PPUSH
48178: LD_INT 4
48180: PPUSH
48181: CALL_OW 273
48185: PUSH
48186: EMPTY
48187: LIST
48188: LIST
48189: PUSH
48190: LD_VAR 0 7
48194: PPUSH
48195: LD_INT 2
48197: PPUSH
48198: LD_INT 4
48200: PPUSH
48201: CALL_OW 272
48205: PUSH
48206: LD_VAR 0 8
48210: PPUSH
48211: LD_INT 2
48213: PPUSH
48214: LD_INT 4
48216: PPUSH
48217: CALL_OW 273
48221: PUSH
48222: EMPTY
48223: LIST
48224: LIST
48225: PUSH
48226: LD_VAR 0 7
48230: PPUSH
48231: LD_INT 3
48233: PPUSH
48234: LD_INT 4
48236: PPUSH
48237: CALL_OW 272
48241: PUSH
48242: LD_VAR 0 8
48246: PPUSH
48247: LD_INT 3
48249: PPUSH
48250: LD_INT 4
48252: PPUSH
48253: CALL_OW 273
48257: PUSH
48258: EMPTY
48259: LIST
48260: LIST
48261: PUSH
48262: LD_VAR 0 7
48266: PPUSH
48267: LD_INT 4
48269: PPUSH
48270: LD_INT 4
48272: PPUSH
48273: CALL_OW 272
48277: PUSH
48278: LD_VAR 0 8
48282: PPUSH
48283: LD_INT 4
48285: PPUSH
48286: LD_INT 4
48288: PPUSH
48289: CALL_OW 273
48293: PUSH
48294: EMPTY
48295: LIST
48296: LIST
48297: PUSH
48298: LD_VAR 0 7
48302: PPUSH
48303: LD_INT 5
48305: PPUSH
48306: LD_INT 4
48308: PPUSH
48309: CALL_OW 272
48313: PUSH
48314: LD_VAR 0 8
48318: PPUSH
48319: LD_INT 5
48321: PPUSH
48322: LD_INT 4
48324: PPUSH
48325: CALL_OW 273
48329: PUSH
48330: EMPTY
48331: LIST
48332: LIST
48333: PUSH
48334: EMPTY
48335: LIST
48336: LIST
48337: LIST
48338: LIST
48339: LIST
48340: LIST
48341: ST_TO_ADDR
// for i = tmp downto 1 do
48342: LD_ADDR_VAR 0 4
48346: PUSH
48347: DOUBLE
48348: LD_VAR 0 6
48352: INC
48353: ST_TO_ADDR
48354: LD_INT 1
48356: PUSH
48357: FOR_DOWNTO
48358: IFFALSE 48459
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48360: LD_VAR 0 6
48364: PUSH
48365: LD_VAR 0 4
48369: ARRAY
48370: PUSH
48371: LD_INT 1
48373: ARRAY
48374: PPUSH
48375: LD_VAR 0 6
48379: PUSH
48380: LD_VAR 0 4
48384: ARRAY
48385: PUSH
48386: LD_INT 2
48388: ARRAY
48389: PPUSH
48390: CALL_OW 488
48394: NOT
48395: PUSH
48396: LD_VAR 0 6
48400: PUSH
48401: LD_VAR 0 4
48405: ARRAY
48406: PUSH
48407: LD_INT 1
48409: ARRAY
48410: PPUSH
48411: LD_VAR 0 6
48415: PUSH
48416: LD_VAR 0 4
48420: ARRAY
48421: PUSH
48422: LD_INT 2
48424: ARRAY
48425: PPUSH
48426: CALL_OW 428
48430: PUSH
48431: LD_INT 0
48433: NONEQUAL
48434: OR
48435: IFFALSE 48457
// tmp := Delete ( tmp , i ) ;
48437: LD_ADDR_VAR 0 6
48441: PUSH
48442: LD_VAR 0 6
48446: PPUSH
48447: LD_VAR 0 4
48451: PPUSH
48452: CALL_OW 3
48456: ST_TO_ADDR
48457: GO 48357
48459: POP
48460: POP
// j := GetClosestHex ( unit , tmp ) ;
48461: LD_ADDR_VAR 0 5
48465: PUSH
48466: LD_VAR 0 1
48470: PPUSH
48471: LD_VAR 0 6
48475: PPUSH
48476: CALL 47761 0 2
48480: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48481: LD_VAR 0 1
48485: PPUSH
48486: LD_VAR 0 5
48490: PUSH
48491: LD_INT 1
48493: ARRAY
48494: PPUSH
48495: LD_VAR 0 5
48499: PUSH
48500: LD_INT 2
48502: ARRAY
48503: PPUSH
48504: CALL_OW 111
// end ;
48508: LD_VAR 0 3
48512: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48513: LD_INT 0
48515: PPUSH
48516: PPUSH
48517: PPUSH
// uc_side = 0 ;
48518: LD_ADDR_OWVAR 20
48522: PUSH
48523: LD_INT 0
48525: ST_TO_ADDR
// uc_nation = 0 ;
48526: LD_ADDR_OWVAR 21
48530: PUSH
48531: LD_INT 0
48533: ST_TO_ADDR
// InitHc ;
48534: CALL_OW 19
// InitVc ;
48538: CALL_OW 20
// if mastodonts then
48542: LD_VAR 0 6
48546: IFFALSE 48613
// for i = 1 to mastodonts do
48548: LD_ADDR_VAR 0 11
48552: PUSH
48553: DOUBLE
48554: LD_INT 1
48556: DEC
48557: ST_TO_ADDR
48558: LD_VAR 0 6
48562: PUSH
48563: FOR_TO
48564: IFFALSE 48611
// begin vc_chassis := 31 ;
48566: LD_ADDR_OWVAR 37
48570: PUSH
48571: LD_INT 31
48573: ST_TO_ADDR
// vc_control := control_rider ;
48574: LD_ADDR_OWVAR 38
48578: PUSH
48579: LD_INT 4
48581: ST_TO_ADDR
// animal := CreateVehicle ;
48582: LD_ADDR_VAR 0 12
48586: PUSH
48587: CALL_OW 45
48591: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48592: LD_VAR 0 12
48596: PPUSH
48597: LD_VAR 0 8
48601: PPUSH
48602: LD_INT 0
48604: PPUSH
48605: CALL 55358 0 3
// end ;
48609: GO 48563
48611: POP
48612: POP
// if horses then
48613: LD_VAR 0 5
48617: IFFALSE 48684
// for i = 1 to horses do
48619: LD_ADDR_VAR 0 11
48623: PUSH
48624: DOUBLE
48625: LD_INT 1
48627: DEC
48628: ST_TO_ADDR
48629: LD_VAR 0 5
48633: PUSH
48634: FOR_TO
48635: IFFALSE 48682
// begin hc_class := 21 ;
48637: LD_ADDR_OWVAR 28
48641: PUSH
48642: LD_INT 21
48644: ST_TO_ADDR
// hc_gallery :=  ;
48645: LD_ADDR_OWVAR 33
48649: PUSH
48650: LD_STRING 
48652: ST_TO_ADDR
// animal := CreateHuman ;
48653: LD_ADDR_VAR 0 12
48657: PUSH
48658: CALL_OW 44
48662: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48663: LD_VAR 0 12
48667: PPUSH
48668: LD_VAR 0 8
48672: PPUSH
48673: LD_INT 0
48675: PPUSH
48676: CALL 55358 0 3
// end ;
48680: GO 48634
48682: POP
48683: POP
// if birds then
48684: LD_VAR 0 1
48688: IFFALSE 48755
// for i = 1 to birds do
48690: LD_ADDR_VAR 0 11
48694: PUSH
48695: DOUBLE
48696: LD_INT 1
48698: DEC
48699: ST_TO_ADDR
48700: LD_VAR 0 1
48704: PUSH
48705: FOR_TO
48706: IFFALSE 48753
// begin hc_class = 18 ;
48708: LD_ADDR_OWVAR 28
48712: PUSH
48713: LD_INT 18
48715: ST_TO_ADDR
// hc_gallery =  ;
48716: LD_ADDR_OWVAR 33
48720: PUSH
48721: LD_STRING 
48723: ST_TO_ADDR
// animal := CreateHuman ;
48724: LD_ADDR_VAR 0 12
48728: PUSH
48729: CALL_OW 44
48733: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48734: LD_VAR 0 12
48738: PPUSH
48739: LD_VAR 0 8
48743: PPUSH
48744: LD_INT 0
48746: PPUSH
48747: CALL 55358 0 3
// end ;
48751: GO 48705
48753: POP
48754: POP
// if tigers then
48755: LD_VAR 0 2
48759: IFFALSE 48843
// for i = 1 to tigers do
48761: LD_ADDR_VAR 0 11
48765: PUSH
48766: DOUBLE
48767: LD_INT 1
48769: DEC
48770: ST_TO_ADDR
48771: LD_VAR 0 2
48775: PUSH
48776: FOR_TO
48777: IFFALSE 48841
// begin hc_class = class_tiger ;
48779: LD_ADDR_OWVAR 28
48783: PUSH
48784: LD_INT 14
48786: ST_TO_ADDR
// hc_gallery =  ;
48787: LD_ADDR_OWVAR 33
48791: PUSH
48792: LD_STRING 
48794: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48795: LD_ADDR_OWVAR 35
48799: PUSH
48800: LD_INT 7
48802: NEG
48803: PPUSH
48804: LD_INT 7
48806: PPUSH
48807: CALL_OW 12
48811: ST_TO_ADDR
// animal := CreateHuman ;
48812: LD_ADDR_VAR 0 12
48816: PUSH
48817: CALL_OW 44
48821: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48822: LD_VAR 0 12
48826: PPUSH
48827: LD_VAR 0 8
48831: PPUSH
48832: LD_INT 0
48834: PPUSH
48835: CALL 55358 0 3
// end ;
48839: GO 48776
48841: POP
48842: POP
// if apemans then
48843: LD_VAR 0 3
48847: IFFALSE 48970
// for i = 1 to apemans do
48849: LD_ADDR_VAR 0 11
48853: PUSH
48854: DOUBLE
48855: LD_INT 1
48857: DEC
48858: ST_TO_ADDR
48859: LD_VAR 0 3
48863: PUSH
48864: FOR_TO
48865: IFFALSE 48968
// begin hc_class = class_apeman ;
48867: LD_ADDR_OWVAR 28
48871: PUSH
48872: LD_INT 12
48874: ST_TO_ADDR
// hc_gallery =  ;
48875: LD_ADDR_OWVAR 33
48879: PUSH
48880: LD_STRING 
48882: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
48883: LD_ADDR_OWVAR 35
48887: PUSH
48888: LD_INT 5
48890: NEG
48891: PPUSH
48892: LD_INT 5
48894: PPUSH
48895: CALL_OW 12
48899: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48900: LD_ADDR_OWVAR 31
48904: PUSH
48905: LD_INT 1
48907: PPUSH
48908: LD_INT 3
48910: PPUSH
48911: CALL_OW 12
48915: PUSH
48916: LD_INT 1
48918: PPUSH
48919: LD_INT 3
48921: PPUSH
48922: CALL_OW 12
48926: PUSH
48927: LD_INT 0
48929: PUSH
48930: LD_INT 0
48932: PUSH
48933: EMPTY
48934: LIST
48935: LIST
48936: LIST
48937: LIST
48938: ST_TO_ADDR
// animal := CreateHuman ;
48939: LD_ADDR_VAR 0 12
48943: PUSH
48944: CALL_OW 44
48948: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48949: LD_VAR 0 12
48953: PPUSH
48954: LD_VAR 0 8
48958: PPUSH
48959: LD_INT 0
48961: PPUSH
48962: CALL 55358 0 3
// end ;
48966: GO 48864
48968: POP
48969: POP
// if enchidnas then
48970: LD_VAR 0 4
48974: IFFALSE 49041
// for i = 1 to enchidnas do
48976: LD_ADDR_VAR 0 11
48980: PUSH
48981: DOUBLE
48982: LD_INT 1
48984: DEC
48985: ST_TO_ADDR
48986: LD_VAR 0 4
48990: PUSH
48991: FOR_TO
48992: IFFALSE 49039
// begin hc_class = 13 ;
48994: LD_ADDR_OWVAR 28
48998: PUSH
48999: LD_INT 13
49001: ST_TO_ADDR
// hc_gallery =  ;
49002: LD_ADDR_OWVAR 33
49006: PUSH
49007: LD_STRING 
49009: ST_TO_ADDR
// animal := CreateHuman ;
49010: LD_ADDR_VAR 0 12
49014: PUSH
49015: CALL_OW 44
49019: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49020: LD_VAR 0 12
49024: PPUSH
49025: LD_VAR 0 8
49029: PPUSH
49030: LD_INT 0
49032: PPUSH
49033: CALL 55358 0 3
// end ;
49037: GO 48991
49039: POP
49040: POP
// if fishes then
49041: LD_VAR 0 7
49045: IFFALSE 49112
// for i = 1 to fishes do
49047: LD_ADDR_VAR 0 11
49051: PUSH
49052: DOUBLE
49053: LD_INT 1
49055: DEC
49056: ST_TO_ADDR
49057: LD_VAR 0 7
49061: PUSH
49062: FOR_TO
49063: IFFALSE 49110
// begin hc_class = 20 ;
49065: LD_ADDR_OWVAR 28
49069: PUSH
49070: LD_INT 20
49072: ST_TO_ADDR
// hc_gallery =  ;
49073: LD_ADDR_OWVAR 33
49077: PUSH
49078: LD_STRING 
49080: ST_TO_ADDR
// animal := CreateHuman ;
49081: LD_ADDR_VAR 0 12
49085: PUSH
49086: CALL_OW 44
49090: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49091: LD_VAR 0 12
49095: PPUSH
49096: LD_VAR 0 9
49100: PPUSH
49101: LD_INT 0
49103: PPUSH
49104: CALL 55358 0 3
// end ;
49108: GO 49062
49110: POP
49111: POP
// end ;
49112: LD_VAR 0 10
49116: RET
// export function WantHeal ( sci , unit ) ; begin
49117: LD_INT 0
49119: PPUSH
// if GetTaskList ( sci ) > 0 then
49120: LD_VAR 0 1
49124: PPUSH
49125: CALL_OW 437
49129: PUSH
49130: LD_INT 0
49132: GREATER
49133: IFFALSE 49203
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49135: LD_VAR 0 1
49139: PPUSH
49140: CALL_OW 437
49144: PUSH
49145: LD_INT 1
49147: ARRAY
49148: PUSH
49149: LD_INT 1
49151: ARRAY
49152: PUSH
49153: LD_STRING l
49155: EQUAL
49156: PUSH
49157: LD_VAR 0 1
49161: PPUSH
49162: CALL_OW 437
49166: PUSH
49167: LD_INT 1
49169: ARRAY
49170: PUSH
49171: LD_INT 4
49173: ARRAY
49174: PUSH
49175: LD_VAR 0 2
49179: EQUAL
49180: AND
49181: IFFALSE 49193
// result := true else
49183: LD_ADDR_VAR 0 3
49187: PUSH
49188: LD_INT 1
49190: ST_TO_ADDR
49191: GO 49201
// result := false ;
49193: LD_ADDR_VAR 0 3
49197: PUSH
49198: LD_INT 0
49200: ST_TO_ADDR
// end else
49201: GO 49211
// result := false ;
49203: LD_ADDR_VAR 0 3
49207: PUSH
49208: LD_INT 0
49210: ST_TO_ADDR
// end ;
49211: LD_VAR 0 3
49215: RET
// export function HealTarget ( sci ) ; begin
49216: LD_INT 0
49218: PPUSH
// if not sci then
49219: LD_VAR 0 1
49223: NOT
49224: IFFALSE 49228
// exit ;
49226: GO 49293
// result := 0 ;
49228: LD_ADDR_VAR 0 2
49232: PUSH
49233: LD_INT 0
49235: ST_TO_ADDR
// if GetTaskList ( sci ) then
49236: LD_VAR 0 1
49240: PPUSH
49241: CALL_OW 437
49245: IFFALSE 49293
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49247: LD_VAR 0 1
49251: PPUSH
49252: CALL_OW 437
49256: PUSH
49257: LD_INT 1
49259: ARRAY
49260: PUSH
49261: LD_INT 1
49263: ARRAY
49264: PUSH
49265: LD_STRING l
49267: EQUAL
49268: IFFALSE 49293
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49270: LD_ADDR_VAR 0 2
49274: PUSH
49275: LD_VAR 0 1
49279: PPUSH
49280: CALL_OW 437
49284: PUSH
49285: LD_INT 1
49287: ARRAY
49288: PUSH
49289: LD_INT 4
49291: ARRAY
49292: ST_TO_ADDR
// end ;
49293: LD_VAR 0 2
49297: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
49298: LD_INT 0
49300: PPUSH
49301: PPUSH
49302: PPUSH
49303: PPUSH
49304: PPUSH
49305: PPUSH
49306: PPUSH
49307: PPUSH
49308: PPUSH
49309: PPUSH
49310: PPUSH
49311: PPUSH
49312: PPUSH
49313: PPUSH
49314: PPUSH
49315: PPUSH
49316: PPUSH
49317: PPUSH
49318: PPUSH
49319: PPUSH
49320: PPUSH
49321: PPUSH
49322: PPUSH
49323: PPUSH
49324: PPUSH
49325: PPUSH
49326: PPUSH
49327: PPUSH
49328: PPUSH
49329: PPUSH
49330: PPUSH
49331: PPUSH
49332: PPUSH
49333: PPUSH
// if not list then
49334: LD_VAR 0 1
49338: NOT
49339: IFFALSE 49343
// exit ;
49341: GO 53969
// base := list [ 1 ] ;
49343: LD_ADDR_VAR 0 3
49347: PUSH
49348: LD_VAR 0 1
49352: PUSH
49353: LD_INT 1
49355: ARRAY
49356: ST_TO_ADDR
// group := list [ 2 ] ;
49357: LD_ADDR_VAR 0 4
49361: PUSH
49362: LD_VAR 0 1
49366: PUSH
49367: LD_INT 2
49369: ARRAY
49370: ST_TO_ADDR
// path := list [ 3 ] ;
49371: LD_ADDR_VAR 0 5
49375: PUSH
49376: LD_VAR 0 1
49380: PUSH
49381: LD_INT 3
49383: ARRAY
49384: ST_TO_ADDR
// flags := list [ 4 ] ;
49385: LD_ADDR_VAR 0 6
49389: PUSH
49390: LD_VAR 0 1
49394: PUSH
49395: LD_INT 4
49397: ARRAY
49398: ST_TO_ADDR
// mined := [ ] ;
49399: LD_ADDR_VAR 0 27
49403: PUSH
49404: EMPTY
49405: ST_TO_ADDR
// bombed := [ ] ;
49406: LD_ADDR_VAR 0 28
49410: PUSH
49411: EMPTY
49412: ST_TO_ADDR
// healers := [ ] ;
49413: LD_ADDR_VAR 0 31
49417: PUSH
49418: EMPTY
49419: ST_TO_ADDR
// to_heal := [ ] ;
49420: LD_ADDR_VAR 0 30
49424: PUSH
49425: EMPTY
49426: ST_TO_ADDR
// repairs := [ ] ;
49427: LD_ADDR_VAR 0 33
49431: PUSH
49432: EMPTY
49433: ST_TO_ADDR
// to_repair := [ ] ;
49434: LD_ADDR_VAR 0 32
49438: PUSH
49439: EMPTY
49440: ST_TO_ADDR
// if not group or not path then
49441: LD_VAR 0 4
49445: NOT
49446: PUSH
49447: LD_VAR 0 5
49451: NOT
49452: OR
49453: IFFALSE 49457
// exit ;
49455: GO 53969
// side := GetSide ( group [ 1 ] ) ;
49457: LD_ADDR_VAR 0 35
49461: PUSH
49462: LD_VAR 0 4
49466: PUSH
49467: LD_INT 1
49469: ARRAY
49470: PPUSH
49471: CALL_OW 255
49475: ST_TO_ADDR
// if flags then
49476: LD_VAR 0 6
49480: IFFALSE 49624
// begin f_ignore_area := flags [ 1 ] ;
49482: LD_ADDR_VAR 0 17
49486: PUSH
49487: LD_VAR 0 6
49491: PUSH
49492: LD_INT 1
49494: ARRAY
49495: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
49496: LD_ADDR_VAR 0 18
49500: PUSH
49501: LD_VAR 0 6
49505: PUSH
49506: LD_INT 2
49508: ARRAY
49509: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
49510: LD_ADDR_VAR 0 19
49514: PUSH
49515: LD_VAR 0 6
49519: PUSH
49520: LD_INT 3
49522: ARRAY
49523: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
49524: LD_ADDR_VAR 0 20
49528: PUSH
49529: LD_VAR 0 6
49533: PUSH
49534: LD_INT 4
49536: ARRAY
49537: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
49538: LD_ADDR_VAR 0 21
49542: PUSH
49543: LD_VAR 0 6
49547: PUSH
49548: LD_INT 5
49550: ARRAY
49551: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
49552: LD_ADDR_VAR 0 22
49556: PUSH
49557: LD_VAR 0 6
49561: PUSH
49562: LD_INT 6
49564: ARRAY
49565: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
49566: LD_ADDR_VAR 0 23
49570: PUSH
49571: LD_VAR 0 6
49575: PUSH
49576: LD_INT 7
49578: ARRAY
49579: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
49580: LD_ADDR_VAR 0 24
49584: PUSH
49585: LD_VAR 0 6
49589: PUSH
49590: LD_INT 8
49592: ARRAY
49593: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
49594: LD_ADDR_VAR 0 25
49598: PUSH
49599: LD_VAR 0 6
49603: PUSH
49604: LD_INT 9
49606: ARRAY
49607: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
49608: LD_ADDR_VAR 0 26
49612: PUSH
49613: LD_VAR 0 6
49617: PUSH
49618: LD_INT 10
49620: ARRAY
49621: ST_TO_ADDR
// end else
49622: GO 49704
// begin f_ignore_area := false ;
49624: LD_ADDR_VAR 0 17
49628: PUSH
49629: LD_INT 0
49631: ST_TO_ADDR
// f_capture := false ;
49632: LD_ADDR_VAR 0 18
49636: PUSH
49637: LD_INT 0
49639: ST_TO_ADDR
// f_ignore_civ := false ;
49640: LD_ADDR_VAR 0 19
49644: PUSH
49645: LD_INT 0
49647: ST_TO_ADDR
// f_murder := false ;
49648: LD_ADDR_VAR 0 20
49652: PUSH
49653: LD_INT 0
49655: ST_TO_ADDR
// f_mines := false ;
49656: LD_ADDR_VAR 0 21
49660: PUSH
49661: LD_INT 0
49663: ST_TO_ADDR
// f_repair := false ;
49664: LD_ADDR_VAR 0 22
49668: PUSH
49669: LD_INT 0
49671: ST_TO_ADDR
// f_heal := false ;
49672: LD_ADDR_VAR 0 23
49676: PUSH
49677: LD_INT 0
49679: ST_TO_ADDR
// f_spacetime := false ;
49680: LD_ADDR_VAR 0 24
49684: PUSH
49685: LD_INT 0
49687: ST_TO_ADDR
// f_attack_depot := false ;
49688: LD_ADDR_VAR 0 25
49692: PUSH
49693: LD_INT 0
49695: ST_TO_ADDR
// f_crawl := false ;
49696: LD_ADDR_VAR 0 26
49700: PUSH
49701: LD_INT 0
49703: ST_TO_ADDR
// end ; if f_heal then
49704: LD_VAR 0 23
49708: IFFALSE 49735
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
49710: LD_ADDR_VAR 0 31
49714: PUSH
49715: LD_VAR 0 4
49719: PPUSH
49720: LD_INT 25
49722: PUSH
49723: LD_INT 4
49725: PUSH
49726: EMPTY
49727: LIST
49728: LIST
49729: PPUSH
49730: CALL_OW 72
49734: ST_TO_ADDR
// if f_repair then
49735: LD_VAR 0 22
49739: IFFALSE 49766
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
49741: LD_ADDR_VAR 0 33
49745: PUSH
49746: LD_VAR 0 4
49750: PPUSH
49751: LD_INT 25
49753: PUSH
49754: LD_INT 3
49756: PUSH
49757: EMPTY
49758: LIST
49759: LIST
49760: PPUSH
49761: CALL_OW 72
49765: ST_TO_ADDR
// units_path := [ ] ;
49766: LD_ADDR_VAR 0 16
49770: PUSH
49771: EMPTY
49772: ST_TO_ADDR
// for i = 1 to group do
49773: LD_ADDR_VAR 0 7
49777: PUSH
49778: DOUBLE
49779: LD_INT 1
49781: DEC
49782: ST_TO_ADDR
49783: LD_VAR 0 4
49787: PUSH
49788: FOR_TO
49789: IFFALSE 49818
// units_path := Replace ( units_path , i , path ) ;
49791: LD_ADDR_VAR 0 16
49795: PUSH
49796: LD_VAR 0 16
49800: PPUSH
49801: LD_VAR 0 7
49805: PPUSH
49806: LD_VAR 0 5
49810: PPUSH
49811: CALL_OW 1
49815: ST_TO_ADDR
49816: GO 49788
49818: POP
49819: POP
// repeat for i = group downto 1 do
49820: LD_ADDR_VAR 0 7
49824: PUSH
49825: DOUBLE
49826: LD_VAR 0 4
49830: INC
49831: ST_TO_ADDR
49832: LD_INT 1
49834: PUSH
49835: FOR_DOWNTO
49836: IFFALSE 53932
// begin wait ( 5 ) ;
49838: LD_INT 5
49840: PPUSH
49841: CALL_OW 67
// tmp := [ ] ;
49845: LD_ADDR_VAR 0 14
49849: PUSH
49850: EMPTY
49851: ST_TO_ADDR
// attacking := false ;
49852: LD_ADDR_VAR 0 29
49856: PUSH
49857: LD_INT 0
49859: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
49860: LD_VAR 0 4
49864: PUSH
49865: LD_VAR 0 7
49869: ARRAY
49870: PPUSH
49871: CALL_OW 301
49875: PUSH
49876: LD_VAR 0 4
49880: PUSH
49881: LD_VAR 0 7
49885: ARRAY
49886: NOT
49887: OR
49888: IFFALSE 49997
// begin if GetType ( group [ i ] ) = unit_human then
49890: LD_VAR 0 4
49894: PUSH
49895: LD_VAR 0 7
49899: ARRAY
49900: PPUSH
49901: CALL_OW 247
49905: PUSH
49906: LD_INT 1
49908: EQUAL
49909: IFFALSE 49955
// begin to_heal := to_heal diff group [ i ] ;
49911: LD_ADDR_VAR 0 30
49915: PUSH
49916: LD_VAR 0 30
49920: PUSH
49921: LD_VAR 0 4
49925: PUSH
49926: LD_VAR 0 7
49930: ARRAY
49931: DIFF
49932: ST_TO_ADDR
// healers := healers diff group [ i ] ;
49933: LD_ADDR_VAR 0 31
49937: PUSH
49938: LD_VAR 0 31
49942: PUSH
49943: LD_VAR 0 4
49947: PUSH
49948: LD_VAR 0 7
49952: ARRAY
49953: DIFF
49954: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
49955: LD_ADDR_VAR 0 4
49959: PUSH
49960: LD_VAR 0 4
49964: PPUSH
49965: LD_VAR 0 7
49969: PPUSH
49970: CALL_OW 3
49974: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
49975: LD_ADDR_VAR 0 16
49979: PUSH
49980: LD_VAR 0 16
49984: PPUSH
49985: LD_VAR 0 7
49989: PPUSH
49990: CALL_OW 3
49994: ST_TO_ADDR
// continue ;
49995: GO 49835
// end ; if f_repair then
49997: LD_VAR 0 22
50001: IFFALSE 50490
// begin if GetType ( group [ i ] ) = unit_vehicle then
50003: LD_VAR 0 4
50007: PUSH
50008: LD_VAR 0 7
50012: ARRAY
50013: PPUSH
50014: CALL_OW 247
50018: PUSH
50019: LD_INT 2
50021: EQUAL
50022: IFFALSE 50212
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
50024: LD_VAR 0 4
50028: PUSH
50029: LD_VAR 0 7
50033: ARRAY
50034: PPUSH
50035: CALL_OW 256
50039: PUSH
50040: LD_INT 700
50042: LESS
50043: PUSH
50044: LD_VAR 0 4
50048: PUSH
50049: LD_VAR 0 7
50053: ARRAY
50054: PUSH
50055: LD_VAR 0 32
50059: IN
50060: NOT
50061: AND
50062: IFFALSE 50086
// to_repair := to_repair union group [ i ] ;
50064: LD_ADDR_VAR 0 32
50068: PUSH
50069: LD_VAR 0 32
50073: PUSH
50074: LD_VAR 0 4
50078: PUSH
50079: LD_VAR 0 7
50083: ARRAY
50084: UNION
50085: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
50086: LD_VAR 0 4
50090: PUSH
50091: LD_VAR 0 7
50095: ARRAY
50096: PPUSH
50097: CALL_OW 256
50101: PUSH
50102: LD_INT 1000
50104: EQUAL
50105: PUSH
50106: LD_VAR 0 4
50110: PUSH
50111: LD_VAR 0 7
50115: ARRAY
50116: PUSH
50117: LD_VAR 0 32
50121: IN
50122: AND
50123: IFFALSE 50147
// to_repair := to_repair diff group [ i ] ;
50125: LD_ADDR_VAR 0 32
50129: PUSH
50130: LD_VAR 0 32
50134: PUSH
50135: LD_VAR 0 4
50139: PUSH
50140: LD_VAR 0 7
50144: ARRAY
50145: DIFF
50146: ST_TO_ADDR
// if group [ i ] in to_repair then
50147: LD_VAR 0 4
50151: PUSH
50152: LD_VAR 0 7
50156: ARRAY
50157: PUSH
50158: LD_VAR 0 32
50162: IN
50163: IFFALSE 50210
// begin if not IsInArea ( group [ i ] , f_repair ) then
50165: LD_VAR 0 4
50169: PUSH
50170: LD_VAR 0 7
50174: ARRAY
50175: PPUSH
50176: LD_VAR 0 22
50180: PPUSH
50181: CALL_OW 308
50185: NOT
50186: IFFALSE 50208
// ComMoveToArea ( group [ i ] , f_repair ) ;
50188: LD_VAR 0 4
50192: PUSH
50193: LD_VAR 0 7
50197: ARRAY
50198: PPUSH
50199: LD_VAR 0 22
50203: PPUSH
50204: CALL_OW 113
// continue ;
50208: GO 49835
// end ; end else
50210: GO 50490
// if group [ i ] in repairs then
50212: LD_VAR 0 4
50216: PUSH
50217: LD_VAR 0 7
50221: ARRAY
50222: PUSH
50223: LD_VAR 0 33
50227: IN
50228: IFFALSE 50490
// begin if IsInUnit ( group [ i ] ) then
50230: LD_VAR 0 4
50234: PUSH
50235: LD_VAR 0 7
50239: ARRAY
50240: PPUSH
50241: CALL_OW 310
50245: IFFALSE 50313
// begin z := IsInUnit ( group [ i ] ) ;
50247: LD_ADDR_VAR 0 13
50251: PUSH
50252: LD_VAR 0 4
50256: PUSH
50257: LD_VAR 0 7
50261: ARRAY
50262: PPUSH
50263: CALL_OW 310
50267: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
50268: LD_VAR 0 13
50272: PUSH
50273: LD_VAR 0 32
50277: IN
50278: PUSH
50279: LD_VAR 0 13
50283: PPUSH
50284: LD_VAR 0 22
50288: PPUSH
50289: CALL_OW 308
50293: AND
50294: IFFALSE 50311
// ComExitVehicle ( group [ i ] ) ;
50296: LD_VAR 0 4
50300: PUSH
50301: LD_VAR 0 7
50305: ARRAY
50306: PPUSH
50307: CALL_OW 121
// end else
50311: GO 50490
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
50313: LD_ADDR_VAR 0 13
50317: PUSH
50318: LD_VAR 0 4
50322: PPUSH
50323: LD_INT 95
50325: PUSH
50326: LD_VAR 0 22
50330: PUSH
50331: EMPTY
50332: LIST
50333: LIST
50334: PUSH
50335: LD_INT 58
50337: PUSH
50338: EMPTY
50339: LIST
50340: PUSH
50341: EMPTY
50342: LIST
50343: LIST
50344: PPUSH
50345: CALL_OW 72
50349: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
50350: LD_VAR 0 4
50354: PUSH
50355: LD_VAR 0 7
50359: ARRAY
50360: PPUSH
50361: CALL_OW 314
50365: NOT
50366: IFFALSE 50488
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
50368: LD_ADDR_VAR 0 10
50372: PUSH
50373: LD_VAR 0 13
50377: PPUSH
50378: LD_VAR 0 4
50382: PUSH
50383: LD_VAR 0 7
50387: ARRAY
50388: PPUSH
50389: CALL_OW 74
50393: ST_TO_ADDR
// if not x then
50394: LD_VAR 0 10
50398: NOT
50399: IFFALSE 50403
// continue ;
50401: GO 49835
// if GetLives ( x ) < 1000 then
50403: LD_VAR 0 10
50407: PPUSH
50408: CALL_OW 256
50412: PUSH
50413: LD_INT 1000
50415: LESS
50416: IFFALSE 50440
// ComRepairVehicle ( group [ i ] , x ) else
50418: LD_VAR 0 4
50422: PUSH
50423: LD_VAR 0 7
50427: ARRAY
50428: PPUSH
50429: LD_VAR 0 10
50433: PPUSH
50434: CALL_OW 129
50438: GO 50488
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
50440: LD_VAR 0 23
50444: PUSH
50445: LD_VAR 0 4
50449: PUSH
50450: LD_VAR 0 7
50454: ARRAY
50455: PPUSH
50456: CALL_OW 256
50460: PUSH
50461: LD_INT 1000
50463: LESS
50464: AND
50465: NOT
50466: IFFALSE 50488
// ComEnterUnit ( group [ i ] , x ) ;
50468: LD_VAR 0 4
50472: PUSH
50473: LD_VAR 0 7
50477: ARRAY
50478: PPUSH
50479: LD_VAR 0 10
50483: PPUSH
50484: CALL_OW 120
// end ; continue ;
50488: GO 49835
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
50490: LD_VAR 0 23
50494: PUSH
50495: LD_VAR 0 4
50499: PUSH
50500: LD_VAR 0 7
50504: ARRAY
50505: PPUSH
50506: CALL_OW 247
50510: PUSH
50511: LD_INT 1
50513: EQUAL
50514: AND
50515: IFFALSE 50993
// begin if group [ i ] in healers then
50517: LD_VAR 0 4
50521: PUSH
50522: LD_VAR 0 7
50526: ARRAY
50527: PUSH
50528: LD_VAR 0 31
50532: IN
50533: IFFALSE 50806
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
50535: LD_VAR 0 4
50539: PUSH
50540: LD_VAR 0 7
50544: ARRAY
50545: PPUSH
50546: LD_VAR 0 23
50550: PPUSH
50551: CALL_OW 308
50555: NOT
50556: PUSH
50557: LD_VAR 0 4
50561: PUSH
50562: LD_VAR 0 7
50566: ARRAY
50567: PPUSH
50568: CALL_OW 314
50572: NOT
50573: AND
50574: IFFALSE 50598
// ComMoveToArea ( group [ i ] , f_heal ) else
50576: LD_VAR 0 4
50580: PUSH
50581: LD_VAR 0 7
50585: ARRAY
50586: PPUSH
50587: LD_VAR 0 23
50591: PPUSH
50592: CALL_OW 113
50596: GO 50804
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
50598: LD_VAR 0 4
50602: PUSH
50603: LD_VAR 0 7
50607: ARRAY
50608: PPUSH
50609: CALL 49216 0 1
50613: PPUSH
50614: CALL_OW 256
50618: PUSH
50619: LD_INT 1000
50621: EQUAL
50622: IFFALSE 50641
// ComStop ( group [ i ] ) else
50624: LD_VAR 0 4
50628: PUSH
50629: LD_VAR 0 7
50633: ARRAY
50634: PPUSH
50635: CALL_OW 141
50639: GO 50804
// if not HasTask ( group [ i ] ) and to_heal then
50641: LD_VAR 0 4
50645: PUSH
50646: LD_VAR 0 7
50650: ARRAY
50651: PPUSH
50652: CALL_OW 314
50656: NOT
50657: PUSH
50658: LD_VAR 0 30
50662: AND
50663: IFFALSE 50804
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
50665: LD_ADDR_VAR 0 13
50669: PUSH
50670: LD_VAR 0 30
50674: PPUSH
50675: LD_INT 3
50677: PUSH
50678: LD_INT 54
50680: PUSH
50681: EMPTY
50682: LIST
50683: PUSH
50684: EMPTY
50685: LIST
50686: LIST
50687: PPUSH
50688: CALL_OW 72
50692: PPUSH
50693: LD_VAR 0 4
50697: PUSH
50698: LD_VAR 0 7
50702: ARRAY
50703: PPUSH
50704: CALL_OW 74
50708: ST_TO_ADDR
// if z then
50709: LD_VAR 0 13
50713: IFFALSE 50804
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
50715: LD_INT 91
50717: PUSH
50718: LD_VAR 0 13
50722: PUSH
50723: LD_INT 10
50725: PUSH
50726: EMPTY
50727: LIST
50728: LIST
50729: LIST
50730: PUSH
50731: LD_INT 81
50733: PUSH
50734: LD_VAR 0 13
50738: PPUSH
50739: CALL_OW 255
50743: PUSH
50744: EMPTY
50745: LIST
50746: LIST
50747: PUSH
50748: EMPTY
50749: LIST
50750: LIST
50751: PPUSH
50752: CALL_OW 69
50756: PUSH
50757: LD_INT 0
50759: EQUAL
50760: IFFALSE 50784
// ComHeal ( group [ i ] , z ) else
50762: LD_VAR 0 4
50766: PUSH
50767: LD_VAR 0 7
50771: ARRAY
50772: PPUSH
50773: LD_VAR 0 13
50777: PPUSH
50778: CALL_OW 128
50782: GO 50804
// ComMoveToArea ( group [ i ] , f_heal ) ;
50784: LD_VAR 0 4
50788: PUSH
50789: LD_VAR 0 7
50793: ARRAY
50794: PPUSH
50795: LD_VAR 0 23
50799: PPUSH
50800: CALL_OW 113
// end ; continue ;
50804: GO 49835
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
50806: LD_VAR 0 4
50810: PUSH
50811: LD_VAR 0 7
50815: ARRAY
50816: PPUSH
50817: CALL_OW 256
50821: PUSH
50822: LD_INT 700
50824: LESS
50825: PUSH
50826: LD_VAR 0 4
50830: PUSH
50831: LD_VAR 0 7
50835: ARRAY
50836: PUSH
50837: LD_VAR 0 30
50841: IN
50842: NOT
50843: AND
50844: IFFALSE 50868
// to_heal := to_heal union group [ i ] ;
50846: LD_ADDR_VAR 0 30
50850: PUSH
50851: LD_VAR 0 30
50855: PUSH
50856: LD_VAR 0 4
50860: PUSH
50861: LD_VAR 0 7
50865: ARRAY
50866: UNION
50867: ST_TO_ADDR
// if group [ i ] in to_heal then
50868: LD_VAR 0 4
50872: PUSH
50873: LD_VAR 0 7
50877: ARRAY
50878: PUSH
50879: LD_VAR 0 30
50883: IN
50884: IFFALSE 50993
// begin if GetLives ( group [ i ] ) = 1000 then
50886: LD_VAR 0 4
50890: PUSH
50891: LD_VAR 0 7
50895: ARRAY
50896: PPUSH
50897: CALL_OW 256
50901: PUSH
50902: LD_INT 1000
50904: EQUAL
50905: IFFALSE 50931
// to_heal := to_heal diff group [ i ] else
50907: LD_ADDR_VAR 0 30
50911: PUSH
50912: LD_VAR 0 30
50916: PUSH
50917: LD_VAR 0 4
50921: PUSH
50922: LD_VAR 0 7
50926: ARRAY
50927: DIFF
50928: ST_TO_ADDR
50929: GO 50993
// begin if not IsInArea ( group [ i ] , to_heal ) then
50931: LD_VAR 0 4
50935: PUSH
50936: LD_VAR 0 7
50940: ARRAY
50941: PPUSH
50942: LD_VAR 0 30
50946: PPUSH
50947: CALL_OW 308
50951: NOT
50952: IFFALSE 50976
// ComMoveToArea ( group [ i ] , f_heal ) else
50954: LD_VAR 0 4
50958: PUSH
50959: LD_VAR 0 7
50963: ARRAY
50964: PPUSH
50965: LD_VAR 0 23
50969: PPUSH
50970: CALL_OW 113
50974: GO 50991
// ComHold ( group [ i ] ) ;
50976: LD_VAR 0 4
50980: PUSH
50981: LD_VAR 0 7
50985: ARRAY
50986: PPUSH
50987: CALL_OW 140
// continue ;
50991: GO 49835
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
50993: LD_VAR 0 4
50997: PUSH
50998: LD_VAR 0 7
51002: ARRAY
51003: PPUSH
51004: LD_INT 10
51006: PPUSH
51007: CALL 47613 0 2
51011: NOT
51012: PUSH
51013: LD_VAR 0 16
51017: PUSH
51018: LD_VAR 0 7
51022: ARRAY
51023: PUSH
51024: EMPTY
51025: EQUAL
51026: NOT
51027: AND
51028: IFFALSE 51294
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
51030: LD_VAR 0 4
51034: PUSH
51035: LD_VAR 0 7
51039: ARRAY
51040: PPUSH
51041: CALL_OW 262
51045: PUSH
51046: LD_INT 1
51048: PUSH
51049: LD_INT 2
51051: PUSH
51052: EMPTY
51053: LIST
51054: LIST
51055: IN
51056: IFFALSE 51097
// if GetFuel ( group [ i ] ) < 10 then
51058: LD_VAR 0 4
51062: PUSH
51063: LD_VAR 0 7
51067: ARRAY
51068: PPUSH
51069: CALL_OW 261
51073: PUSH
51074: LD_INT 10
51076: LESS
51077: IFFALSE 51097
// SetFuel ( group [ i ] , 12 ) ;
51079: LD_VAR 0 4
51083: PUSH
51084: LD_VAR 0 7
51088: ARRAY
51089: PPUSH
51090: LD_INT 12
51092: PPUSH
51093: CALL_OW 240
// if units_path [ i ] then
51097: LD_VAR 0 16
51101: PUSH
51102: LD_VAR 0 7
51106: ARRAY
51107: IFFALSE 51292
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
51109: LD_VAR 0 4
51113: PUSH
51114: LD_VAR 0 7
51118: ARRAY
51119: PPUSH
51120: LD_VAR 0 16
51124: PUSH
51125: LD_VAR 0 7
51129: ARRAY
51130: PUSH
51131: LD_INT 1
51133: ARRAY
51134: PUSH
51135: LD_INT 1
51137: ARRAY
51138: PPUSH
51139: LD_VAR 0 16
51143: PUSH
51144: LD_VAR 0 7
51148: ARRAY
51149: PUSH
51150: LD_INT 1
51152: ARRAY
51153: PUSH
51154: LD_INT 2
51156: ARRAY
51157: PPUSH
51158: CALL_OW 297
51162: PUSH
51163: LD_INT 6
51165: GREATER
51166: IFFALSE 51241
// begin if not HasTask ( group [ i ] ) then
51168: LD_VAR 0 4
51172: PUSH
51173: LD_VAR 0 7
51177: ARRAY
51178: PPUSH
51179: CALL_OW 314
51183: NOT
51184: IFFALSE 51239
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
51186: LD_VAR 0 4
51190: PUSH
51191: LD_VAR 0 7
51195: ARRAY
51196: PPUSH
51197: LD_VAR 0 16
51201: PUSH
51202: LD_VAR 0 7
51206: ARRAY
51207: PUSH
51208: LD_INT 1
51210: ARRAY
51211: PUSH
51212: LD_INT 1
51214: ARRAY
51215: PPUSH
51216: LD_VAR 0 16
51220: PUSH
51221: LD_VAR 0 7
51225: ARRAY
51226: PUSH
51227: LD_INT 1
51229: ARRAY
51230: PUSH
51231: LD_INT 2
51233: ARRAY
51234: PPUSH
51235: CALL_OW 114
// end else
51239: GO 51292
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
51241: LD_ADDR_VAR 0 15
51245: PUSH
51246: LD_VAR 0 16
51250: PUSH
51251: LD_VAR 0 7
51255: ARRAY
51256: PPUSH
51257: LD_INT 1
51259: PPUSH
51260: CALL_OW 3
51264: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
51265: LD_ADDR_VAR 0 16
51269: PUSH
51270: LD_VAR 0 16
51274: PPUSH
51275: LD_VAR 0 7
51279: PPUSH
51280: LD_VAR 0 15
51284: PPUSH
51285: CALL_OW 1
51289: ST_TO_ADDR
// continue ;
51290: GO 49835
// end ; end ; end else
51292: GO 53930
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
51294: LD_ADDR_VAR 0 14
51298: PUSH
51299: LD_INT 81
51301: PUSH
51302: LD_VAR 0 4
51306: PUSH
51307: LD_VAR 0 7
51311: ARRAY
51312: PPUSH
51313: CALL_OW 255
51317: PUSH
51318: EMPTY
51319: LIST
51320: LIST
51321: PPUSH
51322: CALL_OW 69
51326: ST_TO_ADDR
// if not tmp then
51327: LD_VAR 0 14
51331: NOT
51332: IFFALSE 51336
// continue ;
51334: GO 49835
// if f_ignore_area then
51336: LD_VAR 0 17
51340: IFFALSE 51428
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
51342: LD_ADDR_VAR 0 15
51346: PUSH
51347: LD_VAR 0 14
51351: PPUSH
51352: LD_INT 3
51354: PUSH
51355: LD_INT 92
51357: PUSH
51358: LD_VAR 0 17
51362: PUSH
51363: LD_INT 1
51365: ARRAY
51366: PUSH
51367: LD_VAR 0 17
51371: PUSH
51372: LD_INT 2
51374: ARRAY
51375: PUSH
51376: LD_VAR 0 17
51380: PUSH
51381: LD_INT 3
51383: ARRAY
51384: PUSH
51385: EMPTY
51386: LIST
51387: LIST
51388: LIST
51389: LIST
51390: PUSH
51391: EMPTY
51392: LIST
51393: LIST
51394: PPUSH
51395: CALL_OW 72
51399: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51400: LD_VAR 0 14
51404: PUSH
51405: LD_VAR 0 15
51409: DIFF
51410: IFFALSE 51428
// tmp := tmp diff tmp2 ;
51412: LD_ADDR_VAR 0 14
51416: PUSH
51417: LD_VAR 0 14
51421: PUSH
51422: LD_VAR 0 15
51426: DIFF
51427: ST_TO_ADDR
// end ; if not f_murder then
51428: LD_VAR 0 20
51432: NOT
51433: IFFALSE 51491
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
51435: LD_ADDR_VAR 0 15
51439: PUSH
51440: LD_VAR 0 14
51444: PPUSH
51445: LD_INT 3
51447: PUSH
51448: LD_INT 50
51450: PUSH
51451: EMPTY
51452: LIST
51453: PUSH
51454: EMPTY
51455: LIST
51456: LIST
51457: PPUSH
51458: CALL_OW 72
51462: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51463: LD_VAR 0 14
51467: PUSH
51468: LD_VAR 0 15
51472: DIFF
51473: IFFALSE 51491
// tmp := tmp diff tmp2 ;
51475: LD_ADDR_VAR 0 14
51479: PUSH
51480: LD_VAR 0 14
51484: PUSH
51485: LD_VAR 0 15
51489: DIFF
51490: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
51491: LD_ADDR_VAR 0 14
51495: PUSH
51496: LD_VAR 0 4
51500: PUSH
51501: LD_VAR 0 7
51505: ARRAY
51506: PPUSH
51507: LD_VAR 0 14
51511: PPUSH
51512: LD_INT 1
51514: PPUSH
51515: LD_INT 1
51517: PPUSH
51518: CALL 21256 0 4
51522: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
51523: LD_VAR 0 4
51527: PUSH
51528: LD_VAR 0 7
51532: ARRAY
51533: PPUSH
51534: CALL_OW 257
51538: PUSH
51539: LD_INT 1
51541: EQUAL
51542: IFFALSE 51990
// begin if WantPlant ( group [ i ] ) then
51544: LD_VAR 0 4
51548: PUSH
51549: LD_VAR 0 7
51553: ARRAY
51554: PPUSH
51555: CALL 20757 0 1
51559: IFFALSE 51563
// continue ;
51561: GO 49835
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
51563: LD_VAR 0 18
51567: PUSH
51568: LD_VAR 0 4
51572: PUSH
51573: LD_VAR 0 7
51577: ARRAY
51578: PPUSH
51579: CALL_OW 310
51583: NOT
51584: AND
51585: PUSH
51586: LD_VAR 0 14
51590: PUSH
51591: LD_INT 1
51593: ARRAY
51594: PUSH
51595: LD_VAR 0 14
51599: PPUSH
51600: LD_INT 21
51602: PUSH
51603: LD_INT 2
51605: PUSH
51606: EMPTY
51607: LIST
51608: LIST
51609: PUSH
51610: LD_INT 58
51612: PUSH
51613: EMPTY
51614: LIST
51615: PUSH
51616: EMPTY
51617: LIST
51618: LIST
51619: PPUSH
51620: CALL_OW 72
51624: IN
51625: AND
51626: IFFALSE 51662
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
51628: LD_VAR 0 4
51632: PUSH
51633: LD_VAR 0 7
51637: ARRAY
51638: PPUSH
51639: LD_VAR 0 14
51643: PUSH
51644: LD_INT 1
51646: ARRAY
51647: PPUSH
51648: CALL_OW 120
// attacking := true ;
51652: LD_ADDR_VAR 0 29
51656: PUSH
51657: LD_INT 1
51659: ST_TO_ADDR
// continue ;
51660: GO 49835
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
51662: LD_VAR 0 26
51666: PUSH
51667: LD_VAR 0 4
51671: PUSH
51672: LD_VAR 0 7
51676: ARRAY
51677: PPUSH
51678: CALL_OW 257
51682: PUSH
51683: LD_INT 1
51685: EQUAL
51686: AND
51687: PUSH
51688: LD_VAR 0 4
51692: PUSH
51693: LD_VAR 0 7
51697: ARRAY
51698: PPUSH
51699: CALL_OW 256
51703: PUSH
51704: LD_INT 800
51706: LESS
51707: AND
51708: PUSH
51709: LD_VAR 0 4
51713: PUSH
51714: LD_VAR 0 7
51718: ARRAY
51719: PPUSH
51720: CALL_OW 318
51724: NOT
51725: AND
51726: IFFALSE 51743
// ComCrawl ( group [ i ] ) ;
51728: LD_VAR 0 4
51732: PUSH
51733: LD_VAR 0 7
51737: ARRAY
51738: PPUSH
51739: CALL_OW 137
// if f_mines then
51743: LD_VAR 0 21
51747: IFFALSE 51990
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
51749: LD_VAR 0 14
51753: PUSH
51754: LD_INT 1
51756: ARRAY
51757: PPUSH
51758: CALL_OW 247
51762: PUSH
51763: LD_INT 3
51765: EQUAL
51766: PUSH
51767: LD_VAR 0 14
51771: PUSH
51772: LD_INT 1
51774: ARRAY
51775: PUSH
51776: LD_VAR 0 27
51780: IN
51781: NOT
51782: AND
51783: IFFALSE 51990
// begin x := GetX ( tmp [ 1 ] ) ;
51785: LD_ADDR_VAR 0 10
51789: PUSH
51790: LD_VAR 0 14
51794: PUSH
51795: LD_INT 1
51797: ARRAY
51798: PPUSH
51799: CALL_OW 250
51803: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
51804: LD_ADDR_VAR 0 11
51808: PUSH
51809: LD_VAR 0 14
51813: PUSH
51814: LD_INT 1
51816: ARRAY
51817: PPUSH
51818: CALL_OW 251
51822: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
51823: LD_ADDR_VAR 0 12
51827: PUSH
51828: LD_VAR 0 4
51832: PUSH
51833: LD_VAR 0 7
51837: ARRAY
51838: PPUSH
51839: CALL 47698 0 1
51843: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
51844: LD_VAR 0 4
51848: PUSH
51849: LD_VAR 0 7
51853: ARRAY
51854: PPUSH
51855: LD_VAR 0 10
51859: PPUSH
51860: LD_VAR 0 11
51864: PPUSH
51865: LD_VAR 0 14
51869: PUSH
51870: LD_INT 1
51872: ARRAY
51873: PPUSH
51874: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
51878: LD_VAR 0 4
51882: PUSH
51883: LD_VAR 0 7
51887: ARRAY
51888: PPUSH
51889: LD_VAR 0 10
51893: PPUSH
51894: LD_VAR 0 12
51898: PPUSH
51899: LD_INT 7
51901: PPUSH
51902: CALL_OW 272
51906: PPUSH
51907: LD_VAR 0 11
51911: PPUSH
51912: LD_VAR 0 12
51916: PPUSH
51917: LD_INT 7
51919: PPUSH
51920: CALL_OW 273
51924: PPUSH
51925: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
51929: LD_VAR 0 4
51933: PUSH
51934: LD_VAR 0 7
51938: ARRAY
51939: PPUSH
51940: LD_INT 71
51942: PPUSH
51943: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
51947: LD_ADDR_VAR 0 27
51951: PUSH
51952: LD_VAR 0 27
51956: PPUSH
51957: LD_VAR 0 27
51961: PUSH
51962: LD_INT 1
51964: PLUS
51965: PPUSH
51966: LD_VAR 0 14
51970: PUSH
51971: LD_INT 1
51973: ARRAY
51974: PPUSH
51975: CALL_OW 1
51979: ST_TO_ADDR
// attacking := true ;
51980: LD_ADDR_VAR 0 29
51984: PUSH
51985: LD_INT 1
51987: ST_TO_ADDR
// continue ;
51988: GO 49835
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
51990: LD_VAR 0 4
51994: PUSH
51995: LD_VAR 0 7
51999: ARRAY
52000: PPUSH
52001: CALL_OW 257
52005: PUSH
52006: LD_INT 17
52008: EQUAL
52009: PUSH
52010: LD_VAR 0 4
52014: PUSH
52015: LD_VAR 0 7
52019: ARRAY
52020: PPUSH
52021: CALL_OW 110
52025: PUSH
52026: LD_INT 71
52028: EQUAL
52029: NOT
52030: AND
52031: IFFALSE 52177
// begin attacking := false ;
52033: LD_ADDR_VAR 0 29
52037: PUSH
52038: LD_INT 0
52040: ST_TO_ADDR
// k := 5 ;
52041: LD_ADDR_VAR 0 9
52045: PUSH
52046: LD_INT 5
52048: ST_TO_ADDR
// if tmp < k then
52049: LD_VAR 0 14
52053: PUSH
52054: LD_VAR 0 9
52058: LESS
52059: IFFALSE 52071
// k := tmp ;
52061: LD_ADDR_VAR 0 9
52065: PUSH
52066: LD_VAR 0 14
52070: ST_TO_ADDR
// for j = 1 to k do
52071: LD_ADDR_VAR 0 8
52075: PUSH
52076: DOUBLE
52077: LD_INT 1
52079: DEC
52080: ST_TO_ADDR
52081: LD_VAR 0 9
52085: PUSH
52086: FOR_TO
52087: IFFALSE 52175
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
52089: LD_VAR 0 14
52093: PUSH
52094: LD_VAR 0 8
52098: ARRAY
52099: PUSH
52100: LD_VAR 0 14
52104: PPUSH
52105: LD_INT 58
52107: PUSH
52108: EMPTY
52109: LIST
52110: PPUSH
52111: CALL_OW 72
52115: IN
52116: NOT
52117: IFFALSE 52173
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52119: LD_VAR 0 4
52123: PUSH
52124: LD_VAR 0 7
52128: ARRAY
52129: PPUSH
52130: LD_VAR 0 14
52134: PUSH
52135: LD_VAR 0 8
52139: ARRAY
52140: PPUSH
52141: CALL_OW 115
// attacking := true ;
52145: LD_ADDR_VAR 0 29
52149: PUSH
52150: LD_INT 1
52152: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
52153: LD_VAR 0 4
52157: PUSH
52158: LD_VAR 0 7
52162: ARRAY
52163: PPUSH
52164: LD_INT 71
52166: PPUSH
52167: CALL_OW 109
// continue ;
52171: GO 52086
// end ; end ;
52173: GO 52086
52175: POP
52176: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
52177: LD_VAR 0 4
52181: PUSH
52182: LD_VAR 0 7
52186: ARRAY
52187: PPUSH
52188: CALL_OW 257
52192: PUSH
52193: LD_INT 8
52195: EQUAL
52196: PUSH
52197: LD_VAR 0 4
52201: PUSH
52202: LD_VAR 0 7
52206: ARRAY
52207: PPUSH
52208: CALL_OW 264
52212: PUSH
52213: LD_INT 28
52215: PUSH
52216: LD_INT 45
52218: PUSH
52219: LD_INT 7
52221: PUSH
52222: LD_INT 47
52224: PUSH
52225: EMPTY
52226: LIST
52227: LIST
52228: LIST
52229: LIST
52230: IN
52231: OR
52232: IFFALSE 52462
// begin attacking := false ;
52234: LD_ADDR_VAR 0 29
52238: PUSH
52239: LD_INT 0
52241: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
52242: LD_VAR 0 14
52246: PUSH
52247: LD_INT 1
52249: ARRAY
52250: PPUSH
52251: CALL_OW 266
52255: PUSH
52256: LD_INT 32
52258: PUSH
52259: LD_INT 31
52261: PUSH
52262: LD_INT 33
52264: PUSH
52265: LD_INT 4
52267: PUSH
52268: LD_INT 5
52270: PUSH
52271: EMPTY
52272: LIST
52273: LIST
52274: LIST
52275: LIST
52276: LIST
52277: IN
52278: IFFALSE 52462
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
52280: LD_ADDR_VAR 0 9
52284: PUSH
52285: LD_VAR 0 14
52289: PUSH
52290: LD_INT 1
52292: ARRAY
52293: PPUSH
52294: CALL_OW 266
52298: PPUSH
52299: LD_VAR 0 14
52303: PUSH
52304: LD_INT 1
52306: ARRAY
52307: PPUSH
52308: CALL_OW 250
52312: PPUSH
52313: LD_VAR 0 14
52317: PUSH
52318: LD_INT 1
52320: ARRAY
52321: PPUSH
52322: CALL_OW 251
52326: PPUSH
52327: LD_VAR 0 14
52331: PUSH
52332: LD_INT 1
52334: ARRAY
52335: PPUSH
52336: CALL_OW 254
52340: PPUSH
52341: LD_VAR 0 14
52345: PUSH
52346: LD_INT 1
52348: ARRAY
52349: PPUSH
52350: CALL_OW 248
52354: PPUSH
52355: LD_INT 0
52357: PPUSH
52358: CALL 29068 0 6
52362: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
52363: LD_ADDR_VAR 0 8
52367: PUSH
52368: LD_VAR 0 4
52372: PUSH
52373: LD_VAR 0 7
52377: ARRAY
52378: PPUSH
52379: LD_VAR 0 9
52383: PPUSH
52384: CALL 47761 0 2
52388: ST_TO_ADDR
// if j then
52389: LD_VAR 0 8
52393: IFFALSE 52462
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
52395: LD_VAR 0 8
52399: PUSH
52400: LD_INT 1
52402: ARRAY
52403: PPUSH
52404: LD_VAR 0 8
52408: PUSH
52409: LD_INT 2
52411: ARRAY
52412: PPUSH
52413: CALL_OW 488
52417: IFFALSE 52462
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
52419: LD_VAR 0 4
52423: PUSH
52424: LD_VAR 0 7
52428: ARRAY
52429: PPUSH
52430: LD_VAR 0 8
52434: PUSH
52435: LD_INT 1
52437: ARRAY
52438: PPUSH
52439: LD_VAR 0 8
52443: PUSH
52444: LD_INT 2
52446: ARRAY
52447: PPUSH
52448: CALL_OW 116
// attacking := true ;
52452: LD_ADDR_VAR 0 29
52456: PUSH
52457: LD_INT 1
52459: ST_TO_ADDR
// continue ;
52460: GO 49835
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
52462: LD_VAR 0 4
52466: PUSH
52467: LD_VAR 0 7
52471: ARRAY
52472: PPUSH
52473: CALL_OW 265
52477: PUSH
52478: LD_INT 11
52480: EQUAL
52481: IFFALSE 52759
// begin k := 10 ;
52483: LD_ADDR_VAR 0 9
52487: PUSH
52488: LD_INT 10
52490: ST_TO_ADDR
// x := 0 ;
52491: LD_ADDR_VAR 0 10
52495: PUSH
52496: LD_INT 0
52498: ST_TO_ADDR
// if tmp < k then
52499: LD_VAR 0 14
52503: PUSH
52504: LD_VAR 0 9
52508: LESS
52509: IFFALSE 52521
// k := tmp ;
52511: LD_ADDR_VAR 0 9
52515: PUSH
52516: LD_VAR 0 14
52520: ST_TO_ADDR
// for j = k downto 1 do
52521: LD_ADDR_VAR 0 8
52525: PUSH
52526: DOUBLE
52527: LD_VAR 0 9
52531: INC
52532: ST_TO_ADDR
52533: LD_INT 1
52535: PUSH
52536: FOR_DOWNTO
52537: IFFALSE 52612
// begin if GetType ( tmp [ j ] ) = unit_human then
52539: LD_VAR 0 14
52543: PUSH
52544: LD_VAR 0 8
52548: ARRAY
52549: PPUSH
52550: CALL_OW 247
52554: PUSH
52555: LD_INT 1
52557: EQUAL
52558: IFFALSE 52610
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
52560: LD_VAR 0 4
52564: PUSH
52565: LD_VAR 0 7
52569: ARRAY
52570: PPUSH
52571: LD_VAR 0 14
52575: PUSH
52576: LD_VAR 0 8
52580: ARRAY
52581: PPUSH
52582: CALL 48032 0 2
// x := tmp [ j ] ;
52586: LD_ADDR_VAR 0 10
52590: PUSH
52591: LD_VAR 0 14
52595: PUSH
52596: LD_VAR 0 8
52600: ARRAY
52601: ST_TO_ADDR
// attacking := true ;
52602: LD_ADDR_VAR 0 29
52606: PUSH
52607: LD_INT 1
52609: ST_TO_ADDR
// end ; end ;
52610: GO 52536
52612: POP
52613: POP
// if not x then
52614: LD_VAR 0 10
52618: NOT
52619: IFFALSE 52759
// begin attacking := true ;
52621: LD_ADDR_VAR 0 29
52625: PUSH
52626: LD_INT 1
52628: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
52629: LD_VAR 0 4
52633: PUSH
52634: LD_VAR 0 7
52638: ARRAY
52639: PPUSH
52640: CALL_OW 250
52644: PPUSH
52645: LD_VAR 0 4
52649: PUSH
52650: LD_VAR 0 7
52654: ARRAY
52655: PPUSH
52656: CALL_OW 251
52660: PPUSH
52661: CALL_OW 546
52665: PUSH
52666: LD_INT 2
52668: ARRAY
52669: PUSH
52670: LD_VAR 0 14
52674: PUSH
52675: LD_INT 1
52677: ARRAY
52678: PPUSH
52679: CALL_OW 250
52683: PPUSH
52684: LD_VAR 0 14
52688: PUSH
52689: LD_INT 1
52691: ARRAY
52692: PPUSH
52693: CALL_OW 251
52697: PPUSH
52698: CALL_OW 546
52702: PUSH
52703: LD_INT 2
52705: ARRAY
52706: EQUAL
52707: IFFALSE 52735
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
52709: LD_VAR 0 4
52713: PUSH
52714: LD_VAR 0 7
52718: ARRAY
52719: PPUSH
52720: LD_VAR 0 14
52724: PUSH
52725: LD_INT 1
52727: ARRAY
52728: PPUSH
52729: CALL 48032 0 2
52733: GO 52759
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52735: LD_VAR 0 4
52739: PUSH
52740: LD_VAR 0 7
52744: ARRAY
52745: PPUSH
52746: LD_VAR 0 14
52750: PUSH
52751: LD_INT 1
52753: ARRAY
52754: PPUSH
52755: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
52759: LD_VAR 0 4
52763: PUSH
52764: LD_VAR 0 7
52768: ARRAY
52769: PPUSH
52770: CALL_OW 264
52774: PUSH
52775: LD_INT 29
52777: EQUAL
52778: IFFALSE 53144
// begin if WantsToAttack ( group [ i ] ) in bombed then
52780: LD_VAR 0 4
52784: PUSH
52785: LD_VAR 0 7
52789: ARRAY
52790: PPUSH
52791: CALL_OW 319
52795: PUSH
52796: LD_VAR 0 28
52800: IN
52801: IFFALSE 52805
// continue ;
52803: GO 49835
// k := 8 ;
52805: LD_ADDR_VAR 0 9
52809: PUSH
52810: LD_INT 8
52812: ST_TO_ADDR
// x := 0 ;
52813: LD_ADDR_VAR 0 10
52817: PUSH
52818: LD_INT 0
52820: ST_TO_ADDR
// if tmp < k then
52821: LD_VAR 0 14
52825: PUSH
52826: LD_VAR 0 9
52830: LESS
52831: IFFALSE 52843
// k := tmp ;
52833: LD_ADDR_VAR 0 9
52837: PUSH
52838: LD_VAR 0 14
52842: ST_TO_ADDR
// for j = 1 to k do
52843: LD_ADDR_VAR 0 8
52847: PUSH
52848: DOUBLE
52849: LD_INT 1
52851: DEC
52852: ST_TO_ADDR
52853: LD_VAR 0 9
52857: PUSH
52858: FOR_TO
52859: IFFALSE 52991
// begin if GetType ( tmp [ j ] ) = unit_building then
52861: LD_VAR 0 14
52865: PUSH
52866: LD_VAR 0 8
52870: ARRAY
52871: PPUSH
52872: CALL_OW 247
52876: PUSH
52877: LD_INT 3
52879: EQUAL
52880: IFFALSE 52989
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
52882: LD_VAR 0 14
52886: PUSH
52887: LD_VAR 0 8
52891: ARRAY
52892: PUSH
52893: LD_VAR 0 28
52897: IN
52898: NOT
52899: PUSH
52900: LD_VAR 0 14
52904: PUSH
52905: LD_VAR 0 8
52909: ARRAY
52910: PPUSH
52911: CALL_OW 313
52915: AND
52916: IFFALSE 52989
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52918: LD_VAR 0 4
52922: PUSH
52923: LD_VAR 0 7
52927: ARRAY
52928: PPUSH
52929: LD_VAR 0 14
52933: PUSH
52934: LD_VAR 0 8
52938: ARRAY
52939: PPUSH
52940: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
52944: LD_ADDR_VAR 0 28
52948: PUSH
52949: LD_VAR 0 28
52953: PPUSH
52954: LD_VAR 0 28
52958: PUSH
52959: LD_INT 1
52961: PLUS
52962: PPUSH
52963: LD_VAR 0 14
52967: PUSH
52968: LD_VAR 0 8
52972: ARRAY
52973: PPUSH
52974: CALL_OW 1
52978: ST_TO_ADDR
// attacking := true ;
52979: LD_ADDR_VAR 0 29
52983: PUSH
52984: LD_INT 1
52986: ST_TO_ADDR
// break ;
52987: GO 52991
// end ; end ;
52989: GO 52858
52991: POP
52992: POP
// if not attacking and f_attack_depot then
52993: LD_VAR 0 29
52997: NOT
52998: PUSH
52999: LD_VAR 0 25
53003: AND
53004: IFFALSE 53099
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53006: LD_ADDR_VAR 0 13
53010: PUSH
53011: LD_VAR 0 14
53015: PPUSH
53016: LD_INT 2
53018: PUSH
53019: LD_INT 30
53021: PUSH
53022: LD_INT 0
53024: PUSH
53025: EMPTY
53026: LIST
53027: LIST
53028: PUSH
53029: LD_INT 30
53031: PUSH
53032: LD_INT 1
53034: PUSH
53035: EMPTY
53036: LIST
53037: LIST
53038: PUSH
53039: EMPTY
53040: LIST
53041: LIST
53042: LIST
53043: PPUSH
53044: CALL_OW 72
53048: ST_TO_ADDR
// if z then
53049: LD_VAR 0 13
53053: IFFALSE 53099
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
53055: LD_VAR 0 4
53059: PUSH
53060: LD_VAR 0 7
53064: ARRAY
53065: PPUSH
53066: LD_VAR 0 13
53070: PPUSH
53071: LD_VAR 0 4
53075: PUSH
53076: LD_VAR 0 7
53080: ARRAY
53081: PPUSH
53082: CALL_OW 74
53086: PPUSH
53087: CALL_OW 115
// attacking := true ;
53091: LD_ADDR_VAR 0 29
53095: PUSH
53096: LD_INT 1
53098: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
53099: LD_VAR 0 4
53103: PUSH
53104: LD_VAR 0 7
53108: ARRAY
53109: PPUSH
53110: CALL_OW 256
53114: PUSH
53115: LD_INT 500
53117: LESS
53118: IFFALSE 53144
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53120: LD_VAR 0 4
53124: PUSH
53125: LD_VAR 0 7
53129: ARRAY
53130: PPUSH
53131: LD_VAR 0 14
53135: PUSH
53136: LD_INT 1
53138: ARRAY
53139: PPUSH
53140: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
53144: LD_VAR 0 4
53148: PUSH
53149: LD_VAR 0 7
53153: ARRAY
53154: PPUSH
53155: CALL_OW 264
53159: PUSH
53160: LD_INT 49
53162: EQUAL
53163: IFFALSE 53284
// begin if not HasTask ( group [ i ] ) then
53165: LD_VAR 0 4
53169: PUSH
53170: LD_VAR 0 7
53174: ARRAY
53175: PPUSH
53176: CALL_OW 314
53180: NOT
53181: IFFALSE 53284
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
53183: LD_ADDR_VAR 0 9
53187: PUSH
53188: LD_INT 81
53190: PUSH
53191: LD_VAR 0 4
53195: PUSH
53196: LD_VAR 0 7
53200: ARRAY
53201: PPUSH
53202: CALL_OW 255
53206: PUSH
53207: EMPTY
53208: LIST
53209: LIST
53210: PPUSH
53211: CALL_OW 69
53215: PPUSH
53216: LD_VAR 0 4
53220: PUSH
53221: LD_VAR 0 7
53225: ARRAY
53226: PPUSH
53227: CALL_OW 74
53231: ST_TO_ADDR
// if k then
53232: LD_VAR 0 9
53236: IFFALSE 53284
// if GetDistUnits ( group [ i ] , k ) > 10 then
53238: LD_VAR 0 4
53242: PUSH
53243: LD_VAR 0 7
53247: ARRAY
53248: PPUSH
53249: LD_VAR 0 9
53253: PPUSH
53254: CALL_OW 296
53258: PUSH
53259: LD_INT 10
53261: GREATER
53262: IFFALSE 53284
// ComMoveUnit ( group [ i ] , k ) ;
53264: LD_VAR 0 4
53268: PUSH
53269: LD_VAR 0 7
53273: ARRAY
53274: PPUSH
53275: LD_VAR 0 9
53279: PPUSH
53280: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53284: LD_VAR 0 4
53288: PUSH
53289: LD_VAR 0 7
53293: ARRAY
53294: PPUSH
53295: CALL_OW 256
53299: PUSH
53300: LD_INT 250
53302: LESS
53303: PUSH
53304: LD_VAR 0 4
53308: PUSH
53309: LD_VAR 0 7
53313: ARRAY
53314: PUSH
53315: LD_INT 21
53317: PUSH
53318: LD_INT 2
53320: PUSH
53321: EMPTY
53322: LIST
53323: LIST
53324: PUSH
53325: LD_INT 23
53327: PUSH
53328: LD_INT 2
53330: PUSH
53331: EMPTY
53332: LIST
53333: LIST
53334: PUSH
53335: EMPTY
53336: LIST
53337: LIST
53338: PPUSH
53339: CALL_OW 69
53343: IN
53344: AND
53345: IFFALSE 53470
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
53347: LD_ADDR_VAR 0 9
53351: PUSH
53352: LD_OWVAR 3
53356: PUSH
53357: LD_VAR 0 4
53361: PUSH
53362: LD_VAR 0 7
53366: ARRAY
53367: DIFF
53368: PPUSH
53369: LD_VAR 0 4
53373: PUSH
53374: LD_VAR 0 7
53378: ARRAY
53379: PPUSH
53380: CALL_OW 74
53384: ST_TO_ADDR
// if not k then
53385: LD_VAR 0 9
53389: NOT
53390: IFFALSE 53394
// continue ;
53392: GO 49835
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
53394: LD_VAR 0 9
53398: PUSH
53399: LD_INT 81
53401: PUSH
53402: LD_VAR 0 4
53406: PUSH
53407: LD_VAR 0 7
53411: ARRAY
53412: PPUSH
53413: CALL_OW 255
53417: PUSH
53418: EMPTY
53419: LIST
53420: LIST
53421: PPUSH
53422: CALL_OW 69
53426: IN
53427: PUSH
53428: LD_VAR 0 9
53432: PPUSH
53433: LD_VAR 0 4
53437: PUSH
53438: LD_VAR 0 7
53442: ARRAY
53443: PPUSH
53444: CALL_OW 296
53448: PUSH
53449: LD_INT 5
53451: LESS
53452: AND
53453: IFFALSE 53470
// ComAutodestruct ( group [ i ] ) ;
53455: LD_VAR 0 4
53459: PUSH
53460: LD_VAR 0 7
53464: ARRAY
53465: PPUSH
53466: CALL 47930 0 1
// end ; if f_attack_depot then
53470: LD_VAR 0 25
53474: IFFALSE 53586
// begin k := 6 ;
53476: LD_ADDR_VAR 0 9
53480: PUSH
53481: LD_INT 6
53483: ST_TO_ADDR
// if tmp < k then
53484: LD_VAR 0 14
53488: PUSH
53489: LD_VAR 0 9
53493: LESS
53494: IFFALSE 53506
// k := tmp ;
53496: LD_ADDR_VAR 0 9
53500: PUSH
53501: LD_VAR 0 14
53505: ST_TO_ADDR
// for j = 1 to k do
53506: LD_ADDR_VAR 0 8
53510: PUSH
53511: DOUBLE
53512: LD_INT 1
53514: DEC
53515: ST_TO_ADDR
53516: LD_VAR 0 9
53520: PUSH
53521: FOR_TO
53522: IFFALSE 53584
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
53524: LD_VAR 0 8
53528: PPUSH
53529: CALL_OW 266
53533: PUSH
53534: LD_INT 0
53536: PUSH
53537: LD_INT 1
53539: PUSH
53540: EMPTY
53541: LIST
53542: LIST
53543: IN
53544: IFFALSE 53582
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53546: LD_VAR 0 4
53550: PUSH
53551: LD_VAR 0 7
53555: ARRAY
53556: PPUSH
53557: LD_VAR 0 14
53561: PUSH
53562: LD_VAR 0 8
53566: ARRAY
53567: PPUSH
53568: CALL_OW 115
// attacking := true ;
53572: LD_ADDR_VAR 0 29
53576: PUSH
53577: LD_INT 1
53579: ST_TO_ADDR
// break ;
53580: GO 53584
// end ;
53582: GO 53521
53584: POP
53585: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
53586: LD_VAR 0 4
53590: PUSH
53591: LD_VAR 0 7
53595: ARRAY
53596: PPUSH
53597: CALL_OW 302
53601: PUSH
53602: LD_VAR 0 29
53606: NOT
53607: AND
53608: IFFALSE 53930
// begin if GetTag ( group [ i ] ) = 71 then
53610: LD_VAR 0 4
53614: PUSH
53615: LD_VAR 0 7
53619: ARRAY
53620: PPUSH
53621: CALL_OW 110
53625: PUSH
53626: LD_INT 71
53628: EQUAL
53629: IFFALSE 53670
// begin if HasTask ( group [ i ] ) then
53631: LD_VAR 0 4
53635: PUSH
53636: LD_VAR 0 7
53640: ARRAY
53641: PPUSH
53642: CALL_OW 314
53646: IFFALSE 53652
// continue else
53648: GO 49835
53650: GO 53670
// SetTag ( group [ i ] , 0 ) ;
53652: LD_VAR 0 4
53656: PUSH
53657: LD_VAR 0 7
53661: ARRAY
53662: PPUSH
53663: LD_INT 0
53665: PPUSH
53666: CALL_OW 109
// end ; k := 8 ;
53670: LD_ADDR_VAR 0 9
53674: PUSH
53675: LD_INT 8
53677: ST_TO_ADDR
// x := 0 ;
53678: LD_ADDR_VAR 0 10
53682: PUSH
53683: LD_INT 0
53685: ST_TO_ADDR
// if tmp < k then
53686: LD_VAR 0 14
53690: PUSH
53691: LD_VAR 0 9
53695: LESS
53696: IFFALSE 53708
// k := tmp ;
53698: LD_ADDR_VAR 0 9
53702: PUSH
53703: LD_VAR 0 14
53707: ST_TO_ADDR
// for j = 1 to k do
53708: LD_ADDR_VAR 0 8
53712: PUSH
53713: DOUBLE
53714: LD_INT 1
53716: DEC
53717: ST_TO_ADDR
53718: LD_VAR 0 9
53722: PUSH
53723: FOR_TO
53724: IFFALSE 53822
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
53726: LD_VAR 0 14
53730: PUSH
53731: LD_VAR 0 8
53735: ARRAY
53736: PPUSH
53737: CALL_OW 247
53741: PUSH
53742: LD_INT 1
53744: EQUAL
53745: PUSH
53746: LD_VAR 0 14
53750: PUSH
53751: LD_VAR 0 8
53755: ARRAY
53756: PPUSH
53757: CALL_OW 256
53761: PUSH
53762: LD_INT 250
53764: LESS
53765: PUSH
53766: LD_VAR 0 20
53770: AND
53771: PUSH
53772: LD_VAR 0 20
53776: NOT
53777: PUSH
53778: LD_VAR 0 14
53782: PUSH
53783: LD_VAR 0 8
53787: ARRAY
53788: PPUSH
53789: CALL_OW 256
53793: PUSH
53794: LD_INT 250
53796: GREATEREQUAL
53797: AND
53798: OR
53799: AND
53800: IFFALSE 53820
// begin x := tmp [ j ] ;
53802: LD_ADDR_VAR 0 10
53806: PUSH
53807: LD_VAR 0 14
53811: PUSH
53812: LD_VAR 0 8
53816: ARRAY
53817: ST_TO_ADDR
// break ;
53818: GO 53822
// end ;
53820: GO 53723
53822: POP
53823: POP
// if x then
53824: LD_VAR 0 10
53828: IFFALSE 53852
// ComAttackUnit ( group [ i ] , x ) else
53830: LD_VAR 0 4
53834: PUSH
53835: LD_VAR 0 7
53839: ARRAY
53840: PPUSH
53841: LD_VAR 0 10
53845: PPUSH
53846: CALL_OW 115
53850: GO 53876
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53852: LD_VAR 0 4
53856: PUSH
53857: LD_VAR 0 7
53861: ARRAY
53862: PPUSH
53863: LD_VAR 0 14
53867: PUSH
53868: LD_INT 1
53870: ARRAY
53871: PPUSH
53872: CALL_OW 115
// if not HasTask ( group [ i ] ) then
53876: LD_VAR 0 4
53880: PUSH
53881: LD_VAR 0 7
53885: ARRAY
53886: PPUSH
53887: CALL_OW 314
53891: NOT
53892: IFFALSE 53930
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
53894: LD_VAR 0 4
53898: PUSH
53899: LD_VAR 0 7
53903: ARRAY
53904: PPUSH
53905: LD_VAR 0 14
53909: PPUSH
53910: LD_VAR 0 4
53914: PUSH
53915: LD_VAR 0 7
53919: ARRAY
53920: PPUSH
53921: CALL_OW 74
53925: PPUSH
53926: CALL_OW 115
// end ; end ; end ;
53930: GO 49835
53932: POP
53933: POP
// wait ( 0 0$1 ) ;
53934: LD_INT 35
53936: PPUSH
53937: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
53941: LD_VAR 0 4
53945: PUSH
53946: EMPTY
53947: EQUAL
53948: PUSH
53949: LD_INT 81
53951: PUSH
53952: LD_VAR 0 35
53956: PUSH
53957: EMPTY
53958: LIST
53959: LIST
53960: PPUSH
53961: CALL_OW 69
53965: NOT
53966: OR
53967: IFFALSE 49820
// end ;
53969: LD_VAR 0 2
53973: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53974: LD_INT 0
53976: PPUSH
53977: PPUSH
53978: PPUSH
53979: PPUSH
// if not base_units then
53980: LD_VAR 0 1
53984: NOT
53985: IFFALSE 53989
// exit ;
53987: GO 54076
// result := false ;
53989: LD_ADDR_VAR 0 2
53993: PUSH
53994: LD_INT 0
53996: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53997: LD_ADDR_VAR 0 5
54001: PUSH
54002: LD_VAR 0 1
54006: PPUSH
54007: LD_INT 21
54009: PUSH
54010: LD_INT 3
54012: PUSH
54013: EMPTY
54014: LIST
54015: LIST
54016: PPUSH
54017: CALL_OW 72
54021: ST_TO_ADDR
// if not tmp then
54022: LD_VAR 0 5
54026: NOT
54027: IFFALSE 54031
// exit ;
54029: GO 54076
// for i in tmp do
54031: LD_ADDR_VAR 0 3
54035: PUSH
54036: LD_VAR 0 5
54040: PUSH
54041: FOR_IN
54042: IFFALSE 54074
// begin result := EnemyInRange ( i , 22 ) ;
54044: LD_ADDR_VAR 0 2
54048: PUSH
54049: LD_VAR 0 3
54053: PPUSH
54054: LD_INT 22
54056: PPUSH
54057: CALL 47613 0 2
54061: ST_TO_ADDR
// if result then
54062: LD_VAR 0 2
54066: IFFALSE 54072
// exit ;
54068: POP
54069: POP
54070: GO 54076
// end ;
54072: GO 54041
54074: POP
54075: POP
// end ;
54076: LD_VAR 0 2
54080: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
54081: LD_INT 0
54083: PPUSH
54084: PPUSH
// if not units then
54085: LD_VAR 0 1
54089: NOT
54090: IFFALSE 54094
// exit ;
54092: GO 54164
// result := [ ] ;
54094: LD_ADDR_VAR 0 3
54098: PUSH
54099: EMPTY
54100: ST_TO_ADDR
// for i in units do
54101: LD_ADDR_VAR 0 4
54105: PUSH
54106: LD_VAR 0 1
54110: PUSH
54111: FOR_IN
54112: IFFALSE 54162
// if GetTag ( i ) = tag then
54114: LD_VAR 0 4
54118: PPUSH
54119: CALL_OW 110
54123: PUSH
54124: LD_VAR 0 2
54128: EQUAL
54129: IFFALSE 54160
// result := Insert ( result , result + 1 , i ) ;
54131: LD_ADDR_VAR 0 3
54135: PUSH
54136: LD_VAR 0 3
54140: PPUSH
54141: LD_VAR 0 3
54145: PUSH
54146: LD_INT 1
54148: PLUS
54149: PPUSH
54150: LD_VAR 0 4
54154: PPUSH
54155: CALL_OW 2
54159: ST_TO_ADDR
54160: GO 54111
54162: POP
54163: POP
// end ;
54164: LD_VAR 0 3
54168: RET
// export function IsDriver ( un ) ; begin
54169: LD_INT 0
54171: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54172: LD_ADDR_VAR 0 2
54176: PUSH
54177: LD_VAR 0 1
54181: PUSH
54182: LD_INT 55
54184: PUSH
54185: EMPTY
54186: LIST
54187: PPUSH
54188: CALL_OW 69
54192: IN
54193: ST_TO_ADDR
// end ;
54194: LD_VAR 0 2
54198: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54199: LD_INT 0
54201: PPUSH
54202: PPUSH
// list := [ ] ;
54203: LD_ADDR_VAR 0 5
54207: PUSH
54208: EMPTY
54209: ST_TO_ADDR
// case d of 0 :
54210: LD_VAR 0 3
54214: PUSH
54215: LD_INT 0
54217: DOUBLE
54218: EQUAL
54219: IFTRUE 54223
54221: GO 54356
54223: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54224: LD_ADDR_VAR 0 5
54228: PUSH
54229: LD_VAR 0 1
54233: PUSH
54234: LD_INT 4
54236: MINUS
54237: PUSH
54238: LD_VAR 0 2
54242: PUSH
54243: LD_INT 4
54245: MINUS
54246: PUSH
54247: LD_INT 2
54249: PUSH
54250: EMPTY
54251: LIST
54252: LIST
54253: LIST
54254: PUSH
54255: LD_VAR 0 1
54259: PUSH
54260: LD_INT 3
54262: MINUS
54263: PUSH
54264: LD_VAR 0 2
54268: PUSH
54269: LD_INT 1
54271: PUSH
54272: EMPTY
54273: LIST
54274: LIST
54275: LIST
54276: PUSH
54277: LD_VAR 0 1
54281: PUSH
54282: LD_INT 4
54284: PLUS
54285: PUSH
54286: LD_VAR 0 2
54290: PUSH
54291: LD_INT 4
54293: PUSH
54294: EMPTY
54295: LIST
54296: LIST
54297: LIST
54298: PUSH
54299: LD_VAR 0 1
54303: PUSH
54304: LD_INT 3
54306: PLUS
54307: PUSH
54308: LD_VAR 0 2
54312: PUSH
54313: LD_INT 3
54315: PLUS
54316: PUSH
54317: LD_INT 5
54319: PUSH
54320: EMPTY
54321: LIST
54322: LIST
54323: LIST
54324: PUSH
54325: LD_VAR 0 1
54329: PUSH
54330: LD_VAR 0 2
54334: PUSH
54335: LD_INT 4
54337: PLUS
54338: PUSH
54339: LD_INT 0
54341: PUSH
54342: EMPTY
54343: LIST
54344: LIST
54345: LIST
54346: PUSH
54347: EMPTY
54348: LIST
54349: LIST
54350: LIST
54351: LIST
54352: LIST
54353: ST_TO_ADDR
// end ; 1 :
54354: GO 55054
54356: LD_INT 1
54358: DOUBLE
54359: EQUAL
54360: IFTRUE 54364
54362: GO 54497
54364: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54365: LD_ADDR_VAR 0 5
54369: PUSH
54370: LD_VAR 0 1
54374: PUSH
54375: LD_VAR 0 2
54379: PUSH
54380: LD_INT 4
54382: MINUS
54383: PUSH
54384: LD_INT 3
54386: PUSH
54387: EMPTY
54388: LIST
54389: LIST
54390: LIST
54391: PUSH
54392: LD_VAR 0 1
54396: PUSH
54397: LD_INT 3
54399: MINUS
54400: PUSH
54401: LD_VAR 0 2
54405: PUSH
54406: LD_INT 3
54408: MINUS
54409: PUSH
54410: LD_INT 2
54412: PUSH
54413: EMPTY
54414: LIST
54415: LIST
54416: LIST
54417: PUSH
54418: LD_VAR 0 1
54422: PUSH
54423: LD_INT 4
54425: MINUS
54426: PUSH
54427: LD_VAR 0 2
54431: PUSH
54432: LD_INT 1
54434: PUSH
54435: EMPTY
54436: LIST
54437: LIST
54438: LIST
54439: PUSH
54440: LD_VAR 0 1
54444: PUSH
54445: LD_VAR 0 2
54449: PUSH
54450: LD_INT 3
54452: PLUS
54453: PUSH
54454: LD_INT 0
54456: PUSH
54457: EMPTY
54458: LIST
54459: LIST
54460: LIST
54461: PUSH
54462: LD_VAR 0 1
54466: PUSH
54467: LD_INT 4
54469: PLUS
54470: PUSH
54471: LD_VAR 0 2
54475: PUSH
54476: LD_INT 4
54478: PLUS
54479: PUSH
54480: LD_INT 5
54482: PUSH
54483: EMPTY
54484: LIST
54485: LIST
54486: LIST
54487: PUSH
54488: EMPTY
54489: LIST
54490: LIST
54491: LIST
54492: LIST
54493: LIST
54494: ST_TO_ADDR
// end ; 2 :
54495: GO 55054
54497: LD_INT 2
54499: DOUBLE
54500: EQUAL
54501: IFTRUE 54505
54503: GO 54634
54505: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54506: LD_ADDR_VAR 0 5
54510: PUSH
54511: LD_VAR 0 1
54515: PUSH
54516: LD_VAR 0 2
54520: PUSH
54521: LD_INT 3
54523: MINUS
54524: PUSH
54525: LD_INT 3
54527: PUSH
54528: EMPTY
54529: LIST
54530: LIST
54531: LIST
54532: PUSH
54533: LD_VAR 0 1
54537: PUSH
54538: LD_INT 4
54540: PLUS
54541: PUSH
54542: LD_VAR 0 2
54546: PUSH
54547: LD_INT 4
54549: PUSH
54550: EMPTY
54551: LIST
54552: LIST
54553: LIST
54554: PUSH
54555: LD_VAR 0 1
54559: PUSH
54560: LD_VAR 0 2
54564: PUSH
54565: LD_INT 4
54567: PLUS
54568: PUSH
54569: LD_INT 0
54571: PUSH
54572: EMPTY
54573: LIST
54574: LIST
54575: LIST
54576: PUSH
54577: LD_VAR 0 1
54581: PUSH
54582: LD_INT 3
54584: MINUS
54585: PUSH
54586: LD_VAR 0 2
54590: PUSH
54591: LD_INT 1
54593: PUSH
54594: EMPTY
54595: LIST
54596: LIST
54597: LIST
54598: PUSH
54599: LD_VAR 0 1
54603: PUSH
54604: LD_INT 4
54606: MINUS
54607: PUSH
54608: LD_VAR 0 2
54612: PUSH
54613: LD_INT 4
54615: MINUS
54616: PUSH
54617: LD_INT 2
54619: PUSH
54620: EMPTY
54621: LIST
54622: LIST
54623: LIST
54624: PUSH
54625: EMPTY
54626: LIST
54627: LIST
54628: LIST
54629: LIST
54630: LIST
54631: ST_TO_ADDR
// end ; 3 :
54632: GO 55054
54634: LD_INT 3
54636: DOUBLE
54637: EQUAL
54638: IFTRUE 54642
54640: GO 54775
54642: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54643: LD_ADDR_VAR 0 5
54647: PUSH
54648: LD_VAR 0 1
54652: PUSH
54653: LD_INT 3
54655: PLUS
54656: PUSH
54657: LD_VAR 0 2
54661: PUSH
54662: LD_INT 4
54664: PUSH
54665: EMPTY
54666: LIST
54667: LIST
54668: LIST
54669: PUSH
54670: LD_VAR 0 1
54674: PUSH
54675: LD_INT 4
54677: PLUS
54678: PUSH
54679: LD_VAR 0 2
54683: PUSH
54684: LD_INT 4
54686: PLUS
54687: PUSH
54688: LD_INT 5
54690: PUSH
54691: EMPTY
54692: LIST
54693: LIST
54694: LIST
54695: PUSH
54696: LD_VAR 0 1
54700: PUSH
54701: LD_INT 4
54703: MINUS
54704: PUSH
54705: LD_VAR 0 2
54709: PUSH
54710: LD_INT 1
54712: PUSH
54713: EMPTY
54714: LIST
54715: LIST
54716: LIST
54717: PUSH
54718: LD_VAR 0 1
54722: PUSH
54723: LD_VAR 0 2
54727: PUSH
54728: LD_INT 4
54730: MINUS
54731: PUSH
54732: LD_INT 3
54734: PUSH
54735: EMPTY
54736: LIST
54737: LIST
54738: LIST
54739: PUSH
54740: LD_VAR 0 1
54744: PUSH
54745: LD_INT 3
54747: MINUS
54748: PUSH
54749: LD_VAR 0 2
54753: PUSH
54754: LD_INT 3
54756: MINUS
54757: PUSH
54758: LD_INT 2
54760: PUSH
54761: EMPTY
54762: LIST
54763: LIST
54764: LIST
54765: PUSH
54766: EMPTY
54767: LIST
54768: LIST
54769: LIST
54770: LIST
54771: LIST
54772: ST_TO_ADDR
// end ; 4 :
54773: GO 55054
54775: LD_INT 4
54777: DOUBLE
54778: EQUAL
54779: IFTRUE 54783
54781: GO 54916
54783: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54784: LD_ADDR_VAR 0 5
54788: PUSH
54789: LD_VAR 0 1
54793: PUSH
54794: LD_VAR 0 2
54798: PUSH
54799: LD_INT 4
54801: PLUS
54802: PUSH
54803: LD_INT 0
54805: PUSH
54806: EMPTY
54807: LIST
54808: LIST
54809: LIST
54810: PUSH
54811: LD_VAR 0 1
54815: PUSH
54816: LD_INT 3
54818: PLUS
54819: PUSH
54820: LD_VAR 0 2
54824: PUSH
54825: LD_INT 3
54827: PLUS
54828: PUSH
54829: LD_INT 5
54831: PUSH
54832: EMPTY
54833: LIST
54834: LIST
54835: LIST
54836: PUSH
54837: LD_VAR 0 1
54841: PUSH
54842: LD_INT 4
54844: PLUS
54845: PUSH
54846: LD_VAR 0 2
54850: PUSH
54851: LD_INT 4
54853: PUSH
54854: EMPTY
54855: LIST
54856: LIST
54857: LIST
54858: PUSH
54859: LD_VAR 0 1
54863: PUSH
54864: LD_VAR 0 2
54868: PUSH
54869: LD_INT 3
54871: MINUS
54872: PUSH
54873: LD_INT 3
54875: PUSH
54876: EMPTY
54877: LIST
54878: LIST
54879: LIST
54880: PUSH
54881: LD_VAR 0 1
54885: PUSH
54886: LD_INT 4
54888: MINUS
54889: PUSH
54890: LD_VAR 0 2
54894: PUSH
54895: LD_INT 4
54897: MINUS
54898: PUSH
54899: LD_INT 2
54901: PUSH
54902: EMPTY
54903: LIST
54904: LIST
54905: LIST
54906: PUSH
54907: EMPTY
54908: LIST
54909: LIST
54910: LIST
54911: LIST
54912: LIST
54913: ST_TO_ADDR
// end ; 5 :
54914: GO 55054
54916: LD_INT 5
54918: DOUBLE
54919: EQUAL
54920: IFTRUE 54924
54922: GO 55053
54924: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54925: LD_ADDR_VAR 0 5
54929: PUSH
54930: LD_VAR 0 1
54934: PUSH
54935: LD_INT 4
54937: MINUS
54938: PUSH
54939: LD_VAR 0 2
54943: PUSH
54944: LD_INT 1
54946: PUSH
54947: EMPTY
54948: LIST
54949: LIST
54950: LIST
54951: PUSH
54952: LD_VAR 0 1
54956: PUSH
54957: LD_VAR 0 2
54961: PUSH
54962: LD_INT 4
54964: MINUS
54965: PUSH
54966: LD_INT 3
54968: PUSH
54969: EMPTY
54970: LIST
54971: LIST
54972: LIST
54973: PUSH
54974: LD_VAR 0 1
54978: PUSH
54979: LD_INT 4
54981: PLUS
54982: PUSH
54983: LD_VAR 0 2
54987: PUSH
54988: LD_INT 4
54990: PLUS
54991: PUSH
54992: LD_INT 5
54994: PUSH
54995: EMPTY
54996: LIST
54997: LIST
54998: LIST
54999: PUSH
55000: LD_VAR 0 1
55004: PUSH
55005: LD_INT 3
55007: PLUS
55008: PUSH
55009: LD_VAR 0 2
55013: PUSH
55014: LD_INT 4
55016: PUSH
55017: EMPTY
55018: LIST
55019: LIST
55020: LIST
55021: PUSH
55022: LD_VAR 0 1
55026: PUSH
55027: LD_VAR 0 2
55031: PUSH
55032: LD_INT 3
55034: PLUS
55035: PUSH
55036: LD_INT 0
55038: PUSH
55039: EMPTY
55040: LIST
55041: LIST
55042: LIST
55043: PUSH
55044: EMPTY
55045: LIST
55046: LIST
55047: LIST
55048: LIST
55049: LIST
55050: ST_TO_ADDR
// end ; end ;
55051: GO 55054
55053: POP
// result := list ;
55054: LD_ADDR_VAR 0 4
55058: PUSH
55059: LD_VAR 0 5
55063: ST_TO_ADDR
// end ;
55064: LD_VAR 0 4
55068: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55069: LD_INT 0
55071: PPUSH
55072: PPUSH
55073: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55074: LD_VAR 0 1
55078: NOT
55079: PUSH
55080: LD_VAR 0 2
55084: PUSH
55085: LD_INT 1
55087: PUSH
55088: LD_INT 2
55090: PUSH
55091: LD_INT 3
55093: PUSH
55094: LD_INT 4
55096: PUSH
55097: EMPTY
55098: LIST
55099: LIST
55100: LIST
55101: LIST
55102: IN
55103: NOT
55104: OR
55105: IFFALSE 55109
// exit ;
55107: GO 55201
// tmp := [ ] ;
55109: LD_ADDR_VAR 0 5
55113: PUSH
55114: EMPTY
55115: ST_TO_ADDR
// for i in units do
55116: LD_ADDR_VAR 0 4
55120: PUSH
55121: LD_VAR 0 1
55125: PUSH
55126: FOR_IN
55127: IFFALSE 55170
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55129: LD_ADDR_VAR 0 5
55133: PUSH
55134: LD_VAR 0 5
55138: PPUSH
55139: LD_VAR 0 5
55143: PUSH
55144: LD_INT 1
55146: PLUS
55147: PPUSH
55148: LD_VAR 0 4
55152: PPUSH
55153: LD_VAR 0 2
55157: PPUSH
55158: CALL_OW 259
55162: PPUSH
55163: CALL_OW 2
55167: ST_TO_ADDR
55168: GO 55126
55170: POP
55171: POP
// if not tmp then
55172: LD_VAR 0 5
55176: NOT
55177: IFFALSE 55181
// exit ;
55179: GO 55201
// result := SortListByListDesc ( units , tmp ) ;
55181: LD_ADDR_VAR 0 3
55185: PUSH
55186: LD_VAR 0 1
55190: PPUSH
55191: LD_VAR 0 5
55195: PPUSH
55196: CALL_OW 77
55200: ST_TO_ADDR
// end ;
55201: LD_VAR 0 3
55205: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55206: LD_INT 0
55208: PPUSH
55209: PPUSH
55210: PPUSH
// x := GetX ( building ) ;
55211: LD_ADDR_VAR 0 4
55215: PUSH
55216: LD_VAR 0 2
55220: PPUSH
55221: CALL_OW 250
55225: ST_TO_ADDR
// y := GetY ( building ) ;
55226: LD_ADDR_VAR 0 5
55230: PUSH
55231: LD_VAR 0 2
55235: PPUSH
55236: CALL_OW 251
55240: ST_TO_ADDR
// if GetTaskList ( unit ) then
55241: LD_VAR 0 1
55245: PPUSH
55246: CALL_OW 437
55250: IFFALSE 55345
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55252: LD_STRING e
55254: PUSH
55255: LD_VAR 0 1
55259: PPUSH
55260: CALL_OW 437
55264: PUSH
55265: LD_INT 1
55267: ARRAY
55268: PUSH
55269: LD_INT 1
55271: ARRAY
55272: EQUAL
55273: PUSH
55274: LD_VAR 0 4
55278: PUSH
55279: LD_VAR 0 1
55283: PPUSH
55284: CALL_OW 437
55288: PUSH
55289: LD_INT 1
55291: ARRAY
55292: PUSH
55293: LD_INT 2
55295: ARRAY
55296: EQUAL
55297: AND
55298: PUSH
55299: LD_VAR 0 5
55303: PUSH
55304: LD_VAR 0 1
55308: PPUSH
55309: CALL_OW 437
55313: PUSH
55314: LD_INT 1
55316: ARRAY
55317: PUSH
55318: LD_INT 3
55320: ARRAY
55321: EQUAL
55322: AND
55323: IFFALSE 55335
// result := true else
55325: LD_ADDR_VAR 0 3
55329: PUSH
55330: LD_INT 1
55332: ST_TO_ADDR
55333: GO 55343
// result := false ;
55335: LD_ADDR_VAR 0 3
55339: PUSH
55340: LD_INT 0
55342: ST_TO_ADDR
// end else
55343: GO 55353
// result := false ;
55345: LD_ADDR_VAR 0 3
55349: PUSH
55350: LD_INT 0
55352: ST_TO_ADDR
// end ;
55353: LD_VAR 0 3
55357: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55358: LD_INT 0
55360: PPUSH
55361: PPUSH
55362: PPUSH
55363: PPUSH
// if not unit or not area then
55364: LD_VAR 0 1
55368: NOT
55369: PUSH
55370: LD_VAR 0 2
55374: NOT
55375: OR
55376: IFFALSE 55380
// exit ;
55378: GO 55544
// tmp := AreaToList ( area , i ) ;
55380: LD_ADDR_VAR 0 6
55384: PUSH
55385: LD_VAR 0 2
55389: PPUSH
55390: LD_VAR 0 5
55394: PPUSH
55395: CALL_OW 517
55399: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55400: LD_ADDR_VAR 0 5
55404: PUSH
55405: DOUBLE
55406: LD_INT 1
55408: DEC
55409: ST_TO_ADDR
55410: LD_VAR 0 6
55414: PUSH
55415: LD_INT 1
55417: ARRAY
55418: PUSH
55419: FOR_TO
55420: IFFALSE 55542
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55422: LD_ADDR_VAR 0 7
55426: PUSH
55427: LD_VAR 0 6
55431: PUSH
55432: LD_INT 1
55434: ARRAY
55435: PUSH
55436: LD_VAR 0 5
55440: ARRAY
55441: PUSH
55442: LD_VAR 0 6
55446: PUSH
55447: LD_INT 2
55449: ARRAY
55450: PUSH
55451: LD_VAR 0 5
55455: ARRAY
55456: PUSH
55457: EMPTY
55458: LIST
55459: LIST
55460: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
55461: LD_VAR 0 7
55465: PUSH
55466: LD_INT 1
55468: ARRAY
55469: PPUSH
55470: LD_VAR 0 7
55474: PUSH
55475: LD_INT 2
55477: ARRAY
55478: PPUSH
55479: CALL_OW 428
55483: PUSH
55484: LD_INT 0
55486: EQUAL
55487: IFFALSE 55540
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55489: LD_VAR 0 1
55493: PPUSH
55494: LD_VAR 0 7
55498: PUSH
55499: LD_INT 1
55501: ARRAY
55502: PPUSH
55503: LD_VAR 0 7
55507: PUSH
55508: LD_INT 2
55510: ARRAY
55511: PPUSH
55512: LD_VAR 0 3
55516: PPUSH
55517: CALL_OW 48
// result := IsPlaced ( unit ) ;
55521: LD_ADDR_VAR 0 4
55525: PUSH
55526: LD_VAR 0 1
55530: PPUSH
55531: CALL_OW 305
55535: ST_TO_ADDR
// exit ;
55536: POP
55537: POP
55538: GO 55544
// end ; end ;
55540: GO 55419
55542: POP
55543: POP
// end ;
55544: LD_VAR 0 4
55548: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55549: LD_INT 0
55551: PPUSH
55552: PPUSH
55553: PPUSH
// if not side or side > 8 then
55554: LD_VAR 0 1
55558: NOT
55559: PUSH
55560: LD_VAR 0 1
55564: PUSH
55565: LD_INT 8
55567: GREATER
55568: OR
55569: IFFALSE 55573
// exit ;
55571: GO 55760
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55573: LD_ADDR_VAR 0 4
55577: PUSH
55578: LD_INT 22
55580: PUSH
55581: LD_VAR 0 1
55585: PUSH
55586: EMPTY
55587: LIST
55588: LIST
55589: PUSH
55590: LD_INT 21
55592: PUSH
55593: LD_INT 3
55595: PUSH
55596: EMPTY
55597: LIST
55598: LIST
55599: PUSH
55600: EMPTY
55601: LIST
55602: LIST
55603: PPUSH
55604: CALL_OW 69
55608: ST_TO_ADDR
// if not tmp then
55609: LD_VAR 0 4
55613: NOT
55614: IFFALSE 55618
// exit ;
55616: GO 55760
// enable_addtolog := true ;
55618: LD_ADDR_OWVAR 81
55622: PUSH
55623: LD_INT 1
55625: ST_TO_ADDR
// AddToLog ( [ ) ;
55626: LD_STRING [
55628: PPUSH
55629: CALL_OW 561
// for i in tmp do
55633: LD_ADDR_VAR 0 3
55637: PUSH
55638: LD_VAR 0 4
55642: PUSH
55643: FOR_IN
55644: IFFALSE 55751
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55646: LD_STRING [
55648: PUSH
55649: LD_VAR 0 3
55653: PPUSH
55654: CALL_OW 266
55658: STR
55659: PUSH
55660: LD_STRING , 
55662: STR
55663: PUSH
55664: LD_VAR 0 3
55668: PPUSH
55669: CALL_OW 250
55673: STR
55674: PUSH
55675: LD_STRING , 
55677: STR
55678: PUSH
55679: LD_VAR 0 3
55683: PPUSH
55684: CALL_OW 251
55688: STR
55689: PUSH
55690: LD_STRING , 
55692: STR
55693: PUSH
55694: LD_VAR 0 3
55698: PPUSH
55699: CALL_OW 254
55703: STR
55704: PUSH
55705: LD_STRING , 
55707: STR
55708: PUSH
55709: LD_VAR 0 3
55713: PPUSH
55714: LD_INT 1
55716: PPUSH
55717: CALL_OW 268
55721: STR
55722: PUSH
55723: LD_STRING , 
55725: STR
55726: PUSH
55727: LD_VAR 0 3
55731: PPUSH
55732: LD_INT 2
55734: PPUSH
55735: CALL_OW 268
55739: STR
55740: PUSH
55741: LD_STRING ],
55743: STR
55744: PPUSH
55745: CALL_OW 561
// end ;
55749: GO 55643
55751: POP
55752: POP
// AddToLog ( ]; ) ;
55753: LD_STRING ];
55755: PPUSH
55756: CALL_OW 561
// end ;
55760: LD_VAR 0 2
55764: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55765: LD_INT 0
55767: PPUSH
55768: PPUSH
55769: PPUSH
55770: PPUSH
55771: PPUSH
// if not area or not rate or not max then
55772: LD_VAR 0 1
55776: NOT
55777: PUSH
55778: LD_VAR 0 2
55782: NOT
55783: OR
55784: PUSH
55785: LD_VAR 0 4
55789: NOT
55790: OR
55791: IFFALSE 55795
// exit ;
55793: GO 55987
// while 1 do
55795: LD_INT 1
55797: IFFALSE 55987
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55799: LD_ADDR_VAR 0 9
55803: PUSH
55804: LD_VAR 0 1
55808: PPUSH
55809: LD_INT 1
55811: PPUSH
55812: CALL_OW 287
55816: PUSH
55817: LD_INT 10
55819: MUL
55820: ST_TO_ADDR
// r := rate / 10 ;
55821: LD_ADDR_VAR 0 7
55825: PUSH
55826: LD_VAR 0 2
55830: PUSH
55831: LD_INT 10
55833: DIVREAL
55834: ST_TO_ADDR
// time := 1 1$00 ;
55835: LD_ADDR_VAR 0 8
55839: PUSH
55840: LD_INT 2100
55842: ST_TO_ADDR
// if amount < min then
55843: LD_VAR 0 9
55847: PUSH
55848: LD_VAR 0 3
55852: LESS
55853: IFFALSE 55871
// r := r * 2 else
55855: LD_ADDR_VAR 0 7
55859: PUSH
55860: LD_VAR 0 7
55864: PUSH
55865: LD_INT 2
55867: MUL
55868: ST_TO_ADDR
55869: GO 55897
// if amount > max then
55871: LD_VAR 0 9
55875: PUSH
55876: LD_VAR 0 4
55880: GREATER
55881: IFFALSE 55897
// r := r / 2 ;
55883: LD_ADDR_VAR 0 7
55887: PUSH
55888: LD_VAR 0 7
55892: PUSH
55893: LD_INT 2
55895: DIVREAL
55896: ST_TO_ADDR
// time := time / r ;
55897: LD_ADDR_VAR 0 8
55901: PUSH
55902: LD_VAR 0 8
55906: PUSH
55907: LD_VAR 0 7
55911: DIVREAL
55912: ST_TO_ADDR
// if time < 0 then
55913: LD_VAR 0 8
55917: PUSH
55918: LD_INT 0
55920: LESS
55921: IFFALSE 55938
// time := time * - 1 ;
55923: LD_ADDR_VAR 0 8
55927: PUSH
55928: LD_VAR 0 8
55932: PUSH
55933: LD_INT 1
55935: NEG
55936: MUL
55937: ST_TO_ADDR
// wait ( time ) ;
55938: LD_VAR 0 8
55942: PPUSH
55943: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
55947: LD_INT 35
55949: PPUSH
55950: LD_INT 875
55952: PPUSH
55953: CALL_OW 12
55957: PPUSH
55958: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55962: LD_INT 1
55964: PPUSH
55965: LD_INT 5
55967: PPUSH
55968: CALL_OW 12
55972: PPUSH
55973: LD_VAR 0 1
55977: PPUSH
55978: LD_INT 1
55980: PPUSH
55981: CALL_OW 55
// end ;
55985: GO 55795
// end ;
55987: LD_VAR 0 5
55991: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55992: LD_INT 0
55994: PPUSH
55995: PPUSH
55996: PPUSH
55997: PPUSH
55998: PPUSH
55999: PPUSH
56000: PPUSH
56001: PPUSH
// if not turrets or not factories then
56002: LD_VAR 0 1
56006: NOT
56007: PUSH
56008: LD_VAR 0 2
56012: NOT
56013: OR
56014: IFFALSE 56018
// exit ;
56016: GO 56325
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56018: LD_ADDR_VAR 0 10
56022: PUSH
56023: LD_INT 5
56025: PUSH
56026: LD_INT 6
56028: PUSH
56029: EMPTY
56030: LIST
56031: LIST
56032: PUSH
56033: LD_INT 2
56035: PUSH
56036: LD_INT 4
56038: PUSH
56039: EMPTY
56040: LIST
56041: LIST
56042: PUSH
56043: LD_INT 3
56045: PUSH
56046: LD_INT 5
56048: PUSH
56049: EMPTY
56050: LIST
56051: LIST
56052: PUSH
56053: EMPTY
56054: LIST
56055: LIST
56056: LIST
56057: PUSH
56058: LD_INT 24
56060: PUSH
56061: LD_INT 25
56063: PUSH
56064: EMPTY
56065: LIST
56066: LIST
56067: PUSH
56068: LD_INT 23
56070: PUSH
56071: LD_INT 27
56073: PUSH
56074: EMPTY
56075: LIST
56076: LIST
56077: PUSH
56078: EMPTY
56079: LIST
56080: LIST
56081: PUSH
56082: LD_INT 42
56084: PUSH
56085: LD_INT 43
56087: PUSH
56088: EMPTY
56089: LIST
56090: LIST
56091: PUSH
56092: LD_INT 44
56094: PUSH
56095: LD_INT 46
56097: PUSH
56098: EMPTY
56099: LIST
56100: LIST
56101: PUSH
56102: LD_INT 45
56104: PUSH
56105: LD_INT 47
56107: PUSH
56108: EMPTY
56109: LIST
56110: LIST
56111: PUSH
56112: EMPTY
56113: LIST
56114: LIST
56115: LIST
56116: PUSH
56117: EMPTY
56118: LIST
56119: LIST
56120: LIST
56121: ST_TO_ADDR
// result := [ ] ;
56122: LD_ADDR_VAR 0 3
56126: PUSH
56127: EMPTY
56128: ST_TO_ADDR
// for i in turrets do
56129: LD_ADDR_VAR 0 4
56133: PUSH
56134: LD_VAR 0 1
56138: PUSH
56139: FOR_IN
56140: IFFALSE 56323
// begin nat := GetNation ( i ) ;
56142: LD_ADDR_VAR 0 7
56146: PUSH
56147: LD_VAR 0 4
56151: PPUSH
56152: CALL_OW 248
56156: ST_TO_ADDR
// weapon := 0 ;
56157: LD_ADDR_VAR 0 8
56161: PUSH
56162: LD_INT 0
56164: ST_TO_ADDR
// if not nat then
56165: LD_VAR 0 7
56169: NOT
56170: IFFALSE 56174
// continue ;
56172: GO 56139
// for j in list [ nat ] do
56174: LD_ADDR_VAR 0 5
56178: PUSH
56179: LD_VAR 0 10
56183: PUSH
56184: LD_VAR 0 7
56188: ARRAY
56189: PUSH
56190: FOR_IN
56191: IFFALSE 56232
// if GetBWeapon ( i ) = j [ 1 ] then
56193: LD_VAR 0 4
56197: PPUSH
56198: CALL_OW 269
56202: PUSH
56203: LD_VAR 0 5
56207: PUSH
56208: LD_INT 1
56210: ARRAY
56211: EQUAL
56212: IFFALSE 56230
// begin weapon := j [ 2 ] ;
56214: LD_ADDR_VAR 0 8
56218: PUSH
56219: LD_VAR 0 5
56223: PUSH
56224: LD_INT 2
56226: ARRAY
56227: ST_TO_ADDR
// break ;
56228: GO 56232
// end ;
56230: GO 56190
56232: POP
56233: POP
// if not weapon then
56234: LD_VAR 0 8
56238: NOT
56239: IFFALSE 56243
// continue ;
56241: GO 56139
// for k in factories do
56243: LD_ADDR_VAR 0 6
56247: PUSH
56248: LD_VAR 0 2
56252: PUSH
56253: FOR_IN
56254: IFFALSE 56319
// begin weapons := AvailableWeaponList ( k ) ;
56256: LD_ADDR_VAR 0 9
56260: PUSH
56261: LD_VAR 0 6
56265: PPUSH
56266: CALL_OW 478
56270: ST_TO_ADDR
// if not weapons then
56271: LD_VAR 0 9
56275: NOT
56276: IFFALSE 56280
// continue ;
56278: GO 56253
// if weapon in weapons then
56280: LD_VAR 0 8
56284: PUSH
56285: LD_VAR 0 9
56289: IN
56290: IFFALSE 56317
// begin result := [ i , weapon ] ;
56292: LD_ADDR_VAR 0 3
56296: PUSH
56297: LD_VAR 0 4
56301: PUSH
56302: LD_VAR 0 8
56306: PUSH
56307: EMPTY
56308: LIST
56309: LIST
56310: ST_TO_ADDR
// exit ;
56311: POP
56312: POP
56313: POP
56314: POP
56315: GO 56325
// end ; end ;
56317: GO 56253
56319: POP
56320: POP
// end ;
56321: GO 56139
56323: POP
56324: POP
// end ;
56325: LD_VAR 0 3
56329: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56330: LD_INT 0
56332: PPUSH
// if not side or side > 8 then
56333: LD_VAR 0 3
56337: NOT
56338: PUSH
56339: LD_VAR 0 3
56343: PUSH
56344: LD_INT 8
56346: GREATER
56347: OR
56348: IFFALSE 56352
// exit ;
56350: GO 56411
// if not range then
56352: LD_VAR 0 4
56356: NOT
56357: IFFALSE 56368
// range := - 12 ;
56359: LD_ADDR_VAR 0 4
56363: PUSH
56364: LD_INT 12
56366: NEG
56367: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56368: LD_VAR 0 1
56372: PPUSH
56373: LD_VAR 0 2
56377: PPUSH
56378: LD_VAR 0 3
56382: PPUSH
56383: LD_VAR 0 4
56387: PPUSH
56388: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56392: LD_VAR 0 1
56396: PPUSH
56397: LD_VAR 0 2
56401: PPUSH
56402: LD_VAR 0 3
56406: PPUSH
56407: CALL_OW 331
// end ;
56411: LD_VAR 0 5
56415: RET
// export function Video ( mode ) ; begin
56416: LD_INT 0
56418: PPUSH
// ingame_video = mode ;
56419: LD_ADDR_OWVAR 52
56423: PUSH
56424: LD_VAR 0 1
56428: ST_TO_ADDR
// interface_hidden = mode ;
56429: LD_ADDR_OWVAR 54
56433: PUSH
56434: LD_VAR 0 1
56438: ST_TO_ADDR
// end ;
56439: LD_VAR 0 2
56443: RET
// export function Join ( array , element ) ; begin
56444: LD_INT 0
56446: PPUSH
// result := array ^ element ;
56447: LD_ADDR_VAR 0 3
56451: PUSH
56452: LD_VAR 0 1
56456: PUSH
56457: LD_VAR 0 2
56461: ADD
56462: ST_TO_ADDR
// end ;
56463: LD_VAR 0 3
56467: RET
// export function JoinUnion ( array , element ) ; begin
56468: LD_INT 0
56470: PPUSH
// result := array union element ;
56471: LD_ADDR_VAR 0 3
56475: PUSH
56476: LD_VAR 0 1
56480: PUSH
56481: LD_VAR 0 2
56485: UNION
56486: ST_TO_ADDR
// end ;
56487: LD_VAR 0 3
56491: RET
// export function GetBehemoths ( side ) ; begin
56492: LD_INT 0
56494: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
56495: LD_ADDR_VAR 0 2
56499: PUSH
56500: LD_INT 22
56502: PUSH
56503: LD_VAR 0 1
56507: PUSH
56508: EMPTY
56509: LIST
56510: LIST
56511: PUSH
56512: LD_INT 31
56514: PUSH
56515: LD_INT 25
56517: PUSH
56518: EMPTY
56519: LIST
56520: LIST
56521: PUSH
56522: EMPTY
56523: LIST
56524: LIST
56525: PPUSH
56526: CALL_OW 69
56530: ST_TO_ADDR
// end ;
56531: LD_VAR 0 2
56535: RET
// export function Shuffle ( array ) ; var i , index ; begin
56536: LD_INT 0
56538: PPUSH
56539: PPUSH
56540: PPUSH
// result := [ ] ;
56541: LD_ADDR_VAR 0 2
56545: PUSH
56546: EMPTY
56547: ST_TO_ADDR
// if not array then
56548: LD_VAR 0 1
56552: NOT
56553: IFFALSE 56557
// exit ;
56555: GO 56656
// Randomize ;
56557: CALL_OW 10
// for i = array downto 1 do
56561: LD_ADDR_VAR 0 3
56565: PUSH
56566: DOUBLE
56567: LD_VAR 0 1
56571: INC
56572: ST_TO_ADDR
56573: LD_INT 1
56575: PUSH
56576: FOR_DOWNTO
56577: IFFALSE 56654
// begin index := rand ( 1 , array ) ;
56579: LD_ADDR_VAR 0 4
56583: PUSH
56584: LD_INT 1
56586: PPUSH
56587: LD_VAR 0 1
56591: PPUSH
56592: CALL_OW 12
56596: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56597: LD_ADDR_VAR 0 2
56601: PUSH
56602: LD_VAR 0 2
56606: PPUSH
56607: LD_VAR 0 2
56611: PUSH
56612: LD_INT 1
56614: PLUS
56615: PPUSH
56616: LD_VAR 0 1
56620: PUSH
56621: LD_VAR 0 4
56625: ARRAY
56626: PPUSH
56627: CALL_OW 2
56631: ST_TO_ADDR
// array := Delete ( array , index ) ;
56632: LD_ADDR_VAR 0 1
56636: PUSH
56637: LD_VAR 0 1
56641: PPUSH
56642: LD_VAR 0 4
56646: PPUSH
56647: CALL_OW 3
56651: ST_TO_ADDR
// end ;
56652: GO 56576
56654: POP
56655: POP
// end ; end_of_file
56656: LD_VAR 0 2
56660: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
56661: LD_INT 0
56663: PPUSH
56664: PPUSH
// skirmish := false ;
56665: LD_ADDR_EXP 56
56669: PUSH
56670: LD_INT 0
56672: ST_TO_ADDR
// debug_mc := false ;
56673: LD_ADDR_EXP 57
56677: PUSH
56678: LD_INT 0
56680: ST_TO_ADDR
// mc_bases := [ ] ;
56681: LD_ADDR_EXP 58
56685: PUSH
56686: EMPTY
56687: ST_TO_ADDR
// mc_sides := [ ] ;
56688: LD_ADDR_EXP 84
56692: PUSH
56693: EMPTY
56694: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
56695: LD_ADDR_EXP 59
56699: PUSH
56700: EMPTY
56701: ST_TO_ADDR
// mc_building_repairs := [ ] ;
56702: LD_ADDR_EXP 60
56706: PUSH
56707: EMPTY
56708: ST_TO_ADDR
// mc_need_heal := [ ] ;
56709: LD_ADDR_EXP 61
56713: PUSH
56714: EMPTY
56715: ST_TO_ADDR
// mc_healers := [ ] ;
56716: LD_ADDR_EXP 62
56720: PUSH
56721: EMPTY
56722: ST_TO_ADDR
// mc_build_list := [ ] ;
56723: LD_ADDR_EXP 63
56727: PUSH
56728: EMPTY
56729: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
56730: LD_ADDR_EXP 90
56734: PUSH
56735: EMPTY
56736: ST_TO_ADDR
// mc_builders := [ ] ;
56737: LD_ADDR_EXP 64
56741: PUSH
56742: EMPTY
56743: ST_TO_ADDR
// mc_construct_list := [ ] ;
56744: LD_ADDR_EXP 65
56748: PUSH
56749: EMPTY
56750: ST_TO_ADDR
// mc_turret_list := [ ] ;
56751: LD_ADDR_EXP 66
56755: PUSH
56756: EMPTY
56757: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
56758: LD_ADDR_EXP 67
56762: PUSH
56763: EMPTY
56764: ST_TO_ADDR
// mc_miners := [ ] ;
56765: LD_ADDR_EXP 72
56769: PUSH
56770: EMPTY
56771: ST_TO_ADDR
// mc_mines := [ ] ;
56772: LD_ADDR_EXP 71
56776: PUSH
56777: EMPTY
56778: ST_TO_ADDR
// mc_minefields := [ ] ;
56779: LD_ADDR_EXP 73
56783: PUSH
56784: EMPTY
56785: ST_TO_ADDR
// mc_crates := [ ] ;
56786: LD_ADDR_EXP 74
56790: PUSH
56791: EMPTY
56792: ST_TO_ADDR
// mc_crates_collector := [ ] ;
56793: LD_ADDR_EXP 75
56797: PUSH
56798: EMPTY
56799: ST_TO_ADDR
// mc_crates_area := [ ] ;
56800: LD_ADDR_EXP 76
56804: PUSH
56805: EMPTY
56806: ST_TO_ADDR
// mc_vehicles := [ ] ;
56807: LD_ADDR_EXP 77
56811: PUSH
56812: EMPTY
56813: ST_TO_ADDR
// mc_attack := [ ] ;
56814: LD_ADDR_EXP 78
56818: PUSH
56819: EMPTY
56820: ST_TO_ADDR
// mc_produce := [ ] ;
56821: LD_ADDR_EXP 79
56825: PUSH
56826: EMPTY
56827: ST_TO_ADDR
// mc_defender := [ ] ;
56828: LD_ADDR_EXP 80
56832: PUSH
56833: EMPTY
56834: ST_TO_ADDR
// mc_parking := [ ] ;
56835: LD_ADDR_EXP 82
56839: PUSH
56840: EMPTY
56841: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
56842: LD_ADDR_EXP 68
56846: PUSH
56847: EMPTY
56848: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
56849: LD_ADDR_EXP 70
56853: PUSH
56854: EMPTY
56855: ST_TO_ADDR
// mc_scan := [ ] ;
56856: LD_ADDR_EXP 81
56860: PUSH
56861: EMPTY
56862: ST_TO_ADDR
// mc_scan_area := [ ] ;
56863: LD_ADDR_EXP 83
56867: PUSH
56868: EMPTY
56869: ST_TO_ADDR
// mc_tech := [ ] ;
56870: LD_ADDR_EXP 85
56874: PUSH
56875: EMPTY
56876: ST_TO_ADDR
// mc_class := [ ] ;
56877: LD_ADDR_EXP 99
56881: PUSH
56882: EMPTY
56883: ST_TO_ADDR
// mc_class_case_use := [ ] ;
56884: LD_ADDR_EXP 100
56888: PUSH
56889: EMPTY
56890: ST_TO_ADDR
// end ;
56891: LD_VAR 0 1
56895: RET
// export function MC_Kill ( base ) ; begin
56896: LD_INT 0
56898: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
56899: LD_ADDR_EXP 58
56903: PUSH
56904: LD_EXP 58
56908: PPUSH
56909: LD_VAR 0 1
56913: PPUSH
56914: EMPTY
56915: PPUSH
56916: CALL_OW 1
56920: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56921: LD_ADDR_EXP 59
56925: PUSH
56926: LD_EXP 59
56930: PPUSH
56931: LD_VAR 0 1
56935: PPUSH
56936: EMPTY
56937: PPUSH
56938: CALL_OW 1
56942: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56943: LD_ADDR_EXP 60
56947: PUSH
56948: LD_EXP 60
56952: PPUSH
56953: LD_VAR 0 1
56957: PPUSH
56958: EMPTY
56959: PPUSH
56960: CALL_OW 1
56964: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56965: LD_ADDR_EXP 61
56969: PUSH
56970: LD_EXP 61
56974: PPUSH
56975: LD_VAR 0 1
56979: PPUSH
56980: EMPTY
56981: PPUSH
56982: CALL_OW 1
56986: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56987: LD_ADDR_EXP 62
56991: PUSH
56992: LD_EXP 62
56996: PPUSH
56997: LD_VAR 0 1
57001: PPUSH
57002: EMPTY
57003: PPUSH
57004: CALL_OW 1
57008: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57009: LD_ADDR_EXP 63
57013: PUSH
57014: LD_EXP 63
57018: PPUSH
57019: LD_VAR 0 1
57023: PPUSH
57024: EMPTY
57025: PPUSH
57026: CALL_OW 1
57030: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57031: LD_ADDR_EXP 64
57035: PUSH
57036: LD_EXP 64
57040: PPUSH
57041: LD_VAR 0 1
57045: PPUSH
57046: EMPTY
57047: PPUSH
57048: CALL_OW 1
57052: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57053: LD_ADDR_EXP 65
57057: PUSH
57058: LD_EXP 65
57062: PPUSH
57063: LD_VAR 0 1
57067: PPUSH
57068: EMPTY
57069: PPUSH
57070: CALL_OW 1
57074: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57075: LD_ADDR_EXP 66
57079: PUSH
57080: LD_EXP 66
57084: PPUSH
57085: LD_VAR 0 1
57089: PPUSH
57090: EMPTY
57091: PPUSH
57092: CALL_OW 1
57096: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57097: LD_ADDR_EXP 67
57101: PUSH
57102: LD_EXP 67
57106: PPUSH
57107: LD_VAR 0 1
57111: PPUSH
57112: EMPTY
57113: PPUSH
57114: CALL_OW 1
57118: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57119: LD_ADDR_EXP 68
57123: PUSH
57124: LD_EXP 68
57128: PPUSH
57129: LD_VAR 0 1
57133: PPUSH
57134: EMPTY
57135: PPUSH
57136: CALL_OW 1
57140: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57141: LD_ADDR_EXP 69
57145: PUSH
57146: LD_EXP 69
57150: PPUSH
57151: LD_VAR 0 1
57155: PPUSH
57156: LD_INT 0
57158: PPUSH
57159: CALL_OW 1
57163: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57164: LD_ADDR_EXP 70
57168: PUSH
57169: LD_EXP 70
57173: PPUSH
57174: LD_VAR 0 1
57178: PPUSH
57179: EMPTY
57180: PPUSH
57181: CALL_OW 1
57185: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57186: LD_ADDR_EXP 71
57190: PUSH
57191: LD_EXP 71
57195: PPUSH
57196: LD_VAR 0 1
57200: PPUSH
57201: EMPTY
57202: PPUSH
57203: CALL_OW 1
57207: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57208: LD_ADDR_EXP 72
57212: PUSH
57213: LD_EXP 72
57217: PPUSH
57218: LD_VAR 0 1
57222: PPUSH
57223: EMPTY
57224: PPUSH
57225: CALL_OW 1
57229: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57230: LD_ADDR_EXP 73
57234: PUSH
57235: LD_EXP 73
57239: PPUSH
57240: LD_VAR 0 1
57244: PPUSH
57245: EMPTY
57246: PPUSH
57247: CALL_OW 1
57251: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57252: LD_ADDR_EXP 74
57256: PUSH
57257: LD_EXP 74
57261: PPUSH
57262: LD_VAR 0 1
57266: PPUSH
57267: EMPTY
57268: PPUSH
57269: CALL_OW 1
57273: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57274: LD_ADDR_EXP 75
57278: PUSH
57279: LD_EXP 75
57283: PPUSH
57284: LD_VAR 0 1
57288: PPUSH
57289: EMPTY
57290: PPUSH
57291: CALL_OW 1
57295: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57296: LD_ADDR_EXP 76
57300: PUSH
57301: LD_EXP 76
57305: PPUSH
57306: LD_VAR 0 1
57310: PPUSH
57311: EMPTY
57312: PPUSH
57313: CALL_OW 1
57317: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57318: LD_ADDR_EXP 77
57322: PUSH
57323: LD_EXP 77
57327: PPUSH
57328: LD_VAR 0 1
57332: PPUSH
57333: EMPTY
57334: PPUSH
57335: CALL_OW 1
57339: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57340: LD_ADDR_EXP 78
57344: PUSH
57345: LD_EXP 78
57349: PPUSH
57350: LD_VAR 0 1
57354: PPUSH
57355: EMPTY
57356: PPUSH
57357: CALL_OW 1
57361: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57362: LD_ADDR_EXP 79
57366: PUSH
57367: LD_EXP 79
57371: PPUSH
57372: LD_VAR 0 1
57376: PPUSH
57377: EMPTY
57378: PPUSH
57379: CALL_OW 1
57383: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57384: LD_ADDR_EXP 80
57388: PUSH
57389: LD_EXP 80
57393: PPUSH
57394: LD_VAR 0 1
57398: PPUSH
57399: EMPTY
57400: PPUSH
57401: CALL_OW 1
57405: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57406: LD_ADDR_EXP 81
57410: PUSH
57411: LD_EXP 81
57415: PPUSH
57416: LD_VAR 0 1
57420: PPUSH
57421: EMPTY
57422: PPUSH
57423: CALL_OW 1
57427: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57428: LD_ADDR_EXP 82
57432: PUSH
57433: LD_EXP 82
57437: PPUSH
57438: LD_VAR 0 1
57442: PPUSH
57443: EMPTY
57444: PPUSH
57445: CALL_OW 1
57449: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57450: LD_ADDR_EXP 83
57454: PUSH
57455: LD_EXP 83
57459: PPUSH
57460: LD_VAR 0 1
57464: PPUSH
57465: EMPTY
57466: PPUSH
57467: CALL_OW 1
57471: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57472: LD_ADDR_EXP 85
57476: PUSH
57477: LD_EXP 85
57481: PPUSH
57482: LD_VAR 0 1
57486: PPUSH
57487: EMPTY
57488: PPUSH
57489: CALL_OW 1
57493: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57494: LD_ADDR_EXP 87
57498: PUSH
57499: LD_EXP 87
57503: PPUSH
57504: LD_VAR 0 1
57508: PPUSH
57509: EMPTY
57510: PPUSH
57511: CALL_OW 1
57515: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57516: LD_ADDR_EXP 88
57520: PUSH
57521: LD_EXP 88
57525: PPUSH
57526: LD_VAR 0 1
57530: PPUSH
57531: EMPTY
57532: PPUSH
57533: CALL_OW 1
57537: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57538: LD_ADDR_EXP 89
57542: PUSH
57543: LD_EXP 89
57547: PPUSH
57548: LD_VAR 0 1
57552: PPUSH
57553: EMPTY
57554: PPUSH
57555: CALL_OW 1
57559: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57560: LD_ADDR_EXP 90
57564: PUSH
57565: LD_EXP 90
57569: PPUSH
57570: LD_VAR 0 1
57574: PPUSH
57575: EMPTY
57576: PPUSH
57577: CALL_OW 1
57581: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57582: LD_ADDR_EXP 91
57586: PUSH
57587: LD_EXP 91
57591: PPUSH
57592: LD_VAR 0 1
57596: PPUSH
57597: EMPTY
57598: PPUSH
57599: CALL_OW 1
57603: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57604: LD_ADDR_EXP 92
57608: PUSH
57609: LD_EXP 92
57613: PPUSH
57614: LD_VAR 0 1
57618: PPUSH
57619: EMPTY
57620: PPUSH
57621: CALL_OW 1
57625: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57626: LD_ADDR_EXP 93
57630: PUSH
57631: LD_EXP 93
57635: PPUSH
57636: LD_VAR 0 1
57640: PPUSH
57641: EMPTY
57642: PPUSH
57643: CALL_OW 1
57647: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57648: LD_ADDR_EXP 94
57652: PUSH
57653: LD_EXP 94
57657: PPUSH
57658: LD_VAR 0 1
57662: PPUSH
57663: EMPTY
57664: PPUSH
57665: CALL_OW 1
57669: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57670: LD_ADDR_EXP 95
57674: PUSH
57675: LD_EXP 95
57679: PPUSH
57680: LD_VAR 0 1
57684: PPUSH
57685: EMPTY
57686: PPUSH
57687: CALL_OW 1
57691: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57692: LD_ADDR_EXP 96
57696: PUSH
57697: LD_EXP 96
57701: PPUSH
57702: LD_VAR 0 1
57706: PPUSH
57707: EMPTY
57708: PPUSH
57709: CALL_OW 1
57713: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57714: LD_ADDR_EXP 97
57718: PUSH
57719: LD_EXP 97
57723: PPUSH
57724: LD_VAR 0 1
57728: PPUSH
57729: EMPTY
57730: PPUSH
57731: CALL_OW 1
57735: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57736: LD_ADDR_EXP 98
57740: PUSH
57741: LD_EXP 98
57745: PPUSH
57746: LD_VAR 0 1
57750: PPUSH
57751: EMPTY
57752: PPUSH
57753: CALL_OW 1
57757: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57758: LD_ADDR_EXP 99
57762: PUSH
57763: LD_EXP 99
57767: PPUSH
57768: LD_VAR 0 1
57772: PPUSH
57773: EMPTY
57774: PPUSH
57775: CALL_OW 1
57779: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57780: LD_ADDR_EXP 100
57784: PUSH
57785: LD_EXP 100
57789: PPUSH
57790: LD_VAR 0 1
57794: PPUSH
57795: LD_INT 0
57797: PPUSH
57798: CALL_OW 1
57802: ST_TO_ADDR
// end ;
57803: LD_VAR 0 2
57807: RET
// export function MC_Add ( side , units ) ; var base ; begin
57808: LD_INT 0
57810: PPUSH
57811: PPUSH
// base := mc_bases + 1 ;
57812: LD_ADDR_VAR 0 4
57816: PUSH
57817: LD_EXP 58
57821: PUSH
57822: LD_INT 1
57824: PLUS
57825: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
57826: LD_ADDR_EXP 84
57830: PUSH
57831: LD_EXP 84
57835: PPUSH
57836: LD_VAR 0 4
57840: PPUSH
57841: LD_VAR 0 1
57845: PPUSH
57846: CALL_OW 1
57850: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
57851: LD_ADDR_EXP 58
57855: PUSH
57856: LD_EXP 58
57860: PPUSH
57861: LD_VAR 0 4
57865: PPUSH
57866: LD_VAR 0 2
57870: PPUSH
57871: CALL_OW 1
57875: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57876: LD_ADDR_EXP 59
57880: PUSH
57881: LD_EXP 59
57885: PPUSH
57886: LD_VAR 0 4
57890: PPUSH
57891: EMPTY
57892: PPUSH
57893: CALL_OW 1
57897: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57898: LD_ADDR_EXP 60
57902: PUSH
57903: LD_EXP 60
57907: PPUSH
57908: LD_VAR 0 4
57912: PPUSH
57913: EMPTY
57914: PPUSH
57915: CALL_OW 1
57919: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57920: LD_ADDR_EXP 61
57924: PUSH
57925: LD_EXP 61
57929: PPUSH
57930: LD_VAR 0 4
57934: PPUSH
57935: EMPTY
57936: PPUSH
57937: CALL_OW 1
57941: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57942: LD_ADDR_EXP 62
57946: PUSH
57947: LD_EXP 62
57951: PPUSH
57952: LD_VAR 0 4
57956: PPUSH
57957: EMPTY
57958: PPUSH
57959: CALL_OW 1
57963: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57964: LD_ADDR_EXP 63
57968: PUSH
57969: LD_EXP 63
57973: PPUSH
57974: LD_VAR 0 4
57978: PPUSH
57979: EMPTY
57980: PPUSH
57981: CALL_OW 1
57985: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57986: LD_ADDR_EXP 64
57990: PUSH
57991: LD_EXP 64
57995: PPUSH
57996: LD_VAR 0 4
58000: PPUSH
58001: EMPTY
58002: PPUSH
58003: CALL_OW 1
58007: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
58008: LD_ADDR_EXP 65
58012: PUSH
58013: LD_EXP 65
58017: PPUSH
58018: LD_VAR 0 4
58022: PPUSH
58023: EMPTY
58024: PPUSH
58025: CALL_OW 1
58029: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
58030: LD_ADDR_EXP 66
58034: PUSH
58035: LD_EXP 66
58039: PPUSH
58040: LD_VAR 0 4
58044: PPUSH
58045: EMPTY
58046: PPUSH
58047: CALL_OW 1
58051: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58052: LD_ADDR_EXP 67
58056: PUSH
58057: LD_EXP 67
58061: PPUSH
58062: LD_VAR 0 4
58066: PPUSH
58067: EMPTY
58068: PPUSH
58069: CALL_OW 1
58073: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58074: LD_ADDR_EXP 68
58078: PUSH
58079: LD_EXP 68
58083: PPUSH
58084: LD_VAR 0 4
58088: PPUSH
58089: EMPTY
58090: PPUSH
58091: CALL_OW 1
58095: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58096: LD_ADDR_EXP 69
58100: PUSH
58101: LD_EXP 69
58105: PPUSH
58106: LD_VAR 0 4
58110: PPUSH
58111: LD_INT 0
58113: PPUSH
58114: CALL_OW 1
58118: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58119: LD_ADDR_EXP 70
58123: PUSH
58124: LD_EXP 70
58128: PPUSH
58129: LD_VAR 0 4
58133: PPUSH
58134: EMPTY
58135: PPUSH
58136: CALL_OW 1
58140: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
58141: LD_ADDR_EXP 71
58145: PUSH
58146: LD_EXP 71
58150: PPUSH
58151: LD_VAR 0 4
58155: PPUSH
58156: EMPTY
58157: PPUSH
58158: CALL_OW 1
58162: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58163: LD_ADDR_EXP 72
58167: PUSH
58168: LD_EXP 72
58172: PPUSH
58173: LD_VAR 0 4
58177: PPUSH
58178: EMPTY
58179: PPUSH
58180: CALL_OW 1
58184: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58185: LD_ADDR_EXP 73
58189: PUSH
58190: LD_EXP 73
58194: PPUSH
58195: LD_VAR 0 4
58199: PPUSH
58200: EMPTY
58201: PPUSH
58202: CALL_OW 1
58206: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58207: LD_ADDR_EXP 74
58211: PUSH
58212: LD_EXP 74
58216: PPUSH
58217: LD_VAR 0 4
58221: PPUSH
58222: EMPTY
58223: PPUSH
58224: CALL_OW 1
58228: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58229: LD_ADDR_EXP 75
58233: PUSH
58234: LD_EXP 75
58238: PPUSH
58239: LD_VAR 0 4
58243: PPUSH
58244: EMPTY
58245: PPUSH
58246: CALL_OW 1
58250: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58251: LD_ADDR_EXP 76
58255: PUSH
58256: LD_EXP 76
58260: PPUSH
58261: LD_VAR 0 4
58265: PPUSH
58266: EMPTY
58267: PPUSH
58268: CALL_OW 1
58272: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58273: LD_ADDR_EXP 77
58277: PUSH
58278: LD_EXP 77
58282: PPUSH
58283: LD_VAR 0 4
58287: PPUSH
58288: EMPTY
58289: PPUSH
58290: CALL_OW 1
58294: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58295: LD_ADDR_EXP 78
58299: PUSH
58300: LD_EXP 78
58304: PPUSH
58305: LD_VAR 0 4
58309: PPUSH
58310: EMPTY
58311: PPUSH
58312: CALL_OW 1
58316: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58317: LD_ADDR_EXP 79
58321: PUSH
58322: LD_EXP 79
58326: PPUSH
58327: LD_VAR 0 4
58331: PPUSH
58332: EMPTY
58333: PPUSH
58334: CALL_OW 1
58338: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58339: LD_ADDR_EXP 80
58343: PUSH
58344: LD_EXP 80
58348: PPUSH
58349: LD_VAR 0 4
58353: PPUSH
58354: EMPTY
58355: PPUSH
58356: CALL_OW 1
58360: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58361: LD_ADDR_EXP 81
58365: PUSH
58366: LD_EXP 81
58370: PPUSH
58371: LD_VAR 0 4
58375: PPUSH
58376: EMPTY
58377: PPUSH
58378: CALL_OW 1
58382: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58383: LD_ADDR_EXP 82
58387: PUSH
58388: LD_EXP 82
58392: PPUSH
58393: LD_VAR 0 4
58397: PPUSH
58398: EMPTY
58399: PPUSH
58400: CALL_OW 1
58404: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58405: LD_ADDR_EXP 83
58409: PUSH
58410: LD_EXP 83
58414: PPUSH
58415: LD_VAR 0 4
58419: PPUSH
58420: EMPTY
58421: PPUSH
58422: CALL_OW 1
58426: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58427: LD_ADDR_EXP 85
58431: PUSH
58432: LD_EXP 85
58436: PPUSH
58437: LD_VAR 0 4
58441: PPUSH
58442: EMPTY
58443: PPUSH
58444: CALL_OW 1
58448: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58449: LD_ADDR_EXP 87
58453: PUSH
58454: LD_EXP 87
58458: PPUSH
58459: LD_VAR 0 4
58463: PPUSH
58464: EMPTY
58465: PPUSH
58466: CALL_OW 1
58470: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58471: LD_ADDR_EXP 88
58475: PUSH
58476: LD_EXP 88
58480: PPUSH
58481: LD_VAR 0 4
58485: PPUSH
58486: EMPTY
58487: PPUSH
58488: CALL_OW 1
58492: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58493: LD_ADDR_EXP 89
58497: PUSH
58498: LD_EXP 89
58502: PPUSH
58503: LD_VAR 0 4
58507: PPUSH
58508: EMPTY
58509: PPUSH
58510: CALL_OW 1
58514: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58515: LD_ADDR_EXP 90
58519: PUSH
58520: LD_EXP 90
58524: PPUSH
58525: LD_VAR 0 4
58529: PPUSH
58530: EMPTY
58531: PPUSH
58532: CALL_OW 1
58536: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58537: LD_ADDR_EXP 91
58541: PUSH
58542: LD_EXP 91
58546: PPUSH
58547: LD_VAR 0 4
58551: PPUSH
58552: EMPTY
58553: PPUSH
58554: CALL_OW 1
58558: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58559: LD_ADDR_EXP 92
58563: PUSH
58564: LD_EXP 92
58568: PPUSH
58569: LD_VAR 0 4
58573: PPUSH
58574: EMPTY
58575: PPUSH
58576: CALL_OW 1
58580: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58581: LD_ADDR_EXP 93
58585: PUSH
58586: LD_EXP 93
58590: PPUSH
58591: LD_VAR 0 4
58595: PPUSH
58596: EMPTY
58597: PPUSH
58598: CALL_OW 1
58602: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58603: LD_ADDR_EXP 94
58607: PUSH
58608: LD_EXP 94
58612: PPUSH
58613: LD_VAR 0 4
58617: PPUSH
58618: EMPTY
58619: PPUSH
58620: CALL_OW 1
58624: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58625: LD_ADDR_EXP 95
58629: PUSH
58630: LD_EXP 95
58634: PPUSH
58635: LD_VAR 0 4
58639: PPUSH
58640: EMPTY
58641: PPUSH
58642: CALL_OW 1
58646: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58647: LD_ADDR_EXP 96
58651: PUSH
58652: LD_EXP 96
58656: PPUSH
58657: LD_VAR 0 4
58661: PPUSH
58662: EMPTY
58663: PPUSH
58664: CALL_OW 1
58668: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58669: LD_ADDR_EXP 97
58673: PUSH
58674: LD_EXP 97
58678: PPUSH
58679: LD_VAR 0 4
58683: PPUSH
58684: EMPTY
58685: PPUSH
58686: CALL_OW 1
58690: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58691: LD_ADDR_EXP 98
58695: PUSH
58696: LD_EXP 98
58700: PPUSH
58701: LD_VAR 0 4
58705: PPUSH
58706: EMPTY
58707: PPUSH
58708: CALL_OW 1
58712: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58713: LD_ADDR_EXP 99
58717: PUSH
58718: LD_EXP 99
58722: PPUSH
58723: LD_VAR 0 4
58727: PPUSH
58728: EMPTY
58729: PPUSH
58730: CALL_OW 1
58734: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58735: LD_ADDR_EXP 100
58739: PUSH
58740: LD_EXP 100
58744: PPUSH
58745: LD_VAR 0 4
58749: PPUSH
58750: LD_INT 0
58752: PPUSH
58753: CALL_OW 1
58757: ST_TO_ADDR
// result := base ;
58758: LD_ADDR_VAR 0 3
58762: PUSH
58763: LD_VAR 0 4
58767: ST_TO_ADDR
// end ;
58768: LD_VAR 0 3
58772: RET
// export function MC_Start ( ) ; var i ; begin
58773: LD_INT 0
58775: PPUSH
58776: PPUSH
// for i = 1 to mc_bases do
58777: LD_ADDR_VAR 0 2
58781: PUSH
58782: DOUBLE
58783: LD_INT 1
58785: DEC
58786: ST_TO_ADDR
58787: LD_EXP 58
58791: PUSH
58792: FOR_TO
58793: IFFALSE 59870
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
58795: LD_ADDR_EXP 58
58799: PUSH
58800: LD_EXP 58
58804: PPUSH
58805: LD_VAR 0 2
58809: PPUSH
58810: LD_EXP 58
58814: PUSH
58815: LD_VAR 0 2
58819: ARRAY
58820: PUSH
58821: LD_INT 0
58823: DIFF
58824: PPUSH
58825: CALL_OW 1
58829: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
58830: LD_ADDR_EXP 59
58834: PUSH
58835: LD_EXP 59
58839: PPUSH
58840: LD_VAR 0 2
58844: PPUSH
58845: EMPTY
58846: PPUSH
58847: CALL_OW 1
58851: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
58852: LD_ADDR_EXP 60
58856: PUSH
58857: LD_EXP 60
58861: PPUSH
58862: LD_VAR 0 2
58866: PPUSH
58867: EMPTY
58868: PPUSH
58869: CALL_OW 1
58873: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
58874: LD_ADDR_EXP 61
58878: PUSH
58879: LD_EXP 61
58883: PPUSH
58884: LD_VAR 0 2
58888: PPUSH
58889: EMPTY
58890: PPUSH
58891: CALL_OW 1
58895: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
58896: LD_ADDR_EXP 62
58900: PUSH
58901: LD_EXP 62
58905: PPUSH
58906: LD_VAR 0 2
58910: PPUSH
58911: EMPTY
58912: PUSH
58913: EMPTY
58914: PUSH
58915: EMPTY
58916: LIST
58917: LIST
58918: PPUSH
58919: CALL_OW 1
58923: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
58924: LD_ADDR_EXP 63
58928: PUSH
58929: LD_EXP 63
58933: PPUSH
58934: LD_VAR 0 2
58938: PPUSH
58939: EMPTY
58940: PPUSH
58941: CALL_OW 1
58945: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
58946: LD_ADDR_EXP 90
58950: PUSH
58951: LD_EXP 90
58955: PPUSH
58956: LD_VAR 0 2
58960: PPUSH
58961: EMPTY
58962: PPUSH
58963: CALL_OW 1
58967: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
58968: LD_ADDR_EXP 64
58972: PUSH
58973: LD_EXP 64
58977: PPUSH
58978: LD_VAR 0 2
58982: PPUSH
58983: EMPTY
58984: PPUSH
58985: CALL_OW 1
58989: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
58990: LD_ADDR_EXP 65
58994: PUSH
58995: LD_EXP 65
58999: PPUSH
59000: LD_VAR 0 2
59004: PPUSH
59005: EMPTY
59006: PPUSH
59007: CALL_OW 1
59011: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
59012: LD_ADDR_EXP 66
59016: PUSH
59017: LD_EXP 66
59021: PPUSH
59022: LD_VAR 0 2
59026: PPUSH
59027: LD_EXP 58
59031: PUSH
59032: LD_VAR 0 2
59036: ARRAY
59037: PPUSH
59038: LD_INT 2
59040: PUSH
59041: LD_INT 30
59043: PUSH
59044: LD_INT 32
59046: PUSH
59047: EMPTY
59048: LIST
59049: LIST
59050: PUSH
59051: LD_INT 30
59053: PUSH
59054: LD_INT 33
59056: PUSH
59057: EMPTY
59058: LIST
59059: LIST
59060: PUSH
59061: EMPTY
59062: LIST
59063: LIST
59064: LIST
59065: PPUSH
59066: CALL_OW 72
59070: PPUSH
59071: CALL_OW 1
59075: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
59076: LD_ADDR_EXP 67
59080: PUSH
59081: LD_EXP 67
59085: PPUSH
59086: LD_VAR 0 2
59090: PPUSH
59091: LD_EXP 58
59095: PUSH
59096: LD_VAR 0 2
59100: ARRAY
59101: PPUSH
59102: LD_INT 2
59104: PUSH
59105: LD_INT 30
59107: PUSH
59108: LD_INT 32
59110: PUSH
59111: EMPTY
59112: LIST
59113: LIST
59114: PUSH
59115: LD_INT 30
59117: PUSH
59118: LD_INT 31
59120: PUSH
59121: EMPTY
59122: LIST
59123: LIST
59124: PUSH
59125: EMPTY
59126: LIST
59127: LIST
59128: LIST
59129: PUSH
59130: LD_INT 58
59132: PUSH
59133: EMPTY
59134: LIST
59135: PUSH
59136: EMPTY
59137: LIST
59138: LIST
59139: PPUSH
59140: CALL_OW 72
59144: PPUSH
59145: CALL_OW 1
59149: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
59150: LD_ADDR_EXP 68
59154: PUSH
59155: LD_EXP 68
59159: PPUSH
59160: LD_VAR 0 2
59164: PPUSH
59165: EMPTY
59166: PPUSH
59167: CALL_OW 1
59171: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
59172: LD_ADDR_EXP 72
59176: PUSH
59177: LD_EXP 72
59181: PPUSH
59182: LD_VAR 0 2
59186: PPUSH
59187: EMPTY
59188: PPUSH
59189: CALL_OW 1
59193: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
59194: LD_ADDR_EXP 71
59198: PUSH
59199: LD_EXP 71
59203: PPUSH
59204: LD_VAR 0 2
59208: PPUSH
59209: EMPTY
59210: PPUSH
59211: CALL_OW 1
59215: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
59216: LD_ADDR_EXP 73
59220: PUSH
59221: LD_EXP 73
59225: PPUSH
59226: LD_VAR 0 2
59230: PPUSH
59231: EMPTY
59232: PPUSH
59233: CALL_OW 1
59237: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
59238: LD_ADDR_EXP 74
59242: PUSH
59243: LD_EXP 74
59247: PPUSH
59248: LD_VAR 0 2
59252: PPUSH
59253: EMPTY
59254: PPUSH
59255: CALL_OW 1
59259: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
59260: LD_ADDR_EXP 75
59264: PUSH
59265: LD_EXP 75
59269: PPUSH
59270: LD_VAR 0 2
59274: PPUSH
59275: EMPTY
59276: PPUSH
59277: CALL_OW 1
59281: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
59282: LD_ADDR_EXP 76
59286: PUSH
59287: LD_EXP 76
59291: PPUSH
59292: LD_VAR 0 2
59296: PPUSH
59297: EMPTY
59298: PPUSH
59299: CALL_OW 1
59303: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
59304: LD_ADDR_EXP 77
59308: PUSH
59309: LD_EXP 77
59313: PPUSH
59314: LD_VAR 0 2
59318: PPUSH
59319: EMPTY
59320: PPUSH
59321: CALL_OW 1
59325: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
59326: LD_ADDR_EXP 78
59330: PUSH
59331: LD_EXP 78
59335: PPUSH
59336: LD_VAR 0 2
59340: PPUSH
59341: EMPTY
59342: PPUSH
59343: CALL_OW 1
59347: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
59348: LD_ADDR_EXP 79
59352: PUSH
59353: LD_EXP 79
59357: PPUSH
59358: LD_VAR 0 2
59362: PPUSH
59363: EMPTY
59364: PPUSH
59365: CALL_OW 1
59369: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
59370: LD_ADDR_EXP 80
59374: PUSH
59375: LD_EXP 80
59379: PPUSH
59380: LD_VAR 0 2
59384: PPUSH
59385: EMPTY
59386: PPUSH
59387: CALL_OW 1
59391: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
59392: LD_ADDR_EXP 69
59396: PUSH
59397: LD_EXP 69
59401: PPUSH
59402: LD_VAR 0 2
59406: PPUSH
59407: LD_INT 0
59409: PPUSH
59410: CALL_OW 1
59414: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
59415: LD_ADDR_EXP 82
59419: PUSH
59420: LD_EXP 82
59424: PPUSH
59425: LD_VAR 0 2
59429: PPUSH
59430: LD_INT 0
59432: PPUSH
59433: CALL_OW 1
59437: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59438: LD_ADDR_EXP 70
59442: PUSH
59443: LD_EXP 70
59447: PPUSH
59448: LD_VAR 0 2
59452: PPUSH
59453: EMPTY
59454: PPUSH
59455: CALL_OW 1
59459: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
59460: LD_ADDR_EXP 81
59464: PUSH
59465: LD_EXP 81
59469: PPUSH
59470: LD_VAR 0 2
59474: PPUSH
59475: LD_INT 0
59477: PPUSH
59478: CALL_OW 1
59482: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
59483: LD_ADDR_EXP 83
59487: PUSH
59488: LD_EXP 83
59492: PPUSH
59493: LD_VAR 0 2
59497: PPUSH
59498: EMPTY
59499: PPUSH
59500: CALL_OW 1
59504: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
59505: LD_ADDR_EXP 86
59509: PUSH
59510: LD_EXP 86
59514: PPUSH
59515: LD_VAR 0 2
59519: PPUSH
59520: LD_INT 0
59522: PPUSH
59523: CALL_OW 1
59527: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
59528: LD_ADDR_EXP 87
59532: PUSH
59533: LD_EXP 87
59537: PPUSH
59538: LD_VAR 0 2
59542: PPUSH
59543: EMPTY
59544: PPUSH
59545: CALL_OW 1
59549: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
59550: LD_ADDR_EXP 88
59554: PUSH
59555: LD_EXP 88
59559: PPUSH
59560: LD_VAR 0 2
59564: PPUSH
59565: EMPTY
59566: PPUSH
59567: CALL_OW 1
59571: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59572: LD_ADDR_EXP 89
59576: PUSH
59577: LD_EXP 89
59581: PPUSH
59582: LD_VAR 0 2
59586: PPUSH
59587: EMPTY
59588: PPUSH
59589: CALL_OW 1
59593: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
59594: LD_ADDR_EXP 91
59598: PUSH
59599: LD_EXP 91
59603: PPUSH
59604: LD_VAR 0 2
59608: PPUSH
59609: LD_EXP 58
59613: PUSH
59614: LD_VAR 0 2
59618: ARRAY
59619: PPUSH
59620: LD_INT 2
59622: PUSH
59623: LD_INT 30
59625: PUSH
59626: LD_INT 6
59628: PUSH
59629: EMPTY
59630: LIST
59631: LIST
59632: PUSH
59633: LD_INT 30
59635: PUSH
59636: LD_INT 7
59638: PUSH
59639: EMPTY
59640: LIST
59641: LIST
59642: PUSH
59643: LD_INT 30
59645: PUSH
59646: LD_INT 8
59648: PUSH
59649: EMPTY
59650: LIST
59651: LIST
59652: PUSH
59653: EMPTY
59654: LIST
59655: LIST
59656: LIST
59657: LIST
59658: PPUSH
59659: CALL_OW 72
59663: PPUSH
59664: CALL_OW 1
59668: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
59669: LD_ADDR_EXP 92
59673: PUSH
59674: LD_EXP 92
59678: PPUSH
59679: LD_VAR 0 2
59683: PPUSH
59684: EMPTY
59685: PPUSH
59686: CALL_OW 1
59690: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
59691: LD_ADDR_EXP 93
59695: PUSH
59696: LD_EXP 93
59700: PPUSH
59701: LD_VAR 0 2
59705: PPUSH
59706: EMPTY
59707: PPUSH
59708: CALL_OW 1
59712: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
59713: LD_ADDR_EXP 94
59717: PUSH
59718: LD_EXP 94
59722: PPUSH
59723: LD_VAR 0 2
59727: PPUSH
59728: EMPTY
59729: PPUSH
59730: CALL_OW 1
59734: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
59735: LD_ADDR_EXP 95
59739: PUSH
59740: LD_EXP 95
59744: PPUSH
59745: LD_VAR 0 2
59749: PPUSH
59750: EMPTY
59751: PPUSH
59752: CALL_OW 1
59756: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59757: LD_ADDR_EXP 96
59761: PUSH
59762: LD_EXP 96
59766: PPUSH
59767: LD_VAR 0 2
59771: PPUSH
59772: EMPTY
59773: PPUSH
59774: CALL_OW 1
59778: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
59779: LD_ADDR_EXP 97
59783: PUSH
59784: LD_EXP 97
59788: PPUSH
59789: LD_VAR 0 2
59793: PPUSH
59794: EMPTY
59795: PPUSH
59796: CALL_OW 1
59800: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
59801: LD_ADDR_EXP 98
59805: PUSH
59806: LD_EXP 98
59810: PPUSH
59811: LD_VAR 0 2
59815: PPUSH
59816: EMPTY
59817: PPUSH
59818: CALL_OW 1
59822: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
59823: LD_ADDR_EXP 99
59827: PUSH
59828: LD_EXP 99
59832: PPUSH
59833: LD_VAR 0 2
59837: PPUSH
59838: EMPTY
59839: PPUSH
59840: CALL_OW 1
59844: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
59845: LD_ADDR_EXP 100
59849: PUSH
59850: LD_EXP 100
59854: PPUSH
59855: LD_VAR 0 2
59859: PPUSH
59860: LD_INT 0
59862: PPUSH
59863: CALL_OW 1
59867: ST_TO_ADDR
// end ;
59868: GO 58792
59870: POP
59871: POP
// MC_InitSides ( ) ;
59872: CALL 60158 0 0
// MC_InitResearch ( ) ;
59876: CALL 59897 0 0
// CustomInitMacro ( ) ;
59880: CALL 181 0 0
// skirmish := true ;
59884: LD_ADDR_EXP 56
59888: PUSH
59889: LD_INT 1
59891: ST_TO_ADDR
// end ;
59892: LD_VAR 0 1
59896: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
59897: LD_INT 0
59899: PPUSH
59900: PPUSH
59901: PPUSH
59902: PPUSH
59903: PPUSH
59904: PPUSH
// if not mc_bases then
59905: LD_EXP 58
59909: NOT
59910: IFFALSE 59914
// exit ;
59912: GO 60153
// for i = 1 to 8 do
59914: LD_ADDR_VAR 0 2
59918: PUSH
59919: DOUBLE
59920: LD_INT 1
59922: DEC
59923: ST_TO_ADDR
59924: LD_INT 8
59926: PUSH
59927: FOR_TO
59928: IFFALSE 59954
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
59930: LD_ADDR_EXP 85
59934: PUSH
59935: LD_EXP 85
59939: PPUSH
59940: LD_VAR 0 2
59944: PPUSH
59945: EMPTY
59946: PPUSH
59947: CALL_OW 1
59951: ST_TO_ADDR
59952: GO 59927
59954: POP
59955: POP
// tmp := [ ] ;
59956: LD_ADDR_VAR 0 5
59960: PUSH
59961: EMPTY
59962: ST_TO_ADDR
// for i = 1 to mc_sides do
59963: LD_ADDR_VAR 0 2
59967: PUSH
59968: DOUBLE
59969: LD_INT 1
59971: DEC
59972: ST_TO_ADDR
59973: LD_EXP 84
59977: PUSH
59978: FOR_TO
59979: IFFALSE 60037
// if not mc_sides [ i ] in tmp then
59981: LD_EXP 84
59985: PUSH
59986: LD_VAR 0 2
59990: ARRAY
59991: PUSH
59992: LD_VAR 0 5
59996: IN
59997: NOT
59998: IFFALSE 60035
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
60000: LD_ADDR_VAR 0 5
60004: PUSH
60005: LD_VAR 0 5
60009: PPUSH
60010: LD_VAR 0 5
60014: PUSH
60015: LD_INT 1
60017: PLUS
60018: PPUSH
60019: LD_EXP 84
60023: PUSH
60024: LD_VAR 0 2
60028: ARRAY
60029: PPUSH
60030: CALL_OW 2
60034: ST_TO_ADDR
60035: GO 59978
60037: POP
60038: POP
// if not tmp then
60039: LD_VAR 0 5
60043: NOT
60044: IFFALSE 60048
// exit ;
60046: GO 60153
// for j in tmp do
60048: LD_ADDR_VAR 0 3
60052: PUSH
60053: LD_VAR 0 5
60057: PUSH
60058: FOR_IN
60059: IFFALSE 60151
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
60061: LD_ADDR_VAR 0 6
60065: PUSH
60066: LD_INT 22
60068: PUSH
60069: LD_VAR 0 3
60073: PUSH
60074: EMPTY
60075: LIST
60076: LIST
60077: PPUSH
60078: CALL_OW 69
60082: ST_TO_ADDR
// if not un then
60083: LD_VAR 0 6
60087: NOT
60088: IFFALSE 60092
// continue ;
60090: GO 60058
// nation := GetNation ( un [ 1 ] ) ;
60092: LD_ADDR_VAR 0 4
60096: PUSH
60097: LD_VAR 0 6
60101: PUSH
60102: LD_INT 1
60104: ARRAY
60105: PPUSH
60106: CALL_OW 248
60110: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
60111: LD_ADDR_EXP 85
60115: PUSH
60116: LD_EXP 85
60120: PPUSH
60121: LD_VAR 0 3
60125: PPUSH
60126: LD_VAR 0 3
60130: PPUSH
60131: LD_VAR 0 4
60135: PPUSH
60136: LD_INT 1
60138: PPUSH
60139: CALL 14011 0 3
60143: PPUSH
60144: CALL_OW 1
60148: ST_TO_ADDR
// end ;
60149: GO 60058
60151: POP
60152: POP
// end ;
60153: LD_VAR 0 1
60157: RET
// export function MC_InitSides ( ) ; var i ; begin
60158: LD_INT 0
60160: PPUSH
60161: PPUSH
// if not mc_bases then
60162: LD_EXP 58
60166: NOT
60167: IFFALSE 60171
// exit ;
60169: GO 60245
// for i = 1 to mc_bases do
60171: LD_ADDR_VAR 0 2
60175: PUSH
60176: DOUBLE
60177: LD_INT 1
60179: DEC
60180: ST_TO_ADDR
60181: LD_EXP 58
60185: PUSH
60186: FOR_TO
60187: IFFALSE 60243
// if mc_bases [ i ] then
60189: LD_EXP 58
60193: PUSH
60194: LD_VAR 0 2
60198: ARRAY
60199: IFFALSE 60241
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
60201: LD_ADDR_EXP 84
60205: PUSH
60206: LD_EXP 84
60210: PPUSH
60211: LD_VAR 0 2
60215: PPUSH
60216: LD_EXP 58
60220: PUSH
60221: LD_VAR 0 2
60225: ARRAY
60226: PUSH
60227: LD_INT 1
60229: ARRAY
60230: PPUSH
60231: CALL_OW 255
60235: PPUSH
60236: CALL_OW 1
60240: ST_TO_ADDR
60241: GO 60186
60243: POP
60244: POP
// end ;
60245: LD_VAR 0 1
60249: RET
// every 0 0$01 trigger skirmish do
60250: LD_EXP 56
60254: IFFALSE 60408
60256: GO 60258
60258: DISABLE
// begin enable ;
60259: ENABLE
// MC_CheckBuildings ( ) ;
60260: CALL 64906 0 0
// MC_CheckPeopleLife ( ) ;
60264: CALL 65031 0 0
// RaiseSailEvent ( 100 ) ;
60268: LD_INT 100
60270: PPUSH
60271: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
60275: LD_INT 103
60277: PPUSH
60278: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
60282: LD_INT 104
60284: PPUSH
60285: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
60289: LD_INT 105
60291: PPUSH
60292: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
60296: LD_INT 106
60298: PPUSH
60299: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
60303: LD_INT 107
60305: PPUSH
60306: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
60310: LD_INT 108
60312: PPUSH
60313: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
60317: LD_INT 109
60319: PPUSH
60320: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
60324: LD_INT 110
60326: PPUSH
60327: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
60331: LD_INT 111
60333: PPUSH
60334: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
60338: LD_INT 112
60340: PPUSH
60341: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
60345: LD_INT 113
60347: PPUSH
60348: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
60352: LD_INT 120
60354: PPUSH
60355: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
60359: LD_INT 121
60361: PPUSH
60362: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
60366: LD_INT 122
60368: PPUSH
60369: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
60373: LD_INT 123
60375: PPUSH
60376: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
60380: LD_INT 124
60382: PPUSH
60383: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
60387: LD_INT 125
60389: PPUSH
60390: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
60394: LD_INT 126
60396: PPUSH
60397: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
60401: LD_INT 200
60403: PPUSH
60404: CALL_OW 427
// end ;
60408: END
// on SailEvent ( event ) do begin if event < 100 then
60409: LD_VAR 0 1
60413: PUSH
60414: LD_INT 100
60416: LESS
60417: IFFALSE 60428
// CustomEvent ( event ) ;
60419: LD_VAR 0 1
60423: PPUSH
60424: CALL 12713 0 1
// if event = 100 then
60428: LD_VAR 0 1
60432: PUSH
60433: LD_INT 100
60435: EQUAL
60436: IFFALSE 60442
// MC_ClassManager ( ) ;
60438: CALL 60834 0 0
// if event = 101 then
60442: LD_VAR 0 1
60446: PUSH
60447: LD_INT 101
60449: EQUAL
60450: IFFALSE 60456
// MC_RepairBuildings ( ) ;
60452: CALL 65627 0 0
// if event = 102 then
60456: LD_VAR 0 1
60460: PUSH
60461: LD_INT 102
60463: EQUAL
60464: IFFALSE 60470
// MC_Heal ( ) ;
60466: CALL 66359 0 0
// if event = 103 then
60470: LD_VAR 0 1
60474: PUSH
60475: LD_INT 103
60477: EQUAL
60478: IFFALSE 60484
// MC_Build ( ) ;
60480: CALL 66781 0 0
// if event = 104 then
60484: LD_VAR 0 1
60488: PUSH
60489: LD_INT 104
60491: EQUAL
60492: IFFALSE 60498
// MC_TurretWeapon ( ) ;
60494: CALL 68394 0 0
// if event = 105 then
60498: LD_VAR 0 1
60502: PUSH
60503: LD_INT 105
60505: EQUAL
60506: IFFALSE 60512
// MC_BuildUpgrade ( ) ;
60508: CALL 67945 0 0
// if event = 106 then
60512: LD_VAR 0 1
60516: PUSH
60517: LD_INT 106
60519: EQUAL
60520: IFFALSE 60526
// MC_PlantMines ( ) ;
60522: CALL 68824 0 0
// if event = 107 then
60526: LD_VAR 0 1
60530: PUSH
60531: LD_INT 107
60533: EQUAL
60534: IFFALSE 60540
// MC_CollectCrates ( ) ;
60536: CALL 69858 0 0
// if event = 108 then
60540: LD_VAR 0 1
60544: PUSH
60545: LD_INT 108
60547: EQUAL
60548: IFFALSE 60554
// MC_LinkRemoteControl ( ) ;
60550: CALL 71634 0 0
// if event = 109 then
60554: LD_VAR 0 1
60558: PUSH
60559: LD_INT 109
60561: EQUAL
60562: IFFALSE 60568
// MC_ProduceVehicle ( ) ;
60564: CALL 71815 0 0
// if event = 110 then
60568: LD_VAR 0 1
60572: PUSH
60573: LD_INT 110
60575: EQUAL
60576: IFFALSE 60582
// MC_SendAttack ( ) ;
60578: CALL 72281 0 0
// if event = 111 then
60582: LD_VAR 0 1
60586: PUSH
60587: LD_INT 111
60589: EQUAL
60590: IFFALSE 60596
// MC_Defend ( ) ;
60592: CALL 72389 0 0
// if event = 112 then
60596: LD_VAR 0 1
60600: PUSH
60601: LD_INT 112
60603: EQUAL
60604: IFFALSE 60610
// MC_Research ( ) ;
60606: CALL 72994 0 0
// if event = 113 then
60610: LD_VAR 0 1
60614: PUSH
60615: LD_INT 113
60617: EQUAL
60618: IFFALSE 60624
// MC_MinesTrigger ( ) ;
60620: CALL 74108 0 0
// if event = 120 then
60624: LD_VAR 0 1
60628: PUSH
60629: LD_INT 120
60631: EQUAL
60632: IFFALSE 60638
// MC_RepairVehicle ( ) ;
60634: CALL 74207 0 0
// if event = 121 then
60638: LD_VAR 0 1
60642: PUSH
60643: LD_INT 121
60645: EQUAL
60646: IFFALSE 60652
// MC_TameApe ( ) ;
60648: CALL 74937 0 0
// if event = 122 then
60652: LD_VAR 0 1
60656: PUSH
60657: LD_INT 122
60659: EQUAL
60660: IFFALSE 60666
// MC_ChangeApeClass ( ) ;
60662: CALL 75766 0 0
// if event = 123 then
60666: LD_VAR 0 1
60670: PUSH
60671: LD_INT 123
60673: EQUAL
60674: IFFALSE 60680
// MC_Bazooka ( ) ;
60676: CALL 76416 0 0
// if event = 124 then
60680: LD_VAR 0 1
60684: PUSH
60685: LD_INT 124
60687: EQUAL
60688: IFFALSE 60694
// MC_TeleportExit ( ) ;
60690: CALL 76614 0 0
// if event = 125 then
60694: LD_VAR 0 1
60698: PUSH
60699: LD_INT 125
60701: EQUAL
60702: IFFALSE 60708
// MC_Deposits ( ) ;
60704: CALL 77261 0 0
// if event = 126 then
60708: LD_VAR 0 1
60712: PUSH
60713: LD_INT 126
60715: EQUAL
60716: IFFALSE 60722
// MC_RemoteDriver ( ) ;
60718: CALL 77886 0 0
// if event = 200 then
60722: LD_VAR 0 1
60726: PUSH
60727: LD_INT 200
60729: EQUAL
60730: IFFALSE 60736
// MC_Idle ( ) ;
60732: CALL 79619 0 0
// end ;
60736: PPOPN 1
60738: END
// export function MC_Reset ( base , tag ) ; var i ; begin
60739: LD_INT 0
60741: PPUSH
60742: PPUSH
// if not mc_bases [ base ] or not tag then
60743: LD_EXP 58
60747: PUSH
60748: LD_VAR 0 1
60752: ARRAY
60753: NOT
60754: PUSH
60755: LD_VAR 0 2
60759: NOT
60760: OR
60761: IFFALSE 60765
// exit ;
60763: GO 60829
// for i in mc_bases [ base ] union mc_ape [ base ] do
60765: LD_ADDR_VAR 0 4
60769: PUSH
60770: LD_EXP 58
60774: PUSH
60775: LD_VAR 0 1
60779: ARRAY
60780: PUSH
60781: LD_EXP 87
60785: PUSH
60786: LD_VAR 0 1
60790: ARRAY
60791: UNION
60792: PUSH
60793: FOR_IN
60794: IFFALSE 60827
// if GetTag ( i ) = tag then
60796: LD_VAR 0 4
60800: PPUSH
60801: CALL_OW 110
60805: PUSH
60806: LD_VAR 0 2
60810: EQUAL
60811: IFFALSE 60825
// SetTag ( i , 0 ) ;
60813: LD_VAR 0 4
60817: PPUSH
60818: LD_INT 0
60820: PPUSH
60821: CALL_OW 109
60825: GO 60793
60827: POP
60828: POP
// end ;
60829: LD_VAR 0 3
60833: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
60834: LD_INT 0
60836: PPUSH
60837: PPUSH
60838: PPUSH
60839: PPUSH
60840: PPUSH
60841: PPUSH
60842: PPUSH
60843: PPUSH
// if not mc_bases then
60844: LD_EXP 58
60848: NOT
60849: IFFALSE 60853
// exit ;
60851: GO 61311
// for i = 1 to mc_bases do
60853: LD_ADDR_VAR 0 2
60857: PUSH
60858: DOUBLE
60859: LD_INT 1
60861: DEC
60862: ST_TO_ADDR
60863: LD_EXP 58
60867: PUSH
60868: FOR_TO
60869: IFFALSE 61309
// begin tmp := MC_ClassCheckReq ( i ) ;
60871: LD_ADDR_VAR 0 4
60875: PUSH
60876: LD_VAR 0 2
60880: PPUSH
60881: CALL 61316 0 1
60885: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
60886: LD_ADDR_EXP 99
60890: PUSH
60891: LD_EXP 99
60895: PPUSH
60896: LD_VAR 0 2
60900: PPUSH
60901: LD_VAR 0 4
60905: PPUSH
60906: CALL_OW 1
60910: ST_TO_ADDR
// if not tmp then
60911: LD_VAR 0 4
60915: NOT
60916: IFFALSE 60920
// continue ;
60918: GO 60868
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
60920: LD_ADDR_VAR 0 6
60924: PUSH
60925: LD_EXP 58
60929: PUSH
60930: LD_VAR 0 2
60934: ARRAY
60935: PPUSH
60936: LD_INT 2
60938: PUSH
60939: LD_INT 30
60941: PUSH
60942: LD_INT 4
60944: PUSH
60945: EMPTY
60946: LIST
60947: LIST
60948: PUSH
60949: LD_INT 30
60951: PUSH
60952: LD_INT 5
60954: PUSH
60955: EMPTY
60956: LIST
60957: LIST
60958: PUSH
60959: EMPTY
60960: LIST
60961: LIST
60962: LIST
60963: PPUSH
60964: CALL_OW 72
60968: PUSH
60969: LD_EXP 58
60973: PUSH
60974: LD_VAR 0 2
60978: ARRAY
60979: PPUSH
60980: LD_INT 2
60982: PUSH
60983: LD_INT 30
60985: PUSH
60986: LD_INT 0
60988: PUSH
60989: EMPTY
60990: LIST
60991: LIST
60992: PUSH
60993: LD_INT 30
60995: PUSH
60996: LD_INT 1
60998: PUSH
60999: EMPTY
61000: LIST
61001: LIST
61002: PUSH
61003: EMPTY
61004: LIST
61005: LIST
61006: LIST
61007: PPUSH
61008: CALL_OW 72
61012: PUSH
61013: LD_EXP 58
61017: PUSH
61018: LD_VAR 0 2
61022: ARRAY
61023: PPUSH
61024: LD_INT 30
61026: PUSH
61027: LD_INT 3
61029: PUSH
61030: EMPTY
61031: LIST
61032: LIST
61033: PPUSH
61034: CALL_OW 72
61038: PUSH
61039: LD_EXP 58
61043: PUSH
61044: LD_VAR 0 2
61048: ARRAY
61049: PPUSH
61050: LD_INT 2
61052: PUSH
61053: LD_INT 30
61055: PUSH
61056: LD_INT 6
61058: PUSH
61059: EMPTY
61060: LIST
61061: LIST
61062: PUSH
61063: LD_INT 30
61065: PUSH
61066: LD_INT 7
61068: PUSH
61069: EMPTY
61070: LIST
61071: LIST
61072: PUSH
61073: LD_INT 30
61075: PUSH
61076: LD_INT 8
61078: PUSH
61079: EMPTY
61080: LIST
61081: LIST
61082: PUSH
61083: EMPTY
61084: LIST
61085: LIST
61086: LIST
61087: LIST
61088: PPUSH
61089: CALL_OW 72
61093: PUSH
61094: EMPTY
61095: LIST
61096: LIST
61097: LIST
61098: LIST
61099: ST_TO_ADDR
// for j = 1 to 4 do
61100: LD_ADDR_VAR 0 3
61104: PUSH
61105: DOUBLE
61106: LD_INT 1
61108: DEC
61109: ST_TO_ADDR
61110: LD_INT 4
61112: PUSH
61113: FOR_TO
61114: IFFALSE 61305
// begin if not tmp [ j ] then
61116: LD_VAR 0 4
61120: PUSH
61121: LD_VAR 0 3
61125: ARRAY
61126: NOT
61127: IFFALSE 61131
// continue ;
61129: GO 61113
// for p in tmp [ j ] do
61131: LD_ADDR_VAR 0 5
61135: PUSH
61136: LD_VAR 0 4
61140: PUSH
61141: LD_VAR 0 3
61145: ARRAY
61146: PUSH
61147: FOR_IN
61148: IFFALSE 61301
// begin if not b [ j ] then
61150: LD_VAR 0 6
61154: PUSH
61155: LD_VAR 0 3
61159: ARRAY
61160: NOT
61161: IFFALSE 61165
// break ;
61163: GO 61301
// e := 0 ;
61165: LD_ADDR_VAR 0 7
61169: PUSH
61170: LD_INT 0
61172: ST_TO_ADDR
// for k in b [ j ] do
61173: LD_ADDR_VAR 0 8
61177: PUSH
61178: LD_VAR 0 6
61182: PUSH
61183: LD_VAR 0 3
61187: ARRAY
61188: PUSH
61189: FOR_IN
61190: IFFALSE 61217
// if IsNotFull ( k ) then
61192: LD_VAR 0 8
61196: PPUSH
61197: CALL 18087 0 1
61201: IFFALSE 61215
// begin e := k ;
61203: LD_ADDR_VAR 0 7
61207: PUSH
61208: LD_VAR 0 8
61212: ST_TO_ADDR
// break ;
61213: GO 61217
// end ;
61215: GO 61189
61217: POP
61218: POP
// if e and not UnitGoingToBuilding ( p , e ) then
61219: LD_VAR 0 7
61223: PUSH
61224: LD_VAR 0 5
61228: PPUSH
61229: LD_VAR 0 7
61233: PPUSH
61234: CALL 55206 0 2
61238: NOT
61239: AND
61240: IFFALSE 61299
// begin if IsInUnit ( p ) then
61242: LD_VAR 0 5
61246: PPUSH
61247: CALL_OW 310
61251: IFFALSE 61262
// ComExitBuilding ( p ) ;
61253: LD_VAR 0 5
61257: PPUSH
61258: CALL_OW 122
// ComEnterUnit ( p , e ) ;
61262: LD_VAR 0 5
61266: PPUSH
61267: LD_VAR 0 7
61271: PPUSH
61272: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
61276: LD_VAR 0 5
61280: PPUSH
61281: LD_VAR 0 3
61285: PPUSH
61286: CALL_OW 183
// AddComExitBuilding ( p ) ;
61290: LD_VAR 0 5
61294: PPUSH
61295: CALL_OW 182
// end ; end ;
61299: GO 61147
61301: POP
61302: POP
// end ;
61303: GO 61113
61305: POP
61306: POP
// end ;
61307: GO 60868
61309: POP
61310: POP
// end ;
61311: LD_VAR 0 1
61315: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
61316: LD_INT 0
61318: PPUSH
61319: PPUSH
61320: PPUSH
61321: PPUSH
61322: PPUSH
61323: PPUSH
61324: PPUSH
61325: PPUSH
61326: PPUSH
61327: PPUSH
61328: PPUSH
61329: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61330: LD_VAR 0 1
61334: NOT
61335: PUSH
61336: LD_EXP 58
61340: PUSH
61341: LD_VAR 0 1
61345: ARRAY
61346: NOT
61347: OR
61348: PUSH
61349: LD_EXP 58
61353: PUSH
61354: LD_VAR 0 1
61358: ARRAY
61359: PPUSH
61360: LD_INT 2
61362: PUSH
61363: LD_INT 30
61365: PUSH
61366: LD_INT 0
61368: PUSH
61369: EMPTY
61370: LIST
61371: LIST
61372: PUSH
61373: LD_INT 30
61375: PUSH
61376: LD_INT 1
61378: PUSH
61379: EMPTY
61380: LIST
61381: LIST
61382: PUSH
61383: EMPTY
61384: LIST
61385: LIST
61386: LIST
61387: PPUSH
61388: CALL_OW 72
61392: NOT
61393: OR
61394: IFFALSE 61398
// exit ;
61396: GO 64901
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61398: LD_ADDR_VAR 0 4
61402: PUSH
61403: LD_EXP 58
61407: PUSH
61408: LD_VAR 0 1
61412: ARRAY
61413: PPUSH
61414: LD_INT 2
61416: PUSH
61417: LD_INT 25
61419: PUSH
61420: LD_INT 1
61422: PUSH
61423: EMPTY
61424: LIST
61425: LIST
61426: PUSH
61427: LD_INT 25
61429: PUSH
61430: LD_INT 2
61432: PUSH
61433: EMPTY
61434: LIST
61435: LIST
61436: PUSH
61437: LD_INT 25
61439: PUSH
61440: LD_INT 3
61442: PUSH
61443: EMPTY
61444: LIST
61445: LIST
61446: PUSH
61447: LD_INT 25
61449: PUSH
61450: LD_INT 4
61452: PUSH
61453: EMPTY
61454: LIST
61455: LIST
61456: PUSH
61457: LD_INT 25
61459: PUSH
61460: LD_INT 5
61462: PUSH
61463: EMPTY
61464: LIST
61465: LIST
61466: PUSH
61467: LD_INT 25
61469: PUSH
61470: LD_INT 8
61472: PUSH
61473: EMPTY
61474: LIST
61475: LIST
61476: PUSH
61477: LD_INT 25
61479: PUSH
61480: LD_INT 9
61482: PUSH
61483: EMPTY
61484: LIST
61485: LIST
61486: PUSH
61487: EMPTY
61488: LIST
61489: LIST
61490: LIST
61491: LIST
61492: LIST
61493: LIST
61494: LIST
61495: LIST
61496: PPUSH
61497: CALL_OW 72
61501: ST_TO_ADDR
// if not tmp then
61502: LD_VAR 0 4
61506: NOT
61507: IFFALSE 61511
// exit ;
61509: GO 64901
// for i in tmp do
61511: LD_ADDR_VAR 0 3
61515: PUSH
61516: LD_VAR 0 4
61520: PUSH
61521: FOR_IN
61522: IFFALSE 61553
// if GetTag ( i ) then
61524: LD_VAR 0 3
61528: PPUSH
61529: CALL_OW 110
61533: IFFALSE 61551
// tmp := tmp diff i ;
61535: LD_ADDR_VAR 0 4
61539: PUSH
61540: LD_VAR 0 4
61544: PUSH
61545: LD_VAR 0 3
61549: DIFF
61550: ST_TO_ADDR
61551: GO 61521
61553: POP
61554: POP
// if not tmp then
61555: LD_VAR 0 4
61559: NOT
61560: IFFALSE 61564
// exit ;
61562: GO 64901
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61564: LD_ADDR_VAR 0 5
61568: PUSH
61569: LD_EXP 58
61573: PUSH
61574: LD_VAR 0 1
61578: ARRAY
61579: PPUSH
61580: LD_INT 2
61582: PUSH
61583: LD_INT 25
61585: PUSH
61586: LD_INT 1
61588: PUSH
61589: EMPTY
61590: LIST
61591: LIST
61592: PUSH
61593: LD_INT 25
61595: PUSH
61596: LD_INT 5
61598: PUSH
61599: EMPTY
61600: LIST
61601: LIST
61602: PUSH
61603: LD_INT 25
61605: PUSH
61606: LD_INT 8
61608: PUSH
61609: EMPTY
61610: LIST
61611: LIST
61612: PUSH
61613: LD_INT 25
61615: PUSH
61616: LD_INT 9
61618: PUSH
61619: EMPTY
61620: LIST
61621: LIST
61622: PUSH
61623: EMPTY
61624: LIST
61625: LIST
61626: LIST
61627: LIST
61628: LIST
61629: PPUSH
61630: CALL_OW 72
61634: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
61635: LD_ADDR_VAR 0 6
61639: PUSH
61640: LD_EXP 58
61644: PUSH
61645: LD_VAR 0 1
61649: ARRAY
61650: PPUSH
61651: LD_INT 25
61653: PUSH
61654: LD_INT 2
61656: PUSH
61657: EMPTY
61658: LIST
61659: LIST
61660: PPUSH
61661: CALL_OW 72
61665: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
61666: LD_ADDR_VAR 0 7
61670: PUSH
61671: LD_EXP 58
61675: PUSH
61676: LD_VAR 0 1
61680: ARRAY
61681: PPUSH
61682: LD_INT 25
61684: PUSH
61685: LD_INT 3
61687: PUSH
61688: EMPTY
61689: LIST
61690: LIST
61691: PPUSH
61692: CALL_OW 72
61696: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
61697: LD_ADDR_VAR 0 8
61701: PUSH
61702: LD_EXP 58
61706: PUSH
61707: LD_VAR 0 1
61711: ARRAY
61712: PPUSH
61713: LD_INT 25
61715: PUSH
61716: LD_INT 4
61718: PUSH
61719: EMPTY
61720: LIST
61721: LIST
61722: PUSH
61723: LD_INT 24
61725: PUSH
61726: LD_INT 251
61728: PUSH
61729: EMPTY
61730: LIST
61731: LIST
61732: PUSH
61733: EMPTY
61734: LIST
61735: LIST
61736: PPUSH
61737: CALL_OW 72
61741: ST_TO_ADDR
// if mc_scan [ base ] then
61742: LD_EXP 81
61746: PUSH
61747: LD_VAR 0 1
61751: ARRAY
61752: IFFALSE 62213
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
61754: LD_ADDR_EXP 100
61758: PUSH
61759: LD_EXP 100
61763: PPUSH
61764: LD_VAR 0 1
61768: PPUSH
61769: LD_INT 4
61771: PPUSH
61772: CALL_OW 1
61776: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
61777: LD_ADDR_VAR 0 12
61781: PUSH
61782: LD_EXP 58
61786: PUSH
61787: LD_VAR 0 1
61791: ARRAY
61792: PPUSH
61793: LD_INT 2
61795: PUSH
61796: LD_INT 30
61798: PUSH
61799: LD_INT 4
61801: PUSH
61802: EMPTY
61803: LIST
61804: LIST
61805: PUSH
61806: LD_INT 30
61808: PUSH
61809: LD_INT 5
61811: PUSH
61812: EMPTY
61813: LIST
61814: LIST
61815: PUSH
61816: EMPTY
61817: LIST
61818: LIST
61819: LIST
61820: PPUSH
61821: CALL_OW 72
61825: ST_TO_ADDR
// if not b then
61826: LD_VAR 0 12
61830: NOT
61831: IFFALSE 61835
// exit ;
61833: GO 64901
// p := [ ] ;
61835: LD_ADDR_VAR 0 11
61839: PUSH
61840: EMPTY
61841: ST_TO_ADDR
// if sci >= 2 then
61842: LD_VAR 0 8
61846: PUSH
61847: LD_INT 2
61849: GREATEREQUAL
61850: IFFALSE 61881
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
61852: LD_ADDR_VAR 0 8
61856: PUSH
61857: LD_VAR 0 8
61861: PUSH
61862: LD_INT 1
61864: ARRAY
61865: PUSH
61866: LD_VAR 0 8
61870: PUSH
61871: LD_INT 2
61873: ARRAY
61874: PUSH
61875: EMPTY
61876: LIST
61877: LIST
61878: ST_TO_ADDR
61879: GO 61942
// if sci = 1 then
61881: LD_VAR 0 8
61885: PUSH
61886: LD_INT 1
61888: EQUAL
61889: IFFALSE 61910
// sci := [ sci [ 1 ] ] else
61891: LD_ADDR_VAR 0 8
61895: PUSH
61896: LD_VAR 0 8
61900: PUSH
61901: LD_INT 1
61903: ARRAY
61904: PUSH
61905: EMPTY
61906: LIST
61907: ST_TO_ADDR
61908: GO 61942
// if sci = 0 then
61910: LD_VAR 0 8
61914: PUSH
61915: LD_INT 0
61917: EQUAL
61918: IFFALSE 61942
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
61920: LD_ADDR_VAR 0 11
61924: PUSH
61925: LD_VAR 0 4
61929: PPUSH
61930: LD_INT 4
61932: PPUSH
61933: CALL 55069 0 2
61937: PUSH
61938: LD_INT 1
61940: ARRAY
61941: ST_TO_ADDR
// if eng > 4 then
61942: LD_VAR 0 6
61946: PUSH
61947: LD_INT 4
61949: GREATER
61950: IFFALSE 61996
// for i = eng downto 4 do
61952: LD_ADDR_VAR 0 3
61956: PUSH
61957: DOUBLE
61958: LD_VAR 0 6
61962: INC
61963: ST_TO_ADDR
61964: LD_INT 4
61966: PUSH
61967: FOR_DOWNTO
61968: IFFALSE 61994
// eng := eng diff eng [ i ] ;
61970: LD_ADDR_VAR 0 6
61974: PUSH
61975: LD_VAR 0 6
61979: PUSH
61980: LD_VAR 0 6
61984: PUSH
61985: LD_VAR 0 3
61989: ARRAY
61990: DIFF
61991: ST_TO_ADDR
61992: GO 61967
61994: POP
61995: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
61996: LD_ADDR_VAR 0 4
62000: PUSH
62001: LD_VAR 0 4
62005: PUSH
62006: LD_VAR 0 5
62010: PUSH
62011: LD_VAR 0 6
62015: UNION
62016: PUSH
62017: LD_VAR 0 7
62021: UNION
62022: PUSH
62023: LD_VAR 0 8
62027: UNION
62028: DIFF
62029: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
62030: LD_ADDR_VAR 0 13
62034: PUSH
62035: LD_EXP 58
62039: PUSH
62040: LD_VAR 0 1
62044: ARRAY
62045: PPUSH
62046: LD_INT 2
62048: PUSH
62049: LD_INT 30
62051: PUSH
62052: LD_INT 32
62054: PUSH
62055: EMPTY
62056: LIST
62057: LIST
62058: PUSH
62059: LD_INT 30
62061: PUSH
62062: LD_INT 31
62064: PUSH
62065: EMPTY
62066: LIST
62067: LIST
62068: PUSH
62069: EMPTY
62070: LIST
62071: LIST
62072: LIST
62073: PPUSH
62074: CALL_OW 72
62078: PUSH
62079: LD_EXP 58
62083: PUSH
62084: LD_VAR 0 1
62088: ARRAY
62089: PPUSH
62090: LD_INT 2
62092: PUSH
62093: LD_INT 30
62095: PUSH
62096: LD_INT 4
62098: PUSH
62099: EMPTY
62100: LIST
62101: LIST
62102: PUSH
62103: LD_INT 30
62105: PUSH
62106: LD_INT 5
62108: PUSH
62109: EMPTY
62110: LIST
62111: LIST
62112: PUSH
62113: EMPTY
62114: LIST
62115: LIST
62116: LIST
62117: PPUSH
62118: CALL_OW 72
62122: PUSH
62123: LD_INT 6
62125: MUL
62126: PLUS
62127: ST_TO_ADDR
// if bcount < tmp then
62128: LD_VAR 0 13
62132: PUSH
62133: LD_VAR 0 4
62137: LESS
62138: IFFALSE 62184
// for i = tmp downto bcount do
62140: LD_ADDR_VAR 0 3
62144: PUSH
62145: DOUBLE
62146: LD_VAR 0 4
62150: INC
62151: ST_TO_ADDR
62152: LD_VAR 0 13
62156: PUSH
62157: FOR_DOWNTO
62158: IFFALSE 62182
// tmp := Delete ( tmp , tmp ) ;
62160: LD_ADDR_VAR 0 4
62164: PUSH
62165: LD_VAR 0 4
62169: PPUSH
62170: LD_VAR 0 4
62174: PPUSH
62175: CALL_OW 3
62179: ST_TO_ADDR
62180: GO 62157
62182: POP
62183: POP
// result := [ tmp , 0 , 0 , p ] ;
62184: LD_ADDR_VAR 0 2
62188: PUSH
62189: LD_VAR 0 4
62193: PUSH
62194: LD_INT 0
62196: PUSH
62197: LD_INT 0
62199: PUSH
62200: LD_VAR 0 11
62204: PUSH
62205: EMPTY
62206: LIST
62207: LIST
62208: LIST
62209: LIST
62210: ST_TO_ADDR
// exit ;
62211: GO 64901
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62213: LD_EXP 58
62217: PUSH
62218: LD_VAR 0 1
62222: ARRAY
62223: PPUSH
62224: LD_INT 2
62226: PUSH
62227: LD_INT 30
62229: PUSH
62230: LD_INT 6
62232: PUSH
62233: EMPTY
62234: LIST
62235: LIST
62236: PUSH
62237: LD_INT 30
62239: PUSH
62240: LD_INT 7
62242: PUSH
62243: EMPTY
62244: LIST
62245: LIST
62246: PUSH
62247: LD_INT 30
62249: PUSH
62250: LD_INT 8
62252: PUSH
62253: EMPTY
62254: LIST
62255: LIST
62256: PUSH
62257: EMPTY
62258: LIST
62259: LIST
62260: LIST
62261: LIST
62262: PPUSH
62263: CALL_OW 72
62267: NOT
62268: PUSH
62269: LD_EXP 58
62273: PUSH
62274: LD_VAR 0 1
62278: ARRAY
62279: PPUSH
62280: LD_INT 30
62282: PUSH
62283: LD_INT 3
62285: PUSH
62286: EMPTY
62287: LIST
62288: LIST
62289: PPUSH
62290: CALL_OW 72
62294: NOT
62295: AND
62296: IFFALSE 62368
// begin if eng = tmp then
62298: LD_VAR 0 6
62302: PUSH
62303: LD_VAR 0 4
62307: EQUAL
62308: IFFALSE 62312
// exit ;
62310: GO 64901
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
62312: LD_ADDR_EXP 100
62316: PUSH
62317: LD_EXP 100
62321: PPUSH
62322: LD_VAR 0 1
62326: PPUSH
62327: LD_INT 1
62329: PPUSH
62330: CALL_OW 1
62334: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
62335: LD_ADDR_VAR 0 2
62339: PUSH
62340: LD_INT 0
62342: PUSH
62343: LD_VAR 0 4
62347: PUSH
62348: LD_VAR 0 6
62352: DIFF
62353: PUSH
62354: LD_INT 0
62356: PUSH
62357: LD_INT 0
62359: PUSH
62360: EMPTY
62361: LIST
62362: LIST
62363: LIST
62364: LIST
62365: ST_TO_ADDR
// exit ;
62366: GO 64901
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62368: LD_EXP 85
62372: PUSH
62373: LD_EXP 84
62377: PUSH
62378: LD_VAR 0 1
62382: ARRAY
62383: ARRAY
62384: PUSH
62385: LD_EXP 58
62389: PUSH
62390: LD_VAR 0 1
62394: ARRAY
62395: PPUSH
62396: LD_INT 2
62398: PUSH
62399: LD_INT 30
62401: PUSH
62402: LD_INT 6
62404: PUSH
62405: EMPTY
62406: LIST
62407: LIST
62408: PUSH
62409: LD_INT 30
62411: PUSH
62412: LD_INT 7
62414: PUSH
62415: EMPTY
62416: LIST
62417: LIST
62418: PUSH
62419: LD_INT 30
62421: PUSH
62422: LD_INT 8
62424: PUSH
62425: EMPTY
62426: LIST
62427: LIST
62428: PUSH
62429: EMPTY
62430: LIST
62431: LIST
62432: LIST
62433: LIST
62434: PPUSH
62435: CALL_OW 72
62439: AND
62440: PUSH
62441: LD_EXP 58
62445: PUSH
62446: LD_VAR 0 1
62450: ARRAY
62451: PPUSH
62452: LD_INT 30
62454: PUSH
62455: LD_INT 3
62457: PUSH
62458: EMPTY
62459: LIST
62460: LIST
62461: PPUSH
62462: CALL_OW 72
62466: NOT
62467: AND
62468: IFFALSE 62682
// begin if sci >= 6 then
62470: LD_VAR 0 8
62474: PUSH
62475: LD_INT 6
62477: GREATEREQUAL
62478: IFFALSE 62482
// exit ;
62480: GO 64901
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
62482: LD_ADDR_EXP 100
62486: PUSH
62487: LD_EXP 100
62491: PPUSH
62492: LD_VAR 0 1
62496: PPUSH
62497: LD_INT 2
62499: PPUSH
62500: CALL_OW 1
62504: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
62505: LD_ADDR_VAR 0 9
62509: PUSH
62510: LD_VAR 0 4
62514: PUSH
62515: LD_VAR 0 8
62519: DIFF
62520: PPUSH
62521: LD_INT 4
62523: PPUSH
62524: CALL 55069 0 2
62528: ST_TO_ADDR
// p := [ ] ;
62529: LD_ADDR_VAR 0 11
62533: PUSH
62534: EMPTY
62535: ST_TO_ADDR
// if sci < 6 and sort > 6 then
62536: LD_VAR 0 8
62540: PUSH
62541: LD_INT 6
62543: LESS
62544: PUSH
62545: LD_VAR 0 9
62549: PUSH
62550: LD_INT 6
62552: GREATER
62553: AND
62554: IFFALSE 62635
// begin for i = 1 to 6 - sci do
62556: LD_ADDR_VAR 0 3
62560: PUSH
62561: DOUBLE
62562: LD_INT 1
62564: DEC
62565: ST_TO_ADDR
62566: LD_INT 6
62568: PUSH
62569: LD_VAR 0 8
62573: MINUS
62574: PUSH
62575: FOR_TO
62576: IFFALSE 62631
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
62578: LD_ADDR_VAR 0 11
62582: PUSH
62583: LD_VAR 0 11
62587: PPUSH
62588: LD_VAR 0 11
62592: PUSH
62593: LD_INT 1
62595: PLUS
62596: PPUSH
62597: LD_VAR 0 9
62601: PUSH
62602: LD_INT 1
62604: ARRAY
62605: PPUSH
62606: CALL_OW 2
62610: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
62611: LD_ADDR_VAR 0 9
62615: PUSH
62616: LD_VAR 0 9
62620: PPUSH
62621: LD_INT 1
62623: PPUSH
62624: CALL_OW 3
62628: ST_TO_ADDR
// end ;
62629: GO 62575
62631: POP
62632: POP
// end else
62633: GO 62655
// if sort then
62635: LD_VAR 0 9
62639: IFFALSE 62655
// p := sort [ 1 ] ;
62641: LD_ADDR_VAR 0 11
62645: PUSH
62646: LD_VAR 0 9
62650: PUSH
62651: LD_INT 1
62653: ARRAY
62654: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
62655: LD_ADDR_VAR 0 2
62659: PUSH
62660: LD_INT 0
62662: PUSH
62663: LD_INT 0
62665: PUSH
62666: LD_INT 0
62668: PUSH
62669: LD_VAR 0 11
62673: PUSH
62674: EMPTY
62675: LIST
62676: LIST
62677: LIST
62678: LIST
62679: ST_TO_ADDR
// exit ;
62680: GO 64901
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62682: LD_EXP 85
62686: PUSH
62687: LD_EXP 84
62691: PUSH
62692: LD_VAR 0 1
62696: ARRAY
62697: ARRAY
62698: PUSH
62699: LD_EXP 58
62703: PUSH
62704: LD_VAR 0 1
62708: ARRAY
62709: PPUSH
62710: LD_INT 2
62712: PUSH
62713: LD_INT 30
62715: PUSH
62716: LD_INT 6
62718: PUSH
62719: EMPTY
62720: LIST
62721: LIST
62722: PUSH
62723: LD_INT 30
62725: PUSH
62726: LD_INT 7
62728: PUSH
62729: EMPTY
62730: LIST
62731: LIST
62732: PUSH
62733: LD_INT 30
62735: PUSH
62736: LD_INT 8
62738: PUSH
62739: EMPTY
62740: LIST
62741: LIST
62742: PUSH
62743: EMPTY
62744: LIST
62745: LIST
62746: LIST
62747: LIST
62748: PPUSH
62749: CALL_OW 72
62753: AND
62754: PUSH
62755: LD_EXP 58
62759: PUSH
62760: LD_VAR 0 1
62764: ARRAY
62765: PPUSH
62766: LD_INT 30
62768: PUSH
62769: LD_INT 3
62771: PUSH
62772: EMPTY
62773: LIST
62774: LIST
62775: PPUSH
62776: CALL_OW 72
62780: AND
62781: IFFALSE 63515
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
62783: LD_ADDR_EXP 100
62787: PUSH
62788: LD_EXP 100
62792: PPUSH
62793: LD_VAR 0 1
62797: PPUSH
62798: LD_INT 3
62800: PPUSH
62801: CALL_OW 1
62805: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62806: LD_ADDR_VAR 0 2
62810: PUSH
62811: LD_INT 0
62813: PUSH
62814: LD_INT 0
62816: PUSH
62817: LD_INT 0
62819: PUSH
62820: LD_INT 0
62822: PUSH
62823: EMPTY
62824: LIST
62825: LIST
62826: LIST
62827: LIST
62828: ST_TO_ADDR
// if not eng then
62829: LD_VAR 0 6
62833: NOT
62834: IFFALSE 62897
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
62836: LD_ADDR_VAR 0 11
62840: PUSH
62841: LD_VAR 0 4
62845: PPUSH
62846: LD_INT 2
62848: PPUSH
62849: CALL 55069 0 2
62853: PUSH
62854: LD_INT 1
62856: ARRAY
62857: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
62858: LD_ADDR_VAR 0 2
62862: PUSH
62863: LD_VAR 0 2
62867: PPUSH
62868: LD_INT 2
62870: PPUSH
62871: LD_VAR 0 11
62875: PPUSH
62876: CALL_OW 1
62880: ST_TO_ADDR
// tmp := tmp diff p ;
62881: LD_ADDR_VAR 0 4
62885: PUSH
62886: LD_VAR 0 4
62890: PUSH
62891: LD_VAR 0 11
62895: DIFF
62896: ST_TO_ADDR
// end ; if tmp and sci < 6 then
62897: LD_VAR 0 4
62901: PUSH
62902: LD_VAR 0 8
62906: PUSH
62907: LD_INT 6
62909: LESS
62910: AND
62911: IFFALSE 63099
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
62913: LD_ADDR_VAR 0 9
62917: PUSH
62918: LD_VAR 0 4
62922: PUSH
62923: LD_VAR 0 8
62927: PUSH
62928: LD_VAR 0 7
62932: UNION
62933: DIFF
62934: PPUSH
62935: LD_INT 4
62937: PPUSH
62938: CALL 55069 0 2
62942: ST_TO_ADDR
// p := [ ] ;
62943: LD_ADDR_VAR 0 11
62947: PUSH
62948: EMPTY
62949: ST_TO_ADDR
// if sort then
62950: LD_VAR 0 9
62954: IFFALSE 63070
// for i = 1 to 6 - sci do
62956: LD_ADDR_VAR 0 3
62960: PUSH
62961: DOUBLE
62962: LD_INT 1
62964: DEC
62965: ST_TO_ADDR
62966: LD_INT 6
62968: PUSH
62969: LD_VAR 0 8
62973: MINUS
62974: PUSH
62975: FOR_TO
62976: IFFALSE 63068
// begin if i = sort then
62978: LD_VAR 0 3
62982: PUSH
62983: LD_VAR 0 9
62987: EQUAL
62988: IFFALSE 62992
// break ;
62990: GO 63068
// if GetClass ( i ) = 4 then
62992: LD_VAR 0 3
62996: PPUSH
62997: CALL_OW 257
63001: PUSH
63002: LD_INT 4
63004: EQUAL
63005: IFFALSE 63009
// continue ;
63007: GO 62975
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63009: LD_ADDR_VAR 0 11
63013: PUSH
63014: LD_VAR 0 11
63018: PPUSH
63019: LD_VAR 0 11
63023: PUSH
63024: LD_INT 1
63026: PLUS
63027: PPUSH
63028: LD_VAR 0 9
63032: PUSH
63033: LD_VAR 0 3
63037: ARRAY
63038: PPUSH
63039: CALL_OW 2
63043: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63044: LD_ADDR_VAR 0 4
63048: PUSH
63049: LD_VAR 0 4
63053: PUSH
63054: LD_VAR 0 9
63058: PUSH
63059: LD_VAR 0 3
63063: ARRAY
63064: DIFF
63065: ST_TO_ADDR
// end ;
63066: GO 62975
63068: POP
63069: POP
// if p then
63070: LD_VAR 0 11
63074: IFFALSE 63099
// result := Replace ( result , 4 , p ) ;
63076: LD_ADDR_VAR 0 2
63080: PUSH
63081: LD_VAR 0 2
63085: PPUSH
63086: LD_INT 4
63088: PPUSH
63089: LD_VAR 0 11
63093: PPUSH
63094: CALL_OW 1
63098: ST_TO_ADDR
// end ; if tmp and mech < 6 then
63099: LD_VAR 0 4
63103: PUSH
63104: LD_VAR 0 7
63108: PUSH
63109: LD_INT 6
63111: LESS
63112: AND
63113: IFFALSE 63301
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63115: LD_ADDR_VAR 0 9
63119: PUSH
63120: LD_VAR 0 4
63124: PUSH
63125: LD_VAR 0 8
63129: PUSH
63130: LD_VAR 0 7
63134: UNION
63135: DIFF
63136: PPUSH
63137: LD_INT 3
63139: PPUSH
63140: CALL 55069 0 2
63144: ST_TO_ADDR
// p := [ ] ;
63145: LD_ADDR_VAR 0 11
63149: PUSH
63150: EMPTY
63151: ST_TO_ADDR
// if sort then
63152: LD_VAR 0 9
63156: IFFALSE 63272
// for i = 1 to 6 - mech do
63158: LD_ADDR_VAR 0 3
63162: PUSH
63163: DOUBLE
63164: LD_INT 1
63166: DEC
63167: ST_TO_ADDR
63168: LD_INT 6
63170: PUSH
63171: LD_VAR 0 7
63175: MINUS
63176: PUSH
63177: FOR_TO
63178: IFFALSE 63270
// begin if i = sort then
63180: LD_VAR 0 3
63184: PUSH
63185: LD_VAR 0 9
63189: EQUAL
63190: IFFALSE 63194
// break ;
63192: GO 63270
// if GetClass ( i ) = 3 then
63194: LD_VAR 0 3
63198: PPUSH
63199: CALL_OW 257
63203: PUSH
63204: LD_INT 3
63206: EQUAL
63207: IFFALSE 63211
// continue ;
63209: GO 63177
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63211: LD_ADDR_VAR 0 11
63215: PUSH
63216: LD_VAR 0 11
63220: PPUSH
63221: LD_VAR 0 11
63225: PUSH
63226: LD_INT 1
63228: PLUS
63229: PPUSH
63230: LD_VAR 0 9
63234: PUSH
63235: LD_VAR 0 3
63239: ARRAY
63240: PPUSH
63241: CALL_OW 2
63245: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63246: LD_ADDR_VAR 0 4
63250: PUSH
63251: LD_VAR 0 4
63255: PUSH
63256: LD_VAR 0 9
63260: PUSH
63261: LD_VAR 0 3
63265: ARRAY
63266: DIFF
63267: ST_TO_ADDR
// end ;
63268: GO 63177
63270: POP
63271: POP
// if p then
63272: LD_VAR 0 11
63276: IFFALSE 63301
// result := Replace ( result , 3 , p ) ;
63278: LD_ADDR_VAR 0 2
63282: PUSH
63283: LD_VAR 0 2
63287: PPUSH
63288: LD_INT 3
63290: PPUSH
63291: LD_VAR 0 11
63295: PPUSH
63296: CALL_OW 1
63300: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
63301: LD_VAR 0 4
63305: PUSH
63306: LD_INT 6
63308: GREATER
63309: PUSH
63310: LD_VAR 0 6
63314: PUSH
63315: LD_INT 6
63317: LESS
63318: AND
63319: IFFALSE 63513
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63321: LD_ADDR_VAR 0 9
63325: PUSH
63326: LD_VAR 0 4
63330: PUSH
63331: LD_VAR 0 8
63335: PUSH
63336: LD_VAR 0 7
63340: UNION
63341: PUSH
63342: LD_VAR 0 6
63346: UNION
63347: DIFF
63348: PPUSH
63349: LD_INT 2
63351: PPUSH
63352: CALL 55069 0 2
63356: ST_TO_ADDR
// p := [ ] ;
63357: LD_ADDR_VAR 0 11
63361: PUSH
63362: EMPTY
63363: ST_TO_ADDR
// if sort then
63364: LD_VAR 0 9
63368: IFFALSE 63484
// for i = 1 to 6 - eng do
63370: LD_ADDR_VAR 0 3
63374: PUSH
63375: DOUBLE
63376: LD_INT 1
63378: DEC
63379: ST_TO_ADDR
63380: LD_INT 6
63382: PUSH
63383: LD_VAR 0 6
63387: MINUS
63388: PUSH
63389: FOR_TO
63390: IFFALSE 63482
// begin if i = sort then
63392: LD_VAR 0 3
63396: PUSH
63397: LD_VAR 0 9
63401: EQUAL
63402: IFFALSE 63406
// break ;
63404: GO 63482
// if GetClass ( i ) = 2 then
63406: LD_VAR 0 3
63410: PPUSH
63411: CALL_OW 257
63415: PUSH
63416: LD_INT 2
63418: EQUAL
63419: IFFALSE 63423
// continue ;
63421: GO 63389
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63423: LD_ADDR_VAR 0 11
63427: PUSH
63428: LD_VAR 0 11
63432: PPUSH
63433: LD_VAR 0 11
63437: PUSH
63438: LD_INT 1
63440: PLUS
63441: PPUSH
63442: LD_VAR 0 9
63446: PUSH
63447: LD_VAR 0 3
63451: ARRAY
63452: PPUSH
63453: CALL_OW 2
63457: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63458: LD_ADDR_VAR 0 4
63462: PUSH
63463: LD_VAR 0 4
63467: PUSH
63468: LD_VAR 0 9
63472: PUSH
63473: LD_VAR 0 3
63477: ARRAY
63478: DIFF
63479: ST_TO_ADDR
// end ;
63480: GO 63389
63482: POP
63483: POP
// if p then
63484: LD_VAR 0 11
63488: IFFALSE 63513
// result := Replace ( result , 2 , p ) ;
63490: LD_ADDR_VAR 0 2
63494: PUSH
63495: LD_VAR 0 2
63499: PPUSH
63500: LD_INT 2
63502: PPUSH
63503: LD_VAR 0 11
63507: PPUSH
63508: CALL_OW 1
63512: ST_TO_ADDR
// end ; exit ;
63513: GO 64901
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
63515: LD_EXP 85
63519: PUSH
63520: LD_EXP 84
63524: PUSH
63525: LD_VAR 0 1
63529: ARRAY
63530: ARRAY
63531: NOT
63532: PUSH
63533: LD_EXP 58
63537: PUSH
63538: LD_VAR 0 1
63542: ARRAY
63543: PPUSH
63544: LD_INT 30
63546: PUSH
63547: LD_INT 3
63549: PUSH
63550: EMPTY
63551: LIST
63552: LIST
63553: PPUSH
63554: CALL_OW 72
63558: AND
63559: PUSH
63560: LD_EXP 63
63564: PUSH
63565: LD_VAR 0 1
63569: ARRAY
63570: AND
63571: IFFALSE 64179
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
63573: LD_ADDR_EXP 100
63577: PUSH
63578: LD_EXP 100
63582: PPUSH
63583: LD_VAR 0 1
63587: PPUSH
63588: LD_INT 5
63590: PPUSH
63591: CALL_OW 1
63595: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63596: LD_ADDR_VAR 0 2
63600: PUSH
63601: LD_INT 0
63603: PUSH
63604: LD_INT 0
63606: PUSH
63607: LD_INT 0
63609: PUSH
63610: LD_INT 0
63612: PUSH
63613: EMPTY
63614: LIST
63615: LIST
63616: LIST
63617: LIST
63618: ST_TO_ADDR
// if sci > 1 then
63619: LD_VAR 0 8
63623: PUSH
63624: LD_INT 1
63626: GREATER
63627: IFFALSE 63655
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
63629: LD_ADDR_VAR 0 4
63633: PUSH
63634: LD_VAR 0 4
63638: PUSH
63639: LD_VAR 0 8
63643: PUSH
63644: LD_VAR 0 8
63648: PUSH
63649: LD_INT 1
63651: ARRAY
63652: DIFF
63653: DIFF
63654: ST_TO_ADDR
// if tmp and not sci then
63655: LD_VAR 0 4
63659: PUSH
63660: LD_VAR 0 8
63664: NOT
63665: AND
63666: IFFALSE 63735
// begin sort := SortBySkill ( tmp , 4 ) ;
63668: LD_ADDR_VAR 0 9
63672: PUSH
63673: LD_VAR 0 4
63677: PPUSH
63678: LD_INT 4
63680: PPUSH
63681: CALL 55069 0 2
63685: ST_TO_ADDR
// if sort then
63686: LD_VAR 0 9
63690: IFFALSE 63706
// p := sort [ 1 ] ;
63692: LD_ADDR_VAR 0 11
63696: PUSH
63697: LD_VAR 0 9
63701: PUSH
63702: LD_INT 1
63704: ARRAY
63705: ST_TO_ADDR
// if p then
63706: LD_VAR 0 11
63710: IFFALSE 63735
// result := Replace ( result , 4 , p ) ;
63712: LD_ADDR_VAR 0 2
63716: PUSH
63717: LD_VAR 0 2
63721: PPUSH
63722: LD_INT 4
63724: PPUSH
63725: LD_VAR 0 11
63729: PPUSH
63730: CALL_OW 1
63734: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
63735: LD_ADDR_VAR 0 4
63739: PUSH
63740: LD_VAR 0 4
63744: PUSH
63745: LD_VAR 0 7
63749: DIFF
63750: ST_TO_ADDR
// if tmp and mech < 6 then
63751: LD_VAR 0 4
63755: PUSH
63756: LD_VAR 0 7
63760: PUSH
63761: LD_INT 6
63763: LESS
63764: AND
63765: IFFALSE 63953
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63767: LD_ADDR_VAR 0 9
63771: PUSH
63772: LD_VAR 0 4
63776: PUSH
63777: LD_VAR 0 8
63781: PUSH
63782: LD_VAR 0 7
63786: UNION
63787: DIFF
63788: PPUSH
63789: LD_INT 3
63791: PPUSH
63792: CALL 55069 0 2
63796: ST_TO_ADDR
// p := [ ] ;
63797: LD_ADDR_VAR 0 11
63801: PUSH
63802: EMPTY
63803: ST_TO_ADDR
// if sort then
63804: LD_VAR 0 9
63808: IFFALSE 63924
// for i = 1 to 6 - mech do
63810: LD_ADDR_VAR 0 3
63814: PUSH
63815: DOUBLE
63816: LD_INT 1
63818: DEC
63819: ST_TO_ADDR
63820: LD_INT 6
63822: PUSH
63823: LD_VAR 0 7
63827: MINUS
63828: PUSH
63829: FOR_TO
63830: IFFALSE 63922
// begin if i = sort then
63832: LD_VAR 0 3
63836: PUSH
63837: LD_VAR 0 9
63841: EQUAL
63842: IFFALSE 63846
// break ;
63844: GO 63922
// if GetClass ( i ) = 3 then
63846: LD_VAR 0 3
63850: PPUSH
63851: CALL_OW 257
63855: PUSH
63856: LD_INT 3
63858: EQUAL
63859: IFFALSE 63863
// continue ;
63861: GO 63829
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63863: LD_ADDR_VAR 0 11
63867: PUSH
63868: LD_VAR 0 11
63872: PPUSH
63873: LD_VAR 0 11
63877: PUSH
63878: LD_INT 1
63880: PLUS
63881: PPUSH
63882: LD_VAR 0 9
63886: PUSH
63887: LD_VAR 0 3
63891: ARRAY
63892: PPUSH
63893: CALL_OW 2
63897: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63898: LD_ADDR_VAR 0 4
63902: PUSH
63903: LD_VAR 0 4
63907: PUSH
63908: LD_VAR 0 9
63912: PUSH
63913: LD_VAR 0 3
63917: ARRAY
63918: DIFF
63919: ST_TO_ADDR
// end ;
63920: GO 63829
63922: POP
63923: POP
// if p then
63924: LD_VAR 0 11
63928: IFFALSE 63953
// result := Replace ( result , 3 , p ) ;
63930: LD_ADDR_VAR 0 2
63934: PUSH
63935: LD_VAR 0 2
63939: PPUSH
63940: LD_INT 3
63942: PPUSH
63943: LD_VAR 0 11
63947: PPUSH
63948: CALL_OW 1
63952: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
63953: LD_ADDR_VAR 0 4
63957: PUSH
63958: LD_VAR 0 4
63962: PUSH
63963: LD_VAR 0 6
63967: DIFF
63968: ST_TO_ADDR
// if tmp and eng < 6 then
63969: LD_VAR 0 4
63973: PUSH
63974: LD_VAR 0 6
63978: PUSH
63979: LD_INT 6
63981: LESS
63982: AND
63983: IFFALSE 64177
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63985: LD_ADDR_VAR 0 9
63989: PUSH
63990: LD_VAR 0 4
63994: PUSH
63995: LD_VAR 0 8
63999: PUSH
64000: LD_VAR 0 7
64004: UNION
64005: PUSH
64006: LD_VAR 0 6
64010: UNION
64011: DIFF
64012: PPUSH
64013: LD_INT 2
64015: PPUSH
64016: CALL 55069 0 2
64020: ST_TO_ADDR
// p := [ ] ;
64021: LD_ADDR_VAR 0 11
64025: PUSH
64026: EMPTY
64027: ST_TO_ADDR
// if sort then
64028: LD_VAR 0 9
64032: IFFALSE 64148
// for i = 1 to 6 - eng do
64034: LD_ADDR_VAR 0 3
64038: PUSH
64039: DOUBLE
64040: LD_INT 1
64042: DEC
64043: ST_TO_ADDR
64044: LD_INT 6
64046: PUSH
64047: LD_VAR 0 6
64051: MINUS
64052: PUSH
64053: FOR_TO
64054: IFFALSE 64146
// begin if i = sort then
64056: LD_VAR 0 3
64060: PUSH
64061: LD_VAR 0 9
64065: EQUAL
64066: IFFALSE 64070
// break ;
64068: GO 64146
// if GetClass ( i ) = 2 then
64070: LD_VAR 0 3
64074: PPUSH
64075: CALL_OW 257
64079: PUSH
64080: LD_INT 2
64082: EQUAL
64083: IFFALSE 64087
// continue ;
64085: GO 64053
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64087: LD_ADDR_VAR 0 11
64091: PUSH
64092: LD_VAR 0 11
64096: PPUSH
64097: LD_VAR 0 11
64101: PUSH
64102: LD_INT 1
64104: PLUS
64105: PPUSH
64106: LD_VAR 0 9
64110: PUSH
64111: LD_VAR 0 3
64115: ARRAY
64116: PPUSH
64117: CALL_OW 2
64121: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64122: LD_ADDR_VAR 0 4
64126: PUSH
64127: LD_VAR 0 4
64131: PUSH
64132: LD_VAR 0 9
64136: PUSH
64137: LD_VAR 0 3
64141: ARRAY
64142: DIFF
64143: ST_TO_ADDR
// end ;
64144: GO 64053
64146: POP
64147: POP
// if p then
64148: LD_VAR 0 11
64152: IFFALSE 64177
// result := Replace ( result , 2 , p ) ;
64154: LD_ADDR_VAR 0 2
64158: PUSH
64159: LD_VAR 0 2
64163: PPUSH
64164: LD_INT 2
64166: PPUSH
64167: LD_VAR 0 11
64171: PPUSH
64172: CALL_OW 1
64176: ST_TO_ADDR
// end ; exit ;
64177: GO 64901
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
64179: LD_EXP 85
64183: PUSH
64184: LD_EXP 84
64188: PUSH
64189: LD_VAR 0 1
64193: ARRAY
64194: ARRAY
64195: NOT
64196: PUSH
64197: LD_EXP 58
64201: PUSH
64202: LD_VAR 0 1
64206: ARRAY
64207: PPUSH
64208: LD_INT 30
64210: PUSH
64211: LD_INT 3
64213: PUSH
64214: EMPTY
64215: LIST
64216: LIST
64217: PPUSH
64218: CALL_OW 72
64222: AND
64223: PUSH
64224: LD_EXP 63
64228: PUSH
64229: LD_VAR 0 1
64233: ARRAY
64234: NOT
64235: AND
64236: IFFALSE 64901
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
64238: LD_ADDR_EXP 100
64242: PUSH
64243: LD_EXP 100
64247: PPUSH
64248: LD_VAR 0 1
64252: PPUSH
64253: LD_INT 6
64255: PPUSH
64256: CALL_OW 1
64260: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64261: LD_ADDR_VAR 0 2
64265: PUSH
64266: LD_INT 0
64268: PUSH
64269: LD_INT 0
64271: PUSH
64272: LD_INT 0
64274: PUSH
64275: LD_INT 0
64277: PUSH
64278: EMPTY
64279: LIST
64280: LIST
64281: LIST
64282: LIST
64283: ST_TO_ADDR
// if sci >= 1 then
64284: LD_VAR 0 8
64288: PUSH
64289: LD_INT 1
64291: GREATEREQUAL
64292: IFFALSE 64314
// tmp := tmp diff sci [ 1 ] ;
64294: LD_ADDR_VAR 0 4
64298: PUSH
64299: LD_VAR 0 4
64303: PUSH
64304: LD_VAR 0 8
64308: PUSH
64309: LD_INT 1
64311: ARRAY
64312: DIFF
64313: ST_TO_ADDR
// if tmp and not sci then
64314: LD_VAR 0 4
64318: PUSH
64319: LD_VAR 0 8
64323: NOT
64324: AND
64325: IFFALSE 64394
// begin sort := SortBySkill ( tmp , 4 ) ;
64327: LD_ADDR_VAR 0 9
64331: PUSH
64332: LD_VAR 0 4
64336: PPUSH
64337: LD_INT 4
64339: PPUSH
64340: CALL 55069 0 2
64344: ST_TO_ADDR
// if sort then
64345: LD_VAR 0 9
64349: IFFALSE 64365
// p := sort [ 1 ] ;
64351: LD_ADDR_VAR 0 11
64355: PUSH
64356: LD_VAR 0 9
64360: PUSH
64361: LD_INT 1
64363: ARRAY
64364: ST_TO_ADDR
// if p then
64365: LD_VAR 0 11
64369: IFFALSE 64394
// result := Replace ( result , 4 , p ) ;
64371: LD_ADDR_VAR 0 2
64375: PUSH
64376: LD_VAR 0 2
64380: PPUSH
64381: LD_INT 4
64383: PPUSH
64384: LD_VAR 0 11
64388: PPUSH
64389: CALL_OW 1
64393: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64394: LD_ADDR_VAR 0 4
64398: PUSH
64399: LD_VAR 0 4
64403: PUSH
64404: LD_VAR 0 7
64408: DIFF
64409: ST_TO_ADDR
// if tmp and mech < 6 then
64410: LD_VAR 0 4
64414: PUSH
64415: LD_VAR 0 7
64419: PUSH
64420: LD_INT 6
64422: LESS
64423: AND
64424: IFFALSE 64606
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
64426: LD_ADDR_VAR 0 9
64430: PUSH
64431: LD_VAR 0 4
64435: PUSH
64436: LD_VAR 0 7
64440: DIFF
64441: PPUSH
64442: LD_INT 3
64444: PPUSH
64445: CALL 55069 0 2
64449: ST_TO_ADDR
// p := [ ] ;
64450: LD_ADDR_VAR 0 11
64454: PUSH
64455: EMPTY
64456: ST_TO_ADDR
// if sort then
64457: LD_VAR 0 9
64461: IFFALSE 64577
// for i = 1 to 6 - mech do
64463: LD_ADDR_VAR 0 3
64467: PUSH
64468: DOUBLE
64469: LD_INT 1
64471: DEC
64472: ST_TO_ADDR
64473: LD_INT 6
64475: PUSH
64476: LD_VAR 0 7
64480: MINUS
64481: PUSH
64482: FOR_TO
64483: IFFALSE 64575
// begin if i = sort then
64485: LD_VAR 0 3
64489: PUSH
64490: LD_VAR 0 9
64494: EQUAL
64495: IFFALSE 64499
// break ;
64497: GO 64575
// if GetClass ( i ) = 3 then
64499: LD_VAR 0 3
64503: PPUSH
64504: CALL_OW 257
64508: PUSH
64509: LD_INT 3
64511: EQUAL
64512: IFFALSE 64516
// continue ;
64514: GO 64482
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64516: LD_ADDR_VAR 0 11
64520: PUSH
64521: LD_VAR 0 11
64525: PPUSH
64526: LD_VAR 0 11
64530: PUSH
64531: LD_INT 1
64533: PLUS
64534: PPUSH
64535: LD_VAR 0 9
64539: PUSH
64540: LD_VAR 0 3
64544: ARRAY
64545: PPUSH
64546: CALL_OW 2
64550: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64551: LD_ADDR_VAR 0 4
64555: PUSH
64556: LD_VAR 0 4
64560: PUSH
64561: LD_VAR 0 9
64565: PUSH
64566: LD_VAR 0 3
64570: ARRAY
64571: DIFF
64572: ST_TO_ADDR
// end ;
64573: GO 64482
64575: POP
64576: POP
// if p then
64577: LD_VAR 0 11
64581: IFFALSE 64606
// result := Replace ( result , 3 , p ) ;
64583: LD_ADDR_VAR 0 2
64587: PUSH
64588: LD_VAR 0 2
64592: PPUSH
64593: LD_INT 3
64595: PPUSH
64596: LD_VAR 0 11
64600: PPUSH
64601: CALL_OW 1
64605: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64606: LD_ADDR_VAR 0 4
64610: PUSH
64611: LD_VAR 0 4
64615: PUSH
64616: LD_VAR 0 6
64620: DIFF
64621: ST_TO_ADDR
// if tmp and eng < 4 then
64622: LD_VAR 0 4
64626: PUSH
64627: LD_VAR 0 6
64631: PUSH
64632: LD_INT 4
64634: LESS
64635: AND
64636: IFFALSE 64826
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
64638: LD_ADDR_VAR 0 9
64642: PUSH
64643: LD_VAR 0 4
64647: PUSH
64648: LD_VAR 0 7
64652: PUSH
64653: LD_VAR 0 6
64657: UNION
64658: DIFF
64659: PPUSH
64660: LD_INT 2
64662: PPUSH
64663: CALL 55069 0 2
64667: ST_TO_ADDR
// p := [ ] ;
64668: LD_ADDR_VAR 0 11
64672: PUSH
64673: EMPTY
64674: ST_TO_ADDR
// if sort then
64675: LD_VAR 0 9
64679: IFFALSE 64795
// for i = 1 to 4 - eng do
64681: LD_ADDR_VAR 0 3
64685: PUSH
64686: DOUBLE
64687: LD_INT 1
64689: DEC
64690: ST_TO_ADDR
64691: LD_INT 4
64693: PUSH
64694: LD_VAR 0 6
64698: MINUS
64699: PUSH
64700: FOR_TO
64701: IFFALSE 64793
// begin if i = sort then
64703: LD_VAR 0 3
64707: PUSH
64708: LD_VAR 0 9
64712: EQUAL
64713: IFFALSE 64717
// break ;
64715: GO 64793
// if GetClass ( i ) = 2 then
64717: LD_VAR 0 3
64721: PPUSH
64722: CALL_OW 257
64726: PUSH
64727: LD_INT 2
64729: EQUAL
64730: IFFALSE 64734
// continue ;
64732: GO 64700
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64734: LD_ADDR_VAR 0 11
64738: PUSH
64739: LD_VAR 0 11
64743: PPUSH
64744: LD_VAR 0 11
64748: PUSH
64749: LD_INT 1
64751: PLUS
64752: PPUSH
64753: LD_VAR 0 9
64757: PUSH
64758: LD_VAR 0 3
64762: ARRAY
64763: PPUSH
64764: CALL_OW 2
64768: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64769: LD_ADDR_VAR 0 4
64773: PUSH
64774: LD_VAR 0 4
64778: PUSH
64779: LD_VAR 0 9
64783: PUSH
64784: LD_VAR 0 3
64788: ARRAY
64789: DIFF
64790: ST_TO_ADDR
// end ;
64791: GO 64700
64793: POP
64794: POP
// if p then
64795: LD_VAR 0 11
64799: IFFALSE 64824
// result := Replace ( result , 2 , p ) ;
64801: LD_ADDR_VAR 0 2
64805: PUSH
64806: LD_VAR 0 2
64810: PPUSH
64811: LD_INT 2
64813: PPUSH
64814: LD_VAR 0 11
64818: PPUSH
64819: CALL_OW 1
64823: ST_TO_ADDR
// end else
64824: GO 64870
// for i = eng downto 5 do
64826: LD_ADDR_VAR 0 3
64830: PUSH
64831: DOUBLE
64832: LD_VAR 0 6
64836: INC
64837: ST_TO_ADDR
64838: LD_INT 5
64840: PUSH
64841: FOR_DOWNTO
64842: IFFALSE 64868
// tmp := tmp union eng [ i ] ;
64844: LD_ADDR_VAR 0 4
64848: PUSH
64849: LD_VAR 0 4
64853: PUSH
64854: LD_VAR 0 6
64858: PUSH
64859: LD_VAR 0 3
64863: ARRAY
64864: UNION
64865: ST_TO_ADDR
64866: GO 64841
64868: POP
64869: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
64870: LD_ADDR_VAR 0 2
64874: PUSH
64875: LD_VAR 0 2
64879: PPUSH
64880: LD_INT 1
64882: PPUSH
64883: LD_VAR 0 4
64887: PUSH
64888: LD_VAR 0 5
64892: DIFF
64893: PPUSH
64894: CALL_OW 1
64898: ST_TO_ADDR
// exit ;
64899: GO 64901
// end ; end ;
64901: LD_VAR 0 2
64905: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
64906: LD_INT 0
64908: PPUSH
64909: PPUSH
64910: PPUSH
// if not mc_bases then
64911: LD_EXP 58
64915: NOT
64916: IFFALSE 64920
// exit ;
64918: GO 65026
// for i = 1 to mc_bases do
64920: LD_ADDR_VAR 0 2
64924: PUSH
64925: DOUBLE
64926: LD_INT 1
64928: DEC
64929: ST_TO_ADDR
64930: LD_EXP 58
64934: PUSH
64935: FOR_TO
64936: IFFALSE 65017
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64938: LD_ADDR_VAR 0 3
64942: PUSH
64943: LD_EXP 58
64947: PUSH
64948: LD_VAR 0 2
64952: ARRAY
64953: PPUSH
64954: LD_INT 21
64956: PUSH
64957: LD_INT 3
64959: PUSH
64960: EMPTY
64961: LIST
64962: LIST
64963: PUSH
64964: LD_INT 3
64966: PUSH
64967: LD_INT 24
64969: PUSH
64970: LD_INT 1000
64972: PUSH
64973: EMPTY
64974: LIST
64975: LIST
64976: PUSH
64977: EMPTY
64978: LIST
64979: LIST
64980: PUSH
64981: EMPTY
64982: LIST
64983: LIST
64984: PPUSH
64985: CALL_OW 72
64989: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
64990: LD_ADDR_EXP 59
64994: PUSH
64995: LD_EXP 59
64999: PPUSH
65000: LD_VAR 0 2
65004: PPUSH
65005: LD_VAR 0 3
65009: PPUSH
65010: CALL_OW 1
65014: ST_TO_ADDR
// end ;
65015: GO 64935
65017: POP
65018: POP
// RaiseSailEvent ( 101 ) ;
65019: LD_INT 101
65021: PPUSH
65022: CALL_OW 427
// end ;
65026: LD_VAR 0 1
65030: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
65031: LD_INT 0
65033: PPUSH
65034: PPUSH
65035: PPUSH
65036: PPUSH
65037: PPUSH
65038: PPUSH
65039: PPUSH
// if not mc_bases then
65040: LD_EXP 58
65044: NOT
65045: IFFALSE 65049
// exit ;
65047: GO 65622
// for i = 1 to mc_bases do
65049: LD_ADDR_VAR 0 2
65053: PUSH
65054: DOUBLE
65055: LD_INT 1
65057: DEC
65058: ST_TO_ADDR
65059: LD_EXP 58
65063: PUSH
65064: FOR_TO
65065: IFFALSE 65613
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
65067: LD_ADDR_VAR 0 5
65071: PUSH
65072: LD_EXP 58
65076: PUSH
65077: LD_VAR 0 2
65081: ARRAY
65082: PUSH
65083: LD_EXP 87
65087: PUSH
65088: LD_VAR 0 2
65092: ARRAY
65093: UNION
65094: PPUSH
65095: LD_INT 21
65097: PUSH
65098: LD_INT 1
65100: PUSH
65101: EMPTY
65102: LIST
65103: LIST
65104: PUSH
65105: LD_INT 1
65107: PUSH
65108: LD_INT 3
65110: PUSH
65111: LD_INT 54
65113: PUSH
65114: EMPTY
65115: LIST
65116: PUSH
65117: EMPTY
65118: LIST
65119: LIST
65120: PUSH
65121: LD_INT 3
65123: PUSH
65124: LD_INT 24
65126: PUSH
65127: LD_INT 800
65129: PUSH
65130: EMPTY
65131: LIST
65132: LIST
65133: PUSH
65134: EMPTY
65135: LIST
65136: LIST
65137: PUSH
65138: EMPTY
65139: LIST
65140: LIST
65141: LIST
65142: PUSH
65143: EMPTY
65144: LIST
65145: LIST
65146: PPUSH
65147: CALL_OW 72
65151: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
65152: LD_ADDR_VAR 0 6
65156: PUSH
65157: LD_EXP 58
65161: PUSH
65162: LD_VAR 0 2
65166: ARRAY
65167: PPUSH
65168: LD_INT 21
65170: PUSH
65171: LD_INT 1
65173: PUSH
65174: EMPTY
65175: LIST
65176: LIST
65177: PUSH
65178: LD_INT 1
65180: PUSH
65181: LD_INT 3
65183: PUSH
65184: LD_INT 54
65186: PUSH
65187: EMPTY
65188: LIST
65189: PUSH
65190: EMPTY
65191: LIST
65192: LIST
65193: PUSH
65194: LD_INT 3
65196: PUSH
65197: LD_INT 24
65199: PUSH
65200: LD_INT 250
65202: PUSH
65203: EMPTY
65204: LIST
65205: LIST
65206: PUSH
65207: EMPTY
65208: LIST
65209: LIST
65210: PUSH
65211: EMPTY
65212: LIST
65213: LIST
65214: LIST
65215: PUSH
65216: EMPTY
65217: LIST
65218: LIST
65219: PPUSH
65220: CALL_OW 72
65224: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
65225: LD_ADDR_VAR 0 7
65229: PUSH
65230: LD_VAR 0 5
65234: PUSH
65235: LD_VAR 0 6
65239: DIFF
65240: ST_TO_ADDR
// if not need_heal_1 then
65241: LD_VAR 0 6
65245: NOT
65246: IFFALSE 65279
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
65248: LD_ADDR_EXP 61
65252: PUSH
65253: LD_EXP 61
65257: PPUSH
65258: LD_VAR 0 2
65262: PUSH
65263: LD_INT 1
65265: PUSH
65266: EMPTY
65267: LIST
65268: LIST
65269: PPUSH
65270: EMPTY
65271: PPUSH
65272: CALL 20821 0 3
65276: ST_TO_ADDR
65277: GO 65349
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
65279: LD_ADDR_EXP 61
65283: PUSH
65284: LD_EXP 61
65288: PPUSH
65289: LD_VAR 0 2
65293: PUSH
65294: LD_INT 1
65296: PUSH
65297: EMPTY
65298: LIST
65299: LIST
65300: PPUSH
65301: LD_EXP 61
65305: PUSH
65306: LD_VAR 0 2
65310: ARRAY
65311: PUSH
65312: LD_INT 1
65314: ARRAY
65315: PPUSH
65316: LD_INT 3
65318: PUSH
65319: LD_INT 24
65321: PUSH
65322: LD_INT 1000
65324: PUSH
65325: EMPTY
65326: LIST
65327: LIST
65328: PUSH
65329: EMPTY
65330: LIST
65331: LIST
65332: PPUSH
65333: CALL_OW 72
65337: PUSH
65338: LD_VAR 0 6
65342: UNION
65343: PPUSH
65344: CALL 20821 0 3
65348: ST_TO_ADDR
// if not need_heal_2 then
65349: LD_VAR 0 7
65353: NOT
65354: IFFALSE 65387
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
65356: LD_ADDR_EXP 61
65360: PUSH
65361: LD_EXP 61
65365: PPUSH
65366: LD_VAR 0 2
65370: PUSH
65371: LD_INT 2
65373: PUSH
65374: EMPTY
65375: LIST
65376: LIST
65377: PPUSH
65378: EMPTY
65379: PPUSH
65380: CALL 20821 0 3
65384: ST_TO_ADDR
65385: GO 65419
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
65387: LD_ADDR_EXP 61
65391: PUSH
65392: LD_EXP 61
65396: PPUSH
65397: LD_VAR 0 2
65401: PUSH
65402: LD_INT 2
65404: PUSH
65405: EMPTY
65406: LIST
65407: LIST
65408: PPUSH
65409: LD_VAR 0 7
65413: PPUSH
65414: CALL 20821 0 3
65418: ST_TO_ADDR
// if need_heal_2 then
65419: LD_VAR 0 7
65423: IFFALSE 65595
// for j in need_heal_2 do
65425: LD_ADDR_VAR 0 3
65429: PUSH
65430: LD_VAR 0 7
65434: PUSH
65435: FOR_IN
65436: IFFALSE 65593
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
65438: LD_ADDR_VAR 0 5
65442: PUSH
65443: LD_EXP 58
65447: PUSH
65448: LD_VAR 0 2
65452: ARRAY
65453: PPUSH
65454: LD_INT 2
65456: PUSH
65457: LD_INT 30
65459: PUSH
65460: LD_INT 6
65462: PUSH
65463: EMPTY
65464: LIST
65465: LIST
65466: PUSH
65467: LD_INT 30
65469: PUSH
65470: LD_INT 7
65472: PUSH
65473: EMPTY
65474: LIST
65475: LIST
65476: PUSH
65477: LD_INT 30
65479: PUSH
65480: LD_INT 8
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: PUSH
65487: LD_INT 30
65489: PUSH
65490: LD_INT 0
65492: PUSH
65493: EMPTY
65494: LIST
65495: LIST
65496: PUSH
65497: LD_INT 30
65499: PUSH
65500: LD_INT 1
65502: PUSH
65503: EMPTY
65504: LIST
65505: LIST
65506: PUSH
65507: LD_INT 25
65509: PUSH
65510: LD_INT 4
65512: PUSH
65513: EMPTY
65514: LIST
65515: LIST
65516: PUSH
65517: EMPTY
65518: LIST
65519: LIST
65520: LIST
65521: LIST
65522: LIST
65523: LIST
65524: LIST
65525: PPUSH
65526: CALL_OW 72
65530: ST_TO_ADDR
// if tmp then
65531: LD_VAR 0 5
65535: IFFALSE 65591
// begin k := NearestUnitToUnit ( tmp , j ) ;
65537: LD_ADDR_VAR 0 4
65541: PUSH
65542: LD_VAR 0 5
65546: PPUSH
65547: LD_VAR 0 3
65551: PPUSH
65552: CALL_OW 74
65556: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
65557: LD_VAR 0 3
65561: PPUSH
65562: LD_VAR 0 4
65566: PPUSH
65567: CALL_OW 296
65571: PUSH
65572: LD_INT 7
65574: GREATER
65575: IFFALSE 65591
// ComMoveUnit ( j , k ) ;
65577: LD_VAR 0 3
65581: PPUSH
65582: LD_VAR 0 4
65586: PPUSH
65587: CALL_OW 112
// end ; end ;
65591: GO 65435
65593: POP
65594: POP
// if not need_heal_1 and not need_heal_2 then
65595: LD_VAR 0 6
65599: NOT
65600: PUSH
65601: LD_VAR 0 7
65605: NOT
65606: AND
65607: IFFALSE 65611
// continue ;
65609: GO 65064
// end ;
65611: GO 65064
65613: POP
65614: POP
// RaiseSailEvent ( 102 ) ;
65615: LD_INT 102
65617: PPUSH
65618: CALL_OW 427
// end ;
65622: LD_VAR 0 1
65626: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
65627: LD_INT 0
65629: PPUSH
65630: PPUSH
65631: PPUSH
65632: PPUSH
65633: PPUSH
65634: PPUSH
// if not mc_bases then
65635: LD_EXP 58
65639: NOT
65640: IFFALSE 65644
// exit ;
65642: GO 66354
// for i = 1 to mc_bases do
65644: LD_ADDR_VAR 0 2
65648: PUSH
65649: DOUBLE
65650: LD_INT 1
65652: DEC
65653: ST_TO_ADDR
65654: LD_EXP 58
65658: PUSH
65659: FOR_TO
65660: IFFALSE 66352
// begin if not mc_building_need_repair [ i ] then
65662: LD_EXP 59
65666: PUSH
65667: LD_VAR 0 2
65671: ARRAY
65672: NOT
65673: IFFALSE 65847
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
65675: LD_ADDR_VAR 0 6
65679: PUSH
65680: LD_EXP 77
65684: PUSH
65685: LD_VAR 0 2
65689: ARRAY
65690: PPUSH
65691: LD_INT 3
65693: PUSH
65694: LD_INT 24
65696: PUSH
65697: LD_INT 1000
65699: PUSH
65700: EMPTY
65701: LIST
65702: LIST
65703: PUSH
65704: EMPTY
65705: LIST
65706: LIST
65707: PUSH
65708: LD_INT 2
65710: PUSH
65711: LD_INT 34
65713: PUSH
65714: LD_INT 13
65716: PUSH
65717: EMPTY
65718: LIST
65719: LIST
65720: PUSH
65721: LD_INT 34
65723: PUSH
65724: LD_INT 52
65726: PUSH
65727: EMPTY
65728: LIST
65729: LIST
65730: PUSH
65731: EMPTY
65732: LIST
65733: LIST
65734: LIST
65735: PUSH
65736: EMPTY
65737: LIST
65738: LIST
65739: PPUSH
65740: CALL_OW 72
65744: ST_TO_ADDR
// if cranes then
65745: LD_VAR 0 6
65749: IFFALSE 65811
// for j in cranes do
65751: LD_ADDR_VAR 0 3
65755: PUSH
65756: LD_VAR 0 6
65760: PUSH
65761: FOR_IN
65762: IFFALSE 65809
// if not IsInArea ( j , mc_parking [ i ] ) then
65764: LD_VAR 0 3
65768: PPUSH
65769: LD_EXP 82
65773: PUSH
65774: LD_VAR 0 2
65778: ARRAY
65779: PPUSH
65780: CALL_OW 308
65784: NOT
65785: IFFALSE 65807
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65787: LD_VAR 0 3
65791: PPUSH
65792: LD_EXP 82
65796: PUSH
65797: LD_VAR 0 2
65801: ARRAY
65802: PPUSH
65803: CALL_OW 113
65807: GO 65761
65809: POP
65810: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
65811: LD_ADDR_EXP 60
65815: PUSH
65816: LD_EXP 60
65820: PPUSH
65821: LD_VAR 0 2
65825: PPUSH
65826: EMPTY
65827: PPUSH
65828: CALL_OW 1
65832: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
65833: LD_VAR 0 2
65837: PPUSH
65838: LD_INT 101
65840: PPUSH
65841: CALL 60739 0 2
// continue ;
65845: GO 65659
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
65847: LD_ADDR_EXP 64
65851: PUSH
65852: LD_EXP 64
65856: PPUSH
65857: LD_VAR 0 2
65861: PPUSH
65862: EMPTY
65863: PPUSH
65864: CALL_OW 1
65868: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65869: LD_VAR 0 2
65873: PPUSH
65874: LD_INT 103
65876: PPUSH
65877: CALL 60739 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
65881: LD_ADDR_VAR 0 5
65885: PUSH
65886: LD_EXP 58
65890: PUSH
65891: LD_VAR 0 2
65895: ARRAY
65896: PUSH
65897: LD_EXP 87
65901: PUSH
65902: LD_VAR 0 2
65906: ARRAY
65907: UNION
65908: PPUSH
65909: LD_INT 2
65911: PUSH
65912: LD_INT 25
65914: PUSH
65915: LD_INT 2
65917: PUSH
65918: EMPTY
65919: LIST
65920: LIST
65921: PUSH
65922: LD_INT 25
65924: PUSH
65925: LD_INT 16
65927: PUSH
65928: EMPTY
65929: LIST
65930: LIST
65931: PUSH
65932: EMPTY
65933: LIST
65934: LIST
65935: LIST
65936: PUSH
65937: EMPTY
65938: LIST
65939: PPUSH
65940: CALL_OW 72
65944: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
65945: LD_ADDR_VAR 0 6
65949: PUSH
65950: LD_EXP 77
65954: PUSH
65955: LD_VAR 0 2
65959: ARRAY
65960: PPUSH
65961: LD_INT 2
65963: PUSH
65964: LD_INT 34
65966: PUSH
65967: LD_INT 13
65969: PUSH
65970: EMPTY
65971: LIST
65972: LIST
65973: PUSH
65974: LD_INT 34
65976: PUSH
65977: LD_INT 52
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: PUSH
65984: EMPTY
65985: LIST
65986: LIST
65987: LIST
65988: PPUSH
65989: CALL_OW 72
65993: ST_TO_ADDR
// if cranes then
65994: LD_VAR 0 6
65998: IFFALSE 66134
// begin for j in cranes do
66000: LD_ADDR_VAR 0 3
66004: PUSH
66005: LD_VAR 0 6
66009: PUSH
66010: FOR_IN
66011: IFFALSE 66132
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
66013: LD_VAR 0 3
66017: PPUSH
66018: CALL_OW 256
66022: PUSH
66023: LD_INT 500
66025: GREATEREQUAL
66026: PUSH
66027: LD_VAR 0 3
66031: PPUSH
66032: CALL_OW 314
66036: NOT
66037: AND
66038: IFFALSE 66072
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
66040: LD_VAR 0 3
66044: PPUSH
66045: LD_EXP 59
66049: PUSH
66050: LD_VAR 0 2
66054: ARRAY
66055: PPUSH
66056: LD_VAR 0 3
66060: PPUSH
66061: CALL_OW 74
66065: PPUSH
66066: CALL_OW 130
66070: GO 66130
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
66072: LD_VAR 0 3
66076: PPUSH
66077: CALL_OW 256
66081: PUSH
66082: LD_INT 500
66084: LESS
66085: PUSH
66086: LD_VAR 0 3
66090: PPUSH
66091: LD_EXP 82
66095: PUSH
66096: LD_VAR 0 2
66100: ARRAY
66101: PPUSH
66102: CALL_OW 308
66106: NOT
66107: AND
66108: IFFALSE 66130
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66110: LD_VAR 0 3
66114: PPUSH
66115: LD_EXP 82
66119: PUSH
66120: LD_VAR 0 2
66124: ARRAY
66125: PPUSH
66126: CALL_OW 113
66130: GO 66010
66132: POP
66133: POP
// end ; if not tmp then
66134: LD_VAR 0 5
66138: NOT
66139: IFFALSE 66143
// continue ;
66141: GO 65659
// for j in tmp do
66143: LD_ADDR_VAR 0 3
66147: PUSH
66148: LD_VAR 0 5
66152: PUSH
66153: FOR_IN
66154: IFFALSE 66348
// begin if mc_need_heal [ i ] then
66156: LD_EXP 61
66160: PUSH
66161: LD_VAR 0 2
66165: ARRAY
66166: IFFALSE 66214
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
66168: LD_VAR 0 3
66172: PUSH
66173: LD_EXP 61
66177: PUSH
66178: LD_VAR 0 2
66182: ARRAY
66183: PUSH
66184: LD_INT 1
66186: ARRAY
66187: IN
66188: PUSH
66189: LD_VAR 0 3
66193: PUSH
66194: LD_EXP 61
66198: PUSH
66199: LD_VAR 0 2
66203: ARRAY
66204: PUSH
66205: LD_INT 2
66207: ARRAY
66208: IN
66209: OR
66210: IFFALSE 66214
// continue ;
66212: GO 66153
// if IsInUnit ( j ) then
66214: LD_VAR 0 3
66218: PPUSH
66219: CALL_OW 310
66223: IFFALSE 66234
// ComExitBuilding ( j ) ;
66225: LD_VAR 0 3
66229: PPUSH
66230: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
66234: LD_VAR 0 3
66238: PUSH
66239: LD_EXP 60
66243: PUSH
66244: LD_VAR 0 2
66248: ARRAY
66249: IN
66250: NOT
66251: IFFALSE 66309
// begin SetTag ( j , 101 ) ;
66253: LD_VAR 0 3
66257: PPUSH
66258: LD_INT 101
66260: PPUSH
66261: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
66265: LD_ADDR_EXP 60
66269: PUSH
66270: LD_EXP 60
66274: PPUSH
66275: LD_VAR 0 2
66279: PUSH
66280: LD_EXP 60
66284: PUSH
66285: LD_VAR 0 2
66289: ARRAY
66290: PUSH
66291: LD_INT 1
66293: PLUS
66294: PUSH
66295: EMPTY
66296: LIST
66297: LIST
66298: PPUSH
66299: LD_VAR 0 3
66303: PPUSH
66304: CALL 20821 0 3
66308: ST_TO_ADDR
// end ; wait ( 1 ) ;
66309: LD_INT 1
66311: PPUSH
66312: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
66316: LD_VAR 0 3
66320: PPUSH
66321: LD_EXP 59
66325: PUSH
66326: LD_VAR 0 2
66330: ARRAY
66331: PPUSH
66332: LD_VAR 0 3
66336: PPUSH
66337: CALL_OW 74
66341: PPUSH
66342: CALL_OW 130
// end ;
66346: GO 66153
66348: POP
66349: POP
// end ;
66350: GO 65659
66352: POP
66353: POP
// end ;
66354: LD_VAR 0 1
66358: RET
// export function MC_Heal ; var i , j , tmp ; begin
66359: LD_INT 0
66361: PPUSH
66362: PPUSH
66363: PPUSH
66364: PPUSH
// if not mc_bases then
66365: LD_EXP 58
66369: NOT
66370: IFFALSE 66374
// exit ;
66372: GO 66776
// for i = 1 to mc_bases do
66374: LD_ADDR_VAR 0 2
66378: PUSH
66379: DOUBLE
66380: LD_INT 1
66382: DEC
66383: ST_TO_ADDR
66384: LD_EXP 58
66388: PUSH
66389: FOR_TO
66390: IFFALSE 66774
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
66392: LD_EXP 61
66396: PUSH
66397: LD_VAR 0 2
66401: ARRAY
66402: PUSH
66403: LD_INT 1
66405: ARRAY
66406: NOT
66407: PUSH
66408: LD_EXP 61
66412: PUSH
66413: LD_VAR 0 2
66417: ARRAY
66418: PUSH
66419: LD_INT 2
66421: ARRAY
66422: NOT
66423: AND
66424: IFFALSE 66462
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
66426: LD_ADDR_EXP 62
66430: PUSH
66431: LD_EXP 62
66435: PPUSH
66436: LD_VAR 0 2
66440: PPUSH
66441: EMPTY
66442: PPUSH
66443: CALL_OW 1
66447: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
66448: LD_VAR 0 2
66452: PPUSH
66453: LD_INT 102
66455: PPUSH
66456: CALL 60739 0 2
// continue ;
66460: GO 66389
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
66462: LD_ADDR_VAR 0 4
66466: PUSH
66467: LD_EXP 58
66471: PUSH
66472: LD_VAR 0 2
66476: ARRAY
66477: PPUSH
66478: LD_INT 25
66480: PUSH
66481: LD_INT 4
66483: PUSH
66484: EMPTY
66485: LIST
66486: LIST
66487: PPUSH
66488: CALL_OW 72
66492: ST_TO_ADDR
// if not tmp then
66493: LD_VAR 0 4
66497: NOT
66498: IFFALSE 66502
// continue ;
66500: GO 66389
// if mc_taming [ i ] then
66502: LD_EXP 89
66506: PUSH
66507: LD_VAR 0 2
66511: ARRAY
66512: IFFALSE 66536
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
66514: LD_ADDR_EXP 89
66518: PUSH
66519: LD_EXP 89
66523: PPUSH
66524: LD_VAR 0 2
66528: PPUSH
66529: EMPTY
66530: PPUSH
66531: CALL_OW 1
66535: ST_TO_ADDR
// for j in tmp do
66536: LD_ADDR_VAR 0 3
66540: PUSH
66541: LD_VAR 0 4
66545: PUSH
66546: FOR_IN
66547: IFFALSE 66770
// begin if IsInUnit ( j ) then
66549: LD_VAR 0 3
66553: PPUSH
66554: CALL_OW 310
66558: IFFALSE 66569
// ComExitBuilding ( j ) ;
66560: LD_VAR 0 3
66564: PPUSH
66565: CALL_OW 122
// if not j in mc_healers [ i ] then
66569: LD_VAR 0 3
66573: PUSH
66574: LD_EXP 62
66578: PUSH
66579: LD_VAR 0 2
66583: ARRAY
66584: IN
66585: NOT
66586: IFFALSE 66632
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
66588: LD_ADDR_EXP 62
66592: PUSH
66593: LD_EXP 62
66597: PPUSH
66598: LD_VAR 0 2
66602: PUSH
66603: LD_EXP 62
66607: PUSH
66608: LD_VAR 0 2
66612: ARRAY
66613: PUSH
66614: LD_INT 1
66616: PLUS
66617: PUSH
66618: EMPTY
66619: LIST
66620: LIST
66621: PPUSH
66622: LD_VAR 0 3
66626: PPUSH
66627: CALL 20821 0 3
66631: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
66632: LD_VAR 0 3
66636: PPUSH
66637: CALL_OW 110
66641: PUSH
66642: LD_INT 102
66644: NONEQUAL
66645: IFFALSE 66659
// SetTag ( j , 102 ) ;
66647: LD_VAR 0 3
66651: PPUSH
66652: LD_INT 102
66654: PPUSH
66655: CALL_OW 109
// Wait ( 3 ) ;
66659: LD_INT 3
66661: PPUSH
66662: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
66666: LD_EXP 61
66670: PUSH
66671: LD_VAR 0 2
66675: ARRAY
66676: PUSH
66677: LD_INT 1
66679: ARRAY
66680: IFFALSE 66712
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
66682: LD_VAR 0 3
66686: PPUSH
66687: LD_EXP 61
66691: PUSH
66692: LD_VAR 0 2
66696: ARRAY
66697: PUSH
66698: LD_INT 1
66700: ARRAY
66701: PUSH
66702: LD_INT 1
66704: ARRAY
66705: PPUSH
66706: CALL_OW 128
66710: GO 66768
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
66712: LD_VAR 0 3
66716: PPUSH
66717: CALL_OW 314
66721: NOT
66722: PUSH
66723: LD_EXP 61
66727: PUSH
66728: LD_VAR 0 2
66732: ARRAY
66733: PUSH
66734: LD_INT 2
66736: ARRAY
66737: AND
66738: IFFALSE 66768
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
66740: LD_VAR 0 3
66744: PPUSH
66745: LD_EXP 61
66749: PUSH
66750: LD_VAR 0 2
66754: ARRAY
66755: PUSH
66756: LD_INT 2
66758: ARRAY
66759: PUSH
66760: LD_INT 1
66762: ARRAY
66763: PPUSH
66764: CALL_OW 128
// end ;
66768: GO 66546
66770: POP
66771: POP
// end ;
66772: GO 66389
66774: POP
66775: POP
// end ;
66776: LD_VAR 0 1
66780: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
66781: LD_INT 0
66783: PPUSH
66784: PPUSH
66785: PPUSH
66786: PPUSH
66787: PPUSH
// if not mc_bases then
66788: LD_EXP 58
66792: NOT
66793: IFFALSE 66797
// exit ;
66795: GO 67940
// for i = 1 to mc_bases do
66797: LD_ADDR_VAR 0 2
66801: PUSH
66802: DOUBLE
66803: LD_INT 1
66805: DEC
66806: ST_TO_ADDR
66807: LD_EXP 58
66811: PUSH
66812: FOR_TO
66813: IFFALSE 67938
// begin if mc_scan [ i ] then
66815: LD_EXP 81
66819: PUSH
66820: LD_VAR 0 2
66824: ARRAY
66825: IFFALSE 66829
// continue ;
66827: GO 66812
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
66829: LD_EXP 63
66833: PUSH
66834: LD_VAR 0 2
66838: ARRAY
66839: NOT
66840: PUSH
66841: LD_EXP 65
66845: PUSH
66846: LD_VAR 0 2
66850: ARRAY
66851: NOT
66852: AND
66853: PUSH
66854: LD_EXP 64
66858: PUSH
66859: LD_VAR 0 2
66863: ARRAY
66864: AND
66865: IFFALSE 66903
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
66867: LD_ADDR_EXP 64
66871: PUSH
66872: LD_EXP 64
66876: PPUSH
66877: LD_VAR 0 2
66881: PPUSH
66882: EMPTY
66883: PPUSH
66884: CALL_OW 1
66888: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66889: LD_VAR 0 2
66893: PPUSH
66894: LD_INT 103
66896: PPUSH
66897: CALL 60739 0 2
// continue ;
66901: GO 66812
// end ; if mc_construct_list [ i ] then
66903: LD_EXP 65
66907: PUSH
66908: LD_VAR 0 2
66912: ARRAY
66913: IFFALSE 67133
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
66915: LD_ADDR_VAR 0 4
66919: PUSH
66920: LD_EXP 58
66924: PUSH
66925: LD_VAR 0 2
66929: ARRAY
66930: PPUSH
66931: LD_INT 25
66933: PUSH
66934: LD_INT 2
66936: PUSH
66937: EMPTY
66938: LIST
66939: LIST
66940: PPUSH
66941: CALL_OW 72
66945: PUSH
66946: LD_EXP 60
66950: PUSH
66951: LD_VAR 0 2
66955: ARRAY
66956: DIFF
66957: ST_TO_ADDR
// if not tmp then
66958: LD_VAR 0 4
66962: NOT
66963: IFFALSE 66967
// continue ;
66965: GO 66812
// for j in tmp do
66967: LD_ADDR_VAR 0 3
66971: PUSH
66972: LD_VAR 0 4
66976: PUSH
66977: FOR_IN
66978: IFFALSE 67129
// begin if not mc_builders [ i ] then
66980: LD_EXP 64
66984: PUSH
66985: LD_VAR 0 2
66989: ARRAY
66990: NOT
66991: IFFALSE 67049
// begin SetTag ( j , 103 ) ;
66993: LD_VAR 0 3
66997: PPUSH
66998: LD_INT 103
67000: PPUSH
67001: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67005: LD_ADDR_EXP 64
67009: PUSH
67010: LD_EXP 64
67014: PPUSH
67015: LD_VAR 0 2
67019: PUSH
67020: LD_EXP 64
67024: PUSH
67025: LD_VAR 0 2
67029: ARRAY
67030: PUSH
67031: LD_INT 1
67033: PLUS
67034: PUSH
67035: EMPTY
67036: LIST
67037: LIST
67038: PPUSH
67039: LD_VAR 0 3
67043: PPUSH
67044: CALL 20821 0 3
67048: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67049: LD_VAR 0 3
67053: PPUSH
67054: CALL_OW 310
67058: IFFALSE 67069
// ComExitBuilding ( j ) ;
67060: LD_VAR 0 3
67064: PPUSH
67065: CALL_OW 122
// wait ( 3 ) ;
67069: LD_INT 3
67071: PPUSH
67072: CALL_OW 67
// if not mc_construct_list [ i ] then
67076: LD_EXP 65
67080: PUSH
67081: LD_VAR 0 2
67085: ARRAY
67086: NOT
67087: IFFALSE 67091
// break ;
67089: GO 67129
// if not HasTask ( j ) then
67091: LD_VAR 0 3
67095: PPUSH
67096: CALL_OW 314
67100: NOT
67101: IFFALSE 67127
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
67103: LD_VAR 0 3
67107: PPUSH
67108: LD_EXP 65
67112: PUSH
67113: LD_VAR 0 2
67117: ARRAY
67118: PUSH
67119: LD_INT 1
67121: ARRAY
67122: PPUSH
67123: CALL 23672 0 2
// end ;
67127: GO 66977
67129: POP
67130: POP
// end else
67131: GO 67936
// if mc_build_list [ i ] then
67133: LD_EXP 63
67137: PUSH
67138: LD_VAR 0 2
67142: ARRAY
67143: IFFALSE 67936
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67145: LD_ADDR_VAR 0 5
67149: PUSH
67150: LD_EXP 58
67154: PUSH
67155: LD_VAR 0 2
67159: ARRAY
67160: PPUSH
67161: LD_INT 2
67163: PUSH
67164: LD_INT 30
67166: PUSH
67167: LD_INT 0
67169: PUSH
67170: EMPTY
67171: LIST
67172: LIST
67173: PUSH
67174: LD_INT 30
67176: PUSH
67177: LD_INT 1
67179: PUSH
67180: EMPTY
67181: LIST
67182: LIST
67183: PUSH
67184: EMPTY
67185: LIST
67186: LIST
67187: LIST
67188: PPUSH
67189: CALL_OW 72
67193: ST_TO_ADDR
// if depot then
67194: LD_VAR 0 5
67198: IFFALSE 67216
// depot := depot [ 1 ] else
67200: LD_ADDR_VAR 0 5
67204: PUSH
67205: LD_VAR 0 5
67209: PUSH
67210: LD_INT 1
67212: ARRAY
67213: ST_TO_ADDR
67214: GO 67224
// depot := 0 ;
67216: LD_ADDR_VAR 0 5
67220: PUSH
67221: LD_INT 0
67223: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
67224: LD_EXP 63
67228: PUSH
67229: LD_VAR 0 2
67233: ARRAY
67234: PUSH
67235: LD_INT 1
67237: ARRAY
67238: PUSH
67239: LD_INT 1
67241: ARRAY
67242: PPUSH
67243: CALL 23502 0 1
67247: PUSH
67248: LD_EXP 58
67252: PUSH
67253: LD_VAR 0 2
67257: ARRAY
67258: PPUSH
67259: LD_INT 2
67261: PUSH
67262: LD_INT 30
67264: PUSH
67265: LD_INT 2
67267: PUSH
67268: EMPTY
67269: LIST
67270: LIST
67271: PUSH
67272: LD_INT 30
67274: PUSH
67275: LD_INT 3
67277: PUSH
67278: EMPTY
67279: LIST
67280: LIST
67281: PUSH
67282: EMPTY
67283: LIST
67284: LIST
67285: LIST
67286: PPUSH
67287: CALL_OW 72
67291: NOT
67292: AND
67293: IFFALSE 67398
// begin for j = 1 to mc_build_list [ i ] do
67295: LD_ADDR_VAR 0 3
67299: PUSH
67300: DOUBLE
67301: LD_INT 1
67303: DEC
67304: ST_TO_ADDR
67305: LD_EXP 63
67309: PUSH
67310: LD_VAR 0 2
67314: ARRAY
67315: PUSH
67316: FOR_TO
67317: IFFALSE 67396
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
67319: LD_EXP 63
67323: PUSH
67324: LD_VAR 0 2
67328: ARRAY
67329: PUSH
67330: LD_VAR 0 3
67334: ARRAY
67335: PUSH
67336: LD_INT 1
67338: ARRAY
67339: PUSH
67340: LD_INT 2
67342: EQUAL
67343: IFFALSE 67394
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
67345: LD_ADDR_EXP 63
67349: PUSH
67350: LD_EXP 63
67354: PPUSH
67355: LD_VAR 0 2
67359: PPUSH
67360: LD_EXP 63
67364: PUSH
67365: LD_VAR 0 2
67369: ARRAY
67370: PPUSH
67371: LD_VAR 0 3
67375: PPUSH
67376: LD_INT 1
67378: PPUSH
67379: LD_INT 0
67381: PPUSH
67382: CALL 20239 0 4
67386: PPUSH
67387: CALL_OW 1
67391: ST_TO_ADDR
// break ;
67392: GO 67396
// end ;
67394: GO 67316
67396: POP
67397: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
67398: LD_EXP 63
67402: PUSH
67403: LD_VAR 0 2
67407: ARRAY
67408: PUSH
67409: LD_INT 1
67411: ARRAY
67412: PUSH
67413: LD_INT 1
67415: ARRAY
67416: PUSH
67417: LD_INT 0
67419: EQUAL
67420: PUSH
67421: LD_VAR 0 5
67425: PUSH
67426: LD_VAR 0 5
67430: PPUSH
67431: LD_EXP 63
67435: PUSH
67436: LD_VAR 0 2
67440: ARRAY
67441: PUSH
67442: LD_INT 1
67444: ARRAY
67445: PUSH
67446: LD_INT 1
67448: ARRAY
67449: PPUSH
67450: LD_EXP 63
67454: PUSH
67455: LD_VAR 0 2
67459: ARRAY
67460: PUSH
67461: LD_INT 1
67463: ARRAY
67464: PUSH
67465: LD_INT 2
67467: ARRAY
67468: PPUSH
67469: LD_EXP 63
67473: PUSH
67474: LD_VAR 0 2
67478: ARRAY
67479: PUSH
67480: LD_INT 1
67482: ARRAY
67483: PUSH
67484: LD_INT 3
67486: ARRAY
67487: PPUSH
67488: LD_EXP 63
67492: PUSH
67493: LD_VAR 0 2
67497: ARRAY
67498: PUSH
67499: LD_INT 1
67501: ARRAY
67502: PUSH
67503: LD_INT 4
67505: ARRAY
67506: PPUSH
67507: CALL 28236 0 5
67511: AND
67512: OR
67513: IFFALSE 67794
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67515: LD_ADDR_VAR 0 4
67519: PUSH
67520: LD_EXP 58
67524: PUSH
67525: LD_VAR 0 2
67529: ARRAY
67530: PPUSH
67531: LD_INT 25
67533: PUSH
67534: LD_INT 2
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: PPUSH
67541: CALL_OW 72
67545: PUSH
67546: LD_EXP 60
67550: PUSH
67551: LD_VAR 0 2
67555: ARRAY
67556: DIFF
67557: ST_TO_ADDR
// if not tmp then
67558: LD_VAR 0 4
67562: NOT
67563: IFFALSE 67567
// continue ;
67565: GO 66812
// for j in tmp do
67567: LD_ADDR_VAR 0 3
67571: PUSH
67572: LD_VAR 0 4
67576: PUSH
67577: FOR_IN
67578: IFFALSE 67790
// begin if not mc_builders [ i ] then
67580: LD_EXP 64
67584: PUSH
67585: LD_VAR 0 2
67589: ARRAY
67590: NOT
67591: IFFALSE 67649
// begin SetTag ( j , 103 ) ;
67593: LD_VAR 0 3
67597: PPUSH
67598: LD_INT 103
67600: PPUSH
67601: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67605: LD_ADDR_EXP 64
67609: PUSH
67610: LD_EXP 64
67614: PPUSH
67615: LD_VAR 0 2
67619: PUSH
67620: LD_EXP 64
67624: PUSH
67625: LD_VAR 0 2
67629: ARRAY
67630: PUSH
67631: LD_INT 1
67633: PLUS
67634: PUSH
67635: EMPTY
67636: LIST
67637: LIST
67638: PPUSH
67639: LD_VAR 0 3
67643: PPUSH
67644: CALL 20821 0 3
67648: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67649: LD_VAR 0 3
67653: PPUSH
67654: CALL_OW 310
67658: IFFALSE 67669
// ComExitBuilding ( j ) ;
67660: LD_VAR 0 3
67664: PPUSH
67665: CALL_OW 122
// wait ( 3 ) ;
67669: LD_INT 3
67671: PPUSH
67672: CALL_OW 67
// if not mc_build_list [ i ] then
67676: LD_EXP 63
67680: PUSH
67681: LD_VAR 0 2
67685: ARRAY
67686: NOT
67687: IFFALSE 67691
// break ;
67689: GO 67790
// if not HasTask ( j ) then
67691: LD_VAR 0 3
67695: PPUSH
67696: CALL_OW 314
67700: NOT
67701: IFFALSE 67788
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
67703: LD_VAR 0 3
67707: PPUSH
67708: LD_EXP 63
67712: PUSH
67713: LD_VAR 0 2
67717: ARRAY
67718: PUSH
67719: LD_INT 1
67721: ARRAY
67722: PUSH
67723: LD_INT 1
67725: ARRAY
67726: PPUSH
67727: LD_EXP 63
67731: PUSH
67732: LD_VAR 0 2
67736: ARRAY
67737: PUSH
67738: LD_INT 1
67740: ARRAY
67741: PUSH
67742: LD_INT 2
67744: ARRAY
67745: PPUSH
67746: LD_EXP 63
67750: PUSH
67751: LD_VAR 0 2
67755: ARRAY
67756: PUSH
67757: LD_INT 1
67759: ARRAY
67760: PUSH
67761: LD_INT 3
67763: ARRAY
67764: PPUSH
67765: LD_EXP 63
67769: PUSH
67770: LD_VAR 0 2
67774: ARRAY
67775: PUSH
67776: LD_INT 1
67778: ARRAY
67779: PUSH
67780: LD_INT 4
67782: ARRAY
67783: PPUSH
67784: CALL_OW 145
// end ;
67788: GO 67577
67790: POP
67791: POP
// end else
67792: GO 67936
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
67794: LD_EXP 58
67798: PUSH
67799: LD_VAR 0 2
67803: ARRAY
67804: PPUSH
67805: LD_EXP 63
67809: PUSH
67810: LD_VAR 0 2
67814: ARRAY
67815: PUSH
67816: LD_INT 1
67818: ARRAY
67819: PUSH
67820: LD_INT 1
67822: ARRAY
67823: PPUSH
67824: LD_EXP 63
67828: PUSH
67829: LD_VAR 0 2
67833: ARRAY
67834: PUSH
67835: LD_INT 1
67837: ARRAY
67838: PUSH
67839: LD_INT 2
67841: ARRAY
67842: PPUSH
67843: LD_EXP 63
67847: PUSH
67848: LD_VAR 0 2
67852: ARRAY
67853: PUSH
67854: LD_INT 1
67856: ARRAY
67857: PUSH
67858: LD_INT 3
67860: ARRAY
67861: PPUSH
67862: LD_EXP 63
67866: PUSH
67867: LD_VAR 0 2
67871: ARRAY
67872: PUSH
67873: LD_INT 1
67875: ARRAY
67876: PUSH
67877: LD_INT 4
67879: ARRAY
67880: PPUSH
67881: CALL 27572 0 5
67885: NOT
67886: IFFALSE 67936
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
67888: LD_ADDR_EXP 63
67892: PUSH
67893: LD_EXP 63
67897: PPUSH
67898: LD_VAR 0 2
67902: PPUSH
67903: LD_EXP 63
67907: PUSH
67908: LD_VAR 0 2
67912: ARRAY
67913: PPUSH
67914: LD_INT 1
67916: PPUSH
67917: LD_INT 1
67919: NEG
67920: PPUSH
67921: LD_INT 0
67923: PPUSH
67924: CALL 20239 0 4
67928: PPUSH
67929: CALL_OW 1
67933: ST_TO_ADDR
// continue ;
67934: GO 66812
// end ; end ; end ;
67936: GO 66812
67938: POP
67939: POP
// end ;
67940: LD_VAR 0 1
67944: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
67945: LD_INT 0
67947: PPUSH
67948: PPUSH
67949: PPUSH
67950: PPUSH
67951: PPUSH
67952: PPUSH
// if not mc_bases then
67953: LD_EXP 58
67957: NOT
67958: IFFALSE 67962
// exit ;
67960: GO 68389
// for i = 1 to mc_bases do
67962: LD_ADDR_VAR 0 2
67966: PUSH
67967: DOUBLE
67968: LD_INT 1
67970: DEC
67971: ST_TO_ADDR
67972: LD_EXP 58
67976: PUSH
67977: FOR_TO
67978: IFFALSE 68387
// begin tmp := mc_build_upgrade [ i ] ;
67980: LD_ADDR_VAR 0 4
67984: PUSH
67985: LD_EXP 90
67989: PUSH
67990: LD_VAR 0 2
67994: ARRAY
67995: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
67996: LD_ADDR_VAR 0 6
68000: PUSH
68001: LD_EXP 91
68005: PUSH
68006: LD_VAR 0 2
68010: ARRAY
68011: PPUSH
68012: LD_INT 2
68014: PUSH
68015: LD_INT 30
68017: PUSH
68018: LD_INT 6
68020: PUSH
68021: EMPTY
68022: LIST
68023: LIST
68024: PUSH
68025: LD_INT 30
68027: PUSH
68028: LD_INT 7
68030: PUSH
68031: EMPTY
68032: LIST
68033: LIST
68034: PUSH
68035: EMPTY
68036: LIST
68037: LIST
68038: LIST
68039: PPUSH
68040: CALL_OW 72
68044: ST_TO_ADDR
// if not tmp and not lab then
68045: LD_VAR 0 4
68049: NOT
68050: PUSH
68051: LD_VAR 0 6
68055: NOT
68056: AND
68057: IFFALSE 68061
// continue ;
68059: GO 67977
// if tmp then
68061: LD_VAR 0 4
68065: IFFALSE 68185
// for j in tmp do
68067: LD_ADDR_VAR 0 3
68071: PUSH
68072: LD_VAR 0 4
68076: PUSH
68077: FOR_IN
68078: IFFALSE 68183
// begin if UpgradeCost ( j ) then
68080: LD_VAR 0 3
68084: PPUSH
68085: CALL 27232 0 1
68089: IFFALSE 68181
// begin ComUpgrade ( j ) ;
68091: LD_VAR 0 3
68095: PPUSH
68096: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
68100: LD_ADDR_EXP 90
68104: PUSH
68105: LD_EXP 90
68109: PPUSH
68110: LD_VAR 0 2
68114: PPUSH
68115: LD_EXP 90
68119: PUSH
68120: LD_VAR 0 2
68124: ARRAY
68125: PUSH
68126: LD_VAR 0 3
68130: DIFF
68131: PPUSH
68132: CALL_OW 1
68136: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68137: LD_ADDR_EXP 65
68141: PUSH
68142: LD_EXP 65
68146: PPUSH
68147: LD_VAR 0 2
68151: PUSH
68152: LD_EXP 65
68156: PUSH
68157: LD_VAR 0 2
68161: ARRAY
68162: PUSH
68163: LD_INT 1
68165: PLUS
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: PPUSH
68171: LD_VAR 0 3
68175: PPUSH
68176: CALL 20821 0 3
68180: ST_TO_ADDR
// end ; end ;
68181: GO 68077
68183: POP
68184: POP
// if not lab or not mc_lab_upgrade [ i ] then
68185: LD_VAR 0 6
68189: NOT
68190: PUSH
68191: LD_EXP 92
68195: PUSH
68196: LD_VAR 0 2
68200: ARRAY
68201: NOT
68202: OR
68203: IFFALSE 68207
// continue ;
68205: GO 67977
// for j in lab do
68207: LD_ADDR_VAR 0 3
68211: PUSH
68212: LD_VAR 0 6
68216: PUSH
68217: FOR_IN
68218: IFFALSE 68383
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
68220: LD_VAR 0 3
68224: PPUSH
68225: CALL_OW 266
68229: PUSH
68230: LD_INT 6
68232: PUSH
68233: LD_INT 7
68235: PUSH
68236: EMPTY
68237: LIST
68238: LIST
68239: IN
68240: PUSH
68241: LD_VAR 0 3
68245: PPUSH
68246: CALL_OW 461
68250: PUSH
68251: LD_INT 1
68253: NONEQUAL
68254: AND
68255: IFFALSE 68381
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
68257: LD_VAR 0 3
68261: PPUSH
68262: LD_EXP 92
68266: PUSH
68267: LD_VAR 0 2
68271: ARRAY
68272: PUSH
68273: LD_INT 1
68275: ARRAY
68276: PPUSH
68277: CALL 27437 0 2
68281: IFFALSE 68381
// begin ComCancel ( j ) ;
68283: LD_VAR 0 3
68287: PPUSH
68288: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
68292: LD_VAR 0 3
68296: PPUSH
68297: LD_EXP 92
68301: PUSH
68302: LD_VAR 0 2
68306: ARRAY
68307: PUSH
68308: LD_INT 1
68310: ARRAY
68311: PPUSH
68312: CALL_OW 207
// if not j in mc_construct_list [ i ] then
68316: LD_VAR 0 3
68320: PUSH
68321: LD_EXP 65
68325: PUSH
68326: LD_VAR 0 2
68330: ARRAY
68331: IN
68332: NOT
68333: IFFALSE 68379
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68335: LD_ADDR_EXP 65
68339: PUSH
68340: LD_EXP 65
68344: PPUSH
68345: LD_VAR 0 2
68349: PUSH
68350: LD_EXP 65
68354: PUSH
68355: LD_VAR 0 2
68359: ARRAY
68360: PUSH
68361: LD_INT 1
68363: PLUS
68364: PUSH
68365: EMPTY
68366: LIST
68367: LIST
68368: PPUSH
68369: LD_VAR 0 3
68373: PPUSH
68374: CALL 20821 0 3
68378: ST_TO_ADDR
// break ;
68379: GO 68383
// end ; end ; end ;
68381: GO 68217
68383: POP
68384: POP
// end ;
68385: GO 67977
68387: POP
68388: POP
// end ;
68389: LD_VAR 0 1
68393: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
68394: LD_INT 0
68396: PPUSH
68397: PPUSH
68398: PPUSH
68399: PPUSH
68400: PPUSH
68401: PPUSH
68402: PPUSH
68403: PPUSH
68404: PPUSH
// if not mc_bases then
68405: LD_EXP 58
68409: NOT
68410: IFFALSE 68414
// exit ;
68412: GO 68819
// for i = 1 to mc_bases do
68414: LD_ADDR_VAR 0 2
68418: PUSH
68419: DOUBLE
68420: LD_INT 1
68422: DEC
68423: ST_TO_ADDR
68424: LD_EXP 58
68428: PUSH
68429: FOR_TO
68430: IFFALSE 68817
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
68432: LD_EXP 66
68436: PUSH
68437: LD_VAR 0 2
68441: ARRAY
68442: NOT
68443: PUSH
68444: LD_EXP 58
68448: PUSH
68449: LD_VAR 0 2
68453: ARRAY
68454: PPUSH
68455: LD_INT 30
68457: PUSH
68458: LD_INT 3
68460: PUSH
68461: EMPTY
68462: LIST
68463: LIST
68464: PPUSH
68465: CALL_OW 72
68469: NOT
68470: OR
68471: IFFALSE 68475
// continue ;
68473: GO 68429
// busy := false ;
68475: LD_ADDR_VAR 0 8
68479: PUSH
68480: LD_INT 0
68482: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68483: LD_ADDR_VAR 0 4
68487: PUSH
68488: LD_EXP 58
68492: PUSH
68493: LD_VAR 0 2
68497: ARRAY
68498: PPUSH
68499: LD_INT 30
68501: PUSH
68502: LD_INT 3
68504: PUSH
68505: EMPTY
68506: LIST
68507: LIST
68508: PPUSH
68509: CALL_OW 72
68513: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
68514: LD_ADDR_VAR 0 6
68518: PUSH
68519: LD_EXP 66
68523: PUSH
68524: LD_VAR 0 2
68528: ARRAY
68529: PPUSH
68530: LD_INT 2
68532: PUSH
68533: LD_INT 30
68535: PUSH
68536: LD_INT 32
68538: PUSH
68539: EMPTY
68540: LIST
68541: LIST
68542: PUSH
68543: LD_INT 30
68545: PUSH
68546: LD_INT 33
68548: PUSH
68549: EMPTY
68550: LIST
68551: LIST
68552: PUSH
68553: EMPTY
68554: LIST
68555: LIST
68556: LIST
68557: PPUSH
68558: CALL_OW 72
68562: ST_TO_ADDR
// if not t then
68563: LD_VAR 0 6
68567: NOT
68568: IFFALSE 68572
// continue ;
68570: GO 68429
// for j in tmp do
68572: LD_ADDR_VAR 0 3
68576: PUSH
68577: LD_VAR 0 4
68581: PUSH
68582: FOR_IN
68583: IFFALSE 68613
// if not BuildingStatus ( j ) = bs_idle then
68585: LD_VAR 0 3
68589: PPUSH
68590: CALL_OW 461
68594: PUSH
68595: LD_INT 2
68597: EQUAL
68598: NOT
68599: IFFALSE 68611
// begin busy := true ;
68601: LD_ADDR_VAR 0 8
68605: PUSH
68606: LD_INT 1
68608: ST_TO_ADDR
// break ;
68609: GO 68613
// end ;
68611: GO 68582
68613: POP
68614: POP
// if busy then
68615: LD_VAR 0 8
68619: IFFALSE 68623
// continue ;
68621: GO 68429
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
68623: LD_ADDR_VAR 0 7
68627: PUSH
68628: LD_VAR 0 6
68632: PPUSH
68633: LD_INT 35
68635: PUSH
68636: LD_INT 0
68638: PUSH
68639: EMPTY
68640: LIST
68641: LIST
68642: PPUSH
68643: CALL_OW 72
68647: ST_TO_ADDR
// if tw then
68648: LD_VAR 0 7
68652: IFFALSE 68729
// begin tw := tw [ 1 ] ;
68654: LD_ADDR_VAR 0 7
68658: PUSH
68659: LD_VAR 0 7
68663: PUSH
68664: LD_INT 1
68666: ARRAY
68667: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
68668: LD_ADDR_VAR 0 9
68672: PUSH
68673: LD_VAR 0 7
68677: PPUSH
68678: LD_EXP 83
68682: PUSH
68683: LD_VAR 0 2
68687: ARRAY
68688: PPUSH
68689: CALL 25791 0 2
68693: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
68694: LD_EXP 97
68698: PUSH
68699: LD_VAR 0 2
68703: ARRAY
68704: IFFALSE 68727
// if not weapon in mc_allowed_tower_weapons [ i ] then
68706: LD_VAR 0 9
68710: PUSH
68711: LD_EXP 97
68715: PUSH
68716: LD_VAR 0 2
68720: ARRAY
68721: IN
68722: NOT
68723: IFFALSE 68727
// continue ;
68725: GO 68429
// end else
68727: GO 68792
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
68729: LD_ADDR_VAR 0 5
68733: PUSH
68734: LD_EXP 66
68738: PUSH
68739: LD_VAR 0 2
68743: ARRAY
68744: PPUSH
68745: LD_VAR 0 4
68749: PPUSH
68750: CALL 55992 0 2
68754: ST_TO_ADDR
// if not tmp2 then
68755: LD_VAR 0 5
68759: NOT
68760: IFFALSE 68764
// continue ;
68762: GO 68429
// tw := tmp2 [ 1 ] ;
68764: LD_ADDR_VAR 0 7
68768: PUSH
68769: LD_VAR 0 5
68773: PUSH
68774: LD_INT 1
68776: ARRAY
68777: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
68778: LD_ADDR_VAR 0 9
68782: PUSH
68783: LD_VAR 0 5
68787: PUSH
68788: LD_INT 2
68790: ARRAY
68791: ST_TO_ADDR
// end ; if not weapon then
68792: LD_VAR 0 9
68796: NOT
68797: IFFALSE 68801
// continue ;
68799: GO 68429
// ComPlaceWeapon ( tw , weapon ) ;
68801: LD_VAR 0 7
68805: PPUSH
68806: LD_VAR 0 9
68810: PPUSH
68811: CALL_OW 148
// end ;
68815: GO 68429
68817: POP
68818: POP
// end ;
68819: LD_VAR 0 1
68823: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
68824: LD_INT 0
68826: PPUSH
68827: PPUSH
68828: PPUSH
68829: PPUSH
68830: PPUSH
68831: PPUSH
// if not mc_bases then
68832: LD_EXP 58
68836: NOT
68837: IFFALSE 68841
// exit ;
68839: GO 69853
// for i = 1 to mc_bases do
68841: LD_ADDR_VAR 0 2
68845: PUSH
68846: DOUBLE
68847: LD_INT 1
68849: DEC
68850: ST_TO_ADDR
68851: LD_EXP 58
68855: PUSH
68856: FOR_TO
68857: IFFALSE 69851
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
68859: LD_EXP 71
68863: PUSH
68864: LD_VAR 0 2
68868: ARRAY
68869: NOT
68870: PUSH
68871: LD_EXP 71
68875: PUSH
68876: LD_VAR 0 2
68880: ARRAY
68881: PUSH
68882: LD_EXP 72
68886: PUSH
68887: LD_VAR 0 2
68891: ARRAY
68892: EQUAL
68893: OR
68894: IFFALSE 68898
// continue ;
68896: GO 68856
// if mc_miners [ i ] then
68898: LD_EXP 72
68902: PUSH
68903: LD_VAR 0 2
68907: ARRAY
68908: IFFALSE 69538
// begin k := 1 ;
68910: LD_ADDR_VAR 0 4
68914: PUSH
68915: LD_INT 1
68917: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
68918: LD_ADDR_VAR 0 3
68922: PUSH
68923: DOUBLE
68924: LD_EXP 72
68928: PUSH
68929: LD_VAR 0 2
68933: ARRAY
68934: INC
68935: ST_TO_ADDR
68936: LD_INT 1
68938: PUSH
68939: FOR_DOWNTO
68940: IFFALSE 69536
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
68942: LD_EXP 72
68946: PUSH
68947: LD_VAR 0 2
68951: ARRAY
68952: PUSH
68953: LD_VAR 0 3
68957: ARRAY
68958: PPUSH
68959: CALL_OW 301
68963: PUSH
68964: LD_EXP 72
68968: PUSH
68969: LD_VAR 0 2
68973: ARRAY
68974: PUSH
68975: LD_VAR 0 3
68979: ARRAY
68980: PPUSH
68981: CALL_OW 257
68985: PUSH
68986: LD_INT 1
68988: NONEQUAL
68989: OR
68990: IFFALSE 69053
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
68992: LD_ADDR_VAR 0 5
68996: PUSH
68997: LD_EXP 72
69001: PUSH
69002: LD_VAR 0 2
69006: ARRAY
69007: PUSH
69008: LD_EXP 72
69012: PUSH
69013: LD_VAR 0 2
69017: ARRAY
69018: PUSH
69019: LD_VAR 0 3
69023: ARRAY
69024: DIFF
69025: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
69026: LD_ADDR_EXP 72
69030: PUSH
69031: LD_EXP 72
69035: PPUSH
69036: LD_VAR 0 2
69040: PPUSH
69041: LD_VAR 0 5
69045: PPUSH
69046: CALL_OW 1
69050: ST_TO_ADDR
// continue ;
69051: GO 68939
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
69053: LD_EXP 72
69057: PUSH
69058: LD_VAR 0 2
69062: ARRAY
69063: PUSH
69064: LD_VAR 0 3
69068: ARRAY
69069: PPUSH
69070: CALL 20757 0 1
69074: PUSH
69075: LD_EXP 72
69079: PUSH
69080: LD_VAR 0 2
69084: ARRAY
69085: PUSH
69086: LD_VAR 0 3
69090: ARRAY
69091: PPUSH
69092: CALL_OW 255
69096: PPUSH
69097: LD_EXP 71
69101: PUSH
69102: LD_VAR 0 2
69106: ARRAY
69107: PUSH
69108: LD_VAR 0 4
69112: ARRAY
69113: PUSH
69114: LD_INT 1
69116: ARRAY
69117: PPUSH
69118: LD_EXP 71
69122: PUSH
69123: LD_VAR 0 2
69127: ARRAY
69128: PUSH
69129: LD_VAR 0 4
69133: ARRAY
69134: PUSH
69135: LD_INT 2
69137: ARRAY
69138: PPUSH
69139: LD_INT 15
69141: PPUSH
69142: CALL 21717 0 4
69146: PUSH
69147: LD_INT 4
69149: ARRAY
69150: PUSH
69151: LD_EXP 72
69155: PUSH
69156: LD_VAR 0 2
69160: ARRAY
69161: PUSH
69162: LD_VAR 0 3
69166: ARRAY
69167: PPUSH
69168: LD_INT 10
69170: PPUSH
69171: CALL 23414 0 2
69175: PUSH
69176: LD_INT 4
69178: ARRAY
69179: OR
69180: AND
69181: IFFALSE 69204
// ComStop ( mc_miners [ i ] [ j ] ) ;
69183: LD_EXP 72
69187: PUSH
69188: LD_VAR 0 2
69192: ARRAY
69193: PUSH
69194: LD_VAR 0 3
69198: ARRAY
69199: PPUSH
69200: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
69204: LD_EXP 72
69208: PUSH
69209: LD_VAR 0 2
69213: ARRAY
69214: PUSH
69215: LD_VAR 0 3
69219: ARRAY
69220: PPUSH
69221: CALL_OW 257
69225: PUSH
69226: LD_INT 1
69228: EQUAL
69229: PUSH
69230: LD_EXP 72
69234: PUSH
69235: LD_VAR 0 2
69239: ARRAY
69240: PUSH
69241: LD_VAR 0 3
69245: ARRAY
69246: PPUSH
69247: CALL_OW 459
69251: NOT
69252: AND
69253: PUSH
69254: LD_EXP 72
69258: PUSH
69259: LD_VAR 0 2
69263: ARRAY
69264: PUSH
69265: LD_VAR 0 3
69269: ARRAY
69270: PPUSH
69271: CALL_OW 255
69275: PPUSH
69276: LD_EXP 71
69280: PUSH
69281: LD_VAR 0 2
69285: ARRAY
69286: PUSH
69287: LD_VAR 0 4
69291: ARRAY
69292: PUSH
69293: LD_INT 1
69295: ARRAY
69296: PPUSH
69297: LD_EXP 71
69301: PUSH
69302: LD_VAR 0 2
69306: ARRAY
69307: PUSH
69308: LD_VAR 0 4
69312: ARRAY
69313: PUSH
69314: LD_INT 2
69316: ARRAY
69317: PPUSH
69318: LD_INT 15
69320: PPUSH
69321: CALL 21717 0 4
69325: PUSH
69326: LD_INT 4
69328: ARRAY
69329: PUSH
69330: LD_INT 0
69332: EQUAL
69333: AND
69334: PUSH
69335: LD_EXP 72
69339: PUSH
69340: LD_VAR 0 2
69344: ARRAY
69345: PUSH
69346: LD_VAR 0 3
69350: ARRAY
69351: PPUSH
69352: CALL_OW 314
69356: NOT
69357: AND
69358: IFFALSE 69534
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
69360: LD_EXP 72
69364: PUSH
69365: LD_VAR 0 2
69369: ARRAY
69370: PUSH
69371: LD_VAR 0 3
69375: ARRAY
69376: PPUSH
69377: CALL_OW 310
69381: IFFALSE 69404
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
69383: LD_EXP 72
69387: PUSH
69388: LD_VAR 0 2
69392: ARRAY
69393: PUSH
69394: LD_VAR 0 3
69398: ARRAY
69399: PPUSH
69400: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
69404: LD_EXP 72
69408: PUSH
69409: LD_VAR 0 2
69413: ARRAY
69414: PUSH
69415: LD_VAR 0 3
69419: ARRAY
69420: PPUSH
69421: CALL_OW 314
69425: NOT
69426: IFFALSE 69494
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
69428: LD_EXP 72
69432: PUSH
69433: LD_VAR 0 2
69437: ARRAY
69438: PUSH
69439: LD_VAR 0 3
69443: ARRAY
69444: PPUSH
69445: LD_EXP 71
69449: PUSH
69450: LD_VAR 0 2
69454: ARRAY
69455: PUSH
69456: LD_VAR 0 4
69460: ARRAY
69461: PUSH
69462: LD_INT 1
69464: ARRAY
69465: PPUSH
69466: LD_EXP 71
69470: PUSH
69471: LD_VAR 0 2
69475: ARRAY
69476: PUSH
69477: LD_VAR 0 4
69481: ARRAY
69482: PUSH
69483: LD_INT 2
69485: ARRAY
69486: PPUSH
69487: LD_INT 0
69489: PPUSH
69490: CALL_OW 193
// k := k + 1 ;
69494: LD_ADDR_VAR 0 4
69498: PUSH
69499: LD_VAR 0 4
69503: PUSH
69504: LD_INT 1
69506: PLUS
69507: ST_TO_ADDR
// if k > mc_mines [ i ] then
69508: LD_VAR 0 4
69512: PUSH
69513: LD_EXP 71
69517: PUSH
69518: LD_VAR 0 2
69522: ARRAY
69523: GREATER
69524: IFFALSE 69534
// k := 1 ;
69526: LD_ADDR_VAR 0 4
69530: PUSH
69531: LD_INT 1
69533: ST_TO_ADDR
// end ; end ;
69534: GO 68939
69536: POP
69537: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
69538: LD_ADDR_VAR 0 5
69542: PUSH
69543: LD_EXP 58
69547: PUSH
69548: LD_VAR 0 2
69552: ARRAY
69553: PPUSH
69554: LD_INT 2
69556: PUSH
69557: LD_INT 30
69559: PUSH
69560: LD_INT 4
69562: PUSH
69563: EMPTY
69564: LIST
69565: LIST
69566: PUSH
69567: LD_INT 30
69569: PUSH
69570: LD_INT 5
69572: PUSH
69573: EMPTY
69574: LIST
69575: LIST
69576: PUSH
69577: LD_INT 30
69579: PUSH
69580: LD_INT 32
69582: PUSH
69583: EMPTY
69584: LIST
69585: LIST
69586: PUSH
69587: EMPTY
69588: LIST
69589: LIST
69590: LIST
69591: LIST
69592: PPUSH
69593: CALL_OW 72
69597: ST_TO_ADDR
// if not tmp then
69598: LD_VAR 0 5
69602: NOT
69603: IFFALSE 69607
// continue ;
69605: GO 68856
// list := [ ] ;
69607: LD_ADDR_VAR 0 6
69611: PUSH
69612: EMPTY
69613: ST_TO_ADDR
// for j in tmp do
69614: LD_ADDR_VAR 0 3
69618: PUSH
69619: LD_VAR 0 5
69623: PUSH
69624: FOR_IN
69625: IFFALSE 69694
// begin for k in UnitsInside ( j ) do
69627: LD_ADDR_VAR 0 4
69631: PUSH
69632: LD_VAR 0 3
69636: PPUSH
69637: CALL_OW 313
69641: PUSH
69642: FOR_IN
69643: IFFALSE 69690
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
69645: LD_VAR 0 4
69649: PPUSH
69650: CALL_OW 257
69654: PUSH
69655: LD_INT 1
69657: EQUAL
69658: PUSH
69659: LD_VAR 0 4
69663: PPUSH
69664: CALL_OW 459
69668: NOT
69669: AND
69670: IFFALSE 69688
// list := list ^ k ;
69672: LD_ADDR_VAR 0 6
69676: PUSH
69677: LD_VAR 0 6
69681: PUSH
69682: LD_VAR 0 4
69686: ADD
69687: ST_TO_ADDR
69688: GO 69642
69690: POP
69691: POP
// end ;
69692: GO 69624
69694: POP
69695: POP
// list := list diff mc_miners [ i ] ;
69696: LD_ADDR_VAR 0 6
69700: PUSH
69701: LD_VAR 0 6
69705: PUSH
69706: LD_EXP 72
69710: PUSH
69711: LD_VAR 0 2
69715: ARRAY
69716: DIFF
69717: ST_TO_ADDR
// if not list then
69718: LD_VAR 0 6
69722: NOT
69723: IFFALSE 69727
// continue ;
69725: GO 68856
// k := mc_mines [ i ] - mc_miners [ i ] ;
69727: LD_ADDR_VAR 0 4
69731: PUSH
69732: LD_EXP 71
69736: PUSH
69737: LD_VAR 0 2
69741: ARRAY
69742: PUSH
69743: LD_EXP 72
69747: PUSH
69748: LD_VAR 0 2
69752: ARRAY
69753: MINUS
69754: ST_TO_ADDR
// if k > list then
69755: LD_VAR 0 4
69759: PUSH
69760: LD_VAR 0 6
69764: GREATER
69765: IFFALSE 69777
// k := list ;
69767: LD_ADDR_VAR 0 4
69771: PUSH
69772: LD_VAR 0 6
69776: ST_TO_ADDR
// for j = 1 to k do
69777: LD_ADDR_VAR 0 3
69781: PUSH
69782: DOUBLE
69783: LD_INT 1
69785: DEC
69786: ST_TO_ADDR
69787: LD_VAR 0 4
69791: PUSH
69792: FOR_TO
69793: IFFALSE 69847
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
69795: LD_ADDR_EXP 72
69799: PUSH
69800: LD_EXP 72
69804: PPUSH
69805: LD_VAR 0 2
69809: PUSH
69810: LD_EXP 72
69814: PUSH
69815: LD_VAR 0 2
69819: ARRAY
69820: PUSH
69821: LD_INT 1
69823: PLUS
69824: PUSH
69825: EMPTY
69826: LIST
69827: LIST
69828: PPUSH
69829: LD_VAR 0 6
69833: PUSH
69834: LD_VAR 0 3
69838: ARRAY
69839: PPUSH
69840: CALL 20821 0 3
69844: ST_TO_ADDR
69845: GO 69792
69847: POP
69848: POP
// end ;
69849: GO 68856
69851: POP
69852: POP
// end ;
69853: LD_VAR 0 1
69857: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
69858: LD_INT 0
69860: PPUSH
69861: PPUSH
69862: PPUSH
69863: PPUSH
69864: PPUSH
69865: PPUSH
69866: PPUSH
69867: PPUSH
69868: PPUSH
69869: PPUSH
// if not mc_bases then
69870: LD_EXP 58
69874: NOT
69875: IFFALSE 69879
// exit ;
69877: GO 71629
// for i = 1 to mc_bases do
69879: LD_ADDR_VAR 0 2
69883: PUSH
69884: DOUBLE
69885: LD_INT 1
69887: DEC
69888: ST_TO_ADDR
69889: LD_EXP 58
69893: PUSH
69894: FOR_TO
69895: IFFALSE 71627
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
69897: LD_EXP 58
69901: PUSH
69902: LD_VAR 0 2
69906: ARRAY
69907: NOT
69908: PUSH
69909: LD_EXP 65
69913: PUSH
69914: LD_VAR 0 2
69918: ARRAY
69919: OR
69920: IFFALSE 69924
// continue ;
69922: GO 69894
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
69924: LD_EXP 74
69928: PUSH
69929: LD_VAR 0 2
69933: ARRAY
69934: NOT
69935: PUSH
69936: LD_EXP 75
69940: PUSH
69941: LD_VAR 0 2
69945: ARRAY
69946: AND
69947: IFFALSE 69985
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
69949: LD_ADDR_EXP 75
69953: PUSH
69954: LD_EXP 75
69958: PPUSH
69959: LD_VAR 0 2
69963: PPUSH
69964: EMPTY
69965: PPUSH
69966: CALL_OW 1
69970: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
69971: LD_VAR 0 2
69975: PPUSH
69976: LD_INT 107
69978: PPUSH
69979: CALL 60739 0 2
// continue ;
69983: GO 69894
// end ; target := [ ] ;
69985: LD_ADDR_VAR 0 6
69989: PUSH
69990: EMPTY
69991: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
69992: LD_ADDR_VAR 0 3
69996: PUSH
69997: DOUBLE
69998: LD_EXP 74
70002: PUSH
70003: LD_VAR 0 2
70007: ARRAY
70008: INC
70009: ST_TO_ADDR
70010: LD_INT 1
70012: PUSH
70013: FOR_DOWNTO
70014: IFFALSE 70274
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
70016: LD_EXP 74
70020: PUSH
70021: LD_VAR 0 2
70025: ARRAY
70026: PUSH
70027: LD_VAR 0 3
70031: ARRAY
70032: PUSH
70033: LD_INT 2
70035: ARRAY
70036: PPUSH
70037: LD_EXP 74
70041: PUSH
70042: LD_VAR 0 2
70046: ARRAY
70047: PUSH
70048: LD_VAR 0 3
70052: ARRAY
70053: PUSH
70054: LD_INT 3
70056: ARRAY
70057: PPUSH
70058: CALL_OW 488
70062: PUSH
70063: LD_EXP 74
70067: PUSH
70068: LD_VAR 0 2
70072: ARRAY
70073: PUSH
70074: LD_VAR 0 3
70078: ARRAY
70079: PUSH
70080: LD_INT 2
70082: ARRAY
70083: PPUSH
70084: LD_EXP 74
70088: PUSH
70089: LD_VAR 0 2
70093: ARRAY
70094: PUSH
70095: LD_VAR 0 3
70099: ARRAY
70100: PUSH
70101: LD_INT 3
70103: ARRAY
70104: PPUSH
70105: CALL_OW 284
70109: PUSH
70110: LD_INT 0
70112: EQUAL
70113: AND
70114: IFFALSE 70169
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
70116: LD_ADDR_VAR 0 5
70120: PUSH
70121: LD_EXP 74
70125: PUSH
70126: LD_VAR 0 2
70130: ARRAY
70131: PPUSH
70132: LD_VAR 0 3
70136: PPUSH
70137: CALL_OW 3
70141: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
70142: LD_ADDR_EXP 74
70146: PUSH
70147: LD_EXP 74
70151: PPUSH
70152: LD_VAR 0 2
70156: PPUSH
70157: LD_VAR 0 5
70161: PPUSH
70162: CALL_OW 1
70166: ST_TO_ADDR
// continue ;
70167: GO 70013
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70169: LD_EXP 58
70173: PUSH
70174: LD_VAR 0 2
70178: ARRAY
70179: PUSH
70180: LD_INT 1
70182: ARRAY
70183: PPUSH
70184: CALL_OW 255
70188: PPUSH
70189: LD_EXP 74
70193: PUSH
70194: LD_VAR 0 2
70198: ARRAY
70199: PUSH
70200: LD_VAR 0 3
70204: ARRAY
70205: PUSH
70206: LD_INT 2
70208: ARRAY
70209: PPUSH
70210: LD_EXP 74
70214: PUSH
70215: LD_VAR 0 2
70219: ARRAY
70220: PUSH
70221: LD_VAR 0 3
70225: ARRAY
70226: PUSH
70227: LD_INT 3
70229: ARRAY
70230: PPUSH
70231: LD_INT 30
70233: PPUSH
70234: CALL 21717 0 4
70238: PUSH
70239: LD_INT 4
70241: ARRAY
70242: PUSH
70243: LD_INT 0
70245: EQUAL
70246: IFFALSE 70272
// begin target := mc_crates [ i ] [ j ] ;
70248: LD_ADDR_VAR 0 6
70252: PUSH
70253: LD_EXP 74
70257: PUSH
70258: LD_VAR 0 2
70262: ARRAY
70263: PUSH
70264: LD_VAR 0 3
70268: ARRAY
70269: ST_TO_ADDR
// break ;
70270: GO 70274
// end ; end ;
70272: GO 70013
70274: POP
70275: POP
// if not target then
70276: LD_VAR 0 6
70280: NOT
70281: IFFALSE 70285
// continue ;
70283: GO 69894
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
70285: LD_ADDR_VAR 0 7
70289: PUSH
70290: LD_EXP 77
70294: PUSH
70295: LD_VAR 0 2
70299: ARRAY
70300: PPUSH
70301: LD_INT 2
70303: PUSH
70304: LD_INT 3
70306: PUSH
70307: LD_INT 58
70309: PUSH
70310: EMPTY
70311: LIST
70312: PUSH
70313: EMPTY
70314: LIST
70315: LIST
70316: PUSH
70317: LD_INT 61
70319: PUSH
70320: EMPTY
70321: LIST
70322: PUSH
70323: LD_INT 33
70325: PUSH
70326: LD_INT 5
70328: PUSH
70329: EMPTY
70330: LIST
70331: LIST
70332: PUSH
70333: LD_INT 33
70335: PUSH
70336: LD_INT 3
70338: PUSH
70339: EMPTY
70340: LIST
70341: LIST
70342: PUSH
70343: EMPTY
70344: LIST
70345: LIST
70346: LIST
70347: LIST
70348: LIST
70349: PUSH
70350: LD_INT 2
70352: PUSH
70353: LD_INT 34
70355: PUSH
70356: LD_INT 32
70358: PUSH
70359: EMPTY
70360: LIST
70361: LIST
70362: PUSH
70363: LD_INT 34
70365: PUSH
70366: LD_INT 51
70368: PUSH
70369: EMPTY
70370: LIST
70371: LIST
70372: PUSH
70373: LD_INT 34
70375: PUSH
70376: LD_INT 12
70378: PUSH
70379: EMPTY
70380: LIST
70381: LIST
70382: PUSH
70383: EMPTY
70384: LIST
70385: LIST
70386: LIST
70387: LIST
70388: PUSH
70389: EMPTY
70390: LIST
70391: LIST
70392: PPUSH
70393: CALL_OW 72
70397: ST_TO_ADDR
// if not cargo then
70398: LD_VAR 0 7
70402: NOT
70403: IFFALSE 71046
// begin if mc_crates_collector [ i ] < 5 then
70405: LD_EXP 75
70409: PUSH
70410: LD_VAR 0 2
70414: ARRAY
70415: PUSH
70416: LD_INT 5
70418: LESS
70419: IFFALSE 70785
// begin if mc_ape [ i ] then
70421: LD_EXP 87
70425: PUSH
70426: LD_VAR 0 2
70430: ARRAY
70431: IFFALSE 70478
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
70433: LD_ADDR_VAR 0 5
70437: PUSH
70438: LD_EXP 87
70442: PUSH
70443: LD_VAR 0 2
70447: ARRAY
70448: PPUSH
70449: LD_INT 25
70451: PUSH
70452: LD_INT 16
70454: PUSH
70455: EMPTY
70456: LIST
70457: LIST
70458: PUSH
70459: LD_INT 24
70461: PUSH
70462: LD_INT 750
70464: PUSH
70465: EMPTY
70466: LIST
70467: LIST
70468: PUSH
70469: EMPTY
70470: LIST
70471: LIST
70472: PPUSH
70473: CALL_OW 72
70477: ST_TO_ADDR
// if not tmp then
70478: LD_VAR 0 5
70482: NOT
70483: IFFALSE 70530
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
70485: LD_ADDR_VAR 0 5
70489: PUSH
70490: LD_EXP 58
70494: PUSH
70495: LD_VAR 0 2
70499: ARRAY
70500: PPUSH
70501: LD_INT 25
70503: PUSH
70504: LD_INT 2
70506: PUSH
70507: EMPTY
70508: LIST
70509: LIST
70510: PUSH
70511: LD_INT 24
70513: PUSH
70514: LD_INT 750
70516: PUSH
70517: EMPTY
70518: LIST
70519: LIST
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: PPUSH
70525: CALL_OW 72
70529: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
70530: LD_EXP 87
70534: PUSH
70535: LD_VAR 0 2
70539: ARRAY
70540: PUSH
70541: LD_EXP 58
70545: PUSH
70546: LD_VAR 0 2
70550: ARRAY
70551: PPUSH
70552: LD_INT 25
70554: PUSH
70555: LD_INT 2
70557: PUSH
70558: EMPTY
70559: LIST
70560: LIST
70561: PUSH
70562: LD_INT 24
70564: PUSH
70565: LD_INT 750
70567: PUSH
70568: EMPTY
70569: LIST
70570: LIST
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: PPUSH
70576: CALL_OW 72
70580: AND
70581: PUSH
70582: LD_VAR 0 5
70586: PUSH
70587: LD_INT 5
70589: LESS
70590: AND
70591: IFFALSE 70673
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
70593: LD_ADDR_VAR 0 3
70597: PUSH
70598: LD_EXP 58
70602: PUSH
70603: LD_VAR 0 2
70607: ARRAY
70608: PPUSH
70609: LD_INT 25
70611: PUSH
70612: LD_INT 2
70614: PUSH
70615: EMPTY
70616: LIST
70617: LIST
70618: PUSH
70619: LD_INT 24
70621: PUSH
70622: LD_INT 750
70624: PUSH
70625: EMPTY
70626: LIST
70627: LIST
70628: PUSH
70629: EMPTY
70630: LIST
70631: LIST
70632: PPUSH
70633: CALL_OW 72
70637: PUSH
70638: FOR_IN
70639: IFFALSE 70671
// begin tmp := tmp union j ;
70641: LD_ADDR_VAR 0 5
70645: PUSH
70646: LD_VAR 0 5
70650: PUSH
70651: LD_VAR 0 3
70655: UNION
70656: ST_TO_ADDR
// if tmp >= 5 then
70657: LD_VAR 0 5
70661: PUSH
70662: LD_INT 5
70664: GREATEREQUAL
70665: IFFALSE 70669
// break ;
70667: GO 70671
// end ;
70669: GO 70638
70671: POP
70672: POP
// end ; if not tmp then
70673: LD_VAR 0 5
70677: NOT
70678: IFFALSE 70682
// continue ;
70680: GO 69894
// for j in tmp do
70682: LD_ADDR_VAR 0 3
70686: PUSH
70687: LD_VAR 0 5
70691: PUSH
70692: FOR_IN
70693: IFFALSE 70783
// if not GetTag ( j ) then
70695: LD_VAR 0 3
70699: PPUSH
70700: CALL_OW 110
70704: NOT
70705: IFFALSE 70781
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
70707: LD_ADDR_EXP 75
70711: PUSH
70712: LD_EXP 75
70716: PPUSH
70717: LD_VAR 0 2
70721: PUSH
70722: LD_EXP 75
70726: PUSH
70727: LD_VAR 0 2
70731: ARRAY
70732: PUSH
70733: LD_INT 1
70735: PLUS
70736: PUSH
70737: EMPTY
70738: LIST
70739: LIST
70740: PPUSH
70741: LD_VAR 0 3
70745: PPUSH
70746: CALL 20821 0 3
70750: ST_TO_ADDR
// SetTag ( j , 107 ) ;
70751: LD_VAR 0 3
70755: PPUSH
70756: LD_INT 107
70758: PPUSH
70759: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
70763: LD_EXP 75
70767: PUSH
70768: LD_VAR 0 2
70772: ARRAY
70773: PUSH
70774: LD_INT 5
70776: GREATEREQUAL
70777: IFFALSE 70781
// break ;
70779: GO 70783
// end ;
70781: GO 70692
70783: POP
70784: POP
// end ; if mc_crates_collector [ i ] and target then
70785: LD_EXP 75
70789: PUSH
70790: LD_VAR 0 2
70794: ARRAY
70795: PUSH
70796: LD_VAR 0 6
70800: AND
70801: IFFALSE 71044
// begin if mc_crates_collector [ i ] < target [ 1 ] then
70803: LD_EXP 75
70807: PUSH
70808: LD_VAR 0 2
70812: ARRAY
70813: PUSH
70814: LD_VAR 0 6
70818: PUSH
70819: LD_INT 1
70821: ARRAY
70822: LESS
70823: IFFALSE 70843
// tmp := mc_crates_collector [ i ] else
70825: LD_ADDR_VAR 0 5
70829: PUSH
70830: LD_EXP 75
70834: PUSH
70835: LD_VAR 0 2
70839: ARRAY
70840: ST_TO_ADDR
70841: GO 70857
// tmp := target [ 1 ] ;
70843: LD_ADDR_VAR 0 5
70847: PUSH
70848: LD_VAR 0 6
70852: PUSH
70853: LD_INT 1
70855: ARRAY
70856: ST_TO_ADDR
// k := 0 ;
70857: LD_ADDR_VAR 0 4
70861: PUSH
70862: LD_INT 0
70864: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
70865: LD_ADDR_VAR 0 3
70869: PUSH
70870: LD_EXP 75
70874: PUSH
70875: LD_VAR 0 2
70879: ARRAY
70880: PUSH
70881: FOR_IN
70882: IFFALSE 71042
// begin k := k + 1 ;
70884: LD_ADDR_VAR 0 4
70888: PUSH
70889: LD_VAR 0 4
70893: PUSH
70894: LD_INT 1
70896: PLUS
70897: ST_TO_ADDR
// if k > tmp then
70898: LD_VAR 0 4
70902: PUSH
70903: LD_VAR 0 5
70907: GREATER
70908: IFFALSE 70912
// break ;
70910: GO 71042
// if not GetClass ( j ) in [ 2 , 16 ] then
70912: LD_VAR 0 3
70916: PPUSH
70917: CALL_OW 257
70921: PUSH
70922: LD_INT 2
70924: PUSH
70925: LD_INT 16
70927: PUSH
70928: EMPTY
70929: LIST
70930: LIST
70931: IN
70932: NOT
70933: IFFALSE 70986
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
70935: LD_ADDR_EXP 75
70939: PUSH
70940: LD_EXP 75
70944: PPUSH
70945: LD_VAR 0 2
70949: PPUSH
70950: LD_EXP 75
70954: PUSH
70955: LD_VAR 0 2
70959: ARRAY
70960: PUSH
70961: LD_VAR 0 3
70965: DIFF
70966: PPUSH
70967: CALL_OW 1
70971: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70972: LD_VAR 0 3
70976: PPUSH
70977: LD_INT 0
70979: PPUSH
70980: CALL_OW 109
// continue ;
70984: GO 70881
// end ; if IsInUnit ( j ) then
70986: LD_VAR 0 3
70990: PPUSH
70991: CALL_OW 310
70995: IFFALSE 71006
// ComExitBuilding ( j ) ;
70997: LD_VAR 0 3
71001: PPUSH
71002: CALL_OW 122
// wait ( 3 ) ;
71006: LD_INT 3
71008: PPUSH
71009: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71013: LD_VAR 0 3
71017: PPUSH
71018: LD_VAR 0 6
71022: PUSH
71023: LD_INT 2
71025: ARRAY
71026: PPUSH
71027: LD_VAR 0 6
71031: PUSH
71032: LD_INT 3
71034: ARRAY
71035: PPUSH
71036: CALL_OW 117
// end ;
71040: GO 70881
71042: POP
71043: POP
// end ; end else
71044: GO 71625
// begin for j in cargo do
71046: LD_ADDR_VAR 0 3
71050: PUSH
71051: LD_VAR 0 7
71055: PUSH
71056: FOR_IN
71057: IFFALSE 71623
// begin if GetTag ( j ) <> 0 then
71059: LD_VAR 0 3
71063: PPUSH
71064: CALL_OW 110
71068: PUSH
71069: LD_INT 0
71071: NONEQUAL
71072: IFFALSE 71076
// continue ;
71074: GO 71056
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
71076: LD_VAR 0 3
71080: PPUSH
71081: CALL_OW 256
71085: PUSH
71086: LD_INT 1000
71088: LESS
71089: PUSH
71090: LD_VAR 0 3
71094: PPUSH
71095: LD_EXP 82
71099: PUSH
71100: LD_VAR 0 2
71104: ARRAY
71105: PPUSH
71106: CALL_OW 308
71110: NOT
71111: AND
71112: IFFALSE 71134
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71114: LD_VAR 0 3
71118: PPUSH
71119: LD_EXP 82
71123: PUSH
71124: LD_VAR 0 2
71128: ARRAY
71129: PPUSH
71130: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71134: LD_VAR 0 3
71138: PPUSH
71139: CALL_OW 256
71143: PUSH
71144: LD_INT 1000
71146: LESS
71147: PUSH
71148: LD_VAR 0 3
71152: PPUSH
71153: LD_EXP 82
71157: PUSH
71158: LD_VAR 0 2
71162: ARRAY
71163: PPUSH
71164: CALL_OW 308
71168: AND
71169: IFFALSE 71173
// continue ;
71171: GO 71056
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71173: LD_VAR 0 3
71177: PPUSH
71178: CALL_OW 262
71182: PUSH
71183: LD_INT 2
71185: EQUAL
71186: PUSH
71187: LD_VAR 0 3
71191: PPUSH
71192: CALL_OW 261
71196: PUSH
71197: LD_INT 15
71199: LESS
71200: AND
71201: IFFALSE 71205
// continue ;
71203: GO 71056
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71205: LD_VAR 0 3
71209: PPUSH
71210: CALL_OW 262
71214: PUSH
71215: LD_INT 1
71217: EQUAL
71218: PUSH
71219: LD_VAR 0 3
71223: PPUSH
71224: CALL_OW 261
71228: PUSH
71229: LD_INT 10
71231: LESS
71232: AND
71233: IFFALSE 71562
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71235: LD_ADDR_VAR 0 8
71239: PUSH
71240: LD_EXP 58
71244: PUSH
71245: LD_VAR 0 2
71249: ARRAY
71250: PPUSH
71251: LD_INT 2
71253: PUSH
71254: LD_INT 30
71256: PUSH
71257: LD_INT 0
71259: PUSH
71260: EMPTY
71261: LIST
71262: LIST
71263: PUSH
71264: LD_INT 30
71266: PUSH
71267: LD_INT 1
71269: PUSH
71270: EMPTY
71271: LIST
71272: LIST
71273: PUSH
71274: EMPTY
71275: LIST
71276: LIST
71277: LIST
71278: PPUSH
71279: CALL_OW 72
71283: ST_TO_ADDR
// if not depot then
71284: LD_VAR 0 8
71288: NOT
71289: IFFALSE 71293
// continue ;
71291: GO 71056
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
71293: LD_VAR 0 3
71297: PPUSH
71298: LD_VAR 0 8
71302: PPUSH
71303: LD_VAR 0 3
71307: PPUSH
71308: CALL_OW 74
71312: PPUSH
71313: CALL_OW 296
71317: PUSH
71318: LD_INT 6
71320: LESS
71321: IFFALSE 71337
// SetFuel ( j , 100 ) else
71323: LD_VAR 0 3
71327: PPUSH
71328: LD_INT 100
71330: PPUSH
71331: CALL_OW 240
71335: GO 71562
// if GetFuel ( j ) = 0 then
71337: LD_VAR 0 3
71341: PPUSH
71342: CALL_OW 261
71346: PUSH
71347: LD_INT 0
71349: EQUAL
71350: IFFALSE 71562
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
71352: LD_ADDR_EXP 77
71356: PUSH
71357: LD_EXP 77
71361: PPUSH
71362: LD_VAR 0 2
71366: PPUSH
71367: LD_EXP 77
71371: PUSH
71372: LD_VAR 0 2
71376: ARRAY
71377: PUSH
71378: LD_VAR 0 3
71382: DIFF
71383: PPUSH
71384: CALL_OW 1
71388: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
71389: LD_VAR 0 3
71393: PPUSH
71394: CALL_OW 263
71398: PUSH
71399: LD_INT 1
71401: EQUAL
71402: IFFALSE 71418
// ComExitVehicle ( IsInUnit ( j ) ) ;
71404: LD_VAR 0 3
71408: PPUSH
71409: CALL_OW 310
71413: PPUSH
71414: CALL_OW 121
// if GetControl ( j ) = control_remote then
71418: LD_VAR 0 3
71422: PPUSH
71423: CALL_OW 263
71427: PUSH
71428: LD_INT 2
71430: EQUAL
71431: IFFALSE 71442
// ComUnlink ( j ) ;
71433: LD_VAR 0 3
71437: PPUSH
71438: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
71442: LD_ADDR_VAR 0 9
71446: PUSH
71447: LD_VAR 0 2
71451: PPUSH
71452: LD_INT 3
71454: PPUSH
71455: CALL 80699 0 2
71459: ST_TO_ADDR
// if fac then
71460: LD_VAR 0 9
71464: IFFALSE 71560
// begin for k in fac do
71466: LD_ADDR_VAR 0 4
71470: PUSH
71471: LD_VAR 0 9
71475: PUSH
71476: FOR_IN
71477: IFFALSE 71558
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
71479: LD_ADDR_VAR 0 10
71483: PUSH
71484: LD_VAR 0 9
71488: PPUSH
71489: LD_VAR 0 3
71493: PPUSH
71494: CALL_OW 265
71498: PPUSH
71499: LD_VAR 0 3
71503: PPUSH
71504: CALL_OW 262
71508: PPUSH
71509: LD_VAR 0 3
71513: PPUSH
71514: CALL_OW 263
71518: PPUSH
71519: LD_VAR 0 3
71523: PPUSH
71524: CALL_OW 264
71528: PPUSH
71529: CALL 18353 0 5
71533: ST_TO_ADDR
// if components then
71534: LD_VAR 0 10
71538: IFFALSE 71556
// begin MC_InsertProduceList ( i , components ) ;
71540: LD_VAR 0 2
71544: PPUSH
71545: LD_VAR 0 10
71549: PPUSH
71550: CALL 80244 0 2
// break ;
71554: GO 71558
// end ; end ;
71556: GO 71476
71558: POP
71559: POP
// end ; continue ;
71560: GO 71056
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
71562: LD_VAR 0 3
71566: PPUSH
71567: LD_INT 1
71569: PPUSH
71570: CALL_OW 289
71574: PUSH
71575: LD_INT 100
71577: LESS
71578: PUSH
71579: LD_VAR 0 3
71583: PPUSH
71584: CALL_OW 314
71588: NOT
71589: AND
71590: IFFALSE 71619
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71592: LD_VAR 0 3
71596: PPUSH
71597: LD_VAR 0 6
71601: PUSH
71602: LD_INT 2
71604: ARRAY
71605: PPUSH
71606: LD_VAR 0 6
71610: PUSH
71611: LD_INT 3
71613: ARRAY
71614: PPUSH
71615: CALL_OW 117
// break ;
71619: GO 71623
// end ;
71621: GO 71056
71623: POP
71624: POP
// end ; end ;
71625: GO 69894
71627: POP
71628: POP
// end ;
71629: LD_VAR 0 1
71633: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
71634: LD_INT 0
71636: PPUSH
71637: PPUSH
71638: PPUSH
71639: PPUSH
// if not mc_bases then
71640: LD_EXP 58
71644: NOT
71645: IFFALSE 71649
// exit ;
71647: GO 71810
// for i = 1 to mc_bases do
71649: LD_ADDR_VAR 0 2
71653: PUSH
71654: DOUBLE
71655: LD_INT 1
71657: DEC
71658: ST_TO_ADDR
71659: LD_EXP 58
71663: PUSH
71664: FOR_TO
71665: IFFALSE 71808
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
71667: LD_ADDR_VAR 0 4
71671: PUSH
71672: LD_EXP 77
71676: PUSH
71677: LD_VAR 0 2
71681: ARRAY
71682: PUSH
71683: LD_EXP 80
71687: PUSH
71688: LD_VAR 0 2
71692: ARRAY
71693: UNION
71694: PPUSH
71695: LD_INT 33
71697: PUSH
71698: LD_INT 2
71700: PUSH
71701: EMPTY
71702: LIST
71703: LIST
71704: PPUSH
71705: CALL_OW 72
71709: ST_TO_ADDR
// if tmp then
71710: LD_VAR 0 4
71714: IFFALSE 71806
// for j in tmp do
71716: LD_ADDR_VAR 0 3
71720: PUSH
71721: LD_VAR 0 4
71725: PUSH
71726: FOR_IN
71727: IFFALSE 71804
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
71729: LD_VAR 0 3
71733: PPUSH
71734: CALL_OW 312
71738: NOT
71739: PUSH
71740: LD_VAR 0 3
71744: PPUSH
71745: CALL_OW 256
71749: PUSH
71750: LD_INT 250
71752: GREATEREQUAL
71753: AND
71754: IFFALSE 71767
// Connect ( j ) else
71756: LD_VAR 0 3
71760: PPUSH
71761: CALL 23754 0 1
71765: GO 71802
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
71767: LD_VAR 0 3
71771: PPUSH
71772: CALL_OW 256
71776: PUSH
71777: LD_INT 250
71779: LESS
71780: PUSH
71781: LD_VAR 0 3
71785: PPUSH
71786: CALL_OW 312
71790: AND
71791: IFFALSE 71802
// ComUnlink ( j ) ;
71793: LD_VAR 0 3
71797: PPUSH
71798: CALL_OW 136
71802: GO 71726
71804: POP
71805: POP
// end ;
71806: GO 71664
71808: POP
71809: POP
// end ;
71810: LD_VAR 0 1
71814: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
71815: LD_INT 0
71817: PPUSH
71818: PPUSH
71819: PPUSH
71820: PPUSH
71821: PPUSH
// if not mc_bases then
71822: LD_EXP 58
71826: NOT
71827: IFFALSE 71831
// exit ;
71829: GO 72276
// for i = 1 to mc_bases do
71831: LD_ADDR_VAR 0 2
71835: PUSH
71836: DOUBLE
71837: LD_INT 1
71839: DEC
71840: ST_TO_ADDR
71841: LD_EXP 58
71845: PUSH
71846: FOR_TO
71847: IFFALSE 72274
// begin if not mc_produce [ i ] then
71849: LD_EXP 79
71853: PUSH
71854: LD_VAR 0 2
71858: ARRAY
71859: NOT
71860: IFFALSE 71864
// continue ;
71862: GO 71846
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71864: LD_ADDR_VAR 0 5
71868: PUSH
71869: LD_EXP 58
71873: PUSH
71874: LD_VAR 0 2
71878: ARRAY
71879: PPUSH
71880: LD_INT 30
71882: PUSH
71883: LD_INT 3
71885: PUSH
71886: EMPTY
71887: LIST
71888: LIST
71889: PPUSH
71890: CALL_OW 72
71894: ST_TO_ADDR
// if not fac then
71895: LD_VAR 0 5
71899: NOT
71900: IFFALSE 71904
// continue ;
71902: GO 71846
// for j in fac do
71904: LD_ADDR_VAR 0 3
71908: PUSH
71909: LD_VAR 0 5
71913: PUSH
71914: FOR_IN
71915: IFFALSE 72270
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
71917: LD_VAR 0 3
71921: PPUSH
71922: CALL_OW 461
71926: PUSH
71927: LD_INT 2
71929: NONEQUAL
71930: PUSH
71931: LD_VAR 0 3
71935: PPUSH
71936: LD_INT 15
71938: PPUSH
71939: CALL 23414 0 2
71943: PUSH
71944: LD_INT 4
71946: ARRAY
71947: OR
71948: IFFALSE 71952
// continue ;
71950: GO 71914
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
71952: LD_VAR 0 3
71956: PPUSH
71957: LD_EXP 79
71961: PUSH
71962: LD_VAR 0 2
71966: ARRAY
71967: PUSH
71968: LD_INT 1
71970: ARRAY
71971: PUSH
71972: LD_INT 1
71974: ARRAY
71975: PPUSH
71976: LD_EXP 79
71980: PUSH
71981: LD_VAR 0 2
71985: ARRAY
71986: PUSH
71987: LD_INT 1
71989: ARRAY
71990: PUSH
71991: LD_INT 2
71993: ARRAY
71994: PPUSH
71995: LD_EXP 79
71999: PUSH
72000: LD_VAR 0 2
72004: ARRAY
72005: PUSH
72006: LD_INT 1
72008: ARRAY
72009: PUSH
72010: LD_INT 3
72012: ARRAY
72013: PPUSH
72014: LD_EXP 79
72018: PUSH
72019: LD_VAR 0 2
72023: ARRAY
72024: PUSH
72025: LD_INT 1
72027: ARRAY
72028: PUSH
72029: LD_INT 4
72031: ARRAY
72032: PPUSH
72033: CALL_OW 448
72037: PUSH
72038: LD_VAR 0 3
72042: PPUSH
72043: LD_EXP 79
72047: PUSH
72048: LD_VAR 0 2
72052: ARRAY
72053: PUSH
72054: LD_INT 1
72056: ARRAY
72057: PUSH
72058: LD_INT 1
72060: ARRAY
72061: PUSH
72062: LD_EXP 79
72066: PUSH
72067: LD_VAR 0 2
72071: ARRAY
72072: PUSH
72073: LD_INT 1
72075: ARRAY
72076: PUSH
72077: LD_INT 2
72079: ARRAY
72080: PUSH
72081: LD_EXP 79
72085: PUSH
72086: LD_VAR 0 2
72090: ARRAY
72091: PUSH
72092: LD_INT 1
72094: ARRAY
72095: PUSH
72096: LD_INT 3
72098: ARRAY
72099: PUSH
72100: LD_EXP 79
72104: PUSH
72105: LD_VAR 0 2
72109: ARRAY
72110: PUSH
72111: LD_INT 1
72113: ARRAY
72114: PUSH
72115: LD_INT 4
72117: ARRAY
72118: PUSH
72119: EMPTY
72120: LIST
72121: LIST
72122: LIST
72123: LIST
72124: PPUSH
72125: CALL 27085 0 2
72129: AND
72130: IFFALSE 72268
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
72132: LD_VAR 0 3
72136: PPUSH
72137: LD_EXP 79
72141: PUSH
72142: LD_VAR 0 2
72146: ARRAY
72147: PUSH
72148: LD_INT 1
72150: ARRAY
72151: PUSH
72152: LD_INT 1
72154: ARRAY
72155: PPUSH
72156: LD_EXP 79
72160: PUSH
72161: LD_VAR 0 2
72165: ARRAY
72166: PUSH
72167: LD_INT 1
72169: ARRAY
72170: PUSH
72171: LD_INT 2
72173: ARRAY
72174: PPUSH
72175: LD_EXP 79
72179: PUSH
72180: LD_VAR 0 2
72184: ARRAY
72185: PUSH
72186: LD_INT 1
72188: ARRAY
72189: PUSH
72190: LD_INT 3
72192: ARRAY
72193: PPUSH
72194: LD_EXP 79
72198: PUSH
72199: LD_VAR 0 2
72203: ARRAY
72204: PUSH
72205: LD_INT 1
72207: ARRAY
72208: PUSH
72209: LD_INT 4
72211: ARRAY
72212: PPUSH
72213: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
72217: LD_ADDR_VAR 0 4
72221: PUSH
72222: LD_EXP 79
72226: PUSH
72227: LD_VAR 0 2
72231: ARRAY
72232: PPUSH
72233: LD_INT 1
72235: PPUSH
72236: CALL_OW 3
72240: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
72241: LD_ADDR_EXP 79
72245: PUSH
72246: LD_EXP 79
72250: PPUSH
72251: LD_VAR 0 2
72255: PPUSH
72256: LD_VAR 0 4
72260: PPUSH
72261: CALL_OW 1
72265: ST_TO_ADDR
// break ;
72266: GO 72270
// end ; end ;
72268: GO 71914
72270: POP
72271: POP
// end ;
72272: GO 71846
72274: POP
72275: POP
// end ;
72276: LD_VAR 0 1
72280: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
72281: LD_INT 0
72283: PPUSH
72284: PPUSH
72285: PPUSH
// if not mc_bases then
72286: LD_EXP 58
72290: NOT
72291: IFFALSE 72295
// exit ;
72293: GO 72384
// for i = 1 to mc_bases do
72295: LD_ADDR_VAR 0 2
72299: PUSH
72300: DOUBLE
72301: LD_INT 1
72303: DEC
72304: ST_TO_ADDR
72305: LD_EXP 58
72309: PUSH
72310: FOR_TO
72311: IFFALSE 72382
// begin if mc_attack [ i ] then
72313: LD_EXP 78
72317: PUSH
72318: LD_VAR 0 2
72322: ARRAY
72323: IFFALSE 72380
// begin tmp := mc_attack [ i ] [ 1 ] ;
72325: LD_ADDR_VAR 0 3
72329: PUSH
72330: LD_EXP 78
72334: PUSH
72335: LD_VAR 0 2
72339: ARRAY
72340: PUSH
72341: LD_INT 1
72343: ARRAY
72344: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
72345: LD_ADDR_EXP 78
72349: PUSH
72350: LD_EXP 78
72354: PPUSH
72355: LD_VAR 0 2
72359: PPUSH
72360: EMPTY
72361: PPUSH
72362: CALL_OW 1
72366: ST_TO_ADDR
// Attack ( tmp ) ;
72367: LD_VAR 0 3
72371: PPUSH
72372: CALL 49298 0 1
// exit ;
72376: POP
72377: POP
72378: GO 72384
// end ; end ;
72380: GO 72310
72382: POP
72383: POP
// end ;
72384: LD_VAR 0 1
72388: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
72389: LD_INT 0
72391: PPUSH
72392: PPUSH
72393: PPUSH
72394: PPUSH
72395: PPUSH
72396: PPUSH
72397: PPUSH
// if not mc_bases then
72398: LD_EXP 58
72402: NOT
72403: IFFALSE 72407
// exit ;
72405: GO 72989
// for i = 1 to mc_bases do
72407: LD_ADDR_VAR 0 2
72411: PUSH
72412: DOUBLE
72413: LD_INT 1
72415: DEC
72416: ST_TO_ADDR
72417: LD_EXP 58
72421: PUSH
72422: FOR_TO
72423: IFFALSE 72987
// begin if not mc_bases [ i ] then
72425: LD_EXP 58
72429: PUSH
72430: LD_VAR 0 2
72434: ARRAY
72435: NOT
72436: IFFALSE 72440
// continue ;
72438: GO 72422
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
72440: LD_ADDR_VAR 0 7
72444: PUSH
72445: LD_EXP 58
72449: PUSH
72450: LD_VAR 0 2
72454: ARRAY
72455: PUSH
72456: LD_INT 1
72458: ARRAY
72459: PPUSH
72460: CALL 17657 0 1
72464: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
72465: LD_ADDR_EXP 81
72469: PUSH
72470: LD_EXP 81
72474: PPUSH
72475: LD_VAR 0 2
72479: PPUSH
72480: LD_EXP 58
72484: PUSH
72485: LD_VAR 0 2
72489: ARRAY
72490: PUSH
72491: LD_INT 1
72493: ARRAY
72494: PPUSH
72495: CALL_OW 255
72499: PPUSH
72500: LD_EXP 83
72504: PUSH
72505: LD_VAR 0 2
72509: ARRAY
72510: PPUSH
72511: CALL 15575 0 2
72515: PPUSH
72516: CALL_OW 1
72520: ST_TO_ADDR
// if not mc_scan [ i ] then
72521: LD_EXP 81
72525: PUSH
72526: LD_VAR 0 2
72530: ARRAY
72531: NOT
72532: IFFALSE 72687
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72534: LD_ADDR_VAR 0 4
72538: PUSH
72539: LD_EXP 58
72543: PUSH
72544: LD_VAR 0 2
72548: ARRAY
72549: PPUSH
72550: LD_INT 2
72552: PUSH
72553: LD_INT 25
72555: PUSH
72556: LD_INT 5
72558: PUSH
72559: EMPTY
72560: LIST
72561: LIST
72562: PUSH
72563: LD_INT 25
72565: PUSH
72566: LD_INT 8
72568: PUSH
72569: EMPTY
72570: LIST
72571: LIST
72572: PUSH
72573: LD_INT 25
72575: PUSH
72576: LD_INT 9
72578: PUSH
72579: EMPTY
72580: LIST
72581: LIST
72582: PUSH
72583: EMPTY
72584: LIST
72585: LIST
72586: LIST
72587: LIST
72588: PPUSH
72589: CALL_OW 72
72593: ST_TO_ADDR
// if not tmp then
72594: LD_VAR 0 4
72598: NOT
72599: IFFALSE 72603
// continue ;
72601: GO 72422
// for j in tmp do
72603: LD_ADDR_VAR 0 3
72607: PUSH
72608: LD_VAR 0 4
72612: PUSH
72613: FOR_IN
72614: IFFALSE 72685
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
72616: LD_VAR 0 3
72620: PPUSH
72621: CALL_OW 310
72625: PPUSH
72626: CALL_OW 266
72630: PUSH
72631: LD_INT 5
72633: EQUAL
72634: PUSH
72635: LD_VAR 0 3
72639: PPUSH
72640: CALL_OW 257
72644: PUSH
72645: LD_INT 1
72647: EQUAL
72648: AND
72649: PUSH
72650: LD_VAR 0 3
72654: PPUSH
72655: CALL_OW 459
72659: NOT
72660: AND
72661: PUSH
72662: LD_VAR 0 7
72666: AND
72667: IFFALSE 72683
// ComChangeProfession ( j , class ) ;
72669: LD_VAR 0 3
72673: PPUSH
72674: LD_VAR 0 7
72678: PPUSH
72679: CALL_OW 123
72683: GO 72613
72685: POP
72686: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
72687: LD_EXP 81
72691: PUSH
72692: LD_VAR 0 2
72696: ARRAY
72697: PUSH
72698: LD_EXP 80
72702: PUSH
72703: LD_VAR 0 2
72707: ARRAY
72708: NOT
72709: AND
72710: PUSH
72711: LD_EXP 58
72715: PUSH
72716: LD_VAR 0 2
72720: ARRAY
72721: PPUSH
72722: LD_INT 30
72724: PUSH
72725: LD_INT 32
72727: PUSH
72728: EMPTY
72729: LIST
72730: LIST
72731: PPUSH
72732: CALL_OW 72
72736: NOT
72737: AND
72738: PUSH
72739: LD_EXP 58
72743: PUSH
72744: LD_VAR 0 2
72748: ARRAY
72749: PPUSH
72750: LD_INT 2
72752: PUSH
72753: LD_INT 30
72755: PUSH
72756: LD_INT 4
72758: PUSH
72759: EMPTY
72760: LIST
72761: LIST
72762: PUSH
72763: LD_INT 30
72765: PUSH
72766: LD_INT 5
72768: PUSH
72769: EMPTY
72770: LIST
72771: LIST
72772: PUSH
72773: EMPTY
72774: LIST
72775: LIST
72776: LIST
72777: PPUSH
72778: CALL_OW 72
72782: NOT
72783: AND
72784: IFFALSE 72916
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72786: LD_ADDR_VAR 0 4
72790: PUSH
72791: LD_EXP 58
72795: PUSH
72796: LD_VAR 0 2
72800: ARRAY
72801: PPUSH
72802: LD_INT 2
72804: PUSH
72805: LD_INT 25
72807: PUSH
72808: LD_INT 1
72810: PUSH
72811: EMPTY
72812: LIST
72813: LIST
72814: PUSH
72815: LD_INT 25
72817: PUSH
72818: LD_INT 5
72820: PUSH
72821: EMPTY
72822: LIST
72823: LIST
72824: PUSH
72825: LD_INT 25
72827: PUSH
72828: LD_INT 8
72830: PUSH
72831: EMPTY
72832: LIST
72833: LIST
72834: PUSH
72835: LD_INT 25
72837: PUSH
72838: LD_INT 9
72840: PUSH
72841: EMPTY
72842: LIST
72843: LIST
72844: PUSH
72845: EMPTY
72846: LIST
72847: LIST
72848: LIST
72849: LIST
72850: LIST
72851: PPUSH
72852: CALL_OW 72
72856: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
72857: LD_ADDR_VAR 0 4
72861: PUSH
72862: LD_VAR 0 4
72866: PUSH
72867: LD_VAR 0 4
72871: PPUSH
72872: LD_INT 18
72874: PPUSH
72875: CALL 54081 0 2
72879: DIFF
72880: ST_TO_ADDR
// if tmp then
72881: LD_VAR 0 4
72885: IFFALSE 72916
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
72887: LD_VAR 0 2
72891: PPUSH
72892: LD_VAR 0 4
72896: PPUSH
72897: LD_EXP 83
72901: PUSH
72902: LD_VAR 0 2
72906: ARRAY
72907: PPUSH
72908: CALL 15610 0 3
// exit ;
72912: POP
72913: POP
72914: GO 72989
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
72916: LD_EXP 81
72920: PUSH
72921: LD_VAR 0 2
72925: ARRAY
72926: PUSH
72927: LD_EXP 80
72931: PUSH
72932: LD_VAR 0 2
72936: ARRAY
72937: AND
72938: IFFALSE 72985
// begin tmp := mc_defender [ i ] ;
72940: LD_ADDR_VAR 0 4
72944: PUSH
72945: LD_EXP 80
72949: PUSH
72950: LD_VAR 0 2
72954: ARRAY
72955: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
72956: LD_VAR 0 2
72960: PPUSH
72961: LD_VAR 0 4
72965: PPUSH
72966: LD_EXP 81
72970: PUSH
72971: LD_VAR 0 2
72975: ARRAY
72976: PPUSH
72977: CALL 16108 0 3
// exit ;
72981: POP
72982: POP
72983: GO 72989
// end ; end ;
72985: GO 72422
72987: POP
72988: POP
// end ;
72989: LD_VAR 0 1
72993: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
72994: LD_INT 0
72996: PPUSH
72997: PPUSH
72998: PPUSH
72999: PPUSH
73000: PPUSH
73001: PPUSH
73002: PPUSH
73003: PPUSH
73004: PPUSH
73005: PPUSH
73006: PPUSH
// if not mc_bases then
73007: LD_EXP 58
73011: NOT
73012: IFFALSE 73016
// exit ;
73014: GO 74103
// for i = 1 to mc_bases do
73016: LD_ADDR_VAR 0 2
73020: PUSH
73021: DOUBLE
73022: LD_INT 1
73024: DEC
73025: ST_TO_ADDR
73026: LD_EXP 58
73030: PUSH
73031: FOR_TO
73032: IFFALSE 74101
// begin tmp := mc_lab [ i ] ;
73034: LD_ADDR_VAR 0 6
73038: PUSH
73039: LD_EXP 91
73043: PUSH
73044: LD_VAR 0 2
73048: ARRAY
73049: ST_TO_ADDR
// if not tmp then
73050: LD_VAR 0 6
73054: NOT
73055: IFFALSE 73059
// continue ;
73057: GO 73031
// idle_lab := 0 ;
73059: LD_ADDR_VAR 0 11
73063: PUSH
73064: LD_INT 0
73066: ST_TO_ADDR
// for j in tmp do
73067: LD_ADDR_VAR 0 3
73071: PUSH
73072: LD_VAR 0 6
73076: PUSH
73077: FOR_IN
73078: IFFALSE 74097
// begin researching := false ;
73080: LD_ADDR_VAR 0 10
73084: PUSH
73085: LD_INT 0
73087: ST_TO_ADDR
// side := GetSide ( j ) ;
73088: LD_ADDR_VAR 0 4
73092: PUSH
73093: LD_VAR 0 3
73097: PPUSH
73098: CALL_OW 255
73102: ST_TO_ADDR
// if not mc_tech [ side ] then
73103: LD_EXP 85
73107: PUSH
73108: LD_VAR 0 4
73112: ARRAY
73113: NOT
73114: IFFALSE 73118
// continue ;
73116: GO 73077
// if BuildingStatus ( j ) = bs_idle then
73118: LD_VAR 0 3
73122: PPUSH
73123: CALL_OW 461
73127: PUSH
73128: LD_INT 2
73130: EQUAL
73131: IFFALSE 73319
// begin if idle_lab and UnitsInside ( j ) < 6 then
73133: LD_VAR 0 11
73137: PUSH
73138: LD_VAR 0 3
73142: PPUSH
73143: CALL_OW 313
73147: PUSH
73148: LD_INT 6
73150: LESS
73151: AND
73152: IFFALSE 73223
// begin tmp2 := UnitsInside ( idle_lab ) ;
73154: LD_ADDR_VAR 0 9
73158: PUSH
73159: LD_VAR 0 11
73163: PPUSH
73164: CALL_OW 313
73168: ST_TO_ADDR
// if tmp2 then
73169: LD_VAR 0 9
73173: IFFALSE 73215
// for x in tmp2 do
73175: LD_ADDR_VAR 0 7
73179: PUSH
73180: LD_VAR 0 9
73184: PUSH
73185: FOR_IN
73186: IFFALSE 73213
// begin ComExitBuilding ( x ) ;
73188: LD_VAR 0 7
73192: PPUSH
73193: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73197: LD_VAR 0 7
73201: PPUSH
73202: LD_VAR 0 3
73206: PPUSH
73207: CALL_OW 180
// end ;
73211: GO 73185
73213: POP
73214: POP
// idle_lab := 0 ;
73215: LD_ADDR_VAR 0 11
73219: PUSH
73220: LD_INT 0
73222: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
73223: LD_ADDR_VAR 0 5
73227: PUSH
73228: LD_EXP 85
73232: PUSH
73233: LD_VAR 0 4
73237: ARRAY
73238: PUSH
73239: FOR_IN
73240: IFFALSE 73300
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
73242: LD_VAR 0 3
73246: PPUSH
73247: LD_VAR 0 5
73251: PPUSH
73252: CALL_OW 430
73256: PUSH
73257: LD_VAR 0 4
73261: PPUSH
73262: LD_VAR 0 5
73266: PPUSH
73267: CALL 14680 0 2
73271: AND
73272: IFFALSE 73298
// begin researching := true ;
73274: LD_ADDR_VAR 0 10
73278: PUSH
73279: LD_INT 1
73281: ST_TO_ADDR
// ComResearch ( j , t ) ;
73282: LD_VAR 0 3
73286: PPUSH
73287: LD_VAR 0 5
73291: PPUSH
73292: CALL_OW 124
// break ;
73296: GO 73300
// end ;
73298: GO 73239
73300: POP
73301: POP
// if not researching then
73302: LD_VAR 0 10
73306: NOT
73307: IFFALSE 73319
// idle_lab := j ;
73309: LD_ADDR_VAR 0 11
73313: PUSH
73314: LD_VAR 0 3
73318: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
73319: LD_VAR 0 3
73323: PPUSH
73324: CALL_OW 461
73328: PUSH
73329: LD_INT 10
73331: EQUAL
73332: IFFALSE 73920
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
73334: LD_EXP 87
73338: PUSH
73339: LD_VAR 0 2
73343: ARRAY
73344: NOT
73345: PUSH
73346: LD_EXP 88
73350: PUSH
73351: LD_VAR 0 2
73355: ARRAY
73356: NOT
73357: AND
73358: PUSH
73359: LD_EXP 85
73363: PUSH
73364: LD_VAR 0 4
73368: ARRAY
73369: PUSH
73370: LD_INT 1
73372: GREATER
73373: AND
73374: IFFALSE 73505
// begin ComCancel ( j ) ;
73376: LD_VAR 0 3
73380: PPUSH
73381: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
73385: LD_ADDR_EXP 85
73389: PUSH
73390: LD_EXP 85
73394: PPUSH
73395: LD_VAR 0 4
73399: PPUSH
73400: LD_EXP 85
73404: PUSH
73405: LD_VAR 0 4
73409: ARRAY
73410: PPUSH
73411: LD_EXP 85
73415: PUSH
73416: LD_VAR 0 4
73420: ARRAY
73421: PUSH
73422: LD_INT 1
73424: MINUS
73425: PPUSH
73426: LD_EXP 85
73430: PUSH
73431: LD_VAR 0 4
73435: ARRAY
73436: PPUSH
73437: LD_INT 0
73439: PPUSH
73440: CALL 20239 0 4
73444: PPUSH
73445: CALL_OW 1
73449: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
73450: LD_ADDR_EXP 85
73454: PUSH
73455: LD_EXP 85
73459: PPUSH
73460: LD_VAR 0 4
73464: PPUSH
73465: LD_EXP 85
73469: PUSH
73470: LD_VAR 0 4
73474: ARRAY
73475: PPUSH
73476: LD_EXP 85
73480: PUSH
73481: LD_VAR 0 4
73485: ARRAY
73486: PPUSH
73487: LD_INT 1
73489: PPUSH
73490: LD_INT 0
73492: PPUSH
73493: CALL 20239 0 4
73497: PPUSH
73498: CALL_OW 1
73502: ST_TO_ADDR
// continue ;
73503: GO 73077
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
73505: LD_EXP 87
73509: PUSH
73510: LD_VAR 0 2
73514: ARRAY
73515: PUSH
73516: LD_EXP 88
73520: PUSH
73521: LD_VAR 0 2
73525: ARRAY
73526: NOT
73527: AND
73528: IFFALSE 73655
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
73530: LD_ADDR_EXP 88
73534: PUSH
73535: LD_EXP 88
73539: PPUSH
73540: LD_VAR 0 2
73544: PUSH
73545: LD_EXP 88
73549: PUSH
73550: LD_VAR 0 2
73554: ARRAY
73555: PUSH
73556: LD_INT 1
73558: PLUS
73559: PUSH
73560: EMPTY
73561: LIST
73562: LIST
73563: PPUSH
73564: LD_EXP 87
73568: PUSH
73569: LD_VAR 0 2
73573: ARRAY
73574: PUSH
73575: LD_INT 1
73577: ARRAY
73578: PPUSH
73579: CALL 20821 0 3
73583: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
73584: LD_EXP 87
73588: PUSH
73589: LD_VAR 0 2
73593: ARRAY
73594: PUSH
73595: LD_INT 1
73597: ARRAY
73598: PPUSH
73599: LD_INT 112
73601: PPUSH
73602: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
73606: LD_ADDR_VAR 0 9
73610: PUSH
73611: LD_EXP 87
73615: PUSH
73616: LD_VAR 0 2
73620: ARRAY
73621: PPUSH
73622: LD_INT 1
73624: PPUSH
73625: CALL_OW 3
73629: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
73630: LD_ADDR_EXP 87
73634: PUSH
73635: LD_EXP 87
73639: PPUSH
73640: LD_VAR 0 2
73644: PPUSH
73645: LD_VAR 0 9
73649: PPUSH
73650: CALL_OW 1
73654: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
73655: LD_EXP 87
73659: PUSH
73660: LD_VAR 0 2
73664: ARRAY
73665: PUSH
73666: LD_EXP 88
73670: PUSH
73671: LD_VAR 0 2
73675: ARRAY
73676: AND
73677: PUSH
73678: LD_EXP 88
73682: PUSH
73683: LD_VAR 0 2
73687: ARRAY
73688: PUSH
73689: LD_INT 1
73691: ARRAY
73692: PPUSH
73693: CALL_OW 310
73697: NOT
73698: AND
73699: PUSH
73700: LD_VAR 0 3
73704: PPUSH
73705: CALL_OW 313
73709: PUSH
73710: LD_INT 6
73712: EQUAL
73713: AND
73714: IFFALSE 73770
// begin tmp2 := UnitsInside ( j ) ;
73716: LD_ADDR_VAR 0 9
73720: PUSH
73721: LD_VAR 0 3
73725: PPUSH
73726: CALL_OW 313
73730: ST_TO_ADDR
// if tmp2 = 6 then
73731: LD_VAR 0 9
73735: PUSH
73736: LD_INT 6
73738: EQUAL
73739: IFFALSE 73770
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
73741: LD_VAR 0 9
73745: PUSH
73746: LD_INT 1
73748: ARRAY
73749: PPUSH
73750: LD_INT 112
73752: PPUSH
73753: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
73757: LD_VAR 0 9
73761: PUSH
73762: LD_INT 1
73764: ARRAY
73765: PPUSH
73766: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
73770: LD_EXP 88
73774: PUSH
73775: LD_VAR 0 2
73779: ARRAY
73780: PUSH
73781: LD_EXP 88
73785: PUSH
73786: LD_VAR 0 2
73790: ARRAY
73791: PUSH
73792: LD_INT 1
73794: ARRAY
73795: PPUSH
73796: CALL_OW 314
73800: NOT
73801: AND
73802: PUSH
73803: LD_EXP 88
73807: PUSH
73808: LD_VAR 0 2
73812: ARRAY
73813: PUSH
73814: LD_INT 1
73816: ARRAY
73817: PPUSH
73818: CALL_OW 310
73822: NOT
73823: AND
73824: IFFALSE 73850
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
73826: LD_EXP 88
73830: PUSH
73831: LD_VAR 0 2
73835: ARRAY
73836: PUSH
73837: LD_INT 1
73839: ARRAY
73840: PPUSH
73841: LD_VAR 0 3
73845: PPUSH
73846: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
73850: LD_EXP 88
73854: PUSH
73855: LD_VAR 0 2
73859: ARRAY
73860: PUSH
73861: LD_INT 1
73863: ARRAY
73864: PPUSH
73865: CALL_OW 310
73869: PUSH
73870: LD_EXP 88
73874: PUSH
73875: LD_VAR 0 2
73879: ARRAY
73880: PUSH
73881: LD_INT 1
73883: ARRAY
73884: PPUSH
73885: CALL_OW 310
73889: PPUSH
73890: CALL_OW 461
73894: PUSH
73895: LD_INT 3
73897: NONEQUAL
73898: AND
73899: IFFALSE 73920
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
73901: LD_EXP 88
73905: PUSH
73906: LD_VAR 0 2
73910: ARRAY
73911: PUSH
73912: LD_INT 1
73914: ARRAY
73915: PPUSH
73916: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
73920: LD_VAR 0 3
73924: PPUSH
73925: CALL_OW 461
73929: PUSH
73930: LD_INT 6
73932: EQUAL
73933: PUSH
73934: LD_VAR 0 6
73938: PUSH
73939: LD_INT 1
73941: GREATER
73942: AND
73943: IFFALSE 74095
// begin sci := [ ] ;
73945: LD_ADDR_VAR 0 8
73949: PUSH
73950: EMPTY
73951: ST_TO_ADDR
// for x in ( tmp diff j ) do
73952: LD_ADDR_VAR 0 7
73956: PUSH
73957: LD_VAR 0 6
73961: PUSH
73962: LD_VAR 0 3
73966: DIFF
73967: PUSH
73968: FOR_IN
73969: IFFALSE 74021
// begin if sci = 6 then
73971: LD_VAR 0 8
73975: PUSH
73976: LD_INT 6
73978: EQUAL
73979: IFFALSE 73983
// break ;
73981: GO 74021
// if BuildingStatus ( x ) = bs_idle then
73983: LD_VAR 0 7
73987: PPUSH
73988: CALL_OW 461
73992: PUSH
73993: LD_INT 2
73995: EQUAL
73996: IFFALSE 74019
// sci := sci ^ UnitsInside ( x ) ;
73998: LD_ADDR_VAR 0 8
74002: PUSH
74003: LD_VAR 0 8
74007: PUSH
74008: LD_VAR 0 7
74012: PPUSH
74013: CALL_OW 313
74017: ADD
74018: ST_TO_ADDR
// end ;
74019: GO 73968
74021: POP
74022: POP
// if not sci then
74023: LD_VAR 0 8
74027: NOT
74028: IFFALSE 74032
// continue ;
74030: GO 73077
// for x in sci do
74032: LD_ADDR_VAR 0 7
74036: PUSH
74037: LD_VAR 0 8
74041: PUSH
74042: FOR_IN
74043: IFFALSE 74093
// if IsInUnit ( x ) and not HasTask ( x ) then
74045: LD_VAR 0 7
74049: PPUSH
74050: CALL_OW 310
74054: PUSH
74055: LD_VAR 0 7
74059: PPUSH
74060: CALL_OW 314
74064: NOT
74065: AND
74066: IFFALSE 74091
// begin ComExitBuilding ( x ) ;
74068: LD_VAR 0 7
74072: PPUSH
74073: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74077: LD_VAR 0 7
74081: PPUSH
74082: LD_VAR 0 3
74086: PPUSH
74087: CALL_OW 180
// end ;
74091: GO 74042
74093: POP
74094: POP
// end ; end ;
74095: GO 73077
74097: POP
74098: POP
// end ;
74099: GO 73031
74101: POP
74102: POP
// end ;
74103: LD_VAR 0 1
74107: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74108: LD_INT 0
74110: PPUSH
74111: PPUSH
// if not mc_bases then
74112: LD_EXP 58
74116: NOT
74117: IFFALSE 74121
// exit ;
74119: GO 74202
// for i = 1 to mc_bases do
74121: LD_ADDR_VAR 0 2
74125: PUSH
74126: DOUBLE
74127: LD_INT 1
74129: DEC
74130: ST_TO_ADDR
74131: LD_EXP 58
74135: PUSH
74136: FOR_TO
74137: IFFALSE 74200
// if mc_mines [ i ] and mc_miners [ i ] then
74139: LD_EXP 71
74143: PUSH
74144: LD_VAR 0 2
74148: ARRAY
74149: PUSH
74150: LD_EXP 72
74154: PUSH
74155: LD_VAR 0 2
74159: ARRAY
74160: AND
74161: IFFALSE 74198
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74163: LD_EXP 72
74167: PUSH
74168: LD_VAR 0 2
74172: ARRAY
74173: PUSH
74174: LD_INT 1
74176: ARRAY
74177: PPUSH
74178: CALL_OW 255
74182: PPUSH
74183: LD_EXP 71
74187: PUSH
74188: LD_VAR 0 2
74192: ARRAY
74193: PPUSH
74194: CALL 17810 0 2
74198: GO 74136
74200: POP
74201: POP
// end ;
74202: LD_VAR 0 1
74206: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
74207: LD_INT 0
74209: PPUSH
74210: PPUSH
74211: PPUSH
74212: PPUSH
74213: PPUSH
74214: PPUSH
74215: PPUSH
74216: PPUSH
// if not mc_bases or not mc_parking then
74217: LD_EXP 58
74221: NOT
74222: PUSH
74223: LD_EXP 82
74227: NOT
74228: OR
74229: IFFALSE 74233
// exit ;
74231: GO 74932
// for i = 1 to mc_bases do
74233: LD_ADDR_VAR 0 2
74237: PUSH
74238: DOUBLE
74239: LD_INT 1
74241: DEC
74242: ST_TO_ADDR
74243: LD_EXP 58
74247: PUSH
74248: FOR_TO
74249: IFFALSE 74930
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
74251: LD_EXP 58
74255: PUSH
74256: LD_VAR 0 2
74260: ARRAY
74261: NOT
74262: PUSH
74263: LD_EXP 82
74267: PUSH
74268: LD_VAR 0 2
74272: ARRAY
74273: NOT
74274: OR
74275: IFFALSE 74279
// continue ;
74277: GO 74248
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74279: LD_ADDR_VAR 0 5
74283: PUSH
74284: LD_EXP 58
74288: PUSH
74289: LD_VAR 0 2
74293: ARRAY
74294: PUSH
74295: LD_INT 1
74297: ARRAY
74298: PPUSH
74299: CALL_OW 255
74303: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74304: LD_ADDR_VAR 0 6
74308: PUSH
74309: LD_EXP 58
74313: PUSH
74314: LD_VAR 0 2
74318: ARRAY
74319: PPUSH
74320: LD_INT 30
74322: PUSH
74323: LD_INT 3
74325: PUSH
74326: EMPTY
74327: LIST
74328: LIST
74329: PPUSH
74330: CALL_OW 72
74334: ST_TO_ADDR
// if not fac then
74335: LD_VAR 0 6
74339: NOT
74340: IFFALSE 74391
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74342: LD_ADDR_VAR 0 6
74346: PUSH
74347: LD_EXP 58
74351: PUSH
74352: LD_VAR 0 2
74356: ARRAY
74357: PPUSH
74358: LD_INT 2
74360: PUSH
74361: LD_INT 30
74363: PUSH
74364: LD_INT 0
74366: PUSH
74367: EMPTY
74368: LIST
74369: LIST
74370: PUSH
74371: LD_INT 30
74373: PUSH
74374: LD_INT 1
74376: PUSH
74377: EMPTY
74378: LIST
74379: LIST
74380: PUSH
74381: EMPTY
74382: LIST
74383: LIST
74384: LIST
74385: PPUSH
74386: CALL_OW 72
74390: ST_TO_ADDR
// if not fac then
74391: LD_VAR 0 6
74395: NOT
74396: IFFALSE 74400
// continue ;
74398: GO 74248
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74400: LD_ADDR_VAR 0 7
74404: PUSH
74405: LD_EXP 82
74409: PUSH
74410: LD_VAR 0 2
74414: ARRAY
74415: PPUSH
74416: LD_INT 22
74418: PUSH
74419: LD_VAR 0 5
74423: PUSH
74424: EMPTY
74425: LIST
74426: LIST
74427: PUSH
74428: LD_INT 21
74430: PUSH
74431: LD_INT 2
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: PUSH
74438: LD_INT 3
74440: PUSH
74441: LD_INT 24
74443: PUSH
74444: LD_INT 1000
74446: PUSH
74447: EMPTY
74448: LIST
74449: LIST
74450: PUSH
74451: EMPTY
74452: LIST
74453: LIST
74454: PUSH
74455: EMPTY
74456: LIST
74457: LIST
74458: LIST
74459: PPUSH
74460: CALL_OW 70
74464: ST_TO_ADDR
// for j in fac do
74465: LD_ADDR_VAR 0 3
74469: PUSH
74470: LD_VAR 0 6
74474: PUSH
74475: FOR_IN
74476: IFFALSE 74557
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74478: LD_ADDR_VAR 0 7
74482: PUSH
74483: LD_VAR 0 7
74487: PUSH
74488: LD_INT 22
74490: PUSH
74491: LD_VAR 0 5
74495: PUSH
74496: EMPTY
74497: LIST
74498: LIST
74499: PUSH
74500: LD_INT 91
74502: PUSH
74503: LD_VAR 0 3
74507: PUSH
74508: LD_INT 15
74510: PUSH
74511: EMPTY
74512: LIST
74513: LIST
74514: LIST
74515: PUSH
74516: LD_INT 21
74518: PUSH
74519: LD_INT 2
74521: PUSH
74522: EMPTY
74523: LIST
74524: LIST
74525: PUSH
74526: LD_INT 3
74528: PUSH
74529: LD_INT 24
74531: PUSH
74532: LD_INT 1000
74534: PUSH
74535: EMPTY
74536: LIST
74537: LIST
74538: PUSH
74539: EMPTY
74540: LIST
74541: LIST
74542: PUSH
74543: EMPTY
74544: LIST
74545: LIST
74546: LIST
74547: LIST
74548: PPUSH
74549: CALL_OW 69
74553: UNION
74554: ST_TO_ADDR
74555: GO 74475
74557: POP
74558: POP
// if not vehs then
74559: LD_VAR 0 7
74563: NOT
74564: IFFALSE 74590
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
74566: LD_ADDR_EXP 70
74570: PUSH
74571: LD_EXP 70
74575: PPUSH
74576: LD_VAR 0 2
74580: PPUSH
74581: EMPTY
74582: PPUSH
74583: CALL_OW 1
74587: ST_TO_ADDR
// continue ;
74588: GO 74248
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74590: LD_ADDR_VAR 0 8
74594: PUSH
74595: LD_EXP 58
74599: PUSH
74600: LD_VAR 0 2
74604: ARRAY
74605: PPUSH
74606: LD_INT 30
74608: PUSH
74609: LD_INT 3
74611: PUSH
74612: EMPTY
74613: LIST
74614: LIST
74615: PPUSH
74616: CALL_OW 72
74620: ST_TO_ADDR
// if tmp then
74621: LD_VAR 0 8
74625: IFFALSE 74728
// begin for j in tmp do
74627: LD_ADDR_VAR 0 3
74631: PUSH
74632: LD_VAR 0 8
74636: PUSH
74637: FOR_IN
74638: IFFALSE 74726
// for k in UnitsInside ( j ) do
74640: LD_ADDR_VAR 0 4
74644: PUSH
74645: LD_VAR 0 3
74649: PPUSH
74650: CALL_OW 313
74654: PUSH
74655: FOR_IN
74656: IFFALSE 74722
// if k then
74658: LD_VAR 0 4
74662: IFFALSE 74720
// if not k in mc_repair_vehicle [ i ] then
74664: LD_VAR 0 4
74668: PUSH
74669: LD_EXP 70
74673: PUSH
74674: LD_VAR 0 2
74678: ARRAY
74679: IN
74680: NOT
74681: IFFALSE 74720
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
74683: LD_ADDR_EXP 70
74687: PUSH
74688: LD_EXP 70
74692: PPUSH
74693: LD_VAR 0 2
74697: PPUSH
74698: LD_EXP 70
74702: PUSH
74703: LD_VAR 0 2
74707: ARRAY
74708: PUSH
74709: LD_VAR 0 4
74713: UNION
74714: PPUSH
74715: CALL_OW 1
74719: ST_TO_ADDR
74720: GO 74655
74722: POP
74723: POP
74724: GO 74637
74726: POP
74727: POP
// end ; if not mc_repair_vehicle [ i ] then
74728: LD_EXP 70
74732: PUSH
74733: LD_VAR 0 2
74737: ARRAY
74738: NOT
74739: IFFALSE 74743
// continue ;
74741: GO 74248
// for j in mc_repair_vehicle [ i ] do
74743: LD_ADDR_VAR 0 3
74747: PUSH
74748: LD_EXP 70
74752: PUSH
74753: LD_VAR 0 2
74757: ARRAY
74758: PUSH
74759: FOR_IN
74760: IFFALSE 74926
// begin if GetClass ( j ) <> 3 then
74762: LD_VAR 0 3
74766: PPUSH
74767: CALL_OW 257
74771: PUSH
74772: LD_INT 3
74774: NONEQUAL
74775: IFFALSE 74816
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
74777: LD_ADDR_EXP 70
74781: PUSH
74782: LD_EXP 70
74786: PPUSH
74787: LD_VAR 0 2
74791: PPUSH
74792: LD_EXP 70
74796: PUSH
74797: LD_VAR 0 2
74801: ARRAY
74802: PUSH
74803: LD_VAR 0 3
74807: DIFF
74808: PPUSH
74809: CALL_OW 1
74813: ST_TO_ADDR
// continue ;
74814: GO 74759
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74816: LD_VAR 0 3
74820: PPUSH
74821: CALL_OW 311
74825: NOT
74826: PUSH
74827: LD_VAR 0 3
74831: PUSH
74832: LD_EXP 61
74836: PUSH
74837: LD_VAR 0 2
74841: ARRAY
74842: PUSH
74843: LD_INT 1
74845: ARRAY
74846: IN
74847: NOT
74848: AND
74849: PUSH
74850: LD_VAR 0 3
74854: PUSH
74855: LD_EXP 61
74859: PUSH
74860: LD_VAR 0 2
74864: ARRAY
74865: PUSH
74866: LD_INT 2
74868: ARRAY
74869: IN
74870: NOT
74871: AND
74872: IFFALSE 74924
// begin if IsInUnit ( j ) then
74874: LD_VAR 0 3
74878: PPUSH
74879: CALL_OW 310
74883: IFFALSE 74894
// ComExitBuilding ( j ) ;
74885: LD_VAR 0 3
74889: PPUSH
74890: CALL_OW 122
// if not HasTask ( j ) then
74894: LD_VAR 0 3
74898: PPUSH
74899: CALL_OW 314
74903: NOT
74904: IFFALSE 74924
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
74906: LD_VAR 0 3
74910: PPUSH
74911: LD_VAR 0 7
74915: PUSH
74916: LD_INT 1
74918: ARRAY
74919: PPUSH
74920: CALL_OW 189
// end ; end ;
74924: GO 74759
74926: POP
74927: POP
// end ;
74928: GO 74248
74930: POP
74931: POP
// end ;
74932: LD_VAR 0 1
74936: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
74937: LD_INT 0
74939: PPUSH
74940: PPUSH
74941: PPUSH
74942: PPUSH
74943: PPUSH
74944: PPUSH
74945: PPUSH
74946: PPUSH
74947: PPUSH
74948: PPUSH
74949: PPUSH
// if not mc_bases then
74950: LD_EXP 58
74954: NOT
74955: IFFALSE 74959
// exit ;
74957: GO 75761
// for i = 1 to mc_bases do
74959: LD_ADDR_VAR 0 2
74963: PUSH
74964: DOUBLE
74965: LD_INT 1
74967: DEC
74968: ST_TO_ADDR
74969: LD_EXP 58
74973: PUSH
74974: FOR_TO
74975: IFFALSE 75759
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
74977: LD_EXP 86
74981: PUSH
74982: LD_VAR 0 2
74986: ARRAY
74987: NOT
74988: PUSH
74989: LD_EXP 61
74993: PUSH
74994: LD_VAR 0 2
74998: ARRAY
74999: PUSH
75000: LD_INT 1
75002: ARRAY
75003: OR
75004: PUSH
75005: LD_EXP 61
75009: PUSH
75010: LD_VAR 0 2
75014: ARRAY
75015: PUSH
75016: LD_INT 2
75018: ARRAY
75019: OR
75020: PUSH
75021: LD_EXP 84
75025: PUSH
75026: LD_VAR 0 2
75030: ARRAY
75031: PPUSH
75032: LD_INT 1
75034: PPUSH
75035: CALL_OW 325
75039: NOT
75040: OR
75041: PUSH
75042: LD_EXP 81
75046: PUSH
75047: LD_VAR 0 2
75051: ARRAY
75052: OR
75053: IFFALSE 75057
// continue ;
75055: GO 74974
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75057: LD_ADDR_VAR 0 8
75061: PUSH
75062: LD_EXP 58
75066: PUSH
75067: LD_VAR 0 2
75071: ARRAY
75072: PPUSH
75073: LD_INT 25
75075: PUSH
75076: LD_INT 4
75078: PUSH
75079: EMPTY
75080: LIST
75081: LIST
75082: PUSH
75083: LD_INT 50
75085: PUSH
75086: EMPTY
75087: LIST
75088: PUSH
75089: LD_INT 3
75091: PUSH
75092: LD_INT 60
75094: PUSH
75095: EMPTY
75096: LIST
75097: PUSH
75098: EMPTY
75099: LIST
75100: LIST
75101: PUSH
75102: EMPTY
75103: LIST
75104: LIST
75105: LIST
75106: PPUSH
75107: CALL_OW 72
75111: PUSH
75112: LD_EXP 62
75116: PUSH
75117: LD_VAR 0 2
75121: ARRAY
75122: DIFF
75123: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75124: LD_ADDR_VAR 0 9
75128: PUSH
75129: LD_EXP 58
75133: PUSH
75134: LD_VAR 0 2
75138: ARRAY
75139: PPUSH
75140: LD_INT 2
75142: PUSH
75143: LD_INT 30
75145: PUSH
75146: LD_INT 0
75148: PUSH
75149: EMPTY
75150: LIST
75151: LIST
75152: PUSH
75153: LD_INT 30
75155: PUSH
75156: LD_INT 1
75158: PUSH
75159: EMPTY
75160: LIST
75161: LIST
75162: PUSH
75163: EMPTY
75164: LIST
75165: LIST
75166: LIST
75167: PPUSH
75168: CALL_OW 72
75172: ST_TO_ADDR
// if not tmp or not dep then
75173: LD_VAR 0 8
75177: NOT
75178: PUSH
75179: LD_VAR 0 9
75183: NOT
75184: OR
75185: IFFALSE 75189
// continue ;
75187: GO 74974
// side := GetSide ( tmp [ 1 ] ) ;
75189: LD_ADDR_VAR 0 11
75193: PUSH
75194: LD_VAR 0 8
75198: PUSH
75199: LD_INT 1
75201: ARRAY
75202: PPUSH
75203: CALL_OW 255
75207: ST_TO_ADDR
// dep := dep [ 1 ] ;
75208: LD_ADDR_VAR 0 9
75212: PUSH
75213: LD_VAR 0 9
75217: PUSH
75218: LD_INT 1
75220: ARRAY
75221: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
75222: LD_ADDR_VAR 0 7
75226: PUSH
75227: LD_EXP 86
75231: PUSH
75232: LD_VAR 0 2
75236: ARRAY
75237: PPUSH
75238: LD_INT 22
75240: PUSH
75241: LD_INT 0
75243: PUSH
75244: EMPTY
75245: LIST
75246: LIST
75247: PUSH
75248: LD_INT 25
75250: PUSH
75251: LD_INT 12
75253: PUSH
75254: EMPTY
75255: LIST
75256: LIST
75257: PUSH
75258: EMPTY
75259: LIST
75260: LIST
75261: PPUSH
75262: CALL_OW 70
75266: PUSH
75267: LD_INT 22
75269: PUSH
75270: LD_INT 0
75272: PUSH
75273: EMPTY
75274: LIST
75275: LIST
75276: PUSH
75277: LD_INT 25
75279: PUSH
75280: LD_INT 12
75282: PUSH
75283: EMPTY
75284: LIST
75285: LIST
75286: PUSH
75287: LD_INT 91
75289: PUSH
75290: LD_VAR 0 9
75294: PUSH
75295: LD_INT 20
75297: PUSH
75298: EMPTY
75299: LIST
75300: LIST
75301: LIST
75302: PUSH
75303: EMPTY
75304: LIST
75305: LIST
75306: LIST
75307: PPUSH
75308: CALL_OW 69
75312: UNION
75313: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
75314: LD_ADDR_VAR 0 10
75318: PUSH
75319: LD_EXP 86
75323: PUSH
75324: LD_VAR 0 2
75328: ARRAY
75329: PPUSH
75330: LD_INT 81
75332: PUSH
75333: LD_VAR 0 11
75337: PUSH
75338: EMPTY
75339: LIST
75340: LIST
75341: PPUSH
75342: CALL_OW 70
75346: ST_TO_ADDR
// if not apes or danger_at_area then
75347: LD_VAR 0 7
75351: NOT
75352: PUSH
75353: LD_VAR 0 10
75357: OR
75358: IFFALSE 75408
// begin if mc_taming [ i ] then
75360: LD_EXP 89
75364: PUSH
75365: LD_VAR 0 2
75369: ARRAY
75370: IFFALSE 75406
// begin MC_Reset ( i , 121 ) ;
75372: LD_VAR 0 2
75376: PPUSH
75377: LD_INT 121
75379: PPUSH
75380: CALL 60739 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
75384: LD_ADDR_EXP 89
75388: PUSH
75389: LD_EXP 89
75393: PPUSH
75394: LD_VAR 0 2
75398: PPUSH
75399: EMPTY
75400: PPUSH
75401: CALL_OW 1
75405: ST_TO_ADDR
// end ; continue ;
75406: GO 74974
// end ; for j in tmp do
75408: LD_ADDR_VAR 0 3
75412: PUSH
75413: LD_VAR 0 8
75417: PUSH
75418: FOR_IN
75419: IFFALSE 75755
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
75421: LD_VAR 0 3
75425: PUSH
75426: LD_EXP 89
75430: PUSH
75431: LD_VAR 0 2
75435: ARRAY
75436: IN
75437: NOT
75438: PUSH
75439: LD_EXP 89
75443: PUSH
75444: LD_VAR 0 2
75448: ARRAY
75449: PUSH
75450: LD_INT 3
75452: LESS
75453: AND
75454: IFFALSE 75512
// begin SetTag ( j , 121 ) ;
75456: LD_VAR 0 3
75460: PPUSH
75461: LD_INT 121
75463: PPUSH
75464: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
75468: LD_ADDR_EXP 89
75472: PUSH
75473: LD_EXP 89
75477: PPUSH
75478: LD_VAR 0 2
75482: PUSH
75483: LD_EXP 89
75487: PUSH
75488: LD_VAR 0 2
75492: ARRAY
75493: PUSH
75494: LD_INT 1
75496: PLUS
75497: PUSH
75498: EMPTY
75499: LIST
75500: LIST
75501: PPUSH
75502: LD_VAR 0 3
75506: PPUSH
75507: CALL 20821 0 3
75511: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
75512: LD_VAR 0 3
75516: PUSH
75517: LD_EXP 89
75521: PUSH
75522: LD_VAR 0 2
75526: ARRAY
75527: IN
75528: IFFALSE 75753
// begin if GetClass ( j ) <> 4 then
75530: LD_VAR 0 3
75534: PPUSH
75535: CALL_OW 257
75539: PUSH
75540: LD_INT 4
75542: NONEQUAL
75543: IFFALSE 75596
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
75545: LD_ADDR_EXP 89
75549: PUSH
75550: LD_EXP 89
75554: PPUSH
75555: LD_VAR 0 2
75559: PPUSH
75560: LD_EXP 89
75564: PUSH
75565: LD_VAR 0 2
75569: ARRAY
75570: PUSH
75571: LD_VAR 0 3
75575: DIFF
75576: PPUSH
75577: CALL_OW 1
75581: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75582: LD_VAR 0 3
75586: PPUSH
75587: LD_INT 0
75589: PPUSH
75590: CALL_OW 109
// continue ;
75594: GO 75418
// end ; if IsInUnit ( j ) then
75596: LD_VAR 0 3
75600: PPUSH
75601: CALL_OW 310
75605: IFFALSE 75616
// ComExitBuilding ( j ) ;
75607: LD_VAR 0 3
75611: PPUSH
75612: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
75616: LD_ADDR_VAR 0 6
75620: PUSH
75621: LD_VAR 0 7
75625: PPUSH
75626: LD_VAR 0 3
75630: PPUSH
75631: CALL_OW 74
75635: ST_TO_ADDR
// if not ape then
75636: LD_VAR 0 6
75640: NOT
75641: IFFALSE 75645
// break ;
75643: GO 75755
// x := GetX ( ape ) ;
75645: LD_ADDR_VAR 0 4
75649: PUSH
75650: LD_VAR 0 6
75654: PPUSH
75655: CALL_OW 250
75659: ST_TO_ADDR
// y := GetY ( ape ) ;
75660: LD_ADDR_VAR 0 5
75664: PUSH
75665: LD_VAR 0 6
75669: PPUSH
75670: CALL_OW 251
75674: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
75675: LD_VAR 0 4
75679: PPUSH
75680: LD_VAR 0 5
75684: PPUSH
75685: CALL_OW 488
75689: NOT
75690: PUSH
75691: LD_VAR 0 11
75695: PPUSH
75696: LD_VAR 0 4
75700: PPUSH
75701: LD_VAR 0 5
75705: PPUSH
75706: LD_INT 20
75708: PPUSH
75709: CALL 21717 0 4
75713: PUSH
75714: LD_INT 4
75716: ARRAY
75717: OR
75718: IFFALSE 75722
// break ;
75720: GO 75755
// if not HasTask ( j ) then
75722: LD_VAR 0 3
75726: PPUSH
75727: CALL_OW 314
75731: NOT
75732: IFFALSE 75753
// ComTameXY ( j , x , y ) ;
75734: LD_VAR 0 3
75738: PPUSH
75739: LD_VAR 0 4
75743: PPUSH
75744: LD_VAR 0 5
75748: PPUSH
75749: CALL_OW 131
// end ; end ;
75753: GO 75418
75755: POP
75756: POP
// end ;
75757: GO 74974
75759: POP
75760: POP
// end ;
75761: LD_VAR 0 1
75765: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
75766: LD_INT 0
75768: PPUSH
75769: PPUSH
75770: PPUSH
75771: PPUSH
75772: PPUSH
75773: PPUSH
75774: PPUSH
75775: PPUSH
// if not mc_bases then
75776: LD_EXP 58
75780: NOT
75781: IFFALSE 75785
// exit ;
75783: GO 76411
// for i = 1 to mc_bases do
75785: LD_ADDR_VAR 0 2
75789: PUSH
75790: DOUBLE
75791: LD_INT 1
75793: DEC
75794: ST_TO_ADDR
75795: LD_EXP 58
75799: PUSH
75800: FOR_TO
75801: IFFALSE 76409
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
75803: LD_EXP 87
75807: PUSH
75808: LD_VAR 0 2
75812: ARRAY
75813: NOT
75814: PUSH
75815: LD_EXP 87
75819: PUSH
75820: LD_VAR 0 2
75824: ARRAY
75825: PPUSH
75826: LD_INT 25
75828: PUSH
75829: LD_INT 12
75831: PUSH
75832: EMPTY
75833: LIST
75834: LIST
75835: PPUSH
75836: CALL_OW 72
75840: NOT
75841: OR
75842: IFFALSE 75846
// continue ;
75844: GO 75800
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
75846: LD_ADDR_VAR 0 5
75850: PUSH
75851: LD_EXP 87
75855: PUSH
75856: LD_VAR 0 2
75860: ARRAY
75861: PUSH
75862: LD_INT 1
75864: ARRAY
75865: PPUSH
75866: CALL_OW 255
75870: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
75871: LD_VAR 0 5
75875: PPUSH
75876: LD_INT 2
75878: PPUSH
75879: CALL_OW 325
75883: IFFALSE 76136
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
75885: LD_ADDR_VAR 0 4
75889: PUSH
75890: LD_EXP 87
75894: PUSH
75895: LD_VAR 0 2
75899: ARRAY
75900: PPUSH
75901: LD_INT 25
75903: PUSH
75904: LD_INT 16
75906: PUSH
75907: EMPTY
75908: LIST
75909: LIST
75910: PPUSH
75911: CALL_OW 72
75915: ST_TO_ADDR
// if tmp < 6 then
75916: LD_VAR 0 4
75920: PUSH
75921: LD_INT 6
75923: LESS
75924: IFFALSE 76136
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75926: LD_ADDR_VAR 0 6
75930: PUSH
75931: LD_EXP 58
75935: PUSH
75936: LD_VAR 0 2
75940: ARRAY
75941: PPUSH
75942: LD_INT 2
75944: PUSH
75945: LD_INT 30
75947: PUSH
75948: LD_INT 0
75950: PUSH
75951: EMPTY
75952: LIST
75953: LIST
75954: PUSH
75955: LD_INT 30
75957: PUSH
75958: LD_INT 1
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: EMPTY
75966: LIST
75967: LIST
75968: LIST
75969: PPUSH
75970: CALL_OW 72
75974: ST_TO_ADDR
// if depot then
75975: LD_VAR 0 6
75979: IFFALSE 76136
// begin selected := 0 ;
75981: LD_ADDR_VAR 0 7
75985: PUSH
75986: LD_INT 0
75988: ST_TO_ADDR
// for j in depot do
75989: LD_ADDR_VAR 0 3
75993: PUSH
75994: LD_VAR 0 6
75998: PUSH
75999: FOR_IN
76000: IFFALSE 76031
// begin if UnitsInside ( j ) < 6 then
76002: LD_VAR 0 3
76006: PPUSH
76007: CALL_OW 313
76011: PUSH
76012: LD_INT 6
76014: LESS
76015: IFFALSE 76029
// begin selected := j ;
76017: LD_ADDR_VAR 0 7
76021: PUSH
76022: LD_VAR 0 3
76026: ST_TO_ADDR
// break ;
76027: GO 76031
// end ; end ;
76029: GO 75999
76031: POP
76032: POP
// if selected then
76033: LD_VAR 0 7
76037: IFFALSE 76136
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76039: LD_ADDR_VAR 0 3
76043: PUSH
76044: LD_EXP 87
76048: PUSH
76049: LD_VAR 0 2
76053: ARRAY
76054: PPUSH
76055: LD_INT 25
76057: PUSH
76058: LD_INT 12
76060: PUSH
76061: EMPTY
76062: LIST
76063: LIST
76064: PPUSH
76065: CALL_OW 72
76069: PUSH
76070: FOR_IN
76071: IFFALSE 76134
// if not HasTask ( j ) then
76073: LD_VAR 0 3
76077: PPUSH
76078: CALL_OW 314
76082: NOT
76083: IFFALSE 76132
// begin if not IsInUnit ( j ) then
76085: LD_VAR 0 3
76089: PPUSH
76090: CALL_OW 310
76094: NOT
76095: IFFALSE 76111
// ComEnterUnit ( j , selected ) ;
76097: LD_VAR 0 3
76101: PPUSH
76102: LD_VAR 0 7
76106: PPUSH
76107: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76111: LD_VAR 0 3
76115: PPUSH
76116: LD_INT 16
76118: PPUSH
76119: CALL_OW 183
// AddComExitBuilding ( j ) ;
76123: LD_VAR 0 3
76127: PPUSH
76128: CALL_OW 182
// end ;
76132: GO 76070
76134: POP
76135: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76136: LD_VAR 0 5
76140: PPUSH
76141: LD_INT 11
76143: PPUSH
76144: CALL_OW 325
76148: IFFALSE 76407
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76150: LD_ADDR_VAR 0 4
76154: PUSH
76155: LD_EXP 87
76159: PUSH
76160: LD_VAR 0 2
76164: ARRAY
76165: PPUSH
76166: LD_INT 25
76168: PUSH
76169: LD_INT 16
76171: PUSH
76172: EMPTY
76173: LIST
76174: LIST
76175: PPUSH
76176: CALL_OW 72
76180: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
76181: LD_VAR 0 4
76185: PUSH
76186: LD_INT 6
76188: GREATEREQUAL
76189: PUSH
76190: LD_VAR 0 5
76194: PPUSH
76195: LD_INT 2
76197: PPUSH
76198: CALL_OW 325
76202: NOT
76203: OR
76204: IFFALSE 76407
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76206: LD_ADDR_VAR 0 8
76210: PUSH
76211: LD_EXP 58
76215: PUSH
76216: LD_VAR 0 2
76220: ARRAY
76221: PPUSH
76222: LD_INT 2
76224: PUSH
76225: LD_INT 30
76227: PUSH
76228: LD_INT 4
76230: PUSH
76231: EMPTY
76232: LIST
76233: LIST
76234: PUSH
76235: LD_INT 30
76237: PUSH
76238: LD_INT 5
76240: PUSH
76241: EMPTY
76242: LIST
76243: LIST
76244: PUSH
76245: EMPTY
76246: LIST
76247: LIST
76248: LIST
76249: PPUSH
76250: CALL_OW 72
76254: ST_TO_ADDR
// if barracks then
76255: LD_VAR 0 8
76259: IFFALSE 76407
// begin selected := 0 ;
76261: LD_ADDR_VAR 0 7
76265: PUSH
76266: LD_INT 0
76268: ST_TO_ADDR
// for j in barracks do
76269: LD_ADDR_VAR 0 3
76273: PUSH
76274: LD_VAR 0 8
76278: PUSH
76279: FOR_IN
76280: IFFALSE 76311
// begin if UnitsInside ( j ) < 6 then
76282: LD_VAR 0 3
76286: PPUSH
76287: CALL_OW 313
76291: PUSH
76292: LD_INT 6
76294: LESS
76295: IFFALSE 76309
// begin selected := j ;
76297: LD_ADDR_VAR 0 7
76301: PUSH
76302: LD_VAR 0 3
76306: ST_TO_ADDR
// break ;
76307: GO 76311
// end ; end ;
76309: GO 76279
76311: POP
76312: POP
// if selected then
76313: LD_VAR 0 7
76317: IFFALSE 76407
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76319: LD_ADDR_VAR 0 3
76323: PUSH
76324: LD_EXP 87
76328: PUSH
76329: LD_VAR 0 2
76333: ARRAY
76334: PPUSH
76335: LD_INT 25
76337: PUSH
76338: LD_INT 12
76340: PUSH
76341: EMPTY
76342: LIST
76343: LIST
76344: PPUSH
76345: CALL_OW 72
76349: PUSH
76350: FOR_IN
76351: IFFALSE 76405
// if not IsInUnit ( j ) and not HasTask ( j ) then
76353: LD_VAR 0 3
76357: PPUSH
76358: CALL_OW 310
76362: NOT
76363: PUSH
76364: LD_VAR 0 3
76368: PPUSH
76369: CALL_OW 314
76373: NOT
76374: AND
76375: IFFALSE 76403
// begin ComEnterUnit ( j , selected ) ;
76377: LD_VAR 0 3
76381: PPUSH
76382: LD_VAR 0 7
76386: PPUSH
76387: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
76391: LD_VAR 0 3
76395: PPUSH
76396: LD_INT 15
76398: PPUSH
76399: CALL_OW 183
// end ;
76403: GO 76350
76405: POP
76406: POP
// end ; end ; end ; end ; end ;
76407: GO 75800
76409: POP
76410: POP
// end ;
76411: LD_VAR 0 1
76415: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
76416: LD_INT 0
76418: PPUSH
76419: PPUSH
76420: PPUSH
76421: PPUSH
// if not mc_bases then
76422: LD_EXP 58
76426: NOT
76427: IFFALSE 76431
// exit ;
76429: GO 76609
// for i = 1 to mc_bases do
76431: LD_ADDR_VAR 0 2
76435: PUSH
76436: DOUBLE
76437: LD_INT 1
76439: DEC
76440: ST_TO_ADDR
76441: LD_EXP 58
76445: PUSH
76446: FOR_TO
76447: IFFALSE 76607
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
76449: LD_ADDR_VAR 0 4
76453: PUSH
76454: LD_EXP 58
76458: PUSH
76459: LD_VAR 0 2
76463: ARRAY
76464: PPUSH
76465: LD_INT 25
76467: PUSH
76468: LD_INT 9
76470: PUSH
76471: EMPTY
76472: LIST
76473: LIST
76474: PPUSH
76475: CALL_OW 72
76479: ST_TO_ADDR
// if not tmp then
76480: LD_VAR 0 4
76484: NOT
76485: IFFALSE 76489
// continue ;
76487: GO 76446
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
76489: LD_EXP 84
76493: PUSH
76494: LD_VAR 0 2
76498: ARRAY
76499: PPUSH
76500: LD_INT 29
76502: PPUSH
76503: CALL_OW 325
76507: NOT
76508: PUSH
76509: LD_EXP 84
76513: PUSH
76514: LD_VAR 0 2
76518: ARRAY
76519: PPUSH
76520: LD_INT 28
76522: PPUSH
76523: CALL_OW 325
76527: NOT
76528: AND
76529: IFFALSE 76533
// continue ;
76531: GO 76446
// for j in tmp do
76533: LD_ADDR_VAR 0 3
76537: PUSH
76538: LD_VAR 0 4
76542: PUSH
76543: FOR_IN
76544: IFFALSE 76603
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
76546: LD_VAR 0 3
76550: PUSH
76551: LD_EXP 61
76555: PUSH
76556: LD_VAR 0 2
76560: ARRAY
76561: PUSH
76562: LD_INT 1
76564: ARRAY
76565: IN
76566: NOT
76567: PUSH
76568: LD_VAR 0 3
76572: PUSH
76573: LD_EXP 61
76577: PUSH
76578: LD_VAR 0 2
76582: ARRAY
76583: PUSH
76584: LD_INT 2
76586: ARRAY
76587: IN
76588: NOT
76589: AND
76590: IFFALSE 76601
// ComSpaceTimeShoot ( j ) ;
76592: LD_VAR 0 3
76596: PPUSH
76597: CALL 14771 0 1
76601: GO 76543
76603: POP
76604: POP
// end ;
76605: GO 76446
76607: POP
76608: POP
// end ;
76609: LD_VAR 0 1
76613: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
76614: LD_INT 0
76616: PPUSH
76617: PPUSH
76618: PPUSH
76619: PPUSH
76620: PPUSH
76621: PPUSH
76622: PPUSH
76623: PPUSH
76624: PPUSH
// if not mc_bases then
76625: LD_EXP 58
76629: NOT
76630: IFFALSE 76634
// exit ;
76632: GO 77256
// for i = 1 to mc_bases do
76634: LD_ADDR_VAR 0 2
76638: PUSH
76639: DOUBLE
76640: LD_INT 1
76642: DEC
76643: ST_TO_ADDR
76644: LD_EXP 58
76648: PUSH
76649: FOR_TO
76650: IFFALSE 77254
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
76652: LD_EXP 93
76656: PUSH
76657: LD_VAR 0 2
76661: ARRAY
76662: NOT
76663: PUSH
76664: LD_INT 38
76666: PPUSH
76667: LD_EXP 84
76671: PUSH
76672: LD_VAR 0 2
76676: ARRAY
76677: PPUSH
76678: CALL_OW 321
76682: PUSH
76683: LD_INT 2
76685: NONEQUAL
76686: OR
76687: IFFALSE 76691
// continue ;
76689: GO 76649
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
76691: LD_ADDR_VAR 0 8
76695: PUSH
76696: LD_EXP 58
76700: PUSH
76701: LD_VAR 0 2
76705: ARRAY
76706: PPUSH
76707: LD_INT 30
76709: PUSH
76710: LD_INT 34
76712: PUSH
76713: EMPTY
76714: LIST
76715: LIST
76716: PPUSH
76717: CALL_OW 72
76721: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
76722: LD_ADDR_VAR 0 9
76726: PUSH
76727: LD_EXP 58
76731: PUSH
76732: LD_VAR 0 2
76736: ARRAY
76737: PPUSH
76738: LD_INT 25
76740: PUSH
76741: LD_INT 4
76743: PUSH
76744: EMPTY
76745: LIST
76746: LIST
76747: PPUSH
76748: CALL_OW 72
76752: PPUSH
76753: LD_INT 0
76755: PPUSH
76756: CALL 54081 0 2
76760: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
76761: LD_VAR 0 9
76765: NOT
76766: PUSH
76767: LD_VAR 0 8
76771: NOT
76772: OR
76773: PUSH
76774: LD_EXP 58
76778: PUSH
76779: LD_VAR 0 2
76783: ARRAY
76784: PPUSH
76785: LD_INT 124
76787: PPUSH
76788: CALL 54081 0 2
76792: OR
76793: IFFALSE 76797
// continue ;
76795: GO 76649
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
76797: LD_EXP 94
76801: PUSH
76802: LD_VAR 0 2
76806: ARRAY
76807: PUSH
76808: LD_EXP 93
76812: PUSH
76813: LD_VAR 0 2
76817: ARRAY
76818: LESS
76819: PUSH
76820: LD_EXP 94
76824: PUSH
76825: LD_VAR 0 2
76829: ARRAY
76830: PUSH
76831: LD_VAR 0 8
76835: LESS
76836: AND
76837: IFFALSE 77252
// begin tmp := sci [ 1 ] ;
76839: LD_ADDR_VAR 0 7
76843: PUSH
76844: LD_VAR 0 9
76848: PUSH
76849: LD_INT 1
76851: ARRAY
76852: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
76853: LD_VAR 0 7
76857: PPUSH
76858: LD_INT 124
76860: PPUSH
76861: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
76865: LD_ADDR_VAR 0 3
76869: PUSH
76870: DOUBLE
76871: LD_EXP 93
76875: PUSH
76876: LD_VAR 0 2
76880: ARRAY
76881: INC
76882: ST_TO_ADDR
76883: LD_EXP 93
76887: PUSH
76888: LD_VAR 0 2
76892: ARRAY
76893: PUSH
76894: FOR_DOWNTO
76895: IFFALSE 77238
// begin if IsInUnit ( tmp ) then
76897: LD_VAR 0 7
76901: PPUSH
76902: CALL_OW 310
76906: IFFALSE 76917
// ComExitBuilding ( tmp ) ;
76908: LD_VAR 0 7
76912: PPUSH
76913: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
76917: LD_INT 35
76919: PPUSH
76920: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
76924: LD_VAR 0 7
76928: PPUSH
76929: CALL_OW 310
76933: NOT
76934: PUSH
76935: LD_VAR 0 7
76939: PPUSH
76940: CALL_OW 314
76944: NOT
76945: AND
76946: IFFALSE 76917
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
76948: LD_ADDR_VAR 0 6
76952: PUSH
76953: LD_VAR 0 7
76957: PPUSH
76958: CALL_OW 250
76962: PUSH
76963: LD_VAR 0 7
76967: PPUSH
76968: CALL_OW 251
76972: PUSH
76973: EMPTY
76974: LIST
76975: LIST
76976: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
76977: LD_INT 35
76979: PPUSH
76980: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
76984: LD_ADDR_VAR 0 4
76988: PUSH
76989: LD_EXP 93
76993: PUSH
76994: LD_VAR 0 2
76998: ARRAY
76999: PUSH
77000: LD_VAR 0 3
77004: ARRAY
77005: PUSH
77006: LD_INT 1
77008: ARRAY
77009: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77010: LD_ADDR_VAR 0 5
77014: PUSH
77015: LD_EXP 93
77019: PUSH
77020: LD_VAR 0 2
77024: ARRAY
77025: PUSH
77026: LD_VAR 0 3
77030: ARRAY
77031: PUSH
77032: LD_INT 2
77034: ARRAY
77035: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77036: LD_VAR 0 7
77040: PPUSH
77041: LD_INT 10
77043: PPUSH
77044: CALL 23414 0 2
77048: PUSH
77049: LD_INT 4
77051: ARRAY
77052: IFFALSE 77090
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77054: LD_VAR 0 7
77058: PPUSH
77059: LD_VAR 0 6
77063: PUSH
77064: LD_INT 1
77066: ARRAY
77067: PPUSH
77068: LD_VAR 0 6
77072: PUSH
77073: LD_INT 2
77075: ARRAY
77076: PPUSH
77077: CALL_OW 111
// wait ( 0 0$10 ) ;
77081: LD_INT 350
77083: PPUSH
77084: CALL_OW 67
// end else
77088: GO 77116
// begin ComMoveXY ( tmp , x , y ) ;
77090: LD_VAR 0 7
77094: PPUSH
77095: LD_VAR 0 4
77099: PPUSH
77100: LD_VAR 0 5
77104: PPUSH
77105: CALL_OW 111
// wait ( 0 0$3 ) ;
77109: LD_INT 105
77111: PPUSH
77112: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77116: LD_VAR 0 7
77120: PPUSH
77121: LD_VAR 0 4
77125: PPUSH
77126: LD_VAR 0 5
77130: PPUSH
77131: CALL_OW 307
77135: IFFALSE 76977
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77137: LD_VAR 0 7
77141: PPUSH
77142: LD_VAR 0 4
77146: PPUSH
77147: LD_VAR 0 5
77151: PPUSH
77152: LD_VAR 0 8
77156: PUSH
77157: LD_VAR 0 3
77161: ARRAY
77162: PPUSH
77163: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77167: LD_INT 35
77169: PPUSH
77170: CALL_OW 67
// until not HasTask ( tmp ) ;
77174: LD_VAR 0 7
77178: PPUSH
77179: CALL_OW 314
77183: NOT
77184: IFFALSE 77167
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
77186: LD_ADDR_EXP 94
77190: PUSH
77191: LD_EXP 94
77195: PPUSH
77196: LD_VAR 0 2
77200: PUSH
77201: LD_EXP 94
77205: PUSH
77206: LD_VAR 0 2
77210: ARRAY
77211: PUSH
77212: LD_INT 1
77214: PLUS
77215: PUSH
77216: EMPTY
77217: LIST
77218: LIST
77219: PPUSH
77220: LD_VAR 0 8
77224: PUSH
77225: LD_VAR 0 3
77229: ARRAY
77230: PPUSH
77231: CALL 20821 0 3
77235: ST_TO_ADDR
// end ;
77236: GO 76894
77238: POP
77239: POP
// MC_Reset ( i , 124 ) ;
77240: LD_VAR 0 2
77244: PPUSH
77245: LD_INT 124
77247: PPUSH
77248: CALL 60739 0 2
// end ; end ;
77252: GO 76649
77254: POP
77255: POP
// end ;
77256: LD_VAR 0 1
77260: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
77261: LD_INT 0
77263: PPUSH
77264: PPUSH
77265: PPUSH
// if not mc_bases then
77266: LD_EXP 58
77270: NOT
77271: IFFALSE 77275
// exit ;
77273: GO 77881
// for i = 1 to mc_bases do
77275: LD_ADDR_VAR 0 2
77279: PUSH
77280: DOUBLE
77281: LD_INT 1
77283: DEC
77284: ST_TO_ADDR
77285: LD_EXP 58
77289: PUSH
77290: FOR_TO
77291: IFFALSE 77879
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
77293: LD_ADDR_VAR 0 3
77297: PUSH
77298: LD_EXP 58
77302: PUSH
77303: LD_VAR 0 2
77307: ARRAY
77308: PPUSH
77309: LD_INT 25
77311: PUSH
77312: LD_INT 4
77314: PUSH
77315: EMPTY
77316: LIST
77317: LIST
77318: PPUSH
77319: CALL_OW 72
77323: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
77324: LD_VAR 0 3
77328: NOT
77329: PUSH
77330: LD_EXP 95
77334: PUSH
77335: LD_VAR 0 2
77339: ARRAY
77340: NOT
77341: OR
77342: PUSH
77343: LD_EXP 58
77347: PUSH
77348: LD_VAR 0 2
77352: ARRAY
77353: PPUSH
77354: LD_INT 2
77356: PUSH
77357: LD_INT 30
77359: PUSH
77360: LD_INT 0
77362: PUSH
77363: EMPTY
77364: LIST
77365: LIST
77366: PUSH
77367: LD_INT 30
77369: PUSH
77370: LD_INT 1
77372: PUSH
77373: EMPTY
77374: LIST
77375: LIST
77376: PUSH
77377: EMPTY
77378: LIST
77379: LIST
77380: LIST
77381: PPUSH
77382: CALL_OW 72
77386: NOT
77387: OR
77388: IFFALSE 77438
// begin if mc_deposits_finder [ i ] then
77390: LD_EXP 96
77394: PUSH
77395: LD_VAR 0 2
77399: ARRAY
77400: IFFALSE 77436
// begin MC_Reset ( i , 125 ) ;
77402: LD_VAR 0 2
77406: PPUSH
77407: LD_INT 125
77409: PPUSH
77410: CALL 60739 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77414: LD_ADDR_EXP 96
77418: PUSH
77419: LD_EXP 96
77423: PPUSH
77424: LD_VAR 0 2
77428: PPUSH
77429: EMPTY
77430: PPUSH
77431: CALL_OW 1
77435: ST_TO_ADDR
// end ; continue ;
77436: GO 77290
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
77438: LD_EXP 95
77442: PUSH
77443: LD_VAR 0 2
77447: ARRAY
77448: PUSH
77449: LD_INT 1
77451: ARRAY
77452: PUSH
77453: LD_INT 3
77455: ARRAY
77456: PUSH
77457: LD_INT 1
77459: EQUAL
77460: PUSH
77461: LD_INT 20
77463: PPUSH
77464: LD_EXP 84
77468: PUSH
77469: LD_VAR 0 2
77473: ARRAY
77474: PPUSH
77475: CALL_OW 321
77479: PUSH
77480: LD_INT 2
77482: NONEQUAL
77483: AND
77484: IFFALSE 77534
// begin if mc_deposits_finder [ i ] then
77486: LD_EXP 96
77490: PUSH
77491: LD_VAR 0 2
77495: ARRAY
77496: IFFALSE 77532
// begin MC_Reset ( i , 125 ) ;
77498: LD_VAR 0 2
77502: PPUSH
77503: LD_INT 125
77505: PPUSH
77506: CALL 60739 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77510: LD_ADDR_EXP 96
77514: PUSH
77515: LD_EXP 96
77519: PPUSH
77520: LD_VAR 0 2
77524: PPUSH
77525: EMPTY
77526: PPUSH
77527: CALL_OW 1
77531: ST_TO_ADDR
// end ; continue ;
77532: GO 77290
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
77534: LD_EXP 95
77538: PUSH
77539: LD_VAR 0 2
77543: ARRAY
77544: PUSH
77545: LD_INT 1
77547: ARRAY
77548: PUSH
77549: LD_INT 1
77551: ARRAY
77552: PPUSH
77553: LD_EXP 95
77557: PUSH
77558: LD_VAR 0 2
77562: ARRAY
77563: PUSH
77564: LD_INT 1
77566: ARRAY
77567: PUSH
77568: LD_INT 2
77570: ARRAY
77571: PPUSH
77572: LD_EXP 84
77576: PUSH
77577: LD_VAR 0 2
77581: ARRAY
77582: PPUSH
77583: CALL_OW 440
77587: IFFALSE 77630
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
77589: LD_ADDR_EXP 95
77593: PUSH
77594: LD_EXP 95
77598: PPUSH
77599: LD_VAR 0 2
77603: PPUSH
77604: LD_EXP 95
77608: PUSH
77609: LD_VAR 0 2
77613: ARRAY
77614: PPUSH
77615: LD_INT 1
77617: PPUSH
77618: CALL_OW 3
77622: PPUSH
77623: CALL_OW 1
77627: ST_TO_ADDR
77628: GO 77877
// begin if not mc_deposits_finder [ i ] then
77630: LD_EXP 96
77634: PUSH
77635: LD_VAR 0 2
77639: ARRAY
77640: NOT
77641: IFFALSE 77693
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
77643: LD_ADDR_EXP 96
77647: PUSH
77648: LD_EXP 96
77652: PPUSH
77653: LD_VAR 0 2
77657: PPUSH
77658: LD_VAR 0 3
77662: PUSH
77663: LD_INT 1
77665: ARRAY
77666: PUSH
77667: EMPTY
77668: LIST
77669: PPUSH
77670: CALL_OW 1
77674: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
77675: LD_VAR 0 3
77679: PUSH
77680: LD_INT 1
77682: ARRAY
77683: PPUSH
77684: LD_INT 125
77686: PPUSH
77687: CALL_OW 109
// end else
77691: GO 77877
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
77693: LD_EXP 96
77697: PUSH
77698: LD_VAR 0 2
77702: ARRAY
77703: PUSH
77704: LD_INT 1
77706: ARRAY
77707: PPUSH
77708: CALL_OW 310
77712: IFFALSE 77735
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
77714: LD_EXP 96
77718: PUSH
77719: LD_VAR 0 2
77723: ARRAY
77724: PUSH
77725: LD_INT 1
77727: ARRAY
77728: PPUSH
77729: CALL_OW 122
77733: GO 77877
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
77735: LD_EXP 96
77739: PUSH
77740: LD_VAR 0 2
77744: ARRAY
77745: PUSH
77746: LD_INT 1
77748: ARRAY
77749: PPUSH
77750: CALL_OW 314
77754: NOT
77755: PUSH
77756: LD_EXP 96
77760: PUSH
77761: LD_VAR 0 2
77765: ARRAY
77766: PUSH
77767: LD_INT 1
77769: ARRAY
77770: PPUSH
77771: LD_EXP 95
77775: PUSH
77776: LD_VAR 0 2
77780: ARRAY
77781: PUSH
77782: LD_INT 1
77784: ARRAY
77785: PUSH
77786: LD_INT 1
77788: ARRAY
77789: PPUSH
77790: LD_EXP 95
77794: PUSH
77795: LD_VAR 0 2
77799: ARRAY
77800: PUSH
77801: LD_INT 1
77803: ARRAY
77804: PUSH
77805: LD_INT 2
77807: ARRAY
77808: PPUSH
77809: CALL_OW 297
77813: PUSH
77814: LD_INT 6
77816: GREATER
77817: AND
77818: IFFALSE 77877
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
77820: LD_EXP 96
77824: PUSH
77825: LD_VAR 0 2
77829: ARRAY
77830: PUSH
77831: LD_INT 1
77833: ARRAY
77834: PPUSH
77835: LD_EXP 95
77839: PUSH
77840: LD_VAR 0 2
77844: ARRAY
77845: PUSH
77846: LD_INT 1
77848: ARRAY
77849: PUSH
77850: LD_INT 1
77852: ARRAY
77853: PPUSH
77854: LD_EXP 95
77858: PUSH
77859: LD_VAR 0 2
77863: ARRAY
77864: PUSH
77865: LD_INT 1
77867: ARRAY
77868: PUSH
77869: LD_INT 2
77871: ARRAY
77872: PPUSH
77873: CALL_OW 111
// end ; end ; end ;
77877: GO 77290
77879: POP
77880: POP
// end ;
77881: LD_VAR 0 1
77885: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
77886: LD_INT 0
77888: PPUSH
77889: PPUSH
77890: PPUSH
77891: PPUSH
77892: PPUSH
77893: PPUSH
77894: PPUSH
77895: PPUSH
77896: PPUSH
77897: PPUSH
77898: PPUSH
// if not mc_bases then
77899: LD_EXP 58
77903: NOT
77904: IFFALSE 77908
// exit ;
77906: GO 78632
// for i = 1 to mc_bases do
77908: LD_ADDR_VAR 0 2
77912: PUSH
77913: DOUBLE
77914: LD_INT 1
77916: DEC
77917: ST_TO_ADDR
77918: LD_EXP 58
77922: PUSH
77923: FOR_TO
77924: IFFALSE 78630
// begin if not mc_bases [ i ] then
77926: LD_EXP 58
77930: PUSH
77931: LD_VAR 0 2
77935: ARRAY
77936: NOT
77937: IFFALSE 77941
// continue ;
77939: GO 77923
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
77941: LD_ADDR_VAR 0 7
77945: PUSH
77946: LD_EXP 58
77950: PUSH
77951: LD_VAR 0 2
77955: ARRAY
77956: PUSH
77957: LD_INT 1
77959: ARRAY
77960: PPUSH
77961: CALL_OW 248
77965: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
77966: LD_VAR 0 7
77970: PUSH
77971: LD_INT 3
77973: EQUAL
77974: PUSH
77975: LD_EXP 77
77979: PUSH
77980: LD_VAR 0 2
77984: ARRAY
77985: PUSH
77986: LD_EXP 80
77990: PUSH
77991: LD_VAR 0 2
77995: ARRAY
77996: UNION
77997: PPUSH
77998: LD_INT 33
78000: PUSH
78001: LD_INT 2
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: PPUSH
78008: CALL_OW 72
78012: NOT
78013: OR
78014: IFFALSE 78018
// continue ;
78016: GO 77923
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78018: LD_ADDR_VAR 0 9
78022: PUSH
78023: LD_EXP 58
78027: PUSH
78028: LD_VAR 0 2
78032: ARRAY
78033: PPUSH
78034: LD_INT 30
78036: PUSH
78037: LD_INT 36
78039: PUSH
78040: EMPTY
78041: LIST
78042: LIST
78043: PPUSH
78044: CALL_OW 72
78048: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78049: LD_ADDR_VAR 0 10
78053: PUSH
78054: LD_EXP 77
78058: PUSH
78059: LD_VAR 0 2
78063: ARRAY
78064: PPUSH
78065: LD_INT 34
78067: PUSH
78068: LD_INT 31
78070: PUSH
78071: EMPTY
78072: LIST
78073: LIST
78074: PPUSH
78075: CALL_OW 72
78079: ST_TO_ADDR
// if not cts and not mcts then
78080: LD_VAR 0 9
78084: NOT
78085: PUSH
78086: LD_VAR 0 10
78090: NOT
78091: AND
78092: IFFALSE 78096
// continue ;
78094: GO 77923
// x := cts ;
78096: LD_ADDR_VAR 0 11
78100: PUSH
78101: LD_VAR 0 9
78105: ST_TO_ADDR
// if not x then
78106: LD_VAR 0 11
78110: NOT
78111: IFFALSE 78123
// x := mcts ;
78113: LD_ADDR_VAR 0 11
78117: PUSH
78118: LD_VAR 0 10
78122: ST_TO_ADDR
// if mc_remote_driver [ i ] then
78123: LD_EXP 98
78127: PUSH
78128: LD_VAR 0 2
78132: ARRAY
78133: IFFALSE 78402
// for j in mc_remote_driver [ i ] do
78135: LD_ADDR_VAR 0 3
78139: PUSH
78140: LD_EXP 98
78144: PUSH
78145: LD_VAR 0 2
78149: ARRAY
78150: PUSH
78151: FOR_IN
78152: IFFALSE 78400
// begin if GetClass ( j ) <> 3 then
78154: LD_VAR 0 3
78158: PPUSH
78159: CALL_OW 257
78163: PUSH
78164: LD_INT 3
78166: NONEQUAL
78167: IFFALSE 78220
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
78169: LD_ADDR_EXP 98
78173: PUSH
78174: LD_EXP 98
78178: PPUSH
78179: LD_VAR 0 2
78183: PPUSH
78184: LD_EXP 98
78188: PUSH
78189: LD_VAR 0 2
78193: ARRAY
78194: PUSH
78195: LD_VAR 0 3
78199: DIFF
78200: PPUSH
78201: CALL_OW 1
78205: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78206: LD_VAR 0 3
78210: PPUSH
78211: LD_INT 0
78213: PPUSH
78214: CALL_OW 109
// continue ;
78218: GO 78151
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
78220: LD_VAR 0 3
78224: PPUSH
78225: CALL_OW 310
78229: NOT
78230: PUSH
78231: LD_VAR 0 3
78235: PPUSH
78236: CALL_OW 310
78240: PPUSH
78241: CALL_OW 266
78245: PUSH
78246: LD_INT 36
78248: NONEQUAL
78249: PUSH
78250: LD_VAR 0 3
78254: PPUSH
78255: CALL 54169 0 1
78259: NOT
78260: AND
78261: OR
78262: IFFALSE 78398
// begin if IsInUnit ( j ) then
78264: LD_VAR 0 3
78268: PPUSH
78269: CALL_OW 310
78273: IFFALSE 78284
// ComExitBuilding ( j ) ;
78275: LD_VAR 0 3
78279: PPUSH
78280: CALL_OW 122
// ct := 0 ;
78284: LD_ADDR_VAR 0 8
78288: PUSH
78289: LD_INT 0
78291: ST_TO_ADDR
// for k in x do
78292: LD_ADDR_VAR 0 4
78296: PUSH
78297: LD_VAR 0 11
78301: PUSH
78302: FOR_IN
78303: IFFALSE 78376
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
78305: LD_VAR 0 4
78309: PPUSH
78310: CALL_OW 264
78314: PUSH
78315: LD_INT 31
78317: EQUAL
78318: PUSH
78319: LD_VAR 0 4
78323: PPUSH
78324: CALL_OW 311
78328: NOT
78329: AND
78330: PUSH
78331: LD_VAR 0 4
78335: PPUSH
78336: CALL_OW 266
78340: PUSH
78341: LD_INT 36
78343: EQUAL
78344: PUSH
78345: LD_VAR 0 4
78349: PPUSH
78350: CALL_OW 313
78354: PUSH
78355: LD_INT 3
78357: LESS
78358: AND
78359: OR
78360: IFFALSE 78374
// begin ct := k ;
78362: LD_ADDR_VAR 0 8
78366: PUSH
78367: LD_VAR 0 4
78371: ST_TO_ADDR
// break ;
78372: GO 78376
// end ;
78374: GO 78302
78376: POP
78377: POP
// if ct then
78378: LD_VAR 0 8
78382: IFFALSE 78398
// ComEnterUnit ( j , ct ) ;
78384: LD_VAR 0 3
78388: PPUSH
78389: LD_VAR 0 8
78393: PPUSH
78394: CALL_OW 120
// end ; end ;
78398: GO 78151
78400: POP
78401: POP
// places := 0 ;
78402: LD_ADDR_VAR 0 5
78406: PUSH
78407: LD_INT 0
78409: ST_TO_ADDR
// for j = 1 to x do
78410: LD_ADDR_VAR 0 3
78414: PUSH
78415: DOUBLE
78416: LD_INT 1
78418: DEC
78419: ST_TO_ADDR
78420: LD_VAR 0 11
78424: PUSH
78425: FOR_TO
78426: IFFALSE 78481
// if GetWeapon ( x [ j ] ) = ar_control_tower then
78428: LD_VAR 0 11
78432: PUSH
78433: LD_VAR 0 3
78437: ARRAY
78438: PPUSH
78439: CALL_OW 264
78443: PUSH
78444: LD_INT 31
78446: EQUAL
78447: IFFALSE 78465
// places := places + 1 else
78449: LD_ADDR_VAR 0 5
78453: PUSH
78454: LD_VAR 0 5
78458: PUSH
78459: LD_INT 1
78461: PLUS
78462: ST_TO_ADDR
78463: GO 78479
// places := places + 3 ;
78465: LD_ADDR_VAR 0 5
78469: PUSH
78470: LD_VAR 0 5
78474: PUSH
78475: LD_INT 3
78477: PLUS
78478: ST_TO_ADDR
78479: GO 78425
78481: POP
78482: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
78483: LD_ADDR_VAR 0 6
78487: PUSH
78488: LD_EXP 58
78492: PUSH
78493: LD_VAR 0 2
78497: ARRAY
78498: PPUSH
78499: LD_INT 25
78501: PUSH
78502: LD_INT 3
78504: PUSH
78505: EMPTY
78506: LIST
78507: LIST
78508: PPUSH
78509: CALL_OW 72
78513: PUSH
78514: LD_EXP 98
78518: PUSH
78519: LD_VAR 0 2
78523: ARRAY
78524: DIFF
78525: PPUSH
78526: LD_INT 3
78528: PPUSH
78529: CALL 55069 0 2
78533: ST_TO_ADDR
// if not tmp then
78534: LD_VAR 0 6
78538: NOT
78539: IFFALSE 78543
// continue ;
78541: GO 77923
// places := places - mc_remote_driver [ i ] ;
78543: LD_ADDR_VAR 0 5
78547: PUSH
78548: LD_VAR 0 5
78552: PUSH
78553: LD_EXP 98
78557: PUSH
78558: LD_VAR 0 2
78562: ARRAY
78563: MINUS
78564: ST_TO_ADDR
// if places then
78565: LD_VAR 0 5
78569: IFFALSE 78628
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
78571: LD_ADDR_EXP 98
78575: PUSH
78576: LD_EXP 98
78580: PPUSH
78581: LD_VAR 0 2
78585: PPUSH
78586: LD_EXP 98
78590: PUSH
78591: LD_VAR 0 2
78595: ARRAY
78596: PUSH
78597: LD_VAR 0 6
78601: PUSH
78602: LD_INT 1
78604: ARRAY
78605: UNION
78606: PPUSH
78607: CALL_OW 1
78611: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
78612: LD_VAR 0 6
78616: PUSH
78617: LD_INT 1
78619: ARRAY
78620: PPUSH
78621: LD_INT 126
78623: PPUSH
78624: CALL_OW 109
// end ; end ;
78628: GO 77923
78630: POP
78631: POP
// end ;
78632: LD_VAR 0 1
78636: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
78637: LD_INT 0
78639: PPUSH
78640: PPUSH
78641: PPUSH
78642: PPUSH
78643: PPUSH
78644: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
78645: LD_VAR 0 1
78649: NOT
78650: PUSH
78651: LD_VAR 0 2
78655: NOT
78656: OR
78657: PUSH
78658: LD_VAR 0 3
78662: NOT
78663: OR
78664: PUSH
78665: LD_VAR 0 4
78669: PUSH
78670: LD_INT 1
78672: PUSH
78673: LD_INT 2
78675: PUSH
78676: LD_INT 3
78678: PUSH
78679: LD_INT 4
78681: PUSH
78682: LD_INT 5
78684: PUSH
78685: LD_INT 8
78687: PUSH
78688: LD_INT 9
78690: PUSH
78691: LD_INT 15
78693: PUSH
78694: LD_INT 16
78696: PUSH
78697: EMPTY
78698: LIST
78699: LIST
78700: LIST
78701: LIST
78702: LIST
78703: LIST
78704: LIST
78705: LIST
78706: LIST
78707: IN
78708: NOT
78709: OR
78710: IFFALSE 78714
// exit ;
78712: GO 79614
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
78714: LD_ADDR_VAR 0 2
78718: PUSH
78719: LD_VAR 0 2
78723: PPUSH
78724: LD_INT 21
78726: PUSH
78727: LD_INT 3
78729: PUSH
78730: EMPTY
78731: LIST
78732: LIST
78733: PUSH
78734: LD_INT 24
78736: PUSH
78737: LD_INT 250
78739: PUSH
78740: EMPTY
78741: LIST
78742: LIST
78743: PUSH
78744: EMPTY
78745: LIST
78746: LIST
78747: PPUSH
78748: CALL_OW 72
78752: ST_TO_ADDR
// case class of 1 , 15 :
78753: LD_VAR 0 4
78757: PUSH
78758: LD_INT 1
78760: DOUBLE
78761: EQUAL
78762: IFTRUE 78772
78764: LD_INT 15
78766: DOUBLE
78767: EQUAL
78768: IFTRUE 78772
78770: GO 78857
78772: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
78773: LD_ADDR_VAR 0 8
78777: PUSH
78778: LD_VAR 0 2
78782: PPUSH
78783: LD_INT 2
78785: PUSH
78786: LD_INT 30
78788: PUSH
78789: LD_INT 32
78791: PUSH
78792: EMPTY
78793: LIST
78794: LIST
78795: PUSH
78796: LD_INT 30
78798: PUSH
78799: LD_INT 31
78801: PUSH
78802: EMPTY
78803: LIST
78804: LIST
78805: PUSH
78806: EMPTY
78807: LIST
78808: LIST
78809: LIST
78810: PPUSH
78811: CALL_OW 72
78815: PUSH
78816: LD_VAR 0 2
78820: PPUSH
78821: LD_INT 2
78823: PUSH
78824: LD_INT 30
78826: PUSH
78827: LD_INT 4
78829: PUSH
78830: EMPTY
78831: LIST
78832: LIST
78833: PUSH
78834: LD_INT 30
78836: PUSH
78837: LD_INT 5
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: LIST
78848: PPUSH
78849: CALL_OW 72
78853: ADD
78854: ST_TO_ADDR
78855: GO 79103
78857: LD_INT 2
78859: DOUBLE
78860: EQUAL
78861: IFTRUE 78871
78863: LD_INT 16
78865: DOUBLE
78866: EQUAL
78867: IFTRUE 78871
78869: GO 78917
78871: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
78872: LD_ADDR_VAR 0 8
78876: PUSH
78877: LD_VAR 0 2
78881: PPUSH
78882: LD_INT 2
78884: PUSH
78885: LD_INT 30
78887: PUSH
78888: LD_INT 0
78890: PUSH
78891: EMPTY
78892: LIST
78893: LIST
78894: PUSH
78895: LD_INT 30
78897: PUSH
78898: LD_INT 1
78900: PUSH
78901: EMPTY
78902: LIST
78903: LIST
78904: PUSH
78905: EMPTY
78906: LIST
78907: LIST
78908: LIST
78909: PPUSH
78910: CALL_OW 72
78914: ST_TO_ADDR
78915: GO 79103
78917: LD_INT 3
78919: DOUBLE
78920: EQUAL
78921: IFTRUE 78925
78923: GO 78971
78925: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
78926: LD_ADDR_VAR 0 8
78930: PUSH
78931: LD_VAR 0 2
78935: PPUSH
78936: LD_INT 2
78938: PUSH
78939: LD_INT 30
78941: PUSH
78942: LD_INT 2
78944: PUSH
78945: EMPTY
78946: LIST
78947: LIST
78948: PUSH
78949: LD_INT 30
78951: PUSH
78952: LD_INT 3
78954: PUSH
78955: EMPTY
78956: LIST
78957: LIST
78958: PUSH
78959: EMPTY
78960: LIST
78961: LIST
78962: LIST
78963: PPUSH
78964: CALL_OW 72
78968: ST_TO_ADDR
78969: GO 79103
78971: LD_INT 4
78973: DOUBLE
78974: EQUAL
78975: IFTRUE 78979
78977: GO 79036
78979: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
78980: LD_ADDR_VAR 0 8
78984: PUSH
78985: LD_VAR 0 2
78989: PPUSH
78990: LD_INT 2
78992: PUSH
78993: LD_INT 30
78995: PUSH
78996: LD_INT 6
78998: PUSH
78999: EMPTY
79000: LIST
79001: LIST
79002: PUSH
79003: LD_INT 30
79005: PUSH
79006: LD_INT 7
79008: PUSH
79009: EMPTY
79010: LIST
79011: LIST
79012: PUSH
79013: LD_INT 30
79015: PUSH
79016: LD_INT 8
79018: PUSH
79019: EMPTY
79020: LIST
79021: LIST
79022: PUSH
79023: EMPTY
79024: LIST
79025: LIST
79026: LIST
79027: LIST
79028: PPUSH
79029: CALL_OW 72
79033: ST_TO_ADDR
79034: GO 79103
79036: LD_INT 5
79038: DOUBLE
79039: EQUAL
79040: IFTRUE 79056
79042: LD_INT 8
79044: DOUBLE
79045: EQUAL
79046: IFTRUE 79056
79048: LD_INT 9
79050: DOUBLE
79051: EQUAL
79052: IFTRUE 79056
79054: GO 79102
79056: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
79057: LD_ADDR_VAR 0 8
79061: PUSH
79062: LD_VAR 0 2
79066: PPUSH
79067: LD_INT 2
79069: PUSH
79070: LD_INT 30
79072: PUSH
79073: LD_INT 4
79075: PUSH
79076: EMPTY
79077: LIST
79078: LIST
79079: PUSH
79080: LD_INT 30
79082: PUSH
79083: LD_INT 5
79085: PUSH
79086: EMPTY
79087: LIST
79088: LIST
79089: PUSH
79090: EMPTY
79091: LIST
79092: LIST
79093: LIST
79094: PPUSH
79095: CALL_OW 72
79099: ST_TO_ADDR
79100: GO 79103
79102: POP
// if not tmp then
79103: LD_VAR 0 8
79107: NOT
79108: IFFALSE 79112
// exit ;
79110: GO 79614
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
79112: LD_VAR 0 4
79116: PUSH
79117: LD_INT 1
79119: PUSH
79120: LD_INT 15
79122: PUSH
79123: EMPTY
79124: LIST
79125: LIST
79126: IN
79127: PUSH
79128: LD_EXP 67
79132: PUSH
79133: LD_VAR 0 1
79137: ARRAY
79138: AND
79139: IFFALSE 79295
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
79141: LD_ADDR_VAR 0 9
79145: PUSH
79146: LD_EXP 67
79150: PUSH
79151: LD_VAR 0 1
79155: ARRAY
79156: PUSH
79157: LD_INT 1
79159: ARRAY
79160: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
79161: LD_VAR 0 9
79165: PUSH
79166: LD_EXP 68
79170: PUSH
79171: LD_VAR 0 1
79175: ARRAY
79176: IN
79177: NOT
79178: IFFALSE 79293
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
79180: LD_ADDR_EXP 68
79184: PUSH
79185: LD_EXP 68
79189: PPUSH
79190: LD_VAR 0 1
79194: PUSH
79195: LD_EXP 68
79199: PUSH
79200: LD_VAR 0 1
79204: ARRAY
79205: PUSH
79206: LD_INT 1
79208: PLUS
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: PPUSH
79214: LD_VAR 0 9
79218: PPUSH
79219: CALL 20821 0 3
79223: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
79224: LD_ADDR_EXP 67
79228: PUSH
79229: LD_EXP 67
79233: PPUSH
79234: LD_VAR 0 1
79238: PPUSH
79239: LD_EXP 67
79243: PUSH
79244: LD_VAR 0 1
79248: ARRAY
79249: PUSH
79250: LD_VAR 0 9
79254: DIFF
79255: PPUSH
79256: CALL_OW 1
79260: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
79261: LD_VAR 0 3
79265: PPUSH
79266: LD_EXP 68
79270: PUSH
79271: LD_VAR 0 1
79275: ARRAY
79276: PUSH
79277: LD_EXP 68
79281: PUSH
79282: LD_VAR 0 1
79286: ARRAY
79287: ARRAY
79288: PPUSH
79289: CALL_OW 120
// end ; exit ;
79293: GO 79614
// end ; if tmp > 1 then
79295: LD_VAR 0 8
79299: PUSH
79300: LD_INT 1
79302: GREATER
79303: IFFALSE 79407
// for i = 2 to tmp do
79305: LD_ADDR_VAR 0 6
79309: PUSH
79310: DOUBLE
79311: LD_INT 2
79313: DEC
79314: ST_TO_ADDR
79315: LD_VAR 0 8
79319: PUSH
79320: FOR_TO
79321: IFFALSE 79405
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
79323: LD_VAR 0 8
79327: PUSH
79328: LD_VAR 0 6
79332: ARRAY
79333: PPUSH
79334: CALL_OW 461
79338: PUSH
79339: LD_INT 6
79341: EQUAL
79342: IFFALSE 79403
// begin x := tmp [ i ] ;
79344: LD_ADDR_VAR 0 9
79348: PUSH
79349: LD_VAR 0 8
79353: PUSH
79354: LD_VAR 0 6
79358: ARRAY
79359: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
79360: LD_ADDR_VAR 0 8
79364: PUSH
79365: LD_VAR 0 8
79369: PPUSH
79370: LD_VAR 0 6
79374: PPUSH
79375: CALL_OW 3
79379: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
79380: LD_ADDR_VAR 0 8
79384: PUSH
79385: LD_VAR 0 8
79389: PPUSH
79390: LD_INT 1
79392: PPUSH
79393: LD_VAR 0 9
79397: PPUSH
79398: CALL_OW 2
79402: ST_TO_ADDR
// end ;
79403: GO 79320
79405: POP
79406: POP
// for i in tmp do
79407: LD_ADDR_VAR 0 6
79411: PUSH
79412: LD_VAR 0 8
79416: PUSH
79417: FOR_IN
79418: IFFALSE 79487
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
79420: LD_VAR 0 6
79424: PPUSH
79425: CALL_OW 313
79429: PUSH
79430: LD_INT 6
79432: LESS
79433: PUSH
79434: LD_VAR 0 6
79438: PPUSH
79439: CALL_OW 266
79443: PUSH
79444: LD_INT 31
79446: PUSH
79447: LD_INT 32
79449: PUSH
79450: EMPTY
79451: LIST
79452: LIST
79453: IN
79454: NOT
79455: AND
79456: PUSH
79457: LD_VAR 0 6
79461: PPUSH
79462: CALL_OW 313
79466: PUSH
79467: LD_INT 0
79469: EQUAL
79470: OR
79471: IFFALSE 79485
// begin j := i ;
79473: LD_ADDR_VAR 0 7
79477: PUSH
79478: LD_VAR 0 6
79482: ST_TO_ADDR
// break ;
79483: GO 79487
// end ; end ;
79485: GO 79417
79487: POP
79488: POP
// if j then
79489: LD_VAR 0 7
79493: IFFALSE 79511
// ComEnterUnit ( unit , j ) else
79495: LD_VAR 0 3
79499: PPUSH
79500: LD_VAR 0 7
79504: PPUSH
79505: CALL_OW 120
79509: GO 79614
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79511: LD_ADDR_VAR 0 10
79515: PUSH
79516: LD_VAR 0 2
79520: PPUSH
79521: LD_INT 2
79523: PUSH
79524: LD_INT 30
79526: PUSH
79527: LD_INT 0
79529: PUSH
79530: EMPTY
79531: LIST
79532: LIST
79533: PUSH
79534: LD_INT 30
79536: PUSH
79537: LD_INT 1
79539: PUSH
79540: EMPTY
79541: LIST
79542: LIST
79543: PUSH
79544: EMPTY
79545: LIST
79546: LIST
79547: LIST
79548: PPUSH
79549: CALL_OW 72
79553: ST_TO_ADDR
// if depot then
79554: LD_VAR 0 10
79558: IFFALSE 79614
// begin depot := NearestUnitToUnit ( depot , unit ) ;
79560: LD_ADDR_VAR 0 10
79564: PUSH
79565: LD_VAR 0 10
79569: PPUSH
79570: LD_VAR 0 3
79574: PPUSH
79575: CALL_OW 74
79579: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
79580: LD_VAR 0 3
79584: PPUSH
79585: LD_VAR 0 10
79589: PPUSH
79590: CALL_OW 296
79594: PUSH
79595: LD_INT 10
79597: GREATER
79598: IFFALSE 79614
// ComStandNearbyBuilding ( unit , depot ) ;
79600: LD_VAR 0 3
79604: PPUSH
79605: LD_VAR 0 10
79609: PPUSH
79610: CALL 15388 0 2
// end ; end ; end ;
79614: LD_VAR 0 5
79618: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
79619: LD_INT 0
79621: PPUSH
79622: PPUSH
79623: PPUSH
79624: PPUSH
// if not mc_bases then
79625: LD_EXP 58
79629: NOT
79630: IFFALSE 79634
// exit ;
79632: GO 79873
// for i = 1 to mc_bases do
79634: LD_ADDR_VAR 0 2
79638: PUSH
79639: DOUBLE
79640: LD_INT 1
79642: DEC
79643: ST_TO_ADDR
79644: LD_EXP 58
79648: PUSH
79649: FOR_TO
79650: IFFALSE 79871
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
79652: LD_ADDR_VAR 0 4
79656: PUSH
79657: LD_EXP 58
79661: PUSH
79662: LD_VAR 0 2
79666: ARRAY
79667: PPUSH
79668: LD_INT 21
79670: PUSH
79671: LD_INT 1
79673: PUSH
79674: EMPTY
79675: LIST
79676: LIST
79677: PPUSH
79678: CALL_OW 72
79682: PUSH
79683: LD_EXP 87
79687: PUSH
79688: LD_VAR 0 2
79692: ARRAY
79693: UNION
79694: ST_TO_ADDR
// if not tmp then
79695: LD_VAR 0 4
79699: NOT
79700: IFFALSE 79704
// continue ;
79702: GO 79649
// for j in tmp do
79704: LD_ADDR_VAR 0 3
79708: PUSH
79709: LD_VAR 0 4
79713: PUSH
79714: FOR_IN
79715: IFFALSE 79867
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
79717: LD_VAR 0 3
79721: PPUSH
79722: CALL_OW 110
79726: NOT
79727: PUSH
79728: LD_VAR 0 3
79732: PPUSH
79733: CALL_OW 314
79737: NOT
79738: AND
79739: PUSH
79740: LD_VAR 0 3
79744: PPUSH
79745: CALL_OW 311
79749: NOT
79750: AND
79751: PUSH
79752: LD_VAR 0 3
79756: PPUSH
79757: CALL_OW 310
79761: NOT
79762: AND
79763: PUSH
79764: LD_VAR 0 3
79768: PUSH
79769: LD_EXP 61
79773: PUSH
79774: LD_VAR 0 2
79778: ARRAY
79779: PUSH
79780: LD_INT 1
79782: ARRAY
79783: IN
79784: NOT
79785: AND
79786: PUSH
79787: LD_VAR 0 3
79791: PUSH
79792: LD_EXP 61
79796: PUSH
79797: LD_VAR 0 2
79801: ARRAY
79802: PUSH
79803: LD_INT 2
79805: ARRAY
79806: IN
79807: NOT
79808: AND
79809: PUSH
79810: LD_VAR 0 3
79814: PUSH
79815: LD_EXP 70
79819: PUSH
79820: LD_VAR 0 2
79824: ARRAY
79825: IN
79826: NOT
79827: AND
79828: IFFALSE 79865
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
79830: LD_VAR 0 2
79834: PPUSH
79835: LD_EXP 58
79839: PUSH
79840: LD_VAR 0 2
79844: ARRAY
79845: PPUSH
79846: LD_VAR 0 3
79850: PPUSH
79851: LD_VAR 0 3
79855: PPUSH
79856: CALL_OW 257
79860: PPUSH
79861: CALL 78637 0 4
// end ;
79865: GO 79714
79867: POP
79868: POP
// end ;
79869: GO 79649
79871: POP
79872: POP
// end ;
79873: LD_VAR 0 1
79877: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
79878: LD_INT 0
79880: PPUSH
79881: PPUSH
79882: PPUSH
79883: PPUSH
79884: PPUSH
79885: PPUSH
// if not mc_bases [ base ] then
79886: LD_EXP 58
79890: PUSH
79891: LD_VAR 0 1
79895: ARRAY
79896: NOT
79897: IFFALSE 79901
// exit ;
79899: GO 80083
// tmp := [ ] ;
79901: LD_ADDR_VAR 0 6
79905: PUSH
79906: EMPTY
79907: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
79908: LD_ADDR_VAR 0 7
79912: PUSH
79913: LD_VAR 0 3
79917: PPUSH
79918: LD_INT 0
79920: PPUSH
79921: CALL_OW 517
79925: ST_TO_ADDR
// if not list then
79926: LD_VAR 0 7
79930: NOT
79931: IFFALSE 79935
// exit ;
79933: GO 80083
// for i = 1 to amount do
79935: LD_ADDR_VAR 0 5
79939: PUSH
79940: DOUBLE
79941: LD_INT 1
79943: DEC
79944: ST_TO_ADDR
79945: LD_VAR 0 2
79949: PUSH
79950: FOR_TO
79951: IFFALSE 80031
// begin x := rand ( 1 , list [ 1 ] ) ;
79953: LD_ADDR_VAR 0 8
79957: PUSH
79958: LD_INT 1
79960: PPUSH
79961: LD_VAR 0 7
79965: PUSH
79966: LD_INT 1
79968: ARRAY
79969: PPUSH
79970: CALL_OW 12
79974: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
79975: LD_ADDR_VAR 0 6
79979: PUSH
79980: LD_VAR 0 6
79984: PPUSH
79985: LD_VAR 0 5
79989: PPUSH
79990: LD_VAR 0 7
79994: PUSH
79995: LD_INT 1
79997: ARRAY
79998: PUSH
79999: LD_VAR 0 8
80003: ARRAY
80004: PUSH
80005: LD_VAR 0 7
80009: PUSH
80010: LD_INT 2
80012: ARRAY
80013: PUSH
80014: LD_VAR 0 8
80018: ARRAY
80019: PUSH
80020: EMPTY
80021: LIST
80022: LIST
80023: PPUSH
80024: CALL_OW 1
80028: ST_TO_ADDR
// end ;
80029: GO 79950
80031: POP
80032: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
80033: LD_ADDR_EXP 71
80037: PUSH
80038: LD_EXP 71
80042: PPUSH
80043: LD_VAR 0 1
80047: PPUSH
80048: LD_VAR 0 6
80052: PPUSH
80053: CALL_OW 1
80057: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
80058: LD_ADDR_EXP 73
80062: PUSH
80063: LD_EXP 73
80067: PPUSH
80068: LD_VAR 0 1
80072: PPUSH
80073: LD_VAR 0 3
80077: PPUSH
80078: CALL_OW 1
80082: ST_TO_ADDR
// end ;
80083: LD_VAR 0 4
80087: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
80088: LD_INT 0
80090: PPUSH
// if not mc_bases [ base ] then
80091: LD_EXP 58
80095: PUSH
80096: LD_VAR 0 1
80100: ARRAY
80101: NOT
80102: IFFALSE 80106
// exit ;
80104: GO 80131
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
80106: LD_ADDR_EXP 63
80110: PUSH
80111: LD_EXP 63
80115: PPUSH
80116: LD_VAR 0 1
80120: PPUSH
80121: LD_VAR 0 2
80125: PPUSH
80126: CALL_OW 1
80130: ST_TO_ADDR
// end ;
80131: LD_VAR 0 3
80135: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
80136: LD_INT 0
80138: PPUSH
// if not mc_bases [ base ] then
80139: LD_EXP 58
80143: PUSH
80144: LD_VAR 0 1
80148: ARRAY
80149: NOT
80150: IFFALSE 80154
// exit ;
80152: GO 80191
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
80154: LD_ADDR_EXP 63
80158: PUSH
80159: LD_EXP 63
80163: PPUSH
80164: LD_VAR 0 1
80168: PPUSH
80169: LD_EXP 63
80173: PUSH
80174: LD_VAR 0 1
80178: ARRAY
80179: PUSH
80180: LD_VAR 0 2
80184: UNION
80185: PPUSH
80186: CALL_OW 1
80190: ST_TO_ADDR
// end ;
80191: LD_VAR 0 3
80195: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
80196: LD_INT 0
80198: PPUSH
// if not mc_bases [ base ] then
80199: LD_EXP 58
80203: PUSH
80204: LD_VAR 0 1
80208: ARRAY
80209: NOT
80210: IFFALSE 80214
// exit ;
80212: GO 80239
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
80214: LD_ADDR_EXP 79
80218: PUSH
80219: LD_EXP 79
80223: PPUSH
80224: LD_VAR 0 1
80228: PPUSH
80229: LD_VAR 0 2
80233: PPUSH
80234: CALL_OW 1
80238: ST_TO_ADDR
// end ;
80239: LD_VAR 0 3
80243: RET
// export function MC_InsertProduceList ( base , components ) ; begin
80244: LD_INT 0
80246: PPUSH
// if not mc_bases [ base ] then
80247: LD_EXP 58
80251: PUSH
80252: LD_VAR 0 1
80256: ARRAY
80257: NOT
80258: IFFALSE 80262
// exit ;
80260: GO 80299
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
80262: LD_ADDR_EXP 79
80266: PUSH
80267: LD_EXP 79
80271: PPUSH
80272: LD_VAR 0 1
80276: PPUSH
80277: LD_EXP 79
80281: PUSH
80282: LD_VAR 0 1
80286: ARRAY
80287: PUSH
80288: LD_VAR 0 2
80292: ADD
80293: PPUSH
80294: CALL_OW 1
80298: ST_TO_ADDR
// end ;
80299: LD_VAR 0 3
80303: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
80304: LD_INT 0
80306: PPUSH
// if not mc_bases [ base ] then
80307: LD_EXP 58
80311: PUSH
80312: LD_VAR 0 1
80316: ARRAY
80317: NOT
80318: IFFALSE 80322
// exit ;
80320: GO 80376
// mc_defender := Replace ( mc_defender , base , deflist ) ;
80322: LD_ADDR_EXP 80
80326: PUSH
80327: LD_EXP 80
80331: PPUSH
80332: LD_VAR 0 1
80336: PPUSH
80337: LD_VAR 0 2
80341: PPUSH
80342: CALL_OW 1
80346: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
80347: LD_ADDR_EXP 69
80351: PUSH
80352: LD_EXP 69
80356: PPUSH
80357: LD_VAR 0 1
80361: PPUSH
80362: LD_VAR 0 2
80366: PUSH
80367: LD_INT 0
80369: PLUS
80370: PPUSH
80371: CALL_OW 1
80375: ST_TO_ADDR
// end ;
80376: LD_VAR 0 3
80380: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
80381: LD_INT 0
80383: PPUSH
// if not mc_bases [ base ] then
80384: LD_EXP 58
80388: PUSH
80389: LD_VAR 0 1
80393: ARRAY
80394: NOT
80395: IFFALSE 80399
// exit ;
80397: GO 80424
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
80399: LD_ADDR_EXP 69
80403: PUSH
80404: LD_EXP 69
80408: PPUSH
80409: LD_VAR 0 1
80413: PPUSH
80414: LD_VAR 0 2
80418: PPUSH
80419: CALL_OW 1
80423: ST_TO_ADDR
// end ;
80424: LD_VAR 0 3
80428: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
80429: LD_INT 0
80431: PPUSH
80432: PPUSH
80433: PPUSH
80434: PPUSH
// if not mc_bases [ base ] then
80435: LD_EXP 58
80439: PUSH
80440: LD_VAR 0 1
80444: ARRAY
80445: NOT
80446: IFFALSE 80450
// exit ;
80448: GO 80515
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
80450: LD_ADDR_EXP 78
80454: PUSH
80455: LD_EXP 78
80459: PPUSH
80460: LD_VAR 0 1
80464: PUSH
80465: LD_EXP 78
80469: PUSH
80470: LD_VAR 0 1
80474: ARRAY
80475: PUSH
80476: LD_INT 1
80478: PLUS
80479: PUSH
80480: EMPTY
80481: LIST
80482: LIST
80483: PPUSH
80484: LD_VAR 0 1
80488: PUSH
80489: LD_VAR 0 2
80493: PUSH
80494: LD_VAR 0 3
80498: PUSH
80499: LD_VAR 0 4
80503: PUSH
80504: EMPTY
80505: LIST
80506: LIST
80507: LIST
80508: LIST
80509: PPUSH
80510: CALL 20821 0 3
80514: ST_TO_ADDR
// end ;
80515: LD_VAR 0 5
80519: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
80520: LD_INT 0
80522: PPUSH
// if not mc_bases [ base ] then
80523: LD_EXP 58
80527: PUSH
80528: LD_VAR 0 1
80532: ARRAY
80533: NOT
80534: IFFALSE 80538
// exit ;
80536: GO 80563
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
80538: LD_ADDR_EXP 95
80542: PUSH
80543: LD_EXP 95
80547: PPUSH
80548: LD_VAR 0 1
80552: PPUSH
80553: LD_VAR 0 2
80557: PPUSH
80558: CALL_OW 1
80562: ST_TO_ADDR
// end ;
80563: LD_VAR 0 3
80567: RET
// export function MC_GetMinesField ( base ) ; begin
80568: LD_INT 0
80570: PPUSH
// result := mc_mines [ base ] ;
80571: LD_ADDR_VAR 0 2
80575: PUSH
80576: LD_EXP 71
80580: PUSH
80581: LD_VAR 0 1
80585: ARRAY
80586: ST_TO_ADDR
// end ;
80587: LD_VAR 0 2
80591: RET
// export function MC_GetProduceList ( base ) ; begin
80592: LD_INT 0
80594: PPUSH
// result := mc_produce [ base ] ;
80595: LD_ADDR_VAR 0 2
80599: PUSH
80600: LD_EXP 79
80604: PUSH
80605: LD_VAR 0 1
80609: ARRAY
80610: ST_TO_ADDR
// end ;
80611: LD_VAR 0 2
80615: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
80616: LD_INT 0
80618: PPUSH
80619: PPUSH
// if not mc_bases then
80620: LD_EXP 58
80624: NOT
80625: IFFALSE 80629
// exit ;
80627: GO 80694
// if mc_bases [ base ] then
80629: LD_EXP 58
80633: PUSH
80634: LD_VAR 0 1
80638: ARRAY
80639: IFFALSE 80694
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80641: LD_ADDR_VAR 0 3
80645: PUSH
80646: LD_EXP 58
80650: PUSH
80651: LD_VAR 0 1
80655: ARRAY
80656: PPUSH
80657: LD_INT 30
80659: PUSH
80660: LD_VAR 0 2
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: PPUSH
80669: CALL_OW 72
80673: ST_TO_ADDR
// if result then
80674: LD_VAR 0 3
80678: IFFALSE 80694
// result := result [ 1 ] ;
80680: LD_ADDR_VAR 0 3
80684: PUSH
80685: LD_VAR 0 3
80689: PUSH
80690: LD_INT 1
80692: ARRAY
80693: ST_TO_ADDR
// end ; end ;
80694: LD_VAR 0 3
80698: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
80699: LD_INT 0
80701: PPUSH
80702: PPUSH
// if not mc_bases then
80703: LD_EXP 58
80707: NOT
80708: IFFALSE 80712
// exit ;
80710: GO 80757
// if mc_bases [ base ] then
80712: LD_EXP 58
80716: PUSH
80717: LD_VAR 0 1
80721: ARRAY
80722: IFFALSE 80757
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80724: LD_ADDR_VAR 0 3
80728: PUSH
80729: LD_EXP 58
80733: PUSH
80734: LD_VAR 0 1
80738: ARRAY
80739: PPUSH
80740: LD_INT 30
80742: PUSH
80743: LD_VAR 0 2
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: PPUSH
80752: CALL_OW 72
80756: ST_TO_ADDR
// end ;
80757: LD_VAR 0 3
80761: RET
// export function MC_SetTame ( base , area ) ; begin
80762: LD_INT 0
80764: PPUSH
// if not mc_bases or not base then
80765: LD_EXP 58
80769: NOT
80770: PUSH
80771: LD_VAR 0 1
80775: NOT
80776: OR
80777: IFFALSE 80781
// exit ;
80779: GO 80806
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
80781: LD_ADDR_EXP 86
80785: PUSH
80786: LD_EXP 86
80790: PPUSH
80791: LD_VAR 0 1
80795: PPUSH
80796: LD_VAR 0 2
80800: PPUSH
80801: CALL_OW 1
80805: ST_TO_ADDR
// end ;
80806: LD_VAR 0 3
80810: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
80811: LD_INT 0
80813: PPUSH
80814: PPUSH
// if not mc_bases or not base then
80815: LD_EXP 58
80819: NOT
80820: PUSH
80821: LD_VAR 0 1
80825: NOT
80826: OR
80827: IFFALSE 80831
// exit ;
80829: GO 80933
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80831: LD_ADDR_VAR 0 4
80835: PUSH
80836: LD_EXP 58
80840: PUSH
80841: LD_VAR 0 1
80845: ARRAY
80846: PPUSH
80847: LD_INT 30
80849: PUSH
80850: LD_VAR 0 2
80854: PUSH
80855: EMPTY
80856: LIST
80857: LIST
80858: PPUSH
80859: CALL_OW 72
80863: ST_TO_ADDR
// if not tmp then
80864: LD_VAR 0 4
80868: NOT
80869: IFFALSE 80873
// exit ;
80871: GO 80933
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
80873: LD_ADDR_EXP 90
80877: PUSH
80878: LD_EXP 90
80882: PPUSH
80883: LD_VAR 0 1
80887: PPUSH
80888: LD_EXP 90
80892: PUSH
80893: LD_VAR 0 1
80897: ARRAY
80898: PPUSH
80899: LD_EXP 90
80903: PUSH
80904: LD_VAR 0 1
80908: ARRAY
80909: PUSH
80910: LD_INT 1
80912: PLUS
80913: PPUSH
80914: LD_VAR 0 4
80918: PUSH
80919: LD_INT 1
80921: ARRAY
80922: PPUSH
80923: CALL_OW 2
80927: PPUSH
80928: CALL_OW 1
80932: ST_TO_ADDR
// end ;
80933: LD_VAR 0 3
80937: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
80938: LD_INT 0
80940: PPUSH
80941: PPUSH
// if not mc_bases or not base or not kinds then
80942: LD_EXP 58
80946: NOT
80947: PUSH
80948: LD_VAR 0 1
80952: NOT
80953: OR
80954: PUSH
80955: LD_VAR 0 2
80959: NOT
80960: OR
80961: IFFALSE 80965
// exit ;
80963: GO 81026
// for i in kinds do
80965: LD_ADDR_VAR 0 4
80969: PUSH
80970: LD_VAR 0 2
80974: PUSH
80975: FOR_IN
80976: IFFALSE 81024
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
80978: LD_ADDR_EXP 92
80982: PUSH
80983: LD_EXP 92
80987: PPUSH
80988: LD_VAR 0 1
80992: PUSH
80993: LD_EXP 92
80997: PUSH
80998: LD_VAR 0 1
81002: ARRAY
81003: PUSH
81004: LD_INT 1
81006: PLUS
81007: PUSH
81008: EMPTY
81009: LIST
81010: LIST
81011: PPUSH
81012: LD_VAR 0 4
81016: PPUSH
81017: CALL 20821 0 3
81021: ST_TO_ADDR
81022: GO 80975
81024: POP
81025: POP
// end ;
81026: LD_VAR 0 3
81030: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
81031: LD_INT 0
81033: PPUSH
// if not mc_bases or not base or not areas then
81034: LD_EXP 58
81038: NOT
81039: PUSH
81040: LD_VAR 0 1
81044: NOT
81045: OR
81046: PUSH
81047: LD_VAR 0 2
81051: NOT
81052: OR
81053: IFFALSE 81057
// exit ;
81055: GO 81082
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
81057: LD_ADDR_EXP 76
81061: PUSH
81062: LD_EXP 76
81066: PPUSH
81067: LD_VAR 0 1
81071: PPUSH
81072: LD_VAR 0 2
81076: PPUSH
81077: CALL_OW 1
81081: ST_TO_ADDR
// end ;
81082: LD_VAR 0 3
81086: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
81087: LD_INT 0
81089: PPUSH
// if not mc_bases or not base or not teleports_exit then
81090: LD_EXP 58
81094: NOT
81095: PUSH
81096: LD_VAR 0 1
81100: NOT
81101: OR
81102: PUSH
81103: LD_VAR 0 2
81107: NOT
81108: OR
81109: IFFALSE 81113
// exit ;
81111: GO 81138
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
81113: LD_ADDR_EXP 93
81117: PUSH
81118: LD_EXP 93
81122: PPUSH
81123: LD_VAR 0 1
81127: PPUSH
81128: LD_VAR 0 2
81132: PPUSH
81133: CALL_OW 1
81137: ST_TO_ADDR
// end ;
81138: LD_VAR 0 3
81142: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
81143: LD_INT 0
81145: PPUSH
81146: PPUSH
81147: PPUSH
// if not mc_bases or not base or not ext_list then
81148: LD_EXP 58
81152: NOT
81153: PUSH
81154: LD_VAR 0 1
81158: NOT
81159: OR
81160: PUSH
81161: LD_VAR 0 5
81165: NOT
81166: OR
81167: IFFALSE 81171
// exit ;
81169: GO 81344
// tmp := GetFacExtXYD ( x , y , d ) ;
81171: LD_ADDR_VAR 0 8
81175: PUSH
81176: LD_VAR 0 2
81180: PPUSH
81181: LD_VAR 0 3
81185: PPUSH
81186: LD_VAR 0 4
81190: PPUSH
81191: CALL 54199 0 3
81195: ST_TO_ADDR
// if not tmp then
81196: LD_VAR 0 8
81200: NOT
81201: IFFALSE 81205
// exit ;
81203: GO 81344
// for i in tmp do
81205: LD_ADDR_VAR 0 7
81209: PUSH
81210: LD_VAR 0 8
81214: PUSH
81215: FOR_IN
81216: IFFALSE 81342
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
81218: LD_ADDR_EXP 63
81222: PUSH
81223: LD_EXP 63
81227: PPUSH
81228: LD_VAR 0 1
81232: PPUSH
81233: LD_EXP 63
81237: PUSH
81238: LD_VAR 0 1
81242: ARRAY
81243: PPUSH
81244: LD_EXP 63
81248: PUSH
81249: LD_VAR 0 1
81253: ARRAY
81254: PUSH
81255: LD_INT 1
81257: PLUS
81258: PPUSH
81259: LD_VAR 0 5
81263: PUSH
81264: LD_INT 1
81266: ARRAY
81267: PUSH
81268: LD_VAR 0 7
81272: PUSH
81273: LD_INT 1
81275: ARRAY
81276: PUSH
81277: LD_VAR 0 7
81281: PUSH
81282: LD_INT 2
81284: ARRAY
81285: PUSH
81286: LD_VAR 0 7
81290: PUSH
81291: LD_INT 3
81293: ARRAY
81294: PUSH
81295: EMPTY
81296: LIST
81297: LIST
81298: LIST
81299: LIST
81300: PPUSH
81301: CALL_OW 2
81305: PPUSH
81306: CALL_OW 1
81310: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
81311: LD_ADDR_VAR 0 5
81315: PUSH
81316: LD_VAR 0 5
81320: PPUSH
81321: LD_INT 1
81323: PPUSH
81324: CALL_OW 3
81328: ST_TO_ADDR
// if not ext_list then
81329: LD_VAR 0 5
81333: NOT
81334: IFFALSE 81340
// exit ;
81336: POP
81337: POP
81338: GO 81344
// end ;
81340: GO 81215
81342: POP
81343: POP
// end ;
81344: LD_VAR 0 6
81348: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
81349: LD_INT 0
81351: PPUSH
// if not mc_bases or not base or not weapon_list then
81352: LD_EXP 58
81356: NOT
81357: PUSH
81358: LD_VAR 0 1
81362: NOT
81363: OR
81364: PUSH
81365: LD_VAR 0 2
81369: NOT
81370: OR
81371: IFFALSE 81375
// exit ;
81373: GO 81400
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
81375: LD_ADDR_EXP 97
81379: PUSH
81380: LD_EXP 97
81384: PPUSH
81385: LD_VAR 0 1
81389: PPUSH
81390: LD_VAR 0 2
81394: PPUSH
81395: CALL_OW 1
81399: ST_TO_ADDR
// end ;
81400: LD_VAR 0 3
81404: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
81405: LD_INT 0
81407: PPUSH
// if not mc_bases or not base or not tech_list then
81408: LD_EXP 58
81412: NOT
81413: PUSH
81414: LD_VAR 0 1
81418: NOT
81419: OR
81420: PUSH
81421: LD_VAR 0 2
81425: NOT
81426: OR
81427: IFFALSE 81431
// exit ;
81429: GO 81456
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
81431: LD_ADDR_EXP 85
81435: PUSH
81436: LD_EXP 85
81440: PPUSH
81441: LD_VAR 0 1
81445: PPUSH
81446: LD_VAR 0 2
81450: PPUSH
81451: CALL_OW 1
81455: ST_TO_ADDR
// end ;
81456: LD_VAR 0 3
81460: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
81461: LD_INT 0
81463: PPUSH
// if not mc_bases or not parking_area or not base then
81464: LD_EXP 58
81468: NOT
81469: PUSH
81470: LD_VAR 0 2
81474: NOT
81475: OR
81476: PUSH
81477: LD_VAR 0 1
81481: NOT
81482: OR
81483: IFFALSE 81487
// exit ;
81485: GO 81512
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
81487: LD_ADDR_EXP 82
81491: PUSH
81492: LD_EXP 82
81496: PPUSH
81497: LD_VAR 0 1
81501: PPUSH
81502: LD_VAR 0 2
81506: PPUSH
81507: CALL_OW 1
81511: ST_TO_ADDR
// end ;
81512: LD_VAR 0 3
81516: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
81517: LD_INT 0
81519: PPUSH
// if not mc_bases or not base or not scan_area then
81520: LD_EXP 58
81524: NOT
81525: PUSH
81526: LD_VAR 0 1
81530: NOT
81531: OR
81532: PUSH
81533: LD_VAR 0 2
81537: NOT
81538: OR
81539: IFFALSE 81543
// exit ;
81541: GO 81568
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
81543: LD_ADDR_EXP 83
81547: PUSH
81548: LD_EXP 83
81552: PPUSH
81553: LD_VAR 0 1
81557: PPUSH
81558: LD_VAR 0 2
81562: PPUSH
81563: CALL_OW 1
81567: ST_TO_ADDR
// end ;
81568: LD_VAR 0 3
81572: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
81573: LD_INT 0
81575: PPUSH
81576: PPUSH
// if not mc_bases or not base then
81577: LD_EXP 58
81581: NOT
81582: PUSH
81583: LD_VAR 0 1
81587: NOT
81588: OR
81589: IFFALSE 81593
// exit ;
81591: GO 81657
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
81593: LD_ADDR_VAR 0 3
81597: PUSH
81598: LD_INT 1
81600: PUSH
81601: LD_INT 2
81603: PUSH
81604: LD_INT 3
81606: PUSH
81607: LD_INT 4
81609: PUSH
81610: LD_INT 11
81612: PUSH
81613: EMPTY
81614: LIST
81615: LIST
81616: LIST
81617: LIST
81618: LIST
81619: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
81620: LD_ADDR_EXP 85
81624: PUSH
81625: LD_EXP 85
81629: PPUSH
81630: LD_VAR 0 1
81634: PPUSH
81635: LD_EXP 85
81639: PUSH
81640: LD_VAR 0 1
81644: ARRAY
81645: PUSH
81646: LD_VAR 0 3
81650: DIFF
81651: PPUSH
81652: CALL_OW 1
81656: ST_TO_ADDR
// end ;
81657: LD_VAR 0 2
81661: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
81662: LD_INT 0
81664: PPUSH
// result := mc_vehicles [ base ] ;
81665: LD_ADDR_VAR 0 3
81669: PUSH
81670: LD_EXP 77
81674: PUSH
81675: LD_VAR 0 1
81679: ARRAY
81680: ST_TO_ADDR
// if onlyCombat then
81681: LD_VAR 0 2
81685: IFFALSE 81850
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
81687: LD_ADDR_VAR 0 3
81691: PUSH
81692: LD_VAR 0 3
81696: PUSH
81697: LD_VAR 0 3
81701: PPUSH
81702: LD_INT 2
81704: PUSH
81705: LD_INT 34
81707: PUSH
81708: LD_INT 12
81710: PUSH
81711: EMPTY
81712: LIST
81713: LIST
81714: PUSH
81715: LD_INT 34
81717: PUSH
81718: LD_INT 51
81720: PUSH
81721: EMPTY
81722: LIST
81723: LIST
81724: PUSH
81725: LD_INT 34
81727: PUSH
81728: LD_EXP 102
81732: PUSH
81733: EMPTY
81734: LIST
81735: LIST
81736: PUSH
81737: LD_INT 34
81739: PUSH
81740: LD_INT 32
81742: PUSH
81743: EMPTY
81744: LIST
81745: LIST
81746: PUSH
81747: LD_INT 34
81749: PUSH
81750: LD_INT 13
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PUSH
81757: LD_INT 34
81759: PUSH
81760: LD_INT 52
81762: PUSH
81763: EMPTY
81764: LIST
81765: LIST
81766: PUSH
81767: LD_INT 34
81769: PUSH
81770: LD_INT 14
81772: PUSH
81773: EMPTY
81774: LIST
81775: LIST
81776: PUSH
81777: LD_INT 34
81779: PUSH
81780: LD_INT 53
81782: PUSH
81783: EMPTY
81784: LIST
81785: LIST
81786: PUSH
81787: LD_INT 34
81789: PUSH
81790: LD_EXP 101
81794: PUSH
81795: EMPTY
81796: LIST
81797: LIST
81798: PUSH
81799: LD_INT 34
81801: PUSH
81802: LD_INT 31
81804: PUSH
81805: EMPTY
81806: LIST
81807: LIST
81808: PUSH
81809: LD_INT 34
81811: PUSH
81812: LD_INT 48
81814: PUSH
81815: EMPTY
81816: LIST
81817: LIST
81818: PUSH
81819: LD_INT 34
81821: PUSH
81822: LD_INT 8
81824: PUSH
81825: EMPTY
81826: LIST
81827: LIST
81828: PUSH
81829: EMPTY
81830: LIST
81831: LIST
81832: LIST
81833: LIST
81834: LIST
81835: LIST
81836: LIST
81837: LIST
81838: LIST
81839: LIST
81840: LIST
81841: LIST
81842: LIST
81843: PPUSH
81844: CALL_OW 72
81848: DIFF
81849: ST_TO_ADDR
// end ; end_of_file
81850: LD_VAR 0 3
81854: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
81855: LD_INT 0
81857: PPUSH
81858: PPUSH
81859: PPUSH
// if not mc_bases or not skirmish then
81860: LD_EXP 58
81864: NOT
81865: PUSH
81866: LD_EXP 56
81870: NOT
81871: OR
81872: IFFALSE 81876
// exit ;
81874: GO 82041
// for i = 1 to mc_bases do
81876: LD_ADDR_VAR 0 4
81880: PUSH
81881: DOUBLE
81882: LD_INT 1
81884: DEC
81885: ST_TO_ADDR
81886: LD_EXP 58
81890: PUSH
81891: FOR_TO
81892: IFFALSE 82039
// begin if sci in mc_bases [ i ] then
81894: LD_VAR 0 2
81898: PUSH
81899: LD_EXP 58
81903: PUSH
81904: LD_VAR 0 4
81908: ARRAY
81909: IN
81910: IFFALSE 82037
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
81912: LD_ADDR_EXP 87
81916: PUSH
81917: LD_EXP 87
81921: PPUSH
81922: LD_VAR 0 4
81926: PUSH
81927: LD_EXP 87
81931: PUSH
81932: LD_VAR 0 4
81936: ARRAY
81937: PUSH
81938: LD_INT 1
81940: PLUS
81941: PUSH
81942: EMPTY
81943: LIST
81944: LIST
81945: PPUSH
81946: LD_VAR 0 1
81950: PPUSH
81951: CALL 20821 0 3
81955: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
81956: LD_ADDR_VAR 0 5
81960: PUSH
81961: LD_EXP 58
81965: PUSH
81966: LD_VAR 0 4
81970: ARRAY
81971: PPUSH
81972: LD_INT 2
81974: PUSH
81975: LD_INT 30
81977: PUSH
81978: LD_INT 0
81980: PUSH
81981: EMPTY
81982: LIST
81983: LIST
81984: PUSH
81985: LD_INT 30
81987: PUSH
81988: LD_INT 1
81990: PUSH
81991: EMPTY
81992: LIST
81993: LIST
81994: PUSH
81995: EMPTY
81996: LIST
81997: LIST
81998: LIST
81999: PPUSH
82000: CALL_OW 72
82004: PPUSH
82005: LD_VAR 0 1
82009: PPUSH
82010: CALL_OW 74
82014: ST_TO_ADDR
// if tmp then
82015: LD_VAR 0 5
82019: IFFALSE 82035
// ComStandNearbyBuilding ( ape , tmp ) ;
82021: LD_VAR 0 1
82025: PPUSH
82026: LD_VAR 0 5
82030: PPUSH
82031: CALL 15388 0 2
// break ;
82035: GO 82039
// end ; end ;
82037: GO 81891
82039: POP
82040: POP
// end ;
82041: LD_VAR 0 3
82045: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
82046: LD_INT 0
82048: PPUSH
82049: PPUSH
82050: PPUSH
// if not mc_bases or not skirmish then
82051: LD_EXP 58
82055: NOT
82056: PUSH
82057: LD_EXP 56
82061: NOT
82062: OR
82063: IFFALSE 82067
// exit ;
82065: GO 82156
// for i = 1 to mc_bases do
82067: LD_ADDR_VAR 0 4
82071: PUSH
82072: DOUBLE
82073: LD_INT 1
82075: DEC
82076: ST_TO_ADDR
82077: LD_EXP 58
82081: PUSH
82082: FOR_TO
82083: IFFALSE 82154
// begin if building in mc_busy_turret_list [ i ] then
82085: LD_VAR 0 1
82089: PUSH
82090: LD_EXP 68
82094: PUSH
82095: LD_VAR 0 4
82099: ARRAY
82100: IN
82101: IFFALSE 82152
// begin tmp := mc_busy_turret_list [ i ] diff building ;
82103: LD_ADDR_VAR 0 5
82107: PUSH
82108: LD_EXP 68
82112: PUSH
82113: LD_VAR 0 4
82117: ARRAY
82118: PUSH
82119: LD_VAR 0 1
82123: DIFF
82124: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
82125: LD_ADDR_EXP 68
82129: PUSH
82130: LD_EXP 68
82134: PPUSH
82135: LD_VAR 0 4
82139: PPUSH
82140: LD_VAR 0 5
82144: PPUSH
82145: CALL_OW 1
82149: ST_TO_ADDR
// break ;
82150: GO 82154
// end ; end ;
82152: GO 82082
82154: POP
82155: POP
// end ;
82156: LD_VAR 0 3
82160: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
82161: LD_INT 0
82163: PPUSH
82164: PPUSH
82165: PPUSH
// if not mc_bases or not skirmish then
82166: LD_EXP 58
82170: NOT
82171: PUSH
82172: LD_EXP 56
82176: NOT
82177: OR
82178: IFFALSE 82182
// exit ;
82180: GO 82381
// for i = 1 to mc_bases do
82182: LD_ADDR_VAR 0 5
82186: PUSH
82187: DOUBLE
82188: LD_INT 1
82190: DEC
82191: ST_TO_ADDR
82192: LD_EXP 58
82196: PUSH
82197: FOR_TO
82198: IFFALSE 82379
// if building in mc_bases [ i ] then
82200: LD_VAR 0 1
82204: PUSH
82205: LD_EXP 58
82209: PUSH
82210: LD_VAR 0 5
82214: ARRAY
82215: IN
82216: IFFALSE 82377
// begin tmp := mc_bases [ i ] diff building ;
82218: LD_ADDR_VAR 0 6
82222: PUSH
82223: LD_EXP 58
82227: PUSH
82228: LD_VAR 0 5
82232: ARRAY
82233: PUSH
82234: LD_VAR 0 1
82238: DIFF
82239: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
82240: LD_ADDR_EXP 58
82244: PUSH
82245: LD_EXP 58
82249: PPUSH
82250: LD_VAR 0 5
82254: PPUSH
82255: LD_VAR 0 6
82259: PPUSH
82260: CALL_OW 1
82264: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
82265: LD_VAR 0 1
82269: PUSH
82270: LD_EXP 66
82274: PUSH
82275: LD_VAR 0 5
82279: ARRAY
82280: IN
82281: IFFALSE 82320
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
82283: LD_ADDR_EXP 66
82287: PUSH
82288: LD_EXP 66
82292: PPUSH
82293: LD_VAR 0 5
82297: PPUSH
82298: LD_EXP 66
82302: PUSH
82303: LD_VAR 0 5
82307: ARRAY
82308: PUSH
82309: LD_VAR 0 1
82313: DIFF
82314: PPUSH
82315: CALL_OW 1
82319: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
82320: LD_VAR 0 1
82324: PUSH
82325: LD_EXP 67
82329: PUSH
82330: LD_VAR 0 5
82334: ARRAY
82335: IN
82336: IFFALSE 82375
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
82338: LD_ADDR_EXP 67
82342: PUSH
82343: LD_EXP 67
82347: PPUSH
82348: LD_VAR 0 5
82352: PPUSH
82353: LD_EXP 67
82357: PUSH
82358: LD_VAR 0 5
82362: ARRAY
82363: PUSH
82364: LD_VAR 0 1
82368: DIFF
82369: PPUSH
82370: CALL_OW 1
82374: ST_TO_ADDR
// break ;
82375: GO 82379
// end ;
82377: GO 82197
82379: POP
82380: POP
// end ;
82381: LD_VAR 0 4
82385: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
82386: LD_INT 0
82388: PPUSH
82389: PPUSH
82390: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
82391: LD_EXP 58
82395: NOT
82396: PUSH
82397: LD_EXP 56
82401: NOT
82402: OR
82403: PUSH
82404: LD_VAR 0 3
82408: PUSH
82409: LD_EXP 84
82413: IN
82414: NOT
82415: OR
82416: IFFALSE 82420
// exit ;
82418: GO 82543
// for i = 1 to mc_vehicles do
82420: LD_ADDR_VAR 0 6
82424: PUSH
82425: DOUBLE
82426: LD_INT 1
82428: DEC
82429: ST_TO_ADDR
82430: LD_EXP 77
82434: PUSH
82435: FOR_TO
82436: IFFALSE 82541
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
82438: LD_VAR 0 2
82442: PUSH
82443: LD_EXP 77
82447: PUSH
82448: LD_VAR 0 6
82452: ARRAY
82453: IN
82454: PUSH
82455: LD_VAR 0 1
82459: PUSH
82460: LD_EXP 77
82464: PUSH
82465: LD_VAR 0 6
82469: ARRAY
82470: IN
82471: OR
82472: IFFALSE 82539
// begin tmp := mc_vehicles [ i ] diff old ;
82474: LD_ADDR_VAR 0 7
82478: PUSH
82479: LD_EXP 77
82483: PUSH
82484: LD_VAR 0 6
82488: ARRAY
82489: PUSH
82490: LD_VAR 0 2
82494: DIFF
82495: ST_TO_ADDR
// tmp := tmp diff new ;
82496: LD_ADDR_VAR 0 7
82500: PUSH
82501: LD_VAR 0 7
82505: PUSH
82506: LD_VAR 0 1
82510: DIFF
82511: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
82512: LD_ADDR_EXP 77
82516: PUSH
82517: LD_EXP 77
82521: PPUSH
82522: LD_VAR 0 6
82526: PPUSH
82527: LD_VAR 0 7
82531: PPUSH
82532: CALL_OW 1
82536: ST_TO_ADDR
// break ;
82537: GO 82541
// end ;
82539: GO 82435
82541: POP
82542: POP
// end ;
82543: LD_VAR 0 5
82547: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
82548: LD_INT 0
82550: PPUSH
82551: PPUSH
82552: PPUSH
82553: PPUSH
// if not mc_bases or not skirmish then
82554: LD_EXP 58
82558: NOT
82559: PUSH
82560: LD_EXP 56
82564: NOT
82565: OR
82566: IFFALSE 82570
// exit ;
82568: GO 82947
// side := GetSide ( vehicle ) ;
82570: LD_ADDR_VAR 0 5
82574: PUSH
82575: LD_VAR 0 1
82579: PPUSH
82580: CALL_OW 255
82584: ST_TO_ADDR
// for i = 1 to mc_bases do
82585: LD_ADDR_VAR 0 4
82589: PUSH
82590: DOUBLE
82591: LD_INT 1
82593: DEC
82594: ST_TO_ADDR
82595: LD_EXP 58
82599: PUSH
82600: FOR_TO
82601: IFFALSE 82945
// begin if factory in mc_bases [ i ] then
82603: LD_VAR 0 2
82607: PUSH
82608: LD_EXP 58
82612: PUSH
82613: LD_VAR 0 4
82617: ARRAY
82618: IN
82619: IFFALSE 82943
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
82621: LD_EXP 80
82625: PUSH
82626: LD_VAR 0 4
82630: ARRAY
82631: PUSH
82632: LD_EXP 69
82636: PUSH
82637: LD_VAR 0 4
82641: ARRAY
82642: LESS
82643: PUSH
82644: LD_VAR 0 1
82648: PPUSH
82649: CALL_OW 264
82653: PUSH
82654: LD_INT 31
82656: PUSH
82657: LD_INT 32
82659: PUSH
82660: LD_INT 51
82662: PUSH
82663: LD_EXP 102
82667: PUSH
82668: LD_INT 12
82670: PUSH
82671: LD_INT 30
82673: PUSH
82674: LD_EXP 101
82678: PUSH
82679: LD_INT 11
82681: PUSH
82682: LD_INT 53
82684: PUSH
82685: LD_INT 14
82687: PUSH
82688: LD_EXP 105
82692: PUSH
82693: LD_INT 29
82695: PUSH
82696: LD_EXP 103
82700: PUSH
82701: LD_INT 13
82703: PUSH
82704: LD_INT 52
82706: PUSH
82707: LD_INT 48
82709: PUSH
82710: LD_INT 8
82712: PUSH
82713: EMPTY
82714: LIST
82715: LIST
82716: LIST
82717: LIST
82718: LIST
82719: LIST
82720: LIST
82721: LIST
82722: LIST
82723: LIST
82724: LIST
82725: LIST
82726: LIST
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: IN
82732: NOT
82733: AND
82734: IFFALSE 82782
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
82736: LD_ADDR_EXP 80
82740: PUSH
82741: LD_EXP 80
82745: PPUSH
82746: LD_VAR 0 4
82750: PUSH
82751: LD_EXP 80
82755: PUSH
82756: LD_VAR 0 4
82760: ARRAY
82761: PUSH
82762: LD_INT 1
82764: PLUS
82765: PUSH
82766: EMPTY
82767: LIST
82768: LIST
82769: PPUSH
82770: LD_VAR 0 1
82774: PPUSH
82775: CALL 20821 0 3
82779: ST_TO_ADDR
82780: GO 82826
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
82782: LD_ADDR_EXP 77
82786: PUSH
82787: LD_EXP 77
82791: PPUSH
82792: LD_VAR 0 4
82796: PUSH
82797: LD_EXP 77
82801: PUSH
82802: LD_VAR 0 4
82806: ARRAY
82807: PUSH
82808: LD_INT 1
82810: PLUS
82811: PUSH
82812: EMPTY
82813: LIST
82814: LIST
82815: PPUSH
82816: LD_VAR 0 1
82820: PPUSH
82821: CALL 20821 0 3
82825: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
82826: LD_VAR 0 1
82830: PPUSH
82831: CALL_OW 263
82835: PUSH
82836: LD_INT 2
82838: EQUAL
82839: IFFALSE 82859
// begin repeat wait ( 0 0$1 ) ;
82841: LD_INT 35
82843: PPUSH
82844: CALL_OW 67
// until IsControledBy ( vehicle ) ;
82848: LD_VAR 0 1
82852: PPUSH
82853: CALL_OW 312
82857: IFFALSE 82841
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
82859: LD_VAR 0 1
82863: PPUSH
82864: LD_EXP 82
82868: PUSH
82869: LD_VAR 0 4
82873: ARRAY
82874: PPUSH
82875: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
82879: LD_VAR 0 1
82883: PPUSH
82884: CALL_OW 263
82888: PUSH
82889: LD_INT 1
82891: NONEQUAL
82892: IFFALSE 82896
// break ;
82894: GO 82945
// repeat wait ( 0 0$1 ) ;
82896: LD_INT 35
82898: PPUSH
82899: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
82903: LD_VAR 0 1
82907: PPUSH
82908: LD_EXP 82
82912: PUSH
82913: LD_VAR 0 4
82917: ARRAY
82918: PPUSH
82919: CALL_OW 308
82923: IFFALSE 82896
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
82925: LD_VAR 0 1
82929: PPUSH
82930: CALL_OW 311
82934: PPUSH
82935: CALL_OW 121
// exit ;
82939: POP
82940: POP
82941: GO 82947
// end ; end ;
82943: GO 82600
82945: POP
82946: POP
// end ;
82947: LD_VAR 0 3
82951: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
82952: LD_INT 0
82954: PPUSH
82955: PPUSH
82956: PPUSH
82957: PPUSH
// if not mc_bases or not skirmish then
82958: LD_EXP 58
82962: NOT
82963: PUSH
82964: LD_EXP 56
82968: NOT
82969: OR
82970: IFFALSE 82974
// exit ;
82972: GO 83327
// repeat wait ( 0 0$1 ) ;
82974: LD_INT 35
82976: PPUSH
82977: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
82981: LD_VAR 0 2
82985: PPUSH
82986: LD_VAR 0 3
82990: PPUSH
82991: CALL_OW 284
82995: IFFALSE 82974
// if GetResourceTypeXY ( x , y ) = mat_artefact then
82997: LD_VAR 0 2
83001: PPUSH
83002: LD_VAR 0 3
83006: PPUSH
83007: CALL_OW 283
83011: PUSH
83012: LD_INT 4
83014: EQUAL
83015: IFFALSE 83019
// exit ;
83017: GO 83327
// for i = 1 to mc_bases do
83019: LD_ADDR_VAR 0 7
83023: PUSH
83024: DOUBLE
83025: LD_INT 1
83027: DEC
83028: ST_TO_ADDR
83029: LD_EXP 58
83033: PUSH
83034: FOR_TO
83035: IFFALSE 83325
// begin if mc_crates_area [ i ] then
83037: LD_EXP 76
83041: PUSH
83042: LD_VAR 0 7
83046: ARRAY
83047: IFFALSE 83158
// for j in mc_crates_area [ i ] do
83049: LD_ADDR_VAR 0 8
83053: PUSH
83054: LD_EXP 76
83058: PUSH
83059: LD_VAR 0 7
83063: ARRAY
83064: PUSH
83065: FOR_IN
83066: IFFALSE 83156
// if InArea ( x , y , j ) then
83068: LD_VAR 0 2
83072: PPUSH
83073: LD_VAR 0 3
83077: PPUSH
83078: LD_VAR 0 8
83082: PPUSH
83083: CALL_OW 309
83087: IFFALSE 83154
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83089: LD_ADDR_EXP 74
83093: PUSH
83094: LD_EXP 74
83098: PPUSH
83099: LD_VAR 0 7
83103: PUSH
83104: LD_EXP 74
83108: PUSH
83109: LD_VAR 0 7
83113: ARRAY
83114: PUSH
83115: LD_INT 1
83117: PLUS
83118: PUSH
83119: EMPTY
83120: LIST
83121: LIST
83122: PPUSH
83123: LD_VAR 0 4
83127: PUSH
83128: LD_VAR 0 2
83132: PUSH
83133: LD_VAR 0 3
83137: PUSH
83138: EMPTY
83139: LIST
83140: LIST
83141: LIST
83142: PPUSH
83143: CALL 20821 0 3
83147: ST_TO_ADDR
// exit ;
83148: POP
83149: POP
83150: POP
83151: POP
83152: GO 83327
// end ;
83154: GO 83065
83156: POP
83157: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83158: LD_ADDR_VAR 0 9
83162: PUSH
83163: LD_EXP 58
83167: PUSH
83168: LD_VAR 0 7
83172: ARRAY
83173: PPUSH
83174: LD_INT 2
83176: PUSH
83177: LD_INT 30
83179: PUSH
83180: LD_INT 0
83182: PUSH
83183: EMPTY
83184: LIST
83185: LIST
83186: PUSH
83187: LD_INT 30
83189: PUSH
83190: LD_INT 1
83192: PUSH
83193: EMPTY
83194: LIST
83195: LIST
83196: PUSH
83197: EMPTY
83198: LIST
83199: LIST
83200: LIST
83201: PPUSH
83202: CALL_OW 72
83206: ST_TO_ADDR
// if not depot then
83207: LD_VAR 0 9
83211: NOT
83212: IFFALSE 83216
// continue ;
83214: GO 83034
// for j in depot do
83216: LD_ADDR_VAR 0 8
83220: PUSH
83221: LD_VAR 0 9
83225: PUSH
83226: FOR_IN
83227: IFFALSE 83321
// if GetDistUnitXY ( j , x , y ) < 30 then
83229: LD_VAR 0 8
83233: PPUSH
83234: LD_VAR 0 2
83238: PPUSH
83239: LD_VAR 0 3
83243: PPUSH
83244: CALL_OW 297
83248: PUSH
83249: LD_INT 30
83251: LESS
83252: IFFALSE 83319
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83254: LD_ADDR_EXP 74
83258: PUSH
83259: LD_EXP 74
83263: PPUSH
83264: LD_VAR 0 7
83268: PUSH
83269: LD_EXP 74
83273: PUSH
83274: LD_VAR 0 7
83278: ARRAY
83279: PUSH
83280: LD_INT 1
83282: PLUS
83283: PUSH
83284: EMPTY
83285: LIST
83286: LIST
83287: PPUSH
83288: LD_VAR 0 4
83292: PUSH
83293: LD_VAR 0 2
83297: PUSH
83298: LD_VAR 0 3
83302: PUSH
83303: EMPTY
83304: LIST
83305: LIST
83306: LIST
83307: PPUSH
83308: CALL 20821 0 3
83312: ST_TO_ADDR
// exit ;
83313: POP
83314: POP
83315: POP
83316: POP
83317: GO 83327
// end ;
83319: GO 83226
83321: POP
83322: POP
// end ;
83323: GO 83034
83325: POP
83326: POP
// end ;
83327: LD_VAR 0 6
83331: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
83332: LD_INT 0
83334: PPUSH
83335: PPUSH
83336: PPUSH
83337: PPUSH
// if not mc_bases or not skirmish then
83338: LD_EXP 58
83342: NOT
83343: PUSH
83344: LD_EXP 56
83348: NOT
83349: OR
83350: IFFALSE 83354
// exit ;
83352: GO 83631
// side := GetSide ( lab ) ;
83354: LD_ADDR_VAR 0 4
83358: PUSH
83359: LD_VAR 0 2
83363: PPUSH
83364: CALL_OW 255
83368: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
83369: LD_VAR 0 4
83373: PUSH
83374: LD_EXP 84
83378: IN
83379: NOT
83380: PUSH
83381: LD_EXP 85
83385: NOT
83386: OR
83387: PUSH
83388: LD_EXP 58
83392: NOT
83393: OR
83394: IFFALSE 83398
// exit ;
83396: GO 83631
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
83398: LD_ADDR_EXP 85
83402: PUSH
83403: LD_EXP 85
83407: PPUSH
83408: LD_VAR 0 4
83412: PPUSH
83413: LD_EXP 85
83417: PUSH
83418: LD_VAR 0 4
83422: ARRAY
83423: PUSH
83424: LD_VAR 0 1
83428: DIFF
83429: PPUSH
83430: CALL_OW 1
83434: ST_TO_ADDR
// for i = 1 to mc_bases do
83435: LD_ADDR_VAR 0 5
83439: PUSH
83440: DOUBLE
83441: LD_INT 1
83443: DEC
83444: ST_TO_ADDR
83445: LD_EXP 58
83449: PUSH
83450: FOR_TO
83451: IFFALSE 83629
// begin if lab in mc_bases [ i ] then
83453: LD_VAR 0 2
83457: PUSH
83458: LD_EXP 58
83462: PUSH
83463: LD_VAR 0 5
83467: ARRAY
83468: IN
83469: IFFALSE 83627
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
83471: LD_VAR 0 1
83475: PUSH
83476: LD_INT 11
83478: PUSH
83479: LD_INT 4
83481: PUSH
83482: LD_INT 3
83484: PUSH
83485: LD_INT 2
83487: PUSH
83488: EMPTY
83489: LIST
83490: LIST
83491: LIST
83492: LIST
83493: IN
83494: PUSH
83495: LD_EXP 88
83499: PUSH
83500: LD_VAR 0 5
83504: ARRAY
83505: AND
83506: IFFALSE 83627
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
83508: LD_ADDR_VAR 0 6
83512: PUSH
83513: LD_EXP 88
83517: PUSH
83518: LD_VAR 0 5
83522: ARRAY
83523: PUSH
83524: LD_INT 1
83526: ARRAY
83527: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83528: LD_ADDR_EXP 88
83532: PUSH
83533: LD_EXP 88
83537: PPUSH
83538: LD_VAR 0 5
83542: PPUSH
83543: EMPTY
83544: PPUSH
83545: CALL_OW 1
83549: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
83550: LD_VAR 0 6
83554: PPUSH
83555: LD_INT 0
83557: PPUSH
83558: CALL_OW 109
// ComExitBuilding ( tmp ) ;
83562: LD_VAR 0 6
83566: PPUSH
83567: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
83571: LD_ADDR_EXP 87
83575: PUSH
83576: LD_EXP 87
83580: PPUSH
83581: LD_VAR 0 5
83585: PPUSH
83586: LD_EXP 87
83590: PUSH
83591: LD_VAR 0 5
83595: ARRAY
83596: PPUSH
83597: LD_INT 1
83599: PPUSH
83600: LD_VAR 0 6
83604: PPUSH
83605: CALL_OW 2
83609: PPUSH
83610: CALL_OW 1
83614: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
83615: LD_VAR 0 5
83619: PPUSH
83620: LD_INT 112
83622: PPUSH
83623: CALL 60739 0 2
// end ; end ; end ;
83627: GO 83450
83629: POP
83630: POP
// end ;
83631: LD_VAR 0 3
83635: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
83636: LD_INT 0
83638: PPUSH
83639: PPUSH
83640: PPUSH
83641: PPUSH
83642: PPUSH
83643: PPUSH
83644: PPUSH
83645: PPUSH
// if not mc_bases or not skirmish then
83646: LD_EXP 58
83650: NOT
83651: PUSH
83652: LD_EXP 56
83656: NOT
83657: OR
83658: IFFALSE 83662
// exit ;
83660: GO 84811
// for i = 1 to mc_bases do
83662: LD_ADDR_VAR 0 3
83666: PUSH
83667: DOUBLE
83668: LD_INT 1
83670: DEC
83671: ST_TO_ADDR
83672: LD_EXP 58
83676: PUSH
83677: FOR_TO
83678: IFFALSE 84809
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
83680: LD_VAR 0 1
83684: PUSH
83685: LD_EXP 58
83689: PUSH
83690: LD_VAR 0 3
83694: ARRAY
83695: IN
83696: PUSH
83697: LD_VAR 0 1
83701: PUSH
83702: LD_EXP 65
83706: PUSH
83707: LD_VAR 0 3
83711: ARRAY
83712: IN
83713: OR
83714: PUSH
83715: LD_VAR 0 1
83719: PUSH
83720: LD_EXP 80
83724: PUSH
83725: LD_VAR 0 3
83729: ARRAY
83730: IN
83731: OR
83732: PUSH
83733: LD_VAR 0 1
83737: PUSH
83738: LD_EXP 77
83742: PUSH
83743: LD_VAR 0 3
83747: ARRAY
83748: IN
83749: OR
83750: PUSH
83751: LD_VAR 0 1
83755: PUSH
83756: LD_EXP 87
83760: PUSH
83761: LD_VAR 0 3
83765: ARRAY
83766: IN
83767: OR
83768: PUSH
83769: LD_VAR 0 1
83773: PUSH
83774: LD_EXP 88
83778: PUSH
83779: LD_VAR 0 3
83783: ARRAY
83784: IN
83785: OR
83786: IFFALSE 84807
// begin if un in mc_ape [ i ] then
83788: LD_VAR 0 1
83792: PUSH
83793: LD_EXP 87
83797: PUSH
83798: LD_VAR 0 3
83802: ARRAY
83803: IN
83804: IFFALSE 83843
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
83806: LD_ADDR_EXP 87
83810: PUSH
83811: LD_EXP 87
83815: PPUSH
83816: LD_VAR 0 3
83820: PPUSH
83821: LD_EXP 87
83825: PUSH
83826: LD_VAR 0 3
83830: ARRAY
83831: PUSH
83832: LD_VAR 0 1
83836: DIFF
83837: PPUSH
83838: CALL_OW 1
83842: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
83843: LD_VAR 0 1
83847: PUSH
83848: LD_EXP 88
83852: PUSH
83853: LD_VAR 0 3
83857: ARRAY
83858: IN
83859: IFFALSE 83883
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83861: LD_ADDR_EXP 88
83865: PUSH
83866: LD_EXP 88
83870: PPUSH
83871: LD_VAR 0 3
83875: PPUSH
83876: EMPTY
83877: PPUSH
83878: CALL_OW 1
83882: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane ] ) then
83883: LD_VAR 0 1
83887: PPUSH
83888: CALL_OW 247
83892: PUSH
83893: LD_INT 2
83895: EQUAL
83896: PUSH
83897: LD_VAR 0 1
83901: PPUSH
83902: CALL_OW 110
83906: PUSH
83907: LD_INT 20
83909: EQUAL
83910: PUSH
83911: LD_VAR 0 1
83915: PUSH
83916: LD_EXP 80
83920: PUSH
83921: LD_VAR 0 3
83925: ARRAY
83926: IN
83927: OR
83928: PUSH
83929: LD_VAR 0 1
83933: PPUSH
83934: CALL_OW 264
83938: PUSH
83939: LD_INT 12
83941: PUSH
83942: LD_INT 51
83944: PUSH
83945: LD_EXP 102
83949: PUSH
83950: LD_INT 32
83952: PUSH
83953: LD_INT 13
83955: PUSH
83956: LD_INT 52
83958: PUSH
83959: EMPTY
83960: LIST
83961: LIST
83962: LIST
83963: LIST
83964: LIST
83965: LIST
83966: IN
83967: OR
83968: AND
83969: IFFALSE 84147
// begin if un in mc_defender [ i ] then
83971: LD_VAR 0 1
83975: PUSH
83976: LD_EXP 80
83980: PUSH
83981: LD_VAR 0 3
83985: ARRAY
83986: IN
83987: IFFALSE 84026
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
83989: LD_ADDR_EXP 80
83993: PUSH
83994: LD_EXP 80
83998: PPUSH
83999: LD_VAR 0 3
84003: PPUSH
84004: LD_EXP 80
84008: PUSH
84009: LD_VAR 0 3
84013: ARRAY
84014: PUSH
84015: LD_VAR 0 1
84019: DIFF
84020: PPUSH
84021: CALL_OW 1
84025: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
84026: LD_ADDR_VAR 0 8
84030: PUSH
84031: LD_VAR 0 3
84035: PPUSH
84036: LD_INT 3
84038: PPUSH
84039: CALL 80699 0 2
84043: ST_TO_ADDR
// if fac then
84044: LD_VAR 0 8
84048: IFFALSE 84147
// begin for j in fac do
84050: LD_ADDR_VAR 0 4
84054: PUSH
84055: LD_VAR 0 8
84059: PUSH
84060: FOR_IN
84061: IFFALSE 84145
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
84063: LD_ADDR_VAR 0 9
84067: PUSH
84068: LD_VAR 0 8
84072: PPUSH
84073: LD_VAR 0 1
84077: PPUSH
84078: CALL_OW 265
84082: PPUSH
84083: LD_VAR 0 1
84087: PPUSH
84088: CALL_OW 262
84092: PPUSH
84093: LD_VAR 0 1
84097: PPUSH
84098: CALL_OW 263
84102: PPUSH
84103: LD_VAR 0 1
84107: PPUSH
84108: CALL_OW 264
84112: PPUSH
84113: CALL 18353 0 5
84117: ST_TO_ADDR
// if components then
84118: LD_VAR 0 9
84122: IFFALSE 84143
// begin MC_InsertProduceList ( i , [ components ] ) ;
84124: LD_VAR 0 3
84128: PPUSH
84129: LD_VAR 0 9
84133: PUSH
84134: EMPTY
84135: LIST
84136: PPUSH
84137: CALL 80244 0 2
// break ;
84141: GO 84145
// end ; end ;
84143: GO 84060
84145: POP
84146: POP
// end ; end ; if GetType ( un ) = unit_building then
84147: LD_VAR 0 1
84151: PPUSH
84152: CALL_OW 247
84156: PUSH
84157: LD_INT 3
84159: EQUAL
84160: IFFALSE 84475
// begin btype := GetBType ( un ) ;
84162: LD_ADDR_VAR 0 5
84166: PUSH
84167: LD_VAR 0 1
84171: PPUSH
84172: CALL_OW 266
84176: ST_TO_ADDR
// if btype = b_warehouse then
84177: LD_VAR 0 5
84181: PUSH
84182: LD_INT 1
84184: EQUAL
84185: IFFALSE 84203
// begin btype := b_depot ;
84187: LD_ADDR_VAR 0 5
84191: PUSH
84192: LD_INT 0
84194: ST_TO_ADDR
// pos := 1 ;
84195: LD_ADDR_VAR 0 6
84199: PUSH
84200: LD_INT 1
84202: ST_TO_ADDR
// end ; if btype = b_factory then
84203: LD_VAR 0 5
84207: PUSH
84208: LD_INT 3
84210: EQUAL
84211: IFFALSE 84229
// begin btype := b_workshop ;
84213: LD_ADDR_VAR 0 5
84217: PUSH
84218: LD_INT 2
84220: ST_TO_ADDR
// pos := 1 ;
84221: LD_ADDR_VAR 0 6
84225: PUSH
84226: LD_INT 1
84228: ST_TO_ADDR
// end ; if btype = b_barracks then
84229: LD_VAR 0 5
84233: PUSH
84234: LD_INT 5
84236: EQUAL
84237: IFFALSE 84247
// btype := b_armoury ;
84239: LD_ADDR_VAR 0 5
84243: PUSH
84244: LD_INT 4
84246: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
84247: LD_VAR 0 5
84251: PUSH
84252: LD_INT 7
84254: PUSH
84255: LD_INT 8
84257: PUSH
84258: EMPTY
84259: LIST
84260: LIST
84261: IN
84262: IFFALSE 84272
// btype := b_lab ;
84264: LD_ADDR_VAR 0 5
84268: PUSH
84269: LD_INT 6
84271: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
84272: LD_ADDR_EXP 63
84276: PUSH
84277: LD_EXP 63
84281: PPUSH
84282: LD_VAR 0 3
84286: PUSH
84287: LD_EXP 63
84291: PUSH
84292: LD_VAR 0 3
84296: ARRAY
84297: PUSH
84298: LD_INT 1
84300: PLUS
84301: PUSH
84302: EMPTY
84303: LIST
84304: LIST
84305: PPUSH
84306: LD_VAR 0 5
84310: PUSH
84311: LD_VAR 0 1
84315: PPUSH
84316: CALL_OW 250
84320: PUSH
84321: LD_VAR 0 1
84325: PPUSH
84326: CALL_OW 251
84330: PUSH
84331: LD_VAR 0 1
84335: PPUSH
84336: CALL_OW 254
84340: PUSH
84341: EMPTY
84342: LIST
84343: LIST
84344: LIST
84345: LIST
84346: PPUSH
84347: CALL 20821 0 3
84351: ST_TO_ADDR
// if pos = 1 then
84352: LD_VAR 0 6
84356: PUSH
84357: LD_INT 1
84359: EQUAL
84360: IFFALSE 84475
// begin tmp := mc_build_list [ i ] ;
84362: LD_ADDR_VAR 0 7
84366: PUSH
84367: LD_EXP 63
84371: PUSH
84372: LD_VAR 0 3
84376: ARRAY
84377: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
84378: LD_VAR 0 7
84382: PPUSH
84383: LD_INT 2
84385: PUSH
84386: LD_INT 30
84388: PUSH
84389: LD_INT 0
84391: PUSH
84392: EMPTY
84393: LIST
84394: LIST
84395: PUSH
84396: LD_INT 30
84398: PUSH
84399: LD_INT 1
84401: PUSH
84402: EMPTY
84403: LIST
84404: LIST
84405: PUSH
84406: EMPTY
84407: LIST
84408: LIST
84409: LIST
84410: PPUSH
84411: CALL_OW 72
84415: IFFALSE 84425
// pos := 2 ;
84417: LD_ADDR_VAR 0 6
84421: PUSH
84422: LD_INT 2
84424: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
84425: LD_ADDR_VAR 0 7
84429: PUSH
84430: LD_VAR 0 7
84434: PPUSH
84435: LD_VAR 0 6
84439: PPUSH
84440: LD_VAR 0 7
84444: PPUSH
84445: CALL 21147 0 3
84449: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
84450: LD_ADDR_EXP 63
84454: PUSH
84455: LD_EXP 63
84459: PPUSH
84460: LD_VAR 0 3
84464: PPUSH
84465: LD_VAR 0 7
84469: PPUSH
84470: CALL_OW 1
84474: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
84475: LD_VAR 0 1
84479: PUSH
84480: LD_EXP 58
84484: PUSH
84485: LD_VAR 0 3
84489: ARRAY
84490: IN
84491: IFFALSE 84530
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
84493: LD_ADDR_EXP 58
84497: PUSH
84498: LD_EXP 58
84502: PPUSH
84503: LD_VAR 0 3
84507: PPUSH
84508: LD_EXP 58
84512: PUSH
84513: LD_VAR 0 3
84517: ARRAY
84518: PUSH
84519: LD_VAR 0 1
84523: DIFF
84524: PPUSH
84525: CALL_OW 1
84529: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
84530: LD_VAR 0 1
84534: PUSH
84535: LD_EXP 65
84539: PUSH
84540: LD_VAR 0 3
84544: ARRAY
84545: IN
84546: IFFALSE 84585
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
84548: LD_ADDR_EXP 65
84552: PUSH
84553: LD_EXP 65
84557: PPUSH
84558: LD_VAR 0 3
84562: PPUSH
84563: LD_EXP 65
84567: PUSH
84568: LD_VAR 0 3
84572: ARRAY
84573: PUSH
84574: LD_VAR 0 1
84578: DIFF
84579: PPUSH
84580: CALL_OW 1
84584: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
84585: LD_VAR 0 1
84589: PUSH
84590: LD_EXP 77
84594: PUSH
84595: LD_VAR 0 3
84599: ARRAY
84600: IN
84601: IFFALSE 84640
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
84603: LD_ADDR_EXP 77
84607: PUSH
84608: LD_EXP 77
84612: PPUSH
84613: LD_VAR 0 3
84617: PPUSH
84618: LD_EXP 77
84622: PUSH
84623: LD_VAR 0 3
84627: ARRAY
84628: PUSH
84629: LD_VAR 0 1
84633: DIFF
84634: PPUSH
84635: CALL_OW 1
84639: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
84640: LD_VAR 0 1
84644: PUSH
84645: LD_EXP 80
84649: PUSH
84650: LD_VAR 0 3
84654: ARRAY
84655: IN
84656: IFFALSE 84695
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84658: LD_ADDR_EXP 80
84662: PUSH
84663: LD_EXP 80
84667: PPUSH
84668: LD_VAR 0 3
84672: PPUSH
84673: LD_EXP 80
84677: PUSH
84678: LD_VAR 0 3
84682: ARRAY
84683: PUSH
84684: LD_VAR 0 1
84688: DIFF
84689: PPUSH
84690: CALL_OW 1
84694: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
84695: LD_VAR 0 1
84699: PUSH
84700: LD_EXP 67
84704: PUSH
84705: LD_VAR 0 3
84709: ARRAY
84710: IN
84711: IFFALSE 84750
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
84713: LD_ADDR_EXP 67
84717: PUSH
84718: LD_EXP 67
84722: PPUSH
84723: LD_VAR 0 3
84727: PPUSH
84728: LD_EXP 67
84732: PUSH
84733: LD_VAR 0 3
84737: ARRAY
84738: PUSH
84739: LD_VAR 0 1
84743: DIFF
84744: PPUSH
84745: CALL_OW 1
84749: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
84750: LD_VAR 0 1
84754: PUSH
84755: LD_EXP 66
84759: PUSH
84760: LD_VAR 0 3
84764: ARRAY
84765: IN
84766: IFFALSE 84805
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
84768: LD_ADDR_EXP 66
84772: PUSH
84773: LD_EXP 66
84777: PPUSH
84778: LD_VAR 0 3
84782: PPUSH
84783: LD_EXP 66
84787: PUSH
84788: LD_VAR 0 3
84792: ARRAY
84793: PUSH
84794: LD_VAR 0 1
84798: DIFF
84799: PPUSH
84800: CALL_OW 1
84804: ST_TO_ADDR
// end ; break ;
84805: GO 84809
// end ;
84807: GO 83677
84809: POP
84810: POP
// end ;
84811: LD_VAR 0 2
84815: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
84816: LD_INT 0
84818: PPUSH
84819: PPUSH
84820: PPUSH
// if not mc_bases or not skirmish then
84821: LD_EXP 58
84825: NOT
84826: PUSH
84827: LD_EXP 56
84831: NOT
84832: OR
84833: IFFALSE 84837
// exit ;
84835: GO 85052
// for i = 1 to mc_bases do
84837: LD_ADDR_VAR 0 3
84841: PUSH
84842: DOUBLE
84843: LD_INT 1
84845: DEC
84846: ST_TO_ADDR
84847: LD_EXP 58
84851: PUSH
84852: FOR_TO
84853: IFFALSE 85050
// begin if building in mc_construct_list [ i ] then
84855: LD_VAR 0 1
84859: PUSH
84860: LD_EXP 65
84864: PUSH
84865: LD_VAR 0 3
84869: ARRAY
84870: IN
84871: IFFALSE 85048
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84873: LD_ADDR_EXP 65
84877: PUSH
84878: LD_EXP 65
84882: PPUSH
84883: LD_VAR 0 3
84887: PPUSH
84888: LD_EXP 65
84892: PUSH
84893: LD_VAR 0 3
84897: ARRAY
84898: PUSH
84899: LD_VAR 0 1
84903: DIFF
84904: PPUSH
84905: CALL_OW 1
84909: ST_TO_ADDR
// if building in mc_lab [ i ] then
84910: LD_VAR 0 1
84914: PUSH
84915: LD_EXP 91
84919: PUSH
84920: LD_VAR 0 3
84924: ARRAY
84925: IN
84926: IFFALSE 84981
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
84928: LD_ADDR_EXP 92
84932: PUSH
84933: LD_EXP 92
84937: PPUSH
84938: LD_VAR 0 3
84942: PPUSH
84943: LD_EXP 92
84947: PUSH
84948: LD_VAR 0 3
84952: ARRAY
84953: PPUSH
84954: LD_INT 1
84956: PPUSH
84957: LD_EXP 92
84961: PUSH
84962: LD_VAR 0 3
84966: ARRAY
84967: PPUSH
84968: LD_INT 0
84970: PPUSH
84971: CALL 20239 0 4
84975: PPUSH
84976: CALL_OW 1
84980: ST_TO_ADDR
// if not building in mc_bases [ i ] then
84981: LD_VAR 0 1
84985: PUSH
84986: LD_EXP 58
84990: PUSH
84991: LD_VAR 0 3
84995: ARRAY
84996: IN
84997: NOT
84998: IFFALSE 85044
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85000: LD_ADDR_EXP 58
85004: PUSH
85005: LD_EXP 58
85009: PPUSH
85010: LD_VAR 0 3
85014: PUSH
85015: LD_EXP 58
85019: PUSH
85020: LD_VAR 0 3
85024: ARRAY
85025: PUSH
85026: LD_INT 1
85028: PLUS
85029: PUSH
85030: EMPTY
85031: LIST
85032: LIST
85033: PPUSH
85034: LD_VAR 0 1
85038: PPUSH
85039: CALL 20821 0 3
85043: ST_TO_ADDR
// exit ;
85044: POP
85045: POP
85046: GO 85052
// end ; end ;
85048: GO 84852
85050: POP
85051: POP
// end ;
85052: LD_VAR 0 2
85056: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
85057: LD_INT 0
85059: PPUSH
85060: PPUSH
85061: PPUSH
85062: PPUSH
85063: PPUSH
85064: PPUSH
85065: PPUSH
// if not mc_bases or not skirmish then
85066: LD_EXP 58
85070: NOT
85071: PUSH
85072: LD_EXP 56
85076: NOT
85077: OR
85078: IFFALSE 85082
// exit ;
85080: GO 85743
// for i = 1 to mc_bases do
85082: LD_ADDR_VAR 0 3
85086: PUSH
85087: DOUBLE
85088: LD_INT 1
85090: DEC
85091: ST_TO_ADDR
85092: LD_EXP 58
85096: PUSH
85097: FOR_TO
85098: IFFALSE 85741
// begin if building in mc_construct_list [ i ] then
85100: LD_VAR 0 1
85104: PUSH
85105: LD_EXP 65
85109: PUSH
85110: LD_VAR 0 3
85114: ARRAY
85115: IN
85116: IFFALSE 85739
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85118: LD_ADDR_EXP 65
85122: PUSH
85123: LD_EXP 65
85127: PPUSH
85128: LD_VAR 0 3
85132: PPUSH
85133: LD_EXP 65
85137: PUSH
85138: LD_VAR 0 3
85142: ARRAY
85143: PUSH
85144: LD_VAR 0 1
85148: DIFF
85149: PPUSH
85150: CALL_OW 1
85154: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85155: LD_ADDR_EXP 58
85159: PUSH
85160: LD_EXP 58
85164: PPUSH
85165: LD_VAR 0 3
85169: PUSH
85170: LD_EXP 58
85174: PUSH
85175: LD_VAR 0 3
85179: ARRAY
85180: PUSH
85181: LD_INT 1
85183: PLUS
85184: PUSH
85185: EMPTY
85186: LIST
85187: LIST
85188: PPUSH
85189: LD_VAR 0 1
85193: PPUSH
85194: CALL 20821 0 3
85198: ST_TO_ADDR
// btype := GetBType ( building ) ;
85199: LD_ADDR_VAR 0 5
85203: PUSH
85204: LD_VAR 0 1
85208: PPUSH
85209: CALL_OW 266
85213: ST_TO_ADDR
// side := GetSide ( building ) ;
85214: LD_ADDR_VAR 0 8
85218: PUSH
85219: LD_VAR 0 1
85223: PPUSH
85224: CALL_OW 255
85228: ST_TO_ADDR
// if btype = b_lab then
85229: LD_VAR 0 5
85233: PUSH
85234: LD_INT 6
85236: EQUAL
85237: IFFALSE 85287
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
85239: LD_ADDR_EXP 91
85243: PUSH
85244: LD_EXP 91
85248: PPUSH
85249: LD_VAR 0 3
85253: PUSH
85254: LD_EXP 91
85258: PUSH
85259: LD_VAR 0 3
85263: ARRAY
85264: PUSH
85265: LD_INT 1
85267: PLUS
85268: PUSH
85269: EMPTY
85270: LIST
85271: LIST
85272: PPUSH
85273: LD_VAR 0 1
85277: PPUSH
85278: CALL 20821 0 3
85282: ST_TO_ADDR
// exit ;
85283: POP
85284: POP
85285: GO 85743
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
85287: LD_VAR 0 5
85291: PUSH
85292: LD_INT 0
85294: PUSH
85295: LD_INT 2
85297: PUSH
85298: LD_INT 4
85300: PUSH
85301: EMPTY
85302: LIST
85303: LIST
85304: LIST
85305: IN
85306: IFFALSE 85430
// begin if btype = b_armoury then
85308: LD_VAR 0 5
85312: PUSH
85313: LD_INT 4
85315: EQUAL
85316: IFFALSE 85326
// btype := b_barracks ;
85318: LD_ADDR_VAR 0 5
85322: PUSH
85323: LD_INT 5
85325: ST_TO_ADDR
// if btype = b_depot then
85326: LD_VAR 0 5
85330: PUSH
85331: LD_INT 0
85333: EQUAL
85334: IFFALSE 85344
// btype := b_warehouse ;
85336: LD_ADDR_VAR 0 5
85340: PUSH
85341: LD_INT 1
85343: ST_TO_ADDR
// if btype = b_workshop then
85344: LD_VAR 0 5
85348: PUSH
85349: LD_INT 2
85351: EQUAL
85352: IFFALSE 85362
// btype := b_factory ;
85354: LD_ADDR_VAR 0 5
85358: PUSH
85359: LD_INT 3
85361: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
85362: LD_VAR 0 5
85366: PPUSH
85367: LD_VAR 0 8
85371: PPUSH
85372: CALL_OW 323
85376: PUSH
85377: LD_INT 1
85379: EQUAL
85380: IFFALSE 85426
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
85382: LD_ADDR_EXP 90
85386: PUSH
85387: LD_EXP 90
85391: PPUSH
85392: LD_VAR 0 3
85396: PUSH
85397: LD_EXP 90
85401: PUSH
85402: LD_VAR 0 3
85406: ARRAY
85407: PUSH
85408: LD_INT 1
85410: PLUS
85411: PUSH
85412: EMPTY
85413: LIST
85414: LIST
85415: PPUSH
85416: LD_VAR 0 1
85420: PPUSH
85421: CALL 20821 0 3
85425: ST_TO_ADDR
// exit ;
85426: POP
85427: POP
85428: GO 85743
// end ; if btype in [ b_bunker , b_turret ] then
85430: LD_VAR 0 5
85434: PUSH
85435: LD_INT 32
85437: PUSH
85438: LD_INT 33
85440: PUSH
85441: EMPTY
85442: LIST
85443: LIST
85444: IN
85445: IFFALSE 85735
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
85447: LD_ADDR_EXP 66
85451: PUSH
85452: LD_EXP 66
85456: PPUSH
85457: LD_VAR 0 3
85461: PUSH
85462: LD_EXP 66
85466: PUSH
85467: LD_VAR 0 3
85471: ARRAY
85472: PUSH
85473: LD_INT 1
85475: PLUS
85476: PUSH
85477: EMPTY
85478: LIST
85479: LIST
85480: PPUSH
85481: LD_VAR 0 1
85485: PPUSH
85486: CALL 20821 0 3
85490: ST_TO_ADDR
// if btype = b_bunker then
85491: LD_VAR 0 5
85495: PUSH
85496: LD_INT 32
85498: EQUAL
85499: IFFALSE 85735
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
85501: LD_ADDR_EXP 67
85505: PUSH
85506: LD_EXP 67
85510: PPUSH
85511: LD_VAR 0 3
85515: PUSH
85516: LD_EXP 67
85520: PUSH
85521: LD_VAR 0 3
85525: ARRAY
85526: PUSH
85527: LD_INT 1
85529: PLUS
85530: PUSH
85531: EMPTY
85532: LIST
85533: LIST
85534: PPUSH
85535: LD_VAR 0 1
85539: PPUSH
85540: CALL 20821 0 3
85544: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
85545: LD_ADDR_VAR 0 6
85549: PUSH
85550: LD_EXP 58
85554: PUSH
85555: LD_VAR 0 3
85559: ARRAY
85560: PPUSH
85561: LD_INT 25
85563: PUSH
85564: LD_INT 1
85566: PUSH
85567: EMPTY
85568: LIST
85569: LIST
85570: PUSH
85571: LD_INT 3
85573: PUSH
85574: LD_INT 54
85576: PUSH
85577: EMPTY
85578: LIST
85579: PUSH
85580: EMPTY
85581: LIST
85582: LIST
85583: PUSH
85584: EMPTY
85585: LIST
85586: LIST
85587: PPUSH
85588: CALL_OW 72
85592: ST_TO_ADDR
// if tmp then
85593: LD_VAR 0 6
85597: IFFALSE 85603
// exit ;
85599: POP
85600: POP
85601: GO 85743
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
85603: LD_ADDR_VAR 0 6
85607: PUSH
85608: LD_EXP 58
85612: PUSH
85613: LD_VAR 0 3
85617: ARRAY
85618: PPUSH
85619: LD_INT 2
85621: PUSH
85622: LD_INT 30
85624: PUSH
85625: LD_INT 4
85627: PUSH
85628: EMPTY
85629: LIST
85630: LIST
85631: PUSH
85632: LD_INT 30
85634: PUSH
85635: LD_INT 5
85637: PUSH
85638: EMPTY
85639: LIST
85640: LIST
85641: PUSH
85642: EMPTY
85643: LIST
85644: LIST
85645: LIST
85646: PPUSH
85647: CALL_OW 72
85651: ST_TO_ADDR
// if not tmp then
85652: LD_VAR 0 6
85656: NOT
85657: IFFALSE 85663
// exit ;
85659: POP
85660: POP
85661: GO 85743
// for j in tmp do
85663: LD_ADDR_VAR 0 4
85667: PUSH
85668: LD_VAR 0 6
85672: PUSH
85673: FOR_IN
85674: IFFALSE 85733
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
85676: LD_ADDR_VAR 0 7
85680: PUSH
85681: LD_VAR 0 4
85685: PPUSH
85686: CALL_OW 313
85690: PPUSH
85691: LD_INT 25
85693: PUSH
85694: LD_INT 1
85696: PUSH
85697: EMPTY
85698: LIST
85699: LIST
85700: PPUSH
85701: CALL_OW 72
85705: ST_TO_ADDR
// if units then
85706: LD_VAR 0 7
85710: IFFALSE 85731
// begin ComExitBuilding ( units [ 1 ] ) ;
85712: LD_VAR 0 7
85716: PUSH
85717: LD_INT 1
85719: ARRAY
85720: PPUSH
85721: CALL_OW 122
// exit ;
85725: POP
85726: POP
85727: POP
85728: POP
85729: GO 85743
// end ; end ;
85731: GO 85673
85733: POP
85734: POP
// end ; end ; exit ;
85735: POP
85736: POP
85737: GO 85743
// end ; end ;
85739: GO 85097
85741: POP
85742: POP
// end ;
85743: LD_VAR 0 2
85747: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
85748: LD_INT 0
85750: PPUSH
85751: PPUSH
85752: PPUSH
85753: PPUSH
85754: PPUSH
85755: PPUSH
85756: PPUSH
// if not mc_bases or not skirmish then
85757: LD_EXP 58
85761: NOT
85762: PUSH
85763: LD_EXP 56
85767: NOT
85768: OR
85769: IFFALSE 85773
// exit ;
85771: GO 86004
// btype := GetBType ( building ) ;
85773: LD_ADDR_VAR 0 6
85777: PUSH
85778: LD_VAR 0 1
85782: PPUSH
85783: CALL_OW 266
85787: ST_TO_ADDR
// x := GetX ( building ) ;
85788: LD_ADDR_VAR 0 7
85792: PUSH
85793: LD_VAR 0 1
85797: PPUSH
85798: CALL_OW 250
85802: ST_TO_ADDR
// y := GetY ( building ) ;
85803: LD_ADDR_VAR 0 8
85807: PUSH
85808: LD_VAR 0 1
85812: PPUSH
85813: CALL_OW 251
85817: ST_TO_ADDR
// d := GetDir ( building ) ;
85818: LD_ADDR_VAR 0 9
85822: PUSH
85823: LD_VAR 0 1
85827: PPUSH
85828: CALL_OW 254
85832: ST_TO_ADDR
// for i = 1 to mc_bases do
85833: LD_ADDR_VAR 0 4
85837: PUSH
85838: DOUBLE
85839: LD_INT 1
85841: DEC
85842: ST_TO_ADDR
85843: LD_EXP 58
85847: PUSH
85848: FOR_TO
85849: IFFALSE 86002
// begin if not mc_build_list [ i ] then
85851: LD_EXP 63
85855: PUSH
85856: LD_VAR 0 4
85860: ARRAY
85861: NOT
85862: IFFALSE 85866
// continue ;
85864: GO 85848
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
85866: LD_VAR 0 6
85870: PUSH
85871: LD_VAR 0 7
85875: PUSH
85876: LD_VAR 0 8
85880: PUSH
85881: LD_VAR 0 9
85885: PUSH
85886: EMPTY
85887: LIST
85888: LIST
85889: LIST
85890: LIST
85891: PPUSH
85892: LD_EXP 63
85896: PUSH
85897: LD_VAR 0 4
85901: ARRAY
85902: PUSH
85903: LD_INT 1
85905: ARRAY
85906: PPUSH
85907: CALL 26990 0 2
85911: IFFALSE 86000
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
85913: LD_ADDR_EXP 63
85917: PUSH
85918: LD_EXP 63
85922: PPUSH
85923: LD_VAR 0 4
85927: PPUSH
85928: LD_EXP 63
85932: PUSH
85933: LD_VAR 0 4
85937: ARRAY
85938: PPUSH
85939: LD_INT 1
85941: PPUSH
85942: CALL_OW 3
85946: PPUSH
85947: CALL_OW 1
85951: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
85952: LD_ADDR_EXP 65
85956: PUSH
85957: LD_EXP 65
85961: PPUSH
85962: LD_VAR 0 4
85966: PUSH
85967: LD_EXP 65
85971: PUSH
85972: LD_VAR 0 4
85976: ARRAY
85977: PUSH
85978: LD_INT 1
85980: PLUS
85981: PUSH
85982: EMPTY
85983: LIST
85984: LIST
85985: PPUSH
85986: LD_VAR 0 1
85990: PPUSH
85991: CALL 20821 0 3
85995: ST_TO_ADDR
// exit ;
85996: POP
85997: POP
85998: GO 86004
// end ; end ;
86000: GO 85848
86002: POP
86003: POP
// end ;
86004: LD_VAR 0 3
86008: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
86009: LD_INT 0
86011: PPUSH
86012: PPUSH
86013: PPUSH
// if not mc_bases or not skirmish then
86014: LD_EXP 58
86018: NOT
86019: PUSH
86020: LD_EXP 56
86024: NOT
86025: OR
86026: IFFALSE 86030
// exit ;
86028: GO 86220
// for i = 1 to mc_bases do
86030: LD_ADDR_VAR 0 4
86034: PUSH
86035: DOUBLE
86036: LD_INT 1
86038: DEC
86039: ST_TO_ADDR
86040: LD_EXP 58
86044: PUSH
86045: FOR_TO
86046: IFFALSE 86133
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
86048: LD_VAR 0 1
86052: PUSH
86053: LD_EXP 66
86057: PUSH
86058: LD_VAR 0 4
86062: ARRAY
86063: IN
86064: PUSH
86065: LD_VAR 0 1
86069: PUSH
86070: LD_EXP 67
86074: PUSH
86075: LD_VAR 0 4
86079: ARRAY
86080: IN
86081: NOT
86082: AND
86083: IFFALSE 86131
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86085: LD_ADDR_EXP 67
86089: PUSH
86090: LD_EXP 67
86094: PPUSH
86095: LD_VAR 0 4
86099: PUSH
86100: LD_EXP 67
86104: PUSH
86105: LD_VAR 0 4
86109: ARRAY
86110: PUSH
86111: LD_INT 1
86113: PLUS
86114: PUSH
86115: EMPTY
86116: LIST
86117: LIST
86118: PPUSH
86119: LD_VAR 0 1
86123: PPUSH
86124: CALL 20821 0 3
86128: ST_TO_ADDR
// break ;
86129: GO 86133
// end ; end ;
86131: GO 86045
86133: POP
86134: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
86135: LD_VAR 0 1
86139: PPUSH
86140: CALL_OW 257
86144: PUSH
86145: LD_EXP 84
86149: IN
86150: PUSH
86151: LD_VAR 0 1
86155: PPUSH
86156: CALL_OW 266
86160: PUSH
86161: LD_INT 5
86163: EQUAL
86164: AND
86165: PUSH
86166: LD_VAR 0 2
86170: PPUSH
86171: CALL_OW 110
86175: PUSH
86176: LD_INT 18
86178: NONEQUAL
86179: AND
86180: IFFALSE 86220
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
86182: LD_VAR 0 2
86186: PPUSH
86187: CALL_OW 257
86191: PUSH
86192: LD_INT 5
86194: PUSH
86195: LD_INT 8
86197: PUSH
86198: LD_INT 9
86200: PUSH
86201: EMPTY
86202: LIST
86203: LIST
86204: LIST
86205: IN
86206: IFFALSE 86220
// SetClass ( unit , 1 ) ;
86208: LD_VAR 0 2
86212: PPUSH
86213: LD_INT 1
86215: PPUSH
86216: CALL_OW 336
// end ;
86220: LD_VAR 0 3
86224: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
86225: LD_INT 0
86227: PPUSH
86228: PPUSH
// if not mc_bases or not skirmish then
86229: LD_EXP 58
86233: NOT
86234: PUSH
86235: LD_EXP 56
86239: NOT
86240: OR
86241: IFFALSE 86245
// exit ;
86243: GO 86361
// if GetLives ( abandoned_vehicle ) > 250 then
86245: LD_VAR 0 2
86249: PPUSH
86250: CALL_OW 256
86254: PUSH
86255: LD_INT 250
86257: GREATER
86258: IFFALSE 86262
// exit ;
86260: GO 86361
// for i = 1 to mc_bases do
86262: LD_ADDR_VAR 0 6
86266: PUSH
86267: DOUBLE
86268: LD_INT 1
86270: DEC
86271: ST_TO_ADDR
86272: LD_EXP 58
86276: PUSH
86277: FOR_TO
86278: IFFALSE 86359
// begin if driver in mc_bases [ i ] then
86280: LD_VAR 0 1
86284: PUSH
86285: LD_EXP 58
86289: PUSH
86290: LD_VAR 0 6
86294: ARRAY
86295: IN
86296: IFFALSE 86357
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
86298: LD_VAR 0 1
86302: PPUSH
86303: LD_EXP 58
86307: PUSH
86308: LD_VAR 0 6
86312: ARRAY
86313: PPUSH
86314: LD_INT 2
86316: PUSH
86317: LD_INT 30
86319: PUSH
86320: LD_INT 0
86322: PUSH
86323: EMPTY
86324: LIST
86325: LIST
86326: PUSH
86327: LD_INT 30
86329: PUSH
86330: LD_INT 1
86332: PUSH
86333: EMPTY
86334: LIST
86335: LIST
86336: PUSH
86337: EMPTY
86338: LIST
86339: LIST
86340: LIST
86341: PPUSH
86342: CALL_OW 72
86346: PUSH
86347: LD_INT 1
86349: ARRAY
86350: PPUSH
86351: CALL_OW 112
// break ;
86355: GO 86359
// end ; end ;
86357: GO 86277
86359: POP
86360: POP
// end ; end_of_file
86361: LD_VAR 0 5
86365: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
86366: GO 86368
86368: DISABLE
// begin ru_radar := 98 ;
86369: LD_ADDR_EXP 101
86373: PUSH
86374: LD_INT 98
86376: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
86377: LD_ADDR_EXP 102
86381: PUSH
86382: LD_INT 89
86384: ST_TO_ADDR
// us_hack := 99 ;
86385: LD_ADDR_EXP 103
86389: PUSH
86390: LD_INT 99
86392: ST_TO_ADDR
// us_artillery := 97 ;
86393: LD_ADDR_EXP 104
86397: PUSH
86398: LD_INT 97
86400: ST_TO_ADDR
// ar_bio_bomb := 91 ;
86401: LD_ADDR_EXP 105
86405: PUSH
86406: LD_INT 91
86408: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
86409: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
86410: LD_INT 0
86412: PPUSH
86413: PPUSH
86414: PPUSH
86415: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
86416: LD_VAR 0 1
86420: PPUSH
86421: CALL_OW 264
86425: PUSH
86426: LD_EXP 105
86430: EQUAL
86431: IFFALSE 86503
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
86433: LD_INT 68
86435: PPUSH
86436: LD_VAR 0 1
86440: PPUSH
86441: CALL_OW 255
86445: PPUSH
86446: CALL_OW 321
86450: PUSH
86451: LD_INT 2
86453: EQUAL
86454: IFFALSE 86466
// eff := 70 else
86456: LD_ADDR_VAR 0 6
86460: PUSH
86461: LD_INT 70
86463: ST_TO_ADDR
86464: GO 86474
// eff := 30 ;
86466: LD_ADDR_VAR 0 6
86470: PUSH
86471: LD_INT 30
86473: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
86474: LD_VAR 0 1
86478: PPUSH
86479: CALL_OW 250
86483: PPUSH
86484: LD_VAR 0 1
86488: PPUSH
86489: CALL_OW 251
86493: PPUSH
86494: LD_VAR 0 6
86498: PPUSH
86499: CALL_OW 495
// end ; end ;
86503: LD_VAR 0 4
86507: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
86508: LD_INT 0
86510: PPUSH
86511: PPUSH
86512: PPUSH
86513: PPUSH
86514: PPUSH
86515: PPUSH
// if cmd = 124 then
86516: LD_VAR 0 1
86520: PUSH
86521: LD_INT 124
86523: EQUAL
86524: IFFALSE 86730
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
86526: LD_ADDR_VAR 0 5
86530: PUSH
86531: LD_INT 2
86533: PUSH
86534: LD_INT 34
86536: PUSH
86537: LD_INT 53
86539: PUSH
86540: EMPTY
86541: LIST
86542: LIST
86543: PUSH
86544: LD_INT 34
86546: PUSH
86547: LD_INT 14
86549: PUSH
86550: EMPTY
86551: LIST
86552: LIST
86553: PUSH
86554: EMPTY
86555: LIST
86556: LIST
86557: LIST
86558: PPUSH
86559: CALL_OW 69
86563: ST_TO_ADDR
// if not tmp then
86564: LD_VAR 0 5
86568: NOT
86569: IFFALSE 86573
// exit ;
86571: GO 86730
// for i in tmp do
86573: LD_ADDR_VAR 0 3
86577: PUSH
86578: LD_VAR 0 5
86582: PUSH
86583: FOR_IN
86584: IFFALSE 86728
// begin taskList := GetTaskList ( i ) ;
86586: LD_ADDR_VAR 0 6
86590: PUSH
86591: LD_VAR 0 3
86595: PPUSH
86596: CALL_OW 437
86600: ST_TO_ADDR
// if not taskList then
86601: LD_VAR 0 6
86605: NOT
86606: IFFALSE 86610
// continue ;
86608: GO 86583
// for j = 1 to taskList do
86610: LD_ADDR_VAR 0 4
86614: PUSH
86615: DOUBLE
86616: LD_INT 1
86618: DEC
86619: ST_TO_ADDR
86620: LD_VAR 0 6
86624: PUSH
86625: FOR_TO
86626: IFFALSE 86724
// if taskList [ j ] [ 1 ] = | then
86628: LD_VAR 0 6
86632: PUSH
86633: LD_VAR 0 4
86637: ARRAY
86638: PUSH
86639: LD_INT 1
86641: ARRAY
86642: PUSH
86643: LD_STRING |
86645: EQUAL
86646: IFFALSE 86722
// begin _taskList := Delete ( taskList , 1 ) ;
86648: LD_ADDR_VAR 0 7
86652: PUSH
86653: LD_VAR 0 6
86657: PPUSH
86658: LD_INT 1
86660: PPUSH
86661: CALL_OW 3
86665: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
86666: LD_VAR 0 3
86670: PPUSH
86671: LD_VAR 0 7
86675: PPUSH
86676: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
86680: LD_VAR 0 3
86684: PPUSH
86685: LD_VAR 0 6
86689: PUSH
86690: LD_VAR 0 4
86694: ARRAY
86695: PUSH
86696: LD_INT 2
86698: ARRAY
86699: PPUSH
86700: LD_VAR 0 6
86704: PUSH
86705: LD_VAR 0 4
86709: ARRAY
86710: PUSH
86711: LD_INT 3
86713: ARRAY
86714: PPUSH
86715: LD_INT 8
86717: PPUSH
86718: CALL 86735 0 4
// end ;
86722: GO 86625
86724: POP
86725: POP
// end ;
86726: GO 86583
86728: POP
86729: POP
// end ; end ;
86730: LD_VAR 0 2
86734: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
86735: LD_INT 0
86737: PPUSH
86738: PPUSH
86739: PPUSH
86740: PPUSH
86741: PPUSH
86742: PPUSH
86743: PPUSH
86744: PPUSH
86745: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
86746: LD_VAR 0 1
86750: NOT
86751: PUSH
86752: LD_VAR 0 2
86756: PPUSH
86757: LD_VAR 0 3
86761: PPUSH
86762: CALL_OW 488
86766: NOT
86767: OR
86768: PUSH
86769: LD_VAR 0 4
86773: NOT
86774: OR
86775: IFFALSE 86779
// exit ;
86777: GO 87119
// list := [ ] ;
86779: LD_ADDR_VAR 0 13
86783: PUSH
86784: EMPTY
86785: ST_TO_ADDR
// if x - r < 0 then
86786: LD_VAR 0 2
86790: PUSH
86791: LD_VAR 0 4
86795: MINUS
86796: PUSH
86797: LD_INT 0
86799: LESS
86800: IFFALSE 86812
// min_x := 0 else
86802: LD_ADDR_VAR 0 7
86806: PUSH
86807: LD_INT 0
86809: ST_TO_ADDR
86810: GO 86828
// min_x := x - r ;
86812: LD_ADDR_VAR 0 7
86816: PUSH
86817: LD_VAR 0 2
86821: PUSH
86822: LD_VAR 0 4
86826: MINUS
86827: ST_TO_ADDR
// if y - r < 0 then
86828: LD_VAR 0 3
86832: PUSH
86833: LD_VAR 0 4
86837: MINUS
86838: PUSH
86839: LD_INT 0
86841: LESS
86842: IFFALSE 86854
// min_y := 0 else
86844: LD_ADDR_VAR 0 8
86848: PUSH
86849: LD_INT 0
86851: ST_TO_ADDR
86852: GO 86870
// min_y := y - r ;
86854: LD_ADDR_VAR 0 8
86858: PUSH
86859: LD_VAR 0 3
86863: PUSH
86864: LD_VAR 0 4
86868: MINUS
86869: ST_TO_ADDR
// max_x := x + r ;
86870: LD_ADDR_VAR 0 9
86874: PUSH
86875: LD_VAR 0 2
86879: PUSH
86880: LD_VAR 0 4
86884: PLUS
86885: ST_TO_ADDR
// max_y := y + r ;
86886: LD_ADDR_VAR 0 10
86890: PUSH
86891: LD_VAR 0 3
86895: PUSH
86896: LD_VAR 0 4
86900: PLUS
86901: ST_TO_ADDR
// for _x = min_x to max_x do
86902: LD_ADDR_VAR 0 11
86906: PUSH
86907: DOUBLE
86908: LD_VAR 0 7
86912: DEC
86913: ST_TO_ADDR
86914: LD_VAR 0 9
86918: PUSH
86919: FOR_TO
86920: IFFALSE 87037
// for _y = min_y to max_y do
86922: LD_ADDR_VAR 0 12
86926: PUSH
86927: DOUBLE
86928: LD_VAR 0 8
86932: DEC
86933: ST_TO_ADDR
86934: LD_VAR 0 10
86938: PUSH
86939: FOR_TO
86940: IFFALSE 87033
// begin if not ValidHex ( _x , _y ) then
86942: LD_VAR 0 11
86946: PPUSH
86947: LD_VAR 0 12
86951: PPUSH
86952: CALL_OW 488
86956: NOT
86957: IFFALSE 86961
// continue ;
86959: GO 86939
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
86961: LD_VAR 0 11
86965: PPUSH
86966: LD_VAR 0 12
86970: PPUSH
86971: CALL_OW 351
86975: PUSH
86976: LD_VAR 0 11
86980: PPUSH
86981: LD_VAR 0 12
86985: PPUSH
86986: CALL_OW 554
86990: AND
86991: IFFALSE 87031
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
86993: LD_ADDR_VAR 0 13
86997: PUSH
86998: LD_VAR 0 13
87002: PPUSH
87003: LD_VAR 0 13
87007: PUSH
87008: LD_INT 1
87010: PLUS
87011: PPUSH
87012: LD_VAR 0 11
87016: PUSH
87017: LD_VAR 0 12
87021: PUSH
87022: EMPTY
87023: LIST
87024: LIST
87025: PPUSH
87026: CALL_OW 2
87030: ST_TO_ADDR
// end ;
87031: GO 86939
87033: POP
87034: POP
87035: GO 86919
87037: POP
87038: POP
// if not list then
87039: LD_VAR 0 13
87043: NOT
87044: IFFALSE 87048
// exit ;
87046: GO 87119
// for i in list do
87048: LD_ADDR_VAR 0 6
87052: PUSH
87053: LD_VAR 0 13
87057: PUSH
87058: FOR_IN
87059: IFFALSE 87117
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
87061: LD_VAR 0 1
87065: PPUSH
87066: LD_STRING M
87068: PUSH
87069: LD_VAR 0 6
87073: PUSH
87074: LD_INT 1
87076: ARRAY
87077: PUSH
87078: LD_VAR 0 6
87082: PUSH
87083: LD_INT 2
87085: ARRAY
87086: PUSH
87087: LD_INT 0
87089: PUSH
87090: LD_INT 0
87092: PUSH
87093: LD_INT 0
87095: PUSH
87096: LD_INT 0
87098: PUSH
87099: EMPTY
87100: LIST
87101: LIST
87102: LIST
87103: LIST
87104: LIST
87105: LIST
87106: LIST
87107: PUSH
87108: EMPTY
87109: LIST
87110: PPUSH
87111: CALL_OW 447
87115: GO 87058
87117: POP
87118: POP
// end ;
87119: LD_VAR 0 5
87123: RET
