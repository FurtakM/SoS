// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 600 0 0
// InitMacro ;
  19: CALL 56482 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 48334 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 48334 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 48334 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 48334 0 9
// PrepareArabian ;
 147: CALL 3510 0 0
// PrepareRussian ;
 151: CALL 2645 0 0
// PrepareAlliance ;
 155: CALL 710 0 0
// MC_Start ( ) ;
 159: CALL 58594 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6673 0 0
// end ;
 180: END
// export function CustomInitMacro ; var i ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 185: LD_ADDR_EXP 82
 189: PUSH
 190: LD_INT 1
 192: PUSH
 193: LD_INT 2
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 200: LD_ADDR_EXP 83
 204: PUSH
 205: LD_INT 3
 207: PUSH
 208: LD_INT 4
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 215: LD_INT 1
 217: PPUSH
 218: LD_INT 12
 220: PUSH
 221: LD_INT 15
 223: PUSH
 224: LD_INT 18
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: PUSH
 232: LD_OWVAR 67
 236: ARRAY
 237: PPUSH
 238: LD_INT 7
 240: PPUSH
 241: CALL 79337 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 245: LD_INT 1
 247: PPUSH
 248: LD_EXP 53
 252: PPUSH
 253: CALL 79763 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 257: LD_INT 1
 259: PPUSH
 260: LD_INT 6
 262: PPUSH
 263: CALL 80158 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 267: LD_INT 1
 269: PPUSH
 270: LD_INT 9
 272: PUSH
 273: EMPTY
 274: LIST
 275: PPUSH
 276: CALL 80427 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 13
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 2
 291: PUSH
 292: LD_INT 32
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: PUSH
 301: EMPTY
 302: LIST
 303: PPUSH
 304: CALL 79703 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 308: LD_INT 2
 310: PPUSH
 311: LD_INT 12
 313: PUSH
 314: LD_INT 14
 316: PUSH
 317: LD_INT 10
 319: PUSH
 320: LD_INT 11
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 80334 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_EXP 50
 340: PPUSH
 341: CALL 79763 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 345: LD_INT 2
 347: PPUSH
 348: LD_INT 8
 350: PPUSH
 351: CALL 80158 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 355: LD_INT 2
 357: PPUSH
 358: LD_INT 10
 360: PUSH
 361: EMPTY
 362: LIST
 363: PPUSH
 364: CALL 80427 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 368: LD_INT 2
 370: PPUSH
 371: LD_INT 6
 373: PUSH
 374: LD_INT 71
 376: PUSH
 377: LD_INT 116
 379: PUSH
 380: LD_INT 4
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_INT 4
 391: PUSH
 392: LD_INT 85
 394: PUSH
 395: LD_INT 116
 397: PUSH
 398: LD_INT 4
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: LD_INT 32
 409: PUSH
 410: LD_INT 83
 412: PUSH
 413: LD_INT 111
 415: PUSH
 416: LD_INT 4
 418: PUSH
 419: EMPTY
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: PUSH
 425: LD_INT 32
 427: PUSH
 428: LD_INT 87
 430: PUSH
 431: LD_INT 121
 433: PUSH
 434: LD_INT 4
 436: PUSH
 437: EMPTY
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 88
 448: PUSH
 449: LD_INT 128
 451: PUSH
 452: LD_INT 4
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: PUSH
 461: LD_INT 32
 463: PUSH
 464: LD_INT 59
 466: PUSH
 467: LD_INT 89
 469: PUSH
 470: LD_INT 3
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_INT 33
 481: PUSH
 482: LD_INT 69
 484: PUSH
 485: LD_INT 98
 487: PUSH
 488: LD_INT 3
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: PUSH
 497: LD_INT 33
 499: PUSH
 500: LD_INT 77
 502: PUSH
 503: LD_INT 103
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 33
 517: PUSH
 518: LD_INT 83
 520: PUSH
 521: LD_INT 105
 523: PUSH
 524: LD_INT 3
 526: PUSH
 527: EMPTY
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 33
 535: PUSH
 536: LD_INT 71
 538: PUSH
 539: LD_INT 125
 541: PUSH
 542: LD_INT 5
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PPUSH
 563: CALL 79547 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
 567: LD_INT 2
 569: PPUSH
 570: LD_INT 21
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 3
 578: PUSH
 579: LD_INT 51
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PUSH
 588: EMPTY
 589: LIST
 590: PPUSH
 591: CALL 79703 0 2
// end ;
 595: LD_VAR 0 1
 599: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 600: LD_INT 0
 602: PPUSH
// debug := false ;
 603: LD_ADDR_EXP 1
 607: PUSH
 608: LD_INT 0
 610: ST_TO_ADDR
// game := true ;
 611: LD_ADDR_EXP 2
 615: PUSH
 616: LD_INT 1
 618: ST_TO_ADDR
// gossudarov_arrive := false ;
 619: LD_ADDR_EXP 4
 623: PUSH
 624: LD_INT 0
 626: ST_TO_ADDR
// ru_lab_builded := false ;
 627: LD_ADDR_EXP 5
 631: PUSH
 632: LD_INT 0
 634: ST_TO_ADDR
// player_spotted := false ;
 635: LD_ADDR_EXP 6
 639: PUSH
 640: LD_INT 0
 642: ST_TO_ADDR
// first_attack := false ;
 643: LD_ADDR_EXP 7
 647: PUSH
 648: LD_INT 0
 650: ST_TO_ADDR
// ru_attackers := [ ] ;
 651: LD_ADDR_EXP 51
 655: PUSH
 656: EMPTY
 657: ST_TO_ADDR
// ar_base_spotted := false ;
 658: LD_ADDR_EXP 8
 662: PUSH
 663: LD_INT 0
 665: ST_TO_ADDR
// ar_active_attack := false ;
 666: LD_ADDR_EXP 9
 670: PUSH
 671: LD_INT 0
 673: ST_TO_ADDR
// ar_attackers := [ ] ;
 674: LD_ADDR_EXP 10
 678: PUSH
 679: EMPTY
 680: ST_TO_ADDR
// first_powell_attack := false ;
 681: LD_ADDR_EXP 11
 685: PUSH
 686: LD_INT 0
 688: ST_TO_ADDR
// abdul_escaped := true ;
 689: LD_ADDR_EXP 12
 693: PUSH
 694: LD_INT 1
 696: ST_TO_ADDR
// loss_counter := 0 ;
 697: LD_ADDR_EXP 13
 701: PUSH
 702: LD_INT 0
 704: ST_TO_ADDR
// end ; end_of_file
 705: LD_VAR 0 1
 709: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 710: LD_INT 0
 712: PPUSH
 713: PPUSH
 714: PPUSH
 715: PPUSH
// uc_side := 7 ;
 716: LD_ADDR_OWVAR 20
 720: PUSH
 721: LD_INT 7
 723: ST_TO_ADDR
// uc_nation := 1 ;
 724: LD_ADDR_OWVAR 21
 728: PUSH
 729: LD_INT 1
 731: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 732: LD_ADDR_EXP 14
 736: PUSH
 737: LD_STRING JMM
 739: PPUSH
 740: LD_EXP 1
 744: NOT
 745: PPUSH
 746: LD_STRING 12a_
 748: PPUSH
 749: CALL 13917 0 3
 753: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 754: LD_EXP 14
 758: PPUSH
 759: LD_INT 71
 761: PPUSH
 762: LD_INT 23
 764: PPUSH
 765: LD_INT 0
 767: PPUSH
 768: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 772: LD_EXP 14
 776: PPUSH
 777: LD_INT 2
 779: PPUSH
 780: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 784: LD_ADDR_EXP 15
 788: PUSH
 789: LD_STRING Roth
 791: PPUSH
 792: LD_EXP 1
 796: NOT
 797: PPUSH
 798: LD_STRING 12a_
 800: PPUSH
 801: CALL 13917 0 3
 805: ST_TO_ADDR
// if Roth then
 806: LD_EXP 15
 810: IFFALSE 830
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 812: LD_EXP 15
 816: PPUSH
 817: LD_INT 71
 819: PPUSH
 820: LD_INT 21
 822: PPUSH
 823: LD_INT 0
 825: PPUSH
 826: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 830: LD_ADDR_EXP 16
 834: PUSH
 835: LD_STRING Lisa
 837: PPUSH
 838: LD_EXP 1
 842: NOT
 843: PPUSH
 844: LD_STRING 12a_
 846: PPUSH
 847: CALL 13917 0 3
 851: ST_TO_ADDR
// if Lisa then
 852: LD_EXP 16
 856: IFFALSE 873
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 858: LD_EXP 16
 862: PPUSH
 863: LD_INT 13
 865: PPUSH
 866: LD_INT 0
 868: PPUSH
 869: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 873: LD_ADDR_EXP 17
 877: PUSH
 878: LD_STRING Donaldson
 880: PPUSH
 881: LD_EXP 1
 885: NOT
 886: PPUSH
 887: LD_STRING 12a_
 889: PPUSH
 890: CALL 13917 0 3
 894: ST_TO_ADDR
// if Donaldson then
 895: LD_EXP 17
 899: IFFALSE 916
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 901: LD_EXP 17
 905: PPUSH
 906: LD_INT 13
 908: PPUSH
 909: LD_INT 0
 911: PPUSH
 912: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 916: LD_ADDR_EXP 18
 920: PUSH
 921: LD_STRING Bobby
 923: PPUSH
 924: LD_EXP 1
 928: NOT
 929: PPUSH
 930: LD_STRING 12a_
 932: PPUSH
 933: CALL 13917 0 3
 937: ST_TO_ADDR
// if Bobby then
 938: LD_EXP 18
 942: IFFALSE 959
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 944: LD_EXP 18
 948: PPUSH
 949: LD_INT 13
 951: PPUSH
 952: LD_INT 0
 954: PPUSH
 955: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 959: LD_ADDR_EXP 19
 963: PUSH
 964: LD_STRING Cyrus
 966: PPUSH
 967: LD_EXP 1
 971: NOT
 972: PPUSH
 973: LD_STRING 12a_
 975: PPUSH
 976: CALL 13917 0 3
 980: ST_TO_ADDR
// if Cyrus then
 981: LD_EXP 19
 985: IFFALSE 1002
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
 987: LD_EXP 19
 991: PPUSH
 992: LD_INT 13
 994: PPUSH
 995: LD_INT 0
 997: PPUSH
 998: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1002: LD_ADDR_EXP 20
1006: PUSH
1007: LD_STRING Denis
1009: PPUSH
1010: LD_EXP 1
1014: NOT
1015: PPUSH
1016: LD_STRING 12a_
1018: PPUSH
1019: CALL 13917 0 3
1023: ST_TO_ADDR
// if Denis then
1024: LD_EXP 20
1028: IFFALSE 1045
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1030: LD_EXP 20
1034: PPUSH
1035: LD_INT 13
1037: PPUSH
1038: LD_INT 0
1040: PPUSH
1041: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1045: LD_ADDR_EXP 21
1049: PUSH
1050: LD_STRING Brown
1052: PPUSH
1053: LD_EXP 1
1057: NOT
1058: PPUSH
1059: LD_STRING 12a_
1061: PPUSH
1062: CALL 13917 0 3
1066: ST_TO_ADDR
// if Brown then
1067: LD_EXP 21
1071: IFFALSE 1088
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1073: LD_EXP 21
1077: PPUSH
1078: LD_INT 13
1080: PPUSH
1081: LD_INT 0
1083: PPUSH
1084: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1088: LD_ADDR_EXP 22
1092: PUSH
1093: LD_STRING Gladstone
1095: PPUSH
1096: LD_EXP 1
1100: NOT
1101: PPUSH
1102: LD_STRING 12a_
1104: PPUSH
1105: CALL 13917 0 3
1109: ST_TO_ADDR
// if Gladstone then
1110: LD_EXP 22
1114: IFFALSE 1131
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1116: LD_EXP 22
1120: PPUSH
1121: LD_INT 13
1123: PPUSH
1124: LD_INT 0
1126: PPUSH
1127: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1131: LD_ADDR_EXP 23
1135: PUSH
1136: LD_STRING Houten
1138: PPUSH
1139: LD_EXP 1
1143: NOT
1144: PPUSH
1145: LD_STRING 12a_
1147: PPUSH
1148: CALL 13917 0 3
1152: ST_TO_ADDR
// if Houten then
1153: LD_EXP 23
1157: IFFALSE 1174
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1159: LD_EXP 23
1163: PPUSH
1164: LD_INT 13
1166: PPUSH
1167: LD_INT 0
1169: PPUSH
1170: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1174: LD_ADDR_EXP 24
1178: PUSH
1179: LD_STRING Cornell
1181: PPUSH
1182: LD_EXP 1
1186: NOT
1187: PPUSH
1188: LD_STRING 12a_
1190: PPUSH
1191: CALL 13917 0 3
1195: ST_TO_ADDR
// if Cornel then
1196: LD_EXP 24
1200: IFFALSE 1217
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1202: LD_EXP 24
1206: PPUSH
1207: LD_INT 13
1209: PPUSH
1210: LD_INT 0
1212: PPUSH
1213: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1217: LD_ADDR_EXP 25
1221: PUSH
1222: LD_STRING Gary
1224: PPUSH
1225: LD_EXP 1
1229: NOT
1230: PPUSH
1231: LD_STRING 12a_
1233: PPUSH
1234: CALL 13917 0 3
1238: ST_TO_ADDR
// if Gary then
1239: LD_EXP 25
1243: IFFALSE 1260
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1245: LD_EXP 25
1249: PPUSH
1250: LD_INT 13
1252: PPUSH
1253: LD_INT 0
1255: PPUSH
1256: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1260: LD_ADDR_EXP 26
1264: PUSH
1265: LD_STRING Frank
1267: PPUSH
1268: LD_EXP 1
1272: NOT
1273: PPUSH
1274: LD_STRING 12a_
1276: PPUSH
1277: CALL 13917 0 3
1281: ST_TO_ADDR
// if Frank then
1282: LD_EXP 26
1286: IFFALSE 1303
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1288: LD_EXP 26
1292: PPUSH
1293: LD_INT 13
1295: PPUSH
1296: LD_INT 0
1298: PPUSH
1299: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1303: LD_ADDR_EXP 27
1307: PUSH
1308: LD_STRING Kikuchi
1310: PPUSH
1311: LD_EXP 1
1315: NOT
1316: PPUSH
1317: LD_STRING 12a_
1319: PPUSH
1320: CALL 13917 0 3
1324: ST_TO_ADDR
// if Kikuchi then
1325: LD_EXP 27
1329: IFFALSE 1346
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1331: LD_EXP 27
1335: PPUSH
1336: LD_INT 13
1338: PPUSH
1339: LD_INT 0
1341: PPUSH
1342: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1346: LD_ADDR_EXP 28
1350: PUSH
1351: LD_STRING Simms
1353: PPUSH
1354: LD_EXP 1
1358: NOT
1359: PPUSH
1360: LD_STRING 12a_
1362: PPUSH
1363: CALL 13917 0 3
1367: ST_TO_ADDR
// if Simms then
1368: LD_EXP 28
1372: IFFALSE 1389
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1374: LD_EXP 28
1378: PPUSH
1379: LD_INT 13
1381: PPUSH
1382: LD_INT 0
1384: PPUSH
1385: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1389: LD_ADDR_EXP 29
1393: PUSH
1394: LD_STRING Joan
1396: PPUSH
1397: LD_EXP 1
1401: NOT
1402: PPUSH
1403: LD_STRING 12a_
1405: PPUSH
1406: CALL 13917 0 3
1410: ST_TO_ADDR
// if Joan then
1411: LD_EXP 29
1415: IFFALSE 1432
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1417: LD_EXP 29
1421: PPUSH
1422: LD_INT 13
1424: PPUSH
1425: LD_INT 0
1427: PPUSH
1428: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1432: LD_ADDR_EXP 30
1436: PUSH
1437: LD_STRING DeltaDoctor
1439: PPUSH
1440: LD_EXP 1
1444: NOT
1445: PPUSH
1446: LD_STRING 12a_
1448: PPUSH
1449: CALL 13917 0 3
1453: ST_TO_ADDR
// if DeltaDoctor then
1454: LD_EXP 30
1458: IFFALSE 1475
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1460: LD_EXP 30
1464: PPUSH
1465: LD_INT 13
1467: PPUSH
1468: LD_INT 0
1470: PPUSH
1471: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1475: LD_ADDR_VAR 0 4
1479: PUSH
1480: LD_STRING 12a_others
1482: PPUSH
1483: CALL_OW 31
1487: ST_TO_ADDR
// if tmp then
1488: LD_VAR 0 4
1492: IFFALSE 1526
// for i in tmp do
1494: LD_ADDR_VAR 0 3
1498: PUSH
1499: LD_VAR 0 4
1503: PUSH
1504: FOR_IN
1505: IFFALSE 1524
// PlaceUnitArea ( i , alliance_start , false ) ;
1507: LD_VAR 0 3
1511: PPUSH
1512: LD_INT 13
1514: PPUSH
1515: LD_INT 0
1517: PPUSH
1518: CALL_OW 49
1522: GO 1504
1524: POP
1525: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1526: LD_INT 3
1528: PPUSH
1529: LD_INT 3
1531: PPUSH
1532: LD_INT 3
1534: PPUSH
1535: LD_INT 12
1537: PPUSH
1538: LD_INT 100
1540: PPUSH
1541: CALL 20520 0 5
// veh := CreateVehicle ;
1545: LD_ADDR_VAR 0 2
1549: PUSH
1550: CALL_OW 45
1554: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1555: LD_VAR 0 2
1559: PPUSH
1560: LD_INT 2
1562: PPUSH
1563: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1567: LD_VAR 0 2
1571: PPUSH
1572: LD_INT 60
1574: PPUSH
1575: LD_INT 6
1577: PPUSH
1578: LD_INT 0
1580: PPUSH
1581: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1585: LD_VAR 0 2
1589: PPUSH
1590: LD_INT 4
1592: PPUSH
1593: LD_INT 30
1595: PPUSH
1596: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1600: LD_STRING 11_artifact_captured
1602: PPUSH
1603: LD_INT 0
1605: PPUSH
1606: CALL_OW 30
1610: IFFALSE 1686
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1612: LD_INT 3
1614: PPUSH
1615: LD_INT 3
1617: PPUSH
1618: LD_INT 3
1620: PPUSH
1621: LD_INT 12
1623: PPUSH
1624: LD_INT 100
1626: PPUSH
1627: CALL 20520 0 5
// veh := CreateVehicle ;
1631: LD_ADDR_VAR 0 2
1635: PUSH
1636: CALL_OW 45
1640: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1641: LD_VAR 0 2
1645: PPUSH
1646: LD_INT 3
1648: PPUSH
1649: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1653: LD_VAR 0 2
1657: PPUSH
1658: LD_INT 75
1660: PPUSH
1661: LD_INT 6
1663: PPUSH
1664: LD_INT 0
1666: PPUSH
1667: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1671: LD_VAR 0 2
1675: PPUSH
1676: LD_INT 4
1678: PPUSH
1679: LD_INT 50
1681: PPUSH
1682: CALL_OW 290
// end ; end ;
1686: LD_VAR 0 1
1690: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1691: LD_INT 0
1693: PPUSH
1694: PPUSH
1695: PPUSH
1696: PPUSH
// uc_side := 6 ;
1697: LD_ADDR_OWVAR 20
1701: PUSH
1702: LD_INT 6
1704: ST_TO_ADDR
// uc_nation := 3 ;
1705: LD_ADDR_OWVAR 21
1709: PUSH
1710: LD_INT 3
1712: ST_TO_ADDR
// InitHc ;
1713: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1717: LD_ADDR_EXP 31
1721: PUSH
1722: LD_STRING Gossudarov
1724: PPUSH
1725: CALL_OW 25
1729: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1730: LD_ADDR_EXP 32
1734: PUSH
1735: LD_STRING Kirilenkova
1737: PPUSH
1738: CALL_OW 25
1742: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1743: LD_ADDR_EXP 33
1747: PUSH
1748: LD_STRING Titov
1750: PPUSH
1751: CALL_OW 25
1755: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1756: LD_ADDR_EXP 38
1760: PUSH
1761: LD_STRING Oblukov
1763: PPUSH
1764: CALL_OW 25
1768: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1769: LD_ADDR_EXP 35
1773: PUSH
1774: LD_STRING Dolgov
1776: PPUSH
1777: CALL_OW 25
1781: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1782: LD_ADDR_EXP 36
1786: PUSH
1787: LD_STRING Petrosyan
1789: PPUSH
1790: CALL_OW 25
1794: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1795: LD_ADDR_EXP 37
1799: PUSH
1800: LD_STRING Scholtze
1802: PPUSH
1803: CALL_OW 25
1807: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1808: LD_ADDR_EXP 39
1812: PUSH
1813: LD_STRING Kapitsova
1815: PPUSH
1816: CALL_OW 25
1820: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1821: LD_ADDR_VAR 0 2
1825: PUSH
1826: LD_EXP 31
1830: PUSH
1831: LD_EXP 32
1835: PUSH
1836: LD_EXP 33
1840: PUSH
1841: LD_EXP 38
1845: PUSH
1846: LD_EXP 35
1850: PUSH
1851: LD_EXP 36
1855: PUSH
1856: LD_EXP 37
1860: PUSH
1861: LD_EXP 39
1865: PUSH
1866: EMPTY
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: LIST
1873: LIST
1874: LIST
1875: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1876: LD_INT 1
1878: PPUSH
1879: LD_INT 4
1881: PPUSH
1882: LD_INT 8
1884: PPUSH
1885: CALL_OW 380
// un := CreateHuman ;
1889: LD_ADDR_VAR 0 4
1893: PUSH
1894: CALL_OW 44
1898: ST_TO_ADDR
// tmp := tmp ^ un ;
1899: LD_ADDR_VAR 0 2
1903: PUSH
1904: LD_VAR 0 2
1908: PUSH
1909: LD_VAR 0 4
1913: ADD
1914: ST_TO_ADDR
// for i in tmp do
1915: LD_ADDR_VAR 0 3
1919: PUSH
1920: LD_VAR 0 2
1924: PUSH
1925: FOR_IN
1926: IFFALSE 1945
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1928: LD_VAR 0 3
1932: PPUSH
1933: LD_INT 14
1935: PPUSH
1936: LD_INT 0
1938: PPUSH
1939: CALL_OW 49
1943: GO 1925
1945: POP
1946: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1947: LD_VAR 0 2
1951: PPUSH
1952: LD_EXP 3
1956: PPUSH
1957: CALL_OW 250
1961: PPUSH
1962: LD_EXP 3
1966: PPUSH
1967: CALL_OW 251
1971: PPUSH
1972: CALL_OW 111
// end ;
1976: LD_VAR 0 1
1980: RET
// export function PrepareBelkov ; begin
1981: LD_INT 0
1983: PPUSH
// uc_side := 4 ;
1984: LD_ADDR_OWVAR 20
1988: PUSH
1989: LD_INT 4
1991: ST_TO_ADDR
// uc_nation := 3 ;
1992: LD_ADDR_OWVAR 21
1996: PUSH
1997: LD_INT 3
1999: ST_TO_ADDR
// InitHc ;
2000: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2004: LD_ADDR_EXP 46
2008: PUSH
2009: LD_STRING Belkov
2011: PPUSH
2012: CALL_OW 25
2016: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2017: LD_EXP 46
2021: PPUSH
2022: LD_INT 14
2024: PPUSH
2025: LD_INT 0
2027: PPUSH
2028: CALL_OW 49
// end ;
2032: LD_VAR 0 1
2036: RET
// export function PrepareGnyevko ; begin
2037: LD_INT 0
2039: PPUSH
// uc_side := 4 ;
2040: LD_ADDR_OWVAR 20
2044: PUSH
2045: LD_INT 4
2047: ST_TO_ADDR
// uc_nation := 3 ;
2048: LD_ADDR_OWVAR 21
2052: PUSH
2053: LD_INT 3
2055: ST_TO_ADDR
// InitHc ;
2056: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2060: LD_ADDR_EXP 47
2064: PUSH
2065: LD_STRING Gnyevko
2067: PPUSH
2068: CALL_OW 25
2072: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2073: LD_EXP 47
2077: PPUSH
2078: LD_INT 14
2080: PPUSH
2081: LD_INT 0
2083: PPUSH
2084: CALL_OW 49
// end ;
2088: LD_VAR 0 1
2092: RET
// export function PrepareBurlak ; var i , tmp ; begin
2093: LD_INT 0
2095: PPUSH
2096: PPUSH
2097: PPUSH
// uc_side := 4 ;
2098: LD_ADDR_OWVAR 20
2102: PUSH
2103: LD_INT 4
2105: ST_TO_ADDR
// uc_nation := 3 ;
2106: LD_ADDR_OWVAR 21
2110: PUSH
2111: LD_INT 3
2113: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
2114: LD_INT 35
2116: PPUSH
2117: CALL_OW 67
// until not FilterAllUnits ( [ f_distxy , 123 , 3 , 3 ] ) ;
2121: LD_INT 92
2123: PUSH
2124: LD_INT 123
2126: PUSH
2127: LD_INT 3
2129: PUSH
2130: LD_INT 3
2132: PUSH
2133: EMPTY
2134: LIST
2135: LIST
2136: LIST
2137: LIST
2138: PPUSH
2139: CALL_OW 69
2143: NOT
2144: IFFALSE 2114
// InitHc ;
2146: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2150: LD_ADDR_EXP 45
2154: PUSH
2155: LD_STRING Burlak
2157: PPUSH
2158: CALL_OW 25
2162: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2163: LD_INT 24
2165: PUSH
2166: LD_INT 23
2168: PUSH
2169: LD_INT 22
2171: PUSH
2172: EMPTY
2173: LIST
2174: LIST
2175: LIST
2176: PUSH
2177: LD_OWVAR 67
2181: ARRAY
2182: PPUSH
2183: LD_INT 1
2185: PPUSH
2186: LD_INT 1
2188: PPUSH
2189: LD_INT 45
2191: PUSH
2192: LD_INT 44
2194: PUSH
2195: LD_INT 43
2197: PUSH
2198: EMPTY
2199: LIST
2200: LIST
2201: LIST
2202: PUSH
2203: LD_OWVAR 67
2207: ARRAY
2208: PPUSH
2209: LD_INT 0
2211: PPUSH
2212: CALL 20520 0 5
// Masha := CreateVehicle ;
2216: LD_ADDR_EXP 48
2220: PUSH
2221: CALL_OW 45
2225: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2226: LD_EXP 48
2230: PUSH
2231: LD_EXP 45
2235: PUSH
2236: EMPTY
2237: LIST
2238: LIST
2239: PPUSH
2240: LD_INT 499
2242: PPUSH
2243: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2247: LD_EXP 48
2251: PPUSH
2252: LD_INT 3
2254: PPUSH
2255: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2259: LD_EXP 48
2263: PPUSH
2264: LD_INT 1
2266: PPUSH
2267: CALL_OW 242
// PlaceUnitArea ( Masha , burlak_spawn , false ) ;
2271: LD_EXP 48
2275: PPUSH
2276: LD_INT 18
2278: PPUSH
2279: LD_INT 0
2281: PPUSH
2282: CALL_OW 49
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2286: LD_EXP 45
2290: PPUSH
2291: LD_INT 125
2293: PPUSH
2294: LD_INT 1
2296: PPUSH
2297: LD_INT 0
2299: PPUSH
2300: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2304: LD_EXP 45
2308: PPUSH
2309: LD_EXP 48
2313: PPUSH
2314: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2318: LD_INT 10
2320: PPUSH
2321: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2325: LD_EXP 48
2329: PPUSH
2330: LD_INT 110
2332: PPUSH
2333: LD_INT 10
2335: PPUSH
2336: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2340: LD_ADDR_EXP 41
2344: PUSH
2345: LD_STRING Petrovova
2347: PPUSH
2348: CALL_OW 25
2352: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2353: LD_ADDR_EXP 43
2357: PUSH
2358: LD_STRING Kuzmov
2360: PPUSH
2361: CALL_OW 25
2365: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2366: LD_ADDR_EXP 42
2370: PUSH
2371: LD_STRING Kovalyuk
2373: PPUSH
2374: CALL_OW 25
2378: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2379: LD_ADDR_EXP 40
2383: PUSH
2384: LD_STRING Lipshchin
2386: PPUSH
2387: CALL_OW 25
2391: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2392: LD_ADDR_EXP 44
2396: PUSH
2397: LD_STRING Karamazov
2399: PPUSH
2400: CALL_OW 25
2404: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2405: LD_ADDR_VAR 0 3
2409: PUSH
2410: LD_EXP 41
2414: PUSH
2415: LD_EXP 43
2419: PUSH
2420: LD_EXP 42
2424: PUSH
2425: LD_EXP 40
2429: PUSH
2430: LD_EXP 44
2434: PUSH
2435: EMPTY
2436: LIST
2437: LIST
2438: LIST
2439: LIST
2440: LIST
2441: ST_TO_ADDR
// for i in tmp do
2442: LD_ADDR_VAR 0 2
2446: PUSH
2447: LD_VAR 0 3
2451: PUSH
2452: FOR_IN
2453: IFFALSE 2492
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2455: LD_VAR 0 2
2459: PPUSH
2460: LD_INT 399
2462: PPUSH
2463: LD_INT 799
2465: PPUSH
2466: CALL_OW 12
2470: PPUSH
2471: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2475: LD_VAR 0 2
2479: PPUSH
2480: LD_INT 19
2482: PPUSH
2483: LD_INT 0
2485: PPUSH
2486: CALL_OW 49
// end ;
2490: GO 2452
2492: POP
2493: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2494: LD_VAR 0 3
2498: PPUSH
2499: LD_INT 116
2501: PPUSH
2502: LD_INT 8
2504: PPUSH
2505: CALL_OW 111
// AddComHold ( tmp ) ;
2509: LD_VAR 0 3
2513: PPUSH
2514: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2518: LD_ADDR_VAR 0 2
2522: PUSH
2523: LD_VAR 0 3
2527: PPUSH
2528: LD_INT 25
2530: PUSH
2531: LD_INT 1
2533: PUSH
2534: EMPTY
2535: LIST
2536: LIST
2537: PPUSH
2538: CALL_OW 72
2542: PUSH
2543: FOR_IN
2544: IFFALSE 2584
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2546: LD_VAR 0 2
2550: PPUSH
2551: LD_INT 20
2553: PPUSH
2554: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2558: LD_VAR 0 2
2562: PPUSH
2563: LD_INT 147
2565: PPUSH
2566: LD_INT 45
2568: PPUSH
2569: CALL_OW 178
// AddComCrawl ( i ) ;
2573: LD_VAR 0 2
2577: PPUSH
2578: CALL_OW 197
// end ;
2582: GO 2543
2584: POP
2585: POP
// repeat wait ( 0 0$1 ) ;
2586: LD_INT 35
2588: PPUSH
2589: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2593: LD_EXP 48
2597: PPUSH
2598: LD_INT 110
2600: PPUSH
2601: LD_INT 10
2603: PPUSH
2604: CALL_OW 307
2608: PUSH
2609: LD_EXP 48
2613: PPUSH
2614: CALL_OW 305
2618: NOT
2619: OR
2620: IFFALSE 2586
// ComStop ( Burlak ) ;
2622: LD_EXP 45
2626: PPUSH
2627: CALL_OW 141
// AddComHold ( Burlak ) ;
2631: LD_EXP 45
2635: PPUSH
2636: CALL_OW 200
// end ; end_of_file
2640: LD_VAR 0 1
2644: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2645: LD_INT 0
2647: PPUSH
2648: PPUSH
2649: PPUSH
2650: PPUSH
// uc_side := 3 ;
2651: LD_ADDR_OWVAR 20
2655: PUSH
2656: LD_INT 3
2658: ST_TO_ADDR
// uc_nation := 3 ;
2659: LD_ADDR_OWVAR 21
2663: PUSH
2664: LD_INT 3
2666: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2667: LD_ADDR_EXP 49
2671: PUSH
2672: LD_INT 47
2674: PPUSH
2675: LD_INT 4
2677: PPUSH
2678: LD_STRING 
2680: PPUSH
2681: LD_INT 7
2683: PUSH
2684: LD_INT 8
2686: PUSH
2687: LD_INT 9
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: LIST
2694: PUSH
2695: LD_OWVAR 67
2699: ARRAY
2700: PPUSH
2701: LD_INT 10000
2703: PUSH
2704: LD_INT 3000
2706: PUSH
2707: LD_INT 300
2709: PUSH
2710: EMPTY
2711: LIST
2712: LIST
2713: LIST
2714: PPUSH
2715: LD_INT 9
2717: PUSH
2718: LD_INT 5
2720: PUSH
2721: LD_INT 6
2723: PUSH
2724: LD_INT 6
2726: PUSH
2727: EMPTY
2728: LIST
2729: LIST
2730: LIST
2731: LIST
2732: PPUSH
2733: CALL 23929 0 6
2737: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2738: LD_ADDR_EXP 58
2742: PUSH
2743: LD_EXP 58
2747: PPUSH
2748: LD_INT 2
2750: PPUSH
2751: LD_EXP 49
2755: PPUSH
2756: CALL_OW 1
2760: ST_TO_ADDR
// tmp := [ ] ;
2761: LD_ADDR_VAR 0 4
2765: PUSH
2766: EMPTY
2767: ST_TO_ADDR
// for i = 1 to 4 do
2768: LD_ADDR_VAR 0 2
2772: PUSH
2773: DOUBLE
2774: LD_INT 1
2776: DEC
2777: ST_TO_ADDR
2778: LD_INT 4
2780: PUSH
2781: FOR_TO
2782: IFFALSE 2875
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2784: LD_INT 22
2786: PPUSH
2787: LD_INT 3
2789: PPUSH
2790: LD_INT 3
2792: PPUSH
2793: LD_INT 43
2795: PUSH
2796: LD_INT 45
2798: PUSH
2799: LD_INT 45
2801: PUSH
2802: LD_INT 44
2804: PUSH
2805: EMPTY
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: PUSH
2811: LD_VAR 0 2
2815: PUSH
2816: LD_INT 4
2818: MOD
2819: PUSH
2820: LD_INT 1
2822: PLUS
2823: ARRAY
2824: PPUSH
2825: LD_INT 100
2827: PPUSH
2828: CALL 20520 0 5
// veh := CreateVehicle ;
2832: LD_ADDR_VAR 0 3
2836: PUSH
2837: CALL_OW 45
2841: ST_TO_ADDR
// tmp := tmp ^ veh ;
2842: LD_ADDR_VAR 0 4
2846: PUSH
2847: LD_VAR 0 4
2851: PUSH
2852: LD_VAR 0 3
2856: ADD
2857: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2858: LD_VAR 0 3
2862: PPUSH
2863: LD_INT 2
2865: PPUSH
2866: LD_INT 0
2868: PPUSH
2869: CALL_OW 49
// end ;
2873: GO 2781
2875: POP
2876: POP
// russian_guard := tmp ;
2877: LD_ADDR_EXP 50
2881: PUSH
2882: LD_VAR 0 4
2886: ST_TO_ADDR
// end ;
2887: LD_VAR 0 1
2891: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2892: LD_INT 47
2894: PPUSH
2895: CALL_OW 302
2899: PUSH
2900: LD_EXP 6
2904: AND
2905: IFFALSE 3507
2907: GO 2909
2909: DISABLE
2910: LD_INT 0
2912: PPUSH
2913: PPUSH
2914: PPUSH
2915: PPUSH
2916: PPUSH
2917: PPUSH
// begin enable ;
2918: ENABLE
// base := 2 ;
2919: LD_ADDR_VAR 0 2
2923: PUSH
2924: LD_INT 2
2926: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
2927: LD_ADDR_VAR 0 4
2931: PUSH
2932: LD_INT 0
2934: PUSH
2935: LD_INT 0
2937: PUSH
2938: LD_INT 0
2940: PUSH
2941: LD_INT 0
2943: PUSH
2944: LD_INT 0
2946: PUSH
2947: LD_INT 0
2949: PUSH
2950: LD_INT 0
2952: PUSH
2953: LD_INT 0
2955: PUSH
2956: LD_INT 1
2958: PUSH
2959: LD_INT 0
2961: PUSH
2962: EMPTY
2963: LIST
2964: LIST
2965: LIST
2966: LIST
2967: LIST
2968: LIST
2969: LIST
2970: LIST
2971: LIST
2972: LIST
2973: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
2974: LD_ADDR_VAR 0 3
2978: PUSH
2979: LD_INT 22
2981: PUSH
2982: LD_INT 1
2984: PUSH
2985: LD_INT 3
2987: PUSH
2988: LD_INT 45
2990: PUSH
2991: EMPTY
2992: LIST
2993: LIST
2994: LIST
2995: LIST
2996: PUSH
2997: LD_INT 21
2999: PUSH
3000: LD_INT 1
3002: PUSH
3003: LD_INT 3
3005: PUSH
3006: LD_INT 45
3008: PUSH
3009: EMPTY
3010: LIST
3011: LIST
3012: LIST
3013: LIST
3014: PUSH
3015: LD_INT 22
3017: PUSH
3018: LD_INT 1
3020: PUSH
3021: LD_INT 3
3023: PUSH
3024: LD_INT 45
3026: PUSH
3027: EMPTY
3028: LIST
3029: LIST
3030: LIST
3031: LIST
3032: PUSH
3033: LD_INT 23
3035: PUSH
3036: LD_INT 1
3038: PUSH
3039: LD_INT 3
3041: PUSH
3042: LD_INT 46
3044: PUSH
3045: EMPTY
3046: LIST
3047: LIST
3048: LIST
3049: LIST
3050: PUSH
3051: EMPTY
3052: LIST
3053: LIST
3054: LIST
3055: LIST
3056: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3057: LD_ADDR_VAR 0 1
3061: PUSH
3062: DOUBLE
3063: LD_INT 1
3065: DEC
3066: ST_TO_ADDR
3067: LD_OWVAR 67
3071: PUSH
3072: LD_OWVAR 1
3076: PUSH
3077: LD_INT 21000
3079: DIV
3080: PLUS
3081: PUSH
3082: FOR_TO
3083: IFFALSE 3171
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3085: LD_ADDR_VAR 0 3
3089: PUSH
3090: LD_VAR 0 3
3094: PPUSH
3095: LD_VAR 0 3
3099: PUSH
3100: LD_INT 1
3102: PLUS
3103: PPUSH
3104: LD_INT 23
3106: PUSH
3107: LD_INT 24
3109: PUSH
3110: EMPTY
3111: LIST
3112: LIST
3113: PUSH
3114: LD_INT 1
3116: PPUSH
3117: LD_INT 2
3119: PPUSH
3120: CALL_OW 12
3124: ARRAY
3125: PUSH
3126: LD_INT 1
3128: PUSH
3129: LD_INT 3
3131: PUSH
3132: LD_INT 46
3134: PUSH
3135: LD_INT 47
3137: PUSH
3138: LD_INT 45
3140: PUSH
3141: EMPTY
3142: LIST
3143: LIST
3144: LIST
3145: PUSH
3146: LD_INT 1
3148: PPUSH
3149: LD_INT 3
3151: PPUSH
3152: CALL_OW 12
3156: ARRAY
3157: PUSH
3158: EMPTY
3159: LIST
3160: LIST
3161: LIST
3162: LIST
3163: PPUSH
3164: CALL_OW 2
3168: ST_TO_ADDR
3169: GO 3082
3171: POP
3172: POP
// MC_InsertProduceList ( base , tmp ) ;
3173: LD_VAR 0 2
3177: PPUSH
3178: LD_VAR 0 3
3182: PPUSH
3183: CALL 79703 0 2
// repeat wait ( 0 0$1 ) ;
3187: LD_INT 35
3189: PPUSH
3190: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3194: LD_EXP 77
3198: PUSH
3199: LD_VAR 0 2
3203: ARRAY
3204: PUSH
3205: LD_INT 6
3207: GREATER
3208: IFFALSE 3187
// wait ( 0 0$20 ) ;
3210: LD_INT 700
3212: PPUSH
3213: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3217: LD_ADDR_VAR 0 5
3221: PUSH
3222: LD_INT 71
3224: PUSH
3225: LD_INT 19
3227: PUSH
3228: EMPTY
3229: LIST
3230: LIST
3231: PUSH
3232: LD_INT 91
3234: PUSH
3235: LD_INT 67
3237: PUSH
3238: EMPTY
3239: LIST
3240: LIST
3241: PUSH
3242: LD_INT 52
3244: PUSH
3245: LD_INT 44
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: PUSH
3252: LD_INT 68
3254: PUSH
3255: LD_INT 48
3257: PUSH
3258: EMPTY
3259: LIST
3260: LIST
3261: PUSH
3262: EMPTY
3263: LIST
3264: LIST
3265: LIST
3266: LIST
3267: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3268: LD_ADDR_VAR 0 6
3272: PUSH
3273: LD_EXP 77
3277: PUSH
3278: LD_VAR 0 2
3282: ARRAY
3283: PUSH
3284: LD_EXP 77
3288: PUSH
3289: LD_VAR 0 2
3293: ARRAY
3294: PPUSH
3295: LD_INT 2
3297: PUSH
3298: LD_INT 34
3300: PUSH
3301: LD_INT 51
3303: PUSH
3304: EMPTY
3305: LIST
3306: LIST
3307: PUSH
3308: LD_INT 34
3310: PUSH
3311: LD_INT 52
3313: PUSH
3314: EMPTY
3315: LIST
3316: LIST
3317: PUSH
3318: EMPTY
3319: LIST
3320: LIST
3321: LIST
3322: PPUSH
3323: CALL_OW 72
3327: DIFF
3328: ST_TO_ADDR
// if not attackers then
3329: LD_VAR 0 6
3333: NOT
3334: IFFALSE 3338
// exit ;
3336: GO 3507
// ru_attackers := attackers ;
3338: LD_ADDR_EXP 51
3342: PUSH
3343: LD_VAR 0 6
3347: ST_TO_ADDR
// for i = 1 to attackers do
3348: LD_ADDR_VAR 0 1
3352: PUSH
3353: DOUBLE
3354: LD_INT 1
3356: DEC
3357: ST_TO_ADDR
3358: LD_VAR 0 6
3362: PUSH
3363: FOR_TO
3364: IFFALSE 3441
// begin case i mod 3 of 0 :
3366: LD_VAR 0 1
3370: PUSH
3371: LD_INT 3
3373: MOD
3374: PUSH
3375: LD_INT 0
3377: DOUBLE
3378: EQUAL
3379: IFTRUE 3383
3381: GO 3386
3383: POP
// ; 1 :
3384: GO 3439
3386: LD_INT 1
3388: DOUBLE
3389: EQUAL
3390: IFTRUE 3394
3392: GO 3412
3394: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3395: LD_VAR 0 1
3399: PPUSH
3400: LD_INT 32
3402: PPUSH
3403: LD_INT 49
3405: PPUSH
3406: CALL_OW 114
3410: GO 3439
3412: LD_INT 2
3414: DOUBLE
3415: EQUAL
3416: IFTRUE 3420
3418: GO 3438
3420: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3421: LD_VAR 0 1
3425: PPUSH
3426: LD_INT 117
3428: PPUSH
3429: LD_INT 107
3431: PPUSH
3432: CALL_OW 114
3436: GO 3439
3438: POP
// end ;
3439: GO 3363
3441: POP
3442: POP
// repeat wait ( 0 0$1 ) ;
3443: LD_INT 35
3445: PPUSH
3446: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3450: LD_VAR 0 6
3454: PPUSH
3455: LD_INT 60
3457: PUSH
3458: EMPTY
3459: LIST
3460: PPUSH
3461: CALL_OW 72
3465: NOT
3466: IFFALSE 3443
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3468: LD_VAR 0 2
3472: PPUSH
3473: LD_VAR 0 6
3477: PPUSH
3478: LD_VAR 0 5
3482: PPUSH
3483: LD_VAR 0 4
3487: PPUSH
3488: CALL 79888 0 4
// if not first_attack then
3492: LD_EXP 7
3496: NOT
3497: IFFALSE 3507
// first_attack := true ;
3499: LD_ADDR_EXP 7
3503: PUSH
3504: LD_INT 1
3506: ST_TO_ADDR
// end ; end_of_file
3507: PPOPN 6
3509: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3510: LD_INT 0
3512: PPUSH
3513: PPUSH
3514: PPUSH
3515: PPUSH
3516: PPUSH
3517: PPUSH
3518: PPUSH
// uc_side := 2 ;
3519: LD_ADDR_OWVAR 20
3523: PUSH
3524: LD_INT 2
3526: ST_TO_ADDR
// uc_nation := 2 ;
3527: LD_ADDR_OWVAR 21
3531: PUSH
3532: LD_INT 2
3534: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3535: LD_ADDR_EXP 54
3539: PUSH
3540: LD_STRING Abdul
3542: PPUSH
3543: CALL_OW 25
3547: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3548: LD_EXP 54
3552: PPUSH
3553: LD_INT 11
3555: PPUSH
3556: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3560: LD_EXP 54
3564: PPUSH
3565: LD_INT 1
3567: PPUSH
3568: CALL_OW 52
// vc_chassis := 31 ;
3572: LD_ADDR_OWVAR 37
3576: PUSH
3577: LD_INT 31
3579: ST_TO_ADDR
// vc_control := control_rider ;
3580: LD_ADDR_OWVAR 38
3584: PUSH
3585: LD_INT 4
3587: ST_TO_ADDR
// mastodont := CreateVehicle ;
3588: LD_ADDR_EXP 55
3592: PUSH
3593: CALL_OW 45
3597: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3598: LD_EXP 55
3602: PPUSH
3603: LD_INT 153
3605: PPUSH
3606: LD_INT 71
3608: PPUSH
3609: LD_INT 0
3611: PPUSH
3612: CALL_OW 48
// InitVc ;
3616: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3620: LD_ADDR_EXP 52
3624: PUSH
3625: LD_INT 1
3627: PPUSH
3628: LD_INT 3
3630: PPUSH
3631: LD_STRING 
3633: PPUSH
3634: LD_INT 7
3636: PUSH
3637: LD_INT 8
3639: PUSH
3640: LD_INT 9
3642: PUSH
3643: EMPTY
3644: LIST
3645: LIST
3646: LIST
3647: PUSH
3648: LD_OWVAR 67
3652: ARRAY
3653: PPUSH
3654: LD_INT 5000
3656: PUSH
3657: LD_INT 1000
3659: PUSH
3660: LD_INT 300
3662: PUSH
3663: EMPTY
3664: LIST
3665: LIST
3666: LIST
3667: PPUSH
3668: LD_INT 22
3670: PUSH
3671: LD_INT 5
3673: PUSH
3674: LD_INT 6
3676: PUSH
3677: LD_INT 9
3679: PUSH
3680: EMPTY
3681: LIST
3682: LIST
3683: LIST
3684: LIST
3685: PPUSH
3686: CALL 23929 0 6
3690: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3691: LD_ADDR_EXP 58
3695: PUSH
3696: LD_EXP 58
3700: PPUSH
3701: LD_INT 1
3703: PPUSH
3704: LD_EXP 52
3708: PPUSH
3709: CALL_OW 1
3713: ST_TO_ADDR
// tmp := [ ] ;
3714: LD_ADDR_VAR 0 4
3718: PUSH
3719: EMPTY
3720: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3721: LD_ADDR_OWVAR 37
3725: PUSH
3726: LD_INT 14
3728: ST_TO_ADDR
// vc_engine := engine_siberite ;
3729: LD_ADDR_OWVAR 39
3733: PUSH
3734: LD_INT 3
3736: ST_TO_ADDR
// vc_control := control_manual ;
3737: LD_ADDR_OWVAR 38
3741: PUSH
3742: LD_INT 1
3744: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3745: LD_ADDR_OWVAR 40
3749: PUSH
3750: LD_INT 31
3752: ST_TO_ADDR
// for i = 1 to 3 do
3753: LD_ADDR_VAR 0 2
3757: PUSH
3758: DOUBLE
3759: LD_INT 1
3761: DEC
3762: ST_TO_ADDR
3763: LD_INT 3
3765: PUSH
3766: FOR_TO
3767: IFFALSE 4011
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3769: LD_ADDR_VAR 0 5
3773: PUSH
3774: LD_INT 153
3776: PUSH
3777: LD_INT 71
3779: PUSH
3780: EMPTY
3781: LIST
3782: LIST
3783: PUSH
3784: LD_INT 155
3786: PUSH
3787: LD_INT 81
3789: PUSH
3790: EMPTY
3791: LIST
3792: LIST
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PUSH
3798: LD_VAR 0 2
3802: PUSH
3803: LD_INT 2
3805: MOD
3806: PUSH
3807: LD_INT 1
3809: PLUS
3810: ARRAY
3811: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3812: LD_INT 0
3814: PPUSH
3815: LD_INT 3
3817: PPUSH
3818: LD_INT 7
3820: PUSH
3821: LD_INT 8
3823: PUSH
3824: LD_INT 9
3826: PUSH
3827: EMPTY
3828: LIST
3829: LIST
3830: LIST
3831: PUSH
3832: LD_OWVAR 67
3836: ARRAY
3837: PPUSH
3838: CALL_OW 380
// un := CreateVehicle ;
3842: LD_ADDR_VAR 0 6
3846: PUSH
3847: CALL_OW 45
3851: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3852: LD_VAR 0 6
3856: PPUSH
3857: LD_INT 0
3859: PPUSH
3860: LD_INT 5
3862: PPUSH
3863: CALL_OW 12
3867: PPUSH
3868: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3872: LD_VAR 0 6
3876: PPUSH
3877: LD_VAR 0 5
3881: PUSH
3882: LD_INT 1
3884: ARRAY
3885: PPUSH
3886: LD_VAR 0 5
3890: PUSH
3891: LD_INT 2
3893: ARRAY
3894: PPUSH
3895: LD_INT 6
3897: PPUSH
3898: LD_INT 0
3900: PPUSH
3901: CALL_OW 50
// un2 := CreateHuman ;
3905: LD_ADDR_VAR 0 7
3909: PUSH
3910: CALL_OW 44
3914: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
3915: LD_VAR 0 7
3919: PPUSH
3920: LD_VAR 0 6
3924: PPUSH
3925: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
3929: LD_ADDR_EXP 58
3933: PUSH
3934: LD_EXP 58
3938: PPUSH
3939: LD_INT 1
3941: PUSH
3942: LD_EXP 58
3946: PUSH
3947: LD_INT 1
3949: ARRAY
3950: PUSH
3951: LD_INT 1
3953: PLUS
3954: PUSH
3955: EMPTY
3956: LIST
3957: LIST
3958: PPUSH
3959: LD_VAR 0 6
3963: PPUSH
3964: CALL 20642 0 3
3968: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
3969: LD_ADDR_EXP 58
3973: PUSH
3974: LD_EXP 58
3978: PPUSH
3979: LD_INT 1
3981: PUSH
3982: LD_EXP 58
3986: PUSH
3987: LD_INT 1
3989: ARRAY
3990: PUSH
3991: LD_INT 1
3993: PLUS
3994: PUSH
3995: EMPTY
3996: LIST
3997: LIST
3998: PPUSH
3999: LD_VAR 0 7
4003: PPUSH
4004: CALL 20642 0 3
4008: ST_TO_ADDR
// end ;
4009: GO 3766
4011: POP
4012: POP
// for i = 1 to 5 do
4013: LD_ADDR_VAR 0 2
4017: PUSH
4018: DOUBLE
4019: LD_INT 1
4021: DEC
4022: ST_TO_ADDR
4023: LD_INT 5
4025: PUSH
4026: FOR_TO
4027: IFFALSE 4120
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4029: LD_INT 14
4031: PPUSH
4032: LD_INT 3
4034: PPUSH
4035: LD_INT 1
4037: PPUSH
4038: LD_INT 25
4040: PUSH
4041: LD_INT 28
4043: PUSH
4044: LD_INT 28
4046: PUSH
4047: LD_INT 26
4049: PUSH
4050: EMPTY
4051: LIST
4052: LIST
4053: LIST
4054: LIST
4055: PUSH
4056: LD_VAR 0 2
4060: PUSH
4061: LD_INT 4
4063: MOD
4064: PUSH
4065: LD_INT 1
4067: PLUS
4068: ARRAY
4069: PPUSH
4070: LD_INT 100
4072: PPUSH
4073: CALL 20520 0 5
// veh := CreateVehicle ;
4077: LD_ADDR_VAR 0 3
4081: PUSH
4082: CALL_OW 45
4086: ST_TO_ADDR
// tmp := tmp ^ veh ;
4087: LD_ADDR_VAR 0 4
4091: PUSH
4092: LD_VAR 0 4
4096: PUSH
4097: LD_VAR 0 3
4101: ADD
4102: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4103: LD_VAR 0 3
4107: PPUSH
4108: LD_INT 1
4110: PPUSH
4111: LD_INT 0
4113: PPUSH
4114: CALL_OW 49
// end ;
4118: GO 4026
4120: POP
4121: POP
// arabian_guard := tmp ;
4122: LD_ADDR_EXP 53
4126: PUSH
4127: LD_VAR 0 4
4131: ST_TO_ADDR
// end ;
4132: LD_VAR 0 1
4136: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4137: LD_INT 22
4139: PUSH
4140: LD_INT 7
4142: PUSH
4143: EMPTY
4144: LIST
4145: LIST
4146: PUSH
4147: LD_INT 91
4149: PUSH
4150: LD_INT 1
4152: PUSH
4153: LD_INT 12
4155: PUSH
4156: EMPTY
4157: LIST
4158: LIST
4159: LIST
4160: PUSH
4161: EMPTY
4162: LIST
4163: LIST
4164: PPUSH
4165: CALL_OW 69
4169: PUSH
4170: LD_EXP 55
4174: PPUSH
4175: CALL_OW 256
4179: PUSH
4180: LD_INT 990
4182: LESS
4183: OR
4184: PUSH
4185: LD_EXP 54
4189: PPUSH
4190: CALL_OW 256
4194: PUSH
4195: LD_INT 990
4197: LESS
4198: OR
4199: IFFALSE 4342
4201: GO 4203
4203: DISABLE
// begin if IsInUnit ( Abdul ) then
4204: LD_EXP 54
4208: PPUSH
4209: CALL_OW 310
4213: IFFALSE 4224
// ComExitBuilding ( Abdul ) ;
4215: LD_EXP 54
4219: PPUSH
4220: CALL_OW 122
// if Mastodont then
4224: LD_EXP 55
4228: IFFALSE 4245
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4230: LD_EXP 55
4234: PPUSH
4235: LD_INT 205
4237: PPUSH
4238: LD_INT 132
4240: PPUSH
4241: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4245: LD_EXP 54
4249: PPUSH
4250: LD_INT 205
4252: PPUSH
4253: LD_INT 132
4255: PPUSH
4256: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4260: LD_INT 35
4262: PPUSH
4263: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4267: LD_EXP 54
4271: PPUSH
4272: LD_INT 21
4274: PPUSH
4275: CALL_OW 308
4279: IFFALSE 4260
// RemoveUnit ( Abdul ) ;
4281: LD_EXP 54
4285: PPUSH
4286: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4290: LD_INT 35
4292: PPUSH
4293: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4297: LD_EXP 55
4301: PPUSH
4302: LD_INT 21
4304: PPUSH
4305: CALL_OW 308
4309: PUSH
4310: LD_EXP 55
4314: PPUSH
4315: CALL_OW 301
4319: OR
4320: IFFALSE 4290
// if IsOk ( Mastodont ) then
4322: LD_EXP 55
4326: PPUSH
4327: CALL_OW 302
4331: IFFALSE 4342
// RemoveUnit ( Mastodont ) ;
4333: LD_EXP 55
4337: PPUSH
4338: CALL_OW 64
// end ;
4342: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4343: LD_EXP 54
4347: PPUSH
4348: CALL_OW 301
4352: PUSH
4353: LD_INT 22
4355: PUSH
4356: LD_INT 2
4358: PUSH
4359: EMPTY
4360: LIST
4361: LIST
4362: PUSH
4363: LD_INT 2
4365: PUSH
4366: LD_INT 25
4368: PUSH
4369: LD_INT 1
4371: PUSH
4372: EMPTY
4373: LIST
4374: LIST
4375: PUSH
4376: LD_INT 25
4378: PUSH
4379: LD_INT 2
4381: PUSH
4382: EMPTY
4383: LIST
4384: LIST
4385: PUSH
4386: LD_INT 25
4388: PUSH
4389: LD_INT 3
4391: PUSH
4392: EMPTY
4393: LIST
4394: LIST
4395: PUSH
4396: LD_INT 25
4398: PUSH
4399: LD_INT 4
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: PUSH
4406: LD_INT 25
4408: PUSH
4409: LD_INT 8
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: LIST
4420: LIST
4421: LIST
4422: LIST
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PPUSH
4428: CALL_OW 69
4432: PUSH
4433: LD_INT 16
4435: PUSH
4436: LD_INT 19
4438: PUSH
4439: LD_INT 22
4441: PUSH
4442: EMPTY
4443: LIST
4444: LIST
4445: LIST
4446: PUSH
4447: LD_OWVAR 67
4451: ARRAY
4452: LESS
4453: OR
4454: IFFALSE 5127
4456: GO 4458
4458: DISABLE
4459: LD_INT 0
4461: PPUSH
4462: PPUSH
4463: PPUSH
4464: PPUSH
4465: PPUSH
4466: PPUSH
// begin MC_Kill ( 1 ) ;
4467: LD_INT 1
4469: PPUSH
4470: CALL 56717 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4474: LD_ADDR_VAR 0 2
4478: PUSH
4479: LD_INT 22
4481: PUSH
4482: LD_INT 2
4484: PUSH
4485: EMPTY
4486: LIST
4487: LIST
4488: PUSH
4489: LD_INT 2
4491: PUSH
4492: LD_INT 25
4494: PUSH
4495: LD_INT 1
4497: PUSH
4498: EMPTY
4499: LIST
4500: LIST
4501: PUSH
4502: LD_INT 25
4504: PUSH
4505: LD_INT 2
4507: PUSH
4508: EMPTY
4509: LIST
4510: LIST
4511: PUSH
4512: LD_INT 25
4514: PUSH
4515: LD_INT 3
4517: PUSH
4518: EMPTY
4519: LIST
4520: LIST
4521: PUSH
4522: LD_INT 25
4524: PUSH
4525: LD_INT 4
4527: PUSH
4528: EMPTY
4529: LIST
4530: LIST
4531: PUSH
4532: LD_INT 25
4534: PUSH
4535: LD_INT 8
4537: PUSH
4538: EMPTY
4539: LIST
4540: LIST
4541: PUSH
4542: EMPTY
4543: LIST
4544: LIST
4545: LIST
4546: LIST
4547: LIST
4548: LIST
4549: PUSH
4550: EMPTY
4551: LIST
4552: LIST
4553: PPUSH
4554: CALL_OW 69
4558: ST_TO_ADDR
// for i in tmp do
4559: LD_ADDR_VAR 0 5
4563: PUSH
4564: LD_VAR 0 2
4568: PUSH
4569: FOR_IN
4570: IFFALSE 4586
// SetTag ( i , 10 ) ;
4572: LD_VAR 0 5
4576: PPUSH
4577: LD_INT 10
4579: PPUSH
4580: CALL_OW 109
4584: GO 4569
4586: POP
4587: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4588: LD_ADDR_VAR 0 3
4592: PUSH
4593: LD_INT 22
4595: PUSH
4596: LD_INT 2
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: PUSH
4603: LD_INT 21
4605: PUSH
4606: LD_INT 1
4608: PUSH
4609: EMPTY
4610: LIST
4611: LIST
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: PPUSH
4617: CALL_OW 69
4621: PUSH
4622: LD_VAR 0 2
4626: DIFF
4627: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4628: LD_ADDR_VAR 0 1
4632: PUSH
4633: LD_INT 22
4635: PUSH
4636: LD_INT 2
4638: PUSH
4639: EMPTY
4640: LIST
4641: LIST
4642: PUSH
4643: LD_INT 21
4645: PUSH
4646: LD_INT 2
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: PUSH
4653: LD_INT 24
4655: PUSH
4656: LD_INT 300
4658: PUSH
4659: EMPTY
4660: LIST
4661: LIST
4662: PUSH
4663: EMPTY
4664: LIST
4665: LIST
4666: LIST
4667: PPUSH
4668: CALL_OW 69
4672: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4673: LD_ADDR_VAR 0 4
4677: PUSH
4678: LD_VAR 0 1
4682: PPUSH
4683: LD_INT 33
4685: PUSH
4686: LD_INT 1
4688: PUSH
4689: EMPTY
4690: LIST
4691: LIST
4692: PUSH
4693: LD_INT 58
4695: PUSH
4696: EMPTY
4697: LIST
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: PPUSH
4703: CALL_OW 72
4707: ST_TO_ADDR
// for i in tmp do
4708: LD_ADDR_VAR 0 5
4712: PUSH
4713: LD_VAR 0 2
4717: PUSH
4718: FOR_IN
4719: IFFALSE 4903
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4721: LD_VAR 0 5
4725: PUSH
4726: LD_INT 55
4728: PUSH
4729: EMPTY
4730: LIST
4731: PPUSH
4732: CALL_OW 69
4736: IN
4737: IFFALSE 4756
// begin AddComMoveXY ( i , 209 , 132 ) ;
4739: LD_VAR 0 5
4743: PPUSH
4744: LD_INT 209
4746: PPUSH
4747: LD_INT 132
4749: PPUSH
4750: CALL_OW 171
// continue ;
4754: GO 4718
// end ; if IsInUnit ( i ) then
4756: LD_VAR 0 5
4760: PPUSH
4761: CALL_OW 310
4765: IFFALSE 4783
// begin ComExitBuilding ( i ) ;
4767: LD_VAR 0 5
4771: PPUSH
4772: CALL_OW 122
// wait ( 3 ) ;
4776: LD_INT 3
4778: PPUSH
4779: CALL_OW 67
// end ; if tmp_empty then
4783: LD_VAR 0 4
4787: IFFALSE 4886
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4789: LD_VAR 0 5
4793: PPUSH
4794: LD_VAR 0 4
4798: PPUSH
4799: LD_VAR 0 5
4803: PPUSH
4804: CALL_OW 74
4808: PPUSH
4809: CALL_OW 296
4813: PUSH
4814: LD_INT 25
4816: LESS
4817: IFFALSE 4886
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4819: LD_ADDR_VAR 0 6
4823: PUSH
4824: LD_VAR 0 4
4828: PPUSH
4829: LD_VAR 0 5
4833: PPUSH
4834: CALL_OW 74
4838: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4839: LD_VAR 0 5
4843: PPUSH
4844: LD_VAR 0 6
4848: PPUSH
4849: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4853: LD_VAR 0 5
4857: PPUSH
4858: LD_INT 209
4860: PPUSH
4861: LD_INT 132
4863: PPUSH
4864: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4868: LD_ADDR_VAR 0 4
4872: PUSH
4873: LD_VAR 0 4
4877: PUSH
4878: LD_VAR 0 6
4882: DIFF
4883: ST_TO_ADDR
// continue ;
4884: GO 4718
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4886: LD_VAR 0 5
4890: PPUSH
4891: LD_INT 201
4893: PPUSH
4894: LD_INT 132
4896: PPUSH
4897: CALL_OW 171
// end ;
4901: GO 4718
4903: POP
4904: POP
// for i in tmp_ape do
4905: LD_ADDR_VAR 0 5
4909: PUSH
4910: LD_VAR 0 3
4914: PUSH
4915: FOR_IN
4916: IFFALSE 4955
// begin if IsInUnit ( i ) then
4918: LD_VAR 0 5
4922: PPUSH
4923: CALL_OW 310
4927: IFFALSE 4938
// ComExitBuilding ( i ) ;
4929: LD_VAR 0 5
4933: PPUSH
4934: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
4938: LD_VAR 0 5
4942: PPUSH
4943: LD_INT 201
4945: PPUSH
4946: LD_INT 132
4948: PPUSH
4949: CALL_OW 171
// end ;
4953: GO 4915
4955: POP
4956: POP
// repeat wait ( 0 0$1 ) ;
4957: LD_INT 35
4959: PPUSH
4960: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
4964: LD_ADDR_VAR 0 5
4968: PUSH
4969: LD_VAR 0 2
4973: PUSH
4974: LD_VAR 0 3
4978: UNION
4979: PUSH
4980: LD_VAR 0 1
4984: UNION
4985: PUSH
4986: FOR_IN
4987: IFFALSE 5018
// if not HasTask ( i ) then
4989: LD_VAR 0 5
4993: PPUSH
4994: CALL_OW 314
4998: NOT
4999: IFFALSE 5016
// ComMoveXY ( i , 201 , 132 ) ;
5001: LD_VAR 0 5
5005: PPUSH
5006: LD_INT 201
5008: PPUSH
5009: LD_INT 132
5011: PPUSH
5012: CALL_OW 111
5016: GO 4986
5018: POP
5019: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5020: LD_INT 21
5022: PPUSH
5023: LD_INT 22
5025: PUSH
5026: LD_INT 2
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: PPUSH
5033: CALL_OW 70
5037: IFFALSE 5078
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5039: LD_ADDR_VAR 0 5
5043: PUSH
5044: LD_INT 21
5046: PPUSH
5047: LD_INT 22
5049: PUSH
5050: LD_INT 2
5052: PUSH
5053: EMPTY
5054: LIST
5055: LIST
5056: PPUSH
5057: CALL_OW 70
5061: PUSH
5062: FOR_IN
5063: IFFALSE 5076
// RemoveUnit ( i ) ;
5065: LD_VAR 0 5
5069: PPUSH
5070: CALL_OW 64
5074: GO 5062
5076: POP
5077: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5078: LD_INT 22
5080: PUSH
5081: LD_INT 2
5083: PUSH
5084: EMPTY
5085: LIST
5086: LIST
5087: PUSH
5088: LD_INT 2
5090: PUSH
5091: LD_INT 21
5093: PUSH
5094: LD_INT 1
5096: PUSH
5097: EMPTY
5098: LIST
5099: LIST
5100: PUSH
5101: LD_INT 21
5103: PUSH
5104: LD_INT 2
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: PUSH
5111: EMPTY
5112: LIST
5113: LIST
5114: LIST
5115: PUSH
5116: EMPTY
5117: LIST
5118: LIST
5119: PPUSH
5120: CALL_OW 69
5124: NOT
5125: IFFALSE 4957
// end ;
5127: PPOPN 6
5129: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5130: LD_EXP 9
5134: PUSH
5135: LD_INT 92
5137: PPUSH
5138: LD_INT 40
5140: PPUSH
5141: CALL_OW 428
5145: PPUSH
5146: CALL_OW 266
5150: PUSH
5151: LD_INT 30
5153: EQUAL
5154: AND
5155: IFFALSE 5351
5157: GO 5159
5159: DISABLE
5160: LD_INT 0
5162: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5163: LD_ADDR_VAR 0 1
5167: PUSH
5168: LD_EXP 58
5172: PUSH
5173: LD_INT 1
5175: ARRAY
5176: PPUSH
5177: LD_INT 25
5179: PUSH
5180: LD_INT 4
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: PPUSH
5187: CALL_OW 72
5191: ST_TO_ADDR
// if not sci then
5192: LD_VAR 0 1
5196: NOT
5197: IFFALSE 5201
// exit ;
5199: GO 5351
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5201: LD_ADDR_EXP 58
5205: PUSH
5206: LD_EXP 58
5210: PPUSH
5211: LD_INT 1
5213: PPUSH
5214: LD_EXP 58
5218: PUSH
5219: LD_INT 1
5221: ARRAY
5222: PUSH
5223: LD_VAR 0 1
5227: PUSH
5228: LD_INT 1
5230: ARRAY
5231: DIFF
5232: PPUSH
5233: CALL_OW 1
5237: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5238: LD_VAR 0 1
5242: PUSH
5243: LD_INT 1
5245: ARRAY
5246: PPUSH
5247: CALL_OW 310
5251: IFFALSE 5266
// ComExitBuilding ( sci [ 1 ] ) ;
5253: LD_VAR 0 1
5257: PUSH
5258: LD_INT 1
5260: ARRAY
5261: PPUSH
5262: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5266: LD_INT 2
5268: PPUSH
5269: LD_INT 105
5271: PPUSH
5272: LD_INT 14
5274: PPUSH
5275: LD_INT 20
5277: PPUSH
5278: CALL 21538 0 4
5282: PUSH
5283: LD_INT 4
5285: ARRAY
5286: PUSH
5287: LD_INT 10
5289: LESS
5290: IFFALSE 5313
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5292: LD_VAR 0 1
5296: PUSH
5297: LD_INT 1
5299: ARRAY
5300: PPUSH
5301: LD_INT 105
5303: PPUSH
5304: LD_INT 14
5306: PPUSH
5307: CALL_OW 171
5311: GO 5332
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5313: LD_VAR 0 1
5317: PUSH
5318: LD_INT 1
5320: ARRAY
5321: PPUSH
5322: LD_INT 118
5324: PPUSH
5325: LD_INT 77
5327: PPUSH
5328: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5332: LD_VAR 0 1
5336: PUSH
5337: LD_INT 1
5339: ARRAY
5340: PPUSH
5341: LD_INT 92
5343: PPUSH
5344: LD_INT 40
5346: PPUSH
5347: CALL_OW 218
// end ;
5351: PPOPN 1
5353: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5354: LD_INT 1
5356: PPUSH
5357: CALL_OW 302
5361: PUSH
5362: LD_EXP 9
5366: AND
5367: IFFALSE 5826
5369: GO 5371
5371: DISABLE
5372: LD_INT 0
5374: PPUSH
5375: PPUSH
5376: PPUSH
5377: PPUSH
5378: PPUSH
5379: PPUSH
// begin enable ;
5380: ENABLE
// base := 1 ;
5381: LD_ADDR_VAR 0 2
5385: PUSH
5386: LD_INT 1
5388: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5389: LD_ADDR_VAR 0 4
5393: PUSH
5394: LD_INT 0
5396: PUSH
5397: LD_INT 0
5399: PUSH
5400: LD_INT 0
5402: PUSH
5403: LD_INT 0
5405: PUSH
5406: LD_INT 0
5408: PUSH
5409: LD_INT 0
5411: PUSH
5412: LD_INT 0
5414: PUSH
5415: LD_INT 0
5417: PUSH
5418: LD_INT 1
5420: PUSH
5421: LD_INT 0
5423: PUSH
5424: EMPTY
5425: LIST
5426: LIST
5427: LIST
5428: LIST
5429: LIST
5430: LIST
5431: LIST
5432: LIST
5433: LIST
5434: LIST
5435: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5436: LD_ADDR_VAR 0 3
5440: PUSH
5441: LD_INT 14
5443: PUSH
5444: LD_INT 1
5446: PUSH
5447: LD_INT 2
5449: PUSH
5450: LD_INT 26
5452: PUSH
5453: EMPTY
5454: LIST
5455: LIST
5456: LIST
5457: LIST
5458: PUSH
5459: LD_INT 14
5461: PUSH
5462: LD_INT 1
5464: PUSH
5465: LD_INT 2
5467: PUSH
5468: LD_INT 28
5470: PUSH
5471: EMPTY
5472: LIST
5473: LIST
5474: LIST
5475: LIST
5476: PUSH
5477: LD_INT 13
5479: PUSH
5480: LD_INT 1
5482: PUSH
5483: LD_INT 2
5485: PUSH
5486: LD_INT 29
5488: PUSH
5489: EMPTY
5490: LIST
5491: LIST
5492: LIST
5493: LIST
5494: PUSH
5495: EMPTY
5496: LIST
5497: LIST
5498: LIST
5499: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5500: LD_ADDR_VAR 0 1
5504: PUSH
5505: DOUBLE
5506: LD_INT 1
5508: DEC
5509: ST_TO_ADDR
5510: LD_OWVAR 67
5514: PUSH
5515: LD_OWVAR 1
5519: PUSH
5520: LD_INT 21000
5522: DIV
5523: PLUS
5524: PUSH
5525: FOR_TO
5526: IFFALSE 5618
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5528: LD_ADDR_VAR 0 3
5532: PUSH
5533: LD_VAR 0 3
5537: PPUSH
5538: LD_VAR 0 3
5542: PUSH
5543: LD_INT 1
5545: PLUS
5546: PPUSH
5547: LD_INT 13
5549: PUSH
5550: LD_INT 14
5552: PUSH
5553: EMPTY
5554: LIST
5555: LIST
5556: PUSH
5557: LD_INT 1
5559: PPUSH
5560: LD_INT 2
5562: PPUSH
5563: CALL_OW 12
5567: ARRAY
5568: PUSH
5569: LD_INT 1
5571: PUSH
5572: LD_INT 2
5574: PUSH
5575: LD_INT 28
5577: PUSH
5578: LD_INT 29
5580: PUSH
5581: LD_INT 25
5583: PUSH
5584: LD_INT 26
5586: PUSH
5587: EMPTY
5588: LIST
5589: LIST
5590: LIST
5591: LIST
5592: PUSH
5593: LD_INT 1
5595: PPUSH
5596: LD_INT 4
5598: PPUSH
5599: CALL_OW 12
5603: ARRAY
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: LIST
5609: LIST
5610: PPUSH
5611: CALL_OW 2
5615: ST_TO_ADDR
5616: GO 5525
5618: POP
5619: POP
// MC_InsertProduceList ( base , tmp ) ;
5620: LD_VAR 0 2
5624: PPUSH
5625: LD_VAR 0 3
5629: PPUSH
5630: CALL 79703 0 2
// repeat wait ( 0 0$1 ) ;
5634: LD_INT 35
5636: PPUSH
5637: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5641: LD_EXP 77
5645: PUSH
5646: LD_VAR 0 2
5650: ARRAY
5651: PUSH
5652: LD_INT 6
5654: GREATER
5655: IFFALSE 5634
// wait ( 0 0$20 ) ;
5657: LD_INT 700
5659: PPUSH
5660: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5664: LD_ADDR_VAR 0 5
5668: PUSH
5669: LD_INT 124
5671: PUSH
5672: LD_INT 85
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: PUSH
5679: LD_INT 90
5681: PUSH
5682: LD_INT 61
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: PUSH
5689: LD_INT 69
5691: PUSH
5692: LD_INT 48
5694: PUSH
5695: EMPTY
5696: LIST
5697: LIST
5698: PUSH
5699: LD_INT 68
5701: PUSH
5702: LD_INT 48
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: PUSH
5709: EMPTY
5710: LIST
5711: LIST
5712: LIST
5713: LIST
5714: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5715: LD_ADDR_VAR 0 6
5719: PUSH
5720: LD_EXP 77
5724: PUSH
5725: LD_VAR 0 2
5729: ARRAY
5730: PUSH
5731: LD_EXP 77
5735: PUSH
5736: LD_VAR 0 2
5740: ARRAY
5741: PPUSH
5742: LD_INT 34
5744: PUSH
5745: LD_INT 32
5747: PUSH
5748: EMPTY
5749: LIST
5750: LIST
5751: PPUSH
5752: CALL_OW 72
5756: DIFF
5757: ST_TO_ADDR
// if not attackers then
5758: LD_VAR 0 6
5762: NOT
5763: IFFALSE 5767
// exit ;
5765: GO 5826
// ar_attackers := attackers ;
5767: LD_ADDR_EXP 10
5771: PUSH
5772: LD_VAR 0 6
5776: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5777: LD_INT 35
5779: PPUSH
5780: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5784: LD_VAR 0 6
5788: PPUSH
5789: LD_INT 60
5791: PUSH
5792: EMPTY
5793: LIST
5794: PPUSH
5795: CALL_OW 72
5799: NOT
5800: IFFALSE 5777
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5802: LD_VAR 0 2
5806: PPUSH
5807: LD_VAR 0 6
5811: PPUSH
5812: LD_VAR 0 5
5816: PPUSH
5817: LD_VAR 0 4
5821: PPUSH
5822: CALL 79888 0 4
// end ;
5826: PPOPN 6
5828: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5829: LD_INT 1
5831: PPUSH
5832: CALL_OW 302
5836: PUSH
5837: LD_EXP 9
5841: AND
5842: PUSH
5843: LD_EXP 48
5847: PPUSH
5848: LD_INT 22
5850: PPUSH
5851: CALL_OW 308
5855: AND
5856: PUSH
5857: LD_INT 1
5859: PPUSH
5860: CALL 80051 0 1
5864: PUSH
5865: LD_INT 0
5867: EQUAL
5868: AND
5869: PUSH
5870: LD_EXP 10
5874: NOT
5875: AND
5876: IFFALSE 6340
5878: GO 5880
5880: DISABLE
5881: LD_INT 0
5883: PPUSH
5884: PPUSH
5885: PPUSH
5886: PPUSH
5887: PPUSH
5888: PPUSH
5889: PPUSH
// begin base := 1 ;
5890: LD_ADDR_VAR 0 2
5894: PUSH
5895: LD_INT 1
5897: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5898: LD_ADDR_VAR 0 4
5902: PUSH
5903: LD_INT 0
5905: PUSH
5906: LD_INT 0
5908: PUSH
5909: LD_INT 0
5911: PUSH
5912: LD_INT 0
5914: PUSH
5915: LD_INT 0
5917: PUSH
5918: LD_INT 0
5920: PUSH
5921: LD_INT 0
5923: PUSH
5924: LD_INT 0
5926: PUSH
5927: LD_INT 1
5929: PUSH
5930: LD_INT 0
5932: PUSH
5933: EMPTY
5934: LIST
5935: LIST
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: LIST
5943: LIST
5944: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
5945: LD_ADDR_VAR 0 3
5949: PUSH
5950: LD_INT 13
5952: PUSH
5953: LD_INT 1
5955: PUSH
5956: LD_INT 2
5958: PUSH
5959: LD_INT 28
5961: PUSH
5962: EMPTY
5963: LIST
5964: LIST
5965: LIST
5966: LIST
5967: PUSH
5968: LD_INT 13
5970: PUSH
5971: LD_INT 1
5973: PUSH
5974: LD_INT 2
5976: PUSH
5977: LD_INT 27
5979: PUSH
5980: EMPTY
5981: LIST
5982: LIST
5983: LIST
5984: LIST
5985: PUSH
5986: LD_INT 13
5988: PUSH
5989: LD_INT 1
5991: PUSH
5992: LD_INT 2
5994: PUSH
5995: LD_INT 25
5997: PUSH
5998: EMPTY
5999: LIST
6000: LIST
6001: LIST
6002: LIST
6003: PUSH
6004: LD_INT 11
6006: PUSH
6007: LD_INT 2
6009: PUSH
6010: LD_INT 2
6012: PUSH
6013: LD_INT 24
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: PUSH
6022: LD_INT 11
6024: PUSH
6025: LD_INT 2
6027: PUSH
6028: LD_INT 2
6030: PUSH
6031: LD_INT 24
6033: PUSH
6034: EMPTY
6035: LIST
6036: LIST
6037: LIST
6038: LIST
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: LIST
6044: LIST
6045: LIST
6046: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6047: LD_VAR 0 2
6051: PPUSH
6052: LD_VAR 0 3
6056: PPUSH
6057: CALL 79703 0 2
// repeat wait ( 0 0$1 ) ;
6061: LD_INT 35
6063: PPUSH
6064: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6068: LD_EXP 77
6072: PUSH
6073: LD_VAR 0 2
6077: ARRAY
6078: PUSH
6079: LD_INT 6
6081: GREATEREQUAL
6082: IFFALSE 6061
// wait ( 0 0$20 ) ;
6084: LD_INT 700
6086: PPUSH
6087: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6091: LD_ADDR_VAR 0 5
6095: PUSH
6096: LD_INT 119
6098: PUSH
6099: LD_INT 9
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PUSH
6106: EMPTY
6107: LIST
6108: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6109: LD_ADDR_VAR 0 6
6113: PUSH
6114: LD_EXP 77
6118: PUSH
6119: LD_VAR 0 2
6123: ARRAY
6124: PUSH
6125: LD_EXP 77
6129: PUSH
6130: LD_VAR 0 2
6134: ARRAY
6135: PPUSH
6136: LD_INT 34
6138: PUSH
6139: LD_INT 32
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: PPUSH
6146: CALL_OW 72
6150: DIFF
6151: ST_TO_ADDR
// if not attackers then
6152: LD_VAR 0 6
6156: NOT
6157: IFFALSE 6161
// exit ;
6159: GO 6340
// uc_side := 2 ;
6161: LD_ADDR_OWVAR 20
6165: PUSH
6166: LD_INT 2
6168: ST_TO_ADDR
// uc_nation := 2 ;
6169: LD_ADDR_OWVAR 21
6173: PUSH
6174: LD_INT 2
6176: ST_TO_ADDR
// InitHc ;
6177: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6181: LD_ADDR_VAR 0 1
6185: PUSH
6186: DOUBLE
6187: LD_INT 1
6189: DEC
6190: ST_TO_ADDR
6191: LD_INT 4
6193: PUSH
6194: LD_INT 5
6196: PUSH
6197: LD_INT 6
6199: PUSH
6200: EMPTY
6201: LIST
6202: LIST
6203: LIST
6204: PUSH
6205: LD_OWVAR 67
6209: ARRAY
6210: PUSH
6211: FOR_TO
6212: IFFALSE 6289
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6214: LD_INT 0
6216: PPUSH
6217: LD_INT 15
6219: PUSH
6220: LD_INT 17
6222: PUSH
6223: EMPTY
6224: LIST
6225: LIST
6226: PUSH
6227: LD_INT 1
6229: PPUSH
6230: LD_INT 2
6232: PPUSH
6233: CALL_OW 12
6237: ARRAY
6238: PPUSH
6239: LD_INT 8
6241: PPUSH
6242: CALL_OW 380
// un := CreateHuman ;
6246: LD_ADDR_VAR 0 7
6250: PUSH
6251: CALL_OW 44
6255: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6256: LD_VAR 0 7
6260: PPUSH
6261: LD_INT 23
6263: PPUSH
6264: LD_INT 0
6266: PPUSH
6267: CALL_OW 49
// attackers := attackers union un ;
6271: LD_ADDR_VAR 0 6
6275: PUSH
6276: LD_VAR 0 6
6280: PUSH
6281: LD_VAR 0 7
6285: UNION
6286: ST_TO_ADDR
// end ;
6287: GO 6211
6289: POP
6290: POP
// repeat wait ( 0 0$1 ) ;
6291: LD_INT 35
6293: PPUSH
6294: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6298: LD_VAR 0 6
6302: PPUSH
6303: LD_INT 60
6305: PUSH
6306: EMPTY
6307: LIST
6308: PPUSH
6309: CALL_OW 72
6313: NOT
6314: IFFALSE 6291
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6316: LD_VAR 0 2
6320: PPUSH
6321: LD_VAR 0 6
6325: PPUSH
6326: LD_VAR 0 5
6330: PPUSH
6331: LD_VAR 0 4
6335: PPUSH
6336: CALL 79888 0 4
// end ; end_of_file
6340: PPOPN 7
6342: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6343: LD_INT 0
6345: PPUSH
6346: PPUSH
6347: PPUSH
6348: PPUSH
// uc_side := 1 ;
6349: LD_ADDR_OWVAR 20
6353: PUSH
6354: LD_INT 1
6356: ST_TO_ADDR
// uc_nation := 1 ;
6357: LD_ADDR_OWVAR 21
6361: PUSH
6362: LD_INT 1
6364: ST_TO_ADDR
// InitHc ;
6365: CALL_OW 19
// InitVc ;
6369: CALL_OW 20
// tmp := [ ] ;
6373: LD_ADDR_VAR 0 3
6377: PUSH
6378: EMPTY
6379: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6380: LD_ADDR_VAR 0 2
6384: PUSH
6385: DOUBLE
6386: LD_INT 1
6388: DEC
6389: ST_TO_ADDR
6390: LD_INT 5
6392: PUSH
6393: LD_INT 6
6395: PUSH
6396: LD_INT 6
6398: PUSH
6399: EMPTY
6400: LIST
6401: LIST
6402: LIST
6403: PUSH
6404: LD_OWVAR 67
6408: ARRAY
6409: PUSH
6410: FOR_TO
6411: IFFALSE 6548
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6413: LD_INT 2
6415: PUSH
6416: LD_INT 4
6418: PUSH
6419: LD_INT 5
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: LIST
6426: PUSH
6427: LD_INT 1
6429: PPUSH
6430: LD_INT 3
6432: PPUSH
6433: CALL_OW 12
6437: ARRAY
6438: PPUSH
6439: LD_INT 1
6441: PUSH
6442: LD_INT 3
6444: PUSH
6445: EMPTY
6446: LIST
6447: LIST
6448: PUSH
6449: LD_INT 1
6451: PPUSH
6452: LD_INT 2
6454: PPUSH
6455: CALL_OW 12
6459: ARRAY
6460: PPUSH
6461: LD_INT 3
6463: PPUSH
6464: LD_INT 9
6466: PUSH
6467: LD_INT 7
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: PUSH
6474: LD_INT 1
6476: PPUSH
6477: LD_INT 2
6479: PPUSH
6480: CALL_OW 12
6484: ARRAY
6485: PPUSH
6486: LD_INT 78
6488: PPUSH
6489: CALL 20520 0 5
// veh := CreateVehicle ;
6493: LD_ADDR_VAR 0 4
6497: PUSH
6498: CALL_OW 45
6502: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6503: LD_VAR 0 4
6507: PPUSH
6508: LD_INT 2
6510: PPUSH
6511: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6515: LD_VAR 0 4
6519: PPUSH
6520: LD_INT 17
6522: PPUSH
6523: LD_INT 0
6525: PPUSH
6526: CALL_OW 49
// tmp := tmp ^ veh ;
6530: LD_ADDR_VAR 0 3
6534: PUSH
6535: LD_VAR 0 3
6539: PUSH
6540: LD_VAR 0 4
6544: ADD
6545: ST_TO_ADDR
// end ;
6546: GO 6410
6548: POP
6549: POP
// if not tmp then
6550: LD_VAR 0 3
6554: NOT
6555: IFFALSE 6559
// exit ;
6557: GO 6668
// if not first_powell_attack then
6559: LD_EXP 11
6563: NOT
6564: IFFALSE 6574
// first_powell_attack := true ;
6566: LD_ADDR_EXP 11
6570: PUSH
6571: LD_INT 1
6573: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6574: LD_INT 70
6576: PPUSH
6577: CALL_OW 67
// for i in tmp do
6581: LD_ADDR_VAR 0 2
6585: PUSH
6586: LD_VAR 0 3
6590: PUSH
6591: FOR_IN
6592: IFFALSE 6659
// if IsOk ( i ) then
6594: LD_VAR 0 2
6598: PPUSH
6599: CALL_OW 302
6603: IFFALSE 6641
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6605: LD_VAR 0 2
6609: PPUSH
6610: LD_INT 81
6612: PUSH
6613: LD_INT 1
6615: PUSH
6616: EMPTY
6617: LIST
6618: LIST
6619: PPUSH
6620: CALL_OW 69
6624: PPUSH
6625: LD_VAR 0 2
6629: PPUSH
6630: CALL_OW 74
6634: PPUSH
6635: CALL_OW 115
6639: GO 6657
// tmp := tmp diff i ;
6641: LD_ADDR_VAR 0 3
6645: PUSH
6646: LD_VAR 0 3
6650: PUSH
6651: LD_VAR 0 2
6655: DIFF
6656: ST_TO_ADDR
6657: GO 6591
6659: POP
6660: POP
// until not tmp ;
6661: LD_VAR 0 3
6665: NOT
6666: IFFALSE 6574
// end ; end_of_file
6668: LD_VAR 0 1
6672: RET
// export function Action ; var tmp , i , un ; begin
6673: LD_INT 0
6675: PPUSH
6676: PPUSH
6677: PPUSH
6678: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6679: LD_INT 68
6681: PPUSH
6682: LD_INT 39
6684: PPUSH
6685: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6689: LD_ADDR_VAR 0 2
6693: PUSH
6694: LD_INT 22
6696: PUSH
6697: LD_INT 7
6699: PUSH
6700: EMPTY
6701: LIST
6702: LIST
6703: PPUSH
6704: CALL_OW 69
6708: ST_TO_ADDR
// InGameOn ;
6709: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6713: LD_VAR 0 2
6717: PPUSH
6718: LD_INT 71
6720: PPUSH
6721: LD_INT 49
6723: PPUSH
6724: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6728: LD_INT 35
6730: PPUSH
6731: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6735: LD_INT 7
6737: PPUSH
6738: LD_INT 71
6740: PPUSH
6741: LD_INT 51
6743: PPUSH
6744: CALL_OW 293
6748: IFFALSE 6728
// DialogueOn ;
6750: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6754: LD_EXP 14
6758: PPUSH
6759: LD_STRING D1-JMM-1
6761: PPUSH
6762: CALL_OW 88
// if Joan then
6766: LD_EXP 29
6770: IFFALSE 6784
// Say ( Joan , D1-Joan-1 ) ;
6772: LD_EXP 29
6776: PPUSH
6777: LD_STRING D1-Joan-1
6779: PPUSH
6780: CALL_OW 88
// if Lisa then
6784: LD_EXP 16
6788: IFFALSE 6802
// Say ( Lisa , D1-Lisa-1 ) ;
6790: LD_EXP 16
6794: PPUSH
6795: LD_STRING D1-Lisa-1
6797: PPUSH
6798: CALL_OW 88
// if Joan or Lisa then
6802: LD_EXP 29
6806: PUSH
6807: LD_EXP 16
6811: OR
6812: IFFALSE 6826
// Say ( JMM , D1-JMM-2 ) ;
6814: LD_EXP 14
6818: PPUSH
6819: LD_STRING D1-JMM-2
6821: PPUSH
6822: CALL_OW 88
// DialogueOff ;
6826: CALL_OW 7
// InGameOff ;
6830: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6834: LD_INT 71
6836: PPUSH
6837: LD_INT 50
6839: PPUSH
6840: LD_INT 7
6842: PPUSH
6843: LD_INT 30
6845: NEG
6846: PPUSH
6847: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6851: LD_INT 71
6853: PPUSH
6854: LD_INT 50
6856: PPUSH
6857: LD_INT 7
6859: PPUSH
6860: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6864: LD_STRING M1
6866: PPUSH
6867: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6871: LD_INT 35
6873: PPUSH
6874: CALL_OW 67
// until freedom ;
6878: LD_EXP 3
6882: IFFALSE 6871
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6884: LD_INT 350
6886: PPUSH
6887: LD_INT 700
6889: PPUSH
6890: CALL_OW 12
6894: PPUSH
6895: CALL_OW 67
// PrepareGossudarov ;
6899: CALL 1691 0 0
// repeat wait ( 0 0$1 ) ;
6903: LD_INT 35
6905: PPUSH
6906: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
6910: LD_INT 22
6912: PUSH
6913: LD_INT 6
6915: PUSH
6916: EMPTY
6917: LIST
6918: LIST
6919: PUSH
6920: LD_INT 3
6922: PUSH
6923: LD_INT 24
6925: PUSH
6926: LD_INT 1000
6928: PUSH
6929: EMPTY
6930: LIST
6931: LIST
6932: PUSH
6933: EMPTY
6934: LIST
6935: LIST
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: PPUSH
6941: CALL_OW 69
6945: PUSH
6946: LD_INT 7
6948: PPUSH
6949: LD_EXP 31
6953: PPUSH
6954: CALL_OW 292
6958: OR
6959: IFFALSE 6903
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
6961: LD_ADDR_VAR 0 2
6965: PUSH
6966: LD_INT 22
6968: PUSH
6969: LD_INT 6
6971: PUSH
6972: EMPTY
6973: LIST
6974: LIST
6975: PPUSH
6976: CALL_OW 69
6980: ST_TO_ADDR
// for i in tmp do
6981: LD_ADDR_VAR 0 3
6985: PUSH
6986: LD_VAR 0 2
6990: PUSH
6991: FOR_IN
6992: IFFALSE 7008
// SetSide ( i , 7 ) ;
6994: LD_VAR 0 3
6998: PPUSH
6999: LD_INT 7
7001: PPUSH
7002: CALL_OW 235
7006: GO 6991
7008: POP
7009: POP
// DialogueOn ;
7010: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7014: LD_EXP 14
7018: PUSH
7019: LD_EXP 15
7023: PUSH
7024: EMPTY
7025: LIST
7026: LIST
7027: PPUSH
7028: LD_EXP 31
7032: PPUSH
7033: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7037: LD_EXP 31
7041: PPUSH
7042: CALL_OW 87
// if not Roth then
7046: LD_EXP 15
7050: NOT
7051: IFFALSE 7143
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7053: LD_VAR 0 2
7057: PPUSH
7058: LD_INT 3
7060: PUSH
7061: LD_INT 24
7063: PUSH
7064: LD_INT 1000
7066: PUSH
7067: EMPTY
7068: LIST
7069: LIST
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: PPUSH
7075: CALL_OW 72
7079: IFFALSE 7093
// Say ( JMM , D2-JMM-1 ) ;
7081: LD_EXP 14
7085: PPUSH
7086: LD_STRING D2-JMM-1
7088: PPUSH
7089: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7093: LD_EXP 14
7097: PPUSH
7098: LD_STRING D2-JMM-1b
7100: PPUSH
7101: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7105: LD_EXP 31
7109: PPUSH
7110: LD_STRING D2-Gos-1
7112: PPUSH
7113: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7117: LD_EXP 14
7121: PPUSH
7122: LD_STRING D2-JMM-2
7124: PPUSH
7125: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7129: LD_EXP 31
7133: PPUSH
7134: LD_STRING D2-Gos-2
7136: PPUSH
7137: CALL_OW 88
// end else
7141: GO 7295
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7143: LD_VAR 0 2
7147: PPUSH
7148: LD_INT 3
7150: PUSH
7151: LD_INT 24
7153: PUSH
7154: LD_INT 1000
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: PUSH
7161: EMPTY
7162: LIST
7163: LIST
7164: PPUSH
7165: CALL_OW 72
7169: IFFALSE 7195
// begin Say ( Roth , D2-Roth-2 ) ;
7171: LD_EXP 15
7175: PPUSH
7176: LD_STRING D2-Roth-2
7178: PPUSH
7179: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7183: LD_EXP 14
7187: PPUSH
7188: LD_STRING D2-JMM-1a
7190: PPUSH
7191: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7195: LD_EXP 15
7199: PPUSH
7200: LD_STRING D2-Roth-2a
7202: PPUSH
7203: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7207: LD_EXP 15
7211: PPUSH
7212: LD_STRING D2-Roth-2b
7214: PPUSH
7215: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7219: LD_EXP 14
7223: PPUSH
7224: LD_STRING D2-JMM-3
7226: PPUSH
7227: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7231: LD_VAR 0 2
7235: PPUSH
7236: LD_INT 3
7238: PUSH
7239: LD_INT 24
7241: PUSH
7242: LD_INT 1000
7244: PUSH
7245: EMPTY
7246: LIST
7247: LIST
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: PPUSH
7253: CALL_OW 72
7257: IFFALSE 7295
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7259: LD_EXP 31
7263: PPUSH
7264: LD_STRING D2-Gos-3
7266: PPUSH
7267: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7271: LD_EXP 14
7275: PPUSH
7276: LD_STRING D2-JMM-4
7278: PPUSH
7279: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7283: LD_EXP 31
7287: PPUSH
7288: LD_STRING D2-Gos-4
7290: PPUSH
7291: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7295: LD_EXP 14
7299: PPUSH
7300: LD_STRING D2-JMM-5
7302: PPUSH
7303: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7307: LD_EXP 31
7311: PPUSH
7312: LD_STRING D2-Gos-5
7314: PPUSH
7315: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7319: LD_EXP 14
7323: PPUSH
7324: LD_STRING D2-JMM-6
7326: PPUSH
7327: CALL_OW 88
// DialogueOff ;
7331: CALL_OW 7
// wait ( 0 0$2 ) ;
7335: LD_INT 70
7337: PPUSH
7338: CALL_OW 67
// if Kirilenkova then
7342: LD_EXP 32
7346: IFFALSE 7360
// Say ( Kirilenkova , D3-Kir-1 ) ;
7348: LD_EXP 32
7352: PPUSH
7353: LD_STRING D3-Kir-1
7355: PPUSH
7356: CALL_OW 88
// gossudarov_arrive := true ;
7360: LD_ADDR_EXP 4
7364: PUSH
7365: LD_INT 1
7367: ST_TO_ADDR
// Hint ( CombinedForces ) ;
7368: LD_STRING CombinedForces
7370: PPUSH
7371: CALL_OW 339
// repeat wait ( 0 0$1 ) ;
7375: LD_INT 35
7377: PPUSH
7378: CALL_OW 67
// until ru_lab_builded ;
7382: LD_EXP 5
7386: IFFALSE 7375
// if Kirilenkova then
7388: LD_EXP 32
7392: IFFALSE 7408
// Say ( Kirilenkova , D3a-Kir-1 ) else
7394: LD_EXP 32
7398: PPUSH
7399: LD_STRING D3a-Kir-1
7401: PPUSH
7402: CALL_OW 88
7406: GO 7430
// begin un := SciRu ;
7408: LD_ADDR_VAR 0 4
7412: PUSH
7413: CALL 12400 0 0
7417: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7418: LD_VAR 0 4
7422: PPUSH
7423: LD_STRING D3a-Sci1-1
7425: PPUSH
7426: CALL_OW 88
// end ; if Kirilenkova or un then
7430: LD_EXP 32
7434: PUSH
7435: LD_VAR 0 4
7439: OR
7440: IFFALSE 7454
// Say ( JMM , D3a-JMM-1 ) ;
7442: LD_EXP 14
7446: PPUSH
7447: LD_STRING D3a-JMM-1
7449: PPUSH
7450: CALL_OW 88
// end ;
7454: LD_VAR 0 1
7458: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7459: LD_EXP 4
7463: PUSH
7464: LD_INT 22
7466: PUSH
7467: LD_INT 7
7469: PUSH
7470: EMPTY
7471: LIST
7472: LIST
7473: PUSH
7474: LD_INT 2
7476: PUSH
7477: LD_INT 25
7479: PUSH
7480: LD_INT 1
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: PUSH
7487: LD_INT 25
7489: PUSH
7490: LD_INT 2
7492: PUSH
7493: EMPTY
7494: LIST
7495: LIST
7496: PUSH
7497: LD_INT 25
7499: PUSH
7500: LD_INT 3
7502: PUSH
7503: EMPTY
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 25
7509: PUSH
7510: LD_INT 4
7512: PUSH
7513: EMPTY
7514: LIST
7515: LIST
7516: PUSH
7517: LD_INT 25
7519: PUSH
7520: LD_INT 5
7522: PUSH
7523: EMPTY
7524: LIST
7525: LIST
7526: PUSH
7527: LD_INT 25
7529: PUSH
7530: LD_INT 8
7532: PUSH
7533: EMPTY
7534: LIST
7535: LIST
7536: PUSH
7537: LD_INT 25
7539: PUSH
7540: LD_INT 9
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: LIST
7551: LIST
7552: LIST
7553: LIST
7554: LIST
7555: LIST
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: PPUSH
7561: CALL_OW 69
7565: PUSH
7566: LD_INT 7
7568: LESS
7569: AND
7570: IFFALSE 7582
7572: GO 7574
7574: DISABLE
// YouLost ( TooMany ) ;
7575: LD_STRING TooMany
7577: PPUSH
7578: CALL_OW 104
7582: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7583: LD_EXP 31
7587: PPUSH
7588: CALL_OW 255
7592: PUSH
7593: LD_INT 7
7595: EQUAL
7596: IFFALSE 7796
7598: GO 7600
7600: DISABLE
7601: LD_INT 0
7603: PPUSH
7604: PPUSH
7605: PPUSH
// begin uc_side := 3 ;
7606: LD_ADDR_OWVAR 20
7610: PUSH
7611: LD_INT 3
7613: ST_TO_ADDR
// uc_nation := 3 ;
7614: LD_ADDR_OWVAR 21
7618: PUSH
7619: LD_INT 3
7621: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7622: LD_INT 21
7624: PPUSH
7625: LD_INT 3
7627: PPUSH
7628: LD_INT 3
7630: PPUSH
7631: LD_INT 42
7633: PPUSH
7634: LD_INT 100
7636: PPUSH
7637: CALL 20520 0 5
// un := CreateVehicle ;
7641: LD_ADDR_VAR 0 3
7645: PUSH
7646: CALL_OW 45
7650: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7651: LD_VAR 0 3
7655: PPUSH
7656: LD_INT 15
7658: PPUSH
7659: LD_INT 0
7661: PPUSH
7662: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7666: LD_VAR 0 3
7670: PPUSH
7671: LD_INT 67
7673: PPUSH
7674: LD_INT 45
7676: PPUSH
7677: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7681: LD_VAR 0 3
7685: PPUSH
7686: LD_INT 70
7688: PPUSH
7689: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7693: LD_VAR 0 3
7697: PPUSH
7698: LD_INT 69
7700: PPUSH
7701: LD_INT 18
7703: PPUSH
7704: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7708: LD_VAR 0 3
7712: PPUSH
7713: LD_INT 60
7715: PPUSH
7716: LD_INT 2
7718: PPUSH
7719: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7723: LD_INT 35
7725: PPUSH
7726: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7730: LD_VAR 0 3
7734: PPUSH
7735: CALL_OW 302
7739: NOT
7740: PUSH
7741: LD_VAR 0 3
7745: PPUSH
7746: LD_INT 17
7748: PPUSH
7749: CALL_OW 308
7753: OR
7754: IFFALSE 7723
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7756: LD_VAR 0 3
7760: PPUSH
7761: LD_INT 17
7763: PPUSH
7764: CALL_OW 308
7768: PUSH
7769: LD_VAR 0 3
7773: PPUSH
7774: LD_INT 60
7776: PPUSH
7777: LD_INT 2
7779: PPUSH
7780: CALL_OW 307
7784: OR
7785: IFFALSE 7796
// RemoveUnit ( un ) ;
7787: LD_VAR 0 3
7791: PPUSH
7792: CALL_OW 64
// end ;
7796: PPOPN 3
7798: END
// every 0 0$2 do var i , un , tmp ;
7799: GO 7801
7801: DISABLE
7802: LD_INT 0
7804: PPUSH
7805: PPUSH
7806: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7807: LD_INT 70
7809: PPUSH
7810: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7814: LD_ADDR_VAR 0 3
7818: PUSH
7819: LD_INT 22
7821: PUSH
7822: LD_INT 7
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: PUSH
7829: LD_INT 101
7831: PUSH
7832: LD_INT 3
7834: PUSH
7835: EMPTY
7836: LIST
7837: LIST
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: PPUSH
7843: CALL_OW 69
7847: ST_TO_ADDR
// until tmp ;
7848: LD_VAR 0 3
7852: IFFALSE 7807
// un := NearestUnitToUnit ( tmp , JMM ) ;
7854: LD_ADDR_VAR 0 2
7858: PUSH
7859: LD_VAR 0 3
7863: PPUSH
7864: LD_EXP 14
7868: PPUSH
7869: CALL_OW 74
7873: ST_TO_ADDR
// player_spotted := true ;
7874: LD_ADDR_EXP 6
7878: PUSH
7879: LD_INT 1
7881: ST_TO_ADDR
// tmp := SciRu ;
7882: LD_ADDR_VAR 0 3
7886: PUSH
7887: CALL 12400 0 0
7891: ST_TO_ADDR
// if not tmp then
7892: LD_VAR 0 3
7896: NOT
7897: IFFALSE 7909
// tmp := SolRu ;
7899: LD_ADDR_VAR 0 3
7903: PUSH
7904: CALL 12547 0 0
7908: ST_TO_ADDR
// DialogueOn ;
7909: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7913: LD_VAR 0 2
7917: PPUSH
7918: CALL_OW 250
7922: PPUSH
7923: LD_VAR 0 2
7927: PPUSH
7928: CALL_OW 251
7932: PPUSH
7933: LD_INT 7
7935: PPUSH
7936: LD_INT 8
7938: NEG
7939: PPUSH
7940: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7944: LD_VAR 0 2
7948: PPUSH
7949: CALL_OW 87
// if tmp then
7953: LD_VAR 0 3
7957: IFFALSE 7971
// Say ( tmp , D4-RSci1-1 ) ;
7959: LD_VAR 0 3
7963: PPUSH
7964: LD_STRING D4-RSci1-1
7966: PPUSH
7967: CALL_OW 88
// if Gossudarov then
7971: LD_EXP 31
7975: IFFALSE 8001
// begin Say ( Gossudarov , D4-Gos-1 ) ;
7977: LD_EXP 31
7981: PPUSH
7982: LD_STRING D4-Gos-1
7984: PPUSH
7985: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
7989: LD_EXP 14
7993: PPUSH
7994: LD_STRING D4-JMM-1
7996: PPUSH
7997: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8001: LD_VAR 0 2
8005: PPUSH
8006: CALL_OW 250
8010: PPUSH
8011: LD_VAR 0 2
8015: PPUSH
8016: CALL_OW 251
8020: PPUSH
8021: LD_INT 7
8023: PPUSH
8024: CALL_OW 331
// DialogueOff ;
8028: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8032: LD_STRING M5
8034: PPUSH
8035: CALL_OW 337
// end ;
8039: PPOPN 3
8041: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8042: LD_EXP 6
8046: IFFALSE 8635
8048: GO 8050
8050: DISABLE
8051: LD_INT 0
8053: PPUSH
8054: PPUSH
8055: PPUSH
// begin PrepareBelkov ;
8056: CALL 1981 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8060: LD_EXP 46
8064: PPUSH
8065: LD_INT 118
8067: PPUSH
8068: LD_INT 106
8070: PPUSH
8071: CALL_OW 111
// AddComHold ( Belkov ) ;
8075: LD_EXP 46
8079: PPUSH
8080: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8084: LD_INT 35
8086: PPUSH
8087: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8091: LD_EXP 46
8095: PPUSH
8096: LD_INT 118
8098: PPUSH
8099: LD_INT 106
8101: PPUSH
8102: CALL_OW 307
8106: IFFALSE 8084
// ChangeSideFog ( 4 , 7 ) ;
8108: LD_INT 4
8110: PPUSH
8111: LD_INT 7
8113: PPUSH
8114: CALL_OW 343
// if IsOk ( Belkov ) then
8118: LD_EXP 46
8122: PPUSH
8123: CALL_OW 302
8127: IFFALSE 8211
// begin InGameOn ;
8129: CALL_OW 8
// DialogueOn ;
8133: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8137: LD_EXP 46
8141: PPUSH
8142: LD_STRING D5-Bel-1
8144: PPUSH
8145: CALL_OW 94
// if Gossudarov then
8149: LD_EXP 31
8153: IFFALSE 8203
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8155: LD_EXP 31
8159: PPUSH
8160: LD_STRING D5-Gos-1
8162: PPUSH
8163: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8167: LD_EXP 14
8171: PPUSH
8172: LD_STRING D5-JMM-1
8174: PPUSH
8175: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8179: LD_EXP 31
8183: PPUSH
8184: LD_STRING D5-Gos-2
8186: PPUSH
8187: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8191: LD_EXP 14
8195: PPUSH
8196: LD_STRING D5-JMM-2
8198: PPUSH
8199: CALL_OW 88
// end ; DialogueOff ;
8203: CALL_OW 7
// InGameOff ;
8207: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8211: LD_STRING QSaveBelkov
8213: PPUSH
8214: CALL_OW 97
8218: PUSH
8219: LD_INT 1
8221: DOUBLE
8222: EQUAL
8223: IFTRUE 8227
8225: GO 8277
8227: POP
// begin DialogueOn ;
8228: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8232: LD_EXP 14
8236: PPUSH
8237: LD_STRING D5a-JMM-1
8239: PPUSH
8240: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8244: LD_EXP 46
8248: PPUSH
8249: LD_STRING D5a-Bel-1
8251: PPUSH
8252: CALL_OW 94
// DialogueOff ;
8256: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8260: LD_EXP 46
8264: PPUSH
8265: LD_INT 83
8267: PPUSH
8268: LD_INT 49
8270: PPUSH
8271: CALL_OW 111
// end ; 2 :
8275: GO 8310
8277: LD_INT 2
8279: DOUBLE
8280: EQUAL
8281: IFTRUE 8285
8283: GO 8309
8285: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8286: LD_EXP 14
8290: PPUSH
8291: LD_STRING D5a-JMM-2
8293: PPUSH
8294: CALL_OW 88
// ComHold ( Belkov ) ;
8298: LD_EXP 46
8302: PPUSH
8303: CALL_OW 140
// end ; end ;
8307: GO 8310
8309: POP
// time := 0 0$00 ;
8310: LD_ADDR_VAR 0 1
8314: PUSH
8315: LD_INT 0
8317: ST_TO_ADDR
// vehSpawned := false ;
8318: LD_ADDR_VAR 0 3
8322: PUSH
8323: LD_INT 0
8325: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8326: LD_INT 35
8328: PPUSH
8329: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8333: LD_VAR 0 1
8337: PUSH
8338: LD_INT 350
8340: PUSH
8341: LD_INT 175
8343: PUSH
8344: LD_INT 70
8346: PUSH
8347: EMPTY
8348: LIST
8349: LIST
8350: LIST
8351: PUSH
8352: LD_OWVAR 67
8356: ARRAY
8357: GREATEREQUAL
8358: PUSH
8359: LD_VAR 0 3
8363: NOT
8364: AND
8365: IFFALSE 8455
// begin vehSpawned := true ;
8367: LD_ADDR_VAR 0 3
8371: PUSH
8372: LD_INT 1
8374: ST_TO_ADDR
// uc_side := 3 ;
8375: LD_ADDR_OWVAR 20
8379: PUSH
8380: LD_INT 3
8382: ST_TO_ADDR
// uc_nation := 3 ;
8383: LD_ADDR_OWVAR 21
8387: PUSH
8388: LD_INT 3
8390: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8391: LD_INT 22
8393: PPUSH
8394: LD_INT 3
8396: PPUSH
8397: LD_INT 3
8399: PPUSH
8400: LD_INT 43
8402: PPUSH
8403: LD_INT 100
8405: PPUSH
8406: CALL 20520 0 5
// veh := CreateVehicle ;
8410: LD_ADDR_VAR 0 2
8414: PUSH
8415: CALL_OW 45
8419: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8420: LD_VAR 0 2
8424: PPUSH
8425: LD_INT 130
8427: PPUSH
8428: LD_INT 131
8430: PPUSH
8431: LD_INT 0
8433: PPUSH
8434: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8438: LD_VAR 0 2
8442: PPUSH
8443: LD_INT 100
8445: PPUSH
8446: LD_INT 82
8448: PPUSH
8449: CALL_OW 114
// end else
8453: GO 8469
// time := time + 0 0$1 ;
8455: LD_ADDR_VAR 0 1
8459: PUSH
8460: LD_VAR 0 1
8464: PUSH
8465: LD_INT 35
8467: PLUS
8468: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8469: LD_EXP 46
8473: PPUSH
8474: CALL_OW 301
8478: PUSH
8479: LD_EXP 46
8483: PPUSH
8484: CALL_OW 255
8488: PUSH
8489: LD_INT 4
8491: EQUAL
8492: AND
8493: PUSH
8494: LD_INT 22
8496: PUSH
8497: LD_INT 7
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: PPUSH
8504: CALL_OW 69
8508: PPUSH
8509: LD_EXP 46
8513: PPUSH
8514: CALL_OW 74
8518: PPUSH
8519: LD_EXP 46
8523: PPUSH
8524: CALL_OW 296
8528: PUSH
8529: LD_INT 10
8531: LESS
8532: OR
8533: IFFALSE 8326
// if IsDead ( Belkov ) then
8535: LD_EXP 46
8539: PPUSH
8540: CALL_OW 301
8544: IFFALSE 8569
// begin CenterNowOnUnits ( Belkov ) ;
8546: LD_EXP 46
8550: PPUSH
8551: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8555: LD_EXP 14
8559: PPUSH
8560: LD_STRING D5a-JMM-2a
8562: PPUSH
8563: CALL_OW 88
// exit ;
8567: GO 8635
// end ; if See ( 7 , Belkov ) then
8569: LD_INT 7
8571: PPUSH
8572: LD_EXP 46
8576: PPUSH
8577: CALL_OW 292
8581: IFFALSE 8595
// SetSide ( Belkov , 7 ) ;
8583: LD_EXP 46
8587: PPUSH
8588: LD_INT 7
8590: PPUSH
8591: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8595: LD_INT 35
8597: PPUSH
8598: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8602: LD_EXP 46
8606: PPUSH
8607: LD_INT 66
8609: PPUSH
8610: LD_INT 45
8612: PPUSH
8613: CALL_OW 297
8617: PUSH
8618: LD_INT 30
8620: LESS
8621: IFFALSE 8595
// Say ( Belkov , D6-Bel-1 ) ;
8623: LD_EXP 46
8627: PPUSH
8628: LD_STRING D6-Bel-1
8630: PPUSH
8631: CALL_OW 88
// end ;
8635: PPOPN 3
8637: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8638: LD_EXP 46
8642: PPUSH
8643: CALL_OW 302
8647: PUSH
8648: LD_EXP 46
8652: PPUSH
8653: CALL_OW 504
8657: PUSH
8658: LD_INT 2
8660: PUSH
8661: LD_INT 34
8663: PUSH
8664: LD_INT 47
8666: PUSH
8667: EMPTY
8668: LIST
8669: LIST
8670: PUSH
8671: LD_INT 34
8673: PUSH
8674: LD_INT 45
8676: PUSH
8677: EMPTY
8678: LIST
8679: LIST
8680: PUSH
8681: EMPTY
8682: LIST
8683: LIST
8684: LIST
8685: PPUSH
8686: CALL_OW 69
8690: IN
8691: AND
8692: IFFALSE 8709
8694: GO 8696
8696: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8697: LD_EXP 46
8701: PPUSH
8702: LD_STRING D7-Bel-1
8704: PPUSH
8705: CALL_OW 88
8709: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8710: LD_INT 22
8712: PUSH
8713: LD_INT 7
8715: PUSH
8716: EMPTY
8717: LIST
8718: LIST
8719: PUSH
8720: LD_INT 101
8722: PUSH
8723: LD_INT 2
8725: PUSH
8726: EMPTY
8727: LIST
8728: LIST
8729: PUSH
8730: EMPTY
8731: LIST
8732: LIST
8733: PPUSH
8734: CALL_OW 69
8738: PUSH
8739: LD_EXP 8
8743: NOT
8744: AND
8745: PUSH
8746: LD_EXP 45
8750: PPUSH
8751: CALL_OW 305
8755: NOT
8756: AND
8757: IFFALSE 9227
8759: GO 8761
8761: DISABLE
8762: LD_INT 0
8764: PPUSH
// begin ar_base_spotted := true ;
8765: LD_ADDR_EXP 8
8769: PUSH
8770: LD_INT 1
8772: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8773: LD_ADDR_VAR 0 1
8777: PUSH
8778: LD_INT 22
8780: PUSH
8781: LD_INT 2
8783: PUSH
8784: EMPTY
8785: LIST
8786: LIST
8787: PUSH
8788: LD_INT 21
8790: PUSH
8791: LD_INT 3
8793: PUSH
8794: EMPTY
8795: LIST
8796: LIST
8797: PUSH
8798: EMPTY
8799: LIST
8800: LIST
8801: PPUSH
8802: CALL_OW 69
8806: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8807: LD_ADDR_VAR 0 1
8811: PUSH
8812: LD_VAR 0 1
8816: PPUSH
8817: LD_EXP 14
8821: PPUSH
8822: CALL_OW 74
8826: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8827: LD_INT 7
8829: PPUSH
8830: LD_INT 3
8832: PPUSH
8833: CALL_OW 332
// DialogueOn ;
8837: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8841: LD_VAR 0 1
8845: PPUSH
8846: CALL_OW 250
8850: PPUSH
8851: LD_VAR 0 1
8855: PPUSH
8856: CALL_OW 251
8860: PPUSH
8861: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8865: LD_ADDR_VAR 0 1
8869: PUSH
8870: LD_INT 22
8872: PUSH
8873: LD_INT 7
8875: PUSH
8876: EMPTY
8877: LIST
8878: LIST
8879: PUSH
8880: LD_INT 23
8882: PUSH
8883: LD_INT 1
8885: PUSH
8886: EMPTY
8887: LIST
8888: LIST
8889: PUSH
8890: LD_INT 26
8892: PUSH
8893: LD_INT 1
8895: PUSH
8896: EMPTY
8897: LIST
8898: LIST
8899: PUSH
8900: EMPTY
8901: LIST
8902: LIST
8903: LIST
8904: PPUSH
8905: CALL_OW 69
8909: PUSH
8910: LD_EXP 14
8914: PUSH
8915: LD_EXP 18
8919: PUSH
8920: LD_EXP 19
8924: PUSH
8925: LD_EXP 26
8929: PUSH
8930: LD_EXP 15
8934: PUSH
8935: LD_EXP 24
8939: PUSH
8940: LD_EXP 20
8944: PUSH
8945: LD_EXP 22
8949: PUSH
8950: EMPTY
8951: LIST
8952: LIST
8953: LIST
8954: LIST
8955: LIST
8956: LIST
8957: LIST
8958: LIST
8959: DIFF
8960: ST_TO_ADDR
// if not tmp then
8961: LD_VAR 0 1
8965: NOT
8966: IFFALSE 9040
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
8968: LD_ADDR_VAR 0 1
8972: PUSH
8973: LD_INT 22
8975: PUSH
8976: LD_INT 7
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: PUSH
8983: LD_INT 23
8985: PUSH
8986: LD_INT 1
8988: PUSH
8989: EMPTY
8990: LIST
8991: LIST
8992: PUSH
8993: LD_INT 26
8995: PUSH
8996: LD_INT 2
8998: PUSH
8999: EMPTY
9000: LIST
9001: LIST
9002: PUSH
9003: EMPTY
9004: LIST
9005: LIST
9006: LIST
9007: PPUSH
9008: CALL_OW 69
9012: PUSH
9013: LD_EXP 29
9017: PUSH
9018: LD_EXP 16
9022: PUSH
9023: LD_EXP 27
9027: PUSH
9028: LD_EXP 28
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: LIST
9037: LIST
9038: DIFF
9039: ST_TO_ADDR
// if tmp then
9040: LD_VAR 0 1
9044: IFFALSE 9115
// case GetSex ( tmp [ 1 ] ) of sex_male :
9046: LD_VAR 0 1
9050: PUSH
9051: LD_INT 1
9053: ARRAY
9054: PPUSH
9055: CALL_OW 258
9059: PUSH
9060: LD_INT 1
9062: DOUBLE
9063: EQUAL
9064: IFTRUE 9068
9066: GO 9087
9068: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9069: LD_VAR 0 1
9073: PUSH
9074: LD_INT 1
9076: ARRAY
9077: PPUSH
9078: LD_STRING D9-Sol1-1
9080: PPUSH
9081: CALL_OW 88
9085: GO 9115
9087: LD_INT 2
9089: DOUBLE
9090: EQUAL
9091: IFTRUE 9095
9093: GO 9114
9095: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9096: LD_VAR 0 1
9100: PUSH
9101: LD_INT 1
9103: ARRAY
9104: PPUSH
9105: LD_STRING D9-FSol1-1
9107: PPUSH
9108: CALL_OW 88
9112: GO 9115
9114: POP
// if Frank then
9115: LD_EXP 26
9119: IFFALSE 9223
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9121: LD_EXP 55
9125: PPUSH
9126: CALL_OW 250
9130: PPUSH
9131: LD_EXP 55
9135: PPUSH
9136: CALL_OW 251
9140: PPUSH
9141: LD_INT 7
9143: PPUSH
9144: LD_INT 8
9146: PPUSH
9147: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9151: LD_EXP 55
9155: PPUSH
9156: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9160: LD_EXP 26
9164: PPUSH
9165: LD_STRING D9-Frank-1
9167: PPUSH
9168: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9172: LD_EXP 14
9176: PPUSH
9177: LD_STRING D9-JMM-1
9179: PPUSH
9180: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9184: LD_EXP 26
9188: PPUSH
9189: LD_STRING D9-Frank-2
9191: PPUSH
9192: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9196: LD_EXP 55
9200: PPUSH
9201: CALL_OW 250
9205: PPUSH
9206: LD_EXP 55
9210: PPUSH
9211: CALL_OW 251
9215: PPUSH
9216: LD_INT 7
9218: PPUSH
9219: CALL_OW 331
// end ; DialogueOff ;
9223: CALL_OW 7
// end ;
9227: PPOPN 1
9229: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9230: LD_EXP 7
9234: PUSH
9235: LD_OWVAR 1
9239: PUSH
9240: LD_INT 42000
9242: GREATEREQUAL
9243: OR
9244: IFFALSE 10271
9246: GO 9248
9248: DISABLE
9249: LD_INT 0
9251: PPUSH
9252: PPUSH
// begin selected_option := 1 ;
9253: LD_ADDR_VAR 0 2
9257: PUSH
9258: LD_INT 1
9260: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9261: LD_INT 10500
9263: PPUSH
9264: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9268: LD_INT 35
9270: PPUSH
9271: CALL_OW 67
// until not ru_attackers ;
9275: LD_EXP 51
9279: NOT
9280: IFFALSE 9268
// PrepareBurlak ;
9282: CALL 2093 0 0
// repeat wait ( 0 0$2 ) ;
9286: LD_INT 70
9288: PPUSH
9289: CALL_OW 67
// until not HasTask ( Burlak ) ;
9293: LD_EXP 45
9297: PPUSH
9298: CALL_OW 314
9302: NOT
9303: IFFALSE 9286
// InGameOn ;
9305: CALL_OW 8
// DialogueOn ;
9309: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9313: LD_EXP 48
9317: PPUSH
9318: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9322: LD_EXP 45
9326: PPUSH
9327: LD_STRING D10-Bur-1
9329: PPUSH
9330: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9334: LD_EXP 46
9338: PUSH
9339: LD_EXP 46
9343: PPUSH
9344: CALL_OW 255
9348: PUSH
9349: LD_INT 7
9351: EQUAL
9352: AND
9353: IFFALSE 9367
// Say ( Belkov , D10-Bel-1 ) ;
9355: LD_EXP 46
9359: PPUSH
9360: LD_STRING D10-Bel-1
9362: PPUSH
9363: CALL_OW 88
// if Gossudarov then
9367: LD_EXP 31
9371: IFFALSE 9385
// Say ( Gossudarov , D10-Gos-1 ) ;
9373: LD_EXP 31
9377: PPUSH
9378: LD_STRING D10-Gos-1
9380: PPUSH
9381: CALL_OW 88
// if Kirilenkova then
9385: LD_EXP 32
9389: IFFALSE 9403
// Say ( Kirilenkova , D10-Kir-1 ) ;
9391: LD_EXP 32
9395: PPUSH
9396: LD_STRING D10-Kir-1
9398: PPUSH
9399: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9403: CALL 12547 0 0
9407: PPUSH
9408: LD_STRING D10-RSol1-1
9410: PPUSH
9411: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9415: LD_EXP 45
9419: PPUSH
9420: LD_STRING D10-Bur-2
9422: PPUSH
9423: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9427: LD_EXP 14
9431: PPUSH
9432: LD_STRING D10-JMM-2
9434: PPUSH
9435: CALL_OW 88
// if Kirilenkova then
9439: LD_EXP 32
9443: IFFALSE 9459
// Say ( Kirilenkova , D10-Kir-2 ) else
9445: LD_EXP 32
9449: PPUSH
9450: LD_STRING D10-Kir-2
9452: PPUSH
9453: CALL_OW 88
9457: GO 9471
// Say ( SolRu , D10-RSol1-2 ) ;
9459: CALL 12547 0 0
9463: PPUSH
9464: LD_STRING D10-RSol1-2
9466: PPUSH
9467: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9471: LD_EXP 14
9475: PPUSH
9476: LD_STRING D10-JMM-3
9478: PPUSH
9479: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9483: LD_EXP 45
9487: PPUSH
9488: LD_STRING D10-Bur-3
9490: PPUSH
9491: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9495: LD_EXP 14
9499: PPUSH
9500: LD_STRING D10-JMM-4
9502: PPUSH
9503: CALL_OW 88
// DialogueOff ;
9507: CALL_OW 7
// InGameOff ;
9511: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9515: LD_STRING M2
9517: PPUSH
9518: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9522: LD_INT 35
9524: PPUSH
9525: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9529: LD_INT 22
9531: PUSH
9532: LD_INT 7
9534: PUSH
9535: EMPTY
9536: LIST
9537: LIST
9538: PUSH
9539: LD_INT 91
9541: PUSH
9542: LD_EXP 45
9546: PUSH
9547: LD_INT 8
9549: PUSH
9550: EMPTY
9551: LIST
9552: LIST
9553: LIST
9554: PUSH
9555: EMPTY
9556: LIST
9557: LIST
9558: PPUSH
9559: CALL_OW 69
9563: IFFALSE 9522
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9565: LD_ADDR_VAR 0 1
9569: PUSH
9570: LD_INT 22
9572: PUSH
9573: LD_INT 4
9575: PUSH
9576: EMPTY
9577: LIST
9578: LIST
9579: PPUSH
9580: CALL_OW 69
9584: PUSH
9585: FOR_IN
9586: IFFALSE 9602
// SetSide ( i , 7 ) ;
9588: LD_VAR 0 1
9592: PPUSH
9593: LD_INT 7
9595: PPUSH
9596: CALL_OW 235
9600: GO 9585
9602: POP
9603: POP
// ChangeMissionObjectives ( M3 ) ;
9604: LD_STRING M3
9606: PPUSH
9607: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9611: LD_INT 35
9613: PPUSH
9614: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9618: LD_EXP 14
9622: PPUSH
9623: LD_EXP 45
9627: PPUSH
9628: CALL_OW 296
9632: PUSH
9633: LD_INT 8
9635: LESS
9636: IFFALSE 9611
// ComTurnUnit ( JMM , Burlak ) ;
9638: LD_EXP 14
9642: PPUSH
9643: LD_EXP 45
9647: PPUSH
9648: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9652: LD_EXP 45
9656: PPUSH
9657: LD_EXP 14
9661: PPUSH
9662: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9666: LD_INT 10
9668: PPUSH
9669: CALL_OW 67
// DialogueOn ;
9673: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9677: LD_EXP 14
9681: PPUSH
9682: LD_STRING D11-JMM-1
9684: PPUSH
9685: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9689: LD_EXP 45
9693: PPUSH
9694: LD_STRING D11-Bur-1
9696: PPUSH
9697: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9701: LD_EXP 14
9705: PPUSH
9706: LD_STRING D11-JMM-2
9708: PPUSH
9709: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9713: LD_EXP 45
9717: PPUSH
9718: LD_STRING D11-Bur-2
9720: PPUSH
9721: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9725: LD_EXP 14
9729: PPUSH
9730: LD_STRING D11-JMM-3
9732: PPUSH
9733: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9737: LD_EXP 45
9741: PPUSH
9742: LD_STRING D11-Bur-3
9744: PPUSH
9745: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9749: LD_EXP 14
9753: PPUSH
9754: LD_STRING D11-JMM-4
9756: PPUSH
9757: CALL_OW 88
// if ar_base_spotted then
9761: LD_EXP 8
9765: IFFALSE 9781
// Say ( Burlak , D12-Bur-1 ) else
9767: LD_EXP 45
9771: PPUSH
9772: LD_STRING D12-Bur-1
9774: PPUSH
9775: CALL_OW 88
9779: GO 9820
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9781: LD_INT 7
9783: PPUSH
9784: LD_INT 3
9786: PPUSH
9787: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9791: LD_INT 127
9793: PPUSH
9794: LD_INT 45
9796: PPUSH
9797: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9801: LD_EXP 45
9805: PPUSH
9806: LD_STRING D12-Bur-1a
9808: PPUSH
9809: CALL_OW 88
// dwait ( 0 0$2 ) ;
9813: LD_INT 70
9815: PPUSH
9816: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9820: LD_EXP 45
9824: PPUSH
9825: LD_STRING D12-Bur-1b
9827: PPUSH
9828: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9832: LD_EXP 14
9836: PPUSH
9837: LD_STRING D12-JMM-1
9839: PPUSH
9840: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9844: LD_EXP 45
9848: PPUSH
9849: LD_STRING D12-Bur-2
9851: PPUSH
9852: CALL_OW 88
// if Roth then
9856: LD_EXP 15
9860: IFFALSE 9876
// Say ( Roth , D12-Roth-2 ) else
9862: LD_EXP 15
9866: PPUSH
9867: LD_STRING D12-Roth-2
9869: PPUSH
9870: CALL_OW 88
9874: GO 9888
// Say ( SciRu , D12-RSci1-2 ) ;
9876: CALL 12400 0 0
9880: PPUSH
9881: LD_STRING D12-RSci1-2
9883: PPUSH
9884: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9888: LD_EXP 14
9892: PPUSH
9893: LD_STRING D12-JMM-2
9895: PPUSH
9896: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9900: LD_EXP 45
9904: PPUSH
9905: LD_STRING D12-Bur-3
9907: PPUSH
9908: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9912: LD_EXP 14
9916: PPUSH
9917: LD_STRING D12-JMM-3
9919: PPUSH
9920: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
9924: LD_EXP 45
9928: PPUSH
9929: LD_STRING D12-Bur-4
9931: PPUSH
9932: CALL_OW 88
// case Query ( QBase ) of 1 :
9936: LD_STRING QBase
9938: PPUSH
9939: CALL_OW 97
9943: PUSH
9944: LD_INT 1
9946: DOUBLE
9947: EQUAL
9948: IFTRUE 9952
9950: GO 10070
9952: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
9953: LD_EXP 14
9957: PPUSH
9958: LD_STRING D13a-JMM-1
9960: PPUSH
9961: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
9965: LD_EXP 45
9969: PPUSH
9970: LD_STRING D13a-Bur-1
9972: PPUSH
9973: CALL_OW 88
// if Roth then
9977: LD_EXP 15
9981: IFFALSE 9997
// Say ( Roth , D13a-Roth-1 ) else
9983: LD_EXP 15
9987: PPUSH
9988: LD_STRING D13a-Roth-1
9990: PPUSH
9991: CALL_OW 88
9995: GO 10009
// Say ( SciRu , D13a-RSci1-1 ) ;
9997: CALL 12400 0 0
10001: PPUSH
10002: LD_STRING D13a-RSci1-1
10004: PPUSH
10005: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10009: LD_EXP 14
10013: PPUSH
10014: LD_STRING D13a-JMM-2
10016: PPUSH
10017: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10021: LD_STRING QBaseAgain
10023: PPUSH
10024: CALL_OW 97
10028: PUSH
10029: LD_INT 1
10031: DOUBLE
10032: EQUAL
10033: IFTRUE 10037
10035: GO 10048
10037: POP
// selected_option := 2 ; 2 :
10038: LD_ADDR_VAR 0 2
10042: PUSH
10043: LD_INT 2
10045: ST_TO_ADDR
10046: GO 10068
10048: LD_INT 2
10050: DOUBLE
10051: EQUAL
10052: IFTRUE 10056
10054: GO 10067
10056: POP
// selected_option := 3 ; end ;
10057: LD_ADDR_VAR 0 2
10061: PUSH
10062: LD_INT 3
10064: ST_TO_ADDR
10065: GO 10068
10067: POP
// end ; 2 :
10068: GO 10109
10070: LD_INT 2
10072: DOUBLE
10073: EQUAL
10074: IFTRUE 10078
10076: GO 10089
10078: POP
// selected_option := 2 ; 3 :
10079: LD_ADDR_VAR 0 2
10083: PUSH
10084: LD_INT 2
10086: ST_TO_ADDR
10087: GO 10109
10089: LD_INT 3
10091: DOUBLE
10092: EQUAL
10093: IFTRUE 10097
10095: GO 10108
10097: POP
// selected_option := 3 ; end ;
10098: LD_ADDR_VAR 0 2
10102: PUSH
10103: LD_INT 3
10105: ST_TO_ADDR
10106: GO 10109
10108: POP
// if selected_option = 2 then
10109: LD_VAR 0 2
10113: PUSH
10114: LD_INT 2
10116: EQUAL
10117: IFFALSE 10211
// begin Say ( JMM , D13b-JMM-1 ) ;
10119: LD_EXP 14
10123: PPUSH
10124: LD_STRING D13b-JMM-1
10126: PPUSH
10127: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10131: LD_EXP 45
10135: PPUSH
10136: LD_STRING D13b-Bur-1
10138: PPUSH
10139: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10143: LD_EXP 14
10147: PPUSH
10148: LD_STRING D13b-JMM-2
10150: PPUSH
10151: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10155: LD_EXP 54
10159: PPUSH
10160: LD_STRING D13b-Abd-2
10162: PPUSH
10163: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10167: LD_EXP 14
10171: PPUSH
10172: LD_STRING D13b-JMM-3
10174: PPUSH
10175: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10179: LD_EXP 54
10183: PPUSH
10184: LD_STRING D13b-Abd-3
10186: PPUSH
10187: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10191: LD_EXP 14
10195: PPUSH
10196: LD_STRING D13b-JMM-4
10198: PPUSH
10199: CALL_OW 88
// ar_active_attack := true ;
10203: LD_ADDR_EXP 9
10207: PUSH
10208: LD_INT 1
10210: ST_TO_ADDR
// end ; if selected_option = 3 then
10211: LD_VAR 0 2
10215: PUSH
10216: LD_INT 3
10218: EQUAL
10219: IFFALSE 10245
// begin Say ( JMM , D13c-JMM-1 ) ;
10221: LD_EXP 14
10225: PPUSH
10226: LD_STRING D13c-JMM-1
10228: PPUSH
10229: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10233: LD_EXP 45
10237: PPUSH
10238: LD_STRING D13c-Bur-1
10240: PPUSH
10241: CALL_OW 88
// end ; DialogueOff ;
10245: CALL_OW 7
// if not ar_active_attack then
10249: LD_EXP 9
10253: NOT
10254: IFFALSE 10271
// begin wait ( 6 6$00 ) ;
10256: LD_INT 12600
10258: PPUSH
10259: CALL_OW 67
// ar_active_attack := true ;
10263: LD_ADDR_EXP 9
10267: PUSH
10268: LD_INT 1
10270: ST_TO_ADDR
// end ; end ;
10271: PPOPN 2
10273: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10274: LD_EXP 45
10278: PPUSH
10279: CALL_OW 305
10283: PUSH
10284: LD_EXP 45
10288: PPUSH
10289: CALL_OW 255
10293: PUSH
10294: LD_INT 7
10296: EQUAL
10297: AND
10298: IFFALSE 10494
10300: GO 10302
10302: DISABLE
10303: LD_INT 0
10305: PPUSH
// begin wait ( 4 4$40 ) ;
10306: LD_INT 9800
10308: PPUSH
10309: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10313: LD_INT 35
10315: PPUSH
10316: CALL_OW 67
// until not ru_attackers ;
10320: LD_EXP 51
10324: NOT
10325: IFFALSE 10313
// PrepareGnyevko ;
10327: CALL 2037 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10331: LD_EXP 47
10335: PPUSH
10336: LD_INT 124
10338: PPUSH
10339: LD_INT 118
10341: PPUSH
10342: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10346: LD_EXP 47
10350: PPUSH
10351: CALL_OW 200
// time := 0 0$00 ;
10355: LD_ADDR_VAR 0 1
10359: PUSH
10360: LD_INT 0
10362: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10363: LD_INT 35
10365: PPUSH
10366: CALL_OW 67
// time := time + 0 0$1 ;
10370: LD_ADDR_VAR 0 1
10374: PUSH
10375: LD_VAR 0 1
10379: PUSH
10380: LD_INT 35
10382: PLUS
10383: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10384: LD_EXP 47
10388: PPUSH
10389: LD_INT 124
10391: PPUSH
10392: LD_INT 118
10394: PPUSH
10395: CALL_OW 307
10399: PUSH
10400: LD_VAR 0 1
10404: PUSH
10405: LD_INT 1050
10407: GREATEREQUAL
10408: OR
10409: IFFALSE 10363
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10411: LD_EXP 47
10415: PPUSH
10416: LD_STRING DBelkov-Gny-1
10418: PPUSH
10419: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10423: LD_EXP 45
10427: PPUSH
10428: LD_STRING DBelkov-Bur-1a
10430: PPUSH
10431: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10435: LD_INT 35
10437: PPUSH
10438: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10442: LD_EXP 47
10446: PPUSH
10447: LD_INT 22
10449: PUSH
10450: LD_INT 7
10452: PUSH
10453: EMPTY
10454: LIST
10455: LIST
10456: PPUSH
10457: CALL_OW 69
10461: PPUSH
10462: LD_EXP 47
10466: PPUSH
10467: CALL_OW 74
10471: PPUSH
10472: CALL_OW 296
10476: PUSH
10477: LD_INT 8
10479: LESS
10480: IFFALSE 10435
// SetSide ( Gnyevko , 7 ) ;
10482: LD_EXP 47
10486: PPUSH
10487: LD_INT 7
10489: PPUSH
10490: CALL_OW 235
// end ;
10494: PPOPN 1
10496: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10497: LD_EXP 45
10501: PPUSH
10502: CALL_OW 255
10506: PUSH
10507: LD_INT 7
10509: EQUAL
10510: IFFALSE 10520
10512: GO 10514
10514: DISABLE
// begin enable ;
10515: ENABLE
// PrepareAmericanAttack ;
10516: CALL 6343 0 0
// end ;
10520: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10521: LD_INT 22
10523: PUSH
10524: LD_INT 1
10526: PUSH
10527: EMPTY
10528: LIST
10529: LIST
10530: PPUSH
10531: CALL_OW 69
10535: IFFALSE 10719
10537: GO 10539
10539: DISABLE
10540: LD_INT 0
10542: PPUSH
10543: PPUSH
// begin while true do
10544: LD_INT 1
10546: IFFALSE 10603
// begin wait ( 0 0$1 ) ;
10548: LD_INT 35
10550: PPUSH
10551: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10555: LD_ADDR_VAR 0 2
10559: PUSH
10560: LD_INT 22
10562: PUSH
10563: LD_INT 1
10565: PUSH
10566: EMPTY
10567: LIST
10568: LIST
10569: PPUSH
10570: CALL_OW 69
10574: PPUSH
10575: LD_EXP 14
10579: PPUSH
10580: CALL_OW 74
10584: ST_TO_ADDR
// if See ( 7 , tmp ) then
10585: LD_INT 7
10587: PPUSH
10588: LD_VAR 0 2
10592: PPUSH
10593: CALL_OW 292
10597: IFFALSE 10601
// break ;
10599: GO 10603
// end ;
10601: GO 10544
// DialogueOn ;
10603: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10607: LD_VAR 0 2
10611: PPUSH
10612: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10616: LD_VAR 0 2
10620: PPUSH
10621: CALL_OW 250
10625: PPUSH
10626: LD_VAR 0 2
10630: PPUSH
10631: CALL_OW 251
10635: PPUSH
10636: LD_INT 7
10638: PPUSH
10639: LD_INT 8
10641: PPUSH
10642: CALL_OW 330
// if Denis then
10646: LD_EXP 20
10650: IFFALSE 10664
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10652: LD_EXP 20
10656: PPUSH
10657: LD_STRING DAmerAttack-Pet-1
10659: PPUSH
10660: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10664: LD_EXP 14
10668: PPUSH
10669: LD_STRING DAmerAttack-JMM-1
10671: PPUSH
10672: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10676: LD_EXP 45
10680: PPUSH
10681: LD_STRING DStop-Bur-1
10683: PPUSH
10684: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10688: LD_VAR 0 2
10692: PPUSH
10693: CALL_OW 250
10697: PPUSH
10698: LD_VAR 0 2
10702: PPUSH
10703: CALL_OW 251
10707: PPUSH
10708: LD_INT 7
10710: PPUSH
10711: CALL_OW 331
// DialogueOff ;
10715: CALL_OW 7
// end ;
10719: PPOPN 2
10721: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10722: LD_INT 22
10724: PUSH
10725: LD_INT 3
10727: PUSH
10728: EMPTY
10729: LIST
10730: LIST
10731: PUSH
10732: LD_INT 21
10734: PUSH
10735: LD_INT 1
10737: PUSH
10738: EMPTY
10739: LIST
10740: LIST
10741: PUSH
10742: EMPTY
10743: LIST
10744: LIST
10745: PPUSH
10746: CALL_OW 69
10750: PUSH
10751: LD_INT 0
10753: EQUAL
10754: IFFALSE 10796
10756: GO 10758
10758: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10759: LD_STRING M5a
10761: PPUSH
10762: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10766: LD_EXP 14
10770: PPUSH
10771: LD_STRING D8-JMM-1
10773: PPUSH
10774: CALL_OW 88
// if Gossudarov then
10778: LD_EXP 31
10782: IFFALSE 10796
// Say ( Gossudarov , D8-Gos-1 ) ;
10784: LD_EXP 31
10788: PPUSH
10789: LD_STRING D8-Gos-1
10791: PPUSH
10792: CALL_OW 88
// end ;
10796: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10797: LD_INT 22
10799: PUSH
10800: LD_INT 2
10802: PUSH
10803: EMPTY
10804: LIST
10805: LIST
10806: PUSH
10807: LD_INT 21
10809: PUSH
10810: LD_INT 1
10812: PUSH
10813: EMPTY
10814: LIST
10815: LIST
10816: PUSH
10817: EMPTY
10818: LIST
10819: LIST
10820: PPUSH
10821: CALL_OW 69
10825: PUSH
10826: LD_INT 0
10828: EQUAL
10829: IFFALSE 10879
10831: GO 10833
10833: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10834: LD_STRING M4c
10836: PPUSH
10837: CALL_OW 337
// if Roth then
10841: LD_EXP 15
10845: IFFALSE 10861
// Say ( Roth , DStop-Roth-1 ) else
10847: LD_EXP 15
10851: PPUSH
10852: LD_STRING DStop-Roth-1
10854: PPUSH
10855: CALL_OW 88
10859: GO 10879
// if Gossudarov then
10861: LD_EXP 31
10865: IFFALSE 10879
// Say ( Gossudarov , D8-Gos-1a ) ;
10867: LD_EXP 31
10871: PPUSH
10872: LD_STRING D8-Gos-1a
10874: PPUSH
10875: CALL_OW 88
// end ;
10879: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10880: LD_INT 7
10882: PPUSH
10883: LD_INT 1
10885: PPUSH
10886: LD_INT 1
10888: PPUSH
10889: CALL 13980 0 3
10893: PUSH
10894: LD_INT 0
10896: EQUAL
10897: PUSH
10898: LD_INT 7
10900: PPUSH
10901: LD_INT 3
10903: PPUSH
10904: LD_INT 1
10906: PPUSH
10907: CALL 13980 0 3
10911: PUSH
10912: LD_INT 0
10914: EQUAL
10915: AND
10916: IFFALSE 10928
10918: GO 10920
10920: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
10921: LD_STRING M1a
10923: PPUSH
10924: CALL_OW 337
// end ;
10928: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 ;
10929: LD_INT 22
10931: PUSH
10932: LD_INT 2
10934: PUSH
10935: EMPTY
10936: LIST
10937: LIST
10938: PUSH
10939: LD_INT 21
10941: PUSH
10942: LD_INT 1
10944: PUSH
10945: EMPTY
10946: LIST
10947: LIST
10948: PUSH
10949: EMPTY
10950: LIST
10951: LIST
10952: PPUSH
10953: CALL_OW 69
10957: PUSH
10958: LD_INT 0
10960: EQUAL
10961: PUSH
10962: LD_INT 22
10964: PUSH
10965: LD_INT 3
10967: PUSH
10968: EMPTY
10969: LIST
10970: LIST
10971: PUSH
10972: LD_INT 21
10974: PUSH
10975: LD_INT 1
10977: PUSH
10978: EMPTY
10979: LIST
10980: LIST
10981: PUSH
10982: EMPTY
10983: LIST
10984: LIST
10985: PPUSH
10986: CALL_OW 69
10990: PUSH
10991: LD_INT 0
10993: EQUAL
10994: AND
10995: PUSH
10996: LD_INT 22
10998: PUSH
10999: LD_INT 1
11001: PUSH
11002: EMPTY
11003: LIST
11004: LIST
11005: PPUSH
11006: CALL_OW 69
11010: PUSH
11011: LD_INT 0
11013: EQUAL
11014: AND
11015: PUSH
11016: LD_INT 7
11018: PPUSH
11019: LD_INT 1
11021: PPUSH
11022: LD_INT 1
11024: PPUSH
11025: CALL 13980 0 3
11029: PUSH
11030: LD_INT 0
11032: EQUAL
11033: AND
11034: PUSH
11035: LD_INT 7
11037: PPUSH
11038: LD_INT 3
11040: PPUSH
11041: LD_INT 1
11043: PPUSH
11044: CALL 13980 0 3
11048: PUSH
11049: LD_INT 0
11051: EQUAL
11052: AND
11053: IFFALSE 12397
11055: GO 11057
11057: DISABLE
11058: LD_INT 0
11060: PPUSH
11061: PPUSH
11062: PPUSH
// begin wait ( 0 0$3 ) ;
11063: LD_INT 105
11065: PPUSH
11066: CALL_OW 67
// if not IsDead ( Masha ) then
11070: LD_EXP 48
11074: PPUSH
11075: CALL_OW 301
11079: NOT
11080: IFFALSE 11094
// AddMedal ( Masha , 1 ) else
11082: LD_STRING Masha
11084: PPUSH
11085: LD_INT 1
11087: PPUSH
11088: CALL_OW 101
11092: GO 11105
// AddMedal ( Masha , - 1 ) ;
11094: LD_STRING Masha
11096: PPUSH
11097: LD_INT 1
11099: NEG
11100: PPUSH
11101: CALL_OW 101
// if abdul_escaped then
11105: LD_EXP 12
11109: IFFALSE 11124
// AddMedal ( Abdul , - 1 ) else
11111: LD_STRING Abdul
11113: PPUSH
11114: LD_INT 1
11116: NEG
11117: PPUSH
11118: CALL_OW 101
11122: GO 11134
// AddMedal ( Abdul , 1 ) ;
11124: LD_STRING Abdul
11126: PPUSH
11127: LD_INT 1
11129: PPUSH
11130: CALL_OW 101
// if loss_counter = 0 then
11134: LD_EXP 13
11138: PUSH
11139: LD_INT 0
11141: EQUAL
11142: IFFALSE 11156
// AddMedal ( People , 2 ) else
11144: LD_STRING People
11146: PPUSH
11147: LD_INT 2
11149: PPUSH
11150: CALL_OW 101
11154: GO 11206
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11156: LD_EXP 13
11160: PUSH
11161: LD_INT 3
11163: PUSH
11164: LD_INT 2
11166: PUSH
11167: LD_INT 2
11169: PUSH
11170: EMPTY
11171: LIST
11172: LIST
11173: LIST
11174: PUSH
11175: LD_OWVAR 67
11179: ARRAY
11180: LESSEQUAL
11181: IFFALSE 11195
// AddMedal ( People , 1 ) else
11183: LD_STRING People
11185: PPUSH
11186: LD_INT 1
11188: PPUSH
11189: CALL_OW 101
11193: GO 11206
// AddMedal ( People , - 1 ) ;
11195: LD_STRING People
11197: PPUSH
11198: LD_INT 1
11200: NEG
11201: PPUSH
11202: CALL_OW 101
// GiveMedals ( MAIN ) ;
11206: LD_STRING MAIN
11208: PPUSH
11209: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11213: LD_ADDR_VAR 0 2
11217: PUSH
11218: LD_INT 22
11220: PUSH
11221: LD_INT 7
11223: PUSH
11224: EMPTY
11225: LIST
11226: LIST
11227: PUSH
11228: LD_INT 2
11230: PUSH
11231: LD_INT 25
11233: PUSH
11234: LD_INT 1
11236: PUSH
11237: EMPTY
11238: LIST
11239: LIST
11240: PUSH
11241: LD_INT 25
11243: PUSH
11244: LD_INT 2
11246: PUSH
11247: EMPTY
11248: LIST
11249: LIST
11250: PUSH
11251: LD_INT 25
11253: PUSH
11254: LD_INT 3
11256: PUSH
11257: EMPTY
11258: LIST
11259: LIST
11260: PUSH
11261: LD_INT 25
11263: PUSH
11264: LD_INT 4
11266: PUSH
11267: EMPTY
11268: LIST
11269: LIST
11270: PUSH
11271: LD_INT 25
11273: PUSH
11274: LD_INT 5
11276: PUSH
11277: EMPTY
11278: LIST
11279: LIST
11280: PUSH
11281: LD_INT 25
11283: PUSH
11284: LD_INT 8
11286: PUSH
11287: EMPTY
11288: LIST
11289: LIST
11290: PUSH
11291: LD_INT 25
11293: PUSH
11294: LD_INT 9
11296: PUSH
11297: EMPTY
11298: LIST
11299: LIST
11300: PUSH
11301: EMPTY
11302: LIST
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: LIST
11308: LIST
11309: LIST
11310: PUSH
11311: EMPTY
11312: LIST
11313: LIST
11314: PPUSH
11315: CALL_OW 69
11319: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11320: LD_VAR 0 2
11324: PPUSH
11325: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11329: LD_ADDR_VAR 0 3
11333: PUSH
11334: LD_EXP 14
11338: PUSH
11339: LD_EXP 15
11343: PUSH
11344: LD_EXP 16
11348: PUSH
11349: LD_EXP 17
11353: PUSH
11354: LD_EXP 18
11358: PUSH
11359: LD_EXP 19
11363: PUSH
11364: LD_EXP 20
11368: PUSH
11369: LD_EXP 21
11373: PUSH
11374: LD_EXP 22
11378: PUSH
11379: LD_EXP 23
11383: PUSH
11384: LD_EXP 24
11388: PUSH
11389: LD_EXP 25
11393: PUSH
11394: LD_EXP 26
11398: PUSH
11399: LD_EXP 27
11403: PUSH
11404: LD_EXP 28
11408: PUSH
11409: LD_EXP 29
11413: PUSH
11414: LD_EXP 30
11418: PUSH
11419: LD_EXP 31
11423: PUSH
11424: LD_EXP 32
11428: PUSH
11429: LD_EXP 33
11433: PUSH
11434: LD_EXP 35
11438: PUSH
11439: LD_EXP 36
11443: PUSH
11444: LD_EXP 37
11448: PUSH
11449: LD_EXP 38
11453: PUSH
11454: LD_EXP 39
11458: PUSH
11459: LD_EXP 40
11463: PUSH
11464: LD_EXP 41
11468: PUSH
11469: LD_EXP 42
11473: PUSH
11474: LD_EXP 43
11478: PUSH
11479: LD_EXP 44
11483: PUSH
11484: LD_EXP 45
11488: PUSH
11489: LD_EXP 46
11493: PUSH
11494: LD_EXP 47
11498: PUSH
11499: EMPTY
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: ST_TO_ADDR
// if tmp diff tmp2 then
11534: LD_VAR 0 2
11538: PUSH
11539: LD_VAR 0 3
11543: DIFF
11544: IFFALSE 11564
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11546: LD_VAR 0 2
11550: PUSH
11551: LD_VAR 0 3
11555: DIFF
11556: PPUSH
11557: LD_STRING 13a_others
11559: PPUSH
11560: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11564: LD_EXP 14
11568: PPUSH
11569: LD_STRING 13a_JMM
11571: PPUSH
11572: CALL_OW 38
// if Titov then
11576: LD_EXP 33
11580: IFFALSE 11594
// SaveCharacters ( Titov , 13a_Titov ) ;
11582: LD_EXP 33
11586: PPUSH
11587: LD_STRING 13a_Titov
11589: PPUSH
11590: CALL_OW 38
// if Dolgov then
11594: LD_EXP 35
11598: IFFALSE 11612
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11600: LD_EXP 35
11604: PPUSH
11605: LD_STRING 13a_Dolgov
11607: PPUSH
11608: CALL_OW 38
// if Petrosyan then
11612: LD_EXP 36
11616: IFFALSE 11630
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11618: LD_EXP 36
11622: PPUSH
11623: LD_STRING 13a_Petrosyan
11625: PPUSH
11626: CALL_OW 38
// if Scholtze then
11630: LD_EXP 37
11634: IFFALSE 11648
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11636: LD_EXP 37
11640: PPUSH
11641: LD_STRING 13a_Scholtze
11643: PPUSH
11644: CALL_OW 38
// if Oblukov then
11648: LD_EXP 38
11652: IFFALSE 11666
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11654: LD_EXP 38
11658: PPUSH
11659: LD_STRING 13a_Oblukov
11661: PPUSH
11662: CALL_OW 38
// if Kapitsova then
11666: LD_EXP 39
11670: IFFALSE 11684
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11672: LD_EXP 39
11676: PPUSH
11677: LD_STRING 13a_Kapitsova
11679: PPUSH
11680: CALL_OW 38
// if Lipshchin then
11684: LD_EXP 40
11688: IFFALSE 11702
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11690: LD_EXP 40
11694: PPUSH
11695: LD_STRING 13a_Lipshchin
11697: PPUSH
11698: CALL_OW 38
// if Petrovova then
11702: LD_EXP 41
11706: IFFALSE 11720
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11708: LD_EXP 41
11712: PPUSH
11713: LD_STRING 13a_Petrovova
11715: PPUSH
11716: CALL_OW 38
// if Kovalyuk then
11720: LD_EXP 42
11724: IFFALSE 11738
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11726: LD_EXP 42
11730: PPUSH
11731: LD_STRING 13a_Kovalyuk
11733: PPUSH
11734: CALL_OW 38
// if Kuzmov then
11738: LD_EXP 43
11742: IFFALSE 11756
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11744: LD_EXP 43
11748: PPUSH
11749: LD_STRING 13a_Kuzmov
11751: PPUSH
11752: CALL_OW 38
// if Karamazov then
11756: LD_EXP 44
11760: IFFALSE 11774
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11762: LD_EXP 44
11766: PPUSH
11767: LD_STRING 13a_Karamazov
11769: PPUSH
11770: CALL_OW 38
// if Burlak then
11774: LD_EXP 45
11778: IFFALSE 11792
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11780: LD_EXP 45
11784: PPUSH
11785: LD_STRING 13a_Burlak
11787: PPUSH
11788: CALL_OW 38
// if Belkov then
11792: LD_EXP 46
11796: IFFALSE 11810
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11798: LD_EXP 46
11802: PPUSH
11803: LD_STRING 13a_Belkov
11805: PPUSH
11806: CALL_OW 38
// if Gnyevko then
11810: LD_EXP 47
11814: IFFALSE 11828
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11816: LD_EXP 47
11820: PPUSH
11821: LD_STRING 13a_Gnyevko
11823: PPUSH
11824: CALL_OW 38
// if Lisa then
11828: LD_EXP 16
11832: IFFALSE 11846
// SaveCharacters ( Lisa , 13a_Lisa ) ;
11834: LD_EXP 16
11838: PPUSH
11839: LD_STRING 13a_Lisa
11841: PPUSH
11842: CALL_OW 38
// if Donaldson then
11846: LD_EXP 17
11850: IFFALSE 11864
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
11852: LD_EXP 17
11856: PPUSH
11857: LD_STRING 13a_Donaldson
11859: PPUSH
11860: CALL_OW 38
// if Bobby then
11864: LD_EXP 18
11868: IFFALSE 11882
// SaveCharacters ( Bobby , 13a_Bobby ) ;
11870: LD_EXP 18
11874: PPUSH
11875: LD_STRING 13a_Bobby
11877: PPUSH
11878: CALL_OW 38
// if Cyrus then
11882: LD_EXP 19
11886: IFFALSE 11900
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
11888: LD_EXP 19
11892: PPUSH
11893: LD_STRING 13a_Cyrus
11895: PPUSH
11896: CALL_OW 38
// if Denis then
11900: LD_EXP 20
11904: IFFALSE 11918
// SaveCharacters ( Denis , 13a_Denis ) ;
11906: LD_EXP 20
11910: PPUSH
11911: LD_STRING 13a_Denis
11913: PPUSH
11914: CALL_OW 38
// if Brown then
11918: LD_EXP 21
11922: IFFALSE 11936
// SaveCharacters ( Brown , 13a_Brown ) ;
11924: LD_EXP 21
11928: PPUSH
11929: LD_STRING 13a_Brown
11931: PPUSH
11932: CALL_OW 38
// if Gladstone then
11936: LD_EXP 22
11940: IFFALSE 11954
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
11942: LD_EXP 22
11946: PPUSH
11947: LD_STRING 13a_Gladstone
11949: PPUSH
11950: CALL_OW 38
// if Houten then
11954: LD_EXP 23
11958: IFFALSE 11972
// SaveCharacters ( Houten , 13a_Houten ) ;
11960: LD_EXP 23
11964: PPUSH
11965: LD_STRING 13a_Houten
11967: PPUSH
11968: CALL_OW 38
// if Cornel then
11972: LD_EXP 24
11976: IFFALSE 11990
// SaveCharacters ( Cornel , 13a_Cornel ) ;
11978: LD_EXP 24
11982: PPUSH
11983: LD_STRING 13a_Cornel
11985: PPUSH
11986: CALL_OW 38
// if Gary then
11990: LD_EXP 25
11994: IFFALSE 12008
// SaveCharacters ( Gary , 13a_Gary ) ;
11996: LD_EXP 25
12000: PPUSH
12001: LD_STRING 13a_Gary
12003: PPUSH
12004: CALL_OW 38
// if Frank then
12008: LD_EXP 26
12012: IFFALSE 12026
// SaveCharacters ( Frank , 13a_Frank ) ;
12014: LD_EXP 26
12018: PPUSH
12019: LD_STRING 13a_Frank
12021: PPUSH
12022: CALL_OW 38
// if Kikuchi then
12026: LD_EXP 27
12030: IFFALSE 12044
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12032: LD_EXP 27
12036: PPUSH
12037: LD_STRING 13a_Kikuchi
12039: PPUSH
12040: CALL_OW 38
// if Simms then
12044: LD_EXP 28
12048: IFFALSE 12062
// SaveCharacters ( Simms , 13a_Simms ) ;
12050: LD_EXP 28
12054: PPUSH
12055: LD_STRING 13a_Simms
12057: PPUSH
12058: CALL_OW 38
// if Joan then
12062: LD_EXP 29
12066: IFFALSE 12080
// SaveCharacters ( Joan , 13a_Joan ) ;
12068: LD_EXP 29
12072: PPUSH
12073: LD_STRING 13a_Joan
12075: PPUSH
12076: CALL_OW 38
// if DeltaDoctor then
12080: LD_EXP 30
12084: IFFALSE 12098
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12086: LD_EXP 30
12090: PPUSH
12091: LD_STRING 13a_DeltaDoctor
12093: PPUSH
12094: CALL_OW 38
// if Gossudarov then
12098: LD_EXP 31
12102: IFFALSE 12116
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12104: LD_EXP 31
12108: PPUSH
12109: LD_STRING 13a_Gossudarov
12111: PPUSH
12112: CALL_OW 38
// if Kirilenkova then
12116: LD_EXP 32
12120: IFFALSE 12134
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12122: LD_EXP 32
12126: PPUSH
12127: LD_STRING 13a_Kirilenkova
12129: PPUSH
12130: CALL_OW 38
// if Masha then
12134: LD_EXP 48
12138: IFFALSE 12193
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12140: LD_EXP 48
12144: PPUSH
12145: CALL_OW 265
12149: PUSH
12150: LD_EXP 48
12154: PPUSH
12155: CALL_OW 262
12159: PUSH
12160: LD_EXP 48
12164: PPUSH
12165: CALL_OW 263
12169: PUSH
12170: LD_EXP 48
12174: PPUSH
12175: CALL_OW 264
12179: PUSH
12180: EMPTY
12181: LIST
12182: LIST
12183: LIST
12184: LIST
12185: PPUSH
12186: LD_STRING 13a_Masha
12188: PPUSH
12189: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12193: LD_ADDR_VAR 0 2
12197: PUSH
12198: LD_INT 21
12200: PUSH
12201: LD_INT 3
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PPUSH
12208: CALL_OW 69
12212: ST_TO_ADDR
// tmp2 := [ ] ;
12213: LD_ADDR_VAR 0 3
12217: PUSH
12218: EMPTY
12219: ST_TO_ADDR
// if tmp then
12220: LD_VAR 0 2
12224: IFFALSE 12375
// for i in tmp do
12226: LD_ADDR_VAR 0 1
12230: PUSH
12231: LD_VAR 0 2
12235: PUSH
12236: FOR_IN
12237: IFFALSE 12373
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12239: LD_ADDR_VAR 0 3
12243: PUSH
12244: LD_VAR 0 3
12248: PUSH
12249: LD_VAR 0 1
12253: PPUSH
12254: CALL_OW 255
12258: PUSH
12259: LD_VAR 0 1
12263: PPUSH
12264: CALL_OW 248
12268: PUSH
12269: LD_VAR 0 1
12273: PPUSH
12274: CALL_OW 266
12278: PUSH
12279: LD_VAR 0 1
12283: PPUSH
12284: CALL_OW 250
12288: PUSH
12289: LD_VAR 0 1
12293: PPUSH
12294: CALL_OW 251
12298: PUSH
12299: LD_VAR 0 1
12303: PPUSH
12304: CALL_OW 254
12308: PUSH
12309: LD_VAR 0 1
12313: PPUSH
12314: CALL_OW 267
12318: PUSH
12319: LD_VAR 0 1
12323: PPUSH
12324: LD_INT 1
12326: PPUSH
12327: CALL_OW 268
12331: PUSH
12332: LD_VAR 0 1
12336: PPUSH
12337: LD_INT 2
12339: PPUSH
12340: CALL_OW 268
12344: PUSH
12345: LD_VAR 0 1
12349: PPUSH
12350: CALL_OW 269
12354: PUSH
12355: EMPTY
12356: LIST
12357: LIST
12358: LIST
12359: LIST
12360: LIST
12361: LIST
12362: LIST
12363: LIST
12364: LIST
12365: LIST
12366: PUSH
12367: EMPTY
12368: LIST
12369: ADD
12370: ST_TO_ADDR
12371: GO 12236
12373: POP
12374: POP
// if tmp2 then
12375: LD_VAR 0 3
12379: IFFALSE 12393
// SaveVariable ( tmp2 , 13a_buildings ) ;
12381: LD_VAR 0 3
12385: PPUSH
12386: LD_STRING 13a_buildings
12388: PPUSH
12389: CALL_OW 39
// YouWin ;
12393: CALL_OW 103
// end ;
12397: PPOPN 3
12399: END
// export function SciRu ; var tmp , t ; begin
12400: LD_INT 0
12402: PPUSH
12403: PPUSH
12404: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12405: LD_ADDR_VAR 0 3
12409: PUSH
12410: LD_EXP 31
12414: PUSH
12415: LD_EXP 45
12419: PUSH
12420: LD_EXP 33
12424: PUSH
12425: LD_EXP 46
12429: PUSH
12430: LD_EXP 47
12434: PUSH
12435: LD_EXP 36
12439: PUSH
12440: LD_EXP 37
12444: PUSH
12445: LD_EXP 35
12449: PUSH
12450: EMPTY
12451: LIST
12452: LIST
12453: LIST
12454: LIST
12455: LIST
12456: LIST
12457: LIST
12458: LIST
12459: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12460: LD_ADDR_VAR 0 2
12464: PUSH
12465: LD_INT 22
12467: PUSH
12468: LD_INT 7
12470: PUSH
12471: EMPTY
12472: LIST
12473: LIST
12474: PUSH
12475: LD_INT 23
12477: PUSH
12478: LD_INT 3
12480: PUSH
12481: EMPTY
12482: LIST
12483: LIST
12484: PUSH
12485: LD_INT 25
12487: PUSH
12488: LD_INT 4
12490: PUSH
12491: EMPTY
12492: LIST
12493: LIST
12494: PUSH
12495: LD_INT 26
12497: PUSH
12498: LD_INT 1
12500: PUSH
12501: EMPTY
12502: LIST
12503: LIST
12504: PUSH
12505: EMPTY
12506: LIST
12507: LIST
12508: LIST
12509: LIST
12510: PPUSH
12511: CALL_OW 69
12515: PUSH
12516: LD_VAR 0 3
12520: DIFF
12521: ST_TO_ADDR
// if tmp then
12522: LD_VAR 0 2
12526: IFFALSE 12542
// result := tmp [ 1 ] ;
12528: LD_ADDR_VAR 0 1
12532: PUSH
12533: LD_VAR 0 2
12537: PUSH
12538: LD_INT 1
12540: ARRAY
12541: ST_TO_ADDR
// end ;
12542: LD_VAR 0 1
12546: RET
// export function SolRu ; var tmp , t ; begin
12547: LD_INT 0
12549: PPUSH
12550: PPUSH
12551: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12552: LD_ADDR_VAR 0 3
12556: PUSH
12557: LD_EXP 31
12561: PUSH
12562: LD_EXP 45
12566: PUSH
12567: LD_EXP 33
12571: PUSH
12572: LD_EXP 46
12576: PUSH
12577: LD_EXP 47
12581: PUSH
12582: LD_EXP 36
12586: PUSH
12587: LD_EXP 37
12591: PUSH
12592: LD_EXP 35
12596: PUSH
12597: EMPTY
12598: LIST
12599: LIST
12600: LIST
12601: LIST
12602: LIST
12603: LIST
12604: LIST
12605: LIST
12606: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12607: LD_ADDR_VAR 0 2
12611: PUSH
12612: LD_INT 22
12614: PUSH
12615: LD_INT 7
12617: PUSH
12618: EMPTY
12619: LIST
12620: LIST
12621: PUSH
12622: LD_INT 23
12624: PUSH
12625: LD_INT 3
12627: PUSH
12628: EMPTY
12629: LIST
12630: LIST
12631: PUSH
12632: LD_INT 25
12634: PUSH
12635: LD_INT 1
12637: PUSH
12638: EMPTY
12639: LIST
12640: LIST
12641: PUSH
12642: LD_INT 26
12644: PUSH
12645: LD_INT 1
12647: PUSH
12648: EMPTY
12649: LIST
12650: LIST
12651: PUSH
12652: EMPTY
12653: LIST
12654: LIST
12655: LIST
12656: LIST
12657: PPUSH
12658: CALL_OW 69
12662: PUSH
12663: LD_VAR 0 3
12667: DIFF
12668: ST_TO_ADDR
// if tmp then
12669: LD_VAR 0 2
12673: IFFALSE 12689
// result := tmp [ 1 ] ;
12675: LD_ADDR_VAR 0 1
12679: PUSH
12680: LD_VAR 0 2
12684: PUSH
12685: LD_INT 1
12687: ARRAY
12688: ST_TO_ADDR
// end ; end_of_file
12689: LD_VAR 0 1
12693: RET
// export function CustomEvent ( event ) ; begin
12694: LD_INT 0
12696: PPUSH
// end ;
12697: LD_VAR 0 2
12701: RET
// on UnitDestroyed ( un ) do var i , side ;
12702: LD_INT 0
12704: PPUSH
12705: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12706: LD_VAR 0 1
12710: PUSH
12711: LD_INT 22
12713: PUSH
12714: LD_INT 7
12716: PUSH
12717: EMPTY
12718: LIST
12719: LIST
12720: PUSH
12721: LD_INT 2
12723: PUSH
12724: LD_INT 25
12726: PUSH
12727: LD_INT 1
12729: PUSH
12730: EMPTY
12731: LIST
12732: LIST
12733: PUSH
12734: LD_INT 25
12736: PUSH
12737: LD_INT 2
12739: PUSH
12740: EMPTY
12741: LIST
12742: LIST
12743: PUSH
12744: LD_INT 25
12746: PUSH
12747: LD_INT 3
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PUSH
12754: LD_INT 25
12756: PUSH
12757: LD_INT 4
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: LD_INT 25
12766: PUSH
12767: LD_INT 5
12769: PUSH
12770: EMPTY
12771: LIST
12772: LIST
12773: PUSH
12774: LD_INT 25
12776: PUSH
12777: LD_INT 8
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: PUSH
12784: LD_INT 25
12786: PUSH
12787: LD_INT 9
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: EMPTY
12795: LIST
12796: LIST
12797: LIST
12798: LIST
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: PUSH
12804: EMPTY
12805: LIST
12806: LIST
12807: PPUSH
12808: CALL_OW 69
12812: IN
12813: IFFALSE 12829
// loss_counter := loss_counter + 1 ;
12815: LD_ADDR_EXP 13
12819: PUSH
12820: LD_EXP 13
12824: PUSH
12825: LD_INT 1
12827: PLUS
12828: ST_TO_ADDR
// if un = Abdul then
12829: LD_VAR 0 1
12833: PUSH
12834: LD_EXP 54
12838: EQUAL
12839: IFFALSE 12849
// abdul_escaped := false ;
12841: LD_ADDR_EXP 12
12845: PUSH
12846: LD_INT 0
12848: ST_TO_ADDR
// if un in ru_attackers then
12849: LD_VAR 0 1
12853: PUSH
12854: LD_EXP 51
12858: IN
12859: IFFALSE 12877
// ru_attackers := ru_attackers diff un ;
12861: LD_ADDR_EXP 51
12865: PUSH
12866: LD_EXP 51
12870: PUSH
12871: LD_VAR 0 1
12875: DIFF
12876: ST_TO_ADDR
// if un in ar_attackers then
12877: LD_VAR 0 1
12881: PUSH
12882: LD_EXP 10
12886: IN
12887: IFFALSE 12905
// ar_attackers := ar_attackers diff un ;
12889: LD_ADDR_EXP 10
12893: PUSH
12894: LD_EXP 10
12898: PUSH
12899: LD_VAR 0 1
12903: DIFF
12904: ST_TO_ADDR
// if un = JMM then
12905: LD_VAR 0 1
12909: PUSH
12910: LD_EXP 14
12914: EQUAL
12915: IFFALSE 12926
// begin YouLost ( JMM ) ;
12917: LD_STRING JMM
12919: PPUSH
12920: CALL_OW 104
// exit ;
12924: GO 13015
// end ; if un = Burlak then
12926: LD_VAR 0 1
12930: PUSH
12931: LD_EXP 45
12935: EQUAL
12936: IFFALSE 12947
// begin YouLost ( Burlak ) ;
12938: LD_STRING Burlak
12940: PPUSH
12941: CALL_OW 104
// exit ;
12945: GO 13015
// end ; if un = freedom then
12947: LD_VAR 0 1
12951: PUSH
12952: LD_EXP 3
12956: EQUAL
12957: IFFALSE 12968
// begin YouLost ( Destroyed ) ;
12959: LD_STRING Destroyed
12961: PPUSH
12962: CALL_OW 104
// exit ;
12966: GO 13015
// end ; if un = Masha then
12968: LD_VAR 0 1
12972: PUSH
12973: LD_EXP 48
12977: EQUAL
12978: IFFALSE 12987
// ChangeMissionObjectives ( M4b ) ;
12980: LD_STRING M4b
12982: PPUSH
12983: CALL_OW 337
// if un = Mastodont then
12987: LD_VAR 0 1
12991: PUSH
12992: LD_EXP 55
12996: EQUAL
12997: IFFALSE 13006
// ChangeMissionObjectives ( M4a ) ;
12999: LD_STRING M4a
13001: PPUSH
13002: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13006: LD_VAR 0 1
13010: PPUSH
13011: CALL 83032 0 1
// end ;
13015: PPOPN 3
13017: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13018: LD_VAR 0 1
13022: PPUSH
13023: LD_VAR 0 2
13027: PPUSH
13028: CALL 85087 0 2
// end ;
13032: PPOPN 2
13034: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13035: LD_VAR 0 1
13039: PPUSH
13040: CALL 84155 0 1
// end ;
13044: PPOPN 1
13046: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13047: LD_VAR 0 1
13051: PUSH
13052: LD_INT 22
13054: PUSH
13055: LD_INT 7
13057: PUSH
13058: EMPTY
13059: LIST
13060: LIST
13061: PUSH
13062: LD_INT 30
13064: PUSH
13065: LD_INT 0
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: PPUSH
13076: CALL_OW 69
13080: IN
13081: IFFALSE 13120
// begin SetBName ( building , freedom ) ;
13083: LD_VAR 0 1
13087: PPUSH
13088: LD_STRING freedom
13090: PPUSH
13091: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13095: LD_INT 0
13097: PPUSH
13098: LD_INT 7
13100: PPUSH
13101: LD_INT 0
13103: PPUSH
13104: CALL_OW 324
// freedom := building ;
13108: LD_ADDR_EXP 3
13112: PUSH
13113: LD_VAR 0 1
13117: ST_TO_ADDR
// exit ;
13118: GO 13186
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13120: LD_VAR 0 1
13124: PUSH
13125: LD_INT 22
13127: PUSH
13128: LD_INT 7
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: PUSH
13135: LD_INT 23
13137: PUSH
13138: LD_INT 3
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: PUSH
13145: LD_INT 30
13147: PUSH
13148: LD_INT 6
13150: PUSH
13151: EMPTY
13152: LIST
13153: LIST
13154: PUSH
13155: EMPTY
13156: LIST
13157: LIST
13158: LIST
13159: PPUSH
13160: CALL_OW 69
13164: IN
13165: IFFALSE 13177
// begin ru_lab_builded := true ;
13167: LD_ADDR_EXP 5
13171: PUSH
13172: LD_INT 1
13174: ST_TO_ADDR
// exit ;
13175: GO 13186
// end ; MCE_BuildingComplete ( building ) ;
13177: LD_VAR 0 1
13181: PPUSH
13182: CALL 84396 0 1
// end ;
13186: PPOPN 1
13188: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13189: LD_VAR 0 1
13193: PPUSH
13194: LD_VAR 0 2
13198: PPUSH
13199: CALL 82728 0 2
// end ;
13203: PPOPN 2
13205: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13206: LD_VAR 0 1
13210: PPUSH
13211: LD_VAR 0 2
13215: PPUSH
13216: LD_VAR 0 3
13220: PPUSH
13221: LD_VAR 0 4
13225: PPUSH
13226: LD_VAR 0 5
13230: PPUSH
13231: CALL 82348 0 5
// end ;
13235: PPOPN 5
13237: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13238: LD_VAR 0 1
13242: PPUSH
13243: LD_VAR 0 2
13247: PPUSH
13248: CALL 81944 0 2
// end ;
13252: PPOPN 2
13254: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13255: LD_VAR 0 1
13259: PPUSH
13260: LD_VAR 0 2
13264: PPUSH
13265: LD_VAR 0 3
13269: PPUSH
13270: LD_VAR 0 4
13274: PPUSH
13275: CALL 81782 0 4
// end ;
13279: PPOPN 4
13281: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13282: LD_VAR 0 1
13286: PPUSH
13287: LD_VAR 0 2
13291: PPUSH
13292: LD_VAR 0 3
13296: PPUSH
13297: CALL 81557 0 3
// end ;
13301: PPOPN 3
13303: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13304: LD_VAR 0 1
13308: PPUSH
13309: LD_VAR 0 2
13313: PPUSH
13314: CALL 81442 0 2
// end ;
13318: PPOPN 2
13320: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13321: LD_VAR 0 1
13325: PPUSH
13326: LD_VAR 0 2
13330: PPUSH
13331: CALL 85348 0 2
// end ;
13335: PPOPN 2
13337: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13338: LD_VAR 0 1
13342: PPUSH
13343: LD_VAR 0 2
13347: PPUSH
13348: LD_VAR 0 3
13352: PPUSH
13353: LD_VAR 0 4
13357: PPUSH
13358: CALL 85564 0 4
// end ;
13362: PPOPN 4
13364: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13365: LD_VAR 0 1
13369: PPUSH
13370: LD_VAR 0 2
13374: PPUSH
13375: CALL 81251 0 2
// end ; end_of_file
13379: PPOPN 2
13381: END
// every 0 0$30 do var cr , time ;
13382: GO 13384
13384: DISABLE
13385: LD_INT 0
13387: PPUSH
13388: PPUSH
// begin time := 0 0$30 ;
13389: LD_ADDR_VAR 0 2
13393: PUSH
13394: LD_INT 1050
13396: ST_TO_ADDR
// while game do
13397: LD_EXP 2
13401: IFFALSE 13500
// begin wait ( time ) ;
13403: LD_VAR 0 2
13407: PPUSH
13408: CALL_OW 67
// if tick > 2 2$00 then
13412: LD_OWVAR 1
13416: PUSH
13417: LD_INT 4200
13419: GREATER
13420: IFFALSE 13453
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13422: LD_ADDR_VAR 0 2
13426: PUSH
13427: LD_VAR 0 2
13431: PUSH
13432: LD_INT 280
13434: PUSH
13435: LD_INT 420
13437: PUSH
13438: LD_INT 630
13440: PUSH
13441: EMPTY
13442: LIST
13443: LIST
13444: LIST
13445: PUSH
13446: LD_OWVAR 67
13450: ARRAY
13451: PLUS
13452: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13453: LD_INT 1
13455: PPUSH
13456: LD_INT 5
13458: PPUSH
13459: CALL_OW 12
13463: PPUSH
13464: LD_INT 70
13466: PPUSH
13467: LD_INT 49
13469: PPUSH
13470: LD_INT 25
13472: PPUSH
13473: LD_INT 1
13475: PPUSH
13476: CALL_OW 56
// if time > 5 5$00 then
13480: LD_VAR 0 2
13484: PUSH
13485: LD_INT 10500
13487: GREATER
13488: IFFALSE 13498
// time := 0 0$30 ;
13490: LD_ADDR_VAR 0 2
13494: PUSH
13495: LD_INT 1050
13497: ST_TO_ADDR
// end ;
13498: GO 13397
// end ;
13500: PPOPN 2
13502: END
// every 0 0$30 do var cr , time ;
13503: GO 13505
13505: DISABLE
13506: LD_INT 0
13508: PPUSH
13509: PPUSH
// begin time := 0 0$20 ;
13510: LD_ADDR_VAR 0 2
13514: PUSH
13515: LD_INT 700
13517: ST_TO_ADDR
// while game do
13518: LD_EXP 2
13522: IFFALSE 13611
// begin wait ( time ) ;
13524: LD_VAR 0 2
13528: PPUSH
13529: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13533: LD_ADDR_VAR 0 2
13537: PUSH
13538: LD_VAR 0 2
13542: PUSH
13543: LD_INT 490
13545: PUSH
13546: LD_INT 525
13548: PUSH
13549: LD_INT 560
13551: PUSH
13552: EMPTY
13553: LIST
13554: LIST
13555: LIST
13556: PUSH
13557: LD_OWVAR 67
13561: ARRAY
13562: PLUS
13563: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13564: LD_INT 3
13566: PPUSH
13567: LD_INT 5
13569: PPUSH
13570: CALL_OW 12
13574: PPUSH
13575: LD_INT 26
13577: PPUSH
13578: LD_INT 9
13580: PPUSH
13581: LD_INT 30
13583: PPUSH
13584: LD_INT 1
13586: PPUSH
13587: CALL_OW 56
// if time > 3 3$00 then
13591: LD_VAR 0 2
13595: PUSH
13596: LD_INT 6300
13598: GREATER
13599: IFFALSE 13609
// time := 0 0$20 ;
13601: LD_ADDR_VAR 0 2
13605: PUSH
13606: LD_INT 700
13608: ST_TO_ADDR
// end ;
13609: GO 13518
// end ;
13611: PPOPN 2
13613: END
// every 0 0$30 do var cr , time ;
13614: GO 13616
13616: DISABLE
13617: LD_INT 0
13619: PPUSH
13620: PPUSH
// begin time := 0 0$20 ;
13621: LD_ADDR_VAR 0 2
13625: PUSH
13626: LD_INT 700
13628: ST_TO_ADDR
// while game do
13629: LD_EXP 2
13633: IFFALSE 13758
// begin wait ( time ) ;
13635: LD_VAR 0 2
13639: PPUSH
13640: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13644: LD_ADDR_VAR 0 2
13648: PUSH
13649: LD_VAR 0 2
13653: PUSH
13654: LD_INT 175
13656: PUSH
13657: LD_INT 210
13659: PUSH
13660: LD_INT 280
13662: PUSH
13663: EMPTY
13664: LIST
13665: LIST
13666: LIST
13667: PUSH
13668: LD_OWVAR 67
13672: ARRAY
13673: PLUS
13674: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13675: LD_INT 1
13677: PPUSH
13678: LD_INT 5
13680: PPUSH
13681: CALL_OW 12
13685: PPUSH
13686: LD_INT 179
13688: PPUSH
13689: LD_INT 101
13691: PPUSH
13692: LD_INT 20
13694: PPUSH
13695: LD_INT 1
13697: PPUSH
13698: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13702: LD_INT 350
13704: PPUSH
13705: LD_INT 525
13707: PPUSH
13708: CALL_OW 12
13712: PPUSH
13713: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13717: LD_INT 1
13719: PPUSH
13720: LD_INT 5
13722: PPUSH
13723: CALL_OW 12
13727: PPUSH
13728: LD_INT 9
13730: PPUSH
13731: LD_INT 1
13733: PPUSH
13734: CALL_OW 55
// if time > 4 4$00 then
13738: LD_VAR 0 2
13742: PUSH
13743: LD_INT 8400
13745: GREATER
13746: IFFALSE 13756
// time := 0 0$30 ;
13748: LD_ADDR_VAR 0 2
13752: PUSH
13753: LD_INT 1050
13755: ST_TO_ADDR
// end ;
13756: GO 13629
// end ;
13758: PPOPN 2
13760: END
// every 0 0$30 do var cr , time ;
13761: GO 13763
13763: DISABLE
13764: LD_INT 0
13766: PPUSH
13767: PPUSH
// begin time := 0 0$10 ;
13768: LD_ADDR_VAR 0 2
13772: PUSH
13773: LD_INT 350
13775: ST_TO_ADDR
// while game do
13776: LD_EXP 2
13780: IFFALSE 13914
// begin wait ( time ) ;
13782: LD_VAR 0 2
13786: PPUSH
13787: CALL_OW 67
// time := time + 0 0$10 ;
13791: LD_ADDR_VAR 0 2
13795: PUSH
13796: LD_VAR 0 2
13800: PUSH
13801: LD_INT 350
13803: PLUS
13804: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
13805: LD_INT 1
13807: PPUSH
13808: LD_INT 5
13810: PPUSH
13811: CALL_OW 12
13815: PPUSH
13816: LD_INT 11
13818: PPUSH
13819: LD_INT 1
13821: PPUSH
13822: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
13826: LD_ADDR_VAR 0 1
13830: PUSH
13831: LD_INT 1
13833: PPUSH
13834: LD_INT 3
13836: PPUSH
13837: CALL_OW 12
13841: ST_TO_ADDR
// if cr = 1 then
13842: LD_VAR 0 1
13846: PUSH
13847: LD_INT 1
13849: EQUAL
13850: IFFALSE 13894
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
13852: LD_INT 700
13854: PPUSH
13855: LD_INT 1575
13857: PPUSH
13858: CALL_OW 12
13862: PPUSH
13863: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
13867: LD_INT 1
13869: PPUSH
13870: LD_INT 5
13872: PPUSH
13873: CALL_OW 12
13877: PPUSH
13878: LD_INT 34
13880: PPUSH
13881: LD_INT 50
13883: PPUSH
13884: LD_INT 7
13886: PPUSH
13887: LD_INT 1
13889: PPUSH
13890: CALL_OW 56
// end ; if time > 8 8$00 then
13894: LD_VAR 0 2
13898: PUSH
13899: LD_INT 16800
13901: GREATER
13902: IFFALSE 13912
// time := 0 0$40 ;
13904: LD_ADDR_VAR 0 2
13908: PUSH
13909: LD_INT 1400
13911: ST_TO_ADDR
// end ;
13912: GO 13776
// end ; end_of_file
13914: PPOPN 2
13916: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13917: LD_INT 0
13919: PPUSH
13920: PPUSH
// if exist_mode then
13921: LD_VAR 0 2
13925: IFFALSE 13950
// unit := CreateCharacter ( prefix & ident ) else
13927: LD_ADDR_VAR 0 5
13931: PUSH
13932: LD_VAR 0 3
13936: PUSH
13937: LD_VAR 0 1
13941: STR
13942: PPUSH
13943: CALL_OW 34
13947: ST_TO_ADDR
13948: GO 13965
// unit := NewCharacter ( ident ) ;
13950: LD_ADDR_VAR 0 5
13954: PUSH
13955: LD_VAR 0 1
13959: PPUSH
13960: CALL_OW 25
13964: ST_TO_ADDR
// result := unit ;
13965: LD_ADDR_VAR 0 4
13969: PUSH
13970: LD_VAR 0 5
13974: ST_TO_ADDR
// end ;
13975: LD_VAR 0 4
13979: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13980: LD_INT 0
13982: PPUSH
13983: PPUSH
// if not side or not nation then
13984: LD_VAR 0 1
13988: NOT
13989: PUSH
13990: LD_VAR 0 2
13994: NOT
13995: OR
13996: IFFALSE 14000
// exit ;
13998: GO 14636
// case nation of nation_american :
14000: LD_VAR 0 2
14004: PUSH
14005: LD_INT 1
14007: DOUBLE
14008: EQUAL
14009: IFTRUE 14013
14011: GO 14183
14013: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
14014: LD_ADDR_VAR 0 4
14018: PUSH
14019: LD_INT 35
14021: PUSH
14022: LD_INT 45
14024: PUSH
14025: LD_INT 46
14027: PUSH
14028: LD_INT 47
14030: PUSH
14031: LD_INT 1
14033: PUSH
14034: LD_INT 2
14036: PUSH
14037: LD_INT 6
14039: PUSH
14040: LD_INT 15
14042: PUSH
14043: LD_INT 16
14045: PUSH
14046: LD_INT 7
14048: PUSH
14049: LD_INT 12
14051: PUSH
14052: LD_INT 13
14054: PUSH
14055: LD_INT 10
14057: PUSH
14058: LD_INT 14
14060: PUSH
14061: LD_INT 20
14063: PUSH
14064: LD_INT 21
14066: PUSH
14067: LD_INT 22
14069: PUSH
14070: LD_INT 25
14072: PUSH
14073: LD_INT 32
14075: PUSH
14076: LD_INT 27
14078: PUSH
14079: LD_INT 36
14081: PUSH
14082: LD_INT 69
14084: PUSH
14085: LD_INT 39
14087: PUSH
14088: LD_INT 34
14090: PUSH
14091: LD_INT 40
14093: PUSH
14094: LD_INT 48
14096: PUSH
14097: LD_INT 49
14099: PUSH
14100: LD_INT 50
14102: PUSH
14103: LD_INT 51
14105: PUSH
14106: LD_INT 52
14108: PUSH
14109: LD_INT 53
14111: PUSH
14112: LD_INT 54
14114: PUSH
14115: LD_INT 55
14117: PUSH
14118: LD_INT 56
14120: PUSH
14121: LD_INT 57
14123: PUSH
14124: LD_INT 58
14126: PUSH
14127: LD_INT 59
14129: PUSH
14130: LD_INT 60
14132: PUSH
14133: LD_INT 61
14135: PUSH
14136: LD_INT 62
14138: PUSH
14139: EMPTY
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: LIST
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: LIST
14153: LIST
14154: LIST
14155: LIST
14156: LIST
14157: LIST
14158: LIST
14159: LIST
14160: LIST
14161: LIST
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: LIST
14167: LIST
14168: LIST
14169: LIST
14170: LIST
14171: LIST
14172: LIST
14173: LIST
14174: LIST
14175: LIST
14176: LIST
14177: LIST
14178: LIST
14179: LIST
14180: ST_TO_ADDR
14181: GO 14560
14183: LD_INT 2
14185: DOUBLE
14186: EQUAL
14187: IFTRUE 14191
14189: GO 14369
14191: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
14192: LD_ADDR_VAR 0 4
14196: PUSH
14197: LD_INT 35
14199: PUSH
14200: LD_INT 45
14202: PUSH
14203: LD_INT 46
14205: PUSH
14206: LD_INT 47
14208: PUSH
14209: LD_INT 70
14211: PUSH
14212: LD_INT 1
14214: PUSH
14215: LD_INT 11
14217: PUSH
14218: LD_INT 3
14220: PUSH
14221: LD_INT 4
14223: PUSH
14224: LD_INT 5
14226: PUSH
14227: LD_INT 6
14229: PUSH
14230: LD_INT 15
14232: PUSH
14233: LD_INT 18
14235: PUSH
14236: LD_INT 7
14238: PUSH
14239: LD_INT 17
14241: PUSH
14242: LD_INT 8
14244: PUSH
14245: LD_INT 20
14247: PUSH
14248: LD_INT 21
14250: PUSH
14251: LD_INT 22
14253: PUSH
14254: LD_INT 72
14256: PUSH
14257: LD_INT 26
14259: PUSH
14260: LD_INT 69
14262: PUSH
14263: LD_INT 39
14265: PUSH
14266: LD_INT 40
14268: PUSH
14269: LD_INT 41
14271: PUSH
14272: LD_INT 42
14274: PUSH
14275: LD_INT 43
14277: PUSH
14278: LD_INT 48
14280: PUSH
14281: LD_INT 49
14283: PUSH
14284: LD_INT 50
14286: PUSH
14287: LD_INT 51
14289: PUSH
14290: LD_INT 52
14292: PUSH
14293: LD_INT 53
14295: PUSH
14296: LD_INT 54
14298: PUSH
14299: LD_INT 55
14301: PUSH
14302: LD_INT 56
14304: PUSH
14305: LD_INT 60
14307: PUSH
14308: LD_INT 61
14310: PUSH
14311: LD_INT 62
14313: PUSH
14314: LD_INT 66
14316: PUSH
14317: LD_INT 67
14319: PUSH
14320: LD_INT 68
14322: PUSH
14323: EMPTY
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: ST_TO_ADDR
14367: GO 14560
14369: LD_INT 3
14371: DOUBLE
14372: EQUAL
14373: IFTRUE 14377
14375: GO 14559
14377: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14378: LD_ADDR_VAR 0 4
14382: PUSH
14383: LD_INT 46
14385: PUSH
14386: LD_INT 47
14388: PUSH
14389: LD_INT 1
14391: PUSH
14392: LD_INT 2
14394: PUSH
14395: LD_INT 11
14397: PUSH
14398: LD_INT 9
14400: PUSH
14401: LD_INT 20
14403: PUSH
14404: LD_INT 19
14406: PUSH
14407: LD_INT 21
14409: PUSH
14410: LD_INT 24
14412: PUSH
14413: LD_INT 22
14415: PUSH
14416: LD_INT 25
14418: PUSH
14419: LD_INT 28
14421: PUSH
14422: LD_INT 29
14424: PUSH
14425: LD_INT 30
14427: PUSH
14428: LD_INT 31
14430: PUSH
14431: LD_INT 37
14433: PUSH
14434: LD_INT 38
14436: PUSH
14437: LD_INT 32
14439: PUSH
14440: LD_INT 27
14442: PUSH
14443: LD_INT 33
14445: PUSH
14446: LD_INT 69
14448: PUSH
14449: LD_INT 39
14451: PUSH
14452: LD_INT 34
14454: PUSH
14455: LD_INT 40
14457: PUSH
14458: LD_INT 71
14460: PUSH
14461: LD_INT 23
14463: PUSH
14464: LD_INT 44
14466: PUSH
14467: LD_INT 48
14469: PUSH
14470: LD_INT 49
14472: PUSH
14473: LD_INT 50
14475: PUSH
14476: LD_INT 51
14478: PUSH
14479: LD_INT 52
14481: PUSH
14482: LD_INT 53
14484: PUSH
14485: LD_INT 54
14487: PUSH
14488: LD_INT 55
14490: PUSH
14491: LD_INT 56
14493: PUSH
14494: LD_INT 57
14496: PUSH
14497: LD_INT 58
14499: PUSH
14500: LD_INT 59
14502: PUSH
14503: LD_INT 63
14505: PUSH
14506: LD_INT 64
14508: PUSH
14509: LD_INT 65
14511: PUSH
14512: EMPTY
14513: LIST
14514: LIST
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: LIST
14520: LIST
14521: LIST
14522: LIST
14523: LIST
14524: LIST
14525: LIST
14526: LIST
14527: LIST
14528: LIST
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: LIST
14534: LIST
14535: LIST
14536: LIST
14537: LIST
14538: LIST
14539: LIST
14540: LIST
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: ST_TO_ADDR
14557: GO 14560
14559: POP
// if state > - 1 and state < 3 then
14560: LD_VAR 0 3
14564: PUSH
14565: LD_INT 1
14567: NEG
14568: GREATER
14569: PUSH
14570: LD_VAR 0 3
14574: PUSH
14575: LD_INT 3
14577: LESS
14578: AND
14579: IFFALSE 14636
// for i in result do
14581: LD_ADDR_VAR 0 5
14585: PUSH
14586: LD_VAR 0 4
14590: PUSH
14591: FOR_IN
14592: IFFALSE 14634
// if GetTech ( i , side ) <> state then
14594: LD_VAR 0 5
14598: PPUSH
14599: LD_VAR 0 1
14603: PPUSH
14604: CALL_OW 321
14608: PUSH
14609: LD_VAR 0 3
14613: NONEQUAL
14614: IFFALSE 14632
// result := result diff i ;
14616: LD_ADDR_VAR 0 4
14620: PUSH
14621: LD_VAR 0 4
14625: PUSH
14626: LD_VAR 0 5
14630: DIFF
14631: ST_TO_ADDR
14632: GO 14591
14634: POP
14635: POP
// end ;
14636: LD_VAR 0 4
14640: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14641: LD_INT 0
14643: PPUSH
14644: PPUSH
14645: PPUSH
// result := true ;
14646: LD_ADDR_VAR 0 3
14650: PUSH
14651: LD_INT 1
14653: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14654: LD_ADDR_VAR 0 5
14658: PUSH
14659: LD_VAR 0 2
14663: PPUSH
14664: CALL_OW 480
14668: ST_TO_ADDR
// if not tmp then
14669: LD_VAR 0 5
14673: NOT
14674: IFFALSE 14678
// exit ;
14676: GO 14727
// for i in tmp do
14678: LD_ADDR_VAR 0 4
14682: PUSH
14683: LD_VAR 0 5
14687: PUSH
14688: FOR_IN
14689: IFFALSE 14725
// if GetTech ( i , side ) <> state_researched then
14691: LD_VAR 0 4
14695: PPUSH
14696: LD_VAR 0 1
14700: PPUSH
14701: CALL_OW 321
14705: PUSH
14706: LD_INT 2
14708: NONEQUAL
14709: IFFALSE 14723
// begin result := false ;
14711: LD_ADDR_VAR 0 3
14715: PUSH
14716: LD_INT 0
14718: ST_TO_ADDR
// exit ;
14719: POP
14720: POP
14721: GO 14727
// end ;
14723: GO 14688
14725: POP
14726: POP
// end ;
14727: LD_VAR 0 3
14731: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14732: LD_INT 0
14734: PPUSH
14735: PPUSH
14736: PPUSH
14737: PPUSH
14738: PPUSH
14739: PPUSH
14740: PPUSH
14741: PPUSH
14742: PPUSH
14743: PPUSH
14744: PPUSH
14745: PPUSH
14746: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14747: LD_VAR 0 1
14751: NOT
14752: PUSH
14753: LD_VAR 0 1
14757: PPUSH
14758: CALL_OW 257
14762: PUSH
14763: LD_INT 9
14765: NONEQUAL
14766: OR
14767: IFFALSE 14771
// exit ;
14769: GO 15344
// side := GetSide ( unit ) ;
14771: LD_ADDR_VAR 0 9
14775: PUSH
14776: LD_VAR 0 1
14780: PPUSH
14781: CALL_OW 255
14785: ST_TO_ADDR
// tech_space := tech_spacanom ;
14786: LD_ADDR_VAR 0 12
14790: PUSH
14791: LD_INT 29
14793: ST_TO_ADDR
// tech_time := tech_taurad ;
14794: LD_ADDR_VAR 0 13
14798: PUSH
14799: LD_INT 28
14801: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14802: LD_ADDR_VAR 0 11
14806: PUSH
14807: LD_VAR 0 1
14811: PPUSH
14812: CALL_OW 310
14816: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14817: LD_VAR 0 11
14821: PPUSH
14822: CALL_OW 247
14826: PUSH
14827: LD_INT 2
14829: EQUAL
14830: IFFALSE 14834
// exit ;
14832: GO 15344
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14834: LD_ADDR_VAR 0 8
14838: PUSH
14839: LD_INT 81
14841: PUSH
14842: LD_VAR 0 9
14846: PUSH
14847: EMPTY
14848: LIST
14849: LIST
14850: PUSH
14851: LD_INT 3
14853: PUSH
14854: LD_INT 21
14856: PUSH
14857: LD_INT 3
14859: PUSH
14860: EMPTY
14861: LIST
14862: LIST
14863: PUSH
14864: EMPTY
14865: LIST
14866: LIST
14867: PUSH
14868: EMPTY
14869: LIST
14870: LIST
14871: PPUSH
14872: CALL_OW 69
14876: ST_TO_ADDR
// if not tmp then
14877: LD_VAR 0 8
14881: NOT
14882: IFFALSE 14886
// exit ;
14884: GO 15344
// if in_unit then
14886: LD_VAR 0 11
14890: IFFALSE 14914
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14892: LD_ADDR_VAR 0 10
14896: PUSH
14897: LD_VAR 0 8
14901: PPUSH
14902: LD_VAR 0 11
14906: PPUSH
14907: CALL_OW 74
14911: ST_TO_ADDR
14912: GO 14934
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14914: LD_ADDR_VAR 0 10
14918: PUSH
14919: LD_VAR 0 8
14923: PPUSH
14924: LD_VAR 0 1
14928: PPUSH
14929: CALL_OW 74
14933: ST_TO_ADDR
// if not enemy then
14934: LD_VAR 0 10
14938: NOT
14939: IFFALSE 14943
// exit ;
14941: GO 15344
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14943: LD_VAR 0 11
14947: PUSH
14948: LD_VAR 0 11
14952: PPUSH
14953: LD_VAR 0 10
14957: PPUSH
14958: CALL_OW 296
14962: PUSH
14963: LD_INT 13
14965: GREATER
14966: AND
14967: PUSH
14968: LD_VAR 0 1
14972: PPUSH
14973: LD_VAR 0 10
14977: PPUSH
14978: CALL_OW 296
14982: PUSH
14983: LD_INT 12
14985: GREATER
14986: OR
14987: IFFALSE 14991
// exit ;
14989: GO 15344
// missile := [ 1 ] ;
14991: LD_ADDR_VAR 0 14
14995: PUSH
14996: LD_INT 1
14998: PUSH
14999: EMPTY
15000: LIST
15001: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15002: LD_VAR 0 9
15006: PPUSH
15007: LD_VAR 0 12
15011: PPUSH
15012: CALL_OW 325
15016: IFFALSE 15045
// missile := Insert ( missile , missile + 1 , 2 ) ;
15018: LD_ADDR_VAR 0 14
15022: PUSH
15023: LD_VAR 0 14
15027: PPUSH
15028: LD_VAR 0 14
15032: PUSH
15033: LD_INT 1
15035: PLUS
15036: PPUSH
15037: LD_INT 2
15039: PPUSH
15040: CALL_OW 2
15044: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15045: LD_VAR 0 9
15049: PPUSH
15050: LD_VAR 0 13
15054: PPUSH
15055: CALL_OW 325
15059: PUSH
15060: LD_VAR 0 10
15064: PPUSH
15065: CALL_OW 255
15069: PPUSH
15070: LD_VAR 0 13
15074: PPUSH
15075: CALL_OW 325
15079: NOT
15080: AND
15081: IFFALSE 15110
// missile := Insert ( missile , missile + 1 , 3 ) ;
15083: LD_ADDR_VAR 0 14
15087: PUSH
15088: LD_VAR 0 14
15092: PPUSH
15093: LD_VAR 0 14
15097: PUSH
15098: LD_INT 1
15100: PLUS
15101: PPUSH
15102: LD_INT 3
15104: PPUSH
15105: CALL_OW 2
15109: ST_TO_ADDR
// if missile < 2 then
15110: LD_VAR 0 14
15114: PUSH
15115: LD_INT 2
15117: LESS
15118: IFFALSE 15122
// exit ;
15120: GO 15344
// x := GetX ( enemy ) ;
15122: LD_ADDR_VAR 0 4
15126: PUSH
15127: LD_VAR 0 10
15131: PPUSH
15132: CALL_OW 250
15136: ST_TO_ADDR
// y := GetY ( enemy ) ;
15137: LD_ADDR_VAR 0 5
15141: PUSH
15142: LD_VAR 0 10
15146: PPUSH
15147: CALL_OW 251
15151: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15152: LD_ADDR_VAR 0 6
15156: PUSH
15157: LD_VAR 0 4
15161: PUSH
15162: LD_INT 1
15164: NEG
15165: PPUSH
15166: LD_INT 1
15168: PPUSH
15169: CALL_OW 12
15173: PLUS
15174: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15175: LD_ADDR_VAR 0 7
15179: PUSH
15180: LD_VAR 0 5
15184: PUSH
15185: LD_INT 1
15187: NEG
15188: PPUSH
15189: LD_INT 1
15191: PPUSH
15192: CALL_OW 12
15196: PLUS
15197: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15198: LD_VAR 0 6
15202: PPUSH
15203: LD_VAR 0 7
15207: PPUSH
15208: CALL_OW 488
15212: NOT
15213: IFFALSE 15235
// begin _x := x ;
15215: LD_ADDR_VAR 0 6
15219: PUSH
15220: LD_VAR 0 4
15224: ST_TO_ADDR
// _y := y ;
15225: LD_ADDR_VAR 0 7
15229: PUSH
15230: LD_VAR 0 5
15234: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15235: LD_ADDR_VAR 0 3
15239: PUSH
15240: LD_INT 1
15242: PPUSH
15243: LD_VAR 0 14
15247: PPUSH
15248: CALL_OW 12
15252: ST_TO_ADDR
// case i of 1 :
15253: LD_VAR 0 3
15257: PUSH
15258: LD_INT 1
15260: DOUBLE
15261: EQUAL
15262: IFTRUE 15266
15264: GO 15283
15266: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15267: LD_VAR 0 1
15271: PPUSH
15272: LD_VAR 0 10
15276: PPUSH
15277: CALL_OW 115
15281: GO 15344
15283: LD_INT 2
15285: DOUBLE
15286: EQUAL
15287: IFTRUE 15291
15289: GO 15313
15291: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15292: LD_VAR 0 1
15296: PPUSH
15297: LD_VAR 0 6
15301: PPUSH
15302: LD_VAR 0 7
15306: PPUSH
15307: CALL_OW 153
15311: GO 15344
15313: LD_INT 3
15315: DOUBLE
15316: EQUAL
15317: IFTRUE 15321
15319: GO 15343
15321: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15322: LD_VAR 0 1
15326: PPUSH
15327: LD_VAR 0 6
15331: PPUSH
15332: LD_VAR 0 7
15336: PPUSH
15337: CALL_OW 154
15341: GO 15344
15343: POP
// end ;
15344: LD_VAR 0 2
15348: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15349: LD_INT 0
15351: PPUSH
15352: PPUSH
15353: PPUSH
15354: PPUSH
15355: PPUSH
15356: PPUSH
// if not unit or not building then
15357: LD_VAR 0 1
15361: NOT
15362: PUSH
15363: LD_VAR 0 2
15367: NOT
15368: OR
15369: IFFALSE 15373
// exit ;
15371: GO 15531
// x := GetX ( building ) ;
15373: LD_ADDR_VAR 0 5
15377: PUSH
15378: LD_VAR 0 2
15382: PPUSH
15383: CALL_OW 250
15387: ST_TO_ADDR
// y := GetY ( building ) ;
15388: LD_ADDR_VAR 0 6
15392: PUSH
15393: LD_VAR 0 2
15397: PPUSH
15398: CALL_OW 251
15402: ST_TO_ADDR
// for i = 0 to 5 do
15403: LD_ADDR_VAR 0 4
15407: PUSH
15408: DOUBLE
15409: LD_INT 0
15411: DEC
15412: ST_TO_ADDR
15413: LD_INT 5
15415: PUSH
15416: FOR_TO
15417: IFFALSE 15529
// begin _x := ShiftX ( x , i , 3 ) ;
15419: LD_ADDR_VAR 0 7
15423: PUSH
15424: LD_VAR 0 5
15428: PPUSH
15429: LD_VAR 0 4
15433: PPUSH
15434: LD_INT 3
15436: PPUSH
15437: CALL_OW 272
15441: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15442: LD_ADDR_VAR 0 8
15446: PUSH
15447: LD_VAR 0 6
15451: PPUSH
15452: LD_VAR 0 4
15456: PPUSH
15457: LD_INT 3
15459: PPUSH
15460: CALL_OW 273
15464: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15465: LD_VAR 0 7
15469: PPUSH
15470: LD_VAR 0 8
15474: PPUSH
15475: CALL_OW 488
15479: NOT
15480: IFFALSE 15484
// continue ;
15482: GO 15416
// if HexInfo ( _x , _y ) = 0 then
15484: LD_VAR 0 7
15488: PPUSH
15489: LD_VAR 0 8
15493: PPUSH
15494: CALL_OW 428
15498: PUSH
15499: LD_INT 0
15501: EQUAL
15502: IFFALSE 15527
// begin ComMoveXY ( unit , _x , _y ) ;
15504: LD_VAR 0 1
15508: PPUSH
15509: LD_VAR 0 7
15513: PPUSH
15514: LD_VAR 0 8
15518: PPUSH
15519: CALL_OW 111
// exit ;
15523: POP
15524: POP
15525: GO 15531
// end ; end ;
15527: GO 15416
15529: POP
15530: POP
// end ;
15531: LD_VAR 0 3
15535: RET
// export function ScanBase ( side , base_area ) ; begin
15536: LD_INT 0
15538: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15539: LD_ADDR_VAR 0 3
15543: PUSH
15544: LD_VAR 0 2
15548: PPUSH
15549: LD_INT 81
15551: PUSH
15552: LD_VAR 0 1
15556: PUSH
15557: EMPTY
15558: LIST
15559: LIST
15560: PPUSH
15561: CALL_OW 70
15565: ST_TO_ADDR
// end ;
15566: LD_VAR 0 3
15570: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15571: LD_INT 0
15573: PPUSH
15574: PPUSH
15575: PPUSH
15576: PPUSH
15577: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15578: LD_VAR 0 1
15582: NOT
15583: PUSH
15584: LD_EXP 58
15588: PUSH
15589: LD_VAR 0 1
15593: ARRAY
15594: NOT
15595: OR
15596: PUSH
15597: LD_VAR 0 2
15601: NOT
15602: OR
15603: PUSH
15604: LD_VAR 0 3
15608: NOT
15609: OR
15610: IFFALSE 15614
// exit ;
15612: GO 16064
// side := mc_sides [ base ] ;
15614: LD_ADDR_VAR 0 6
15618: PUSH
15619: LD_EXP 84
15623: PUSH
15624: LD_VAR 0 1
15628: ARRAY
15629: ST_TO_ADDR
// if not side then
15630: LD_VAR 0 6
15634: NOT
15635: IFFALSE 15639
// exit ;
15637: GO 16064
// for i in solds do
15639: LD_ADDR_VAR 0 7
15643: PUSH
15644: LD_VAR 0 2
15648: PUSH
15649: FOR_IN
15650: IFFALSE 15711
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15652: LD_VAR 0 7
15656: PPUSH
15657: CALL_OW 310
15661: PPUSH
15662: CALL_OW 266
15666: PUSH
15667: LD_INT 32
15669: PUSH
15670: LD_INT 31
15672: PUSH
15673: EMPTY
15674: LIST
15675: LIST
15676: IN
15677: IFFALSE 15697
// solds := solds diff i else
15679: LD_ADDR_VAR 0 2
15683: PUSH
15684: LD_VAR 0 2
15688: PUSH
15689: LD_VAR 0 7
15693: DIFF
15694: ST_TO_ADDR
15695: GO 15709
// SetTag ( i , 18 ) ;
15697: LD_VAR 0 7
15701: PPUSH
15702: LD_INT 18
15704: PPUSH
15705: CALL_OW 109
15709: GO 15649
15711: POP
15712: POP
// if not solds then
15713: LD_VAR 0 2
15717: NOT
15718: IFFALSE 15722
// exit ;
15720: GO 16064
// repeat wait ( 0 0$1 ) ;
15722: LD_INT 35
15724: PPUSH
15725: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15729: LD_ADDR_VAR 0 5
15733: PUSH
15734: LD_VAR 0 6
15738: PPUSH
15739: LD_VAR 0 3
15743: PPUSH
15744: CALL 15536 0 2
15748: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
15749: LD_VAR 0 5
15753: NOT
15754: PUSH
15755: LD_VAR 0 5
15759: PUSH
15760: LD_INT 3
15762: GREATER
15763: OR
15764: PUSH
15765: LD_EXP 80
15769: PUSH
15770: LD_VAR 0 1
15774: ARRAY
15775: OR
15776: IFFALSE 15817
// begin for i in solds do
15778: LD_ADDR_VAR 0 7
15782: PUSH
15783: LD_VAR 0 2
15787: PUSH
15788: FOR_IN
15789: IFFALSE 15813
// if HasTask ( i ) then
15791: LD_VAR 0 7
15795: PPUSH
15796: CALL_OW 314
15800: IFFALSE 15811
// ComStop ( i ) ;
15802: LD_VAR 0 7
15806: PPUSH
15807: CALL_OW 141
15811: GO 15788
15813: POP
15814: POP
// break ;
15815: GO 16052
// end ; for i in solds do
15817: LD_ADDR_VAR 0 7
15821: PUSH
15822: LD_VAR 0 2
15826: PUSH
15827: FOR_IN
15828: IFFALSE 16044
// begin if IsInUnit ( i ) then
15830: LD_VAR 0 7
15834: PPUSH
15835: CALL_OW 310
15839: IFFALSE 15850
// ComExitBuilding ( i ) ;
15841: LD_VAR 0 7
15845: PPUSH
15846: CALL_OW 122
// if GetLives ( i ) > 333 then
15850: LD_VAR 0 7
15854: PPUSH
15855: CALL_OW 256
15859: PUSH
15860: LD_INT 333
15862: GREATER
15863: IFFALSE 15891
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15865: LD_VAR 0 7
15869: PPUSH
15870: LD_VAR 0 5
15874: PPUSH
15875: LD_VAR 0 7
15879: PPUSH
15880: CALL_OW 74
15884: PPUSH
15885: CALL_OW 115
15889: GO 16042
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
15891: LD_ADDR_VAR 0 8
15895: PUSH
15896: LD_EXP 58
15900: PUSH
15901: LD_VAR 0 1
15905: ARRAY
15906: PPUSH
15907: LD_INT 2
15909: PUSH
15910: LD_INT 30
15912: PUSH
15913: LD_INT 0
15915: PUSH
15916: EMPTY
15917: LIST
15918: LIST
15919: PUSH
15920: LD_INT 30
15922: PUSH
15923: LD_INT 1
15925: PUSH
15926: EMPTY
15927: LIST
15928: LIST
15929: PUSH
15930: LD_INT 30
15932: PUSH
15933: LD_INT 6
15935: PUSH
15936: EMPTY
15937: LIST
15938: LIST
15939: PUSH
15940: EMPTY
15941: LIST
15942: LIST
15943: LIST
15944: LIST
15945: PPUSH
15946: CALL_OW 72
15950: PPUSH
15951: LD_VAR 0 7
15955: PPUSH
15956: CALL_OW 74
15960: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
15961: LD_VAR 0 7
15965: PPUSH
15966: LD_VAR 0 8
15970: PPUSH
15971: CALL_OW 250
15975: PPUSH
15976: LD_INT 3
15978: PPUSH
15979: LD_INT 5
15981: PPUSH
15982: CALL_OW 272
15986: PPUSH
15987: LD_VAR 0 8
15991: PPUSH
15992: CALL_OW 251
15996: PPUSH
15997: LD_INT 3
15999: PPUSH
16000: LD_INT 5
16002: PPUSH
16003: CALL_OW 273
16007: PPUSH
16008: CALL_OW 111
// SetTag ( i , 0 ) ;
16012: LD_VAR 0 7
16016: PPUSH
16017: LD_INT 0
16019: PPUSH
16020: CALL_OW 109
// solds := solds diff i ;
16024: LD_ADDR_VAR 0 2
16028: PUSH
16029: LD_VAR 0 2
16033: PUSH
16034: LD_VAR 0 7
16038: DIFF
16039: ST_TO_ADDR
// continue ;
16040: GO 15827
// end ; end ;
16042: GO 15827
16044: POP
16045: POP
// until solds ;
16046: LD_VAR 0 2
16050: IFFALSE 15722
// MC_Reset ( base , 18 ) ;
16052: LD_VAR 0 1
16056: PPUSH
16057: LD_INT 18
16059: PPUSH
16060: CALL 60560 0 2
// end ;
16064: LD_VAR 0 4
16068: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16069: LD_INT 0
16071: PPUSH
16072: PPUSH
16073: PPUSH
16074: PPUSH
16075: PPUSH
16076: PPUSH
16077: PPUSH
16078: PPUSH
16079: PPUSH
16080: PPUSH
16081: PPUSH
16082: PPUSH
16083: PPUSH
16084: PPUSH
16085: PPUSH
16086: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16087: LD_ADDR_VAR 0 12
16091: PUSH
16092: LD_EXP 58
16096: PUSH
16097: LD_VAR 0 1
16101: ARRAY
16102: PPUSH
16103: LD_INT 25
16105: PUSH
16106: LD_INT 3
16108: PUSH
16109: EMPTY
16110: LIST
16111: LIST
16112: PPUSH
16113: CALL_OW 72
16117: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16118: LD_ADDR_VAR 0 8
16122: PUSH
16123: LD_EXP 58
16127: PUSH
16128: LD_VAR 0 1
16132: ARRAY
16133: PPUSH
16134: LD_INT 2
16136: PUSH
16137: LD_INT 25
16139: PUSH
16140: LD_INT 1
16142: PUSH
16143: EMPTY
16144: LIST
16145: LIST
16146: PUSH
16147: LD_INT 25
16149: PUSH
16150: LD_INT 5
16152: PUSH
16153: EMPTY
16154: LIST
16155: LIST
16156: PUSH
16157: LD_INT 25
16159: PUSH
16160: LD_INT 8
16162: PUSH
16163: EMPTY
16164: LIST
16165: LIST
16166: PUSH
16167: LD_INT 25
16169: PUSH
16170: LD_INT 9
16172: PUSH
16173: EMPTY
16174: LIST
16175: LIST
16176: PUSH
16177: EMPTY
16178: LIST
16179: LIST
16180: LIST
16181: LIST
16182: LIST
16183: PPUSH
16184: CALL_OW 72
16188: ST_TO_ADDR
// if not defenders and not solds then
16189: LD_VAR 0 2
16193: NOT
16194: PUSH
16195: LD_VAR 0 8
16199: NOT
16200: AND
16201: IFFALSE 16205
// exit ;
16203: GO 17534
// depot_under_attack := false ;
16205: LD_ADDR_VAR 0 16
16209: PUSH
16210: LD_INT 0
16212: ST_TO_ADDR
// sold_defenders := [ ] ;
16213: LD_ADDR_VAR 0 17
16217: PUSH
16218: EMPTY
16219: ST_TO_ADDR
// if mechs then
16220: LD_VAR 0 12
16224: IFFALSE 16353
// for i in defenders do
16226: LD_ADDR_VAR 0 5
16230: PUSH
16231: LD_VAR 0 2
16235: PUSH
16236: FOR_IN
16237: IFFALSE 16351
// begin SetTag ( i , 20 ) ;
16239: LD_VAR 0 5
16243: PPUSH
16244: LD_INT 20
16246: PPUSH
16247: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16251: LD_VAR 0 5
16255: PPUSH
16256: CALL_OW 263
16260: PUSH
16261: LD_INT 1
16263: EQUAL
16264: PUSH
16265: LD_VAR 0 5
16269: PPUSH
16270: CALL_OW 311
16274: NOT
16275: AND
16276: PUSH
16277: LD_VAR 0 12
16281: AND
16282: IFFALSE 16349
// begin un := mechs [ 1 ] ;
16284: LD_ADDR_VAR 0 10
16288: PUSH
16289: LD_VAR 0 12
16293: PUSH
16294: LD_INT 1
16296: ARRAY
16297: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16298: LD_VAR 0 10
16302: PPUSH
16303: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16307: LD_VAR 0 10
16311: PPUSH
16312: LD_VAR 0 5
16316: PPUSH
16317: CALL_OW 180
// SetTag ( un , 19 ) ;
16321: LD_VAR 0 10
16325: PPUSH
16326: LD_INT 19
16328: PPUSH
16329: CALL_OW 109
// mechs := mechs diff un ;
16333: LD_ADDR_VAR 0 12
16337: PUSH
16338: LD_VAR 0 12
16342: PUSH
16343: LD_VAR 0 10
16347: DIFF
16348: ST_TO_ADDR
// end ; end ;
16349: GO 16236
16351: POP
16352: POP
// if solds then
16353: LD_VAR 0 8
16357: IFFALSE 16416
// for i in solds do
16359: LD_ADDR_VAR 0 5
16363: PUSH
16364: LD_VAR 0 8
16368: PUSH
16369: FOR_IN
16370: IFFALSE 16414
// if not GetTag ( i ) then
16372: LD_VAR 0 5
16376: PPUSH
16377: CALL_OW 110
16381: NOT
16382: IFFALSE 16412
// begin defenders := defenders union i ;
16384: LD_ADDR_VAR 0 2
16388: PUSH
16389: LD_VAR 0 2
16393: PUSH
16394: LD_VAR 0 5
16398: UNION
16399: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16400: LD_VAR 0 5
16404: PPUSH
16405: LD_INT 18
16407: PPUSH
16408: CALL_OW 109
// end ;
16412: GO 16369
16414: POP
16415: POP
// repeat wait ( 0 0$1 ) ;
16416: LD_INT 35
16418: PPUSH
16419: CALL_OW 67
// enemy := mc_scan [ base ] ;
16423: LD_ADDR_VAR 0 3
16427: PUSH
16428: LD_EXP 81
16432: PUSH
16433: LD_VAR 0 1
16437: ARRAY
16438: ST_TO_ADDR
// for i in defenders do
16439: LD_ADDR_VAR 0 5
16443: PUSH
16444: LD_VAR 0 2
16448: PUSH
16449: FOR_IN
16450: IFFALSE 17135
// begin e := NearestUnitToUnit ( enemy , i ) ;
16452: LD_ADDR_VAR 0 13
16456: PUSH
16457: LD_VAR 0 3
16461: PPUSH
16462: LD_VAR 0 5
16466: PPUSH
16467: CALL_OW 74
16471: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
16472: LD_ADDR_VAR 0 16
16476: PUSH
16477: LD_EXP 58
16481: PUSH
16482: LD_VAR 0 1
16486: ARRAY
16487: PPUSH
16488: LD_INT 2
16490: PUSH
16491: LD_INT 30
16493: PUSH
16494: LD_INT 0
16496: PUSH
16497: EMPTY
16498: LIST
16499: LIST
16500: PUSH
16501: LD_INT 30
16503: PUSH
16504: LD_INT 1
16506: PUSH
16507: EMPTY
16508: LIST
16509: LIST
16510: PUSH
16511: EMPTY
16512: LIST
16513: LIST
16514: LIST
16515: PPUSH
16516: CALL_OW 72
16520: NOT
16521: PUSH
16522: LD_EXP 58
16526: PUSH
16527: LD_VAR 0 1
16531: ARRAY
16532: PPUSH
16533: LD_INT 2
16535: PUSH
16536: LD_INT 30
16538: PUSH
16539: LD_INT 0
16541: PUSH
16542: EMPTY
16543: LIST
16544: LIST
16545: PUSH
16546: LD_INT 30
16548: PUSH
16549: LD_INT 1
16551: PUSH
16552: EMPTY
16553: LIST
16554: LIST
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: LIST
16560: PPUSH
16561: CALL_OW 72
16565: PPUSH
16566: CALL_OW 256
16570: PUSH
16571: LD_INT 600
16573: LESS
16574: OR
16575: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
16576: LD_VAR 0 5
16580: PPUSH
16581: CALL_OW 247
16585: PUSH
16586: LD_INT 2
16588: DOUBLE
16589: EQUAL
16590: IFTRUE 16594
16592: GO 16841
16594: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
16595: LD_VAR 0 5
16599: PPUSH
16600: CALL_OW 256
16604: PUSH
16605: LD_INT 650
16607: GREATER
16608: PUSH
16609: LD_VAR 0 5
16613: PPUSH
16614: LD_VAR 0 13
16618: PPUSH
16619: CALL_OW 296
16623: PUSH
16624: LD_INT 40
16626: LESS
16627: AND
16628: IFFALSE 16646
// ComAttackUnit ( i , e ) else
16630: LD_VAR 0 5
16634: PPUSH
16635: LD_VAR 0 13
16639: PPUSH
16640: CALL_OW 115
16644: GO 16724
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
16646: LD_VAR 0 5
16650: PPUSH
16651: LD_VAR 0 13
16655: PPUSH
16656: CALL_OW 296
16660: PUSH
16661: LD_INT 30
16663: GREATEREQUAL
16664: PUSH
16665: LD_VAR 0 5
16669: PPUSH
16670: CALL_OW 256
16674: PUSH
16675: LD_INT 650
16677: LESSEQUAL
16678: OR
16679: PUSH
16680: LD_VAR 0 5
16684: PPUSH
16685: LD_EXP 82
16689: PUSH
16690: LD_VAR 0 1
16694: ARRAY
16695: PPUSH
16696: CALL_OW 308
16700: NOT
16701: AND
16702: IFFALSE 16724
// ComMoveToArea ( i , mc_parking [ base ] ) ;
16704: LD_VAR 0 5
16708: PPUSH
16709: LD_EXP 82
16713: PUSH
16714: LD_VAR 0 1
16718: ARRAY
16719: PPUSH
16720: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
16724: LD_VAR 0 5
16728: PPUSH
16729: CALL_OW 256
16733: PUSH
16734: LD_INT 998
16736: LESS
16737: PUSH
16738: LD_VAR 0 5
16742: PPUSH
16743: CALL_OW 263
16747: PUSH
16748: LD_INT 1
16750: EQUAL
16751: AND
16752: PUSH
16753: LD_VAR 0 5
16757: PPUSH
16758: CALL_OW 311
16762: AND
16763: PUSH
16764: LD_VAR 0 5
16768: PPUSH
16769: LD_EXP 82
16773: PUSH
16774: LD_VAR 0 1
16778: ARRAY
16779: PPUSH
16780: CALL_OW 308
16784: AND
16785: IFFALSE 16839
// begin mech := IsDrivenBy ( i ) ;
16787: LD_ADDR_VAR 0 9
16791: PUSH
16792: LD_VAR 0 5
16796: PPUSH
16797: CALL_OW 311
16801: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
16802: LD_VAR 0 9
16806: PPUSH
16807: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
16811: LD_VAR 0 9
16815: PPUSH
16816: LD_VAR 0 5
16820: PPUSH
16821: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
16825: LD_VAR 0 9
16829: PPUSH
16830: LD_VAR 0 5
16834: PPUSH
16835: CALL_OW 180
// end ; end ; unit_human :
16839: GO 17106
16841: LD_INT 1
16843: DOUBLE
16844: EQUAL
16845: IFTRUE 16849
16847: GO 17105
16849: POP
// begin b := IsInUnit ( i ) ;
16850: LD_ADDR_VAR 0 18
16854: PUSH
16855: LD_VAR 0 5
16859: PPUSH
16860: CALL_OW 310
16864: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
16865: LD_ADDR_VAR 0 19
16869: PUSH
16870: LD_VAR 0 18
16874: NOT
16875: PUSH
16876: LD_VAR 0 18
16880: PPUSH
16881: CALL_OW 266
16885: PUSH
16886: LD_INT 32
16888: PUSH
16889: LD_INT 31
16891: PUSH
16892: EMPTY
16893: LIST
16894: LIST
16895: IN
16896: OR
16897: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
16898: LD_VAR 0 16
16902: PUSH
16903: LD_VAR 0 2
16907: PPUSH
16908: LD_INT 21
16910: PUSH
16911: LD_INT 2
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: PPUSH
16918: CALL_OW 72
16922: PUSH
16923: LD_INT 1
16925: LESSEQUAL
16926: OR
16927: PUSH
16928: LD_VAR 0 19
16932: AND
16933: PUSH
16934: LD_VAR 0 5
16938: PUSH
16939: LD_VAR 0 17
16943: IN
16944: NOT
16945: AND
16946: IFFALSE 17039
// begin if b then
16948: LD_VAR 0 18
16952: IFFALSE 17001
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
16954: LD_VAR 0 18
16958: PPUSH
16959: LD_VAR 0 3
16963: PPUSH
16964: LD_VAR 0 18
16968: PPUSH
16969: CALL_OW 74
16973: PPUSH
16974: CALL_OW 296
16978: PUSH
16979: LD_INT 10
16981: LESS
16982: PUSH
16983: LD_VAR 0 18
16987: PPUSH
16988: CALL_OW 461
16992: PUSH
16993: LD_INT 7
16995: NONEQUAL
16996: AND
16997: IFFALSE 17001
// continue ;
16999: GO 16449
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
17001: LD_ADDR_VAR 0 17
17005: PUSH
17006: LD_VAR 0 17
17010: PPUSH
17011: LD_VAR 0 17
17015: PUSH
17016: LD_INT 1
17018: PLUS
17019: PPUSH
17020: LD_VAR 0 5
17024: PPUSH
17025: CALL_OW 1
17029: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17030: LD_VAR 0 5
17034: PPUSH
17035: CALL_OW 122
// end ; if sold_defenders then
17039: LD_VAR 0 17
17043: IFFALSE 17103
// if i in sold_defenders then
17045: LD_VAR 0 5
17049: PUSH
17050: LD_VAR 0 17
17054: IN
17055: IFFALSE 17103
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17057: LD_VAR 0 5
17061: PPUSH
17062: CALL_OW 314
17066: NOT
17067: PUSH
17068: LD_VAR 0 5
17072: PPUSH
17073: LD_VAR 0 13
17077: PPUSH
17078: CALL_OW 296
17082: PUSH
17083: LD_INT 30
17085: LESS
17086: AND
17087: IFFALSE 17103
// ComAttackUnit ( i , e ) ;
17089: LD_VAR 0 5
17093: PPUSH
17094: LD_VAR 0 13
17098: PPUSH
17099: CALL_OW 115
// end ; end ; end ;
17103: GO 17106
17105: POP
// if IsDead ( i ) then
17106: LD_VAR 0 5
17110: PPUSH
17111: CALL_OW 301
17115: IFFALSE 17133
// defenders := defenders diff i ;
17117: LD_ADDR_VAR 0 2
17121: PUSH
17122: LD_VAR 0 2
17126: PUSH
17127: LD_VAR 0 5
17131: DIFF
17132: ST_TO_ADDR
// end ;
17133: GO 16449
17135: POP
17136: POP
// until not enemy or not defenders ;
17137: LD_VAR 0 3
17141: NOT
17142: PUSH
17143: LD_VAR 0 2
17147: NOT
17148: OR
17149: IFFALSE 16416
// MC_Reset ( base , 18 ) ;
17151: LD_VAR 0 1
17155: PPUSH
17156: LD_INT 18
17158: PPUSH
17159: CALL 60560 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17163: LD_ADDR_VAR 0 2
17167: PUSH
17168: LD_VAR 0 2
17172: PUSH
17173: LD_VAR 0 2
17177: PPUSH
17178: LD_INT 2
17180: PUSH
17181: LD_INT 25
17183: PUSH
17184: LD_INT 1
17186: PUSH
17187: EMPTY
17188: LIST
17189: LIST
17190: PUSH
17191: LD_INT 25
17193: PUSH
17194: LD_INT 5
17196: PUSH
17197: EMPTY
17198: LIST
17199: LIST
17200: PUSH
17201: LD_INT 25
17203: PUSH
17204: LD_INT 8
17206: PUSH
17207: EMPTY
17208: LIST
17209: LIST
17210: PUSH
17211: LD_INT 25
17213: PUSH
17214: LD_INT 9
17216: PUSH
17217: EMPTY
17218: LIST
17219: LIST
17220: PUSH
17221: EMPTY
17222: LIST
17223: LIST
17224: LIST
17225: LIST
17226: LIST
17227: PPUSH
17228: CALL_OW 72
17232: DIFF
17233: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17234: LD_VAR 0 3
17238: NOT
17239: PUSH
17240: LD_VAR 0 2
17244: PPUSH
17245: LD_INT 21
17247: PUSH
17248: LD_INT 2
17250: PUSH
17251: EMPTY
17252: LIST
17253: LIST
17254: PPUSH
17255: CALL_OW 72
17259: AND
17260: IFFALSE 17522
// begin tmp := FilterByTag ( defenders , 19 ) ;
17262: LD_ADDR_VAR 0 11
17266: PUSH
17267: LD_VAR 0 2
17271: PPUSH
17272: LD_INT 19
17274: PPUSH
17275: CALL 53902 0 2
17279: ST_TO_ADDR
// if tmp then
17280: LD_VAR 0 11
17284: IFFALSE 17354
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
17286: LD_ADDR_VAR 0 11
17290: PUSH
17291: LD_VAR 0 11
17295: PPUSH
17296: LD_INT 25
17298: PUSH
17299: LD_INT 3
17301: PUSH
17302: EMPTY
17303: LIST
17304: LIST
17305: PPUSH
17306: CALL_OW 72
17310: ST_TO_ADDR
// if tmp then
17311: LD_VAR 0 11
17315: IFFALSE 17354
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
17317: LD_ADDR_EXP 70
17321: PUSH
17322: LD_EXP 70
17326: PPUSH
17327: LD_VAR 0 1
17331: PPUSH
17332: LD_EXP 70
17336: PUSH
17337: LD_VAR 0 1
17341: ARRAY
17342: PUSH
17343: LD_VAR 0 11
17347: UNION
17348: PPUSH
17349: CALL_OW 1
17353: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
17354: LD_VAR 0 1
17358: PPUSH
17359: LD_INT 19
17361: PPUSH
17362: CALL 60560 0 2
// repeat wait ( 0 0$1 ) ;
17366: LD_INT 35
17368: PPUSH
17369: CALL_OW 67
// for i in defenders do
17373: LD_ADDR_VAR 0 5
17377: PUSH
17378: LD_VAR 0 2
17382: PUSH
17383: FOR_IN
17384: IFFALSE 17473
// begin if not IsInArea ( i , mc_parking [ base ] ) then
17386: LD_VAR 0 5
17390: PPUSH
17391: LD_EXP 82
17395: PUSH
17396: LD_VAR 0 1
17400: ARRAY
17401: PPUSH
17402: CALL_OW 308
17406: NOT
17407: IFFALSE 17431
// ComMoveToArea ( i , mc_parking [ base ] ) else
17409: LD_VAR 0 5
17413: PPUSH
17414: LD_EXP 82
17418: PUSH
17419: LD_VAR 0 1
17423: ARRAY
17424: PPUSH
17425: CALL_OW 113
17429: GO 17471
// if GetControl ( i ) = control_manual then
17431: LD_VAR 0 5
17435: PPUSH
17436: CALL_OW 263
17440: PUSH
17441: LD_INT 1
17443: EQUAL
17444: IFFALSE 17471
// if IsDrivenBy ( i ) then
17446: LD_VAR 0 5
17450: PPUSH
17451: CALL_OW 311
17455: IFFALSE 17471
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
17457: LD_VAR 0 5
17461: PPUSH
17462: CALL_OW 311
17466: PPUSH
17467: CALL_OW 121
// end ;
17471: GO 17383
17473: POP
17474: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
17475: LD_VAR 0 2
17479: PPUSH
17480: LD_INT 95
17482: PUSH
17483: LD_EXP 82
17487: PUSH
17488: LD_VAR 0 1
17492: ARRAY
17493: PUSH
17494: EMPTY
17495: LIST
17496: LIST
17497: PPUSH
17498: CALL_OW 72
17502: PUSH
17503: LD_VAR 0 2
17507: EQUAL
17508: PUSH
17509: LD_EXP 81
17513: PUSH
17514: LD_VAR 0 1
17518: ARRAY
17519: OR
17520: IFFALSE 17366
// end ; MC_Reset ( base , 20 ) ;
17522: LD_VAR 0 1
17526: PPUSH
17527: LD_INT 20
17529: PPUSH
17530: CALL 60560 0 2
// end ;
17534: LD_VAR 0 4
17538: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17539: LD_INT 0
17541: PPUSH
17542: PPUSH
17543: PPUSH
17544: PPUSH
// result := false ;
17545: LD_ADDR_VAR 0 2
17549: PUSH
17550: LD_INT 0
17552: ST_TO_ADDR
// side := GetSide ( unit ) ;
17553: LD_ADDR_VAR 0 3
17557: PUSH
17558: LD_VAR 0 1
17562: PPUSH
17563: CALL_OW 255
17567: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17568: LD_ADDR_VAR 0 4
17572: PUSH
17573: LD_VAR 0 1
17577: PPUSH
17578: CALL_OW 248
17582: ST_TO_ADDR
// case nat of 1 :
17583: LD_VAR 0 4
17587: PUSH
17588: LD_INT 1
17590: DOUBLE
17591: EQUAL
17592: IFTRUE 17596
17594: GO 17607
17596: POP
// tech := tech_lassight ; 2 :
17597: LD_ADDR_VAR 0 5
17601: PUSH
17602: LD_INT 12
17604: ST_TO_ADDR
17605: GO 17646
17607: LD_INT 2
17609: DOUBLE
17610: EQUAL
17611: IFTRUE 17615
17613: GO 17626
17615: POP
// tech := tech_mortar ; 3 :
17616: LD_ADDR_VAR 0 5
17620: PUSH
17621: LD_INT 41
17623: ST_TO_ADDR
17624: GO 17646
17626: LD_INT 3
17628: DOUBLE
17629: EQUAL
17630: IFTRUE 17634
17632: GO 17645
17634: POP
// tech := tech_bazooka ; end ;
17635: LD_ADDR_VAR 0 5
17639: PUSH
17640: LD_INT 44
17642: ST_TO_ADDR
17643: GO 17646
17645: POP
// if Researched ( side , tech ) then
17646: LD_VAR 0 3
17650: PPUSH
17651: LD_VAR 0 5
17655: PPUSH
17656: CALL_OW 325
17660: IFFALSE 17687
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17662: LD_ADDR_VAR 0 2
17666: PUSH
17667: LD_INT 5
17669: PUSH
17670: LD_INT 8
17672: PUSH
17673: LD_INT 9
17675: PUSH
17676: EMPTY
17677: LIST
17678: LIST
17679: LIST
17680: PUSH
17681: LD_VAR 0 4
17685: ARRAY
17686: ST_TO_ADDR
// end ;
17687: LD_VAR 0 2
17691: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17692: LD_INT 0
17694: PPUSH
17695: PPUSH
17696: PPUSH
// if not mines then
17697: LD_VAR 0 2
17701: NOT
17702: IFFALSE 17706
// exit ;
17704: GO 17850
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17706: LD_ADDR_VAR 0 5
17710: PUSH
17711: LD_INT 81
17713: PUSH
17714: LD_VAR 0 1
17718: PUSH
17719: EMPTY
17720: LIST
17721: LIST
17722: PUSH
17723: LD_INT 3
17725: PUSH
17726: LD_INT 21
17728: PUSH
17729: LD_INT 3
17731: PUSH
17732: EMPTY
17733: LIST
17734: LIST
17735: PUSH
17736: EMPTY
17737: LIST
17738: LIST
17739: PUSH
17740: EMPTY
17741: LIST
17742: LIST
17743: PPUSH
17744: CALL_OW 69
17748: ST_TO_ADDR
// for i in mines do
17749: LD_ADDR_VAR 0 4
17753: PUSH
17754: LD_VAR 0 2
17758: PUSH
17759: FOR_IN
17760: IFFALSE 17848
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
17762: LD_VAR 0 4
17766: PUSH
17767: LD_INT 1
17769: ARRAY
17770: PPUSH
17771: LD_VAR 0 4
17775: PUSH
17776: LD_INT 2
17778: ARRAY
17779: PPUSH
17780: CALL_OW 458
17784: NOT
17785: IFFALSE 17789
// continue ;
17787: GO 17759
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
17789: LD_VAR 0 4
17793: PUSH
17794: LD_INT 1
17796: ARRAY
17797: PPUSH
17798: LD_VAR 0 4
17802: PUSH
17803: LD_INT 2
17805: ARRAY
17806: PPUSH
17807: CALL_OW 428
17811: PUSH
17812: LD_VAR 0 5
17816: IN
17817: IFFALSE 17846
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17819: LD_VAR 0 4
17823: PUSH
17824: LD_INT 1
17826: ARRAY
17827: PPUSH
17828: LD_VAR 0 4
17832: PUSH
17833: LD_INT 2
17835: ARRAY
17836: PPUSH
17837: LD_VAR 0 1
17841: PPUSH
17842: CALL_OW 456
// end ;
17846: GO 17759
17848: POP
17849: POP
// end ;
17850: LD_VAR 0 3
17854: RET
// export function Count ( array ) ; var i ; begin
17855: LD_INT 0
17857: PPUSH
17858: PPUSH
// result := 0 ;
17859: LD_ADDR_VAR 0 2
17863: PUSH
17864: LD_INT 0
17866: ST_TO_ADDR
// for i in array do
17867: LD_ADDR_VAR 0 3
17871: PUSH
17872: LD_VAR 0 1
17876: PUSH
17877: FOR_IN
17878: IFFALSE 17902
// if i then
17880: LD_VAR 0 3
17884: IFFALSE 17900
// result := result + 1 ;
17886: LD_ADDR_VAR 0 2
17890: PUSH
17891: LD_VAR 0 2
17895: PUSH
17896: LD_INT 1
17898: PLUS
17899: ST_TO_ADDR
17900: GO 17877
17902: POP
17903: POP
// end ;
17904: LD_VAR 0 2
17908: RET
// export function IsEmpty ( building ) ; begin
17909: LD_INT 0
17911: PPUSH
// if not building then
17912: LD_VAR 0 1
17916: NOT
17917: IFFALSE 17921
// exit ;
17919: GO 17964
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17921: LD_ADDR_VAR 0 2
17925: PUSH
17926: LD_VAR 0 1
17930: PUSH
17931: LD_INT 22
17933: PUSH
17934: LD_VAR 0 1
17938: PPUSH
17939: CALL_OW 255
17943: PUSH
17944: EMPTY
17945: LIST
17946: LIST
17947: PUSH
17948: LD_INT 58
17950: PUSH
17951: EMPTY
17952: LIST
17953: PUSH
17954: EMPTY
17955: LIST
17956: LIST
17957: PPUSH
17958: CALL_OW 69
17962: IN
17963: ST_TO_ADDR
// end ;
17964: LD_VAR 0 2
17968: RET
// export function IsNotFull ( building ) ; begin
17969: LD_INT 0
17971: PPUSH
// if not building then
17972: LD_VAR 0 1
17976: NOT
17977: IFFALSE 17981
// exit ;
17979: GO 18000
// result := UnitsInside ( building ) < 6 ;
17981: LD_ADDR_VAR 0 2
17985: PUSH
17986: LD_VAR 0 1
17990: PPUSH
17991: CALL_OW 313
17995: PUSH
17996: LD_INT 6
17998: LESS
17999: ST_TO_ADDR
// end ;
18000: LD_VAR 0 2
18004: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18005: LD_INT 0
18007: PPUSH
18008: PPUSH
18009: PPUSH
18010: PPUSH
// tmp := [ ] ;
18011: LD_ADDR_VAR 0 3
18015: PUSH
18016: EMPTY
18017: ST_TO_ADDR
// list := [ ] ;
18018: LD_ADDR_VAR 0 5
18022: PUSH
18023: EMPTY
18024: ST_TO_ADDR
// for i = 16 to 25 do
18025: LD_ADDR_VAR 0 4
18029: PUSH
18030: DOUBLE
18031: LD_INT 16
18033: DEC
18034: ST_TO_ADDR
18035: LD_INT 25
18037: PUSH
18038: FOR_TO
18039: IFFALSE 18112
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18041: LD_ADDR_VAR 0 3
18045: PUSH
18046: LD_VAR 0 3
18050: PUSH
18051: LD_INT 22
18053: PUSH
18054: LD_VAR 0 1
18058: PPUSH
18059: CALL_OW 255
18063: PUSH
18064: EMPTY
18065: LIST
18066: LIST
18067: PUSH
18068: LD_INT 91
18070: PUSH
18071: LD_VAR 0 1
18075: PUSH
18076: LD_INT 6
18078: PUSH
18079: EMPTY
18080: LIST
18081: LIST
18082: LIST
18083: PUSH
18084: LD_INT 30
18086: PUSH
18087: LD_VAR 0 4
18091: PUSH
18092: EMPTY
18093: LIST
18094: LIST
18095: PUSH
18096: EMPTY
18097: LIST
18098: LIST
18099: LIST
18100: PUSH
18101: EMPTY
18102: LIST
18103: PPUSH
18104: CALL_OW 69
18108: ADD
18109: ST_TO_ADDR
18110: GO 18038
18112: POP
18113: POP
// for i = 1 to tmp do
18114: LD_ADDR_VAR 0 4
18118: PUSH
18119: DOUBLE
18120: LD_INT 1
18122: DEC
18123: ST_TO_ADDR
18124: LD_VAR 0 3
18128: PUSH
18129: FOR_TO
18130: IFFALSE 18218
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18132: LD_ADDR_VAR 0 5
18136: PUSH
18137: LD_VAR 0 5
18141: PUSH
18142: LD_VAR 0 3
18146: PUSH
18147: LD_VAR 0 4
18151: ARRAY
18152: PPUSH
18153: CALL_OW 266
18157: PUSH
18158: LD_VAR 0 3
18162: PUSH
18163: LD_VAR 0 4
18167: ARRAY
18168: PPUSH
18169: CALL_OW 250
18173: PUSH
18174: LD_VAR 0 3
18178: PUSH
18179: LD_VAR 0 4
18183: ARRAY
18184: PPUSH
18185: CALL_OW 251
18189: PUSH
18190: LD_VAR 0 3
18194: PUSH
18195: LD_VAR 0 4
18199: ARRAY
18200: PPUSH
18201: CALL_OW 254
18205: PUSH
18206: EMPTY
18207: LIST
18208: LIST
18209: LIST
18210: LIST
18211: PUSH
18212: EMPTY
18213: LIST
18214: ADD
18215: ST_TO_ADDR
18216: GO 18129
18218: POP
18219: POP
// result := list ;
18220: LD_ADDR_VAR 0 2
18224: PUSH
18225: LD_VAR 0 5
18229: ST_TO_ADDR
// end ;
18230: LD_VAR 0 2
18234: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18235: LD_INT 0
18237: PPUSH
18238: PPUSH
18239: PPUSH
18240: PPUSH
18241: PPUSH
18242: PPUSH
18243: PPUSH
// if not factory then
18244: LD_VAR 0 1
18248: NOT
18249: IFFALSE 18253
// exit ;
18251: GO 18785
// if control = control_apeman then
18253: LD_VAR 0 4
18257: PUSH
18258: LD_INT 5
18260: EQUAL
18261: IFFALSE 18370
// begin tmp := UnitsInside ( factory ) ;
18263: LD_ADDR_VAR 0 8
18267: PUSH
18268: LD_VAR 0 1
18272: PPUSH
18273: CALL_OW 313
18277: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18278: LD_VAR 0 8
18282: PPUSH
18283: LD_INT 25
18285: PUSH
18286: LD_INT 12
18288: PUSH
18289: EMPTY
18290: LIST
18291: LIST
18292: PPUSH
18293: CALL_OW 72
18297: NOT
18298: IFFALSE 18308
// control := control_manual ;
18300: LD_ADDR_VAR 0 4
18304: PUSH
18305: LD_INT 1
18307: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18308: LD_ADDR_VAR 0 8
18312: PUSH
18313: LD_VAR 0 1
18317: PPUSH
18318: CALL 18005 0 1
18322: ST_TO_ADDR
// if tmp then
18323: LD_VAR 0 8
18327: IFFALSE 18370
// begin for i in tmp do
18329: LD_ADDR_VAR 0 7
18333: PUSH
18334: LD_VAR 0 8
18338: PUSH
18339: FOR_IN
18340: IFFALSE 18368
// if i [ 1 ] = b_ext_radio then
18342: LD_VAR 0 7
18346: PUSH
18347: LD_INT 1
18349: ARRAY
18350: PUSH
18351: LD_INT 22
18353: EQUAL
18354: IFFALSE 18366
// begin control := control_remote ;
18356: LD_ADDR_VAR 0 4
18360: PUSH
18361: LD_INT 2
18363: ST_TO_ADDR
// break ;
18364: GO 18368
// end ;
18366: GO 18339
18368: POP
18369: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18370: LD_VAR 0 1
18374: PPUSH
18375: LD_VAR 0 2
18379: PPUSH
18380: LD_VAR 0 3
18384: PPUSH
18385: LD_VAR 0 4
18389: PPUSH
18390: LD_VAR 0 5
18394: PPUSH
18395: CALL_OW 448
18399: IFFALSE 18434
// begin result := [ chassis , engine , control , weapon ] ;
18401: LD_ADDR_VAR 0 6
18405: PUSH
18406: LD_VAR 0 2
18410: PUSH
18411: LD_VAR 0 3
18415: PUSH
18416: LD_VAR 0 4
18420: PUSH
18421: LD_VAR 0 5
18425: PUSH
18426: EMPTY
18427: LIST
18428: LIST
18429: LIST
18430: LIST
18431: ST_TO_ADDR
// exit ;
18432: GO 18785
// end ; _chassis := AvailableChassisList ( factory ) ;
18434: LD_ADDR_VAR 0 9
18438: PUSH
18439: LD_VAR 0 1
18443: PPUSH
18444: CALL_OW 475
18448: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18449: LD_ADDR_VAR 0 11
18453: PUSH
18454: LD_VAR 0 1
18458: PPUSH
18459: CALL_OW 476
18463: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18464: LD_ADDR_VAR 0 12
18468: PUSH
18469: LD_VAR 0 1
18473: PPUSH
18474: CALL_OW 477
18478: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18479: LD_ADDR_VAR 0 10
18483: PUSH
18484: LD_VAR 0 1
18488: PPUSH
18489: CALL_OW 478
18493: ST_TO_ADDR
// if not chassis in _chassis then
18494: LD_VAR 0 2
18498: PUSH
18499: LD_VAR 0 9
18503: IN
18504: NOT
18505: IFFALSE 18531
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18507: LD_ADDR_VAR 0 2
18511: PUSH
18512: LD_VAR 0 9
18516: PUSH
18517: LD_INT 1
18519: PPUSH
18520: LD_VAR 0 9
18524: PPUSH
18525: CALL_OW 12
18529: ARRAY
18530: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18531: LD_VAR 0 2
18535: PPUSH
18536: LD_VAR 0 3
18540: PPUSH
18541: CALL 18790 0 2
18545: NOT
18546: IFFALSE 18605
// repeat engine := _engine [ 1 ] ;
18548: LD_ADDR_VAR 0 3
18552: PUSH
18553: LD_VAR 0 11
18557: PUSH
18558: LD_INT 1
18560: ARRAY
18561: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18562: LD_ADDR_VAR 0 11
18566: PUSH
18567: LD_VAR 0 11
18571: PPUSH
18572: LD_INT 1
18574: PPUSH
18575: CALL_OW 3
18579: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18580: LD_VAR 0 2
18584: PPUSH
18585: LD_VAR 0 3
18589: PPUSH
18590: CALL 18790 0 2
18594: PUSH
18595: LD_VAR 0 11
18599: PUSH
18600: EMPTY
18601: EQUAL
18602: OR
18603: IFFALSE 18548
// if not control in _control then
18605: LD_VAR 0 4
18609: PUSH
18610: LD_VAR 0 12
18614: IN
18615: NOT
18616: IFFALSE 18642
// control := _control [ rand ( 1 , _control ) ] ;
18618: LD_ADDR_VAR 0 4
18622: PUSH
18623: LD_VAR 0 12
18627: PUSH
18628: LD_INT 1
18630: PPUSH
18631: LD_VAR 0 12
18635: PPUSH
18636: CALL_OW 12
18640: ARRAY
18641: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18642: LD_VAR 0 2
18646: PPUSH
18647: LD_VAR 0 5
18651: PPUSH
18652: CALL 19010 0 2
18656: NOT
18657: IFFALSE 18716
// repeat weapon := _weapon [ 1 ] ;
18659: LD_ADDR_VAR 0 5
18663: PUSH
18664: LD_VAR 0 10
18668: PUSH
18669: LD_INT 1
18671: ARRAY
18672: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18673: LD_ADDR_VAR 0 10
18677: PUSH
18678: LD_VAR 0 10
18682: PPUSH
18683: LD_INT 1
18685: PPUSH
18686: CALL_OW 3
18690: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18691: LD_VAR 0 2
18695: PPUSH
18696: LD_VAR 0 5
18700: PPUSH
18701: CALL 19010 0 2
18705: PUSH
18706: LD_VAR 0 10
18710: PUSH
18711: EMPTY
18712: EQUAL
18713: OR
18714: IFFALSE 18659
// result := [ ] ;
18716: LD_ADDR_VAR 0 6
18720: PUSH
18721: EMPTY
18722: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18723: LD_VAR 0 1
18727: PPUSH
18728: LD_VAR 0 2
18732: PPUSH
18733: LD_VAR 0 3
18737: PPUSH
18738: LD_VAR 0 4
18742: PPUSH
18743: LD_VAR 0 5
18747: PPUSH
18748: CALL_OW 448
18752: IFFALSE 18785
// result := [ chassis , engine , control , weapon ] ;
18754: LD_ADDR_VAR 0 6
18758: PUSH
18759: LD_VAR 0 2
18763: PUSH
18764: LD_VAR 0 3
18768: PUSH
18769: LD_VAR 0 4
18773: PUSH
18774: LD_VAR 0 5
18778: PUSH
18779: EMPTY
18780: LIST
18781: LIST
18782: LIST
18783: LIST
18784: ST_TO_ADDR
// end ;
18785: LD_VAR 0 6
18789: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18790: LD_INT 0
18792: PPUSH
// if not chassis or not engine then
18793: LD_VAR 0 1
18797: NOT
18798: PUSH
18799: LD_VAR 0 2
18803: NOT
18804: OR
18805: IFFALSE 18809
// exit ;
18807: GO 19005
// case engine of engine_solar :
18809: LD_VAR 0 2
18813: PUSH
18814: LD_INT 2
18816: DOUBLE
18817: EQUAL
18818: IFTRUE 18822
18820: GO 18860
18822: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18823: LD_ADDR_VAR 0 3
18827: PUSH
18828: LD_INT 11
18830: PUSH
18831: LD_INT 12
18833: PUSH
18834: LD_INT 13
18836: PUSH
18837: LD_INT 14
18839: PUSH
18840: LD_INT 1
18842: PUSH
18843: LD_INT 2
18845: PUSH
18846: LD_INT 3
18848: PUSH
18849: EMPTY
18850: LIST
18851: LIST
18852: LIST
18853: LIST
18854: LIST
18855: LIST
18856: LIST
18857: ST_TO_ADDR
18858: GO 18989
18860: LD_INT 1
18862: DOUBLE
18863: EQUAL
18864: IFTRUE 18868
18866: GO 18930
18868: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18869: LD_ADDR_VAR 0 3
18873: PUSH
18874: LD_INT 11
18876: PUSH
18877: LD_INT 12
18879: PUSH
18880: LD_INT 13
18882: PUSH
18883: LD_INT 14
18885: PUSH
18886: LD_INT 1
18888: PUSH
18889: LD_INT 2
18891: PUSH
18892: LD_INT 3
18894: PUSH
18895: LD_INT 4
18897: PUSH
18898: LD_INT 5
18900: PUSH
18901: LD_INT 21
18903: PUSH
18904: LD_INT 23
18906: PUSH
18907: LD_INT 22
18909: PUSH
18910: LD_INT 24
18912: PUSH
18913: EMPTY
18914: LIST
18915: LIST
18916: LIST
18917: LIST
18918: LIST
18919: LIST
18920: LIST
18921: LIST
18922: LIST
18923: LIST
18924: LIST
18925: LIST
18926: LIST
18927: ST_TO_ADDR
18928: GO 18989
18930: LD_INT 3
18932: DOUBLE
18933: EQUAL
18934: IFTRUE 18938
18936: GO 18988
18938: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18939: LD_ADDR_VAR 0 3
18943: PUSH
18944: LD_INT 13
18946: PUSH
18947: LD_INT 14
18949: PUSH
18950: LD_INT 2
18952: PUSH
18953: LD_INT 3
18955: PUSH
18956: LD_INT 4
18958: PUSH
18959: LD_INT 5
18961: PUSH
18962: LD_INT 21
18964: PUSH
18965: LD_INT 22
18967: PUSH
18968: LD_INT 23
18970: PUSH
18971: LD_INT 24
18973: PUSH
18974: EMPTY
18975: LIST
18976: LIST
18977: LIST
18978: LIST
18979: LIST
18980: LIST
18981: LIST
18982: LIST
18983: LIST
18984: LIST
18985: ST_TO_ADDR
18986: GO 18989
18988: POP
// result := ( chassis in result ) ;
18989: LD_ADDR_VAR 0 3
18993: PUSH
18994: LD_VAR 0 1
18998: PUSH
18999: LD_VAR 0 3
19003: IN
19004: ST_TO_ADDR
// end ;
19005: LD_VAR 0 3
19009: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19010: LD_INT 0
19012: PPUSH
// if not chassis or not weapon then
19013: LD_VAR 0 1
19017: NOT
19018: PUSH
19019: LD_VAR 0 2
19023: NOT
19024: OR
19025: IFFALSE 19029
// exit ;
19027: GO 20055
// case weapon of us_machine_gun :
19029: LD_VAR 0 2
19033: PUSH
19034: LD_INT 2
19036: DOUBLE
19037: EQUAL
19038: IFTRUE 19042
19040: GO 19072
19042: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19043: LD_ADDR_VAR 0 3
19047: PUSH
19048: LD_INT 1
19050: PUSH
19051: LD_INT 2
19053: PUSH
19054: LD_INT 3
19056: PUSH
19057: LD_INT 4
19059: PUSH
19060: LD_INT 5
19062: PUSH
19063: EMPTY
19064: LIST
19065: LIST
19066: LIST
19067: LIST
19068: LIST
19069: ST_TO_ADDR
19070: GO 20039
19072: LD_INT 3
19074: DOUBLE
19075: EQUAL
19076: IFTRUE 19080
19078: GO 19110
19080: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19081: LD_ADDR_VAR 0 3
19085: PUSH
19086: LD_INT 1
19088: PUSH
19089: LD_INT 2
19091: PUSH
19092: LD_INT 3
19094: PUSH
19095: LD_INT 4
19097: PUSH
19098: LD_INT 5
19100: PUSH
19101: EMPTY
19102: LIST
19103: LIST
19104: LIST
19105: LIST
19106: LIST
19107: ST_TO_ADDR
19108: GO 20039
19110: LD_INT 11
19112: DOUBLE
19113: EQUAL
19114: IFTRUE 19118
19116: GO 19148
19118: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19119: LD_ADDR_VAR 0 3
19123: PUSH
19124: LD_INT 1
19126: PUSH
19127: LD_INT 2
19129: PUSH
19130: LD_INT 3
19132: PUSH
19133: LD_INT 4
19135: PUSH
19136: LD_INT 5
19138: PUSH
19139: EMPTY
19140: LIST
19141: LIST
19142: LIST
19143: LIST
19144: LIST
19145: ST_TO_ADDR
19146: GO 20039
19148: LD_INT 4
19150: DOUBLE
19151: EQUAL
19152: IFTRUE 19156
19154: GO 19182
19156: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19157: LD_ADDR_VAR 0 3
19161: PUSH
19162: LD_INT 2
19164: PUSH
19165: LD_INT 3
19167: PUSH
19168: LD_INT 4
19170: PUSH
19171: LD_INT 5
19173: PUSH
19174: EMPTY
19175: LIST
19176: LIST
19177: LIST
19178: LIST
19179: ST_TO_ADDR
19180: GO 20039
19182: LD_INT 5
19184: DOUBLE
19185: EQUAL
19186: IFTRUE 19190
19188: GO 19216
19190: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19191: LD_ADDR_VAR 0 3
19195: PUSH
19196: LD_INT 2
19198: PUSH
19199: LD_INT 3
19201: PUSH
19202: LD_INT 4
19204: PUSH
19205: LD_INT 5
19207: PUSH
19208: EMPTY
19209: LIST
19210: LIST
19211: LIST
19212: LIST
19213: ST_TO_ADDR
19214: GO 20039
19216: LD_INT 9
19218: DOUBLE
19219: EQUAL
19220: IFTRUE 19224
19222: GO 19250
19224: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19225: LD_ADDR_VAR 0 3
19229: PUSH
19230: LD_INT 2
19232: PUSH
19233: LD_INT 3
19235: PUSH
19236: LD_INT 4
19238: PUSH
19239: LD_INT 5
19241: PUSH
19242: EMPTY
19243: LIST
19244: LIST
19245: LIST
19246: LIST
19247: ST_TO_ADDR
19248: GO 20039
19250: LD_INT 7
19252: DOUBLE
19253: EQUAL
19254: IFTRUE 19258
19256: GO 19284
19258: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19259: LD_ADDR_VAR 0 3
19263: PUSH
19264: LD_INT 2
19266: PUSH
19267: LD_INT 3
19269: PUSH
19270: LD_INT 4
19272: PUSH
19273: LD_INT 5
19275: PUSH
19276: EMPTY
19277: LIST
19278: LIST
19279: LIST
19280: LIST
19281: ST_TO_ADDR
19282: GO 20039
19284: LD_INT 12
19286: DOUBLE
19287: EQUAL
19288: IFTRUE 19292
19290: GO 19318
19292: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
19293: LD_ADDR_VAR 0 3
19297: PUSH
19298: LD_INT 2
19300: PUSH
19301: LD_INT 3
19303: PUSH
19304: LD_INT 4
19306: PUSH
19307: LD_INT 5
19309: PUSH
19310: EMPTY
19311: LIST
19312: LIST
19313: LIST
19314: LIST
19315: ST_TO_ADDR
19316: GO 20039
19318: LD_INT 13
19320: DOUBLE
19321: EQUAL
19322: IFTRUE 19326
19324: GO 19352
19326: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
19327: LD_ADDR_VAR 0 3
19331: PUSH
19332: LD_INT 2
19334: PUSH
19335: LD_INT 3
19337: PUSH
19338: LD_INT 4
19340: PUSH
19341: LD_INT 5
19343: PUSH
19344: EMPTY
19345: LIST
19346: LIST
19347: LIST
19348: LIST
19349: ST_TO_ADDR
19350: GO 20039
19352: LD_INT 14
19354: DOUBLE
19355: EQUAL
19356: IFTRUE 19360
19358: GO 19378
19360: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
19361: LD_ADDR_VAR 0 3
19365: PUSH
19366: LD_INT 4
19368: PUSH
19369: LD_INT 5
19371: PUSH
19372: EMPTY
19373: LIST
19374: LIST
19375: ST_TO_ADDR
19376: GO 20039
19378: LD_INT 6
19380: DOUBLE
19381: EQUAL
19382: IFTRUE 19386
19384: GO 19404
19386: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19387: LD_ADDR_VAR 0 3
19391: PUSH
19392: LD_INT 4
19394: PUSH
19395: LD_INT 5
19397: PUSH
19398: EMPTY
19399: LIST
19400: LIST
19401: ST_TO_ADDR
19402: GO 20039
19404: LD_INT 10
19406: DOUBLE
19407: EQUAL
19408: IFTRUE 19412
19410: GO 19430
19412: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19413: LD_ADDR_VAR 0 3
19417: PUSH
19418: LD_INT 4
19420: PUSH
19421: LD_INT 5
19423: PUSH
19424: EMPTY
19425: LIST
19426: LIST
19427: ST_TO_ADDR
19428: GO 20039
19430: LD_INT 22
19432: DOUBLE
19433: EQUAL
19434: IFTRUE 19438
19436: GO 19464
19438: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19439: LD_ADDR_VAR 0 3
19443: PUSH
19444: LD_INT 11
19446: PUSH
19447: LD_INT 12
19449: PUSH
19450: LD_INT 13
19452: PUSH
19453: LD_INT 14
19455: PUSH
19456: EMPTY
19457: LIST
19458: LIST
19459: LIST
19460: LIST
19461: ST_TO_ADDR
19462: GO 20039
19464: LD_INT 23
19466: DOUBLE
19467: EQUAL
19468: IFTRUE 19472
19470: GO 19498
19472: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19473: LD_ADDR_VAR 0 3
19477: PUSH
19478: LD_INT 11
19480: PUSH
19481: LD_INT 12
19483: PUSH
19484: LD_INT 13
19486: PUSH
19487: LD_INT 14
19489: PUSH
19490: EMPTY
19491: LIST
19492: LIST
19493: LIST
19494: LIST
19495: ST_TO_ADDR
19496: GO 20039
19498: LD_INT 24
19500: DOUBLE
19501: EQUAL
19502: IFTRUE 19506
19504: GO 19532
19506: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19507: LD_ADDR_VAR 0 3
19511: PUSH
19512: LD_INT 11
19514: PUSH
19515: LD_INT 12
19517: PUSH
19518: LD_INT 13
19520: PUSH
19521: LD_INT 14
19523: PUSH
19524: EMPTY
19525: LIST
19526: LIST
19527: LIST
19528: LIST
19529: ST_TO_ADDR
19530: GO 20039
19532: LD_INT 30
19534: DOUBLE
19535: EQUAL
19536: IFTRUE 19540
19538: GO 19566
19540: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19541: LD_ADDR_VAR 0 3
19545: PUSH
19546: LD_INT 11
19548: PUSH
19549: LD_INT 12
19551: PUSH
19552: LD_INT 13
19554: PUSH
19555: LD_INT 14
19557: PUSH
19558: EMPTY
19559: LIST
19560: LIST
19561: LIST
19562: LIST
19563: ST_TO_ADDR
19564: GO 20039
19566: LD_INT 25
19568: DOUBLE
19569: EQUAL
19570: IFTRUE 19574
19572: GO 19592
19574: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19575: LD_ADDR_VAR 0 3
19579: PUSH
19580: LD_INT 13
19582: PUSH
19583: LD_INT 14
19585: PUSH
19586: EMPTY
19587: LIST
19588: LIST
19589: ST_TO_ADDR
19590: GO 20039
19592: LD_INT 27
19594: DOUBLE
19595: EQUAL
19596: IFTRUE 19600
19598: GO 19618
19600: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19601: LD_ADDR_VAR 0 3
19605: PUSH
19606: LD_INT 13
19608: PUSH
19609: LD_INT 14
19611: PUSH
19612: EMPTY
19613: LIST
19614: LIST
19615: ST_TO_ADDR
19616: GO 20039
19618: LD_INT 28
19620: DOUBLE
19621: EQUAL
19622: IFTRUE 19626
19624: GO 19644
19626: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19627: LD_ADDR_VAR 0 3
19631: PUSH
19632: LD_INT 13
19634: PUSH
19635: LD_INT 14
19637: PUSH
19638: EMPTY
19639: LIST
19640: LIST
19641: ST_TO_ADDR
19642: GO 20039
19644: LD_INT 29
19646: DOUBLE
19647: EQUAL
19648: IFTRUE 19652
19650: GO 19670
19652: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19653: LD_ADDR_VAR 0 3
19657: PUSH
19658: LD_INT 13
19660: PUSH
19661: LD_INT 14
19663: PUSH
19664: EMPTY
19665: LIST
19666: LIST
19667: ST_TO_ADDR
19668: GO 20039
19670: LD_INT 31
19672: DOUBLE
19673: EQUAL
19674: IFTRUE 19678
19676: GO 19696
19678: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19679: LD_ADDR_VAR 0 3
19683: PUSH
19684: LD_INT 13
19686: PUSH
19687: LD_INT 14
19689: PUSH
19690: EMPTY
19691: LIST
19692: LIST
19693: ST_TO_ADDR
19694: GO 20039
19696: LD_INT 26
19698: DOUBLE
19699: EQUAL
19700: IFTRUE 19704
19702: GO 19722
19704: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19705: LD_ADDR_VAR 0 3
19709: PUSH
19710: LD_INT 13
19712: PUSH
19713: LD_INT 14
19715: PUSH
19716: EMPTY
19717: LIST
19718: LIST
19719: ST_TO_ADDR
19720: GO 20039
19722: LD_INT 42
19724: DOUBLE
19725: EQUAL
19726: IFTRUE 19730
19728: GO 19756
19730: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19731: LD_ADDR_VAR 0 3
19735: PUSH
19736: LD_INT 21
19738: PUSH
19739: LD_INT 22
19741: PUSH
19742: LD_INT 23
19744: PUSH
19745: LD_INT 24
19747: PUSH
19748: EMPTY
19749: LIST
19750: LIST
19751: LIST
19752: LIST
19753: ST_TO_ADDR
19754: GO 20039
19756: LD_INT 43
19758: DOUBLE
19759: EQUAL
19760: IFTRUE 19764
19762: GO 19790
19764: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19765: LD_ADDR_VAR 0 3
19769: PUSH
19770: LD_INT 21
19772: PUSH
19773: LD_INT 22
19775: PUSH
19776: LD_INT 23
19778: PUSH
19779: LD_INT 24
19781: PUSH
19782: EMPTY
19783: LIST
19784: LIST
19785: LIST
19786: LIST
19787: ST_TO_ADDR
19788: GO 20039
19790: LD_INT 44
19792: DOUBLE
19793: EQUAL
19794: IFTRUE 19798
19796: GO 19824
19798: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19799: LD_ADDR_VAR 0 3
19803: PUSH
19804: LD_INT 21
19806: PUSH
19807: LD_INT 22
19809: PUSH
19810: LD_INT 23
19812: PUSH
19813: LD_INT 24
19815: PUSH
19816: EMPTY
19817: LIST
19818: LIST
19819: LIST
19820: LIST
19821: ST_TO_ADDR
19822: GO 20039
19824: LD_INT 45
19826: DOUBLE
19827: EQUAL
19828: IFTRUE 19832
19830: GO 19858
19832: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19833: LD_ADDR_VAR 0 3
19837: PUSH
19838: LD_INT 21
19840: PUSH
19841: LD_INT 22
19843: PUSH
19844: LD_INT 23
19846: PUSH
19847: LD_INT 24
19849: PUSH
19850: EMPTY
19851: LIST
19852: LIST
19853: LIST
19854: LIST
19855: ST_TO_ADDR
19856: GO 20039
19858: LD_INT 49
19860: DOUBLE
19861: EQUAL
19862: IFTRUE 19866
19864: GO 19892
19866: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19867: LD_ADDR_VAR 0 3
19871: PUSH
19872: LD_INT 21
19874: PUSH
19875: LD_INT 22
19877: PUSH
19878: LD_INT 23
19880: PUSH
19881: LD_INT 24
19883: PUSH
19884: EMPTY
19885: LIST
19886: LIST
19887: LIST
19888: LIST
19889: ST_TO_ADDR
19890: GO 20039
19892: LD_INT 51
19894: DOUBLE
19895: EQUAL
19896: IFTRUE 19900
19898: GO 19926
19900: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19901: LD_ADDR_VAR 0 3
19905: PUSH
19906: LD_INT 21
19908: PUSH
19909: LD_INT 22
19911: PUSH
19912: LD_INT 23
19914: PUSH
19915: LD_INT 24
19917: PUSH
19918: EMPTY
19919: LIST
19920: LIST
19921: LIST
19922: LIST
19923: ST_TO_ADDR
19924: GO 20039
19926: LD_INT 52
19928: DOUBLE
19929: EQUAL
19930: IFTRUE 19934
19932: GO 19960
19934: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19935: LD_ADDR_VAR 0 3
19939: PUSH
19940: LD_INT 21
19942: PUSH
19943: LD_INT 22
19945: PUSH
19946: LD_INT 23
19948: PUSH
19949: LD_INT 24
19951: PUSH
19952: EMPTY
19953: LIST
19954: LIST
19955: LIST
19956: LIST
19957: ST_TO_ADDR
19958: GO 20039
19960: LD_INT 53
19962: DOUBLE
19963: EQUAL
19964: IFTRUE 19968
19966: GO 19986
19968: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19969: LD_ADDR_VAR 0 3
19973: PUSH
19974: LD_INT 23
19976: PUSH
19977: LD_INT 24
19979: PUSH
19980: EMPTY
19981: LIST
19982: LIST
19983: ST_TO_ADDR
19984: GO 20039
19986: LD_INT 46
19988: DOUBLE
19989: EQUAL
19990: IFTRUE 19994
19992: GO 20012
19994: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19995: LD_ADDR_VAR 0 3
19999: PUSH
20000: LD_INT 23
20002: PUSH
20003: LD_INT 24
20005: PUSH
20006: EMPTY
20007: LIST
20008: LIST
20009: ST_TO_ADDR
20010: GO 20039
20012: LD_INT 47
20014: DOUBLE
20015: EQUAL
20016: IFTRUE 20020
20018: GO 20038
20020: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20021: LD_ADDR_VAR 0 3
20025: PUSH
20026: LD_INT 23
20028: PUSH
20029: LD_INT 24
20031: PUSH
20032: EMPTY
20033: LIST
20034: LIST
20035: ST_TO_ADDR
20036: GO 20039
20038: POP
// result := ( chassis in result ) ;
20039: LD_ADDR_VAR 0 3
20043: PUSH
20044: LD_VAR 0 1
20048: PUSH
20049: LD_VAR 0 3
20053: IN
20054: ST_TO_ADDR
// end ;
20055: LD_VAR 0 3
20059: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20060: LD_INT 0
20062: PPUSH
20063: PPUSH
20064: PPUSH
20065: PPUSH
20066: PPUSH
20067: PPUSH
20068: PPUSH
// result := array ;
20069: LD_ADDR_VAR 0 5
20073: PUSH
20074: LD_VAR 0 1
20078: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20079: LD_VAR 0 1
20083: NOT
20084: PUSH
20085: LD_VAR 0 2
20089: NOT
20090: OR
20091: PUSH
20092: LD_VAR 0 3
20096: NOT
20097: OR
20098: PUSH
20099: LD_VAR 0 2
20103: PUSH
20104: LD_VAR 0 1
20108: GREATER
20109: OR
20110: PUSH
20111: LD_VAR 0 3
20115: PUSH
20116: LD_VAR 0 1
20120: GREATER
20121: OR
20122: IFFALSE 20126
// exit ;
20124: GO 20422
// if direction then
20126: LD_VAR 0 4
20130: IFFALSE 20194
// begin d := 1 ;
20132: LD_ADDR_VAR 0 9
20136: PUSH
20137: LD_INT 1
20139: ST_TO_ADDR
// if i_from > i_to then
20140: LD_VAR 0 2
20144: PUSH
20145: LD_VAR 0 3
20149: GREATER
20150: IFFALSE 20176
// length := ( array - i_from ) + i_to else
20152: LD_ADDR_VAR 0 11
20156: PUSH
20157: LD_VAR 0 1
20161: PUSH
20162: LD_VAR 0 2
20166: MINUS
20167: PUSH
20168: LD_VAR 0 3
20172: PLUS
20173: ST_TO_ADDR
20174: GO 20192
// length := i_to - i_from ;
20176: LD_ADDR_VAR 0 11
20180: PUSH
20181: LD_VAR 0 3
20185: PUSH
20186: LD_VAR 0 2
20190: MINUS
20191: ST_TO_ADDR
// end else
20192: GO 20255
// begin d := - 1 ;
20194: LD_ADDR_VAR 0 9
20198: PUSH
20199: LD_INT 1
20201: NEG
20202: ST_TO_ADDR
// if i_from > i_to then
20203: LD_VAR 0 2
20207: PUSH
20208: LD_VAR 0 3
20212: GREATER
20213: IFFALSE 20233
// length := i_from - i_to else
20215: LD_ADDR_VAR 0 11
20219: PUSH
20220: LD_VAR 0 2
20224: PUSH
20225: LD_VAR 0 3
20229: MINUS
20230: ST_TO_ADDR
20231: GO 20255
// length := ( array - i_to ) + i_from ;
20233: LD_ADDR_VAR 0 11
20237: PUSH
20238: LD_VAR 0 1
20242: PUSH
20243: LD_VAR 0 3
20247: MINUS
20248: PUSH
20249: LD_VAR 0 2
20253: PLUS
20254: ST_TO_ADDR
// end ; if not length then
20255: LD_VAR 0 11
20259: NOT
20260: IFFALSE 20264
// exit ;
20262: GO 20422
// tmp := array ;
20264: LD_ADDR_VAR 0 10
20268: PUSH
20269: LD_VAR 0 1
20273: ST_TO_ADDR
// for i = 1 to length do
20274: LD_ADDR_VAR 0 6
20278: PUSH
20279: DOUBLE
20280: LD_INT 1
20282: DEC
20283: ST_TO_ADDR
20284: LD_VAR 0 11
20288: PUSH
20289: FOR_TO
20290: IFFALSE 20410
// begin for j = 1 to array do
20292: LD_ADDR_VAR 0 7
20296: PUSH
20297: DOUBLE
20298: LD_INT 1
20300: DEC
20301: ST_TO_ADDR
20302: LD_VAR 0 1
20306: PUSH
20307: FOR_TO
20308: IFFALSE 20396
// begin k := j + d ;
20310: LD_ADDR_VAR 0 8
20314: PUSH
20315: LD_VAR 0 7
20319: PUSH
20320: LD_VAR 0 9
20324: PLUS
20325: ST_TO_ADDR
// if k > array then
20326: LD_VAR 0 8
20330: PUSH
20331: LD_VAR 0 1
20335: GREATER
20336: IFFALSE 20346
// k := 1 ;
20338: LD_ADDR_VAR 0 8
20342: PUSH
20343: LD_INT 1
20345: ST_TO_ADDR
// if not k then
20346: LD_VAR 0 8
20350: NOT
20351: IFFALSE 20363
// k := array ;
20353: LD_ADDR_VAR 0 8
20357: PUSH
20358: LD_VAR 0 1
20362: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
20363: LD_ADDR_VAR 0 10
20367: PUSH
20368: LD_VAR 0 10
20372: PPUSH
20373: LD_VAR 0 8
20377: PPUSH
20378: LD_VAR 0 1
20382: PUSH
20383: LD_VAR 0 7
20387: ARRAY
20388: PPUSH
20389: CALL_OW 1
20393: ST_TO_ADDR
// end ;
20394: GO 20307
20396: POP
20397: POP
// array := tmp ;
20398: LD_ADDR_VAR 0 1
20402: PUSH
20403: LD_VAR 0 10
20407: ST_TO_ADDR
// end ;
20408: GO 20289
20410: POP
20411: POP
// result := array ;
20412: LD_ADDR_VAR 0 5
20416: PUSH
20417: LD_VAR 0 1
20421: ST_TO_ADDR
// end ;
20422: LD_VAR 0 5
20426: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20427: LD_INT 0
20429: PPUSH
20430: PPUSH
// result := 0 ;
20431: LD_ADDR_VAR 0 3
20435: PUSH
20436: LD_INT 0
20438: ST_TO_ADDR
// if not array or not value in array then
20439: LD_VAR 0 1
20443: NOT
20444: PUSH
20445: LD_VAR 0 2
20449: PUSH
20450: LD_VAR 0 1
20454: IN
20455: NOT
20456: OR
20457: IFFALSE 20461
// exit ;
20459: GO 20515
// for i = 1 to array do
20461: LD_ADDR_VAR 0 4
20465: PUSH
20466: DOUBLE
20467: LD_INT 1
20469: DEC
20470: ST_TO_ADDR
20471: LD_VAR 0 1
20475: PUSH
20476: FOR_TO
20477: IFFALSE 20513
// if value = array [ i ] then
20479: LD_VAR 0 2
20483: PUSH
20484: LD_VAR 0 1
20488: PUSH
20489: LD_VAR 0 4
20493: ARRAY
20494: EQUAL
20495: IFFALSE 20511
// begin result := i ;
20497: LD_ADDR_VAR 0 3
20501: PUSH
20502: LD_VAR 0 4
20506: ST_TO_ADDR
// exit ;
20507: POP
20508: POP
20509: GO 20515
// end ;
20511: GO 20476
20513: POP
20514: POP
// end ;
20515: LD_VAR 0 3
20519: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20520: LD_INT 0
20522: PPUSH
// vc_chassis := chassis ;
20523: LD_ADDR_OWVAR 37
20527: PUSH
20528: LD_VAR 0 1
20532: ST_TO_ADDR
// vc_engine := engine ;
20533: LD_ADDR_OWVAR 39
20537: PUSH
20538: LD_VAR 0 2
20542: ST_TO_ADDR
// vc_control := control ;
20543: LD_ADDR_OWVAR 38
20547: PUSH
20548: LD_VAR 0 3
20552: ST_TO_ADDR
// vc_weapon := weapon ;
20553: LD_ADDR_OWVAR 40
20557: PUSH
20558: LD_VAR 0 4
20562: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20563: LD_ADDR_OWVAR 41
20567: PUSH
20568: LD_VAR 0 5
20572: ST_TO_ADDR
// end ;
20573: LD_VAR 0 6
20577: RET
// export function WantPlant ( unit ) ; var task ; begin
20578: LD_INT 0
20580: PPUSH
20581: PPUSH
// result := false ;
20582: LD_ADDR_VAR 0 2
20586: PUSH
20587: LD_INT 0
20589: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20590: LD_ADDR_VAR 0 3
20594: PUSH
20595: LD_VAR 0 1
20599: PPUSH
20600: CALL_OW 437
20604: ST_TO_ADDR
// if task then
20605: LD_VAR 0 3
20609: IFFALSE 20637
// if task [ 1 ] [ 1 ] = p then
20611: LD_VAR 0 3
20615: PUSH
20616: LD_INT 1
20618: ARRAY
20619: PUSH
20620: LD_INT 1
20622: ARRAY
20623: PUSH
20624: LD_STRING p
20626: EQUAL
20627: IFFALSE 20637
// result := true ;
20629: LD_ADDR_VAR 0 2
20633: PUSH
20634: LD_INT 1
20636: ST_TO_ADDR
// end ;
20637: LD_VAR 0 2
20641: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20642: LD_INT 0
20644: PPUSH
20645: PPUSH
20646: PPUSH
20647: PPUSH
// if pos < 1 then
20648: LD_VAR 0 2
20652: PUSH
20653: LD_INT 1
20655: LESS
20656: IFFALSE 20660
// exit ;
20658: GO 20963
// if pos = 1 then
20660: LD_VAR 0 2
20664: PUSH
20665: LD_INT 1
20667: EQUAL
20668: IFFALSE 20701
// result := Replace ( arr , pos [ 1 ] , value ) else
20670: LD_ADDR_VAR 0 4
20674: PUSH
20675: LD_VAR 0 1
20679: PPUSH
20680: LD_VAR 0 2
20684: PUSH
20685: LD_INT 1
20687: ARRAY
20688: PPUSH
20689: LD_VAR 0 3
20693: PPUSH
20694: CALL_OW 1
20698: ST_TO_ADDR
20699: GO 20963
// begin tmp := arr ;
20701: LD_ADDR_VAR 0 6
20705: PUSH
20706: LD_VAR 0 1
20710: ST_TO_ADDR
// s_arr := [ tmp ] ;
20711: LD_ADDR_VAR 0 7
20715: PUSH
20716: LD_VAR 0 6
20720: PUSH
20721: EMPTY
20722: LIST
20723: ST_TO_ADDR
// for i = 1 to pos - 1 do
20724: LD_ADDR_VAR 0 5
20728: PUSH
20729: DOUBLE
20730: LD_INT 1
20732: DEC
20733: ST_TO_ADDR
20734: LD_VAR 0 2
20738: PUSH
20739: LD_INT 1
20741: MINUS
20742: PUSH
20743: FOR_TO
20744: IFFALSE 20789
// begin tmp := tmp [ pos [ i ] ] ;
20746: LD_ADDR_VAR 0 6
20750: PUSH
20751: LD_VAR 0 6
20755: PUSH
20756: LD_VAR 0 2
20760: PUSH
20761: LD_VAR 0 5
20765: ARRAY
20766: ARRAY
20767: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20768: LD_ADDR_VAR 0 7
20772: PUSH
20773: LD_VAR 0 7
20777: PUSH
20778: LD_VAR 0 6
20782: PUSH
20783: EMPTY
20784: LIST
20785: ADD
20786: ST_TO_ADDR
// end ;
20787: GO 20743
20789: POP
20790: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20791: LD_ADDR_VAR 0 6
20795: PUSH
20796: LD_VAR 0 6
20800: PPUSH
20801: LD_VAR 0 2
20805: PUSH
20806: LD_VAR 0 2
20810: ARRAY
20811: PPUSH
20812: LD_VAR 0 3
20816: PPUSH
20817: CALL_OW 1
20821: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20822: LD_ADDR_VAR 0 7
20826: PUSH
20827: LD_VAR 0 7
20831: PPUSH
20832: LD_VAR 0 7
20836: PPUSH
20837: LD_VAR 0 6
20841: PPUSH
20842: CALL_OW 1
20846: ST_TO_ADDR
// for i = s_arr downto 2 do
20847: LD_ADDR_VAR 0 5
20851: PUSH
20852: DOUBLE
20853: LD_VAR 0 7
20857: INC
20858: ST_TO_ADDR
20859: LD_INT 2
20861: PUSH
20862: FOR_DOWNTO
20863: IFFALSE 20947
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20865: LD_ADDR_VAR 0 6
20869: PUSH
20870: LD_VAR 0 7
20874: PUSH
20875: LD_VAR 0 5
20879: PUSH
20880: LD_INT 1
20882: MINUS
20883: ARRAY
20884: PPUSH
20885: LD_VAR 0 2
20889: PUSH
20890: LD_VAR 0 5
20894: PUSH
20895: LD_INT 1
20897: MINUS
20898: ARRAY
20899: PPUSH
20900: LD_VAR 0 7
20904: PUSH
20905: LD_VAR 0 5
20909: ARRAY
20910: PPUSH
20911: CALL_OW 1
20915: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20916: LD_ADDR_VAR 0 7
20920: PUSH
20921: LD_VAR 0 7
20925: PPUSH
20926: LD_VAR 0 5
20930: PUSH
20931: LD_INT 1
20933: MINUS
20934: PPUSH
20935: LD_VAR 0 6
20939: PPUSH
20940: CALL_OW 1
20944: ST_TO_ADDR
// end ;
20945: GO 20862
20947: POP
20948: POP
// result := s_arr [ 1 ] ;
20949: LD_ADDR_VAR 0 4
20953: PUSH
20954: LD_VAR 0 7
20958: PUSH
20959: LD_INT 1
20961: ARRAY
20962: ST_TO_ADDR
// end ; end ;
20963: LD_VAR 0 4
20967: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20968: LD_INT 0
20970: PPUSH
20971: PPUSH
// if not list then
20972: LD_VAR 0 1
20976: NOT
20977: IFFALSE 20981
// exit ;
20979: GO 21072
// i := list [ pos1 ] ;
20981: LD_ADDR_VAR 0 5
20985: PUSH
20986: LD_VAR 0 1
20990: PUSH
20991: LD_VAR 0 2
20995: ARRAY
20996: ST_TO_ADDR
// if not i then
20997: LD_VAR 0 5
21001: NOT
21002: IFFALSE 21006
// exit ;
21004: GO 21072
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21006: LD_ADDR_VAR 0 1
21010: PUSH
21011: LD_VAR 0 1
21015: PPUSH
21016: LD_VAR 0 2
21020: PPUSH
21021: LD_VAR 0 1
21025: PUSH
21026: LD_VAR 0 3
21030: ARRAY
21031: PPUSH
21032: CALL_OW 1
21036: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21037: LD_ADDR_VAR 0 1
21041: PUSH
21042: LD_VAR 0 1
21046: PPUSH
21047: LD_VAR 0 3
21051: PPUSH
21052: LD_VAR 0 5
21056: PPUSH
21057: CALL_OW 1
21061: ST_TO_ADDR
// result := list ;
21062: LD_ADDR_VAR 0 4
21066: PUSH
21067: LD_VAR 0 1
21071: ST_TO_ADDR
// end ;
21072: LD_VAR 0 4
21076: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21077: LD_INT 0
21079: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21080: LD_ADDR_VAR 0 5
21084: PUSH
21085: LD_VAR 0 1
21089: PPUSH
21090: CALL_OW 250
21094: PPUSH
21095: LD_VAR 0 1
21099: PPUSH
21100: CALL_OW 251
21104: PPUSH
21105: LD_VAR 0 2
21109: PPUSH
21110: LD_VAR 0 3
21114: PPUSH
21115: LD_VAR 0 4
21119: PPUSH
21120: CALL 21130 0 5
21124: ST_TO_ADDR
// end ;
21125: LD_VAR 0 5
21129: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
21130: LD_INT 0
21132: PPUSH
21133: PPUSH
21134: PPUSH
21135: PPUSH
// if not list then
21136: LD_VAR 0 3
21140: NOT
21141: IFFALSE 21145
// exit ;
21143: GO 21533
// result := [ ] ;
21145: LD_ADDR_VAR 0 6
21149: PUSH
21150: EMPTY
21151: ST_TO_ADDR
// for i in list do
21152: LD_ADDR_VAR 0 7
21156: PUSH
21157: LD_VAR 0 3
21161: PUSH
21162: FOR_IN
21163: IFFALSE 21365
// begin tmp := GetDistUnitXY ( i , x , y ) ;
21165: LD_ADDR_VAR 0 9
21169: PUSH
21170: LD_VAR 0 7
21174: PPUSH
21175: LD_VAR 0 1
21179: PPUSH
21180: LD_VAR 0 2
21184: PPUSH
21185: CALL_OW 297
21189: ST_TO_ADDR
// if not result then
21190: LD_VAR 0 6
21194: NOT
21195: IFFALSE 21221
// result := [ [ i , tmp ] ] else
21197: LD_ADDR_VAR 0 6
21201: PUSH
21202: LD_VAR 0 7
21206: PUSH
21207: LD_VAR 0 9
21211: PUSH
21212: EMPTY
21213: LIST
21214: LIST
21215: PUSH
21216: EMPTY
21217: LIST
21218: ST_TO_ADDR
21219: GO 21363
// begin if result [ result ] [ 2 ] < tmp then
21221: LD_VAR 0 6
21225: PUSH
21226: LD_VAR 0 6
21230: ARRAY
21231: PUSH
21232: LD_INT 2
21234: ARRAY
21235: PUSH
21236: LD_VAR 0 9
21240: LESS
21241: IFFALSE 21283
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21243: LD_ADDR_VAR 0 6
21247: PUSH
21248: LD_VAR 0 6
21252: PPUSH
21253: LD_VAR 0 6
21257: PUSH
21258: LD_INT 1
21260: PLUS
21261: PPUSH
21262: LD_VAR 0 7
21266: PUSH
21267: LD_VAR 0 9
21271: PUSH
21272: EMPTY
21273: LIST
21274: LIST
21275: PPUSH
21276: CALL_OW 2
21280: ST_TO_ADDR
21281: GO 21363
// for j = 1 to result do
21283: LD_ADDR_VAR 0 8
21287: PUSH
21288: DOUBLE
21289: LD_INT 1
21291: DEC
21292: ST_TO_ADDR
21293: LD_VAR 0 6
21297: PUSH
21298: FOR_TO
21299: IFFALSE 21361
// begin if tmp < result [ j ] [ 2 ] then
21301: LD_VAR 0 9
21305: PUSH
21306: LD_VAR 0 6
21310: PUSH
21311: LD_VAR 0 8
21315: ARRAY
21316: PUSH
21317: LD_INT 2
21319: ARRAY
21320: LESS
21321: IFFALSE 21359
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21323: LD_ADDR_VAR 0 6
21327: PUSH
21328: LD_VAR 0 6
21332: PPUSH
21333: LD_VAR 0 8
21337: PPUSH
21338: LD_VAR 0 7
21342: PUSH
21343: LD_VAR 0 9
21347: PUSH
21348: EMPTY
21349: LIST
21350: LIST
21351: PPUSH
21352: CALL_OW 2
21356: ST_TO_ADDR
// break ;
21357: GO 21361
// end ; end ;
21359: GO 21298
21361: POP
21362: POP
// end ; end ;
21363: GO 21162
21365: POP
21366: POP
// if result and not asc then
21367: LD_VAR 0 6
21371: PUSH
21372: LD_VAR 0 4
21376: NOT
21377: AND
21378: IFFALSE 21453
// begin tmp := result ;
21380: LD_ADDR_VAR 0 9
21384: PUSH
21385: LD_VAR 0 6
21389: ST_TO_ADDR
// for i = tmp downto 1 do
21390: LD_ADDR_VAR 0 7
21394: PUSH
21395: DOUBLE
21396: LD_VAR 0 9
21400: INC
21401: ST_TO_ADDR
21402: LD_INT 1
21404: PUSH
21405: FOR_DOWNTO
21406: IFFALSE 21451
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21408: LD_ADDR_VAR 0 6
21412: PUSH
21413: LD_VAR 0 6
21417: PPUSH
21418: LD_VAR 0 9
21422: PUSH
21423: LD_VAR 0 7
21427: MINUS
21428: PUSH
21429: LD_INT 1
21431: PLUS
21432: PPUSH
21433: LD_VAR 0 9
21437: PUSH
21438: LD_VAR 0 7
21442: ARRAY
21443: PPUSH
21444: CALL_OW 1
21448: ST_TO_ADDR
21449: GO 21405
21451: POP
21452: POP
// end ; tmp := [ ] ;
21453: LD_ADDR_VAR 0 9
21457: PUSH
21458: EMPTY
21459: ST_TO_ADDR
// if mode then
21460: LD_VAR 0 5
21464: IFFALSE 21533
// begin for i = 1 to result do
21466: LD_ADDR_VAR 0 7
21470: PUSH
21471: DOUBLE
21472: LD_INT 1
21474: DEC
21475: ST_TO_ADDR
21476: LD_VAR 0 6
21480: PUSH
21481: FOR_TO
21482: IFFALSE 21521
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21484: LD_ADDR_VAR 0 9
21488: PUSH
21489: LD_VAR 0 9
21493: PPUSH
21494: LD_VAR 0 7
21498: PPUSH
21499: LD_VAR 0 6
21503: PUSH
21504: LD_VAR 0 7
21508: ARRAY
21509: PUSH
21510: LD_INT 1
21512: ARRAY
21513: PPUSH
21514: CALL_OW 1
21518: ST_TO_ADDR
21519: GO 21481
21521: POP
21522: POP
// result := tmp ;
21523: LD_ADDR_VAR 0 6
21527: PUSH
21528: LD_VAR 0 9
21532: ST_TO_ADDR
// end ; end ;
21533: LD_VAR 0 6
21537: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21538: LD_INT 0
21540: PPUSH
21541: PPUSH
21542: PPUSH
21543: PPUSH
21544: PPUSH
21545: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21546: LD_ADDR_VAR 0 5
21550: PUSH
21551: LD_INT 0
21553: PUSH
21554: LD_INT 0
21556: PUSH
21557: LD_INT 0
21559: PUSH
21560: EMPTY
21561: PUSH
21562: EMPTY
21563: LIST
21564: LIST
21565: LIST
21566: LIST
21567: ST_TO_ADDR
// if not x or not y then
21568: LD_VAR 0 2
21572: NOT
21573: PUSH
21574: LD_VAR 0 3
21578: NOT
21579: OR
21580: IFFALSE 21584
// exit ;
21582: GO 23230
// if not range then
21584: LD_VAR 0 4
21588: NOT
21589: IFFALSE 21599
// range := 10 ;
21591: LD_ADDR_VAR 0 4
21595: PUSH
21596: LD_INT 10
21598: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21599: LD_ADDR_VAR 0 8
21603: PUSH
21604: LD_INT 81
21606: PUSH
21607: LD_VAR 0 1
21611: PUSH
21612: EMPTY
21613: LIST
21614: LIST
21615: PUSH
21616: LD_INT 92
21618: PUSH
21619: LD_VAR 0 2
21623: PUSH
21624: LD_VAR 0 3
21628: PUSH
21629: LD_VAR 0 4
21633: PUSH
21634: EMPTY
21635: LIST
21636: LIST
21637: LIST
21638: LIST
21639: PUSH
21640: LD_INT 3
21642: PUSH
21643: LD_INT 21
21645: PUSH
21646: LD_INT 3
21648: PUSH
21649: EMPTY
21650: LIST
21651: LIST
21652: PUSH
21653: EMPTY
21654: LIST
21655: LIST
21656: PUSH
21657: EMPTY
21658: LIST
21659: LIST
21660: LIST
21661: PPUSH
21662: CALL_OW 69
21666: ST_TO_ADDR
// if not tmp then
21667: LD_VAR 0 8
21671: NOT
21672: IFFALSE 21676
// exit ;
21674: GO 23230
// for i in tmp do
21676: LD_ADDR_VAR 0 6
21680: PUSH
21681: LD_VAR 0 8
21685: PUSH
21686: FOR_IN
21687: IFFALSE 23205
// begin points := [ 0 , 0 , 0 ] ;
21689: LD_ADDR_VAR 0 9
21693: PUSH
21694: LD_INT 0
21696: PUSH
21697: LD_INT 0
21699: PUSH
21700: LD_INT 0
21702: PUSH
21703: EMPTY
21704: LIST
21705: LIST
21706: LIST
21707: ST_TO_ADDR
// bpoints := 1 ;
21708: LD_ADDR_VAR 0 10
21712: PUSH
21713: LD_INT 1
21715: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21716: LD_VAR 0 6
21720: PPUSH
21721: CALL_OW 247
21725: PUSH
21726: LD_INT 1
21728: DOUBLE
21729: EQUAL
21730: IFTRUE 21734
21732: GO 22312
21734: POP
// begin if GetClass ( i ) = 1 then
21735: LD_VAR 0 6
21739: PPUSH
21740: CALL_OW 257
21744: PUSH
21745: LD_INT 1
21747: EQUAL
21748: IFFALSE 21769
// points := [ 10 , 5 , 3 ] ;
21750: LD_ADDR_VAR 0 9
21754: PUSH
21755: LD_INT 10
21757: PUSH
21758: LD_INT 5
21760: PUSH
21761: LD_INT 3
21763: PUSH
21764: EMPTY
21765: LIST
21766: LIST
21767: LIST
21768: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21769: LD_VAR 0 6
21773: PPUSH
21774: CALL_OW 257
21778: PUSH
21779: LD_INT 2
21781: PUSH
21782: LD_INT 3
21784: PUSH
21785: LD_INT 4
21787: PUSH
21788: EMPTY
21789: LIST
21790: LIST
21791: LIST
21792: IN
21793: IFFALSE 21814
// points := [ 3 , 2 , 1 ] ;
21795: LD_ADDR_VAR 0 9
21799: PUSH
21800: LD_INT 3
21802: PUSH
21803: LD_INT 2
21805: PUSH
21806: LD_INT 1
21808: PUSH
21809: EMPTY
21810: LIST
21811: LIST
21812: LIST
21813: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21814: LD_VAR 0 6
21818: PPUSH
21819: CALL_OW 257
21823: PUSH
21824: LD_INT 5
21826: EQUAL
21827: IFFALSE 21848
// points := [ 130 , 5 , 2 ] ;
21829: LD_ADDR_VAR 0 9
21833: PUSH
21834: LD_INT 130
21836: PUSH
21837: LD_INT 5
21839: PUSH
21840: LD_INT 2
21842: PUSH
21843: EMPTY
21844: LIST
21845: LIST
21846: LIST
21847: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21848: LD_VAR 0 6
21852: PPUSH
21853: CALL_OW 257
21857: PUSH
21858: LD_INT 8
21860: EQUAL
21861: IFFALSE 21882
// points := [ 35 , 35 , 30 ] ;
21863: LD_ADDR_VAR 0 9
21867: PUSH
21868: LD_INT 35
21870: PUSH
21871: LD_INT 35
21873: PUSH
21874: LD_INT 30
21876: PUSH
21877: EMPTY
21878: LIST
21879: LIST
21880: LIST
21881: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21882: LD_VAR 0 6
21886: PPUSH
21887: CALL_OW 257
21891: PUSH
21892: LD_INT 9
21894: EQUAL
21895: IFFALSE 21916
// points := [ 20 , 55 , 40 ] ;
21897: LD_ADDR_VAR 0 9
21901: PUSH
21902: LD_INT 20
21904: PUSH
21905: LD_INT 55
21907: PUSH
21908: LD_INT 40
21910: PUSH
21911: EMPTY
21912: LIST
21913: LIST
21914: LIST
21915: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21916: LD_VAR 0 6
21920: PPUSH
21921: CALL_OW 257
21925: PUSH
21926: LD_INT 12
21928: PUSH
21929: LD_INT 16
21931: PUSH
21932: EMPTY
21933: LIST
21934: LIST
21935: IN
21936: IFFALSE 21957
// points := [ 5 , 3 , 2 ] ;
21938: LD_ADDR_VAR 0 9
21942: PUSH
21943: LD_INT 5
21945: PUSH
21946: LD_INT 3
21948: PUSH
21949: LD_INT 2
21951: PUSH
21952: EMPTY
21953: LIST
21954: LIST
21955: LIST
21956: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21957: LD_VAR 0 6
21961: PPUSH
21962: CALL_OW 257
21966: PUSH
21967: LD_INT 17
21969: EQUAL
21970: IFFALSE 21991
// points := [ 100 , 50 , 75 ] ;
21972: LD_ADDR_VAR 0 9
21976: PUSH
21977: LD_INT 100
21979: PUSH
21980: LD_INT 50
21982: PUSH
21983: LD_INT 75
21985: PUSH
21986: EMPTY
21987: LIST
21988: LIST
21989: LIST
21990: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21991: LD_VAR 0 6
21995: PPUSH
21996: CALL_OW 257
22000: PUSH
22001: LD_INT 15
22003: EQUAL
22004: IFFALSE 22025
// points := [ 10 , 5 , 3 ] ;
22006: LD_ADDR_VAR 0 9
22010: PUSH
22011: LD_INT 10
22013: PUSH
22014: LD_INT 5
22016: PUSH
22017: LD_INT 3
22019: PUSH
22020: EMPTY
22021: LIST
22022: LIST
22023: LIST
22024: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22025: LD_VAR 0 6
22029: PPUSH
22030: CALL_OW 257
22034: PUSH
22035: LD_INT 14
22037: EQUAL
22038: IFFALSE 22059
// points := [ 10 , 0 , 0 ] ;
22040: LD_ADDR_VAR 0 9
22044: PUSH
22045: LD_INT 10
22047: PUSH
22048: LD_INT 0
22050: PUSH
22051: LD_INT 0
22053: PUSH
22054: EMPTY
22055: LIST
22056: LIST
22057: LIST
22058: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22059: LD_VAR 0 6
22063: PPUSH
22064: CALL_OW 257
22068: PUSH
22069: LD_INT 11
22071: EQUAL
22072: IFFALSE 22093
// points := [ 30 , 10 , 5 ] ;
22074: LD_ADDR_VAR 0 9
22078: PUSH
22079: LD_INT 30
22081: PUSH
22082: LD_INT 10
22084: PUSH
22085: LD_INT 5
22087: PUSH
22088: EMPTY
22089: LIST
22090: LIST
22091: LIST
22092: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22093: LD_VAR 0 1
22097: PPUSH
22098: LD_INT 5
22100: PPUSH
22101: CALL_OW 321
22105: PUSH
22106: LD_INT 2
22108: EQUAL
22109: IFFALSE 22126
// bpoints := bpoints * 1.8 ;
22111: LD_ADDR_VAR 0 10
22115: PUSH
22116: LD_VAR 0 10
22120: PUSH
22121: LD_REAL  1.80000000000000E+0000
22124: MUL
22125: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
22126: LD_VAR 0 6
22130: PPUSH
22131: CALL_OW 257
22135: PUSH
22136: LD_INT 1
22138: PUSH
22139: LD_INT 2
22141: PUSH
22142: LD_INT 3
22144: PUSH
22145: LD_INT 4
22147: PUSH
22148: EMPTY
22149: LIST
22150: LIST
22151: LIST
22152: LIST
22153: IN
22154: PUSH
22155: LD_VAR 0 1
22159: PPUSH
22160: LD_INT 51
22162: PPUSH
22163: CALL_OW 321
22167: PUSH
22168: LD_INT 2
22170: EQUAL
22171: AND
22172: IFFALSE 22189
// bpoints := bpoints * 1.2 ;
22174: LD_ADDR_VAR 0 10
22178: PUSH
22179: LD_VAR 0 10
22183: PUSH
22184: LD_REAL  1.20000000000000E+0000
22187: MUL
22188: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
22189: LD_VAR 0 6
22193: PPUSH
22194: CALL_OW 257
22198: PUSH
22199: LD_INT 5
22201: PUSH
22202: LD_INT 7
22204: PUSH
22205: LD_INT 9
22207: PUSH
22208: EMPTY
22209: LIST
22210: LIST
22211: LIST
22212: IN
22213: PUSH
22214: LD_VAR 0 1
22218: PPUSH
22219: LD_INT 52
22221: PPUSH
22222: CALL_OW 321
22226: PUSH
22227: LD_INT 2
22229: EQUAL
22230: AND
22231: IFFALSE 22248
// bpoints := bpoints * 1.5 ;
22233: LD_ADDR_VAR 0 10
22237: PUSH
22238: LD_VAR 0 10
22242: PUSH
22243: LD_REAL  1.50000000000000E+0000
22246: MUL
22247: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22248: LD_VAR 0 1
22252: PPUSH
22253: LD_INT 66
22255: PPUSH
22256: CALL_OW 321
22260: PUSH
22261: LD_INT 2
22263: EQUAL
22264: IFFALSE 22281
// bpoints := bpoints * 1.1 ;
22266: LD_ADDR_VAR 0 10
22270: PUSH
22271: LD_VAR 0 10
22275: PUSH
22276: LD_REAL  1.10000000000000E+0000
22279: MUL
22280: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
22281: LD_ADDR_VAR 0 10
22285: PUSH
22286: LD_VAR 0 10
22290: PUSH
22291: LD_VAR 0 6
22295: PPUSH
22296: LD_INT 1
22298: PPUSH
22299: CALL_OW 259
22303: PUSH
22304: LD_REAL  1.15000000000000E+0000
22307: MUL
22308: MUL
22309: ST_TO_ADDR
// end ; unit_vehicle :
22310: GO 23134
22312: LD_INT 2
22314: DOUBLE
22315: EQUAL
22316: IFTRUE 22320
22318: GO 23122
22320: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
22321: LD_VAR 0 6
22325: PPUSH
22326: CALL_OW 264
22330: PUSH
22331: LD_INT 2
22333: PUSH
22334: LD_INT 42
22336: PUSH
22337: LD_INT 24
22339: PUSH
22340: EMPTY
22341: LIST
22342: LIST
22343: LIST
22344: IN
22345: IFFALSE 22366
// points := [ 25 , 5 , 3 ] ;
22347: LD_ADDR_VAR 0 9
22351: PUSH
22352: LD_INT 25
22354: PUSH
22355: LD_INT 5
22357: PUSH
22358: LD_INT 3
22360: PUSH
22361: EMPTY
22362: LIST
22363: LIST
22364: LIST
22365: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
22366: LD_VAR 0 6
22370: PPUSH
22371: CALL_OW 264
22375: PUSH
22376: LD_INT 4
22378: PUSH
22379: LD_INT 43
22381: PUSH
22382: LD_INT 25
22384: PUSH
22385: EMPTY
22386: LIST
22387: LIST
22388: LIST
22389: IN
22390: IFFALSE 22411
// points := [ 40 , 15 , 5 ] ;
22392: LD_ADDR_VAR 0 9
22396: PUSH
22397: LD_INT 40
22399: PUSH
22400: LD_INT 15
22402: PUSH
22403: LD_INT 5
22405: PUSH
22406: EMPTY
22407: LIST
22408: LIST
22409: LIST
22410: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22411: LD_VAR 0 6
22415: PPUSH
22416: CALL_OW 264
22420: PUSH
22421: LD_INT 3
22423: PUSH
22424: LD_INT 23
22426: PUSH
22427: EMPTY
22428: LIST
22429: LIST
22430: IN
22431: IFFALSE 22452
// points := [ 7 , 25 , 8 ] ;
22433: LD_ADDR_VAR 0 9
22437: PUSH
22438: LD_INT 7
22440: PUSH
22441: LD_INT 25
22443: PUSH
22444: LD_INT 8
22446: PUSH
22447: EMPTY
22448: LIST
22449: LIST
22450: LIST
22451: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22452: LD_VAR 0 6
22456: PPUSH
22457: CALL_OW 264
22461: PUSH
22462: LD_INT 5
22464: PUSH
22465: LD_INT 27
22467: PUSH
22468: LD_INT 44
22470: PUSH
22471: EMPTY
22472: LIST
22473: LIST
22474: LIST
22475: IN
22476: IFFALSE 22497
// points := [ 14 , 50 , 16 ] ;
22478: LD_ADDR_VAR 0 9
22482: PUSH
22483: LD_INT 14
22485: PUSH
22486: LD_INT 50
22488: PUSH
22489: LD_INT 16
22491: PUSH
22492: EMPTY
22493: LIST
22494: LIST
22495: LIST
22496: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22497: LD_VAR 0 6
22501: PPUSH
22502: CALL_OW 264
22506: PUSH
22507: LD_INT 6
22509: PUSH
22510: LD_INT 46
22512: PUSH
22513: EMPTY
22514: LIST
22515: LIST
22516: IN
22517: IFFALSE 22538
// points := [ 32 , 120 , 70 ] ;
22519: LD_ADDR_VAR 0 9
22523: PUSH
22524: LD_INT 32
22526: PUSH
22527: LD_INT 120
22529: PUSH
22530: LD_INT 70
22532: PUSH
22533: EMPTY
22534: LIST
22535: LIST
22536: LIST
22537: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
22538: LD_VAR 0 6
22542: PPUSH
22543: CALL_OW 264
22547: PUSH
22548: LD_INT 7
22550: PUSH
22551: LD_INT 28
22553: PUSH
22554: LD_INT 45
22556: PUSH
22557: EMPTY
22558: LIST
22559: LIST
22560: LIST
22561: IN
22562: IFFALSE 22583
// points := [ 35 , 20 , 45 ] ;
22564: LD_ADDR_VAR 0 9
22568: PUSH
22569: LD_INT 35
22571: PUSH
22572: LD_INT 20
22574: PUSH
22575: LD_INT 45
22577: PUSH
22578: EMPTY
22579: LIST
22580: LIST
22581: LIST
22582: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22583: LD_VAR 0 6
22587: PPUSH
22588: CALL_OW 264
22592: PUSH
22593: LD_INT 47
22595: PUSH
22596: EMPTY
22597: LIST
22598: IN
22599: IFFALSE 22620
// points := [ 67 , 45 , 75 ] ;
22601: LD_ADDR_VAR 0 9
22605: PUSH
22606: LD_INT 67
22608: PUSH
22609: LD_INT 45
22611: PUSH
22612: LD_INT 75
22614: PUSH
22615: EMPTY
22616: LIST
22617: LIST
22618: LIST
22619: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22620: LD_VAR 0 6
22624: PPUSH
22625: CALL_OW 264
22629: PUSH
22630: LD_INT 26
22632: PUSH
22633: EMPTY
22634: LIST
22635: IN
22636: IFFALSE 22657
// points := [ 120 , 30 , 80 ] ;
22638: LD_ADDR_VAR 0 9
22642: PUSH
22643: LD_INT 120
22645: PUSH
22646: LD_INT 30
22648: PUSH
22649: LD_INT 80
22651: PUSH
22652: EMPTY
22653: LIST
22654: LIST
22655: LIST
22656: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22657: LD_VAR 0 6
22661: PPUSH
22662: CALL_OW 264
22666: PUSH
22667: LD_INT 22
22669: PUSH
22670: EMPTY
22671: LIST
22672: IN
22673: IFFALSE 22694
// points := [ 40 , 1 , 1 ] ;
22675: LD_ADDR_VAR 0 9
22679: PUSH
22680: LD_INT 40
22682: PUSH
22683: LD_INT 1
22685: PUSH
22686: LD_INT 1
22688: PUSH
22689: EMPTY
22690: LIST
22691: LIST
22692: LIST
22693: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22694: LD_VAR 0 6
22698: PPUSH
22699: CALL_OW 264
22703: PUSH
22704: LD_INT 29
22706: PUSH
22707: EMPTY
22708: LIST
22709: IN
22710: IFFALSE 22731
// points := [ 70 , 200 , 400 ] ;
22712: LD_ADDR_VAR 0 9
22716: PUSH
22717: LD_INT 70
22719: PUSH
22720: LD_INT 200
22722: PUSH
22723: LD_INT 400
22725: PUSH
22726: EMPTY
22727: LIST
22728: LIST
22729: LIST
22730: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22731: LD_VAR 0 6
22735: PPUSH
22736: CALL_OW 264
22740: PUSH
22741: LD_INT 14
22743: PUSH
22744: LD_INT 53
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: IN
22751: IFFALSE 22772
// points := [ 40 , 10 , 20 ] ;
22753: LD_ADDR_VAR 0 9
22757: PUSH
22758: LD_INT 40
22760: PUSH
22761: LD_INT 10
22763: PUSH
22764: LD_INT 20
22766: PUSH
22767: EMPTY
22768: LIST
22769: LIST
22770: LIST
22771: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22772: LD_VAR 0 6
22776: PPUSH
22777: CALL_OW 264
22781: PUSH
22782: LD_INT 9
22784: PUSH
22785: EMPTY
22786: LIST
22787: IN
22788: IFFALSE 22809
// points := [ 5 , 70 , 20 ] ;
22790: LD_ADDR_VAR 0 9
22794: PUSH
22795: LD_INT 5
22797: PUSH
22798: LD_INT 70
22800: PUSH
22801: LD_INT 20
22803: PUSH
22804: EMPTY
22805: LIST
22806: LIST
22807: LIST
22808: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22809: LD_VAR 0 6
22813: PPUSH
22814: CALL_OW 264
22818: PUSH
22819: LD_INT 10
22821: PUSH
22822: EMPTY
22823: LIST
22824: IN
22825: IFFALSE 22846
// points := [ 35 , 110 , 70 ] ;
22827: LD_ADDR_VAR 0 9
22831: PUSH
22832: LD_INT 35
22834: PUSH
22835: LD_INT 110
22837: PUSH
22838: LD_INT 70
22840: PUSH
22841: EMPTY
22842: LIST
22843: LIST
22844: LIST
22845: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22846: LD_VAR 0 6
22850: PPUSH
22851: CALL_OW 265
22855: PUSH
22856: LD_INT 25
22858: EQUAL
22859: IFFALSE 22880
// points := [ 80 , 65 , 100 ] ;
22861: LD_ADDR_VAR 0 9
22865: PUSH
22866: LD_INT 80
22868: PUSH
22869: LD_INT 65
22871: PUSH
22872: LD_INT 100
22874: PUSH
22875: EMPTY
22876: LIST
22877: LIST
22878: LIST
22879: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22880: LD_VAR 0 6
22884: PPUSH
22885: CALL_OW 263
22889: PUSH
22890: LD_INT 1
22892: EQUAL
22893: IFFALSE 22928
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22895: LD_ADDR_VAR 0 10
22899: PUSH
22900: LD_VAR 0 10
22904: PUSH
22905: LD_VAR 0 6
22909: PPUSH
22910: CALL_OW 311
22914: PPUSH
22915: LD_INT 3
22917: PPUSH
22918: CALL_OW 259
22922: PUSH
22923: LD_INT 4
22925: MUL
22926: MUL
22927: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22928: LD_VAR 0 6
22932: PPUSH
22933: CALL_OW 263
22937: PUSH
22938: LD_INT 2
22940: EQUAL
22941: IFFALSE 22992
// begin j := IsControledBy ( i ) ;
22943: LD_ADDR_VAR 0 7
22947: PUSH
22948: LD_VAR 0 6
22952: PPUSH
22953: CALL_OW 312
22957: ST_TO_ADDR
// if j then
22958: LD_VAR 0 7
22962: IFFALSE 22992
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22964: LD_ADDR_VAR 0 10
22968: PUSH
22969: LD_VAR 0 10
22973: PUSH
22974: LD_VAR 0 7
22978: PPUSH
22979: LD_INT 3
22981: PPUSH
22982: CALL_OW 259
22986: PUSH
22987: LD_INT 3
22989: MUL
22990: MUL
22991: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22992: LD_VAR 0 6
22996: PPUSH
22997: CALL_OW 264
23001: PUSH
23002: LD_INT 5
23004: PUSH
23005: LD_INT 6
23007: PUSH
23008: LD_INT 46
23010: PUSH
23011: LD_INT 44
23013: PUSH
23014: LD_INT 47
23016: PUSH
23017: LD_INT 45
23019: PUSH
23020: LD_INT 28
23022: PUSH
23023: LD_INT 7
23025: PUSH
23026: LD_INT 27
23028: PUSH
23029: LD_INT 29
23031: PUSH
23032: EMPTY
23033: LIST
23034: LIST
23035: LIST
23036: LIST
23037: LIST
23038: LIST
23039: LIST
23040: LIST
23041: LIST
23042: LIST
23043: IN
23044: PUSH
23045: LD_VAR 0 1
23049: PPUSH
23050: LD_INT 52
23052: PPUSH
23053: CALL_OW 321
23057: PUSH
23058: LD_INT 2
23060: EQUAL
23061: AND
23062: IFFALSE 23079
// bpoints := bpoints * 1.2 ;
23064: LD_ADDR_VAR 0 10
23068: PUSH
23069: LD_VAR 0 10
23073: PUSH
23074: LD_REAL  1.20000000000000E+0000
23077: MUL
23078: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23079: LD_VAR 0 6
23083: PPUSH
23084: CALL_OW 264
23088: PUSH
23089: LD_INT 6
23091: PUSH
23092: LD_INT 46
23094: PUSH
23095: LD_INT 47
23097: PUSH
23098: EMPTY
23099: LIST
23100: LIST
23101: LIST
23102: IN
23103: IFFALSE 23120
// bpoints := bpoints * 1.2 ;
23105: LD_ADDR_VAR 0 10
23109: PUSH
23110: LD_VAR 0 10
23114: PUSH
23115: LD_REAL  1.20000000000000E+0000
23118: MUL
23119: ST_TO_ADDR
// end ; unit_building :
23120: GO 23134
23122: LD_INT 3
23124: DOUBLE
23125: EQUAL
23126: IFTRUE 23130
23128: GO 23133
23130: POP
// ; end ;
23131: GO 23134
23133: POP
// for j = 1 to 3 do
23134: LD_ADDR_VAR 0 7
23138: PUSH
23139: DOUBLE
23140: LD_INT 1
23142: DEC
23143: ST_TO_ADDR
23144: LD_INT 3
23146: PUSH
23147: FOR_TO
23148: IFFALSE 23201
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
23150: LD_ADDR_VAR 0 5
23154: PUSH
23155: LD_VAR 0 5
23159: PPUSH
23160: LD_VAR 0 7
23164: PPUSH
23165: LD_VAR 0 5
23169: PUSH
23170: LD_VAR 0 7
23174: ARRAY
23175: PUSH
23176: LD_VAR 0 9
23180: PUSH
23181: LD_VAR 0 7
23185: ARRAY
23186: PUSH
23187: LD_VAR 0 10
23191: MUL
23192: PLUS
23193: PPUSH
23194: CALL_OW 1
23198: ST_TO_ADDR
23199: GO 23147
23201: POP
23202: POP
// end ;
23203: GO 21686
23205: POP
23206: POP
// result := Replace ( result , 4 , tmp ) ;
23207: LD_ADDR_VAR 0 5
23211: PUSH
23212: LD_VAR 0 5
23216: PPUSH
23217: LD_INT 4
23219: PPUSH
23220: LD_VAR 0 8
23224: PPUSH
23225: CALL_OW 1
23229: ST_TO_ADDR
// end ;
23230: LD_VAR 0 5
23234: RET
// export function DangerAtRange ( unit , range ) ; begin
23235: LD_INT 0
23237: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23238: LD_ADDR_VAR 0 3
23242: PUSH
23243: LD_VAR 0 1
23247: PPUSH
23248: CALL_OW 255
23252: PPUSH
23253: LD_VAR 0 1
23257: PPUSH
23258: CALL_OW 250
23262: PPUSH
23263: LD_VAR 0 1
23267: PPUSH
23268: CALL_OW 251
23272: PPUSH
23273: LD_VAR 0 2
23277: PPUSH
23278: CALL 21538 0 4
23282: ST_TO_ADDR
// end ;
23283: LD_VAR 0 3
23287: RET
// export function DangerInArea ( side , area ) ; begin
23288: LD_INT 0
23290: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
23291: LD_ADDR_VAR 0 3
23295: PUSH
23296: LD_VAR 0 2
23300: PPUSH
23301: LD_INT 81
23303: PUSH
23304: LD_VAR 0 1
23308: PUSH
23309: EMPTY
23310: LIST
23311: LIST
23312: PPUSH
23313: CALL_OW 70
23317: ST_TO_ADDR
// end ;
23318: LD_VAR 0 3
23322: RET
// export function IsExtension ( b ) ; begin
23323: LD_INT 0
23325: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
23326: LD_ADDR_VAR 0 2
23330: PUSH
23331: LD_VAR 0 1
23335: PUSH
23336: LD_INT 23
23338: PUSH
23339: LD_INT 20
23341: PUSH
23342: LD_INT 22
23344: PUSH
23345: LD_INT 17
23347: PUSH
23348: LD_INT 24
23350: PUSH
23351: LD_INT 21
23353: PUSH
23354: LD_INT 19
23356: PUSH
23357: LD_INT 16
23359: PUSH
23360: LD_INT 25
23362: PUSH
23363: LD_INT 18
23365: PUSH
23366: EMPTY
23367: LIST
23368: LIST
23369: LIST
23370: LIST
23371: LIST
23372: LIST
23373: LIST
23374: LIST
23375: LIST
23376: LIST
23377: IN
23378: ST_TO_ADDR
// end ;
23379: LD_VAR 0 2
23383: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
23384: LD_INT 0
23386: PPUSH
23387: PPUSH
23388: PPUSH
// result := [ ] ;
23389: LD_ADDR_VAR 0 3
23393: PUSH
23394: EMPTY
23395: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23396: LD_ADDR_VAR 0 4
23400: PUSH
23401: LD_VAR 0 2
23405: PPUSH
23406: LD_INT 21
23408: PUSH
23409: LD_INT 3
23411: PUSH
23412: EMPTY
23413: LIST
23414: LIST
23415: PPUSH
23416: CALL_OW 70
23420: ST_TO_ADDR
// if not tmp then
23421: LD_VAR 0 4
23425: NOT
23426: IFFALSE 23430
// exit ;
23428: GO 23488
// for i in tmp do
23430: LD_ADDR_VAR 0 5
23434: PUSH
23435: LD_VAR 0 4
23439: PUSH
23440: FOR_IN
23441: IFFALSE 23476
// if GetBase ( i ) <> base then
23443: LD_VAR 0 5
23447: PPUSH
23448: CALL_OW 274
23452: PUSH
23453: LD_VAR 0 1
23457: NONEQUAL
23458: IFFALSE 23474
// ComLinkToBase ( base , i ) ;
23460: LD_VAR 0 1
23464: PPUSH
23465: LD_VAR 0 5
23469: PPUSH
23470: CALL_OW 169
23474: GO 23440
23476: POP
23477: POP
// result := tmp ;
23478: LD_ADDR_VAR 0 3
23482: PUSH
23483: LD_VAR 0 4
23487: ST_TO_ADDR
// end ;
23488: LD_VAR 0 3
23492: RET
// export function ComComplete ( unit , b ) ; var i ; begin
23493: LD_INT 0
23495: PPUSH
23496: PPUSH
// if BuildingStatus ( b ) = bs_build then
23497: LD_VAR 0 2
23501: PPUSH
23502: CALL_OW 461
23506: PUSH
23507: LD_INT 1
23509: EQUAL
23510: IFFALSE 23570
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23512: LD_VAR 0 1
23516: PPUSH
23517: LD_STRING h
23519: PUSH
23520: LD_VAR 0 2
23524: PPUSH
23525: CALL_OW 250
23529: PUSH
23530: LD_VAR 0 2
23534: PPUSH
23535: CALL_OW 251
23539: PUSH
23540: LD_VAR 0 2
23544: PUSH
23545: LD_INT 0
23547: PUSH
23548: LD_INT 0
23550: PUSH
23551: LD_INT 0
23553: PUSH
23554: EMPTY
23555: LIST
23556: LIST
23557: LIST
23558: LIST
23559: LIST
23560: LIST
23561: LIST
23562: PUSH
23563: EMPTY
23564: LIST
23565: PPUSH
23566: CALL_OW 446
// end ;
23570: LD_VAR 0 3
23574: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23575: LD_INT 0
23577: PPUSH
23578: PPUSH
23579: PPUSH
23580: PPUSH
23581: PPUSH
23582: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
23583: LD_VAR 0 1
23587: NOT
23588: PUSH
23589: LD_VAR 0 1
23593: PPUSH
23594: CALL_OW 263
23598: PUSH
23599: LD_INT 2
23601: EQUAL
23602: NOT
23603: OR
23604: IFFALSE 23608
// exit ;
23606: GO 23924
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23608: LD_ADDR_VAR 0 6
23612: PUSH
23613: LD_INT 22
23615: PUSH
23616: LD_VAR 0 1
23620: PPUSH
23621: CALL_OW 255
23625: PUSH
23626: EMPTY
23627: LIST
23628: LIST
23629: PUSH
23630: LD_INT 2
23632: PUSH
23633: LD_INT 30
23635: PUSH
23636: LD_INT 36
23638: PUSH
23639: EMPTY
23640: LIST
23641: LIST
23642: PUSH
23643: LD_INT 34
23645: PUSH
23646: LD_INT 31
23648: PUSH
23649: EMPTY
23650: LIST
23651: LIST
23652: PUSH
23653: EMPTY
23654: LIST
23655: LIST
23656: LIST
23657: PUSH
23658: EMPTY
23659: LIST
23660: LIST
23661: PPUSH
23662: CALL_OW 69
23666: ST_TO_ADDR
// if not tmp then
23667: LD_VAR 0 6
23671: NOT
23672: IFFALSE 23676
// exit ;
23674: GO 23924
// result := [ ] ;
23676: LD_ADDR_VAR 0 2
23680: PUSH
23681: EMPTY
23682: ST_TO_ADDR
// for i in tmp do
23683: LD_ADDR_VAR 0 3
23687: PUSH
23688: LD_VAR 0 6
23692: PUSH
23693: FOR_IN
23694: IFFALSE 23765
// begin t := UnitsInside ( i ) ;
23696: LD_ADDR_VAR 0 4
23700: PUSH
23701: LD_VAR 0 3
23705: PPUSH
23706: CALL_OW 313
23710: ST_TO_ADDR
// if t then
23711: LD_VAR 0 4
23715: IFFALSE 23763
// for j in t do
23717: LD_ADDR_VAR 0 7
23721: PUSH
23722: LD_VAR 0 4
23726: PUSH
23727: FOR_IN
23728: IFFALSE 23761
// result := Insert ( result , result + 1 , j ) ;
23730: LD_ADDR_VAR 0 2
23734: PUSH
23735: LD_VAR 0 2
23739: PPUSH
23740: LD_VAR 0 2
23744: PUSH
23745: LD_INT 1
23747: PLUS
23748: PPUSH
23749: LD_VAR 0 7
23753: PPUSH
23754: CALL_OW 2
23758: ST_TO_ADDR
23759: GO 23727
23761: POP
23762: POP
// end ;
23763: GO 23693
23765: POP
23766: POP
// if not result then
23767: LD_VAR 0 2
23771: NOT
23772: IFFALSE 23776
// exit ;
23774: GO 23924
// mech := result [ 1 ] ;
23776: LD_ADDR_VAR 0 5
23780: PUSH
23781: LD_VAR 0 2
23785: PUSH
23786: LD_INT 1
23788: ARRAY
23789: ST_TO_ADDR
// if result > 1 then
23790: LD_VAR 0 2
23794: PUSH
23795: LD_INT 1
23797: GREATER
23798: IFFALSE 23910
// for i = 2 to result do
23800: LD_ADDR_VAR 0 3
23804: PUSH
23805: DOUBLE
23806: LD_INT 2
23808: DEC
23809: ST_TO_ADDR
23810: LD_VAR 0 2
23814: PUSH
23815: FOR_TO
23816: IFFALSE 23908
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23818: LD_ADDR_VAR 0 4
23822: PUSH
23823: LD_VAR 0 2
23827: PUSH
23828: LD_VAR 0 3
23832: ARRAY
23833: PPUSH
23834: LD_INT 3
23836: PPUSH
23837: CALL_OW 259
23841: PUSH
23842: LD_VAR 0 2
23846: PUSH
23847: LD_VAR 0 3
23851: ARRAY
23852: PPUSH
23853: CALL_OW 432
23857: MINUS
23858: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23859: LD_VAR 0 4
23863: PUSH
23864: LD_VAR 0 5
23868: PPUSH
23869: LD_INT 3
23871: PPUSH
23872: CALL_OW 259
23876: PUSH
23877: LD_VAR 0 5
23881: PPUSH
23882: CALL_OW 432
23886: MINUS
23887: GREATEREQUAL
23888: IFFALSE 23906
// mech := result [ i ] ;
23890: LD_ADDR_VAR 0 5
23894: PUSH
23895: LD_VAR 0 2
23899: PUSH
23900: LD_VAR 0 3
23904: ARRAY
23905: ST_TO_ADDR
// end ;
23906: GO 23815
23908: POP
23909: POP
// ComLinkTo ( vehicle , mech ) ;
23910: LD_VAR 0 1
23914: PPUSH
23915: LD_VAR 0 5
23919: PPUSH
23920: CALL_OW 135
// end ;
23924: LD_VAR 0 2
23928: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23929: LD_INT 0
23931: PPUSH
23932: PPUSH
23933: PPUSH
23934: PPUSH
23935: PPUSH
23936: PPUSH
23937: PPUSH
23938: PPUSH
23939: PPUSH
23940: PPUSH
23941: PPUSH
23942: PPUSH
23943: PPUSH
// result := [ ] ;
23944: LD_ADDR_VAR 0 7
23948: PUSH
23949: EMPTY
23950: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23951: LD_VAR 0 1
23955: PPUSH
23956: CALL_OW 266
23960: PUSH
23961: LD_INT 0
23963: PUSH
23964: LD_INT 1
23966: PUSH
23967: EMPTY
23968: LIST
23969: LIST
23970: IN
23971: NOT
23972: IFFALSE 23976
// exit ;
23974: GO 25607
// if name then
23976: LD_VAR 0 3
23980: IFFALSE 23996
// SetBName ( base_dep , name ) ;
23982: LD_VAR 0 1
23986: PPUSH
23987: LD_VAR 0 3
23991: PPUSH
23992: CALL_OW 500
// base := GetBase ( base_dep ) ;
23996: LD_ADDR_VAR 0 15
24000: PUSH
24001: LD_VAR 0 1
24005: PPUSH
24006: CALL_OW 274
24010: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24011: LD_ADDR_VAR 0 16
24015: PUSH
24016: LD_VAR 0 1
24020: PPUSH
24021: CALL_OW 255
24025: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24026: LD_ADDR_VAR 0 17
24030: PUSH
24031: LD_VAR 0 1
24035: PPUSH
24036: CALL_OW 248
24040: ST_TO_ADDR
// if sources then
24041: LD_VAR 0 5
24045: IFFALSE 24092
// for i = 1 to 3 do
24047: LD_ADDR_VAR 0 8
24051: PUSH
24052: DOUBLE
24053: LD_INT 1
24055: DEC
24056: ST_TO_ADDR
24057: LD_INT 3
24059: PUSH
24060: FOR_TO
24061: IFFALSE 24090
// AddResourceType ( base , i , sources [ i ] ) ;
24063: LD_VAR 0 15
24067: PPUSH
24068: LD_VAR 0 8
24072: PPUSH
24073: LD_VAR 0 5
24077: PUSH
24078: LD_VAR 0 8
24082: ARRAY
24083: PPUSH
24084: CALL_OW 276
24088: GO 24060
24090: POP
24091: POP
// buildings := GetBaseBuildings ( base , area ) ;
24092: LD_ADDR_VAR 0 18
24096: PUSH
24097: LD_VAR 0 15
24101: PPUSH
24102: LD_VAR 0 2
24106: PPUSH
24107: CALL 23384 0 2
24111: ST_TO_ADDR
// InitHc ;
24112: CALL_OW 19
// InitUc ;
24116: CALL_OW 18
// uc_side := side ;
24120: LD_ADDR_OWVAR 20
24124: PUSH
24125: LD_VAR 0 16
24129: ST_TO_ADDR
// uc_nation := nation ;
24130: LD_ADDR_OWVAR 21
24134: PUSH
24135: LD_VAR 0 17
24139: ST_TO_ADDR
// if buildings then
24140: LD_VAR 0 18
24144: IFFALSE 25466
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
24146: LD_ADDR_VAR 0 19
24150: PUSH
24151: LD_VAR 0 18
24155: PPUSH
24156: LD_INT 2
24158: PUSH
24159: LD_INT 30
24161: PUSH
24162: LD_INT 29
24164: PUSH
24165: EMPTY
24166: LIST
24167: LIST
24168: PUSH
24169: LD_INT 30
24171: PUSH
24172: LD_INT 30
24174: PUSH
24175: EMPTY
24176: LIST
24177: LIST
24178: PUSH
24179: EMPTY
24180: LIST
24181: LIST
24182: LIST
24183: PPUSH
24184: CALL_OW 72
24188: ST_TO_ADDR
// if tmp then
24189: LD_VAR 0 19
24193: IFFALSE 24241
// for i in tmp do
24195: LD_ADDR_VAR 0 8
24199: PUSH
24200: LD_VAR 0 19
24204: PUSH
24205: FOR_IN
24206: IFFALSE 24239
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24208: LD_VAR 0 8
24212: PPUSH
24213: CALL_OW 250
24217: PPUSH
24218: LD_VAR 0 8
24222: PPUSH
24223: CALL_OW 251
24227: PPUSH
24228: LD_VAR 0 16
24232: PPUSH
24233: CALL_OW 441
24237: GO 24205
24239: POP
24240: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24241: LD_VAR 0 18
24245: PPUSH
24246: LD_INT 2
24248: PUSH
24249: LD_INT 30
24251: PUSH
24252: LD_INT 32
24254: PUSH
24255: EMPTY
24256: LIST
24257: LIST
24258: PUSH
24259: LD_INT 30
24261: PUSH
24262: LD_INT 33
24264: PUSH
24265: EMPTY
24266: LIST
24267: LIST
24268: PUSH
24269: EMPTY
24270: LIST
24271: LIST
24272: LIST
24273: PPUSH
24274: CALL_OW 72
24278: IFFALSE 24366
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
24280: LD_ADDR_VAR 0 8
24284: PUSH
24285: LD_VAR 0 18
24289: PPUSH
24290: LD_INT 2
24292: PUSH
24293: LD_INT 30
24295: PUSH
24296: LD_INT 32
24298: PUSH
24299: EMPTY
24300: LIST
24301: LIST
24302: PUSH
24303: LD_INT 30
24305: PUSH
24306: LD_INT 33
24308: PUSH
24309: EMPTY
24310: LIST
24311: LIST
24312: PUSH
24313: EMPTY
24314: LIST
24315: LIST
24316: LIST
24317: PPUSH
24318: CALL_OW 72
24322: PUSH
24323: FOR_IN
24324: IFFALSE 24364
// begin if not GetBWeapon ( i ) then
24326: LD_VAR 0 8
24330: PPUSH
24331: CALL_OW 269
24335: NOT
24336: IFFALSE 24362
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
24338: LD_VAR 0 8
24342: PPUSH
24343: LD_VAR 0 8
24347: PPUSH
24348: LD_VAR 0 2
24352: PPUSH
24353: CALL 25612 0 2
24357: PPUSH
24358: CALL_OW 431
// end ;
24362: GO 24323
24364: POP
24365: POP
// end ; for i = 1 to personel do
24366: LD_ADDR_VAR 0 8
24370: PUSH
24371: DOUBLE
24372: LD_INT 1
24374: DEC
24375: ST_TO_ADDR
24376: LD_VAR 0 6
24380: PUSH
24381: FOR_TO
24382: IFFALSE 25446
// begin if i > 4 then
24384: LD_VAR 0 8
24388: PUSH
24389: LD_INT 4
24391: GREATER
24392: IFFALSE 24396
// break ;
24394: GO 25446
// case i of 1 :
24396: LD_VAR 0 8
24400: PUSH
24401: LD_INT 1
24403: DOUBLE
24404: EQUAL
24405: IFTRUE 24409
24407: GO 24489
24409: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24410: LD_ADDR_VAR 0 12
24414: PUSH
24415: LD_VAR 0 18
24419: PPUSH
24420: LD_INT 22
24422: PUSH
24423: LD_VAR 0 16
24427: PUSH
24428: EMPTY
24429: LIST
24430: LIST
24431: PUSH
24432: LD_INT 58
24434: PUSH
24435: EMPTY
24436: LIST
24437: PUSH
24438: LD_INT 2
24440: PUSH
24441: LD_INT 30
24443: PUSH
24444: LD_INT 32
24446: PUSH
24447: EMPTY
24448: LIST
24449: LIST
24450: PUSH
24451: LD_INT 30
24453: PUSH
24454: LD_INT 4
24456: PUSH
24457: EMPTY
24458: LIST
24459: LIST
24460: PUSH
24461: LD_INT 30
24463: PUSH
24464: LD_INT 5
24466: PUSH
24467: EMPTY
24468: LIST
24469: LIST
24470: PUSH
24471: EMPTY
24472: LIST
24473: LIST
24474: LIST
24475: LIST
24476: PUSH
24477: EMPTY
24478: LIST
24479: LIST
24480: LIST
24481: PPUSH
24482: CALL_OW 72
24486: ST_TO_ADDR
24487: GO 24711
24489: LD_INT 2
24491: DOUBLE
24492: EQUAL
24493: IFTRUE 24497
24495: GO 24559
24497: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24498: LD_ADDR_VAR 0 12
24502: PUSH
24503: LD_VAR 0 18
24507: PPUSH
24508: LD_INT 22
24510: PUSH
24511: LD_VAR 0 16
24515: PUSH
24516: EMPTY
24517: LIST
24518: LIST
24519: PUSH
24520: LD_INT 2
24522: PUSH
24523: LD_INT 30
24525: PUSH
24526: LD_INT 0
24528: PUSH
24529: EMPTY
24530: LIST
24531: LIST
24532: PUSH
24533: LD_INT 30
24535: PUSH
24536: LD_INT 1
24538: PUSH
24539: EMPTY
24540: LIST
24541: LIST
24542: PUSH
24543: EMPTY
24544: LIST
24545: LIST
24546: LIST
24547: PUSH
24548: EMPTY
24549: LIST
24550: LIST
24551: PPUSH
24552: CALL_OW 72
24556: ST_TO_ADDR
24557: GO 24711
24559: LD_INT 3
24561: DOUBLE
24562: EQUAL
24563: IFTRUE 24567
24565: GO 24629
24567: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24568: LD_ADDR_VAR 0 12
24572: PUSH
24573: LD_VAR 0 18
24577: PPUSH
24578: LD_INT 22
24580: PUSH
24581: LD_VAR 0 16
24585: PUSH
24586: EMPTY
24587: LIST
24588: LIST
24589: PUSH
24590: LD_INT 2
24592: PUSH
24593: LD_INT 30
24595: PUSH
24596: LD_INT 2
24598: PUSH
24599: EMPTY
24600: LIST
24601: LIST
24602: PUSH
24603: LD_INT 30
24605: PUSH
24606: LD_INT 3
24608: PUSH
24609: EMPTY
24610: LIST
24611: LIST
24612: PUSH
24613: EMPTY
24614: LIST
24615: LIST
24616: LIST
24617: PUSH
24618: EMPTY
24619: LIST
24620: LIST
24621: PPUSH
24622: CALL_OW 72
24626: ST_TO_ADDR
24627: GO 24711
24629: LD_INT 4
24631: DOUBLE
24632: EQUAL
24633: IFTRUE 24637
24635: GO 24710
24637: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24638: LD_ADDR_VAR 0 12
24642: PUSH
24643: LD_VAR 0 18
24647: PPUSH
24648: LD_INT 22
24650: PUSH
24651: LD_VAR 0 16
24655: PUSH
24656: EMPTY
24657: LIST
24658: LIST
24659: PUSH
24660: LD_INT 2
24662: PUSH
24663: LD_INT 30
24665: PUSH
24666: LD_INT 6
24668: PUSH
24669: EMPTY
24670: LIST
24671: LIST
24672: PUSH
24673: LD_INT 30
24675: PUSH
24676: LD_INT 7
24678: PUSH
24679: EMPTY
24680: LIST
24681: LIST
24682: PUSH
24683: LD_INT 30
24685: PUSH
24686: LD_INT 8
24688: PUSH
24689: EMPTY
24690: LIST
24691: LIST
24692: PUSH
24693: EMPTY
24694: LIST
24695: LIST
24696: LIST
24697: LIST
24698: PUSH
24699: EMPTY
24700: LIST
24701: LIST
24702: PPUSH
24703: CALL_OW 72
24707: ST_TO_ADDR
24708: GO 24711
24710: POP
// if i = 1 then
24711: LD_VAR 0 8
24715: PUSH
24716: LD_INT 1
24718: EQUAL
24719: IFFALSE 24830
// begin tmp := [ ] ;
24721: LD_ADDR_VAR 0 19
24725: PUSH
24726: EMPTY
24727: ST_TO_ADDR
// for j in f do
24728: LD_ADDR_VAR 0 9
24732: PUSH
24733: LD_VAR 0 12
24737: PUSH
24738: FOR_IN
24739: IFFALSE 24812
// if GetBType ( j ) = b_bunker then
24741: LD_VAR 0 9
24745: PPUSH
24746: CALL_OW 266
24750: PUSH
24751: LD_INT 32
24753: EQUAL
24754: IFFALSE 24781
// tmp := Insert ( tmp , 1 , j ) else
24756: LD_ADDR_VAR 0 19
24760: PUSH
24761: LD_VAR 0 19
24765: PPUSH
24766: LD_INT 1
24768: PPUSH
24769: LD_VAR 0 9
24773: PPUSH
24774: CALL_OW 2
24778: ST_TO_ADDR
24779: GO 24810
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24781: LD_ADDR_VAR 0 19
24785: PUSH
24786: LD_VAR 0 19
24790: PPUSH
24791: LD_VAR 0 19
24795: PUSH
24796: LD_INT 1
24798: PLUS
24799: PPUSH
24800: LD_VAR 0 9
24804: PPUSH
24805: CALL_OW 2
24809: ST_TO_ADDR
24810: GO 24738
24812: POP
24813: POP
// if tmp then
24814: LD_VAR 0 19
24818: IFFALSE 24830
// f := tmp ;
24820: LD_ADDR_VAR 0 12
24824: PUSH
24825: LD_VAR 0 19
24829: ST_TO_ADDR
// end ; x := personel [ i ] ;
24830: LD_ADDR_VAR 0 13
24834: PUSH
24835: LD_VAR 0 6
24839: PUSH
24840: LD_VAR 0 8
24844: ARRAY
24845: ST_TO_ADDR
// if x = - 1 then
24846: LD_VAR 0 13
24850: PUSH
24851: LD_INT 1
24853: NEG
24854: EQUAL
24855: IFFALSE 25064
// begin for j in f do
24857: LD_ADDR_VAR 0 9
24861: PUSH
24862: LD_VAR 0 12
24866: PUSH
24867: FOR_IN
24868: IFFALSE 25060
// repeat InitHc ;
24870: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24874: LD_VAR 0 9
24878: PPUSH
24879: CALL_OW 266
24883: PUSH
24884: LD_INT 5
24886: EQUAL
24887: IFFALSE 24957
// begin if UnitsInside ( j ) < 3 then
24889: LD_VAR 0 9
24893: PPUSH
24894: CALL_OW 313
24898: PUSH
24899: LD_INT 3
24901: LESS
24902: IFFALSE 24938
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24904: LD_INT 0
24906: PPUSH
24907: LD_INT 5
24909: PUSH
24910: LD_INT 8
24912: PUSH
24913: LD_INT 9
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: LIST
24920: PUSH
24921: LD_VAR 0 17
24925: ARRAY
24926: PPUSH
24927: LD_VAR 0 4
24931: PPUSH
24932: CALL_OW 380
24936: GO 24955
// PrepareHuman ( false , i , skill ) ;
24938: LD_INT 0
24940: PPUSH
24941: LD_VAR 0 8
24945: PPUSH
24946: LD_VAR 0 4
24950: PPUSH
24951: CALL_OW 380
// end else
24955: GO 24974
// PrepareHuman ( false , i , skill ) ;
24957: LD_INT 0
24959: PPUSH
24960: LD_VAR 0 8
24964: PPUSH
24965: LD_VAR 0 4
24969: PPUSH
24970: CALL_OW 380
// un := CreateHuman ;
24974: LD_ADDR_VAR 0 14
24978: PUSH
24979: CALL_OW 44
24983: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24984: LD_ADDR_VAR 0 7
24988: PUSH
24989: LD_VAR 0 7
24993: PPUSH
24994: LD_INT 1
24996: PPUSH
24997: LD_VAR 0 14
25001: PPUSH
25002: CALL_OW 2
25006: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25007: LD_VAR 0 14
25011: PPUSH
25012: LD_VAR 0 9
25016: PPUSH
25017: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25021: LD_VAR 0 9
25025: PPUSH
25026: CALL_OW 313
25030: PUSH
25031: LD_INT 6
25033: EQUAL
25034: PUSH
25035: LD_VAR 0 9
25039: PPUSH
25040: CALL_OW 266
25044: PUSH
25045: LD_INT 32
25047: PUSH
25048: LD_INT 31
25050: PUSH
25051: EMPTY
25052: LIST
25053: LIST
25054: IN
25055: OR
25056: IFFALSE 24870
25058: GO 24867
25060: POP
25061: POP
// end else
25062: GO 25444
// for j = 1 to x do
25064: LD_ADDR_VAR 0 9
25068: PUSH
25069: DOUBLE
25070: LD_INT 1
25072: DEC
25073: ST_TO_ADDR
25074: LD_VAR 0 13
25078: PUSH
25079: FOR_TO
25080: IFFALSE 25442
// begin InitHc ;
25082: CALL_OW 19
// if not f then
25086: LD_VAR 0 12
25090: NOT
25091: IFFALSE 25180
// begin PrepareHuman ( false , i , skill ) ;
25093: LD_INT 0
25095: PPUSH
25096: LD_VAR 0 8
25100: PPUSH
25101: LD_VAR 0 4
25105: PPUSH
25106: CALL_OW 380
// un := CreateHuman ;
25110: LD_ADDR_VAR 0 14
25114: PUSH
25115: CALL_OW 44
25119: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25120: LD_ADDR_VAR 0 7
25124: PUSH
25125: LD_VAR 0 7
25129: PPUSH
25130: LD_INT 1
25132: PPUSH
25133: LD_VAR 0 14
25137: PPUSH
25138: CALL_OW 2
25142: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25143: LD_VAR 0 14
25147: PPUSH
25148: LD_VAR 0 1
25152: PPUSH
25153: CALL_OW 250
25157: PPUSH
25158: LD_VAR 0 1
25162: PPUSH
25163: CALL_OW 251
25167: PPUSH
25168: LD_INT 10
25170: PPUSH
25171: LD_INT 0
25173: PPUSH
25174: CALL_OW 50
// continue ;
25178: GO 25079
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25180: LD_VAR 0 12
25184: PUSH
25185: LD_INT 1
25187: ARRAY
25188: PPUSH
25189: CALL_OW 313
25193: PUSH
25194: LD_VAR 0 12
25198: PUSH
25199: LD_INT 1
25201: ARRAY
25202: PPUSH
25203: CALL_OW 266
25207: PUSH
25208: LD_INT 32
25210: PUSH
25211: LD_INT 31
25213: PUSH
25214: EMPTY
25215: LIST
25216: LIST
25217: IN
25218: AND
25219: PUSH
25220: LD_VAR 0 12
25224: PUSH
25225: LD_INT 1
25227: ARRAY
25228: PPUSH
25229: CALL_OW 313
25233: PUSH
25234: LD_INT 6
25236: EQUAL
25237: OR
25238: IFFALSE 25258
// f := Delete ( f , 1 ) ;
25240: LD_ADDR_VAR 0 12
25244: PUSH
25245: LD_VAR 0 12
25249: PPUSH
25250: LD_INT 1
25252: PPUSH
25253: CALL_OW 3
25257: ST_TO_ADDR
// if not f then
25258: LD_VAR 0 12
25262: NOT
25263: IFFALSE 25281
// begin x := x + 2 ;
25265: LD_ADDR_VAR 0 13
25269: PUSH
25270: LD_VAR 0 13
25274: PUSH
25275: LD_INT 2
25277: PLUS
25278: ST_TO_ADDR
// continue ;
25279: GO 25079
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
25281: LD_VAR 0 12
25285: PUSH
25286: LD_INT 1
25288: ARRAY
25289: PPUSH
25290: CALL_OW 266
25294: PUSH
25295: LD_INT 5
25297: EQUAL
25298: IFFALSE 25372
// begin if UnitsInside ( f [ 1 ] ) < 3 then
25300: LD_VAR 0 12
25304: PUSH
25305: LD_INT 1
25307: ARRAY
25308: PPUSH
25309: CALL_OW 313
25313: PUSH
25314: LD_INT 3
25316: LESS
25317: IFFALSE 25353
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25319: LD_INT 0
25321: PPUSH
25322: LD_INT 5
25324: PUSH
25325: LD_INT 8
25327: PUSH
25328: LD_INT 9
25330: PUSH
25331: EMPTY
25332: LIST
25333: LIST
25334: LIST
25335: PUSH
25336: LD_VAR 0 17
25340: ARRAY
25341: PPUSH
25342: LD_VAR 0 4
25346: PPUSH
25347: CALL_OW 380
25351: GO 25370
// PrepareHuman ( false , i , skill ) ;
25353: LD_INT 0
25355: PPUSH
25356: LD_VAR 0 8
25360: PPUSH
25361: LD_VAR 0 4
25365: PPUSH
25366: CALL_OW 380
// end else
25370: GO 25389
// PrepareHuman ( false , i , skill ) ;
25372: LD_INT 0
25374: PPUSH
25375: LD_VAR 0 8
25379: PPUSH
25380: LD_VAR 0 4
25384: PPUSH
25385: CALL_OW 380
// un := CreateHuman ;
25389: LD_ADDR_VAR 0 14
25393: PUSH
25394: CALL_OW 44
25398: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25399: LD_ADDR_VAR 0 7
25403: PUSH
25404: LD_VAR 0 7
25408: PPUSH
25409: LD_INT 1
25411: PPUSH
25412: LD_VAR 0 14
25416: PPUSH
25417: CALL_OW 2
25421: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25422: LD_VAR 0 14
25426: PPUSH
25427: LD_VAR 0 12
25431: PUSH
25432: LD_INT 1
25434: ARRAY
25435: PPUSH
25436: CALL_OW 52
// end ;
25440: GO 25079
25442: POP
25443: POP
// end ;
25444: GO 24381
25446: POP
25447: POP
// result := result ^ buildings ;
25448: LD_ADDR_VAR 0 7
25452: PUSH
25453: LD_VAR 0 7
25457: PUSH
25458: LD_VAR 0 18
25462: ADD
25463: ST_TO_ADDR
// end else
25464: GO 25607
// begin for i = 1 to personel do
25466: LD_ADDR_VAR 0 8
25470: PUSH
25471: DOUBLE
25472: LD_INT 1
25474: DEC
25475: ST_TO_ADDR
25476: LD_VAR 0 6
25480: PUSH
25481: FOR_TO
25482: IFFALSE 25605
// begin if i > 4 then
25484: LD_VAR 0 8
25488: PUSH
25489: LD_INT 4
25491: GREATER
25492: IFFALSE 25496
// break ;
25494: GO 25605
// x := personel [ i ] ;
25496: LD_ADDR_VAR 0 13
25500: PUSH
25501: LD_VAR 0 6
25505: PUSH
25506: LD_VAR 0 8
25510: ARRAY
25511: ST_TO_ADDR
// if x = - 1 then
25512: LD_VAR 0 13
25516: PUSH
25517: LD_INT 1
25519: NEG
25520: EQUAL
25521: IFFALSE 25525
// continue ;
25523: GO 25481
// PrepareHuman ( false , i , skill ) ;
25525: LD_INT 0
25527: PPUSH
25528: LD_VAR 0 8
25532: PPUSH
25533: LD_VAR 0 4
25537: PPUSH
25538: CALL_OW 380
// un := CreateHuman ;
25542: LD_ADDR_VAR 0 14
25546: PUSH
25547: CALL_OW 44
25551: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25552: LD_VAR 0 14
25556: PPUSH
25557: LD_VAR 0 1
25561: PPUSH
25562: CALL_OW 250
25566: PPUSH
25567: LD_VAR 0 1
25571: PPUSH
25572: CALL_OW 251
25576: PPUSH
25577: LD_INT 10
25579: PPUSH
25580: LD_INT 0
25582: PPUSH
25583: CALL_OW 50
// result := result ^ un ;
25587: LD_ADDR_VAR 0 7
25591: PUSH
25592: LD_VAR 0 7
25596: PUSH
25597: LD_VAR 0 14
25601: ADD
25602: ST_TO_ADDR
// end ;
25603: GO 25481
25605: POP
25606: POP
// end ; end ;
25607: LD_VAR 0 7
25611: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25612: LD_INT 0
25614: PPUSH
25615: PPUSH
25616: PPUSH
25617: PPUSH
25618: PPUSH
25619: PPUSH
25620: PPUSH
25621: PPUSH
25622: PPUSH
25623: PPUSH
25624: PPUSH
25625: PPUSH
25626: PPUSH
25627: PPUSH
25628: PPUSH
25629: PPUSH
// result := false ;
25630: LD_ADDR_VAR 0 3
25634: PUSH
25635: LD_INT 0
25637: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25638: LD_VAR 0 1
25642: NOT
25643: PUSH
25644: LD_VAR 0 1
25648: PPUSH
25649: CALL_OW 266
25653: PUSH
25654: LD_INT 32
25656: PUSH
25657: LD_INT 33
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: IN
25664: NOT
25665: OR
25666: IFFALSE 25670
// exit ;
25668: GO 26806
// nat := GetNation ( tower ) ;
25670: LD_ADDR_VAR 0 12
25674: PUSH
25675: LD_VAR 0 1
25679: PPUSH
25680: CALL_OW 248
25684: ST_TO_ADDR
// side := GetSide ( tower ) ;
25685: LD_ADDR_VAR 0 16
25689: PUSH
25690: LD_VAR 0 1
25694: PPUSH
25695: CALL_OW 255
25699: ST_TO_ADDR
// x := GetX ( tower ) ;
25700: LD_ADDR_VAR 0 10
25704: PUSH
25705: LD_VAR 0 1
25709: PPUSH
25710: CALL_OW 250
25714: ST_TO_ADDR
// y := GetY ( tower ) ;
25715: LD_ADDR_VAR 0 11
25719: PUSH
25720: LD_VAR 0 1
25724: PPUSH
25725: CALL_OW 251
25729: ST_TO_ADDR
// if not x or not y then
25730: LD_VAR 0 10
25734: NOT
25735: PUSH
25736: LD_VAR 0 11
25740: NOT
25741: OR
25742: IFFALSE 25746
// exit ;
25744: GO 26806
// weapon := 0 ;
25746: LD_ADDR_VAR 0 18
25750: PUSH
25751: LD_INT 0
25753: ST_TO_ADDR
// fac_list := [ ] ;
25754: LD_ADDR_VAR 0 17
25758: PUSH
25759: EMPTY
25760: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
25761: LD_ADDR_VAR 0 6
25765: PUSH
25766: LD_VAR 0 1
25770: PPUSH
25771: CALL_OW 274
25775: PPUSH
25776: LD_VAR 0 2
25780: PPUSH
25781: CALL 23384 0 2
25785: PPUSH
25786: LD_INT 30
25788: PUSH
25789: LD_INT 3
25791: PUSH
25792: EMPTY
25793: LIST
25794: LIST
25795: PPUSH
25796: CALL_OW 72
25800: ST_TO_ADDR
// if not factories then
25801: LD_VAR 0 6
25805: NOT
25806: IFFALSE 25810
// exit ;
25808: GO 26806
// for i in factories do
25810: LD_ADDR_VAR 0 8
25814: PUSH
25815: LD_VAR 0 6
25819: PUSH
25820: FOR_IN
25821: IFFALSE 25846
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25823: LD_ADDR_VAR 0 17
25827: PUSH
25828: LD_VAR 0 17
25832: PUSH
25833: LD_VAR 0 8
25837: PPUSH
25838: CALL_OW 478
25842: UNION
25843: ST_TO_ADDR
25844: GO 25820
25846: POP
25847: POP
// if not fac_list then
25848: LD_VAR 0 17
25852: NOT
25853: IFFALSE 25857
// exit ;
25855: GO 26806
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25857: LD_ADDR_VAR 0 5
25861: PUSH
25862: LD_INT 4
25864: PUSH
25865: LD_INT 5
25867: PUSH
25868: LD_INT 9
25870: PUSH
25871: LD_INT 10
25873: PUSH
25874: LD_INT 6
25876: PUSH
25877: LD_INT 7
25879: PUSH
25880: LD_INT 11
25882: PUSH
25883: EMPTY
25884: LIST
25885: LIST
25886: LIST
25887: LIST
25888: LIST
25889: LIST
25890: LIST
25891: PUSH
25892: LD_INT 27
25894: PUSH
25895: LD_INT 28
25897: PUSH
25898: LD_INT 26
25900: PUSH
25901: LD_INT 30
25903: PUSH
25904: EMPTY
25905: LIST
25906: LIST
25907: LIST
25908: LIST
25909: PUSH
25910: LD_INT 43
25912: PUSH
25913: LD_INT 44
25915: PUSH
25916: LD_INT 46
25918: PUSH
25919: LD_INT 45
25921: PUSH
25922: LD_INT 47
25924: PUSH
25925: LD_INT 49
25927: PUSH
25928: EMPTY
25929: LIST
25930: LIST
25931: LIST
25932: LIST
25933: LIST
25934: LIST
25935: PUSH
25936: EMPTY
25937: LIST
25938: LIST
25939: LIST
25940: PUSH
25941: LD_VAR 0 12
25945: ARRAY
25946: ST_TO_ADDR
// for i in list do
25947: LD_ADDR_VAR 0 8
25951: PUSH
25952: LD_VAR 0 5
25956: PUSH
25957: FOR_IN
25958: IFFALSE 25991
// if not i in fac_list then
25960: LD_VAR 0 8
25964: PUSH
25965: LD_VAR 0 17
25969: IN
25970: NOT
25971: IFFALSE 25989
// list := list diff i ;
25973: LD_ADDR_VAR 0 5
25977: PUSH
25978: LD_VAR 0 5
25982: PUSH
25983: LD_VAR 0 8
25987: DIFF
25988: ST_TO_ADDR
25989: GO 25957
25991: POP
25992: POP
// if not list then
25993: LD_VAR 0 5
25997: NOT
25998: IFFALSE 26002
// exit ;
26000: GO 26806
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26002: LD_VAR 0 12
26006: PUSH
26007: LD_INT 3
26009: EQUAL
26010: PUSH
26011: LD_INT 49
26013: PUSH
26014: LD_VAR 0 5
26018: IN
26019: AND
26020: PUSH
26021: LD_INT 31
26023: PPUSH
26024: LD_VAR 0 16
26028: PPUSH
26029: CALL_OW 321
26033: PUSH
26034: LD_INT 2
26036: EQUAL
26037: AND
26038: IFFALSE 26098
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26040: LD_INT 22
26042: PUSH
26043: LD_VAR 0 16
26047: PUSH
26048: EMPTY
26049: LIST
26050: LIST
26051: PUSH
26052: LD_INT 35
26054: PUSH
26055: LD_INT 49
26057: PUSH
26058: EMPTY
26059: LIST
26060: LIST
26061: PUSH
26062: LD_INT 91
26064: PUSH
26065: LD_VAR 0 1
26069: PUSH
26070: LD_INT 10
26072: PUSH
26073: EMPTY
26074: LIST
26075: LIST
26076: LIST
26077: PUSH
26078: EMPTY
26079: LIST
26080: LIST
26081: LIST
26082: PPUSH
26083: CALL_OW 69
26087: NOT
26088: IFFALSE 26098
// weapon := ru_time_lapser ;
26090: LD_ADDR_VAR 0 18
26094: PUSH
26095: LD_INT 49
26097: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26098: LD_VAR 0 12
26102: PUSH
26103: LD_INT 1
26105: PUSH
26106: LD_INT 2
26108: PUSH
26109: EMPTY
26110: LIST
26111: LIST
26112: IN
26113: PUSH
26114: LD_INT 11
26116: PUSH
26117: LD_VAR 0 5
26121: IN
26122: PUSH
26123: LD_INT 30
26125: PUSH
26126: LD_VAR 0 5
26130: IN
26131: OR
26132: AND
26133: PUSH
26134: LD_INT 6
26136: PPUSH
26137: LD_VAR 0 16
26141: PPUSH
26142: CALL_OW 321
26146: PUSH
26147: LD_INT 2
26149: EQUAL
26150: AND
26151: IFFALSE 26316
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
26153: LD_INT 22
26155: PUSH
26156: LD_VAR 0 16
26160: PUSH
26161: EMPTY
26162: LIST
26163: LIST
26164: PUSH
26165: LD_INT 2
26167: PUSH
26168: LD_INT 35
26170: PUSH
26171: LD_INT 11
26173: PUSH
26174: EMPTY
26175: LIST
26176: LIST
26177: PUSH
26178: LD_INT 35
26180: PUSH
26181: LD_INT 30
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: PUSH
26188: EMPTY
26189: LIST
26190: LIST
26191: LIST
26192: PUSH
26193: LD_INT 91
26195: PUSH
26196: LD_VAR 0 1
26200: PUSH
26201: LD_INT 18
26203: PUSH
26204: EMPTY
26205: LIST
26206: LIST
26207: LIST
26208: PUSH
26209: EMPTY
26210: LIST
26211: LIST
26212: LIST
26213: PPUSH
26214: CALL_OW 69
26218: NOT
26219: PUSH
26220: LD_INT 22
26222: PUSH
26223: LD_VAR 0 16
26227: PUSH
26228: EMPTY
26229: LIST
26230: LIST
26231: PUSH
26232: LD_INT 2
26234: PUSH
26235: LD_INT 30
26237: PUSH
26238: LD_INT 32
26240: PUSH
26241: EMPTY
26242: LIST
26243: LIST
26244: PUSH
26245: LD_INT 30
26247: PUSH
26248: LD_INT 33
26250: PUSH
26251: EMPTY
26252: LIST
26253: LIST
26254: PUSH
26255: EMPTY
26256: LIST
26257: LIST
26258: LIST
26259: PUSH
26260: LD_INT 91
26262: PUSH
26263: LD_VAR 0 1
26267: PUSH
26268: LD_INT 12
26270: PUSH
26271: EMPTY
26272: LIST
26273: LIST
26274: LIST
26275: PUSH
26276: EMPTY
26277: LIST
26278: LIST
26279: LIST
26280: PUSH
26281: EMPTY
26282: LIST
26283: PPUSH
26284: CALL_OW 69
26288: PUSH
26289: LD_INT 2
26291: GREATER
26292: AND
26293: IFFALSE 26316
// weapon := [ us_radar , ar_radar ] [ nat ] ;
26295: LD_ADDR_VAR 0 18
26299: PUSH
26300: LD_INT 11
26302: PUSH
26303: LD_INT 30
26305: PUSH
26306: EMPTY
26307: LIST
26308: LIST
26309: PUSH
26310: LD_VAR 0 12
26314: ARRAY
26315: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
26316: LD_VAR 0 18
26320: NOT
26321: PUSH
26322: LD_INT 40
26324: PPUSH
26325: LD_VAR 0 16
26329: PPUSH
26330: CALL_OW 321
26334: PUSH
26335: LD_INT 2
26337: EQUAL
26338: AND
26339: PUSH
26340: LD_INT 7
26342: PUSH
26343: LD_VAR 0 5
26347: IN
26348: PUSH
26349: LD_INT 28
26351: PUSH
26352: LD_VAR 0 5
26356: IN
26357: OR
26358: PUSH
26359: LD_INT 45
26361: PUSH
26362: LD_VAR 0 5
26366: IN
26367: OR
26368: AND
26369: IFFALSE 26623
// begin hex := GetHexInfo ( x , y ) ;
26371: LD_ADDR_VAR 0 4
26375: PUSH
26376: LD_VAR 0 10
26380: PPUSH
26381: LD_VAR 0 11
26385: PPUSH
26386: CALL_OW 546
26390: ST_TO_ADDR
// if hex [ 1 ] then
26391: LD_VAR 0 4
26395: PUSH
26396: LD_INT 1
26398: ARRAY
26399: IFFALSE 26403
// exit ;
26401: GO 26806
// height := hex [ 2 ] ;
26403: LD_ADDR_VAR 0 15
26407: PUSH
26408: LD_VAR 0 4
26412: PUSH
26413: LD_INT 2
26415: ARRAY
26416: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26417: LD_ADDR_VAR 0 14
26421: PUSH
26422: LD_INT 0
26424: PUSH
26425: LD_INT 2
26427: PUSH
26428: LD_INT 3
26430: PUSH
26431: LD_INT 5
26433: PUSH
26434: EMPTY
26435: LIST
26436: LIST
26437: LIST
26438: LIST
26439: ST_TO_ADDR
// for i in tmp do
26440: LD_ADDR_VAR 0 8
26444: PUSH
26445: LD_VAR 0 14
26449: PUSH
26450: FOR_IN
26451: IFFALSE 26621
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26453: LD_ADDR_VAR 0 9
26457: PUSH
26458: LD_VAR 0 10
26462: PPUSH
26463: LD_VAR 0 8
26467: PPUSH
26468: LD_INT 5
26470: PPUSH
26471: CALL_OW 272
26475: PUSH
26476: LD_VAR 0 11
26480: PPUSH
26481: LD_VAR 0 8
26485: PPUSH
26486: LD_INT 5
26488: PPUSH
26489: CALL_OW 273
26493: PUSH
26494: EMPTY
26495: LIST
26496: LIST
26497: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26498: LD_VAR 0 9
26502: PUSH
26503: LD_INT 1
26505: ARRAY
26506: PPUSH
26507: LD_VAR 0 9
26511: PUSH
26512: LD_INT 2
26514: ARRAY
26515: PPUSH
26516: CALL_OW 488
26520: IFFALSE 26619
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26522: LD_ADDR_VAR 0 4
26526: PUSH
26527: LD_VAR 0 9
26531: PUSH
26532: LD_INT 1
26534: ARRAY
26535: PPUSH
26536: LD_VAR 0 9
26540: PUSH
26541: LD_INT 2
26543: ARRAY
26544: PPUSH
26545: CALL_OW 546
26549: ST_TO_ADDR
// if hex [ 1 ] then
26550: LD_VAR 0 4
26554: PUSH
26555: LD_INT 1
26557: ARRAY
26558: IFFALSE 26562
// continue ;
26560: GO 26450
// h := hex [ 2 ] ;
26562: LD_ADDR_VAR 0 13
26566: PUSH
26567: LD_VAR 0 4
26571: PUSH
26572: LD_INT 2
26574: ARRAY
26575: ST_TO_ADDR
// if h + 7 < height then
26576: LD_VAR 0 13
26580: PUSH
26581: LD_INT 7
26583: PLUS
26584: PUSH
26585: LD_VAR 0 15
26589: LESS
26590: IFFALSE 26619
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26592: LD_ADDR_VAR 0 18
26596: PUSH
26597: LD_INT 7
26599: PUSH
26600: LD_INT 28
26602: PUSH
26603: LD_INT 45
26605: PUSH
26606: EMPTY
26607: LIST
26608: LIST
26609: LIST
26610: PUSH
26611: LD_VAR 0 12
26615: ARRAY
26616: ST_TO_ADDR
// break ;
26617: GO 26621
// end ; end ; end ;
26619: GO 26450
26621: POP
26622: POP
// end ; if not weapon then
26623: LD_VAR 0 18
26627: NOT
26628: IFFALSE 26688
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26630: LD_ADDR_VAR 0 5
26634: PUSH
26635: LD_VAR 0 5
26639: PUSH
26640: LD_INT 11
26642: PUSH
26643: LD_INT 30
26645: PUSH
26646: LD_INT 49
26648: PUSH
26649: EMPTY
26650: LIST
26651: LIST
26652: LIST
26653: DIFF
26654: ST_TO_ADDR
// if not list then
26655: LD_VAR 0 5
26659: NOT
26660: IFFALSE 26664
// exit ;
26662: GO 26806
// weapon := list [ rand ( 1 , list ) ] ;
26664: LD_ADDR_VAR 0 18
26668: PUSH
26669: LD_VAR 0 5
26673: PUSH
26674: LD_INT 1
26676: PPUSH
26677: LD_VAR 0 5
26681: PPUSH
26682: CALL_OW 12
26686: ARRAY
26687: ST_TO_ADDR
// end ; if weapon then
26688: LD_VAR 0 18
26692: IFFALSE 26806
// begin tmp := CostOfWeapon ( weapon ) ;
26694: LD_ADDR_VAR 0 14
26698: PUSH
26699: LD_VAR 0 18
26703: PPUSH
26704: CALL_OW 451
26708: ST_TO_ADDR
// j := GetBase ( tower ) ;
26709: LD_ADDR_VAR 0 9
26713: PUSH
26714: LD_VAR 0 1
26718: PPUSH
26719: CALL_OW 274
26723: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26724: LD_VAR 0 9
26728: PPUSH
26729: LD_INT 1
26731: PPUSH
26732: CALL_OW 275
26736: PUSH
26737: LD_VAR 0 14
26741: PUSH
26742: LD_INT 1
26744: ARRAY
26745: GREATEREQUAL
26746: PUSH
26747: LD_VAR 0 9
26751: PPUSH
26752: LD_INT 2
26754: PPUSH
26755: CALL_OW 275
26759: PUSH
26760: LD_VAR 0 14
26764: PUSH
26765: LD_INT 2
26767: ARRAY
26768: GREATEREQUAL
26769: AND
26770: PUSH
26771: LD_VAR 0 9
26775: PPUSH
26776: LD_INT 3
26778: PPUSH
26779: CALL_OW 275
26783: PUSH
26784: LD_VAR 0 14
26788: PUSH
26789: LD_INT 3
26791: ARRAY
26792: GREATEREQUAL
26793: AND
26794: IFFALSE 26806
// result := weapon ;
26796: LD_ADDR_VAR 0 3
26800: PUSH
26801: LD_VAR 0 18
26805: ST_TO_ADDR
// end ; end ;
26806: LD_VAR 0 3
26810: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26811: LD_INT 0
26813: PPUSH
26814: PPUSH
// result := true ;
26815: LD_ADDR_VAR 0 3
26819: PUSH
26820: LD_INT 1
26822: ST_TO_ADDR
// if array1 = array2 then
26823: LD_VAR 0 1
26827: PUSH
26828: LD_VAR 0 2
26832: EQUAL
26833: IFFALSE 26893
// begin for i = 1 to array1 do
26835: LD_ADDR_VAR 0 4
26839: PUSH
26840: DOUBLE
26841: LD_INT 1
26843: DEC
26844: ST_TO_ADDR
26845: LD_VAR 0 1
26849: PUSH
26850: FOR_TO
26851: IFFALSE 26889
// if array1 [ i ] <> array2 [ i ] then
26853: LD_VAR 0 1
26857: PUSH
26858: LD_VAR 0 4
26862: ARRAY
26863: PUSH
26864: LD_VAR 0 2
26868: PUSH
26869: LD_VAR 0 4
26873: ARRAY
26874: NONEQUAL
26875: IFFALSE 26887
// begin result := false ;
26877: LD_ADDR_VAR 0 3
26881: PUSH
26882: LD_INT 0
26884: ST_TO_ADDR
// break ;
26885: GO 26889
// end ;
26887: GO 26850
26889: POP
26890: POP
// end else
26891: GO 26901
// result := false ;
26893: LD_ADDR_VAR 0 3
26897: PUSH
26898: LD_INT 0
26900: ST_TO_ADDR
// end ;
26901: LD_VAR 0 3
26905: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26906: LD_INT 0
26908: PPUSH
26909: PPUSH
26910: PPUSH
// pom := GetBase ( fac ) ;
26911: LD_ADDR_VAR 0 5
26915: PUSH
26916: LD_VAR 0 1
26920: PPUSH
26921: CALL_OW 274
26925: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26926: LD_ADDR_VAR 0 4
26930: PUSH
26931: LD_VAR 0 2
26935: PUSH
26936: LD_INT 1
26938: ARRAY
26939: PPUSH
26940: LD_VAR 0 2
26944: PUSH
26945: LD_INT 2
26947: ARRAY
26948: PPUSH
26949: LD_VAR 0 2
26953: PUSH
26954: LD_INT 3
26956: ARRAY
26957: PPUSH
26958: LD_VAR 0 2
26962: PUSH
26963: LD_INT 4
26965: ARRAY
26966: PPUSH
26967: CALL_OW 449
26971: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26972: LD_ADDR_VAR 0 3
26976: PUSH
26977: LD_VAR 0 5
26981: PPUSH
26982: LD_INT 1
26984: PPUSH
26985: CALL_OW 275
26989: PUSH
26990: LD_VAR 0 4
26994: PUSH
26995: LD_INT 1
26997: ARRAY
26998: GREATEREQUAL
26999: PUSH
27000: LD_VAR 0 5
27004: PPUSH
27005: LD_INT 2
27007: PPUSH
27008: CALL_OW 275
27012: PUSH
27013: LD_VAR 0 4
27017: PUSH
27018: LD_INT 2
27020: ARRAY
27021: GREATEREQUAL
27022: AND
27023: PUSH
27024: LD_VAR 0 5
27028: PPUSH
27029: LD_INT 3
27031: PPUSH
27032: CALL_OW 275
27036: PUSH
27037: LD_VAR 0 4
27041: PUSH
27042: LD_INT 3
27044: ARRAY
27045: GREATEREQUAL
27046: AND
27047: ST_TO_ADDR
// end ;
27048: LD_VAR 0 3
27052: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27053: LD_INT 0
27055: PPUSH
27056: PPUSH
27057: PPUSH
27058: PPUSH
// pom := GetBase ( building ) ;
27059: LD_ADDR_VAR 0 3
27063: PUSH
27064: LD_VAR 0 1
27068: PPUSH
27069: CALL_OW 274
27073: ST_TO_ADDR
// if not pom then
27074: LD_VAR 0 3
27078: NOT
27079: IFFALSE 27083
// exit ;
27081: GO 27253
// btype := GetBType ( building ) ;
27083: LD_ADDR_VAR 0 5
27087: PUSH
27088: LD_VAR 0 1
27092: PPUSH
27093: CALL_OW 266
27097: ST_TO_ADDR
// if btype = b_armoury then
27098: LD_VAR 0 5
27102: PUSH
27103: LD_INT 4
27105: EQUAL
27106: IFFALSE 27116
// btype := b_barracks ;
27108: LD_ADDR_VAR 0 5
27112: PUSH
27113: LD_INT 5
27115: ST_TO_ADDR
// if btype = b_depot then
27116: LD_VAR 0 5
27120: PUSH
27121: LD_INT 0
27123: EQUAL
27124: IFFALSE 27134
// btype := b_warehouse ;
27126: LD_ADDR_VAR 0 5
27130: PUSH
27131: LD_INT 1
27133: ST_TO_ADDR
// if btype = b_workshop then
27134: LD_VAR 0 5
27138: PUSH
27139: LD_INT 2
27141: EQUAL
27142: IFFALSE 27152
// btype := b_factory ;
27144: LD_ADDR_VAR 0 5
27148: PUSH
27149: LD_INT 3
27151: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27152: LD_ADDR_VAR 0 4
27156: PUSH
27157: LD_VAR 0 5
27161: PPUSH
27162: LD_VAR 0 1
27166: PPUSH
27167: CALL_OW 248
27171: PPUSH
27172: CALL_OW 450
27176: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27177: LD_ADDR_VAR 0 2
27181: PUSH
27182: LD_VAR 0 3
27186: PPUSH
27187: LD_INT 1
27189: PPUSH
27190: CALL_OW 275
27194: PUSH
27195: LD_VAR 0 4
27199: PUSH
27200: LD_INT 1
27202: ARRAY
27203: GREATEREQUAL
27204: PUSH
27205: LD_VAR 0 3
27209: PPUSH
27210: LD_INT 2
27212: PPUSH
27213: CALL_OW 275
27217: PUSH
27218: LD_VAR 0 4
27222: PUSH
27223: LD_INT 2
27225: ARRAY
27226: GREATEREQUAL
27227: AND
27228: PUSH
27229: LD_VAR 0 3
27233: PPUSH
27234: LD_INT 3
27236: PPUSH
27237: CALL_OW 275
27241: PUSH
27242: LD_VAR 0 4
27246: PUSH
27247: LD_INT 3
27249: ARRAY
27250: GREATEREQUAL
27251: AND
27252: ST_TO_ADDR
// end ;
27253: LD_VAR 0 2
27257: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
27258: LD_INT 0
27260: PPUSH
27261: PPUSH
27262: PPUSH
// pom := GetBase ( building ) ;
27263: LD_ADDR_VAR 0 4
27267: PUSH
27268: LD_VAR 0 1
27272: PPUSH
27273: CALL_OW 274
27277: ST_TO_ADDR
// if not pom then
27278: LD_VAR 0 4
27282: NOT
27283: IFFALSE 27287
// exit ;
27285: GO 27388
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27287: LD_ADDR_VAR 0 5
27291: PUSH
27292: LD_VAR 0 2
27296: PPUSH
27297: LD_VAR 0 1
27301: PPUSH
27302: CALL_OW 248
27306: PPUSH
27307: CALL_OW 450
27311: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27312: LD_ADDR_VAR 0 3
27316: PUSH
27317: LD_VAR 0 4
27321: PPUSH
27322: LD_INT 1
27324: PPUSH
27325: CALL_OW 275
27329: PUSH
27330: LD_VAR 0 5
27334: PUSH
27335: LD_INT 1
27337: ARRAY
27338: GREATEREQUAL
27339: PUSH
27340: LD_VAR 0 4
27344: PPUSH
27345: LD_INT 2
27347: PPUSH
27348: CALL_OW 275
27352: PUSH
27353: LD_VAR 0 5
27357: PUSH
27358: LD_INT 2
27360: ARRAY
27361: GREATEREQUAL
27362: AND
27363: PUSH
27364: LD_VAR 0 4
27368: PPUSH
27369: LD_INT 3
27371: PPUSH
27372: CALL_OW 275
27376: PUSH
27377: LD_VAR 0 5
27381: PUSH
27382: LD_INT 3
27384: ARRAY
27385: GREATEREQUAL
27386: AND
27387: ST_TO_ADDR
// end ;
27388: LD_VAR 0 3
27392: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
27393: LD_INT 0
27395: PPUSH
27396: PPUSH
27397: PPUSH
27398: PPUSH
27399: PPUSH
27400: PPUSH
27401: PPUSH
27402: PPUSH
27403: PPUSH
27404: PPUSH
// result := false ;
27405: LD_ADDR_VAR 0 6
27409: PUSH
27410: LD_INT 0
27412: ST_TO_ADDR
// if not base or not btype or not x or not y then
27413: LD_VAR 0 1
27417: NOT
27418: PUSH
27419: LD_VAR 0 2
27423: NOT
27424: OR
27425: PUSH
27426: LD_VAR 0 3
27430: NOT
27431: OR
27432: PUSH
27433: LD_VAR 0 4
27437: NOT
27438: OR
27439: IFFALSE 27443
// exit ;
27441: GO 28052
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
27443: LD_ADDR_VAR 0 12
27447: PUSH
27448: LD_VAR 0 2
27452: PPUSH
27453: LD_VAR 0 3
27457: PPUSH
27458: LD_VAR 0 4
27462: PPUSH
27463: LD_VAR 0 5
27467: PPUSH
27468: LD_VAR 0 1
27472: PUSH
27473: LD_INT 1
27475: ARRAY
27476: PPUSH
27477: CALL_OW 248
27481: PPUSH
27482: LD_INT 0
27484: PPUSH
27485: CALL 28889 0 6
27489: ST_TO_ADDR
// if not hexes then
27490: LD_VAR 0 12
27494: NOT
27495: IFFALSE 27499
// exit ;
27497: GO 28052
// for i = 1 to hexes do
27499: LD_ADDR_VAR 0 7
27503: PUSH
27504: DOUBLE
27505: LD_INT 1
27507: DEC
27508: ST_TO_ADDR
27509: LD_VAR 0 12
27513: PUSH
27514: FOR_TO
27515: IFFALSE 28050
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27517: LD_ADDR_VAR 0 11
27521: PUSH
27522: LD_VAR 0 12
27526: PUSH
27527: LD_VAR 0 7
27531: ARRAY
27532: PUSH
27533: LD_INT 1
27535: ARRAY
27536: PPUSH
27537: LD_VAR 0 12
27541: PUSH
27542: LD_VAR 0 7
27546: ARRAY
27547: PUSH
27548: LD_INT 2
27550: ARRAY
27551: PPUSH
27552: CALL_OW 428
27556: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27557: LD_VAR 0 12
27561: PUSH
27562: LD_VAR 0 7
27566: ARRAY
27567: PUSH
27568: LD_INT 1
27570: ARRAY
27571: PPUSH
27572: LD_VAR 0 12
27576: PUSH
27577: LD_VAR 0 7
27581: ARRAY
27582: PUSH
27583: LD_INT 2
27585: ARRAY
27586: PPUSH
27587: CALL_OW 351
27591: PUSH
27592: LD_VAR 0 12
27596: PUSH
27597: LD_VAR 0 7
27601: ARRAY
27602: PUSH
27603: LD_INT 1
27605: ARRAY
27606: PPUSH
27607: LD_VAR 0 12
27611: PUSH
27612: LD_VAR 0 7
27616: ARRAY
27617: PUSH
27618: LD_INT 2
27620: ARRAY
27621: PPUSH
27622: CALL_OW 488
27626: NOT
27627: OR
27628: PUSH
27629: LD_VAR 0 11
27633: PPUSH
27634: CALL_OW 247
27638: PUSH
27639: LD_INT 3
27641: EQUAL
27642: OR
27643: IFFALSE 27649
// exit ;
27645: POP
27646: POP
27647: GO 28052
// if not tmp or not tmp in base then
27649: LD_VAR 0 11
27653: NOT
27654: PUSH
27655: LD_VAR 0 11
27659: PUSH
27660: LD_VAR 0 1
27664: IN
27665: NOT
27666: OR
27667: IFFALSE 27671
// continue ;
27669: GO 27514
// result := true ;
27671: LD_ADDR_VAR 0 6
27675: PUSH
27676: LD_INT 1
27678: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27679: LD_ADDR_VAR 0 15
27683: PUSH
27684: LD_VAR 0 1
27688: PPUSH
27689: LD_INT 22
27691: PUSH
27692: LD_VAR 0 11
27696: PPUSH
27697: CALL_OW 255
27701: PUSH
27702: EMPTY
27703: LIST
27704: LIST
27705: PUSH
27706: LD_INT 2
27708: PUSH
27709: LD_INT 30
27711: PUSH
27712: LD_INT 0
27714: PUSH
27715: EMPTY
27716: LIST
27717: LIST
27718: PUSH
27719: LD_INT 30
27721: PUSH
27722: LD_INT 1
27724: PUSH
27725: EMPTY
27726: LIST
27727: LIST
27728: PUSH
27729: EMPTY
27730: LIST
27731: LIST
27732: LIST
27733: PUSH
27734: EMPTY
27735: LIST
27736: LIST
27737: PPUSH
27738: CALL_OW 72
27742: ST_TO_ADDR
// if dep then
27743: LD_VAR 0 15
27747: IFFALSE 27883
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27749: LD_ADDR_VAR 0 14
27753: PUSH
27754: LD_VAR 0 15
27758: PUSH
27759: LD_INT 1
27761: ARRAY
27762: PPUSH
27763: CALL_OW 250
27767: PPUSH
27768: LD_VAR 0 15
27772: PUSH
27773: LD_INT 1
27775: ARRAY
27776: PPUSH
27777: CALL_OW 254
27781: PPUSH
27782: LD_INT 5
27784: PPUSH
27785: CALL_OW 272
27789: PUSH
27790: LD_VAR 0 15
27794: PUSH
27795: LD_INT 1
27797: ARRAY
27798: PPUSH
27799: CALL_OW 251
27803: PPUSH
27804: LD_VAR 0 15
27808: PUSH
27809: LD_INT 1
27811: ARRAY
27812: PPUSH
27813: CALL_OW 254
27817: PPUSH
27818: LD_INT 5
27820: PPUSH
27821: CALL_OW 273
27825: PUSH
27826: EMPTY
27827: LIST
27828: LIST
27829: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27830: LD_VAR 0 14
27834: PUSH
27835: LD_INT 1
27837: ARRAY
27838: PPUSH
27839: LD_VAR 0 14
27843: PUSH
27844: LD_INT 2
27846: ARRAY
27847: PPUSH
27848: CALL_OW 488
27852: IFFALSE 27883
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27854: LD_VAR 0 11
27858: PPUSH
27859: LD_VAR 0 14
27863: PUSH
27864: LD_INT 1
27866: ARRAY
27867: PPUSH
27868: LD_VAR 0 14
27872: PUSH
27873: LD_INT 2
27875: ARRAY
27876: PPUSH
27877: CALL_OW 111
// continue ;
27881: GO 27514
// end ; end ; r := GetDir ( tmp ) ;
27883: LD_ADDR_VAR 0 13
27887: PUSH
27888: LD_VAR 0 11
27892: PPUSH
27893: CALL_OW 254
27897: ST_TO_ADDR
// if r = 5 then
27898: LD_VAR 0 13
27902: PUSH
27903: LD_INT 5
27905: EQUAL
27906: IFFALSE 27916
// r := 0 ;
27908: LD_ADDR_VAR 0 13
27912: PUSH
27913: LD_INT 0
27915: ST_TO_ADDR
// for j = r to 5 do
27916: LD_ADDR_VAR 0 8
27920: PUSH
27921: DOUBLE
27922: LD_VAR 0 13
27926: DEC
27927: ST_TO_ADDR
27928: LD_INT 5
27930: PUSH
27931: FOR_TO
27932: IFFALSE 28046
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27934: LD_ADDR_VAR 0 9
27938: PUSH
27939: LD_VAR 0 11
27943: PPUSH
27944: CALL_OW 250
27948: PPUSH
27949: LD_VAR 0 8
27953: PPUSH
27954: LD_INT 2
27956: PPUSH
27957: CALL_OW 272
27961: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27962: LD_ADDR_VAR 0 10
27966: PUSH
27967: LD_VAR 0 11
27971: PPUSH
27972: CALL_OW 251
27976: PPUSH
27977: LD_VAR 0 8
27981: PPUSH
27982: LD_INT 2
27984: PPUSH
27985: CALL_OW 273
27989: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27990: LD_VAR 0 9
27994: PPUSH
27995: LD_VAR 0 10
27999: PPUSH
28000: CALL_OW 488
28004: PUSH
28005: LD_VAR 0 9
28009: PPUSH
28010: LD_VAR 0 10
28014: PPUSH
28015: CALL_OW 428
28019: NOT
28020: AND
28021: IFFALSE 28044
// begin ComMoveXY ( tmp , _x , _y ) ;
28023: LD_VAR 0 11
28027: PPUSH
28028: LD_VAR 0 9
28032: PPUSH
28033: LD_VAR 0 10
28037: PPUSH
28038: CALL_OW 111
// break ;
28042: GO 28046
// end ; end ;
28044: GO 27931
28046: POP
28047: POP
// end ;
28048: GO 27514
28050: POP
28051: POP
// end ;
28052: LD_VAR 0 6
28056: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
28057: LD_INT 0
28059: PPUSH
28060: PPUSH
28061: PPUSH
28062: PPUSH
28063: PPUSH
28064: PPUSH
28065: PPUSH
28066: PPUSH
28067: PPUSH
28068: PPUSH
// result := false ;
28069: LD_ADDR_VAR 0 6
28073: PUSH
28074: LD_INT 0
28076: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28077: LD_VAR 0 1
28081: NOT
28082: PUSH
28083: LD_VAR 0 1
28087: PPUSH
28088: CALL_OW 266
28092: PUSH
28093: LD_INT 0
28095: PUSH
28096: LD_INT 1
28098: PUSH
28099: EMPTY
28100: LIST
28101: LIST
28102: IN
28103: NOT
28104: OR
28105: PUSH
28106: LD_VAR 0 2
28110: NOT
28111: OR
28112: PUSH
28113: LD_VAR 0 5
28117: PUSH
28118: LD_INT 0
28120: PUSH
28121: LD_INT 1
28123: PUSH
28124: LD_INT 2
28126: PUSH
28127: LD_INT 3
28129: PUSH
28130: LD_INT 4
28132: PUSH
28133: LD_INT 5
28135: PUSH
28136: EMPTY
28137: LIST
28138: LIST
28139: LIST
28140: LIST
28141: LIST
28142: LIST
28143: IN
28144: NOT
28145: OR
28146: PUSH
28147: LD_VAR 0 3
28151: PPUSH
28152: LD_VAR 0 4
28156: PPUSH
28157: CALL_OW 488
28161: NOT
28162: OR
28163: IFFALSE 28167
// exit ;
28165: GO 28884
// pom := GetBase ( depot ) ;
28167: LD_ADDR_VAR 0 10
28171: PUSH
28172: LD_VAR 0 1
28176: PPUSH
28177: CALL_OW 274
28181: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28182: LD_ADDR_VAR 0 11
28186: PUSH
28187: LD_VAR 0 2
28191: PPUSH
28192: LD_VAR 0 1
28196: PPUSH
28197: CALL_OW 248
28201: PPUSH
28202: CALL_OW 450
28206: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28207: LD_VAR 0 10
28211: PPUSH
28212: LD_INT 1
28214: PPUSH
28215: CALL_OW 275
28219: PUSH
28220: LD_VAR 0 11
28224: PUSH
28225: LD_INT 1
28227: ARRAY
28228: GREATEREQUAL
28229: PUSH
28230: LD_VAR 0 10
28234: PPUSH
28235: LD_INT 2
28237: PPUSH
28238: CALL_OW 275
28242: PUSH
28243: LD_VAR 0 11
28247: PUSH
28248: LD_INT 2
28250: ARRAY
28251: GREATEREQUAL
28252: AND
28253: PUSH
28254: LD_VAR 0 10
28258: PPUSH
28259: LD_INT 3
28261: PPUSH
28262: CALL_OW 275
28266: PUSH
28267: LD_VAR 0 11
28271: PUSH
28272: LD_INT 3
28274: ARRAY
28275: GREATEREQUAL
28276: AND
28277: NOT
28278: IFFALSE 28282
// exit ;
28280: GO 28884
// if GetBType ( depot ) = b_depot then
28282: LD_VAR 0 1
28286: PPUSH
28287: CALL_OW 266
28291: PUSH
28292: LD_INT 0
28294: EQUAL
28295: IFFALSE 28307
// dist := 28 else
28297: LD_ADDR_VAR 0 14
28301: PUSH
28302: LD_INT 28
28304: ST_TO_ADDR
28305: GO 28315
// dist := 36 ;
28307: LD_ADDR_VAR 0 14
28311: PUSH
28312: LD_INT 36
28314: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28315: LD_VAR 0 1
28319: PPUSH
28320: LD_VAR 0 3
28324: PPUSH
28325: LD_VAR 0 4
28329: PPUSH
28330: CALL_OW 297
28334: PUSH
28335: LD_VAR 0 14
28339: GREATER
28340: IFFALSE 28344
// exit ;
28342: GO 28884
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28344: LD_ADDR_VAR 0 12
28348: PUSH
28349: LD_VAR 0 2
28353: PPUSH
28354: LD_VAR 0 3
28358: PPUSH
28359: LD_VAR 0 4
28363: PPUSH
28364: LD_VAR 0 5
28368: PPUSH
28369: LD_VAR 0 1
28373: PPUSH
28374: CALL_OW 248
28378: PPUSH
28379: LD_INT 0
28381: PPUSH
28382: CALL 28889 0 6
28386: ST_TO_ADDR
// if not hexes then
28387: LD_VAR 0 12
28391: NOT
28392: IFFALSE 28396
// exit ;
28394: GO 28884
// hex := GetHexInfo ( x , y ) ;
28396: LD_ADDR_VAR 0 15
28400: PUSH
28401: LD_VAR 0 3
28405: PPUSH
28406: LD_VAR 0 4
28410: PPUSH
28411: CALL_OW 546
28415: ST_TO_ADDR
// if hex [ 1 ] then
28416: LD_VAR 0 15
28420: PUSH
28421: LD_INT 1
28423: ARRAY
28424: IFFALSE 28428
// exit ;
28426: GO 28884
// height := hex [ 2 ] ;
28428: LD_ADDR_VAR 0 13
28432: PUSH
28433: LD_VAR 0 15
28437: PUSH
28438: LD_INT 2
28440: ARRAY
28441: ST_TO_ADDR
// for i = 1 to hexes do
28442: LD_ADDR_VAR 0 7
28446: PUSH
28447: DOUBLE
28448: LD_INT 1
28450: DEC
28451: ST_TO_ADDR
28452: LD_VAR 0 12
28456: PUSH
28457: FOR_TO
28458: IFFALSE 28788
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28460: LD_VAR 0 12
28464: PUSH
28465: LD_VAR 0 7
28469: ARRAY
28470: PUSH
28471: LD_INT 1
28473: ARRAY
28474: PPUSH
28475: LD_VAR 0 12
28479: PUSH
28480: LD_VAR 0 7
28484: ARRAY
28485: PUSH
28486: LD_INT 2
28488: ARRAY
28489: PPUSH
28490: CALL_OW 488
28494: NOT
28495: PUSH
28496: LD_VAR 0 12
28500: PUSH
28501: LD_VAR 0 7
28505: ARRAY
28506: PUSH
28507: LD_INT 1
28509: ARRAY
28510: PPUSH
28511: LD_VAR 0 12
28515: PUSH
28516: LD_VAR 0 7
28520: ARRAY
28521: PUSH
28522: LD_INT 2
28524: ARRAY
28525: PPUSH
28526: CALL_OW 428
28530: PUSH
28531: LD_INT 0
28533: GREATER
28534: OR
28535: PUSH
28536: LD_VAR 0 12
28540: PUSH
28541: LD_VAR 0 7
28545: ARRAY
28546: PUSH
28547: LD_INT 1
28549: ARRAY
28550: PPUSH
28551: LD_VAR 0 12
28555: PUSH
28556: LD_VAR 0 7
28560: ARRAY
28561: PUSH
28562: LD_INT 2
28564: ARRAY
28565: PPUSH
28566: CALL_OW 351
28570: OR
28571: IFFALSE 28577
// exit ;
28573: POP
28574: POP
28575: GO 28884
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28577: LD_ADDR_VAR 0 8
28581: PUSH
28582: LD_VAR 0 12
28586: PUSH
28587: LD_VAR 0 7
28591: ARRAY
28592: PUSH
28593: LD_INT 1
28595: ARRAY
28596: PPUSH
28597: LD_VAR 0 12
28601: PUSH
28602: LD_VAR 0 7
28606: ARRAY
28607: PUSH
28608: LD_INT 2
28610: ARRAY
28611: PPUSH
28612: CALL_OW 546
28616: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28617: LD_VAR 0 8
28621: PUSH
28622: LD_INT 1
28624: ARRAY
28625: PUSH
28626: LD_VAR 0 8
28630: PUSH
28631: LD_INT 2
28633: ARRAY
28634: PUSH
28635: LD_VAR 0 13
28639: PUSH
28640: LD_INT 2
28642: PLUS
28643: GREATER
28644: OR
28645: PUSH
28646: LD_VAR 0 8
28650: PUSH
28651: LD_INT 2
28653: ARRAY
28654: PUSH
28655: LD_VAR 0 13
28659: PUSH
28660: LD_INT 2
28662: MINUS
28663: LESS
28664: OR
28665: PUSH
28666: LD_VAR 0 8
28670: PUSH
28671: LD_INT 3
28673: ARRAY
28674: PUSH
28675: LD_INT 0
28677: PUSH
28678: LD_INT 8
28680: PUSH
28681: LD_INT 9
28683: PUSH
28684: LD_INT 10
28686: PUSH
28687: LD_INT 11
28689: PUSH
28690: LD_INT 12
28692: PUSH
28693: LD_INT 13
28695: PUSH
28696: LD_INT 16
28698: PUSH
28699: LD_INT 17
28701: PUSH
28702: LD_INT 18
28704: PUSH
28705: LD_INT 19
28707: PUSH
28708: LD_INT 20
28710: PUSH
28711: LD_INT 21
28713: PUSH
28714: EMPTY
28715: LIST
28716: LIST
28717: LIST
28718: LIST
28719: LIST
28720: LIST
28721: LIST
28722: LIST
28723: LIST
28724: LIST
28725: LIST
28726: LIST
28727: LIST
28728: IN
28729: NOT
28730: OR
28731: PUSH
28732: LD_VAR 0 8
28736: PUSH
28737: LD_INT 5
28739: ARRAY
28740: NOT
28741: OR
28742: PUSH
28743: LD_VAR 0 8
28747: PUSH
28748: LD_INT 6
28750: ARRAY
28751: PUSH
28752: LD_INT 1
28754: PUSH
28755: LD_INT 2
28757: PUSH
28758: LD_INT 7
28760: PUSH
28761: LD_INT 9
28763: PUSH
28764: LD_INT 10
28766: PUSH
28767: LD_INT 11
28769: PUSH
28770: EMPTY
28771: LIST
28772: LIST
28773: LIST
28774: LIST
28775: LIST
28776: LIST
28777: IN
28778: NOT
28779: OR
28780: IFFALSE 28786
// exit ;
28782: POP
28783: POP
28784: GO 28884
// end ;
28786: GO 28457
28788: POP
28789: POP
// side := GetSide ( depot ) ;
28790: LD_ADDR_VAR 0 9
28794: PUSH
28795: LD_VAR 0 1
28799: PPUSH
28800: CALL_OW 255
28804: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28805: LD_VAR 0 9
28809: PPUSH
28810: LD_VAR 0 3
28814: PPUSH
28815: LD_VAR 0 4
28819: PPUSH
28820: LD_INT 20
28822: PPUSH
28823: CALL 21538 0 4
28827: PUSH
28828: LD_INT 4
28830: ARRAY
28831: IFFALSE 28835
// exit ;
28833: GO 28884
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28835: LD_VAR 0 2
28839: PUSH
28840: LD_INT 29
28842: PUSH
28843: LD_INT 30
28845: PUSH
28846: EMPTY
28847: LIST
28848: LIST
28849: IN
28850: PUSH
28851: LD_VAR 0 3
28855: PPUSH
28856: LD_VAR 0 4
28860: PPUSH
28861: LD_VAR 0 9
28865: PPUSH
28866: CALL_OW 440
28870: NOT
28871: AND
28872: IFFALSE 28876
// exit ;
28874: GO 28884
// result := true ;
28876: LD_ADDR_VAR 0 6
28880: PUSH
28881: LD_INT 1
28883: ST_TO_ADDR
// end ;
28884: LD_VAR 0 6
28888: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
28889: LD_INT 0
28891: PPUSH
28892: PPUSH
28893: PPUSH
28894: PPUSH
28895: PPUSH
28896: PPUSH
28897: PPUSH
28898: PPUSH
28899: PPUSH
28900: PPUSH
28901: PPUSH
28902: PPUSH
28903: PPUSH
28904: PPUSH
28905: PPUSH
28906: PPUSH
28907: PPUSH
28908: PPUSH
28909: PPUSH
28910: PPUSH
28911: PPUSH
28912: PPUSH
28913: PPUSH
28914: PPUSH
28915: PPUSH
28916: PPUSH
28917: PPUSH
28918: PPUSH
28919: PPUSH
28920: PPUSH
28921: PPUSH
28922: PPUSH
28923: PPUSH
28924: PPUSH
28925: PPUSH
28926: PPUSH
28927: PPUSH
28928: PPUSH
28929: PPUSH
28930: PPUSH
28931: PPUSH
28932: PPUSH
28933: PPUSH
28934: PPUSH
28935: PPUSH
28936: PPUSH
28937: PPUSH
28938: PPUSH
28939: PPUSH
28940: PPUSH
28941: PPUSH
28942: PPUSH
28943: PPUSH
28944: PPUSH
28945: PPUSH
28946: PPUSH
28947: PPUSH
28948: PPUSH
// result = [ ] ;
28949: LD_ADDR_VAR 0 7
28953: PUSH
28954: EMPTY
28955: ST_TO_ADDR
// temp_list = [ ] ;
28956: LD_ADDR_VAR 0 9
28960: PUSH
28961: EMPTY
28962: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28963: LD_VAR 0 4
28967: PUSH
28968: LD_INT 0
28970: PUSH
28971: LD_INT 1
28973: PUSH
28974: LD_INT 2
28976: PUSH
28977: LD_INT 3
28979: PUSH
28980: LD_INT 4
28982: PUSH
28983: LD_INT 5
28985: PUSH
28986: EMPTY
28987: LIST
28988: LIST
28989: LIST
28990: LIST
28991: LIST
28992: LIST
28993: IN
28994: NOT
28995: PUSH
28996: LD_VAR 0 1
29000: PUSH
29001: LD_INT 0
29003: PUSH
29004: LD_INT 1
29006: PUSH
29007: EMPTY
29008: LIST
29009: LIST
29010: IN
29011: PUSH
29012: LD_VAR 0 5
29016: PUSH
29017: LD_INT 1
29019: PUSH
29020: LD_INT 2
29022: PUSH
29023: LD_INT 3
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: LIST
29030: IN
29031: NOT
29032: AND
29033: OR
29034: IFFALSE 29038
// exit ;
29036: GO 47429
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29038: LD_VAR 0 1
29042: PUSH
29043: LD_INT 6
29045: PUSH
29046: LD_INT 7
29048: PUSH
29049: LD_INT 8
29051: PUSH
29052: LD_INT 13
29054: PUSH
29055: LD_INT 12
29057: PUSH
29058: LD_INT 15
29060: PUSH
29061: LD_INT 11
29063: PUSH
29064: LD_INT 14
29066: PUSH
29067: LD_INT 10
29069: PUSH
29070: EMPTY
29071: LIST
29072: LIST
29073: LIST
29074: LIST
29075: LIST
29076: LIST
29077: LIST
29078: LIST
29079: LIST
29080: IN
29081: IFFALSE 29091
// btype = b_lab ;
29083: LD_ADDR_VAR 0 1
29087: PUSH
29088: LD_INT 6
29090: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29091: LD_VAR 0 6
29095: PUSH
29096: LD_INT 0
29098: PUSH
29099: LD_INT 1
29101: PUSH
29102: LD_INT 2
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: LIST
29109: IN
29110: NOT
29111: PUSH
29112: LD_VAR 0 1
29116: PUSH
29117: LD_INT 0
29119: PUSH
29120: LD_INT 1
29122: PUSH
29123: LD_INT 2
29125: PUSH
29126: LD_INT 3
29128: PUSH
29129: LD_INT 6
29131: PUSH
29132: LD_INT 36
29134: PUSH
29135: LD_INT 4
29137: PUSH
29138: LD_INT 5
29140: PUSH
29141: LD_INT 31
29143: PUSH
29144: LD_INT 32
29146: PUSH
29147: LD_INT 33
29149: PUSH
29150: EMPTY
29151: LIST
29152: LIST
29153: LIST
29154: LIST
29155: LIST
29156: LIST
29157: LIST
29158: LIST
29159: LIST
29160: LIST
29161: LIST
29162: IN
29163: NOT
29164: PUSH
29165: LD_VAR 0 6
29169: PUSH
29170: LD_INT 1
29172: EQUAL
29173: AND
29174: OR
29175: PUSH
29176: LD_VAR 0 1
29180: PUSH
29181: LD_INT 2
29183: PUSH
29184: LD_INT 3
29186: PUSH
29187: EMPTY
29188: LIST
29189: LIST
29190: IN
29191: NOT
29192: PUSH
29193: LD_VAR 0 6
29197: PUSH
29198: LD_INT 2
29200: EQUAL
29201: AND
29202: OR
29203: IFFALSE 29213
// mode = 0 ;
29205: LD_ADDR_VAR 0 6
29209: PUSH
29210: LD_INT 0
29212: ST_TO_ADDR
// case mode of 0 :
29213: LD_VAR 0 6
29217: PUSH
29218: LD_INT 0
29220: DOUBLE
29221: EQUAL
29222: IFTRUE 29226
29224: GO 40679
29226: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29227: LD_ADDR_VAR 0 11
29231: PUSH
29232: LD_INT 0
29234: PUSH
29235: LD_INT 0
29237: PUSH
29238: EMPTY
29239: LIST
29240: LIST
29241: PUSH
29242: LD_INT 0
29244: PUSH
29245: LD_INT 1
29247: NEG
29248: PUSH
29249: EMPTY
29250: LIST
29251: LIST
29252: PUSH
29253: LD_INT 1
29255: PUSH
29256: LD_INT 0
29258: PUSH
29259: EMPTY
29260: LIST
29261: LIST
29262: PUSH
29263: LD_INT 1
29265: PUSH
29266: LD_INT 1
29268: PUSH
29269: EMPTY
29270: LIST
29271: LIST
29272: PUSH
29273: LD_INT 0
29275: PUSH
29276: LD_INT 1
29278: PUSH
29279: EMPTY
29280: LIST
29281: LIST
29282: PUSH
29283: LD_INT 1
29285: NEG
29286: PUSH
29287: LD_INT 0
29289: PUSH
29290: EMPTY
29291: LIST
29292: LIST
29293: PUSH
29294: LD_INT 1
29296: NEG
29297: PUSH
29298: LD_INT 1
29300: NEG
29301: PUSH
29302: EMPTY
29303: LIST
29304: LIST
29305: PUSH
29306: LD_INT 1
29308: NEG
29309: PUSH
29310: LD_INT 2
29312: NEG
29313: PUSH
29314: EMPTY
29315: LIST
29316: LIST
29317: PUSH
29318: LD_INT 0
29320: PUSH
29321: LD_INT 2
29323: NEG
29324: PUSH
29325: EMPTY
29326: LIST
29327: LIST
29328: PUSH
29329: LD_INT 1
29331: PUSH
29332: LD_INT 1
29334: NEG
29335: PUSH
29336: EMPTY
29337: LIST
29338: LIST
29339: PUSH
29340: LD_INT 1
29342: PUSH
29343: LD_INT 2
29345: PUSH
29346: EMPTY
29347: LIST
29348: LIST
29349: PUSH
29350: LD_INT 0
29352: PUSH
29353: LD_INT 2
29355: PUSH
29356: EMPTY
29357: LIST
29358: LIST
29359: PUSH
29360: LD_INT 1
29362: NEG
29363: PUSH
29364: LD_INT 1
29366: PUSH
29367: EMPTY
29368: LIST
29369: LIST
29370: PUSH
29371: LD_INT 1
29373: PUSH
29374: LD_INT 3
29376: PUSH
29377: EMPTY
29378: LIST
29379: LIST
29380: PUSH
29381: LD_INT 0
29383: PUSH
29384: LD_INT 3
29386: PUSH
29387: EMPTY
29388: LIST
29389: LIST
29390: PUSH
29391: LD_INT 1
29393: NEG
29394: PUSH
29395: LD_INT 2
29397: PUSH
29398: EMPTY
29399: LIST
29400: LIST
29401: PUSH
29402: EMPTY
29403: LIST
29404: LIST
29405: LIST
29406: LIST
29407: LIST
29408: LIST
29409: LIST
29410: LIST
29411: LIST
29412: LIST
29413: LIST
29414: LIST
29415: LIST
29416: LIST
29417: LIST
29418: LIST
29419: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29420: LD_ADDR_VAR 0 12
29424: PUSH
29425: LD_INT 0
29427: PUSH
29428: LD_INT 0
29430: PUSH
29431: EMPTY
29432: LIST
29433: LIST
29434: PUSH
29435: LD_INT 0
29437: PUSH
29438: LD_INT 1
29440: NEG
29441: PUSH
29442: EMPTY
29443: LIST
29444: LIST
29445: PUSH
29446: LD_INT 1
29448: PUSH
29449: LD_INT 0
29451: PUSH
29452: EMPTY
29453: LIST
29454: LIST
29455: PUSH
29456: LD_INT 1
29458: PUSH
29459: LD_INT 1
29461: PUSH
29462: EMPTY
29463: LIST
29464: LIST
29465: PUSH
29466: LD_INT 0
29468: PUSH
29469: LD_INT 1
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: PUSH
29476: LD_INT 1
29478: NEG
29479: PUSH
29480: LD_INT 0
29482: PUSH
29483: EMPTY
29484: LIST
29485: LIST
29486: PUSH
29487: LD_INT 1
29489: NEG
29490: PUSH
29491: LD_INT 1
29493: NEG
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: LD_INT 1
29501: PUSH
29502: LD_INT 1
29504: NEG
29505: PUSH
29506: EMPTY
29507: LIST
29508: LIST
29509: PUSH
29510: LD_INT 2
29512: PUSH
29513: LD_INT 0
29515: PUSH
29516: EMPTY
29517: LIST
29518: LIST
29519: PUSH
29520: LD_INT 2
29522: PUSH
29523: LD_INT 1
29525: PUSH
29526: EMPTY
29527: LIST
29528: LIST
29529: PUSH
29530: LD_INT 1
29532: NEG
29533: PUSH
29534: LD_INT 1
29536: PUSH
29537: EMPTY
29538: LIST
29539: LIST
29540: PUSH
29541: LD_INT 2
29543: NEG
29544: PUSH
29545: LD_INT 0
29547: PUSH
29548: EMPTY
29549: LIST
29550: LIST
29551: PUSH
29552: LD_INT 2
29554: NEG
29555: PUSH
29556: LD_INT 1
29558: NEG
29559: PUSH
29560: EMPTY
29561: LIST
29562: LIST
29563: PUSH
29564: LD_INT 2
29566: NEG
29567: PUSH
29568: LD_INT 1
29570: PUSH
29571: EMPTY
29572: LIST
29573: LIST
29574: PUSH
29575: LD_INT 3
29577: NEG
29578: PUSH
29579: LD_INT 0
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: LD_INT 3
29588: NEG
29589: PUSH
29590: LD_INT 1
29592: NEG
29593: PUSH
29594: EMPTY
29595: LIST
29596: LIST
29597: PUSH
29598: EMPTY
29599: LIST
29600: LIST
29601: LIST
29602: LIST
29603: LIST
29604: LIST
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: LIST
29611: LIST
29612: LIST
29613: LIST
29614: LIST
29615: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29616: LD_ADDR_VAR 0 13
29620: PUSH
29621: LD_INT 0
29623: PUSH
29624: LD_INT 0
29626: PUSH
29627: EMPTY
29628: LIST
29629: LIST
29630: PUSH
29631: LD_INT 0
29633: PUSH
29634: LD_INT 1
29636: NEG
29637: PUSH
29638: EMPTY
29639: LIST
29640: LIST
29641: PUSH
29642: LD_INT 1
29644: PUSH
29645: LD_INT 0
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PUSH
29652: LD_INT 1
29654: PUSH
29655: LD_INT 1
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: PUSH
29662: LD_INT 0
29664: PUSH
29665: LD_INT 1
29667: PUSH
29668: EMPTY
29669: LIST
29670: LIST
29671: PUSH
29672: LD_INT 1
29674: NEG
29675: PUSH
29676: LD_INT 0
29678: PUSH
29679: EMPTY
29680: LIST
29681: LIST
29682: PUSH
29683: LD_INT 1
29685: NEG
29686: PUSH
29687: LD_INT 1
29689: NEG
29690: PUSH
29691: EMPTY
29692: LIST
29693: LIST
29694: PUSH
29695: LD_INT 1
29697: NEG
29698: PUSH
29699: LD_INT 2
29701: NEG
29702: PUSH
29703: EMPTY
29704: LIST
29705: LIST
29706: PUSH
29707: LD_INT 2
29709: PUSH
29710: LD_INT 1
29712: PUSH
29713: EMPTY
29714: LIST
29715: LIST
29716: PUSH
29717: LD_INT 2
29719: PUSH
29720: LD_INT 2
29722: PUSH
29723: EMPTY
29724: LIST
29725: LIST
29726: PUSH
29727: LD_INT 1
29729: PUSH
29730: LD_INT 2
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: PUSH
29737: LD_INT 2
29739: NEG
29740: PUSH
29741: LD_INT 1
29743: NEG
29744: PUSH
29745: EMPTY
29746: LIST
29747: LIST
29748: PUSH
29749: LD_INT 2
29751: NEG
29752: PUSH
29753: LD_INT 2
29755: NEG
29756: PUSH
29757: EMPTY
29758: LIST
29759: LIST
29760: PUSH
29761: LD_INT 2
29763: NEG
29764: PUSH
29765: LD_INT 3
29767: NEG
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: PUSH
29773: LD_INT 3
29775: NEG
29776: PUSH
29777: LD_INT 2
29779: NEG
29780: PUSH
29781: EMPTY
29782: LIST
29783: LIST
29784: PUSH
29785: LD_INT 3
29787: NEG
29788: PUSH
29789: LD_INT 3
29791: NEG
29792: PUSH
29793: EMPTY
29794: LIST
29795: LIST
29796: PUSH
29797: EMPTY
29798: LIST
29799: LIST
29800: LIST
29801: LIST
29802: LIST
29803: LIST
29804: LIST
29805: LIST
29806: LIST
29807: LIST
29808: LIST
29809: LIST
29810: LIST
29811: LIST
29812: LIST
29813: LIST
29814: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29815: LD_ADDR_VAR 0 14
29819: PUSH
29820: LD_INT 0
29822: PUSH
29823: LD_INT 0
29825: PUSH
29826: EMPTY
29827: LIST
29828: LIST
29829: PUSH
29830: LD_INT 0
29832: PUSH
29833: LD_INT 1
29835: NEG
29836: PUSH
29837: EMPTY
29838: LIST
29839: LIST
29840: PUSH
29841: LD_INT 1
29843: PUSH
29844: LD_INT 0
29846: PUSH
29847: EMPTY
29848: LIST
29849: LIST
29850: PUSH
29851: LD_INT 1
29853: PUSH
29854: LD_INT 1
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: PUSH
29861: LD_INT 0
29863: PUSH
29864: LD_INT 1
29866: PUSH
29867: EMPTY
29868: LIST
29869: LIST
29870: PUSH
29871: LD_INT 1
29873: NEG
29874: PUSH
29875: LD_INT 0
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: LD_INT 1
29884: NEG
29885: PUSH
29886: LD_INT 1
29888: NEG
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 1
29896: NEG
29897: PUSH
29898: LD_INT 2
29900: NEG
29901: PUSH
29902: EMPTY
29903: LIST
29904: LIST
29905: PUSH
29906: LD_INT 0
29908: PUSH
29909: LD_INT 2
29911: NEG
29912: PUSH
29913: EMPTY
29914: LIST
29915: LIST
29916: PUSH
29917: LD_INT 1
29919: PUSH
29920: LD_INT 1
29922: NEG
29923: PUSH
29924: EMPTY
29925: LIST
29926: LIST
29927: PUSH
29928: LD_INT 1
29930: PUSH
29931: LD_INT 2
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: PUSH
29938: LD_INT 0
29940: PUSH
29941: LD_INT 2
29943: PUSH
29944: EMPTY
29945: LIST
29946: LIST
29947: PUSH
29948: LD_INT 1
29950: NEG
29951: PUSH
29952: LD_INT 1
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: PUSH
29959: LD_INT 1
29961: NEG
29962: PUSH
29963: LD_INT 3
29965: NEG
29966: PUSH
29967: EMPTY
29968: LIST
29969: LIST
29970: PUSH
29971: LD_INT 0
29973: PUSH
29974: LD_INT 3
29976: NEG
29977: PUSH
29978: EMPTY
29979: LIST
29980: LIST
29981: PUSH
29982: LD_INT 1
29984: PUSH
29985: LD_INT 2
29987: NEG
29988: PUSH
29989: EMPTY
29990: LIST
29991: LIST
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: LIST
29997: LIST
29998: LIST
29999: LIST
30000: LIST
30001: LIST
30002: LIST
30003: LIST
30004: LIST
30005: LIST
30006: LIST
30007: LIST
30008: LIST
30009: LIST
30010: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30011: LD_ADDR_VAR 0 15
30015: PUSH
30016: LD_INT 0
30018: PUSH
30019: LD_INT 0
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PUSH
30026: LD_INT 0
30028: PUSH
30029: LD_INT 1
30031: NEG
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: PUSH
30037: LD_INT 1
30039: PUSH
30040: LD_INT 0
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: LD_INT 1
30049: PUSH
30050: LD_INT 1
30052: PUSH
30053: EMPTY
30054: LIST
30055: LIST
30056: PUSH
30057: LD_INT 0
30059: PUSH
30060: LD_INT 1
30062: PUSH
30063: EMPTY
30064: LIST
30065: LIST
30066: PUSH
30067: LD_INT 1
30069: NEG
30070: PUSH
30071: LD_INT 0
30073: PUSH
30074: EMPTY
30075: LIST
30076: LIST
30077: PUSH
30078: LD_INT 1
30080: NEG
30081: PUSH
30082: LD_INT 1
30084: NEG
30085: PUSH
30086: EMPTY
30087: LIST
30088: LIST
30089: PUSH
30090: LD_INT 1
30092: PUSH
30093: LD_INT 1
30095: NEG
30096: PUSH
30097: EMPTY
30098: LIST
30099: LIST
30100: PUSH
30101: LD_INT 2
30103: PUSH
30104: LD_INT 0
30106: PUSH
30107: EMPTY
30108: LIST
30109: LIST
30110: PUSH
30111: LD_INT 2
30113: PUSH
30114: LD_INT 1
30116: PUSH
30117: EMPTY
30118: LIST
30119: LIST
30120: PUSH
30121: LD_INT 1
30123: NEG
30124: PUSH
30125: LD_INT 1
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PUSH
30132: LD_INT 2
30134: NEG
30135: PUSH
30136: LD_INT 0
30138: PUSH
30139: EMPTY
30140: LIST
30141: LIST
30142: PUSH
30143: LD_INT 2
30145: NEG
30146: PUSH
30147: LD_INT 1
30149: NEG
30150: PUSH
30151: EMPTY
30152: LIST
30153: LIST
30154: PUSH
30155: LD_INT 2
30157: PUSH
30158: LD_INT 1
30160: NEG
30161: PUSH
30162: EMPTY
30163: LIST
30164: LIST
30165: PUSH
30166: LD_INT 3
30168: PUSH
30169: LD_INT 0
30171: PUSH
30172: EMPTY
30173: LIST
30174: LIST
30175: PUSH
30176: LD_INT 3
30178: PUSH
30179: LD_INT 1
30181: PUSH
30182: EMPTY
30183: LIST
30184: LIST
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: LIST
30190: LIST
30191: LIST
30192: LIST
30193: LIST
30194: LIST
30195: LIST
30196: LIST
30197: LIST
30198: LIST
30199: LIST
30200: LIST
30201: LIST
30202: LIST
30203: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30204: LD_ADDR_VAR 0 16
30208: PUSH
30209: LD_INT 0
30211: PUSH
30212: LD_INT 0
30214: PUSH
30215: EMPTY
30216: LIST
30217: LIST
30218: PUSH
30219: LD_INT 0
30221: PUSH
30222: LD_INT 1
30224: NEG
30225: PUSH
30226: EMPTY
30227: LIST
30228: LIST
30229: PUSH
30230: LD_INT 1
30232: PUSH
30233: LD_INT 0
30235: PUSH
30236: EMPTY
30237: LIST
30238: LIST
30239: PUSH
30240: LD_INT 1
30242: PUSH
30243: LD_INT 1
30245: PUSH
30246: EMPTY
30247: LIST
30248: LIST
30249: PUSH
30250: LD_INT 0
30252: PUSH
30253: LD_INT 1
30255: PUSH
30256: EMPTY
30257: LIST
30258: LIST
30259: PUSH
30260: LD_INT 1
30262: NEG
30263: PUSH
30264: LD_INT 0
30266: PUSH
30267: EMPTY
30268: LIST
30269: LIST
30270: PUSH
30271: LD_INT 1
30273: NEG
30274: PUSH
30275: LD_INT 1
30277: NEG
30278: PUSH
30279: EMPTY
30280: LIST
30281: LIST
30282: PUSH
30283: LD_INT 1
30285: NEG
30286: PUSH
30287: LD_INT 2
30289: NEG
30290: PUSH
30291: EMPTY
30292: LIST
30293: LIST
30294: PUSH
30295: LD_INT 2
30297: PUSH
30298: LD_INT 1
30300: PUSH
30301: EMPTY
30302: LIST
30303: LIST
30304: PUSH
30305: LD_INT 2
30307: PUSH
30308: LD_INT 2
30310: PUSH
30311: EMPTY
30312: LIST
30313: LIST
30314: PUSH
30315: LD_INT 1
30317: PUSH
30318: LD_INT 2
30320: PUSH
30321: EMPTY
30322: LIST
30323: LIST
30324: PUSH
30325: LD_INT 2
30327: NEG
30328: PUSH
30329: LD_INT 1
30331: NEG
30332: PUSH
30333: EMPTY
30334: LIST
30335: LIST
30336: PUSH
30337: LD_INT 2
30339: NEG
30340: PUSH
30341: LD_INT 2
30343: NEG
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: PUSH
30349: LD_INT 3
30351: PUSH
30352: LD_INT 2
30354: PUSH
30355: EMPTY
30356: LIST
30357: LIST
30358: PUSH
30359: LD_INT 3
30361: PUSH
30362: LD_INT 3
30364: PUSH
30365: EMPTY
30366: LIST
30367: LIST
30368: PUSH
30369: LD_INT 2
30371: PUSH
30372: LD_INT 3
30374: PUSH
30375: EMPTY
30376: LIST
30377: LIST
30378: PUSH
30379: EMPTY
30380: LIST
30381: LIST
30382: LIST
30383: LIST
30384: LIST
30385: LIST
30386: LIST
30387: LIST
30388: LIST
30389: LIST
30390: LIST
30391: LIST
30392: LIST
30393: LIST
30394: LIST
30395: LIST
30396: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30397: LD_ADDR_VAR 0 17
30401: PUSH
30402: LD_INT 0
30404: PUSH
30405: LD_INT 0
30407: PUSH
30408: EMPTY
30409: LIST
30410: LIST
30411: PUSH
30412: LD_INT 0
30414: PUSH
30415: LD_INT 1
30417: NEG
30418: PUSH
30419: EMPTY
30420: LIST
30421: LIST
30422: PUSH
30423: LD_INT 1
30425: PUSH
30426: LD_INT 0
30428: PUSH
30429: EMPTY
30430: LIST
30431: LIST
30432: PUSH
30433: LD_INT 1
30435: PUSH
30436: LD_INT 1
30438: PUSH
30439: EMPTY
30440: LIST
30441: LIST
30442: PUSH
30443: LD_INT 0
30445: PUSH
30446: LD_INT 1
30448: PUSH
30449: EMPTY
30450: LIST
30451: LIST
30452: PUSH
30453: LD_INT 1
30455: NEG
30456: PUSH
30457: LD_INT 0
30459: PUSH
30460: EMPTY
30461: LIST
30462: LIST
30463: PUSH
30464: LD_INT 1
30466: NEG
30467: PUSH
30468: LD_INT 1
30470: NEG
30471: PUSH
30472: EMPTY
30473: LIST
30474: LIST
30475: PUSH
30476: LD_INT 1
30478: NEG
30479: PUSH
30480: LD_INT 2
30482: NEG
30483: PUSH
30484: EMPTY
30485: LIST
30486: LIST
30487: PUSH
30488: LD_INT 0
30490: PUSH
30491: LD_INT 2
30493: NEG
30494: PUSH
30495: EMPTY
30496: LIST
30497: LIST
30498: PUSH
30499: LD_INT 1
30501: PUSH
30502: LD_INT 1
30504: NEG
30505: PUSH
30506: EMPTY
30507: LIST
30508: LIST
30509: PUSH
30510: LD_INT 2
30512: PUSH
30513: LD_INT 0
30515: PUSH
30516: EMPTY
30517: LIST
30518: LIST
30519: PUSH
30520: LD_INT 2
30522: PUSH
30523: LD_INT 1
30525: PUSH
30526: EMPTY
30527: LIST
30528: LIST
30529: PUSH
30530: LD_INT 2
30532: PUSH
30533: LD_INT 2
30535: PUSH
30536: EMPTY
30537: LIST
30538: LIST
30539: PUSH
30540: LD_INT 1
30542: PUSH
30543: LD_INT 2
30545: PUSH
30546: EMPTY
30547: LIST
30548: LIST
30549: PUSH
30550: LD_INT 0
30552: PUSH
30553: LD_INT 2
30555: PUSH
30556: EMPTY
30557: LIST
30558: LIST
30559: PUSH
30560: LD_INT 1
30562: NEG
30563: PUSH
30564: LD_INT 1
30566: PUSH
30567: EMPTY
30568: LIST
30569: LIST
30570: PUSH
30571: LD_INT 2
30573: NEG
30574: PUSH
30575: LD_INT 0
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PUSH
30582: LD_INT 2
30584: NEG
30585: PUSH
30586: LD_INT 1
30588: NEG
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 2
30596: NEG
30597: PUSH
30598: LD_INT 2
30600: NEG
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: EMPTY
30607: LIST
30608: LIST
30609: LIST
30610: LIST
30611: LIST
30612: LIST
30613: LIST
30614: LIST
30615: LIST
30616: LIST
30617: LIST
30618: LIST
30619: LIST
30620: LIST
30621: LIST
30622: LIST
30623: LIST
30624: LIST
30625: LIST
30626: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30627: LD_ADDR_VAR 0 18
30631: PUSH
30632: LD_INT 0
30634: PUSH
30635: LD_INT 0
30637: PUSH
30638: EMPTY
30639: LIST
30640: LIST
30641: PUSH
30642: LD_INT 0
30644: PUSH
30645: LD_INT 1
30647: NEG
30648: PUSH
30649: EMPTY
30650: LIST
30651: LIST
30652: PUSH
30653: LD_INT 1
30655: PUSH
30656: LD_INT 0
30658: PUSH
30659: EMPTY
30660: LIST
30661: LIST
30662: PUSH
30663: LD_INT 1
30665: PUSH
30666: LD_INT 1
30668: PUSH
30669: EMPTY
30670: LIST
30671: LIST
30672: PUSH
30673: LD_INT 0
30675: PUSH
30676: LD_INT 1
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: LD_INT 1
30685: NEG
30686: PUSH
30687: LD_INT 0
30689: PUSH
30690: EMPTY
30691: LIST
30692: LIST
30693: PUSH
30694: LD_INT 1
30696: NEG
30697: PUSH
30698: LD_INT 1
30700: NEG
30701: PUSH
30702: EMPTY
30703: LIST
30704: LIST
30705: PUSH
30706: LD_INT 1
30708: NEG
30709: PUSH
30710: LD_INT 2
30712: NEG
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: LD_INT 0
30720: PUSH
30721: LD_INT 2
30723: NEG
30724: PUSH
30725: EMPTY
30726: LIST
30727: LIST
30728: PUSH
30729: LD_INT 1
30731: PUSH
30732: LD_INT 1
30734: NEG
30735: PUSH
30736: EMPTY
30737: LIST
30738: LIST
30739: PUSH
30740: LD_INT 2
30742: PUSH
30743: LD_INT 0
30745: PUSH
30746: EMPTY
30747: LIST
30748: LIST
30749: PUSH
30750: LD_INT 2
30752: PUSH
30753: LD_INT 1
30755: PUSH
30756: EMPTY
30757: LIST
30758: LIST
30759: PUSH
30760: LD_INT 2
30762: PUSH
30763: LD_INT 2
30765: PUSH
30766: EMPTY
30767: LIST
30768: LIST
30769: PUSH
30770: LD_INT 1
30772: PUSH
30773: LD_INT 2
30775: PUSH
30776: EMPTY
30777: LIST
30778: LIST
30779: PUSH
30780: LD_INT 0
30782: PUSH
30783: LD_INT 2
30785: PUSH
30786: EMPTY
30787: LIST
30788: LIST
30789: PUSH
30790: LD_INT 1
30792: NEG
30793: PUSH
30794: LD_INT 1
30796: PUSH
30797: EMPTY
30798: LIST
30799: LIST
30800: PUSH
30801: LD_INT 2
30803: NEG
30804: PUSH
30805: LD_INT 0
30807: PUSH
30808: EMPTY
30809: LIST
30810: LIST
30811: PUSH
30812: LD_INT 2
30814: NEG
30815: PUSH
30816: LD_INT 1
30818: NEG
30819: PUSH
30820: EMPTY
30821: LIST
30822: LIST
30823: PUSH
30824: LD_INT 2
30826: NEG
30827: PUSH
30828: LD_INT 2
30830: NEG
30831: PUSH
30832: EMPTY
30833: LIST
30834: LIST
30835: PUSH
30836: EMPTY
30837: LIST
30838: LIST
30839: LIST
30840: LIST
30841: LIST
30842: LIST
30843: LIST
30844: LIST
30845: LIST
30846: LIST
30847: LIST
30848: LIST
30849: LIST
30850: LIST
30851: LIST
30852: LIST
30853: LIST
30854: LIST
30855: LIST
30856: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30857: LD_ADDR_VAR 0 19
30861: PUSH
30862: LD_INT 0
30864: PUSH
30865: LD_INT 0
30867: PUSH
30868: EMPTY
30869: LIST
30870: LIST
30871: PUSH
30872: LD_INT 0
30874: PUSH
30875: LD_INT 1
30877: NEG
30878: PUSH
30879: EMPTY
30880: LIST
30881: LIST
30882: PUSH
30883: LD_INT 1
30885: PUSH
30886: LD_INT 0
30888: PUSH
30889: EMPTY
30890: LIST
30891: LIST
30892: PUSH
30893: LD_INT 1
30895: PUSH
30896: LD_INT 1
30898: PUSH
30899: EMPTY
30900: LIST
30901: LIST
30902: PUSH
30903: LD_INT 0
30905: PUSH
30906: LD_INT 1
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: LD_INT 1
30915: NEG
30916: PUSH
30917: LD_INT 0
30919: PUSH
30920: EMPTY
30921: LIST
30922: LIST
30923: PUSH
30924: LD_INT 1
30926: NEG
30927: PUSH
30928: LD_INT 1
30930: NEG
30931: PUSH
30932: EMPTY
30933: LIST
30934: LIST
30935: PUSH
30936: LD_INT 1
30938: NEG
30939: PUSH
30940: LD_INT 2
30942: NEG
30943: PUSH
30944: EMPTY
30945: LIST
30946: LIST
30947: PUSH
30948: LD_INT 0
30950: PUSH
30951: LD_INT 2
30953: NEG
30954: PUSH
30955: EMPTY
30956: LIST
30957: LIST
30958: PUSH
30959: LD_INT 1
30961: PUSH
30962: LD_INT 1
30964: NEG
30965: PUSH
30966: EMPTY
30967: LIST
30968: LIST
30969: PUSH
30970: LD_INT 2
30972: PUSH
30973: LD_INT 0
30975: PUSH
30976: EMPTY
30977: LIST
30978: LIST
30979: PUSH
30980: LD_INT 2
30982: PUSH
30983: LD_INT 1
30985: PUSH
30986: EMPTY
30987: LIST
30988: LIST
30989: PUSH
30990: LD_INT 2
30992: PUSH
30993: LD_INT 2
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: PUSH
31000: LD_INT 1
31002: PUSH
31003: LD_INT 2
31005: PUSH
31006: EMPTY
31007: LIST
31008: LIST
31009: PUSH
31010: LD_INT 0
31012: PUSH
31013: LD_INT 2
31015: PUSH
31016: EMPTY
31017: LIST
31018: LIST
31019: PUSH
31020: LD_INT 1
31022: NEG
31023: PUSH
31024: LD_INT 1
31026: PUSH
31027: EMPTY
31028: LIST
31029: LIST
31030: PUSH
31031: LD_INT 2
31033: NEG
31034: PUSH
31035: LD_INT 0
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PUSH
31042: LD_INT 2
31044: NEG
31045: PUSH
31046: LD_INT 1
31048: NEG
31049: PUSH
31050: EMPTY
31051: LIST
31052: LIST
31053: PUSH
31054: LD_INT 2
31056: NEG
31057: PUSH
31058: LD_INT 2
31060: NEG
31061: PUSH
31062: EMPTY
31063: LIST
31064: LIST
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: LIST
31070: LIST
31071: LIST
31072: LIST
31073: LIST
31074: LIST
31075: LIST
31076: LIST
31077: LIST
31078: LIST
31079: LIST
31080: LIST
31081: LIST
31082: LIST
31083: LIST
31084: LIST
31085: LIST
31086: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31087: LD_ADDR_VAR 0 20
31091: PUSH
31092: LD_INT 0
31094: PUSH
31095: LD_INT 0
31097: PUSH
31098: EMPTY
31099: LIST
31100: LIST
31101: PUSH
31102: LD_INT 0
31104: PUSH
31105: LD_INT 1
31107: NEG
31108: PUSH
31109: EMPTY
31110: LIST
31111: LIST
31112: PUSH
31113: LD_INT 1
31115: PUSH
31116: LD_INT 0
31118: PUSH
31119: EMPTY
31120: LIST
31121: LIST
31122: PUSH
31123: LD_INT 1
31125: PUSH
31126: LD_INT 1
31128: PUSH
31129: EMPTY
31130: LIST
31131: LIST
31132: PUSH
31133: LD_INT 0
31135: PUSH
31136: LD_INT 1
31138: PUSH
31139: EMPTY
31140: LIST
31141: LIST
31142: PUSH
31143: LD_INT 1
31145: NEG
31146: PUSH
31147: LD_INT 0
31149: PUSH
31150: EMPTY
31151: LIST
31152: LIST
31153: PUSH
31154: LD_INT 1
31156: NEG
31157: PUSH
31158: LD_INT 1
31160: NEG
31161: PUSH
31162: EMPTY
31163: LIST
31164: LIST
31165: PUSH
31166: LD_INT 1
31168: NEG
31169: PUSH
31170: LD_INT 2
31172: NEG
31173: PUSH
31174: EMPTY
31175: LIST
31176: LIST
31177: PUSH
31178: LD_INT 0
31180: PUSH
31181: LD_INT 2
31183: NEG
31184: PUSH
31185: EMPTY
31186: LIST
31187: LIST
31188: PUSH
31189: LD_INT 1
31191: PUSH
31192: LD_INT 1
31194: NEG
31195: PUSH
31196: EMPTY
31197: LIST
31198: LIST
31199: PUSH
31200: LD_INT 2
31202: PUSH
31203: LD_INT 0
31205: PUSH
31206: EMPTY
31207: LIST
31208: LIST
31209: PUSH
31210: LD_INT 2
31212: PUSH
31213: LD_INT 1
31215: PUSH
31216: EMPTY
31217: LIST
31218: LIST
31219: PUSH
31220: LD_INT 2
31222: PUSH
31223: LD_INT 2
31225: PUSH
31226: EMPTY
31227: LIST
31228: LIST
31229: PUSH
31230: LD_INT 1
31232: PUSH
31233: LD_INT 2
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: PUSH
31240: LD_INT 0
31242: PUSH
31243: LD_INT 2
31245: PUSH
31246: EMPTY
31247: LIST
31248: LIST
31249: PUSH
31250: LD_INT 1
31252: NEG
31253: PUSH
31254: LD_INT 1
31256: PUSH
31257: EMPTY
31258: LIST
31259: LIST
31260: PUSH
31261: LD_INT 2
31263: NEG
31264: PUSH
31265: LD_INT 0
31267: PUSH
31268: EMPTY
31269: LIST
31270: LIST
31271: PUSH
31272: LD_INT 2
31274: NEG
31275: PUSH
31276: LD_INT 1
31278: NEG
31279: PUSH
31280: EMPTY
31281: LIST
31282: LIST
31283: PUSH
31284: LD_INT 2
31286: NEG
31287: PUSH
31288: LD_INT 2
31290: NEG
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: LIST
31300: LIST
31301: LIST
31302: LIST
31303: LIST
31304: LIST
31305: LIST
31306: LIST
31307: LIST
31308: LIST
31309: LIST
31310: LIST
31311: LIST
31312: LIST
31313: LIST
31314: LIST
31315: LIST
31316: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31317: LD_ADDR_VAR 0 21
31321: PUSH
31322: LD_INT 0
31324: PUSH
31325: LD_INT 0
31327: PUSH
31328: EMPTY
31329: LIST
31330: LIST
31331: PUSH
31332: LD_INT 0
31334: PUSH
31335: LD_INT 1
31337: NEG
31338: PUSH
31339: EMPTY
31340: LIST
31341: LIST
31342: PUSH
31343: LD_INT 1
31345: PUSH
31346: LD_INT 0
31348: PUSH
31349: EMPTY
31350: LIST
31351: LIST
31352: PUSH
31353: LD_INT 1
31355: PUSH
31356: LD_INT 1
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PUSH
31363: LD_INT 0
31365: PUSH
31366: LD_INT 1
31368: PUSH
31369: EMPTY
31370: LIST
31371: LIST
31372: PUSH
31373: LD_INT 1
31375: NEG
31376: PUSH
31377: LD_INT 0
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: PUSH
31384: LD_INT 1
31386: NEG
31387: PUSH
31388: LD_INT 1
31390: NEG
31391: PUSH
31392: EMPTY
31393: LIST
31394: LIST
31395: PUSH
31396: LD_INT 1
31398: NEG
31399: PUSH
31400: LD_INT 2
31402: NEG
31403: PUSH
31404: EMPTY
31405: LIST
31406: LIST
31407: PUSH
31408: LD_INT 0
31410: PUSH
31411: LD_INT 2
31413: NEG
31414: PUSH
31415: EMPTY
31416: LIST
31417: LIST
31418: PUSH
31419: LD_INT 1
31421: PUSH
31422: LD_INT 1
31424: NEG
31425: PUSH
31426: EMPTY
31427: LIST
31428: LIST
31429: PUSH
31430: LD_INT 2
31432: PUSH
31433: LD_INT 0
31435: PUSH
31436: EMPTY
31437: LIST
31438: LIST
31439: PUSH
31440: LD_INT 2
31442: PUSH
31443: LD_INT 1
31445: PUSH
31446: EMPTY
31447: LIST
31448: LIST
31449: PUSH
31450: LD_INT 2
31452: PUSH
31453: LD_INT 2
31455: PUSH
31456: EMPTY
31457: LIST
31458: LIST
31459: PUSH
31460: LD_INT 1
31462: PUSH
31463: LD_INT 2
31465: PUSH
31466: EMPTY
31467: LIST
31468: LIST
31469: PUSH
31470: LD_INT 0
31472: PUSH
31473: LD_INT 2
31475: PUSH
31476: EMPTY
31477: LIST
31478: LIST
31479: PUSH
31480: LD_INT 1
31482: NEG
31483: PUSH
31484: LD_INT 1
31486: PUSH
31487: EMPTY
31488: LIST
31489: LIST
31490: PUSH
31491: LD_INT 2
31493: NEG
31494: PUSH
31495: LD_INT 0
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: PUSH
31502: LD_INT 2
31504: NEG
31505: PUSH
31506: LD_INT 1
31508: NEG
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 2
31516: NEG
31517: PUSH
31518: LD_INT 2
31520: NEG
31521: PUSH
31522: EMPTY
31523: LIST
31524: LIST
31525: PUSH
31526: EMPTY
31527: LIST
31528: LIST
31529: LIST
31530: LIST
31531: LIST
31532: LIST
31533: LIST
31534: LIST
31535: LIST
31536: LIST
31537: LIST
31538: LIST
31539: LIST
31540: LIST
31541: LIST
31542: LIST
31543: LIST
31544: LIST
31545: LIST
31546: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31547: LD_ADDR_VAR 0 22
31551: PUSH
31552: LD_INT 0
31554: PUSH
31555: LD_INT 0
31557: PUSH
31558: EMPTY
31559: LIST
31560: LIST
31561: PUSH
31562: LD_INT 0
31564: PUSH
31565: LD_INT 1
31567: NEG
31568: PUSH
31569: EMPTY
31570: LIST
31571: LIST
31572: PUSH
31573: LD_INT 1
31575: PUSH
31576: LD_INT 0
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 1
31585: PUSH
31586: LD_INT 1
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 0
31595: PUSH
31596: LD_INT 1
31598: PUSH
31599: EMPTY
31600: LIST
31601: LIST
31602: PUSH
31603: LD_INT 1
31605: NEG
31606: PUSH
31607: LD_INT 0
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: PUSH
31614: LD_INT 1
31616: NEG
31617: PUSH
31618: LD_INT 1
31620: NEG
31621: PUSH
31622: EMPTY
31623: LIST
31624: LIST
31625: PUSH
31626: LD_INT 1
31628: NEG
31629: PUSH
31630: LD_INT 2
31632: NEG
31633: PUSH
31634: EMPTY
31635: LIST
31636: LIST
31637: PUSH
31638: LD_INT 0
31640: PUSH
31641: LD_INT 2
31643: NEG
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: LD_INT 1
31651: PUSH
31652: LD_INT 1
31654: NEG
31655: PUSH
31656: EMPTY
31657: LIST
31658: LIST
31659: PUSH
31660: LD_INT 2
31662: PUSH
31663: LD_INT 0
31665: PUSH
31666: EMPTY
31667: LIST
31668: LIST
31669: PUSH
31670: LD_INT 2
31672: PUSH
31673: LD_INT 1
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: LD_INT 2
31682: PUSH
31683: LD_INT 2
31685: PUSH
31686: EMPTY
31687: LIST
31688: LIST
31689: PUSH
31690: LD_INT 1
31692: PUSH
31693: LD_INT 2
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 0
31702: PUSH
31703: LD_INT 2
31705: PUSH
31706: EMPTY
31707: LIST
31708: LIST
31709: PUSH
31710: LD_INT 1
31712: NEG
31713: PUSH
31714: LD_INT 1
31716: PUSH
31717: EMPTY
31718: LIST
31719: LIST
31720: PUSH
31721: LD_INT 2
31723: NEG
31724: PUSH
31725: LD_INT 0
31727: PUSH
31728: EMPTY
31729: LIST
31730: LIST
31731: PUSH
31732: LD_INT 2
31734: NEG
31735: PUSH
31736: LD_INT 1
31738: NEG
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: PUSH
31744: LD_INT 2
31746: NEG
31747: PUSH
31748: LD_INT 2
31750: NEG
31751: PUSH
31752: EMPTY
31753: LIST
31754: LIST
31755: PUSH
31756: EMPTY
31757: LIST
31758: LIST
31759: LIST
31760: LIST
31761: LIST
31762: LIST
31763: LIST
31764: LIST
31765: LIST
31766: LIST
31767: LIST
31768: LIST
31769: LIST
31770: LIST
31771: LIST
31772: LIST
31773: LIST
31774: LIST
31775: LIST
31776: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31777: LD_ADDR_VAR 0 23
31781: PUSH
31782: LD_INT 0
31784: PUSH
31785: LD_INT 0
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: PUSH
31792: LD_INT 0
31794: PUSH
31795: LD_INT 1
31797: NEG
31798: PUSH
31799: EMPTY
31800: LIST
31801: LIST
31802: PUSH
31803: LD_INT 1
31805: PUSH
31806: LD_INT 0
31808: PUSH
31809: EMPTY
31810: LIST
31811: LIST
31812: PUSH
31813: LD_INT 1
31815: PUSH
31816: LD_INT 1
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PUSH
31823: LD_INT 0
31825: PUSH
31826: LD_INT 1
31828: PUSH
31829: EMPTY
31830: LIST
31831: LIST
31832: PUSH
31833: LD_INT 1
31835: NEG
31836: PUSH
31837: LD_INT 0
31839: PUSH
31840: EMPTY
31841: LIST
31842: LIST
31843: PUSH
31844: LD_INT 1
31846: NEG
31847: PUSH
31848: LD_INT 1
31850: NEG
31851: PUSH
31852: EMPTY
31853: LIST
31854: LIST
31855: PUSH
31856: LD_INT 1
31858: NEG
31859: PUSH
31860: LD_INT 2
31862: NEG
31863: PUSH
31864: EMPTY
31865: LIST
31866: LIST
31867: PUSH
31868: LD_INT 0
31870: PUSH
31871: LD_INT 2
31873: NEG
31874: PUSH
31875: EMPTY
31876: LIST
31877: LIST
31878: PUSH
31879: LD_INT 1
31881: PUSH
31882: LD_INT 1
31884: NEG
31885: PUSH
31886: EMPTY
31887: LIST
31888: LIST
31889: PUSH
31890: LD_INT 2
31892: PUSH
31893: LD_INT 0
31895: PUSH
31896: EMPTY
31897: LIST
31898: LIST
31899: PUSH
31900: LD_INT 2
31902: PUSH
31903: LD_INT 1
31905: PUSH
31906: EMPTY
31907: LIST
31908: LIST
31909: PUSH
31910: LD_INT 2
31912: PUSH
31913: LD_INT 2
31915: PUSH
31916: EMPTY
31917: LIST
31918: LIST
31919: PUSH
31920: LD_INT 1
31922: PUSH
31923: LD_INT 2
31925: PUSH
31926: EMPTY
31927: LIST
31928: LIST
31929: PUSH
31930: LD_INT 0
31932: PUSH
31933: LD_INT 2
31935: PUSH
31936: EMPTY
31937: LIST
31938: LIST
31939: PUSH
31940: LD_INT 1
31942: NEG
31943: PUSH
31944: LD_INT 1
31946: PUSH
31947: EMPTY
31948: LIST
31949: LIST
31950: PUSH
31951: LD_INT 2
31953: NEG
31954: PUSH
31955: LD_INT 0
31957: PUSH
31958: EMPTY
31959: LIST
31960: LIST
31961: PUSH
31962: LD_INT 2
31964: NEG
31965: PUSH
31966: LD_INT 1
31968: NEG
31969: PUSH
31970: EMPTY
31971: LIST
31972: LIST
31973: PUSH
31974: LD_INT 2
31976: NEG
31977: PUSH
31978: LD_INT 2
31980: NEG
31981: PUSH
31982: EMPTY
31983: LIST
31984: LIST
31985: PUSH
31986: LD_INT 2
31988: NEG
31989: PUSH
31990: LD_INT 3
31992: NEG
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: PUSH
31998: LD_INT 1
32000: NEG
32001: PUSH
32002: LD_INT 3
32004: NEG
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PUSH
32010: LD_INT 1
32012: PUSH
32013: LD_INT 2
32015: NEG
32016: PUSH
32017: EMPTY
32018: LIST
32019: LIST
32020: PUSH
32021: LD_INT 2
32023: PUSH
32024: LD_INT 1
32026: NEG
32027: PUSH
32028: EMPTY
32029: LIST
32030: LIST
32031: PUSH
32032: EMPTY
32033: LIST
32034: LIST
32035: LIST
32036: LIST
32037: LIST
32038: LIST
32039: LIST
32040: LIST
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: LIST
32056: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32057: LD_ADDR_VAR 0 24
32061: PUSH
32062: LD_INT 0
32064: PUSH
32065: LD_INT 0
32067: PUSH
32068: EMPTY
32069: LIST
32070: LIST
32071: PUSH
32072: LD_INT 0
32074: PUSH
32075: LD_INT 1
32077: NEG
32078: PUSH
32079: EMPTY
32080: LIST
32081: LIST
32082: PUSH
32083: LD_INT 1
32085: PUSH
32086: LD_INT 0
32088: PUSH
32089: EMPTY
32090: LIST
32091: LIST
32092: PUSH
32093: LD_INT 1
32095: PUSH
32096: LD_INT 1
32098: PUSH
32099: EMPTY
32100: LIST
32101: LIST
32102: PUSH
32103: LD_INT 0
32105: PUSH
32106: LD_INT 1
32108: PUSH
32109: EMPTY
32110: LIST
32111: LIST
32112: PUSH
32113: LD_INT 1
32115: NEG
32116: PUSH
32117: LD_INT 0
32119: PUSH
32120: EMPTY
32121: LIST
32122: LIST
32123: PUSH
32124: LD_INT 1
32126: NEG
32127: PUSH
32128: LD_INT 1
32130: NEG
32131: PUSH
32132: EMPTY
32133: LIST
32134: LIST
32135: PUSH
32136: LD_INT 1
32138: NEG
32139: PUSH
32140: LD_INT 2
32142: NEG
32143: PUSH
32144: EMPTY
32145: LIST
32146: LIST
32147: PUSH
32148: LD_INT 0
32150: PUSH
32151: LD_INT 2
32153: NEG
32154: PUSH
32155: EMPTY
32156: LIST
32157: LIST
32158: PUSH
32159: LD_INT 1
32161: PUSH
32162: LD_INT 1
32164: NEG
32165: PUSH
32166: EMPTY
32167: LIST
32168: LIST
32169: PUSH
32170: LD_INT 2
32172: PUSH
32173: LD_INT 0
32175: PUSH
32176: EMPTY
32177: LIST
32178: LIST
32179: PUSH
32180: LD_INT 2
32182: PUSH
32183: LD_INT 1
32185: PUSH
32186: EMPTY
32187: LIST
32188: LIST
32189: PUSH
32190: LD_INT 2
32192: PUSH
32193: LD_INT 2
32195: PUSH
32196: EMPTY
32197: LIST
32198: LIST
32199: PUSH
32200: LD_INT 1
32202: PUSH
32203: LD_INT 2
32205: PUSH
32206: EMPTY
32207: LIST
32208: LIST
32209: PUSH
32210: LD_INT 0
32212: PUSH
32213: LD_INT 2
32215: PUSH
32216: EMPTY
32217: LIST
32218: LIST
32219: PUSH
32220: LD_INT 1
32222: NEG
32223: PUSH
32224: LD_INT 1
32226: PUSH
32227: EMPTY
32228: LIST
32229: LIST
32230: PUSH
32231: LD_INT 2
32233: NEG
32234: PUSH
32235: LD_INT 0
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 2
32244: NEG
32245: PUSH
32246: LD_INT 1
32248: NEG
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: PUSH
32254: LD_INT 2
32256: NEG
32257: PUSH
32258: LD_INT 2
32260: NEG
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: LD_INT 1
32268: PUSH
32269: LD_INT 2
32271: NEG
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 2
32279: PUSH
32280: LD_INT 1
32282: NEG
32283: PUSH
32284: EMPTY
32285: LIST
32286: LIST
32287: PUSH
32288: LD_INT 3
32290: PUSH
32291: LD_INT 1
32293: PUSH
32294: EMPTY
32295: LIST
32296: LIST
32297: PUSH
32298: LD_INT 3
32300: PUSH
32301: LD_INT 2
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: LIST
32312: LIST
32313: LIST
32314: LIST
32315: LIST
32316: LIST
32317: LIST
32318: LIST
32319: LIST
32320: LIST
32321: LIST
32322: LIST
32323: LIST
32324: LIST
32325: LIST
32326: LIST
32327: LIST
32328: LIST
32329: LIST
32330: LIST
32331: LIST
32332: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32333: LD_ADDR_VAR 0 25
32337: PUSH
32338: LD_INT 0
32340: PUSH
32341: LD_INT 0
32343: PUSH
32344: EMPTY
32345: LIST
32346: LIST
32347: PUSH
32348: LD_INT 0
32350: PUSH
32351: LD_INT 1
32353: NEG
32354: PUSH
32355: EMPTY
32356: LIST
32357: LIST
32358: PUSH
32359: LD_INT 1
32361: PUSH
32362: LD_INT 0
32364: PUSH
32365: EMPTY
32366: LIST
32367: LIST
32368: PUSH
32369: LD_INT 1
32371: PUSH
32372: LD_INT 1
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: PUSH
32379: LD_INT 0
32381: PUSH
32382: LD_INT 1
32384: PUSH
32385: EMPTY
32386: LIST
32387: LIST
32388: PUSH
32389: LD_INT 1
32391: NEG
32392: PUSH
32393: LD_INT 0
32395: PUSH
32396: EMPTY
32397: LIST
32398: LIST
32399: PUSH
32400: LD_INT 1
32402: NEG
32403: PUSH
32404: LD_INT 1
32406: NEG
32407: PUSH
32408: EMPTY
32409: LIST
32410: LIST
32411: PUSH
32412: LD_INT 1
32414: NEG
32415: PUSH
32416: LD_INT 2
32418: NEG
32419: PUSH
32420: EMPTY
32421: LIST
32422: LIST
32423: PUSH
32424: LD_INT 0
32426: PUSH
32427: LD_INT 2
32429: NEG
32430: PUSH
32431: EMPTY
32432: LIST
32433: LIST
32434: PUSH
32435: LD_INT 1
32437: PUSH
32438: LD_INT 1
32440: NEG
32441: PUSH
32442: EMPTY
32443: LIST
32444: LIST
32445: PUSH
32446: LD_INT 2
32448: PUSH
32449: LD_INT 0
32451: PUSH
32452: EMPTY
32453: LIST
32454: LIST
32455: PUSH
32456: LD_INT 2
32458: PUSH
32459: LD_INT 1
32461: PUSH
32462: EMPTY
32463: LIST
32464: LIST
32465: PUSH
32466: LD_INT 2
32468: PUSH
32469: LD_INT 2
32471: PUSH
32472: EMPTY
32473: LIST
32474: LIST
32475: PUSH
32476: LD_INT 1
32478: PUSH
32479: LD_INT 2
32481: PUSH
32482: EMPTY
32483: LIST
32484: LIST
32485: PUSH
32486: LD_INT 0
32488: PUSH
32489: LD_INT 2
32491: PUSH
32492: EMPTY
32493: LIST
32494: LIST
32495: PUSH
32496: LD_INT 1
32498: NEG
32499: PUSH
32500: LD_INT 1
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PUSH
32507: LD_INT 2
32509: NEG
32510: PUSH
32511: LD_INT 0
32513: PUSH
32514: EMPTY
32515: LIST
32516: LIST
32517: PUSH
32518: LD_INT 2
32520: NEG
32521: PUSH
32522: LD_INT 1
32524: NEG
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 2
32532: NEG
32533: PUSH
32534: LD_INT 2
32536: NEG
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 3
32544: PUSH
32545: LD_INT 1
32547: PUSH
32548: EMPTY
32549: LIST
32550: LIST
32551: PUSH
32552: LD_INT 3
32554: PUSH
32555: LD_INT 2
32557: PUSH
32558: EMPTY
32559: LIST
32560: LIST
32561: PUSH
32562: LD_INT 2
32564: PUSH
32565: LD_INT 3
32567: PUSH
32568: EMPTY
32569: LIST
32570: LIST
32571: PUSH
32572: LD_INT 1
32574: PUSH
32575: LD_INT 3
32577: PUSH
32578: EMPTY
32579: LIST
32580: LIST
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: LIST
32586: LIST
32587: LIST
32588: LIST
32589: LIST
32590: LIST
32591: LIST
32592: LIST
32593: LIST
32594: LIST
32595: LIST
32596: LIST
32597: LIST
32598: LIST
32599: LIST
32600: LIST
32601: LIST
32602: LIST
32603: LIST
32604: LIST
32605: LIST
32606: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32607: LD_ADDR_VAR 0 26
32611: PUSH
32612: LD_INT 0
32614: PUSH
32615: LD_INT 0
32617: PUSH
32618: EMPTY
32619: LIST
32620: LIST
32621: PUSH
32622: LD_INT 0
32624: PUSH
32625: LD_INT 1
32627: NEG
32628: PUSH
32629: EMPTY
32630: LIST
32631: LIST
32632: PUSH
32633: LD_INT 1
32635: PUSH
32636: LD_INT 0
32638: PUSH
32639: EMPTY
32640: LIST
32641: LIST
32642: PUSH
32643: LD_INT 1
32645: PUSH
32646: LD_INT 1
32648: PUSH
32649: EMPTY
32650: LIST
32651: LIST
32652: PUSH
32653: LD_INT 0
32655: PUSH
32656: LD_INT 1
32658: PUSH
32659: EMPTY
32660: LIST
32661: LIST
32662: PUSH
32663: LD_INT 1
32665: NEG
32666: PUSH
32667: LD_INT 0
32669: PUSH
32670: EMPTY
32671: LIST
32672: LIST
32673: PUSH
32674: LD_INT 1
32676: NEG
32677: PUSH
32678: LD_INT 1
32680: NEG
32681: PUSH
32682: EMPTY
32683: LIST
32684: LIST
32685: PUSH
32686: LD_INT 1
32688: NEG
32689: PUSH
32690: LD_INT 2
32692: NEG
32693: PUSH
32694: EMPTY
32695: LIST
32696: LIST
32697: PUSH
32698: LD_INT 0
32700: PUSH
32701: LD_INT 2
32703: NEG
32704: PUSH
32705: EMPTY
32706: LIST
32707: LIST
32708: PUSH
32709: LD_INT 1
32711: PUSH
32712: LD_INT 1
32714: NEG
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 2
32722: PUSH
32723: LD_INT 0
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: PUSH
32730: LD_INT 2
32732: PUSH
32733: LD_INT 1
32735: PUSH
32736: EMPTY
32737: LIST
32738: LIST
32739: PUSH
32740: LD_INT 2
32742: PUSH
32743: LD_INT 2
32745: PUSH
32746: EMPTY
32747: LIST
32748: LIST
32749: PUSH
32750: LD_INT 1
32752: PUSH
32753: LD_INT 2
32755: PUSH
32756: EMPTY
32757: LIST
32758: LIST
32759: PUSH
32760: LD_INT 0
32762: PUSH
32763: LD_INT 2
32765: PUSH
32766: EMPTY
32767: LIST
32768: LIST
32769: PUSH
32770: LD_INT 1
32772: NEG
32773: PUSH
32774: LD_INT 1
32776: PUSH
32777: EMPTY
32778: LIST
32779: LIST
32780: PUSH
32781: LD_INT 2
32783: NEG
32784: PUSH
32785: LD_INT 0
32787: PUSH
32788: EMPTY
32789: LIST
32790: LIST
32791: PUSH
32792: LD_INT 2
32794: NEG
32795: PUSH
32796: LD_INT 1
32798: NEG
32799: PUSH
32800: EMPTY
32801: LIST
32802: LIST
32803: PUSH
32804: LD_INT 2
32806: NEG
32807: PUSH
32808: LD_INT 2
32810: NEG
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: PUSH
32816: LD_INT 2
32818: PUSH
32819: LD_INT 3
32821: PUSH
32822: EMPTY
32823: LIST
32824: LIST
32825: PUSH
32826: LD_INT 1
32828: PUSH
32829: LD_INT 3
32831: PUSH
32832: EMPTY
32833: LIST
32834: LIST
32835: PUSH
32836: LD_INT 1
32838: NEG
32839: PUSH
32840: LD_INT 2
32842: PUSH
32843: EMPTY
32844: LIST
32845: LIST
32846: PUSH
32847: LD_INT 2
32849: NEG
32850: PUSH
32851: LD_INT 1
32853: PUSH
32854: EMPTY
32855: LIST
32856: LIST
32857: PUSH
32858: EMPTY
32859: LIST
32860: LIST
32861: LIST
32862: LIST
32863: LIST
32864: LIST
32865: LIST
32866: LIST
32867: LIST
32868: LIST
32869: LIST
32870: LIST
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: LIST
32876: LIST
32877: LIST
32878: LIST
32879: LIST
32880: LIST
32881: LIST
32882: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32883: LD_ADDR_VAR 0 27
32887: PUSH
32888: LD_INT 0
32890: PUSH
32891: LD_INT 0
32893: PUSH
32894: EMPTY
32895: LIST
32896: LIST
32897: PUSH
32898: LD_INT 0
32900: PUSH
32901: LD_INT 1
32903: NEG
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: LD_INT 1
32911: PUSH
32912: LD_INT 0
32914: PUSH
32915: EMPTY
32916: LIST
32917: LIST
32918: PUSH
32919: LD_INT 1
32921: PUSH
32922: LD_INT 1
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: PUSH
32929: LD_INT 0
32931: PUSH
32932: LD_INT 1
32934: PUSH
32935: EMPTY
32936: LIST
32937: LIST
32938: PUSH
32939: LD_INT 1
32941: NEG
32942: PUSH
32943: LD_INT 0
32945: PUSH
32946: EMPTY
32947: LIST
32948: LIST
32949: PUSH
32950: LD_INT 1
32952: NEG
32953: PUSH
32954: LD_INT 1
32956: NEG
32957: PUSH
32958: EMPTY
32959: LIST
32960: LIST
32961: PUSH
32962: LD_INT 1
32964: NEG
32965: PUSH
32966: LD_INT 2
32968: NEG
32969: PUSH
32970: EMPTY
32971: LIST
32972: LIST
32973: PUSH
32974: LD_INT 0
32976: PUSH
32977: LD_INT 2
32979: NEG
32980: PUSH
32981: EMPTY
32982: LIST
32983: LIST
32984: PUSH
32985: LD_INT 1
32987: PUSH
32988: LD_INT 1
32990: NEG
32991: PUSH
32992: EMPTY
32993: LIST
32994: LIST
32995: PUSH
32996: LD_INT 2
32998: PUSH
32999: LD_INT 0
33001: PUSH
33002: EMPTY
33003: LIST
33004: LIST
33005: PUSH
33006: LD_INT 2
33008: PUSH
33009: LD_INT 1
33011: PUSH
33012: EMPTY
33013: LIST
33014: LIST
33015: PUSH
33016: LD_INT 2
33018: PUSH
33019: LD_INT 2
33021: PUSH
33022: EMPTY
33023: LIST
33024: LIST
33025: PUSH
33026: LD_INT 1
33028: PUSH
33029: LD_INT 2
33031: PUSH
33032: EMPTY
33033: LIST
33034: LIST
33035: PUSH
33036: LD_INT 0
33038: PUSH
33039: LD_INT 2
33041: PUSH
33042: EMPTY
33043: LIST
33044: LIST
33045: PUSH
33046: LD_INT 1
33048: NEG
33049: PUSH
33050: LD_INT 1
33052: PUSH
33053: EMPTY
33054: LIST
33055: LIST
33056: PUSH
33057: LD_INT 2
33059: NEG
33060: PUSH
33061: LD_INT 0
33063: PUSH
33064: EMPTY
33065: LIST
33066: LIST
33067: PUSH
33068: LD_INT 2
33070: NEG
33071: PUSH
33072: LD_INT 1
33074: NEG
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: LD_INT 2
33082: NEG
33083: PUSH
33084: LD_INT 2
33086: NEG
33087: PUSH
33088: EMPTY
33089: LIST
33090: LIST
33091: PUSH
33092: LD_INT 1
33094: NEG
33095: PUSH
33096: LD_INT 2
33098: PUSH
33099: EMPTY
33100: LIST
33101: LIST
33102: PUSH
33103: LD_INT 2
33105: NEG
33106: PUSH
33107: LD_INT 1
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: PUSH
33114: LD_INT 3
33116: NEG
33117: PUSH
33118: LD_INT 1
33120: NEG
33121: PUSH
33122: EMPTY
33123: LIST
33124: LIST
33125: PUSH
33126: LD_INT 3
33128: NEG
33129: PUSH
33130: LD_INT 2
33132: NEG
33133: PUSH
33134: EMPTY
33135: LIST
33136: LIST
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: LIST
33142: LIST
33143: LIST
33144: LIST
33145: LIST
33146: LIST
33147: LIST
33148: LIST
33149: LIST
33150: LIST
33151: LIST
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33163: LD_ADDR_VAR 0 28
33167: PUSH
33168: LD_INT 0
33170: PUSH
33171: LD_INT 0
33173: PUSH
33174: EMPTY
33175: LIST
33176: LIST
33177: PUSH
33178: LD_INT 0
33180: PUSH
33181: LD_INT 1
33183: NEG
33184: PUSH
33185: EMPTY
33186: LIST
33187: LIST
33188: PUSH
33189: LD_INT 1
33191: PUSH
33192: LD_INT 0
33194: PUSH
33195: EMPTY
33196: LIST
33197: LIST
33198: PUSH
33199: LD_INT 1
33201: PUSH
33202: LD_INT 1
33204: PUSH
33205: EMPTY
33206: LIST
33207: LIST
33208: PUSH
33209: LD_INT 0
33211: PUSH
33212: LD_INT 1
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PUSH
33219: LD_INT 1
33221: NEG
33222: PUSH
33223: LD_INT 0
33225: PUSH
33226: EMPTY
33227: LIST
33228: LIST
33229: PUSH
33230: LD_INT 1
33232: NEG
33233: PUSH
33234: LD_INT 1
33236: NEG
33237: PUSH
33238: EMPTY
33239: LIST
33240: LIST
33241: PUSH
33242: LD_INT 1
33244: NEG
33245: PUSH
33246: LD_INT 2
33248: NEG
33249: PUSH
33250: EMPTY
33251: LIST
33252: LIST
33253: PUSH
33254: LD_INT 0
33256: PUSH
33257: LD_INT 2
33259: NEG
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: PUSH
33265: LD_INT 1
33267: PUSH
33268: LD_INT 1
33270: NEG
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 2
33278: PUSH
33279: LD_INT 0
33281: PUSH
33282: EMPTY
33283: LIST
33284: LIST
33285: PUSH
33286: LD_INT 2
33288: PUSH
33289: LD_INT 1
33291: PUSH
33292: EMPTY
33293: LIST
33294: LIST
33295: PUSH
33296: LD_INT 2
33298: PUSH
33299: LD_INT 2
33301: PUSH
33302: EMPTY
33303: LIST
33304: LIST
33305: PUSH
33306: LD_INT 1
33308: PUSH
33309: LD_INT 2
33311: PUSH
33312: EMPTY
33313: LIST
33314: LIST
33315: PUSH
33316: LD_INT 0
33318: PUSH
33319: LD_INT 2
33321: PUSH
33322: EMPTY
33323: LIST
33324: LIST
33325: PUSH
33326: LD_INT 1
33328: NEG
33329: PUSH
33330: LD_INT 1
33332: PUSH
33333: EMPTY
33334: LIST
33335: LIST
33336: PUSH
33337: LD_INT 2
33339: NEG
33340: PUSH
33341: LD_INT 0
33343: PUSH
33344: EMPTY
33345: LIST
33346: LIST
33347: PUSH
33348: LD_INT 2
33350: NEG
33351: PUSH
33352: LD_INT 1
33354: NEG
33355: PUSH
33356: EMPTY
33357: LIST
33358: LIST
33359: PUSH
33360: LD_INT 2
33362: NEG
33363: PUSH
33364: LD_INT 2
33366: NEG
33367: PUSH
33368: EMPTY
33369: LIST
33370: LIST
33371: PUSH
33372: LD_INT 2
33374: NEG
33375: PUSH
33376: LD_INT 3
33378: NEG
33379: PUSH
33380: EMPTY
33381: LIST
33382: LIST
33383: PUSH
33384: LD_INT 1
33386: NEG
33387: PUSH
33388: LD_INT 3
33390: NEG
33391: PUSH
33392: EMPTY
33393: LIST
33394: LIST
33395: PUSH
33396: LD_INT 3
33398: NEG
33399: PUSH
33400: LD_INT 1
33402: NEG
33403: PUSH
33404: EMPTY
33405: LIST
33406: LIST
33407: PUSH
33408: LD_INT 3
33410: NEG
33411: PUSH
33412: LD_INT 2
33414: NEG
33415: PUSH
33416: EMPTY
33417: LIST
33418: LIST
33419: PUSH
33420: EMPTY
33421: LIST
33422: LIST
33423: LIST
33424: LIST
33425: LIST
33426: LIST
33427: LIST
33428: LIST
33429: LIST
33430: LIST
33431: LIST
33432: LIST
33433: LIST
33434: LIST
33435: LIST
33436: LIST
33437: LIST
33438: LIST
33439: LIST
33440: LIST
33441: LIST
33442: LIST
33443: LIST
33444: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33445: LD_ADDR_VAR 0 29
33449: PUSH
33450: LD_INT 0
33452: PUSH
33453: LD_INT 0
33455: PUSH
33456: EMPTY
33457: LIST
33458: LIST
33459: PUSH
33460: LD_INT 0
33462: PUSH
33463: LD_INT 1
33465: NEG
33466: PUSH
33467: EMPTY
33468: LIST
33469: LIST
33470: PUSH
33471: LD_INT 1
33473: PUSH
33474: LD_INT 0
33476: PUSH
33477: EMPTY
33478: LIST
33479: LIST
33480: PUSH
33481: LD_INT 1
33483: PUSH
33484: LD_INT 1
33486: PUSH
33487: EMPTY
33488: LIST
33489: LIST
33490: PUSH
33491: LD_INT 0
33493: PUSH
33494: LD_INT 1
33496: PUSH
33497: EMPTY
33498: LIST
33499: LIST
33500: PUSH
33501: LD_INT 1
33503: NEG
33504: PUSH
33505: LD_INT 0
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: PUSH
33512: LD_INT 1
33514: NEG
33515: PUSH
33516: LD_INT 1
33518: NEG
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 1
33526: NEG
33527: PUSH
33528: LD_INT 2
33530: NEG
33531: PUSH
33532: EMPTY
33533: LIST
33534: LIST
33535: PUSH
33536: LD_INT 0
33538: PUSH
33539: LD_INT 2
33541: NEG
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 1
33549: PUSH
33550: LD_INT 1
33552: NEG
33553: PUSH
33554: EMPTY
33555: LIST
33556: LIST
33557: PUSH
33558: LD_INT 2
33560: PUSH
33561: LD_INT 0
33563: PUSH
33564: EMPTY
33565: LIST
33566: LIST
33567: PUSH
33568: LD_INT 2
33570: PUSH
33571: LD_INT 1
33573: PUSH
33574: EMPTY
33575: LIST
33576: LIST
33577: PUSH
33578: LD_INT 1
33580: PUSH
33581: LD_INT 2
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: PUSH
33588: LD_INT 0
33590: PUSH
33591: LD_INT 2
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PUSH
33598: LD_INT 1
33600: NEG
33601: PUSH
33602: LD_INT 1
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: PUSH
33609: LD_INT 2
33611: NEG
33612: PUSH
33613: LD_INT 1
33615: NEG
33616: PUSH
33617: EMPTY
33618: LIST
33619: LIST
33620: PUSH
33621: LD_INT 2
33623: NEG
33624: PUSH
33625: LD_INT 2
33627: NEG
33628: PUSH
33629: EMPTY
33630: LIST
33631: LIST
33632: PUSH
33633: LD_INT 2
33635: NEG
33636: PUSH
33637: LD_INT 3
33639: NEG
33640: PUSH
33641: EMPTY
33642: LIST
33643: LIST
33644: PUSH
33645: LD_INT 2
33647: PUSH
33648: LD_INT 1
33650: NEG
33651: PUSH
33652: EMPTY
33653: LIST
33654: LIST
33655: PUSH
33656: LD_INT 3
33658: PUSH
33659: LD_INT 1
33661: PUSH
33662: EMPTY
33663: LIST
33664: LIST
33665: PUSH
33666: LD_INT 1
33668: PUSH
33669: LD_INT 3
33671: PUSH
33672: EMPTY
33673: LIST
33674: LIST
33675: PUSH
33676: LD_INT 1
33678: NEG
33679: PUSH
33680: LD_INT 2
33682: PUSH
33683: EMPTY
33684: LIST
33685: LIST
33686: PUSH
33687: LD_INT 3
33689: NEG
33690: PUSH
33691: LD_INT 2
33693: NEG
33694: PUSH
33695: EMPTY
33696: LIST
33697: LIST
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: LIST
33703: LIST
33704: LIST
33705: LIST
33706: LIST
33707: LIST
33708: LIST
33709: LIST
33710: LIST
33711: LIST
33712: LIST
33713: LIST
33714: LIST
33715: LIST
33716: LIST
33717: LIST
33718: LIST
33719: LIST
33720: LIST
33721: LIST
33722: LIST
33723: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33724: LD_ADDR_VAR 0 30
33728: PUSH
33729: LD_INT 0
33731: PUSH
33732: LD_INT 0
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: PUSH
33739: LD_INT 0
33741: PUSH
33742: LD_INT 1
33744: NEG
33745: PUSH
33746: EMPTY
33747: LIST
33748: LIST
33749: PUSH
33750: LD_INT 1
33752: PUSH
33753: LD_INT 0
33755: PUSH
33756: EMPTY
33757: LIST
33758: LIST
33759: PUSH
33760: LD_INT 1
33762: PUSH
33763: LD_INT 1
33765: PUSH
33766: EMPTY
33767: LIST
33768: LIST
33769: PUSH
33770: LD_INT 0
33772: PUSH
33773: LD_INT 1
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PUSH
33780: LD_INT 1
33782: NEG
33783: PUSH
33784: LD_INT 0
33786: PUSH
33787: EMPTY
33788: LIST
33789: LIST
33790: PUSH
33791: LD_INT 1
33793: NEG
33794: PUSH
33795: LD_INT 1
33797: NEG
33798: PUSH
33799: EMPTY
33800: LIST
33801: LIST
33802: PUSH
33803: LD_INT 1
33805: NEG
33806: PUSH
33807: LD_INT 2
33809: NEG
33810: PUSH
33811: EMPTY
33812: LIST
33813: LIST
33814: PUSH
33815: LD_INT 0
33817: PUSH
33818: LD_INT 2
33820: NEG
33821: PUSH
33822: EMPTY
33823: LIST
33824: LIST
33825: PUSH
33826: LD_INT 1
33828: PUSH
33829: LD_INT 1
33831: NEG
33832: PUSH
33833: EMPTY
33834: LIST
33835: LIST
33836: PUSH
33837: LD_INT 2
33839: PUSH
33840: LD_INT 0
33842: PUSH
33843: EMPTY
33844: LIST
33845: LIST
33846: PUSH
33847: LD_INT 2
33849: PUSH
33850: LD_INT 1
33852: PUSH
33853: EMPTY
33854: LIST
33855: LIST
33856: PUSH
33857: LD_INT 2
33859: PUSH
33860: LD_INT 2
33862: PUSH
33863: EMPTY
33864: LIST
33865: LIST
33866: PUSH
33867: LD_INT 1
33869: PUSH
33870: LD_INT 2
33872: PUSH
33873: EMPTY
33874: LIST
33875: LIST
33876: PUSH
33877: LD_INT 1
33879: NEG
33880: PUSH
33881: LD_INT 1
33883: PUSH
33884: EMPTY
33885: LIST
33886: LIST
33887: PUSH
33888: LD_INT 2
33890: NEG
33891: PUSH
33892: LD_INT 0
33894: PUSH
33895: EMPTY
33896: LIST
33897: LIST
33898: PUSH
33899: LD_INT 2
33901: NEG
33902: PUSH
33903: LD_INT 1
33905: NEG
33906: PUSH
33907: EMPTY
33908: LIST
33909: LIST
33910: PUSH
33911: LD_INT 1
33913: NEG
33914: PUSH
33915: LD_INT 3
33917: NEG
33918: PUSH
33919: EMPTY
33920: LIST
33921: LIST
33922: PUSH
33923: LD_INT 1
33925: PUSH
33926: LD_INT 2
33928: NEG
33929: PUSH
33930: EMPTY
33931: LIST
33932: LIST
33933: PUSH
33934: LD_INT 3
33936: PUSH
33937: LD_INT 2
33939: PUSH
33940: EMPTY
33941: LIST
33942: LIST
33943: PUSH
33944: LD_INT 2
33946: PUSH
33947: LD_INT 3
33949: PUSH
33950: EMPTY
33951: LIST
33952: LIST
33953: PUSH
33954: LD_INT 2
33956: NEG
33957: PUSH
33958: LD_INT 1
33960: PUSH
33961: EMPTY
33962: LIST
33963: LIST
33964: PUSH
33965: LD_INT 3
33967: NEG
33968: PUSH
33969: LD_INT 1
33971: NEG
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: LIST
33981: LIST
33982: LIST
33983: LIST
33984: LIST
33985: LIST
33986: LIST
33987: LIST
33988: LIST
33989: LIST
33990: LIST
33991: LIST
33992: LIST
33993: LIST
33994: LIST
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: LIST
34000: LIST
34001: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34002: LD_ADDR_VAR 0 31
34006: PUSH
34007: LD_INT 0
34009: PUSH
34010: LD_INT 0
34012: PUSH
34013: EMPTY
34014: LIST
34015: LIST
34016: PUSH
34017: LD_INT 0
34019: PUSH
34020: LD_INT 1
34022: NEG
34023: PUSH
34024: EMPTY
34025: LIST
34026: LIST
34027: PUSH
34028: LD_INT 1
34030: PUSH
34031: LD_INT 0
34033: PUSH
34034: EMPTY
34035: LIST
34036: LIST
34037: PUSH
34038: LD_INT 1
34040: PUSH
34041: LD_INT 1
34043: PUSH
34044: EMPTY
34045: LIST
34046: LIST
34047: PUSH
34048: LD_INT 0
34050: PUSH
34051: LD_INT 1
34053: PUSH
34054: EMPTY
34055: LIST
34056: LIST
34057: PUSH
34058: LD_INT 1
34060: NEG
34061: PUSH
34062: LD_INT 0
34064: PUSH
34065: EMPTY
34066: LIST
34067: LIST
34068: PUSH
34069: LD_INT 1
34071: NEG
34072: PUSH
34073: LD_INT 1
34075: NEG
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 1
34083: NEG
34084: PUSH
34085: LD_INT 2
34087: NEG
34088: PUSH
34089: EMPTY
34090: LIST
34091: LIST
34092: PUSH
34093: LD_INT 1
34095: PUSH
34096: LD_INT 1
34098: NEG
34099: PUSH
34100: EMPTY
34101: LIST
34102: LIST
34103: PUSH
34104: LD_INT 2
34106: PUSH
34107: LD_INT 0
34109: PUSH
34110: EMPTY
34111: LIST
34112: LIST
34113: PUSH
34114: LD_INT 2
34116: PUSH
34117: LD_INT 1
34119: PUSH
34120: EMPTY
34121: LIST
34122: LIST
34123: PUSH
34124: LD_INT 2
34126: PUSH
34127: LD_INT 2
34129: PUSH
34130: EMPTY
34131: LIST
34132: LIST
34133: PUSH
34134: LD_INT 1
34136: PUSH
34137: LD_INT 2
34139: PUSH
34140: EMPTY
34141: LIST
34142: LIST
34143: PUSH
34144: LD_INT 0
34146: PUSH
34147: LD_INT 2
34149: PUSH
34150: EMPTY
34151: LIST
34152: LIST
34153: PUSH
34154: LD_INT 1
34156: NEG
34157: PUSH
34158: LD_INT 1
34160: PUSH
34161: EMPTY
34162: LIST
34163: LIST
34164: PUSH
34165: LD_INT 2
34167: NEG
34168: PUSH
34169: LD_INT 1
34171: NEG
34172: PUSH
34173: EMPTY
34174: LIST
34175: LIST
34176: PUSH
34177: LD_INT 2
34179: NEG
34180: PUSH
34181: LD_INT 2
34183: NEG
34184: PUSH
34185: EMPTY
34186: LIST
34187: LIST
34188: PUSH
34189: LD_INT 2
34191: NEG
34192: PUSH
34193: LD_INT 3
34195: NEG
34196: PUSH
34197: EMPTY
34198: LIST
34199: LIST
34200: PUSH
34201: LD_INT 2
34203: PUSH
34204: LD_INT 1
34206: NEG
34207: PUSH
34208: EMPTY
34209: LIST
34210: LIST
34211: PUSH
34212: LD_INT 3
34214: PUSH
34215: LD_INT 1
34217: PUSH
34218: EMPTY
34219: LIST
34220: LIST
34221: PUSH
34222: LD_INT 1
34224: PUSH
34225: LD_INT 3
34227: PUSH
34228: EMPTY
34229: LIST
34230: LIST
34231: PUSH
34232: LD_INT 1
34234: NEG
34235: PUSH
34236: LD_INT 2
34238: PUSH
34239: EMPTY
34240: LIST
34241: LIST
34242: PUSH
34243: LD_INT 3
34245: NEG
34246: PUSH
34247: LD_INT 2
34249: NEG
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: LIST
34259: LIST
34260: LIST
34261: LIST
34262: LIST
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: LIST
34279: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34280: LD_ADDR_VAR 0 32
34284: PUSH
34285: LD_INT 0
34287: PUSH
34288: LD_INT 0
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 0
34297: PUSH
34298: LD_INT 1
34300: NEG
34301: PUSH
34302: EMPTY
34303: LIST
34304: LIST
34305: PUSH
34306: LD_INT 1
34308: PUSH
34309: LD_INT 0
34311: PUSH
34312: EMPTY
34313: LIST
34314: LIST
34315: PUSH
34316: LD_INT 1
34318: PUSH
34319: LD_INT 1
34321: PUSH
34322: EMPTY
34323: LIST
34324: LIST
34325: PUSH
34326: LD_INT 0
34328: PUSH
34329: LD_INT 1
34331: PUSH
34332: EMPTY
34333: LIST
34334: LIST
34335: PUSH
34336: LD_INT 1
34338: NEG
34339: PUSH
34340: LD_INT 0
34342: PUSH
34343: EMPTY
34344: LIST
34345: LIST
34346: PUSH
34347: LD_INT 1
34349: NEG
34350: PUSH
34351: LD_INT 1
34353: NEG
34354: PUSH
34355: EMPTY
34356: LIST
34357: LIST
34358: PUSH
34359: LD_INT 1
34361: NEG
34362: PUSH
34363: LD_INT 2
34365: NEG
34366: PUSH
34367: EMPTY
34368: LIST
34369: LIST
34370: PUSH
34371: LD_INT 0
34373: PUSH
34374: LD_INT 2
34376: NEG
34377: PUSH
34378: EMPTY
34379: LIST
34380: LIST
34381: PUSH
34382: LD_INT 1
34384: PUSH
34385: LD_INT 1
34387: NEG
34388: PUSH
34389: EMPTY
34390: LIST
34391: LIST
34392: PUSH
34393: LD_INT 2
34395: PUSH
34396: LD_INT 1
34398: PUSH
34399: EMPTY
34400: LIST
34401: LIST
34402: PUSH
34403: LD_INT 2
34405: PUSH
34406: LD_INT 2
34408: PUSH
34409: EMPTY
34410: LIST
34411: LIST
34412: PUSH
34413: LD_INT 1
34415: PUSH
34416: LD_INT 2
34418: PUSH
34419: EMPTY
34420: LIST
34421: LIST
34422: PUSH
34423: LD_INT 0
34425: PUSH
34426: LD_INT 2
34428: PUSH
34429: EMPTY
34430: LIST
34431: LIST
34432: PUSH
34433: LD_INT 1
34435: NEG
34436: PUSH
34437: LD_INT 1
34439: PUSH
34440: EMPTY
34441: LIST
34442: LIST
34443: PUSH
34444: LD_INT 2
34446: NEG
34447: PUSH
34448: LD_INT 0
34450: PUSH
34451: EMPTY
34452: LIST
34453: LIST
34454: PUSH
34455: LD_INT 2
34457: NEG
34458: PUSH
34459: LD_INT 1
34461: NEG
34462: PUSH
34463: EMPTY
34464: LIST
34465: LIST
34466: PUSH
34467: LD_INT 1
34469: NEG
34470: PUSH
34471: LD_INT 3
34473: NEG
34474: PUSH
34475: EMPTY
34476: LIST
34477: LIST
34478: PUSH
34479: LD_INT 1
34481: PUSH
34482: LD_INT 2
34484: NEG
34485: PUSH
34486: EMPTY
34487: LIST
34488: LIST
34489: PUSH
34490: LD_INT 3
34492: PUSH
34493: LD_INT 2
34495: PUSH
34496: EMPTY
34497: LIST
34498: LIST
34499: PUSH
34500: LD_INT 2
34502: PUSH
34503: LD_INT 3
34505: PUSH
34506: EMPTY
34507: LIST
34508: LIST
34509: PUSH
34510: LD_INT 2
34512: NEG
34513: PUSH
34514: LD_INT 1
34516: PUSH
34517: EMPTY
34518: LIST
34519: LIST
34520: PUSH
34521: LD_INT 3
34523: NEG
34524: PUSH
34525: LD_INT 1
34527: NEG
34528: PUSH
34529: EMPTY
34530: LIST
34531: LIST
34532: PUSH
34533: EMPTY
34534: LIST
34535: LIST
34536: LIST
34537: LIST
34538: LIST
34539: LIST
34540: LIST
34541: LIST
34542: LIST
34543: LIST
34544: LIST
34545: LIST
34546: LIST
34547: LIST
34548: LIST
34549: LIST
34550: LIST
34551: LIST
34552: LIST
34553: LIST
34554: LIST
34555: LIST
34556: LIST
34557: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34558: LD_ADDR_VAR 0 33
34562: PUSH
34563: LD_INT 0
34565: PUSH
34566: LD_INT 0
34568: PUSH
34569: EMPTY
34570: LIST
34571: LIST
34572: PUSH
34573: LD_INT 0
34575: PUSH
34576: LD_INT 1
34578: NEG
34579: PUSH
34580: EMPTY
34581: LIST
34582: LIST
34583: PUSH
34584: LD_INT 1
34586: PUSH
34587: LD_INT 0
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 1
34596: PUSH
34597: LD_INT 1
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: PUSH
34604: LD_INT 0
34606: PUSH
34607: LD_INT 1
34609: PUSH
34610: EMPTY
34611: LIST
34612: LIST
34613: PUSH
34614: LD_INT 1
34616: NEG
34617: PUSH
34618: LD_INT 0
34620: PUSH
34621: EMPTY
34622: LIST
34623: LIST
34624: PUSH
34625: LD_INT 1
34627: NEG
34628: PUSH
34629: LD_INT 1
34631: NEG
34632: PUSH
34633: EMPTY
34634: LIST
34635: LIST
34636: PUSH
34637: LD_INT 1
34639: NEG
34640: PUSH
34641: LD_INT 2
34643: NEG
34644: PUSH
34645: EMPTY
34646: LIST
34647: LIST
34648: PUSH
34649: LD_INT 1
34651: PUSH
34652: LD_INT 1
34654: NEG
34655: PUSH
34656: EMPTY
34657: LIST
34658: LIST
34659: PUSH
34660: LD_INT 2
34662: PUSH
34663: LD_INT 0
34665: PUSH
34666: EMPTY
34667: LIST
34668: LIST
34669: PUSH
34670: LD_INT 2
34672: PUSH
34673: LD_INT 1
34675: PUSH
34676: EMPTY
34677: LIST
34678: LIST
34679: PUSH
34680: LD_INT 1
34682: PUSH
34683: LD_INT 2
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PUSH
34690: LD_INT 0
34692: PUSH
34693: LD_INT 2
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: PUSH
34700: LD_INT 1
34702: NEG
34703: PUSH
34704: LD_INT 1
34706: PUSH
34707: EMPTY
34708: LIST
34709: LIST
34710: PUSH
34711: LD_INT 2
34713: NEG
34714: PUSH
34715: LD_INT 0
34717: PUSH
34718: EMPTY
34719: LIST
34720: LIST
34721: PUSH
34722: LD_INT 2
34724: NEG
34725: PUSH
34726: LD_INT 1
34728: NEG
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 2
34736: NEG
34737: PUSH
34738: LD_INT 2
34740: NEG
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PUSH
34746: LD_INT 2
34748: NEG
34749: PUSH
34750: LD_INT 3
34752: NEG
34753: PUSH
34754: EMPTY
34755: LIST
34756: LIST
34757: PUSH
34758: LD_INT 2
34760: PUSH
34761: LD_INT 1
34763: NEG
34764: PUSH
34765: EMPTY
34766: LIST
34767: LIST
34768: PUSH
34769: LD_INT 3
34771: PUSH
34772: LD_INT 1
34774: PUSH
34775: EMPTY
34776: LIST
34777: LIST
34778: PUSH
34779: LD_INT 1
34781: PUSH
34782: LD_INT 3
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PUSH
34789: LD_INT 1
34791: NEG
34792: PUSH
34793: LD_INT 2
34795: PUSH
34796: EMPTY
34797: LIST
34798: LIST
34799: PUSH
34800: LD_INT 3
34802: NEG
34803: PUSH
34804: LD_INT 2
34806: NEG
34807: PUSH
34808: EMPTY
34809: LIST
34810: LIST
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: LIST
34824: LIST
34825: LIST
34826: LIST
34827: LIST
34828: LIST
34829: LIST
34830: LIST
34831: LIST
34832: LIST
34833: LIST
34834: LIST
34835: LIST
34836: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34837: LD_ADDR_VAR 0 34
34841: PUSH
34842: LD_INT 0
34844: PUSH
34845: LD_INT 0
34847: PUSH
34848: EMPTY
34849: LIST
34850: LIST
34851: PUSH
34852: LD_INT 0
34854: PUSH
34855: LD_INT 1
34857: NEG
34858: PUSH
34859: EMPTY
34860: LIST
34861: LIST
34862: PUSH
34863: LD_INT 1
34865: PUSH
34866: LD_INT 0
34868: PUSH
34869: EMPTY
34870: LIST
34871: LIST
34872: PUSH
34873: LD_INT 1
34875: PUSH
34876: LD_INT 1
34878: PUSH
34879: EMPTY
34880: LIST
34881: LIST
34882: PUSH
34883: LD_INT 0
34885: PUSH
34886: LD_INT 1
34888: PUSH
34889: EMPTY
34890: LIST
34891: LIST
34892: PUSH
34893: LD_INT 1
34895: NEG
34896: PUSH
34897: LD_INT 0
34899: PUSH
34900: EMPTY
34901: LIST
34902: LIST
34903: PUSH
34904: LD_INT 1
34906: NEG
34907: PUSH
34908: LD_INT 1
34910: NEG
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 1
34918: NEG
34919: PUSH
34920: LD_INT 2
34922: NEG
34923: PUSH
34924: EMPTY
34925: LIST
34926: LIST
34927: PUSH
34928: LD_INT 0
34930: PUSH
34931: LD_INT 2
34933: NEG
34934: PUSH
34935: EMPTY
34936: LIST
34937: LIST
34938: PUSH
34939: LD_INT 1
34941: PUSH
34942: LD_INT 1
34944: NEG
34945: PUSH
34946: EMPTY
34947: LIST
34948: LIST
34949: PUSH
34950: LD_INT 2
34952: PUSH
34953: LD_INT 1
34955: PUSH
34956: EMPTY
34957: LIST
34958: LIST
34959: PUSH
34960: LD_INT 2
34962: PUSH
34963: LD_INT 2
34965: PUSH
34966: EMPTY
34967: LIST
34968: LIST
34969: PUSH
34970: LD_INT 1
34972: PUSH
34973: LD_INT 2
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: PUSH
34980: LD_INT 1
34982: NEG
34983: PUSH
34984: LD_INT 1
34986: PUSH
34987: EMPTY
34988: LIST
34989: LIST
34990: PUSH
34991: LD_INT 2
34993: NEG
34994: PUSH
34995: LD_INT 0
34997: PUSH
34998: EMPTY
34999: LIST
35000: LIST
35001: PUSH
35002: LD_INT 2
35004: NEG
35005: PUSH
35006: LD_INT 1
35008: NEG
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: PUSH
35014: LD_INT 2
35016: NEG
35017: PUSH
35018: LD_INT 2
35020: NEG
35021: PUSH
35022: EMPTY
35023: LIST
35024: LIST
35025: PUSH
35026: LD_INT 1
35028: NEG
35029: PUSH
35030: LD_INT 3
35032: NEG
35033: PUSH
35034: EMPTY
35035: LIST
35036: LIST
35037: PUSH
35038: LD_INT 1
35040: PUSH
35041: LD_INT 2
35043: NEG
35044: PUSH
35045: EMPTY
35046: LIST
35047: LIST
35048: PUSH
35049: LD_INT 3
35051: PUSH
35052: LD_INT 2
35054: PUSH
35055: EMPTY
35056: LIST
35057: LIST
35058: PUSH
35059: LD_INT 2
35061: PUSH
35062: LD_INT 3
35064: PUSH
35065: EMPTY
35066: LIST
35067: LIST
35068: PUSH
35069: LD_INT 2
35071: NEG
35072: PUSH
35073: LD_INT 1
35075: PUSH
35076: EMPTY
35077: LIST
35078: LIST
35079: PUSH
35080: LD_INT 3
35082: NEG
35083: PUSH
35084: LD_INT 1
35086: NEG
35087: PUSH
35088: EMPTY
35089: LIST
35090: LIST
35091: PUSH
35092: EMPTY
35093: LIST
35094: LIST
35095: LIST
35096: LIST
35097: LIST
35098: LIST
35099: LIST
35100: LIST
35101: LIST
35102: LIST
35103: LIST
35104: LIST
35105: LIST
35106: LIST
35107: LIST
35108: LIST
35109: LIST
35110: LIST
35111: LIST
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35117: LD_ADDR_VAR 0 35
35121: PUSH
35122: LD_INT 0
35124: PUSH
35125: LD_INT 0
35127: PUSH
35128: EMPTY
35129: LIST
35130: LIST
35131: PUSH
35132: LD_INT 0
35134: PUSH
35135: LD_INT 1
35137: NEG
35138: PUSH
35139: EMPTY
35140: LIST
35141: LIST
35142: PUSH
35143: LD_INT 1
35145: PUSH
35146: LD_INT 0
35148: PUSH
35149: EMPTY
35150: LIST
35151: LIST
35152: PUSH
35153: LD_INT 1
35155: PUSH
35156: LD_INT 1
35158: PUSH
35159: EMPTY
35160: LIST
35161: LIST
35162: PUSH
35163: LD_INT 0
35165: PUSH
35166: LD_INT 1
35168: PUSH
35169: EMPTY
35170: LIST
35171: LIST
35172: PUSH
35173: LD_INT 1
35175: NEG
35176: PUSH
35177: LD_INT 0
35179: PUSH
35180: EMPTY
35181: LIST
35182: LIST
35183: PUSH
35184: LD_INT 1
35186: NEG
35187: PUSH
35188: LD_INT 1
35190: NEG
35191: PUSH
35192: EMPTY
35193: LIST
35194: LIST
35195: PUSH
35196: LD_INT 2
35198: PUSH
35199: LD_INT 1
35201: PUSH
35202: EMPTY
35203: LIST
35204: LIST
35205: PUSH
35206: LD_INT 2
35208: NEG
35209: PUSH
35210: LD_INT 1
35212: NEG
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: EMPTY
35219: LIST
35220: LIST
35221: LIST
35222: LIST
35223: LIST
35224: LIST
35225: LIST
35226: LIST
35227: LIST
35228: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35229: LD_ADDR_VAR 0 36
35233: PUSH
35234: LD_INT 0
35236: PUSH
35237: LD_INT 0
35239: PUSH
35240: EMPTY
35241: LIST
35242: LIST
35243: PUSH
35244: LD_INT 0
35246: PUSH
35247: LD_INT 1
35249: NEG
35250: PUSH
35251: EMPTY
35252: LIST
35253: LIST
35254: PUSH
35255: LD_INT 1
35257: PUSH
35258: LD_INT 0
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PUSH
35265: LD_INT 1
35267: PUSH
35268: LD_INT 1
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: PUSH
35275: LD_INT 0
35277: PUSH
35278: LD_INT 1
35280: PUSH
35281: EMPTY
35282: LIST
35283: LIST
35284: PUSH
35285: LD_INT 1
35287: NEG
35288: PUSH
35289: LD_INT 0
35291: PUSH
35292: EMPTY
35293: LIST
35294: LIST
35295: PUSH
35296: LD_INT 1
35298: NEG
35299: PUSH
35300: LD_INT 1
35302: NEG
35303: PUSH
35304: EMPTY
35305: LIST
35306: LIST
35307: PUSH
35308: LD_INT 1
35310: NEG
35311: PUSH
35312: LD_INT 2
35314: NEG
35315: PUSH
35316: EMPTY
35317: LIST
35318: LIST
35319: PUSH
35320: LD_INT 1
35322: PUSH
35323: LD_INT 2
35325: PUSH
35326: EMPTY
35327: LIST
35328: LIST
35329: PUSH
35330: EMPTY
35331: LIST
35332: LIST
35333: LIST
35334: LIST
35335: LIST
35336: LIST
35337: LIST
35338: LIST
35339: LIST
35340: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35341: LD_ADDR_VAR 0 37
35345: PUSH
35346: LD_INT 0
35348: PUSH
35349: LD_INT 0
35351: PUSH
35352: EMPTY
35353: LIST
35354: LIST
35355: PUSH
35356: LD_INT 0
35358: PUSH
35359: LD_INT 1
35361: NEG
35362: PUSH
35363: EMPTY
35364: LIST
35365: LIST
35366: PUSH
35367: LD_INT 1
35369: PUSH
35370: LD_INT 0
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 1
35379: PUSH
35380: LD_INT 1
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: PUSH
35387: LD_INT 0
35389: PUSH
35390: LD_INT 1
35392: PUSH
35393: EMPTY
35394: LIST
35395: LIST
35396: PUSH
35397: LD_INT 1
35399: NEG
35400: PUSH
35401: LD_INT 0
35403: PUSH
35404: EMPTY
35405: LIST
35406: LIST
35407: PUSH
35408: LD_INT 1
35410: NEG
35411: PUSH
35412: LD_INT 1
35414: NEG
35415: PUSH
35416: EMPTY
35417: LIST
35418: LIST
35419: PUSH
35420: LD_INT 1
35422: PUSH
35423: LD_INT 1
35425: NEG
35426: PUSH
35427: EMPTY
35428: LIST
35429: LIST
35430: PUSH
35431: LD_INT 1
35433: NEG
35434: PUSH
35435: LD_INT 1
35437: PUSH
35438: EMPTY
35439: LIST
35440: LIST
35441: PUSH
35442: EMPTY
35443: LIST
35444: LIST
35445: LIST
35446: LIST
35447: LIST
35448: LIST
35449: LIST
35450: LIST
35451: LIST
35452: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35453: LD_ADDR_VAR 0 38
35457: PUSH
35458: LD_INT 0
35460: PUSH
35461: LD_INT 0
35463: PUSH
35464: EMPTY
35465: LIST
35466: LIST
35467: PUSH
35468: LD_INT 0
35470: PUSH
35471: LD_INT 1
35473: NEG
35474: PUSH
35475: EMPTY
35476: LIST
35477: LIST
35478: PUSH
35479: LD_INT 1
35481: PUSH
35482: LD_INT 0
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: LD_INT 1
35491: PUSH
35492: LD_INT 1
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: PUSH
35499: LD_INT 0
35501: PUSH
35502: LD_INT 1
35504: PUSH
35505: EMPTY
35506: LIST
35507: LIST
35508: PUSH
35509: LD_INT 1
35511: NEG
35512: PUSH
35513: LD_INT 0
35515: PUSH
35516: EMPTY
35517: LIST
35518: LIST
35519: PUSH
35520: LD_INT 1
35522: NEG
35523: PUSH
35524: LD_INT 1
35526: NEG
35527: PUSH
35528: EMPTY
35529: LIST
35530: LIST
35531: PUSH
35532: LD_INT 2
35534: PUSH
35535: LD_INT 1
35537: PUSH
35538: EMPTY
35539: LIST
35540: LIST
35541: PUSH
35542: LD_INT 2
35544: NEG
35545: PUSH
35546: LD_INT 1
35548: NEG
35549: PUSH
35550: EMPTY
35551: LIST
35552: LIST
35553: PUSH
35554: EMPTY
35555: LIST
35556: LIST
35557: LIST
35558: LIST
35559: LIST
35560: LIST
35561: LIST
35562: LIST
35563: LIST
35564: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35565: LD_ADDR_VAR 0 39
35569: PUSH
35570: LD_INT 0
35572: PUSH
35573: LD_INT 0
35575: PUSH
35576: EMPTY
35577: LIST
35578: LIST
35579: PUSH
35580: LD_INT 0
35582: PUSH
35583: LD_INT 1
35585: NEG
35586: PUSH
35587: EMPTY
35588: LIST
35589: LIST
35590: PUSH
35591: LD_INT 1
35593: PUSH
35594: LD_INT 0
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PUSH
35601: LD_INT 1
35603: PUSH
35604: LD_INT 1
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 0
35613: PUSH
35614: LD_INT 1
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: LD_INT 1
35623: NEG
35624: PUSH
35625: LD_INT 0
35627: PUSH
35628: EMPTY
35629: LIST
35630: LIST
35631: PUSH
35632: LD_INT 1
35634: NEG
35635: PUSH
35636: LD_INT 1
35638: NEG
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: LD_INT 1
35646: NEG
35647: PUSH
35648: LD_INT 2
35650: NEG
35651: PUSH
35652: EMPTY
35653: LIST
35654: LIST
35655: PUSH
35656: LD_INT 1
35658: PUSH
35659: LD_INT 2
35661: PUSH
35662: EMPTY
35663: LIST
35664: LIST
35665: PUSH
35666: EMPTY
35667: LIST
35668: LIST
35669: LIST
35670: LIST
35671: LIST
35672: LIST
35673: LIST
35674: LIST
35675: LIST
35676: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35677: LD_ADDR_VAR 0 40
35681: PUSH
35682: LD_INT 0
35684: PUSH
35685: LD_INT 0
35687: PUSH
35688: EMPTY
35689: LIST
35690: LIST
35691: PUSH
35692: LD_INT 0
35694: PUSH
35695: LD_INT 1
35697: NEG
35698: PUSH
35699: EMPTY
35700: LIST
35701: LIST
35702: PUSH
35703: LD_INT 1
35705: PUSH
35706: LD_INT 0
35708: PUSH
35709: EMPTY
35710: LIST
35711: LIST
35712: PUSH
35713: LD_INT 1
35715: PUSH
35716: LD_INT 1
35718: PUSH
35719: EMPTY
35720: LIST
35721: LIST
35722: PUSH
35723: LD_INT 0
35725: PUSH
35726: LD_INT 1
35728: PUSH
35729: EMPTY
35730: LIST
35731: LIST
35732: PUSH
35733: LD_INT 1
35735: NEG
35736: PUSH
35737: LD_INT 0
35739: PUSH
35740: EMPTY
35741: LIST
35742: LIST
35743: PUSH
35744: LD_INT 1
35746: NEG
35747: PUSH
35748: LD_INT 1
35750: NEG
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: PUSH
35756: LD_INT 1
35758: PUSH
35759: LD_INT 1
35761: NEG
35762: PUSH
35763: EMPTY
35764: LIST
35765: LIST
35766: PUSH
35767: LD_INT 1
35769: NEG
35770: PUSH
35771: LD_INT 1
35773: PUSH
35774: EMPTY
35775: LIST
35776: LIST
35777: PUSH
35778: EMPTY
35779: LIST
35780: LIST
35781: LIST
35782: LIST
35783: LIST
35784: LIST
35785: LIST
35786: LIST
35787: LIST
35788: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35789: LD_ADDR_VAR 0 41
35793: PUSH
35794: LD_INT 0
35796: PUSH
35797: LD_INT 0
35799: PUSH
35800: EMPTY
35801: LIST
35802: LIST
35803: PUSH
35804: LD_INT 0
35806: PUSH
35807: LD_INT 1
35809: NEG
35810: PUSH
35811: EMPTY
35812: LIST
35813: LIST
35814: PUSH
35815: LD_INT 1
35817: PUSH
35818: LD_INT 0
35820: PUSH
35821: EMPTY
35822: LIST
35823: LIST
35824: PUSH
35825: LD_INT 1
35827: PUSH
35828: LD_INT 1
35830: PUSH
35831: EMPTY
35832: LIST
35833: LIST
35834: PUSH
35835: LD_INT 0
35837: PUSH
35838: LD_INT 1
35840: PUSH
35841: EMPTY
35842: LIST
35843: LIST
35844: PUSH
35845: LD_INT 1
35847: NEG
35848: PUSH
35849: LD_INT 0
35851: PUSH
35852: EMPTY
35853: LIST
35854: LIST
35855: PUSH
35856: LD_INT 1
35858: NEG
35859: PUSH
35860: LD_INT 1
35862: NEG
35863: PUSH
35864: EMPTY
35865: LIST
35866: LIST
35867: PUSH
35868: LD_INT 1
35870: NEG
35871: PUSH
35872: LD_INT 2
35874: NEG
35875: PUSH
35876: EMPTY
35877: LIST
35878: LIST
35879: PUSH
35880: LD_INT 1
35882: PUSH
35883: LD_INT 1
35885: NEG
35886: PUSH
35887: EMPTY
35888: LIST
35889: LIST
35890: PUSH
35891: LD_INT 2
35893: PUSH
35894: LD_INT 0
35896: PUSH
35897: EMPTY
35898: LIST
35899: LIST
35900: PUSH
35901: LD_INT 2
35903: PUSH
35904: LD_INT 1
35906: PUSH
35907: EMPTY
35908: LIST
35909: LIST
35910: PUSH
35911: LD_INT 2
35913: PUSH
35914: LD_INT 2
35916: PUSH
35917: EMPTY
35918: LIST
35919: LIST
35920: PUSH
35921: LD_INT 1
35923: PUSH
35924: LD_INT 2
35926: PUSH
35927: EMPTY
35928: LIST
35929: LIST
35930: PUSH
35931: LD_INT 1
35933: NEG
35934: PUSH
35935: LD_INT 1
35937: PUSH
35938: EMPTY
35939: LIST
35940: LIST
35941: PUSH
35942: LD_INT 2
35944: NEG
35945: PUSH
35946: LD_INT 0
35948: PUSH
35949: EMPTY
35950: LIST
35951: LIST
35952: PUSH
35953: LD_INT 2
35955: NEG
35956: PUSH
35957: LD_INT 1
35959: NEG
35960: PUSH
35961: EMPTY
35962: LIST
35963: LIST
35964: PUSH
35965: LD_INT 2
35967: NEG
35968: PUSH
35969: LD_INT 2
35971: NEG
35972: PUSH
35973: EMPTY
35974: LIST
35975: LIST
35976: PUSH
35977: LD_INT 2
35979: NEG
35980: PUSH
35981: LD_INT 3
35983: NEG
35984: PUSH
35985: EMPTY
35986: LIST
35987: LIST
35988: PUSH
35989: LD_INT 2
35991: PUSH
35992: LD_INT 1
35994: NEG
35995: PUSH
35996: EMPTY
35997: LIST
35998: LIST
35999: PUSH
36000: LD_INT 3
36002: PUSH
36003: LD_INT 0
36005: PUSH
36006: EMPTY
36007: LIST
36008: LIST
36009: PUSH
36010: LD_INT 3
36012: PUSH
36013: LD_INT 1
36015: PUSH
36016: EMPTY
36017: LIST
36018: LIST
36019: PUSH
36020: LD_INT 3
36022: PUSH
36023: LD_INT 2
36025: PUSH
36026: EMPTY
36027: LIST
36028: LIST
36029: PUSH
36030: LD_INT 3
36032: PUSH
36033: LD_INT 3
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: PUSH
36040: LD_INT 2
36042: PUSH
36043: LD_INT 3
36045: PUSH
36046: EMPTY
36047: LIST
36048: LIST
36049: PUSH
36050: LD_INT 2
36052: NEG
36053: PUSH
36054: LD_INT 1
36056: PUSH
36057: EMPTY
36058: LIST
36059: LIST
36060: PUSH
36061: LD_INT 3
36063: NEG
36064: PUSH
36065: LD_INT 0
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: PUSH
36072: LD_INT 3
36074: NEG
36075: PUSH
36076: LD_INT 1
36078: NEG
36079: PUSH
36080: EMPTY
36081: LIST
36082: LIST
36083: PUSH
36084: LD_INT 3
36086: NEG
36087: PUSH
36088: LD_INT 2
36090: NEG
36091: PUSH
36092: EMPTY
36093: LIST
36094: LIST
36095: PUSH
36096: LD_INT 3
36098: NEG
36099: PUSH
36100: LD_INT 3
36102: NEG
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PUSH
36108: EMPTY
36109: LIST
36110: LIST
36111: LIST
36112: LIST
36113: LIST
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: LIST
36122: LIST
36123: LIST
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: LIST
36133: LIST
36134: LIST
36135: LIST
36136: LIST
36137: LIST
36138: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36139: LD_ADDR_VAR 0 42
36143: PUSH
36144: LD_INT 0
36146: PUSH
36147: LD_INT 0
36149: PUSH
36150: EMPTY
36151: LIST
36152: LIST
36153: PUSH
36154: LD_INT 0
36156: PUSH
36157: LD_INT 1
36159: NEG
36160: PUSH
36161: EMPTY
36162: LIST
36163: LIST
36164: PUSH
36165: LD_INT 1
36167: PUSH
36168: LD_INT 0
36170: PUSH
36171: EMPTY
36172: LIST
36173: LIST
36174: PUSH
36175: LD_INT 1
36177: PUSH
36178: LD_INT 1
36180: PUSH
36181: EMPTY
36182: LIST
36183: LIST
36184: PUSH
36185: LD_INT 0
36187: PUSH
36188: LD_INT 1
36190: PUSH
36191: EMPTY
36192: LIST
36193: LIST
36194: PUSH
36195: LD_INT 1
36197: NEG
36198: PUSH
36199: LD_INT 0
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: PUSH
36206: LD_INT 1
36208: NEG
36209: PUSH
36210: LD_INT 1
36212: NEG
36213: PUSH
36214: EMPTY
36215: LIST
36216: LIST
36217: PUSH
36218: LD_INT 1
36220: NEG
36221: PUSH
36222: LD_INT 2
36224: NEG
36225: PUSH
36226: EMPTY
36227: LIST
36228: LIST
36229: PUSH
36230: LD_INT 0
36232: PUSH
36233: LD_INT 2
36235: NEG
36236: PUSH
36237: EMPTY
36238: LIST
36239: LIST
36240: PUSH
36241: LD_INT 1
36243: PUSH
36244: LD_INT 1
36246: NEG
36247: PUSH
36248: EMPTY
36249: LIST
36250: LIST
36251: PUSH
36252: LD_INT 2
36254: PUSH
36255: LD_INT 1
36257: PUSH
36258: EMPTY
36259: LIST
36260: LIST
36261: PUSH
36262: LD_INT 2
36264: PUSH
36265: LD_INT 2
36267: PUSH
36268: EMPTY
36269: LIST
36270: LIST
36271: PUSH
36272: LD_INT 1
36274: PUSH
36275: LD_INT 2
36277: PUSH
36278: EMPTY
36279: LIST
36280: LIST
36281: PUSH
36282: LD_INT 0
36284: PUSH
36285: LD_INT 2
36287: PUSH
36288: EMPTY
36289: LIST
36290: LIST
36291: PUSH
36292: LD_INT 1
36294: NEG
36295: PUSH
36296: LD_INT 1
36298: PUSH
36299: EMPTY
36300: LIST
36301: LIST
36302: PUSH
36303: LD_INT 2
36305: NEG
36306: PUSH
36307: LD_INT 1
36309: NEG
36310: PUSH
36311: EMPTY
36312: LIST
36313: LIST
36314: PUSH
36315: LD_INT 2
36317: NEG
36318: PUSH
36319: LD_INT 2
36321: NEG
36322: PUSH
36323: EMPTY
36324: LIST
36325: LIST
36326: PUSH
36327: LD_INT 2
36329: NEG
36330: PUSH
36331: LD_INT 3
36333: NEG
36334: PUSH
36335: EMPTY
36336: LIST
36337: LIST
36338: PUSH
36339: LD_INT 1
36341: NEG
36342: PUSH
36343: LD_INT 3
36345: NEG
36346: PUSH
36347: EMPTY
36348: LIST
36349: LIST
36350: PUSH
36351: LD_INT 0
36353: PUSH
36354: LD_INT 3
36356: NEG
36357: PUSH
36358: EMPTY
36359: LIST
36360: LIST
36361: PUSH
36362: LD_INT 1
36364: PUSH
36365: LD_INT 2
36367: NEG
36368: PUSH
36369: EMPTY
36370: LIST
36371: LIST
36372: PUSH
36373: LD_INT 3
36375: PUSH
36376: LD_INT 2
36378: PUSH
36379: EMPTY
36380: LIST
36381: LIST
36382: PUSH
36383: LD_INT 3
36385: PUSH
36386: LD_INT 3
36388: PUSH
36389: EMPTY
36390: LIST
36391: LIST
36392: PUSH
36393: LD_INT 2
36395: PUSH
36396: LD_INT 3
36398: PUSH
36399: EMPTY
36400: LIST
36401: LIST
36402: PUSH
36403: LD_INT 1
36405: PUSH
36406: LD_INT 3
36408: PUSH
36409: EMPTY
36410: LIST
36411: LIST
36412: PUSH
36413: LD_INT 0
36415: PUSH
36416: LD_INT 3
36418: PUSH
36419: EMPTY
36420: LIST
36421: LIST
36422: PUSH
36423: LD_INT 1
36425: NEG
36426: PUSH
36427: LD_INT 2
36429: PUSH
36430: EMPTY
36431: LIST
36432: LIST
36433: PUSH
36434: LD_INT 3
36436: NEG
36437: PUSH
36438: LD_INT 2
36440: NEG
36441: PUSH
36442: EMPTY
36443: LIST
36444: LIST
36445: PUSH
36446: LD_INT 3
36448: NEG
36449: PUSH
36450: LD_INT 3
36452: NEG
36453: PUSH
36454: EMPTY
36455: LIST
36456: LIST
36457: PUSH
36458: EMPTY
36459: LIST
36460: LIST
36461: LIST
36462: LIST
36463: LIST
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: LIST
36469: LIST
36470: LIST
36471: LIST
36472: LIST
36473: LIST
36474: LIST
36475: LIST
36476: LIST
36477: LIST
36478: LIST
36479: LIST
36480: LIST
36481: LIST
36482: LIST
36483: LIST
36484: LIST
36485: LIST
36486: LIST
36487: LIST
36488: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36489: LD_ADDR_VAR 0 43
36493: PUSH
36494: LD_INT 0
36496: PUSH
36497: LD_INT 0
36499: PUSH
36500: EMPTY
36501: LIST
36502: LIST
36503: PUSH
36504: LD_INT 0
36506: PUSH
36507: LD_INT 1
36509: NEG
36510: PUSH
36511: EMPTY
36512: LIST
36513: LIST
36514: PUSH
36515: LD_INT 1
36517: PUSH
36518: LD_INT 0
36520: PUSH
36521: EMPTY
36522: LIST
36523: LIST
36524: PUSH
36525: LD_INT 1
36527: PUSH
36528: LD_INT 1
36530: PUSH
36531: EMPTY
36532: LIST
36533: LIST
36534: PUSH
36535: LD_INT 0
36537: PUSH
36538: LD_INT 1
36540: PUSH
36541: EMPTY
36542: LIST
36543: LIST
36544: PUSH
36545: LD_INT 1
36547: NEG
36548: PUSH
36549: LD_INT 0
36551: PUSH
36552: EMPTY
36553: LIST
36554: LIST
36555: PUSH
36556: LD_INT 1
36558: NEG
36559: PUSH
36560: LD_INT 1
36562: NEG
36563: PUSH
36564: EMPTY
36565: LIST
36566: LIST
36567: PUSH
36568: LD_INT 1
36570: NEG
36571: PUSH
36572: LD_INT 2
36574: NEG
36575: PUSH
36576: EMPTY
36577: LIST
36578: LIST
36579: PUSH
36580: LD_INT 0
36582: PUSH
36583: LD_INT 2
36585: NEG
36586: PUSH
36587: EMPTY
36588: LIST
36589: LIST
36590: PUSH
36591: LD_INT 1
36593: PUSH
36594: LD_INT 1
36596: NEG
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: PUSH
36602: LD_INT 2
36604: PUSH
36605: LD_INT 0
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: LD_INT 2
36614: PUSH
36615: LD_INT 1
36617: PUSH
36618: EMPTY
36619: LIST
36620: LIST
36621: PUSH
36622: LD_INT 1
36624: PUSH
36625: LD_INT 2
36627: PUSH
36628: EMPTY
36629: LIST
36630: LIST
36631: PUSH
36632: LD_INT 0
36634: PUSH
36635: LD_INT 2
36637: PUSH
36638: EMPTY
36639: LIST
36640: LIST
36641: PUSH
36642: LD_INT 1
36644: NEG
36645: PUSH
36646: LD_INT 1
36648: PUSH
36649: EMPTY
36650: LIST
36651: LIST
36652: PUSH
36653: LD_INT 2
36655: NEG
36656: PUSH
36657: LD_INT 0
36659: PUSH
36660: EMPTY
36661: LIST
36662: LIST
36663: PUSH
36664: LD_INT 2
36666: NEG
36667: PUSH
36668: LD_INT 1
36670: NEG
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: LD_INT 1
36678: NEG
36679: PUSH
36680: LD_INT 3
36682: NEG
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: LD_INT 0
36690: PUSH
36691: LD_INT 3
36693: NEG
36694: PUSH
36695: EMPTY
36696: LIST
36697: LIST
36698: PUSH
36699: LD_INT 1
36701: PUSH
36702: LD_INT 2
36704: NEG
36705: PUSH
36706: EMPTY
36707: LIST
36708: LIST
36709: PUSH
36710: LD_INT 2
36712: PUSH
36713: LD_INT 1
36715: NEG
36716: PUSH
36717: EMPTY
36718: LIST
36719: LIST
36720: PUSH
36721: LD_INT 3
36723: PUSH
36724: LD_INT 0
36726: PUSH
36727: EMPTY
36728: LIST
36729: LIST
36730: PUSH
36731: LD_INT 3
36733: PUSH
36734: LD_INT 1
36736: PUSH
36737: EMPTY
36738: LIST
36739: LIST
36740: PUSH
36741: LD_INT 1
36743: PUSH
36744: LD_INT 3
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: LD_INT 0
36753: PUSH
36754: LD_INT 3
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: LD_INT 1
36763: NEG
36764: PUSH
36765: LD_INT 2
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 2
36774: NEG
36775: PUSH
36776: LD_INT 1
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: LD_INT 3
36785: NEG
36786: PUSH
36787: LD_INT 0
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 3
36796: NEG
36797: PUSH
36798: LD_INT 1
36800: NEG
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: EMPTY
36807: LIST
36808: LIST
36809: LIST
36810: LIST
36811: LIST
36812: LIST
36813: LIST
36814: LIST
36815: LIST
36816: LIST
36817: LIST
36818: LIST
36819: LIST
36820: LIST
36821: LIST
36822: LIST
36823: LIST
36824: LIST
36825: LIST
36826: LIST
36827: LIST
36828: LIST
36829: LIST
36830: LIST
36831: LIST
36832: LIST
36833: LIST
36834: LIST
36835: LIST
36836: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36837: LD_ADDR_VAR 0 44
36841: PUSH
36842: LD_INT 0
36844: PUSH
36845: LD_INT 0
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: LD_INT 0
36854: PUSH
36855: LD_INT 1
36857: NEG
36858: PUSH
36859: EMPTY
36860: LIST
36861: LIST
36862: PUSH
36863: LD_INT 1
36865: PUSH
36866: LD_INT 0
36868: PUSH
36869: EMPTY
36870: LIST
36871: LIST
36872: PUSH
36873: LD_INT 1
36875: PUSH
36876: LD_INT 1
36878: PUSH
36879: EMPTY
36880: LIST
36881: LIST
36882: PUSH
36883: LD_INT 0
36885: PUSH
36886: LD_INT 1
36888: PUSH
36889: EMPTY
36890: LIST
36891: LIST
36892: PUSH
36893: LD_INT 1
36895: NEG
36896: PUSH
36897: LD_INT 0
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 1
36906: NEG
36907: PUSH
36908: LD_INT 1
36910: NEG
36911: PUSH
36912: EMPTY
36913: LIST
36914: LIST
36915: PUSH
36916: LD_INT 1
36918: NEG
36919: PUSH
36920: LD_INT 2
36922: NEG
36923: PUSH
36924: EMPTY
36925: LIST
36926: LIST
36927: PUSH
36928: LD_INT 1
36930: PUSH
36931: LD_INT 1
36933: NEG
36934: PUSH
36935: EMPTY
36936: LIST
36937: LIST
36938: PUSH
36939: LD_INT 2
36941: PUSH
36942: LD_INT 0
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: LD_INT 2
36951: PUSH
36952: LD_INT 1
36954: PUSH
36955: EMPTY
36956: LIST
36957: LIST
36958: PUSH
36959: LD_INT 2
36961: PUSH
36962: LD_INT 2
36964: PUSH
36965: EMPTY
36966: LIST
36967: LIST
36968: PUSH
36969: LD_INT 1
36971: PUSH
36972: LD_INT 2
36974: PUSH
36975: EMPTY
36976: LIST
36977: LIST
36978: PUSH
36979: LD_INT 1
36981: NEG
36982: PUSH
36983: LD_INT 1
36985: PUSH
36986: EMPTY
36987: LIST
36988: LIST
36989: PUSH
36990: LD_INT 2
36992: NEG
36993: PUSH
36994: LD_INT 0
36996: PUSH
36997: EMPTY
36998: LIST
36999: LIST
37000: PUSH
37001: LD_INT 2
37003: NEG
37004: PUSH
37005: LD_INT 1
37007: NEG
37008: PUSH
37009: EMPTY
37010: LIST
37011: LIST
37012: PUSH
37013: LD_INT 2
37015: NEG
37016: PUSH
37017: LD_INT 2
37019: NEG
37020: PUSH
37021: EMPTY
37022: LIST
37023: LIST
37024: PUSH
37025: LD_INT 2
37027: NEG
37028: PUSH
37029: LD_INT 3
37031: NEG
37032: PUSH
37033: EMPTY
37034: LIST
37035: LIST
37036: PUSH
37037: LD_INT 2
37039: PUSH
37040: LD_INT 1
37042: NEG
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PUSH
37048: LD_INT 3
37050: PUSH
37051: LD_INT 0
37053: PUSH
37054: EMPTY
37055: LIST
37056: LIST
37057: PUSH
37058: LD_INT 3
37060: PUSH
37061: LD_INT 1
37063: PUSH
37064: EMPTY
37065: LIST
37066: LIST
37067: PUSH
37068: LD_INT 3
37070: PUSH
37071: LD_INT 2
37073: PUSH
37074: EMPTY
37075: LIST
37076: LIST
37077: PUSH
37078: LD_INT 3
37080: PUSH
37081: LD_INT 3
37083: PUSH
37084: EMPTY
37085: LIST
37086: LIST
37087: PUSH
37088: LD_INT 2
37090: PUSH
37091: LD_INT 3
37093: PUSH
37094: EMPTY
37095: LIST
37096: LIST
37097: PUSH
37098: LD_INT 2
37100: NEG
37101: PUSH
37102: LD_INT 1
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: LD_INT 3
37111: NEG
37112: PUSH
37113: LD_INT 0
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: PUSH
37120: LD_INT 3
37122: NEG
37123: PUSH
37124: LD_INT 1
37126: NEG
37127: PUSH
37128: EMPTY
37129: LIST
37130: LIST
37131: PUSH
37132: LD_INT 3
37134: NEG
37135: PUSH
37136: LD_INT 2
37138: NEG
37139: PUSH
37140: EMPTY
37141: LIST
37142: LIST
37143: PUSH
37144: LD_INT 3
37146: NEG
37147: PUSH
37148: LD_INT 3
37150: NEG
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: EMPTY
37157: LIST
37158: LIST
37159: LIST
37160: LIST
37161: LIST
37162: LIST
37163: LIST
37164: LIST
37165: LIST
37166: LIST
37167: LIST
37168: LIST
37169: LIST
37170: LIST
37171: LIST
37172: LIST
37173: LIST
37174: LIST
37175: LIST
37176: LIST
37177: LIST
37178: LIST
37179: LIST
37180: LIST
37181: LIST
37182: LIST
37183: LIST
37184: LIST
37185: LIST
37186: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37187: LD_ADDR_VAR 0 45
37191: PUSH
37192: LD_INT 0
37194: PUSH
37195: LD_INT 0
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 0
37204: PUSH
37205: LD_INT 1
37207: NEG
37208: PUSH
37209: EMPTY
37210: LIST
37211: LIST
37212: PUSH
37213: LD_INT 1
37215: PUSH
37216: LD_INT 0
37218: PUSH
37219: EMPTY
37220: LIST
37221: LIST
37222: PUSH
37223: LD_INT 1
37225: PUSH
37226: LD_INT 1
37228: PUSH
37229: EMPTY
37230: LIST
37231: LIST
37232: PUSH
37233: LD_INT 0
37235: PUSH
37236: LD_INT 1
37238: PUSH
37239: EMPTY
37240: LIST
37241: LIST
37242: PUSH
37243: LD_INT 1
37245: NEG
37246: PUSH
37247: LD_INT 0
37249: PUSH
37250: EMPTY
37251: LIST
37252: LIST
37253: PUSH
37254: LD_INT 1
37256: NEG
37257: PUSH
37258: LD_INT 1
37260: NEG
37261: PUSH
37262: EMPTY
37263: LIST
37264: LIST
37265: PUSH
37266: LD_INT 1
37268: NEG
37269: PUSH
37270: LD_INT 2
37272: NEG
37273: PUSH
37274: EMPTY
37275: LIST
37276: LIST
37277: PUSH
37278: LD_INT 0
37280: PUSH
37281: LD_INT 2
37283: NEG
37284: PUSH
37285: EMPTY
37286: LIST
37287: LIST
37288: PUSH
37289: LD_INT 1
37291: PUSH
37292: LD_INT 1
37294: NEG
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: PUSH
37300: LD_INT 2
37302: PUSH
37303: LD_INT 1
37305: PUSH
37306: EMPTY
37307: LIST
37308: LIST
37309: PUSH
37310: LD_INT 2
37312: PUSH
37313: LD_INT 2
37315: PUSH
37316: EMPTY
37317: LIST
37318: LIST
37319: PUSH
37320: LD_INT 1
37322: PUSH
37323: LD_INT 2
37325: PUSH
37326: EMPTY
37327: LIST
37328: LIST
37329: PUSH
37330: LD_INT 0
37332: PUSH
37333: LD_INT 2
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: PUSH
37340: LD_INT 1
37342: NEG
37343: PUSH
37344: LD_INT 1
37346: PUSH
37347: EMPTY
37348: LIST
37349: LIST
37350: PUSH
37351: LD_INT 2
37353: NEG
37354: PUSH
37355: LD_INT 1
37357: NEG
37358: PUSH
37359: EMPTY
37360: LIST
37361: LIST
37362: PUSH
37363: LD_INT 2
37365: NEG
37366: PUSH
37367: LD_INT 2
37369: NEG
37370: PUSH
37371: EMPTY
37372: LIST
37373: LIST
37374: PUSH
37375: LD_INT 2
37377: NEG
37378: PUSH
37379: LD_INT 3
37381: NEG
37382: PUSH
37383: EMPTY
37384: LIST
37385: LIST
37386: PUSH
37387: LD_INT 1
37389: NEG
37390: PUSH
37391: LD_INT 3
37393: NEG
37394: PUSH
37395: EMPTY
37396: LIST
37397: LIST
37398: PUSH
37399: LD_INT 0
37401: PUSH
37402: LD_INT 3
37404: NEG
37405: PUSH
37406: EMPTY
37407: LIST
37408: LIST
37409: PUSH
37410: LD_INT 1
37412: PUSH
37413: LD_INT 2
37415: NEG
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: PUSH
37421: LD_INT 3
37423: PUSH
37424: LD_INT 2
37426: PUSH
37427: EMPTY
37428: LIST
37429: LIST
37430: PUSH
37431: LD_INT 3
37433: PUSH
37434: LD_INT 3
37436: PUSH
37437: EMPTY
37438: LIST
37439: LIST
37440: PUSH
37441: LD_INT 2
37443: PUSH
37444: LD_INT 3
37446: PUSH
37447: EMPTY
37448: LIST
37449: LIST
37450: PUSH
37451: LD_INT 1
37453: PUSH
37454: LD_INT 3
37456: PUSH
37457: EMPTY
37458: LIST
37459: LIST
37460: PUSH
37461: LD_INT 0
37463: PUSH
37464: LD_INT 3
37466: PUSH
37467: EMPTY
37468: LIST
37469: LIST
37470: PUSH
37471: LD_INT 1
37473: NEG
37474: PUSH
37475: LD_INT 2
37477: PUSH
37478: EMPTY
37479: LIST
37480: LIST
37481: PUSH
37482: LD_INT 3
37484: NEG
37485: PUSH
37486: LD_INT 2
37488: NEG
37489: PUSH
37490: EMPTY
37491: LIST
37492: LIST
37493: PUSH
37494: LD_INT 3
37496: NEG
37497: PUSH
37498: LD_INT 3
37500: NEG
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: LIST
37510: LIST
37511: LIST
37512: LIST
37513: LIST
37514: LIST
37515: LIST
37516: LIST
37517: LIST
37518: LIST
37519: LIST
37520: LIST
37521: LIST
37522: LIST
37523: LIST
37524: LIST
37525: LIST
37526: LIST
37527: LIST
37528: LIST
37529: LIST
37530: LIST
37531: LIST
37532: LIST
37533: LIST
37534: LIST
37535: LIST
37536: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37537: LD_ADDR_VAR 0 46
37541: PUSH
37542: LD_INT 0
37544: PUSH
37545: LD_INT 0
37547: PUSH
37548: EMPTY
37549: LIST
37550: LIST
37551: PUSH
37552: LD_INT 0
37554: PUSH
37555: LD_INT 1
37557: NEG
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: LD_INT 1
37565: PUSH
37566: LD_INT 0
37568: PUSH
37569: EMPTY
37570: LIST
37571: LIST
37572: PUSH
37573: LD_INT 1
37575: PUSH
37576: LD_INT 1
37578: PUSH
37579: EMPTY
37580: LIST
37581: LIST
37582: PUSH
37583: LD_INT 0
37585: PUSH
37586: LD_INT 1
37588: PUSH
37589: EMPTY
37590: LIST
37591: LIST
37592: PUSH
37593: LD_INT 1
37595: NEG
37596: PUSH
37597: LD_INT 0
37599: PUSH
37600: EMPTY
37601: LIST
37602: LIST
37603: PUSH
37604: LD_INT 1
37606: NEG
37607: PUSH
37608: LD_INT 1
37610: NEG
37611: PUSH
37612: EMPTY
37613: LIST
37614: LIST
37615: PUSH
37616: LD_INT 1
37618: NEG
37619: PUSH
37620: LD_INT 2
37622: NEG
37623: PUSH
37624: EMPTY
37625: LIST
37626: LIST
37627: PUSH
37628: LD_INT 0
37630: PUSH
37631: LD_INT 2
37633: NEG
37634: PUSH
37635: EMPTY
37636: LIST
37637: LIST
37638: PUSH
37639: LD_INT 1
37641: PUSH
37642: LD_INT 1
37644: NEG
37645: PUSH
37646: EMPTY
37647: LIST
37648: LIST
37649: PUSH
37650: LD_INT 2
37652: PUSH
37653: LD_INT 0
37655: PUSH
37656: EMPTY
37657: LIST
37658: LIST
37659: PUSH
37660: LD_INT 2
37662: PUSH
37663: LD_INT 1
37665: PUSH
37666: EMPTY
37667: LIST
37668: LIST
37669: PUSH
37670: LD_INT 1
37672: PUSH
37673: LD_INT 2
37675: PUSH
37676: EMPTY
37677: LIST
37678: LIST
37679: PUSH
37680: LD_INT 0
37682: PUSH
37683: LD_INT 2
37685: PUSH
37686: EMPTY
37687: LIST
37688: LIST
37689: PUSH
37690: LD_INT 1
37692: NEG
37693: PUSH
37694: LD_INT 1
37696: PUSH
37697: EMPTY
37698: LIST
37699: LIST
37700: PUSH
37701: LD_INT 2
37703: NEG
37704: PUSH
37705: LD_INT 0
37707: PUSH
37708: EMPTY
37709: LIST
37710: LIST
37711: PUSH
37712: LD_INT 2
37714: NEG
37715: PUSH
37716: LD_INT 1
37718: NEG
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 1
37726: NEG
37727: PUSH
37728: LD_INT 3
37730: NEG
37731: PUSH
37732: EMPTY
37733: LIST
37734: LIST
37735: PUSH
37736: LD_INT 0
37738: PUSH
37739: LD_INT 3
37741: NEG
37742: PUSH
37743: EMPTY
37744: LIST
37745: LIST
37746: PUSH
37747: LD_INT 1
37749: PUSH
37750: LD_INT 2
37752: NEG
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PUSH
37758: LD_INT 2
37760: PUSH
37761: LD_INT 1
37763: NEG
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 3
37771: PUSH
37772: LD_INT 0
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: LD_INT 3
37781: PUSH
37782: LD_INT 1
37784: PUSH
37785: EMPTY
37786: LIST
37787: LIST
37788: PUSH
37789: LD_INT 1
37791: PUSH
37792: LD_INT 3
37794: PUSH
37795: EMPTY
37796: LIST
37797: LIST
37798: PUSH
37799: LD_INT 0
37801: PUSH
37802: LD_INT 3
37804: PUSH
37805: EMPTY
37806: LIST
37807: LIST
37808: PUSH
37809: LD_INT 1
37811: NEG
37812: PUSH
37813: LD_INT 2
37815: PUSH
37816: EMPTY
37817: LIST
37818: LIST
37819: PUSH
37820: LD_INT 2
37822: NEG
37823: PUSH
37824: LD_INT 1
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 3
37833: NEG
37834: PUSH
37835: LD_INT 0
37837: PUSH
37838: EMPTY
37839: LIST
37840: LIST
37841: PUSH
37842: LD_INT 3
37844: NEG
37845: PUSH
37846: LD_INT 1
37848: NEG
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: LIST
37858: LIST
37859: LIST
37860: LIST
37861: LIST
37862: LIST
37863: LIST
37864: LIST
37865: LIST
37866: LIST
37867: LIST
37868: LIST
37869: LIST
37870: LIST
37871: LIST
37872: LIST
37873: LIST
37874: LIST
37875: LIST
37876: LIST
37877: LIST
37878: LIST
37879: LIST
37880: LIST
37881: LIST
37882: LIST
37883: LIST
37884: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37885: LD_ADDR_VAR 0 47
37889: PUSH
37890: LD_INT 0
37892: PUSH
37893: LD_INT 0
37895: PUSH
37896: EMPTY
37897: LIST
37898: LIST
37899: PUSH
37900: LD_INT 0
37902: PUSH
37903: LD_INT 1
37905: NEG
37906: PUSH
37907: EMPTY
37908: LIST
37909: LIST
37910: PUSH
37911: LD_INT 1
37913: PUSH
37914: LD_INT 0
37916: PUSH
37917: EMPTY
37918: LIST
37919: LIST
37920: PUSH
37921: LD_INT 1
37923: PUSH
37924: LD_INT 1
37926: PUSH
37927: EMPTY
37928: LIST
37929: LIST
37930: PUSH
37931: LD_INT 0
37933: PUSH
37934: LD_INT 1
37936: PUSH
37937: EMPTY
37938: LIST
37939: LIST
37940: PUSH
37941: LD_INT 1
37943: NEG
37944: PUSH
37945: LD_INT 0
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 1
37954: NEG
37955: PUSH
37956: LD_INT 1
37958: NEG
37959: PUSH
37960: EMPTY
37961: LIST
37962: LIST
37963: PUSH
37964: LD_INT 1
37966: NEG
37967: PUSH
37968: LD_INT 2
37970: NEG
37971: PUSH
37972: EMPTY
37973: LIST
37974: LIST
37975: PUSH
37976: LD_INT 0
37978: PUSH
37979: LD_INT 2
37981: NEG
37982: PUSH
37983: EMPTY
37984: LIST
37985: LIST
37986: PUSH
37987: LD_INT 1
37989: PUSH
37990: LD_INT 1
37992: NEG
37993: PUSH
37994: EMPTY
37995: LIST
37996: LIST
37997: PUSH
37998: LD_INT 2
38000: NEG
38001: PUSH
38002: LD_INT 1
38004: NEG
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 2
38012: NEG
38013: PUSH
38014: LD_INT 2
38016: NEG
38017: PUSH
38018: EMPTY
38019: LIST
38020: LIST
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: LIST
38026: LIST
38027: LIST
38028: LIST
38029: LIST
38030: LIST
38031: LIST
38032: LIST
38033: LIST
38034: LIST
38035: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38036: LD_ADDR_VAR 0 48
38040: PUSH
38041: LD_INT 0
38043: PUSH
38044: LD_INT 0
38046: PUSH
38047: EMPTY
38048: LIST
38049: LIST
38050: PUSH
38051: LD_INT 0
38053: PUSH
38054: LD_INT 1
38056: NEG
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: PUSH
38062: LD_INT 1
38064: PUSH
38065: LD_INT 0
38067: PUSH
38068: EMPTY
38069: LIST
38070: LIST
38071: PUSH
38072: LD_INT 1
38074: PUSH
38075: LD_INT 1
38077: PUSH
38078: EMPTY
38079: LIST
38080: LIST
38081: PUSH
38082: LD_INT 0
38084: PUSH
38085: LD_INT 1
38087: PUSH
38088: EMPTY
38089: LIST
38090: LIST
38091: PUSH
38092: LD_INT 1
38094: NEG
38095: PUSH
38096: LD_INT 0
38098: PUSH
38099: EMPTY
38100: LIST
38101: LIST
38102: PUSH
38103: LD_INT 1
38105: NEG
38106: PUSH
38107: LD_INT 1
38109: NEG
38110: PUSH
38111: EMPTY
38112: LIST
38113: LIST
38114: PUSH
38115: LD_INT 1
38117: NEG
38118: PUSH
38119: LD_INT 2
38121: NEG
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: PUSH
38127: LD_INT 0
38129: PUSH
38130: LD_INT 2
38132: NEG
38133: PUSH
38134: EMPTY
38135: LIST
38136: LIST
38137: PUSH
38138: LD_INT 1
38140: PUSH
38141: LD_INT 1
38143: NEG
38144: PUSH
38145: EMPTY
38146: LIST
38147: LIST
38148: PUSH
38149: LD_INT 2
38151: PUSH
38152: LD_INT 0
38154: PUSH
38155: EMPTY
38156: LIST
38157: LIST
38158: PUSH
38159: LD_INT 2
38161: PUSH
38162: LD_INT 1
38164: PUSH
38165: EMPTY
38166: LIST
38167: LIST
38168: PUSH
38169: EMPTY
38170: LIST
38171: LIST
38172: LIST
38173: LIST
38174: LIST
38175: LIST
38176: LIST
38177: LIST
38178: LIST
38179: LIST
38180: LIST
38181: LIST
38182: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38183: LD_ADDR_VAR 0 49
38187: PUSH
38188: LD_INT 0
38190: PUSH
38191: LD_INT 0
38193: PUSH
38194: EMPTY
38195: LIST
38196: LIST
38197: PUSH
38198: LD_INT 0
38200: PUSH
38201: LD_INT 1
38203: NEG
38204: PUSH
38205: EMPTY
38206: LIST
38207: LIST
38208: PUSH
38209: LD_INT 1
38211: PUSH
38212: LD_INT 0
38214: PUSH
38215: EMPTY
38216: LIST
38217: LIST
38218: PUSH
38219: LD_INT 1
38221: PUSH
38222: LD_INT 1
38224: PUSH
38225: EMPTY
38226: LIST
38227: LIST
38228: PUSH
38229: LD_INT 0
38231: PUSH
38232: LD_INT 1
38234: PUSH
38235: EMPTY
38236: LIST
38237: LIST
38238: PUSH
38239: LD_INT 1
38241: NEG
38242: PUSH
38243: LD_INT 0
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: LD_INT 1
38252: NEG
38253: PUSH
38254: LD_INT 1
38256: NEG
38257: PUSH
38258: EMPTY
38259: LIST
38260: LIST
38261: PUSH
38262: LD_INT 1
38264: PUSH
38265: LD_INT 1
38267: NEG
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: PUSH
38273: LD_INT 2
38275: PUSH
38276: LD_INT 0
38278: PUSH
38279: EMPTY
38280: LIST
38281: LIST
38282: PUSH
38283: LD_INT 2
38285: PUSH
38286: LD_INT 1
38288: PUSH
38289: EMPTY
38290: LIST
38291: LIST
38292: PUSH
38293: LD_INT 2
38295: PUSH
38296: LD_INT 2
38298: PUSH
38299: EMPTY
38300: LIST
38301: LIST
38302: PUSH
38303: LD_INT 1
38305: PUSH
38306: LD_INT 2
38308: PUSH
38309: EMPTY
38310: LIST
38311: LIST
38312: PUSH
38313: EMPTY
38314: LIST
38315: LIST
38316: LIST
38317: LIST
38318: LIST
38319: LIST
38320: LIST
38321: LIST
38322: LIST
38323: LIST
38324: LIST
38325: LIST
38326: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38327: LD_ADDR_VAR 0 50
38331: PUSH
38332: LD_INT 0
38334: PUSH
38335: LD_INT 0
38337: PUSH
38338: EMPTY
38339: LIST
38340: LIST
38341: PUSH
38342: LD_INT 0
38344: PUSH
38345: LD_INT 1
38347: NEG
38348: PUSH
38349: EMPTY
38350: LIST
38351: LIST
38352: PUSH
38353: LD_INT 1
38355: PUSH
38356: LD_INT 0
38358: PUSH
38359: EMPTY
38360: LIST
38361: LIST
38362: PUSH
38363: LD_INT 1
38365: PUSH
38366: LD_INT 1
38368: PUSH
38369: EMPTY
38370: LIST
38371: LIST
38372: PUSH
38373: LD_INT 0
38375: PUSH
38376: LD_INT 1
38378: PUSH
38379: EMPTY
38380: LIST
38381: LIST
38382: PUSH
38383: LD_INT 1
38385: NEG
38386: PUSH
38387: LD_INT 0
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: PUSH
38394: LD_INT 1
38396: NEG
38397: PUSH
38398: LD_INT 1
38400: NEG
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: PUSH
38406: LD_INT 2
38408: PUSH
38409: LD_INT 1
38411: PUSH
38412: EMPTY
38413: LIST
38414: LIST
38415: PUSH
38416: LD_INT 2
38418: PUSH
38419: LD_INT 2
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: LD_INT 1
38428: PUSH
38429: LD_INT 2
38431: PUSH
38432: EMPTY
38433: LIST
38434: LIST
38435: PUSH
38436: LD_INT 0
38438: PUSH
38439: LD_INT 2
38441: PUSH
38442: EMPTY
38443: LIST
38444: LIST
38445: PUSH
38446: LD_INT 1
38448: NEG
38449: PUSH
38450: LD_INT 1
38452: PUSH
38453: EMPTY
38454: LIST
38455: LIST
38456: PUSH
38457: EMPTY
38458: LIST
38459: LIST
38460: LIST
38461: LIST
38462: LIST
38463: LIST
38464: LIST
38465: LIST
38466: LIST
38467: LIST
38468: LIST
38469: LIST
38470: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38471: LD_ADDR_VAR 0 51
38475: PUSH
38476: LD_INT 0
38478: PUSH
38479: LD_INT 0
38481: PUSH
38482: EMPTY
38483: LIST
38484: LIST
38485: PUSH
38486: LD_INT 0
38488: PUSH
38489: LD_INT 1
38491: NEG
38492: PUSH
38493: EMPTY
38494: LIST
38495: LIST
38496: PUSH
38497: LD_INT 1
38499: PUSH
38500: LD_INT 0
38502: PUSH
38503: EMPTY
38504: LIST
38505: LIST
38506: PUSH
38507: LD_INT 1
38509: PUSH
38510: LD_INT 1
38512: PUSH
38513: EMPTY
38514: LIST
38515: LIST
38516: PUSH
38517: LD_INT 0
38519: PUSH
38520: LD_INT 1
38522: PUSH
38523: EMPTY
38524: LIST
38525: LIST
38526: PUSH
38527: LD_INT 1
38529: NEG
38530: PUSH
38531: LD_INT 0
38533: PUSH
38534: EMPTY
38535: LIST
38536: LIST
38537: PUSH
38538: LD_INT 1
38540: NEG
38541: PUSH
38542: LD_INT 1
38544: NEG
38545: PUSH
38546: EMPTY
38547: LIST
38548: LIST
38549: PUSH
38550: LD_INT 1
38552: PUSH
38553: LD_INT 2
38555: PUSH
38556: EMPTY
38557: LIST
38558: LIST
38559: PUSH
38560: LD_INT 0
38562: PUSH
38563: LD_INT 2
38565: PUSH
38566: EMPTY
38567: LIST
38568: LIST
38569: PUSH
38570: LD_INT 1
38572: NEG
38573: PUSH
38574: LD_INT 1
38576: PUSH
38577: EMPTY
38578: LIST
38579: LIST
38580: PUSH
38581: LD_INT 2
38583: NEG
38584: PUSH
38585: LD_INT 0
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: PUSH
38592: LD_INT 2
38594: NEG
38595: PUSH
38596: LD_INT 1
38598: NEG
38599: PUSH
38600: EMPTY
38601: LIST
38602: LIST
38603: PUSH
38604: EMPTY
38605: LIST
38606: LIST
38607: LIST
38608: LIST
38609: LIST
38610: LIST
38611: LIST
38612: LIST
38613: LIST
38614: LIST
38615: LIST
38616: LIST
38617: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38618: LD_ADDR_VAR 0 52
38622: PUSH
38623: LD_INT 0
38625: PUSH
38626: LD_INT 0
38628: PUSH
38629: EMPTY
38630: LIST
38631: LIST
38632: PUSH
38633: LD_INT 0
38635: PUSH
38636: LD_INT 1
38638: NEG
38639: PUSH
38640: EMPTY
38641: LIST
38642: LIST
38643: PUSH
38644: LD_INT 1
38646: PUSH
38647: LD_INT 0
38649: PUSH
38650: EMPTY
38651: LIST
38652: LIST
38653: PUSH
38654: LD_INT 1
38656: PUSH
38657: LD_INT 1
38659: PUSH
38660: EMPTY
38661: LIST
38662: LIST
38663: PUSH
38664: LD_INT 0
38666: PUSH
38667: LD_INT 1
38669: PUSH
38670: EMPTY
38671: LIST
38672: LIST
38673: PUSH
38674: LD_INT 1
38676: NEG
38677: PUSH
38678: LD_INT 0
38680: PUSH
38681: EMPTY
38682: LIST
38683: LIST
38684: PUSH
38685: LD_INT 1
38687: NEG
38688: PUSH
38689: LD_INT 1
38691: NEG
38692: PUSH
38693: EMPTY
38694: LIST
38695: LIST
38696: PUSH
38697: LD_INT 1
38699: NEG
38700: PUSH
38701: LD_INT 2
38703: NEG
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: PUSH
38709: LD_INT 1
38711: NEG
38712: PUSH
38713: LD_INT 1
38715: PUSH
38716: EMPTY
38717: LIST
38718: LIST
38719: PUSH
38720: LD_INT 2
38722: NEG
38723: PUSH
38724: LD_INT 0
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: PUSH
38731: LD_INT 2
38733: NEG
38734: PUSH
38735: LD_INT 1
38737: NEG
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PUSH
38743: LD_INT 2
38745: NEG
38746: PUSH
38747: LD_INT 2
38749: NEG
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: LIST
38759: LIST
38760: LIST
38761: LIST
38762: LIST
38763: LIST
38764: LIST
38765: LIST
38766: LIST
38767: LIST
38768: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38769: LD_ADDR_VAR 0 53
38773: PUSH
38774: LD_INT 0
38776: PUSH
38777: LD_INT 0
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: PUSH
38784: LD_INT 0
38786: PUSH
38787: LD_INT 1
38789: NEG
38790: PUSH
38791: EMPTY
38792: LIST
38793: LIST
38794: PUSH
38795: LD_INT 1
38797: PUSH
38798: LD_INT 0
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: PUSH
38805: LD_INT 1
38807: PUSH
38808: LD_INT 1
38810: PUSH
38811: EMPTY
38812: LIST
38813: LIST
38814: PUSH
38815: LD_INT 0
38817: PUSH
38818: LD_INT 1
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: PUSH
38825: LD_INT 1
38827: NEG
38828: PUSH
38829: LD_INT 0
38831: PUSH
38832: EMPTY
38833: LIST
38834: LIST
38835: PUSH
38836: LD_INT 1
38838: NEG
38839: PUSH
38840: LD_INT 1
38842: NEG
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: LD_INT 1
38850: NEG
38851: PUSH
38852: LD_INT 2
38854: NEG
38855: PUSH
38856: EMPTY
38857: LIST
38858: LIST
38859: PUSH
38860: LD_INT 0
38862: PUSH
38863: LD_INT 2
38865: NEG
38866: PUSH
38867: EMPTY
38868: LIST
38869: LIST
38870: PUSH
38871: LD_INT 1
38873: PUSH
38874: LD_INT 1
38876: NEG
38877: PUSH
38878: EMPTY
38879: LIST
38880: LIST
38881: PUSH
38882: LD_INT 2
38884: PUSH
38885: LD_INT 0
38887: PUSH
38888: EMPTY
38889: LIST
38890: LIST
38891: PUSH
38892: LD_INT 2
38894: PUSH
38895: LD_INT 1
38897: PUSH
38898: EMPTY
38899: LIST
38900: LIST
38901: PUSH
38902: LD_INT 2
38904: PUSH
38905: LD_INT 2
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: LD_INT 1
38914: PUSH
38915: LD_INT 2
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 0
38924: PUSH
38925: LD_INT 2
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: LD_INT 1
38934: NEG
38935: PUSH
38936: LD_INT 1
38938: PUSH
38939: EMPTY
38940: LIST
38941: LIST
38942: PUSH
38943: LD_INT 2
38945: NEG
38946: PUSH
38947: LD_INT 0
38949: PUSH
38950: EMPTY
38951: LIST
38952: LIST
38953: PUSH
38954: LD_INT 2
38956: NEG
38957: PUSH
38958: LD_INT 1
38960: NEG
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: PUSH
38966: LD_INT 2
38968: NEG
38969: PUSH
38970: LD_INT 2
38972: NEG
38973: PUSH
38974: EMPTY
38975: LIST
38976: LIST
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: LIST
38982: LIST
38983: LIST
38984: LIST
38985: LIST
38986: LIST
38987: LIST
38988: LIST
38989: LIST
38990: LIST
38991: LIST
38992: LIST
38993: LIST
38994: LIST
38995: LIST
38996: LIST
38997: LIST
38998: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38999: LD_ADDR_VAR 0 54
39003: PUSH
39004: LD_INT 0
39006: PUSH
39007: LD_INT 0
39009: PUSH
39010: EMPTY
39011: LIST
39012: LIST
39013: PUSH
39014: LD_INT 0
39016: PUSH
39017: LD_INT 1
39019: NEG
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: LD_INT 1
39027: PUSH
39028: LD_INT 0
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 1
39037: PUSH
39038: LD_INT 1
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 0
39047: PUSH
39048: LD_INT 1
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: LD_INT 1
39057: NEG
39058: PUSH
39059: LD_INT 0
39061: PUSH
39062: EMPTY
39063: LIST
39064: LIST
39065: PUSH
39066: LD_INT 1
39068: NEG
39069: PUSH
39070: LD_INT 1
39072: NEG
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 1
39080: NEG
39081: PUSH
39082: LD_INT 2
39084: NEG
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PUSH
39090: LD_INT 0
39092: PUSH
39093: LD_INT 2
39095: NEG
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: LD_INT 1
39103: PUSH
39104: LD_INT 1
39106: NEG
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PUSH
39112: LD_INT 2
39114: PUSH
39115: LD_INT 0
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 2
39124: PUSH
39125: LD_INT 1
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: LD_INT 2
39134: PUSH
39135: LD_INT 2
39137: PUSH
39138: EMPTY
39139: LIST
39140: LIST
39141: PUSH
39142: LD_INT 1
39144: PUSH
39145: LD_INT 2
39147: PUSH
39148: EMPTY
39149: LIST
39150: LIST
39151: PUSH
39152: LD_INT 0
39154: PUSH
39155: LD_INT 2
39157: PUSH
39158: EMPTY
39159: LIST
39160: LIST
39161: PUSH
39162: LD_INT 1
39164: NEG
39165: PUSH
39166: LD_INT 1
39168: PUSH
39169: EMPTY
39170: LIST
39171: LIST
39172: PUSH
39173: LD_INT 2
39175: NEG
39176: PUSH
39177: LD_INT 0
39179: PUSH
39180: EMPTY
39181: LIST
39182: LIST
39183: PUSH
39184: LD_INT 2
39186: NEG
39187: PUSH
39188: LD_INT 1
39190: NEG
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: PUSH
39196: LD_INT 2
39198: NEG
39199: PUSH
39200: LD_INT 2
39202: NEG
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: EMPTY
39209: LIST
39210: LIST
39211: LIST
39212: LIST
39213: LIST
39214: LIST
39215: LIST
39216: LIST
39217: LIST
39218: LIST
39219: LIST
39220: LIST
39221: LIST
39222: LIST
39223: LIST
39224: LIST
39225: LIST
39226: LIST
39227: LIST
39228: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39229: LD_ADDR_VAR 0 55
39233: PUSH
39234: LD_INT 0
39236: PUSH
39237: LD_INT 0
39239: PUSH
39240: EMPTY
39241: LIST
39242: LIST
39243: PUSH
39244: LD_INT 0
39246: PUSH
39247: LD_INT 1
39249: NEG
39250: PUSH
39251: EMPTY
39252: LIST
39253: LIST
39254: PUSH
39255: LD_INT 1
39257: PUSH
39258: LD_INT 0
39260: PUSH
39261: EMPTY
39262: LIST
39263: LIST
39264: PUSH
39265: LD_INT 1
39267: PUSH
39268: LD_INT 1
39270: PUSH
39271: EMPTY
39272: LIST
39273: LIST
39274: PUSH
39275: LD_INT 0
39277: PUSH
39278: LD_INT 1
39280: PUSH
39281: EMPTY
39282: LIST
39283: LIST
39284: PUSH
39285: LD_INT 1
39287: NEG
39288: PUSH
39289: LD_INT 0
39291: PUSH
39292: EMPTY
39293: LIST
39294: LIST
39295: PUSH
39296: LD_INT 1
39298: NEG
39299: PUSH
39300: LD_INT 1
39302: NEG
39303: PUSH
39304: EMPTY
39305: LIST
39306: LIST
39307: PUSH
39308: LD_INT 1
39310: NEG
39311: PUSH
39312: LD_INT 2
39314: NEG
39315: PUSH
39316: EMPTY
39317: LIST
39318: LIST
39319: PUSH
39320: LD_INT 0
39322: PUSH
39323: LD_INT 2
39325: NEG
39326: PUSH
39327: EMPTY
39328: LIST
39329: LIST
39330: PUSH
39331: LD_INT 1
39333: PUSH
39334: LD_INT 1
39336: NEG
39337: PUSH
39338: EMPTY
39339: LIST
39340: LIST
39341: PUSH
39342: LD_INT 2
39344: PUSH
39345: LD_INT 0
39347: PUSH
39348: EMPTY
39349: LIST
39350: LIST
39351: PUSH
39352: LD_INT 2
39354: PUSH
39355: LD_INT 1
39357: PUSH
39358: EMPTY
39359: LIST
39360: LIST
39361: PUSH
39362: LD_INT 2
39364: PUSH
39365: LD_INT 2
39367: PUSH
39368: EMPTY
39369: LIST
39370: LIST
39371: PUSH
39372: LD_INT 1
39374: PUSH
39375: LD_INT 2
39377: PUSH
39378: EMPTY
39379: LIST
39380: LIST
39381: PUSH
39382: LD_INT 0
39384: PUSH
39385: LD_INT 2
39387: PUSH
39388: EMPTY
39389: LIST
39390: LIST
39391: PUSH
39392: LD_INT 1
39394: NEG
39395: PUSH
39396: LD_INT 1
39398: PUSH
39399: EMPTY
39400: LIST
39401: LIST
39402: PUSH
39403: LD_INT 2
39405: NEG
39406: PUSH
39407: LD_INT 0
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: PUSH
39414: LD_INT 2
39416: NEG
39417: PUSH
39418: LD_INT 1
39420: NEG
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: PUSH
39426: LD_INT 2
39428: NEG
39429: PUSH
39430: LD_INT 2
39432: NEG
39433: PUSH
39434: EMPTY
39435: LIST
39436: LIST
39437: PUSH
39438: EMPTY
39439: LIST
39440: LIST
39441: LIST
39442: LIST
39443: LIST
39444: LIST
39445: LIST
39446: LIST
39447: LIST
39448: LIST
39449: LIST
39450: LIST
39451: LIST
39452: LIST
39453: LIST
39454: LIST
39455: LIST
39456: LIST
39457: LIST
39458: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39459: LD_ADDR_VAR 0 56
39463: PUSH
39464: LD_INT 0
39466: PUSH
39467: LD_INT 0
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: PUSH
39474: LD_INT 0
39476: PUSH
39477: LD_INT 1
39479: NEG
39480: PUSH
39481: EMPTY
39482: LIST
39483: LIST
39484: PUSH
39485: LD_INT 1
39487: PUSH
39488: LD_INT 0
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: PUSH
39495: LD_INT 1
39497: PUSH
39498: LD_INT 1
39500: PUSH
39501: EMPTY
39502: LIST
39503: LIST
39504: PUSH
39505: LD_INT 0
39507: PUSH
39508: LD_INT 1
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: LD_INT 1
39517: NEG
39518: PUSH
39519: LD_INT 0
39521: PUSH
39522: EMPTY
39523: LIST
39524: LIST
39525: PUSH
39526: LD_INT 1
39528: NEG
39529: PUSH
39530: LD_INT 1
39532: NEG
39533: PUSH
39534: EMPTY
39535: LIST
39536: LIST
39537: PUSH
39538: LD_INT 1
39540: NEG
39541: PUSH
39542: LD_INT 2
39544: NEG
39545: PUSH
39546: EMPTY
39547: LIST
39548: LIST
39549: PUSH
39550: LD_INT 0
39552: PUSH
39553: LD_INT 2
39555: NEG
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 1
39563: PUSH
39564: LD_INT 1
39566: NEG
39567: PUSH
39568: EMPTY
39569: LIST
39570: LIST
39571: PUSH
39572: LD_INT 2
39574: PUSH
39575: LD_INT 0
39577: PUSH
39578: EMPTY
39579: LIST
39580: LIST
39581: PUSH
39582: LD_INT 2
39584: PUSH
39585: LD_INT 1
39587: PUSH
39588: EMPTY
39589: LIST
39590: LIST
39591: PUSH
39592: LD_INT 2
39594: PUSH
39595: LD_INT 2
39597: PUSH
39598: EMPTY
39599: LIST
39600: LIST
39601: PUSH
39602: LD_INT 1
39604: PUSH
39605: LD_INT 2
39607: PUSH
39608: EMPTY
39609: LIST
39610: LIST
39611: PUSH
39612: LD_INT 0
39614: PUSH
39615: LD_INT 2
39617: PUSH
39618: EMPTY
39619: LIST
39620: LIST
39621: PUSH
39622: LD_INT 1
39624: NEG
39625: PUSH
39626: LD_INT 1
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: LD_INT 2
39635: NEG
39636: PUSH
39637: LD_INT 0
39639: PUSH
39640: EMPTY
39641: LIST
39642: LIST
39643: PUSH
39644: LD_INT 2
39646: NEG
39647: PUSH
39648: LD_INT 1
39650: NEG
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: LD_INT 2
39658: NEG
39659: PUSH
39660: LD_INT 2
39662: NEG
39663: PUSH
39664: EMPTY
39665: LIST
39666: LIST
39667: PUSH
39668: EMPTY
39669: LIST
39670: LIST
39671: LIST
39672: LIST
39673: LIST
39674: LIST
39675: LIST
39676: LIST
39677: LIST
39678: LIST
39679: LIST
39680: LIST
39681: LIST
39682: LIST
39683: LIST
39684: LIST
39685: LIST
39686: LIST
39687: LIST
39688: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39689: LD_ADDR_VAR 0 57
39693: PUSH
39694: LD_INT 0
39696: PUSH
39697: LD_INT 0
39699: PUSH
39700: EMPTY
39701: LIST
39702: LIST
39703: PUSH
39704: LD_INT 0
39706: PUSH
39707: LD_INT 1
39709: NEG
39710: PUSH
39711: EMPTY
39712: LIST
39713: LIST
39714: PUSH
39715: LD_INT 1
39717: PUSH
39718: LD_INT 0
39720: PUSH
39721: EMPTY
39722: LIST
39723: LIST
39724: PUSH
39725: LD_INT 1
39727: PUSH
39728: LD_INT 1
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: LD_INT 0
39737: PUSH
39738: LD_INT 1
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: PUSH
39745: LD_INT 1
39747: NEG
39748: PUSH
39749: LD_INT 0
39751: PUSH
39752: EMPTY
39753: LIST
39754: LIST
39755: PUSH
39756: LD_INT 1
39758: NEG
39759: PUSH
39760: LD_INT 1
39762: NEG
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: LD_INT 1
39770: NEG
39771: PUSH
39772: LD_INT 2
39774: NEG
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 0
39782: PUSH
39783: LD_INT 2
39785: NEG
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 1
39793: PUSH
39794: LD_INT 1
39796: NEG
39797: PUSH
39798: EMPTY
39799: LIST
39800: LIST
39801: PUSH
39802: LD_INT 2
39804: PUSH
39805: LD_INT 0
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 2
39814: PUSH
39815: LD_INT 1
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: PUSH
39822: LD_INT 2
39824: PUSH
39825: LD_INT 2
39827: PUSH
39828: EMPTY
39829: LIST
39830: LIST
39831: PUSH
39832: LD_INT 1
39834: PUSH
39835: LD_INT 2
39837: PUSH
39838: EMPTY
39839: LIST
39840: LIST
39841: PUSH
39842: LD_INT 0
39844: PUSH
39845: LD_INT 2
39847: PUSH
39848: EMPTY
39849: LIST
39850: LIST
39851: PUSH
39852: LD_INT 1
39854: NEG
39855: PUSH
39856: LD_INT 1
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: PUSH
39863: LD_INT 2
39865: NEG
39866: PUSH
39867: LD_INT 0
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: PUSH
39874: LD_INT 2
39876: NEG
39877: PUSH
39878: LD_INT 1
39880: NEG
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PUSH
39886: LD_INT 2
39888: NEG
39889: PUSH
39890: LD_INT 2
39892: NEG
39893: PUSH
39894: EMPTY
39895: LIST
39896: LIST
39897: PUSH
39898: EMPTY
39899: LIST
39900: LIST
39901: LIST
39902: LIST
39903: LIST
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: LIST
39918: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39919: LD_ADDR_VAR 0 58
39923: PUSH
39924: LD_INT 0
39926: PUSH
39927: LD_INT 0
39929: PUSH
39930: EMPTY
39931: LIST
39932: LIST
39933: PUSH
39934: LD_INT 0
39936: PUSH
39937: LD_INT 1
39939: NEG
39940: PUSH
39941: EMPTY
39942: LIST
39943: LIST
39944: PUSH
39945: LD_INT 1
39947: PUSH
39948: LD_INT 0
39950: PUSH
39951: EMPTY
39952: LIST
39953: LIST
39954: PUSH
39955: LD_INT 1
39957: PUSH
39958: LD_INT 1
39960: PUSH
39961: EMPTY
39962: LIST
39963: LIST
39964: PUSH
39965: LD_INT 0
39967: PUSH
39968: LD_INT 1
39970: PUSH
39971: EMPTY
39972: LIST
39973: LIST
39974: PUSH
39975: LD_INT 1
39977: NEG
39978: PUSH
39979: LD_INT 0
39981: PUSH
39982: EMPTY
39983: LIST
39984: LIST
39985: PUSH
39986: LD_INT 1
39988: NEG
39989: PUSH
39990: LD_INT 1
39992: NEG
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PUSH
39998: LD_INT 1
40000: NEG
40001: PUSH
40002: LD_INT 2
40004: NEG
40005: PUSH
40006: EMPTY
40007: LIST
40008: LIST
40009: PUSH
40010: LD_INT 0
40012: PUSH
40013: LD_INT 2
40015: NEG
40016: PUSH
40017: EMPTY
40018: LIST
40019: LIST
40020: PUSH
40021: LD_INT 1
40023: PUSH
40024: LD_INT 1
40026: NEG
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: PUSH
40032: LD_INT 2
40034: PUSH
40035: LD_INT 0
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: LD_INT 2
40044: PUSH
40045: LD_INT 1
40047: PUSH
40048: EMPTY
40049: LIST
40050: LIST
40051: PUSH
40052: LD_INT 2
40054: PUSH
40055: LD_INT 2
40057: PUSH
40058: EMPTY
40059: LIST
40060: LIST
40061: PUSH
40062: LD_INT 1
40064: PUSH
40065: LD_INT 2
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PUSH
40072: LD_INT 0
40074: PUSH
40075: LD_INT 2
40077: PUSH
40078: EMPTY
40079: LIST
40080: LIST
40081: PUSH
40082: LD_INT 1
40084: NEG
40085: PUSH
40086: LD_INT 1
40088: PUSH
40089: EMPTY
40090: LIST
40091: LIST
40092: PUSH
40093: LD_INT 2
40095: NEG
40096: PUSH
40097: LD_INT 0
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: PUSH
40104: LD_INT 2
40106: NEG
40107: PUSH
40108: LD_INT 1
40110: NEG
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 2
40118: NEG
40119: PUSH
40120: LD_INT 2
40122: NEG
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PUSH
40128: EMPTY
40129: LIST
40130: LIST
40131: LIST
40132: LIST
40133: LIST
40134: LIST
40135: LIST
40136: LIST
40137: LIST
40138: LIST
40139: LIST
40140: LIST
40141: LIST
40142: LIST
40143: LIST
40144: LIST
40145: LIST
40146: LIST
40147: LIST
40148: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40149: LD_ADDR_VAR 0 59
40153: PUSH
40154: LD_INT 0
40156: PUSH
40157: LD_INT 0
40159: PUSH
40160: EMPTY
40161: LIST
40162: LIST
40163: PUSH
40164: LD_INT 0
40166: PUSH
40167: LD_INT 1
40169: NEG
40170: PUSH
40171: EMPTY
40172: LIST
40173: LIST
40174: PUSH
40175: LD_INT 1
40177: PUSH
40178: LD_INT 0
40180: PUSH
40181: EMPTY
40182: LIST
40183: LIST
40184: PUSH
40185: LD_INT 1
40187: PUSH
40188: LD_INT 1
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: PUSH
40195: LD_INT 0
40197: PUSH
40198: LD_INT 1
40200: PUSH
40201: EMPTY
40202: LIST
40203: LIST
40204: PUSH
40205: LD_INT 1
40207: NEG
40208: PUSH
40209: LD_INT 0
40211: PUSH
40212: EMPTY
40213: LIST
40214: LIST
40215: PUSH
40216: LD_INT 1
40218: NEG
40219: PUSH
40220: LD_INT 1
40222: NEG
40223: PUSH
40224: EMPTY
40225: LIST
40226: LIST
40227: PUSH
40228: EMPTY
40229: LIST
40230: LIST
40231: LIST
40232: LIST
40233: LIST
40234: LIST
40235: LIST
40236: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40237: LD_ADDR_VAR 0 60
40241: PUSH
40242: LD_INT 0
40244: PUSH
40245: LD_INT 0
40247: PUSH
40248: EMPTY
40249: LIST
40250: LIST
40251: PUSH
40252: LD_INT 0
40254: PUSH
40255: LD_INT 1
40257: NEG
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: PUSH
40263: LD_INT 1
40265: PUSH
40266: LD_INT 0
40268: PUSH
40269: EMPTY
40270: LIST
40271: LIST
40272: PUSH
40273: LD_INT 1
40275: PUSH
40276: LD_INT 1
40278: PUSH
40279: EMPTY
40280: LIST
40281: LIST
40282: PUSH
40283: LD_INT 0
40285: PUSH
40286: LD_INT 1
40288: PUSH
40289: EMPTY
40290: LIST
40291: LIST
40292: PUSH
40293: LD_INT 1
40295: NEG
40296: PUSH
40297: LD_INT 0
40299: PUSH
40300: EMPTY
40301: LIST
40302: LIST
40303: PUSH
40304: LD_INT 1
40306: NEG
40307: PUSH
40308: LD_INT 1
40310: NEG
40311: PUSH
40312: EMPTY
40313: LIST
40314: LIST
40315: PUSH
40316: EMPTY
40317: LIST
40318: LIST
40319: LIST
40320: LIST
40321: LIST
40322: LIST
40323: LIST
40324: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40325: LD_ADDR_VAR 0 61
40329: PUSH
40330: LD_INT 0
40332: PUSH
40333: LD_INT 0
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: PUSH
40340: LD_INT 0
40342: PUSH
40343: LD_INT 1
40345: NEG
40346: PUSH
40347: EMPTY
40348: LIST
40349: LIST
40350: PUSH
40351: LD_INT 1
40353: PUSH
40354: LD_INT 0
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 1
40363: PUSH
40364: LD_INT 1
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: PUSH
40371: LD_INT 0
40373: PUSH
40374: LD_INT 1
40376: PUSH
40377: EMPTY
40378: LIST
40379: LIST
40380: PUSH
40381: LD_INT 1
40383: NEG
40384: PUSH
40385: LD_INT 0
40387: PUSH
40388: EMPTY
40389: LIST
40390: LIST
40391: PUSH
40392: LD_INT 1
40394: NEG
40395: PUSH
40396: LD_INT 1
40398: NEG
40399: PUSH
40400: EMPTY
40401: LIST
40402: LIST
40403: PUSH
40404: EMPTY
40405: LIST
40406: LIST
40407: LIST
40408: LIST
40409: LIST
40410: LIST
40411: LIST
40412: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40413: LD_ADDR_VAR 0 62
40417: PUSH
40418: LD_INT 0
40420: PUSH
40421: LD_INT 0
40423: PUSH
40424: EMPTY
40425: LIST
40426: LIST
40427: PUSH
40428: LD_INT 0
40430: PUSH
40431: LD_INT 1
40433: NEG
40434: PUSH
40435: EMPTY
40436: LIST
40437: LIST
40438: PUSH
40439: LD_INT 1
40441: PUSH
40442: LD_INT 0
40444: PUSH
40445: EMPTY
40446: LIST
40447: LIST
40448: PUSH
40449: LD_INT 1
40451: PUSH
40452: LD_INT 1
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: LD_INT 0
40461: PUSH
40462: LD_INT 1
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: LD_INT 1
40471: NEG
40472: PUSH
40473: LD_INT 0
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PUSH
40480: LD_INT 1
40482: NEG
40483: PUSH
40484: LD_INT 1
40486: NEG
40487: PUSH
40488: EMPTY
40489: LIST
40490: LIST
40491: PUSH
40492: EMPTY
40493: LIST
40494: LIST
40495: LIST
40496: LIST
40497: LIST
40498: LIST
40499: LIST
40500: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40501: LD_ADDR_VAR 0 63
40505: PUSH
40506: LD_INT 0
40508: PUSH
40509: LD_INT 0
40511: PUSH
40512: EMPTY
40513: LIST
40514: LIST
40515: PUSH
40516: LD_INT 0
40518: PUSH
40519: LD_INT 1
40521: NEG
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: PUSH
40527: LD_INT 1
40529: PUSH
40530: LD_INT 0
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: PUSH
40537: LD_INT 1
40539: PUSH
40540: LD_INT 1
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: PUSH
40547: LD_INT 0
40549: PUSH
40550: LD_INT 1
40552: PUSH
40553: EMPTY
40554: LIST
40555: LIST
40556: PUSH
40557: LD_INT 1
40559: NEG
40560: PUSH
40561: LD_INT 0
40563: PUSH
40564: EMPTY
40565: LIST
40566: LIST
40567: PUSH
40568: LD_INT 1
40570: NEG
40571: PUSH
40572: LD_INT 1
40574: NEG
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: PUSH
40580: EMPTY
40581: LIST
40582: LIST
40583: LIST
40584: LIST
40585: LIST
40586: LIST
40587: LIST
40588: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40589: LD_ADDR_VAR 0 64
40593: PUSH
40594: LD_INT 0
40596: PUSH
40597: LD_INT 0
40599: PUSH
40600: EMPTY
40601: LIST
40602: LIST
40603: PUSH
40604: LD_INT 0
40606: PUSH
40607: LD_INT 1
40609: NEG
40610: PUSH
40611: EMPTY
40612: LIST
40613: LIST
40614: PUSH
40615: LD_INT 1
40617: PUSH
40618: LD_INT 0
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: PUSH
40625: LD_INT 1
40627: PUSH
40628: LD_INT 1
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: LD_INT 0
40637: PUSH
40638: LD_INT 1
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: LD_INT 1
40647: NEG
40648: PUSH
40649: LD_INT 0
40651: PUSH
40652: EMPTY
40653: LIST
40654: LIST
40655: PUSH
40656: LD_INT 1
40658: NEG
40659: PUSH
40660: LD_INT 1
40662: NEG
40663: PUSH
40664: EMPTY
40665: LIST
40666: LIST
40667: PUSH
40668: EMPTY
40669: LIST
40670: LIST
40671: LIST
40672: LIST
40673: LIST
40674: LIST
40675: LIST
40676: ST_TO_ADDR
// end ; 1 :
40677: GO 46574
40679: LD_INT 1
40681: DOUBLE
40682: EQUAL
40683: IFTRUE 40687
40685: GO 43310
40687: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40688: LD_ADDR_VAR 0 11
40692: PUSH
40693: LD_INT 1
40695: NEG
40696: PUSH
40697: LD_INT 3
40699: NEG
40700: PUSH
40701: EMPTY
40702: LIST
40703: LIST
40704: PUSH
40705: LD_INT 0
40707: PUSH
40708: LD_INT 3
40710: NEG
40711: PUSH
40712: EMPTY
40713: LIST
40714: LIST
40715: PUSH
40716: LD_INT 1
40718: PUSH
40719: LD_INT 2
40721: NEG
40722: PUSH
40723: EMPTY
40724: LIST
40725: LIST
40726: PUSH
40727: EMPTY
40728: LIST
40729: LIST
40730: LIST
40731: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40732: LD_ADDR_VAR 0 12
40736: PUSH
40737: LD_INT 2
40739: PUSH
40740: LD_INT 1
40742: NEG
40743: PUSH
40744: EMPTY
40745: LIST
40746: LIST
40747: PUSH
40748: LD_INT 3
40750: PUSH
40751: LD_INT 0
40753: PUSH
40754: EMPTY
40755: LIST
40756: LIST
40757: PUSH
40758: LD_INT 3
40760: PUSH
40761: LD_INT 1
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: LIST
40772: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40773: LD_ADDR_VAR 0 13
40777: PUSH
40778: LD_INT 3
40780: PUSH
40781: LD_INT 2
40783: PUSH
40784: EMPTY
40785: LIST
40786: LIST
40787: PUSH
40788: LD_INT 3
40790: PUSH
40791: LD_INT 3
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: PUSH
40798: LD_INT 2
40800: PUSH
40801: LD_INT 3
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: LIST
40812: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40813: LD_ADDR_VAR 0 14
40817: PUSH
40818: LD_INT 1
40820: PUSH
40821: LD_INT 3
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: PUSH
40828: LD_INT 0
40830: PUSH
40831: LD_INT 3
40833: PUSH
40834: EMPTY
40835: LIST
40836: LIST
40837: PUSH
40838: LD_INT 1
40840: NEG
40841: PUSH
40842: LD_INT 2
40844: PUSH
40845: EMPTY
40846: LIST
40847: LIST
40848: PUSH
40849: EMPTY
40850: LIST
40851: LIST
40852: LIST
40853: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40854: LD_ADDR_VAR 0 15
40858: PUSH
40859: LD_INT 2
40861: NEG
40862: PUSH
40863: LD_INT 1
40865: PUSH
40866: EMPTY
40867: LIST
40868: LIST
40869: PUSH
40870: LD_INT 3
40872: NEG
40873: PUSH
40874: LD_INT 0
40876: PUSH
40877: EMPTY
40878: LIST
40879: LIST
40880: PUSH
40881: LD_INT 3
40883: NEG
40884: PUSH
40885: LD_INT 1
40887: NEG
40888: PUSH
40889: EMPTY
40890: LIST
40891: LIST
40892: PUSH
40893: EMPTY
40894: LIST
40895: LIST
40896: LIST
40897: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40898: LD_ADDR_VAR 0 16
40902: PUSH
40903: LD_INT 2
40905: NEG
40906: PUSH
40907: LD_INT 3
40909: NEG
40910: PUSH
40911: EMPTY
40912: LIST
40913: LIST
40914: PUSH
40915: LD_INT 3
40917: NEG
40918: PUSH
40919: LD_INT 2
40921: NEG
40922: PUSH
40923: EMPTY
40924: LIST
40925: LIST
40926: PUSH
40927: LD_INT 3
40929: NEG
40930: PUSH
40931: LD_INT 3
40933: NEG
40934: PUSH
40935: EMPTY
40936: LIST
40937: LIST
40938: PUSH
40939: EMPTY
40940: LIST
40941: LIST
40942: LIST
40943: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40944: LD_ADDR_VAR 0 17
40948: PUSH
40949: LD_INT 1
40951: NEG
40952: PUSH
40953: LD_INT 3
40955: NEG
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: LD_INT 0
40963: PUSH
40964: LD_INT 3
40966: NEG
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: LD_INT 1
40974: PUSH
40975: LD_INT 2
40977: NEG
40978: PUSH
40979: EMPTY
40980: LIST
40981: LIST
40982: PUSH
40983: EMPTY
40984: LIST
40985: LIST
40986: LIST
40987: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40988: LD_ADDR_VAR 0 18
40992: PUSH
40993: LD_INT 2
40995: PUSH
40996: LD_INT 1
40998: NEG
40999: PUSH
41000: EMPTY
41001: LIST
41002: LIST
41003: PUSH
41004: LD_INT 3
41006: PUSH
41007: LD_INT 0
41009: PUSH
41010: EMPTY
41011: LIST
41012: LIST
41013: PUSH
41014: LD_INT 3
41016: PUSH
41017: LD_INT 1
41019: PUSH
41020: EMPTY
41021: LIST
41022: LIST
41023: PUSH
41024: EMPTY
41025: LIST
41026: LIST
41027: LIST
41028: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41029: LD_ADDR_VAR 0 19
41033: PUSH
41034: LD_INT 3
41036: PUSH
41037: LD_INT 2
41039: PUSH
41040: EMPTY
41041: LIST
41042: LIST
41043: PUSH
41044: LD_INT 3
41046: PUSH
41047: LD_INT 3
41049: PUSH
41050: EMPTY
41051: LIST
41052: LIST
41053: PUSH
41054: LD_INT 2
41056: PUSH
41057: LD_INT 3
41059: PUSH
41060: EMPTY
41061: LIST
41062: LIST
41063: PUSH
41064: EMPTY
41065: LIST
41066: LIST
41067: LIST
41068: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41069: LD_ADDR_VAR 0 20
41073: PUSH
41074: LD_INT 1
41076: PUSH
41077: LD_INT 3
41079: PUSH
41080: EMPTY
41081: LIST
41082: LIST
41083: PUSH
41084: LD_INT 0
41086: PUSH
41087: LD_INT 3
41089: PUSH
41090: EMPTY
41091: LIST
41092: LIST
41093: PUSH
41094: LD_INT 1
41096: NEG
41097: PUSH
41098: LD_INT 2
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: PUSH
41105: EMPTY
41106: LIST
41107: LIST
41108: LIST
41109: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41110: LD_ADDR_VAR 0 21
41114: PUSH
41115: LD_INT 2
41117: NEG
41118: PUSH
41119: LD_INT 1
41121: PUSH
41122: EMPTY
41123: LIST
41124: LIST
41125: PUSH
41126: LD_INT 3
41128: NEG
41129: PUSH
41130: LD_INT 0
41132: PUSH
41133: EMPTY
41134: LIST
41135: LIST
41136: PUSH
41137: LD_INT 3
41139: NEG
41140: PUSH
41141: LD_INT 1
41143: NEG
41144: PUSH
41145: EMPTY
41146: LIST
41147: LIST
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: LIST
41153: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41154: LD_ADDR_VAR 0 22
41158: PUSH
41159: LD_INT 2
41161: NEG
41162: PUSH
41163: LD_INT 3
41165: NEG
41166: PUSH
41167: EMPTY
41168: LIST
41169: LIST
41170: PUSH
41171: LD_INT 3
41173: NEG
41174: PUSH
41175: LD_INT 2
41177: NEG
41178: PUSH
41179: EMPTY
41180: LIST
41181: LIST
41182: PUSH
41183: LD_INT 3
41185: NEG
41186: PUSH
41187: LD_INT 3
41189: NEG
41190: PUSH
41191: EMPTY
41192: LIST
41193: LIST
41194: PUSH
41195: EMPTY
41196: LIST
41197: LIST
41198: LIST
41199: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41200: LD_ADDR_VAR 0 23
41204: PUSH
41205: LD_INT 0
41207: PUSH
41208: LD_INT 3
41210: NEG
41211: PUSH
41212: EMPTY
41213: LIST
41214: LIST
41215: PUSH
41216: LD_INT 1
41218: NEG
41219: PUSH
41220: LD_INT 4
41222: NEG
41223: PUSH
41224: EMPTY
41225: LIST
41226: LIST
41227: PUSH
41228: LD_INT 1
41230: PUSH
41231: LD_INT 3
41233: NEG
41234: PUSH
41235: EMPTY
41236: LIST
41237: LIST
41238: PUSH
41239: EMPTY
41240: LIST
41241: LIST
41242: LIST
41243: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41244: LD_ADDR_VAR 0 24
41248: PUSH
41249: LD_INT 3
41251: PUSH
41252: LD_INT 0
41254: PUSH
41255: EMPTY
41256: LIST
41257: LIST
41258: PUSH
41259: LD_INT 3
41261: PUSH
41262: LD_INT 1
41264: NEG
41265: PUSH
41266: EMPTY
41267: LIST
41268: LIST
41269: PUSH
41270: LD_INT 4
41272: PUSH
41273: LD_INT 1
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: PUSH
41280: EMPTY
41281: LIST
41282: LIST
41283: LIST
41284: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41285: LD_ADDR_VAR 0 25
41289: PUSH
41290: LD_INT 3
41292: PUSH
41293: LD_INT 3
41295: PUSH
41296: EMPTY
41297: LIST
41298: LIST
41299: PUSH
41300: LD_INT 4
41302: PUSH
41303: LD_INT 3
41305: PUSH
41306: EMPTY
41307: LIST
41308: LIST
41309: PUSH
41310: LD_INT 3
41312: PUSH
41313: LD_INT 4
41315: PUSH
41316: EMPTY
41317: LIST
41318: LIST
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: LIST
41324: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41325: LD_ADDR_VAR 0 26
41329: PUSH
41330: LD_INT 0
41332: PUSH
41333: LD_INT 3
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: PUSH
41340: LD_INT 1
41342: PUSH
41343: LD_INT 4
41345: PUSH
41346: EMPTY
41347: LIST
41348: LIST
41349: PUSH
41350: LD_INT 1
41352: NEG
41353: PUSH
41354: LD_INT 3
41356: PUSH
41357: EMPTY
41358: LIST
41359: LIST
41360: PUSH
41361: EMPTY
41362: LIST
41363: LIST
41364: LIST
41365: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41366: LD_ADDR_VAR 0 27
41370: PUSH
41371: LD_INT 3
41373: NEG
41374: PUSH
41375: LD_INT 0
41377: PUSH
41378: EMPTY
41379: LIST
41380: LIST
41381: PUSH
41382: LD_INT 3
41384: NEG
41385: PUSH
41386: LD_INT 1
41388: PUSH
41389: EMPTY
41390: LIST
41391: LIST
41392: PUSH
41393: LD_INT 4
41395: NEG
41396: PUSH
41397: LD_INT 1
41399: NEG
41400: PUSH
41401: EMPTY
41402: LIST
41403: LIST
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: LIST
41409: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41410: LD_ADDR_VAR 0 28
41414: PUSH
41415: LD_INT 3
41417: NEG
41418: PUSH
41419: LD_INT 3
41421: NEG
41422: PUSH
41423: EMPTY
41424: LIST
41425: LIST
41426: PUSH
41427: LD_INT 3
41429: NEG
41430: PUSH
41431: LD_INT 4
41433: NEG
41434: PUSH
41435: EMPTY
41436: LIST
41437: LIST
41438: PUSH
41439: LD_INT 4
41441: NEG
41442: PUSH
41443: LD_INT 3
41445: NEG
41446: PUSH
41447: EMPTY
41448: LIST
41449: LIST
41450: PUSH
41451: EMPTY
41452: LIST
41453: LIST
41454: LIST
41455: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41456: LD_ADDR_VAR 0 29
41460: PUSH
41461: LD_INT 1
41463: NEG
41464: PUSH
41465: LD_INT 3
41467: NEG
41468: PUSH
41469: EMPTY
41470: LIST
41471: LIST
41472: PUSH
41473: LD_INT 0
41475: PUSH
41476: LD_INT 3
41478: NEG
41479: PUSH
41480: EMPTY
41481: LIST
41482: LIST
41483: PUSH
41484: LD_INT 1
41486: PUSH
41487: LD_INT 2
41489: NEG
41490: PUSH
41491: EMPTY
41492: LIST
41493: LIST
41494: PUSH
41495: LD_INT 1
41497: NEG
41498: PUSH
41499: LD_INT 4
41501: NEG
41502: PUSH
41503: EMPTY
41504: LIST
41505: LIST
41506: PUSH
41507: LD_INT 0
41509: PUSH
41510: LD_INT 4
41512: NEG
41513: PUSH
41514: EMPTY
41515: LIST
41516: LIST
41517: PUSH
41518: LD_INT 1
41520: PUSH
41521: LD_INT 3
41523: NEG
41524: PUSH
41525: EMPTY
41526: LIST
41527: LIST
41528: PUSH
41529: LD_INT 1
41531: NEG
41532: PUSH
41533: LD_INT 5
41535: NEG
41536: PUSH
41537: EMPTY
41538: LIST
41539: LIST
41540: PUSH
41541: LD_INT 0
41543: PUSH
41544: LD_INT 5
41546: NEG
41547: PUSH
41548: EMPTY
41549: LIST
41550: LIST
41551: PUSH
41552: LD_INT 1
41554: PUSH
41555: LD_INT 4
41557: NEG
41558: PUSH
41559: EMPTY
41560: LIST
41561: LIST
41562: PUSH
41563: LD_INT 1
41565: NEG
41566: PUSH
41567: LD_INT 6
41569: NEG
41570: PUSH
41571: EMPTY
41572: LIST
41573: LIST
41574: PUSH
41575: LD_INT 0
41577: PUSH
41578: LD_INT 6
41580: NEG
41581: PUSH
41582: EMPTY
41583: LIST
41584: LIST
41585: PUSH
41586: LD_INT 1
41588: PUSH
41589: LD_INT 5
41591: NEG
41592: PUSH
41593: EMPTY
41594: LIST
41595: LIST
41596: PUSH
41597: EMPTY
41598: LIST
41599: LIST
41600: LIST
41601: LIST
41602: LIST
41603: LIST
41604: LIST
41605: LIST
41606: LIST
41607: LIST
41608: LIST
41609: LIST
41610: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41611: LD_ADDR_VAR 0 30
41615: PUSH
41616: LD_INT 2
41618: PUSH
41619: LD_INT 1
41621: NEG
41622: PUSH
41623: EMPTY
41624: LIST
41625: LIST
41626: PUSH
41627: LD_INT 3
41629: PUSH
41630: LD_INT 0
41632: PUSH
41633: EMPTY
41634: LIST
41635: LIST
41636: PUSH
41637: LD_INT 3
41639: PUSH
41640: LD_INT 1
41642: PUSH
41643: EMPTY
41644: LIST
41645: LIST
41646: PUSH
41647: LD_INT 3
41649: PUSH
41650: LD_INT 1
41652: NEG
41653: PUSH
41654: EMPTY
41655: LIST
41656: LIST
41657: PUSH
41658: LD_INT 4
41660: PUSH
41661: LD_INT 0
41663: PUSH
41664: EMPTY
41665: LIST
41666: LIST
41667: PUSH
41668: LD_INT 4
41670: PUSH
41671: LD_INT 1
41673: PUSH
41674: EMPTY
41675: LIST
41676: LIST
41677: PUSH
41678: LD_INT 4
41680: PUSH
41681: LD_INT 1
41683: NEG
41684: PUSH
41685: EMPTY
41686: LIST
41687: LIST
41688: PUSH
41689: LD_INT 5
41691: PUSH
41692: LD_INT 0
41694: PUSH
41695: EMPTY
41696: LIST
41697: LIST
41698: PUSH
41699: LD_INT 5
41701: PUSH
41702: LD_INT 1
41704: PUSH
41705: EMPTY
41706: LIST
41707: LIST
41708: PUSH
41709: LD_INT 5
41711: PUSH
41712: LD_INT 1
41714: NEG
41715: PUSH
41716: EMPTY
41717: LIST
41718: LIST
41719: PUSH
41720: LD_INT 6
41722: PUSH
41723: LD_INT 0
41725: PUSH
41726: EMPTY
41727: LIST
41728: LIST
41729: PUSH
41730: LD_INT 6
41732: PUSH
41733: LD_INT 1
41735: PUSH
41736: EMPTY
41737: LIST
41738: LIST
41739: PUSH
41740: EMPTY
41741: LIST
41742: LIST
41743: LIST
41744: LIST
41745: LIST
41746: LIST
41747: LIST
41748: LIST
41749: LIST
41750: LIST
41751: LIST
41752: LIST
41753: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41754: LD_ADDR_VAR 0 31
41758: PUSH
41759: LD_INT 3
41761: PUSH
41762: LD_INT 2
41764: PUSH
41765: EMPTY
41766: LIST
41767: LIST
41768: PUSH
41769: LD_INT 3
41771: PUSH
41772: LD_INT 3
41774: PUSH
41775: EMPTY
41776: LIST
41777: LIST
41778: PUSH
41779: LD_INT 2
41781: PUSH
41782: LD_INT 3
41784: PUSH
41785: EMPTY
41786: LIST
41787: LIST
41788: PUSH
41789: LD_INT 4
41791: PUSH
41792: LD_INT 3
41794: PUSH
41795: EMPTY
41796: LIST
41797: LIST
41798: PUSH
41799: LD_INT 4
41801: PUSH
41802: LD_INT 4
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: PUSH
41809: LD_INT 3
41811: PUSH
41812: LD_INT 4
41814: PUSH
41815: EMPTY
41816: LIST
41817: LIST
41818: PUSH
41819: LD_INT 5
41821: PUSH
41822: LD_INT 4
41824: PUSH
41825: EMPTY
41826: LIST
41827: LIST
41828: PUSH
41829: LD_INT 5
41831: PUSH
41832: LD_INT 5
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 4
41841: PUSH
41842: LD_INT 5
41844: PUSH
41845: EMPTY
41846: LIST
41847: LIST
41848: PUSH
41849: LD_INT 6
41851: PUSH
41852: LD_INT 5
41854: PUSH
41855: EMPTY
41856: LIST
41857: LIST
41858: PUSH
41859: LD_INT 6
41861: PUSH
41862: LD_INT 6
41864: PUSH
41865: EMPTY
41866: LIST
41867: LIST
41868: PUSH
41869: LD_INT 5
41871: PUSH
41872: LD_INT 6
41874: PUSH
41875: EMPTY
41876: LIST
41877: LIST
41878: PUSH
41879: EMPTY
41880: LIST
41881: LIST
41882: LIST
41883: LIST
41884: LIST
41885: LIST
41886: LIST
41887: LIST
41888: LIST
41889: LIST
41890: LIST
41891: LIST
41892: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41893: LD_ADDR_VAR 0 32
41897: PUSH
41898: LD_INT 1
41900: PUSH
41901: LD_INT 3
41903: PUSH
41904: EMPTY
41905: LIST
41906: LIST
41907: PUSH
41908: LD_INT 0
41910: PUSH
41911: LD_INT 3
41913: PUSH
41914: EMPTY
41915: LIST
41916: LIST
41917: PUSH
41918: LD_INT 1
41920: NEG
41921: PUSH
41922: LD_INT 2
41924: PUSH
41925: EMPTY
41926: LIST
41927: LIST
41928: PUSH
41929: LD_INT 1
41931: PUSH
41932: LD_INT 4
41934: PUSH
41935: EMPTY
41936: LIST
41937: LIST
41938: PUSH
41939: LD_INT 0
41941: PUSH
41942: LD_INT 4
41944: PUSH
41945: EMPTY
41946: LIST
41947: LIST
41948: PUSH
41949: LD_INT 1
41951: NEG
41952: PUSH
41953: LD_INT 3
41955: PUSH
41956: EMPTY
41957: LIST
41958: LIST
41959: PUSH
41960: LD_INT 1
41962: PUSH
41963: LD_INT 5
41965: PUSH
41966: EMPTY
41967: LIST
41968: LIST
41969: PUSH
41970: LD_INT 0
41972: PUSH
41973: LD_INT 5
41975: PUSH
41976: EMPTY
41977: LIST
41978: LIST
41979: PUSH
41980: LD_INT 1
41982: NEG
41983: PUSH
41984: LD_INT 4
41986: PUSH
41987: EMPTY
41988: LIST
41989: LIST
41990: PUSH
41991: LD_INT 1
41993: PUSH
41994: LD_INT 6
41996: PUSH
41997: EMPTY
41998: LIST
41999: LIST
42000: PUSH
42001: LD_INT 0
42003: PUSH
42004: LD_INT 6
42006: PUSH
42007: EMPTY
42008: LIST
42009: LIST
42010: PUSH
42011: LD_INT 1
42013: NEG
42014: PUSH
42015: LD_INT 5
42017: PUSH
42018: EMPTY
42019: LIST
42020: LIST
42021: PUSH
42022: EMPTY
42023: LIST
42024: LIST
42025: LIST
42026: LIST
42027: LIST
42028: LIST
42029: LIST
42030: LIST
42031: LIST
42032: LIST
42033: LIST
42034: LIST
42035: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42036: LD_ADDR_VAR 0 33
42040: PUSH
42041: LD_INT 2
42043: NEG
42044: PUSH
42045: LD_INT 1
42047: PUSH
42048: EMPTY
42049: LIST
42050: LIST
42051: PUSH
42052: LD_INT 3
42054: NEG
42055: PUSH
42056: LD_INT 0
42058: PUSH
42059: EMPTY
42060: LIST
42061: LIST
42062: PUSH
42063: LD_INT 3
42065: NEG
42066: PUSH
42067: LD_INT 1
42069: NEG
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: PUSH
42075: LD_INT 3
42077: NEG
42078: PUSH
42079: LD_INT 1
42081: PUSH
42082: EMPTY
42083: LIST
42084: LIST
42085: PUSH
42086: LD_INT 4
42088: NEG
42089: PUSH
42090: LD_INT 0
42092: PUSH
42093: EMPTY
42094: LIST
42095: LIST
42096: PUSH
42097: LD_INT 4
42099: NEG
42100: PUSH
42101: LD_INT 1
42103: NEG
42104: PUSH
42105: EMPTY
42106: LIST
42107: LIST
42108: PUSH
42109: LD_INT 4
42111: NEG
42112: PUSH
42113: LD_INT 1
42115: PUSH
42116: EMPTY
42117: LIST
42118: LIST
42119: PUSH
42120: LD_INT 5
42122: NEG
42123: PUSH
42124: LD_INT 0
42126: PUSH
42127: EMPTY
42128: LIST
42129: LIST
42130: PUSH
42131: LD_INT 5
42133: NEG
42134: PUSH
42135: LD_INT 1
42137: NEG
42138: PUSH
42139: EMPTY
42140: LIST
42141: LIST
42142: PUSH
42143: LD_INT 5
42145: NEG
42146: PUSH
42147: LD_INT 1
42149: PUSH
42150: EMPTY
42151: LIST
42152: LIST
42153: PUSH
42154: LD_INT 6
42156: NEG
42157: PUSH
42158: LD_INT 0
42160: PUSH
42161: EMPTY
42162: LIST
42163: LIST
42164: PUSH
42165: LD_INT 6
42167: NEG
42168: PUSH
42169: LD_INT 1
42171: NEG
42172: PUSH
42173: EMPTY
42174: LIST
42175: LIST
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: LIST
42181: LIST
42182: LIST
42183: LIST
42184: LIST
42185: LIST
42186: LIST
42187: LIST
42188: LIST
42189: LIST
42190: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42191: LD_ADDR_VAR 0 34
42195: PUSH
42196: LD_INT 2
42198: NEG
42199: PUSH
42200: LD_INT 3
42202: NEG
42203: PUSH
42204: EMPTY
42205: LIST
42206: LIST
42207: PUSH
42208: LD_INT 3
42210: NEG
42211: PUSH
42212: LD_INT 2
42214: NEG
42215: PUSH
42216: EMPTY
42217: LIST
42218: LIST
42219: PUSH
42220: LD_INT 3
42222: NEG
42223: PUSH
42224: LD_INT 3
42226: NEG
42227: PUSH
42228: EMPTY
42229: LIST
42230: LIST
42231: PUSH
42232: LD_INT 3
42234: NEG
42235: PUSH
42236: LD_INT 4
42238: NEG
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: PUSH
42244: LD_INT 4
42246: NEG
42247: PUSH
42248: LD_INT 3
42250: NEG
42251: PUSH
42252: EMPTY
42253: LIST
42254: LIST
42255: PUSH
42256: LD_INT 4
42258: NEG
42259: PUSH
42260: LD_INT 4
42262: NEG
42263: PUSH
42264: EMPTY
42265: LIST
42266: LIST
42267: PUSH
42268: LD_INT 4
42270: NEG
42271: PUSH
42272: LD_INT 5
42274: NEG
42275: PUSH
42276: EMPTY
42277: LIST
42278: LIST
42279: PUSH
42280: LD_INT 5
42282: NEG
42283: PUSH
42284: LD_INT 4
42286: NEG
42287: PUSH
42288: EMPTY
42289: LIST
42290: LIST
42291: PUSH
42292: LD_INT 5
42294: NEG
42295: PUSH
42296: LD_INT 5
42298: NEG
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: LD_INT 5
42306: NEG
42307: PUSH
42308: LD_INT 6
42310: NEG
42311: PUSH
42312: EMPTY
42313: LIST
42314: LIST
42315: PUSH
42316: LD_INT 6
42318: NEG
42319: PUSH
42320: LD_INT 5
42322: NEG
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: PUSH
42328: LD_INT 6
42330: NEG
42331: PUSH
42332: LD_INT 6
42334: NEG
42335: PUSH
42336: EMPTY
42337: LIST
42338: LIST
42339: PUSH
42340: EMPTY
42341: LIST
42342: LIST
42343: LIST
42344: LIST
42345: LIST
42346: LIST
42347: LIST
42348: LIST
42349: LIST
42350: LIST
42351: LIST
42352: LIST
42353: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42354: LD_ADDR_VAR 0 41
42358: PUSH
42359: LD_INT 0
42361: PUSH
42362: LD_INT 2
42364: NEG
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: LD_INT 1
42372: NEG
42373: PUSH
42374: LD_INT 3
42376: NEG
42377: PUSH
42378: EMPTY
42379: LIST
42380: LIST
42381: PUSH
42382: LD_INT 1
42384: PUSH
42385: LD_INT 2
42387: NEG
42388: PUSH
42389: EMPTY
42390: LIST
42391: LIST
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: LIST
42397: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42398: LD_ADDR_VAR 0 42
42402: PUSH
42403: LD_INT 2
42405: PUSH
42406: LD_INT 0
42408: PUSH
42409: EMPTY
42410: LIST
42411: LIST
42412: PUSH
42413: LD_INT 2
42415: PUSH
42416: LD_INT 1
42418: NEG
42419: PUSH
42420: EMPTY
42421: LIST
42422: LIST
42423: PUSH
42424: LD_INT 3
42426: PUSH
42427: LD_INT 1
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: EMPTY
42435: LIST
42436: LIST
42437: LIST
42438: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42439: LD_ADDR_VAR 0 43
42443: PUSH
42444: LD_INT 2
42446: PUSH
42447: LD_INT 2
42449: PUSH
42450: EMPTY
42451: LIST
42452: LIST
42453: PUSH
42454: LD_INT 3
42456: PUSH
42457: LD_INT 2
42459: PUSH
42460: EMPTY
42461: LIST
42462: LIST
42463: PUSH
42464: LD_INT 2
42466: PUSH
42467: LD_INT 3
42469: PUSH
42470: EMPTY
42471: LIST
42472: LIST
42473: PUSH
42474: EMPTY
42475: LIST
42476: LIST
42477: LIST
42478: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42479: LD_ADDR_VAR 0 44
42483: PUSH
42484: LD_INT 0
42486: PUSH
42487: LD_INT 2
42489: PUSH
42490: EMPTY
42491: LIST
42492: LIST
42493: PUSH
42494: LD_INT 1
42496: PUSH
42497: LD_INT 3
42499: PUSH
42500: EMPTY
42501: LIST
42502: LIST
42503: PUSH
42504: LD_INT 1
42506: NEG
42507: PUSH
42508: LD_INT 2
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: PUSH
42515: EMPTY
42516: LIST
42517: LIST
42518: LIST
42519: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42520: LD_ADDR_VAR 0 45
42524: PUSH
42525: LD_INT 2
42527: NEG
42528: PUSH
42529: LD_INT 0
42531: PUSH
42532: EMPTY
42533: LIST
42534: LIST
42535: PUSH
42536: LD_INT 2
42538: NEG
42539: PUSH
42540: LD_INT 1
42542: PUSH
42543: EMPTY
42544: LIST
42545: LIST
42546: PUSH
42547: LD_INT 3
42549: NEG
42550: PUSH
42551: LD_INT 1
42553: NEG
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: LIST
42563: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42564: LD_ADDR_VAR 0 46
42568: PUSH
42569: LD_INT 2
42571: NEG
42572: PUSH
42573: LD_INT 2
42575: NEG
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: PUSH
42581: LD_INT 2
42583: NEG
42584: PUSH
42585: LD_INT 3
42587: NEG
42588: PUSH
42589: EMPTY
42590: LIST
42591: LIST
42592: PUSH
42593: LD_INT 3
42595: NEG
42596: PUSH
42597: LD_INT 2
42599: NEG
42600: PUSH
42601: EMPTY
42602: LIST
42603: LIST
42604: PUSH
42605: EMPTY
42606: LIST
42607: LIST
42608: LIST
42609: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42610: LD_ADDR_VAR 0 47
42614: PUSH
42615: LD_INT 2
42617: NEG
42618: PUSH
42619: LD_INT 3
42621: NEG
42622: PUSH
42623: EMPTY
42624: LIST
42625: LIST
42626: PUSH
42627: LD_INT 1
42629: NEG
42630: PUSH
42631: LD_INT 3
42633: NEG
42634: PUSH
42635: EMPTY
42636: LIST
42637: LIST
42638: PUSH
42639: EMPTY
42640: LIST
42641: LIST
42642: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42643: LD_ADDR_VAR 0 48
42647: PUSH
42648: LD_INT 1
42650: PUSH
42651: LD_INT 2
42653: NEG
42654: PUSH
42655: EMPTY
42656: LIST
42657: LIST
42658: PUSH
42659: LD_INT 2
42661: PUSH
42662: LD_INT 1
42664: NEG
42665: PUSH
42666: EMPTY
42667: LIST
42668: LIST
42669: PUSH
42670: EMPTY
42671: LIST
42672: LIST
42673: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42674: LD_ADDR_VAR 0 49
42678: PUSH
42679: LD_INT 3
42681: PUSH
42682: LD_INT 1
42684: PUSH
42685: EMPTY
42686: LIST
42687: LIST
42688: PUSH
42689: LD_INT 3
42691: PUSH
42692: LD_INT 2
42694: PUSH
42695: EMPTY
42696: LIST
42697: LIST
42698: PUSH
42699: EMPTY
42700: LIST
42701: LIST
42702: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42703: LD_ADDR_VAR 0 50
42707: PUSH
42708: LD_INT 2
42710: PUSH
42711: LD_INT 3
42713: PUSH
42714: EMPTY
42715: LIST
42716: LIST
42717: PUSH
42718: LD_INT 1
42720: PUSH
42721: LD_INT 3
42723: PUSH
42724: EMPTY
42725: LIST
42726: LIST
42727: PUSH
42728: EMPTY
42729: LIST
42730: LIST
42731: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42732: LD_ADDR_VAR 0 51
42736: PUSH
42737: LD_INT 1
42739: NEG
42740: PUSH
42741: LD_INT 2
42743: PUSH
42744: EMPTY
42745: LIST
42746: LIST
42747: PUSH
42748: LD_INT 2
42750: NEG
42751: PUSH
42752: LD_INT 1
42754: PUSH
42755: EMPTY
42756: LIST
42757: LIST
42758: PUSH
42759: EMPTY
42760: LIST
42761: LIST
42762: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42763: LD_ADDR_VAR 0 52
42767: PUSH
42768: LD_INT 3
42770: NEG
42771: PUSH
42772: LD_INT 1
42774: NEG
42775: PUSH
42776: EMPTY
42777: LIST
42778: LIST
42779: PUSH
42780: LD_INT 3
42782: NEG
42783: PUSH
42784: LD_INT 2
42786: NEG
42787: PUSH
42788: EMPTY
42789: LIST
42790: LIST
42791: PUSH
42792: EMPTY
42793: LIST
42794: LIST
42795: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42796: LD_ADDR_VAR 0 53
42800: PUSH
42801: LD_INT 1
42803: NEG
42804: PUSH
42805: LD_INT 3
42807: NEG
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: PUSH
42813: LD_INT 0
42815: PUSH
42816: LD_INT 3
42818: NEG
42819: PUSH
42820: EMPTY
42821: LIST
42822: LIST
42823: PUSH
42824: LD_INT 1
42826: PUSH
42827: LD_INT 2
42829: NEG
42830: PUSH
42831: EMPTY
42832: LIST
42833: LIST
42834: PUSH
42835: EMPTY
42836: LIST
42837: LIST
42838: LIST
42839: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42840: LD_ADDR_VAR 0 54
42844: PUSH
42845: LD_INT 2
42847: PUSH
42848: LD_INT 1
42850: NEG
42851: PUSH
42852: EMPTY
42853: LIST
42854: LIST
42855: PUSH
42856: LD_INT 3
42858: PUSH
42859: LD_INT 0
42861: PUSH
42862: EMPTY
42863: LIST
42864: LIST
42865: PUSH
42866: LD_INT 3
42868: PUSH
42869: LD_INT 1
42871: PUSH
42872: EMPTY
42873: LIST
42874: LIST
42875: PUSH
42876: EMPTY
42877: LIST
42878: LIST
42879: LIST
42880: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42881: LD_ADDR_VAR 0 55
42885: PUSH
42886: LD_INT 3
42888: PUSH
42889: LD_INT 2
42891: PUSH
42892: EMPTY
42893: LIST
42894: LIST
42895: PUSH
42896: LD_INT 3
42898: PUSH
42899: LD_INT 3
42901: PUSH
42902: EMPTY
42903: LIST
42904: LIST
42905: PUSH
42906: LD_INT 2
42908: PUSH
42909: LD_INT 3
42911: PUSH
42912: EMPTY
42913: LIST
42914: LIST
42915: PUSH
42916: EMPTY
42917: LIST
42918: LIST
42919: LIST
42920: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42921: LD_ADDR_VAR 0 56
42925: PUSH
42926: LD_INT 1
42928: PUSH
42929: LD_INT 3
42931: PUSH
42932: EMPTY
42933: LIST
42934: LIST
42935: PUSH
42936: LD_INT 0
42938: PUSH
42939: LD_INT 3
42941: PUSH
42942: EMPTY
42943: LIST
42944: LIST
42945: PUSH
42946: LD_INT 1
42948: NEG
42949: PUSH
42950: LD_INT 2
42952: PUSH
42953: EMPTY
42954: LIST
42955: LIST
42956: PUSH
42957: EMPTY
42958: LIST
42959: LIST
42960: LIST
42961: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42962: LD_ADDR_VAR 0 57
42966: PUSH
42967: LD_INT 2
42969: NEG
42970: PUSH
42971: LD_INT 1
42973: PUSH
42974: EMPTY
42975: LIST
42976: LIST
42977: PUSH
42978: LD_INT 3
42980: NEG
42981: PUSH
42982: LD_INT 0
42984: PUSH
42985: EMPTY
42986: LIST
42987: LIST
42988: PUSH
42989: LD_INT 3
42991: NEG
42992: PUSH
42993: LD_INT 1
42995: NEG
42996: PUSH
42997: EMPTY
42998: LIST
42999: LIST
43000: PUSH
43001: EMPTY
43002: LIST
43003: LIST
43004: LIST
43005: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43006: LD_ADDR_VAR 0 58
43010: PUSH
43011: LD_INT 2
43013: NEG
43014: PUSH
43015: LD_INT 3
43017: NEG
43018: PUSH
43019: EMPTY
43020: LIST
43021: LIST
43022: PUSH
43023: LD_INT 3
43025: NEG
43026: PUSH
43027: LD_INT 2
43029: NEG
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: LD_INT 3
43037: NEG
43038: PUSH
43039: LD_INT 3
43041: NEG
43042: PUSH
43043: EMPTY
43044: LIST
43045: LIST
43046: PUSH
43047: EMPTY
43048: LIST
43049: LIST
43050: LIST
43051: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43052: LD_ADDR_VAR 0 59
43056: PUSH
43057: LD_INT 1
43059: NEG
43060: PUSH
43061: LD_INT 2
43063: NEG
43064: PUSH
43065: EMPTY
43066: LIST
43067: LIST
43068: PUSH
43069: LD_INT 0
43071: PUSH
43072: LD_INT 2
43074: NEG
43075: PUSH
43076: EMPTY
43077: LIST
43078: LIST
43079: PUSH
43080: LD_INT 1
43082: PUSH
43083: LD_INT 1
43085: NEG
43086: PUSH
43087: EMPTY
43088: LIST
43089: LIST
43090: PUSH
43091: EMPTY
43092: LIST
43093: LIST
43094: LIST
43095: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43096: LD_ADDR_VAR 0 60
43100: PUSH
43101: LD_INT 1
43103: PUSH
43104: LD_INT 1
43106: NEG
43107: PUSH
43108: EMPTY
43109: LIST
43110: LIST
43111: PUSH
43112: LD_INT 2
43114: PUSH
43115: LD_INT 0
43117: PUSH
43118: EMPTY
43119: LIST
43120: LIST
43121: PUSH
43122: LD_INT 2
43124: PUSH
43125: LD_INT 1
43127: PUSH
43128: EMPTY
43129: LIST
43130: LIST
43131: PUSH
43132: EMPTY
43133: LIST
43134: LIST
43135: LIST
43136: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43137: LD_ADDR_VAR 0 61
43141: PUSH
43142: LD_INT 2
43144: PUSH
43145: LD_INT 1
43147: PUSH
43148: EMPTY
43149: LIST
43150: LIST
43151: PUSH
43152: LD_INT 2
43154: PUSH
43155: LD_INT 2
43157: PUSH
43158: EMPTY
43159: LIST
43160: LIST
43161: PUSH
43162: LD_INT 1
43164: PUSH
43165: LD_INT 2
43167: PUSH
43168: EMPTY
43169: LIST
43170: LIST
43171: PUSH
43172: EMPTY
43173: LIST
43174: LIST
43175: LIST
43176: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43177: LD_ADDR_VAR 0 62
43181: PUSH
43182: LD_INT 1
43184: PUSH
43185: LD_INT 2
43187: PUSH
43188: EMPTY
43189: LIST
43190: LIST
43191: PUSH
43192: LD_INT 0
43194: PUSH
43195: LD_INT 2
43197: PUSH
43198: EMPTY
43199: LIST
43200: LIST
43201: PUSH
43202: LD_INT 1
43204: NEG
43205: PUSH
43206: LD_INT 1
43208: PUSH
43209: EMPTY
43210: LIST
43211: LIST
43212: PUSH
43213: EMPTY
43214: LIST
43215: LIST
43216: LIST
43217: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43218: LD_ADDR_VAR 0 63
43222: PUSH
43223: LD_INT 1
43225: NEG
43226: PUSH
43227: LD_INT 1
43229: PUSH
43230: EMPTY
43231: LIST
43232: LIST
43233: PUSH
43234: LD_INT 2
43236: NEG
43237: PUSH
43238: LD_INT 0
43240: PUSH
43241: EMPTY
43242: LIST
43243: LIST
43244: PUSH
43245: LD_INT 2
43247: NEG
43248: PUSH
43249: LD_INT 1
43251: NEG
43252: PUSH
43253: EMPTY
43254: LIST
43255: LIST
43256: PUSH
43257: EMPTY
43258: LIST
43259: LIST
43260: LIST
43261: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43262: LD_ADDR_VAR 0 64
43266: PUSH
43267: LD_INT 1
43269: NEG
43270: PUSH
43271: LD_INT 2
43273: NEG
43274: PUSH
43275: EMPTY
43276: LIST
43277: LIST
43278: PUSH
43279: LD_INT 2
43281: NEG
43282: PUSH
43283: LD_INT 1
43285: NEG
43286: PUSH
43287: EMPTY
43288: LIST
43289: LIST
43290: PUSH
43291: LD_INT 2
43293: NEG
43294: PUSH
43295: LD_INT 2
43297: NEG
43298: PUSH
43299: EMPTY
43300: LIST
43301: LIST
43302: PUSH
43303: EMPTY
43304: LIST
43305: LIST
43306: LIST
43307: ST_TO_ADDR
// end ; 2 :
43308: GO 46574
43310: LD_INT 2
43312: DOUBLE
43313: EQUAL
43314: IFTRUE 43318
43316: GO 46573
43318: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43319: LD_ADDR_VAR 0 29
43323: PUSH
43324: LD_INT 4
43326: PUSH
43327: LD_INT 0
43329: PUSH
43330: EMPTY
43331: LIST
43332: LIST
43333: PUSH
43334: LD_INT 4
43336: PUSH
43337: LD_INT 1
43339: NEG
43340: PUSH
43341: EMPTY
43342: LIST
43343: LIST
43344: PUSH
43345: LD_INT 5
43347: PUSH
43348: LD_INT 0
43350: PUSH
43351: EMPTY
43352: LIST
43353: LIST
43354: PUSH
43355: LD_INT 5
43357: PUSH
43358: LD_INT 1
43360: PUSH
43361: EMPTY
43362: LIST
43363: LIST
43364: PUSH
43365: LD_INT 4
43367: PUSH
43368: LD_INT 1
43370: PUSH
43371: EMPTY
43372: LIST
43373: LIST
43374: PUSH
43375: LD_INT 3
43377: PUSH
43378: LD_INT 0
43380: PUSH
43381: EMPTY
43382: LIST
43383: LIST
43384: PUSH
43385: LD_INT 3
43387: PUSH
43388: LD_INT 1
43390: NEG
43391: PUSH
43392: EMPTY
43393: LIST
43394: LIST
43395: PUSH
43396: LD_INT 3
43398: PUSH
43399: LD_INT 2
43401: NEG
43402: PUSH
43403: EMPTY
43404: LIST
43405: LIST
43406: PUSH
43407: LD_INT 5
43409: PUSH
43410: LD_INT 2
43412: PUSH
43413: EMPTY
43414: LIST
43415: LIST
43416: PUSH
43417: LD_INT 3
43419: PUSH
43420: LD_INT 3
43422: PUSH
43423: EMPTY
43424: LIST
43425: LIST
43426: PUSH
43427: LD_INT 3
43429: PUSH
43430: LD_INT 2
43432: PUSH
43433: EMPTY
43434: LIST
43435: LIST
43436: PUSH
43437: LD_INT 4
43439: PUSH
43440: LD_INT 3
43442: PUSH
43443: EMPTY
43444: LIST
43445: LIST
43446: PUSH
43447: LD_INT 4
43449: PUSH
43450: LD_INT 4
43452: PUSH
43453: EMPTY
43454: LIST
43455: LIST
43456: PUSH
43457: LD_INT 3
43459: PUSH
43460: LD_INT 4
43462: PUSH
43463: EMPTY
43464: LIST
43465: LIST
43466: PUSH
43467: LD_INT 2
43469: PUSH
43470: LD_INT 3
43472: PUSH
43473: EMPTY
43474: LIST
43475: LIST
43476: PUSH
43477: LD_INT 2
43479: PUSH
43480: LD_INT 2
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PUSH
43487: LD_INT 4
43489: PUSH
43490: LD_INT 2
43492: PUSH
43493: EMPTY
43494: LIST
43495: LIST
43496: PUSH
43497: LD_INT 2
43499: PUSH
43500: LD_INT 4
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: PUSH
43507: LD_INT 0
43509: PUSH
43510: LD_INT 4
43512: PUSH
43513: EMPTY
43514: LIST
43515: LIST
43516: PUSH
43517: LD_INT 0
43519: PUSH
43520: LD_INT 3
43522: PUSH
43523: EMPTY
43524: LIST
43525: LIST
43526: PUSH
43527: LD_INT 1
43529: PUSH
43530: LD_INT 4
43532: PUSH
43533: EMPTY
43534: LIST
43535: LIST
43536: PUSH
43537: LD_INT 1
43539: PUSH
43540: LD_INT 5
43542: PUSH
43543: EMPTY
43544: LIST
43545: LIST
43546: PUSH
43547: LD_INT 0
43549: PUSH
43550: LD_INT 5
43552: PUSH
43553: EMPTY
43554: LIST
43555: LIST
43556: PUSH
43557: LD_INT 1
43559: NEG
43560: PUSH
43561: LD_INT 4
43563: PUSH
43564: EMPTY
43565: LIST
43566: LIST
43567: PUSH
43568: LD_INT 1
43570: NEG
43571: PUSH
43572: LD_INT 3
43574: PUSH
43575: EMPTY
43576: LIST
43577: LIST
43578: PUSH
43579: LD_INT 2
43581: PUSH
43582: LD_INT 5
43584: PUSH
43585: EMPTY
43586: LIST
43587: LIST
43588: PUSH
43589: LD_INT 2
43591: NEG
43592: PUSH
43593: LD_INT 3
43595: PUSH
43596: EMPTY
43597: LIST
43598: LIST
43599: PUSH
43600: LD_INT 3
43602: NEG
43603: PUSH
43604: LD_INT 0
43606: PUSH
43607: EMPTY
43608: LIST
43609: LIST
43610: PUSH
43611: LD_INT 3
43613: NEG
43614: PUSH
43615: LD_INT 1
43617: NEG
43618: PUSH
43619: EMPTY
43620: LIST
43621: LIST
43622: PUSH
43623: LD_INT 2
43625: NEG
43626: PUSH
43627: LD_INT 0
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: LD_INT 2
43636: NEG
43637: PUSH
43638: LD_INT 1
43640: PUSH
43641: EMPTY
43642: LIST
43643: LIST
43644: PUSH
43645: LD_INT 3
43647: NEG
43648: PUSH
43649: LD_INT 1
43651: PUSH
43652: EMPTY
43653: LIST
43654: LIST
43655: PUSH
43656: LD_INT 4
43658: NEG
43659: PUSH
43660: LD_INT 0
43662: PUSH
43663: EMPTY
43664: LIST
43665: LIST
43666: PUSH
43667: LD_INT 4
43669: NEG
43670: PUSH
43671: LD_INT 1
43673: NEG
43674: PUSH
43675: EMPTY
43676: LIST
43677: LIST
43678: PUSH
43679: LD_INT 4
43681: NEG
43682: PUSH
43683: LD_INT 2
43685: NEG
43686: PUSH
43687: EMPTY
43688: LIST
43689: LIST
43690: PUSH
43691: LD_INT 2
43693: NEG
43694: PUSH
43695: LD_INT 2
43697: PUSH
43698: EMPTY
43699: LIST
43700: LIST
43701: PUSH
43702: LD_INT 4
43704: NEG
43705: PUSH
43706: LD_INT 4
43708: NEG
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: LD_INT 4
43716: NEG
43717: PUSH
43718: LD_INT 5
43720: NEG
43721: PUSH
43722: EMPTY
43723: LIST
43724: LIST
43725: PUSH
43726: LD_INT 3
43728: NEG
43729: PUSH
43730: LD_INT 4
43732: NEG
43733: PUSH
43734: EMPTY
43735: LIST
43736: LIST
43737: PUSH
43738: LD_INT 3
43740: NEG
43741: PUSH
43742: LD_INT 3
43744: NEG
43745: PUSH
43746: EMPTY
43747: LIST
43748: LIST
43749: PUSH
43750: LD_INT 4
43752: NEG
43753: PUSH
43754: LD_INT 3
43756: NEG
43757: PUSH
43758: EMPTY
43759: LIST
43760: LIST
43761: PUSH
43762: LD_INT 5
43764: NEG
43765: PUSH
43766: LD_INT 4
43768: NEG
43769: PUSH
43770: EMPTY
43771: LIST
43772: LIST
43773: PUSH
43774: LD_INT 5
43776: NEG
43777: PUSH
43778: LD_INT 5
43780: NEG
43781: PUSH
43782: EMPTY
43783: LIST
43784: LIST
43785: PUSH
43786: LD_INT 3
43788: NEG
43789: PUSH
43790: LD_INT 5
43792: NEG
43793: PUSH
43794: EMPTY
43795: LIST
43796: LIST
43797: PUSH
43798: LD_INT 5
43800: NEG
43801: PUSH
43802: LD_INT 3
43804: NEG
43805: PUSH
43806: EMPTY
43807: LIST
43808: LIST
43809: PUSH
43810: EMPTY
43811: LIST
43812: LIST
43813: LIST
43814: LIST
43815: LIST
43816: LIST
43817: LIST
43818: LIST
43819: LIST
43820: LIST
43821: LIST
43822: LIST
43823: LIST
43824: LIST
43825: LIST
43826: LIST
43827: LIST
43828: LIST
43829: LIST
43830: LIST
43831: LIST
43832: LIST
43833: LIST
43834: LIST
43835: LIST
43836: LIST
43837: LIST
43838: LIST
43839: LIST
43840: LIST
43841: LIST
43842: LIST
43843: LIST
43844: LIST
43845: LIST
43846: LIST
43847: LIST
43848: LIST
43849: LIST
43850: LIST
43851: LIST
43852: LIST
43853: LIST
43854: LIST
43855: LIST
43856: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43857: LD_ADDR_VAR 0 30
43861: PUSH
43862: LD_INT 4
43864: PUSH
43865: LD_INT 4
43867: PUSH
43868: EMPTY
43869: LIST
43870: LIST
43871: PUSH
43872: LD_INT 4
43874: PUSH
43875: LD_INT 3
43877: PUSH
43878: EMPTY
43879: LIST
43880: LIST
43881: PUSH
43882: LD_INT 5
43884: PUSH
43885: LD_INT 4
43887: PUSH
43888: EMPTY
43889: LIST
43890: LIST
43891: PUSH
43892: LD_INT 5
43894: PUSH
43895: LD_INT 5
43897: PUSH
43898: EMPTY
43899: LIST
43900: LIST
43901: PUSH
43902: LD_INT 4
43904: PUSH
43905: LD_INT 5
43907: PUSH
43908: EMPTY
43909: LIST
43910: LIST
43911: PUSH
43912: LD_INT 3
43914: PUSH
43915: LD_INT 4
43917: PUSH
43918: EMPTY
43919: LIST
43920: LIST
43921: PUSH
43922: LD_INT 3
43924: PUSH
43925: LD_INT 3
43927: PUSH
43928: EMPTY
43929: LIST
43930: LIST
43931: PUSH
43932: LD_INT 5
43934: PUSH
43935: LD_INT 3
43937: PUSH
43938: EMPTY
43939: LIST
43940: LIST
43941: PUSH
43942: LD_INT 3
43944: PUSH
43945: LD_INT 5
43947: PUSH
43948: EMPTY
43949: LIST
43950: LIST
43951: PUSH
43952: LD_INT 0
43954: PUSH
43955: LD_INT 3
43957: PUSH
43958: EMPTY
43959: LIST
43960: LIST
43961: PUSH
43962: LD_INT 0
43964: PUSH
43965: LD_INT 2
43967: PUSH
43968: EMPTY
43969: LIST
43970: LIST
43971: PUSH
43972: LD_INT 1
43974: PUSH
43975: LD_INT 3
43977: PUSH
43978: EMPTY
43979: LIST
43980: LIST
43981: PUSH
43982: LD_INT 1
43984: PUSH
43985: LD_INT 4
43987: PUSH
43988: EMPTY
43989: LIST
43990: LIST
43991: PUSH
43992: LD_INT 0
43994: PUSH
43995: LD_INT 4
43997: PUSH
43998: EMPTY
43999: LIST
44000: LIST
44001: PUSH
44002: LD_INT 1
44004: NEG
44005: PUSH
44006: LD_INT 3
44008: PUSH
44009: EMPTY
44010: LIST
44011: LIST
44012: PUSH
44013: LD_INT 1
44015: NEG
44016: PUSH
44017: LD_INT 2
44019: PUSH
44020: EMPTY
44021: LIST
44022: LIST
44023: PUSH
44024: LD_INT 2
44026: PUSH
44027: LD_INT 4
44029: PUSH
44030: EMPTY
44031: LIST
44032: LIST
44033: PUSH
44034: LD_INT 2
44036: NEG
44037: PUSH
44038: LD_INT 2
44040: PUSH
44041: EMPTY
44042: LIST
44043: LIST
44044: PUSH
44045: LD_INT 4
44047: NEG
44048: PUSH
44049: LD_INT 0
44051: PUSH
44052: EMPTY
44053: LIST
44054: LIST
44055: PUSH
44056: LD_INT 4
44058: NEG
44059: PUSH
44060: LD_INT 1
44062: NEG
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: PUSH
44068: LD_INT 3
44070: NEG
44071: PUSH
44072: LD_INT 0
44074: PUSH
44075: EMPTY
44076: LIST
44077: LIST
44078: PUSH
44079: LD_INT 3
44081: NEG
44082: PUSH
44083: LD_INT 1
44085: PUSH
44086: EMPTY
44087: LIST
44088: LIST
44089: PUSH
44090: LD_INT 4
44092: NEG
44093: PUSH
44094: LD_INT 1
44096: PUSH
44097: EMPTY
44098: LIST
44099: LIST
44100: PUSH
44101: LD_INT 5
44103: NEG
44104: PUSH
44105: LD_INT 0
44107: PUSH
44108: EMPTY
44109: LIST
44110: LIST
44111: PUSH
44112: LD_INT 5
44114: NEG
44115: PUSH
44116: LD_INT 1
44118: NEG
44119: PUSH
44120: EMPTY
44121: LIST
44122: LIST
44123: PUSH
44124: LD_INT 5
44126: NEG
44127: PUSH
44128: LD_INT 2
44130: NEG
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: PUSH
44136: LD_INT 3
44138: NEG
44139: PUSH
44140: LD_INT 2
44142: PUSH
44143: EMPTY
44144: LIST
44145: LIST
44146: PUSH
44147: LD_INT 3
44149: NEG
44150: PUSH
44151: LD_INT 3
44153: NEG
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PUSH
44159: LD_INT 3
44161: NEG
44162: PUSH
44163: LD_INT 4
44165: NEG
44166: PUSH
44167: EMPTY
44168: LIST
44169: LIST
44170: PUSH
44171: LD_INT 2
44173: NEG
44174: PUSH
44175: LD_INT 3
44177: NEG
44178: PUSH
44179: EMPTY
44180: LIST
44181: LIST
44182: PUSH
44183: LD_INT 2
44185: NEG
44186: PUSH
44187: LD_INT 2
44189: NEG
44190: PUSH
44191: EMPTY
44192: LIST
44193: LIST
44194: PUSH
44195: LD_INT 3
44197: NEG
44198: PUSH
44199: LD_INT 2
44201: NEG
44202: PUSH
44203: EMPTY
44204: LIST
44205: LIST
44206: PUSH
44207: LD_INT 4
44209: NEG
44210: PUSH
44211: LD_INT 3
44213: NEG
44214: PUSH
44215: EMPTY
44216: LIST
44217: LIST
44218: PUSH
44219: LD_INT 4
44221: NEG
44222: PUSH
44223: LD_INT 4
44225: NEG
44226: PUSH
44227: EMPTY
44228: LIST
44229: LIST
44230: PUSH
44231: LD_INT 2
44233: NEG
44234: PUSH
44235: LD_INT 4
44237: NEG
44238: PUSH
44239: EMPTY
44240: LIST
44241: LIST
44242: PUSH
44243: LD_INT 4
44245: NEG
44246: PUSH
44247: LD_INT 2
44249: NEG
44250: PUSH
44251: EMPTY
44252: LIST
44253: LIST
44254: PUSH
44255: LD_INT 0
44257: PUSH
44258: LD_INT 4
44260: NEG
44261: PUSH
44262: EMPTY
44263: LIST
44264: LIST
44265: PUSH
44266: LD_INT 0
44268: PUSH
44269: LD_INT 5
44271: NEG
44272: PUSH
44273: EMPTY
44274: LIST
44275: LIST
44276: PUSH
44277: LD_INT 1
44279: PUSH
44280: LD_INT 4
44282: NEG
44283: PUSH
44284: EMPTY
44285: LIST
44286: LIST
44287: PUSH
44288: LD_INT 1
44290: PUSH
44291: LD_INT 3
44293: NEG
44294: PUSH
44295: EMPTY
44296: LIST
44297: LIST
44298: PUSH
44299: LD_INT 0
44301: PUSH
44302: LD_INT 3
44304: NEG
44305: PUSH
44306: EMPTY
44307: LIST
44308: LIST
44309: PUSH
44310: LD_INT 1
44312: NEG
44313: PUSH
44314: LD_INT 4
44316: NEG
44317: PUSH
44318: EMPTY
44319: LIST
44320: LIST
44321: PUSH
44322: LD_INT 1
44324: NEG
44325: PUSH
44326: LD_INT 5
44328: NEG
44329: PUSH
44330: EMPTY
44331: LIST
44332: LIST
44333: PUSH
44334: LD_INT 2
44336: PUSH
44337: LD_INT 3
44339: NEG
44340: PUSH
44341: EMPTY
44342: LIST
44343: LIST
44344: PUSH
44345: LD_INT 2
44347: NEG
44348: PUSH
44349: LD_INT 5
44351: NEG
44352: PUSH
44353: EMPTY
44354: LIST
44355: LIST
44356: PUSH
44357: EMPTY
44358: LIST
44359: LIST
44360: LIST
44361: LIST
44362: LIST
44363: LIST
44364: LIST
44365: LIST
44366: LIST
44367: LIST
44368: LIST
44369: LIST
44370: LIST
44371: LIST
44372: LIST
44373: LIST
44374: LIST
44375: LIST
44376: LIST
44377: LIST
44378: LIST
44379: LIST
44380: LIST
44381: LIST
44382: LIST
44383: LIST
44384: LIST
44385: LIST
44386: LIST
44387: LIST
44388: LIST
44389: LIST
44390: LIST
44391: LIST
44392: LIST
44393: LIST
44394: LIST
44395: LIST
44396: LIST
44397: LIST
44398: LIST
44399: LIST
44400: LIST
44401: LIST
44402: LIST
44403: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44404: LD_ADDR_VAR 0 31
44408: PUSH
44409: LD_INT 0
44411: PUSH
44412: LD_INT 4
44414: PUSH
44415: EMPTY
44416: LIST
44417: LIST
44418: PUSH
44419: LD_INT 0
44421: PUSH
44422: LD_INT 3
44424: PUSH
44425: EMPTY
44426: LIST
44427: LIST
44428: PUSH
44429: LD_INT 1
44431: PUSH
44432: LD_INT 4
44434: PUSH
44435: EMPTY
44436: LIST
44437: LIST
44438: PUSH
44439: LD_INT 1
44441: PUSH
44442: LD_INT 5
44444: PUSH
44445: EMPTY
44446: LIST
44447: LIST
44448: PUSH
44449: LD_INT 0
44451: PUSH
44452: LD_INT 5
44454: PUSH
44455: EMPTY
44456: LIST
44457: LIST
44458: PUSH
44459: LD_INT 1
44461: NEG
44462: PUSH
44463: LD_INT 4
44465: PUSH
44466: EMPTY
44467: LIST
44468: LIST
44469: PUSH
44470: LD_INT 1
44472: NEG
44473: PUSH
44474: LD_INT 3
44476: PUSH
44477: EMPTY
44478: LIST
44479: LIST
44480: PUSH
44481: LD_INT 2
44483: PUSH
44484: LD_INT 5
44486: PUSH
44487: EMPTY
44488: LIST
44489: LIST
44490: PUSH
44491: LD_INT 2
44493: NEG
44494: PUSH
44495: LD_INT 3
44497: PUSH
44498: EMPTY
44499: LIST
44500: LIST
44501: PUSH
44502: LD_INT 3
44504: NEG
44505: PUSH
44506: LD_INT 0
44508: PUSH
44509: EMPTY
44510: LIST
44511: LIST
44512: PUSH
44513: LD_INT 3
44515: NEG
44516: PUSH
44517: LD_INT 1
44519: NEG
44520: PUSH
44521: EMPTY
44522: LIST
44523: LIST
44524: PUSH
44525: LD_INT 2
44527: NEG
44528: PUSH
44529: LD_INT 0
44531: PUSH
44532: EMPTY
44533: LIST
44534: LIST
44535: PUSH
44536: LD_INT 2
44538: NEG
44539: PUSH
44540: LD_INT 1
44542: PUSH
44543: EMPTY
44544: LIST
44545: LIST
44546: PUSH
44547: LD_INT 3
44549: NEG
44550: PUSH
44551: LD_INT 1
44553: PUSH
44554: EMPTY
44555: LIST
44556: LIST
44557: PUSH
44558: LD_INT 4
44560: NEG
44561: PUSH
44562: LD_INT 0
44564: PUSH
44565: EMPTY
44566: LIST
44567: LIST
44568: PUSH
44569: LD_INT 4
44571: NEG
44572: PUSH
44573: LD_INT 1
44575: NEG
44576: PUSH
44577: EMPTY
44578: LIST
44579: LIST
44580: PUSH
44581: LD_INT 4
44583: NEG
44584: PUSH
44585: LD_INT 2
44587: NEG
44588: PUSH
44589: EMPTY
44590: LIST
44591: LIST
44592: PUSH
44593: LD_INT 2
44595: NEG
44596: PUSH
44597: LD_INT 2
44599: PUSH
44600: EMPTY
44601: LIST
44602: LIST
44603: PUSH
44604: LD_INT 4
44606: NEG
44607: PUSH
44608: LD_INT 4
44610: NEG
44611: PUSH
44612: EMPTY
44613: LIST
44614: LIST
44615: PUSH
44616: LD_INT 4
44618: NEG
44619: PUSH
44620: LD_INT 5
44622: NEG
44623: PUSH
44624: EMPTY
44625: LIST
44626: LIST
44627: PUSH
44628: LD_INT 3
44630: NEG
44631: PUSH
44632: LD_INT 4
44634: NEG
44635: PUSH
44636: EMPTY
44637: LIST
44638: LIST
44639: PUSH
44640: LD_INT 3
44642: NEG
44643: PUSH
44644: LD_INT 3
44646: NEG
44647: PUSH
44648: EMPTY
44649: LIST
44650: LIST
44651: PUSH
44652: LD_INT 4
44654: NEG
44655: PUSH
44656: LD_INT 3
44658: NEG
44659: PUSH
44660: EMPTY
44661: LIST
44662: LIST
44663: PUSH
44664: LD_INT 5
44666: NEG
44667: PUSH
44668: LD_INT 4
44670: NEG
44671: PUSH
44672: EMPTY
44673: LIST
44674: LIST
44675: PUSH
44676: LD_INT 5
44678: NEG
44679: PUSH
44680: LD_INT 5
44682: NEG
44683: PUSH
44684: EMPTY
44685: LIST
44686: LIST
44687: PUSH
44688: LD_INT 3
44690: NEG
44691: PUSH
44692: LD_INT 5
44694: NEG
44695: PUSH
44696: EMPTY
44697: LIST
44698: LIST
44699: PUSH
44700: LD_INT 5
44702: NEG
44703: PUSH
44704: LD_INT 3
44706: NEG
44707: PUSH
44708: EMPTY
44709: LIST
44710: LIST
44711: PUSH
44712: LD_INT 0
44714: PUSH
44715: LD_INT 3
44717: NEG
44718: PUSH
44719: EMPTY
44720: LIST
44721: LIST
44722: PUSH
44723: LD_INT 0
44725: PUSH
44726: LD_INT 4
44728: NEG
44729: PUSH
44730: EMPTY
44731: LIST
44732: LIST
44733: PUSH
44734: LD_INT 1
44736: PUSH
44737: LD_INT 3
44739: NEG
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PUSH
44745: LD_INT 1
44747: PUSH
44748: LD_INT 2
44750: NEG
44751: PUSH
44752: EMPTY
44753: LIST
44754: LIST
44755: PUSH
44756: LD_INT 0
44758: PUSH
44759: LD_INT 2
44761: NEG
44762: PUSH
44763: EMPTY
44764: LIST
44765: LIST
44766: PUSH
44767: LD_INT 1
44769: NEG
44770: PUSH
44771: LD_INT 3
44773: NEG
44774: PUSH
44775: EMPTY
44776: LIST
44777: LIST
44778: PUSH
44779: LD_INT 1
44781: NEG
44782: PUSH
44783: LD_INT 4
44785: NEG
44786: PUSH
44787: EMPTY
44788: LIST
44789: LIST
44790: PUSH
44791: LD_INT 2
44793: PUSH
44794: LD_INT 2
44796: NEG
44797: PUSH
44798: EMPTY
44799: LIST
44800: LIST
44801: PUSH
44802: LD_INT 2
44804: NEG
44805: PUSH
44806: LD_INT 4
44808: NEG
44809: PUSH
44810: EMPTY
44811: LIST
44812: LIST
44813: PUSH
44814: LD_INT 4
44816: PUSH
44817: LD_INT 0
44819: PUSH
44820: EMPTY
44821: LIST
44822: LIST
44823: PUSH
44824: LD_INT 4
44826: PUSH
44827: LD_INT 1
44829: NEG
44830: PUSH
44831: EMPTY
44832: LIST
44833: LIST
44834: PUSH
44835: LD_INT 5
44837: PUSH
44838: LD_INT 0
44840: PUSH
44841: EMPTY
44842: LIST
44843: LIST
44844: PUSH
44845: LD_INT 5
44847: PUSH
44848: LD_INT 1
44850: PUSH
44851: EMPTY
44852: LIST
44853: LIST
44854: PUSH
44855: LD_INT 4
44857: PUSH
44858: LD_INT 1
44860: PUSH
44861: EMPTY
44862: LIST
44863: LIST
44864: PUSH
44865: LD_INT 3
44867: PUSH
44868: LD_INT 0
44870: PUSH
44871: EMPTY
44872: LIST
44873: LIST
44874: PUSH
44875: LD_INT 3
44877: PUSH
44878: LD_INT 1
44880: NEG
44881: PUSH
44882: EMPTY
44883: LIST
44884: LIST
44885: PUSH
44886: LD_INT 3
44888: PUSH
44889: LD_INT 2
44891: NEG
44892: PUSH
44893: EMPTY
44894: LIST
44895: LIST
44896: PUSH
44897: LD_INT 5
44899: PUSH
44900: LD_INT 2
44902: PUSH
44903: EMPTY
44904: LIST
44905: LIST
44906: PUSH
44907: EMPTY
44908: LIST
44909: LIST
44910: LIST
44911: LIST
44912: LIST
44913: LIST
44914: LIST
44915: LIST
44916: LIST
44917: LIST
44918: LIST
44919: LIST
44920: LIST
44921: LIST
44922: LIST
44923: LIST
44924: LIST
44925: LIST
44926: LIST
44927: LIST
44928: LIST
44929: LIST
44930: LIST
44931: LIST
44932: LIST
44933: LIST
44934: LIST
44935: LIST
44936: LIST
44937: LIST
44938: LIST
44939: LIST
44940: LIST
44941: LIST
44942: LIST
44943: LIST
44944: LIST
44945: LIST
44946: LIST
44947: LIST
44948: LIST
44949: LIST
44950: LIST
44951: LIST
44952: LIST
44953: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44954: LD_ADDR_VAR 0 32
44958: PUSH
44959: LD_INT 4
44961: NEG
44962: PUSH
44963: LD_INT 0
44965: PUSH
44966: EMPTY
44967: LIST
44968: LIST
44969: PUSH
44970: LD_INT 4
44972: NEG
44973: PUSH
44974: LD_INT 1
44976: NEG
44977: PUSH
44978: EMPTY
44979: LIST
44980: LIST
44981: PUSH
44982: LD_INT 3
44984: NEG
44985: PUSH
44986: LD_INT 0
44988: PUSH
44989: EMPTY
44990: LIST
44991: LIST
44992: PUSH
44993: LD_INT 3
44995: NEG
44996: PUSH
44997: LD_INT 1
44999: PUSH
45000: EMPTY
45001: LIST
45002: LIST
45003: PUSH
45004: LD_INT 4
45006: NEG
45007: PUSH
45008: LD_INT 1
45010: PUSH
45011: EMPTY
45012: LIST
45013: LIST
45014: PUSH
45015: LD_INT 5
45017: NEG
45018: PUSH
45019: LD_INT 0
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PUSH
45026: LD_INT 5
45028: NEG
45029: PUSH
45030: LD_INT 1
45032: NEG
45033: PUSH
45034: EMPTY
45035: LIST
45036: LIST
45037: PUSH
45038: LD_INT 5
45040: NEG
45041: PUSH
45042: LD_INT 2
45044: NEG
45045: PUSH
45046: EMPTY
45047: LIST
45048: LIST
45049: PUSH
45050: LD_INT 3
45052: NEG
45053: PUSH
45054: LD_INT 2
45056: PUSH
45057: EMPTY
45058: LIST
45059: LIST
45060: PUSH
45061: LD_INT 3
45063: NEG
45064: PUSH
45065: LD_INT 3
45067: NEG
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: PUSH
45073: LD_INT 3
45075: NEG
45076: PUSH
45077: LD_INT 4
45079: NEG
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: PUSH
45085: LD_INT 2
45087: NEG
45088: PUSH
45089: LD_INT 3
45091: NEG
45092: PUSH
45093: EMPTY
45094: LIST
45095: LIST
45096: PUSH
45097: LD_INT 2
45099: NEG
45100: PUSH
45101: LD_INT 2
45103: NEG
45104: PUSH
45105: EMPTY
45106: LIST
45107: LIST
45108: PUSH
45109: LD_INT 3
45111: NEG
45112: PUSH
45113: LD_INT 2
45115: NEG
45116: PUSH
45117: EMPTY
45118: LIST
45119: LIST
45120: PUSH
45121: LD_INT 4
45123: NEG
45124: PUSH
45125: LD_INT 3
45127: NEG
45128: PUSH
45129: EMPTY
45130: LIST
45131: LIST
45132: PUSH
45133: LD_INT 4
45135: NEG
45136: PUSH
45137: LD_INT 4
45139: NEG
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: LD_INT 2
45147: NEG
45148: PUSH
45149: LD_INT 4
45151: NEG
45152: PUSH
45153: EMPTY
45154: LIST
45155: LIST
45156: PUSH
45157: LD_INT 4
45159: NEG
45160: PUSH
45161: LD_INT 2
45163: NEG
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: PUSH
45169: LD_INT 0
45171: PUSH
45172: LD_INT 4
45174: NEG
45175: PUSH
45176: EMPTY
45177: LIST
45178: LIST
45179: PUSH
45180: LD_INT 0
45182: PUSH
45183: LD_INT 5
45185: NEG
45186: PUSH
45187: EMPTY
45188: LIST
45189: LIST
45190: PUSH
45191: LD_INT 1
45193: PUSH
45194: LD_INT 4
45196: NEG
45197: PUSH
45198: EMPTY
45199: LIST
45200: LIST
45201: PUSH
45202: LD_INT 1
45204: PUSH
45205: LD_INT 3
45207: NEG
45208: PUSH
45209: EMPTY
45210: LIST
45211: LIST
45212: PUSH
45213: LD_INT 0
45215: PUSH
45216: LD_INT 3
45218: NEG
45219: PUSH
45220: EMPTY
45221: LIST
45222: LIST
45223: PUSH
45224: LD_INT 1
45226: NEG
45227: PUSH
45228: LD_INT 4
45230: NEG
45231: PUSH
45232: EMPTY
45233: LIST
45234: LIST
45235: PUSH
45236: LD_INT 1
45238: NEG
45239: PUSH
45240: LD_INT 5
45242: NEG
45243: PUSH
45244: EMPTY
45245: LIST
45246: LIST
45247: PUSH
45248: LD_INT 2
45250: PUSH
45251: LD_INT 3
45253: NEG
45254: PUSH
45255: EMPTY
45256: LIST
45257: LIST
45258: PUSH
45259: LD_INT 2
45261: NEG
45262: PUSH
45263: LD_INT 5
45265: NEG
45266: PUSH
45267: EMPTY
45268: LIST
45269: LIST
45270: PUSH
45271: LD_INT 3
45273: PUSH
45274: LD_INT 0
45276: PUSH
45277: EMPTY
45278: LIST
45279: LIST
45280: PUSH
45281: LD_INT 3
45283: PUSH
45284: LD_INT 1
45286: NEG
45287: PUSH
45288: EMPTY
45289: LIST
45290: LIST
45291: PUSH
45292: LD_INT 4
45294: PUSH
45295: LD_INT 0
45297: PUSH
45298: EMPTY
45299: LIST
45300: LIST
45301: PUSH
45302: LD_INT 4
45304: PUSH
45305: LD_INT 1
45307: PUSH
45308: EMPTY
45309: LIST
45310: LIST
45311: PUSH
45312: LD_INT 3
45314: PUSH
45315: LD_INT 1
45317: PUSH
45318: EMPTY
45319: LIST
45320: LIST
45321: PUSH
45322: LD_INT 2
45324: PUSH
45325: LD_INT 0
45327: PUSH
45328: EMPTY
45329: LIST
45330: LIST
45331: PUSH
45332: LD_INT 2
45334: PUSH
45335: LD_INT 1
45337: NEG
45338: PUSH
45339: EMPTY
45340: LIST
45341: LIST
45342: PUSH
45343: LD_INT 2
45345: PUSH
45346: LD_INT 2
45348: NEG
45349: PUSH
45350: EMPTY
45351: LIST
45352: LIST
45353: PUSH
45354: LD_INT 4
45356: PUSH
45357: LD_INT 2
45359: PUSH
45360: EMPTY
45361: LIST
45362: LIST
45363: PUSH
45364: LD_INT 4
45366: PUSH
45367: LD_INT 4
45369: PUSH
45370: EMPTY
45371: LIST
45372: LIST
45373: PUSH
45374: LD_INT 4
45376: PUSH
45377: LD_INT 3
45379: PUSH
45380: EMPTY
45381: LIST
45382: LIST
45383: PUSH
45384: LD_INT 5
45386: PUSH
45387: LD_INT 4
45389: PUSH
45390: EMPTY
45391: LIST
45392: LIST
45393: PUSH
45394: LD_INT 5
45396: PUSH
45397: LD_INT 5
45399: PUSH
45400: EMPTY
45401: LIST
45402: LIST
45403: PUSH
45404: LD_INT 4
45406: PUSH
45407: LD_INT 5
45409: PUSH
45410: EMPTY
45411: LIST
45412: LIST
45413: PUSH
45414: LD_INT 3
45416: PUSH
45417: LD_INT 4
45419: PUSH
45420: EMPTY
45421: LIST
45422: LIST
45423: PUSH
45424: LD_INT 3
45426: PUSH
45427: LD_INT 3
45429: PUSH
45430: EMPTY
45431: LIST
45432: LIST
45433: PUSH
45434: LD_INT 5
45436: PUSH
45437: LD_INT 3
45439: PUSH
45440: EMPTY
45441: LIST
45442: LIST
45443: PUSH
45444: LD_INT 3
45446: PUSH
45447: LD_INT 5
45449: PUSH
45450: EMPTY
45451: LIST
45452: LIST
45453: PUSH
45454: EMPTY
45455: LIST
45456: LIST
45457: LIST
45458: LIST
45459: LIST
45460: LIST
45461: LIST
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: LIST
45467: LIST
45468: LIST
45469: LIST
45470: LIST
45471: LIST
45472: LIST
45473: LIST
45474: LIST
45475: LIST
45476: LIST
45477: LIST
45478: LIST
45479: LIST
45480: LIST
45481: LIST
45482: LIST
45483: LIST
45484: LIST
45485: LIST
45486: LIST
45487: LIST
45488: LIST
45489: LIST
45490: LIST
45491: LIST
45492: LIST
45493: LIST
45494: LIST
45495: LIST
45496: LIST
45497: LIST
45498: LIST
45499: LIST
45500: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45501: LD_ADDR_VAR 0 33
45505: PUSH
45506: LD_INT 4
45508: NEG
45509: PUSH
45510: LD_INT 4
45512: NEG
45513: PUSH
45514: EMPTY
45515: LIST
45516: LIST
45517: PUSH
45518: LD_INT 4
45520: NEG
45521: PUSH
45522: LD_INT 5
45524: NEG
45525: PUSH
45526: EMPTY
45527: LIST
45528: LIST
45529: PUSH
45530: LD_INT 3
45532: NEG
45533: PUSH
45534: LD_INT 4
45536: NEG
45537: PUSH
45538: EMPTY
45539: LIST
45540: LIST
45541: PUSH
45542: LD_INT 3
45544: NEG
45545: PUSH
45546: LD_INT 3
45548: NEG
45549: PUSH
45550: EMPTY
45551: LIST
45552: LIST
45553: PUSH
45554: LD_INT 4
45556: NEG
45557: PUSH
45558: LD_INT 3
45560: NEG
45561: PUSH
45562: EMPTY
45563: LIST
45564: LIST
45565: PUSH
45566: LD_INT 5
45568: NEG
45569: PUSH
45570: LD_INT 4
45572: NEG
45573: PUSH
45574: EMPTY
45575: LIST
45576: LIST
45577: PUSH
45578: LD_INT 5
45580: NEG
45581: PUSH
45582: LD_INT 5
45584: NEG
45585: PUSH
45586: EMPTY
45587: LIST
45588: LIST
45589: PUSH
45590: LD_INT 3
45592: NEG
45593: PUSH
45594: LD_INT 5
45596: NEG
45597: PUSH
45598: EMPTY
45599: LIST
45600: LIST
45601: PUSH
45602: LD_INT 5
45604: NEG
45605: PUSH
45606: LD_INT 3
45608: NEG
45609: PUSH
45610: EMPTY
45611: LIST
45612: LIST
45613: PUSH
45614: LD_INT 0
45616: PUSH
45617: LD_INT 3
45619: NEG
45620: PUSH
45621: EMPTY
45622: LIST
45623: LIST
45624: PUSH
45625: LD_INT 0
45627: PUSH
45628: LD_INT 4
45630: NEG
45631: PUSH
45632: EMPTY
45633: LIST
45634: LIST
45635: PUSH
45636: LD_INT 1
45638: PUSH
45639: LD_INT 3
45641: NEG
45642: PUSH
45643: EMPTY
45644: LIST
45645: LIST
45646: PUSH
45647: LD_INT 1
45649: PUSH
45650: LD_INT 2
45652: NEG
45653: PUSH
45654: EMPTY
45655: LIST
45656: LIST
45657: PUSH
45658: LD_INT 0
45660: PUSH
45661: LD_INT 2
45663: NEG
45664: PUSH
45665: EMPTY
45666: LIST
45667: LIST
45668: PUSH
45669: LD_INT 1
45671: NEG
45672: PUSH
45673: LD_INT 3
45675: NEG
45676: PUSH
45677: EMPTY
45678: LIST
45679: LIST
45680: PUSH
45681: LD_INT 1
45683: NEG
45684: PUSH
45685: LD_INT 4
45687: NEG
45688: PUSH
45689: EMPTY
45690: LIST
45691: LIST
45692: PUSH
45693: LD_INT 2
45695: PUSH
45696: LD_INT 2
45698: NEG
45699: PUSH
45700: EMPTY
45701: LIST
45702: LIST
45703: PUSH
45704: LD_INT 2
45706: NEG
45707: PUSH
45708: LD_INT 4
45710: NEG
45711: PUSH
45712: EMPTY
45713: LIST
45714: LIST
45715: PUSH
45716: LD_INT 4
45718: PUSH
45719: LD_INT 0
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 4
45728: PUSH
45729: LD_INT 1
45731: NEG
45732: PUSH
45733: EMPTY
45734: LIST
45735: LIST
45736: PUSH
45737: LD_INT 5
45739: PUSH
45740: LD_INT 0
45742: PUSH
45743: EMPTY
45744: LIST
45745: LIST
45746: PUSH
45747: LD_INT 5
45749: PUSH
45750: LD_INT 1
45752: PUSH
45753: EMPTY
45754: LIST
45755: LIST
45756: PUSH
45757: LD_INT 4
45759: PUSH
45760: LD_INT 1
45762: PUSH
45763: EMPTY
45764: LIST
45765: LIST
45766: PUSH
45767: LD_INT 3
45769: PUSH
45770: LD_INT 0
45772: PUSH
45773: EMPTY
45774: LIST
45775: LIST
45776: PUSH
45777: LD_INT 3
45779: PUSH
45780: LD_INT 1
45782: NEG
45783: PUSH
45784: EMPTY
45785: LIST
45786: LIST
45787: PUSH
45788: LD_INT 3
45790: PUSH
45791: LD_INT 2
45793: NEG
45794: PUSH
45795: EMPTY
45796: LIST
45797: LIST
45798: PUSH
45799: LD_INT 5
45801: PUSH
45802: LD_INT 2
45804: PUSH
45805: EMPTY
45806: LIST
45807: LIST
45808: PUSH
45809: LD_INT 3
45811: PUSH
45812: LD_INT 3
45814: PUSH
45815: EMPTY
45816: LIST
45817: LIST
45818: PUSH
45819: LD_INT 3
45821: PUSH
45822: LD_INT 2
45824: PUSH
45825: EMPTY
45826: LIST
45827: LIST
45828: PUSH
45829: LD_INT 4
45831: PUSH
45832: LD_INT 3
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: PUSH
45839: LD_INT 4
45841: PUSH
45842: LD_INT 4
45844: PUSH
45845: EMPTY
45846: LIST
45847: LIST
45848: PUSH
45849: LD_INT 3
45851: PUSH
45852: LD_INT 4
45854: PUSH
45855: EMPTY
45856: LIST
45857: LIST
45858: PUSH
45859: LD_INT 2
45861: PUSH
45862: LD_INT 3
45864: PUSH
45865: EMPTY
45866: LIST
45867: LIST
45868: PUSH
45869: LD_INT 2
45871: PUSH
45872: LD_INT 2
45874: PUSH
45875: EMPTY
45876: LIST
45877: LIST
45878: PUSH
45879: LD_INT 4
45881: PUSH
45882: LD_INT 2
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: PUSH
45889: LD_INT 2
45891: PUSH
45892: LD_INT 4
45894: PUSH
45895: EMPTY
45896: LIST
45897: LIST
45898: PUSH
45899: LD_INT 0
45901: PUSH
45902: LD_INT 4
45904: PUSH
45905: EMPTY
45906: LIST
45907: LIST
45908: PUSH
45909: LD_INT 0
45911: PUSH
45912: LD_INT 3
45914: PUSH
45915: EMPTY
45916: LIST
45917: LIST
45918: PUSH
45919: LD_INT 1
45921: PUSH
45922: LD_INT 4
45924: PUSH
45925: EMPTY
45926: LIST
45927: LIST
45928: PUSH
45929: LD_INT 1
45931: PUSH
45932: LD_INT 5
45934: PUSH
45935: EMPTY
45936: LIST
45937: LIST
45938: PUSH
45939: LD_INT 0
45941: PUSH
45942: LD_INT 5
45944: PUSH
45945: EMPTY
45946: LIST
45947: LIST
45948: PUSH
45949: LD_INT 1
45951: NEG
45952: PUSH
45953: LD_INT 4
45955: PUSH
45956: EMPTY
45957: LIST
45958: LIST
45959: PUSH
45960: LD_INT 1
45962: NEG
45963: PUSH
45964: LD_INT 3
45966: PUSH
45967: EMPTY
45968: LIST
45969: LIST
45970: PUSH
45971: LD_INT 2
45973: PUSH
45974: LD_INT 5
45976: PUSH
45977: EMPTY
45978: LIST
45979: LIST
45980: PUSH
45981: LD_INT 2
45983: NEG
45984: PUSH
45985: LD_INT 3
45987: PUSH
45988: EMPTY
45989: LIST
45990: LIST
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: LIST
46000: LIST
46001: LIST
46002: LIST
46003: LIST
46004: LIST
46005: LIST
46006: LIST
46007: LIST
46008: LIST
46009: LIST
46010: LIST
46011: LIST
46012: LIST
46013: LIST
46014: LIST
46015: LIST
46016: LIST
46017: LIST
46018: LIST
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: LIST
46030: LIST
46031: LIST
46032: LIST
46033: LIST
46034: LIST
46035: LIST
46036: LIST
46037: LIST
46038: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46039: LD_ADDR_VAR 0 34
46043: PUSH
46044: LD_INT 0
46046: PUSH
46047: LD_INT 4
46049: NEG
46050: PUSH
46051: EMPTY
46052: LIST
46053: LIST
46054: PUSH
46055: LD_INT 0
46057: PUSH
46058: LD_INT 5
46060: NEG
46061: PUSH
46062: EMPTY
46063: LIST
46064: LIST
46065: PUSH
46066: LD_INT 1
46068: PUSH
46069: LD_INT 4
46071: NEG
46072: PUSH
46073: EMPTY
46074: LIST
46075: LIST
46076: PUSH
46077: LD_INT 1
46079: PUSH
46080: LD_INT 3
46082: NEG
46083: PUSH
46084: EMPTY
46085: LIST
46086: LIST
46087: PUSH
46088: LD_INT 0
46090: PUSH
46091: LD_INT 3
46093: NEG
46094: PUSH
46095: EMPTY
46096: LIST
46097: LIST
46098: PUSH
46099: LD_INT 1
46101: NEG
46102: PUSH
46103: LD_INT 4
46105: NEG
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: PUSH
46111: LD_INT 1
46113: NEG
46114: PUSH
46115: LD_INT 5
46117: NEG
46118: PUSH
46119: EMPTY
46120: LIST
46121: LIST
46122: PUSH
46123: LD_INT 2
46125: PUSH
46126: LD_INT 3
46128: NEG
46129: PUSH
46130: EMPTY
46131: LIST
46132: LIST
46133: PUSH
46134: LD_INT 2
46136: NEG
46137: PUSH
46138: LD_INT 5
46140: NEG
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: PUSH
46146: LD_INT 3
46148: PUSH
46149: LD_INT 0
46151: PUSH
46152: EMPTY
46153: LIST
46154: LIST
46155: PUSH
46156: LD_INT 3
46158: PUSH
46159: LD_INT 1
46161: NEG
46162: PUSH
46163: EMPTY
46164: LIST
46165: LIST
46166: PUSH
46167: LD_INT 4
46169: PUSH
46170: LD_INT 0
46172: PUSH
46173: EMPTY
46174: LIST
46175: LIST
46176: PUSH
46177: LD_INT 4
46179: PUSH
46180: LD_INT 1
46182: PUSH
46183: EMPTY
46184: LIST
46185: LIST
46186: PUSH
46187: LD_INT 3
46189: PUSH
46190: LD_INT 1
46192: PUSH
46193: EMPTY
46194: LIST
46195: LIST
46196: PUSH
46197: LD_INT 2
46199: PUSH
46200: LD_INT 0
46202: PUSH
46203: EMPTY
46204: LIST
46205: LIST
46206: PUSH
46207: LD_INT 2
46209: PUSH
46210: LD_INT 1
46212: NEG
46213: PUSH
46214: EMPTY
46215: LIST
46216: LIST
46217: PUSH
46218: LD_INT 2
46220: PUSH
46221: LD_INT 2
46223: NEG
46224: PUSH
46225: EMPTY
46226: LIST
46227: LIST
46228: PUSH
46229: LD_INT 4
46231: PUSH
46232: LD_INT 2
46234: PUSH
46235: EMPTY
46236: LIST
46237: LIST
46238: PUSH
46239: LD_INT 4
46241: PUSH
46242: LD_INT 4
46244: PUSH
46245: EMPTY
46246: LIST
46247: LIST
46248: PUSH
46249: LD_INT 4
46251: PUSH
46252: LD_INT 3
46254: PUSH
46255: EMPTY
46256: LIST
46257: LIST
46258: PUSH
46259: LD_INT 5
46261: PUSH
46262: LD_INT 4
46264: PUSH
46265: EMPTY
46266: LIST
46267: LIST
46268: PUSH
46269: LD_INT 5
46271: PUSH
46272: LD_INT 5
46274: PUSH
46275: EMPTY
46276: LIST
46277: LIST
46278: PUSH
46279: LD_INT 4
46281: PUSH
46282: LD_INT 5
46284: PUSH
46285: EMPTY
46286: LIST
46287: LIST
46288: PUSH
46289: LD_INT 3
46291: PUSH
46292: LD_INT 4
46294: PUSH
46295: EMPTY
46296: LIST
46297: LIST
46298: PUSH
46299: LD_INT 3
46301: PUSH
46302: LD_INT 3
46304: PUSH
46305: EMPTY
46306: LIST
46307: LIST
46308: PUSH
46309: LD_INT 5
46311: PUSH
46312: LD_INT 3
46314: PUSH
46315: EMPTY
46316: LIST
46317: LIST
46318: PUSH
46319: LD_INT 3
46321: PUSH
46322: LD_INT 5
46324: PUSH
46325: EMPTY
46326: LIST
46327: LIST
46328: PUSH
46329: LD_INT 0
46331: PUSH
46332: LD_INT 3
46334: PUSH
46335: EMPTY
46336: LIST
46337: LIST
46338: PUSH
46339: LD_INT 0
46341: PUSH
46342: LD_INT 2
46344: PUSH
46345: EMPTY
46346: LIST
46347: LIST
46348: PUSH
46349: LD_INT 1
46351: PUSH
46352: LD_INT 3
46354: PUSH
46355: EMPTY
46356: LIST
46357: LIST
46358: PUSH
46359: LD_INT 1
46361: PUSH
46362: LD_INT 4
46364: PUSH
46365: EMPTY
46366: LIST
46367: LIST
46368: PUSH
46369: LD_INT 0
46371: PUSH
46372: LD_INT 4
46374: PUSH
46375: EMPTY
46376: LIST
46377: LIST
46378: PUSH
46379: LD_INT 1
46381: NEG
46382: PUSH
46383: LD_INT 3
46385: PUSH
46386: EMPTY
46387: LIST
46388: LIST
46389: PUSH
46390: LD_INT 1
46392: NEG
46393: PUSH
46394: LD_INT 2
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PUSH
46401: LD_INT 2
46403: PUSH
46404: LD_INT 4
46406: PUSH
46407: EMPTY
46408: LIST
46409: LIST
46410: PUSH
46411: LD_INT 2
46413: NEG
46414: PUSH
46415: LD_INT 2
46417: PUSH
46418: EMPTY
46419: LIST
46420: LIST
46421: PUSH
46422: LD_INT 4
46424: NEG
46425: PUSH
46426: LD_INT 0
46428: PUSH
46429: EMPTY
46430: LIST
46431: LIST
46432: PUSH
46433: LD_INT 4
46435: NEG
46436: PUSH
46437: LD_INT 1
46439: NEG
46440: PUSH
46441: EMPTY
46442: LIST
46443: LIST
46444: PUSH
46445: LD_INT 3
46447: NEG
46448: PUSH
46449: LD_INT 0
46451: PUSH
46452: EMPTY
46453: LIST
46454: LIST
46455: PUSH
46456: LD_INT 3
46458: NEG
46459: PUSH
46460: LD_INT 1
46462: PUSH
46463: EMPTY
46464: LIST
46465: LIST
46466: PUSH
46467: LD_INT 4
46469: NEG
46470: PUSH
46471: LD_INT 1
46473: PUSH
46474: EMPTY
46475: LIST
46476: LIST
46477: PUSH
46478: LD_INT 5
46480: NEG
46481: PUSH
46482: LD_INT 0
46484: PUSH
46485: EMPTY
46486: LIST
46487: LIST
46488: PUSH
46489: LD_INT 5
46491: NEG
46492: PUSH
46493: LD_INT 1
46495: NEG
46496: PUSH
46497: EMPTY
46498: LIST
46499: LIST
46500: PUSH
46501: LD_INT 5
46503: NEG
46504: PUSH
46505: LD_INT 2
46507: NEG
46508: PUSH
46509: EMPTY
46510: LIST
46511: LIST
46512: PUSH
46513: LD_INT 3
46515: NEG
46516: PUSH
46517: LD_INT 2
46519: PUSH
46520: EMPTY
46521: LIST
46522: LIST
46523: PUSH
46524: EMPTY
46525: LIST
46526: LIST
46527: LIST
46528: LIST
46529: LIST
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: LIST
46546: LIST
46547: LIST
46548: LIST
46549: LIST
46550: LIST
46551: LIST
46552: LIST
46553: LIST
46554: LIST
46555: LIST
46556: LIST
46557: LIST
46558: LIST
46559: LIST
46560: LIST
46561: LIST
46562: LIST
46563: LIST
46564: LIST
46565: LIST
46566: LIST
46567: LIST
46568: LIST
46569: LIST
46570: ST_TO_ADDR
// end ; end ;
46571: GO 46574
46573: POP
// case btype of b_depot , b_warehouse :
46574: LD_VAR 0 1
46578: PUSH
46579: LD_INT 0
46581: DOUBLE
46582: EQUAL
46583: IFTRUE 46593
46585: LD_INT 1
46587: DOUBLE
46588: EQUAL
46589: IFTRUE 46593
46591: GO 46794
46593: POP
// case nation of nation_american :
46594: LD_VAR 0 5
46598: PUSH
46599: LD_INT 1
46601: DOUBLE
46602: EQUAL
46603: IFTRUE 46607
46605: GO 46663
46607: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
46608: LD_ADDR_VAR 0 9
46612: PUSH
46613: LD_VAR 0 11
46617: PUSH
46618: LD_VAR 0 12
46622: PUSH
46623: LD_VAR 0 13
46627: PUSH
46628: LD_VAR 0 14
46632: PUSH
46633: LD_VAR 0 15
46637: PUSH
46638: LD_VAR 0 16
46642: PUSH
46643: EMPTY
46644: LIST
46645: LIST
46646: LIST
46647: LIST
46648: LIST
46649: LIST
46650: PUSH
46651: LD_VAR 0 4
46655: PUSH
46656: LD_INT 1
46658: PLUS
46659: ARRAY
46660: ST_TO_ADDR
46661: GO 46792
46663: LD_INT 2
46665: DOUBLE
46666: EQUAL
46667: IFTRUE 46671
46669: GO 46727
46671: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
46672: LD_ADDR_VAR 0 9
46676: PUSH
46677: LD_VAR 0 17
46681: PUSH
46682: LD_VAR 0 18
46686: PUSH
46687: LD_VAR 0 19
46691: PUSH
46692: LD_VAR 0 20
46696: PUSH
46697: LD_VAR 0 21
46701: PUSH
46702: LD_VAR 0 22
46706: PUSH
46707: EMPTY
46708: LIST
46709: LIST
46710: LIST
46711: LIST
46712: LIST
46713: LIST
46714: PUSH
46715: LD_VAR 0 4
46719: PUSH
46720: LD_INT 1
46722: PLUS
46723: ARRAY
46724: ST_TO_ADDR
46725: GO 46792
46727: LD_INT 3
46729: DOUBLE
46730: EQUAL
46731: IFTRUE 46735
46733: GO 46791
46735: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46736: LD_ADDR_VAR 0 9
46740: PUSH
46741: LD_VAR 0 23
46745: PUSH
46746: LD_VAR 0 24
46750: PUSH
46751: LD_VAR 0 25
46755: PUSH
46756: LD_VAR 0 26
46760: PUSH
46761: LD_VAR 0 27
46765: PUSH
46766: LD_VAR 0 28
46770: PUSH
46771: EMPTY
46772: LIST
46773: LIST
46774: LIST
46775: LIST
46776: LIST
46777: LIST
46778: PUSH
46779: LD_VAR 0 4
46783: PUSH
46784: LD_INT 1
46786: PLUS
46787: ARRAY
46788: ST_TO_ADDR
46789: GO 46792
46791: POP
46792: GO 47347
46794: LD_INT 2
46796: DOUBLE
46797: EQUAL
46798: IFTRUE 46808
46800: LD_INT 3
46802: DOUBLE
46803: EQUAL
46804: IFTRUE 46808
46806: GO 46864
46808: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46809: LD_ADDR_VAR 0 9
46813: PUSH
46814: LD_VAR 0 29
46818: PUSH
46819: LD_VAR 0 30
46823: PUSH
46824: LD_VAR 0 31
46828: PUSH
46829: LD_VAR 0 32
46833: PUSH
46834: LD_VAR 0 33
46838: PUSH
46839: LD_VAR 0 34
46843: PUSH
46844: EMPTY
46845: LIST
46846: LIST
46847: LIST
46848: LIST
46849: LIST
46850: LIST
46851: PUSH
46852: LD_VAR 0 4
46856: PUSH
46857: LD_INT 1
46859: PLUS
46860: ARRAY
46861: ST_TO_ADDR
46862: GO 47347
46864: LD_INT 16
46866: DOUBLE
46867: EQUAL
46868: IFTRUE 46926
46870: LD_INT 17
46872: DOUBLE
46873: EQUAL
46874: IFTRUE 46926
46876: LD_INT 18
46878: DOUBLE
46879: EQUAL
46880: IFTRUE 46926
46882: LD_INT 19
46884: DOUBLE
46885: EQUAL
46886: IFTRUE 46926
46888: LD_INT 22
46890: DOUBLE
46891: EQUAL
46892: IFTRUE 46926
46894: LD_INT 20
46896: DOUBLE
46897: EQUAL
46898: IFTRUE 46926
46900: LD_INT 21
46902: DOUBLE
46903: EQUAL
46904: IFTRUE 46926
46906: LD_INT 23
46908: DOUBLE
46909: EQUAL
46910: IFTRUE 46926
46912: LD_INT 24
46914: DOUBLE
46915: EQUAL
46916: IFTRUE 46926
46918: LD_INT 25
46920: DOUBLE
46921: EQUAL
46922: IFTRUE 46926
46924: GO 46982
46926: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46927: LD_ADDR_VAR 0 9
46931: PUSH
46932: LD_VAR 0 35
46936: PUSH
46937: LD_VAR 0 36
46941: PUSH
46942: LD_VAR 0 37
46946: PUSH
46947: LD_VAR 0 38
46951: PUSH
46952: LD_VAR 0 39
46956: PUSH
46957: LD_VAR 0 40
46961: PUSH
46962: EMPTY
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: PUSH
46970: LD_VAR 0 4
46974: PUSH
46975: LD_INT 1
46977: PLUS
46978: ARRAY
46979: ST_TO_ADDR
46980: GO 47347
46982: LD_INT 6
46984: DOUBLE
46985: EQUAL
46986: IFTRUE 47038
46988: LD_INT 7
46990: DOUBLE
46991: EQUAL
46992: IFTRUE 47038
46994: LD_INT 8
46996: DOUBLE
46997: EQUAL
46998: IFTRUE 47038
47000: LD_INT 13
47002: DOUBLE
47003: EQUAL
47004: IFTRUE 47038
47006: LD_INT 12
47008: DOUBLE
47009: EQUAL
47010: IFTRUE 47038
47012: LD_INT 15
47014: DOUBLE
47015: EQUAL
47016: IFTRUE 47038
47018: LD_INT 11
47020: DOUBLE
47021: EQUAL
47022: IFTRUE 47038
47024: LD_INT 14
47026: DOUBLE
47027: EQUAL
47028: IFTRUE 47038
47030: LD_INT 10
47032: DOUBLE
47033: EQUAL
47034: IFTRUE 47038
47036: GO 47094
47038: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
47039: LD_ADDR_VAR 0 9
47043: PUSH
47044: LD_VAR 0 41
47048: PUSH
47049: LD_VAR 0 42
47053: PUSH
47054: LD_VAR 0 43
47058: PUSH
47059: LD_VAR 0 44
47063: PUSH
47064: LD_VAR 0 45
47068: PUSH
47069: LD_VAR 0 46
47073: PUSH
47074: EMPTY
47075: LIST
47076: LIST
47077: LIST
47078: LIST
47079: LIST
47080: LIST
47081: PUSH
47082: LD_VAR 0 4
47086: PUSH
47087: LD_INT 1
47089: PLUS
47090: ARRAY
47091: ST_TO_ADDR
47092: GO 47347
47094: LD_INT 36
47096: DOUBLE
47097: EQUAL
47098: IFTRUE 47102
47100: GO 47158
47102: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47103: LD_ADDR_VAR 0 9
47107: PUSH
47108: LD_VAR 0 47
47112: PUSH
47113: LD_VAR 0 48
47117: PUSH
47118: LD_VAR 0 49
47122: PUSH
47123: LD_VAR 0 50
47127: PUSH
47128: LD_VAR 0 51
47132: PUSH
47133: LD_VAR 0 52
47137: PUSH
47138: EMPTY
47139: LIST
47140: LIST
47141: LIST
47142: LIST
47143: LIST
47144: LIST
47145: PUSH
47146: LD_VAR 0 4
47150: PUSH
47151: LD_INT 1
47153: PLUS
47154: ARRAY
47155: ST_TO_ADDR
47156: GO 47347
47158: LD_INT 4
47160: DOUBLE
47161: EQUAL
47162: IFTRUE 47184
47164: LD_INT 5
47166: DOUBLE
47167: EQUAL
47168: IFTRUE 47184
47170: LD_INT 34
47172: DOUBLE
47173: EQUAL
47174: IFTRUE 47184
47176: LD_INT 37
47178: DOUBLE
47179: EQUAL
47180: IFTRUE 47184
47182: GO 47240
47184: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47185: LD_ADDR_VAR 0 9
47189: PUSH
47190: LD_VAR 0 53
47194: PUSH
47195: LD_VAR 0 54
47199: PUSH
47200: LD_VAR 0 55
47204: PUSH
47205: LD_VAR 0 56
47209: PUSH
47210: LD_VAR 0 57
47214: PUSH
47215: LD_VAR 0 58
47219: PUSH
47220: EMPTY
47221: LIST
47222: LIST
47223: LIST
47224: LIST
47225: LIST
47226: LIST
47227: PUSH
47228: LD_VAR 0 4
47232: PUSH
47233: LD_INT 1
47235: PLUS
47236: ARRAY
47237: ST_TO_ADDR
47238: GO 47347
47240: LD_INT 31
47242: DOUBLE
47243: EQUAL
47244: IFTRUE 47290
47246: LD_INT 32
47248: DOUBLE
47249: EQUAL
47250: IFTRUE 47290
47252: LD_INT 33
47254: DOUBLE
47255: EQUAL
47256: IFTRUE 47290
47258: LD_INT 27
47260: DOUBLE
47261: EQUAL
47262: IFTRUE 47290
47264: LD_INT 26
47266: DOUBLE
47267: EQUAL
47268: IFTRUE 47290
47270: LD_INT 28
47272: DOUBLE
47273: EQUAL
47274: IFTRUE 47290
47276: LD_INT 29
47278: DOUBLE
47279: EQUAL
47280: IFTRUE 47290
47282: LD_INT 30
47284: DOUBLE
47285: EQUAL
47286: IFTRUE 47290
47288: GO 47346
47290: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
47291: LD_ADDR_VAR 0 9
47295: PUSH
47296: LD_VAR 0 59
47300: PUSH
47301: LD_VAR 0 60
47305: PUSH
47306: LD_VAR 0 61
47310: PUSH
47311: LD_VAR 0 62
47315: PUSH
47316: LD_VAR 0 63
47320: PUSH
47321: LD_VAR 0 64
47325: PUSH
47326: EMPTY
47327: LIST
47328: LIST
47329: LIST
47330: LIST
47331: LIST
47332: LIST
47333: PUSH
47334: LD_VAR 0 4
47338: PUSH
47339: LD_INT 1
47341: PLUS
47342: ARRAY
47343: ST_TO_ADDR
47344: GO 47347
47346: POP
// temp_list2 = [ ] ;
47347: LD_ADDR_VAR 0 10
47351: PUSH
47352: EMPTY
47353: ST_TO_ADDR
// for i in temp_list do
47354: LD_ADDR_VAR 0 8
47358: PUSH
47359: LD_VAR 0 9
47363: PUSH
47364: FOR_IN
47365: IFFALSE 47417
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47367: LD_ADDR_VAR 0 10
47371: PUSH
47372: LD_VAR 0 10
47376: PUSH
47377: LD_VAR 0 8
47381: PUSH
47382: LD_INT 1
47384: ARRAY
47385: PUSH
47386: LD_VAR 0 2
47390: PLUS
47391: PUSH
47392: LD_VAR 0 8
47396: PUSH
47397: LD_INT 2
47399: ARRAY
47400: PUSH
47401: LD_VAR 0 3
47405: PLUS
47406: PUSH
47407: EMPTY
47408: LIST
47409: LIST
47410: PUSH
47411: EMPTY
47412: LIST
47413: ADD
47414: ST_TO_ADDR
47415: GO 47364
47417: POP
47418: POP
// result = temp_list2 ;
47419: LD_ADDR_VAR 0 7
47423: PUSH
47424: LD_VAR 0 10
47428: ST_TO_ADDR
// end ;
47429: LD_VAR 0 7
47433: RET
// export function EnemyInRange ( unit , dist ) ; begin
47434: LD_INT 0
47436: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47437: LD_ADDR_VAR 0 3
47441: PUSH
47442: LD_VAR 0 1
47446: PPUSH
47447: CALL_OW 255
47451: PPUSH
47452: LD_VAR 0 1
47456: PPUSH
47457: CALL_OW 250
47461: PPUSH
47462: LD_VAR 0 1
47466: PPUSH
47467: CALL_OW 251
47471: PPUSH
47472: LD_VAR 0 2
47476: PPUSH
47477: CALL 21538 0 4
47481: PUSH
47482: LD_INT 4
47484: ARRAY
47485: ST_TO_ADDR
// end ;
47486: LD_VAR 0 3
47490: RET
// export function PlayerSeeMe ( unit ) ; begin
47491: LD_INT 0
47493: PPUSH
// result := See ( your_side , unit ) ;
47494: LD_ADDR_VAR 0 2
47498: PUSH
47499: LD_OWVAR 2
47503: PPUSH
47504: LD_VAR 0 1
47508: PPUSH
47509: CALL_OW 292
47513: ST_TO_ADDR
// end ;
47514: LD_VAR 0 2
47518: RET
// export function ReverseDir ( unit ) ; begin
47519: LD_INT 0
47521: PPUSH
// if not unit then
47522: LD_VAR 0 1
47526: NOT
47527: IFFALSE 47531
// exit ;
47529: GO 47577
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
47531: LD_ADDR_VAR 0 2
47535: PUSH
47536: LD_INT 3
47538: PUSH
47539: LD_INT 4
47541: PUSH
47542: LD_INT 5
47544: PUSH
47545: LD_INT 0
47547: PUSH
47548: LD_INT 1
47550: PUSH
47551: LD_INT 2
47553: PUSH
47554: EMPTY
47555: LIST
47556: LIST
47557: LIST
47558: LIST
47559: LIST
47560: LIST
47561: PUSH
47562: LD_VAR 0 1
47566: PPUSH
47567: CALL_OW 254
47571: PUSH
47572: LD_INT 1
47574: PLUS
47575: ARRAY
47576: ST_TO_ADDR
// end ;
47577: LD_VAR 0 2
47581: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47582: LD_INT 0
47584: PPUSH
47585: PPUSH
47586: PPUSH
47587: PPUSH
47588: PPUSH
// if not hexes then
47589: LD_VAR 0 2
47593: NOT
47594: IFFALSE 47598
// exit ;
47596: GO 47746
// dist := 9999 ;
47598: LD_ADDR_VAR 0 5
47602: PUSH
47603: LD_INT 9999
47605: ST_TO_ADDR
// for i = 1 to hexes do
47606: LD_ADDR_VAR 0 4
47610: PUSH
47611: DOUBLE
47612: LD_INT 1
47614: DEC
47615: ST_TO_ADDR
47616: LD_VAR 0 2
47620: PUSH
47621: FOR_TO
47622: IFFALSE 47734
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47624: LD_VAR 0 1
47628: PPUSH
47629: LD_VAR 0 2
47633: PUSH
47634: LD_VAR 0 4
47638: ARRAY
47639: PUSH
47640: LD_INT 1
47642: ARRAY
47643: PPUSH
47644: LD_VAR 0 2
47648: PUSH
47649: LD_VAR 0 4
47653: ARRAY
47654: PUSH
47655: LD_INT 2
47657: ARRAY
47658: PPUSH
47659: CALL_OW 297
47663: PUSH
47664: LD_VAR 0 5
47668: LESS
47669: IFFALSE 47732
// begin hex := hexes [ i ] ;
47671: LD_ADDR_VAR 0 7
47675: PUSH
47676: LD_VAR 0 2
47680: PUSH
47681: LD_VAR 0 4
47685: ARRAY
47686: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47687: LD_ADDR_VAR 0 5
47691: PUSH
47692: LD_VAR 0 1
47696: PPUSH
47697: LD_VAR 0 2
47701: PUSH
47702: LD_VAR 0 4
47706: ARRAY
47707: PUSH
47708: LD_INT 1
47710: ARRAY
47711: PPUSH
47712: LD_VAR 0 2
47716: PUSH
47717: LD_VAR 0 4
47721: ARRAY
47722: PUSH
47723: LD_INT 2
47725: ARRAY
47726: PPUSH
47727: CALL_OW 297
47731: ST_TO_ADDR
// end ; end ;
47732: GO 47621
47734: POP
47735: POP
// result := hex ;
47736: LD_ADDR_VAR 0 3
47740: PUSH
47741: LD_VAR 0 7
47745: ST_TO_ADDR
// end ;
47746: LD_VAR 0 3
47750: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47751: LD_INT 0
47753: PPUSH
47754: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47755: LD_VAR 0 1
47759: NOT
47760: PUSH
47761: LD_VAR 0 1
47765: PUSH
47766: LD_INT 21
47768: PUSH
47769: LD_INT 2
47771: PUSH
47772: EMPTY
47773: LIST
47774: LIST
47775: PUSH
47776: LD_INT 23
47778: PUSH
47779: LD_INT 2
47781: PUSH
47782: EMPTY
47783: LIST
47784: LIST
47785: PUSH
47786: EMPTY
47787: LIST
47788: LIST
47789: PPUSH
47790: CALL_OW 69
47794: IN
47795: NOT
47796: OR
47797: IFFALSE 47801
// exit ;
47799: GO 47848
// for i = 1 to 3 do
47801: LD_ADDR_VAR 0 3
47805: PUSH
47806: DOUBLE
47807: LD_INT 1
47809: DEC
47810: ST_TO_ADDR
47811: LD_INT 3
47813: PUSH
47814: FOR_TO
47815: IFFALSE 47846
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47817: LD_VAR 0 1
47821: PPUSH
47822: CALL_OW 250
47826: PPUSH
47827: LD_VAR 0 1
47831: PPUSH
47832: CALL_OW 251
47836: PPUSH
47837: LD_INT 1
47839: PPUSH
47840: CALL_OW 453
47844: GO 47814
47846: POP
47847: POP
// end ;
47848: LD_VAR 0 2
47852: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47853: LD_INT 0
47855: PPUSH
47856: PPUSH
47857: PPUSH
47858: PPUSH
47859: PPUSH
47860: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47861: LD_VAR 0 1
47865: NOT
47866: PUSH
47867: LD_VAR 0 2
47871: NOT
47872: OR
47873: PUSH
47874: LD_VAR 0 1
47878: PPUSH
47879: CALL_OW 314
47883: OR
47884: IFFALSE 47888
// exit ;
47886: GO 48329
// x := GetX ( enemy_unit ) ;
47888: LD_ADDR_VAR 0 7
47892: PUSH
47893: LD_VAR 0 2
47897: PPUSH
47898: CALL_OW 250
47902: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47903: LD_ADDR_VAR 0 8
47907: PUSH
47908: LD_VAR 0 2
47912: PPUSH
47913: CALL_OW 251
47917: ST_TO_ADDR
// if not x or not y then
47918: LD_VAR 0 7
47922: NOT
47923: PUSH
47924: LD_VAR 0 8
47928: NOT
47929: OR
47930: IFFALSE 47934
// exit ;
47932: GO 48329
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47934: LD_ADDR_VAR 0 6
47938: PUSH
47939: LD_VAR 0 7
47943: PPUSH
47944: LD_INT 0
47946: PPUSH
47947: LD_INT 4
47949: PPUSH
47950: CALL_OW 272
47954: PUSH
47955: LD_VAR 0 8
47959: PPUSH
47960: LD_INT 0
47962: PPUSH
47963: LD_INT 4
47965: PPUSH
47966: CALL_OW 273
47970: PUSH
47971: EMPTY
47972: LIST
47973: LIST
47974: PUSH
47975: LD_VAR 0 7
47979: PPUSH
47980: LD_INT 1
47982: PPUSH
47983: LD_INT 4
47985: PPUSH
47986: CALL_OW 272
47990: PUSH
47991: LD_VAR 0 8
47995: PPUSH
47996: LD_INT 1
47998: PPUSH
47999: LD_INT 4
48001: PPUSH
48002: CALL_OW 273
48006: PUSH
48007: EMPTY
48008: LIST
48009: LIST
48010: PUSH
48011: LD_VAR 0 7
48015: PPUSH
48016: LD_INT 2
48018: PPUSH
48019: LD_INT 4
48021: PPUSH
48022: CALL_OW 272
48026: PUSH
48027: LD_VAR 0 8
48031: PPUSH
48032: LD_INT 2
48034: PPUSH
48035: LD_INT 4
48037: PPUSH
48038: CALL_OW 273
48042: PUSH
48043: EMPTY
48044: LIST
48045: LIST
48046: PUSH
48047: LD_VAR 0 7
48051: PPUSH
48052: LD_INT 3
48054: PPUSH
48055: LD_INT 4
48057: PPUSH
48058: CALL_OW 272
48062: PUSH
48063: LD_VAR 0 8
48067: PPUSH
48068: LD_INT 3
48070: PPUSH
48071: LD_INT 4
48073: PPUSH
48074: CALL_OW 273
48078: PUSH
48079: EMPTY
48080: LIST
48081: LIST
48082: PUSH
48083: LD_VAR 0 7
48087: PPUSH
48088: LD_INT 4
48090: PPUSH
48091: LD_INT 4
48093: PPUSH
48094: CALL_OW 272
48098: PUSH
48099: LD_VAR 0 8
48103: PPUSH
48104: LD_INT 4
48106: PPUSH
48107: LD_INT 4
48109: PPUSH
48110: CALL_OW 273
48114: PUSH
48115: EMPTY
48116: LIST
48117: LIST
48118: PUSH
48119: LD_VAR 0 7
48123: PPUSH
48124: LD_INT 5
48126: PPUSH
48127: LD_INT 4
48129: PPUSH
48130: CALL_OW 272
48134: PUSH
48135: LD_VAR 0 8
48139: PPUSH
48140: LD_INT 5
48142: PPUSH
48143: LD_INT 4
48145: PPUSH
48146: CALL_OW 273
48150: PUSH
48151: EMPTY
48152: LIST
48153: LIST
48154: PUSH
48155: EMPTY
48156: LIST
48157: LIST
48158: LIST
48159: LIST
48160: LIST
48161: LIST
48162: ST_TO_ADDR
// for i = tmp downto 1 do
48163: LD_ADDR_VAR 0 4
48167: PUSH
48168: DOUBLE
48169: LD_VAR 0 6
48173: INC
48174: ST_TO_ADDR
48175: LD_INT 1
48177: PUSH
48178: FOR_DOWNTO
48179: IFFALSE 48280
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48181: LD_VAR 0 6
48185: PUSH
48186: LD_VAR 0 4
48190: ARRAY
48191: PUSH
48192: LD_INT 1
48194: ARRAY
48195: PPUSH
48196: LD_VAR 0 6
48200: PUSH
48201: LD_VAR 0 4
48205: ARRAY
48206: PUSH
48207: LD_INT 2
48209: ARRAY
48210: PPUSH
48211: CALL_OW 488
48215: NOT
48216: PUSH
48217: LD_VAR 0 6
48221: PUSH
48222: LD_VAR 0 4
48226: ARRAY
48227: PUSH
48228: LD_INT 1
48230: ARRAY
48231: PPUSH
48232: LD_VAR 0 6
48236: PUSH
48237: LD_VAR 0 4
48241: ARRAY
48242: PUSH
48243: LD_INT 2
48245: ARRAY
48246: PPUSH
48247: CALL_OW 428
48251: PUSH
48252: LD_INT 0
48254: NONEQUAL
48255: OR
48256: IFFALSE 48278
// tmp := Delete ( tmp , i ) ;
48258: LD_ADDR_VAR 0 6
48262: PUSH
48263: LD_VAR 0 6
48267: PPUSH
48268: LD_VAR 0 4
48272: PPUSH
48273: CALL_OW 3
48277: ST_TO_ADDR
48278: GO 48178
48280: POP
48281: POP
// j := GetClosestHex ( unit , tmp ) ;
48282: LD_ADDR_VAR 0 5
48286: PUSH
48287: LD_VAR 0 1
48291: PPUSH
48292: LD_VAR 0 6
48296: PPUSH
48297: CALL 47582 0 2
48301: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48302: LD_VAR 0 1
48306: PPUSH
48307: LD_VAR 0 5
48311: PUSH
48312: LD_INT 1
48314: ARRAY
48315: PPUSH
48316: LD_VAR 0 5
48320: PUSH
48321: LD_INT 2
48323: ARRAY
48324: PPUSH
48325: CALL_OW 111
// end ;
48329: LD_VAR 0 3
48333: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48334: LD_INT 0
48336: PPUSH
48337: PPUSH
48338: PPUSH
// uc_side = 0 ;
48339: LD_ADDR_OWVAR 20
48343: PUSH
48344: LD_INT 0
48346: ST_TO_ADDR
// uc_nation = 0 ;
48347: LD_ADDR_OWVAR 21
48351: PUSH
48352: LD_INT 0
48354: ST_TO_ADDR
// InitHc ;
48355: CALL_OW 19
// InitVc ;
48359: CALL_OW 20
// if mastodonts then
48363: LD_VAR 0 6
48367: IFFALSE 48434
// for i = 1 to mastodonts do
48369: LD_ADDR_VAR 0 11
48373: PUSH
48374: DOUBLE
48375: LD_INT 1
48377: DEC
48378: ST_TO_ADDR
48379: LD_VAR 0 6
48383: PUSH
48384: FOR_TO
48385: IFFALSE 48432
// begin vc_chassis := 31 ;
48387: LD_ADDR_OWVAR 37
48391: PUSH
48392: LD_INT 31
48394: ST_TO_ADDR
// vc_control := control_rider ;
48395: LD_ADDR_OWVAR 38
48399: PUSH
48400: LD_INT 4
48402: ST_TO_ADDR
// animal := CreateVehicle ;
48403: LD_ADDR_VAR 0 12
48407: PUSH
48408: CALL_OW 45
48412: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48413: LD_VAR 0 12
48417: PPUSH
48418: LD_VAR 0 8
48422: PPUSH
48423: LD_INT 0
48425: PPUSH
48426: CALL 55179 0 3
// end ;
48430: GO 48384
48432: POP
48433: POP
// if horses then
48434: LD_VAR 0 5
48438: IFFALSE 48505
// for i = 1 to horses do
48440: LD_ADDR_VAR 0 11
48444: PUSH
48445: DOUBLE
48446: LD_INT 1
48448: DEC
48449: ST_TO_ADDR
48450: LD_VAR 0 5
48454: PUSH
48455: FOR_TO
48456: IFFALSE 48503
// begin hc_class := 21 ;
48458: LD_ADDR_OWVAR 28
48462: PUSH
48463: LD_INT 21
48465: ST_TO_ADDR
// hc_gallery :=  ;
48466: LD_ADDR_OWVAR 33
48470: PUSH
48471: LD_STRING 
48473: ST_TO_ADDR
// animal := CreateHuman ;
48474: LD_ADDR_VAR 0 12
48478: PUSH
48479: CALL_OW 44
48483: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48484: LD_VAR 0 12
48488: PPUSH
48489: LD_VAR 0 8
48493: PPUSH
48494: LD_INT 0
48496: PPUSH
48497: CALL 55179 0 3
// end ;
48501: GO 48455
48503: POP
48504: POP
// if birds then
48505: LD_VAR 0 1
48509: IFFALSE 48576
// for i = 1 to birds do
48511: LD_ADDR_VAR 0 11
48515: PUSH
48516: DOUBLE
48517: LD_INT 1
48519: DEC
48520: ST_TO_ADDR
48521: LD_VAR 0 1
48525: PUSH
48526: FOR_TO
48527: IFFALSE 48574
// begin hc_class = 18 ;
48529: LD_ADDR_OWVAR 28
48533: PUSH
48534: LD_INT 18
48536: ST_TO_ADDR
// hc_gallery =  ;
48537: LD_ADDR_OWVAR 33
48541: PUSH
48542: LD_STRING 
48544: ST_TO_ADDR
// animal := CreateHuman ;
48545: LD_ADDR_VAR 0 12
48549: PUSH
48550: CALL_OW 44
48554: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48555: LD_VAR 0 12
48559: PPUSH
48560: LD_VAR 0 8
48564: PPUSH
48565: LD_INT 0
48567: PPUSH
48568: CALL 55179 0 3
// end ;
48572: GO 48526
48574: POP
48575: POP
// if tigers then
48576: LD_VAR 0 2
48580: IFFALSE 48664
// for i = 1 to tigers do
48582: LD_ADDR_VAR 0 11
48586: PUSH
48587: DOUBLE
48588: LD_INT 1
48590: DEC
48591: ST_TO_ADDR
48592: LD_VAR 0 2
48596: PUSH
48597: FOR_TO
48598: IFFALSE 48662
// begin hc_class = class_tiger ;
48600: LD_ADDR_OWVAR 28
48604: PUSH
48605: LD_INT 14
48607: ST_TO_ADDR
// hc_gallery =  ;
48608: LD_ADDR_OWVAR 33
48612: PUSH
48613: LD_STRING 
48615: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48616: LD_ADDR_OWVAR 35
48620: PUSH
48621: LD_INT 7
48623: NEG
48624: PPUSH
48625: LD_INT 7
48627: PPUSH
48628: CALL_OW 12
48632: ST_TO_ADDR
// animal := CreateHuman ;
48633: LD_ADDR_VAR 0 12
48637: PUSH
48638: CALL_OW 44
48642: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48643: LD_VAR 0 12
48647: PPUSH
48648: LD_VAR 0 8
48652: PPUSH
48653: LD_INT 0
48655: PPUSH
48656: CALL 55179 0 3
// end ;
48660: GO 48597
48662: POP
48663: POP
// if apemans then
48664: LD_VAR 0 3
48668: IFFALSE 48791
// for i = 1 to apemans do
48670: LD_ADDR_VAR 0 11
48674: PUSH
48675: DOUBLE
48676: LD_INT 1
48678: DEC
48679: ST_TO_ADDR
48680: LD_VAR 0 3
48684: PUSH
48685: FOR_TO
48686: IFFALSE 48789
// begin hc_class = class_apeman ;
48688: LD_ADDR_OWVAR 28
48692: PUSH
48693: LD_INT 12
48695: ST_TO_ADDR
// hc_gallery =  ;
48696: LD_ADDR_OWVAR 33
48700: PUSH
48701: LD_STRING 
48703: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
48704: LD_ADDR_OWVAR 35
48708: PUSH
48709: LD_INT 5
48711: NEG
48712: PPUSH
48713: LD_INT 5
48715: PPUSH
48716: CALL_OW 12
48720: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48721: LD_ADDR_OWVAR 31
48725: PUSH
48726: LD_INT 1
48728: PPUSH
48729: LD_INT 3
48731: PPUSH
48732: CALL_OW 12
48736: PUSH
48737: LD_INT 1
48739: PPUSH
48740: LD_INT 3
48742: PPUSH
48743: CALL_OW 12
48747: PUSH
48748: LD_INT 0
48750: PUSH
48751: LD_INT 0
48753: PUSH
48754: EMPTY
48755: LIST
48756: LIST
48757: LIST
48758: LIST
48759: ST_TO_ADDR
// animal := CreateHuman ;
48760: LD_ADDR_VAR 0 12
48764: PUSH
48765: CALL_OW 44
48769: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48770: LD_VAR 0 12
48774: PPUSH
48775: LD_VAR 0 8
48779: PPUSH
48780: LD_INT 0
48782: PPUSH
48783: CALL 55179 0 3
// end ;
48787: GO 48685
48789: POP
48790: POP
// if enchidnas then
48791: LD_VAR 0 4
48795: IFFALSE 48862
// for i = 1 to enchidnas do
48797: LD_ADDR_VAR 0 11
48801: PUSH
48802: DOUBLE
48803: LD_INT 1
48805: DEC
48806: ST_TO_ADDR
48807: LD_VAR 0 4
48811: PUSH
48812: FOR_TO
48813: IFFALSE 48860
// begin hc_class = 13 ;
48815: LD_ADDR_OWVAR 28
48819: PUSH
48820: LD_INT 13
48822: ST_TO_ADDR
// hc_gallery =  ;
48823: LD_ADDR_OWVAR 33
48827: PUSH
48828: LD_STRING 
48830: ST_TO_ADDR
// animal := CreateHuman ;
48831: LD_ADDR_VAR 0 12
48835: PUSH
48836: CALL_OW 44
48840: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48841: LD_VAR 0 12
48845: PPUSH
48846: LD_VAR 0 8
48850: PPUSH
48851: LD_INT 0
48853: PPUSH
48854: CALL 55179 0 3
// end ;
48858: GO 48812
48860: POP
48861: POP
// if fishes then
48862: LD_VAR 0 7
48866: IFFALSE 48933
// for i = 1 to fishes do
48868: LD_ADDR_VAR 0 11
48872: PUSH
48873: DOUBLE
48874: LD_INT 1
48876: DEC
48877: ST_TO_ADDR
48878: LD_VAR 0 7
48882: PUSH
48883: FOR_TO
48884: IFFALSE 48931
// begin hc_class = 20 ;
48886: LD_ADDR_OWVAR 28
48890: PUSH
48891: LD_INT 20
48893: ST_TO_ADDR
// hc_gallery =  ;
48894: LD_ADDR_OWVAR 33
48898: PUSH
48899: LD_STRING 
48901: ST_TO_ADDR
// animal := CreateHuman ;
48902: LD_ADDR_VAR 0 12
48906: PUSH
48907: CALL_OW 44
48911: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48912: LD_VAR 0 12
48916: PPUSH
48917: LD_VAR 0 9
48921: PPUSH
48922: LD_INT 0
48924: PPUSH
48925: CALL 55179 0 3
// end ;
48929: GO 48883
48931: POP
48932: POP
// end ;
48933: LD_VAR 0 10
48937: RET
// export function WantHeal ( sci , unit ) ; begin
48938: LD_INT 0
48940: PPUSH
// if GetTaskList ( sci ) > 0 then
48941: LD_VAR 0 1
48945: PPUSH
48946: CALL_OW 437
48950: PUSH
48951: LD_INT 0
48953: GREATER
48954: IFFALSE 49024
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48956: LD_VAR 0 1
48960: PPUSH
48961: CALL_OW 437
48965: PUSH
48966: LD_INT 1
48968: ARRAY
48969: PUSH
48970: LD_INT 1
48972: ARRAY
48973: PUSH
48974: LD_STRING l
48976: EQUAL
48977: PUSH
48978: LD_VAR 0 1
48982: PPUSH
48983: CALL_OW 437
48987: PUSH
48988: LD_INT 1
48990: ARRAY
48991: PUSH
48992: LD_INT 4
48994: ARRAY
48995: PUSH
48996: LD_VAR 0 2
49000: EQUAL
49001: AND
49002: IFFALSE 49014
// result := true else
49004: LD_ADDR_VAR 0 3
49008: PUSH
49009: LD_INT 1
49011: ST_TO_ADDR
49012: GO 49022
// result := false ;
49014: LD_ADDR_VAR 0 3
49018: PUSH
49019: LD_INT 0
49021: ST_TO_ADDR
// end else
49022: GO 49032
// result := false ;
49024: LD_ADDR_VAR 0 3
49028: PUSH
49029: LD_INT 0
49031: ST_TO_ADDR
// end ;
49032: LD_VAR 0 3
49036: RET
// export function HealTarget ( sci ) ; begin
49037: LD_INT 0
49039: PPUSH
// if not sci then
49040: LD_VAR 0 1
49044: NOT
49045: IFFALSE 49049
// exit ;
49047: GO 49114
// result := 0 ;
49049: LD_ADDR_VAR 0 2
49053: PUSH
49054: LD_INT 0
49056: ST_TO_ADDR
// if GetTaskList ( sci ) then
49057: LD_VAR 0 1
49061: PPUSH
49062: CALL_OW 437
49066: IFFALSE 49114
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49068: LD_VAR 0 1
49072: PPUSH
49073: CALL_OW 437
49077: PUSH
49078: LD_INT 1
49080: ARRAY
49081: PUSH
49082: LD_INT 1
49084: ARRAY
49085: PUSH
49086: LD_STRING l
49088: EQUAL
49089: IFFALSE 49114
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49091: LD_ADDR_VAR 0 2
49095: PUSH
49096: LD_VAR 0 1
49100: PPUSH
49101: CALL_OW 437
49105: PUSH
49106: LD_INT 1
49108: ARRAY
49109: PUSH
49110: LD_INT 4
49112: ARRAY
49113: ST_TO_ADDR
// end ;
49114: LD_VAR 0 2
49118: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
49119: LD_INT 0
49121: PPUSH
49122: PPUSH
49123: PPUSH
49124: PPUSH
49125: PPUSH
49126: PPUSH
49127: PPUSH
49128: PPUSH
49129: PPUSH
49130: PPUSH
49131: PPUSH
49132: PPUSH
49133: PPUSH
49134: PPUSH
49135: PPUSH
49136: PPUSH
49137: PPUSH
49138: PPUSH
49139: PPUSH
49140: PPUSH
49141: PPUSH
49142: PPUSH
49143: PPUSH
49144: PPUSH
49145: PPUSH
49146: PPUSH
49147: PPUSH
49148: PPUSH
49149: PPUSH
49150: PPUSH
49151: PPUSH
49152: PPUSH
49153: PPUSH
49154: PPUSH
// if not list then
49155: LD_VAR 0 1
49159: NOT
49160: IFFALSE 49164
// exit ;
49162: GO 53790
// base := list [ 1 ] ;
49164: LD_ADDR_VAR 0 3
49168: PUSH
49169: LD_VAR 0 1
49173: PUSH
49174: LD_INT 1
49176: ARRAY
49177: ST_TO_ADDR
// group := list [ 2 ] ;
49178: LD_ADDR_VAR 0 4
49182: PUSH
49183: LD_VAR 0 1
49187: PUSH
49188: LD_INT 2
49190: ARRAY
49191: ST_TO_ADDR
// path := list [ 3 ] ;
49192: LD_ADDR_VAR 0 5
49196: PUSH
49197: LD_VAR 0 1
49201: PUSH
49202: LD_INT 3
49204: ARRAY
49205: ST_TO_ADDR
// flags := list [ 4 ] ;
49206: LD_ADDR_VAR 0 6
49210: PUSH
49211: LD_VAR 0 1
49215: PUSH
49216: LD_INT 4
49218: ARRAY
49219: ST_TO_ADDR
// mined := [ ] ;
49220: LD_ADDR_VAR 0 27
49224: PUSH
49225: EMPTY
49226: ST_TO_ADDR
// bombed := [ ] ;
49227: LD_ADDR_VAR 0 28
49231: PUSH
49232: EMPTY
49233: ST_TO_ADDR
// healers := [ ] ;
49234: LD_ADDR_VAR 0 31
49238: PUSH
49239: EMPTY
49240: ST_TO_ADDR
// to_heal := [ ] ;
49241: LD_ADDR_VAR 0 30
49245: PUSH
49246: EMPTY
49247: ST_TO_ADDR
// repairs := [ ] ;
49248: LD_ADDR_VAR 0 33
49252: PUSH
49253: EMPTY
49254: ST_TO_ADDR
// to_repair := [ ] ;
49255: LD_ADDR_VAR 0 32
49259: PUSH
49260: EMPTY
49261: ST_TO_ADDR
// if not group or not path then
49262: LD_VAR 0 4
49266: NOT
49267: PUSH
49268: LD_VAR 0 5
49272: NOT
49273: OR
49274: IFFALSE 49278
// exit ;
49276: GO 53790
// side := GetSide ( group [ 1 ] ) ;
49278: LD_ADDR_VAR 0 35
49282: PUSH
49283: LD_VAR 0 4
49287: PUSH
49288: LD_INT 1
49290: ARRAY
49291: PPUSH
49292: CALL_OW 255
49296: ST_TO_ADDR
// if flags then
49297: LD_VAR 0 6
49301: IFFALSE 49445
// begin f_ignore_area := flags [ 1 ] ;
49303: LD_ADDR_VAR 0 17
49307: PUSH
49308: LD_VAR 0 6
49312: PUSH
49313: LD_INT 1
49315: ARRAY
49316: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
49317: LD_ADDR_VAR 0 18
49321: PUSH
49322: LD_VAR 0 6
49326: PUSH
49327: LD_INT 2
49329: ARRAY
49330: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
49331: LD_ADDR_VAR 0 19
49335: PUSH
49336: LD_VAR 0 6
49340: PUSH
49341: LD_INT 3
49343: ARRAY
49344: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
49345: LD_ADDR_VAR 0 20
49349: PUSH
49350: LD_VAR 0 6
49354: PUSH
49355: LD_INT 4
49357: ARRAY
49358: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
49359: LD_ADDR_VAR 0 21
49363: PUSH
49364: LD_VAR 0 6
49368: PUSH
49369: LD_INT 5
49371: ARRAY
49372: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
49373: LD_ADDR_VAR 0 22
49377: PUSH
49378: LD_VAR 0 6
49382: PUSH
49383: LD_INT 6
49385: ARRAY
49386: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
49387: LD_ADDR_VAR 0 23
49391: PUSH
49392: LD_VAR 0 6
49396: PUSH
49397: LD_INT 7
49399: ARRAY
49400: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
49401: LD_ADDR_VAR 0 24
49405: PUSH
49406: LD_VAR 0 6
49410: PUSH
49411: LD_INT 8
49413: ARRAY
49414: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
49415: LD_ADDR_VAR 0 25
49419: PUSH
49420: LD_VAR 0 6
49424: PUSH
49425: LD_INT 9
49427: ARRAY
49428: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
49429: LD_ADDR_VAR 0 26
49433: PUSH
49434: LD_VAR 0 6
49438: PUSH
49439: LD_INT 10
49441: ARRAY
49442: ST_TO_ADDR
// end else
49443: GO 49525
// begin f_ignore_area := false ;
49445: LD_ADDR_VAR 0 17
49449: PUSH
49450: LD_INT 0
49452: ST_TO_ADDR
// f_capture := false ;
49453: LD_ADDR_VAR 0 18
49457: PUSH
49458: LD_INT 0
49460: ST_TO_ADDR
// f_ignore_civ := false ;
49461: LD_ADDR_VAR 0 19
49465: PUSH
49466: LD_INT 0
49468: ST_TO_ADDR
// f_murder := false ;
49469: LD_ADDR_VAR 0 20
49473: PUSH
49474: LD_INT 0
49476: ST_TO_ADDR
// f_mines := false ;
49477: LD_ADDR_VAR 0 21
49481: PUSH
49482: LD_INT 0
49484: ST_TO_ADDR
// f_repair := false ;
49485: LD_ADDR_VAR 0 22
49489: PUSH
49490: LD_INT 0
49492: ST_TO_ADDR
// f_heal := false ;
49493: LD_ADDR_VAR 0 23
49497: PUSH
49498: LD_INT 0
49500: ST_TO_ADDR
// f_spacetime := false ;
49501: LD_ADDR_VAR 0 24
49505: PUSH
49506: LD_INT 0
49508: ST_TO_ADDR
// f_attack_depot := false ;
49509: LD_ADDR_VAR 0 25
49513: PUSH
49514: LD_INT 0
49516: ST_TO_ADDR
// f_crawl := false ;
49517: LD_ADDR_VAR 0 26
49521: PUSH
49522: LD_INT 0
49524: ST_TO_ADDR
// end ; if f_heal then
49525: LD_VAR 0 23
49529: IFFALSE 49556
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
49531: LD_ADDR_VAR 0 31
49535: PUSH
49536: LD_VAR 0 4
49540: PPUSH
49541: LD_INT 25
49543: PUSH
49544: LD_INT 4
49546: PUSH
49547: EMPTY
49548: LIST
49549: LIST
49550: PPUSH
49551: CALL_OW 72
49555: ST_TO_ADDR
// if f_repair then
49556: LD_VAR 0 22
49560: IFFALSE 49587
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
49562: LD_ADDR_VAR 0 33
49566: PUSH
49567: LD_VAR 0 4
49571: PPUSH
49572: LD_INT 25
49574: PUSH
49575: LD_INT 3
49577: PUSH
49578: EMPTY
49579: LIST
49580: LIST
49581: PPUSH
49582: CALL_OW 72
49586: ST_TO_ADDR
// units_path := [ ] ;
49587: LD_ADDR_VAR 0 16
49591: PUSH
49592: EMPTY
49593: ST_TO_ADDR
// for i = 1 to group do
49594: LD_ADDR_VAR 0 7
49598: PUSH
49599: DOUBLE
49600: LD_INT 1
49602: DEC
49603: ST_TO_ADDR
49604: LD_VAR 0 4
49608: PUSH
49609: FOR_TO
49610: IFFALSE 49639
// units_path := Replace ( units_path , i , path ) ;
49612: LD_ADDR_VAR 0 16
49616: PUSH
49617: LD_VAR 0 16
49621: PPUSH
49622: LD_VAR 0 7
49626: PPUSH
49627: LD_VAR 0 5
49631: PPUSH
49632: CALL_OW 1
49636: ST_TO_ADDR
49637: GO 49609
49639: POP
49640: POP
// repeat for i = group downto 1 do
49641: LD_ADDR_VAR 0 7
49645: PUSH
49646: DOUBLE
49647: LD_VAR 0 4
49651: INC
49652: ST_TO_ADDR
49653: LD_INT 1
49655: PUSH
49656: FOR_DOWNTO
49657: IFFALSE 53753
// begin wait ( 5 ) ;
49659: LD_INT 5
49661: PPUSH
49662: CALL_OW 67
// tmp := [ ] ;
49666: LD_ADDR_VAR 0 14
49670: PUSH
49671: EMPTY
49672: ST_TO_ADDR
// attacking := false ;
49673: LD_ADDR_VAR 0 29
49677: PUSH
49678: LD_INT 0
49680: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
49681: LD_VAR 0 4
49685: PUSH
49686: LD_VAR 0 7
49690: ARRAY
49691: PPUSH
49692: CALL_OW 301
49696: PUSH
49697: LD_VAR 0 4
49701: PUSH
49702: LD_VAR 0 7
49706: ARRAY
49707: NOT
49708: OR
49709: IFFALSE 49818
// begin if GetType ( group [ i ] ) = unit_human then
49711: LD_VAR 0 4
49715: PUSH
49716: LD_VAR 0 7
49720: ARRAY
49721: PPUSH
49722: CALL_OW 247
49726: PUSH
49727: LD_INT 1
49729: EQUAL
49730: IFFALSE 49776
// begin to_heal := to_heal diff group [ i ] ;
49732: LD_ADDR_VAR 0 30
49736: PUSH
49737: LD_VAR 0 30
49741: PUSH
49742: LD_VAR 0 4
49746: PUSH
49747: LD_VAR 0 7
49751: ARRAY
49752: DIFF
49753: ST_TO_ADDR
// healers := healers diff group [ i ] ;
49754: LD_ADDR_VAR 0 31
49758: PUSH
49759: LD_VAR 0 31
49763: PUSH
49764: LD_VAR 0 4
49768: PUSH
49769: LD_VAR 0 7
49773: ARRAY
49774: DIFF
49775: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
49776: LD_ADDR_VAR 0 4
49780: PUSH
49781: LD_VAR 0 4
49785: PPUSH
49786: LD_VAR 0 7
49790: PPUSH
49791: CALL_OW 3
49795: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
49796: LD_ADDR_VAR 0 16
49800: PUSH
49801: LD_VAR 0 16
49805: PPUSH
49806: LD_VAR 0 7
49810: PPUSH
49811: CALL_OW 3
49815: ST_TO_ADDR
// continue ;
49816: GO 49656
// end ; if f_repair then
49818: LD_VAR 0 22
49822: IFFALSE 50311
// begin if GetType ( group [ i ] ) = unit_vehicle then
49824: LD_VAR 0 4
49828: PUSH
49829: LD_VAR 0 7
49833: ARRAY
49834: PPUSH
49835: CALL_OW 247
49839: PUSH
49840: LD_INT 2
49842: EQUAL
49843: IFFALSE 50033
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
49845: LD_VAR 0 4
49849: PUSH
49850: LD_VAR 0 7
49854: ARRAY
49855: PPUSH
49856: CALL_OW 256
49860: PUSH
49861: LD_INT 700
49863: LESS
49864: PUSH
49865: LD_VAR 0 4
49869: PUSH
49870: LD_VAR 0 7
49874: ARRAY
49875: PUSH
49876: LD_VAR 0 32
49880: IN
49881: NOT
49882: AND
49883: IFFALSE 49907
// to_repair := to_repair union group [ i ] ;
49885: LD_ADDR_VAR 0 32
49889: PUSH
49890: LD_VAR 0 32
49894: PUSH
49895: LD_VAR 0 4
49899: PUSH
49900: LD_VAR 0 7
49904: ARRAY
49905: UNION
49906: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
49907: LD_VAR 0 4
49911: PUSH
49912: LD_VAR 0 7
49916: ARRAY
49917: PPUSH
49918: CALL_OW 256
49922: PUSH
49923: LD_INT 1000
49925: EQUAL
49926: PUSH
49927: LD_VAR 0 4
49931: PUSH
49932: LD_VAR 0 7
49936: ARRAY
49937: PUSH
49938: LD_VAR 0 32
49942: IN
49943: AND
49944: IFFALSE 49968
// to_repair := to_repair diff group [ i ] ;
49946: LD_ADDR_VAR 0 32
49950: PUSH
49951: LD_VAR 0 32
49955: PUSH
49956: LD_VAR 0 4
49960: PUSH
49961: LD_VAR 0 7
49965: ARRAY
49966: DIFF
49967: ST_TO_ADDR
// if group [ i ] in to_repair then
49968: LD_VAR 0 4
49972: PUSH
49973: LD_VAR 0 7
49977: ARRAY
49978: PUSH
49979: LD_VAR 0 32
49983: IN
49984: IFFALSE 50031
// begin if not IsInArea ( group [ i ] , f_repair ) then
49986: LD_VAR 0 4
49990: PUSH
49991: LD_VAR 0 7
49995: ARRAY
49996: PPUSH
49997: LD_VAR 0 22
50001: PPUSH
50002: CALL_OW 308
50006: NOT
50007: IFFALSE 50029
// ComMoveToArea ( group [ i ] , f_repair ) ;
50009: LD_VAR 0 4
50013: PUSH
50014: LD_VAR 0 7
50018: ARRAY
50019: PPUSH
50020: LD_VAR 0 22
50024: PPUSH
50025: CALL_OW 113
// continue ;
50029: GO 49656
// end ; end else
50031: GO 50311
// if group [ i ] in repairs then
50033: LD_VAR 0 4
50037: PUSH
50038: LD_VAR 0 7
50042: ARRAY
50043: PUSH
50044: LD_VAR 0 33
50048: IN
50049: IFFALSE 50311
// begin if IsInUnit ( group [ i ] ) then
50051: LD_VAR 0 4
50055: PUSH
50056: LD_VAR 0 7
50060: ARRAY
50061: PPUSH
50062: CALL_OW 310
50066: IFFALSE 50134
// begin z := IsInUnit ( group [ i ] ) ;
50068: LD_ADDR_VAR 0 13
50072: PUSH
50073: LD_VAR 0 4
50077: PUSH
50078: LD_VAR 0 7
50082: ARRAY
50083: PPUSH
50084: CALL_OW 310
50088: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
50089: LD_VAR 0 13
50093: PUSH
50094: LD_VAR 0 32
50098: IN
50099: PUSH
50100: LD_VAR 0 13
50104: PPUSH
50105: LD_VAR 0 22
50109: PPUSH
50110: CALL_OW 308
50114: AND
50115: IFFALSE 50132
// ComExitVehicle ( group [ i ] ) ;
50117: LD_VAR 0 4
50121: PUSH
50122: LD_VAR 0 7
50126: ARRAY
50127: PPUSH
50128: CALL_OW 121
// end else
50132: GO 50311
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
50134: LD_ADDR_VAR 0 13
50138: PUSH
50139: LD_VAR 0 4
50143: PPUSH
50144: LD_INT 95
50146: PUSH
50147: LD_VAR 0 22
50151: PUSH
50152: EMPTY
50153: LIST
50154: LIST
50155: PUSH
50156: LD_INT 58
50158: PUSH
50159: EMPTY
50160: LIST
50161: PUSH
50162: EMPTY
50163: LIST
50164: LIST
50165: PPUSH
50166: CALL_OW 72
50170: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
50171: LD_VAR 0 4
50175: PUSH
50176: LD_VAR 0 7
50180: ARRAY
50181: PPUSH
50182: CALL_OW 314
50186: NOT
50187: IFFALSE 50309
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
50189: LD_ADDR_VAR 0 10
50193: PUSH
50194: LD_VAR 0 13
50198: PPUSH
50199: LD_VAR 0 4
50203: PUSH
50204: LD_VAR 0 7
50208: ARRAY
50209: PPUSH
50210: CALL_OW 74
50214: ST_TO_ADDR
// if not x then
50215: LD_VAR 0 10
50219: NOT
50220: IFFALSE 50224
// continue ;
50222: GO 49656
// if GetLives ( x ) < 1000 then
50224: LD_VAR 0 10
50228: PPUSH
50229: CALL_OW 256
50233: PUSH
50234: LD_INT 1000
50236: LESS
50237: IFFALSE 50261
// ComRepairVehicle ( group [ i ] , x ) else
50239: LD_VAR 0 4
50243: PUSH
50244: LD_VAR 0 7
50248: ARRAY
50249: PPUSH
50250: LD_VAR 0 10
50254: PPUSH
50255: CALL_OW 129
50259: GO 50309
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
50261: LD_VAR 0 23
50265: PUSH
50266: LD_VAR 0 4
50270: PUSH
50271: LD_VAR 0 7
50275: ARRAY
50276: PPUSH
50277: CALL_OW 256
50281: PUSH
50282: LD_INT 1000
50284: LESS
50285: AND
50286: NOT
50287: IFFALSE 50309
// ComEnterUnit ( group [ i ] , x ) ;
50289: LD_VAR 0 4
50293: PUSH
50294: LD_VAR 0 7
50298: ARRAY
50299: PPUSH
50300: LD_VAR 0 10
50304: PPUSH
50305: CALL_OW 120
// end ; continue ;
50309: GO 49656
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
50311: LD_VAR 0 23
50315: PUSH
50316: LD_VAR 0 4
50320: PUSH
50321: LD_VAR 0 7
50325: ARRAY
50326: PPUSH
50327: CALL_OW 247
50331: PUSH
50332: LD_INT 1
50334: EQUAL
50335: AND
50336: IFFALSE 50814
// begin if group [ i ] in healers then
50338: LD_VAR 0 4
50342: PUSH
50343: LD_VAR 0 7
50347: ARRAY
50348: PUSH
50349: LD_VAR 0 31
50353: IN
50354: IFFALSE 50627
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
50356: LD_VAR 0 4
50360: PUSH
50361: LD_VAR 0 7
50365: ARRAY
50366: PPUSH
50367: LD_VAR 0 23
50371: PPUSH
50372: CALL_OW 308
50376: NOT
50377: PUSH
50378: LD_VAR 0 4
50382: PUSH
50383: LD_VAR 0 7
50387: ARRAY
50388: PPUSH
50389: CALL_OW 314
50393: NOT
50394: AND
50395: IFFALSE 50419
// ComMoveToArea ( group [ i ] , f_heal ) else
50397: LD_VAR 0 4
50401: PUSH
50402: LD_VAR 0 7
50406: ARRAY
50407: PPUSH
50408: LD_VAR 0 23
50412: PPUSH
50413: CALL_OW 113
50417: GO 50625
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
50419: LD_VAR 0 4
50423: PUSH
50424: LD_VAR 0 7
50428: ARRAY
50429: PPUSH
50430: CALL 49037 0 1
50434: PPUSH
50435: CALL_OW 256
50439: PUSH
50440: LD_INT 1000
50442: EQUAL
50443: IFFALSE 50462
// ComStop ( group [ i ] ) else
50445: LD_VAR 0 4
50449: PUSH
50450: LD_VAR 0 7
50454: ARRAY
50455: PPUSH
50456: CALL_OW 141
50460: GO 50625
// if not HasTask ( group [ i ] ) and to_heal then
50462: LD_VAR 0 4
50466: PUSH
50467: LD_VAR 0 7
50471: ARRAY
50472: PPUSH
50473: CALL_OW 314
50477: NOT
50478: PUSH
50479: LD_VAR 0 30
50483: AND
50484: IFFALSE 50625
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
50486: LD_ADDR_VAR 0 13
50490: PUSH
50491: LD_VAR 0 30
50495: PPUSH
50496: LD_INT 3
50498: PUSH
50499: LD_INT 54
50501: PUSH
50502: EMPTY
50503: LIST
50504: PUSH
50505: EMPTY
50506: LIST
50507: LIST
50508: PPUSH
50509: CALL_OW 72
50513: PPUSH
50514: LD_VAR 0 4
50518: PUSH
50519: LD_VAR 0 7
50523: ARRAY
50524: PPUSH
50525: CALL_OW 74
50529: ST_TO_ADDR
// if z then
50530: LD_VAR 0 13
50534: IFFALSE 50625
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
50536: LD_INT 91
50538: PUSH
50539: LD_VAR 0 13
50543: PUSH
50544: LD_INT 10
50546: PUSH
50547: EMPTY
50548: LIST
50549: LIST
50550: LIST
50551: PUSH
50552: LD_INT 81
50554: PUSH
50555: LD_VAR 0 13
50559: PPUSH
50560: CALL_OW 255
50564: PUSH
50565: EMPTY
50566: LIST
50567: LIST
50568: PUSH
50569: EMPTY
50570: LIST
50571: LIST
50572: PPUSH
50573: CALL_OW 69
50577: PUSH
50578: LD_INT 0
50580: EQUAL
50581: IFFALSE 50605
// ComHeal ( group [ i ] , z ) else
50583: LD_VAR 0 4
50587: PUSH
50588: LD_VAR 0 7
50592: ARRAY
50593: PPUSH
50594: LD_VAR 0 13
50598: PPUSH
50599: CALL_OW 128
50603: GO 50625
// ComMoveToArea ( group [ i ] , f_heal ) ;
50605: LD_VAR 0 4
50609: PUSH
50610: LD_VAR 0 7
50614: ARRAY
50615: PPUSH
50616: LD_VAR 0 23
50620: PPUSH
50621: CALL_OW 113
// end ; continue ;
50625: GO 49656
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
50627: LD_VAR 0 4
50631: PUSH
50632: LD_VAR 0 7
50636: ARRAY
50637: PPUSH
50638: CALL_OW 256
50642: PUSH
50643: LD_INT 700
50645: LESS
50646: PUSH
50647: LD_VAR 0 4
50651: PUSH
50652: LD_VAR 0 7
50656: ARRAY
50657: PUSH
50658: LD_VAR 0 30
50662: IN
50663: NOT
50664: AND
50665: IFFALSE 50689
// to_heal := to_heal union group [ i ] ;
50667: LD_ADDR_VAR 0 30
50671: PUSH
50672: LD_VAR 0 30
50676: PUSH
50677: LD_VAR 0 4
50681: PUSH
50682: LD_VAR 0 7
50686: ARRAY
50687: UNION
50688: ST_TO_ADDR
// if group [ i ] in to_heal then
50689: LD_VAR 0 4
50693: PUSH
50694: LD_VAR 0 7
50698: ARRAY
50699: PUSH
50700: LD_VAR 0 30
50704: IN
50705: IFFALSE 50814
// begin if GetLives ( group [ i ] ) = 1000 then
50707: LD_VAR 0 4
50711: PUSH
50712: LD_VAR 0 7
50716: ARRAY
50717: PPUSH
50718: CALL_OW 256
50722: PUSH
50723: LD_INT 1000
50725: EQUAL
50726: IFFALSE 50752
// to_heal := to_heal diff group [ i ] else
50728: LD_ADDR_VAR 0 30
50732: PUSH
50733: LD_VAR 0 30
50737: PUSH
50738: LD_VAR 0 4
50742: PUSH
50743: LD_VAR 0 7
50747: ARRAY
50748: DIFF
50749: ST_TO_ADDR
50750: GO 50814
// begin if not IsInArea ( group [ i ] , to_heal ) then
50752: LD_VAR 0 4
50756: PUSH
50757: LD_VAR 0 7
50761: ARRAY
50762: PPUSH
50763: LD_VAR 0 30
50767: PPUSH
50768: CALL_OW 308
50772: NOT
50773: IFFALSE 50797
// ComMoveToArea ( group [ i ] , f_heal ) else
50775: LD_VAR 0 4
50779: PUSH
50780: LD_VAR 0 7
50784: ARRAY
50785: PPUSH
50786: LD_VAR 0 23
50790: PPUSH
50791: CALL_OW 113
50795: GO 50812
// ComHold ( group [ i ] ) ;
50797: LD_VAR 0 4
50801: PUSH
50802: LD_VAR 0 7
50806: ARRAY
50807: PPUSH
50808: CALL_OW 140
// continue ;
50812: GO 49656
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
50814: LD_VAR 0 4
50818: PUSH
50819: LD_VAR 0 7
50823: ARRAY
50824: PPUSH
50825: LD_INT 10
50827: PPUSH
50828: CALL 47434 0 2
50832: NOT
50833: PUSH
50834: LD_VAR 0 16
50838: PUSH
50839: LD_VAR 0 7
50843: ARRAY
50844: PUSH
50845: EMPTY
50846: EQUAL
50847: NOT
50848: AND
50849: IFFALSE 51115
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
50851: LD_VAR 0 4
50855: PUSH
50856: LD_VAR 0 7
50860: ARRAY
50861: PPUSH
50862: CALL_OW 262
50866: PUSH
50867: LD_INT 1
50869: PUSH
50870: LD_INT 2
50872: PUSH
50873: EMPTY
50874: LIST
50875: LIST
50876: IN
50877: IFFALSE 50918
// if GetFuel ( group [ i ] ) < 10 then
50879: LD_VAR 0 4
50883: PUSH
50884: LD_VAR 0 7
50888: ARRAY
50889: PPUSH
50890: CALL_OW 261
50894: PUSH
50895: LD_INT 10
50897: LESS
50898: IFFALSE 50918
// SetFuel ( group [ i ] , 12 ) ;
50900: LD_VAR 0 4
50904: PUSH
50905: LD_VAR 0 7
50909: ARRAY
50910: PPUSH
50911: LD_INT 12
50913: PPUSH
50914: CALL_OW 240
// if units_path [ i ] then
50918: LD_VAR 0 16
50922: PUSH
50923: LD_VAR 0 7
50927: ARRAY
50928: IFFALSE 51113
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
50930: LD_VAR 0 4
50934: PUSH
50935: LD_VAR 0 7
50939: ARRAY
50940: PPUSH
50941: LD_VAR 0 16
50945: PUSH
50946: LD_VAR 0 7
50950: ARRAY
50951: PUSH
50952: LD_INT 1
50954: ARRAY
50955: PUSH
50956: LD_INT 1
50958: ARRAY
50959: PPUSH
50960: LD_VAR 0 16
50964: PUSH
50965: LD_VAR 0 7
50969: ARRAY
50970: PUSH
50971: LD_INT 1
50973: ARRAY
50974: PUSH
50975: LD_INT 2
50977: ARRAY
50978: PPUSH
50979: CALL_OW 297
50983: PUSH
50984: LD_INT 6
50986: GREATER
50987: IFFALSE 51062
// begin if not HasTask ( group [ i ] ) then
50989: LD_VAR 0 4
50993: PUSH
50994: LD_VAR 0 7
50998: ARRAY
50999: PPUSH
51000: CALL_OW 314
51004: NOT
51005: IFFALSE 51060
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
51007: LD_VAR 0 4
51011: PUSH
51012: LD_VAR 0 7
51016: ARRAY
51017: PPUSH
51018: LD_VAR 0 16
51022: PUSH
51023: LD_VAR 0 7
51027: ARRAY
51028: PUSH
51029: LD_INT 1
51031: ARRAY
51032: PUSH
51033: LD_INT 1
51035: ARRAY
51036: PPUSH
51037: LD_VAR 0 16
51041: PUSH
51042: LD_VAR 0 7
51046: ARRAY
51047: PUSH
51048: LD_INT 1
51050: ARRAY
51051: PUSH
51052: LD_INT 2
51054: ARRAY
51055: PPUSH
51056: CALL_OW 114
// end else
51060: GO 51113
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
51062: LD_ADDR_VAR 0 15
51066: PUSH
51067: LD_VAR 0 16
51071: PUSH
51072: LD_VAR 0 7
51076: ARRAY
51077: PPUSH
51078: LD_INT 1
51080: PPUSH
51081: CALL_OW 3
51085: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
51086: LD_ADDR_VAR 0 16
51090: PUSH
51091: LD_VAR 0 16
51095: PPUSH
51096: LD_VAR 0 7
51100: PPUSH
51101: LD_VAR 0 15
51105: PPUSH
51106: CALL_OW 1
51110: ST_TO_ADDR
// continue ;
51111: GO 49656
// end ; end ; end else
51113: GO 53751
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
51115: LD_ADDR_VAR 0 14
51119: PUSH
51120: LD_INT 81
51122: PUSH
51123: LD_VAR 0 4
51127: PUSH
51128: LD_VAR 0 7
51132: ARRAY
51133: PPUSH
51134: CALL_OW 255
51138: PUSH
51139: EMPTY
51140: LIST
51141: LIST
51142: PPUSH
51143: CALL_OW 69
51147: ST_TO_ADDR
// if not tmp then
51148: LD_VAR 0 14
51152: NOT
51153: IFFALSE 51157
// continue ;
51155: GO 49656
// if f_ignore_area then
51157: LD_VAR 0 17
51161: IFFALSE 51249
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
51163: LD_ADDR_VAR 0 15
51167: PUSH
51168: LD_VAR 0 14
51172: PPUSH
51173: LD_INT 3
51175: PUSH
51176: LD_INT 92
51178: PUSH
51179: LD_VAR 0 17
51183: PUSH
51184: LD_INT 1
51186: ARRAY
51187: PUSH
51188: LD_VAR 0 17
51192: PUSH
51193: LD_INT 2
51195: ARRAY
51196: PUSH
51197: LD_VAR 0 17
51201: PUSH
51202: LD_INT 3
51204: ARRAY
51205: PUSH
51206: EMPTY
51207: LIST
51208: LIST
51209: LIST
51210: LIST
51211: PUSH
51212: EMPTY
51213: LIST
51214: LIST
51215: PPUSH
51216: CALL_OW 72
51220: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51221: LD_VAR 0 14
51225: PUSH
51226: LD_VAR 0 15
51230: DIFF
51231: IFFALSE 51249
// tmp := tmp diff tmp2 ;
51233: LD_ADDR_VAR 0 14
51237: PUSH
51238: LD_VAR 0 14
51242: PUSH
51243: LD_VAR 0 15
51247: DIFF
51248: ST_TO_ADDR
// end ; if not f_murder then
51249: LD_VAR 0 20
51253: NOT
51254: IFFALSE 51312
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
51256: LD_ADDR_VAR 0 15
51260: PUSH
51261: LD_VAR 0 14
51265: PPUSH
51266: LD_INT 3
51268: PUSH
51269: LD_INT 50
51271: PUSH
51272: EMPTY
51273: LIST
51274: PUSH
51275: EMPTY
51276: LIST
51277: LIST
51278: PPUSH
51279: CALL_OW 72
51283: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51284: LD_VAR 0 14
51288: PUSH
51289: LD_VAR 0 15
51293: DIFF
51294: IFFALSE 51312
// tmp := tmp diff tmp2 ;
51296: LD_ADDR_VAR 0 14
51300: PUSH
51301: LD_VAR 0 14
51305: PUSH
51306: LD_VAR 0 15
51310: DIFF
51311: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
51312: LD_ADDR_VAR 0 14
51316: PUSH
51317: LD_VAR 0 4
51321: PUSH
51322: LD_VAR 0 7
51326: ARRAY
51327: PPUSH
51328: LD_VAR 0 14
51332: PPUSH
51333: LD_INT 1
51335: PPUSH
51336: LD_INT 1
51338: PPUSH
51339: CALL 21077 0 4
51343: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
51344: LD_VAR 0 4
51348: PUSH
51349: LD_VAR 0 7
51353: ARRAY
51354: PPUSH
51355: CALL_OW 257
51359: PUSH
51360: LD_INT 1
51362: EQUAL
51363: IFFALSE 51811
// begin if WantPlant ( group [ i ] ) then
51365: LD_VAR 0 4
51369: PUSH
51370: LD_VAR 0 7
51374: ARRAY
51375: PPUSH
51376: CALL 20578 0 1
51380: IFFALSE 51384
// continue ;
51382: GO 49656
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
51384: LD_VAR 0 18
51388: PUSH
51389: LD_VAR 0 4
51393: PUSH
51394: LD_VAR 0 7
51398: ARRAY
51399: PPUSH
51400: CALL_OW 310
51404: NOT
51405: AND
51406: PUSH
51407: LD_VAR 0 14
51411: PUSH
51412: LD_INT 1
51414: ARRAY
51415: PUSH
51416: LD_VAR 0 14
51420: PPUSH
51421: LD_INT 21
51423: PUSH
51424: LD_INT 2
51426: PUSH
51427: EMPTY
51428: LIST
51429: LIST
51430: PUSH
51431: LD_INT 58
51433: PUSH
51434: EMPTY
51435: LIST
51436: PUSH
51437: EMPTY
51438: LIST
51439: LIST
51440: PPUSH
51441: CALL_OW 72
51445: IN
51446: AND
51447: IFFALSE 51483
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
51449: LD_VAR 0 4
51453: PUSH
51454: LD_VAR 0 7
51458: ARRAY
51459: PPUSH
51460: LD_VAR 0 14
51464: PUSH
51465: LD_INT 1
51467: ARRAY
51468: PPUSH
51469: CALL_OW 120
// attacking := true ;
51473: LD_ADDR_VAR 0 29
51477: PUSH
51478: LD_INT 1
51480: ST_TO_ADDR
// continue ;
51481: GO 49656
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
51483: LD_VAR 0 26
51487: PUSH
51488: LD_VAR 0 4
51492: PUSH
51493: LD_VAR 0 7
51497: ARRAY
51498: PPUSH
51499: CALL_OW 257
51503: PUSH
51504: LD_INT 1
51506: EQUAL
51507: AND
51508: PUSH
51509: LD_VAR 0 4
51513: PUSH
51514: LD_VAR 0 7
51518: ARRAY
51519: PPUSH
51520: CALL_OW 256
51524: PUSH
51525: LD_INT 800
51527: LESS
51528: AND
51529: PUSH
51530: LD_VAR 0 4
51534: PUSH
51535: LD_VAR 0 7
51539: ARRAY
51540: PPUSH
51541: CALL_OW 318
51545: NOT
51546: AND
51547: IFFALSE 51564
// ComCrawl ( group [ i ] ) ;
51549: LD_VAR 0 4
51553: PUSH
51554: LD_VAR 0 7
51558: ARRAY
51559: PPUSH
51560: CALL_OW 137
// if f_mines then
51564: LD_VAR 0 21
51568: IFFALSE 51811
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
51570: LD_VAR 0 14
51574: PUSH
51575: LD_INT 1
51577: ARRAY
51578: PPUSH
51579: CALL_OW 247
51583: PUSH
51584: LD_INT 3
51586: EQUAL
51587: PUSH
51588: LD_VAR 0 14
51592: PUSH
51593: LD_INT 1
51595: ARRAY
51596: PUSH
51597: LD_VAR 0 27
51601: IN
51602: NOT
51603: AND
51604: IFFALSE 51811
// begin x := GetX ( tmp [ 1 ] ) ;
51606: LD_ADDR_VAR 0 10
51610: PUSH
51611: LD_VAR 0 14
51615: PUSH
51616: LD_INT 1
51618: ARRAY
51619: PPUSH
51620: CALL_OW 250
51624: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
51625: LD_ADDR_VAR 0 11
51629: PUSH
51630: LD_VAR 0 14
51634: PUSH
51635: LD_INT 1
51637: ARRAY
51638: PPUSH
51639: CALL_OW 251
51643: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
51644: LD_ADDR_VAR 0 12
51648: PUSH
51649: LD_VAR 0 4
51653: PUSH
51654: LD_VAR 0 7
51658: ARRAY
51659: PPUSH
51660: CALL 47519 0 1
51664: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
51665: LD_VAR 0 4
51669: PUSH
51670: LD_VAR 0 7
51674: ARRAY
51675: PPUSH
51676: LD_VAR 0 10
51680: PPUSH
51681: LD_VAR 0 11
51685: PPUSH
51686: LD_VAR 0 14
51690: PUSH
51691: LD_INT 1
51693: ARRAY
51694: PPUSH
51695: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
51699: LD_VAR 0 4
51703: PUSH
51704: LD_VAR 0 7
51708: ARRAY
51709: PPUSH
51710: LD_VAR 0 10
51714: PPUSH
51715: LD_VAR 0 12
51719: PPUSH
51720: LD_INT 7
51722: PPUSH
51723: CALL_OW 272
51727: PPUSH
51728: LD_VAR 0 11
51732: PPUSH
51733: LD_VAR 0 12
51737: PPUSH
51738: LD_INT 7
51740: PPUSH
51741: CALL_OW 273
51745: PPUSH
51746: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
51750: LD_VAR 0 4
51754: PUSH
51755: LD_VAR 0 7
51759: ARRAY
51760: PPUSH
51761: LD_INT 71
51763: PPUSH
51764: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
51768: LD_ADDR_VAR 0 27
51772: PUSH
51773: LD_VAR 0 27
51777: PPUSH
51778: LD_VAR 0 27
51782: PUSH
51783: LD_INT 1
51785: PLUS
51786: PPUSH
51787: LD_VAR 0 14
51791: PUSH
51792: LD_INT 1
51794: ARRAY
51795: PPUSH
51796: CALL_OW 1
51800: ST_TO_ADDR
// attacking := true ;
51801: LD_ADDR_VAR 0 29
51805: PUSH
51806: LD_INT 1
51808: ST_TO_ADDR
// continue ;
51809: GO 49656
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
51811: LD_VAR 0 4
51815: PUSH
51816: LD_VAR 0 7
51820: ARRAY
51821: PPUSH
51822: CALL_OW 257
51826: PUSH
51827: LD_INT 17
51829: EQUAL
51830: PUSH
51831: LD_VAR 0 4
51835: PUSH
51836: LD_VAR 0 7
51840: ARRAY
51841: PPUSH
51842: CALL_OW 110
51846: PUSH
51847: LD_INT 71
51849: EQUAL
51850: NOT
51851: AND
51852: IFFALSE 51998
// begin attacking := false ;
51854: LD_ADDR_VAR 0 29
51858: PUSH
51859: LD_INT 0
51861: ST_TO_ADDR
// k := 5 ;
51862: LD_ADDR_VAR 0 9
51866: PUSH
51867: LD_INT 5
51869: ST_TO_ADDR
// if tmp < k then
51870: LD_VAR 0 14
51874: PUSH
51875: LD_VAR 0 9
51879: LESS
51880: IFFALSE 51892
// k := tmp ;
51882: LD_ADDR_VAR 0 9
51886: PUSH
51887: LD_VAR 0 14
51891: ST_TO_ADDR
// for j = 1 to k do
51892: LD_ADDR_VAR 0 8
51896: PUSH
51897: DOUBLE
51898: LD_INT 1
51900: DEC
51901: ST_TO_ADDR
51902: LD_VAR 0 9
51906: PUSH
51907: FOR_TO
51908: IFFALSE 51996
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
51910: LD_VAR 0 14
51914: PUSH
51915: LD_VAR 0 8
51919: ARRAY
51920: PUSH
51921: LD_VAR 0 14
51925: PPUSH
51926: LD_INT 58
51928: PUSH
51929: EMPTY
51930: LIST
51931: PPUSH
51932: CALL_OW 72
51936: IN
51937: NOT
51938: IFFALSE 51994
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
51940: LD_VAR 0 4
51944: PUSH
51945: LD_VAR 0 7
51949: ARRAY
51950: PPUSH
51951: LD_VAR 0 14
51955: PUSH
51956: LD_VAR 0 8
51960: ARRAY
51961: PPUSH
51962: CALL_OW 115
// attacking := true ;
51966: LD_ADDR_VAR 0 29
51970: PUSH
51971: LD_INT 1
51973: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
51974: LD_VAR 0 4
51978: PUSH
51979: LD_VAR 0 7
51983: ARRAY
51984: PPUSH
51985: LD_INT 71
51987: PPUSH
51988: CALL_OW 109
// continue ;
51992: GO 51907
// end ; end ;
51994: GO 51907
51996: POP
51997: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
51998: LD_VAR 0 4
52002: PUSH
52003: LD_VAR 0 7
52007: ARRAY
52008: PPUSH
52009: CALL_OW 257
52013: PUSH
52014: LD_INT 8
52016: EQUAL
52017: PUSH
52018: LD_VAR 0 4
52022: PUSH
52023: LD_VAR 0 7
52027: ARRAY
52028: PPUSH
52029: CALL_OW 264
52033: PUSH
52034: LD_INT 28
52036: PUSH
52037: LD_INT 45
52039: PUSH
52040: LD_INT 7
52042: PUSH
52043: LD_INT 47
52045: PUSH
52046: EMPTY
52047: LIST
52048: LIST
52049: LIST
52050: LIST
52051: IN
52052: OR
52053: IFFALSE 52283
// begin attacking := false ;
52055: LD_ADDR_VAR 0 29
52059: PUSH
52060: LD_INT 0
52062: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
52063: LD_VAR 0 14
52067: PUSH
52068: LD_INT 1
52070: ARRAY
52071: PPUSH
52072: CALL_OW 266
52076: PUSH
52077: LD_INT 32
52079: PUSH
52080: LD_INT 31
52082: PUSH
52083: LD_INT 33
52085: PUSH
52086: LD_INT 4
52088: PUSH
52089: LD_INT 5
52091: PUSH
52092: EMPTY
52093: LIST
52094: LIST
52095: LIST
52096: LIST
52097: LIST
52098: IN
52099: IFFALSE 52283
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
52101: LD_ADDR_VAR 0 9
52105: PUSH
52106: LD_VAR 0 14
52110: PUSH
52111: LD_INT 1
52113: ARRAY
52114: PPUSH
52115: CALL_OW 266
52119: PPUSH
52120: LD_VAR 0 14
52124: PUSH
52125: LD_INT 1
52127: ARRAY
52128: PPUSH
52129: CALL_OW 250
52133: PPUSH
52134: LD_VAR 0 14
52138: PUSH
52139: LD_INT 1
52141: ARRAY
52142: PPUSH
52143: CALL_OW 251
52147: PPUSH
52148: LD_VAR 0 14
52152: PUSH
52153: LD_INT 1
52155: ARRAY
52156: PPUSH
52157: CALL_OW 254
52161: PPUSH
52162: LD_VAR 0 14
52166: PUSH
52167: LD_INT 1
52169: ARRAY
52170: PPUSH
52171: CALL_OW 248
52175: PPUSH
52176: LD_INT 0
52178: PPUSH
52179: CALL 28889 0 6
52183: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
52184: LD_ADDR_VAR 0 8
52188: PUSH
52189: LD_VAR 0 4
52193: PUSH
52194: LD_VAR 0 7
52198: ARRAY
52199: PPUSH
52200: LD_VAR 0 9
52204: PPUSH
52205: CALL 47582 0 2
52209: ST_TO_ADDR
// if j then
52210: LD_VAR 0 8
52214: IFFALSE 52283
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
52216: LD_VAR 0 8
52220: PUSH
52221: LD_INT 1
52223: ARRAY
52224: PPUSH
52225: LD_VAR 0 8
52229: PUSH
52230: LD_INT 2
52232: ARRAY
52233: PPUSH
52234: CALL_OW 488
52238: IFFALSE 52283
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
52240: LD_VAR 0 4
52244: PUSH
52245: LD_VAR 0 7
52249: ARRAY
52250: PPUSH
52251: LD_VAR 0 8
52255: PUSH
52256: LD_INT 1
52258: ARRAY
52259: PPUSH
52260: LD_VAR 0 8
52264: PUSH
52265: LD_INT 2
52267: ARRAY
52268: PPUSH
52269: CALL_OW 116
// attacking := true ;
52273: LD_ADDR_VAR 0 29
52277: PUSH
52278: LD_INT 1
52280: ST_TO_ADDR
// continue ;
52281: GO 49656
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
52283: LD_VAR 0 4
52287: PUSH
52288: LD_VAR 0 7
52292: ARRAY
52293: PPUSH
52294: CALL_OW 265
52298: PUSH
52299: LD_INT 11
52301: EQUAL
52302: IFFALSE 52580
// begin k := 10 ;
52304: LD_ADDR_VAR 0 9
52308: PUSH
52309: LD_INT 10
52311: ST_TO_ADDR
// x := 0 ;
52312: LD_ADDR_VAR 0 10
52316: PUSH
52317: LD_INT 0
52319: ST_TO_ADDR
// if tmp < k then
52320: LD_VAR 0 14
52324: PUSH
52325: LD_VAR 0 9
52329: LESS
52330: IFFALSE 52342
// k := tmp ;
52332: LD_ADDR_VAR 0 9
52336: PUSH
52337: LD_VAR 0 14
52341: ST_TO_ADDR
// for j = k downto 1 do
52342: LD_ADDR_VAR 0 8
52346: PUSH
52347: DOUBLE
52348: LD_VAR 0 9
52352: INC
52353: ST_TO_ADDR
52354: LD_INT 1
52356: PUSH
52357: FOR_DOWNTO
52358: IFFALSE 52433
// begin if GetType ( tmp [ j ] ) = unit_human then
52360: LD_VAR 0 14
52364: PUSH
52365: LD_VAR 0 8
52369: ARRAY
52370: PPUSH
52371: CALL_OW 247
52375: PUSH
52376: LD_INT 1
52378: EQUAL
52379: IFFALSE 52431
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
52381: LD_VAR 0 4
52385: PUSH
52386: LD_VAR 0 7
52390: ARRAY
52391: PPUSH
52392: LD_VAR 0 14
52396: PUSH
52397: LD_VAR 0 8
52401: ARRAY
52402: PPUSH
52403: CALL 47853 0 2
// x := tmp [ j ] ;
52407: LD_ADDR_VAR 0 10
52411: PUSH
52412: LD_VAR 0 14
52416: PUSH
52417: LD_VAR 0 8
52421: ARRAY
52422: ST_TO_ADDR
// attacking := true ;
52423: LD_ADDR_VAR 0 29
52427: PUSH
52428: LD_INT 1
52430: ST_TO_ADDR
// end ; end ;
52431: GO 52357
52433: POP
52434: POP
// if not x then
52435: LD_VAR 0 10
52439: NOT
52440: IFFALSE 52580
// begin attacking := true ;
52442: LD_ADDR_VAR 0 29
52446: PUSH
52447: LD_INT 1
52449: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
52450: LD_VAR 0 4
52454: PUSH
52455: LD_VAR 0 7
52459: ARRAY
52460: PPUSH
52461: CALL_OW 250
52465: PPUSH
52466: LD_VAR 0 4
52470: PUSH
52471: LD_VAR 0 7
52475: ARRAY
52476: PPUSH
52477: CALL_OW 251
52481: PPUSH
52482: CALL_OW 546
52486: PUSH
52487: LD_INT 2
52489: ARRAY
52490: PUSH
52491: LD_VAR 0 14
52495: PUSH
52496: LD_INT 1
52498: ARRAY
52499: PPUSH
52500: CALL_OW 250
52504: PPUSH
52505: LD_VAR 0 14
52509: PUSH
52510: LD_INT 1
52512: ARRAY
52513: PPUSH
52514: CALL_OW 251
52518: PPUSH
52519: CALL_OW 546
52523: PUSH
52524: LD_INT 2
52526: ARRAY
52527: EQUAL
52528: IFFALSE 52556
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
52530: LD_VAR 0 4
52534: PUSH
52535: LD_VAR 0 7
52539: ARRAY
52540: PPUSH
52541: LD_VAR 0 14
52545: PUSH
52546: LD_INT 1
52548: ARRAY
52549: PPUSH
52550: CALL 47853 0 2
52554: GO 52580
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52556: LD_VAR 0 4
52560: PUSH
52561: LD_VAR 0 7
52565: ARRAY
52566: PPUSH
52567: LD_VAR 0 14
52571: PUSH
52572: LD_INT 1
52574: ARRAY
52575: PPUSH
52576: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
52580: LD_VAR 0 4
52584: PUSH
52585: LD_VAR 0 7
52589: ARRAY
52590: PPUSH
52591: CALL_OW 264
52595: PUSH
52596: LD_INT 29
52598: EQUAL
52599: IFFALSE 52965
// begin if WantsToAttack ( group [ i ] ) in bombed then
52601: LD_VAR 0 4
52605: PUSH
52606: LD_VAR 0 7
52610: ARRAY
52611: PPUSH
52612: CALL_OW 319
52616: PUSH
52617: LD_VAR 0 28
52621: IN
52622: IFFALSE 52626
// continue ;
52624: GO 49656
// k := 8 ;
52626: LD_ADDR_VAR 0 9
52630: PUSH
52631: LD_INT 8
52633: ST_TO_ADDR
// x := 0 ;
52634: LD_ADDR_VAR 0 10
52638: PUSH
52639: LD_INT 0
52641: ST_TO_ADDR
// if tmp < k then
52642: LD_VAR 0 14
52646: PUSH
52647: LD_VAR 0 9
52651: LESS
52652: IFFALSE 52664
// k := tmp ;
52654: LD_ADDR_VAR 0 9
52658: PUSH
52659: LD_VAR 0 14
52663: ST_TO_ADDR
// for j = 1 to k do
52664: LD_ADDR_VAR 0 8
52668: PUSH
52669: DOUBLE
52670: LD_INT 1
52672: DEC
52673: ST_TO_ADDR
52674: LD_VAR 0 9
52678: PUSH
52679: FOR_TO
52680: IFFALSE 52812
// begin if GetType ( tmp [ j ] ) = unit_building then
52682: LD_VAR 0 14
52686: PUSH
52687: LD_VAR 0 8
52691: ARRAY
52692: PPUSH
52693: CALL_OW 247
52697: PUSH
52698: LD_INT 3
52700: EQUAL
52701: IFFALSE 52810
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
52703: LD_VAR 0 14
52707: PUSH
52708: LD_VAR 0 8
52712: ARRAY
52713: PUSH
52714: LD_VAR 0 28
52718: IN
52719: NOT
52720: PUSH
52721: LD_VAR 0 14
52725: PUSH
52726: LD_VAR 0 8
52730: ARRAY
52731: PPUSH
52732: CALL_OW 313
52736: AND
52737: IFFALSE 52810
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52739: LD_VAR 0 4
52743: PUSH
52744: LD_VAR 0 7
52748: ARRAY
52749: PPUSH
52750: LD_VAR 0 14
52754: PUSH
52755: LD_VAR 0 8
52759: ARRAY
52760: PPUSH
52761: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
52765: LD_ADDR_VAR 0 28
52769: PUSH
52770: LD_VAR 0 28
52774: PPUSH
52775: LD_VAR 0 28
52779: PUSH
52780: LD_INT 1
52782: PLUS
52783: PPUSH
52784: LD_VAR 0 14
52788: PUSH
52789: LD_VAR 0 8
52793: ARRAY
52794: PPUSH
52795: CALL_OW 1
52799: ST_TO_ADDR
// attacking := true ;
52800: LD_ADDR_VAR 0 29
52804: PUSH
52805: LD_INT 1
52807: ST_TO_ADDR
// break ;
52808: GO 52812
// end ; end ;
52810: GO 52679
52812: POP
52813: POP
// if not attacking and f_attack_depot then
52814: LD_VAR 0 29
52818: NOT
52819: PUSH
52820: LD_VAR 0 25
52824: AND
52825: IFFALSE 52920
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52827: LD_ADDR_VAR 0 13
52831: PUSH
52832: LD_VAR 0 14
52836: PPUSH
52837: LD_INT 2
52839: PUSH
52840: LD_INT 30
52842: PUSH
52843: LD_INT 0
52845: PUSH
52846: EMPTY
52847: LIST
52848: LIST
52849: PUSH
52850: LD_INT 30
52852: PUSH
52853: LD_INT 1
52855: PUSH
52856: EMPTY
52857: LIST
52858: LIST
52859: PUSH
52860: EMPTY
52861: LIST
52862: LIST
52863: LIST
52864: PPUSH
52865: CALL_OW 72
52869: ST_TO_ADDR
// if z then
52870: LD_VAR 0 13
52874: IFFALSE 52920
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
52876: LD_VAR 0 4
52880: PUSH
52881: LD_VAR 0 7
52885: ARRAY
52886: PPUSH
52887: LD_VAR 0 13
52891: PPUSH
52892: LD_VAR 0 4
52896: PUSH
52897: LD_VAR 0 7
52901: ARRAY
52902: PPUSH
52903: CALL_OW 74
52907: PPUSH
52908: CALL_OW 115
// attacking := true ;
52912: LD_ADDR_VAR 0 29
52916: PUSH
52917: LD_INT 1
52919: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
52920: LD_VAR 0 4
52924: PUSH
52925: LD_VAR 0 7
52929: ARRAY
52930: PPUSH
52931: CALL_OW 256
52935: PUSH
52936: LD_INT 500
52938: LESS
52939: IFFALSE 52965
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52941: LD_VAR 0 4
52945: PUSH
52946: LD_VAR 0 7
52950: ARRAY
52951: PPUSH
52952: LD_VAR 0 14
52956: PUSH
52957: LD_INT 1
52959: ARRAY
52960: PPUSH
52961: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
52965: LD_VAR 0 4
52969: PUSH
52970: LD_VAR 0 7
52974: ARRAY
52975: PPUSH
52976: CALL_OW 264
52980: PUSH
52981: LD_INT 49
52983: EQUAL
52984: IFFALSE 53105
// begin if not HasTask ( group [ i ] ) then
52986: LD_VAR 0 4
52990: PUSH
52991: LD_VAR 0 7
52995: ARRAY
52996: PPUSH
52997: CALL_OW 314
53001: NOT
53002: IFFALSE 53105
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
53004: LD_ADDR_VAR 0 9
53008: PUSH
53009: LD_INT 81
53011: PUSH
53012: LD_VAR 0 4
53016: PUSH
53017: LD_VAR 0 7
53021: ARRAY
53022: PPUSH
53023: CALL_OW 255
53027: PUSH
53028: EMPTY
53029: LIST
53030: LIST
53031: PPUSH
53032: CALL_OW 69
53036: PPUSH
53037: LD_VAR 0 4
53041: PUSH
53042: LD_VAR 0 7
53046: ARRAY
53047: PPUSH
53048: CALL_OW 74
53052: ST_TO_ADDR
// if k then
53053: LD_VAR 0 9
53057: IFFALSE 53105
// if GetDistUnits ( group [ i ] , k ) > 10 then
53059: LD_VAR 0 4
53063: PUSH
53064: LD_VAR 0 7
53068: ARRAY
53069: PPUSH
53070: LD_VAR 0 9
53074: PPUSH
53075: CALL_OW 296
53079: PUSH
53080: LD_INT 10
53082: GREATER
53083: IFFALSE 53105
// ComMoveUnit ( group [ i ] , k ) ;
53085: LD_VAR 0 4
53089: PUSH
53090: LD_VAR 0 7
53094: ARRAY
53095: PPUSH
53096: LD_VAR 0 9
53100: PPUSH
53101: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53105: LD_VAR 0 4
53109: PUSH
53110: LD_VAR 0 7
53114: ARRAY
53115: PPUSH
53116: CALL_OW 256
53120: PUSH
53121: LD_INT 250
53123: LESS
53124: PUSH
53125: LD_VAR 0 4
53129: PUSH
53130: LD_VAR 0 7
53134: ARRAY
53135: PUSH
53136: LD_INT 21
53138: PUSH
53139: LD_INT 2
53141: PUSH
53142: EMPTY
53143: LIST
53144: LIST
53145: PUSH
53146: LD_INT 23
53148: PUSH
53149: LD_INT 2
53151: PUSH
53152: EMPTY
53153: LIST
53154: LIST
53155: PUSH
53156: EMPTY
53157: LIST
53158: LIST
53159: PPUSH
53160: CALL_OW 69
53164: IN
53165: AND
53166: IFFALSE 53291
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
53168: LD_ADDR_VAR 0 9
53172: PUSH
53173: LD_OWVAR 3
53177: PUSH
53178: LD_VAR 0 4
53182: PUSH
53183: LD_VAR 0 7
53187: ARRAY
53188: DIFF
53189: PPUSH
53190: LD_VAR 0 4
53194: PUSH
53195: LD_VAR 0 7
53199: ARRAY
53200: PPUSH
53201: CALL_OW 74
53205: ST_TO_ADDR
// if not k then
53206: LD_VAR 0 9
53210: NOT
53211: IFFALSE 53215
// continue ;
53213: GO 49656
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
53215: LD_VAR 0 9
53219: PUSH
53220: LD_INT 81
53222: PUSH
53223: LD_VAR 0 4
53227: PUSH
53228: LD_VAR 0 7
53232: ARRAY
53233: PPUSH
53234: CALL_OW 255
53238: PUSH
53239: EMPTY
53240: LIST
53241: LIST
53242: PPUSH
53243: CALL_OW 69
53247: IN
53248: PUSH
53249: LD_VAR 0 9
53253: PPUSH
53254: LD_VAR 0 4
53258: PUSH
53259: LD_VAR 0 7
53263: ARRAY
53264: PPUSH
53265: CALL_OW 296
53269: PUSH
53270: LD_INT 5
53272: LESS
53273: AND
53274: IFFALSE 53291
// ComAutodestruct ( group [ i ] ) ;
53276: LD_VAR 0 4
53280: PUSH
53281: LD_VAR 0 7
53285: ARRAY
53286: PPUSH
53287: CALL 47751 0 1
// end ; if f_attack_depot then
53291: LD_VAR 0 25
53295: IFFALSE 53407
// begin k := 6 ;
53297: LD_ADDR_VAR 0 9
53301: PUSH
53302: LD_INT 6
53304: ST_TO_ADDR
// if tmp < k then
53305: LD_VAR 0 14
53309: PUSH
53310: LD_VAR 0 9
53314: LESS
53315: IFFALSE 53327
// k := tmp ;
53317: LD_ADDR_VAR 0 9
53321: PUSH
53322: LD_VAR 0 14
53326: ST_TO_ADDR
// for j = 1 to k do
53327: LD_ADDR_VAR 0 8
53331: PUSH
53332: DOUBLE
53333: LD_INT 1
53335: DEC
53336: ST_TO_ADDR
53337: LD_VAR 0 9
53341: PUSH
53342: FOR_TO
53343: IFFALSE 53405
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
53345: LD_VAR 0 8
53349: PPUSH
53350: CALL_OW 266
53354: PUSH
53355: LD_INT 0
53357: PUSH
53358: LD_INT 1
53360: PUSH
53361: EMPTY
53362: LIST
53363: LIST
53364: IN
53365: IFFALSE 53403
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53367: LD_VAR 0 4
53371: PUSH
53372: LD_VAR 0 7
53376: ARRAY
53377: PPUSH
53378: LD_VAR 0 14
53382: PUSH
53383: LD_VAR 0 8
53387: ARRAY
53388: PPUSH
53389: CALL_OW 115
// attacking := true ;
53393: LD_ADDR_VAR 0 29
53397: PUSH
53398: LD_INT 1
53400: ST_TO_ADDR
// break ;
53401: GO 53405
// end ;
53403: GO 53342
53405: POP
53406: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
53407: LD_VAR 0 4
53411: PUSH
53412: LD_VAR 0 7
53416: ARRAY
53417: PPUSH
53418: CALL_OW 302
53422: PUSH
53423: LD_VAR 0 29
53427: NOT
53428: AND
53429: IFFALSE 53751
// begin if GetTag ( group [ i ] ) = 71 then
53431: LD_VAR 0 4
53435: PUSH
53436: LD_VAR 0 7
53440: ARRAY
53441: PPUSH
53442: CALL_OW 110
53446: PUSH
53447: LD_INT 71
53449: EQUAL
53450: IFFALSE 53491
// begin if HasTask ( group [ i ] ) then
53452: LD_VAR 0 4
53456: PUSH
53457: LD_VAR 0 7
53461: ARRAY
53462: PPUSH
53463: CALL_OW 314
53467: IFFALSE 53473
// continue else
53469: GO 49656
53471: GO 53491
// SetTag ( group [ i ] , 0 ) ;
53473: LD_VAR 0 4
53477: PUSH
53478: LD_VAR 0 7
53482: ARRAY
53483: PPUSH
53484: LD_INT 0
53486: PPUSH
53487: CALL_OW 109
// end ; k := 8 ;
53491: LD_ADDR_VAR 0 9
53495: PUSH
53496: LD_INT 8
53498: ST_TO_ADDR
// x := 0 ;
53499: LD_ADDR_VAR 0 10
53503: PUSH
53504: LD_INT 0
53506: ST_TO_ADDR
// if tmp < k then
53507: LD_VAR 0 14
53511: PUSH
53512: LD_VAR 0 9
53516: LESS
53517: IFFALSE 53529
// k := tmp ;
53519: LD_ADDR_VAR 0 9
53523: PUSH
53524: LD_VAR 0 14
53528: ST_TO_ADDR
// for j = 1 to k do
53529: LD_ADDR_VAR 0 8
53533: PUSH
53534: DOUBLE
53535: LD_INT 1
53537: DEC
53538: ST_TO_ADDR
53539: LD_VAR 0 9
53543: PUSH
53544: FOR_TO
53545: IFFALSE 53643
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
53547: LD_VAR 0 14
53551: PUSH
53552: LD_VAR 0 8
53556: ARRAY
53557: PPUSH
53558: CALL_OW 247
53562: PUSH
53563: LD_INT 1
53565: EQUAL
53566: PUSH
53567: LD_VAR 0 14
53571: PUSH
53572: LD_VAR 0 8
53576: ARRAY
53577: PPUSH
53578: CALL_OW 256
53582: PUSH
53583: LD_INT 250
53585: LESS
53586: PUSH
53587: LD_VAR 0 20
53591: AND
53592: PUSH
53593: LD_VAR 0 20
53597: NOT
53598: PUSH
53599: LD_VAR 0 14
53603: PUSH
53604: LD_VAR 0 8
53608: ARRAY
53609: PPUSH
53610: CALL_OW 256
53614: PUSH
53615: LD_INT 250
53617: GREATEREQUAL
53618: AND
53619: OR
53620: AND
53621: IFFALSE 53641
// begin x := tmp [ j ] ;
53623: LD_ADDR_VAR 0 10
53627: PUSH
53628: LD_VAR 0 14
53632: PUSH
53633: LD_VAR 0 8
53637: ARRAY
53638: ST_TO_ADDR
// break ;
53639: GO 53643
// end ;
53641: GO 53544
53643: POP
53644: POP
// if x then
53645: LD_VAR 0 10
53649: IFFALSE 53673
// ComAttackUnit ( group [ i ] , x ) else
53651: LD_VAR 0 4
53655: PUSH
53656: LD_VAR 0 7
53660: ARRAY
53661: PPUSH
53662: LD_VAR 0 10
53666: PPUSH
53667: CALL_OW 115
53671: GO 53697
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53673: LD_VAR 0 4
53677: PUSH
53678: LD_VAR 0 7
53682: ARRAY
53683: PPUSH
53684: LD_VAR 0 14
53688: PUSH
53689: LD_INT 1
53691: ARRAY
53692: PPUSH
53693: CALL_OW 115
// if not HasTask ( group [ i ] ) then
53697: LD_VAR 0 4
53701: PUSH
53702: LD_VAR 0 7
53706: ARRAY
53707: PPUSH
53708: CALL_OW 314
53712: NOT
53713: IFFALSE 53751
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
53715: LD_VAR 0 4
53719: PUSH
53720: LD_VAR 0 7
53724: ARRAY
53725: PPUSH
53726: LD_VAR 0 14
53730: PPUSH
53731: LD_VAR 0 4
53735: PUSH
53736: LD_VAR 0 7
53740: ARRAY
53741: PPUSH
53742: CALL_OW 74
53746: PPUSH
53747: CALL_OW 115
// end ; end ; end ;
53751: GO 49656
53753: POP
53754: POP
// wait ( 0 0$1 ) ;
53755: LD_INT 35
53757: PPUSH
53758: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
53762: LD_VAR 0 4
53766: PUSH
53767: EMPTY
53768: EQUAL
53769: PUSH
53770: LD_INT 81
53772: PUSH
53773: LD_VAR 0 35
53777: PUSH
53778: EMPTY
53779: LIST
53780: LIST
53781: PPUSH
53782: CALL_OW 69
53786: NOT
53787: OR
53788: IFFALSE 49641
// end ;
53790: LD_VAR 0 2
53794: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53795: LD_INT 0
53797: PPUSH
53798: PPUSH
53799: PPUSH
53800: PPUSH
// if not base_units then
53801: LD_VAR 0 1
53805: NOT
53806: IFFALSE 53810
// exit ;
53808: GO 53897
// result := false ;
53810: LD_ADDR_VAR 0 2
53814: PUSH
53815: LD_INT 0
53817: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53818: LD_ADDR_VAR 0 5
53822: PUSH
53823: LD_VAR 0 1
53827: PPUSH
53828: LD_INT 21
53830: PUSH
53831: LD_INT 3
53833: PUSH
53834: EMPTY
53835: LIST
53836: LIST
53837: PPUSH
53838: CALL_OW 72
53842: ST_TO_ADDR
// if not tmp then
53843: LD_VAR 0 5
53847: NOT
53848: IFFALSE 53852
// exit ;
53850: GO 53897
// for i in tmp do
53852: LD_ADDR_VAR 0 3
53856: PUSH
53857: LD_VAR 0 5
53861: PUSH
53862: FOR_IN
53863: IFFALSE 53895
// begin result := EnemyInRange ( i , 22 ) ;
53865: LD_ADDR_VAR 0 2
53869: PUSH
53870: LD_VAR 0 3
53874: PPUSH
53875: LD_INT 22
53877: PPUSH
53878: CALL 47434 0 2
53882: ST_TO_ADDR
// if result then
53883: LD_VAR 0 2
53887: IFFALSE 53893
// exit ;
53889: POP
53890: POP
53891: GO 53897
// end ;
53893: GO 53862
53895: POP
53896: POP
// end ;
53897: LD_VAR 0 2
53901: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
53902: LD_INT 0
53904: PPUSH
53905: PPUSH
// if not units then
53906: LD_VAR 0 1
53910: NOT
53911: IFFALSE 53915
// exit ;
53913: GO 53985
// result := [ ] ;
53915: LD_ADDR_VAR 0 3
53919: PUSH
53920: EMPTY
53921: ST_TO_ADDR
// for i in units do
53922: LD_ADDR_VAR 0 4
53926: PUSH
53927: LD_VAR 0 1
53931: PUSH
53932: FOR_IN
53933: IFFALSE 53983
// if GetTag ( i ) = tag then
53935: LD_VAR 0 4
53939: PPUSH
53940: CALL_OW 110
53944: PUSH
53945: LD_VAR 0 2
53949: EQUAL
53950: IFFALSE 53981
// result := Insert ( result , result + 1 , i ) ;
53952: LD_ADDR_VAR 0 3
53956: PUSH
53957: LD_VAR 0 3
53961: PPUSH
53962: LD_VAR 0 3
53966: PUSH
53967: LD_INT 1
53969: PLUS
53970: PPUSH
53971: LD_VAR 0 4
53975: PPUSH
53976: CALL_OW 2
53980: ST_TO_ADDR
53981: GO 53932
53983: POP
53984: POP
// end ;
53985: LD_VAR 0 3
53989: RET
// export function IsDriver ( un ) ; begin
53990: LD_INT 0
53992: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53993: LD_ADDR_VAR 0 2
53997: PUSH
53998: LD_VAR 0 1
54002: PUSH
54003: LD_INT 55
54005: PUSH
54006: EMPTY
54007: LIST
54008: PPUSH
54009: CALL_OW 69
54013: IN
54014: ST_TO_ADDR
// end ;
54015: LD_VAR 0 2
54019: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54020: LD_INT 0
54022: PPUSH
54023: PPUSH
// list := [ ] ;
54024: LD_ADDR_VAR 0 5
54028: PUSH
54029: EMPTY
54030: ST_TO_ADDR
// case d of 0 :
54031: LD_VAR 0 3
54035: PUSH
54036: LD_INT 0
54038: DOUBLE
54039: EQUAL
54040: IFTRUE 54044
54042: GO 54177
54044: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54045: LD_ADDR_VAR 0 5
54049: PUSH
54050: LD_VAR 0 1
54054: PUSH
54055: LD_INT 4
54057: MINUS
54058: PUSH
54059: LD_VAR 0 2
54063: PUSH
54064: LD_INT 4
54066: MINUS
54067: PUSH
54068: LD_INT 2
54070: PUSH
54071: EMPTY
54072: LIST
54073: LIST
54074: LIST
54075: PUSH
54076: LD_VAR 0 1
54080: PUSH
54081: LD_INT 3
54083: MINUS
54084: PUSH
54085: LD_VAR 0 2
54089: PUSH
54090: LD_INT 1
54092: PUSH
54093: EMPTY
54094: LIST
54095: LIST
54096: LIST
54097: PUSH
54098: LD_VAR 0 1
54102: PUSH
54103: LD_INT 4
54105: PLUS
54106: PUSH
54107: LD_VAR 0 2
54111: PUSH
54112: LD_INT 4
54114: PUSH
54115: EMPTY
54116: LIST
54117: LIST
54118: LIST
54119: PUSH
54120: LD_VAR 0 1
54124: PUSH
54125: LD_INT 3
54127: PLUS
54128: PUSH
54129: LD_VAR 0 2
54133: PUSH
54134: LD_INT 3
54136: PLUS
54137: PUSH
54138: LD_INT 5
54140: PUSH
54141: EMPTY
54142: LIST
54143: LIST
54144: LIST
54145: PUSH
54146: LD_VAR 0 1
54150: PUSH
54151: LD_VAR 0 2
54155: PUSH
54156: LD_INT 4
54158: PLUS
54159: PUSH
54160: LD_INT 0
54162: PUSH
54163: EMPTY
54164: LIST
54165: LIST
54166: LIST
54167: PUSH
54168: EMPTY
54169: LIST
54170: LIST
54171: LIST
54172: LIST
54173: LIST
54174: ST_TO_ADDR
// end ; 1 :
54175: GO 54875
54177: LD_INT 1
54179: DOUBLE
54180: EQUAL
54181: IFTRUE 54185
54183: GO 54318
54185: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54186: LD_ADDR_VAR 0 5
54190: PUSH
54191: LD_VAR 0 1
54195: PUSH
54196: LD_VAR 0 2
54200: PUSH
54201: LD_INT 4
54203: MINUS
54204: PUSH
54205: LD_INT 3
54207: PUSH
54208: EMPTY
54209: LIST
54210: LIST
54211: LIST
54212: PUSH
54213: LD_VAR 0 1
54217: PUSH
54218: LD_INT 3
54220: MINUS
54221: PUSH
54222: LD_VAR 0 2
54226: PUSH
54227: LD_INT 3
54229: MINUS
54230: PUSH
54231: LD_INT 2
54233: PUSH
54234: EMPTY
54235: LIST
54236: LIST
54237: LIST
54238: PUSH
54239: LD_VAR 0 1
54243: PUSH
54244: LD_INT 4
54246: MINUS
54247: PUSH
54248: LD_VAR 0 2
54252: PUSH
54253: LD_INT 1
54255: PUSH
54256: EMPTY
54257: LIST
54258: LIST
54259: LIST
54260: PUSH
54261: LD_VAR 0 1
54265: PUSH
54266: LD_VAR 0 2
54270: PUSH
54271: LD_INT 3
54273: PLUS
54274: PUSH
54275: LD_INT 0
54277: PUSH
54278: EMPTY
54279: LIST
54280: LIST
54281: LIST
54282: PUSH
54283: LD_VAR 0 1
54287: PUSH
54288: LD_INT 4
54290: PLUS
54291: PUSH
54292: LD_VAR 0 2
54296: PUSH
54297: LD_INT 4
54299: PLUS
54300: PUSH
54301: LD_INT 5
54303: PUSH
54304: EMPTY
54305: LIST
54306: LIST
54307: LIST
54308: PUSH
54309: EMPTY
54310: LIST
54311: LIST
54312: LIST
54313: LIST
54314: LIST
54315: ST_TO_ADDR
// end ; 2 :
54316: GO 54875
54318: LD_INT 2
54320: DOUBLE
54321: EQUAL
54322: IFTRUE 54326
54324: GO 54455
54326: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54327: LD_ADDR_VAR 0 5
54331: PUSH
54332: LD_VAR 0 1
54336: PUSH
54337: LD_VAR 0 2
54341: PUSH
54342: LD_INT 3
54344: MINUS
54345: PUSH
54346: LD_INT 3
54348: PUSH
54349: EMPTY
54350: LIST
54351: LIST
54352: LIST
54353: PUSH
54354: LD_VAR 0 1
54358: PUSH
54359: LD_INT 4
54361: PLUS
54362: PUSH
54363: LD_VAR 0 2
54367: PUSH
54368: LD_INT 4
54370: PUSH
54371: EMPTY
54372: LIST
54373: LIST
54374: LIST
54375: PUSH
54376: LD_VAR 0 1
54380: PUSH
54381: LD_VAR 0 2
54385: PUSH
54386: LD_INT 4
54388: PLUS
54389: PUSH
54390: LD_INT 0
54392: PUSH
54393: EMPTY
54394: LIST
54395: LIST
54396: LIST
54397: PUSH
54398: LD_VAR 0 1
54402: PUSH
54403: LD_INT 3
54405: MINUS
54406: PUSH
54407: LD_VAR 0 2
54411: PUSH
54412: LD_INT 1
54414: PUSH
54415: EMPTY
54416: LIST
54417: LIST
54418: LIST
54419: PUSH
54420: LD_VAR 0 1
54424: PUSH
54425: LD_INT 4
54427: MINUS
54428: PUSH
54429: LD_VAR 0 2
54433: PUSH
54434: LD_INT 4
54436: MINUS
54437: PUSH
54438: LD_INT 2
54440: PUSH
54441: EMPTY
54442: LIST
54443: LIST
54444: LIST
54445: PUSH
54446: EMPTY
54447: LIST
54448: LIST
54449: LIST
54450: LIST
54451: LIST
54452: ST_TO_ADDR
// end ; 3 :
54453: GO 54875
54455: LD_INT 3
54457: DOUBLE
54458: EQUAL
54459: IFTRUE 54463
54461: GO 54596
54463: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54464: LD_ADDR_VAR 0 5
54468: PUSH
54469: LD_VAR 0 1
54473: PUSH
54474: LD_INT 3
54476: PLUS
54477: PUSH
54478: LD_VAR 0 2
54482: PUSH
54483: LD_INT 4
54485: PUSH
54486: EMPTY
54487: LIST
54488: LIST
54489: LIST
54490: PUSH
54491: LD_VAR 0 1
54495: PUSH
54496: LD_INT 4
54498: PLUS
54499: PUSH
54500: LD_VAR 0 2
54504: PUSH
54505: LD_INT 4
54507: PLUS
54508: PUSH
54509: LD_INT 5
54511: PUSH
54512: EMPTY
54513: LIST
54514: LIST
54515: LIST
54516: PUSH
54517: LD_VAR 0 1
54521: PUSH
54522: LD_INT 4
54524: MINUS
54525: PUSH
54526: LD_VAR 0 2
54530: PUSH
54531: LD_INT 1
54533: PUSH
54534: EMPTY
54535: LIST
54536: LIST
54537: LIST
54538: PUSH
54539: LD_VAR 0 1
54543: PUSH
54544: LD_VAR 0 2
54548: PUSH
54549: LD_INT 4
54551: MINUS
54552: PUSH
54553: LD_INT 3
54555: PUSH
54556: EMPTY
54557: LIST
54558: LIST
54559: LIST
54560: PUSH
54561: LD_VAR 0 1
54565: PUSH
54566: LD_INT 3
54568: MINUS
54569: PUSH
54570: LD_VAR 0 2
54574: PUSH
54575: LD_INT 3
54577: MINUS
54578: PUSH
54579: LD_INT 2
54581: PUSH
54582: EMPTY
54583: LIST
54584: LIST
54585: LIST
54586: PUSH
54587: EMPTY
54588: LIST
54589: LIST
54590: LIST
54591: LIST
54592: LIST
54593: ST_TO_ADDR
// end ; 4 :
54594: GO 54875
54596: LD_INT 4
54598: DOUBLE
54599: EQUAL
54600: IFTRUE 54604
54602: GO 54737
54604: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54605: LD_ADDR_VAR 0 5
54609: PUSH
54610: LD_VAR 0 1
54614: PUSH
54615: LD_VAR 0 2
54619: PUSH
54620: LD_INT 4
54622: PLUS
54623: PUSH
54624: LD_INT 0
54626: PUSH
54627: EMPTY
54628: LIST
54629: LIST
54630: LIST
54631: PUSH
54632: LD_VAR 0 1
54636: PUSH
54637: LD_INT 3
54639: PLUS
54640: PUSH
54641: LD_VAR 0 2
54645: PUSH
54646: LD_INT 3
54648: PLUS
54649: PUSH
54650: LD_INT 5
54652: PUSH
54653: EMPTY
54654: LIST
54655: LIST
54656: LIST
54657: PUSH
54658: LD_VAR 0 1
54662: PUSH
54663: LD_INT 4
54665: PLUS
54666: PUSH
54667: LD_VAR 0 2
54671: PUSH
54672: LD_INT 4
54674: PUSH
54675: EMPTY
54676: LIST
54677: LIST
54678: LIST
54679: PUSH
54680: LD_VAR 0 1
54684: PUSH
54685: LD_VAR 0 2
54689: PUSH
54690: LD_INT 3
54692: MINUS
54693: PUSH
54694: LD_INT 3
54696: PUSH
54697: EMPTY
54698: LIST
54699: LIST
54700: LIST
54701: PUSH
54702: LD_VAR 0 1
54706: PUSH
54707: LD_INT 4
54709: MINUS
54710: PUSH
54711: LD_VAR 0 2
54715: PUSH
54716: LD_INT 4
54718: MINUS
54719: PUSH
54720: LD_INT 2
54722: PUSH
54723: EMPTY
54724: LIST
54725: LIST
54726: LIST
54727: PUSH
54728: EMPTY
54729: LIST
54730: LIST
54731: LIST
54732: LIST
54733: LIST
54734: ST_TO_ADDR
// end ; 5 :
54735: GO 54875
54737: LD_INT 5
54739: DOUBLE
54740: EQUAL
54741: IFTRUE 54745
54743: GO 54874
54745: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54746: LD_ADDR_VAR 0 5
54750: PUSH
54751: LD_VAR 0 1
54755: PUSH
54756: LD_INT 4
54758: MINUS
54759: PUSH
54760: LD_VAR 0 2
54764: PUSH
54765: LD_INT 1
54767: PUSH
54768: EMPTY
54769: LIST
54770: LIST
54771: LIST
54772: PUSH
54773: LD_VAR 0 1
54777: PUSH
54778: LD_VAR 0 2
54782: PUSH
54783: LD_INT 4
54785: MINUS
54786: PUSH
54787: LD_INT 3
54789: PUSH
54790: EMPTY
54791: LIST
54792: LIST
54793: LIST
54794: PUSH
54795: LD_VAR 0 1
54799: PUSH
54800: LD_INT 4
54802: PLUS
54803: PUSH
54804: LD_VAR 0 2
54808: PUSH
54809: LD_INT 4
54811: PLUS
54812: PUSH
54813: LD_INT 5
54815: PUSH
54816: EMPTY
54817: LIST
54818: LIST
54819: LIST
54820: PUSH
54821: LD_VAR 0 1
54825: PUSH
54826: LD_INT 3
54828: PLUS
54829: PUSH
54830: LD_VAR 0 2
54834: PUSH
54835: LD_INT 4
54837: PUSH
54838: EMPTY
54839: LIST
54840: LIST
54841: LIST
54842: PUSH
54843: LD_VAR 0 1
54847: PUSH
54848: LD_VAR 0 2
54852: PUSH
54853: LD_INT 3
54855: PLUS
54856: PUSH
54857: LD_INT 0
54859: PUSH
54860: EMPTY
54861: LIST
54862: LIST
54863: LIST
54864: PUSH
54865: EMPTY
54866: LIST
54867: LIST
54868: LIST
54869: LIST
54870: LIST
54871: ST_TO_ADDR
// end ; end ;
54872: GO 54875
54874: POP
// result := list ;
54875: LD_ADDR_VAR 0 4
54879: PUSH
54880: LD_VAR 0 5
54884: ST_TO_ADDR
// end ;
54885: LD_VAR 0 4
54889: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54890: LD_INT 0
54892: PPUSH
54893: PPUSH
54894: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54895: LD_VAR 0 1
54899: NOT
54900: PUSH
54901: LD_VAR 0 2
54905: PUSH
54906: LD_INT 1
54908: PUSH
54909: LD_INT 2
54911: PUSH
54912: LD_INT 3
54914: PUSH
54915: LD_INT 4
54917: PUSH
54918: EMPTY
54919: LIST
54920: LIST
54921: LIST
54922: LIST
54923: IN
54924: NOT
54925: OR
54926: IFFALSE 54930
// exit ;
54928: GO 55022
// tmp := [ ] ;
54930: LD_ADDR_VAR 0 5
54934: PUSH
54935: EMPTY
54936: ST_TO_ADDR
// for i in units do
54937: LD_ADDR_VAR 0 4
54941: PUSH
54942: LD_VAR 0 1
54946: PUSH
54947: FOR_IN
54948: IFFALSE 54991
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
54950: LD_ADDR_VAR 0 5
54954: PUSH
54955: LD_VAR 0 5
54959: PPUSH
54960: LD_VAR 0 5
54964: PUSH
54965: LD_INT 1
54967: PLUS
54968: PPUSH
54969: LD_VAR 0 4
54973: PPUSH
54974: LD_VAR 0 2
54978: PPUSH
54979: CALL_OW 259
54983: PPUSH
54984: CALL_OW 2
54988: ST_TO_ADDR
54989: GO 54947
54991: POP
54992: POP
// if not tmp then
54993: LD_VAR 0 5
54997: NOT
54998: IFFALSE 55002
// exit ;
55000: GO 55022
// result := SortListByListDesc ( units , tmp ) ;
55002: LD_ADDR_VAR 0 3
55006: PUSH
55007: LD_VAR 0 1
55011: PPUSH
55012: LD_VAR 0 5
55016: PPUSH
55017: CALL_OW 77
55021: ST_TO_ADDR
// end ;
55022: LD_VAR 0 3
55026: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55027: LD_INT 0
55029: PPUSH
55030: PPUSH
55031: PPUSH
// x := GetX ( building ) ;
55032: LD_ADDR_VAR 0 4
55036: PUSH
55037: LD_VAR 0 2
55041: PPUSH
55042: CALL_OW 250
55046: ST_TO_ADDR
// y := GetY ( building ) ;
55047: LD_ADDR_VAR 0 5
55051: PUSH
55052: LD_VAR 0 2
55056: PPUSH
55057: CALL_OW 251
55061: ST_TO_ADDR
// if GetTaskList ( unit ) then
55062: LD_VAR 0 1
55066: PPUSH
55067: CALL_OW 437
55071: IFFALSE 55166
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55073: LD_STRING e
55075: PUSH
55076: LD_VAR 0 1
55080: PPUSH
55081: CALL_OW 437
55085: PUSH
55086: LD_INT 1
55088: ARRAY
55089: PUSH
55090: LD_INT 1
55092: ARRAY
55093: EQUAL
55094: PUSH
55095: LD_VAR 0 4
55099: PUSH
55100: LD_VAR 0 1
55104: PPUSH
55105: CALL_OW 437
55109: PUSH
55110: LD_INT 1
55112: ARRAY
55113: PUSH
55114: LD_INT 2
55116: ARRAY
55117: EQUAL
55118: AND
55119: PUSH
55120: LD_VAR 0 5
55124: PUSH
55125: LD_VAR 0 1
55129: PPUSH
55130: CALL_OW 437
55134: PUSH
55135: LD_INT 1
55137: ARRAY
55138: PUSH
55139: LD_INT 3
55141: ARRAY
55142: EQUAL
55143: AND
55144: IFFALSE 55156
// result := true else
55146: LD_ADDR_VAR 0 3
55150: PUSH
55151: LD_INT 1
55153: ST_TO_ADDR
55154: GO 55164
// result := false ;
55156: LD_ADDR_VAR 0 3
55160: PUSH
55161: LD_INT 0
55163: ST_TO_ADDR
// end else
55164: GO 55174
// result := false ;
55166: LD_ADDR_VAR 0 3
55170: PUSH
55171: LD_INT 0
55173: ST_TO_ADDR
// end ;
55174: LD_VAR 0 3
55178: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55179: LD_INT 0
55181: PPUSH
55182: PPUSH
55183: PPUSH
55184: PPUSH
// if not unit or not area then
55185: LD_VAR 0 1
55189: NOT
55190: PUSH
55191: LD_VAR 0 2
55195: NOT
55196: OR
55197: IFFALSE 55201
// exit ;
55199: GO 55365
// tmp := AreaToList ( area , i ) ;
55201: LD_ADDR_VAR 0 6
55205: PUSH
55206: LD_VAR 0 2
55210: PPUSH
55211: LD_VAR 0 5
55215: PPUSH
55216: CALL_OW 517
55220: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55221: LD_ADDR_VAR 0 5
55225: PUSH
55226: DOUBLE
55227: LD_INT 1
55229: DEC
55230: ST_TO_ADDR
55231: LD_VAR 0 6
55235: PUSH
55236: LD_INT 1
55238: ARRAY
55239: PUSH
55240: FOR_TO
55241: IFFALSE 55363
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55243: LD_ADDR_VAR 0 7
55247: PUSH
55248: LD_VAR 0 6
55252: PUSH
55253: LD_INT 1
55255: ARRAY
55256: PUSH
55257: LD_VAR 0 5
55261: ARRAY
55262: PUSH
55263: LD_VAR 0 6
55267: PUSH
55268: LD_INT 2
55270: ARRAY
55271: PUSH
55272: LD_VAR 0 5
55276: ARRAY
55277: PUSH
55278: EMPTY
55279: LIST
55280: LIST
55281: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
55282: LD_VAR 0 7
55286: PUSH
55287: LD_INT 1
55289: ARRAY
55290: PPUSH
55291: LD_VAR 0 7
55295: PUSH
55296: LD_INT 2
55298: ARRAY
55299: PPUSH
55300: CALL_OW 428
55304: PUSH
55305: LD_INT 0
55307: EQUAL
55308: IFFALSE 55361
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55310: LD_VAR 0 1
55314: PPUSH
55315: LD_VAR 0 7
55319: PUSH
55320: LD_INT 1
55322: ARRAY
55323: PPUSH
55324: LD_VAR 0 7
55328: PUSH
55329: LD_INT 2
55331: ARRAY
55332: PPUSH
55333: LD_VAR 0 3
55337: PPUSH
55338: CALL_OW 48
// result := IsPlaced ( unit ) ;
55342: LD_ADDR_VAR 0 4
55346: PUSH
55347: LD_VAR 0 1
55351: PPUSH
55352: CALL_OW 305
55356: ST_TO_ADDR
// exit ;
55357: POP
55358: POP
55359: GO 55365
// end ; end ;
55361: GO 55240
55363: POP
55364: POP
// end ;
55365: LD_VAR 0 4
55369: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55370: LD_INT 0
55372: PPUSH
55373: PPUSH
55374: PPUSH
// if not side or side > 8 then
55375: LD_VAR 0 1
55379: NOT
55380: PUSH
55381: LD_VAR 0 1
55385: PUSH
55386: LD_INT 8
55388: GREATER
55389: OR
55390: IFFALSE 55394
// exit ;
55392: GO 55581
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55394: LD_ADDR_VAR 0 4
55398: PUSH
55399: LD_INT 22
55401: PUSH
55402: LD_VAR 0 1
55406: PUSH
55407: EMPTY
55408: LIST
55409: LIST
55410: PUSH
55411: LD_INT 21
55413: PUSH
55414: LD_INT 3
55416: PUSH
55417: EMPTY
55418: LIST
55419: LIST
55420: PUSH
55421: EMPTY
55422: LIST
55423: LIST
55424: PPUSH
55425: CALL_OW 69
55429: ST_TO_ADDR
// if not tmp then
55430: LD_VAR 0 4
55434: NOT
55435: IFFALSE 55439
// exit ;
55437: GO 55581
// enable_addtolog := true ;
55439: LD_ADDR_OWVAR 81
55443: PUSH
55444: LD_INT 1
55446: ST_TO_ADDR
// AddToLog ( [ ) ;
55447: LD_STRING [
55449: PPUSH
55450: CALL_OW 561
// for i in tmp do
55454: LD_ADDR_VAR 0 3
55458: PUSH
55459: LD_VAR 0 4
55463: PUSH
55464: FOR_IN
55465: IFFALSE 55572
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55467: LD_STRING [
55469: PUSH
55470: LD_VAR 0 3
55474: PPUSH
55475: CALL_OW 266
55479: STR
55480: PUSH
55481: LD_STRING , 
55483: STR
55484: PUSH
55485: LD_VAR 0 3
55489: PPUSH
55490: CALL_OW 250
55494: STR
55495: PUSH
55496: LD_STRING , 
55498: STR
55499: PUSH
55500: LD_VAR 0 3
55504: PPUSH
55505: CALL_OW 251
55509: STR
55510: PUSH
55511: LD_STRING , 
55513: STR
55514: PUSH
55515: LD_VAR 0 3
55519: PPUSH
55520: CALL_OW 254
55524: STR
55525: PUSH
55526: LD_STRING , 
55528: STR
55529: PUSH
55530: LD_VAR 0 3
55534: PPUSH
55535: LD_INT 1
55537: PPUSH
55538: CALL_OW 268
55542: STR
55543: PUSH
55544: LD_STRING , 
55546: STR
55547: PUSH
55548: LD_VAR 0 3
55552: PPUSH
55553: LD_INT 2
55555: PPUSH
55556: CALL_OW 268
55560: STR
55561: PUSH
55562: LD_STRING ],
55564: STR
55565: PPUSH
55566: CALL_OW 561
// end ;
55570: GO 55464
55572: POP
55573: POP
// AddToLog ( ]; ) ;
55574: LD_STRING ];
55576: PPUSH
55577: CALL_OW 561
// end ;
55581: LD_VAR 0 2
55585: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55586: LD_INT 0
55588: PPUSH
55589: PPUSH
55590: PPUSH
55591: PPUSH
55592: PPUSH
// if not area or not rate or not max then
55593: LD_VAR 0 1
55597: NOT
55598: PUSH
55599: LD_VAR 0 2
55603: NOT
55604: OR
55605: PUSH
55606: LD_VAR 0 4
55610: NOT
55611: OR
55612: IFFALSE 55616
// exit ;
55614: GO 55808
// while 1 do
55616: LD_INT 1
55618: IFFALSE 55808
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55620: LD_ADDR_VAR 0 9
55624: PUSH
55625: LD_VAR 0 1
55629: PPUSH
55630: LD_INT 1
55632: PPUSH
55633: CALL_OW 287
55637: PUSH
55638: LD_INT 10
55640: MUL
55641: ST_TO_ADDR
// r := rate / 10 ;
55642: LD_ADDR_VAR 0 7
55646: PUSH
55647: LD_VAR 0 2
55651: PUSH
55652: LD_INT 10
55654: DIVREAL
55655: ST_TO_ADDR
// time := 1 1$00 ;
55656: LD_ADDR_VAR 0 8
55660: PUSH
55661: LD_INT 2100
55663: ST_TO_ADDR
// if amount < min then
55664: LD_VAR 0 9
55668: PUSH
55669: LD_VAR 0 3
55673: LESS
55674: IFFALSE 55692
// r := r * 2 else
55676: LD_ADDR_VAR 0 7
55680: PUSH
55681: LD_VAR 0 7
55685: PUSH
55686: LD_INT 2
55688: MUL
55689: ST_TO_ADDR
55690: GO 55718
// if amount > max then
55692: LD_VAR 0 9
55696: PUSH
55697: LD_VAR 0 4
55701: GREATER
55702: IFFALSE 55718
// r := r / 2 ;
55704: LD_ADDR_VAR 0 7
55708: PUSH
55709: LD_VAR 0 7
55713: PUSH
55714: LD_INT 2
55716: DIVREAL
55717: ST_TO_ADDR
// time := time / r ;
55718: LD_ADDR_VAR 0 8
55722: PUSH
55723: LD_VAR 0 8
55727: PUSH
55728: LD_VAR 0 7
55732: DIVREAL
55733: ST_TO_ADDR
// if time < 0 then
55734: LD_VAR 0 8
55738: PUSH
55739: LD_INT 0
55741: LESS
55742: IFFALSE 55759
// time := time * - 1 ;
55744: LD_ADDR_VAR 0 8
55748: PUSH
55749: LD_VAR 0 8
55753: PUSH
55754: LD_INT 1
55756: NEG
55757: MUL
55758: ST_TO_ADDR
// wait ( time ) ;
55759: LD_VAR 0 8
55763: PPUSH
55764: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
55768: LD_INT 35
55770: PPUSH
55771: LD_INT 875
55773: PPUSH
55774: CALL_OW 12
55778: PPUSH
55779: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55783: LD_INT 1
55785: PPUSH
55786: LD_INT 5
55788: PPUSH
55789: CALL_OW 12
55793: PPUSH
55794: LD_VAR 0 1
55798: PPUSH
55799: LD_INT 1
55801: PPUSH
55802: CALL_OW 55
// end ;
55806: GO 55616
// end ;
55808: LD_VAR 0 5
55812: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55813: LD_INT 0
55815: PPUSH
55816: PPUSH
55817: PPUSH
55818: PPUSH
55819: PPUSH
55820: PPUSH
55821: PPUSH
55822: PPUSH
// if not turrets or not factories then
55823: LD_VAR 0 1
55827: NOT
55828: PUSH
55829: LD_VAR 0 2
55833: NOT
55834: OR
55835: IFFALSE 55839
// exit ;
55837: GO 56146
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55839: LD_ADDR_VAR 0 10
55843: PUSH
55844: LD_INT 5
55846: PUSH
55847: LD_INT 6
55849: PUSH
55850: EMPTY
55851: LIST
55852: LIST
55853: PUSH
55854: LD_INT 2
55856: PUSH
55857: LD_INT 4
55859: PUSH
55860: EMPTY
55861: LIST
55862: LIST
55863: PUSH
55864: LD_INT 3
55866: PUSH
55867: LD_INT 5
55869: PUSH
55870: EMPTY
55871: LIST
55872: LIST
55873: PUSH
55874: EMPTY
55875: LIST
55876: LIST
55877: LIST
55878: PUSH
55879: LD_INT 24
55881: PUSH
55882: LD_INT 25
55884: PUSH
55885: EMPTY
55886: LIST
55887: LIST
55888: PUSH
55889: LD_INT 23
55891: PUSH
55892: LD_INT 27
55894: PUSH
55895: EMPTY
55896: LIST
55897: LIST
55898: PUSH
55899: EMPTY
55900: LIST
55901: LIST
55902: PUSH
55903: LD_INT 42
55905: PUSH
55906: LD_INT 43
55908: PUSH
55909: EMPTY
55910: LIST
55911: LIST
55912: PUSH
55913: LD_INT 44
55915: PUSH
55916: LD_INT 46
55918: PUSH
55919: EMPTY
55920: LIST
55921: LIST
55922: PUSH
55923: LD_INT 45
55925: PUSH
55926: LD_INT 47
55928: PUSH
55929: EMPTY
55930: LIST
55931: LIST
55932: PUSH
55933: EMPTY
55934: LIST
55935: LIST
55936: LIST
55937: PUSH
55938: EMPTY
55939: LIST
55940: LIST
55941: LIST
55942: ST_TO_ADDR
// result := [ ] ;
55943: LD_ADDR_VAR 0 3
55947: PUSH
55948: EMPTY
55949: ST_TO_ADDR
// for i in turrets do
55950: LD_ADDR_VAR 0 4
55954: PUSH
55955: LD_VAR 0 1
55959: PUSH
55960: FOR_IN
55961: IFFALSE 56144
// begin nat := GetNation ( i ) ;
55963: LD_ADDR_VAR 0 7
55967: PUSH
55968: LD_VAR 0 4
55972: PPUSH
55973: CALL_OW 248
55977: ST_TO_ADDR
// weapon := 0 ;
55978: LD_ADDR_VAR 0 8
55982: PUSH
55983: LD_INT 0
55985: ST_TO_ADDR
// if not nat then
55986: LD_VAR 0 7
55990: NOT
55991: IFFALSE 55995
// continue ;
55993: GO 55960
// for j in list [ nat ] do
55995: LD_ADDR_VAR 0 5
55999: PUSH
56000: LD_VAR 0 10
56004: PUSH
56005: LD_VAR 0 7
56009: ARRAY
56010: PUSH
56011: FOR_IN
56012: IFFALSE 56053
// if GetBWeapon ( i ) = j [ 1 ] then
56014: LD_VAR 0 4
56018: PPUSH
56019: CALL_OW 269
56023: PUSH
56024: LD_VAR 0 5
56028: PUSH
56029: LD_INT 1
56031: ARRAY
56032: EQUAL
56033: IFFALSE 56051
// begin weapon := j [ 2 ] ;
56035: LD_ADDR_VAR 0 8
56039: PUSH
56040: LD_VAR 0 5
56044: PUSH
56045: LD_INT 2
56047: ARRAY
56048: ST_TO_ADDR
// break ;
56049: GO 56053
// end ;
56051: GO 56011
56053: POP
56054: POP
// if not weapon then
56055: LD_VAR 0 8
56059: NOT
56060: IFFALSE 56064
// continue ;
56062: GO 55960
// for k in factories do
56064: LD_ADDR_VAR 0 6
56068: PUSH
56069: LD_VAR 0 2
56073: PUSH
56074: FOR_IN
56075: IFFALSE 56140
// begin weapons := AvailableWeaponList ( k ) ;
56077: LD_ADDR_VAR 0 9
56081: PUSH
56082: LD_VAR 0 6
56086: PPUSH
56087: CALL_OW 478
56091: ST_TO_ADDR
// if not weapons then
56092: LD_VAR 0 9
56096: NOT
56097: IFFALSE 56101
// continue ;
56099: GO 56074
// if weapon in weapons then
56101: LD_VAR 0 8
56105: PUSH
56106: LD_VAR 0 9
56110: IN
56111: IFFALSE 56138
// begin result := [ i , weapon ] ;
56113: LD_ADDR_VAR 0 3
56117: PUSH
56118: LD_VAR 0 4
56122: PUSH
56123: LD_VAR 0 8
56127: PUSH
56128: EMPTY
56129: LIST
56130: LIST
56131: ST_TO_ADDR
// exit ;
56132: POP
56133: POP
56134: POP
56135: POP
56136: GO 56146
// end ; end ;
56138: GO 56074
56140: POP
56141: POP
// end ;
56142: GO 55960
56144: POP
56145: POP
// end ;
56146: LD_VAR 0 3
56150: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56151: LD_INT 0
56153: PPUSH
// if not side or side > 8 then
56154: LD_VAR 0 3
56158: NOT
56159: PUSH
56160: LD_VAR 0 3
56164: PUSH
56165: LD_INT 8
56167: GREATER
56168: OR
56169: IFFALSE 56173
// exit ;
56171: GO 56232
// if not range then
56173: LD_VAR 0 4
56177: NOT
56178: IFFALSE 56189
// range := - 12 ;
56180: LD_ADDR_VAR 0 4
56184: PUSH
56185: LD_INT 12
56187: NEG
56188: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56189: LD_VAR 0 1
56193: PPUSH
56194: LD_VAR 0 2
56198: PPUSH
56199: LD_VAR 0 3
56203: PPUSH
56204: LD_VAR 0 4
56208: PPUSH
56209: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56213: LD_VAR 0 1
56217: PPUSH
56218: LD_VAR 0 2
56222: PPUSH
56223: LD_VAR 0 3
56227: PPUSH
56228: CALL_OW 331
// end ;
56232: LD_VAR 0 5
56236: RET
// export function Video ( mode ) ; begin
56237: LD_INT 0
56239: PPUSH
// ingame_video = mode ;
56240: LD_ADDR_OWVAR 52
56244: PUSH
56245: LD_VAR 0 1
56249: ST_TO_ADDR
// interface_hidden = mode ;
56250: LD_ADDR_OWVAR 54
56254: PUSH
56255: LD_VAR 0 1
56259: ST_TO_ADDR
// end ;
56260: LD_VAR 0 2
56264: RET
// export function Join ( array , element ) ; begin
56265: LD_INT 0
56267: PPUSH
// result := array ^ element ;
56268: LD_ADDR_VAR 0 3
56272: PUSH
56273: LD_VAR 0 1
56277: PUSH
56278: LD_VAR 0 2
56282: ADD
56283: ST_TO_ADDR
// end ;
56284: LD_VAR 0 3
56288: RET
// export function JoinUnion ( array , element ) ; begin
56289: LD_INT 0
56291: PPUSH
// result := array union element ;
56292: LD_ADDR_VAR 0 3
56296: PUSH
56297: LD_VAR 0 1
56301: PUSH
56302: LD_VAR 0 2
56306: UNION
56307: ST_TO_ADDR
// end ;
56308: LD_VAR 0 3
56312: RET
// export function GetBehemoths ( side ) ; begin
56313: LD_INT 0
56315: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
56316: LD_ADDR_VAR 0 2
56320: PUSH
56321: LD_INT 22
56323: PUSH
56324: LD_VAR 0 1
56328: PUSH
56329: EMPTY
56330: LIST
56331: LIST
56332: PUSH
56333: LD_INT 31
56335: PUSH
56336: LD_INT 25
56338: PUSH
56339: EMPTY
56340: LIST
56341: LIST
56342: PUSH
56343: EMPTY
56344: LIST
56345: LIST
56346: PPUSH
56347: CALL_OW 69
56351: ST_TO_ADDR
// end ;
56352: LD_VAR 0 2
56356: RET
// export function Shuffle ( array ) ; var i , index ; begin
56357: LD_INT 0
56359: PPUSH
56360: PPUSH
56361: PPUSH
// result := [ ] ;
56362: LD_ADDR_VAR 0 2
56366: PUSH
56367: EMPTY
56368: ST_TO_ADDR
// if not array then
56369: LD_VAR 0 1
56373: NOT
56374: IFFALSE 56378
// exit ;
56376: GO 56477
// Randomize ;
56378: CALL_OW 10
// for i = array downto 1 do
56382: LD_ADDR_VAR 0 3
56386: PUSH
56387: DOUBLE
56388: LD_VAR 0 1
56392: INC
56393: ST_TO_ADDR
56394: LD_INT 1
56396: PUSH
56397: FOR_DOWNTO
56398: IFFALSE 56475
// begin index := rand ( 1 , array ) ;
56400: LD_ADDR_VAR 0 4
56404: PUSH
56405: LD_INT 1
56407: PPUSH
56408: LD_VAR 0 1
56412: PPUSH
56413: CALL_OW 12
56417: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56418: LD_ADDR_VAR 0 2
56422: PUSH
56423: LD_VAR 0 2
56427: PPUSH
56428: LD_VAR 0 2
56432: PUSH
56433: LD_INT 1
56435: PLUS
56436: PPUSH
56437: LD_VAR 0 1
56441: PUSH
56442: LD_VAR 0 4
56446: ARRAY
56447: PPUSH
56448: CALL_OW 2
56452: ST_TO_ADDR
// array := Delete ( array , index ) ;
56453: LD_ADDR_VAR 0 1
56457: PUSH
56458: LD_VAR 0 1
56462: PPUSH
56463: LD_VAR 0 4
56467: PPUSH
56468: CALL_OW 3
56472: ST_TO_ADDR
// end ;
56473: GO 56397
56475: POP
56476: POP
// end ; end_of_file
56477: LD_VAR 0 2
56481: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
56482: LD_INT 0
56484: PPUSH
56485: PPUSH
// skirmish := false ;
56486: LD_ADDR_EXP 56
56490: PUSH
56491: LD_INT 0
56493: ST_TO_ADDR
// debug_mc := false ;
56494: LD_ADDR_EXP 57
56498: PUSH
56499: LD_INT 0
56501: ST_TO_ADDR
// mc_bases := [ ] ;
56502: LD_ADDR_EXP 58
56506: PUSH
56507: EMPTY
56508: ST_TO_ADDR
// mc_sides := [ ] ;
56509: LD_ADDR_EXP 84
56513: PUSH
56514: EMPTY
56515: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
56516: LD_ADDR_EXP 59
56520: PUSH
56521: EMPTY
56522: ST_TO_ADDR
// mc_building_repairs := [ ] ;
56523: LD_ADDR_EXP 60
56527: PUSH
56528: EMPTY
56529: ST_TO_ADDR
// mc_need_heal := [ ] ;
56530: LD_ADDR_EXP 61
56534: PUSH
56535: EMPTY
56536: ST_TO_ADDR
// mc_healers := [ ] ;
56537: LD_ADDR_EXP 62
56541: PUSH
56542: EMPTY
56543: ST_TO_ADDR
// mc_build_list := [ ] ;
56544: LD_ADDR_EXP 63
56548: PUSH
56549: EMPTY
56550: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
56551: LD_ADDR_EXP 90
56555: PUSH
56556: EMPTY
56557: ST_TO_ADDR
// mc_builders := [ ] ;
56558: LD_ADDR_EXP 64
56562: PUSH
56563: EMPTY
56564: ST_TO_ADDR
// mc_construct_list := [ ] ;
56565: LD_ADDR_EXP 65
56569: PUSH
56570: EMPTY
56571: ST_TO_ADDR
// mc_turret_list := [ ] ;
56572: LD_ADDR_EXP 66
56576: PUSH
56577: EMPTY
56578: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
56579: LD_ADDR_EXP 67
56583: PUSH
56584: EMPTY
56585: ST_TO_ADDR
// mc_miners := [ ] ;
56586: LD_ADDR_EXP 72
56590: PUSH
56591: EMPTY
56592: ST_TO_ADDR
// mc_mines := [ ] ;
56593: LD_ADDR_EXP 71
56597: PUSH
56598: EMPTY
56599: ST_TO_ADDR
// mc_minefields := [ ] ;
56600: LD_ADDR_EXP 73
56604: PUSH
56605: EMPTY
56606: ST_TO_ADDR
// mc_crates := [ ] ;
56607: LD_ADDR_EXP 74
56611: PUSH
56612: EMPTY
56613: ST_TO_ADDR
// mc_crates_collector := [ ] ;
56614: LD_ADDR_EXP 75
56618: PUSH
56619: EMPTY
56620: ST_TO_ADDR
// mc_crates_area := [ ] ;
56621: LD_ADDR_EXP 76
56625: PUSH
56626: EMPTY
56627: ST_TO_ADDR
// mc_vehicles := [ ] ;
56628: LD_ADDR_EXP 77
56632: PUSH
56633: EMPTY
56634: ST_TO_ADDR
// mc_attack := [ ] ;
56635: LD_ADDR_EXP 78
56639: PUSH
56640: EMPTY
56641: ST_TO_ADDR
// mc_produce := [ ] ;
56642: LD_ADDR_EXP 79
56646: PUSH
56647: EMPTY
56648: ST_TO_ADDR
// mc_defender := [ ] ;
56649: LD_ADDR_EXP 80
56653: PUSH
56654: EMPTY
56655: ST_TO_ADDR
// mc_parking := [ ] ;
56656: LD_ADDR_EXP 82
56660: PUSH
56661: EMPTY
56662: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
56663: LD_ADDR_EXP 68
56667: PUSH
56668: EMPTY
56669: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
56670: LD_ADDR_EXP 70
56674: PUSH
56675: EMPTY
56676: ST_TO_ADDR
// mc_scan := [ ] ;
56677: LD_ADDR_EXP 81
56681: PUSH
56682: EMPTY
56683: ST_TO_ADDR
// mc_scan_area := [ ] ;
56684: LD_ADDR_EXP 83
56688: PUSH
56689: EMPTY
56690: ST_TO_ADDR
// mc_tech := [ ] ;
56691: LD_ADDR_EXP 85
56695: PUSH
56696: EMPTY
56697: ST_TO_ADDR
// mc_class := [ ] ;
56698: LD_ADDR_EXP 99
56702: PUSH
56703: EMPTY
56704: ST_TO_ADDR
// mc_class_case_use := [ ] ;
56705: LD_ADDR_EXP 100
56709: PUSH
56710: EMPTY
56711: ST_TO_ADDR
// end ;
56712: LD_VAR 0 1
56716: RET
// export function MC_Kill ( base ) ; begin
56717: LD_INT 0
56719: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
56720: LD_ADDR_EXP 58
56724: PUSH
56725: LD_EXP 58
56729: PPUSH
56730: LD_VAR 0 1
56734: PPUSH
56735: EMPTY
56736: PPUSH
56737: CALL_OW 1
56741: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56742: LD_ADDR_EXP 59
56746: PUSH
56747: LD_EXP 59
56751: PPUSH
56752: LD_VAR 0 1
56756: PPUSH
56757: EMPTY
56758: PPUSH
56759: CALL_OW 1
56763: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56764: LD_ADDR_EXP 60
56768: PUSH
56769: LD_EXP 60
56773: PPUSH
56774: LD_VAR 0 1
56778: PPUSH
56779: EMPTY
56780: PPUSH
56781: CALL_OW 1
56785: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56786: LD_ADDR_EXP 61
56790: PUSH
56791: LD_EXP 61
56795: PPUSH
56796: LD_VAR 0 1
56800: PPUSH
56801: EMPTY
56802: PPUSH
56803: CALL_OW 1
56807: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56808: LD_ADDR_EXP 62
56812: PUSH
56813: LD_EXP 62
56817: PPUSH
56818: LD_VAR 0 1
56822: PPUSH
56823: EMPTY
56824: PPUSH
56825: CALL_OW 1
56829: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56830: LD_ADDR_EXP 63
56834: PUSH
56835: LD_EXP 63
56839: PPUSH
56840: LD_VAR 0 1
56844: PPUSH
56845: EMPTY
56846: PPUSH
56847: CALL_OW 1
56851: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56852: LD_ADDR_EXP 64
56856: PUSH
56857: LD_EXP 64
56861: PPUSH
56862: LD_VAR 0 1
56866: PPUSH
56867: EMPTY
56868: PPUSH
56869: CALL_OW 1
56873: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56874: LD_ADDR_EXP 65
56878: PUSH
56879: LD_EXP 65
56883: PPUSH
56884: LD_VAR 0 1
56888: PPUSH
56889: EMPTY
56890: PPUSH
56891: CALL_OW 1
56895: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56896: LD_ADDR_EXP 66
56900: PUSH
56901: LD_EXP 66
56905: PPUSH
56906: LD_VAR 0 1
56910: PPUSH
56911: EMPTY
56912: PPUSH
56913: CALL_OW 1
56917: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56918: LD_ADDR_EXP 67
56922: PUSH
56923: LD_EXP 67
56927: PPUSH
56928: LD_VAR 0 1
56932: PPUSH
56933: EMPTY
56934: PPUSH
56935: CALL_OW 1
56939: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56940: LD_ADDR_EXP 68
56944: PUSH
56945: LD_EXP 68
56949: PPUSH
56950: LD_VAR 0 1
56954: PPUSH
56955: EMPTY
56956: PPUSH
56957: CALL_OW 1
56961: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56962: LD_ADDR_EXP 69
56966: PUSH
56967: LD_EXP 69
56971: PPUSH
56972: LD_VAR 0 1
56976: PPUSH
56977: LD_INT 0
56979: PPUSH
56980: CALL_OW 1
56984: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56985: LD_ADDR_EXP 70
56989: PUSH
56990: LD_EXP 70
56994: PPUSH
56995: LD_VAR 0 1
56999: PPUSH
57000: EMPTY
57001: PPUSH
57002: CALL_OW 1
57006: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57007: LD_ADDR_EXP 71
57011: PUSH
57012: LD_EXP 71
57016: PPUSH
57017: LD_VAR 0 1
57021: PPUSH
57022: EMPTY
57023: PPUSH
57024: CALL_OW 1
57028: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57029: LD_ADDR_EXP 72
57033: PUSH
57034: LD_EXP 72
57038: PPUSH
57039: LD_VAR 0 1
57043: PPUSH
57044: EMPTY
57045: PPUSH
57046: CALL_OW 1
57050: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57051: LD_ADDR_EXP 73
57055: PUSH
57056: LD_EXP 73
57060: PPUSH
57061: LD_VAR 0 1
57065: PPUSH
57066: EMPTY
57067: PPUSH
57068: CALL_OW 1
57072: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57073: LD_ADDR_EXP 74
57077: PUSH
57078: LD_EXP 74
57082: PPUSH
57083: LD_VAR 0 1
57087: PPUSH
57088: EMPTY
57089: PPUSH
57090: CALL_OW 1
57094: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57095: LD_ADDR_EXP 75
57099: PUSH
57100: LD_EXP 75
57104: PPUSH
57105: LD_VAR 0 1
57109: PPUSH
57110: EMPTY
57111: PPUSH
57112: CALL_OW 1
57116: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57117: LD_ADDR_EXP 76
57121: PUSH
57122: LD_EXP 76
57126: PPUSH
57127: LD_VAR 0 1
57131: PPUSH
57132: EMPTY
57133: PPUSH
57134: CALL_OW 1
57138: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57139: LD_ADDR_EXP 77
57143: PUSH
57144: LD_EXP 77
57148: PPUSH
57149: LD_VAR 0 1
57153: PPUSH
57154: EMPTY
57155: PPUSH
57156: CALL_OW 1
57160: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57161: LD_ADDR_EXP 78
57165: PUSH
57166: LD_EXP 78
57170: PPUSH
57171: LD_VAR 0 1
57175: PPUSH
57176: EMPTY
57177: PPUSH
57178: CALL_OW 1
57182: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57183: LD_ADDR_EXP 79
57187: PUSH
57188: LD_EXP 79
57192: PPUSH
57193: LD_VAR 0 1
57197: PPUSH
57198: EMPTY
57199: PPUSH
57200: CALL_OW 1
57204: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57205: LD_ADDR_EXP 80
57209: PUSH
57210: LD_EXP 80
57214: PPUSH
57215: LD_VAR 0 1
57219: PPUSH
57220: EMPTY
57221: PPUSH
57222: CALL_OW 1
57226: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57227: LD_ADDR_EXP 81
57231: PUSH
57232: LD_EXP 81
57236: PPUSH
57237: LD_VAR 0 1
57241: PPUSH
57242: EMPTY
57243: PPUSH
57244: CALL_OW 1
57248: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57249: LD_ADDR_EXP 82
57253: PUSH
57254: LD_EXP 82
57258: PPUSH
57259: LD_VAR 0 1
57263: PPUSH
57264: EMPTY
57265: PPUSH
57266: CALL_OW 1
57270: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57271: LD_ADDR_EXP 83
57275: PUSH
57276: LD_EXP 83
57280: PPUSH
57281: LD_VAR 0 1
57285: PPUSH
57286: EMPTY
57287: PPUSH
57288: CALL_OW 1
57292: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57293: LD_ADDR_EXP 85
57297: PUSH
57298: LD_EXP 85
57302: PPUSH
57303: LD_VAR 0 1
57307: PPUSH
57308: EMPTY
57309: PPUSH
57310: CALL_OW 1
57314: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57315: LD_ADDR_EXP 87
57319: PUSH
57320: LD_EXP 87
57324: PPUSH
57325: LD_VAR 0 1
57329: PPUSH
57330: EMPTY
57331: PPUSH
57332: CALL_OW 1
57336: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57337: LD_ADDR_EXP 88
57341: PUSH
57342: LD_EXP 88
57346: PPUSH
57347: LD_VAR 0 1
57351: PPUSH
57352: EMPTY
57353: PPUSH
57354: CALL_OW 1
57358: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57359: LD_ADDR_EXP 89
57363: PUSH
57364: LD_EXP 89
57368: PPUSH
57369: LD_VAR 0 1
57373: PPUSH
57374: EMPTY
57375: PPUSH
57376: CALL_OW 1
57380: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57381: LD_ADDR_EXP 90
57385: PUSH
57386: LD_EXP 90
57390: PPUSH
57391: LD_VAR 0 1
57395: PPUSH
57396: EMPTY
57397: PPUSH
57398: CALL_OW 1
57402: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57403: LD_ADDR_EXP 91
57407: PUSH
57408: LD_EXP 91
57412: PPUSH
57413: LD_VAR 0 1
57417: PPUSH
57418: EMPTY
57419: PPUSH
57420: CALL_OW 1
57424: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57425: LD_ADDR_EXP 92
57429: PUSH
57430: LD_EXP 92
57434: PPUSH
57435: LD_VAR 0 1
57439: PPUSH
57440: EMPTY
57441: PPUSH
57442: CALL_OW 1
57446: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57447: LD_ADDR_EXP 93
57451: PUSH
57452: LD_EXP 93
57456: PPUSH
57457: LD_VAR 0 1
57461: PPUSH
57462: EMPTY
57463: PPUSH
57464: CALL_OW 1
57468: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57469: LD_ADDR_EXP 94
57473: PUSH
57474: LD_EXP 94
57478: PPUSH
57479: LD_VAR 0 1
57483: PPUSH
57484: EMPTY
57485: PPUSH
57486: CALL_OW 1
57490: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57491: LD_ADDR_EXP 95
57495: PUSH
57496: LD_EXP 95
57500: PPUSH
57501: LD_VAR 0 1
57505: PPUSH
57506: EMPTY
57507: PPUSH
57508: CALL_OW 1
57512: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57513: LD_ADDR_EXP 96
57517: PUSH
57518: LD_EXP 96
57522: PPUSH
57523: LD_VAR 0 1
57527: PPUSH
57528: EMPTY
57529: PPUSH
57530: CALL_OW 1
57534: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57535: LD_ADDR_EXP 97
57539: PUSH
57540: LD_EXP 97
57544: PPUSH
57545: LD_VAR 0 1
57549: PPUSH
57550: EMPTY
57551: PPUSH
57552: CALL_OW 1
57556: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57557: LD_ADDR_EXP 98
57561: PUSH
57562: LD_EXP 98
57566: PPUSH
57567: LD_VAR 0 1
57571: PPUSH
57572: EMPTY
57573: PPUSH
57574: CALL_OW 1
57578: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57579: LD_ADDR_EXP 99
57583: PUSH
57584: LD_EXP 99
57588: PPUSH
57589: LD_VAR 0 1
57593: PPUSH
57594: EMPTY
57595: PPUSH
57596: CALL_OW 1
57600: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57601: LD_ADDR_EXP 100
57605: PUSH
57606: LD_EXP 100
57610: PPUSH
57611: LD_VAR 0 1
57615: PPUSH
57616: LD_INT 0
57618: PPUSH
57619: CALL_OW 1
57623: ST_TO_ADDR
// end ;
57624: LD_VAR 0 2
57628: RET
// export function MC_Add ( side , units ) ; var base ; begin
57629: LD_INT 0
57631: PPUSH
57632: PPUSH
// base := mc_bases + 1 ;
57633: LD_ADDR_VAR 0 4
57637: PUSH
57638: LD_EXP 58
57642: PUSH
57643: LD_INT 1
57645: PLUS
57646: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
57647: LD_ADDR_EXP 84
57651: PUSH
57652: LD_EXP 84
57656: PPUSH
57657: LD_VAR 0 4
57661: PPUSH
57662: LD_VAR 0 1
57666: PPUSH
57667: CALL_OW 1
57671: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
57672: LD_ADDR_EXP 58
57676: PUSH
57677: LD_EXP 58
57681: PPUSH
57682: LD_VAR 0 4
57686: PPUSH
57687: LD_VAR 0 2
57691: PPUSH
57692: CALL_OW 1
57696: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57697: LD_ADDR_EXP 59
57701: PUSH
57702: LD_EXP 59
57706: PPUSH
57707: LD_VAR 0 4
57711: PPUSH
57712: EMPTY
57713: PPUSH
57714: CALL_OW 1
57718: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57719: LD_ADDR_EXP 60
57723: PUSH
57724: LD_EXP 60
57728: PPUSH
57729: LD_VAR 0 4
57733: PPUSH
57734: EMPTY
57735: PPUSH
57736: CALL_OW 1
57740: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57741: LD_ADDR_EXP 61
57745: PUSH
57746: LD_EXP 61
57750: PPUSH
57751: LD_VAR 0 4
57755: PPUSH
57756: EMPTY
57757: PPUSH
57758: CALL_OW 1
57762: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57763: LD_ADDR_EXP 62
57767: PUSH
57768: LD_EXP 62
57772: PPUSH
57773: LD_VAR 0 4
57777: PPUSH
57778: EMPTY
57779: PPUSH
57780: CALL_OW 1
57784: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57785: LD_ADDR_EXP 63
57789: PUSH
57790: LD_EXP 63
57794: PPUSH
57795: LD_VAR 0 4
57799: PPUSH
57800: EMPTY
57801: PPUSH
57802: CALL_OW 1
57806: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57807: LD_ADDR_EXP 64
57811: PUSH
57812: LD_EXP 64
57816: PPUSH
57817: LD_VAR 0 4
57821: PPUSH
57822: EMPTY
57823: PPUSH
57824: CALL_OW 1
57828: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57829: LD_ADDR_EXP 65
57833: PUSH
57834: LD_EXP 65
57838: PPUSH
57839: LD_VAR 0 4
57843: PPUSH
57844: EMPTY
57845: PPUSH
57846: CALL_OW 1
57850: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57851: LD_ADDR_EXP 66
57855: PUSH
57856: LD_EXP 66
57860: PPUSH
57861: LD_VAR 0 4
57865: PPUSH
57866: EMPTY
57867: PPUSH
57868: CALL_OW 1
57872: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57873: LD_ADDR_EXP 67
57877: PUSH
57878: LD_EXP 67
57882: PPUSH
57883: LD_VAR 0 4
57887: PPUSH
57888: EMPTY
57889: PPUSH
57890: CALL_OW 1
57894: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57895: LD_ADDR_EXP 68
57899: PUSH
57900: LD_EXP 68
57904: PPUSH
57905: LD_VAR 0 4
57909: PPUSH
57910: EMPTY
57911: PPUSH
57912: CALL_OW 1
57916: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57917: LD_ADDR_EXP 69
57921: PUSH
57922: LD_EXP 69
57926: PPUSH
57927: LD_VAR 0 4
57931: PPUSH
57932: LD_INT 0
57934: PPUSH
57935: CALL_OW 1
57939: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57940: LD_ADDR_EXP 70
57944: PUSH
57945: LD_EXP 70
57949: PPUSH
57950: LD_VAR 0 4
57954: PPUSH
57955: EMPTY
57956: PPUSH
57957: CALL_OW 1
57961: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57962: LD_ADDR_EXP 71
57966: PUSH
57967: LD_EXP 71
57971: PPUSH
57972: LD_VAR 0 4
57976: PPUSH
57977: EMPTY
57978: PPUSH
57979: CALL_OW 1
57983: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57984: LD_ADDR_EXP 72
57988: PUSH
57989: LD_EXP 72
57993: PPUSH
57994: LD_VAR 0 4
57998: PPUSH
57999: EMPTY
58000: PPUSH
58001: CALL_OW 1
58005: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58006: LD_ADDR_EXP 73
58010: PUSH
58011: LD_EXP 73
58015: PPUSH
58016: LD_VAR 0 4
58020: PPUSH
58021: EMPTY
58022: PPUSH
58023: CALL_OW 1
58027: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58028: LD_ADDR_EXP 74
58032: PUSH
58033: LD_EXP 74
58037: PPUSH
58038: LD_VAR 0 4
58042: PPUSH
58043: EMPTY
58044: PPUSH
58045: CALL_OW 1
58049: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58050: LD_ADDR_EXP 75
58054: PUSH
58055: LD_EXP 75
58059: PPUSH
58060: LD_VAR 0 4
58064: PPUSH
58065: EMPTY
58066: PPUSH
58067: CALL_OW 1
58071: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58072: LD_ADDR_EXP 76
58076: PUSH
58077: LD_EXP 76
58081: PPUSH
58082: LD_VAR 0 4
58086: PPUSH
58087: EMPTY
58088: PPUSH
58089: CALL_OW 1
58093: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58094: LD_ADDR_EXP 77
58098: PUSH
58099: LD_EXP 77
58103: PPUSH
58104: LD_VAR 0 4
58108: PPUSH
58109: EMPTY
58110: PPUSH
58111: CALL_OW 1
58115: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58116: LD_ADDR_EXP 78
58120: PUSH
58121: LD_EXP 78
58125: PPUSH
58126: LD_VAR 0 4
58130: PPUSH
58131: EMPTY
58132: PPUSH
58133: CALL_OW 1
58137: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58138: LD_ADDR_EXP 79
58142: PUSH
58143: LD_EXP 79
58147: PPUSH
58148: LD_VAR 0 4
58152: PPUSH
58153: EMPTY
58154: PPUSH
58155: CALL_OW 1
58159: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58160: LD_ADDR_EXP 80
58164: PUSH
58165: LD_EXP 80
58169: PPUSH
58170: LD_VAR 0 4
58174: PPUSH
58175: EMPTY
58176: PPUSH
58177: CALL_OW 1
58181: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58182: LD_ADDR_EXP 81
58186: PUSH
58187: LD_EXP 81
58191: PPUSH
58192: LD_VAR 0 4
58196: PPUSH
58197: EMPTY
58198: PPUSH
58199: CALL_OW 1
58203: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58204: LD_ADDR_EXP 82
58208: PUSH
58209: LD_EXP 82
58213: PPUSH
58214: LD_VAR 0 4
58218: PPUSH
58219: EMPTY
58220: PPUSH
58221: CALL_OW 1
58225: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58226: LD_ADDR_EXP 83
58230: PUSH
58231: LD_EXP 83
58235: PPUSH
58236: LD_VAR 0 4
58240: PPUSH
58241: EMPTY
58242: PPUSH
58243: CALL_OW 1
58247: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58248: LD_ADDR_EXP 85
58252: PUSH
58253: LD_EXP 85
58257: PPUSH
58258: LD_VAR 0 4
58262: PPUSH
58263: EMPTY
58264: PPUSH
58265: CALL_OW 1
58269: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58270: LD_ADDR_EXP 87
58274: PUSH
58275: LD_EXP 87
58279: PPUSH
58280: LD_VAR 0 4
58284: PPUSH
58285: EMPTY
58286: PPUSH
58287: CALL_OW 1
58291: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58292: LD_ADDR_EXP 88
58296: PUSH
58297: LD_EXP 88
58301: PPUSH
58302: LD_VAR 0 4
58306: PPUSH
58307: EMPTY
58308: PPUSH
58309: CALL_OW 1
58313: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58314: LD_ADDR_EXP 89
58318: PUSH
58319: LD_EXP 89
58323: PPUSH
58324: LD_VAR 0 4
58328: PPUSH
58329: EMPTY
58330: PPUSH
58331: CALL_OW 1
58335: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58336: LD_ADDR_EXP 90
58340: PUSH
58341: LD_EXP 90
58345: PPUSH
58346: LD_VAR 0 4
58350: PPUSH
58351: EMPTY
58352: PPUSH
58353: CALL_OW 1
58357: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58358: LD_ADDR_EXP 91
58362: PUSH
58363: LD_EXP 91
58367: PPUSH
58368: LD_VAR 0 4
58372: PPUSH
58373: EMPTY
58374: PPUSH
58375: CALL_OW 1
58379: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58380: LD_ADDR_EXP 92
58384: PUSH
58385: LD_EXP 92
58389: PPUSH
58390: LD_VAR 0 4
58394: PPUSH
58395: EMPTY
58396: PPUSH
58397: CALL_OW 1
58401: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58402: LD_ADDR_EXP 93
58406: PUSH
58407: LD_EXP 93
58411: PPUSH
58412: LD_VAR 0 4
58416: PPUSH
58417: EMPTY
58418: PPUSH
58419: CALL_OW 1
58423: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58424: LD_ADDR_EXP 94
58428: PUSH
58429: LD_EXP 94
58433: PPUSH
58434: LD_VAR 0 4
58438: PPUSH
58439: EMPTY
58440: PPUSH
58441: CALL_OW 1
58445: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58446: LD_ADDR_EXP 95
58450: PUSH
58451: LD_EXP 95
58455: PPUSH
58456: LD_VAR 0 4
58460: PPUSH
58461: EMPTY
58462: PPUSH
58463: CALL_OW 1
58467: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58468: LD_ADDR_EXP 96
58472: PUSH
58473: LD_EXP 96
58477: PPUSH
58478: LD_VAR 0 4
58482: PPUSH
58483: EMPTY
58484: PPUSH
58485: CALL_OW 1
58489: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58490: LD_ADDR_EXP 97
58494: PUSH
58495: LD_EXP 97
58499: PPUSH
58500: LD_VAR 0 4
58504: PPUSH
58505: EMPTY
58506: PPUSH
58507: CALL_OW 1
58511: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58512: LD_ADDR_EXP 98
58516: PUSH
58517: LD_EXP 98
58521: PPUSH
58522: LD_VAR 0 4
58526: PPUSH
58527: EMPTY
58528: PPUSH
58529: CALL_OW 1
58533: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58534: LD_ADDR_EXP 99
58538: PUSH
58539: LD_EXP 99
58543: PPUSH
58544: LD_VAR 0 4
58548: PPUSH
58549: EMPTY
58550: PPUSH
58551: CALL_OW 1
58555: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58556: LD_ADDR_EXP 100
58560: PUSH
58561: LD_EXP 100
58565: PPUSH
58566: LD_VAR 0 4
58570: PPUSH
58571: LD_INT 0
58573: PPUSH
58574: CALL_OW 1
58578: ST_TO_ADDR
// result := base ;
58579: LD_ADDR_VAR 0 3
58583: PUSH
58584: LD_VAR 0 4
58588: ST_TO_ADDR
// end ;
58589: LD_VAR 0 3
58593: RET
// export function MC_Start ( ) ; var i ; begin
58594: LD_INT 0
58596: PPUSH
58597: PPUSH
// for i = 1 to mc_bases do
58598: LD_ADDR_VAR 0 2
58602: PUSH
58603: DOUBLE
58604: LD_INT 1
58606: DEC
58607: ST_TO_ADDR
58608: LD_EXP 58
58612: PUSH
58613: FOR_TO
58614: IFFALSE 59691
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
58616: LD_ADDR_EXP 58
58620: PUSH
58621: LD_EXP 58
58625: PPUSH
58626: LD_VAR 0 2
58630: PPUSH
58631: LD_EXP 58
58635: PUSH
58636: LD_VAR 0 2
58640: ARRAY
58641: PUSH
58642: LD_INT 0
58644: DIFF
58645: PPUSH
58646: CALL_OW 1
58650: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
58651: LD_ADDR_EXP 59
58655: PUSH
58656: LD_EXP 59
58660: PPUSH
58661: LD_VAR 0 2
58665: PPUSH
58666: EMPTY
58667: PPUSH
58668: CALL_OW 1
58672: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
58673: LD_ADDR_EXP 60
58677: PUSH
58678: LD_EXP 60
58682: PPUSH
58683: LD_VAR 0 2
58687: PPUSH
58688: EMPTY
58689: PPUSH
58690: CALL_OW 1
58694: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
58695: LD_ADDR_EXP 61
58699: PUSH
58700: LD_EXP 61
58704: PPUSH
58705: LD_VAR 0 2
58709: PPUSH
58710: EMPTY
58711: PPUSH
58712: CALL_OW 1
58716: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
58717: LD_ADDR_EXP 62
58721: PUSH
58722: LD_EXP 62
58726: PPUSH
58727: LD_VAR 0 2
58731: PPUSH
58732: EMPTY
58733: PUSH
58734: EMPTY
58735: PUSH
58736: EMPTY
58737: LIST
58738: LIST
58739: PPUSH
58740: CALL_OW 1
58744: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
58745: LD_ADDR_EXP 63
58749: PUSH
58750: LD_EXP 63
58754: PPUSH
58755: LD_VAR 0 2
58759: PPUSH
58760: EMPTY
58761: PPUSH
58762: CALL_OW 1
58766: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
58767: LD_ADDR_EXP 90
58771: PUSH
58772: LD_EXP 90
58776: PPUSH
58777: LD_VAR 0 2
58781: PPUSH
58782: EMPTY
58783: PPUSH
58784: CALL_OW 1
58788: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
58789: LD_ADDR_EXP 64
58793: PUSH
58794: LD_EXP 64
58798: PPUSH
58799: LD_VAR 0 2
58803: PPUSH
58804: EMPTY
58805: PPUSH
58806: CALL_OW 1
58810: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
58811: LD_ADDR_EXP 65
58815: PUSH
58816: LD_EXP 65
58820: PPUSH
58821: LD_VAR 0 2
58825: PPUSH
58826: EMPTY
58827: PPUSH
58828: CALL_OW 1
58832: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
58833: LD_ADDR_EXP 66
58837: PUSH
58838: LD_EXP 66
58842: PPUSH
58843: LD_VAR 0 2
58847: PPUSH
58848: LD_EXP 58
58852: PUSH
58853: LD_VAR 0 2
58857: ARRAY
58858: PPUSH
58859: LD_INT 2
58861: PUSH
58862: LD_INT 30
58864: PUSH
58865: LD_INT 32
58867: PUSH
58868: EMPTY
58869: LIST
58870: LIST
58871: PUSH
58872: LD_INT 30
58874: PUSH
58875: LD_INT 33
58877: PUSH
58878: EMPTY
58879: LIST
58880: LIST
58881: PUSH
58882: EMPTY
58883: LIST
58884: LIST
58885: LIST
58886: PPUSH
58887: CALL_OW 72
58891: PPUSH
58892: CALL_OW 1
58896: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
58897: LD_ADDR_EXP 67
58901: PUSH
58902: LD_EXP 67
58906: PPUSH
58907: LD_VAR 0 2
58911: PPUSH
58912: LD_EXP 58
58916: PUSH
58917: LD_VAR 0 2
58921: ARRAY
58922: PPUSH
58923: LD_INT 2
58925: PUSH
58926: LD_INT 30
58928: PUSH
58929: LD_INT 32
58931: PUSH
58932: EMPTY
58933: LIST
58934: LIST
58935: PUSH
58936: LD_INT 30
58938: PUSH
58939: LD_INT 31
58941: PUSH
58942: EMPTY
58943: LIST
58944: LIST
58945: PUSH
58946: EMPTY
58947: LIST
58948: LIST
58949: LIST
58950: PUSH
58951: LD_INT 58
58953: PUSH
58954: EMPTY
58955: LIST
58956: PUSH
58957: EMPTY
58958: LIST
58959: LIST
58960: PPUSH
58961: CALL_OW 72
58965: PPUSH
58966: CALL_OW 1
58970: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
58971: LD_ADDR_EXP 68
58975: PUSH
58976: LD_EXP 68
58980: PPUSH
58981: LD_VAR 0 2
58985: PPUSH
58986: EMPTY
58987: PPUSH
58988: CALL_OW 1
58992: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
58993: LD_ADDR_EXP 72
58997: PUSH
58998: LD_EXP 72
59002: PPUSH
59003: LD_VAR 0 2
59007: PPUSH
59008: EMPTY
59009: PPUSH
59010: CALL_OW 1
59014: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
59015: LD_ADDR_EXP 71
59019: PUSH
59020: LD_EXP 71
59024: PPUSH
59025: LD_VAR 0 2
59029: PPUSH
59030: EMPTY
59031: PPUSH
59032: CALL_OW 1
59036: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
59037: LD_ADDR_EXP 73
59041: PUSH
59042: LD_EXP 73
59046: PPUSH
59047: LD_VAR 0 2
59051: PPUSH
59052: EMPTY
59053: PPUSH
59054: CALL_OW 1
59058: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
59059: LD_ADDR_EXP 74
59063: PUSH
59064: LD_EXP 74
59068: PPUSH
59069: LD_VAR 0 2
59073: PPUSH
59074: EMPTY
59075: PPUSH
59076: CALL_OW 1
59080: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
59081: LD_ADDR_EXP 75
59085: PUSH
59086: LD_EXP 75
59090: PPUSH
59091: LD_VAR 0 2
59095: PPUSH
59096: EMPTY
59097: PPUSH
59098: CALL_OW 1
59102: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
59103: LD_ADDR_EXP 76
59107: PUSH
59108: LD_EXP 76
59112: PPUSH
59113: LD_VAR 0 2
59117: PPUSH
59118: EMPTY
59119: PPUSH
59120: CALL_OW 1
59124: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
59125: LD_ADDR_EXP 77
59129: PUSH
59130: LD_EXP 77
59134: PPUSH
59135: LD_VAR 0 2
59139: PPUSH
59140: EMPTY
59141: PPUSH
59142: CALL_OW 1
59146: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
59147: LD_ADDR_EXP 78
59151: PUSH
59152: LD_EXP 78
59156: PPUSH
59157: LD_VAR 0 2
59161: PPUSH
59162: EMPTY
59163: PPUSH
59164: CALL_OW 1
59168: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
59169: LD_ADDR_EXP 79
59173: PUSH
59174: LD_EXP 79
59178: PPUSH
59179: LD_VAR 0 2
59183: PPUSH
59184: EMPTY
59185: PPUSH
59186: CALL_OW 1
59190: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
59191: LD_ADDR_EXP 80
59195: PUSH
59196: LD_EXP 80
59200: PPUSH
59201: LD_VAR 0 2
59205: PPUSH
59206: EMPTY
59207: PPUSH
59208: CALL_OW 1
59212: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
59213: LD_ADDR_EXP 69
59217: PUSH
59218: LD_EXP 69
59222: PPUSH
59223: LD_VAR 0 2
59227: PPUSH
59228: LD_INT 0
59230: PPUSH
59231: CALL_OW 1
59235: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
59236: LD_ADDR_EXP 82
59240: PUSH
59241: LD_EXP 82
59245: PPUSH
59246: LD_VAR 0 2
59250: PPUSH
59251: LD_INT 0
59253: PPUSH
59254: CALL_OW 1
59258: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59259: LD_ADDR_EXP 70
59263: PUSH
59264: LD_EXP 70
59268: PPUSH
59269: LD_VAR 0 2
59273: PPUSH
59274: EMPTY
59275: PPUSH
59276: CALL_OW 1
59280: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
59281: LD_ADDR_EXP 81
59285: PUSH
59286: LD_EXP 81
59290: PPUSH
59291: LD_VAR 0 2
59295: PPUSH
59296: LD_INT 0
59298: PPUSH
59299: CALL_OW 1
59303: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
59304: LD_ADDR_EXP 83
59308: PUSH
59309: LD_EXP 83
59313: PPUSH
59314: LD_VAR 0 2
59318: PPUSH
59319: EMPTY
59320: PPUSH
59321: CALL_OW 1
59325: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
59326: LD_ADDR_EXP 86
59330: PUSH
59331: LD_EXP 86
59335: PPUSH
59336: LD_VAR 0 2
59340: PPUSH
59341: LD_INT 0
59343: PPUSH
59344: CALL_OW 1
59348: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
59349: LD_ADDR_EXP 87
59353: PUSH
59354: LD_EXP 87
59358: PPUSH
59359: LD_VAR 0 2
59363: PPUSH
59364: EMPTY
59365: PPUSH
59366: CALL_OW 1
59370: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
59371: LD_ADDR_EXP 88
59375: PUSH
59376: LD_EXP 88
59380: PPUSH
59381: LD_VAR 0 2
59385: PPUSH
59386: EMPTY
59387: PPUSH
59388: CALL_OW 1
59392: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59393: LD_ADDR_EXP 89
59397: PUSH
59398: LD_EXP 89
59402: PPUSH
59403: LD_VAR 0 2
59407: PPUSH
59408: EMPTY
59409: PPUSH
59410: CALL_OW 1
59414: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
59415: LD_ADDR_EXP 91
59419: PUSH
59420: LD_EXP 91
59424: PPUSH
59425: LD_VAR 0 2
59429: PPUSH
59430: LD_EXP 58
59434: PUSH
59435: LD_VAR 0 2
59439: ARRAY
59440: PPUSH
59441: LD_INT 2
59443: PUSH
59444: LD_INT 30
59446: PUSH
59447: LD_INT 6
59449: PUSH
59450: EMPTY
59451: LIST
59452: LIST
59453: PUSH
59454: LD_INT 30
59456: PUSH
59457: LD_INT 7
59459: PUSH
59460: EMPTY
59461: LIST
59462: LIST
59463: PUSH
59464: LD_INT 30
59466: PUSH
59467: LD_INT 8
59469: PUSH
59470: EMPTY
59471: LIST
59472: LIST
59473: PUSH
59474: EMPTY
59475: LIST
59476: LIST
59477: LIST
59478: LIST
59479: PPUSH
59480: CALL_OW 72
59484: PPUSH
59485: CALL_OW 1
59489: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
59490: LD_ADDR_EXP 92
59494: PUSH
59495: LD_EXP 92
59499: PPUSH
59500: LD_VAR 0 2
59504: PPUSH
59505: EMPTY
59506: PPUSH
59507: CALL_OW 1
59511: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
59512: LD_ADDR_EXP 93
59516: PUSH
59517: LD_EXP 93
59521: PPUSH
59522: LD_VAR 0 2
59526: PPUSH
59527: EMPTY
59528: PPUSH
59529: CALL_OW 1
59533: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
59534: LD_ADDR_EXP 94
59538: PUSH
59539: LD_EXP 94
59543: PPUSH
59544: LD_VAR 0 2
59548: PPUSH
59549: EMPTY
59550: PPUSH
59551: CALL_OW 1
59555: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
59556: LD_ADDR_EXP 95
59560: PUSH
59561: LD_EXP 95
59565: PPUSH
59566: LD_VAR 0 2
59570: PPUSH
59571: EMPTY
59572: PPUSH
59573: CALL_OW 1
59577: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59578: LD_ADDR_EXP 96
59582: PUSH
59583: LD_EXP 96
59587: PPUSH
59588: LD_VAR 0 2
59592: PPUSH
59593: EMPTY
59594: PPUSH
59595: CALL_OW 1
59599: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
59600: LD_ADDR_EXP 97
59604: PUSH
59605: LD_EXP 97
59609: PPUSH
59610: LD_VAR 0 2
59614: PPUSH
59615: EMPTY
59616: PPUSH
59617: CALL_OW 1
59621: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
59622: LD_ADDR_EXP 98
59626: PUSH
59627: LD_EXP 98
59631: PPUSH
59632: LD_VAR 0 2
59636: PPUSH
59637: EMPTY
59638: PPUSH
59639: CALL_OW 1
59643: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
59644: LD_ADDR_EXP 99
59648: PUSH
59649: LD_EXP 99
59653: PPUSH
59654: LD_VAR 0 2
59658: PPUSH
59659: EMPTY
59660: PPUSH
59661: CALL_OW 1
59665: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
59666: LD_ADDR_EXP 100
59670: PUSH
59671: LD_EXP 100
59675: PPUSH
59676: LD_VAR 0 2
59680: PPUSH
59681: LD_INT 0
59683: PPUSH
59684: CALL_OW 1
59688: ST_TO_ADDR
// end ;
59689: GO 58613
59691: POP
59692: POP
// MC_InitSides ( ) ;
59693: CALL 59979 0 0
// MC_InitResearch ( ) ;
59697: CALL 59718 0 0
// CustomInitMacro ( ) ;
59701: CALL 181 0 0
// skirmish := true ;
59705: LD_ADDR_EXP 56
59709: PUSH
59710: LD_INT 1
59712: ST_TO_ADDR
// end ;
59713: LD_VAR 0 1
59717: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
59718: LD_INT 0
59720: PPUSH
59721: PPUSH
59722: PPUSH
59723: PPUSH
59724: PPUSH
59725: PPUSH
// if not mc_bases then
59726: LD_EXP 58
59730: NOT
59731: IFFALSE 59735
// exit ;
59733: GO 59974
// for i = 1 to 8 do
59735: LD_ADDR_VAR 0 2
59739: PUSH
59740: DOUBLE
59741: LD_INT 1
59743: DEC
59744: ST_TO_ADDR
59745: LD_INT 8
59747: PUSH
59748: FOR_TO
59749: IFFALSE 59775
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
59751: LD_ADDR_EXP 85
59755: PUSH
59756: LD_EXP 85
59760: PPUSH
59761: LD_VAR 0 2
59765: PPUSH
59766: EMPTY
59767: PPUSH
59768: CALL_OW 1
59772: ST_TO_ADDR
59773: GO 59748
59775: POP
59776: POP
// tmp := [ ] ;
59777: LD_ADDR_VAR 0 5
59781: PUSH
59782: EMPTY
59783: ST_TO_ADDR
// for i = 1 to mc_sides do
59784: LD_ADDR_VAR 0 2
59788: PUSH
59789: DOUBLE
59790: LD_INT 1
59792: DEC
59793: ST_TO_ADDR
59794: LD_EXP 84
59798: PUSH
59799: FOR_TO
59800: IFFALSE 59858
// if not mc_sides [ i ] in tmp then
59802: LD_EXP 84
59806: PUSH
59807: LD_VAR 0 2
59811: ARRAY
59812: PUSH
59813: LD_VAR 0 5
59817: IN
59818: NOT
59819: IFFALSE 59856
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
59821: LD_ADDR_VAR 0 5
59825: PUSH
59826: LD_VAR 0 5
59830: PPUSH
59831: LD_VAR 0 5
59835: PUSH
59836: LD_INT 1
59838: PLUS
59839: PPUSH
59840: LD_EXP 84
59844: PUSH
59845: LD_VAR 0 2
59849: ARRAY
59850: PPUSH
59851: CALL_OW 2
59855: ST_TO_ADDR
59856: GO 59799
59858: POP
59859: POP
// if not tmp then
59860: LD_VAR 0 5
59864: NOT
59865: IFFALSE 59869
// exit ;
59867: GO 59974
// for j in tmp do
59869: LD_ADDR_VAR 0 3
59873: PUSH
59874: LD_VAR 0 5
59878: PUSH
59879: FOR_IN
59880: IFFALSE 59972
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
59882: LD_ADDR_VAR 0 6
59886: PUSH
59887: LD_INT 22
59889: PUSH
59890: LD_VAR 0 3
59894: PUSH
59895: EMPTY
59896: LIST
59897: LIST
59898: PPUSH
59899: CALL_OW 69
59903: ST_TO_ADDR
// if not un then
59904: LD_VAR 0 6
59908: NOT
59909: IFFALSE 59913
// continue ;
59911: GO 59879
// nation := GetNation ( un [ 1 ] ) ;
59913: LD_ADDR_VAR 0 4
59917: PUSH
59918: LD_VAR 0 6
59922: PUSH
59923: LD_INT 1
59925: ARRAY
59926: PPUSH
59927: CALL_OW 248
59931: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
59932: LD_ADDR_EXP 85
59936: PUSH
59937: LD_EXP 85
59941: PPUSH
59942: LD_VAR 0 3
59946: PPUSH
59947: LD_VAR 0 3
59951: PPUSH
59952: LD_VAR 0 4
59956: PPUSH
59957: LD_INT 1
59959: PPUSH
59960: CALL 13980 0 3
59964: PPUSH
59965: CALL_OW 1
59969: ST_TO_ADDR
// end ;
59970: GO 59879
59972: POP
59973: POP
// end ;
59974: LD_VAR 0 1
59978: RET
// export function MC_InitSides ( ) ; var i ; begin
59979: LD_INT 0
59981: PPUSH
59982: PPUSH
// if not mc_bases then
59983: LD_EXP 58
59987: NOT
59988: IFFALSE 59992
// exit ;
59990: GO 60066
// for i = 1 to mc_bases do
59992: LD_ADDR_VAR 0 2
59996: PUSH
59997: DOUBLE
59998: LD_INT 1
60000: DEC
60001: ST_TO_ADDR
60002: LD_EXP 58
60006: PUSH
60007: FOR_TO
60008: IFFALSE 60064
// if mc_bases [ i ] then
60010: LD_EXP 58
60014: PUSH
60015: LD_VAR 0 2
60019: ARRAY
60020: IFFALSE 60062
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
60022: LD_ADDR_EXP 84
60026: PUSH
60027: LD_EXP 84
60031: PPUSH
60032: LD_VAR 0 2
60036: PPUSH
60037: LD_EXP 58
60041: PUSH
60042: LD_VAR 0 2
60046: ARRAY
60047: PUSH
60048: LD_INT 1
60050: ARRAY
60051: PPUSH
60052: CALL_OW 255
60056: PPUSH
60057: CALL_OW 1
60061: ST_TO_ADDR
60062: GO 60007
60064: POP
60065: POP
// end ;
60066: LD_VAR 0 1
60070: RET
// every 0 0$01 trigger skirmish do
60071: LD_EXP 56
60075: IFFALSE 60229
60077: GO 60079
60079: DISABLE
// begin enable ;
60080: ENABLE
// MC_CheckBuildings ( ) ;
60081: CALL 64718 0 0
// MC_CheckPeopleLife ( ) ;
60085: CALL 64843 0 0
// RaiseSailEvent ( 100 ) ;
60089: LD_INT 100
60091: PPUSH
60092: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
60096: LD_INT 103
60098: PPUSH
60099: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
60103: LD_INT 104
60105: PPUSH
60106: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
60110: LD_INT 105
60112: PPUSH
60113: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
60117: LD_INT 106
60119: PPUSH
60120: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
60124: LD_INT 107
60126: PPUSH
60127: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
60131: LD_INT 108
60133: PPUSH
60134: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
60138: LD_INT 109
60140: PPUSH
60141: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
60145: LD_INT 110
60147: PPUSH
60148: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
60152: LD_INT 111
60154: PPUSH
60155: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
60159: LD_INT 112
60161: PPUSH
60162: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
60166: LD_INT 113
60168: PPUSH
60169: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
60173: LD_INT 120
60175: PPUSH
60176: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
60180: LD_INT 121
60182: PPUSH
60183: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
60187: LD_INT 122
60189: PPUSH
60190: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
60194: LD_INT 123
60196: PPUSH
60197: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
60201: LD_INT 124
60203: PPUSH
60204: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
60208: LD_INT 125
60210: PPUSH
60211: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
60215: LD_INT 126
60217: PPUSH
60218: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
60222: LD_INT 200
60224: PPUSH
60225: CALL_OW 427
// end ;
60229: END
// on SailEvent ( event ) do begin if event < 100 then
60230: LD_VAR 0 1
60234: PUSH
60235: LD_INT 100
60237: LESS
60238: IFFALSE 60249
// CustomEvent ( event ) ;
60240: LD_VAR 0 1
60244: PPUSH
60245: CALL 12694 0 1
// if event = 100 then
60249: LD_VAR 0 1
60253: PUSH
60254: LD_INT 100
60256: EQUAL
60257: IFFALSE 60263
// MC_ClassManager ( ) ;
60259: CALL 60655 0 0
// if event = 101 then
60263: LD_VAR 0 1
60267: PUSH
60268: LD_INT 101
60270: EQUAL
60271: IFFALSE 60277
// MC_RepairBuildings ( ) ;
60273: CALL 65439 0 0
// if event = 102 then
60277: LD_VAR 0 1
60281: PUSH
60282: LD_INT 102
60284: EQUAL
60285: IFFALSE 60291
// MC_Heal ( ) ;
60287: CALL 65845 0 0
// if event = 103 then
60291: LD_VAR 0 1
60295: PUSH
60296: LD_INT 103
60298: EQUAL
60299: IFFALSE 60305
// MC_Build ( ) ;
60301: CALL 66267 0 0
// if event = 104 then
60305: LD_VAR 0 1
60309: PUSH
60310: LD_INT 104
60312: EQUAL
60313: IFFALSE 60319
// MC_TurretWeapon ( ) ;
60315: CALL 67880 0 0
// if event = 105 then
60319: LD_VAR 0 1
60323: PUSH
60324: LD_INT 105
60326: EQUAL
60327: IFFALSE 60333
// MC_BuildUpgrade ( ) ;
60329: CALL 67431 0 0
// if event = 106 then
60333: LD_VAR 0 1
60337: PUSH
60338: LD_INT 106
60340: EQUAL
60341: IFFALSE 60347
// MC_PlantMines ( ) ;
60343: CALL 68310 0 0
// if event = 107 then
60347: LD_VAR 0 1
60351: PUSH
60352: LD_INT 107
60354: EQUAL
60355: IFFALSE 60361
// MC_CollectCrates ( ) ;
60357: CALL 69344 0 0
// if event = 108 then
60361: LD_VAR 0 1
60365: PUSH
60366: LD_INT 108
60368: EQUAL
60369: IFFALSE 60375
// MC_LinkRemoteControl ( ) ;
60371: CALL 71101 0 0
// if event = 109 then
60375: LD_VAR 0 1
60379: PUSH
60380: LD_INT 109
60382: EQUAL
60383: IFFALSE 60389
// MC_ProduceVehicle ( ) ;
60385: CALL 71282 0 0
// if event = 110 then
60389: LD_VAR 0 1
60393: PUSH
60394: LD_INT 110
60396: EQUAL
60397: IFFALSE 60403
// MC_SendAttack ( ) ;
60399: CALL 71763 0 0
// if event = 111 then
60403: LD_VAR 0 1
60407: PUSH
60408: LD_INT 111
60410: EQUAL
60411: IFFALSE 60417
// MC_Defend ( ) ;
60413: CALL 71871 0 0
// if event = 112 then
60417: LD_VAR 0 1
60421: PUSH
60422: LD_INT 112
60424: EQUAL
60425: IFFALSE 60431
// MC_Research ( ) ;
60427: CALL 72476 0 0
// if event = 113 then
60431: LD_VAR 0 1
60435: PUSH
60436: LD_INT 113
60438: EQUAL
60439: IFFALSE 60445
// MC_MinesTrigger ( ) ;
60441: CALL 73590 0 0
// if event = 120 then
60445: LD_VAR 0 1
60449: PUSH
60450: LD_INT 120
60452: EQUAL
60453: IFFALSE 60459
// MC_RepairVehicle ( ) ;
60455: CALL 73689 0 0
// if event = 121 then
60459: LD_VAR 0 1
60463: PUSH
60464: LD_INT 121
60466: EQUAL
60467: IFFALSE 60473
// MC_TameApe ( ) ;
60469: CALL 74396 0 0
// if event = 122 then
60473: LD_VAR 0 1
60477: PUSH
60478: LD_INT 122
60480: EQUAL
60481: IFFALSE 60487
// MC_ChangeApeClass ( ) ;
60483: CALL 75225 0 0
// if event = 123 then
60487: LD_VAR 0 1
60491: PUSH
60492: LD_INT 123
60494: EQUAL
60495: IFFALSE 60501
// MC_Bazooka ( ) ;
60497: CALL 75875 0 0
// if event = 124 then
60501: LD_VAR 0 1
60505: PUSH
60506: LD_INT 124
60508: EQUAL
60509: IFFALSE 60515
// MC_TeleportExit ( ) ;
60511: CALL 76073 0 0
// if event = 125 then
60515: LD_VAR 0 1
60519: PUSH
60520: LD_INT 125
60522: EQUAL
60523: IFFALSE 60529
// MC_Deposits ( ) ;
60525: CALL 76720 0 0
// if event = 126 then
60529: LD_VAR 0 1
60533: PUSH
60534: LD_INT 126
60536: EQUAL
60537: IFFALSE 60543
// MC_RemoteDriver ( ) ;
60539: CALL 77345 0 0
// if event = 200 then
60543: LD_VAR 0 1
60547: PUSH
60548: LD_INT 200
60550: EQUAL
60551: IFFALSE 60557
// MC_Idle ( ) ;
60553: CALL 79078 0 0
// end ;
60557: PPOPN 1
60559: END
// export function MC_Reset ( base , tag ) ; var i ; begin
60560: LD_INT 0
60562: PPUSH
60563: PPUSH
// if not mc_bases [ base ] or not tag then
60564: LD_EXP 58
60568: PUSH
60569: LD_VAR 0 1
60573: ARRAY
60574: NOT
60575: PUSH
60576: LD_VAR 0 2
60580: NOT
60581: OR
60582: IFFALSE 60586
// exit ;
60584: GO 60650
// for i in mc_bases [ base ] union mc_ape [ base ] do
60586: LD_ADDR_VAR 0 4
60590: PUSH
60591: LD_EXP 58
60595: PUSH
60596: LD_VAR 0 1
60600: ARRAY
60601: PUSH
60602: LD_EXP 87
60606: PUSH
60607: LD_VAR 0 1
60611: ARRAY
60612: UNION
60613: PUSH
60614: FOR_IN
60615: IFFALSE 60648
// if GetTag ( i ) = tag then
60617: LD_VAR 0 4
60621: PPUSH
60622: CALL_OW 110
60626: PUSH
60627: LD_VAR 0 2
60631: EQUAL
60632: IFFALSE 60646
// SetTag ( i , 0 ) ;
60634: LD_VAR 0 4
60638: PPUSH
60639: LD_INT 0
60641: PPUSH
60642: CALL_OW 109
60646: GO 60614
60648: POP
60649: POP
// end ;
60650: LD_VAR 0 3
60654: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
60655: LD_INT 0
60657: PPUSH
60658: PPUSH
60659: PPUSH
60660: PPUSH
60661: PPUSH
60662: PPUSH
60663: PPUSH
60664: PPUSH
// if not mc_bases then
60665: LD_EXP 58
60669: NOT
60670: IFFALSE 60674
// exit ;
60672: GO 61132
// for i = 1 to mc_bases do
60674: LD_ADDR_VAR 0 2
60678: PUSH
60679: DOUBLE
60680: LD_INT 1
60682: DEC
60683: ST_TO_ADDR
60684: LD_EXP 58
60688: PUSH
60689: FOR_TO
60690: IFFALSE 61130
// begin tmp := MC_ClassCheckReq ( i ) ;
60692: LD_ADDR_VAR 0 4
60696: PUSH
60697: LD_VAR 0 2
60701: PPUSH
60702: CALL 61137 0 1
60706: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
60707: LD_ADDR_EXP 99
60711: PUSH
60712: LD_EXP 99
60716: PPUSH
60717: LD_VAR 0 2
60721: PPUSH
60722: LD_VAR 0 4
60726: PPUSH
60727: CALL_OW 1
60731: ST_TO_ADDR
// if not tmp then
60732: LD_VAR 0 4
60736: NOT
60737: IFFALSE 60741
// continue ;
60739: GO 60689
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
60741: LD_ADDR_VAR 0 6
60745: PUSH
60746: LD_EXP 58
60750: PUSH
60751: LD_VAR 0 2
60755: ARRAY
60756: PPUSH
60757: LD_INT 2
60759: PUSH
60760: LD_INT 30
60762: PUSH
60763: LD_INT 4
60765: PUSH
60766: EMPTY
60767: LIST
60768: LIST
60769: PUSH
60770: LD_INT 30
60772: PUSH
60773: LD_INT 5
60775: PUSH
60776: EMPTY
60777: LIST
60778: LIST
60779: PUSH
60780: EMPTY
60781: LIST
60782: LIST
60783: LIST
60784: PPUSH
60785: CALL_OW 72
60789: PUSH
60790: LD_EXP 58
60794: PUSH
60795: LD_VAR 0 2
60799: ARRAY
60800: PPUSH
60801: LD_INT 2
60803: PUSH
60804: LD_INT 30
60806: PUSH
60807: LD_INT 0
60809: PUSH
60810: EMPTY
60811: LIST
60812: LIST
60813: PUSH
60814: LD_INT 30
60816: PUSH
60817: LD_INT 1
60819: PUSH
60820: EMPTY
60821: LIST
60822: LIST
60823: PUSH
60824: EMPTY
60825: LIST
60826: LIST
60827: LIST
60828: PPUSH
60829: CALL_OW 72
60833: PUSH
60834: LD_EXP 58
60838: PUSH
60839: LD_VAR 0 2
60843: ARRAY
60844: PPUSH
60845: LD_INT 30
60847: PUSH
60848: LD_INT 3
60850: PUSH
60851: EMPTY
60852: LIST
60853: LIST
60854: PPUSH
60855: CALL_OW 72
60859: PUSH
60860: LD_EXP 58
60864: PUSH
60865: LD_VAR 0 2
60869: ARRAY
60870: PPUSH
60871: LD_INT 2
60873: PUSH
60874: LD_INT 30
60876: PUSH
60877: LD_INT 6
60879: PUSH
60880: EMPTY
60881: LIST
60882: LIST
60883: PUSH
60884: LD_INT 30
60886: PUSH
60887: LD_INT 7
60889: PUSH
60890: EMPTY
60891: LIST
60892: LIST
60893: PUSH
60894: LD_INT 30
60896: PUSH
60897: LD_INT 8
60899: PUSH
60900: EMPTY
60901: LIST
60902: LIST
60903: PUSH
60904: EMPTY
60905: LIST
60906: LIST
60907: LIST
60908: LIST
60909: PPUSH
60910: CALL_OW 72
60914: PUSH
60915: EMPTY
60916: LIST
60917: LIST
60918: LIST
60919: LIST
60920: ST_TO_ADDR
// for j = 1 to 4 do
60921: LD_ADDR_VAR 0 3
60925: PUSH
60926: DOUBLE
60927: LD_INT 1
60929: DEC
60930: ST_TO_ADDR
60931: LD_INT 4
60933: PUSH
60934: FOR_TO
60935: IFFALSE 61126
// begin if not tmp [ j ] then
60937: LD_VAR 0 4
60941: PUSH
60942: LD_VAR 0 3
60946: ARRAY
60947: NOT
60948: IFFALSE 60952
// continue ;
60950: GO 60934
// for p in tmp [ j ] do
60952: LD_ADDR_VAR 0 5
60956: PUSH
60957: LD_VAR 0 4
60961: PUSH
60962: LD_VAR 0 3
60966: ARRAY
60967: PUSH
60968: FOR_IN
60969: IFFALSE 61122
// begin if not b [ j ] then
60971: LD_VAR 0 6
60975: PUSH
60976: LD_VAR 0 3
60980: ARRAY
60981: NOT
60982: IFFALSE 60986
// break ;
60984: GO 61122
// e := 0 ;
60986: LD_ADDR_VAR 0 7
60990: PUSH
60991: LD_INT 0
60993: ST_TO_ADDR
// for k in b [ j ] do
60994: LD_ADDR_VAR 0 8
60998: PUSH
60999: LD_VAR 0 6
61003: PUSH
61004: LD_VAR 0 3
61008: ARRAY
61009: PUSH
61010: FOR_IN
61011: IFFALSE 61038
// if IsNotFull ( k ) then
61013: LD_VAR 0 8
61017: PPUSH
61018: CALL 17969 0 1
61022: IFFALSE 61036
// begin e := k ;
61024: LD_ADDR_VAR 0 7
61028: PUSH
61029: LD_VAR 0 8
61033: ST_TO_ADDR
// break ;
61034: GO 61038
// end ;
61036: GO 61010
61038: POP
61039: POP
// if e and not UnitGoingToBuilding ( p , e ) then
61040: LD_VAR 0 7
61044: PUSH
61045: LD_VAR 0 5
61049: PPUSH
61050: LD_VAR 0 7
61054: PPUSH
61055: CALL 55027 0 2
61059: NOT
61060: AND
61061: IFFALSE 61120
// begin if IsInUnit ( p ) then
61063: LD_VAR 0 5
61067: PPUSH
61068: CALL_OW 310
61072: IFFALSE 61083
// ComExitBuilding ( p ) ;
61074: LD_VAR 0 5
61078: PPUSH
61079: CALL_OW 122
// ComEnterUnit ( p , e ) ;
61083: LD_VAR 0 5
61087: PPUSH
61088: LD_VAR 0 7
61092: PPUSH
61093: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
61097: LD_VAR 0 5
61101: PPUSH
61102: LD_VAR 0 3
61106: PPUSH
61107: CALL_OW 183
// AddComExitBuilding ( p ) ;
61111: LD_VAR 0 5
61115: PPUSH
61116: CALL_OW 182
// end ; end ;
61120: GO 60968
61122: POP
61123: POP
// end ;
61124: GO 60934
61126: POP
61127: POP
// end ;
61128: GO 60689
61130: POP
61131: POP
// end ;
61132: LD_VAR 0 1
61136: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
61137: LD_INT 0
61139: PPUSH
61140: PPUSH
61141: PPUSH
61142: PPUSH
61143: PPUSH
61144: PPUSH
61145: PPUSH
61146: PPUSH
61147: PPUSH
61148: PPUSH
61149: PPUSH
61150: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61151: LD_VAR 0 1
61155: NOT
61156: PUSH
61157: LD_EXP 58
61161: PUSH
61162: LD_VAR 0 1
61166: ARRAY
61167: NOT
61168: OR
61169: PUSH
61170: LD_EXP 58
61174: PUSH
61175: LD_VAR 0 1
61179: ARRAY
61180: PPUSH
61181: LD_INT 2
61183: PUSH
61184: LD_INT 30
61186: PUSH
61187: LD_INT 0
61189: PUSH
61190: EMPTY
61191: LIST
61192: LIST
61193: PUSH
61194: LD_INT 30
61196: PUSH
61197: LD_INT 1
61199: PUSH
61200: EMPTY
61201: LIST
61202: LIST
61203: PUSH
61204: EMPTY
61205: LIST
61206: LIST
61207: LIST
61208: PPUSH
61209: CALL_OW 72
61213: NOT
61214: OR
61215: IFFALSE 61219
// exit ;
61217: GO 64713
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61219: LD_ADDR_VAR 0 4
61223: PUSH
61224: LD_EXP 58
61228: PUSH
61229: LD_VAR 0 1
61233: ARRAY
61234: PPUSH
61235: LD_INT 2
61237: PUSH
61238: LD_INT 25
61240: PUSH
61241: LD_INT 1
61243: PUSH
61244: EMPTY
61245: LIST
61246: LIST
61247: PUSH
61248: LD_INT 25
61250: PUSH
61251: LD_INT 2
61253: PUSH
61254: EMPTY
61255: LIST
61256: LIST
61257: PUSH
61258: LD_INT 25
61260: PUSH
61261: LD_INT 3
61263: PUSH
61264: EMPTY
61265: LIST
61266: LIST
61267: PUSH
61268: LD_INT 25
61270: PUSH
61271: LD_INT 4
61273: PUSH
61274: EMPTY
61275: LIST
61276: LIST
61277: PUSH
61278: LD_INT 25
61280: PUSH
61281: LD_INT 5
61283: PUSH
61284: EMPTY
61285: LIST
61286: LIST
61287: PUSH
61288: LD_INT 25
61290: PUSH
61291: LD_INT 8
61293: PUSH
61294: EMPTY
61295: LIST
61296: LIST
61297: PUSH
61298: LD_INT 25
61300: PUSH
61301: LD_INT 9
61303: PUSH
61304: EMPTY
61305: LIST
61306: LIST
61307: PUSH
61308: EMPTY
61309: LIST
61310: LIST
61311: LIST
61312: LIST
61313: LIST
61314: LIST
61315: LIST
61316: LIST
61317: PPUSH
61318: CALL_OW 72
61322: ST_TO_ADDR
// for i in tmp do
61323: LD_ADDR_VAR 0 3
61327: PUSH
61328: LD_VAR 0 4
61332: PUSH
61333: FOR_IN
61334: IFFALSE 61365
// if GetTag ( i ) then
61336: LD_VAR 0 3
61340: PPUSH
61341: CALL_OW 110
61345: IFFALSE 61363
// tmp := tmp diff i ;
61347: LD_ADDR_VAR 0 4
61351: PUSH
61352: LD_VAR 0 4
61356: PUSH
61357: LD_VAR 0 3
61361: DIFF
61362: ST_TO_ADDR
61363: GO 61333
61365: POP
61366: POP
// if not tmp then
61367: LD_VAR 0 4
61371: NOT
61372: IFFALSE 61376
// exit ;
61374: GO 64713
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61376: LD_ADDR_VAR 0 5
61380: PUSH
61381: LD_EXP 58
61385: PUSH
61386: LD_VAR 0 1
61390: ARRAY
61391: PPUSH
61392: LD_INT 2
61394: PUSH
61395: LD_INT 25
61397: PUSH
61398: LD_INT 1
61400: PUSH
61401: EMPTY
61402: LIST
61403: LIST
61404: PUSH
61405: LD_INT 25
61407: PUSH
61408: LD_INT 5
61410: PUSH
61411: EMPTY
61412: LIST
61413: LIST
61414: PUSH
61415: LD_INT 25
61417: PUSH
61418: LD_INT 8
61420: PUSH
61421: EMPTY
61422: LIST
61423: LIST
61424: PUSH
61425: LD_INT 25
61427: PUSH
61428: LD_INT 9
61430: PUSH
61431: EMPTY
61432: LIST
61433: LIST
61434: PUSH
61435: EMPTY
61436: LIST
61437: LIST
61438: LIST
61439: LIST
61440: LIST
61441: PPUSH
61442: CALL_OW 72
61446: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
61447: LD_ADDR_VAR 0 6
61451: PUSH
61452: LD_EXP 58
61456: PUSH
61457: LD_VAR 0 1
61461: ARRAY
61462: PPUSH
61463: LD_INT 25
61465: PUSH
61466: LD_INT 2
61468: PUSH
61469: EMPTY
61470: LIST
61471: LIST
61472: PPUSH
61473: CALL_OW 72
61477: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
61478: LD_ADDR_VAR 0 7
61482: PUSH
61483: LD_EXP 58
61487: PUSH
61488: LD_VAR 0 1
61492: ARRAY
61493: PPUSH
61494: LD_INT 25
61496: PUSH
61497: LD_INT 3
61499: PUSH
61500: EMPTY
61501: LIST
61502: LIST
61503: PPUSH
61504: CALL_OW 72
61508: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
61509: LD_ADDR_VAR 0 8
61513: PUSH
61514: LD_EXP 58
61518: PUSH
61519: LD_VAR 0 1
61523: ARRAY
61524: PPUSH
61525: LD_INT 25
61527: PUSH
61528: LD_INT 4
61530: PUSH
61531: EMPTY
61532: LIST
61533: LIST
61534: PUSH
61535: LD_INT 24
61537: PUSH
61538: LD_INT 251
61540: PUSH
61541: EMPTY
61542: LIST
61543: LIST
61544: PUSH
61545: EMPTY
61546: LIST
61547: LIST
61548: PPUSH
61549: CALL_OW 72
61553: ST_TO_ADDR
// if mc_scan [ base ] then
61554: LD_EXP 81
61558: PUSH
61559: LD_VAR 0 1
61563: ARRAY
61564: IFFALSE 62025
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
61566: LD_ADDR_EXP 100
61570: PUSH
61571: LD_EXP 100
61575: PPUSH
61576: LD_VAR 0 1
61580: PPUSH
61581: LD_INT 4
61583: PPUSH
61584: CALL_OW 1
61588: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
61589: LD_ADDR_VAR 0 12
61593: PUSH
61594: LD_EXP 58
61598: PUSH
61599: LD_VAR 0 1
61603: ARRAY
61604: PPUSH
61605: LD_INT 2
61607: PUSH
61608: LD_INT 30
61610: PUSH
61611: LD_INT 4
61613: PUSH
61614: EMPTY
61615: LIST
61616: LIST
61617: PUSH
61618: LD_INT 30
61620: PUSH
61621: LD_INT 5
61623: PUSH
61624: EMPTY
61625: LIST
61626: LIST
61627: PUSH
61628: EMPTY
61629: LIST
61630: LIST
61631: LIST
61632: PPUSH
61633: CALL_OW 72
61637: ST_TO_ADDR
// if not b then
61638: LD_VAR 0 12
61642: NOT
61643: IFFALSE 61647
// exit ;
61645: GO 64713
// p := [ ] ;
61647: LD_ADDR_VAR 0 11
61651: PUSH
61652: EMPTY
61653: ST_TO_ADDR
// if sci >= 2 then
61654: LD_VAR 0 8
61658: PUSH
61659: LD_INT 2
61661: GREATEREQUAL
61662: IFFALSE 61693
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
61664: LD_ADDR_VAR 0 8
61668: PUSH
61669: LD_VAR 0 8
61673: PUSH
61674: LD_INT 1
61676: ARRAY
61677: PUSH
61678: LD_VAR 0 8
61682: PUSH
61683: LD_INT 2
61685: ARRAY
61686: PUSH
61687: EMPTY
61688: LIST
61689: LIST
61690: ST_TO_ADDR
61691: GO 61754
// if sci = 1 then
61693: LD_VAR 0 8
61697: PUSH
61698: LD_INT 1
61700: EQUAL
61701: IFFALSE 61722
// sci := [ sci [ 1 ] ] else
61703: LD_ADDR_VAR 0 8
61707: PUSH
61708: LD_VAR 0 8
61712: PUSH
61713: LD_INT 1
61715: ARRAY
61716: PUSH
61717: EMPTY
61718: LIST
61719: ST_TO_ADDR
61720: GO 61754
// if sci = 0 then
61722: LD_VAR 0 8
61726: PUSH
61727: LD_INT 0
61729: EQUAL
61730: IFFALSE 61754
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
61732: LD_ADDR_VAR 0 11
61736: PUSH
61737: LD_VAR 0 4
61741: PPUSH
61742: LD_INT 4
61744: PPUSH
61745: CALL 54890 0 2
61749: PUSH
61750: LD_INT 1
61752: ARRAY
61753: ST_TO_ADDR
// if eng > 4 then
61754: LD_VAR 0 6
61758: PUSH
61759: LD_INT 4
61761: GREATER
61762: IFFALSE 61808
// for i = eng downto 4 do
61764: LD_ADDR_VAR 0 3
61768: PUSH
61769: DOUBLE
61770: LD_VAR 0 6
61774: INC
61775: ST_TO_ADDR
61776: LD_INT 4
61778: PUSH
61779: FOR_DOWNTO
61780: IFFALSE 61806
// eng := eng diff eng [ i ] ;
61782: LD_ADDR_VAR 0 6
61786: PUSH
61787: LD_VAR 0 6
61791: PUSH
61792: LD_VAR 0 6
61796: PUSH
61797: LD_VAR 0 3
61801: ARRAY
61802: DIFF
61803: ST_TO_ADDR
61804: GO 61779
61806: POP
61807: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
61808: LD_ADDR_VAR 0 4
61812: PUSH
61813: LD_VAR 0 4
61817: PUSH
61818: LD_VAR 0 5
61822: PUSH
61823: LD_VAR 0 6
61827: UNION
61828: PUSH
61829: LD_VAR 0 7
61833: UNION
61834: PUSH
61835: LD_VAR 0 8
61839: UNION
61840: DIFF
61841: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
61842: LD_ADDR_VAR 0 13
61846: PUSH
61847: LD_EXP 58
61851: PUSH
61852: LD_VAR 0 1
61856: ARRAY
61857: PPUSH
61858: LD_INT 2
61860: PUSH
61861: LD_INT 30
61863: PUSH
61864: LD_INT 32
61866: PUSH
61867: EMPTY
61868: LIST
61869: LIST
61870: PUSH
61871: LD_INT 30
61873: PUSH
61874: LD_INT 31
61876: PUSH
61877: EMPTY
61878: LIST
61879: LIST
61880: PUSH
61881: EMPTY
61882: LIST
61883: LIST
61884: LIST
61885: PPUSH
61886: CALL_OW 72
61890: PUSH
61891: LD_EXP 58
61895: PUSH
61896: LD_VAR 0 1
61900: ARRAY
61901: PPUSH
61902: LD_INT 2
61904: PUSH
61905: LD_INT 30
61907: PUSH
61908: LD_INT 4
61910: PUSH
61911: EMPTY
61912: LIST
61913: LIST
61914: PUSH
61915: LD_INT 30
61917: PUSH
61918: LD_INT 5
61920: PUSH
61921: EMPTY
61922: LIST
61923: LIST
61924: PUSH
61925: EMPTY
61926: LIST
61927: LIST
61928: LIST
61929: PPUSH
61930: CALL_OW 72
61934: PUSH
61935: LD_INT 6
61937: MUL
61938: PLUS
61939: ST_TO_ADDR
// if bcount < tmp then
61940: LD_VAR 0 13
61944: PUSH
61945: LD_VAR 0 4
61949: LESS
61950: IFFALSE 61996
// for i = tmp downto bcount do
61952: LD_ADDR_VAR 0 3
61956: PUSH
61957: DOUBLE
61958: LD_VAR 0 4
61962: INC
61963: ST_TO_ADDR
61964: LD_VAR 0 13
61968: PUSH
61969: FOR_DOWNTO
61970: IFFALSE 61994
// tmp := Delete ( tmp , tmp ) ;
61972: LD_ADDR_VAR 0 4
61976: PUSH
61977: LD_VAR 0 4
61981: PPUSH
61982: LD_VAR 0 4
61986: PPUSH
61987: CALL_OW 3
61991: ST_TO_ADDR
61992: GO 61969
61994: POP
61995: POP
// result := [ tmp , 0 , 0 , p ] ;
61996: LD_ADDR_VAR 0 2
62000: PUSH
62001: LD_VAR 0 4
62005: PUSH
62006: LD_INT 0
62008: PUSH
62009: LD_INT 0
62011: PUSH
62012: LD_VAR 0 11
62016: PUSH
62017: EMPTY
62018: LIST
62019: LIST
62020: LIST
62021: LIST
62022: ST_TO_ADDR
// exit ;
62023: GO 64713
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62025: LD_EXP 58
62029: PUSH
62030: LD_VAR 0 1
62034: ARRAY
62035: PPUSH
62036: LD_INT 2
62038: PUSH
62039: LD_INT 30
62041: PUSH
62042: LD_INT 6
62044: PUSH
62045: EMPTY
62046: LIST
62047: LIST
62048: PUSH
62049: LD_INT 30
62051: PUSH
62052: LD_INT 7
62054: PUSH
62055: EMPTY
62056: LIST
62057: LIST
62058: PUSH
62059: LD_INT 30
62061: PUSH
62062: LD_INT 8
62064: PUSH
62065: EMPTY
62066: LIST
62067: LIST
62068: PUSH
62069: EMPTY
62070: LIST
62071: LIST
62072: LIST
62073: LIST
62074: PPUSH
62075: CALL_OW 72
62079: NOT
62080: PUSH
62081: LD_EXP 58
62085: PUSH
62086: LD_VAR 0 1
62090: ARRAY
62091: PPUSH
62092: LD_INT 30
62094: PUSH
62095: LD_INT 3
62097: PUSH
62098: EMPTY
62099: LIST
62100: LIST
62101: PPUSH
62102: CALL_OW 72
62106: NOT
62107: AND
62108: IFFALSE 62180
// begin if eng = tmp then
62110: LD_VAR 0 6
62114: PUSH
62115: LD_VAR 0 4
62119: EQUAL
62120: IFFALSE 62124
// exit ;
62122: GO 64713
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
62124: LD_ADDR_EXP 100
62128: PUSH
62129: LD_EXP 100
62133: PPUSH
62134: LD_VAR 0 1
62138: PPUSH
62139: LD_INT 1
62141: PPUSH
62142: CALL_OW 1
62146: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
62147: LD_ADDR_VAR 0 2
62151: PUSH
62152: LD_INT 0
62154: PUSH
62155: LD_VAR 0 4
62159: PUSH
62160: LD_VAR 0 6
62164: DIFF
62165: PUSH
62166: LD_INT 0
62168: PUSH
62169: LD_INT 0
62171: PUSH
62172: EMPTY
62173: LIST
62174: LIST
62175: LIST
62176: LIST
62177: ST_TO_ADDR
// exit ;
62178: GO 64713
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62180: LD_EXP 85
62184: PUSH
62185: LD_EXP 84
62189: PUSH
62190: LD_VAR 0 1
62194: ARRAY
62195: ARRAY
62196: PUSH
62197: LD_EXP 58
62201: PUSH
62202: LD_VAR 0 1
62206: ARRAY
62207: PPUSH
62208: LD_INT 2
62210: PUSH
62211: LD_INT 30
62213: PUSH
62214: LD_INT 6
62216: PUSH
62217: EMPTY
62218: LIST
62219: LIST
62220: PUSH
62221: LD_INT 30
62223: PUSH
62224: LD_INT 7
62226: PUSH
62227: EMPTY
62228: LIST
62229: LIST
62230: PUSH
62231: LD_INT 30
62233: PUSH
62234: LD_INT 8
62236: PUSH
62237: EMPTY
62238: LIST
62239: LIST
62240: PUSH
62241: EMPTY
62242: LIST
62243: LIST
62244: LIST
62245: LIST
62246: PPUSH
62247: CALL_OW 72
62251: AND
62252: PUSH
62253: LD_EXP 58
62257: PUSH
62258: LD_VAR 0 1
62262: ARRAY
62263: PPUSH
62264: LD_INT 30
62266: PUSH
62267: LD_INT 3
62269: PUSH
62270: EMPTY
62271: LIST
62272: LIST
62273: PPUSH
62274: CALL_OW 72
62278: NOT
62279: AND
62280: IFFALSE 62494
// begin if sci >= 6 then
62282: LD_VAR 0 8
62286: PUSH
62287: LD_INT 6
62289: GREATEREQUAL
62290: IFFALSE 62294
// exit ;
62292: GO 64713
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
62294: LD_ADDR_EXP 100
62298: PUSH
62299: LD_EXP 100
62303: PPUSH
62304: LD_VAR 0 1
62308: PPUSH
62309: LD_INT 2
62311: PPUSH
62312: CALL_OW 1
62316: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
62317: LD_ADDR_VAR 0 9
62321: PUSH
62322: LD_VAR 0 4
62326: PUSH
62327: LD_VAR 0 8
62331: DIFF
62332: PPUSH
62333: LD_INT 4
62335: PPUSH
62336: CALL 54890 0 2
62340: ST_TO_ADDR
// p := [ ] ;
62341: LD_ADDR_VAR 0 11
62345: PUSH
62346: EMPTY
62347: ST_TO_ADDR
// if sci < 6 and sort > 6 then
62348: LD_VAR 0 8
62352: PUSH
62353: LD_INT 6
62355: LESS
62356: PUSH
62357: LD_VAR 0 9
62361: PUSH
62362: LD_INT 6
62364: GREATER
62365: AND
62366: IFFALSE 62447
// begin for i = 1 to 6 - sci do
62368: LD_ADDR_VAR 0 3
62372: PUSH
62373: DOUBLE
62374: LD_INT 1
62376: DEC
62377: ST_TO_ADDR
62378: LD_INT 6
62380: PUSH
62381: LD_VAR 0 8
62385: MINUS
62386: PUSH
62387: FOR_TO
62388: IFFALSE 62443
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
62390: LD_ADDR_VAR 0 11
62394: PUSH
62395: LD_VAR 0 11
62399: PPUSH
62400: LD_VAR 0 11
62404: PUSH
62405: LD_INT 1
62407: PLUS
62408: PPUSH
62409: LD_VAR 0 9
62413: PUSH
62414: LD_INT 1
62416: ARRAY
62417: PPUSH
62418: CALL_OW 2
62422: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
62423: LD_ADDR_VAR 0 9
62427: PUSH
62428: LD_VAR 0 9
62432: PPUSH
62433: LD_INT 1
62435: PPUSH
62436: CALL_OW 3
62440: ST_TO_ADDR
// end ;
62441: GO 62387
62443: POP
62444: POP
// end else
62445: GO 62467
// if sort then
62447: LD_VAR 0 9
62451: IFFALSE 62467
// p := sort [ 1 ] ;
62453: LD_ADDR_VAR 0 11
62457: PUSH
62458: LD_VAR 0 9
62462: PUSH
62463: LD_INT 1
62465: ARRAY
62466: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
62467: LD_ADDR_VAR 0 2
62471: PUSH
62472: LD_INT 0
62474: PUSH
62475: LD_INT 0
62477: PUSH
62478: LD_INT 0
62480: PUSH
62481: LD_VAR 0 11
62485: PUSH
62486: EMPTY
62487: LIST
62488: LIST
62489: LIST
62490: LIST
62491: ST_TO_ADDR
// exit ;
62492: GO 64713
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62494: LD_EXP 85
62498: PUSH
62499: LD_EXP 84
62503: PUSH
62504: LD_VAR 0 1
62508: ARRAY
62509: ARRAY
62510: PUSH
62511: LD_EXP 58
62515: PUSH
62516: LD_VAR 0 1
62520: ARRAY
62521: PPUSH
62522: LD_INT 2
62524: PUSH
62525: LD_INT 30
62527: PUSH
62528: LD_INT 6
62530: PUSH
62531: EMPTY
62532: LIST
62533: LIST
62534: PUSH
62535: LD_INT 30
62537: PUSH
62538: LD_INT 7
62540: PUSH
62541: EMPTY
62542: LIST
62543: LIST
62544: PUSH
62545: LD_INT 30
62547: PUSH
62548: LD_INT 8
62550: PUSH
62551: EMPTY
62552: LIST
62553: LIST
62554: PUSH
62555: EMPTY
62556: LIST
62557: LIST
62558: LIST
62559: LIST
62560: PPUSH
62561: CALL_OW 72
62565: AND
62566: PUSH
62567: LD_EXP 58
62571: PUSH
62572: LD_VAR 0 1
62576: ARRAY
62577: PPUSH
62578: LD_INT 30
62580: PUSH
62581: LD_INT 3
62583: PUSH
62584: EMPTY
62585: LIST
62586: LIST
62587: PPUSH
62588: CALL_OW 72
62592: AND
62593: IFFALSE 63327
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
62595: LD_ADDR_EXP 100
62599: PUSH
62600: LD_EXP 100
62604: PPUSH
62605: LD_VAR 0 1
62609: PPUSH
62610: LD_INT 3
62612: PPUSH
62613: CALL_OW 1
62617: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62618: LD_ADDR_VAR 0 2
62622: PUSH
62623: LD_INT 0
62625: PUSH
62626: LD_INT 0
62628: PUSH
62629: LD_INT 0
62631: PUSH
62632: LD_INT 0
62634: PUSH
62635: EMPTY
62636: LIST
62637: LIST
62638: LIST
62639: LIST
62640: ST_TO_ADDR
// if not eng then
62641: LD_VAR 0 6
62645: NOT
62646: IFFALSE 62709
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
62648: LD_ADDR_VAR 0 11
62652: PUSH
62653: LD_VAR 0 4
62657: PPUSH
62658: LD_INT 2
62660: PPUSH
62661: CALL 54890 0 2
62665: PUSH
62666: LD_INT 1
62668: ARRAY
62669: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
62670: LD_ADDR_VAR 0 2
62674: PUSH
62675: LD_VAR 0 2
62679: PPUSH
62680: LD_INT 2
62682: PPUSH
62683: LD_VAR 0 11
62687: PPUSH
62688: CALL_OW 1
62692: ST_TO_ADDR
// tmp := tmp diff p ;
62693: LD_ADDR_VAR 0 4
62697: PUSH
62698: LD_VAR 0 4
62702: PUSH
62703: LD_VAR 0 11
62707: DIFF
62708: ST_TO_ADDR
// end ; if tmp and sci < 6 then
62709: LD_VAR 0 4
62713: PUSH
62714: LD_VAR 0 8
62718: PUSH
62719: LD_INT 6
62721: LESS
62722: AND
62723: IFFALSE 62911
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
62725: LD_ADDR_VAR 0 9
62729: PUSH
62730: LD_VAR 0 4
62734: PUSH
62735: LD_VAR 0 8
62739: PUSH
62740: LD_VAR 0 7
62744: UNION
62745: DIFF
62746: PPUSH
62747: LD_INT 4
62749: PPUSH
62750: CALL 54890 0 2
62754: ST_TO_ADDR
// p := [ ] ;
62755: LD_ADDR_VAR 0 11
62759: PUSH
62760: EMPTY
62761: ST_TO_ADDR
// if sort then
62762: LD_VAR 0 9
62766: IFFALSE 62882
// for i = 1 to 6 - sci do
62768: LD_ADDR_VAR 0 3
62772: PUSH
62773: DOUBLE
62774: LD_INT 1
62776: DEC
62777: ST_TO_ADDR
62778: LD_INT 6
62780: PUSH
62781: LD_VAR 0 8
62785: MINUS
62786: PUSH
62787: FOR_TO
62788: IFFALSE 62880
// begin if i = sort then
62790: LD_VAR 0 3
62794: PUSH
62795: LD_VAR 0 9
62799: EQUAL
62800: IFFALSE 62804
// break ;
62802: GO 62880
// if GetClass ( i ) = 4 then
62804: LD_VAR 0 3
62808: PPUSH
62809: CALL_OW 257
62813: PUSH
62814: LD_INT 4
62816: EQUAL
62817: IFFALSE 62821
// continue ;
62819: GO 62787
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62821: LD_ADDR_VAR 0 11
62825: PUSH
62826: LD_VAR 0 11
62830: PPUSH
62831: LD_VAR 0 11
62835: PUSH
62836: LD_INT 1
62838: PLUS
62839: PPUSH
62840: LD_VAR 0 9
62844: PUSH
62845: LD_VAR 0 3
62849: ARRAY
62850: PPUSH
62851: CALL_OW 2
62855: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62856: LD_ADDR_VAR 0 4
62860: PUSH
62861: LD_VAR 0 4
62865: PUSH
62866: LD_VAR 0 9
62870: PUSH
62871: LD_VAR 0 3
62875: ARRAY
62876: DIFF
62877: ST_TO_ADDR
// end ;
62878: GO 62787
62880: POP
62881: POP
// if p then
62882: LD_VAR 0 11
62886: IFFALSE 62911
// result := Replace ( result , 4 , p ) ;
62888: LD_ADDR_VAR 0 2
62892: PUSH
62893: LD_VAR 0 2
62897: PPUSH
62898: LD_INT 4
62900: PPUSH
62901: LD_VAR 0 11
62905: PPUSH
62906: CALL_OW 1
62910: ST_TO_ADDR
// end ; if tmp and mech < 6 then
62911: LD_VAR 0 4
62915: PUSH
62916: LD_VAR 0 7
62920: PUSH
62921: LD_INT 6
62923: LESS
62924: AND
62925: IFFALSE 63113
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62927: LD_ADDR_VAR 0 9
62931: PUSH
62932: LD_VAR 0 4
62936: PUSH
62937: LD_VAR 0 8
62941: PUSH
62942: LD_VAR 0 7
62946: UNION
62947: DIFF
62948: PPUSH
62949: LD_INT 3
62951: PPUSH
62952: CALL 54890 0 2
62956: ST_TO_ADDR
// p := [ ] ;
62957: LD_ADDR_VAR 0 11
62961: PUSH
62962: EMPTY
62963: ST_TO_ADDR
// if sort then
62964: LD_VAR 0 9
62968: IFFALSE 63084
// for i = 1 to 6 - mech do
62970: LD_ADDR_VAR 0 3
62974: PUSH
62975: DOUBLE
62976: LD_INT 1
62978: DEC
62979: ST_TO_ADDR
62980: LD_INT 6
62982: PUSH
62983: LD_VAR 0 7
62987: MINUS
62988: PUSH
62989: FOR_TO
62990: IFFALSE 63082
// begin if i = sort then
62992: LD_VAR 0 3
62996: PUSH
62997: LD_VAR 0 9
63001: EQUAL
63002: IFFALSE 63006
// break ;
63004: GO 63082
// if GetClass ( i ) = 3 then
63006: LD_VAR 0 3
63010: PPUSH
63011: CALL_OW 257
63015: PUSH
63016: LD_INT 3
63018: EQUAL
63019: IFFALSE 63023
// continue ;
63021: GO 62989
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63023: LD_ADDR_VAR 0 11
63027: PUSH
63028: LD_VAR 0 11
63032: PPUSH
63033: LD_VAR 0 11
63037: PUSH
63038: LD_INT 1
63040: PLUS
63041: PPUSH
63042: LD_VAR 0 9
63046: PUSH
63047: LD_VAR 0 3
63051: ARRAY
63052: PPUSH
63053: CALL_OW 2
63057: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63058: LD_ADDR_VAR 0 4
63062: PUSH
63063: LD_VAR 0 4
63067: PUSH
63068: LD_VAR 0 9
63072: PUSH
63073: LD_VAR 0 3
63077: ARRAY
63078: DIFF
63079: ST_TO_ADDR
// end ;
63080: GO 62989
63082: POP
63083: POP
// if p then
63084: LD_VAR 0 11
63088: IFFALSE 63113
// result := Replace ( result , 3 , p ) ;
63090: LD_ADDR_VAR 0 2
63094: PUSH
63095: LD_VAR 0 2
63099: PPUSH
63100: LD_INT 3
63102: PPUSH
63103: LD_VAR 0 11
63107: PPUSH
63108: CALL_OW 1
63112: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
63113: LD_VAR 0 4
63117: PUSH
63118: LD_INT 6
63120: GREATER
63121: PUSH
63122: LD_VAR 0 6
63126: PUSH
63127: LD_INT 6
63129: LESS
63130: AND
63131: IFFALSE 63325
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63133: LD_ADDR_VAR 0 9
63137: PUSH
63138: LD_VAR 0 4
63142: PUSH
63143: LD_VAR 0 8
63147: PUSH
63148: LD_VAR 0 7
63152: UNION
63153: PUSH
63154: LD_VAR 0 6
63158: UNION
63159: DIFF
63160: PPUSH
63161: LD_INT 2
63163: PPUSH
63164: CALL 54890 0 2
63168: ST_TO_ADDR
// p := [ ] ;
63169: LD_ADDR_VAR 0 11
63173: PUSH
63174: EMPTY
63175: ST_TO_ADDR
// if sort then
63176: LD_VAR 0 9
63180: IFFALSE 63296
// for i = 1 to 6 - eng do
63182: LD_ADDR_VAR 0 3
63186: PUSH
63187: DOUBLE
63188: LD_INT 1
63190: DEC
63191: ST_TO_ADDR
63192: LD_INT 6
63194: PUSH
63195: LD_VAR 0 6
63199: MINUS
63200: PUSH
63201: FOR_TO
63202: IFFALSE 63294
// begin if i = sort then
63204: LD_VAR 0 3
63208: PUSH
63209: LD_VAR 0 9
63213: EQUAL
63214: IFFALSE 63218
// break ;
63216: GO 63294
// if GetClass ( i ) = 2 then
63218: LD_VAR 0 3
63222: PPUSH
63223: CALL_OW 257
63227: PUSH
63228: LD_INT 2
63230: EQUAL
63231: IFFALSE 63235
// continue ;
63233: GO 63201
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63235: LD_ADDR_VAR 0 11
63239: PUSH
63240: LD_VAR 0 11
63244: PPUSH
63245: LD_VAR 0 11
63249: PUSH
63250: LD_INT 1
63252: PLUS
63253: PPUSH
63254: LD_VAR 0 9
63258: PUSH
63259: LD_VAR 0 3
63263: ARRAY
63264: PPUSH
63265: CALL_OW 2
63269: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63270: LD_ADDR_VAR 0 4
63274: PUSH
63275: LD_VAR 0 4
63279: PUSH
63280: LD_VAR 0 9
63284: PUSH
63285: LD_VAR 0 3
63289: ARRAY
63290: DIFF
63291: ST_TO_ADDR
// end ;
63292: GO 63201
63294: POP
63295: POP
// if p then
63296: LD_VAR 0 11
63300: IFFALSE 63325
// result := Replace ( result , 2 , p ) ;
63302: LD_ADDR_VAR 0 2
63306: PUSH
63307: LD_VAR 0 2
63311: PPUSH
63312: LD_INT 2
63314: PPUSH
63315: LD_VAR 0 11
63319: PPUSH
63320: CALL_OW 1
63324: ST_TO_ADDR
// end ; exit ;
63325: GO 64713
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
63327: LD_EXP 85
63331: PUSH
63332: LD_EXP 84
63336: PUSH
63337: LD_VAR 0 1
63341: ARRAY
63342: ARRAY
63343: NOT
63344: PUSH
63345: LD_EXP 58
63349: PUSH
63350: LD_VAR 0 1
63354: ARRAY
63355: PPUSH
63356: LD_INT 30
63358: PUSH
63359: LD_INT 3
63361: PUSH
63362: EMPTY
63363: LIST
63364: LIST
63365: PPUSH
63366: CALL_OW 72
63370: AND
63371: PUSH
63372: LD_EXP 63
63376: PUSH
63377: LD_VAR 0 1
63381: ARRAY
63382: AND
63383: IFFALSE 63991
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
63385: LD_ADDR_EXP 100
63389: PUSH
63390: LD_EXP 100
63394: PPUSH
63395: LD_VAR 0 1
63399: PPUSH
63400: LD_INT 5
63402: PPUSH
63403: CALL_OW 1
63407: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63408: LD_ADDR_VAR 0 2
63412: PUSH
63413: LD_INT 0
63415: PUSH
63416: LD_INT 0
63418: PUSH
63419: LD_INT 0
63421: PUSH
63422: LD_INT 0
63424: PUSH
63425: EMPTY
63426: LIST
63427: LIST
63428: LIST
63429: LIST
63430: ST_TO_ADDR
// if sci > 1 then
63431: LD_VAR 0 8
63435: PUSH
63436: LD_INT 1
63438: GREATER
63439: IFFALSE 63467
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
63441: LD_ADDR_VAR 0 4
63445: PUSH
63446: LD_VAR 0 4
63450: PUSH
63451: LD_VAR 0 8
63455: PUSH
63456: LD_VAR 0 8
63460: PUSH
63461: LD_INT 1
63463: ARRAY
63464: DIFF
63465: DIFF
63466: ST_TO_ADDR
// if tmp and not sci then
63467: LD_VAR 0 4
63471: PUSH
63472: LD_VAR 0 8
63476: NOT
63477: AND
63478: IFFALSE 63547
// begin sort := SortBySkill ( tmp , 4 ) ;
63480: LD_ADDR_VAR 0 9
63484: PUSH
63485: LD_VAR 0 4
63489: PPUSH
63490: LD_INT 4
63492: PPUSH
63493: CALL 54890 0 2
63497: ST_TO_ADDR
// if sort then
63498: LD_VAR 0 9
63502: IFFALSE 63518
// p := sort [ 1 ] ;
63504: LD_ADDR_VAR 0 11
63508: PUSH
63509: LD_VAR 0 9
63513: PUSH
63514: LD_INT 1
63516: ARRAY
63517: ST_TO_ADDR
// if p then
63518: LD_VAR 0 11
63522: IFFALSE 63547
// result := Replace ( result , 4 , p ) ;
63524: LD_ADDR_VAR 0 2
63528: PUSH
63529: LD_VAR 0 2
63533: PPUSH
63534: LD_INT 4
63536: PPUSH
63537: LD_VAR 0 11
63541: PPUSH
63542: CALL_OW 1
63546: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
63547: LD_ADDR_VAR 0 4
63551: PUSH
63552: LD_VAR 0 4
63556: PUSH
63557: LD_VAR 0 7
63561: DIFF
63562: ST_TO_ADDR
// if tmp and mech < 6 then
63563: LD_VAR 0 4
63567: PUSH
63568: LD_VAR 0 7
63572: PUSH
63573: LD_INT 6
63575: LESS
63576: AND
63577: IFFALSE 63765
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63579: LD_ADDR_VAR 0 9
63583: PUSH
63584: LD_VAR 0 4
63588: PUSH
63589: LD_VAR 0 8
63593: PUSH
63594: LD_VAR 0 7
63598: UNION
63599: DIFF
63600: PPUSH
63601: LD_INT 3
63603: PPUSH
63604: CALL 54890 0 2
63608: ST_TO_ADDR
// p := [ ] ;
63609: LD_ADDR_VAR 0 11
63613: PUSH
63614: EMPTY
63615: ST_TO_ADDR
// if sort then
63616: LD_VAR 0 9
63620: IFFALSE 63736
// for i = 1 to 6 - mech do
63622: LD_ADDR_VAR 0 3
63626: PUSH
63627: DOUBLE
63628: LD_INT 1
63630: DEC
63631: ST_TO_ADDR
63632: LD_INT 6
63634: PUSH
63635: LD_VAR 0 7
63639: MINUS
63640: PUSH
63641: FOR_TO
63642: IFFALSE 63734
// begin if i = sort then
63644: LD_VAR 0 3
63648: PUSH
63649: LD_VAR 0 9
63653: EQUAL
63654: IFFALSE 63658
// break ;
63656: GO 63734
// if GetClass ( i ) = 3 then
63658: LD_VAR 0 3
63662: PPUSH
63663: CALL_OW 257
63667: PUSH
63668: LD_INT 3
63670: EQUAL
63671: IFFALSE 63675
// continue ;
63673: GO 63641
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63675: LD_ADDR_VAR 0 11
63679: PUSH
63680: LD_VAR 0 11
63684: PPUSH
63685: LD_VAR 0 11
63689: PUSH
63690: LD_INT 1
63692: PLUS
63693: PPUSH
63694: LD_VAR 0 9
63698: PUSH
63699: LD_VAR 0 3
63703: ARRAY
63704: PPUSH
63705: CALL_OW 2
63709: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63710: LD_ADDR_VAR 0 4
63714: PUSH
63715: LD_VAR 0 4
63719: PUSH
63720: LD_VAR 0 9
63724: PUSH
63725: LD_VAR 0 3
63729: ARRAY
63730: DIFF
63731: ST_TO_ADDR
// end ;
63732: GO 63641
63734: POP
63735: POP
// if p then
63736: LD_VAR 0 11
63740: IFFALSE 63765
// result := Replace ( result , 3 , p ) ;
63742: LD_ADDR_VAR 0 2
63746: PUSH
63747: LD_VAR 0 2
63751: PPUSH
63752: LD_INT 3
63754: PPUSH
63755: LD_VAR 0 11
63759: PPUSH
63760: CALL_OW 1
63764: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
63765: LD_ADDR_VAR 0 4
63769: PUSH
63770: LD_VAR 0 4
63774: PUSH
63775: LD_VAR 0 6
63779: DIFF
63780: ST_TO_ADDR
// if tmp and eng < 6 then
63781: LD_VAR 0 4
63785: PUSH
63786: LD_VAR 0 6
63790: PUSH
63791: LD_INT 6
63793: LESS
63794: AND
63795: IFFALSE 63989
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63797: LD_ADDR_VAR 0 9
63801: PUSH
63802: LD_VAR 0 4
63806: PUSH
63807: LD_VAR 0 8
63811: PUSH
63812: LD_VAR 0 7
63816: UNION
63817: PUSH
63818: LD_VAR 0 6
63822: UNION
63823: DIFF
63824: PPUSH
63825: LD_INT 2
63827: PPUSH
63828: CALL 54890 0 2
63832: ST_TO_ADDR
// p := [ ] ;
63833: LD_ADDR_VAR 0 11
63837: PUSH
63838: EMPTY
63839: ST_TO_ADDR
// if sort then
63840: LD_VAR 0 9
63844: IFFALSE 63960
// for i = 1 to 6 - eng do
63846: LD_ADDR_VAR 0 3
63850: PUSH
63851: DOUBLE
63852: LD_INT 1
63854: DEC
63855: ST_TO_ADDR
63856: LD_INT 6
63858: PUSH
63859: LD_VAR 0 6
63863: MINUS
63864: PUSH
63865: FOR_TO
63866: IFFALSE 63958
// begin if i = sort then
63868: LD_VAR 0 3
63872: PUSH
63873: LD_VAR 0 9
63877: EQUAL
63878: IFFALSE 63882
// break ;
63880: GO 63958
// if GetClass ( i ) = 2 then
63882: LD_VAR 0 3
63886: PPUSH
63887: CALL_OW 257
63891: PUSH
63892: LD_INT 2
63894: EQUAL
63895: IFFALSE 63899
// continue ;
63897: GO 63865
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63899: LD_ADDR_VAR 0 11
63903: PUSH
63904: LD_VAR 0 11
63908: PPUSH
63909: LD_VAR 0 11
63913: PUSH
63914: LD_INT 1
63916: PLUS
63917: PPUSH
63918: LD_VAR 0 9
63922: PUSH
63923: LD_VAR 0 3
63927: ARRAY
63928: PPUSH
63929: CALL_OW 2
63933: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63934: LD_ADDR_VAR 0 4
63938: PUSH
63939: LD_VAR 0 4
63943: PUSH
63944: LD_VAR 0 9
63948: PUSH
63949: LD_VAR 0 3
63953: ARRAY
63954: DIFF
63955: ST_TO_ADDR
// end ;
63956: GO 63865
63958: POP
63959: POP
// if p then
63960: LD_VAR 0 11
63964: IFFALSE 63989
// result := Replace ( result , 2 , p ) ;
63966: LD_ADDR_VAR 0 2
63970: PUSH
63971: LD_VAR 0 2
63975: PPUSH
63976: LD_INT 2
63978: PPUSH
63979: LD_VAR 0 11
63983: PPUSH
63984: CALL_OW 1
63988: ST_TO_ADDR
// end ; exit ;
63989: GO 64713
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
63991: LD_EXP 85
63995: PUSH
63996: LD_EXP 84
64000: PUSH
64001: LD_VAR 0 1
64005: ARRAY
64006: ARRAY
64007: NOT
64008: PUSH
64009: LD_EXP 58
64013: PUSH
64014: LD_VAR 0 1
64018: ARRAY
64019: PPUSH
64020: LD_INT 30
64022: PUSH
64023: LD_INT 3
64025: PUSH
64026: EMPTY
64027: LIST
64028: LIST
64029: PPUSH
64030: CALL_OW 72
64034: AND
64035: PUSH
64036: LD_EXP 63
64040: PUSH
64041: LD_VAR 0 1
64045: ARRAY
64046: NOT
64047: AND
64048: IFFALSE 64713
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
64050: LD_ADDR_EXP 100
64054: PUSH
64055: LD_EXP 100
64059: PPUSH
64060: LD_VAR 0 1
64064: PPUSH
64065: LD_INT 6
64067: PPUSH
64068: CALL_OW 1
64072: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64073: LD_ADDR_VAR 0 2
64077: PUSH
64078: LD_INT 0
64080: PUSH
64081: LD_INT 0
64083: PUSH
64084: LD_INT 0
64086: PUSH
64087: LD_INT 0
64089: PUSH
64090: EMPTY
64091: LIST
64092: LIST
64093: LIST
64094: LIST
64095: ST_TO_ADDR
// if sci >= 1 then
64096: LD_VAR 0 8
64100: PUSH
64101: LD_INT 1
64103: GREATEREQUAL
64104: IFFALSE 64126
// tmp := tmp diff sci [ 1 ] ;
64106: LD_ADDR_VAR 0 4
64110: PUSH
64111: LD_VAR 0 4
64115: PUSH
64116: LD_VAR 0 8
64120: PUSH
64121: LD_INT 1
64123: ARRAY
64124: DIFF
64125: ST_TO_ADDR
// if tmp and not sci then
64126: LD_VAR 0 4
64130: PUSH
64131: LD_VAR 0 8
64135: NOT
64136: AND
64137: IFFALSE 64206
// begin sort := SortBySkill ( tmp , 4 ) ;
64139: LD_ADDR_VAR 0 9
64143: PUSH
64144: LD_VAR 0 4
64148: PPUSH
64149: LD_INT 4
64151: PPUSH
64152: CALL 54890 0 2
64156: ST_TO_ADDR
// if sort then
64157: LD_VAR 0 9
64161: IFFALSE 64177
// p := sort [ 1 ] ;
64163: LD_ADDR_VAR 0 11
64167: PUSH
64168: LD_VAR 0 9
64172: PUSH
64173: LD_INT 1
64175: ARRAY
64176: ST_TO_ADDR
// if p then
64177: LD_VAR 0 11
64181: IFFALSE 64206
// result := Replace ( result , 4 , p ) ;
64183: LD_ADDR_VAR 0 2
64187: PUSH
64188: LD_VAR 0 2
64192: PPUSH
64193: LD_INT 4
64195: PPUSH
64196: LD_VAR 0 11
64200: PPUSH
64201: CALL_OW 1
64205: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64206: LD_ADDR_VAR 0 4
64210: PUSH
64211: LD_VAR 0 4
64215: PUSH
64216: LD_VAR 0 7
64220: DIFF
64221: ST_TO_ADDR
// if tmp and mech < 6 then
64222: LD_VAR 0 4
64226: PUSH
64227: LD_VAR 0 7
64231: PUSH
64232: LD_INT 6
64234: LESS
64235: AND
64236: IFFALSE 64418
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
64238: LD_ADDR_VAR 0 9
64242: PUSH
64243: LD_VAR 0 4
64247: PUSH
64248: LD_VAR 0 7
64252: DIFF
64253: PPUSH
64254: LD_INT 3
64256: PPUSH
64257: CALL 54890 0 2
64261: ST_TO_ADDR
// p := [ ] ;
64262: LD_ADDR_VAR 0 11
64266: PUSH
64267: EMPTY
64268: ST_TO_ADDR
// if sort then
64269: LD_VAR 0 9
64273: IFFALSE 64389
// for i = 1 to 6 - mech do
64275: LD_ADDR_VAR 0 3
64279: PUSH
64280: DOUBLE
64281: LD_INT 1
64283: DEC
64284: ST_TO_ADDR
64285: LD_INT 6
64287: PUSH
64288: LD_VAR 0 7
64292: MINUS
64293: PUSH
64294: FOR_TO
64295: IFFALSE 64387
// begin if i = sort then
64297: LD_VAR 0 3
64301: PUSH
64302: LD_VAR 0 9
64306: EQUAL
64307: IFFALSE 64311
// break ;
64309: GO 64387
// if GetClass ( i ) = 3 then
64311: LD_VAR 0 3
64315: PPUSH
64316: CALL_OW 257
64320: PUSH
64321: LD_INT 3
64323: EQUAL
64324: IFFALSE 64328
// continue ;
64326: GO 64294
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64328: LD_ADDR_VAR 0 11
64332: PUSH
64333: LD_VAR 0 11
64337: PPUSH
64338: LD_VAR 0 11
64342: PUSH
64343: LD_INT 1
64345: PLUS
64346: PPUSH
64347: LD_VAR 0 9
64351: PUSH
64352: LD_VAR 0 3
64356: ARRAY
64357: PPUSH
64358: CALL_OW 2
64362: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64363: LD_ADDR_VAR 0 4
64367: PUSH
64368: LD_VAR 0 4
64372: PUSH
64373: LD_VAR 0 9
64377: PUSH
64378: LD_VAR 0 3
64382: ARRAY
64383: DIFF
64384: ST_TO_ADDR
// end ;
64385: GO 64294
64387: POP
64388: POP
// if p then
64389: LD_VAR 0 11
64393: IFFALSE 64418
// result := Replace ( result , 3 , p ) ;
64395: LD_ADDR_VAR 0 2
64399: PUSH
64400: LD_VAR 0 2
64404: PPUSH
64405: LD_INT 3
64407: PPUSH
64408: LD_VAR 0 11
64412: PPUSH
64413: CALL_OW 1
64417: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64418: LD_ADDR_VAR 0 4
64422: PUSH
64423: LD_VAR 0 4
64427: PUSH
64428: LD_VAR 0 6
64432: DIFF
64433: ST_TO_ADDR
// if tmp and eng < 4 then
64434: LD_VAR 0 4
64438: PUSH
64439: LD_VAR 0 6
64443: PUSH
64444: LD_INT 4
64446: LESS
64447: AND
64448: IFFALSE 64638
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
64450: LD_ADDR_VAR 0 9
64454: PUSH
64455: LD_VAR 0 4
64459: PUSH
64460: LD_VAR 0 7
64464: PUSH
64465: LD_VAR 0 6
64469: UNION
64470: DIFF
64471: PPUSH
64472: LD_INT 2
64474: PPUSH
64475: CALL 54890 0 2
64479: ST_TO_ADDR
// p := [ ] ;
64480: LD_ADDR_VAR 0 11
64484: PUSH
64485: EMPTY
64486: ST_TO_ADDR
// if sort then
64487: LD_VAR 0 9
64491: IFFALSE 64607
// for i = 1 to 4 - eng do
64493: LD_ADDR_VAR 0 3
64497: PUSH
64498: DOUBLE
64499: LD_INT 1
64501: DEC
64502: ST_TO_ADDR
64503: LD_INT 4
64505: PUSH
64506: LD_VAR 0 6
64510: MINUS
64511: PUSH
64512: FOR_TO
64513: IFFALSE 64605
// begin if i = sort then
64515: LD_VAR 0 3
64519: PUSH
64520: LD_VAR 0 9
64524: EQUAL
64525: IFFALSE 64529
// break ;
64527: GO 64605
// if GetClass ( i ) = 2 then
64529: LD_VAR 0 3
64533: PPUSH
64534: CALL_OW 257
64538: PUSH
64539: LD_INT 2
64541: EQUAL
64542: IFFALSE 64546
// continue ;
64544: GO 64512
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64546: LD_ADDR_VAR 0 11
64550: PUSH
64551: LD_VAR 0 11
64555: PPUSH
64556: LD_VAR 0 11
64560: PUSH
64561: LD_INT 1
64563: PLUS
64564: PPUSH
64565: LD_VAR 0 9
64569: PUSH
64570: LD_VAR 0 3
64574: ARRAY
64575: PPUSH
64576: CALL_OW 2
64580: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64581: LD_ADDR_VAR 0 4
64585: PUSH
64586: LD_VAR 0 4
64590: PUSH
64591: LD_VAR 0 9
64595: PUSH
64596: LD_VAR 0 3
64600: ARRAY
64601: DIFF
64602: ST_TO_ADDR
// end ;
64603: GO 64512
64605: POP
64606: POP
// if p then
64607: LD_VAR 0 11
64611: IFFALSE 64636
// result := Replace ( result , 2 , p ) ;
64613: LD_ADDR_VAR 0 2
64617: PUSH
64618: LD_VAR 0 2
64622: PPUSH
64623: LD_INT 2
64625: PPUSH
64626: LD_VAR 0 11
64630: PPUSH
64631: CALL_OW 1
64635: ST_TO_ADDR
// end else
64636: GO 64682
// for i = eng downto 5 do
64638: LD_ADDR_VAR 0 3
64642: PUSH
64643: DOUBLE
64644: LD_VAR 0 6
64648: INC
64649: ST_TO_ADDR
64650: LD_INT 5
64652: PUSH
64653: FOR_DOWNTO
64654: IFFALSE 64680
// tmp := tmp union eng [ i ] ;
64656: LD_ADDR_VAR 0 4
64660: PUSH
64661: LD_VAR 0 4
64665: PUSH
64666: LD_VAR 0 6
64670: PUSH
64671: LD_VAR 0 3
64675: ARRAY
64676: UNION
64677: ST_TO_ADDR
64678: GO 64653
64680: POP
64681: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
64682: LD_ADDR_VAR 0 2
64686: PUSH
64687: LD_VAR 0 2
64691: PPUSH
64692: LD_INT 1
64694: PPUSH
64695: LD_VAR 0 4
64699: PUSH
64700: LD_VAR 0 5
64704: DIFF
64705: PPUSH
64706: CALL_OW 1
64710: ST_TO_ADDR
// exit ;
64711: GO 64713
// end ; end ;
64713: LD_VAR 0 2
64717: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
64718: LD_INT 0
64720: PPUSH
64721: PPUSH
64722: PPUSH
// if not mc_bases then
64723: LD_EXP 58
64727: NOT
64728: IFFALSE 64732
// exit ;
64730: GO 64838
// for i = 1 to mc_bases do
64732: LD_ADDR_VAR 0 2
64736: PUSH
64737: DOUBLE
64738: LD_INT 1
64740: DEC
64741: ST_TO_ADDR
64742: LD_EXP 58
64746: PUSH
64747: FOR_TO
64748: IFFALSE 64829
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64750: LD_ADDR_VAR 0 3
64754: PUSH
64755: LD_EXP 58
64759: PUSH
64760: LD_VAR 0 2
64764: ARRAY
64765: PPUSH
64766: LD_INT 21
64768: PUSH
64769: LD_INT 3
64771: PUSH
64772: EMPTY
64773: LIST
64774: LIST
64775: PUSH
64776: LD_INT 3
64778: PUSH
64779: LD_INT 24
64781: PUSH
64782: LD_INT 1000
64784: PUSH
64785: EMPTY
64786: LIST
64787: LIST
64788: PUSH
64789: EMPTY
64790: LIST
64791: LIST
64792: PUSH
64793: EMPTY
64794: LIST
64795: LIST
64796: PPUSH
64797: CALL_OW 72
64801: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
64802: LD_ADDR_EXP 59
64806: PUSH
64807: LD_EXP 59
64811: PPUSH
64812: LD_VAR 0 2
64816: PPUSH
64817: LD_VAR 0 3
64821: PPUSH
64822: CALL_OW 1
64826: ST_TO_ADDR
// end ;
64827: GO 64747
64829: POP
64830: POP
// RaiseSailEvent ( 101 ) ;
64831: LD_INT 101
64833: PPUSH
64834: CALL_OW 427
// end ;
64838: LD_VAR 0 1
64842: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
64843: LD_INT 0
64845: PPUSH
64846: PPUSH
64847: PPUSH
64848: PPUSH
64849: PPUSH
64850: PPUSH
64851: PPUSH
// if not mc_bases then
64852: LD_EXP 58
64856: NOT
64857: IFFALSE 64861
// exit ;
64859: GO 65434
// for i = 1 to mc_bases do
64861: LD_ADDR_VAR 0 2
64865: PUSH
64866: DOUBLE
64867: LD_INT 1
64869: DEC
64870: ST_TO_ADDR
64871: LD_EXP 58
64875: PUSH
64876: FOR_TO
64877: IFFALSE 65425
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
64879: LD_ADDR_VAR 0 5
64883: PUSH
64884: LD_EXP 58
64888: PUSH
64889: LD_VAR 0 2
64893: ARRAY
64894: PUSH
64895: LD_EXP 87
64899: PUSH
64900: LD_VAR 0 2
64904: ARRAY
64905: UNION
64906: PPUSH
64907: LD_INT 21
64909: PUSH
64910: LD_INT 1
64912: PUSH
64913: EMPTY
64914: LIST
64915: LIST
64916: PUSH
64917: LD_INT 1
64919: PUSH
64920: LD_INT 3
64922: PUSH
64923: LD_INT 54
64925: PUSH
64926: EMPTY
64927: LIST
64928: PUSH
64929: EMPTY
64930: LIST
64931: LIST
64932: PUSH
64933: LD_INT 3
64935: PUSH
64936: LD_INT 24
64938: PUSH
64939: LD_INT 800
64941: PUSH
64942: EMPTY
64943: LIST
64944: LIST
64945: PUSH
64946: EMPTY
64947: LIST
64948: LIST
64949: PUSH
64950: EMPTY
64951: LIST
64952: LIST
64953: LIST
64954: PUSH
64955: EMPTY
64956: LIST
64957: LIST
64958: PPUSH
64959: CALL_OW 72
64963: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
64964: LD_ADDR_VAR 0 6
64968: PUSH
64969: LD_EXP 58
64973: PUSH
64974: LD_VAR 0 2
64978: ARRAY
64979: PPUSH
64980: LD_INT 21
64982: PUSH
64983: LD_INT 1
64985: PUSH
64986: EMPTY
64987: LIST
64988: LIST
64989: PUSH
64990: LD_INT 1
64992: PUSH
64993: LD_INT 3
64995: PUSH
64996: LD_INT 54
64998: PUSH
64999: EMPTY
65000: LIST
65001: PUSH
65002: EMPTY
65003: LIST
65004: LIST
65005: PUSH
65006: LD_INT 3
65008: PUSH
65009: LD_INT 24
65011: PUSH
65012: LD_INT 250
65014: PUSH
65015: EMPTY
65016: LIST
65017: LIST
65018: PUSH
65019: EMPTY
65020: LIST
65021: LIST
65022: PUSH
65023: EMPTY
65024: LIST
65025: LIST
65026: LIST
65027: PUSH
65028: EMPTY
65029: LIST
65030: LIST
65031: PPUSH
65032: CALL_OW 72
65036: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
65037: LD_ADDR_VAR 0 7
65041: PUSH
65042: LD_VAR 0 5
65046: PUSH
65047: LD_VAR 0 6
65051: DIFF
65052: ST_TO_ADDR
// if not need_heal_1 then
65053: LD_VAR 0 6
65057: NOT
65058: IFFALSE 65091
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
65060: LD_ADDR_EXP 61
65064: PUSH
65065: LD_EXP 61
65069: PPUSH
65070: LD_VAR 0 2
65074: PUSH
65075: LD_INT 1
65077: PUSH
65078: EMPTY
65079: LIST
65080: LIST
65081: PPUSH
65082: EMPTY
65083: PPUSH
65084: CALL 20642 0 3
65088: ST_TO_ADDR
65089: GO 65161
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
65091: LD_ADDR_EXP 61
65095: PUSH
65096: LD_EXP 61
65100: PPUSH
65101: LD_VAR 0 2
65105: PUSH
65106: LD_INT 1
65108: PUSH
65109: EMPTY
65110: LIST
65111: LIST
65112: PPUSH
65113: LD_EXP 61
65117: PUSH
65118: LD_VAR 0 2
65122: ARRAY
65123: PUSH
65124: LD_INT 1
65126: ARRAY
65127: PPUSH
65128: LD_INT 3
65130: PUSH
65131: LD_INT 24
65133: PUSH
65134: LD_INT 1000
65136: PUSH
65137: EMPTY
65138: LIST
65139: LIST
65140: PUSH
65141: EMPTY
65142: LIST
65143: LIST
65144: PPUSH
65145: CALL_OW 72
65149: PUSH
65150: LD_VAR 0 6
65154: UNION
65155: PPUSH
65156: CALL 20642 0 3
65160: ST_TO_ADDR
// if not need_heal_2 then
65161: LD_VAR 0 7
65165: NOT
65166: IFFALSE 65199
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
65168: LD_ADDR_EXP 61
65172: PUSH
65173: LD_EXP 61
65177: PPUSH
65178: LD_VAR 0 2
65182: PUSH
65183: LD_INT 2
65185: PUSH
65186: EMPTY
65187: LIST
65188: LIST
65189: PPUSH
65190: EMPTY
65191: PPUSH
65192: CALL 20642 0 3
65196: ST_TO_ADDR
65197: GO 65231
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
65199: LD_ADDR_EXP 61
65203: PUSH
65204: LD_EXP 61
65208: PPUSH
65209: LD_VAR 0 2
65213: PUSH
65214: LD_INT 2
65216: PUSH
65217: EMPTY
65218: LIST
65219: LIST
65220: PPUSH
65221: LD_VAR 0 7
65225: PPUSH
65226: CALL 20642 0 3
65230: ST_TO_ADDR
// if need_heal_2 then
65231: LD_VAR 0 7
65235: IFFALSE 65407
// for j in need_heal_2 do
65237: LD_ADDR_VAR 0 3
65241: PUSH
65242: LD_VAR 0 7
65246: PUSH
65247: FOR_IN
65248: IFFALSE 65405
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
65250: LD_ADDR_VAR 0 5
65254: PUSH
65255: LD_EXP 58
65259: PUSH
65260: LD_VAR 0 2
65264: ARRAY
65265: PPUSH
65266: LD_INT 2
65268: PUSH
65269: LD_INT 30
65271: PUSH
65272: LD_INT 6
65274: PUSH
65275: EMPTY
65276: LIST
65277: LIST
65278: PUSH
65279: LD_INT 30
65281: PUSH
65282: LD_INT 7
65284: PUSH
65285: EMPTY
65286: LIST
65287: LIST
65288: PUSH
65289: LD_INT 30
65291: PUSH
65292: LD_INT 8
65294: PUSH
65295: EMPTY
65296: LIST
65297: LIST
65298: PUSH
65299: LD_INT 30
65301: PUSH
65302: LD_INT 0
65304: PUSH
65305: EMPTY
65306: LIST
65307: LIST
65308: PUSH
65309: LD_INT 30
65311: PUSH
65312: LD_INT 1
65314: PUSH
65315: EMPTY
65316: LIST
65317: LIST
65318: PUSH
65319: LD_INT 25
65321: PUSH
65322: LD_INT 4
65324: PUSH
65325: EMPTY
65326: LIST
65327: LIST
65328: PUSH
65329: EMPTY
65330: LIST
65331: LIST
65332: LIST
65333: LIST
65334: LIST
65335: LIST
65336: LIST
65337: PPUSH
65338: CALL_OW 72
65342: ST_TO_ADDR
// if tmp then
65343: LD_VAR 0 5
65347: IFFALSE 65403
// begin k := NearestUnitToUnit ( tmp , j ) ;
65349: LD_ADDR_VAR 0 4
65353: PUSH
65354: LD_VAR 0 5
65358: PPUSH
65359: LD_VAR 0 3
65363: PPUSH
65364: CALL_OW 74
65368: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
65369: LD_VAR 0 3
65373: PPUSH
65374: LD_VAR 0 4
65378: PPUSH
65379: CALL_OW 296
65383: PUSH
65384: LD_INT 7
65386: GREATER
65387: IFFALSE 65403
// ComMoveUnit ( j , k ) ;
65389: LD_VAR 0 3
65393: PPUSH
65394: LD_VAR 0 4
65398: PPUSH
65399: CALL_OW 112
// end ; end ;
65403: GO 65247
65405: POP
65406: POP
// if not need_heal_1 and not need_heal_2 then
65407: LD_VAR 0 6
65411: NOT
65412: PUSH
65413: LD_VAR 0 7
65417: NOT
65418: AND
65419: IFFALSE 65423
// continue ;
65421: GO 64876
// end ;
65423: GO 64876
65425: POP
65426: POP
// RaiseSailEvent ( 102 ) ;
65427: LD_INT 102
65429: PPUSH
65430: CALL_OW 427
// end ;
65434: LD_VAR 0 1
65438: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
65439: LD_INT 0
65441: PPUSH
65442: PPUSH
65443: PPUSH
65444: PPUSH
65445: PPUSH
// if not mc_bases then
65446: LD_EXP 58
65450: NOT
65451: IFFALSE 65455
// exit ;
65453: GO 65840
// for i = 1 to mc_bases do
65455: LD_ADDR_VAR 0 2
65459: PUSH
65460: DOUBLE
65461: LD_INT 1
65463: DEC
65464: ST_TO_ADDR
65465: LD_EXP 58
65469: PUSH
65470: FOR_TO
65471: IFFALSE 65838
// begin if not mc_building_need_repair [ i ] then
65473: LD_EXP 59
65477: PUSH
65478: LD_VAR 0 2
65482: ARRAY
65483: NOT
65484: IFFALSE 65522
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
65486: LD_ADDR_EXP 60
65490: PUSH
65491: LD_EXP 60
65495: PPUSH
65496: LD_VAR 0 2
65500: PPUSH
65501: EMPTY
65502: PPUSH
65503: CALL_OW 1
65507: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
65508: LD_VAR 0 2
65512: PPUSH
65513: LD_INT 101
65515: PPUSH
65516: CALL 60560 0 2
// continue ;
65520: GO 65470
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
65522: LD_ADDR_EXP 64
65526: PUSH
65527: LD_EXP 64
65531: PPUSH
65532: LD_VAR 0 2
65536: PPUSH
65537: EMPTY
65538: PPUSH
65539: CALL_OW 1
65543: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65544: LD_VAR 0 2
65548: PPUSH
65549: LD_INT 103
65551: PPUSH
65552: CALL 60560 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
65556: LD_ADDR_VAR 0 5
65560: PUSH
65561: LD_EXP 58
65565: PUSH
65566: LD_VAR 0 2
65570: ARRAY
65571: PUSH
65572: LD_EXP 87
65576: PUSH
65577: LD_VAR 0 2
65581: ARRAY
65582: UNION
65583: PPUSH
65584: LD_INT 2
65586: PUSH
65587: LD_INT 25
65589: PUSH
65590: LD_INT 2
65592: PUSH
65593: EMPTY
65594: LIST
65595: LIST
65596: PUSH
65597: LD_INT 25
65599: PUSH
65600: LD_INT 16
65602: PUSH
65603: EMPTY
65604: LIST
65605: LIST
65606: PUSH
65607: EMPTY
65608: LIST
65609: LIST
65610: LIST
65611: PUSH
65612: EMPTY
65613: LIST
65614: PPUSH
65615: CALL_OW 72
65619: ST_TO_ADDR
// if not tmp then
65620: LD_VAR 0 5
65624: NOT
65625: IFFALSE 65629
// continue ;
65627: GO 65470
// for j in tmp do
65629: LD_ADDR_VAR 0 3
65633: PUSH
65634: LD_VAR 0 5
65638: PUSH
65639: FOR_IN
65640: IFFALSE 65834
// begin if mc_need_heal [ i ] then
65642: LD_EXP 61
65646: PUSH
65647: LD_VAR 0 2
65651: ARRAY
65652: IFFALSE 65700
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
65654: LD_VAR 0 3
65658: PUSH
65659: LD_EXP 61
65663: PUSH
65664: LD_VAR 0 2
65668: ARRAY
65669: PUSH
65670: LD_INT 1
65672: ARRAY
65673: IN
65674: PUSH
65675: LD_VAR 0 3
65679: PUSH
65680: LD_EXP 61
65684: PUSH
65685: LD_VAR 0 2
65689: ARRAY
65690: PUSH
65691: LD_INT 2
65693: ARRAY
65694: IN
65695: OR
65696: IFFALSE 65700
// continue ;
65698: GO 65639
// if IsInUnit ( j ) then
65700: LD_VAR 0 3
65704: PPUSH
65705: CALL_OW 310
65709: IFFALSE 65720
// ComExitBuilding ( j ) ;
65711: LD_VAR 0 3
65715: PPUSH
65716: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
65720: LD_VAR 0 3
65724: PUSH
65725: LD_EXP 60
65729: PUSH
65730: LD_VAR 0 2
65734: ARRAY
65735: IN
65736: NOT
65737: IFFALSE 65795
// begin SetTag ( j , 101 ) ;
65739: LD_VAR 0 3
65743: PPUSH
65744: LD_INT 101
65746: PPUSH
65747: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
65751: LD_ADDR_EXP 60
65755: PUSH
65756: LD_EXP 60
65760: PPUSH
65761: LD_VAR 0 2
65765: PUSH
65766: LD_EXP 60
65770: PUSH
65771: LD_VAR 0 2
65775: ARRAY
65776: PUSH
65777: LD_INT 1
65779: PLUS
65780: PUSH
65781: EMPTY
65782: LIST
65783: LIST
65784: PPUSH
65785: LD_VAR 0 3
65789: PPUSH
65790: CALL 20642 0 3
65794: ST_TO_ADDR
// end ; wait ( 1 ) ;
65795: LD_INT 1
65797: PPUSH
65798: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
65802: LD_VAR 0 3
65806: PPUSH
65807: LD_EXP 59
65811: PUSH
65812: LD_VAR 0 2
65816: ARRAY
65817: PPUSH
65818: LD_VAR 0 3
65822: PPUSH
65823: CALL_OW 74
65827: PPUSH
65828: CALL_OW 130
// end ;
65832: GO 65639
65834: POP
65835: POP
// end ;
65836: GO 65470
65838: POP
65839: POP
// end ;
65840: LD_VAR 0 1
65844: RET
// export function MC_Heal ; var i , j , tmp ; begin
65845: LD_INT 0
65847: PPUSH
65848: PPUSH
65849: PPUSH
65850: PPUSH
// if not mc_bases then
65851: LD_EXP 58
65855: NOT
65856: IFFALSE 65860
// exit ;
65858: GO 66262
// for i = 1 to mc_bases do
65860: LD_ADDR_VAR 0 2
65864: PUSH
65865: DOUBLE
65866: LD_INT 1
65868: DEC
65869: ST_TO_ADDR
65870: LD_EXP 58
65874: PUSH
65875: FOR_TO
65876: IFFALSE 66260
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
65878: LD_EXP 61
65882: PUSH
65883: LD_VAR 0 2
65887: ARRAY
65888: PUSH
65889: LD_INT 1
65891: ARRAY
65892: NOT
65893: PUSH
65894: LD_EXP 61
65898: PUSH
65899: LD_VAR 0 2
65903: ARRAY
65904: PUSH
65905: LD_INT 2
65907: ARRAY
65908: NOT
65909: AND
65910: IFFALSE 65948
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
65912: LD_ADDR_EXP 62
65916: PUSH
65917: LD_EXP 62
65921: PPUSH
65922: LD_VAR 0 2
65926: PPUSH
65927: EMPTY
65928: PPUSH
65929: CALL_OW 1
65933: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
65934: LD_VAR 0 2
65938: PPUSH
65939: LD_INT 102
65941: PPUSH
65942: CALL 60560 0 2
// continue ;
65946: GO 65875
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
65948: LD_ADDR_VAR 0 4
65952: PUSH
65953: LD_EXP 58
65957: PUSH
65958: LD_VAR 0 2
65962: ARRAY
65963: PPUSH
65964: LD_INT 25
65966: PUSH
65967: LD_INT 4
65969: PUSH
65970: EMPTY
65971: LIST
65972: LIST
65973: PPUSH
65974: CALL_OW 72
65978: ST_TO_ADDR
// if not tmp then
65979: LD_VAR 0 4
65983: NOT
65984: IFFALSE 65988
// continue ;
65986: GO 65875
// if mc_taming [ i ] then
65988: LD_EXP 89
65992: PUSH
65993: LD_VAR 0 2
65997: ARRAY
65998: IFFALSE 66022
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
66000: LD_ADDR_EXP 89
66004: PUSH
66005: LD_EXP 89
66009: PPUSH
66010: LD_VAR 0 2
66014: PPUSH
66015: EMPTY
66016: PPUSH
66017: CALL_OW 1
66021: ST_TO_ADDR
// for j in tmp do
66022: LD_ADDR_VAR 0 3
66026: PUSH
66027: LD_VAR 0 4
66031: PUSH
66032: FOR_IN
66033: IFFALSE 66256
// begin if IsInUnit ( j ) then
66035: LD_VAR 0 3
66039: PPUSH
66040: CALL_OW 310
66044: IFFALSE 66055
// ComExitBuilding ( j ) ;
66046: LD_VAR 0 3
66050: PPUSH
66051: CALL_OW 122
// if not j in mc_healers [ i ] then
66055: LD_VAR 0 3
66059: PUSH
66060: LD_EXP 62
66064: PUSH
66065: LD_VAR 0 2
66069: ARRAY
66070: IN
66071: NOT
66072: IFFALSE 66118
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
66074: LD_ADDR_EXP 62
66078: PUSH
66079: LD_EXP 62
66083: PPUSH
66084: LD_VAR 0 2
66088: PUSH
66089: LD_EXP 62
66093: PUSH
66094: LD_VAR 0 2
66098: ARRAY
66099: PUSH
66100: LD_INT 1
66102: PLUS
66103: PUSH
66104: EMPTY
66105: LIST
66106: LIST
66107: PPUSH
66108: LD_VAR 0 3
66112: PPUSH
66113: CALL 20642 0 3
66117: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
66118: LD_VAR 0 3
66122: PPUSH
66123: CALL_OW 110
66127: PUSH
66128: LD_INT 102
66130: NONEQUAL
66131: IFFALSE 66145
// SetTag ( j , 102 ) ;
66133: LD_VAR 0 3
66137: PPUSH
66138: LD_INT 102
66140: PPUSH
66141: CALL_OW 109
// Wait ( 3 ) ;
66145: LD_INT 3
66147: PPUSH
66148: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
66152: LD_EXP 61
66156: PUSH
66157: LD_VAR 0 2
66161: ARRAY
66162: PUSH
66163: LD_INT 1
66165: ARRAY
66166: IFFALSE 66198
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
66168: LD_VAR 0 3
66172: PPUSH
66173: LD_EXP 61
66177: PUSH
66178: LD_VAR 0 2
66182: ARRAY
66183: PUSH
66184: LD_INT 1
66186: ARRAY
66187: PUSH
66188: LD_INT 1
66190: ARRAY
66191: PPUSH
66192: CALL_OW 128
66196: GO 66254
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
66198: LD_VAR 0 3
66202: PPUSH
66203: CALL_OW 314
66207: NOT
66208: PUSH
66209: LD_EXP 61
66213: PUSH
66214: LD_VAR 0 2
66218: ARRAY
66219: PUSH
66220: LD_INT 2
66222: ARRAY
66223: AND
66224: IFFALSE 66254
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
66226: LD_VAR 0 3
66230: PPUSH
66231: LD_EXP 61
66235: PUSH
66236: LD_VAR 0 2
66240: ARRAY
66241: PUSH
66242: LD_INT 2
66244: ARRAY
66245: PUSH
66246: LD_INT 1
66248: ARRAY
66249: PPUSH
66250: CALL_OW 128
// end ;
66254: GO 66032
66256: POP
66257: POP
// end ;
66258: GO 65875
66260: POP
66261: POP
// end ;
66262: LD_VAR 0 1
66266: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
66267: LD_INT 0
66269: PPUSH
66270: PPUSH
66271: PPUSH
66272: PPUSH
66273: PPUSH
// if not mc_bases then
66274: LD_EXP 58
66278: NOT
66279: IFFALSE 66283
// exit ;
66281: GO 67426
// for i = 1 to mc_bases do
66283: LD_ADDR_VAR 0 2
66287: PUSH
66288: DOUBLE
66289: LD_INT 1
66291: DEC
66292: ST_TO_ADDR
66293: LD_EXP 58
66297: PUSH
66298: FOR_TO
66299: IFFALSE 67424
// begin if mc_scan [ i ] then
66301: LD_EXP 81
66305: PUSH
66306: LD_VAR 0 2
66310: ARRAY
66311: IFFALSE 66315
// continue ;
66313: GO 66298
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
66315: LD_EXP 63
66319: PUSH
66320: LD_VAR 0 2
66324: ARRAY
66325: NOT
66326: PUSH
66327: LD_EXP 65
66331: PUSH
66332: LD_VAR 0 2
66336: ARRAY
66337: NOT
66338: AND
66339: PUSH
66340: LD_EXP 64
66344: PUSH
66345: LD_VAR 0 2
66349: ARRAY
66350: AND
66351: IFFALSE 66389
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
66353: LD_ADDR_EXP 64
66357: PUSH
66358: LD_EXP 64
66362: PPUSH
66363: LD_VAR 0 2
66367: PPUSH
66368: EMPTY
66369: PPUSH
66370: CALL_OW 1
66374: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66375: LD_VAR 0 2
66379: PPUSH
66380: LD_INT 103
66382: PPUSH
66383: CALL 60560 0 2
// continue ;
66387: GO 66298
// end ; if mc_construct_list [ i ] then
66389: LD_EXP 65
66393: PUSH
66394: LD_VAR 0 2
66398: ARRAY
66399: IFFALSE 66619
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
66401: LD_ADDR_VAR 0 4
66405: PUSH
66406: LD_EXP 58
66410: PUSH
66411: LD_VAR 0 2
66415: ARRAY
66416: PPUSH
66417: LD_INT 25
66419: PUSH
66420: LD_INT 2
66422: PUSH
66423: EMPTY
66424: LIST
66425: LIST
66426: PPUSH
66427: CALL_OW 72
66431: PUSH
66432: LD_EXP 60
66436: PUSH
66437: LD_VAR 0 2
66441: ARRAY
66442: DIFF
66443: ST_TO_ADDR
// if not tmp then
66444: LD_VAR 0 4
66448: NOT
66449: IFFALSE 66453
// continue ;
66451: GO 66298
// for j in tmp do
66453: LD_ADDR_VAR 0 3
66457: PUSH
66458: LD_VAR 0 4
66462: PUSH
66463: FOR_IN
66464: IFFALSE 66615
// begin if not mc_builders [ i ] then
66466: LD_EXP 64
66470: PUSH
66471: LD_VAR 0 2
66475: ARRAY
66476: NOT
66477: IFFALSE 66535
// begin SetTag ( j , 103 ) ;
66479: LD_VAR 0 3
66483: PPUSH
66484: LD_INT 103
66486: PPUSH
66487: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
66491: LD_ADDR_EXP 64
66495: PUSH
66496: LD_EXP 64
66500: PPUSH
66501: LD_VAR 0 2
66505: PUSH
66506: LD_EXP 64
66510: PUSH
66511: LD_VAR 0 2
66515: ARRAY
66516: PUSH
66517: LD_INT 1
66519: PLUS
66520: PUSH
66521: EMPTY
66522: LIST
66523: LIST
66524: PPUSH
66525: LD_VAR 0 3
66529: PPUSH
66530: CALL 20642 0 3
66534: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
66535: LD_VAR 0 3
66539: PPUSH
66540: CALL_OW 310
66544: IFFALSE 66555
// ComExitBuilding ( j ) ;
66546: LD_VAR 0 3
66550: PPUSH
66551: CALL_OW 122
// wait ( 3 ) ;
66555: LD_INT 3
66557: PPUSH
66558: CALL_OW 67
// if not mc_construct_list [ i ] then
66562: LD_EXP 65
66566: PUSH
66567: LD_VAR 0 2
66571: ARRAY
66572: NOT
66573: IFFALSE 66577
// break ;
66575: GO 66615
// if not HasTask ( j ) then
66577: LD_VAR 0 3
66581: PPUSH
66582: CALL_OW 314
66586: NOT
66587: IFFALSE 66613
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
66589: LD_VAR 0 3
66593: PPUSH
66594: LD_EXP 65
66598: PUSH
66599: LD_VAR 0 2
66603: ARRAY
66604: PUSH
66605: LD_INT 1
66607: ARRAY
66608: PPUSH
66609: CALL 23493 0 2
// end ;
66613: GO 66463
66615: POP
66616: POP
// end else
66617: GO 67422
// if mc_build_list [ i ] then
66619: LD_EXP 63
66623: PUSH
66624: LD_VAR 0 2
66628: ARRAY
66629: IFFALSE 67422
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66631: LD_ADDR_VAR 0 5
66635: PUSH
66636: LD_EXP 58
66640: PUSH
66641: LD_VAR 0 2
66645: ARRAY
66646: PPUSH
66647: LD_INT 2
66649: PUSH
66650: LD_INT 30
66652: PUSH
66653: LD_INT 0
66655: PUSH
66656: EMPTY
66657: LIST
66658: LIST
66659: PUSH
66660: LD_INT 30
66662: PUSH
66663: LD_INT 1
66665: PUSH
66666: EMPTY
66667: LIST
66668: LIST
66669: PUSH
66670: EMPTY
66671: LIST
66672: LIST
66673: LIST
66674: PPUSH
66675: CALL_OW 72
66679: ST_TO_ADDR
// if depot then
66680: LD_VAR 0 5
66684: IFFALSE 66702
// depot := depot [ 1 ] else
66686: LD_ADDR_VAR 0 5
66690: PUSH
66691: LD_VAR 0 5
66695: PUSH
66696: LD_INT 1
66698: ARRAY
66699: ST_TO_ADDR
66700: GO 66710
// depot := 0 ;
66702: LD_ADDR_VAR 0 5
66706: PUSH
66707: LD_INT 0
66709: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
66710: LD_EXP 63
66714: PUSH
66715: LD_VAR 0 2
66719: ARRAY
66720: PUSH
66721: LD_INT 1
66723: ARRAY
66724: PUSH
66725: LD_INT 1
66727: ARRAY
66728: PPUSH
66729: CALL 23323 0 1
66733: PUSH
66734: LD_EXP 58
66738: PUSH
66739: LD_VAR 0 2
66743: ARRAY
66744: PPUSH
66745: LD_INT 2
66747: PUSH
66748: LD_INT 30
66750: PUSH
66751: LD_INT 2
66753: PUSH
66754: EMPTY
66755: LIST
66756: LIST
66757: PUSH
66758: LD_INT 30
66760: PUSH
66761: LD_INT 3
66763: PUSH
66764: EMPTY
66765: LIST
66766: LIST
66767: PUSH
66768: EMPTY
66769: LIST
66770: LIST
66771: LIST
66772: PPUSH
66773: CALL_OW 72
66777: NOT
66778: AND
66779: IFFALSE 66884
// begin for j = 1 to mc_build_list [ i ] do
66781: LD_ADDR_VAR 0 3
66785: PUSH
66786: DOUBLE
66787: LD_INT 1
66789: DEC
66790: ST_TO_ADDR
66791: LD_EXP 63
66795: PUSH
66796: LD_VAR 0 2
66800: ARRAY
66801: PUSH
66802: FOR_TO
66803: IFFALSE 66882
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
66805: LD_EXP 63
66809: PUSH
66810: LD_VAR 0 2
66814: ARRAY
66815: PUSH
66816: LD_VAR 0 3
66820: ARRAY
66821: PUSH
66822: LD_INT 1
66824: ARRAY
66825: PUSH
66826: LD_INT 2
66828: EQUAL
66829: IFFALSE 66880
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
66831: LD_ADDR_EXP 63
66835: PUSH
66836: LD_EXP 63
66840: PPUSH
66841: LD_VAR 0 2
66845: PPUSH
66846: LD_EXP 63
66850: PUSH
66851: LD_VAR 0 2
66855: ARRAY
66856: PPUSH
66857: LD_VAR 0 3
66861: PPUSH
66862: LD_INT 1
66864: PPUSH
66865: LD_INT 0
66867: PPUSH
66868: CALL 20060 0 4
66872: PPUSH
66873: CALL_OW 1
66877: ST_TO_ADDR
// break ;
66878: GO 66882
// end ;
66880: GO 66802
66882: POP
66883: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
66884: LD_EXP 63
66888: PUSH
66889: LD_VAR 0 2
66893: ARRAY
66894: PUSH
66895: LD_INT 1
66897: ARRAY
66898: PUSH
66899: LD_INT 1
66901: ARRAY
66902: PUSH
66903: LD_INT 0
66905: EQUAL
66906: PUSH
66907: LD_VAR 0 5
66911: PUSH
66912: LD_VAR 0 5
66916: PPUSH
66917: LD_EXP 63
66921: PUSH
66922: LD_VAR 0 2
66926: ARRAY
66927: PUSH
66928: LD_INT 1
66930: ARRAY
66931: PUSH
66932: LD_INT 1
66934: ARRAY
66935: PPUSH
66936: LD_EXP 63
66940: PUSH
66941: LD_VAR 0 2
66945: ARRAY
66946: PUSH
66947: LD_INT 1
66949: ARRAY
66950: PUSH
66951: LD_INT 2
66953: ARRAY
66954: PPUSH
66955: LD_EXP 63
66959: PUSH
66960: LD_VAR 0 2
66964: ARRAY
66965: PUSH
66966: LD_INT 1
66968: ARRAY
66969: PUSH
66970: LD_INT 3
66972: ARRAY
66973: PPUSH
66974: LD_EXP 63
66978: PUSH
66979: LD_VAR 0 2
66983: ARRAY
66984: PUSH
66985: LD_INT 1
66987: ARRAY
66988: PUSH
66989: LD_INT 4
66991: ARRAY
66992: PPUSH
66993: CALL 28057 0 5
66997: AND
66998: OR
66999: IFFALSE 67280
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67001: LD_ADDR_VAR 0 4
67005: PUSH
67006: LD_EXP 58
67010: PUSH
67011: LD_VAR 0 2
67015: ARRAY
67016: PPUSH
67017: LD_INT 25
67019: PUSH
67020: LD_INT 2
67022: PUSH
67023: EMPTY
67024: LIST
67025: LIST
67026: PPUSH
67027: CALL_OW 72
67031: PUSH
67032: LD_EXP 60
67036: PUSH
67037: LD_VAR 0 2
67041: ARRAY
67042: DIFF
67043: ST_TO_ADDR
// if not tmp then
67044: LD_VAR 0 4
67048: NOT
67049: IFFALSE 67053
// continue ;
67051: GO 66298
// for j in tmp do
67053: LD_ADDR_VAR 0 3
67057: PUSH
67058: LD_VAR 0 4
67062: PUSH
67063: FOR_IN
67064: IFFALSE 67276
// begin if not mc_builders [ i ] then
67066: LD_EXP 64
67070: PUSH
67071: LD_VAR 0 2
67075: ARRAY
67076: NOT
67077: IFFALSE 67135
// begin SetTag ( j , 103 ) ;
67079: LD_VAR 0 3
67083: PPUSH
67084: LD_INT 103
67086: PPUSH
67087: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67091: LD_ADDR_EXP 64
67095: PUSH
67096: LD_EXP 64
67100: PPUSH
67101: LD_VAR 0 2
67105: PUSH
67106: LD_EXP 64
67110: PUSH
67111: LD_VAR 0 2
67115: ARRAY
67116: PUSH
67117: LD_INT 1
67119: PLUS
67120: PUSH
67121: EMPTY
67122: LIST
67123: LIST
67124: PPUSH
67125: LD_VAR 0 3
67129: PPUSH
67130: CALL 20642 0 3
67134: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67135: LD_VAR 0 3
67139: PPUSH
67140: CALL_OW 310
67144: IFFALSE 67155
// ComExitBuilding ( j ) ;
67146: LD_VAR 0 3
67150: PPUSH
67151: CALL_OW 122
// wait ( 3 ) ;
67155: LD_INT 3
67157: PPUSH
67158: CALL_OW 67
// if not mc_build_list [ i ] then
67162: LD_EXP 63
67166: PUSH
67167: LD_VAR 0 2
67171: ARRAY
67172: NOT
67173: IFFALSE 67177
// break ;
67175: GO 67276
// if not HasTask ( j ) then
67177: LD_VAR 0 3
67181: PPUSH
67182: CALL_OW 314
67186: NOT
67187: IFFALSE 67274
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
67189: LD_VAR 0 3
67193: PPUSH
67194: LD_EXP 63
67198: PUSH
67199: LD_VAR 0 2
67203: ARRAY
67204: PUSH
67205: LD_INT 1
67207: ARRAY
67208: PUSH
67209: LD_INT 1
67211: ARRAY
67212: PPUSH
67213: LD_EXP 63
67217: PUSH
67218: LD_VAR 0 2
67222: ARRAY
67223: PUSH
67224: LD_INT 1
67226: ARRAY
67227: PUSH
67228: LD_INT 2
67230: ARRAY
67231: PPUSH
67232: LD_EXP 63
67236: PUSH
67237: LD_VAR 0 2
67241: ARRAY
67242: PUSH
67243: LD_INT 1
67245: ARRAY
67246: PUSH
67247: LD_INT 3
67249: ARRAY
67250: PPUSH
67251: LD_EXP 63
67255: PUSH
67256: LD_VAR 0 2
67260: ARRAY
67261: PUSH
67262: LD_INT 1
67264: ARRAY
67265: PUSH
67266: LD_INT 4
67268: ARRAY
67269: PPUSH
67270: CALL_OW 145
// end ;
67274: GO 67063
67276: POP
67277: POP
// end else
67278: GO 67422
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
67280: LD_EXP 58
67284: PUSH
67285: LD_VAR 0 2
67289: ARRAY
67290: PPUSH
67291: LD_EXP 63
67295: PUSH
67296: LD_VAR 0 2
67300: ARRAY
67301: PUSH
67302: LD_INT 1
67304: ARRAY
67305: PUSH
67306: LD_INT 1
67308: ARRAY
67309: PPUSH
67310: LD_EXP 63
67314: PUSH
67315: LD_VAR 0 2
67319: ARRAY
67320: PUSH
67321: LD_INT 1
67323: ARRAY
67324: PUSH
67325: LD_INT 2
67327: ARRAY
67328: PPUSH
67329: LD_EXP 63
67333: PUSH
67334: LD_VAR 0 2
67338: ARRAY
67339: PUSH
67340: LD_INT 1
67342: ARRAY
67343: PUSH
67344: LD_INT 3
67346: ARRAY
67347: PPUSH
67348: LD_EXP 63
67352: PUSH
67353: LD_VAR 0 2
67357: ARRAY
67358: PUSH
67359: LD_INT 1
67361: ARRAY
67362: PUSH
67363: LD_INT 4
67365: ARRAY
67366: PPUSH
67367: CALL 27393 0 5
67371: NOT
67372: IFFALSE 67422
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
67374: LD_ADDR_EXP 63
67378: PUSH
67379: LD_EXP 63
67383: PPUSH
67384: LD_VAR 0 2
67388: PPUSH
67389: LD_EXP 63
67393: PUSH
67394: LD_VAR 0 2
67398: ARRAY
67399: PPUSH
67400: LD_INT 1
67402: PPUSH
67403: LD_INT 1
67405: NEG
67406: PPUSH
67407: LD_INT 0
67409: PPUSH
67410: CALL 20060 0 4
67414: PPUSH
67415: CALL_OW 1
67419: ST_TO_ADDR
// continue ;
67420: GO 66298
// end ; end ; end ;
67422: GO 66298
67424: POP
67425: POP
// end ;
67426: LD_VAR 0 1
67430: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
67431: LD_INT 0
67433: PPUSH
67434: PPUSH
67435: PPUSH
67436: PPUSH
67437: PPUSH
67438: PPUSH
// if not mc_bases then
67439: LD_EXP 58
67443: NOT
67444: IFFALSE 67448
// exit ;
67446: GO 67875
// for i = 1 to mc_bases do
67448: LD_ADDR_VAR 0 2
67452: PUSH
67453: DOUBLE
67454: LD_INT 1
67456: DEC
67457: ST_TO_ADDR
67458: LD_EXP 58
67462: PUSH
67463: FOR_TO
67464: IFFALSE 67873
// begin tmp := mc_build_upgrade [ i ] ;
67466: LD_ADDR_VAR 0 4
67470: PUSH
67471: LD_EXP 90
67475: PUSH
67476: LD_VAR 0 2
67480: ARRAY
67481: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
67482: LD_ADDR_VAR 0 6
67486: PUSH
67487: LD_EXP 91
67491: PUSH
67492: LD_VAR 0 2
67496: ARRAY
67497: PPUSH
67498: LD_INT 2
67500: PUSH
67501: LD_INT 30
67503: PUSH
67504: LD_INT 6
67506: PUSH
67507: EMPTY
67508: LIST
67509: LIST
67510: PUSH
67511: LD_INT 30
67513: PUSH
67514: LD_INT 7
67516: PUSH
67517: EMPTY
67518: LIST
67519: LIST
67520: PUSH
67521: EMPTY
67522: LIST
67523: LIST
67524: LIST
67525: PPUSH
67526: CALL_OW 72
67530: ST_TO_ADDR
// if not tmp and not lab then
67531: LD_VAR 0 4
67535: NOT
67536: PUSH
67537: LD_VAR 0 6
67541: NOT
67542: AND
67543: IFFALSE 67547
// continue ;
67545: GO 67463
// if tmp then
67547: LD_VAR 0 4
67551: IFFALSE 67671
// for j in tmp do
67553: LD_ADDR_VAR 0 3
67557: PUSH
67558: LD_VAR 0 4
67562: PUSH
67563: FOR_IN
67564: IFFALSE 67669
// begin if UpgradeCost ( j ) then
67566: LD_VAR 0 3
67570: PPUSH
67571: CALL 27053 0 1
67575: IFFALSE 67667
// begin ComUpgrade ( j ) ;
67577: LD_VAR 0 3
67581: PPUSH
67582: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
67586: LD_ADDR_EXP 90
67590: PUSH
67591: LD_EXP 90
67595: PPUSH
67596: LD_VAR 0 2
67600: PPUSH
67601: LD_EXP 90
67605: PUSH
67606: LD_VAR 0 2
67610: ARRAY
67611: PUSH
67612: LD_VAR 0 3
67616: DIFF
67617: PPUSH
67618: CALL_OW 1
67622: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
67623: LD_ADDR_EXP 65
67627: PUSH
67628: LD_EXP 65
67632: PPUSH
67633: LD_VAR 0 2
67637: PUSH
67638: LD_EXP 65
67642: PUSH
67643: LD_VAR 0 2
67647: ARRAY
67648: PUSH
67649: LD_INT 1
67651: PLUS
67652: PUSH
67653: EMPTY
67654: LIST
67655: LIST
67656: PPUSH
67657: LD_VAR 0 3
67661: PPUSH
67662: CALL 20642 0 3
67666: ST_TO_ADDR
// end ; end ;
67667: GO 67563
67669: POP
67670: POP
// if not lab or not mc_lab_upgrade [ i ] then
67671: LD_VAR 0 6
67675: NOT
67676: PUSH
67677: LD_EXP 92
67681: PUSH
67682: LD_VAR 0 2
67686: ARRAY
67687: NOT
67688: OR
67689: IFFALSE 67693
// continue ;
67691: GO 67463
// for j in lab do
67693: LD_ADDR_VAR 0 3
67697: PUSH
67698: LD_VAR 0 6
67702: PUSH
67703: FOR_IN
67704: IFFALSE 67869
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
67706: LD_VAR 0 3
67710: PPUSH
67711: CALL_OW 266
67715: PUSH
67716: LD_INT 6
67718: PUSH
67719: LD_INT 7
67721: PUSH
67722: EMPTY
67723: LIST
67724: LIST
67725: IN
67726: PUSH
67727: LD_VAR 0 3
67731: PPUSH
67732: CALL_OW 461
67736: PUSH
67737: LD_INT 1
67739: NONEQUAL
67740: AND
67741: IFFALSE 67867
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
67743: LD_VAR 0 3
67747: PPUSH
67748: LD_EXP 92
67752: PUSH
67753: LD_VAR 0 2
67757: ARRAY
67758: PUSH
67759: LD_INT 1
67761: ARRAY
67762: PPUSH
67763: CALL 27258 0 2
67767: IFFALSE 67867
// begin ComCancel ( j ) ;
67769: LD_VAR 0 3
67773: PPUSH
67774: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
67778: LD_VAR 0 3
67782: PPUSH
67783: LD_EXP 92
67787: PUSH
67788: LD_VAR 0 2
67792: ARRAY
67793: PUSH
67794: LD_INT 1
67796: ARRAY
67797: PPUSH
67798: CALL_OW 207
// if not j in mc_construct_list [ i ] then
67802: LD_VAR 0 3
67806: PUSH
67807: LD_EXP 65
67811: PUSH
67812: LD_VAR 0 2
67816: ARRAY
67817: IN
67818: NOT
67819: IFFALSE 67865
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
67821: LD_ADDR_EXP 65
67825: PUSH
67826: LD_EXP 65
67830: PPUSH
67831: LD_VAR 0 2
67835: PUSH
67836: LD_EXP 65
67840: PUSH
67841: LD_VAR 0 2
67845: ARRAY
67846: PUSH
67847: LD_INT 1
67849: PLUS
67850: PUSH
67851: EMPTY
67852: LIST
67853: LIST
67854: PPUSH
67855: LD_VAR 0 3
67859: PPUSH
67860: CALL 20642 0 3
67864: ST_TO_ADDR
// break ;
67865: GO 67869
// end ; end ; end ;
67867: GO 67703
67869: POP
67870: POP
// end ;
67871: GO 67463
67873: POP
67874: POP
// end ;
67875: LD_VAR 0 1
67879: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
67880: LD_INT 0
67882: PPUSH
67883: PPUSH
67884: PPUSH
67885: PPUSH
67886: PPUSH
67887: PPUSH
67888: PPUSH
67889: PPUSH
67890: PPUSH
// if not mc_bases then
67891: LD_EXP 58
67895: NOT
67896: IFFALSE 67900
// exit ;
67898: GO 68305
// for i = 1 to mc_bases do
67900: LD_ADDR_VAR 0 2
67904: PUSH
67905: DOUBLE
67906: LD_INT 1
67908: DEC
67909: ST_TO_ADDR
67910: LD_EXP 58
67914: PUSH
67915: FOR_TO
67916: IFFALSE 68303
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
67918: LD_EXP 66
67922: PUSH
67923: LD_VAR 0 2
67927: ARRAY
67928: NOT
67929: PUSH
67930: LD_EXP 58
67934: PUSH
67935: LD_VAR 0 2
67939: ARRAY
67940: PPUSH
67941: LD_INT 30
67943: PUSH
67944: LD_INT 3
67946: PUSH
67947: EMPTY
67948: LIST
67949: LIST
67950: PPUSH
67951: CALL_OW 72
67955: NOT
67956: OR
67957: IFFALSE 67961
// continue ;
67959: GO 67915
// busy := false ;
67961: LD_ADDR_VAR 0 8
67965: PUSH
67966: LD_INT 0
67968: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67969: LD_ADDR_VAR 0 4
67973: PUSH
67974: LD_EXP 58
67978: PUSH
67979: LD_VAR 0 2
67983: ARRAY
67984: PPUSH
67985: LD_INT 30
67987: PUSH
67988: LD_INT 3
67990: PUSH
67991: EMPTY
67992: LIST
67993: LIST
67994: PPUSH
67995: CALL_OW 72
67999: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
68000: LD_ADDR_VAR 0 6
68004: PUSH
68005: LD_EXP 66
68009: PUSH
68010: LD_VAR 0 2
68014: ARRAY
68015: PPUSH
68016: LD_INT 2
68018: PUSH
68019: LD_INT 30
68021: PUSH
68022: LD_INT 32
68024: PUSH
68025: EMPTY
68026: LIST
68027: LIST
68028: PUSH
68029: LD_INT 30
68031: PUSH
68032: LD_INT 33
68034: PUSH
68035: EMPTY
68036: LIST
68037: LIST
68038: PUSH
68039: EMPTY
68040: LIST
68041: LIST
68042: LIST
68043: PPUSH
68044: CALL_OW 72
68048: ST_TO_ADDR
// if not t then
68049: LD_VAR 0 6
68053: NOT
68054: IFFALSE 68058
// continue ;
68056: GO 67915
// for j in tmp do
68058: LD_ADDR_VAR 0 3
68062: PUSH
68063: LD_VAR 0 4
68067: PUSH
68068: FOR_IN
68069: IFFALSE 68099
// if not BuildingStatus ( j ) = bs_idle then
68071: LD_VAR 0 3
68075: PPUSH
68076: CALL_OW 461
68080: PUSH
68081: LD_INT 2
68083: EQUAL
68084: NOT
68085: IFFALSE 68097
// begin busy := true ;
68087: LD_ADDR_VAR 0 8
68091: PUSH
68092: LD_INT 1
68094: ST_TO_ADDR
// break ;
68095: GO 68099
// end ;
68097: GO 68068
68099: POP
68100: POP
// if busy then
68101: LD_VAR 0 8
68105: IFFALSE 68109
// continue ;
68107: GO 67915
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
68109: LD_ADDR_VAR 0 7
68113: PUSH
68114: LD_VAR 0 6
68118: PPUSH
68119: LD_INT 35
68121: PUSH
68122: LD_INT 0
68124: PUSH
68125: EMPTY
68126: LIST
68127: LIST
68128: PPUSH
68129: CALL_OW 72
68133: ST_TO_ADDR
// if tw then
68134: LD_VAR 0 7
68138: IFFALSE 68215
// begin tw := tw [ 1 ] ;
68140: LD_ADDR_VAR 0 7
68144: PUSH
68145: LD_VAR 0 7
68149: PUSH
68150: LD_INT 1
68152: ARRAY
68153: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
68154: LD_ADDR_VAR 0 9
68158: PUSH
68159: LD_VAR 0 7
68163: PPUSH
68164: LD_EXP 83
68168: PUSH
68169: LD_VAR 0 2
68173: ARRAY
68174: PPUSH
68175: CALL 25612 0 2
68179: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
68180: LD_EXP 97
68184: PUSH
68185: LD_VAR 0 2
68189: ARRAY
68190: IFFALSE 68213
// if not weapon in mc_allowed_tower_weapons [ i ] then
68192: LD_VAR 0 9
68196: PUSH
68197: LD_EXP 97
68201: PUSH
68202: LD_VAR 0 2
68206: ARRAY
68207: IN
68208: NOT
68209: IFFALSE 68213
// continue ;
68211: GO 67915
// end else
68213: GO 68278
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
68215: LD_ADDR_VAR 0 5
68219: PUSH
68220: LD_EXP 66
68224: PUSH
68225: LD_VAR 0 2
68229: ARRAY
68230: PPUSH
68231: LD_VAR 0 4
68235: PPUSH
68236: CALL 55813 0 2
68240: ST_TO_ADDR
// if not tmp2 then
68241: LD_VAR 0 5
68245: NOT
68246: IFFALSE 68250
// continue ;
68248: GO 67915
// tw := tmp2 [ 1 ] ;
68250: LD_ADDR_VAR 0 7
68254: PUSH
68255: LD_VAR 0 5
68259: PUSH
68260: LD_INT 1
68262: ARRAY
68263: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
68264: LD_ADDR_VAR 0 9
68268: PUSH
68269: LD_VAR 0 5
68273: PUSH
68274: LD_INT 2
68276: ARRAY
68277: ST_TO_ADDR
// end ; if not weapon then
68278: LD_VAR 0 9
68282: NOT
68283: IFFALSE 68287
// continue ;
68285: GO 67915
// ComPlaceWeapon ( tw , weapon ) ;
68287: LD_VAR 0 7
68291: PPUSH
68292: LD_VAR 0 9
68296: PPUSH
68297: CALL_OW 148
// end ;
68301: GO 67915
68303: POP
68304: POP
// end ;
68305: LD_VAR 0 1
68309: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
68310: LD_INT 0
68312: PPUSH
68313: PPUSH
68314: PPUSH
68315: PPUSH
68316: PPUSH
68317: PPUSH
// if not mc_bases then
68318: LD_EXP 58
68322: NOT
68323: IFFALSE 68327
// exit ;
68325: GO 69339
// for i = 1 to mc_bases do
68327: LD_ADDR_VAR 0 2
68331: PUSH
68332: DOUBLE
68333: LD_INT 1
68335: DEC
68336: ST_TO_ADDR
68337: LD_EXP 58
68341: PUSH
68342: FOR_TO
68343: IFFALSE 69337
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
68345: LD_EXP 71
68349: PUSH
68350: LD_VAR 0 2
68354: ARRAY
68355: NOT
68356: PUSH
68357: LD_EXP 71
68361: PUSH
68362: LD_VAR 0 2
68366: ARRAY
68367: PUSH
68368: LD_EXP 72
68372: PUSH
68373: LD_VAR 0 2
68377: ARRAY
68378: EQUAL
68379: OR
68380: IFFALSE 68384
// continue ;
68382: GO 68342
// if mc_miners [ i ] then
68384: LD_EXP 72
68388: PUSH
68389: LD_VAR 0 2
68393: ARRAY
68394: IFFALSE 69024
// begin k := 1 ;
68396: LD_ADDR_VAR 0 4
68400: PUSH
68401: LD_INT 1
68403: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
68404: LD_ADDR_VAR 0 3
68408: PUSH
68409: DOUBLE
68410: LD_EXP 72
68414: PUSH
68415: LD_VAR 0 2
68419: ARRAY
68420: INC
68421: ST_TO_ADDR
68422: LD_INT 1
68424: PUSH
68425: FOR_DOWNTO
68426: IFFALSE 69022
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
68428: LD_EXP 72
68432: PUSH
68433: LD_VAR 0 2
68437: ARRAY
68438: PUSH
68439: LD_VAR 0 3
68443: ARRAY
68444: PPUSH
68445: CALL_OW 301
68449: PUSH
68450: LD_EXP 72
68454: PUSH
68455: LD_VAR 0 2
68459: ARRAY
68460: PUSH
68461: LD_VAR 0 3
68465: ARRAY
68466: PPUSH
68467: CALL_OW 257
68471: PUSH
68472: LD_INT 1
68474: NONEQUAL
68475: OR
68476: IFFALSE 68539
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
68478: LD_ADDR_VAR 0 5
68482: PUSH
68483: LD_EXP 72
68487: PUSH
68488: LD_VAR 0 2
68492: ARRAY
68493: PUSH
68494: LD_EXP 72
68498: PUSH
68499: LD_VAR 0 2
68503: ARRAY
68504: PUSH
68505: LD_VAR 0 3
68509: ARRAY
68510: DIFF
68511: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
68512: LD_ADDR_EXP 72
68516: PUSH
68517: LD_EXP 72
68521: PPUSH
68522: LD_VAR 0 2
68526: PPUSH
68527: LD_VAR 0 5
68531: PPUSH
68532: CALL_OW 1
68536: ST_TO_ADDR
// continue ;
68537: GO 68425
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
68539: LD_EXP 72
68543: PUSH
68544: LD_VAR 0 2
68548: ARRAY
68549: PUSH
68550: LD_VAR 0 3
68554: ARRAY
68555: PPUSH
68556: CALL 20578 0 1
68560: PUSH
68561: LD_EXP 72
68565: PUSH
68566: LD_VAR 0 2
68570: ARRAY
68571: PUSH
68572: LD_VAR 0 3
68576: ARRAY
68577: PPUSH
68578: CALL_OW 255
68582: PPUSH
68583: LD_EXP 71
68587: PUSH
68588: LD_VAR 0 2
68592: ARRAY
68593: PUSH
68594: LD_VAR 0 4
68598: ARRAY
68599: PUSH
68600: LD_INT 1
68602: ARRAY
68603: PPUSH
68604: LD_EXP 71
68608: PUSH
68609: LD_VAR 0 2
68613: ARRAY
68614: PUSH
68615: LD_VAR 0 4
68619: ARRAY
68620: PUSH
68621: LD_INT 2
68623: ARRAY
68624: PPUSH
68625: LD_INT 15
68627: PPUSH
68628: CALL 21538 0 4
68632: PUSH
68633: LD_INT 4
68635: ARRAY
68636: PUSH
68637: LD_EXP 72
68641: PUSH
68642: LD_VAR 0 2
68646: ARRAY
68647: PUSH
68648: LD_VAR 0 3
68652: ARRAY
68653: PPUSH
68654: LD_INT 10
68656: PPUSH
68657: CALL 23235 0 2
68661: PUSH
68662: LD_INT 4
68664: ARRAY
68665: OR
68666: AND
68667: IFFALSE 68690
// ComStop ( mc_miners [ i ] [ j ] ) ;
68669: LD_EXP 72
68673: PUSH
68674: LD_VAR 0 2
68678: ARRAY
68679: PUSH
68680: LD_VAR 0 3
68684: ARRAY
68685: PPUSH
68686: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
68690: LD_EXP 72
68694: PUSH
68695: LD_VAR 0 2
68699: ARRAY
68700: PUSH
68701: LD_VAR 0 3
68705: ARRAY
68706: PPUSH
68707: CALL_OW 257
68711: PUSH
68712: LD_INT 1
68714: EQUAL
68715: PUSH
68716: LD_EXP 72
68720: PUSH
68721: LD_VAR 0 2
68725: ARRAY
68726: PUSH
68727: LD_VAR 0 3
68731: ARRAY
68732: PPUSH
68733: CALL_OW 459
68737: NOT
68738: AND
68739: PUSH
68740: LD_EXP 72
68744: PUSH
68745: LD_VAR 0 2
68749: ARRAY
68750: PUSH
68751: LD_VAR 0 3
68755: ARRAY
68756: PPUSH
68757: CALL_OW 255
68761: PPUSH
68762: LD_EXP 71
68766: PUSH
68767: LD_VAR 0 2
68771: ARRAY
68772: PUSH
68773: LD_VAR 0 4
68777: ARRAY
68778: PUSH
68779: LD_INT 1
68781: ARRAY
68782: PPUSH
68783: LD_EXP 71
68787: PUSH
68788: LD_VAR 0 2
68792: ARRAY
68793: PUSH
68794: LD_VAR 0 4
68798: ARRAY
68799: PUSH
68800: LD_INT 2
68802: ARRAY
68803: PPUSH
68804: LD_INT 15
68806: PPUSH
68807: CALL 21538 0 4
68811: PUSH
68812: LD_INT 4
68814: ARRAY
68815: PUSH
68816: LD_INT 0
68818: EQUAL
68819: AND
68820: PUSH
68821: LD_EXP 72
68825: PUSH
68826: LD_VAR 0 2
68830: ARRAY
68831: PUSH
68832: LD_VAR 0 3
68836: ARRAY
68837: PPUSH
68838: CALL_OW 314
68842: NOT
68843: AND
68844: IFFALSE 69020
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
68846: LD_EXP 72
68850: PUSH
68851: LD_VAR 0 2
68855: ARRAY
68856: PUSH
68857: LD_VAR 0 3
68861: ARRAY
68862: PPUSH
68863: CALL_OW 310
68867: IFFALSE 68890
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
68869: LD_EXP 72
68873: PUSH
68874: LD_VAR 0 2
68878: ARRAY
68879: PUSH
68880: LD_VAR 0 3
68884: ARRAY
68885: PPUSH
68886: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
68890: LD_EXP 72
68894: PUSH
68895: LD_VAR 0 2
68899: ARRAY
68900: PUSH
68901: LD_VAR 0 3
68905: ARRAY
68906: PPUSH
68907: CALL_OW 314
68911: NOT
68912: IFFALSE 68980
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
68914: LD_EXP 72
68918: PUSH
68919: LD_VAR 0 2
68923: ARRAY
68924: PUSH
68925: LD_VAR 0 3
68929: ARRAY
68930: PPUSH
68931: LD_EXP 71
68935: PUSH
68936: LD_VAR 0 2
68940: ARRAY
68941: PUSH
68942: LD_VAR 0 4
68946: ARRAY
68947: PUSH
68948: LD_INT 1
68950: ARRAY
68951: PPUSH
68952: LD_EXP 71
68956: PUSH
68957: LD_VAR 0 2
68961: ARRAY
68962: PUSH
68963: LD_VAR 0 4
68967: ARRAY
68968: PUSH
68969: LD_INT 2
68971: ARRAY
68972: PPUSH
68973: LD_INT 0
68975: PPUSH
68976: CALL_OW 193
// k := k + 1 ;
68980: LD_ADDR_VAR 0 4
68984: PUSH
68985: LD_VAR 0 4
68989: PUSH
68990: LD_INT 1
68992: PLUS
68993: ST_TO_ADDR
// if k > mc_mines [ i ] then
68994: LD_VAR 0 4
68998: PUSH
68999: LD_EXP 71
69003: PUSH
69004: LD_VAR 0 2
69008: ARRAY
69009: GREATER
69010: IFFALSE 69020
// k := 1 ;
69012: LD_ADDR_VAR 0 4
69016: PUSH
69017: LD_INT 1
69019: ST_TO_ADDR
// end ; end ;
69020: GO 68425
69022: POP
69023: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
69024: LD_ADDR_VAR 0 5
69028: PUSH
69029: LD_EXP 58
69033: PUSH
69034: LD_VAR 0 2
69038: ARRAY
69039: PPUSH
69040: LD_INT 2
69042: PUSH
69043: LD_INT 30
69045: PUSH
69046: LD_INT 4
69048: PUSH
69049: EMPTY
69050: LIST
69051: LIST
69052: PUSH
69053: LD_INT 30
69055: PUSH
69056: LD_INT 5
69058: PUSH
69059: EMPTY
69060: LIST
69061: LIST
69062: PUSH
69063: LD_INT 30
69065: PUSH
69066: LD_INT 32
69068: PUSH
69069: EMPTY
69070: LIST
69071: LIST
69072: PUSH
69073: EMPTY
69074: LIST
69075: LIST
69076: LIST
69077: LIST
69078: PPUSH
69079: CALL_OW 72
69083: ST_TO_ADDR
// if not tmp then
69084: LD_VAR 0 5
69088: NOT
69089: IFFALSE 69093
// continue ;
69091: GO 68342
// list := [ ] ;
69093: LD_ADDR_VAR 0 6
69097: PUSH
69098: EMPTY
69099: ST_TO_ADDR
// for j in tmp do
69100: LD_ADDR_VAR 0 3
69104: PUSH
69105: LD_VAR 0 5
69109: PUSH
69110: FOR_IN
69111: IFFALSE 69180
// begin for k in UnitsInside ( j ) do
69113: LD_ADDR_VAR 0 4
69117: PUSH
69118: LD_VAR 0 3
69122: PPUSH
69123: CALL_OW 313
69127: PUSH
69128: FOR_IN
69129: IFFALSE 69176
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
69131: LD_VAR 0 4
69135: PPUSH
69136: CALL_OW 257
69140: PUSH
69141: LD_INT 1
69143: EQUAL
69144: PUSH
69145: LD_VAR 0 4
69149: PPUSH
69150: CALL_OW 459
69154: NOT
69155: AND
69156: IFFALSE 69174
// list := list ^ k ;
69158: LD_ADDR_VAR 0 6
69162: PUSH
69163: LD_VAR 0 6
69167: PUSH
69168: LD_VAR 0 4
69172: ADD
69173: ST_TO_ADDR
69174: GO 69128
69176: POP
69177: POP
// end ;
69178: GO 69110
69180: POP
69181: POP
// list := list diff mc_miners [ i ] ;
69182: LD_ADDR_VAR 0 6
69186: PUSH
69187: LD_VAR 0 6
69191: PUSH
69192: LD_EXP 72
69196: PUSH
69197: LD_VAR 0 2
69201: ARRAY
69202: DIFF
69203: ST_TO_ADDR
// if not list then
69204: LD_VAR 0 6
69208: NOT
69209: IFFALSE 69213
// continue ;
69211: GO 68342
// k := mc_mines [ i ] - mc_miners [ i ] ;
69213: LD_ADDR_VAR 0 4
69217: PUSH
69218: LD_EXP 71
69222: PUSH
69223: LD_VAR 0 2
69227: ARRAY
69228: PUSH
69229: LD_EXP 72
69233: PUSH
69234: LD_VAR 0 2
69238: ARRAY
69239: MINUS
69240: ST_TO_ADDR
// if k > list then
69241: LD_VAR 0 4
69245: PUSH
69246: LD_VAR 0 6
69250: GREATER
69251: IFFALSE 69263
// k := list ;
69253: LD_ADDR_VAR 0 4
69257: PUSH
69258: LD_VAR 0 6
69262: ST_TO_ADDR
// for j = 1 to k do
69263: LD_ADDR_VAR 0 3
69267: PUSH
69268: DOUBLE
69269: LD_INT 1
69271: DEC
69272: ST_TO_ADDR
69273: LD_VAR 0 4
69277: PUSH
69278: FOR_TO
69279: IFFALSE 69333
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
69281: LD_ADDR_EXP 72
69285: PUSH
69286: LD_EXP 72
69290: PPUSH
69291: LD_VAR 0 2
69295: PUSH
69296: LD_EXP 72
69300: PUSH
69301: LD_VAR 0 2
69305: ARRAY
69306: PUSH
69307: LD_INT 1
69309: PLUS
69310: PUSH
69311: EMPTY
69312: LIST
69313: LIST
69314: PPUSH
69315: LD_VAR 0 6
69319: PUSH
69320: LD_VAR 0 3
69324: ARRAY
69325: PPUSH
69326: CALL 20642 0 3
69330: ST_TO_ADDR
69331: GO 69278
69333: POP
69334: POP
// end ;
69335: GO 68342
69337: POP
69338: POP
// end ;
69339: LD_VAR 0 1
69343: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
69344: LD_INT 0
69346: PPUSH
69347: PPUSH
69348: PPUSH
69349: PPUSH
69350: PPUSH
69351: PPUSH
69352: PPUSH
69353: PPUSH
69354: PPUSH
69355: PPUSH
// if not mc_bases then
69356: LD_EXP 58
69360: NOT
69361: IFFALSE 69365
// exit ;
69363: GO 71096
// for i = 1 to mc_bases do
69365: LD_ADDR_VAR 0 2
69369: PUSH
69370: DOUBLE
69371: LD_INT 1
69373: DEC
69374: ST_TO_ADDR
69375: LD_EXP 58
69379: PUSH
69380: FOR_TO
69381: IFFALSE 71094
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
69383: LD_EXP 58
69387: PUSH
69388: LD_VAR 0 2
69392: ARRAY
69393: NOT
69394: PUSH
69395: LD_EXP 65
69399: PUSH
69400: LD_VAR 0 2
69404: ARRAY
69405: OR
69406: IFFALSE 69410
// continue ;
69408: GO 69380
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
69410: LD_EXP 74
69414: PUSH
69415: LD_VAR 0 2
69419: ARRAY
69420: NOT
69421: PUSH
69422: LD_EXP 75
69426: PUSH
69427: LD_VAR 0 2
69431: ARRAY
69432: AND
69433: IFFALSE 69471
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
69435: LD_ADDR_EXP 75
69439: PUSH
69440: LD_EXP 75
69444: PPUSH
69445: LD_VAR 0 2
69449: PPUSH
69450: EMPTY
69451: PPUSH
69452: CALL_OW 1
69456: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
69457: LD_VAR 0 2
69461: PPUSH
69462: LD_INT 107
69464: PPUSH
69465: CALL 60560 0 2
// continue ;
69469: GO 69380
// end ; target := [ ] ;
69471: LD_ADDR_VAR 0 6
69475: PUSH
69476: EMPTY
69477: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
69478: LD_ADDR_VAR 0 3
69482: PUSH
69483: DOUBLE
69484: LD_EXP 74
69488: PUSH
69489: LD_VAR 0 2
69493: ARRAY
69494: INC
69495: ST_TO_ADDR
69496: LD_INT 1
69498: PUSH
69499: FOR_DOWNTO
69500: IFFALSE 69760
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
69502: LD_EXP 74
69506: PUSH
69507: LD_VAR 0 2
69511: ARRAY
69512: PUSH
69513: LD_VAR 0 3
69517: ARRAY
69518: PUSH
69519: LD_INT 2
69521: ARRAY
69522: PPUSH
69523: LD_EXP 74
69527: PUSH
69528: LD_VAR 0 2
69532: ARRAY
69533: PUSH
69534: LD_VAR 0 3
69538: ARRAY
69539: PUSH
69540: LD_INT 3
69542: ARRAY
69543: PPUSH
69544: CALL_OW 488
69548: PUSH
69549: LD_EXP 74
69553: PUSH
69554: LD_VAR 0 2
69558: ARRAY
69559: PUSH
69560: LD_VAR 0 3
69564: ARRAY
69565: PUSH
69566: LD_INT 2
69568: ARRAY
69569: PPUSH
69570: LD_EXP 74
69574: PUSH
69575: LD_VAR 0 2
69579: ARRAY
69580: PUSH
69581: LD_VAR 0 3
69585: ARRAY
69586: PUSH
69587: LD_INT 3
69589: ARRAY
69590: PPUSH
69591: CALL_OW 284
69595: PUSH
69596: LD_INT 0
69598: EQUAL
69599: AND
69600: IFFALSE 69655
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
69602: LD_ADDR_VAR 0 5
69606: PUSH
69607: LD_EXP 74
69611: PUSH
69612: LD_VAR 0 2
69616: ARRAY
69617: PPUSH
69618: LD_VAR 0 3
69622: PPUSH
69623: CALL_OW 3
69627: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
69628: LD_ADDR_EXP 74
69632: PUSH
69633: LD_EXP 74
69637: PPUSH
69638: LD_VAR 0 2
69642: PPUSH
69643: LD_VAR 0 5
69647: PPUSH
69648: CALL_OW 1
69652: ST_TO_ADDR
// continue ;
69653: GO 69499
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
69655: LD_EXP 58
69659: PUSH
69660: LD_VAR 0 2
69664: ARRAY
69665: PUSH
69666: LD_INT 1
69668: ARRAY
69669: PPUSH
69670: CALL_OW 255
69674: PPUSH
69675: LD_EXP 74
69679: PUSH
69680: LD_VAR 0 2
69684: ARRAY
69685: PUSH
69686: LD_VAR 0 3
69690: ARRAY
69691: PUSH
69692: LD_INT 2
69694: ARRAY
69695: PPUSH
69696: LD_EXP 74
69700: PUSH
69701: LD_VAR 0 2
69705: ARRAY
69706: PUSH
69707: LD_VAR 0 3
69711: ARRAY
69712: PUSH
69713: LD_INT 3
69715: ARRAY
69716: PPUSH
69717: LD_INT 30
69719: PPUSH
69720: CALL 21538 0 4
69724: PUSH
69725: LD_INT 4
69727: ARRAY
69728: PUSH
69729: LD_INT 0
69731: EQUAL
69732: IFFALSE 69758
// begin target := mc_crates [ i ] [ j ] ;
69734: LD_ADDR_VAR 0 6
69738: PUSH
69739: LD_EXP 74
69743: PUSH
69744: LD_VAR 0 2
69748: ARRAY
69749: PUSH
69750: LD_VAR 0 3
69754: ARRAY
69755: ST_TO_ADDR
// break ;
69756: GO 69760
// end ; end ;
69758: GO 69499
69760: POP
69761: POP
// if not target then
69762: LD_VAR 0 6
69766: NOT
69767: IFFALSE 69771
// continue ;
69769: GO 69380
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
69771: LD_ADDR_VAR 0 7
69775: PUSH
69776: LD_EXP 77
69780: PUSH
69781: LD_VAR 0 2
69785: ARRAY
69786: PPUSH
69787: LD_INT 2
69789: PUSH
69790: LD_INT 3
69792: PUSH
69793: LD_INT 58
69795: PUSH
69796: EMPTY
69797: LIST
69798: PUSH
69799: EMPTY
69800: LIST
69801: LIST
69802: PUSH
69803: LD_INT 61
69805: PUSH
69806: EMPTY
69807: LIST
69808: PUSH
69809: LD_INT 33
69811: PUSH
69812: LD_INT 5
69814: PUSH
69815: EMPTY
69816: LIST
69817: LIST
69818: PUSH
69819: LD_INT 33
69821: PUSH
69822: LD_INT 3
69824: PUSH
69825: EMPTY
69826: LIST
69827: LIST
69828: PUSH
69829: EMPTY
69830: LIST
69831: LIST
69832: LIST
69833: LIST
69834: LIST
69835: PUSH
69836: LD_INT 2
69838: PUSH
69839: LD_INT 34
69841: PUSH
69842: LD_INT 32
69844: PUSH
69845: EMPTY
69846: LIST
69847: LIST
69848: PUSH
69849: LD_INT 34
69851: PUSH
69852: LD_INT 51
69854: PUSH
69855: EMPTY
69856: LIST
69857: LIST
69858: PUSH
69859: LD_INT 34
69861: PUSH
69862: LD_INT 12
69864: PUSH
69865: EMPTY
69866: LIST
69867: LIST
69868: PUSH
69869: EMPTY
69870: LIST
69871: LIST
69872: LIST
69873: LIST
69874: PUSH
69875: EMPTY
69876: LIST
69877: LIST
69878: PPUSH
69879: CALL_OW 72
69883: ST_TO_ADDR
// if not cargo then
69884: LD_VAR 0 7
69888: NOT
69889: IFFALSE 70532
// begin if mc_crates_collector [ i ] < 5 then
69891: LD_EXP 75
69895: PUSH
69896: LD_VAR 0 2
69900: ARRAY
69901: PUSH
69902: LD_INT 5
69904: LESS
69905: IFFALSE 70271
// begin if mc_ape [ i ] then
69907: LD_EXP 87
69911: PUSH
69912: LD_VAR 0 2
69916: ARRAY
69917: IFFALSE 69964
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
69919: LD_ADDR_VAR 0 5
69923: PUSH
69924: LD_EXP 87
69928: PUSH
69929: LD_VAR 0 2
69933: ARRAY
69934: PPUSH
69935: LD_INT 25
69937: PUSH
69938: LD_INT 16
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: PUSH
69945: LD_INT 24
69947: PUSH
69948: LD_INT 750
69950: PUSH
69951: EMPTY
69952: LIST
69953: LIST
69954: PUSH
69955: EMPTY
69956: LIST
69957: LIST
69958: PPUSH
69959: CALL_OW 72
69963: ST_TO_ADDR
// if not tmp then
69964: LD_VAR 0 5
69968: NOT
69969: IFFALSE 70016
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
69971: LD_ADDR_VAR 0 5
69975: PUSH
69976: LD_EXP 58
69980: PUSH
69981: LD_VAR 0 2
69985: ARRAY
69986: PPUSH
69987: LD_INT 25
69989: PUSH
69990: LD_INT 2
69992: PUSH
69993: EMPTY
69994: LIST
69995: LIST
69996: PUSH
69997: LD_INT 24
69999: PUSH
70000: LD_INT 750
70002: PUSH
70003: EMPTY
70004: LIST
70005: LIST
70006: PUSH
70007: EMPTY
70008: LIST
70009: LIST
70010: PPUSH
70011: CALL_OW 72
70015: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
70016: LD_EXP 87
70020: PUSH
70021: LD_VAR 0 2
70025: ARRAY
70026: PUSH
70027: LD_EXP 58
70031: PUSH
70032: LD_VAR 0 2
70036: ARRAY
70037: PPUSH
70038: LD_INT 25
70040: PUSH
70041: LD_INT 2
70043: PUSH
70044: EMPTY
70045: LIST
70046: LIST
70047: PUSH
70048: LD_INT 24
70050: PUSH
70051: LD_INT 750
70053: PUSH
70054: EMPTY
70055: LIST
70056: LIST
70057: PUSH
70058: EMPTY
70059: LIST
70060: LIST
70061: PPUSH
70062: CALL_OW 72
70066: AND
70067: PUSH
70068: LD_VAR 0 5
70072: PUSH
70073: LD_INT 5
70075: LESS
70076: AND
70077: IFFALSE 70159
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
70079: LD_ADDR_VAR 0 3
70083: PUSH
70084: LD_EXP 58
70088: PUSH
70089: LD_VAR 0 2
70093: ARRAY
70094: PPUSH
70095: LD_INT 25
70097: PUSH
70098: LD_INT 2
70100: PUSH
70101: EMPTY
70102: LIST
70103: LIST
70104: PUSH
70105: LD_INT 24
70107: PUSH
70108: LD_INT 750
70110: PUSH
70111: EMPTY
70112: LIST
70113: LIST
70114: PUSH
70115: EMPTY
70116: LIST
70117: LIST
70118: PPUSH
70119: CALL_OW 72
70123: PUSH
70124: FOR_IN
70125: IFFALSE 70157
// begin tmp := tmp union j ;
70127: LD_ADDR_VAR 0 5
70131: PUSH
70132: LD_VAR 0 5
70136: PUSH
70137: LD_VAR 0 3
70141: UNION
70142: ST_TO_ADDR
// if tmp >= 5 then
70143: LD_VAR 0 5
70147: PUSH
70148: LD_INT 5
70150: GREATEREQUAL
70151: IFFALSE 70155
// break ;
70153: GO 70157
// end ;
70155: GO 70124
70157: POP
70158: POP
// end ; if not tmp then
70159: LD_VAR 0 5
70163: NOT
70164: IFFALSE 70168
// continue ;
70166: GO 69380
// for j in tmp do
70168: LD_ADDR_VAR 0 3
70172: PUSH
70173: LD_VAR 0 5
70177: PUSH
70178: FOR_IN
70179: IFFALSE 70269
// if not GetTag ( j ) then
70181: LD_VAR 0 3
70185: PPUSH
70186: CALL_OW 110
70190: NOT
70191: IFFALSE 70267
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
70193: LD_ADDR_EXP 75
70197: PUSH
70198: LD_EXP 75
70202: PPUSH
70203: LD_VAR 0 2
70207: PUSH
70208: LD_EXP 75
70212: PUSH
70213: LD_VAR 0 2
70217: ARRAY
70218: PUSH
70219: LD_INT 1
70221: PLUS
70222: PUSH
70223: EMPTY
70224: LIST
70225: LIST
70226: PPUSH
70227: LD_VAR 0 3
70231: PPUSH
70232: CALL 20642 0 3
70236: ST_TO_ADDR
// SetTag ( j , 107 ) ;
70237: LD_VAR 0 3
70241: PPUSH
70242: LD_INT 107
70244: PPUSH
70245: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
70249: LD_EXP 75
70253: PUSH
70254: LD_VAR 0 2
70258: ARRAY
70259: PUSH
70260: LD_INT 5
70262: GREATEREQUAL
70263: IFFALSE 70267
// break ;
70265: GO 70269
// end ;
70267: GO 70178
70269: POP
70270: POP
// end ; if mc_crates_collector [ i ] and target then
70271: LD_EXP 75
70275: PUSH
70276: LD_VAR 0 2
70280: ARRAY
70281: PUSH
70282: LD_VAR 0 6
70286: AND
70287: IFFALSE 70530
// begin if mc_crates_collector [ i ] < target [ 1 ] then
70289: LD_EXP 75
70293: PUSH
70294: LD_VAR 0 2
70298: ARRAY
70299: PUSH
70300: LD_VAR 0 6
70304: PUSH
70305: LD_INT 1
70307: ARRAY
70308: LESS
70309: IFFALSE 70329
// tmp := mc_crates_collector [ i ] else
70311: LD_ADDR_VAR 0 5
70315: PUSH
70316: LD_EXP 75
70320: PUSH
70321: LD_VAR 0 2
70325: ARRAY
70326: ST_TO_ADDR
70327: GO 70343
// tmp := target [ 1 ] ;
70329: LD_ADDR_VAR 0 5
70333: PUSH
70334: LD_VAR 0 6
70338: PUSH
70339: LD_INT 1
70341: ARRAY
70342: ST_TO_ADDR
// k := 0 ;
70343: LD_ADDR_VAR 0 4
70347: PUSH
70348: LD_INT 0
70350: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
70351: LD_ADDR_VAR 0 3
70355: PUSH
70356: LD_EXP 75
70360: PUSH
70361: LD_VAR 0 2
70365: ARRAY
70366: PUSH
70367: FOR_IN
70368: IFFALSE 70528
// begin k := k + 1 ;
70370: LD_ADDR_VAR 0 4
70374: PUSH
70375: LD_VAR 0 4
70379: PUSH
70380: LD_INT 1
70382: PLUS
70383: ST_TO_ADDR
// if k > tmp then
70384: LD_VAR 0 4
70388: PUSH
70389: LD_VAR 0 5
70393: GREATER
70394: IFFALSE 70398
// break ;
70396: GO 70528
// if not GetClass ( j ) in [ 2 , 16 ] then
70398: LD_VAR 0 3
70402: PPUSH
70403: CALL_OW 257
70407: PUSH
70408: LD_INT 2
70410: PUSH
70411: LD_INT 16
70413: PUSH
70414: EMPTY
70415: LIST
70416: LIST
70417: IN
70418: NOT
70419: IFFALSE 70472
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
70421: LD_ADDR_EXP 75
70425: PUSH
70426: LD_EXP 75
70430: PPUSH
70431: LD_VAR 0 2
70435: PPUSH
70436: LD_EXP 75
70440: PUSH
70441: LD_VAR 0 2
70445: ARRAY
70446: PUSH
70447: LD_VAR 0 3
70451: DIFF
70452: PPUSH
70453: CALL_OW 1
70457: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70458: LD_VAR 0 3
70462: PPUSH
70463: LD_INT 0
70465: PPUSH
70466: CALL_OW 109
// continue ;
70470: GO 70367
// end ; if IsInUnit ( j ) then
70472: LD_VAR 0 3
70476: PPUSH
70477: CALL_OW 310
70481: IFFALSE 70492
// ComExitBuilding ( j ) ;
70483: LD_VAR 0 3
70487: PPUSH
70488: CALL_OW 122
// wait ( 3 ) ;
70492: LD_INT 3
70494: PPUSH
70495: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
70499: LD_VAR 0 3
70503: PPUSH
70504: LD_VAR 0 6
70508: PUSH
70509: LD_INT 2
70511: ARRAY
70512: PPUSH
70513: LD_VAR 0 6
70517: PUSH
70518: LD_INT 3
70520: ARRAY
70521: PPUSH
70522: CALL_OW 117
// end ;
70526: GO 70367
70528: POP
70529: POP
// end ; end else
70530: GO 71092
// begin for j in cargo do
70532: LD_ADDR_VAR 0 3
70536: PUSH
70537: LD_VAR 0 7
70541: PUSH
70542: FOR_IN
70543: IFFALSE 71090
// begin if GetTag ( j ) <> 0 then
70545: LD_VAR 0 3
70549: PPUSH
70550: CALL_OW 110
70554: PUSH
70555: LD_INT 0
70557: NONEQUAL
70558: IFFALSE 70562
// continue ;
70560: GO 70542
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
70562: LD_VAR 0 3
70566: PPUSH
70567: CALL_OW 256
70571: PUSH
70572: LD_INT 1000
70574: LESS
70575: PUSH
70576: LD_VAR 0 3
70580: PPUSH
70581: LD_EXP 82
70585: PUSH
70586: LD_VAR 0 2
70590: ARRAY
70591: PPUSH
70592: CALL_OW 308
70596: NOT
70597: AND
70598: IFFALSE 70620
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70600: LD_VAR 0 3
70604: PPUSH
70605: LD_EXP 82
70609: PUSH
70610: LD_VAR 0 2
70614: ARRAY
70615: PPUSH
70616: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
70620: LD_VAR 0 3
70624: PPUSH
70625: CALL_OW 256
70629: PUSH
70630: LD_INT 1000
70632: LESS
70633: PUSH
70634: LD_VAR 0 3
70638: PPUSH
70639: LD_EXP 82
70643: PUSH
70644: LD_VAR 0 2
70648: ARRAY
70649: PPUSH
70650: CALL_OW 308
70654: AND
70655: IFFALSE 70659
// continue ;
70657: GO 70542
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
70659: LD_VAR 0 3
70663: PPUSH
70664: CALL_OW 262
70668: PUSH
70669: LD_INT 2
70671: EQUAL
70672: PUSH
70673: LD_VAR 0 3
70677: PPUSH
70678: CALL_OW 261
70682: PUSH
70683: LD_INT 15
70685: LESS
70686: AND
70687: IFFALSE 70691
// continue ;
70689: GO 70542
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
70691: LD_VAR 0 3
70695: PPUSH
70696: CALL_OW 262
70700: PUSH
70701: LD_INT 1
70703: EQUAL
70704: PUSH
70705: LD_VAR 0 3
70709: PPUSH
70710: CALL_OW 261
70714: PUSH
70715: LD_INT 10
70717: LESS
70718: AND
70719: IFFALSE 71029
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70721: LD_ADDR_VAR 0 8
70725: PUSH
70726: LD_EXP 58
70730: PUSH
70731: LD_VAR 0 2
70735: ARRAY
70736: PPUSH
70737: LD_INT 2
70739: PUSH
70740: LD_INT 30
70742: PUSH
70743: LD_INT 0
70745: PUSH
70746: EMPTY
70747: LIST
70748: LIST
70749: PUSH
70750: LD_INT 30
70752: PUSH
70753: LD_INT 1
70755: PUSH
70756: EMPTY
70757: LIST
70758: LIST
70759: PUSH
70760: EMPTY
70761: LIST
70762: LIST
70763: LIST
70764: PPUSH
70765: CALL_OW 72
70769: ST_TO_ADDR
// if not depot then
70770: LD_VAR 0 8
70774: NOT
70775: IFFALSE 70779
// continue ;
70777: GO 70542
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
70779: LD_VAR 0 3
70783: PPUSH
70784: LD_VAR 0 8
70788: PPUSH
70789: LD_VAR 0 3
70793: PPUSH
70794: CALL_OW 74
70798: PPUSH
70799: CALL_OW 296
70803: PUSH
70804: LD_INT 6
70806: LESS
70807: IFFALSE 70823
// SetFuel ( j , 100 ) else
70809: LD_VAR 0 3
70813: PPUSH
70814: LD_INT 100
70816: PPUSH
70817: CALL_OW 240
70821: GO 71029
// if GetFuel ( j ) = 0 then
70823: LD_VAR 0 3
70827: PPUSH
70828: CALL_OW 261
70832: PUSH
70833: LD_INT 0
70835: EQUAL
70836: IFFALSE 71029
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
70838: LD_ADDR_EXP 77
70842: PUSH
70843: LD_EXP 77
70847: PPUSH
70848: LD_VAR 0 2
70852: PPUSH
70853: LD_EXP 77
70857: PUSH
70858: LD_VAR 0 2
70862: ARRAY
70863: PUSH
70864: LD_VAR 0 3
70868: DIFF
70869: PPUSH
70870: CALL_OW 1
70874: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
70875: LD_VAR 0 3
70879: PPUSH
70880: CALL_OW 263
70884: PUSH
70885: LD_INT 1
70887: EQUAL
70888: IFFALSE 70904
// ComExitVehicle ( IsInUnit ( j ) ) ;
70890: LD_VAR 0 3
70894: PPUSH
70895: CALL_OW 310
70899: PPUSH
70900: CALL_OW 121
// if GetControl ( j ) = control_remote then
70904: LD_VAR 0 3
70908: PPUSH
70909: CALL_OW 263
70913: PUSH
70914: LD_INT 2
70916: EQUAL
70917: IFFALSE 70928
// ComUnlink ( j ) ;
70919: LD_VAR 0 3
70923: PPUSH
70924: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
70928: LD_ADDR_VAR 0 9
70932: PUSH
70933: LD_VAR 0 2
70937: PPUSH
70938: LD_INT 3
70940: PPUSH
70941: CALL 80075 0 2
70945: ST_TO_ADDR
// if fac then
70946: LD_VAR 0 9
70950: IFFALSE 71027
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
70952: LD_ADDR_VAR 0 10
70956: PUSH
70957: LD_VAR 0 9
70961: PPUSH
70962: LD_VAR 0 3
70966: PPUSH
70967: CALL_OW 265
70971: PPUSH
70972: LD_VAR 0 3
70976: PPUSH
70977: CALL_OW 262
70981: PPUSH
70982: LD_VAR 0 3
70986: PPUSH
70987: CALL_OW 263
70991: PPUSH
70992: LD_VAR 0 3
70996: PPUSH
70997: CALL_OW 264
71001: PPUSH
71002: CALL 18235 0 5
71006: ST_TO_ADDR
// if components then
71007: LD_VAR 0 10
71011: IFFALSE 71027
// MC_InsertProduceList ( i , components ) ;
71013: LD_VAR 0 2
71017: PPUSH
71018: LD_VAR 0 10
71022: PPUSH
71023: CALL 79703 0 2
// end ; continue ;
71027: GO 70542
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
71029: LD_VAR 0 3
71033: PPUSH
71034: LD_INT 1
71036: PPUSH
71037: CALL_OW 289
71041: PUSH
71042: LD_INT 100
71044: LESS
71045: PUSH
71046: LD_VAR 0 3
71050: PPUSH
71051: CALL_OW 314
71055: NOT
71056: AND
71057: IFFALSE 71086
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71059: LD_VAR 0 3
71063: PPUSH
71064: LD_VAR 0 6
71068: PUSH
71069: LD_INT 2
71071: ARRAY
71072: PPUSH
71073: LD_VAR 0 6
71077: PUSH
71078: LD_INT 3
71080: ARRAY
71081: PPUSH
71082: CALL_OW 117
// break ;
71086: GO 71090
// end ;
71088: GO 70542
71090: POP
71091: POP
// end ; end ;
71092: GO 69380
71094: POP
71095: POP
// end ;
71096: LD_VAR 0 1
71100: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
71101: LD_INT 0
71103: PPUSH
71104: PPUSH
71105: PPUSH
71106: PPUSH
// if not mc_bases then
71107: LD_EXP 58
71111: NOT
71112: IFFALSE 71116
// exit ;
71114: GO 71277
// for i = 1 to mc_bases do
71116: LD_ADDR_VAR 0 2
71120: PUSH
71121: DOUBLE
71122: LD_INT 1
71124: DEC
71125: ST_TO_ADDR
71126: LD_EXP 58
71130: PUSH
71131: FOR_TO
71132: IFFALSE 71275
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
71134: LD_ADDR_VAR 0 4
71138: PUSH
71139: LD_EXP 77
71143: PUSH
71144: LD_VAR 0 2
71148: ARRAY
71149: PUSH
71150: LD_EXP 80
71154: PUSH
71155: LD_VAR 0 2
71159: ARRAY
71160: UNION
71161: PPUSH
71162: LD_INT 33
71164: PUSH
71165: LD_INT 2
71167: PUSH
71168: EMPTY
71169: LIST
71170: LIST
71171: PPUSH
71172: CALL_OW 72
71176: ST_TO_ADDR
// if tmp then
71177: LD_VAR 0 4
71181: IFFALSE 71273
// for j in tmp do
71183: LD_ADDR_VAR 0 3
71187: PUSH
71188: LD_VAR 0 4
71192: PUSH
71193: FOR_IN
71194: IFFALSE 71271
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
71196: LD_VAR 0 3
71200: PPUSH
71201: CALL_OW 312
71205: NOT
71206: PUSH
71207: LD_VAR 0 3
71211: PPUSH
71212: CALL_OW 256
71216: PUSH
71217: LD_INT 250
71219: GREATEREQUAL
71220: AND
71221: IFFALSE 71234
// Connect ( j ) else
71223: LD_VAR 0 3
71227: PPUSH
71228: CALL 23575 0 1
71232: GO 71269
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
71234: LD_VAR 0 3
71238: PPUSH
71239: CALL_OW 256
71243: PUSH
71244: LD_INT 250
71246: LESS
71247: PUSH
71248: LD_VAR 0 3
71252: PPUSH
71253: CALL_OW 312
71257: AND
71258: IFFALSE 71269
// ComUnlink ( j ) ;
71260: LD_VAR 0 3
71264: PPUSH
71265: CALL_OW 136
71269: GO 71193
71271: POP
71272: POP
// end ;
71273: GO 71131
71275: POP
71276: POP
// end ;
71277: LD_VAR 0 1
71281: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
71282: LD_INT 0
71284: PPUSH
71285: PPUSH
71286: PPUSH
71287: PPUSH
71288: PPUSH
// if not mc_bases then
71289: LD_EXP 58
71293: NOT
71294: IFFALSE 71298
// exit ;
71296: GO 71758
// for i = 1 to mc_bases do
71298: LD_ADDR_VAR 0 2
71302: PUSH
71303: DOUBLE
71304: LD_INT 1
71306: DEC
71307: ST_TO_ADDR
71308: LD_EXP 58
71312: PUSH
71313: FOR_TO
71314: IFFALSE 71756
// begin if not mc_produce [ i ] then
71316: LD_EXP 79
71320: PUSH
71321: LD_VAR 0 2
71325: ARRAY
71326: NOT
71327: IFFALSE 71331
// continue ;
71329: GO 71313
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71331: LD_ADDR_VAR 0 5
71335: PUSH
71336: LD_EXP 58
71340: PUSH
71341: LD_VAR 0 2
71345: ARRAY
71346: PPUSH
71347: LD_INT 30
71349: PUSH
71350: LD_INT 3
71352: PUSH
71353: EMPTY
71354: LIST
71355: LIST
71356: PPUSH
71357: CALL_OW 72
71361: ST_TO_ADDR
// if not fac then
71362: LD_VAR 0 5
71366: NOT
71367: IFFALSE 71371
// continue ;
71369: GO 71313
// for j in fac do
71371: LD_ADDR_VAR 0 3
71375: PUSH
71376: LD_VAR 0 5
71380: PUSH
71381: FOR_IN
71382: IFFALSE 71752
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
71384: LD_VAR 0 3
71388: PPUSH
71389: CALL_OW 461
71393: PUSH
71394: LD_INT 2
71396: NONEQUAL
71397: PUSH
71398: LD_VAR 0 3
71402: PPUSH
71403: LD_INT 15
71405: PPUSH
71406: CALL 23235 0 2
71410: PUSH
71411: LD_INT 4
71413: ARRAY
71414: OR
71415: PUSH
71416: LD_VAR 0 3
71420: PPUSH
71421: CALL_OW 313
71425: PUSH
71426: LD_INT 0
71428: EQUAL
71429: OR
71430: IFFALSE 71434
// continue ;
71432: GO 71381
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
71434: LD_VAR 0 3
71438: PPUSH
71439: LD_EXP 79
71443: PUSH
71444: LD_VAR 0 2
71448: ARRAY
71449: PUSH
71450: LD_INT 1
71452: ARRAY
71453: PUSH
71454: LD_INT 1
71456: ARRAY
71457: PPUSH
71458: LD_EXP 79
71462: PUSH
71463: LD_VAR 0 2
71467: ARRAY
71468: PUSH
71469: LD_INT 1
71471: ARRAY
71472: PUSH
71473: LD_INT 2
71475: ARRAY
71476: PPUSH
71477: LD_EXP 79
71481: PUSH
71482: LD_VAR 0 2
71486: ARRAY
71487: PUSH
71488: LD_INT 1
71490: ARRAY
71491: PUSH
71492: LD_INT 3
71494: ARRAY
71495: PPUSH
71496: LD_EXP 79
71500: PUSH
71501: LD_VAR 0 2
71505: ARRAY
71506: PUSH
71507: LD_INT 1
71509: ARRAY
71510: PUSH
71511: LD_INT 4
71513: ARRAY
71514: PPUSH
71515: CALL_OW 448
71519: PUSH
71520: LD_VAR 0 3
71524: PPUSH
71525: LD_EXP 79
71529: PUSH
71530: LD_VAR 0 2
71534: ARRAY
71535: PUSH
71536: LD_INT 1
71538: ARRAY
71539: PUSH
71540: LD_INT 1
71542: ARRAY
71543: PUSH
71544: LD_EXP 79
71548: PUSH
71549: LD_VAR 0 2
71553: ARRAY
71554: PUSH
71555: LD_INT 1
71557: ARRAY
71558: PUSH
71559: LD_INT 2
71561: ARRAY
71562: PUSH
71563: LD_EXP 79
71567: PUSH
71568: LD_VAR 0 2
71572: ARRAY
71573: PUSH
71574: LD_INT 1
71576: ARRAY
71577: PUSH
71578: LD_INT 3
71580: ARRAY
71581: PUSH
71582: LD_EXP 79
71586: PUSH
71587: LD_VAR 0 2
71591: ARRAY
71592: PUSH
71593: LD_INT 1
71595: ARRAY
71596: PUSH
71597: LD_INT 4
71599: ARRAY
71600: PUSH
71601: EMPTY
71602: LIST
71603: LIST
71604: LIST
71605: LIST
71606: PPUSH
71607: CALL 26906 0 2
71611: AND
71612: IFFALSE 71750
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
71614: LD_VAR 0 3
71618: PPUSH
71619: LD_EXP 79
71623: PUSH
71624: LD_VAR 0 2
71628: ARRAY
71629: PUSH
71630: LD_INT 1
71632: ARRAY
71633: PUSH
71634: LD_INT 1
71636: ARRAY
71637: PPUSH
71638: LD_EXP 79
71642: PUSH
71643: LD_VAR 0 2
71647: ARRAY
71648: PUSH
71649: LD_INT 1
71651: ARRAY
71652: PUSH
71653: LD_INT 2
71655: ARRAY
71656: PPUSH
71657: LD_EXP 79
71661: PUSH
71662: LD_VAR 0 2
71666: ARRAY
71667: PUSH
71668: LD_INT 1
71670: ARRAY
71671: PUSH
71672: LD_INT 3
71674: ARRAY
71675: PPUSH
71676: LD_EXP 79
71680: PUSH
71681: LD_VAR 0 2
71685: ARRAY
71686: PUSH
71687: LD_INT 1
71689: ARRAY
71690: PUSH
71691: LD_INT 4
71693: ARRAY
71694: PPUSH
71695: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
71699: LD_ADDR_VAR 0 4
71703: PUSH
71704: LD_EXP 79
71708: PUSH
71709: LD_VAR 0 2
71713: ARRAY
71714: PPUSH
71715: LD_INT 1
71717: PPUSH
71718: CALL_OW 3
71722: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
71723: LD_ADDR_EXP 79
71727: PUSH
71728: LD_EXP 79
71732: PPUSH
71733: LD_VAR 0 2
71737: PPUSH
71738: LD_VAR 0 4
71742: PPUSH
71743: CALL_OW 1
71747: ST_TO_ADDR
// break ;
71748: GO 71752
// end ; end ;
71750: GO 71381
71752: POP
71753: POP
// end ;
71754: GO 71313
71756: POP
71757: POP
// end ;
71758: LD_VAR 0 1
71762: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
71763: LD_INT 0
71765: PPUSH
71766: PPUSH
71767: PPUSH
// if not mc_bases then
71768: LD_EXP 58
71772: NOT
71773: IFFALSE 71777
// exit ;
71775: GO 71866
// for i = 1 to mc_bases do
71777: LD_ADDR_VAR 0 2
71781: PUSH
71782: DOUBLE
71783: LD_INT 1
71785: DEC
71786: ST_TO_ADDR
71787: LD_EXP 58
71791: PUSH
71792: FOR_TO
71793: IFFALSE 71864
// begin if mc_attack [ i ] then
71795: LD_EXP 78
71799: PUSH
71800: LD_VAR 0 2
71804: ARRAY
71805: IFFALSE 71862
// begin tmp := mc_attack [ i ] [ 1 ] ;
71807: LD_ADDR_VAR 0 3
71811: PUSH
71812: LD_EXP 78
71816: PUSH
71817: LD_VAR 0 2
71821: ARRAY
71822: PUSH
71823: LD_INT 1
71825: ARRAY
71826: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
71827: LD_ADDR_EXP 78
71831: PUSH
71832: LD_EXP 78
71836: PPUSH
71837: LD_VAR 0 2
71841: PPUSH
71842: EMPTY
71843: PPUSH
71844: CALL_OW 1
71848: ST_TO_ADDR
// Attack ( tmp ) ;
71849: LD_VAR 0 3
71853: PPUSH
71854: CALL 49119 0 1
// exit ;
71858: POP
71859: POP
71860: GO 71866
// end ; end ;
71862: GO 71792
71864: POP
71865: POP
// end ;
71866: LD_VAR 0 1
71870: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
71871: LD_INT 0
71873: PPUSH
71874: PPUSH
71875: PPUSH
71876: PPUSH
71877: PPUSH
71878: PPUSH
71879: PPUSH
// if not mc_bases then
71880: LD_EXP 58
71884: NOT
71885: IFFALSE 71889
// exit ;
71887: GO 72471
// for i = 1 to mc_bases do
71889: LD_ADDR_VAR 0 2
71893: PUSH
71894: DOUBLE
71895: LD_INT 1
71897: DEC
71898: ST_TO_ADDR
71899: LD_EXP 58
71903: PUSH
71904: FOR_TO
71905: IFFALSE 72469
// begin if not mc_bases [ i ] then
71907: LD_EXP 58
71911: PUSH
71912: LD_VAR 0 2
71916: ARRAY
71917: NOT
71918: IFFALSE 71922
// continue ;
71920: GO 71904
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
71922: LD_ADDR_VAR 0 7
71926: PUSH
71927: LD_EXP 58
71931: PUSH
71932: LD_VAR 0 2
71936: ARRAY
71937: PUSH
71938: LD_INT 1
71940: ARRAY
71941: PPUSH
71942: CALL 17539 0 1
71946: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
71947: LD_ADDR_EXP 81
71951: PUSH
71952: LD_EXP 81
71956: PPUSH
71957: LD_VAR 0 2
71961: PPUSH
71962: LD_EXP 58
71966: PUSH
71967: LD_VAR 0 2
71971: ARRAY
71972: PUSH
71973: LD_INT 1
71975: ARRAY
71976: PPUSH
71977: CALL_OW 255
71981: PPUSH
71982: LD_EXP 83
71986: PUSH
71987: LD_VAR 0 2
71991: ARRAY
71992: PPUSH
71993: CALL 15536 0 2
71997: PPUSH
71998: CALL_OW 1
72002: ST_TO_ADDR
// if not mc_scan [ i ] then
72003: LD_EXP 81
72007: PUSH
72008: LD_VAR 0 2
72012: ARRAY
72013: NOT
72014: IFFALSE 72169
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72016: LD_ADDR_VAR 0 4
72020: PUSH
72021: LD_EXP 58
72025: PUSH
72026: LD_VAR 0 2
72030: ARRAY
72031: PPUSH
72032: LD_INT 2
72034: PUSH
72035: LD_INT 25
72037: PUSH
72038: LD_INT 5
72040: PUSH
72041: EMPTY
72042: LIST
72043: LIST
72044: PUSH
72045: LD_INT 25
72047: PUSH
72048: LD_INT 8
72050: PUSH
72051: EMPTY
72052: LIST
72053: LIST
72054: PUSH
72055: LD_INT 25
72057: PUSH
72058: LD_INT 9
72060: PUSH
72061: EMPTY
72062: LIST
72063: LIST
72064: PUSH
72065: EMPTY
72066: LIST
72067: LIST
72068: LIST
72069: LIST
72070: PPUSH
72071: CALL_OW 72
72075: ST_TO_ADDR
// if not tmp then
72076: LD_VAR 0 4
72080: NOT
72081: IFFALSE 72085
// continue ;
72083: GO 71904
// for j in tmp do
72085: LD_ADDR_VAR 0 3
72089: PUSH
72090: LD_VAR 0 4
72094: PUSH
72095: FOR_IN
72096: IFFALSE 72167
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
72098: LD_VAR 0 3
72102: PPUSH
72103: CALL_OW 310
72107: PPUSH
72108: CALL_OW 266
72112: PUSH
72113: LD_INT 5
72115: EQUAL
72116: PUSH
72117: LD_VAR 0 3
72121: PPUSH
72122: CALL_OW 257
72126: PUSH
72127: LD_INT 1
72129: EQUAL
72130: AND
72131: PUSH
72132: LD_VAR 0 3
72136: PPUSH
72137: CALL_OW 459
72141: NOT
72142: AND
72143: PUSH
72144: LD_VAR 0 7
72148: AND
72149: IFFALSE 72165
// ComChangeProfession ( j , class ) ;
72151: LD_VAR 0 3
72155: PPUSH
72156: LD_VAR 0 7
72160: PPUSH
72161: CALL_OW 123
72165: GO 72095
72167: POP
72168: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
72169: LD_EXP 81
72173: PUSH
72174: LD_VAR 0 2
72178: ARRAY
72179: PUSH
72180: LD_EXP 80
72184: PUSH
72185: LD_VAR 0 2
72189: ARRAY
72190: NOT
72191: AND
72192: PUSH
72193: LD_EXP 58
72197: PUSH
72198: LD_VAR 0 2
72202: ARRAY
72203: PPUSH
72204: LD_INT 30
72206: PUSH
72207: LD_INT 32
72209: PUSH
72210: EMPTY
72211: LIST
72212: LIST
72213: PPUSH
72214: CALL_OW 72
72218: NOT
72219: AND
72220: PUSH
72221: LD_EXP 58
72225: PUSH
72226: LD_VAR 0 2
72230: ARRAY
72231: PPUSH
72232: LD_INT 2
72234: PUSH
72235: LD_INT 30
72237: PUSH
72238: LD_INT 4
72240: PUSH
72241: EMPTY
72242: LIST
72243: LIST
72244: PUSH
72245: LD_INT 30
72247: PUSH
72248: LD_INT 5
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: EMPTY
72256: LIST
72257: LIST
72258: LIST
72259: PPUSH
72260: CALL_OW 72
72264: NOT
72265: AND
72266: IFFALSE 72398
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72268: LD_ADDR_VAR 0 4
72272: PUSH
72273: LD_EXP 58
72277: PUSH
72278: LD_VAR 0 2
72282: ARRAY
72283: PPUSH
72284: LD_INT 2
72286: PUSH
72287: LD_INT 25
72289: PUSH
72290: LD_INT 1
72292: PUSH
72293: EMPTY
72294: LIST
72295: LIST
72296: PUSH
72297: LD_INT 25
72299: PUSH
72300: LD_INT 5
72302: PUSH
72303: EMPTY
72304: LIST
72305: LIST
72306: PUSH
72307: LD_INT 25
72309: PUSH
72310: LD_INT 8
72312: PUSH
72313: EMPTY
72314: LIST
72315: LIST
72316: PUSH
72317: LD_INT 25
72319: PUSH
72320: LD_INT 9
72322: PUSH
72323: EMPTY
72324: LIST
72325: LIST
72326: PUSH
72327: EMPTY
72328: LIST
72329: LIST
72330: LIST
72331: LIST
72332: LIST
72333: PPUSH
72334: CALL_OW 72
72338: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
72339: LD_ADDR_VAR 0 4
72343: PUSH
72344: LD_VAR 0 4
72348: PUSH
72349: LD_VAR 0 4
72353: PPUSH
72354: LD_INT 18
72356: PPUSH
72357: CALL 53902 0 2
72361: DIFF
72362: ST_TO_ADDR
// if tmp then
72363: LD_VAR 0 4
72367: IFFALSE 72398
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
72369: LD_VAR 0 2
72373: PPUSH
72374: LD_VAR 0 4
72378: PPUSH
72379: LD_EXP 83
72383: PUSH
72384: LD_VAR 0 2
72388: ARRAY
72389: PPUSH
72390: CALL 15571 0 3
// exit ;
72394: POP
72395: POP
72396: GO 72471
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
72398: LD_EXP 81
72402: PUSH
72403: LD_VAR 0 2
72407: ARRAY
72408: PUSH
72409: LD_EXP 80
72413: PUSH
72414: LD_VAR 0 2
72418: ARRAY
72419: AND
72420: IFFALSE 72467
// begin tmp := mc_defender [ i ] ;
72422: LD_ADDR_VAR 0 4
72426: PUSH
72427: LD_EXP 80
72431: PUSH
72432: LD_VAR 0 2
72436: ARRAY
72437: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
72438: LD_VAR 0 2
72442: PPUSH
72443: LD_VAR 0 4
72447: PPUSH
72448: LD_EXP 81
72452: PUSH
72453: LD_VAR 0 2
72457: ARRAY
72458: PPUSH
72459: CALL 16069 0 3
// exit ;
72463: POP
72464: POP
72465: GO 72471
// end ; end ;
72467: GO 71904
72469: POP
72470: POP
// end ;
72471: LD_VAR 0 1
72475: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
72476: LD_INT 0
72478: PPUSH
72479: PPUSH
72480: PPUSH
72481: PPUSH
72482: PPUSH
72483: PPUSH
72484: PPUSH
72485: PPUSH
72486: PPUSH
72487: PPUSH
72488: PPUSH
// if not mc_bases then
72489: LD_EXP 58
72493: NOT
72494: IFFALSE 72498
// exit ;
72496: GO 73585
// for i = 1 to mc_bases do
72498: LD_ADDR_VAR 0 2
72502: PUSH
72503: DOUBLE
72504: LD_INT 1
72506: DEC
72507: ST_TO_ADDR
72508: LD_EXP 58
72512: PUSH
72513: FOR_TO
72514: IFFALSE 73583
// begin tmp := mc_lab [ i ] ;
72516: LD_ADDR_VAR 0 6
72520: PUSH
72521: LD_EXP 91
72525: PUSH
72526: LD_VAR 0 2
72530: ARRAY
72531: ST_TO_ADDR
// if not tmp then
72532: LD_VAR 0 6
72536: NOT
72537: IFFALSE 72541
// continue ;
72539: GO 72513
// idle_lab := 0 ;
72541: LD_ADDR_VAR 0 11
72545: PUSH
72546: LD_INT 0
72548: ST_TO_ADDR
// for j in tmp do
72549: LD_ADDR_VAR 0 3
72553: PUSH
72554: LD_VAR 0 6
72558: PUSH
72559: FOR_IN
72560: IFFALSE 73579
// begin researching := false ;
72562: LD_ADDR_VAR 0 10
72566: PUSH
72567: LD_INT 0
72569: ST_TO_ADDR
// side := GetSide ( j ) ;
72570: LD_ADDR_VAR 0 4
72574: PUSH
72575: LD_VAR 0 3
72579: PPUSH
72580: CALL_OW 255
72584: ST_TO_ADDR
// if not mc_tech [ side ] then
72585: LD_EXP 85
72589: PUSH
72590: LD_VAR 0 4
72594: ARRAY
72595: NOT
72596: IFFALSE 72600
// continue ;
72598: GO 72559
// if BuildingStatus ( j ) = bs_idle then
72600: LD_VAR 0 3
72604: PPUSH
72605: CALL_OW 461
72609: PUSH
72610: LD_INT 2
72612: EQUAL
72613: IFFALSE 72801
// begin if idle_lab and UnitsInside ( j ) < 6 then
72615: LD_VAR 0 11
72619: PUSH
72620: LD_VAR 0 3
72624: PPUSH
72625: CALL_OW 313
72629: PUSH
72630: LD_INT 6
72632: LESS
72633: AND
72634: IFFALSE 72705
// begin tmp2 := UnitsInside ( idle_lab ) ;
72636: LD_ADDR_VAR 0 9
72640: PUSH
72641: LD_VAR 0 11
72645: PPUSH
72646: CALL_OW 313
72650: ST_TO_ADDR
// if tmp2 then
72651: LD_VAR 0 9
72655: IFFALSE 72697
// for x in tmp2 do
72657: LD_ADDR_VAR 0 7
72661: PUSH
72662: LD_VAR 0 9
72666: PUSH
72667: FOR_IN
72668: IFFALSE 72695
// begin ComExitBuilding ( x ) ;
72670: LD_VAR 0 7
72674: PPUSH
72675: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72679: LD_VAR 0 7
72683: PPUSH
72684: LD_VAR 0 3
72688: PPUSH
72689: CALL_OW 180
// end ;
72693: GO 72667
72695: POP
72696: POP
// idle_lab := 0 ;
72697: LD_ADDR_VAR 0 11
72701: PUSH
72702: LD_INT 0
72704: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
72705: LD_ADDR_VAR 0 5
72709: PUSH
72710: LD_EXP 85
72714: PUSH
72715: LD_VAR 0 4
72719: ARRAY
72720: PUSH
72721: FOR_IN
72722: IFFALSE 72782
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
72724: LD_VAR 0 3
72728: PPUSH
72729: LD_VAR 0 5
72733: PPUSH
72734: CALL_OW 430
72738: PUSH
72739: LD_VAR 0 4
72743: PPUSH
72744: LD_VAR 0 5
72748: PPUSH
72749: CALL 14641 0 2
72753: AND
72754: IFFALSE 72780
// begin researching := true ;
72756: LD_ADDR_VAR 0 10
72760: PUSH
72761: LD_INT 1
72763: ST_TO_ADDR
// ComResearch ( j , t ) ;
72764: LD_VAR 0 3
72768: PPUSH
72769: LD_VAR 0 5
72773: PPUSH
72774: CALL_OW 124
// break ;
72778: GO 72782
// end ;
72780: GO 72721
72782: POP
72783: POP
// if not researching then
72784: LD_VAR 0 10
72788: NOT
72789: IFFALSE 72801
// idle_lab := j ;
72791: LD_ADDR_VAR 0 11
72795: PUSH
72796: LD_VAR 0 3
72800: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
72801: LD_VAR 0 3
72805: PPUSH
72806: CALL_OW 461
72810: PUSH
72811: LD_INT 10
72813: EQUAL
72814: IFFALSE 73402
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
72816: LD_EXP 87
72820: PUSH
72821: LD_VAR 0 2
72825: ARRAY
72826: NOT
72827: PUSH
72828: LD_EXP 88
72832: PUSH
72833: LD_VAR 0 2
72837: ARRAY
72838: NOT
72839: AND
72840: PUSH
72841: LD_EXP 85
72845: PUSH
72846: LD_VAR 0 4
72850: ARRAY
72851: PUSH
72852: LD_INT 1
72854: GREATER
72855: AND
72856: IFFALSE 72987
// begin ComCancel ( j ) ;
72858: LD_VAR 0 3
72862: PPUSH
72863: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
72867: LD_ADDR_EXP 85
72871: PUSH
72872: LD_EXP 85
72876: PPUSH
72877: LD_VAR 0 4
72881: PPUSH
72882: LD_EXP 85
72886: PUSH
72887: LD_VAR 0 4
72891: ARRAY
72892: PPUSH
72893: LD_EXP 85
72897: PUSH
72898: LD_VAR 0 4
72902: ARRAY
72903: PUSH
72904: LD_INT 1
72906: MINUS
72907: PPUSH
72908: LD_EXP 85
72912: PUSH
72913: LD_VAR 0 4
72917: ARRAY
72918: PPUSH
72919: LD_INT 0
72921: PPUSH
72922: CALL 20060 0 4
72926: PPUSH
72927: CALL_OW 1
72931: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
72932: LD_ADDR_EXP 85
72936: PUSH
72937: LD_EXP 85
72941: PPUSH
72942: LD_VAR 0 4
72946: PPUSH
72947: LD_EXP 85
72951: PUSH
72952: LD_VAR 0 4
72956: ARRAY
72957: PPUSH
72958: LD_EXP 85
72962: PUSH
72963: LD_VAR 0 4
72967: ARRAY
72968: PPUSH
72969: LD_INT 1
72971: PPUSH
72972: LD_INT 0
72974: PPUSH
72975: CALL 20060 0 4
72979: PPUSH
72980: CALL_OW 1
72984: ST_TO_ADDR
// continue ;
72985: GO 72559
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
72987: LD_EXP 87
72991: PUSH
72992: LD_VAR 0 2
72996: ARRAY
72997: PUSH
72998: LD_EXP 88
73002: PUSH
73003: LD_VAR 0 2
73007: ARRAY
73008: NOT
73009: AND
73010: IFFALSE 73137
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
73012: LD_ADDR_EXP 88
73016: PUSH
73017: LD_EXP 88
73021: PPUSH
73022: LD_VAR 0 2
73026: PUSH
73027: LD_EXP 88
73031: PUSH
73032: LD_VAR 0 2
73036: ARRAY
73037: PUSH
73038: LD_INT 1
73040: PLUS
73041: PUSH
73042: EMPTY
73043: LIST
73044: LIST
73045: PPUSH
73046: LD_EXP 87
73050: PUSH
73051: LD_VAR 0 2
73055: ARRAY
73056: PUSH
73057: LD_INT 1
73059: ARRAY
73060: PPUSH
73061: CALL 20642 0 3
73065: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
73066: LD_EXP 87
73070: PUSH
73071: LD_VAR 0 2
73075: ARRAY
73076: PUSH
73077: LD_INT 1
73079: ARRAY
73080: PPUSH
73081: LD_INT 112
73083: PPUSH
73084: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
73088: LD_ADDR_VAR 0 9
73092: PUSH
73093: LD_EXP 87
73097: PUSH
73098: LD_VAR 0 2
73102: ARRAY
73103: PPUSH
73104: LD_INT 1
73106: PPUSH
73107: CALL_OW 3
73111: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
73112: LD_ADDR_EXP 87
73116: PUSH
73117: LD_EXP 87
73121: PPUSH
73122: LD_VAR 0 2
73126: PPUSH
73127: LD_VAR 0 9
73131: PPUSH
73132: CALL_OW 1
73136: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
73137: LD_EXP 87
73141: PUSH
73142: LD_VAR 0 2
73146: ARRAY
73147: PUSH
73148: LD_EXP 88
73152: PUSH
73153: LD_VAR 0 2
73157: ARRAY
73158: AND
73159: PUSH
73160: LD_EXP 88
73164: PUSH
73165: LD_VAR 0 2
73169: ARRAY
73170: PUSH
73171: LD_INT 1
73173: ARRAY
73174: PPUSH
73175: CALL_OW 310
73179: NOT
73180: AND
73181: PUSH
73182: LD_VAR 0 3
73186: PPUSH
73187: CALL_OW 313
73191: PUSH
73192: LD_INT 6
73194: EQUAL
73195: AND
73196: IFFALSE 73252
// begin tmp2 := UnitsInside ( j ) ;
73198: LD_ADDR_VAR 0 9
73202: PUSH
73203: LD_VAR 0 3
73207: PPUSH
73208: CALL_OW 313
73212: ST_TO_ADDR
// if tmp2 = 6 then
73213: LD_VAR 0 9
73217: PUSH
73218: LD_INT 6
73220: EQUAL
73221: IFFALSE 73252
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
73223: LD_VAR 0 9
73227: PUSH
73228: LD_INT 1
73230: ARRAY
73231: PPUSH
73232: LD_INT 112
73234: PPUSH
73235: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
73239: LD_VAR 0 9
73243: PUSH
73244: LD_INT 1
73246: ARRAY
73247: PPUSH
73248: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
73252: LD_EXP 88
73256: PUSH
73257: LD_VAR 0 2
73261: ARRAY
73262: PUSH
73263: LD_EXP 88
73267: PUSH
73268: LD_VAR 0 2
73272: ARRAY
73273: PUSH
73274: LD_INT 1
73276: ARRAY
73277: PPUSH
73278: CALL_OW 314
73282: NOT
73283: AND
73284: PUSH
73285: LD_EXP 88
73289: PUSH
73290: LD_VAR 0 2
73294: ARRAY
73295: PUSH
73296: LD_INT 1
73298: ARRAY
73299: PPUSH
73300: CALL_OW 310
73304: NOT
73305: AND
73306: IFFALSE 73332
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
73308: LD_EXP 88
73312: PUSH
73313: LD_VAR 0 2
73317: ARRAY
73318: PUSH
73319: LD_INT 1
73321: ARRAY
73322: PPUSH
73323: LD_VAR 0 3
73327: PPUSH
73328: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
73332: LD_EXP 88
73336: PUSH
73337: LD_VAR 0 2
73341: ARRAY
73342: PUSH
73343: LD_INT 1
73345: ARRAY
73346: PPUSH
73347: CALL_OW 310
73351: PUSH
73352: LD_EXP 88
73356: PUSH
73357: LD_VAR 0 2
73361: ARRAY
73362: PUSH
73363: LD_INT 1
73365: ARRAY
73366: PPUSH
73367: CALL_OW 310
73371: PPUSH
73372: CALL_OW 461
73376: PUSH
73377: LD_INT 3
73379: NONEQUAL
73380: AND
73381: IFFALSE 73402
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
73383: LD_EXP 88
73387: PUSH
73388: LD_VAR 0 2
73392: ARRAY
73393: PUSH
73394: LD_INT 1
73396: ARRAY
73397: PPUSH
73398: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
73402: LD_VAR 0 3
73406: PPUSH
73407: CALL_OW 461
73411: PUSH
73412: LD_INT 6
73414: EQUAL
73415: PUSH
73416: LD_VAR 0 6
73420: PUSH
73421: LD_INT 1
73423: GREATER
73424: AND
73425: IFFALSE 73577
// begin sci := [ ] ;
73427: LD_ADDR_VAR 0 8
73431: PUSH
73432: EMPTY
73433: ST_TO_ADDR
// for x in ( tmp diff j ) do
73434: LD_ADDR_VAR 0 7
73438: PUSH
73439: LD_VAR 0 6
73443: PUSH
73444: LD_VAR 0 3
73448: DIFF
73449: PUSH
73450: FOR_IN
73451: IFFALSE 73503
// begin if sci = 6 then
73453: LD_VAR 0 8
73457: PUSH
73458: LD_INT 6
73460: EQUAL
73461: IFFALSE 73465
// break ;
73463: GO 73503
// if BuildingStatus ( x ) = bs_idle then
73465: LD_VAR 0 7
73469: PPUSH
73470: CALL_OW 461
73474: PUSH
73475: LD_INT 2
73477: EQUAL
73478: IFFALSE 73501
// sci := sci ^ UnitsInside ( x ) ;
73480: LD_ADDR_VAR 0 8
73484: PUSH
73485: LD_VAR 0 8
73489: PUSH
73490: LD_VAR 0 7
73494: PPUSH
73495: CALL_OW 313
73499: ADD
73500: ST_TO_ADDR
// end ;
73501: GO 73450
73503: POP
73504: POP
// if not sci then
73505: LD_VAR 0 8
73509: NOT
73510: IFFALSE 73514
// continue ;
73512: GO 72559
// for x in sci do
73514: LD_ADDR_VAR 0 7
73518: PUSH
73519: LD_VAR 0 8
73523: PUSH
73524: FOR_IN
73525: IFFALSE 73575
// if IsInUnit ( x ) and not HasTask ( x ) then
73527: LD_VAR 0 7
73531: PPUSH
73532: CALL_OW 310
73536: PUSH
73537: LD_VAR 0 7
73541: PPUSH
73542: CALL_OW 314
73546: NOT
73547: AND
73548: IFFALSE 73573
// begin ComExitBuilding ( x ) ;
73550: LD_VAR 0 7
73554: PPUSH
73555: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73559: LD_VAR 0 7
73563: PPUSH
73564: LD_VAR 0 3
73568: PPUSH
73569: CALL_OW 180
// end ;
73573: GO 73524
73575: POP
73576: POP
// end ; end ;
73577: GO 72559
73579: POP
73580: POP
// end ;
73581: GO 72513
73583: POP
73584: POP
// end ;
73585: LD_VAR 0 1
73589: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
73590: LD_INT 0
73592: PPUSH
73593: PPUSH
// if not mc_bases then
73594: LD_EXP 58
73598: NOT
73599: IFFALSE 73603
// exit ;
73601: GO 73684
// for i = 1 to mc_bases do
73603: LD_ADDR_VAR 0 2
73607: PUSH
73608: DOUBLE
73609: LD_INT 1
73611: DEC
73612: ST_TO_ADDR
73613: LD_EXP 58
73617: PUSH
73618: FOR_TO
73619: IFFALSE 73682
// if mc_mines [ i ] and mc_miners [ i ] then
73621: LD_EXP 71
73625: PUSH
73626: LD_VAR 0 2
73630: ARRAY
73631: PUSH
73632: LD_EXP 72
73636: PUSH
73637: LD_VAR 0 2
73641: ARRAY
73642: AND
73643: IFFALSE 73680
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
73645: LD_EXP 72
73649: PUSH
73650: LD_VAR 0 2
73654: ARRAY
73655: PUSH
73656: LD_INT 1
73658: ARRAY
73659: PPUSH
73660: CALL_OW 255
73664: PPUSH
73665: LD_EXP 71
73669: PUSH
73670: LD_VAR 0 2
73674: ARRAY
73675: PPUSH
73676: CALL 17692 0 2
73680: GO 73618
73682: POP
73683: POP
// end ;
73684: LD_VAR 0 1
73688: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
73689: LD_INT 0
73691: PPUSH
73692: PPUSH
73693: PPUSH
73694: PPUSH
73695: PPUSH
73696: PPUSH
73697: PPUSH
73698: PPUSH
// if not mc_bases or not mc_parking then
73699: LD_EXP 58
73703: NOT
73704: PUSH
73705: LD_EXP 82
73709: NOT
73710: OR
73711: IFFALSE 73715
// exit ;
73713: GO 74391
// for i = 1 to mc_bases do
73715: LD_ADDR_VAR 0 2
73719: PUSH
73720: DOUBLE
73721: LD_INT 1
73723: DEC
73724: ST_TO_ADDR
73725: LD_EXP 58
73729: PUSH
73730: FOR_TO
73731: IFFALSE 74389
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
73733: LD_EXP 58
73737: PUSH
73738: LD_VAR 0 2
73742: ARRAY
73743: NOT
73744: PUSH
73745: LD_EXP 82
73749: PUSH
73750: LD_VAR 0 2
73754: ARRAY
73755: NOT
73756: OR
73757: IFFALSE 73761
// continue ;
73759: GO 73730
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
73761: LD_ADDR_VAR 0 5
73765: PUSH
73766: LD_EXP 58
73770: PUSH
73771: LD_VAR 0 2
73775: ARRAY
73776: PUSH
73777: LD_INT 1
73779: ARRAY
73780: PPUSH
73781: CALL_OW 255
73785: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73786: LD_ADDR_VAR 0 6
73790: PUSH
73791: LD_EXP 58
73795: PUSH
73796: LD_VAR 0 2
73800: ARRAY
73801: PPUSH
73802: LD_INT 30
73804: PUSH
73805: LD_INT 3
73807: PUSH
73808: EMPTY
73809: LIST
73810: LIST
73811: PPUSH
73812: CALL_OW 72
73816: ST_TO_ADDR
// if not fac then
73817: LD_VAR 0 6
73821: NOT
73822: IFFALSE 73873
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73824: LD_ADDR_VAR 0 6
73828: PUSH
73829: LD_EXP 58
73833: PUSH
73834: LD_VAR 0 2
73838: ARRAY
73839: PPUSH
73840: LD_INT 2
73842: PUSH
73843: LD_INT 30
73845: PUSH
73846: LD_INT 0
73848: PUSH
73849: EMPTY
73850: LIST
73851: LIST
73852: PUSH
73853: LD_INT 30
73855: PUSH
73856: LD_INT 1
73858: PUSH
73859: EMPTY
73860: LIST
73861: LIST
73862: PUSH
73863: EMPTY
73864: LIST
73865: LIST
73866: LIST
73867: PPUSH
73868: CALL_OW 72
73872: ST_TO_ADDR
// if not fac then
73873: LD_VAR 0 6
73877: NOT
73878: IFFALSE 73882
// continue ;
73880: GO 73730
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73882: LD_ADDR_VAR 0 7
73886: PUSH
73887: LD_EXP 82
73891: PUSH
73892: LD_VAR 0 2
73896: ARRAY
73897: PPUSH
73898: LD_INT 22
73900: PUSH
73901: LD_VAR 0 5
73905: PUSH
73906: EMPTY
73907: LIST
73908: LIST
73909: PUSH
73910: LD_INT 21
73912: PUSH
73913: LD_INT 2
73915: PUSH
73916: EMPTY
73917: LIST
73918: LIST
73919: PUSH
73920: LD_INT 3
73922: PUSH
73923: LD_INT 24
73925: PUSH
73926: LD_INT 1000
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: EMPTY
73934: LIST
73935: LIST
73936: PUSH
73937: EMPTY
73938: LIST
73939: LIST
73940: LIST
73941: PPUSH
73942: CALL_OW 70
73946: PUSH
73947: LD_INT 22
73949: PUSH
73950: LD_VAR 0 5
73954: PUSH
73955: EMPTY
73956: LIST
73957: LIST
73958: PUSH
73959: LD_INT 91
73961: PUSH
73962: LD_VAR 0 6
73966: PUSH
73967: LD_INT 1
73969: ARRAY
73970: PUSH
73971: LD_INT 25
73973: PUSH
73974: EMPTY
73975: LIST
73976: LIST
73977: LIST
73978: PUSH
73979: LD_INT 21
73981: PUSH
73982: LD_INT 2
73984: PUSH
73985: EMPTY
73986: LIST
73987: LIST
73988: PUSH
73989: LD_INT 3
73991: PUSH
73992: LD_INT 24
73994: PUSH
73995: LD_INT 1000
73997: PUSH
73998: EMPTY
73999: LIST
74000: LIST
74001: PUSH
74002: EMPTY
74003: LIST
74004: LIST
74005: PUSH
74006: EMPTY
74007: LIST
74008: LIST
74009: LIST
74010: LIST
74011: PPUSH
74012: CALL_OW 69
74016: UNION
74017: ST_TO_ADDR
// if not vehs then
74018: LD_VAR 0 7
74022: NOT
74023: IFFALSE 74049
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
74025: LD_ADDR_EXP 70
74029: PUSH
74030: LD_EXP 70
74034: PPUSH
74035: LD_VAR 0 2
74039: PPUSH
74040: EMPTY
74041: PPUSH
74042: CALL_OW 1
74046: ST_TO_ADDR
// continue ;
74047: GO 73730
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74049: LD_ADDR_VAR 0 8
74053: PUSH
74054: LD_EXP 58
74058: PUSH
74059: LD_VAR 0 2
74063: ARRAY
74064: PPUSH
74065: LD_INT 30
74067: PUSH
74068: LD_INT 3
74070: PUSH
74071: EMPTY
74072: LIST
74073: LIST
74074: PPUSH
74075: CALL_OW 72
74079: ST_TO_ADDR
// if tmp then
74080: LD_VAR 0 8
74084: IFFALSE 74187
// begin for j in tmp do
74086: LD_ADDR_VAR 0 3
74090: PUSH
74091: LD_VAR 0 8
74095: PUSH
74096: FOR_IN
74097: IFFALSE 74185
// for k in UnitsInside ( j ) do
74099: LD_ADDR_VAR 0 4
74103: PUSH
74104: LD_VAR 0 3
74108: PPUSH
74109: CALL_OW 313
74113: PUSH
74114: FOR_IN
74115: IFFALSE 74181
// if k then
74117: LD_VAR 0 4
74121: IFFALSE 74179
// if not k in mc_repair_vehicle [ i ] then
74123: LD_VAR 0 4
74127: PUSH
74128: LD_EXP 70
74132: PUSH
74133: LD_VAR 0 2
74137: ARRAY
74138: IN
74139: NOT
74140: IFFALSE 74179
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
74142: LD_ADDR_EXP 70
74146: PUSH
74147: LD_EXP 70
74151: PPUSH
74152: LD_VAR 0 2
74156: PPUSH
74157: LD_EXP 70
74161: PUSH
74162: LD_VAR 0 2
74166: ARRAY
74167: PUSH
74168: LD_VAR 0 4
74172: UNION
74173: PPUSH
74174: CALL_OW 1
74178: ST_TO_ADDR
74179: GO 74114
74181: POP
74182: POP
74183: GO 74096
74185: POP
74186: POP
// end ; if not mc_repair_vehicle [ i ] then
74187: LD_EXP 70
74191: PUSH
74192: LD_VAR 0 2
74196: ARRAY
74197: NOT
74198: IFFALSE 74202
// continue ;
74200: GO 73730
// for j in mc_repair_vehicle [ i ] do
74202: LD_ADDR_VAR 0 3
74206: PUSH
74207: LD_EXP 70
74211: PUSH
74212: LD_VAR 0 2
74216: ARRAY
74217: PUSH
74218: FOR_IN
74219: IFFALSE 74385
// begin if GetClass ( j ) <> 3 then
74221: LD_VAR 0 3
74225: PPUSH
74226: CALL_OW 257
74230: PUSH
74231: LD_INT 3
74233: NONEQUAL
74234: IFFALSE 74275
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
74236: LD_ADDR_EXP 70
74240: PUSH
74241: LD_EXP 70
74245: PPUSH
74246: LD_VAR 0 2
74250: PPUSH
74251: LD_EXP 70
74255: PUSH
74256: LD_VAR 0 2
74260: ARRAY
74261: PUSH
74262: LD_VAR 0 3
74266: DIFF
74267: PPUSH
74268: CALL_OW 1
74272: ST_TO_ADDR
// continue ;
74273: GO 74218
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74275: LD_VAR 0 3
74279: PPUSH
74280: CALL_OW 311
74284: NOT
74285: PUSH
74286: LD_VAR 0 3
74290: PUSH
74291: LD_EXP 61
74295: PUSH
74296: LD_VAR 0 2
74300: ARRAY
74301: PUSH
74302: LD_INT 1
74304: ARRAY
74305: IN
74306: NOT
74307: AND
74308: PUSH
74309: LD_VAR 0 3
74313: PUSH
74314: LD_EXP 61
74318: PUSH
74319: LD_VAR 0 2
74323: ARRAY
74324: PUSH
74325: LD_INT 2
74327: ARRAY
74328: IN
74329: NOT
74330: AND
74331: IFFALSE 74383
// begin if IsInUnit ( j ) then
74333: LD_VAR 0 3
74337: PPUSH
74338: CALL_OW 310
74342: IFFALSE 74353
// ComExitBuilding ( j ) ;
74344: LD_VAR 0 3
74348: PPUSH
74349: CALL_OW 122
// if not HasTask ( j ) then
74353: LD_VAR 0 3
74357: PPUSH
74358: CALL_OW 314
74362: NOT
74363: IFFALSE 74383
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
74365: LD_VAR 0 3
74369: PPUSH
74370: LD_VAR 0 7
74374: PUSH
74375: LD_INT 1
74377: ARRAY
74378: PPUSH
74379: CALL_OW 189
// end ; end ;
74383: GO 74218
74385: POP
74386: POP
// end ;
74387: GO 73730
74389: POP
74390: POP
// end ;
74391: LD_VAR 0 1
74395: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
74396: LD_INT 0
74398: PPUSH
74399: PPUSH
74400: PPUSH
74401: PPUSH
74402: PPUSH
74403: PPUSH
74404: PPUSH
74405: PPUSH
74406: PPUSH
74407: PPUSH
74408: PPUSH
// if not mc_bases then
74409: LD_EXP 58
74413: NOT
74414: IFFALSE 74418
// exit ;
74416: GO 75220
// for i = 1 to mc_bases do
74418: LD_ADDR_VAR 0 2
74422: PUSH
74423: DOUBLE
74424: LD_INT 1
74426: DEC
74427: ST_TO_ADDR
74428: LD_EXP 58
74432: PUSH
74433: FOR_TO
74434: IFFALSE 75218
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
74436: LD_EXP 86
74440: PUSH
74441: LD_VAR 0 2
74445: ARRAY
74446: NOT
74447: PUSH
74448: LD_EXP 61
74452: PUSH
74453: LD_VAR 0 2
74457: ARRAY
74458: PUSH
74459: LD_INT 1
74461: ARRAY
74462: OR
74463: PUSH
74464: LD_EXP 61
74468: PUSH
74469: LD_VAR 0 2
74473: ARRAY
74474: PUSH
74475: LD_INT 2
74477: ARRAY
74478: OR
74479: PUSH
74480: LD_EXP 84
74484: PUSH
74485: LD_VAR 0 2
74489: ARRAY
74490: PPUSH
74491: LD_INT 1
74493: PPUSH
74494: CALL_OW 325
74498: NOT
74499: OR
74500: PUSH
74501: LD_EXP 81
74505: PUSH
74506: LD_VAR 0 2
74510: ARRAY
74511: OR
74512: IFFALSE 74516
// continue ;
74514: GO 74433
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
74516: LD_ADDR_VAR 0 8
74520: PUSH
74521: LD_EXP 58
74525: PUSH
74526: LD_VAR 0 2
74530: ARRAY
74531: PPUSH
74532: LD_INT 25
74534: PUSH
74535: LD_INT 4
74537: PUSH
74538: EMPTY
74539: LIST
74540: LIST
74541: PUSH
74542: LD_INT 50
74544: PUSH
74545: EMPTY
74546: LIST
74547: PUSH
74548: LD_INT 3
74550: PUSH
74551: LD_INT 60
74553: PUSH
74554: EMPTY
74555: LIST
74556: PUSH
74557: EMPTY
74558: LIST
74559: LIST
74560: PUSH
74561: EMPTY
74562: LIST
74563: LIST
74564: LIST
74565: PPUSH
74566: CALL_OW 72
74570: PUSH
74571: LD_EXP 62
74575: PUSH
74576: LD_VAR 0 2
74580: ARRAY
74581: DIFF
74582: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74583: LD_ADDR_VAR 0 9
74587: PUSH
74588: LD_EXP 58
74592: PUSH
74593: LD_VAR 0 2
74597: ARRAY
74598: PPUSH
74599: LD_INT 2
74601: PUSH
74602: LD_INT 30
74604: PUSH
74605: LD_INT 0
74607: PUSH
74608: EMPTY
74609: LIST
74610: LIST
74611: PUSH
74612: LD_INT 30
74614: PUSH
74615: LD_INT 1
74617: PUSH
74618: EMPTY
74619: LIST
74620: LIST
74621: PUSH
74622: EMPTY
74623: LIST
74624: LIST
74625: LIST
74626: PPUSH
74627: CALL_OW 72
74631: ST_TO_ADDR
// if not tmp or not dep then
74632: LD_VAR 0 8
74636: NOT
74637: PUSH
74638: LD_VAR 0 9
74642: NOT
74643: OR
74644: IFFALSE 74648
// continue ;
74646: GO 74433
// side := GetSide ( tmp [ 1 ] ) ;
74648: LD_ADDR_VAR 0 11
74652: PUSH
74653: LD_VAR 0 8
74657: PUSH
74658: LD_INT 1
74660: ARRAY
74661: PPUSH
74662: CALL_OW 255
74666: ST_TO_ADDR
// dep := dep [ 1 ] ;
74667: LD_ADDR_VAR 0 9
74671: PUSH
74672: LD_VAR 0 9
74676: PUSH
74677: LD_INT 1
74679: ARRAY
74680: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
74681: LD_ADDR_VAR 0 7
74685: PUSH
74686: LD_EXP 86
74690: PUSH
74691: LD_VAR 0 2
74695: ARRAY
74696: PPUSH
74697: LD_INT 22
74699: PUSH
74700: LD_INT 0
74702: PUSH
74703: EMPTY
74704: LIST
74705: LIST
74706: PUSH
74707: LD_INT 25
74709: PUSH
74710: LD_INT 12
74712: PUSH
74713: EMPTY
74714: LIST
74715: LIST
74716: PUSH
74717: EMPTY
74718: LIST
74719: LIST
74720: PPUSH
74721: CALL_OW 70
74725: PUSH
74726: LD_INT 22
74728: PUSH
74729: LD_INT 0
74731: PUSH
74732: EMPTY
74733: LIST
74734: LIST
74735: PUSH
74736: LD_INT 25
74738: PUSH
74739: LD_INT 12
74741: PUSH
74742: EMPTY
74743: LIST
74744: LIST
74745: PUSH
74746: LD_INT 91
74748: PUSH
74749: LD_VAR 0 9
74753: PUSH
74754: LD_INT 20
74756: PUSH
74757: EMPTY
74758: LIST
74759: LIST
74760: LIST
74761: PUSH
74762: EMPTY
74763: LIST
74764: LIST
74765: LIST
74766: PPUSH
74767: CALL_OW 69
74771: UNION
74772: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
74773: LD_ADDR_VAR 0 10
74777: PUSH
74778: LD_EXP 86
74782: PUSH
74783: LD_VAR 0 2
74787: ARRAY
74788: PPUSH
74789: LD_INT 81
74791: PUSH
74792: LD_VAR 0 11
74796: PUSH
74797: EMPTY
74798: LIST
74799: LIST
74800: PPUSH
74801: CALL_OW 70
74805: ST_TO_ADDR
// if not apes or danger_at_area then
74806: LD_VAR 0 7
74810: NOT
74811: PUSH
74812: LD_VAR 0 10
74816: OR
74817: IFFALSE 74867
// begin if mc_taming [ i ] then
74819: LD_EXP 89
74823: PUSH
74824: LD_VAR 0 2
74828: ARRAY
74829: IFFALSE 74865
// begin MC_Reset ( i , 121 ) ;
74831: LD_VAR 0 2
74835: PPUSH
74836: LD_INT 121
74838: PPUSH
74839: CALL 60560 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
74843: LD_ADDR_EXP 89
74847: PUSH
74848: LD_EXP 89
74852: PPUSH
74853: LD_VAR 0 2
74857: PPUSH
74858: EMPTY
74859: PPUSH
74860: CALL_OW 1
74864: ST_TO_ADDR
// end ; continue ;
74865: GO 74433
// end ; for j in tmp do
74867: LD_ADDR_VAR 0 3
74871: PUSH
74872: LD_VAR 0 8
74876: PUSH
74877: FOR_IN
74878: IFFALSE 75214
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
74880: LD_VAR 0 3
74884: PUSH
74885: LD_EXP 89
74889: PUSH
74890: LD_VAR 0 2
74894: ARRAY
74895: IN
74896: NOT
74897: PUSH
74898: LD_EXP 89
74902: PUSH
74903: LD_VAR 0 2
74907: ARRAY
74908: PUSH
74909: LD_INT 3
74911: LESS
74912: AND
74913: IFFALSE 74971
// begin SetTag ( j , 121 ) ;
74915: LD_VAR 0 3
74919: PPUSH
74920: LD_INT 121
74922: PPUSH
74923: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
74927: LD_ADDR_EXP 89
74931: PUSH
74932: LD_EXP 89
74936: PPUSH
74937: LD_VAR 0 2
74941: PUSH
74942: LD_EXP 89
74946: PUSH
74947: LD_VAR 0 2
74951: ARRAY
74952: PUSH
74953: LD_INT 1
74955: PLUS
74956: PUSH
74957: EMPTY
74958: LIST
74959: LIST
74960: PPUSH
74961: LD_VAR 0 3
74965: PPUSH
74966: CALL 20642 0 3
74970: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
74971: LD_VAR 0 3
74975: PUSH
74976: LD_EXP 89
74980: PUSH
74981: LD_VAR 0 2
74985: ARRAY
74986: IN
74987: IFFALSE 75212
// begin if GetClass ( j ) <> 4 then
74989: LD_VAR 0 3
74993: PPUSH
74994: CALL_OW 257
74998: PUSH
74999: LD_INT 4
75001: NONEQUAL
75002: IFFALSE 75055
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
75004: LD_ADDR_EXP 89
75008: PUSH
75009: LD_EXP 89
75013: PPUSH
75014: LD_VAR 0 2
75018: PPUSH
75019: LD_EXP 89
75023: PUSH
75024: LD_VAR 0 2
75028: ARRAY
75029: PUSH
75030: LD_VAR 0 3
75034: DIFF
75035: PPUSH
75036: CALL_OW 1
75040: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75041: LD_VAR 0 3
75045: PPUSH
75046: LD_INT 0
75048: PPUSH
75049: CALL_OW 109
// continue ;
75053: GO 74877
// end ; if IsInUnit ( j ) then
75055: LD_VAR 0 3
75059: PPUSH
75060: CALL_OW 310
75064: IFFALSE 75075
// ComExitBuilding ( j ) ;
75066: LD_VAR 0 3
75070: PPUSH
75071: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
75075: LD_ADDR_VAR 0 6
75079: PUSH
75080: LD_VAR 0 7
75084: PPUSH
75085: LD_VAR 0 3
75089: PPUSH
75090: CALL_OW 74
75094: ST_TO_ADDR
// if not ape then
75095: LD_VAR 0 6
75099: NOT
75100: IFFALSE 75104
// break ;
75102: GO 75214
// x := GetX ( ape ) ;
75104: LD_ADDR_VAR 0 4
75108: PUSH
75109: LD_VAR 0 6
75113: PPUSH
75114: CALL_OW 250
75118: ST_TO_ADDR
// y := GetY ( ape ) ;
75119: LD_ADDR_VAR 0 5
75123: PUSH
75124: LD_VAR 0 6
75128: PPUSH
75129: CALL_OW 251
75133: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
75134: LD_VAR 0 4
75138: PPUSH
75139: LD_VAR 0 5
75143: PPUSH
75144: CALL_OW 488
75148: NOT
75149: PUSH
75150: LD_VAR 0 11
75154: PPUSH
75155: LD_VAR 0 4
75159: PPUSH
75160: LD_VAR 0 5
75164: PPUSH
75165: LD_INT 20
75167: PPUSH
75168: CALL 21538 0 4
75172: PUSH
75173: LD_INT 4
75175: ARRAY
75176: OR
75177: IFFALSE 75181
// break ;
75179: GO 75214
// if not HasTask ( j ) then
75181: LD_VAR 0 3
75185: PPUSH
75186: CALL_OW 314
75190: NOT
75191: IFFALSE 75212
// ComTameXY ( j , x , y ) ;
75193: LD_VAR 0 3
75197: PPUSH
75198: LD_VAR 0 4
75202: PPUSH
75203: LD_VAR 0 5
75207: PPUSH
75208: CALL_OW 131
// end ; end ;
75212: GO 74877
75214: POP
75215: POP
// end ;
75216: GO 74433
75218: POP
75219: POP
// end ;
75220: LD_VAR 0 1
75224: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
75225: LD_INT 0
75227: PPUSH
75228: PPUSH
75229: PPUSH
75230: PPUSH
75231: PPUSH
75232: PPUSH
75233: PPUSH
75234: PPUSH
// if not mc_bases then
75235: LD_EXP 58
75239: NOT
75240: IFFALSE 75244
// exit ;
75242: GO 75870
// for i = 1 to mc_bases do
75244: LD_ADDR_VAR 0 2
75248: PUSH
75249: DOUBLE
75250: LD_INT 1
75252: DEC
75253: ST_TO_ADDR
75254: LD_EXP 58
75258: PUSH
75259: FOR_TO
75260: IFFALSE 75868
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
75262: LD_EXP 87
75266: PUSH
75267: LD_VAR 0 2
75271: ARRAY
75272: NOT
75273: PUSH
75274: LD_EXP 87
75278: PUSH
75279: LD_VAR 0 2
75283: ARRAY
75284: PPUSH
75285: LD_INT 25
75287: PUSH
75288: LD_INT 12
75290: PUSH
75291: EMPTY
75292: LIST
75293: LIST
75294: PPUSH
75295: CALL_OW 72
75299: NOT
75300: OR
75301: IFFALSE 75305
// continue ;
75303: GO 75259
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
75305: LD_ADDR_VAR 0 5
75309: PUSH
75310: LD_EXP 87
75314: PUSH
75315: LD_VAR 0 2
75319: ARRAY
75320: PUSH
75321: LD_INT 1
75323: ARRAY
75324: PPUSH
75325: CALL_OW 255
75329: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
75330: LD_VAR 0 5
75334: PPUSH
75335: LD_INT 2
75337: PPUSH
75338: CALL_OW 325
75342: IFFALSE 75595
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
75344: LD_ADDR_VAR 0 4
75348: PUSH
75349: LD_EXP 87
75353: PUSH
75354: LD_VAR 0 2
75358: ARRAY
75359: PPUSH
75360: LD_INT 25
75362: PUSH
75363: LD_INT 16
75365: PUSH
75366: EMPTY
75367: LIST
75368: LIST
75369: PPUSH
75370: CALL_OW 72
75374: ST_TO_ADDR
// if tmp < 6 then
75375: LD_VAR 0 4
75379: PUSH
75380: LD_INT 6
75382: LESS
75383: IFFALSE 75595
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75385: LD_ADDR_VAR 0 6
75389: PUSH
75390: LD_EXP 58
75394: PUSH
75395: LD_VAR 0 2
75399: ARRAY
75400: PPUSH
75401: LD_INT 2
75403: PUSH
75404: LD_INT 30
75406: PUSH
75407: LD_INT 0
75409: PUSH
75410: EMPTY
75411: LIST
75412: LIST
75413: PUSH
75414: LD_INT 30
75416: PUSH
75417: LD_INT 1
75419: PUSH
75420: EMPTY
75421: LIST
75422: LIST
75423: PUSH
75424: EMPTY
75425: LIST
75426: LIST
75427: LIST
75428: PPUSH
75429: CALL_OW 72
75433: ST_TO_ADDR
// if depot then
75434: LD_VAR 0 6
75438: IFFALSE 75595
// begin selected := 0 ;
75440: LD_ADDR_VAR 0 7
75444: PUSH
75445: LD_INT 0
75447: ST_TO_ADDR
// for j in depot do
75448: LD_ADDR_VAR 0 3
75452: PUSH
75453: LD_VAR 0 6
75457: PUSH
75458: FOR_IN
75459: IFFALSE 75490
// begin if UnitsInside ( j ) < 6 then
75461: LD_VAR 0 3
75465: PPUSH
75466: CALL_OW 313
75470: PUSH
75471: LD_INT 6
75473: LESS
75474: IFFALSE 75488
// begin selected := j ;
75476: LD_ADDR_VAR 0 7
75480: PUSH
75481: LD_VAR 0 3
75485: ST_TO_ADDR
// break ;
75486: GO 75490
// end ; end ;
75488: GO 75458
75490: POP
75491: POP
// if selected then
75492: LD_VAR 0 7
75496: IFFALSE 75595
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
75498: LD_ADDR_VAR 0 3
75502: PUSH
75503: LD_EXP 87
75507: PUSH
75508: LD_VAR 0 2
75512: ARRAY
75513: PPUSH
75514: LD_INT 25
75516: PUSH
75517: LD_INT 12
75519: PUSH
75520: EMPTY
75521: LIST
75522: LIST
75523: PPUSH
75524: CALL_OW 72
75528: PUSH
75529: FOR_IN
75530: IFFALSE 75593
// if not HasTask ( j ) then
75532: LD_VAR 0 3
75536: PPUSH
75537: CALL_OW 314
75541: NOT
75542: IFFALSE 75591
// begin if not IsInUnit ( j ) then
75544: LD_VAR 0 3
75548: PPUSH
75549: CALL_OW 310
75553: NOT
75554: IFFALSE 75570
// ComEnterUnit ( j , selected ) ;
75556: LD_VAR 0 3
75560: PPUSH
75561: LD_VAR 0 7
75565: PPUSH
75566: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
75570: LD_VAR 0 3
75574: PPUSH
75575: LD_INT 16
75577: PPUSH
75578: CALL_OW 183
// AddComExitBuilding ( j ) ;
75582: LD_VAR 0 3
75586: PPUSH
75587: CALL_OW 182
// end ;
75591: GO 75529
75593: POP
75594: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
75595: LD_VAR 0 5
75599: PPUSH
75600: LD_INT 11
75602: PPUSH
75603: CALL_OW 325
75607: IFFALSE 75866
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
75609: LD_ADDR_VAR 0 4
75613: PUSH
75614: LD_EXP 87
75618: PUSH
75619: LD_VAR 0 2
75623: ARRAY
75624: PPUSH
75625: LD_INT 25
75627: PUSH
75628: LD_INT 16
75630: PUSH
75631: EMPTY
75632: LIST
75633: LIST
75634: PPUSH
75635: CALL_OW 72
75639: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
75640: LD_VAR 0 4
75644: PUSH
75645: LD_INT 6
75647: GREATEREQUAL
75648: PUSH
75649: LD_VAR 0 5
75653: PPUSH
75654: LD_INT 2
75656: PPUSH
75657: CALL_OW 325
75661: NOT
75662: OR
75663: IFFALSE 75866
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
75665: LD_ADDR_VAR 0 8
75669: PUSH
75670: LD_EXP 58
75674: PUSH
75675: LD_VAR 0 2
75679: ARRAY
75680: PPUSH
75681: LD_INT 2
75683: PUSH
75684: LD_INT 30
75686: PUSH
75687: LD_INT 4
75689: PUSH
75690: EMPTY
75691: LIST
75692: LIST
75693: PUSH
75694: LD_INT 30
75696: PUSH
75697: LD_INT 5
75699: PUSH
75700: EMPTY
75701: LIST
75702: LIST
75703: PUSH
75704: EMPTY
75705: LIST
75706: LIST
75707: LIST
75708: PPUSH
75709: CALL_OW 72
75713: ST_TO_ADDR
// if barracks then
75714: LD_VAR 0 8
75718: IFFALSE 75866
// begin selected := 0 ;
75720: LD_ADDR_VAR 0 7
75724: PUSH
75725: LD_INT 0
75727: ST_TO_ADDR
// for j in barracks do
75728: LD_ADDR_VAR 0 3
75732: PUSH
75733: LD_VAR 0 8
75737: PUSH
75738: FOR_IN
75739: IFFALSE 75770
// begin if UnitsInside ( j ) < 6 then
75741: LD_VAR 0 3
75745: PPUSH
75746: CALL_OW 313
75750: PUSH
75751: LD_INT 6
75753: LESS
75754: IFFALSE 75768
// begin selected := j ;
75756: LD_ADDR_VAR 0 7
75760: PUSH
75761: LD_VAR 0 3
75765: ST_TO_ADDR
// break ;
75766: GO 75770
// end ; end ;
75768: GO 75738
75770: POP
75771: POP
// if selected then
75772: LD_VAR 0 7
75776: IFFALSE 75866
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
75778: LD_ADDR_VAR 0 3
75782: PUSH
75783: LD_EXP 87
75787: PUSH
75788: LD_VAR 0 2
75792: ARRAY
75793: PPUSH
75794: LD_INT 25
75796: PUSH
75797: LD_INT 12
75799: PUSH
75800: EMPTY
75801: LIST
75802: LIST
75803: PPUSH
75804: CALL_OW 72
75808: PUSH
75809: FOR_IN
75810: IFFALSE 75864
// if not IsInUnit ( j ) and not HasTask ( j ) then
75812: LD_VAR 0 3
75816: PPUSH
75817: CALL_OW 310
75821: NOT
75822: PUSH
75823: LD_VAR 0 3
75827: PPUSH
75828: CALL_OW 314
75832: NOT
75833: AND
75834: IFFALSE 75862
// begin ComEnterUnit ( j , selected ) ;
75836: LD_VAR 0 3
75840: PPUSH
75841: LD_VAR 0 7
75845: PPUSH
75846: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
75850: LD_VAR 0 3
75854: PPUSH
75855: LD_INT 15
75857: PPUSH
75858: CALL_OW 183
// end ;
75862: GO 75809
75864: POP
75865: POP
// end ; end ; end ; end ; end ;
75866: GO 75259
75868: POP
75869: POP
// end ;
75870: LD_VAR 0 1
75874: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
75875: LD_INT 0
75877: PPUSH
75878: PPUSH
75879: PPUSH
75880: PPUSH
// if not mc_bases then
75881: LD_EXP 58
75885: NOT
75886: IFFALSE 75890
// exit ;
75888: GO 76068
// for i = 1 to mc_bases do
75890: LD_ADDR_VAR 0 2
75894: PUSH
75895: DOUBLE
75896: LD_INT 1
75898: DEC
75899: ST_TO_ADDR
75900: LD_EXP 58
75904: PUSH
75905: FOR_TO
75906: IFFALSE 76066
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
75908: LD_ADDR_VAR 0 4
75912: PUSH
75913: LD_EXP 58
75917: PUSH
75918: LD_VAR 0 2
75922: ARRAY
75923: PPUSH
75924: LD_INT 25
75926: PUSH
75927: LD_INT 9
75929: PUSH
75930: EMPTY
75931: LIST
75932: LIST
75933: PPUSH
75934: CALL_OW 72
75938: ST_TO_ADDR
// if not tmp then
75939: LD_VAR 0 4
75943: NOT
75944: IFFALSE 75948
// continue ;
75946: GO 75905
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
75948: LD_EXP 84
75952: PUSH
75953: LD_VAR 0 2
75957: ARRAY
75958: PPUSH
75959: LD_INT 29
75961: PPUSH
75962: CALL_OW 325
75966: NOT
75967: PUSH
75968: LD_EXP 84
75972: PUSH
75973: LD_VAR 0 2
75977: ARRAY
75978: PPUSH
75979: LD_INT 28
75981: PPUSH
75982: CALL_OW 325
75986: NOT
75987: AND
75988: IFFALSE 75992
// continue ;
75990: GO 75905
// for j in tmp do
75992: LD_ADDR_VAR 0 3
75996: PUSH
75997: LD_VAR 0 4
76001: PUSH
76002: FOR_IN
76003: IFFALSE 76062
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
76005: LD_VAR 0 3
76009: PUSH
76010: LD_EXP 61
76014: PUSH
76015: LD_VAR 0 2
76019: ARRAY
76020: PUSH
76021: LD_INT 1
76023: ARRAY
76024: IN
76025: NOT
76026: PUSH
76027: LD_VAR 0 3
76031: PUSH
76032: LD_EXP 61
76036: PUSH
76037: LD_VAR 0 2
76041: ARRAY
76042: PUSH
76043: LD_INT 2
76045: ARRAY
76046: IN
76047: NOT
76048: AND
76049: IFFALSE 76060
// ComSpaceTimeShoot ( j ) ;
76051: LD_VAR 0 3
76055: PPUSH
76056: CALL 14732 0 1
76060: GO 76002
76062: POP
76063: POP
// end ;
76064: GO 75905
76066: POP
76067: POP
// end ;
76068: LD_VAR 0 1
76072: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
76073: LD_INT 0
76075: PPUSH
76076: PPUSH
76077: PPUSH
76078: PPUSH
76079: PPUSH
76080: PPUSH
76081: PPUSH
76082: PPUSH
76083: PPUSH
// if not mc_bases then
76084: LD_EXP 58
76088: NOT
76089: IFFALSE 76093
// exit ;
76091: GO 76715
// for i = 1 to mc_bases do
76093: LD_ADDR_VAR 0 2
76097: PUSH
76098: DOUBLE
76099: LD_INT 1
76101: DEC
76102: ST_TO_ADDR
76103: LD_EXP 58
76107: PUSH
76108: FOR_TO
76109: IFFALSE 76713
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
76111: LD_EXP 93
76115: PUSH
76116: LD_VAR 0 2
76120: ARRAY
76121: NOT
76122: PUSH
76123: LD_INT 38
76125: PPUSH
76126: LD_EXP 84
76130: PUSH
76131: LD_VAR 0 2
76135: ARRAY
76136: PPUSH
76137: CALL_OW 321
76141: PUSH
76142: LD_INT 2
76144: NONEQUAL
76145: OR
76146: IFFALSE 76150
// continue ;
76148: GO 76108
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
76150: LD_ADDR_VAR 0 8
76154: PUSH
76155: LD_EXP 58
76159: PUSH
76160: LD_VAR 0 2
76164: ARRAY
76165: PPUSH
76166: LD_INT 30
76168: PUSH
76169: LD_INT 34
76171: PUSH
76172: EMPTY
76173: LIST
76174: LIST
76175: PPUSH
76176: CALL_OW 72
76180: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
76181: LD_ADDR_VAR 0 9
76185: PUSH
76186: LD_EXP 58
76190: PUSH
76191: LD_VAR 0 2
76195: ARRAY
76196: PPUSH
76197: LD_INT 25
76199: PUSH
76200: LD_INT 4
76202: PUSH
76203: EMPTY
76204: LIST
76205: LIST
76206: PPUSH
76207: CALL_OW 72
76211: PPUSH
76212: LD_INT 0
76214: PPUSH
76215: CALL 53902 0 2
76219: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
76220: LD_VAR 0 9
76224: NOT
76225: PUSH
76226: LD_VAR 0 8
76230: NOT
76231: OR
76232: PUSH
76233: LD_EXP 58
76237: PUSH
76238: LD_VAR 0 2
76242: ARRAY
76243: PPUSH
76244: LD_INT 124
76246: PPUSH
76247: CALL 53902 0 2
76251: OR
76252: IFFALSE 76256
// continue ;
76254: GO 76108
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
76256: LD_EXP 94
76260: PUSH
76261: LD_VAR 0 2
76265: ARRAY
76266: PUSH
76267: LD_EXP 93
76271: PUSH
76272: LD_VAR 0 2
76276: ARRAY
76277: LESS
76278: PUSH
76279: LD_EXP 94
76283: PUSH
76284: LD_VAR 0 2
76288: ARRAY
76289: PUSH
76290: LD_VAR 0 8
76294: LESS
76295: AND
76296: IFFALSE 76711
// begin tmp := sci [ 1 ] ;
76298: LD_ADDR_VAR 0 7
76302: PUSH
76303: LD_VAR 0 9
76307: PUSH
76308: LD_INT 1
76310: ARRAY
76311: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
76312: LD_VAR 0 7
76316: PPUSH
76317: LD_INT 124
76319: PPUSH
76320: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
76324: LD_ADDR_VAR 0 3
76328: PUSH
76329: DOUBLE
76330: LD_EXP 93
76334: PUSH
76335: LD_VAR 0 2
76339: ARRAY
76340: INC
76341: ST_TO_ADDR
76342: LD_EXP 93
76346: PUSH
76347: LD_VAR 0 2
76351: ARRAY
76352: PUSH
76353: FOR_DOWNTO
76354: IFFALSE 76697
// begin if IsInUnit ( tmp ) then
76356: LD_VAR 0 7
76360: PPUSH
76361: CALL_OW 310
76365: IFFALSE 76376
// ComExitBuilding ( tmp ) ;
76367: LD_VAR 0 7
76371: PPUSH
76372: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
76376: LD_INT 35
76378: PPUSH
76379: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
76383: LD_VAR 0 7
76387: PPUSH
76388: CALL_OW 310
76392: NOT
76393: PUSH
76394: LD_VAR 0 7
76398: PPUSH
76399: CALL_OW 314
76403: NOT
76404: AND
76405: IFFALSE 76376
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
76407: LD_ADDR_VAR 0 6
76411: PUSH
76412: LD_VAR 0 7
76416: PPUSH
76417: CALL_OW 250
76421: PUSH
76422: LD_VAR 0 7
76426: PPUSH
76427: CALL_OW 251
76431: PUSH
76432: EMPTY
76433: LIST
76434: LIST
76435: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
76436: LD_INT 35
76438: PPUSH
76439: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
76443: LD_ADDR_VAR 0 4
76447: PUSH
76448: LD_EXP 93
76452: PUSH
76453: LD_VAR 0 2
76457: ARRAY
76458: PUSH
76459: LD_VAR 0 3
76463: ARRAY
76464: PUSH
76465: LD_INT 1
76467: ARRAY
76468: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
76469: LD_ADDR_VAR 0 5
76473: PUSH
76474: LD_EXP 93
76478: PUSH
76479: LD_VAR 0 2
76483: ARRAY
76484: PUSH
76485: LD_VAR 0 3
76489: ARRAY
76490: PUSH
76491: LD_INT 2
76493: ARRAY
76494: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
76495: LD_VAR 0 7
76499: PPUSH
76500: LD_INT 10
76502: PPUSH
76503: CALL 23235 0 2
76507: PUSH
76508: LD_INT 4
76510: ARRAY
76511: IFFALSE 76549
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
76513: LD_VAR 0 7
76517: PPUSH
76518: LD_VAR 0 6
76522: PUSH
76523: LD_INT 1
76525: ARRAY
76526: PPUSH
76527: LD_VAR 0 6
76531: PUSH
76532: LD_INT 2
76534: ARRAY
76535: PPUSH
76536: CALL_OW 111
// wait ( 0 0$10 ) ;
76540: LD_INT 350
76542: PPUSH
76543: CALL_OW 67
// end else
76547: GO 76575
// begin ComMoveXY ( tmp , x , y ) ;
76549: LD_VAR 0 7
76553: PPUSH
76554: LD_VAR 0 4
76558: PPUSH
76559: LD_VAR 0 5
76563: PPUSH
76564: CALL_OW 111
// wait ( 0 0$3 ) ;
76568: LD_INT 105
76570: PPUSH
76571: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
76575: LD_VAR 0 7
76579: PPUSH
76580: LD_VAR 0 4
76584: PPUSH
76585: LD_VAR 0 5
76589: PPUSH
76590: CALL_OW 307
76594: IFFALSE 76436
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
76596: LD_VAR 0 7
76600: PPUSH
76601: LD_VAR 0 4
76605: PPUSH
76606: LD_VAR 0 5
76610: PPUSH
76611: LD_VAR 0 8
76615: PUSH
76616: LD_VAR 0 3
76620: ARRAY
76621: PPUSH
76622: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
76626: LD_INT 35
76628: PPUSH
76629: CALL_OW 67
// until not HasTask ( tmp ) ;
76633: LD_VAR 0 7
76637: PPUSH
76638: CALL_OW 314
76642: NOT
76643: IFFALSE 76626
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
76645: LD_ADDR_EXP 94
76649: PUSH
76650: LD_EXP 94
76654: PPUSH
76655: LD_VAR 0 2
76659: PUSH
76660: LD_EXP 94
76664: PUSH
76665: LD_VAR 0 2
76669: ARRAY
76670: PUSH
76671: LD_INT 1
76673: PLUS
76674: PUSH
76675: EMPTY
76676: LIST
76677: LIST
76678: PPUSH
76679: LD_VAR 0 8
76683: PUSH
76684: LD_VAR 0 3
76688: ARRAY
76689: PPUSH
76690: CALL 20642 0 3
76694: ST_TO_ADDR
// end ;
76695: GO 76353
76697: POP
76698: POP
// MC_Reset ( i , 124 ) ;
76699: LD_VAR 0 2
76703: PPUSH
76704: LD_INT 124
76706: PPUSH
76707: CALL 60560 0 2
// end ; end ;
76711: GO 76108
76713: POP
76714: POP
// end ;
76715: LD_VAR 0 1
76719: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
76720: LD_INT 0
76722: PPUSH
76723: PPUSH
76724: PPUSH
// if not mc_bases then
76725: LD_EXP 58
76729: NOT
76730: IFFALSE 76734
// exit ;
76732: GO 77340
// for i = 1 to mc_bases do
76734: LD_ADDR_VAR 0 2
76738: PUSH
76739: DOUBLE
76740: LD_INT 1
76742: DEC
76743: ST_TO_ADDR
76744: LD_EXP 58
76748: PUSH
76749: FOR_TO
76750: IFFALSE 77338
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
76752: LD_ADDR_VAR 0 3
76756: PUSH
76757: LD_EXP 58
76761: PUSH
76762: LD_VAR 0 2
76766: ARRAY
76767: PPUSH
76768: LD_INT 25
76770: PUSH
76771: LD_INT 4
76773: PUSH
76774: EMPTY
76775: LIST
76776: LIST
76777: PPUSH
76778: CALL_OW 72
76782: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
76783: LD_VAR 0 3
76787: NOT
76788: PUSH
76789: LD_EXP 95
76793: PUSH
76794: LD_VAR 0 2
76798: ARRAY
76799: NOT
76800: OR
76801: PUSH
76802: LD_EXP 58
76806: PUSH
76807: LD_VAR 0 2
76811: ARRAY
76812: PPUSH
76813: LD_INT 2
76815: PUSH
76816: LD_INT 30
76818: PUSH
76819: LD_INT 0
76821: PUSH
76822: EMPTY
76823: LIST
76824: LIST
76825: PUSH
76826: LD_INT 30
76828: PUSH
76829: LD_INT 1
76831: PUSH
76832: EMPTY
76833: LIST
76834: LIST
76835: PUSH
76836: EMPTY
76837: LIST
76838: LIST
76839: LIST
76840: PPUSH
76841: CALL_OW 72
76845: NOT
76846: OR
76847: IFFALSE 76897
// begin if mc_deposits_finder [ i ] then
76849: LD_EXP 96
76853: PUSH
76854: LD_VAR 0 2
76858: ARRAY
76859: IFFALSE 76895
// begin MC_Reset ( i , 125 ) ;
76861: LD_VAR 0 2
76865: PPUSH
76866: LD_INT 125
76868: PPUSH
76869: CALL 60560 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76873: LD_ADDR_EXP 96
76877: PUSH
76878: LD_EXP 96
76882: PPUSH
76883: LD_VAR 0 2
76887: PPUSH
76888: EMPTY
76889: PPUSH
76890: CALL_OW 1
76894: ST_TO_ADDR
// end ; continue ;
76895: GO 76749
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
76897: LD_EXP 95
76901: PUSH
76902: LD_VAR 0 2
76906: ARRAY
76907: PUSH
76908: LD_INT 1
76910: ARRAY
76911: PUSH
76912: LD_INT 3
76914: ARRAY
76915: PUSH
76916: LD_INT 1
76918: EQUAL
76919: PUSH
76920: LD_INT 20
76922: PPUSH
76923: LD_EXP 84
76927: PUSH
76928: LD_VAR 0 2
76932: ARRAY
76933: PPUSH
76934: CALL_OW 321
76938: PUSH
76939: LD_INT 2
76941: NONEQUAL
76942: AND
76943: IFFALSE 76993
// begin if mc_deposits_finder [ i ] then
76945: LD_EXP 96
76949: PUSH
76950: LD_VAR 0 2
76954: ARRAY
76955: IFFALSE 76991
// begin MC_Reset ( i , 125 ) ;
76957: LD_VAR 0 2
76961: PPUSH
76962: LD_INT 125
76964: PPUSH
76965: CALL 60560 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76969: LD_ADDR_EXP 96
76973: PUSH
76974: LD_EXP 96
76978: PPUSH
76979: LD_VAR 0 2
76983: PPUSH
76984: EMPTY
76985: PPUSH
76986: CALL_OW 1
76990: ST_TO_ADDR
// end ; continue ;
76991: GO 76749
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
76993: LD_EXP 95
76997: PUSH
76998: LD_VAR 0 2
77002: ARRAY
77003: PUSH
77004: LD_INT 1
77006: ARRAY
77007: PUSH
77008: LD_INT 1
77010: ARRAY
77011: PPUSH
77012: LD_EXP 95
77016: PUSH
77017: LD_VAR 0 2
77021: ARRAY
77022: PUSH
77023: LD_INT 1
77025: ARRAY
77026: PUSH
77027: LD_INT 2
77029: ARRAY
77030: PPUSH
77031: LD_EXP 84
77035: PUSH
77036: LD_VAR 0 2
77040: ARRAY
77041: PPUSH
77042: CALL_OW 440
77046: IFFALSE 77089
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
77048: LD_ADDR_EXP 95
77052: PUSH
77053: LD_EXP 95
77057: PPUSH
77058: LD_VAR 0 2
77062: PPUSH
77063: LD_EXP 95
77067: PUSH
77068: LD_VAR 0 2
77072: ARRAY
77073: PPUSH
77074: LD_INT 1
77076: PPUSH
77077: CALL_OW 3
77081: PPUSH
77082: CALL_OW 1
77086: ST_TO_ADDR
77087: GO 77336
// begin if not mc_deposits_finder [ i ] then
77089: LD_EXP 96
77093: PUSH
77094: LD_VAR 0 2
77098: ARRAY
77099: NOT
77100: IFFALSE 77152
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
77102: LD_ADDR_EXP 96
77106: PUSH
77107: LD_EXP 96
77111: PPUSH
77112: LD_VAR 0 2
77116: PPUSH
77117: LD_VAR 0 3
77121: PUSH
77122: LD_INT 1
77124: ARRAY
77125: PUSH
77126: EMPTY
77127: LIST
77128: PPUSH
77129: CALL_OW 1
77133: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
77134: LD_VAR 0 3
77138: PUSH
77139: LD_INT 1
77141: ARRAY
77142: PPUSH
77143: LD_INT 125
77145: PPUSH
77146: CALL_OW 109
// end else
77150: GO 77336
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
77152: LD_EXP 96
77156: PUSH
77157: LD_VAR 0 2
77161: ARRAY
77162: PUSH
77163: LD_INT 1
77165: ARRAY
77166: PPUSH
77167: CALL_OW 310
77171: IFFALSE 77194
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
77173: LD_EXP 96
77177: PUSH
77178: LD_VAR 0 2
77182: ARRAY
77183: PUSH
77184: LD_INT 1
77186: ARRAY
77187: PPUSH
77188: CALL_OW 122
77192: GO 77336
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
77194: LD_EXP 96
77198: PUSH
77199: LD_VAR 0 2
77203: ARRAY
77204: PUSH
77205: LD_INT 1
77207: ARRAY
77208: PPUSH
77209: CALL_OW 314
77213: NOT
77214: PUSH
77215: LD_EXP 96
77219: PUSH
77220: LD_VAR 0 2
77224: ARRAY
77225: PUSH
77226: LD_INT 1
77228: ARRAY
77229: PPUSH
77230: LD_EXP 95
77234: PUSH
77235: LD_VAR 0 2
77239: ARRAY
77240: PUSH
77241: LD_INT 1
77243: ARRAY
77244: PUSH
77245: LD_INT 1
77247: ARRAY
77248: PPUSH
77249: LD_EXP 95
77253: PUSH
77254: LD_VAR 0 2
77258: ARRAY
77259: PUSH
77260: LD_INT 1
77262: ARRAY
77263: PUSH
77264: LD_INT 2
77266: ARRAY
77267: PPUSH
77268: CALL_OW 297
77272: PUSH
77273: LD_INT 6
77275: GREATER
77276: AND
77277: IFFALSE 77336
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
77279: LD_EXP 96
77283: PUSH
77284: LD_VAR 0 2
77288: ARRAY
77289: PUSH
77290: LD_INT 1
77292: ARRAY
77293: PPUSH
77294: LD_EXP 95
77298: PUSH
77299: LD_VAR 0 2
77303: ARRAY
77304: PUSH
77305: LD_INT 1
77307: ARRAY
77308: PUSH
77309: LD_INT 1
77311: ARRAY
77312: PPUSH
77313: LD_EXP 95
77317: PUSH
77318: LD_VAR 0 2
77322: ARRAY
77323: PUSH
77324: LD_INT 1
77326: ARRAY
77327: PUSH
77328: LD_INT 2
77330: ARRAY
77331: PPUSH
77332: CALL_OW 111
// end ; end ; end ;
77336: GO 76749
77338: POP
77339: POP
// end ;
77340: LD_VAR 0 1
77344: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
77345: LD_INT 0
77347: PPUSH
77348: PPUSH
77349: PPUSH
77350: PPUSH
77351: PPUSH
77352: PPUSH
77353: PPUSH
77354: PPUSH
77355: PPUSH
77356: PPUSH
77357: PPUSH
// if not mc_bases then
77358: LD_EXP 58
77362: NOT
77363: IFFALSE 77367
// exit ;
77365: GO 78091
// for i = 1 to mc_bases do
77367: LD_ADDR_VAR 0 2
77371: PUSH
77372: DOUBLE
77373: LD_INT 1
77375: DEC
77376: ST_TO_ADDR
77377: LD_EXP 58
77381: PUSH
77382: FOR_TO
77383: IFFALSE 78089
// begin if not mc_bases [ i ] then
77385: LD_EXP 58
77389: PUSH
77390: LD_VAR 0 2
77394: ARRAY
77395: NOT
77396: IFFALSE 77400
// continue ;
77398: GO 77382
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
77400: LD_ADDR_VAR 0 7
77404: PUSH
77405: LD_EXP 58
77409: PUSH
77410: LD_VAR 0 2
77414: ARRAY
77415: PUSH
77416: LD_INT 1
77418: ARRAY
77419: PPUSH
77420: CALL_OW 248
77424: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
77425: LD_VAR 0 7
77429: PUSH
77430: LD_INT 3
77432: EQUAL
77433: PUSH
77434: LD_EXP 77
77438: PUSH
77439: LD_VAR 0 2
77443: ARRAY
77444: PUSH
77445: LD_EXP 80
77449: PUSH
77450: LD_VAR 0 2
77454: ARRAY
77455: UNION
77456: PPUSH
77457: LD_INT 33
77459: PUSH
77460: LD_INT 2
77462: PUSH
77463: EMPTY
77464: LIST
77465: LIST
77466: PPUSH
77467: CALL_OW 72
77471: NOT
77472: OR
77473: IFFALSE 77477
// continue ;
77475: GO 77382
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
77477: LD_ADDR_VAR 0 9
77481: PUSH
77482: LD_EXP 58
77486: PUSH
77487: LD_VAR 0 2
77491: ARRAY
77492: PPUSH
77493: LD_INT 30
77495: PUSH
77496: LD_INT 36
77498: PUSH
77499: EMPTY
77500: LIST
77501: LIST
77502: PPUSH
77503: CALL_OW 72
77507: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
77508: LD_ADDR_VAR 0 10
77512: PUSH
77513: LD_EXP 77
77517: PUSH
77518: LD_VAR 0 2
77522: ARRAY
77523: PPUSH
77524: LD_INT 34
77526: PUSH
77527: LD_INT 31
77529: PUSH
77530: EMPTY
77531: LIST
77532: LIST
77533: PPUSH
77534: CALL_OW 72
77538: ST_TO_ADDR
// if not cts and not mcts then
77539: LD_VAR 0 9
77543: NOT
77544: PUSH
77545: LD_VAR 0 10
77549: NOT
77550: AND
77551: IFFALSE 77555
// continue ;
77553: GO 77382
// x := cts ;
77555: LD_ADDR_VAR 0 11
77559: PUSH
77560: LD_VAR 0 9
77564: ST_TO_ADDR
// if not x then
77565: LD_VAR 0 11
77569: NOT
77570: IFFALSE 77582
// x := mcts ;
77572: LD_ADDR_VAR 0 11
77576: PUSH
77577: LD_VAR 0 10
77581: ST_TO_ADDR
// if mc_remote_driver [ i ] then
77582: LD_EXP 98
77586: PUSH
77587: LD_VAR 0 2
77591: ARRAY
77592: IFFALSE 77861
// for j in mc_remote_driver [ i ] do
77594: LD_ADDR_VAR 0 3
77598: PUSH
77599: LD_EXP 98
77603: PUSH
77604: LD_VAR 0 2
77608: ARRAY
77609: PUSH
77610: FOR_IN
77611: IFFALSE 77859
// begin if GetClass ( j ) <> 3 then
77613: LD_VAR 0 3
77617: PPUSH
77618: CALL_OW 257
77622: PUSH
77623: LD_INT 3
77625: NONEQUAL
77626: IFFALSE 77679
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
77628: LD_ADDR_EXP 98
77632: PUSH
77633: LD_EXP 98
77637: PPUSH
77638: LD_VAR 0 2
77642: PPUSH
77643: LD_EXP 98
77647: PUSH
77648: LD_VAR 0 2
77652: ARRAY
77653: PUSH
77654: LD_VAR 0 3
77658: DIFF
77659: PPUSH
77660: CALL_OW 1
77664: ST_TO_ADDR
// SetTag ( j , 0 ) ;
77665: LD_VAR 0 3
77669: PPUSH
77670: LD_INT 0
77672: PPUSH
77673: CALL_OW 109
// continue ;
77677: GO 77610
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
77679: LD_VAR 0 3
77683: PPUSH
77684: CALL_OW 310
77688: NOT
77689: PUSH
77690: LD_VAR 0 3
77694: PPUSH
77695: CALL_OW 310
77699: PPUSH
77700: CALL_OW 266
77704: PUSH
77705: LD_INT 36
77707: NONEQUAL
77708: PUSH
77709: LD_VAR 0 3
77713: PPUSH
77714: CALL 53990 0 1
77718: NOT
77719: AND
77720: OR
77721: IFFALSE 77857
// begin if IsInUnit ( j ) then
77723: LD_VAR 0 3
77727: PPUSH
77728: CALL_OW 310
77732: IFFALSE 77743
// ComExitBuilding ( j ) ;
77734: LD_VAR 0 3
77738: PPUSH
77739: CALL_OW 122
// ct := 0 ;
77743: LD_ADDR_VAR 0 8
77747: PUSH
77748: LD_INT 0
77750: ST_TO_ADDR
// for k in x do
77751: LD_ADDR_VAR 0 4
77755: PUSH
77756: LD_VAR 0 11
77760: PUSH
77761: FOR_IN
77762: IFFALSE 77835
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
77764: LD_VAR 0 4
77768: PPUSH
77769: CALL_OW 264
77773: PUSH
77774: LD_INT 31
77776: EQUAL
77777: PUSH
77778: LD_VAR 0 4
77782: PPUSH
77783: CALL_OW 311
77787: NOT
77788: AND
77789: PUSH
77790: LD_VAR 0 4
77794: PPUSH
77795: CALL_OW 266
77799: PUSH
77800: LD_INT 36
77802: EQUAL
77803: PUSH
77804: LD_VAR 0 4
77808: PPUSH
77809: CALL_OW 313
77813: PUSH
77814: LD_INT 3
77816: LESS
77817: AND
77818: OR
77819: IFFALSE 77833
// begin ct := k ;
77821: LD_ADDR_VAR 0 8
77825: PUSH
77826: LD_VAR 0 4
77830: ST_TO_ADDR
// break ;
77831: GO 77835
// end ;
77833: GO 77761
77835: POP
77836: POP
// if ct then
77837: LD_VAR 0 8
77841: IFFALSE 77857
// ComEnterUnit ( j , ct ) ;
77843: LD_VAR 0 3
77847: PPUSH
77848: LD_VAR 0 8
77852: PPUSH
77853: CALL_OW 120
// end ; end ;
77857: GO 77610
77859: POP
77860: POP
// places := 0 ;
77861: LD_ADDR_VAR 0 5
77865: PUSH
77866: LD_INT 0
77868: ST_TO_ADDR
// for j = 1 to x do
77869: LD_ADDR_VAR 0 3
77873: PUSH
77874: DOUBLE
77875: LD_INT 1
77877: DEC
77878: ST_TO_ADDR
77879: LD_VAR 0 11
77883: PUSH
77884: FOR_TO
77885: IFFALSE 77940
// if GetWeapon ( x [ j ] ) = ar_control_tower then
77887: LD_VAR 0 11
77891: PUSH
77892: LD_VAR 0 3
77896: ARRAY
77897: PPUSH
77898: CALL_OW 264
77902: PUSH
77903: LD_INT 31
77905: EQUAL
77906: IFFALSE 77924
// places := places + 1 else
77908: LD_ADDR_VAR 0 5
77912: PUSH
77913: LD_VAR 0 5
77917: PUSH
77918: LD_INT 1
77920: PLUS
77921: ST_TO_ADDR
77922: GO 77938
// places := places + 3 ;
77924: LD_ADDR_VAR 0 5
77928: PUSH
77929: LD_VAR 0 5
77933: PUSH
77934: LD_INT 3
77936: PLUS
77937: ST_TO_ADDR
77938: GO 77884
77940: POP
77941: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
77942: LD_ADDR_VAR 0 6
77946: PUSH
77947: LD_EXP 58
77951: PUSH
77952: LD_VAR 0 2
77956: ARRAY
77957: PPUSH
77958: LD_INT 25
77960: PUSH
77961: LD_INT 3
77963: PUSH
77964: EMPTY
77965: LIST
77966: LIST
77967: PPUSH
77968: CALL_OW 72
77972: PUSH
77973: LD_EXP 98
77977: PUSH
77978: LD_VAR 0 2
77982: ARRAY
77983: DIFF
77984: PPUSH
77985: LD_INT 3
77987: PPUSH
77988: CALL 54890 0 2
77992: ST_TO_ADDR
// if not tmp then
77993: LD_VAR 0 6
77997: NOT
77998: IFFALSE 78002
// continue ;
78000: GO 77382
// places := places - mc_remote_driver [ i ] ;
78002: LD_ADDR_VAR 0 5
78006: PUSH
78007: LD_VAR 0 5
78011: PUSH
78012: LD_EXP 98
78016: PUSH
78017: LD_VAR 0 2
78021: ARRAY
78022: MINUS
78023: ST_TO_ADDR
// if places then
78024: LD_VAR 0 5
78028: IFFALSE 78087
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
78030: LD_ADDR_EXP 98
78034: PUSH
78035: LD_EXP 98
78039: PPUSH
78040: LD_VAR 0 2
78044: PPUSH
78045: LD_EXP 98
78049: PUSH
78050: LD_VAR 0 2
78054: ARRAY
78055: PUSH
78056: LD_VAR 0 6
78060: PUSH
78061: LD_INT 1
78063: ARRAY
78064: UNION
78065: PPUSH
78066: CALL_OW 1
78070: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
78071: LD_VAR 0 6
78075: PUSH
78076: LD_INT 1
78078: ARRAY
78079: PPUSH
78080: LD_INT 126
78082: PPUSH
78083: CALL_OW 109
// end ; end ;
78087: GO 77382
78089: POP
78090: POP
// end ;
78091: LD_VAR 0 1
78095: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
78096: LD_INT 0
78098: PPUSH
78099: PPUSH
78100: PPUSH
78101: PPUSH
78102: PPUSH
78103: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
78104: LD_VAR 0 1
78108: NOT
78109: PUSH
78110: LD_VAR 0 2
78114: NOT
78115: OR
78116: PUSH
78117: LD_VAR 0 3
78121: NOT
78122: OR
78123: PUSH
78124: LD_VAR 0 4
78128: PUSH
78129: LD_INT 1
78131: PUSH
78132: LD_INT 2
78134: PUSH
78135: LD_INT 3
78137: PUSH
78138: LD_INT 4
78140: PUSH
78141: LD_INT 5
78143: PUSH
78144: LD_INT 8
78146: PUSH
78147: LD_INT 9
78149: PUSH
78150: LD_INT 15
78152: PUSH
78153: LD_INT 16
78155: PUSH
78156: EMPTY
78157: LIST
78158: LIST
78159: LIST
78160: LIST
78161: LIST
78162: LIST
78163: LIST
78164: LIST
78165: LIST
78166: IN
78167: NOT
78168: OR
78169: IFFALSE 78173
// exit ;
78171: GO 79073
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
78173: LD_ADDR_VAR 0 2
78177: PUSH
78178: LD_VAR 0 2
78182: PPUSH
78183: LD_INT 21
78185: PUSH
78186: LD_INT 3
78188: PUSH
78189: EMPTY
78190: LIST
78191: LIST
78192: PUSH
78193: LD_INT 24
78195: PUSH
78196: LD_INT 250
78198: PUSH
78199: EMPTY
78200: LIST
78201: LIST
78202: PUSH
78203: EMPTY
78204: LIST
78205: LIST
78206: PPUSH
78207: CALL_OW 72
78211: ST_TO_ADDR
// case class of 1 , 15 :
78212: LD_VAR 0 4
78216: PUSH
78217: LD_INT 1
78219: DOUBLE
78220: EQUAL
78221: IFTRUE 78231
78223: LD_INT 15
78225: DOUBLE
78226: EQUAL
78227: IFTRUE 78231
78229: GO 78316
78231: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
78232: LD_ADDR_VAR 0 8
78236: PUSH
78237: LD_VAR 0 2
78241: PPUSH
78242: LD_INT 2
78244: PUSH
78245: LD_INT 30
78247: PUSH
78248: LD_INT 32
78250: PUSH
78251: EMPTY
78252: LIST
78253: LIST
78254: PUSH
78255: LD_INT 30
78257: PUSH
78258: LD_INT 31
78260: PUSH
78261: EMPTY
78262: LIST
78263: LIST
78264: PUSH
78265: EMPTY
78266: LIST
78267: LIST
78268: LIST
78269: PPUSH
78270: CALL_OW 72
78274: PUSH
78275: LD_VAR 0 2
78279: PPUSH
78280: LD_INT 2
78282: PUSH
78283: LD_INT 30
78285: PUSH
78286: LD_INT 4
78288: PUSH
78289: EMPTY
78290: LIST
78291: LIST
78292: PUSH
78293: LD_INT 30
78295: PUSH
78296: LD_INT 5
78298: PUSH
78299: EMPTY
78300: LIST
78301: LIST
78302: PUSH
78303: EMPTY
78304: LIST
78305: LIST
78306: LIST
78307: PPUSH
78308: CALL_OW 72
78312: ADD
78313: ST_TO_ADDR
78314: GO 78562
78316: LD_INT 2
78318: DOUBLE
78319: EQUAL
78320: IFTRUE 78330
78322: LD_INT 16
78324: DOUBLE
78325: EQUAL
78326: IFTRUE 78330
78328: GO 78376
78330: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
78331: LD_ADDR_VAR 0 8
78335: PUSH
78336: LD_VAR 0 2
78340: PPUSH
78341: LD_INT 2
78343: PUSH
78344: LD_INT 30
78346: PUSH
78347: LD_INT 0
78349: PUSH
78350: EMPTY
78351: LIST
78352: LIST
78353: PUSH
78354: LD_INT 30
78356: PUSH
78357: LD_INT 1
78359: PUSH
78360: EMPTY
78361: LIST
78362: LIST
78363: PUSH
78364: EMPTY
78365: LIST
78366: LIST
78367: LIST
78368: PPUSH
78369: CALL_OW 72
78373: ST_TO_ADDR
78374: GO 78562
78376: LD_INT 3
78378: DOUBLE
78379: EQUAL
78380: IFTRUE 78384
78382: GO 78430
78384: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
78385: LD_ADDR_VAR 0 8
78389: PUSH
78390: LD_VAR 0 2
78394: PPUSH
78395: LD_INT 2
78397: PUSH
78398: LD_INT 30
78400: PUSH
78401: LD_INT 2
78403: PUSH
78404: EMPTY
78405: LIST
78406: LIST
78407: PUSH
78408: LD_INT 30
78410: PUSH
78411: LD_INT 3
78413: PUSH
78414: EMPTY
78415: LIST
78416: LIST
78417: PUSH
78418: EMPTY
78419: LIST
78420: LIST
78421: LIST
78422: PPUSH
78423: CALL_OW 72
78427: ST_TO_ADDR
78428: GO 78562
78430: LD_INT 4
78432: DOUBLE
78433: EQUAL
78434: IFTRUE 78438
78436: GO 78495
78438: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
78439: LD_ADDR_VAR 0 8
78443: PUSH
78444: LD_VAR 0 2
78448: PPUSH
78449: LD_INT 2
78451: PUSH
78452: LD_INT 30
78454: PUSH
78455: LD_INT 6
78457: PUSH
78458: EMPTY
78459: LIST
78460: LIST
78461: PUSH
78462: LD_INT 30
78464: PUSH
78465: LD_INT 7
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: PUSH
78472: LD_INT 30
78474: PUSH
78475: LD_INT 8
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: LIST
78486: LIST
78487: PPUSH
78488: CALL_OW 72
78492: ST_TO_ADDR
78493: GO 78562
78495: LD_INT 5
78497: DOUBLE
78498: EQUAL
78499: IFTRUE 78515
78501: LD_INT 8
78503: DOUBLE
78504: EQUAL
78505: IFTRUE 78515
78507: LD_INT 9
78509: DOUBLE
78510: EQUAL
78511: IFTRUE 78515
78513: GO 78561
78515: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
78516: LD_ADDR_VAR 0 8
78520: PUSH
78521: LD_VAR 0 2
78525: PPUSH
78526: LD_INT 2
78528: PUSH
78529: LD_INT 30
78531: PUSH
78532: LD_INT 4
78534: PUSH
78535: EMPTY
78536: LIST
78537: LIST
78538: PUSH
78539: LD_INT 30
78541: PUSH
78542: LD_INT 5
78544: PUSH
78545: EMPTY
78546: LIST
78547: LIST
78548: PUSH
78549: EMPTY
78550: LIST
78551: LIST
78552: LIST
78553: PPUSH
78554: CALL_OW 72
78558: ST_TO_ADDR
78559: GO 78562
78561: POP
// if not tmp then
78562: LD_VAR 0 8
78566: NOT
78567: IFFALSE 78571
// exit ;
78569: GO 79073
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
78571: LD_VAR 0 4
78575: PUSH
78576: LD_INT 1
78578: PUSH
78579: LD_INT 15
78581: PUSH
78582: EMPTY
78583: LIST
78584: LIST
78585: IN
78586: PUSH
78587: LD_EXP 67
78591: PUSH
78592: LD_VAR 0 1
78596: ARRAY
78597: AND
78598: IFFALSE 78754
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
78600: LD_ADDR_VAR 0 9
78604: PUSH
78605: LD_EXP 67
78609: PUSH
78610: LD_VAR 0 1
78614: ARRAY
78615: PUSH
78616: LD_INT 1
78618: ARRAY
78619: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
78620: LD_VAR 0 9
78624: PUSH
78625: LD_EXP 68
78629: PUSH
78630: LD_VAR 0 1
78634: ARRAY
78635: IN
78636: NOT
78637: IFFALSE 78752
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
78639: LD_ADDR_EXP 68
78643: PUSH
78644: LD_EXP 68
78648: PPUSH
78649: LD_VAR 0 1
78653: PUSH
78654: LD_EXP 68
78658: PUSH
78659: LD_VAR 0 1
78663: ARRAY
78664: PUSH
78665: LD_INT 1
78667: PLUS
78668: PUSH
78669: EMPTY
78670: LIST
78671: LIST
78672: PPUSH
78673: LD_VAR 0 9
78677: PPUSH
78678: CALL 20642 0 3
78682: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
78683: LD_ADDR_EXP 67
78687: PUSH
78688: LD_EXP 67
78692: PPUSH
78693: LD_VAR 0 1
78697: PPUSH
78698: LD_EXP 67
78702: PUSH
78703: LD_VAR 0 1
78707: ARRAY
78708: PUSH
78709: LD_VAR 0 9
78713: DIFF
78714: PPUSH
78715: CALL_OW 1
78719: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
78720: LD_VAR 0 3
78724: PPUSH
78725: LD_EXP 68
78729: PUSH
78730: LD_VAR 0 1
78734: ARRAY
78735: PUSH
78736: LD_EXP 68
78740: PUSH
78741: LD_VAR 0 1
78745: ARRAY
78746: ARRAY
78747: PPUSH
78748: CALL_OW 120
// end ; exit ;
78752: GO 79073
// end ; if tmp > 1 then
78754: LD_VAR 0 8
78758: PUSH
78759: LD_INT 1
78761: GREATER
78762: IFFALSE 78866
// for i = 2 to tmp do
78764: LD_ADDR_VAR 0 6
78768: PUSH
78769: DOUBLE
78770: LD_INT 2
78772: DEC
78773: ST_TO_ADDR
78774: LD_VAR 0 8
78778: PUSH
78779: FOR_TO
78780: IFFALSE 78864
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
78782: LD_VAR 0 8
78786: PUSH
78787: LD_VAR 0 6
78791: ARRAY
78792: PPUSH
78793: CALL_OW 461
78797: PUSH
78798: LD_INT 6
78800: EQUAL
78801: IFFALSE 78862
// begin x := tmp [ i ] ;
78803: LD_ADDR_VAR 0 9
78807: PUSH
78808: LD_VAR 0 8
78812: PUSH
78813: LD_VAR 0 6
78817: ARRAY
78818: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
78819: LD_ADDR_VAR 0 8
78823: PUSH
78824: LD_VAR 0 8
78828: PPUSH
78829: LD_VAR 0 6
78833: PPUSH
78834: CALL_OW 3
78838: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
78839: LD_ADDR_VAR 0 8
78843: PUSH
78844: LD_VAR 0 8
78848: PPUSH
78849: LD_INT 1
78851: PPUSH
78852: LD_VAR 0 9
78856: PPUSH
78857: CALL_OW 2
78861: ST_TO_ADDR
// end ;
78862: GO 78779
78864: POP
78865: POP
// for i in tmp do
78866: LD_ADDR_VAR 0 6
78870: PUSH
78871: LD_VAR 0 8
78875: PUSH
78876: FOR_IN
78877: IFFALSE 78946
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
78879: LD_VAR 0 6
78883: PPUSH
78884: CALL_OW 313
78888: PUSH
78889: LD_INT 6
78891: LESS
78892: PUSH
78893: LD_VAR 0 6
78897: PPUSH
78898: CALL_OW 266
78902: PUSH
78903: LD_INT 31
78905: PUSH
78906: LD_INT 32
78908: PUSH
78909: EMPTY
78910: LIST
78911: LIST
78912: IN
78913: NOT
78914: AND
78915: PUSH
78916: LD_VAR 0 6
78920: PPUSH
78921: CALL_OW 313
78925: PUSH
78926: LD_INT 0
78928: EQUAL
78929: OR
78930: IFFALSE 78944
// begin j := i ;
78932: LD_ADDR_VAR 0 7
78936: PUSH
78937: LD_VAR 0 6
78941: ST_TO_ADDR
// break ;
78942: GO 78946
// end ; end ;
78944: GO 78876
78946: POP
78947: POP
// if j then
78948: LD_VAR 0 7
78952: IFFALSE 78970
// ComEnterUnit ( unit , j ) else
78954: LD_VAR 0 3
78958: PPUSH
78959: LD_VAR 0 7
78963: PPUSH
78964: CALL_OW 120
78968: GO 79073
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78970: LD_ADDR_VAR 0 10
78974: PUSH
78975: LD_VAR 0 2
78979: PPUSH
78980: LD_INT 2
78982: PUSH
78983: LD_INT 30
78985: PUSH
78986: LD_INT 0
78988: PUSH
78989: EMPTY
78990: LIST
78991: LIST
78992: PUSH
78993: LD_INT 30
78995: PUSH
78996: LD_INT 1
78998: PUSH
78999: EMPTY
79000: LIST
79001: LIST
79002: PUSH
79003: EMPTY
79004: LIST
79005: LIST
79006: LIST
79007: PPUSH
79008: CALL_OW 72
79012: ST_TO_ADDR
// if depot then
79013: LD_VAR 0 10
79017: IFFALSE 79073
// begin depot := NearestUnitToUnit ( depot , unit ) ;
79019: LD_ADDR_VAR 0 10
79023: PUSH
79024: LD_VAR 0 10
79028: PPUSH
79029: LD_VAR 0 3
79033: PPUSH
79034: CALL_OW 74
79038: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
79039: LD_VAR 0 3
79043: PPUSH
79044: LD_VAR 0 10
79048: PPUSH
79049: CALL_OW 296
79053: PUSH
79054: LD_INT 10
79056: GREATER
79057: IFFALSE 79073
// ComStandNearbyBuilding ( unit , depot ) ;
79059: LD_VAR 0 3
79063: PPUSH
79064: LD_VAR 0 10
79068: PPUSH
79069: CALL 15349 0 2
// end ; end ; end ;
79073: LD_VAR 0 5
79077: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
79078: LD_INT 0
79080: PPUSH
79081: PPUSH
79082: PPUSH
79083: PPUSH
// if not mc_bases then
79084: LD_EXP 58
79088: NOT
79089: IFFALSE 79093
// exit ;
79091: GO 79332
// for i = 1 to mc_bases do
79093: LD_ADDR_VAR 0 2
79097: PUSH
79098: DOUBLE
79099: LD_INT 1
79101: DEC
79102: ST_TO_ADDR
79103: LD_EXP 58
79107: PUSH
79108: FOR_TO
79109: IFFALSE 79330
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
79111: LD_ADDR_VAR 0 4
79115: PUSH
79116: LD_EXP 58
79120: PUSH
79121: LD_VAR 0 2
79125: ARRAY
79126: PPUSH
79127: LD_INT 21
79129: PUSH
79130: LD_INT 1
79132: PUSH
79133: EMPTY
79134: LIST
79135: LIST
79136: PPUSH
79137: CALL_OW 72
79141: PUSH
79142: LD_EXP 87
79146: PUSH
79147: LD_VAR 0 2
79151: ARRAY
79152: UNION
79153: ST_TO_ADDR
// if not tmp then
79154: LD_VAR 0 4
79158: NOT
79159: IFFALSE 79163
// continue ;
79161: GO 79108
// for j in tmp do
79163: LD_ADDR_VAR 0 3
79167: PUSH
79168: LD_VAR 0 4
79172: PUSH
79173: FOR_IN
79174: IFFALSE 79326
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
79176: LD_VAR 0 3
79180: PPUSH
79181: CALL_OW 110
79185: NOT
79186: PUSH
79187: LD_VAR 0 3
79191: PPUSH
79192: CALL_OW 314
79196: NOT
79197: AND
79198: PUSH
79199: LD_VAR 0 3
79203: PPUSH
79204: CALL_OW 311
79208: NOT
79209: AND
79210: PUSH
79211: LD_VAR 0 3
79215: PPUSH
79216: CALL_OW 310
79220: NOT
79221: AND
79222: PUSH
79223: LD_VAR 0 3
79227: PUSH
79228: LD_EXP 61
79232: PUSH
79233: LD_VAR 0 2
79237: ARRAY
79238: PUSH
79239: LD_INT 1
79241: ARRAY
79242: IN
79243: NOT
79244: AND
79245: PUSH
79246: LD_VAR 0 3
79250: PUSH
79251: LD_EXP 61
79255: PUSH
79256: LD_VAR 0 2
79260: ARRAY
79261: PUSH
79262: LD_INT 2
79264: ARRAY
79265: IN
79266: NOT
79267: AND
79268: PUSH
79269: LD_VAR 0 3
79273: PUSH
79274: LD_EXP 70
79278: PUSH
79279: LD_VAR 0 2
79283: ARRAY
79284: IN
79285: NOT
79286: AND
79287: IFFALSE 79324
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
79289: LD_VAR 0 2
79293: PPUSH
79294: LD_EXP 58
79298: PUSH
79299: LD_VAR 0 2
79303: ARRAY
79304: PPUSH
79305: LD_VAR 0 3
79309: PPUSH
79310: LD_VAR 0 3
79314: PPUSH
79315: CALL_OW 257
79319: PPUSH
79320: CALL 78096 0 4
// end ;
79324: GO 79173
79326: POP
79327: POP
// end ;
79328: GO 79108
79330: POP
79331: POP
// end ;
79332: LD_VAR 0 1
79336: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
79337: LD_INT 0
79339: PPUSH
79340: PPUSH
79341: PPUSH
79342: PPUSH
79343: PPUSH
79344: PPUSH
// if not mc_bases [ base ] then
79345: LD_EXP 58
79349: PUSH
79350: LD_VAR 0 1
79354: ARRAY
79355: NOT
79356: IFFALSE 79360
// exit ;
79358: GO 79542
// tmp := [ ] ;
79360: LD_ADDR_VAR 0 6
79364: PUSH
79365: EMPTY
79366: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
79367: LD_ADDR_VAR 0 7
79371: PUSH
79372: LD_VAR 0 3
79376: PPUSH
79377: LD_INT 0
79379: PPUSH
79380: CALL_OW 517
79384: ST_TO_ADDR
// if not list then
79385: LD_VAR 0 7
79389: NOT
79390: IFFALSE 79394
// exit ;
79392: GO 79542
// for i = 1 to amount do
79394: LD_ADDR_VAR 0 5
79398: PUSH
79399: DOUBLE
79400: LD_INT 1
79402: DEC
79403: ST_TO_ADDR
79404: LD_VAR 0 2
79408: PUSH
79409: FOR_TO
79410: IFFALSE 79490
// begin x := rand ( 1 , list [ 1 ] ) ;
79412: LD_ADDR_VAR 0 8
79416: PUSH
79417: LD_INT 1
79419: PPUSH
79420: LD_VAR 0 7
79424: PUSH
79425: LD_INT 1
79427: ARRAY
79428: PPUSH
79429: CALL_OW 12
79433: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
79434: LD_ADDR_VAR 0 6
79438: PUSH
79439: LD_VAR 0 6
79443: PPUSH
79444: LD_VAR 0 5
79448: PPUSH
79449: LD_VAR 0 7
79453: PUSH
79454: LD_INT 1
79456: ARRAY
79457: PUSH
79458: LD_VAR 0 8
79462: ARRAY
79463: PUSH
79464: LD_VAR 0 7
79468: PUSH
79469: LD_INT 2
79471: ARRAY
79472: PUSH
79473: LD_VAR 0 8
79477: ARRAY
79478: PUSH
79479: EMPTY
79480: LIST
79481: LIST
79482: PPUSH
79483: CALL_OW 1
79487: ST_TO_ADDR
// end ;
79488: GO 79409
79490: POP
79491: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
79492: LD_ADDR_EXP 71
79496: PUSH
79497: LD_EXP 71
79501: PPUSH
79502: LD_VAR 0 1
79506: PPUSH
79507: LD_VAR 0 6
79511: PPUSH
79512: CALL_OW 1
79516: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
79517: LD_ADDR_EXP 73
79521: PUSH
79522: LD_EXP 73
79526: PPUSH
79527: LD_VAR 0 1
79531: PPUSH
79532: LD_VAR 0 3
79536: PPUSH
79537: CALL_OW 1
79541: ST_TO_ADDR
// end ;
79542: LD_VAR 0 4
79546: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
79547: LD_INT 0
79549: PPUSH
// if not mc_bases [ base ] then
79550: LD_EXP 58
79554: PUSH
79555: LD_VAR 0 1
79559: ARRAY
79560: NOT
79561: IFFALSE 79565
// exit ;
79563: GO 79590
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
79565: LD_ADDR_EXP 63
79569: PUSH
79570: LD_EXP 63
79574: PPUSH
79575: LD_VAR 0 1
79579: PPUSH
79580: LD_VAR 0 2
79584: PPUSH
79585: CALL_OW 1
79589: ST_TO_ADDR
// end ;
79590: LD_VAR 0 3
79594: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
79595: LD_INT 0
79597: PPUSH
// if not mc_bases [ base ] then
79598: LD_EXP 58
79602: PUSH
79603: LD_VAR 0 1
79607: ARRAY
79608: NOT
79609: IFFALSE 79613
// exit ;
79611: GO 79650
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
79613: LD_ADDR_EXP 63
79617: PUSH
79618: LD_EXP 63
79622: PPUSH
79623: LD_VAR 0 1
79627: PPUSH
79628: LD_EXP 63
79632: PUSH
79633: LD_VAR 0 1
79637: ARRAY
79638: PUSH
79639: LD_VAR 0 2
79643: UNION
79644: PPUSH
79645: CALL_OW 1
79649: ST_TO_ADDR
// end ;
79650: LD_VAR 0 3
79654: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
79655: LD_INT 0
79657: PPUSH
// if not mc_bases [ base ] then
79658: LD_EXP 58
79662: PUSH
79663: LD_VAR 0 1
79667: ARRAY
79668: NOT
79669: IFFALSE 79673
// exit ;
79671: GO 79698
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
79673: LD_ADDR_EXP 79
79677: PUSH
79678: LD_EXP 79
79682: PPUSH
79683: LD_VAR 0 1
79687: PPUSH
79688: LD_VAR 0 2
79692: PPUSH
79693: CALL_OW 1
79697: ST_TO_ADDR
// end ;
79698: LD_VAR 0 3
79702: RET
// export function MC_InsertProduceList ( base , components ) ; begin
79703: LD_INT 0
79705: PPUSH
// if not mc_bases [ base ] then
79706: LD_EXP 58
79710: PUSH
79711: LD_VAR 0 1
79715: ARRAY
79716: NOT
79717: IFFALSE 79721
// exit ;
79719: GO 79758
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
79721: LD_ADDR_EXP 79
79725: PUSH
79726: LD_EXP 79
79730: PPUSH
79731: LD_VAR 0 1
79735: PPUSH
79736: LD_EXP 79
79740: PUSH
79741: LD_VAR 0 1
79745: ARRAY
79746: PUSH
79747: LD_VAR 0 2
79751: ADD
79752: PPUSH
79753: CALL_OW 1
79757: ST_TO_ADDR
// end ;
79758: LD_VAR 0 3
79762: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
79763: LD_INT 0
79765: PPUSH
// if not mc_bases [ base ] then
79766: LD_EXP 58
79770: PUSH
79771: LD_VAR 0 1
79775: ARRAY
79776: NOT
79777: IFFALSE 79781
// exit ;
79779: GO 79835
// mc_defender := Replace ( mc_defender , base , deflist ) ;
79781: LD_ADDR_EXP 80
79785: PUSH
79786: LD_EXP 80
79790: PPUSH
79791: LD_VAR 0 1
79795: PPUSH
79796: LD_VAR 0 2
79800: PPUSH
79801: CALL_OW 1
79805: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
79806: LD_ADDR_EXP 69
79810: PUSH
79811: LD_EXP 69
79815: PPUSH
79816: LD_VAR 0 1
79820: PPUSH
79821: LD_VAR 0 2
79825: PUSH
79826: LD_INT 0
79828: PLUS
79829: PPUSH
79830: CALL_OW 1
79834: ST_TO_ADDR
// end ;
79835: LD_VAR 0 3
79839: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
79840: LD_INT 0
79842: PPUSH
// if not mc_bases [ base ] then
79843: LD_EXP 58
79847: PUSH
79848: LD_VAR 0 1
79852: ARRAY
79853: NOT
79854: IFFALSE 79858
// exit ;
79856: GO 79883
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
79858: LD_ADDR_EXP 69
79862: PUSH
79863: LD_EXP 69
79867: PPUSH
79868: LD_VAR 0 1
79872: PPUSH
79873: LD_VAR 0 2
79877: PPUSH
79878: CALL_OW 1
79882: ST_TO_ADDR
// end ;
79883: LD_VAR 0 3
79887: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
79888: LD_INT 0
79890: PPUSH
79891: PPUSH
79892: PPUSH
79893: PPUSH
// if not mc_bases [ base ] then
79894: LD_EXP 58
79898: PUSH
79899: LD_VAR 0 1
79903: ARRAY
79904: NOT
79905: IFFALSE 79909
// exit ;
79907: GO 79974
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
79909: LD_ADDR_EXP 78
79913: PUSH
79914: LD_EXP 78
79918: PPUSH
79919: LD_VAR 0 1
79923: PUSH
79924: LD_EXP 78
79928: PUSH
79929: LD_VAR 0 1
79933: ARRAY
79934: PUSH
79935: LD_INT 1
79937: PLUS
79938: PUSH
79939: EMPTY
79940: LIST
79941: LIST
79942: PPUSH
79943: LD_VAR 0 1
79947: PUSH
79948: LD_VAR 0 2
79952: PUSH
79953: LD_VAR 0 3
79957: PUSH
79958: LD_VAR 0 4
79962: PUSH
79963: EMPTY
79964: LIST
79965: LIST
79966: LIST
79967: LIST
79968: PPUSH
79969: CALL 20642 0 3
79973: ST_TO_ADDR
// end ;
79974: LD_VAR 0 5
79978: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
79979: LD_INT 0
79981: PPUSH
// if not mc_bases [ base ] then
79982: LD_EXP 58
79986: PUSH
79987: LD_VAR 0 1
79991: ARRAY
79992: NOT
79993: IFFALSE 79997
// exit ;
79995: GO 80022
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
79997: LD_ADDR_EXP 95
80001: PUSH
80002: LD_EXP 95
80006: PPUSH
80007: LD_VAR 0 1
80011: PPUSH
80012: LD_VAR 0 2
80016: PPUSH
80017: CALL_OW 1
80021: ST_TO_ADDR
// end ;
80022: LD_VAR 0 3
80026: RET
// export function MC_GetMinesField ( base ) ; begin
80027: LD_INT 0
80029: PPUSH
// result := mc_mines [ base ] ;
80030: LD_ADDR_VAR 0 2
80034: PUSH
80035: LD_EXP 71
80039: PUSH
80040: LD_VAR 0 1
80044: ARRAY
80045: ST_TO_ADDR
// end ;
80046: LD_VAR 0 2
80050: RET
// export function MC_GetProduceList ( base ) ; begin
80051: LD_INT 0
80053: PPUSH
// result := mc_produce [ base ] ;
80054: LD_ADDR_VAR 0 2
80058: PUSH
80059: LD_EXP 79
80063: PUSH
80064: LD_VAR 0 1
80068: ARRAY
80069: ST_TO_ADDR
// end ;
80070: LD_VAR 0 2
80074: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
80075: LD_INT 0
80077: PPUSH
80078: PPUSH
// if not mc_bases then
80079: LD_EXP 58
80083: NOT
80084: IFFALSE 80088
// exit ;
80086: GO 80153
// if mc_bases [ base ] then
80088: LD_EXP 58
80092: PUSH
80093: LD_VAR 0 1
80097: ARRAY
80098: IFFALSE 80153
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80100: LD_ADDR_VAR 0 3
80104: PUSH
80105: LD_EXP 58
80109: PUSH
80110: LD_VAR 0 1
80114: ARRAY
80115: PPUSH
80116: LD_INT 30
80118: PUSH
80119: LD_VAR 0 2
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: PPUSH
80128: CALL_OW 72
80132: ST_TO_ADDR
// if result then
80133: LD_VAR 0 3
80137: IFFALSE 80153
// result := result [ 1 ] ;
80139: LD_ADDR_VAR 0 3
80143: PUSH
80144: LD_VAR 0 3
80148: PUSH
80149: LD_INT 1
80151: ARRAY
80152: ST_TO_ADDR
// end ; end ;
80153: LD_VAR 0 3
80157: RET
// export function MC_SetTame ( base , area ) ; begin
80158: LD_INT 0
80160: PPUSH
// if not mc_bases or not base then
80161: LD_EXP 58
80165: NOT
80166: PUSH
80167: LD_VAR 0 1
80171: NOT
80172: OR
80173: IFFALSE 80177
// exit ;
80175: GO 80202
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
80177: LD_ADDR_EXP 86
80181: PUSH
80182: LD_EXP 86
80186: PPUSH
80187: LD_VAR 0 1
80191: PPUSH
80192: LD_VAR 0 2
80196: PPUSH
80197: CALL_OW 1
80201: ST_TO_ADDR
// end ;
80202: LD_VAR 0 3
80206: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
80207: LD_INT 0
80209: PPUSH
80210: PPUSH
// if not mc_bases or not base then
80211: LD_EXP 58
80215: NOT
80216: PUSH
80217: LD_VAR 0 1
80221: NOT
80222: OR
80223: IFFALSE 80227
// exit ;
80225: GO 80329
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80227: LD_ADDR_VAR 0 4
80231: PUSH
80232: LD_EXP 58
80236: PUSH
80237: LD_VAR 0 1
80241: ARRAY
80242: PPUSH
80243: LD_INT 30
80245: PUSH
80246: LD_VAR 0 2
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: PPUSH
80255: CALL_OW 72
80259: ST_TO_ADDR
// if not tmp then
80260: LD_VAR 0 4
80264: NOT
80265: IFFALSE 80269
// exit ;
80267: GO 80329
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
80269: LD_ADDR_EXP 90
80273: PUSH
80274: LD_EXP 90
80278: PPUSH
80279: LD_VAR 0 1
80283: PPUSH
80284: LD_EXP 90
80288: PUSH
80289: LD_VAR 0 1
80293: ARRAY
80294: PPUSH
80295: LD_EXP 90
80299: PUSH
80300: LD_VAR 0 1
80304: ARRAY
80305: PUSH
80306: LD_INT 1
80308: PLUS
80309: PPUSH
80310: LD_VAR 0 4
80314: PUSH
80315: LD_INT 1
80317: ARRAY
80318: PPUSH
80319: CALL_OW 2
80323: PPUSH
80324: CALL_OW 1
80328: ST_TO_ADDR
// end ;
80329: LD_VAR 0 3
80333: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
80334: LD_INT 0
80336: PPUSH
80337: PPUSH
// if not mc_bases or not base or not kinds then
80338: LD_EXP 58
80342: NOT
80343: PUSH
80344: LD_VAR 0 1
80348: NOT
80349: OR
80350: PUSH
80351: LD_VAR 0 2
80355: NOT
80356: OR
80357: IFFALSE 80361
// exit ;
80359: GO 80422
// for i in kinds do
80361: LD_ADDR_VAR 0 4
80365: PUSH
80366: LD_VAR 0 2
80370: PUSH
80371: FOR_IN
80372: IFFALSE 80420
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
80374: LD_ADDR_EXP 92
80378: PUSH
80379: LD_EXP 92
80383: PPUSH
80384: LD_VAR 0 1
80388: PUSH
80389: LD_EXP 92
80393: PUSH
80394: LD_VAR 0 1
80398: ARRAY
80399: PUSH
80400: LD_INT 1
80402: PLUS
80403: PUSH
80404: EMPTY
80405: LIST
80406: LIST
80407: PPUSH
80408: LD_VAR 0 4
80412: PPUSH
80413: CALL 20642 0 3
80417: ST_TO_ADDR
80418: GO 80371
80420: POP
80421: POP
// end ;
80422: LD_VAR 0 3
80426: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
80427: LD_INT 0
80429: PPUSH
// if not mc_bases or not base or not areas then
80430: LD_EXP 58
80434: NOT
80435: PUSH
80436: LD_VAR 0 1
80440: NOT
80441: OR
80442: PUSH
80443: LD_VAR 0 2
80447: NOT
80448: OR
80449: IFFALSE 80453
// exit ;
80451: GO 80478
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
80453: LD_ADDR_EXP 76
80457: PUSH
80458: LD_EXP 76
80462: PPUSH
80463: LD_VAR 0 1
80467: PPUSH
80468: LD_VAR 0 2
80472: PPUSH
80473: CALL_OW 1
80477: ST_TO_ADDR
// end ;
80478: LD_VAR 0 3
80482: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
80483: LD_INT 0
80485: PPUSH
// if not mc_bases or not base or not teleports_exit then
80486: LD_EXP 58
80490: NOT
80491: PUSH
80492: LD_VAR 0 1
80496: NOT
80497: OR
80498: PUSH
80499: LD_VAR 0 2
80503: NOT
80504: OR
80505: IFFALSE 80509
// exit ;
80507: GO 80534
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
80509: LD_ADDR_EXP 93
80513: PUSH
80514: LD_EXP 93
80518: PPUSH
80519: LD_VAR 0 1
80523: PPUSH
80524: LD_VAR 0 2
80528: PPUSH
80529: CALL_OW 1
80533: ST_TO_ADDR
// end ;
80534: LD_VAR 0 3
80538: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
80539: LD_INT 0
80541: PPUSH
80542: PPUSH
80543: PPUSH
// if not mc_bases or not base or not ext_list then
80544: LD_EXP 58
80548: NOT
80549: PUSH
80550: LD_VAR 0 1
80554: NOT
80555: OR
80556: PUSH
80557: LD_VAR 0 5
80561: NOT
80562: OR
80563: IFFALSE 80567
// exit ;
80565: GO 80740
// tmp := GetFacExtXYD ( x , y , d ) ;
80567: LD_ADDR_VAR 0 8
80571: PUSH
80572: LD_VAR 0 2
80576: PPUSH
80577: LD_VAR 0 3
80581: PPUSH
80582: LD_VAR 0 4
80586: PPUSH
80587: CALL 54020 0 3
80591: ST_TO_ADDR
// if not tmp then
80592: LD_VAR 0 8
80596: NOT
80597: IFFALSE 80601
// exit ;
80599: GO 80740
// for i in tmp do
80601: LD_ADDR_VAR 0 7
80605: PUSH
80606: LD_VAR 0 8
80610: PUSH
80611: FOR_IN
80612: IFFALSE 80738
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
80614: LD_ADDR_EXP 63
80618: PUSH
80619: LD_EXP 63
80623: PPUSH
80624: LD_VAR 0 1
80628: PPUSH
80629: LD_EXP 63
80633: PUSH
80634: LD_VAR 0 1
80638: ARRAY
80639: PPUSH
80640: LD_EXP 63
80644: PUSH
80645: LD_VAR 0 1
80649: ARRAY
80650: PUSH
80651: LD_INT 1
80653: PLUS
80654: PPUSH
80655: LD_VAR 0 5
80659: PUSH
80660: LD_INT 1
80662: ARRAY
80663: PUSH
80664: LD_VAR 0 7
80668: PUSH
80669: LD_INT 1
80671: ARRAY
80672: PUSH
80673: LD_VAR 0 7
80677: PUSH
80678: LD_INT 2
80680: ARRAY
80681: PUSH
80682: LD_VAR 0 7
80686: PUSH
80687: LD_INT 3
80689: ARRAY
80690: PUSH
80691: EMPTY
80692: LIST
80693: LIST
80694: LIST
80695: LIST
80696: PPUSH
80697: CALL_OW 2
80701: PPUSH
80702: CALL_OW 1
80706: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
80707: LD_ADDR_VAR 0 5
80711: PUSH
80712: LD_VAR 0 5
80716: PPUSH
80717: LD_INT 1
80719: PPUSH
80720: CALL_OW 3
80724: ST_TO_ADDR
// if not ext_list then
80725: LD_VAR 0 5
80729: NOT
80730: IFFALSE 80736
// exit ;
80732: POP
80733: POP
80734: GO 80740
// end ;
80736: GO 80611
80738: POP
80739: POP
// end ;
80740: LD_VAR 0 6
80744: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
80745: LD_INT 0
80747: PPUSH
// if not mc_bases or not base or not weapon_list then
80748: LD_EXP 58
80752: NOT
80753: PUSH
80754: LD_VAR 0 1
80758: NOT
80759: OR
80760: PUSH
80761: LD_VAR 0 2
80765: NOT
80766: OR
80767: IFFALSE 80771
// exit ;
80769: GO 80796
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
80771: LD_ADDR_EXP 97
80775: PUSH
80776: LD_EXP 97
80780: PPUSH
80781: LD_VAR 0 1
80785: PPUSH
80786: LD_VAR 0 2
80790: PPUSH
80791: CALL_OW 1
80795: ST_TO_ADDR
// end ;
80796: LD_VAR 0 3
80800: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
80801: LD_INT 0
80803: PPUSH
// if not mc_bases or not base or not tech_list then
80804: LD_EXP 58
80808: NOT
80809: PUSH
80810: LD_VAR 0 1
80814: NOT
80815: OR
80816: PUSH
80817: LD_VAR 0 2
80821: NOT
80822: OR
80823: IFFALSE 80827
// exit ;
80825: GO 80852
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
80827: LD_ADDR_EXP 85
80831: PUSH
80832: LD_EXP 85
80836: PPUSH
80837: LD_VAR 0 1
80841: PPUSH
80842: LD_VAR 0 2
80846: PPUSH
80847: CALL_OW 1
80851: ST_TO_ADDR
// end ;
80852: LD_VAR 0 3
80856: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
80857: LD_INT 0
80859: PPUSH
// if not mc_bases or not parking_area or not base then
80860: LD_EXP 58
80864: NOT
80865: PUSH
80866: LD_VAR 0 2
80870: NOT
80871: OR
80872: PUSH
80873: LD_VAR 0 1
80877: NOT
80878: OR
80879: IFFALSE 80883
// exit ;
80881: GO 80908
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
80883: LD_ADDR_EXP 82
80887: PUSH
80888: LD_EXP 82
80892: PPUSH
80893: LD_VAR 0 1
80897: PPUSH
80898: LD_VAR 0 2
80902: PPUSH
80903: CALL_OW 1
80907: ST_TO_ADDR
// end ;
80908: LD_VAR 0 3
80912: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
80913: LD_INT 0
80915: PPUSH
// if not mc_bases or not base or not scan_area then
80916: LD_EXP 58
80920: NOT
80921: PUSH
80922: LD_VAR 0 1
80926: NOT
80927: OR
80928: PUSH
80929: LD_VAR 0 2
80933: NOT
80934: OR
80935: IFFALSE 80939
// exit ;
80937: GO 80964
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
80939: LD_ADDR_EXP 83
80943: PUSH
80944: LD_EXP 83
80948: PPUSH
80949: LD_VAR 0 1
80953: PPUSH
80954: LD_VAR 0 2
80958: PPUSH
80959: CALL_OW 1
80963: ST_TO_ADDR
// end ;
80964: LD_VAR 0 3
80968: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
80969: LD_INT 0
80971: PPUSH
80972: PPUSH
// if not mc_bases or not base then
80973: LD_EXP 58
80977: NOT
80978: PUSH
80979: LD_VAR 0 1
80983: NOT
80984: OR
80985: IFFALSE 80989
// exit ;
80987: GO 81053
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
80989: LD_ADDR_VAR 0 3
80993: PUSH
80994: LD_INT 1
80996: PUSH
80997: LD_INT 2
80999: PUSH
81000: LD_INT 3
81002: PUSH
81003: LD_INT 4
81005: PUSH
81006: LD_INT 11
81008: PUSH
81009: EMPTY
81010: LIST
81011: LIST
81012: LIST
81013: LIST
81014: LIST
81015: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
81016: LD_ADDR_EXP 85
81020: PUSH
81021: LD_EXP 85
81025: PPUSH
81026: LD_VAR 0 1
81030: PPUSH
81031: LD_EXP 85
81035: PUSH
81036: LD_VAR 0 1
81040: ARRAY
81041: PUSH
81042: LD_VAR 0 3
81046: DIFF
81047: PPUSH
81048: CALL_OW 1
81052: ST_TO_ADDR
// end ;
81053: LD_VAR 0 2
81057: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
81058: LD_INT 0
81060: PPUSH
// result := mc_vehicles [ base ] ;
81061: LD_ADDR_VAR 0 3
81065: PUSH
81066: LD_EXP 77
81070: PUSH
81071: LD_VAR 0 1
81075: ARRAY
81076: ST_TO_ADDR
// if onlyCombat then
81077: LD_VAR 0 2
81081: IFFALSE 81246
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
81083: LD_ADDR_VAR 0 3
81087: PUSH
81088: LD_VAR 0 3
81092: PUSH
81093: LD_VAR 0 3
81097: PPUSH
81098: LD_INT 2
81100: PUSH
81101: LD_INT 34
81103: PUSH
81104: LD_INT 12
81106: PUSH
81107: EMPTY
81108: LIST
81109: LIST
81110: PUSH
81111: LD_INT 34
81113: PUSH
81114: LD_INT 51
81116: PUSH
81117: EMPTY
81118: LIST
81119: LIST
81120: PUSH
81121: LD_INT 34
81123: PUSH
81124: LD_EXP 102
81128: PUSH
81129: EMPTY
81130: LIST
81131: LIST
81132: PUSH
81133: LD_INT 34
81135: PUSH
81136: LD_INT 32
81138: PUSH
81139: EMPTY
81140: LIST
81141: LIST
81142: PUSH
81143: LD_INT 34
81145: PUSH
81146: LD_INT 13
81148: PUSH
81149: EMPTY
81150: LIST
81151: LIST
81152: PUSH
81153: LD_INT 34
81155: PUSH
81156: LD_INT 52
81158: PUSH
81159: EMPTY
81160: LIST
81161: LIST
81162: PUSH
81163: LD_INT 34
81165: PUSH
81166: LD_INT 14
81168: PUSH
81169: EMPTY
81170: LIST
81171: LIST
81172: PUSH
81173: LD_INT 34
81175: PUSH
81176: LD_INT 53
81178: PUSH
81179: EMPTY
81180: LIST
81181: LIST
81182: PUSH
81183: LD_INT 34
81185: PUSH
81186: LD_EXP 101
81190: PUSH
81191: EMPTY
81192: LIST
81193: LIST
81194: PUSH
81195: LD_INT 34
81197: PUSH
81198: LD_INT 31
81200: PUSH
81201: EMPTY
81202: LIST
81203: LIST
81204: PUSH
81205: LD_INT 34
81207: PUSH
81208: LD_INT 48
81210: PUSH
81211: EMPTY
81212: LIST
81213: LIST
81214: PUSH
81215: LD_INT 34
81217: PUSH
81218: LD_INT 8
81220: PUSH
81221: EMPTY
81222: LIST
81223: LIST
81224: PUSH
81225: EMPTY
81226: LIST
81227: LIST
81228: LIST
81229: LIST
81230: LIST
81231: LIST
81232: LIST
81233: LIST
81234: LIST
81235: LIST
81236: LIST
81237: LIST
81238: LIST
81239: PPUSH
81240: CALL_OW 72
81244: DIFF
81245: ST_TO_ADDR
// end ; end_of_file
81246: LD_VAR 0 3
81250: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
81251: LD_INT 0
81253: PPUSH
81254: PPUSH
81255: PPUSH
// if not mc_bases or not skirmish then
81256: LD_EXP 58
81260: NOT
81261: PUSH
81262: LD_EXP 56
81266: NOT
81267: OR
81268: IFFALSE 81272
// exit ;
81270: GO 81437
// for i = 1 to mc_bases do
81272: LD_ADDR_VAR 0 4
81276: PUSH
81277: DOUBLE
81278: LD_INT 1
81280: DEC
81281: ST_TO_ADDR
81282: LD_EXP 58
81286: PUSH
81287: FOR_TO
81288: IFFALSE 81435
// begin if sci in mc_bases [ i ] then
81290: LD_VAR 0 2
81294: PUSH
81295: LD_EXP 58
81299: PUSH
81300: LD_VAR 0 4
81304: ARRAY
81305: IN
81306: IFFALSE 81433
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
81308: LD_ADDR_EXP 87
81312: PUSH
81313: LD_EXP 87
81317: PPUSH
81318: LD_VAR 0 4
81322: PUSH
81323: LD_EXP 87
81327: PUSH
81328: LD_VAR 0 4
81332: ARRAY
81333: PUSH
81334: LD_INT 1
81336: PLUS
81337: PUSH
81338: EMPTY
81339: LIST
81340: LIST
81341: PPUSH
81342: LD_VAR 0 1
81346: PPUSH
81347: CALL 20642 0 3
81351: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
81352: LD_ADDR_VAR 0 5
81356: PUSH
81357: LD_EXP 58
81361: PUSH
81362: LD_VAR 0 4
81366: ARRAY
81367: PPUSH
81368: LD_INT 2
81370: PUSH
81371: LD_INT 30
81373: PUSH
81374: LD_INT 0
81376: PUSH
81377: EMPTY
81378: LIST
81379: LIST
81380: PUSH
81381: LD_INT 30
81383: PUSH
81384: LD_INT 1
81386: PUSH
81387: EMPTY
81388: LIST
81389: LIST
81390: PUSH
81391: EMPTY
81392: LIST
81393: LIST
81394: LIST
81395: PPUSH
81396: CALL_OW 72
81400: PPUSH
81401: LD_VAR 0 1
81405: PPUSH
81406: CALL_OW 74
81410: ST_TO_ADDR
// if tmp then
81411: LD_VAR 0 5
81415: IFFALSE 81431
// ComStandNearbyBuilding ( ape , tmp ) ;
81417: LD_VAR 0 1
81421: PPUSH
81422: LD_VAR 0 5
81426: PPUSH
81427: CALL 15349 0 2
// break ;
81431: GO 81435
// end ; end ;
81433: GO 81287
81435: POP
81436: POP
// end ;
81437: LD_VAR 0 3
81441: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
81442: LD_INT 0
81444: PPUSH
81445: PPUSH
81446: PPUSH
// if not mc_bases or not skirmish then
81447: LD_EXP 58
81451: NOT
81452: PUSH
81453: LD_EXP 56
81457: NOT
81458: OR
81459: IFFALSE 81463
// exit ;
81461: GO 81552
// for i = 1 to mc_bases do
81463: LD_ADDR_VAR 0 4
81467: PUSH
81468: DOUBLE
81469: LD_INT 1
81471: DEC
81472: ST_TO_ADDR
81473: LD_EXP 58
81477: PUSH
81478: FOR_TO
81479: IFFALSE 81550
// begin if building in mc_busy_turret_list [ i ] then
81481: LD_VAR 0 1
81485: PUSH
81486: LD_EXP 68
81490: PUSH
81491: LD_VAR 0 4
81495: ARRAY
81496: IN
81497: IFFALSE 81548
// begin tmp := mc_busy_turret_list [ i ] diff building ;
81499: LD_ADDR_VAR 0 5
81503: PUSH
81504: LD_EXP 68
81508: PUSH
81509: LD_VAR 0 4
81513: ARRAY
81514: PUSH
81515: LD_VAR 0 1
81519: DIFF
81520: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
81521: LD_ADDR_EXP 68
81525: PUSH
81526: LD_EXP 68
81530: PPUSH
81531: LD_VAR 0 4
81535: PPUSH
81536: LD_VAR 0 5
81540: PPUSH
81541: CALL_OW 1
81545: ST_TO_ADDR
// break ;
81546: GO 81550
// end ; end ;
81548: GO 81478
81550: POP
81551: POP
// end ;
81552: LD_VAR 0 3
81556: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
81557: LD_INT 0
81559: PPUSH
81560: PPUSH
81561: PPUSH
// if not mc_bases or not skirmish then
81562: LD_EXP 58
81566: NOT
81567: PUSH
81568: LD_EXP 56
81572: NOT
81573: OR
81574: IFFALSE 81578
// exit ;
81576: GO 81777
// for i = 1 to mc_bases do
81578: LD_ADDR_VAR 0 5
81582: PUSH
81583: DOUBLE
81584: LD_INT 1
81586: DEC
81587: ST_TO_ADDR
81588: LD_EXP 58
81592: PUSH
81593: FOR_TO
81594: IFFALSE 81775
// if building in mc_bases [ i ] then
81596: LD_VAR 0 1
81600: PUSH
81601: LD_EXP 58
81605: PUSH
81606: LD_VAR 0 5
81610: ARRAY
81611: IN
81612: IFFALSE 81773
// begin tmp := mc_bases [ i ] diff building ;
81614: LD_ADDR_VAR 0 6
81618: PUSH
81619: LD_EXP 58
81623: PUSH
81624: LD_VAR 0 5
81628: ARRAY
81629: PUSH
81630: LD_VAR 0 1
81634: DIFF
81635: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
81636: LD_ADDR_EXP 58
81640: PUSH
81641: LD_EXP 58
81645: PPUSH
81646: LD_VAR 0 5
81650: PPUSH
81651: LD_VAR 0 6
81655: PPUSH
81656: CALL_OW 1
81660: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
81661: LD_VAR 0 1
81665: PUSH
81666: LD_EXP 66
81670: PUSH
81671: LD_VAR 0 5
81675: ARRAY
81676: IN
81677: IFFALSE 81716
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
81679: LD_ADDR_EXP 66
81683: PUSH
81684: LD_EXP 66
81688: PPUSH
81689: LD_VAR 0 5
81693: PPUSH
81694: LD_EXP 66
81698: PUSH
81699: LD_VAR 0 5
81703: ARRAY
81704: PUSH
81705: LD_VAR 0 1
81709: DIFF
81710: PPUSH
81711: CALL_OW 1
81715: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
81716: LD_VAR 0 1
81720: PUSH
81721: LD_EXP 67
81725: PUSH
81726: LD_VAR 0 5
81730: ARRAY
81731: IN
81732: IFFALSE 81771
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
81734: LD_ADDR_EXP 67
81738: PUSH
81739: LD_EXP 67
81743: PPUSH
81744: LD_VAR 0 5
81748: PPUSH
81749: LD_EXP 67
81753: PUSH
81754: LD_VAR 0 5
81758: ARRAY
81759: PUSH
81760: LD_VAR 0 1
81764: DIFF
81765: PPUSH
81766: CALL_OW 1
81770: ST_TO_ADDR
// break ;
81771: GO 81775
// end ;
81773: GO 81593
81775: POP
81776: POP
// end ;
81777: LD_VAR 0 4
81781: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
81782: LD_INT 0
81784: PPUSH
81785: PPUSH
81786: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
81787: LD_EXP 58
81791: NOT
81792: PUSH
81793: LD_EXP 56
81797: NOT
81798: OR
81799: PUSH
81800: LD_VAR 0 3
81804: PUSH
81805: LD_EXP 84
81809: IN
81810: NOT
81811: OR
81812: IFFALSE 81816
// exit ;
81814: GO 81939
// for i = 1 to mc_vehicles do
81816: LD_ADDR_VAR 0 6
81820: PUSH
81821: DOUBLE
81822: LD_INT 1
81824: DEC
81825: ST_TO_ADDR
81826: LD_EXP 77
81830: PUSH
81831: FOR_TO
81832: IFFALSE 81937
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
81834: LD_VAR 0 2
81838: PUSH
81839: LD_EXP 77
81843: PUSH
81844: LD_VAR 0 6
81848: ARRAY
81849: IN
81850: PUSH
81851: LD_VAR 0 1
81855: PUSH
81856: LD_EXP 77
81860: PUSH
81861: LD_VAR 0 6
81865: ARRAY
81866: IN
81867: OR
81868: IFFALSE 81935
// begin tmp := mc_vehicles [ i ] diff old ;
81870: LD_ADDR_VAR 0 7
81874: PUSH
81875: LD_EXP 77
81879: PUSH
81880: LD_VAR 0 6
81884: ARRAY
81885: PUSH
81886: LD_VAR 0 2
81890: DIFF
81891: ST_TO_ADDR
// tmp := tmp diff new ;
81892: LD_ADDR_VAR 0 7
81896: PUSH
81897: LD_VAR 0 7
81901: PUSH
81902: LD_VAR 0 1
81906: DIFF
81907: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
81908: LD_ADDR_EXP 77
81912: PUSH
81913: LD_EXP 77
81917: PPUSH
81918: LD_VAR 0 6
81922: PPUSH
81923: LD_VAR 0 7
81927: PPUSH
81928: CALL_OW 1
81932: ST_TO_ADDR
// break ;
81933: GO 81937
// end ;
81935: GO 81831
81937: POP
81938: POP
// end ;
81939: LD_VAR 0 5
81943: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
81944: LD_INT 0
81946: PPUSH
81947: PPUSH
81948: PPUSH
81949: PPUSH
// if not mc_bases or not skirmish then
81950: LD_EXP 58
81954: NOT
81955: PUSH
81956: LD_EXP 56
81960: NOT
81961: OR
81962: IFFALSE 81966
// exit ;
81964: GO 82343
// side := GetSide ( vehicle ) ;
81966: LD_ADDR_VAR 0 5
81970: PUSH
81971: LD_VAR 0 1
81975: PPUSH
81976: CALL_OW 255
81980: ST_TO_ADDR
// for i = 1 to mc_bases do
81981: LD_ADDR_VAR 0 4
81985: PUSH
81986: DOUBLE
81987: LD_INT 1
81989: DEC
81990: ST_TO_ADDR
81991: LD_EXP 58
81995: PUSH
81996: FOR_TO
81997: IFFALSE 82341
// begin if factory in mc_bases [ i ] then
81999: LD_VAR 0 2
82003: PUSH
82004: LD_EXP 58
82008: PUSH
82009: LD_VAR 0 4
82013: ARRAY
82014: IN
82015: IFFALSE 82339
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
82017: LD_EXP 80
82021: PUSH
82022: LD_VAR 0 4
82026: ARRAY
82027: PUSH
82028: LD_EXP 69
82032: PUSH
82033: LD_VAR 0 4
82037: ARRAY
82038: LESS
82039: PUSH
82040: LD_VAR 0 1
82044: PPUSH
82045: CALL_OW 264
82049: PUSH
82050: LD_INT 31
82052: PUSH
82053: LD_INT 32
82055: PUSH
82056: LD_INT 51
82058: PUSH
82059: LD_EXP 102
82063: PUSH
82064: LD_INT 12
82066: PUSH
82067: LD_INT 30
82069: PUSH
82070: LD_EXP 101
82074: PUSH
82075: LD_INT 11
82077: PUSH
82078: LD_INT 53
82080: PUSH
82081: LD_INT 14
82083: PUSH
82084: LD_EXP 105
82088: PUSH
82089: LD_INT 29
82091: PUSH
82092: LD_EXP 103
82096: PUSH
82097: LD_INT 13
82099: PUSH
82100: LD_INT 52
82102: PUSH
82103: LD_INT 48
82105: PUSH
82106: LD_INT 8
82108: PUSH
82109: EMPTY
82110: LIST
82111: LIST
82112: LIST
82113: LIST
82114: LIST
82115: LIST
82116: LIST
82117: LIST
82118: LIST
82119: LIST
82120: LIST
82121: LIST
82122: LIST
82123: LIST
82124: LIST
82125: LIST
82126: LIST
82127: IN
82128: NOT
82129: AND
82130: IFFALSE 82178
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
82132: LD_ADDR_EXP 80
82136: PUSH
82137: LD_EXP 80
82141: PPUSH
82142: LD_VAR 0 4
82146: PUSH
82147: LD_EXP 80
82151: PUSH
82152: LD_VAR 0 4
82156: ARRAY
82157: PUSH
82158: LD_INT 1
82160: PLUS
82161: PUSH
82162: EMPTY
82163: LIST
82164: LIST
82165: PPUSH
82166: LD_VAR 0 1
82170: PPUSH
82171: CALL 20642 0 3
82175: ST_TO_ADDR
82176: GO 82222
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
82178: LD_ADDR_EXP 77
82182: PUSH
82183: LD_EXP 77
82187: PPUSH
82188: LD_VAR 0 4
82192: PUSH
82193: LD_EXP 77
82197: PUSH
82198: LD_VAR 0 4
82202: ARRAY
82203: PUSH
82204: LD_INT 1
82206: PLUS
82207: PUSH
82208: EMPTY
82209: LIST
82210: LIST
82211: PPUSH
82212: LD_VAR 0 1
82216: PPUSH
82217: CALL 20642 0 3
82221: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
82222: LD_VAR 0 1
82226: PPUSH
82227: CALL_OW 263
82231: PUSH
82232: LD_INT 2
82234: EQUAL
82235: IFFALSE 82255
// begin repeat wait ( 0 0$1 ) ;
82237: LD_INT 35
82239: PPUSH
82240: CALL_OW 67
// until IsControledBy ( vehicle ) ;
82244: LD_VAR 0 1
82248: PPUSH
82249: CALL_OW 312
82253: IFFALSE 82237
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
82255: LD_VAR 0 1
82259: PPUSH
82260: LD_EXP 82
82264: PUSH
82265: LD_VAR 0 4
82269: ARRAY
82270: PPUSH
82271: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
82275: LD_VAR 0 1
82279: PPUSH
82280: CALL_OW 263
82284: PUSH
82285: LD_INT 1
82287: NONEQUAL
82288: IFFALSE 82292
// break ;
82290: GO 82341
// repeat wait ( 0 0$1 ) ;
82292: LD_INT 35
82294: PPUSH
82295: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
82299: LD_VAR 0 1
82303: PPUSH
82304: LD_EXP 82
82308: PUSH
82309: LD_VAR 0 4
82313: ARRAY
82314: PPUSH
82315: CALL_OW 308
82319: IFFALSE 82292
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
82321: LD_VAR 0 1
82325: PPUSH
82326: CALL_OW 311
82330: PPUSH
82331: CALL_OW 121
// exit ;
82335: POP
82336: POP
82337: GO 82343
// end ; end ;
82339: GO 81996
82341: POP
82342: POP
// end ;
82343: LD_VAR 0 3
82347: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
82348: LD_INT 0
82350: PPUSH
82351: PPUSH
82352: PPUSH
82353: PPUSH
// if not mc_bases or not skirmish then
82354: LD_EXP 58
82358: NOT
82359: PUSH
82360: LD_EXP 56
82364: NOT
82365: OR
82366: IFFALSE 82370
// exit ;
82368: GO 82723
// repeat wait ( 0 0$1 ) ;
82370: LD_INT 35
82372: PPUSH
82373: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
82377: LD_VAR 0 2
82381: PPUSH
82382: LD_VAR 0 3
82386: PPUSH
82387: CALL_OW 284
82391: IFFALSE 82370
// if GetResourceTypeXY ( x , y ) = mat_artefact then
82393: LD_VAR 0 2
82397: PPUSH
82398: LD_VAR 0 3
82402: PPUSH
82403: CALL_OW 283
82407: PUSH
82408: LD_INT 4
82410: EQUAL
82411: IFFALSE 82415
// exit ;
82413: GO 82723
// for i = 1 to mc_bases do
82415: LD_ADDR_VAR 0 7
82419: PUSH
82420: DOUBLE
82421: LD_INT 1
82423: DEC
82424: ST_TO_ADDR
82425: LD_EXP 58
82429: PUSH
82430: FOR_TO
82431: IFFALSE 82721
// begin if mc_crates_area [ i ] then
82433: LD_EXP 76
82437: PUSH
82438: LD_VAR 0 7
82442: ARRAY
82443: IFFALSE 82554
// for j in mc_crates_area [ i ] do
82445: LD_ADDR_VAR 0 8
82449: PUSH
82450: LD_EXP 76
82454: PUSH
82455: LD_VAR 0 7
82459: ARRAY
82460: PUSH
82461: FOR_IN
82462: IFFALSE 82552
// if InArea ( x , y , j ) then
82464: LD_VAR 0 2
82468: PPUSH
82469: LD_VAR 0 3
82473: PPUSH
82474: LD_VAR 0 8
82478: PPUSH
82479: CALL_OW 309
82483: IFFALSE 82550
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82485: LD_ADDR_EXP 74
82489: PUSH
82490: LD_EXP 74
82494: PPUSH
82495: LD_VAR 0 7
82499: PUSH
82500: LD_EXP 74
82504: PUSH
82505: LD_VAR 0 7
82509: ARRAY
82510: PUSH
82511: LD_INT 1
82513: PLUS
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PPUSH
82519: LD_VAR 0 4
82523: PUSH
82524: LD_VAR 0 2
82528: PUSH
82529: LD_VAR 0 3
82533: PUSH
82534: EMPTY
82535: LIST
82536: LIST
82537: LIST
82538: PPUSH
82539: CALL 20642 0 3
82543: ST_TO_ADDR
// exit ;
82544: POP
82545: POP
82546: POP
82547: POP
82548: GO 82723
// end ;
82550: GO 82461
82552: POP
82553: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82554: LD_ADDR_VAR 0 9
82558: PUSH
82559: LD_EXP 58
82563: PUSH
82564: LD_VAR 0 7
82568: ARRAY
82569: PPUSH
82570: LD_INT 2
82572: PUSH
82573: LD_INT 30
82575: PUSH
82576: LD_INT 0
82578: PUSH
82579: EMPTY
82580: LIST
82581: LIST
82582: PUSH
82583: LD_INT 30
82585: PUSH
82586: LD_INT 1
82588: PUSH
82589: EMPTY
82590: LIST
82591: LIST
82592: PUSH
82593: EMPTY
82594: LIST
82595: LIST
82596: LIST
82597: PPUSH
82598: CALL_OW 72
82602: ST_TO_ADDR
// if not depot then
82603: LD_VAR 0 9
82607: NOT
82608: IFFALSE 82612
// continue ;
82610: GO 82430
// for j in depot do
82612: LD_ADDR_VAR 0 8
82616: PUSH
82617: LD_VAR 0 9
82621: PUSH
82622: FOR_IN
82623: IFFALSE 82717
// if GetDistUnitXY ( j , x , y ) < 30 then
82625: LD_VAR 0 8
82629: PPUSH
82630: LD_VAR 0 2
82634: PPUSH
82635: LD_VAR 0 3
82639: PPUSH
82640: CALL_OW 297
82644: PUSH
82645: LD_INT 30
82647: LESS
82648: IFFALSE 82715
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82650: LD_ADDR_EXP 74
82654: PUSH
82655: LD_EXP 74
82659: PPUSH
82660: LD_VAR 0 7
82664: PUSH
82665: LD_EXP 74
82669: PUSH
82670: LD_VAR 0 7
82674: ARRAY
82675: PUSH
82676: LD_INT 1
82678: PLUS
82679: PUSH
82680: EMPTY
82681: LIST
82682: LIST
82683: PPUSH
82684: LD_VAR 0 4
82688: PUSH
82689: LD_VAR 0 2
82693: PUSH
82694: LD_VAR 0 3
82698: PUSH
82699: EMPTY
82700: LIST
82701: LIST
82702: LIST
82703: PPUSH
82704: CALL 20642 0 3
82708: ST_TO_ADDR
// exit ;
82709: POP
82710: POP
82711: POP
82712: POP
82713: GO 82723
// end ;
82715: GO 82622
82717: POP
82718: POP
// end ;
82719: GO 82430
82721: POP
82722: POP
// end ;
82723: LD_VAR 0 6
82727: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
82728: LD_INT 0
82730: PPUSH
82731: PPUSH
82732: PPUSH
82733: PPUSH
// if not mc_bases or not skirmish then
82734: LD_EXP 58
82738: NOT
82739: PUSH
82740: LD_EXP 56
82744: NOT
82745: OR
82746: IFFALSE 82750
// exit ;
82748: GO 83027
// side := GetSide ( lab ) ;
82750: LD_ADDR_VAR 0 4
82754: PUSH
82755: LD_VAR 0 2
82759: PPUSH
82760: CALL_OW 255
82764: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
82765: LD_VAR 0 4
82769: PUSH
82770: LD_EXP 84
82774: IN
82775: NOT
82776: PUSH
82777: LD_EXP 85
82781: NOT
82782: OR
82783: PUSH
82784: LD_EXP 58
82788: NOT
82789: OR
82790: IFFALSE 82794
// exit ;
82792: GO 83027
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
82794: LD_ADDR_EXP 85
82798: PUSH
82799: LD_EXP 85
82803: PPUSH
82804: LD_VAR 0 4
82808: PPUSH
82809: LD_EXP 85
82813: PUSH
82814: LD_VAR 0 4
82818: ARRAY
82819: PUSH
82820: LD_VAR 0 1
82824: DIFF
82825: PPUSH
82826: CALL_OW 1
82830: ST_TO_ADDR
// for i = 1 to mc_bases do
82831: LD_ADDR_VAR 0 5
82835: PUSH
82836: DOUBLE
82837: LD_INT 1
82839: DEC
82840: ST_TO_ADDR
82841: LD_EXP 58
82845: PUSH
82846: FOR_TO
82847: IFFALSE 83025
// begin if lab in mc_bases [ i ] then
82849: LD_VAR 0 2
82853: PUSH
82854: LD_EXP 58
82858: PUSH
82859: LD_VAR 0 5
82863: ARRAY
82864: IN
82865: IFFALSE 83023
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
82867: LD_VAR 0 1
82871: PUSH
82872: LD_INT 11
82874: PUSH
82875: LD_INT 4
82877: PUSH
82878: LD_INT 3
82880: PUSH
82881: LD_INT 2
82883: PUSH
82884: EMPTY
82885: LIST
82886: LIST
82887: LIST
82888: LIST
82889: IN
82890: PUSH
82891: LD_EXP 88
82895: PUSH
82896: LD_VAR 0 5
82900: ARRAY
82901: AND
82902: IFFALSE 83023
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
82904: LD_ADDR_VAR 0 6
82908: PUSH
82909: LD_EXP 88
82913: PUSH
82914: LD_VAR 0 5
82918: ARRAY
82919: PUSH
82920: LD_INT 1
82922: ARRAY
82923: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82924: LD_ADDR_EXP 88
82928: PUSH
82929: LD_EXP 88
82933: PPUSH
82934: LD_VAR 0 5
82938: PPUSH
82939: EMPTY
82940: PPUSH
82941: CALL_OW 1
82945: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
82946: LD_VAR 0 6
82950: PPUSH
82951: LD_INT 0
82953: PPUSH
82954: CALL_OW 109
// ComExitBuilding ( tmp ) ;
82958: LD_VAR 0 6
82962: PPUSH
82963: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
82967: LD_ADDR_EXP 87
82971: PUSH
82972: LD_EXP 87
82976: PPUSH
82977: LD_VAR 0 5
82981: PPUSH
82982: LD_EXP 87
82986: PUSH
82987: LD_VAR 0 5
82991: ARRAY
82992: PPUSH
82993: LD_INT 1
82995: PPUSH
82996: LD_VAR 0 6
83000: PPUSH
83001: CALL_OW 2
83005: PPUSH
83006: CALL_OW 1
83010: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
83011: LD_VAR 0 5
83015: PPUSH
83016: LD_INT 112
83018: PPUSH
83019: CALL 60560 0 2
// end ; end ; end ;
83023: GO 82846
83025: POP
83026: POP
// end ;
83027: LD_VAR 0 3
83031: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
83032: LD_INT 0
83034: PPUSH
83035: PPUSH
83036: PPUSH
83037: PPUSH
83038: PPUSH
83039: PPUSH
83040: PPUSH
83041: PPUSH
// if not mc_bases or not skirmish then
83042: LD_EXP 58
83046: NOT
83047: PUSH
83048: LD_EXP 56
83052: NOT
83053: OR
83054: IFFALSE 83058
// exit ;
83056: GO 84150
// for i = 1 to mc_bases do
83058: LD_ADDR_VAR 0 3
83062: PUSH
83063: DOUBLE
83064: LD_INT 1
83066: DEC
83067: ST_TO_ADDR
83068: LD_EXP 58
83072: PUSH
83073: FOR_TO
83074: IFFALSE 84148
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
83076: LD_VAR 0 1
83080: PUSH
83081: LD_EXP 58
83085: PUSH
83086: LD_VAR 0 3
83090: ARRAY
83091: IN
83092: PUSH
83093: LD_VAR 0 1
83097: PUSH
83098: LD_EXP 65
83102: PUSH
83103: LD_VAR 0 3
83107: ARRAY
83108: IN
83109: OR
83110: PUSH
83111: LD_VAR 0 1
83115: PUSH
83116: LD_EXP 80
83120: PUSH
83121: LD_VAR 0 3
83125: ARRAY
83126: IN
83127: OR
83128: PUSH
83129: LD_VAR 0 1
83133: PUSH
83134: LD_EXP 77
83138: PUSH
83139: LD_VAR 0 3
83143: ARRAY
83144: IN
83145: OR
83146: PUSH
83147: LD_VAR 0 1
83151: PUSH
83152: LD_EXP 87
83156: PUSH
83157: LD_VAR 0 3
83161: ARRAY
83162: IN
83163: OR
83164: PUSH
83165: LD_VAR 0 1
83169: PUSH
83170: LD_EXP 88
83174: PUSH
83175: LD_VAR 0 3
83179: ARRAY
83180: IN
83181: OR
83182: IFFALSE 84146
// begin if un in mc_ape [ i ] then
83184: LD_VAR 0 1
83188: PUSH
83189: LD_EXP 87
83193: PUSH
83194: LD_VAR 0 3
83198: ARRAY
83199: IN
83200: IFFALSE 83239
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
83202: LD_ADDR_EXP 87
83206: PUSH
83207: LD_EXP 87
83211: PPUSH
83212: LD_VAR 0 3
83216: PPUSH
83217: LD_EXP 87
83221: PUSH
83222: LD_VAR 0 3
83226: ARRAY
83227: PUSH
83228: LD_VAR 0 1
83232: DIFF
83233: PPUSH
83234: CALL_OW 1
83238: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
83239: LD_VAR 0 1
83243: PUSH
83244: LD_EXP 88
83248: PUSH
83249: LD_VAR 0 3
83253: ARRAY
83254: IN
83255: IFFALSE 83279
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83257: LD_ADDR_EXP 88
83261: PUSH
83262: LD_EXP 88
83266: PPUSH
83267: LD_VAR 0 3
83271: PPUSH
83272: EMPTY
83273: PPUSH
83274: CALL_OW 1
83278: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] ) then
83279: LD_VAR 0 1
83283: PPUSH
83284: CALL_OW 247
83288: PUSH
83289: LD_INT 2
83291: EQUAL
83292: PUSH
83293: LD_VAR 0 1
83297: PPUSH
83298: CALL_OW 110
83302: PUSH
83303: LD_INT 20
83305: EQUAL
83306: PUSH
83307: LD_VAR 0 1
83311: PUSH
83312: LD_EXP 80
83316: PUSH
83317: LD_VAR 0 3
83321: ARRAY
83322: IN
83323: OR
83324: AND
83325: IFFALSE 83486
// begin if un in mc_defender [ i ] then
83327: LD_VAR 0 1
83331: PUSH
83332: LD_EXP 80
83336: PUSH
83337: LD_VAR 0 3
83341: ARRAY
83342: IN
83343: IFFALSE 83382
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
83345: LD_ADDR_EXP 80
83349: PUSH
83350: LD_EXP 80
83354: PPUSH
83355: LD_VAR 0 3
83359: PPUSH
83360: LD_EXP 80
83364: PUSH
83365: LD_VAR 0 3
83369: ARRAY
83370: PUSH
83371: LD_VAR 0 1
83375: DIFF
83376: PPUSH
83377: CALL_OW 1
83381: ST_TO_ADDR
// fac := MC_GetBuilding ( i , b_factory ) ;
83382: LD_ADDR_VAR 0 8
83386: PUSH
83387: LD_VAR 0 3
83391: PPUSH
83392: LD_INT 3
83394: PPUSH
83395: CALL 80075 0 2
83399: ST_TO_ADDR
// if fac then
83400: LD_VAR 0 8
83404: IFFALSE 83486
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
83406: LD_ADDR_VAR 0 9
83410: PUSH
83411: LD_VAR 0 8
83415: PPUSH
83416: LD_VAR 0 1
83420: PPUSH
83421: CALL_OW 265
83425: PPUSH
83426: LD_VAR 0 1
83430: PPUSH
83431: CALL_OW 262
83435: PPUSH
83436: LD_VAR 0 1
83440: PPUSH
83441: CALL_OW 263
83445: PPUSH
83446: LD_VAR 0 1
83450: PPUSH
83451: CALL_OW 264
83455: PPUSH
83456: CALL 18235 0 5
83460: ST_TO_ADDR
// if components then
83461: LD_VAR 0 9
83465: IFFALSE 83484
// MC_InsertProduceList ( i , [ components ] ) ;
83467: LD_VAR 0 3
83471: PPUSH
83472: LD_VAR 0 9
83476: PUSH
83477: EMPTY
83478: LIST
83479: PPUSH
83480: CALL 79703 0 2
// break ;
83484: GO 84148
// end ; end ; if GetType ( un ) = unit_building then
83486: LD_VAR 0 1
83490: PPUSH
83491: CALL_OW 247
83495: PUSH
83496: LD_INT 3
83498: EQUAL
83499: IFFALSE 83814
// begin btype := GetBType ( un ) ;
83501: LD_ADDR_VAR 0 5
83505: PUSH
83506: LD_VAR 0 1
83510: PPUSH
83511: CALL_OW 266
83515: ST_TO_ADDR
// if btype = b_warehouse then
83516: LD_VAR 0 5
83520: PUSH
83521: LD_INT 1
83523: EQUAL
83524: IFFALSE 83542
// begin btype := b_depot ;
83526: LD_ADDR_VAR 0 5
83530: PUSH
83531: LD_INT 0
83533: ST_TO_ADDR
// pos := 1 ;
83534: LD_ADDR_VAR 0 6
83538: PUSH
83539: LD_INT 1
83541: ST_TO_ADDR
// end ; if btype = b_factory then
83542: LD_VAR 0 5
83546: PUSH
83547: LD_INT 3
83549: EQUAL
83550: IFFALSE 83568
// begin btype := b_workshop ;
83552: LD_ADDR_VAR 0 5
83556: PUSH
83557: LD_INT 2
83559: ST_TO_ADDR
// pos := 1 ;
83560: LD_ADDR_VAR 0 6
83564: PUSH
83565: LD_INT 1
83567: ST_TO_ADDR
// end ; if btype = b_barracks then
83568: LD_VAR 0 5
83572: PUSH
83573: LD_INT 5
83575: EQUAL
83576: IFFALSE 83586
// btype := b_armoury ;
83578: LD_ADDR_VAR 0 5
83582: PUSH
83583: LD_INT 4
83585: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
83586: LD_VAR 0 5
83590: PUSH
83591: LD_INT 7
83593: PUSH
83594: LD_INT 8
83596: PUSH
83597: EMPTY
83598: LIST
83599: LIST
83600: IN
83601: IFFALSE 83611
// btype := b_lab ;
83603: LD_ADDR_VAR 0 5
83607: PUSH
83608: LD_INT 6
83610: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
83611: LD_ADDR_EXP 63
83615: PUSH
83616: LD_EXP 63
83620: PPUSH
83621: LD_VAR 0 3
83625: PUSH
83626: LD_EXP 63
83630: PUSH
83631: LD_VAR 0 3
83635: ARRAY
83636: PUSH
83637: LD_INT 1
83639: PLUS
83640: PUSH
83641: EMPTY
83642: LIST
83643: LIST
83644: PPUSH
83645: LD_VAR 0 5
83649: PUSH
83650: LD_VAR 0 1
83654: PPUSH
83655: CALL_OW 250
83659: PUSH
83660: LD_VAR 0 1
83664: PPUSH
83665: CALL_OW 251
83669: PUSH
83670: LD_VAR 0 1
83674: PPUSH
83675: CALL_OW 254
83679: PUSH
83680: EMPTY
83681: LIST
83682: LIST
83683: LIST
83684: LIST
83685: PPUSH
83686: CALL 20642 0 3
83690: ST_TO_ADDR
// if pos = 1 then
83691: LD_VAR 0 6
83695: PUSH
83696: LD_INT 1
83698: EQUAL
83699: IFFALSE 83814
// begin tmp := mc_build_list [ i ] ;
83701: LD_ADDR_VAR 0 7
83705: PUSH
83706: LD_EXP 63
83710: PUSH
83711: LD_VAR 0 3
83715: ARRAY
83716: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
83717: LD_VAR 0 7
83721: PPUSH
83722: LD_INT 2
83724: PUSH
83725: LD_INT 30
83727: PUSH
83728: LD_INT 0
83730: PUSH
83731: EMPTY
83732: LIST
83733: LIST
83734: PUSH
83735: LD_INT 30
83737: PUSH
83738: LD_INT 1
83740: PUSH
83741: EMPTY
83742: LIST
83743: LIST
83744: PUSH
83745: EMPTY
83746: LIST
83747: LIST
83748: LIST
83749: PPUSH
83750: CALL_OW 72
83754: IFFALSE 83764
// pos := 2 ;
83756: LD_ADDR_VAR 0 6
83760: PUSH
83761: LD_INT 2
83763: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
83764: LD_ADDR_VAR 0 7
83768: PUSH
83769: LD_VAR 0 7
83773: PPUSH
83774: LD_VAR 0 6
83778: PPUSH
83779: LD_VAR 0 7
83783: PPUSH
83784: CALL 20968 0 3
83788: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
83789: LD_ADDR_EXP 63
83793: PUSH
83794: LD_EXP 63
83798: PPUSH
83799: LD_VAR 0 3
83803: PPUSH
83804: LD_VAR 0 7
83808: PPUSH
83809: CALL_OW 1
83813: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
83814: LD_VAR 0 1
83818: PUSH
83819: LD_EXP 58
83823: PUSH
83824: LD_VAR 0 3
83828: ARRAY
83829: IN
83830: IFFALSE 83869
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
83832: LD_ADDR_EXP 58
83836: PUSH
83837: LD_EXP 58
83841: PPUSH
83842: LD_VAR 0 3
83846: PPUSH
83847: LD_EXP 58
83851: PUSH
83852: LD_VAR 0 3
83856: ARRAY
83857: PUSH
83858: LD_VAR 0 1
83862: DIFF
83863: PPUSH
83864: CALL_OW 1
83868: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
83869: LD_VAR 0 1
83873: PUSH
83874: LD_EXP 65
83878: PUSH
83879: LD_VAR 0 3
83883: ARRAY
83884: IN
83885: IFFALSE 83924
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
83887: LD_ADDR_EXP 65
83891: PUSH
83892: LD_EXP 65
83896: PPUSH
83897: LD_VAR 0 3
83901: PPUSH
83902: LD_EXP 65
83906: PUSH
83907: LD_VAR 0 3
83911: ARRAY
83912: PUSH
83913: LD_VAR 0 1
83917: DIFF
83918: PPUSH
83919: CALL_OW 1
83923: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
83924: LD_VAR 0 1
83928: PUSH
83929: LD_EXP 77
83933: PUSH
83934: LD_VAR 0 3
83938: ARRAY
83939: IN
83940: IFFALSE 83979
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
83942: LD_ADDR_EXP 77
83946: PUSH
83947: LD_EXP 77
83951: PPUSH
83952: LD_VAR 0 3
83956: PPUSH
83957: LD_EXP 77
83961: PUSH
83962: LD_VAR 0 3
83966: ARRAY
83967: PUSH
83968: LD_VAR 0 1
83972: DIFF
83973: PPUSH
83974: CALL_OW 1
83978: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
83979: LD_VAR 0 1
83983: PUSH
83984: LD_EXP 80
83988: PUSH
83989: LD_VAR 0 3
83993: ARRAY
83994: IN
83995: IFFALSE 84034
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
83997: LD_ADDR_EXP 80
84001: PUSH
84002: LD_EXP 80
84006: PPUSH
84007: LD_VAR 0 3
84011: PPUSH
84012: LD_EXP 80
84016: PUSH
84017: LD_VAR 0 3
84021: ARRAY
84022: PUSH
84023: LD_VAR 0 1
84027: DIFF
84028: PPUSH
84029: CALL_OW 1
84033: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
84034: LD_VAR 0 1
84038: PUSH
84039: LD_EXP 67
84043: PUSH
84044: LD_VAR 0 3
84048: ARRAY
84049: IN
84050: IFFALSE 84089
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
84052: LD_ADDR_EXP 67
84056: PUSH
84057: LD_EXP 67
84061: PPUSH
84062: LD_VAR 0 3
84066: PPUSH
84067: LD_EXP 67
84071: PUSH
84072: LD_VAR 0 3
84076: ARRAY
84077: PUSH
84078: LD_VAR 0 1
84082: DIFF
84083: PPUSH
84084: CALL_OW 1
84088: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
84089: LD_VAR 0 1
84093: PUSH
84094: LD_EXP 66
84098: PUSH
84099: LD_VAR 0 3
84103: ARRAY
84104: IN
84105: IFFALSE 84144
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
84107: LD_ADDR_EXP 66
84111: PUSH
84112: LD_EXP 66
84116: PPUSH
84117: LD_VAR 0 3
84121: PPUSH
84122: LD_EXP 66
84126: PUSH
84127: LD_VAR 0 3
84131: ARRAY
84132: PUSH
84133: LD_VAR 0 1
84137: DIFF
84138: PPUSH
84139: CALL_OW 1
84143: ST_TO_ADDR
// end ; break ;
84144: GO 84148
// end ;
84146: GO 83073
84148: POP
84149: POP
// end ;
84150: LD_VAR 0 2
84154: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
84155: LD_INT 0
84157: PPUSH
84158: PPUSH
84159: PPUSH
// if not mc_bases or not skirmish then
84160: LD_EXP 58
84164: NOT
84165: PUSH
84166: LD_EXP 56
84170: NOT
84171: OR
84172: IFFALSE 84176
// exit ;
84174: GO 84391
// for i = 1 to mc_bases do
84176: LD_ADDR_VAR 0 3
84180: PUSH
84181: DOUBLE
84182: LD_INT 1
84184: DEC
84185: ST_TO_ADDR
84186: LD_EXP 58
84190: PUSH
84191: FOR_TO
84192: IFFALSE 84389
// begin if building in mc_construct_list [ i ] then
84194: LD_VAR 0 1
84198: PUSH
84199: LD_EXP 65
84203: PUSH
84204: LD_VAR 0 3
84208: ARRAY
84209: IN
84210: IFFALSE 84387
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84212: LD_ADDR_EXP 65
84216: PUSH
84217: LD_EXP 65
84221: PPUSH
84222: LD_VAR 0 3
84226: PPUSH
84227: LD_EXP 65
84231: PUSH
84232: LD_VAR 0 3
84236: ARRAY
84237: PUSH
84238: LD_VAR 0 1
84242: DIFF
84243: PPUSH
84244: CALL_OW 1
84248: ST_TO_ADDR
// if building in mc_lab [ i ] then
84249: LD_VAR 0 1
84253: PUSH
84254: LD_EXP 91
84258: PUSH
84259: LD_VAR 0 3
84263: ARRAY
84264: IN
84265: IFFALSE 84320
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
84267: LD_ADDR_EXP 92
84271: PUSH
84272: LD_EXP 92
84276: PPUSH
84277: LD_VAR 0 3
84281: PPUSH
84282: LD_EXP 92
84286: PUSH
84287: LD_VAR 0 3
84291: ARRAY
84292: PPUSH
84293: LD_INT 1
84295: PPUSH
84296: LD_EXP 92
84300: PUSH
84301: LD_VAR 0 3
84305: ARRAY
84306: PPUSH
84307: LD_INT 0
84309: PPUSH
84310: CALL 20060 0 4
84314: PPUSH
84315: CALL_OW 1
84319: ST_TO_ADDR
// if not building in mc_bases [ i ] then
84320: LD_VAR 0 1
84324: PUSH
84325: LD_EXP 58
84329: PUSH
84330: LD_VAR 0 3
84334: ARRAY
84335: IN
84336: NOT
84337: IFFALSE 84383
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84339: LD_ADDR_EXP 58
84343: PUSH
84344: LD_EXP 58
84348: PPUSH
84349: LD_VAR 0 3
84353: PUSH
84354: LD_EXP 58
84358: PUSH
84359: LD_VAR 0 3
84363: ARRAY
84364: PUSH
84365: LD_INT 1
84367: PLUS
84368: PUSH
84369: EMPTY
84370: LIST
84371: LIST
84372: PPUSH
84373: LD_VAR 0 1
84377: PPUSH
84378: CALL 20642 0 3
84382: ST_TO_ADDR
// exit ;
84383: POP
84384: POP
84385: GO 84391
// end ; end ;
84387: GO 84191
84389: POP
84390: POP
// end ;
84391: LD_VAR 0 2
84395: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
84396: LD_INT 0
84398: PPUSH
84399: PPUSH
84400: PPUSH
84401: PPUSH
84402: PPUSH
84403: PPUSH
84404: PPUSH
// if not mc_bases or not skirmish then
84405: LD_EXP 58
84409: NOT
84410: PUSH
84411: LD_EXP 56
84415: NOT
84416: OR
84417: IFFALSE 84421
// exit ;
84419: GO 85082
// for i = 1 to mc_bases do
84421: LD_ADDR_VAR 0 3
84425: PUSH
84426: DOUBLE
84427: LD_INT 1
84429: DEC
84430: ST_TO_ADDR
84431: LD_EXP 58
84435: PUSH
84436: FOR_TO
84437: IFFALSE 85080
// begin if building in mc_construct_list [ i ] then
84439: LD_VAR 0 1
84443: PUSH
84444: LD_EXP 65
84448: PUSH
84449: LD_VAR 0 3
84453: ARRAY
84454: IN
84455: IFFALSE 85078
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84457: LD_ADDR_EXP 65
84461: PUSH
84462: LD_EXP 65
84466: PPUSH
84467: LD_VAR 0 3
84471: PPUSH
84472: LD_EXP 65
84476: PUSH
84477: LD_VAR 0 3
84481: ARRAY
84482: PUSH
84483: LD_VAR 0 1
84487: DIFF
84488: PPUSH
84489: CALL_OW 1
84493: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84494: LD_ADDR_EXP 58
84498: PUSH
84499: LD_EXP 58
84503: PPUSH
84504: LD_VAR 0 3
84508: PUSH
84509: LD_EXP 58
84513: PUSH
84514: LD_VAR 0 3
84518: ARRAY
84519: PUSH
84520: LD_INT 1
84522: PLUS
84523: PUSH
84524: EMPTY
84525: LIST
84526: LIST
84527: PPUSH
84528: LD_VAR 0 1
84532: PPUSH
84533: CALL 20642 0 3
84537: ST_TO_ADDR
// btype := GetBType ( building ) ;
84538: LD_ADDR_VAR 0 5
84542: PUSH
84543: LD_VAR 0 1
84547: PPUSH
84548: CALL_OW 266
84552: ST_TO_ADDR
// side := GetSide ( building ) ;
84553: LD_ADDR_VAR 0 8
84557: PUSH
84558: LD_VAR 0 1
84562: PPUSH
84563: CALL_OW 255
84567: ST_TO_ADDR
// if btype = b_lab then
84568: LD_VAR 0 5
84572: PUSH
84573: LD_INT 6
84575: EQUAL
84576: IFFALSE 84626
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
84578: LD_ADDR_EXP 91
84582: PUSH
84583: LD_EXP 91
84587: PPUSH
84588: LD_VAR 0 3
84592: PUSH
84593: LD_EXP 91
84597: PUSH
84598: LD_VAR 0 3
84602: ARRAY
84603: PUSH
84604: LD_INT 1
84606: PLUS
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: PPUSH
84612: LD_VAR 0 1
84616: PPUSH
84617: CALL 20642 0 3
84621: ST_TO_ADDR
// exit ;
84622: POP
84623: POP
84624: GO 85082
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
84626: LD_VAR 0 5
84630: PUSH
84631: LD_INT 0
84633: PUSH
84634: LD_INT 2
84636: PUSH
84637: LD_INT 4
84639: PUSH
84640: EMPTY
84641: LIST
84642: LIST
84643: LIST
84644: IN
84645: IFFALSE 84769
// begin if btype = b_armoury then
84647: LD_VAR 0 5
84651: PUSH
84652: LD_INT 4
84654: EQUAL
84655: IFFALSE 84665
// btype := b_barracks ;
84657: LD_ADDR_VAR 0 5
84661: PUSH
84662: LD_INT 5
84664: ST_TO_ADDR
// if btype = b_depot then
84665: LD_VAR 0 5
84669: PUSH
84670: LD_INT 0
84672: EQUAL
84673: IFFALSE 84683
// btype := b_warehouse ;
84675: LD_ADDR_VAR 0 5
84679: PUSH
84680: LD_INT 1
84682: ST_TO_ADDR
// if btype = b_workshop then
84683: LD_VAR 0 5
84687: PUSH
84688: LD_INT 2
84690: EQUAL
84691: IFFALSE 84701
// btype := b_factory ;
84693: LD_ADDR_VAR 0 5
84697: PUSH
84698: LD_INT 3
84700: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
84701: LD_VAR 0 5
84705: PPUSH
84706: LD_VAR 0 8
84710: PPUSH
84711: CALL_OW 323
84715: PUSH
84716: LD_INT 1
84718: EQUAL
84719: IFFALSE 84765
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
84721: LD_ADDR_EXP 90
84725: PUSH
84726: LD_EXP 90
84730: PPUSH
84731: LD_VAR 0 3
84735: PUSH
84736: LD_EXP 90
84740: PUSH
84741: LD_VAR 0 3
84745: ARRAY
84746: PUSH
84747: LD_INT 1
84749: PLUS
84750: PUSH
84751: EMPTY
84752: LIST
84753: LIST
84754: PPUSH
84755: LD_VAR 0 1
84759: PPUSH
84760: CALL 20642 0 3
84764: ST_TO_ADDR
// exit ;
84765: POP
84766: POP
84767: GO 85082
// end ; if btype in [ b_bunker , b_turret ] then
84769: LD_VAR 0 5
84773: PUSH
84774: LD_INT 32
84776: PUSH
84777: LD_INT 33
84779: PUSH
84780: EMPTY
84781: LIST
84782: LIST
84783: IN
84784: IFFALSE 85074
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
84786: LD_ADDR_EXP 66
84790: PUSH
84791: LD_EXP 66
84795: PPUSH
84796: LD_VAR 0 3
84800: PUSH
84801: LD_EXP 66
84805: PUSH
84806: LD_VAR 0 3
84810: ARRAY
84811: PUSH
84812: LD_INT 1
84814: PLUS
84815: PUSH
84816: EMPTY
84817: LIST
84818: LIST
84819: PPUSH
84820: LD_VAR 0 1
84824: PPUSH
84825: CALL 20642 0 3
84829: ST_TO_ADDR
// if btype = b_bunker then
84830: LD_VAR 0 5
84834: PUSH
84835: LD_INT 32
84837: EQUAL
84838: IFFALSE 85074
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84840: LD_ADDR_EXP 67
84844: PUSH
84845: LD_EXP 67
84849: PPUSH
84850: LD_VAR 0 3
84854: PUSH
84855: LD_EXP 67
84859: PUSH
84860: LD_VAR 0 3
84864: ARRAY
84865: PUSH
84866: LD_INT 1
84868: PLUS
84869: PUSH
84870: EMPTY
84871: LIST
84872: LIST
84873: PPUSH
84874: LD_VAR 0 1
84878: PPUSH
84879: CALL 20642 0 3
84883: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
84884: LD_ADDR_VAR 0 6
84888: PUSH
84889: LD_EXP 58
84893: PUSH
84894: LD_VAR 0 3
84898: ARRAY
84899: PPUSH
84900: LD_INT 25
84902: PUSH
84903: LD_INT 1
84905: PUSH
84906: EMPTY
84907: LIST
84908: LIST
84909: PUSH
84910: LD_INT 3
84912: PUSH
84913: LD_INT 54
84915: PUSH
84916: EMPTY
84917: LIST
84918: PUSH
84919: EMPTY
84920: LIST
84921: LIST
84922: PUSH
84923: EMPTY
84924: LIST
84925: LIST
84926: PPUSH
84927: CALL_OW 72
84931: ST_TO_ADDR
// if tmp then
84932: LD_VAR 0 6
84936: IFFALSE 84942
// exit ;
84938: POP
84939: POP
84940: GO 85082
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
84942: LD_ADDR_VAR 0 6
84946: PUSH
84947: LD_EXP 58
84951: PUSH
84952: LD_VAR 0 3
84956: ARRAY
84957: PPUSH
84958: LD_INT 2
84960: PUSH
84961: LD_INT 30
84963: PUSH
84964: LD_INT 4
84966: PUSH
84967: EMPTY
84968: LIST
84969: LIST
84970: PUSH
84971: LD_INT 30
84973: PUSH
84974: LD_INT 5
84976: PUSH
84977: EMPTY
84978: LIST
84979: LIST
84980: PUSH
84981: EMPTY
84982: LIST
84983: LIST
84984: LIST
84985: PPUSH
84986: CALL_OW 72
84990: ST_TO_ADDR
// if not tmp then
84991: LD_VAR 0 6
84995: NOT
84996: IFFALSE 85002
// exit ;
84998: POP
84999: POP
85000: GO 85082
// for j in tmp do
85002: LD_ADDR_VAR 0 4
85006: PUSH
85007: LD_VAR 0 6
85011: PUSH
85012: FOR_IN
85013: IFFALSE 85072
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
85015: LD_ADDR_VAR 0 7
85019: PUSH
85020: LD_VAR 0 4
85024: PPUSH
85025: CALL_OW 313
85029: PPUSH
85030: LD_INT 25
85032: PUSH
85033: LD_INT 1
85035: PUSH
85036: EMPTY
85037: LIST
85038: LIST
85039: PPUSH
85040: CALL_OW 72
85044: ST_TO_ADDR
// if units then
85045: LD_VAR 0 7
85049: IFFALSE 85070
// begin ComExitBuilding ( units [ 1 ] ) ;
85051: LD_VAR 0 7
85055: PUSH
85056: LD_INT 1
85058: ARRAY
85059: PPUSH
85060: CALL_OW 122
// exit ;
85064: POP
85065: POP
85066: POP
85067: POP
85068: GO 85082
// end ; end ;
85070: GO 85012
85072: POP
85073: POP
// end ; end ; exit ;
85074: POP
85075: POP
85076: GO 85082
// end ; end ;
85078: GO 84436
85080: POP
85081: POP
// end ;
85082: LD_VAR 0 2
85086: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
85087: LD_INT 0
85089: PPUSH
85090: PPUSH
85091: PPUSH
85092: PPUSH
85093: PPUSH
85094: PPUSH
85095: PPUSH
// if not mc_bases or not skirmish then
85096: LD_EXP 58
85100: NOT
85101: PUSH
85102: LD_EXP 56
85106: NOT
85107: OR
85108: IFFALSE 85112
// exit ;
85110: GO 85343
// btype := GetBType ( building ) ;
85112: LD_ADDR_VAR 0 6
85116: PUSH
85117: LD_VAR 0 1
85121: PPUSH
85122: CALL_OW 266
85126: ST_TO_ADDR
// x := GetX ( building ) ;
85127: LD_ADDR_VAR 0 7
85131: PUSH
85132: LD_VAR 0 1
85136: PPUSH
85137: CALL_OW 250
85141: ST_TO_ADDR
// y := GetY ( building ) ;
85142: LD_ADDR_VAR 0 8
85146: PUSH
85147: LD_VAR 0 1
85151: PPUSH
85152: CALL_OW 251
85156: ST_TO_ADDR
// d := GetDir ( building ) ;
85157: LD_ADDR_VAR 0 9
85161: PUSH
85162: LD_VAR 0 1
85166: PPUSH
85167: CALL_OW 254
85171: ST_TO_ADDR
// for i = 1 to mc_bases do
85172: LD_ADDR_VAR 0 4
85176: PUSH
85177: DOUBLE
85178: LD_INT 1
85180: DEC
85181: ST_TO_ADDR
85182: LD_EXP 58
85186: PUSH
85187: FOR_TO
85188: IFFALSE 85341
// begin if not mc_build_list [ i ] then
85190: LD_EXP 63
85194: PUSH
85195: LD_VAR 0 4
85199: ARRAY
85200: NOT
85201: IFFALSE 85205
// continue ;
85203: GO 85187
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
85205: LD_VAR 0 6
85209: PUSH
85210: LD_VAR 0 7
85214: PUSH
85215: LD_VAR 0 8
85219: PUSH
85220: LD_VAR 0 9
85224: PUSH
85225: EMPTY
85226: LIST
85227: LIST
85228: LIST
85229: LIST
85230: PPUSH
85231: LD_EXP 63
85235: PUSH
85236: LD_VAR 0 4
85240: ARRAY
85241: PUSH
85242: LD_INT 1
85244: ARRAY
85245: PPUSH
85246: CALL 26811 0 2
85250: IFFALSE 85339
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
85252: LD_ADDR_EXP 63
85256: PUSH
85257: LD_EXP 63
85261: PPUSH
85262: LD_VAR 0 4
85266: PPUSH
85267: LD_EXP 63
85271: PUSH
85272: LD_VAR 0 4
85276: ARRAY
85277: PPUSH
85278: LD_INT 1
85280: PPUSH
85281: CALL_OW 3
85285: PPUSH
85286: CALL_OW 1
85290: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
85291: LD_ADDR_EXP 65
85295: PUSH
85296: LD_EXP 65
85300: PPUSH
85301: LD_VAR 0 4
85305: PUSH
85306: LD_EXP 65
85310: PUSH
85311: LD_VAR 0 4
85315: ARRAY
85316: PUSH
85317: LD_INT 1
85319: PLUS
85320: PUSH
85321: EMPTY
85322: LIST
85323: LIST
85324: PPUSH
85325: LD_VAR 0 1
85329: PPUSH
85330: CALL 20642 0 3
85334: ST_TO_ADDR
// exit ;
85335: POP
85336: POP
85337: GO 85343
// end ; end ;
85339: GO 85187
85341: POP
85342: POP
// end ;
85343: LD_VAR 0 3
85347: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
85348: LD_INT 0
85350: PPUSH
85351: PPUSH
85352: PPUSH
// if not mc_bases or not skirmish then
85353: LD_EXP 58
85357: NOT
85358: PUSH
85359: LD_EXP 56
85363: NOT
85364: OR
85365: IFFALSE 85369
// exit ;
85367: GO 85559
// for i = 1 to mc_bases do
85369: LD_ADDR_VAR 0 4
85373: PUSH
85374: DOUBLE
85375: LD_INT 1
85377: DEC
85378: ST_TO_ADDR
85379: LD_EXP 58
85383: PUSH
85384: FOR_TO
85385: IFFALSE 85472
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
85387: LD_VAR 0 1
85391: PUSH
85392: LD_EXP 66
85396: PUSH
85397: LD_VAR 0 4
85401: ARRAY
85402: IN
85403: PUSH
85404: LD_VAR 0 1
85408: PUSH
85409: LD_EXP 67
85413: PUSH
85414: LD_VAR 0 4
85418: ARRAY
85419: IN
85420: NOT
85421: AND
85422: IFFALSE 85470
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
85424: LD_ADDR_EXP 67
85428: PUSH
85429: LD_EXP 67
85433: PPUSH
85434: LD_VAR 0 4
85438: PUSH
85439: LD_EXP 67
85443: PUSH
85444: LD_VAR 0 4
85448: ARRAY
85449: PUSH
85450: LD_INT 1
85452: PLUS
85453: PUSH
85454: EMPTY
85455: LIST
85456: LIST
85457: PPUSH
85458: LD_VAR 0 1
85462: PPUSH
85463: CALL 20642 0 3
85467: ST_TO_ADDR
// break ;
85468: GO 85472
// end ; end ;
85470: GO 85384
85472: POP
85473: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
85474: LD_VAR 0 1
85478: PPUSH
85479: CALL_OW 257
85483: PUSH
85484: LD_EXP 84
85488: IN
85489: PUSH
85490: LD_VAR 0 1
85494: PPUSH
85495: CALL_OW 266
85499: PUSH
85500: LD_INT 5
85502: EQUAL
85503: AND
85504: PUSH
85505: LD_VAR 0 2
85509: PPUSH
85510: CALL_OW 110
85514: PUSH
85515: LD_INT 18
85517: NONEQUAL
85518: AND
85519: IFFALSE 85559
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
85521: LD_VAR 0 2
85525: PPUSH
85526: CALL_OW 257
85530: PUSH
85531: LD_INT 5
85533: PUSH
85534: LD_INT 8
85536: PUSH
85537: LD_INT 9
85539: PUSH
85540: EMPTY
85541: LIST
85542: LIST
85543: LIST
85544: IN
85545: IFFALSE 85559
// SetClass ( unit , 1 ) ;
85547: LD_VAR 0 2
85551: PPUSH
85552: LD_INT 1
85554: PPUSH
85555: CALL_OW 336
// end ;
85559: LD_VAR 0 3
85563: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
85564: LD_INT 0
85566: PPUSH
85567: PPUSH
// if not mc_bases or not skirmish then
85568: LD_EXP 58
85572: NOT
85573: PUSH
85574: LD_EXP 56
85578: NOT
85579: OR
85580: IFFALSE 85584
// exit ;
85582: GO 85700
// if GetLives ( abandoned_vehicle ) > 250 then
85584: LD_VAR 0 2
85588: PPUSH
85589: CALL_OW 256
85593: PUSH
85594: LD_INT 250
85596: GREATER
85597: IFFALSE 85601
// exit ;
85599: GO 85700
// for i = 1 to mc_bases do
85601: LD_ADDR_VAR 0 6
85605: PUSH
85606: DOUBLE
85607: LD_INT 1
85609: DEC
85610: ST_TO_ADDR
85611: LD_EXP 58
85615: PUSH
85616: FOR_TO
85617: IFFALSE 85698
// begin if driver in mc_bases [ i ] then
85619: LD_VAR 0 1
85623: PUSH
85624: LD_EXP 58
85628: PUSH
85629: LD_VAR 0 6
85633: ARRAY
85634: IN
85635: IFFALSE 85696
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
85637: LD_VAR 0 1
85641: PPUSH
85642: LD_EXP 58
85646: PUSH
85647: LD_VAR 0 6
85651: ARRAY
85652: PPUSH
85653: LD_INT 2
85655: PUSH
85656: LD_INT 30
85658: PUSH
85659: LD_INT 0
85661: PUSH
85662: EMPTY
85663: LIST
85664: LIST
85665: PUSH
85666: LD_INT 30
85668: PUSH
85669: LD_INT 1
85671: PUSH
85672: EMPTY
85673: LIST
85674: LIST
85675: PUSH
85676: EMPTY
85677: LIST
85678: LIST
85679: LIST
85680: PPUSH
85681: CALL_OW 72
85685: PUSH
85686: LD_INT 1
85688: ARRAY
85689: PPUSH
85690: CALL_OW 112
// break ;
85694: GO 85698
// end ; end ;
85696: GO 85616
85698: POP
85699: POP
// end ; end_of_file
85700: LD_VAR 0 5
85704: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
85705: GO 85707
85707: DISABLE
// begin ru_radar := 98 ;
85708: LD_ADDR_EXP 101
85712: PUSH
85713: LD_INT 98
85715: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
85716: LD_ADDR_EXP 102
85720: PUSH
85721: LD_INT 89
85723: ST_TO_ADDR
// us_hack := 99 ;
85724: LD_ADDR_EXP 103
85728: PUSH
85729: LD_INT 99
85731: ST_TO_ADDR
// us_artillery := 97 ;
85732: LD_ADDR_EXP 104
85736: PUSH
85737: LD_INT 97
85739: ST_TO_ADDR
// ar_bio_bomb := 91 ;
85740: LD_ADDR_EXP 105
85744: PUSH
85745: LD_INT 91
85747: ST_TO_ADDR
// end ;
85748: END
