// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 701 0 0
// InitMacro ;
  19: CALL 56843 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 49461 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 49461 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 49461 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 49461 0 9
// if Difficulty < 4 then
 168: LD_OWVAR 67
 172: PUSH
 173: LD_INT 4
 175: LESS
 176: IFFALSE 185
// RemoveEnvironmentArea ( oilBlockArea ) ;
 178: LD_INT 24
 180: PPUSH
 181: CALL_OW 355
// PrepareArabian ;
 185: CALL 4085 0 0
// PrepareRussian ;
 189: CALL 2989 0 0
// PrepareAlliance ;
 193: CALL 911 0 0
// MC_Start ( ) ;
 197: CALL 59023 0 0
// if debug then
 201: LD_EXP 1
 205: IFFALSE 214
// FogOff ( 1 ) ;
 207: LD_INT 1
 209: PPUSH
 210: CALL_OW 344
// Action ;
 214: CALL 7736 0 0
// end ;
 218: END
// export function CustomInitMacro ; var i ; begin
 219: LD_INT 0
 221: PPUSH
 222: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 223: LD_ADDR_EXP 85
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 2
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 238: LD_ADDR_EXP 86
 242: PUSH
 243: LD_INT 3
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 12
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 18
 264: PUSH
 265: LD_INT 20
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: PUSH
 274: LD_OWVAR 67
 278: ARRAY
 279: PPUSH
 280: LD_INT 7
 282: PPUSH
 283: CALL 80726 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 287: LD_INT 1
 289: PPUSH
 290: LD_EXP 56
 294: PPUSH
 295: CALL 81171 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 6
 304: PPUSH
 305: CALL 81629 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 9
 314: PUSH
 315: EMPTY
 316: LIST
 317: PPUSH
 318: CALL 81898 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 322: LD_INT 1
 324: PPUSH
 325: LD_INT 13
 327: PUSH
 328: LD_INT 1
 330: PUSH
 331: LD_INT 2
 333: PUSH
 334: LD_INT 32
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: PUSH
 343: LD_INT 13
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 2
 351: PUSH
 352: LD_INT 88
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: PPUSH
 365: CALL 81111 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 369: LD_INT 2
 371: PPUSH
 372: LD_INT 12
 374: PUSH
 375: LD_INT 14
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL 81805 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 394: LD_INT 2
 396: PPUSH
 397: LD_EXP 53
 401: PPUSH
 402: CALL 81171 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 406: LD_INT 2
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: CALL 81629 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 416: LD_INT 2
 418: PPUSH
 419: LD_INT 10
 421: PUSH
 422: EMPTY
 423: LIST
 424: PPUSH
 425: CALL 81898 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 429: LD_INT 2
 431: PPUSH
 432: LD_INT 6
 434: PUSH
 435: LD_INT 71
 437: PUSH
 438: LD_INT 116
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: LD_INT 85
 455: PUSH
 456: LD_INT 116
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 32
 470: PUSH
 471: LD_INT 83
 473: PUSH
 474: LD_INT 111
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 87
 491: PUSH
 492: LD_INT 121
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 88
 509: PUSH
 510: LD_INT 128
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 32
 524: PUSH
 525: LD_INT 59
 527: PUSH
 528: LD_INT 89
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 69
 545: PUSH
 546: LD_INT 98
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 77
 563: PUSH
 564: LD_INT 103
 566: PUSH
 567: LD_INT 3
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 33
 578: PUSH
 579: LD_INT 83
 581: PUSH
 582: LD_INT 105
 584: PUSH
 585: LD_INT 3
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 33
 596: PUSH
 597: LD_INT 71
 599: PUSH
 600: LD_INT 125
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 80955 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 628: LD_INT 2
 630: PPUSH
 631: LD_INT 43
 633: PUSH
 634: LD_INT 47
 636: PUSH
 637: LD_INT 46
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL 82216 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 649: LD_INT 2
 651: PPUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 51
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 22
 672: PUSH
 673: LD_INT 1
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 52
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL 81111 0 2
// end ;
 696: LD_VAR 0 1
 700: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 701: LD_INT 0
 703: PPUSH
// debug := false ;
 704: LD_ADDR_EXP 1
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// game := true ;
 712: LD_ADDR_EXP 2
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// gossudarov_arrive := false ;
 720: LD_ADDR_EXP 4
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// ru_lab_builded := false ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_INT 0
 735: ST_TO_ADDR
// player_spotted := false ;
 736: LD_ADDR_EXP 6
 740: PUSH
 741: LD_INT 0
 743: ST_TO_ADDR
// first_attack := false ;
 744: LD_ADDR_EXP 7
 748: PUSH
 749: LD_INT 0
 751: ST_TO_ADDR
// ru_attackers := [ ] ;
 752: LD_ADDR_EXP 54
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// ar_base_spotted := false ;
 759: LD_ADDR_EXP 8
 763: PUSH
 764: LD_INT 0
 766: ST_TO_ADDR
// ar_active_attack := false ;
 767: LD_ADDR_EXP 9
 771: PUSH
 772: LD_INT 0
 774: ST_TO_ADDR
// ar_attackers := [ ] ;
 775: LD_ADDR_EXP 11
 779: PUSH
 780: EMPTY
 781: ST_TO_ADDR
// first_powell_attack := false ;
 782: LD_ADDR_EXP 12
 786: PUSH
 787: LD_INT 0
 789: ST_TO_ADDR
// masha_killed := false ;
 790: LD_ADDR_EXP 10
 794: PUSH
 795: LD_INT 0
 797: ST_TO_ADDR
// abdul_escaped := true ;
 798: LD_ADDR_EXP 13
 802: PUSH
 803: LD_INT 1
 805: ST_TO_ADDR
// loss_counter := 0 ;
 806: LD_ADDR_EXP 14
 810: PUSH
 811: LD_INT 0
 813: ST_TO_ADDR
// hack_counter := 0 ;
 814: LD_ADDR_EXP 15
 818: PUSH
 819: LD_INT 0
 821: ST_TO_ADDR
// end ;
 822: LD_VAR 0 1
 826: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 827: LD_EXP 50
 831: PPUSH
 832: CALL_OW 255
 836: PUSH
 837: LD_INT 7
 839: EQUAL
 840: PUSH
 841: LD_EXP 49
 845: PPUSH
 846: CALL_OW 255
 850: PUSH
 851: LD_INT 7
 853: EQUAL
 854: AND
 855: PUSH
 856: LD_EXP 50
 860: PPUSH
 861: CALL_OW 302
 865: AND
 866: PUSH
 867: LD_EXP 49
 871: PPUSH
 872: CALL_OW 302
 876: AND
 877: IFFALSE 889
 879: GO 881
 881: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 882: LD_STRING ACH_COMRADE
 884: PPUSH
 885: CALL_OW 543
 889: END
// every 0 0$1 trigger hack_counter >= 10 do
 890: LD_EXP 15
 894: PUSH
 895: LD_INT 10
 897: GREATEREQUAL
 898: IFFALSE 910
 900: GO 902
 902: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 903: LD_STRING ACH_HACK
 905: PPUSH
 906: CALL_OW 543
 910: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 911: LD_INT 0
 913: PPUSH
 914: PPUSH
 915: PPUSH
 916: PPUSH
// uc_side := 7 ;
 917: LD_ADDR_OWVAR 20
 921: PUSH
 922: LD_INT 7
 924: ST_TO_ADDR
// uc_nation := 1 ;
 925: LD_ADDR_OWVAR 21
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 933: LD_ADDR_EXP 16
 937: PUSH
 938: LD_STRING JMM
 940: PPUSH
 941: LD_EXP 1
 945: NOT
 946: PPUSH
 947: LD_STRING 12a_
 949: PPUSH
 950: CALL 15479 0 3
 954: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 955: LD_EXP 16
 959: PPUSH
 960: LD_INT 71
 962: PPUSH
 963: LD_INT 23
 965: PPUSH
 966: LD_INT 0
 968: PPUSH
 969: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 973: LD_EXP 16
 977: PPUSH
 978: LD_INT 2
 980: PPUSH
 981: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 985: LD_ADDR_EXP 17
 989: PUSH
 990: LD_STRING Roth
 992: PPUSH
 993: LD_EXP 1
 997: NOT
 998: PPUSH
 999: LD_STRING 12a_
1001: PPUSH
1002: CALL 15479 0 3
1006: ST_TO_ADDR
// if Roth then
1007: LD_EXP 17
1011: IFFALSE 1031
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1013: LD_EXP 17
1017: PPUSH
1018: LD_INT 71
1020: PPUSH
1021: LD_INT 21
1023: PPUSH
1024: LD_INT 0
1026: PPUSH
1027: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1031: LD_ADDR_EXP 33
1035: PUSH
1036: LD_STRING Mike
1038: PPUSH
1039: LD_EXP 1
1043: NOT
1044: PPUSH
1045: LD_STRING 12a_
1047: PPUSH
1048: CALL 15479 0 3
1052: ST_TO_ADDR
// if Mike then
1053: LD_EXP 33
1057: IFFALSE 1074
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1059: LD_EXP 33
1063: PPUSH
1064: LD_INT 13
1066: PPUSH
1067: LD_INT 0
1069: PPUSH
1070: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1074: LD_ADDR_EXP 18
1078: PUSH
1079: LD_STRING Lisa
1081: PPUSH
1082: LD_EXP 1
1086: NOT
1087: PPUSH
1088: LD_STRING 12a_
1090: PPUSH
1091: CALL 15479 0 3
1095: ST_TO_ADDR
// if Lisa then
1096: LD_EXP 18
1100: IFFALSE 1117
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1102: LD_EXP 18
1106: PPUSH
1107: LD_INT 13
1109: PPUSH
1110: LD_INT 0
1112: PPUSH
1113: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1117: LD_ADDR_EXP 19
1121: PUSH
1122: LD_STRING Donaldson
1124: PPUSH
1125: LD_EXP 1
1129: NOT
1130: PPUSH
1131: LD_STRING 12a_
1133: PPUSH
1134: CALL 15479 0 3
1138: ST_TO_ADDR
// if Donaldson then
1139: LD_EXP 19
1143: IFFALSE 1160
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1145: LD_EXP 19
1149: PPUSH
1150: LD_INT 13
1152: PPUSH
1153: LD_INT 0
1155: PPUSH
1156: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1160: LD_ADDR_EXP 20
1164: PUSH
1165: LD_STRING Bobby
1167: PPUSH
1168: LD_EXP 1
1172: NOT
1173: PPUSH
1174: LD_STRING 12a_
1176: PPUSH
1177: CALL 15479 0 3
1181: ST_TO_ADDR
// if Bobby then
1182: LD_EXP 20
1186: IFFALSE 1203
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1188: LD_EXP 20
1192: PPUSH
1193: LD_INT 13
1195: PPUSH
1196: LD_INT 0
1198: PPUSH
1199: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1203: LD_ADDR_EXP 21
1207: PUSH
1208: LD_STRING Cyrus
1210: PPUSH
1211: LD_EXP 1
1215: NOT
1216: PPUSH
1217: LD_STRING 12a_
1219: PPUSH
1220: CALL 15479 0 3
1224: ST_TO_ADDR
// if Cyrus then
1225: LD_EXP 21
1229: IFFALSE 1246
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1231: LD_EXP 21
1235: PPUSH
1236: LD_INT 13
1238: PPUSH
1239: LD_INT 0
1241: PPUSH
1242: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1246: LD_ADDR_EXP 22
1250: PUSH
1251: LD_STRING Denis
1253: PPUSH
1254: LD_EXP 1
1258: NOT
1259: PPUSH
1260: LD_STRING 12a_
1262: PPUSH
1263: CALL 15479 0 3
1267: ST_TO_ADDR
// if Denis then
1268: LD_EXP 22
1272: IFFALSE 1289
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1274: LD_EXP 22
1278: PPUSH
1279: LD_INT 13
1281: PPUSH
1282: LD_INT 0
1284: PPUSH
1285: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1289: LD_ADDR_EXP 23
1293: PUSH
1294: LD_STRING Brown
1296: PPUSH
1297: LD_EXP 1
1301: NOT
1302: PPUSH
1303: LD_STRING 12a_
1305: PPUSH
1306: CALL 15479 0 3
1310: ST_TO_ADDR
// if Brown then
1311: LD_EXP 23
1315: IFFALSE 1332
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1317: LD_EXP 23
1321: PPUSH
1322: LD_INT 13
1324: PPUSH
1325: LD_INT 0
1327: PPUSH
1328: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1332: LD_ADDR_EXP 24
1336: PUSH
1337: LD_STRING Gladstone
1339: PPUSH
1340: LD_EXP 1
1344: NOT
1345: PPUSH
1346: LD_STRING 12a_
1348: PPUSH
1349: CALL 15479 0 3
1353: ST_TO_ADDR
// if Gladstone then
1354: LD_EXP 24
1358: IFFALSE 1375
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1360: LD_EXP 24
1364: PPUSH
1365: LD_INT 13
1367: PPUSH
1368: LD_INT 0
1370: PPUSH
1371: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1375: LD_ADDR_EXP 25
1379: PUSH
1380: LD_STRING Houten
1382: PPUSH
1383: LD_EXP 1
1387: NOT
1388: PPUSH
1389: LD_STRING 12a_
1391: PPUSH
1392: CALL 15479 0 3
1396: ST_TO_ADDR
// if Houten then
1397: LD_EXP 25
1401: IFFALSE 1418
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1403: LD_EXP 25
1407: PPUSH
1408: LD_INT 13
1410: PPUSH
1411: LD_INT 0
1413: PPUSH
1414: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1418: LD_ADDR_EXP 26
1422: PUSH
1423: LD_STRING Cornell
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: LD_STRING 12a_
1434: PPUSH
1435: CALL 15479 0 3
1439: ST_TO_ADDR
// if Cornel then
1440: LD_EXP 26
1444: IFFALSE 1461
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1446: LD_EXP 26
1450: PPUSH
1451: LD_INT 13
1453: PPUSH
1454: LD_INT 0
1456: PPUSH
1457: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1461: LD_ADDR_EXP 27
1465: PUSH
1466: LD_STRING Gary
1468: PPUSH
1469: LD_EXP 1
1473: NOT
1474: PPUSH
1475: LD_STRING 12a_
1477: PPUSH
1478: CALL 15479 0 3
1482: ST_TO_ADDR
// if Gary then
1483: LD_EXP 27
1487: IFFALSE 1504
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1489: LD_EXP 27
1493: PPUSH
1494: LD_INT 13
1496: PPUSH
1497: LD_INT 0
1499: PPUSH
1500: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1504: LD_ADDR_EXP 28
1508: PUSH
1509: LD_STRING Frank
1511: PPUSH
1512: LD_EXP 1
1516: NOT
1517: PPUSH
1518: LD_STRING 12a_
1520: PPUSH
1521: CALL 15479 0 3
1525: ST_TO_ADDR
// if Frank then
1526: LD_EXP 28
1530: IFFALSE 1547
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1532: LD_EXP 28
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: LD_INT 0
1542: PPUSH
1543: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1547: LD_ADDR_EXP 29
1551: PUSH
1552: LD_STRING Kikuchi
1554: PPUSH
1555: LD_EXP 1
1559: NOT
1560: PPUSH
1561: LD_STRING 12a_
1563: PPUSH
1564: CALL 15479 0 3
1568: ST_TO_ADDR
// if Kikuchi then
1569: LD_EXP 29
1573: IFFALSE 1590
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1575: LD_EXP 29
1579: PPUSH
1580: LD_INT 13
1582: PPUSH
1583: LD_INT 0
1585: PPUSH
1586: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1590: LD_ADDR_EXP 30
1594: PUSH
1595: LD_STRING Simms
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 12a_
1606: PPUSH
1607: CALL 15479 0 3
1611: ST_TO_ADDR
// if Simms then
1612: LD_EXP 30
1616: IFFALSE 1633
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1618: LD_EXP 30
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1633: LD_ADDR_EXP 31
1637: PUSH
1638: LD_STRING Joan
1640: PPUSH
1641: LD_EXP 1
1645: NOT
1646: PPUSH
1647: LD_STRING 12a_
1649: PPUSH
1650: CALL 15479 0 3
1654: ST_TO_ADDR
// if Joan then
1655: LD_EXP 31
1659: IFFALSE 1676
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1661: LD_EXP 31
1665: PPUSH
1666: LD_INT 13
1668: PPUSH
1669: LD_INT 0
1671: PPUSH
1672: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1676: LD_ADDR_EXP 32
1680: PUSH
1681: LD_STRING DeltaDoctor
1683: PPUSH
1684: LD_EXP 1
1688: NOT
1689: PPUSH
1690: LD_STRING 12a_
1692: PPUSH
1693: CALL 15479 0 3
1697: ST_TO_ADDR
// if DeltaDoctor then
1698: LD_EXP 32
1702: IFFALSE 1719
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1704: LD_EXP 32
1708: PPUSH
1709: LD_INT 13
1711: PPUSH
1712: LD_INT 0
1714: PPUSH
1715: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1719: LD_ADDR_VAR 0 4
1723: PUSH
1724: LD_STRING 12a_others
1726: PPUSH
1727: CALL_OW 31
1731: ST_TO_ADDR
// if tmp then
1732: LD_VAR 0 4
1736: IFFALSE 1770
// for i in tmp do
1738: LD_ADDR_VAR 0 3
1742: PUSH
1743: LD_VAR 0 4
1747: PUSH
1748: FOR_IN
1749: IFFALSE 1768
// PlaceUnitArea ( i , alliance_start , false ) ;
1751: LD_VAR 0 3
1755: PPUSH
1756: LD_INT 13
1758: PPUSH
1759: LD_INT 0
1761: PPUSH
1762: CALL_OW 49
1766: GO 1748
1768: POP
1769: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1770: LD_INT 3
1772: PPUSH
1773: LD_INT 3
1775: PPUSH
1776: LD_INT 3
1778: PPUSH
1779: LD_INT 12
1781: PPUSH
1782: LD_INT 100
1784: PPUSH
1785: CALL 20319 0 5
// veh := CreateVehicle ;
1789: LD_ADDR_VAR 0 2
1793: PUSH
1794: CALL_OW 45
1798: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1799: LD_VAR 0 2
1803: PPUSH
1804: LD_INT 2
1806: PPUSH
1807: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1811: LD_VAR 0 2
1815: PPUSH
1816: LD_INT 60
1818: PPUSH
1819: LD_INT 6
1821: PPUSH
1822: LD_INT 0
1824: PPUSH
1825: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1829: LD_VAR 0 2
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: LD_INT 30
1839: PPUSH
1840: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1844: LD_STRING 11_artifact_captured
1846: PPUSH
1847: LD_INT 0
1849: PPUSH
1850: CALL_OW 30
1854: IFFALSE 1930
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1856: LD_INT 3
1858: PPUSH
1859: LD_INT 3
1861: PPUSH
1862: LD_INT 3
1864: PPUSH
1865: LD_INT 12
1867: PPUSH
1868: LD_INT 100
1870: PPUSH
1871: CALL 20319 0 5
// veh := CreateVehicle ;
1875: LD_ADDR_VAR 0 2
1879: PUSH
1880: CALL_OW 45
1884: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1885: LD_VAR 0 2
1889: PPUSH
1890: LD_INT 3
1892: PPUSH
1893: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1897: LD_VAR 0 2
1901: PPUSH
1902: LD_INT 75
1904: PPUSH
1905: LD_INT 6
1907: PPUSH
1908: LD_INT 0
1910: PPUSH
1911: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1915: LD_VAR 0 2
1919: PPUSH
1920: LD_INT 4
1922: PPUSH
1923: LD_INT 50
1925: PPUSH
1926: CALL_OW 290
// end ; end ;
1930: LD_VAR 0 1
1934: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1935: LD_INT 0
1937: PPUSH
1938: PPUSH
1939: PPUSH
1940: PPUSH
// uc_side := 6 ;
1941: LD_ADDR_OWVAR 20
1945: PUSH
1946: LD_INT 6
1948: ST_TO_ADDR
// uc_nation := 3 ;
1949: LD_ADDR_OWVAR 21
1953: PUSH
1954: LD_INT 3
1956: ST_TO_ADDR
// InitHc ;
1957: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1961: LD_ADDR_EXP 34
1965: PUSH
1966: LD_STRING Gossudarov
1968: PPUSH
1969: CALL_OW 25
1973: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1974: LD_ADDR_EXP 35
1978: PUSH
1979: LD_STRING Kirilenkova
1981: PPUSH
1982: CALL_OW 25
1986: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1987: LD_ADDR_EXP 36
1991: PUSH
1992: LD_STRING Titov
1994: PPUSH
1995: CALL_OW 25
1999: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
2000: LD_ADDR_EXP 41
2004: PUSH
2005: LD_STRING Oblukov
2007: PPUSH
2008: CALL_OW 25
2012: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
2013: LD_ADDR_EXP 38
2017: PUSH
2018: LD_STRING Dolgov
2020: PPUSH
2021: CALL_OW 25
2025: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2026: LD_ADDR_EXP 39
2030: PUSH
2031: LD_STRING Petrosyan
2033: PPUSH
2034: CALL_OW 25
2038: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2039: LD_ADDR_EXP 40
2043: PUSH
2044: LD_STRING Scholtze
2046: PPUSH
2047: CALL_OW 25
2051: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2052: LD_ADDR_EXP 42
2056: PUSH
2057: LD_STRING Kapitsova
2059: PPUSH
2060: CALL_OW 25
2064: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2065: LD_ADDR_VAR 0 2
2069: PUSH
2070: LD_EXP 34
2074: PUSH
2075: LD_EXP 35
2079: PUSH
2080: LD_EXP 36
2084: PUSH
2085: LD_EXP 41
2089: PUSH
2090: LD_EXP 38
2094: PUSH
2095: LD_EXP 39
2099: PUSH
2100: LD_EXP 40
2104: PUSH
2105: LD_EXP 42
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: LIST
2116: LIST
2117: LIST
2118: LIST
2119: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2120: LD_INT 1
2122: PPUSH
2123: LD_INT 4
2125: PPUSH
2126: LD_INT 8
2128: PPUSH
2129: CALL_OW 380
// un := CreateHuman ;
2133: LD_ADDR_VAR 0 4
2137: PUSH
2138: CALL_OW 44
2142: ST_TO_ADDR
// tmp := tmp ^ un ;
2143: LD_ADDR_VAR 0 2
2147: PUSH
2148: LD_VAR 0 2
2152: PUSH
2153: LD_VAR 0 4
2157: ADD
2158: ST_TO_ADDR
// for i in tmp do
2159: LD_ADDR_VAR 0 3
2163: PUSH
2164: LD_VAR 0 2
2168: PUSH
2169: FOR_IN
2170: IFFALSE 2189
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2172: LD_VAR 0 3
2176: PPUSH
2177: LD_INT 14
2179: PPUSH
2180: LD_INT 0
2182: PPUSH
2183: CALL_OW 49
2187: GO 2169
2189: POP
2190: POP
// if freedom then
2191: LD_EXP 3
2195: IFFALSE 2228
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2197: LD_VAR 0 2
2201: PPUSH
2202: LD_EXP 3
2206: PPUSH
2207: CALL_OW 250
2211: PPUSH
2212: LD_EXP 3
2216: PPUSH
2217: CALL_OW 251
2221: PPUSH
2222: CALL_OW 111
2226: GO 2243
// ComMoveXY ( tmp , 70 , 48 ) ;
2228: LD_VAR 0 2
2232: PPUSH
2233: LD_INT 70
2235: PPUSH
2236: LD_INT 48
2238: PPUSH
2239: CALL_OW 111
// end ;
2243: LD_VAR 0 1
2247: RET
// export function PrepareBelkov ; begin
2248: LD_INT 0
2250: PPUSH
// uc_side := 4 ;
2251: LD_ADDR_OWVAR 20
2255: PUSH
2256: LD_INT 4
2258: ST_TO_ADDR
// uc_nation := 3 ;
2259: LD_ADDR_OWVAR 21
2263: PUSH
2264: LD_INT 3
2266: ST_TO_ADDR
// InitHc ;
2267: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2271: LD_ADDR_EXP 49
2275: PUSH
2276: LD_STRING Belkov
2278: PPUSH
2279: CALL_OW 25
2283: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2284: LD_EXP 49
2288: PPUSH
2289: LD_INT 14
2291: PPUSH
2292: LD_INT 0
2294: PPUSH
2295: CALL_OW 49
// end ;
2299: LD_VAR 0 1
2303: RET
// export function PrepareGnyevko ; begin
2304: LD_INT 0
2306: PPUSH
// uc_side := 4 ;
2307: LD_ADDR_OWVAR 20
2311: PUSH
2312: LD_INT 4
2314: ST_TO_ADDR
// uc_nation := 3 ;
2315: LD_ADDR_OWVAR 21
2319: PUSH
2320: LD_INT 3
2322: ST_TO_ADDR
// InitHc ;
2323: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2327: LD_ADDR_EXP 50
2331: PUSH
2332: LD_STRING Gnyevko
2334: PPUSH
2335: CALL_OW 25
2339: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2340: LD_EXP 50
2344: PPUSH
2345: LD_INT 14
2347: PPUSH
2348: LD_INT 0
2350: PPUSH
2351: CALL_OW 49
// end ;
2355: LD_VAR 0 1
2359: RET
// export function PrepareBurlak ; var i , tmp ; begin
2360: LD_INT 0
2362: PPUSH
2363: PPUSH
2364: PPUSH
// uc_side := 4 ;
2365: LD_ADDR_OWVAR 20
2369: PUSH
2370: LD_INT 4
2372: ST_TO_ADDR
// uc_nation := 3 ;
2373: LD_ADDR_OWVAR 21
2377: PUSH
2378: LD_INT 3
2380: ST_TO_ADDR
// InitHc ;
2381: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2385: LD_ADDR_EXP 48
2389: PUSH
2390: LD_STRING Burlak
2392: PPUSH
2393: CALL_OW 25
2397: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2398: LD_INT 24
2400: PUSH
2401: LD_INT 23
2403: PUSH
2404: LD_INT 22
2406: PUSH
2407: LD_INT 22
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: LIST
2414: LIST
2415: PUSH
2416: LD_OWVAR 67
2420: ARRAY
2421: PPUSH
2422: LD_INT 1
2424: PPUSH
2425: LD_INT 1
2427: PPUSH
2428: LD_INT 45
2430: PUSH
2431: LD_INT 44
2433: PUSH
2434: LD_INT 43
2436: PUSH
2437: LD_INT 42
2439: PUSH
2440: EMPTY
2441: LIST
2442: LIST
2443: LIST
2444: LIST
2445: PUSH
2446: LD_OWVAR 67
2450: ARRAY
2451: PPUSH
2452: LD_INT 0
2454: PPUSH
2455: CALL 20319 0 5
// Masha := CreateVehicle ;
2459: LD_ADDR_EXP 51
2463: PUSH
2464: CALL_OW 45
2468: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2469: LD_EXP 51
2473: PUSH
2474: LD_EXP 48
2478: PUSH
2479: EMPTY
2480: LIST
2481: LIST
2482: PPUSH
2483: LD_INT 499
2485: PPUSH
2486: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2490: LD_EXP 51
2494: PPUSH
2495: LD_INT 3
2497: PPUSH
2498: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2502: LD_EXP 51
2506: PPUSH
2507: LD_INT 1
2509: PPUSH
2510: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2514: LD_INT 1
2516: PPUSH
2517: LD_INT 18
2519: PPUSH
2520: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2524: LD_INT 35
2526: PPUSH
2527: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2531: LD_ADDR_VAR 0 3
2535: PUSH
2536: LD_INT 18
2538: PPUSH
2539: EMPTY
2540: PPUSH
2541: CALL_OW 70
2545: ST_TO_ADDR
// if tmp then
2546: LD_VAR 0 3
2550: IFFALSE 2584
// for i in tmp do
2552: LD_ADDR_VAR 0 2
2556: PUSH
2557: LD_VAR 0 3
2561: PUSH
2562: FOR_IN
2563: IFFALSE 2582
// ComMoveXY ( i , 114 , 9 ) ;
2565: LD_VAR 0 2
2569: PPUSH
2570: LD_INT 114
2572: PPUSH
2573: LD_INT 9
2575: PPUSH
2576: CALL_OW 111
2580: GO 2562
2582: POP
2583: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2584: LD_INT 18
2586: PPUSH
2587: EMPTY
2588: PPUSH
2589: CALL_OW 70
2593: NOT
2594: PUSH
2595: LD_INT 123
2597: PPUSH
2598: LD_INT 3
2600: PPUSH
2601: CALL_OW 428
2605: PUSH
2606: LD_INT 0
2608: EQUAL
2609: AND
2610: IFFALSE 2524
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2612: LD_EXP 51
2616: PPUSH
2617: LD_INT 123
2619: PPUSH
2620: LD_INT 3
2622: PPUSH
2623: LD_INT 0
2625: PPUSH
2626: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2630: LD_EXP 48
2634: PPUSH
2635: LD_INT 125
2637: PPUSH
2638: LD_INT 1
2640: PPUSH
2641: LD_INT 0
2643: PPUSH
2644: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2648: LD_EXP 48
2652: PPUSH
2653: LD_EXP 51
2657: PPUSH
2658: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2662: LD_INT 10
2664: PPUSH
2665: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2669: LD_EXP 51
2673: PPUSH
2674: LD_INT 110
2676: PPUSH
2677: LD_INT 10
2679: PPUSH
2680: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2684: LD_ADDR_EXP 44
2688: PUSH
2689: LD_STRING Petrovova
2691: PPUSH
2692: CALL_OW 25
2696: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2697: LD_ADDR_EXP 46
2701: PUSH
2702: LD_STRING Kuzmov
2704: PPUSH
2705: CALL_OW 25
2709: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2710: LD_ADDR_EXP 45
2714: PUSH
2715: LD_STRING Kovalyuk
2717: PPUSH
2718: CALL_OW 25
2722: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2723: LD_ADDR_EXP 43
2727: PUSH
2728: LD_STRING Lipshchin
2730: PPUSH
2731: CALL_OW 25
2735: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2736: LD_ADDR_EXP 47
2740: PUSH
2741: LD_STRING Karamazov
2743: PPUSH
2744: CALL_OW 25
2748: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2749: LD_ADDR_VAR 0 3
2753: PUSH
2754: LD_EXP 44
2758: PUSH
2759: LD_EXP 46
2763: PUSH
2764: LD_EXP 45
2768: PUSH
2769: LD_EXP 43
2773: PUSH
2774: LD_EXP 47
2778: PUSH
2779: EMPTY
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: LIST
2785: ST_TO_ADDR
// for i in tmp do
2786: LD_ADDR_VAR 0 2
2790: PUSH
2791: LD_VAR 0 3
2795: PUSH
2796: FOR_IN
2797: IFFALSE 2836
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2799: LD_VAR 0 2
2803: PPUSH
2804: LD_INT 399
2806: PPUSH
2807: LD_INT 799
2809: PPUSH
2810: CALL_OW 12
2814: PPUSH
2815: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2819: LD_VAR 0 2
2823: PPUSH
2824: LD_INT 19
2826: PPUSH
2827: LD_INT 0
2829: PPUSH
2830: CALL_OW 49
// end ;
2834: GO 2796
2836: POP
2837: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2838: LD_VAR 0 3
2842: PPUSH
2843: LD_INT 112
2845: PPUSH
2846: LD_INT 5
2848: PPUSH
2849: CALL_OW 111
// AddComHold ( tmp ) ;
2853: LD_VAR 0 3
2857: PPUSH
2858: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2862: LD_ADDR_VAR 0 2
2866: PUSH
2867: LD_VAR 0 3
2871: PPUSH
2872: LD_INT 25
2874: PUSH
2875: LD_INT 1
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: PPUSH
2882: CALL_OW 72
2886: PUSH
2887: FOR_IN
2888: IFFALSE 2928
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2890: LD_VAR 0 2
2894: PPUSH
2895: LD_INT 20
2897: PPUSH
2898: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2902: LD_VAR 0 2
2906: PPUSH
2907: LD_INT 147
2909: PPUSH
2910: LD_INT 45
2912: PPUSH
2913: CALL_OW 178
// AddComCrawl ( i ) ;
2917: LD_VAR 0 2
2921: PPUSH
2922: CALL_OW 197
// end ;
2926: GO 2887
2928: POP
2929: POP
// repeat wait ( 0 0$1 ) ;
2930: LD_INT 35
2932: PPUSH
2933: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2937: LD_EXP 51
2941: PPUSH
2942: LD_INT 110
2944: PPUSH
2945: LD_INT 10
2947: PPUSH
2948: CALL_OW 307
2952: PUSH
2953: LD_EXP 51
2957: PPUSH
2958: CALL_OW 305
2962: NOT
2963: OR
2964: IFFALSE 2930
// ComStop ( Burlak ) ;
2966: LD_EXP 48
2970: PPUSH
2971: CALL_OW 141
// AddComHold ( Burlak ) ;
2975: LD_EXP 48
2979: PPUSH
2980: CALL_OW 200
// end ; end_of_file
2984: LD_VAR 0 1
2988: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2989: LD_INT 0
2991: PPUSH
2992: PPUSH
2993: PPUSH
2994: PPUSH
2995: PPUSH
// uc_side := 3 ;
2996: LD_ADDR_OWVAR 20
3000: PUSH
3001: LD_INT 3
3003: ST_TO_ADDR
// uc_nation := 3 ;
3004: LD_ADDR_OWVAR 21
3008: PUSH
3009: LD_INT 3
3011: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
3012: LD_ADDR_EXP 52
3016: PUSH
3017: LD_INT 47
3019: PPUSH
3020: LD_INT 4
3022: PPUSH
3023: LD_STRING 
3025: PPUSH
3026: LD_INT 7
3028: PUSH
3029: LD_INT 8
3031: PUSH
3032: LD_INT 9
3034: PUSH
3035: LD_INT 10
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: PUSH
3044: LD_OWVAR 67
3048: ARRAY
3049: PPUSH
3050: LD_INT 10000
3052: PUSH
3053: LD_INT 3000
3055: PUSH
3056: LD_INT 300
3058: PUSH
3059: EMPTY
3060: LIST
3061: LIST
3062: LIST
3063: PPUSH
3064: LD_INT 9
3066: PUSH
3067: LD_INT 5
3069: PUSH
3070: LD_INT 6
3072: PUSH
3073: LD_INT 6
3075: PUSH
3076: EMPTY
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PPUSH
3082: CALL 23763 0 6
3086: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3087: LD_ADDR_EXP 61
3091: PUSH
3092: LD_EXP 61
3096: PPUSH
3097: LD_INT 2
3099: PPUSH
3100: LD_EXP 52
3104: PPUSH
3105: CALL_OW 1
3109: ST_TO_ADDR
// tmp := [ ] ;
3110: LD_ADDR_VAR 0 4
3114: PUSH
3115: EMPTY
3116: ST_TO_ADDR
// for i = 1 to 4 do
3117: LD_ADDR_VAR 0 2
3121: PUSH
3122: DOUBLE
3123: LD_INT 1
3125: DEC
3126: ST_TO_ADDR
3127: LD_INT 4
3129: PUSH
3130: FOR_TO
3131: IFFALSE 3224
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3133: LD_INT 22
3135: PPUSH
3136: LD_INT 3
3138: PPUSH
3139: LD_INT 3
3141: PPUSH
3142: LD_INT 43
3144: PUSH
3145: LD_INT 45
3147: PUSH
3148: LD_INT 45
3150: PUSH
3151: LD_INT 44
3153: PUSH
3154: EMPTY
3155: LIST
3156: LIST
3157: LIST
3158: LIST
3159: PUSH
3160: LD_VAR 0 2
3164: PUSH
3165: LD_INT 4
3167: MOD
3168: PUSH
3169: LD_INT 1
3171: PLUS
3172: ARRAY
3173: PPUSH
3174: LD_INT 100
3176: PPUSH
3177: CALL 20319 0 5
// veh := CreateVehicle ;
3181: LD_ADDR_VAR 0 3
3185: PUSH
3186: CALL_OW 45
3190: ST_TO_ADDR
// tmp := tmp ^ veh ;
3191: LD_ADDR_VAR 0 4
3195: PUSH
3196: LD_VAR 0 4
3200: PUSH
3201: LD_VAR 0 3
3205: ADD
3206: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3207: LD_VAR 0 3
3211: PPUSH
3212: LD_INT 2
3214: PPUSH
3215: LD_INT 0
3217: PPUSH
3218: CALL_OW 49
// end ;
3222: GO 3130
3224: POP
3225: POP
// russian_guard := tmp ;
3226: LD_ADDR_EXP 53
3230: PUSH
3231: LD_VAR 0 4
3235: ST_TO_ADDR
// if Difficulty >= 3 then
3236: LD_OWVAR 67
3240: PUSH
3241: LD_INT 3
3243: GREATEREQUAL
3244: IFFALSE 3308
// begin bc_type := b_breastwork ;
3246: LD_ADDR_OWVAR 42
3250: PUSH
3251: LD_INT 31
3253: ST_TO_ADDR
// bc_level := 10 ;
3254: LD_ADDR_OWVAR 43
3258: PUSH
3259: LD_INT 10
3261: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3262: LD_ADDR_VAR 0 5
3266: PUSH
3267: LD_INT 96
3269: PPUSH
3270: LD_INT 105
3272: PPUSH
3273: LD_INT 3
3275: PPUSH
3276: CALL_OW 47
3280: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3281: LD_INT 0
3283: PPUSH
3284: LD_INT 9
3286: PPUSH
3287: LD_INT 10
3289: PPUSH
3290: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3294: CALL_OW 44
3298: PPUSH
3299: LD_VAR 0 5
3303: PPUSH
3304: CALL_OW 52
// end ; end ;
3308: LD_VAR 0 1
3312: RET
// every 7 7$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , p , base , tmp , flags , _target , attackers , amount ;
3313: LD_INT 47
3315: PPUSH
3316: CALL_OW 302
3320: PUSH
3321: LD_EXP 6
3325: AND
3326: IFFALSE 4082
3328: GO 3330
3330: DISABLE
3331: LD_INT 0
3333: PPUSH
3334: PPUSH
3335: PPUSH
3336: PPUSH
3337: PPUSH
3338: PPUSH
3339: PPUSH
3340: PPUSH
// begin enable ;
3341: ENABLE
// base := 2 ;
3342: LD_ADDR_VAR 0 3
3346: PUSH
3347: LD_INT 2
3349: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3350: LD_ADDR_VAR 0 5
3354: PUSH
3355: LD_INT 0
3357: PUSH
3358: LD_INT 0
3360: PUSH
3361: LD_INT 0
3363: PUSH
3364: LD_INT 0
3366: PUSH
3367: LD_INT 0
3369: PUSH
3370: LD_INT 0
3372: PUSH
3373: LD_INT 0
3375: PUSH
3376: LD_INT 0
3378: PUSH
3379: LD_INT 1
3381: PUSH
3382: LD_INT 0
3384: PUSH
3385: EMPTY
3386: LIST
3387: LIST
3388: LIST
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: LIST
3394: LIST
3395: LIST
3396: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3397: LD_ADDR_VAR 0 4
3401: PUSH
3402: LD_INT 22
3404: PUSH
3405: LD_INT 1
3407: PUSH
3408: LD_INT 3
3410: PUSH
3411: LD_INT 45
3413: PUSH
3414: EMPTY
3415: LIST
3416: LIST
3417: LIST
3418: LIST
3419: PUSH
3420: LD_INT 21
3422: PUSH
3423: LD_INT 1
3425: PUSH
3426: LD_INT 3
3428: PUSH
3429: LD_INT 45
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: PUSH
3438: LD_INT 22
3440: PUSH
3441: LD_INT 1
3443: PUSH
3444: LD_INT 3
3446: PUSH
3447: LD_INT 45
3449: PUSH
3450: EMPTY
3451: LIST
3452: LIST
3453: LIST
3454: LIST
3455: PUSH
3456: LD_INT 23
3458: PUSH
3459: LD_INT 1
3461: PUSH
3462: LD_INT 3
3464: PUSH
3465: LD_INT 46
3467: PUSH
3468: EMPTY
3469: LIST
3470: LIST
3471: LIST
3472: LIST
3473: PUSH
3474: EMPTY
3475: LIST
3476: LIST
3477: LIST
3478: LIST
3479: ST_TO_ADDR
// amount := Difficulty ;
3480: LD_ADDR_VAR 0 8
3484: PUSH
3485: LD_OWVAR 67
3489: ST_TO_ADDR
// if tick > 30 30$00 then
3490: LD_OWVAR 1
3494: PUSH
3495: LD_INT 63000
3497: GREATER
3498: IFFALSE 3535
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3500: LD_ADDR_VAR 0 8
3504: PUSH
3505: LD_VAR 0 8
3509: PUSH
3510: LD_INT 2
3512: PUSH
3513: LD_INT 3
3515: PUSH
3516: LD_INT 4
3518: PUSH
3519: LD_INT 4
3521: PUSH
3522: EMPTY
3523: LIST
3524: LIST
3525: LIST
3526: LIST
3527: PUSH
3528: LD_OWVAR 67
3532: ARRAY
3533: PLUS
3534: ST_TO_ADDR
// for i = 1 to amount do
3535: LD_ADDR_VAR 0 1
3539: PUSH
3540: DOUBLE
3541: LD_INT 1
3543: DEC
3544: ST_TO_ADDR
3545: LD_VAR 0 8
3549: PUSH
3550: FOR_TO
3551: IFFALSE 3639
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3553: LD_ADDR_VAR 0 4
3557: PUSH
3558: LD_VAR 0 4
3562: PPUSH
3563: LD_VAR 0 4
3567: PUSH
3568: LD_INT 1
3570: PLUS
3571: PPUSH
3572: LD_INT 23
3574: PUSH
3575: LD_INT 24
3577: PUSH
3578: EMPTY
3579: LIST
3580: LIST
3581: PUSH
3582: LD_INT 1
3584: PPUSH
3585: LD_INT 2
3587: PPUSH
3588: CALL_OW 12
3592: ARRAY
3593: PUSH
3594: LD_INT 1
3596: PUSH
3597: LD_INT 3
3599: PUSH
3600: LD_INT 46
3602: PUSH
3603: LD_INT 47
3605: PUSH
3606: LD_INT 45
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: LIST
3613: PUSH
3614: LD_INT 1
3616: PPUSH
3617: LD_INT 3
3619: PPUSH
3620: CALL_OW 12
3624: ARRAY
3625: PUSH
3626: EMPTY
3627: LIST
3628: LIST
3629: LIST
3630: LIST
3631: PPUSH
3632: CALL_OW 2
3636: ST_TO_ADDR
3637: GO 3550
3639: POP
3640: POP
// p := 1 ;
3641: LD_ADDR_VAR 0 2
3645: PUSH
3646: LD_INT 1
3648: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
3649: LD_VAR 0 3
3653: PPUSH
3654: LD_VAR 0 4
3658: PPUSH
3659: CALL 81111 0 2
// repeat wait ( 0 0$1 ) ;
3663: LD_INT 35
3665: PPUSH
3666: CALL_OW 67
// p := Inc ( p ) ;
3670: LD_ADDR_VAR 0 2
3674: PUSH
3675: LD_VAR 0 2
3679: PPUSH
3680: CALL 54132 0 1
3684: ST_TO_ADDR
// until MC_GetVehicles ( base , true ) >= amount or p >= 100 ;
3685: LD_VAR 0 3
3689: PPUSH
3690: LD_INT 1
3692: PPUSH
3693: CALL 82529 0 2
3697: PUSH
3698: LD_VAR 0 8
3702: GREATEREQUAL
3703: PUSH
3704: LD_VAR 0 2
3708: PUSH
3709: LD_INT 100
3711: GREATEREQUAL
3712: OR
3713: IFFALSE 3663
// wait ( 0 0$30 ) ;
3715: LD_INT 1050
3717: PPUSH
3718: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3722: LD_ADDR_VAR 0 6
3726: PUSH
3727: LD_INT 71
3729: PUSH
3730: LD_INT 19
3732: PUSH
3733: EMPTY
3734: LIST
3735: LIST
3736: PUSH
3737: LD_INT 91
3739: PUSH
3740: LD_INT 67
3742: PUSH
3743: EMPTY
3744: LIST
3745: LIST
3746: PUSH
3747: LD_INT 52
3749: PUSH
3750: LD_INT 44
3752: PUSH
3753: EMPTY
3754: LIST
3755: LIST
3756: PUSH
3757: LD_INT 68
3759: PUSH
3760: LD_INT 48
3762: PUSH
3763: EMPTY
3764: LIST
3765: LIST
3766: PUSH
3767: EMPTY
3768: LIST
3769: LIST
3770: LIST
3771: LIST
3772: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3773: LD_ADDR_VAR 0 7
3777: PUSH
3778: LD_EXP 80
3782: PUSH
3783: LD_VAR 0 3
3787: ARRAY
3788: PUSH
3789: LD_EXP 80
3793: PUSH
3794: LD_VAR 0 3
3798: ARRAY
3799: PPUSH
3800: LD_INT 2
3802: PUSH
3803: LD_INT 34
3805: PUSH
3806: LD_INT 51
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: PUSH
3813: LD_INT 34
3815: PUSH
3816: LD_INT 52
3818: PUSH
3819: EMPTY
3820: LIST
3821: LIST
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: LIST
3827: PPUSH
3828: CALL_OW 72
3832: DIFF
3833: ST_TO_ADDR
// if not attackers then
3834: LD_VAR 0 7
3838: NOT
3839: IFFALSE 3843
// exit ;
3841: GO 4082
// ru_attackers := attackers ;
3843: LD_ADDR_EXP 54
3847: PUSH
3848: LD_VAR 0 7
3852: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3853: LD_ADDR_EXP 80
3857: PUSH
3858: LD_EXP 80
3862: PPUSH
3863: LD_VAR 0 3
3867: PPUSH
3868: LD_EXP 80
3872: PUSH
3873: LD_VAR 0 3
3877: ARRAY
3878: PUSH
3879: LD_VAR 0 7
3883: DIFF
3884: PPUSH
3885: CALL_OW 1
3889: ST_TO_ADDR
// for i = 1 to attackers do
3890: LD_ADDR_VAR 0 1
3894: PUSH
3895: DOUBLE
3896: LD_INT 1
3898: DEC
3899: ST_TO_ADDR
3900: LD_VAR 0 7
3904: PUSH
3905: FOR_TO
3906: IFFALSE 3983
// begin case i mod 3 of 0 :
3908: LD_VAR 0 1
3912: PUSH
3913: LD_INT 3
3915: MOD
3916: PUSH
3917: LD_INT 0
3919: DOUBLE
3920: EQUAL
3921: IFTRUE 3925
3923: GO 3928
3925: POP
// ; 1 :
3926: GO 3981
3928: LD_INT 1
3930: DOUBLE
3931: EQUAL
3932: IFTRUE 3936
3934: GO 3954
3936: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3937: LD_VAR 0 1
3941: PPUSH
3942: LD_INT 32
3944: PPUSH
3945: LD_INT 49
3947: PPUSH
3948: CALL_OW 114
3952: GO 3981
3954: LD_INT 2
3956: DOUBLE
3957: EQUAL
3958: IFTRUE 3962
3960: GO 3980
3962: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3963: LD_VAR 0 1
3967: PPUSH
3968: LD_INT 117
3970: PPUSH
3971: LD_INT 107
3973: PPUSH
3974: CALL_OW 114
3978: GO 3981
3980: POP
// end ;
3981: GO 3905
3983: POP
3984: POP
// p := 0 ;
3985: LD_ADDR_VAR 0 2
3989: PUSH
3990: LD_INT 0
3992: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3993: LD_INT 35
3995: PPUSH
3996: CALL_OW 67
// p := Inc ( p ) ;
4000: LD_ADDR_VAR 0 2
4004: PUSH
4005: LD_VAR 0 2
4009: PPUSH
4010: CALL 54132 0 1
4014: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
4015: LD_VAR 0 7
4019: PPUSH
4020: LD_INT 60
4022: PUSH
4023: EMPTY
4024: LIST
4025: PPUSH
4026: CALL_OW 72
4030: NOT
4031: PUSH
4032: LD_VAR 0 2
4036: PUSH
4037: LD_INT 30
4039: GREATER
4040: OR
4041: IFFALSE 3993
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
4043: LD_VAR 0 3
4047: PPUSH
4048: LD_VAR 0 7
4052: PPUSH
4053: LD_VAR 0 6
4057: PPUSH
4058: LD_VAR 0 5
4062: PPUSH
4063: CALL 81296 0 4
// if not first_attack then
4067: LD_EXP 7
4071: NOT
4072: IFFALSE 4082
// first_attack := true ;
4074: LD_ADDR_EXP 7
4078: PUSH
4079: LD_INT 1
4081: ST_TO_ADDR
// end ; end_of_file
4082: PPOPN 8
4084: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
4085: LD_INT 0
4087: PPUSH
4088: PPUSH
4089: PPUSH
4090: PPUSH
4091: PPUSH
4092: PPUSH
4093: PPUSH
// uc_side := 2 ;
4094: LD_ADDR_OWVAR 20
4098: PUSH
4099: LD_INT 2
4101: ST_TO_ADDR
// uc_nation := 2 ;
4102: LD_ADDR_OWVAR 21
4106: PUSH
4107: LD_INT 2
4109: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
4110: LD_ADDR_EXP 57
4114: PUSH
4115: LD_STRING Abdul
4117: PPUSH
4118: CALL_OW 25
4122: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4123: LD_EXP 57
4127: PPUSH
4128: LD_INT 11
4130: PPUSH
4131: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4135: LD_EXP 57
4139: PPUSH
4140: LD_INT 1
4142: PPUSH
4143: CALL_OW 52
// vc_chassis := 31 ;
4147: LD_ADDR_OWVAR 37
4151: PUSH
4152: LD_INT 31
4154: ST_TO_ADDR
// vc_control := control_rider ;
4155: LD_ADDR_OWVAR 38
4159: PUSH
4160: LD_INT 4
4162: ST_TO_ADDR
// mastodont := CreateVehicle ;
4163: LD_ADDR_EXP 58
4167: PUSH
4168: CALL_OW 45
4172: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4173: LD_EXP 58
4177: PPUSH
4178: LD_INT 153
4180: PPUSH
4181: LD_INT 71
4183: PPUSH
4184: LD_INT 0
4186: PPUSH
4187: CALL_OW 48
// InitVc ;
4191: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
4195: LD_ADDR_EXP 55
4199: PUSH
4200: LD_INT 1
4202: PPUSH
4203: LD_INT 3
4205: PPUSH
4206: LD_STRING 
4208: PPUSH
4209: LD_INT 7
4211: PUSH
4212: LD_INT 8
4214: PUSH
4215: LD_INT 9
4217: PUSH
4218: LD_INT 10
4220: PUSH
4221: EMPTY
4222: LIST
4223: LIST
4224: LIST
4225: LIST
4226: PUSH
4227: LD_OWVAR 67
4231: ARRAY
4232: PPUSH
4233: LD_INT 5000
4235: PUSH
4236: LD_INT 1000
4238: PUSH
4239: LD_INT 300
4241: PUSH
4242: EMPTY
4243: LIST
4244: LIST
4245: LIST
4246: PPUSH
4247: LD_INT 18
4249: PUSH
4250: LD_INT 5
4252: PUSH
4253: LD_INT 6
4255: PUSH
4256: LD_INT 9
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: LIST
4263: LIST
4264: PPUSH
4265: CALL 23763 0 6
4269: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4270: LD_ADDR_EXP 61
4274: PUSH
4275: LD_EXP 61
4279: PPUSH
4280: LD_INT 1
4282: PPUSH
4283: LD_EXP 55
4287: PPUSH
4288: CALL_OW 1
4292: ST_TO_ADDR
// tmp := [ ] ;
4293: LD_ADDR_VAR 0 4
4297: PUSH
4298: EMPTY
4299: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
4300: LD_ADDR_OWVAR 37
4304: PUSH
4305: LD_INT 13
4307: ST_TO_ADDR
// vc_engine := engine_siberite ;
4308: LD_ADDR_OWVAR 39
4312: PUSH
4313: LD_INT 3
4315: ST_TO_ADDR
// vc_control := control_manual ;
4316: LD_ADDR_OWVAR 38
4320: PUSH
4321: LD_INT 1
4323: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4324: LD_ADDR_OWVAR 40
4328: PUSH
4329: LD_INT 31
4331: ST_TO_ADDR
// for i = 1 to 3 do
4332: LD_ADDR_VAR 0 2
4336: PUSH
4337: DOUBLE
4338: LD_INT 1
4340: DEC
4341: ST_TO_ADDR
4342: LD_INT 3
4344: PUSH
4345: FOR_TO
4346: IFFALSE 4594
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4348: LD_ADDR_VAR 0 5
4352: PUSH
4353: LD_INT 153
4355: PUSH
4356: LD_INT 71
4358: PUSH
4359: EMPTY
4360: LIST
4361: LIST
4362: PUSH
4363: LD_INT 155
4365: PUSH
4366: LD_INT 81
4368: PUSH
4369: EMPTY
4370: LIST
4371: LIST
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PUSH
4377: LD_VAR 0 2
4381: PUSH
4382: LD_INT 2
4384: MOD
4385: PUSH
4386: LD_INT 1
4388: PLUS
4389: ARRAY
4390: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4391: LD_INT 0
4393: PPUSH
4394: LD_INT 3
4396: PPUSH
4397: LD_INT 7
4399: PUSH
4400: LD_INT 8
4402: PUSH
4403: LD_INT 10
4405: PUSH
4406: LD_INT 10
4408: PUSH
4409: EMPTY
4410: LIST
4411: LIST
4412: LIST
4413: LIST
4414: PUSH
4415: LD_OWVAR 67
4419: ARRAY
4420: PPUSH
4421: CALL_OW 380
// un := CreateVehicle ;
4425: LD_ADDR_VAR 0 6
4429: PUSH
4430: CALL_OW 45
4434: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4435: LD_VAR 0 6
4439: PPUSH
4440: LD_INT 0
4442: PPUSH
4443: LD_INT 5
4445: PPUSH
4446: CALL_OW 12
4450: PPUSH
4451: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4455: LD_VAR 0 6
4459: PPUSH
4460: LD_VAR 0 5
4464: PUSH
4465: LD_INT 1
4467: ARRAY
4468: PPUSH
4469: LD_VAR 0 5
4473: PUSH
4474: LD_INT 2
4476: ARRAY
4477: PPUSH
4478: LD_INT 6
4480: PPUSH
4481: LD_INT 0
4483: PPUSH
4484: CALL_OW 50
// un2 := CreateHuman ;
4488: LD_ADDR_VAR 0 7
4492: PUSH
4493: CALL_OW 44
4497: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4498: LD_VAR 0 7
4502: PPUSH
4503: LD_VAR 0 6
4507: PPUSH
4508: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4512: LD_ADDR_EXP 61
4516: PUSH
4517: LD_EXP 61
4521: PPUSH
4522: LD_INT 1
4524: PUSH
4525: LD_EXP 61
4529: PUSH
4530: LD_INT 1
4532: ARRAY
4533: PUSH
4534: LD_INT 1
4536: PLUS
4537: PUSH
4538: EMPTY
4539: LIST
4540: LIST
4541: PPUSH
4542: LD_VAR 0 6
4546: PPUSH
4547: CALL 20441 0 3
4551: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4552: LD_ADDR_EXP 61
4556: PUSH
4557: LD_EXP 61
4561: PPUSH
4562: LD_INT 1
4564: PUSH
4565: LD_EXP 61
4569: PUSH
4570: LD_INT 1
4572: ARRAY
4573: PUSH
4574: LD_INT 1
4576: PLUS
4577: PUSH
4578: EMPTY
4579: LIST
4580: LIST
4581: PPUSH
4582: LD_VAR 0 7
4586: PPUSH
4587: CALL 20441 0 3
4591: ST_TO_ADDR
// end ;
4592: GO 4345
4594: POP
4595: POP
// for i = 1 to 5 do
4596: LD_ADDR_VAR 0 2
4600: PUSH
4601: DOUBLE
4602: LD_INT 1
4604: DEC
4605: ST_TO_ADDR
4606: LD_INT 5
4608: PUSH
4609: FOR_TO
4610: IFFALSE 4703
// begin PrepareVehicle ( ar_medium_trike , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4612: LD_INT 13
4614: PPUSH
4615: LD_INT 3
4617: PPUSH
4618: LD_INT 1
4620: PPUSH
4621: LD_INT 25
4623: PUSH
4624: LD_INT 28
4626: PUSH
4627: LD_INT 28
4629: PUSH
4630: LD_INT 26
4632: PUSH
4633: EMPTY
4634: LIST
4635: LIST
4636: LIST
4637: LIST
4638: PUSH
4639: LD_VAR 0 2
4643: PUSH
4644: LD_INT 4
4646: MOD
4647: PUSH
4648: LD_INT 1
4650: PLUS
4651: ARRAY
4652: PPUSH
4653: LD_INT 100
4655: PPUSH
4656: CALL 20319 0 5
// veh := CreateVehicle ;
4660: LD_ADDR_VAR 0 3
4664: PUSH
4665: CALL_OW 45
4669: ST_TO_ADDR
// tmp := tmp ^ veh ;
4670: LD_ADDR_VAR 0 4
4674: PUSH
4675: LD_VAR 0 4
4679: PUSH
4680: LD_VAR 0 3
4684: ADD
4685: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4686: LD_VAR 0 3
4690: PPUSH
4691: LD_INT 1
4693: PPUSH
4694: LD_INT 0
4696: PPUSH
4697: CALL_OW 49
// end ;
4701: GO 4609
4703: POP
4704: POP
// arabian_guard := tmp ;
4705: LD_ADDR_EXP 56
4709: PUSH
4710: LD_VAR 0 4
4714: ST_TO_ADDR
// end ;
4715: LD_VAR 0 1
4719: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4720: LD_INT 22
4722: PUSH
4723: LD_INT 7
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_INT 91
4732: PUSH
4733: LD_INT 1
4735: PUSH
4736: LD_INT 12
4738: PUSH
4739: EMPTY
4740: LIST
4741: LIST
4742: LIST
4743: PUSH
4744: EMPTY
4745: LIST
4746: LIST
4747: PPUSH
4748: CALL_OW 69
4752: PUSH
4753: LD_EXP 58
4757: PPUSH
4758: CALL_OW 256
4762: PUSH
4763: LD_INT 990
4765: LESS
4766: OR
4767: PUSH
4768: LD_EXP 57
4772: PPUSH
4773: CALL_OW 256
4777: PUSH
4778: LD_INT 990
4780: LESS
4781: OR
4782: IFFALSE 4925
4784: GO 4786
4786: DISABLE
// begin if IsInUnit ( Abdul ) then
4787: LD_EXP 57
4791: PPUSH
4792: CALL_OW 310
4796: IFFALSE 4807
// ComExitBuilding ( Abdul ) ;
4798: LD_EXP 57
4802: PPUSH
4803: CALL_OW 122
// if Mastodont then
4807: LD_EXP 58
4811: IFFALSE 4828
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4813: LD_EXP 58
4817: PPUSH
4818: LD_INT 205
4820: PPUSH
4821: LD_INT 132
4823: PPUSH
4824: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4828: LD_EXP 57
4832: PPUSH
4833: LD_INT 205
4835: PPUSH
4836: LD_INT 132
4838: PPUSH
4839: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4843: LD_INT 35
4845: PPUSH
4846: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4850: LD_EXP 57
4854: PPUSH
4855: LD_INT 21
4857: PPUSH
4858: CALL_OW 308
4862: IFFALSE 4843
// RemoveUnit ( Abdul ) ;
4864: LD_EXP 57
4868: PPUSH
4869: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4873: LD_INT 35
4875: PPUSH
4876: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4880: LD_EXP 58
4884: PPUSH
4885: LD_INT 21
4887: PPUSH
4888: CALL_OW 308
4892: PUSH
4893: LD_EXP 58
4897: PPUSH
4898: CALL_OW 301
4902: OR
4903: IFFALSE 4873
// if IsOk ( Mastodont ) then
4905: LD_EXP 58
4909: PPUSH
4910: CALL_OW 302
4914: IFFALSE 4925
// RemoveUnit ( Mastodont ) ;
4916: LD_EXP 58
4920: PPUSH
4921: CALL_OW 64
// end ;
4925: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4926: LD_EXP 57
4930: PPUSH
4931: CALL_OW 301
4935: PUSH
4936: LD_INT 22
4938: PUSH
4939: LD_INT 2
4941: PUSH
4942: EMPTY
4943: LIST
4944: LIST
4945: PUSH
4946: LD_INT 2
4948: PUSH
4949: LD_INT 25
4951: PUSH
4952: LD_INT 1
4954: PUSH
4955: EMPTY
4956: LIST
4957: LIST
4958: PUSH
4959: LD_INT 25
4961: PUSH
4962: LD_INT 2
4964: PUSH
4965: EMPTY
4966: LIST
4967: LIST
4968: PUSH
4969: LD_INT 25
4971: PUSH
4972: LD_INT 3
4974: PUSH
4975: EMPTY
4976: LIST
4977: LIST
4978: PUSH
4979: LD_INT 25
4981: PUSH
4982: LD_INT 4
4984: PUSH
4985: EMPTY
4986: LIST
4987: LIST
4988: PUSH
4989: LD_INT 25
4991: PUSH
4992: LD_INT 8
4994: PUSH
4995: EMPTY
4996: LIST
4997: LIST
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: LIST
5003: LIST
5004: LIST
5005: LIST
5006: PUSH
5007: EMPTY
5008: LIST
5009: LIST
5010: PPUSH
5011: CALL_OW 69
5015: PUSH
5016: LD_INT 16
5018: PUSH
5019: LD_INT 19
5021: PUSH
5022: LD_INT 22
5024: PUSH
5025: LD_INT 22
5027: PUSH
5028: EMPTY
5029: LIST
5030: LIST
5031: LIST
5032: LIST
5033: PUSH
5034: LD_OWVAR 67
5038: ARRAY
5039: LESS
5040: OR
5041: IFFALSE 5714
5043: GO 5045
5045: DISABLE
5046: LD_INT 0
5048: PPUSH
5049: PPUSH
5050: PPUSH
5051: PPUSH
5052: PPUSH
5053: PPUSH
// begin MC_Kill ( 1 ) ;
5054: LD_INT 1
5056: PPUSH
5057: CALL 57100 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
5061: LD_ADDR_VAR 0 2
5065: PUSH
5066: LD_INT 22
5068: PUSH
5069: LD_INT 2
5071: PUSH
5072: EMPTY
5073: LIST
5074: LIST
5075: PUSH
5076: LD_INT 2
5078: PUSH
5079: LD_INT 25
5081: PUSH
5082: LD_INT 1
5084: PUSH
5085: EMPTY
5086: LIST
5087: LIST
5088: PUSH
5089: LD_INT 25
5091: PUSH
5092: LD_INT 2
5094: PUSH
5095: EMPTY
5096: LIST
5097: LIST
5098: PUSH
5099: LD_INT 25
5101: PUSH
5102: LD_INT 3
5104: PUSH
5105: EMPTY
5106: LIST
5107: LIST
5108: PUSH
5109: LD_INT 25
5111: PUSH
5112: LD_INT 4
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 25
5121: PUSH
5122: LD_INT 8
5124: PUSH
5125: EMPTY
5126: LIST
5127: LIST
5128: PUSH
5129: EMPTY
5130: LIST
5131: LIST
5132: LIST
5133: LIST
5134: LIST
5135: LIST
5136: PUSH
5137: EMPTY
5138: LIST
5139: LIST
5140: PPUSH
5141: CALL_OW 69
5145: ST_TO_ADDR
// for i in tmp do
5146: LD_ADDR_VAR 0 5
5150: PUSH
5151: LD_VAR 0 2
5155: PUSH
5156: FOR_IN
5157: IFFALSE 5173
// SetTag ( i , 10 ) ;
5159: LD_VAR 0 5
5163: PPUSH
5164: LD_INT 10
5166: PPUSH
5167: CALL_OW 109
5171: GO 5156
5173: POP
5174: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5175: LD_ADDR_VAR 0 3
5179: PUSH
5180: LD_INT 22
5182: PUSH
5183: LD_INT 2
5185: PUSH
5186: EMPTY
5187: LIST
5188: LIST
5189: PUSH
5190: LD_INT 21
5192: PUSH
5193: LD_INT 1
5195: PUSH
5196: EMPTY
5197: LIST
5198: LIST
5199: PUSH
5200: EMPTY
5201: LIST
5202: LIST
5203: PPUSH
5204: CALL_OW 69
5208: PUSH
5209: LD_VAR 0 2
5213: DIFF
5214: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5215: LD_ADDR_VAR 0 1
5219: PUSH
5220: LD_INT 22
5222: PUSH
5223: LD_INT 2
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: PUSH
5230: LD_INT 21
5232: PUSH
5233: LD_INT 2
5235: PUSH
5236: EMPTY
5237: LIST
5238: LIST
5239: PUSH
5240: LD_INT 24
5242: PUSH
5243: LD_INT 300
5245: PUSH
5246: EMPTY
5247: LIST
5248: LIST
5249: PUSH
5250: EMPTY
5251: LIST
5252: LIST
5253: LIST
5254: PPUSH
5255: CALL_OW 69
5259: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5260: LD_ADDR_VAR 0 4
5264: PUSH
5265: LD_VAR 0 1
5269: PPUSH
5270: LD_INT 33
5272: PUSH
5273: LD_INT 1
5275: PUSH
5276: EMPTY
5277: LIST
5278: LIST
5279: PUSH
5280: LD_INT 58
5282: PUSH
5283: EMPTY
5284: LIST
5285: PUSH
5286: EMPTY
5287: LIST
5288: LIST
5289: PPUSH
5290: CALL_OW 72
5294: ST_TO_ADDR
// for i in tmp do
5295: LD_ADDR_VAR 0 5
5299: PUSH
5300: LD_VAR 0 2
5304: PUSH
5305: FOR_IN
5306: IFFALSE 5490
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5308: LD_VAR 0 5
5312: PUSH
5313: LD_INT 55
5315: PUSH
5316: EMPTY
5317: LIST
5318: PPUSH
5319: CALL_OW 69
5323: IN
5324: IFFALSE 5343
// begin AddComMoveXY ( i , 209 , 132 ) ;
5326: LD_VAR 0 5
5330: PPUSH
5331: LD_INT 209
5333: PPUSH
5334: LD_INT 132
5336: PPUSH
5337: CALL_OW 171
// continue ;
5341: GO 5305
// end ; if IsInUnit ( i ) then
5343: LD_VAR 0 5
5347: PPUSH
5348: CALL_OW 310
5352: IFFALSE 5370
// begin ComExitBuilding ( i ) ;
5354: LD_VAR 0 5
5358: PPUSH
5359: CALL_OW 122
// wait ( 3 ) ;
5363: LD_INT 3
5365: PPUSH
5366: CALL_OW 67
// end ; if tmp_empty then
5370: LD_VAR 0 4
5374: IFFALSE 5473
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5376: LD_VAR 0 5
5380: PPUSH
5381: LD_VAR 0 4
5385: PPUSH
5386: LD_VAR 0 5
5390: PPUSH
5391: CALL_OW 74
5395: PPUSH
5396: CALL_OW 296
5400: PUSH
5401: LD_INT 25
5403: LESS
5404: IFFALSE 5473
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5406: LD_ADDR_VAR 0 6
5410: PUSH
5411: LD_VAR 0 4
5415: PPUSH
5416: LD_VAR 0 5
5420: PPUSH
5421: CALL_OW 74
5425: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5426: LD_VAR 0 5
5430: PPUSH
5431: LD_VAR 0 6
5435: PPUSH
5436: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5440: LD_VAR 0 5
5444: PPUSH
5445: LD_INT 209
5447: PPUSH
5448: LD_INT 132
5450: PPUSH
5451: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5455: LD_ADDR_VAR 0 4
5459: PUSH
5460: LD_VAR 0 4
5464: PUSH
5465: LD_VAR 0 6
5469: DIFF
5470: ST_TO_ADDR
// continue ;
5471: GO 5305
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5473: LD_VAR 0 5
5477: PPUSH
5478: LD_INT 201
5480: PPUSH
5481: LD_INT 132
5483: PPUSH
5484: CALL_OW 171
// end ;
5488: GO 5305
5490: POP
5491: POP
// for i in tmp_ape do
5492: LD_ADDR_VAR 0 5
5496: PUSH
5497: LD_VAR 0 3
5501: PUSH
5502: FOR_IN
5503: IFFALSE 5542
// begin if IsInUnit ( i ) then
5505: LD_VAR 0 5
5509: PPUSH
5510: CALL_OW 310
5514: IFFALSE 5525
// ComExitBuilding ( i ) ;
5516: LD_VAR 0 5
5520: PPUSH
5521: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5525: LD_VAR 0 5
5529: PPUSH
5530: LD_INT 201
5532: PPUSH
5533: LD_INT 132
5535: PPUSH
5536: CALL_OW 171
// end ;
5540: GO 5502
5542: POP
5543: POP
// repeat wait ( 0 0$1 ) ;
5544: LD_INT 35
5546: PPUSH
5547: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5551: LD_ADDR_VAR 0 5
5555: PUSH
5556: LD_VAR 0 2
5560: PUSH
5561: LD_VAR 0 3
5565: UNION
5566: PUSH
5567: LD_VAR 0 1
5571: UNION
5572: PUSH
5573: FOR_IN
5574: IFFALSE 5605
// if not HasTask ( i ) then
5576: LD_VAR 0 5
5580: PPUSH
5581: CALL_OW 314
5585: NOT
5586: IFFALSE 5603
// ComMoveXY ( i , 201 , 132 ) ;
5588: LD_VAR 0 5
5592: PPUSH
5593: LD_INT 201
5595: PPUSH
5596: LD_INT 132
5598: PPUSH
5599: CALL_OW 111
5603: GO 5573
5605: POP
5606: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5607: LD_INT 21
5609: PPUSH
5610: LD_INT 22
5612: PUSH
5613: LD_INT 2
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: PPUSH
5620: CALL_OW 70
5624: IFFALSE 5665
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5626: LD_ADDR_VAR 0 5
5630: PUSH
5631: LD_INT 21
5633: PPUSH
5634: LD_INT 22
5636: PUSH
5637: LD_INT 2
5639: PUSH
5640: EMPTY
5641: LIST
5642: LIST
5643: PPUSH
5644: CALL_OW 70
5648: PUSH
5649: FOR_IN
5650: IFFALSE 5663
// RemoveUnit ( i ) ;
5652: LD_VAR 0 5
5656: PPUSH
5657: CALL_OW 64
5661: GO 5649
5663: POP
5664: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5665: LD_INT 22
5667: PUSH
5668: LD_INT 2
5670: PUSH
5671: EMPTY
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 2
5677: PUSH
5678: LD_INT 21
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: EMPTY
5685: LIST
5686: LIST
5687: PUSH
5688: LD_INT 21
5690: PUSH
5691: LD_INT 2
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: LIST
5702: PUSH
5703: EMPTY
5704: LIST
5705: LIST
5706: PPUSH
5707: CALL_OW 69
5711: NOT
5712: IFFALSE 5544
// end ;
5714: PPOPN 6
5716: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5717: LD_EXP 9
5721: PUSH
5722: LD_INT 92
5724: PPUSH
5725: LD_INT 40
5727: PPUSH
5728: CALL_OW 428
5732: PPUSH
5733: CALL_OW 266
5737: PUSH
5738: LD_INT 30
5740: EQUAL
5741: AND
5742: IFFALSE 5938
5744: GO 5746
5746: DISABLE
5747: LD_INT 0
5749: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5750: LD_ADDR_VAR 0 1
5754: PUSH
5755: LD_EXP 61
5759: PUSH
5760: LD_INT 1
5762: ARRAY
5763: PPUSH
5764: LD_INT 25
5766: PUSH
5767: LD_INT 4
5769: PUSH
5770: EMPTY
5771: LIST
5772: LIST
5773: PPUSH
5774: CALL_OW 72
5778: ST_TO_ADDR
// if not sci then
5779: LD_VAR 0 1
5783: NOT
5784: IFFALSE 5788
// exit ;
5786: GO 5938
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5788: LD_ADDR_EXP 61
5792: PUSH
5793: LD_EXP 61
5797: PPUSH
5798: LD_INT 1
5800: PPUSH
5801: LD_EXP 61
5805: PUSH
5806: LD_INT 1
5808: ARRAY
5809: PUSH
5810: LD_VAR 0 1
5814: PUSH
5815: LD_INT 1
5817: ARRAY
5818: DIFF
5819: PPUSH
5820: CALL_OW 1
5824: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5825: LD_VAR 0 1
5829: PUSH
5830: LD_INT 1
5832: ARRAY
5833: PPUSH
5834: CALL_OW 310
5838: IFFALSE 5853
// ComExitBuilding ( sci [ 1 ] ) ;
5840: LD_VAR 0 1
5844: PUSH
5845: LD_INT 1
5847: ARRAY
5848: PPUSH
5849: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5853: LD_INT 2
5855: PPUSH
5856: LD_INT 105
5858: PPUSH
5859: LD_INT 14
5861: PPUSH
5862: LD_INT 20
5864: PPUSH
5865: CALL 21337 0 4
5869: PUSH
5870: LD_INT 4
5872: ARRAY
5873: PUSH
5874: LD_INT 10
5876: LESS
5877: IFFALSE 5900
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5879: LD_VAR 0 1
5883: PUSH
5884: LD_INT 1
5886: ARRAY
5887: PPUSH
5888: LD_INT 105
5890: PPUSH
5891: LD_INT 14
5893: PPUSH
5894: CALL_OW 171
5898: GO 5919
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5900: LD_VAR 0 1
5904: PUSH
5905: LD_INT 1
5907: ARRAY
5908: PPUSH
5909: LD_INT 118
5911: PPUSH
5912: LD_INT 77
5914: PPUSH
5915: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5919: LD_VAR 0 1
5923: PUSH
5924: LD_INT 1
5926: ARRAY
5927: PPUSH
5928: LD_INT 92
5930: PPUSH
5931: LD_INT 40
5933: PPUSH
5934: CALL_OW 218
// end ;
5938: PPOPN 1
5940: END
// every 9 9$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , un , base , tmp , flags , _target , attackers , p ;
5941: LD_INT 1
5943: PPUSH
5944: CALL_OW 302
5948: PUSH
5949: LD_EXP 9
5953: AND
5954: IFFALSE 6742
5956: GO 5958
5958: DISABLE
5959: LD_INT 0
5961: PPUSH
5962: PPUSH
5963: PPUSH
5964: PPUSH
5965: PPUSH
5966: PPUSH
5967: PPUSH
5968: PPUSH
// begin enable ;
5969: ENABLE
// base := 1 ;
5970: LD_ADDR_VAR 0 3
5974: PUSH
5975: LD_INT 1
5977: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5978: LD_ADDR_VAR 0 5
5982: PUSH
5983: LD_INT 0
5985: PUSH
5986: LD_INT 0
5988: PUSH
5989: LD_INT 0
5991: PUSH
5992: LD_INT 0
5994: PUSH
5995: LD_INT 0
5997: PUSH
5998: LD_INT 0
6000: PUSH
6001: LD_INT 0
6003: PUSH
6004: LD_INT 0
6006: PUSH
6007: LD_INT 1
6009: PUSH
6010: LD_INT 0
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: LIST
6023: LIST
6024: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
6025: LD_ADDR_VAR 0 4
6029: PUSH
6030: LD_INT 13
6032: PUSH
6033: LD_INT 1
6035: PUSH
6036: LD_INT 2
6038: PUSH
6039: LD_INT 26
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 13
6050: PUSH
6051: LD_INT 1
6053: PUSH
6054: LD_INT 2
6056: PUSH
6057: LD_INT 28
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 13
6068: PUSH
6069: LD_INT 1
6071: PUSH
6072: LD_INT 2
6074: PUSH
6075: LD_INT 29
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: EMPTY
6085: LIST
6086: LIST
6087: LIST
6088: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6089: LD_ADDR_VAR 0 1
6093: PUSH
6094: DOUBLE
6095: LD_INT 1
6097: DEC
6098: ST_TO_ADDR
6099: LD_OWVAR 67
6103: PUSH
6104: LD_OWVAR 1
6108: PUSH
6109: LD_INT 21000
6111: DIV
6112: PLUS
6113: PUSH
6114: FOR_TO
6115: IFFALSE 6188
// tmp := Insert ( tmp , tmp + 1 , [ ar_medium_trike , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6117: LD_ADDR_VAR 0 4
6121: PUSH
6122: LD_VAR 0 4
6126: PPUSH
6127: LD_VAR 0 4
6131: PUSH
6132: LD_INT 1
6134: PLUS
6135: PPUSH
6136: LD_INT 13
6138: PUSH
6139: LD_INT 1
6141: PUSH
6142: LD_INT 2
6144: PUSH
6145: LD_INT 28
6147: PUSH
6148: LD_INT 29
6150: PUSH
6151: LD_INT 25
6153: PUSH
6154: LD_INT 26
6156: PUSH
6157: EMPTY
6158: LIST
6159: LIST
6160: LIST
6161: LIST
6162: PUSH
6163: LD_INT 1
6165: PPUSH
6166: LD_INT 4
6168: PPUSH
6169: CALL_OW 12
6173: ARRAY
6174: PUSH
6175: EMPTY
6176: LIST
6177: LIST
6178: LIST
6179: LIST
6180: PPUSH
6181: CALL_OW 2
6185: ST_TO_ADDR
6186: GO 6114
6188: POP
6189: POP
// MC_InsertProduceList ( base , tmp ) ;
6190: LD_VAR 0 3
6194: PPUSH
6195: LD_VAR 0 4
6199: PPUSH
6200: CALL 81111 0 2
// wait ( 4 4$20 ) ;
6204: LD_INT 9100
6206: PPUSH
6207: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6211: LD_ADDR_VAR 0 6
6215: PUSH
6216: LD_INT 124
6218: PUSH
6219: LD_INT 85
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: PUSH
6226: LD_INT 90
6228: PUSH
6229: LD_INT 61
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: PUSH
6236: LD_INT 69
6238: PUSH
6239: LD_INT 48
6241: PUSH
6242: EMPTY
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 68
6248: PUSH
6249: LD_INT 48
6251: PUSH
6252: EMPTY
6253: LIST
6254: LIST
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6262: LD_ADDR_VAR 0 7
6266: PUSH
6267: LD_EXP 80
6271: PUSH
6272: LD_VAR 0 3
6276: ARRAY
6277: PUSH
6278: LD_EXP 80
6282: PUSH
6283: LD_VAR 0 3
6287: ARRAY
6288: PPUSH
6289: LD_INT 2
6291: PUSH
6292: LD_INT 34
6294: PUSH
6295: LD_INT 32
6297: PUSH
6298: EMPTY
6299: LIST
6300: LIST
6301: PUSH
6302: LD_INT 34
6304: PUSH
6305: LD_INT 88
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: PUSH
6312: EMPTY
6313: LIST
6314: LIST
6315: LIST
6316: PPUSH
6317: CALL_OW 72
6321: DIFF
6322: ST_TO_ADDR
// if rand ( 0 , 1 ) then
6323: LD_INT 0
6325: PPUSH
6326: LD_INT 1
6328: PPUSH
6329: CALL_OW 12
6333: IFFALSE 6483
// begin for i := 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
6335: LD_ADDR_VAR 0 1
6339: PUSH
6340: DOUBLE
6341: LD_INT 1
6343: DEC
6344: ST_TO_ADDR
6345: LD_INT 3
6347: PUSH
6348: LD_INT 4
6350: PUSH
6351: LD_INT 5
6353: PUSH
6354: LD_INT 6
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: LIST
6361: LIST
6362: PUSH
6363: LD_OWVAR 67
6367: ARRAY
6368: PUSH
6369: FOR_TO
6370: IFFALSE 6479
// begin uc_side := 2 ;
6372: LD_ADDR_OWVAR 20
6376: PUSH
6377: LD_INT 2
6379: ST_TO_ADDR
// uc_nation := 2 ;
6380: LD_ADDR_OWVAR 21
6384: PUSH
6385: LD_INT 2
6387: ST_TO_ADDR
// InitHc ;
6388: CALL_OW 19
// PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6392: LD_INT 0
6394: PPUSH
6395: LD_INT 15
6397: PUSH
6398: LD_INT 17
6400: PUSH
6401: EMPTY
6402: LIST
6403: LIST
6404: PUSH
6405: LD_INT 1
6407: PPUSH
6408: LD_INT 2
6410: PPUSH
6411: CALL_OW 12
6415: ARRAY
6416: PPUSH
6417: LD_INT 8
6419: PPUSH
6420: CALL_OW 380
// un := CreateHuman ;
6424: LD_ADDR_VAR 0 2
6428: PUSH
6429: CALL_OW 44
6433: ST_TO_ADDR
// SetDir ( un , 4 ) ;
6434: LD_VAR 0 2
6438: PPUSH
6439: LD_INT 4
6441: PPUSH
6442: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
6446: LD_VAR 0 2
6450: PPUSH
6451: LD_INT 23
6453: PPUSH
6454: LD_INT 0
6456: PPUSH
6457: CALL_OW 49
// attackers := attackers union un ;
6461: LD_ADDR_VAR 0 7
6465: PUSH
6466: LD_VAR 0 7
6470: PUSH
6471: LD_VAR 0 2
6475: UNION
6476: ST_TO_ADDR
// end ;
6477: GO 6369
6479: POP
6480: POP
// end else
6481: GO 6641
// begin for i := 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
6483: LD_ADDR_VAR 0 1
6487: PUSH
6488: DOUBLE
6489: LD_INT 1
6491: DEC
6492: ST_TO_ADDR
6493: LD_INT 2
6495: PUSH
6496: LD_INT 3
6498: PUSH
6499: LD_INT 4
6501: PUSH
6502: LD_INT 5
6504: PUSH
6505: EMPTY
6506: LIST
6507: LIST
6508: LIST
6509: LIST
6510: PUSH
6511: LD_OWVAR 67
6515: ARRAY
6516: PUSH
6517: FOR_TO
6518: IFFALSE 6639
// begin uc_side := 2 ;
6520: LD_ADDR_OWVAR 20
6524: PUSH
6525: LD_INT 2
6527: ST_TO_ADDR
// uc_nation := 2 ;
6528: LD_ADDR_OWVAR 21
6532: PUSH
6533: LD_INT 2
6535: ST_TO_ADDR
// InitHc ;
6536: CALL_OW 19
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_flame_thrower ] [ i mod 3 + 1 ] , 100 ) ;
6540: LD_INT 14
6542: PPUSH
6543: LD_INT 3
6545: PPUSH
6546: LD_INT 5
6548: PPUSH
6549: LD_INT 29
6551: PUSH
6552: LD_INT 29
6554: PUSH
6555: LD_INT 26
6557: PUSH
6558: EMPTY
6559: LIST
6560: LIST
6561: LIST
6562: PUSH
6563: LD_VAR 0 1
6567: PUSH
6568: LD_INT 3
6570: MOD
6571: PUSH
6572: LD_INT 1
6574: PLUS
6575: ARRAY
6576: PPUSH
6577: LD_INT 100
6579: PPUSH
6580: CALL 20319 0 5
// un := CreateVehicle ;
6584: LD_ADDR_VAR 0 2
6588: PUSH
6589: CALL_OW 45
6593: ST_TO_ADDR
// SetDir ( un , 4 ) ;
6594: LD_VAR 0 2
6598: PPUSH
6599: LD_INT 4
6601: PPUSH
6602: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
6606: LD_VAR 0 2
6610: PPUSH
6611: LD_INT 23
6613: PPUSH
6614: LD_INT 0
6616: PPUSH
6617: CALL_OW 49
// attackers := attackers union un ;
6621: LD_ADDR_VAR 0 7
6625: PUSH
6626: LD_VAR 0 7
6630: PUSH
6631: LD_VAR 0 2
6635: UNION
6636: ST_TO_ADDR
// end ;
6637: GO 6517
6639: POP
6640: POP
// end ; if not attackers then
6641: LD_VAR 0 7
6645: NOT
6646: IFFALSE 6650
// exit ;
6648: GO 6742
// ar_attackers := attackers ;
6650: LD_ADDR_EXP 11
6654: PUSH
6655: LD_VAR 0 7
6659: ST_TO_ADDR
// p := 0 ;
6660: LD_ADDR_VAR 0 8
6664: PUSH
6665: LD_INT 0
6667: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6668: LD_INT 35
6670: PPUSH
6671: CALL_OW 67
// p := Inc ( p ) ;
6675: LD_ADDR_VAR 0 8
6679: PUSH
6680: LD_VAR 0 8
6684: PPUSH
6685: CALL 54132 0 1
6689: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
6690: LD_VAR 0 7
6694: PPUSH
6695: LD_INT 60
6697: PUSH
6698: EMPTY
6699: LIST
6700: PPUSH
6701: CALL_OW 72
6705: NOT
6706: PUSH
6707: LD_VAR 0 8
6711: PUSH
6712: LD_INT 30
6714: GREATER
6715: OR
6716: IFFALSE 6668
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6718: LD_VAR 0 3
6722: PPUSH
6723: LD_VAR 0 7
6727: PPUSH
6728: LD_VAR 0 6
6732: PPUSH
6733: LD_VAR 0 5
6737: PPUSH
6738: CALL 81296 0 4
// end ;
6742: PPOPN 8
6744: END
// every 5 5$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) do var i , base , tmp , flags , _target , attackers , un , p ;
6745: LD_INT 1
6747: PPUSH
6748: CALL_OW 302
6752: PUSH
6753: LD_EXP 9
6757: AND
6758: PUSH
6759: LD_EXP 51
6763: PPUSH
6764: LD_INT 22
6766: PPUSH
6767: CALL_OW 308
6771: AND
6772: IFFALSE 7260
6774: GO 6776
6776: DISABLE
6777: LD_INT 0
6779: PPUSH
6780: PPUSH
6781: PPUSH
6782: PPUSH
6783: PPUSH
6784: PPUSH
6785: PPUSH
6786: PPUSH
// begin base := 1 ;
6787: LD_ADDR_VAR 0 2
6791: PUSH
6792: LD_INT 1
6794: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6795: LD_ADDR_VAR 0 4
6799: PUSH
6800: LD_INT 0
6802: PUSH
6803: LD_INT 0
6805: PUSH
6806: LD_INT 0
6808: PUSH
6809: LD_INT 0
6811: PUSH
6812: LD_INT 0
6814: PUSH
6815: LD_INT 0
6817: PUSH
6818: LD_INT 0
6820: PUSH
6821: LD_INT 0
6823: PUSH
6824: LD_INT 1
6826: PUSH
6827: LD_INT 0
6829: PUSH
6830: EMPTY
6831: LIST
6832: LIST
6833: LIST
6834: LIST
6835: LIST
6836: LIST
6837: LIST
6838: LIST
6839: LIST
6840: LIST
6841: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6842: LD_ADDR_VAR 0 3
6846: PUSH
6847: LD_INT 13
6849: PUSH
6850: LD_INT 1
6852: PUSH
6853: LD_INT 2
6855: PUSH
6856: LD_INT 28
6858: PUSH
6859: EMPTY
6860: LIST
6861: LIST
6862: LIST
6863: LIST
6864: PUSH
6865: LD_INT 13
6867: PUSH
6868: LD_INT 1
6870: PUSH
6871: LD_INT 2
6873: PUSH
6874: LD_INT 27
6876: PUSH
6877: EMPTY
6878: LIST
6879: LIST
6880: LIST
6881: LIST
6882: PUSH
6883: LD_INT 13
6885: PUSH
6886: LD_INT 1
6888: PUSH
6889: LD_INT 2
6891: PUSH
6892: LD_INT 25
6894: PUSH
6895: EMPTY
6896: LIST
6897: LIST
6898: LIST
6899: LIST
6900: PUSH
6901: LD_INT 11
6903: PUSH
6904: LD_INT 2
6906: PUSH
6907: LD_INT 2
6909: PUSH
6910: LD_INT 24
6912: PUSH
6913: EMPTY
6914: LIST
6915: LIST
6916: LIST
6917: LIST
6918: PUSH
6919: LD_INT 11
6921: PUSH
6922: LD_INT 2
6924: PUSH
6925: LD_INT 2
6927: PUSH
6928: LD_INT 24
6930: PUSH
6931: EMPTY
6932: LIST
6933: LIST
6934: LIST
6935: LIST
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: LIST
6941: LIST
6942: LIST
6943: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6944: LD_VAR 0 2
6948: PPUSH
6949: LD_VAR 0 3
6953: PPUSH
6954: CALL 81111 0 2
// wait ( 4 4$20 ) ;
6958: LD_INT 9100
6960: PPUSH
6961: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6965: LD_ADDR_VAR 0 5
6969: PUSH
6970: LD_INT 119
6972: PUSH
6973: LD_INT 9
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: PUSH
6980: EMPTY
6981: LIST
6982: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6983: LD_ADDR_VAR 0 6
6987: PUSH
6988: LD_EXP 80
6992: PUSH
6993: LD_VAR 0 2
6997: ARRAY
6998: PUSH
6999: LD_EXP 80
7003: PUSH
7004: LD_VAR 0 2
7008: ARRAY
7009: PPUSH
7010: LD_INT 2
7012: PUSH
7013: LD_INT 34
7015: PUSH
7016: LD_INT 32
7018: PUSH
7019: EMPTY
7020: LIST
7021: LIST
7022: PUSH
7023: LD_INT 34
7025: PUSH
7026: LD_INT 88
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: PUSH
7033: EMPTY
7034: LIST
7035: LIST
7036: LIST
7037: PPUSH
7038: CALL_OW 72
7042: DIFF
7043: ST_TO_ADDR
// uc_side := 2 ;
7044: LD_ADDR_OWVAR 20
7048: PUSH
7049: LD_INT 2
7051: ST_TO_ADDR
// uc_nation := 2 ;
7052: LD_ADDR_OWVAR 21
7056: PUSH
7057: LD_INT 2
7059: ST_TO_ADDR
// InitHc ;
7060: CALL_OW 19
// for i := 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
7064: LD_ADDR_VAR 0 1
7068: PUSH
7069: DOUBLE
7070: LD_INT 1
7072: DEC
7073: ST_TO_ADDR
7074: LD_INT 4
7076: PUSH
7077: LD_INT 5
7079: PUSH
7080: LD_INT 6
7082: PUSH
7083: LD_INT 6
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: LIST
7090: LIST
7091: PUSH
7092: LD_OWVAR 67
7096: ARRAY
7097: PUSH
7098: FOR_TO
7099: IFFALSE 7176
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7101: LD_INT 0
7103: PPUSH
7104: LD_INT 15
7106: PUSH
7107: LD_INT 17
7109: PUSH
7110: EMPTY
7111: LIST
7112: LIST
7113: PUSH
7114: LD_INT 1
7116: PPUSH
7117: LD_INT 2
7119: PPUSH
7120: CALL_OW 12
7124: ARRAY
7125: PPUSH
7126: LD_INT 8
7128: PPUSH
7129: CALL_OW 380
// un := CreateHuman ;
7133: LD_ADDR_VAR 0 7
7137: PUSH
7138: CALL_OW 44
7142: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
7143: LD_VAR 0 7
7147: PPUSH
7148: LD_INT 23
7150: PPUSH
7151: LD_INT 0
7153: PPUSH
7154: CALL_OW 49
// attackers := attackers union un ;
7158: LD_ADDR_VAR 0 6
7162: PUSH
7163: LD_VAR 0 6
7167: PUSH
7168: LD_VAR 0 7
7172: UNION
7173: ST_TO_ADDR
// end ;
7174: GO 7098
7176: POP
7177: POP
// p := 0 ;
7178: LD_ADDR_VAR 0 8
7182: PUSH
7183: LD_INT 0
7185: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7186: LD_INT 35
7188: PPUSH
7189: CALL_OW 67
// p := Inc ( p ) ;
7193: LD_ADDR_VAR 0 8
7197: PUSH
7198: LD_VAR 0 8
7202: PPUSH
7203: CALL 54132 0 1
7207: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7208: LD_VAR 0 6
7212: PPUSH
7213: LD_INT 60
7215: PUSH
7216: EMPTY
7217: LIST
7218: PPUSH
7219: CALL_OW 72
7223: NOT
7224: PUSH
7225: LD_VAR 0 8
7229: PUSH
7230: LD_INT 30
7232: GREATER
7233: OR
7234: IFFALSE 7186
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
7236: LD_VAR 0 2
7240: PPUSH
7241: LD_VAR 0 6
7245: PPUSH
7246: LD_VAR 0 5
7250: PPUSH
7251: LD_VAR 0 4
7255: PPUSH
7256: CALL 81296 0 4
// end ; end_of_file
7260: PPOPN 8
7262: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
7263: LD_INT 0
7265: PPUSH
7266: PPUSH
7267: PPUSH
7268: PPUSH
7269: PPUSH
7270: PPUSH
// uc_side := 1 ;
7271: LD_ADDR_OWVAR 20
7275: PUSH
7276: LD_INT 1
7278: ST_TO_ADDR
// uc_nation := 1 ;
7279: LD_ADDR_OWVAR 21
7283: PUSH
7284: LD_INT 1
7286: ST_TO_ADDR
// InitHc ;
7287: CALL_OW 19
// InitVc ;
7291: CALL_OW 20
// tmp := [ ] ;
7295: LD_ADDR_VAR 0 3
7299: PUSH
7300: EMPTY
7301: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
7302: LD_ADDR_VAR 0 2
7306: PUSH
7307: DOUBLE
7308: LD_INT 1
7310: DEC
7311: ST_TO_ADDR
7312: LD_INT 6
7314: PUSH
7315: LD_INT 8
7317: PUSH
7318: LD_INT 10
7320: PUSH
7321: LD_INT 10
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: LIST
7328: LIST
7329: PUSH
7330: LD_OWVAR 67
7334: ARRAY
7335: PUSH
7336: FOR_TO
7337: IFFALSE 7611
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
7339: LD_ADDR_VAR 0 5
7343: PUSH
7344: LD_INT 2
7346: PUSH
7347: LD_INT 4
7349: PUSH
7350: LD_INT 5
7352: PUSH
7353: EMPTY
7354: LIST
7355: LIST
7356: LIST
7357: PUSH
7358: LD_INT 1
7360: PPUSH
7361: LD_INT 3
7363: PPUSH
7364: CALL_OW 12
7368: ARRAY
7369: ST_TO_ADDR
// case chassis of us_medium_wheeled :
7370: LD_VAR 0 5
7374: PUSH
7375: LD_INT 2
7377: DOUBLE
7378: EQUAL
7379: IFTRUE 7383
7381: GO 7417
7383: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
7384: LD_ADDR_VAR 0 6
7388: PUSH
7389: LD_INT 9
7391: PUSH
7392: LD_INT 5
7394: PUSH
7395: LD_INT 7
7397: PUSH
7398: EMPTY
7399: LIST
7400: LIST
7401: LIST
7402: PUSH
7403: LD_INT 1
7405: PPUSH
7406: LD_INT 3
7408: PPUSH
7409: CALL_OW 12
7413: ARRAY
7414: ST_TO_ADDR
7415: GO 7506
7417: LD_INT 4
7419: DOUBLE
7420: EQUAL
7421: IFTRUE 7425
7423: GO 7463
7425: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7426: LD_ADDR_VAR 0 6
7430: PUSH
7431: LD_INT 9
7433: PUSH
7434: LD_INT 6
7436: PUSH
7437: LD_INT 6
7439: PUSH
7440: LD_INT 7
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: LIST
7447: LIST
7448: PUSH
7449: LD_INT 1
7451: PPUSH
7452: LD_INT 4
7454: PPUSH
7455: CALL_OW 12
7459: ARRAY
7460: ST_TO_ADDR
7461: GO 7506
7463: LD_INT 5
7465: DOUBLE
7466: EQUAL
7467: IFTRUE 7471
7469: GO 7505
7471: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7472: LD_ADDR_VAR 0 6
7476: PUSH
7477: LD_INT 9
7479: PUSH
7480: LD_INT 6
7482: PUSH
7483: LD_INT 7
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: LIST
7490: PUSH
7491: LD_INT 1
7493: PPUSH
7494: LD_INT 3
7496: PPUSH
7497: CALL_OW 12
7501: ARRAY
7502: ST_TO_ADDR
7503: GO 7506
7505: POP
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7506: LD_VAR 0 5
7510: PPUSH
7511: LD_INT 1
7513: PUSH
7514: LD_INT 3
7516: PUSH
7517: EMPTY
7518: LIST
7519: LIST
7520: PUSH
7521: LD_INT 1
7523: PPUSH
7524: LD_INT 2
7526: PPUSH
7527: CALL_OW 12
7531: ARRAY
7532: PPUSH
7533: LD_INT 3
7535: PPUSH
7536: LD_VAR 0 6
7540: PPUSH
7541: LD_INT 70
7543: PPUSH
7544: LD_INT 90
7546: PPUSH
7547: CALL_OW 12
7551: PPUSH
7552: CALL 20319 0 5
// veh := CreateVehicle ;
7556: LD_ADDR_VAR 0 4
7560: PUSH
7561: CALL_OW 45
7565: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
7566: LD_VAR 0 4
7570: PPUSH
7571: LD_INT 2
7573: PPUSH
7574: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
7578: LD_VAR 0 4
7582: PPUSH
7583: LD_INT 17
7585: PPUSH
7586: LD_INT 0
7588: PPUSH
7589: CALL_OW 49
// tmp := tmp ^ veh ;
7593: LD_ADDR_VAR 0 3
7597: PUSH
7598: LD_VAR 0 3
7602: PUSH
7603: LD_VAR 0 4
7607: ADD
7608: ST_TO_ADDR
// end ;
7609: GO 7336
7611: POP
7612: POP
// if not tmp then
7613: LD_VAR 0 3
7617: NOT
7618: IFFALSE 7622
// exit ;
7620: GO 7731
// if not first_powell_attack then
7622: LD_EXP 12
7626: NOT
7627: IFFALSE 7637
// first_powell_attack := true ;
7629: LD_ADDR_EXP 12
7633: PUSH
7634: LD_INT 1
7636: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
7637: LD_INT 70
7639: PPUSH
7640: CALL_OW 67
// for i in tmp do
7644: LD_ADDR_VAR 0 2
7648: PUSH
7649: LD_VAR 0 3
7653: PUSH
7654: FOR_IN
7655: IFFALSE 7722
// if IsOk ( i ) then
7657: LD_VAR 0 2
7661: PPUSH
7662: CALL_OW 302
7666: IFFALSE 7704
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
7668: LD_VAR 0 2
7672: PPUSH
7673: LD_INT 81
7675: PUSH
7676: LD_INT 1
7678: PUSH
7679: EMPTY
7680: LIST
7681: LIST
7682: PPUSH
7683: CALL_OW 69
7687: PPUSH
7688: LD_VAR 0 2
7692: PPUSH
7693: CALL_OW 74
7697: PPUSH
7698: CALL_OW 115
7702: GO 7720
// tmp := tmp diff i ;
7704: LD_ADDR_VAR 0 3
7708: PUSH
7709: LD_VAR 0 3
7713: PUSH
7714: LD_VAR 0 2
7718: DIFF
7719: ST_TO_ADDR
7720: GO 7654
7722: POP
7723: POP
// until not tmp ;
7724: LD_VAR 0 3
7728: NOT
7729: IFFALSE 7637
// end ; end_of_file
7731: LD_VAR 0 1
7735: RET
// export function Action ; var tmp , i , un ; begin
7736: LD_INT 0
7738: PPUSH
7739: PPUSH
7740: PPUSH
7741: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
7742: LD_INT 68
7744: PPUSH
7745: LD_INT 39
7747: PPUSH
7748: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
7752: LD_ADDR_VAR 0 2
7756: PUSH
7757: LD_INT 22
7759: PUSH
7760: LD_INT 7
7762: PUSH
7763: EMPTY
7764: LIST
7765: LIST
7766: PPUSH
7767: CALL_OW 69
7771: ST_TO_ADDR
// InGameOn ;
7772: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
7776: LD_VAR 0 2
7780: PPUSH
7781: LD_INT 71
7783: PPUSH
7784: LD_INT 49
7786: PPUSH
7787: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7791: LD_INT 35
7793: PPUSH
7794: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
7798: LD_INT 7
7800: PPUSH
7801: LD_INT 71
7803: PPUSH
7804: LD_INT 51
7806: PPUSH
7807: CALL_OW 293
7811: IFFALSE 7791
// DialogueOn ;
7813: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7817: LD_EXP 16
7821: PPUSH
7822: LD_STRING D1-JMM-1
7824: PPUSH
7825: CALL_OW 88
// if Joan then
7829: LD_EXP 31
7833: IFFALSE 7847
// Say ( Joan , D1-Joan-1 ) ;
7835: LD_EXP 31
7839: PPUSH
7840: LD_STRING D1-Joan-1
7842: PPUSH
7843: CALL_OW 88
// if Lisa then
7847: LD_EXP 18
7851: IFFALSE 7865
// Say ( Lisa , D1-Lisa-1 ) ;
7853: LD_EXP 18
7857: PPUSH
7858: LD_STRING D1-Lisa-1
7860: PPUSH
7861: CALL_OW 88
// if Joan or Lisa then
7865: LD_EXP 31
7869: PUSH
7870: LD_EXP 18
7874: OR
7875: IFFALSE 7889
// Say ( JMM , D1-JMM-2 ) ;
7877: LD_EXP 16
7881: PPUSH
7882: LD_STRING D1-JMM-2
7884: PPUSH
7885: CALL_OW 88
// DialogueOff ;
7889: CALL_OW 7
// InGameOff ;
7893: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7897: LD_INT 71
7899: PPUSH
7900: LD_INT 50
7902: PPUSH
7903: LD_INT 7
7905: PPUSH
7906: LD_INT 30
7908: NEG
7909: PPUSH
7910: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7914: LD_INT 71
7916: PPUSH
7917: LD_INT 50
7919: PPUSH
7920: LD_INT 7
7922: PPUSH
7923: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7927: LD_STRING M1
7929: PPUSH
7930: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7934: LD_INT 35
7936: PPUSH
7937: CALL_OW 67
// until freedom or tick > 1 1$00 ;
7941: LD_EXP 3
7945: PUSH
7946: LD_OWVAR 1
7950: PUSH
7951: LD_INT 2100
7953: GREATER
7954: OR
7955: IFFALSE 7934
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7957: LD_INT 350
7959: PPUSH
7960: LD_INT 700
7962: PPUSH
7963: CALL_OW 12
7967: PPUSH
7968: CALL_OW 67
// PrepareGossudarov ;
7972: CALL 1935 0 0
// repeat wait ( 0 0$1 ) ;
7976: LD_INT 35
7978: PPUSH
7979: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7983: LD_INT 22
7985: PUSH
7986: LD_INT 6
7988: PUSH
7989: EMPTY
7990: LIST
7991: LIST
7992: PUSH
7993: LD_INT 3
7995: PUSH
7996: LD_INT 24
7998: PUSH
7999: LD_INT 1000
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: PUSH
8006: EMPTY
8007: LIST
8008: LIST
8009: PUSH
8010: EMPTY
8011: LIST
8012: LIST
8013: PPUSH
8014: CALL_OW 69
8018: PUSH
8019: LD_INT 7
8021: PPUSH
8022: LD_EXP 34
8026: PPUSH
8027: CALL_OW 292
8031: OR
8032: IFFALSE 7976
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
8034: LD_ADDR_VAR 0 2
8038: PUSH
8039: LD_INT 22
8041: PUSH
8042: LD_INT 6
8044: PUSH
8045: EMPTY
8046: LIST
8047: LIST
8048: PPUSH
8049: CALL_OW 69
8053: ST_TO_ADDR
// for i in tmp do
8054: LD_ADDR_VAR 0 3
8058: PUSH
8059: LD_VAR 0 2
8063: PUSH
8064: FOR_IN
8065: IFFALSE 8081
// SetSide ( i , 7 ) ;
8067: LD_VAR 0 3
8071: PPUSH
8072: LD_INT 7
8074: PPUSH
8075: CALL_OW 235
8079: GO 8064
8081: POP
8082: POP
// DialogueOn ;
8083: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
8087: LD_EXP 16
8091: PUSH
8092: LD_EXP 17
8096: PUSH
8097: EMPTY
8098: LIST
8099: LIST
8100: PPUSH
8101: LD_EXP 34
8105: PPUSH
8106: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
8110: LD_EXP 34
8114: PPUSH
8115: CALL_OW 87
// if not Roth then
8119: LD_EXP 17
8123: NOT
8124: IFFALSE 8216
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8126: LD_VAR 0 2
8130: PPUSH
8131: LD_INT 3
8133: PUSH
8134: LD_INT 24
8136: PUSH
8137: LD_INT 1000
8139: PUSH
8140: EMPTY
8141: LIST
8142: LIST
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PPUSH
8148: CALL_OW 72
8152: IFFALSE 8166
// Say ( JMM , D2-JMM-1 ) ;
8154: LD_EXP 16
8158: PPUSH
8159: LD_STRING D2-JMM-1
8161: PPUSH
8162: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
8166: LD_EXP 16
8170: PPUSH
8171: LD_STRING D2-JMM-1b
8173: PPUSH
8174: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
8178: LD_EXP 34
8182: PPUSH
8183: LD_STRING D2-Gos-1
8185: PPUSH
8186: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
8190: LD_EXP 16
8194: PPUSH
8195: LD_STRING D2-JMM-2
8197: PPUSH
8198: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
8202: LD_EXP 34
8206: PPUSH
8207: LD_STRING D2-Gos-2
8209: PPUSH
8210: CALL_OW 88
// end else
8214: GO 8368
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8216: LD_VAR 0 2
8220: PPUSH
8221: LD_INT 3
8223: PUSH
8224: LD_INT 24
8226: PUSH
8227: LD_INT 1000
8229: PUSH
8230: EMPTY
8231: LIST
8232: LIST
8233: PUSH
8234: EMPTY
8235: LIST
8236: LIST
8237: PPUSH
8238: CALL_OW 72
8242: IFFALSE 8268
// begin Say ( Roth , D2-Roth-2 ) ;
8244: LD_EXP 17
8248: PPUSH
8249: LD_STRING D2-Roth-2
8251: PPUSH
8252: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
8256: LD_EXP 16
8260: PPUSH
8261: LD_STRING D2-JMM-1a
8263: PPUSH
8264: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
8268: LD_EXP 17
8272: PPUSH
8273: LD_STRING D2-Roth-2a
8275: PPUSH
8276: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
8280: LD_EXP 17
8284: PPUSH
8285: LD_STRING D2-Roth-2b
8287: PPUSH
8288: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
8292: LD_EXP 16
8296: PPUSH
8297: LD_STRING D2-JMM-3
8299: PPUSH
8300: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8304: LD_VAR 0 2
8308: PPUSH
8309: LD_INT 3
8311: PUSH
8312: LD_INT 24
8314: PUSH
8315: LD_INT 1000
8317: PUSH
8318: EMPTY
8319: LIST
8320: LIST
8321: PUSH
8322: EMPTY
8323: LIST
8324: LIST
8325: PPUSH
8326: CALL_OW 72
8330: IFFALSE 8368
// begin Say ( Gossudarov , D2-Gos-3 ) ;
8332: LD_EXP 34
8336: PPUSH
8337: LD_STRING D2-Gos-3
8339: PPUSH
8340: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
8344: LD_EXP 16
8348: PPUSH
8349: LD_STRING D2-JMM-4
8351: PPUSH
8352: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
8356: LD_EXP 34
8360: PPUSH
8361: LD_STRING D2-Gos-4
8363: PPUSH
8364: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
8368: LD_EXP 16
8372: PPUSH
8373: LD_STRING D2-JMM-5
8375: PPUSH
8376: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
8380: LD_EXP 34
8384: PPUSH
8385: LD_STRING D2-Gos-5
8387: PPUSH
8388: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
8392: LD_EXP 16
8396: PPUSH
8397: LD_STRING D2-JMM-6
8399: PPUSH
8400: CALL_OW 88
// DialogueOff ;
8404: CALL_OW 7
// wait ( 0 0$2 ) ;
8408: LD_INT 70
8410: PPUSH
8411: CALL_OW 67
// if Kirilenkova then
8415: LD_EXP 35
8419: IFFALSE 8433
// Say ( Kirilenkova , D3-Kir-1 ) ;
8421: LD_EXP 35
8425: PPUSH
8426: LD_STRING D3-Kir-1
8428: PPUSH
8429: CALL_OW 88
// gossudarov_arrive := true ;
8433: LD_ADDR_EXP 4
8437: PUSH
8438: LD_INT 1
8440: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8441: LD_INT 35
8443: PPUSH
8444: CALL_OW 67
// until ru_lab_builded ;
8448: LD_EXP 5
8452: IFFALSE 8441
// DialogueOn ;
8454: CALL_OW 6
// if Kirilenkova then
8458: LD_EXP 35
8462: IFFALSE 8478
// Say ( Kirilenkova , D3a-Kir-1 ) else
8464: LD_EXP 35
8468: PPUSH
8469: LD_STRING D3a-Kir-1
8471: PPUSH
8472: CALL_OW 88
8476: GO 8500
// begin un := SciRu ;
8478: LD_ADDR_VAR 0 4
8482: PUSH
8483: CALL 13863 0 0
8487: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8488: LD_VAR 0 4
8492: PPUSH
8493: LD_STRING D3a-Sci1-1
8495: PPUSH
8496: CALL_OW 88
// end ; if Kirilenkova or un then
8500: LD_EXP 35
8504: PUSH
8505: LD_VAR 0 4
8509: OR
8510: IFFALSE 8524
// Say ( JMM , D3a-JMM-1 ) ;
8512: LD_EXP 16
8516: PPUSH
8517: LD_STRING D3a-JMM-1
8519: PPUSH
8520: CALL_OW 88
// DialogueOff ;
8524: CALL_OW 7
// end ;
8528: LD_VAR 0 1
8532: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
8533: LD_EXP 4
8537: PUSH
8538: LD_INT 22
8540: PUSH
8541: LD_INT 7
8543: PUSH
8544: EMPTY
8545: LIST
8546: LIST
8547: PUSH
8548: LD_INT 2
8550: PUSH
8551: LD_INT 25
8553: PUSH
8554: LD_INT 1
8556: PUSH
8557: EMPTY
8558: LIST
8559: LIST
8560: PUSH
8561: LD_INT 25
8563: PUSH
8564: LD_INT 2
8566: PUSH
8567: EMPTY
8568: LIST
8569: LIST
8570: PUSH
8571: LD_INT 25
8573: PUSH
8574: LD_INT 3
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: PUSH
8581: LD_INT 25
8583: PUSH
8584: LD_INT 4
8586: PUSH
8587: EMPTY
8588: LIST
8589: LIST
8590: PUSH
8591: LD_INT 25
8593: PUSH
8594: LD_INT 5
8596: PUSH
8597: EMPTY
8598: LIST
8599: LIST
8600: PUSH
8601: LD_INT 25
8603: PUSH
8604: LD_INT 8
8606: PUSH
8607: EMPTY
8608: LIST
8609: LIST
8610: PUSH
8611: LD_INT 25
8613: PUSH
8614: LD_INT 9
8616: PUSH
8617: EMPTY
8618: LIST
8619: LIST
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: LIST
8625: LIST
8626: LIST
8627: LIST
8628: LIST
8629: LIST
8630: PUSH
8631: EMPTY
8632: LIST
8633: LIST
8634: PPUSH
8635: CALL_OW 69
8639: PUSH
8640: LD_INT 7
8642: LESS
8643: AND
8644: IFFALSE 8656
8646: GO 8648
8648: DISABLE
// YouLost ( TooMany ) ;
8649: LD_STRING TooMany
8651: PPUSH
8652: CALL_OW 104
8656: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
8657: LD_EXP 34
8661: PPUSH
8662: CALL_OW 255
8666: PUSH
8667: LD_INT 7
8669: EQUAL
8670: IFFALSE 8887
8672: GO 8674
8674: DISABLE
8675: LD_INT 0
8677: PPUSH
8678: PPUSH
8679: PPUSH
// begin uc_side := 3 ;
8680: LD_ADDR_OWVAR 20
8684: PUSH
8685: LD_INT 3
8687: ST_TO_ADDR
// uc_nation := 3 ;
8688: LD_ADDR_OWVAR 21
8692: PUSH
8693: LD_INT 3
8695: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
8696: LD_INT 21
8698: PPUSH
8699: LD_INT 3
8701: PPUSH
8702: LD_INT 3
8704: PPUSH
8705: LD_INT 42
8707: PPUSH
8708: LD_INT 100
8710: PPUSH
8711: CALL 20319 0 5
// un := CreateVehicle ;
8715: LD_ADDR_VAR 0 3
8719: PUSH
8720: CALL_OW 45
8724: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
8725: LD_VAR 0 3
8729: PPUSH
8730: LD_INT 15
8732: PPUSH
8733: LD_INT 0
8735: PPUSH
8736: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
8740: LD_VAR 0 3
8744: PPUSH
8745: LD_INT 67
8747: PPUSH
8748: LD_INT 45
8750: PPUSH
8751: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
8755: LD_VAR 0 3
8759: PPUSH
8760: LD_INT 70
8762: PPUSH
8763: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
8767: LD_VAR 0 3
8771: PPUSH
8772: LD_INT 69
8774: PPUSH
8775: LD_INT 18
8777: PPUSH
8778: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
8782: LD_VAR 0 3
8786: PPUSH
8787: LD_INT 60
8789: PPUSH
8790: LD_INT 3
8792: PPUSH
8793: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8797: LD_INT 35
8799: PPUSH
8800: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
8804: LD_VAR 0 3
8808: PPUSH
8809: CALL_OW 302
8813: NOT
8814: PUSH
8815: LD_VAR 0 3
8819: PPUSH
8820: LD_INT 17
8822: PPUSH
8823: CALL_OW 308
8827: OR
8828: PUSH
8829: LD_VAR 0 3
8833: PPUSH
8834: LD_INT 60
8836: PPUSH
8837: LD_INT 3
8839: PPUSH
8840: CALL_OW 307
8844: OR
8845: IFFALSE 8797
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
8847: LD_VAR 0 3
8851: PPUSH
8852: LD_INT 17
8854: PPUSH
8855: CALL_OW 308
8859: PUSH
8860: LD_VAR 0 3
8864: PPUSH
8865: LD_INT 60
8867: PPUSH
8868: LD_INT 3
8870: PPUSH
8871: CALL_OW 307
8875: OR
8876: IFFALSE 8887
// RemoveUnit ( un ) ;
8878: LD_VAR 0 3
8882: PPUSH
8883: CALL_OW 64
// end ;
8887: PPOPN 3
8889: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8890: LD_EXP 4
8894: IFFALSE 9136
8896: GO 8898
8898: DISABLE
8899: LD_INT 0
8901: PPUSH
8902: PPUSH
8903: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8904: LD_INT 70
8906: PPUSH
8907: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8911: LD_ADDR_VAR 0 3
8915: PUSH
8916: LD_INT 22
8918: PUSH
8919: LD_INT 7
8921: PUSH
8922: EMPTY
8923: LIST
8924: LIST
8925: PUSH
8926: LD_INT 101
8928: PUSH
8929: LD_INT 3
8931: PUSH
8932: EMPTY
8933: LIST
8934: LIST
8935: PUSH
8936: EMPTY
8937: LIST
8938: LIST
8939: PPUSH
8940: CALL_OW 69
8944: ST_TO_ADDR
// until tmp ;
8945: LD_VAR 0 3
8949: IFFALSE 8904
// un := NearestUnitToUnit ( tmp , JMM ) ;
8951: LD_ADDR_VAR 0 2
8955: PUSH
8956: LD_VAR 0 3
8960: PPUSH
8961: LD_EXP 16
8965: PPUSH
8966: CALL_OW 74
8970: ST_TO_ADDR
// player_spotted := true ;
8971: LD_ADDR_EXP 6
8975: PUSH
8976: LD_INT 1
8978: ST_TO_ADDR
// tmp := SciRu ;
8979: LD_ADDR_VAR 0 3
8983: PUSH
8984: CALL 13863 0 0
8988: ST_TO_ADDR
// if not tmp then
8989: LD_VAR 0 3
8993: NOT
8994: IFFALSE 9006
// tmp := SolRu ;
8996: LD_ADDR_VAR 0 3
9000: PUSH
9001: CALL 14010 0 0
9005: ST_TO_ADDR
// DialogueOn ;
9006: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
9010: LD_VAR 0 2
9014: PPUSH
9015: CALL_OW 250
9019: PPUSH
9020: LD_VAR 0 2
9024: PPUSH
9025: CALL_OW 251
9029: PPUSH
9030: LD_INT 7
9032: PPUSH
9033: LD_INT 8
9035: NEG
9036: PPUSH
9037: CALL_OW 330
// CenterNowOnUnits ( un ) ;
9041: LD_VAR 0 2
9045: PPUSH
9046: CALL_OW 87
// if tmp then
9050: LD_VAR 0 3
9054: IFFALSE 9068
// Say ( tmp , D4-RSci1-1 ) ;
9056: LD_VAR 0 3
9060: PPUSH
9061: LD_STRING D4-RSci1-1
9063: PPUSH
9064: CALL_OW 88
// if Gossudarov then
9068: LD_EXP 34
9072: IFFALSE 9098
// begin Say ( Gossudarov , D4-Gos-1 ) ;
9074: LD_EXP 34
9078: PPUSH
9079: LD_STRING D4-Gos-1
9081: PPUSH
9082: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
9086: LD_EXP 16
9090: PPUSH
9091: LD_STRING D4-JMM-1
9093: PPUSH
9094: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
9098: LD_VAR 0 2
9102: PPUSH
9103: CALL_OW 250
9107: PPUSH
9108: LD_VAR 0 2
9112: PPUSH
9113: CALL_OW 251
9117: PPUSH
9118: LD_INT 7
9120: PPUSH
9121: CALL_OW 331
// DialogueOff ;
9125: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
9129: LD_STRING M5
9131: PPUSH
9132: CALL_OW 337
// end ;
9136: PPOPN 3
9138: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
9139: LD_EXP 6
9143: IFFALSE 9736
9145: GO 9147
9147: DISABLE
9148: LD_INT 0
9150: PPUSH
9151: PPUSH
9152: PPUSH
// begin PrepareBelkov ;
9153: CALL 2248 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
9157: LD_EXP 49
9161: PPUSH
9162: LD_INT 118
9164: PPUSH
9165: LD_INT 106
9167: PPUSH
9168: CALL_OW 111
// AddComHold ( Belkov ) ;
9172: LD_EXP 49
9176: PPUSH
9177: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
9181: LD_INT 35
9183: PPUSH
9184: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
9188: LD_EXP 49
9192: PPUSH
9193: LD_INT 118
9195: PPUSH
9196: LD_INT 106
9198: PPUSH
9199: CALL_OW 307
9203: IFFALSE 9181
// ChangeSideFog ( 4 , 7 ) ;
9205: LD_INT 4
9207: PPUSH
9208: LD_INT 7
9210: PPUSH
9211: CALL_OW 343
// if IsOk ( Belkov ) then
9215: LD_EXP 49
9219: PPUSH
9220: CALL_OW 302
9224: IFFALSE 9308
// begin InGameOn ;
9226: CALL_OW 8
// DialogueOn ;
9230: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
9234: LD_EXP 49
9238: PPUSH
9239: LD_STRING D5-Bel-1
9241: PPUSH
9242: CALL_OW 94
// if Gossudarov then
9246: LD_EXP 34
9250: IFFALSE 9300
// begin Say ( Gossudarov , D5-Gos-1 ) ;
9252: LD_EXP 34
9256: PPUSH
9257: LD_STRING D5-Gos-1
9259: PPUSH
9260: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
9264: LD_EXP 16
9268: PPUSH
9269: LD_STRING D5-JMM-1
9271: PPUSH
9272: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
9276: LD_EXP 34
9280: PPUSH
9281: LD_STRING D5-Gos-2
9283: PPUSH
9284: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
9288: LD_EXP 16
9292: PPUSH
9293: LD_STRING D5-JMM-2
9295: PPUSH
9296: CALL_OW 88
// end ; DialogueOff ;
9300: CALL_OW 7
// InGameOff ;
9304: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
9308: LD_STRING QSaveBelkov
9310: PPUSH
9311: CALL_OW 97
9315: PUSH
9316: LD_INT 1
9318: DOUBLE
9319: EQUAL
9320: IFTRUE 9324
9322: GO 9374
9324: POP
// begin DialogueOn ;
9325: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
9329: LD_EXP 16
9333: PPUSH
9334: LD_STRING D5a-JMM-1
9336: PPUSH
9337: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
9341: LD_EXP 49
9345: PPUSH
9346: LD_STRING D5a-Bel-1
9348: PPUSH
9349: CALL_OW 94
// DialogueOff ;
9353: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
9357: LD_EXP 49
9361: PPUSH
9362: LD_INT 83
9364: PPUSH
9365: LD_INT 49
9367: PPUSH
9368: CALL_OW 111
// end ; 2 :
9372: GO 9407
9374: LD_INT 2
9376: DOUBLE
9377: EQUAL
9378: IFTRUE 9382
9380: GO 9406
9382: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
9383: LD_EXP 16
9387: PPUSH
9388: LD_STRING D5a-JMM-2
9390: PPUSH
9391: CALL_OW 88
// ComHold ( Belkov ) ;
9395: LD_EXP 49
9399: PPUSH
9400: CALL_OW 140
// end ; end ;
9404: GO 9407
9406: POP
// time := 0 0$00 ;
9407: LD_ADDR_VAR 0 1
9411: PUSH
9412: LD_INT 0
9414: ST_TO_ADDR
// vehSpawned := false ;
9415: LD_ADDR_VAR 0 3
9419: PUSH
9420: LD_INT 0
9422: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9423: LD_INT 35
9425: PPUSH
9426: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
9430: LD_VAR 0 1
9434: PUSH
9435: LD_INT 350
9437: PUSH
9438: LD_INT 175
9440: PUSH
9441: LD_INT 105
9443: PUSH
9444: LD_INT 70
9446: PUSH
9447: EMPTY
9448: LIST
9449: LIST
9450: LIST
9451: LIST
9452: PUSH
9453: LD_OWVAR 67
9457: ARRAY
9458: GREATEREQUAL
9459: PUSH
9460: LD_VAR 0 3
9464: NOT
9465: AND
9466: IFFALSE 9556
// begin vehSpawned := true ;
9468: LD_ADDR_VAR 0 3
9472: PUSH
9473: LD_INT 1
9475: ST_TO_ADDR
// uc_side := 3 ;
9476: LD_ADDR_OWVAR 20
9480: PUSH
9481: LD_INT 3
9483: ST_TO_ADDR
// uc_nation := 3 ;
9484: LD_ADDR_OWVAR 21
9488: PUSH
9489: LD_INT 3
9491: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9492: LD_INT 22
9494: PPUSH
9495: LD_INT 3
9497: PPUSH
9498: LD_INT 3
9500: PPUSH
9501: LD_INT 43
9503: PPUSH
9504: LD_INT 100
9506: PPUSH
9507: CALL 20319 0 5
// veh := CreateVehicle ;
9511: LD_ADDR_VAR 0 2
9515: PUSH
9516: CALL_OW 45
9520: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
9521: LD_VAR 0 2
9525: PPUSH
9526: LD_INT 130
9528: PPUSH
9529: LD_INT 131
9531: PPUSH
9532: LD_INT 0
9534: PPUSH
9535: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
9539: LD_VAR 0 2
9543: PPUSH
9544: LD_INT 100
9546: PPUSH
9547: LD_INT 82
9549: PPUSH
9550: CALL_OW 114
// end else
9554: GO 9570
// time := time + 0 0$1 ;
9556: LD_ADDR_VAR 0 1
9560: PUSH
9561: LD_VAR 0 1
9565: PUSH
9566: LD_INT 35
9568: PLUS
9569: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
9570: LD_EXP 49
9574: PPUSH
9575: CALL_OW 301
9579: PUSH
9580: LD_EXP 49
9584: PPUSH
9585: CALL_OW 255
9589: PUSH
9590: LD_INT 4
9592: EQUAL
9593: AND
9594: PUSH
9595: LD_INT 22
9597: PUSH
9598: LD_INT 7
9600: PUSH
9601: EMPTY
9602: LIST
9603: LIST
9604: PPUSH
9605: CALL_OW 69
9609: PPUSH
9610: LD_EXP 49
9614: PPUSH
9615: CALL_OW 74
9619: PPUSH
9620: LD_EXP 49
9624: PPUSH
9625: CALL_OW 296
9629: PUSH
9630: LD_INT 10
9632: LESS
9633: OR
9634: IFFALSE 9423
// if IsDead ( Belkov ) then
9636: LD_EXP 49
9640: PPUSH
9641: CALL_OW 301
9645: IFFALSE 9670
// begin CenterNowOnUnits ( Belkov ) ;
9647: LD_EXP 49
9651: PPUSH
9652: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
9656: LD_EXP 16
9660: PPUSH
9661: LD_STRING D5a-JMM-2a
9663: PPUSH
9664: CALL_OW 88
// exit ;
9668: GO 9736
// end ; if See ( 7 , Belkov ) then
9670: LD_INT 7
9672: PPUSH
9673: LD_EXP 49
9677: PPUSH
9678: CALL_OW 292
9682: IFFALSE 9696
// SetSide ( Belkov , 7 ) ;
9684: LD_EXP 49
9688: PPUSH
9689: LD_INT 7
9691: PPUSH
9692: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
9696: LD_INT 35
9698: PPUSH
9699: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
9703: LD_EXP 49
9707: PPUSH
9708: LD_INT 66
9710: PPUSH
9711: LD_INT 45
9713: PPUSH
9714: CALL_OW 297
9718: PUSH
9719: LD_INT 30
9721: LESS
9722: IFFALSE 9696
// Say ( Belkov , D6-Bel-1 ) ;
9724: LD_EXP 49
9728: PPUSH
9729: LD_STRING D6-Bel-1
9731: PPUSH
9732: CALL_OW 88
// end ;
9736: PPOPN 3
9738: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
9739: LD_EXP 49
9743: PPUSH
9744: CALL_OW 302
9748: PUSH
9749: LD_EXP 49
9753: PPUSH
9754: CALL_OW 504
9758: PUSH
9759: LD_INT 2
9761: PUSH
9762: LD_INT 34
9764: PUSH
9765: LD_INT 47
9767: PUSH
9768: EMPTY
9769: LIST
9770: LIST
9771: PUSH
9772: LD_INT 34
9774: PUSH
9775: LD_INT 45
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: PUSH
9782: EMPTY
9783: LIST
9784: LIST
9785: LIST
9786: PPUSH
9787: CALL_OW 69
9791: IN
9792: AND
9793: IFFALSE 9810
9795: GO 9797
9797: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
9798: LD_EXP 49
9802: PPUSH
9803: LD_STRING D7-Bel-1
9805: PPUSH
9806: CALL_OW 88
9810: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
9811: LD_INT 22
9813: PUSH
9814: LD_INT 7
9816: PUSH
9817: EMPTY
9818: LIST
9819: LIST
9820: PUSH
9821: LD_INT 101
9823: PUSH
9824: LD_INT 2
9826: PUSH
9827: EMPTY
9828: LIST
9829: LIST
9830: PUSH
9831: EMPTY
9832: LIST
9833: LIST
9834: PPUSH
9835: CALL_OW 69
9839: PUSH
9840: LD_EXP 8
9844: NOT
9845: AND
9846: PUSH
9847: LD_EXP 48
9851: PPUSH
9852: CALL_OW 305
9856: NOT
9857: AND
9858: IFFALSE 10328
9860: GO 9862
9862: DISABLE
9863: LD_INT 0
9865: PPUSH
// begin ar_base_spotted := true ;
9866: LD_ADDR_EXP 8
9870: PUSH
9871: LD_INT 1
9873: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9874: LD_ADDR_VAR 0 1
9878: PUSH
9879: LD_INT 22
9881: PUSH
9882: LD_INT 2
9884: PUSH
9885: EMPTY
9886: LIST
9887: LIST
9888: PUSH
9889: LD_INT 21
9891: PUSH
9892: LD_INT 3
9894: PUSH
9895: EMPTY
9896: LIST
9897: LIST
9898: PUSH
9899: EMPTY
9900: LIST
9901: LIST
9902: PPUSH
9903: CALL_OW 69
9907: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9908: LD_ADDR_VAR 0 1
9912: PUSH
9913: LD_VAR 0 1
9917: PPUSH
9918: LD_EXP 16
9922: PPUSH
9923: CALL_OW 74
9927: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9928: LD_INT 7
9930: PPUSH
9931: LD_INT 3
9933: PPUSH
9934: CALL_OW 332
// DialogueOn ;
9938: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9942: LD_VAR 0 1
9946: PPUSH
9947: CALL_OW 250
9951: PPUSH
9952: LD_VAR 0 1
9956: PPUSH
9957: CALL_OW 251
9961: PPUSH
9962: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9966: LD_ADDR_VAR 0 1
9970: PUSH
9971: LD_INT 22
9973: PUSH
9974: LD_INT 7
9976: PUSH
9977: EMPTY
9978: LIST
9979: LIST
9980: PUSH
9981: LD_INT 23
9983: PUSH
9984: LD_INT 1
9986: PUSH
9987: EMPTY
9988: LIST
9989: LIST
9990: PUSH
9991: LD_INT 26
9993: PUSH
9994: LD_INT 1
9996: PUSH
9997: EMPTY
9998: LIST
9999: LIST
10000: PUSH
10001: EMPTY
10002: LIST
10003: LIST
10004: LIST
10005: PPUSH
10006: CALL_OW 69
10010: PUSH
10011: LD_EXP 16
10015: PUSH
10016: LD_EXP 20
10020: PUSH
10021: LD_EXP 21
10025: PUSH
10026: LD_EXP 28
10030: PUSH
10031: LD_EXP 17
10035: PUSH
10036: LD_EXP 26
10040: PUSH
10041: LD_EXP 22
10045: PUSH
10046: LD_EXP 24
10050: PUSH
10051: EMPTY
10052: LIST
10053: LIST
10054: LIST
10055: LIST
10056: LIST
10057: LIST
10058: LIST
10059: LIST
10060: DIFF
10061: ST_TO_ADDR
// if not tmp then
10062: LD_VAR 0 1
10066: NOT
10067: IFFALSE 10141
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
10069: LD_ADDR_VAR 0 1
10073: PUSH
10074: LD_INT 22
10076: PUSH
10077: LD_INT 7
10079: PUSH
10080: EMPTY
10081: LIST
10082: LIST
10083: PUSH
10084: LD_INT 23
10086: PUSH
10087: LD_INT 1
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: PUSH
10094: LD_INT 26
10096: PUSH
10097: LD_INT 2
10099: PUSH
10100: EMPTY
10101: LIST
10102: LIST
10103: PUSH
10104: EMPTY
10105: LIST
10106: LIST
10107: LIST
10108: PPUSH
10109: CALL_OW 69
10113: PUSH
10114: LD_EXP 31
10118: PUSH
10119: LD_EXP 18
10123: PUSH
10124: LD_EXP 29
10128: PUSH
10129: LD_EXP 30
10133: PUSH
10134: EMPTY
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: DIFF
10140: ST_TO_ADDR
// if tmp then
10141: LD_VAR 0 1
10145: IFFALSE 10216
// case GetSex ( tmp [ 1 ] ) of sex_male :
10147: LD_VAR 0 1
10151: PUSH
10152: LD_INT 1
10154: ARRAY
10155: PPUSH
10156: CALL_OW 258
10160: PUSH
10161: LD_INT 1
10163: DOUBLE
10164: EQUAL
10165: IFTRUE 10169
10167: GO 10188
10169: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
10170: LD_VAR 0 1
10174: PUSH
10175: LD_INT 1
10177: ARRAY
10178: PPUSH
10179: LD_STRING D9-Sol1-1
10181: PPUSH
10182: CALL_OW 88
10186: GO 10216
10188: LD_INT 2
10190: DOUBLE
10191: EQUAL
10192: IFTRUE 10196
10194: GO 10215
10196: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
10197: LD_VAR 0 1
10201: PUSH
10202: LD_INT 1
10204: ARRAY
10205: PPUSH
10206: LD_STRING D9-FSol1-1
10208: PPUSH
10209: CALL_OW 88
10213: GO 10216
10215: POP
// if Frank then
10216: LD_EXP 28
10220: IFFALSE 10324
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
10222: LD_EXP 58
10226: PPUSH
10227: CALL_OW 250
10231: PPUSH
10232: LD_EXP 58
10236: PPUSH
10237: CALL_OW 251
10241: PPUSH
10242: LD_INT 7
10244: PPUSH
10245: LD_INT 8
10247: PPUSH
10248: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
10252: LD_EXP 58
10256: PPUSH
10257: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
10261: LD_EXP 28
10265: PPUSH
10266: LD_STRING D9-Frank-1
10268: PPUSH
10269: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
10273: LD_EXP 16
10277: PPUSH
10278: LD_STRING D9-JMM-1
10280: PPUSH
10281: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
10285: LD_EXP 28
10289: PPUSH
10290: LD_STRING D9-Frank-2
10292: PPUSH
10293: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
10297: LD_EXP 58
10301: PPUSH
10302: CALL_OW 250
10306: PPUSH
10307: LD_EXP 58
10311: PPUSH
10312: CALL_OW 251
10316: PPUSH
10317: LD_INT 7
10319: PPUSH
10320: CALL_OW 331
// end ; DialogueOff ;
10324: CALL_OW 7
// end ;
10328: PPOPN 1
10330: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
10331: LD_EXP 7
10335: PUSH
10336: LD_OWVAR 1
10340: PUSH
10341: LD_INT 42000
10343: GREATEREQUAL
10344: OR
10345: IFFALSE 11379
10347: GO 10349
10349: DISABLE
10350: LD_INT 0
10352: PPUSH
10353: PPUSH
// begin selected_option := 1 ;
10354: LD_ADDR_VAR 0 2
10358: PUSH
10359: LD_INT 1
10361: ST_TO_ADDR
// wait ( 5 5$00 ) ;
10362: LD_INT 10500
10364: PPUSH
10365: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10369: LD_INT 35
10371: PPUSH
10372: CALL_OW 67
// until not ru_attackers ;
10376: LD_EXP 54
10380: NOT
10381: IFFALSE 10369
// PrepareBurlak ;
10383: CALL 2360 0 0
// repeat wait ( 0 0$2 ) ;
10387: LD_INT 70
10389: PPUSH
10390: CALL_OW 67
// until not HasTask ( Burlak ) ;
10394: LD_EXP 48
10398: PPUSH
10399: CALL_OW 314
10403: NOT
10404: IFFALSE 10387
// InGameOn ;
10406: CALL_OW 8
// DialogueOn ;
10410: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
10414: LD_EXP 51
10418: PPUSH
10419: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
10423: LD_EXP 48
10427: PPUSH
10428: LD_STRING D10-Bur-1
10430: PPUSH
10431: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
10435: LD_EXP 49
10439: PUSH
10440: LD_EXP 49
10444: PPUSH
10445: CALL_OW 255
10449: PUSH
10450: LD_INT 7
10452: EQUAL
10453: AND
10454: IFFALSE 10468
// Say ( Belkov , D10-Bel-1 ) ;
10456: LD_EXP 49
10460: PPUSH
10461: LD_STRING D10-Bel-1
10463: PPUSH
10464: CALL_OW 88
// if Gossudarov then
10468: LD_EXP 34
10472: IFFALSE 10486
// Say ( Gossudarov , D10-Gos-1 ) ;
10474: LD_EXP 34
10478: PPUSH
10479: LD_STRING D10-Gos-1
10481: PPUSH
10482: CALL_OW 88
// if Kirilenkova then
10486: LD_EXP 35
10490: IFFALSE 10504
// Say ( Kirilenkova , D10-Kir-1 ) ;
10492: LD_EXP 35
10496: PPUSH
10497: LD_STRING D10-Kir-1
10499: PPUSH
10500: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10504: CALL 14010 0 0
10508: PPUSH
10509: LD_STRING D10-RSol1-1
10511: PPUSH
10512: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
10516: LD_EXP 48
10520: PPUSH
10521: LD_STRING D10-Bur-2
10523: PPUSH
10524: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
10528: LD_EXP 16
10532: PPUSH
10533: LD_STRING D10-JMM-2
10535: PPUSH
10536: CALL_OW 88
// if Kirilenkova then
10540: LD_EXP 35
10544: IFFALSE 10560
// Say ( Kirilenkova , D10-Kir-2 ) else
10546: LD_EXP 35
10550: PPUSH
10551: LD_STRING D10-Kir-2
10553: PPUSH
10554: CALL_OW 88
10558: GO 10572
// Say ( SolRu , D10-RSol1-2 ) ;
10560: CALL 14010 0 0
10564: PPUSH
10565: LD_STRING D10-RSol1-2
10567: PPUSH
10568: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
10572: LD_EXP 16
10576: PPUSH
10577: LD_STRING D10-JMM-3
10579: PPUSH
10580: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
10584: LD_EXP 48
10588: PPUSH
10589: LD_STRING D10-Bur-3
10591: PPUSH
10592: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
10596: LD_EXP 16
10600: PPUSH
10601: LD_STRING D10-JMM-4
10603: PPUSH
10604: CALL_OW 88
// DialogueOff ;
10608: CALL_OW 7
// InGameOff ;
10612: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
10616: LD_STRING M2
10618: PPUSH
10619: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10623: LD_INT 35
10625: PPUSH
10626: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
10630: LD_INT 22
10632: PUSH
10633: LD_INT 7
10635: PUSH
10636: EMPTY
10637: LIST
10638: LIST
10639: PUSH
10640: LD_INT 91
10642: PUSH
10643: LD_EXP 48
10647: PUSH
10648: LD_INT 8
10650: PUSH
10651: EMPTY
10652: LIST
10653: LIST
10654: LIST
10655: PUSH
10656: EMPTY
10657: LIST
10658: LIST
10659: PPUSH
10660: CALL_OW 69
10664: IFFALSE 10623
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
10666: LD_ADDR_VAR 0 1
10670: PUSH
10671: LD_INT 22
10673: PUSH
10674: LD_INT 4
10676: PUSH
10677: EMPTY
10678: LIST
10679: LIST
10680: PPUSH
10681: CALL_OW 69
10685: PUSH
10686: FOR_IN
10687: IFFALSE 10703
// SetSide ( i , 7 ) ;
10689: LD_VAR 0 1
10693: PPUSH
10694: LD_INT 7
10696: PPUSH
10697: CALL_OW 235
10701: GO 10686
10703: POP
10704: POP
// ChangeMissionObjectives ( M3 ) ;
10705: LD_STRING M3
10707: PPUSH
10708: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10712: LD_INT 35
10714: PPUSH
10715: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
10719: LD_EXP 16
10723: PPUSH
10724: LD_EXP 48
10728: PPUSH
10729: CALL_OW 296
10733: PUSH
10734: LD_INT 8
10736: LESS
10737: IFFALSE 10712
// ComTurnUnit ( JMM , Burlak ) ;
10739: LD_EXP 16
10743: PPUSH
10744: LD_EXP 48
10748: PPUSH
10749: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
10753: LD_EXP 48
10757: PPUSH
10758: LD_EXP 16
10762: PPUSH
10763: CALL_OW 119
// wait ( 0 0$0.3 ) ;
10767: LD_INT 10
10769: PPUSH
10770: CALL_OW 67
// DialogueOn ;
10774: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
10778: LD_EXP 16
10782: PPUSH
10783: LD_STRING D11-JMM-1
10785: PPUSH
10786: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
10790: LD_EXP 48
10794: PPUSH
10795: LD_STRING D11-Bur-1
10797: PPUSH
10798: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
10802: LD_EXP 16
10806: PPUSH
10807: LD_STRING D11-JMM-2
10809: PPUSH
10810: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
10814: LD_EXP 48
10818: PPUSH
10819: LD_STRING D11-Bur-2
10821: PPUSH
10822: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
10826: LD_EXP 16
10830: PPUSH
10831: LD_STRING D11-JMM-3
10833: PPUSH
10834: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
10838: LD_EXP 48
10842: PPUSH
10843: LD_STRING D11-Bur-3
10845: PPUSH
10846: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10850: LD_EXP 16
10854: PPUSH
10855: LD_STRING D11-JMM-4
10857: PPUSH
10858: CALL_OW 88
// if ar_base_spotted then
10862: LD_EXP 8
10866: IFFALSE 10882
// Say ( Burlak , D12-Bur-1 ) else
10868: LD_EXP 48
10872: PPUSH
10873: LD_STRING D12-Bur-1
10875: PPUSH
10876: CALL_OW 88
10880: GO 10921
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10882: LD_INT 7
10884: PPUSH
10885: LD_INT 3
10887: PPUSH
10888: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10892: LD_INT 127
10894: PPUSH
10895: LD_INT 45
10897: PPUSH
10898: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10902: LD_EXP 48
10906: PPUSH
10907: LD_STRING D12-Bur-1a
10909: PPUSH
10910: CALL_OW 88
// dwait ( 0 0$2 ) ;
10914: LD_INT 70
10916: PPUSH
10917: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10921: LD_EXP 48
10925: PPUSH
10926: LD_STRING D12-Bur-1b
10928: PPUSH
10929: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10933: LD_EXP 16
10937: PPUSH
10938: LD_STRING D12-JMM-1
10940: PPUSH
10941: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10945: LD_EXP 48
10949: PPUSH
10950: LD_STRING D12-Bur-2
10952: PPUSH
10953: CALL_OW 88
// if Roth then
10957: LD_EXP 17
10961: IFFALSE 10977
// Say ( Roth , D12-Roth-2 ) else
10963: LD_EXP 17
10967: PPUSH
10968: LD_STRING D12-Roth-2
10970: PPUSH
10971: CALL_OW 88
10975: GO 10989
// Say ( SciRu , D12-RSci1-2 ) ;
10977: CALL 13863 0 0
10981: PPUSH
10982: LD_STRING D12-RSci1-2
10984: PPUSH
10985: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10989: LD_EXP 16
10993: PPUSH
10994: LD_STRING D12-JMM-2
10996: PPUSH
10997: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
11001: LD_EXP 48
11005: PPUSH
11006: LD_STRING D12-Bur-3
11008: PPUSH
11009: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
11013: LD_EXP 16
11017: PPUSH
11018: LD_STRING D12-JMM-3
11020: PPUSH
11021: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
11025: LD_EXP 48
11029: PPUSH
11030: LD_STRING D12-Bur-4
11032: PPUSH
11033: CALL_OW 88
// case Query ( QBase ) of 1 :
11037: LD_STRING QBase
11039: PPUSH
11040: CALL_OW 97
11044: PUSH
11045: LD_INT 1
11047: DOUBLE
11048: EQUAL
11049: IFTRUE 11053
11051: GO 11171
11053: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
11054: LD_EXP 16
11058: PPUSH
11059: LD_STRING D13a-JMM-1
11061: PPUSH
11062: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
11066: LD_EXP 48
11070: PPUSH
11071: LD_STRING D13a-Bur-1
11073: PPUSH
11074: CALL_OW 88
// if Roth then
11078: LD_EXP 17
11082: IFFALSE 11098
// Say ( Roth , D13a-Roth-1 ) else
11084: LD_EXP 17
11088: PPUSH
11089: LD_STRING D13a-Roth-1
11091: PPUSH
11092: CALL_OW 88
11096: GO 11110
// Say ( SciRu , D13a-RSci1-1 ) ;
11098: CALL 13863 0 0
11102: PPUSH
11103: LD_STRING D13a-RSci1-1
11105: PPUSH
11106: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
11110: LD_EXP 16
11114: PPUSH
11115: LD_STRING D13a-JMM-2
11117: PPUSH
11118: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
11122: LD_STRING QBaseAgain
11124: PPUSH
11125: CALL_OW 97
11129: PUSH
11130: LD_INT 1
11132: DOUBLE
11133: EQUAL
11134: IFTRUE 11138
11136: GO 11149
11138: POP
// selected_option := 2 ; 2 :
11139: LD_ADDR_VAR 0 2
11143: PUSH
11144: LD_INT 2
11146: ST_TO_ADDR
11147: GO 11169
11149: LD_INT 2
11151: DOUBLE
11152: EQUAL
11153: IFTRUE 11157
11155: GO 11168
11157: POP
// selected_option := 3 ; end ;
11158: LD_ADDR_VAR 0 2
11162: PUSH
11163: LD_INT 3
11165: ST_TO_ADDR
11166: GO 11169
11168: POP
// end ; 2 :
11169: GO 11210
11171: LD_INT 2
11173: DOUBLE
11174: EQUAL
11175: IFTRUE 11179
11177: GO 11190
11179: POP
// selected_option := 2 ; 3 :
11180: LD_ADDR_VAR 0 2
11184: PUSH
11185: LD_INT 2
11187: ST_TO_ADDR
11188: GO 11210
11190: LD_INT 3
11192: DOUBLE
11193: EQUAL
11194: IFTRUE 11198
11196: GO 11209
11198: POP
// selected_option := 3 ; end ;
11199: LD_ADDR_VAR 0 2
11203: PUSH
11204: LD_INT 3
11206: ST_TO_ADDR
11207: GO 11210
11209: POP
// if selected_option = 2 then
11210: LD_VAR 0 2
11214: PUSH
11215: LD_INT 2
11217: EQUAL
11218: IFFALSE 11312
// begin Say ( JMM , D13b-JMM-1 ) ;
11220: LD_EXP 16
11224: PPUSH
11225: LD_STRING D13b-JMM-1
11227: PPUSH
11228: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
11232: LD_EXP 48
11236: PPUSH
11237: LD_STRING D13b-Bur-1
11239: PPUSH
11240: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
11244: LD_EXP 16
11248: PPUSH
11249: LD_STRING D13b-JMM-2
11251: PPUSH
11252: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
11256: LD_EXP 57
11260: PPUSH
11261: LD_STRING D13b-Abd-2
11263: PPUSH
11264: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
11268: LD_EXP 16
11272: PPUSH
11273: LD_STRING D13b-JMM-3
11275: PPUSH
11276: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
11280: LD_EXP 57
11284: PPUSH
11285: LD_STRING D13b-Abd-3
11287: PPUSH
11288: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
11292: LD_EXP 16
11296: PPUSH
11297: LD_STRING D13b-JMM-4
11299: PPUSH
11300: CALL_OW 88
// ar_active_attack := true ;
11304: LD_ADDR_EXP 9
11308: PUSH
11309: LD_INT 1
11311: ST_TO_ADDR
// end ; if selected_option = 3 then
11312: LD_VAR 0 2
11316: PUSH
11317: LD_INT 3
11319: EQUAL
11320: IFFALSE 11346
// begin Say ( JMM , D13c-JMM-1 ) ;
11322: LD_EXP 16
11326: PPUSH
11327: LD_STRING D13c-JMM-1
11329: PPUSH
11330: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
11334: LD_EXP 48
11338: PPUSH
11339: LD_STRING D13c-Bur-1
11341: PPUSH
11342: CALL_OW 88
// end ; DialogueOff ;
11346: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
11350: LD_STRING M4
11352: PPUSH
11353: CALL_OW 337
// if not ar_active_attack then
11357: LD_EXP 9
11361: NOT
11362: IFFALSE 11379
// begin wait ( 6 6$00 ) ;
11364: LD_INT 12600
11366: PPUSH
11367: CALL_OW 67
// ar_active_attack := true ;
11371: LD_ADDR_EXP 9
11375: PUSH
11376: LD_INT 1
11378: ST_TO_ADDR
// end ; end ;
11379: PPOPN 2
11381: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
11382: LD_EXP 48
11386: PPUSH
11387: CALL_OW 305
11391: PUSH
11392: LD_EXP 48
11396: PPUSH
11397: CALL_OW 255
11401: PUSH
11402: LD_INT 7
11404: EQUAL
11405: AND
11406: IFFALSE 11602
11408: GO 11410
11410: DISABLE
11411: LD_INT 0
11413: PPUSH
// begin wait ( 4 4$40 ) ;
11414: LD_INT 9800
11416: PPUSH
11417: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11421: LD_INT 35
11423: PPUSH
11424: CALL_OW 67
// until not ru_attackers ;
11428: LD_EXP 54
11432: NOT
11433: IFFALSE 11421
// PrepareGnyevko ;
11435: CALL 2304 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
11439: LD_EXP 50
11443: PPUSH
11444: LD_INT 124
11446: PPUSH
11447: LD_INT 118
11449: PPUSH
11450: CALL_OW 111
// AddComHold ( Gnyevko ) ;
11454: LD_EXP 50
11458: PPUSH
11459: CALL_OW 200
// time := 0 0$00 ;
11463: LD_ADDR_VAR 0 1
11467: PUSH
11468: LD_INT 0
11470: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11471: LD_INT 35
11473: PPUSH
11474: CALL_OW 67
// time := time + 0 0$1 ;
11478: LD_ADDR_VAR 0 1
11482: PUSH
11483: LD_VAR 0 1
11487: PUSH
11488: LD_INT 35
11490: PLUS
11491: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
11492: LD_EXP 50
11496: PPUSH
11497: LD_INT 124
11499: PPUSH
11500: LD_INT 118
11502: PPUSH
11503: CALL_OW 307
11507: PUSH
11508: LD_VAR 0 1
11512: PUSH
11513: LD_INT 1050
11515: GREATEREQUAL
11516: OR
11517: IFFALSE 11471
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
11519: LD_EXP 50
11523: PPUSH
11524: LD_STRING DBelkov-Gny-1
11526: PPUSH
11527: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
11531: LD_EXP 48
11535: PPUSH
11536: LD_STRING DBelkov-Bur-1a
11538: PPUSH
11539: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11543: LD_INT 35
11545: PPUSH
11546: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
11550: LD_EXP 50
11554: PPUSH
11555: LD_INT 22
11557: PUSH
11558: LD_INT 7
11560: PUSH
11561: EMPTY
11562: LIST
11563: LIST
11564: PPUSH
11565: CALL_OW 69
11569: PPUSH
11570: LD_EXP 50
11574: PPUSH
11575: CALL_OW 74
11579: PPUSH
11580: CALL_OW 296
11584: PUSH
11585: LD_INT 8
11587: LESS
11588: IFFALSE 11543
// SetSide ( Gnyevko , 7 ) ;
11590: LD_EXP 50
11594: PPUSH
11595: LD_INT 7
11597: PPUSH
11598: CALL_OW 235
// end ;
11602: PPOPN 1
11604: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
11605: LD_EXP 48
11609: PPUSH
11610: CALL_OW 255
11614: PUSH
11615: LD_INT 7
11617: EQUAL
11618: IFFALSE 11628
11620: GO 11622
11622: DISABLE
// begin enable ;
11623: ENABLE
// PrepareAmericanAttack ;
11624: CALL 7263 0 0
// end ;
11628: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
11629: LD_INT 22
11631: PUSH
11632: LD_INT 1
11634: PUSH
11635: EMPTY
11636: LIST
11637: LIST
11638: PPUSH
11639: CALL_OW 69
11643: IFFALSE 11827
11645: GO 11647
11647: DISABLE
11648: LD_INT 0
11650: PPUSH
11651: PPUSH
// begin while true do
11652: LD_INT 1
11654: IFFALSE 11711
// begin wait ( 0 0$1 ) ;
11656: LD_INT 35
11658: PPUSH
11659: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
11663: LD_ADDR_VAR 0 2
11667: PUSH
11668: LD_INT 22
11670: PUSH
11671: LD_INT 1
11673: PUSH
11674: EMPTY
11675: LIST
11676: LIST
11677: PPUSH
11678: CALL_OW 69
11682: PPUSH
11683: LD_EXP 16
11687: PPUSH
11688: CALL_OW 74
11692: ST_TO_ADDR
// if See ( 7 , tmp ) then
11693: LD_INT 7
11695: PPUSH
11696: LD_VAR 0 2
11700: PPUSH
11701: CALL_OW 292
11705: IFFALSE 11709
// break ;
11707: GO 11711
// end ;
11709: GO 11652
// DialogueOn ;
11711: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
11715: LD_VAR 0 2
11719: PPUSH
11720: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
11724: LD_VAR 0 2
11728: PPUSH
11729: CALL_OW 250
11733: PPUSH
11734: LD_VAR 0 2
11738: PPUSH
11739: CALL_OW 251
11743: PPUSH
11744: LD_INT 7
11746: PPUSH
11747: LD_INT 8
11749: PPUSH
11750: CALL_OW 330
// if Denis then
11754: LD_EXP 22
11758: IFFALSE 11772
// Say ( Denis , DAmerAttack-Pet-1 ) ;
11760: LD_EXP 22
11764: PPUSH
11765: LD_STRING DAmerAttack-Pet-1
11767: PPUSH
11768: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
11772: LD_EXP 16
11776: PPUSH
11777: LD_STRING DAmerAttack-JMM-1
11779: PPUSH
11780: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
11784: LD_EXP 48
11788: PPUSH
11789: LD_STRING DStop-Bur-1
11791: PPUSH
11792: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
11796: LD_VAR 0 2
11800: PPUSH
11801: CALL_OW 250
11805: PPUSH
11806: LD_VAR 0 2
11810: PPUSH
11811: CALL_OW 251
11815: PPUSH
11816: LD_INT 7
11818: PPUSH
11819: CALL_OW 331
// DialogueOff ;
11823: CALL_OW 7
// end ;
11827: PPOPN 2
11829: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11830: LD_INT 22
11832: PUSH
11833: LD_INT 3
11835: PUSH
11836: EMPTY
11837: LIST
11838: LIST
11839: PUSH
11840: LD_INT 21
11842: PUSH
11843: LD_INT 1
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: PPUSH
11854: CALL_OW 69
11858: PUSH
11859: LD_INT 0
11861: EQUAL
11862: IFFALSE 11904
11864: GO 11866
11866: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11867: LD_STRING M5a
11869: PPUSH
11870: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11874: LD_EXP 16
11878: PPUSH
11879: LD_STRING D8-JMM-1
11881: PPUSH
11882: CALL_OW 88
// if Gossudarov then
11886: LD_EXP 34
11890: IFFALSE 11904
// Say ( Gossudarov , D8-Gos-1 ) ;
11892: LD_EXP 34
11896: PPUSH
11897: LD_STRING D8-Gos-1
11899: PPUSH
11900: CALL_OW 88
// end ;
11904: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11905: LD_INT 22
11907: PUSH
11908: LD_INT 2
11910: PUSH
11911: EMPTY
11912: LIST
11913: LIST
11914: PUSH
11915: LD_INT 21
11917: PUSH
11918: LD_INT 1
11920: PUSH
11921: EMPTY
11922: LIST
11923: LIST
11924: PUSH
11925: EMPTY
11926: LIST
11927: LIST
11928: PPUSH
11929: CALL_OW 69
11933: PUSH
11934: LD_INT 0
11936: EQUAL
11937: IFFALSE 11987
11939: GO 11941
11941: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11942: LD_STRING M4c
11944: PPUSH
11945: CALL_OW 337
// if Roth then
11949: LD_EXP 17
11953: IFFALSE 11969
// Say ( Roth , DStop-Roth-1 ) else
11955: LD_EXP 17
11959: PPUSH
11960: LD_STRING DStop-Roth-1
11962: PPUSH
11963: CALL_OW 88
11967: GO 11987
// if Gossudarov then
11969: LD_EXP 34
11973: IFFALSE 11987
// Say ( Gossudarov , D8-Gos-1a ) ;
11975: LD_EXP 34
11979: PPUSH
11980: LD_STRING D8-Gos-1a
11982: PPUSH
11983: CALL_OW 88
// end ;
11987: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11988: LD_INT 7
11990: PPUSH
11991: LD_INT 1
11993: PPUSH
11994: LD_INT 1
11996: PPUSH
11997: CALL 15542 0 3
12001: PUSH
12002: LD_INT 0
12004: EQUAL
12005: PUSH
12006: LD_INT 7
12008: PPUSH
12009: LD_INT 3
12011: PPUSH
12012: LD_INT 1
12014: PPUSH
12015: CALL 15542 0 3
12019: PUSH
12020: LD_INT 0
12022: EQUAL
12023: AND
12024: IFFALSE 12036
12026: GO 12028
12028: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
12029: LD_STRING M1a
12031: PPUSH
12032: CALL_OW 337
// end ;
12036: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
12037: LD_INT 22
12039: PUSH
12040: LD_INT 2
12042: PUSH
12043: EMPTY
12044: LIST
12045: LIST
12046: PUSH
12047: LD_INT 21
12049: PUSH
12050: LD_INT 1
12052: PUSH
12053: EMPTY
12054: LIST
12055: LIST
12056: PUSH
12057: EMPTY
12058: LIST
12059: LIST
12060: PPUSH
12061: CALL_OW 69
12065: PUSH
12066: LD_INT 0
12068: EQUAL
12069: PUSH
12070: LD_INT 22
12072: PUSH
12073: LD_INT 3
12075: PUSH
12076: EMPTY
12077: LIST
12078: LIST
12079: PUSH
12080: LD_INT 21
12082: PUSH
12083: LD_INT 1
12085: PUSH
12086: EMPTY
12087: LIST
12088: LIST
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: PPUSH
12094: CALL_OW 69
12098: PUSH
12099: LD_INT 0
12101: EQUAL
12102: AND
12103: PUSH
12104: LD_INT 22
12106: PUSH
12107: LD_INT 1
12109: PUSH
12110: EMPTY
12111: LIST
12112: LIST
12113: PPUSH
12114: CALL_OW 69
12118: PUSH
12119: LD_INT 0
12121: EQUAL
12122: AND
12123: PUSH
12124: LD_INT 7
12126: PPUSH
12127: LD_INT 1
12129: PPUSH
12130: LD_INT 1
12132: PPUSH
12133: CALL 15542 0 3
12137: PUSH
12138: LD_INT 0
12140: EQUAL
12141: AND
12142: PUSH
12143: LD_INT 7
12145: PPUSH
12146: LD_INT 3
12148: PPUSH
12149: LD_INT 1
12151: PPUSH
12152: CALL 15542 0 3
12156: PUSH
12157: LD_INT 0
12159: EQUAL
12160: AND
12161: PUSH
12162: LD_EXP 48
12166: PPUSH
12167: CALL_OW 255
12171: PUSH
12172: LD_INT 7
12174: EQUAL
12175: AND
12176: PUSH
12177: LD_EXP 48
12181: PPUSH
12182: CALL_OW 302
12186: AND
12187: IFFALSE 13860
12189: GO 12191
12191: DISABLE
12192: LD_INT 0
12194: PPUSH
12195: PPUSH
12196: PPUSH
12197: PPUSH
12198: PPUSH
12199: PPUSH
// begin m1 := false ;
12200: LD_ADDR_VAR 0 4
12204: PUSH
12205: LD_INT 0
12207: ST_TO_ADDR
// m2 := false ;
12208: LD_ADDR_VAR 0 5
12212: PUSH
12213: LD_INT 0
12215: ST_TO_ADDR
// m3 := false ;
12216: LD_ADDR_VAR 0 6
12220: PUSH
12221: LD_INT 0
12223: ST_TO_ADDR
// if tick < 40 40$00 then
12224: LD_OWVAR 1
12228: PUSH
12229: LD_INT 84000
12231: LESS
12232: IFFALSE 12241
// SetAchievement ( ACH_ASPEED_17 ) ;
12234: LD_STRING ACH_ASPEED_17
12236: PPUSH
12237: CALL_OW 543
// wait ( 0 0$5 ) ;
12241: LD_INT 175
12243: PPUSH
12244: CALL_OW 67
// if not masha_killed then
12248: LD_EXP 10
12252: NOT
12253: IFFALSE 12275
// begin m1 := true ;
12255: LD_ADDR_VAR 0 4
12259: PUSH
12260: LD_INT 1
12262: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
12263: LD_STRING Masha
12265: PPUSH
12266: LD_INT 1
12268: PPUSH
12269: CALL_OW 101
// end else
12273: GO 12286
// AddMedal ( Masha , - 1 ) ;
12275: LD_STRING Masha
12277: PPUSH
12278: LD_INT 1
12280: NEG
12281: PPUSH
12282: CALL_OW 101
// if abdul_escaped then
12286: LD_EXP 13
12290: IFFALSE 12305
// AddMedal ( Abdul , - 1 ) else
12292: LD_STRING Abdul
12294: PPUSH
12295: LD_INT 1
12297: NEG
12298: PPUSH
12299: CALL_OW 101
12303: GO 12323
// begin m2 := true ;
12305: LD_ADDR_VAR 0 5
12309: PUSH
12310: LD_INT 1
12312: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
12313: LD_STRING Abdul
12315: PPUSH
12316: LD_INT 1
12318: PPUSH
12319: CALL_OW 101
// end ; if loss_counter = 0 then
12323: LD_EXP 14
12327: PUSH
12328: LD_INT 0
12330: EQUAL
12331: IFFALSE 12353
// begin m3 := true ;
12333: LD_ADDR_VAR 0 6
12337: PUSH
12338: LD_INT 1
12340: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
12341: LD_STRING People
12343: PPUSH
12344: LD_INT 2
12346: PPUSH
12347: CALL_OW 101
// end else
12351: GO 12415
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
12353: LD_EXP 14
12357: PUSH
12358: LD_INT 3
12360: PUSH
12361: LD_INT 2
12363: PUSH
12364: LD_INT 2
12366: PUSH
12367: LD_INT 1
12369: PUSH
12370: EMPTY
12371: LIST
12372: LIST
12373: LIST
12374: LIST
12375: PUSH
12376: LD_OWVAR 67
12380: ARRAY
12381: LESSEQUAL
12382: IFFALSE 12404
// begin AddMedal ( People , 1 ) ;
12384: LD_STRING People
12386: PPUSH
12387: LD_INT 1
12389: PPUSH
12390: CALL_OW 101
// m3 := true ;
12394: LD_ADDR_VAR 0 6
12398: PUSH
12399: LD_INT 1
12401: ST_TO_ADDR
// end else
12402: GO 12415
// AddMedal ( People , - 1 ) ;
12404: LD_STRING People
12406: PPUSH
12407: LD_INT 1
12409: NEG
12410: PPUSH
12411: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
12415: LD_OWVAR 67
12419: PUSH
12420: LD_INT 3
12422: GREATEREQUAL
12423: PUSH
12424: LD_VAR 0 4
12428: AND
12429: PUSH
12430: LD_VAR 0 5
12434: AND
12435: PUSH
12436: LD_VAR 0 6
12440: AND
12441: IFFALSE 12453
// SetAchievementEX ( ACH_AMER , 17 ) ;
12443: LD_STRING ACH_AMER
12445: PPUSH
12446: LD_INT 17
12448: PPUSH
12449: CALL_OW 564
// GiveMedals ( MAIN ) ;
12453: LD_STRING MAIN
12455: PPUSH
12456: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
12460: LD_ADDR_VAR 0 2
12464: PUSH
12465: LD_INT 22
12467: PUSH
12468: LD_INT 7
12470: PUSH
12471: EMPTY
12472: LIST
12473: LIST
12474: PUSH
12475: LD_INT 50
12477: PUSH
12478: EMPTY
12479: LIST
12480: PUSH
12481: LD_INT 2
12483: PUSH
12484: LD_INT 25
12486: PUSH
12487: LD_INT 1
12489: PUSH
12490: EMPTY
12491: LIST
12492: LIST
12493: PUSH
12494: LD_INT 25
12496: PUSH
12497: LD_INT 2
12499: PUSH
12500: EMPTY
12501: LIST
12502: LIST
12503: PUSH
12504: LD_INT 25
12506: PUSH
12507: LD_INT 3
12509: PUSH
12510: EMPTY
12511: LIST
12512: LIST
12513: PUSH
12514: LD_INT 25
12516: PUSH
12517: LD_INT 4
12519: PUSH
12520: EMPTY
12521: LIST
12522: LIST
12523: PUSH
12524: LD_INT 25
12526: PUSH
12527: LD_INT 5
12529: PUSH
12530: EMPTY
12531: LIST
12532: LIST
12533: PUSH
12534: LD_INT 25
12536: PUSH
12537: LD_INT 8
12539: PUSH
12540: EMPTY
12541: LIST
12542: LIST
12543: PUSH
12544: LD_INT 25
12546: PUSH
12547: LD_INT 9
12549: PUSH
12550: EMPTY
12551: LIST
12552: LIST
12553: PUSH
12554: EMPTY
12555: LIST
12556: LIST
12557: LIST
12558: LIST
12559: LIST
12560: LIST
12561: LIST
12562: LIST
12563: PUSH
12564: EMPTY
12565: LIST
12566: LIST
12567: LIST
12568: PPUSH
12569: CALL_OW 69
12573: ST_TO_ADDR
// RewardPeople ( tmp ) ;
12574: LD_VAR 0 2
12578: PPUSH
12579: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
12583: LD_ADDR_VAR 0 3
12587: PUSH
12588: LD_EXP 16
12592: PUSH
12593: LD_EXP 17
12597: PUSH
12598: LD_EXP 18
12602: PUSH
12603: LD_EXP 19
12607: PUSH
12608: LD_EXP 20
12612: PUSH
12613: LD_EXP 21
12617: PUSH
12618: LD_EXP 22
12622: PUSH
12623: LD_EXP 23
12627: PUSH
12628: LD_EXP 24
12632: PUSH
12633: LD_EXP 25
12637: PUSH
12638: LD_EXP 26
12642: PUSH
12643: LD_EXP 27
12647: PUSH
12648: LD_EXP 28
12652: PUSH
12653: LD_EXP 29
12657: PUSH
12658: LD_EXP 30
12662: PUSH
12663: LD_EXP 31
12667: PUSH
12668: LD_EXP 32
12672: PUSH
12673: LD_EXP 34
12677: PUSH
12678: LD_EXP 35
12682: PUSH
12683: LD_EXP 36
12687: PUSH
12688: LD_EXP 38
12692: PUSH
12693: LD_EXP 39
12697: PUSH
12698: LD_EXP 40
12702: PUSH
12703: LD_EXP 41
12707: PUSH
12708: LD_EXP 42
12712: PUSH
12713: LD_EXP 43
12717: PUSH
12718: LD_EXP 44
12722: PUSH
12723: LD_EXP 45
12727: PUSH
12728: LD_EXP 46
12732: PUSH
12733: LD_EXP 47
12737: PUSH
12738: LD_EXP 48
12742: PUSH
12743: LD_EXP 49
12747: PUSH
12748: LD_EXP 50
12752: PUSH
12753: LD_EXP 33
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: LIST
12762: LIST
12763: LIST
12764: LIST
12765: LIST
12766: LIST
12767: LIST
12768: LIST
12769: LIST
12770: LIST
12771: LIST
12772: LIST
12773: LIST
12774: LIST
12775: LIST
12776: LIST
12777: LIST
12778: LIST
12779: LIST
12780: LIST
12781: LIST
12782: LIST
12783: LIST
12784: LIST
12785: LIST
12786: LIST
12787: LIST
12788: LIST
12789: LIST
12790: LIST
12791: LIST
12792: LIST
12793: ST_TO_ADDR
// if tmp diff tmp2 then
12794: LD_VAR 0 2
12798: PUSH
12799: LD_VAR 0 3
12803: DIFF
12804: IFFALSE 12824
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
12806: LD_VAR 0 2
12810: PUSH
12811: LD_VAR 0 3
12815: DIFF
12816: PPUSH
12817: LD_STRING 13a_others
12819: PPUSH
12820: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
12824: LD_EXP 16
12828: PPUSH
12829: LD_STRING 13a_JMM
12831: PPUSH
12832: CALL_OW 38
// if IsOk ( Mike ) then
12836: LD_EXP 33
12840: PPUSH
12841: CALL_OW 302
12845: IFFALSE 12859
// SaveCharacters ( Mike , 13a_Mike ) ;
12847: LD_EXP 33
12851: PPUSH
12852: LD_STRING 13a_Mike
12854: PPUSH
12855: CALL_OW 38
// if IsOk ( Titov ) then
12859: LD_EXP 36
12863: PPUSH
12864: CALL_OW 302
12868: IFFALSE 12882
// SaveCharacters ( Titov , 13a_Titov ) ;
12870: LD_EXP 36
12874: PPUSH
12875: LD_STRING 13a_Titov
12877: PPUSH
12878: CALL_OW 38
// if IsOk ( Dolgov ) then
12882: LD_EXP 38
12886: PPUSH
12887: CALL_OW 302
12891: IFFALSE 12905
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
12893: LD_EXP 38
12897: PPUSH
12898: LD_STRING 13a_Dolgov
12900: PPUSH
12901: CALL_OW 38
// if IsOk ( Petrosyan ) then
12905: LD_EXP 39
12909: PPUSH
12910: CALL_OW 302
12914: IFFALSE 12928
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
12916: LD_EXP 39
12920: PPUSH
12921: LD_STRING 13a_Petrosyan
12923: PPUSH
12924: CALL_OW 38
// if IsOk ( Scholtze ) then
12928: LD_EXP 40
12932: PPUSH
12933: CALL_OW 302
12937: IFFALSE 12951
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12939: LD_EXP 40
12943: PPUSH
12944: LD_STRING 13a_Scholtze
12946: PPUSH
12947: CALL_OW 38
// if IsOk ( Oblukov ) then
12951: LD_EXP 41
12955: PPUSH
12956: CALL_OW 302
12960: IFFALSE 12974
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12962: LD_EXP 41
12966: PPUSH
12967: LD_STRING 13a_Oblukov
12969: PPUSH
12970: CALL_OW 38
// if IsOk ( Kapitsova ) then
12974: LD_EXP 42
12978: PPUSH
12979: CALL_OW 302
12983: IFFALSE 12997
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
12985: LD_EXP 42
12989: PPUSH
12990: LD_STRING 13a_Kapitsova
12992: PPUSH
12993: CALL_OW 38
// if IsOk ( Lipshchin ) then
12997: LD_EXP 43
13001: PPUSH
13002: CALL_OW 302
13006: IFFALSE 13020
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
13008: LD_EXP 43
13012: PPUSH
13013: LD_STRING 13a_Lipshchin
13015: PPUSH
13016: CALL_OW 38
// if IsOk ( Petrovova ) then
13020: LD_EXP 44
13024: PPUSH
13025: CALL_OW 302
13029: IFFALSE 13043
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
13031: LD_EXP 44
13035: PPUSH
13036: LD_STRING 13a_Petrovova
13038: PPUSH
13039: CALL_OW 38
// if IsOk ( Kovalyuk ) then
13043: LD_EXP 45
13047: PPUSH
13048: CALL_OW 302
13052: IFFALSE 13066
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
13054: LD_EXP 45
13058: PPUSH
13059: LD_STRING 13a_Kovalyuk
13061: PPUSH
13062: CALL_OW 38
// if IsOk ( Kuzmov ) then
13066: LD_EXP 46
13070: PPUSH
13071: CALL_OW 302
13075: IFFALSE 13089
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
13077: LD_EXP 46
13081: PPUSH
13082: LD_STRING 13a_Kuzmov
13084: PPUSH
13085: CALL_OW 38
// if IsOk ( Karamazov ) then
13089: LD_EXP 47
13093: PPUSH
13094: CALL_OW 302
13098: IFFALSE 13112
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
13100: LD_EXP 47
13104: PPUSH
13105: LD_STRING 13a_Karamazov
13107: PPUSH
13108: CALL_OW 38
// if Burlak then
13112: LD_EXP 48
13116: IFFALSE 13137
// begin ToLua ( enableBioCharacter(BIO_GORKI) ) ;
13118: LD_STRING enableBioCharacter(BIO_GORKI)
13120: PPUSH
13121: CALL_OW 559
// SaveCharacters ( Burlak , 13a_Burlak ) ;
13125: LD_EXP 48
13129: PPUSH
13130: LD_STRING 13a_Burlak
13132: PPUSH
13133: CALL_OW 38
// end ; if IsOk ( Belkov ) then
13137: LD_EXP 49
13141: PPUSH
13142: CALL_OW 302
13146: IFFALSE 13160
// SaveCharacters ( Belkov , 13a_Belkov ) ;
13148: LD_EXP 49
13152: PPUSH
13153: LD_STRING 13a_Belkov
13155: PPUSH
13156: CALL_OW 38
// if IsOk ( Gnyevko ) then
13160: LD_EXP 50
13164: PPUSH
13165: CALL_OW 302
13169: IFFALSE 13183
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
13171: LD_EXP 50
13175: PPUSH
13176: LD_STRING 13a_Gnyevko
13178: PPUSH
13179: CALL_OW 38
// if IsOk ( Lisa ) then
13183: LD_EXP 18
13187: PPUSH
13188: CALL_OW 302
13192: IFFALSE 13206
// SaveCharacters ( Lisa , 13a_Lisa ) ;
13194: LD_EXP 18
13198: PPUSH
13199: LD_STRING 13a_Lisa
13201: PPUSH
13202: CALL_OW 38
// if IsOk ( Donaldson ) then
13206: LD_EXP 19
13210: PPUSH
13211: CALL_OW 302
13215: IFFALSE 13229
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
13217: LD_EXP 19
13221: PPUSH
13222: LD_STRING 13a_Donaldson
13224: PPUSH
13225: CALL_OW 38
// if IsOk ( Bobby ) then
13229: LD_EXP 20
13233: PPUSH
13234: CALL_OW 302
13238: IFFALSE 13252
// SaveCharacters ( Bobby , 13a_Bobby ) ;
13240: LD_EXP 20
13244: PPUSH
13245: LD_STRING 13a_Bobby
13247: PPUSH
13248: CALL_OW 38
// if IsOk ( Cyrus ) then
13252: LD_EXP 21
13256: PPUSH
13257: CALL_OW 302
13261: IFFALSE 13275
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
13263: LD_EXP 21
13267: PPUSH
13268: LD_STRING 13a_Cyrus
13270: PPUSH
13271: CALL_OW 38
// if IsOk ( Denis ) then
13275: LD_EXP 22
13279: PPUSH
13280: CALL_OW 302
13284: IFFALSE 13298
// SaveCharacters ( Denis , 13a_Denis ) ;
13286: LD_EXP 22
13290: PPUSH
13291: LD_STRING 13a_Denis
13293: PPUSH
13294: CALL_OW 38
// if IsOk ( Brown ) then
13298: LD_EXP 23
13302: PPUSH
13303: CALL_OW 302
13307: IFFALSE 13321
// SaveCharacters ( Brown , 13a_Brown ) ;
13309: LD_EXP 23
13313: PPUSH
13314: LD_STRING 13a_Brown
13316: PPUSH
13317: CALL_OW 38
// if IsOk ( Gladstone ) then
13321: LD_EXP 24
13325: PPUSH
13326: CALL_OW 302
13330: IFFALSE 13344
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
13332: LD_EXP 24
13336: PPUSH
13337: LD_STRING 13a_Gladstone
13339: PPUSH
13340: CALL_OW 38
// if IsOk ( Houten ) then
13344: LD_EXP 25
13348: PPUSH
13349: CALL_OW 302
13353: IFFALSE 13367
// SaveCharacters ( Houten , 13a_Houten ) ;
13355: LD_EXP 25
13359: PPUSH
13360: LD_STRING 13a_Houten
13362: PPUSH
13363: CALL_OW 38
// if IsOk ( Cornel ) then
13367: LD_EXP 26
13371: PPUSH
13372: CALL_OW 302
13376: IFFALSE 13390
// SaveCharacters ( Cornel , 13a_Cornel ) ;
13378: LD_EXP 26
13382: PPUSH
13383: LD_STRING 13a_Cornel
13385: PPUSH
13386: CALL_OW 38
// if IsOk ( Gary ) then
13390: LD_EXP 27
13394: PPUSH
13395: CALL_OW 302
13399: IFFALSE 13413
// SaveCharacters ( Gary , 13a_Gary ) ;
13401: LD_EXP 27
13405: PPUSH
13406: LD_STRING 13a_Gary
13408: PPUSH
13409: CALL_OW 38
// if IsOk ( Frank ) then
13413: LD_EXP 28
13417: PPUSH
13418: CALL_OW 302
13422: IFFALSE 13436
// SaveCharacters ( Frank , 13a_Frank ) ;
13424: LD_EXP 28
13428: PPUSH
13429: LD_STRING 13a_Frank
13431: PPUSH
13432: CALL_OW 38
// if IsOk ( Kikuchi ) then
13436: LD_EXP 29
13440: PPUSH
13441: CALL_OW 302
13445: IFFALSE 13459
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
13447: LD_EXP 29
13451: PPUSH
13452: LD_STRING 13a_Kikuchi
13454: PPUSH
13455: CALL_OW 38
// if IsOk ( Simms ) then
13459: LD_EXP 30
13463: PPUSH
13464: CALL_OW 302
13468: IFFALSE 13482
// SaveCharacters ( Simms , 13a_Simms ) ;
13470: LD_EXP 30
13474: PPUSH
13475: LD_STRING 13a_Simms
13477: PPUSH
13478: CALL_OW 38
// if IsOk ( Joan ) then
13482: LD_EXP 31
13486: PPUSH
13487: CALL_OW 302
13491: IFFALSE 13505
// SaveCharacters ( Joan , 13a_Joan ) ;
13493: LD_EXP 31
13497: PPUSH
13498: LD_STRING 13a_Joan
13500: PPUSH
13501: CALL_OW 38
// if IsOk ( DeltaDoctor ) then
13505: LD_EXP 32
13509: PPUSH
13510: CALL_OW 302
13514: IFFALSE 13528
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
13516: LD_EXP 32
13520: PPUSH
13521: LD_STRING 13a_DeltaDoctor
13523: PPUSH
13524: CALL_OW 38
// if IsOk ( Gossudarov ) then
13528: LD_EXP 34
13532: PPUSH
13533: CALL_OW 302
13537: IFFALSE 13551
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
13539: LD_EXP 34
13543: PPUSH
13544: LD_STRING 13a_Gossudarov
13546: PPUSH
13547: CALL_OW 38
// if IsOk ( Kirilenkova ) then
13551: LD_EXP 35
13555: PPUSH
13556: CALL_OW 302
13560: IFFALSE 13574
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
13562: LD_EXP 35
13566: PPUSH
13567: LD_STRING 13a_Kirilenkova
13569: PPUSH
13570: CALL_OW 38
// if IsOk ( Roth ) then
13574: LD_EXP 17
13578: PPUSH
13579: CALL_OW 302
13583: IFFALSE 13597
// SaveCharacters ( Roth , 13a_Roth ) ;
13585: LD_EXP 17
13589: PPUSH
13590: LD_STRING 13a_Roth
13592: PPUSH
13593: CALL_OW 38
// if Masha then
13597: LD_EXP 51
13601: IFFALSE 13656
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
13603: LD_EXP 51
13607: PPUSH
13608: CALL_OW 265
13612: PUSH
13613: LD_EXP 51
13617: PPUSH
13618: CALL_OW 262
13622: PUSH
13623: LD_EXP 51
13627: PPUSH
13628: CALL_OW 263
13632: PUSH
13633: LD_EXP 51
13637: PPUSH
13638: CALL_OW 264
13642: PUSH
13643: EMPTY
13644: LIST
13645: LIST
13646: LIST
13647: LIST
13648: PPUSH
13649: LD_STRING 13a_Masha
13651: PPUSH
13652: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
13656: LD_ADDR_VAR 0 2
13660: PUSH
13661: LD_INT 21
13663: PUSH
13664: LD_INT 3
13666: PUSH
13667: EMPTY
13668: LIST
13669: LIST
13670: PPUSH
13671: CALL_OW 69
13675: ST_TO_ADDR
// tmp2 := [ ] ;
13676: LD_ADDR_VAR 0 3
13680: PUSH
13681: EMPTY
13682: ST_TO_ADDR
// if tmp then
13683: LD_VAR 0 2
13687: IFFALSE 13838
// for i in tmp do
13689: LD_ADDR_VAR 0 1
13693: PUSH
13694: LD_VAR 0 2
13698: PUSH
13699: FOR_IN
13700: IFFALSE 13836
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
13702: LD_ADDR_VAR 0 3
13706: PUSH
13707: LD_VAR 0 3
13711: PUSH
13712: LD_VAR 0 1
13716: PPUSH
13717: CALL_OW 255
13721: PUSH
13722: LD_VAR 0 1
13726: PPUSH
13727: CALL_OW 248
13731: PUSH
13732: LD_VAR 0 1
13736: PPUSH
13737: CALL_OW 266
13741: PUSH
13742: LD_VAR 0 1
13746: PPUSH
13747: CALL_OW 250
13751: PUSH
13752: LD_VAR 0 1
13756: PPUSH
13757: CALL_OW 251
13761: PUSH
13762: LD_VAR 0 1
13766: PPUSH
13767: CALL_OW 254
13771: PUSH
13772: LD_VAR 0 1
13776: PPUSH
13777: CALL_OW 267
13781: PUSH
13782: LD_VAR 0 1
13786: PPUSH
13787: LD_INT 1
13789: PPUSH
13790: CALL_OW 268
13794: PUSH
13795: LD_VAR 0 1
13799: PPUSH
13800: LD_INT 2
13802: PPUSH
13803: CALL_OW 268
13807: PUSH
13808: LD_VAR 0 1
13812: PPUSH
13813: CALL_OW 269
13817: PUSH
13818: EMPTY
13819: LIST
13820: LIST
13821: LIST
13822: LIST
13823: LIST
13824: LIST
13825: LIST
13826: LIST
13827: LIST
13828: LIST
13829: PUSH
13830: EMPTY
13831: LIST
13832: ADD
13833: ST_TO_ADDR
13834: GO 13699
13836: POP
13837: POP
// if tmp2 then
13838: LD_VAR 0 3
13842: IFFALSE 13856
// SaveVariable ( tmp2 , 13a_buildings ) ;
13844: LD_VAR 0 3
13848: PPUSH
13849: LD_STRING 13a_buildings
13851: PPUSH
13852: CALL_OW 39
// YouWin ;
13856: CALL_OW 103
// end ;
13860: PPOPN 6
13862: END
// export function SciRu ; var tmp , t ; begin
13863: LD_INT 0
13865: PPUSH
13866: PPUSH
13867: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13868: LD_ADDR_VAR 0 3
13872: PUSH
13873: LD_EXP 34
13877: PUSH
13878: LD_EXP 48
13882: PUSH
13883: LD_EXP 36
13887: PUSH
13888: LD_EXP 49
13892: PUSH
13893: LD_EXP 50
13897: PUSH
13898: LD_EXP 39
13902: PUSH
13903: LD_EXP 40
13907: PUSH
13908: LD_EXP 38
13912: PUSH
13913: EMPTY
13914: LIST
13915: LIST
13916: LIST
13917: LIST
13918: LIST
13919: LIST
13920: LIST
13921: LIST
13922: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
13923: LD_ADDR_VAR 0 2
13927: PUSH
13928: LD_INT 22
13930: PUSH
13931: LD_INT 7
13933: PUSH
13934: EMPTY
13935: LIST
13936: LIST
13937: PUSH
13938: LD_INT 23
13940: PUSH
13941: LD_INT 3
13943: PUSH
13944: EMPTY
13945: LIST
13946: LIST
13947: PUSH
13948: LD_INT 25
13950: PUSH
13951: LD_INT 4
13953: PUSH
13954: EMPTY
13955: LIST
13956: LIST
13957: PUSH
13958: LD_INT 26
13960: PUSH
13961: LD_INT 1
13963: PUSH
13964: EMPTY
13965: LIST
13966: LIST
13967: PUSH
13968: EMPTY
13969: LIST
13970: LIST
13971: LIST
13972: LIST
13973: PPUSH
13974: CALL_OW 69
13978: PUSH
13979: LD_VAR 0 3
13983: DIFF
13984: ST_TO_ADDR
// if tmp then
13985: LD_VAR 0 2
13989: IFFALSE 14005
// result := tmp [ 1 ] ;
13991: LD_ADDR_VAR 0 1
13995: PUSH
13996: LD_VAR 0 2
14000: PUSH
14001: LD_INT 1
14003: ARRAY
14004: ST_TO_ADDR
// end ;
14005: LD_VAR 0 1
14009: RET
// export function SolRu ; var tmp , t ; begin
14010: LD_INT 0
14012: PPUSH
14013: PPUSH
14014: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
14015: LD_ADDR_VAR 0 3
14019: PUSH
14020: LD_EXP 34
14024: PUSH
14025: LD_EXP 48
14029: PUSH
14030: LD_EXP 36
14034: PUSH
14035: LD_EXP 49
14039: PUSH
14040: LD_EXP 50
14044: PUSH
14045: LD_EXP 39
14049: PUSH
14050: LD_EXP 40
14054: PUSH
14055: LD_EXP 38
14059: PUSH
14060: EMPTY
14061: LIST
14062: LIST
14063: LIST
14064: LIST
14065: LIST
14066: LIST
14067: LIST
14068: LIST
14069: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
14070: LD_ADDR_VAR 0 2
14074: PUSH
14075: LD_INT 22
14077: PUSH
14078: LD_INT 7
14080: PUSH
14081: EMPTY
14082: LIST
14083: LIST
14084: PUSH
14085: LD_INT 23
14087: PUSH
14088: LD_INT 3
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: PUSH
14095: LD_INT 25
14097: PUSH
14098: LD_INT 1
14100: PUSH
14101: EMPTY
14102: LIST
14103: LIST
14104: PUSH
14105: LD_INT 26
14107: PUSH
14108: LD_INT 1
14110: PUSH
14111: EMPTY
14112: LIST
14113: LIST
14114: PUSH
14115: EMPTY
14116: LIST
14117: LIST
14118: LIST
14119: LIST
14120: PPUSH
14121: CALL_OW 69
14125: PUSH
14126: LD_VAR 0 3
14130: DIFF
14131: ST_TO_ADDR
// if tmp then
14132: LD_VAR 0 2
14136: IFFALSE 14152
// result := tmp [ 1 ] ;
14138: LD_ADDR_VAR 0 1
14142: PUSH
14143: LD_VAR 0 2
14147: PUSH
14148: LD_INT 1
14150: ARRAY
14151: ST_TO_ADDR
// end ; end_of_file
14152: LD_VAR 0 1
14156: RET
// export function CustomEvent ( event ) ; begin
14157: LD_INT 0
14159: PPUSH
// end ;
14160: LD_VAR 0 2
14164: RET
// on UnitDestroyed ( un ) do var i , side ;
14165: LD_INT 0
14167: PPUSH
14168: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
14169: LD_VAR 0 1
14173: PPUSH
14174: CALL 103339 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
14178: LD_VAR 0 1
14182: PUSH
14183: LD_INT 22
14185: PUSH
14186: LD_INT 7
14188: PUSH
14189: EMPTY
14190: LIST
14191: LIST
14192: PUSH
14193: LD_INT 2
14195: PUSH
14196: LD_INT 25
14198: PUSH
14199: LD_INT 1
14201: PUSH
14202: EMPTY
14203: LIST
14204: LIST
14205: PUSH
14206: LD_INT 25
14208: PUSH
14209: LD_INT 2
14211: PUSH
14212: EMPTY
14213: LIST
14214: LIST
14215: PUSH
14216: LD_INT 25
14218: PUSH
14219: LD_INT 3
14221: PUSH
14222: EMPTY
14223: LIST
14224: LIST
14225: PUSH
14226: LD_INT 25
14228: PUSH
14229: LD_INT 4
14231: PUSH
14232: EMPTY
14233: LIST
14234: LIST
14235: PUSH
14236: LD_INT 25
14238: PUSH
14239: LD_INT 5
14241: PUSH
14242: EMPTY
14243: LIST
14244: LIST
14245: PUSH
14246: LD_INT 25
14248: PUSH
14249: LD_INT 8
14251: PUSH
14252: EMPTY
14253: LIST
14254: LIST
14255: PUSH
14256: LD_INT 25
14258: PUSH
14259: LD_INT 9
14261: PUSH
14262: EMPTY
14263: LIST
14264: LIST
14265: PUSH
14266: EMPTY
14267: LIST
14268: LIST
14269: LIST
14270: LIST
14271: LIST
14272: LIST
14273: LIST
14274: LIST
14275: PUSH
14276: EMPTY
14277: LIST
14278: LIST
14279: PPUSH
14280: CALL_OW 69
14284: IN
14285: IFFALSE 14301
// loss_counter := loss_counter + 1 ;
14287: LD_ADDR_EXP 14
14291: PUSH
14292: LD_EXP 14
14296: PUSH
14297: LD_INT 1
14299: PLUS
14300: ST_TO_ADDR
// if un = Abdul then
14301: LD_VAR 0 1
14305: PUSH
14306: LD_EXP 57
14310: EQUAL
14311: IFFALSE 14321
// abdul_escaped := false ;
14313: LD_ADDR_EXP 13
14317: PUSH
14318: LD_INT 0
14320: ST_TO_ADDR
// if un in ru_attackers then
14321: LD_VAR 0 1
14325: PUSH
14326: LD_EXP 54
14330: IN
14331: IFFALSE 14349
// ru_attackers := ru_attackers diff un ;
14333: LD_ADDR_EXP 54
14337: PUSH
14338: LD_EXP 54
14342: PUSH
14343: LD_VAR 0 1
14347: DIFF
14348: ST_TO_ADDR
// if un in ar_attackers then
14349: LD_VAR 0 1
14353: PUSH
14354: LD_EXP 11
14358: IN
14359: IFFALSE 14377
// ar_attackers := ar_attackers diff un ;
14361: LD_ADDR_EXP 11
14365: PUSH
14366: LD_EXP 11
14370: PUSH
14371: LD_VAR 0 1
14375: DIFF
14376: ST_TO_ADDR
// if un = JMM then
14377: LD_VAR 0 1
14381: PUSH
14382: LD_EXP 16
14386: EQUAL
14387: IFFALSE 14398
// begin YouLost ( JMM ) ;
14389: LD_STRING JMM
14391: PPUSH
14392: CALL_OW 104
// exit ;
14396: GO 14495
// end ; if un = Burlak then
14398: LD_VAR 0 1
14402: PUSH
14403: LD_EXP 48
14407: EQUAL
14408: IFFALSE 14419
// begin YouLost ( Burlak ) ;
14410: LD_STRING Burlak
14412: PPUSH
14413: CALL_OW 104
// exit ;
14417: GO 14495
// end ; if un = freedom then
14419: LD_VAR 0 1
14423: PUSH
14424: LD_EXP 3
14428: EQUAL
14429: IFFALSE 14440
// begin YouLost ( Destroyed ) ;
14431: LD_STRING Destroyed
14433: PPUSH
14434: CALL_OW 104
// exit ;
14438: GO 14495
// end ; if un = Masha then
14440: LD_VAR 0 1
14444: PUSH
14445: LD_EXP 51
14449: EQUAL
14450: IFFALSE 14467
// begin ChangeMissionObjectives ( M4b ) ;
14452: LD_STRING M4b
14454: PPUSH
14455: CALL_OW 337
// masha_killed := true ;
14459: LD_ADDR_EXP 10
14463: PUSH
14464: LD_INT 1
14466: ST_TO_ADDR
// end ; if un = Mastodont then
14467: LD_VAR 0 1
14471: PUSH
14472: LD_EXP 58
14476: EQUAL
14477: IFFALSE 14486
// ChangeMissionObjectives ( M4a ) ;
14479: LD_STRING M4a
14481: PPUSH
14482: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
14486: LD_VAR 0 1
14490: PPUSH
14491: CALL 84553 0 1
// end ;
14495: PPOPN 3
14497: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
14498: LD_VAR 0 1
14502: PPUSH
14503: LD_VAR 0 2
14507: PPUSH
14508: CALL 86885 0 2
// end ;
14512: PPOPN 2
14514: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
14515: LD_VAR 0 1
14519: PPUSH
14520: CALL 85953 0 1
// end ;
14524: PPOPN 1
14526: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
14527: LD_VAR 0 1
14531: PUSH
14532: LD_INT 22
14534: PUSH
14535: LD_INT 7
14537: PUSH
14538: EMPTY
14539: LIST
14540: LIST
14541: PUSH
14542: LD_INT 30
14544: PUSH
14545: LD_INT 0
14547: PUSH
14548: EMPTY
14549: LIST
14550: LIST
14551: PUSH
14552: EMPTY
14553: LIST
14554: LIST
14555: PPUSH
14556: CALL_OW 69
14560: IN
14561: IFFALSE 14600
// begin SetBName ( building , freedom ) ;
14563: LD_VAR 0 1
14567: PPUSH
14568: LD_STRING freedom
14570: PPUSH
14571: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
14575: LD_INT 0
14577: PPUSH
14578: LD_INT 7
14580: PPUSH
14581: LD_INT 0
14583: PPUSH
14584: CALL_OW 324
// freedom := building ;
14588: LD_ADDR_EXP 3
14592: PUSH
14593: LD_VAR 0 1
14597: ST_TO_ADDR
// exit ;
14598: GO 14666
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
14600: LD_VAR 0 1
14604: PUSH
14605: LD_INT 22
14607: PUSH
14608: LD_INT 7
14610: PUSH
14611: EMPTY
14612: LIST
14613: LIST
14614: PUSH
14615: LD_INT 23
14617: PUSH
14618: LD_INT 3
14620: PUSH
14621: EMPTY
14622: LIST
14623: LIST
14624: PUSH
14625: LD_INT 30
14627: PUSH
14628: LD_INT 6
14630: PUSH
14631: EMPTY
14632: LIST
14633: LIST
14634: PUSH
14635: EMPTY
14636: LIST
14637: LIST
14638: LIST
14639: PPUSH
14640: CALL_OW 69
14644: IN
14645: IFFALSE 14657
// begin ru_lab_builded := true ;
14647: LD_ADDR_EXP 5
14651: PUSH
14652: LD_INT 1
14654: ST_TO_ADDR
// exit ;
14655: GO 14666
// end ; MCE_BuildingComplete ( building ) ;
14657: LD_VAR 0 1
14661: PPUSH
14662: CALL 86194 0 1
// end ;
14666: PPOPN 1
14668: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
14669: LD_VAR 0 1
14673: PPUSH
14674: LD_VAR 0 2
14678: PPUSH
14679: CALL 84249 0 2
// end ;
14683: PPOPN 2
14685: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
14686: LD_VAR 0 1
14690: PPUSH
14691: LD_VAR 0 2
14695: PPUSH
14696: LD_VAR 0 3
14700: PPUSH
14701: LD_VAR 0 4
14705: PPUSH
14706: LD_VAR 0 5
14710: PPUSH
14711: CALL 83869 0 5
// end ;
14715: PPOPN 5
14717: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
14718: LD_VAR 0 1
14722: PPUSH
14723: LD_VAR 0 2
14727: PPUSH
14728: CALL 103459 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
14732: LD_VAR 0 1
14736: PPUSH
14737: LD_VAR 0 2
14741: PPUSH
14742: CALL 83422 0 2
// end ;
14746: PPOPN 2
14748: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
14749: LD_VAR 0 1
14753: PPUSH
14754: CALL_OW 263
14758: PUSH
14759: LD_INT 3
14761: EQUAL
14762: PUSH
14763: LD_VAR 0 2
14767: PPUSH
14768: CALL_OW 263
14772: PUSH
14773: LD_INT 3
14775: EQUAL
14776: OR
14777: IFFALSE 14793
// hack_counter := hack_counter + 1 ;
14779: LD_ADDR_EXP 15
14783: PUSH
14784: LD_EXP 15
14788: PUSH
14789: LD_INT 1
14791: PLUS
14792: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14793: LD_VAR 0 1
14797: PPUSH
14798: LD_VAR 0 2
14802: PPUSH
14803: LD_VAR 0 3
14807: PPUSH
14808: LD_VAR 0 4
14812: PPUSH
14813: CALL 83260 0 4
// end ;
14817: PPOPN 4
14819: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14820: LD_VAR 0 1
14824: PPUSH
14825: LD_VAR 0 2
14829: PPUSH
14830: LD_VAR 0 3
14834: PPUSH
14835: CALL 83035 0 3
// end ;
14839: PPOPN 3
14841: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14842: LD_VAR 0 1
14846: PPUSH
14847: LD_VAR 0 2
14851: PPUSH
14852: CALL 82920 0 2
// end ;
14856: PPOPN 2
14858: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14859: LD_VAR 0 1
14863: PPUSH
14864: LD_VAR 0 2
14868: PPUSH
14869: CALL 87180 0 2
// end ;
14873: PPOPN 2
14875: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14876: LD_VAR 0 1
14880: PPUSH
14881: LD_VAR 0 2
14885: PPUSH
14886: LD_VAR 0 3
14890: PPUSH
14891: LD_VAR 0 4
14895: PPUSH
14896: CALL 87396 0 4
// end ;
14900: PPOPN 4
14902: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14903: LD_VAR 0 1
14907: PPUSH
14908: LD_VAR 0 2
14912: PPUSH
14913: CALL 82729 0 2
// end ;
14917: PPOPN 2
14919: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
14920: LD_VAR 0 1
14924: PPUSH
14925: CALL 103443 0 1
// end ; end_of_file
14929: PPOPN 1
14931: END
// every 0 0$30 do var cr , time ;
14932: GO 14934
14934: DISABLE
14935: LD_INT 0
14937: PPUSH
14938: PPUSH
// begin time := 0 0$20 ;
14939: LD_ADDR_VAR 0 2
14943: PUSH
14944: LD_INT 700
14946: ST_TO_ADDR
// while game do
14947: LD_EXP 2
14951: IFFALSE 15054
// begin wait ( time ) ;
14953: LD_VAR 0 2
14957: PPUSH
14958: CALL_OW 67
// if tick > 2 2$00 then
14962: LD_OWVAR 1
14966: PUSH
14967: LD_INT 4200
14969: GREATER
14970: IFFALSE 15007
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14972: LD_ADDR_VAR 0 2
14976: PUSH
14977: LD_VAR 0 2
14981: PUSH
14982: LD_INT 140
14984: PUSH
14985: LD_INT 140
14987: PUSH
14988: LD_INT 210
14990: PUSH
14991: LD_INT 280
14993: PUSH
14994: EMPTY
14995: LIST
14996: LIST
14997: LIST
14998: LIST
14999: PUSH
15000: LD_OWVAR 67
15004: ARRAY
15005: PLUS
15006: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
15007: LD_INT 1
15009: PPUSH
15010: LD_INT 5
15012: PPUSH
15013: CALL_OW 12
15017: PPUSH
15018: LD_INT 70
15020: PPUSH
15021: LD_INT 49
15023: PPUSH
15024: LD_INT 25
15026: PPUSH
15027: LD_INT 1
15029: PPUSH
15030: CALL_OW 56
// if time > 3 3$00 then
15034: LD_VAR 0 2
15038: PUSH
15039: LD_INT 6300
15041: GREATER
15042: IFFALSE 15052
// time := 0 0$30 ;
15044: LD_ADDR_VAR 0 2
15048: PUSH
15049: LD_INT 1050
15051: ST_TO_ADDR
// end ;
15052: GO 14947
// end ;
15054: PPOPN 2
15056: END
// every 0 0$30 do var cr , time ;
15057: GO 15059
15059: DISABLE
15060: LD_INT 0
15062: PPUSH
15063: PPUSH
// begin time := 0 0$20 ;
15064: LD_ADDR_VAR 0 2
15068: PUSH
15069: LD_INT 700
15071: ST_TO_ADDR
// while game do
15072: LD_EXP 2
15076: IFFALSE 15169
// begin wait ( time ) ;
15078: LD_VAR 0 2
15082: PPUSH
15083: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
15087: LD_ADDR_VAR 0 2
15091: PUSH
15092: LD_VAR 0 2
15096: PUSH
15097: LD_INT 140
15099: PUSH
15100: LD_INT 175
15102: PUSH
15103: LD_INT 210
15105: PUSH
15106: LD_INT 280
15108: PUSH
15109: EMPTY
15110: LIST
15111: LIST
15112: LIST
15113: LIST
15114: PUSH
15115: LD_OWVAR 67
15119: ARRAY
15120: PLUS
15121: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
15122: LD_INT 3
15124: PPUSH
15125: LD_INT 5
15127: PPUSH
15128: CALL_OW 12
15132: PPUSH
15133: LD_INT 26
15135: PPUSH
15136: LD_INT 9
15138: PPUSH
15139: LD_INT 30
15141: PPUSH
15142: LD_INT 1
15144: PPUSH
15145: CALL_OW 56
// if time > 3 3$00 then
15149: LD_VAR 0 2
15153: PUSH
15154: LD_INT 6300
15156: GREATER
15157: IFFALSE 15167
// time := 0 0$20 ;
15159: LD_ADDR_VAR 0 2
15163: PUSH
15164: LD_INT 700
15166: ST_TO_ADDR
// end ;
15167: GO 15072
// end ;
15169: PPOPN 2
15171: END
// every 0 0$30 do var cr , time ;
15172: GO 15174
15174: DISABLE
15175: LD_INT 0
15177: PPUSH
15178: PPUSH
// begin time := 0 0$20 ;
15179: LD_ADDR_VAR 0 2
15183: PUSH
15184: LD_INT 700
15186: ST_TO_ADDR
// while game do
15187: LD_EXP 2
15191: IFFALSE 15320
// begin wait ( time ) ;
15193: LD_VAR 0 2
15197: PPUSH
15198: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
15202: LD_ADDR_VAR 0 2
15206: PUSH
15207: LD_VAR 0 2
15211: PUSH
15212: LD_INT 175
15214: PUSH
15215: LD_INT 210
15217: PUSH
15218: LD_INT 280
15220: PUSH
15221: LD_INT 350
15223: PUSH
15224: EMPTY
15225: LIST
15226: LIST
15227: LIST
15228: LIST
15229: PUSH
15230: LD_OWVAR 67
15234: ARRAY
15235: PLUS
15236: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
15237: LD_INT 1
15239: PPUSH
15240: LD_INT 5
15242: PPUSH
15243: CALL_OW 12
15247: PPUSH
15248: LD_INT 179
15250: PPUSH
15251: LD_INT 101
15253: PPUSH
15254: LD_INT 20
15256: PPUSH
15257: LD_INT 1
15259: PPUSH
15260: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
15264: LD_INT 350
15266: PPUSH
15267: LD_INT 525
15269: PPUSH
15270: CALL_OW 12
15274: PPUSH
15275: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
15279: LD_INT 1
15281: PPUSH
15282: LD_INT 5
15284: PPUSH
15285: CALL_OW 12
15289: PPUSH
15290: LD_INT 9
15292: PPUSH
15293: LD_INT 1
15295: PPUSH
15296: CALL_OW 55
// if time > 4 4$00 then
15300: LD_VAR 0 2
15304: PUSH
15305: LD_INT 8400
15307: GREATER
15308: IFFALSE 15318
// time := 0 0$30 ;
15310: LD_ADDR_VAR 0 2
15314: PUSH
15315: LD_INT 1050
15317: ST_TO_ADDR
// end ;
15318: GO 15187
// end ;
15320: PPOPN 2
15322: END
// every 0 0$30 do var cr , time ;
15323: GO 15325
15325: DISABLE
15326: LD_INT 0
15328: PPUSH
15329: PPUSH
// begin time := 0 0$10 ;
15330: LD_ADDR_VAR 0 2
15334: PUSH
15335: LD_INT 350
15337: ST_TO_ADDR
// while game do
15338: LD_EXP 2
15342: IFFALSE 15476
// begin wait ( time ) ;
15344: LD_VAR 0 2
15348: PPUSH
15349: CALL_OW 67
// time := time + 0 0$10 ;
15353: LD_ADDR_VAR 0 2
15357: PUSH
15358: LD_VAR 0 2
15362: PUSH
15363: LD_INT 350
15365: PLUS
15366: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
15367: LD_INT 1
15369: PPUSH
15370: LD_INT 5
15372: PPUSH
15373: CALL_OW 12
15377: PPUSH
15378: LD_INT 11
15380: PPUSH
15381: LD_INT 1
15383: PPUSH
15384: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
15388: LD_ADDR_VAR 0 1
15392: PUSH
15393: LD_INT 1
15395: PPUSH
15396: LD_INT 3
15398: PPUSH
15399: CALL_OW 12
15403: ST_TO_ADDR
// if cr = 1 then
15404: LD_VAR 0 1
15408: PUSH
15409: LD_INT 1
15411: EQUAL
15412: IFFALSE 15456
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
15414: LD_INT 700
15416: PPUSH
15417: LD_INT 1575
15419: PPUSH
15420: CALL_OW 12
15424: PPUSH
15425: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
15429: LD_INT 1
15431: PPUSH
15432: LD_INT 5
15434: PPUSH
15435: CALL_OW 12
15439: PPUSH
15440: LD_INT 34
15442: PPUSH
15443: LD_INT 50
15445: PPUSH
15446: LD_INT 7
15448: PPUSH
15449: LD_INT 1
15451: PPUSH
15452: CALL_OW 56
// end ; if time > 4 4$00 then
15456: LD_VAR 0 2
15460: PUSH
15461: LD_INT 8400
15463: GREATER
15464: IFFALSE 15474
// time := 0 0$40 ;
15466: LD_ADDR_VAR 0 2
15470: PUSH
15471: LD_INT 1400
15473: ST_TO_ADDR
// end ;
15474: GO 15338
// end ; end_of_file
15476: PPOPN 2
15478: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
15479: LD_INT 0
15481: PPUSH
15482: PPUSH
// if exist_mode then
15483: LD_VAR 0 2
15487: IFFALSE 15512
// unit := CreateCharacter ( prefix & ident ) else
15489: LD_ADDR_VAR 0 5
15493: PUSH
15494: LD_VAR 0 3
15498: PUSH
15499: LD_VAR 0 1
15503: STR
15504: PPUSH
15505: CALL_OW 34
15509: ST_TO_ADDR
15510: GO 15527
// unit := NewCharacter ( ident ) ;
15512: LD_ADDR_VAR 0 5
15516: PUSH
15517: LD_VAR 0 1
15521: PPUSH
15522: CALL_OW 25
15526: ST_TO_ADDR
// result := unit ;
15527: LD_ADDR_VAR 0 4
15531: PUSH
15532: LD_VAR 0 5
15536: ST_TO_ADDR
// end ;
15537: LD_VAR 0 4
15541: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
15542: LD_INT 0
15544: PPUSH
15545: PPUSH
// if not side or not nation then
15546: LD_VAR 0 1
15550: NOT
15551: PUSH
15552: LD_VAR 0 2
15556: NOT
15557: OR
15558: IFFALSE 15562
// exit ;
15560: GO 16330
// case nation of nation_american :
15562: LD_VAR 0 2
15566: PUSH
15567: LD_INT 1
15569: DOUBLE
15570: EQUAL
15571: IFTRUE 15575
15573: GO 15789
15575: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
15576: LD_ADDR_VAR 0 4
15580: PUSH
15581: LD_INT 35
15583: PUSH
15584: LD_INT 45
15586: PUSH
15587: LD_INT 46
15589: PUSH
15590: LD_INT 47
15592: PUSH
15593: LD_INT 82
15595: PUSH
15596: LD_INT 83
15598: PUSH
15599: LD_INT 84
15601: PUSH
15602: LD_INT 85
15604: PUSH
15605: LD_INT 86
15607: PUSH
15608: LD_INT 1
15610: PUSH
15611: LD_INT 2
15613: PUSH
15614: LD_INT 6
15616: PUSH
15617: LD_INT 15
15619: PUSH
15620: LD_INT 16
15622: PUSH
15623: LD_INT 7
15625: PUSH
15626: LD_INT 12
15628: PUSH
15629: LD_INT 13
15631: PUSH
15632: LD_INT 10
15634: PUSH
15635: LD_INT 14
15637: PUSH
15638: LD_INT 20
15640: PUSH
15641: LD_INT 21
15643: PUSH
15644: LD_INT 22
15646: PUSH
15647: LD_INT 25
15649: PUSH
15650: LD_INT 32
15652: PUSH
15653: LD_INT 27
15655: PUSH
15656: LD_INT 36
15658: PUSH
15659: LD_INT 69
15661: PUSH
15662: LD_INT 39
15664: PUSH
15665: LD_INT 34
15667: PUSH
15668: LD_INT 40
15670: PUSH
15671: LD_INT 48
15673: PUSH
15674: LD_INT 49
15676: PUSH
15677: LD_INT 50
15679: PUSH
15680: LD_INT 51
15682: PUSH
15683: LD_INT 52
15685: PUSH
15686: LD_INT 53
15688: PUSH
15689: LD_INT 54
15691: PUSH
15692: LD_INT 55
15694: PUSH
15695: LD_INT 56
15697: PUSH
15698: LD_INT 57
15700: PUSH
15701: LD_INT 58
15703: PUSH
15704: LD_INT 59
15706: PUSH
15707: LD_INT 60
15709: PUSH
15710: LD_INT 61
15712: PUSH
15713: LD_INT 62
15715: PUSH
15716: LD_INT 80
15718: PUSH
15719: LD_INT 82
15721: PUSH
15722: LD_INT 83
15724: PUSH
15725: LD_INT 84
15727: PUSH
15728: LD_INT 85
15730: PUSH
15731: LD_INT 86
15733: PUSH
15734: EMPTY
15735: LIST
15736: LIST
15737: LIST
15738: LIST
15739: LIST
15740: LIST
15741: LIST
15742: LIST
15743: LIST
15744: LIST
15745: LIST
15746: LIST
15747: LIST
15748: LIST
15749: LIST
15750: LIST
15751: LIST
15752: LIST
15753: LIST
15754: LIST
15755: LIST
15756: LIST
15757: LIST
15758: LIST
15759: LIST
15760: LIST
15761: LIST
15762: LIST
15763: LIST
15764: LIST
15765: LIST
15766: LIST
15767: LIST
15768: LIST
15769: LIST
15770: LIST
15771: LIST
15772: LIST
15773: LIST
15774: LIST
15775: LIST
15776: LIST
15777: LIST
15778: LIST
15779: LIST
15780: LIST
15781: LIST
15782: LIST
15783: LIST
15784: LIST
15785: LIST
15786: ST_TO_ADDR
15787: GO 16254
15789: LD_INT 2
15791: DOUBLE
15792: EQUAL
15793: IFTRUE 15797
15795: GO 16023
15797: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
15798: LD_ADDR_VAR 0 4
15802: PUSH
15803: LD_INT 35
15805: PUSH
15806: LD_INT 45
15808: PUSH
15809: LD_INT 46
15811: PUSH
15812: LD_INT 47
15814: PUSH
15815: LD_INT 82
15817: PUSH
15818: LD_INT 83
15820: PUSH
15821: LD_INT 84
15823: PUSH
15824: LD_INT 85
15826: PUSH
15827: LD_INT 87
15829: PUSH
15830: LD_INT 70
15832: PUSH
15833: LD_INT 1
15835: PUSH
15836: LD_INT 11
15838: PUSH
15839: LD_INT 3
15841: PUSH
15842: LD_INT 4
15844: PUSH
15845: LD_INT 5
15847: PUSH
15848: LD_INT 6
15850: PUSH
15851: LD_INT 15
15853: PUSH
15854: LD_INT 18
15856: PUSH
15857: LD_INT 7
15859: PUSH
15860: LD_INT 17
15862: PUSH
15863: LD_INT 8
15865: PUSH
15866: LD_INT 20
15868: PUSH
15869: LD_INT 21
15871: PUSH
15872: LD_INT 22
15874: PUSH
15875: LD_INT 72
15877: PUSH
15878: LD_INT 26
15880: PUSH
15881: LD_INT 69
15883: PUSH
15884: LD_INT 39
15886: PUSH
15887: LD_INT 40
15889: PUSH
15890: LD_INT 41
15892: PUSH
15893: LD_INT 42
15895: PUSH
15896: LD_INT 43
15898: PUSH
15899: LD_INT 48
15901: PUSH
15902: LD_INT 49
15904: PUSH
15905: LD_INT 50
15907: PUSH
15908: LD_INT 51
15910: PUSH
15911: LD_INT 52
15913: PUSH
15914: LD_INT 53
15916: PUSH
15917: LD_INT 54
15919: PUSH
15920: LD_INT 55
15922: PUSH
15923: LD_INT 56
15925: PUSH
15926: LD_INT 60
15928: PUSH
15929: LD_INT 61
15931: PUSH
15932: LD_INT 62
15934: PUSH
15935: LD_INT 66
15937: PUSH
15938: LD_INT 67
15940: PUSH
15941: LD_INT 68
15943: PUSH
15944: LD_INT 81
15946: PUSH
15947: LD_INT 82
15949: PUSH
15950: LD_INT 83
15952: PUSH
15953: LD_INT 84
15955: PUSH
15956: LD_INT 85
15958: PUSH
15959: LD_INT 87
15961: PUSH
15962: LD_INT 88
15964: PUSH
15965: EMPTY
15966: LIST
15967: LIST
15968: LIST
15969: LIST
15970: LIST
15971: LIST
15972: LIST
15973: LIST
15974: LIST
15975: LIST
15976: LIST
15977: LIST
15978: LIST
15979: LIST
15980: LIST
15981: LIST
15982: LIST
15983: LIST
15984: LIST
15985: LIST
15986: LIST
15987: LIST
15988: LIST
15989: LIST
15990: LIST
15991: LIST
15992: LIST
15993: LIST
15994: LIST
15995: LIST
15996: LIST
15997: LIST
15998: LIST
15999: LIST
16000: LIST
16001: LIST
16002: LIST
16003: LIST
16004: LIST
16005: LIST
16006: LIST
16007: LIST
16008: LIST
16009: LIST
16010: LIST
16011: LIST
16012: LIST
16013: LIST
16014: LIST
16015: LIST
16016: LIST
16017: LIST
16018: LIST
16019: LIST
16020: ST_TO_ADDR
16021: GO 16254
16023: LD_INT 3
16025: DOUBLE
16026: EQUAL
16027: IFTRUE 16031
16029: GO 16253
16031: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
16032: LD_ADDR_VAR 0 4
16036: PUSH
16037: LD_INT 46
16039: PUSH
16040: LD_INT 47
16042: PUSH
16043: LD_INT 1
16045: PUSH
16046: LD_INT 2
16048: PUSH
16049: LD_INT 82
16051: PUSH
16052: LD_INT 83
16054: PUSH
16055: LD_INT 84
16057: PUSH
16058: LD_INT 85
16060: PUSH
16061: LD_INT 86
16063: PUSH
16064: LD_INT 11
16066: PUSH
16067: LD_INT 9
16069: PUSH
16070: LD_INT 20
16072: PUSH
16073: LD_INT 19
16075: PUSH
16076: LD_INT 21
16078: PUSH
16079: LD_INT 24
16081: PUSH
16082: LD_INT 22
16084: PUSH
16085: LD_INT 25
16087: PUSH
16088: LD_INT 28
16090: PUSH
16091: LD_INT 29
16093: PUSH
16094: LD_INT 30
16096: PUSH
16097: LD_INT 31
16099: PUSH
16100: LD_INT 37
16102: PUSH
16103: LD_INT 38
16105: PUSH
16106: LD_INT 32
16108: PUSH
16109: LD_INT 27
16111: PUSH
16112: LD_INT 33
16114: PUSH
16115: LD_INT 69
16117: PUSH
16118: LD_INT 39
16120: PUSH
16121: LD_INT 34
16123: PUSH
16124: LD_INT 40
16126: PUSH
16127: LD_INT 71
16129: PUSH
16130: LD_INT 23
16132: PUSH
16133: LD_INT 44
16135: PUSH
16136: LD_INT 48
16138: PUSH
16139: LD_INT 49
16141: PUSH
16142: LD_INT 50
16144: PUSH
16145: LD_INT 51
16147: PUSH
16148: LD_INT 52
16150: PUSH
16151: LD_INT 53
16153: PUSH
16154: LD_INT 54
16156: PUSH
16157: LD_INT 55
16159: PUSH
16160: LD_INT 56
16162: PUSH
16163: LD_INT 57
16165: PUSH
16166: LD_INT 58
16168: PUSH
16169: LD_INT 59
16171: PUSH
16172: LD_INT 63
16174: PUSH
16175: LD_INT 64
16177: PUSH
16178: LD_INT 65
16180: PUSH
16181: LD_INT 82
16183: PUSH
16184: LD_INT 83
16186: PUSH
16187: LD_INT 84
16189: PUSH
16190: LD_INT 85
16192: PUSH
16193: LD_INT 86
16195: PUSH
16196: EMPTY
16197: LIST
16198: LIST
16199: LIST
16200: LIST
16201: LIST
16202: LIST
16203: LIST
16204: LIST
16205: LIST
16206: LIST
16207: LIST
16208: LIST
16209: LIST
16210: LIST
16211: LIST
16212: LIST
16213: LIST
16214: LIST
16215: LIST
16216: LIST
16217: LIST
16218: LIST
16219: LIST
16220: LIST
16221: LIST
16222: LIST
16223: LIST
16224: LIST
16225: LIST
16226: LIST
16227: LIST
16228: LIST
16229: LIST
16230: LIST
16231: LIST
16232: LIST
16233: LIST
16234: LIST
16235: LIST
16236: LIST
16237: LIST
16238: LIST
16239: LIST
16240: LIST
16241: LIST
16242: LIST
16243: LIST
16244: LIST
16245: LIST
16246: LIST
16247: LIST
16248: LIST
16249: LIST
16250: ST_TO_ADDR
16251: GO 16254
16253: POP
// if state > - 1 and state < 3 then
16254: LD_VAR 0 3
16258: PUSH
16259: LD_INT 1
16261: NEG
16262: GREATER
16263: PUSH
16264: LD_VAR 0 3
16268: PUSH
16269: LD_INT 3
16271: LESS
16272: AND
16273: IFFALSE 16330
// for i in result do
16275: LD_ADDR_VAR 0 5
16279: PUSH
16280: LD_VAR 0 4
16284: PUSH
16285: FOR_IN
16286: IFFALSE 16328
// if GetTech ( i , side ) <> state then
16288: LD_VAR 0 5
16292: PPUSH
16293: LD_VAR 0 1
16297: PPUSH
16298: CALL_OW 321
16302: PUSH
16303: LD_VAR 0 3
16307: NONEQUAL
16308: IFFALSE 16326
// result := result diff i ;
16310: LD_ADDR_VAR 0 4
16314: PUSH
16315: LD_VAR 0 4
16319: PUSH
16320: LD_VAR 0 5
16324: DIFF
16325: ST_TO_ADDR
16326: GO 16285
16328: POP
16329: POP
// end ;
16330: LD_VAR 0 4
16334: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
16335: LD_INT 0
16337: PPUSH
16338: PPUSH
16339: PPUSH
// result := true ;
16340: LD_ADDR_VAR 0 3
16344: PUSH
16345: LD_INT 1
16347: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
16348: LD_ADDR_VAR 0 5
16352: PUSH
16353: LD_VAR 0 2
16357: PPUSH
16358: CALL_OW 480
16362: ST_TO_ADDR
// if not tmp then
16363: LD_VAR 0 5
16367: NOT
16368: IFFALSE 16372
// exit ;
16370: GO 16421
// for i in tmp do
16372: LD_ADDR_VAR 0 4
16376: PUSH
16377: LD_VAR 0 5
16381: PUSH
16382: FOR_IN
16383: IFFALSE 16419
// if GetTech ( i , side ) <> state_researched then
16385: LD_VAR 0 4
16389: PPUSH
16390: LD_VAR 0 1
16394: PPUSH
16395: CALL_OW 321
16399: PUSH
16400: LD_INT 2
16402: NONEQUAL
16403: IFFALSE 16417
// begin result := false ;
16405: LD_ADDR_VAR 0 3
16409: PUSH
16410: LD_INT 0
16412: ST_TO_ADDR
// exit ;
16413: POP
16414: POP
16415: GO 16421
// end ;
16417: GO 16382
16419: POP
16420: POP
// end ;
16421: LD_VAR 0 3
16425: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
16426: LD_INT 0
16428: PPUSH
16429: PPUSH
16430: PPUSH
16431: PPUSH
16432: PPUSH
16433: PPUSH
16434: PPUSH
16435: PPUSH
16436: PPUSH
16437: PPUSH
16438: PPUSH
16439: PPUSH
16440: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
16441: LD_VAR 0 1
16445: NOT
16446: PUSH
16447: LD_VAR 0 1
16451: PPUSH
16452: CALL_OW 257
16456: PUSH
16457: LD_INT 9
16459: NONEQUAL
16460: OR
16461: IFFALSE 16465
// exit ;
16463: GO 17038
// side := GetSide ( unit ) ;
16465: LD_ADDR_VAR 0 9
16469: PUSH
16470: LD_VAR 0 1
16474: PPUSH
16475: CALL_OW 255
16479: ST_TO_ADDR
// tech_space := tech_spacanom ;
16480: LD_ADDR_VAR 0 12
16484: PUSH
16485: LD_INT 29
16487: ST_TO_ADDR
// tech_time := tech_taurad ;
16488: LD_ADDR_VAR 0 13
16492: PUSH
16493: LD_INT 28
16495: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
16496: LD_ADDR_VAR 0 11
16500: PUSH
16501: LD_VAR 0 1
16505: PPUSH
16506: CALL_OW 310
16510: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
16511: LD_VAR 0 11
16515: PPUSH
16516: CALL_OW 247
16520: PUSH
16521: LD_INT 2
16523: EQUAL
16524: IFFALSE 16528
// exit ;
16526: GO 17038
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16528: LD_ADDR_VAR 0 8
16532: PUSH
16533: LD_INT 81
16535: PUSH
16536: LD_VAR 0 9
16540: PUSH
16541: EMPTY
16542: LIST
16543: LIST
16544: PUSH
16545: LD_INT 3
16547: PUSH
16548: LD_INT 21
16550: PUSH
16551: LD_INT 3
16553: PUSH
16554: EMPTY
16555: LIST
16556: LIST
16557: PUSH
16558: EMPTY
16559: LIST
16560: LIST
16561: PUSH
16562: EMPTY
16563: LIST
16564: LIST
16565: PPUSH
16566: CALL_OW 69
16570: ST_TO_ADDR
// if not tmp then
16571: LD_VAR 0 8
16575: NOT
16576: IFFALSE 16580
// exit ;
16578: GO 17038
// if in_unit then
16580: LD_VAR 0 11
16584: IFFALSE 16608
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
16586: LD_ADDR_VAR 0 10
16590: PUSH
16591: LD_VAR 0 8
16595: PPUSH
16596: LD_VAR 0 11
16600: PPUSH
16601: CALL_OW 74
16605: ST_TO_ADDR
16606: GO 16628
// enemy := NearestUnitToUnit ( tmp , unit ) ;
16608: LD_ADDR_VAR 0 10
16612: PUSH
16613: LD_VAR 0 8
16617: PPUSH
16618: LD_VAR 0 1
16622: PPUSH
16623: CALL_OW 74
16627: ST_TO_ADDR
// if not enemy then
16628: LD_VAR 0 10
16632: NOT
16633: IFFALSE 16637
// exit ;
16635: GO 17038
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
16637: LD_VAR 0 11
16641: PUSH
16642: LD_VAR 0 11
16646: PPUSH
16647: LD_VAR 0 10
16651: PPUSH
16652: CALL_OW 296
16656: PUSH
16657: LD_INT 13
16659: GREATER
16660: AND
16661: PUSH
16662: LD_VAR 0 1
16666: PPUSH
16667: LD_VAR 0 10
16671: PPUSH
16672: CALL_OW 296
16676: PUSH
16677: LD_INT 12
16679: GREATER
16680: OR
16681: IFFALSE 16685
// exit ;
16683: GO 17038
// missile := [ 1 ] ;
16685: LD_ADDR_VAR 0 14
16689: PUSH
16690: LD_INT 1
16692: PUSH
16693: EMPTY
16694: LIST
16695: ST_TO_ADDR
// if Researched ( side , tech_space ) then
16696: LD_VAR 0 9
16700: PPUSH
16701: LD_VAR 0 12
16705: PPUSH
16706: CALL_OW 325
16710: IFFALSE 16739
// missile := Replace ( missile , missile + 1 , 2 ) ;
16712: LD_ADDR_VAR 0 14
16716: PUSH
16717: LD_VAR 0 14
16721: PPUSH
16722: LD_VAR 0 14
16726: PUSH
16727: LD_INT 1
16729: PLUS
16730: PPUSH
16731: LD_INT 2
16733: PPUSH
16734: CALL_OW 1
16738: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
16739: LD_VAR 0 9
16743: PPUSH
16744: LD_VAR 0 13
16748: PPUSH
16749: CALL_OW 325
16753: PUSH
16754: LD_VAR 0 10
16758: PPUSH
16759: CALL_OW 255
16763: PPUSH
16764: LD_VAR 0 13
16768: PPUSH
16769: CALL_OW 325
16773: NOT
16774: AND
16775: IFFALSE 16804
// missile := Replace ( missile , missile + 1 , 3 ) ;
16777: LD_ADDR_VAR 0 14
16781: PUSH
16782: LD_VAR 0 14
16786: PPUSH
16787: LD_VAR 0 14
16791: PUSH
16792: LD_INT 1
16794: PLUS
16795: PPUSH
16796: LD_INT 3
16798: PPUSH
16799: CALL_OW 1
16803: ST_TO_ADDR
// if missile < 2 then
16804: LD_VAR 0 14
16808: PUSH
16809: LD_INT 2
16811: LESS
16812: IFFALSE 16816
// exit ;
16814: GO 17038
// x := GetX ( enemy ) ;
16816: LD_ADDR_VAR 0 4
16820: PUSH
16821: LD_VAR 0 10
16825: PPUSH
16826: CALL_OW 250
16830: ST_TO_ADDR
// y := GetY ( enemy ) ;
16831: LD_ADDR_VAR 0 5
16835: PUSH
16836: LD_VAR 0 10
16840: PPUSH
16841: CALL_OW 251
16845: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
16846: LD_ADDR_VAR 0 6
16850: PUSH
16851: LD_VAR 0 4
16855: PUSH
16856: LD_INT 1
16858: NEG
16859: PPUSH
16860: LD_INT 1
16862: PPUSH
16863: CALL_OW 12
16867: PLUS
16868: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
16869: LD_ADDR_VAR 0 7
16873: PUSH
16874: LD_VAR 0 5
16878: PUSH
16879: LD_INT 1
16881: NEG
16882: PPUSH
16883: LD_INT 1
16885: PPUSH
16886: CALL_OW 12
16890: PLUS
16891: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16892: LD_VAR 0 6
16896: PPUSH
16897: LD_VAR 0 7
16901: PPUSH
16902: CALL_OW 488
16906: NOT
16907: IFFALSE 16929
// begin _x := x ;
16909: LD_ADDR_VAR 0 6
16913: PUSH
16914: LD_VAR 0 4
16918: ST_TO_ADDR
// _y := y ;
16919: LD_ADDR_VAR 0 7
16923: PUSH
16924: LD_VAR 0 5
16928: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
16929: LD_ADDR_VAR 0 3
16933: PUSH
16934: LD_INT 1
16936: PPUSH
16937: LD_VAR 0 14
16941: PPUSH
16942: CALL_OW 12
16946: ST_TO_ADDR
// case i of 1 :
16947: LD_VAR 0 3
16951: PUSH
16952: LD_INT 1
16954: DOUBLE
16955: EQUAL
16956: IFTRUE 16960
16958: GO 16977
16960: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
16961: LD_VAR 0 1
16965: PPUSH
16966: LD_VAR 0 10
16970: PPUSH
16971: CALL_OW 115
16975: GO 17038
16977: LD_INT 2
16979: DOUBLE
16980: EQUAL
16981: IFTRUE 16985
16983: GO 17007
16985: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
16986: LD_VAR 0 1
16990: PPUSH
16991: LD_VAR 0 6
16995: PPUSH
16996: LD_VAR 0 7
17000: PPUSH
17001: CALL_OW 153
17005: GO 17038
17007: LD_INT 3
17009: DOUBLE
17010: EQUAL
17011: IFTRUE 17015
17013: GO 17037
17015: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
17016: LD_VAR 0 1
17020: PPUSH
17021: LD_VAR 0 6
17025: PPUSH
17026: LD_VAR 0 7
17030: PPUSH
17031: CALL_OW 154
17035: GO 17038
17037: POP
// end ;
17038: LD_VAR 0 2
17042: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
17043: LD_INT 0
17045: PPUSH
17046: PPUSH
17047: PPUSH
17048: PPUSH
17049: PPUSH
17050: PPUSH
// if not unit or not building then
17051: LD_VAR 0 1
17055: NOT
17056: PUSH
17057: LD_VAR 0 2
17061: NOT
17062: OR
17063: IFFALSE 17067
// exit ;
17065: GO 17225
// x := GetX ( building ) ;
17067: LD_ADDR_VAR 0 5
17071: PUSH
17072: LD_VAR 0 2
17076: PPUSH
17077: CALL_OW 250
17081: ST_TO_ADDR
// y := GetY ( building ) ;
17082: LD_ADDR_VAR 0 6
17086: PUSH
17087: LD_VAR 0 2
17091: PPUSH
17092: CALL_OW 251
17096: ST_TO_ADDR
// for i = 0 to 5 do
17097: LD_ADDR_VAR 0 4
17101: PUSH
17102: DOUBLE
17103: LD_INT 0
17105: DEC
17106: ST_TO_ADDR
17107: LD_INT 5
17109: PUSH
17110: FOR_TO
17111: IFFALSE 17223
// begin _x := ShiftX ( x , i , 3 ) ;
17113: LD_ADDR_VAR 0 7
17117: PUSH
17118: LD_VAR 0 5
17122: PPUSH
17123: LD_VAR 0 4
17127: PPUSH
17128: LD_INT 3
17130: PPUSH
17131: CALL_OW 272
17135: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
17136: LD_ADDR_VAR 0 8
17140: PUSH
17141: LD_VAR 0 6
17145: PPUSH
17146: LD_VAR 0 4
17150: PPUSH
17151: LD_INT 3
17153: PPUSH
17154: CALL_OW 273
17158: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
17159: LD_VAR 0 7
17163: PPUSH
17164: LD_VAR 0 8
17168: PPUSH
17169: CALL_OW 488
17173: NOT
17174: IFFALSE 17178
// continue ;
17176: GO 17110
// if HexInfo ( _x , _y ) = 0 then
17178: LD_VAR 0 7
17182: PPUSH
17183: LD_VAR 0 8
17187: PPUSH
17188: CALL_OW 428
17192: PUSH
17193: LD_INT 0
17195: EQUAL
17196: IFFALSE 17221
// begin ComMoveXY ( unit , _x , _y ) ;
17198: LD_VAR 0 1
17202: PPUSH
17203: LD_VAR 0 7
17207: PPUSH
17208: LD_VAR 0 8
17212: PPUSH
17213: CALL_OW 111
// exit ;
17217: POP
17218: POP
17219: GO 17225
// end ; end ;
17221: GO 17110
17223: POP
17224: POP
// end ;
17225: LD_VAR 0 3
17229: RET
// export function ScanBase ( side , base_area ) ; begin
17230: LD_INT 0
17232: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
17233: LD_ADDR_VAR 0 3
17237: PUSH
17238: LD_VAR 0 2
17242: PPUSH
17243: LD_INT 81
17245: PUSH
17246: LD_VAR 0 1
17250: PUSH
17251: EMPTY
17252: LIST
17253: LIST
17254: PPUSH
17255: CALL_OW 70
17259: ST_TO_ADDR
// end ;
17260: LD_VAR 0 3
17264: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17265: LD_INT 0
17267: PPUSH
17268: PPUSH
17269: PPUSH
17270: PPUSH
// result := false ;
17271: LD_ADDR_VAR 0 2
17275: PUSH
17276: LD_INT 0
17278: ST_TO_ADDR
// side := GetSide ( unit ) ;
17279: LD_ADDR_VAR 0 3
17283: PUSH
17284: LD_VAR 0 1
17288: PPUSH
17289: CALL_OW 255
17293: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17294: LD_ADDR_VAR 0 4
17298: PUSH
17299: LD_VAR 0 1
17303: PPUSH
17304: CALL_OW 248
17308: ST_TO_ADDR
// case nat of 1 :
17309: LD_VAR 0 4
17313: PUSH
17314: LD_INT 1
17316: DOUBLE
17317: EQUAL
17318: IFTRUE 17322
17320: GO 17333
17322: POP
// tech := tech_lassight ; 2 :
17323: LD_ADDR_VAR 0 5
17327: PUSH
17328: LD_INT 12
17330: ST_TO_ADDR
17331: GO 17372
17333: LD_INT 2
17335: DOUBLE
17336: EQUAL
17337: IFTRUE 17341
17339: GO 17352
17341: POP
// tech := tech_mortar ; 3 :
17342: LD_ADDR_VAR 0 5
17346: PUSH
17347: LD_INT 41
17349: ST_TO_ADDR
17350: GO 17372
17352: LD_INT 3
17354: DOUBLE
17355: EQUAL
17356: IFTRUE 17360
17358: GO 17371
17360: POP
// tech := tech_bazooka ; end ;
17361: LD_ADDR_VAR 0 5
17365: PUSH
17366: LD_INT 44
17368: ST_TO_ADDR
17369: GO 17372
17371: POP
// if Researched ( side , tech ) then
17372: LD_VAR 0 3
17376: PPUSH
17377: LD_VAR 0 5
17381: PPUSH
17382: CALL_OW 325
17386: IFFALSE 17413
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17388: LD_ADDR_VAR 0 2
17392: PUSH
17393: LD_INT 5
17395: PUSH
17396: LD_INT 8
17398: PUSH
17399: LD_INT 9
17401: PUSH
17402: EMPTY
17403: LIST
17404: LIST
17405: LIST
17406: PUSH
17407: LD_VAR 0 4
17411: ARRAY
17412: ST_TO_ADDR
// end ;
17413: LD_VAR 0 2
17417: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17418: LD_INT 0
17420: PPUSH
17421: PPUSH
17422: PPUSH
// if not mines then
17423: LD_VAR 0 2
17427: NOT
17428: IFFALSE 17432
// exit ;
17430: GO 17576
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17432: LD_ADDR_VAR 0 5
17436: PUSH
17437: LD_INT 81
17439: PUSH
17440: LD_VAR 0 1
17444: PUSH
17445: EMPTY
17446: LIST
17447: LIST
17448: PUSH
17449: LD_INT 3
17451: PUSH
17452: LD_INT 21
17454: PUSH
17455: LD_INT 3
17457: PUSH
17458: EMPTY
17459: LIST
17460: LIST
17461: PUSH
17462: EMPTY
17463: LIST
17464: LIST
17465: PUSH
17466: EMPTY
17467: LIST
17468: LIST
17469: PPUSH
17470: CALL_OW 69
17474: ST_TO_ADDR
// for i in mines do
17475: LD_ADDR_VAR 0 4
17479: PUSH
17480: LD_VAR 0 2
17484: PUSH
17485: FOR_IN
17486: IFFALSE 17574
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
17488: LD_VAR 0 4
17492: PUSH
17493: LD_INT 1
17495: ARRAY
17496: PPUSH
17497: LD_VAR 0 4
17501: PUSH
17502: LD_INT 2
17504: ARRAY
17505: PPUSH
17506: CALL_OW 458
17510: NOT
17511: IFFALSE 17515
// continue ;
17513: GO 17485
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
17515: LD_VAR 0 4
17519: PUSH
17520: LD_INT 1
17522: ARRAY
17523: PPUSH
17524: LD_VAR 0 4
17528: PUSH
17529: LD_INT 2
17531: ARRAY
17532: PPUSH
17533: CALL_OW 428
17537: PUSH
17538: LD_VAR 0 5
17542: IN
17543: IFFALSE 17572
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17545: LD_VAR 0 4
17549: PUSH
17550: LD_INT 1
17552: ARRAY
17553: PPUSH
17554: LD_VAR 0 4
17558: PUSH
17559: LD_INT 2
17561: ARRAY
17562: PPUSH
17563: LD_VAR 0 1
17567: PPUSH
17568: CALL_OW 456
// end ;
17572: GO 17485
17574: POP
17575: POP
// end ;
17576: LD_VAR 0 3
17580: RET
// export function Count ( array ) ; begin
17581: LD_INT 0
17583: PPUSH
// result := array + 0 ;
17584: LD_ADDR_VAR 0 2
17588: PUSH
17589: LD_VAR 0 1
17593: PUSH
17594: LD_INT 0
17596: PLUS
17597: ST_TO_ADDR
// end ;
17598: LD_VAR 0 2
17602: RET
// export function IsEmpty ( building ) ; begin
17603: LD_INT 0
17605: PPUSH
// if not building then
17606: LD_VAR 0 1
17610: NOT
17611: IFFALSE 17615
// exit ;
17613: GO 17658
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17615: LD_ADDR_VAR 0 2
17619: PUSH
17620: LD_VAR 0 1
17624: PUSH
17625: LD_INT 22
17627: PUSH
17628: LD_VAR 0 1
17632: PPUSH
17633: CALL_OW 255
17637: PUSH
17638: EMPTY
17639: LIST
17640: LIST
17641: PUSH
17642: LD_INT 58
17644: PUSH
17645: EMPTY
17646: LIST
17647: PUSH
17648: EMPTY
17649: LIST
17650: LIST
17651: PPUSH
17652: CALL_OW 69
17656: IN
17657: ST_TO_ADDR
// end ;
17658: LD_VAR 0 2
17662: RET
// export function IsNotFull ( building ) ; var places ; begin
17663: LD_INT 0
17665: PPUSH
17666: PPUSH
// if not building then
17667: LD_VAR 0 1
17671: NOT
17672: IFFALSE 17676
// exit ;
17674: GO 17704
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
17676: LD_ADDR_VAR 0 2
17680: PUSH
17681: LD_VAR 0 1
17685: PPUSH
17686: LD_INT 3
17688: PUSH
17689: LD_INT 62
17691: PUSH
17692: EMPTY
17693: LIST
17694: PUSH
17695: EMPTY
17696: LIST
17697: LIST
17698: PPUSH
17699: CALL_OW 72
17703: ST_TO_ADDR
// end ;
17704: LD_VAR 0 2
17708: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17709: LD_INT 0
17711: PPUSH
17712: PPUSH
17713: PPUSH
17714: PPUSH
// tmp := [ ] ;
17715: LD_ADDR_VAR 0 3
17719: PUSH
17720: EMPTY
17721: ST_TO_ADDR
// list := [ ] ;
17722: LD_ADDR_VAR 0 5
17726: PUSH
17727: EMPTY
17728: ST_TO_ADDR
// for i = 16 to 25 do
17729: LD_ADDR_VAR 0 4
17733: PUSH
17734: DOUBLE
17735: LD_INT 16
17737: DEC
17738: ST_TO_ADDR
17739: LD_INT 25
17741: PUSH
17742: FOR_TO
17743: IFFALSE 17816
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17745: LD_ADDR_VAR 0 3
17749: PUSH
17750: LD_VAR 0 3
17754: PUSH
17755: LD_INT 22
17757: PUSH
17758: LD_VAR 0 1
17762: PPUSH
17763: CALL_OW 255
17767: PUSH
17768: EMPTY
17769: LIST
17770: LIST
17771: PUSH
17772: LD_INT 91
17774: PUSH
17775: LD_VAR 0 1
17779: PUSH
17780: LD_INT 6
17782: PUSH
17783: EMPTY
17784: LIST
17785: LIST
17786: LIST
17787: PUSH
17788: LD_INT 30
17790: PUSH
17791: LD_VAR 0 4
17795: PUSH
17796: EMPTY
17797: LIST
17798: LIST
17799: PUSH
17800: EMPTY
17801: LIST
17802: LIST
17803: LIST
17804: PUSH
17805: EMPTY
17806: LIST
17807: PPUSH
17808: CALL_OW 69
17812: ADD
17813: ST_TO_ADDR
17814: GO 17742
17816: POP
17817: POP
// for i = 1 to tmp do
17818: LD_ADDR_VAR 0 4
17822: PUSH
17823: DOUBLE
17824: LD_INT 1
17826: DEC
17827: ST_TO_ADDR
17828: LD_VAR 0 3
17832: PUSH
17833: FOR_TO
17834: IFFALSE 17922
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17836: LD_ADDR_VAR 0 5
17840: PUSH
17841: LD_VAR 0 5
17845: PUSH
17846: LD_VAR 0 3
17850: PUSH
17851: LD_VAR 0 4
17855: ARRAY
17856: PPUSH
17857: CALL_OW 266
17861: PUSH
17862: LD_VAR 0 3
17866: PUSH
17867: LD_VAR 0 4
17871: ARRAY
17872: PPUSH
17873: CALL_OW 250
17877: PUSH
17878: LD_VAR 0 3
17882: PUSH
17883: LD_VAR 0 4
17887: ARRAY
17888: PPUSH
17889: CALL_OW 251
17893: PUSH
17894: LD_VAR 0 3
17898: PUSH
17899: LD_VAR 0 4
17903: ARRAY
17904: PPUSH
17905: CALL_OW 254
17909: PUSH
17910: EMPTY
17911: LIST
17912: LIST
17913: LIST
17914: LIST
17915: PUSH
17916: EMPTY
17917: LIST
17918: ADD
17919: ST_TO_ADDR
17920: GO 17833
17922: POP
17923: POP
// result := list ;
17924: LD_ADDR_VAR 0 2
17928: PUSH
17929: LD_VAR 0 5
17933: ST_TO_ADDR
// end ;
17934: LD_VAR 0 2
17938: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17939: LD_INT 0
17941: PPUSH
17942: PPUSH
17943: PPUSH
17944: PPUSH
17945: PPUSH
17946: PPUSH
17947: PPUSH
// if not factory then
17948: LD_VAR 0 1
17952: NOT
17953: IFFALSE 17957
// exit ;
17955: GO 18550
// if control = control_apeman then
17957: LD_VAR 0 4
17961: PUSH
17962: LD_INT 5
17964: EQUAL
17965: IFFALSE 18074
// begin tmp := UnitsInside ( factory ) ;
17967: LD_ADDR_VAR 0 8
17971: PUSH
17972: LD_VAR 0 1
17976: PPUSH
17977: CALL_OW 313
17981: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17982: LD_VAR 0 8
17986: PPUSH
17987: LD_INT 25
17989: PUSH
17990: LD_INT 12
17992: PUSH
17993: EMPTY
17994: LIST
17995: LIST
17996: PPUSH
17997: CALL_OW 72
18001: NOT
18002: IFFALSE 18012
// control := control_manual ;
18004: LD_ADDR_VAR 0 4
18008: PUSH
18009: LD_INT 1
18011: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18012: LD_ADDR_VAR 0 8
18016: PUSH
18017: LD_VAR 0 1
18021: PPUSH
18022: CALL 17709 0 1
18026: ST_TO_ADDR
// if tmp then
18027: LD_VAR 0 8
18031: IFFALSE 18074
// begin for i in tmp do
18033: LD_ADDR_VAR 0 7
18037: PUSH
18038: LD_VAR 0 8
18042: PUSH
18043: FOR_IN
18044: IFFALSE 18072
// if i [ 1 ] = b_ext_radio then
18046: LD_VAR 0 7
18050: PUSH
18051: LD_INT 1
18053: ARRAY
18054: PUSH
18055: LD_INT 22
18057: EQUAL
18058: IFFALSE 18070
// begin control := control_remote ;
18060: LD_ADDR_VAR 0 4
18064: PUSH
18065: LD_INT 2
18067: ST_TO_ADDR
// break ;
18068: GO 18072
// end ;
18070: GO 18043
18072: POP
18073: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18074: LD_VAR 0 1
18078: PPUSH
18079: LD_VAR 0 2
18083: PPUSH
18084: LD_VAR 0 3
18088: PPUSH
18089: LD_VAR 0 4
18093: PPUSH
18094: LD_VAR 0 5
18098: PPUSH
18099: CALL_OW 448
18103: IFFALSE 18138
// begin result := [ chassis , engine , control , weapon ] ;
18105: LD_ADDR_VAR 0 6
18109: PUSH
18110: LD_VAR 0 2
18114: PUSH
18115: LD_VAR 0 3
18119: PUSH
18120: LD_VAR 0 4
18124: PUSH
18125: LD_VAR 0 5
18129: PUSH
18130: EMPTY
18131: LIST
18132: LIST
18133: LIST
18134: LIST
18135: ST_TO_ADDR
// exit ;
18136: GO 18550
// end ; _chassis := AvailableChassisList ( factory ) ;
18138: LD_ADDR_VAR 0 9
18142: PUSH
18143: LD_VAR 0 1
18147: PPUSH
18148: CALL_OW 475
18152: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18153: LD_ADDR_VAR 0 11
18157: PUSH
18158: LD_VAR 0 1
18162: PPUSH
18163: CALL_OW 476
18167: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18168: LD_ADDR_VAR 0 12
18172: PUSH
18173: LD_VAR 0 1
18177: PPUSH
18178: CALL_OW 477
18182: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18183: LD_ADDR_VAR 0 10
18187: PUSH
18188: LD_VAR 0 1
18192: PPUSH
18193: CALL_OW 478
18197: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
18198: LD_VAR 0 9
18202: NOT
18203: PUSH
18204: LD_VAR 0 11
18208: NOT
18209: OR
18210: PUSH
18211: LD_VAR 0 12
18215: NOT
18216: OR
18217: PUSH
18218: LD_VAR 0 10
18222: NOT
18223: OR
18224: IFFALSE 18259
// begin result := [ chassis , engine , control , weapon ] ;
18226: LD_ADDR_VAR 0 6
18230: PUSH
18231: LD_VAR 0 2
18235: PUSH
18236: LD_VAR 0 3
18240: PUSH
18241: LD_VAR 0 4
18245: PUSH
18246: LD_VAR 0 5
18250: PUSH
18251: EMPTY
18252: LIST
18253: LIST
18254: LIST
18255: LIST
18256: ST_TO_ADDR
// exit ;
18257: GO 18550
// end ; if not chassis in _chassis then
18259: LD_VAR 0 2
18263: PUSH
18264: LD_VAR 0 9
18268: IN
18269: NOT
18270: IFFALSE 18296
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18272: LD_ADDR_VAR 0 2
18276: PUSH
18277: LD_VAR 0 9
18281: PUSH
18282: LD_INT 1
18284: PPUSH
18285: LD_VAR 0 9
18289: PPUSH
18290: CALL_OW 12
18294: ARRAY
18295: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18296: LD_VAR 0 2
18300: PPUSH
18301: LD_VAR 0 3
18305: PPUSH
18306: CALL 18555 0 2
18310: NOT
18311: IFFALSE 18370
// repeat engine := _engine [ 1 ] ;
18313: LD_ADDR_VAR 0 3
18317: PUSH
18318: LD_VAR 0 11
18322: PUSH
18323: LD_INT 1
18325: ARRAY
18326: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18327: LD_ADDR_VAR 0 11
18331: PUSH
18332: LD_VAR 0 11
18336: PPUSH
18337: LD_INT 1
18339: PPUSH
18340: CALL_OW 3
18344: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18345: LD_VAR 0 2
18349: PPUSH
18350: LD_VAR 0 3
18354: PPUSH
18355: CALL 18555 0 2
18359: PUSH
18360: LD_VAR 0 11
18364: PUSH
18365: EMPTY
18366: EQUAL
18367: OR
18368: IFFALSE 18313
// if not control in _control then
18370: LD_VAR 0 4
18374: PUSH
18375: LD_VAR 0 12
18379: IN
18380: NOT
18381: IFFALSE 18407
// control := _control [ rand ( 1 , _control ) ] ;
18383: LD_ADDR_VAR 0 4
18387: PUSH
18388: LD_VAR 0 12
18392: PUSH
18393: LD_INT 1
18395: PPUSH
18396: LD_VAR 0 12
18400: PPUSH
18401: CALL_OW 12
18405: ARRAY
18406: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18407: LD_VAR 0 2
18411: PPUSH
18412: LD_VAR 0 5
18416: PPUSH
18417: CALL 18775 0 2
18421: NOT
18422: IFFALSE 18481
// repeat weapon := _weapon [ 1 ] ;
18424: LD_ADDR_VAR 0 5
18428: PUSH
18429: LD_VAR 0 10
18433: PUSH
18434: LD_INT 1
18436: ARRAY
18437: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18438: LD_ADDR_VAR 0 10
18442: PUSH
18443: LD_VAR 0 10
18447: PPUSH
18448: LD_INT 1
18450: PPUSH
18451: CALL_OW 3
18455: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18456: LD_VAR 0 2
18460: PPUSH
18461: LD_VAR 0 5
18465: PPUSH
18466: CALL 18775 0 2
18470: PUSH
18471: LD_VAR 0 10
18475: PUSH
18476: EMPTY
18477: EQUAL
18478: OR
18479: IFFALSE 18424
// result := [ ] ;
18481: LD_ADDR_VAR 0 6
18485: PUSH
18486: EMPTY
18487: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18488: LD_VAR 0 1
18492: PPUSH
18493: LD_VAR 0 2
18497: PPUSH
18498: LD_VAR 0 3
18502: PPUSH
18503: LD_VAR 0 4
18507: PPUSH
18508: LD_VAR 0 5
18512: PPUSH
18513: CALL_OW 448
18517: IFFALSE 18550
// result := [ chassis , engine , control , weapon ] ;
18519: LD_ADDR_VAR 0 6
18523: PUSH
18524: LD_VAR 0 2
18528: PUSH
18529: LD_VAR 0 3
18533: PUSH
18534: LD_VAR 0 4
18538: PUSH
18539: LD_VAR 0 5
18543: PUSH
18544: EMPTY
18545: LIST
18546: LIST
18547: LIST
18548: LIST
18549: ST_TO_ADDR
// end ;
18550: LD_VAR 0 6
18554: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18555: LD_INT 0
18557: PPUSH
// if not chassis or not engine then
18558: LD_VAR 0 1
18562: NOT
18563: PUSH
18564: LD_VAR 0 2
18568: NOT
18569: OR
18570: IFFALSE 18574
// exit ;
18572: GO 18770
// case engine of engine_solar :
18574: LD_VAR 0 2
18578: PUSH
18579: LD_INT 2
18581: DOUBLE
18582: EQUAL
18583: IFTRUE 18587
18585: GO 18625
18587: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18588: LD_ADDR_VAR 0 3
18592: PUSH
18593: LD_INT 11
18595: PUSH
18596: LD_INT 12
18598: PUSH
18599: LD_INT 13
18601: PUSH
18602: LD_INT 14
18604: PUSH
18605: LD_INT 1
18607: PUSH
18608: LD_INT 2
18610: PUSH
18611: LD_INT 3
18613: PUSH
18614: EMPTY
18615: LIST
18616: LIST
18617: LIST
18618: LIST
18619: LIST
18620: LIST
18621: LIST
18622: ST_TO_ADDR
18623: GO 18754
18625: LD_INT 1
18627: DOUBLE
18628: EQUAL
18629: IFTRUE 18633
18631: GO 18695
18633: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18634: LD_ADDR_VAR 0 3
18638: PUSH
18639: LD_INT 11
18641: PUSH
18642: LD_INT 12
18644: PUSH
18645: LD_INT 13
18647: PUSH
18648: LD_INT 14
18650: PUSH
18651: LD_INT 1
18653: PUSH
18654: LD_INT 2
18656: PUSH
18657: LD_INT 3
18659: PUSH
18660: LD_INT 4
18662: PUSH
18663: LD_INT 5
18665: PUSH
18666: LD_INT 21
18668: PUSH
18669: LD_INT 23
18671: PUSH
18672: LD_INT 22
18674: PUSH
18675: LD_INT 24
18677: PUSH
18678: EMPTY
18679: LIST
18680: LIST
18681: LIST
18682: LIST
18683: LIST
18684: LIST
18685: LIST
18686: LIST
18687: LIST
18688: LIST
18689: LIST
18690: LIST
18691: LIST
18692: ST_TO_ADDR
18693: GO 18754
18695: LD_INT 3
18697: DOUBLE
18698: EQUAL
18699: IFTRUE 18703
18701: GO 18753
18703: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18704: LD_ADDR_VAR 0 3
18708: PUSH
18709: LD_INT 13
18711: PUSH
18712: LD_INT 14
18714: PUSH
18715: LD_INT 2
18717: PUSH
18718: LD_INT 3
18720: PUSH
18721: LD_INT 4
18723: PUSH
18724: LD_INT 5
18726: PUSH
18727: LD_INT 21
18729: PUSH
18730: LD_INT 22
18732: PUSH
18733: LD_INT 23
18735: PUSH
18736: LD_INT 24
18738: PUSH
18739: EMPTY
18740: LIST
18741: LIST
18742: LIST
18743: LIST
18744: LIST
18745: LIST
18746: LIST
18747: LIST
18748: LIST
18749: LIST
18750: ST_TO_ADDR
18751: GO 18754
18753: POP
// result := ( chassis in result ) ;
18754: LD_ADDR_VAR 0 3
18758: PUSH
18759: LD_VAR 0 1
18763: PUSH
18764: LD_VAR 0 3
18768: IN
18769: ST_TO_ADDR
// end ;
18770: LD_VAR 0 3
18774: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18775: LD_INT 0
18777: PPUSH
// if not chassis or not weapon then
18778: LD_VAR 0 1
18782: NOT
18783: PUSH
18784: LD_VAR 0 2
18788: NOT
18789: OR
18790: IFFALSE 18794
// exit ;
18792: GO 19854
// case weapon of us_machine_gun :
18794: LD_VAR 0 2
18798: PUSH
18799: LD_INT 2
18801: DOUBLE
18802: EQUAL
18803: IFTRUE 18807
18805: GO 18837
18807: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18808: LD_ADDR_VAR 0 3
18812: PUSH
18813: LD_INT 1
18815: PUSH
18816: LD_INT 2
18818: PUSH
18819: LD_INT 3
18821: PUSH
18822: LD_INT 4
18824: PUSH
18825: LD_INT 5
18827: PUSH
18828: EMPTY
18829: LIST
18830: LIST
18831: LIST
18832: LIST
18833: LIST
18834: ST_TO_ADDR
18835: GO 19838
18837: LD_INT 3
18839: DOUBLE
18840: EQUAL
18841: IFTRUE 18845
18843: GO 18875
18845: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18846: LD_ADDR_VAR 0 3
18850: PUSH
18851: LD_INT 1
18853: PUSH
18854: LD_INT 2
18856: PUSH
18857: LD_INT 3
18859: PUSH
18860: LD_INT 4
18862: PUSH
18863: LD_INT 5
18865: PUSH
18866: EMPTY
18867: LIST
18868: LIST
18869: LIST
18870: LIST
18871: LIST
18872: ST_TO_ADDR
18873: GO 19838
18875: LD_INT 11
18877: DOUBLE
18878: EQUAL
18879: IFTRUE 18883
18881: GO 18913
18883: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18884: LD_ADDR_VAR 0 3
18888: PUSH
18889: LD_INT 1
18891: PUSH
18892: LD_INT 2
18894: PUSH
18895: LD_INT 3
18897: PUSH
18898: LD_INT 4
18900: PUSH
18901: LD_INT 5
18903: PUSH
18904: EMPTY
18905: LIST
18906: LIST
18907: LIST
18908: LIST
18909: LIST
18910: ST_TO_ADDR
18911: GO 19838
18913: LD_INT 4
18915: DOUBLE
18916: EQUAL
18917: IFTRUE 18921
18919: GO 18947
18921: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18922: LD_ADDR_VAR 0 3
18926: PUSH
18927: LD_INT 2
18929: PUSH
18930: LD_INT 3
18932: PUSH
18933: LD_INT 4
18935: PUSH
18936: LD_INT 5
18938: PUSH
18939: EMPTY
18940: LIST
18941: LIST
18942: LIST
18943: LIST
18944: ST_TO_ADDR
18945: GO 19838
18947: LD_INT 5
18949: DOUBLE
18950: EQUAL
18951: IFTRUE 18955
18953: GO 18981
18955: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18956: LD_ADDR_VAR 0 3
18960: PUSH
18961: LD_INT 2
18963: PUSH
18964: LD_INT 3
18966: PUSH
18967: LD_INT 4
18969: PUSH
18970: LD_INT 5
18972: PUSH
18973: EMPTY
18974: LIST
18975: LIST
18976: LIST
18977: LIST
18978: ST_TO_ADDR
18979: GO 19838
18981: LD_INT 9
18983: DOUBLE
18984: EQUAL
18985: IFTRUE 18989
18987: GO 19015
18989: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18990: LD_ADDR_VAR 0 3
18994: PUSH
18995: LD_INT 2
18997: PUSH
18998: LD_INT 3
19000: PUSH
19001: LD_INT 4
19003: PUSH
19004: LD_INT 5
19006: PUSH
19007: EMPTY
19008: LIST
19009: LIST
19010: LIST
19011: LIST
19012: ST_TO_ADDR
19013: GO 19838
19015: LD_INT 7
19017: DOUBLE
19018: EQUAL
19019: IFTRUE 19023
19021: GO 19049
19023: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19024: LD_ADDR_VAR 0 3
19028: PUSH
19029: LD_INT 2
19031: PUSH
19032: LD_INT 3
19034: PUSH
19035: LD_INT 4
19037: PUSH
19038: LD_INT 5
19040: PUSH
19041: EMPTY
19042: LIST
19043: LIST
19044: LIST
19045: LIST
19046: ST_TO_ADDR
19047: GO 19838
19049: LD_INT 12
19051: DOUBLE
19052: EQUAL
19053: IFTRUE 19057
19055: GO 19083
19057: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
19058: LD_ADDR_VAR 0 3
19062: PUSH
19063: LD_INT 2
19065: PUSH
19066: LD_INT 3
19068: PUSH
19069: LD_INT 4
19071: PUSH
19072: LD_INT 5
19074: PUSH
19075: EMPTY
19076: LIST
19077: LIST
19078: LIST
19079: LIST
19080: ST_TO_ADDR
19081: GO 19838
19083: LD_INT 13
19085: DOUBLE
19086: EQUAL
19087: IFTRUE 19091
19089: GO 19117
19091: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
19092: LD_ADDR_VAR 0 3
19096: PUSH
19097: LD_INT 2
19099: PUSH
19100: LD_INT 3
19102: PUSH
19103: LD_INT 4
19105: PUSH
19106: LD_INT 5
19108: PUSH
19109: EMPTY
19110: LIST
19111: LIST
19112: LIST
19113: LIST
19114: ST_TO_ADDR
19115: GO 19838
19117: LD_INT 14
19119: DOUBLE
19120: EQUAL
19121: IFTRUE 19125
19123: GO 19143
19125: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
19126: LD_ADDR_VAR 0 3
19130: PUSH
19131: LD_INT 4
19133: PUSH
19134: LD_INT 5
19136: PUSH
19137: EMPTY
19138: LIST
19139: LIST
19140: ST_TO_ADDR
19141: GO 19838
19143: LD_INT 6
19145: DOUBLE
19146: EQUAL
19147: IFTRUE 19151
19149: GO 19169
19151: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19152: LD_ADDR_VAR 0 3
19156: PUSH
19157: LD_INT 4
19159: PUSH
19160: LD_INT 5
19162: PUSH
19163: EMPTY
19164: LIST
19165: LIST
19166: ST_TO_ADDR
19167: GO 19838
19169: LD_INT 10
19171: DOUBLE
19172: EQUAL
19173: IFTRUE 19177
19175: GO 19195
19177: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19178: LD_ADDR_VAR 0 3
19182: PUSH
19183: LD_INT 4
19185: PUSH
19186: LD_INT 5
19188: PUSH
19189: EMPTY
19190: LIST
19191: LIST
19192: ST_TO_ADDR
19193: GO 19838
19195: LD_INT 22
19197: DOUBLE
19198: EQUAL
19199: IFTRUE 19203
19201: GO 19229
19203: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19204: LD_ADDR_VAR 0 3
19208: PUSH
19209: LD_INT 11
19211: PUSH
19212: LD_INT 12
19214: PUSH
19215: LD_INT 13
19217: PUSH
19218: LD_INT 14
19220: PUSH
19221: EMPTY
19222: LIST
19223: LIST
19224: LIST
19225: LIST
19226: ST_TO_ADDR
19227: GO 19838
19229: LD_INT 23
19231: DOUBLE
19232: EQUAL
19233: IFTRUE 19237
19235: GO 19263
19237: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19238: LD_ADDR_VAR 0 3
19242: PUSH
19243: LD_INT 11
19245: PUSH
19246: LD_INT 12
19248: PUSH
19249: LD_INT 13
19251: PUSH
19252: LD_INT 14
19254: PUSH
19255: EMPTY
19256: LIST
19257: LIST
19258: LIST
19259: LIST
19260: ST_TO_ADDR
19261: GO 19838
19263: LD_INT 24
19265: DOUBLE
19266: EQUAL
19267: IFTRUE 19271
19269: GO 19297
19271: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19272: LD_ADDR_VAR 0 3
19276: PUSH
19277: LD_INT 11
19279: PUSH
19280: LD_INT 12
19282: PUSH
19283: LD_INT 13
19285: PUSH
19286: LD_INT 14
19288: PUSH
19289: EMPTY
19290: LIST
19291: LIST
19292: LIST
19293: LIST
19294: ST_TO_ADDR
19295: GO 19838
19297: LD_INT 30
19299: DOUBLE
19300: EQUAL
19301: IFTRUE 19305
19303: GO 19331
19305: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19306: LD_ADDR_VAR 0 3
19310: PUSH
19311: LD_INT 11
19313: PUSH
19314: LD_INT 12
19316: PUSH
19317: LD_INT 13
19319: PUSH
19320: LD_INT 14
19322: PUSH
19323: EMPTY
19324: LIST
19325: LIST
19326: LIST
19327: LIST
19328: ST_TO_ADDR
19329: GO 19838
19331: LD_INT 25
19333: DOUBLE
19334: EQUAL
19335: IFTRUE 19339
19337: GO 19357
19339: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19340: LD_ADDR_VAR 0 3
19344: PUSH
19345: LD_INT 13
19347: PUSH
19348: LD_INT 14
19350: PUSH
19351: EMPTY
19352: LIST
19353: LIST
19354: ST_TO_ADDR
19355: GO 19838
19357: LD_INT 27
19359: DOUBLE
19360: EQUAL
19361: IFTRUE 19365
19363: GO 19383
19365: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
19366: LD_ADDR_VAR 0 3
19370: PUSH
19371: LD_INT 13
19373: PUSH
19374: LD_INT 14
19376: PUSH
19377: EMPTY
19378: LIST
19379: LIST
19380: ST_TO_ADDR
19381: GO 19838
19383: LD_INT 92
19385: DOUBLE
19386: EQUAL
19387: IFTRUE 19391
19389: GO 19417
19391: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19392: LD_ADDR_VAR 0 3
19396: PUSH
19397: LD_INT 11
19399: PUSH
19400: LD_INT 12
19402: PUSH
19403: LD_INT 13
19405: PUSH
19406: LD_INT 14
19408: PUSH
19409: EMPTY
19410: LIST
19411: LIST
19412: LIST
19413: LIST
19414: ST_TO_ADDR
19415: GO 19838
19417: LD_INT 28
19419: DOUBLE
19420: EQUAL
19421: IFTRUE 19425
19423: GO 19443
19425: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19426: LD_ADDR_VAR 0 3
19430: PUSH
19431: LD_INT 13
19433: PUSH
19434: LD_INT 14
19436: PUSH
19437: EMPTY
19438: LIST
19439: LIST
19440: ST_TO_ADDR
19441: GO 19838
19443: LD_INT 29
19445: DOUBLE
19446: EQUAL
19447: IFTRUE 19451
19449: GO 19469
19451: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19452: LD_ADDR_VAR 0 3
19456: PUSH
19457: LD_INT 13
19459: PUSH
19460: LD_INT 14
19462: PUSH
19463: EMPTY
19464: LIST
19465: LIST
19466: ST_TO_ADDR
19467: GO 19838
19469: LD_INT 31
19471: DOUBLE
19472: EQUAL
19473: IFTRUE 19477
19475: GO 19495
19477: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19478: LD_ADDR_VAR 0 3
19482: PUSH
19483: LD_INT 13
19485: PUSH
19486: LD_INT 14
19488: PUSH
19489: EMPTY
19490: LIST
19491: LIST
19492: ST_TO_ADDR
19493: GO 19838
19495: LD_INT 26
19497: DOUBLE
19498: EQUAL
19499: IFTRUE 19503
19501: GO 19521
19503: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19504: LD_ADDR_VAR 0 3
19508: PUSH
19509: LD_INT 13
19511: PUSH
19512: LD_INT 14
19514: PUSH
19515: EMPTY
19516: LIST
19517: LIST
19518: ST_TO_ADDR
19519: GO 19838
19521: LD_INT 42
19523: DOUBLE
19524: EQUAL
19525: IFTRUE 19529
19527: GO 19555
19529: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19530: LD_ADDR_VAR 0 3
19534: PUSH
19535: LD_INT 21
19537: PUSH
19538: LD_INT 22
19540: PUSH
19541: LD_INT 23
19543: PUSH
19544: LD_INT 24
19546: PUSH
19547: EMPTY
19548: LIST
19549: LIST
19550: LIST
19551: LIST
19552: ST_TO_ADDR
19553: GO 19838
19555: LD_INT 43
19557: DOUBLE
19558: EQUAL
19559: IFTRUE 19563
19561: GO 19589
19563: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19564: LD_ADDR_VAR 0 3
19568: PUSH
19569: LD_INT 21
19571: PUSH
19572: LD_INT 22
19574: PUSH
19575: LD_INT 23
19577: PUSH
19578: LD_INT 24
19580: PUSH
19581: EMPTY
19582: LIST
19583: LIST
19584: LIST
19585: LIST
19586: ST_TO_ADDR
19587: GO 19838
19589: LD_INT 44
19591: DOUBLE
19592: EQUAL
19593: IFTRUE 19597
19595: GO 19623
19597: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19598: LD_ADDR_VAR 0 3
19602: PUSH
19603: LD_INT 21
19605: PUSH
19606: LD_INT 22
19608: PUSH
19609: LD_INT 23
19611: PUSH
19612: LD_INT 24
19614: PUSH
19615: EMPTY
19616: LIST
19617: LIST
19618: LIST
19619: LIST
19620: ST_TO_ADDR
19621: GO 19838
19623: LD_INT 45
19625: DOUBLE
19626: EQUAL
19627: IFTRUE 19631
19629: GO 19657
19631: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19632: LD_ADDR_VAR 0 3
19636: PUSH
19637: LD_INT 21
19639: PUSH
19640: LD_INT 22
19642: PUSH
19643: LD_INT 23
19645: PUSH
19646: LD_INT 24
19648: PUSH
19649: EMPTY
19650: LIST
19651: LIST
19652: LIST
19653: LIST
19654: ST_TO_ADDR
19655: GO 19838
19657: LD_INT 49
19659: DOUBLE
19660: EQUAL
19661: IFTRUE 19665
19663: GO 19691
19665: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19666: LD_ADDR_VAR 0 3
19670: PUSH
19671: LD_INT 21
19673: PUSH
19674: LD_INT 22
19676: PUSH
19677: LD_INT 23
19679: PUSH
19680: LD_INT 24
19682: PUSH
19683: EMPTY
19684: LIST
19685: LIST
19686: LIST
19687: LIST
19688: ST_TO_ADDR
19689: GO 19838
19691: LD_INT 51
19693: DOUBLE
19694: EQUAL
19695: IFTRUE 19699
19697: GO 19725
19699: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19700: LD_ADDR_VAR 0 3
19704: PUSH
19705: LD_INT 21
19707: PUSH
19708: LD_INT 22
19710: PUSH
19711: LD_INT 23
19713: PUSH
19714: LD_INT 24
19716: PUSH
19717: EMPTY
19718: LIST
19719: LIST
19720: LIST
19721: LIST
19722: ST_TO_ADDR
19723: GO 19838
19725: LD_INT 52
19727: DOUBLE
19728: EQUAL
19729: IFTRUE 19733
19731: GO 19759
19733: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19734: LD_ADDR_VAR 0 3
19738: PUSH
19739: LD_INT 21
19741: PUSH
19742: LD_INT 22
19744: PUSH
19745: LD_INT 23
19747: PUSH
19748: LD_INT 24
19750: PUSH
19751: EMPTY
19752: LIST
19753: LIST
19754: LIST
19755: LIST
19756: ST_TO_ADDR
19757: GO 19838
19759: LD_INT 53
19761: DOUBLE
19762: EQUAL
19763: IFTRUE 19767
19765: GO 19785
19767: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19768: LD_ADDR_VAR 0 3
19772: PUSH
19773: LD_INT 23
19775: PUSH
19776: LD_INT 24
19778: PUSH
19779: EMPTY
19780: LIST
19781: LIST
19782: ST_TO_ADDR
19783: GO 19838
19785: LD_INT 46
19787: DOUBLE
19788: EQUAL
19789: IFTRUE 19793
19791: GO 19811
19793: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19794: LD_ADDR_VAR 0 3
19798: PUSH
19799: LD_INT 23
19801: PUSH
19802: LD_INT 24
19804: PUSH
19805: EMPTY
19806: LIST
19807: LIST
19808: ST_TO_ADDR
19809: GO 19838
19811: LD_INT 47
19813: DOUBLE
19814: EQUAL
19815: IFTRUE 19819
19817: GO 19837
19819: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19820: LD_ADDR_VAR 0 3
19824: PUSH
19825: LD_INT 23
19827: PUSH
19828: LD_INT 24
19830: PUSH
19831: EMPTY
19832: LIST
19833: LIST
19834: ST_TO_ADDR
19835: GO 19838
19837: POP
// result := ( chassis in result ) ;
19838: LD_ADDR_VAR 0 3
19842: PUSH
19843: LD_VAR 0 1
19847: PUSH
19848: LD_VAR 0 3
19852: IN
19853: ST_TO_ADDR
// end ;
19854: LD_VAR 0 3
19858: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19859: LD_INT 0
19861: PPUSH
19862: PPUSH
19863: PPUSH
19864: PPUSH
19865: PPUSH
19866: PPUSH
19867: PPUSH
// result := array ;
19868: LD_ADDR_VAR 0 5
19872: PUSH
19873: LD_VAR 0 1
19877: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19878: LD_VAR 0 1
19882: NOT
19883: PUSH
19884: LD_VAR 0 2
19888: NOT
19889: OR
19890: PUSH
19891: LD_VAR 0 3
19895: NOT
19896: OR
19897: PUSH
19898: LD_VAR 0 2
19902: PUSH
19903: LD_VAR 0 1
19907: GREATER
19908: OR
19909: PUSH
19910: LD_VAR 0 3
19914: PUSH
19915: LD_VAR 0 1
19919: GREATER
19920: OR
19921: IFFALSE 19925
// exit ;
19923: GO 20221
// if direction then
19925: LD_VAR 0 4
19929: IFFALSE 19993
// begin d := 1 ;
19931: LD_ADDR_VAR 0 9
19935: PUSH
19936: LD_INT 1
19938: ST_TO_ADDR
// if i_from > i_to then
19939: LD_VAR 0 2
19943: PUSH
19944: LD_VAR 0 3
19948: GREATER
19949: IFFALSE 19975
// length := ( array - i_from ) + i_to else
19951: LD_ADDR_VAR 0 11
19955: PUSH
19956: LD_VAR 0 1
19960: PUSH
19961: LD_VAR 0 2
19965: MINUS
19966: PUSH
19967: LD_VAR 0 3
19971: PLUS
19972: ST_TO_ADDR
19973: GO 19991
// length := i_to - i_from ;
19975: LD_ADDR_VAR 0 11
19979: PUSH
19980: LD_VAR 0 3
19984: PUSH
19985: LD_VAR 0 2
19989: MINUS
19990: ST_TO_ADDR
// end else
19991: GO 20054
// begin d := - 1 ;
19993: LD_ADDR_VAR 0 9
19997: PUSH
19998: LD_INT 1
20000: NEG
20001: ST_TO_ADDR
// if i_from > i_to then
20002: LD_VAR 0 2
20006: PUSH
20007: LD_VAR 0 3
20011: GREATER
20012: IFFALSE 20032
// length := i_from - i_to else
20014: LD_ADDR_VAR 0 11
20018: PUSH
20019: LD_VAR 0 2
20023: PUSH
20024: LD_VAR 0 3
20028: MINUS
20029: ST_TO_ADDR
20030: GO 20054
// length := ( array - i_to ) + i_from ;
20032: LD_ADDR_VAR 0 11
20036: PUSH
20037: LD_VAR 0 1
20041: PUSH
20042: LD_VAR 0 3
20046: MINUS
20047: PUSH
20048: LD_VAR 0 2
20052: PLUS
20053: ST_TO_ADDR
// end ; if not length then
20054: LD_VAR 0 11
20058: NOT
20059: IFFALSE 20063
// exit ;
20061: GO 20221
// tmp := array ;
20063: LD_ADDR_VAR 0 10
20067: PUSH
20068: LD_VAR 0 1
20072: ST_TO_ADDR
// for i = 1 to length do
20073: LD_ADDR_VAR 0 6
20077: PUSH
20078: DOUBLE
20079: LD_INT 1
20081: DEC
20082: ST_TO_ADDR
20083: LD_VAR 0 11
20087: PUSH
20088: FOR_TO
20089: IFFALSE 20209
// begin for j = 1 to array do
20091: LD_ADDR_VAR 0 7
20095: PUSH
20096: DOUBLE
20097: LD_INT 1
20099: DEC
20100: ST_TO_ADDR
20101: LD_VAR 0 1
20105: PUSH
20106: FOR_TO
20107: IFFALSE 20195
// begin k := j + d ;
20109: LD_ADDR_VAR 0 8
20113: PUSH
20114: LD_VAR 0 7
20118: PUSH
20119: LD_VAR 0 9
20123: PLUS
20124: ST_TO_ADDR
// if k > array then
20125: LD_VAR 0 8
20129: PUSH
20130: LD_VAR 0 1
20134: GREATER
20135: IFFALSE 20145
// k := 1 ;
20137: LD_ADDR_VAR 0 8
20141: PUSH
20142: LD_INT 1
20144: ST_TO_ADDR
// if not k then
20145: LD_VAR 0 8
20149: NOT
20150: IFFALSE 20162
// k := array ;
20152: LD_ADDR_VAR 0 8
20156: PUSH
20157: LD_VAR 0 1
20161: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
20162: LD_ADDR_VAR 0 10
20166: PUSH
20167: LD_VAR 0 10
20171: PPUSH
20172: LD_VAR 0 8
20176: PPUSH
20177: LD_VAR 0 1
20181: PUSH
20182: LD_VAR 0 7
20186: ARRAY
20187: PPUSH
20188: CALL_OW 1
20192: ST_TO_ADDR
// end ;
20193: GO 20106
20195: POP
20196: POP
// array := tmp ;
20197: LD_ADDR_VAR 0 1
20201: PUSH
20202: LD_VAR 0 10
20206: ST_TO_ADDR
// end ;
20207: GO 20088
20209: POP
20210: POP
// result := array ;
20211: LD_ADDR_VAR 0 5
20215: PUSH
20216: LD_VAR 0 1
20220: ST_TO_ADDR
// end ;
20221: LD_VAR 0 5
20225: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20226: LD_INT 0
20228: PPUSH
20229: PPUSH
// result := 0 ;
20230: LD_ADDR_VAR 0 3
20234: PUSH
20235: LD_INT 0
20237: ST_TO_ADDR
// if not array or not value in array then
20238: LD_VAR 0 1
20242: NOT
20243: PUSH
20244: LD_VAR 0 2
20248: PUSH
20249: LD_VAR 0 1
20253: IN
20254: NOT
20255: OR
20256: IFFALSE 20260
// exit ;
20258: GO 20314
// for i = 1 to array do
20260: LD_ADDR_VAR 0 4
20264: PUSH
20265: DOUBLE
20266: LD_INT 1
20268: DEC
20269: ST_TO_ADDR
20270: LD_VAR 0 1
20274: PUSH
20275: FOR_TO
20276: IFFALSE 20312
// if value = array [ i ] then
20278: LD_VAR 0 2
20282: PUSH
20283: LD_VAR 0 1
20287: PUSH
20288: LD_VAR 0 4
20292: ARRAY
20293: EQUAL
20294: IFFALSE 20310
// begin result := i ;
20296: LD_ADDR_VAR 0 3
20300: PUSH
20301: LD_VAR 0 4
20305: ST_TO_ADDR
// exit ;
20306: POP
20307: POP
20308: GO 20314
// end ;
20310: GO 20275
20312: POP
20313: POP
// end ;
20314: LD_VAR 0 3
20318: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20319: LD_INT 0
20321: PPUSH
// vc_chassis := chassis ;
20322: LD_ADDR_OWVAR 37
20326: PUSH
20327: LD_VAR 0 1
20331: ST_TO_ADDR
// vc_engine := engine ;
20332: LD_ADDR_OWVAR 39
20336: PUSH
20337: LD_VAR 0 2
20341: ST_TO_ADDR
// vc_control := control ;
20342: LD_ADDR_OWVAR 38
20346: PUSH
20347: LD_VAR 0 3
20351: ST_TO_ADDR
// vc_weapon := weapon ;
20352: LD_ADDR_OWVAR 40
20356: PUSH
20357: LD_VAR 0 4
20361: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20362: LD_ADDR_OWVAR 41
20366: PUSH
20367: LD_VAR 0 5
20371: ST_TO_ADDR
// end ;
20372: LD_VAR 0 6
20376: RET
// export function WantPlant ( unit ) ; var task ; begin
20377: LD_INT 0
20379: PPUSH
20380: PPUSH
// result := false ;
20381: LD_ADDR_VAR 0 2
20385: PUSH
20386: LD_INT 0
20388: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20389: LD_ADDR_VAR 0 3
20393: PUSH
20394: LD_VAR 0 1
20398: PPUSH
20399: CALL_OW 437
20403: ST_TO_ADDR
// if task then
20404: LD_VAR 0 3
20408: IFFALSE 20436
// if task [ 1 ] [ 1 ] = p then
20410: LD_VAR 0 3
20414: PUSH
20415: LD_INT 1
20417: ARRAY
20418: PUSH
20419: LD_INT 1
20421: ARRAY
20422: PUSH
20423: LD_STRING p
20425: EQUAL
20426: IFFALSE 20436
// result := true ;
20428: LD_ADDR_VAR 0 2
20432: PUSH
20433: LD_INT 1
20435: ST_TO_ADDR
// end ;
20436: LD_VAR 0 2
20440: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20441: LD_INT 0
20443: PPUSH
20444: PPUSH
20445: PPUSH
20446: PPUSH
// if pos < 1 then
20447: LD_VAR 0 2
20451: PUSH
20452: LD_INT 1
20454: LESS
20455: IFFALSE 20459
// exit ;
20457: GO 20762
// if pos = 1 then
20459: LD_VAR 0 2
20463: PUSH
20464: LD_INT 1
20466: EQUAL
20467: IFFALSE 20500
// result := Replace ( arr , pos [ 1 ] , value ) else
20469: LD_ADDR_VAR 0 4
20473: PUSH
20474: LD_VAR 0 1
20478: PPUSH
20479: LD_VAR 0 2
20483: PUSH
20484: LD_INT 1
20486: ARRAY
20487: PPUSH
20488: LD_VAR 0 3
20492: PPUSH
20493: CALL_OW 1
20497: ST_TO_ADDR
20498: GO 20762
// begin tmp := arr ;
20500: LD_ADDR_VAR 0 6
20504: PUSH
20505: LD_VAR 0 1
20509: ST_TO_ADDR
// s_arr := [ tmp ] ;
20510: LD_ADDR_VAR 0 7
20514: PUSH
20515: LD_VAR 0 6
20519: PUSH
20520: EMPTY
20521: LIST
20522: ST_TO_ADDR
// for i = 1 to pos - 1 do
20523: LD_ADDR_VAR 0 5
20527: PUSH
20528: DOUBLE
20529: LD_INT 1
20531: DEC
20532: ST_TO_ADDR
20533: LD_VAR 0 2
20537: PUSH
20538: LD_INT 1
20540: MINUS
20541: PUSH
20542: FOR_TO
20543: IFFALSE 20588
// begin tmp := tmp [ pos [ i ] ] ;
20545: LD_ADDR_VAR 0 6
20549: PUSH
20550: LD_VAR 0 6
20554: PUSH
20555: LD_VAR 0 2
20559: PUSH
20560: LD_VAR 0 5
20564: ARRAY
20565: ARRAY
20566: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20567: LD_ADDR_VAR 0 7
20571: PUSH
20572: LD_VAR 0 7
20576: PUSH
20577: LD_VAR 0 6
20581: PUSH
20582: EMPTY
20583: LIST
20584: ADD
20585: ST_TO_ADDR
// end ;
20586: GO 20542
20588: POP
20589: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20590: LD_ADDR_VAR 0 6
20594: PUSH
20595: LD_VAR 0 6
20599: PPUSH
20600: LD_VAR 0 2
20604: PUSH
20605: LD_VAR 0 2
20609: ARRAY
20610: PPUSH
20611: LD_VAR 0 3
20615: PPUSH
20616: CALL_OW 1
20620: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20621: LD_ADDR_VAR 0 7
20625: PUSH
20626: LD_VAR 0 7
20630: PPUSH
20631: LD_VAR 0 7
20635: PPUSH
20636: LD_VAR 0 6
20640: PPUSH
20641: CALL_OW 1
20645: ST_TO_ADDR
// for i = s_arr downto 2 do
20646: LD_ADDR_VAR 0 5
20650: PUSH
20651: DOUBLE
20652: LD_VAR 0 7
20656: INC
20657: ST_TO_ADDR
20658: LD_INT 2
20660: PUSH
20661: FOR_DOWNTO
20662: IFFALSE 20746
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20664: LD_ADDR_VAR 0 6
20668: PUSH
20669: LD_VAR 0 7
20673: PUSH
20674: LD_VAR 0 5
20678: PUSH
20679: LD_INT 1
20681: MINUS
20682: ARRAY
20683: PPUSH
20684: LD_VAR 0 2
20688: PUSH
20689: LD_VAR 0 5
20693: PUSH
20694: LD_INT 1
20696: MINUS
20697: ARRAY
20698: PPUSH
20699: LD_VAR 0 7
20703: PUSH
20704: LD_VAR 0 5
20708: ARRAY
20709: PPUSH
20710: CALL_OW 1
20714: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20715: LD_ADDR_VAR 0 7
20719: PUSH
20720: LD_VAR 0 7
20724: PPUSH
20725: LD_VAR 0 5
20729: PUSH
20730: LD_INT 1
20732: MINUS
20733: PPUSH
20734: LD_VAR 0 6
20738: PPUSH
20739: CALL_OW 1
20743: ST_TO_ADDR
// end ;
20744: GO 20661
20746: POP
20747: POP
// result := s_arr [ 1 ] ;
20748: LD_ADDR_VAR 0 4
20752: PUSH
20753: LD_VAR 0 7
20757: PUSH
20758: LD_INT 1
20760: ARRAY
20761: ST_TO_ADDR
// end ; end ;
20762: LD_VAR 0 4
20766: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20767: LD_INT 0
20769: PPUSH
20770: PPUSH
// if not list then
20771: LD_VAR 0 1
20775: NOT
20776: IFFALSE 20780
// exit ;
20778: GO 20871
// i := list [ pos1 ] ;
20780: LD_ADDR_VAR 0 5
20784: PUSH
20785: LD_VAR 0 1
20789: PUSH
20790: LD_VAR 0 2
20794: ARRAY
20795: ST_TO_ADDR
// if not i then
20796: LD_VAR 0 5
20800: NOT
20801: IFFALSE 20805
// exit ;
20803: GO 20871
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20805: LD_ADDR_VAR 0 1
20809: PUSH
20810: LD_VAR 0 1
20814: PPUSH
20815: LD_VAR 0 2
20819: PPUSH
20820: LD_VAR 0 1
20824: PUSH
20825: LD_VAR 0 3
20829: ARRAY
20830: PPUSH
20831: CALL_OW 1
20835: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20836: LD_ADDR_VAR 0 1
20840: PUSH
20841: LD_VAR 0 1
20845: PPUSH
20846: LD_VAR 0 3
20850: PPUSH
20851: LD_VAR 0 5
20855: PPUSH
20856: CALL_OW 1
20860: ST_TO_ADDR
// result := list ;
20861: LD_ADDR_VAR 0 4
20865: PUSH
20866: LD_VAR 0 1
20870: ST_TO_ADDR
// end ;
20871: LD_VAR 0 4
20875: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20876: LD_INT 0
20878: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20879: LD_ADDR_VAR 0 5
20883: PUSH
20884: LD_VAR 0 1
20888: PPUSH
20889: CALL_OW 250
20893: PPUSH
20894: LD_VAR 0 1
20898: PPUSH
20899: CALL_OW 251
20903: PPUSH
20904: LD_VAR 0 2
20908: PPUSH
20909: LD_VAR 0 3
20913: PPUSH
20914: LD_VAR 0 4
20918: PPUSH
20919: CALL 20929 0 5
20923: ST_TO_ADDR
// end ;
20924: LD_VAR 0 5
20928: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20929: LD_INT 0
20931: PPUSH
20932: PPUSH
20933: PPUSH
20934: PPUSH
// if not list then
20935: LD_VAR 0 3
20939: NOT
20940: IFFALSE 20944
// exit ;
20942: GO 21332
// result := [ ] ;
20944: LD_ADDR_VAR 0 6
20948: PUSH
20949: EMPTY
20950: ST_TO_ADDR
// for i in list do
20951: LD_ADDR_VAR 0 7
20955: PUSH
20956: LD_VAR 0 3
20960: PUSH
20961: FOR_IN
20962: IFFALSE 21164
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20964: LD_ADDR_VAR 0 9
20968: PUSH
20969: LD_VAR 0 7
20973: PPUSH
20974: LD_VAR 0 1
20978: PPUSH
20979: LD_VAR 0 2
20983: PPUSH
20984: CALL_OW 297
20988: ST_TO_ADDR
// if not result then
20989: LD_VAR 0 6
20993: NOT
20994: IFFALSE 21020
// result := [ [ i , tmp ] ] else
20996: LD_ADDR_VAR 0 6
21000: PUSH
21001: LD_VAR 0 7
21005: PUSH
21006: LD_VAR 0 9
21010: PUSH
21011: EMPTY
21012: LIST
21013: LIST
21014: PUSH
21015: EMPTY
21016: LIST
21017: ST_TO_ADDR
21018: GO 21162
// begin if result [ result ] [ 2 ] < tmp then
21020: LD_VAR 0 6
21024: PUSH
21025: LD_VAR 0 6
21029: ARRAY
21030: PUSH
21031: LD_INT 2
21033: ARRAY
21034: PUSH
21035: LD_VAR 0 9
21039: LESS
21040: IFFALSE 21082
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21042: LD_ADDR_VAR 0 6
21046: PUSH
21047: LD_VAR 0 6
21051: PPUSH
21052: LD_VAR 0 6
21056: PUSH
21057: LD_INT 1
21059: PLUS
21060: PPUSH
21061: LD_VAR 0 7
21065: PUSH
21066: LD_VAR 0 9
21070: PUSH
21071: EMPTY
21072: LIST
21073: LIST
21074: PPUSH
21075: CALL_OW 2
21079: ST_TO_ADDR
21080: GO 21162
// for j = 1 to result do
21082: LD_ADDR_VAR 0 8
21086: PUSH
21087: DOUBLE
21088: LD_INT 1
21090: DEC
21091: ST_TO_ADDR
21092: LD_VAR 0 6
21096: PUSH
21097: FOR_TO
21098: IFFALSE 21160
// begin if tmp < result [ j ] [ 2 ] then
21100: LD_VAR 0 9
21104: PUSH
21105: LD_VAR 0 6
21109: PUSH
21110: LD_VAR 0 8
21114: ARRAY
21115: PUSH
21116: LD_INT 2
21118: ARRAY
21119: LESS
21120: IFFALSE 21158
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21122: LD_ADDR_VAR 0 6
21126: PUSH
21127: LD_VAR 0 6
21131: PPUSH
21132: LD_VAR 0 8
21136: PPUSH
21137: LD_VAR 0 7
21141: PUSH
21142: LD_VAR 0 9
21146: PUSH
21147: EMPTY
21148: LIST
21149: LIST
21150: PPUSH
21151: CALL_OW 2
21155: ST_TO_ADDR
// break ;
21156: GO 21160
// end ; end ;
21158: GO 21097
21160: POP
21161: POP
// end ; end ;
21162: GO 20961
21164: POP
21165: POP
// if result and not asc then
21166: LD_VAR 0 6
21170: PUSH
21171: LD_VAR 0 4
21175: NOT
21176: AND
21177: IFFALSE 21252
// begin tmp := result ;
21179: LD_ADDR_VAR 0 9
21183: PUSH
21184: LD_VAR 0 6
21188: ST_TO_ADDR
// for i = tmp downto 1 do
21189: LD_ADDR_VAR 0 7
21193: PUSH
21194: DOUBLE
21195: LD_VAR 0 9
21199: INC
21200: ST_TO_ADDR
21201: LD_INT 1
21203: PUSH
21204: FOR_DOWNTO
21205: IFFALSE 21250
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21207: LD_ADDR_VAR 0 6
21211: PUSH
21212: LD_VAR 0 6
21216: PPUSH
21217: LD_VAR 0 9
21221: PUSH
21222: LD_VAR 0 7
21226: MINUS
21227: PUSH
21228: LD_INT 1
21230: PLUS
21231: PPUSH
21232: LD_VAR 0 9
21236: PUSH
21237: LD_VAR 0 7
21241: ARRAY
21242: PPUSH
21243: CALL_OW 1
21247: ST_TO_ADDR
21248: GO 21204
21250: POP
21251: POP
// end ; tmp := [ ] ;
21252: LD_ADDR_VAR 0 9
21256: PUSH
21257: EMPTY
21258: ST_TO_ADDR
// if mode then
21259: LD_VAR 0 5
21263: IFFALSE 21332
// begin for i = 1 to result do
21265: LD_ADDR_VAR 0 7
21269: PUSH
21270: DOUBLE
21271: LD_INT 1
21273: DEC
21274: ST_TO_ADDR
21275: LD_VAR 0 6
21279: PUSH
21280: FOR_TO
21281: IFFALSE 21320
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21283: LD_ADDR_VAR 0 9
21287: PUSH
21288: LD_VAR 0 9
21292: PPUSH
21293: LD_VAR 0 7
21297: PPUSH
21298: LD_VAR 0 6
21302: PUSH
21303: LD_VAR 0 7
21307: ARRAY
21308: PUSH
21309: LD_INT 1
21311: ARRAY
21312: PPUSH
21313: CALL_OW 1
21317: ST_TO_ADDR
21318: GO 21280
21320: POP
21321: POP
// result := tmp ;
21322: LD_ADDR_VAR 0 6
21326: PUSH
21327: LD_VAR 0 9
21331: ST_TO_ADDR
// end ; end ;
21332: LD_VAR 0 6
21336: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21337: LD_INT 0
21339: PPUSH
21340: PPUSH
21341: PPUSH
21342: PPUSH
21343: PPUSH
21344: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21345: LD_ADDR_VAR 0 5
21349: PUSH
21350: LD_INT 0
21352: PUSH
21353: LD_INT 0
21355: PUSH
21356: LD_INT 0
21358: PUSH
21359: EMPTY
21360: PUSH
21361: EMPTY
21362: LIST
21363: LIST
21364: LIST
21365: LIST
21366: ST_TO_ADDR
// if not x or not y then
21367: LD_VAR 0 2
21371: NOT
21372: PUSH
21373: LD_VAR 0 3
21377: NOT
21378: OR
21379: IFFALSE 21383
// exit ;
21381: GO 23033
// if not range then
21383: LD_VAR 0 4
21387: NOT
21388: IFFALSE 21398
// range := 10 ;
21390: LD_ADDR_VAR 0 4
21394: PUSH
21395: LD_INT 10
21397: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21398: LD_ADDR_VAR 0 8
21402: PUSH
21403: LD_INT 81
21405: PUSH
21406: LD_VAR 0 1
21410: PUSH
21411: EMPTY
21412: LIST
21413: LIST
21414: PUSH
21415: LD_INT 92
21417: PUSH
21418: LD_VAR 0 2
21422: PUSH
21423: LD_VAR 0 3
21427: PUSH
21428: LD_VAR 0 4
21432: PUSH
21433: EMPTY
21434: LIST
21435: LIST
21436: LIST
21437: LIST
21438: PUSH
21439: LD_INT 3
21441: PUSH
21442: LD_INT 21
21444: PUSH
21445: LD_INT 3
21447: PUSH
21448: EMPTY
21449: LIST
21450: LIST
21451: PUSH
21452: EMPTY
21453: LIST
21454: LIST
21455: PUSH
21456: EMPTY
21457: LIST
21458: LIST
21459: LIST
21460: PPUSH
21461: CALL_OW 69
21465: ST_TO_ADDR
// if not tmp then
21466: LD_VAR 0 8
21470: NOT
21471: IFFALSE 21475
// exit ;
21473: GO 23033
// for i in tmp do
21475: LD_ADDR_VAR 0 6
21479: PUSH
21480: LD_VAR 0 8
21484: PUSH
21485: FOR_IN
21486: IFFALSE 23008
// begin points := [ 0 , 0 , 0 ] ;
21488: LD_ADDR_VAR 0 9
21492: PUSH
21493: LD_INT 0
21495: PUSH
21496: LD_INT 0
21498: PUSH
21499: LD_INT 0
21501: PUSH
21502: EMPTY
21503: LIST
21504: LIST
21505: LIST
21506: ST_TO_ADDR
// bpoints := 1 ;
21507: LD_ADDR_VAR 0 10
21511: PUSH
21512: LD_INT 1
21514: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21515: LD_VAR 0 6
21519: PPUSH
21520: CALL_OW 247
21524: PUSH
21525: LD_INT 1
21527: DOUBLE
21528: EQUAL
21529: IFTRUE 21533
21531: GO 22111
21533: POP
// begin if GetClass ( i ) = 1 then
21534: LD_VAR 0 6
21538: PPUSH
21539: CALL_OW 257
21543: PUSH
21544: LD_INT 1
21546: EQUAL
21547: IFFALSE 21568
// points := [ 10 , 5 , 3 ] ;
21549: LD_ADDR_VAR 0 9
21553: PUSH
21554: LD_INT 10
21556: PUSH
21557: LD_INT 5
21559: PUSH
21560: LD_INT 3
21562: PUSH
21563: EMPTY
21564: LIST
21565: LIST
21566: LIST
21567: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21568: LD_VAR 0 6
21572: PPUSH
21573: CALL_OW 257
21577: PUSH
21578: LD_INT 2
21580: PUSH
21581: LD_INT 3
21583: PUSH
21584: LD_INT 4
21586: PUSH
21587: EMPTY
21588: LIST
21589: LIST
21590: LIST
21591: IN
21592: IFFALSE 21613
// points := [ 3 , 2 , 1 ] ;
21594: LD_ADDR_VAR 0 9
21598: PUSH
21599: LD_INT 3
21601: PUSH
21602: LD_INT 2
21604: PUSH
21605: LD_INT 1
21607: PUSH
21608: EMPTY
21609: LIST
21610: LIST
21611: LIST
21612: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21613: LD_VAR 0 6
21617: PPUSH
21618: CALL_OW 257
21622: PUSH
21623: LD_INT 5
21625: EQUAL
21626: IFFALSE 21647
// points := [ 130 , 5 , 2 ] ;
21628: LD_ADDR_VAR 0 9
21632: PUSH
21633: LD_INT 130
21635: PUSH
21636: LD_INT 5
21638: PUSH
21639: LD_INT 2
21641: PUSH
21642: EMPTY
21643: LIST
21644: LIST
21645: LIST
21646: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21647: LD_VAR 0 6
21651: PPUSH
21652: CALL_OW 257
21656: PUSH
21657: LD_INT 8
21659: EQUAL
21660: IFFALSE 21681
// points := [ 35 , 35 , 30 ] ;
21662: LD_ADDR_VAR 0 9
21666: PUSH
21667: LD_INT 35
21669: PUSH
21670: LD_INT 35
21672: PUSH
21673: LD_INT 30
21675: PUSH
21676: EMPTY
21677: LIST
21678: LIST
21679: LIST
21680: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21681: LD_VAR 0 6
21685: PPUSH
21686: CALL_OW 257
21690: PUSH
21691: LD_INT 9
21693: EQUAL
21694: IFFALSE 21715
// points := [ 20 , 55 , 40 ] ;
21696: LD_ADDR_VAR 0 9
21700: PUSH
21701: LD_INT 20
21703: PUSH
21704: LD_INT 55
21706: PUSH
21707: LD_INT 40
21709: PUSH
21710: EMPTY
21711: LIST
21712: LIST
21713: LIST
21714: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21715: LD_VAR 0 6
21719: PPUSH
21720: CALL_OW 257
21724: PUSH
21725: LD_INT 12
21727: PUSH
21728: LD_INT 16
21730: PUSH
21731: EMPTY
21732: LIST
21733: LIST
21734: IN
21735: IFFALSE 21756
// points := [ 5 , 3 , 2 ] ;
21737: LD_ADDR_VAR 0 9
21741: PUSH
21742: LD_INT 5
21744: PUSH
21745: LD_INT 3
21747: PUSH
21748: LD_INT 2
21750: PUSH
21751: EMPTY
21752: LIST
21753: LIST
21754: LIST
21755: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21756: LD_VAR 0 6
21760: PPUSH
21761: CALL_OW 257
21765: PUSH
21766: LD_INT 17
21768: EQUAL
21769: IFFALSE 21790
// points := [ 100 , 50 , 75 ] ;
21771: LD_ADDR_VAR 0 9
21775: PUSH
21776: LD_INT 100
21778: PUSH
21779: LD_INT 50
21781: PUSH
21782: LD_INT 75
21784: PUSH
21785: EMPTY
21786: LIST
21787: LIST
21788: LIST
21789: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21790: LD_VAR 0 6
21794: PPUSH
21795: CALL_OW 257
21799: PUSH
21800: LD_INT 15
21802: EQUAL
21803: IFFALSE 21824
// points := [ 10 , 5 , 3 ] ;
21805: LD_ADDR_VAR 0 9
21809: PUSH
21810: LD_INT 10
21812: PUSH
21813: LD_INT 5
21815: PUSH
21816: LD_INT 3
21818: PUSH
21819: EMPTY
21820: LIST
21821: LIST
21822: LIST
21823: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21824: LD_VAR 0 6
21828: PPUSH
21829: CALL_OW 257
21833: PUSH
21834: LD_INT 14
21836: EQUAL
21837: IFFALSE 21858
// points := [ 10 , 0 , 0 ] ;
21839: LD_ADDR_VAR 0 9
21843: PUSH
21844: LD_INT 10
21846: PUSH
21847: LD_INT 0
21849: PUSH
21850: LD_INT 0
21852: PUSH
21853: EMPTY
21854: LIST
21855: LIST
21856: LIST
21857: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21858: LD_VAR 0 6
21862: PPUSH
21863: CALL_OW 257
21867: PUSH
21868: LD_INT 11
21870: EQUAL
21871: IFFALSE 21892
// points := [ 30 , 10 , 5 ] ;
21873: LD_ADDR_VAR 0 9
21877: PUSH
21878: LD_INT 30
21880: PUSH
21881: LD_INT 10
21883: PUSH
21884: LD_INT 5
21886: PUSH
21887: EMPTY
21888: LIST
21889: LIST
21890: LIST
21891: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21892: LD_VAR 0 1
21896: PPUSH
21897: LD_INT 5
21899: PPUSH
21900: CALL_OW 321
21904: PUSH
21905: LD_INT 2
21907: EQUAL
21908: IFFALSE 21925
// bpoints := bpoints * 1.8 ;
21910: LD_ADDR_VAR 0 10
21914: PUSH
21915: LD_VAR 0 10
21919: PUSH
21920: LD_REAL  1.80000000000000E+0000
21923: MUL
21924: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21925: LD_VAR 0 6
21929: PPUSH
21930: CALL_OW 257
21934: PUSH
21935: LD_INT 1
21937: PUSH
21938: LD_INT 2
21940: PUSH
21941: LD_INT 3
21943: PUSH
21944: LD_INT 4
21946: PUSH
21947: EMPTY
21948: LIST
21949: LIST
21950: LIST
21951: LIST
21952: IN
21953: PUSH
21954: LD_VAR 0 1
21958: PPUSH
21959: LD_INT 51
21961: PPUSH
21962: CALL_OW 321
21966: PUSH
21967: LD_INT 2
21969: EQUAL
21970: AND
21971: IFFALSE 21988
// bpoints := bpoints * 1.2 ;
21973: LD_ADDR_VAR 0 10
21977: PUSH
21978: LD_VAR 0 10
21982: PUSH
21983: LD_REAL  1.20000000000000E+0000
21986: MUL
21987: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21988: LD_VAR 0 6
21992: PPUSH
21993: CALL_OW 257
21997: PUSH
21998: LD_INT 5
22000: PUSH
22001: LD_INT 7
22003: PUSH
22004: LD_INT 9
22006: PUSH
22007: EMPTY
22008: LIST
22009: LIST
22010: LIST
22011: IN
22012: PUSH
22013: LD_VAR 0 1
22017: PPUSH
22018: LD_INT 52
22020: PPUSH
22021: CALL_OW 321
22025: PUSH
22026: LD_INT 2
22028: EQUAL
22029: AND
22030: IFFALSE 22047
// bpoints := bpoints * 1.5 ;
22032: LD_ADDR_VAR 0 10
22036: PUSH
22037: LD_VAR 0 10
22041: PUSH
22042: LD_REAL  1.50000000000000E+0000
22045: MUL
22046: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22047: LD_VAR 0 1
22051: PPUSH
22052: LD_INT 66
22054: PPUSH
22055: CALL_OW 321
22059: PUSH
22060: LD_INT 2
22062: EQUAL
22063: IFFALSE 22080
// bpoints := bpoints * 1.1 ;
22065: LD_ADDR_VAR 0 10
22069: PUSH
22070: LD_VAR 0 10
22074: PUSH
22075: LD_REAL  1.10000000000000E+0000
22078: MUL
22079: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
22080: LD_ADDR_VAR 0 10
22084: PUSH
22085: LD_VAR 0 10
22089: PUSH
22090: LD_VAR 0 6
22094: PPUSH
22095: LD_INT 1
22097: PPUSH
22098: CALL_OW 259
22102: PUSH
22103: LD_REAL  1.15000000000000E+0000
22106: MUL
22107: MUL
22108: ST_TO_ADDR
// end ; unit_vehicle :
22109: GO 22937
22111: LD_INT 2
22113: DOUBLE
22114: EQUAL
22115: IFTRUE 22119
22117: GO 22925
22119: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
22120: LD_VAR 0 6
22124: PPUSH
22125: CALL_OW 264
22129: PUSH
22130: LD_INT 2
22132: PUSH
22133: LD_INT 42
22135: PUSH
22136: LD_INT 24
22138: PUSH
22139: EMPTY
22140: LIST
22141: LIST
22142: LIST
22143: IN
22144: IFFALSE 22165
// points := [ 25 , 5 , 3 ] ;
22146: LD_ADDR_VAR 0 9
22150: PUSH
22151: LD_INT 25
22153: PUSH
22154: LD_INT 5
22156: PUSH
22157: LD_INT 3
22159: PUSH
22160: EMPTY
22161: LIST
22162: LIST
22163: LIST
22164: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
22165: LD_VAR 0 6
22169: PPUSH
22170: CALL_OW 264
22174: PUSH
22175: LD_INT 4
22177: PUSH
22178: LD_INT 43
22180: PUSH
22181: LD_INT 25
22183: PUSH
22184: EMPTY
22185: LIST
22186: LIST
22187: LIST
22188: IN
22189: IFFALSE 22210
// points := [ 40 , 15 , 5 ] ;
22191: LD_ADDR_VAR 0 9
22195: PUSH
22196: LD_INT 40
22198: PUSH
22199: LD_INT 15
22201: PUSH
22202: LD_INT 5
22204: PUSH
22205: EMPTY
22206: LIST
22207: LIST
22208: LIST
22209: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22210: LD_VAR 0 6
22214: PPUSH
22215: CALL_OW 264
22219: PUSH
22220: LD_INT 3
22222: PUSH
22223: LD_INT 23
22225: PUSH
22226: EMPTY
22227: LIST
22228: LIST
22229: IN
22230: IFFALSE 22251
// points := [ 7 , 25 , 8 ] ;
22232: LD_ADDR_VAR 0 9
22236: PUSH
22237: LD_INT 7
22239: PUSH
22240: LD_INT 25
22242: PUSH
22243: LD_INT 8
22245: PUSH
22246: EMPTY
22247: LIST
22248: LIST
22249: LIST
22250: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22251: LD_VAR 0 6
22255: PPUSH
22256: CALL_OW 264
22260: PUSH
22261: LD_INT 5
22263: PUSH
22264: LD_INT 27
22266: PUSH
22267: LD_INT 44
22269: PUSH
22270: EMPTY
22271: LIST
22272: LIST
22273: LIST
22274: IN
22275: IFFALSE 22296
// points := [ 14 , 50 , 16 ] ;
22277: LD_ADDR_VAR 0 9
22281: PUSH
22282: LD_INT 14
22284: PUSH
22285: LD_INT 50
22287: PUSH
22288: LD_INT 16
22290: PUSH
22291: EMPTY
22292: LIST
22293: LIST
22294: LIST
22295: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22296: LD_VAR 0 6
22300: PPUSH
22301: CALL_OW 264
22305: PUSH
22306: LD_INT 6
22308: PUSH
22309: LD_INT 46
22311: PUSH
22312: EMPTY
22313: LIST
22314: LIST
22315: IN
22316: IFFALSE 22337
// points := [ 32 , 120 , 70 ] ;
22318: LD_ADDR_VAR 0 9
22322: PUSH
22323: LD_INT 32
22325: PUSH
22326: LD_INT 120
22328: PUSH
22329: LD_INT 70
22331: PUSH
22332: EMPTY
22333: LIST
22334: LIST
22335: LIST
22336: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
22337: LD_VAR 0 6
22341: PPUSH
22342: CALL_OW 264
22346: PUSH
22347: LD_INT 7
22349: PUSH
22350: LD_INT 28
22352: PUSH
22353: LD_INT 45
22355: PUSH
22356: LD_INT 92
22358: PUSH
22359: EMPTY
22360: LIST
22361: LIST
22362: LIST
22363: LIST
22364: IN
22365: IFFALSE 22386
// points := [ 35 , 20 , 45 ] ;
22367: LD_ADDR_VAR 0 9
22371: PUSH
22372: LD_INT 35
22374: PUSH
22375: LD_INT 20
22377: PUSH
22378: LD_INT 45
22380: PUSH
22381: EMPTY
22382: LIST
22383: LIST
22384: LIST
22385: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22386: LD_VAR 0 6
22390: PPUSH
22391: CALL_OW 264
22395: PUSH
22396: LD_INT 47
22398: PUSH
22399: EMPTY
22400: LIST
22401: IN
22402: IFFALSE 22423
// points := [ 67 , 45 , 75 ] ;
22404: LD_ADDR_VAR 0 9
22408: PUSH
22409: LD_INT 67
22411: PUSH
22412: LD_INT 45
22414: PUSH
22415: LD_INT 75
22417: PUSH
22418: EMPTY
22419: LIST
22420: LIST
22421: LIST
22422: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22423: LD_VAR 0 6
22427: PPUSH
22428: CALL_OW 264
22432: PUSH
22433: LD_INT 26
22435: PUSH
22436: EMPTY
22437: LIST
22438: IN
22439: IFFALSE 22460
// points := [ 120 , 30 , 80 ] ;
22441: LD_ADDR_VAR 0 9
22445: PUSH
22446: LD_INT 120
22448: PUSH
22449: LD_INT 30
22451: PUSH
22452: LD_INT 80
22454: PUSH
22455: EMPTY
22456: LIST
22457: LIST
22458: LIST
22459: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22460: LD_VAR 0 6
22464: PPUSH
22465: CALL_OW 264
22469: PUSH
22470: LD_INT 22
22472: PUSH
22473: EMPTY
22474: LIST
22475: IN
22476: IFFALSE 22497
// points := [ 40 , 1 , 1 ] ;
22478: LD_ADDR_VAR 0 9
22482: PUSH
22483: LD_INT 40
22485: PUSH
22486: LD_INT 1
22488: PUSH
22489: LD_INT 1
22491: PUSH
22492: EMPTY
22493: LIST
22494: LIST
22495: LIST
22496: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22497: LD_VAR 0 6
22501: PPUSH
22502: CALL_OW 264
22506: PUSH
22507: LD_INT 29
22509: PUSH
22510: EMPTY
22511: LIST
22512: IN
22513: IFFALSE 22534
// points := [ 70 , 200 , 400 ] ;
22515: LD_ADDR_VAR 0 9
22519: PUSH
22520: LD_INT 70
22522: PUSH
22523: LD_INT 200
22525: PUSH
22526: LD_INT 400
22528: PUSH
22529: EMPTY
22530: LIST
22531: LIST
22532: LIST
22533: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22534: LD_VAR 0 6
22538: PPUSH
22539: CALL_OW 264
22543: PUSH
22544: LD_INT 14
22546: PUSH
22547: LD_INT 53
22549: PUSH
22550: EMPTY
22551: LIST
22552: LIST
22553: IN
22554: IFFALSE 22575
// points := [ 40 , 10 , 20 ] ;
22556: LD_ADDR_VAR 0 9
22560: PUSH
22561: LD_INT 40
22563: PUSH
22564: LD_INT 10
22566: PUSH
22567: LD_INT 20
22569: PUSH
22570: EMPTY
22571: LIST
22572: LIST
22573: LIST
22574: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22575: LD_VAR 0 6
22579: PPUSH
22580: CALL_OW 264
22584: PUSH
22585: LD_INT 9
22587: PUSH
22588: EMPTY
22589: LIST
22590: IN
22591: IFFALSE 22612
// points := [ 5 , 70 , 20 ] ;
22593: LD_ADDR_VAR 0 9
22597: PUSH
22598: LD_INT 5
22600: PUSH
22601: LD_INT 70
22603: PUSH
22604: LD_INT 20
22606: PUSH
22607: EMPTY
22608: LIST
22609: LIST
22610: LIST
22611: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22612: LD_VAR 0 6
22616: PPUSH
22617: CALL_OW 264
22621: PUSH
22622: LD_INT 10
22624: PUSH
22625: EMPTY
22626: LIST
22627: IN
22628: IFFALSE 22649
// points := [ 35 , 110 , 70 ] ;
22630: LD_ADDR_VAR 0 9
22634: PUSH
22635: LD_INT 35
22637: PUSH
22638: LD_INT 110
22640: PUSH
22641: LD_INT 70
22643: PUSH
22644: EMPTY
22645: LIST
22646: LIST
22647: LIST
22648: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22649: LD_VAR 0 6
22653: PPUSH
22654: CALL_OW 265
22658: PUSH
22659: LD_INT 25
22661: EQUAL
22662: IFFALSE 22683
// points := [ 80 , 65 , 100 ] ;
22664: LD_ADDR_VAR 0 9
22668: PUSH
22669: LD_INT 80
22671: PUSH
22672: LD_INT 65
22674: PUSH
22675: LD_INT 100
22677: PUSH
22678: EMPTY
22679: LIST
22680: LIST
22681: LIST
22682: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22683: LD_VAR 0 6
22687: PPUSH
22688: CALL_OW 263
22692: PUSH
22693: LD_INT 1
22695: EQUAL
22696: IFFALSE 22731
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22698: LD_ADDR_VAR 0 10
22702: PUSH
22703: LD_VAR 0 10
22707: PUSH
22708: LD_VAR 0 6
22712: PPUSH
22713: CALL_OW 311
22717: PPUSH
22718: LD_INT 3
22720: PPUSH
22721: CALL_OW 259
22725: PUSH
22726: LD_INT 4
22728: MUL
22729: MUL
22730: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22731: LD_VAR 0 6
22735: PPUSH
22736: CALL_OW 263
22740: PUSH
22741: LD_INT 2
22743: EQUAL
22744: IFFALSE 22795
// begin j := IsControledBy ( i ) ;
22746: LD_ADDR_VAR 0 7
22750: PUSH
22751: LD_VAR 0 6
22755: PPUSH
22756: CALL_OW 312
22760: ST_TO_ADDR
// if j then
22761: LD_VAR 0 7
22765: IFFALSE 22795
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22767: LD_ADDR_VAR 0 10
22771: PUSH
22772: LD_VAR 0 10
22776: PUSH
22777: LD_VAR 0 7
22781: PPUSH
22782: LD_INT 3
22784: PPUSH
22785: CALL_OW 259
22789: PUSH
22790: LD_INT 3
22792: MUL
22793: MUL
22794: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22795: LD_VAR 0 6
22799: PPUSH
22800: CALL_OW 264
22804: PUSH
22805: LD_INT 5
22807: PUSH
22808: LD_INT 6
22810: PUSH
22811: LD_INT 46
22813: PUSH
22814: LD_INT 44
22816: PUSH
22817: LD_INT 47
22819: PUSH
22820: LD_INT 45
22822: PUSH
22823: LD_INT 28
22825: PUSH
22826: LD_INT 7
22828: PUSH
22829: LD_INT 27
22831: PUSH
22832: LD_INT 29
22834: PUSH
22835: EMPTY
22836: LIST
22837: LIST
22838: LIST
22839: LIST
22840: LIST
22841: LIST
22842: LIST
22843: LIST
22844: LIST
22845: LIST
22846: IN
22847: PUSH
22848: LD_VAR 0 1
22852: PPUSH
22853: LD_INT 52
22855: PPUSH
22856: CALL_OW 321
22860: PUSH
22861: LD_INT 2
22863: EQUAL
22864: AND
22865: IFFALSE 22882
// bpoints := bpoints * 1.2 ;
22867: LD_ADDR_VAR 0 10
22871: PUSH
22872: LD_VAR 0 10
22876: PUSH
22877: LD_REAL  1.20000000000000E+0000
22880: MUL
22881: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22882: LD_VAR 0 6
22886: PPUSH
22887: CALL_OW 264
22891: PUSH
22892: LD_INT 6
22894: PUSH
22895: LD_INT 46
22897: PUSH
22898: LD_INT 47
22900: PUSH
22901: EMPTY
22902: LIST
22903: LIST
22904: LIST
22905: IN
22906: IFFALSE 22923
// bpoints := bpoints * 1.2 ;
22908: LD_ADDR_VAR 0 10
22912: PUSH
22913: LD_VAR 0 10
22917: PUSH
22918: LD_REAL  1.20000000000000E+0000
22921: MUL
22922: ST_TO_ADDR
// end ; unit_building :
22923: GO 22937
22925: LD_INT 3
22927: DOUBLE
22928: EQUAL
22929: IFTRUE 22933
22931: GO 22936
22933: POP
// ; end ;
22934: GO 22937
22936: POP
// for j = 1 to 3 do
22937: LD_ADDR_VAR 0 7
22941: PUSH
22942: DOUBLE
22943: LD_INT 1
22945: DEC
22946: ST_TO_ADDR
22947: LD_INT 3
22949: PUSH
22950: FOR_TO
22951: IFFALSE 23004
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22953: LD_ADDR_VAR 0 5
22957: PUSH
22958: LD_VAR 0 5
22962: PPUSH
22963: LD_VAR 0 7
22967: PPUSH
22968: LD_VAR 0 5
22972: PUSH
22973: LD_VAR 0 7
22977: ARRAY
22978: PUSH
22979: LD_VAR 0 9
22983: PUSH
22984: LD_VAR 0 7
22988: ARRAY
22989: PUSH
22990: LD_VAR 0 10
22994: MUL
22995: PLUS
22996: PPUSH
22997: CALL_OW 1
23001: ST_TO_ADDR
23002: GO 22950
23004: POP
23005: POP
// end ;
23006: GO 21485
23008: POP
23009: POP
// result := Replace ( result , 4 , tmp ) ;
23010: LD_ADDR_VAR 0 5
23014: PUSH
23015: LD_VAR 0 5
23019: PPUSH
23020: LD_INT 4
23022: PPUSH
23023: LD_VAR 0 8
23027: PPUSH
23028: CALL_OW 1
23032: ST_TO_ADDR
// end ;
23033: LD_VAR 0 5
23037: RET
// export function DangerAtRange ( unit , range ) ; begin
23038: LD_INT 0
23040: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23041: LD_ADDR_VAR 0 3
23045: PUSH
23046: LD_VAR 0 1
23050: PPUSH
23051: CALL_OW 255
23055: PPUSH
23056: LD_VAR 0 1
23060: PPUSH
23061: CALL_OW 250
23065: PPUSH
23066: LD_VAR 0 1
23070: PPUSH
23071: CALL_OW 251
23075: PPUSH
23076: LD_VAR 0 2
23080: PPUSH
23081: CALL 21337 0 4
23085: ST_TO_ADDR
// end ;
23086: LD_VAR 0 3
23090: RET
// export function DangerInArea ( side , area ) ; begin
23091: LD_INT 0
23093: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
23094: LD_ADDR_VAR 0 3
23098: PUSH
23099: LD_VAR 0 2
23103: PPUSH
23104: LD_INT 81
23106: PUSH
23107: LD_VAR 0 1
23111: PUSH
23112: EMPTY
23113: LIST
23114: LIST
23115: PPUSH
23116: CALL_OW 70
23120: ST_TO_ADDR
// end ;
23121: LD_VAR 0 3
23125: RET
// export function IsExtension ( b ) ; begin
23126: LD_INT 0
23128: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
23129: LD_ADDR_VAR 0 2
23133: PUSH
23134: LD_VAR 0 1
23138: PUSH
23139: LD_INT 23
23141: PUSH
23142: LD_INT 20
23144: PUSH
23145: LD_INT 22
23147: PUSH
23148: LD_INT 17
23150: PUSH
23151: LD_INT 24
23153: PUSH
23154: LD_INT 21
23156: PUSH
23157: LD_INT 19
23159: PUSH
23160: LD_INT 16
23162: PUSH
23163: LD_INT 25
23165: PUSH
23166: LD_INT 18
23168: PUSH
23169: EMPTY
23170: LIST
23171: LIST
23172: LIST
23173: LIST
23174: LIST
23175: LIST
23176: LIST
23177: LIST
23178: LIST
23179: LIST
23180: IN
23181: ST_TO_ADDR
// end ;
23182: LD_VAR 0 2
23186: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
23187: LD_INT 0
23189: PPUSH
23190: PPUSH
23191: PPUSH
// result := [ ] ;
23192: LD_ADDR_VAR 0 4
23196: PUSH
23197: EMPTY
23198: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23199: LD_ADDR_VAR 0 5
23203: PUSH
23204: LD_VAR 0 2
23208: PPUSH
23209: LD_INT 21
23211: PUSH
23212: LD_INT 3
23214: PUSH
23215: EMPTY
23216: LIST
23217: LIST
23218: PPUSH
23219: CALL_OW 70
23223: ST_TO_ADDR
// if not tmp then
23224: LD_VAR 0 5
23228: NOT
23229: IFFALSE 23233
// exit ;
23231: GO 23297
// if checkLink then
23233: LD_VAR 0 3
23237: IFFALSE 23287
// begin for i in tmp do
23239: LD_ADDR_VAR 0 6
23243: PUSH
23244: LD_VAR 0 5
23248: PUSH
23249: FOR_IN
23250: IFFALSE 23285
// if GetBase ( i ) <> base then
23252: LD_VAR 0 6
23256: PPUSH
23257: CALL_OW 274
23261: PUSH
23262: LD_VAR 0 1
23266: NONEQUAL
23267: IFFALSE 23283
// ComLinkToBase ( base , i ) ;
23269: LD_VAR 0 1
23273: PPUSH
23274: LD_VAR 0 6
23278: PPUSH
23279: CALL_OW 169
23283: GO 23249
23285: POP
23286: POP
// end ; result := tmp ;
23287: LD_ADDR_VAR 0 4
23291: PUSH
23292: LD_VAR 0 5
23296: ST_TO_ADDR
// end ;
23297: LD_VAR 0 4
23301: RET
// export function ComComplete ( units , b ) ; var i ; begin
23302: LD_INT 0
23304: PPUSH
23305: PPUSH
// if not units then
23306: LD_VAR 0 1
23310: NOT
23311: IFFALSE 23315
// exit ;
23313: GO 23405
// for i in units do
23315: LD_ADDR_VAR 0 4
23319: PUSH
23320: LD_VAR 0 1
23324: PUSH
23325: FOR_IN
23326: IFFALSE 23403
// if BuildingStatus ( b ) = bs_build then
23328: LD_VAR 0 2
23332: PPUSH
23333: CALL_OW 461
23337: PUSH
23338: LD_INT 1
23340: EQUAL
23341: IFFALSE 23401
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23343: LD_VAR 0 4
23347: PPUSH
23348: LD_STRING h
23350: PUSH
23351: LD_VAR 0 2
23355: PPUSH
23356: CALL_OW 250
23360: PUSH
23361: LD_VAR 0 2
23365: PPUSH
23366: CALL_OW 251
23370: PUSH
23371: LD_VAR 0 2
23375: PUSH
23376: LD_INT 0
23378: PUSH
23379: LD_INT 0
23381: PUSH
23382: LD_INT 0
23384: PUSH
23385: EMPTY
23386: LIST
23387: LIST
23388: LIST
23389: LIST
23390: LIST
23391: LIST
23392: LIST
23393: PUSH
23394: EMPTY
23395: LIST
23396: PPUSH
23397: CALL_OW 446
23401: GO 23325
23403: POP
23404: POP
// end ;
23405: LD_VAR 0 3
23409: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23410: LD_INT 0
23412: PPUSH
23413: PPUSH
23414: PPUSH
23415: PPUSH
23416: PPUSH
23417: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
23418: LD_VAR 0 1
23422: NOT
23423: PUSH
23424: LD_VAR 0 1
23428: PPUSH
23429: CALL_OW 263
23433: PUSH
23434: LD_INT 2
23436: NONEQUAL
23437: OR
23438: IFFALSE 23442
// exit ;
23440: GO 23758
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23442: LD_ADDR_VAR 0 6
23446: PUSH
23447: LD_INT 22
23449: PUSH
23450: LD_VAR 0 1
23454: PPUSH
23455: CALL_OW 255
23459: PUSH
23460: EMPTY
23461: LIST
23462: LIST
23463: PUSH
23464: LD_INT 2
23466: PUSH
23467: LD_INT 30
23469: PUSH
23470: LD_INT 36
23472: PUSH
23473: EMPTY
23474: LIST
23475: LIST
23476: PUSH
23477: LD_INT 34
23479: PUSH
23480: LD_INT 31
23482: PUSH
23483: EMPTY
23484: LIST
23485: LIST
23486: PUSH
23487: EMPTY
23488: LIST
23489: LIST
23490: LIST
23491: PUSH
23492: EMPTY
23493: LIST
23494: LIST
23495: PPUSH
23496: CALL_OW 69
23500: ST_TO_ADDR
// if not tmp then
23501: LD_VAR 0 6
23505: NOT
23506: IFFALSE 23510
// exit ;
23508: GO 23758
// result := [ ] ;
23510: LD_ADDR_VAR 0 2
23514: PUSH
23515: EMPTY
23516: ST_TO_ADDR
// for i in tmp do
23517: LD_ADDR_VAR 0 3
23521: PUSH
23522: LD_VAR 0 6
23526: PUSH
23527: FOR_IN
23528: IFFALSE 23599
// begin t := UnitsInside ( i ) ;
23530: LD_ADDR_VAR 0 4
23534: PUSH
23535: LD_VAR 0 3
23539: PPUSH
23540: CALL_OW 313
23544: ST_TO_ADDR
// if t then
23545: LD_VAR 0 4
23549: IFFALSE 23597
// for j in t do
23551: LD_ADDR_VAR 0 7
23555: PUSH
23556: LD_VAR 0 4
23560: PUSH
23561: FOR_IN
23562: IFFALSE 23595
// result := Replace ( result , result + 1 , j ) ;
23564: LD_ADDR_VAR 0 2
23568: PUSH
23569: LD_VAR 0 2
23573: PPUSH
23574: LD_VAR 0 2
23578: PUSH
23579: LD_INT 1
23581: PLUS
23582: PPUSH
23583: LD_VAR 0 7
23587: PPUSH
23588: CALL_OW 1
23592: ST_TO_ADDR
23593: GO 23561
23595: POP
23596: POP
// end ;
23597: GO 23527
23599: POP
23600: POP
// if not result then
23601: LD_VAR 0 2
23605: NOT
23606: IFFALSE 23610
// exit ;
23608: GO 23758
// mech := result [ 1 ] ;
23610: LD_ADDR_VAR 0 5
23614: PUSH
23615: LD_VAR 0 2
23619: PUSH
23620: LD_INT 1
23622: ARRAY
23623: ST_TO_ADDR
// if result > 1 then
23624: LD_VAR 0 2
23628: PUSH
23629: LD_INT 1
23631: GREATER
23632: IFFALSE 23744
// begin for i = 2 to result do
23634: LD_ADDR_VAR 0 3
23638: PUSH
23639: DOUBLE
23640: LD_INT 2
23642: DEC
23643: ST_TO_ADDR
23644: LD_VAR 0 2
23648: PUSH
23649: FOR_TO
23650: IFFALSE 23742
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23652: LD_ADDR_VAR 0 4
23656: PUSH
23657: LD_VAR 0 2
23661: PUSH
23662: LD_VAR 0 3
23666: ARRAY
23667: PPUSH
23668: LD_INT 3
23670: PPUSH
23671: CALL_OW 259
23675: PUSH
23676: LD_VAR 0 2
23680: PUSH
23681: LD_VAR 0 3
23685: ARRAY
23686: PPUSH
23687: CALL_OW 432
23691: MINUS
23692: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23693: LD_VAR 0 4
23697: PUSH
23698: LD_VAR 0 5
23702: PPUSH
23703: LD_INT 3
23705: PPUSH
23706: CALL_OW 259
23710: PUSH
23711: LD_VAR 0 5
23715: PPUSH
23716: CALL_OW 432
23720: MINUS
23721: GREATEREQUAL
23722: IFFALSE 23740
// mech := result [ i ] ;
23724: LD_ADDR_VAR 0 5
23728: PUSH
23729: LD_VAR 0 2
23733: PUSH
23734: LD_VAR 0 3
23738: ARRAY
23739: ST_TO_ADDR
// end ;
23740: GO 23649
23742: POP
23743: POP
// end ; ComLinkTo ( vehicle , mech ) ;
23744: LD_VAR 0 1
23748: PPUSH
23749: LD_VAR 0 5
23753: PPUSH
23754: CALL_OW 135
// end ;
23758: LD_VAR 0 2
23762: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23763: LD_INT 0
23765: PPUSH
23766: PPUSH
23767: PPUSH
23768: PPUSH
23769: PPUSH
23770: PPUSH
23771: PPUSH
23772: PPUSH
23773: PPUSH
23774: PPUSH
23775: PPUSH
23776: PPUSH
23777: PPUSH
// result := [ ] ;
23778: LD_ADDR_VAR 0 7
23782: PUSH
23783: EMPTY
23784: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23785: LD_VAR 0 1
23789: PPUSH
23790: CALL_OW 266
23794: PUSH
23795: LD_INT 0
23797: PUSH
23798: LD_INT 1
23800: PUSH
23801: EMPTY
23802: LIST
23803: LIST
23804: IN
23805: NOT
23806: IFFALSE 23810
// exit ;
23808: GO 25444
// if name then
23810: LD_VAR 0 3
23814: IFFALSE 23830
// SetBName ( base_dep , name ) ;
23816: LD_VAR 0 1
23820: PPUSH
23821: LD_VAR 0 3
23825: PPUSH
23826: CALL_OW 500
// base := GetBase ( base_dep ) ;
23830: LD_ADDR_VAR 0 15
23834: PUSH
23835: LD_VAR 0 1
23839: PPUSH
23840: CALL_OW 274
23844: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23845: LD_ADDR_VAR 0 16
23849: PUSH
23850: LD_VAR 0 1
23854: PPUSH
23855: CALL_OW 255
23859: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23860: LD_ADDR_VAR 0 17
23864: PUSH
23865: LD_VAR 0 1
23869: PPUSH
23870: CALL_OW 248
23874: ST_TO_ADDR
// if sources then
23875: LD_VAR 0 5
23879: IFFALSE 23926
// for i = 1 to 3 do
23881: LD_ADDR_VAR 0 8
23885: PUSH
23886: DOUBLE
23887: LD_INT 1
23889: DEC
23890: ST_TO_ADDR
23891: LD_INT 3
23893: PUSH
23894: FOR_TO
23895: IFFALSE 23924
// AddResourceType ( base , i , sources [ i ] ) ;
23897: LD_VAR 0 15
23901: PPUSH
23902: LD_VAR 0 8
23906: PPUSH
23907: LD_VAR 0 5
23911: PUSH
23912: LD_VAR 0 8
23916: ARRAY
23917: PPUSH
23918: CALL_OW 276
23922: GO 23894
23924: POP
23925: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
23926: LD_ADDR_VAR 0 18
23930: PUSH
23931: LD_VAR 0 15
23935: PPUSH
23936: LD_VAR 0 2
23940: PPUSH
23941: LD_INT 1
23943: PPUSH
23944: CALL 23187 0 3
23948: ST_TO_ADDR
// InitHc ;
23949: CALL_OW 19
// InitUc ;
23953: CALL_OW 18
// uc_side := side ;
23957: LD_ADDR_OWVAR 20
23961: PUSH
23962: LD_VAR 0 16
23966: ST_TO_ADDR
// uc_nation := nation ;
23967: LD_ADDR_OWVAR 21
23971: PUSH
23972: LD_VAR 0 17
23976: ST_TO_ADDR
// if buildings then
23977: LD_VAR 0 18
23981: IFFALSE 25303
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
23983: LD_ADDR_VAR 0 19
23987: PUSH
23988: LD_VAR 0 18
23992: PPUSH
23993: LD_INT 2
23995: PUSH
23996: LD_INT 30
23998: PUSH
23999: LD_INT 29
24001: PUSH
24002: EMPTY
24003: LIST
24004: LIST
24005: PUSH
24006: LD_INT 30
24008: PUSH
24009: LD_INT 30
24011: PUSH
24012: EMPTY
24013: LIST
24014: LIST
24015: PUSH
24016: EMPTY
24017: LIST
24018: LIST
24019: LIST
24020: PPUSH
24021: CALL_OW 72
24025: ST_TO_ADDR
// if tmp then
24026: LD_VAR 0 19
24030: IFFALSE 24078
// for i in tmp do
24032: LD_ADDR_VAR 0 8
24036: PUSH
24037: LD_VAR 0 19
24041: PUSH
24042: FOR_IN
24043: IFFALSE 24076
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24045: LD_VAR 0 8
24049: PPUSH
24050: CALL_OW 250
24054: PPUSH
24055: LD_VAR 0 8
24059: PPUSH
24060: CALL_OW 251
24064: PPUSH
24065: LD_VAR 0 16
24069: PPUSH
24070: CALL_OW 441
24074: GO 24042
24076: POP
24077: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24078: LD_VAR 0 18
24082: PPUSH
24083: LD_INT 2
24085: PUSH
24086: LD_INT 30
24088: PUSH
24089: LD_INT 32
24091: PUSH
24092: EMPTY
24093: LIST
24094: LIST
24095: PUSH
24096: LD_INT 30
24098: PUSH
24099: LD_INT 33
24101: PUSH
24102: EMPTY
24103: LIST
24104: LIST
24105: PUSH
24106: EMPTY
24107: LIST
24108: LIST
24109: LIST
24110: PPUSH
24111: CALL_OW 72
24115: IFFALSE 24203
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
24117: LD_ADDR_VAR 0 8
24121: PUSH
24122: LD_VAR 0 18
24126: PPUSH
24127: LD_INT 2
24129: PUSH
24130: LD_INT 30
24132: PUSH
24133: LD_INT 32
24135: PUSH
24136: EMPTY
24137: LIST
24138: LIST
24139: PUSH
24140: LD_INT 30
24142: PUSH
24143: LD_INT 33
24145: PUSH
24146: EMPTY
24147: LIST
24148: LIST
24149: PUSH
24150: EMPTY
24151: LIST
24152: LIST
24153: LIST
24154: PPUSH
24155: CALL_OW 72
24159: PUSH
24160: FOR_IN
24161: IFFALSE 24201
// begin if not GetBWeapon ( i ) then
24163: LD_VAR 0 8
24167: PPUSH
24168: CALL_OW 269
24172: NOT
24173: IFFALSE 24199
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
24175: LD_VAR 0 8
24179: PPUSH
24180: LD_VAR 0 8
24184: PPUSH
24185: LD_VAR 0 2
24189: PPUSH
24190: CALL 25449 0 2
24194: PPUSH
24195: CALL_OW 431
// end ;
24199: GO 24160
24201: POP
24202: POP
// end ; for i = 1 to personel do
24203: LD_ADDR_VAR 0 8
24207: PUSH
24208: DOUBLE
24209: LD_INT 1
24211: DEC
24212: ST_TO_ADDR
24213: LD_VAR 0 6
24217: PUSH
24218: FOR_TO
24219: IFFALSE 25283
// begin if i > 4 then
24221: LD_VAR 0 8
24225: PUSH
24226: LD_INT 4
24228: GREATER
24229: IFFALSE 24233
// break ;
24231: GO 25283
// case i of 1 :
24233: LD_VAR 0 8
24237: PUSH
24238: LD_INT 1
24240: DOUBLE
24241: EQUAL
24242: IFTRUE 24246
24244: GO 24326
24246: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24247: LD_ADDR_VAR 0 12
24251: PUSH
24252: LD_VAR 0 18
24256: PPUSH
24257: LD_INT 22
24259: PUSH
24260: LD_VAR 0 16
24264: PUSH
24265: EMPTY
24266: LIST
24267: LIST
24268: PUSH
24269: LD_INT 58
24271: PUSH
24272: EMPTY
24273: LIST
24274: PUSH
24275: LD_INT 2
24277: PUSH
24278: LD_INT 30
24280: PUSH
24281: LD_INT 32
24283: PUSH
24284: EMPTY
24285: LIST
24286: LIST
24287: PUSH
24288: LD_INT 30
24290: PUSH
24291: LD_INT 4
24293: PUSH
24294: EMPTY
24295: LIST
24296: LIST
24297: PUSH
24298: LD_INT 30
24300: PUSH
24301: LD_INT 5
24303: PUSH
24304: EMPTY
24305: LIST
24306: LIST
24307: PUSH
24308: EMPTY
24309: LIST
24310: LIST
24311: LIST
24312: LIST
24313: PUSH
24314: EMPTY
24315: LIST
24316: LIST
24317: LIST
24318: PPUSH
24319: CALL_OW 72
24323: ST_TO_ADDR
24324: GO 24548
24326: LD_INT 2
24328: DOUBLE
24329: EQUAL
24330: IFTRUE 24334
24332: GO 24396
24334: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24335: LD_ADDR_VAR 0 12
24339: PUSH
24340: LD_VAR 0 18
24344: PPUSH
24345: LD_INT 22
24347: PUSH
24348: LD_VAR 0 16
24352: PUSH
24353: EMPTY
24354: LIST
24355: LIST
24356: PUSH
24357: LD_INT 2
24359: PUSH
24360: LD_INT 30
24362: PUSH
24363: LD_INT 0
24365: PUSH
24366: EMPTY
24367: LIST
24368: LIST
24369: PUSH
24370: LD_INT 30
24372: PUSH
24373: LD_INT 1
24375: PUSH
24376: EMPTY
24377: LIST
24378: LIST
24379: PUSH
24380: EMPTY
24381: LIST
24382: LIST
24383: LIST
24384: PUSH
24385: EMPTY
24386: LIST
24387: LIST
24388: PPUSH
24389: CALL_OW 72
24393: ST_TO_ADDR
24394: GO 24548
24396: LD_INT 3
24398: DOUBLE
24399: EQUAL
24400: IFTRUE 24404
24402: GO 24466
24404: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24405: LD_ADDR_VAR 0 12
24409: PUSH
24410: LD_VAR 0 18
24414: PPUSH
24415: LD_INT 22
24417: PUSH
24418: LD_VAR 0 16
24422: PUSH
24423: EMPTY
24424: LIST
24425: LIST
24426: PUSH
24427: LD_INT 2
24429: PUSH
24430: LD_INT 30
24432: PUSH
24433: LD_INT 2
24435: PUSH
24436: EMPTY
24437: LIST
24438: LIST
24439: PUSH
24440: LD_INT 30
24442: PUSH
24443: LD_INT 3
24445: PUSH
24446: EMPTY
24447: LIST
24448: LIST
24449: PUSH
24450: EMPTY
24451: LIST
24452: LIST
24453: LIST
24454: PUSH
24455: EMPTY
24456: LIST
24457: LIST
24458: PPUSH
24459: CALL_OW 72
24463: ST_TO_ADDR
24464: GO 24548
24466: LD_INT 4
24468: DOUBLE
24469: EQUAL
24470: IFTRUE 24474
24472: GO 24547
24474: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24475: LD_ADDR_VAR 0 12
24479: PUSH
24480: LD_VAR 0 18
24484: PPUSH
24485: LD_INT 22
24487: PUSH
24488: LD_VAR 0 16
24492: PUSH
24493: EMPTY
24494: LIST
24495: LIST
24496: PUSH
24497: LD_INT 2
24499: PUSH
24500: LD_INT 30
24502: PUSH
24503: LD_INT 6
24505: PUSH
24506: EMPTY
24507: LIST
24508: LIST
24509: PUSH
24510: LD_INT 30
24512: PUSH
24513: LD_INT 7
24515: PUSH
24516: EMPTY
24517: LIST
24518: LIST
24519: PUSH
24520: LD_INT 30
24522: PUSH
24523: LD_INT 8
24525: PUSH
24526: EMPTY
24527: LIST
24528: LIST
24529: PUSH
24530: EMPTY
24531: LIST
24532: LIST
24533: LIST
24534: LIST
24535: PUSH
24536: EMPTY
24537: LIST
24538: LIST
24539: PPUSH
24540: CALL_OW 72
24544: ST_TO_ADDR
24545: GO 24548
24547: POP
// if i = 1 then
24548: LD_VAR 0 8
24552: PUSH
24553: LD_INT 1
24555: EQUAL
24556: IFFALSE 24667
// begin tmp := [ ] ;
24558: LD_ADDR_VAR 0 19
24562: PUSH
24563: EMPTY
24564: ST_TO_ADDR
// for j in f do
24565: LD_ADDR_VAR 0 9
24569: PUSH
24570: LD_VAR 0 12
24574: PUSH
24575: FOR_IN
24576: IFFALSE 24649
// if GetBType ( j ) = b_bunker then
24578: LD_VAR 0 9
24582: PPUSH
24583: CALL_OW 266
24587: PUSH
24588: LD_INT 32
24590: EQUAL
24591: IFFALSE 24618
// tmp := Insert ( tmp , 1 , j ) else
24593: LD_ADDR_VAR 0 19
24597: PUSH
24598: LD_VAR 0 19
24602: PPUSH
24603: LD_INT 1
24605: PPUSH
24606: LD_VAR 0 9
24610: PPUSH
24611: CALL_OW 2
24615: ST_TO_ADDR
24616: GO 24647
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24618: LD_ADDR_VAR 0 19
24622: PUSH
24623: LD_VAR 0 19
24627: PPUSH
24628: LD_VAR 0 19
24632: PUSH
24633: LD_INT 1
24635: PLUS
24636: PPUSH
24637: LD_VAR 0 9
24641: PPUSH
24642: CALL_OW 2
24646: ST_TO_ADDR
24647: GO 24575
24649: POP
24650: POP
// if tmp then
24651: LD_VAR 0 19
24655: IFFALSE 24667
// f := tmp ;
24657: LD_ADDR_VAR 0 12
24661: PUSH
24662: LD_VAR 0 19
24666: ST_TO_ADDR
// end ; x := personel [ i ] ;
24667: LD_ADDR_VAR 0 13
24671: PUSH
24672: LD_VAR 0 6
24676: PUSH
24677: LD_VAR 0 8
24681: ARRAY
24682: ST_TO_ADDR
// if x = - 1 then
24683: LD_VAR 0 13
24687: PUSH
24688: LD_INT 1
24690: NEG
24691: EQUAL
24692: IFFALSE 24901
// begin for j in f do
24694: LD_ADDR_VAR 0 9
24698: PUSH
24699: LD_VAR 0 12
24703: PUSH
24704: FOR_IN
24705: IFFALSE 24897
// repeat InitHc ;
24707: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24711: LD_VAR 0 9
24715: PPUSH
24716: CALL_OW 266
24720: PUSH
24721: LD_INT 5
24723: EQUAL
24724: IFFALSE 24794
// begin if UnitsInside ( j ) < 3 then
24726: LD_VAR 0 9
24730: PPUSH
24731: CALL_OW 313
24735: PUSH
24736: LD_INT 3
24738: LESS
24739: IFFALSE 24775
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24741: LD_INT 0
24743: PPUSH
24744: LD_INT 5
24746: PUSH
24747: LD_INT 8
24749: PUSH
24750: LD_INT 9
24752: PUSH
24753: EMPTY
24754: LIST
24755: LIST
24756: LIST
24757: PUSH
24758: LD_VAR 0 17
24762: ARRAY
24763: PPUSH
24764: LD_VAR 0 4
24768: PPUSH
24769: CALL_OW 380
24773: GO 24792
// PrepareHuman ( false , i , skill ) ;
24775: LD_INT 0
24777: PPUSH
24778: LD_VAR 0 8
24782: PPUSH
24783: LD_VAR 0 4
24787: PPUSH
24788: CALL_OW 380
// end else
24792: GO 24811
// PrepareHuman ( false , i , skill ) ;
24794: LD_INT 0
24796: PPUSH
24797: LD_VAR 0 8
24801: PPUSH
24802: LD_VAR 0 4
24806: PPUSH
24807: CALL_OW 380
// un := CreateHuman ;
24811: LD_ADDR_VAR 0 14
24815: PUSH
24816: CALL_OW 44
24820: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24821: LD_ADDR_VAR 0 7
24825: PUSH
24826: LD_VAR 0 7
24830: PPUSH
24831: LD_INT 1
24833: PPUSH
24834: LD_VAR 0 14
24838: PPUSH
24839: CALL_OW 2
24843: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24844: LD_VAR 0 14
24848: PPUSH
24849: LD_VAR 0 9
24853: PPUSH
24854: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24858: LD_VAR 0 9
24862: PPUSH
24863: CALL_OW 313
24867: PUSH
24868: LD_INT 6
24870: EQUAL
24871: PUSH
24872: LD_VAR 0 9
24876: PPUSH
24877: CALL_OW 266
24881: PUSH
24882: LD_INT 32
24884: PUSH
24885: LD_INT 31
24887: PUSH
24888: EMPTY
24889: LIST
24890: LIST
24891: IN
24892: OR
24893: IFFALSE 24707
24895: GO 24704
24897: POP
24898: POP
// end else
24899: GO 25281
// for j = 1 to x do
24901: LD_ADDR_VAR 0 9
24905: PUSH
24906: DOUBLE
24907: LD_INT 1
24909: DEC
24910: ST_TO_ADDR
24911: LD_VAR 0 13
24915: PUSH
24916: FOR_TO
24917: IFFALSE 25279
// begin InitHc ;
24919: CALL_OW 19
// if not f then
24923: LD_VAR 0 12
24927: NOT
24928: IFFALSE 25017
// begin PrepareHuman ( false , i , skill ) ;
24930: LD_INT 0
24932: PPUSH
24933: LD_VAR 0 8
24937: PPUSH
24938: LD_VAR 0 4
24942: PPUSH
24943: CALL_OW 380
// un := CreateHuman ;
24947: LD_ADDR_VAR 0 14
24951: PUSH
24952: CALL_OW 44
24956: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24957: LD_ADDR_VAR 0 7
24961: PUSH
24962: LD_VAR 0 7
24966: PPUSH
24967: LD_INT 1
24969: PPUSH
24970: LD_VAR 0 14
24974: PPUSH
24975: CALL_OW 2
24979: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24980: LD_VAR 0 14
24984: PPUSH
24985: LD_VAR 0 1
24989: PPUSH
24990: CALL_OW 250
24994: PPUSH
24995: LD_VAR 0 1
24999: PPUSH
25000: CALL_OW 251
25004: PPUSH
25005: LD_INT 10
25007: PPUSH
25008: LD_INT 0
25010: PPUSH
25011: CALL_OW 50
// continue ;
25015: GO 24916
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25017: LD_VAR 0 12
25021: PUSH
25022: LD_INT 1
25024: ARRAY
25025: PPUSH
25026: CALL_OW 313
25030: PUSH
25031: LD_VAR 0 12
25035: PUSH
25036: LD_INT 1
25038: ARRAY
25039: PPUSH
25040: CALL_OW 266
25044: PUSH
25045: LD_INT 32
25047: PUSH
25048: LD_INT 31
25050: PUSH
25051: EMPTY
25052: LIST
25053: LIST
25054: IN
25055: AND
25056: PUSH
25057: LD_VAR 0 12
25061: PUSH
25062: LD_INT 1
25064: ARRAY
25065: PPUSH
25066: CALL_OW 313
25070: PUSH
25071: LD_INT 6
25073: EQUAL
25074: OR
25075: IFFALSE 25095
// f := Delete ( f , 1 ) ;
25077: LD_ADDR_VAR 0 12
25081: PUSH
25082: LD_VAR 0 12
25086: PPUSH
25087: LD_INT 1
25089: PPUSH
25090: CALL_OW 3
25094: ST_TO_ADDR
// if not f then
25095: LD_VAR 0 12
25099: NOT
25100: IFFALSE 25118
// begin x := x + 2 ;
25102: LD_ADDR_VAR 0 13
25106: PUSH
25107: LD_VAR 0 13
25111: PUSH
25112: LD_INT 2
25114: PLUS
25115: ST_TO_ADDR
// continue ;
25116: GO 24916
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
25118: LD_VAR 0 12
25122: PUSH
25123: LD_INT 1
25125: ARRAY
25126: PPUSH
25127: CALL_OW 266
25131: PUSH
25132: LD_INT 5
25134: EQUAL
25135: IFFALSE 25209
// begin if UnitsInside ( f [ 1 ] ) < 3 then
25137: LD_VAR 0 12
25141: PUSH
25142: LD_INT 1
25144: ARRAY
25145: PPUSH
25146: CALL_OW 313
25150: PUSH
25151: LD_INT 3
25153: LESS
25154: IFFALSE 25190
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25156: LD_INT 0
25158: PPUSH
25159: LD_INT 5
25161: PUSH
25162: LD_INT 8
25164: PUSH
25165: LD_INT 9
25167: PUSH
25168: EMPTY
25169: LIST
25170: LIST
25171: LIST
25172: PUSH
25173: LD_VAR 0 17
25177: ARRAY
25178: PPUSH
25179: LD_VAR 0 4
25183: PPUSH
25184: CALL_OW 380
25188: GO 25207
// PrepareHuman ( false , i , skill ) ;
25190: LD_INT 0
25192: PPUSH
25193: LD_VAR 0 8
25197: PPUSH
25198: LD_VAR 0 4
25202: PPUSH
25203: CALL_OW 380
// end else
25207: GO 25226
// PrepareHuman ( false , i , skill ) ;
25209: LD_INT 0
25211: PPUSH
25212: LD_VAR 0 8
25216: PPUSH
25217: LD_VAR 0 4
25221: PPUSH
25222: CALL_OW 380
// un := CreateHuman ;
25226: LD_ADDR_VAR 0 14
25230: PUSH
25231: CALL_OW 44
25235: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25236: LD_ADDR_VAR 0 7
25240: PUSH
25241: LD_VAR 0 7
25245: PPUSH
25246: LD_INT 1
25248: PPUSH
25249: LD_VAR 0 14
25253: PPUSH
25254: CALL_OW 2
25258: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25259: LD_VAR 0 14
25263: PPUSH
25264: LD_VAR 0 12
25268: PUSH
25269: LD_INT 1
25271: ARRAY
25272: PPUSH
25273: CALL_OW 52
// end ;
25277: GO 24916
25279: POP
25280: POP
// end ;
25281: GO 24218
25283: POP
25284: POP
// result := result ^ buildings ;
25285: LD_ADDR_VAR 0 7
25289: PUSH
25290: LD_VAR 0 7
25294: PUSH
25295: LD_VAR 0 18
25299: ADD
25300: ST_TO_ADDR
// end else
25301: GO 25444
// begin for i = 1 to personel do
25303: LD_ADDR_VAR 0 8
25307: PUSH
25308: DOUBLE
25309: LD_INT 1
25311: DEC
25312: ST_TO_ADDR
25313: LD_VAR 0 6
25317: PUSH
25318: FOR_TO
25319: IFFALSE 25442
// begin if i > 4 then
25321: LD_VAR 0 8
25325: PUSH
25326: LD_INT 4
25328: GREATER
25329: IFFALSE 25333
// break ;
25331: GO 25442
// x := personel [ i ] ;
25333: LD_ADDR_VAR 0 13
25337: PUSH
25338: LD_VAR 0 6
25342: PUSH
25343: LD_VAR 0 8
25347: ARRAY
25348: ST_TO_ADDR
// if x = - 1 then
25349: LD_VAR 0 13
25353: PUSH
25354: LD_INT 1
25356: NEG
25357: EQUAL
25358: IFFALSE 25362
// continue ;
25360: GO 25318
// PrepareHuman ( false , i , skill ) ;
25362: LD_INT 0
25364: PPUSH
25365: LD_VAR 0 8
25369: PPUSH
25370: LD_VAR 0 4
25374: PPUSH
25375: CALL_OW 380
// un := CreateHuman ;
25379: LD_ADDR_VAR 0 14
25383: PUSH
25384: CALL_OW 44
25388: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25389: LD_VAR 0 14
25393: PPUSH
25394: LD_VAR 0 1
25398: PPUSH
25399: CALL_OW 250
25403: PPUSH
25404: LD_VAR 0 1
25408: PPUSH
25409: CALL_OW 251
25413: PPUSH
25414: LD_INT 10
25416: PPUSH
25417: LD_INT 0
25419: PPUSH
25420: CALL_OW 50
// result := result ^ un ;
25424: LD_ADDR_VAR 0 7
25428: PUSH
25429: LD_VAR 0 7
25433: PUSH
25434: LD_VAR 0 14
25438: ADD
25439: ST_TO_ADDR
// end ;
25440: GO 25318
25442: POP
25443: POP
// end ; end ;
25444: LD_VAR 0 7
25448: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25449: LD_INT 0
25451: PPUSH
25452: PPUSH
25453: PPUSH
25454: PPUSH
25455: PPUSH
25456: PPUSH
25457: PPUSH
25458: PPUSH
25459: PPUSH
25460: PPUSH
25461: PPUSH
25462: PPUSH
25463: PPUSH
25464: PPUSH
25465: PPUSH
25466: PPUSH
// result := false ;
25467: LD_ADDR_VAR 0 3
25471: PUSH
25472: LD_INT 0
25474: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25475: LD_VAR 0 1
25479: NOT
25480: PUSH
25481: LD_VAR 0 1
25485: PPUSH
25486: CALL_OW 266
25490: PUSH
25491: LD_INT 32
25493: PUSH
25494: LD_INT 33
25496: PUSH
25497: EMPTY
25498: LIST
25499: LIST
25500: IN
25501: NOT
25502: OR
25503: IFFALSE 25507
// exit ;
25505: GO 26616
// nat := GetNation ( tower ) ;
25507: LD_ADDR_VAR 0 12
25511: PUSH
25512: LD_VAR 0 1
25516: PPUSH
25517: CALL_OW 248
25521: ST_TO_ADDR
// side := GetSide ( tower ) ;
25522: LD_ADDR_VAR 0 16
25526: PUSH
25527: LD_VAR 0 1
25531: PPUSH
25532: CALL_OW 255
25536: ST_TO_ADDR
// x := GetX ( tower ) ;
25537: LD_ADDR_VAR 0 10
25541: PUSH
25542: LD_VAR 0 1
25546: PPUSH
25547: CALL_OW 250
25551: ST_TO_ADDR
// y := GetY ( tower ) ;
25552: LD_ADDR_VAR 0 11
25556: PUSH
25557: LD_VAR 0 1
25561: PPUSH
25562: CALL_OW 251
25566: ST_TO_ADDR
// if not x or not y then
25567: LD_VAR 0 10
25571: NOT
25572: PUSH
25573: LD_VAR 0 11
25577: NOT
25578: OR
25579: IFFALSE 25583
// exit ;
25581: GO 26616
// weapon := 0 ;
25583: LD_ADDR_VAR 0 18
25587: PUSH
25588: LD_INT 0
25590: ST_TO_ADDR
// fac_list := [ ] ;
25591: LD_ADDR_VAR 0 17
25595: PUSH
25596: EMPTY
25597: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
25598: LD_ADDR_VAR 0 6
25602: PUSH
25603: LD_VAR 0 1
25607: PPUSH
25608: CALL_OW 274
25612: PPUSH
25613: LD_VAR 0 2
25617: PPUSH
25618: LD_INT 0
25620: PPUSH
25621: CALL 23187 0 3
25625: PPUSH
25626: LD_INT 30
25628: PUSH
25629: LD_INT 3
25631: PUSH
25632: EMPTY
25633: LIST
25634: LIST
25635: PPUSH
25636: CALL_OW 72
25640: ST_TO_ADDR
// if not factories then
25641: LD_VAR 0 6
25645: NOT
25646: IFFALSE 25650
// exit ;
25648: GO 26616
// for i in factories do
25650: LD_ADDR_VAR 0 8
25654: PUSH
25655: LD_VAR 0 6
25659: PUSH
25660: FOR_IN
25661: IFFALSE 25686
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25663: LD_ADDR_VAR 0 17
25667: PUSH
25668: LD_VAR 0 17
25672: PUSH
25673: LD_VAR 0 8
25677: PPUSH
25678: CALL_OW 478
25682: UNION
25683: ST_TO_ADDR
25684: GO 25660
25686: POP
25687: POP
// if not fac_list then
25688: LD_VAR 0 17
25692: NOT
25693: IFFALSE 25697
// exit ;
25695: GO 26616
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25697: LD_ADDR_VAR 0 5
25701: PUSH
25702: LD_INT 4
25704: PUSH
25705: LD_INT 5
25707: PUSH
25708: LD_INT 9
25710: PUSH
25711: LD_INT 10
25713: PUSH
25714: LD_INT 6
25716: PUSH
25717: LD_INT 7
25719: PUSH
25720: LD_INT 11
25722: PUSH
25723: EMPTY
25724: LIST
25725: LIST
25726: LIST
25727: LIST
25728: LIST
25729: LIST
25730: LIST
25731: PUSH
25732: LD_INT 27
25734: PUSH
25735: LD_INT 28
25737: PUSH
25738: LD_INT 26
25740: PUSH
25741: LD_INT 30
25743: PUSH
25744: EMPTY
25745: LIST
25746: LIST
25747: LIST
25748: LIST
25749: PUSH
25750: LD_INT 43
25752: PUSH
25753: LD_INT 44
25755: PUSH
25756: LD_INT 46
25758: PUSH
25759: LD_INT 45
25761: PUSH
25762: LD_INT 47
25764: PUSH
25765: LD_INT 49
25767: PUSH
25768: EMPTY
25769: LIST
25770: LIST
25771: LIST
25772: LIST
25773: LIST
25774: LIST
25775: PUSH
25776: EMPTY
25777: LIST
25778: LIST
25779: LIST
25780: PUSH
25781: LD_VAR 0 12
25785: ARRAY
25786: ST_TO_ADDR
// list := list isect fac_list ;
25787: LD_ADDR_VAR 0 5
25791: PUSH
25792: LD_VAR 0 5
25796: PUSH
25797: LD_VAR 0 17
25801: ISECT
25802: ST_TO_ADDR
// if not list then
25803: LD_VAR 0 5
25807: NOT
25808: IFFALSE 25812
// exit ;
25810: GO 26616
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25812: LD_VAR 0 12
25816: PUSH
25817: LD_INT 3
25819: EQUAL
25820: PUSH
25821: LD_INT 49
25823: PUSH
25824: LD_VAR 0 5
25828: IN
25829: AND
25830: PUSH
25831: LD_INT 31
25833: PPUSH
25834: LD_VAR 0 16
25838: PPUSH
25839: CALL_OW 321
25843: PUSH
25844: LD_INT 2
25846: EQUAL
25847: AND
25848: IFFALSE 25908
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25850: LD_INT 22
25852: PUSH
25853: LD_VAR 0 16
25857: PUSH
25858: EMPTY
25859: LIST
25860: LIST
25861: PUSH
25862: LD_INT 35
25864: PUSH
25865: LD_INT 49
25867: PUSH
25868: EMPTY
25869: LIST
25870: LIST
25871: PUSH
25872: LD_INT 91
25874: PUSH
25875: LD_VAR 0 1
25879: PUSH
25880: LD_INT 10
25882: PUSH
25883: EMPTY
25884: LIST
25885: LIST
25886: LIST
25887: PUSH
25888: EMPTY
25889: LIST
25890: LIST
25891: LIST
25892: PPUSH
25893: CALL_OW 69
25897: NOT
25898: IFFALSE 25908
// weapon := ru_time_lapser ;
25900: LD_ADDR_VAR 0 18
25904: PUSH
25905: LD_INT 49
25907: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25908: LD_VAR 0 12
25912: PUSH
25913: LD_INT 1
25915: PUSH
25916: LD_INT 2
25918: PUSH
25919: EMPTY
25920: LIST
25921: LIST
25922: IN
25923: PUSH
25924: LD_INT 11
25926: PUSH
25927: LD_VAR 0 5
25931: IN
25932: PUSH
25933: LD_INT 30
25935: PUSH
25936: LD_VAR 0 5
25940: IN
25941: OR
25942: AND
25943: PUSH
25944: LD_INT 6
25946: PPUSH
25947: LD_VAR 0 16
25951: PPUSH
25952: CALL_OW 321
25956: PUSH
25957: LD_INT 2
25959: EQUAL
25960: AND
25961: IFFALSE 26126
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25963: LD_INT 22
25965: PUSH
25966: LD_VAR 0 16
25970: PUSH
25971: EMPTY
25972: LIST
25973: LIST
25974: PUSH
25975: LD_INT 2
25977: PUSH
25978: LD_INT 35
25980: PUSH
25981: LD_INT 11
25983: PUSH
25984: EMPTY
25985: LIST
25986: LIST
25987: PUSH
25988: LD_INT 35
25990: PUSH
25991: LD_INT 30
25993: PUSH
25994: EMPTY
25995: LIST
25996: LIST
25997: PUSH
25998: EMPTY
25999: LIST
26000: LIST
26001: LIST
26002: PUSH
26003: LD_INT 91
26005: PUSH
26006: LD_VAR 0 1
26010: PUSH
26011: LD_INT 18
26013: PUSH
26014: EMPTY
26015: LIST
26016: LIST
26017: LIST
26018: PUSH
26019: EMPTY
26020: LIST
26021: LIST
26022: LIST
26023: PPUSH
26024: CALL_OW 69
26028: NOT
26029: PUSH
26030: LD_INT 22
26032: PUSH
26033: LD_VAR 0 16
26037: PUSH
26038: EMPTY
26039: LIST
26040: LIST
26041: PUSH
26042: LD_INT 2
26044: PUSH
26045: LD_INT 30
26047: PUSH
26048: LD_INT 32
26050: PUSH
26051: EMPTY
26052: LIST
26053: LIST
26054: PUSH
26055: LD_INT 30
26057: PUSH
26058: LD_INT 33
26060: PUSH
26061: EMPTY
26062: LIST
26063: LIST
26064: PUSH
26065: EMPTY
26066: LIST
26067: LIST
26068: LIST
26069: PUSH
26070: LD_INT 91
26072: PUSH
26073: LD_VAR 0 1
26077: PUSH
26078: LD_INT 12
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: LIST
26085: PUSH
26086: EMPTY
26087: LIST
26088: LIST
26089: LIST
26090: PUSH
26091: EMPTY
26092: LIST
26093: PPUSH
26094: CALL_OW 69
26098: PUSH
26099: LD_INT 2
26101: GREATER
26102: AND
26103: IFFALSE 26126
// weapon := [ us_radar , ar_radar ] [ nat ] ;
26105: LD_ADDR_VAR 0 18
26109: PUSH
26110: LD_INT 11
26112: PUSH
26113: LD_INT 30
26115: PUSH
26116: EMPTY
26117: LIST
26118: LIST
26119: PUSH
26120: LD_VAR 0 12
26124: ARRAY
26125: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
26126: LD_VAR 0 18
26130: NOT
26131: PUSH
26132: LD_INT 40
26134: PPUSH
26135: LD_VAR 0 16
26139: PPUSH
26140: CALL_OW 321
26144: PUSH
26145: LD_INT 2
26147: EQUAL
26148: AND
26149: PUSH
26150: LD_INT 7
26152: PUSH
26153: LD_VAR 0 5
26157: IN
26158: PUSH
26159: LD_INT 28
26161: PUSH
26162: LD_VAR 0 5
26166: IN
26167: OR
26168: PUSH
26169: LD_INT 45
26171: PUSH
26172: LD_VAR 0 5
26176: IN
26177: OR
26178: AND
26179: IFFALSE 26433
// begin hex := GetHexInfo ( x , y ) ;
26181: LD_ADDR_VAR 0 4
26185: PUSH
26186: LD_VAR 0 10
26190: PPUSH
26191: LD_VAR 0 11
26195: PPUSH
26196: CALL_OW 546
26200: ST_TO_ADDR
// if hex [ 1 ] then
26201: LD_VAR 0 4
26205: PUSH
26206: LD_INT 1
26208: ARRAY
26209: IFFALSE 26213
// exit ;
26211: GO 26616
// height := hex [ 2 ] ;
26213: LD_ADDR_VAR 0 15
26217: PUSH
26218: LD_VAR 0 4
26222: PUSH
26223: LD_INT 2
26225: ARRAY
26226: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26227: LD_ADDR_VAR 0 14
26231: PUSH
26232: LD_INT 0
26234: PUSH
26235: LD_INT 2
26237: PUSH
26238: LD_INT 3
26240: PUSH
26241: LD_INT 5
26243: PUSH
26244: EMPTY
26245: LIST
26246: LIST
26247: LIST
26248: LIST
26249: ST_TO_ADDR
// for i in tmp do
26250: LD_ADDR_VAR 0 8
26254: PUSH
26255: LD_VAR 0 14
26259: PUSH
26260: FOR_IN
26261: IFFALSE 26431
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26263: LD_ADDR_VAR 0 9
26267: PUSH
26268: LD_VAR 0 10
26272: PPUSH
26273: LD_VAR 0 8
26277: PPUSH
26278: LD_INT 5
26280: PPUSH
26281: CALL_OW 272
26285: PUSH
26286: LD_VAR 0 11
26290: PPUSH
26291: LD_VAR 0 8
26295: PPUSH
26296: LD_INT 5
26298: PPUSH
26299: CALL_OW 273
26303: PUSH
26304: EMPTY
26305: LIST
26306: LIST
26307: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26308: LD_VAR 0 9
26312: PUSH
26313: LD_INT 1
26315: ARRAY
26316: PPUSH
26317: LD_VAR 0 9
26321: PUSH
26322: LD_INT 2
26324: ARRAY
26325: PPUSH
26326: CALL_OW 488
26330: IFFALSE 26429
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26332: LD_ADDR_VAR 0 4
26336: PUSH
26337: LD_VAR 0 9
26341: PUSH
26342: LD_INT 1
26344: ARRAY
26345: PPUSH
26346: LD_VAR 0 9
26350: PUSH
26351: LD_INT 2
26353: ARRAY
26354: PPUSH
26355: CALL_OW 546
26359: ST_TO_ADDR
// if hex [ 1 ] then
26360: LD_VAR 0 4
26364: PUSH
26365: LD_INT 1
26367: ARRAY
26368: IFFALSE 26372
// continue ;
26370: GO 26260
// h := hex [ 2 ] ;
26372: LD_ADDR_VAR 0 13
26376: PUSH
26377: LD_VAR 0 4
26381: PUSH
26382: LD_INT 2
26384: ARRAY
26385: ST_TO_ADDR
// if h + 7 < height then
26386: LD_VAR 0 13
26390: PUSH
26391: LD_INT 7
26393: PLUS
26394: PUSH
26395: LD_VAR 0 15
26399: LESS
26400: IFFALSE 26429
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26402: LD_ADDR_VAR 0 18
26406: PUSH
26407: LD_INT 7
26409: PUSH
26410: LD_INT 28
26412: PUSH
26413: LD_INT 45
26415: PUSH
26416: EMPTY
26417: LIST
26418: LIST
26419: LIST
26420: PUSH
26421: LD_VAR 0 12
26425: ARRAY
26426: ST_TO_ADDR
// break ;
26427: GO 26431
// end ; end ; end ;
26429: GO 26260
26431: POP
26432: POP
// end ; if not weapon then
26433: LD_VAR 0 18
26437: NOT
26438: IFFALSE 26498
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26440: LD_ADDR_VAR 0 5
26444: PUSH
26445: LD_VAR 0 5
26449: PUSH
26450: LD_INT 11
26452: PUSH
26453: LD_INT 30
26455: PUSH
26456: LD_INT 49
26458: PUSH
26459: EMPTY
26460: LIST
26461: LIST
26462: LIST
26463: DIFF
26464: ST_TO_ADDR
// if not list then
26465: LD_VAR 0 5
26469: NOT
26470: IFFALSE 26474
// exit ;
26472: GO 26616
// weapon := list [ rand ( 1 , list ) ] ;
26474: LD_ADDR_VAR 0 18
26478: PUSH
26479: LD_VAR 0 5
26483: PUSH
26484: LD_INT 1
26486: PPUSH
26487: LD_VAR 0 5
26491: PPUSH
26492: CALL_OW 12
26496: ARRAY
26497: ST_TO_ADDR
// end ; if weapon then
26498: LD_VAR 0 18
26502: IFFALSE 26616
// begin tmp := CostOfWeapon ( weapon ) ;
26504: LD_ADDR_VAR 0 14
26508: PUSH
26509: LD_VAR 0 18
26513: PPUSH
26514: CALL_OW 451
26518: ST_TO_ADDR
// j := GetBase ( tower ) ;
26519: LD_ADDR_VAR 0 9
26523: PUSH
26524: LD_VAR 0 1
26528: PPUSH
26529: CALL_OW 274
26533: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26534: LD_VAR 0 9
26538: PPUSH
26539: LD_INT 1
26541: PPUSH
26542: CALL_OW 275
26546: PUSH
26547: LD_VAR 0 14
26551: PUSH
26552: LD_INT 1
26554: ARRAY
26555: GREATEREQUAL
26556: PUSH
26557: LD_VAR 0 9
26561: PPUSH
26562: LD_INT 2
26564: PPUSH
26565: CALL_OW 275
26569: PUSH
26570: LD_VAR 0 14
26574: PUSH
26575: LD_INT 2
26577: ARRAY
26578: GREATEREQUAL
26579: AND
26580: PUSH
26581: LD_VAR 0 9
26585: PPUSH
26586: LD_INT 3
26588: PPUSH
26589: CALL_OW 275
26593: PUSH
26594: LD_VAR 0 14
26598: PUSH
26599: LD_INT 3
26601: ARRAY
26602: GREATEREQUAL
26603: AND
26604: IFFALSE 26616
// result := weapon ;
26606: LD_ADDR_VAR 0 3
26610: PUSH
26611: LD_VAR 0 18
26615: ST_TO_ADDR
// end ; end ;
26616: LD_VAR 0 3
26620: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26621: LD_INT 0
26623: PPUSH
26624: PPUSH
// result := true ;
26625: LD_ADDR_VAR 0 3
26629: PUSH
26630: LD_INT 1
26632: ST_TO_ADDR
// if array1 = array2 then
26633: LD_VAR 0 1
26637: PUSH
26638: LD_VAR 0 2
26642: EQUAL
26643: IFFALSE 26703
// begin for i = 1 to array1 do
26645: LD_ADDR_VAR 0 4
26649: PUSH
26650: DOUBLE
26651: LD_INT 1
26653: DEC
26654: ST_TO_ADDR
26655: LD_VAR 0 1
26659: PUSH
26660: FOR_TO
26661: IFFALSE 26699
// if array1 [ i ] <> array2 [ i ] then
26663: LD_VAR 0 1
26667: PUSH
26668: LD_VAR 0 4
26672: ARRAY
26673: PUSH
26674: LD_VAR 0 2
26678: PUSH
26679: LD_VAR 0 4
26683: ARRAY
26684: NONEQUAL
26685: IFFALSE 26697
// begin result := false ;
26687: LD_ADDR_VAR 0 3
26691: PUSH
26692: LD_INT 0
26694: ST_TO_ADDR
// break ;
26695: GO 26699
// end ;
26697: GO 26660
26699: POP
26700: POP
// end else
26701: GO 26711
// result := false ;
26703: LD_ADDR_VAR 0 3
26707: PUSH
26708: LD_INT 0
26710: ST_TO_ADDR
// end ;
26711: LD_VAR 0 3
26715: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
26716: LD_INT 0
26718: PPUSH
26719: PPUSH
// if not array1 or not array2 then
26720: LD_VAR 0 1
26724: NOT
26725: PUSH
26726: LD_VAR 0 2
26730: NOT
26731: OR
26732: IFFALSE 26736
// exit ;
26734: GO 26800
// result := true ;
26736: LD_ADDR_VAR 0 3
26740: PUSH
26741: LD_INT 1
26743: ST_TO_ADDR
// for i = 1 to array1 do
26744: LD_ADDR_VAR 0 4
26748: PUSH
26749: DOUBLE
26750: LD_INT 1
26752: DEC
26753: ST_TO_ADDR
26754: LD_VAR 0 1
26758: PUSH
26759: FOR_TO
26760: IFFALSE 26798
// if array1 [ i ] <> array2 [ i ] then
26762: LD_VAR 0 1
26766: PUSH
26767: LD_VAR 0 4
26771: ARRAY
26772: PUSH
26773: LD_VAR 0 2
26777: PUSH
26778: LD_VAR 0 4
26782: ARRAY
26783: NONEQUAL
26784: IFFALSE 26796
// begin result := false ;
26786: LD_ADDR_VAR 0 3
26790: PUSH
26791: LD_INT 0
26793: ST_TO_ADDR
// break ;
26794: GO 26798
// end ;
26796: GO 26759
26798: POP
26799: POP
// end ;
26800: LD_VAR 0 3
26804: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26805: LD_INT 0
26807: PPUSH
26808: PPUSH
26809: PPUSH
// pom := GetBase ( fac ) ;
26810: LD_ADDR_VAR 0 5
26814: PUSH
26815: LD_VAR 0 1
26819: PPUSH
26820: CALL_OW 274
26824: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26825: LD_ADDR_VAR 0 4
26829: PUSH
26830: LD_VAR 0 2
26834: PUSH
26835: LD_INT 1
26837: ARRAY
26838: PPUSH
26839: LD_VAR 0 2
26843: PUSH
26844: LD_INT 2
26846: ARRAY
26847: PPUSH
26848: LD_VAR 0 2
26852: PUSH
26853: LD_INT 3
26855: ARRAY
26856: PPUSH
26857: LD_VAR 0 2
26861: PUSH
26862: LD_INT 4
26864: ARRAY
26865: PPUSH
26866: CALL_OW 449
26870: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26871: LD_ADDR_VAR 0 3
26875: PUSH
26876: LD_VAR 0 5
26880: PPUSH
26881: LD_INT 1
26883: PPUSH
26884: CALL_OW 275
26888: PUSH
26889: LD_VAR 0 4
26893: PUSH
26894: LD_INT 1
26896: ARRAY
26897: GREATEREQUAL
26898: PUSH
26899: LD_VAR 0 5
26903: PPUSH
26904: LD_INT 2
26906: PPUSH
26907: CALL_OW 275
26911: PUSH
26912: LD_VAR 0 4
26916: PUSH
26917: LD_INT 2
26919: ARRAY
26920: GREATEREQUAL
26921: AND
26922: PUSH
26923: LD_VAR 0 5
26927: PPUSH
26928: LD_INT 3
26930: PPUSH
26931: CALL_OW 275
26935: PUSH
26936: LD_VAR 0 4
26940: PUSH
26941: LD_INT 3
26943: ARRAY
26944: GREATEREQUAL
26945: AND
26946: ST_TO_ADDR
// end ;
26947: LD_VAR 0 3
26951: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26952: LD_INT 0
26954: PPUSH
26955: PPUSH
26956: PPUSH
26957: PPUSH
// pom := GetBase ( building ) ;
26958: LD_ADDR_VAR 0 3
26962: PUSH
26963: LD_VAR 0 1
26967: PPUSH
26968: CALL_OW 274
26972: ST_TO_ADDR
// if not pom then
26973: LD_VAR 0 3
26977: NOT
26978: IFFALSE 26982
// exit ;
26980: GO 27152
// btype := GetBType ( building ) ;
26982: LD_ADDR_VAR 0 5
26986: PUSH
26987: LD_VAR 0 1
26991: PPUSH
26992: CALL_OW 266
26996: ST_TO_ADDR
// if btype = b_armoury then
26997: LD_VAR 0 5
27001: PUSH
27002: LD_INT 4
27004: EQUAL
27005: IFFALSE 27015
// btype := b_barracks ;
27007: LD_ADDR_VAR 0 5
27011: PUSH
27012: LD_INT 5
27014: ST_TO_ADDR
// if btype = b_depot then
27015: LD_VAR 0 5
27019: PUSH
27020: LD_INT 0
27022: EQUAL
27023: IFFALSE 27033
// btype := b_warehouse ;
27025: LD_ADDR_VAR 0 5
27029: PUSH
27030: LD_INT 1
27032: ST_TO_ADDR
// if btype = b_workshop then
27033: LD_VAR 0 5
27037: PUSH
27038: LD_INT 2
27040: EQUAL
27041: IFFALSE 27051
// btype := b_factory ;
27043: LD_ADDR_VAR 0 5
27047: PUSH
27048: LD_INT 3
27050: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27051: LD_ADDR_VAR 0 4
27055: PUSH
27056: LD_VAR 0 5
27060: PPUSH
27061: LD_VAR 0 1
27065: PPUSH
27066: CALL_OW 248
27070: PPUSH
27071: CALL_OW 450
27075: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27076: LD_ADDR_VAR 0 2
27080: PUSH
27081: LD_VAR 0 3
27085: PPUSH
27086: LD_INT 1
27088: PPUSH
27089: CALL_OW 275
27093: PUSH
27094: LD_VAR 0 4
27098: PUSH
27099: LD_INT 1
27101: ARRAY
27102: GREATEREQUAL
27103: PUSH
27104: LD_VAR 0 3
27108: PPUSH
27109: LD_INT 2
27111: PPUSH
27112: CALL_OW 275
27116: PUSH
27117: LD_VAR 0 4
27121: PUSH
27122: LD_INT 2
27124: ARRAY
27125: GREATEREQUAL
27126: AND
27127: PUSH
27128: LD_VAR 0 3
27132: PPUSH
27133: LD_INT 3
27135: PPUSH
27136: CALL_OW 275
27140: PUSH
27141: LD_VAR 0 4
27145: PUSH
27146: LD_INT 3
27148: ARRAY
27149: GREATEREQUAL
27150: AND
27151: ST_TO_ADDR
// end ;
27152: LD_VAR 0 2
27156: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
27157: LD_INT 0
27159: PPUSH
27160: PPUSH
27161: PPUSH
// pom := GetBase ( building ) ;
27162: LD_ADDR_VAR 0 4
27166: PUSH
27167: LD_VAR 0 1
27171: PPUSH
27172: CALL_OW 274
27176: ST_TO_ADDR
// if not pom then
27177: LD_VAR 0 4
27181: NOT
27182: IFFALSE 27186
// exit ;
27184: GO 27287
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27186: LD_ADDR_VAR 0 5
27190: PUSH
27191: LD_VAR 0 2
27195: PPUSH
27196: LD_VAR 0 1
27200: PPUSH
27201: CALL_OW 248
27205: PPUSH
27206: CALL_OW 450
27210: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27211: LD_ADDR_VAR 0 3
27215: PUSH
27216: LD_VAR 0 4
27220: PPUSH
27221: LD_INT 1
27223: PPUSH
27224: CALL_OW 275
27228: PUSH
27229: LD_VAR 0 5
27233: PUSH
27234: LD_INT 1
27236: ARRAY
27237: GREATEREQUAL
27238: PUSH
27239: LD_VAR 0 4
27243: PPUSH
27244: LD_INT 2
27246: PPUSH
27247: CALL_OW 275
27251: PUSH
27252: LD_VAR 0 5
27256: PUSH
27257: LD_INT 2
27259: ARRAY
27260: GREATEREQUAL
27261: AND
27262: PUSH
27263: LD_VAR 0 4
27267: PPUSH
27268: LD_INT 3
27270: PPUSH
27271: CALL_OW 275
27275: PUSH
27276: LD_VAR 0 5
27280: PUSH
27281: LD_INT 3
27283: ARRAY
27284: GREATEREQUAL
27285: AND
27286: ST_TO_ADDR
// end ;
27287: LD_VAR 0 3
27291: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
27292: LD_INT 0
27294: PPUSH
27295: PPUSH
27296: PPUSH
27297: PPUSH
27298: PPUSH
27299: PPUSH
27300: PPUSH
27301: PPUSH
27302: PPUSH
27303: PPUSH
27304: PPUSH
// result := false ;
27305: LD_ADDR_VAR 0 8
27309: PUSH
27310: LD_INT 0
27312: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
27313: LD_VAR 0 5
27317: NOT
27318: PUSH
27319: LD_VAR 0 1
27323: NOT
27324: OR
27325: PUSH
27326: LD_VAR 0 2
27330: NOT
27331: OR
27332: PUSH
27333: LD_VAR 0 3
27337: NOT
27338: OR
27339: IFFALSE 27343
// exit ;
27341: GO 28157
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
27343: LD_ADDR_VAR 0 14
27347: PUSH
27348: LD_VAR 0 1
27352: PPUSH
27353: LD_VAR 0 2
27357: PPUSH
27358: LD_VAR 0 3
27362: PPUSH
27363: LD_VAR 0 4
27367: PPUSH
27368: LD_VAR 0 5
27372: PUSH
27373: LD_INT 1
27375: ARRAY
27376: PPUSH
27377: CALL_OW 248
27381: PPUSH
27382: LD_INT 0
27384: PPUSH
27385: CALL 29390 0 6
27389: ST_TO_ADDR
// if not hexes then
27390: LD_VAR 0 14
27394: NOT
27395: IFFALSE 27399
// exit ;
27397: GO 28157
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27399: LD_ADDR_VAR 0 17
27403: PUSH
27404: LD_VAR 0 5
27408: PPUSH
27409: LD_INT 22
27411: PUSH
27412: LD_VAR 0 13
27416: PPUSH
27417: CALL_OW 255
27421: PUSH
27422: EMPTY
27423: LIST
27424: LIST
27425: PUSH
27426: LD_INT 2
27428: PUSH
27429: LD_INT 30
27431: PUSH
27432: LD_INT 0
27434: PUSH
27435: EMPTY
27436: LIST
27437: LIST
27438: PUSH
27439: LD_INT 30
27441: PUSH
27442: LD_INT 1
27444: PUSH
27445: EMPTY
27446: LIST
27447: LIST
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: LIST
27453: PUSH
27454: EMPTY
27455: LIST
27456: LIST
27457: PPUSH
27458: CALL_OW 72
27462: ST_TO_ADDR
// for i = 1 to hexes do
27463: LD_ADDR_VAR 0 9
27467: PUSH
27468: DOUBLE
27469: LD_INT 1
27471: DEC
27472: ST_TO_ADDR
27473: LD_VAR 0 14
27477: PUSH
27478: FOR_TO
27479: IFFALSE 28155
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27481: LD_ADDR_VAR 0 13
27485: PUSH
27486: LD_VAR 0 14
27490: PUSH
27491: LD_VAR 0 9
27495: ARRAY
27496: PUSH
27497: LD_INT 1
27499: ARRAY
27500: PPUSH
27501: LD_VAR 0 14
27505: PUSH
27506: LD_VAR 0 9
27510: ARRAY
27511: PUSH
27512: LD_INT 2
27514: ARRAY
27515: PPUSH
27516: CALL_OW 428
27520: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27521: LD_VAR 0 14
27525: PUSH
27526: LD_VAR 0 9
27530: ARRAY
27531: PUSH
27532: LD_INT 1
27534: ARRAY
27535: PPUSH
27536: LD_VAR 0 14
27540: PUSH
27541: LD_VAR 0 9
27545: ARRAY
27546: PUSH
27547: LD_INT 2
27549: ARRAY
27550: PPUSH
27551: CALL_OW 351
27555: PUSH
27556: LD_VAR 0 14
27560: PUSH
27561: LD_VAR 0 9
27565: ARRAY
27566: PUSH
27567: LD_INT 1
27569: ARRAY
27570: PPUSH
27571: LD_VAR 0 14
27575: PUSH
27576: LD_VAR 0 9
27580: ARRAY
27581: PUSH
27582: LD_INT 2
27584: ARRAY
27585: PPUSH
27586: CALL_OW 488
27590: NOT
27591: OR
27592: PUSH
27593: LD_VAR 0 13
27597: PPUSH
27598: CALL_OW 247
27602: PUSH
27603: LD_INT 3
27605: EQUAL
27606: OR
27607: IFFALSE 27613
// exit ;
27609: POP
27610: POP
27611: GO 28157
// if not tmp then
27613: LD_VAR 0 13
27617: NOT
27618: IFFALSE 27622
// continue ;
27620: GO 27478
// result := true ;
27622: LD_ADDR_VAR 0 8
27626: PUSH
27627: LD_INT 1
27629: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
27630: LD_VAR 0 6
27634: PUSH
27635: LD_VAR 0 13
27639: PPUSH
27640: CALL_OW 247
27644: PUSH
27645: LD_INT 2
27647: EQUAL
27648: AND
27649: PUSH
27650: LD_VAR 0 13
27654: PPUSH
27655: CALL_OW 263
27659: PUSH
27660: LD_INT 1
27662: EQUAL
27663: AND
27664: IFFALSE 27828
// begin if IsDrivenBy ( tmp ) then
27666: LD_VAR 0 13
27670: PPUSH
27671: CALL_OW 311
27675: IFFALSE 27679
// continue ;
27677: GO 27478
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
27679: LD_VAR 0 6
27683: PPUSH
27684: LD_INT 3
27686: PUSH
27687: LD_INT 60
27689: PUSH
27690: EMPTY
27691: LIST
27692: PUSH
27693: EMPTY
27694: LIST
27695: LIST
27696: PUSH
27697: LD_INT 3
27699: PUSH
27700: LD_INT 55
27702: PUSH
27703: EMPTY
27704: LIST
27705: PUSH
27706: EMPTY
27707: LIST
27708: LIST
27709: PUSH
27710: EMPTY
27711: LIST
27712: LIST
27713: PPUSH
27714: CALL_OW 72
27718: IFFALSE 27826
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
27720: LD_ADDR_VAR 0 18
27724: PUSH
27725: LD_VAR 0 6
27729: PPUSH
27730: LD_INT 3
27732: PUSH
27733: LD_INT 60
27735: PUSH
27736: EMPTY
27737: LIST
27738: PUSH
27739: EMPTY
27740: LIST
27741: LIST
27742: PUSH
27743: LD_INT 3
27745: PUSH
27746: LD_INT 55
27748: PUSH
27749: EMPTY
27750: LIST
27751: PUSH
27752: EMPTY
27753: LIST
27754: LIST
27755: PUSH
27756: EMPTY
27757: LIST
27758: LIST
27759: PPUSH
27760: CALL_OW 72
27764: PUSH
27765: LD_INT 1
27767: ARRAY
27768: ST_TO_ADDR
// if IsInUnit ( driver ) then
27769: LD_VAR 0 18
27773: PPUSH
27774: CALL_OW 310
27778: IFFALSE 27789
// ComExit ( driver ) ;
27780: LD_VAR 0 18
27784: PPUSH
27785: CALL 53169 0 1
// AddComEnterUnit ( driver , tmp ) ;
27789: LD_VAR 0 18
27793: PPUSH
27794: LD_VAR 0 13
27798: PPUSH
27799: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
27803: LD_VAR 0 18
27807: PPUSH
27808: LD_VAR 0 7
27812: PPUSH
27813: CALL_OW 173
// AddComExitVehicle ( driver ) ;
27817: LD_VAR 0 18
27821: PPUSH
27822: CALL_OW 181
// end ; continue ;
27826: GO 27478
// end ; if not cleaners or not tmp in cleaners then
27828: LD_VAR 0 6
27832: NOT
27833: PUSH
27834: LD_VAR 0 13
27838: PUSH
27839: LD_VAR 0 6
27843: IN
27844: NOT
27845: OR
27846: IFFALSE 28153
// begin if dep then
27848: LD_VAR 0 17
27852: IFFALSE 27988
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27854: LD_ADDR_VAR 0 16
27858: PUSH
27859: LD_VAR 0 17
27863: PUSH
27864: LD_INT 1
27866: ARRAY
27867: PPUSH
27868: CALL_OW 250
27872: PPUSH
27873: LD_VAR 0 17
27877: PUSH
27878: LD_INT 1
27880: ARRAY
27881: PPUSH
27882: CALL_OW 254
27886: PPUSH
27887: LD_INT 5
27889: PPUSH
27890: CALL_OW 272
27894: PUSH
27895: LD_VAR 0 17
27899: PUSH
27900: LD_INT 1
27902: ARRAY
27903: PPUSH
27904: CALL_OW 251
27908: PPUSH
27909: LD_VAR 0 17
27913: PUSH
27914: LD_INT 1
27916: ARRAY
27917: PPUSH
27918: CALL_OW 254
27922: PPUSH
27923: LD_INT 5
27925: PPUSH
27926: CALL_OW 273
27930: PUSH
27931: EMPTY
27932: LIST
27933: LIST
27934: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27935: LD_VAR 0 16
27939: PUSH
27940: LD_INT 1
27942: ARRAY
27943: PPUSH
27944: LD_VAR 0 16
27948: PUSH
27949: LD_INT 2
27951: ARRAY
27952: PPUSH
27953: CALL_OW 488
27957: IFFALSE 27988
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27959: LD_VAR 0 13
27963: PPUSH
27964: LD_VAR 0 16
27968: PUSH
27969: LD_INT 1
27971: ARRAY
27972: PPUSH
27973: LD_VAR 0 16
27977: PUSH
27978: LD_INT 2
27980: ARRAY
27981: PPUSH
27982: CALL_OW 111
// continue ;
27986: GO 27478
// end ; end ; r := GetDir ( tmp ) ;
27988: LD_ADDR_VAR 0 15
27992: PUSH
27993: LD_VAR 0 13
27997: PPUSH
27998: CALL_OW 254
28002: ST_TO_ADDR
// if r = 5 then
28003: LD_VAR 0 15
28007: PUSH
28008: LD_INT 5
28010: EQUAL
28011: IFFALSE 28021
// r := 0 ;
28013: LD_ADDR_VAR 0 15
28017: PUSH
28018: LD_INT 0
28020: ST_TO_ADDR
// for j = r to 5 do
28021: LD_ADDR_VAR 0 10
28025: PUSH
28026: DOUBLE
28027: LD_VAR 0 15
28031: DEC
28032: ST_TO_ADDR
28033: LD_INT 5
28035: PUSH
28036: FOR_TO
28037: IFFALSE 28151
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
28039: LD_ADDR_VAR 0 11
28043: PUSH
28044: LD_VAR 0 13
28048: PPUSH
28049: CALL_OW 250
28053: PPUSH
28054: LD_VAR 0 10
28058: PPUSH
28059: LD_INT 2
28061: PPUSH
28062: CALL_OW 272
28066: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
28067: LD_ADDR_VAR 0 12
28071: PUSH
28072: LD_VAR 0 13
28076: PPUSH
28077: CALL_OW 251
28081: PPUSH
28082: LD_VAR 0 10
28086: PPUSH
28087: LD_INT 2
28089: PPUSH
28090: CALL_OW 273
28094: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28095: LD_VAR 0 11
28099: PPUSH
28100: LD_VAR 0 12
28104: PPUSH
28105: CALL_OW 488
28109: PUSH
28110: LD_VAR 0 11
28114: PPUSH
28115: LD_VAR 0 12
28119: PPUSH
28120: CALL_OW 428
28124: NOT
28125: AND
28126: IFFALSE 28149
// begin ComMoveXY ( tmp , _x , _y ) ;
28128: LD_VAR 0 13
28132: PPUSH
28133: LD_VAR 0 11
28137: PPUSH
28138: LD_VAR 0 12
28142: PPUSH
28143: CALL_OW 111
// break ;
28147: GO 28151
// end ; end ;
28149: GO 28036
28151: POP
28152: POP
// end ; end ;
28153: GO 27478
28155: POP
28156: POP
// end ;
28157: LD_VAR 0 8
28161: RET
// export function BuildingTechInvented ( side , btype ) ; begin
28162: LD_INT 0
28164: PPUSH
// result := true ;
28165: LD_ADDR_VAR 0 3
28169: PUSH
28170: LD_INT 1
28172: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
28173: LD_VAR 0 2
28177: PUSH
28178: LD_INT 24
28180: DOUBLE
28181: EQUAL
28182: IFTRUE 28192
28184: LD_INT 33
28186: DOUBLE
28187: EQUAL
28188: IFTRUE 28192
28190: GO 28217
28192: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
28193: LD_ADDR_VAR 0 3
28197: PUSH
28198: LD_INT 32
28200: PPUSH
28201: LD_VAR 0 1
28205: PPUSH
28206: CALL_OW 321
28210: PUSH
28211: LD_INT 2
28213: EQUAL
28214: ST_TO_ADDR
28215: GO 28533
28217: LD_INT 20
28219: DOUBLE
28220: EQUAL
28221: IFTRUE 28225
28223: GO 28250
28225: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
28226: LD_ADDR_VAR 0 3
28230: PUSH
28231: LD_INT 6
28233: PPUSH
28234: LD_VAR 0 1
28238: PPUSH
28239: CALL_OW 321
28243: PUSH
28244: LD_INT 2
28246: EQUAL
28247: ST_TO_ADDR
28248: GO 28533
28250: LD_INT 22
28252: DOUBLE
28253: EQUAL
28254: IFTRUE 28264
28256: LD_INT 36
28258: DOUBLE
28259: EQUAL
28260: IFTRUE 28264
28262: GO 28289
28264: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
28265: LD_ADDR_VAR 0 3
28269: PUSH
28270: LD_INT 15
28272: PPUSH
28273: LD_VAR 0 1
28277: PPUSH
28278: CALL_OW 321
28282: PUSH
28283: LD_INT 2
28285: EQUAL
28286: ST_TO_ADDR
28287: GO 28533
28289: LD_INT 30
28291: DOUBLE
28292: EQUAL
28293: IFTRUE 28297
28295: GO 28322
28297: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
28298: LD_ADDR_VAR 0 3
28302: PUSH
28303: LD_INT 20
28305: PPUSH
28306: LD_VAR 0 1
28310: PPUSH
28311: CALL_OW 321
28315: PUSH
28316: LD_INT 2
28318: EQUAL
28319: ST_TO_ADDR
28320: GO 28533
28322: LD_INT 28
28324: DOUBLE
28325: EQUAL
28326: IFTRUE 28336
28328: LD_INT 21
28330: DOUBLE
28331: EQUAL
28332: IFTRUE 28336
28334: GO 28361
28336: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
28337: LD_ADDR_VAR 0 3
28341: PUSH
28342: LD_INT 21
28344: PPUSH
28345: LD_VAR 0 1
28349: PPUSH
28350: CALL_OW 321
28354: PUSH
28355: LD_INT 2
28357: EQUAL
28358: ST_TO_ADDR
28359: GO 28533
28361: LD_INT 16
28363: DOUBLE
28364: EQUAL
28365: IFTRUE 28369
28367: GO 28394
28369: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
28370: LD_ADDR_VAR 0 3
28374: PUSH
28375: LD_INT 84
28377: PPUSH
28378: LD_VAR 0 1
28382: PPUSH
28383: CALL_OW 321
28387: PUSH
28388: LD_INT 2
28390: EQUAL
28391: ST_TO_ADDR
28392: GO 28533
28394: LD_INT 19
28396: DOUBLE
28397: EQUAL
28398: IFTRUE 28408
28400: LD_INT 23
28402: DOUBLE
28403: EQUAL
28404: IFTRUE 28408
28406: GO 28433
28408: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
28409: LD_ADDR_VAR 0 3
28413: PUSH
28414: LD_INT 83
28416: PPUSH
28417: LD_VAR 0 1
28421: PPUSH
28422: CALL_OW 321
28426: PUSH
28427: LD_INT 2
28429: EQUAL
28430: ST_TO_ADDR
28431: GO 28533
28433: LD_INT 17
28435: DOUBLE
28436: EQUAL
28437: IFTRUE 28441
28439: GO 28466
28441: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
28442: LD_ADDR_VAR 0 3
28446: PUSH
28447: LD_INT 39
28449: PPUSH
28450: LD_VAR 0 1
28454: PPUSH
28455: CALL_OW 321
28459: PUSH
28460: LD_INT 2
28462: EQUAL
28463: ST_TO_ADDR
28464: GO 28533
28466: LD_INT 18
28468: DOUBLE
28469: EQUAL
28470: IFTRUE 28474
28472: GO 28499
28474: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
28475: LD_ADDR_VAR 0 3
28479: PUSH
28480: LD_INT 40
28482: PPUSH
28483: LD_VAR 0 1
28487: PPUSH
28488: CALL_OW 321
28492: PUSH
28493: LD_INT 2
28495: EQUAL
28496: ST_TO_ADDR
28497: GO 28533
28499: LD_INT 27
28501: DOUBLE
28502: EQUAL
28503: IFTRUE 28507
28505: GO 28532
28507: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
28508: LD_ADDR_VAR 0 3
28512: PUSH
28513: LD_INT 35
28515: PPUSH
28516: LD_VAR 0 1
28520: PPUSH
28521: CALL_OW 321
28525: PUSH
28526: LD_INT 2
28528: EQUAL
28529: ST_TO_ADDR
28530: GO 28533
28532: POP
// end ;
28533: LD_VAR 0 3
28537: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
28538: LD_INT 0
28540: PPUSH
28541: PPUSH
28542: PPUSH
28543: PPUSH
28544: PPUSH
28545: PPUSH
28546: PPUSH
28547: PPUSH
28548: PPUSH
28549: PPUSH
28550: PPUSH
// result := false ;
28551: LD_ADDR_VAR 0 6
28555: PUSH
28556: LD_INT 0
28558: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28559: LD_VAR 0 1
28563: NOT
28564: PUSH
28565: LD_VAR 0 1
28569: PPUSH
28570: CALL_OW 266
28574: PUSH
28575: LD_INT 0
28577: PUSH
28578: LD_INT 1
28580: PUSH
28581: EMPTY
28582: LIST
28583: LIST
28584: IN
28585: NOT
28586: OR
28587: PUSH
28588: LD_VAR 0 2
28592: NOT
28593: OR
28594: PUSH
28595: LD_VAR 0 5
28599: PUSH
28600: LD_INT 0
28602: PUSH
28603: LD_INT 1
28605: PUSH
28606: LD_INT 2
28608: PUSH
28609: LD_INT 3
28611: PUSH
28612: LD_INT 4
28614: PUSH
28615: LD_INT 5
28617: PUSH
28618: EMPTY
28619: LIST
28620: LIST
28621: LIST
28622: LIST
28623: LIST
28624: LIST
28625: IN
28626: NOT
28627: OR
28628: PUSH
28629: LD_VAR 0 3
28633: PPUSH
28634: LD_VAR 0 4
28638: PPUSH
28639: CALL_OW 488
28643: NOT
28644: OR
28645: IFFALSE 28649
// exit ;
28647: GO 29385
// side := GetSide ( depot ) ;
28649: LD_ADDR_VAR 0 9
28653: PUSH
28654: LD_VAR 0 1
28658: PPUSH
28659: CALL_OW 255
28663: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
28664: LD_VAR 0 9
28668: PPUSH
28669: LD_VAR 0 2
28673: PPUSH
28674: CALL 28162 0 2
28678: NOT
28679: IFFALSE 28683
// exit ;
28681: GO 29385
// pom := GetBase ( depot ) ;
28683: LD_ADDR_VAR 0 10
28687: PUSH
28688: LD_VAR 0 1
28692: PPUSH
28693: CALL_OW 274
28697: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28698: LD_ADDR_VAR 0 11
28702: PUSH
28703: LD_VAR 0 2
28707: PPUSH
28708: LD_VAR 0 1
28712: PPUSH
28713: CALL_OW 248
28717: PPUSH
28718: CALL_OW 450
28722: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28723: LD_VAR 0 10
28727: PPUSH
28728: LD_INT 1
28730: PPUSH
28731: CALL_OW 275
28735: PUSH
28736: LD_VAR 0 11
28740: PUSH
28741: LD_INT 1
28743: ARRAY
28744: GREATEREQUAL
28745: PUSH
28746: LD_VAR 0 10
28750: PPUSH
28751: LD_INT 2
28753: PPUSH
28754: CALL_OW 275
28758: PUSH
28759: LD_VAR 0 11
28763: PUSH
28764: LD_INT 2
28766: ARRAY
28767: GREATEREQUAL
28768: AND
28769: PUSH
28770: LD_VAR 0 10
28774: PPUSH
28775: LD_INT 3
28777: PPUSH
28778: CALL_OW 275
28782: PUSH
28783: LD_VAR 0 11
28787: PUSH
28788: LD_INT 3
28790: ARRAY
28791: GREATEREQUAL
28792: AND
28793: NOT
28794: IFFALSE 28798
// exit ;
28796: GO 29385
// if GetBType ( depot ) = b_depot then
28798: LD_VAR 0 1
28802: PPUSH
28803: CALL_OW 266
28807: PUSH
28808: LD_INT 0
28810: EQUAL
28811: IFFALSE 28823
// dist := 28 else
28813: LD_ADDR_VAR 0 14
28817: PUSH
28818: LD_INT 28
28820: ST_TO_ADDR
28821: GO 28831
// dist := 36 ;
28823: LD_ADDR_VAR 0 14
28827: PUSH
28828: LD_INT 36
28830: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28831: LD_VAR 0 1
28835: PPUSH
28836: LD_VAR 0 3
28840: PPUSH
28841: LD_VAR 0 4
28845: PPUSH
28846: CALL_OW 297
28850: PUSH
28851: LD_VAR 0 14
28855: GREATER
28856: IFFALSE 28860
// exit ;
28858: GO 29385
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28860: LD_ADDR_VAR 0 12
28864: PUSH
28865: LD_VAR 0 2
28869: PPUSH
28870: LD_VAR 0 3
28874: PPUSH
28875: LD_VAR 0 4
28879: PPUSH
28880: LD_VAR 0 5
28884: PPUSH
28885: LD_VAR 0 1
28889: PPUSH
28890: CALL_OW 248
28894: PPUSH
28895: LD_INT 0
28897: PPUSH
28898: CALL 29390 0 6
28902: ST_TO_ADDR
// if not hexes then
28903: LD_VAR 0 12
28907: NOT
28908: IFFALSE 28912
// exit ;
28910: GO 29385
// hex := GetHexInfo ( x , y ) ;
28912: LD_ADDR_VAR 0 15
28916: PUSH
28917: LD_VAR 0 3
28921: PPUSH
28922: LD_VAR 0 4
28926: PPUSH
28927: CALL_OW 546
28931: ST_TO_ADDR
// if hex [ 1 ] then
28932: LD_VAR 0 15
28936: PUSH
28937: LD_INT 1
28939: ARRAY
28940: IFFALSE 28944
// exit ;
28942: GO 29385
// height := hex [ 2 ] ;
28944: LD_ADDR_VAR 0 13
28948: PUSH
28949: LD_VAR 0 15
28953: PUSH
28954: LD_INT 2
28956: ARRAY
28957: ST_TO_ADDR
// for i = 1 to hexes do
28958: LD_ADDR_VAR 0 7
28962: PUSH
28963: DOUBLE
28964: LD_INT 1
28966: DEC
28967: ST_TO_ADDR
28968: LD_VAR 0 12
28972: PUSH
28973: FOR_TO
28974: IFFALSE 29304
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28976: LD_VAR 0 12
28980: PUSH
28981: LD_VAR 0 7
28985: ARRAY
28986: PUSH
28987: LD_INT 1
28989: ARRAY
28990: PPUSH
28991: LD_VAR 0 12
28995: PUSH
28996: LD_VAR 0 7
29000: ARRAY
29001: PUSH
29002: LD_INT 2
29004: ARRAY
29005: PPUSH
29006: CALL_OW 488
29010: NOT
29011: PUSH
29012: LD_VAR 0 12
29016: PUSH
29017: LD_VAR 0 7
29021: ARRAY
29022: PUSH
29023: LD_INT 1
29025: ARRAY
29026: PPUSH
29027: LD_VAR 0 12
29031: PUSH
29032: LD_VAR 0 7
29036: ARRAY
29037: PUSH
29038: LD_INT 2
29040: ARRAY
29041: PPUSH
29042: CALL_OW 428
29046: PUSH
29047: LD_INT 0
29049: GREATER
29050: OR
29051: PUSH
29052: LD_VAR 0 12
29056: PUSH
29057: LD_VAR 0 7
29061: ARRAY
29062: PUSH
29063: LD_INT 1
29065: ARRAY
29066: PPUSH
29067: LD_VAR 0 12
29071: PUSH
29072: LD_VAR 0 7
29076: ARRAY
29077: PUSH
29078: LD_INT 2
29080: ARRAY
29081: PPUSH
29082: CALL_OW 351
29086: OR
29087: IFFALSE 29093
// exit ;
29089: POP
29090: POP
29091: GO 29385
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29093: LD_ADDR_VAR 0 8
29097: PUSH
29098: LD_VAR 0 12
29102: PUSH
29103: LD_VAR 0 7
29107: ARRAY
29108: PUSH
29109: LD_INT 1
29111: ARRAY
29112: PPUSH
29113: LD_VAR 0 12
29117: PUSH
29118: LD_VAR 0 7
29122: ARRAY
29123: PUSH
29124: LD_INT 2
29126: ARRAY
29127: PPUSH
29128: CALL_OW 546
29132: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
29133: LD_VAR 0 8
29137: PUSH
29138: LD_INT 1
29140: ARRAY
29141: PUSH
29142: LD_VAR 0 8
29146: PUSH
29147: LD_INT 2
29149: ARRAY
29150: PUSH
29151: LD_VAR 0 13
29155: PUSH
29156: LD_INT 2
29158: PLUS
29159: GREATER
29160: OR
29161: PUSH
29162: LD_VAR 0 8
29166: PUSH
29167: LD_INT 2
29169: ARRAY
29170: PUSH
29171: LD_VAR 0 13
29175: PUSH
29176: LD_INT 2
29178: MINUS
29179: LESS
29180: OR
29181: PUSH
29182: LD_VAR 0 8
29186: PUSH
29187: LD_INT 3
29189: ARRAY
29190: PUSH
29191: LD_INT 0
29193: PUSH
29194: LD_INT 8
29196: PUSH
29197: LD_INT 9
29199: PUSH
29200: LD_INT 10
29202: PUSH
29203: LD_INT 11
29205: PUSH
29206: LD_INT 12
29208: PUSH
29209: LD_INT 13
29211: PUSH
29212: LD_INT 16
29214: PUSH
29215: LD_INT 17
29217: PUSH
29218: LD_INT 18
29220: PUSH
29221: LD_INT 19
29223: PUSH
29224: LD_INT 20
29226: PUSH
29227: LD_INT 21
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: LIST
29234: LIST
29235: LIST
29236: LIST
29237: LIST
29238: LIST
29239: LIST
29240: LIST
29241: LIST
29242: LIST
29243: LIST
29244: IN
29245: NOT
29246: OR
29247: PUSH
29248: LD_VAR 0 8
29252: PUSH
29253: LD_INT 5
29255: ARRAY
29256: NOT
29257: OR
29258: PUSH
29259: LD_VAR 0 8
29263: PUSH
29264: LD_INT 6
29266: ARRAY
29267: PUSH
29268: LD_INT 1
29270: PUSH
29271: LD_INT 2
29273: PUSH
29274: LD_INT 7
29276: PUSH
29277: LD_INT 9
29279: PUSH
29280: LD_INT 10
29282: PUSH
29283: LD_INT 11
29285: PUSH
29286: EMPTY
29287: LIST
29288: LIST
29289: LIST
29290: LIST
29291: LIST
29292: LIST
29293: IN
29294: NOT
29295: OR
29296: IFFALSE 29302
// exit ;
29298: POP
29299: POP
29300: GO 29385
// end ;
29302: GO 28973
29304: POP
29305: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
29306: LD_VAR 0 9
29310: PPUSH
29311: LD_VAR 0 3
29315: PPUSH
29316: LD_VAR 0 4
29320: PPUSH
29321: LD_INT 20
29323: PPUSH
29324: CALL 21337 0 4
29328: PUSH
29329: LD_INT 4
29331: ARRAY
29332: IFFALSE 29336
// exit ;
29334: GO 29385
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
29336: LD_VAR 0 2
29340: PUSH
29341: LD_INT 29
29343: PUSH
29344: LD_INT 30
29346: PUSH
29347: EMPTY
29348: LIST
29349: LIST
29350: IN
29351: PUSH
29352: LD_VAR 0 3
29356: PPUSH
29357: LD_VAR 0 4
29361: PPUSH
29362: LD_VAR 0 9
29366: PPUSH
29367: CALL_OW 440
29371: NOT
29372: AND
29373: IFFALSE 29377
// exit ;
29375: GO 29385
// result := true ;
29377: LD_ADDR_VAR 0 6
29381: PUSH
29382: LD_INT 1
29384: ST_TO_ADDR
// end ;
29385: LD_VAR 0 6
29389: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
29390: LD_INT 0
29392: PPUSH
29393: PPUSH
29394: PPUSH
29395: PPUSH
29396: PPUSH
29397: PPUSH
29398: PPUSH
29399: PPUSH
29400: PPUSH
29401: PPUSH
29402: PPUSH
29403: PPUSH
29404: PPUSH
29405: PPUSH
29406: PPUSH
29407: PPUSH
29408: PPUSH
29409: PPUSH
29410: PPUSH
29411: PPUSH
29412: PPUSH
29413: PPUSH
29414: PPUSH
29415: PPUSH
29416: PPUSH
29417: PPUSH
29418: PPUSH
29419: PPUSH
29420: PPUSH
29421: PPUSH
29422: PPUSH
29423: PPUSH
29424: PPUSH
29425: PPUSH
29426: PPUSH
29427: PPUSH
29428: PPUSH
29429: PPUSH
29430: PPUSH
29431: PPUSH
29432: PPUSH
29433: PPUSH
29434: PPUSH
29435: PPUSH
29436: PPUSH
29437: PPUSH
29438: PPUSH
29439: PPUSH
29440: PPUSH
29441: PPUSH
29442: PPUSH
29443: PPUSH
29444: PPUSH
29445: PPUSH
29446: PPUSH
29447: PPUSH
29448: PPUSH
29449: PPUSH
// result = [ ] ;
29450: LD_ADDR_VAR 0 7
29454: PUSH
29455: EMPTY
29456: ST_TO_ADDR
// temp_list = [ ] ;
29457: LD_ADDR_VAR 0 9
29461: PUSH
29462: EMPTY
29463: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29464: LD_VAR 0 4
29468: PUSH
29469: LD_INT 0
29471: PUSH
29472: LD_INT 1
29474: PUSH
29475: LD_INT 2
29477: PUSH
29478: LD_INT 3
29480: PUSH
29481: LD_INT 4
29483: PUSH
29484: LD_INT 5
29486: PUSH
29487: EMPTY
29488: LIST
29489: LIST
29490: LIST
29491: LIST
29492: LIST
29493: LIST
29494: IN
29495: NOT
29496: PUSH
29497: LD_VAR 0 1
29501: PUSH
29502: LD_INT 0
29504: PUSH
29505: LD_INT 1
29507: PUSH
29508: EMPTY
29509: LIST
29510: LIST
29511: IN
29512: PUSH
29513: LD_VAR 0 5
29517: PUSH
29518: LD_INT 1
29520: PUSH
29521: LD_INT 2
29523: PUSH
29524: LD_INT 3
29526: PUSH
29527: EMPTY
29528: LIST
29529: LIST
29530: LIST
29531: IN
29532: NOT
29533: AND
29534: OR
29535: IFFALSE 29539
// exit ;
29537: GO 47930
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29539: LD_VAR 0 1
29543: PUSH
29544: LD_INT 6
29546: PUSH
29547: LD_INT 7
29549: PUSH
29550: LD_INT 8
29552: PUSH
29553: LD_INT 13
29555: PUSH
29556: LD_INT 12
29558: PUSH
29559: LD_INT 15
29561: PUSH
29562: LD_INT 11
29564: PUSH
29565: LD_INT 14
29567: PUSH
29568: LD_INT 10
29570: PUSH
29571: EMPTY
29572: LIST
29573: LIST
29574: LIST
29575: LIST
29576: LIST
29577: LIST
29578: LIST
29579: LIST
29580: LIST
29581: IN
29582: IFFALSE 29592
// btype = b_lab ;
29584: LD_ADDR_VAR 0 1
29588: PUSH
29589: LD_INT 6
29591: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29592: LD_VAR 0 6
29596: PUSH
29597: LD_INT 0
29599: PUSH
29600: LD_INT 1
29602: PUSH
29603: LD_INT 2
29605: PUSH
29606: EMPTY
29607: LIST
29608: LIST
29609: LIST
29610: IN
29611: NOT
29612: PUSH
29613: LD_VAR 0 1
29617: PUSH
29618: LD_INT 0
29620: PUSH
29621: LD_INT 1
29623: PUSH
29624: LD_INT 2
29626: PUSH
29627: LD_INT 3
29629: PUSH
29630: LD_INT 6
29632: PUSH
29633: LD_INT 36
29635: PUSH
29636: LD_INT 4
29638: PUSH
29639: LD_INT 5
29641: PUSH
29642: LD_INT 31
29644: PUSH
29645: LD_INT 32
29647: PUSH
29648: LD_INT 33
29650: PUSH
29651: EMPTY
29652: LIST
29653: LIST
29654: LIST
29655: LIST
29656: LIST
29657: LIST
29658: LIST
29659: LIST
29660: LIST
29661: LIST
29662: LIST
29663: IN
29664: NOT
29665: PUSH
29666: LD_VAR 0 6
29670: PUSH
29671: LD_INT 1
29673: EQUAL
29674: AND
29675: OR
29676: PUSH
29677: LD_VAR 0 1
29681: PUSH
29682: LD_INT 2
29684: PUSH
29685: LD_INT 3
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: IN
29692: NOT
29693: PUSH
29694: LD_VAR 0 6
29698: PUSH
29699: LD_INT 2
29701: EQUAL
29702: AND
29703: OR
29704: IFFALSE 29714
// mode = 0 ;
29706: LD_ADDR_VAR 0 6
29710: PUSH
29711: LD_INT 0
29713: ST_TO_ADDR
// case mode of 0 :
29714: LD_VAR 0 6
29718: PUSH
29719: LD_INT 0
29721: DOUBLE
29722: EQUAL
29723: IFTRUE 29727
29725: GO 41180
29727: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29728: LD_ADDR_VAR 0 11
29732: PUSH
29733: LD_INT 0
29735: PUSH
29736: LD_INT 0
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: LD_INT 0
29745: PUSH
29746: LD_INT 1
29748: NEG
29749: PUSH
29750: EMPTY
29751: LIST
29752: LIST
29753: PUSH
29754: LD_INT 1
29756: PUSH
29757: LD_INT 0
29759: PUSH
29760: EMPTY
29761: LIST
29762: LIST
29763: PUSH
29764: LD_INT 1
29766: PUSH
29767: LD_INT 1
29769: PUSH
29770: EMPTY
29771: LIST
29772: LIST
29773: PUSH
29774: LD_INT 0
29776: PUSH
29777: LD_INT 1
29779: PUSH
29780: EMPTY
29781: LIST
29782: LIST
29783: PUSH
29784: LD_INT 1
29786: NEG
29787: PUSH
29788: LD_INT 0
29790: PUSH
29791: EMPTY
29792: LIST
29793: LIST
29794: PUSH
29795: LD_INT 1
29797: NEG
29798: PUSH
29799: LD_INT 1
29801: NEG
29802: PUSH
29803: EMPTY
29804: LIST
29805: LIST
29806: PUSH
29807: LD_INT 1
29809: NEG
29810: PUSH
29811: LD_INT 2
29813: NEG
29814: PUSH
29815: EMPTY
29816: LIST
29817: LIST
29818: PUSH
29819: LD_INT 0
29821: PUSH
29822: LD_INT 2
29824: NEG
29825: PUSH
29826: EMPTY
29827: LIST
29828: LIST
29829: PUSH
29830: LD_INT 1
29832: PUSH
29833: LD_INT 1
29835: NEG
29836: PUSH
29837: EMPTY
29838: LIST
29839: LIST
29840: PUSH
29841: LD_INT 1
29843: PUSH
29844: LD_INT 2
29846: PUSH
29847: EMPTY
29848: LIST
29849: LIST
29850: PUSH
29851: LD_INT 0
29853: PUSH
29854: LD_INT 2
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: PUSH
29861: LD_INT 1
29863: NEG
29864: PUSH
29865: LD_INT 1
29867: PUSH
29868: EMPTY
29869: LIST
29870: LIST
29871: PUSH
29872: LD_INT 1
29874: PUSH
29875: LD_INT 3
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: LD_INT 0
29884: PUSH
29885: LD_INT 3
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: PUSH
29892: LD_INT 1
29894: NEG
29895: PUSH
29896: LD_INT 2
29898: PUSH
29899: EMPTY
29900: LIST
29901: LIST
29902: PUSH
29903: EMPTY
29904: LIST
29905: LIST
29906: LIST
29907: LIST
29908: LIST
29909: LIST
29910: LIST
29911: LIST
29912: LIST
29913: LIST
29914: LIST
29915: LIST
29916: LIST
29917: LIST
29918: LIST
29919: LIST
29920: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29921: LD_ADDR_VAR 0 12
29925: PUSH
29926: LD_INT 0
29928: PUSH
29929: LD_INT 0
29931: PUSH
29932: EMPTY
29933: LIST
29934: LIST
29935: PUSH
29936: LD_INT 0
29938: PUSH
29939: LD_INT 1
29941: NEG
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: LD_INT 1
29949: PUSH
29950: LD_INT 0
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: PUSH
29957: LD_INT 1
29959: PUSH
29960: LD_INT 1
29962: PUSH
29963: EMPTY
29964: LIST
29965: LIST
29966: PUSH
29967: LD_INT 0
29969: PUSH
29970: LD_INT 1
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: PUSH
29977: LD_INT 1
29979: NEG
29980: PUSH
29981: LD_INT 0
29983: PUSH
29984: EMPTY
29985: LIST
29986: LIST
29987: PUSH
29988: LD_INT 1
29990: NEG
29991: PUSH
29992: LD_INT 1
29994: NEG
29995: PUSH
29996: EMPTY
29997: LIST
29998: LIST
29999: PUSH
30000: LD_INT 1
30002: PUSH
30003: LD_INT 1
30005: NEG
30006: PUSH
30007: EMPTY
30008: LIST
30009: LIST
30010: PUSH
30011: LD_INT 2
30013: PUSH
30014: LD_INT 0
30016: PUSH
30017: EMPTY
30018: LIST
30019: LIST
30020: PUSH
30021: LD_INT 2
30023: PUSH
30024: LD_INT 1
30026: PUSH
30027: EMPTY
30028: LIST
30029: LIST
30030: PUSH
30031: LD_INT 1
30033: NEG
30034: PUSH
30035: LD_INT 1
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: LD_INT 2
30044: NEG
30045: PUSH
30046: LD_INT 0
30048: PUSH
30049: EMPTY
30050: LIST
30051: LIST
30052: PUSH
30053: LD_INT 2
30055: NEG
30056: PUSH
30057: LD_INT 1
30059: NEG
30060: PUSH
30061: EMPTY
30062: LIST
30063: LIST
30064: PUSH
30065: LD_INT 2
30067: NEG
30068: PUSH
30069: LD_INT 1
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PUSH
30076: LD_INT 3
30078: NEG
30079: PUSH
30080: LD_INT 0
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: PUSH
30087: LD_INT 3
30089: NEG
30090: PUSH
30091: LD_INT 1
30093: NEG
30094: PUSH
30095: EMPTY
30096: LIST
30097: LIST
30098: PUSH
30099: EMPTY
30100: LIST
30101: LIST
30102: LIST
30103: LIST
30104: LIST
30105: LIST
30106: LIST
30107: LIST
30108: LIST
30109: LIST
30110: LIST
30111: LIST
30112: LIST
30113: LIST
30114: LIST
30115: LIST
30116: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30117: LD_ADDR_VAR 0 13
30121: PUSH
30122: LD_INT 0
30124: PUSH
30125: LD_INT 0
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PUSH
30132: LD_INT 0
30134: PUSH
30135: LD_INT 1
30137: NEG
30138: PUSH
30139: EMPTY
30140: LIST
30141: LIST
30142: PUSH
30143: LD_INT 1
30145: PUSH
30146: LD_INT 0
30148: PUSH
30149: EMPTY
30150: LIST
30151: LIST
30152: PUSH
30153: LD_INT 1
30155: PUSH
30156: LD_INT 1
30158: PUSH
30159: EMPTY
30160: LIST
30161: LIST
30162: PUSH
30163: LD_INT 0
30165: PUSH
30166: LD_INT 1
30168: PUSH
30169: EMPTY
30170: LIST
30171: LIST
30172: PUSH
30173: LD_INT 1
30175: NEG
30176: PUSH
30177: LD_INT 0
30179: PUSH
30180: EMPTY
30181: LIST
30182: LIST
30183: PUSH
30184: LD_INT 1
30186: NEG
30187: PUSH
30188: LD_INT 1
30190: NEG
30191: PUSH
30192: EMPTY
30193: LIST
30194: LIST
30195: PUSH
30196: LD_INT 1
30198: NEG
30199: PUSH
30200: LD_INT 2
30202: NEG
30203: PUSH
30204: EMPTY
30205: LIST
30206: LIST
30207: PUSH
30208: LD_INT 2
30210: PUSH
30211: LD_INT 1
30213: PUSH
30214: EMPTY
30215: LIST
30216: LIST
30217: PUSH
30218: LD_INT 2
30220: PUSH
30221: LD_INT 2
30223: PUSH
30224: EMPTY
30225: LIST
30226: LIST
30227: PUSH
30228: LD_INT 1
30230: PUSH
30231: LD_INT 2
30233: PUSH
30234: EMPTY
30235: LIST
30236: LIST
30237: PUSH
30238: LD_INT 2
30240: NEG
30241: PUSH
30242: LD_INT 1
30244: NEG
30245: PUSH
30246: EMPTY
30247: LIST
30248: LIST
30249: PUSH
30250: LD_INT 2
30252: NEG
30253: PUSH
30254: LD_INT 2
30256: NEG
30257: PUSH
30258: EMPTY
30259: LIST
30260: LIST
30261: PUSH
30262: LD_INT 2
30264: NEG
30265: PUSH
30266: LD_INT 3
30268: NEG
30269: PUSH
30270: EMPTY
30271: LIST
30272: LIST
30273: PUSH
30274: LD_INT 3
30276: NEG
30277: PUSH
30278: LD_INT 2
30280: NEG
30281: PUSH
30282: EMPTY
30283: LIST
30284: LIST
30285: PUSH
30286: LD_INT 3
30288: NEG
30289: PUSH
30290: LD_INT 3
30292: NEG
30293: PUSH
30294: EMPTY
30295: LIST
30296: LIST
30297: PUSH
30298: EMPTY
30299: LIST
30300: LIST
30301: LIST
30302: LIST
30303: LIST
30304: LIST
30305: LIST
30306: LIST
30307: LIST
30308: LIST
30309: LIST
30310: LIST
30311: LIST
30312: LIST
30313: LIST
30314: LIST
30315: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
30316: LD_ADDR_VAR 0 14
30320: PUSH
30321: LD_INT 0
30323: PUSH
30324: LD_INT 0
30326: PUSH
30327: EMPTY
30328: LIST
30329: LIST
30330: PUSH
30331: LD_INT 0
30333: PUSH
30334: LD_INT 1
30336: NEG
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PUSH
30342: LD_INT 1
30344: PUSH
30345: LD_INT 0
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: LD_INT 1
30354: PUSH
30355: LD_INT 1
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: PUSH
30362: LD_INT 0
30364: PUSH
30365: LD_INT 1
30367: PUSH
30368: EMPTY
30369: LIST
30370: LIST
30371: PUSH
30372: LD_INT 1
30374: NEG
30375: PUSH
30376: LD_INT 0
30378: PUSH
30379: EMPTY
30380: LIST
30381: LIST
30382: PUSH
30383: LD_INT 1
30385: NEG
30386: PUSH
30387: LD_INT 1
30389: NEG
30390: PUSH
30391: EMPTY
30392: LIST
30393: LIST
30394: PUSH
30395: LD_INT 1
30397: NEG
30398: PUSH
30399: LD_INT 2
30401: NEG
30402: PUSH
30403: EMPTY
30404: LIST
30405: LIST
30406: PUSH
30407: LD_INT 0
30409: PUSH
30410: LD_INT 2
30412: NEG
30413: PUSH
30414: EMPTY
30415: LIST
30416: LIST
30417: PUSH
30418: LD_INT 1
30420: PUSH
30421: LD_INT 1
30423: NEG
30424: PUSH
30425: EMPTY
30426: LIST
30427: LIST
30428: PUSH
30429: LD_INT 1
30431: PUSH
30432: LD_INT 2
30434: PUSH
30435: EMPTY
30436: LIST
30437: LIST
30438: PUSH
30439: LD_INT 0
30441: PUSH
30442: LD_INT 2
30444: PUSH
30445: EMPTY
30446: LIST
30447: LIST
30448: PUSH
30449: LD_INT 1
30451: NEG
30452: PUSH
30453: LD_INT 1
30455: PUSH
30456: EMPTY
30457: LIST
30458: LIST
30459: PUSH
30460: LD_INT 1
30462: NEG
30463: PUSH
30464: LD_INT 3
30466: NEG
30467: PUSH
30468: EMPTY
30469: LIST
30470: LIST
30471: PUSH
30472: LD_INT 0
30474: PUSH
30475: LD_INT 3
30477: NEG
30478: PUSH
30479: EMPTY
30480: LIST
30481: LIST
30482: PUSH
30483: LD_INT 1
30485: PUSH
30486: LD_INT 2
30488: NEG
30489: PUSH
30490: EMPTY
30491: LIST
30492: LIST
30493: PUSH
30494: EMPTY
30495: LIST
30496: LIST
30497: LIST
30498: LIST
30499: LIST
30500: LIST
30501: LIST
30502: LIST
30503: LIST
30504: LIST
30505: LIST
30506: LIST
30507: LIST
30508: LIST
30509: LIST
30510: LIST
30511: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30512: LD_ADDR_VAR 0 15
30516: PUSH
30517: LD_INT 0
30519: PUSH
30520: LD_INT 0
30522: PUSH
30523: EMPTY
30524: LIST
30525: LIST
30526: PUSH
30527: LD_INT 0
30529: PUSH
30530: LD_INT 1
30532: NEG
30533: PUSH
30534: EMPTY
30535: LIST
30536: LIST
30537: PUSH
30538: LD_INT 1
30540: PUSH
30541: LD_INT 0
30543: PUSH
30544: EMPTY
30545: LIST
30546: LIST
30547: PUSH
30548: LD_INT 1
30550: PUSH
30551: LD_INT 1
30553: PUSH
30554: EMPTY
30555: LIST
30556: LIST
30557: PUSH
30558: LD_INT 0
30560: PUSH
30561: LD_INT 1
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 1
30570: NEG
30571: PUSH
30572: LD_INT 0
30574: PUSH
30575: EMPTY
30576: LIST
30577: LIST
30578: PUSH
30579: LD_INT 1
30581: NEG
30582: PUSH
30583: LD_INT 1
30585: NEG
30586: PUSH
30587: EMPTY
30588: LIST
30589: LIST
30590: PUSH
30591: LD_INT 1
30593: PUSH
30594: LD_INT 1
30596: NEG
30597: PUSH
30598: EMPTY
30599: LIST
30600: LIST
30601: PUSH
30602: LD_INT 2
30604: PUSH
30605: LD_INT 0
30607: PUSH
30608: EMPTY
30609: LIST
30610: LIST
30611: PUSH
30612: LD_INT 2
30614: PUSH
30615: LD_INT 1
30617: PUSH
30618: EMPTY
30619: LIST
30620: LIST
30621: PUSH
30622: LD_INT 1
30624: NEG
30625: PUSH
30626: LD_INT 1
30628: PUSH
30629: EMPTY
30630: LIST
30631: LIST
30632: PUSH
30633: LD_INT 2
30635: NEG
30636: PUSH
30637: LD_INT 0
30639: PUSH
30640: EMPTY
30641: LIST
30642: LIST
30643: PUSH
30644: LD_INT 2
30646: NEG
30647: PUSH
30648: LD_INT 1
30650: NEG
30651: PUSH
30652: EMPTY
30653: LIST
30654: LIST
30655: PUSH
30656: LD_INT 2
30658: PUSH
30659: LD_INT 1
30661: NEG
30662: PUSH
30663: EMPTY
30664: LIST
30665: LIST
30666: PUSH
30667: LD_INT 3
30669: PUSH
30670: LD_INT 0
30672: PUSH
30673: EMPTY
30674: LIST
30675: LIST
30676: PUSH
30677: LD_INT 3
30679: PUSH
30680: LD_INT 1
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PUSH
30687: EMPTY
30688: LIST
30689: LIST
30690: LIST
30691: LIST
30692: LIST
30693: LIST
30694: LIST
30695: LIST
30696: LIST
30697: LIST
30698: LIST
30699: LIST
30700: LIST
30701: LIST
30702: LIST
30703: LIST
30704: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30705: LD_ADDR_VAR 0 16
30709: PUSH
30710: LD_INT 0
30712: PUSH
30713: LD_INT 0
30715: PUSH
30716: EMPTY
30717: LIST
30718: LIST
30719: PUSH
30720: LD_INT 0
30722: PUSH
30723: LD_INT 1
30725: NEG
30726: PUSH
30727: EMPTY
30728: LIST
30729: LIST
30730: PUSH
30731: LD_INT 1
30733: PUSH
30734: LD_INT 0
30736: PUSH
30737: EMPTY
30738: LIST
30739: LIST
30740: PUSH
30741: LD_INT 1
30743: PUSH
30744: LD_INT 1
30746: PUSH
30747: EMPTY
30748: LIST
30749: LIST
30750: PUSH
30751: LD_INT 0
30753: PUSH
30754: LD_INT 1
30756: PUSH
30757: EMPTY
30758: LIST
30759: LIST
30760: PUSH
30761: LD_INT 1
30763: NEG
30764: PUSH
30765: LD_INT 0
30767: PUSH
30768: EMPTY
30769: LIST
30770: LIST
30771: PUSH
30772: LD_INT 1
30774: NEG
30775: PUSH
30776: LD_INT 1
30778: NEG
30779: PUSH
30780: EMPTY
30781: LIST
30782: LIST
30783: PUSH
30784: LD_INT 1
30786: NEG
30787: PUSH
30788: LD_INT 2
30790: NEG
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: PUSH
30796: LD_INT 2
30798: PUSH
30799: LD_INT 1
30801: PUSH
30802: EMPTY
30803: LIST
30804: LIST
30805: PUSH
30806: LD_INT 2
30808: PUSH
30809: LD_INT 2
30811: PUSH
30812: EMPTY
30813: LIST
30814: LIST
30815: PUSH
30816: LD_INT 1
30818: PUSH
30819: LD_INT 2
30821: PUSH
30822: EMPTY
30823: LIST
30824: LIST
30825: PUSH
30826: LD_INT 2
30828: NEG
30829: PUSH
30830: LD_INT 1
30832: NEG
30833: PUSH
30834: EMPTY
30835: LIST
30836: LIST
30837: PUSH
30838: LD_INT 2
30840: NEG
30841: PUSH
30842: LD_INT 2
30844: NEG
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 3
30852: PUSH
30853: LD_INT 2
30855: PUSH
30856: EMPTY
30857: LIST
30858: LIST
30859: PUSH
30860: LD_INT 3
30862: PUSH
30863: LD_INT 3
30865: PUSH
30866: EMPTY
30867: LIST
30868: LIST
30869: PUSH
30870: LD_INT 2
30872: PUSH
30873: LD_INT 3
30875: PUSH
30876: EMPTY
30877: LIST
30878: LIST
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: LIST
30884: LIST
30885: LIST
30886: LIST
30887: LIST
30888: LIST
30889: LIST
30890: LIST
30891: LIST
30892: LIST
30893: LIST
30894: LIST
30895: LIST
30896: LIST
30897: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30898: LD_ADDR_VAR 0 17
30902: PUSH
30903: LD_INT 0
30905: PUSH
30906: LD_INT 0
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: LD_INT 0
30915: PUSH
30916: LD_INT 1
30918: NEG
30919: PUSH
30920: EMPTY
30921: LIST
30922: LIST
30923: PUSH
30924: LD_INT 1
30926: PUSH
30927: LD_INT 0
30929: PUSH
30930: EMPTY
30931: LIST
30932: LIST
30933: PUSH
30934: LD_INT 1
30936: PUSH
30937: LD_INT 1
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: PUSH
30944: LD_INT 0
30946: PUSH
30947: LD_INT 1
30949: PUSH
30950: EMPTY
30951: LIST
30952: LIST
30953: PUSH
30954: LD_INT 1
30956: NEG
30957: PUSH
30958: LD_INT 0
30960: PUSH
30961: EMPTY
30962: LIST
30963: LIST
30964: PUSH
30965: LD_INT 1
30967: NEG
30968: PUSH
30969: LD_INT 1
30971: NEG
30972: PUSH
30973: EMPTY
30974: LIST
30975: LIST
30976: PUSH
30977: LD_INT 1
30979: NEG
30980: PUSH
30981: LD_INT 2
30983: NEG
30984: PUSH
30985: EMPTY
30986: LIST
30987: LIST
30988: PUSH
30989: LD_INT 0
30991: PUSH
30992: LD_INT 2
30994: NEG
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: PUSH
31000: LD_INT 1
31002: PUSH
31003: LD_INT 1
31005: NEG
31006: PUSH
31007: EMPTY
31008: LIST
31009: LIST
31010: PUSH
31011: LD_INT 2
31013: PUSH
31014: LD_INT 0
31016: PUSH
31017: EMPTY
31018: LIST
31019: LIST
31020: PUSH
31021: LD_INT 2
31023: PUSH
31024: LD_INT 1
31026: PUSH
31027: EMPTY
31028: LIST
31029: LIST
31030: PUSH
31031: LD_INT 2
31033: PUSH
31034: LD_INT 2
31036: PUSH
31037: EMPTY
31038: LIST
31039: LIST
31040: PUSH
31041: LD_INT 1
31043: PUSH
31044: LD_INT 2
31046: PUSH
31047: EMPTY
31048: LIST
31049: LIST
31050: PUSH
31051: LD_INT 0
31053: PUSH
31054: LD_INT 2
31056: PUSH
31057: EMPTY
31058: LIST
31059: LIST
31060: PUSH
31061: LD_INT 1
31063: NEG
31064: PUSH
31065: LD_INT 1
31067: PUSH
31068: EMPTY
31069: LIST
31070: LIST
31071: PUSH
31072: LD_INT 2
31074: NEG
31075: PUSH
31076: LD_INT 0
31078: PUSH
31079: EMPTY
31080: LIST
31081: LIST
31082: PUSH
31083: LD_INT 2
31085: NEG
31086: PUSH
31087: LD_INT 1
31089: NEG
31090: PUSH
31091: EMPTY
31092: LIST
31093: LIST
31094: PUSH
31095: LD_INT 2
31097: NEG
31098: PUSH
31099: LD_INT 2
31101: NEG
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PUSH
31107: EMPTY
31108: LIST
31109: LIST
31110: LIST
31111: LIST
31112: LIST
31113: LIST
31114: LIST
31115: LIST
31116: LIST
31117: LIST
31118: LIST
31119: LIST
31120: LIST
31121: LIST
31122: LIST
31123: LIST
31124: LIST
31125: LIST
31126: LIST
31127: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31128: LD_ADDR_VAR 0 18
31132: PUSH
31133: LD_INT 0
31135: PUSH
31136: LD_INT 0
31138: PUSH
31139: EMPTY
31140: LIST
31141: LIST
31142: PUSH
31143: LD_INT 0
31145: PUSH
31146: LD_INT 1
31148: NEG
31149: PUSH
31150: EMPTY
31151: LIST
31152: LIST
31153: PUSH
31154: LD_INT 1
31156: PUSH
31157: LD_INT 0
31159: PUSH
31160: EMPTY
31161: LIST
31162: LIST
31163: PUSH
31164: LD_INT 1
31166: PUSH
31167: LD_INT 1
31169: PUSH
31170: EMPTY
31171: LIST
31172: LIST
31173: PUSH
31174: LD_INT 0
31176: PUSH
31177: LD_INT 1
31179: PUSH
31180: EMPTY
31181: LIST
31182: LIST
31183: PUSH
31184: LD_INT 1
31186: NEG
31187: PUSH
31188: LD_INT 0
31190: PUSH
31191: EMPTY
31192: LIST
31193: LIST
31194: PUSH
31195: LD_INT 1
31197: NEG
31198: PUSH
31199: LD_INT 1
31201: NEG
31202: PUSH
31203: EMPTY
31204: LIST
31205: LIST
31206: PUSH
31207: LD_INT 1
31209: NEG
31210: PUSH
31211: LD_INT 2
31213: NEG
31214: PUSH
31215: EMPTY
31216: LIST
31217: LIST
31218: PUSH
31219: LD_INT 0
31221: PUSH
31222: LD_INT 2
31224: NEG
31225: PUSH
31226: EMPTY
31227: LIST
31228: LIST
31229: PUSH
31230: LD_INT 1
31232: PUSH
31233: LD_INT 1
31235: NEG
31236: PUSH
31237: EMPTY
31238: LIST
31239: LIST
31240: PUSH
31241: LD_INT 2
31243: PUSH
31244: LD_INT 0
31246: PUSH
31247: EMPTY
31248: LIST
31249: LIST
31250: PUSH
31251: LD_INT 2
31253: PUSH
31254: LD_INT 1
31256: PUSH
31257: EMPTY
31258: LIST
31259: LIST
31260: PUSH
31261: LD_INT 2
31263: PUSH
31264: LD_INT 2
31266: PUSH
31267: EMPTY
31268: LIST
31269: LIST
31270: PUSH
31271: LD_INT 1
31273: PUSH
31274: LD_INT 2
31276: PUSH
31277: EMPTY
31278: LIST
31279: LIST
31280: PUSH
31281: LD_INT 0
31283: PUSH
31284: LD_INT 2
31286: PUSH
31287: EMPTY
31288: LIST
31289: LIST
31290: PUSH
31291: LD_INT 1
31293: NEG
31294: PUSH
31295: LD_INT 1
31297: PUSH
31298: EMPTY
31299: LIST
31300: LIST
31301: PUSH
31302: LD_INT 2
31304: NEG
31305: PUSH
31306: LD_INT 0
31308: PUSH
31309: EMPTY
31310: LIST
31311: LIST
31312: PUSH
31313: LD_INT 2
31315: NEG
31316: PUSH
31317: LD_INT 1
31319: NEG
31320: PUSH
31321: EMPTY
31322: LIST
31323: LIST
31324: PUSH
31325: LD_INT 2
31327: NEG
31328: PUSH
31329: LD_INT 2
31331: NEG
31332: PUSH
31333: EMPTY
31334: LIST
31335: LIST
31336: PUSH
31337: EMPTY
31338: LIST
31339: LIST
31340: LIST
31341: LIST
31342: LIST
31343: LIST
31344: LIST
31345: LIST
31346: LIST
31347: LIST
31348: LIST
31349: LIST
31350: LIST
31351: LIST
31352: LIST
31353: LIST
31354: LIST
31355: LIST
31356: LIST
31357: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31358: LD_ADDR_VAR 0 19
31362: PUSH
31363: LD_INT 0
31365: PUSH
31366: LD_INT 0
31368: PUSH
31369: EMPTY
31370: LIST
31371: LIST
31372: PUSH
31373: LD_INT 0
31375: PUSH
31376: LD_INT 1
31378: NEG
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: PUSH
31384: LD_INT 1
31386: PUSH
31387: LD_INT 0
31389: PUSH
31390: EMPTY
31391: LIST
31392: LIST
31393: PUSH
31394: LD_INT 1
31396: PUSH
31397: LD_INT 1
31399: PUSH
31400: EMPTY
31401: LIST
31402: LIST
31403: PUSH
31404: LD_INT 0
31406: PUSH
31407: LD_INT 1
31409: PUSH
31410: EMPTY
31411: LIST
31412: LIST
31413: PUSH
31414: LD_INT 1
31416: NEG
31417: PUSH
31418: LD_INT 0
31420: PUSH
31421: EMPTY
31422: LIST
31423: LIST
31424: PUSH
31425: LD_INT 1
31427: NEG
31428: PUSH
31429: LD_INT 1
31431: NEG
31432: PUSH
31433: EMPTY
31434: LIST
31435: LIST
31436: PUSH
31437: LD_INT 1
31439: NEG
31440: PUSH
31441: LD_INT 2
31443: NEG
31444: PUSH
31445: EMPTY
31446: LIST
31447: LIST
31448: PUSH
31449: LD_INT 0
31451: PUSH
31452: LD_INT 2
31454: NEG
31455: PUSH
31456: EMPTY
31457: LIST
31458: LIST
31459: PUSH
31460: LD_INT 1
31462: PUSH
31463: LD_INT 1
31465: NEG
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: PUSH
31471: LD_INT 2
31473: PUSH
31474: LD_INT 0
31476: PUSH
31477: EMPTY
31478: LIST
31479: LIST
31480: PUSH
31481: LD_INT 2
31483: PUSH
31484: LD_INT 1
31486: PUSH
31487: EMPTY
31488: LIST
31489: LIST
31490: PUSH
31491: LD_INT 2
31493: PUSH
31494: LD_INT 2
31496: PUSH
31497: EMPTY
31498: LIST
31499: LIST
31500: PUSH
31501: LD_INT 1
31503: PUSH
31504: LD_INT 2
31506: PUSH
31507: EMPTY
31508: LIST
31509: LIST
31510: PUSH
31511: LD_INT 0
31513: PUSH
31514: LD_INT 2
31516: PUSH
31517: EMPTY
31518: LIST
31519: LIST
31520: PUSH
31521: LD_INT 1
31523: NEG
31524: PUSH
31525: LD_INT 1
31527: PUSH
31528: EMPTY
31529: LIST
31530: LIST
31531: PUSH
31532: LD_INT 2
31534: NEG
31535: PUSH
31536: LD_INT 0
31538: PUSH
31539: EMPTY
31540: LIST
31541: LIST
31542: PUSH
31543: LD_INT 2
31545: NEG
31546: PUSH
31547: LD_INT 1
31549: NEG
31550: PUSH
31551: EMPTY
31552: LIST
31553: LIST
31554: PUSH
31555: LD_INT 2
31557: NEG
31558: PUSH
31559: LD_INT 2
31561: NEG
31562: PUSH
31563: EMPTY
31564: LIST
31565: LIST
31566: PUSH
31567: EMPTY
31568: LIST
31569: LIST
31570: LIST
31571: LIST
31572: LIST
31573: LIST
31574: LIST
31575: LIST
31576: LIST
31577: LIST
31578: LIST
31579: LIST
31580: LIST
31581: LIST
31582: LIST
31583: LIST
31584: LIST
31585: LIST
31586: LIST
31587: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31588: LD_ADDR_VAR 0 20
31592: PUSH
31593: LD_INT 0
31595: PUSH
31596: LD_INT 0
31598: PUSH
31599: EMPTY
31600: LIST
31601: LIST
31602: PUSH
31603: LD_INT 0
31605: PUSH
31606: LD_INT 1
31608: NEG
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: PUSH
31614: LD_INT 1
31616: PUSH
31617: LD_INT 0
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: PUSH
31624: LD_INT 1
31626: PUSH
31627: LD_INT 1
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PUSH
31634: LD_INT 0
31636: PUSH
31637: LD_INT 1
31639: PUSH
31640: EMPTY
31641: LIST
31642: LIST
31643: PUSH
31644: LD_INT 1
31646: NEG
31647: PUSH
31648: LD_INT 0
31650: PUSH
31651: EMPTY
31652: LIST
31653: LIST
31654: PUSH
31655: LD_INT 1
31657: NEG
31658: PUSH
31659: LD_INT 1
31661: NEG
31662: PUSH
31663: EMPTY
31664: LIST
31665: LIST
31666: PUSH
31667: LD_INT 1
31669: NEG
31670: PUSH
31671: LD_INT 2
31673: NEG
31674: PUSH
31675: EMPTY
31676: LIST
31677: LIST
31678: PUSH
31679: LD_INT 0
31681: PUSH
31682: LD_INT 2
31684: NEG
31685: PUSH
31686: EMPTY
31687: LIST
31688: LIST
31689: PUSH
31690: LD_INT 1
31692: PUSH
31693: LD_INT 1
31695: NEG
31696: PUSH
31697: EMPTY
31698: LIST
31699: LIST
31700: PUSH
31701: LD_INT 2
31703: PUSH
31704: LD_INT 0
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: LD_INT 2
31713: PUSH
31714: LD_INT 1
31716: PUSH
31717: EMPTY
31718: LIST
31719: LIST
31720: PUSH
31721: LD_INT 2
31723: PUSH
31724: LD_INT 2
31726: PUSH
31727: EMPTY
31728: LIST
31729: LIST
31730: PUSH
31731: LD_INT 1
31733: PUSH
31734: LD_INT 2
31736: PUSH
31737: EMPTY
31738: LIST
31739: LIST
31740: PUSH
31741: LD_INT 0
31743: PUSH
31744: LD_INT 2
31746: PUSH
31747: EMPTY
31748: LIST
31749: LIST
31750: PUSH
31751: LD_INT 1
31753: NEG
31754: PUSH
31755: LD_INT 1
31757: PUSH
31758: EMPTY
31759: LIST
31760: LIST
31761: PUSH
31762: LD_INT 2
31764: NEG
31765: PUSH
31766: LD_INT 0
31768: PUSH
31769: EMPTY
31770: LIST
31771: LIST
31772: PUSH
31773: LD_INT 2
31775: NEG
31776: PUSH
31777: LD_INT 1
31779: NEG
31780: PUSH
31781: EMPTY
31782: LIST
31783: LIST
31784: PUSH
31785: LD_INT 2
31787: NEG
31788: PUSH
31789: LD_INT 2
31791: NEG
31792: PUSH
31793: EMPTY
31794: LIST
31795: LIST
31796: PUSH
31797: EMPTY
31798: LIST
31799: LIST
31800: LIST
31801: LIST
31802: LIST
31803: LIST
31804: LIST
31805: LIST
31806: LIST
31807: LIST
31808: LIST
31809: LIST
31810: LIST
31811: LIST
31812: LIST
31813: LIST
31814: LIST
31815: LIST
31816: LIST
31817: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31818: LD_ADDR_VAR 0 21
31822: PUSH
31823: LD_INT 0
31825: PUSH
31826: LD_INT 0
31828: PUSH
31829: EMPTY
31830: LIST
31831: LIST
31832: PUSH
31833: LD_INT 0
31835: PUSH
31836: LD_INT 1
31838: NEG
31839: PUSH
31840: EMPTY
31841: LIST
31842: LIST
31843: PUSH
31844: LD_INT 1
31846: PUSH
31847: LD_INT 0
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: LD_INT 1
31856: PUSH
31857: LD_INT 1
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PUSH
31864: LD_INT 0
31866: PUSH
31867: LD_INT 1
31869: PUSH
31870: EMPTY
31871: LIST
31872: LIST
31873: PUSH
31874: LD_INT 1
31876: NEG
31877: PUSH
31878: LD_INT 0
31880: PUSH
31881: EMPTY
31882: LIST
31883: LIST
31884: PUSH
31885: LD_INT 1
31887: NEG
31888: PUSH
31889: LD_INT 1
31891: NEG
31892: PUSH
31893: EMPTY
31894: LIST
31895: LIST
31896: PUSH
31897: LD_INT 1
31899: NEG
31900: PUSH
31901: LD_INT 2
31903: NEG
31904: PUSH
31905: EMPTY
31906: LIST
31907: LIST
31908: PUSH
31909: LD_INT 0
31911: PUSH
31912: LD_INT 2
31914: NEG
31915: PUSH
31916: EMPTY
31917: LIST
31918: LIST
31919: PUSH
31920: LD_INT 1
31922: PUSH
31923: LD_INT 1
31925: NEG
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: LD_INT 2
31933: PUSH
31934: LD_INT 0
31936: PUSH
31937: EMPTY
31938: LIST
31939: LIST
31940: PUSH
31941: LD_INT 2
31943: PUSH
31944: LD_INT 1
31946: PUSH
31947: EMPTY
31948: LIST
31949: LIST
31950: PUSH
31951: LD_INT 2
31953: PUSH
31954: LD_INT 2
31956: PUSH
31957: EMPTY
31958: LIST
31959: LIST
31960: PUSH
31961: LD_INT 1
31963: PUSH
31964: LD_INT 2
31966: PUSH
31967: EMPTY
31968: LIST
31969: LIST
31970: PUSH
31971: LD_INT 0
31973: PUSH
31974: LD_INT 2
31976: PUSH
31977: EMPTY
31978: LIST
31979: LIST
31980: PUSH
31981: LD_INT 1
31983: NEG
31984: PUSH
31985: LD_INT 1
31987: PUSH
31988: EMPTY
31989: LIST
31990: LIST
31991: PUSH
31992: LD_INT 2
31994: NEG
31995: PUSH
31996: LD_INT 0
31998: PUSH
31999: EMPTY
32000: LIST
32001: LIST
32002: PUSH
32003: LD_INT 2
32005: NEG
32006: PUSH
32007: LD_INT 1
32009: NEG
32010: PUSH
32011: EMPTY
32012: LIST
32013: LIST
32014: PUSH
32015: LD_INT 2
32017: NEG
32018: PUSH
32019: LD_INT 2
32021: NEG
32022: PUSH
32023: EMPTY
32024: LIST
32025: LIST
32026: PUSH
32027: EMPTY
32028: LIST
32029: LIST
32030: LIST
32031: LIST
32032: LIST
32033: LIST
32034: LIST
32035: LIST
32036: LIST
32037: LIST
32038: LIST
32039: LIST
32040: LIST
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32048: LD_ADDR_VAR 0 22
32052: PUSH
32053: LD_INT 0
32055: PUSH
32056: LD_INT 0
32058: PUSH
32059: EMPTY
32060: LIST
32061: LIST
32062: PUSH
32063: LD_INT 0
32065: PUSH
32066: LD_INT 1
32068: NEG
32069: PUSH
32070: EMPTY
32071: LIST
32072: LIST
32073: PUSH
32074: LD_INT 1
32076: PUSH
32077: LD_INT 0
32079: PUSH
32080: EMPTY
32081: LIST
32082: LIST
32083: PUSH
32084: LD_INT 1
32086: PUSH
32087: LD_INT 1
32089: PUSH
32090: EMPTY
32091: LIST
32092: LIST
32093: PUSH
32094: LD_INT 0
32096: PUSH
32097: LD_INT 1
32099: PUSH
32100: EMPTY
32101: LIST
32102: LIST
32103: PUSH
32104: LD_INT 1
32106: NEG
32107: PUSH
32108: LD_INT 0
32110: PUSH
32111: EMPTY
32112: LIST
32113: LIST
32114: PUSH
32115: LD_INT 1
32117: NEG
32118: PUSH
32119: LD_INT 1
32121: NEG
32122: PUSH
32123: EMPTY
32124: LIST
32125: LIST
32126: PUSH
32127: LD_INT 1
32129: NEG
32130: PUSH
32131: LD_INT 2
32133: NEG
32134: PUSH
32135: EMPTY
32136: LIST
32137: LIST
32138: PUSH
32139: LD_INT 0
32141: PUSH
32142: LD_INT 2
32144: NEG
32145: PUSH
32146: EMPTY
32147: LIST
32148: LIST
32149: PUSH
32150: LD_INT 1
32152: PUSH
32153: LD_INT 1
32155: NEG
32156: PUSH
32157: EMPTY
32158: LIST
32159: LIST
32160: PUSH
32161: LD_INT 2
32163: PUSH
32164: LD_INT 0
32166: PUSH
32167: EMPTY
32168: LIST
32169: LIST
32170: PUSH
32171: LD_INT 2
32173: PUSH
32174: LD_INT 1
32176: PUSH
32177: EMPTY
32178: LIST
32179: LIST
32180: PUSH
32181: LD_INT 2
32183: PUSH
32184: LD_INT 2
32186: PUSH
32187: EMPTY
32188: LIST
32189: LIST
32190: PUSH
32191: LD_INT 1
32193: PUSH
32194: LD_INT 2
32196: PUSH
32197: EMPTY
32198: LIST
32199: LIST
32200: PUSH
32201: LD_INT 0
32203: PUSH
32204: LD_INT 2
32206: PUSH
32207: EMPTY
32208: LIST
32209: LIST
32210: PUSH
32211: LD_INT 1
32213: NEG
32214: PUSH
32215: LD_INT 1
32217: PUSH
32218: EMPTY
32219: LIST
32220: LIST
32221: PUSH
32222: LD_INT 2
32224: NEG
32225: PUSH
32226: LD_INT 0
32228: PUSH
32229: EMPTY
32230: LIST
32231: LIST
32232: PUSH
32233: LD_INT 2
32235: NEG
32236: PUSH
32237: LD_INT 1
32239: NEG
32240: PUSH
32241: EMPTY
32242: LIST
32243: LIST
32244: PUSH
32245: LD_INT 2
32247: NEG
32248: PUSH
32249: LD_INT 2
32251: NEG
32252: PUSH
32253: EMPTY
32254: LIST
32255: LIST
32256: PUSH
32257: EMPTY
32258: LIST
32259: LIST
32260: LIST
32261: LIST
32262: LIST
32263: LIST
32264: LIST
32265: LIST
32266: LIST
32267: LIST
32268: LIST
32269: LIST
32270: LIST
32271: LIST
32272: LIST
32273: LIST
32274: LIST
32275: LIST
32276: LIST
32277: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
32278: LD_ADDR_VAR 0 23
32282: PUSH
32283: LD_INT 0
32285: PUSH
32286: LD_INT 0
32288: PUSH
32289: EMPTY
32290: LIST
32291: LIST
32292: PUSH
32293: LD_INT 0
32295: PUSH
32296: LD_INT 1
32298: NEG
32299: PUSH
32300: EMPTY
32301: LIST
32302: LIST
32303: PUSH
32304: LD_INT 1
32306: PUSH
32307: LD_INT 0
32309: PUSH
32310: EMPTY
32311: LIST
32312: LIST
32313: PUSH
32314: LD_INT 1
32316: PUSH
32317: LD_INT 1
32319: PUSH
32320: EMPTY
32321: LIST
32322: LIST
32323: PUSH
32324: LD_INT 0
32326: PUSH
32327: LD_INT 1
32329: PUSH
32330: EMPTY
32331: LIST
32332: LIST
32333: PUSH
32334: LD_INT 1
32336: NEG
32337: PUSH
32338: LD_INT 0
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: PUSH
32345: LD_INT 1
32347: NEG
32348: PUSH
32349: LD_INT 1
32351: NEG
32352: PUSH
32353: EMPTY
32354: LIST
32355: LIST
32356: PUSH
32357: LD_INT 1
32359: NEG
32360: PUSH
32361: LD_INT 2
32363: NEG
32364: PUSH
32365: EMPTY
32366: LIST
32367: LIST
32368: PUSH
32369: LD_INT 0
32371: PUSH
32372: LD_INT 2
32374: NEG
32375: PUSH
32376: EMPTY
32377: LIST
32378: LIST
32379: PUSH
32380: LD_INT 1
32382: PUSH
32383: LD_INT 1
32385: NEG
32386: PUSH
32387: EMPTY
32388: LIST
32389: LIST
32390: PUSH
32391: LD_INT 2
32393: PUSH
32394: LD_INT 0
32396: PUSH
32397: EMPTY
32398: LIST
32399: LIST
32400: PUSH
32401: LD_INT 2
32403: PUSH
32404: LD_INT 1
32406: PUSH
32407: EMPTY
32408: LIST
32409: LIST
32410: PUSH
32411: LD_INT 2
32413: PUSH
32414: LD_INT 2
32416: PUSH
32417: EMPTY
32418: LIST
32419: LIST
32420: PUSH
32421: LD_INT 1
32423: PUSH
32424: LD_INT 2
32426: PUSH
32427: EMPTY
32428: LIST
32429: LIST
32430: PUSH
32431: LD_INT 0
32433: PUSH
32434: LD_INT 2
32436: PUSH
32437: EMPTY
32438: LIST
32439: LIST
32440: PUSH
32441: LD_INT 1
32443: NEG
32444: PUSH
32445: LD_INT 1
32447: PUSH
32448: EMPTY
32449: LIST
32450: LIST
32451: PUSH
32452: LD_INT 2
32454: NEG
32455: PUSH
32456: LD_INT 0
32458: PUSH
32459: EMPTY
32460: LIST
32461: LIST
32462: PUSH
32463: LD_INT 2
32465: NEG
32466: PUSH
32467: LD_INT 1
32469: NEG
32470: PUSH
32471: EMPTY
32472: LIST
32473: LIST
32474: PUSH
32475: LD_INT 2
32477: NEG
32478: PUSH
32479: LD_INT 2
32481: NEG
32482: PUSH
32483: EMPTY
32484: LIST
32485: LIST
32486: PUSH
32487: LD_INT 2
32489: NEG
32490: PUSH
32491: LD_INT 3
32493: NEG
32494: PUSH
32495: EMPTY
32496: LIST
32497: LIST
32498: PUSH
32499: LD_INT 1
32501: NEG
32502: PUSH
32503: LD_INT 3
32505: NEG
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: PUSH
32511: LD_INT 1
32513: PUSH
32514: LD_INT 2
32516: NEG
32517: PUSH
32518: EMPTY
32519: LIST
32520: LIST
32521: PUSH
32522: LD_INT 2
32524: PUSH
32525: LD_INT 1
32527: NEG
32528: PUSH
32529: EMPTY
32530: LIST
32531: LIST
32532: PUSH
32533: EMPTY
32534: LIST
32535: LIST
32536: LIST
32537: LIST
32538: LIST
32539: LIST
32540: LIST
32541: LIST
32542: LIST
32543: LIST
32544: LIST
32545: LIST
32546: LIST
32547: LIST
32548: LIST
32549: LIST
32550: LIST
32551: LIST
32552: LIST
32553: LIST
32554: LIST
32555: LIST
32556: LIST
32557: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32558: LD_ADDR_VAR 0 24
32562: PUSH
32563: LD_INT 0
32565: PUSH
32566: LD_INT 0
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: PUSH
32573: LD_INT 0
32575: PUSH
32576: LD_INT 1
32578: NEG
32579: PUSH
32580: EMPTY
32581: LIST
32582: LIST
32583: PUSH
32584: LD_INT 1
32586: PUSH
32587: LD_INT 0
32589: PUSH
32590: EMPTY
32591: LIST
32592: LIST
32593: PUSH
32594: LD_INT 1
32596: PUSH
32597: LD_INT 1
32599: PUSH
32600: EMPTY
32601: LIST
32602: LIST
32603: PUSH
32604: LD_INT 0
32606: PUSH
32607: LD_INT 1
32609: PUSH
32610: EMPTY
32611: LIST
32612: LIST
32613: PUSH
32614: LD_INT 1
32616: NEG
32617: PUSH
32618: LD_INT 0
32620: PUSH
32621: EMPTY
32622: LIST
32623: LIST
32624: PUSH
32625: LD_INT 1
32627: NEG
32628: PUSH
32629: LD_INT 1
32631: NEG
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: PUSH
32637: LD_INT 1
32639: NEG
32640: PUSH
32641: LD_INT 2
32643: NEG
32644: PUSH
32645: EMPTY
32646: LIST
32647: LIST
32648: PUSH
32649: LD_INT 0
32651: PUSH
32652: LD_INT 2
32654: NEG
32655: PUSH
32656: EMPTY
32657: LIST
32658: LIST
32659: PUSH
32660: LD_INT 1
32662: PUSH
32663: LD_INT 1
32665: NEG
32666: PUSH
32667: EMPTY
32668: LIST
32669: LIST
32670: PUSH
32671: LD_INT 2
32673: PUSH
32674: LD_INT 0
32676: PUSH
32677: EMPTY
32678: LIST
32679: LIST
32680: PUSH
32681: LD_INT 2
32683: PUSH
32684: LD_INT 1
32686: PUSH
32687: EMPTY
32688: LIST
32689: LIST
32690: PUSH
32691: LD_INT 2
32693: PUSH
32694: LD_INT 2
32696: PUSH
32697: EMPTY
32698: LIST
32699: LIST
32700: PUSH
32701: LD_INT 1
32703: PUSH
32704: LD_INT 2
32706: PUSH
32707: EMPTY
32708: LIST
32709: LIST
32710: PUSH
32711: LD_INT 0
32713: PUSH
32714: LD_INT 2
32716: PUSH
32717: EMPTY
32718: LIST
32719: LIST
32720: PUSH
32721: LD_INT 1
32723: NEG
32724: PUSH
32725: LD_INT 1
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: PUSH
32732: LD_INT 2
32734: NEG
32735: PUSH
32736: LD_INT 0
32738: PUSH
32739: EMPTY
32740: LIST
32741: LIST
32742: PUSH
32743: LD_INT 2
32745: NEG
32746: PUSH
32747: LD_INT 1
32749: NEG
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 2
32757: NEG
32758: PUSH
32759: LD_INT 2
32761: NEG
32762: PUSH
32763: EMPTY
32764: LIST
32765: LIST
32766: PUSH
32767: LD_INT 1
32769: PUSH
32770: LD_INT 2
32772: NEG
32773: PUSH
32774: EMPTY
32775: LIST
32776: LIST
32777: PUSH
32778: LD_INT 2
32780: PUSH
32781: LD_INT 1
32783: NEG
32784: PUSH
32785: EMPTY
32786: LIST
32787: LIST
32788: PUSH
32789: LD_INT 3
32791: PUSH
32792: LD_INT 1
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 3
32801: PUSH
32802: LD_INT 2
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: EMPTY
32810: LIST
32811: LIST
32812: LIST
32813: LIST
32814: LIST
32815: LIST
32816: LIST
32817: LIST
32818: LIST
32819: LIST
32820: LIST
32821: LIST
32822: LIST
32823: LIST
32824: LIST
32825: LIST
32826: LIST
32827: LIST
32828: LIST
32829: LIST
32830: LIST
32831: LIST
32832: LIST
32833: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32834: LD_ADDR_VAR 0 25
32838: PUSH
32839: LD_INT 0
32841: PUSH
32842: LD_INT 0
32844: PUSH
32845: EMPTY
32846: LIST
32847: LIST
32848: PUSH
32849: LD_INT 0
32851: PUSH
32852: LD_INT 1
32854: NEG
32855: PUSH
32856: EMPTY
32857: LIST
32858: LIST
32859: PUSH
32860: LD_INT 1
32862: PUSH
32863: LD_INT 0
32865: PUSH
32866: EMPTY
32867: LIST
32868: LIST
32869: PUSH
32870: LD_INT 1
32872: PUSH
32873: LD_INT 1
32875: PUSH
32876: EMPTY
32877: LIST
32878: LIST
32879: PUSH
32880: LD_INT 0
32882: PUSH
32883: LD_INT 1
32885: PUSH
32886: EMPTY
32887: LIST
32888: LIST
32889: PUSH
32890: LD_INT 1
32892: NEG
32893: PUSH
32894: LD_INT 0
32896: PUSH
32897: EMPTY
32898: LIST
32899: LIST
32900: PUSH
32901: LD_INT 1
32903: NEG
32904: PUSH
32905: LD_INT 1
32907: NEG
32908: PUSH
32909: EMPTY
32910: LIST
32911: LIST
32912: PUSH
32913: LD_INT 1
32915: NEG
32916: PUSH
32917: LD_INT 2
32919: NEG
32920: PUSH
32921: EMPTY
32922: LIST
32923: LIST
32924: PUSH
32925: LD_INT 0
32927: PUSH
32928: LD_INT 2
32930: NEG
32931: PUSH
32932: EMPTY
32933: LIST
32934: LIST
32935: PUSH
32936: LD_INT 1
32938: PUSH
32939: LD_INT 1
32941: NEG
32942: PUSH
32943: EMPTY
32944: LIST
32945: LIST
32946: PUSH
32947: LD_INT 2
32949: PUSH
32950: LD_INT 0
32952: PUSH
32953: EMPTY
32954: LIST
32955: LIST
32956: PUSH
32957: LD_INT 2
32959: PUSH
32960: LD_INT 1
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 2
32969: PUSH
32970: LD_INT 2
32972: PUSH
32973: EMPTY
32974: LIST
32975: LIST
32976: PUSH
32977: LD_INT 1
32979: PUSH
32980: LD_INT 2
32982: PUSH
32983: EMPTY
32984: LIST
32985: LIST
32986: PUSH
32987: LD_INT 0
32989: PUSH
32990: LD_INT 2
32992: PUSH
32993: EMPTY
32994: LIST
32995: LIST
32996: PUSH
32997: LD_INT 1
32999: NEG
33000: PUSH
33001: LD_INT 1
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: PUSH
33008: LD_INT 2
33010: NEG
33011: PUSH
33012: LD_INT 0
33014: PUSH
33015: EMPTY
33016: LIST
33017: LIST
33018: PUSH
33019: LD_INT 2
33021: NEG
33022: PUSH
33023: LD_INT 1
33025: NEG
33026: PUSH
33027: EMPTY
33028: LIST
33029: LIST
33030: PUSH
33031: LD_INT 2
33033: NEG
33034: PUSH
33035: LD_INT 2
33037: NEG
33038: PUSH
33039: EMPTY
33040: LIST
33041: LIST
33042: PUSH
33043: LD_INT 3
33045: PUSH
33046: LD_INT 1
33048: PUSH
33049: EMPTY
33050: LIST
33051: LIST
33052: PUSH
33053: LD_INT 3
33055: PUSH
33056: LD_INT 2
33058: PUSH
33059: EMPTY
33060: LIST
33061: LIST
33062: PUSH
33063: LD_INT 2
33065: PUSH
33066: LD_INT 3
33068: PUSH
33069: EMPTY
33070: LIST
33071: LIST
33072: PUSH
33073: LD_INT 1
33075: PUSH
33076: LD_INT 3
33078: PUSH
33079: EMPTY
33080: LIST
33081: LIST
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: LIST
33087: LIST
33088: LIST
33089: LIST
33090: LIST
33091: LIST
33092: LIST
33093: LIST
33094: LIST
33095: LIST
33096: LIST
33097: LIST
33098: LIST
33099: LIST
33100: LIST
33101: LIST
33102: LIST
33103: LIST
33104: LIST
33105: LIST
33106: LIST
33107: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
33108: LD_ADDR_VAR 0 26
33112: PUSH
33113: LD_INT 0
33115: PUSH
33116: LD_INT 0
33118: PUSH
33119: EMPTY
33120: LIST
33121: LIST
33122: PUSH
33123: LD_INT 0
33125: PUSH
33126: LD_INT 1
33128: NEG
33129: PUSH
33130: EMPTY
33131: LIST
33132: LIST
33133: PUSH
33134: LD_INT 1
33136: PUSH
33137: LD_INT 0
33139: PUSH
33140: EMPTY
33141: LIST
33142: LIST
33143: PUSH
33144: LD_INT 1
33146: PUSH
33147: LD_INT 1
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: PUSH
33154: LD_INT 0
33156: PUSH
33157: LD_INT 1
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: PUSH
33164: LD_INT 1
33166: NEG
33167: PUSH
33168: LD_INT 0
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 1
33177: NEG
33178: PUSH
33179: LD_INT 1
33181: NEG
33182: PUSH
33183: EMPTY
33184: LIST
33185: LIST
33186: PUSH
33187: LD_INT 1
33189: NEG
33190: PUSH
33191: LD_INT 2
33193: NEG
33194: PUSH
33195: EMPTY
33196: LIST
33197: LIST
33198: PUSH
33199: LD_INT 0
33201: PUSH
33202: LD_INT 2
33204: NEG
33205: PUSH
33206: EMPTY
33207: LIST
33208: LIST
33209: PUSH
33210: LD_INT 1
33212: PUSH
33213: LD_INT 1
33215: NEG
33216: PUSH
33217: EMPTY
33218: LIST
33219: LIST
33220: PUSH
33221: LD_INT 2
33223: PUSH
33224: LD_INT 0
33226: PUSH
33227: EMPTY
33228: LIST
33229: LIST
33230: PUSH
33231: LD_INT 2
33233: PUSH
33234: LD_INT 1
33236: PUSH
33237: EMPTY
33238: LIST
33239: LIST
33240: PUSH
33241: LD_INT 2
33243: PUSH
33244: LD_INT 2
33246: PUSH
33247: EMPTY
33248: LIST
33249: LIST
33250: PUSH
33251: LD_INT 1
33253: PUSH
33254: LD_INT 2
33256: PUSH
33257: EMPTY
33258: LIST
33259: LIST
33260: PUSH
33261: LD_INT 0
33263: PUSH
33264: LD_INT 2
33266: PUSH
33267: EMPTY
33268: LIST
33269: LIST
33270: PUSH
33271: LD_INT 1
33273: NEG
33274: PUSH
33275: LD_INT 1
33277: PUSH
33278: EMPTY
33279: LIST
33280: LIST
33281: PUSH
33282: LD_INT 2
33284: NEG
33285: PUSH
33286: LD_INT 0
33288: PUSH
33289: EMPTY
33290: LIST
33291: LIST
33292: PUSH
33293: LD_INT 2
33295: NEG
33296: PUSH
33297: LD_INT 1
33299: NEG
33300: PUSH
33301: EMPTY
33302: LIST
33303: LIST
33304: PUSH
33305: LD_INT 2
33307: NEG
33308: PUSH
33309: LD_INT 2
33311: NEG
33312: PUSH
33313: EMPTY
33314: LIST
33315: LIST
33316: PUSH
33317: LD_INT 2
33319: PUSH
33320: LD_INT 3
33322: PUSH
33323: EMPTY
33324: LIST
33325: LIST
33326: PUSH
33327: LD_INT 1
33329: PUSH
33330: LD_INT 3
33332: PUSH
33333: EMPTY
33334: LIST
33335: LIST
33336: PUSH
33337: LD_INT 1
33339: NEG
33340: PUSH
33341: LD_INT 2
33343: PUSH
33344: EMPTY
33345: LIST
33346: LIST
33347: PUSH
33348: LD_INT 2
33350: NEG
33351: PUSH
33352: LD_INT 1
33354: PUSH
33355: EMPTY
33356: LIST
33357: LIST
33358: PUSH
33359: EMPTY
33360: LIST
33361: LIST
33362: LIST
33363: LIST
33364: LIST
33365: LIST
33366: LIST
33367: LIST
33368: LIST
33369: LIST
33370: LIST
33371: LIST
33372: LIST
33373: LIST
33374: LIST
33375: LIST
33376: LIST
33377: LIST
33378: LIST
33379: LIST
33380: LIST
33381: LIST
33382: LIST
33383: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33384: LD_ADDR_VAR 0 27
33388: PUSH
33389: LD_INT 0
33391: PUSH
33392: LD_INT 0
33394: PUSH
33395: EMPTY
33396: LIST
33397: LIST
33398: PUSH
33399: LD_INT 0
33401: PUSH
33402: LD_INT 1
33404: NEG
33405: PUSH
33406: EMPTY
33407: LIST
33408: LIST
33409: PUSH
33410: LD_INT 1
33412: PUSH
33413: LD_INT 0
33415: PUSH
33416: EMPTY
33417: LIST
33418: LIST
33419: PUSH
33420: LD_INT 1
33422: PUSH
33423: LD_INT 1
33425: PUSH
33426: EMPTY
33427: LIST
33428: LIST
33429: PUSH
33430: LD_INT 0
33432: PUSH
33433: LD_INT 1
33435: PUSH
33436: EMPTY
33437: LIST
33438: LIST
33439: PUSH
33440: LD_INT 1
33442: NEG
33443: PUSH
33444: LD_INT 0
33446: PUSH
33447: EMPTY
33448: LIST
33449: LIST
33450: PUSH
33451: LD_INT 1
33453: NEG
33454: PUSH
33455: LD_INT 1
33457: NEG
33458: PUSH
33459: EMPTY
33460: LIST
33461: LIST
33462: PUSH
33463: LD_INT 1
33465: NEG
33466: PUSH
33467: LD_INT 2
33469: NEG
33470: PUSH
33471: EMPTY
33472: LIST
33473: LIST
33474: PUSH
33475: LD_INT 0
33477: PUSH
33478: LD_INT 2
33480: NEG
33481: PUSH
33482: EMPTY
33483: LIST
33484: LIST
33485: PUSH
33486: LD_INT 1
33488: PUSH
33489: LD_INT 1
33491: NEG
33492: PUSH
33493: EMPTY
33494: LIST
33495: LIST
33496: PUSH
33497: LD_INT 2
33499: PUSH
33500: LD_INT 0
33502: PUSH
33503: EMPTY
33504: LIST
33505: LIST
33506: PUSH
33507: LD_INT 2
33509: PUSH
33510: LD_INT 1
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 2
33519: PUSH
33520: LD_INT 2
33522: PUSH
33523: EMPTY
33524: LIST
33525: LIST
33526: PUSH
33527: LD_INT 1
33529: PUSH
33530: LD_INT 2
33532: PUSH
33533: EMPTY
33534: LIST
33535: LIST
33536: PUSH
33537: LD_INT 0
33539: PUSH
33540: LD_INT 2
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 1
33549: NEG
33550: PUSH
33551: LD_INT 1
33553: PUSH
33554: EMPTY
33555: LIST
33556: LIST
33557: PUSH
33558: LD_INT 2
33560: NEG
33561: PUSH
33562: LD_INT 0
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: LD_INT 2
33571: NEG
33572: PUSH
33573: LD_INT 1
33575: NEG
33576: PUSH
33577: EMPTY
33578: LIST
33579: LIST
33580: PUSH
33581: LD_INT 2
33583: NEG
33584: PUSH
33585: LD_INT 2
33587: NEG
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: PUSH
33593: LD_INT 1
33595: NEG
33596: PUSH
33597: LD_INT 2
33599: PUSH
33600: EMPTY
33601: LIST
33602: LIST
33603: PUSH
33604: LD_INT 2
33606: NEG
33607: PUSH
33608: LD_INT 1
33610: PUSH
33611: EMPTY
33612: LIST
33613: LIST
33614: PUSH
33615: LD_INT 3
33617: NEG
33618: PUSH
33619: LD_INT 1
33621: NEG
33622: PUSH
33623: EMPTY
33624: LIST
33625: LIST
33626: PUSH
33627: LD_INT 3
33629: NEG
33630: PUSH
33631: LD_INT 2
33633: NEG
33634: PUSH
33635: EMPTY
33636: LIST
33637: LIST
33638: PUSH
33639: EMPTY
33640: LIST
33641: LIST
33642: LIST
33643: LIST
33644: LIST
33645: LIST
33646: LIST
33647: LIST
33648: LIST
33649: LIST
33650: LIST
33651: LIST
33652: LIST
33653: LIST
33654: LIST
33655: LIST
33656: LIST
33657: LIST
33658: LIST
33659: LIST
33660: LIST
33661: LIST
33662: LIST
33663: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33664: LD_ADDR_VAR 0 28
33668: PUSH
33669: LD_INT 0
33671: PUSH
33672: LD_INT 0
33674: PUSH
33675: EMPTY
33676: LIST
33677: LIST
33678: PUSH
33679: LD_INT 0
33681: PUSH
33682: LD_INT 1
33684: NEG
33685: PUSH
33686: EMPTY
33687: LIST
33688: LIST
33689: PUSH
33690: LD_INT 1
33692: PUSH
33693: LD_INT 0
33695: PUSH
33696: EMPTY
33697: LIST
33698: LIST
33699: PUSH
33700: LD_INT 1
33702: PUSH
33703: LD_INT 1
33705: PUSH
33706: EMPTY
33707: LIST
33708: LIST
33709: PUSH
33710: LD_INT 0
33712: PUSH
33713: LD_INT 1
33715: PUSH
33716: EMPTY
33717: LIST
33718: LIST
33719: PUSH
33720: LD_INT 1
33722: NEG
33723: PUSH
33724: LD_INT 0
33726: PUSH
33727: EMPTY
33728: LIST
33729: LIST
33730: PUSH
33731: LD_INT 1
33733: NEG
33734: PUSH
33735: LD_INT 1
33737: NEG
33738: PUSH
33739: EMPTY
33740: LIST
33741: LIST
33742: PUSH
33743: LD_INT 1
33745: NEG
33746: PUSH
33747: LD_INT 2
33749: NEG
33750: PUSH
33751: EMPTY
33752: LIST
33753: LIST
33754: PUSH
33755: LD_INT 0
33757: PUSH
33758: LD_INT 2
33760: NEG
33761: PUSH
33762: EMPTY
33763: LIST
33764: LIST
33765: PUSH
33766: LD_INT 1
33768: PUSH
33769: LD_INT 1
33771: NEG
33772: PUSH
33773: EMPTY
33774: LIST
33775: LIST
33776: PUSH
33777: LD_INT 2
33779: PUSH
33780: LD_INT 0
33782: PUSH
33783: EMPTY
33784: LIST
33785: LIST
33786: PUSH
33787: LD_INT 2
33789: PUSH
33790: LD_INT 1
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PUSH
33797: LD_INT 2
33799: PUSH
33800: LD_INT 2
33802: PUSH
33803: EMPTY
33804: LIST
33805: LIST
33806: PUSH
33807: LD_INT 1
33809: PUSH
33810: LD_INT 2
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 0
33819: PUSH
33820: LD_INT 2
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PUSH
33827: LD_INT 1
33829: NEG
33830: PUSH
33831: LD_INT 1
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: PUSH
33838: LD_INT 2
33840: NEG
33841: PUSH
33842: LD_INT 0
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: PUSH
33849: LD_INT 2
33851: NEG
33852: PUSH
33853: LD_INT 1
33855: NEG
33856: PUSH
33857: EMPTY
33858: LIST
33859: LIST
33860: PUSH
33861: LD_INT 2
33863: NEG
33864: PUSH
33865: LD_INT 2
33867: NEG
33868: PUSH
33869: EMPTY
33870: LIST
33871: LIST
33872: PUSH
33873: LD_INT 2
33875: NEG
33876: PUSH
33877: LD_INT 3
33879: NEG
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 1
33887: NEG
33888: PUSH
33889: LD_INT 3
33891: NEG
33892: PUSH
33893: EMPTY
33894: LIST
33895: LIST
33896: PUSH
33897: LD_INT 3
33899: NEG
33900: PUSH
33901: LD_INT 1
33903: NEG
33904: PUSH
33905: EMPTY
33906: LIST
33907: LIST
33908: PUSH
33909: LD_INT 3
33911: NEG
33912: PUSH
33913: LD_INT 2
33915: NEG
33916: PUSH
33917: EMPTY
33918: LIST
33919: LIST
33920: PUSH
33921: EMPTY
33922: LIST
33923: LIST
33924: LIST
33925: LIST
33926: LIST
33927: LIST
33928: LIST
33929: LIST
33930: LIST
33931: LIST
33932: LIST
33933: LIST
33934: LIST
33935: LIST
33936: LIST
33937: LIST
33938: LIST
33939: LIST
33940: LIST
33941: LIST
33942: LIST
33943: LIST
33944: LIST
33945: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33946: LD_ADDR_VAR 0 29
33950: PUSH
33951: LD_INT 0
33953: PUSH
33954: LD_INT 0
33956: PUSH
33957: EMPTY
33958: LIST
33959: LIST
33960: PUSH
33961: LD_INT 0
33963: PUSH
33964: LD_INT 1
33966: NEG
33967: PUSH
33968: EMPTY
33969: LIST
33970: LIST
33971: PUSH
33972: LD_INT 1
33974: PUSH
33975: LD_INT 0
33977: PUSH
33978: EMPTY
33979: LIST
33980: LIST
33981: PUSH
33982: LD_INT 1
33984: PUSH
33985: LD_INT 1
33987: PUSH
33988: EMPTY
33989: LIST
33990: LIST
33991: PUSH
33992: LD_INT 0
33994: PUSH
33995: LD_INT 1
33997: PUSH
33998: EMPTY
33999: LIST
34000: LIST
34001: PUSH
34002: LD_INT 1
34004: NEG
34005: PUSH
34006: LD_INT 0
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 1
34015: NEG
34016: PUSH
34017: LD_INT 1
34019: NEG
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: LD_INT 1
34027: NEG
34028: PUSH
34029: LD_INT 2
34031: NEG
34032: PUSH
34033: EMPTY
34034: LIST
34035: LIST
34036: PUSH
34037: LD_INT 0
34039: PUSH
34040: LD_INT 2
34042: NEG
34043: PUSH
34044: EMPTY
34045: LIST
34046: LIST
34047: PUSH
34048: LD_INT 1
34050: PUSH
34051: LD_INT 1
34053: NEG
34054: PUSH
34055: EMPTY
34056: LIST
34057: LIST
34058: PUSH
34059: LD_INT 2
34061: PUSH
34062: LD_INT 0
34064: PUSH
34065: EMPTY
34066: LIST
34067: LIST
34068: PUSH
34069: LD_INT 2
34071: PUSH
34072: LD_INT 1
34074: PUSH
34075: EMPTY
34076: LIST
34077: LIST
34078: PUSH
34079: LD_INT 1
34081: PUSH
34082: LD_INT 2
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: PUSH
34089: LD_INT 0
34091: PUSH
34092: LD_INT 2
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: PUSH
34099: LD_INT 1
34101: NEG
34102: PUSH
34103: LD_INT 1
34105: PUSH
34106: EMPTY
34107: LIST
34108: LIST
34109: PUSH
34110: LD_INT 2
34112: NEG
34113: PUSH
34114: LD_INT 1
34116: NEG
34117: PUSH
34118: EMPTY
34119: LIST
34120: LIST
34121: PUSH
34122: LD_INT 2
34124: NEG
34125: PUSH
34126: LD_INT 2
34128: NEG
34129: PUSH
34130: EMPTY
34131: LIST
34132: LIST
34133: PUSH
34134: LD_INT 2
34136: NEG
34137: PUSH
34138: LD_INT 3
34140: NEG
34141: PUSH
34142: EMPTY
34143: LIST
34144: LIST
34145: PUSH
34146: LD_INT 2
34148: PUSH
34149: LD_INT 1
34151: NEG
34152: PUSH
34153: EMPTY
34154: LIST
34155: LIST
34156: PUSH
34157: LD_INT 3
34159: PUSH
34160: LD_INT 1
34162: PUSH
34163: EMPTY
34164: LIST
34165: LIST
34166: PUSH
34167: LD_INT 1
34169: PUSH
34170: LD_INT 3
34172: PUSH
34173: EMPTY
34174: LIST
34175: LIST
34176: PUSH
34177: LD_INT 1
34179: NEG
34180: PUSH
34181: LD_INT 2
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: LD_INT 3
34190: NEG
34191: PUSH
34192: LD_INT 2
34194: NEG
34195: PUSH
34196: EMPTY
34197: LIST
34198: LIST
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: LIST
34204: LIST
34205: LIST
34206: LIST
34207: LIST
34208: LIST
34209: LIST
34210: LIST
34211: LIST
34212: LIST
34213: LIST
34214: LIST
34215: LIST
34216: LIST
34217: LIST
34218: LIST
34219: LIST
34220: LIST
34221: LIST
34222: LIST
34223: LIST
34224: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34225: LD_ADDR_VAR 0 30
34229: PUSH
34230: LD_INT 0
34232: PUSH
34233: LD_INT 0
34235: PUSH
34236: EMPTY
34237: LIST
34238: LIST
34239: PUSH
34240: LD_INT 0
34242: PUSH
34243: LD_INT 1
34245: NEG
34246: PUSH
34247: EMPTY
34248: LIST
34249: LIST
34250: PUSH
34251: LD_INT 1
34253: PUSH
34254: LD_INT 0
34256: PUSH
34257: EMPTY
34258: LIST
34259: LIST
34260: PUSH
34261: LD_INT 1
34263: PUSH
34264: LD_INT 1
34266: PUSH
34267: EMPTY
34268: LIST
34269: LIST
34270: PUSH
34271: LD_INT 0
34273: PUSH
34274: LD_INT 1
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PUSH
34281: LD_INT 1
34283: NEG
34284: PUSH
34285: LD_INT 0
34287: PUSH
34288: EMPTY
34289: LIST
34290: LIST
34291: PUSH
34292: LD_INT 1
34294: NEG
34295: PUSH
34296: LD_INT 1
34298: NEG
34299: PUSH
34300: EMPTY
34301: LIST
34302: LIST
34303: PUSH
34304: LD_INT 1
34306: NEG
34307: PUSH
34308: LD_INT 2
34310: NEG
34311: PUSH
34312: EMPTY
34313: LIST
34314: LIST
34315: PUSH
34316: LD_INT 0
34318: PUSH
34319: LD_INT 2
34321: NEG
34322: PUSH
34323: EMPTY
34324: LIST
34325: LIST
34326: PUSH
34327: LD_INT 1
34329: PUSH
34330: LD_INT 1
34332: NEG
34333: PUSH
34334: EMPTY
34335: LIST
34336: LIST
34337: PUSH
34338: LD_INT 2
34340: PUSH
34341: LD_INT 0
34343: PUSH
34344: EMPTY
34345: LIST
34346: LIST
34347: PUSH
34348: LD_INT 2
34350: PUSH
34351: LD_INT 1
34353: PUSH
34354: EMPTY
34355: LIST
34356: LIST
34357: PUSH
34358: LD_INT 2
34360: PUSH
34361: LD_INT 2
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: PUSH
34368: LD_INT 1
34370: PUSH
34371: LD_INT 2
34373: PUSH
34374: EMPTY
34375: LIST
34376: LIST
34377: PUSH
34378: LD_INT 1
34380: NEG
34381: PUSH
34382: LD_INT 1
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: PUSH
34389: LD_INT 2
34391: NEG
34392: PUSH
34393: LD_INT 0
34395: PUSH
34396: EMPTY
34397: LIST
34398: LIST
34399: PUSH
34400: LD_INT 2
34402: NEG
34403: PUSH
34404: LD_INT 1
34406: NEG
34407: PUSH
34408: EMPTY
34409: LIST
34410: LIST
34411: PUSH
34412: LD_INT 1
34414: NEG
34415: PUSH
34416: LD_INT 3
34418: NEG
34419: PUSH
34420: EMPTY
34421: LIST
34422: LIST
34423: PUSH
34424: LD_INT 1
34426: PUSH
34427: LD_INT 2
34429: NEG
34430: PUSH
34431: EMPTY
34432: LIST
34433: LIST
34434: PUSH
34435: LD_INT 3
34437: PUSH
34438: LD_INT 2
34440: PUSH
34441: EMPTY
34442: LIST
34443: LIST
34444: PUSH
34445: LD_INT 2
34447: PUSH
34448: LD_INT 3
34450: PUSH
34451: EMPTY
34452: LIST
34453: LIST
34454: PUSH
34455: LD_INT 2
34457: NEG
34458: PUSH
34459: LD_INT 1
34461: PUSH
34462: EMPTY
34463: LIST
34464: LIST
34465: PUSH
34466: LD_INT 3
34468: NEG
34469: PUSH
34470: LD_INT 1
34472: NEG
34473: PUSH
34474: EMPTY
34475: LIST
34476: LIST
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: LIST
34482: LIST
34483: LIST
34484: LIST
34485: LIST
34486: LIST
34487: LIST
34488: LIST
34489: LIST
34490: LIST
34491: LIST
34492: LIST
34493: LIST
34494: LIST
34495: LIST
34496: LIST
34497: LIST
34498: LIST
34499: LIST
34500: LIST
34501: LIST
34502: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34503: LD_ADDR_VAR 0 31
34507: PUSH
34508: LD_INT 0
34510: PUSH
34511: LD_INT 0
34513: PUSH
34514: EMPTY
34515: LIST
34516: LIST
34517: PUSH
34518: LD_INT 0
34520: PUSH
34521: LD_INT 1
34523: NEG
34524: PUSH
34525: EMPTY
34526: LIST
34527: LIST
34528: PUSH
34529: LD_INT 1
34531: PUSH
34532: LD_INT 0
34534: PUSH
34535: EMPTY
34536: LIST
34537: LIST
34538: PUSH
34539: LD_INT 1
34541: PUSH
34542: LD_INT 1
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: PUSH
34549: LD_INT 0
34551: PUSH
34552: LD_INT 1
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: LD_INT 1
34561: NEG
34562: PUSH
34563: LD_INT 0
34565: PUSH
34566: EMPTY
34567: LIST
34568: LIST
34569: PUSH
34570: LD_INT 1
34572: NEG
34573: PUSH
34574: LD_INT 1
34576: NEG
34577: PUSH
34578: EMPTY
34579: LIST
34580: LIST
34581: PUSH
34582: LD_INT 1
34584: NEG
34585: PUSH
34586: LD_INT 2
34588: NEG
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 1
34596: PUSH
34597: LD_INT 1
34599: NEG
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: LD_INT 2
34607: PUSH
34608: LD_INT 0
34610: PUSH
34611: EMPTY
34612: LIST
34613: LIST
34614: PUSH
34615: LD_INT 2
34617: PUSH
34618: LD_INT 1
34620: PUSH
34621: EMPTY
34622: LIST
34623: LIST
34624: PUSH
34625: LD_INT 2
34627: PUSH
34628: LD_INT 2
34630: PUSH
34631: EMPTY
34632: LIST
34633: LIST
34634: PUSH
34635: LD_INT 1
34637: PUSH
34638: LD_INT 2
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: LD_INT 0
34647: PUSH
34648: LD_INT 2
34650: PUSH
34651: EMPTY
34652: LIST
34653: LIST
34654: PUSH
34655: LD_INT 1
34657: NEG
34658: PUSH
34659: LD_INT 1
34661: PUSH
34662: EMPTY
34663: LIST
34664: LIST
34665: PUSH
34666: LD_INT 2
34668: NEG
34669: PUSH
34670: LD_INT 1
34672: NEG
34673: PUSH
34674: EMPTY
34675: LIST
34676: LIST
34677: PUSH
34678: LD_INT 2
34680: NEG
34681: PUSH
34682: LD_INT 2
34684: NEG
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PUSH
34690: LD_INT 2
34692: NEG
34693: PUSH
34694: LD_INT 3
34696: NEG
34697: PUSH
34698: EMPTY
34699: LIST
34700: LIST
34701: PUSH
34702: LD_INT 2
34704: PUSH
34705: LD_INT 1
34707: NEG
34708: PUSH
34709: EMPTY
34710: LIST
34711: LIST
34712: PUSH
34713: LD_INT 3
34715: PUSH
34716: LD_INT 1
34718: PUSH
34719: EMPTY
34720: LIST
34721: LIST
34722: PUSH
34723: LD_INT 1
34725: PUSH
34726: LD_INT 3
34728: PUSH
34729: EMPTY
34730: LIST
34731: LIST
34732: PUSH
34733: LD_INT 1
34735: NEG
34736: PUSH
34737: LD_INT 2
34739: PUSH
34740: EMPTY
34741: LIST
34742: LIST
34743: PUSH
34744: LD_INT 3
34746: NEG
34747: PUSH
34748: LD_INT 2
34750: NEG
34751: PUSH
34752: EMPTY
34753: LIST
34754: LIST
34755: PUSH
34756: EMPTY
34757: LIST
34758: LIST
34759: LIST
34760: LIST
34761: LIST
34762: LIST
34763: LIST
34764: LIST
34765: LIST
34766: LIST
34767: LIST
34768: LIST
34769: LIST
34770: LIST
34771: LIST
34772: LIST
34773: LIST
34774: LIST
34775: LIST
34776: LIST
34777: LIST
34778: LIST
34779: LIST
34780: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34781: LD_ADDR_VAR 0 32
34785: PUSH
34786: LD_INT 0
34788: PUSH
34789: LD_INT 0
34791: PUSH
34792: EMPTY
34793: LIST
34794: LIST
34795: PUSH
34796: LD_INT 0
34798: PUSH
34799: LD_INT 1
34801: NEG
34802: PUSH
34803: EMPTY
34804: LIST
34805: LIST
34806: PUSH
34807: LD_INT 1
34809: PUSH
34810: LD_INT 0
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PUSH
34817: LD_INT 1
34819: PUSH
34820: LD_INT 1
34822: PUSH
34823: EMPTY
34824: LIST
34825: LIST
34826: PUSH
34827: LD_INT 0
34829: PUSH
34830: LD_INT 1
34832: PUSH
34833: EMPTY
34834: LIST
34835: LIST
34836: PUSH
34837: LD_INT 1
34839: NEG
34840: PUSH
34841: LD_INT 0
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: PUSH
34848: LD_INT 1
34850: NEG
34851: PUSH
34852: LD_INT 1
34854: NEG
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: PUSH
34860: LD_INT 1
34862: NEG
34863: PUSH
34864: LD_INT 2
34866: NEG
34867: PUSH
34868: EMPTY
34869: LIST
34870: LIST
34871: PUSH
34872: LD_INT 0
34874: PUSH
34875: LD_INT 2
34877: NEG
34878: PUSH
34879: EMPTY
34880: LIST
34881: LIST
34882: PUSH
34883: LD_INT 1
34885: PUSH
34886: LD_INT 1
34888: NEG
34889: PUSH
34890: EMPTY
34891: LIST
34892: LIST
34893: PUSH
34894: LD_INT 2
34896: PUSH
34897: LD_INT 1
34899: PUSH
34900: EMPTY
34901: LIST
34902: LIST
34903: PUSH
34904: LD_INT 2
34906: PUSH
34907: LD_INT 2
34909: PUSH
34910: EMPTY
34911: LIST
34912: LIST
34913: PUSH
34914: LD_INT 1
34916: PUSH
34917: LD_INT 2
34919: PUSH
34920: EMPTY
34921: LIST
34922: LIST
34923: PUSH
34924: LD_INT 0
34926: PUSH
34927: LD_INT 2
34929: PUSH
34930: EMPTY
34931: LIST
34932: LIST
34933: PUSH
34934: LD_INT 1
34936: NEG
34937: PUSH
34938: LD_INT 1
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PUSH
34945: LD_INT 2
34947: NEG
34948: PUSH
34949: LD_INT 0
34951: PUSH
34952: EMPTY
34953: LIST
34954: LIST
34955: PUSH
34956: LD_INT 2
34958: NEG
34959: PUSH
34960: LD_INT 1
34962: NEG
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: LD_INT 1
34970: NEG
34971: PUSH
34972: LD_INT 3
34974: NEG
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: PUSH
34980: LD_INT 1
34982: PUSH
34983: LD_INT 2
34985: NEG
34986: PUSH
34987: EMPTY
34988: LIST
34989: LIST
34990: PUSH
34991: LD_INT 3
34993: PUSH
34994: LD_INT 2
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: PUSH
35001: LD_INT 2
35003: PUSH
35004: LD_INT 3
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: PUSH
35011: LD_INT 2
35013: NEG
35014: PUSH
35015: LD_INT 1
35017: PUSH
35018: EMPTY
35019: LIST
35020: LIST
35021: PUSH
35022: LD_INT 3
35024: NEG
35025: PUSH
35026: LD_INT 1
35028: NEG
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: PUSH
35034: EMPTY
35035: LIST
35036: LIST
35037: LIST
35038: LIST
35039: LIST
35040: LIST
35041: LIST
35042: LIST
35043: LIST
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: LIST
35049: LIST
35050: LIST
35051: LIST
35052: LIST
35053: LIST
35054: LIST
35055: LIST
35056: LIST
35057: LIST
35058: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35059: LD_ADDR_VAR 0 33
35063: PUSH
35064: LD_INT 0
35066: PUSH
35067: LD_INT 0
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: LD_INT 0
35076: PUSH
35077: LD_INT 1
35079: NEG
35080: PUSH
35081: EMPTY
35082: LIST
35083: LIST
35084: PUSH
35085: LD_INT 1
35087: PUSH
35088: LD_INT 0
35090: PUSH
35091: EMPTY
35092: LIST
35093: LIST
35094: PUSH
35095: LD_INT 1
35097: PUSH
35098: LD_INT 1
35100: PUSH
35101: EMPTY
35102: LIST
35103: LIST
35104: PUSH
35105: LD_INT 0
35107: PUSH
35108: LD_INT 1
35110: PUSH
35111: EMPTY
35112: LIST
35113: LIST
35114: PUSH
35115: LD_INT 1
35117: NEG
35118: PUSH
35119: LD_INT 0
35121: PUSH
35122: EMPTY
35123: LIST
35124: LIST
35125: PUSH
35126: LD_INT 1
35128: NEG
35129: PUSH
35130: LD_INT 1
35132: NEG
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: LD_INT 1
35140: NEG
35141: PUSH
35142: LD_INT 2
35144: NEG
35145: PUSH
35146: EMPTY
35147: LIST
35148: LIST
35149: PUSH
35150: LD_INT 1
35152: PUSH
35153: LD_INT 1
35155: NEG
35156: PUSH
35157: EMPTY
35158: LIST
35159: LIST
35160: PUSH
35161: LD_INT 2
35163: PUSH
35164: LD_INT 0
35166: PUSH
35167: EMPTY
35168: LIST
35169: LIST
35170: PUSH
35171: LD_INT 2
35173: PUSH
35174: LD_INT 1
35176: PUSH
35177: EMPTY
35178: LIST
35179: LIST
35180: PUSH
35181: LD_INT 1
35183: PUSH
35184: LD_INT 2
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PUSH
35191: LD_INT 0
35193: PUSH
35194: LD_INT 2
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 1
35203: NEG
35204: PUSH
35205: LD_INT 1
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 2
35214: NEG
35215: PUSH
35216: LD_INT 0
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: LD_INT 2
35225: NEG
35226: PUSH
35227: LD_INT 1
35229: NEG
35230: PUSH
35231: EMPTY
35232: LIST
35233: LIST
35234: PUSH
35235: LD_INT 2
35237: NEG
35238: PUSH
35239: LD_INT 2
35241: NEG
35242: PUSH
35243: EMPTY
35244: LIST
35245: LIST
35246: PUSH
35247: LD_INT 2
35249: NEG
35250: PUSH
35251: LD_INT 3
35253: NEG
35254: PUSH
35255: EMPTY
35256: LIST
35257: LIST
35258: PUSH
35259: LD_INT 2
35261: PUSH
35262: LD_INT 1
35264: NEG
35265: PUSH
35266: EMPTY
35267: LIST
35268: LIST
35269: PUSH
35270: LD_INT 3
35272: PUSH
35273: LD_INT 1
35275: PUSH
35276: EMPTY
35277: LIST
35278: LIST
35279: PUSH
35280: LD_INT 1
35282: PUSH
35283: LD_INT 3
35285: PUSH
35286: EMPTY
35287: LIST
35288: LIST
35289: PUSH
35290: LD_INT 1
35292: NEG
35293: PUSH
35294: LD_INT 2
35296: PUSH
35297: EMPTY
35298: LIST
35299: LIST
35300: PUSH
35301: LD_INT 3
35303: NEG
35304: PUSH
35305: LD_INT 2
35307: NEG
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: EMPTY
35314: LIST
35315: LIST
35316: LIST
35317: LIST
35318: LIST
35319: LIST
35320: LIST
35321: LIST
35322: LIST
35323: LIST
35324: LIST
35325: LIST
35326: LIST
35327: LIST
35328: LIST
35329: LIST
35330: LIST
35331: LIST
35332: LIST
35333: LIST
35334: LIST
35335: LIST
35336: LIST
35337: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35338: LD_ADDR_VAR 0 34
35342: PUSH
35343: LD_INT 0
35345: PUSH
35346: LD_INT 0
35348: PUSH
35349: EMPTY
35350: LIST
35351: LIST
35352: PUSH
35353: LD_INT 0
35355: PUSH
35356: LD_INT 1
35358: NEG
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 1
35366: PUSH
35367: LD_INT 0
35369: PUSH
35370: EMPTY
35371: LIST
35372: LIST
35373: PUSH
35374: LD_INT 1
35376: PUSH
35377: LD_INT 1
35379: PUSH
35380: EMPTY
35381: LIST
35382: LIST
35383: PUSH
35384: LD_INT 0
35386: PUSH
35387: LD_INT 1
35389: PUSH
35390: EMPTY
35391: LIST
35392: LIST
35393: PUSH
35394: LD_INT 1
35396: NEG
35397: PUSH
35398: LD_INT 0
35400: PUSH
35401: EMPTY
35402: LIST
35403: LIST
35404: PUSH
35405: LD_INT 1
35407: NEG
35408: PUSH
35409: LD_INT 1
35411: NEG
35412: PUSH
35413: EMPTY
35414: LIST
35415: LIST
35416: PUSH
35417: LD_INT 1
35419: NEG
35420: PUSH
35421: LD_INT 2
35423: NEG
35424: PUSH
35425: EMPTY
35426: LIST
35427: LIST
35428: PUSH
35429: LD_INT 0
35431: PUSH
35432: LD_INT 2
35434: NEG
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PUSH
35440: LD_INT 1
35442: PUSH
35443: LD_INT 1
35445: NEG
35446: PUSH
35447: EMPTY
35448: LIST
35449: LIST
35450: PUSH
35451: LD_INT 2
35453: PUSH
35454: LD_INT 1
35456: PUSH
35457: EMPTY
35458: LIST
35459: LIST
35460: PUSH
35461: LD_INT 2
35463: PUSH
35464: LD_INT 2
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PUSH
35471: LD_INT 1
35473: PUSH
35474: LD_INT 2
35476: PUSH
35477: EMPTY
35478: LIST
35479: LIST
35480: PUSH
35481: LD_INT 1
35483: NEG
35484: PUSH
35485: LD_INT 1
35487: PUSH
35488: EMPTY
35489: LIST
35490: LIST
35491: PUSH
35492: LD_INT 2
35494: NEG
35495: PUSH
35496: LD_INT 0
35498: PUSH
35499: EMPTY
35500: LIST
35501: LIST
35502: PUSH
35503: LD_INT 2
35505: NEG
35506: PUSH
35507: LD_INT 1
35509: NEG
35510: PUSH
35511: EMPTY
35512: LIST
35513: LIST
35514: PUSH
35515: LD_INT 2
35517: NEG
35518: PUSH
35519: LD_INT 2
35521: NEG
35522: PUSH
35523: EMPTY
35524: LIST
35525: LIST
35526: PUSH
35527: LD_INT 1
35529: NEG
35530: PUSH
35531: LD_INT 3
35533: NEG
35534: PUSH
35535: EMPTY
35536: LIST
35537: LIST
35538: PUSH
35539: LD_INT 1
35541: PUSH
35542: LD_INT 2
35544: NEG
35545: PUSH
35546: EMPTY
35547: LIST
35548: LIST
35549: PUSH
35550: LD_INT 3
35552: PUSH
35553: LD_INT 2
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: PUSH
35560: LD_INT 2
35562: PUSH
35563: LD_INT 3
35565: PUSH
35566: EMPTY
35567: LIST
35568: LIST
35569: PUSH
35570: LD_INT 2
35572: NEG
35573: PUSH
35574: LD_INT 1
35576: PUSH
35577: EMPTY
35578: LIST
35579: LIST
35580: PUSH
35581: LD_INT 3
35583: NEG
35584: PUSH
35585: LD_INT 1
35587: NEG
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: PUSH
35593: EMPTY
35594: LIST
35595: LIST
35596: LIST
35597: LIST
35598: LIST
35599: LIST
35600: LIST
35601: LIST
35602: LIST
35603: LIST
35604: LIST
35605: LIST
35606: LIST
35607: LIST
35608: LIST
35609: LIST
35610: LIST
35611: LIST
35612: LIST
35613: LIST
35614: LIST
35615: LIST
35616: LIST
35617: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35618: LD_ADDR_VAR 0 35
35622: PUSH
35623: LD_INT 0
35625: PUSH
35626: LD_INT 0
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: PUSH
35633: LD_INT 0
35635: PUSH
35636: LD_INT 1
35638: NEG
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: LD_INT 1
35646: PUSH
35647: LD_INT 0
35649: PUSH
35650: EMPTY
35651: LIST
35652: LIST
35653: PUSH
35654: LD_INT 1
35656: PUSH
35657: LD_INT 1
35659: PUSH
35660: EMPTY
35661: LIST
35662: LIST
35663: PUSH
35664: LD_INT 0
35666: PUSH
35667: LD_INT 1
35669: PUSH
35670: EMPTY
35671: LIST
35672: LIST
35673: PUSH
35674: LD_INT 1
35676: NEG
35677: PUSH
35678: LD_INT 0
35680: PUSH
35681: EMPTY
35682: LIST
35683: LIST
35684: PUSH
35685: LD_INT 1
35687: NEG
35688: PUSH
35689: LD_INT 1
35691: NEG
35692: PUSH
35693: EMPTY
35694: LIST
35695: LIST
35696: PUSH
35697: LD_INT 2
35699: PUSH
35700: LD_INT 1
35702: PUSH
35703: EMPTY
35704: LIST
35705: LIST
35706: PUSH
35707: LD_INT 2
35709: NEG
35710: PUSH
35711: LD_INT 1
35713: NEG
35714: PUSH
35715: EMPTY
35716: LIST
35717: LIST
35718: PUSH
35719: EMPTY
35720: LIST
35721: LIST
35722: LIST
35723: LIST
35724: LIST
35725: LIST
35726: LIST
35727: LIST
35728: LIST
35729: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35730: LD_ADDR_VAR 0 36
35734: PUSH
35735: LD_INT 0
35737: PUSH
35738: LD_INT 0
35740: PUSH
35741: EMPTY
35742: LIST
35743: LIST
35744: PUSH
35745: LD_INT 0
35747: PUSH
35748: LD_INT 1
35750: NEG
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: PUSH
35756: LD_INT 1
35758: PUSH
35759: LD_INT 0
35761: PUSH
35762: EMPTY
35763: LIST
35764: LIST
35765: PUSH
35766: LD_INT 1
35768: PUSH
35769: LD_INT 1
35771: PUSH
35772: EMPTY
35773: LIST
35774: LIST
35775: PUSH
35776: LD_INT 0
35778: PUSH
35779: LD_INT 1
35781: PUSH
35782: EMPTY
35783: LIST
35784: LIST
35785: PUSH
35786: LD_INT 1
35788: NEG
35789: PUSH
35790: LD_INT 0
35792: PUSH
35793: EMPTY
35794: LIST
35795: LIST
35796: PUSH
35797: LD_INT 1
35799: NEG
35800: PUSH
35801: LD_INT 1
35803: NEG
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 1
35811: NEG
35812: PUSH
35813: LD_INT 2
35815: NEG
35816: PUSH
35817: EMPTY
35818: LIST
35819: LIST
35820: PUSH
35821: LD_INT 1
35823: PUSH
35824: LD_INT 2
35826: PUSH
35827: EMPTY
35828: LIST
35829: LIST
35830: PUSH
35831: EMPTY
35832: LIST
35833: LIST
35834: LIST
35835: LIST
35836: LIST
35837: LIST
35838: LIST
35839: LIST
35840: LIST
35841: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35842: LD_ADDR_VAR 0 37
35846: PUSH
35847: LD_INT 0
35849: PUSH
35850: LD_INT 0
35852: PUSH
35853: EMPTY
35854: LIST
35855: LIST
35856: PUSH
35857: LD_INT 0
35859: PUSH
35860: LD_INT 1
35862: NEG
35863: PUSH
35864: EMPTY
35865: LIST
35866: LIST
35867: PUSH
35868: LD_INT 1
35870: PUSH
35871: LD_INT 0
35873: PUSH
35874: EMPTY
35875: LIST
35876: LIST
35877: PUSH
35878: LD_INT 1
35880: PUSH
35881: LD_INT 1
35883: PUSH
35884: EMPTY
35885: LIST
35886: LIST
35887: PUSH
35888: LD_INT 0
35890: PUSH
35891: LD_INT 1
35893: PUSH
35894: EMPTY
35895: LIST
35896: LIST
35897: PUSH
35898: LD_INT 1
35900: NEG
35901: PUSH
35902: LD_INT 0
35904: PUSH
35905: EMPTY
35906: LIST
35907: LIST
35908: PUSH
35909: LD_INT 1
35911: NEG
35912: PUSH
35913: LD_INT 1
35915: NEG
35916: PUSH
35917: EMPTY
35918: LIST
35919: LIST
35920: PUSH
35921: LD_INT 1
35923: PUSH
35924: LD_INT 1
35926: NEG
35927: PUSH
35928: EMPTY
35929: LIST
35930: LIST
35931: PUSH
35932: LD_INT 1
35934: NEG
35935: PUSH
35936: LD_INT 1
35938: PUSH
35939: EMPTY
35940: LIST
35941: LIST
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: LIST
35947: LIST
35948: LIST
35949: LIST
35950: LIST
35951: LIST
35952: LIST
35953: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35954: LD_ADDR_VAR 0 38
35958: PUSH
35959: LD_INT 0
35961: PUSH
35962: LD_INT 0
35964: PUSH
35965: EMPTY
35966: LIST
35967: LIST
35968: PUSH
35969: LD_INT 0
35971: PUSH
35972: LD_INT 1
35974: NEG
35975: PUSH
35976: EMPTY
35977: LIST
35978: LIST
35979: PUSH
35980: LD_INT 1
35982: PUSH
35983: LD_INT 0
35985: PUSH
35986: EMPTY
35987: LIST
35988: LIST
35989: PUSH
35990: LD_INT 1
35992: PUSH
35993: LD_INT 1
35995: PUSH
35996: EMPTY
35997: LIST
35998: LIST
35999: PUSH
36000: LD_INT 0
36002: PUSH
36003: LD_INT 1
36005: PUSH
36006: EMPTY
36007: LIST
36008: LIST
36009: PUSH
36010: LD_INT 1
36012: NEG
36013: PUSH
36014: LD_INT 0
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 1
36023: NEG
36024: PUSH
36025: LD_INT 1
36027: NEG
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: PUSH
36033: LD_INT 2
36035: PUSH
36036: LD_INT 1
36038: PUSH
36039: EMPTY
36040: LIST
36041: LIST
36042: PUSH
36043: LD_INT 2
36045: NEG
36046: PUSH
36047: LD_INT 1
36049: NEG
36050: PUSH
36051: EMPTY
36052: LIST
36053: LIST
36054: PUSH
36055: EMPTY
36056: LIST
36057: LIST
36058: LIST
36059: LIST
36060: LIST
36061: LIST
36062: LIST
36063: LIST
36064: LIST
36065: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36066: LD_ADDR_VAR 0 39
36070: PUSH
36071: LD_INT 0
36073: PUSH
36074: LD_INT 0
36076: PUSH
36077: EMPTY
36078: LIST
36079: LIST
36080: PUSH
36081: LD_INT 0
36083: PUSH
36084: LD_INT 1
36086: NEG
36087: PUSH
36088: EMPTY
36089: LIST
36090: LIST
36091: PUSH
36092: LD_INT 1
36094: PUSH
36095: LD_INT 0
36097: PUSH
36098: EMPTY
36099: LIST
36100: LIST
36101: PUSH
36102: LD_INT 1
36104: PUSH
36105: LD_INT 1
36107: PUSH
36108: EMPTY
36109: LIST
36110: LIST
36111: PUSH
36112: LD_INT 0
36114: PUSH
36115: LD_INT 1
36117: PUSH
36118: EMPTY
36119: LIST
36120: LIST
36121: PUSH
36122: LD_INT 1
36124: NEG
36125: PUSH
36126: LD_INT 0
36128: PUSH
36129: EMPTY
36130: LIST
36131: LIST
36132: PUSH
36133: LD_INT 1
36135: NEG
36136: PUSH
36137: LD_INT 1
36139: NEG
36140: PUSH
36141: EMPTY
36142: LIST
36143: LIST
36144: PUSH
36145: LD_INT 1
36147: NEG
36148: PUSH
36149: LD_INT 2
36151: NEG
36152: PUSH
36153: EMPTY
36154: LIST
36155: LIST
36156: PUSH
36157: LD_INT 1
36159: PUSH
36160: LD_INT 2
36162: PUSH
36163: EMPTY
36164: LIST
36165: LIST
36166: PUSH
36167: EMPTY
36168: LIST
36169: LIST
36170: LIST
36171: LIST
36172: LIST
36173: LIST
36174: LIST
36175: LIST
36176: LIST
36177: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36178: LD_ADDR_VAR 0 40
36182: PUSH
36183: LD_INT 0
36185: PUSH
36186: LD_INT 0
36188: PUSH
36189: EMPTY
36190: LIST
36191: LIST
36192: PUSH
36193: LD_INT 0
36195: PUSH
36196: LD_INT 1
36198: NEG
36199: PUSH
36200: EMPTY
36201: LIST
36202: LIST
36203: PUSH
36204: LD_INT 1
36206: PUSH
36207: LD_INT 0
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: LD_INT 1
36216: PUSH
36217: LD_INT 1
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: LD_INT 0
36226: PUSH
36227: LD_INT 1
36229: PUSH
36230: EMPTY
36231: LIST
36232: LIST
36233: PUSH
36234: LD_INT 1
36236: NEG
36237: PUSH
36238: LD_INT 0
36240: PUSH
36241: EMPTY
36242: LIST
36243: LIST
36244: PUSH
36245: LD_INT 1
36247: NEG
36248: PUSH
36249: LD_INT 1
36251: NEG
36252: PUSH
36253: EMPTY
36254: LIST
36255: LIST
36256: PUSH
36257: LD_INT 1
36259: PUSH
36260: LD_INT 1
36262: NEG
36263: PUSH
36264: EMPTY
36265: LIST
36266: LIST
36267: PUSH
36268: LD_INT 1
36270: NEG
36271: PUSH
36272: LD_INT 1
36274: PUSH
36275: EMPTY
36276: LIST
36277: LIST
36278: PUSH
36279: EMPTY
36280: LIST
36281: LIST
36282: LIST
36283: LIST
36284: LIST
36285: LIST
36286: LIST
36287: LIST
36288: LIST
36289: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36290: LD_ADDR_VAR 0 41
36294: PUSH
36295: LD_INT 0
36297: PUSH
36298: LD_INT 0
36300: PUSH
36301: EMPTY
36302: LIST
36303: LIST
36304: PUSH
36305: LD_INT 0
36307: PUSH
36308: LD_INT 1
36310: NEG
36311: PUSH
36312: EMPTY
36313: LIST
36314: LIST
36315: PUSH
36316: LD_INT 1
36318: PUSH
36319: LD_INT 0
36321: PUSH
36322: EMPTY
36323: LIST
36324: LIST
36325: PUSH
36326: LD_INT 1
36328: PUSH
36329: LD_INT 1
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: PUSH
36336: LD_INT 0
36338: PUSH
36339: LD_INT 1
36341: PUSH
36342: EMPTY
36343: LIST
36344: LIST
36345: PUSH
36346: LD_INT 1
36348: NEG
36349: PUSH
36350: LD_INT 0
36352: PUSH
36353: EMPTY
36354: LIST
36355: LIST
36356: PUSH
36357: LD_INT 1
36359: NEG
36360: PUSH
36361: LD_INT 1
36363: NEG
36364: PUSH
36365: EMPTY
36366: LIST
36367: LIST
36368: PUSH
36369: LD_INT 1
36371: NEG
36372: PUSH
36373: LD_INT 2
36375: NEG
36376: PUSH
36377: EMPTY
36378: LIST
36379: LIST
36380: PUSH
36381: LD_INT 1
36383: PUSH
36384: LD_INT 1
36386: NEG
36387: PUSH
36388: EMPTY
36389: LIST
36390: LIST
36391: PUSH
36392: LD_INT 2
36394: PUSH
36395: LD_INT 0
36397: PUSH
36398: EMPTY
36399: LIST
36400: LIST
36401: PUSH
36402: LD_INT 2
36404: PUSH
36405: LD_INT 1
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 2
36414: PUSH
36415: LD_INT 2
36417: PUSH
36418: EMPTY
36419: LIST
36420: LIST
36421: PUSH
36422: LD_INT 1
36424: PUSH
36425: LD_INT 2
36427: PUSH
36428: EMPTY
36429: LIST
36430: LIST
36431: PUSH
36432: LD_INT 1
36434: NEG
36435: PUSH
36436: LD_INT 1
36438: PUSH
36439: EMPTY
36440: LIST
36441: LIST
36442: PUSH
36443: LD_INT 2
36445: NEG
36446: PUSH
36447: LD_INT 0
36449: PUSH
36450: EMPTY
36451: LIST
36452: LIST
36453: PUSH
36454: LD_INT 2
36456: NEG
36457: PUSH
36458: LD_INT 1
36460: NEG
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 2
36468: NEG
36469: PUSH
36470: LD_INT 2
36472: NEG
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: PUSH
36478: LD_INT 2
36480: NEG
36481: PUSH
36482: LD_INT 3
36484: NEG
36485: PUSH
36486: EMPTY
36487: LIST
36488: LIST
36489: PUSH
36490: LD_INT 2
36492: PUSH
36493: LD_INT 1
36495: NEG
36496: PUSH
36497: EMPTY
36498: LIST
36499: LIST
36500: PUSH
36501: LD_INT 3
36503: PUSH
36504: LD_INT 0
36506: PUSH
36507: EMPTY
36508: LIST
36509: LIST
36510: PUSH
36511: LD_INT 3
36513: PUSH
36514: LD_INT 1
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: PUSH
36521: LD_INT 3
36523: PUSH
36524: LD_INT 2
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: PUSH
36531: LD_INT 3
36533: PUSH
36534: LD_INT 3
36536: PUSH
36537: EMPTY
36538: LIST
36539: LIST
36540: PUSH
36541: LD_INT 2
36543: PUSH
36544: LD_INT 3
36546: PUSH
36547: EMPTY
36548: LIST
36549: LIST
36550: PUSH
36551: LD_INT 2
36553: NEG
36554: PUSH
36555: LD_INT 1
36557: PUSH
36558: EMPTY
36559: LIST
36560: LIST
36561: PUSH
36562: LD_INT 3
36564: NEG
36565: PUSH
36566: LD_INT 0
36568: PUSH
36569: EMPTY
36570: LIST
36571: LIST
36572: PUSH
36573: LD_INT 3
36575: NEG
36576: PUSH
36577: LD_INT 1
36579: NEG
36580: PUSH
36581: EMPTY
36582: LIST
36583: LIST
36584: PUSH
36585: LD_INT 3
36587: NEG
36588: PUSH
36589: LD_INT 2
36591: NEG
36592: PUSH
36593: EMPTY
36594: LIST
36595: LIST
36596: PUSH
36597: LD_INT 3
36599: NEG
36600: PUSH
36601: LD_INT 3
36603: NEG
36604: PUSH
36605: EMPTY
36606: LIST
36607: LIST
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: LIST
36613: LIST
36614: LIST
36615: LIST
36616: LIST
36617: LIST
36618: LIST
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: LIST
36624: LIST
36625: LIST
36626: LIST
36627: LIST
36628: LIST
36629: LIST
36630: LIST
36631: LIST
36632: LIST
36633: LIST
36634: LIST
36635: LIST
36636: LIST
36637: LIST
36638: LIST
36639: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36640: LD_ADDR_VAR 0 42
36644: PUSH
36645: LD_INT 0
36647: PUSH
36648: LD_INT 0
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: PUSH
36655: LD_INT 0
36657: PUSH
36658: LD_INT 1
36660: NEG
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: PUSH
36666: LD_INT 1
36668: PUSH
36669: LD_INT 0
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: LD_INT 1
36678: PUSH
36679: LD_INT 1
36681: PUSH
36682: EMPTY
36683: LIST
36684: LIST
36685: PUSH
36686: LD_INT 0
36688: PUSH
36689: LD_INT 1
36691: PUSH
36692: EMPTY
36693: LIST
36694: LIST
36695: PUSH
36696: LD_INT 1
36698: NEG
36699: PUSH
36700: LD_INT 0
36702: PUSH
36703: EMPTY
36704: LIST
36705: LIST
36706: PUSH
36707: LD_INT 1
36709: NEG
36710: PUSH
36711: LD_INT 1
36713: NEG
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 1
36721: NEG
36722: PUSH
36723: LD_INT 2
36725: NEG
36726: PUSH
36727: EMPTY
36728: LIST
36729: LIST
36730: PUSH
36731: LD_INT 0
36733: PUSH
36734: LD_INT 2
36736: NEG
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 1
36744: PUSH
36745: LD_INT 1
36747: NEG
36748: PUSH
36749: EMPTY
36750: LIST
36751: LIST
36752: PUSH
36753: LD_INT 2
36755: PUSH
36756: LD_INT 1
36758: PUSH
36759: EMPTY
36760: LIST
36761: LIST
36762: PUSH
36763: LD_INT 2
36765: PUSH
36766: LD_INT 2
36768: PUSH
36769: EMPTY
36770: LIST
36771: LIST
36772: PUSH
36773: LD_INT 1
36775: PUSH
36776: LD_INT 2
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: LD_INT 0
36785: PUSH
36786: LD_INT 2
36788: PUSH
36789: EMPTY
36790: LIST
36791: LIST
36792: PUSH
36793: LD_INT 1
36795: NEG
36796: PUSH
36797: LD_INT 1
36799: PUSH
36800: EMPTY
36801: LIST
36802: LIST
36803: PUSH
36804: LD_INT 2
36806: NEG
36807: PUSH
36808: LD_INT 1
36810: NEG
36811: PUSH
36812: EMPTY
36813: LIST
36814: LIST
36815: PUSH
36816: LD_INT 2
36818: NEG
36819: PUSH
36820: LD_INT 2
36822: NEG
36823: PUSH
36824: EMPTY
36825: LIST
36826: LIST
36827: PUSH
36828: LD_INT 2
36830: NEG
36831: PUSH
36832: LD_INT 3
36834: NEG
36835: PUSH
36836: EMPTY
36837: LIST
36838: LIST
36839: PUSH
36840: LD_INT 1
36842: NEG
36843: PUSH
36844: LD_INT 3
36846: NEG
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: LD_INT 0
36854: PUSH
36855: LD_INT 3
36857: NEG
36858: PUSH
36859: EMPTY
36860: LIST
36861: LIST
36862: PUSH
36863: LD_INT 1
36865: PUSH
36866: LD_INT 2
36868: NEG
36869: PUSH
36870: EMPTY
36871: LIST
36872: LIST
36873: PUSH
36874: LD_INT 3
36876: PUSH
36877: LD_INT 2
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PUSH
36884: LD_INT 3
36886: PUSH
36887: LD_INT 3
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: PUSH
36894: LD_INT 2
36896: PUSH
36897: LD_INT 3
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 1
36906: PUSH
36907: LD_INT 3
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: PUSH
36914: LD_INT 0
36916: PUSH
36917: LD_INT 3
36919: PUSH
36920: EMPTY
36921: LIST
36922: LIST
36923: PUSH
36924: LD_INT 1
36926: NEG
36927: PUSH
36928: LD_INT 2
36930: PUSH
36931: EMPTY
36932: LIST
36933: LIST
36934: PUSH
36935: LD_INT 3
36937: NEG
36938: PUSH
36939: LD_INT 2
36941: NEG
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: LD_INT 3
36949: NEG
36950: PUSH
36951: LD_INT 3
36953: NEG
36954: PUSH
36955: EMPTY
36956: LIST
36957: LIST
36958: PUSH
36959: EMPTY
36960: LIST
36961: LIST
36962: LIST
36963: LIST
36964: LIST
36965: LIST
36966: LIST
36967: LIST
36968: LIST
36969: LIST
36970: LIST
36971: LIST
36972: LIST
36973: LIST
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: LIST
36979: LIST
36980: LIST
36981: LIST
36982: LIST
36983: LIST
36984: LIST
36985: LIST
36986: LIST
36987: LIST
36988: LIST
36989: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36990: LD_ADDR_VAR 0 43
36994: PUSH
36995: LD_INT 0
36997: PUSH
36998: LD_INT 0
37000: PUSH
37001: EMPTY
37002: LIST
37003: LIST
37004: PUSH
37005: LD_INT 0
37007: PUSH
37008: LD_INT 1
37010: NEG
37011: PUSH
37012: EMPTY
37013: LIST
37014: LIST
37015: PUSH
37016: LD_INT 1
37018: PUSH
37019: LD_INT 0
37021: PUSH
37022: EMPTY
37023: LIST
37024: LIST
37025: PUSH
37026: LD_INT 1
37028: PUSH
37029: LD_INT 1
37031: PUSH
37032: EMPTY
37033: LIST
37034: LIST
37035: PUSH
37036: LD_INT 0
37038: PUSH
37039: LD_INT 1
37041: PUSH
37042: EMPTY
37043: LIST
37044: LIST
37045: PUSH
37046: LD_INT 1
37048: NEG
37049: PUSH
37050: LD_INT 0
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: PUSH
37057: LD_INT 1
37059: NEG
37060: PUSH
37061: LD_INT 1
37063: NEG
37064: PUSH
37065: EMPTY
37066: LIST
37067: LIST
37068: PUSH
37069: LD_INT 1
37071: NEG
37072: PUSH
37073: LD_INT 2
37075: NEG
37076: PUSH
37077: EMPTY
37078: LIST
37079: LIST
37080: PUSH
37081: LD_INT 0
37083: PUSH
37084: LD_INT 2
37086: NEG
37087: PUSH
37088: EMPTY
37089: LIST
37090: LIST
37091: PUSH
37092: LD_INT 1
37094: PUSH
37095: LD_INT 1
37097: NEG
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: PUSH
37103: LD_INT 2
37105: PUSH
37106: LD_INT 0
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: LD_INT 2
37115: PUSH
37116: LD_INT 1
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 1
37125: PUSH
37126: LD_INT 2
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: PUSH
37133: LD_INT 0
37135: PUSH
37136: LD_INT 2
37138: PUSH
37139: EMPTY
37140: LIST
37141: LIST
37142: PUSH
37143: LD_INT 1
37145: NEG
37146: PUSH
37147: LD_INT 1
37149: PUSH
37150: EMPTY
37151: LIST
37152: LIST
37153: PUSH
37154: LD_INT 2
37156: NEG
37157: PUSH
37158: LD_INT 0
37160: PUSH
37161: EMPTY
37162: LIST
37163: LIST
37164: PUSH
37165: LD_INT 2
37167: NEG
37168: PUSH
37169: LD_INT 1
37171: NEG
37172: PUSH
37173: EMPTY
37174: LIST
37175: LIST
37176: PUSH
37177: LD_INT 1
37179: NEG
37180: PUSH
37181: LD_INT 3
37183: NEG
37184: PUSH
37185: EMPTY
37186: LIST
37187: LIST
37188: PUSH
37189: LD_INT 0
37191: PUSH
37192: LD_INT 3
37194: NEG
37195: PUSH
37196: EMPTY
37197: LIST
37198: LIST
37199: PUSH
37200: LD_INT 1
37202: PUSH
37203: LD_INT 2
37205: NEG
37206: PUSH
37207: EMPTY
37208: LIST
37209: LIST
37210: PUSH
37211: LD_INT 2
37213: PUSH
37214: LD_INT 1
37216: NEG
37217: PUSH
37218: EMPTY
37219: LIST
37220: LIST
37221: PUSH
37222: LD_INT 3
37224: PUSH
37225: LD_INT 0
37227: PUSH
37228: EMPTY
37229: LIST
37230: LIST
37231: PUSH
37232: LD_INT 3
37234: PUSH
37235: LD_INT 1
37237: PUSH
37238: EMPTY
37239: LIST
37240: LIST
37241: PUSH
37242: LD_INT 1
37244: PUSH
37245: LD_INT 3
37247: PUSH
37248: EMPTY
37249: LIST
37250: LIST
37251: PUSH
37252: LD_INT 0
37254: PUSH
37255: LD_INT 3
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PUSH
37262: LD_INT 1
37264: NEG
37265: PUSH
37266: LD_INT 2
37268: PUSH
37269: EMPTY
37270: LIST
37271: LIST
37272: PUSH
37273: LD_INT 2
37275: NEG
37276: PUSH
37277: LD_INT 1
37279: PUSH
37280: EMPTY
37281: LIST
37282: LIST
37283: PUSH
37284: LD_INT 3
37286: NEG
37287: PUSH
37288: LD_INT 0
37290: PUSH
37291: EMPTY
37292: LIST
37293: LIST
37294: PUSH
37295: LD_INT 3
37297: NEG
37298: PUSH
37299: LD_INT 1
37301: NEG
37302: PUSH
37303: EMPTY
37304: LIST
37305: LIST
37306: PUSH
37307: EMPTY
37308: LIST
37309: LIST
37310: LIST
37311: LIST
37312: LIST
37313: LIST
37314: LIST
37315: LIST
37316: LIST
37317: LIST
37318: LIST
37319: LIST
37320: LIST
37321: LIST
37322: LIST
37323: LIST
37324: LIST
37325: LIST
37326: LIST
37327: LIST
37328: LIST
37329: LIST
37330: LIST
37331: LIST
37332: LIST
37333: LIST
37334: LIST
37335: LIST
37336: LIST
37337: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37338: LD_ADDR_VAR 0 44
37342: PUSH
37343: LD_INT 0
37345: PUSH
37346: LD_INT 0
37348: PUSH
37349: EMPTY
37350: LIST
37351: LIST
37352: PUSH
37353: LD_INT 0
37355: PUSH
37356: LD_INT 1
37358: NEG
37359: PUSH
37360: EMPTY
37361: LIST
37362: LIST
37363: PUSH
37364: LD_INT 1
37366: PUSH
37367: LD_INT 0
37369: PUSH
37370: EMPTY
37371: LIST
37372: LIST
37373: PUSH
37374: LD_INT 1
37376: PUSH
37377: LD_INT 1
37379: PUSH
37380: EMPTY
37381: LIST
37382: LIST
37383: PUSH
37384: LD_INT 0
37386: PUSH
37387: LD_INT 1
37389: PUSH
37390: EMPTY
37391: LIST
37392: LIST
37393: PUSH
37394: LD_INT 1
37396: NEG
37397: PUSH
37398: LD_INT 0
37400: PUSH
37401: EMPTY
37402: LIST
37403: LIST
37404: PUSH
37405: LD_INT 1
37407: NEG
37408: PUSH
37409: LD_INT 1
37411: NEG
37412: PUSH
37413: EMPTY
37414: LIST
37415: LIST
37416: PUSH
37417: LD_INT 1
37419: NEG
37420: PUSH
37421: LD_INT 2
37423: NEG
37424: PUSH
37425: EMPTY
37426: LIST
37427: LIST
37428: PUSH
37429: LD_INT 1
37431: PUSH
37432: LD_INT 1
37434: NEG
37435: PUSH
37436: EMPTY
37437: LIST
37438: LIST
37439: PUSH
37440: LD_INT 2
37442: PUSH
37443: LD_INT 0
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: LD_INT 2
37452: PUSH
37453: LD_INT 1
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 2
37462: PUSH
37463: LD_INT 2
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: LD_INT 1
37472: PUSH
37473: LD_INT 2
37475: PUSH
37476: EMPTY
37477: LIST
37478: LIST
37479: PUSH
37480: LD_INT 1
37482: NEG
37483: PUSH
37484: LD_INT 1
37486: PUSH
37487: EMPTY
37488: LIST
37489: LIST
37490: PUSH
37491: LD_INT 2
37493: NEG
37494: PUSH
37495: LD_INT 0
37497: PUSH
37498: EMPTY
37499: LIST
37500: LIST
37501: PUSH
37502: LD_INT 2
37504: NEG
37505: PUSH
37506: LD_INT 1
37508: NEG
37509: PUSH
37510: EMPTY
37511: LIST
37512: LIST
37513: PUSH
37514: LD_INT 2
37516: NEG
37517: PUSH
37518: LD_INT 2
37520: NEG
37521: PUSH
37522: EMPTY
37523: LIST
37524: LIST
37525: PUSH
37526: LD_INT 2
37528: NEG
37529: PUSH
37530: LD_INT 3
37532: NEG
37533: PUSH
37534: EMPTY
37535: LIST
37536: LIST
37537: PUSH
37538: LD_INT 2
37540: PUSH
37541: LD_INT 1
37543: NEG
37544: PUSH
37545: EMPTY
37546: LIST
37547: LIST
37548: PUSH
37549: LD_INT 3
37551: PUSH
37552: LD_INT 0
37554: PUSH
37555: EMPTY
37556: LIST
37557: LIST
37558: PUSH
37559: LD_INT 3
37561: PUSH
37562: LD_INT 1
37564: PUSH
37565: EMPTY
37566: LIST
37567: LIST
37568: PUSH
37569: LD_INT 3
37571: PUSH
37572: LD_INT 2
37574: PUSH
37575: EMPTY
37576: LIST
37577: LIST
37578: PUSH
37579: LD_INT 3
37581: PUSH
37582: LD_INT 3
37584: PUSH
37585: EMPTY
37586: LIST
37587: LIST
37588: PUSH
37589: LD_INT 2
37591: PUSH
37592: LD_INT 3
37594: PUSH
37595: EMPTY
37596: LIST
37597: LIST
37598: PUSH
37599: LD_INT 2
37601: NEG
37602: PUSH
37603: LD_INT 1
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 3
37612: NEG
37613: PUSH
37614: LD_INT 0
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 3
37623: NEG
37624: PUSH
37625: LD_INT 1
37627: NEG
37628: PUSH
37629: EMPTY
37630: LIST
37631: LIST
37632: PUSH
37633: LD_INT 3
37635: NEG
37636: PUSH
37637: LD_INT 2
37639: NEG
37640: PUSH
37641: EMPTY
37642: LIST
37643: LIST
37644: PUSH
37645: LD_INT 3
37647: NEG
37648: PUSH
37649: LD_INT 3
37651: NEG
37652: PUSH
37653: EMPTY
37654: LIST
37655: LIST
37656: PUSH
37657: EMPTY
37658: LIST
37659: LIST
37660: LIST
37661: LIST
37662: LIST
37663: LIST
37664: LIST
37665: LIST
37666: LIST
37667: LIST
37668: LIST
37669: LIST
37670: LIST
37671: LIST
37672: LIST
37673: LIST
37674: LIST
37675: LIST
37676: LIST
37677: LIST
37678: LIST
37679: LIST
37680: LIST
37681: LIST
37682: LIST
37683: LIST
37684: LIST
37685: LIST
37686: LIST
37687: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37688: LD_ADDR_VAR 0 45
37692: PUSH
37693: LD_INT 0
37695: PUSH
37696: LD_INT 0
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 0
37705: PUSH
37706: LD_INT 1
37708: NEG
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: PUSH
37714: LD_INT 1
37716: PUSH
37717: LD_INT 0
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 1
37726: PUSH
37727: LD_INT 1
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 0
37736: PUSH
37737: LD_INT 1
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PUSH
37744: LD_INT 1
37746: NEG
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 1
37757: NEG
37758: PUSH
37759: LD_INT 1
37761: NEG
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: LD_INT 1
37769: NEG
37770: PUSH
37771: LD_INT 2
37773: NEG
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: LD_INT 0
37781: PUSH
37782: LD_INT 2
37784: NEG
37785: PUSH
37786: EMPTY
37787: LIST
37788: LIST
37789: PUSH
37790: LD_INT 1
37792: PUSH
37793: LD_INT 1
37795: NEG
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 2
37803: PUSH
37804: LD_INT 1
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: PUSH
37811: LD_INT 2
37813: PUSH
37814: LD_INT 2
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: PUSH
37821: LD_INT 1
37823: PUSH
37824: LD_INT 2
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 0
37833: PUSH
37834: LD_INT 2
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 1
37843: NEG
37844: PUSH
37845: LD_INT 1
37847: PUSH
37848: EMPTY
37849: LIST
37850: LIST
37851: PUSH
37852: LD_INT 2
37854: NEG
37855: PUSH
37856: LD_INT 1
37858: NEG
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: PUSH
37864: LD_INT 2
37866: NEG
37867: PUSH
37868: LD_INT 2
37870: NEG
37871: PUSH
37872: EMPTY
37873: LIST
37874: LIST
37875: PUSH
37876: LD_INT 2
37878: NEG
37879: PUSH
37880: LD_INT 3
37882: NEG
37883: PUSH
37884: EMPTY
37885: LIST
37886: LIST
37887: PUSH
37888: LD_INT 1
37890: NEG
37891: PUSH
37892: LD_INT 3
37894: NEG
37895: PUSH
37896: EMPTY
37897: LIST
37898: LIST
37899: PUSH
37900: LD_INT 0
37902: PUSH
37903: LD_INT 3
37905: NEG
37906: PUSH
37907: EMPTY
37908: LIST
37909: LIST
37910: PUSH
37911: LD_INT 1
37913: PUSH
37914: LD_INT 2
37916: NEG
37917: PUSH
37918: EMPTY
37919: LIST
37920: LIST
37921: PUSH
37922: LD_INT 3
37924: PUSH
37925: LD_INT 2
37927: PUSH
37928: EMPTY
37929: LIST
37930: LIST
37931: PUSH
37932: LD_INT 3
37934: PUSH
37935: LD_INT 3
37937: PUSH
37938: EMPTY
37939: LIST
37940: LIST
37941: PUSH
37942: LD_INT 2
37944: PUSH
37945: LD_INT 3
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 1
37954: PUSH
37955: LD_INT 3
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: PUSH
37962: LD_INT 0
37964: PUSH
37965: LD_INT 3
37967: PUSH
37968: EMPTY
37969: LIST
37970: LIST
37971: PUSH
37972: LD_INT 1
37974: NEG
37975: PUSH
37976: LD_INT 2
37978: PUSH
37979: EMPTY
37980: LIST
37981: LIST
37982: PUSH
37983: LD_INT 3
37985: NEG
37986: PUSH
37987: LD_INT 2
37989: NEG
37990: PUSH
37991: EMPTY
37992: LIST
37993: LIST
37994: PUSH
37995: LD_INT 3
37997: NEG
37998: PUSH
37999: LD_INT 3
38001: NEG
38002: PUSH
38003: EMPTY
38004: LIST
38005: LIST
38006: PUSH
38007: EMPTY
38008: LIST
38009: LIST
38010: LIST
38011: LIST
38012: LIST
38013: LIST
38014: LIST
38015: LIST
38016: LIST
38017: LIST
38018: LIST
38019: LIST
38020: LIST
38021: LIST
38022: LIST
38023: LIST
38024: LIST
38025: LIST
38026: LIST
38027: LIST
38028: LIST
38029: LIST
38030: LIST
38031: LIST
38032: LIST
38033: LIST
38034: LIST
38035: LIST
38036: LIST
38037: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38038: LD_ADDR_VAR 0 46
38042: PUSH
38043: LD_INT 0
38045: PUSH
38046: LD_INT 0
38048: PUSH
38049: EMPTY
38050: LIST
38051: LIST
38052: PUSH
38053: LD_INT 0
38055: PUSH
38056: LD_INT 1
38058: NEG
38059: PUSH
38060: EMPTY
38061: LIST
38062: LIST
38063: PUSH
38064: LD_INT 1
38066: PUSH
38067: LD_INT 0
38069: PUSH
38070: EMPTY
38071: LIST
38072: LIST
38073: PUSH
38074: LD_INT 1
38076: PUSH
38077: LD_INT 1
38079: PUSH
38080: EMPTY
38081: LIST
38082: LIST
38083: PUSH
38084: LD_INT 0
38086: PUSH
38087: LD_INT 1
38089: PUSH
38090: EMPTY
38091: LIST
38092: LIST
38093: PUSH
38094: LD_INT 1
38096: NEG
38097: PUSH
38098: LD_INT 0
38100: PUSH
38101: EMPTY
38102: LIST
38103: LIST
38104: PUSH
38105: LD_INT 1
38107: NEG
38108: PUSH
38109: LD_INT 1
38111: NEG
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 1
38119: NEG
38120: PUSH
38121: LD_INT 2
38123: NEG
38124: PUSH
38125: EMPTY
38126: LIST
38127: LIST
38128: PUSH
38129: LD_INT 0
38131: PUSH
38132: LD_INT 2
38134: NEG
38135: PUSH
38136: EMPTY
38137: LIST
38138: LIST
38139: PUSH
38140: LD_INT 1
38142: PUSH
38143: LD_INT 1
38145: NEG
38146: PUSH
38147: EMPTY
38148: LIST
38149: LIST
38150: PUSH
38151: LD_INT 2
38153: PUSH
38154: LD_INT 0
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 2
38163: PUSH
38164: LD_INT 1
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 1
38173: PUSH
38174: LD_INT 2
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: LD_INT 0
38183: PUSH
38184: LD_INT 2
38186: PUSH
38187: EMPTY
38188: LIST
38189: LIST
38190: PUSH
38191: LD_INT 1
38193: NEG
38194: PUSH
38195: LD_INT 1
38197: PUSH
38198: EMPTY
38199: LIST
38200: LIST
38201: PUSH
38202: LD_INT 2
38204: NEG
38205: PUSH
38206: LD_INT 0
38208: PUSH
38209: EMPTY
38210: LIST
38211: LIST
38212: PUSH
38213: LD_INT 2
38215: NEG
38216: PUSH
38217: LD_INT 1
38219: NEG
38220: PUSH
38221: EMPTY
38222: LIST
38223: LIST
38224: PUSH
38225: LD_INT 1
38227: NEG
38228: PUSH
38229: LD_INT 3
38231: NEG
38232: PUSH
38233: EMPTY
38234: LIST
38235: LIST
38236: PUSH
38237: LD_INT 0
38239: PUSH
38240: LD_INT 3
38242: NEG
38243: PUSH
38244: EMPTY
38245: LIST
38246: LIST
38247: PUSH
38248: LD_INT 1
38250: PUSH
38251: LD_INT 2
38253: NEG
38254: PUSH
38255: EMPTY
38256: LIST
38257: LIST
38258: PUSH
38259: LD_INT 2
38261: PUSH
38262: LD_INT 1
38264: NEG
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: PUSH
38270: LD_INT 3
38272: PUSH
38273: LD_INT 0
38275: PUSH
38276: EMPTY
38277: LIST
38278: LIST
38279: PUSH
38280: LD_INT 3
38282: PUSH
38283: LD_INT 1
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 1
38292: PUSH
38293: LD_INT 3
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 0
38302: PUSH
38303: LD_INT 3
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: LD_INT 1
38312: NEG
38313: PUSH
38314: LD_INT 2
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PUSH
38321: LD_INT 2
38323: NEG
38324: PUSH
38325: LD_INT 1
38327: PUSH
38328: EMPTY
38329: LIST
38330: LIST
38331: PUSH
38332: LD_INT 3
38334: NEG
38335: PUSH
38336: LD_INT 0
38338: PUSH
38339: EMPTY
38340: LIST
38341: LIST
38342: PUSH
38343: LD_INT 3
38345: NEG
38346: PUSH
38347: LD_INT 1
38349: NEG
38350: PUSH
38351: EMPTY
38352: LIST
38353: LIST
38354: PUSH
38355: EMPTY
38356: LIST
38357: LIST
38358: LIST
38359: LIST
38360: LIST
38361: LIST
38362: LIST
38363: LIST
38364: LIST
38365: LIST
38366: LIST
38367: LIST
38368: LIST
38369: LIST
38370: LIST
38371: LIST
38372: LIST
38373: LIST
38374: LIST
38375: LIST
38376: LIST
38377: LIST
38378: LIST
38379: LIST
38380: LIST
38381: LIST
38382: LIST
38383: LIST
38384: LIST
38385: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38386: LD_ADDR_VAR 0 47
38390: PUSH
38391: LD_INT 0
38393: PUSH
38394: LD_INT 0
38396: PUSH
38397: EMPTY
38398: LIST
38399: LIST
38400: PUSH
38401: LD_INT 0
38403: PUSH
38404: LD_INT 1
38406: NEG
38407: PUSH
38408: EMPTY
38409: LIST
38410: LIST
38411: PUSH
38412: LD_INT 1
38414: PUSH
38415: LD_INT 0
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: LD_INT 1
38424: PUSH
38425: LD_INT 1
38427: PUSH
38428: EMPTY
38429: LIST
38430: LIST
38431: PUSH
38432: LD_INT 0
38434: PUSH
38435: LD_INT 1
38437: PUSH
38438: EMPTY
38439: LIST
38440: LIST
38441: PUSH
38442: LD_INT 1
38444: NEG
38445: PUSH
38446: LD_INT 0
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 1
38455: NEG
38456: PUSH
38457: LD_INT 1
38459: NEG
38460: PUSH
38461: EMPTY
38462: LIST
38463: LIST
38464: PUSH
38465: LD_INT 1
38467: NEG
38468: PUSH
38469: LD_INT 2
38471: NEG
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 0
38479: PUSH
38480: LD_INT 2
38482: NEG
38483: PUSH
38484: EMPTY
38485: LIST
38486: LIST
38487: PUSH
38488: LD_INT 1
38490: PUSH
38491: LD_INT 1
38493: NEG
38494: PUSH
38495: EMPTY
38496: LIST
38497: LIST
38498: PUSH
38499: LD_INT 2
38501: NEG
38502: PUSH
38503: LD_INT 1
38505: NEG
38506: PUSH
38507: EMPTY
38508: LIST
38509: LIST
38510: PUSH
38511: LD_INT 2
38513: NEG
38514: PUSH
38515: LD_INT 2
38517: NEG
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: PUSH
38523: EMPTY
38524: LIST
38525: LIST
38526: LIST
38527: LIST
38528: LIST
38529: LIST
38530: LIST
38531: LIST
38532: LIST
38533: LIST
38534: LIST
38535: LIST
38536: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38537: LD_ADDR_VAR 0 48
38541: PUSH
38542: LD_INT 0
38544: PUSH
38545: LD_INT 0
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PUSH
38552: LD_INT 0
38554: PUSH
38555: LD_INT 1
38557: NEG
38558: PUSH
38559: EMPTY
38560: LIST
38561: LIST
38562: PUSH
38563: LD_INT 1
38565: PUSH
38566: LD_INT 0
38568: PUSH
38569: EMPTY
38570: LIST
38571: LIST
38572: PUSH
38573: LD_INT 1
38575: PUSH
38576: LD_INT 1
38578: PUSH
38579: EMPTY
38580: LIST
38581: LIST
38582: PUSH
38583: LD_INT 0
38585: PUSH
38586: LD_INT 1
38588: PUSH
38589: EMPTY
38590: LIST
38591: LIST
38592: PUSH
38593: LD_INT 1
38595: NEG
38596: PUSH
38597: LD_INT 0
38599: PUSH
38600: EMPTY
38601: LIST
38602: LIST
38603: PUSH
38604: LD_INT 1
38606: NEG
38607: PUSH
38608: LD_INT 1
38610: NEG
38611: PUSH
38612: EMPTY
38613: LIST
38614: LIST
38615: PUSH
38616: LD_INT 1
38618: NEG
38619: PUSH
38620: LD_INT 2
38622: NEG
38623: PUSH
38624: EMPTY
38625: LIST
38626: LIST
38627: PUSH
38628: LD_INT 0
38630: PUSH
38631: LD_INT 2
38633: NEG
38634: PUSH
38635: EMPTY
38636: LIST
38637: LIST
38638: PUSH
38639: LD_INT 1
38641: PUSH
38642: LD_INT 1
38644: NEG
38645: PUSH
38646: EMPTY
38647: LIST
38648: LIST
38649: PUSH
38650: LD_INT 2
38652: PUSH
38653: LD_INT 0
38655: PUSH
38656: EMPTY
38657: LIST
38658: LIST
38659: PUSH
38660: LD_INT 2
38662: PUSH
38663: LD_INT 1
38665: PUSH
38666: EMPTY
38667: LIST
38668: LIST
38669: PUSH
38670: EMPTY
38671: LIST
38672: LIST
38673: LIST
38674: LIST
38675: LIST
38676: LIST
38677: LIST
38678: LIST
38679: LIST
38680: LIST
38681: LIST
38682: LIST
38683: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38684: LD_ADDR_VAR 0 49
38688: PUSH
38689: LD_INT 0
38691: PUSH
38692: LD_INT 0
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: PUSH
38699: LD_INT 0
38701: PUSH
38702: LD_INT 1
38704: NEG
38705: PUSH
38706: EMPTY
38707: LIST
38708: LIST
38709: PUSH
38710: LD_INT 1
38712: PUSH
38713: LD_INT 0
38715: PUSH
38716: EMPTY
38717: LIST
38718: LIST
38719: PUSH
38720: LD_INT 1
38722: PUSH
38723: LD_INT 1
38725: PUSH
38726: EMPTY
38727: LIST
38728: LIST
38729: PUSH
38730: LD_INT 0
38732: PUSH
38733: LD_INT 1
38735: PUSH
38736: EMPTY
38737: LIST
38738: LIST
38739: PUSH
38740: LD_INT 1
38742: NEG
38743: PUSH
38744: LD_INT 0
38746: PUSH
38747: EMPTY
38748: LIST
38749: LIST
38750: PUSH
38751: LD_INT 1
38753: NEG
38754: PUSH
38755: LD_INT 1
38757: NEG
38758: PUSH
38759: EMPTY
38760: LIST
38761: LIST
38762: PUSH
38763: LD_INT 1
38765: PUSH
38766: LD_INT 1
38768: NEG
38769: PUSH
38770: EMPTY
38771: LIST
38772: LIST
38773: PUSH
38774: LD_INT 2
38776: PUSH
38777: LD_INT 0
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: PUSH
38784: LD_INT 2
38786: PUSH
38787: LD_INT 1
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 2
38796: PUSH
38797: LD_INT 2
38799: PUSH
38800: EMPTY
38801: LIST
38802: LIST
38803: PUSH
38804: LD_INT 1
38806: PUSH
38807: LD_INT 2
38809: PUSH
38810: EMPTY
38811: LIST
38812: LIST
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: LIST
38818: LIST
38819: LIST
38820: LIST
38821: LIST
38822: LIST
38823: LIST
38824: LIST
38825: LIST
38826: LIST
38827: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38828: LD_ADDR_VAR 0 50
38832: PUSH
38833: LD_INT 0
38835: PUSH
38836: LD_INT 0
38838: PUSH
38839: EMPTY
38840: LIST
38841: LIST
38842: PUSH
38843: LD_INT 0
38845: PUSH
38846: LD_INT 1
38848: NEG
38849: PUSH
38850: EMPTY
38851: LIST
38852: LIST
38853: PUSH
38854: LD_INT 1
38856: PUSH
38857: LD_INT 0
38859: PUSH
38860: EMPTY
38861: LIST
38862: LIST
38863: PUSH
38864: LD_INT 1
38866: PUSH
38867: LD_INT 1
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: PUSH
38874: LD_INT 0
38876: PUSH
38877: LD_INT 1
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: LD_INT 1
38886: NEG
38887: PUSH
38888: LD_INT 0
38890: PUSH
38891: EMPTY
38892: LIST
38893: LIST
38894: PUSH
38895: LD_INT 1
38897: NEG
38898: PUSH
38899: LD_INT 1
38901: NEG
38902: PUSH
38903: EMPTY
38904: LIST
38905: LIST
38906: PUSH
38907: LD_INT 2
38909: PUSH
38910: LD_INT 1
38912: PUSH
38913: EMPTY
38914: LIST
38915: LIST
38916: PUSH
38917: LD_INT 2
38919: PUSH
38920: LD_INT 2
38922: PUSH
38923: EMPTY
38924: LIST
38925: LIST
38926: PUSH
38927: LD_INT 1
38929: PUSH
38930: LD_INT 2
38932: PUSH
38933: EMPTY
38934: LIST
38935: LIST
38936: PUSH
38937: LD_INT 0
38939: PUSH
38940: LD_INT 2
38942: PUSH
38943: EMPTY
38944: LIST
38945: LIST
38946: PUSH
38947: LD_INT 1
38949: NEG
38950: PUSH
38951: LD_INT 1
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: LIST
38962: LIST
38963: LIST
38964: LIST
38965: LIST
38966: LIST
38967: LIST
38968: LIST
38969: LIST
38970: LIST
38971: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38972: LD_ADDR_VAR 0 51
38976: PUSH
38977: LD_INT 0
38979: PUSH
38980: LD_INT 0
38982: PUSH
38983: EMPTY
38984: LIST
38985: LIST
38986: PUSH
38987: LD_INT 0
38989: PUSH
38990: LD_INT 1
38992: NEG
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 1
39000: PUSH
39001: LD_INT 0
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: PUSH
39008: LD_INT 1
39010: PUSH
39011: LD_INT 1
39013: PUSH
39014: EMPTY
39015: LIST
39016: LIST
39017: PUSH
39018: LD_INT 0
39020: PUSH
39021: LD_INT 1
39023: PUSH
39024: EMPTY
39025: LIST
39026: LIST
39027: PUSH
39028: LD_INT 1
39030: NEG
39031: PUSH
39032: LD_INT 0
39034: PUSH
39035: EMPTY
39036: LIST
39037: LIST
39038: PUSH
39039: LD_INT 1
39041: NEG
39042: PUSH
39043: LD_INT 1
39045: NEG
39046: PUSH
39047: EMPTY
39048: LIST
39049: LIST
39050: PUSH
39051: LD_INT 1
39053: PUSH
39054: LD_INT 2
39056: PUSH
39057: EMPTY
39058: LIST
39059: LIST
39060: PUSH
39061: LD_INT 0
39063: PUSH
39064: LD_INT 2
39066: PUSH
39067: EMPTY
39068: LIST
39069: LIST
39070: PUSH
39071: LD_INT 1
39073: NEG
39074: PUSH
39075: LD_INT 1
39077: PUSH
39078: EMPTY
39079: LIST
39080: LIST
39081: PUSH
39082: LD_INT 2
39084: NEG
39085: PUSH
39086: LD_INT 0
39088: PUSH
39089: EMPTY
39090: LIST
39091: LIST
39092: PUSH
39093: LD_INT 2
39095: NEG
39096: PUSH
39097: LD_INT 1
39099: NEG
39100: PUSH
39101: EMPTY
39102: LIST
39103: LIST
39104: PUSH
39105: EMPTY
39106: LIST
39107: LIST
39108: LIST
39109: LIST
39110: LIST
39111: LIST
39112: LIST
39113: LIST
39114: LIST
39115: LIST
39116: LIST
39117: LIST
39118: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39119: LD_ADDR_VAR 0 52
39123: PUSH
39124: LD_INT 0
39126: PUSH
39127: LD_INT 0
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 0
39136: PUSH
39137: LD_INT 1
39139: NEG
39140: PUSH
39141: EMPTY
39142: LIST
39143: LIST
39144: PUSH
39145: LD_INT 1
39147: PUSH
39148: LD_INT 0
39150: PUSH
39151: EMPTY
39152: LIST
39153: LIST
39154: PUSH
39155: LD_INT 1
39157: PUSH
39158: LD_INT 1
39160: PUSH
39161: EMPTY
39162: LIST
39163: LIST
39164: PUSH
39165: LD_INT 0
39167: PUSH
39168: LD_INT 1
39170: PUSH
39171: EMPTY
39172: LIST
39173: LIST
39174: PUSH
39175: LD_INT 1
39177: NEG
39178: PUSH
39179: LD_INT 0
39181: PUSH
39182: EMPTY
39183: LIST
39184: LIST
39185: PUSH
39186: LD_INT 1
39188: NEG
39189: PUSH
39190: LD_INT 1
39192: NEG
39193: PUSH
39194: EMPTY
39195: LIST
39196: LIST
39197: PUSH
39198: LD_INT 1
39200: NEG
39201: PUSH
39202: LD_INT 2
39204: NEG
39205: PUSH
39206: EMPTY
39207: LIST
39208: LIST
39209: PUSH
39210: LD_INT 1
39212: NEG
39213: PUSH
39214: LD_INT 1
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: PUSH
39221: LD_INT 2
39223: NEG
39224: PUSH
39225: LD_INT 0
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: PUSH
39232: LD_INT 2
39234: NEG
39235: PUSH
39236: LD_INT 1
39238: NEG
39239: PUSH
39240: EMPTY
39241: LIST
39242: LIST
39243: PUSH
39244: LD_INT 2
39246: NEG
39247: PUSH
39248: LD_INT 2
39250: NEG
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PUSH
39256: EMPTY
39257: LIST
39258: LIST
39259: LIST
39260: LIST
39261: LIST
39262: LIST
39263: LIST
39264: LIST
39265: LIST
39266: LIST
39267: LIST
39268: LIST
39269: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39270: LD_ADDR_VAR 0 53
39274: PUSH
39275: LD_INT 0
39277: PUSH
39278: LD_INT 0
39280: PUSH
39281: EMPTY
39282: LIST
39283: LIST
39284: PUSH
39285: LD_INT 0
39287: PUSH
39288: LD_INT 1
39290: NEG
39291: PUSH
39292: EMPTY
39293: LIST
39294: LIST
39295: PUSH
39296: LD_INT 1
39298: PUSH
39299: LD_INT 0
39301: PUSH
39302: EMPTY
39303: LIST
39304: LIST
39305: PUSH
39306: LD_INT 1
39308: PUSH
39309: LD_INT 1
39311: PUSH
39312: EMPTY
39313: LIST
39314: LIST
39315: PUSH
39316: LD_INT 0
39318: PUSH
39319: LD_INT 1
39321: PUSH
39322: EMPTY
39323: LIST
39324: LIST
39325: PUSH
39326: LD_INT 1
39328: NEG
39329: PUSH
39330: LD_INT 0
39332: PUSH
39333: EMPTY
39334: LIST
39335: LIST
39336: PUSH
39337: LD_INT 1
39339: NEG
39340: PUSH
39341: LD_INT 1
39343: NEG
39344: PUSH
39345: EMPTY
39346: LIST
39347: LIST
39348: PUSH
39349: LD_INT 1
39351: NEG
39352: PUSH
39353: LD_INT 2
39355: NEG
39356: PUSH
39357: EMPTY
39358: LIST
39359: LIST
39360: PUSH
39361: LD_INT 0
39363: PUSH
39364: LD_INT 2
39366: NEG
39367: PUSH
39368: EMPTY
39369: LIST
39370: LIST
39371: PUSH
39372: LD_INT 1
39374: PUSH
39375: LD_INT 1
39377: NEG
39378: PUSH
39379: EMPTY
39380: LIST
39381: LIST
39382: PUSH
39383: LD_INT 2
39385: PUSH
39386: LD_INT 0
39388: PUSH
39389: EMPTY
39390: LIST
39391: LIST
39392: PUSH
39393: LD_INT 2
39395: PUSH
39396: LD_INT 1
39398: PUSH
39399: EMPTY
39400: LIST
39401: LIST
39402: PUSH
39403: LD_INT 2
39405: PUSH
39406: LD_INT 2
39408: PUSH
39409: EMPTY
39410: LIST
39411: LIST
39412: PUSH
39413: LD_INT 1
39415: PUSH
39416: LD_INT 2
39418: PUSH
39419: EMPTY
39420: LIST
39421: LIST
39422: PUSH
39423: LD_INT 0
39425: PUSH
39426: LD_INT 2
39428: PUSH
39429: EMPTY
39430: LIST
39431: LIST
39432: PUSH
39433: LD_INT 1
39435: NEG
39436: PUSH
39437: LD_INT 1
39439: PUSH
39440: EMPTY
39441: LIST
39442: LIST
39443: PUSH
39444: LD_INT 2
39446: NEG
39447: PUSH
39448: LD_INT 0
39450: PUSH
39451: EMPTY
39452: LIST
39453: LIST
39454: PUSH
39455: LD_INT 2
39457: NEG
39458: PUSH
39459: LD_INT 1
39461: NEG
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PUSH
39467: LD_INT 2
39469: NEG
39470: PUSH
39471: LD_INT 2
39473: NEG
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PUSH
39479: EMPTY
39480: LIST
39481: LIST
39482: LIST
39483: LIST
39484: LIST
39485: LIST
39486: LIST
39487: LIST
39488: LIST
39489: LIST
39490: LIST
39491: LIST
39492: LIST
39493: LIST
39494: LIST
39495: LIST
39496: LIST
39497: LIST
39498: LIST
39499: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39500: LD_ADDR_VAR 0 54
39504: PUSH
39505: LD_INT 0
39507: PUSH
39508: LD_INT 0
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: LD_INT 0
39517: PUSH
39518: LD_INT 1
39520: NEG
39521: PUSH
39522: EMPTY
39523: LIST
39524: LIST
39525: PUSH
39526: LD_INT 1
39528: PUSH
39529: LD_INT 0
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: PUSH
39536: LD_INT 1
39538: PUSH
39539: LD_INT 1
39541: PUSH
39542: EMPTY
39543: LIST
39544: LIST
39545: PUSH
39546: LD_INT 0
39548: PUSH
39549: LD_INT 1
39551: PUSH
39552: EMPTY
39553: LIST
39554: LIST
39555: PUSH
39556: LD_INT 1
39558: NEG
39559: PUSH
39560: LD_INT 0
39562: PUSH
39563: EMPTY
39564: LIST
39565: LIST
39566: PUSH
39567: LD_INT 1
39569: NEG
39570: PUSH
39571: LD_INT 1
39573: NEG
39574: PUSH
39575: EMPTY
39576: LIST
39577: LIST
39578: PUSH
39579: LD_INT 1
39581: NEG
39582: PUSH
39583: LD_INT 2
39585: NEG
39586: PUSH
39587: EMPTY
39588: LIST
39589: LIST
39590: PUSH
39591: LD_INT 0
39593: PUSH
39594: LD_INT 2
39596: NEG
39597: PUSH
39598: EMPTY
39599: LIST
39600: LIST
39601: PUSH
39602: LD_INT 1
39604: PUSH
39605: LD_INT 1
39607: NEG
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: PUSH
39613: LD_INT 2
39615: PUSH
39616: LD_INT 0
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 2
39625: PUSH
39626: LD_INT 1
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: LD_INT 2
39635: PUSH
39636: LD_INT 2
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 1
39645: PUSH
39646: LD_INT 2
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 0
39655: PUSH
39656: LD_INT 2
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: LD_INT 1
39665: NEG
39666: PUSH
39667: LD_INT 1
39669: PUSH
39670: EMPTY
39671: LIST
39672: LIST
39673: PUSH
39674: LD_INT 2
39676: NEG
39677: PUSH
39678: LD_INT 0
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 2
39687: NEG
39688: PUSH
39689: LD_INT 1
39691: NEG
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: PUSH
39697: LD_INT 2
39699: NEG
39700: PUSH
39701: LD_INT 2
39703: NEG
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: PUSH
39709: EMPTY
39710: LIST
39711: LIST
39712: LIST
39713: LIST
39714: LIST
39715: LIST
39716: LIST
39717: LIST
39718: LIST
39719: LIST
39720: LIST
39721: LIST
39722: LIST
39723: LIST
39724: LIST
39725: LIST
39726: LIST
39727: LIST
39728: LIST
39729: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39730: LD_ADDR_VAR 0 55
39734: PUSH
39735: LD_INT 0
39737: PUSH
39738: LD_INT 0
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: PUSH
39745: LD_INT 0
39747: PUSH
39748: LD_INT 1
39750: NEG
39751: PUSH
39752: EMPTY
39753: LIST
39754: LIST
39755: PUSH
39756: LD_INT 1
39758: PUSH
39759: LD_INT 0
39761: PUSH
39762: EMPTY
39763: LIST
39764: LIST
39765: PUSH
39766: LD_INT 1
39768: PUSH
39769: LD_INT 1
39771: PUSH
39772: EMPTY
39773: LIST
39774: LIST
39775: PUSH
39776: LD_INT 0
39778: PUSH
39779: LD_INT 1
39781: PUSH
39782: EMPTY
39783: LIST
39784: LIST
39785: PUSH
39786: LD_INT 1
39788: NEG
39789: PUSH
39790: LD_INT 0
39792: PUSH
39793: EMPTY
39794: LIST
39795: LIST
39796: PUSH
39797: LD_INT 1
39799: NEG
39800: PUSH
39801: LD_INT 1
39803: NEG
39804: PUSH
39805: EMPTY
39806: LIST
39807: LIST
39808: PUSH
39809: LD_INT 1
39811: NEG
39812: PUSH
39813: LD_INT 2
39815: NEG
39816: PUSH
39817: EMPTY
39818: LIST
39819: LIST
39820: PUSH
39821: LD_INT 0
39823: PUSH
39824: LD_INT 2
39826: NEG
39827: PUSH
39828: EMPTY
39829: LIST
39830: LIST
39831: PUSH
39832: LD_INT 1
39834: PUSH
39835: LD_INT 1
39837: NEG
39838: PUSH
39839: EMPTY
39840: LIST
39841: LIST
39842: PUSH
39843: LD_INT 2
39845: PUSH
39846: LD_INT 0
39848: PUSH
39849: EMPTY
39850: LIST
39851: LIST
39852: PUSH
39853: LD_INT 2
39855: PUSH
39856: LD_INT 1
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: PUSH
39863: LD_INT 2
39865: PUSH
39866: LD_INT 2
39868: PUSH
39869: EMPTY
39870: LIST
39871: LIST
39872: PUSH
39873: LD_INT 1
39875: PUSH
39876: LD_INT 2
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: PUSH
39883: LD_INT 0
39885: PUSH
39886: LD_INT 2
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: LD_INT 1
39895: NEG
39896: PUSH
39897: LD_INT 1
39899: PUSH
39900: EMPTY
39901: LIST
39902: LIST
39903: PUSH
39904: LD_INT 2
39906: NEG
39907: PUSH
39908: LD_INT 0
39910: PUSH
39911: EMPTY
39912: LIST
39913: LIST
39914: PUSH
39915: LD_INT 2
39917: NEG
39918: PUSH
39919: LD_INT 1
39921: NEG
39922: PUSH
39923: EMPTY
39924: LIST
39925: LIST
39926: PUSH
39927: LD_INT 2
39929: NEG
39930: PUSH
39931: LD_INT 2
39933: NEG
39934: PUSH
39935: EMPTY
39936: LIST
39937: LIST
39938: PUSH
39939: EMPTY
39940: LIST
39941: LIST
39942: LIST
39943: LIST
39944: LIST
39945: LIST
39946: LIST
39947: LIST
39948: LIST
39949: LIST
39950: LIST
39951: LIST
39952: LIST
39953: LIST
39954: LIST
39955: LIST
39956: LIST
39957: LIST
39958: LIST
39959: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39960: LD_ADDR_VAR 0 56
39964: PUSH
39965: LD_INT 0
39967: PUSH
39968: LD_INT 0
39970: PUSH
39971: EMPTY
39972: LIST
39973: LIST
39974: PUSH
39975: LD_INT 0
39977: PUSH
39978: LD_INT 1
39980: NEG
39981: PUSH
39982: EMPTY
39983: LIST
39984: LIST
39985: PUSH
39986: LD_INT 1
39988: PUSH
39989: LD_INT 0
39991: PUSH
39992: EMPTY
39993: LIST
39994: LIST
39995: PUSH
39996: LD_INT 1
39998: PUSH
39999: LD_INT 1
40001: PUSH
40002: EMPTY
40003: LIST
40004: LIST
40005: PUSH
40006: LD_INT 0
40008: PUSH
40009: LD_INT 1
40011: PUSH
40012: EMPTY
40013: LIST
40014: LIST
40015: PUSH
40016: LD_INT 1
40018: NEG
40019: PUSH
40020: LD_INT 0
40022: PUSH
40023: EMPTY
40024: LIST
40025: LIST
40026: PUSH
40027: LD_INT 1
40029: NEG
40030: PUSH
40031: LD_INT 1
40033: NEG
40034: PUSH
40035: EMPTY
40036: LIST
40037: LIST
40038: PUSH
40039: LD_INT 1
40041: NEG
40042: PUSH
40043: LD_INT 2
40045: NEG
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: PUSH
40051: LD_INT 0
40053: PUSH
40054: LD_INT 2
40056: NEG
40057: PUSH
40058: EMPTY
40059: LIST
40060: LIST
40061: PUSH
40062: LD_INT 1
40064: PUSH
40065: LD_INT 1
40067: NEG
40068: PUSH
40069: EMPTY
40070: LIST
40071: LIST
40072: PUSH
40073: LD_INT 2
40075: PUSH
40076: LD_INT 0
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 2
40085: PUSH
40086: LD_INT 1
40088: PUSH
40089: EMPTY
40090: LIST
40091: LIST
40092: PUSH
40093: LD_INT 2
40095: PUSH
40096: LD_INT 2
40098: PUSH
40099: EMPTY
40100: LIST
40101: LIST
40102: PUSH
40103: LD_INT 1
40105: PUSH
40106: LD_INT 2
40108: PUSH
40109: EMPTY
40110: LIST
40111: LIST
40112: PUSH
40113: LD_INT 0
40115: PUSH
40116: LD_INT 2
40118: PUSH
40119: EMPTY
40120: LIST
40121: LIST
40122: PUSH
40123: LD_INT 1
40125: NEG
40126: PUSH
40127: LD_INT 1
40129: PUSH
40130: EMPTY
40131: LIST
40132: LIST
40133: PUSH
40134: LD_INT 2
40136: NEG
40137: PUSH
40138: LD_INT 0
40140: PUSH
40141: EMPTY
40142: LIST
40143: LIST
40144: PUSH
40145: LD_INT 2
40147: NEG
40148: PUSH
40149: LD_INT 1
40151: NEG
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 2
40159: NEG
40160: PUSH
40161: LD_INT 2
40163: NEG
40164: PUSH
40165: EMPTY
40166: LIST
40167: LIST
40168: PUSH
40169: EMPTY
40170: LIST
40171: LIST
40172: LIST
40173: LIST
40174: LIST
40175: LIST
40176: LIST
40177: LIST
40178: LIST
40179: LIST
40180: LIST
40181: LIST
40182: LIST
40183: LIST
40184: LIST
40185: LIST
40186: LIST
40187: LIST
40188: LIST
40189: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40190: LD_ADDR_VAR 0 57
40194: PUSH
40195: LD_INT 0
40197: PUSH
40198: LD_INT 0
40200: PUSH
40201: EMPTY
40202: LIST
40203: LIST
40204: PUSH
40205: LD_INT 0
40207: PUSH
40208: LD_INT 1
40210: NEG
40211: PUSH
40212: EMPTY
40213: LIST
40214: LIST
40215: PUSH
40216: LD_INT 1
40218: PUSH
40219: LD_INT 0
40221: PUSH
40222: EMPTY
40223: LIST
40224: LIST
40225: PUSH
40226: LD_INT 1
40228: PUSH
40229: LD_INT 1
40231: PUSH
40232: EMPTY
40233: LIST
40234: LIST
40235: PUSH
40236: LD_INT 0
40238: PUSH
40239: LD_INT 1
40241: PUSH
40242: EMPTY
40243: LIST
40244: LIST
40245: PUSH
40246: LD_INT 1
40248: NEG
40249: PUSH
40250: LD_INT 0
40252: PUSH
40253: EMPTY
40254: LIST
40255: LIST
40256: PUSH
40257: LD_INT 1
40259: NEG
40260: PUSH
40261: LD_INT 1
40263: NEG
40264: PUSH
40265: EMPTY
40266: LIST
40267: LIST
40268: PUSH
40269: LD_INT 1
40271: NEG
40272: PUSH
40273: LD_INT 2
40275: NEG
40276: PUSH
40277: EMPTY
40278: LIST
40279: LIST
40280: PUSH
40281: LD_INT 0
40283: PUSH
40284: LD_INT 2
40286: NEG
40287: PUSH
40288: EMPTY
40289: LIST
40290: LIST
40291: PUSH
40292: LD_INT 1
40294: PUSH
40295: LD_INT 1
40297: NEG
40298: PUSH
40299: EMPTY
40300: LIST
40301: LIST
40302: PUSH
40303: LD_INT 2
40305: PUSH
40306: LD_INT 0
40308: PUSH
40309: EMPTY
40310: LIST
40311: LIST
40312: PUSH
40313: LD_INT 2
40315: PUSH
40316: LD_INT 1
40318: PUSH
40319: EMPTY
40320: LIST
40321: LIST
40322: PUSH
40323: LD_INT 2
40325: PUSH
40326: LD_INT 2
40328: PUSH
40329: EMPTY
40330: LIST
40331: LIST
40332: PUSH
40333: LD_INT 1
40335: PUSH
40336: LD_INT 2
40338: PUSH
40339: EMPTY
40340: LIST
40341: LIST
40342: PUSH
40343: LD_INT 0
40345: PUSH
40346: LD_INT 2
40348: PUSH
40349: EMPTY
40350: LIST
40351: LIST
40352: PUSH
40353: LD_INT 1
40355: NEG
40356: PUSH
40357: LD_INT 1
40359: PUSH
40360: EMPTY
40361: LIST
40362: LIST
40363: PUSH
40364: LD_INT 2
40366: NEG
40367: PUSH
40368: LD_INT 0
40370: PUSH
40371: EMPTY
40372: LIST
40373: LIST
40374: PUSH
40375: LD_INT 2
40377: NEG
40378: PUSH
40379: LD_INT 1
40381: NEG
40382: PUSH
40383: EMPTY
40384: LIST
40385: LIST
40386: PUSH
40387: LD_INT 2
40389: NEG
40390: PUSH
40391: LD_INT 2
40393: NEG
40394: PUSH
40395: EMPTY
40396: LIST
40397: LIST
40398: PUSH
40399: EMPTY
40400: LIST
40401: LIST
40402: LIST
40403: LIST
40404: LIST
40405: LIST
40406: LIST
40407: LIST
40408: LIST
40409: LIST
40410: LIST
40411: LIST
40412: LIST
40413: LIST
40414: LIST
40415: LIST
40416: LIST
40417: LIST
40418: LIST
40419: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40420: LD_ADDR_VAR 0 58
40424: PUSH
40425: LD_INT 0
40427: PUSH
40428: LD_INT 0
40430: PUSH
40431: EMPTY
40432: LIST
40433: LIST
40434: PUSH
40435: LD_INT 0
40437: PUSH
40438: LD_INT 1
40440: NEG
40441: PUSH
40442: EMPTY
40443: LIST
40444: LIST
40445: PUSH
40446: LD_INT 1
40448: PUSH
40449: LD_INT 0
40451: PUSH
40452: EMPTY
40453: LIST
40454: LIST
40455: PUSH
40456: LD_INT 1
40458: PUSH
40459: LD_INT 1
40461: PUSH
40462: EMPTY
40463: LIST
40464: LIST
40465: PUSH
40466: LD_INT 0
40468: PUSH
40469: LD_INT 1
40471: PUSH
40472: EMPTY
40473: LIST
40474: LIST
40475: PUSH
40476: LD_INT 1
40478: NEG
40479: PUSH
40480: LD_INT 0
40482: PUSH
40483: EMPTY
40484: LIST
40485: LIST
40486: PUSH
40487: LD_INT 1
40489: NEG
40490: PUSH
40491: LD_INT 1
40493: NEG
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: LD_INT 1
40501: NEG
40502: PUSH
40503: LD_INT 2
40505: NEG
40506: PUSH
40507: EMPTY
40508: LIST
40509: LIST
40510: PUSH
40511: LD_INT 0
40513: PUSH
40514: LD_INT 2
40516: NEG
40517: PUSH
40518: EMPTY
40519: LIST
40520: LIST
40521: PUSH
40522: LD_INT 1
40524: PUSH
40525: LD_INT 1
40527: NEG
40528: PUSH
40529: EMPTY
40530: LIST
40531: LIST
40532: PUSH
40533: LD_INT 2
40535: PUSH
40536: LD_INT 0
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: LD_INT 2
40545: PUSH
40546: LD_INT 1
40548: PUSH
40549: EMPTY
40550: LIST
40551: LIST
40552: PUSH
40553: LD_INT 2
40555: PUSH
40556: LD_INT 2
40558: PUSH
40559: EMPTY
40560: LIST
40561: LIST
40562: PUSH
40563: LD_INT 1
40565: PUSH
40566: LD_INT 2
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: PUSH
40573: LD_INT 0
40575: PUSH
40576: LD_INT 2
40578: PUSH
40579: EMPTY
40580: LIST
40581: LIST
40582: PUSH
40583: LD_INT 1
40585: NEG
40586: PUSH
40587: LD_INT 1
40589: PUSH
40590: EMPTY
40591: LIST
40592: LIST
40593: PUSH
40594: LD_INT 2
40596: NEG
40597: PUSH
40598: LD_INT 0
40600: PUSH
40601: EMPTY
40602: LIST
40603: LIST
40604: PUSH
40605: LD_INT 2
40607: NEG
40608: PUSH
40609: LD_INT 1
40611: NEG
40612: PUSH
40613: EMPTY
40614: LIST
40615: LIST
40616: PUSH
40617: LD_INT 2
40619: NEG
40620: PUSH
40621: LD_INT 2
40623: NEG
40624: PUSH
40625: EMPTY
40626: LIST
40627: LIST
40628: PUSH
40629: EMPTY
40630: LIST
40631: LIST
40632: LIST
40633: LIST
40634: LIST
40635: LIST
40636: LIST
40637: LIST
40638: LIST
40639: LIST
40640: LIST
40641: LIST
40642: LIST
40643: LIST
40644: LIST
40645: LIST
40646: LIST
40647: LIST
40648: LIST
40649: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40650: LD_ADDR_VAR 0 59
40654: PUSH
40655: LD_INT 0
40657: PUSH
40658: LD_INT 0
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: PUSH
40665: LD_INT 0
40667: PUSH
40668: LD_INT 1
40670: NEG
40671: PUSH
40672: EMPTY
40673: LIST
40674: LIST
40675: PUSH
40676: LD_INT 1
40678: PUSH
40679: LD_INT 0
40681: PUSH
40682: EMPTY
40683: LIST
40684: LIST
40685: PUSH
40686: LD_INT 1
40688: PUSH
40689: LD_INT 1
40691: PUSH
40692: EMPTY
40693: LIST
40694: LIST
40695: PUSH
40696: LD_INT 0
40698: PUSH
40699: LD_INT 1
40701: PUSH
40702: EMPTY
40703: LIST
40704: LIST
40705: PUSH
40706: LD_INT 1
40708: NEG
40709: PUSH
40710: LD_INT 0
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: LD_INT 1
40719: NEG
40720: PUSH
40721: LD_INT 1
40723: NEG
40724: PUSH
40725: EMPTY
40726: LIST
40727: LIST
40728: PUSH
40729: EMPTY
40730: LIST
40731: LIST
40732: LIST
40733: LIST
40734: LIST
40735: LIST
40736: LIST
40737: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40738: LD_ADDR_VAR 0 60
40742: PUSH
40743: LD_INT 0
40745: PUSH
40746: LD_INT 0
40748: PUSH
40749: EMPTY
40750: LIST
40751: LIST
40752: PUSH
40753: LD_INT 0
40755: PUSH
40756: LD_INT 1
40758: NEG
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: PUSH
40764: LD_INT 1
40766: PUSH
40767: LD_INT 0
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 1
40776: PUSH
40777: LD_INT 1
40779: PUSH
40780: EMPTY
40781: LIST
40782: LIST
40783: PUSH
40784: LD_INT 0
40786: PUSH
40787: LD_INT 1
40789: PUSH
40790: EMPTY
40791: LIST
40792: LIST
40793: PUSH
40794: LD_INT 1
40796: NEG
40797: PUSH
40798: LD_INT 0
40800: PUSH
40801: EMPTY
40802: LIST
40803: LIST
40804: PUSH
40805: LD_INT 1
40807: NEG
40808: PUSH
40809: LD_INT 1
40811: NEG
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: LIST
40821: LIST
40822: LIST
40823: LIST
40824: LIST
40825: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40826: LD_ADDR_VAR 0 61
40830: PUSH
40831: LD_INT 0
40833: PUSH
40834: LD_INT 0
40836: PUSH
40837: EMPTY
40838: LIST
40839: LIST
40840: PUSH
40841: LD_INT 0
40843: PUSH
40844: LD_INT 1
40846: NEG
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: LD_INT 1
40854: PUSH
40855: LD_INT 0
40857: PUSH
40858: EMPTY
40859: LIST
40860: LIST
40861: PUSH
40862: LD_INT 1
40864: PUSH
40865: LD_INT 1
40867: PUSH
40868: EMPTY
40869: LIST
40870: LIST
40871: PUSH
40872: LD_INT 0
40874: PUSH
40875: LD_INT 1
40877: PUSH
40878: EMPTY
40879: LIST
40880: LIST
40881: PUSH
40882: LD_INT 1
40884: NEG
40885: PUSH
40886: LD_INT 0
40888: PUSH
40889: EMPTY
40890: LIST
40891: LIST
40892: PUSH
40893: LD_INT 1
40895: NEG
40896: PUSH
40897: LD_INT 1
40899: NEG
40900: PUSH
40901: EMPTY
40902: LIST
40903: LIST
40904: PUSH
40905: EMPTY
40906: LIST
40907: LIST
40908: LIST
40909: LIST
40910: LIST
40911: LIST
40912: LIST
40913: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40914: LD_ADDR_VAR 0 62
40918: PUSH
40919: LD_INT 0
40921: PUSH
40922: LD_INT 0
40924: PUSH
40925: EMPTY
40926: LIST
40927: LIST
40928: PUSH
40929: LD_INT 0
40931: PUSH
40932: LD_INT 1
40934: NEG
40935: PUSH
40936: EMPTY
40937: LIST
40938: LIST
40939: PUSH
40940: LD_INT 1
40942: PUSH
40943: LD_INT 0
40945: PUSH
40946: EMPTY
40947: LIST
40948: LIST
40949: PUSH
40950: LD_INT 1
40952: PUSH
40953: LD_INT 1
40955: PUSH
40956: EMPTY
40957: LIST
40958: LIST
40959: PUSH
40960: LD_INT 0
40962: PUSH
40963: LD_INT 1
40965: PUSH
40966: EMPTY
40967: LIST
40968: LIST
40969: PUSH
40970: LD_INT 1
40972: NEG
40973: PUSH
40974: LD_INT 0
40976: PUSH
40977: EMPTY
40978: LIST
40979: LIST
40980: PUSH
40981: LD_INT 1
40983: NEG
40984: PUSH
40985: LD_INT 1
40987: NEG
40988: PUSH
40989: EMPTY
40990: LIST
40991: LIST
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: LIST
40997: LIST
40998: LIST
40999: LIST
41000: LIST
41001: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41002: LD_ADDR_VAR 0 63
41006: PUSH
41007: LD_INT 0
41009: PUSH
41010: LD_INT 0
41012: PUSH
41013: EMPTY
41014: LIST
41015: LIST
41016: PUSH
41017: LD_INT 0
41019: PUSH
41020: LD_INT 1
41022: NEG
41023: PUSH
41024: EMPTY
41025: LIST
41026: LIST
41027: PUSH
41028: LD_INT 1
41030: PUSH
41031: LD_INT 0
41033: PUSH
41034: EMPTY
41035: LIST
41036: LIST
41037: PUSH
41038: LD_INT 1
41040: PUSH
41041: LD_INT 1
41043: PUSH
41044: EMPTY
41045: LIST
41046: LIST
41047: PUSH
41048: LD_INT 0
41050: PUSH
41051: LD_INT 1
41053: PUSH
41054: EMPTY
41055: LIST
41056: LIST
41057: PUSH
41058: LD_INT 1
41060: NEG
41061: PUSH
41062: LD_INT 0
41064: PUSH
41065: EMPTY
41066: LIST
41067: LIST
41068: PUSH
41069: LD_INT 1
41071: NEG
41072: PUSH
41073: LD_INT 1
41075: NEG
41076: PUSH
41077: EMPTY
41078: LIST
41079: LIST
41080: PUSH
41081: EMPTY
41082: LIST
41083: LIST
41084: LIST
41085: LIST
41086: LIST
41087: LIST
41088: LIST
41089: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41090: LD_ADDR_VAR 0 64
41094: PUSH
41095: LD_INT 0
41097: PUSH
41098: LD_INT 0
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: PUSH
41105: LD_INT 0
41107: PUSH
41108: LD_INT 1
41110: NEG
41111: PUSH
41112: EMPTY
41113: LIST
41114: LIST
41115: PUSH
41116: LD_INT 1
41118: PUSH
41119: LD_INT 0
41121: PUSH
41122: EMPTY
41123: LIST
41124: LIST
41125: PUSH
41126: LD_INT 1
41128: PUSH
41129: LD_INT 1
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PUSH
41136: LD_INT 0
41138: PUSH
41139: LD_INT 1
41141: PUSH
41142: EMPTY
41143: LIST
41144: LIST
41145: PUSH
41146: LD_INT 1
41148: NEG
41149: PUSH
41150: LD_INT 0
41152: PUSH
41153: EMPTY
41154: LIST
41155: LIST
41156: PUSH
41157: LD_INT 1
41159: NEG
41160: PUSH
41161: LD_INT 1
41163: NEG
41164: PUSH
41165: EMPTY
41166: LIST
41167: LIST
41168: PUSH
41169: EMPTY
41170: LIST
41171: LIST
41172: LIST
41173: LIST
41174: LIST
41175: LIST
41176: LIST
41177: ST_TO_ADDR
// end ; 1 :
41178: GO 47075
41180: LD_INT 1
41182: DOUBLE
41183: EQUAL
41184: IFTRUE 41188
41186: GO 43811
41188: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41189: LD_ADDR_VAR 0 11
41193: PUSH
41194: LD_INT 1
41196: NEG
41197: PUSH
41198: LD_INT 3
41200: NEG
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PUSH
41206: LD_INT 0
41208: PUSH
41209: LD_INT 3
41211: NEG
41212: PUSH
41213: EMPTY
41214: LIST
41215: LIST
41216: PUSH
41217: LD_INT 1
41219: PUSH
41220: LD_INT 2
41222: NEG
41223: PUSH
41224: EMPTY
41225: LIST
41226: LIST
41227: PUSH
41228: EMPTY
41229: LIST
41230: LIST
41231: LIST
41232: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41233: LD_ADDR_VAR 0 12
41237: PUSH
41238: LD_INT 2
41240: PUSH
41241: LD_INT 1
41243: NEG
41244: PUSH
41245: EMPTY
41246: LIST
41247: LIST
41248: PUSH
41249: LD_INT 3
41251: PUSH
41252: LD_INT 0
41254: PUSH
41255: EMPTY
41256: LIST
41257: LIST
41258: PUSH
41259: LD_INT 3
41261: PUSH
41262: LD_INT 1
41264: PUSH
41265: EMPTY
41266: LIST
41267: LIST
41268: PUSH
41269: EMPTY
41270: LIST
41271: LIST
41272: LIST
41273: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41274: LD_ADDR_VAR 0 13
41278: PUSH
41279: LD_INT 3
41281: PUSH
41282: LD_INT 2
41284: PUSH
41285: EMPTY
41286: LIST
41287: LIST
41288: PUSH
41289: LD_INT 3
41291: PUSH
41292: LD_INT 3
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: PUSH
41299: LD_INT 2
41301: PUSH
41302: LD_INT 3
41304: PUSH
41305: EMPTY
41306: LIST
41307: LIST
41308: PUSH
41309: EMPTY
41310: LIST
41311: LIST
41312: LIST
41313: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41314: LD_ADDR_VAR 0 14
41318: PUSH
41319: LD_INT 1
41321: PUSH
41322: LD_INT 3
41324: PUSH
41325: EMPTY
41326: LIST
41327: LIST
41328: PUSH
41329: LD_INT 0
41331: PUSH
41332: LD_INT 3
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PUSH
41339: LD_INT 1
41341: NEG
41342: PUSH
41343: LD_INT 2
41345: PUSH
41346: EMPTY
41347: LIST
41348: LIST
41349: PUSH
41350: EMPTY
41351: LIST
41352: LIST
41353: LIST
41354: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41355: LD_ADDR_VAR 0 15
41359: PUSH
41360: LD_INT 2
41362: NEG
41363: PUSH
41364: LD_INT 1
41366: PUSH
41367: EMPTY
41368: LIST
41369: LIST
41370: PUSH
41371: LD_INT 3
41373: NEG
41374: PUSH
41375: LD_INT 0
41377: PUSH
41378: EMPTY
41379: LIST
41380: LIST
41381: PUSH
41382: LD_INT 3
41384: NEG
41385: PUSH
41386: LD_INT 1
41388: NEG
41389: PUSH
41390: EMPTY
41391: LIST
41392: LIST
41393: PUSH
41394: EMPTY
41395: LIST
41396: LIST
41397: LIST
41398: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41399: LD_ADDR_VAR 0 16
41403: PUSH
41404: LD_INT 2
41406: NEG
41407: PUSH
41408: LD_INT 3
41410: NEG
41411: PUSH
41412: EMPTY
41413: LIST
41414: LIST
41415: PUSH
41416: LD_INT 3
41418: NEG
41419: PUSH
41420: LD_INT 2
41422: NEG
41423: PUSH
41424: EMPTY
41425: LIST
41426: LIST
41427: PUSH
41428: LD_INT 3
41430: NEG
41431: PUSH
41432: LD_INT 3
41434: NEG
41435: PUSH
41436: EMPTY
41437: LIST
41438: LIST
41439: PUSH
41440: EMPTY
41441: LIST
41442: LIST
41443: LIST
41444: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41445: LD_ADDR_VAR 0 17
41449: PUSH
41450: LD_INT 1
41452: NEG
41453: PUSH
41454: LD_INT 3
41456: NEG
41457: PUSH
41458: EMPTY
41459: LIST
41460: LIST
41461: PUSH
41462: LD_INT 0
41464: PUSH
41465: LD_INT 3
41467: NEG
41468: PUSH
41469: EMPTY
41470: LIST
41471: LIST
41472: PUSH
41473: LD_INT 1
41475: PUSH
41476: LD_INT 2
41478: NEG
41479: PUSH
41480: EMPTY
41481: LIST
41482: LIST
41483: PUSH
41484: EMPTY
41485: LIST
41486: LIST
41487: LIST
41488: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41489: LD_ADDR_VAR 0 18
41493: PUSH
41494: LD_INT 2
41496: PUSH
41497: LD_INT 1
41499: NEG
41500: PUSH
41501: EMPTY
41502: LIST
41503: LIST
41504: PUSH
41505: LD_INT 3
41507: PUSH
41508: LD_INT 0
41510: PUSH
41511: EMPTY
41512: LIST
41513: LIST
41514: PUSH
41515: LD_INT 3
41517: PUSH
41518: LD_INT 1
41520: PUSH
41521: EMPTY
41522: LIST
41523: LIST
41524: PUSH
41525: EMPTY
41526: LIST
41527: LIST
41528: LIST
41529: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41530: LD_ADDR_VAR 0 19
41534: PUSH
41535: LD_INT 3
41537: PUSH
41538: LD_INT 2
41540: PUSH
41541: EMPTY
41542: LIST
41543: LIST
41544: PUSH
41545: LD_INT 3
41547: PUSH
41548: LD_INT 3
41550: PUSH
41551: EMPTY
41552: LIST
41553: LIST
41554: PUSH
41555: LD_INT 2
41557: PUSH
41558: LD_INT 3
41560: PUSH
41561: EMPTY
41562: LIST
41563: LIST
41564: PUSH
41565: EMPTY
41566: LIST
41567: LIST
41568: LIST
41569: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41570: LD_ADDR_VAR 0 20
41574: PUSH
41575: LD_INT 1
41577: PUSH
41578: LD_INT 3
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: PUSH
41585: LD_INT 0
41587: PUSH
41588: LD_INT 3
41590: PUSH
41591: EMPTY
41592: LIST
41593: LIST
41594: PUSH
41595: LD_INT 1
41597: NEG
41598: PUSH
41599: LD_INT 2
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: LIST
41610: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41611: LD_ADDR_VAR 0 21
41615: PUSH
41616: LD_INT 2
41618: NEG
41619: PUSH
41620: LD_INT 1
41622: PUSH
41623: EMPTY
41624: LIST
41625: LIST
41626: PUSH
41627: LD_INT 3
41629: NEG
41630: PUSH
41631: LD_INT 0
41633: PUSH
41634: EMPTY
41635: LIST
41636: LIST
41637: PUSH
41638: LD_INT 3
41640: NEG
41641: PUSH
41642: LD_INT 1
41644: NEG
41645: PUSH
41646: EMPTY
41647: LIST
41648: LIST
41649: PUSH
41650: EMPTY
41651: LIST
41652: LIST
41653: LIST
41654: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41655: LD_ADDR_VAR 0 22
41659: PUSH
41660: LD_INT 2
41662: NEG
41663: PUSH
41664: LD_INT 3
41666: NEG
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: PUSH
41672: LD_INT 3
41674: NEG
41675: PUSH
41676: LD_INT 2
41678: NEG
41679: PUSH
41680: EMPTY
41681: LIST
41682: LIST
41683: PUSH
41684: LD_INT 3
41686: NEG
41687: PUSH
41688: LD_INT 3
41690: NEG
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: EMPTY
41697: LIST
41698: LIST
41699: LIST
41700: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41701: LD_ADDR_VAR 0 23
41705: PUSH
41706: LD_INT 0
41708: PUSH
41709: LD_INT 3
41711: NEG
41712: PUSH
41713: EMPTY
41714: LIST
41715: LIST
41716: PUSH
41717: LD_INT 1
41719: NEG
41720: PUSH
41721: LD_INT 4
41723: NEG
41724: PUSH
41725: EMPTY
41726: LIST
41727: LIST
41728: PUSH
41729: LD_INT 1
41731: PUSH
41732: LD_INT 3
41734: NEG
41735: PUSH
41736: EMPTY
41737: LIST
41738: LIST
41739: PUSH
41740: EMPTY
41741: LIST
41742: LIST
41743: LIST
41744: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41745: LD_ADDR_VAR 0 24
41749: PUSH
41750: LD_INT 3
41752: PUSH
41753: LD_INT 0
41755: PUSH
41756: EMPTY
41757: LIST
41758: LIST
41759: PUSH
41760: LD_INT 3
41762: PUSH
41763: LD_INT 1
41765: NEG
41766: PUSH
41767: EMPTY
41768: LIST
41769: LIST
41770: PUSH
41771: LD_INT 4
41773: PUSH
41774: LD_INT 1
41776: PUSH
41777: EMPTY
41778: LIST
41779: LIST
41780: PUSH
41781: EMPTY
41782: LIST
41783: LIST
41784: LIST
41785: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41786: LD_ADDR_VAR 0 25
41790: PUSH
41791: LD_INT 3
41793: PUSH
41794: LD_INT 3
41796: PUSH
41797: EMPTY
41798: LIST
41799: LIST
41800: PUSH
41801: LD_INT 4
41803: PUSH
41804: LD_INT 3
41806: PUSH
41807: EMPTY
41808: LIST
41809: LIST
41810: PUSH
41811: LD_INT 3
41813: PUSH
41814: LD_INT 4
41816: PUSH
41817: EMPTY
41818: LIST
41819: LIST
41820: PUSH
41821: EMPTY
41822: LIST
41823: LIST
41824: LIST
41825: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41826: LD_ADDR_VAR 0 26
41830: PUSH
41831: LD_INT 0
41833: PUSH
41834: LD_INT 3
41836: PUSH
41837: EMPTY
41838: LIST
41839: LIST
41840: PUSH
41841: LD_INT 1
41843: PUSH
41844: LD_INT 4
41846: PUSH
41847: EMPTY
41848: LIST
41849: LIST
41850: PUSH
41851: LD_INT 1
41853: NEG
41854: PUSH
41855: LD_INT 3
41857: PUSH
41858: EMPTY
41859: LIST
41860: LIST
41861: PUSH
41862: EMPTY
41863: LIST
41864: LIST
41865: LIST
41866: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41867: LD_ADDR_VAR 0 27
41871: PUSH
41872: LD_INT 3
41874: NEG
41875: PUSH
41876: LD_INT 0
41878: PUSH
41879: EMPTY
41880: LIST
41881: LIST
41882: PUSH
41883: LD_INT 3
41885: NEG
41886: PUSH
41887: LD_INT 1
41889: PUSH
41890: EMPTY
41891: LIST
41892: LIST
41893: PUSH
41894: LD_INT 4
41896: NEG
41897: PUSH
41898: LD_INT 1
41900: NEG
41901: PUSH
41902: EMPTY
41903: LIST
41904: LIST
41905: PUSH
41906: EMPTY
41907: LIST
41908: LIST
41909: LIST
41910: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41911: LD_ADDR_VAR 0 28
41915: PUSH
41916: LD_INT 3
41918: NEG
41919: PUSH
41920: LD_INT 3
41922: NEG
41923: PUSH
41924: EMPTY
41925: LIST
41926: LIST
41927: PUSH
41928: LD_INT 3
41930: NEG
41931: PUSH
41932: LD_INT 4
41934: NEG
41935: PUSH
41936: EMPTY
41937: LIST
41938: LIST
41939: PUSH
41940: LD_INT 4
41942: NEG
41943: PUSH
41944: LD_INT 3
41946: NEG
41947: PUSH
41948: EMPTY
41949: LIST
41950: LIST
41951: PUSH
41952: EMPTY
41953: LIST
41954: LIST
41955: LIST
41956: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41957: LD_ADDR_VAR 0 29
41961: PUSH
41962: LD_INT 1
41964: NEG
41965: PUSH
41966: LD_INT 3
41968: NEG
41969: PUSH
41970: EMPTY
41971: LIST
41972: LIST
41973: PUSH
41974: LD_INT 0
41976: PUSH
41977: LD_INT 3
41979: NEG
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: LD_INT 1
41987: PUSH
41988: LD_INT 2
41990: NEG
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: PUSH
41996: LD_INT 1
41998: NEG
41999: PUSH
42000: LD_INT 4
42002: NEG
42003: PUSH
42004: EMPTY
42005: LIST
42006: LIST
42007: PUSH
42008: LD_INT 0
42010: PUSH
42011: LD_INT 4
42013: NEG
42014: PUSH
42015: EMPTY
42016: LIST
42017: LIST
42018: PUSH
42019: LD_INT 1
42021: PUSH
42022: LD_INT 3
42024: NEG
42025: PUSH
42026: EMPTY
42027: LIST
42028: LIST
42029: PUSH
42030: LD_INT 1
42032: NEG
42033: PUSH
42034: LD_INT 5
42036: NEG
42037: PUSH
42038: EMPTY
42039: LIST
42040: LIST
42041: PUSH
42042: LD_INT 0
42044: PUSH
42045: LD_INT 5
42047: NEG
42048: PUSH
42049: EMPTY
42050: LIST
42051: LIST
42052: PUSH
42053: LD_INT 1
42055: PUSH
42056: LD_INT 4
42058: NEG
42059: PUSH
42060: EMPTY
42061: LIST
42062: LIST
42063: PUSH
42064: LD_INT 1
42066: NEG
42067: PUSH
42068: LD_INT 6
42070: NEG
42071: PUSH
42072: EMPTY
42073: LIST
42074: LIST
42075: PUSH
42076: LD_INT 0
42078: PUSH
42079: LD_INT 6
42081: NEG
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: PUSH
42087: LD_INT 1
42089: PUSH
42090: LD_INT 5
42092: NEG
42093: PUSH
42094: EMPTY
42095: LIST
42096: LIST
42097: PUSH
42098: EMPTY
42099: LIST
42100: LIST
42101: LIST
42102: LIST
42103: LIST
42104: LIST
42105: LIST
42106: LIST
42107: LIST
42108: LIST
42109: LIST
42110: LIST
42111: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
42112: LD_ADDR_VAR 0 30
42116: PUSH
42117: LD_INT 2
42119: PUSH
42120: LD_INT 1
42122: NEG
42123: PUSH
42124: EMPTY
42125: LIST
42126: LIST
42127: PUSH
42128: LD_INT 3
42130: PUSH
42131: LD_INT 0
42133: PUSH
42134: EMPTY
42135: LIST
42136: LIST
42137: PUSH
42138: LD_INT 3
42140: PUSH
42141: LD_INT 1
42143: PUSH
42144: EMPTY
42145: LIST
42146: LIST
42147: PUSH
42148: LD_INT 3
42150: PUSH
42151: LD_INT 1
42153: NEG
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: LD_INT 4
42161: PUSH
42162: LD_INT 0
42164: PUSH
42165: EMPTY
42166: LIST
42167: LIST
42168: PUSH
42169: LD_INT 4
42171: PUSH
42172: LD_INT 1
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: PUSH
42179: LD_INT 4
42181: PUSH
42182: LD_INT 1
42184: NEG
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 5
42192: PUSH
42193: LD_INT 0
42195: PUSH
42196: EMPTY
42197: LIST
42198: LIST
42199: PUSH
42200: LD_INT 5
42202: PUSH
42203: LD_INT 1
42205: PUSH
42206: EMPTY
42207: LIST
42208: LIST
42209: PUSH
42210: LD_INT 5
42212: PUSH
42213: LD_INT 1
42215: NEG
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 6
42223: PUSH
42224: LD_INT 0
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: LD_INT 6
42233: PUSH
42234: LD_INT 1
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: EMPTY
42242: LIST
42243: LIST
42244: LIST
42245: LIST
42246: LIST
42247: LIST
42248: LIST
42249: LIST
42250: LIST
42251: LIST
42252: LIST
42253: LIST
42254: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
42255: LD_ADDR_VAR 0 31
42259: PUSH
42260: LD_INT 3
42262: PUSH
42263: LD_INT 2
42265: PUSH
42266: EMPTY
42267: LIST
42268: LIST
42269: PUSH
42270: LD_INT 3
42272: PUSH
42273: LD_INT 3
42275: PUSH
42276: EMPTY
42277: LIST
42278: LIST
42279: PUSH
42280: LD_INT 2
42282: PUSH
42283: LD_INT 3
42285: PUSH
42286: EMPTY
42287: LIST
42288: LIST
42289: PUSH
42290: LD_INT 4
42292: PUSH
42293: LD_INT 3
42295: PUSH
42296: EMPTY
42297: LIST
42298: LIST
42299: PUSH
42300: LD_INT 4
42302: PUSH
42303: LD_INT 4
42305: PUSH
42306: EMPTY
42307: LIST
42308: LIST
42309: PUSH
42310: LD_INT 3
42312: PUSH
42313: LD_INT 4
42315: PUSH
42316: EMPTY
42317: LIST
42318: LIST
42319: PUSH
42320: LD_INT 5
42322: PUSH
42323: LD_INT 4
42325: PUSH
42326: EMPTY
42327: LIST
42328: LIST
42329: PUSH
42330: LD_INT 5
42332: PUSH
42333: LD_INT 5
42335: PUSH
42336: EMPTY
42337: LIST
42338: LIST
42339: PUSH
42340: LD_INT 4
42342: PUSH
42343: LD_INT 5
42345: PUSH
42346: EMPTY
42347: LIST
42348: LIST
42349: PUSH
42350: LD_INT 6
42352: PUSH
42353: LD_INT 5
42355: PUSH
42356: EMPTY
42357: LIST
42358: LIST
42359: PUSH
42360: LD_INT 6
42362: PUSH
42363: LD_INT 6
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: LD_INT 5
42372: PUSH
42373: LD_INT 6
42375: PUSH
42376: EMPTY
42377: LIST
42378: LIST
42379: PUSH
42380: EMPTY
42381: LIST
42382: LIST
42383: LIST
42384: LIST
42385: LIST
42386: LIST
42387: LIST
42388: LIST
42389: LIST
42390: LIST
42391: LIST
42392: LIST
42393: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42394: LD_ADDR_VAR 0 32
42398: PUSH
42399: LD_INT 1
42401: PUSH
42402: LD_INT 3
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: PUSH
42409: LD_INT 0
42411: PUSH
42412: LD_INT 3
42414: PUSH
42415: EMPTY
42416: LIST
42417: LIST
42418: PUSH
42419: LD_INT 1
42421: NEG
42422: PUSH
42423: LD_INT 2
42425: PUSH
42426: EMPTY
42427: LIST
42428: LIST
42429: PUSH
42430: LD_INT 1
42432: PUSH
42433: LD_INT 4
42435: PUSH
42436: EMPTY
42437: LIST
42438: LIST
42439: PUSH
42440: LD_INT 0
42442: PUSH
42443: LD_INT 4
42445: PUSH
42446: EMPTY
42447: LIST
42448: LIST
42449: PUSH
42450: LD_INT 1
42452: NEG
42453: PUSH
42454: LD_INT 3
42456: PUSH
42457: EMPTY
42458: LIST
42459: LIST
42460: PUSH
42461: LD_INT 1
42463: PUSH
42464: LD_INT 5
42466: PUSH
42467: EMPTY
42468: LIST
42469: LIST
42470: PUSH
42471: LD_INT 0
42473: PUSH
42474: LD_INT 5
42476: PUSH
42477: EMPTY
42478: LIST
42479: LIST
42480: PUSH
42481: LD_INT 1
42483: NEG
42484: PUSH
42485: LD_INT 4
42487: PUSH
42488: EMPTY
42489: LIST
42490: LIST
42491: PUSH
42492: LD_INT 1
42494: PUSH
42495: LD_INT 6
42497: PUSH
42498: EMPTY
42499: LIST
42500: LIST
42501: PUSH
42502: LD_INT 0
42504: PUSH
42505: LD_INT 6
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 1
42514: NEG
42515: PUSH
42516: LD_INT 5
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: PUSH
42523: EMPTY
42524: LIST
42525: LIST
42526: LIST
42527: LIST
42528: LIST
42529: LIST
42530: LIST
42531: LIST
42532: LIST
42533: LIST
42534: LIST
42535: LIST
42536: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42537: LD_ADDR_VAR 0 33
42541: PUSH
42542: LD_INT 2
42544: NEG
42545: PUSH
42546: LD_INT 1
42548: PUSH
42549: EMPTY
42550: LIST
42551: LIST
42552: PUSH
42553: LD_INT 3
42555: NEG
42556: PUSH
42557: LD_INT 0
42559: PUSH
42560: EMPTY
42561: LIST
42562: LIST
42563: PUSH
42564: LD_INT 3
42566: NEG
42567: PUSH
42568: LD_INT 1
42570: NEG
42571: PUSH
42572: EMPTY
42573: LIST
42574: LIST
42575: PUSH
42576: LD_INT 3
42578: NEG
42579: PUSH
42580: LD_INT 1
42582: PUSH
42583: EMPTY
42584: LIST
42585: LIST
42586: PUSH
42587: LD_INT 4
42589: NEG
42590: PUSH
42591: LD_INT 0
42593: PUSH
42594: EMPTY
42595: LIST
42596: LIST
42597: PUSH
42598: LD_INT 4
42600: NEG
42601: PUSH
42602: LD_INT 1
42604: NEG
42605: PUSH
42606: EMPTY
42607: LIST
42608: LIST
42609: PUSH
42610: LD_INT 4
42612: NEG
42613: PUSH
42614: LD_INT 1
42616: PUSH
42617: EMPTY
42618: LIST
42619: LIST
42620: PUSH
42621: LD_INT 5
42623: NEG
42624: PUSH
42625: LD_INT 0
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: PUSH
42632: LD_INT 5
42634: NEG
42635: PUSH
42636: LD_INT 1
42638: NEG
42639: PUSH
42640: EMPTY
42641: LIST
42642: LIST
42643: PUSH
42644: LD_INT 5
42646: NEG
42647: PUSH
42648: LD_INT 1
42650: PUSH
42651: EMPTY
42652: LIST
42653: LIST
42654: PUSH
42655: LD_INT 6
42657: NEG
42658: PUSH
42659: LD_INT 0
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PUSH
42666: LD_INT 6
42668: NEG
42669: PUSH
42670: LD_INT 1
42672: NEG
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: LIST
42682: LIST
42683: LIST
42684: LIST
42685: LIST
42686: LIST
42687: LIST
42688: LIST
42689: LIST
42690: LIST
42691: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42692: LD_ADDR_VAR 0 34
42696: PUSH
42697: LD_INT 2
42699: NEG
42700: PUSH
42701: LD_INT 3
42703: NEG
42704: PUSH
42705: EMPTY
42706: LIST
42707: LIST
42708: PUSH
42709: LD_INT 3
42711: NEG
42712: PUSH
42713: LD_INT 2
42715: NEG
42716: PUSH
42717: EMPTY
42718: LIST
42719: LIST
42720: PUSH
42721: LD_INT 3
42723: NEG
42724: PUSH
42725: LD_INT 3
42727: NEG
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: LD_INT 3
42735: NEG
42736: PUSH
42737: LD_INT 4
42739: NEG
42740: PUSH
42741: EMPTY
42742: LIST
42743: LIST
42744: PUSH
42745: LD_INT 4
42747: NEG
42748: PUSH
42749: LD_INT 3
42751: NEG
42752: PUSH
42753: EMPTY
42754: LIST
42755: LIST
42756: PUSH
42757: LD_INT 4
42759: NEG
42760: PUSH
42761: LD_INT 4
42763: NEG
42764: PUSH
42765: EMPTY
42766: LIST
42767: LIST
42768: PUSH
42769: LD_INT 4
42771: NEG
42772: PUSH
42773: LD_INT 5
42775: NEG
42776: PUSH
42777: EMPTY
42778: LIST
42779: LIST
42780: PUSH
42781: LD_INT 5
42783: NEG
42784: PUSH
42785: LD_INT 4
42787: NEG
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: PUSH
42793: LD_INT 5
42795: NEG
42796: PUSH
42797: LD_INT 5
42799: NEG
42800: PUSH
42801: EMPTY
42802: LIST
42803: LIST
42804: PUSH
42805: LD_INT 5
42807: NEG
42808: PUSH
42809: LD_INT 6
42811: NEG
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: PUSH
42817: LD_INT 6
42819: NEG
42820: PUSH
42821: LD_INT 5
42823: NEG
42824: PUSH
42825: EMPTY
42826: LIST
42827: LIST
42828: PUSH
42829: LD_INT 6
42831: NEG
42832: PUSH
42833: LD_INT 6
42835: NEG
42836: PUSH
42837: EMPTY
42838: LIST
42839: LIST
42840: PUSH
42841: EMPTY
42842: LIST
42843: LIST
42844: LIST
42845: LIST
42846: LIST
42847: LIST
42848: LIST
42849: LIST
42850: LIST
42851: LIST
42852: LIST
42853: LIST
42854: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42855: LD_ADDR_VAR 0 41
42859: PUSH
42860: LD_INT 0
42862: PUSH
42863: LD_INT 2
42865: NEG
42866: PUSH
42867: EMPTY
42868: LIST
42869: LIST
42870: PUSH
42871: LD_INT 1
42873: NEG
42874: PUSH
42875: LD_INT 3
42877: NEG
42878: PUSH
42879: EMPTY
42880: LIST
42881: LIST
42882: PUSH
42883: LD_INT 1
42885: PUSH
42886: LD_INT 2
42888: NEG
42889: PUSH
42890: EMPTY
42891: LIST
42892: LIST
42893: PUSH
42894: EMPTY
42895: LIST
42896: LIST
42897: LIST
42898: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42899: LD_ADDR_VAR 0 42
42903: PUSH
42904: LD_INT 2
42906: PUSH
42907: LD_INT 0
42909: PUSH
42910: EMPTY
42911: LIST
42912: LIST
42913: PUSH
42914: LD_INT 2
42916: PUSH
42917: LD_INT 1
42919: NEG
42920: PUSH
42921: EMPTY
42922: LIST
42923: LIST
42924: PUSH
42925: LD_INT 3
42927: PUSH
42928: LD_INT 1
42930: PUSH
42931: EMPTY
42932: LIST
42933: LIST
42934: PUSH
42935: EMPTY
42936: LIST
42937: LIST
42938: LIST
42939: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42940: LD_ADDR_VAR 0 43
42944: PUSH
42945: LD_INT 2
42947: PUSH
42948: LD_INT 2
42950: PUSH
42951: EMPTY
42952: LIST
42953: LIST
42954: PUSH
42955: LD_INT 3
42957: PUSH
42958: LD_INT 2
42960: PUSH
42961: EMPTY
42962: LIST
42963: LIST
42964: PUSH
42965: LD_INT 2
42967: PUSH
42968: LD_INT 3
42970: PUSH
42971: EMPTY
42972: LIST
42973: LIST
42974: PUSH
42975: EMPTY
42976: LIST
42977: LIST
42978: LIST
42979: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42980: LD_ADDR_VAR 0 44
42984: PUSH
42985: LD_INT 0
42987: PUSH
42988: LD_INT 2
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: PUSH
42995: LD_INT 1
42997: PUSH
42998: LD_INT 3
43000: PUSH
43001: EMPTY
43002: LIST
43003: LIST
43004: PUSH
43005: LD_INT 1
43007: NEG
43008: PUSH
43009: LD_INT 2
43011: PUSH
43012: EMPTY
43013: LIST
43014: LIST
43015: PUSH
43016: EMPTY
43017: LIST
43018: LIST
43019: LIST
43020: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
43021: LD_ADDR_VAR 0 45
43025: PUSH
43026: LD_INT 2
43028: NEG
43029: PUSH
43030: LD_INT 0
43032: PUSH
43033: EMPTY
43034: LIST
43035: LIST
43036: PUSH
43037: LD_INT 2
43039: NEG
43040: PUSH
43041: LD_INT 1
43043: PUSH
43044: EMPTY
43045: LIST
43046: LIST
43047: PUSH
43048: LD_INT 3
43050: NEG
43051: PUSH
43052: LD_INT 1
43054: NEG
43055: PUSH
43056: EMPTY
43057: LIST
43058: LIST
43059: PUSH
43060: EMPTY
43061: LIST
43062: LIST
43063: LIST
43064: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
43065: LD_ADDR_VAR 0 46
43069: PUSH
43070: LD_INT 2
43072: NEG
43073: PUSH
43074: LD_INT 2
43076: NEG
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: PUSH
43082: LD_INT 2
43084: NEG
43085: PUSH
43086: LD_INT 3
43088: NEG
43089: PUSH
43090: EMPTY
43091: LIST
43092: LIST
43093: PUSH
43094: LD_INT 3
43096: NEG
43097: PUSH
43098: LD_INT 2
43100: NEG
43101: PUSH
43102: EMPTY
43103: LIST
43104: LIST
43105: PUSH
43106: EMPTY
43107: LIST
43108: LIST
43109: LIST
43110: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
43111: LD_ADDR_VAR 0 47
43115: PUSH
43116: LD_INT 2
43118: NEG
43119: PUSH
43120: LD_INT 3
43122: NEG
43123: PUSH
43124: EMPTY
43125: LIST
43126: LIST
43127: PUSH
43128: LD_INT 1
43130: NEG
43131: PUSH
43132: LD_INT 3
43134: NEG
43135: PUSH
43136: EMPTY
43137: LIST
43138: LIST
43139: PUSH
43140: EMPTY
43141: LIST
43142: LIST
43143: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
43144: LD_ADDR_VAR 0 48
43148: PUSH
43149: LD_INT 1
43151: PUSH
43152: LD_INT 2
43154: NEG
43155: PUSH
43156: EMPTY
43157: LIST
43158: LIST
43159: PUSH
43160: LD_INT 2
43162: PUSH
43163: LD_INT 1
43165: NEG
43166: PUSH
43167: EMPTY
43168: LIST
43169: LIST
43170: PUSH
43171: EMPTY
43172: LIST
43173: LIST
43174: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
43175: LD_ADDR_VAR 0 49
43179: PUSH
43180: LD_INT 3
43182: PUSH
43183: LD_INT 1
43185: PUSH
43186: EMPTY
43187: LIST
43188: LIST
43189: PUSH
43190: LD_INT 3
43192: PUSH
43193: LD_INT 2
43195: PUSH
43196: EMPTY
43197: LIST
43198: LIST
43199: PUSH
43200: EMPTY
43201: LIST
43202: LIST
43203: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
43204: LD_ADDR_VAR 0 50
43208: PUSH
43209: LD_INT 2
43211: PUSH
43212: LD_INT 3
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: PUSH
43219: LD_INT 1
43221: PUSH
43222: LD_INT 3
43224: PUSH
43225: EMPTY
43226: LIST
43227: LIST
43228: PUSH
43229: EMPTY
43230: LIST
43231: LIST
43232: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
43233: LD_ADDR_VAR 0 51
43237: PUSH
43238: LD_INT 1
43240: NEG
43241: PUSH
43242: LD_INT 2
43244: PUSH
43245: EMPTY
43246: LIST
43247: LIST
43248: PUSH
43249: LD_INT 2
43251: NEG
43252: PUSH
43253: LD_INT 1
43255: PUSH
43256: EMPTY
43257: LIST
43258: LIST
43259: PUSH
43260: EMPTY
43261: LIST
43262: LIST
43263: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
43264: LD_ADDR_VAR 0 52
43268: PUSH
43269: LD_INT 3
43271: NEG
43272: PUSH
43273: LD_INT 1
43275: NEG
43276: PUSH
43277: EMPTY
43278: LIST
43279: LIST
43280: PUSH
43281: LD_INT 3
43283: NEG
43284: PUSH
43285: LD_INT 2
43287: NEG
43288: PUSH
43289: EMPTY
43290: LIST
43291: LIST
43292: PUSH
43293: EMPTY
43294: LIST
43295: LIST
43296: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43297: LD_ADDR_VAR 0 53
43301: PUSH
43302: LD_INT 1
43304: NEG
43305: PUSH
43306: LD_INT 3
43308: NEG
43309: PUSH
43310: EMPTY
43311: LIST
43312: LIST
43313: PUSH
43314: LD_INT 0
43316: PUSH
43317: LD_INT 3
43319: NEG
43320: PUSH
43321: EMPTY
43322: LIST
43323: LIST
43324: PUSH
43325: LD_INT 1
43327: PUSH
43328: LD_INT 2
43330: NEG
43331: PUSH
43332: EMPTY
43333: LIST
43334: LIST
43335: PUSH
43336: EMPTY
43337: LIST
43338: LIST
43339: LIST
43340: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43341: LD_ADDR_VAR 0 54
43345: PUSH
43346: LD_INT 2
43348: PUSH
43349: LD_INT 1
43351: NEG
43352: PUSH
43353: EMPTY
43354: LIST
43355: LIST
43356: PUSH
43357: LD_INT 3
43359: PUSH
43360: LD_INT 0
43362: PUSH
43363: EMPTY
43364: LIST
43365: LIST
43366: PUSH
43367: LD_INT 3
43369: PUSH
43370: LD_INT 1
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: EMPTY
43378: LIST
43379: LIST
43380: LIST
43381: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43382: LD_ADDR_VAR 0 55
43386: PUSH
43387: LD_INT 3
43389: PUSH
43390: LD_INT 2
43392: PUSH
43393: EMPTY
43394: LIST
43395: LIST
43396: PUSH
43397: LD_INT 3
43399: PUSH
43400: LD_INT 3
43402: PUSH
43403: EMPTY
43404: LIST
43405: LIST
43406: PUSH
43407: LD_INT 2
43409: PUSH
43410: LD_INT 3
43412: PUSH
43413: EMPTY
43414: LIST
43415: LIST
43416: PUSH
43417: EMPTY
43418: LIST
43419: LIST
43420: LIST
43421: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43422: LD_ADDR_VAR 0 56
43426: PUSH
43427: LD_INT 1
43429: PUSH
43430: LD_INT 3
43432: PUSH
43433: EMPTY
43434: LIST
43435: LIST
43436: PUSH
43437: LD_INT 0
43439: PUSH
43440: LD_INT 3
43442: PUSH
43443: EMPTY
43444: LIST
43445: LIST
43446: PUSH
43447: LD_INT 1
43449: NEG
43450: PUSH
43451: LD_INT 2
43453: PUSH
43454: EMPTY
43455: LIST
43456: LIST
43457: PUSH
43458: EMPTY
43459: LIST
43460: LIST
43461: LIST
43462: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43463: LD_ADDR_VAR 0 57
43467: PUSH
43468: LD_INT 2
43470: NEG
43471: PUSH
43472: LD_INT 1
43474: PUSH
43475: EMPTY
43476: LIST
43477: LIST
43478: PUSH
43479: LD_INT 3
43481: NEG
43482: PUSH
43483: LD_INT 0
43485: PUSH
43486: EMPTY
43487: LIST
43488: LIST
43489: PUSH
43490: LD_INT 3
43492: NEG
43493: PUSH
43494: LD_INT 1
43496: NEG
43497: PUSH
43498: EMPTY
43499: LIST
43500: LIST
43501: PUSH
43502: EMPTY
43503: LIST
43504: LIST
43505: LIST
43506: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43507: LD_ADDR_VAR 0 58
43511: PUSH
43512: LD_INT 2
43514: NEG
43515: PUSH
43516: LD_INT 3
43518: NEG
43519: PUSH
43520: EMPTY
43521: LIST
43522: LIST
43523: PUSH
43524: LD_INT 3
43526: NEG
43527: PUSH
43528: LD_INT 2
43530: NEG
43531: PUSH
43532: EMPTY
43533: LIST
43534: LIST
43535: PUSH
43536: LD_INT 3
43538: NEG
43539: PUSH
43540: LD_INT 3
43542: NEG
43543: PUSH
43544: EMPTY
43545: LIST
43546: LIST
43547: PUSH
43548: EMPTY
43549: LIST
43550: LIST
43551: LIST
43552: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43553: LD_ADDR_VAR 0 59
43557: PUSH
43558: LD_INT 1
43560: NEG
43561: PUSH
43562: LD_INT 2
43564: NEG
43565: PUSH
43566: EMPTY
43567: LIST
43568: LIST
43569: PUSH
43570: LD_INT 0
43572: PUSH
43573: LD_INT 2
43575: NEG
43576: PUSH
43577: EMPTY
43578: LIST
43579: LIST
43580: PUSH
43581: LD_INT 1
43583: PUSH
43584: LD_INT 1
43586: NEG
43587: PUSH
43588: EMPTY
43589: LIST
43590: LIST
43591: PUSH
43592: EMPTY
43593: LIST
43594: LIST
43595: LIST
43596: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43597: LD_ADDR_VAR 0 60
43601: PUSH
43602: LD_INT 1
43604: PUSH
43605: LD_INT 1
43607: NEG
43608: PUSH
43609: EMPTY
43610: LIST
43611: LIST
43612: PUSH
43613: LD_INT 2
43615: PUSH
43616: LD_INT 0
43618: PUSH
43619: EMPTY
43620: LIST
43621: LIST
43622: PUSH
43623: LD_INT 2
43625: PUSH
43626: LD_INT 1
43628: PUSH
43629: EMPTY
43630: LIST
43631: LIST
43632: PUSH
43633: EMPTY
43634: LIST
43635: LIST
43636: LIST
43637: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43638: LD_ADDR_VAR 0 61
43642: PUSH
43643: LD_INT 2
43645: PUSH
43646: LD_INT 1
43648: PUSH
43649: EMPTY
43650: LIST
43651: LIST
43652: PUSH
43653: LD_INT 2
43655: PUSH
43656: LD_INT 2
43658: PUSH
43659: EMPTY
43660: LIST
43661: LIST
43662: PUSH
43663: LD_INT 1
43665: PUSH
43666: LD_INT 2
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: EMPTY
43674: LIST
43675: LIST
43676: LIST
43677: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43678: LD_ADDR_VAR 0 62
43682: PUSH
43683: LD_INT 1
43685: PUSH
43686: LD_INT 2
43688: PUSH
43689: EMPTY
43690: LIST
43691: LIST
43692: PUSH
43693: LD_INT 0
43695: PUSH
43696: LD_INT 2
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: PUSH
43703: LD_INT 1
43705: NEG
43706: PUSH
43707: LD_INT 1
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: LIST
43718: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43719: LD_ADDR_VAR 0 63
43723: PUSH
43724: LD_INT 1
43726: NEG
43727: PUSH
43728: LD_INT 1
43730: PUSH
43731: EMPTY
43732: LIST
43733: LIST
43734: PUSH
43735: LD_INT 2
43737: NEG
43738: PUSH
43739: LD_INT 0
43741: PUSH
43742: EMPTY
43743: LIST
43744: LIST
43745: PUSH
43746: LD_INT 2
43748: NEG
43749: PUSH
43750: LD_INT 1
43752: NEG
43753: PUSH
43754: EMPTY
43755: LIST
43756: LIST
43757: PUSH
43758: EMPTY
43759: LIST
43760: LIST
43761: LIST
43762: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43763: LD_ADDR_VAR 0 64
43767: PUSH
43768: LD_INT 1
43770: NEG
43771: PUSH
43772: LD_INT 2
43774: NEG
43775: PUSH
43776: EMPTY
43777: LIST
43778: LIST
43779: PUSH
43780: LD_INT 2
43782: NEG
43783: PUSH
43784: LD_INT 1
43786: NEG
43787: PUSH
43788: EMPTY
43789: LIST
43790: LIST
43791: PUSH
43792: LD_INT 2
43794: NEG
43795: PUSH
43796: LD_INT 2
43798: NEG
43799: PUSH
43800: EMPTY
43801: LIST
43802: LIST
43803: PUSH
43804: EMPTY
43805: LIST
43806: LIST
43807: LIST
43808: ST_TO_ADDR
// end ; 2 :
43809: GO 47075
43811: LD_INT 2
43813: DOUBLE
43814: EQUAL
43815: IFTRUE 43819
43817: GO 47074
43819: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43820: LD_ADDR_VAR 0 29
43824: PUSH
43825: LD_INT 4
43827: PUSH
43828: LD_INT 0
43830: PUSH
43831: EMPTY
43832: LIST
43833: LIST
43834: PUSH
43835: LD_INT 4
43837: PUSH
43838: LD_INT 1
43840: NEG
43841: PUSH
43842: EMPTY
43843: LIST
43844: LIST
43845: PUSH
43846: LD_INT 5
43848: PUSH
43849: LD_INT 0
43851: PUSH
43852: EMPTY
43853: LIST
43854: LIST
43855: PUSH
43856: LD_INT 5
43858: PUSH
43859: LD_INT 1
43861: PUSH
43862: EMPTY
43863: LIST
43864: LIST
43865: PUSH
43866: LD_INT 4
43868: PUSH
43869: LD_INT 1
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: PUSH
43876: LD_INT 3
43878: PUSH
43879: LD_INT 0
43881: PUSH
43882: EMPTY
43883: LIST
43884: LIST
43885: PUSH
43886: LD_INT 3
43888: PUSH
43889: LD_INT 1
43891: NEG
43892: PUSH
43893: EMPTY
43894: LIST
43895: LIST
43896: PUSH
43897: LD_INT 3
43899: PUSH
43900: LD_INT 2
43902: NEG
43903: PUSH
43904: EMPTY
43905: LIST
43906: LIST
43907: PUSH
43908: LD_INT 5
43910: PUSH
43911: LD_INT 2
43913: PUSH
43914: EMPTY
43915: LIST
43916: LIST
43917: PUSH
43918: LD_INT 3
43920: PUSH
43921: LD_INT 3
43923: PUSH
43924: EMPTY
43925: LIST
43926: LIST
43927: PUSH
43928: LD_INT 3
43930: PUSH
43931: LD_INT 2
43933: PUSH
43934: EMPTY
43935: LIST
43936: LIST
43937: PUSH
43938: LD_INT 4
43940: PUSH
43941: LD_INT 3
43943: PUSH
43944: EMPTY
43945: LIST
43946: LIST
43947: PUSH
43948: LD_INT 4
43950: PUSH
43951: LD_INT 4
43953: PUSH
43954: EMPTY
43955: LIST
43956: LIST
43957: PUSH
43958: LD_INT 3
43960: PUSH
43961: LD_INT 4
43963: PUSH
43964: EMPTY
43965: LIST
43966: LIST
43967: PUSH
43968: LD_INT 2
43970: PUSH
43971: LD_INT 3
43973: PUSH
43974: EMPTY
43975: LIST
43976: LIST
43977: PUSH
43978: LD_INT 2
43980: PUSH
43981: LD_INT 2
43983: PUSH
43984: EMPTY
43985: LIST
43986: LIST
43987: PUSH
43988: LD_INT 4
43990: PUSH
43991: LD_INT 2
43993: PUSH
43994: EMPTY
43995: LIST
43996: LIST
43997: PUSH
43998: LD_INT 2
44000: PUSH
44001: LD_INT 4
44003: PUSH
44004: EMPTY
44005: LIST
44006: LIST
44007: PUSH
44008: LD_INT 0
44010: PUSH
44011: LD_INT 4
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: PUSH
44018: LD_INT 0
44020: PUSH
44021: LD_INT 3
44023: PUSH
44024: EMPTY
44025: LIST
44026: LIST
44027: PUSH
44028: LD_INT 1
44030: PUSH
44031: LD_INT 4
44033: PUSH
44034: EMPTY
44035: LIST
44036: LIST
44037: PUSH
44038: LD_INT 1
44040: PUSH
44041: LD_INT 5
44043: PUSH
44044: EMPTY
44045: LIST
44046: LIST
44047: PUSH
44048: LD_INT 0
44050: PUSH
44051: LD_INT 5
44053: PUSH
44054: EMPTY
44055: LIST
44056: LIST
44057: PUSH
44058: LD_INT 1
44060: NEG
44061: PUSH
44062: LD_INT 4
44064: PUSH
44065: EMPTY
44066: LIST
44067: LIST
44068: PUSH
44069: LD_INT 1
44071: NEG
44072: PUSH
44073: LD_INT 3
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PUSH
44080: LD_INT 2
44082: PUSH
44083: LD_INT 5
44085: PUSH
44086: EMPTY
44087: LIST
44088: LIST
44089: PUSH
44090: LD_INT 2
44092: NEG
44093: PUSH
44094: LD_INT 3
44096: PUSH
44097: EMPTY
44098: LIST
44099: LIST
44100: PUSH
44101: LD_INT 3
44103: NEG
44104: PUSH
44105: LD_INT 0
44107: PUSH
44108: EMPTY
44109: LIST
44110: LIST
44111: PUSH
44112: LD_INT 3
44114: NEG
44115: PUSH
44116: LD_INT 1
44118: NEG
44119: PUSH
44120: EMPTY
44121: LIST
44122: LIST
44123: PUSH
44124: LD_INT 2
44126: NEG
44127: PUSH
44128: LD_INT 0
44130: PUSH
44131: EMPTY
44132: LIST
44133: LIST
44134: PUSH
44135: LD_INT 2
44137: NEG
44138: PUSH
44139: LD_INT 1
44141: PUSH
44142: EMPTY
44143: LIST
44144: LIST
44145: PUSH
44146: LD_INT 3
44148: NEG
44149: PUSH
44150: LD_INT 1
44152: PUSH
44153: EMPTY
44154: LIST
44155: LIST
44156: PUSH
44157: LD_INT 4
44159: NEG
44160: PUSH
44161: LD_INT 0
44163: PUSH
44164: EMPTY
44165: LIST
44166: LIST
44167: PUSH
44168: LD_INT 4
44170: NEG
44171: PUSH
44172: LD_INT 1
44174: NEG
44175: PUSH
44176: EMPTY
44177: LIST
44178: LIST
44179: PUSH
44180: LD_INT 4
44182: NEG
44183: PUSH
44184: LD_INT 2
44186: NEG
44187: PUSH
44188: EMPTY
44189: LIST
44190: LIST
44191: PUSH
44192: LD_INT 2
44194: NEG
44195: PUSH
44196: LD_INT 2
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PUSH
44203: LD_INT 4
44205: NEG
44206: PUSH
44207: LD_INT 4
44209: NEG
44210: PUSH
44211: EMPTY
44212: LIST
44213: LIST
44214: PUSH
44215: LD_INT 4
44217: NEG
44218: PUSH
44219: LD_INT 5
44221: NEG
44222: PUSH
44223: EMPTY
44224: LIST
44225: LIST
44226: PUSH
44227: LD_INT 3
44229: NEG
44230: PUSH
44231: LD_INT 4
44233: NEG
44234: PUSH
44235: EMPTY
44236: LIST
44237: LIST
44238: PUSH
44239: LD_INT 3
44241: NEG
44242: PUSH
44243: LD_INT 3
44245: NEG
44246: PUSH
44247: EMPTY
44248: LIST
44249: LIST
44250: PUSH
44251: LD_INT 4
44253: NEG
44254: PUSH
44255: LD_INT 3
44257: NEG
44258: PUSH
44259: EMPTY
44260: LIST
44261: LIST
44262: PUSH
44263: LD_INT 5
44265: NEG
44266: PUSH
44267: LD_INT 4
44269: NEG
44270: PUSH
44271: EMPTY
44272: LIST
44273: LIST
44274: PUSH
44275: LD_INT 5
44277: NEG
44278: PUSH
44279: LD_INT 5
44281: NEG
44282: PUSH
44283: EMPTY
44284: LIST
44285: LIST
44286: PUSH
44287: LD_INT 3
44289: NEG
44290: PUSH
44291: LD_INT 5
44293: NEG
44294: PUSH
44295: EMPTY
44296: LIST
44297: LIST
44298: PUSH
44299: LD_INT 5
44301: NEG
44302: PUSH
44303: LD_INT 3
44305: NEG
44306: PUSH
44307: EMPTY
44308: LIST
44309: LIST
44310: PUSH
44311: EMPTY
44312: LIST
44313: LIST
44314: LIST
44315: LIST
44316: LIST
44317: LIST
44318: LIST
44319: LIST
44320: LIST
44321: LIST
44322: LIST
44323: LIST
44324: LIST
44325: LIST
44326: LIST
44327: LIST
44328: LIST
44329: LIST
44330: LIST
44331: LIST
44332: LIST
44333: LIST
44334: LIST
44335: LIST
44336: LIST
44337: LIST
44338: LIST
44339: LIST
44340: LIST
44341: LIST
44342: LIST
44343: LIST
44344: LIST
44345: LIST
44346: LIST
44347: LIST
44348: LIST
44349: LIST
44350: LIST
44351: LIST
44352: LIST
44353: LIST
44354: LIST
44355: LIST
44356: LIST
44357: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
44358: LD_ADDR_VAR 0 30
44362: PUSH
44363: LD_INT 4
44365: PUSH
44366: LD_INT 4
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 4
44375: PUSH
44376: LD_INT 3
44378: PUSH
44379: EMPTY
44380: LIST
44381: LIST
44382: PUSH
44383: LD_INT 5
44385: PUSH
44386: LD_INT 4
44388: PUSH
44389: EMPTY
44390: LIST
44391: LIST
44392: PUSH
44393: LD_INT 5
44395: PUSH
44396: LD_INT 5
44398: PUSH
44399: EMPTY
44400: LIST
44401: LIST
44402: PUSH
44403: LD_INT 4
44405: PUSH
44406: LD_INT 5
44408: PUSH
44409: EMPTY
44410: LIST
44411: LIST
44412: PUSH
44413: LD_INT 3
44415: PUSH
44416: LD_INT 4
44418: PUSH
44419: EMPTY
44420: LIST
44421: LIST
44422: PUSH
44423: LD_INT 3
44425: PUSH
44426: LD_INT 3
44428: PUSH
44429: EMPTY
44430: LIST
44431: LIST
44432: PUSH
44433: LD_INT 5
44435: PUSH
44436: LD_INT 3
44438: PUSH
44439: EMPTY
44440: LIST
44441: LIST
44442: PUSH
44443: LD_INT 3
44445: PUSH
44446: LD_INT 5
44448: PUSH
44449: EMPTY
44450: LIST
44451: LIST
44452: PUSH
44453: LD_INT 0
44455: PUSH
44456: LD_INT 3
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 0
44465: PUSH
44466: LD_INT 2
44468: PUSH
44469: EMPTY
44470: LIST
44471: LIST
44472: PUSH
44473: LD_INT 1
44475: PUSH
44476: LD_INT 3
44478: PUSH
44479: EMPTY
44480: LIST
44481: LIST
44482: PUSH
44483: LD_INT 1
44485: PUSH
44486: LD_INT 4
44488: PUSH
44489: EMPTY
44490: LIST
44491: LIST
44492: PUSH
44493: LD_INT 0
44495: PUSH
44496: LD_INT 4
44498: PUSH
44499: EMPTY
44500: LIST
44501: LIST
44502: PUSH
44503: LD_INT 1
44505: NEG
44506: PUSH
44507: LD_INT 3
44509: PUSH
44510: EMPTY
44511: LIST
44512: LIST
44513: PUSH
44514: LD_INT 1
44516: NEG
44517: PUSH
44518: LD_INT 2
44520: PUSH
44521: EMPTY
44522: LIST
44523: LIST
44524: PUSH
44525: LD_INT 2
44527: PUSH
44528: LD_INT 4
44530: PUSH
44531: EMPTY
44532: LIST
44533: LIST
44534: PUSH
44535: LD_INT 2
44537: NEG
44538: PUSH
44539: LD_INT 2
44541: PUSH
44542: EMPTY
44543: LIST
44544: LIST
44545: PUSH
44546: LD_INT 4
44548: NEG
44549: PUSH
44550: LD_INT 0
44552: PUSH
44553: EMPTY
44554: LIST
44555: LIST
44556: PUSH
44557: LD_INT 4
44559: NEG
44560: PUSH
44561: LD_INT 1
44563: NEG
44564: PUSH
44565: EMPTY
44566: LIST
44567: LIST
44568: PUSH
44569: LD_INT 3
44571: NEG
44572: PUSH
44573: LD_INT 0
44575: PUSH
44576: EMPTY
44577: LIST
44578: LIST
44579: PUSH
44580: LD_INT 3
44582: NEG
44583: PUSH
44584: LD_INT 1
44586: PUSH
44587: EMPTY
44588: LIST
44589: LIST
44590: PUSH
44591: LD_INT 4
44593: NEG
44594: PUSH
44595: LD_INT 1
44597: PUSH
44598: EMPTY
44599: LIST
44600: LIST
44601: PUSH
44602: LD_INT 5
44604: NEG
44605: PUSH
44606: LD_INT 0
44608: PUSH
44609: EMPTY
44610: LIST
44611: LIST
44612: PUSH
44613: LD_INT 5
44615: NEG
44616: PUSH
44617: LD_INT 1
44619: NEG
44620: PUSH
44621: EMPTY
44622: LIST
44623: LIST
44624: PUSH
44625: LD_INT 5
44627: NEG
44628: PUSH
44629: LD_INT 2
44631: NEG
44632: PUSH
44633: EMPTY
44634: LIST
44635: LIST
44636: PUSH
44637: LD_INT 3
44639: NEG
44640: PUSH
44641: LD_INT 2
44643: PUSH
44644: EMPTY
44645: LIST
44646: LIST
44647: PUSH
44648: LD_INT 3
44650: NEG
44651: PUSH
44652: LD_INT 3
44654: NEG
44655: PUSH
44656: EMPTY
44657: LIST
44658: LIST
44659: PUSH
44660: LD_INT 3
44662: NEG
44663: PUSH
44664: LD_INT 4
44666: NEG
44667: PUSH
44668: EMPTY
44669: LIST
44670: LIST
44671: PUSH
44672: LD_INT 2
44674: NEG
44675: PUSH
44676: LD_INT 3
44678: NEG
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: PUSH
44684: LD_INT 2
44686: NEG
44687: PUSH
44688: LD_INT 2
44690: NEG
44691: PUSH
44692: EMPTY
44693: LIST
44694: LIST
44695: PUSH
44696: LD_INT 3
44698: NEG
44699: PUSH
44700: LD_INT 2
44702: NEG
44703: PUSH
44704: EMPTY
44705: LIST
44706: LIST
44707: PUSH
44708: LD_INT 4
44710: NEG
44711: PUSH
44712: LD_INT 3
44714: NEG
44715: PUSH
44716: EMPTY
44717: LIST
44718: LIST
44719: PUSH
44720: LD_INT 4
44722: NEG
44723: PUSH
44724: LD_INT 4
44726: NEG
44727: PUSH
44728: EMPTY
44729: LIST
44730: LIST
44731: PUSH
44732: LD_INT 2
44734: NEG
44735: PUSH
44736: LD_INT 4
44738: NEG
44739: PUSH
44740: EMPTY
44741: LIST
44742: LIST
44743: PUSH
44744: LD_INT 4
44746: NEG
44747: PUSH
44748: LD_INT 2
44750: NEG
44751: PUSH
44752: EMPTY
44753: LIST
44754: LIST
44755: PUSH
44756: LD_INT 0
44758: PUSH
44759: LD_INT 4
44761: NEG
44762: PUSH
44763: EMPTY
44764: LIST
44765: LIST
44766: PUSH
44767: LD_INT 0
44769: PUSH
44770: LD_INT 5
44772: NEG
44773: PUSH
44774: EMPTY
44775: LIST
44776: LIST
44777: PUSH
44778: LD_INT 1
44780: PUSH
44781: LD_INT 4
44783: NEG
44784: PUSH
44785: EMPTY
44786: LIST
44787: LIST
44788: PUSH
44789: LD_INT 1
44791: PUSH
44792: LD_INT 3
44794: NEG
44795: PUSH
44796: EMPTY
44797: LIST
44798: LIST
44799: PUSH
44800: LD_INT 0
44802: PUSH
44803: LD_INT 3
44805: NEG
44806: PUSH
44807: EMPTY
44808: LIST
44809: LIST
44810: PUSH
44811: LD_INT 1
44813: NEG
44814: PUSH
44815: LD_INT 4
44817: NEG
44818: PUSH
44819: EMPTY
44820: LIST
44821: LIST
44822: PUSH
44823: LD_INT 1
44825: NEG
44826: PUSH
44827: LD_INT 5
44829: NEG
44830: PUSH
44831: EMPTY
44832: LIST
44833: LIST
44834: PUSH
44835: LD_INT 2
44837: PUSH
44838: LD_INT 3
44840: NEG
44841: PUSH
44842: EMPTY
44843: LIST
44844: LIST
44845: PUSH
44846: LD_INT 2
44848: NEG
44849: PUSH
44850: LD_INT 5
44852: NEG
44853: PUSH
44854: EMPTY
44855: LIST
44856: LIST
44857: PUSH
44858: EMPTY
44859: LIST
44860: LIST
44861: LIST
44862: LIST
44863: LIST
44864: LIST
44865: LIST
44866: LIST
44867: LIST
44868: LIST
44869: LIST
44870: LIST
44871: LIST
44872: LIST
44873: LIST
44874: LIST
44875: LIST
44876: LIST
44877: LIST
44878: LIST
44879: LIST
44880: LIST
44881: LIST
44882: LIST
44883: LIST
44884: LIST
44885: LIST
44886: LIST
44887: LIST
44888: LIST
44889: LIST
44890: LIST
44891: LIST
44892: LIST
44893: LIST
44894: LIST
44895: LIST
44896: LIST
44897: LIST
44898: LIST
44899: LIST
44900: LIST
44901: LIST
44902: LIST
44903: LIST
44904: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44905: LD_ADDR_VAR 0 31
44909: PUSH
44910: LD_INT 0
44912: PUSH
44913: LD_INT 4
44915: PUSH
44916: EMPTY
44917: LIST
44918: LIST
44919: PUSH
44920: LD_INT 0
44922: PUSH
44923: LD_INT 3
44925: PUSH
44926: EMPTY
44927: LIST
44928: LIST
44929: PUSH
44930: LD_INT 1
44932: PUSH
44933: LD_INT 4
44935: PUSH
44936: EMPTY
44937: LIST
44938: LIST
44939: PUSH
44940: LD_INT 1
44942: PUSH
44943: LD_INT 5
44945: PUSH
44946: EMPTY
44947: LIST
44948: LIST
44949: PUSH
44950: LD_INT 0
44952: PUSH
44953: LD_INT 5
44955: PUSH
44956: EMPTY
44957: LIST
44958: LIST
44959: PUSH
44960: LD_INT 1
44962: NEG
44963: PUSH
44964: LD_INT 4
44966: PUSH
44967: EMPTY
44968: LIST
44969: LIST
44970: PUSH
44971: LD_INT 1
44973: NEG
44974: PUSH
44975: LD_INT 3
44977: PUSH
44978: EMPTY
44979: LIST
44980: LIST
44981: PUSH
44982: LD_INT 2
44984: PUSH
44985: LD_INT 5
44987: PUSH
44988: EMPTY
44989: LIST
44990: LIST
44991: PUSH
44992: LD_INT 2
44994: NEG
44995: PUSH
44996: LD_INT 3
44998: PUSH
44999: EMPTY
45000: LIST
45001: LIST
45002: PUSH
45003: LD_INT 3
45005: NEG
45006: PUSH
45007: LD_INT 0
45009: PUSH
45010: EMPTY
45011: LIST
45012: LIST
45013: PUSH
45014: LD_INT 3
45016: NEG
45017: PUSH
45018: LD_INT 1
45020: NEG
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PUSH
45026: LD_INT 2
45028: NEG
45029: PUSH
45030: LD_INT 0
45032: PUSH
45033: EMPTY
45034: LIST
45035: LIST
45036: PUSH
45037: LD_INT 2
45039: NEG
45040: PUSH
45041: LD_INT 1
45043: PUSH
45044: EMPTY
45045: LIST
45046: LIST
45047: PUSH
45048: LD_INT 3
45050: NEG
45051: PUSH
45052: LD_INT 1
45054: PUSH
45055: EMPTY
45056: LIST
45057: LIST
45058: PUSH
45059: LD_INT 4
45061: NEG
45062: PUSH
45063: LD_INT 0
45065: PUSH
45066: EMPTY
45067: LIST
45068: LIST
45069: PUSH
45070: LD_INT 4
45072: NEG
45073: PUSH
45074: LD_INT 1
45076: NEG
45077: PUSH
45078: EMPTY
45079: LIST
45080: LIST
45081: PUSH
45082: LD_INT 4
45084: NEG
45085: PUSH
45086: LD_INT 2
45088: NEG
45089: PUSH
45090: EMPTY
45091: LIST
45092: LIST
45093: PUSH
45094: LD_INT 2
45096: NEG
45097: PUSH
45098: LD_INT 2
45100: PUSH
45101: EMPTY
45102: LIST
45103: LIST
45104: PUSH
45105: LD_INT 4
45107: NEG
45108: PUSH
45109: LD_INT 4
45111: NEG
45112: PUSH
45113: EMPTY
45114: LIST
45115: LIST
45116: PUSH
45117: LD_INT 4
45119: NEG
45120: PUSH
45121: LD_INT 5
45123: NEG
45124: PUSH
45125: EMPTY
45126: LIST
45127: LIST
45128: PUSH
45129: LD_INT 3
45131: NEG
45132: PUSH
45133: LD_INT 4
45135: NEG
45136: PUSH
45137: EMPTY
45138: LIST
45139: LIST
45140: PUSH
45141: LD_INT 3
45143: NEG
45144: PUSH
45145: LD_INT 3
45147: NEG
45148: PUSH
45149: EMPTY
45150: LIST
45151: LIST
45152: PUSH
45153: LD_INT 4
45155: NEG
45156: PUSH
45157: LD_INT 3
45159: NEG
45160: PUSH
45161: EMPTY
45162: LIST
45163: LIST
45164: PUSH
45165: LD_INT 5
45167: NEG
45168: PUSH
45169: LD_INT 4
45171: NEG
45172: PUSH
45173: EMPTY
45174: LIST
45175: LIST
45176: PUSH
45177: LD_INT 5
45179: NEG
45180: PUSH
45181: LD_INT 5
45183: NEG
45184: PUSH
45185: EMPTY
45186: LIST
45187: LIST
45188: PUSH
45189: LD_INT 3
45191: NEG
45192: PUSH
45193: LD_INT 5
45195: NEG
45196: PUSH
45197: EMPTY
45198: LIST
45199: LIST
45200: PUSH
45201: LD_INT 5
45203: NEG
45204: PUSH
45205: LD_INT 3
45207: NEG
45208: PUSH
45209: EMPTY
45210: LIST
45211: LIST
45212: PUSH
45213: LD_INT 0
45215: PUSH
45216: LD_INT 3
45218: NEG
45219: PUSH
45220: EMPTY
45221: LIST
45222: LIST
45223: PUSH
45224: LD_INT 0
45226: PUSH
45227: LD_INT 4
45229: NEG
45230: PUSH
45231: EMPTY
45232: LIST
45233: LIST
45234: PUSH
45235: LD_INT 1
45237: PUSH
45238: LD_INT 3
45240: NEG
45241: PUSH
45242: EMPTY
45243: LIST
45244: LIST
45245: PUSH
45246: LD_INT 1
45248: PUSH
45249: LD_INT 2
45251: NEG
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: PUSH
45257: LD_INT 0
45259: PUSH
45260: LD_INT 2
45262: NEG
45263: PUSH
45264: EMPTY
45265: LIST
45266: LIST
45267: PUSH
45268: LD_INT 1
45270: NEG
45271: PUSH
45272: LD_INT 3
45274: NEG
45275: PUSH
45276: EMPTY
45277: LIST
45278: LIST
45279: PUSH
45280: LD_INT 1
45282: NEG
45283: PUSH
45284: LD_INT 4
45286: NEG
45287: PUSH
45288: EMPTY
45289: LIST
45290: LIST
45291: PUSH
45292: LD_INT 2
45294: PUSH
45295: LD_INT 2
45297: NEG
45298: PUSH
45299: EMPTY
45300: LIST
45301: LIST
45302: PUSH
45303: LD_INT 2
45305: NEG
45306: PUSH
45307: LD_INT 4
45309: NEG
45310: PUSH
45311: EMPTY
45312: LIST
45313: LIST
45314: PUSH
45315: LD_INT 4
45317: PUSH
45318: LD_INT 0
45320: PUSH
45321: EMPTY
45322: LIST
45323: LIST
45324: PUSH
45325: LD_INT 4
45327: PUSH
45328: LD_INT 1
45330: NEG
45331: PUSH
45332: EMPTY
45333: LIST
45334: LIST
45335: PUSH
45336: LD_INT 5
45338: PUSH
45339: LD_INT 0
45341: PUSH
45342: EMPTY
45343: LIST
45344: LIST
45345: PUSH
45346: LD_INT 5
45348: PUSH
45349: LD_INT 1
45351: PUSH
45352: EMPTY
45353: LIST
45354: LIST
45355: PUSH
45356: LD_INT 4
45358: PUSH
45359: LD_INT 1
45361: PUSH
45362: EMPTY
45363: LIST
45364: LIST
45365: PUSH
45366: LD_INT 3
45368: PUSH
45369: LD_INT 0
45371: PUSH
45372: EMPTY
45373: LIST
45374: LIST
45375: PUSH
45376: LD_INT 3
45378: PUSH
45379: LD_INT 1
45381: NEG
45382: PUSH
45383: EMPTY
45384: LIST
45385: LIST
45386: PUSH
45387: LD_INT 3
45389: PUSH
45390: LD_INT 2
45392: NEG
45393: PUSH
45394: EMPTY
45395: LIST
45396: LIST
45397: PUSH
45398: LD_INT 5
45400: PUSH
45401: LD_INT 2
45403: PUSH
45404: EMPTY
45405: LIST
45406: LIST
45407: PUSH
45408: EMPTY
45409: LIST
45410: LIST
45411: LIST
45412: LIST
45413: LIST
45414: LIST
45415: LIST
45416: LIST
45417: LIST
45418: LIST
45419: LIST
45420: LIST
45421: LIST
45422: LIST
45423: LIST
45424: LIST
45425: LIST
45426: LIST
45427: LIST
45428: LIST
45429: LIST
45430: LIST
45431: LIST
45432: LIST
45433: LIST
45434: LIST
45435: LIST
45436: LIST
45437: LIST
45438: LIST
45439: LIST
45440: LIST
45441: LIST
45442: LIST
45443: LIST
45444: LIST
45445: LIST
45446: LIST
45447: LIST
45448: LIST
45449: LIST
45450: LIST
45451: LIST
45452: LIST
45453: LIST
45454: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45455: LD_ADDR_VAR 0 32
45459: PUSH
45460: LD_INT 4
45462: NEG
45463: PUSH
45464: LD_INT 0
45466: PUSH
45467: EMPTY
45468: LIST
45469: LIST
45470: PUSH
45471: LD_INT 4
45473: NEG
45474: PUSH
45475: LD_INT 1
45477: NEG
45478: PUSH
45479: EMPTY
45480: LIST
45481: LIST
45482: PUSH
45483: LD_INT 3
45485: NEG
45486: PUSH
45487: LD_INT 0
45489: PUSH
45490: EMPTY
45491: LIST
45492: LIST
45493: PUSH
45494: LD_INT 3
45496: NEG
45497: PUSH
45498: LD_INT 1
45500: PUSH
45501: EMPTY
45502: LIST
45503: LIST
45504: PUSH
45505: LD_INT 4
45507: NEG
45508: PUSH
45509: LD_INT 1
45511: PUSH
45512: EMPTY
45513: LIST
45514: LIST
45515: PUSH
45516: LD_INT 5
45518: NEG
45519: PUSH
45520: LD_INT 0
45522: PUSH
45523: EMPTY
45524: LIST
45525: LIST
45526: PUSH
45527: LD_INT 5
45529: NEG
45530: PUSH
45531: LD_INT 1
45533: NEG
45534: PUSH
45535: EMPTY
45536: LIST
45537: LIST
45538: PUSH
45539: LD_INT 5
45541: NEG
45542: PUSH
45543: LD_INT 2
45545: NEG
45546: PUSH
45547: EMPTY
45548: LIST
45549: LIST
45550: PUSH
45551: LD_INT 3
45553: NEG
45554: PUSH
45555: LD_INT 2
45557: PUSH
45558: EMPTY
45559: LIST
45560: LIST
45561: PUSH
45562: LD_INT 3
45564: NEG
45565: PUSH
45566: LD_INT 3
45568: NEG
45569: PUSH
45570: EMPTY
45571: LIST
45572: LIST
45573: PUSH
45574: LD_INT 3
45576: NEG
45577: PUSH
45578: LD_INT 4
45580: NEG
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: PUSH
45586: LD_INT 2
45588: NEG
45589: PUSH
45590: LD_INT 3
45592: NEG
45593: PUSH
45594: EMPTY
45595: LIST
45596: LIST
45597: PUSH
45598: LD_INT 2
45600: NEG
45601: PUSH
45602: LD_INT 2
45604: NEG
45605: PUSH
45606: EMPTY
45607: LIST
45608: LIST
45609: PUSH
45610: LD_INT 3
45612: NEG
45613: PUSH
45614: LD_INT 2
45616: NEG
45617: PUSH
45618: EMPTY
45619: LIST
45620: LIST
45621: PUSH
45622: LD_INT 4
45624: NEG
45625: PUSH
45626: LD_INT 3
45628: NEG
45629: PUSH
45630: EMPTY
45631: LIST
45632: LIST
45633: PUSH
45634: LD_INT 4
45636: NEG
45637: PUSH
45638: LD_INT 4
45640: NEG
45641: PUSH
45642: EMPTY
45643: LIST
45644: LIST
45645: PUSH
45646: LD_INT 2
45648: NEG
45649: PUSH
45650: LD_INT 4
45652: NEG
45653: PUSH
45654: EMPTY
45655: LIST
45656: LIST
45657: PUSH
45658: LD_INT 4
45660: NEG
45661: PUSH
45662: LD_INT 2
45664: NEG
45665: PUSH
45666: EMPTY
45667: LIST
45668: LIST
45669: PUSH
45670: LD_INT 0
45672: PUSH
45673: LD_INT 4
45675: NEG
45676: PUSH
45677: EMPTY
45678: LIST
45679: LIST
45680: PUSH
45681: LD_INT 0
45683: PUSH
45684: LD_INT 5
45686: NEG
45687: PUSH
45688: EMPTY
45689: LIST
45690: LIST
45691: PUSH
45692: LD_INT 1
45694: PUSH
45695: LD_INT 4
45697: NEG
45698: PUSH
45699: EMPTY
45700: LIST
45701: LIST
45702: PUSH
45703: LD_INT 1
45705: PUSH
45706: LD_INT 3
45708: NEG
45709: PUSH
45710: EMPTY
45711: LIST
45712: LIST
45713: PUSH
45714: LD_INT 0
45716: PUSH
45717: LD_INT 3
45719: NEG
45720: PUSH
45721: EMPTY
45722: LIST
45723: LIST
45724: PUSH
45725: LD_INT 1
45727: NEG
45728: PUSH
45729: LD_INT 4
45731: NEG
45732: PUSH
45733: EMPTY
45734: LIST
45735: LIST
45736: PUSH
45737: LD_INT 1
45739: NEG
45740: PUSH
45741: LD_INT 5
45743: NEG
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PUSH
45749: LD_INT 2
45751: PUSH
45752: LD_INT 3
45754: NEG
45755: PUSH
45756: EMPTY
45757: LIST
45758: LIST
45759: PUSH
45760: LD_INT 2
45762: NEG
45763: PUSH
45764: LD_INT 5
45766: NEG
45767: PUSH
45768: EMPTY
45769: LIST
45770: LIST
45771: PUSH
45772: LD_INT 3
45774: PUSH
45775: LD_INT 0
45777: PUSH
45778: EMPTY
45779: LIST
45780: LIST
45781: PUSH
45782: LD_INT 3
45784: PUSH
45785: LD_INT 1
45787: NEG
45788: PUSH
45789: EMPTY
45790: LIST
45791: LIST
45792: PUSH
45793: LD_INT 4
45795: PUSH
45796: LD_INT 0
45798: PUSH
45799: EMPTY
45800: LIST
45801: LIST
45802: PUSH
45803: LD_INT 4
45805: PUSH
45806: LD_INT 1
45808: PUSH
45809: EMPTY
45810: LIST
45811: LIST
45812: PUSH
45813: LD_INT 3
45815: PUSH
45816: LD_INT 1
45818: PUSH
45819: EMPTY
45820: LIST
45821: LIST
45822: PUSH
45823: LD_INT 2
45825: PUSH
45826: LD_INT 0
45828: PUSH
45829: EMPTY
45830: LIST
45831: LIST
45832: PUSH
45833: LD_INT 2
45835: PUSH
45836: LD_INT 1
45838: NEG
45839: PUSH
45840: EMPTY
45841: LIST
45842: LIST
45843: PUSH
45844: LD_INT 2
45846: PUSH
45847: LD_INT 2
45849: NEG
45850: PUSH
45851: EMPTY
45852: LIST
45853: LIST
45854: PUSH
45855: LD_INT 4
45857: PUSH
45858: LD_INT 2
45860: PUSH
45861: EMPTY
45862: LIST
45863: LIST
45864: PUSH
45865: LD_INT 4
45867: PUSH
45868: LD_INT 4
45870: PUSH
45871: EMPTY
45872: LIST
45873: LIST
45874: PUSH
45875: LD_INT 4
45877: PUSH
45878: LD_INT 3
45880: PUSH
45881: EMPTY
45882: LIST
45883: LIST
45884: PUSH
45885: LD_INT 5
45887: PUSH
45888: LD_INT 4
45890: PUSH
45891: EMPTY
45892: LIST
45893: LIST
45894: PUSH
45895: LD_INT 5
45897: PUSH
45898: LD_INT 5
45900: PUSH
45901: EMPTY
45902: LIST
45903: LIST
45904: PUSH
45905: LD_INT 4
45907: PUSH
45908: LD_INT 5
45910: PUSH
45911: EMPTY
45912: LIST
45913: LIST
45914: PUSH
45915: LD_INT 3
45917: PUSH
45918: LD_INT 4
45920: PUSH
45921: EMPTY
45922: LIST
45923: LIST
45924: PUSH
45925: LD_INT 3
45927: PUSH
45928: LD_INT 3
45930: PUSH
45931: EMPTY
45932: LIST
45933: LIST
45934: PUSH
45935: LD_INT 5
45937: PUSH
45938: LD_INT 3
45940: PUSH
45941: EMPTY
45942: LIST
45943: LIST
45944: PUSH
45945: LD_INT 3
45947: PUSH
45948: LD_INT 5
45950: PUSH
45951: EMPTY
45952: LIST
45953: LIST
45954: PUSH
45955: EMPTY
45956: LIST
45957: LIST
45958: LIST
45959: LIST
45960: LIST
45961: LIST
45962: LIST
45963: LIST
45964: LIST
45965: LIST
45966: LIST
45967: LIST
45968: LIST
45969: LIST
45970: LIST
45971: LIST
45972: LIST
45973: LIST
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: LIST
45979: LIST
45980: LIST
45981: LIST
45982: LIST
45983: LIST
45984: LIST
45985: LIST
45986: LIST
45987: LIST
45988: LIST
45989: LIST
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: LIST
46000: LIST
46001: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
46002: LD_ADDR_VAR 0 33
46006: PUSH
46007: LD_INT 4
46009: NEG
46010: PUSH
46011: LD_INT 4
46013: NEG
46014: PUSH
46015: EMPTY
46016: LIST
46017: LIST
46018: PUSH
46019: LD_INT 4
46021: NEG
46022: PUSH
46023: LD_INT 5
46025: NEG
46026: PUSH
46027: EMPTY
46028: LIST
46029: LIST
46030: PUSH
46031: LD_INT 3
46033: NEG
46034: PUSH
46035: LD_INT 4
46037: NEG
46038: PUSH
46039: EMPTY
46040: LIST
46041: LIST
46042: PUSH
46043: LD_INT 3
46045: NEG
46046: PUSH
46047: LD_INT 3
46049: NEG
46050: PUSH
46051: EMPTY
46052: LIST
46053: LIST
46054: PUSH
46055: LD_INT 4
46057: NEG
46058: PUSH
46059: LD_INT 3
46061: NEG
46062: PUSH
46063: EMPTY
46064: LIST
46065: LIST
46066: PUSH
46067: LD_INT 5
46069: NEG
46070: PUSH
46071: LD_INT 4
46073: NEG
46074: PUSH
46075: EMPTY
46076: LIST
46077: LIST
46078: PUSH
46079: LD_INT 5
46081: NEG
46082: PUSH
46083: LD_INT 5
46085: NEG
46086: PUSH
46087: EMPTY
46088: LIST
46089: LIST
46090: PUSH
46091: LD_INT 3
46093: NEG
46094: PUSH
46095: LD_INT 5
46097: NEG
46098: PUSH
46099: EMPTY
46100: LIST
46101: LIST
46102: PUSH
46103: LD_INT 5
46105: NEG
46106: PUSH
46107: LD_INT 3
46109: NEG
46110: PUSH
46111: EMPTY
46112: LIST
46113: LIST
46114: PUSH
46115: LD_INT 0
46117: PUSH
46118: LD_INT 3
46120: NEG
46121: PUSH
46122: EMPTY
46123: LIST
46124: LIST
46125: PUSH
46126: LD_INT 0
46128: PUSH
46129: LD_INT 4
46131: NEG
46132: PUSH
46133: EMPTY
46134: LIST
46135: LIST
46136: PUSH
46137: LD_INT 1
46139: PUSH
46140: LD_INT 3
46142: NEG
46143: PUSH
46144: EMPTY
46145: LIST
46146: LIST
46147: PUSH
46148: LD_INT 1
46150: PUSH
46151: LD_INT 2
46153: NEG
46154: PUSH
46155: EMPTY
46156: LIST
46157: LIST
46158: PUSH
46159: LD_INT 0
46161: PUSH
46162: LD_INT 2
46164: NEG
46165: PUSH
46166: EMPTY
46167: LIST
46168: LIST
46169: PUSH
46170: LD_INT 1
46172: NEG
46173: PUSH
46174: LD_INT 3
46176: NEG
46177: PUSH
46178: EMPTY
46179: LIST
46180: LIST
46181: PUSH
46182: LD_INT 1
46184: NEG
46185: PUSH
46186: LD_INT 4
46188: NEG
46189: PUSH
46190: EMPTY
46191: LIST
46192: LIST
46193: PUSH
46194: LD_INT 2
46196: PUSH
46197: LD_INT 2
46199: NEG
46200: PUSH
46201: EMPTY
46202: LIST
46203: LIST
46204: PUSH
46205: LD_INT 2
46207: NEG
46208: PUSH
46209: LD_INT 4
46211: NEG
46212: PUSH
46213: EMPTY
46214: LIST
46215: LIST
46216: PUSH
46217: LD_INT 4
46219: PUSH
46220: LD_INT 0
46222: PUSH
46223: EMPTY
46224: LIST
46225: LIST
46226: PUSH
46227: LD_INT 4
46229: PUSH
46230: LD_INT 1
46232: NEG
46233: PUSH
46234: EMPTY
46235: LIST
46236: LIST
46237: PUSH
46238: LD_INT 5
46240: PUSH
46241: LD_INT 0
46243: PUSH
46244: EMPTY
46245: LIST
46246: LIST
46247: PUSH
46248: LD_INT 5
46250: PUSH
46251: LD_INT 1
46253: PUSH
46254: EMPTY
46255: LIST
46256: LIST
46257: PUSH
46258: LD_INT 4
46260: PUSH
46261: LD_INT 1
46263: PUSH
46264: EMPTY
46265: LIST
46266: LIST
46267: PUSH
46268: LD_INT 3
46270: PUSH
46271: LD_INT 0
46273: PUSH
46274: EMPTY
46275: LIST
46276: LIST
46277: PUSH
46278: LD_INT 3
46280: PUSH
46281: LD_INT 1
46283: NEG
46284: PUSH
46285: EMPTY
46286: LIST
46287: LIST
46288: PUSH
46289: LD_INT 3
46291: PUSH
46292: LD_INT 2
46294: NEG
46295: PUSH
46296: EMPTY
46297: LIST
46298: LIST
46299: PUSH
46300: LD_INT 5
46302: PUSH
46303: LD_INT 2
46305: PUSH
46306: EMPTY
46307: LIST
46308: LIST
46309: PUSH
46310: LD_INT 3
46312: PUSH
46313: LD_INT 3
46315: PUSH
46316: EMPTY
46317: LIST
46318: LIST
46319: PUSH
46320: LD_INT 3
46322: PUSH
46323: LD_INT 2
46325: PUSH
46326: EMPTY
46327: LIST
46328: LIST
46329: PUSH
46330: LD_INT 4
46332: PUSH
46333: LD_INT 3
46335: PUSH
46336: EMPTY
46337: LIST
46338: LIST
46339: PUSH
46340: LD_INT 4
46342: PUSH
46343: LD_INT 4
46345: PUSH
46346: EMPTY
46347: LIST
46348: LIST
46349: PUSH
46350: LD_INT 3
46352: PUSH
46353: LD_INT 4
46355: PUSH
46356: EMPTY
46357: LIST
46358: LIST
46359: PUSH
46360: LD_INT 2
46362: PUSH
46363: LD_INT 3
46365: PUSH
46366: EMPTY
46367: LIST
46368: LIST
46369: PUSH
46370: LD_INT 2
46372: PUSH
46373: LD_INT 2
46375: PUSH
46376: EMPTY
46377: LIST
46378: LIST
46379: PUSH
46380: LD_INT 4
46382: PUSH
46383: LD_INT 2
46385: PUSH
46386: EMPTY
46387: LIST
46388: LIST
46389: PUSH
46390: LD_INT 2
46392: PUSH
46393: LD_INT 4
46395: PUSH
46396: EMPTY
46397: LIST
46398: LIST
46399: PUSH
46400: LD_INT 0
46402: PUSH
46403: LD_INT 4
46405: PUSH
46406: EMPTY
46407: LIST
46408: LIST
46409: PUSH
46410: LD_INT 0
46412: PUSH
46413: LD_INT 3
46415: PUSH
46416: EMPTY
46417: LIST
46418: LIST
46419: PUSH
46420: LD_INT 1
46422: PUSH
46423: LD_INT 4
46425: PUSH
46426: EMPTY
46427: LIST
46428: LIST
46429: PUSH
46430: LD_INT 1
46432: PUSH
46433: LD_INT 5
46435: PUSH
46436: EMPTY
46437: LIST
46438: LIST
46439: PUSH
46440: LD_INT 0
46442: PUSH
46443: LD_INT 5
46445: PUSH
46446: EMPTY
46447: LIST
46448: LIST
46449: PUSH
46450: LD_INT 1
46452: NEG
46453: PUSH
46454: LD_INT 4
46456: PUSH
46457: EMPTY
46458: LIST
46459: LIST
46460: PUSH
46461: LD_INT 1
46463: NEG
46464: PUSH
46465: LD_INT 3
46467: PUSH
46468: EMPTY
46469: LIST
46470: LIST
46471: PUSH
46472: LD_INT 2
46474: PUSH
46475: LD_INT 5
46477: PUSH
46478: EMPTY
46479: LIST
46480: LIST
46481: PUSH
46482: LD_INT 2
46484: NEG
46485: PUSH
46486: LD_INT 3
46488: PUSH
46489: EMPTY
46490: LIST
46491: LIST
46492: PUSH
46493: EMPTY
46494: LIST
46495: LIST
46496: LIST
46497: LIST
46498: LIST
46499: LIST
46500: LIST
46501: LIST
46502: LIST
46503: LIST
46504: LIST
46505: LIST
46506: LIST
46507: LIST
46508: LIST
46509: LIST
46510: LIST
46511: LIST
46512: LIST
46513: LIST
46514: LIST
46515: LIST
46516: LIST
46517: LIST
46518: LIST
46519: LIST
46520: LIST
46521: LIST
46522: LIST
46523: LIST
46524: LIST
46525: LIST
46526: LIST
46527: LIST
46528: LIST
46529: LIST
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46540: LD_ADDR_VAR 0 34
46544: PUSH
46545: LD_INT 0
46547: PUSH
46548: LD_INT 4
46550: NEG
46551: PUSH
46552: EMPTY
46553: LIST
46554: LIST
46555: PUSH
46556: LD_INT 0
46558: PUSH
46559: LD_INT 5
46561: NEG
46562: PUSH
46563: EMPTY
46564: LIST
46565: LIST
46566: PUSH
46567: LD_INT 1
46569: PUSH
46570: LD_INT 4
46572: NEG
46573: PUSH
46574: EMPTY
46575: LIST
46576: LIST
46577: PUSH
46578: LD_INT 1
46580: PUSH
46581: LD_INT 3
46583: NEG
46584: PUSH
46585: EMPTY
46586: LIST
46587: LIST
46588: PUSH
46589: LD_INT 0
46591: PUSH
46592: LD_INT 3
46594: NEG
46595: PUSH
46596: EMPTY
46597: LIST
46598: LIST
46599: PUSH
46600: LD_INT 1
46602: NEG
46603: PUSH
46604: LD_INT 4
46606: NEG
46607: PUSH
46608: EMPTY
46609: LIST
46610: LIST
46611: PUSH
46612: LD_INT 1
46614: NEG
46615: PUSH
46616: LD_INT 5
46618: NEG
46619: PUSH
46620: EMPTY
46621: LIST
46622: LIST
46623: PUSH
46624: LD_INT 2
46626: PUSH
46627: LD_INT 3
46629: NEG
46630: PUSH
46631: EMPTY
46632: LIST
46633: LIST
46634: PUSH
46635: LD_INT 2
46637: NEG
46638: PUSH
46639: LD_INT 5
46641: NEG
46642: PUSH
46643: EMPTY
46644: LIST
46645: LIST
46646: PUSH
46647: LD_INT 3
46649: PUSH
46650: LD_INT 0
46652: PUSH
46653: EMPTY
46654: LIST
46655: LIST
46656: PUSH
46657: LD_INT 3
46659: PUSH
46660: LD_INT 1
46662: NEG
46663: PUSH
46664: EMPTY
46665: LIST
46666: LIST
46667: PUSH
46668: LD_INT 4
46670: PUSH
46671: LD_INT 0
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: PUSH
46678: LD_INT 4
46680: PUSH
46681: LD_INT 1
46683: PUSH
46684: EMPTY
46685: LIST
46686: LIST
46687: PUSH
46688: LD_INT 3
46690: PUSH
46691: LD_INT 1
46693: PUSH
46694: EMPTY
46695: LIST
46696: LIST
46697: PUSH
46698: LD_INT 2
46700: PUSH
46701: LD_INT 0
46703: PUSH
46704: EMPTY
46705: LIST
46706: LIST
46707: PUSH
46708: LD_INT 2
46710: PUSH
46711: LD_INT 1
46713: NEG
46714: PUSH
46715: EMPTY
46716: LIST
46717: LIST
46718: PUSH
46719: LD_INT 2
46721: PUSH
46722: LD_INT 2
46724: NEG
46725: PUSH
46726: EMPTY
46727: LIST
46728: LIST
46729: PUSH
46730: LD_INT 4
46732: PUSH
46733: LD_INT 2
46735: PUSH
46736: EMPTY
46737: LIST
46738: LIST
46739: PUSH
46740: LD_INT 4
46742: PUSH
46743: LD_INT 4
46745: PUSH
46746: EMPTY
46747: LIST
46748: LIST
46749: PUSH
46750: LD_INT 4
46752: PUSH
46753: LD_INT 3
46755: PUSH
46756: EMPTY
46757: LIST
46758: LIST
46759: PUSH
46760: LD_INT 5
46762: PUSH
46763: LD_INT 4
46765: PUSH
46766: EMPTY
46767: LIST
46768: LIST
46769: PUSH
46770: LD_INT 5
46772: PUSH
46773: LD_INT 5
46775: PUSH
46776: EMPTY
46777: LIST
46778: LIST
46779: PUSH
46780: LD_INT 4
46782: PUSH
46783: LD_INT 5
46785: PUSH
46786: EMPTY
46787: LIST
46788: LIST
46789: PUSH
46790: LD_INT 3
46792: PUSH
46793: LD_INT 4
46795: PUSH
46796: EMPTY
46797: LIST
46798: LIST
46799: PUSH
46800: LD_INT 3
46802: PUSH
46803: LD_INT 3
46805: PUSH
46806: EMPTY
46807: LIST
46808: LIST
46809: PUSH
46810: LD_INT 5
46812: PUSH
46813: LD_INT 3
46815: PUSH
46816: EMPTY
46817: LIST
46818: LIST
46819: PUSH
46820: LD_INT 3
46822: PUSH
46823: LD_INT 5
46825: PUSH
46826: EMPTY
46827: LIST
46828: LIST
46829: PUSH
46830: LD_INT 0
46832: PUSH
46833: LD_INT 3
46835: PUSH
46836: EMPTY
46837: LIST
46838: LIST
46839: PUSH
46840: LD_INT 0
46842: PUSH
46843: LD_INT 2
46845: PUSH
46846: EMPTY
46847: LIST
46848: LIST
46849: PUSH
46850: LD_INT 1
46852: PUSH
46853: LD_INT 3
46855: PUSH
46856: EMPTY
46857: LIST
46858: LIST
46859: PUSH
46860: LD_INT 1
46862: PUSH
46863: LD_INT 4
46865: PUSH
46866: EMPTY
46867: LIST
46868: LIST
46869: PUSH
46870: LD_INT 0
46872: PUSH
46873: LD_INT 4
46875: PUSH
46876: EMPTY
46877: LIST
46878: LIST
46879: PUSH
46880: LD_INT 1
46882: NEG
46883: PUSH
46884: LD_INT 3
46886: PUSH
46887: EMPTY
46888: LIST
46889: LIST
46890: PUSH
46891: LD_INT 1
46893: NEG
46894: PUSH
46895: LD_INT 2
46897: PUSH
46898: EMPTY
46899: LIST
46900: LIST
46901: PUSH
46902: LD_INT 2
46904: PUSH
46905: LD_INT 4
46907: PUSH
46908: EMPTY
46909: LIST
46910: LIST
46911: PUSH
46912: LD_INT 2
46914: NEG
46915: PUSH
46916: LD_INT 2
46918: PUSH
46919: EMPTY
46920: LIST
46921: LIST
46922: PUSH
46923: LD_INT 4
46925: NEG
46926: PUSH
46927: LD_INT 0
46929: PUSH
46930: EMPTY
46931: LIST
46932: LIST
46933: PUSH
46934: LD_INT 4
46936: NEG
46937: PUSH
46938: LD_INT 1
46940: NEG
46941: PUSH
46942: EMPTY
46943: LIST
46944: LIST
46945: PUSH
46946: LD_INT 3
46948: NEG
46949: PUSH
46950: LD_INT 0
46952: PUSH
46953: EMPTY
46954: LIST
46955: LIST
46956: PUSH
46957: LD_INT 3
46959: NEG
46960: PUSH
46961: LD_INT 1
46963: PUSH
46964: EMPTY
46965: LIST
46966: LIST
46967: PUSH
46968: LD_INT 4
46970: NEG
46971: PUSH
46972: LD_INT 1
46974: PUSH
46975: EMPTY
46976: LIST
46977: LIST
46978: PUSH
46979: LD_INT 5
46981: NEG
46982: PUSH
46983: LD_INT 0
46985: PUSH
46986: EMPTY
46987: LIST
46988: LIST
46989: PUSH
46990: LD_INT 5
46992: NEG
46993: PUSH
46994: LD_INT 1
46996: NEG
46997: PUSH
46998: EMPTY
46999: LIST
47000: LIST
47001: PUSH
47002: LD_INT 5
47004: NEG
47005: PUSH
47006: LD_INT 2
47008: NEG
47009: PUSH
47010: EMPTY
47011: LIST
47012: LIST
47013: PUSH
47014: LD_INT 3
47016: NEG
47017: PUSH
47018: LD_INT 2
47020: PUSH
47021: EMPTY
47022: LIST
47023: LIST
47024: PUSH
47025: EMPTY
47026: LIST
47027: LIST
47028: LIST
47029: LIST
47030: LIST
47031: LIST
47032: LIST
47033: LIST
47034: LIST
47035: LIST
47036: LIST
47037: LIST
47038: LIST
47039: LIST
47040: LIST
47041: LIST
47042: LIST
47043: LIST
47044: LIST
47045: LIST
47046: LIST
47047: LIST
47048: LIST
47049: LIST
47050: LIST
47051: LIST
47052: LIST
47053: LIST
47054: LIST
47055: LIST
47056: LIST
47057: LIST
47058: LIST
47059: LIST
47060: LIST
47061: LIST
47062: LIST
47063: LIST
47064: LIST
47065: LIST
47066: LIST
47067: LIST
47068: LIST
47069: LIST
47070: LIST
47071: ST_TO_ADDR
// end ; end ;
47072: GO 47075
47074: POP
// case btype of b_depot , b_warehouse :
47075: LD_VAR 0 1
47079: PUSH
47080: LD_INT 0
47082: DOUBLE
47083: EQUAL
47084: IFTRUE 47094
47086: LD_INT 1
47088: DOUBLE
47089: EQUAL
47090: IFTRUE 47094
47092: GO 47295
47094: POP
// case nation of nation_american :
47095: LD_VAR 0 5
47099: PUSH
47100: LD_INT 1
47102: DOUBLE
47103: EQUAL
47104: IFTRUE 47108
47106: GO 47164
47108: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
47109: LD_ADDR_VAR 0 9
47113: PUSH
47114: LD_VAR 0 11
47118: PUSH
47119: LD_VAR 0 12
47123: PUSH
47124: LD_VAR 0 13
47128: PUSH
47129: LD_VAR 0 14
47133: PUSH
47134: LD_VAR 0 15
47138: PUSH
47139: LD_VAR 0 16
47143: PUSH
47144: EMPTY
47145: LIST
47146: LIST
47147: LIST
47148: LIST
47149: LIST
47150: LIST
47151: PUSH
47152: LD_VAR 0 4
47156: PUSH
47157: LD_INT 1
47159: PLUS
47160: ARRAY
47161: ST_TO_ADDR
47162: GO 47293
47164: LD_INT 2
47166: DOUBLE
47167: EQUAL
47168: IFTRUE 47172
47170: GO 47228
47172: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
47173: LD_ADDR_VAR 0 9
47177: PUSH
47178: LD_VAR 0 17
47182: PUSH
47183: LD_VAR 0 18
47187: PUSH
47188: LD_VAR 0 19
47192: PUSH
47193: LD_VAR 0 20
47197: PUSH
47198: LD_VAR 0 21
47202: PUSH
47203: LD_VAR 0 22
47207: PUSH
47208: EMPTY
47209: LIST
47210: LIST
47211: LIST
47212: LIST
47213: LIST
47214: LIST
47215: PUSH
47216: LD_VAR 0 4
47220: PUSH
47221: LD_INT 1
47223: PLUS
47224: ARRAY
47225: ST_TO_ADDR
47226: GO 47293
47228: LD_INT 3
47230: DOUBLE
47231: EQUAL
47232: IFTRUE 47236
47234: GO 47292
47236: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
47237: LD_ADDR_VAR 0 9
47241: PUSH
47242: LD_VAR 0 23
47246: PUSH
47247: LD_VAR 0 24
47251: PUSH
47252: LD_VAR 0 25
47256: PUSH
47257: LD_VAR 0 26
47261: PUSH
47262: LD_VAR 0 27
47266: PUSH
47267: LD_VAR 0 28
47271: PUSH
47272: EMPTY
47273: LIST
47274: LIST
47275: LIST
47276: LIST
47277: LIST
47278: LIST
47279: PUSH
47280: LD_VAR 0 4
47284: PUSH
47285: LD_INT 1
47287: PLUS
47288: ARRAY
47289: ST_TO_ADDR
47290: GO 47293
47292: POP
47293: GO 47848
47295: LD_INT 2
47297: DOUBLE
47298: EQUAL
47299: IFTRUE 47309
47301: LD_INT 3
47303: DOUBLE
47304: EQUAL
47305: IFTRUE 47309
47307: GO 47365
47309: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
47310: LD_ADDR_VAR 0 9
47314: PUSH
47315: LD_VAR 0 29
47319: PUSH
47320: LD_VAR 0 30
47324: PUSH
47325: LD_VAR 0 31
47329: PUSH
47330: LD_VAR 0 32
47334: PUSH
47335: LD_VAR 0 33
47339: PUSH
47340: LD_VAR 0 34
47344: PUSH
47345: EMPTY
47346: LIST
47347: LIST
47348: LIST
47349: LIST
47350: LIST
47351: LIST
47352: PUSH
47353: LD_VAR 0 4
47357: PUSH
47358: LD_INT 1
47360: PLUS
47361: ARRAY
47362: ST_TO_ADDR
47363: GO 47848
47365: LD_INT 16
47367: DOUBLE
47368: EQUAL
47369: IFTRUE 47427
47371: LD_INT 17
47373: DOUBLE
47374: EQUAL
47375: IFTRUE 47427
47377: LD_INT 18
47379: DOUBLE
47380: EQUAL
47381: IFTRUE 47427
47383: LD_INT 19
47385: DOUBLE
47386: EQUAL
47387: IFTRUE 47427
47389: LD_INT 22
47391: DOUBLE
47392: EQUAL
47393: IFTRUE 47427
47395: LD_INT 20
47397: DOUBLE
47398: EQUAL
47399: IFTRUE 47427
47401: LD_INT 21
47403: DOUBLE
47404: EQUAL
47405: IFTRUE 47427
47407: LD_INT 23
47409: DOUBLE
47410: EQUAL
47411: IFTRUE 47427
47413: LD_INT 24
47415: DOUBLE
47416: EQUAL
47417: IFTRUE 47427
47419: LD_INT 25
47421: DOUBLE
47422: EQUAL
47423: IFTRUE 47427
47425: GO 47483
47427: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47428: LD_ADDR_VAR 0 9
47432: PUSH
47433: LD_VAR 0 35
47437: PUSH
47438: LD_VAR 0 36
47442: PUSH
47443: LD_VAR 0 37
47447: PUSH
47448: LD_VAR 0 38
47452: PUSH
47453: LD_VAR 0 39
47457: PUSH
47458: LD_VAR 0 40
47462: PUSH
47463: EMPTY
47464: LIST
47465: LIST
47466: LIST
47467: LIST
47468: LIST
47469: LIST
47470: PUSH
47471: LD_VAR 0 4
47475: PUSH
47476: LD_INT 1
47478: PLUS
47479: ARRAY
47480: ST_TO_ADDR
47481: GO 47848
47483: LD_INT 6
47485: DOUBLE
47486: EQUAL
47487: IFTRUE 47539
47489: LD_INT 7
47491: DOUBLE
47492: EQUAL
47493: IFTRUE 47539
47495: LD_INT 8
47497: DOUBLE
47498: EQUAL
47499: IFTRUE 47539
47501: LD_INT 13
47503: DOUBLE
47504: EQUAL
47505: IFTRUE 47539
47507: LD_INT 12
47509: DOUBLE
47510: EQUAL
47511: IFTRUE 47539
47513: LD_INT 15
47515: DOUBLE
47516: EQUAL
47517: IFTRUE 47539
47519: LD_INT 11
47521: DOUBLE
47522: EQUAL
47523: IFTRUE 47539
47525: LD_INT 14
47527: DOUBLE
47528: EQUAL
47529: IFTRUE 47539
47531: LD_INT 10
47533: DOUBLE
47534: EQUAL
47535: IFTRUE 47539
47537: GO 47595
47539: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
47540: LD_ADDR_VAR 0 9
47544: PUSH
47545: LD_VAR 0 41
47549: PUSH
47550: LD_VAR 0 42
47554: PUSH
47555: LD_VAR 0 43
47559: PUSH
47560: LD_VAR 0 44
47564: PUSH
47565: LD_VAR 0 45
47569: PUSH
47570: LD_VAR 0 46
47574: PUSH
47575: EMPTY
47576: LIST
47577: LIST
47578: LIST
47579: LIST
47580: LIST
47581: LIST
47582: PUSH
47583: LD_VAR 0 4
47587: PUSH
47588: LD_INT 1
47590: PLUS
47591: ARRAY
47592: ST_TO_ADDR
47593: GO 47848
47595: LD_INT 36
47597: DOUBLE
47598: EQUAL
47599: IFTRUE 47603
47601: GO 47659
47603: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47604: LD_ADDR_VAR 0 9
47608: PUSH
47609: LD_VAR 0 47
47613: PUSH
47614: LD_VAR 0 48
47618: PUSH
47619: LD_VAR 0 49
47623: PUSH
47624: LD_VAR 0 50
47628: PUSH
47629: LD_VAR 0 51
47633: PUSH
47634: LD_VAR 0 52
47638: PUSH
47639: EMPTY
47640: LIST
47641: LIST
47642: LIST
47643: LIST
47644: LIST
47645: LIST
47646: PUSH
47647: LD_VAR 0 4
47651: PUSH
47652: LD_INT 1
47654: PLUS
47655: ARRAY
47656: ST_TO_ADDR
47657: GO 47848
47659: LD_INT 4
47661: DOUBLE
47662: EQUAL
47663: IFTRUE 47685
47665: LD_INT 5
47667: DOUBLE
47668: EQUAL
47669: IFTRUE 47685
47671: LD_INT 34
47673: DOUBLE
47674: EQUAL
47675: IFTRUE 47685
47677: LD_INT 37
47679: DOUBLE
47680: EQUAL
47681: IFTRUE 47685
47683: GO 47741
47685: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47686: LD_ADDR_VAR 0 9
47690: PUSH
47691: LD_VAR 0 53
47695: PUSH
47696: LD_VAR 0 54
47700: PUSH
47701: LD_VAR 0 55
47705: PUSH
47706: LD_VAR 0 56
47710: PUSH
47711: LD_VAR 0 57
47715: PUSH
47716: LD_VAR 0 58
47720: PUSH
47721: EMPTY
47722: LIST
47723: LIST
47724: LIST
47725: LIST
47726: LIST
47727: LIST
47728: PUSH
47729: LD_VAR 0 4
47733: PUSH
47734: LD_INT 1
47736: PLUS
47737: ARRAY
47738: ST_TO_ADDR
47739: GO 47848
47741: LD_INT 31
47743: DOUBLE
47744: EQUAL
47745: IFTRUE 47791
47747: LD_INT 32
47749: DOUBLE
47750: EQUAL
47751: IFTRUE 47791
47753: LD_INT 33
47755: DOUBLE
47756: EQUAL
47757: IFTRUE 47791
47759: LD_INT 27
47761: DOUBLE
47762: EQUAL
47763: IFTRUE 47791
47765: LD_INT 26
47767: DOUBLE
47768: EQUAL
47769: IFTRUE 47791
47771: LD_INT 28
47773: DOUBLE
47774: EQUAL
47775: IFTRUE 47791
47777: LD_INT 29
47779: DOUBLE
47780: EQUAL
47781: IFTRUE 47791
47783: LD_INT 30
47785: DOUBLE
47786: EQUAL
47787: IFTRUE 47791
47789: GO 47847
47791: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
47792: LD_ADDR_VAR 0 9
47796: PUSH
47797: LD_VAR 0 59
47801: PUSH
47802: LD_VAR 0 60
47806: PUSH
47807: LD_VAR 0 61
47811: PUSH
47812: LD_VAR 0 62
47816: PUSH
47817: LD_VAR 0 63
47821: PUSH
47822: LD_VAR 0 64
47826: PUSH
47827: EMPTY
47828: LIST
47829: LIST
47830: LIST
47831: LIST
47832: LIST
47833: LIST
47834: PUSH
47835: LD_VAR 0 4
47839: PUSH
47840: LD_INT 1
47842: PLUS
47843: ARRAY
47844: ST_TO_ADDR
47845: GO 47848
47847: POP
// temp_list2 = [ ] ;
47848: LD_ADDR_VAR 0 10
47852: PUSH
47853: EMPTY
47854: ST_TO_ADDR
// for i in temp_list do
47855: LD_ADDR_VAR 0 8
47859: PUSH
47860: LD_VAR 0 9
47864: PUSH
47865: FOR_IN
47866: IFFALSE 47918
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47868: LD_ADDR_VAR 0 10
47872: PUSH
47873: LD_VAR 0 10
47877: PUSH
47878: LD_VAR 0 8
47882: PUSH
47883: LD_INT 1
47885: ARRAY
47886: PUSH
47887: LD_VAR 0 2
47891: PLUS
47892: PUSH
47893: LD_VAR 0 8
47897: PUSH
47898: LD_INT 2
47900: ARRAY
47901: PUSH
47902: LD_VAR 0 3
47906: PLUS
47907: PUSH
47908: EMPTY
47909: LIST
47910: LIST
47911: PUSH
47912: EMPTY
47913: LIST
47914: ADD
47915: ST_TO_ADDR
47916: GO 47865
47918: POP
47919: POP
// result = temp_list2 ;
47920: LD_ADDR_VAR 0 7
47924: PUSH
47925: LD_VAR 0 10
47929: ST_TO_ADDR
// end ;
47930: LD_VAR 0 7
47934: RET
// export function EnemyInRange ( unit , dist ) ; begin
47935: LD_INT 0
47937: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47938: LD_ADDR_VAR 0 3
47942: PUSH
47943: LD_VAR 0 1
47947: PPUSH
47948: CALL_OW 255
47952: PPUSH
47953: LD_VAR 0 1
47957: PPUSH
47958: CALL_OW 250
47962: PPUSH
47963: LD_VAR 0 1
47967: PPUSH
47968: CALL_OW 251
47972: PPUSH
47973: LD_VAR 0 2
47977: PPUSH
47978: CALL 21337 0 4
47982: PUSH
47983: LD_INT 4
47985: ARRAY
47986: ST_TO_ADDR
// end ;
47987: LD_VAR 0 3
47991: RET
// export function PlayerSeeMe ( unit ) ; begin
47992: LD_INT 0
47994: PPUSH
// result := See ( your_side , unit ) ;
47995: LD_ADDR_VAR 0 2
47999: PUSH
48000: LD_OWVAR 2
48004: PPUSH
48005: LD_VAR 0 1
48009: PPUSH
48010: CALL_OW 292
48014: ST_TO_ADDR
// end ;
48015: LD_VAR 0 2
48019: RET
// export function ReverseDir ( unit ) ; begin
48020: LD_INT 0
48022: PPUSH
// if not unit then
48023: LD_VAR 0 1
48027: NOT
48028: IFFALSE 48032
// exit ;
48030: GO 48055
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
48032: LD_ADDR_VAR 0 2
48036: PUSH
48037: LD_VAR 0 1
48041: PPUSH
48042: CALL_OW 254
48046: PUSH
48047: LD_INT 3
48049: PLUS
48050: PUSH
48051: LD_INT 6
48053: MOD
48054: ST_TO_ADDR
// end ;
48055: LD_VAR 0 2
48059: RET
// export function ReverseArray ( array ) ; var i ; begin
48060: LD_INT 0
48062: PPUSH
48063: PPUSH
// if not array then
48064: LD_VAR 0 1
48068: NOT
48069: IFFALSE 48073
// exit ;
48071: GO 48128
// result := [ ] ;
48073: LD_ADDR_VAR 0 2
48077: PUSH
48078: EMPTY
48079: ST_TO_ADDR
// for i := array downto 1 do
48080: LD_ADDR_VAR 0 3
48084: PUSH
48085: DOUBLE
48086: LD_VAR 0 1
48090: INC
48091: ST_TO_ADDR
48092: LD_INT 1
48094: PUSH
48095: FOR_DOWNTO
48096: IFFALSE 48126
// result := Join ( result , array [ i ] ) ;
48098: LD_ADDR_VAR 0 2
48102: PUSH
48103: LD_VAR 0 2
48107: PPUSH
48108: LD_VAR 0 1
48112: PUSH
48113: LD_VAR 0 3
48117: ARRAY
48118: PPUSH
48119: CALL 52771 0 2
48123: ST_TO_ADDR
48124: GO 48095
48126: POP
48127: POP
// end ;
48128: LD_VAR 0 2
48132: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
48133: LD_INT 0
48135: PPUSH
48136: PPUSH
48137: PPUSH
48138: PPUSH
48139: PPUSH
48140: PPUSH
// if not unit or not hexes then
48141: LD_VAR 0 1
48145: NOT
48146: PUSH
48147: LD_VAR 0 2
48151: NOT
48152: OR
48153: IFFALSE 48157
// exit ;
48155: GO 48280
// dist := 9999 ;
48157: LD_ADDR_VAR 0 5
48161: PUSH
48162: LD_INT 9999
48164: ST_TO_ADDR
// for i = 1 to hexes do
48165: LD_ADDR_VAR 0 4
48169: PUSH
48170: DOUBLE
48171: LD_INT 1
48173: DEC
48174: ST_TO_ADDR
48175: LD_VAR 0 2
48179: PUSH
48180: FOR_TO
48181: IFFALSE 48268
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
48183: LD_ADDR_VAR 0 6
48187: PUSH
48188: LD_VAR 0 1
48192: PPUSH
48193: LD_VAR 0 2
48197: PUSH
48198: LD_VAR 0 4
48202: ARRAY
48203: PUSH
48204: LD_INT 1
48206: ARRAY
48207: PPUSH
48208: LD_VAR 0 2
48212: PUSH
48213: LD_VAR 0 4
48217: ARRAY
48218: PUSH
48219: LD_INT 2
48221: ARRAY
48222: PPUSH
48223: CALL_OW 297
48227: ST_TO_ADDR
// if tdist < dist then
48228: LD_VAR 0 6
48232: PUSH
48233: LD_VAR 0 5
48237: LESS
48238: IFFALSE 48266
// begin hex := hexes [ i ] ;
48240: LD_ADDR_VAR 0 8
48244: PUSH
48245: LD_VAR 0 2
48249: PUSH
48250: LD_VAR 0 4
48254: ARRAY
48255: ST_TO_ADDR
// dist := tdist ;
48256: LD_ADDR_VAR 0 5
48260: PUSH
48261: LD_VAR 0 6
48265: ST_TO_ADDR
// end ; end ;
48266: GO 48180
48268: POP
48269: POP
// result := hex ;
48270: LD_ADDR_VAR 0 3
48274: PUSH
48275: LD_VAR 0 8
48279: ST_TO_ADDR
// end ;
48280: LD_VAR 0 3
48284: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
48285: LD_INT 0
48287: PPUSH
48288: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
48289: LD_VAR 0 1
48293: NOT
48294: PUSH
48295: LD_VAR 0 1
48299: PUSH
48300: LD_INT 21
48302: PUSH
48303: LD_INT 2
48305: PUSH
48306: EMPTY
48307: LIST
48308: LIST
48309: PUSH
48310: LD_INT 23
48312: PUSH
48313: LD_INT 2
48315: PUSH
48316: EMPTY
48317: LIST
48318: LIST
48319: PUSH
48320: EMPTY
48321: LIST
48322: LIST
48323: PPUSH
48324: CALL_OW 69
48328: IN
48329: NOT
48330: OR
48331: IFFALSE 48335
// exit ;
48333: GO 48382
// for i = 1 to 3 do
48335: LD_ADDR_VAR 0 3
48339: PUSH
48340: DOUBLE
48341: LD_INT 1
48343: DEC
48344: ST_TO_ADDR
48345: LD_INT 3
48347: PUSH
48348: FOR_TO
48349: IFFALSE 48380
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
48351: LD_VAR 0 1
48355: PPUSH
48356: CALL_OW 250
48360: PPUSH
48361: LD_VAR 0 1
48365: PPUSH
48366: CALL_OW 251
48370: PPUSH
48371: LD_INT 1
48373: PPUSH
48374: CALL_OW 453
48378: GO 48348
48380: POP
48381: POP
// end ;
48382: LD_VAR 0 2
48386: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48387: LD_INT 0
48389: PPUSH
48390: PPUSH
48391: PPUSH
48392: PPUSH
48393: PPUSH
48394: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48395: LD_VAR 0 1
48399: NOT
48400: PUSH
48401: LD_VAR 0 2
48405: NOT
48406: OR
48407: PUSH
48408: LD_VAR 0 1
48412: PPUSH
48413: CALL_OW 314
48417: OR
48418: IFFALSE 48422
// exit ;
48420: GO 48889
// if GetLives ( i ) < 250 then
48422: LD_VAR 0 4
48426: PPUSH
48427: CALL_OW 256
48431: PUSH
48432: LD_INT 250
48434: LESS
48435: IFFALSE 48448
// begin ComAutodestruct ( i ) ;
48437: LD_VAR 0 4
48441: PPUSH
48442: CALL 48285 0 1
// exit ;
48446: GO 48889
// end ; x := GetX ( enemy_unit ) ;
48448: LD_ADDR_VAR 0 7
48452: PUSH
48453: LD_VAR 0 2
48457: PPUSH
48458: CALL_OW 250
48462: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48463: LD_ADDR_VAR 0 8
48467: PUSH
48468: LD_VAR 0 2
48472: PPUSH
48473: CALL_OW 251
48477: ST_TO_ADDR
// if not x or not y then
48478: LD_VAR 0 7
48482: NOT
48483: PUSH
48484: LD_VAR 0 8
48488: NOT
48489: OR
48490: IFFALSE 48494
// exit ;
48492: GO 48889
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48494: LD_ADDR_VAR 0 6
48498: PUSH
48499: LD_VAR 0 7
48503: PPUSH
48504: LD_INT 0
48506: PPUSH
48507: LD_INT 4
48509: PPUSH
48510: CALL_OW 272
48514: PUSH
48515: LD_VAR 0 8
48519: PPUSH
48520: LD_INT 0
48522: PPUSH
48523: LD_INT 4
48525: PPUSH
48526: CALL_OW 273
48530: PUSH
48531: EMPTY
48532: LIST
48533: LIST
48534: PUSH
48535: LD_VAR 0 7
48539: PPUSH
48540: LD_INT 1
48542: PPUSH
48543: LD_INT 4
48545: PPUSH
48546: CALL_OW 272
48550: PUSH
48551: LD_VAR 0 8
48555: PPUSH
48556: LD_INT 1
48558: PPUSH
48559: LD_INT 4
48561: PPUSH
48562: CALL_OW 273
48566: PUSH
48567: EMPTY
48568: LIST
48569: LIST
48570: PUSH
48571: LD_VAR 0 7
48575: PPUSH
48576: LD_INT 2
48578: PPUSH
48579: LD_INT 4
48581: PPUSH
48582: CALL_OW 272
48586: PUSH
48587: LD_VAR 0 8
48591: PPUSH
48592: LD_INT 2
48594: PPUSH
48595: LD_INT 4
48597: PPUSH
48598: CALL_OW 273
48602: PUSH
48603: EMPTY
48604: LIST
48605: LIST
48606: PUSH
48607: LD_VAR 0 7
48611: PPUSH
48612: LD_INT 3
48614: PPUSH
48615: LD_INT 4
48617: PPUSH
48618: CALL_OW 272
48622: PUSH
48623: LD_VAR 0 8
48627: PPUSH
48628: LD_INT 3
48630: PPUSH
48631: LD_INT 4
48633: PPUSH
48634: CALL_OW 273
48638: PUSH
48639: EMPTY
48640: LIST
48641: LIST
48642: PUSH
48643: LD_VAR 0 7
48647: PPUSH
48648: LD_INT 4
48650: PPUSH
48651: LD_INT 4
48653: PPUSH
48654: CALL_OW 272
48658: PUSH
48659: LD_VAR 0 8
48663: PPUSH
48664: LD_INT 4
48666: PPUSH
48667: LD_INT 4
48669: PPUSH
48670: CALL_OW 273
48674: PUSH
48675: EMPTY
48676: LIST
48677: LIST
48678: PUSH
48679: LD_VAR 0 7
48683: PPUSH
48684: LD_INT 5
48686: PPUSH
48687: LD_INT 4
48689: PPUSH
48690: CALL_OW 272
48694: PUSH
48695: LD_VAR 0 8
48699: PPUSH
48700: LD_INT 5
48702: PPUSH
48703: LD_INT 4
48705: PPUSH
48706: CALL_OW 273
48710: PUSH
48711: EMPTY
48712: LIST
48713: LIST
48714: PUSH
48715: EMPTY
48716: LIST
48717: LIST
48718: LIST
48719: LIST
48720: LIST
48721: LIST
48722: ST_TO_ADDR
// for i = tmp downto 1 do
48723: LD_ADDR_VAR 0 4
48727: PUSH
48728: DOUBLE
48729: LD_VAR 0 6
48733: INC
48734: ST_TO_ADDR
48735: LD_INT 1
48737: PUSH
48738: FOR_DOWNTO
48739: IFFALSE 48840
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48741: LD_VAR 0 6
48745: PUSH
48746: LD_VAR 0 4
48750: ARRAY
48751: PUSH
48752: LD_INT 1
48754: ARRAY
48755: PPUSH
48756: LD_VAR 0 6
48760: PUSH
48761: LD_VAR 0 4
48765: ARRAY
48766: PUSH
48767: LD_INT 2
48769: ARRAY
48770: PPUSH
48771: CALL_OW 488
48775: NOT
48776: PUSH
48777: LD_VAR 0 6
48781: PUSH
48782: LD_VAR 0 4
48786: ARRAY
48787: PUSH
48788: LD_INT 1
48790: ARRAY
48791: PPUSH
48792: LD_VAR 0 6
48796: PUSH
48797: LD_VAR 0 4
48801: ARRAY
48802: PUSH
48803: LD_INT 2
48805: ARRAY
48806: PPUSH
48807: CALL_OW 428
48811: PUSH
48812: LD_INT 0
48814: NONEQUAL
48815: OR
48816: IFFALSE 48838
// tmp := Delete ( tmp , i ) ;
48818: LD_ADDR_VAR 0 6
48822: PUSH
48823: LD_VAR 0 6
48827: PPUSH
48828: LD_VAR 0 4
48832: PPUSH
48833: CALL_OW 3
48837: ST_TO_ADDR
48838: GO 48738
48840: POP
48841: POP
// j := GetClosestHex ( unit , tmp ) ;
48842: LD_ADDR_VAR 0 5
48846: PUSH
48847: LD_VAR 0 1
48851: PPUSH
48852: LD_VAR 0 6
48856: PPUSH
48857: CALL 48133 0 2
48861: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48862: LD_VAR 0 1
48866: PPUSH
48867: LD_VAR 0 5
48871: PUSH
48872: LD_INT 1
48874: ARRAY
48875: PPUSH
48876: LD_VAR 0 5
48880: PUSH
48881: LD_INT 2
48883: ARRAY
48884: PPUSH
48885: CALL_OW 111
// end ;
48889: LD_VAR 0 3
48893: RET
// export function PrepareApemanSoldier ( ) ; begin
48894: LD_INT 0
48896: PPUSH
// uc_nation := 0 ;
48897: LD_ADDR_OWVAR 21
48901: PUSH
48902: LD_INT 0
48904: ST_TO_ADDR
// hc_sex := sex_male ;
48905: LD_ADDR_OWVAR 27
48909: PUSH
48910: LD_INT 1
48912: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
48913: LD_ADDR_OWVAR 28
48917: PUSH
48918: LD_INT 15
48920: ST_TO_ADDR
// hc_gallery :=  ;
48921: LD_ADDR_OWVAR 33
48925: PUSH
48926: LD_STRING 
48928: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48929: LD_ADDR_OWVAR 31
48933: PUSH
48934: LD_INT 0
48936: PPUSH
48937: LD_INT 3
48939: PPUSH
48940: CALL_OW 12
48944: PUSH
48945: LD_INT 0
48947: PPUSH
48948: LD_INT 3
48950: PPUSH
48951: CALL_OW 12
48955: PUSH
48956: LD_INT 0
48958: PUSH
48959: LD_INT 0
48961: PUSH
48962: EMPTY
48963: LIST
48964: LIST
48965: LIST
48966: LIST
48967: ST_TO_ADDR
// end ;
48968: LD_VAR 0 1
48972: RET
// export function PrepareApemanEngineer ( ) ; begin
48973: LD_INT 0
48975: PPUSH
// uc_nation := 0 ;
48976: LD_ADDR_OWVAR 21
48980: PUSH
48981: LD_INT 0
48983: ST_TO_ADDR
// hc_sex := sex_male ;
48984: LD_ADDR_OWVAR 27
48988: PUSH
48989: LD_INT 1
48991: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
48992: LD_ADDR_OWVAR 28
48996: PUSH
48997: LD_INT 16
48999: ST_TO_ADDR
// hc_gallery :=  ;
49000: LD_ADDR_OWVAR 33
49004: PUSH
49005: LD_STRING 
49007: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
49008: LD_ADDR_OWVAR 31
49012: PUSH
49013: LD_INT 0
49015: PPUSH
49016: LD_INT 3
49018: PPUSH
49019: CALL_OW 12
49023: PUSH
49024: LD_INT 0
49026: PPUSH
49027: LD_INT 3
49029: PPUSH
49030: CALL_OW 12
49034: PUSH
49035: LD_INT 0
49037: PUSH
49038: LD_INT 0
49040: PUSH
49041: EMPTY
49042: LIST
49043: LIST
49044: LIST
49045: LIST
49046: ST_TO_ADDR
// end ;
49047: LD_VAR 0 1
49051: RET
// export function PrepareApeman ( agressivity ) ; begin
49052: LD_INT 0
49054: PPUSH
// uc_side := 0 ;
49055: LD_ADDR_OWVAR 20
49059: PUSH
49060: LD_INT 0
49062: ST_TO_ADDR
// uc_nation := 0 ;
49063: LD_ADDR_OWVAR 21
49067: PUSH
49068: LD_INT 0
49070: ST_TO_ADDR
// hc_sex := sex_male ;
49071: LD_ADDR_OWVAR 27
49075: PUSH
49076: LD_INT 1
49078: ST_TO_ADDR
// hc_class := class_apeman ;
49079: LD_ADDR_OWVAR 28
49083: PUSH
49084: LD_INT 12
49086: ST_TO_ADDR
// hc_gallery :=  ;
49087: LD_ADDR_OWVAR 33
49091: PUSH
49092: LD_STRING 
49094: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
49095: LD_ADDR_OWVAR 35
49099: PUSH
49100: LD_VAR 0 1
49104: NEG
49105: PPUSH
49106: LD_VAR 0 1
49110: PPUSH
49111: CALL_OW 12
49115: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
49116: LD_ADDR_OWVAR 31
49120: PUSH
49121: LD_INT 0
49123: PPUSH
49124: LD_INT 3
49126: PPUSH
49127: CALL_OW 12
49131: PUSH
49132: LD_INT 0
49134: PPUSH
49135: LD_INT 3
49137: PPUSH
49138: CALL_OW 12
49142: PUSH
49143: LD_INT 0
49145: PUSH
49146: LD_INT 0
49148: PUSH
49149: EMPTY
49150: LIST
49151: LIST
49152: LIST
49153: LIST
49154: ST_TO_ADDR
// end ;
49155: LD_VAR 0 2
49159: RET
// export function PrepareTiger ( agressivity ) ; begin
49160: LD_INT 0
49162: PPUSH
// uc_side := 0 ;
49163: LD_ADDR_OWVAR 20
49167: PUSH
49168: LD_INT 0
49170: ST_TO_ADDR
// uc_nation := 0 ;
49171: LD_ADDR_OWVAR 21
49175: PUSH
49176: LD_INT 0
49178: ST_TO_ADDR
// hc_class := class_tiger ;
49179: LD_ADDR_OWVAR 28
49183: PUSH
49184: LD_INT 14
49186: ST_TO_ADDR
// hc_gallery :=  ;
49187: LD_ADDR_OWVAR 33
49191: PUSH
49192: LD_STRING 
49194: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
49195: LD_ADDR_OWVAR 35
49199: PUSH
49200: LD_VAR 0 1
49204: NEG
49205: PPUSH
49206: LD_VAR 0 1
49210: PPUSH
49211: CALL_OW 12
49215: ST_TO_ADDR
// end ;
49216: LD_VAR 0 2
49220: RET
// export function PrepareEnchidna ( ) ; begin
49221: LD_INT 0
49223: PPUSH
// uc_side := 0 ;
49224: LD_ADDR_OWVAR 20
49228: PUSH
49229: LD_INT 0
49231: ST_TO_ADDR
// uc_nation := 0 ;
49232: LD_ADDR_OWVAR 21
49236: PUSH
49237: LD_INT 0
49239: ST_TO_ADDR
// hc_class := class_baggie ;
49240: LD_ADDR_OWVAR 28
49244: PUSH
49245: LD_INT 13
49247: ST_TO_ADDR
// hc_gallery :=  ;
49248: LD_ADDR_OWVAR 33
49252: PUSH
49253: LD_STRING 
49255: ST_TO_ADDR
// end ;
49256: LD_VAR 0 1
49260: RET
// export function PrepareFrog ( ) ; begin
49261: LD_INT 0
49263: PPUSH
// uc_side := 0 ;
49264: LD_ADDR_OWVAR 20
49268: PUSH
49269: LD_INT 0
49271: ST_TO_ADDR
// uc_nation := 0 ;
49272: LD_ADDR_OWVAR 21
49276: PUSH
49277: LD_INT 0
49279: ST_TO_ADDR
// hc_class := class_frog ;
49280: LD_ADDR_OWVAR 28
49284: PUSH
49285: LD_INT 19
49287: ST_TO_ADDR
// hc_gallery :=  ;
49288: LD_ADDR_OWVAR 33
49292: PUSH
49293: LD_STRING 
49295: ST_TO_ADDR
// end ;
49296: LD_VAR 0 1
49300: RET
// export function PrepareFish ( ) ; begin
49301: LD_INT 0
49303: PPUSH
// uc_side := 0 ;
49304: LD_ADDR_OWVAR 20
49308: PUSH
49309: LD_INT 0
49311: ST_TO_ADDR
// uc_nation := 0 ;
49312: LD_ADDR_OWVAR 21
49316: PUSH
49317: LD_INT 0
49319: ST_TO_ADDR
// hc_class := class_fish ;
49320: LD_ADDR_OWVAR 28
49324: PUSH
49325: LD_INT 20
49327: ST_TO_ADDR
// hc_gallery :=  ;
49328: LD_ADDR_OWVAR 33
49332: PUSH
49333: LD_STRING 
49335: ST_TO_ADDR
// end ;
49336: LD_VAR 0 1
49340: RET
// export function PrepareBird ( ) ; begin
49341: LD_INT 0
49343: PPUSH
// uc_side := 0 ;
49344: LD_ADDR_OWVAR 20
49348: PUSH
49349: LD_INT 0
49351: ST_TO_ADDR
// uc_nation := 0 ;
49352: LD_ADDR_OWVAR 21
49356: PUSH
49357: LD_INT 0
49359: ST_TO_ADDR
// hc_class := class_phororhacos ;
49360: LD_ADDR_OWVAR 28
49364: PUSH
49365: LD_INT 18
49367: ST_TO_ADDR
// hc_gallery :=  ;
49368: LD_ADDR_OWVAR 33
49372: PUSH
49373: LD_STRING 
49375: ST_TO_ADDR
// end ;
49376: LD_VAR 0 1
49380: RET
// export function PrepareHorse ( ) ; begin
49381: LD_INT 0
49383: PPUSH
// uc_side := 0 ;
49384: LD_ADDR_OWVAR 20
49388: PUSH
49389: LD_INT 0
49391: ST_TO_ADDR
// uc_nation := 0 ;
49392: LD_ADDR_OWVAR 21
49396: PUSH
49397: LD_INT 0
49399: ST_TO_ADDR
// hc_class := class_horse ;
49400: LD_ADDR_OWVAR 28
49404: PUSH
49405: LD_INT 21
49407: ST_TO_ADDR
// hc_gallery :=  ;
49408: LD_ADDR_OWVAR 33
49412: PUSH
49413: LD_STRING 
49415: ST_TO_ADDR
// end ;
49416: LD_VAR 0 1
49420: RET
// export function PrepareMastodont ( ) ; begin
49421: LD_INT 0
49423: PPUSH
// uc_side := 0 ;
49424: LD_ADDR_OWVAR 20
49428: PUSH
49429: LD_INT 0
49431: ST_TO_ADDR
// uc_nation := 0 ;
49432: LD_ADDR_OWVAR 21
49436: PUSH
49437: LD_INT 0
49439: ST_TO_ADDR
// vc_chassis := class_mastodont ;
49440: LD_ADDR_OWVAR 37
49444: PUSH
49445: LD_INT 31
49447: ST_TO_ADDR
// vc_control := control_rider ;
49448: LD_ADDR_OWVAR 38
49452: PUSH
49453: LD_INT 4
49455: ST_TO_ADDR
// end ;
49456: LD_VAR 0 1
49460: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
49461: LD_INT 0
49463: PPUSH
49464: PPUSH
49465: PPUSH
// uc_side = 0 ;
49466: LD_ADDR_OWVAR 20
49470: PUSH
49471: LD_INT 0
49473: ST_TO_ADDR
// uc_nation = 0 ;
49474: LD_ADDR_OWVAR 21
49478: PUSH
49479: LD_INT 0
49481: ST_TO_ADDR
// InitHc_All ( ) ;
49482: CALL_OW 584
// InitVc ;
49486: CALL_OW 20
// if mastodonts then
49490: LD_VAR 0 6
49494: IFFALSE 49561
// for i = 1 to mastodonts do
49496: LD_ADDR_VAR 0 11
49500: PUSH
49501: DOUBLE
49502: LD_INT 1
49504: DEC
49505: ST_TO_ADDR
49506: LD_VAR 0 6
49510: PUSH
49511: FOR_TO
49512: IFFALSE 49559
// begin vc_chassis := 31 ;
49514: LD_ADDR_OWVAR 37
49518: PUSH
49519: LD_INT 31
49521: ST_TO_ADDR
// vc_control := control_rider ;
49522: LD_ADDR_OWVAR 38
49526: PUSH
49527: LD_INT 4
49529: ST_TO_ADDR
// animal := CreateVehicle ;
49530: LD_ADDR_VAR 0 12
49534: PUSH
49535: CALL_OW 45
49539: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49540: LD_VAR 0 12
49544: PPUSH
49545: LD_VAR 0 8
49549: PPUSH
49550: LD_INT 0
49552: PPUSH
49553: CALL 51689 0 3
// end ;
49557: GO 49511
49559: POP
49560: POP
// if horses then
49561: LD_VAR 0 5
49565: IFFALSE 49632
// for i = 1 to horses do
49567: LD_ADDR_VAR 0 11
49571: PUSH
49572: DOUBLE
49573: LD_INT 1
49575: DEC
49576: ST_TO_ADDR
49577: LD_VAR 0 5
49581: PUSH
49582: FOR_TO
49583: IFFALSE 49630
// begin hc_class := 21 ;
49585: LD_ADDR_OWVAR 28
49589: PUSH
49590: LD_INT 21
49592: ST_TO_ADDR
// hc_gallery :=  ;
49593: LD_ADDR_OWVAR 33
49597: PUSH
49598: LD_STRING 
49600: ST_TO_ADDR
// animal := CreateHuman ;
49601: LD_ADDR_VAR 0 12
49605: PUSH
49606: CALL_OW 44
49610: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49611: LD_VAR 0 12
49615: PPUSH
49616: LD_VAR 0 8
49620: PPUSH
49621: LD_INT 0
49623: PPUSH
49624: CALL 51689 0 3
// end ;
49628: GO 49582
49630: POP
49631: POP
// if birds then
49632: LD_VAR 0 1
49636: IFFALSE 49703
// for i = 1 to birds do
49638: LD_ADDR_VAR 0 11
49642: PUSH
49643: DOUBLE
49644: LD_INT 1
49646: DEC
49647: ST_TO_ADDR
49648: LD_VAR 0 1
49652: PUSH
49653: FOR_TO
49654: IFFALSE 49701
// begin hc_class = 18 ;
49656: LD_ADDR_OWVAR 28
49660: PUSH
49661: LD_INT 18
49663: ST_TO_ADDR
// hc_gallery =  ;
49664: LD_ADDR_OWVAR 33
49668: PUSH
49669: LD_STRING 
49671: ST_TO_ADDR
// animal := CreateHuman ;
49672: LD_ADDR_VAR 0 12
49676: PUSH
49677: CALL_OW 44
49681: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49682: LD_VAR 0 12
49686: PPUSH
49687: LD_VAR 0 8
49691: PPUSH
49692: LD_INT 0
49694: PPUSH
49695: CALL 51689 0 3
// end ;
49699: GO 49653
49701: POP
49702: POP
// if tigers then
49703: LD_VAR 0 2
49707: IFFALSE 49791
// for i = 1 to tigers do
49709: LD_ADDR_VAR 0 11
49713: PUSH
49714: DOUBLE
49715: LD_INT 1
49717: DEC
49718: ST_TO_ADDR
49719: LD_VAR 0 2
49723: PUSH
49724: FOR_TO
49725: IFFALSE 49789
// begin hc_class = class_tiger ;
49727: LD_ADDR_OWVAR 28
49731: PUSH
49732: LD_INT 14
49734: ST_TO_ADDR
// hc_gallery =  ;
49735: LD_ADDR_OWVAR 33
49739: PUSH
49740: LD_STRING 
49742: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49743: LD_ADDR_OWVAR 35
49747: PUSH
49748: LD_INT 7
49750: NEG
49751: PPUSH
49752: LD_INT 7
49754: PPUSH
49755: CALL_OW 12
49759: ST_TO_ADDR
// animal := CreateHuman ;
49760: LD_ADDR_VAR 0 12
49764: PUSH
49765: CALL_OW 44
49769: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49770: LD_VAR 0 12
49774: PPUSH
49775: LD_VAR 0 8
49779: PPUSH
49780: LD_INT 0
49782: PPUSH
49783: CALL 51689 0 3
// end ;
49787: GO 49724
49789: POP
49790: POP
// if apemans then
49791: LD_VAR 0 3
49795: IFFALSE 49918
// for i = 1 to apemans do
49797: LD_ADDR_VAR 0 11
49801: PUSH
49802: DOUBLE
49803: LD_INT 1
49805: DEC
49806: ST_TO_ADDR
49807: LD_VAR 0 3
49811: PUSH
49812: FOR_TO
49813: IFFALSE 49916
// begin hc_class = class_apeman ;
49815: LD_ADDR_OWVAR 28
49819: PUSH
49820: LD_INT 12
49822: ST_TO_ADDR
// hc_gallery =  ;
49823: LD_ADDR_OWVAR 33
49827: PUSH
49828: LD_STRING 
49830: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
49831: LD_ADDR_OWVAR 35
49835: PUSH
49836: LD_INT 2
49838: NEG
49839: PPUSH
49840: LD_INT 2
49842: PPUSH
49843: CALL_OW 12
49847: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49848: LD_ADDR_OWVAR 31
49852: PUSH
49853: LD_INT 1
49855: PPUSH
49856: LD_INT 3
49858: PPUSH
49859: CALL_OW 12
49863: PUSH
49864: LD_INT 1
49866: PPUSH
49867: LD_INT 3
49869: PPUSH
49870: CALL_OW 12
49874: PUSH
49875: LD_INT 0
49877: PUSH
49878: LD_INT 0
49880: PUSH
49881: EMPTY
49882: LIST
49883: LIST
49884: LIST
49885: LIST
49886: ST_TO_ADDR
// animal := CreateHuman ;
49887: LD_ADDR_VAR 0 12
49891: PUSH
49892: CALL_OW 44
49896: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49897: LD_VAR 0 12
49901: PPUSH
49902: LD_VAR 0 8
49906: PPUSH
49907: LD_INT 0
49909: PPUSH
49910: CALL 51689 0 3
// end ;
49914: GO 49812
49916: POP
49917: POP
// if enchidnas then
49918: LD_VAR 0 4
49922: IFFALSE 49989
// for i = 1 to enchidnas do
49924: LD_ADDR_VAR 0 11
49928: PUSH
49929: DOUBLE
49930: LD_INT 1
49932: DEC
49933: ST_TO_ADDR
49934: LD_VAR 0 4
49938: PUSH
49939: FOR_TO
49940: IFFALSE 49987
// begin hc_class = 13 ;
49942: LD_ADDR_OWVAR 28
49946: PUSH
49947: LD_INT 13
49949: ST_TO_ADDR
// hc_gallery =  ;
49950: LD_ADDR_OWVAR 33
49954: PUSH
49955: LD_STRING 
49957: ST_TO_ADDR
// animal := CreateHuman ;
49958: LD_ADDR_VAR 0 12
49962: PUSH
49963: CALL_OW 44
49967: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49968: LD_VAR 0 12
49972: PPUSH
49973: LD_VAR 0 8
49977: PPUSH
49978: LD_INT 0
49980: PPUSH
49981: CALL 51689 0 3
// end ;
49985: GO 49939
49987: POP
49988: POP
// if fishes then
49989: LD_VAR 0 7
49993: IFFALSE 50060
// for i = 1 to fishes do
49995: LD_ADDR_VAR 0 11
49999: PUSH
50000: DOUBLE
50001: LD_INT 1
50003: DEC
50004: ST_TO_ADDR
50005: LD_VAR 0 7
50009: PUSH
50010: FOR_TO
50011: IFFALSE 50058
// begin hc_class = 20 ;
50013: LD_ADDR_OWVAR 28
50017: PUSH
50018: LD_INT 20
50020: ST_TO_ADDR
// hc_gallery =  ;
50021: LD_ADDR_OWVAR 33
50025: PUSH
50026: LD_STRING 
50028: ST_TO_ADDR
// animal := CreateHuman ;
50029: LD_ADDR_VAR 0 12
50033: PUSH
50034: CALL_OW 44
50038: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
50039: LD_VAR 0 12
50043: PPUSH
50044: LD_VAR 0 9
50048: PPUSH
50049: LD_INT 0
50051: PPUSH
50052: CALL 51689 0 3
// end ;
50056: GO 50010
50058: POP
50059: POP
// end ;
50060: LD_VAR 0 10
50064: RET
// export function WantHeal ( sci , unit ) ; begin
50065: LD_INT 0
50067: PPUSH
// if GetTaskList ( sci ) > 0 then
50068: LD_VAR 0 1
50072: PPUSH
50073: CALL_OW 437
50077: PUSH
50078: LD_INT 0
50080: GREATER
50081: IFFALSE 50151
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
50083: LD_VAR 0 1
50087: PPUSH
50088: CALL_OW 437
50092: PUSH
50093: LD_INT 1
50095: ARRAY
50096: PUSH
50097: LD_INT 1
50099: ARRAY
50100: PUSH
50101: LD_STRING l
50103: EQUAL
50104: PUSH
50105: LD_VAR 0 1
50109: PPUSH
50110: CALL_OW 437
50114: PUSH
50115: LD_INT 1
50117: ARRAY
50118: PUSH
50119: LD_INT 4
50121: ARRAY
50122: PUSH
50123: LD_VAR 0 2
50127: EQUAL
50128: AND
50129: IFFALSE 50141
// result := true else
50131: LD_ADDR_VAR 0 3
50135: PUSH
50136: LD_INT 1
50138: ST_TO_ADDR
50139: GO 50149
// result := false ;
50141: LD_ADDR_VAR 0 3
50145: PUSH
50146: LD_INT 0
50148: ST_TO_ADDR
// end else
50149: GO 50159
// result := false ;
50151: LD_ADDR_VAR 0 3
50155: PUSH
50156: LD_INT 0
50158: ST_TO_ADDR
// end ;
50159: LD_VAR 0 3
50163: RET
// export function HealTarget ( sci ) ; begin
50164: LD_INT 0
50166: PPUSH
// if not sci then
50167: LD_VAR 0 1
50171: NOT
50172: IFFALSE 50176
// exit ;
50174: GO 50241
// result := 0 ;
50176: LD_ADDR_VAR 0 2
50180: PUSH
50181: LD_INT 0
50183: ST_TO_ADDR
// if GetTaskList ( sci ) then
50184: LD_VAR 0 1
50188: PPUSH
50189: CALL_OW 437
50193: IFFALSE 50241
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
50195: LD_VAR 0 1
50199: PPUSH
50200: CALL_OW 437
50204: PUSH
50205: LD_INT 1
50207: ARRAY
50208: PUSH
50209: LD_INT 1
50211: ARRAY
50212: PUSH
50213: LD_STRING l
50215: EQUAL
50216: IFFALSE 50241
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
50218: LD_ADDR_VAR 0 2
50222: PUSH
50223: LD_VAR 0 1
50227: PPUSH
50228: CALL_OW 437
50232: PUSH
50233: LD_INT 1
50235: ARRAY
50236: PUSH
50237: LD_INT 4
50239: ARRAY
50240: ST_TO_ADDR
// end ;
50241: LD_VAR 0 2
50245: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
50246: LD_INT 0
50248: PPUSH
50249: PPUSH
50250: PPUSH
50251: PPUSH
// if not base_units then
50252: LD_VAR 0 1
50256: NOT
50257: IFFALSE 50261
// exit ;
50259: GO 50348
// result := false ;
50261: LD_ADDR_VAR 0 2
50265: PUSH
50266: LD_INT 0
50268: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
50269: LD_ADDR_VAR 0 5
50273: PUSH
50274: LD_VAR 0 1
50278: PPUSH
50279: LD_INT 21
50281: PUSH
50282: LD_INT 3
50284: PUSH
50285: EMPTY
50286: LIST
50287: LIST
50288: PPUSH
50289: CALL_OW 72
50293: ST_TO_ADDR
// if not tmp then
50294: LD_VAR 0 5
50298: NOT
50299: IFFALSE 50303
// exit ;
50301: GO 50348
// for i in tmp do
50303: LD_ADDR_VAR 0 3
50307: PUSH
50308: LD_VAR 0 5
50312: PUSH
50313: FOR_IN
50314: IFFALSE 50346
// begin result := EnemyInRange ( i , 22 ) ;
50316: LD_ADDR_VAR 0 2
50320: PUSH
50321: LD_VAR 0 3
50325: PPUSH
50326: LD_INT 22
50328: PPUSH
50329: CALL 47935 0 2
50333: ST_TO_ADDR
// if result then
50334: LD_VAR 0 2
50338: IFFALSE 50344
// exit ;
50340: POP
50341: POP
50342: GO 50348
// end ;
50344: GO 50313
50346: POP
50347: POP
// end ;
50348: LD_VAR 0 2
50352: RET
// export function FilterByTag ( units , tag ) ; begin
50353: LD_INT 0
50355: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
50356: LD_ADDR_VAR 0 3
50360: PUSH
50361: LD_VAR 0 1
50365: PPUSH
50366: LD_INT 120
50368: PUSH
50369: LD_VAR 0 2
50373: PUSH
50374: EMPTY
50375: LIST
50376: LIST
50377: PPUSH
50378: CALL_OW 72
50382: ST_TO_ADDR
// end ;
50383: LD_VAR 0 3
50387: RET
// export function IsDriver ( un ) ; begin
50388: LD_INT 0
50390: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
50391: LD_ADDR_VAR 0 2
50395: PUSH
50396: LD_VAR 0 1
50400: PUSH
50401: LD_INT 55
50403: PUSH
50404: EMPTY
50405: LIST
50406: PPUSH
50407: CALL_OW 69
50411: IN
50412: ST_TO_ADDR
// end ;
50413: LD_VAR 0 2
50417: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
50418: LD_INT 0
50420: PPUSH
50421: PPUSH
// list := [ ] ;
50422: LD_ADDR_VAR 0 5
50426: PUSH
50427: EMPTY
50428: ST_TO_ADDR
// case d of 0 :
50429: LD_VAR 0 3
50433: PUSH
50434: LD_INT 0
50436: DOUBLE
50437: EQUAL
50438: IFTRUE 50442
50440: GO 50575
50442: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
50443: LD_ADDR_VAR 0 5
50447: PUSH
50448: LD_VAR 0 1
50452: PUSH
50453: LD_INT 4
50455: MINUS
50456: PUSH
50457: LD_VAR 0 2
50461: PUSH
50462: LD_INT 4
50464: MINUS
50465: PUSH
50466: LD_INT 2
50468: PUSH
50469: EMPTY
50470: LIST
50471: LIST
50472: LIST
50473: PUSH
50474: LD_VAR 0 1
50478: PUSH
50479: LD_INT 3
50481: MINUS
50482: PUSH
50483: LD_VAR 0 2
50487: PUSH
50488: LD_INT 1
50490: PUSH
50491: EMPTY
50492: LIST
50493: LIST
50494: LIST
50495: PUSH
50496: LD_VAR 0 1
50500: PUSH
50501: LD_INT 4
50503: PLUS
50504: PUSH
50505: LD_VAR 0 2
50509: PUSH
50510: LD_INT 4
50512: PUSH
50513: EMPTY
50514: LIST
50515: LIST
50516: LIST
50517: PUSH
50518: LD_VAR 0 1
50522: PUSH
50523: LD_INT 3
50525: PLUS
50526: PUSH
50527: LD_VAR 0 2
50531: PUSH
50532: LD_INT 3
50534: PLUS
50535: PUSH
50536: LD_INT 5
50538: PUSH
50539: EMPTY
50540: LIST
50541: LIST
50542: LIST
50543: PUSH
50544: LD_VAR 0 1
50548: PUSH
50549: LD_VAR 0 2
50553: PUSH
50554: LD_INT 4
50556: PLUS
50557: PUSH
50558: LD_INT 0
50560: PUSH
50561: EMPTY
50562: LIST
50563: LIST
50564: LIST
50565: PUSH
50566: EMPTY
50567: LIST
50568: LIST
50569: LIST
50570: LIST
50571: LIST
50572: ST_TO_ADDR
// end ; 1 :
50573: GO 51273
50575: LD_INT 1
50577: DOUBLE
50578: EQUAL
50579: IFTRUE 50583
50581: GO 50716
50583: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
50584: LD_ADDR_VAR 0 5
50588: PUSH
50589: LD_VAR 0 1
50593: PUSH
50594: LD_VAR 0 2
50598: PUSH
50599: LD_INT 4
50601: MINUS
50602: PUSH
50603: LD_INT 3
50605: PUSH
50606: EMPTY
50607: LIST
50608: LIST
50609: LIST
50610: PUSH
50611: LD_VAR 0 1
50615: PUSH
50616: LD_INT 3
50618: MINUS
50619: PUSH
50620: LD_VAR 0 2
50624: PUSH
50625: LD_INT 3
50627: MINUS
50628: PUSH
50629: LD_INT 2
50631: PUSH
50632: EMPTY
50633: LIST
50634: LIST
50635: LIST
50636: PUSH
50637: LD_VAR 0 1
50641: PUSH
50642: LD_INT 4
50644: MINUS
50645: PUSH
50646: LD_VAR 0 2
50650: PUSH
50651: LD_INT 1
50653: PUSH
50654: EMPTY
50655: LIST
50656: LIST
50657: LIST
50658: PUSH
50659: LD_VAR 0 1
50663: PUSH
50664: LD_VAR 0 2
50668: PUSH
50669: LD_INT 3
50671: PLUS
50672: PUSH
50673: LD_INT 0
50675: PUSH
50676: EMPTY
50677: LIST
50678: LIST
50679: LIST
50680: PUSH
50681: LD_VAR 0 1
50685: PUSH
50686: LD_INT 4
50688: PLUS
50689: PUSH
50690: LD_VAR 0 2
50694: PUSH
50695: LD_INT 4
50697: PLUS
50698: PUSH
50699: LD_INT 5
50701: PUSH
50702: EMPTY
50703: LIST
50704: LIST
50705: LIST
50706: PUSH
50707: EMPTY
50708: LIST
50709: LIST
50710: LIST
50711: LIST
50712: LIST
50713: ST_TO_ADDR
// end ; 2 :
50714: GO 51273
50716: LD_INT 2
50718: DOUBLE
50719: EQUAL
50720: IFTRUE 50724
50722: GO 50853
50724: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
50725: LD_ADDR_VAR 0 5
50729: PUSH
50730: LD_VAR 0 1
50734: PUSH
50735: LD_VAR 0 2
50739: PUSH
50740: LD_INT 3
50742: MINUS
50743: PUSH
50744: LD_INT 3
50746: PUSH
50747: EMPTY
50748: LIST
50749: LIST
50750: LIST
50751: PUSH
50752: LD_VAR 0 1
50756: PUSH
50757: LD_INT 4
50759: PLUS
50760: PUSH
50761: LD_VAR 0 2
50765: PUSH
50766: LD_INT 4
50768: PUSH
50769: EMPTY
50770: LIST
50771: LIST
50772: LIST
50773: PUSH
50774: LD_VAR 0 1
50778: PUSH
50779: LD_VAR 0 2
50783: PUSH
50784: LD_INT 4
50786: PLUS
50787: PUSH
50788: LD_INT 0
50790: PUSH
50791: EMPTY
50792: LIST
50793: LIST
50794: LIST
50795: PUSH
50796: LD_VAR 0 1
50800: PUSH
50801: LD_INT 3
50803: MINUS
50804: PUSH
50805: LD_VAR 0 2
50809: PUSH
50810: LD_INT 1
50812: PUSH
50813: EMPTY
50814: LIST
50815: LIST
50816: LIST
50817: PUSH
50818: LD_VAR 0 1
50822: PUSH
50823: LD_INT 4
50825: MINUS
50826: PUSH
50827: LD_VAR 0 2
50831: PUSH
50832: LD_INT 4
50834: MINUS
50835: PUSH
50836: LD_INT 2
50838: PUSH
50839: EMPTY
50840: LIST
50841: LIST
50842: LIST
50843: PUSH
50844: EMPTY
50845: LIST
50846: LIST
50847: LIST
50848: LIST
50849: LIST
50850: ST_TO_ADDR
// end ; 3 :
50851: GO 51273
50853: LD_INT 3
50855: DOUBLE
50856: EQUAL
50857: IFTRUE 50861
50859: GO 50994
50861: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
50862: LD_ADDR_VAR 0 5
50866: PUSH
50867: LD_VAR 0 1
50871: PUSH
50872: LD_INT 3
50874: PLUS
50875: PUSH
50876: LD_VAR 0 2
50880: PUSH
50881: LD_INT 4
50883: PUSH
50884: EMPTY
50885: LIST
50886: LIST
50887: LIST
50888: PUSH
50889: LD_VAR 0 1
50893: PUSH
50894: LD_INT 4
50896: PLUS
50897: PUSH
50898: LD_VAR 0 2
50902: PUSH
50903: LD_INT 4
50905: PLUS
50906: PUSH
50907: LD_INT 5
50909: PUSH
50910: EMPTY
50911: LIST
50912: LIST
50913: LIST
50914: PUSH
50915: LD_VAR 0 1
50919: PUSH
50920: LD_INT 4
50922: MINUS
50923: PUSH
50924: LD_VAR 0 2
50928: PUSH
50929: LD_INT 1
50931: PUSH
50932: EMPTY
50933: LIST
50934: LIST
50935: LIST
50936: PUSH
50937: LD_VAR 0 1
50941: PUSH
50942: LD_VAR 0 2
50946: PUSH
50947: LD_INT 4
50949: MINUS
50950: PUSH
50951: LD_INT 3
50953: PUSH
50954: EMPTY
50955: LIST
50956: LIST
50957: LIST
50958: PUSH
50959: LD_VAR 0 1
50963: PUSH
50964: LD_INT 3
50966: MINUS
50967: PUSH
50968: LD_VAR 0 2
50972: PUSH
50973: LD_INT 3
50975: MINUS
50976: PUSH
50977: LD_INT 2
50979: PUSH
50980: EMPTY
50981: LIST
50982: LIST
50983: LIST
50984: PUSH
50985: EMPTY
50986: LIST
50987: LIST
50988: LIST
50989: LIST
50990: LIST
50991: ST_TO_ADDR
// end ; 4 :
50992: GO 51273
50994: LD_INT 4
50996: DOUBLE
50997: EQUAL
50998: IFTRUE 51002
51000: GO 51135
51002: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
51003: LD_ADDR_VAR 0 5
51007: PUSH
51008: LD_VAR 0 1
51012: PUSH
51013: LD_VAR 0 2
51017: PUSH
51018: LD_INT 4
51020: PLUS
51021: PUSH
51022: LD_INT 0
51024: PUSH
51025: EMPTY
51026: LIST
51027: LIST
51028: LIST
51029: PUSH
51030: LD_VAR 0 1
51034: PUSH
51035: LD_INT 3
51037: PLUS
51038: PUSH
51039: LD_VAR 0 2
51043: PUSH
51044: LD_INT 3
51046: PLUS
51047: PUSH
51048: LD_INT 5
51050: PUSH
51051: EMPTY
51052: LIST
51053: LIST
51054: LIST
51055: PUSH
51056: LD_VAR 0 1
51060: PUSH
51061: LD_INT 4
51063: PLUS
51064: PUSH
51065: LD_VAR 0 2
51069: PUSH
51070: LD_INT 4
51072: PUSH
51073: EMPTY
51074: LIST
51075: LIST
51076: LIST
51077: PUSH
51078: LD_VAR 0 1
51082: PUSH
51083: LD_VAR 0 2
51087: PUSH
51088: LD_INT 3
51090: MINUS
51091: PUSH
51092: LD_INT 3
51094: PUSH
51095: EMPTY
51096: LIST
51097: LIST
51098: LIST
51099: PUSH
51100: LD_VAR 0 1
51104: PUSH
51105: LD_INT 4
51107: MINUS
51108: PUSH
51109: LD_VAR 0 2
51113: PUSH
51114: LD_INT 4
51116: MINUS
51117: PUSH
51118: LD_INT 2
51120: PUSH
51121: EMPTY
51122: LIST
51123: LIST
51124: LIST
51125: PUSH
51126: EMPTY
51127: LIST
51128: LIST
51129: LIST
51130: LIST
51131: LIST
51132: ST_TO_ADDR
// end ; 5 :
51133: GO 51273
51135: LD_INT 5
51137: DOUBLE
51138: EQUAL
51139: IFTRUE 51143
51141: GO 51272
51143: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
51144: LD_ADDR_VAR 0 5
51148: PUSH
51149: LD_VAR 0 1
51153: PUSH
51154: LD_INT 4
51156: MINUS
51157: PUSH
51158: LD_VAR 0 2
51162: PUSH
51163: LD_INT 1
51165: PUSH
51166: EMPTY
51167: LIST
51168: LIST
51169: LIST
51170: PUSH
51171: LD_VAR 0 1
51175: PUSH
51176: LD_VAR 0 2
51180: PUSH
51181: LD_INT 4
51183: MINUS
51184: PUSH
51185: LD_INT 3
51187: PUSH
51188: EMPTY
51189: LIST
51190: LIST
51191: LIST
51192: PUSH
51193: LD_VAR 0 1
51197: PUSH
51198: LD_INT 4
51200: PLUS
51201: PUSH
51202: LD_VAR 0 2
51206: PUSH
51207: LD_INT 4
51209: PLUS
51210: PUSH
51211: LD_INT 5
51213: PUSH
51214: EMPTY
51215: LIST
51216: LIST
51217: LIST
51218: PUSH
51219: LD_VAR 0 1
51223: PUSH
51224: LD_INT 3
51226: PLUS
51227: PUSH
51228: LD_VAR 0 2
51232: PUSH
51233: LD_INT 4
51235: PUSH
51236: EMPTY
51237: LIST
51238: LIST
51239: LIST
51240: PUSH
51241: LD_VAR 0 1
51245: PUSH
51246: LD_VAR 0 2
51250: PUSH
51251: LD_INT 3
51253: PLUS
51254: PUSH
51255: LD_INT 0
51257: PUSH
51258: EMPTY
51259: LIST
51260: LIST
51261: LIST
51262: PUSH
51263: EMPTY
51264: LIST
51265: LIST
51266: LIST
51267: LIST
51268: LIST
51269: ST_TO_ADDR
// end ; end ;
51270: GO 51273
51272: POP
// result := list ;
51273: LD_ADDR_VAR 0 4
51277: PUSH
51278: LD_VAR 0 5
51282: ST_TO_ADDR
// end ;
51283: LD_VAR 0 4
51287: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
51288: LD_INT 0
51290: PPUSH
51291: PPUSH
51292: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
51293: LD_VAR 0 1
51297: NOT
51298: PUSH
51299: LD_VAR 0 2
51303: PUSH
51304: LD_INT 1
51306: PUSH
51307: LD_INT 2
51309: PUSH
51310: LD_INT 3
51312: PUSH
51313: LD_INT 4
51315: PUSH
51316: EMPTY
51317: LIST
51318: LIST
51319: LIST
51320: LIST
51321: IN
51322: NOT
51323: OR
51324: IFFALSE 51328
// exit ;
51326: GO 51411
// tmp := [ ] ;
51328: LD_ADDR_VAR 0 5
51332: PUSH
51333: EMPTY
51334: ST_TO_ADDR
// for i in units do
51335: LD_ADDR_VAR 0 4
51339: PUSH
51340: LD_VAR 0 1
51344: PUSH
51345: FOR_IN
51346: IFFALSE 51380
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
51348: LD_ADDR_VAR 0 5
51352: PUSH
51353: LD_VAR 0 5
51357: PPUSH
51358: LD_VAR 0 4
51362: PPUSH
51363: LD_VAR 0 2
51367: PPUSH
51368: CALL_OW 259
51372: PPUSH
51373: CALL 52771 0 2
51377: ST_TO_ADDR
51378: GO 51345
51380: POP
51381: POP
// if not tmp then
51382: LD_VAR 0 5
51386: NOT
51387: IFFALSE 51391
// exit ;
51389: GO 51411
// result := SortListByListDesc ( units , tmp ) ;
51391: LD_ADDR_VAR 0 3
51395: PUSH
51396: LD_VAR 0 1
51400: PPUSH
51401: LD_VAR 0 5
51405: PPUSH
51406: CALL_OW 77
51410: ST_TO_ADDR
// end ;
51411: LD_VAR 0 3
51415: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
51416: LD_INT 0
51418: PPUSH
51419: PPUSH
51420: PPUSH
// result := false ;
51421: LD_ADDR_VAR 0 3
51425: PUSH
51426: LD_INT 0
51428: ST_TO_ADDR
// if not building then
51429: LD_VAR 0 2
51433: NOT
51434: IFFALSE 51438
// exit ;
51436: GO 51576
// x := GetX ( building ) ;
51438: LD_ADDR_VAR 0 4
51442: PUSH
51443: LD_VAR 0 2
51447: PPUSH
51448: CALL_OW 250
51452: ST_TO_ADDR
// y := GetY ( building ) ;
51453: LD_ADDR_VAR 0 5
51457: PUSH
51458: LD_VAR 0 2
51462: PPUSH
51463: CALL_OW 251
51467: ST_TO_ADDR
// if not x or not y then
51468: LD_VAR 0 4
51472: NOT
51473: PUSH
51474: LD_VAR 0 5
51478: NOT
51479: OR
51480: IFFALSE 51484
// exit ;
51482: GO 51576
// if GetTaskList ( unit ) then
51484: LD_VAR 0 1
51488: PPUSH
51489: CALL_OW 437
51493: IFFALSE 51576
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
51495: LD_STRING e
51497: PUSH
51498: LD_VAR 0 1
51502: PPUSH
51503: CALL_OW 437
51507: PUSH
51508: LD_INT 1
51510: ARRAY
51511: PUSH
51512: LD_INT 1
51514: ARRAY
51515: EQUAL
51516: PUSH
51517: LD_VAR 0 4
51521: PUSH
51522: LD_VAR 0 1
51526: PPUSH
51527: CALL_OW 437
51531: PUSH
51532: LD_INT 1
51534: ARRAY
51535: PUSH
51536: LD_INT 2
51538: ARRAY
51539: EQUAL
51540: AND
51541: PUSH
51542: LD_VAR 0 5
51546: PUSH
51547: LD_VAR 0 1
51551: PPUSH
51552: CALL_OW 437
51556: PUSH
51557: LD_INT 1
51559: ARRAY
51560: PUSH
51561: LD_INT 3
51563: ARRAY
51564: EQUAL
51565: AND
51566: IFFALSE 51576
// result := true end ;
51568: LD_ADDR_VAR 0 3
51572: PUSH
51573: LD_INT 1
51575: ST_TO_ADDR
// end ;
51576: LD_VAR 0 3
51580: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
51581: LD_INT 0
51583: PPUSH
// result := false ;
51584: LD_ADDR_VAR 0 4
51588: PUSH
51589: LD_INT 0
51591: ST_TO_ADDR
// if GetTaskList ( unit ) then
51592: LD_VAR 0 1
51596: PPUSH
51597: CALL_OW 437
51601: IFFALSE 51684
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
51603: LD_STRING M
51605: PUSH
51606: LD_VAR 0 1
51610: PPUSH
51611: CALL_OW 437
51615: PUSH
51616: LD_INT 1
51618: ARRAY
51619: PUSH
51620: LD_INT 1
51622: ARRAY
51623: EQUAL
51624: PUSH
51625: LD_VAR 0 2
51629: PUSH
51630: LD_VAR 0 1
51634: PPUSH
51635: CALL_OW 437
51639: PUSH
51640: LD_INT 1
51642: ARRAY
51643: PUSH
51644: LD_INT 2
51646: ARRAY
51647: EQUAL
51648: AND
51649: PUSH
51650: LD_VAR 0 3
51654: PUSH
51655: LD_VAR 0 1
51659: PPUSH
51660: CALL_OW 437
51664: PUSH
51665: LD_INT 1
51667: ARRAY
51668: PUSH
51669: LD_INT 3
51671: ARRAY
51672: EQUAL
51673: AND
51674: IFFALSE 51684
// result := true ;
51676: LD_ADDR_VAR 0 4
51680: PUSH
51681: LD_INT 1
51683: ST_TO_ADDR
// end ; end ;
51684: LD_VAR 0 4
51688: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
51689: LD_INT 0
51691: PPUSH
51692: PPUSH
51693: PPUSH
51694: PPUSH
// if not unit or not area then
51695: LD_VAR 0 1
51699: NOT
51700: PUSH
51701: LD_VAR 0 2
51705: NOT
51706: OR
51707: IFFALSE 51711
// exit ;
51709: GO 51874
// tmp := AreaToList ( area , i ) ;
51711: LD_ADDR_VAR 0 6
51715: PUSH
51716: LD_VAR 0 2
51720: PPUSH
51721: LD_VAR 0 5
51725: PPUSH
51726: CALL_OW 517
51730: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
51731: LD_ADDR_VAR 0 5
51735: PUSH
51736: DOUBLE
51737: LD_INT 1
51739: DEC
51740: ST_TO_ADDR
51741: LD_VAR 0 6
51745: PUSH
51746: LD_INT 1
51748: ARRAY
51749: PUSH
51750: FOR_TO
51751: IFFALSE 51872
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
51753: LD_ADDR_VAR 0 7
51757: PUSH
51758: LD_VAR 0 6
51762: PUSH
51763: LD_INT 1
51765: ARRAY
51766: PUSH
51767: LD_VAR 0 5
51771: ARRAY
51772: PUSH
51773: LD_VAR 0 6
51777: PUSH
51778: LD_INT 2
51780: ARRAY
51781: PUSH
51782: LD_VAR 0 5
51786: ARRAY
51787: PUSH
51788: EMPTY
51789: LIST
51790: LIST
51791: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
51792: LD_INT 92
51794: PUSH
51795: LD_VAR 0 7
51799: PUSH
51800: LD_INT 1
51802: ARRAY
51803: PUSH
51804: LD_VAR 0 7
51808: PUSH
51809: LD_INT 2
51811: ARRAY
51812: PUSH
51813: LD_INT 3
51815: PUSH
51816: EMPTY
51817: LIST
51818: LIST
51819: LIST
51820: LIST
51821: PPUSH
51822: CALL_OW 69
51826: PUSH
51827: LD_INT 0
51829: EQUAL
51830: IFFALSE 51870
// begin PlaceUnitArea ( unit , area , mode ) ;
51832: LD_VAR 0 1
51836: PPUSH
51837: LD_VAR 0 2
51841: PPUSH
51842: LD_VAR 0 3
51846: PPUSH
51847: CALL_OW 49
// result := IsPlaced ( unit ) ;
51851: LD_ADDR_VAR 0 4
51855: PUSH
51856: LD_VAR 0 1
51860: PPUSH
51861: CALL_OW 305
51865: ST_TO_ADDR
// exit ;
51866: POP
51867: POP
51868: GO 51874
// end ; end ;
51870: GO 51750
51872: POP
51873: POP
// end ;
51874: LD_VAR 0 4
51878: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
51879: LD_INT 0
51881: PPUSH
51882: PPUSH
51883: PPUSH
// if not side or side > 8 then
51884: LD_VAR 0 1
51888: NOT
51889: PUSH
51890: LD_VAR 0 1
51894: PUSH
51895: LD_INT 8
51897: GREATER
51898: OR
51899: IFFALSE 51903
// exit ;
51901: GO 52090
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
51903: LD_ADDR_VAR 0 4
51907: PUSH
51908: LD_INT 22
51910: PUSH
51911: LD_VAR 0 1
51915: PUSH
51916: EMPTY
51917: LIST
51918: LIST
51919: PUSH
51920: LD_INT 21
51922: PUSH
51923: LD_INT 3
51925: PUSH
51926: EMPTY
51927: LIST
51928: LIST
51929: PUSH
51930: EMPTY
51931: LIST
51932: LIST
51933: PPUSH
51934: CALL_OW 69
51938: ST_TO_ADDR
// if not tmp then
51939: LD_VAR 0 4
51943: NOT
51944: IFFALSE 51948
// exit ;
51946: GO 52090
// enable_addtolog := true ;
51948: LD_ADDR_OWVAR 81
51952: PUSH
51953: LD_INT 1
51955: ST_TO_ADDR
// AddToLog ( [ ) ;
51956: LD_STRING [
51958: PPUSH
51959: CALL_OW 561
// for i in tmp do
51963: LD_ADDR_VAR 0 3
51967: PUSH
51968: LD_VAR 0 4
51972: PUSH
51973: FOR_IN
51974: IFFALSE 52081
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
51976: LD_STRING [
51978: PUSH
51979: LD_VAR 0 3
51983: PPUSH
51984: CALL_OW 266
51988: STR
51989: PUSH
51990: LD_STRING , 
51992: STR
51993: PUSH
51994: LD_VAR 0 3
51998: PPUSH
51999: CALL_OW 250
52003: STR
52004: PUSH
52005: LD_STRING , 
52007: STR
52008: PUSH
52009: LD_VAR 0 3
52013: PPUSH
52014: CALL_OW 251
52018: STR
52019: PUSH
52020: LD_STRING , 
52022: STR
52023: PUSH
52024: LD_VAR 0 3
52028: PPUSH
52029: CALL_OW 254
52033: STR
52034: PUSH
52035: LD_STRING , 
52037: STR
52038: PUSH
52039: LD_VAR 0 3
52043: PPUSH
52044: LD_INT 1
52046: PPUSH
52047: CALL_OW 268
52051: STR
52052: PUSH
52053: LD_STRING , 
52055: STR
52056: PUSH
52057: LD_VAR 0 3
52061: PPUSH
52062: LD_INT 2
52064: PPUSH
52065: CALL_OW 268
52069: STR
52070: PUSH
52071: LD_STRING ],
52073: STR
52074: PPUSH
52075: CALL_OW 561
// end ;
52079: GO 51973
52081: POP
52082: POP
// AddToLog ( ]; ) ;
52083: LD_STRING ];
52085: PPUSH
52086: CALL_OW 561
// end ;
52090: LD_VAR 0 2
52094: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
52095: LD_INT 0
52097: PPUSH
52098: PPUSH
52099: PPUSH
52100: PPUSH
52101: PPUSH
// if not area or not rate or not max then
52102: LD_VAR 0 1
52106: NOT
52107: PUSH
52108: LD_VAR 0 2
52112: NOT
52113: OR
52114: PUSH
52115: LD_VAR 0 4
52119: NOT
52120: OR
52121: IFFALSE 52125
// exit ;
52123: GO 52314
// while 1 do
52125: LD_INT 1
52127: IFFALSE 52314
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
52129: LD_ADDR_VAR 0 9
52133: PUSH
52134: LD_VAR 0 1
52138: PPUSH
52139: LD_INT 1
52141: PPUSH
52142: CALL_OW 287
52146: PUSH
52147: LD_INT 10
52149: MUL
52150: ST_TO_ADDR
// r := rate / 10 ;
52151: LD_ADDR_VAR 0 7
52155: PUSH
52156: LD_VAR 0 2
52160: PUSH
52161: LD_INT 10
52163: DIVREAL
52164: ST_TO_ADDR
// time := 1 1$00 ;
52165: LD_ADDR_VAR 0 8
52169: PUSH
52170: LD_INT 2100
52172: ST_TO_ADDR
// if amount < min then
52173: LD_VAR 0 9
52177: PUSH
52178: LD_VAR 0 3
52182: LESS
52183: IFFALSE 52201
// r := r * 2 else
52185: LD_ADDR_VAR 0 7
52189: PUSH
52190: LD_VAR 0 7
52194: PUSH
52195: LD_INT 2
52197: MUL
52198: ST_TO_ADDR
52199: GO 52227
// if amount > max then
52201: LD_VAR 0 9
52205: PUSH
52206: LD_VAR 0 4
52210: GREATER
52211: IFFALSE 52227
// r := r / 2 ;
52213: LD_ADDR_VAR 0 7
52217: PUSH
52218: LD_VAR 0 7
52222: PUSH
52223: LD_INT 2
52225: DIVREAL
52226: ST_TO_ADDR
// time := time / r ;
52227: LD_ADDR_VAR 0 8
52231: PUSH
52232: LD_VAR 0 8
52236: PUSH
52237: LD_VAR 0 7
52241: DIVREAL
52242: ST_TO_ADDR
// if time < 0 then
52243: LD_VAR 0 8
52247: PUSH
52248: LD_INT 0
52250: LESS
52251: IFFALSE 52268
// time := time * - 1 ;
52253: LD_ADDR_VAR 0 8
52257: PUSH
52258: LD_VAR 0 8
52262: PUSH
52263: LD_INT 1
52265: NEG
52266: MUL
52267: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
52268: LD_VAR 0 8
52272: PUSH
52273: LD_INT 35
52275: PPUSH
52276: LD_INT 875
52278: PPUSH
52279: CALL_OW 12
52283: PLUS
52284: PPUSH
52285: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
52289: LD_INT 1
52291: PPUSH
52292: LD_INT 5
52294: PPUSH
52295: CALL_OW 12
52299: PPUSH
52300: LD_VAR 0 1
52304: PPUSH
52305: LD_INT 1
52307: PPUSH
52308: CALL_OW 55
// end ;
52312: GO 52125
// end ;
52314: LD_VAR 0 5
52318: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
52319: LD_INT 0
52321: PPUSH
52322: PPUSH
52323: PPUSH
52324: PPUSH
52325: PPUSH
52326: PPUSH
52327: PPUSH
52328: PPUSH
// if not turrets or not factories then
52329: LD_VAR 0 1
52333: NOT
52334: PUSH
52335: LD_VAR 0 2
52339: NOT
52340: OR
52341: IFFALSE 52345
// exit ;
52343: GO 52652
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
52345: LD_ADDR_VAR 0 10
52349: PUSH
52350: LD_INT 5
52352: PUSH
52353: LD_INT 6
52355: PUSH
52356: EMPTY
52357: LIST
52358: LIST
52359: PUSH
52360: LD_INT 2
52362: PUSH
52363: LD_INT 4
52365: PUSH
52366: EMPTY
52367: LIST
52368: LIST
52369: PUSH
52370: LD_INT 3
52372: PUSH
52373: LD_INT 5
52375: PUSH
52376: EMPTY
52377: LIST
52378: LIST
52379: PUSH
52380: EMPTY
52381: LIST
52382: LIST
52383: LIST
52384: PUSH
52385: LD_INT 24
52387: PUSH
52388: LD_INT 25
52390: PUSH
52391: EMPTY
52392: LIST
52393: LIST
52394: PUSH
52395: LD_INT 23
52397: PUSH
52398: LD_INT 27
52400: PUSH
52401: EMPTY
52402: LIST
52403: LIST
52404: PUSH
52405: EMPTY
52406: LIST
52407: LIST
52408: PUSH
52409: LD_INT 42
52411: PUSH
52412: LD_INT 43
52414: PUSH
52415: EMPTY
52416: LIST
52417: LIST
52418: PUSH
52419: LD_INT 44
52421: PUSH
52422: LD_INT 46
52424: PUSH
52425: EMPTY
52426: LIST
52427: LIST
52428: PUSH
52429: LD_INT 45
52431: PUSH
52432: LD_INT 47
52434: PUSH
52435: EMPTY
52436: LIST
52437: LIST
52438: PUSH
52439: EMPTY
52440: LIST
52441: LIST
52442: LIST
52443: PUSH
52444: EMPTY
52445: LIST
52446: LIST
52447: LIST
52448: ST_TO_ADDR
// result := [ ] ;
52449: LD_ADDR_VAR 0 3
52453: PUSH
52454: EMPTY
52455: ST_TO_ADDR
// for i in turrets do
52456: LD_ADDR_VAR 0 4
52460: PUSH
52461: LD_VAR 0 1
52465: PUSH
52466: FOR_IN
52467: IFFALSE 52650
// begin nat := GetNation ( i ) ;
52469: LD_ADDR_VAR 0 7
52473: PUSH
52474: LD_VAR 0 4
52478: PPUSH
52479: CALL_OW 248
52483: ST_TO_ADDR
// weapon := 0 ;
52484: LD_ADDR_VAR 0 8
52488: PUSH
52489: LD_INT 0
52491: ST_TO_ADDR
// if not nat then
52492: LD_VAR 0 7
52496: NOT
52497: IFFALSE 52501
// continue ;
52499: GO 52466
// for j in list [ nat ] do
52501: LD_ADDR_VAR 0 5
52505: PUSH
52506: LD_VAR 0 10
52510: PUSH
52511: LD_VAR 0 7
52515: ARRAY
52516: PUSH
52517: FOR_IN
52518: IFFALSE 52559
// if GetBWeapon ( i ) = j [ 1 ] then
52520: LD_VAR 0 4
52524: PPUSH
52525: CALL_OW 269
52529: PUSH
52530: LD_VAR 0 5
52534: PUSH
52535: LD_INT 1
52537: ARRAY
52538: EQUAL
52539: IFFALSE 52557
// begin weapon := j [ 2 ] ;
52541: LD_ADDR_VAR 0 8
52545: PUSH
52546: LD_VAR 0 5
52550: PUSH
52551: LD_INT 2
52553: ARRAY
52554: ST_TO_ADDR
// break ;
52555: GO 52559
// end ;
52557: GO 52517
52559: POP
52560: POP
// if not weapon then
52561: LD_VAR 0 8
52565: NOT
52566: IFFALSE 52570
// continue ;
52568: GO 52466
// for k in factories do
52570: LD_ADDR_VAR 0 6
52574: PUSH
52575: LD_VAR 0 2
52579: PUSH
52580: FOR_IN
52581: IFFALSE 52646
// begin weapons := AvailableWeaponList ( k ) ;
52583: LD_ADDR_VAR 0 9
52587: PUSH
52588: LD_VAR 0 6
52592: PPUSH
52593: CALL_OW 478
52597: ST_TO_ADDR
// if not weapons then
52598: LD_VAR 0 9
52602: NOT
52603: IFFALSE 52607
// continue ;
52605: GO 52580
// if weapon in weapons then
52607: LD_VAR 0 8
52611: PUSH
52612: LD_VAR 0 9
52616: IN
52617: IFFALSE 52644
// begin result := [ i , weapon ] ;
52619: LD_ADDR_VAR 0 3
52623: PUSH
52624: LD_VAR 0 4
52628: PUSH
52629: LD_VAR 0 8
52633: PUSH
52634: EMPTY
52635: LIST
52636: LIST
52637: ST_TO_ADDR
// exit ;
52638: POP
52639: POP
52640: POP
52641: POP
52642: GO 52652
// end ; end ;
52644: GO 52580
52646: POP
52647: POP
// end ;
52648: GO 52466
52650: POP
52651: POP
// end ;
52652: LD_VAR 0 3
52656: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
52657: LD_INT 0
52659: PPUSH
// if not side or side > 8 then
52660: LD_VAR 0 3
52664: NOT
52665: PUSH
52666: LD_VAR 0 3
52670: PUSH
52671: LD_INT 8
52673: GREATER
52674: OR
52675: IFFALSE 52679
// exit ;
52677: GO 52738
// if not range then
52679: LD_VAR 0 4
52683: NOT
52684: IFFALSE 52695
// range := - 12 ;
52686: LD_ADDR_VAR 0 4
52690: PUSH
52691: LD_INT 12
52693: NEG
52694: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
52695: LD_VAR 0 1
52699: PPUSH
52700: LD_VAR 0 2
52704: PPUSH
52705: LD_VAR 0 3
52709: PPUSH
52710: LD_VAR 0 4
52714: PPUSH
52715: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
52719: LD_VAR 0 1
52723: PPUSH
52724: LD_VAR 0 2
52728: PPUSH
52729: LD_VAR 0 3
52733: PPUSH
52734: CALL_OW 331
// end ;
52738: LD_VAR 0 5
52742: RET
// export function Video ( mode ) ; begin
52743: LD_INT 0
52745: PPUSH
// ingame_video = mode ;
52746: LD_ADDR_OWVAR 52
52750: PUSH
52751: LD_VAR 0 1
52755: ST_TO_ADDR
// interface_hidden = mode ;
52756: LD_ADDR_OWVAR 54
52760: PUSH
52761: LD_VAR 0 1
52765: ST_TO_ADDR
// end ;
52766: LD_VAR 0 2
52770: RET
// export function Join ( array , element ) ; begin
52771: LD_INT 0
52773: PPUSH
// result := Replace ( array , array + 1 , element ) ;
52774: LD_ADDR_VAR 0 3
52778: PUSH
52779: LD_VAR 0 1
52783: PPUSH
52784: LD_VAR 0 1
52788: PUSH
52789: LD_INT 1
52791: PLUS
52792: PPUSH
52793: LD_VAR 0 2
52797: PPUSH
52798: CALL_OW 1
52802: ST_TO_ADDR
// end ;
52803: LD_VAR 0 3
52807: RET
// export function JoinUnion ( array , element ) ; begin
52808: LD_INT 0
52810: PPUSH
// result := array union element ;
52811: LD_ADDR_VAR 0 3
52815: PUSH
52816: LD_VAR 0 1
52820: PUSH
52821: LD_VAR 0 2
52825: UNION
52826: ST_TO_ADDR
// end ;
52827: LD_VAR 0 3
52831: RET
// export function GetBehemoths ( side ) ; begin
52832: LD_INT 0
52834: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
52835: LD_ADDR_VAR 0 2
52839: PUSH
52840: LD_INT 22
52842: PUSH
52843: LD_VAR 0 1
52847: PUSH
52848: EMPTY
52849: LIST
52850: LIST
52851: PUSH
52852: LD_INT 31
52854: PUSH
52855: LD_INT 25
52857: PUSH
52858: EMPTY
52859: LIST
52860: LIST
52861: PUSH
52862: EMPTY
52863: LIST
52864: LIST
52865: PPUSH
52866: CALL_OW 69
52870: ST_TO_ADDR
// end ;
52871: LD_VAR 0 2
52875: RET
// export function Shuffle ( array ) ; var i , index ; begin
52876: LD_INT 0
52878: PPUSH
52879: PPUSH
52880: PPUSH
// result := [ ] ;
52881: LD_ADDR_VAR 0 2
52885: PUSH
52886: EMPTY
52887: ST_TO_ADDR
// if not array then
52888: LD_VAR 0 1
52892: NOT
52893: IFFALSE 52897
// exit ;
52895: GO 52996
// Randomize ;
52897: CALL_OW 10
// for i = array downto 1 do
52901: LD_ADDR_VAR 0 3
52905: PUSH
52906: DOUBLE
52907: LD_VAR 0 1
52911: INC
52912: ST_TO_ADDR
52913: LD_INT 1
52915: PUSH
52916: FOR_DOWNTO
52917: IFFALSE 52994
// begin index := rand ( 1 , array ) ;
52919: LD_ADDR_VAR 0 4
52923: PUSH
52924: LD_INT 1
52926: PPUSH
52927: LD_VAR 0 1
52931: PPUSH
52932: CALL_OW 12
52936: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
52937: LD_ADDR_VAR 0 2
52941: PUSH
52942: LD_VAR 0 2
52946: PPUSH
52947: LD_VAR 0 2
52951: PUSH
52952: LD_INT 1
52954: PLUS
52955: PPUSH
52956: LD_VAR 0 1
52960: PUSH
52961: LD_VAR 0 4
52965: ARRAY
52966: PPUSH
52967: CALL_OW 2
52971: ST_TO_ADDR
// array := Delete ( array , index ) ;
52972: LD_ADDR_VAR 0 1
52976: PUSH
52977: LD_VAR 0 1
52981: PPUSH
52982: LD_VAR 0 4
52986: PPUSH
52987: CALL_OW 3
52991: ST_TO_ADDR
// end ;
52992: GO 52916
52994: POP
52995: POP
// end ;
52996: LD_VAR 0 2
53000: RET
// export function GetBaseMaterials ( base ) ; begin
53001: LD_INT 0
53003: PPUSH
// result := [ 0 , 0 , 0 ] ;
53004: LD_ADDR_VAR 0 2
53008: PUSH
53009: LD_INT 0
53011: PUSH
53012: LD_INT 0
53014: PUSH
53015: LD_INT 0
53017: PUSH
53018: EMPTY
53019: LIST
53020: LIST
53021: LIST
53022: ST_TO_ADDR
// if not base then
53023: LD_VAR 0 1
53027: NOT
53028: IFFALSE 53032
// exit ;
53030: GO 53081
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
53032: LD_ADDR_VAR 0 2
53036: PUSH
53037: LD_VAR 0 1
53041: PPUSH
53042: LD_INT 1
53044: PPUSH
53045: CALL_OW 275
53049: PUSH
53050: LD_VAR 0 1
53054: PPUSH
53055: LD_INT 2
53057: PPUSH
53058: CALL_OW 275
53062: PUSH
53063: LD_VAR 0 1
53067: PPUSH
53068: LD_INT 3
53070: PPUSH
53071: CALL_OW 275
53075: PUSH
53076: EMPTY
53077: LIST
53078: LIST
53079: LIST
53080: ST_TO_ADDR
// end ;
53081: LD_VAR 0 2
53085: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
53086: LD_INT 0
53088: PPUSH
53089: PPUSH
// result := array ;
53090: LD_ADDR_VAR 0 3
53094: PUSH
53095: LD_VAR 0 1
53099: ST_TO_ADDR
// if size >= result then
53100: LD_VAR 0 2
53104: PUSH
53105: LD_VAR 0 3
53109: GREATEREQUAL
53110: IFFALSE 53114
// exit ;
53112: GO 53164
// if size then
53114: LD_VAR 0 2
53118: IFFALSE 53164
// for i := array downto size do
53120: LD_ADDR_VAR 0 4
53124: PUSH
53125: DOUBLE
53126: LD_VAR 0 1
53130: INC
53131: ST_TO_ADDR
53132: LD_VAR 0 2
53136: PUSH
53137: FOR_DOWNTO
53138: IFFALSE 53162
// result := Delete ( result , result ) ;
53140: LD_ADDR_VAR 0 3
53144: PUSH
53145: LD_VAR 0 3
53149: PPUSH
53150: LD_VAR 0 3
53154: PPUSH
53155: CALL_OW 3
53159: ST_TO_ADDR
53160: GO 53137
53162: POP
53163: POP
// end ;
53164: LD_VAR 0 3
53168: RET
// export function ComExit ( unit ) ; var tmp ; begin
53169: LD_INT 0
53171: PPUSH
53172: PPUSH
// if not IsInUnit ( unit ) then
53173: LD_VAR 0 1
53177: PPUSH
53178: CALL_OW 310
53182: NOT
53183: IFFALSE 53187
// exit ;
53185: GO 53247
// tmp := IsInUnit ( unit ) ;
53187: LD_ADDR_VAR 0 3
53191: PUSH
53192: LD_VAR 0 1
53196: PPUSH
53197: CALL_OW 310
53201: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
53202: LD_VAR 0 3
53206: PPUSH
53207: CALL_OW 247
53211: PUSH
53212: LD_INT 2
53214: EQUAL
53215: IFFALSE 53228
// ComExitVehicle ( unit ) else
53217: LD_VAR 0 1
53221: PPUSH
53222: CALL_OW 121
53226: GO 53237
// ComExitBuilding ( unit ) ;
53228: LD_VAR 0 1
53232: PPUSH
53233: CALL_OW 122
// result := tmp ;
53237: LD_ADDR_VAR 0 2
53241: PUSH
53242: LD_VAR 0 3
53246: ST_TO_ADDR
// end ;
53247: LD_VAR 0 2
53251: RET
// export function ComExitAll ( units ) ; var i ; begin
53252: LD_INT 0
53254: PPUSH
53255: PPUSH
// if not units then
53256: LD_VAR 0 1
53260: NOT
53261: IFFALSE 53265
// exit ;
53263: GO 53291
// for i in units do
53265: LD_ADDR_VAR 0 3
53269: PUSH
53270: LD_VAR 0 1
53274: PUSH
53275: FOR_IN
53276: IFFALSE 53289
// ComExit ( i ) ;
53278: LD_VAR 0 3
53282: PPUSH
53283: CALL 53169 0 1
53287: GO 53275
53289: POP
53290: POP
// end ;
53291: LD_VAR 0 2
53295: RET
// export function ResetHc ; begin
53296: LD_INT 0
53298: PPUSH
// InitHc ;
53299: CALL_OW 19
// hc_importance := 0 ;
53303: LD_ADDR_OWVAR 32
53307: PUSH
53308: LD_INT 0
53310: ST_TO_ADDR
// end ;
53311: LD_VAR 0 1
53315: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
53316: LD_INT 0
53318: PPUSH
53319: PPUSH
53320: PPUSH
// _x := ( x1 + x2 ) div 2 ;
53321: LD_ADDR_VAR 0 6
53325: PUSH
53326: LD_VAR 0 1
53330: PUSH
53331: LD_VAR 0 3
53335: PLUS
53336: PUSH
53337: LD_INT 2
53339: DIV
53340: ST_TO_ADDR
// if _x < 0 then
53341: LD_VAR 0 6
53345: PUSH
53346: LD_INT 0
53348: LESS
53349: IFFALSE 53366
// _x := _x * - 1 ;
53351: LD_ADDR_VAR 0 6
53355: PUSH
53356: LD_VAR 0 6
53360: PUSH
53361: LD_INT 1
53363: NEG
53364: MUL
53365: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
53366: LD_ADDR_VAR 0 7
53370: PUSH
53371: LD_VAR 0 2
53375: PUSH
53376: LD_VAR 0 4
53380: PLUS
53381: PUSH
53382: LD_INT 2
53384: DIV
53385: ST_TO_ADDR
// if _y < 0 then
53386: LD_VAR 0 7
53390: PUSH
53391: LD_INT 0
53393: LESS
53394: IFFALSE 53411
// _y := _y * - 1 ;
53396: LD_ADDR_VAR 0 7
53400: PUSH
53401: LD_VAR 0 7
53405: PUSH
53406: LD_INT 1
53408: NEG
53409: MUL
53410: ST_TO_ADDR
// result := [ _x , _y ] ;
53411: LD_ADDR_VAR 0 5
53415: PUSH
53416: LD_VAR 0 6
53420: PUSH
53421: LD_VAR 0 7
53425: PUSH
53426: EMPTY
53427: LIST
53428: LIST
53429: ST_TO_ADDR
// end ;
53430: LD_VAR 0 5
53434: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
53435: LD_INT 0
53437: PPUSH
53438: PPUSH
53439: PPUSH
53440: PPUSH
// task := GetTaskList ( unit ) ;
53441: LD_ADDR_VAR 0 7
53445: PUSH
53446: LD_VAR 0 1
53450: PPUSH
53451: CALL_OW 437
53455: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
53456: LD_VAR 0 7
53460: NOT
53461: PUSH
53462: LD_VAR 0 1
53466: PPUSH
53467: LD_VAR 0 2
53471: PPUSH
53472: CALL_OW 308
53476: NOT
53477: AND
53478: IFFALSE 53482
// exit ;
53480: GO 53600
// if IsInArea ( unit , area ) then
53482: LD_VAR 0 1
53486: PPUSH
53487: LD_VAR 0 2
53491: PPUSH
53492: CALL_OW 308
53496: IFFALSE 53514
// begin ComMoveToArea ( unit , goAway ) ;
53498: LD_VAR 0 1
53502: PPUSH
53503: LD_VAR 0 3
53507: PPUSH
53508: CALL_OW 113
// exit ;
53512: GO 53600
// end ; if task [ 1 ] [ 1 ] <> M then
53514: LD_VAR 0 7
53518: PUSH
53519: LD_INT 1
53521: ARRAY
53522: PUSH
53523: LD_INT 1
53525: ARRAY
53526: PUSH
53527: LD_STRING M
53529: NONEQUAL
53530: IFFALSE 53534
// exit ;
53532: GO 53600
// x := task [ 1 ] [ 2 ] ;
53534: LD_ADDR_VAR 0 5
53538: PUSH
53539: LD_VAR 0 7
53543: PUSH
53544: LD_INT 1
53546: ARRAY
53547: PUSH
53548: LD_INT 2
53550: ARRAY
53551: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
53552: LD_ADDR_VAR 0 6
53556: PUSH
53557: LD_VAR 0 7
53561: PUSH
53562: LD_INT 1
53564: ARRAY
53565: PUSH
53566: LD_INT 3
53568: ARRAY
53569: ST_TO_ADDR
// if InArea ( x , y , area ) then
53570: LD_VAR 0 5
53574: PPUSH
53575: LD_VAR 0 6
53579: PPUSH
53580: LD_VAR 0 2
53584: PPUSH
53585: CALL_OW 309
53589: IFFALSE 53600
// ComStop ( unit ) ;
53591: LD_VAR 0 1
53595: PPUSH
53596: CALL_OW 141
// end ;
53600: LD_VAR 0 4
53604: RET
// export function Abs ( value ) ; begin
53605: LD_INT 0
53607: PPUSH
// result := value ;
53608: LD_ADDR_VAR 0 2
53612: PUSH
53613: LD_VAR 0 1
53617: ST_TO_ADDR
// if value < 0 then
53618: LD_VAR 0 1
53622: PUSH
53623: LD_INT 0
53625: LESS
53626: IFFALSE 53643
// result := value * - 1 ;
53628: LD_ADDR_VAR 0 2
53632: PUSH
53633: LD_VAR 0 1
53637: PUSH
53638: LD_INT 1
53640: NEG
53641: MUL
53642: ST_TO_ADDR
// end ;
53643: LD_VAR 0 2
53647: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
53648: LD_INT 0
53650: PPUSH
53651: PPUSH
53652: PPUSH
53653: PPUSH
53654: PPUSH
53655: PPUSH
53656: PPUSH
53657: PPUSH
// if not unit or not building then
53658: LD_VAR 0 1
53662: NOT
53663: PUSH
53664: LD_VAR 0 2
53668: NOT
53669: OR
53670: IFFALSE 53674
// exit ;
53672: GO 53900
// x := GetX ( building ) ;
53674: LD_ADDR_VAR 0 4
53678: PUSH
53679: LD_VAR 0 2
53683: PPUSH
53684: CALL_OW 250
53688: ST_TO_ADDR
// y := GetY ( building ) ;
53689: LD_ADDR_VAR 0 6
53693: PUSH
53694: LD_VAR 0 2
53698: PPUSH
53699: CALL_OW 251
53703: ST_TO_ADDR
// d := GetDir ( building ) ;
53704: LD_ADDR_VAR 0 8
53708: PUSH
53709: LD_VAR 0 2
53713: PPUSH
53714: CALL_OW 254
53718: ST_TO_ADDR
// r := 4 ;
53719: LD_ADDR_VAR 0 9
53723: PUSH
53724: LD_INT 4
53726: ST_TO_ADDR
// for i := 1 to 5 do
53727: LD_ADDR_VAR 0 10
53731: PUSH
53732: DOUBLE
53733: LD_INT 1
53735: DEC
53736: ST_TO_ADDR
53737: LD_INT 5
53739: PUSH
53740: FOR_TO
53741: IFFALSE 53898
// begin _x := ShiftX ( x , d , r + i ) ;
53743: LD_ADDR_VAR 0 5
53747: PUSH
53748: LD_VAR 0 4
53752: PPUSH
53753: LD_VAR 0 8
53757: PPUSH
53758: LD_VAR 0 9
53762: PUSH
53763: LD_VAR 0 10
53767: PLUS
53768: PPUSH
53769: CALL_OW 272
53773: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
53774: LD_ADDR_VAR 0 7
53778: PUSH
53779: LD_VAR 0 6
53783: PPUSH
53784: LD_VAR 0 8
53788: PPUSH
53789: LD_VAR 0 9
53793: PUSH
53794: LD_VAR 0 10
53798: PLUS
53799: PPUSH
53800: CALL_OW 273
53804: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
53805: LD_VAR 0 5
53809: PPUSH
53810: LD_VAR 0 7
53814: PPUSH
53815: CALL_OW 488
53819: PUSH
53820: LD_VAR 0 5
53824: PPUSH
53825: LD_VAR 0 7
53829: PPUSH
53830: CALL_OW 428
53834: PPUSH
53835: CALL_OW 247
53839: PUSH
53840: LD_INT 3
53842: PUSH
53843: LD_INT 2
53845: PUSH
53846: EMPTY
53847: LIST
53848: LIST
53849: IN
53850: NOT
53851: AND
53852: IFFALSE 53896
// begin ComMoveXY ( unit , _x , _y ) ;
53854: LD_VAR 0 1
53858: PPUSH
53859: LD_VAR 0 5
53863: PPUSH
53864: LD_VAR 0 7
53868: PPUSH
53869: CALL_OW 111
// result := [ _x , _y ] ;
53873: LD_ADDR_VAR 0 3
53877: PUSH
53878: LD_VAR 0 5
53882: PUSH
53883: LD_VAR 0 7
53887: PUSH
53888: EMPTY
53889: LIST
53890: LIST
53891: ST_TO_ADDR
// exit ;
53892: POP
53893: POP
53894: GO 53900
// end ; end ;
53896: GO 53740
53898: POP
53899: POP
// end ;
53900: LD_VAR 0 3
53904: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
53905: LD_INT 0
53907: PPUSH
53908: PPUSH
53909: PPUSH
// result := 0 ;
53910: LD_ADDR_VAR 0 3
53914: PUSH
53915: LD_INT 0
53917: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
53918: LD_VAR 0 1
53922: PUSH
53923: LD_INT 0
53925: LESS
53926: PUSH
53927: LD_VAR 0 1
53931: PUSH
53932: LD_INT 8
53934: GREATER
53935: OR
53936: PUSH
53937: LD_VAR 0 2
53941: PUSH
53942: LD_INT 0
53944: LESS
53945: OR
53946: PUSH
53947: LD_VAR 0 2
53951: PUSH
53952: LD_INT 8
53954: GREATER
53955: OR
53956: IFFALSE 53960
// exit ;
53958: GO 54035
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
53960: LD_ADDR_VAR 0 4
53964: PUSH
53965: LD_INT 22
53967: PUSH
53968: LD_VAR 0 2
53972: PUSH
53973: EMPTY
53974: LIST
53975: LIST
53976: PPUSH
53977: CALL_OW 69
53981: PUSH
53982: FOR_IN
53983: IFFALSE 54033
// begin un := UnitShoot ( i ) ;
53985: LD_ADDR_VAR 0 5
53989: PUSH
53990: LD_VAR 0 4
53994: PPUSH
53995: CALL_OW 504
53999: ST_TO_ADDR
// if GetSide ( un ) = side1 then
54000: LD_VAR 0 5
54004: PPUSH
54005: CALL_OW 255
54009: PUSH
54010: LD_VAR 0 1
54014: EQUAL
54015: IFFALSE 54031
// begin result := un ;
54017: LD_ADDR_VAR 0 3
54021: PUSH
54022: LD_VAR 0 5
54026: ST_TO_ADDR
// exit ;
54027: POP
54028: POP
54029: GO 54035
// end ; end ;
54031: GO 53982
54033: POP
54034: POP
// end ;
54035: LD_VAR 0 3
54039: RET
// export function GetCargoBay ( units ) ; begin
54040: LD_INT 0
54042: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
54043: LD_ADDR_VAR 0 2
54047: PUSH
54048: LD_VAR 0 1
54052: PPUSH
54053: LD_INT 2
54055: PUSH
54056: LD_INT 34
54058: PUSH
54059: LD_INT 12
54061: PUSH
54062: EMPTY
54063: LIST
54064: LIST
54065: PUSH
54066: LD_INT 34
54068: PUSH
54069: LD_INT 51
54071: PUSH
54072: EMPTY
54073: LIST
54074: LIST
54075: PUSH
54076: LD_INT 34
54078: PUSH
54079: LD_INT 32
54081: PUSH
54082: EMPTY
54083: LIST
54084: LIST
54085: PUSH
54086: LD_INT 34
54088: PUSH
54089: LD_INT 89
54091: PUSH
54092: EMPTY
54093: LIST
54094: LIST
54095: PUSH
54096: EMPTY
54097: LIST
54098: LIST
54099: LIST
54100: LIST
54101: LIST
54102: PPUSH
54103: CALL_OW 72
54107: ST_TO_ADDR
// end ;
54108: LD_VAR 0 2
54112: RET
// export function Negate ( value ) ; begin
54113: LD_INT 0
54115: PPUSH
// result := not value ;
54116: LD_ADDR_VAR 0 2
54120: PUSH
54121: LD_VAR 0 1
54125: NOT
54126: ST_TO_ADDR
// end ;
54127: LD_VAR 0 2
54131: RET
// export function Inc ( value ) ; begin
54132: LD_INT 0
54134: PPUSH
// result := value + 1 ;
54135: LD_ADDR_VAR 0 2
54139: PUSH
54140: LD_VAR 0 1
54144: PUSH
54145: LD_INT 1
54147: PLUS
54148: ST_TO_ADDR
// end ;
54149: LD_VAR 0 2
54153: RET
// export function Dec ( value ) ; begin
54154: LD_INT 0
54156: PPUSH
// result := value - 1 ;
54157: LD_ADDR_VAR 0 2
54161: PUSH
54162: LD_VAR 0 1
54166: PUSH
54167: LD_INT 1
54169: MINUS
54170: ST_TO_ADDR
// end ;
54171: LD_VAR 0 2
54175: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
54176: LD_INT 0
54178: PPUSH
54179: PPUSH
54180: PPUSH
54181: PPUSH
54182: PPUSH
54183: PPUSH
54184: PPUSH
54185: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
54186: LD_VAR 0 1
54190: PPUSH
54191: LD_VAR 0 2
54195: PPUSH
54196: CALL_OW 488
54200: NOT
54201: PUSH
54202: LD_VAR 0 3
54206: PPUSH
54207: LD_VAR 0 4
54211: PPUSH
54212: CALL_OW 488
54216: NOT
54217: OR
54218: IFFALSE 54231
// begin result := - 1 ;
54220: LD_ADDR_VAR 0 5
54224: PUSH
54225: LD_INT 1
54227: NEG
54228: ST_TO_ADDR
// exit ;
54229: GO 54466
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
54231: LD_ADDR_VAR 0 12
54235: PUSH
54236: LD_VAR 0 1
54240: PPUSH
54241: LD_VAR 0 2
54245: PPUSH
54246: LD_VAR 0 3
54250: PPUSH
54251: LD_VAR 0 4
54255: PPUSH
54256: CALL 53316 0 4
54260: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
54261: LD_ADDR_VAR 0 11
54265: PUSH
54266: LD_VAR 0 1
54270: PPUSH
54271: LD_VAR 0 2
54275: PPUSH
54276: LD_VAR 0 12
54280: PUSH
54281: LD_INT 1
54283: ARRAY
54284: PPUSH
54285: LD_VAR 0 12
54289: PUSH
54290: LD_INT 2
54292: ARRAY
54293: PPUSH
54294: CALL_OW 298
54298: ST_TO_ADDR
// distance := 9999 ;
54299: LD_ADDR_VAR 0 10
54303: PUSH
54304: LD_INT 9999
54306: ST_TO_ADDR
// for i := 0 to 5 do
54307: LD_ADDR_VAR 0 6
54311: PUSH
54312: DOUBLE
54313: LD_INT 0
54315: DEC
54316: ST_TO_ADDR
54317: LD_INT 5
54319: PUSH
54320: FOR_TO
54321: IFFALSE 54464
// begin _x := ShiftX ( x1 , i , centerDist ) ;
54323: LD_ADDR_VAR 0 7
54327: PUSH
54328: LD_VAR 0 1
54332: PPUSH
54333: LD_VAR 0 6
54337: PPUSH
54338: LD_VAR 0 11
54342: PPUSH
54343: CALL_OW 272
54347: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
54348: LD_ADDR_VAR 0 8
54352: PUSH
54353: LD_VAR 0 2
54357: PPUSH
54358: LD_VAR 0 6
54362: PPUSH
54363: LD_VAR 0 11
54367: PPUSH
54368: CALL_OW 273
54372: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54373: LD_VAR 0 7
54377: PPUSH
54378: LD_VAR 0 8
54382: PPUSH
54383: CALL_OW 488
54387: NOT
54388: IFFALSE 54392
// continue ;
54390: GO 54320
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
54392: LD_ADDR_VAR 0 9
54396: PUSH
54397: LD_VAR 0 12
54401: PUSH
54402: LD_INT 1
54404: ARRAY
54405: PPUSH
54406: LD_VAR 0 12
54410: PUSH
54411: LD_INT 2
54413: ARRAY
54414: PPUSH
54415: LD_VAR 0 7
54419: PPUSH
54420: LD_VAR 0 8
54424: PPUSH
54425: CALL_OW 298
54429: ST_TO_ADDR
// if tmp < distance then
54430: LD_VAR 0 9
54434: PUSH
54435: LD_VAR 0 10
54439: LESS
54440: IFFALSE 54462
// begin result := i ;
54442: LD_ADDR_VAR 0 5
54446: PUSH
54447: LD_VAR 0 6
54451: ST_TO_ADDR
// distance := tmp ;
54452: LD_ADDR_VAR 0 10
54456: PUSH
54457: LD_VAR 0 9
54461: ST_TO_ADDR
// end ; end ;
54462: GO 54320
54464: POP
54465: POP
// end ;
54466: LD_VAR 0 5
54470: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
54471: LD_INT 0
54473: PPUSH
54474: PPUSH
// if not driver or not IsInUnit ( driver ) then
54475: LD_VAR 0 1
54479: NOT
54480: PUSH
54481: LD_VAR 0 1
54485: PPUSH
54486: CALL_OW 310
54490: NOT
54491: OR
54492: IFFALSE 54496
// exit ;
54494: GO 54586
// vehicle := IsInUnit ( driver ) ;
54496: LD_ADDR_VAR 0 3
54500: PUSH
54501: LD_VAR 0 1
54505: PPUSH
54506: CALL_OW 310
54510: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
54511: LD_VAR 0 1
54515: PPUSH
54516: LD_STRING \
54518: PUSH
54519: LD_INT 0
54521: PUSH
54522: LD_INT 0
54524: PUSH
54525: LD_INT 0
54527: PUSH
54528: LD_INT 0
54530: PUSH
54531: LD_INT 0
54533: PUSH
54534: LD_INT 0
54536: PUSH
54537: EMPTY
54538: LIST
54539: LIST
54540: LIST
54541: LIST
54542: LIST
54543: LIST
54544: LIST
54545: PUSH
54546: LD_STRING E
54548: PUSH
54549: LD_INT 0
54551: PUSH
54552: LD_INT 0
54554: PUSH
54555: LD_VAR 0 3
54559: PUSH
54560: LD_INT 0
54562: PUSH
54563: LD_INT 0
54565: PUSH
54566: LD_INT 0
54568: PUSH
54569: EMPTY
54570: LIST
54571: LIST
54572: LIST
54573: LIST
54574: LIST
54575: LIST
54576: LIST
54577: PUSH
54578: EMPTY
54579: LIST
54580: LIST
54581: PPUSH
54582: CALL_OW 446
// end ;
54586: LD_VAR 0 2
54590: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
54591: LD_INT 0
54593: PPUSH
54594: PPUSH
// if not driver or not IsInUnit ( driver ) then
54595: LD_VAR 0 1
54599: NOT
54600: PUSH
54601: LD_VAR 0 1
54605: PPUSH
54606: CALL_OW 310
54610: NOT
54611: OR
54612: IFFALSE 54616
// exit ;
54614: GO 54706
// vehicle := IsInUnit ( driver ) ;
54616: LD_ADDR_VAR 0 3
54620: PUSH
54621: LD_VAR 0 1
54625: PPUSH
54626: CALL_OW 310
54630: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
54631: LD_VAR 0 1
54635: PPUSH
54636: LD_STRING \
54638: PUSH
54639: LD_INT 0
54641: PUSH
54642: LD_INT 0
54644: PUSH
54645: LD_INT 0
54647: PUSH
54648: LD_INT 0
54650: PUSH
54651: LD_INT 0
54653: PUSH
54654: LD_INT 0
54656: PUSH
54657: EMPTY
54658: LIST
54659: LIST
54660: LIST
54661: LIST
54662: LIST
54663: LIST
54664: LIST
54665: PUSH
54666: LD_STRING E
54668: PUSH
54669: LD_INT 0
54671: PUSH
54672: LD_INT 0
54674: PUSH
54675: LD_VAR 0 3
54679: PUSH
54680: LD_INT 0
54682: PUSH
54683: LD_INT 0
54685: PUSH
54686: LD_INT 0
54688: PUSH
54689: EMPTY
54690: LIST
54691: LIST
54692: LIST
54693: LIST
54694: LIST
54695: LIST
54696: LIST
54697: PUSH
54698: EMPTY
54699: LIST
54700: LIST
54701: PPUSH
54702: CALL_OW 447
// end ;
54706: LD_VAR 0 2
54710: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
54711: LD_INT 0
54713: PPUSH
54714: PPUSH
54715: PPUSH
// tmp := [ ] ;
54716: LD_ADDR_VAR 0 5
54720: PUSH
54721: EMPTY
54722: ST_TO_ADDR
// for i in units do
54723: LD_ADDR_VAR 0 4
54727: PUSH
54728: LD_VAR 0 1
54732: PUSH
54733: FOR_IN
54734: IFFALSE 54772
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
54736: LD_ADDR_VAR 0 5
54740: PUSH
54741: LD_VAR 0 5
54745: PPUSH
54746: LD_VAR 0 5
54750: PUSH
54751: LD_INT 1
54753: PLUS
54754: PPUSH
54755: LD_VAR 0 4
54759: PPUSH
54760: CALL_OW 256
54764: PPUSH
54765: CALL_OW 2
54769: ST_TO_ADDR
54770: GO 54733
54772: POP
54773: POP
// if not tmp then
54774: LD_VAR 0 5
54778: NOT
54779: IFFALSE 54783
// exit ;
54781: GO 54831
// if asc then
54783: LD_VAR 0 2
54787: IFFALSE 54811
// result := SortListByListAsc ( units , tmp ) else
54789: LD_ADDR_VAR 0 3
54793: PUSH
54794: LD_VAR 0 1
54798: PPUSH
54799: LD_VAR 0 5
54803: PPUSH
54804: CALL_OW 76
54808: ST_TO_ADDR
54809: GO 54831
// result := SortListByListDesc ( units , tmp ) ;
54811: LD_ADDR_VAR 0 3
54815: PUSH
54816: LD_VAR 0 1
54820: PPUSH
54821: LD_VAR 0 5
54825: PPUSH
54826: CALL_OW 77
54830: ST_TO_ADDR
// end ;
54831: LD_VAR 0 3
54835: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
54836: LD_INT 0
54838: PPUSH
54839: PPUSH
// task := GetTaskList ( mech ) ;
54840: LD_ADDR_VAR 0 4
54844: PUSH
54845: LD_VAR 0 1
54849: PPUSH
54850: CALL_OW 437
54854: ST_TO_ADDR
// if not task then
54855: LD_VAR 0 4
54859: NOT
54860: IFFALSE 54864
// exit ;
54862: GO 54906
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
54864: LD_ADDR_VAR 0 3
54868: PUSH
54869: LD_VAR 0 4
54873: PUSH
54874: LD_INT 1
54876: ARRAY
54877: PUSH
54878: LD_INT 1
54880: ARRAY
54881: PUSH
54882: LD_STRING r
54884: EQUAL
54885: PUSH
54886: LD_VAR 0 4
54890: PUSH
54891: LD_INT 1
54893: ARRAY
54894: PUSH
54895: LD_INT 4
54897: ARRAY
54898: PUSH
54899: LD_VAR 0 2
54903: EQUAL
54904: AND
54905: ST_TO_ADDR
// end ;
54906: LD_VAR 0 3
54910: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
54911: LD_INT 0
54913: PPUSH
// SetDir ( unit , d ) ;
54914: LD_VAR 0 1
54918: PPUSH
54919: LD_VAR 0 4
54923: PPUSH
54924: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
54928: LD_VAR 0 1
54932: PPUSH
54933: LD_VAR 0 2
54937: PPUSH
54938: LD_VAR 0 3
54942: PPUSH
54943: LD_VAR 0 5
54947: PPUSH
54948: CALL_OW 48
// end ;
54952: LD_VAR 0 6
54956: RET
// export function ToNaturalNumber ( number ) ; begin
54957: LD_INT 0
54959: PPUSH
// result := number div 1 ;
54960: LD_ADDR_VAR 0 2
54964: PUSH
54965: LD_VAR 0 1
54969: PUSH
54970: LD_INT 1
54972: DIV
54973: ST_TO_ADDR
// if number < 0 then
54974: LD_VAR 0 1
54978: PUSH
54979: LD_INT 0
54981: LESS
54982: IFFALSE 54992
// result := 0 ;
54984: LD_ADDR_VAR 0 2
54988: PUSH
54989: LD_INT 0
54991: ST_TO_ADDR
// end ;
54992: LD_VAR 0 2
54996: RET
// export function SortByClass ( units , class ) ; var un ; begin
54997: LD_INT 0
54999: PPUSH
55000: PPUSH
// if not units or not class then
55001: LD_VAR 0 1
55005: NOT
55006: PUSH
55007: LD_VAR 0 2
55011: NOT
55012: OR
55013: IFFALSE 55017
// exit ;
55015: GO 55112
// result := [ ] ;
55017: LD_ADDR_VAR 0 3
55021: PUSH
55022: EMPTY
55023: ST_TO_ADDR
// for un in units do
55024: LD_ADDR_VAR 0 4
55028: PUSH
55029: LD_VAR 0 1
55033: PUSH
55034: FOR_IN
55035: IFFALSE 55110
// if GetClass ( un ) = class then
55037: LD_VAR 0 4
55041: PPUSH
55042: CALL_OW 257
55046: PUSH
55047: LD_VAR 0 2
55051: EQUAL
55052: IFFALSE 55079
// result := Insert ( result , 1 , un ) else
55054: LD_ADDR_VAR 0 3
55058: PUSH
55059: LD_VAR 0 3
55063: PPUSH
55064: LD_INT 1
55066: PPUSH
55067: LD_VAR 0 4
55071: PPUSH
55072: CALL_OW 2
55076: ST_TO_ADDR
55077: GO 55108
// result := Replace ( result , result + 1 , un ) ;
55079: LD_ADDR_VAR 0 3
55083: PUSH
55084: LD_VAR 0 3
55088: PPUSH
55089: LD_VAR 0 3
55093: PUSH
55094: LD_INT 1
55096: PLUS
55097: PPUSH
55098: LD_VAR 0 4
55102: PPUSH
55103: CALL_OW 1
55107: ST_TO_ADDR
55108: GO 55034
55110: POP
55111: POP
// end ;
55112: LD_VAR 0 3
55116: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
55117: LD_INT 0
55119: PPUSH
55120: PPUSH
55121: PPUSH
55122: PPUSH
55123: PPUSH
55124: PPUSH
55125: PPUSH
// result := [ ] ;
55126: LD_ADDR_VAR 0 4
55130: PUSH
55131: EMPTY
55132: ST_TO_ADDR
// if x - r < 0 then
55133: LD_VAR 0 1
55137: PUSH
55138: LD_VAR 0 3
55142: MINUS
55143: PUSH
55144: LD_INT 0
55146: LESS
55147: IFFALSE 55159
// min_x := 0 else
55149: LD_ADDR_VAR 0 8
55153: PUSH
55154: LD_INT 0
55156: ST_TO_ADDR
55157: GO 55175
// min_x := x - r ;
55159: LD_ADDR_VAR 0 8
55163: PUSH
55164: LD_VAR 0 1
55168: PUSH
55169: LD_VAR 0 3
55173: MINUS
55174: ST_TO_ADDR
// if y - r < 0 then
55175: LD_VAR 0 2
55179: PUSH
55180: LD_VAR 0 3
55184: MINUS
55185: PUSH
55186: LD_INT 0
55188: LESS
55189: IFFALSE 55201
// min_y := 0 else
55191: LD_ADDR_VAR 0 7
55195: PUSH
55196: LD_INT 0
55198: ST_TO_ADDR
55199: GO 55217
// min_y := y - r ;
55201: LD_ADDR_VAR 0 7
55205: PUSH
55206: LD_VAR 0 2
55210: PUSH
55211: LD_VAR 0 3
55215: MINUS
55216: ST_TO_ADDR
// max_x := x + r ;
55217: LD_ADDR_VAR 0 9
55221: PUSH
55222: LD_VAR 0 1
55226: PUSH
55227: LD_VAR 0 3
55231: PLUS
55232: ST_TO_ADDR
// max_y := y + r ;
55233: LD_ADDR_VAR 0 10
55237: PUSH
55238: LD_VAR 0 2
55242: PUSH
55243: LD_VAR 0 3
55247: PLUS
55248: ST_TO_ADDR
// for _x = min_x to max_x do
55249: LD_ADDR_VAR 0 5
55253: PUSH
55254: DOUBLE
55255: LD_VAR 0 8
55259: DEC
55260: ST_TO_ADDR
55261: LD_VAR 0 9
55265: PUSH
55266: FOR_TO
55267: IFFALSE 55368
// for _y = min_y to max_y do
55269: LD_ADDR_VAR 0 6
55273: PUSH
55274: DOUBLE
55275: LD_VAR 0 7
55279: DEC
55280: ST_TO_ADDR
55281: LD_VAR 0 10
55285: PUSH
55286: FOR_TO
55287: IFFALSE 55364
// begin if not ValidHex ( _x , _y ) then
55289: LD_VAR 0 5
55293: PPUSH
55294: LD_VAR 0 6
55298: PPUSH
55299: CALL_OW 488
55303: NOT
55304: IFFALSE 55308
// continue ;
55306: GO 55286
// if GetResourceTypeXY ( _x , _y ) then
55308: LD_VAR 0 5
55312: PPUSH
55313: LD_VAR 0 6
55317: PPUSH
55318: CALL_OW 283
55322: IFFALSE 55362
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
55324: LD_ADDR_VAR 0 4
55328: PUSH
55329: LD_VAR 0 4
55333: PPUSH
55334: LD_VAR 0 4
55338: PUSH
55339: LD_INT 1
55341: PLUS
55342: PPUSH
55343: LD_VAR 0 5
55347: PUSH
55348: LD_VAR 0 6
55352: PUSH
55353: EMPTY
55354: LIST
55355: LIST
55356: PPUSH
55357: CALL_OW 1
55361: ST_TO_ADDR
// end ;
55362: GO 55286
55364: POP
55365: POP
55366: GO 55266
55368: POP
55369: POP
// end ;
55370: LD_VAR 0 4
55374: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
55375: LD_INT 0
55377: PPUSH
55378: PPUSH
55379: PPUSH
55380: PPUSH
55381: PPUSH
55382: PPUSH
55383: PPUSH
55384: PPUSH
// if not units then
55385: LD_VAR 0 1
55389: NOT
55390: IFFALSE 55394
// exit ;
55392: GO 55918
// result := UnitFilter ( units , [ f_ok ] ) ;
55394: LD_ADDR_VAR 0 3
55398: PUSH
55399: LD_VAR 0 1
55403: PPUSH
55404: LD_INT 50
55406: PUSH
55407: EMPTY
55408: LIST
55409: PPUSH
55410: CALL_OW 72
55414: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
55415: LD_ADDR_VAR 0 8
55419: PUSH
55420: LD_VAR 0 1
55424: PUSH
55425: LD_INT 1
55427: ARRAY
55428: PPUSH
55429: CALL_OW 255
55433: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
55434: LD_ADDR_VAR 0 10
55438: PUSH
55439: LD_INT 29
55441: PUSH
55442: LD_INT 91
55444: PUSH
55445: LD_INT 49
55447: PUSH
55448: EMPTY
55449: LIST
55450: LIST
55451: LIST
55452: ST_TO_ADDR
// if not result then
55453: LD_VAR 0 3
55457: NOT
55458: IFFALSE 55462
// exit ;
55460: GO 55918
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
55462: LD_ADDR_VAR 0 5
55466: PUSH
55467: LD_INT 81
55469: PUSH
55470: LD_VAR 0 8
55474: PUSH
55475: EMPTY
55476: LIST
55477: LIST
55478: PPUSH
55479: CALL_OW 69
55483: ST_TO_ADDR
// for i in result do
55484: LD_ADDR_VAR 0 4
55488: PUSH
55489: LD_VAR 0 3
55493: PUSH
55494: FOR_IN
55495: IFFALSE 55916
// begin tag := GetTag ( i ) + 1 ;
55497: LD_ADDR_VAR 0 9
55501: PUSH
55502: LD_VAR 0 4
55506: PPUSH
55507: CALL_OW 110
55511: PUSH
55512: LD_INT 1
55514: PLUS
55515: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
55516: LD_ADDR_VAR 0 7
55520: PUSH
55521: LD_VAR 0 4
55525: PPUSH
55526: CALL_OW 250
55530: PPUSH
55531: LD_VAR 0 4
55535: PPUSH
55536: CALL_OW 251
55540: PPUSH
55541: LD_INT 6
55543: PPUSH
55544: CALL 55117 0 3
55548: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
55549: LD_VAR 0 4
55553: PPUSH
55554: CALL_OW 247
55558: PUSH
55559: LD_INT 2
55561: EQUAL
55562: PUSH
55563: LD_VAR 0 7
55567: AND
55568: PUSH
55569: LD_VAR 0 4
55573: PPUSH
55574: CALL_OW 264
55578: PUSH
55579: LD_VAR 0 10
55583: IN
55584: NOT
55585: AND
55586: IFFALSE 55625
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
55588: LD_VAR 0 4
55592: PPUSH
55593: LD_VAR 0 7
55597: PUSH
55598: LD_INT 1
55600: ARRAY
55601: PUSH
55602: LD_INT 1
55604: ARRAY
55605: PPUSH
55606: LD_VAR 0 7
55610: PUSH
55611: LD_INT 1
55613: ARRAY
55614: PUSH
55615: LD_INT 2
55617: ARRAY
55618: PPUSH
55619: CALL_OW 116
55623: GO 55914
// if path > tag then
55625: LD_VAR 0 2
55629: PUSH
55630: LD_VAR 0 9
55634: GREATER
55635: IFFALSE 55843
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
55637: LD_ADDR_VAR 0 6
55641: PUSH
55642: LD_VAR 0 5
55646: PPUSH
55647: LD_INT 91
55649: PUSH
55650: LD_VAR 0 4
55654: PUSH
55655: LD_INT 8
55657: PUSH
55658: EMPTY
55659: LIST
55660: LIST
55661: LIST
55662: PPUSH
55663: CALL_OW 72
55667: ST_TO_ADDR
// if nearEnemy then
55668: LD_VAR 0 6
55672: IFFALSE 55741
// begin if GetWeapon ( i ) = ru_time_lapser then
55674: LD_VAR 0 4
55678: PPUSH
55679: CALL_OW 264
55683: PUSH
55684: LD_INT 49
55686: EQUAL
55687: IFFALSE 55715
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
55689: LD_VAR 0 4
55693: PPUSH
55694: LD_VAR 0 6
55698: PPUSH
55699: LD_VAR 0 4
55703: PPUSH
55704: CALL_OW 74
55708: PPUSH
55709: CALL_OW 112
55713: GO 55739
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
55715: LD_VAR 0 4
55719: PPUSH
55720: LD_VAR 0 6
55724: PPUSH
55725: LD_VAR 0 4
55729: PPUSH
55730: CALL_OW 74
55734: PPUSH
55735: CALL_OW 115
// end else
55739: GO 55841
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
55741: LD_VAR 0 4
55745: PPUSH
55746: LD_VAR 0 2
55750: PUSH
55751: LD_VAR 0 9
55755: ARRAY
55756: PUSH
55757: LD_INT 1
55759: ARRAY
55760: PPUSH
55761: LD_VAR 0 2
55765: PUSH
55766: LD_VAR 0 9
55770: ARRAY
55771: PUSH
55772: LD_INT 2
55774: ARRAY
55775: PPUSH
55776: CALL_OW 297
55780: PUSH
55781: LD_INT 6
55783: GREATER
55784: IFFALSE 55827
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
55786: LD_VAR 0 4
55790: PPUSH
55791: LD_VAR 0 2
55795: PUSH
55796: LD_VAR 0 9
55800: ARRAY
55801: PUSH
55802: LD_INT 1
55804: ARRAY
55805: PPUSH
55806: LD_VAR 0 2
55810: PUSH
55811: LD_VAR 0 9
55815: ARRAY
55816: PUSH
55817: LD_INT 2
55819: ARRAY
55820: PPUSH
55821: CALL_OW 114
55825: GO 55841
// SetTag ( i , tag ) ;
55827: LD_VAR 0 4
55831: PPUSH
55832: LD_VAR 0 9
55836: PPUSH
55837: CALL_OW 109
// end else
55841: GO 55914
// if enemy then
55843: LD_VAR 0 5
55847: IFFALSE 55914
// begin if GetWeapon ( i ) = ru_time_lapser then
55849: LD_VAR 0 4
55853: PPUSH
55854: CALL_OW 264
55858: PUSH
55859: LD_INT 49
55861: EQUAL
55862: IFFALSE 55890
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
55864: LD_VAR 0 4
55868: PPUSH
55869: LD_VAR 0 5
55873: PPUSH
55874: LD_VAR 0 4
55878: PPUSH
55879: CALL_OW 74
55883: PPUSH
55884: CALL_OW 112
55888: GO 55914
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
55890: LD_VAR 0 4
55894: PPUSH
55895: LD_VAR 0 5
55899: PPUSH
55900: LD_VAR 0 4
55904: PPUSH
55905: CALL_OW 74
55909: PPUSH
55910: CALL_OW 115
// end ; end ;
55914: GO 55494
55916: POP
55917: POP
// end ;
55918: LD_VAR 0 3
55922: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
55923: LD_INT 0
55925: PPUSH
55926: PPUSH
55927: PPUSH
// if not unit or IsInUnit ( unit ) then
55928: LD_VAR 0 1
55932: NOT
55933: PUSH
55934: LD_VAR 0 1
55938: PPUSH
55939: CALL_OW 310
55943: OR
55944: IFFALSE 55948
// exit ;
55946: GO 56039
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
55948: LD_ADDR_VAR 0 4
55952: PUSH
55953: LD_VAR 0 1
55957: PPUSH
55958: CALL_OW 250
55962: PPUSH
55963: LD_VAR 0 2
55967: PPUSH
55968: LD_INT 1
55970: PPUSH
55971: CALL_OW 272
55975: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
55976: LD_ADDR_VAR 0 5
55980: PUSH
55981: LD_VAR 0 1
55985: PPUSH
55986: CALL_OW 251
55990: PPUSH
55991: LD_VAR 0 2
55995: PPUSH
55996: LD_INT 1
55998: PPUSH
55999: CALL_OW 273
56003: ST_TO_ADDR
// if ValidHex ( x , y ) then
56004: LD_VAR 0 4
56008: PPUSH
56009: LD_VAR 0 5
56013: PPUSH
56014: CALL_OW 488
56018: IFFALSE 56039
// ComTurnXY ( unit , x , y ) ;
56020: LD_VAR 0 1
56024: PPUSH
56025: LD_VAR 0 4
56029: PPUSH
56030: LD_VAR 0 5
56034: PPUSH
56035: CALL_OW 118
// end ;
56039: LD_VAR 0 3
56043: RET
// export function SeeUnits ( side , units ) ; var i ; begin
56044: LD_INT 0
56046: PPUSH
56047: PPUSH
// result := false ;
56048: LD_ADDR_VAR 0 3
56052: PUSH
56053: LD_INT 0
56055: ST_TO_ADDR
// if not units then
56056: LD_VAR 0 2
56060: NOT
56061: IFFALSE 56065
// exit ;
56063: GO 56110
// for i in units do
56065: LD_ADDR_VAR 0 4
56069: PUSH
56070: LD_VAR 0 2
56074: PUSH
56075: FOR_IN
56076: IFFALSE 56108
// if See ( side , i ) then
56078: LD_VAR 0 1
56082: PPUSH
56083: LD_VAR 0 4
56087: PPUSH
56088: CALL_OW 292
56092: IFFALSE 56106
// begin result := true ;
56094: LD_ADDR_VAR 0 3
56098: PUSH
56099: LD_INT 1
56101: ST_TO_ADDR
// exit ;
56102: POP
56103: POP
56104: GO 56110
// end ;
56106: GO 56075
56108: POP
56109: POP
// end ;
56110: LD_VAR 0 3
56114: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
56115: LD_INT 0
56117: PPUSH
56118: PPUSH
56119: PPUSH
56120: PPUSH
// if not unit or not points then
56121: LD_VAR 0 1
56125: NOT
56126: PUSH
56127: LD_VAR 0 2
56131: NOT
56132: OR
56133: IFFALSE 56137
// exit ;
56135: GO 56227
// dist := 99999 ;
56137: LD_ADDR_VAR 0 5
56141: PUSH
56142: LD_INT 99999
56144: ST_TO_ADDR
// for i in points do
56145: LD_ADDR_VAR 0 4
56149: PUSH
56150: LD_VAR 0 2
56154: PUSH
56155: FOR_IN
56156: IFFALSE 56225
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
56158: LD_ADDR_VAR 0 6
56162: PUSH
56163: LD_VAR 0 1
56167: PPUSH
56168: LD_VAR 0 4
56172: PUSH
56173: LD_INT 1
56175: ARRAY
56176: PPUSH
56177: LD_VAR 0 4
56181: PUSH
56182: LD_INT 2
56184: ARRAY
56185: PPUSH
56186: CALL_OW 297
56190: ST_TO_ADDR
// if tmpDist < dist then
56191: LD_VAR 0 6
56195: PUSH
56196: LD_VAR 0 5
56200: LESS
56201: IFFALSE 56223
// begin result := i ;
56203: LD_ADDR_VAR 0 3
56207: PUSH
56208: LD_VAR 0 4
56212: ST_TO_ADDR
// dist := tmpDist ;
56213: LD_ADDR_VAR 0 5
56217: PUSH
56218: LD_VAR 0 6
56222: ST_TO_ADDR
// end ; end ;
56223: GO 56155
56225: POP
56226: POP
// end ;
56227: LD_VAR 0 3
56231: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
56232: LD_INT 0
56234: PPUSH
// uc_side := side ;
56235: LD_ADDR_OWVAR 20
56239: PUSH
56240: LD_VAR 0 1
56244: ST_TO_ADDR
// uc_nation := 3 ;
56245: LD_ADDR_OWVAR 21
56249: PUSH
56250: LD_INT 3
56252: ST_TO_ADDR
// vc_chassis := 25 ;
56253: LD_ADDR_OWVAR 37
56257: PUSH
56258: LD_INT 25
56260: ST_TO_ADDR
// vc_engine := engine_siberite ;
56261: LD_ADDR_OWVAR 39
56265: PUSH
56266: LD_INT 3
56268: ST_TO_ADDR
// vc_control := control_computer ;
56269: LD_ADDR_OWVAR 38
56273: PUSH
56274: LD_INT 3
56276: ST_TO_ADDR
// vc_weapon := 59 ;
56277: LD_ADDR_OWVAR 40
56281: PUSH
56282: LD_INT 59
56284: ST_TO_ADDR
// result := CreateVehicle ;
56285: LD_ADDR_VAR 0 5
56289: PUSH
56290: CALL_OW 45
56294: ST_TO_ADDR
// SetDir ( result , d ) ;
56295: LD_VAR 0 5
56299: PPUSH
56300: LD_VAR 0 4
56304: PPUSH
56305: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
56309: LD_VAR 0 5
56313: PPUSH
56314: LD_VAR 0 2
56318: PPUSH
56319: LD_VAR 0 3
56323: PPUSH
56324: LD_INT 0
56326: PPUSH
56327: CALL_OW 48
// end ;
56331: LD_VAR 0 5
56335: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
56336: LD_INT 0
56338: PPUSH
56339: PPUSH
56340: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
56341: LD_ADDR_VAR 0 2
56345: PUSH
56346: LD_INT 0
56348: PUSH
56349: LD_INT 0
56351: PUSH
56352: LD_INT 0
56354: PUSH
56355: LD_INT 0
56357: PUSH
56358: EMPTY
56359: LIST
56360: LIST
56361: LIST
56362: LIST
56363: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
56364: LD_VAR 0 1
56368: NOT
56369: PUSH
56370: LD_VAR 0 1
56374: PPUSH
56375: CALL_OW 264
56379: PUSH
56380: LD_INT 12
56382: PUSH
56383: LD_INT 51
56385: PUSH
56386: LD_INT 32
56388: PUSH
56389: LD_INT 89
56391: PUSH
56392: EMPTY
56393: LIST
56394: LIST
56395: LIST
56396: LIST
56397: IN
56398: NOT
56399: OR
56400: IFFALSE 56404
// exit ;
56402: GO 56502
// for i := 1 to 3 do
56404: LD_ADDR_VAR 0 3
56408: PUSH
56409: DOUBLE
56410: LD_INT 1
56412: DEC
56413: ST_TO_ADDR
56414: LD_INT 3
56416: PUSH
56417: FOR_TO
56418: IFFALSE 56500
// begin tmp := GetCargo ( cargo , i ) ;
56420: LD_ADDR_VAR 0 4
56424: PUSH
56425: LD_VAR 0 1
56429: PPUSH
56430: LD_VAR 0 3
56434: PPUSH
56435: CALL_OW 289
56439: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
56440: LD_ADDR_VAR 0 2
56444: PUSH
56445: LD_VAR 0 2
56449: PPUSH
56450: LD_VAR 0 3
56454: PPUSH
56455: LD_VAR 0 4
56459: PPUSH
56460: CALL_OW 1
56464: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
56465: LD_ADDR_VAR 0 2
56469: PUSH
56470: LD_VAR 0 2
56474: PPUSH
56475: LD_INT 4
56477: PPUSH
56478: LD_VAR 0 2
56482: PUSH
56483: LD_INT 4
56485: ARRAY
56486: PUSH
56487: LD_VAR 0 4
56491: PLUS
56492: PPUSH
56493: CALL_OW 1
56497: ST_TO_ADDR
// end ;
56498: GO 56417
56500: POP
56501: POP
// end ;
56502: LD_VAR 0 2
56506: RET
// export function Length ( array ) ; begin
56507: LD_INT 0
56509: PPUSH
// result := array + 0 ;
56510: LD_ADDR_VAR 0 2
56514: PUSH
56515: LD_VAR 0 1
56519: PUSH
56520: LD_INT 0
56522: PLUS
56523: ST_TO_ADDR
// end ;
56524: LD_VAR 0 2
56528: RET
// export function PrepareArray ( array ) ; begin
56529: LD_INT 0
56531: PPUSH
// result := array diff 0 ;
56532: LD_ADDR_VAR 0 2
56536: PUSH
56537: LD_VAR 0 1
56541: PUSH
56542: LD_INT 0
56544: DIFF
56545: ST_TO_ADDR
// if not result [ 1 ] then
56546: LD_VAR 0 2
56550: PUSH
56551: LD_INT 1
56553: ARRAY
56554: NOT
56555: IFFALSE 56575
// result := Delete ( result , 1 ) ;
56557: LD_ADDR_VAR 0 2
56561: PUSH
56562: LD_VAR 0 2
56566: PPUSH
56567: LD_INT 1
56569: PPUSH
56570: CALL_OW 3
56574: ST_TO_ADDR
// end ;
56575: LD_VAR 0 2
56579: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
56580: LD_INT 0
56582: PPUSH
56583: PPUSH
56584: PPUSH
56585: PPUSH
// sibRocketRange := 25 ;
56586: LD_ADDR_VAR 0 6
56590: PUSH
56591: LD_INT 25
56593: ST_TO_ADDR
// result := false ;
56594: LD_ADDR_VAR 0 4
56598: PUSH
56599: LD_INT 0
56601: ST_TO_ADDR
// for i := 0 to 5 do
56602: LD_ADDR_VAR 0 5
56606: PUSH
56607: DOUBLE
56608: LD_INT 0
56610: DEC
56611: ST_TO_ADDR
56612: LD_INT 5
56614: PUSH
56615: FOR_TO
56616: IFFALSE 56683
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
56618: LD_VAR 0 1
56622: PPUSH
56623: LD_VAR 0 5
56627: PPUSH
56628: LD_VAR 0 6
56632: PPUSH
56633: CALL_OW 272
56637: PPUSH
56638: LD_VAR 0 2
56642: PPUSH
56643: LD_VAR 0 5
56647: PPUSH
56648: LD_VAR 0 6
56652: PPUSH
56653: CALL_OW 273
56657: PPUSH
56658: LD_VAR 0 3
56662: PPUSH
56663: CALL_OW 309
56667: IFFALSE 56681
// begin result := true ;
56669: LD_ADDR_VAR 0 4
56673: PUSH
56674: LD_INT 1
56676: ST_TO_ADDR
// exit ;
56677: POP
56678: POP
56679: GO 56685
// end ;
56681: GO 56615
56683: POP
56684: POP
// end ;
56685: LD_VAR 0 4
56689: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
56690: LD_INT 0
56692: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
56693: LD_VAR 0 1
56697: PPUSH
56698: LD_VAR 0 2
56702: PPUSH
56703: LD_INT 0
56705: PPUSH
56706: LD_INT 0
56708: PPUSH
56709: LD_INT 1
56711: PPUSH
56712: LD_INT 0
56714: PPUSH
56715: CALL_OW 587
// end ;
56719: LD_VAR 0 3
56723: RET
// export function CenterOnNow ( unit ) ; begin
56724: LD_INT 0
56726: PPUSH
// result := IsInUnit ( unit ) ;
56727: LD_ADDR_VAR 0 2
56731: PUSH
56732: LD_VAR 0 1
56736: PPUSH
56737: CALL_OW 310
56741: ST_TO_ADDR
// if not result then
56742: LD_VAR 0 2
56746: NOT
56747: IFFALSE 56759
// result := unit ;
56749: LD_ADDR_VAR 0 2
56753: PUSH
56754: LD_VAR 0 1
56758: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
56759: LD_VAR 0 1
56763: PPUSH
56764: CALL_OW 87
// end ;
56768: LD_VAR 0 2
56772: RET
// export function ComMoveHex ( unit , hex ) ; begin
56773: LD_INT 0
56775: PPUSH
// if not hex then
56776: LD_VAR 0 2
56780: NOT
56781: IFFALSE 56785
// exit ;
56783: GO 56838
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
56785: LD_VAR 0 2
56789: PUSH
56790: LD_INT 1
56792: ARRAY
56793: PPUSH
56794: LD_VAR 0 2
56798: PUSH
56799: LD_INT 2
56801: ARRAY
56802: PPUSH
56803: CALL_OW 428
56807: IFFALSE 56811
// exit ;
56809: GO 56838
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
56811: LD_VAR 0 1
56815: PPUSH
56816: LD_VAR 0 2
56820: PUSH
56821: LD_INT 1
56823: ARRAY
56824: PPUSH
56825: LD_VAR 0 2
56829: PUSH
56830: LD_INT 2
56832: ARRAY
56833: PPUSH
56834: CALL_OW 111
// end ; end_of_file
56838: LD_VAR 0 3
56842: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
56843: LD_INT 0
56845: PPUSH
56846: PPUSH
// skirmish := false ;
56847: LD_ADDR_EXP 59
56851: PUSH
56852: LD_INT 0
56854: ST_TO_ADDR
// debug_mc := false ;
56855: LD_ADDR_EXP 60
56859: PUSH
56860: LD_INT 0
56862: ST_TO_ADDR
// mc_bases := [ ] ;
56863: LD_ADDR_EXP 61
56867: PUSH
56868: EMPTY
56869: ST_TO_ADDR
// mc_sides := [ ] ;
56870: LD_ADDR_EXP 87
56874: PUSH
56875: EMPTY
56876: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
56877: LD_ADDR_EXP 62
56881: PUSH
56882: EMPTY
56883: ST_TO_ADDR
// mc_building_repairs := [ ] ;
56884: LD_ADDR_EXP 63
56888: PUSH
56889: EMPTY
56890: ST_TO_ADDR
// mc_need_heal := [ ] ;
56891: LD_ADDR_EXP 64
56895: PUSH
56896: EMPTY
56897: ST_TO_ADDR
// mc_healers := [ ] ;
56898: LD_ADDR_EXP 65
56902: PUSH
56903: EMPTY
56904: ST_TO_ADDR
// mc_build_list := [ ] ;
56905: LD_ADDR_EXP 66
56909: PUSH
56910: EMPTY
56911: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
56912: LD_ADDR_EXP 93
56916: PUSH
56917: EMPTY
56918: ST_TO_ADDR
// mc_builders := [ ] ;
56919: LD_ADDR_EXP 67
56923: PUSH
56924: EMPTY
56925: ST_TO_ADDR
// mc_construct_list := [ ] ;
56926: LD_ADDR_EXP 68
56930: PUSH
56931: EMPTY
56932: ST_TO_ADDR
// mc_turret_list := [ ] ;
56933: LD_ADDR_EXP 69
56937: PUSH
56938: EMPTY
56939: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
56940: LD_ADDR_EXP 70
56944: PUSH
56945: EMPTY
56946: ST_TO_ADDR
// mc_miners := [ ] ;
56947: LD_ADDR_EXP 75
56951: PUSH
56952: EMPTY
56953: ST_TO_ADDR
// mc_mines := [ ] ;
56954: LD_ADDR_EXP 74
56958: PUSH
56959: EMPTY
56960: ST_TO_ADDR
// mc_minefields := [ ] ;
56961: LD_ADDR_EXP 76
56965: PUSH
56966: EMPTY
56967: ST_TO_ADDR
// mc_crates := [ ] ;
56968: LD_ADDR_EXP 77
56972: PUSH
56973: EMPTY
56974: ST_TO_ADDR
// mc_crates_collector := [ ] ;
56975: LD_ADDR_EXP 78
56979: PUSH
56980: EMPTY
56981: ST_TO_ADDR
// mc_crates_area := [ ] ;
56982: LD_ADDR_EXP 79
56986: PUSH
56987: EMPTY
56988: ST_TO_ADDR
// mc_vehicles := [ ] ;
56989: LD_ADDR_EXP 80
56993: PUSH
56994: EMPTY
56995: ST_TO_ADDR
// mc_attack := [ ] ;
56996: LD_ADDR_EXP 81
57000: PUSH
57001: EMPTY
57002: ST_TO_ADDR
// mc_produce := [ ] ;
57003: LD_ADDR_EXP 82
57007: PUSH
57008: EMPTY
57009: ST_TO_ADDR
// mc_defender := [ ] ;
57010: LD_ADDR_EXP 83
57014: PUSH
57015: EMPTY
57016: ST_TO_ADDR
// mc_parking := [ ] ;
57017: LD_ADDR_EXP 85
57021: PUSH
57022: EMPTY
57023: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
57024: LD_ADDR_EXP 71
57028: PUSH
57029: EMPTY
57030: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
57031: LD_ADDR_EXP 73
57035: PUSH
57036: EMPTY
57037: ST_TO_ADDR
// mc_scan := [ ] ;
57038: LD_ADDR_EXP 84
57042: PUSH
57043: EMPTY
57044: ST_TO_ADDR
// mc_scan_area := [ ] ;
57045: LD_ADDR_EXP 86
57049: PUSH
57050: EMPTY
57051: ST_TO_ADDR
// mc_tech := [ ] ;
57052: LD_ADDR_EXP 88
57056: PUSH
57057: EMPTY
57058: ST_TO_ADDR
// mc_class := [ ] ;
57059: LD_ADDR_EXP 102
57063: PUSH
57064: EMPTY
57065: ST_TO_ADDR
// mc_class_case_use := [ ] ;
57066: LD_ADDR_EXP 103
57070: PUSH
57071: EMPTY
57072: ST_TO_ADDR
// mc_is_defending := [ ] ;
57073: LD_ADDR_EXP 104
57077: PUSH
57078: EMPTY
57079: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
57080: LD_ADDR_EXP 95
57084: PUSH
57085: EMPTY
57086: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
57087: LD_ADDR_EXP 105
57091: PUSH
57092: LD_INT 0
57094: ST_TO_ADDR
// end ;
57095: LD_VAR 0 1
57099: RET
// export function MC_Kill ( base ) ; begin
57100: LD_INT 0
57102: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
57103: LD_ADDR_EXP 61
57107: PUSH
57108: LD_EXP 61
57112: PPUSH
57113: LD_VAR 0 1
57117: PPUSH
57118: EMPTY
57119: PPUSH
57120: CALL_OW 1
57124: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57125: LD_ADDR_EXP 62
57129: PUSH
57130: LD_EXP 62
57134: PPUSH
57135: LD_VAR 0 1
57139: PPUSH
57140: EMPTY
57141: PPUSH
57142: CALL_OW 1
57146: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57147: LD_ADDR_EXP 63
57151: PUSH
57152: LD_EXP 63
57156: PPUSH
57157: LD_VAR 0 1
57161: PPUSH
57162: EMPTY
57163: PPUSH
57164: CALL_OW 1
57168: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57169: LD_ADDR_EXP 64
57173: PUSH
57174: LD_EXP 64
57178: PPUSH
57179: LD_VAR 0 1
57183: PPUSH
57184: EMPTY
57185: PPUSH
57186: CALL_OW 1
57190: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57191: LD_ADDR_EXP 65
57195: PUSH
57196: LD_EXP 65
57200: PPUSH
57201: LD_VAR 0 1
57205: PPUSH
57206: EMPTY
57207: PPUSH
57208: CALL_OW 1
57212: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57213: LD_ADDR_EXP 66
57217: PUSH
57218: LD_EXP 66
57222: PPUSH
57223: LD_VAR 0 1
57227: PPUSH
57228: EMPTY
57229: PPUSH
57230: CALL_OW 1
57234: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57235: LD_ADDR_EXP 67
57239: PUSH
57240: LD_EXP 67
57244: PPUSH
57245: LD_VAR 0 1
57249: PPUSH
57250: EMPTY
57251: PPUSH
57252: CALL_OW 1
57256: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57257: LD_ADDR_EXP 68
57261: PUSH
57262: LD_EXP 68
57266: PPUSH
57267: LD_VAR 0 1
57271: PPUSH
57272: EMPTY
57273: PPUSH
57274: CALL_OW 1
57278: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57279: LD_ADDR_EXP 69
57283: PUSH
57284: LD_EXP 69
57288: PPUSH
57289: LD_VAR 0 1
57293: PPUSH
57294: EMPTY
57295: PPUSH
57296: CALL_OW 1
57300: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57301: LD_ADDR_EXP 70
57305: PUSH
57306: LD_EXP 70
57310: PPUSH
57311: LD_VAR 0 1
57315: PPUSH
57316: EMPTY
57317: PPUSH
57318: CALL_OW 1
57322: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57323: LD_ADDR_EXP 71
57327: PUSH
57328: LD_EXP 71
57332: PPUSH
57333: LD_VAR 0 1
57337: PPUSH
57338: EMPTY
57339: PPUSH
57340: CALL_OW 1
57344: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57345: LD_ADDR_EXP 72
57349: PUSH
57350: LD_EXP 72
57354: PPUSH
57355: LD_VAR 0 1
57359: PPUSH
57360: LD_INT 0
57362: PPUSH
57363: CALL_OW 1
57367: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57368: LD_ADDR_EXP 73
57372: PUSH
57373: LD_EXP 73
57377: PPUSH
57378: LD_VAR 0 1
57382: PPUSH
57383: EMPTY
57384: PPUSH
57385: CALL_OW 1
57389: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57390: LD_ADDR_EXP 74
57394: PUSH
57395: LD_EXP 74
57399: PPUSH
57400: LD_VAR 0 1
57404: PPUSH
57405: EMPTY
57406: PPUSH
57407: CALL_OW 1
57411: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57412: LD_ADDR_EXP 75
57416: PUSH
57417: LD_EXP 75
57421: PPUSH
57422: LD_VAR 0 1
57426: PPUSH
57427: EMPTY
57428: PPUSH
57429: CALL_OW 1
57433: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57434: LD_ADDR_EXP 76
57438: PUSH
57439: LD_EXP 76
57443: PPUSH
57444: LD_VAR 0 1
57448: PPUSH
57449: EMPTY
57450: PPUSH
57451: CALL_OW 1
57455: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57456: LD_ADDR_EXP 77
57460: PUSH
57461: LD_EXP 77
57465: PPUSH
57466: LD_VAR 0 1
57470: PPUSH
57471: EMPTY
57472: PPUSH
57473: CALL_OW 1
57477: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57478: LD_ADDR_EXP 78
57482: PUSH
57483: LD_EXP 78
57487: PPUSH
57488: LD_VAR 0 1
57492: PPUSH
57493: EMPTY
57494: PPUSH
57495: CALL_OW 1
57499: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57500: LD_ADDR_EXP 79
57504: PUSH
57505: LD_EXP 79
57509: PPUSH
57510: LD_VAR 0 1
57514: PPUSH
57515: EMPTY
57516: PPUSH
57517: CALL_OW 1
57521: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57522: LD_ADDR_EXP 80
57526: PUSH
57527: LD_EXP 80
57531: PPUSH
57532: LD_VAR 0 1
57536: PPUSH
57537: EMPTY
57538: PPUSH
57539: CALL_OW 1
57543: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57544: LD_ADDR_EXP 81
57548: PUSH
57549: LD_EXP 81
57553: PPUSH
57554: LD_VAR 0 1
57558: PPUSH
57559: EMPTY
57560: PPUSH
57561: CALL_OW 1
57565: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57566: LD_ADDR_EXP 82
57570: PUSH
57571: LD_EXP 82
57575: PPUSH
57576: LD_VAR 0 1
57580: PPUSH
57581: EMPTY
57582: PPUSH
57583: CALL_OW 1
57587: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57588: LD_ADDR_EXP 83
57592: PUSH
57593: LD_EXP 83
57597: PPUSH
57598: LD_VAR 0 1
57602: PPUSH
57603: EMPTY
57604: PPUSH
57605: CALL_OW 1
57609: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57610: LD_ADDR_EXP 84
57614: PUSH
57615: LD_EXP 84
57619: PPUSH
57620: LD_VAR 0 1
57624: PPUSH
57625: EMPTY
57626: PPUSH
57627: CALL_OW 1
57631: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57632: LD_ADDR_EXP 85
57636: PUSH
57637: LD_EXP 85
57641: PPUSH
57642: LD_VAR 0 1
57646: PPUSH
57647: EMPTY
57648: PPUSH
57649: CALL_OW 1
57653: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57654: LD_ADDR_EXP 86
57658: PUSH
57659: LD_EXP 86
57663: PPUSH
57664: LD_VAR 0 1
57668: PPUSH
57669: EMPTY
57670: PPUSH
57671: CALL_OW 1
57675: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57676: LD_ADDR_EXP 88
57680: PUSH
57681: LD_EXP 88
57685: PPUSH
57686: LD_VAR 0 1
57690: PPUSH
57691: EMPTY
57692: PPUSH
57693: CALL_OW 1
57697: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57698: LD_ADDR_EXP 90
57702: PUSH
57703: LD_EXP 90
57707: PPUSH
57708: LD_VAR 0 1
57712: PPUSH
57713: EMPTY
57714: PPUSH
57715: CALL_OW 1
57719: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57720: LD_ADDR_EXP 91
57724: PUSH
57725: LD_EXP 91
57729: PPUSH
57730: LD_VAR 0 1
57734: PPUSH
57735: EMPTY
57736: PPUSH
57737: CALL_OW 1
57741: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57742: LD_ADDR_EXP 92
57746: PUSH
57747: LD_EXP 92
57751: PPUSH
57752: LD_VAR 0 1
57756: PPUSH
57757: EMPTY
57758: PPUSH
57759: CALL_OW 1
57763: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57764: LD_ADDR_EXP 93
57768: PUSH
57769: LD_EXP 93
57773: PPUSH
57774: LD_VAR 0 1
57778: PPUSH
57779: EMPTY
57780: PPUSH
57781: CALL_OW 1
57785: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57786: LD_ADDR_EXP 94
57790: PUSH
57791: LD_EXP 94
57795: PPUSH
57796: LD_VAR 0 1
57800: PPUSH
57801: EMPTY
57802: PPUSH
57803: CALL_OW 1
57807: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57808: LD_ADDR_EXP 95
57812: PUSH
57813: LD_EXP 95
57817: PPUSH
57818: LD_VAR 0 1
57822: PPUSH
57823: EMPTY
57824: PPUSH
57825: CALL_OW 1
57829: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57830: LD_ADDR_EXP 96
57834: PUSH
57835: LD_EXP 96
57839: PPUSH
57840: LD_VAR 0 1
57844: PPUSH
57845: EMPTY
57846: PPUSH
57847: CALL_OW 1
57851: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57852: LD_ADDR_EXP 97
57856: PUSH
57857: LD_EXP 97
57861: PPUSH
57862: LD_VAR 0 1
57866: PPUSH
57867: EMPTY
57868: PPUSH
57869: CALL_OW 1
57873: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57874: LD_ADDR_EXP 98
57878: PUSH
57879: LD_EXP 98
57883: PPUSH
57884: LD_VAR 0 1
57888: PPUSH
57889: EMPTY
57890: PPUSH
57891: CALL_OW 1
57895: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57896: LD_ADDR_EXP 99
57900: PUSH
57901: LD_EXP 99
57905: PPUSH
57906: LD_VAR 0 1
57910: PPUSH
57911: EMPTY
57912: PPUSH
57913: CALL_OW 1
57917: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57918: LD_ADDR_EXP 100
57922: PUSH
57923: LD_EXP 100
57927: PPUSH
57928: LD_VAR 0 1
57932: PPUSH
57933: EMPTY
57934: PPUSH
57935: CALL_OW 1
57939: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57940: LD_ADDR_EXP 101
57944: PUSH
57945: LD_EXP 101
57949: PPUSH
57950: LD_VAR 0 1
57954: PPUSH
57955: EMPTY
57956: PPUSH
57957: CALL_OW 1
57961: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57962: LD_ADDR_EXP 102
57966: PUSH
57967: LD_EXP 102
57971: PPUSH
57972: LD_VAR 0 1
57976: PPUSH
57977: EMPTY
57978: PPUSH
57979: CALL_OW 1
57983: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57984: LD_ADDR_EXP 103
57988: PUSH
57989: LD_EXP 103
57993: PPUSH
57994: LD_VAR 0 1
57998: PPUSH
57999: LD_INT 0
58001: PPUSH
58002: CALL_OW 1
58006: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
58007: LD_ADDR_EXP 104
58011: PUSH
58012: LD_EXP 104
58016: PPUSH
58017: LD_VAR 0 1
58021: PPUSH
58022: LD_INT 0
58024: PPUSH
58025: CALL_OW 1
58029: ST_TO_ADDR
// end ;
58030: LD_VAR 0 2
58034: RET
// export function MC_Add ( side , units ) ; var base ; begin
58035: LD_INT 0
58037: PPUSH
58038: PPUSH
// base := mc_bases + 1 ;
58039: LD_ADDR_VAR 0 4
58043: PUSH
58044: LD_EXP 61
58048: PUSH
58049: LD_INT 1
58051: PLUS
58052: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
58053: LD_ADDR_EXP 87
58057: PUSH
58058: LD_EXP 87
58062: PPUSH
58063: LD_VAR 0 4
58067: PPUSH
58068: LD_VAR 0 1
58072: PPUSH
58073: CALL_OW 1
58077: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
58078: LD_ADDR_EXP 61
58082: PUSH
58083: LD_EXP 61
58087: PPUSH
58088: LD_VAR 0 4
58092: PPUSH
58093: LD_VAR 0 2
58097: PPUSH
58098: CALL_OW 1
58102: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
58103: LD_ADDR_EXP 62
58107: PUSH
58108: LD_EXP 62
58112: PPUSH
58113: LD_VAR 0 4
58117: PPUSH
58118: EMPTY
58119: PPUSH
58120: CALL_OW 1
58124: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
58125: LD_ADDR_EXP 63
58129: PUSH
58130: LD_EXP 63
58134: PPUSH
58135: LD_VAR 0 4
58139: PPUSH
58140: EMPTY
58141: PPUSH
58142: CALL_OW 1
58146: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
58147: LD_ADDR_EXP 64
58151: PUSH
58152: LD_EXP 64
58156: PPUSH
58157: LD_VAR 0 4
58161: PPUSH
58162: EMPTY
58163: PPUSH
58164: CALL_OW 1
58168: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
58169: LD_ADDR_EXP 65
58173: PUSH
58174: LD_EXP 65
58178: PPUSH
58179: LD_VAR 0 4
58183: PPUSH
58184: EMPTY
58185: PPUSH
58186: CALL_OW 1
58190: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
58191: LD_ADDR_EXP 66
58195: PUSH
58196: LD_EXP 66
58200: PPUSH
58201: LD_VAR 0 4
58205: PPUSH
58206: EMPTY
58207: PPUSH
58208: CALL_OW 1
58212: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
58213: LD_ADDR_EXP 67
58217: PUSH
58218: LD_EXP 67
58222: PPUSH
58223: LD_VAR 0 4
58227: PPUSH
58228: EMPTY
58229: PPUSH
58230: CALL_OW 1
58234: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
58235: LD_ADDR_EXP 68
58239: PUSH
58240: LD_EXP 68
58244: PPUSH
58245: LD_VAR 0 4
58249: PPUSH
58250: EMPTY
58251: PPUSH
58252: CALL_OW 1
58256: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
58257: LD_ADDR_EXP 69
58261: PUSH
58262: LD_EXP 69
58266: PPUSH
58267: LD_VAR 0 4
58271: PPUSH
58272: EMPTY
58273: PPUSH
58274: CALL_OW 1
58278: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58279: LD_ADDR_EXP 70
58283: PUSH
58284: LD_EXP 70
58288: PPUSH
58289: LD_VAR 0 4
58293: PPUSH
58294: EMPTY
58295: PPUSH
58296: CALL_OW 1
58300: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58301: LD_ADDR_EXP 71
58305: PUSH
58306: LD_EXP 71
58310: PPUSH
58311: LD_VAR 0 4
58315: PPUSH
58316: EMPTY
58317: PPUSH
58318: CALL_OW 1
58322: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58323: LD_ADDR_EXP 72
58327: PUSH
58328: LD_EXP 72
58332: PPUSH
58333: LD_VAR 0 4
58337: PPUSH
58338: LD_INT 0
58340: PPUSH
58341: CALL_OW 1
58345: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58346: LD_ADDR_EXP 73
58350: PUSH
58351: LD_EXP 73
58355: PPUSH
58356: LD_VAR 0 4
58360: PPUSH
58361: EMPTY
58362: PPUSH
58363: CALL_OW 1
58367: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
58368: LD_ADDR_EXP 74
58372: PUSH
58373: LD_EXP 74
58377: PPUSH
58378: LD_VAR 0 4
58382: PPUSH
58383: EMPTY
58384: PPUSH
58385: CALL_OW 1
58389: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58390: LD_ADDR_EXP 75
58394: PUSH
58395: LD_EXP 75
58399: PPUSH
58400: LD_VAR 0 4
58404: PPUSH
58405: EMPTY
58406: PPUSH
58407: CALL_OW 1
58411: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58412: LD_ADDR_EXP 76
58416: PUSH
58417: LD_EXP 76
58421: PPUSH
58422: LD_VAR 0 4
58426: PPUSH
58427: EMPTY
58428: PPUSH
58429: CALL_OW 1
58433: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58434: LD_ADDR_EXP 77
58438: PUSH
58439: LD_EXP 77
58443: PPUSH
58444: LD_VAR 0 4
58448: PPUSH
58449: EMPTY
58450: PPUSH
58451: CALL_OW 1
58455: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58456: LD_ADDR_EXP 78
58460: PUSH
58461: LD_EXP 78
58465: PPUSH
58466: LD_VAR 0 4
58470: PPUSH
58471: EMPTY
58472: PPUSH
58473: CALL_OW 1
58477: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58478: LD_ADDR_EXP 79
58482: PUSH
58483: LD_EXP 79
58487: PPUSH
58488: LD_VAR 0 4
58492: PPUSH
58493: EMPTY
58494: PPUSH
58495: CALL_OW 1
58499: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58500: LD_ADDR_EXP 80
58504: PUSH
58505: LD_EXP 80
58509: PPUSH
58510: LD_VAR 0 4
58514: PPUSH
58515: EMPTY
58516: PPUSH
58517: CALL_OW 1
58521: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58522: LD_ADDR_EXP 81
58526: PUSH
58527: LD_EXP 81
58531: PPUSH
58532: LD_VAR 0 4
58536: PPUSH
58537: EMPTY
58538: PPUSH
58539: CALL_OW 1
58543: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58544: LD_ADDR_EXP 82
58548: PUSH
58549: LD_EXP 82
58553: PPUSH
58554: LD_VAR 0 4
58558: PPUSH
58559: EMPTY
58560: PPUSH
58561: CALL_OW 1
58565: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58566: LD_ADDR_EXP 83
58570: PUSH
58571: LD_EXP 83
58575: PPUSH
58576: LD_VAR 0 4
58580: PPUSH
58581: EMPTY
58582: PPUSH
58583: CALL_OW 1
58587: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58588: LD_ADDR_EXP 84
58592: PUSH
58593: LD_EXP 84
58597: PPUSH
58598: LD_VAR 0 4
58602: PPUSH
58603: EMPTY
58604: PPUSH
58605: CALL_OW 1
58609: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58610: LD_ADDR_EXP 85
58614: PUSH
58615: LD_EXP 85
58619: PPUSH
58620: LD_VAR 0 4
58624: PPUSH
58625: EMPTY
58626: PPUSH
58627: CALL_OW 1
58631: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58632: LD_ADDR_EXP 86
58636: PUSH
58637: LD_EXP 86
58641: PPUSH
58642: LD_VAR 0 4
58646: PPUSH
58647: EMPTY
58648: PPUSH
58649: CALL_OW 1
58653: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58654: LD_ADDR_EXP 88
58658: PUSH
58659: LD_EXP 88
58663: PPUSH
58664: LD_VAR 0 4
58668: PPUSH
58669: EMPTY
58670: PPUSH
58671: CALL_OW 1
58675: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58676: LD_ADDR_EXP 90
58680: PUSH
58681: LD_EXP 90
58685: PPUSH
58686: LD_VAR 0 4
58690: PPUSH
58691: EMPTY
58692: PPUSH
58693: CALL_OW 1
58697: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58698: LD_ADDR_EXP 91
58702: PUSH
58703: LD_EXP 91
58707: PPUSH
58708: LD_VAR 0 4
58712: PPUSH
58713: EMPTY
58714: PPUSH
58715: CALL_OW 1
58719: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58720: LD_ADDR_EXP 92
58724: PUSH
58725: LD_EXP 92
58729: PPUSH
58730: LD_VAR 0 4
58734: PPUSH
58735: EMPTY
58736: PPUSH
58737: CALL_OW 1
58741: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58742: LD_ADDR_EXP 93
58746: PUSH
58747: LD_EXP 93
58751: PPUSH
58752: LD_VAR 0 4
58756: PPUSH
58757: EMPTY
58758: PPUSH
58759: CALL_OW 1
58763: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58764: LD_ADDR_EXP 94
58768: PUSH
58769: LD_EXP 94
58773: PPUSH
58774: LD_VAR 0 4
58778: PPUSH
58779: EMPTY
58780: PPUSH
58781: CALL_OW 1
58785: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58786: LD_ADDR_EXP 95
58790: PUSH
58791: LD_EXP 95
58795: PPUSH
58796: LD_VAR 0 4
58800: PPUSH
58801: EMPTY
58802: PPUSH
58803: CALL_OW 1
58807: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58808: LD_ADDR_EXP 96
58812: PUSH
58813: LD_EXP 96
58817: PPUSH
58818: LD_VAR 0 4
58822: PPUSH
58823: EMPTY
58824: PPUSH
58825: CALL_OW 1
58829: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58830: LD_ADDR_EXP 97
58834: PUSH
58835: LD_EXP 97
58839: PPUSH
58840: LD_VAR 0 4
58844: PPUSH
58845: EMPTY
58846: PPUSH
58847: CALL_OW 1
58851: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58852: LD_ADDR_EXP 98
58856: PUSH
58857: LD_EXP 98
58861: PPUSH
58862: LD_VAR 0 4
58866: PPUSH
58867: EMPTY
58868: PPUSH
58869: CALL_OW 1
58873: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58874: LD_ADDR_EXP 99
58878: PUSH
58879: LD_EXP 99
58883: PPUSH
58884: LD_VAR 0 4
58888: PPUSH
58889: EMPTY
58890: PPUSH
58891: CALL_OW 1
58895: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58896: LD_ADDR_EXP 100
58900: PUSH
58901: LD_EXP 100
58905: PPUSH
58906: LD_VAR 0 4
58910: PPUSH
58911: EMPTY
58912: PPUSH
58913: CALL_OW 1
58917: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58918: LD_ADDR_EXP 101
58922: PUSH
58923: LD_EXP 101
58927: PPUSH
58928: LD_VAR 0 4
58932: PPUSH
58933: EMPTY
58934: PPUSH
58935: CALL_OW 1
58939: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58940: LD_ADDR_EXP 102
58944: PUSH
58945: LD_EXP 102
58949: PPUSH
58950: LD_VAR 0 4
58954: PPUSH
58955: EMPTY
58956: PPUSH
58957: CALL_OW 1
58961: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58962: LD_ADDR_EXP 103
58966: PUSH
58967: LD_EXP 103
58971: PPUSH
58972: LD_VAR 0 4
58976: PPUSH
58977: LD_INT 0
58979: PPUSH
58980: CALL_OW 1
58984: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
58985: LD_ADDR_EXP 104
58989: PUSH
58990: LD_EXP 104
58994: PPUSH
58995: LD_VAR 0 4
58999: PPUSH
59000: LD_INT 0
59002: PPUSH
59003: CALL_OW 1
59007: ST_TO_ADDR
// result := base ;
59008: LD_ADDR_VAR 0 3
59012: PUSH
59013: LD_VAR 0 4
59017: ST_TO_ADDR
// end ;
59018: LD_VAR 0 3
59022: RET
// export function MC_Start ( ) ; var i ; begin
59023: LD_INT 0
59025: PPUSH
59026: PPUSH
// for i = 1 to mc_bases do
59027: LD_ADDR_VAR 0 2
59031: PUSH
59032: DOUBLE
59033: LD_INT 1
59035: DEC
59036: ST_TO_ADDR
59037: LD_EXP 61
59041: PUSH
59042: FOR_TO
59043: IFFALSE 60143
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
59045: LD_ADDR_EXP 61
59049: PUSH
59050: LD_EXP 61
59054: PPUSH
59055: LD_VAR 0 2
59059: PPUSH
59060: LD_EXP 61
59064: PUSH
59065: LD_VAR 0 2
59069: ARRAY
59070: PUSH
59071: LD_INT 0
59073: DIFF
59074: PPUSH
59075: CALL_OW 1
59079: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
59080: LD_ADDR_EXP 62
59084: PUSH
59085: LD_EXP 62
59089: PPUSH
59090: LD_VAR 0 2
59094: PPUSH
59095: EMPTY
59096: PPUSH
59097: CALL_OW 1
59101: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59102: LD_ADDR_EXP 63
59106: PUSH
59107: LD_EXP 63
59111: PPUSH
59112: LD_VAR 0 2
59116: PPUSH
59117: EMPTY
59118: PPUSH
59119: CALL_OW 1
59123: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
59124: LD_ADDR_EXP 64
59128: PUSH
59129: LD_EXP 64
59133: PPUSH
59134: LD_VAR 0 2
59138: PPUSH
59139: EMPTY
59140: PPUSH
59141: CALL_OW 1
59145: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
59146: LD_ADDR_EXP 65
59150: PUSH
59151: LD_EXP 65
59155: PPUSH
59156: LD_VAR 0 2
59160: PPUSH
59161: EMPTY
59162: PUSH
59163: EMPTY
59164: PUSH
59165: EMPTY
59166: LIST
59167: LIST
59168: PPUSH
59169: CALL_OW 1
59173: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
59174: LD_ADDR_EXP 66
59178: PUSH
59179: LD_EXP 66
59183: PPUSH
59184: LD_VAR 0 2
59188: PPUSH
59189: EMPTY
59190: PPUSH
59191: CALL_OW 1
59195: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
59196: LD_ADDR_EXP 93
59200: PUSH
59201: LD_EXP 93
59205: PPUSH
59206: LD_VAR 0 2
59210: PPUSH
59211: EMPTY
59212: PPUSH
59213: CALL_OW 1
59217: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
59218: LD_ADDR_EXP 67
59222: PUSH
59223: LD_EXP 67
59227: PPUSH
59228: LD_VAR 0 2
59232: PPUSH
59233: EMPTY
59234: PPUSH
59235: CALL_OW 1
59239: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
59240: LD_ADDR_EXP 68
59244: PUSH
59245: LD_EXP 68
59249: PPUSH
59250: LD_VAR 0 2
59254: PPUSH
59255: EMPTY
59256: PPUSH
59257: CALL_OW 1
59261: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
59262: LD_ADDR_EXP 69
59266: PUSH
59267: LD_EXP 69
59271: PPUSH
59272: LD_VAR 0 2
59276: PPUSH
59277: LD_EXP 61
59281: PUSH
59282: LD_VAR 0 2
59286: ARRAY
59287: PPUSH
59288: LD_INT 2
59290: PUSH
59291: LD_INT 30
59293: PUSH
59294: LD_INT 32
59296: PUSH
59297: EMPTY
59298: LIST
59299: LIST
59300: PUSH
59301: LD_INT 30
59303: PUSH
59304: LD_INT 33
59306: PUSH
59307: EMPTY
59308: LIST
59309: LIST
59310: PUSH
59311: EMPTY
59312: LIST
59313: LIST
59314: LIST
59315: PPUSH
59316: CALL_OW 72
59320: PPUSH
59321: CALL_OW 1
59325: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
59326: LD_ADDR_EXP 70
59330: PUSH
59331: LD_EXP 70
59335: PPUSH
59336: LD_VAR 0 2
59340: PPUSH
59341: LD_EXP 61
59345: PUSH
59346: LD_VAR 0 2
59350: ARRAY
59351: PPUSH
59352: LD_INT 2
59354: PUSH
59355: LD_INT 30
59357: PUSH
59358: LD_INT 32
59360: PUSH
59361: EMPTY
59362: LIST
59363: LIST
59364: PUSH
59365: LD_INT 30
59367: PUSH
59368: LD_INT 31
59370: PUSH
59371: EMPTY
59372: LIST
59373: LIST
59374: PUSH
59375: EMPTY
59376: LIST
59377: LIST
59378: LIST
59379: PUSH
59380: LD_INT 58
59382: PUSH
59383: EMPTY
59384: LIST
59385: PUSH
59386: EMPTY
59387: LIST
59388: LIST
59389: PPUSH
59390: CALL_OW 72
59394: PPUSH
59395: CALL_OW 1
59399: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
59400: LD_ADDR_EXP 71
59404: PUSH
59405: LD_EXP 71
59409: PPUSH
59410: LD_VAR 0 2
59414: PPUSH
59415: EMPTY
59416: PPUSH
59417: CALL_OW 1
59421: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
59422: LD_ADDR_EXP 75
59426: PUSH
59427: LD_EXP 75
59431: PPUSH
59432: LD_VAR 0 2
59436: PPUSH
59437: EMPTY
59438: PPUSH
59439: CALL_OW 1
59443: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
59444: LD_ADDR_EXP 74
59448: PUSH
59449: LD_EXP 74
59453: PPUSH
59454: LD_VAR 0 2
59458: PPUSH
59459: EMPTY
59460: PPUSH
59461: CALL_OW 1
59465: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
59466: LD_ADDR_EXP 76
59470: PUSH
59471: LD_EXP 76
59475: PPUSH
59476: LD_VAR 0 2
59480: PPUSH
59481: EMPTY
59482: PPUSH
59483: CALL_OW 1
59487: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
59488: LD_ADDR_EXP 77
59492: PUSH
59493: LD_EXP 77
59497: PPUSH
59498: LD_VAR 0 2
59502: PPUSH
59503: EMPTY
59504: PPUSH
59505: CALL_OW 1
59509: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
59510: LD_ADDR_EXP 78
59514: PUSH
59515: LD_EXP 78
59519: PPUSH
59520: LD_VAR 0 2
59524: PPUSH
59525: EMPTY
59526: PPUSH
59527: CALL_OW 1
59531: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
59532: LD_ADDR_EXP 79
59536: PUSH
59537: LD_EXP 79
59541: PPUSH
59542: LD_VAR 0 2
59546: PPUSH
59547: EMPTY
59548: PPUSH
59549: CALL_OW 1
59553: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
59554: LD_ADDR_EXP 80
59558: PUSH
59559: LD_EXP 80
59563: PPUSH
59564: LD_VAR 0 2
59568: PPUSH
59569: EMPTY
59570: PPUSH
59571: CALL_OW 1
59575: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
59576: LD_ADDR_EXP 81
59580: PUSH
59581: LD_EXP 81
59585: PPUSH
59586: LD_VAR 0 2
59590: PPUSH
59591: EMPTY
59592: PPUSH
59593: CALL_OW 1
59597: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
59598: LD_ADDR_EXP 82
59602: PUSH
59603: LD_EXP 82
59607: PPUSH
59608: LD_VAR 0 2
59612: PPUSH
59613: EMPTY
59614: PPUSH
59615: CALL_OW 1
59619: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
59620: LD_ADDR_EXP 83
59624: PUSH
59625: LD_EXP 83
59629: PPUSH
59630: LD_VAR 0 2
59634: PPUSH
59635: EMPTY
59636: PPUSH
59637: CALL_OW 1
59641: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
59642: LD_ADDR_EXP 72
59646: PUSH
59647: LD_EXP 72
59651: PPUSH
59652: LD_VAR 0 2
59656: PPUSH
59657: LD_INT 0
59659: PPUSH
59660: CALL_OW 1
59664: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
59665: LD_ADDR_EXP 85
59669: PUSH
59670: LD_EXP 85
59674: PPUSH
59675: LD_VAR 0 2
59679: PPUSH
59680: LD_INT 0
59682: PPUSH
59683: CALL_OW 1
59687: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59688: LD_ADDR_EXP 73
59692: PUSH
59693: LD_EXP 73
59697: PPUSH
59698: LD_VAR 0 2
59702: PPUSH
59703: EMPTY
59704: PPUSH
59705: CALL_OW 1
59709: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
59710: LD_ADDR_EXP 84
59714: PUSH
59715: LD_EXP 84
59719: PPUSH
59720: LD_VAR 0 2
59724: PPUSH
59725: LD_INT 0
59727: PPUSH
59728: CALL_OW 1
59732: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
59733: LD_ADDR_EXP 86
59737: PUSH
59738: LD_EXP 86
59742: PPUSH
59743: LD_VAR 0 2
59747: PPUSH
59748: EMPTY
59749: PPUSH
59750: CALL_OW 1
59754: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
59755: LD_ADDR_EXP 89
59759: PUSH
59760: LD_EXP 89
59764: PPUSH
59765: LD_VAR 0 2
59769: PPUSH
59770: LD_INT 0
59772: PPUSH
59773: CALL_OW 1
59777: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
59778: LD_ADDR_EXP 90
59782: PUSH
59783: LD_EXP 90
59787: PPUSH
59788: LD_VAR 0 2
59792: PPUSH
59793: EMPTY
59794: PPUSH
59795: CALL_OW 1
59799: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
59800: LD_ADDR_EXP 91
59804: PUSH
59805: LD_EXP 91
59809: PPUSH
59810: LD_VAR 0 2
59814: PPUSH
59815: EMPTY
59816: PPUSH
59817: CALL_OW 1
59821: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59822: LD_ADDR_EXP 92
59826: PUSH
59827: LD_EXP 92
59831: PPUSH
59832: LD_VAR 0 2
59836: PPUSH
59837: EMPTY
59838: PPUSH
59839: CALL_OW 1
59843: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
59844: LD_ADDR_EXP 94
59848: PUSH
59849: LD_EXP 94
59853: PPUSH
59854: LD_VAR 0 2
59858: PPUSH
59859: LD_EXP 61
59863: PUSH
59864: LD_VAR 0 2
59868: ARRAY
59869: PPUSH
59870: LD_INT 2
59872: PUSH
59873: LD_INT 30
59875: PUSH
59876: LD_INT 6
59878: PUSH
59879: EMPTY
59880: LIST
59881: LIST
59882: PUSH
59883: LD_INT 30
59885: PUSH
59886: LD_INT 7
59888: PUSH
59889: EMPTY
59890: LIST
59891: LIST
59892: PUSH
59893: LD_INT 30
59895: PUSH
59896: LD_INT 8
59898: PUSH
59899: EMPTY
59900: LIST
59901: LIST
59902: PUSH
59903: EMPTY
59904: LIST
59905: LIST
59906: LIST
59907: LIST
59908: PPUSH
59909: CALL_OW 72
59913: PPUSH
59914: CALL_OW 1
59918: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
59919: LD_ADDR_EXP 95
59923: PUSH
59924: LD_EXP 95
59928: PPUSH
59929: LD_VAR 0 2
59933: PPUSH
59934: EMPTY
59935: PPUSH
59936: CALL_OW 1
59940: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
59941: LD_ADDR_EXP 96
59945: PUSH
59946: LD_EXP 96
59950: PPUSH
59951: LD_VAR 0 2
59955: PPUSH
59956: EMPTY
59957: PPUSH
59958: CALL_OW 1
59962: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
59963: LD_ADDR_EXP 97
59967: PUSH
59968: LD_EXP 97
59972: PPUSH
59973: LD_VAR 0 2
59977: PPUSH
59978: EMPTY
59979: PPUSH
59980: CALL_OW 1
59984: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
59985: LD_ADDR_EXP 98
59989: PUSH
59990: LD_EXP 98
59994: PPUSH
59995: LD_VAR 0 2
59999: PPUSH
60000: EMPTY
60001: PPUSH
60002: CALL_OW 1
60006: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60007: LD_ADDR_EXP 99
60011: PUSH
60012: LD_EXP 99
60016: PPUSH
60017: LD_VAR 0 2
60021: PPUSH
60022: EMPTY
60023: PPUSH
60024: CALL_OW 1
60028: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
60029: LD_ADDR_EXP 100
60033: PUSH
60034: LD_EXP 100
60038: PPUSH
60039: LD_VAR 0 2
60043: PPUSH
60044: EMPTY
60045: PPUSH
60046: CALL_OW 1
60050: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
60051: LD_ADDR_EXP 101
60055: PUSH
60056: LD_EXP 101
60060: PPUSH
60061: LD_VAR 0 2
60065: PPUSH
60066: EMPTY
60067: PPUSH
60068: CALL_OW 1
60072: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
60073: LD_ADDR_EXP 102
60077: PUSH
60078: LD_EXP 102
60082: PPUSH
60083: LD_VAR 0 2
60087: PPUSH
60088: EMPTY
60089: PPUSH
60090: CALL_OW 1
60094: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
60095: LD_ADDR_EXP 103
60099: PUSH
60100: LD_EXP 103
60104: PPUSH
60105: LD_VAR 0 2
60109: PPUSH
60110: LD_INT 0
60112: PPUSH
60113: CALL_OW 1
60117: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
60118: LD_ADDR_EXP 104
60122: PUSH
60123: LD_EXP 104
60127: PPUSH
60128: LD_VAR 0 2
60132: PPUSH
60133: LD_INT 0
60135: PPUSH
60136: CALL_OW 1
60140: ST_TO_ADDR
// end ;
60141: GO 59042
60143: POP
60144: POP
// MC_InitSides ( ) ;
60145: CALL 60431 0 0
// MC_InitResearch ( ) ;
60149: CALL 60170 0 0
// CustomInitMacro ( ) ;
60153: CALL 219 0 0
// skirmish := true ;
60157: LD_ADDR_EXP 59
60161: PUSH
60162: LD_INT 1
60164: ST_TO_ADDR
// end ;
60165: LD_VAR 0 1
60169: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
60170: LD_INT 0
60172: PPUSH
60173: PPUSH
60174: PPUSH
60175: PPUSH
60176: PPUSH
60177: PPUSH
// if not mc_bases then
60178: LD_EXP 61
60182: NOT
60183: IFFALSE 60187
// exit ;
60185: GO 60426
// for i = 1 to 8 do
60187: LD_ADDR_VAR 0 2
60191: PUSH
60192: DOUBLE
60193: LD_INT 1
60195: DEC
60196: ST_TO_ADDR
60197: LD_INT 8
60199: PUSH
60200: FOR_TO
60201: IFFALSE 60227
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
60203: LD_ADDR_EXP 88
60207: PUSH
60208: LD_EXP 88
60212: PPUSH
60213: LD_VAR 0 2
60217: PPUSH
60218: EMPTY
60219: PPUSH
60220: CALL_OW 1
60224: ST_TO_ADDR
60225: GO 60200
60227: POP
60228: POP
// tmp := [ ] ;
60229: LD_ADDR_VAR 0 5
60233: PUSH
60234: EMPTY
60235: ST_TO_ADDR
// for i = 1 to mc_sides do
60236: LD_ADDR_VAR 0 2
60240: PUSH
60241: DOUBLE
60242: LD_INT 1
60244: DEC
60245: ST_TO_ADDR
60246: LD_EXP 87
60250: PUSH
60251: FOR_TO
60252: IFFALSE 60310
// if not mc_sides [ i ] in tmp then
60254: LD_EXP 87
60258: PUSH
60259: LD_VAR 0 2
60263: ARRAY
60264: PUSH
60265: LD_VAR 0 5
60269: IN
60270: NOT
60271: IFFALSE 60308
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
60273: LD_ADDR_VAR 0 5
60277: PUSH
60278: LD_VAR 0 5
60282: PPUSH
60283: LD_VAR 0 5
60287: PUSH
60288: LD_INT 1
60290: PLUS
60291: PPUSH
60292: LD_EXP 87
60296: PUSH
60297: LD_VAR 0 2
60301: ARRAY
60302: PPUSH
60303: CALL_OW 2
60307: ST_TO_ADDR
60308: GO 60251
60310: POP
60311: POP
// if not tmp then
60312: LD_VAR 0 5
60316: NOT
60317: IFFALSE 60321
// exit ;
60319: GO 60426
// for j in tmp do
60321: LD_ADDR_VAR 0 3
60325: PUSH
60326: LD_VAR 0 5
60330: PUSH
60331: FOR_IN
60332: IFFALSE 60424
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
60334: LD_ADDR_VAR 0 6
60338: PUSH
60339: LD_INT 22
60341: PUSH
60342: LD_VAR 0 3
60346: PUSH
60347: EMPTY
60348: LIST
60349: LIST
60350: PPUSH
60351: CALL_OW 69
60355: ST_TO_ADDR
// if not un then
60356: LD_VAR 0 6
60360: NOT
60361: IFFALSE 60365
// continue ;
60363: GO 60331
// nation := GetNation ( un [ 1 ] ) ;
60365: LD_ADDR_VAR 0 4
60369: PUSH
60370: LD_VAR 0 6
60374: PUSH
60375: LD_INT 1
60377: ARRAY
60378: PPUSH
60379: CALL_OW 248
60383: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
60384: LD_ADDR_EXP 88
60388: PUSH
60389: LD_EXP 88
60393: PPUSH
60394: LD_VAR 0 3
60398: PPUSH
60399: LD_VAR 0 3
60403: PPUSH
60404: LD_VAR 0 4
60408: PPUSH
60409: LD_INT 1
60411: PPUSH
60412: CALL 15542 0 3
60416: PPUSH
60417: CALL_OW 1
60421: ST_TO_ADDR
// end ;
60422: GO 60331
60424: POP
60425: POP
// end ;
60426: LD_VAR 0 1
60430: RET
// export function MC_InitSides ( ) ; var i ; begin
60431: LD_INT 0
60433: PPUSH
60434: PPUSH
// if not mc_bases then
60435: LD_EXP 61
60439: NOT
60440: IFFALSE 60444
// exit ;
60442: GO 60518
// for i = 1 to mc_bases do
60444: LD_ADDR_VAR 0 2
60448: PUSH
60449: DOUBLE
60450: LD_INT 1
60452: DEC
60453: ST_TO_ADDR
60454: LD_EXP 61
60458: PUSH
60459: FOR_TO
60460: IFFALSE 60516
// if mc_bases [ i ] then
60462: LD_EXP 61
60466: PUSH
60467: LD_VAR 0 2
60471: ARRAY
60472: IFFALSE 60514
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
60474: LD_ADDR_EXP 87
60478: PUSH
60479: LD_EXP 87
60483: PPUSH
60484: LD_VAR 0 2
60488: PPUSH
60489: LD_EXP 61
60493: PUSH
60494: LD_VAR 0 2
60498: ARRAY
60499: PUSH
60500: LD_INT 1
60502: ARRAY
60503: PPUSH
60504: CALL_OW 255
60508: PPUSH
60509: CALL_OW 1
60513: ST_TO_ADDR
60514: GO 60459
60516: POP
60517: POP
// end ;
60518: LD_VAR 0 1
60522: RET
// every 0 0$03 trigger skirmish do
60523: LD_EXP 59
60527: IFFALSE 60681
60529: GO 60531
60531: DISABLE
// begin enable ;
60532: ENABLE
// MC_CheckBuildings ( ) ;
60533: CALL 65179 0 0
// MC_CheckPeopleLife ( ) ;
60537: CALL 65340 0 0
// RaiseSailEvent ( 100 ) ;
60541: LD_INT 100
60543: PPUSH
60544: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
60548: LD_INT 103
60550: PPUSH
60551: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
60555: LD_INT 104
60557: PPUSH
60558: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
60562: LD_INT 105
60564: PPUSH
60565: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
60569: LD_INT 106
60571: PPUSH
60572: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
60576: LD_INT 107
60578: PPUSH
60579: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
60583: LD_INT 108
60585: PPUSH
60586: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
60590: LD_INT 109
60592: PPUSH
60593: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
60597: LD_INT 110
60599: PPUSH
60600: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
60604: LD_INT 111
60606: PPUSH
60607: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
60611: LD_INT 112
60613: PPUSH
60614: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
60618: LD_INT 113
60620: PPUSH
60621: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
60625: LD_INT 120
60627: PPUSH
60628: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
60632: LD_INT 121
60634: PPUSH
60635: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
60639: LD_INT 122
60641: PPUSH
60642: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
60646: LD_INT 123
60648: PPUSH
60649: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
60653: LD_INT 124
60655: PPUSH
60656: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
60660: LD_INT 125
60662: PPUSH
60663: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
60667: LD_INT 126
60669: PPUSH
60670: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
60674: LD_INT 200
60676: PPUSH
60677: CALL_OW 427
// end ;
60681: END
// on SailEvent ( event ) do begin if event < 100 then
60682: LD_VAR 0 1
60686: PUSH
60687: LD_INT 100
60689: LESS
60690: IFFALSE 60701
// CustomEvent ( event ) ;
60692: LD_VAR 0 1
60696: PPUSH
60697: CALL 14157 0 1
// if event = 100 then
60701: LD_VAR 0 1
60705: PUSH
60706: LD_INT 100
60708: EQUAL
60709: IFFALSE 60715
// MC_ClassManager ( ) ;
60711: CALL 61107 0 0
// if event = 101 then
60715: LD_VAR 0 1
60719: PUSH
60720: LD_INT 101
60722: EQUAL
60723: IFFALSE 60729
// MC_RepairBuildings ( ) ;
60725: CALL 65925 0 0
// if event = 102 then
60729: LD_VAR 0 1
60733: PUSH
60734: LD_INT 102
60736: EQUAL
60737: IFFALSE 60743
// MC_Heal ( ) ;
60739: CALL 66860 0 0
// if event = 103 then
60743: LD_VAR 0 1
60747: PUSH
60748: LD_INT 103
60750: EQUAL
60751: IFFALSE 60757
// MC_Build ( ) ;
60753: CALL 67282 0 0
// if event = 104 then
60757: LD_VAR 0 1
60761: PUSH
60762: LD_INT 104
60764: EQUAL
60765: IFFALSE 60771
// MC_TurretWeapon ( ) ;
60767: CALL 68916 0 0
// if event = 105 then
60771: LD_VAR 0 1
60775: PUSH
60776: LD_INT 105
60778: EQUAL
60779: IFFALSE 60785
// MC_BuildUpgrade ( ) ;
60781: CALL 68467 0 0
// if event = 106 then
60785: LD_VAR 0 1
60789: PUSH
60790: LD_INT 106
60792: EQUAL
60793: IFFALSE 60799
// MC_PlantMines ( ) ;
60795: CALL 69346 0 0
// if event = 107 then
60799: LD_VAR 0 1
60803: PUSH
60804: LD_INT 107
60806: EQUAL
60807: IFFALSE 60813
// MC_CollectCrates ( ) ;
60809: CALL 70144 0 0
// if event = 108 then
60813: LD_VAR 0 1
60817: PUSH
60818: LD_INT 108
60820: EQUAL
60821: IFFALSE 60827
// MC_LinkRemoteControl ( ) ;
60823: CALL 71994 0 0
// if event = 109 then
60827: LD_VAR 0 1
60831: PUSH
60832: LD_INT 109
60834: EQUAL
60835: IFFALSE 60841
// MC_ProduceVehicle ( ) ;
60837: CALL 72175 0 0
// if event = 110 then
60841: LD_VAR 0 1
60845: PUSH
60846: LD_INT 110
60848: EQUAL
60849: IFFALSE 60855
// MC_SendAttack ( ) ;
60851: CALL 72641 0 0
// if event = 111 then
60855: LD_VAR 0 1
60859: PUSH
60860: LD_INT 111
60862: EQUAL
60863: IFFALSE 60869
// MC_Defend ( ) ;
60865: CALL 72749 0 0
// if event = 112 then
60869: LD_VAR 0 1
60873: PUSH
60874: LD_INT 112
60876: EQUAL
60877: IFFALSE 60883
// MC_Research ( ) ;
60879: CALL 73629 0 0
// if event = 113 then
60883: LD_VAR 0 1
60887: PUSH
60888: LD_INT 113
60890: EQUAL
60891: IFFALSE 60897
// MC_MinesTrigger ( ) ;
60893: CALL 74743 0 0
// if event = 120 then
60897: LD_VAR 0 1
60901: PUSH
60902: LD_INT 120
60904: EQUAL
60905: IFFALSE 60911
// MC_RepairVehicle ( ) ;
60907: CALL 74842 0 0
// if event = 121 then
60911: LD_VAR 0 1
60915: PUSH
60916: LD_INT 121
60918: EQUAL
60919: IFFALSE 60925
// MC_TameApe ( ) ;
60921: CALL 75611 0 0
// if event = 122 then
60925: LD_VAR 0 1
60929: PUSH
60930: LD_INT 122
60932: EQUAL
60933: IFFALSE 60939
// MC_ChangeApeClass ( ) ;
60935: CALL 76440 0 0
// if event = 123 then
60939: LD_VAR 0 1
60943: PUSH
60944: LD_INT 123
60946: EQUAL
60947: IFFALSE 60953
// MC_Bazooka ( ) ;
60949: CALL 77090 0 0
// if event = 124 then
60953: LD_VAR 0 1
60957: PUSH
60958: LD_INT 124
60960: EQUAL
60961: IFFALSE 60967
// MC_TeleportExit ( ) ;
60963: CALL 77288 0 0
// if event = 125 then
60967: LD_VAR 0 1
60971: PUSH
60972: LD_INT 125
60974: EQUAL
60975: IFFALSE 60981
// MC_Deposits ( ) ;
60977: CALL 77935 0 0
// if event = 126 then
60981: LD_VAR 0 1
60985: PUSH
60986: LD_INT 126
60988: EQUAL
60989: IFFALSE 60995
// MC_RemoteDriver ( ) ;
60991: CALL 78560 0 0
// if event = 200 then
60995: LD_VAR 0 1
60999: PUSH
61000: LD_INT 200
61002: EQUAL
61003: IFFALSE 61009
// MC_Idle ( ) ;
61005: CALL 80467 0 0
// end ;
61009: PPOPN 1
61011: END
// export function MC_Reset ( base , tag ) ; var i ; begin
61012: LD_INT 0
61014: PPUSH
61015: PPUSH
// if not mc_bases [ base ] or not tag then
61016: LD_EXP 61
61020: PUSH
61021: LD_VAR 0 1
61025: ARRAY
61026: NOT
61027: PUSH
61028: LD_VAR 0 2
61032: NOT
61033: OR
61034: IFFALSE 61038
// exit ;
61036: GO 61102
// for i in mc_bases [ base ] union mc_ape [ base ] do
61038: LD_ADDR_VAR 0 4
61042: PUSH
61043: LD_EXP 61
61047: PUSH
61048: LD_VAR 0 1
61052: ARRAY
61053: PUSH
61054: LD_EXP 90
61058: PUSH
61059: LD_VAR 0 1
61063: ARRAY
61064: UNION
61065: PUSH
61066: FOR_IN
61067: IFFALSE 61100
// if GetTag ( i ) = tag then
61069: LD_VAR 0 4
61073: PPUSH
61074: CALL_OW 110
61078: PUSH
61079: LD_VAR 0 2
61083: EQUAL
61084: IFFALSE 61098
// SetTag ( i , 0 ) ;
61086: LD_VAR 0 4
61090: PPUSH
61091: LD_INT 0
61093: PPUSH
61094: CALL_OW 109
61098: GO 61066
61100: POP
61101: POP
// end ;
61102: LD_VAR 0 3
61106: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
61107: LD_INT 0
61109: PPUSH
61110: PPUSH
61111: PPUSH
61112: PPUSH
61113: PPUSH
61114: PPUSH
61115: PPUSH
61116: PPUSH
// if not mc_bases then
61117: LD_EXP 61
61121: NOT
61122: IFFALSE 61126
// exit ;
61124: GO 61584
// for i = 1 to mc_bases do
61126: LD_ADDR_VAR 0 2
61130: PUSH
61131: DOUBLE
61132: LD_INT 1
61134: DEC
61135: ST_TO_ADDR
61136: LD_EXP 61
61140: PUSH
61141: FOR_TO
61142: IFFALSE 61582
// begin tmp := MC_ClassCheckReq ( i ) ;
61144: LD_ADDR_VAR 0 4
61148: PUSH
61149: LD_VAR 0 2
61153: PPUSH
61154: CALL 61589 0 1
61158: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
61159: LD_ADDR_EXP 102
61163: PUSH
61164: LD_EXP 102
61168: PPUSH
61169: LD_VAR 0 2
61173: PPUSH
61174: LD_VAR 0 4
61178: PPUSH
61179: CALL_OW 1
61183: ST_TO_ADDR
// if not tmp then
61184: LD_VAR 0 4
61188: NOT
61189: IFFALSE 61193
// continue ;
61191: GO 61141
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
61193: LD_ADDR_VAR 0 6
61197: PUSH
61198: LD_EXP 61
61202: PUSH
61203: LD_VAR 0 2
61207: ARRAY
61208: PPUSH
61209: LD_INT 2
61211: PUSH
61212: LD_INT 30
61214: PUSH
61215: LD_INT 4
61217: PUSH
61218: EMPTY
61219: LIST
61220: LIST
61221: PUSH
61222: LD_INT 30
61224: PUSH
61225: LD_INT 5
61227: PUSH
61228: EMPTY
61229: LIST
61230: LIST
61231: PUSH
61232: EMPTY
61233: LIST
61234: LIST
61235: LIST
61236: PPUSH
61237: CALL_OW 72
61241: PUSH
61242: LD_EXP 61
61246: PUSH
61247: LD_VAR 0 2
61251: ARRAY
61252: PPUSH
61253: LD_INT 2
61255: PUSH
61256: LD_INT 30
61258: PUSH
61259: LD_INT 0
61261: PUSH
61262: EMPTY
61263: LIST
61264: LIST
61265: PUSH
61266: LD_INT 30
61268: PUSH
61269: LD_INT 1
61271: PUSH
61272: EMPTY
61273: LIST
61274: LIST
61275: PUSH
61276: EMPTY
61277: LIST
61278: LIST
61279: LIST
61280: PPUSH
61281: CALL_OW 72
61285: PUSH
61286: LD_EXP 61
61290: PUSH
61291: LD_VAR 0 2
61295: ARRAY
61296: PPUSH
61297: LD_INT 30
61299: PUSH
61300: LD_INT 3
61302: PUSH
61303: EMPTY
61304: LIST
61305: LIST
61306: PPUSH
61307: CALL_OW 72
61311: PUSH
61312: LD_EXP 61
61316: PUSH
61317: LD_VAR 0 2
61321: ARRAY
61322: PPUSH
61323: LD_INT 2
61325: PUSH
61326: LD_INT 30
61328: PUSH
61329: LD_INT 6
61331: PUSH
61332: EMPTY
61333: LIST
61334: LIST
61335: PUSH
61336: LD_INT 30
61338: PUSH
61339: LD_INT 7
61341: PUSH
61342: EMPTY
61343: LIST
61344: LIST
61345: PUSH
61346: LD_INT 30
61348: PUSH
61349: LD_INT 8
61351: PUSH
61352: EMPTY
61353: LIST
61354: LIST
61355: PUSH
61356: EMPTY
61357: LIST
61358: LIST
61359: LIST
61360: LIST
61361: PPUSH
61362: CALL_OW 72
61366: PUSH
61367: EMPTY
61368: LIST
61369: LIST
61370: LIST
61371: LIST
61372: ST_TO_ADDR
// for j = 1 to 4 do
61373: LD_ADDR_VAR 0 3
61377: PUSH
61378: DOUBLE
61379: LD_INT 1
61381: DEC
61382: ST_TO_ADDR
61383: LD_INT 4
61385: PUSH
61386: FOR_TO
61387: IFFALSE 61578
// begin if not tmp [ j ] then
61389: LD_VAR 0 4
61393: PUSH
61394: LD_VAR 0 3
61398: ARRAY
61399: NOT
61400: IFFALSE 61404
// continue ;
61402: GO 61386
// for p in tmp [ j ] do
61404: LD_ADDR_VAR 0 5
61408: PUSH
61409: LD_VAR 0 4
61413: PUSH
61414: LD_VAR 0 3
61418: ARRAY
61419: PUSH
61420: FOR_IN
61421: IFFALSE 61574
// begin if not b [ j ] then
61423: LD_VAR 0 6
61427: PUSH
61428: LD_VAR 0 3
61432: ARRAY
61433: NOT
61434: IFFALSE 61438
// break ;
61436: GO 61574
// e := 0 ;
61438: LD_ADDR_VAR 0 7
61442: PUSH
61443: LD_INT 0
61445: ST_TO_ADDR
// for k in b [ j ] do
61446: LD_ADDR_VAR 0 8
61450: PUSH
61451: LD_VAR 0 6
61455: PUSH
61456: LD_VAR 0 3
61460: ARRAY
61461: PUSH
61462: FOR_IN
61463: IFFALSE 61490
// if IsNotFull ( k ) then
61465: LD_VAR 0 8
61469: PPUSH
61470: CALL 17663 0 1
61474: IFFALSE 61488
// begin e := k ;
61476: LD_ADDR_VAR 0 7
61480: PUSH
61481: LD_VAR 0 8
61485: ST_TO_ADDR
// break ;
61486: GO 61490
// end ;
61488: GO 61462
61490: POP
61491: POP
// if e and not UnitGoingToBuilding ( p , e ) then
61492: LD_VAR 0 7
61496: PUSH
61497: LD_VAR 0 5
61501: PPUSH
61502: LD_VAR 0 7
61506: PPUSH
61507: CALL 51416 0 2
61511: NOT
61512: AND
61513: IFFALSE 61572
// begin if IsInUnit ( p ) then
61515: LD_VAR 0 5
61519: PPUSH
61520: CALL_OW 310
61524: IFFALSE 61535
// ComExitBuilding ( p ) ;
61526: LD_VAR 0 5
61530: PPUSH
61531: CALL_OW 122
// ComEnterUnit ( p , e ) ;
61535: LD_VAR 0 5
61539: PPUSH
61540: LD_VAR 0 7
61544: PPUSH
61545: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
61549: LD_VAR 0 5
61553: PPUSH
61554: LD_VAR 0 3
61558: PPUSH
61559: CALL_OW 183
// AddComExitBuilding ( p ) ;
61563: LD_VAR 0 5
61567: PPUSH
61568: CALL_OW 182
// end ; end ;
61572: GO 61420
61574: POP
61575: POP
// end ;
61576: GO 61386
61578: POP
61579: POP
// end ;
61580: GO 61141
61582: POP
61583: POP
// end ;
61584: LD_VAR 0 1
61588: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
61589: LD_INT 0
61591: PPUSH
61592: PPUSH
61593: PPUSH
61594: PPUSH
61595: PPUSH
61596: PPUSH
61597: PPUSH
61598: PPUSH
61599: PPUSH
61600: PPUSH
61601: PPUSH
61602: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61603: LD_VAR 0 1
61607: NOT
61608: PUSH
61609: LD_EXP 61
61613: PUSH
61614: LD_VAR 0 1
61618: ARRAY
61619: NOT
61620: OR
61621: PUSH
61622: LD_EXP 61
61626: PUSH
61627: LD_VAR 0 1
61631: ARRAY
61632: PPUSH
61633: LD_INT 2
61635: PUSH
61636: LD_INT 30
61638: PUSH
61639: LD_INT 0
61641: PUSH
61642: EMPTY
61643: LIST
61644: LIST
61645: PUSH
61646: LD_INT 30
61648: PUSH
61649: LD_INT 1
61651: PUSH
61652: EMPTY
61653: LIST
61654: LIST
61655: PUSH
61656: EMPTY
61657: LIST
61658: LIST
61659: LIST
61660: PPUSH
61661: CALL_OW 72
61665: NOT
61666: OR
61667: IFFALSE 61671
// exit ;
61669: GO 65174
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61671: LD_ADDR_VAR 0 4
61675: PUSH
61676: LD_EXP 61
61680: PUSH
61681: LD_VAR 0 1
61685: ARRAY
61686: PPUSH
61687: LD_INT 2
61689: PUSH
61690: LD_INT 25
61692: PUSH
61693: LD_INT 1
61695: PUSH
61696: EMPTY
61697: LIST
61698: LIST
61699: PUSH
61700: LD_INT 25
61702: PUSH
61703: LD_INT 2
61705: PUSH
61706: EMPTY
61707: LIST
61708: LIST
61709: PUSH
61710: LD_INT 25
61712: PUSH
61713: LD_INT 3
61715: PUSH
61716: EMPTY
61717: LIST
61718: LIST
61719: PUSH
61720: LD_INT 25
61722: PUSH
61723: LD_INT 4
61725: PUSH
61726: EMPTY
61727: LIST
61728: LIST
61729: PUSH
61730: LD_INT 25
61732: PUSH
61733: LD_INT 5
61735: PUSH
61736: EMPTY
61737: LIST
61738: LIST
61739: PUSH
61740: LD_INT 25
61742: PUSH
61743: LD_INT 8
61745: PUSH
61746: EMPTY
61747: LIST
61748: LIST
61749: PUSH
61750: LD_INT 25
61752: PUSH
61753: LD_INT 9
61755: PUSH
61756: EMPTY
61757: LIST
61758: LIST
61759: PUSH
61760: EMPTY
61761: LIST
61762: LIST
61763: LIST
61764: LIST
61765: LIST
61766: LIST
61767: LIST
61768: LIST
61769: PPUSH
61770: CALL_OW 72
61774: ST_TO_ADDR
// if not tmp then
61775: LD_VAR 0 4
61779: NOT
61780: IFFALSE 61784
// exit ;
61782: GO 65174
// for i in tmp do
61784: LD_ADDR_VAR 0 3
61788: PUSH
61789: LD_VAR 0 4
61793: PUSH
61794: FOR_IN
61795: IFFALSE 61826
// if GetTag ( i ) then
61797: LD_VAR 0 3
61801: PPUSH
61802: CALL_OW 110
61806: IFFALSE 61824
// tmp := tmp diff i ;
61808: LD_ADDR_VAR 0 4
61812: PUSH
61813: LD_VAR 0 4
61817: PUSH
61818: LD_VAR 0 3
61822: DIFF
61823: ST_TO_ADDR
61824: GO 61794
61826: POP
61827: POP
// if not tmp then
61828: LD_VAR 0 4
61832: NOT
61833: IFFALSE 61837
// exit ;
61835: GO 65174
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61837: LD_ADDR_VAR 0 5
61841: PUSH
61842: LD_EXP 61
61846: PUSH
61847: LD_VAR 0 1
61851: ARRAY
61852: PPUSH
61853: LD_INT 2
61855: PUSH
61856: LD_INT 25
61858: PUSH
61859: LD_INT 1
61861: PUSH
61862: EMPTY
61863: LIST
61864: LIST
61865: PUSH
61866: LD_INT 25
61868: PUSH
61869: LD_INT 5
61871: PUSH
61872: EMPTY
61873: LIST
61874: LIST
61875: PUSH
61876: LD_INT 25
61878: PUSH
61879: LD_INT 8
61881: PUSH
61882: EMPTY
61883: LIST
61884: LIST
61885: PUSH
61886: LD_INT 25
61888: PUSH
61889: LD_INT 9
61891: PUSH
61892: EMPTY
61893: LIST
61894: LIST
61895: PUSH
61896: EMPTY
61897: LIST
61898: LIST
61899: LIST
61900: LIST
61901: LIST
61902: PPUSH
61903: CALL_OW 72
61907: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
61908: LD_ADDR_VAR 0 6
61912: PUSH
61913: LD_EXP 61
61917: PUSH
61918: LD_VAR 0 1
61922: ARRAY
61923: PPUSH
61924: LD_INT 25
61926: PUSH
61927: LD_INT 2
61929: PUSH
61930: EMPTY
61931: LIST
61932: LIST
61933: PPUSH
61934: CALL_OW 72
61938: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
61939: LD_ADDR_VAR 0 7
61943: PUSH
61944: LD_EXP 61
61948: PUSH
61949: LD_VAR 0 1
61953: ARRAY
61954: PPUSH
61955: LD_INT 25
61957: PUSH
61958: LD_INT 3
61960: PUSH
61961: EMPTY
61962: LIST
61963: LIST
61964: PPUSH
61965: CALL_OW 72
61969: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
61970: LD_ADDR_VAR 0 8
61974: PUSH
61975: LD_EXP 61
61979: PUSH
61980: LD_VAR 0 1
61984: ARRAY
61985: PPUSH
61986: LD_INT 25
61988: PUSH
61989: LD_INT 4
61991: PUSH
61992: EMPTY
61993: LIST
61994: LIST
61995: PUSH
61996: LD_INT 24
61998: PUSH
61999: LD_INT 251
62001: PUSH
62002: EMPTY
62003: LIST
62004: LIST
62005: PUSH
62006: EMPTY
62007: LIST
62008: LIST
62009: PPUSH
62010: CALL_OW 72
62014: ST_TO_ADDR
// if mc_is_defending [ base ] then
62015: LD_EXP 104
62019: PUSH
62020: LD_VAR 0 1
62024: ARRAY
62025: IFFALSE 62486
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
62027: LD_ADDR_EXP 103
62031: PUSH
62032: LD_EXP 103
62036: PPUSH
62037: LD_VAR 0 1
62041: PPUSH
62042: LD_INT 4
62044: PPUSH
62045: CALL_OW 1
62049: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62050: LD_ADDR_VAR 0 12
62054: PUSH
62055: LD_EXP 61
62059: PUSH
62060: LD_VAR 0 1
62064: ARRAY
62065: PPUSH
62066: LD_INT 2
62068: PUSH
62069: LD_INT 30
62071: PUSH
62072: LD_INT 4
62074: PUSH
62075: EMPTY
62076: LIST
62077: LIST
62078: PUSH
62079: LD_INT 30
62081: PUSH
62082: LD_INT 5
62084: PUSH
62085: EMPTY
62086: LIST
62087: LIST
62088: PUSH
62089: EMPTY
62090: LIST
62091: LIST
62092: LIST
62093: PPUSH
62094: CALL_OW 72
62098: ST_TO_ADDR
// if not b then
62099: LD_VAR 0 12
62103: NOT
62104: IFFALSE 62108
// exit ;
62106: GO 65174
// p := [ ] ;
62108: LD_ADDR_VAR 0 11
62112: PUSH
62113: EMPTY
62114: ST_TO_ADDR
// if sci >= 2 then
62115: LD_VAR 0 8
62119: PUSH
62120: LD_INT 2
62122: GREATEREQUAL
62123: IFFALSE 62154
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
62125: LD_ADDR_VAR 0 8
62129: PUSH
62130: LD_VAR 0 8
62134: PUSH
62135: LD_INT 1
62137: ARRAY
62138: PUSH
62139: LD_VAR 0 8
62143: PUSH
62144: LD_INT 2
62146: ARRAY
62147: PUSH
62148: EMPTY
62149: LIST
62150: LIST
62151: ST_TO_ADDR
62152: GO 62215
// if sci = 1 then
62154: LD_VAR 0 8
62158: PUSH
62159: LD_INT 1
62161: EQUAL
62162: IFFALSE 62183
// sci := [ sci [ 1 ] ] else
62164: LD_ADDR_VAR 0 8
62168: PUSH
62169: LD_VAR 0 8
62173: PUSH
62174: LD_INT 1
62176: ARRAY
62177: PUSH
62178: EMPTY
62179: LIST
62180: ST_TO_ADDR
62181: GO 62215
// if sci = 0 then
62183: LD_VAR 0 8
62187: PUSH
62188: LD_INT 0
62190: EQUAL
62191: IFFALSE 62215
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
62193: LD_ADDR_VAR 0 11
62197: PUSH
62198: LD_VAR 0 4
62202: PPUSH
62203: LD_INT 4
62205: PPUSH
62206: CALL 51288 0 2
62210: PUSH
62211: LD_INT 1
62213: ARRAY
62214: ST_TO_ADDR
// if eng > 4 then
62215: LD_VAR 0 6
62219: PUSH
62220: LD_INT 4
62222: GREATER
62223: IFFALSE 62269
// for i = eng downto 4 do
62225: LD_ADDR_VAR 0 3
62229: PUSH
62230: DOUBLE
62231: LD_VAR 0 6
62235: INC
62236: ST_TO_ADDR
62237: LD_INT 4
62239: PUSH
62240: FOR_DOWNTO
62241: IFFALSE 62267
// eng := eng diff eng [ i ] ;
62243: LD_ADDR_VAR 0 6
62247: PUSH
62248: LD_VAR 0 6
62252: PUSH
62253: LD_VAR 0 6
62257: PUSH
62258: LD_VAR 0 3
62262: ARRAY
62263: DIFF
62264: ST_TO_ADDR
62265: GO 62240
62267: POP
62268: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
62269: LD_ADDR_VAR 0 4
62273: PUSH
62274: LD_VAR 0 4
62278: PUSH
62279: LD_VAR 0 5
62283: PUSH
62284: LD_VAR 0 6
62288: UNION
62289: PUSH
62290: LD_VAR 0 7
62294: UNION
62295: PUSH
62296: LD_VAR 0 8
62300: UNION
62301: DIFF
62302: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
62303: LD_ADDR_VAR 0 13
62307: PUSH
62308: LD_EXP 61
62312: PUSH
62313: LD_VAR 0 1
62317: ARRAY
62318: PPUSH
62319: LD_INT 2
62321: PUSH
62322: LD_INT 30
62324: PUSH
62325: LD_INT 32
62327: PUSH
62328: EMPTY
62329: LIST
62330: LIST
62331: PUSH
62332: LD_INT 30
62334: PUSH
62335: LD_INT 31
62337: PUSH
62338: EMPTY
62339: LIST
62340: LIST
62341: PUSH
62342: EMPTY
62343: LIST
62344: LIST
62345: LIST
62346: PPUSH
62347: CALL_OW 72
62351: PUSH
62352: LD_EXP 61
62356: PUSH
62357: LD_VAR 0 1
62361: ARRAY
62362: PPUSH
62363: LD_INT 2
62365: PUSH
62366: LD_INT 30
62368: PUSH
62369: LD_INT 4
62371: PUSH
62372: EMPTY
62373: LIST
62374: LIST
62375: PUSH
62376: LD_INT 30
62378: PUSH
62379: LD_INT 5
62381: PUSH
62382: EMPTY
62383: LIST
62384: LIST
62385: PUSH
62386: EMPTY
62387: LIST
62388: LIST
62389: LIST
62390: PPUSH
62391: CALL_OW 72
62395: PUSH
62396: LD_INT 6
62398: MUL
62399: PLUS
62400: ST_TO_ADDR
// if bcount < tmp then
62401: LD_VAR 0 13
62405: PUSH
62406: LD_VAR 0 4
62410: LESS
62411: IFFALSE 62457
// for i = tmp downto bcount do
62413: LD_ADDR_VAR 0 3
62417: PUSH
62418: DOUBLE
62419: LD_VAR 0 4
62423: INC
62424: ST_TO_ADDR
62425: LD_VAR 0 13
62429: PUSH
62430: FOR_DOWNTO
62431: IFFALSE 62455
// tmp := Delete ( tmp , tmp ) ;
62433: LD_ADDR_VAR 0 4
62437: PUSH
62438: LD_VAR 0 4
62442: PPUSH
62443: LD_VAR 0 4
62447: PPUSH
62448: CALL_OW 3
62452: ST_TO_ADDR
62453: GO 62430
62455: POP
62456: POP
// result := [ tmp , 0 , 0 , p ] ;
62457: LD_ADDR_VAR 0 2
62461: PUSH
62462: LD_VAR 0 4
62466: PUSH
62467: LD_INT 0
62469: PUSH
62470: LD_INT 0
62472: PUSH
62473: LD_VAR 0 11
62477: PUSH
62478: EMPTY
62479: LIST
62480: LIST
62481: LIST
62482: LIST
62483: ST_TO_ADDR
// exit ;
62484: GO 65174
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62486: LD_EXP 61
62490: PUSH
62491: LD_VAR 0 1
62495: ARRAY
62496: PPUSH
62497: LD_INT 2
62499: PUSH
62500: LD_INT 30
62502: PUSH
62503: LD_INT 6
62505: PUSH
62506: EMPTY
62507: LIST
62508: LIST
62509: PUSH
62510: LD_INT 30
62512: PUSH
62513: LD_INT 7
62515: PUSH
62516: EMPTY
62517: LIST
62518: LIST
62519: PUSH
62520: LD_INT 30
62522: PUSH
62523: LD_INT 8
62525: PUSH
62526: EMPTY
62527: LIST
62528: LIST
62529: PUSH
62530: EMPTY
62531: LIST
62532: LIST
62533: LIST
62534: LIST
62535: PPUSH
62536: CALL_OW 72
62540: NOT
62541: PUSH
62542: LD_EXP 61
62546: PUSH
62547: LD_VAR 0 1
62551: ARRAY
62552: PPUSH
62553: LD_INT 30
62555: PUSH
62556: LD_INT 3
62558: PUSH
62559: EMPTY
62560: LIST
62561: LIST
62562: PPUSH
62563: CALL_OW 72
62567: NOT
62568: AND
62569: IFFALSE 62641
// begin if eng = tmp then
62571: LD_VAR 0 6
62575: PUSH
62576: LD_VAR 0 4
62580: EQUAL
62581: IFFALSE 62585
// exit ;
62583: GO 65174
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
62585: LD_ADDR_EXP 103
62589: PUSH
62590: LD_EXP 103
62594: PPUSH
62595: LD_VAR 0 1
62599: PPUSH
62600: LD_INT 1
62602: PPUSH
62603: CALL_OW 1
62607: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
62608: LD_ADDR_VAR 0 2
62612: PUSH
62613: LD_INT 0
62615: PUSH
62616: LD_VAR 0 4
62620: PUSH
62621: LD_VAR 0 6
62625: DIFF
62626: PUSH
62627: LD_INT 0
62629: PUSH
62630: LD_INT 0
62632: PUSH
62633: EMPTY
62634: LIST
62635: LIST
62636: LIST
62637: LIST
62638: ST_TO_ADDR
// exit ;
62639: GO 65174
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62641: LD_EXP 88
62645: PUSH
62646: LD_EXP 87
62650: PUSH
62651: LD_VAR 0 1
62655: ARRAY
62656: ARRAY
62657: PUSH
62658: LD_EXP 61
62662: PUSH
62663: LD_VAR 0 1
62667: ARRAY
62668: PPUSH
62669: LD_INT 2
62671: PUSH
62672: LD_INT 30
62674: PUSH
62675: LD_INT 6
62677: PUSH
62678: EMPTY
62679: LIST
62680: LIST
62681: PUSH
62682: LD_INT 30
62684: PUSH
62685: LD_INT 7
62687: PUSH
62688: EMPTY
62689: LIST
62690: LIST
62691: PUSH
62692: LD_INT 30
62694: PUSH
62695: LD_INT 8
62697: PUSH
62698: EMPTY
62699: LIST
62700: LIST
62701: PUSH
62702: EMPTY
62703: LIST
62704: LIST
62705: LIST
62706: LIST
62707: PPUSH
62708: CALL_OW 72
62712: AND
62713: PUSH
62714: LD_EXP 61
62718: PUSH
62719: LD_VAR 0 1
62723: ARRAY
62724: PPUSH
62725: LD_INT 30
62727: PUSH
62728: LD_INT 3
62730: PUSH
62731: EMPTY
62732: LIST
62733: LIST
62734: PPUSH
62735: CALL_OW 72
62739: NOT
62740: AND
62741: IFFALSE 62955
// begin if sci >= 6 then
62743: LD_VAR 0 8
62747: PUSH
62748: LD_INT 6
62750: GREATEREQUAL
62751: IFFALSE 62755
// exit ;
62753: GO 65174
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
62755: LD_ADDR_EXP 103
62759: PUSH
62760: LD_EXP 103
62764: PPUSH
62765: LD_VAR 0 1
62769: PPUSH
62770: LD_INT 2
62772: PPUSH
62773: CALL_OW 1
62777: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
62778: LD_ADDR_VAR 0 9
62782: PUSH
62783: LD_VAR 0 4
62787: PUSH
62788: LD_VAR 0 8
62792: DIFF
62793: PPUSH
62794: LD_INT 4
62796: PPUSH
62797: CALL 51288 0 2
62801: ST_TO_ADDR
// p := [ ] ;
62802: LD_ADDR_VAR 0 11
62806: PUSH
62807: EMPTY
62808: ST_TO_ADDR
// if sci < 6 and sort > 6 then
62809: LD_VAR 0 8
62813: PUSH
62814: LD_INT 6
62816: LESS
62817: PUSH
62818: LD_VAR 0 9
62822: PUSH
62823: LD_INT 6
62825: GREATER
62826: AND
62827: IFFALSE 62908
// begin for i = 1 to 6 - sci do
62829: LD_ADDR_VAR 0 3
62833: PUSH
62834: DOUBLE
62835: LD_INT 1
62837: DEC
62838: ST_TO_ADDR
62839: LD_INT 6
62841: PUSH
62842: LD_VAR 0 8
62846: MINUS
62847: PUSH
62848: FOR_TO
62849: IFFALSE 62904
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
62851: LD_ADDR_VAR 0 11
62855: PUSH
62856: LD_VAR 0 11
62860: PPUSH
62861: LD_VAR 0 11
62865: PUSH
62866: LD_INT 1
62868: PLUS
62869: PPUSH
62870: LD_VAR 0 9
62874: PUSH
62875: LD_INT 1
62877: ARRAY
62878: PPUSH
62879: CALL_OW 2
62883: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
62884: LD_ADDR_VAR 0 9
62888: PUSH
62889: LD_VAR 0 9
62893: PPUSH
62894: LD_INT 1
62896: PPUSH
62897: CALL_OW 3
62901: ST_TO_ADDR
// end ;
62902: GO 62848
62904: POP
62905: POP
// end else
62906: GO 62928
// if sort then
62908: LD_VAR 0 9
62912: IFFALSE 62928
// p := sort [ 1 ] ;
62914: LD_ADDR_VAR 0 11
62918: PUSH
62919: LD_VAR 0 9
62923: PUSH
62924: LD_INT 1
62926: ARRAY
62927: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
62928: LD_ADDR_VAR 0 2
62932: PUSH
62933: LD_INT 0
62935: PUSH
62936: LD_INT 0
62938: PUSH
62939: LD_INT 0
62941: PUSH
62942: LD_VAR 0 11
62946: PUSH
62947: EMPTY
62948: LIST
62949: LIST
62950: LIST
62951: LIST
62952: ST_TO_ADDR
// exit ;
62953: GO 65174
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62955: LD_EXP 88
62959: PUSH
62960: LD_EXP 87
62964: PUSH
62965: LD_VAR 0 1
62969: ARRAY
62970: ARRAY
62971: PUSH
62972: LD_EXP 61
62976: PUSH
62977: LD_VAR 0 1
62981: ARRAY
62982: PPUSH
62983: LD_INT 2
62985: PUSH
62986: LD_INT 30
62988: PUSH
62989: LD_INT 6
62991: PUSH
62992: EMPTY
62993: LIST
62994: LIST
62995: PUSH
62996: LD_INT 30
62998: PUSH
62999: LD_INT 7
63001: PUSH
63002: EMPTY
63003: LIST
63004: LIST
63005: PUSH
63006: LD_INT 30
63008: PUSH
63009: LD_INT 8
63011: PUSH
63012: EMPTY
63013: LIST
63014: LIST
63015: PUSH
63016: EMPTY
63017: LIST
63018: LIST
63019: LIST
63020: LIST
63021: PPUSH
63022: CALL_OW 72
63026: AND
63027: PUSH
63028: LD_EXP 61
63032: PUSH
63033: LD_VAR 0 1
63037: ARRAY
63038: PPUSH
63039: LD_INT 30
63041: PUSH
63042: LD_INT 3
63044: PUSH
63045: EMPTY
63046: LIST
63047: LIST
63048: PPUSH
63049: CALL_OW 72
63053: AND
63054: IFFALSE 63788
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
63056: LD_ADDR_EXP 103
63060: PUSH
63061: LD_EXP 103
63065: PPUSH
63066: LD_VAR 0 1
63070: PPUSH
63071: LD_INT 3
63073: PPUSH
63074: CALL_OW 1
63078: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63079: LD_ADDR_VAR 0 2
63083: PUSH
63084: LD_INT 0
63086: PUSH
63087: LD_INT 0
63089: PUSH
63090: LD_INT 0
63092: PUSH
63093: LD_INT 0
63095: PUSH
63096: EMPTY
63097: LIST
63098: LIST
63099: LIST
63100: LIST
63101: ST_TO_ADDR
// if not eng then
63102: LD_VAR 0 6
63106: NOT
63107: IFFALSE 63170
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
63109: LD_ADDR_VAR 0 11
63113: PUSH
63114: LD_VAR 0 4
63118: PPUSH
63119: LD_INT 2
63121: PPUSH
63122: CALL 51288 0 2
63126: PUSH
63127: LD_INT 1
63129: ARRAY
63130: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
63131: LD_ADDR_VAR 0 2
63135: PUSH
63136: LD_VAR 0 2
63140: PPUSH
63141: LD_INT 2
63143: PPUSH
63144: LD_VAR 0 11
63148: PPUSH
63149: CALL_OW 1
63153: ST_TO_ADDR
// tmp := tmp diff p ;
63154: LD_ADDR_VAR 0 4
63158: PUSH
63159: LD_VAR 0 4
63163: PUSH
63164: LD_VAR 0 11
63168: DIFF
63169: ST_TO_ADDR
// end ; if tmp and sci < 6 then
63170: LD_VAR 0 4
63174: PUSH
63175: LD_VAR 0 8
63179: PUSH
63180: LD_INT 6
63182: LESS
63183: AND
63184: IFFALSE 63372
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
63186: LD_ADDR_VAR 0 9
63190: PUSH
63191: LD_VAR 0 4
63195: PUSH
63196: LD_VAR 0 8
63200: PUSH
63201: LD_VAR 0 7
63205: UNION
63206: DIFF
63207: PPUSH
63208: LD_INT 4
63210: PPUSH
63211: CALL 51288 0 2
63215: ST_TO_ADDR
// p := [ ] ;
63216: LD_ADDR_VAR 0 11
63220: PUSH
63221: EMPTY
63222: ST_TO_ADDR
// if sort then
63223: LD_VAR 0 9
63227: IFFALSE 63343
// for i = 1 to 6 - sci do
63229: LD_ADDR_VAR 0 3
63233: PUSH
63234: DOUBLE
63235: LD_INT 1
63237: DEC
63238: ST_TO_ADDR
63239: LD_INT 6
63241: PUSH
63242: LD_VAR 0 8
63246: MINUS
63247: PUSH
63248: FOR_TO
63249: IFFALSE 63341
// begin if i = sort then
63251: LD_VAR 0 3
63255: PUSH
63256: LD_VAR 0 9
63260: EQUAL
63261: IFFALSE 63265
// break ;
63263: GO 63341
// if GetClass ( i ) = 4 then
63265: LD_VAR 0 3
63269: PPUSH
63270: CALL_OW 257
63274: PUSH
63275: LD_INT 4
63277: EQUAL
63278: IFFALSE 63282
// continue ;
63280: GO 63248
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63282: LD_ADDR_VAR 0 11
63286: PUSH
63287: LD_VAR 0 11
63291: PPUSH
63292: LD_VAR 0 11
63296: PUSH
63297: LD_INT 1
63299: PLUS
63300: PPUSH
63301: LD_VAR 0 9
63305: PUSH
63306: LD_VAR 0 3
63310: ARRAY
63311: PPUSH
63312: CALL_OW 2
63316: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63317: LD_ADDR_VAR 0 4
63321: PUSH
63322: LD_VAR 0 4
63326: PUSH
63327: LD_VAR 0 9
63331: PUSH
63332: LD_VAR 0 3
63336: ARRAY
63337: DIFF
63338: ST_TO_ADDR
// end ;
63339: GO 63248
63341: POP
63342: POP
// if p then
63343: LD_VAR 0 11
63347: IFFALSE 63372
// result := Replace ( result , 4 , p ) ;
63349: LD_ADDR_VAR 0 2
63353: PUSH
63354: LD_VAR 0 2
63358: PPUSH
63359: LD_INT 4
63361: PPUSH
63362: LD_VAR 0 11
63366: PPUSH
63367: CALL_OW 1
63371: ST_TO_ADDR
// end ; if tmp and mech < 6 then
63372: LD_VAR 0 4
63376: PUSH
63377: LD_VAR 0 7
63381: PUSH
63382: LD_INT 6
63384: LESS
63385: AND
63386: IFFALSE 63574
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63388: LD_ADDR_VAR 0 9
63392: PUSH
63393: LD_VAR 0 4
63397: PUSH
63398: LD_VAR 0 8
63402: PUSH
63403: LD_VAR 0 7
63407: UNION
63408: DIFF
63409: PPUSH
63410: LD_INT 3
63412: PPUSH
63413: CALL 51288 0 2
63417: ST_TO_ADDR
// p := [ ] ;
63418: LD_ADDR_VAR 0 11
63422: PUSH
63423: EMPTY
63424: ST_TO_ADDR
// if sort then
63425: LD_VAR 0 9
63429: IFFALSE 63545
// for i = 1 to 6 - mech do
63431: LD_ADDR_VAR 0 3
63435: PUSH
63436: DOUBLE
63437: LD_INT 1
63439: DEC
63440: ST_TO_ADDR
63441: LD_INT 6
63443: PUSH
63444: LD_VAR 0 7
63448: MINUS
63449: PUSH
63450: FOR_TO
63451: IFFALSE 63543
// begin if i = sort then
63453: LD_VAR 0 3
63457: PUSH
63458: LD_VAR 0 9
63462: EQUAL
63463: IFFALSE 63467
// break ;
63465: GO 63543
// if GetClass ( i ) = 3 then
63467: LD_VAR 0 3
63471: PPUSH
63472: CALL_OW 257
63476: PUSH
63477: LD_INT 3
63479: EQUAL
63480: IFFALSE 63484
// continue ;
63482: GO 63450
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63484: LD_ADDR_VAR 0 11
63488: PUSH
63489: LD_VAR 0 11
63493: PPUSH
63494: LD_VAR 0 11
63498: PUSH
63499: LD_INT 1
63501: PLUS
63502: PPUSH
63503: LD_VAR 0 9
63507: PUSH
63508: LD_VAR 0 3
63512: ARRAY
63513: PPUSH
63514: CALL_OW 2
63518: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63519: LD_ADDR_VAR 0 4
63523: PUSH
63524: LD_VAR 0 4
63528: PUSH
63529: LD_VAR 0 9
63533: PUSH
63534: LD_VAR 0 3
63538: ARRAY
63539: DIFF
63540: ST_TO_ADDR
// end ;
63541: GO 63450
63543: POP
63544: POP
// if p then
63545: LD_VAR 0 11
63549: IFFALSE 63574
// result := Replace ( result , 3 , p ) ;
63551: LD_ADDR_VAR 0 2
63555: PUSH
63556: LD_VAR 0 2
63560: PPUSH
63561: LD_INT 3
63563: PPUSH
63564: LD_VAR 0 11
63568: PPUSH
63569: CALL_OW 1
63573: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
63574: LD_VAR 0 4
63578: PUSH
63579: LD_INT 6
63581: GREATER
63582: PUSH
63583: LD_VAR 0 6
63587: PUSH
63588: LD_INT 6
63590: LESS
63591: AND
63592: IFFALSE 63786
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63594: LD_ADDR_VAR 0 9
63598: PUSH
63599: LD_VAR 0 4
63603: PUSH
63604: LD_VAR 0 8
63608: PUSH
63609: LD_VAR 0 7
63613: UNION
63614: PUSH
63615: LD_VAR 0 6
63619: UNION
63620: DIFF
63621: PPUSH
63622: LD_INT 2
63624: PPUSH
63625: CALL 51288 0 2
63629: ST_TO_ADDR
// p := [ ] ;
63630: LD_ADDR_VAR 0 11
63634: PUSH
63635: EMPTY
63636: ST_TO_ADDR
// if sort then
63637: LD_VAR 0 9
63641: IFFALSE 63757
// for i = 1 to 6 - eng do
63643: LD_ADDR_VAR 0 3
63647: PUSH
63648: DOUBLE
63649: LD_INT 1
63651: DEC
63652: ST_TO_ADDR
63653: LD_INT 6
63655: PUSH
63656: LD_VAR 0 6
63660: MINUS
63661: PUSH
63662: FOR_TO
63663: IFFALSE 63755
// begin if i = sort then
63665: LD_VAR 0 3
63669: PUSH
63670: LD_VAR 0 9
63674: EQUAL
63675: IFFALSE 63679
// break ;
63677: GO 63755
// if GetClass ( i ) = 2 then
63679: LD_VAR 0 3
63683: PPUSH
63684: CALL_OW 257
63688: PUSH
63689: LD_INT 2
63691: EQUAL
63692: IFFALSE 63696
// continue ;
63694: GO 63662
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63696: LD_ADDR_VAR 0 11
63700: PUSH
63701: LD_VAR 0 11
63705: PPUSH
63706: LD_VAR 0 11
63710: PUSH
63711: LD_INT 1
63713: PLUS
63714: PPUSH
63715: LD_VAR 0 9
63719: PUSH
63720: LD_VAR 0 3
63724: ARRAY
63725: PPUSH
63726: CALL_OW 2
63730: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63731: LD_ADDR_VAR 0 4
63735: PUSH
63736: LD_VAR 0 4
63740: PUSH
63741: LD_VAR 0 9
63745: PUSH
63746: LD_VAR 0 3
63750: ARRAY
63751: DIFF
63752: ST_TO_ADDR
// end ;
63753: GO 63662
63755: POP
63756: POP
// if p then
63757: LD_VAR 0 11
63761: IFFALSE 63786
// result := Replace ( result , 2 , p ) ;
63763: LD_ADDR_VAR 0 2
63767: PUSH
63768: LD_VAR 0 2
63772: PPUSH
63773: LD_INT 2
63775: PPUSH
63776: LD_VAR 0 11
63780: PPUSH
63781: CALL_OW 1
63785: ST_TO_ADDR
// end ; exit ;
63786: GO 65174
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
63788: LD_EXP 88
63792: PUSH
63793: LD_EXP 87
63797: PUSH
63798: LD_VAR 0 1
63802: ARRAY
63803: ARRAY
63804: NOT
63805: PUSH
63806: LD_EXP 61
63810: PUSH
63811: LD_VAR 0 1
63815: ARRAY
63816: PPUSH
63817: LD_INT 30
63819: PUSH
63820: LD_INT 3
63822: PUSH
63823: EMPTY
63824: LIST
63825: LIST
63826: PPUSH
63827: CALL_OW 72
63831: AND
63832: PUSH
63833: LD_EXP 66
63837: PUSH
63838: LD_VAR 0 1
63842: ARRAY
63843: AND
63844: IFFALSE 64452
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
63846: LD_ADDR_EXP 103
63850: PUSH
63851: LD_EXP 103
63855: PPUSH
63856: LD_VAR 0 1
63860: PPUSH
63861: LD_INT 5
63863: PPUSH
63864: CALL_OW 1
63868: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63869: LD_ADDR_VAR 0 2
63873: PUSH
63874: LD_INT 0
63876: PUSH
63877: LD_INT 0
63879: PUSH
63880: LD_INT 0
63882: PUSH
63883: LD_INT 0
63885: PUSH
63886: EMPTY
63887: LIST
63888: LIST
63889: LIST
63890: LIST
63891: ST_TO_ADDR
// if sci > 1 then
63892: LD_VAR 0 8
63896: PUSH
63897: LD_INT 1
63899: GREATER
63900: IFFALSE 63928
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
63902: LD_ADDR_VAR 0 4
63906: PUSH
63907: LD_VAR 0 4
63911: PUSH
63912: LD_VAR 0 8
63916: PUSH
63917: LD_VAR 0 8
63921: PUSH
63922: LD_INT 1
63924: ARRAY
63925: DIFF
63926: DIFF
63927: ST_TO_ADDR
// if tmp and not sci then
63928: LD_VAR 0 4
63932: PUSH
63933: LD_VAR 0 8
63937: NOT
63938: AND
63939: IFFALSE 64008
// begin sort := SortBySkill ( tmp , 4 ) ;
63941: LD_ADDR_VAR 0 9
63945: PUSH
63946: LD_VAR 0 4
63950: PPUSH
63951: LD_INT 4
63953: PPUSH
63954: CALL 51288 0 2
63958: ST_TO_ADDR
// if sort then
63959: LD_VAR 0 9
63963: IFFALSE 63979
// p := sort [ 1 ] ;
63965: LD_ADDR_VAR 0 11
63969: PUSH
63970: LD_VAR 0 9
63974: PUSH
63975: LD_INT 1
63977: ARRAY
63978: ST_TO_ADDR
// if p then
63979: LD_VAR 0 11
63983: IFFALSE 64008
// result := Replace ( result , 4 , p ) ;
63985: LD_ADDR_VAR 0 2
63989: PUSH
63990: LD_VAR 0 2
63994: PPUSH
63995: LD_INT 4
63997: PPUSH
63998: LD_VAR 0 11
64002: PPUSH
64003: CALL_OW 1
64007: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64008: LD_ADDR_VAR 0 4
64012: PUSH
64013: LD_VAR 0 4
64017: PUSH
64018: LD_VAR 0 7
64022: DIFF
64023: ST_TO_ADDR
// if tmp and mech < 6 then
64024: LD_VAR 0 4
64028: PUSH
64029: LD_VAR 0 7
64033: PUSH
64034: LD_INT 6
64036: LESS
64037: AND
64038: IFFALSE 64226
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
64040: LD_ADDR_VAR 0 9
64044: PUSH
64045: LD_VAR 0 4
64049: PUSH
64050: LD_VAR 0 8
64054: PUSH
64055: LD_VAR 0 7
64059: UNION
64060: DIFF
64061: PPUSH
64062: LD_INT 3
64064: PPUSH
64065: CALL 51288 0 2
64069: ST_TO_ADDR
// p := [ ] ;
64070: LD_ADDR_VAR 0 11
64074: PUSH
64075: EMPTY
64076: ST_TO_ADDR
// if sort then
64077: LD_VAR 0 9
64081: IFFALSE 64197
// for i = 1 to 6 - mech do
64083: LD_ADDR_VAR 0 3
64087: PUSH
64088: DOUBLE
64089: LD_INT 1
64091: DEC
64092: ST_TO_ADDR
64093: LD_INT 6
64095: PUSH
64096: LD_VAR 0 7
64100: MINUS
64101: PUSH
64102: FOR_TO
64103: IFFALSE 64195
// begin if i = sort then
64105: LD_VAR 0 3
64109: PUSH
64110: LD_VAR 0 9
64114: EQUAL
64115: IFFALSE 64119
// break ;
64117: GO 64195
// if GetClass ( i ) = 3 then
64119: LD_VAR 0 3
64123: PPUSH
64124: CALL_OW 257
64128: PUSH
64129: LD_INT 3
64131: EQUAL
64132: IFFALSE 64136
// continue ;
64134: GO 64102
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64136: LD_ADDR_VAR 0 11
64140: PUSH
64141: LD_VAR 0 11
64145: PPUSH
64146: LD_VAR 0 11
64150: PUSH
64151: LD_INT 1
64153: PLUS
64154: PPUSH
64155: LD_VAR 0 9
64159: PUSH
64160: LD_VAR 0 3
64164: ARRAY
64165: PPUSH
64166: CALL_OW 2
64170: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64171: LD_ADDR_VAR 0 4
64175: PUSH
64176: LD_VAR 0 4
64180: PUSH
64181: LD_VAR 0 9
64185: PUSH
64186: LD_VAR 0 3
64190: ARRAY
64191: DIFF
64192: ST_TO_ADDR
// end ;
64193: GO 64102
64195: POP
64196: POP
// if p then
64197: LD_VAR 0 11
64201: IFFALSE 64226
// result := Replace ( result , 3 , p ) ;
64203: LD_ADDR_VAR 0 2
64207: PUSH
64208: LD_VAR 0 2
64212: PPUSH
64213: LD_INT 3
64215: PPUSH
64216: LD_VAR 0 11
64220: PPUSH
64221: CALL_OW 1
64225: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64226: LD_ADDR_VAR 0 4
64230: PUSH
64231: LD_VAR 0 4
64235: PUSH
64236: LD_VAR 0 6
64240: DIFF
64241: ST_TO_ADDR
// if tmp and eng < 6 then
64242: LD_VAR 0 4
64246: PUSH
64247: LD_VAR 0 6
64251: PUSH
64252: LD_INT 6
64254: LESS
64255: AND
64256: IFFALSE 64450
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64258: LD_ADDR_VAR 0 9
64262: PUSH
64263: LD_VAR 0 4
64267: PUSH
64268: LD_VAR 0 8
64272: PUSH
64273: LD_VAR 0 7
64277: UNION
64278: PUSH
64279: LD_VAR 0 6
64283: UNION
64284: DIFF
64285: PPUSH
64286: LD_INT 2
64288: PPUSH
64289: CALL 51288 0 2
64293: ST_TO_ADDR
// p := [ ] ;
64294: LD_ADDR_VAR 0 11
64298: PUSH
64299: EMPTY
64300: ST_TO_ADDR
// if sort then
64301: LD_VAR 0 9
64305: IFFALSE 64421
// for i = 1 to 6 - eng do
64307: LD_ADDR_VAR 0 3
64311: PUSH
64312: DOUBLE
64313: LD_INT 1
64315: DEC
64316: ST_TO_ADDR
64317: LD_INT 6
64319: PUSH
64320: LD_VAR 0 6
64324: MINUS
64325: PUSH
64326: FOR_TO
64327: IFFALSE 64419
// begin if i = sort then
64329: LD_VAR 0 3
64333: PUSH
64334: LD_VAR 0 9
64338: EQUAL
64339: IFFALSE 64343
// break ;
64341: GO 64419
// if GetClass ( i ) = 2 then
64343: LD_VAR 0 3
64347: PPUSH
64348: CALL_OW 257
64352: PUSH
64353: LD_INT 2
64355: EQUAL
64356: IFFALSE 64360
// continue ;
64358: GO 64326
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64360: LD_ADDR_VAR 0 11
64364: PUSH
64365: LD_VAR 0 11
64369: PPUSH
64370: LD_VAR 0 11
64374: PUSH
64375: LD_INT 1
64377: PLUS
64378: PPUSH
64379: LD_VAR 0 9
64383: PUSH
64384: LD_VAR 0 3
64388: ARRAY
64389: PPUSH
64390: CALL_OW 2
64394: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64395: LD_ADDR_VAR 0 4
64399: PUSH
64400: LD_VAR 0 4
64404: PUSH
64405: LD_VAR 0 9
64409: PUSH
64410: LD_VAR 0 3
64414: ARRAY
64415: DIFF
64416: ST_TO_ADDR
// end ;
64417: GO 64326
64419: POP
64420: POP
// if p then
64421: LD_VAR 0 11
64425: IFFALSE 64450
// result := Replace ( result , 2 , p ) ;
64427: LD_ADDR_VAR 0 2
64431: PUSH
64432: LD_VAR 0 2
64436: PPUSH
64437: LD_INT 2
64439: PPUSH
64440: LD_VAR 0 11
64444: PPUSH
64445: CALL_OW 1
64449: ST_TO_ADDR
// end ; exit ;
64450: GO 65174
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
64452: LD_EXP 88
64456: PUSH
64457: LD_EXP 87
64461: PUSH
64462: LD_VAR 0 1
64466: ARRAY
64467: ARRAY
64468: NOT
64469: PUSH
64470: LD_EXP 61
64474: PUSH
64475: LD_VAR 0 1
64479: ARRAY
64480: PPUSH
64481: LD_INT 30
64483: PUSH
64484: LD_INT 3
64486: PUSH
64487: EMPTY
64488: LIST
64489: LIST
64490: PPUSH
64491: CALL_OW 72
64495: AND
64496: PUSH
64497: LD_EXP 66
64501: PUSH
64502: LD_VAR 0 1
64506: ARRAY
64507: NOT
64508: AND
64509: IFFALSE 65174
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
64511: LD_ADDR_EXP 103
64515: PUSH
64516: LD_EXP 103
64520: PPUSH
64521: LD_VAR 0 1
64525: PPUSH
64526: LD_INT 6
64528: PPUSH
64529: CALL_OW 1
64533: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64534: LD_ADDR_VAR 0 2
64538: PUSH
64539: LD_INT 0
64541: PUSH
64542: LD_INT 0
64544: PUSH
64545: LD_INT 0
64547: PUSH
64548: LD_INT 0
64550: PUSH
64551: EMPTY
64552: LIST
64553: LIST
64554: LIST
64555: LIST
64556: ST_TO_ADDR
// if sci >= 1 then
64557: LD_VAR 0 8
64561: PUSH
64562: LD_INT 1
64564: GREATEREQUAL
64565: IFFALSE 64587
// tmp := tmp diff sci [ 1 ] ;
64567: LD_ADDR_VAR 0 4
64571: PUSH
64572: LD_VAR 0 4
64576: PUSH
64577: LD_VAR 0 8
64581: PUSH
64582: LD_INT 1
64584: ARRAY
64585: DIFF
64586: ST_TO_ADDR
// if tmp and not sci then
64587: LD_VAR 0 4
64591: PUSH
64592: LD_VAR 0 8
64596: NOT
64597: AND
64598: IFFALSE 64667
// begin sort := SortBySkill ( tmp , 4 ) ;
64600: LD_ADDR_VAR 0 9
64604: PUSH
64605: LD_VAR 0 4
64609: PPUSH
64610: LD_INT 4
64612: PPUSH
64613: CALL 51288 0 2
64617: ST_TO_ADDR
// if sort then
64618: LD_VAR 0 9
64622: IFFALSE 64638
// p := sort [ 1 ] ;
64624: LD_ADDR_VAR 0 11
64628: PUSH
64629: LD_VAR 0 9
64633: PUSH
64634: LD_INT 1
64636: ARRAY
64637: ST_TO_ADDR
// if p then
64638: LD_VAR 0 11
64642: IFFALSE 64667
// result := Replace ( result , 4 , p ) ;
64644: LD_ADDR_VAR 0 2
64648: PUSH
64649: LD_VAR 0 2
64653: PPUSH
64654: LD_INT 4
64656: PPUSH
64657: LD_VAR 0 11
64661: PPUSH
64662: CALL_OW 1
64666: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64667: LD_ADDR_VAR 0 4
64671: PUSH
64672: LD_VAR 0 4
64676: PUSH
64677: LD_VAR 0 7
64681: DIFF
64682: ST_TO_ADDR
// if tmp and mech < 6 then
64683: LD_VAR 0 4
64687: PUSH
64688: LD_VAR 0 7
64692: PUSH
64693: LD_INT 6
64695: LESS
64696: AND
64697: IFFALSE 64879
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
64699: LD_ADDR_VAR 0 9
64703: PUSH
64704: LD_VAR 0 4
64708: PUSH
64709: LD_VAR 0 7
64713: DIFF
64714: PPUSH
64715: LD_INT 3
64717: PPUSH
64718: CALL 51288 0 2
64722: ST_TO_ADDR
// p := [ ] ;
64723: LD_ADDR_VAR 0 11
64727: PUSH
64728: EMPTY
64729: ST_TO_ADDR
// if sort then
64730: LD_VAR 0 9
64734: IFFALSE 64850
// for i = 1 to 6 - mech do
64736: LD_ADDR_VAR 0 3
64740: PUSH
64741: DOUBLE
64742: LD_INT 1
64744: DEC
64745: ST_TO_ADDR
64746: LD_INT 6
64748: PUSH
64749: LD_VAR 0 7
64753: MINUS
64754: PUSH
64755: FOR_TO
64756: IFFALSE 64848
// begin if i = sort then
64758: LD_VAR 0 3
64762: PUSH
64763: LD_VAR 0 9
64767: EQUAL
64768: IFFALSE 64772
// break ;
64770: GO 64848
// if GetClass ( i ) = 3 then
64772: LD_VAR 0 3
64776: PPUSH
64777: CALL_OW 257
64781: PUSH
64782: LD_INT 3
64784: EQUAL
64785: IFFALSE 64789
// continue ;
64787: GO 64755
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64789: LD_ADDR_VAR 0 11
64793: PUSH
64794: LD_VAR 0 11
64798: PPUSH
64799: LD_VAR 0 11
64803: PUSH
64804: LD_INT 1
64806: PLUS
64807: PPUSH
64808: LD_VAR 0 9
64812: PUSH
64813: LD_VAR 0 3
64817: ARRAY
64818: PPUSH
64819: CALL_OW 2
64823: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64824: LD_ADDR_VAR 0 4
64828: PUSH
64829: LD_VAR 0 4
64833: PUSH
64834: LD_VAR 0 9
64838: PUSH
64839: LD_VAR 0 3
64843: ARRAY
64844: DIFF
64845: ST_TO_ADDR
// end ;
64846: GO 64755
64848: POP
64849: POP
// if p then
64850: LD_VAR 0 11
64854: IFFALSE 64879
// result := Replace ( result , 3 , p ) ;
64856: LD_ADDR_VAR 0 2
64860: PUSH
64861: LD_VAR 0 2
64865: PPUSH
64866: LD_INT 3
64868: PPUSH
64869: LD_VAR 0 11
64873: PPUSH
64874: CALL_OW 1
64878: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64879: LD_ADDR_VAR 0 4
64883: PUSH
64884: LD_VAR 0 4
64888: PUSH
64889: LD_VAR 0 6
64893: DIFF
64894: ST_TO_ADDR
// if tmp and eng < 4 then
64895: LD_VAR 0 4
64899: PUSH
64900: LD_VAR 0 6
64904: PUSH
64905: LD_INT 4
64907: LESS
64908: AND
64909: IFFALSE 65099
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
64911: LD_ADDR_VAR 0 9
64915: PUSH
64916: LD_VAR 0 4
64920: PUSH
64921: LD_VAR 0 7
64925: PUSH
64926: LD_VAR 0 6
64930: UNION
64931: DIFF
64932: PPUSH
64933: LD_INT 2
64935: PPUSH
64936: CALL 51288 0 2
64940: ST_TO_ADDR
// p := [ ] ;
64941: LD_ADDR_VAR 0 11
64945: PUSH
64946: EMPTY
64947: ST_TO_ADDR
// if sort then
64948: LD_VAR 0 9
64952: IFFALSE 65068
// for i = 1 to 4 - eng do
64954: LD_ADDR_VAR 0 3
64958: PUSH
64959: DOUBLE
64960: LD_INT 1
64962: DEC
64963: ST_TO_ADDR
64964: LD_INT 4
64966: PUSH
64967: LD_VAR 0 6
64971: MINUS
64972: PUSH
64973: FOR_TO
64974: IFFALSE 65066
// begin if i = sort then
64976: LD_VAR 0 3
64980: PUSH
64981: LD_VAR 0 9
64985: EQUAL
64986: IFFALSE 64990
// break ;
64988: GO 65066
// if GetClass ( i ) = 2 then
64990: LD_VAR 0 3
64994: PPUSH
64995: CALL_OW 257
64999: PUSH
65000: LD_INT 2
65002: EQUAL
65003: IFFALSE 65007
// continue ;
65005: GO 64973
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65007: LD_ADDR_VAR 0 11
65011: PUSH
65012: LD_VAR 0 11
65016: PPUSH
65017: LD_VAR 0 11
65021: PUSH
65022: LD_INT 1
65024: PLUS
65025: PPUSH
65026: LD_VAR 0 9
65030: PUSH
65031: LD_VAR 0 3
65035: ARRAY
65036: PPUSH
65037: CALL_OW 2
65041: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65042: LD_ADDR_VAR 0 4
65046: PUSH
65047: LD_VAR 0 4
65051: PUSH
65052: LD_VAR 0 9
65056: PUSH
65057: LD_VAR 0 3
65061: ARRAY
65062: DIFF
65063: ST_TO_ADDR
// end ;
65064: GO 64973
65066: POP
65067: POP
// if p then
65068: LD_VAR 0 11
65072: IFFALSE 65097
// result := Replace ( result , 2 , p ) ;
65074: LD_ADDR_VAR 0 2
65078: PUSH
65079: LD_VAR 0 2
65083: PPUSH
65084: LD_INT 2
65086: PPUSH
65087: LD_VAR 0 11
65091: PPUSH
65092: CALL_OW 1
65096: ST_TO_ADDR
// end else
65097: GO 65143
// for i = eng downto 5 do
65099: LD_ADDR_VAR 0 3
65103: PUSH
65104: DOUBLE
65105: LD_VAR 0 6
65109: INC
65110: ST_TO_ADDR
65111: LD_INT 5
65113: PUSH
65114: FOR_DOWNTO
65115: IFFALSE 65141
// tmp := tmp union eng [ i ] ;
65117: LD_ADDR_VAR 0 4
65121: PUSH
65122: LD_VAR 0 4
65126: PUSH
65127: LD_VAR 0 6
65131: PUSH
65132: LD_VAR 0 3
65136: ARRAY
65137: UNION
65138: ST_TO_ADDR
65139: GO 65114
65141: POP
65142: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
65143: LD_ADDR_VAR 0 2
65147: PUSH
65148: LD_VAR 0 2
65152: PPUSH
65153: LD_INT 1
65155: PPUSH
65156: LD_VAR 0 4
65160: PUSH
65161: LD_VAR 0 5
65165: DIFF
65166: PPUSH
65167: CALL_OW 1
65171: ST_TO_ADDR
// exit ;
65172: GO 65174
// end ; end ;
65174: LD_VAR 0 2
65178: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
65179: LD_INT 0
65181: PPUSH
65182: PPUSH
65183: PPUSH
// if not mc_bases then
65184: LD_EXP 61
65188: NOT
65189: IFFALSE 65193
// exit ;
65191: GO 65335
// for i = 1 to mc_bases do
65193: LD_ADDR_VAR 0 2
65197: PUSH
65198: DOUBLE
65199: LD_INT 1
65201: DEC
65202: ST_TO_ADDR
65203: LD_EXP 61
65207: PUSH
65208: FOR_TO
65209: IFFALSE 65326
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65211: LD_ADDR_VAR 0 3
65215: PUSH
65216: LD_EXP 61
65220: PUSH
65221: LD_VAR 0 2
65225: ARRAY
65226: PPUSH
65227: LD_INT 21
65229: PUSH
65230: LD_INT 3
65232: PUSH
65233: EMPTY
65234: LIST
65235: LIST
65236: PUSH
65237: LD_INT 3
65239: PUSH
65240: LD_INT 2
65242: PUSH
65243: LD_INT 30
65245: PUSH
65246: LD_INT 29
65248: PUSH
65249: EMPTY
65250: LIST
65251: LIST
65252: PUSH
65253: LD_INT 30
65255: PUSH
65256: LD_INT 30
65258: PUSH
65259: EMPTY
65260: LIST
65261: LIST
65262: PUSH
65263: EMPTY
65264: LIST
65265: LIST
65266: LIST
65267: PUSH
65268: EMPTY
65269: LIST
65270: LIST
65271: PUSH
65272: LD_INT 3
65274: PUSH
65275: LD_INT 24
65277: PUSH
65278: LD_INT 1000
65280: PUSH
65281: EMPTY
65282: LIST
65283: LIST
65284: PUSH
65285: EMPTY
65286: LIST
65287: LIST
65288: PUSH
65289: EMPTY
65290: LIST
65291: LIST
65292: LIST
65293: PPUSH
65294: CALL_OW 72
65298: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
65299: LD_ADDR_EXP 62
65303: PUSH
65304: LD_EXP 62
65308: PPUSH
65309: LD_VAR 0 2
65313: PPUSH
65314: LD_VAR 0 3
65318: PPUSH
65319: CALL_OW 1
65323: ST_TO_ADDR
// end ;
65324: GO 65208
65326: POP
65327: POP
// RaiseSailEvent ( 101 ) ;
65328: LD_INT 101
65330: PPUSH
65331: CALL_OW 427
// end ;
65335: LD_VAR 0 1
65339: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
65340: LD_INT 0
65342: PPUSH
65343: PPUSH
65344: PPUSH
65345: PPUSH
65346: PPUSH
65347: PPUSH
65348: PPUSH
// if not mc_bases then
65349: LD_EXP 61
65353: NOT
65354: IFFALSE 65358
// exit ;
65356: GO 65920
// for i = 1 to mc_bases do
65358: LD_ADDR_VAR 0 2
65362: PUSH
65363: DOUBLE
65364: LD_INT 1
65366: DEC
65367: ST_TO_ADDR
65368: LD_EXP 61
65372: PUSH
65373: FOR_TO
65374: IFFALSE 65911
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
65376: LD_ADDR_VAR 0 5
65380: PUSH
65381: LD_EXP 61
65385: PUSH
65386: LD_VAR 0 2
65390: ARRAY
65391: PUSH
65392: LD_EXP 90
65396: PUSH
65397: LD_VAR 0 2
65401: ARRAY
65402: UNION
65403: PPUSH
65404: LD_INT 21
65406: PUSH
65407: LD_INT 1
65409: PUSH
65410: EMPTY
65411: LIST
65412: LIST
65413: PUSH
65414: LD_INT 1
65416: PUSH
65417: LD_INT 3
65419: PUSH
65420: LD_INT 54
65422: PUSH
65423: EMPTY
65424: LIST
65425: PUSH
65426: EMPTY
65427: LIST
65428: LIST
65429: PUSH
65430: LD_INT 3
65432: PUSH
65433: LD_INT 24
65435: PUSH
65436: LD_INT 1000
65438: PUSH
65439: EMPTY
65440: LIST
65441: LIST
65442: PUSH
65443: EMPTY
65444: LIST
65445: LIST
65446: PUSH
65447: EMPTY
65448: LIST
65449: LIST
65450: LIST
65451: PUSH
65452: EMPTY
65453: LIST
65454: LIST
65455: PPUSH
65456: CALL_OW 72
65460: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
65461: LD_ADDR_VAR 0 6
65465: PUSH
65466: LD_EXP 61
65470: PUSH
65471: LD_VAR 0 2
65475: ARRAY
65476: PPUSH
65477: LD_INT 21
65479: PUSH
65480: LD_INT 1
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: PUSH
65487: LD_INT 1
65489: PUSH
65490: LD_INT 3
65492: PUSH
65493: LD_INT 54
65495: PUSH
65496: EMPTY
65497: LIST
65498: PUSH
65499: EMPTY
65500: LIST
65501: LIST
65502: PUSH
65503: LD_INT 3
65505: PUSH
65506: LD_INT 24
65508: PUSH
65509: LD_INT 250
65511: PUSH
65512: EMPTY
65513: LIST
65514: LIST
65515: PUSH
65516: EMPTY
65517: LIST
65518: LIST
65519: PUSH
65520: EMPTY
65521: LIST
65522: LIST
65523: LIST
65524: PUSH
65525: EMPTY
65526: LIST
65527: LIST
65528: PPUSH
65529: CALL_OW 72
65533: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
65534: LD_ADDR_VAR 0 7
65538: PUSH
65539: LD_VAR 0 5
65543: PUSH
65544: LD_VAR 0 6
65548: DIFF
65549: ST_TO_ADDR
// if not need_heal_1 then
65550: LD_VAR 0 6
65554: NOT
65555: IFFALSE 65588
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
65557: LD_ADDR_EXP 64
65561: PUSH
65562: LD_EXP 64
65566: PPUSH
65567: LD_VAR 0 2
65571: PUSH
65572: LD_INT 1
65574: PUSH
65575: EMPTY
65576: LIST
65577: LIST
65578: PPUSH
65579: EMPTY
65580: PPUSH
65581: CALL 20441 0 3
65585: ST_TO_ADDR
65586: GO 65658
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
65588: LD_ADDR_EXP 64
65592: PUSH
65593: LD_EXP 64
65597: PPUSH
65598: LD_VAR 0 2
65602: PUSH
65603: LD_INT 1
65605: PUSH
65606: EMPTY
65607: LIST
65608: LIST
65609: PPUSH
65610: LD_EXP 64
65614: PUSH
65615: LD_VAR 0 2
65619: ARRAY
65620: PUSH
65621: LD_INT 1
65623: ARRAY
65624: PPUSH
65625: LD_INT 3
65627: PUSH
65628: LD_INT 24
65630: PUSH
65631: LD_INT 1000
65633: PUSH
65634: EMPTY
65635: LIST
65636: LIST
65637: PUSH
65638: EMPTY
65639: LIST
65640: LIST
65641: PPUSH
65642: CALL_OW 72
65646: PUSH
65647: LD_VAR 0 6
65651: UNION
65652: PPUSH
65653: CALL 20441 0 3
65657: ST_TO_ADDR
// if not need_heal_2 then
65658: LD_VAR 0 7
65662: NOT
65663: IFFALSE 65696
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
65665: LD_ADDR_EXP 64
65669: PUSH
65670: LD_EXP 64
65674: PPUSH
65675: LD_VAR 0 2
65679: PUSH
65680: LD_INT 2
65682: PUSH
65683: EMPTY
65684: LIST
65685: LIST
65686: PPUSH
65687: EMPTY
65688: PPUSH
65689: CALL 20441 0 3
65693: ST_TO_ADDR
65694: GO 65728
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
65696: LD_ADDR_EXP 64
65700: PUSH
65701: LD_EXP 64
65705: PPUSH
65706: LD_VAR 0 2
65710: PUSH
65711: LD_INT 2
65713: PUSH
65714: EMPTY
65715: LIST
65716: LIST
65717: PPUSH
65718: LD_VAR 0 7
65722: PPUSH
65723: CALL 20441 0 3
65727: ST_TO_ADDR
// if need_heal_2 then
65728: LD_VAR 0 7
65732: IFFALSE 65893
// for j in need_heal_2 do
65734: LD_ADDR_VAR 0 3
65738: PUSH
65739: LD_VAR 0 7
65743: PUSH
65744: FOR_IN
65745: IFFALSE 65891
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65747: LD_ADDR_VAR 0 5
65751: PUSH
65752: LD_EXP 61
65756: PUSH
65757: LD_VAR 0 2
65761: ARRAY
65762: PPUSH
65763: LD_INT 2
65765: PUSH
65766: LD_INT 30
65768: PUSH
65769: LD_INT 6
65771: PUSH
65772: EMPTY
65773: LIST
65774: LIST
65775: PUSH
65776: LD_INT 30
65778: PUSH
65779: LD_INT 7
65781: PUSH
65782: EMPTY
65783: LIST
65784: LIST
65785: PUSH
65786: LD_INT 30
65788: PUSH
65789: LD_INT 8
65791: PUSH
65792: EMPTY
65793: LIST
65794: LIST
65795: PUSH
65796: LD_INT 30
65798: PUSH
65799: LD_INT 0
65801: PUSH
65802: EMPTY
65803: LIST
65804: LIST
65805: PUSH
65806: LD_INT 30
65808: PUSH
65809: LD_INT 1
65811: PUSH
65812: EMPTY
65813: LIST
65814: LIST
65815: PUSH
65816: EMPTY
65817: LIST
65818: LIST
65819: LIST
65820: LIST
65821: LIST
65822: LIST
65823: PPUSH
65824: CALL_OW 72
65828: ST_TO_ADDR
// if tmp then
65829: LD_VAR 0 5
65833: IFFALSE 65889
// begin k := NearestUnitToUnit ( tmp , j ) ;
65835: LD_ADDR_VAR 0 4
65839: PUSH
65840: LD_VAR 0 5
65844: PPUSH
65845: LD_VAR 0 3
65849: PPUSH
65850: CALL_OW 74
65854: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
65855: LD_VAR 0 3
65859: PPUSH
65860: LD_VAR 0 4
65864: PPUSH
65865: CALL_OW 296
65869: PUSH
65870: LD_INT 5
65872: GREATER
65873: IFFALSE 65889
// ComMoveToNearbyEntrance ( j , k ) ;
65875: LD_VAR 0 3
65879: PPUSH
65880: LD_VAR 0 4
65884: PPUSH
65885: CALL 53648 0 2
// end ; end ;
65889: GO 65744
65891: POP
65892: POP
// if not need_heal_1 and not need_heal_2 then
65893: LD_VAR 0 6
65897: NOT
65898: PUSH
65899: LD_VAR 0 7
65903: NOT
65904: AND
65905: IFFALSE 65909
// continue ;
65907: GO 65373
// end ;
65909: GO 65373
65911: POP
65912: POP
// RaiseSailEvent ( 102 ) ;
65913: LD_INT 102
65915: PPUSH
65916: CALL_OW 427
// end ;
65920: LD_VAR 0 1
65924: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
65925: LD_INT 0
65927: PPUSH
65928: PPUSH
65929: PPUSH
65930: PPUSH
65931: PPUSH
65932: PPUSH
65933: PPUSH
65934: PPUSH
// if not mc_bases then
65935: LD_EXP 61
65939: NOT
65940: IFFALSE 65944
// exit ;
65942: GO 66855
// for i = 1 to mc_bases do
65944: LD_ADDR_VAR 0 2
65948: PUSH
65949: DOUBLE
65950: LD_INT 1
65952: DEC
65953: ST_TO_ADDR
65954: LD_EXP 61
65958: PUSH
65959: FOR_TO
65960: IFFALSE 66853
// begin if not mc_building_need_repair [ i ] then
65962: LD_EXP 62
65966: PUSH
65967: LD_VAR 0 2
65971: ARRAY
65972: NOT
65973: IFFALSE 66158
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
65975: LD_ADDR_VAR 0 6
65979: PUSH
65980: LD_EXP 80
65984: PUSH
65985: LD_VAR 0 2
65989: ARRAY
65990: PPUSH
65991: LD_INT 3
65993: PUSH
65994: LD_INT 24
65996: PUSH
65997: LD_INT 1000
65999: PUSH
66000: EMPTY
66001: LIST
66002: LIST
66003: PUSH
66004: EMPTY
66005: LIST
66006: LIST
66007: PUSH
66008: LD_INT 2
66010: PUSH
66011: LD_INT 34
66013: PUSH
66014: LD_INT 13
66016: PUSH
66017: EMPTY
66018: LIST
66019: LIST
66020: PUSH
66021: LD_INT 34
66023: PUSH
66024: LD_INT 52
66026: PUSH
66027: EMPTY
66028: LIST
66029: LIST
66030: PUSH
66031: LD_INT 34
66033: PUSH
66034: LD_INT 88
66036: PUSH
66037: EMPTY
66038: LIST
66039: LIST
66040: PUSH
66041: EMPTY
66042: LIST
66043: LIST
66044: LIST
66045: LIST
66046: PUSH
66047: EMPTY
66048: LIST
66049: LIST
66050: PPUSH
66051: CALL_OW 72
66055: ST_TO_ADDR
// if cranes then
66056: LD_VAR 0 6
66060: IFFALSE 66122
// for j in cranes do
66062: LD_ADDR_VAR 0 3
66066: PUSH
66067: LD_VAR 0 6
66071: PUSH
66072: FOR_IN
66073: IFFALSE 66120
// if not IsInArea ( j , mc_parking [ i ] ) then
66075: LD_VAR 0 3
66079: PPUSH
66080: LD_EXP 85
66084: PUSH
66085: LD_VAR 0 2
66089: ARRAY
66090: PPUSH
66091: CALL_OW 308
66095: NOT
66096: IFFALSE 66118
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66098: LD_VAR 0 3
66102: PPUSH
66103: LD_EXP 85
66107: PUSH
66108: LD_VAR 0 2
66112: ARRAY
66113: PPUSH
66114: CALL_OW 113
66118: GO 66072
66120: POP
66121: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
66122: LD_ADDR_EXP 63
66126: PUSH
66127: LD_EXP 63
66131: PPUSH
66132: LD_VAR 0 2
66136: PPUSH
66137: EMPTY
66138: PPUSH
66139: CALL_OW 1
66143: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
66144: LD_VAR 0 2
66148: PPUSH
66149: LD_INT 101
66151: PPUSH
66152: CALL 61012 0 2
// continue ;
66156: GO 65959
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
66158: LD_ADDR_EXP 67
66162: PUSH
66163: LD_EXP 67
66167: PPUSH
66168: LD_VAR 0 2
66172: PPUSH
66173: EMPTY
66174: PPUSH
66175: CALL_OW 1
66179: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66180: LD_VAR 0 2
66184: PPUSH
66185: LD_INT 103
66187: PPUSH
66188: CALL 61012 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
66192: LD_ADDR_VAR 0 5
66196: PUSH
66197: LD_EXP 61
66201: PUSH
66202: LD_VAR 0 2
66206: ARRAY
66207: PUSH
66208: LD_EXP 90
66212: PUSH
66213: LD_VAR 0 2
66217: ARRAY
66218: UNION
66219: PPUSH
66220: LD_INT 2
66222: PUSH
66223: LD_INT 25
66225: PUSH
66226: LD_INT 2
66228: PUSH
66229: EMPTY
66230: LIST
66231: LIST
66232: PUSH
66233: LD_INT 25
66235: PUSH
66236: LD_INT 16
66238: PUSH
66239: EMPTY
66240: LIST
66241: LIST
66242: PUSH
66243: EMPTY
66244: LIST
66245: LIST
66246: LIST
66247: PUSH
66248: EMPTY
66249: LIST
66250: PPUSH
66251: CALL_OW 72
66255: ST_TO_ADDR
// if mc_need_heal [ i ] then
66256: LD_EXP 64
66260: PUSH
66261: LD_VAR 0 2
66265: ARRAY
66266: IFFALSE 66310
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
66268: LD_ADDR_VAR 0 5
66272: PUSH
66273: LD_VAR 0 5
66277: PUSH
66278: LD_EXP 64
66282: PUSH
66283: LD_VAR 0 2
66287: ARRAY
66288: PUSH
66289: LD_INT 1
66291: ARRAY
66292: PUSH
66293: LD_EXP 64
66297: PUSH
66298: LD_VAR 0 2
66302: ARRAY
66303: PUSH
66304: LD_INT 2
66306: ARRAY
66307: UNION
66308: DIFF
66309: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
66310: LD_ADDR_VAR 0 6
66314: PUSH
66315: LD_EXP 80
66319: PUSH
66320: LD_VAR 0 2
66324: ARRAY
66325: PPUSH
66326: LD_INT 2
66328: PUSH
66329: LD_INT 34
66331: PUSH
66332: LD_INT 13
66334: PUSH
66335: EMPTY
66336: LIST
66337: LIST
66338: PUSH
66339: LD_INT 34
66341: PUSH
66342: LD_INT 52
66344: PUSH
66345: EMPTY
66346: LIST
66347: LIST
66348: PUSH
66349: LD_INT 34
66351: PUSH
66352: LD_INT 88
66354: PUSH
66355: EMPTY
66356: LIST
66357: LIST
66358: PUSH
66359: EMPTY
66360: LIST
66361: LIST
66362: LIST
66363: LIST
66364: PPUSH
66365: CALL_OW 72
66369: ST_TO_ADDR
// if cranes then
66370: LD_VAR 0 6
66374: IFFALSE 66542
// begin for j in cranes do
66376: LD_ADDR_VAR 0 3
66380: PUSH
66381: LD_VAR 0 6
66385: PUSH
66386: FOR_IN
66387: IFFALSE 66540
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
66389: LD_VAR 0 3
66393: PPUSH
66394: CALL_OW 256
66398: PUSH
66399: LD_INT 1000
66401: EQUAL
66402: PUSH
66403: LD_VAR 0 3
66407: PPUSH
66408: CALL_OW 314
66412: NOT
66413: AND
66414: IFFALSE 66480
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
66416: LD_ADDR_VAR 0 8
66420: PUSH
66421: LD_EXP 62
66425: PUSH
66426: LD_VAR 0 2
66430: ARRAY
66431: PPUSH
66432: LD_VAR 0 3
66436: PPUSH
66437: CALL_OW 74
66441: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
66442: LD_VAR 0 8
66446: PPUSH
66447: LD_INT 16
66449: PPUSH
66450: CALL 23038 0 2
66454: PUSH
66455: LD_INT 4
66457: ARRAY
66458: PUSH
66459: LD_INT 10
66461: LESS
66462: IFFALSE 66478
// ComRepairBuilding ( j , to_repair ) ;
66464: LD_VAR 0 3
66468: PPUSH
66469: LD_VAR 0 8
66473: PPUSH
66474: CALL_OW 130
// end else
66478: GO 66538
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
66480: LD_VAR 0 3
66484: PPUSH
66485: CALL_OW 256
66489: PUSH
66490: LD_INT 500
66492: LESS
66493: PUSH
66494: LD_VAR 0 3
66498: PPUSH
66499: LD_EXP 85
66503: PUSH
66504: LD_VAR 0 2
66508: ARRAY
66509: PPUSH
66510: CALL_OW 308
66514: NOT
66515: AND
66516: IFFALSE 66538
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66518: LD_VAR 0 3
66522: PPUSH
66523: LD_EXP 85
66527: PUSH
66528: LD_VAR 0 2
66532: ARRAY
66533: PPUSH
66534: CALL_OW 113
// end ;
66538: GO 66386
66540: POP
66541: POP
// end ; if tmp > 3 then
66542: LD_VAR 0 5
66546: PUSH
66547: LD_INT 3
66549: GREATER
66550: IFFALSE 66570
// tmp := ShrinkArray ( tmp , 4 ) ;
66552: LD_ADDR_VAR 0 5
66556: PUSH
66557: LD_VAR 0 5
66561: PPUSH
66562: LD_INT 4
66564: PPUSH
66565: CALL 53086 0 2
66569: ST_TO_ADDR
// if not tmp then
66570: LD_VAR 0 5
66574: NOT
66575: IFFALSE 66579
// continue ;
66577: GO 65959
// for j in tmp do
66579: LD_ADDR_VAR 0 3
66583: PUSH
66584: LD_VAR 0 5
66588: PUSH
66589: FOR_IN
66590: IFFALSE 66849
// begin if IsInUnit ( j ) then
66592: LD_VAR 0 3
66596: PPUSH
66597: CALL_OW 310
66601: IFFALSE 66612
// ComExitBuilding ( j ) ;
66603: LD_VAR 0 3
66607: PPUSH
66608: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
66612: LD_VAR 0 3
66616: PUSH
66617: LD_EXP 63
66621: PUSH
66622: LD_VAR 0 2
66626: ARRAY
66627: IN
66628: NOT
66629: IFFALSE 66687
// begin SetTag ( j , 101 ) ;
66631: LD_VAR 0 3
66635: PPUSH
66636: LD_INT 101
66638: PPUSH
66639: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
66643: LD_ADDR_EXP 63
66647: PUSH
66648: LD_EXP 63
66652: PPUSH
66653: LD_VAR 0 2
66657: PUSH
66658: LD_EXP 63
66662: PUSH
66663: LD_VAR 0 2
66667: ARRAY
66668: PUSH
66669: LD_INT 1
66671: PLUS
66672: PUSH
66673: EMPTY
66674: LIST
66675: LIST
66676: PPUSH
66677: LD_VAR 0 3
66681: PPUSH
66682: CALL 20441 0 3
66686: ST_TO_ADDR
// end ; wait ( 1 ) ;
66687: LD_INT 1
66689: PPUSH
66690: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
66694: LD_ADDR_VAR 0 7
66698: PUSH
66699: LD_EXP 62
66703: PUSH
66704: LD_VAR 0 2
66708: ARRAY
66709: ST_TO_ADDR
// if mc_scan [ i ] then
66710: LD_EXP 84
66714: PUSH
66715: LD_VAR 0 2
66719: ARRAY
66720: IFFALSE 66782
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
66722: LD_ADDR_VAR 0 7
66726: PUSH
66727: LD_EXP 62
66731: PUSH
66732: LD_VAR 0 2
66736: ARRAY
66737: PPUSH
66738: LD_INT 3
66740: PUSH
66741: LD_INT 30
66743: PUSH
66744: LD_INT 32
66746: PUSH
66747: EMPTY
66748: LIST
66749: LIST
66750: PUSH
66751: LD_INT 30
66753: PUSH
66754: LD_INT 33
66756: PUSH
66757: EMPTY
66758: LIST
66759: LIST
66760: PUSH
66761: LD_INT 30
66763: PUSH
66764: LD_INT 31
66766: PUSH
66767: EMPTY
66768: LIST
66769: LIST
66770: PUSH
66771: EMPTY
66772: LIST
66773: LIST
66774: LIST
66775: LIST
66776: PPUSH
66777: CALL_OW 72
66781: ST_TO_ADDR
// if not to_repair_tmp then
66782: LD_VAR 0 7
66786: NOT
66787: IFFALSE 66791
// continue ;
66789: GO 66589
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
66791: LD_ADDR_VAR 0 8
66795: PUSH
66796: LD_VAR 0 7
66800: PPUSH
66801: LD_VAR 0 3
66805: PPUSH
66806: CALL_OW 74
66810: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
66811: LD_VAR 0 8
66815: PPUSH
66816: LD_INT 16
66818: PPUSH
66819: CALL 23038 0 2
66823: PUSH
66824: LD_INT 4
66826: ARRAY
66827: PUSH
66828: LD_INT 14
66830: LESS
66831: IFFALSE 66847
// ComRepairBuilding ( j , to_repair ) ;
66833: LD_VAR 0 3
66837: PPUSH
66838: LD_VAR 0 8
66842: PPUSH
66843: CALL_OW 130
// end ;
66847: GO 66589
66849: POP
66850: POP
// end ;
66851: GO 65959
66853: POP
66854: POP
// end ;
66855: LD_VAR 0 1
66859: RET
// export function MC_Heal ; var i , j , tmp ; begin
66860: LD_INT 0
66862: PPUSH
66863: PPUSH
66864: PPUSH
66865: PPUSH
// if not mc_bases then
66866: LD_EXP 61
66870: NOT
66871: IFFALSE 66875
// exit ;
66873: GO 67277
// for i = 1 to mc_bases do
66875: LD_ADDR_VAR 0 2
66879: PUSH
66880: DOUBLE
66881: LD_INT 1
66883: DEC
66884: ST_TO_ADDR
66885: LD_EXP 61
66889: PUSH
66890: FOR_TO
66891: IFFALSE 67275
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
66893: LD_EXP 64
66897: PUSH
66898: LD_VAR 0 2
66902: ARRAY
66903: PUSH
66904: LD_INT 1
66906: ARRAY
66907: NOT
66908: PUSH
66909: LD_EXP 64
66913: PUSH
66914: LD_VAR 0 2
66918: ARRAY
66919: PUSH
66920: LD_INT 2
66922: ARRAY
66923: NOT
66924: AND
66925: IFFALSE 66963
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
66927: LD_ADDR_EXP 65
66931: PUSH
66932: LD_EXP 65
66936: PPUSH
66937: LD_VAR 0 2
66941: PPUSH
66942: EMPTY
66943: PPUSH
66944: CALL_OW 1
66948: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
66949: LD_VAR 0 2
66953: PPUSH
66954: LD_INT 102
66956: PPUSH
66957: CALL 61012 0 2
// continue ;
66961: GO 66890
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
66963: LD_ADDR_VAR 0 4
66967: PUSH
66968: LD_EXP 61
66972: PUSH
66973: LD_VAR 0 2
66977: ARRAY
66978: PPUSH
66979: LD_INT 25
66981: PUSH
66982: LD_INT 4
66984: PUSH
66985: EMPTY
66986: LIST
66987: LIST
66988: PPUSH
66989: CALL_OW 72
66993: ST_TO_ADDR
// if not tmp then
66994: LD_VAR 0 4
66998: NOT
66999: IFFALSE 67003
// continue ;
67001: GO 66890
// if mc_taming [ i ] then
67003: LD_EXP 92
67007: PUSH
67008: LD_VAR 0 2
67012: ARRAY
67013: IFFALSE 67037
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
67015: LD_ADDR_EXP 92
67019: PUSH
67020: LD_EXP 92
67024: PPUSH
67025: LD_VAR 0 2
67029: PPUSH
67030: EMPTY
67031: PPUSH
67032: CALL_OW 1
67036: ST_TO_ADDR
// for j in tmp do
67037: LD_ADDR_VAR 0 3
67041: PUSH
67042: LD_VAR 0 4
67046: PUSH
67047: FOR_IN
67048: IFFALSE 67271
// begin if IsInUnit ( j ) then
67050: LD_VAR 0 3
67054: PPUSH
67055: CALL_OW 310
67059: IFFALSE 67070
// ComExitBuilding ( j ) ;
67061: LD_VAR 0 3
67065: PPUSH
67066: CALL_OW 122
// if not j in mc_healers [ i ] then
67070: LD_VAR 0 3
67074: PUSH
67075: LD_EXP 65
67079: PUSH
67080: LD_VAR 0 2
67084: ARRAY
67085: IN
67086: NOT
67087: IFFALSE 67133
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
67089: LD_ADDR_EXP 65
67093: PUSH
67094: LD_EXP 65
67098: PPUSH
67099: LD_VAR 0 2
67103: PUSH
67104: LD_EXP 65
67108: PUSH
67109: LD_VAR 0 2
67113: ARRAY
67114: PUSH
67115: LD_INT 1
67117: PLUS
67118: PUSH
67119: EMPTY
67120: LIST
67121: LIST
67122: PPUSH
67123: LD_VAR 0 3
67127: PPUSH
67128: CALL 20441 0 3
67132: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
67133: LD_VAR 0 3
67137: PPUSH
67138: CALL_OW 110
67142: PUSH
67143: LD_INT 102
67145: NONEQUAL
67146: IFFALSE 67160
// SetTag ( j , 102 ) ;
67148: LD_VAR 0 3
67152: PPUSH
67153: LD_INT 102
67155: PPUSH
67156: CALL_OW 109
// Wait ( 3 ) ;
67160: LD_INT 3
67162: PPUSH
67163: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
67167: LD_EXP 64
67171: PUSH
67172: LD_VAR 0 2
67176: ARRAY
67177: PUSH
67178: LD_INT 1
67180: ARRAY
67181: IFFALSE 67213
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
67183: LD_VAR 0 3
67187: PPUSH
67188: LD_EXP 64
67192: PUSH
67193: LD_VAR 0 2
67197: ARRAY
67198: PUSH
67199: LD_INT 1
67201: ARRAY
67202: PUSH
67203: LD_INT 1
67205: ARRAY
67206: PPUSH
67207: CALL_OW 128
67211: GO 67269
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
67213: LD_VAR 0 3
67217: PPUSH
67218: CALL_OW 314
67222: NOT
67223: PUSH
67224: LD_EXP 64
67228: PUSH
67229: LD_VAR 0 2
67233: ARRAY
67234: PUSH
67235: LD_INT 2
67237: ARRAY
67238: AND
67239: IFFALSE 67269
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
67241: LD_VAR 0 3
67245: PPUSH
67246: LD_EXP 64
67250: PUSH
67251: LD_VAR 0 2
67255: ARRAY
67256: PUSH
67257: LD_INT 2
67259: ARRAY
67260: PUSH
67261: LD_INT 1
67263: ARRAY
67264: PPUSH
67265: CALL_OW 128
// end ;
67269: GO 67047
67271: POP
67272: POP
// end ;
67273: GO 66890
67275: POP
67276: POP
// end ;
67277: LD_VAR 0 1
67281: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
67282: LD_INT 0
67284: PPUSH
67285: PPUSH
67286: PPUSH
67287: PPUSH
67288: PPUSH
67289: PPUSH
// if not mc_bases then
67290: LD_EXP 61
67294: NOT
67295: IFFALSE 67299
// exit ;
67297: GO 68462
// for i = 1 to mc_bases do
67299: LD_ADDR_VAR 0 2
67303: PUSH
67304: DOUBLE
67305: LD_INT 1
67307: DEC
67308: ST_TO_ADDR
67309: LD_EXP 61
67313: PUSH
67314: FOR_TO
67315: IFFALSE 68460
// begin if mc_scan [ i ] then
67317: LD_EXP 84
67321: PUSH
67322: LD_VAR 0 2
67326: ARRAY
67327: IFFALSE 67331
// continue ;
67329: GO 67314
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
67331: LD_EXP 66
67335: PUSH
67336: LD_VAR 0 2
67340: ARRAY
67341: NOT
67342: PUSH
67343: LD_EXP 68
67347: PUSH
67348: LD_VAR 0 2
67352: ARRAY
67353: NOT
67354: AND
67355: PUSH
67356: LD_EXP 67
67360: PUSH
67361: LD_VAR 0 2
67365: ARRAY
67366: AND
67367: IFFALSE 67405
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
67369: LD_ADDR_EXP 67
67373: PUSH
67374: LD_EXP 67
67378: PPUSH
67379: LD_VAR 0 2
67383: PPUSH
67384: EMPTY
67385: PPUSH
67386: CALL_OW 1
67390: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
67391: LD_VAR 0 2
67395: PPUSH
67396: LD_INT 103
67398: PPUSH
67399: CALL 61012 0 2
// continue ;
67403: GO 67314
// end ; if mc_construct_list [ i ] then
67405: LD_EXP 68
67409: PUSH
67410: LD_VAR 0 2
67414: ARRAY
67415: IFFALSE 67635
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67417: LD_ADDR_VAR 0 5
67421: PUSH
67422: LD_EXP 61
67426: PUSH
67427: LD_VAR 0 2
67431: ARRAY
67432: PPUSH
67433: LD_INT 25
67435: PUSH
67436: LD_INT 2
67438: PUSH
67439: EMPTY
67440: LIST
67441: LIST
67442: PPUSH
67443: CALL_OW 72
67447: PUSH
67448: LD_EXP 63
67452: PUSH
67453: LD_VAR 0 2
67457: ARRAY
67458: DIFF
67459: ST_TO_ADDR
// if not tmp then
67460: LD_VAR 0 5
67464: NOT
67465: IFFALSE 67469
// continue ;
67467: GO 67314
// for j in tmp do
67469: LD_ADDR_VAR 0 3
67473: PUSH
67474: LD_VAR 0 5
67478: PUSH
67479: FOR_IN
67480: IFFALSE 67631
// begin if not mc_builders [ i ] then
67482: LD_EXP 67
67486: PUSH
67487: LD_VAR 0 2
67491: ARRAY
67492: NOT
67493: IFFALSE 67551
// begin SetTag ( j , 103 ) ;
67495: LD_VAR 0 3
67499: PPUSH
67500: LD_INT 103
67502: PPUSH
67503: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67507: LD_ADDR_EXP 67
67511: PUSH
67512: LD_EXP 67
67516: PPUSH
67517: LD_VAR 0 2
67521: PUSH
67522: LD_EXP 67
67526: PUSH
67527: LD_VAR 0 2
67531: ARRAY
67532: PUSH
67533: LD_INT 1
67535: PLUS
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: PPUSH
67541: LD_VAR 0 3
67545: PPUSH
67546: CALL 20441 0 3
67550: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67551: LD_VAR 0 3
67555: PPUSH
67556: CALL_OW 310
67560: IFFALSE 67571
// ComExitBuilding ( j ) ;
67562: LD_VAR 0 3
67566: PPUSH
67567: CALL_OW 122
// wait ( 3 ) ;
67571: LD_INT 3
67573: PPUSH
67574: CALL_OW 67
// if not mc_construct_list [ i ] then
67578: LD_EXP 68
67582: PUSH
67583: LD_VAR 0 2
67587: ARRAY
67588: NOT
67589: IFFALSE 67593
// break ;
67591: GO 67631
// if not HasTask ( j ) then
67593: LD_VAR 0 3
67597: PPUSH
67598: CALL_OW 314
67602: NOT
67603: IFFALSE 67629
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
67605: LD_VAR 0 3
67609: PPUSH
67610: LD_EXP 68
67614: PUSH
67615: LD_VAR 0 2
67619: ARRAY
67620: PUSH
67621: LD_INT 1
67623: ARRAY
67624: PPUSH
67625: CALL 23302 0 2
// end ;
67629: GO 67479
67631: POP
67632: POP
// end else
67633: GO 68458
// if mc_build_list [ i ] then
67635: LD_EXP 66
67639: PUSH
67640: LD_VAR 0 2
67644: ARRAY
67645: IFFALSE 68458
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
67647: LD_EXP 66
67651: PUSH
67652: LD_VAR 0 2
67656: ARRAY
67657: PUSH
67658: LD_INT 1
67660: ARRAY
67661: PUSH
67662: LD_INT 1
67664: ARRAY
67665: PPUSH
67666: CALL 23126 0 1
67670: PUSH
67671: LD_EXP 61
67675: PUSH
67676: LD_VAR 0 2
67680: ARRAY
67681: PPUSH
67682: LD_INT 2
67684: PUSH
67685: LD_INT 30
67687: PUSH
67688: LD_INT 2
67690: PUSH
67691: EMPTY
67692: LIST
67693: LIST
67694: PUSH
67695: LD_INT 30
67697: PUSH
67698: LD_INT 3
67700: PUSH
67701: EMPTY
67702: LIST
67703: LIST
67704: PUSH
67705: EMPTY
67706: LIST
67707: LIST
67708: LIST
67709: PPUSH
67710: CALL_OW 72
67714: NOT
67715: AND
67716: IFFALSE 67821
// begin for j = 1 to mc_build_list [ i ] do
67718: LD_ADDR_VAR 0 3
67722: PUSH
67723: DOUBLE
67724: LD_INT 1
67726: DEC
67727: ST_TO_ADDR
67728: LD_EXP 66
67732: PUSH
67733: LD_VAR 0 2
67737: ARRAY
67738: PUSH
67739: FOR_TO
67740: IFFALSE 67819
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
67742: LD_EXP 66
67746: PUSH
67747: LD_VAR 0 2
67751: ARRAY
67752: PUSH
67753: LD_VAR 0 3
67757: ARRAY
67758: PUSH
67759: LD_INT 1
67761: ARRAY
67762: PUSH
67763: LD_INT 2
67765: EQUAL
67766: IFFALSE 67817
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
67768: LD_ADDR_EXP 66
67772: PUSH
67773: LD_EXP 66
67777: PPUSH
67778: LD_VAR 0 2
67782: PPUSH
67783: LD_EXP 66
67787: PUSH
67788: LD_VAR 0 2
67792: ARRAY
67793: PPUSH
67794: LD_VAR 0 3
67798: PPUSH
67799: LD_INT 1
67801: PPUSH
67802: LD_INT 0
67804: PPUSH
67805: CALL 19859 0 4
67809: PPUSH
67810: CALL_OW 1
67814: ST_TO_ADDR
// break ;
67815: GO 67819
// end ;
67817: GO 67739
67819: POP
67820: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67821: LD_ADDR_VAR 0 6
67825: PUSH
67826: LD_EXP 61
67830: PUSH
67831: LD_VAR 0 2
67835: ARRAY
67836: PPUSH
67837: LD_INT 2
67839: PUSH
67840: LD_INT 30
67842: PUSH
67843: LD_INT 0
67845: PUSH
67846: EMPTY
67847: LIST
67848: LIST
67849: PUSH
67850: LD_INT 30
67852: PUSH
67853: LD_INT 1
67855: PUSH
67856: EMPTY
67857: LIST
67858: LIST
67859: PUSH
67860: EMPTY
67861: LIST
67862: LIST
67863: LIST
67864: PPUSH
67865: CALL_OW 72
67869: ST_TO_ADDR
// for k := 1 to depot do
67870: LD_ADDR_VAR 0 4
67874: PUSH
67875: DOUBLE
67876: LD_INT 1
67878: DEC
67879: ST_TO_ADDR
67880: LD_VAR 0 6
67884: PUSH
67885: FOR_TO
67886: IFFALSE 68456
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
67888: LD_EXP 66
67892: PUSH
67893: LD_VAR 0 2
67897: ARRAY
67898: PUSH
67899: LD_INT 1
67901: ARRAY
67902: PUSH
67903: LD_INT 1
67905: ARRAY
67906: PUSH
67907: LD_INT 0
67909: EQUAL
67910: PUSH
67911: LD_VAR 0 6
67915: PUSH
67916: LD_VAR 0 4
67920: ARRAY
67921: PPUSH
67922: LD_EXP 66
67926: PUSH
67927: LD_VAR 0 2
67931: ARRAY
67932: PUSH
67933: LD_INT 1
67935: ARRAY
67936: PUSH
67937: LD_INT 1
67939: ARRAY
67940: PPUSH
67941: LD_EXP 66
67945: PUSH
67946: LD_VAR 0 2
67950: ARRAY
67951: PUSH
67952: LD_INT 1
67954: ARRAY
67955: PUSH
67956: LD_INT 2
67958: ARRAY
67959: PPUSH
67960: LD_EXP 66
67964: PUSH
67965: LD_VAR 0 2
67969: ARRAY
67970: PUSH
67971: LD_INT 1
67973: ARRAY
67974: PUSH
67975: LD_INT 3
67977: ARRAY
67978: PPUSH
67979: LD_EXP 66
67983: PUSH
67984: LD_VAR 0 2
67988: ARRAY
67989: PUSH
67990: LD_INT 1
67992: ARRAY
67993: PUSH
67994: LD_INT 4
67996: ARRAY
67997: PPUSH
67998: CALL 28538 0 5
68002: OR
68003: IFFALSE 68284
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
68005: LD_ADDR_VAR 0 5
68009: PUSH
68010: LD_EXP 61
68014: PUSH
68015: LD_VAR 0 2
68019: ARRAY
68020: PPUSH
68021: LD_INT 25
68023: PUSH
68024: LD_INT 2
68026: PUSH
68027: EMPTY
68028: LIST
68029: LIST
68030: PPUSH
68031: CALL_OW 72
68035: PUSH
68036: LD_EXP 63
68040: PUSH
68041: LD_VAR 0 2
68045: ARRAY
68046: DIFF
68047: ST_TO_ADDR
// if not tmp then
68048: LD_VAR 0 5
68052: NOT
68053: IFFALSE 68057
// continue ;
68055: GO 67885
// for j in tmp do
68057: LD_ADDR_VAR 0 3
68061: PUSH
68062: LD_VAR 0 5
68066: PUSH
68067: FOR_IN
68068: IFFALSE 68280
// begin if not mc_builders [ i ] then
68070: LD_EXP 67
68074: PUSH
68075: LD_VAR 0 2
68079: ARRAY
68080: NOT
68081: IFFALSE 68139
// begin SetTag ( j , 103 ) ;
68083: LD_VAR 0 3
68087: PPUSH
68088: LD_INT 103
68090: PPUSH
68091: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
68095: LD_ADDR_EXP 67
68099: PUSH
68100: LD_EXP 67
68104: PPUSH
68105: LD_VAR 0 2
68109: PUSH
68110: LD_EXP 67
68114: PUSH
68115: LD_VAR 0 2
68119: ARRAY
68120: PUSH
68121: LD_INT 1
68123: PLUS
68124: PUSH
68125: EMPTY
68126: LIST
68127: LIST
68128: PPUSH
68129: LD_VAR 0 3
68133: PPUSH
68134: CALL 20441 0 3
68138: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
68139: LD_VAR 0 3
68143: PPUSH
68144: CALL_OW 310
68148: IFFALSE 68159
// ComExitBuilding ( j ) ;
68150: LD_VAR 0 3
68154: PPUSH
68155: CALL_OW 122
// wait ( 3 ) ;
68159: LD_INT 3
68161: PPUSH
68162: CALL_OW 67
// if not mc_build_list [ i ] then
68166: LD_EXP 66
68170: PUSH
68171: LD_VAR 0 2
68175: ARRAY
68176: NOT
68177: IFFALSE 68181
// break ;
68179: GO 68280
// if not HasTask ( j ) then
68181: LD_VAR 0 3
68185: PPUSH
68186: CALL_OW 314
68190: NOT
68191: IFFALSE 68278
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
68193: LD_VAR 0 3
68197: PPUSH
68198: LD_EXP 66
68202: PUSH
68203: LD_VAR 0 2
68207: ARRAY
68208: PUSH
68209: LD_INT 1
68211: ARRAY
68212: PUSH
68213: LD_INT 1
68215: ARRAY
68216: PPUSH
68217: LD_EXP 66
68221: PUSH
68222: LD_VAR 0 2
68226: ARRAY
68227: PUSH
68228: LD_INT 1
68230: ARRAY
68231: PUSH
68232: LD_INT 2
68234: ARRAY
68235: PPUSH
68236: LD_EXP 66
68240: PUSH
68241: LD_VAR 0 2
68245: ARRAY
68246: PUSH
68247: LD_INT 1
68249: ARRAY
68250: PUSH
68251: LD_INT 3
68253: ARRAY
68254: PPUSH
68255: LD_EXP 66
68259: PUSH
68260: LD_VAR 0 2
68264: ARRAY
68265: PUSH
68266: LD_INT 1
68268: ARRAY
68269: PUSH
68270: LD_INT 4
68272: ARRAY
68273: PPUSH
68274: CALL_OW 145
// end ;
68278: GO 68067
68280: POP
68281: POP
// end else
68282: GO 68454
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
68284: LD_EXP 61
68288: PUSH
68289: LD_VAR 0 2
68293: ARRAY
68294: PPUSH
68295: LD_EXP 66
68299: PUSH
68300: LD_VAR 0 2
68304: ARRAY
68305: PUSH
68306: LD_INT 1
68308: ARRAY
68309: PUSH
68310: LD_INT 1
68312: ARRAY
68313: PPUSH
68314: LD_EXP 66
68318: PUSH
68319: LD_VAR 0 2
68323: ARRAY
68324: PUSH
68325: LD_INT 1
68327: ARRAY
68328: PUSH
68329: LD_INT 2
68331: ARRAY
68332: PPUSH
68333: LD_EXP 66
68337: PUSH
68338: LD_VAR 0 2
68342: ARRAY
68343: PUSH
68344: LD_INT 1
68346: ARRAY
68347: PUSH
68348: LD_INT 3
68350: ARRAY
68351: PPUSH
68352: LD_EXP 66
68356: PUSH
68357: LD_VAR 0 2
68361: ARRAY
68362: PUSH
68363: LD_INT 1
68365: ARRAY
68366: PUSH
68367: LD_INT 4
68369: ARRAY
68370: PPUSH
68371: LD_EXP 61
68375: PUSH
68376: LD_VAR 0 2
68380: ARRAY
68381: PPUSH
68382: LD_INT 21
68384: PUSH
68385: LD_INT 3
68387: PUSH
68388: EMPTY
68389: LIST
68390: LIST
68391: PPUSH
68392: CALL_OW 72
68396: PPUSH
68397: EMPTY
68398: PPUSH
68399: CALL 27292 0 7
68403: NOT
68404: IFFALSE 68454
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
68406: LD_ADDR_EXP 66
68410: PUSH
68411: LD_EXP 66
68415: PPUSH
68416: LD_VAR 0 2
68420: PPUSH
68421: LD_EXP 66
68425: PUSH
68426: LD_VAR 0 2
68430: ARRAY
68431: PPUSH
68432: LD_INT 1
68434: PPUSH
68435: LD_INT 1
68437: NEG
68438: PPUSH
68439: LD_INT 0
68441: PPUSH
68442: CALL 19859 0 4
68446: PPUSH
68447: CALL_OW 1
68451: ST_TO_ADDR
// continue ;
68452: GO 67885
// end ; end ;
68454: GO 67885
68456: POP
68457: POP
// end ; end ;
68458: GO 67314
68460: POP
68461: POP
// end ;
68462: LD_VAR 0 1
68466: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
68467: LD_INT 0
68469: PPUSH
68470: PPUSH
68471: PPUSH
68472: PPUSH
68473: PPUSH
68474: PPUSH
// if not mc_bases then
68475: LD_EXP 61
68479: NOT
68480: IFFALSE 68484
// exit ;
68482: GO 68911
// for i = 1 to mc_bases do
68484: LD_ADDR_VAR 0 2
68488: PUSH
68489: DOUBLE
68490: LD_INT 1
68492: DEC
68493: ST_TO_ADDR
68494: LD_EXP 61
68498: PUSH
68499: FOR_TO
68500: IFFALSE 68909
// begin tmp := mc_build_upgrade [ i ] ;
68502: LD_ADDR_VAR 0 4
68506: PUSH
68507: LD_EXP 93
68511: PUSH
68512: LD_VAR 0 2
68516: ARRAY
68517: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
68518: LD_ADDR_VAR 0 6
68522: PUSH
68523: LD_EXP 94
68527: PUSH
68528: LD_VAR 0 2
68532: ARRAY
68533: PPUSH
68534: LD_INT 2
68536: PUSH
68537: LD_INT 30
68539: PUSH
68540: LD_INT 6
68542: PUSH
68543: EMPTY
68544: LIST
68545: LIST
68546: PUSH
68547: LD_INT 30
68549: PUSH
68550: LD_INT 7
68552: PUSH
68553: EMPTY
68554: LIST
68555: LIST
68556: PUSH
68557: EMPTY
68558: LIST
68559: LIST
68560: LIST
68561: PPUSH
68562: CALL_OW 72
68566: ST_TO_ADDR
// if not tmp and not lab then
68567: LD_VAR 0 4
68571: NOT
68572: PUSH
68573: LD_VAR 0 6
68577: NOT
68578: AND
68579: IFFALSE 68583
// continue ;
68581: GO 68499
// if tmp then
68583: LD_VAR 0 4
68587: IFFALSE 68707
// for j in tmp do
68589: LD_ADDR_VAR 0 3
68593: PUSH
68594: LD_VAR 0 4
68598: PUSH
68599: FOR_IN
68600: IFFALSE 68705
// begin if UpgradeCost ( j ) then
68602: LD_VAR 0 3
68606: PPUSH
68607: CALL 26952 0 1
68611: IFFALSE 68703
// begin ComUpgrade ( j ) ;
68613: LD_VAR 0 3
68617: PPUSH
68618: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
68622: LD_ADDR_EXP 93
68626: PUSH
68627: LD_EXP 93
68631: PPUSH
68632: LD_VAR 0 2
68636: PPUSH
68637: LD_EXP 93
68641: PUSH
68642: LD_VAR 0 2
68646: ARRAY
68647: PUSH
68648: LD_VAR 0 3
68652: DIFF
68653: PPUSH
68654: CALL_OW 1
68658: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68659: LD_ADDR_EXP 68
68663: PUSH
68664: LD_EXP 68
68668: PPUSH
68669: LD_VAR 0 2
68673: PUSH
68674: LD_EXP 68
68678: PUSH
68679: LD_VAR 0 2
68683: ARRAY
68684: PUSH
68685: LD_INT 1
68687: PLUS
68688: PUSH
68689: EMPTY
68690: LIST
68691: LIST
68692: PPUSH
68693: LD_VAR 0 3
68697: PPUSH
68698: CALL 20441 0 3
68702: ST_TO_ADDR
// end ; end ;
68703: GO 68599
68705: POP
68706: POP
// if not lab or not mc_lab_upgrade [ i ] then
68707: LD_VAR 0 6
68711: NOT
68712: PUSH
68713: LD_EXP 95
68717: PUSH
68718: LD_VAR 0 2
68722: ARRAY
68723: NOT
68724: OR
68725: IFFALSE 68729
// continue ;
68727: GO 68499
// for j in lab do
68729: LD_ADDR_VAR 0 3
68733: PUSH
68734: LD_VAR 0 6
68738: PUSH
68739: FOR_IN
68740: IFFALSE 68905
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
68742: LD_VAR 0 3
68746: PPUSH
68747: CALL_OW 266
68751: PUSH
68752: LD_INT 6
68754: PUSH
68755: LD_INT 7
68757: PUSH
68758: EMPTY
68759: LIST
68760: LIST
68761: IN
68762: PUSH
68763: LD_VAR 0 3
68767: PPUSH
68768: CALL_OW 461
68772: PUSH
68773: LD_INT 1
68775: NONEQUAL
68776: AND
68777: IFFALSE 68903
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
68779: LD_VAR 0 3
68783: PPUSH
68784: LD_EXP 95
68788: PUSH
68789: LD_VAR 0 2
68793: ARRAY
68794: PUSH
68795: LD_INT 1
68797: ARRAY
68798: PPUSH
68799: CALL 27157 0 2
68803: IFFALSE 68903
// begin ComCancel ( j ) ;
68805: LD_VAR 0 3
68809: PPUSH
68810: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
68814: LD_VAR 0 3
68818: PPUSH
68819: LD_EXP 95
68823: PUSH
68824: LD_VAR 0 2
68828: ARRAY
68829: PUSH
68830: LD_INT 1
68832: ARRAY
68833: PPUSH
68834: CALL_OW 207
// if not j in mc_construct_list [ i ] then
68838: LD_VAR 0 3
68842: PUSH
68843: LD_EXP 68
68847: PUSH
68848: LD_VAR 0 2
68852: ARRAY
68853: IN
68854: NOT
68855: IFFALSE 68901
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68857: LD_ADDR_EXP 68
68861: PUSH
68862: LD_EXP 68
68866: PPUSH
68867: LD_VAR 0 2
68871: PUSH
68872: LD_EXP 68
68876: PUSH
68877: LD_VAR 0 2
68881: ARRAY
68882: PUSH
68883: LD_INT 1
68885: PLUS
68886: PUSH
68887: EMPTY
68888: LIST
68889: LIST
68890: PPUSH
68891: LD_VAR 0 3
68895: PPUSH
68896: CALL 20441 0 3
68900: ST_TO_ADDR
// break ;
68901: GO 68905
// end ; end ; end ;
68903: GO 68739
68905: POP
68906: POP
// end ;
68907: GO 68499
68909: POP
68910: POP
// end ;
68911: LD_VAR 0 1
68915: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
68916: LD_INT 0
68918: PPUSH
68919: PPUSH
68920: PPUSH
68921: PPUSH
68922: PPUSH
68923: PPUSH
68924: PPUSH
68925: PPUSH
68926: PPUSH
// if not mc_bases then
68927: LD_EXP 61
68931: NOT
68932: IFFALSE 68936
// exit ;
68934: GO 69341
// for i = 1 to mc_bases do
68936: LD_ADDR_VAR 0 2
68940: PUSH
68941: DOUBLE
68942: LD_INT 1
68944: DEC
68945: ST_TO_ADDR
68946: LD_EXP 61
68950: PUSH
68951: FOR_TO
68952: IFFALSE 69339
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
68954: LD_EXP 69
68958: PUSH
68959: LD_VAR 0 2
68963: ARRAY
68964: NOT
68965: PUSH
68966: LD_EXP 61
68970: PUSH
68971: LD_VAR 0 2
68975: ARRAY
68976: PPUSH
68977: LD_INT 30
68979: PUSH
68980: LD_INT 3
68982: PUSH
68983: EMPTY
68984: LIST
68985: LIST
68986: PPUSH
68987: CALL_OW 72
68991: NOT
68992: OR
68993: IFFALSE 68997
// continue ;
68995: GO 68951
// busy := false ;
68997: LD_ADDR_VAR 0 8
69001: PUSH
69002: LD_INT 0
69004: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69005: LD_ADDR_VAR 0 4
69009: PUSH
69010: LD_EXP 61
69014: PUSH
69015: LD_VAR 0 2
69019: ARRAY
69020: PPUSH
69021: LD_INT 30
69023: PUSH
69024: LD_INT 3
69026: PUSH
69027: EMPTY
69028: LIST
69029: LIST
69030: PPUSH
69031: CALL_OW 72
69035: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
69036: LD_ADDR_VAR 0 6
69040: PUSH
69041: LD_EXP 69
69045: PUSH
69046: LD_VAR 0 2
69050: ARRAY
69051: PPUSH
69052: LD_INT 2
69054: PUSH
69055: LD_INT 30
69057: PUSH
69058: LD_INT 32
69060: PUSH
69061: EMPTY
69062: LIST
69063: LIST
69064: PUSH
69065: LD_INT 30
69067: PUSH
69068: LD_INT 33
69070: PUSH
69071: EMPTY
69072: LIST
69073: LIST
69074: PUSH
69075: EMPTY
69076: LIST
69077: LIST
69078: LIST
69079: PPUSH
69080: CALL_OW 72
69084: ST_TO_ADDR
// if not t then
69085: LD_VAR 0 6
69089: NOT
69090: IFFALSE 69094
// continue ;
69092: GO 68951
// for j in tmp do
69094: LD_ADDR_VAR 0 3
69098: PUSH
69099: LD_VAR 0 4
69103: PUSH
69104: FOR_IN
69105: IFFALSE 69135
// if not BuildingStatus ( j ) = bs_idle then
69107: LD_VAR 0 3
69111: PPUSH
69112: CALL_OW 461
69116: PUSH
69117: LD_INT 2
69119: EQUAL
69120: NOT
69121: IFFALSE 69133
// begin busy := true ;
69123: LD_ADDR_VAR 0 8
69127: PUSH
69128: LD_INT 1
69130: ST_TO_ADDR
// break ;
69131: GO 69135
// end ;
69133: GO 69104
69135: POP
69136: POP
// if busy then
69137: LD_VAR 0 8
69141: IFFALSE 69145
// continue ;
69143: GO 68951
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
69145: LD_ADDR_VAR 0 7
69149: PUSH
69150: LD_VAR 0 6
69154: PPUSH
69155: LD_INT 35
69157: PUSH
69158: LD_INT 0
69160: PUSH
69161: EMPTY
69162: LIST
69163: LIST
69164: PPUSH
69165: CALL_OW 72
69169: ST_TO_ADDR
// if tw then
69170: LD_VAR 0 7
69174: IFFALSE 69251
// begin tw := tw [ 1 ] ;
69176: LD_ADDR_VAR 0 7
69180: PUSH
69181: LD_VAR 0 7
69185: PUSH
69186: LD_INT 1
69188: ARRAY
69189: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
69190: LD_ADDR_VAR 0 9
69194: PUSH
69195: LD_VAR 0 7
69199: PPUSH
69200: LD_EXP 86
69204: PUSH
69205: LD_VAR 0 2
69209: ARRAY
69210: PPUSH
69211: CALL 25449 0 2
69215: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
69216: LD_EXP 100
69220: PUSH
69221: LD_VAR 0 2
69225: ARRAY
69226: IFFALSE 69249
// if not weapon in mc_allowed_tower_weapons [ i ] then
69228: LD_VAR 0 9
69232: PUSH
69233: LD_EXP 100
69237: PUSH
69238: LD_VAR 0 2
69242: ARRAY
69243: IN
69244: NOT
69245: IFFALSE 69249
// continue ;
69247: GO 68951
// end else
69249: GO 69314
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
69251: LD_ADDR_VAR 0 5
69255: PUSH
69256: LD_EXP 69
69260: PUSH
69261: LD_VAR 0 2
69265: ARRAY
69266: PPUSH
69267: LD_VAR 0 4
69271: PPUSH
69272: CALL 52319 0 2
69276: ST_TO_ADDR
// if not tmp2 then
69277: LD_VAR 0 5
69281: NOT
69282: IFFALSE 69286
// continue ;
69284: GO 68951
// tw := tmp2 [ 1 ] ;
69286: LD_ADDR_VAR 0 7
69290: PUSH
69291: LD_VAR 0 5
69295: PUSH
69296: LD_INT 1
69298: ARRAY
69299: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
69300: LD_ADDR_VAR 0 9
69304: PUSH
69305: LD_VAR 0 5
69309: PUSH
69310: LD_INT 2
69312: ARRAY
69313: ST_TO_ADDR
// end ; if not weapon then
69314: LD_VAR 0 9
69318: NOT
69319: IFFALSE 69323
// continue ;
69321: GO 68951
// ComPlaceWeapon ( tw , weapon ) ;
69323: LD_VAR 0 7
69327: PPUSH
69328: LD_VAR 0 9
69332: PPUSH
69333: CALL_OW 148
// end ;
69337: GO 68951
69339: POP
69340: POP
// end ;
69341: LD_VAR 0 1
69345: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
69346: LD_INT 0
69348: PPUSH
69349: PPUSH
69350: PPUSH
69351: PPUSH
69352: PPUSH
69353: PPUSH
69354: PPUSH
// if not mc_bases then
69355: LD_EXP 61
69359: NOT
69360: IFFALSE 69364
// exit ;
69362: GO 70139
// for i = 1 to mc_bases do
69364: LD_ADDR_VAR 0 2
69368: PUSH
69369: DOUBLE
69370: LD_INT 1
69372: DEC
69373: ST_TO_ADDR
69374: LD_EXP 61
69378: PUSH
69379: FOR_TO
69380: IFFALSE 70137
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
69382: LD_EXP 74
69386: PUSH
69387: LD_VAR 0 2
69391: ARRAY
69392: NOT
69393: PUSH
69394: LD_EXP 74
69398: PUSH
69399: LD_VAR 0 2
69403: ARRAY
69404: PUSH
69405: LD_EXP 75
69409: PUSH
69410: LD_VAR 0 2
69414: ARRAY
69415: EQUAL
69416: OR
69417: PUSH
69418: LD_EXP 84
69422: PUSH
69423: LD_VAR 0 2
69427: ARRAY
69428: OR
69429: IFFALSE 69433
// continue ;
69431: GO 69379
// if mc_miners [ i ] then
69433: LD_EXP 75
69437: PUSH
69438: LD_VAR 0 2
69442: ARRAY
69443: IFFALSE 69824
// begin for j = mc_miners [ i ] downto 1 do
69445: LD_ADDR_VAR 0 3
69449: PUSH
69450: DOUBLE
69451: LD_EXP 75
69455: PUSH
69456: LD_VAR 0 2
69460: ARRAY
69461: INC
69462: ST_TO_ADDR
69463: LD_INT 1
69465: PUSH
69466: FOR_DOWNTO
69467: IFFALSE 69822
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
69469: LD_EXP 75
69473: PUSH
69474: LD_VAR 0 2
69478: ARRAY
69479: PUSH
69480: LD_VAR 0 3
69484: ARRAY
69485: PPUSH
69486: CALL_OW 301
69490: PUSH
69491: LD_EXP 75
69495: PUSH
69496: LD_VAR 0 2
69500: ARRAY
69501: PUSH
69502: LD_VAR 0 3
69506: ARRAY
69507: PPUSH
69508: CALL_OW 257
69512: PUSH
69513: LD_INT 1
69515: NONEQUAL
69516: OR
69517: IFFALSE 69580
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
69519: LD_ADDR_VAR 0 5
69523: PUSH
69524: LD_EXP 75
69528: PUSH
69529: LD_VAR 0 2
69533: ARRAY
69534: PUSH
69535: LD_EXP 75
69539: PUSH
69540: LD_VAR 0 2
69544: ARRAY
69545: PUSH
69546: LD_VAR 0 3
69550: ARRAY
69551: DIFF
69552: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
69553: LD_ADDR_EXP 75
69557: PUSH
69558: LD_EXP 75
69562: PPUSH
69563: LD_VAR 0 2
69567: PPUSH
69568: LD_VAR 0 5
69572: PPUSH
69573: CALL_OW 1
69577: ST_TO_ADDR
// continue ;
69578: GO 69466
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
69580: LD_EXP 75
69584: PUSH
69585: LD_VAR 0 2
69589: ARRAY
69590: PUSH
69591: LD_VAR 0 3
69595: ARRAY
69596: PPUSH
69597: CALL_OW 257
69601: PUSH
69602: LD_INT 1
69604: EQUAL
69605: PUSH
69606: LD_EXP 75
69610: PUSH
69611: LD_VAR 0 2
69615: ARRAY
69616: PUSH
69617: LD_VAR 0 3
69621: ARRAY
69622: PPUSH
69623: CALL_OW 459
69627: NOT
69628: AND
69629: PUSH
69630: LD_EXP 75
69634: PUSH
69635: LD_VAR 0 2
69639: ARRAY
69640: PUSH
69641: LD_VAR 0 3
69645: ARRAY
69646: PPUSH
69647: CALL_OW 314
69651: NOT
69652: AND
69653: IFFALSE 69820
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
69655: LD_EXP 75
69659: PUSH
69660: LD_VAR 0 2
69664: ARRAY
69665: PUSH
69666: LD_VAR 0 3
69670: ARRAY
69671: PPUSH
69672: CALL_OW 310
69676: IFFALSE 69699
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
69678: LD_EXP 75
69682: PUSH
69683: LD_VAR 0 2
69687: ARRAY
69688: PUSH
69689: LD_VAR 0 3
69693: ARRAY
69694: PPUSH
69695: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
69699: LD_EXP 75
69703: PUSH
69704: LD_VAR 0 2
69708: ARRAY
69709: PUSH
69710: LD_VAR 0 3
69714: ARRAY
69715: PPUSH
69716: CALL_OW 314
69720: NOT
69721: IFFALSE 69820
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
69723: LD_ADDR_VAR 0 7
69727: PUSH
69728: LD_VAR 0 3
69732: PUSH
69733: LD_EXP 74
69737: PUSH
69738: LD_VAR 0 2
69742: ARRAY
69743: PPUSH
69744: CALL 17581 0 1
69748: MOD
69749: PUSH
69750: LD_INT 1
69752: PLUS
69753: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
69754: LD_EXP 75
69758: PUSH
69759: LD_VAR 0 2
69763: ARRAY
69764: PUSH
69765: LD_VAR 0 3
69769: ARRAY
69770: PPUSH
69771: LD_EXP 74
69775: PUSH
69776: LD_VAR 0 2
69780: ARRAY
69781: PUSH
69782: LD_VAR 0 7
69786: ARRAY
69787: PUSH
69788: LD_INT 1
69790: ARRAY
69791: PPUSH
69792: LD_EXP 74
69796: PUSH
69797: LD_VAR 0 2
69801: ARRAY
69802: PUSH
69803: LD_VAR 0 7
69807: ARRAY
69808: PUSH
69809: LD_INT 2
69811: ARRAY
69812: PPUSH
69813: LD_INT 0
69815: PPUSH
69816: CALL_OW 193
// end ; end ; end ;
69820: GO 69466
69822: POP
69823: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
69824: LD_ADDR_VAR 0 5
69828: PUSH
69829: LD_EXP 61
69833: PUSH
69834: LD_VAR 0 2
69838: ARRAY
69839: PPUSH
69840: LD_INT 2
69842: PUSH
69843: LD_INT 30
69845: PUSH
69846: LD_INT 4
69848: PUSH
69849: EMPTY
69850: LIST
69851: LIST
69852: PUSH
69853: LD_INT 30
69855: PUSH
69856: LD_INT 5
69858: PUSH
69859: EMPTY
69860: LIST
69861: LIST
69862: PUSH
69863: LD_INT 30
69865: PUSH
69866: LD_INT 32
69868: PUSH
69869: EMPTY
69870: LIST
69871: LIST
69872: PUSH
69873: EMPTY
69874: LIST
69875: LIST
69876: LIST
69877: LIST
69878: PPUSH
69879: CALL_OW 72
69883: ST_TO_ADDR
// if not tmp then
69884: LD_VAR 0 5
69888: NOT
69889: IFFALSE 69893
// continue ;
69891: GO 69379
// list := [ ] ;
69893: LD_ADDR_VAR 0 6
69897: PUSH
69898: EMPTY
69899: ST_TO_ADDR
// for j in tmp do
69900: LD_ADDR_VAR 0 3
69904: PUSH
69905: LD_VAR 0 5
69909: PUSH
69910: FOR_IN
69911: IFFALSE 69980
// begin for k in UnitsInside ( j ) do
69913: LD_ADDR_VAR 0 4
69917: PUSH
69918: LD_VAR 0 3
69922: PPUSH
69923: CALL_OW 313
69927: PUSH
69928: FOR_IN
69929: IFFALSE 69976
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
69931: LD_VAR 0 4
69935: PPUSH
69936: CALL_OW 257
69940: PUSH
69941: LD_INT 1
69943: EQUAL
69944: PUSH
69945: LD_VAR 0 4
69949: PPUSH
69950: CALL_OW 459
69954: NOT
69955: AND
69956: IFFALSE 69974
// list := list ^ k ;
69958: LD_ADDR_VAR 0 6
69962: PUSH
69963: LD_VAR 0 6
69967: PUSH
69968: LD_VAR 0 4
69972: ADD
69973: ST_TO_ADDR
69974: GO 69928
69976: POP
69977: POP
// end ;
69978: GO 69910
69980: POP
69981: POP
// list := list diff mc_miners [ i ] ;
69982: LD_ADDR_VAR 0 6
69986: PUSH
69987: LD_VAR 0 6
69991: PUSH
69992: LD_EXP 75
69996: PUSH
69997: LD_VAR 0 2
70001: ARRAY
70002: DIFF
70003: ST_TO_ADDR
// if not list then
70004: LD_VAR 0 6
70008: NOT
70009: IFFALSE 70013
// continue ;
70011: GO 69379
// k := mc_mines [ i ] - mc_miners [ i ] ;
70013: LD_ADDR_VAR 0 4
70017: PUSH
70018: LD_EXP 74
70022: PUSH
70023: LD_VAR 0 2
70027: ARRAY
70028: PUSH
70029: LD_EXP 75
70033: PUSH
70034: LD_VAR 0 2
70038: ARRAY
70039: MINUS
70040: ST_TO_ADDR
// if k > list then
70041: LD_VAR 0 4
70045: PUSH
70046: LD_VAR 0 6
70050: GREATER
70051: IFFALSE 70063
// k := list ;
70053: LD_ADDR_VAR 0 4
70057: PUSH
70058: LD_VAR 0 6
70062: ST_TO_ADDR
// for j = 1 to k do
70063: LD_ADDR_VAR 0 3
70067: PUSH
70068: DOUBLE
70069: LD_INT 1
70071: DEC
70072: ST_TO_ADDR
70073: LD_VAR 0 4
70077: PUSH
70078: FOR_TO
70079: IFFALSE 70133
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
70081: LD_ADDR_EXP 75
70085: PUSH
70086: LD_EXP 75
70090: PPUSH
70091: LD_VAR 0 2
70095: PUSH
70096: LD_EXP 75
70100: PUSH
70101: LD_VAR 0 2
70105: ARRAY
70106: PUSH
70107: LD_INT 1
70109: PLUS
70110: PUSH
70111: EMPTY
70112: LIST
70113: LIST
70114: PPUSH
70115: LD_VAR 0 6
70119: PUSH
70120: LD_VAR 0 3
70124: ARRAY
70125: PPUSH
70126: CALL 20441 0 3
70130: ST_TO_ADDR
70131: GO 70078
70133: POP
70134: POP
// end ;
70135: GO 69379
70137: POP
70138: POP
// end ;
70139: LD_VAR 0 1
70143: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
70144: LD_INT 0
70146: PPUSH
70147: PPUSH
70148: PPUSH
70149: PPUSH
70150: PPUSH
70151: PPUSH
70152: PPUSH
70153: PPUSH
70154: PPUSH
70155: PPUSH
70156: PPUSH
// if not mc_bases then
70157: LD_EXP 61
70161: NOT
70162: IFFALSE 70166
// exit ;
70164: GO 71989
// for i = 1 to mc_bases do
70166: LD_ADDR_VAR 0 2
70170: PUSH
70171: DOUBLE
70172: LD_INT 1
70174: DEC
70175: ST_TO_ADDR
70176: LD_EXP 61
70180: PUSH
70181: FOR_TO
70182: IFFALSE 71987
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
70184: LD_EXP 61
70188: PUSH
70189: LD_VAR 0 2
70193: ARRAY
70194: NOT
70195: PUSH
70196: LD_EXP 68
70200: PUSH
70201: LD_VAR 0 2
70205: ARRAY
70206: OR
70207: IFFALSE 70211
// continue ;
70209: GO 70181
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
70211: LD_EXP 77
70215: PUSH
70216: LD_VAR 0 2
70220: ARRAY
70221: NOT
70222: PUSH
70223: LD_EXP 78
70227: PUSH
70228: LD_VAR 0 2
70232: ARRAY
70233: AND
70234: IFFALSE 70272
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
70236: LD_ADDR_EXP 78
70240: PUSH
70241: LD_EXP 78
70245: PPUSH
70246: LD_VAR 0 2
70250: PPUSH
70251: EMPTY
70252: PPUSH
70253: CALL_OW 1
70257: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
70258: LD_VAR 0 2
70262: PPUSH
70263: LD_INT 107
70265: PPUSH
70266: CALL 61012 0 2
// continue ;
70270: GO 70181
// end ; target := [ ] ;
70272: LD_ADDR_VAR 0 7
70276: PUSH
70277: EMPTY
70278: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
70279: LD_ADDR_VAR 0 6
70283: PUSH
70284: LD_EXP 61
70288: PUSH
70289: LD_VAR 0 2
70293: ARRAY
70294: PUSH
70295: LD_INT 1
70297: ARRAY
70298: PPUSH
70299: CALL_OW 255
70303: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70304: LD_ADDR_VAR 0 9
70308: PUSH
70309: LD_EXP 61
70313: PUSH
70314: LD_VAR 0 2
70318: ARRAY
70319: PPUSH
70320: LD_INT 2
70322: PUSH
70323: LD_INT 30
70325: PUSH
70326: LD_INT 0
70328: PUSH
70329: EMPTY
70330: LIST
70331: LIST
70332: PUSH
70333: LD_INT 30
70335: PUSH
70336: LD_INT 1
70338: PUSH
70339: EMPTY
70340: LIST
70341: LIST
70342: PUSH
70343: EMPTY
70344: LIST
70345: LIST
70346: LIST
70347: PPUSH
70348: CALL_OW 72
70352: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
70353: LD_ADDR_VAR 0 3
70357: PUSH
70358: DOUBLE
70359: LD_EXP 77
70363: PUSH
70364: LD_VAR 0 2
70368: ARRAY
70369: INC
70370: ST_TO_ADDR
70371: LD_INT 1
70373: PUSH
70374: FOR_DOWNTO
70375: IFFALSE 70620
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
70377: LD_EXP 77
70381: PUSH
70382: LD_VAR 0 2
70386: ARRAY
70387: PUSH
70388: LD_VAR 0 3
70392: ARRAY
70393: PUSH
70394: LD_INT 2
70396: ARRAY
70397: PPUSH
70398: LD_EXP 77
70402: PUSH
70403: LD_VAR 0 2
70407: ARRAY
70408: PUSH
70409: LD_VAR 0 3
70413: ARRAY
70414: PUSH
70415: LD_INT 3
70417: ARRAY
70418: PPUSH
70419: CALL_OW 488
70423: PUSH
70424: LD_EXP 77
70428: PUSH
70429: LD_VAR 0 2
70433: ARRAY
70434: PUSH
70435: LD_VAR 0 3
70439: ARRAY
70440: PUSH
70441: LD_INT 2
70443: ARRAY
70444: PPUSH
70445: LD_EXP 77
70449: PUSH
70450: LD_VAR 0 2
70454: ARRAY
70455: PUSH
70456: LD_VAR 0 3
70460: ARRAY
70461: PUSH
70462: LD_INT 3
70464: ARRAY
70465: PPUSH
70466: CALL_OW 284
70470: PUSH
70471: LD_INT 0
70473: EQUAL
70474: AND
70475: IFFALSE 70530
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
70477: LD_ADDR_VAR 0 5
70481: PUSH
70482: LD_EXP 77
70486: PUSH
70487: LD_VAR 0 2
70491: ARRAY
70492: PPUSH
70493: LD_VAR 0 3
70497: PPUSH
70498: CALL_OW 3
70502: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
70503: LD_ADDR_EXP 77
70507: PUSH
70508: LD_EXP 77
70512: PPUSH
70513: LD_VAR 0 2
70517: PPUSH
70518: LD_VAR 0 5
70522: PPUSH
70523: CALL_OW 1
70527: ST_TO_ADDR
// continue ;
70528: GO 70374
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70530: LD_VAR 0 6
70534: PPUSH
70535: LD_EXP 77
70539: PUSH
70540: LD_VAR 0 2
70544: ARRAY
70545: PUSH
70546: LD_VAR 0 3
70550: ARRAY
70551: PUSH
70552: LD_INT 2
70554: ARRAY
70555: PPUSH
70556: LD_EXP 77
70560: PUSH
70561: LD_VAR 0 2
70565: ARRAY
70566: PUSH
70567: LD_VAR 0 3
70571: ARRAY
70572: PUSH
70573: LD_INT 3
70575: ARRAY
70576: PPUSH
70577: LD_INT 30
70579: PPUSH
70580: CALL 21337 0 4
70584: PUSH
70585: LD_INT 4
70587: ARRAY
70588: PUSH
70589: LD_INT 0
70591: EQUAL
70592: IFFALSE 70618
// begin target := mc_crates [ i ] [ j ] ;
70594: LD_ADDR_VAR 0 7
70598: PUSH
70599: LD_EXP 77
70603: PUSH
70604: LD_VAR 0 2
70608: ARRAY
70609: PUSH
70610: LD_VAR 0 3
70614: ARRAY
70615: ST_TO_ADDR
// break ;
70616: GO 70620
// end ; end ;
70618: GO 70374
70620: POP
70621: POP
// if not target then
70622: LD_VAR 0 7
70626: NOT
70627: IFFALSE 70631
// continue ;
70629: GO 70181
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
70631: LD_ADDR_VAR 0 8
70635: PUSH
70636: LD_EXP 80
70640: PUSH
70641: LD_VAR 0 2
70645: ARRAY
70646: PPUSH
70647: LD_INT 2
70649: PUSH
70650: LD_INT 3
70652: PUSH
70653: LD_INT 58
70655: PUSH
70656: EMPTY
70657: LIST
70658: PUSH
70659: EMPTY
70660: LIST
70661: LIST
70662: PUSH
70663: LD_INT 61
70665: PUSH
70666: EMPTY
70667: LIST
70668: PUSH
70669: LD_INT 33
70671: PUSH
70672: LD_INT 5
70674: PUSH
70675: EMPTY
70676: LIST
70677: LIST
70678: PUSH
70679: LD_INT 33
70681: PUSH
70682: LD_INT 3
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: PUSH
70689: EMPTY
70690: LIST
70691: LIST
70692: LIST
70693: LIST
70694: LIST
70695: PUSH
70696: LD_INT 2
70698: PUSH
70699: LD_INT 34
70701: PUSH
70702: LD_INT 32
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: LD_INT 34
70711: PUSH
70712: LD_INT 51
70714: PUSH
70715: EMPTY
70716: LIST
70717: LIST
70718: PUSH
70719: LD_INT 34
70721: PUSH
70722: LD_INT 12
70724: PUSH
70725: EMPTY
70726: LIST
70727: LIST
70728: PUSH
70729: EMPTY
70730: LIST
70731: LIST
70732: LIST
70733: LIST
70734: PUSH
70735: EMPTY
70736: LIST
70737: LIST
70738: PPUSH
70739: CALL_OW 72
70743: ST_TO_ADDR
// if not cargo then
70744: LD_VAR 0 8
70748: NOT
70749: IFFALSE 71455
// begin if mc_crates_collector [ i ] < 5 then
70751: LD_EXP 78
70755: PUSH
70756: LD_VAR 0 2
70760: ARRAY
70761: PUSH
70762: LD_INT 5
70764: LESS
70765: IFFALSE 71131
// begin if mc_ape [ i ] then
70767: LD_EXP 90
70771: PUSH
70772: LD_VAR 0 2
70776: ARRAY
70777: IFFALSE 70824
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
70779: LD_ADDR_VAR 0 5
70783: PUSH
70784: LD_EXP 90
70788: PUSH
70789: LD_VAR 0 2
70793: ARRAY
70794: PPUSH
70795: LD_INT 25
70797: PUSH
70798: LD_INT 16
70800: PUSH
70801: EMPTY
70802: LIST
70803: LIST
70804: PUSH
70805: LD_INT 24
70807: PUSH
70808: LD_INT 750
70810: PUSH
70811: EMPTY
70812: LIST
70813: LIST
70814: PUSH
70815: EMPTY
70816: LIST
70817: LIST
70818: PPUSH
70819: CALL_OW 72
70823: ST_TO_ADDR
// if not tmp then
70824: LD_VAR 0 5
70828: NOT
70829: IFFALSE 70876
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
70831: LD_ADDR_VAR 0 5
70835: PUSH
70836: LD_EXP 61
70840: PUSH
70841: LD_VAR 0 2
70845: ARRAY
70846: PPUSH
70847: LD_INT 25
70849: PUSH
70850: LD_INT 2
70852: PUSH
70853: EMPTY
70854: LIST
70855: LIST
70856: PUSH
70857: LD_INT 24
70859: PUSH
70860: LD_INT 750
70862: PUSH
70863: EMPTY
70864: LIST
70865: LIST
70866: PUSH
70867: EMPTY
70868: LIST
70869: LIST
70870: PPUSH
70871: CALL_OW 72
70875: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
70876: LD_EXP 90
70880: PUSH
70881: LD_VAR 0 2
70885: ARRAY
70886: PUSH
70887: LD_EXP 61
70891: PUSH
70892: LD_VAR 0 2
70896: ARRAY
70897: PPUSH
70898: LD_INT 25
70900: PUSH
70901: LD_INT 2
70903: PUSH
70904: EMPTY
70905: LIST
70906: LIST
70907: PUSH
70908: LD_INT 24
70910: PUSH
70911: LD_INT 750
70913: PUSH
70914: EMPTY
70915: LIST
70916: LIST
70917: PUSH
70918: EMPTY
70919: LIST
70920: LIST
70921: PPUSH
70922: CALL_OW 72
70926: AND
70927: PUSH
70928: LD_VAR 0 5
70932: PUSH
70933: LD_INT 5
70935: LESS
70936: AND
70937: IFFALSE 71019
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
70939: LD_ADDR_VAR 0 3
70943: PUSH
70944: LD_EXP 61
70948: PUSH
70949: LD_VAR 0 2
70953: ARRAY
70954: PPUSH
70955: LD_INT 25
70957: PUSH
70958: LD_INT 2
70960: PUSH
70961: EMPTY
70962: LIST
70963: LIST
70964: PUSH
70965: LD_INT 24
70967: PUSH
70968: LD_INT 750
70970: PUSH
70971: EMPTY
70972: LIST
70973: LIST
70974: PUSH
70975: EMPTY
70976: LIST
70977: LIST
70978: PPUSH
70979: CALL_OW 72
70983: PUSH
70984: FOR_IN
70985: IFFALSE 71017
// begin tmp := tmp union j ;
70987: LD_ADDR_VAR 0 5
70991: PUSH
70992: LD_VAR 0 5
70996: PUSH
70997: LD_VAR 0 3
71001: UNION
71002: ST_TO_ADDR
// if tmp >= 5 then
71003: LD_VAR 0 5
71007: PUSH
71008: LD_INT 5
71010: GREATEREQUAL
71011: IFFALSE 71015
// break ;
71013: GO 71017
// end ;
71015: GO 70984
71017: POP
71018: POP
// end ; if not tmp then
71019: LD_VAR 0 5
71023: NOT
71024: IFFALSE 71028
// continue ;
71026: GO 70181
// for j in tmp do
71028: LD_ADDR_VAR 0 3
71032: PUSH
71033: LD_VAR 0 5
71037: PUSH
71038: FOR_IN
71039: IFFALSE 71129
// if not GetTag ( j ) then
71041: LD_VAR 0 3
71045: PPUSH
71046: CALL_OW 110
71050: NOT
71051: IFFALSE 71127
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
71053: LD_ADDR_EXP 78
71057: PUSH
71058: LD_EXP 78
71062: PPUSH
71063: LD_VAR 0 2
71067: PUSH
71068: LD_EXP 78
71072: PUSH
71073: LD_VAR 0 2
71077: ARRAY
71078: PUSH
71079: LD_INT 1
71081: PLUS
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: PPUSH
71087: LD_VAR 0 3
71091: PPUSH
71092: CALL 20441 0 3
71096: ST_TO_ADDR
// SetTag ( j , 107 ) ;
71097: LD_VAR 0 3
71101: PPUSH
71102: LD_INT 107
71104: PPUSH
71105: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
71109: LD_EXP 78
71113: PUSH
71114: LD_VAR 0 2
71118: ARRAY
71119: PUSH
71120: LD_INT 5
71122: GREATEREQUAL
71123: IFFALSE 71127
// break ;
71125: GO 71129
// end ;
71127: GO 71038
71129: POP
71130: POP
// end ; if mc_crates_collector [ i ] and target then
71131: LD_EXP 78
71135: PUSH
71136: LD_VAR 0 2
71140: ARRAY
71141: PUSH
71142: LD_VAR 0 7
71146: AND
71147: IFFALSE 71453
// begin if mc_crates_collector [ i ] < target [ 1 ] then
71149: LD_EXP 78
71153: PUSH
71154: LD_VAR 0 2
71158: ARRAY
71159: PUSH
71160: LD_VAR 0 7
71164: PUSH
71165: LD_INT 1
71167: ARRAY
71168: LESS
71169: IFFALSE 71189
// tmp := mc_crates_collector [ i ] else
71171: LD_ADDR_VAR 0 5
71175: PUSH
71176: LD_EXP 78
71180: PUSH
71181: LD_VAR 0 2
71185: ARRAY
71186: ST_TO_ADDR
71187: GO 71203
// tmp := target [ 1 ] ;
71189: LD_ADDR_VAR 0 5
71193: PUSH
71194: LD_VAR 0 7
71198: PUSH
71199: LD_INT 1
71201: ARRAY
71202: ST_TO_ADDR
// k := 0 ;
71203: LD_ADDR_VAR 0 4
71207: PUSH
71208: LD_INT 0
71210: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
71211: LD_ADDR_VAR 0 3
71215: PUSH
71216: LD_EXP 78
71220: PUSH
71221: LD_VAR 0 2
71225: ARRAY
71226: PUSH
71227: FOR_IN
71228: IFFALSE 71451
// begin k := k + 1 ;
71230: LD_ADDR_VAR 0 4
71234: PUSH
71235: LD_VAR 0 4
71239: PUSH
71240: LD_INT 1
71242: PLUS
71243: ST_TO_ADDR
// if k > tmp then
71244: LD_VAR 0 4
71248: PUSH
71249: LD_VAR 0 5
71253: GREATER
71254: IFFALSE 71258
// break ;
71256: GO 71451
// if not GetClass ( j ) in [ 2 , 16 ] then
71258: LD_VAR 0 3
71262: PPUSH
71263: CALL_OW 257
71267: PUSH
71268: LD_INT 2
71270: PUSH
71271: LD_INT 16
71273: PUSH
71274: EMPTY
71275: LIST
71276: LIST
71277: IN
71278: NOT
71279: IFFALSE 71332
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
71281: LD_ADDR_EXP 78
71285: PUSH
71286: LD_EXP 78
71290: PPUSH
71291: LD_VAR 0 2
71295: PPUSH
71296: LD_EXP 78
71300: PUSH
71301: LD_VAR 0 2
71305: ARRAY
71306: PUSH
71307: LD_VAR 0 3
71311: DIFF
71312: PPUSH
71313: CALL_OW 1
71317: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71318: LD_VAR 0 3
71322: PPUSH
71323: LD_INT 0
71325: PPUSH
71326: CALL_OW 109
// continue ;
71330: GO 71227
// end ; if IsInUnit ( j ) then
71332: LD_VAR 0 3
71336: PPUSH
71337: CALL_OW 310
71341: IFFALSE 71352
// ComExitBuilding ( j ) ;
71343: LD_VAR 0 3
71347: PPUSH
71348: CALL_OW 122
// wait ( 3 ) ;
71352: LD_INT 3
71354: PPUSH
71355: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
71359: LD_VAR 0 3
71363: PPUSH
71364: CALL_OW 314
71368: PUSH
71369: LD_VAR 0 6
71373: PPUSH
71374: LD_VAR 0 7
71378: PUSH
71379: LD_INT 2
71381: ARRAY
71382: PPUSH
71383: LD_VAR 0 7
71387: PUSH
71388: LD_INT 3
71390: ARRAY
71391: PPUSH
71392: LD_INT 30
71394: PPUSH
71395: CALL 21337 0 4
71399: PUSH
71400: LD_INT 4
71402: ARRAY
71403: AND
71404: IFFALSE 71422
// ComStandNearbyBuilding ( j , depot ) else
71406: LD_VAR 0 3
71410: PPUSH
71411: LD_VAR 0 9
71415: PPUSH
71416: CALL 17043 0 2
71420: GO 71449
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71422: LD_VAR 0 3
71426: PPUSH
71427: LD_VAR 0 7
71431: PUSH
71432: LD_INT 2
71434: ARRAY
71435: PPUSH
71436: LD_VAR 0 7
71440: PUSH
71441: LD_INT 3
71443: ARRAY
71444: PPUSH
71445: CALL_OW 117
// end ;
71449: GO 71227
71451: POP
71452: POP
// end ; end else
71453: GO 71985
// begin for j in cargo do
71455: LD_ADDR_VAR 0 3
71459: PUSH
71460: LD_VAR 0 8
71464: PUSH
71465: FOR_IN
71466: IFFALSE 71983
// begin if GetTag ( j ) <> 0 then
71468: LD_VAR 0 3
71472: PPUSH
71473: CALL_OW 110
71477: PUSH
71478: LD_INT 0
71480: NONEQUAL
71481: IFFALSE 71485
// continue ;
71483: GO 71465
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
71485: LD_VAR 0 3
71489: PPUSH
71490: CALL_OW 256
71494: PUSH
71495: LD_INT 1000
71497: LESS
71498: PUSH
71499: LD_VAR 0 3
71503: PPUSH
71504: LD_EXP 85
71508: PUSH
71509: LD_VAR 0 2
71513: ARRAY
71514: PPUSH
71515: CALL_OW 308
71519: NOT
71520: AND
71521: IFFALSE 71543
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71523: LD_VAR 0 3
71527: PPUSH
71528: LD_EXP 85
71532: PUSH
71533: LD_VAR 0 2
71537: ARRAY
71538: PPUSH
71539: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71543: LD_VAR 0 3
71547: PPUSH
71548: CALL_OW 256
71552: PUSH
71553: LD_INT 1000
71555: LESS
71556: PUSH
71557: LD_VAR 0 3
71561: PPUSH
71562: LD_EXP 85
71566: PUSH
71567: LD_VAR 0 2
71571: ARRAY
71572: PPUSH
71573: CALL_OW 308
71577: AND
71578: IFFALSE 71582
// continue ;
71580: GO 71465
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71582: LD_VAR 0 3
71586: PPUSH
71587: CALL_OW 262
71591: PUSH
71592: LD_INT 2
71594: EQUAL
71595: PUSH
71596: LD_VAR 0 3
71600: PPUSH
71601: CALL_OW 261
71605: PUSH
71606: LD_INT 15
71608: LESS
71609: AND
71610: IFFALSE 71614
// continue ;
71612: GO 71465
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71614: LD_VAR 0 3
71618: PPUSH
71619: CALL_OW 262
71623: PUSH
71624: LD_INT 1
71626: EQUAL
71627: PUSH
71628: LD_VAR 0 3
71632: PPUSH
71633: CALL_OW 261
71637: PUSH
71638: LD_INT 10
71640: LESS
71641: AND
71642: IFFALSE 71922
// begin if not depot then
71644: LD_VAR 0 9
71648: NOT
71649: IFFALSE 71653
// continue ;
71651: GO 71465
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
71653: LD_VAR 0 3
71657: PPUSH
71658: LD_VAR 0 9
71662: PPUSH
71663: LD_VAR 0 3
71667: PPUSH
71668: CALL_OW 74
71672: PPUSH
71673: CALL_OW 296
71677: PUSH
71678: LD_INT 6
71680: LESS
71681: IFFALSE 71697
// SetFuel ( j , 100 ) else
71683: LD_VAR 0 3
71687: PPUSH
71688: LD_INT 100
71690: PPUSH
71691: CALL_OW 240
71695: GO 71922
// if GetFuel ( j ) = 0 then
71697: LD_VAR 0 3
71701: PPUSH
71702: CALL_OW 261
71706: PUSH
71707: LD_INT 0
71709: EQUAL
71710: IFFALSE 71922
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
71712: LD_ADDR_EXP 80
71716: PUSH
71717: LD_EXP 80
71721: PPUSH
71722: LD_VAR 0 2
71726: PPUSH
71727: LD_EXP 80
71731: PUSH
71732: LD_VAR 0 2
71736: ARRAY
71737: PUSH
71738: LD_VAR 0 3
71742: DIFF
71743: PPUSH
71744: CALL_OW 1
71748: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
71749: LD_VAR 0 3
71753: PPUSH
71754: CALL_OW 263
71758: PUSH
71759: LD_INT 1
71761: EQUAL
71762: IFFALSE 71778
// ComExitVehicle ( IsInUnit ( j ) ) ;
71764: LD_VAR 0 3
71768: PPUSH
71769: CALL_OW 310
71773: PPUSH
71774: CALL_OW 121
// if GetControl ( j ) = control_remote then
71778: LD_VAR 0 3
71782: PPUSH
71783: CALL_OW 263
71787: PUSH
71788: LD_INT 2
71790: EQUAL
71791: IFFALSE 71802
// ComUnlink ( j ) ;
71793: LD_VAR 0 3
71797: PPUSH
71798: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
71802: LD_ADDR_VAR 0 10
71806: PUSH
71807: LD_VAR 0 2
71811: PPUSH
71812: LD_INT 3
71814: PPUSH
71815: CALL 81566 0 2
71819: ST_TO_ADDR
// if fac then
71820: LD_VAR 0 10
71824: IFFALSE 71920
// begin for k in fac do
71826: LD_ADDR_VAR 0 4
71830: PUSH
71831: LD_VAR 0 10
71835: PUSH
71836: FOR_IN
71837: IFFALSE 71918
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
71839: LD_ADDR_VAR 0 11
71843: PUSH
71844: LD_VAR 0 10
71848: PPUSH
71849: LD_VAR 0 3
71853: PPUSH
71854: CALL_OW 265
71858: PPUSH
71859: LD_VAR 0 3
71863: PPUSH
71864: CALL_OW 262
71868: PPUSH
71869: LD_VAR 0 3
71873: PPUSH
71874: CALL_OW 263
71878: PPUSH
71879: LD_VAR 0 3
71883: PPUSH
71884: CALL_OW 264
71888: PPUSH
71889: CALL 17939 0 5
71893: ST_TO_ADDR
// if components then
71894: LD_VAR 0 11
71898: IFFALSE 71916
// begin MC_InsertProduceList ( i , components ) ;
71900: LD_VAR 0 2
71904: PPUSH
71905: LD_VAR 0 11
71909: PPUSH
71910: CALL 81111 0 2
// break ;
71914: GO 71918
// end ; end ;
71916: GO 71836
71918: POP
71919: POP
// end ; continue ;
71920: GO 71465
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
71922: LD_VAR 0 3
71926: PPUSH
71927: LD_INT 1
71929: PPUSH
71930: CALL_OW 289
71934: PUSH
71935: LD_INT 100
71937: LESS
71938: PUSH
71939: LD_VAR 0 3
71943: PPUSH
71944: CALL_OW 314
71948: NOT
71949: AND
71950: IFFALSE 71979
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71952: LD_VAR 0 3
71956: PPUSH
71957: LD_VAR 0 7
71961: PUSH
71962: LD_INT 2
71964: ARRAY
71965: PPUSH
71966: LD_VAR 0 7
71970: PUSH
71971: LD_INT 3
71973: ARRAY
71974: PPUSH
71975: CALL_OW 117
// break ;
71979: GO 71983
// end ;
71981: GO 71465
71983: POP
71984: POP
// end ; end ;
71985: GO 70181
71987: POP
71988: POP
// end ;
71989: LD_VAR 0 1
71993: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
71994: LD_INT 0
71996: PPUSH
71997: PPUSH
71998: PPUSH
71999: PPUSH
// if not mc_bases then
72000: LD_EXP 61
72004: NOT
72005: IFFALSE 72009
// exit ;
72007: GO 72170
// for i = 1 to mc_bases do
72009: LD_ADDR_VAR 0 2
72013: PUSH
72014: DOUBLE
72015: LD_INT 1
72017: DEC
72018: ST_TO_ADDR
72019: LD_EXP 61
72023: PUSH
72024: FOR_TO
72025: IFFALSE 72168
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
72027: LD_ADDR_VAR 0 4
72031: PUSH
72032: LD_EXP 80
72036: PUSH
72037: LD_VAR 0 2
72041: ARRAY
72042: PUSH
72043: LD_EXP 83
72047: PUSH
72048: LD_VAR 0 2
72052: ARRAY
72053: UNION
72054: PPUSH
72055: LD_INT 33
72057: PUSH
72058: LD_INT 2
72060: PUSH
72061: EMPTY
72062: LIST
72063: LIST
72064: PPUSH
72065: CALL_OW 72
72069: ST_TO_ADDR
// if tmp then
72070: LD_VAR 0 4
72074: IFFALSE 72166
// for j in tmp do
72076: LD_ADDR_VAR 0 3
72080: PUSH
72081: LD_VAR 0 4
72085: PUSH
72086: FOR_IN
72087: IFFALSE 72164
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
72089: LD_VAR 0 3
72093: PPUSH
72094: CALL_OW 312
72098: NOT
72099: PUSH
72100: LD_VAR 0 3
72104: PPUSH
72105: CALL_OW 256
72109: PUSH
72110: LD_INT 250
72112: GREATEREQUAL
72113: AND
72114: IFFALSE 72127
// Connect ( j ) else
72116: LD_VAR 0 3
72120: PPUSH
72121: CALL 23410 0 1
72125: GO 72162
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
72127: LD_VAR 0 3
72131: PPUSH
72132: CALL_OW 256
72136: PUSH
72137: LD_INT 250
72139: LESS
72140: PUSH
72141: LD_VAR 0 3
72145: PPUSH
72146: CALL_OW 312
72150: AND
72151: IFFALSE 72162
// ComUnlink ( j ) ;
72153: LD_VAR 0 3
72157: PPUSH
72158: CALL_OW 136
72162: GO 72086
72164: POP
72165: POP
// end ;
72166: GO 72024
72168: POP
72169: POP
// end ;
72170: LD_VAR 0 1
72174: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
72175: LD_INT 0
72177: PPUSH
72178: PPUSH
72179: PPUSH
72180: PPUSH
72181: PPUSH
// if not mc_bases then
72182: LD_EXP 61
72186: NOT
72187: IFFALSE 72191
// exit ;
72189: GO 72636
// for i = 1 to mc_bases do
72191: LD_ADDR_VAR 0 2
72195: PUSH
72196: DOUBLE
72197: LD_INT 1
72199: DEC
72200: ST_TO_ADDR
72201: LD_EXP 61
72205: PUSH
72206: FOR_TO
72207: IFFALSE 72634
// begin if not mc_produce [ i ] then
72209: LD_EXP 82
72213: PUSH
72214: LD_VAR 0 2
72218: ARRAY
72219: NOT
72220: IFFALSE 72224
// continue ;
72222: GO 72206
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72224: LD_ADDR_VAR 0 5
72228: PUSH
72229: LD_EXP 61
72233: PUSH
72234: LD_VAR 0 2
72238: ARRAY
72239: PPUSH
72240: LD_INT 30
72242: PUSH
72243: LD_INT 3
72245: PUSH
72246: EMPTY
72247: LIST
72248: LIST
72249: PPUSH
72250: CALL_OW 72
72254: ST_TO_ADDR
// if not fac then
72255: LD_VAR 0 5
72259: NOT
72260: IFFALSE 72264
// continue ;
72262: GO 72206
// for j in fac do
72264: LD_ADDR_VAR 0 3
72268: PUSH
72269: LD_VAR 0 5
72273: PUSH
72274: FOR_IN
72275: IFFALSE 72630
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
72277: LD_VAR 0 3
72281: PPUSH
72282: CALL_OW 461
72286: PUSH
72287: LD_INT 2
72289: NONEQUAL
72290: PUSH
72291: LD_VAR 0 3
72295: PPUSH
72296: LD_INT 15
72298: PPUSH
72299: CALL 23038 0 2
72303: PUSH
72304: LD_INT 4
72306: ARRAY
72307: OR
72308: IFFALSE 72312
// continue ;
72310: GO 72274
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
72312: LD_VAR 0 3
72316: PPUSH
72317: LD_EXP 82
72321: PUSH
72322: LD_VAR 0 2
72326: ARRAY
72327: PUSH
72328: LD_INT 1
72330: ARRAY
72331: PUSH
72332: LD_INT 1
72334: ARRAY
72335: PPUSH
72336: LD_EXP 82
72340: PUSH
72341: LD_VAR 0 2
72345: ARRAY
72346: PUSH
72347: LD_INT 1
72349: ARRAY
72350: PUSH
72351: LD_INT 2
72353: ARRAY
72354: PPUSH
72355: LD_EXP 82
72359: PUSH
72360: LD_VAR 0 2
72364: ARRAY
72365: PUSH
72366: LD_INT 1
72368: ARRAY
72369: PUSH
72370: LD_INT 3
72372: ARRAY
72373: PPUSH
72374: LD_EXP 82
72378: PUSH
72379: LD_VAR 0 2
72383: ARRAY
72384: PUSH
72385: LD_INT 1
72387: ARRAY
72388: PUSH
72389: LD_INT 4
72391: ARRAY
72392: PPUSH
72393: CALL_OW 448
72397: PUSH
72398: LD_VAR 0 3
72402: PPUSH
72403: LD_EXP 82
72407: PUSH
72408: LD_VAR 0 2
72412: ARRAY
72413: PUSH
72414: LD_INT 1
72416: ARRAY
72417: PUSH
72418: LD_INT 1
72420: ARRAY
72421: PUSH
72422: LD_EXP 82
72426: PUSH
72427: LD_VAR 0 2
72431: ARRAY
72432: PUSH
72433: LD_INT 1
72435: ARRAY
72436: PUSH
72437: LD_INT 2
72439: ARRAY
72440: PUSH
72441: LD_EXP 82
72445: PUSH
72446: LD_VAR 0 2
72450: ARRAY
72451: PUSH
72452: LD_INT 1
72454: ARRAY
72455: PUSH
72456: LD_INT 3
72458: ARRAY
72459: PUSH
72460: LD_EXP 82
72464: PUSH
72465: LD_VAR 0 2
72469: ARRAY
72470: PUSH
72471: LD_INT 1
72473: ARRAY
72474: PUSH
72475: LD_INT 4
72477: ARRAY
72478: PUSH
72479: EMPTY
72480: LIST
72481: LIST
72482: LIST
72483: LIST
72484: PPUSH
72485: CALL 26805 0 2
72489: AND
72490: IFFALSE 72628
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
72492: LD_VAR 0 3
72496: PPUSH
72497: LD_EXP 82
72501: PUSH
72502: LD_VAR 0 2
72506: ARRAY
72507: PUSH
72508: LD_INT 1
72510: ARRAY
72511: PUSH
72512: LD_INT 1
72514: ARRAY
72515: PPUSH
72516: LD_EXP 82
72520: PUSH
72521: LD_VAR 0 2
72525: ARRAY
72526: PUSH
72527: LD_INT 1
72529: ARRAY
72530: PUSH
72531: LD_INT 2
72533: ARRAY
72534: PPUSH
72535: LD_EXP 82
72539: PUSH
72540: LD_VAR 0 2
72544: ARRAY
72545: PUSH
72546: LD_INT 1
72548: ARRAY
72549: PUSH
72550: LD_INT 3
72552: ARRAY
72553: PPUSH
72554: LD_EXP 82
72558: PUSH
72559: LD_VAR 0 2
72563: ARRAY
72564: PUSH
72565: LD_INT 1
72567: ARRAY
72568: PUSH
72569: LD_INT 4
72571: ARRAY
72572: PPUSH
72573: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
72577: LD_ADDR_VAR 0 4
72581: PUSH
72582: LD_EXP 82
72586: PUSH
72587: LD_VAR 0 2
72591: ARRAY
72592: PPUSH
72593: LD_INT 1
72595: PPUSH
72596: CALL_OW 3
72600: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
72601: LD_ADDR_EXP 82
72605: PUSH
72606: LD_EXP 82
72610: PPUSH
72611: LD_VAR 0 2
72615: PPUSH
72616: LD_VAR 0 4
72620: PPUSH
72621: CALL_OW 1
72625: ST_TO_ADDR
// break ;
72626: GO 72630
// end ; end ;
72628: GO 72274
72630: POP
72631: POP
// end ;
72632: GO 72206
72634: POP
72635: POP
// end ;
72636: LD_VAR 0 1
72640: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
72641: LD_INT 0
72643: PPUSH
72644: PPUSH
72645: PPUSH
// if not mc_bases then
72646: LD_EXP 61
72650: NOT
72651: IFFALSE 72655
// exit ;
72653: GO 72744
// for i = 1 to mc_bases do
72655: LD_ADDR_VAR 0 2
72659: PUSH
72660: DOUBLE
72661: LD_INT 1
72663: DEC
72664: ST_TO_ADDR
72665: LD_EXP 61
72669: PUSH
72670: FOR_TO
72671: IFFALSE 72742
// begin if mc_attack [ i ] then
72673: LD_EXP 81
72677: PUSH
72678: LD_VAR 0 2
72682: ARRAY
72683: IFFALSE 72740
// begin tmp := mc_attack [ i ] [ 1 ] ;
72685: LD_ADDR_VAR 0 3
72689: PUSH
72690: LD_EXP 81
72694: PUSH
72695: LD_VAR 0 2
72699: ARRAY
72700: PUSH
72701: LD_INT 1
72703: ARRAY
72704: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
72705: LD_ADDR_EXP 81
72709: PUSH
72710: LD_EXP 81
72714: PPUSH
72715: LD_VAR 0 2
72719: PPUSH
72720: EMPTY
72721: PPUSH
72722: CALL_OW 1
72726: ST_TO_ADDR
// Attack ( tmp ) ;
72727: LD_VAR 0 3
72731: PPUSH
72732: CALL 107628 0 1
// exit ;
72736: POP
72737: POP
72738: GO 72744
// end ; end ;
72740: GO 72670
72742: POP
72743: POP
// end ;
72744: LD_VAR 0 1
72748: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
72749: LD_INT 0
72751: PPUSH
72752: PPUSH
72753: PPUSH
72754: PPUSH
72755: PPUSH
72756: PPUSH
72757: PPUSH
// if not mc_bases then
72758: LD_EXP 61
72762: NOT
72763: IFFALSE 72767
// exit ;
72765: GO 73624
// for i = 1 to mc_bases do
72767: LD_ADDR_VAR 0 2
72771: PUSH
72772: DOUBLE
72773: LD_INT 1
72775: DEC
72776: ST_TO_ADDR
72777: LD_EXP 61
72781: PUSH
72782: FOR_TO
72783: IFFALSE 73622
// begin if not mc_bases [ i ] then
72785: LD_EXP 61
72789: PUSH
72790: LD_VAR 0 2
72794: ARRAY
72795: NOT
72796: IFFALSE 72800
// continue ;
72798: GO 72782
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
72800: LD_ADDR_VAR 0 7
72804: PUSH
72805: LD_EXP 61
72809: PUSH
72810: LD_VAR 0 2
72814: ARRAY
72815: PUSH
72816: LD_INT 1
72818: ARRAY
72819: PPUSH
72820: CALL 17265 0 1
72824: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
72825: LD_ADDR_EXP 84
72829: PUSH
72830: LD_EXP 84
72834: PPUSH
72835: LD_VAR 0 2
72839: PPUSH
72840: LD_EXP 61
72844: PUSH
72845: LD_VAR 0 2
72849: ARRAY
72850: PUSH
72851: LD_INT 1
72853: ARRAY
72854: PPUSH
72855: CALL_OW 255
72859: PPUSH
72860: LD_EXP 86
72864: PUSH
72865: LD_VAR 0 2
72869: ARRAY
72870: PPUSH
72871: CALL 17230 0 2
72875: PPUSH
72876: CALL_OW 1
72880: ST_TO_ADDR
// if not mc_scan [ i ] then
72881: LD_EXP 84
72885: PUSH
72886: LD_VAR 0 2
72890: ARRAY
72891: NOT
72892: IFFALSE 73070
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
72894: LD_ADDR_EXP 104
72898: PUSH
72899: LD_EXP 104
72903: PPUSH
72904: LD_VAR 0 2
72908: PPUSH
72909: LD_INT 0
72911: PPUSH
72912: CALL_OW 1
72916: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72917: LD_ADDR_VAR 0 4
72921: PUSH
72922: LD_EXP 61
72926: PUSH
72927: LD_VAR 0 2
72931: ARRAY
72932: PPUSH
72933: LD_INT 2
72935: PUSH
72936: LD_INT 25
72938: PUSH
72939: LD_INT 5
72941: PUSH
72942: EMPTY
72943: LIST
72944: LIST
72945: PUSH
72946: LD_INT 25
72948: PUSH
72949: LD_INT 8
72951: PUSH
72952: EMPTY
72953: LIST
72954: LIST
72955: PUSH
72956: LD_INT 25
72958: PUSH
72959: LD_INT 9
72961: PUSH
72962: EMPTY
72963: LIST
72964: LIST
72965: PUSH
72966: EMPTY
72967: LIST
72968: LIST
72969: LIST
72970: LIST
72971: PPUSH
72972: CALL_OW 72
72976: ST_TO_ADDR
// if not tmp then
72977: LD_VAR 0 4
72981: NOT
72982: IFFALSE 72986
// continue ;
72984: GO 72782
// for j in tmp do
72986: LD_ADDR_VAR 0 3
72990: PUSH
72991: LD_VAR 0 4
72995: PUSH
72996: FOR_IN
72997: IFFALSE 73068
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
72999: LD_VAR 0 3
73003: PPUSH
73004: CALL_OW 310
73008: PPUSH
73009: CALL_OW 266
73013: PUSH
73014: LD_INT 5
73016: EQUAL
73017: PUSH
73018: LD_VAR 0 3
73022: PPUSH
73023: CALL_OW 257
73027: PUSH
73028: LD_INT 1
73030: EQUAL
73031: AND
73032: PUSH
73033: LD_VAR 0 3
73037: PPUSH
73038: CALL_OW 459
73042: NOT
73043: AND
73044: PUSH
73045: LD_VAR 0 7
73049: AND
73050: IFFALSE 73066
// ComChangeProfession ( j , class ) ;
73052: LD_VAR 0 3
73056: PPUSH
73057: LD_VAR 0 7
73061: PPUSH
73062: CALL_OW 123
73066: GO 72996
73068: POP
73069: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
73070: LD_EXP 84
73074: PUSH
73075: LD_VAR 0 2
73079: ARRAY
73080: PUSH
73081: LD_EXP 104
73085: PUSH
73086: LD_VAR 0 2
73090: ARRAY
73091: NOT
73092: AND
73093: PUSH
73094: LD_EXP 83
73098: PUSH
73099: LD_VAR 0 2
73103: ARRAY
73104: NOT
73105: AND
73106: PUSH
73107: LD_EXP 61
73111: PUSH
73112: LD_VAR 0 2
73116: ARRAY
73117: PPUSH
73118: LD_INT 50
73120: PUSH
73121: EMPTY
73122: LIST
73123: PUSH
73124: LD_INT 2
73126: PUSH
73127: LD_INT 30
73129: PUSH
73130: LD_INT 32
73132: PUSH
73133: EMPTY
73134: LIST
73135: LIST
73136: PUSH
73137: LD_INT 30
73139: PUSH
73140: LD_INT 33
73142: PUSH
73143: EMPTY
73144: LIST
73145: LIST
73146: PUSH
73147: LD_INT 30
73149: PUSH
73150: LD_INT 4
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: PUSH
73157: LD_INT 30
73159: PUSH
73160: LD_INT 5
73162: PUSH
73163: EMPTY
73164: LIST
73165: LIST
73166: PUSH
73167: EMPTY
73168: LIST
73169: LIST
73170: LIST
73171: LIST
73172: LIST
73173: PUSH
73174: EMPTY
73175: LIST
73176: LIST
73177: PPUSH
73178: CALL_OW 72
73182: PUSH
73183: LD_INT 4
73185: LESS
73186: PUSH
73187: LD_EXP 61
73191: PUSH
73192: LD_VAR 0 2
73196: ARRAY
73197: PPUSH
73198: LD_INT 3
73200: PUSH
73201: LD_INT 24
73203: PUSH
73204: LD_INT 1000
73206: PUSH
73207: EMPTY
73208: LIST
73209: LIST
73210: PUSH
73211: EMPTY
73212: LIST
73213: LIST
73214: PUSH
73215: LD_INT 2
73217: PUSH
73218: LD_INT 30
73220: PUSH
73221: LD_INT 0
73223: PUSH
73224: EMPTY
73225: LIST
73226: LIST
73227: PUSH
73228: LD_INT 30
73230: PUSH
73231: LD_INT 1
73233: PUSH
73234: EMPTY
73235: LIST
73236: LIST
73237: PUSH
73238: EMPTY
73239: LIST
73240: LIST
73241: LIST
73242: PUSH
73243: EMPTY
73244: LIST
73245: LIST
73246: PPUSH
73247: CALL_OW 72
73251: OR
73252: AND
73253: IFFALSE 73504
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
73255: LD_ADDR_EXP 104
73259: PUSH
73260: LD_EXP 104
73264: PPUSH
73265: LD_VAR 0 2
73269: PPUSH
73270: LD_INT 1
73272: PPUSH
73273: CALL_OW 1
73277: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73278: LD_ADDR_VAR 0 4
73282: PUSH
73283: LD_EXP 61
73287: PUSH
73288: LD_VAR 0 2
73292: ARRAY
73293: PPUSH
73294: LD_INT 2
73296: PUSH
73297: LD_INT 25
73299: PUSH
73300: LD_INT 1
73302: PUSH
73303: EMPTY
73304: LIST
73305: LIST
73306: PUSH
73307: LD_INT 25
73309: PUSH
73310: LD_INT 5
73312: PUSH
73313: EMPTY
73314: LIST
73315: LIST
73316: PUSH
73317: LD_INT 25
73319: PUSH
73320: LD_INT 8
73322: PUSH
73323: EMPTY
73324: LIST
73325: LIST
73326: PUSH
73327: LD_INT 25
73329: PUSH
73330: LD_INT 9
73332: PUSH
73333: EMPTY
73334: LIST
73335: LIST
73336: PUSH
73337: EMPTY
73338: LIST
73339: LIST
73340: LIST
73341: LIST
73342: LIST
73343: PPUSH
73344: CALL_OW 72
73348: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
73349: LD_ADDR_VAR 0 4
73353: PUSH
73354: LD_VAR 0 4
73358: PUSH
73359: LD_VAR 0 4
73363: PPUSH
73364: LD_INT 18
73366: PPUSH
73367: CALL 50353 0 2
73371: DIFF
73372: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
73373: LD_VAR 0 4
73377: NOT
73378: PUSH
73379: LD_EXP 61
73383: PUSH
73384: LD_VAR 0 2
73388: ARRAY
73389: PPUSH
73390: LD_INT 2
73392: PUSH
73393: LD_INT 30
73395: PUSH
73396: LD_INT 4
73398: PUSH
73399: EMPTY
73400: LIST
73401: LIST
73402: PUSH
73403: LD_INT 30
73405: PUSH
73406: LD_INT 5
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: PUSH
73413: EMPTY
73414: LIST
73415: LIST
73416: LIST
73417: PPUSH
73418: CALL_OW 72
73422: NOT
73423: AND
73424: IFFALSE 73486
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
73426: LD_ADDR_VAR 0 4
73430: PUSH
73431: LD_EXP 61
73435: PUSH
73436: LD_VAR 0 2
73440: ARRAY
73441: PPUSH
73442: LD_INT 2
73444: PUSH
73445: LD_INT 25
73447: PUSH
73448: LD_INT 2
73450: PUSH
73451: EMPTY
73452: LIST
73453: LIST
73454: PUSH
73455: LD_INT 25
73457: PUSH
73458: LD_INT 3
73460: PUSH
73461: EMPTY
73462: LIST
73463: LIST
73464: PUSH
73465: LD_INT 25
73467: PUSH
73468: LD_INT 4
73470: PUSH
73471: EMPTY
73472: LIST
73473: LIST
73474: PUSH
73475: EMPTY
73476: LIST
73477: LIST
73478: LIST
73479: LIST
73480: PPUSH
73481: CALL_OW 72
73485: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
73486: LD_VAR 0 2
73490: PPUSH
73491: LD_VAR 0 4
73495: PPUSH
73496: CALL 112337 0 2
// exit ;
73500: POP
73501: POP
73502: GO 73624
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
73504: LD_EXP 84
73508: PUSH
73509: LD_VAR 0 2
73513: ARRAY
73514: PUSH
73515: LD_EXP 104
73519: PUSH
73520: LD_VAR 0 2
73524: ARRAY
73525: NOT
73526: AND
73527: PUSH
73528: LD_EXP 83
73532: PUSH
73533: LD_VAR 0 2
73537: ARRAY
73538: AND
73539: IFFALSE 73620
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
73541: LD_ADDR_EXP 104
73545: PUSH
73546: LD_EXP 104
73550: PPUSH
73551: LD_VAR 0 2
73555: PPUSH
73556: LD_INT 1
73558: PPUSH
73559: CALL_OW 1
73563: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
73564: LD_ADDR_VAR 0 4
73568: PUSH
73569: LD_EXP 83
73573: PUSH
73574: LD_VAR 0 2
73578: ARRAY
73579: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
73580: LD_ADDR_EXP 83
73584: PUSH
73585: LD_EXP 83
73589: PPUSH
73590: LD_VAR 0 2
73594: PPUSH
73595: EMPTY
73596: PPUSH
73597: CALL_OW 1
73601: ST_TO_ADDR
// Defend ( i , tmp ) ;
73602: LD_VAR 0 2
73606: PPUSH
73607: LD_VAR 0 4
73611: PPUSH
73612: CALL 112933 0 2
// exit ;
73616: POP
73617: POP
73618: GO 73624
// end ; end ;
73620: GO 72782
73622: POP
73623: POP
// end ;
73624: LD_VAR 0 1
73628: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73629: LD_INT 0
73631: PPUSH
73632: PPUSH
73633: PPUSH
73634: PPUSH
73635: PPUSH
73636: PPUSH
73637: PPUSH
73638: PPUSH
73639: PPUSH
73640: PPUSH
73641: PPUSH
// if not mc_bases then
73642: LD_EXP 61
73646: NOT
73647: IFFALSE 73651
// exit ;
73649: GO 74738
// for i = 1 to mc_bases do
73651: LD_ADDR_VAR 0 2
73655: PUSH
73656: DOUBLE
73657: LD_INT 1
73659: DEC
73660: ST_TO_ADDR
73661: LD_EXP 61
73665: PUSH
73666: FOR_TO
73667: IFFALSE 74736
// begin tmp := mc_lab [ i ] ;
73669: LD_ADDR_VAR 0 6
73673: PUSH
73674: LD_EXP 94
73678: PUSH
73679: LD_VAR 0 2
73683: ARRAY
73684: ST_TO_ADDR
// if not tmp then
73685: LD_VAR 0 6
73689: NOT
73690: IFFALSE 73694
// continue ;
73692: GO 73666
// idle_lab := 0 ;
73694: LD_ADDR_VAR 0 11
73698: PUSH
73699: LD_INT 0
73701: ST_TO_ADDR
// for j in tmp do
73702: LD_ADDR_VAR 0 3
73706: PUSH
73707: LD_VAR 0 6
73711: PUSH
73712: FOR_IN
73713: IFFALSE 74732
// begin researching := false ;
73715: LD_ADDR_VAR 0 10
73719: PUSH
73720: LD_INT 0
73722: ST_TO_ADDR
// side := GetSide ( j ) ;
73723: LD_ADDR_VAR 0 4
73727: PUSH
73728: LD_VAR 0 3
73732: PPUSH
73733: CALL_OW 255
73737: ST_TO_ADDR
// if not mc_tech [ side ] then
73738: LD_EXP 88
73742: PUSH
73743: LD_VAR 0 4
73747: ARRAY
73748: NOT
73749: IFFALSE 73753
// continue ;
73751: GO 73712
// if BuildingStatus ( j ) = bs_idle then
73753: LD_VAR 0 3
73757: PPUSH
73758: CALL_OW 461
73762: PUSH
73763: LD_INT 2
73765: EQUAL
73766: IFFALSE 73954
// begin if idle_lab and UnitsInside ( j ) < 6 then
73768: LD_VAR 0 11
73772: PUSH
73773: LD_VAR 0 3
73777: PPUSH
73778: CALL_OW 313
73782: PUSH
73783: LD_INT 6
73785: LESS
73786: AND
73787: IFFALSE 73858
// begin tmp2 := UnitsInside ( idle_lab ) ;
73789: LD_ADDR_VAR 0 9
73793: PUSH
73794: LD_VAR 0 11
73798: PPUSH
73799: CALL_OW 313
73803: ST_TO_ADDR
// if tmp2 then
73804: LD_VAR 0 9
73808: IFFALSE 73850
// for x in tmp2 do
73810: LD_ADDR_VAR 0 7
73814: PUSH
73815: LD_VAR 0 9
73819: PUSH
73820: FOR_IN
73821: IFFALSE 73848
// begin ComExitBuilding ( x ) ;
73823: LD_VAR 0 7
73827: PPUSH
73828: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73832: LD_VAR 0 7
73836: PPUSH
73837: LD_VAR 0 3
73841: PPUSH
73842: CALL_OW 180
// end ;
73846: GO 73820
73848: POP
73849: POP
// idle_lab := 0 ;
73850: LD_ADDR_VAR 0 11
73854: PUSH
73855: LD_INT 0
73857: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
73858: LD_ADDR_VAR 0 5
73862: PUSH
73863: LD_EXP 88
73867: PUSH
73868: LD_VAR 0 4
73872: ARRAY
73873: PUSH
73874: FOR_IN
73875: IFFALSE 73935
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
73877: LD_VAR 0 3
73881: PPUSH
73882: LD_VAR 0 5
73886: PPUSH
73887: CALL_OW 430
73891: PUSH
73892: LD_VAR 0 4
73896: PPUSH
73897: LD_VAR 0 5
73901: PPUSH
73902: CALL 16335 0 2
73906: AND
73907: IFFALSE 73933
// begin researching := true ;
73909: LD_ADDR_VAR 0 10
73913: PUSH
73914: LD_INT 1
73916: ST_TO_ADDR
// ComResearch ( j , t ) ;
73917: LD_VAR 0 3
73921: PPUSH
73922: LD_VAR 0 5
73926: PPUSH
73927: CALL_OW 124
// break ;
73931: GO 73935
// end ;
73933: GO 73874
73935: POP
73936: POP
// if not researching then
73937: LD_VAR 0 10
73941: NOT
73942: IFFALSE 73954
// idle_lab := j ;
73944: LD_ADDR_VAR 0 11
73948: PUSH
73949: LD_VAR 0 3
73953: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
73954: LD_VAR 0 3
73958: PPUSH
73959: CALL_OW 461
73963: PUSH
73964: LD_INT 10
73966: EQUAL
73967: IFFALSE 74555
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
73969: LD_EXP 90
73973: PUSH
73974: LD_VAR 0 2
73978: ARRAY
73979: NOT
73980: PUSH
73981: LD_EXP 91
73985: PUSH
73986: LD_VAR 0 2
73990: ARRAY
73991: NOT
73992: AND
73993: PUSH
73994: LD_EXP 88
73998: PUSH
73999: LD_VAR 0 4
74003: ARRAY
74004: PUSH
74005: LD_INT 1
74007: GREATER
74008: AND
74009: IFFALSE 74140
// begin ComCancel ( j ) ;
74011: LD_VAR 0 3
74015: PPUSH
74016: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
74020: LD_ADDR_EXP 88
74024: PUSH
74025: LD_EXP 88
74029: PPUSH
74030: LD_VAR 0 4
74034: PPUSH
74035: LD_EXP 88
74039: PUSH
74040: LD_VAR 0 4
74044: ARRAY
74045: PPUSH
74046: LD_EXP 88
74050: PUSH
74051: LD_VAR 0 4
74055: ARRAY
74056: PUSH
74057: LD_INT 1
74059: MINUS
74060: PPUSH
74061: LD_EXP 88
74065: PUSH
74066: LD_VAR 0 4
74070: ARRAY
74071: PPUSH
74072: LD_INT 0
74074: PPUSH
74075: CALL 19859 0 4
74079: PPUSH
74080: CALL_OW 1
74084: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
74085: LD_ADDR_EXP 88
74089: PUSH
74090: LD_EXP 88
74094: PPUSH
74095: LD_VAR 0 4
74099: PPUSH
74100: LD_EXP 88
74104: PUSH
74105: LD_VAR 0 4
74109: ARRAY
74110: PPUSH
74111: LD_EXP 88
74115: PUSH
74116: LD_VAR 0 4
74120: ARRAY
74121: PPUSH
74122: LD_INT 1
74124: PPUSH
74125: LD_INT 0
74127: PPUSH
74128: CALL 19859 0 4
74132: PPUSH
74133: CALL_OW 1
74137: ST_TO_ADDR
// continue ;
74138: GO 73712
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
74140: LD_EXP 90
74144: PUSH
74145: LD_VAR 0 2
74149: ARRAY
74150: PUSH
74151: LD_EXP 91
74155: PUSH
74156: LD_VAR 0 2
74160: ARRAY
74161: NOT
74162: AND
74163: IFFALSE 74290
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
74165: LD_ADDR_EXP 91
74169: PUSH
74170: LD_EXP 91
74174: PPUSH
74175: LD_VAR 0 2
74179: PUSH
74180: LD_EXP 91
74184: PUSH
74185: LD_VAR 0 2
74189: ARRAY
74190: PUSH
74191: LD_INT 1
74193: PLUS
74194: PUSH
74195: EMPTY
74196: LIST
74197: LIST
74198: PPUSH
74199: LD_EXP 90
74203: PUSH
74204: LD_VAR 0 2
74208: ARRAY
74209: PUSH
74210: LD_INT 1
74212: ARRAY
74213: PPUSH
74214: CALL 20441 0 3
74218: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
74219: LD_EXP 90
74223: PUSH
74224: LD_VAR 0 2
74228: ARRAY
74229: PUSH
74230: LD_INT 1
74232: ARRAY
74233: PPUSH
74234: LD_INT 112
74236: PPUSH
74237: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
74241: LD_ADDR_VAR 0 9
74245: PUSH
74246: LD_EXP 90
74250: PUSH
74251: LD_VAR 0 2
74255: ARRAY
74256: PPUSH
74257: LD_INT 1
74259: PPUSH
74260: CALL_OW 3
74264: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
74265: LD_ADDR_EXP 90
74269: PUSH
74270: LD_EXP 90
74274: PPUSH
74275: LD_VAR 0 2
74279: PPUSH
74280: LD_VAR 0 9
74284: PPUSH
74285: CALL_OW 1
74289: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
74290: LD_EXP 90
74294: PUSH
74295: LD_VAR 0 2
74299: ARRAY
74300: PUSH
74301: LD_EXP 91
74305: PUSH
74306: LD_VAR 0 2
74310: ARRAY
74311: AND
74312: PUSH
74313: LD_EXP 91
74317: PUSH
74318: LD_VAR 0 2
74322: ARRAY
74323: PUSH
74324: LD_INT 1
74326: ARRAY
74327: PPUSH
74328: CALL_OW 310
74332: NOT
74333: AND
74334: PUSH
74335: LD_VAR 0 3
74339: PPUSH
74340: CALL_OW 313
74344: PUSH
74345: LD_INT 6
74347: EQUAL
74348: AND
74349: IFFALSE 74405
// begin tmp2 := UnitsInside ( j ) ;
74351: LD_ADDR_VAR 0 9
74355: PUSH
74356: LD_VAR 0 3
74360: PPUSH
74361: CALL_OW 313
74365: ST_TO_ADDR
// if tmp2 = 6 then
74366: LD_VAR 0 9
74370: PUSH
74371: LD_INT 6
74373: EQUAL
74374: IFFALSE 74405
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
74376: LD_VAR 0 9
74380: PUSH
74381: LD_INT 1
74383: ARRAY
74384: PPUSH
74385: LD_INT 112
74387: PPUSH
74388: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
74392: LD_VAR 0 9
74396: PUSH
74397: LD_INT 1
74399: ARRAY
74400: PPUSH
74401: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
74405: LD_EXP 91
74409: PUSH
74410: LD_VAR 0 2
74414: ARRAY
74415: PUSH
74416: LD_EXP 91
74420: PUSH
74421: LD_VAR 0 2
74425: ARRAY
74426: PUSH
74427: LD_INT 1
74429: ARRAY
74430: PPUSH
74431: CALL_OW 314
74435: NOT
74436: AND
74437: PUSH
74438: LD_EXP 91
74442: PUSH
74443: LD_VAR 0 2
74447: ARRAY
74448: PUSH
74449: LD_INT 1
74451: ARRAY
74452: PPUSH
74453: CALL_OW 310
74457: NOT
74458: AND
74459: IFFALSE 74485
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
74461: LD_EXP 91
74465: PUSH
74466: LD_VAR 0 2
74470: ARRAY
74471: PUSH
74472: LD_INT 1
74474: ARRAY
74475: PPUSH
74476: LD_VAR 0 3
74480: PPUSH
74481: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
74485: LD_EXP 91
74489: PUSH
74490: LD_VAR 0 2
74494: ARRAY
74495: PUSH
74496: LD_INT 1
74498: ARRAY
74499: PPUSH
74500: CALL_OW 310
74504: PUSH
74505: LD_EXP 91
74509: PUSH
74510: LD_VAR 0 2
74514: ARRAY
74515: PUSH
74516: LD_INT 1
74518: ARRAY
74519: PPUSH
74520: CALL_OW 310
74524: PPUSH
74525: CALL_OW 461
74529: PUSH
74530: LD_INT 3
74532: NONEQUAL
74533: AND
74534: IFFALSE 74555
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74536: LD_EXP 91
74540: PUSH
74541: LD_VAR 0 2
74545: ARRAY
74546: PUSH
74547: LD_INT 1
74549: ARRAY
74550: PPUSH
74551: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74555: LD_VAR 0 3
74559: PPUSH
74560: CALL_OW 461
74564: PUSH
74565: LD_INT 6
74567: EQUAL
74568: PUSH
74569: LD_VAR 0 6
74573: PUSH
74574: LD_INT 1
74576: GREATER
74577: AND
74578: IFFALSE 74730
// begin sci := [ ] ;
74580: LD_ADDR_VAR 0 8
74584: PUSH
74585: EMPTY
74586: ST_TO_ADDR
// for x in ( tmp diff j ) do
74587: LD_ADDR_VAR 0 7
74591: PUSH
74592: LD_VAR 0 6
74596: PUSH
74597: LD_VAR 0 3
74601: DIFF
74602: PUSH
74603: FOR_IN
74604: IFFALSE 74656
// begin if sci = 6 then
74606: LD_VAR 0 8
74610: PUSH
74611: LD_INT 6
74613: EQUAL
74614: IFFALSE 74618
// break ;
74616: GO 74656
// if BuildingStatus ( x ) = bs_idle then
74618: LD_VAR 0 7
74622: PPUSH
74623: CALL_OW 461
74627: PUSH
74628: LD_INT 2
74630: EQUAL
74631: IFFALSE 74654
// sci := sci ^ UnitsInside ( x ) ;
74633: LD_ADDR_VAR 0 8
74637: PUSH
74638: LD_VAR 0 8
74642: PUSH
74643: LD_VAR 0 7
74647: PPUSH
74648: CALL_OW 313
74652: ADD
74653: ST_TO_ADDR
// end ;
74654: GO 74603
74656: POP
74657: POP
// if not sci then
74658: LD_VAR 0 8
74662: NOT
74663: IFFALSE 74667
// continue ;
74665: GO 73712
// for x in sci do
74667: LD_ADDR_VAR 0 7
74671: PUSH
74672: LD_VAR 0 8
74676: PUSH
74677: FOR_IN
74678: IFFALSE 74728
// if IsInUnit ( x ) and not HasTask ( x ) then
74680: LD_VAR 0 7
74684: PPUSH
74685: CALL_OW 310
74689: PUSH
74690: LD_VAR 0 7
74694: PPUSH
74695: CALL_OW 314
74699: NOT
74700: AND
74701: IFFALSE 74726
// begin ComExitBuilding ( x ) ;
74703: LD_VAR 0 7
74707: PPUSH
74708: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74712: LD_VAR 0 7
74716: PPUSH
74717: LD_VAR 0 3
74721: PPUSH
74722: CALL_OW 180
// end ;
74726: GO 74677
74728: POP
74729: POP
// end ; end ;
74730: GO 73712
74732: POP
74733: POP
// end ;
74734: GO 73666
74736: POP
74737: POP
// end ;
74738: LD_VAR 0 1
74742: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74743: LD_INT 0
74745: PPUSH
74746: PPUSH
// if not mc_bases then
74747: LD_EXP 61
74751: NOT
74752: IFFALSE 74756
// exit ;
74754: GO 74837
// for i = 1 to mc_bases do
74756: LD_ADDR_VAR 0 2
74760: PUSH
74761: DOUBLE
74762: LD_INT 1
74764: DEC
74765: ST_TO_ADDR
74766: LD_EXP 61
74770: PUSH
74771: FOR_TO
74772: IFFALSE 74835
// if mc_mines [ i ] and mc_miners [ i ] then
74774: LD_EXP 74
74778: PUSH
74779: LD_VAR 0 2
74783: ARRAY
74784: PUSH
74785: LD_EXP 75
74789: PUSH
74790: LD_VAR 0 2
74794: ARRAY
74795: AND
74796: IFFALSE 74833
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74798: LD_EXP 75
74802: PUSH
74803: LD_VAR 0 2
74807: ARRAY
74808: PUSH
74809: LD_INT 1
74811: ARRAY
74812: PPUSH
74813: CALL_OW 255
74817: PPUSH
74818: LD_EXP 74
74822: PUSH
74823: LD_VAR 0 2
74827: ARRAY
74828: PPUSH
74829: CALL 17418 0 2
74833: GO 74771
74835: POP
74836: POP
// end ;
74837: LD_VAR 0 1
74841: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
74842: LD_INT 0
74844: PPUSH
74845: PPUSH
74846: PPUSH
74847: PPUSH
74848: PPUSH
74849: PPUSH
74850: PPUSH
74851: PPUSH
// if not mc_bases or not mc_parking then
74852: LD_EXP 61
74856: NOT
74857: PUSH
74858: LD_EXP 85
74862: NOT
74863: OR
74864: IFFALSE 74868
// exit ;
74866: GO 75606
// for i = 1 to mc_bases do
74868: LD_ADDR_VAR 0 2
74872: PUSH
74873: DOUBLE
74874: LD_INT 1
74876: DEC
74877: ST_TO_ADDR
74878: LD_EXP 61
74882: PUSH
74883: FOR_TO
74884: IFFALSE 75604
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
74886: LD_EXP 61
74890: PUSH
74891: LD_VAR 0 2
74895: ARRAY
74896: NOT
74897: PUSH
74898: LD_EXP 85
74902: PUSH
74903: LD_VAR 0 2
74907: ARRAY
74908: NOT
74909: OR
74910: IFFALSE 74914
// continue ;
74912: GO 74883
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74914: LD_ADDR_VAR 0 5
74918: PUSH
74919: LD_EXP 61
74923: PUSH
74924: LD_VAR 0 2
74928: ARRAY
74929: PUSH
74930: LD_INT 1
74932: ARRAY
74933: PPUSH
74934: CALL_OW 255
74938: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74939: LD_ADDR_VAR 0 6
74943: PUSH
74944: LD_EXP 61
74948: PUSH
74949: LD_VAR 0 2
74953: ARRAY
74954: PPUSH
74955: LD_INT 30
74957: PUSH
74958: LD_INT 3
74960: PUSH
74961: EMPTY
74962: LIST
74963: LIST
74964: PPUSH
74965: CALL_OW 72
74969: ST_TO_ADDR
// if not fac then
74970: LD_VAR 0 6
74974: NOT
74975: IFFALSE 75026
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74977: LD_ADDR_VAR 0 6
74981: PUSH
74982: LD_EXP 61
74986: PUSH
74987: LD_VAR 0 2
74991: ARRAY
74992: PPUSH
74993: LD_INT 2
74995: PUSH
74996: LD_INT 30
74998: PUSH
74999: LD_INT 0
75001: PUSH
75002: EMPTY
75003: LIST
75004: LIST
75005: PUSH
75006: LD_INT 30
75008: PUSH
75009: LD_INT 1
75011: PUSH
75012: EMPTY
75013: LIST
75014: LIST
75015: PUSH
75016: EMPTY
75017: LIST
75018: LIST
75019: LIST
75020: PPUSH
75021: CALL_OW 72
75025: ST_TO_ADDR
// if not fac then
75026: LD_VAR 0 6
75030: NOT
75031: IFFALSE 75035
// continue ;
75033: GO 74883
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75035: LD_ADDR_VAR 0 7
75039: PUSH
75040: LD_EXP 85
75044: PUSH
75045: LD_VAR 0 2
75049: ARRAY
75050: PPUSH
75051: LD_INT 22
75053: PUSH
75054: LD_VAR 0 5
75058: PUSH
75059: EMPTY
75060: LIST
75061: LIST
75062: PUSH
75063: LD_INT 21
75065: PUSH
75066: LD_INT 2
75068: PUSH
75069: EMPTY
75070: LIST
75071: LIST
75072: PUSH
75073: LD_INT 3
75075: PUSH
75076: LD_INT 60
75078: PUSH
75079: EMPTY
75080: LIST
75081: PUSH
75082: EMPTY
75083: LIST
75084: LIST
75085: PUSH
75086: LD_INT 3
75088: PUSH
75089: LD_INT 24
75091: PUSH
75092: LD_INT 1000
75094: PUSH
75095: EMPTY
75096: LIST
75097: LIST
75098: PUSH
75099: EMPTY
75100: LIST
75101: LIST
75102: PUSH
75103: EMPTY
75104: LIST
75105: LIST
75106: LIST
75107: LIST
75108: PPUSH
75109: CALL_OW 70
75113: ST_TO_ADDR
// for j in fac do
75114: LD_ADDR_VAR 0 3
75118: PUSH
75119: LD_VAR 0 6
75123: PUSH
75124: FOR_IN
75125: IFFALSE 75220
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75127: LD_ADDR_VAR 0 7
75131: PUSH
75132: LD_VAR 0 7
75136: PUSH
75137: LD_INT 22
75139: PUSH
75140: LD_VAR 0 5
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PUSH
75149: LD_INT 91
75151: PUSH
75152: LD_VAR 0 3
75156: PUSH
75157: LD_INT 15
75159: PUSH
75160: EMPTY
75161: LIST
75162: LIST
75163: LIST
75164: PUSH
75165: LD_INT 21
75167: PUSH
75168: LD_INT 2
75170: PUSH
75171: EMPTY
75172: LIST
75173: LIST
75174: PUSH
75175: LD_INT 3
75177: PUSH
75178: LD_INT 60
75180: PUSH
75181: EMPTY
75182: LIST
75183: PUSH
75184: EMPTY
75185: LIST
75186: LIST
75187: PUSH
75188: LD_INT 3
75190: PUSH
75191: LD_INT 24
75193: PUSH
75194: LD_INT 1000
75196: PUSH
75197: EMPTY
75198: LIST
75199: LIST
75200: PUSH
75201: EMPTY
75202: LIST
75203: LIST
75204: PUSH
75205: EMPTY
75206: LIST
75207: LIST
75208: LIST
75209: LIST
75210: LIST
75211: PPUSH
75212: CALL_OW 69
75216: UNION
75217: ST_TO_ADDR
75218: GO 75124
75220: POP
75221: POP
// if not vehs then
75222: LD_VAR 0 7
75226: NOT
75227: IFFALSE 75253
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
75229: LD_ADDR_EXP 73
75233: PUSH
75234: LD_EXP 73
75238: PPUSH
75239: LD_VAR 0 2
75243: PPUSH
75244: EMPTY
75245: PPUSH
75246: CALL_OW 1
75250: ST_TO_ADDR
// continue ;
75251: GO 74883
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75253: LD_ADDR_VAR 0 8
75257: PUSH
75258: LD_EXP 61
75262: PUSH
75263: LD_VAR 0 2
75267: ARRAY
75268: PPUSH
75269: LD_INT 30
75271: PUSH
75272: LD_INT 3
75274: PUSH
75275: EMPTY
75276: LIST
75277: LIST
75278: PPUSH
75279: CALL_OW 72
75283: ST_TO_ADDR
// if tmp then
75284: LD_VAR 0 8
75288: IFFALSE 75391
// begin for j in tmp do
75290: LD_ADDR_VAR 0 3
75294: PUSH
75295: LD_VAR 0 8
75299: PUSH
75300: FOR_IN
75301: IFFALSE 75389
// for k in UnitsInside ( j ) do
75303: LD_ADDR_VAR 0 4
75307: PUSH
75308: LD_VAR 0 3
75312: PPUSH
75313: CALL_OW 313
75317: PUSH
75318: FOR_IN
75319: IFFALSE 75385
// if k then
75321: LD_VAR 0 4
75325: IFFALSE 75383
// if not k in mc_repair_vehicle [ i ] then
75327: LD_VAR 0 4
75331: PUSH
75332: LD_EXP 73
75336: PUSH
75337: LD_VAR 0 2
75341: ARRAY
75342: IN
75343: NOT
75344: IFFALSE 75383
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
75346: LD_ADDR_EXP 73
75350: PUSH
75351: LD_EXP 73
75355: PPUSH
75356: LD_VAR 0 2
75360: PPUSH
75361: LD_EXP 73
75365: PUSH
75366: LD_VAR 0 2
75370: ARRAY
75371: PUSH
75372: LD_VAR 0 4
75376: UNION
75377: PPUSH
75378: CALL_OW 1
75382: ST_TO_ADDR
75383: GO 75318
75385: POP
75386: POP
75387: GO 75300
75389: POP
75390: POP
// end ; if not mc_repair_vehicle [ i ] then
75391: LD_EXP 73
75395: PUSH
75396: LD_VAR 0 2
75400: ARRAY
75401: NOT
75402: IFFALSE 75406
// continue ;
75404: GO 74883
// for j in mc_repair_vehicle [ i ] do
75406: LD_ADDR_VAR 0 3
75410: PUSH
75411: LD_EXP 73
75415: PUSH
75416: LD_VAR 0 2
75420: ARRAY
75421: PUSH
75422: FOR_IN
75423: IFFALSE 75600
// begin if GetClass ( j ) <> 3 then
75425: LD_VAR 0 3
75429: PPUSH
75430: CALL_OW 257
75434: PUSH
75435: LD_INT 3
75437: NONEQUAL
75438: IFFALSE 75479
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
75440: LD_ADDR_EXP 73
75444: PUSH
75445: LD_EXP 73
75449: PPUSH
75450: LD_VAR 0 2
75454: PPUSH
75455: LD_EXP 73
75459: PUSH
75460: LD_VAR 0 2
75464: ARRAY
75465: PUSH
75466: LD_VAR 0 3
75470: DIFF
75471: PPUSH
75472: CALL_OW 1
75476: ST_TO_ADDR
// continue ;
75477: GO 75422
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75479: LD_VAR 0 3
75483: PPUSH
75484: CALL_OW 311
75488: NOT
75489: PUSH
75490: LD_VAR 0 3
75494: PUSH
75495: LD_EXP 64
75499: PUSH
75500: LD_VAR 0 2
75504: ARRAY
75505: PUSH
75506: LD_INT 1
75508: ARRAY
75509: IN
75510: NOT
75511: AND
75512: PUSH
75513: LD_VAR 0 3
75517: PUSH
75518: LD_EXP 64
75522: PUSH
75523: LD_VAR 0 2
75527: ARRAY
75528: PUSH
75529: LD_INT 2
75531: ARRAY
75532: IN
75533: NOT
75534: AND
75535: IFFALSE 75598
// begin if IsInUnit ( j ) then
75537: LD_VAR 0 3
75541: PPUSH
75542: CALL_OW 310
75546: IFFALSE 75559
// ComExitBuilding ( j ) else
75548: LD_VAR 0 3
75552: PPUSH
75553: CALL_OW 122
75557: GO 75598
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
75559: LD_VAR 0 3
75563: PPUSH
75564: LD_VAR 0 7
75568: PUSH
75569: LD_INT 1
75571: ARRAY
75572: PPUSH
75573: CALL 54836 0 2
75577: NOT
75578: IFFALSE 75598
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
75580: LD_VAR 0 3
75584: PPUSH
75585: LD_VAR 0 7
75589: PUSH
75590: LD_INT 1
75592: ARRAY
75593: PPUSH
75594: CALL_OW 129
// end ; end ;
75598: GO 75422
75600: POP
75601: POP
// end ;
75602: GO 74883
75604: POP
75605: POP
// end ;
75606: LD_VAR 0 1
75610: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75611: LD_INT 0
75613: PPUSH
75614: PPUSH
75615: PPUSH
75616: PPUSH
75617: PPUSH
75618: PPUSH
75619: PPUSH
75620: PPUSH
75621: PPUSH
75622: PPUSH
75623: PPUSH
// if not mc_bases then
75624: LD_EXP 61
75628: NOT
75629: IFFALSE 75633
// exit ;
75631: GO 76435
// for i = 1 to mc_bases do
75633: LD_ADDR_VAR 0 2
75637: PUSH
75638: DOUBLE
75639: LD_INT 1
75641: DEC
75642: ST_TO_ADDR
75643: LD_EXP 61
75647: PUSH
75648: FOR_TO
75649: IFFALSE 76433
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75651: LD_EXP 89
75655: PUSH
75656: LD_VAR 0 2
75660: ARRAY
75661: NOT
75662: PUSH
75663: LD_EXP 64
75667: PUSH
75668: LD_VAR 0 2
75672: ARRAY
75673: PUSH
75674: LD_INT 1
75676: ARRAY
75677: OR
75678: PUSH
75679: LD_EXP 64
75683: PUSH
75684: LD_VAR 0 2
75688: ARRAY
75689: PUSH
75690: LD_INT 2
75692: ARRAY
75693: OR
75694: PUSH
75695: LD_EXP 87
75699: PUSH
75700: LD_VAR 0 2
75704: ARRAY
75705: PPUSH
75706: LD_INT 1
75708: PPUSH
75709: CALL_OW 325
75713: NOT
75714: OR
75715: PUSH
75716: LD_EXP 84
75720: PUSH
75721: LD_VAR 0 2
75725: ARRAY
75726: OR
75727: IFFALSE 75731
// continue ;
75729: GO 75648
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75731: LD_ADDR_VAR 0 8
75735: PUSH
75736: LD_EXP 61
75740: PUSH
75741: LD_VAR 0 2
75745: ARRAY
75746: PPUSH
75747: LD_INT 25
75749: PUSH
75750: LD_INT 4
75752: PUSH
75753: EMPTY
75754: LIST
75755: LIST
75756: PUSH
75757: LD_INT 50
75759: PUSH
75760: EMPTY
75761: LIST
75762: PUSH
75763: LD_INT 3
75765: PUSH
75766: LD_INT 60
75768: PUSH
75769: EMPTY
75770: LIST
75771: PUSH
75772: EMPTY
75773: LIST
75774: LIST
75775: PUSH
75776: EMPTY
75777: LIST
75778: LIST
75779: LIST
75780: PPUSH
75781: CALL_OW 72
75785: PUSH
75786: LD_EXP 65
75790: PUSH
75791: LD_VAR 0 2
75795: ARRAY
75796: DIFF
75797: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75798: LD_ADDR_VAR 0 9
75802: PUSH
75803: LD_EXP 61
75807: PUSH
75808: LD_VAR 0 2
75812: ARRAY
75813: PPUSH
75814: LD_INT 2
75816: PUSH
75817: LD_INT 30
75819: PUSH
75820: LD_INT 0
75822: PUSH
75823: EMPTY
75824: LIST
75825: LIST
75826: PUSH
75827: LD_INT 30
75829: PUSH
75830: LD_INT 1
75832: PUSH
75833: EMPTY
75834: LIST
75835: LIST
75836: PUSH
75837: EMPTY
75838: LIST
75839: LIST
75840: LIST
75841: PPUSH
75842: CALL_OW 72
75846: ST_TO_ADDR
// if not tmp or not dep then
75847: LD_VAR 0 8
75851: NOT
75852: PUSH
75853: LD_VAR 0 9
75857: NOT
75858: OR
75859: IFFALSE 75863
// continue ;
75861: GO 75648
// side := GetSide ( tmp [ 1 ] ) ;
75863: LD_ADDR_VAR 0 11
75867: PUSH
75868: LD_VAR 0 8
75872: PUSH
75873: LD_INT 1
75875: ARRAY
75876: PPUSH
75877: CALL_OW 255
75881: ST_TO_ADDR
// dep := dep [ 1 ] ;
75882: LD_ADDR_VAR 0 9
75886: PUSH
75887: LD_VAR 0 9
75891: PUSH
75892: LD_INT 1
75894: ARRAY
75895: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
75896: LD_ADDR_VAR 0 7
75900: PUSH
75901: LD_EXP 89
75905: PUSH
75906: LD_VAR 0 2
75910: ARRAY
75911: PPUSH
75912: LD_INT 22
75914: PUSH
75915: LD_INT 0
75917: PUSH
75918: EMPTY
75919: LIST
75920: LIST
75921: PUSH
75922: LD_INT 25
75924: PUSH
75925: LD_INT 12
75927: PUSH
75928: EMPTY
75929: LIST
75930: LIST
75931: PUSH
75932: EMPTY
75933: LIST
75934: LIST
75935: PPUSH
75936: CALL_OW 70
75940: PUSH
75941: LD_INT 22
75943: PUSH
75944: LD_INT 0
75946: PUSH
75947: EMPTY
75948: LIST
75949: LIST
75950: PUSH
75951: LD_INT 25
75953: PUSH
75954: LD_INT 12
75956: PUSH
75957: EMPTY
75958: LIST
75959: LIST
75960: PUSH
75961: LD_INT 91
75963: PUSH
75964: LD_VAR 0 9
75968: PUSH
75969: LD_INT 20
75971: PUSH
75972: EMPTY
75973: LIST
75974: LIST
75975: LIST
75976: PUSH
75977: EMPTY
75978: LIST
75979: LIST
75980: LIST
75981: PPUSH
75982: CALL_OW 69
75986: UNION
75987: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
75988: LD_ADDR_VAR 0 10
75992: PUSH
75993: LD_EXP 89
75997: PUSH
75998: LD_VAR 0 2
76002: ARRAY
76003: PPUSH
76004: LD_INT 81
76006: PUSH
76007: LD_VAR 0 11
76011: PUSH
76012: EMPTY
76013: LIST
76014: LIST
76015: PPUSH
76016: CALL_OW 70
76020: ST_TO_ADDR
// if not apes or danger_at_area then
76021: LD_VAR 0 7
76025: NOT
76026: PUSH
76027: LD_VAR 0 10
76031: OR
76032: IFFALSE 76082
// begin if mc_taming [ i ] then
76034: LD_EXP 92
76038: PUSH
76039: LD_VAR 0 2
76043: ARRAY
76044: IFFALSE 76080
// begin MC_Reset ( i , 121 ) ;
76046: LD_VAR 0 2
76050: PPUSH
76051: LD_INT 121
76053: PPUSH
76054: CALL 61012 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
76058: LD_ADDR_EXP 92
76062: PUSH
76063: LD_EXP 92
76067: PPUSH
76068: LD_VAR 0 2
76072: PPUSH
76073: EMPTY
76074: PPUSH
76075: CALL_OW 1
76079: ST_TO_ADDR
// end ; continue ;
76080: GO 75648
// end ; for j in tmp do
76082: LD_ADDR_VAR 0 3
76086: PUSH
76087: LD_VAR 0 8
76091: PUSH
76092: FOR_IN
76093: IFFALSE 76429
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
76095: LD_VAR 0 3
76099: PUSH
76100: LD_EXP 92
76104: PUSH
76105: LD_VAR 0 2
76109: ARRAY
76110: IN
76111: NOT
76112: PUSH
76113: LD_EXP 92
76117: PUSH
76118: LD_VAR 0 2
76122: ARRAY
76123: PUSH
76124: LD_INT 3
76126: LESS
76127: AND
76128: IFFALSE 76186
// begin SetTag ( j , 121 ) ;
76130: LD_VAR 0 3
76134: PPUSH
76135: LD_INT 121
76137: PPUSH
76138: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
76142: LD_ADDR_EXP 92
76146: PUSH
76147: LD_EXP 92
76151: PPUSH
76152: LD_VAR 0 2
76156: PUSH
76157: LD_EXP 92
76161: PUSH
76162: LD_VAR 0 2
76166: ARRAY
76167: PUSH
76168: LD_INT 1
76170: PLUS
76171: PUSH
76172: EMPTY
76173: LIST
76174: LIST
76175: PPUSH
76176: LD_VAR 0 3
76180: PPUSH
76181: CALL 20441 0 3
76185: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
76186: LD_VAR 0 3
76190: PUSH
76191: LD_EXP 92
76195: PUSH
76196: LD_VAR 0 2
76200: ARRAY
76201: IN
76202: IFFALSE 76427
// begin if GetClass ( j ) <> 4 then
76204: LD_VAR 0 3
76208: PPUSH
76209: CALL_OW 257
76213: PUSH
76214: LD_INT 4
76216: NONEQUAL
76217: IFFALSE 76270
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
76219: LD_ADDR_EXP 92
76223: PUSH
76224: LD_EXP 92
76228: PPUSH
76229: LD_VAR 0 2
76233: PPUSH
76234: LD_EXP 92
76238: PUSH
76239: LD_VAR 0 2
76243: ARRAY
76244: PUSH
76245: LD_VAR 0 3
76249: DIFF
76250: PPUSH
76251: CALL_OW 1
76255: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76256: LD_VAR 0 3
76260: PPUSH
76261: LD_INT 0
76263: PPUSH
76264: CALL_OW 109
// continue ;
76268: GO 76092
// end ; if IsInUnit ( j ) then
76270: LD_VAR 0 3
76274: PPUSH
76275: CALL_OW 310
76279: IFFALSE 76290
// ComExitBuilding ( j ) ;
76281: LD_VAR 0 3
76285: PPUSH
76286: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
76290: LD_ADDR_VAR 0 6
76294: PUSH
76295: LD_VAR 0 7
76299: PPUSH
76300: LD_VAR 0 3
76304: PPUSH
76305: CALL_OW 74
76309: ST_TO_ADDR
// if not ape then
76310: LD_VAR 0 6
76314: NOT
76315: IFFALSE 76319
// break ;
76317: GO 76429
// x := GetX ( ape ) ;
76319: LD_ADDR_VAR 0 4
76323: PUSH
76324: LD_VAR 0 6
76328: PPUSH
76329: CALL_OW 250
76333: ST_TO_ADDR
// y := GetY ( ape ) ;
76334: LD_ADDR_VAR 0 5
76338: PUSH
76339: LD_VAR 0 6
76343: PPUSH
76344: CALL_OW 251
76348: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76349: LD_VAR 0 4
76353: PPUSH
76354: LD_VAR 0 5
76358: PPUSH
76359: CALL_OW 488
76363: NOT
76364: PUSH
76365: LD_VAR 0 11
76369: PPUSH
76370: LD_VAR 0 4
76374: PPUSH
76375: LD_VAR 0 5
76379: PPUSH
76380: LD_INT 20
76382: PPUSH
76383: CALL 21337 0 4
76387: PUSH
76388: LD_INT 4
76390: ARRAY
76391: OR
76392: IFFALSE 76396
// break ;
76394: GO 76429
// if not HasTask ( j ) then
76396: LD_VAR 0 3
76400: PPUSH
76401: CALL_OW 314
76405: NOT
76406: IFFALSE 76427
// ComTameXY ( j , x , y ) ;
76408: LD_VAR 0 3
76412: PPUSH
76413: LD_VAR 0 4
76417: PPUSH
76418: LD_VAR 0 5
76422: PPUSH
76423: CALL_OW 131
// end ; end ;
76427: GO 76092
76429: POP
76430: POP
// end ;
76431: GO 75648
76433: POP
76434: POP
// end ;
76435: LD_VAR 0 1
76439: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
76440: LD_INT 0
76442: PPUSH
76443: PPUSH
76444: PPUSH
76445: PPUSH
76446: PPUSH
76447: PPUSH
76448: PPUSH
76449: PPUSH
// if not mc_bases then
76450: LD_EXP 61
76454: NOT
76455: IFFALSE 76459
// exit ;
76457: GO 77085
// for i = 1 to mc_bases do
76459: LD_ADDR_VAR 0 2
76463: PUSH
76464: DOUBLE
76465: LD_INT 1
76467: DEC
76468: ST_TO_ADDR
76469: LD_EXP 61
76473: PUSH
76474: FOR_TO
76475: IFFALSE 77083
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
76477: LD_EXP 90
76481: PUSH
76482: LD_VAR 0 2
76486: ARRAY
76487: NOT
76488: PUSH
76489: LD_EXP 90
76493: PUSH
76494: LD_VAR 0 2
76498: ARRAY
76499: PPUSH
76500: LD_INT 25
76502: PUSH
76503: LD_INT 12
76505: PUSH
76506: EMPTY
76507: LIST
76508: LIST
76509: PPUSH
76510: CALL_OW 72
76514: NOT
76515: OR
76516: IFFALSE 76520
// continue ;
76518: GO 76474
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
76520: LD_ADDR_VAR 0 5
76524: PUSH
76525: LD_EXP 90
76529: PUSH
76530: LD_VAR 0 2
76534: ARRAY
76535: PUSH
76536: LD_INT 1
76538: ARRAY
76539: PPUSH
76540: CALL_OW 255
76544: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
76545: LD_VAR 0 5
76549: PPUSH
76550: LD_INT 2
76552: PPUSH
76553: CALL_OW 325
76557: IFFALSE 76810
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76559: LD_ADDR_VAR 0 4
76563: PUSH
76564: LD_EXP 90
76568: PUSH
76569: LD_VAR 0 2
76573: ARRAY
76574: PPUSH
76575: LD_INT 25
76577: PUSH
76578: LD_INT 16
76580: PUSH
76581: EMPTY
76582: LIST
76583: LIST
76584: PPUSH
76585: CALL_OW 72
76589: ST_TO_ADDR
// if tmp < 6 then
76590: LD_VAR 0 4
76594: PUSH
76595: LD_INT 6
76597: LESS
76598: IFFALSE 76810
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76600: LD_ADDR_VAR 0 6
76604: PUSH
76605: LD_EXP 61
76609: PUSH
76610: LD_VAR 0 2
76614: ARRAY
76615: PPUSH
76616: LD_INT 2
76618: PUSH
76619: LD_INT 30
76621: PUSH
76622: LD_INT 0
76624: PUSH
76625: EMPTY
76626: LIST
76627: LIST
76628: PUSH
76629: LD_INT 30
76631: PUSH
76632: LD_INT 1
76634: PUSH
76635: EMPTY
76636: LIST
76637: LIST
76638: PUSH
76639: EMPTY
76640: LIST
76641: LIST
76642: LIST
76643: PPUSH
76644: CALL_OW 72
76648: ST_TO_ADDR
// if depot then
76649: LD_VAR 0 6
76653: IFFALSE 76810
// begin selected := 0 ;
76655: LD_ADDR_VAR 0 7
76659: PUSH
76660: LD_INT 0
76662: ST_TO_ADDR
// for j in depot do
76663: LD_ADDR_VAR 0 3
76667: PUSH
76668: LD_VAR 0 6
76672: PUSH
76673: FOR_IN
76674: IFFALSE 76705
// begin if UnitsInside ( j ) < 6 then
76676: LD_VAR 0 3
76680: PPUSH
76681: CALL_OW 313
76685: PUSH
76686: LD_INT 6
76688: LESS
76689: IFFALSE 76703
// begin selected := j ;
76691: LD_ADDR_VAR 0 7
76695: PUSH
76696: LD_VAR 0 3
76700: ST_TO_ADDR
// break ;
76701: GO 76705
// end ; end ;
76703: GO 76673
76705: POP
76706: POP
// if selected then
76707: LD_VAR 0 7
76711: IFFALSE 76810
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76713: LD_ADDR_VAR 0 3
76717: PUSH
76718: LD_EXP 90
76722: PUSH
76723: LD_VAR 0 2
76727: ARRAY
76728: PPUSH
76729: LD_INT 25
76731: PUSH
76732: LD_INT 12
76734: PUSH
76735: EMPTY
76736: LIST
76737: LIST
76738: PPUSH
76739: CALL_OW 72
76743: PUSH
76744: FOR_IN
76745: IFFALSE 76808
// if not HasTask ( j ) then
76747: LD_VAR 0 3
76751: PPUSH
76752: CALL_OW 314
76756: NOT
76757: IFFALSE 76806
// begin if not IsInUnit ( j ) then
76759: LD_VAR 0 3
76763: PPUSH
76764: CALL_OW 310
76768: NOT
76769: IFFALSE 76785
// ComEnterUnit ( j , selected ) ;
76771: LD_VAR 0 3
76775: PPUSH
76776: LD_VAR 0 7
76780: PPUSH
76781: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76785: LD_VAR 0 3
76789: PPUSH
76790: LD_INT 16
76792: PPUSH
76793: CALL_OW 183
// AddComExitBuilding ( j ) ;
76797: LD_VAR 0 3
76801: PPUSH
76802: CALL_OW 182
// end ;
76806: GO 76744
76808: POP
76809: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76810: LD_VAR 0 5
76814: PPUSH
76815: LD_INT 11
76817: PPUSH
76818: CALL_OW 325
76822: IFFALSE 77081
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76824: LD_ADDR_VAR 0 4
76828: PUSH
76829: LD_EXP 90
76833: PUSH
76834: LD_VAR 0 2
76838: ARRAY
76839: PPUSH
76840: LD_INT 25
76842: PUSH
76843: LD_INT 16
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: PPUSH
76850: CALL_OW 72
76854: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
76855: LD_VAR 0 4
76859: PUSH
76860: LD_INT 6
76862: GREATEREQUAL
76863: PUSH
76864: LD_VAR 0 5
76868: PPUSH
76869: LD_INT 2
76871: PPUSH
76872: CALL_OW 325
76876: NOT
76877: OR
76878: IFFALSE 77081
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76880: LD_ADDR_VAR 0 8
76884: PUSH
76885: LD_EXP 61
76889: PUSH
76890: LD_VAR 0 2
76894: ARRAY
76895: PPUSH
76896: LD_INT 2
76898: PUSH
76899: LD_INT 30
76901: PUSH
76902: LD_INT 4
76904: PUSH
76905: EMPTY
76906: LIST
76907: LIST
76908: PUSH
76909: LD_INT 30
76911: PUSH
76912: LD_INT 5
76914: PUSH
76915: EMPTY
76916: LIST
76917: LIST
76918: PUSH
76919: EMPTY
76920: LIST
76921: LIST
76922: LIST
76923: PPUSH
76924: CALL_OW 72
76928: ST_TO_ADDR
// if barracks then
76929: LD_VAR 0 8
76933: IFFALSE 77081
// begin selected := 0 ;
76935: LD_ADDR_VAR 0 7
76939: PUSH
76940: LD_INT 0
76942: ST_TO_ADDR
// for j in barracks do
76943: LD_ADDR_VAR 0 3
76947: PUSH
76948: LD_VAR 0 8
76952: PUSH
76953: FOR_IN
76954: IFFALSE 76985
// begin if UnitsInside ( j ) < 6 then
76956: LD_VAR 0 3
76960: PPUSH
76961: CALL_OW 313
76965: PUSH
76966: LD_INT 6
76968: LESS
76969: IFFALSE 76983
// begin selected := j ;
76971: LD_ADDR_VAR 0 7
76975: PUSH
76976: LD_VAR 0 3
76980: ST_TO_ADDR
// break ;
76981: GO 76985
// end ; end ;
76983: GO 76953
76985: POP
76986: POP
// if selected then
76987: LD_VAR 0 7
76991: IFFALSE 77081
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76993: LD_ADDR_VAR 0 3
76997: PUSH
76998: LD_EXP 90
77002: PUSH
77003: LD_VAR 0 2
77007: ARRAY
77008: PPUSH
77009: LD_INT 25
77011: PUSH
77012: LD_INT 12
77014: PUSH
77015: EMPTY
77016: LIST
77017: LIST
77018: PPUSH
77019: CALL_OW 72
77023: PUSH
77024: FOR_IN
77025: IFFALSE 77079
// if not IsInUnit ( j ) and not HasTask ( j ) then
77027: LD_VAR 0 3
77031: PPUSH
77032: CALL_OW 310
77036: NOT
77037: PUSH
77038: LD_VAR 0 3
77042: PPUSH
77043: CALL_OW 314
77047: NOT
77048: AND
77049: IFFALSE 77077
// begin ComEnterUnit ( j , selected ) ;
77051: LD_VAR 0 3
77055: PPUSH
77056: LD_VAR 0 7
77060: PPUSH
77061: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
77065: LD_VAR 0 3
77069: PPUSH
77070: LD_INT 15
77072: PPUSH
77073: CALL_OW 183
// end ;
77077: GO 77024
77079: POP
77080: POP
// end ; end ; end ; end ; end ;
77081: GO 76474
77083: POP
77084: POP
// end ;
77085: LD_VAR 0 1
77089: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
77090: LD_INT 0
77092: PPUSH
77093: PPUSH
77094: PPUSH
77095: PPUSH
// if not mc_bases then
77096: LD_EXP 61
77100: NOT
77101: IFFALSE 77105
// exit ;
77103: GO 77283
// for i = 1 to mc_bases do
77105: LD_ADDR_VAR 0 2
77109: PUSH
77110: DOUBLE
77111: LD_INT 1
77113: DEC
77114: ST_TO_ADDR
77115: LD_EXP 61
77119: PUSH
77120: FOR_TO
77121: IFFALSE 77281
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
77123: LD_ADDR_VAR 0 4
77127: PUSH
77128: LD_EXP 61
77132: PUSH
77133: LD_VAR 0 2
77137: ARRAY
77138: PPUSH
77139: LD_INT 25
77141: PUSH
77142: LD_INT 9
77144: PUSH
77145: EMPTY
77146: LIST
77147: LIST
77148: PPUSH
77149: CALL_OW 72
77153: ST_TO_ADDR
// if not tmp then
77154: LD_VAR 0 4
77158: NOT
77159: IFFALSE 77163
// continue ;
77161: GO 77120
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
77163: LD_EXP 87
77167: PUSH
77168: LD_VAR 0 2
77172: ARRAY
77173: PPUSH
77174: LD_INT 29
77176: PPUSH
77177: CALL_OW 325
77181: NOT
77182: PUSH
77183: LD_EXP 87
77187: PUSH
77188: LD_VAR 0 2
77192: ARRAY
77193: PPUSH
77194: LD_INT 28
77196: PPUSH
77197: CALL_OW 325
77201: NOT
77202: AND
77203: IFFALSE 77207
// continue ;
77205: GO 77120
// for j in tmp do
77207: LD_ADDR_VAR 0 3
77211: PUSH
77212: LD_VAR 0 4
77216: PUSH
77217: FOR_IN
77218: IFFALSE 77277
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
77220: LD_VAR 0 3
77224: PUSH
77225: LD_EXP 64
77229: PUSH
77230: LD_VAR 0 2
77234: ARRAY
77235: PUSH
77236: LD_INT 1
77238: ARRAY
77239: IN
77240: NOT
77241: PUSH
77242: LD_VAR 0 3
77246: PUSH
77247: LD_EXP 64
77251: PUSH
77252: LD_VAR 0 2
77256: ARRAY
77257: PUSH
77258: LD_INT 2
77260: ARRAY
77261: IN
77262: NOT
77263: AND
77264: IFFALSE 77275
// ComSpaceTimeShoot ( j ) ;
77266: LD_VAR 0 3
77270: PPUSH
77271: CALL 16426 0 1
77275: GO 77217
77277: POP
77278: POP
// end ;
77279: GO 77120
77281: POP
77282: POP
// end ;
77283: LD_VAR 0 1
77287: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
77288: LD_INT 0
77290: PPUSH
77291: PPUSH
77292: PPUSH
77293: PPUSH
77294: PPUSH
77295: PPUSH
77296: PPUSH
77297: PPUSH
77298: PPUSH
// if not mc_bases then
77299: LD_EXP 61
77303: NOT
77304: IFFALSE 77308
// exit ;
77306: GO 77930
// for i = 1 to mc_bases do
77308: LD_ADDR_VAR 0 2
77312: PUSH
77313: DOUBLE
77314: LD_INT 1
77316: DEC
77317: ST_TO_ADDR
77318: LD_EXP 61
77322: PUSH
77323: FOR_TO
77324: IFFALSE 77928
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
77326: LD_EXP 96
77330: PUSH
77331: LD_VAR 0 2
77335: ARRAY
77336: NOT
77337: PUSH
77338: LD_INT 38
77340: PPUSH
77341: LD_EXP 87
77345: PUSH
77346: LD_VAR 0 2
77350: ARRAY
77351: PPUSH
77352: CALL_OW 321
77356: PUSH
77357: LD_INT 2
77359: NONEQUAL
77360: OR
77361: IFFALSE 77365
// continue ;
77363: GO 77323
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
77365: LD_ADDR_VAR 0 8
77369: PUSH
77370: LD_EXP 61
77374: PUSH
77375: LD_VAR 0 2
77379: ARRAY
77380: PPUSH
77381: LD_INT 30
77383: PUSH
77384: LD_INT 34
77386: PUSH
77387: EMPTY
77388: LIST
77389: LIST
77390: PPUSH
77391: CALL_OW 72
77395: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
77396: LD_ADDR_VAR 0 9
77400: PUSH
77401: LD_EXP 61
77405: PUSH
77406: LD_VAR 0 2
77410: ARRAY
77411: PPUSH
77412: LD_INT 25
77414: PUSH
77415: LD_INT 4
77417: PUSH
77418: EMPTY
77419: LIST
77420: LIST
77421: PPUSH
77422: CALL_OW 72
77426: PPUSH
77427: LD_INT 0
77429: PPUSH
77430: CALL 50353 0 2
77434: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
77435: LD_VAR 0 9
77439: NOT
77440: PUSH
77441: LD_VAR 0 8
77445: NOT
77446: OR
77447: PUSH
77448: LD_EXP 61
77452: PUSH
77453: LD_VAR 0 2
77457: ARRAY
77458: PPUSH
77459: LD_INT 124
77461: PPUSH
77462: CALL 50353 0 2
77466: OR
77467: IFFALSE 77471
// continue ;
77469: GO 77323
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
77471: LD_EXP 97
77475: PUSH
77476: LD_VAR 0 2
77480: ARRAY
77481: PUSH
77482: LD_EXP 96
77486: PUSH
77487: LD_VAR 0 2
77491: ARRAY
77492: LESS
77493: PUSH
77494: LD_EXP 97
77498: PUSH
77499: LD_VAR 0 2
77503: ARRAY
77504: PUSH
77505: LD_VAR 0 8
77509: LESS
77510: AND
77511: IFFALSE 77926
// begin tmp := sci [ 1 ] ;
77513: LD_ADDR_VAR 0 7
77517: PUSH
77518: LD_VAR 0 9
77522: PUSH
77523: LD_INT 1
77525: ARRAY
77526: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
77527: LD_VAR 0 7
77531: PPUSH
77532: LD_INT 124
77534: PPUSH
77535: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
77539: LD_ADDR_VAR 0 3
77543: PUSH
77544: DOUBLE
77545: LD_EXP 96
77549: PUSH
77550: LD_VAR 0 2
77554: ARRAY
77555: INC
77556: ST_TO_ADDR
77557: LD_EXP 96
77561: PUSH
77562: LD_VAR 0 2
77566: ARRAY
77567: PUSH
77568: FOR_DOWNTO
77569: IFFALSE 77912
// begin if IsInUnit ( tmp ) then
77571: LD_VAR 0 7
77575: PPUSH
77576: CALL_OW 310
77580: IFFALSE 77591
// ComExitBuilding ( tmp ) ;
77582: LD_VAR 0 7
77586: PPUSH
77587: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77591: LD_INT 35
77593: PPUSH
77594: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77598: LD_VAR 0 7
77602: PPUSH
77603: CALL_OW 310
77607: NOT
77608: PUSH
77609: LD_VAR 0 7
77613: PPUSH
77614: CALL_OW 314
77618: NOT
77619: AND
77620: IFFALSE 77591
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77622: LD_ADDR_VAR 0 6
77626: PUSH
77627: LD_VAR 0 7
77631: PPUSH
77632: CALL_OW 250
77636: PUSH
77637: LD_VAR 0 7
77641: PPUSH
77642: CALL_OW 251
77646: PUSH
77647: EMPTY
77648: LIST
77649: LIST
77650: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77651: LD_INT 35
77653: PPUSH
77654: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77658: LD_ADDR_VAR 0 4
77662: PUSH
77663: LD_EXP 96
77667: PUSH
77668: LD_VAR 0 2
77672: ARRAY
77673: PUSH
77674: LD_VAR 0 3
77678: ARRAY
77679: PUSH
77680: LD_INT 1
77682: ARRAY
77683: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77684: LD_ADDR_VAR 0 5
77688: PUSH
77689: LD_EXP 96
77693: PUSH
77694: LD_VAR 0 2
77698: ARRAY
77699: PUSH
77700: LD_VAR 0 3
77704: ARRAY
77705: PUSH
77706: LD_INT 2
77708: ARRAY
77709: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77710: LD_VAR 0 7
77714: PPUSH
77715: LD_INT 10
77717: PPUSH
77718: CALL 23038 0 2
77722: PUSH
77723: LD_INT 4
77725: ARRAY
77726: IFFALSE 77764
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77728: LD_VAR 0 7
77732: PPUSH
77733: LD_VAR 0 6
77737: PUSH
77738: LD_INT 1
77740: ARRAY
77741: PPUSH
77742: LD_VAR 0 6
77746: PUSH
77747: LD_INT 2
77749: ARRAY
77750: PPUSH
77751: CALL_OW 111
// wait ( 0 0$10 ) ;
77755: LD_INT 350
77757: PPUSH
77758: CALL_OW 67
// end else
77762: GO 77790
// begin ComMoveXY ( tmp , x , y ) ;
77764: LD_VAR 0 7
77768: PPUSH
77769: LD_VAR 0 4
77773: PPUSH
77774: LD_VAR 0 5
77778: PPUSH
77779: CALL_OW 111
// wait ( 0 0$3 ) ;
77783: LD_INT 105
77785: PPUSH
77786: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77790: LD_VAR 0 7
77794: PPUSH
77795: LD_VAR 0 4
77799: PPUSH
77800: LD_VAR 0 5
77804: PPUSH
77805: CALL_OW 307
77809: IFFALSE 77651
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77811: LD_VAR 0 7
77815: PPUSH
77816: LD_VAR 0 4
77820: PPUSH
77821: LD_VAR 0 5
77825: PPUSH
77826: LD_VAR 0 8
77830: PUSH
77831: LD_VAR 0 3
77835: ARRAY
77836: PPUSH
77837: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77841: LD_INT 35
77843: PPUSH
77844: CALL_OW 67
// until not HasTask ( tmp ) ;
77848: LD_VAR 0 7
77852: PPUSH
77853: CALL_OW 314
77857: NOT
77858: IFFALSE 77841
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
77860: LD_ADDR_EXP 97
77864: PUSH
77865: LD_EXP 97
77869: PPUSH
77870: LD_VAR 0 2
77874: PUSH
77875: LD_EXP 97
77879: PUSH
77880: LD_VAR 0 2
77884: ARRAY
77885: PUSH
77886: LD_INT 1
77888: PLUS
77889: PUSH
77890: EMPTY
77891: LIST
77892: LIST
77893: PPUSH
77894: LD_VAR 0 8
77898: PUSH
77899: LD_VAR 0 3
77903: ARRAY
77904: PPUSH
77905: CALL 20441 0 3
77909: ST_TO_ADDR
// end ;
77910: GO 77568
77912: POP
77913: POP
// MC_Reset ( i , 124 ) ;
77914: LD_VAR 0 2
77918: PPUSH
77919: LD_INT 124
77921: PPUSH
77922: CALL 61012 0 2
// end ; end ;
77926: GO 77323
77928: POP
77929: POP
// end ;
77930: LD_VAR 0 1
77934: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
77935: LD_INT 0
77937: PPUSH
77938: PPUSH
77939: PPUSH
// if not mc_bases then
77940: LD_EXP 61
77944: NOT
77945: IFFALSE 77949
// exit ;
77947: GO 78555
// for i = 1 to mc_bases do
77949: LD_ADDR_VAR 0 2
77953: PUSH
77954: DOUBLE
77955: LD_INT 1
77957: DEC
77958: ST_TO_ADDR
77959: LD_EXP 61
77963: PUSH
77964: FOR_TO
77965: IFFALSE 78553
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
77967: LD_ADDR_VAR 0 3
77971: PUSH
77972: LD_EXP 61
77976: PUSH
77977: LD_VAR 0 2
77981: ARRAY
77982: PPUSH
77983: LD_INT 25
77985: PUSH
77986: LD_INT 4
77988: PUSH
77989: EMPTY
77990: LIST
77991: LIST
77992: PPUSH
77993: CALL_OW 72
77997: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
77998: LD_VAR 0 3
78002: NOT
78003: PUSH
78004: LD_EXP 98
78008: PUSH
78009: LD_VAR 0 2
78013: ARRAY
78014: NOT
78015: OR
78016: PUSH
78017: LD_EXP 61
78021: PUSH
78022: LD_VAR 0 2
78026: ARRAY
78027: PPUSH
78028: LD_INT 2
78030: PUSH
78031: LD_INT 30
78033: PUSH
78034: LD_INT 0
78036: PUSH
78037: EMPTY
78038: LIST
78039: LIST
78040: PUSH
78041: LD_INT 30
78043: PUSH
78044: LD_INT 1
78046: PUSH
78047: EMPTY
78048: LIST
78049: LIST
78050: PUSH
78051: EMPTY
78052: LIST
78053: LIST
78054: LIST
78055: PPUSH
78056: CALL_OW 72
78060: NOT
78061: OR
78062: IFFALSE 78112
// begin if mc_deposits_finder [ i ] then
78064: LD_EXP 99
78068: PUSH
78069: LD_VAR 0 2
78073: ARRAY
78074: IFFALSE 78110
// begin MC_Reset ( i , 125 ) ;
78076: LD_VAR 0 2
78080: PPUSH
78081: LD_INT 125
78083: PPUSH
78084: CALL 61012 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78088: LD_ADDR_EXP 99
78092: PUSH
78093: LD_EXP 99
78097: PPUSH
78098: LD_VAR 0 2
78102: PPUSH
78103: EMPTY
78104: PPUSH
78105: CALL_OW 1
78109: ST_TO_ADDR
// end ; continue ;
78110: GO 77964
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
78112: LD_EXP 98
78116: PUSH
78117: LD_VAR 0 2
78121: ARRAY
78122: PUSH
78123: LD_INT 1
78125: ARRAY
78126: PUSH
78127: LD_INT 3
78129: ARRAY
78130: PUSH
78131: LD_INT 1
78133: EQUAL
78134: PUSH
78135: LD_INT 20
78137: PPUSH
78138: LD_EXP 87
78142: PUSH
78143: LD_VAR 0 2
78147: ARRAY
78148: PPUSH
78149: CALL_OW 321
78153: PUSH
78154: LD_INT 2
78156: NONEQUAL
78157: AND
78158: IFFALSE 78208
// begin if mc_deposits_finder [ i ] then
78160: LD_EXP 99
78164: PUSH
78165: LD_VAR 0 2
78169: ARRAY
78170: IFFALSE 78206
// begin MC_Reset ( i , 125 ) ;
78172: LD_VAR 0 2
78176: PPUSH
78177: LD_INT 125
78179: PPUSH
78180: CALL 61012 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78184: LD_ADDR_EXP 99
78188: PUSH
78189: LD_EXP 99
78193: PPUSH
78194: LD_VAR 0 2
78198: PPUSH
78199: EMPTY
78200: PPUSH
78201: CALL_OW 1
78205: ST_TO_ADDR
// end ; continue ;
78206: GO 77964
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
78208: LD_EXP 98
78212: PUSH
78213: LD_VAR 0 2
78217: ARRAY
78218: PUSH
78219: LD_INT 1
78221: ARRAY
78222: PUSH
78223: LD_INT 1
78225: ARRAY
78226: PPUSH
78227: LD_EXP 98
78231: PUSH
78232: LD_VAR 0 2
78236: ARRAY
78237: PUSH
78238: LD_INT 1
78240: ARRAY
78241: PUSH
78242: LD_INT 2
78244: ARRAY
78245: PPUSH
78246: LD_EXP 87
78250: PUSH
78251: LD_VAR 0 2
78255: ARRAY
78256: PPUSH
78257: CALL_OW 440
78261: IFFALSE 78304
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
78263: LD_ADDR_EXP 98
78267: PUSH
78268: LD_EXP 98
78272: PPUSH
78273: LD_VAR 0 2
78277: PPUSH
78278: LD_EXP 98
78282: PUSH
78283: LD_VAR 0 2
78287: ARRAY
78288: PPUSH
78289: LD_INT 1
78291: PPUSH
78292: CALL_OW 3
78296: PPUSH
78297: CALL_OW 1
78301: ST_TO_ADDR
78302: GO 78551
// begin if not mc_deposits_finder [ i ] then
78304: LD_EXP 99
78308: PUSH
78309: LD_VAR 0 2
78313: ARRAY
78314: NOT
78315: IFFALSE 78367
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
78317: LD_ADDR_EXP 99
78321: PUSH
78322: LD_EXP 99
78326: PPUSH
78327: LD_VAR 0 2
78331: PPUSH
78332: LD_VAR 0 3
78336: PUSH
78337: LD_INT 1
78339: ARRAY
78340: PUSH
78341: EMPTY
78342: LIST
78343: PPUSH
78344: CALL_OW 1
78348: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
78349: LD_VAR 0 3
78353: PUSH
78354: LD_INT 1
78356: ARRAY
78357: PPUSH
78358: LD_INT 125
78360: PPUSH
78361: CALL_OW 109
// end else
78365: GO 78551
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
78367: LD_EXP 99
78371: PUSH
78372: LD_VAR 0 2
78376: ARRAY
78377: PUSH
78378: LD_INT 1
78380: ARRAY
78381: PPUSH
78382: CALL_OW 310
78386: IFFALSE 78409
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
78388: LD_EXP 99
78392: PUSH
78393: LD_VAR 0 2
78397: ARRAY
78398: PUSH
78399: LD_INT 1
78401: ARRAY
78402: PPUSH
78403: CALL_OW 122
78407: GO 78551
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
78409: LD_EXP 99
78413: PUSH
78414: LD_VAR 0 2
78418: ARRAY
78419: PUSH
78420: LD_INT 1
78422: ARRAY
78423: PPUSH
78424: CALL_OW 314
78428: NOT
78429: PUSH
78430: LD_EXP 99
78434: PUSH
78435: LD_VAR 0 2
78439: ARRAY
78440: PUSH
78441: LD_INT 1
78443: ARRAY
78444: PPUSH
78445: LD_EXP 98
78449: PUSH
78450: LD_VAR 0 2
78454: ARRAY
78455: PUSH
78456: LD_INT 1
78458: ARRAY
78459: PUSH
78460: LD_INT 1
78462: ARRAY
78463: PPUSH
78464: LD_EXP 98
78468: PUSH
78469: LD_VAR 0 2
78473: ARRAY
78474: PUSH
78475: LD_INT 1
78477: ARRAY
78478: PUSH
78479: LD_INT 2
78481: ARRAY
78482: PPUSH
78483: CALL_OW 297
78487: PUSH
78488: LD_INT 6
78490: GREATER
78491: AND
78492: IFFALSE 78551
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
78494: LD_EXP 99
78498: PUSH
78499: LD_VAR 0 2
78503: ARRAY
78504: PUSH
78505: LD_INT 1
78507: ARRAY
78508: PPUSH
78509: LD_EXP 98
78513: PUSH
78514: LD_VAR 0 2
78518: ARRAY
78519: PUSH
78520: LD_INT 1
78522: ARRAY
78523: PUSH
78524: LD_INT 1
78526: ARRAY
78527: PPUSH
78528: LD_EXP 98
78532: PUSH
78533: LD_VAR 0 2
78537: ARRAY
78538: PUSH
78539: LD_INT 1
78541: ARRAY
78542: PUSH
78543: LD_INT 2
78545: ARRAY
78546: PPUSH
78547: CALL_OW 111
// end ; end ; end ;
78551: GO 77964
78553: POP
78554: POP
// end ;
78555: LD_VAR 0 1
78559: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
78560: LD_INT 0
78562: PPUSH
78563: PPUSH
78564: PPUSH
78565: PPUSH
78566: PPUSH
78567: PPUSH
78568: PPUSH
78569: PPUSH
78570: PPUSH
78571: PPUSH
78572: PPUSH
// if not mc_bases then
78573: LD_EXP 61
78577: NOT
78578: IFFALSE 78582
// exit ;
78580: GO 79522
// for i = 1 to mc_bases do
78582: LD_ADDR_VAR 0 2
78586: PUSH
78587: DOUBLE
78588: LD_INT 1
78590: DEC
78591: ST_TO_ADDR
78592: LD_EXP 61
78596: PUSH
78597: FOR_TO
78598: IFFALSE 79520
// begin if not mc_bases [ i ] or mc_scan [ i ] then
78600: LD_EXP 61
78604: PUSH
78605: LD_VAR 0 2
78609: ARRAY
78610: NOT
78611: PUSH
78612: LD_EXP 84
78616: PUSH
78617: LD_VAR 0 2
78621: ARRAY
78622: OR
78623: IFFALSE 78627
// continue ;
78625: GO 78597
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78627: LD_ADDR_VAR 0 7
78631: PUSH
78632: LD_EXP 61
78636: PUSH
78637: LD_VAR 0 2
78641: ARRAY
78642: PUSH
78643: LD_INT 1
78645: ARRAY
78646: PPUSH
78647: CALL_OW 248
78651: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78652: LD_VAR 0 7
78656: PUSH
78657: LD_INT 3
78659: EQUAL
78660: PUSH
78661: LD_EXP 80
78665: PUSH
78666: LD_VAR 0 2
78670: ARRAY
78671: PUSH
78672: LD_EXP 83
78676: PUSH
78677: LD_VAR 0 2
78681: ARRAY
78682: UNION
78683: PPUSH
78684: LD_INT 33
78686: PUSH
78687: LD_INT 2
78689: PUSH
78690: EMPTY
78691: LIST
78692: LIST
78693: PPUSH
78694: CALL_OW 72
78698: NOT
78699: OR
78700: IFFALSE 78704
// continue ;
78702: GO 78597
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78704: LD_ADDR_VAR 0 9
78708: PUSH
78709: LD_EXP 61
78713: PUSH
78714: LD_VAR 0 2
78718: ARRAY
78719: PPUSH
78720: LD_INT 30
78722: PUSH
78723: LD_INT 36
78725: PUSH
78726: EMPTY
78727: LIST
78728: LIST
78729: PPUSH
78730: CALL_OW 72
78734: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78735: LD_ADDR_VAR 0 10
78739: PUSH
78740: LD_EXP 80
78744: PUSH
78745: LD_VAR 0 2
78749: ARRAY
78750: PPUSH
78751: LD_INT 34
78753: PUSH
78754: LD_INT 31
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: PPUSH
78761: CALL_OW 72
78765: ST_TO_ADDR
// if not cts and not mcts then
78766: LD_VAR 0 9
78770: NOT
78771: PUSH
78772: LD_VAR 0 10
78776: NOT
78777: AND
78778: IFFALSE 78782
// continue ;
78780: GO 78597
// x := cts ;
78782: LD_ADDR_VAR 0 11
78786: PUSH
78787: LD_VAR 0 9
78791: ST_TO_ADDR
// if not x then
78792: LD_VAR 0 11
78796: NOT
78797: IFFALSE 78809
// x := mcts ;
78799: LD_ADDR_VAR 0 11
78803: PUSH
78804: LD_VAR 0 10
78808: ST_TO_ADDR
// if not x then
78809: LD_VAR 0 11
78813: NOT
78814: IFFALSE 78818
// continue ;
78816: GO 78597
// if mc_remote_driver [ i ] then
78818: LD_EXP 101
78822: PUSH
78823: LD_VAR 0 2
78827: ARRAY
78828: IFFALSE 79215
// for j in mc_remote_driver [ i ] do
78830: LD_ADDR_VAR 0 3
78834: PUSH
78835: LD_EXP 101
78839: PUSH
78840: LD_VAR 0 2
78844: ARRAY
78845: PUSH
78846: FOR_IN
78847: IFFALSE 79213
// begin if GetClass ( j ) <> 3 then
78849: LD_VAR 0 3
78853: PPUSH
78854: CALL_OW 257
78858: PUSH
78859: LD_INT 3
78861: NONEQUAL
78862: IFFALSE 78915
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
78864: LD_ADDR_EXP 101
78868: PUSH
78869: LD_EXP 101
78873: PPUSH
78874: LD_VAR 0 2
78878: PPUSH
78879: LD_EXP 101
78883: PUSH
78884: LD_VAR 0 2
78888: ARRAY
78889: PUSH
78890: LD_VAR 0 3
78894: DIFF
78895: PPUSH
78896: CALL_OW 1
78900: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78901: LD_VAR 0 3
78905: PPUSH
78906: LD_INT 0
78908: PPUSH
78909: CALL_OW 109
// continue ;
78913: GO 78846
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
78915: LD_EXP 80
78919: PUSH
78920: LD_VAR 0 2
78924: ARRAY
78925: PPUSH
78926: LD_INT 34
78928: PUSH
78929: LD_INT 31
78931: PUSH
78932: EMPTY
78933: LIST
78934: LIST
78935: PUSH
78936: LD_INT 58
78938: PUSH
78939: EMPTY
78940: LIST
78941: PUSH
78942: EMPTY
78943: LIST
78944: LIST
78945: PPUSH
78946: CALL_OW 72
78950: PUSH
78951: LD_VAR 0 3
78955: PPUSH
78956: CALL 50388 0 1
78960: NOT
78961: AND
78962: IFFALSE 79033
// begin if IsInUnit ( j ) then
78964: LD_VAR 0 3
78968: PPUSH
78969: CALL_OW 310
78973: IFFALSE 78984
// ComExitBuilding ( j ) ;
78975: LD_VAR 0 3
78979: PPUSH
78980: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
78984: LD_VAR 0 3
78988: PPUSH
78989: LD_EXP 80
78993: PUSH
78994: LD_VAR 0 2
78998: ARRAY
78999: PPUSH
79000: LD_INT 34
79002: PUSH
79003: LD_INT 31
79005: PUSH
79006: EMPTY
79007: LIST
79008: LIST
79009: PUSH
79010: LD_INT 58
79012: PUSH
79013: EMPTY
79014: LIST
79015: PUSH
79016: EMPTY
79017: LIST
79018: LIST
79019: PPUSH
79020: CALL_OW 72
79024: PUSH
79025: LD_INT 1
79027: ARRAY
79028: PPUSH
79029: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
79033: LD_VAR 0 3
79037: PPUSH
79038: CALL_OW 310
79042: NOT
79043: PUSH
79044: LD_VAR 0 3
79048: PPUSH
79049: CALL_OW 310
79053: PPUSH
79054: CALL_OW 266
79058: PUSH
79059: LD_INT 36
79061: NONEQUAL
79062: PUSH
79063: LD_VAR 0 3
79067: PPUSH
79068: CALL 50388 0 1
79072: NOT
79073: AND
79074: OR
79075: IFFALSE 79211
// begin if IsInUnit ( j ) then
79077: LD_VAR 0 3
79081: PPUSH
79082: CALL_OW 310
79086: IFFALSE 79097
// ComExitBuilding ( j ) ;
79088: LD_VAR 0 3
79092: PPUSH
79093: CALL_OW 122
// ct := 0 ;
79097: LD_ADDR_VAR 0 8
79101: PUSH
79102: LD_INT 0
79104: ST_TO_ADDR
// for k in x do
79105: LD_ADDR_VAR 0 4
79109: PUSH
79110: LD_VAR 0 11
79114: PUSH
79115: FOR_IN
79116: IFFALSE 79189
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
79118: LD_VAR 0 4
79122: PPUSH
79123: CALL_OW 264
79127: PUSH
79128: LD_INT 31
79130: EQUAL
79131: PUSH
79132: LD_VAR 0 4
79136: PPUSH
79137: CALL_OW 311
79141: NOT
79142: AND
79143: PUSH
79144: LD_VAR 0 4
79148: PPUSH
79149: CALL_OW 266
79153: PUSH
79154: LD_INT 36
79156: EQUAL
79157: PUSH
79158: LD_VAR 0 4
79162: PPUSH
79163: CALL_OW 313
79167: PUSH
79168: LD_INT 3
79170: LESS
79171: AND
79172: OR
79173: IFFALSE 79187
// begin ct := k ;
79175: LD_ADDR_VAR 0 8
79179: PUSH
79180: LD_VAR 0 4
79184: ST_TO_ADDR
// break ;
79185: GO 79189
// end ;
79187: GO 79115
79189: POP
79190: POP
// if ct then
79191: LD_VAR 0 8
79195: IFFALSE 79211
// ComEnterUnit ( j , ct ) ;
79197: LD_VAR 0 3
79201: PPUSH
79202: LD_VAR 0 8
79206: PPUSH
79207: CALL_OW 120
// end ; end ;
79211: GO 78846
79213: POP
79214: POP
// places := 0 ;
79215: LD_ADDR_VAR 0 5
79219: PUSH
79220: LD_INT 0
79222: ST_TO_ADDR
// for j = 1 to x do
79223: LD_ADDR_VAR 0 3
79227: PUSH
79228: DOUBLE
79229: LD_INT 1
79231: DEC
79232: ST_TO_ADDR
79233: LD_VAR 0 11
79237: PUSH
79238: FOR_TO
79239: IFFALSE 79315
// if GetWeapon ( x [ j ] ) = ar_control_tower then
79241: LD_VAR 0 11
79245: PUSH
79246: LD_VAR 0 3
79250: ARRAY
79251: PPUSH
79252: CALL_OW 264
79256: PUSH
79257: LD_INT 31
79259: EQUAL
79260: IFFALSE 79278
// places := places + 1 else
79262: LD_ADDR_VAR 0 5
79266: PUSH
79267: LD_VAR 0 5
79271: PUSH
79272: LD_INT 1
79274: PLUS
79275: ST_TO_ADDR
79276: GO 79313
// if GetBType ( x [ j ] ) = b_control_tower then
79278: LD_VAR 0 11
79282: PUSH
79283: LD_VAR 0 3
79287: ARRAY
79288: PPUSH
79289: CALL_OW 266
79293: PUSH
79294: LD_INT 36
79296: EQUAL
79297: IFFALSE 79313
// places := places + 3 ;
79299: LD_ADDR_VAR 0 5
79303: PUSH
79304: LD_VAR 0 5
79308: PUSH
79309: LD_INT 3
79311: PLUS
79312: ST_TO_ADDR
79313: GO 79238
79315: POP
79316: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
79317: LD_VAR 0 5
79321: PUSH
79322: LD_INT 0
79324: EQUAL
79325: PUSH
79326: LD_VAR 0 5
79330: PUSH
79331: LD_EXP 101
79335: PUSH
79336: LD_VAR 0 2
79340: ARRAY
79341: LESSEQUAL
79342: OR
79343: IFFALSE 79347
// continue ;
79345: GO 78597
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
79347: LD_ADDR_VAR 0 6
79351: PUSH
79352: LD_EXP 61
79356: PUSH
79357: LD_VAR 0 2
79361: ARRAY
79362: PPUSH
79363: LD_INT 25
79365: PUSH
79366: LD_INT 3
79368: PUSH
79369: EMPTY
79370: LIST
79371: LIST
79372: PPUSH
79373: CALL_OW 72
79377: PUSH
79378: LD_EXP 101
79382: PUSH
79383: LD_VAR 0 2
79387: ARRAY
79388: DIFF
79389: PPUSH
79390: LD_INT 3
79392: PPUSH
79393: CALL 51288 0 2
79397: ST_TO_ADDR
// for j in tmp do
79398: LD_ADDR_VAR 0 3
79402: PUSH
79403: LD_VAR 0 6
79407: PUSH
79408: FOR_IN
79409: IFFALSE 79444
// if GetTag ( j ) > 0 then
79411: LD_VAR 0 3
79415: PPUSH
79416: CALL_OW 110
79420: PUSH
79421: LD_INT 0
79423: GREATER
79424: IFFALSE 79442
// tmp := tmp diff j ;
79426: LD_ADDR_VAR 0 6
79430: PUSH
79431: LD_VAR 0 6
79435: PUSH
79436: LD_VAR 0 3
79440: DIFF
79441: ST_TO_ADDR
79442: GO 79408
79444: POP
79445: POP
// if not tmp then
79446: LD_VAR 0 6
79450: NOT
79451: IFFALSE 79455
// continue ;
79453: GO 78597
// if places then
79455: LD_VAR 0 5
79459: IFFALSE 79518
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
79461: LD_ADDR_EXP 101
79465: PUSH
79466: LD_EXP 101
79470: PPUSH
79471: LD_VAR 0 2
79475: PPUSH
79476: LD_EXP 101
79480: PUSH
79481: LD_VAR 0 2
79485: ARRAY
79486: PUSH
79487: LD_VAR 0 6
79491: PUSH
79492: LD_INT 1
79494: ARRAY
79495: UNION
79496: PPUSH
79497: CALL_OW 1
79501: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
79502: LD_VAR 0 6
79506: PUSH
79507: LD_INT 1
79509: ARRAY
79510: PPUSH
79511: LD_INT 126
79513: PPUSH
79514: CALL_OW 109
// end ; end ;
79518: GO 78597
79520: POP
79521: POP
// end ;
79522: LD_VAR 0 1
79526: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
79527: LD_INT 0
79529: PPUSH
79530: PPUSH
79531: PPUSH
79532: PPUSH
79533: PPUSH
79534: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
79535: LD_VAR 0 1
79539: NOT
79540: PUSH
79541: LD_VAR 0 2
79545: NOT
79546: OR
79547: PUSH
79548: LD_VAR 0 3
79552: NOT
79553: OR
79554: PUSH
79555: LD_VAR 0 4
79559: PUSH
79560: LD_INT 1
79562: PUSH
79563: LD_INT 2
79565: PUSH
79566: LD_INT 3
79568: PUSH
79569: LD_INT 4
79571: PUSH
79572: LD_INT 5
79574: PUSH
79575: LD_INT 8
79577: PUSH
79578: LD_INT 9
79580: PUSH
79581: LD_INT 15
79583: PUSH
79584: LD_INT 16
79586: PUSH
79587: EMPTY
79588: LIST
79589: LIST
79590: LIST
79591: LIST
79592: LIST
79593: LIST
79594: LIST
79595: LIST
79596: LIST
79597: IN
79598: NOT
79599: OR
79600: IFFALSE 79604
// exit ;
79602: GO 80462
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
79604: LD_ADDR_VAR 0 2
79608: PUSH
79609: LD_VAR 0 2
79613: PPUSH
79614: LD_INT 21
79616: PUSH
79617: LD_INT 3
79619: PUSH
79620: EMPTY
79621: LIST
79622: LIST
79623: PUSH
79624: LD_INT 24
79626: PUSH
79627: LD_INT 250
79629: PUSH
79630: EMPTY
79631: LIST
79632: LIST
79633: PUSH
79634: EMPTY
79635: LIST
79636: LIST
79637: PPUSH
79638: CALL_OW 72
79642: ST_TO_ADDR
// case class of 1 , 15 :
79643: LD_VAR 0 4
79647: PUSH
79648: LD_INT 1
79650: DOUBLE
79651: EQUAL
79652: IFTRUE 79662
79654: LD_INT 15
79656: DOUBLE
79657: EQUAL
79658: IFTRUE 79662
79660: GO 79747
79662: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
79663: LD_ADDR_VAR 0 8
79667: PUSH
79668: LD_VAR 0 2
79672: PPUSH
79673: LD_INT 2
79675: PUSH
79676: LD_INT 30
79678: PUSH
79679: LD_INT 32
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: PUSH
79686: LD_INT 30
79688: PUSH
79689: LD_INT 31
79691: PUSH
79692: EMPTY
79693: LIST
79694: LIST
79695: PUSH
79696: EMPTY
79697: LIST
79698: LIST
79699: LIST
79700: PPUSH
79701: CALL_OW 72
79705: PUSH
79706: LD_VAR 0 2
79710: PPUSH
79711: LD_INT 2
79713: PUSH
79714: LD_INT 30
79716: PUSH
79717: LD_INT 4
79719: PUSH
79720: EMPTY
79721: LIST
79722: LIST
79723: PUSH
79724: LD_INT 30
79726: PUSH
79727: LD_INT 5
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: PUSH
79734: EMPTY
79735: LIST
79736: LIST
79737: LIST
79738: PPUSH
79739: CALL_OW 72
79743: ADD
79744: ST_TO_ADDR
79745: GO 79993
79747: LD_INT 2
79749: DOUBLE
79750: EQUAL
79751: IFTRUE 79761
79753: LD_INT 16
79755: DOUBLE
79756: EQUAL
79757: IFTRUE 79761
79759: GO 79807
79761: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
79762: LD_ADDR_VAR 0 8
79766: PUSH
79767: LD_VAR 0 2
79771: PPUSH
79772: LD_INT 2
79774: PUSH
79775: LD_INT 30
79777: PUSH
79778: LD_INT 0
79780: PUSH
79781: EMPTY
79782: LIST
79783: LIST
79784: PUSH
79785: LD_INT 30
79787: PUSH
79788: LD_INT 1
79790: PUSH
79791: EMPTY
79792: LIST
79793: LIST
79794: PUSH
79795: EMPTY
79796: LIST
79797: LIST
79798: LIST
79799: PPUSH
79800: CALL_OW 72
79804: ST_TO_ADDR
79805: GO 79993
79807: LD_INT 3
79809: DOUBLE
79810: EQUAL
79811: IFTRUE 79815
79813: GO 79861
79815: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
79816: LD_ADDR_VAR 0 8
79820: PUSH
79821: LD_VAR 0 2
79825: PPUSH
79826: LD_INT 2
79828: PUSH
79829: LD_INT 30
79831: PUSH
79832: LD_INT 2
79834: PUSH
79835: EMPTY
79836: LIST
79837: LIST
79838: PUSH
79839: LD_INT 30
79841: PUSH
79842: LD_INT 3
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: EMPTY
79850: LIST
79851: LIST
79852: LIST
79853: PPUSH
79854: CALL_OW 72
79858: ST_TO_ADDR
79859: GO 79993
79861: LD_INT 4
79863: DOUBLE
79864: EQUAL
79865: IFTRUE 79869
79867: GO 79926
79869: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
79870: LD_ADDR_VAR 0 8
79874: PUSH
79875: LD_VAR 0 2
79879: PPUSH
79880: LD_INT 2
79882: PUSH
79883: LD_INT 30
79885: PUSH
79886: LD_INT 6
79888: PUSH
79889: EMPTY
79890: LIST
79891: LIST
79892: PUSH
79893: LD_INT 30
79895: PUSH
79896: LD_INT 7
79898: PUSH
79899: EMPTY
79900: LIST
79901: LIST
79902: PUSH
79903: LD_INT 30
79905: PUSH
79906: LD_INT 8
79908: PUSH
79909: EMPTY
79910: LIST
79911: LIST
79912: PUSH
79913: EMPTY
79914: LIST
79915: LIST
79916: LIST
79917: LIST
79918: PPUSH
79919: CALL_OW 72
79923: ST_TO_ADDR
79924: GO 79993
79926: LD_INT 5
79928: DOUBLE
79929: EQUAL
79930: IFTRUE 79946
79932: LD_INT 8
79934: DOUBLE
79935: EQUAL
79936: IFTRUE 79946
79938: LD_INT 9
79940: DOUBLE
79941: EQUAL
79942: IFTRUE 79946
79944: GO 79992
79946: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
79947: LD_ADDR_VAR 0 8
79951: PUSH
79952: LD_VAR 0 2
79956: PPUSH
79957: LD_INT 2
79959: PUSH
79960: LD_INT 30
79962: PUSH
79963: LD_INT 4
79965: PUSH
79966: EMPTY
79967: LIST
79968: LIST
79969: PUSH
79970: LD_INT 30
79972: PUSH
79973: LD_INT 5
79975: PUSH
79976: EMPTY
79977: LIST
79978: LIST
79979: PUSH
79980: EMPTY
79981: LIST
79982: LIST
79983: LIST
79984: PPUSH
79985: CALL_OW 72
79989: ST_TO_ADDR
79990: GO 79993
79992: POP
// if not tmp then
79993: LD_VAR 0 8
79997: NOT
79998: IFFALSE 80002
// exit ;
80000: GO 80462
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
80002: LD_VAR 0 4
80006: PUSH
80007: LD_INT 1
80009: PUSH
80010: LD_INT 15
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: IN
80017: PUSH
80018: LD_EXP 70
80022: PUSH
80023: LD_VAR 0 1
80027: ARRAY
80028: AND
80029: IFFALSE 80185
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
80031: LD_ADDR_VAR 0 9
80035: PUSH
80036: LD_EXP 70
80040: PUSH
80041: LD_VAR 0 1
80045: ARRAY
80046: PUSH
80047: LD_INT 1
80049: ARRAY
80050: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
80051: LD_VAR 0 9
80055: PUSH
80056: LD_EXP 71
80060: PUSH
80061: LD_VAR 0 1
80065: ARRAY
80066: IN
80067: NOT
80068: IFFALSE 80183
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
80070: LD_ADDR_EXP 71
80074: PUSH
80075: LD_EXP 71
80079: PPUSH
80080: LD_VAR 0 1
80084: PUSH
80085: LD_EXP 71
80089: PUSH
80090: LD_VAR 0 1
80094: ARRAY
80095: PUSH
80096: LD_INT 1
80098: PLUS
80099: PUSH
80100: EMPTY
80101: LIST
80102: LIST
80103: PPUSH
80104: LD_VAR 0 9
80108: PPUSH
80109: CALL 20441 0 3
80113: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
80114: LD_ADDR_EXP 70
80118: PUSH
80119: LD_EXP 70
80123: PPUSH
80124: LD_VAR 0 1
80128: PPUSH
80129: LD_EXP 70
80133: PUSH
80134: LD_VAR 0 1
80138: ARRAY
80139: PUSH
80140: LD_VAR 0 9
80144: DIFF
80145: PPUSH
80146: CALL_OW 1
80150: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
80151: LD_VAR 0 3
80155: PPUSH
80156: LD_EXP 71
80160: PUSH
80161: LD_VAR 0 1
80165: ARRAY
80166: PUSH
80167: LD_EXP 71
80171: PUSH
80172: LD_VAR 0 1
80176: ARRAY
80177: ARRAY
80178: PPUSH
80179: CALL_OW 120
// end ; exit ;
80183: GO 80462
// end ; if tmp > 1 then
80185: LD_VAR 0 8
80189: PUSH
80190: LD_INT 1
80192: GREATER
80193: IFFALSE 80297
// for i = 2 to tmp do
80195: LD_ADDR_VAR 0 6
80199: PUSH
80200: DOUBLE
80201: LD_INT 2
80203: DEC
80204: ST_TO_ADDR
80205: LD_VAR 0 8
80209: PUSH
80210: FOR_TO
80211: IFFALSE 80295
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
80213: LD_VAR 0 8
80217: PUSH
80218: LD_VAR 0 6
80222: ARRAY
80223: PPUSH
80224: CALL_OW 461
80228: PUSH
80229: LD_INT 6
80231: EQUAL
80232: IFFALSE 80293
// begin x := tmp [ i ] ;
80234: LD_ADDR_VAR 0 9
80238: PUSH
80239: LD_VAR 0 8
80243: PUSH
80244: LD_VAR 0 6
80248: ARRAY
80249: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
80250: LD_ADDR_VAR 0 8
80254: PUSH
80255: LD_VAR 0 8
80259: PPUSH
80260: LD_VAR 0 6
80264: PPUSH
80265: CALL_OW 3
80269: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
80270: LD_ADDR_VAR 0 8
80274: PUSH
80275: LD_VAR 0 8
80279: PPUSH
80280: LD_INT 1
80282: PPUSH
80283: LD_VAR 0 9
80287: PPUSH
80288: CALL_OW 2
80292: ST_TO_ADDR
// end ;
80293: GO 80210
80295: POP
80296: POP
// for i in tmp do
80297: LD_ADDR_VAR 0 6
80301: PUSH
80302: LD_VAR 0 8
80306: PUSH
80307: FOR_IN
80308: IFFALSE 80335
// begin if IsNotFull ( i ) then
80310: LD_VAR 0 6
80314: PPUSH
80315: CALL 17663 0 1
80319: IFFALSE 80333
// begin j := i ;
80321: LD_ADDR_VAR 0 7
80325: PUSH
80326: LD_VAR 0 6
80330: ST_TO_ADDR
// break ;
80331: GO 80335
// end ; end ;
80333: GO 80307
80335: POP
80336: POP
// if j then
80337: LD_VAR 0 7
80341: IFFALSE 80359
// ComEnterUnit ( unit , j ) else
80343: LD_VAR 0 3
80347: PPUSH
80348: LD_VAR 0 7
80352: PPUSH
80353: CALL_OW 120
80357: GO 80462
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80359: LD_ADDR_VAR 0 10
80363: PUSH
80364: LD_VAR 0 2
80368: PPUSH
80369: LD_INT 2
80371: PUSH
80372: LD_INT 30
80374: PUSH
80375: LD_INT 0
80377: PUSH
80378: EMPTY
80379: LIST
80380: LIST
80381: PUSH
80382: LD_INT 30
80384: PUSH
80385: LD_INT 1
80387: PUSH
80388: EMPTY
80389: LIST
80390: LIST
80391: PUSH
80392: EMPTY
80393: LIST
80394: LIST
80395: LIST
80396: PPUSH
80397: CALL_OW 72
80401: ST_TO_ADDR
// if depot then
80402: LD_VAR 0 10
80406: IFFALSE 80462
// begin depot := NearestUnitToUnit ( depot , unit ) ;
80408: LD_ADDR_VAR 0 10
80412: PUSH
80413: LD_VAR 0 10
80417: PPUSH
80418: LD_VAR 0 3
80422: PPUSH
80423: CALL_OW 74
80427: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
80428: LD_VAR 0 3
80432: PPUSH
80433: LD_VAR 0 10
80437: PPUSH
80438: CALL_OW 296
80442: PUSH
80443: LD_INT 10
80445: GREATER
80446: IFFALSE 80462
// ComStandNearbyBuilding ( unit , depot ) ;
80448: LD_VAR 0 3
80452: PPUSH
80453: LD_VAR 0 10
80457: PPUSH
80458: CALL 17043 0 2
// end ; end ; end ;
80462: LD_VAR 0 5
80466: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
80467: LD_INT 0
80469: PPUSH
80470: PPUSH
80471: PPUSH
80472: PPUSH
// if not mc_bases then
80473: LD_EXP 61
80477: NOT
80478: IFFALSE 80482
// exit ;
80480: GO 80721
// for i = 1 to mc_bases do
80482: LD_ADDR_VAR 0 2
80486: PUSH
80487: DOUBLE
80488: LD_INT 1
80490: DEC
80491: ST_TO_ADDR
80492: LD_EXP 61
80496: PUSH
80497: FOR_TO
80498: IFFALSE 80719
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
80500: LD_ADDR_VAR 0 4
80504: PUSH
80505: LD_EXP 61
80509: PUSH
80510: LD_VAR 0 2
80514: ARRAY
80515: PPUSH
80516: LD_INT 21
80518: PUSH
80519: LD_INT 1
80521: PUSH
80522: EMPTY
80523: LIST
80524: LIST
80525: PPUSH
80526: CALL_OW 72
80530: PUSH
80531: LD_EXP 90
80535: PUSH
80536: LD_VAR 0 2
80540: ARRAY
80541: UNION
80542: ST_TO_ADDR
// if not tmp then
80543: LD_VAR 0 4
80547: NOT
80548: IFFALSE 80552
// continue ;
80550: GO 80497
// for j in tmp do
80552: LD_ADDR_VAR 0 3
80556: PUSH
80557: LD_VAR 0 4
80561: PUSH
80562: FOR_IN
80563: IFFALSE 80715
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
80565: LD_VAR 0 3
80569: PPUSH
80570: CALL_OW 110
80574: NOT
80575: PUSH
80576: LD_VAR 0 3
80580: PPUSH
80581: CALL_OW 314
80585: NOT
80586: AND
80587: PUSH
80588: LD_VAR 0 3
80592: PPUSH
80593: CALL_OW 311
80597: NOT
80598: AND
80599: PUSH
80600: LD_VAR 0 3
80604: PPUSH
80605: CALL_OW 310
80609: NOT
80610: AND
80611: PUSH
80612: LD_VAR 0 3
80616: PUSH
80617: LD_EXP 64
80621: PUSH
80622: LD_VAR 0 2
80626: ARRAY
80627: PUSH
80628: LD_INT 1
80630: ARRAY
80631: IN
80632: NOT
80633: AND
80634: PUSH
80635: LD_VAR 0 3
80639: PUSH
80640: LD_EXP 64
80644: PUSH
80645: LD_VAR 0 2
80649: ARRAY
80650: PUSH
80651: LD_INT 2
80653: ARRAY
80654: IN
80655: NOT
80656: AND
80657: PUSH
80658: LD_VAR 0 3
80662: PUSH
80663: LD_EXP 73
80667: PUSH
80668: LD_VAR 0 2
80672: ARRAY
80673: IN
80674: NOT
80675: AND
80676: IFFALSE 80713
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
80678: LD_VAR 0 2
80682: PPUSH
80683: LD_EXP 61
80687: PUSH
80688: LD_VAR 0 2
80692: ARRAY
80693: PPUSH
80694: LD_VAR 0 3
80698: PPUSH
80699: LD_VAR 0 3
80703: PPUSH
80704: CALL_OW 257
80708: PPUSH
80709: CALL 79527 0 4
// end ;
80713: GO 80562
80715: POP
80716: POP
// end ;
80717: GO 80497
80719: POP
80720: POP
// end ;
80721: LD_VAR 0 1
80725: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
80726: LD_INT 0
80728: PPUSH
80729: PPUSH
80730: PPUSH
80731: PPUSH
80732: PPUSH
80733: PPUSH
// if not mc_bases [ base ] then
80734: LD_EXP 61
80738: PUSH
80739: LD_VAR 0 1
80743: ARRAY
80744: NOT
80745: IFFALSE 80749
// exit ;
80747: GO 80950
// tmp := [ ] ;
80749: LD_ADDR_VAR 0 6
80753: PUSH
80754: EMPTY
80755: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80756: LD_ADDR_VAR 0 7
80760: PUSH
80761: LD_VAR 0 3
80765: PPUSH
80766: LD_INT 0
80768: PPUSH
80769: CALL_OW 517
80773: ST_TO_ADDR
// if not list then
80774: LD_VAR 0 7
80778: NOT
80779: IFFALSE 80783
// exit ;
80781: GO 80950
// c := Count ( list [ 1 ] ) ;
80783: LD_ADDR_VAR 0 9
80787: PUSH
80788: LD_VAR 0 7
80792: PUSH
80793: LD_INT 1
80795: ARRAY
80796: PPUSH
80797: CALL 17581 0 1
80801: ST_TO_ADDR
// if amount > c then
80802: LD_VAR 0 2
80806: PUSH
80807: LD_VAR 0 9
80811: GREATER
80812: IFFALSE 80824
// amount := c ;
80814: LD_ADDR_VAR 0 2
80818: PUSH
80819: LD_VAR 0 9
80823: ST_TO_ADDR
// for i := 1 to amount do
80824: LD_ADDR_VAR 0 5
80828: PUSH
80829: DOUBLE
80830: LD_INT 1
80832: DEC
80833: ST_TO_ADDR
80834: LD_VAR 0 2
80838: PUSH
80839: FOR_TO
80840: IFFALSE 80898
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
80842: LD_ADDR_VAR 0 6
80846: PUSH
80847: LD_VAR 0 6
80851: PPUSH
80852: LD_VAR 0 5
80856: PPUSH
80857: LD_VAR 0 7
80861: PUSH
80862: LD_INT 1
80864: ARRAY
80865: PUSH
80866: LD_VAR 0 5
80870: ARRAY
80871: PUSH
80872: LD_VAR 0 7
80876: PUSH
80877: LD_INT 2
80879: ARRAY
80880: PUSH
80881: LD_VAR 0 5
80885: ARRAY
80886: PUSH
80887: EMPTY
80888: LIST
80889: LIST
80890: PPUSH
80891: CALL_OW 1
80895: ST_TO_ADDR
80896: GO 80839
80898: POP
80899: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
80900: LD_ADDR_EXP 74
80904: PUSH
80905: LD_EXP 74
80909: PPUSH
80910: LD_VAR 0 1
80914: PPUSH
80915: LD_VAR 0 6
80919: PPUSH
80920: CALL_OW 1
80924: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
80925: LD_ADDR_EXP 76
80929: PUSH
80930: LD_EXP 76
80934: PPUSH
80935: LD_VAR 0 1
80939: PPUSH
80940: LD_VAR 0 3
80944: PPUSH
80945: CALL_OW 1
80949: ST_TO_ADDR
// end ;
80950: LD_VAR 0 4
80954: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
80955: LD_INT 0
80957: PPUSH
// if not mc_bases [ base ] then
80958: LD_EXP 61
80962: PUSH
80963: LD_VAR 0 1
80967: ARRAY
80968: NOT
80969: IFFALSE 80973
// exit ;
80971: GO 80998
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
80973: LD_ADDR_EXP 66
80977: PUSH
80978: LD_EXP 66
80982: PPUSH
80983: LD_VAR 0 1
80987: PPUSH
80988: LD_VAR 0 2
80992: PPUSH
80993: CALL_OW 1
80997: ST_TO_ADDR
// end ;
80998: LD_VAR 0 3
81002: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
81003: LD_INT 0
81005: PPUSH
// if not mc_bases [ base ] then
81006: LD_EXP 61
81010: PUSH
81011: LD_VAR 0 1
81015: ARRAY
81016: NOT
81017: IFFALSE 81021
// exit ;
81019: GO 81058
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
81021: LD_ADDR_EXP 66
81025: PUSH
81026: LD_EXP 66
81030: PPUSH
81031: LD_VAR 0 1
81035: PPUSH
81036: LD_EXP 66
81040: PUSH
81041: LD_VAR 0 1
81045: ARRAY
81046: PUSH
81047: LD_VAR 0 2
81051: UNION
81052: PPUSH
81053: CALL_OW 1
81057: ST_TO_ADDR
// end ;
81058: LD_VAR 0 3
81062: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
81063: LD_INT 0
81065: PPUSH
// if not mc_bases [ base ] then
81066: LD_EXP 61
81070: PUSH
81071: LD_VAR 0 1
81075: ARRAY
81076: NOT
81077: IFFALSE 81081
// exit ;
81079: GO 81106
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
81081: LD_ADDR_EXP 82
81085: PUSH
81086: LD_EXP 82
81090: PPUSH
81091: LD_VAR 0 1
81095: PPUSH
81096: LD_VAR 0 2
81100: PPUSH
81101: CALL_OW 1
81105: ST_TO_ADDR
// end ;
81106: LD_VAR 0 3
81110: RET
// export function MC_InsertProduceList ( base , components ) ; begin
81111: LD_INT 0
81113: PPUSH
// if not mc_bases [ base ] then
81114: LD_EXP 61
81118: PUSH
81119: LD_VAR 0 1
81123: ARRAY
81124: NOT
81125: IFFALSE 81129
// exit ;
81127: GO 81166
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
81129: LD_ADDR_EXP 82
81133: PUSH
81134: LD_EXP 82
81138: PPUSH
81139: LD_VAR 0 1
81143: PPUSH
81144: LD_EXP 82
81148: PUSH
81149: LD_VAR 0 1
81153: ARRAY
81154: PUSH
81155: LD_VAR 0 2
81159: ADD
81160: PPUSH
81161: CALL_OW 1
81165: ST_TO_ADDR
// end ;
81166: LD_VAR 0 3
81170: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
81171: LD_INT 0
81173: PPUSH
// if not mc_bases [ base ] then
81174: LD_EXP 61
81178: PUSH
81179: LD_VAR 0 1
81183: ARRAY
81184: NOT
81185: IFFALSE 81189
// exit ;
81187: GO 81243
// mc_defender := Replace ( mc_defender , base , deflist ) ;
81189: LD_ADDR_EXP 83
81193: PUSH
81194: LD_EXP 83
81198: PPUSH
81199: LD_VAR 0 1
81203: PPUSH
81204: LD_VAR 0 2
81208: PPUSH
81209: CALL_OW 1
81213: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
81214: LD_ADDR_EXP 72
81218: PUSH
81219: LD_EXP 72
81223: PPUSH
81224: LD_VAR 0 1
81228: PPUSH
81229: LD_VAR 0 2
81233: PUSH
81234: LD_INT 0
81236: PLUS
81237: PPUSH
81238: CALL_OW 1
81242: ST_TO_ADDR
// end ;
81243: LD_VAR 0 3
81247: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
81248: LD_INT 0
81250: PPUSH
// if not mc_bases [ base ] then
81251: LD_EXP 61
81255: PUSH
81256: LD_VAR 0 1
81260: ARRAY
81261: NOT
81262: IFFALSE 81266
// exit ;
81264: GO 81291
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
81266: LD_ADDR_EXP 72
81270: PUSH
81271: LD_EXP 72
81275: PPUSH
81276: LD_VAR 0 1
81280: PPUSH
81281: LD_VAR 0 2
81285: PPUSH
81286: CALL_OW 1
81290: ST_TO_ADDR
// end ;
81291: LD_VAR 0 3
81295: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
81296: LD_INT 0
81298: PPUSH
81299: PPUSH
81300: PPUSH
81301: PPUSH
// if not mc_bases [ base ] then
81302: LD_EXP 61
81306: PUSH
81307: LD_VAR 0 1
81311: ARRAY
81312: NOT
81313: IFFALSE 81317
// exit ;
81315: GO 81382
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
81317: LD_ADDR_EXP 81
81321: PUSH
81322: LD_EXP 81
81326: PPUSH
81327: LD_VAR 0 1
81331: PUSH
81332: LD_EXP 81
81336: PUSH
81337: LD_VAR 0 1
81341: ARRAY
81342: PUSH
81343: LD_INT 1
81345: PLUS
81346: PUSH
81347: EMPTY
81348: LIST
81349: LIST
81350: PPUSH
81351: LD_VAR 0 1
81355: PUSH
81356: LD_VAR 0 2
81360: PUSH
81361: LD_VAR 0 3
81365: PUSH
81366: LD_VAR 0 4
81370: PUSH
81371: EMPTY
81372: LIST
81373: LIST
81374: LIST
81375: LIST
81376: PPUSH
81377: CALL 20441 0 3
81381: ST_TO_ADDR
// end ;
81382: LD_VAR 0 5
81386: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
81387: LD_INT 0
81389: PPUSH
// if not mc_bases [ base ] then
81390: LD_EXP 61
81394: PUSH
81395: LD_VAR 0 1
81399: ARRAY
81400: NOT
81401: IFFALSE 81405
// exit ;
81403: GO 81430
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
81405: LD_ADDR_EXP 98
81409: PUSH
81410: LD_EXP 98
81414: PPUSH
81415: LD_VAR 0 1
81419: PPUSH
81420: LD_VAR 0 2
81424: PPUSH
81425: CALL_OW 1
81429: ST_TO_ADDR
// end ;
81430: LD_VAR 0 3
81434: RET
// export function MC_GetMinesField ( base ) ; begin
81435: LD_INT 0
81437: PPUSH
// result := mc_mines [ base ] ;
81438: LD_ADDR_VAR 0 2
81442: PUSH
81443: LD_EXP 74
81447: PUSH
81448: LD_VAR 0 1
81452: ARRAY
81453: ST_TO_ADDR
// end ;
81454: LD_VAR 0 2
81458: RET
// export function MC_GetProduceList ( base ) ; begin
81459: LD_INT 0
81461: PPUSH
// result := mc_produce [ base ] ;
81462: LD_ADDR_VAR 0 2
81466: PUSH
81467: LD_EXP 82
81471: PUSH
81472: LD_VAR 0 1
81476: ARRAY
81477: ST_TO_ADDR
// end ;
81478: LD_VAR 0 2
81482: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
81483: LD_INT 0
81485: PPUSH
81486: PPUSH
// if not mc_bases then
81487: LD_EXP 61
81491: NOT
81492: IFFALSE 81496
// exit ;
81494: GO 81561
// if mc_bases [ base ] then
81496: LD_EXP 61
81500: PUSH
81501: LD_VAR 0 1
81505: ARRAY
81506: IFFALSE 81561
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81508: LD_ADDR_VAR 0 3
81512: PUSH
81513: LD_EXP 61
81517: PUSH
81518: LD_VAR 0 1
81522: ARRAY
81523: PPUSH
81524: LD_INT 30
81526: PUSH
81527: LD_VAR 0 2
81531: PUSH
81532: EMPTY
81533: LIST
81534: LIST
81535: PPUSH
81536: CALL_OW 72
81540: ST_TO_ADDR
// if result then
81541: LD_VAR 0 3
81545: IFFALSE 81561
// result := result [ 1 ] ;
81547: LD_ADDR_VAR 0 3
81551: PUSH
81552: LD_VAR 0 3
81556: PUSH
81557: LD_INT 1
81559: ARRAY
81560: ST_TO_ADDR
// end ; end ;
81561: LD_VAR 0 3
81565: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
81566: LD_INT 0
81568: PPUSH
81569: PPUSH
// if not mc_bases then
81570: LD_EXP 61
81574: NOT
81575: IFFALSE 81579
// exit ;
81577: GO 81624
// if mc_bases [ base ] then
81579: LD_EXP 61
81583: PUSH
81584: LD_VAR 0 1
81588: ARRAY
81589: IFFALSE 81624
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81591: LD_ADDR_VAR 0 3
81595: PUSH
81596: LD_EXP 61
81600: PUSH
81601: LD_VAR 0 1
81605: ARRAY
81606: PPUSH
81607: LD_INT 30
81609: PUSH
81610: LD_VAR 0 2
81614: PUSH
81615: EMPTY
81616: LIST
81617: LIST
81618: PPUSH
81619: CALL_OW 72
81623: ST_TO_ADDR
// end ;
81624: LD_VAR 0 3
81628: RET
// export function MC_SetTame ( base , area ) ; begin
81629: LD_INT 0
81631: PPUSH
// if not mc_bases or not base then
81632: LD_EXP 61
81636: NOT
81637: PUSH
81638: LD_VAR 0 1
81642: NOT
81643: OR
81644: IFFALSE 81648
// exit ;
81646: GO 81673
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
81648: LD_ADDR_EXP 89
81652: PUSH
81653: LD_EXP 89
81657: PPUSH
81658: LD_VAR 0 1
81662: PPUSH
81663: LD_VAR 0 2
81667: PPUSH
81668: CALL_OW 1
81672: ST_TO_ADDR
// end ;
81673: LD_VAR 0 3
81677: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
81678: LD_INT 0
81680: PPUSH
81681: PPUSH
// if not mc_bases or not base then
81682: LD_EXP 61
81686: NOT
81687: PUSH
81688: LD_VAR 0 1
81692: NOT
81693: OR
81694: IFFALSE 81698
// exit ;
81696: GO 81800
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81698: LD_ADDR_VAR 0 4
81702: PUSH
81703: LD_EXP 61
81707: PUSH
81708: LD_VAR 0 1
81712: ARRAY
81713: PPUSH
81714: LD_INT 30
81716: PUSH
81717: LD_VAR 0 2
81721: PUSH
81722: EMPTY
81723: LIST
81724: LIST
81725: PPUSH
81726: CALL_OW 72
81730: ST_TO_ADDR
// if not tmp then
81731: LD_VAR 0 4
81735: NOT
81736: IFFALSE 81740
// exit ;
81738: GO 81800
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
81740: LD_ADDR_EXP 93
81744: PUSH
81745: LD_EXP 93
81749: PPUSH
81750: LD_VAR 0 1
81754: PPUSH
81755: LD_EXP 93
81759: PUSH
81760: LD_VAR 0 1
81764: ARRAY
81765: PPUSH
81766: LD_EXP 93
81770: PUSH
81771: LD_VAR 0 1
81775: ARRAY
81776: PUSH
81777: LD_INT 1
81779: PLUS
81780: PPUSH
81781: LD_VAR 0 4
81785: PUSH
81786: LD_INT 1
81788: ARRAY
81789: PPUSH
81790: CALL_OW 2
81794: PPUSH
81795: CALL_OW 1
81799: ST_TO_ADDR
// end ;
81800: LD_VAR 0 3
81804: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
81805: LD_INT 0
81807: PPUSH
81808: PPUSH
// if not mc_bases or not base or not kinds then
81809: LD_EXP 61
81813: NOT
81814: PUSH
81815: LD_VAR 0 1
81819: NOT
81820: OR
81821: PUSH
81822: LD_VAR 0 2
81826: NOT
81827: OR
81828: IFFALSE 81832
// exit ;
81830: GO 81893
// for i in kinds do
81832: LD_ADDR_VAR 0 4
81836: PUSH
81837: LD_VAR 0 2
81841: PUSH
81842: FOR_IN
81843: IFFALSE 81891
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
81845: LD_ADDR_EXP 95
81849: PUSH
81850: LD_EXP 95
81854: PPUSH
81855: LD_VAR 0 1
81859: PUSH
81860: LD_EXP 95
81864: PUSH
81865: LD_VAR 0 1
81869: ARRAY
81870: PUSH
81871: LD_INT 1
81873: PLUS
81874: PUSH
81875: EMPTY
81876: LIST
81877: LIST
81878: PPUSH
81879: LD_VAR 0 4
81883: PPUSH
81884: CALL 20441 0 3
81888: ST_TO_ADDR
81889: GO 81842
81891: POP
81892: POP
// end ;
81893: LD_VAR 0 3
81897: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
81898: LD_INT 0
81900: PPUSH
// if not mc_bases or not base or not areas then
81901: LD_EXP 61
81905: NOT
81906: PUSH
81907: LD_VAR 0 1
81911: NOT
81912: OR
81913: PUSH
81914: LD_VAR 0 2
81918: NOT
81919: OR
81920: IFFALSE 81924
// exit ;
81922: GO 81949
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
81924: LD_ADDR_EXP 79
81928: PUSH
81929: LD_EXP 79
81933: PPUSH
81934: LD_VAR 0 1
81938: PPUSH
81939: LD_VAR 0 2
81943: PPUSH
81944: CALL_OW 1
81948: ST_TO_ADDR
// end ;
81949: LD_VAR 0 3
81953: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
81954: LD_INT 0
81956: PPUSH
// if not mc_bases or not base or not teleports_exit then
81957: LD_EXP 61
81961: NOT
81962: PUSH
81963: LD_VAR 0 1
81967: NOT
81968: OR
81969: PUSH
81970: LD_VAR 0 2
81974: NOT
81975: OR
81976: IFFALSE 81980
// exit ;
81978: GO 82005
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
81980: LD_ADDR_EXP 96
81984: PUSH
81985: LD_EXP 96
81989: PPUSH
81990: LD_VAR 0 1
81994: PPUSH
81995: LD_VAR 0 2
81999: PPUSH
82000: CALL_OW 1
82004: ST_TO_ADDR
// end ;
82005: LD_VAR 0 3
82009: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
82010: LD_INT 0
82012: PPUSH
82013: PPUSH
82014: PPUSH
// if not mc_bases or not base or not ext_list then
82015: LD_EXP 61
82019: NOT
82020: PUSH
82021: LD_VAR 0 1
82025: NOT
82026: OR
82027: PUSH
82028: LD_VAR 0 5
82032: NOT
82033: OR
82034: IFFALSE 82038
// exit ;
82036: GO 82211
// tmp := GetFacExtXYD ( x , y , d ) ;
82038: LD_ADDR_VAR 0 8
82042: PUSH
82043: LD_VAR 0 2
82047: PPUSH
82048: LD_VAR 0 3
82052: PPUSH
82053: LD_VAR 0 4
82057: PPUSH
82058: CALL 50418 0 3
82062: ST_TO_ADDR
// if not tmp then
82063: LD_VAR 0 8
82067: NOT
82068: IFFALSE 82072
// exit ;
82070: GO 82211
// for i in tmp do
82072: LD_ADDR_VAR 0 7
82076: PUSH
82077: LD_VAR 0 8
82081: PUSH
82082: FOR_IN
82083: IFFALSE 82209
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
82085: LD_ADDR_EXP 66
82089: PUSH
82090: LD_EXP 66
82094: PPUSH
82095: LD_VAR 0 1
82099: PPUSH
82100: LD_EXP 66
82104: PUSH
82105: LD_VAR 0 1
82109: ARRAY
82110: PPUSH
82111: LD_EXP 66
82115: PUSH
82116: LD_VAR 0 1
82120: ARRAY
82121: PUSH
82122: LD_INT 1
82124: PLUS
82125: PPUSH
82126: LD_VAR 0 5
82130: PUSH
82131: LD_INT 1
82133: ARRAY
82134: PUSH
82135: LD_VAR 0 7
82139: PUSH
82140: LD_INT 1
82142: ARRAY
82143: PUSH
82144: LD_VAR 0 7
82148: PUSH
82149: LD_INT 2
82151: ARRAY
82152: PUSH
82153: LD_VAR 0 7
82157: PUSH
82158: LD_INT 3
82160: ARRAY
82161: PUSH
82162: EMPTY
82163: LIST
82164: LIST
82165: LIST
82166: LIST
82167: PPUSH
82168: CALL_OW 2
82172: PPUSH
82173: CALL_OW 1
82177: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
82178: LD_ADDR_VAR 0 5
82182: PUSH
82183: LD_VAR 0 5
82187: PPUSH
82188: LD_INT 1
82190: PPUSH
82191: CALL_OW 3
82195: ST_TO_ADDR
// if not ext_list then
82196: LD_VAR 0 5
82200: NOT
82201: IFFALSE 82207
// exit ;
82203: POP
82204: POP
82205: GO 82211
// end ;
82207: GO 82082
82209: POP
82210: POP
// end ;
82211: LD_VAR 0 6
82215: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
82216: LD_INT 0
82218: PPUSH
// if not mc_bases or not base or not weapon_list then
82219: LD_EXP 61
82223: NOT
82224: PUSH
82225: LD_VAR 0 1
82229: NOT
82230: OR
82231: PUSH
82232: LD_VAR 0 2
82236: NOT
82237: OR
82238: IFFALSE 82242
// exit ;
82240: GO 82267
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
82242: LD_ADDR_EXP 100
82246: PUSH
82247: LD_EXP 100
82251: PPUSH
82252: LD_VAR 0 1
82256: PPUSH
82257: LD_VAR 0 2
82261: PPUSH
82262: CALL_OW 1
82266: ST_TO_ADDR
// end ;
82267: LD_VAR 0 3
82271: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
82272: LD_INT 0
82274: PPUSH
// if not mc_bases or not base or not tech_list then
82275: LD_EXP 61
82279: NOT
82280: PUSH
82281: LD_VAR 0 1
82285: NOT
82286: OR
82287: PUSH
82288: LD_VAR 0 2
82292: NOT
82293: OR
82294: IFFALSE 82298
// exit ;
82296: GO 82323
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
82298: LD_ADDR_EXP 88
82302: PUSH
82303: LD_EXP 88
82307: PPUSH
82308: LD_VAR 0 1
82312: PPUSH
82313: LD_VAR 0 2
82317: PPUSH
82318: CALL_OW 1
82322: ST_TO_ADDR
// end ;
82323: LD_VAR 0 3
82327: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
82328: LD_INT 0
82330: PPUSH
// if not mc_bases or not parking_area or not base then
82331: LD_EXP 61
82335: NOT
82336: PUSH
82337: LD_VAR 0 2
82341: NOT
82342: OR
82343: PUSH
82344: LD_VAR 0 1
82348: NOT
82349: OR
82350: IFFALSE 82354
// exit ;
82352: GO 82379
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
82354: LD_ADDR_EXP 85
82358: PUSH
82359: LD_EXP 85
82363: PPUSH
82364: LD_VAR 0 1
82368: PPUSH
82369: LD_VAR 0 2
82373: PPUSH
82374: CALL_OW 1
82378: ST_TO_ADDR
// end ;
82379: LD_VAR 0 3
82383: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
82384: LD_INT 0
82386: PPUSH
// if not mc_bases or not base or not scan_area then
82387: LD_EXP 61
82391: NOT
82392: PUSH
82393: LD_VAR 0 1
82397: NOT
82398: OR
82399: PUSH
82400: LD_VAR 0 2
82404: NOT
82405: OR
82406: IFFALSE 82410
// exit ;
82408: GO 82435
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
82410: LD_ADDR_EXP 86
82414: PUSH
82415: LD_EXP 86
82419: PPUSH
82420: LD_VAR 0 1
82424: PPUSH
82425: LD_VAR 0 2
82429: PPUSH
82430: CALL_OW 1
82434: ST_TO_ADDR
// end ;
82435: LD_VAR 0 3
82439: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
82440: LD_INT 0
82442: PPUSH
82443: PPUSH
// if not mc_bases or not base then
82444: LD_EXP 61
82448: NOT
82449: PUSH
82450: LD_VAR 0 1
82454: NOT
82455: OR
82456: IFFALSE 82460
// exit ;
82458: GO 82524
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
82460: LD_ADDR_VAR 0 3
82464: PUSH
82465: LD_INT 1
82467: PUSH
82468: LD_INT 2
82470: PUSH
82471: LD_INT 3
82473: PUSH
82474: LD_INT 4
82476: PUSH
82477: LD_INT 11
82479: PUSH
82480: EMPTY
82481: LIST
82482: LIST
82483: LIST
82484: LIST
82485: LIST
82486: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
82487: LD_ADDR_EXP 88
82491: PUSH
82492: LD_EXP 88
82496: PPUSH
82497: LD_VAR 0 1
82501: PPUSH
82502: LD_EXP 88
82506: PUSH
82507: LD_VAR 0 1
82511: ARRAY
82512: PUSH
82513: LD_VAR 0 3
82517: DIFF
82518: PPUSH
82519: CALL_OW 1
82523: ST_TO_ADDR
// end ;
82524: LD_VAR 0 2
82528: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
82529: LD_INT 0
82531: PPUSH
// result := mc_vehicles [ base ] ;
82532: LD_ADDR_VAR 0 3
82536: PUSH
82537: LD_EXP 80
82541: PUSH
82542: LD_VAR 0 1
82546: ARRAY
82547: ST_TO_ADDR
// if onlyCombat then
82548: LD_VAR 0 2
82552: IFFALSE 82724
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
82554: LD_ADDR_VAR 0 3
82558: PUSH
82559: LD_VAR 0 3
82563: PUSH
82564: LD_VAR 0 3
82568: PPUSH
82569: LD_INT 2
82571: PUSH
82572: LD_INT 34
82574: PUSH
82575: LD_INT 12
82577: PUSH
82578: EMPTY
82579: LIST
82580: LIST
82581: PUSH
82582: LD_INT 34
82584: PUSH
82585: LD_INT 51
82587: PUSH
82588: EMPTY
82589: LIST
82590: LIST
82591: PUSH
82592: LD_INT 34
82594: PUSH
82595: LD_INT 89
82597: PUSH
82598: EMPTY
82599: LIST
82600: LIST
82601: PUSH
82602: LD_INT 34
82604: PUSH
82605: LD_INT 32
82607: PUSH
82608: EMPTY
82609: LIST
82610: LIST
82611: PUSH
82612: LD_INT 34
82614: PUSH
82615: LD_INT 13
82617: PUSH
82618: EMPTY
82619: LIST
82620: LIST
82621: PUSH
82622: LD_INT 34
82624: PUSH
82625: LD_INT 52
82627: PUSH
82628: EMPTY
82629: LIST
82630: LIST
82631: PUSH
82632: LD_INT 34
82634: PUSH
82635: LD_INT 88
82637: PUSH
82638: EMPTY
82639: LIST
82640: LIST
82641: PUSH
82642: LD_INT 34
82644: PUSH
82645: LD_INT 14
82647: PUSH
82648: EMPTY
82649: LIST
82650: LIST
82651: PUSH
82652: LD_INT 34
82654: PUSH
82655: LD_INT 53
82657: PUSH
82658: EMPTY
82659: LIST
82660: LIST
82661: PUSH
82662: LD_INT 34
82664: PUSH
82665: LD_INT 98
82667: PUSH
82668: EMPTY
82669: LIST
82670: LIST
82671: PUSH
82672: LD_INT 34
82674: PUSH
82675: LD_INT 31
82677: PUSH
82678: EMPTY
82679: LIST
82680: LIST
82681: PUSH
82682: LD_INT 34
82684: PUSH
82685: LD_INT 48
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: PUSH
82692: LD_INT 34
82694: PUSH
82695: LD_INT 8
82697: PUSH
82698: EMPTY
82699: LIST
82700: LIST
82701: PUSH
82702: EMPTY
82703: LIST
82704: LIST
82705: LIST
82706: LIST
82707: LIST
82708: LIST
82709: LIST
82710: LIST
82711: LIST
82712: LIST
82713: LIST
82714: LIST
82715: LIST
82716: LIST
82717: PPUSH
82718: CALL_OW 72
82722: DIFF
82723: ST_TO_ADDR
// end ; end_of_file
82724: LD_VAR 0 3
82728: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
82729: LD_INT 0
82731: PPUSH
82732: PPUSH
82733: PPUSH
// if not mc_bases or not skirmish then
82734: LD_EXP 61
82738: NOT
82739: PUSH
82740: LD_EXP 59
82744: NOT
82745: OR
82746: IFFALSE 82750
// exit ;
82748: GO 82915
// for i = 1 to mc_bases do
82750: LD_ADDR_VAR 0 4
82754: PUSH
82755: DOUBLE
82756: LD_INT 1
82758: DEC
82759: ST_TO_ADDR
82760: LD_EXP 61
82764: PUSH
82765: FOR_TO
82766: IFFALSE 82913
// begin if sci in mc_bases [ i ] then
82768: LD_VAR 0 2
82772: PUSH
82773: LD_EXP 61
82777: PUSH
82778: LD_VAR 0 4
82782: ARRAY
82783: IN
82784: IFFALSE 82911
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
82786: LD_ADDR_EXP 90
82790: PUSH
82791: LD_EXP 90
82795: PPUSH
82796: LD_VAR 0 4
82800: PUSH
82801: LD_EXP 90
82805: PUSH
82806: LD_VAR 0 4
82810: ARRAY
82811: PUSH
82812: LD_INT 1
82814: PLUS
82815: PUSH
82816: EMPTY
82817: LIST
82818: LIST
82819: PPUSH
82820: LD_VAR 0 1
82824: PPUSH
82825: CALL 20441 0 3
82829: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
82830: LD_ADDR_VAR 0 5
82834: PUSH
82835: LD_EXP 61
82839: PUSH
82840: LD_VAR 0 4
82844: ARRAY
82845: PPUSH
82846: LD_INT 2
82848: PUSH
82849: LD_INT 30
82851: PUSH
82852: LD_INT 0
82854: PUSH
82855: EMPTY
82856: LIST
82857: LIST
82858: PUSH
82859: LD_INT 30
82861: PUSH
82862: LD_INT 1
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PUSH
82869: EMPTY
82870: LIST
82871: LIST
82872: LIST
82873: PPUSH
82874: CALL_OW 72
82878: PPUSH
82879: LD_VAR 0 1
82883: PPUSH
82884: CALL_OW 74
82888: ST_TO_ADDR
// if tmp then
82889: LD_VAR 0 5
82893: IFFALSE 82909
// ComStandNearbyBuilding ( ape , tmp ) ;
82895: LD_VAR 0 1
82899: PPUSH
82900: LD_VAR 0 5
82904: PPUSH
82905: CALL 17043 0 2
// break ;
82909: GO 82913
// end ; end ;
82911: GO 82765
82913: POP
82914: POP
// end ;
82915: LD_VAR 0 3
82919: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
82920: LD_INT 0
82922: PPUSH
82923: PPUSH
82924: PPUSH
// if not mc_bases or not skirmish then
82925: LD_EXP 61
82929: NOT
82930: PUSH
82931: LD_EXP 59
82935: NOT
82936: OR
82937: IFFALSE 82941
// exit ;
82939: GO 83030
// for i = 1 to mc_bases do
82941: LD_ADDR_VAR 0 4
82945: PUSH
82946: DOUBLE
82947: LD_INT 1
82949: DEC
82950: ST_TO_ADDR
82951: LD_EXP 61
82955: PUSH
82956: FOR_TO
82957: IFFALSE 83028
// begin if building in mc_busy_turret_list [ i ] then
82959: LD_VAR 0 1
82963: PUSH
82964: LD_EXP 71
82968: PUSH
82969: LD_VAR 0 4
82973: ARRAY
82974: IN
82975: IFFALSE 83026
// begin tmp := mc_busy_turret_list [ i ] diff building ;
82977: LD_ADDR_VAR 0 5
82981: PUSH
82982: LD_EXP 71
82986: PUSH
82987: LD_VAR 0 4
82991: ARRAY
82992: PUSH
82993: LD_VAR 0 1
82997: DIFF
82998: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
82999: LD_ADDR_EXP 71
83003: PUSH
83004: LD_EXP 71
83008: PPUSH
83009: LD_VAR 0 4
83013: PPUSH
83014: LD_VAR 0 5
83018: PPUSH
83019: CALL_OW 1
83023: ST_TO_ADDR
// break ;
83024: GO 83028
// end ; end ;
83026: GO 82956
83028: POP
83029: POP
// end ;
83030: LD_VAR 0 3
83034: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
83035: LD_INT 0
83037: PPUSH
83038: PPUSH
83039: PPUSH
// if not mc_bases or not skirmish then
83040: LD_EXP 61
83044: NOT
83045: PUSH
83046: LD_EXP 59
83050: NOT
83051: OR
83052: IFFALSE 83056
// exit ;
83054: GO 83255
// for i = 1 to mc_bases do
83056: LD_ADDR_VAR 0 5
83060: PUSH
83061: DOUBLE
83062: LD_INT 1
83064: DEC
83065: ST_TO_ADDR
83066: LD_EXP 61
83070: PUSH
83071: FOR_TO
83072: IFFALSE 83253
// if building in mc_bases [ i ] then
83074: LD_VAR 0 1
83078: PUSH
83079: LD_EXP 61
83083: PUSH
83084: LD_VAR 0 5
83088: ARRAY
83089: IN
83090: IFFALSE 83251
// begin tmp := mc_bases [ i ] diff building ;
83092: LD_ADDR_VAR 0 6
83096: PUSH
83097: LD_EXP 61
83101: PUSH
83102: LD_VAR 0 5
83106: ARRAY
83107: PUSH
83108: LD_VAR 0 1
83112: DIFF
83113: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
83114: LD_ADDR_EXP 61
83118: PUSH
83119: LD_EXP 61
83123: PPUSH
83124: LD_VAR 0 5
83128: PPUSH
83129: LD_VAR 0 6
83133: PPUSH
83134: CALL_OW 1
83138: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
83139: LD_VAR 0 1
83143: PUSH
83144: LD_EXP 69
83148: PUSH
83149: LD_VAR 0 5
83153: ARRAY
83154: IN
83155: IFFALSE 83194
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
83157: LD_ADDR_EXP 69
83161: PUSH
83162: LD_EXP 69
83166: PPUSH
83167: LD_VAR 0 5
83171: PPUSH
83172: LD_EXP 69
83176: PUSH
83177: LD_VAR 0 5
83181: ARRAY
83182: PUSH
83183: LD_VAR 0 1
83187: DIFF
83188: PPUSH
83189: CALL_OW 1
83193: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
83194: LD_VAR 0 1
83198: PUSH
83199: LD_EXP 70
83203: PUSH
83204: LD_VAR 0 5
83208: ARRAY
83209: IN
83210: IFFALSE 83249
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
83212: LD_ADDR_EXP 70
83216: PUSH
83217: LD_EXP 70
83221: PPUSH
83222: LD_VAR 0 5
83226: PPUSH
83227: LD_EXP 70
83231: PUSH
83232: LD_VAR 0 5
83236: ARRAY
83237: PUSH
83238: LD_VAR 0 1
83242: DIFF
83243: PPUSH
83244: CALL_OW 1
83248: ST_TO_ADDR
// break ;
83249: GO 83253
// end ;
83251: GO 83071
83253: POP
83254: POP
// end ;
83255: LD_VAR 0 4
83259: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
83260: LD_INT 0
83262: PPUSH
83263: PPUSH
83264: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
83265: LD_EXP 61
83269: NOT
83270: PUSH
83271: LD_EXP 59
83275: NOT
83276: OR
83277: PUSH
83278: LD_VAR 0 3
83282: PUSH
83283: LD_EXP 87
83287: IN
83288: NOT
83289: OR
83290: IFFALSE 83294
// exit ;
83292: GO 83417
// for i = 1 to mc_vehicles do
83294: LD_ADDR_VAR 0 6
83298: PUSH
83299: DOUBLE
83300: LD_INT 1
83302: DEC
83303: ST_TO_ADDR
83304: LD_EXP 80
83308: PUSH
83309: FOR_TO
83310: IFFALSE 83415
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
83312: LD_VAR 0 2
83316: PUSH
83317: LD_EXP 80
83321: PUSH
83322: LD_VAR 0 6
83326: ARRAY
83327: IN
83328: PUSH
83329: LD_VAR 0 1
83333: PUSH
83334: LD_EXP 80
83338: PUSH
83339: LD_VAR 0 6
83343: ARRAY
83344: IN
83345: OR
83346: IFFALSE 83413
// begin tmp := mc_vehicles [ i ] diff old ;
83348: LD_ADDR_VAR 0 7
83352: PUSH
83353: LD_EXP 80
83357: PUSH
83358: LD_VAR 0 6
83362: ARRAY
83363: PUSH
83364: LD_VAR 0 2
83368: DIFF
83369: ST_TO_ADDR
// tmp := tmp diff new ;
83370: LD_ADDR_VAR 0 7
83374: PUSH
83375: LD_VAR 0 7
83379: PUSH
83380: LD_VAR 0 1
83384: DIFF
83385: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
83386: LD_ADDR_EXP 80
83390: PUSH
83391: LD_EXP 80
83395: PPUSH
83396: LD_VAR 0 6
83400: PPUSH
83401: LD_VAR 0 7
83405: PPUSH
83406: CALL_OW 1
83410: ST_TO_ADDR
// break ;
83411: GO 83415
// end ;
83413: GO 83309
83415: POP
83416: POP
// end ;
83417: LD_VAR 0 5
83421: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
83422: LD_INT 0
83424: PPUSH
83425: PPUSH
83426: PPUSH
83427: PPUSH
// if not mc_bases or not skirmish then
83428: LD_EXP 61
83432: NOT
83433: PUSH
83434: LD_EXP 59
83438: NOT
83439: OR
83440: IFFALSE 83444
// exit ;
83442: GO 83864
// repeat wait ( 0 0$1 ) ;
83444: LD_INT 35
83446: PPUSH
83447: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
83451: LD_EXP 105
83455: NOT
83456: IFFALSE 83444
// mc_block_vehicle_constructed_thread := true ;
83458: LD_ADDR_EXP 105
83462: PUSH
83463: LD_INT 1
83465: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
83466: LD_ADDR_VAR 0 5
83470: PUSH
83471: LD_VAR 0 1
83475: PPUSH
83476: CALL_OW 255
83480: ST_TO_ADDR
// for i = 1 to mc_bases do
83481: LD_ADDR_VAR 0 4
83485: PUSH
83486: DOUBLE
83487: LD_INT 1
83489: DEC
83490: ST_TO_ADDR
83491: LD_EXP 61
83495: PUSH
83496: FOR_TO
83497: IFFALSE 83854
// begin if factory in mc_bases [ i ] then
83499: LD_VAR 0 2
83503: PUSH
83504: LD_EXP 61
83508: PUSH
83509: LD_VAR 0 4
83513: ARRAY
83514: IN
83515: IFFALSE 83852
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
83517: LD_EXP 83
83521: PUSH
83522: LD_VAR 0 4
83526: ARRAY
83527: PUSH
83528: LD_EXP 72
83532: PUSH
83533: LD_VAR 0 4
83537: ARRAY
83538: LESS
83539: PUSH
83540: LD_VAR 0 1
83544: PPUSH
83545: CALL_OW 264
83549: PUSH
83550: LD_INT 31
83552: PUSH
83553: LD_INT 32
83555: PUSH
83556: LD_INT 51
83558: PUSH
83559: LD_INT 89
83561: PUSH
83562: LD_INT 12
83564: PUSH
83565: LD_INT 30
83567: PUSH
83568: LD_INT 98
83570: PUSH
83571: LD_INT 11
83573: PUSH
83574: LD_INT 53
83576: PUSH
83577: LD_INT 14
83579: PUSH
83580: LD_INT 91
83582: PUSH
83583: LD_INT 29
83585: PUSH
83586: LD_INT 99
83588: PUSH
83589: LD_INT 13
83591: PUSH
83592: LD_INT 52
83594: PUSH
83595: LD_INT 88
83597: PUSH
83598: LD_INT 48
83600: PUSH
83601: LD_INT 8
83603: PUSH
83604: EMPTY
83605: LIST
83606: LIST
83607: LIST
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: LIST
83613: LIST
83614: LIST
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: LIST
83621: LIST
83622: LIST
83623: IN
83624: NOT
83625: AND
83626: IFFALSE 83674
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
83628: LD_ADDR_EXP 83
83632: PUSH
83633: LD_EXP 83
83637: PPUSH
83638: LD_VAR 0 4
83642: PUSH
83643: LD_EXP 83
83647: PUSH
83648: LD_VAR 0 4
83652: ARRAY
83653: PUSH
83654: LD_INT 1
83656: PLUS
83657: PUSH
83658: EMPTY
83659: LIST
83660: LIST
83661: PPUSH
83662: LD_VAR 0 1
83666: PPUSH
83667: CALL 20441 0 3
83671: ST_TO_ADDR
83672: GO 83718
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
83674: LD_ADDR_EXP 80
83678: PUSH
83679: LD_EXP 80
83683: PPUSH
83684: LD_VAR 0 4
83688: PUSH
83689: LD_EXP 80
83693: PUSH
83694: LD_VAR 0 4
83698: ARRAY
83699: PUSH
83700: LD_INT 1
83702: PLUS
83703: PUSH
83704: EMPTY
83705: LIST
83706: LIST
83707: PPUSH
83708: LD_VAR 0 1
83712: PPUSH
83713: CALL 20441 0 3
83717: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
83718: LD_ADDR_EXP 105
83722: PUSH
83723: LD_INT 0
83725: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
83726: LD_VAR 0 1
83730: PPUSH
83731: CALL_OW 263
83735: PUSH
83736: LD_INT 2
83738: EQUAL
83739: IFFALSE 83768
// begin repeat wait ( 0 0$3 ) ;
83741: LD_INT 105
83743: PPUSH
83744: CALL_OW 67
// Connect ( vehicle ) ;
83748: LD_VAR 0 1
83752: PPUSH
83753: CALL 23410 0 1
// until IsControledBy ( vehicle ) ;
83757: LD_VAR 0 1
83761: PPUSH
83762: CALL_OW 312
83766: IFFALSE 83741
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
83768: LD_VAR 0 1
83772: PPUSH
83773: LD_EXP 85
83777: PUSH
83778: LD_VAR 0 4
83782: ARRAY
83783: PPUSH
83784: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
83788: LD_VAR 0 1
83792: PPUSH
83793: CALL_OW 263
83797: PUSH
83798: LD_INT 1
83800: NONEQUAL
83801: IFFALSE 83805
// break ;
83803: GO 83854
// repeat wait ( 0 0$1 ) ;
83805: LD_INT 35
83807: PPUSH
83808: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
83812: LD_VAR 0 1
83816: PPUSH
83817: LD_EXP 85
83821: PUSH
83822: LD_VAR 0 4
83826: ARRAY
83827: PPUSH
83828: CALL_OW 308
83832: IFFALSE 83805
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
83834: LD_VAR 0 1
83838: PPUSH
83839: CALL_OW 311
83843: PPUSH
83844: CALL_OW 121
// exit ;
83848: POP
83849: POP
83850: GO 83864
// end ; end ;
83852: GO 83496
83854: POP
83855: POP
// mc_block_vehicle_constructed_thread := false ;
83856: LD_ADDR_EXP 105
83860: PUSH
83861: LD_INT 0
83863: ST_TO_ADDR
// end ;
83864: LD_VAR 0 3
83868: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
83869: LD_INT 0
83871: PPUSH
83872: PPUSH
83873: PPUSH
83874: PPUSH
// if not mc_bases or not skirmish then
83875: LD_EXP 61
83879: NOT
83880: PUSH
83881: LD_EXP 59
83885: NOT
83886: OR
83887: IFFALSE 83891
// exit ;
83889: GO 84244
// repeat wait ( 0 0$1 ) ;
83891: LD_INT 35
83893: PPUSH
83894: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
83898: LD_VAR 0 2
83902: PPUSH
83903: LD_VAR 0 3
83907: PPUSH
83908: CALL_OW 284
83912: IFFALSE 83891
// if GetResourceTypeXY ( x , y ) = mat_artefact then
83914: LD_VAR 0 2
83918: PPUSH
83919: LD_VAR 0 3
83923: PPUSH
83924: CALL_OW 283
83928: PUSH
83929: LD_INT 4
83931: EQUAL
83932: IFFALSE 83936
// exit ;
83934: GO 84244
// for i = 1 to mc_bases do
83936: LD_ADDR_VAR 0 7
83940: PUSH
83941: DOUBLE
83942: LD_INT 1
83944: DEC
83945: ST_TO_ADDR
83946: LD_EXP 61
83950: PUSH
83951: FOR_TO
83952: IFFALSE 84242
// begin if mc_crates_area [ i ] then
83954: LD_EXP 79
83958: PUSH
83959: LD_VAR 0 7
83963: ARRAY
83964: IFFALSE 84075
// for j in mc_crates_area [ i ] do
83966: LD_ADDR_VAR 0 8
83970: PUSH
83971: LD_EXP 79
83975: PUSH
83976: LD_VAR 0 7
83980: ARRAY
83981: PUSH
83982: FOR_IN
83983: IFFALSE 84073
// if InArea ( x , y , j ) then
83985: LD_VAR 0 2
83989: PPUSH
83990: LD_VAR 0 3
83994: PPUSH
83995: LD_VAR 0 8
83999: PPUSH
84000: CALL_OW 309
84004: IFFALSE 84071
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84006: LD_ADDR_EXP 77
84010: PUSH
84011: LD_EXP 77
84015: PPUSH
84016: LD_VAR 0 7
84020: PUSH
84021: LD_EXP 77
84025: PUSH
84026: LD_VAR 0 7
84030: ARRAY
84031: PUSH
84032: LD_INT 1
84034: PLUS
84035: PUSH
84036: EMPTY
84037: LIST
84038: LIST
84039: PPUSH
84040: LD_VAR 0 4
84044: PUSH
84045: LD_VAR 0 2
84049: PUSH
84050: LD_VAR 0 3
84054: PUSH
84055: EMPTY
84056: LIST
84057: LIST
84058: LIST
84059: PPUSH
84060: CALL 20441 0 3
84064: ST_TO_ADDR
// exit ;
84065: POP
84066: POP
84067: POP
84068: POP
84069: GO 84244
// end ;
84071: GO 83982
84073: POP
84074: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84075: LD_ADDR_VAR 0 9
84079: PUSH
84080: LD_EXP 61
84084: PUSH
84085: LD_VAR 0 7
84089: ARRAY
84090: PPUSH
84091: LD_INT 2
84093: PUSH
84094: LD_INT 30
84096: PUSH
84097: LD_INT 0
84099: PUSH
84100: EMPTY
84101: LIST
84102: LIST
84103: PUSH
84104: LD_INT 30
84106: PUSH
84107: LD_INT 1
84109: PUSH
84110: EMPTY
84111: LIST
84112: LIST
84113: PUSH
84114: EMPTY
84115: LIST
84116: LIST
84117: LIST
84118: PPUSH
84119: CALL_OW 72
84123: ST_TO_ADDR
// if not depot then
84124: LD_VAR 0 9
84128: NOT
84129: IFFALSE 84133
// continue ;
84131: GO 83951
// for j in depot do
84133: LD_ADDR_VAR 0 8
84137: PUSH
84138: LD_VAR 0 9
84142: PUSH
84143: FOR_IN
84144: IFFALSE 84238
// if GetDistUnitXY ( j , x , y ) < 30 then
84146: LD_VAR 0 8
84150: PPUSH
84151: LD_VAR 0 2
84155: PPUSH
84156: LD_VAR 0 3
84160: PPUSH
84161: CALL_OW 297
84165: PUSH
84166: LD_INT 30
84168: LESS
84169: IFFALSE 84236
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84171: LD_ADDR_EXP 77
84175: PUSH
84176: LD_EXP 77
84180: PPUSH
84181: LD_VAR 0 7
84185: PUSH
84186: LD_EXP 77
84190: PUSH
84191: LD_VAR 0 7
84195: ARRAY
84196: PUSH
84197: LD_INT 1
84199: PLUS
84200: PUSH
84201: EMPTY
84202: LIST
84203: LIST
84204: PPUSH
84205: LD_VAR 0 4
84209: PUSH
84210: LD_VAR 0 2
84214: PUSH
84215: LD_VAR 0 3
84219: PUSH
84220: EMPTY
84221: LIST
84222: LIST
84223: LIST
84224: PPUSH
84225: CALL 20441 0 3
84229: ST_TO_ADDR
// exit ;
84230: POP
84231: POP
84232: POP
84233: POP
84234: GO 84244
// end ;
84236: GO 84143
84238: POP
84239: POP
// end ;
84240: GO 83951
84242: POP
84243: POP
// end ;
84244: LD_VAR 0 6
84248: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
84249: LD_INT 0
84251: PPUSH
84252: PPUSH
84253: PPUSH
84254: PPUSH
// if not mc_bases or not skirmish then
84255: LD_EXP 61
84259: NOT
84260: PUSH
84261: LD_EXP 59
84265: NOT
84266: OR
84267: IFFALSE 84271
// exit ;
84269: GO 84548
// side := GetSide ( lab ) ;
84271: LD_ADDR_VAR 0 4
84275: PUSH
84276: LD_VAR 0 2
84280: PPUSH
84281: CALL_OW 255
84285: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
84286: LD_VAR 0 4
84290: PUSH
84291: LD_EXP 87
84295: IN
84296: NOT
84297: PUSH
84298: LD_EXP 88
84302: NOT
84303: OR
84304: PUSH
84305: LD_EXP 61
84309: NOT
84310: OR
84311: IFFALSE 84315
// exit ;
84313: GO 84548
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
84315: LD_ADDR_EXP 88
84319: PUSH
84320: LD_EXP 88
84324: PPUSH
84325: LD_VAR 0 4
84329: PPUSH
84330: LD_EXP 88
84334: PUSH
84335: LD_VAR 0 4
84339: ARRAY
84340: PUSH
84341: LD_VAR 0 1
84345: DIFF
84346: PPUSH
84347: CALL_OW 1
84351: ST_TO_ADDR
// for i = 1 to mc_bases do
84352: LD_ADDR_VAR 0 5
84356: PUSH
84357: DOUBLE
84358: LD_INT 1
84360: DEC
84361: ST_TO_ADDR
84362: LD_EXP 61
84366: PUSH
84367: FOR_TO
84368: IFFALSE 84546
// begin if lab in mc_bases [ i ] then
84370: LD_VAR 0 2
84374: PUSH
84375: LD_EXP 61
84379: PUSH
84380: LD_VAR 0 5
84384: ARRAY
84385: IN
84386: IFFALSE 84544
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
84388: LD_VAR 0 1
84392: PUSH
84393: LD_INT 11
84395: PUSH
84396: LD_INT 4
84398: PUSH
84399: LD_INT 3
84401: PUSH
84402: LD_INT 2
84404: PUSH
84405: EMPTY
84406: LIST
84407: LIST
84408: LIST
84409: LIST
84410: IN
84411: PUSH
84412: LD_EXP 91
84416: PUSH
84417: LD_VAR 0 5
84421: ARRAY
84422: AND
84423: IFFALSE 84544
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
84425: LD_ADDR_VAR 0 6
84429: PUSH
84430: LD_EXP 91
84434: PUSH
84435: LD_VAR 0 5
84439: ARRAY
84440: PUSH
84441: LD_INT 1
84443: ARRAY
84444: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84445: LD_ADDR_EXP 91
84449: PUSH
84450: LD_EXP 91
84454: PPUSH
84455: LD_VAR 0 5
84459: PPUSH
84460: EMPTY
84461: PPUSH
84462: CALL_OW 1
84466: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
84467: LD_VAR 0 6
84471: PPUSH
84472: LD_INT 0
84474: PPUSH
84475: CALL_OW 109
// ComExitBuilding ( tmp ) ;
84479: LD_VAR 0 6
84483: PPUSH
84484: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
84488: LD_ADDR_EXP 90
84492: PUSH
84493: LD_EXP 90
84497: PPUSH
84498: LD_VAR 0 5
84502: PPUSH
84503: LD_EXP 90
84507: PUSH
84508: LD_VAR 0 5
84512: ARRAY
84513: PPUSH
84514: LD_INT 1
84516: PPUSH
84517: LD_VAR 0 6
84521: PPUSH
84522: CALL_OW 2
84526: PPUSH
84527: CALL_OW 1
84531: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
84532: LD_VAR 0 5
84536: PPUSH
84537: LD_INT 112
84539: PPUSH
84540: CALL 61012 0 2
// end ; end ; end ;
84544: GO 84367
84546: POP
84547: POP
// end ;
84548: LD_VAR 0 3
84552: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
84553: LD_INT 0
84555: PPUSH
84556: PPUSH
84557: PPUSH
84558: PPUSH
84559: PPUSH
84560: PPUSH
84561: PPUSH
84562: PPUSH
// if not mc_bases or not skirmish then
84563: LD_EXP 61
84567: NOT
84568: PUSH
84569: LD_EXP 59
84573: NOT
84574: OR
84575: IFFALSE 84579
// exit ;
84577: GO 85948
// for i = 1 to mc_bases do
84579: LD_ADDR_VAR 0 3
84583: PUSH
84584: DOUBLE
84585: LD_INT 1
84587: DEC
84588: ST_TO_ADDR
84589: LD_EXP 61
84593: PUSH
84594: FOR_TO
84595: IFFALSE 85946
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
84597: LD_VAR 0 1
84601: PUSH
84602: LD_EXP 61
84606: PUSH
84607: LD_VAR 0 3
84611: ARRAY
84612: IN
84613: PUSH
84614: LD_VAR 0 1
84618: PUSH
84619: LD_EXP 68
84623: PUSH
84624: LD_VAR 0 3
84628: ARRAY
84629: IN
84630: OR
84631: PUSH
84632: LD_VAR 0 1
84636: PUSH
84637: LD_EXP 83
84641: PUSH
84642: LD_VAR 0 3
84646: ARRAY
84647: IN
84648: OR
84649: PUSH
84650: LD_VAR 0 1
84654: PUSH
84655: LD_EXP 80
84659: PUSH
84660: LD_VAR 0 3
84664: ARRAY
84665: IN
84666: OR
84667: PUSH
84668: LD_VAR 0 1
84672: PUSH
84673: LD_EXP 90
84677: PUSH
84678: LD_VAR 0 3
84682: ARRAY
84683: IN
84684: OR
84685: PUSH
84686: LD_VAR 0 1
84690: PUSH
84691: LD_EXP 91
84695: PUSH
84696: LD_VAR 0 3
84700: ARRAY
84701: IN
84702: OR
84703: IFFALSE 85944
// begin if un in mc_ape [ i ] then
84705: LD_VAR 0 1
84709: PUSH
84710: LD_EXP 90
84714: PUSH
84715: LD_VAR 0 3
84719: ARRAY
84720: IN
84721: IFFALSE 84760
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
84723: LD_ADDR_EXP 90
84727: PUSH
84728: LD_EXP 90
84732: PPUSH
84733: LD_VAR 0 3
84737: PPUSH
84738: LD_EXP 90
84742: PUSH
84743: LD_VAR 0 3
84747: ARRAY
84748: PUSH
84749: LD_VAR 0 1
84753: DIFF
84754: PPUSH
84755: CALL_OW 1
84759: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
84760: LD_VAR 0 1
84764: PUSH
84765: LD_EXP 91
84769: PUSH
84770: LD_VAR 0 3
84774: ARRAY
84775: IN
84776: IFFALSE 84800
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84778: LD_ADDR_EXP 91
84782: PUSH
84783: LD_EXP 91
84787: PPUSH
84788: LD_VAR 0 3
84792: PPUSH
84793: EMPTY
84794: PPUSH
84795: CALL_OW 1
84799: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
84800: LD_VAR 0 1
84804: PPUSH
84805: CALL_OW 247
84809: PUSH
84810: LD_INT 2
84812: EQUAL
84813: PUSH
84814: LD_VAR 0 1
84818: PPUSH
84819: CALL_OW 110
84823: PUSH
84824: LD_INT 20
84826: EQUAL
84827: PUSH
84828: LD_VAR 0 1
84832: PUSH
84833: LD_EXP 83
84837: PUSH
84838: LD_VAR 0 3
84842: ARRAY
84843: IN
84844: OR
84845: PUSH
84846: LD_VAR 0 1
84850: PPUSH
84851: CALL_OW 264
84855: PUSH
84856: LD_INT 12
84858: PUSH
84859: LD_INT 51
84861: PUSH
84862: LD_INT 89
84864: PUSH
84865: LD_INT 32
84867: PUSH
84868: LD_INT 13
84870: PUSH
84871: LD_INT 52
84873: PUSH
84874: LD_INT 31
84876: PUSH
84877: EMPTY
84878: LIST
84879: LIST
84880: LIST
84881: LIST
84882: LIST
84883: LIST
84884: LIST
84885: IN
84886: OR
84887: AND
84888: IFFALSE 85196
// begin if un in mc_defender [ i ] then
84890: LD_VAR 0 1
84894: PUSH
84895: LD_EXP 83
84899: PUSH
84900: LD_VAR 0 3
84904: ARRAY
84905: IN
84906: IFFALSE 84945
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84908: LD_ADDR_EXP 83
84912: PUSH
84913: LD_EXP 83
84917: PPUSH
84918: LD_VAR 0 3
84922: PPUSH
84923: LD_EXP 83
84927: PUSH
84928: LD_VAR 0 3
84932: ARRAY
84933: PUSH
84934: LD_VAR 0 1
84938: DIFF
84939: PPUSH
84940: CALL_OW 1
84944: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
84945: LD_ADDR_VAR 0 8
84949: PUSH
84950: LD_VAR 0 3
84954: PPUSH
84955: LD_INT 3
84957: PPUSH
84958: CALL 81566 0 2
84962: ST_TO_ADDR
// if fac then
84963: LD_VAR 0 8
84967: IFFALSE 85196
// begin for j in fac do
84969: LD_ADDR_VAR 0 4
84973: PUSH
84974: LD_VAR 0 8
84978: PUSH
84979: FOR_IN
84980: IFFALSE 85194
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
84982: LD_ADDR_VAR 0 9
84986: PUSH
84987: LD_VAR 0 8
84991: PPUSH
84992: LD_VAR 0 1
84996: PPUSH
84997: CALL_OW 265
85001: PPUSH
85002: LD_VAR 0 1
85006: PPUSH
85007: CALL_OW 262
85011: PPUSH
85012: LD_VAR 0 1
85016: PPUSH
85017: CALL_OW 263
85021: PPUSH
85022: LD_VAR 0 1
85026: PPUSH
85027: CALL_OW 264
85031: PPUSH
85032: CALL 17939 0 5
85036: ST_TO_ADDR
// if components then
85037: LD_VAR 0 9
85041: IFFALSE 85192
// begin if GetWeapon ( un ) = ar_control_tower then
85043: LD_VAR 0 1
85047: PPUSH
85048: CALL_OW 264
85052: PUSH
85053: LD_INT 31
85055: EQUAL
85056: IFFALSE 85173
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
85058: LD_VAR 0 1
85062: PPUSH
85063: CALL_OW 311
85067: PPUSH
85068: LD_INT 0
85070: PPUSH
85071: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
85075: LD_ADDR_EXP 101
85079: PUSH
85080: LD_EXP 101
85084: PPUSH
85085: LD_VAR 0 3
85089: PPUSH
85090: LD_EXP 101
85094: PUSH
85095: LD_VAR 0 3
85099: ARRAY
85100: PUSH
85101: LD_VAR 0 1
85105: PPUSH
85106: CALL_OW 311
85110: DIFF
85111: PPUSH
85112: CALL_OW 1
85116: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
85117: LD_ADDR_VAR 0 7
85121: PUSH
85122: LD_EXP 82
85126: PUSH
85127: LD_VAR 0 3
85131: ARRAY
85132: PPUSH
85133: LD_INT 1
85135: PPUSH
85136: LD_VAR 0 9
85140: PPUSH
85141: CALL_OW 2
85145: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
85146: LD_ADDR_EXP 82
85150: PUSH
85151: LD_EXP 82
85155: PPUSH
85156: LD_VAR 0 3
85160: PPUSH
85161: LD_VAR 0 7
85165: PPUSH
85166: CALL_OW 1
85170: ST_TO_ADDR
// end else
85171: GO 85190
// MC_InsertProduceList ( i , [ components ] ) ;
85173: LD_VAR 0 3
85177: PPUSH
85178: LD_VAR 0 9
85182: PUSH
85183: EMPTY
85184: LIST
85185: PPUSH
85186: CALL 81111 0 2
// break ;
85190: GO 85194
// end ; end ;
85192: GO 84979
85194: POP
85195: POP
// end ; end ; if GetType ( un ) = unit_building then
85196: LD_VAR 0 1
85200: PPUSH
85201: CALL_OW 247
85205: PUSH
85206: LD_INT 3
85208: EQUAL
85209: IFFALSE 85612
// begin btype := GetBType ( un ) ;
85211: LD_ADDR_VAR 0 5
85215: PUSH
85216: LD_VAR 0 1
85220: PPUSH
85221: CALL_OW 266
85225: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
85226: LD_VAR 0 5
85230: PUSH
85231: LD_INT 29
85233: PUSH
85234: LD_INT 30
85236: PUSH
85237: EMPTY
85238: LIST
85239: LIST
85240: IN
85241: IFFALSE 85314
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
85243: LD_VAR 0 1
85247: PPUSH
85248: CALL_OW 250
85252: PPUSH
85253: LD_VAR 0 1
85257: PPUSH
85258: CALL_OW 251
85262: PPUSH
85263: LD_VAR 0 1
85267: PPUSH
85268: CALL_OW 255
85272: PPUSH
85273: CALL_OW 440
85277: NOT
85278: IFFALSE 85314
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
85280: LD_VAR 0 1
85284: PPUSH
85285: CALL_OW 250
85289: PPUSH
85290: LD_VAR 0 1
85294: PPUSH
85295: CALL_OW 251
85299: PPUSH
85300: LD_VAR 0 1
85304: PPUSH
85305: CALL_OW 255
85309: PPUSH
85310: CALL_OW 441
// end ; if btype = b_warehouse then
85314: LD_VAR 0 5
85318: PUSH
85319: LD_INT 1
85321: EQUAL
85322: IFFALSE 85340
// begin btype := b_depot ;
85324: LD_ADDR_VAR 0 5
85328: PUSH
85329: LD_INT 0
85331: ST_TO_ADDR
// pos := 1 ;
85332: LD_ADDR_VAR 0 6
85336: PUSH
85337: LD_INT 1
85339: ST_TO_ADDR
// end ; if btype = b_factory then
85340: LD_VAR 0 5
85344: PUSH
85345: LD_INT 3
85347: EQUAL
85348: IFFALSE 85366
// begin btype := b_workshop ;
85350: LD_ADDR_VAR 0 5
85354: PUSH
85355: LD_INT 2
85357: ST_TO_ADDR
// pos := 1 ;
85358: LD_ADDR_VAR 0 6
85362: PUSH
85363: LD_INT 1
85365: ST_TO_ADDR
// end ; if btype = b_barracks then
85366: LD_VAR 0 5
85370: PUSH
85371: LD_INT 5
85373: EQUAL
85374: IFFALSE 85384
// btype := b_armoury ;
85376: LD_ADDR_VAR 0 5
85380: PUSH
85381: LD_INT 4
85383: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
85384: LD_VAR 0 5
85388: PUSH
85389: LD_INT 7
85391: PUSH
85392: LD_INT 8
85394: PUSH
85395: EMPTY
85396: LIST
85397: LIST
85398: IN
85399: IFFALSE 85409
// btype := b_lab ;
85401: LD_ADDR_VAR 0 5
85405: PUSH
85406: LD_INT 6
85408: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
85409: LD_ADDR_EXP 66
85413: PUSH
85414: LD_EXP 66
85418: PPUSH
85419: LD_VAR 0 3
85423: PUSH
85424: LD_EXP 66
85428: PUSH
85429: LD_VAR 0 3
85433: ARRAY
85434: PUSH
85435: LD_INT 1
85437: PLUS
85438: PUSH
85439: EMPTY
85440: LIST
85441: LIST
85442: PPUSH
85443: LD_VAR 0 5
85447: PUSH
85448: LD_VAR 0 1
85452: PPUSH
85453: CALL_OW 250
85457: PUSH
85458: LD_VAR 0 1
85462: PPUSH
85463: CALL_OW 251
85467: PUSH
85468: LD_VAR 0 1
85472: PPUSH
85473: CALL_OW 254
85477: PUSH
85478: EMPTY
85479: LIST
85480: LIST
85481: LIST
85482: LIST
85483: PPUSH
85484: CALL 20441 0 3
85488: ST_TO_ADDR
// if pos = 1 then
85489: LD_VAR 0 6
85493: PUSH
85494: LD_INT 1
85496: EQUAL
85497: IFFALSE 85612
// begin tmp := mc_build_list [ i ] ;
85499: LD_ADDR_VAR 0 7
85503: PUSH
85504: LD_EXP 66
85508: PUSH
85509: LD_VAR 0 3
85513: ARRAY
85514: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
85515: LD_VAR 0 7
85519: PPUSH
85520: LD_INT 2
85522: PUSH
85523: LD_INT 30
85525: PUSH
85526: LD_INT 0
85528: PUSH
85529: EMPTY
85530: LIST
85531: LIST
85532: PUSH
85533: LD_INT 30
85535: PUSH
85536: LD_INT 1
85538: PUSH
85539: EMPTY
85540: LIST
85541: LIST
85542: PUSH
85543: EMPTY
85544: LIST
85545: LIST
85546: LIST
85547: PPUSH
85548: CALL_OW 72
85552: IFFALSE 85562
// pos := 2 ;
85554: LD_ADDR_VAR 0 6
85558: PUSH
85559: LD_INT 2
85561: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
85562: LD_ADDR_VAR 0 7
85566: PUSH
85567: LD_VAR 0 7
85571: PPUSH
85572: LD_VAR 0 6
85576: PPUSH
85577: LD_VAR 0 7
85581: PPUSH
85582: CALL 20767 0 3
85586: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
85587: LD_ADDR_EXP 66
85591: PUSH
85592: LD_EXP 66
85596: PPUSH
85597: LD_VAR 0 3
85601: PPUSH
85602: LD_VAR 0 7
85606: PPUSH
85607: CALL_OW 1
85611: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
85612: LD_VAR 0 1
85616: PUSH
85617: LD_EXP 61
85621: PUSH
85622: LD_VAR 0 3
85626: ARRAY
85627: IN
85628: IFFALSE 85667
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
85630: LD_ADDR_EXP 61
85634: PUSH
85635: LD_EXP 61
85639: PPUSH
85640: LD_VAR 0 3
85644: PPUSH
85645: LD_EXP 61
85649: PUSH
85650: LD_VAR 0 3
85654: ARRAY
85655: PUSH
85656: LD_VAR 0 1
85660: DIFF
85661: PPUSH
85662: CALL_OW 1
85666: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
85667: LD_VAR 0 1
85671: PUSH
85672: LD_EXP 68
85676: PUSH
85677: LD_VAR 0 3
85681: ARRAY
85682: IN
85683: IFFALSE 85722
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
85685: LD_ADDR_EXP 68
85689: PUSH
85690: LD_EXP 68
85694: PPUSH
85695: LD_VAR 0 3
85699: PPUSH
85700: LD_EXP 68
85704: PUSH
85705: LD_VAR 0 3
85709: ARRAY
85710: PUSH
85711: LD_VAR 0 1
85715: DIFF
85716: PPUSH
85717: CALL_OW 1
85721: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
85722: LD_VAR 0 1
85726: PUSH
85727: LD_EXP 80
85731: PUSH
85732: LD_VAR 0 3
85736: ARRAY
85737: IN
85738: IFFALSE 85777
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
85740: LD_ADDR_EXP 80
85744: PUSH
85745: LD_EXP 80
85749: PPUSH
85750: LD_VAR 0 3
85754: PPUSH
85755: LD_EXP 80
85759: PUSH
85760: LD_VAR 0 3
85764: ARRAY
85765: PUSH
85766: LD_VAR 0 1
85770: DIFF
85771: PPUSH
85772: CALL_OW 1
85776: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
85777: LD_VAR 0 1
85781: PUSH
85782: LD_EXP 83
85786: PUSH
85787: LD_VAR 0 3
85791: ARRAY
85792: IN
85793: IFFALSE 85832
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85795: LD_ADDR_EXP 83
85799: PUSH
85800: LD_EXP 83
85804: PPUSH
85805: LD_VAR 0 3
85809: PPUSH
85810: LD_EXP 83
85814: PUSH
85815: LD_VAR 0 3
85819: ARRAY
85820: PUSH
85821: LD_VAR 0 1
85825: DIFF
85826: PPUSH
85827: CALL_OW 1
85831: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
85832: LD_VAR 0 1
85836: PUSH
85837: LD_EXP 70
85841: PUSH
85842: LD_VAR 0 3
85846: ARRAY
85847: IN
85848: IFFALSE 85887
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
85850: LD_ADDR_EXP 70
85854: PUSH
85855: LD_EXP 70
85859: PPUSH
85860: LD_VAR 0 3
85864: PPUSH
85865: LD_EXP 70
85869: PUSH
85870: LD_VAR 0 3
85874: ARRAY
85875: PUSH
85876: LD_VAR 0 1
85880: DIFF
85881: PPUSH
85882: CALL_OW 1
85886: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
85887: LD_VAR 0 1
85891: PUSH
85892: LD_EXP 69
85896: PUSH
85897: LD_VAR 0 3
85901: ARRAY
85902: IN
85903: IFFALSE 85942
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
85905: LD_ADDR_EXP 69
85909: PUSH
85910: LD_EXP 69
85914: PPUSH
85915: LD_VAR 0 3
85919: PPUSH
85920: LD_EXP 69
85924: PUSH
85925: LD_VAR 0 3
85929: ARRAY
85930: PUSH
85931: LD_VAR 0 1
85935: DIFF
85936: PPUSH
85937: CALL_OW 1
85941: ST_TO_ADDR
// end ; break ;
85942: GO 85946
// end ;
85944: GO 84594
85946: POP
85947: POP
// end ;
85948: LD_VAR 0 2
85952: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
85953: LD_INT 0
85955: PPUSH
85956: PPUSH
85957: PPUSH
// if not mc_bases or not skirmish then
85958: LD_EXP 61
85962: NOT
85963: PUSH
85964: LD_EXP 59
85968: NOT
85969: OR
85970: IFFALSE 85974
// exit ;
85972: GO 86189
// for i = 1 to mc_bases do
85974: LD_ADDR_VAR 0 3
85978: PUSH
85979: DOUBLE
85980: LD_INT 1
85982: DEC
85983: ST_TO_ADDR
85984: LD_EXP 61
85988: PUSH
85989: FOR_TO
85990: IFFALSE 86187
// begin if building in mc_construct_list [ i ] then
85992: LD_VAR 0 1
85996: PUSH
85997: LD_EXP 68
86001: PUSH
86002: LD_VAR 0 3
86006: ARRAY
86007: IN
86008: IFFALSE 86185
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86010: LD_ADDR_EXP 68
86014: PUSH
86015: LD_EXP 68
86019: PPUSH
86020: LD_VAR 0 3
86024: PPUSH
86025: LD_EXP 68
86029: PUSH
86030: LD_VAR 0 3
86034: ARRAY
86035: PUSH
86036: LD_VAR 0 1
86040: DIFF
86041: PPUSH
86042: CALL_OW 1
86046: ST_TO_ADDR
// if building in mc_lab [ i ] then
86047: LD_VAR 0 1
86051: PUSH
86052: LD_EXP 94
86056: PUSH
86057: LD_VAR 0 3
86061: ARRAY
86062: IN
86063: IFFALSE 86118
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
86065: LD_ADDR_EXP 95
86069: PUSH
86070: LD_EXP 95
86074: PPUSH
86075: LD_VAR 0 3
86079: PPUSH
86080: LD_EXP 95
86084: PUSH
86085: LD_VAR 0 3
86089: ARRAY
86090: PPUSH
86091: LD_INT 1
86093: PPUSH
86094: LD_EXP 95
86098: PUSH
86099: LD_VAR 0 3
86103: ARRAY
86104: PPUSH
86105: LD_INT 0
86107: PPUSH
86108: CALL 19859 0 4
86112: PPUSH
86113: CALL_OW 1
86117: ST_TO_ADDR
// if not building in mc_bases [ i ] then
86118: LD_VAR 0 1
86122: PUSH
86123: LD_EXP 61
86127: PUSH
86128: LD_VAR 0 3
86132: ARRAY
86133: IN
86134: NOT
86135: IFFALSE 86181
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86137: LD_ADDR_EXP 61
86141: PUSH
86142: LD_EXP 61
86146: PPUSH
86147: LD_VAR 0 3
86151: PUSH
86152: LD_EXP 61
86156: PUSH
86157: LD_VAR 0 3
86161: ARRAY
86162: PUSH
86163: LD_INT 1
86165: PLUS
86166: PUSH
86167: EMPTY
86168: LIST
86169: LIST
86170: PPUSH
86171: LD_VAR 0 1
86175: PPUSH
86176: CALL 20441 0 3
86180: ST_TO_ADDR
// exit ;
86181: POP
86182: POP
86183: GO 86189
// end ; end ;
86185: GO 85989
86187: POP
86188: POP
// end ;
86189: LD_VAR 0 2
86193: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
86194: LD_INT 0
86196: PPUSH
86197: PPUSH
86198: PPUSH
86199: PPUSH
86200: PPUSH
86201: PPUSH
86202: PPUSH
// if not mc_bases or not skirmish then
86203: LD_EXP 61
86207: NOT
86208: PUSH
86209: LD_EXP 59
86213: NOT
86214: OR
86215: IFFALSE 86219
// exit ;
86217: GO 86880
// for i = 1 to mc_bases do
86219: LD_ADDR_VAR 0 3
86223: PUSH
86224: DOUBLE
86225: LD_INT 1
86227: DEC
86228: ST_TO_ADDR
86229: LD_EXP 61
86233: PUSH
86234: FOR_TO
86235: IFFALSE 86878
// begin if building in mc_construct_list [ i ] then
86237: LD_VAR 0 1
86241: PUSH
86242: LD_EXP 68
86246: PUSH
86247: LD_VAR 0 3
86251: ARRAY
86252: IN
86253: IFFALSE 86876
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86255: LD_ADDR_EXP 68
86259: PUSH
86260: LD_EXP 68
86264: PPUSH
86265: LD_VAR 0 3
86269: PPUSH
86270: LD_EXP 68
86274: PUSH
86275: LD_VAR 0 3
86279: ARRAY
86280: PUSH
86281: LD_VAR 0 1
86285: DIFF
86286: PPUSH
86287: CALL_OW 1
86291: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86292: LD_ADDR_EXP 61
86296: PUSH
86297: LD_EXP 61
86301: PPUSH
86302: LD_VAR 0 3
86306: PUSH
86307: LD_EXP 61
86311: PUSH
86312: LD_VAR 0 3
86316: ARRAY
86317: PUSH
86318: LD_INT 1
86320: PLUS
86321: PUSH
86322: EMPTY
86323: LIST
86324: LIST
86325: PPUSH
86326: LD_VAR 0 1
86330: PPUSH
86331: CALL 20441 0 3
86335: ST_TO_ADDR
// btype := GetBType ( building ) ;
86336: LD_ADDR_VAR 0 5
86340: PUSH
86341: LD_VAR 0 1
86345: PPUSH
86346: CALL_OW 266
86350: ST_TO_ADDR
// side := GetSide ( building ) ;
86351: LD_ADDR_VAR 0 8
86355: PUSH
86356: LD_VAR 0 1
86360: PPUSH
86361: CALL_OW 255
86365: ST_TO_ADDR
// if btype = b_lab then
86366: LD_VAR 0 5
86370: PUSH
86371: LD_INT 6
86373: EQUAL
86374: IFFALSE 86424
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
86376: LD_ADDR_EXP 94
86380: PUSH
86381: LD_EXP 94
86385: PPUSH
86386: LD_VAR 0 3
86390: PUSH
86391: LD_EXP 94
86395: PUSH
86396: LD_VAR 0 3
86400: ARRAY
86401: PUSH
86402: LD_INT 1
86404: PLUS
86405: PUSH
86406: EMPTY
86407: LIST
86408: LIST
86409: PPUSH
86410: LD_VAR 0 1
86414: PPUSH
86415: CALL 20441 0 3
86419: ST_TO_ADDR
// exit ;
86420: POP
86421: POP
86422: GO 86880
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
86424: LD_VAR 0 5
86428: PUSH
86429: LD_INT 0
86431: PUSH
86432: LD_INT 2
86434: PUSH
86435: LD_INT 4
86437: PUSH
86438: EMPTY
86439: LIST
86440: LIST
86441: LIST
86442: IN
86443: IFFALSE 86567
// begin if btype = b_armoury then
86445: LD_VAR 0 5
86449: PUSH
86450: LD_INT 4
86452: EQUAL
86453: IFFALSE 86463
// btype := b_barracks ;
86455: LD_ADDR_VAR 0 5
86459: PUSH
86460: LD_INT 5
86462: ST_TO_ADDR
// if btype = b_depot then
86463: LD_VAR 0 5
86467: PUSH
86468: LD_INT 0
86470: EQUAL
86471: IFFALSE 86481
// btype := b_warehouse ;
86473: LD_ADDR_VAR 0 5
86477: PUSH
86478: LD_INT 1
86480: ST_TO_ADDR
// if btype = b_workshop then
86481: LD_VAR 0 5
86485: PUSH
86486: LD_INT 2
86488: EQUAL
86489: IFFALSE 86499
// btype := b_factory ;
86491: LD_ADDR_VAR 0 5
86495: PUSH
86496: LD_INT 3
86498: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
86499: LD_VAR 0 5
86503: PPUSH
86504: LD_VAR 0 8
86508: PPUSH
86509: CALL_OW 323
86513: PUSH
86514: LD_INT 1
86516: EQUAL
86517: IFFALSE 86563
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
86519: LD_ADDR_EXP 93
86523: PUSH
86524: LD_EXP 93
86528: PPUSH
86529: LD_VAR 0 3
86533: PUSH
86534: LD_EXP 93
86538: PUSH
86539: LD_VAR 0 3
86543: ARRAY
86544: PUSH
86545: LD_INT 1
86547: PLUS
86548: PUSH
86549: EMPTY
86550: LIST
86551: LIST
86552: PPUSH
86553: LD_VAR 0 1
86557: PPUSH
86558: CALL 20441 0 3
86562: ST_TO_ADDR
// exit ;
86563: POP
86564: POP
86565: GO 86880
// end ; if btype in [ b_bunker , b_turret ] then
86567: LD_VAR 0 5
86571: PUSH
86572: LD_INT 32
86574: PUSH
86575: LD_INT 33
86577: PUSH
86578: EMPTY
86579: LIST
86580: LIST
86581: IN
86582: IFFALSE 86872
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
86584: LD_ADDR_EXP 69
86588: PUSH
86589: LD_EXP 69
86593: PPUSH
86594: LD_VAR 0 3
86598: PUSH
86599: LD_EXP 69
86603: PUSH
86604: LD_VAR 0 3
86608: ARRAY
86609: PUSH
86610: LD_INT 1
86612: PLUS
86613: PUSH
86614: EMPTY
86615: LIST
86616: LIST
86617: PPUSH
86618: LD_VAR 0 1
86622: PPUSH
86623: CALL 20441 0 3
86627: ST_TO_ADDR
// if btype = b_bunker then
86628: LD_VAR 0 5
86632: PUSH
86633: LD_INT 32
86635: EQUAL
86636: IFFALSE 86872
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86638: LD_ADDR_EXP 70
86642: PUSH
86643: LD_EXP 70
86647: PPUSH
86648: LD_VAR 0 3
86652: PUSH
86653: LD_EXP 70
86657: PUSH
86658: LD_VAR 0 3
86662: ARRAY
86663: PUSH
86664: LD_INT 1
86666: PLUS
86667: PUSH
86668: EMPTY
86669: LIST
86670: LIST
86671: PPUSH
86672: LD_VAR 0 1
86676: PPUSH
86677: CALL 20441 0 3
86681: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
86682: LD_ADDR_VAR 0 6
86686: PUSH
86687: LD_EXP 61
86691: PUSH
86692: LD_VAR 0 3
86696: ARRAY
86697: PPUSH
86698: LD_INT 25
86700: PUSH
86701: LD_INT 1
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: PUSH
86708: LD_INT 3
86710: PUSH
86711: LD_INT 54
86713: PUSH
86714: EMPTY
86715: LIST
86716: PUSH
86717: EMPTY
86718: LIST
86719: LIST
86720: PUSH
86721: EMPTY
86722: LIST
86723: LIST
86724: PPUSH
86725: CALL_OW 72
86729: ST_TO_ADDR
// if tmp then
86730: LD_VAR 0 6
86734: IFFALSE 86740
// exit ;
86736: POP
86737: POP
86738: GO 86880
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86740: LD_ADDR_VAR 0 6
86744: PUSH
86745: LD_EXP 61
86749: PUSH
86750: LD_VAR 0 3
86754: ARRAY
86755: PPUSH
86756: LD_INT 2
86758: PUSH
86759: LD_INT 30
86761: PUSH
86762: LD_INT 4
86764: PUSH
86765: EMPTY
86766: LIST
86767: LIST
86768: PUSH
86769: LD_INT 30
86771: PUSH
86772: LD_INT 5
86774: PUSH
86775: EMPTY
86776: LIST
86777: LIST
86778: PUSH
86779: EMPTY
86780: LIST
86781: LIST
86782: LIST
86783: PPUSH
86784: CALL_OW 72
86788: ST_TO_ADDR
// if not tmp then
86789: LD_VAR 0 6
86793: NOT
86794: IFFALSE 86800
// exit ;
86796: POP
86797: POP
86798: GO 86880
// for j in tmp do
86800: LD_ADDR_VAR 0 4
86804: PUSH
86805: LD_VAR 0 6
86809: PUSH
86810: FOR_IN
86811: IFFALSE 86870
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
86813: LD_ADDR_VAR 0 7
86817: PUSH
86818: LD_VAR 0 4
86822: PPUSH
86823: CALL_OW 313
86827: PPUSH
86828: LD_INT 25
86830: PUSH
86831: LD_INT 1
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PPUSH
86838: CALL_OW 72
86842: ST_TO_ADDR
// if units then
86843: LD_VAR 0 7
86847: IFFALSE 86868
// begin ComExitBuilding ( units [ 1 ] ) ;
86849: LD_VAR 0 7
86853: PUSH
86854: LD_INT 1
86856: ARRAY
86857: PPUSH
86858: CALL_OW 122
// exit ;
86862: POP
86863: POP
86864: POP
86865: POP
86866: GO 86880
// end ; end ;
86868: GO 86810
86870: POP
86871: POP
// end ; end ; exit ;
86872: POP
86873: POP
86874: GO 86880
// end ; end ;
86876: GO 86234
86878: POP
86879: POP
// end ;
86880: LD_VAR 0 2
86884: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
86885: LD_INT 0
86887: PPUSH
86888: PPUSH
86889: PPUSH
86890: PPUSH
86891: PPUSH
86892: PPUSH
86893: PPUSH
// if not mc_bases or not skirmish then
86894: LD_EXP 61
86898: NOT
86899: PUSH
86900: LD_EXP 59
86904: NOT
86905: OR
86906: IFFALSE 86910
// exit ;
86908: GO 87175
// btype := GetBType ( building ) ;
86910: LD_ADDR_VAR 0 6
86914: PUSH
86915: LD_VAR 0 1
86919: PPUSH
86920: CALL_OW 266
86924: ST_TO_ADDR
// x := GetX ( building ) ;
86925: LD_ADDR_VAR 0 7
86929: PUSH
86930: LD_VAR 0 1
86934: PPUSH
86935: CALL_OW 250
86939: ST_TO_ADDR
// y := GetY ( building ) ;
86940: LD_ADDR_VAR 0 8
86944: PUSH
86945: LD_VAR 0 1
86949: PPUSH
86950: CALL_OW 251
86954: ST_TO_ADDR
// d := GetDir ( building ) ;
86955: LD_ADDR_VAR 0 9
86959: PUSH
86960: LD_VAR 0 1
86964: PPUSH
86965: CALL_OW 254
86969: ST_TO_ADDR
// for i = 1 to mc_bases do
86970: LD_ADDR_VAR 0 4
86974: PUSH
86975: DOUBLE
86976: LD_INT 1
86978: DEC
86979: ST_TO_ADDR
86980: LD_EXP 61
86984: PUSH
86985: FOR_TO
86986: IFFALSE 87173
// begin if not mc_build_list [ i ] then
86988: LD_EXP 66
86992: PUSH
86993: LD_VAR 0 4
86997: ARRAY
86998: NOT
86999: IFFALSE 87003
// continue ;
87001: GO 86985
// for j := 1 to mc_build_list [ i ] do
87003: LD_ADDR_VAR 0 5
87007: PUSH
87008: DOUBLE
87009: LD_INT 1
87011: DEC
87012: ST_TO_ADDR
87013: LD_EXP 66
87017: PUSH
87018: LD_VAR 0 4
87022: ARRAY
87023: PUSH
87024: FOR_TO
87025: IFFALSE 87169
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
87027: LD_VAR 0 6
87031: PUSH
87032: LD_VAR 0 7
87036: PUSH
87037: LD_VAR 0 8
87041: PUSH
87042: LD_VAR 0 9
87046: PUSH
87047: EMPTY
87048: LIST
87049: LIST
87050: LIST
87051: LIST
87052: PPUSH
87053: LD_EXP 66
87057: PUSH
87058: LD_VAR 0 4
87062: ARRAY
87063: PUSH
87064: LD_VAR 0 5
87068: ARRAY
87069: PPUSH
87070: CALL 26621 0 2
87074: IFFALSE 87167
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
87076: LD_ADDR_EXP 66
87080: PUSH
87081: LD_EXP 66
87085: PPUSH
87086: LD_VAR 0 4
87090: PPUSH
87091: LD_EXP 66
87095: PUSH
87096: LD_VAR 0 4
87100: ARRAY
87101: PPUSH
87102: LD_VAR 0 5
87106: PPUSH
87107: CALL_OW 3
87111: PPUSH
87112: CALL_OW 1
87116: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
87117: LD_ADDR_EXP 68
87121: PUSH
87122: LD_EXP 68
87126: PPUSH
87127: LD_VAR 0 4
87131: PUSH
87132: LD_EXP 68
87136: PUSH
87137: LD_VAR 0 4
87141: ARRAY
87142: PUSH
87143: LD_INT 1
87145: PLUS
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: PPUSH
87151: LD_VAR 0 1
87155: PPUSH
87156: CALL 20441 0 3
87160: ST_TO_ADDR
// exit ;
87161: POP
87162: POP
87163: POP
87164: POP
87165: GO 87175
// end ;
87167: GO 87024
87169: POP
87170: POP
// end ;
87171: GO 86985
87173: POP
87174: POP
// end ;
87175: LD_VAR 0 3
87179: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
87180: LD_INT 0
87182: PPUSH
87183: PPUSH
87184: PPUSH
// if not mc_bases or not skirmish then
87185: LD_EXP 61
87189: NOT
87190: PUSH
87191: LD_EXP 59
87195: NOT
87196: OR
87197: IFFALSE 87201
// exit ;
87199: GO 87391
// for i = 1 to mc_bases do
87201: LD_ADDR_VAR 0 4
87205: PUSH
87206: DOUBLE
87207: LD_INT 1
87209: DEC
87210: ST_TO_ADDR
87211: LD_EXP 61
87215: PUSH
87216: FOR_TO
87217: IFFALSE 87304
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
87219: LD_VAR 0 1
87223: PUSH
87224: LD_EXP 69
87228: PUSH
87229: LD_VAR 0 4
87233: ARRAY
87234: IN
87235: PUSH
87236: LD_VAR 0 1
87240: PUSH
87241: LD_EXP 70
87245: PUSH
87246: LD_VAR 0 4
87250: ARRAY
87251: IN
87252: NOT
87253: AND
87254: IFFALSE 87302
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
87256: LD_ADDR_EXP 70
87260: PUSH
87261: LD_EXP 70
87265: PPUSH
87266: LD_VAR 0 4
87270: PUSH
87271: LD_EXP 70
87275: PUSH
87276: LD_VAR 0 4
87280: ARRAY
87281: PUSH
87282: LD_INT 1
87284: PLUS
87285: PUSH
87286: EMPTY
87287: LIST
87288: LIST
87289: PPUSH
87290: LD_VAR 0 1
87294: PPUSH
87295: CALL 20441 0 3
87299: ST_TO_ADDR
// break ;
87300: GO 87304
// end ; end ;
87302: GO 87216
87304: POP
87305: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
87306: LD_VAR 0 1
87310: PPUSH
87311: CALL_OW 257
87315: PUSH
87316: LD_EXP 87
87320: IN
87321: PUSH
87322: LD_VAR 0 1
87326: PPUSH
87327: CALL_OW 266
87331: PUSH
87332: LD_INT 5
87334: EQUAL
87335: AND
87336: PUSH
87337: LD_VAR 0 2
87341: PPUSH
87342: CALL_OW 110
87346: PUSH
87347: LD_INT 18
87349: NONEQUAL
87350: AND
87351: IFFALSE 87391
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
87353: LD_VAR 0 2
87357: PPUSH
87358: CALL_OW 257
87362: PUSH
87363: LD_INT 5
87365: PUSH
87366: LD_INT 8
87368: PUSH
87369: LD_INT 9
87371: PUSH
87372: EMPTY
87373: LIST
87374: LIST
87375: LIST
87376: IN
87377: IFFALSE 87391
// SetClass ( unit , 1 ) ;
87379: LD_VAR 0 2
87383: PPUSH
87384: LD_INT 1
87386: PPUSH
87387: CALL_OW 336
// end ;
87391: LD_VAR 0 3
87395: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
87396: LD_INT 0
87398: PPUSH
87399: PPUSH
// if not mc_bases or not skirmish then
87400: LD_EXP 61
87404: NOT
87405: PUSH
87406: LD_EXP 59
87410: NOT
87411: OR
87412: IFFALSE 87416
// exit ;
87414: GO 87532
// if GetLives ( abandoned_vehicle ) > 250 then
87416: LD_VAR 0 2
87420: PPUSH
87421: CALL_OW 256
87425: PUSH
87426: LD_INT 250
87428: GREATER
87429: IFFALSE 87433
// exit ;
87431: GO 87532
// for i = 1 to mc_bases do
87433: LD_ADDR_VAR 0 6
87437: PUSH
87438: DOUBLE
87439: LD_INT 1
87441: DEC
87442: ST_TO_ADDR
87443: LD_EXP 61
87447: PUSH
87448: FOR_TO
87449: IFFALSE 87530
// begin if driver in mc_bases [ i ] then
87451: LD_VAR 0 1
87455: PUSH
87456: LD_EXP 61
87460: PUSH
87461: LD_VAR 0 6
87465: ARRAY
87466: IN
87467: IFFALSE 87528
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
87469: LD_VAR 0 1
87473: PPUSH
87474: LD_EXP 61
87478: PUSH
87479: LD_VAR 0 6
87483: ARRAY
87484: PPUSH
87485: LD_INT 2
87487: PUSH
87488: LD_INT 30
87490: PUSH
87491: LD_INT 0
87493: PUSH
87494: EMPTY
87495: LIST
87496: LIST
87497: PUSH
87498: LD_INT 30
87500: PUSH
87501: LD_INT 1
87503: PUSH
87504: EMPTY
87505: LIST
87506: LIST
87507: PUSH
87508: EMPTY
87509: LIST
87510: LIST
87511: LIST
87512: PPUSH
87513: CALL_OW 72
87517: PUSH
87518: LD_INT 1
87520: ARRAY
87521: PPUSH
87522: CALL 53648 0 2
// break ;
87526: GO 87530
// end ; end ;
87528: GO 87448
87530: POP
87531: POP
// end ; end_of_file end_of_file
87532: LD_VAR 0 5
87536: RET
// export globalGameSaveCounter ; every 0 0$1 do
87537: GO 87539
87539: DISABLE
// begin enable ;
87540: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
87541: LD_STRING updateTimer(
87543: PUSH
87544: LD_OWVAR 1
87548: STR
87549: PUSH
87550: LD_STRING );
87552: STR
87553: PPUSH
87554: CALL_OW 559
// end ;
87558: END
// every 0 0$1 do
87559: GO 87561
87561: DISABLE
// begin globalGameSaveCounter := 0 ;
87562: LD_ADDR_EXP 106
87566: PUSH
87567: LD_INT 0
87569: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
87570: LD_STRING setGameSaveCounter(0)
87572: PPUSH
87573: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
87577: LD_STRING initStreamRollete();
87579: PPUSH
87580: CALL_OW 559
// InitStreamMode ;
87584: CALL 88910 0 0
// DefineStreamItems ( false ) ;
87588: LD_INT 0
87590: PPUSH
87591: CALL 89374 0 1
// end ;
87595: END
// export function SOS_MapStart ( ) ; begin
87596: LD_INT 0
87598: PPUSH
// if streamModeActive then
87599: LD_EXP 107
87603: IFFALSE 87612
// DefineStreamItems ( true ) ;
87605: LD_INT 1
87607: PPUSH
87608: CALL 89374 0 1
// UpdateLuaVariables ( ) ;
87612: CALL 87629 0 0
// UpdateFactoryWaypoints ( ) ;
87616: CALL 102243 0 0
// UpdateWarehouseGatheringPoints ( ) ;
87620: CALL 102500 0 0
// end ;
87624: LD_VAR 0 1
87628: RET
// function UpdateLuaVariables ( ) ; begin
87629: LD_INT 0
87631: PPUSH
// if globalGameSaveCounter then
87632: LD_EXP 106
87636: IFFALSE 87670
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
87638: LD_ADDR_EXP 106
87642: PUSH
87643: LD_EXP 106
87647: PPUSH
87648: CALL 54132 0 1
87652: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
87653: LD_STRING setGameSaveCounter(
87655: PUSH
87656: LD_EXP 106
87660: STR
87661: PUSH
87662: LD_STRING )
87664: STR
87665: PPUSH
87666: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
87670: LD_STRING setGameDifficulty(
87672: PUSH
87673: LD_OWVAR 67
87677: STR
87678: PUSH
87679: LD_STRING )
87681: STR
87682: PPUSH
87683: CALL_OW 559
// end ;
87687: LD_VAR 0 1
87691: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
87692: LD_INT 0
87694: PPUSH
// if p2 = stream_mode then
87695: LD_VAR 0 2
87699: PUSH
87700: LD_INT 100
87702: EQUAL
87703: IFFALSE 88706
// begin if not StreamModeActive then
87705: LD_EXP 107
87709: NOT
87710: IFFALSE 87720
// StreamModeActive := true ;
87712: LD_ADDR_EXP 107
87716: PUSH
87717: LD_INT 1
87719: ST_TO_ADDR
// if p3 = 0 then
87720: LD_VAR 0 3
87724: PUSH
87725: LD_INT 0
87727: EQUAL
87728: IFFALSE 87734
// InitStreamMode ;
87730: CALL 88910 0 0
// if p3 = 1 then
87734: LD_VAR 0 3
87738: PUSH
87739: LD_INT 1
87741: EQUAL
87742: IFFALSE 87752
// sRocket := true ;
87744: LD_ADDR_EXP 112
87748: PUSH
87749: LD_INT 1
87751: ST_TO_ADDR
// if p3 = 2 then
87752: LD_VAR 0 3
87756: PUSH
87757: LD_INT 2
87759: EQUAL
87760: IFFALSE 87770
// sSpeed := true ;
87762: LD_ADDR_EXP 111
87766: PUSH
87767: LD_INT 1
87769: ST_TO_ADDR
// if p3 = 3 then
87770: LD_VAR 0 3
87774: PUSH
87775: LD_INT 3
87777: EQUAL
87778: IFFALSE 87788
// sEngine := true ;
87780: LD_ADDR_EXP 113
87784: PUSH
87785: LD_INT 1
87787: ST_TO_ADDR
// if p3 = 4 then
87788: LD_VAR 0 3
87792: PUSH
87793: LD_INT 4
87795: EQUAL
87796: IFFALSE 87806
// sSpec := true ;
87798: LD_ADDR_EXP 110
87802: PUSH
87803: LD_INT 1
87805: ST_TO_ADDR
// if p3 = 5 then
87806: LD_VAR 0 3
87810: PUSH
87811: LD_INT 5
87813: EQUAL
87814: IFFALSE 87824
// sLevel := true ;
87816: LD_ADDR_EXP 114
87820: PUSH
87821: LD_INT 1
87823: ST_TO_ADDR
// if p3 = 6 then
87824: LD_VAR 0 3
87828: PUSH
87829: LD_INT 6
87831: EQUAL
87832: IFFALSE 87842
// sArmoury := true ;
87834: LD_ADDR_EXP 115
87838: PUSH
87839: LD_INT 1
87841: ST_TO_ADDR
// if p3 = 7 then
87842: LD_VAR 0 3
87846: PUSH
87847: LD_INT 7
87849: EQUAL
87850: IFFALSE 87860
// sRadar := true ;
87852: LD_ADDR_EXP 116
87856: PUSH
87857: LD_INT 1
87859: ST_TO_ADDR
// if p3 = 8 then
87860: LD_VAR 0 3
87864: PUSH
87865: LD_INT 8
87867: EQUAL
87868: IFFALSE 87878
// sBunker := true ;
87870: LD_ADDR_EXP 117
87874: PUSH
87875: LD_INT 1
87877: ST_TO_ADDR
// if p3 = 9 then
87878: LD_VAR 0 3
87882: PUSH
87883: LD_INT 9
87885: EQUAL
87886: IFFALSE 87896
// sHack := true ;
87888: LD_ADDR_EXP 118
87892: PUSH
87893: LD_INT 1
87895: ST_TO_ADDR
// if p3 = 10 then
87896: LD_VAR 0 3
87900: PUSH
87901: LD_INT 10
87903: EQUAL
87904: IFFALSE 87914
// sFire := true ;
87906: LD_ADDR_EXP 119
87910: PUSH
87911: LD_INT 1
87913: ST_TO_ADDR
// if p3 = 11 then
87914: LD_VAR 0 3
87918: PUSH
87919: LD_INT 11
87921: EQUAL
87922: IFFALSE 87932
// sRefresh := true ;
87924: LD_ADDR_EXP 120
87928: PUSH
87929: LD_INT 1
87931: ST_TO_ADDR
// if p3 = 12 then
87932: LD_VAR 0 3
87936: PUSH
87937: LD_INT 12
87939: EQUAL
87940: IFFALSE 87950
// sExp := true ;
87942: LD_ADDR_EXP 121
87946: PUSH
87947: LD_INT 1
87949: ST_TO_ADDR
// if p3 = 13 then
87950: LD_VAR 0 3
87954: PUSH
87955: LD_INT 13
87957: EQUAL
87958: IFFALSE 87968
// sDepot := true ;
87960: LD_ADDR_EXP 122
87964: PUSH
87965: LD_INT 1
87967: ST_TO_ADDR
// if p3 = 14 then
87968: LD_VAR 0 3
87972: PUSH
87973: LD_INT 14
87975: EQUAL
87976: IFFALSE 87986
// sFlag := true ;
87978: LD_ADDR_EXP 123
87982: PUSH
87983: LD_INT 1
87985: ST_TO_ADDR
// if p3 = 15 then
87986: LD_VAR 0 3
87990: PUSH
87991: LD_INT 15
87993: EQUAL
87994: IFFALSE 88004
// sKamikadze := true ;
87996: LD_ADDR_EXP 131
88000: PUSH
88001: LD_INT 1
88003: ST_TO_ADDR
// if p3 = 16 then
88004: LD_VAR 0 3
88008: PUSH
88009: LD_INT 16
88011: EQUAL
88012: IFFALSE 88022
// sTroll := true ;
88014: LD_ADDR_EXP 132
88018: PUSH
88019: LD_INT 1
88021: ST_TO_ADDR
// if p3 = 17 then
88022: LD_VAR 0 3
88026: PUSH
88027: LD_INT 17
88029: EQUAL
88030: IFFALSE 88040
// sSlow := true ;
88032: LD_ADDR_EXP 133
88036: PUSH
88037: LD_INT 1
88039: ST_TO_ADDR
// if p3 = 18 then
88040: LD_VAR 0 3
88044: PUSH
88045: LD_INT 18
88047: EQUAL
88048: IFFALSE 88058
// sLack := true ;
88050: LD_ADDR_EXP 134
88054: PUSH
88055: LD_INT 1
88057: ST_TO_ADDR
// if p3 = 19 then
88058: LD_VAR 0 3
88062: PUSH
88063: LD_INT 19
88065: EQUAL
88066: IFFALSE 88076
// sTank := true ;
88068: LD_ADDR_EXP 136
88072: PUSH
88073: LD_INT 1
88075: ST_TO_ADDR
// if p3 = 20 then
88076: LD_VAR 0 3
88080: PUSH
88081: LD_INT 20
88083: EQUAL
88084: IFFALSE 88094
// sRemote := true ;
88086: LD_ADDR_EXP 137
88090: PUSH
88091: LD_INT 1
88093: ST_TO_ADDR
// if p3 = 21 then
88094: LD_VAR 0 3
88098: PUSH
88099: LD_INT 21
88101: EQUAL
88102: IFFALSE 88112
// sPowell := true ;
88104: LD_ADDR_EXP 138
88108: PUSH
88109: LD_INT 1
88111: ST_TO_ADDR
// if p3 = 22 then
88112: LD_VAR 0 3
88116: PUSH
88117: LD_INT 22
88119: EQUAL
88120: IFFALSE 88130
// sTeleport := true ;
88122: LD_ADDR_EXP 141
88126: PUSH
88127: LD_INT 1
88129: ST_TO_ADDR
// if p3 = 23 then
88130: LD_VAR 0 3
88134: PUSH
88135: LD_INT 23
88137: EQUAL
88138: IFFALSE 88148
// sOilTower := true ;
88140: LD_ADDR_EXP 143
88144: PUSH
88145: LD_INT 1
88147: ST_TO_ADDR
// if p3 = 24 then
88148: LD_VAR 0 3
88152: PUSH
88153: LD_INT 24
88155: EQUAL
88156: IFFALSE 88166
// sShovel := true ;
88158: LD_ADDR_EXP 144
88162: PUSH
88163: LD_INT 1
88165: ST_TO_ADDR
// if p3 = 25 then
88166: LD_VAR 0 3
88170: PUSH
88171: LD_INT 25
88173: EQUAL
88174: IFFALSE 88184
// sSheik := true ;
88176: LD_ADDR_EXP 145
88180: PUSH
88181: LD_INT 1
88183: ST_TO_ADDR
// if p3 = 26 then
88184: LD_VAR 0 3
88188: PUSH
88189: LD_INT 26
88191: EQUAL
88192: IFFALSE 88202
// sEarthquake := true ;
88194: LD_ADDR_EXP 147
88198: PUSH
88199: LD_INT 1
88201: ST_TO_ADDR
// if p3 = 27 then
88202: LD_VAR 0 3
88206: PUSH
88207: LD_INT 27
88209: EQUAL
88210: IFFALSE 88220
// sAI := true ;
88212: LD_ADDR_EXP 148
88216: PUSH
88217: LD_INT 1
88219: ST_TO_ADDR
// if p3 = 28 then
88220: LD_VAR 0 3
88224: PUSH
88225: LD_INT 28
88227: EQUAL
88228: IFFALSE 88238
// sCargo := true ;
88230: LD_ADDR_EXP 151
88234: PUSH
88235: LD_INT 1
88237: ST_TO_ADDR
// if p3 = 29 then
88238: LD_VAR 0 3
88242: PUSH
88243: LD_INT 29
88245: EQUAL
88246: IFFALSE 88256
// sDLaser := true ;
88248: LD_ADDR_EXP 152
88252: PUSH
88253: LD_INT 1
88255: ST_TO_ADDR
// if p3 = 30 then
88256: LD_VAR 0 3
88260: PUSH
88261: LD_INT 30
88263: EQUAL
88264: IFFALSE 88274
// sExchange := true ;
88266: LD_ADDR_EXP 153
88270: PUSH
88271: LD_INT 1
88273: ST_TO_ADDR
// if p3 = 31 then
88274: LD_VAR 0 3
88278: PUSH
88279: LD_INT 31
88281: EQUAL
88282: IFFALSE 88292
// sFac := true ;
88284: LD_ADDR_EXP 154
88288: PUSH
88289: LD_INT 1
88291: ST_TO_ADDR
// if p3 = 32 then
88292: LD_VAR 0 3
88296: PUSH
88297: LD_INT 32
88299: EQUAL
88300: IFFALSE 88310
// sPower := true ;
88302: LD_ADDR_EXP 155
88306: PUSH
88307: LD_INT 1
88309: ST_TO_ADDR
// if p3 = 33 then
88310: LD_VAR 0 3
88314: PUSH
88315: LD_INT 33
88317: EQUAL
88318: IFFALSE 88328
// sRandom := true ;
88320: LD_ADDR_EXP 156
88324: PUSH
88325: LD_INT 1
88327: ST_TO_ADDR
// if p3 = 34 then
88328: LD_VAR 0 3
88332: PUSH
88333: LD_INT 34
88335: EQUAL
88336: IFFALSE 88346
// sShield := true ;
88338: LD_ADDR_EXP 157
88342: PUSH
88343: LD_INT 1
88345: ST_TO_ADDR
// if p3 = 35 then
88346: LD_VAR 0 3
88350: PUSH
88351: LD_INT 35
88353: EQUAL
88354: IFFALSE 88364
// sTime := true ;
88356: LD_ADDR_EXP 158
88360: PUSH
88361: LD_INT 1
88363: ST_TO_ADDR
// if p3 = 36 then
88364: LD_VAR 0 3
88368: PUSH
88369: LD_INT 36
88371: EQUAL
88372: IFFALSE 88382
// sTools := true ;
88374: LD_ADDR_EXP 159
88378: PUSH
88379: LD_INT 1
88381: ST_TO_ADDR
// if p3 = 101 then
88382: LD_VAR 0 3
88386: PUSH
88387: LD_INT 101
88389: EQUAL
88390: IFFALSE 88400
// sSold := true ;
88392: LD_ADDR_EXP 124
88396: PUSH
88397: LD_INT 1
88399: ST_TO_ADDR
// if p3 = 102 then
88400: LD_VAR 0 3
88404: PUSH
88405: LD_INT 102
88407: EQUAL
88408: IFFALSE 88418
// sDiff := true ;
88410: LD_ADDR_EXP 125
88414: PUSH
88415: LD_INT 1
88417: ST_TO_ADDR
// if p3 = 103 then
88418: LD_VAR 0 3
88422: PUSH
88423: LD_INT 103
88425: EQUAL
88426: IFFALSE 88436
// sFog := true ;
88428: LD_ADDR_EXP 128
88432: PUSH
88433: LD_INT 1
88435: ST_TO_ADDR
// if p3 = 104 then
88436: LD_VAR 0 3
88440: PUSH
88441: LD_INT 104
88443: EQUAL
88444: IFFALSE 88454
// sReset := true ;
88446: LD_ADDR_EXP 129
88450: PUSH
88451: LD_INT 1
88453: ST_TO_ADDR
// if p3 = 105 then
88454: LD_VAR 0 3
88458: PUSH
88459: LD_INT 105
88461: EQUAL
88462: IFFALSE 88472
// sSun := true ;
88464: LD_ADDR_EXP 130
88468: PUSH
88469: LD_INT 1
88471: ST_TO_ADDR
// if p3 = 106 then
88472: LD_VAR 0 3
88476: PUSH
88477: LD_INT 106
88479: EQUAL
88480: IFFALSE 88490
// sTiger := true ;
88482: LD_ADDR_EXP 126
88486: PUSH
88487: LD_INT 1
88489: ST_TO_ADDR
// if p3 = 107 then
88490: LD_VAR 0 3
88494: PUSH
88495: LD_INT 107
88497: EQUAL
88498: IFFALSE 88508
// sBomb := true ;
88500: LD_ADDR_EXP 127
88504: PUSH
88505: LD_INT 1
88507: ST_TO_ADDR
// if p3 = 108 then
88508: LD_VAR 0 3
88512: PUSH
88513: LD_INT 108
88515: EQUAL
88516: IFFALSE 88526
// sWound := true ;
88518: LD_ADDR_EXP 135
88522: PUSH
88523: LD_INT 1
88525: ST_TO_ADDR
// if p3 = 109 then
88526: LD_VAR 0 3
88530: PUSH
88531: LD_INT 109
88533: EQUAL
88534: IFFALSE 88544
// sBetray := true ;
88536: LD_ADDR_EXP 139
88540: PUSH
88541: LD_INT 1
88543: ST_TO_ADDR
// if p3 = 110 then
88544: LD_VAR 0 3
88548: PUSH
88549: LD_INT 110
88551: EQUAL
88552: IFFALSE 88562
// sContamin := true ;
88554: LD_ADDR_EXP 140
88558: PUSH
88559: LD_INT 1
88561: ST_TO_ADDR
// if p3 = 111 then
88562: LD_VAR 0 3
88566: PUSH
88567: LD_INT 111
88569: EQUAL
88570: IFFALSE 88580
// sOil := true ;
88572: LD_ADDR_EXP 142
88576: PUSH
88577: LD_INT 1
88579: ST_TO_ADDR
// if p3 = 112 then
88580: LD_VAR 0 3
88584: PUSH
88585: LD_INT 112
88587: EQUAL
88588: IFFALSE 88598
// sStu := true ;
88590: LD_ADDR_EXP 146
88594: PUSH
88595: LD_INT 1
88597: ST_TO_ADDR
// if p3 = 113 then
88598: LD_VAR 0 3
88602: PUSH
88603: LD_INT 113
88605: EQUAL
88606: IFFALSE 88616
// sBazooka := true ;
88608: LD_ADDR_EXP 149
88612: PUSH
88613: LD_INT 1
88615: ST_TO_ADDR
// if p3 = 114 then
88616: LD_VAR 0 3
88620: PUSH
88621: LD_INT 114
88623: EQUAL
88624: IFFALSE 88634
// sMortar := true ;
88626: LD_ADDR_EXP 150
88630: PUSH
88631: LD_INT 1
88633: ST_TO_ADDR
// if p3 = 115 then
88634: LD_VAR 0 3
88638: PUSH
88639: LD_INT 115
88641: EQUAL
88642: IFFALSE 88652
// sRanger := true ;
88644: LD_ADDR_EXP 160
88648: PUSH
88649: LD_INT 1
88651: ST_TO_ADDR
// if p3 = 116 then
88652: LD_VAR 0 3
88656: PUSH
88657: LD_INT 116
88659: EQUAL
88660: IFFALSE 88670
// sComputer := true ;
88662: LD_ADDR_EXP 161
88666: PUSH
88667: LD_INT 1
88669: ST_TO_ADDR
// if p3 = 117 then
88670: LD_VAR 0 3
88674: PUSH
88675: LD_INT 117
88677: EQUAL
88678: IFFALSE 88688
// s30 := true ;
88680: LD_ADDR_EXP 162
88684: PUSH
88685: LD_INT 1
88687: ST_TO_ADDR
// if p3 = 118 then
88688: LD_VAR 0 3
88692: PUSH
88693: LD_INT 118
88695: EQUAL
88696: IFFALSE 88706
// s60 := true ;
88698: LD_ADDR_EXP 163
88702: PUSH
88703: LD_INT 1
88705: ST_TO_ADDR
// end ; if p2 = hack_mode then
88706: LD_VAR 0 2
88710: PUSH
88711: LD_INT 101
88713: EQUAL
88714: IFFALSE 88842
// begin case p3 of 1 :
88716: LD_VAR 0 3
88720: PUSH
88721: LD_INT 1
88723: DOUBLE
88724: EQUAL
88725: IFTRUE 88729
88727: GO 88736
88729: POP
// hHackUnlimitedResources ; 2 :
88730: CALL 100989 0 0
88734: GO 88842
88736: LD_INT 2
88738: DOUBLE
88739: EQUAL
88740: IFTRUE 88744
88742: GO 88751
88744: POP
// hHackSetLevel10 ; 3 :
88745: CALL 101122 0 0
88749: GO 88842
88751: LD_INT 3
88753: DOUBLE
88754: EQUAL
88755: IFTRUE 88759
88757: GO 88766
88759: POP
// hHackSetLevel10YourUnits ; 4 :
88760: CALL 101207 0 0
88764: GO 88842
88766: LD_INT 4
88768: DOUBLE
88769: EQUAL
88770: IFTRUE 88774
88772: GO 88781
88774: POP
// hHackInvincible ; 5 :
88775: CALL 101655 0 0
88779: GO 88842
88781: LD_INT 5
88783: DOUBLE
88784: EQUAL
88785: IFTRUE 88789
88787: GO 88796
88789: POP
// hHackInvisible ; 6 :
88790: CALL 101766 0 0
88794: GO 88842
88796: LD_INT 6
88798: DOUBLE
88799: EQUAL
88800: IFTRUE 88804
88802: GO 88811
88804: POP
// hHackChangeYourSide ; 7 :
88805: CALL 101823 0 0
88809: GO 88842
88811: LD_INT 7
88813: DOUBLE
88814: EQUAL
88815: IFTRUE 88819
88817: GO 88826
88819: POP
// hHackChangeUnitSide ; 8 :
88820: CALL 101865 0 0
88824: GO 88842
88826: LD_INT 8
88828: DOUBLE
88829: EQUAL
88830: IFTRUE 88834
88832: GO 88841
88834: POP
// hHackFog ; end ;
88835: CALL 101966 0 0
88839: GO 88842
88841: POP
// end ; if p2 = game_save_mode then
88842: LD_VAR 0 2
88846: PUSH
88847: LD_INT 102
88849: EQUAL
88850: IFFALSE 88905
// begin if p3 = 1 then
88852: LD_VAR 0 3
88856: PUSH
88857: LD_INT 1
88859: EQUAL
88860: IFFALSE 88872
// globalGameSaveCounter := p4 ;
88862: LD_ADDR_EXP 106
88866: PUSH
88867: LD_VAR 0 4
88871: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
88872: LD_VAR 0 3
88876: PUSH
88877: LD_INT 2
88879: EQUAL
88880: PUSH
88881: LD_EXP 106
88885: AND
88886: IFFALSE 88905
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
88888: LD_STRING setGameSaveCounter(
88890: PUSH
88891: LD_EXP 106
88895: STR
88896: PUSH
88897: LD_STRING )
88899: STR
88900: PPUSH
88901: CALL_OW 559
// end ; end ;
88905: LD_VAR 0 7
88909: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
88910: LD_INT 0
88912: PPUSH
// streamModeActive := false ;
88913: LD_ADDR_EXP 107
88917: PUSH
88918: LD_INT 0
88920: ST_TO_ADDR
// normalCounter := 36 ;
88921: LD_ADDR_EXP 108
88925: PUSH
88926: LD_INT 36
88928: ST_TO_ADDR
// hardcoreCounter := 18 ;
88929: LD_ADDR_EXP 109
88933: PUSH
88934: LD_INT 18
88936: ST_TO_ADDR
// sRocket := false ;
88937: LD_ADDR_EXP 112
88941: PUSH
88942: LD_INT 0
88944: ST_TO_ADDR
// sSpeed := false ;
88945: LD_ADDR_EXP 111
88949: PUSH
88950: LD_INT 0
88952: ST_TO_ADDR
// sEngine := false ;
88953: LD_ADDR_EXP 113
88957: PUSH
88958: LD_INT 0
88960: ST_TO_ADDR
// sSpec := false ;
88961: LD_ADDR_EXP 110
88965: PUSH
88966: LD_INT 0
88968: ST_TO_ADDR
// sLevel := false ;
88969: LD_ADDR_EXP 114
88973: PUSH
88974: LD_INT 0
88976: ST_TO_ADDR
// sArmoury := false ;
88977: LD_ADDR_EXP 115
88981: PUSH
88982: LD_INT 0
88984: ST_TO_ADDR
// sRadar := false ;
88985: LD_ADDR_EXP 116
88989: PUSH
88990: LD_INT 0
88992: ST_TO_ADDR
// sBunker := false ;
88993: LD_ADDR_EXP 117
88997: PUSH
88998: LD_INT 0
89000: ST_TO_ADDR
// sHack := false ;
89001: LD_ADDR_EXP 118
89005: PUSH
89006: LD_INT 0
89008: ST_TO_ADDR
// sFire := false ;
89009: LD_ADDR_EXP 119
89013: PUSH
89014: LD_INT 0
89016: ST_TO_ADDR
// sRefresh := false ;
89017: LD_ADDR_EXP 120
89021: PUSH
89022: LD_INT 0
89024: ST_TO_ADDR
// sExp := false ;
89025: LD_ADDR_EXP 121
89029: PUSH
89030: LD_INT 0
89032: ST_TO_ADDR
// sDepot := false ;
89033: LD_ADDR_EXP 122
89037: PUSH
89038: LD_INT 0
89040: ST_TO_ADDR
// sFlag := false ;
89041: LD_ADDR_EXP 123
89045: PUSH
89046: LD_INT 0
89048: ST_TO_ADDR
// sKamikadze := false ;
89049: LD_ADDR_EXP 131
89053: PUSH
89054: LD_INT 0
89056: ST_TO_ADDR
// sTroll := false ;
89057: LD_ADDR_EXP 132
89061: PUSH
89062: LD_INT 0
89064: ST_TO_ADDR
// sSlow := false ;
89065: LD_ADDR_EXP 133
89069: PUSH
89070: LD_INT 0
89072: ST_TO_ADDR
// sLack := false ;
89073: LD_ADDR_EXP 134
89077: PUSH
89078: LD_INT 0
89080: ST_TO_ADDR
// sTank := false ;
89081: LD_ADDR_EXP 136
89085: PUSH
89086: LD_INT 0
89088: ST_TO_ADDR
// sRemote := false ;
89089: LD_ADDR_EXP 137
89093: PUSH
89094: LD_INT 0
89096: ST_TO_ADDR
// sPowell := false ;
89097: LD_ADDR_EXP 138
89101: PUSH
89102: LD_INT 0
89104: ST_TO_ADDR
// sTeleport := false ;
89105: LD_ADDR_EXP 141
89109: PUSH
89110: LD_INT 0
89112: ST_TO_ADDR
// sOilTower := false ;
89113: LD_ADDR_EXP 143
89117: PUSH
89118: LD_INT 0
89120: ST_TO_ADDR
// sShovel := false ;
89121: LD_ADDR_EXP 144
89125: PUSH
89126: LD_INT 0
89128: ST_TO_ADDR
// sSheik := false ;
89129: LD_ADDR_EXP 145
89133: PUSH
89134: LD_INT 0
89136: ST_TO_ADDR
// sEarthquake := false ;
89137: LD_ADDR_EXP 147
89141: PUSH
89142: LD_INT 0
89144: ST_TO_ADDR
// sAI := false ;
89145: LD_ADDR_EXP 148
89149: PUSH
89150: LD_INT 0
89152: ST_TO_ADDR
// sCargo := false ;
89153: LD_ADDR_EXP 151
89157: PUSH
89158: LD_INT 0
89160: ST_TO_ADDR
// sDLaser := false ;
89161: LD_ADDR_EXP 152
89165: PUSH
89166: LD_INT 0
89168: ST_TO_ADDR
// sExchange := false ;
89169: LD_ADDR_EXP 153
89173: PUSH
89174: LD_INT 0
89176: ST_TO_ADDR
// sFac := false ;
89177: LD_ADDR_EXP 154
89181: PUSH
89182: LD_INT 0
89184: ST_TO_ADDR
// sPower := false ;
89185: LD_ADDR_EXP 155
89189: PUSH
89190: LD_INT 0
89192: ST_TO_ADDR
// sRandom := false ;
89193: LD_ADDR_EXP 156
89197: PUSH
89198: LD_INT 0
89200: ST_TO_ADDR
// sShield := false ;
89201: LD_ADDR_EXP 157
89205: PUSH
89206: LD_INT 0
89208: ST_TO_ADDR
// sTime := false ;
89209: LD_ADDR_EXP 158
89213: PUSH
89214: LD_INT 0
89216: ST_TO_ADDR
// sTools := false ;
89217: LD_ADDR_EXP 159
89221: PUSH
89222: LD_INT 0
89224: ST_TO_ADDR
// sSold := false ;
89225: LD_ADDR_EXP 124
89229: PUSH
89230: LD_INT 0
89232: ST_TO_ADDR
// sDiff := false ;
89233: LD_ADDR_EXP 125
89237: PUSH
89238: LD_INT 0
89240: ST_TO_ADDR
// sFog := false ;
89241: LD_ADDR_EXP 128
89245: PUSH
89246: LD_INT 0
89248: ST_TO_ADDR
// sReset := false ;
89249: LD_ADDR_EXP 129
89253: PUSH
89254: LD_INT 0
89256: ST_TO_ADDR
// sSun := false ;
89257: LD_ADDR_EXP 130
89261: PUSH
89262: LD_INT 0
89264: ST_TO_ADDR
// sTiger := false ;
89265: LD_ADDR_EXP 126
89269: PUSH
89270: LD_INT 0
89272: ST_TO_ADDR
// sBomb := false ;
89273: LD_ADDR_EXP 127
89277: PUSH
89278: LD_INT 0
89280: ST_TO_ADDR
// sWound := false ;
89281: LD_ADDR_EXP 135
89285: PUSH
89286: LD_INT 0
89288: ST_TO_ADDR
// sBetray := false ;
89289: LD_ADDR_EXP 139
89293: PUSH
89294: LD_INT 0
89296: ST_TO_ADDR
// sContamin := false ;
89297: LD_ADDR_EXP 140
89301: PUSH
89302: LD_INT 0
89304: ST_TO_ADDR
// sOil := false ;
89305: LD_ADDR_EXP 142
89309: PUSH
89310: LD_INT 0
89312: ST_TO_ADDR
// sStu := false ;
89313: LD_ADDR_EXP 146
89317: PUSH
89318: LD_INT 0
89320: ST_TO_ADDR
// sBazooka := false ;
89321: LD_ADDR_EXP 149
89325: PUSH
89326: LD_INT 0
89328: ST_TO_ADDR
// sMortar := false ;
89329: LD_ADDR_EXP 150
89333: PUSH
89334: LD_INT 0
89336: ST_TO_ADDR
// sRanger := false ;
89337: LD_ADDR_EXP 160
89341: PUSH
89342: LD_INT 0
89344: ST_TO_ADDR
// sComputer := false ;
89345: LD_ADDR_EXP 161
89349: PUSH
89350: LD_INT 0
89352: ST_TO_ADDR
// s30 := false ;
89353: LD_ADDR_EXP 162
89357: PUSH
89358: LD_INT 0
89360: ST_TO_ADDR
// s60 := false ;
89361: LD_ADDR_EXP 163
89365: PUSH
89366: LD_INT 0
89368: ST_TO_ADDR
// end ;
89369: LD_VAR 0 1
89373: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
89374: LD_INT 0
89376: PPUSH
89377: PPUSH
89378: PPUSH
89379: PPUSH
89380: PPUSH
89381: PPUSH
89382: PPUSH
// result := [ ] ;
89383: LD_ADDR_VAR 0 2
89387: PUSH
89388: EMPTY
89389: ST_TO_ADDR
// if campaign_id = 1 then
89390: LD_OWVAR 69
89394: PUSH
89395: LD_INT 1
89397: EQUAL
89398: IFFALSE 92564
// begin case mission_number of 1 :
89400: LD_OWVAR 70
89404: PUSH
89405: LD_INT 1
89407: DOUBLE
89408: EQUAL
89409: IFTRUE 89413
89411: GO 89489
89413: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
89414: LD_ADDR_VAR 0 2
89418: PUSH
89419: LD_INT 2
89421: PUSH
89422: LD_INT 4
89424: PUSH
89425: LD_INT 11
89427: PUSH
89428: LD_INT 12
89430: PUSH
89431: LD_INT 15
89433: PUSH
89434: LD_INT 16
89436: PUSH
89437: LD_INT 22
89439: PUSH
89440: LD_INT 23
89442: PUSH
89443: LD_INT 26
89445: PUSH
89446: EMPTY
89447: LIST
89448: LIST
89449: LIST
89450: LIST
89451: LIST
89452: LIST
89453: LIST
89454: LIST
89455: LIST
89456: PUSH
89457: LD_INT 101
89459: PUSH
89460: LD_INT 102
89462: PUSH
89463: LD_INT 106
89465: PUSH
89466: LD_INT 116
89468: PUSH
89469: LD_INT 117
89471: PUSH
89472: LD_INT 118
89474: PUSH
89475: EMPTY
89476: LIST
89477: LIST
89478: LIST
89479: LIST
89480: LIST
89481: LIST
89482: PUSH
89483: EMPTY
89484: LIST
89485: LIST
89486: ST_TO_ADDR
89487: GO 92562
89489: LD_INT 2
89491: DOUBLE
89492: EQUAL
89493: IFTRUE 89497
89495: GO 89581
89497: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
89498: LD_ADDR_VAR 0 2
89502: PUSH
89503: LD_INT 2
89505: PUSH
89506: LD_INT 4
89508: PUSH
89509: LD_INT 11
89511: PUSH
89512: LD_INT 12
89514: PUSH
89515: LD_INT 15
89517: PUSH
89518: LD_INT 16
89520: PUSH
89521: LD_INT 22
89523: PUSH
89524: LD_INT 23
89526: PUSH
89527: LD_INT 26
89529: PUSH
89530: EMPTY
89531: LIST
89532: LIST
89533: LIST
89534: LIST
89535: LIST
89536: LIST
89537: LIST
89538: LIST
89539: LIST
89540: PUSH
89541: LD_INT 101
89543: PUSH
89544: LD_INT 102
89546: PUSH
89547: LD_INT 105
89549: PUSH
89550: LD_INT 106
89552: PUSH
89553: LD_INT 108
89555: PUSH
89556: LD_INT 116
89558: PUSH
89559: LD_INT 117
89561: PUSH
89562: LD_INT 118
89564: PUSH
89565: EMPTY
89566: LIST
89567: LIST
89568: LIST
89569: LIST
89570: LIST
89571: LIST
89572: LIST
89573: LIST
89574: PUSH
89575: EMPTY
89576: LIST
89577: LIST
89578: ST_TO_ADDR
89579: GO 92562
89581: LD_INT 3
89583: DOUBLE
89584: EQUAL
89585: IFTRUE 89589
89587: GO 89677
89589: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
89590: LD_ADDR_VAR 0 2
89594: PUSH
89595: LD_INT 2
89597: PUSH
89598: LD_INT 4
89600: PUSH
89601: LD_INT 5
89603: PUSH
89604: LD_INT 11
89606: PUSH
89607: LD_INT 12
89609: PUSH
89610: LD_INT 15
89612: PUSH
89613: LD_INT 16
89615: PUSH
89616: LD_INT 22
89618: PUSH
89619: LD_INT 26
89621: PUSH
89622: LD_INT 36
89624: PUSH
89625: EMPTY
89626: LIST
89627: LIST
89628: LIST
89629: LIST
89630: LIST
89631: LIST
89632: LIST
89633: LIST
89634: LIST
89635: LIST
89636: PUSH
89637: LD_INT 101
89639: PUSH
89640: LD_INT 102
89642: PUSH
89643: LD_INT 105
89645: PUSH
89646: LD_INT 106
89648: PUSH
89649: LD_INT 108
89651: PUSH
89652: LD_INT 116
89654: PUSH
89655: LD_INT 117
89657: PUSH
89658: LD_INT 118
89660: PUSH
89661: EMPTY
89662: LIST
89663: LIST
89664: LIST
89665: LIST
89666: LIST
89667: LIST
89668: LIST
89669: LIST
89670: PUSH
89671: EMPTY
89672: LIST
89673: LIST
89674: ST_TO_ADDR
89675: GO 92562
89677: LD_INT 4
89679: DOUBLE
89680: EQUAL
89681: IFTRUE 89685
89683: GO 89781
89685: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
89686: LD_ADDR_VAR 0 2
89690: PUSH
89691: LD_INT 2
89693: PUSH
89694: LD_INT 4
89696: PUSH
89697: LD_INT 5
89699: PUSH
89700: LD_INT 8
89702: PUSH
89703: LD_INT 11
89705: PUSH
89706: LD_INT 12
89708: PUSH
89709: LD_INT 15
89711: PUSH
89712: LD_INT 16
89714: PUSH
89715: LD_INT 22
89717: PUSH
89718: LD_INT 23
89720: PUSH
89721: LD_INT 26
89723: PUSH
89724: LD_INT 36
89726: PUSH
89727: EMPTY
89728: LIST
89729: LIST
89730: LIST
89731: LIST
89732: LIST
89733: LIST
89734: LIST
89735: LIST
89736: LIST
89737: LIST
89738: LIST
89739: LIST
89740: PUSH
89741: LD_INT 101
89743: PUSH
89744: LD_INT 102
89746: PUSH
89747: LD_INT 105
89749: PUSH
89750: LD_INT 106
89752: PUSH
89753: LD_INT 108
89755: PUSH
89756: LD_INT 116
89758: PUSH
89759: LD_INT 117
89761: PUSH
89762: LD_INT 118
89764: PUSH
89765: EMPTY
89766: LIST
89767: LIST
89768: LIST
89769: LIST
89770: LIST
89771: LIST
89772: LIST
89773: LIST
89774: PUSH
89775: EMPTY
89776: LIST
89777: LIST
89778: ST_TO_ADDR
89779: GO 92562
89781: LD_INT 5
89783: DOUBLE
89784: EQUAL
89785: IFTRUE 89789
89787: GO 89901
89789: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
89790: LD_ADDR_VAR 0 2
89794: PUSH
89795: LD_INT 2
89797: PUSH
89798: LD_INT 4
89800: PUSH
89801: LD_INT 5
89803: PUSH
89804: LD_INT 6
89806: PUSH
89807: LD_INT 8
89809: PUSH
89810: LD_INT 11
89812: PUSH
89813: LD_INT 12
89815: PUSH
89816: LD_INT 15
89818: PUSH
89819: LD_INT 16
89821: PUSH
89822: LD_INT 22
89824: PUSH
89825: LD_INT 23
89827: PUSH
89828: LD_INT 25
89830: PUSH
89831: LD_INT 26
89833: PUSH
89834: LD_INT 36
89836: PUSH
89837: EMPTY
89838: LIST
89839: LIST
89840: LIST
89841: LIST
89842: LIST
89843: LIST
89844: LIST
89845: LIST
89846: LIST
89847: LIST
89848: LIST
89849: LIST
89850: LIST
89851: LIST
89852: PUSH
89853: LD_INT 101
89855: PUSH
89856: LD_INT 102
89858: PUSH
89859: LD_INT 105
89861: PUSH
89862: LD_INT 106
89864: PUSH
89865: LD_INT 108
89867: PUSH
89868: LD_INT 109
89870: PUSH
89871: LD_INT 112
89873: PUSH
89874: LD_INT 116
89876: PUSH
89877: LD_INT 117
89879: PUSH
89880: LD_INT 118
89882: PUSH
89883: EMPTY
89884: LIST
89885: LIST
89886: LIST
89887: LIST
89888: LIST
89889: LIST
89890: LIST
89891: LIST
89892: LIST
89893: LIST
89894: PUSH
89895: EMPTY
89896: LIST
89897: LIST
89898: ST_TO_ADDR
89899: GO 92562
89901: LD_INT 6
89903: DOUBLE
89904: EQUAL
89905: IFTRUE 89909
89907: GO 90041
89909: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
89910: LD_ADDR_VAR 0 2
89914: PUSH
89915: LD_INT 2
89917: PUSH
89918: LD_INT 4
89920: PUSH
89921: LD_INT 5
89923: PUSH
89924: LD_INT 6
89926: PUSH
89927: LD_INT 8
89929: PUSH
89930: LD_INT 11
89932: PUSH
89933: LD_INT 12
89935: PUSH
89936: LD_INT 15
89938: PUSH
89939: LD_INT 16
89941: PUSH
89942: LD_INT 20
89944: PUSH
89945: LD_INT 21
89947: PUSH
89948: LD_INT 22
89950: PUSH
89951: LD_INT 23
89953: PUSH
89954: LD_INT 25
89956: PUSH
89957: LD_INT 26
89959: PUSH
89960: LD_INT 30
89962: PUSH
89963: LD_INT 31
89965: PUSH
89966: LD_INT 32
89968: PUSH
89969: LD_INT 36
89971: PUSH
89972: EMPTY
89973: LIST
89974: LIST
89975: LIST
89976: LIST
89977: LIST
89978: LIST
89979: LIST
89980: LIST
89981: LIST
89982: LIST
89983: LIST
89984: LIST
89985: LIST
89986: LIST
89987: LIST
89988: LIST
89989: LIST
89990: LIST
89991: LIST
89992: PUSH
89993: LD_INT 101
89995: PUSH
89996: LD_INT 102
89998: PUSH
89999: LD_INT 105
90001: PUSH
90002: LD_INT 106
90004: PUSH
90005: LD_INT 108
90007: PUSH
90008: LD_INT 109
90010: PUSH
90011: LD_INT 112
90013: PUSH
90014: LD_INT 116
90016: PUSH
90017: LD_INT 117
90019: PUSH
90020: LD_INT 118
90022: PUSH
90023: EMPTY
90024: LIST
90025: LIST
90026: LIST
90027: LIST
90028: LIST
90029: LIST
90030: LIST
90031: LIST
90032: LIST
90033: LIST
90034: PUSH
90035: EMPTY
90036: LIST
90037: LIST
90038: ST_TO_ADDR
90039: GO 92562
90041: LD_INT 7
90043: DOUBLE
90044: EQUAL
90045: IFTRUE 90049
90047: GO 90161
90049: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
90050: LD_ADDR_VAR 0 2
90054: PUSH
90055: LD_INT 2
90057: PUSH
90058: LD_INT 4
90060: PUSH
90061: LD_INT 5
90063: PUSH
90064: LD_INT 7
90066: PUSH
90067: LD_INT 11
90069: PUSH
90070: LD_INT 12
90072: PUSH
90073: LD_INT 15
90075: PUSH
90076: LD_INT 16
90078: PUSH
90079: LD_INT 20
90081: PUSH
90082: LD_INT 21
90084: PUSH
90085: LD_INT 22
90087: PUSH
90088: LD_INT 23
90090: PUSH
90091: LD_INT 25
90093: PUSH
90094: LD_INT 26
90096: PUSH
90097: EMPTY
90098: LIST
90099: LIST
90100: LIST
90101: LIST
90102: LIST
90103: LIST
90104: LIST
90105: LIST
90106: LIST
90107: LIST
90108: LIST
90109: LIST
90110: LIST
90111: LIST
90112: PUSH
90113: LD_INT 101
90115: PUSH
90116: LD_INT 102
90118: PUSH
90119: LD_INT 103
90121: PUSH
90122: LD_INT 105
90124: PUSH
90125: LD_INT 106
90127: PUSH
90128: LD_INT 108
90130: PUSH
90131: LD_INT 112
90133: PUSH
90134: LD_INT 116
90136: PUSH
90137: LD_INT 117
90139: PUSH
90140: LD_INT 118
90142: PUSH
90143: EMPTY
90144: LIST
90145: LIST
90146: LIST
90147: LIST
90148: LIST
90149: LIST
90150: LIST
90151: LIST
90152: LIST
90153: LIST
90154: PUSH
90155: EMPTY
90156: LIST
90157: LIST
90158: ST_TO_ADDR
90159: GO 92562
90161: LD_INT 8
90163: DOUBLE
90164: EQUAL
90165: IFTRUE 90169
90167: GO 90309
90169: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
90170: LD_ADDR_VAR 0 2
90174: PUSH
90175: LD_INT 2
90177: PUSH
90178: LD_INT 4
90180: PUSH
90181: LD_INT 5
90183: PUSH
90184: LD_INT 6
90186: PUSH
90187: LD_INT 7
90189: PUSH
90190: LD_INT 8
90192: PUSH
90193: LD_INT 11
90195: PUSH
90196: LD_INT 12
90198: PUSH
90199: LD_INT 15
90201: PUSH
90202: LD_INT 16
90204: PUSH
90205: LD_INT 20
90207: PUSH
90208: LD_INT 21
90210: PUSH
90211: LD_INT 22
90213: PUSH
90214: LD_INT 23
90216: PUSH
90217: LD_INT 25
90219: PUSH
90220: LD_INT 26
90222: PUSH
90223: LD_INT 30
90225: PUSH
90226: LD_INT 31
90228: PUSH
90229: LD_INT 32
90231: PUSH
90232: LD_INT 36
90234: PUSH
90235: EMPTY
90236: LIST
90237: LIST
90238: LIST
90239: LIST
90240: LIST
90241: LIST
90242: LIST
90243: LIST
90244: LIST
90245: LIST
90246: LIST
90247: LIST
90248: LIST
90249: LIST
90250: LIST
90251: LIST
90252: LIST
90253: LIST
90254: LIST
90255: LIST
90256: PUSH
90257: LD_INT 101
90259: PUSH
90260: LD_INT 102
90262: PUSH
90263: LD_INT 103
90265: PUSH
90266: LD_INT 105
90268: PUSH
90269: LD_INT 106
90271: PUSH
90272: LD_INT 108
90274: PUSH
90275: LD_INT 109
90277: PUSH
90278: LD_INT 112
90280: PUSH
90281: LD_INT 116
90283: PUSH
90284: LD_INT 117
90286: PUSH
90287: LD_INT 118
90289: PUSH
90290: EMPTY
90291: LIST
90292: LIST
90293: LIST
90294: LIST
90295: LIST
90296: LIST
90297: LIST
90298: LIST
90299: LIST
90300: LIST
90301: LIST
90302: PUSH
90303: EMPTY
90304: LIST
90305: LIST
90306: ST_TO_ADDR
90307: GO 92562
90309: LD_INT 9
90311: DOUBLE
90312: EQUAL
90313: IFTRUE 90317
90315: GO 90465
90317: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
90318: LD_ADDR_VAR 0 2
90322: PUSH
90323: LD_INT 2
90325: PUSH
90326: LD_INT 4
90328: PUSH
90329: LD_INT 5
90331: PUSH
90332: LD_INT 6
90334: PUSH
90335: LD_INT 7
90337: PUSH
90338: LD_INT 8
90340: PUSH
90341: LD_INT 11
90343: PUSH
90344: LD_INT 12
90346: PUSH
90347: LD_INT 15
90349: PUSH
90350: LD_INT 16
90352: PUSH
90353: LD_INT 20
90355: PUSH
90356: LD_INT 21
90358: PUSH
90359: LD_INT 22
90361: PUSH
90362: LD_INT 23
90364: PUSH
90365: LD_INT 25
90367: PUSH
90368: LD_INT 26
90370: PUSH
90371: LD_INT 28
90373: PUSH
90374: LD_INT 30
90376: PUSH
90377: LD_INT 31
90379: PUSH
90380: LD_INT 32
90382: PUSH
90383: LD_INT 36
90385: PUSH
90386: EMPTY
90387: LIST
90388: LIST
90389: LIST
90390: LIST
90391: LIST
90392: LIST
90393: LIST
90394: LIST
90395: LIST
90396: LIST
90397: LIST
90398: LIST
90399: LIST
90400: LIST
90401: LIST
90402: LIST
90403: LIST
90404: LIST
90405: LIST
90406: LIST
90407: LIST
90408: PUSH
90409: LD_INT 101
90411: PUSH
90412: LD_INT 102
90414: PUSH
90415: LD_INT 103
90417: PUSH
90418: LD_INT 105
90420: PUSH
90421: LD_INT 106
90423: PUSH
90424: LD_INT 108
90426: PUSH
90427: LD_INT 109
90429: PUSH
90430: LD_INT 112
90432: PUSH
90433: LD_INT 114
90435: PUSH
90436: LD_INT 116
90438: PUSH
90439: LD_INT 117
90441: PUSH
90442: LD_INT 118
90444: PUSH
90445: EMPTY
90446: LIST
90447: LIST
90448: LIST
90449: LIST
90450: LIST
90451: LIST
90452: LIST
90453: LIST
90454: LIST
90455: LIST
90456: LIST
90457: LIST
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: ST_TO_ADDR
90463: GO 92562
90465: LD_INT 10
90467: DOUBLE
90468: EQUAL
90469: IFTRUE 90473
90471: GO 90669
90473: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
90474: LD_ADDR_VAR 0 2
90478: PUSH
90479: LD_INT 2
90481: PUSH
90482: LD_INT 4
90484: PUSH
90485: LD_INT 5
90487: PUSH
90488: LD_INT 6
90490: PUSH
90491: LD_INT 7
90493: PUSH
90494: LD_INT 8
90496: PUSH
90497: LD_INT 9
90499: PUSH
90500: LD_INT 10
90502: PUSH
90503: LD_INT 11
90505: PUSH
90506: LD_INT 12
90508: PUSH
90509: LD_INT 13
90511: PUSH
90512: LD_INT 14
90514: PUSH
90515: LD_INT 15
90517: PUSH
90518: LD_INT 16
90520: PUSH
90521: LD_INT 17
90523: PUSH
90524: LD_INT 18
90526: PUSH
90527: LD_INT 19
90529: PUSH
90530: LD_INT 20
90532: PUSH
90533: LD_INT 21
90535: PUSH
90536: LD_INT 22
90538: PUSH
90539: LD_INT 23
90541: PUSH
90542: LD_INT 24
90544: PUSH
90545: LD_INT 25
90547: PUSH
90548: LD_INT 26
90550: PUSH
90551: LD_INT 28
90553: PUSH
90554: LD_INT 30
90556: PUSH
90557: LD_INT 31
90559: PUSH
90560: LD_INT 32
90562: PUSH
90563: LD_INT 36
90565: PUSH
90566: EMPTY
90567: LIST
90568: LIST
90569: LIST
90570: LIST
90571: LIST
90572: LIST
90573: LIST
90574: LIST
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: LIST
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: LIST
90589: LIST
90590: LIST
90591: LIST
90592: LIST
90593: LIST
90594: LIST
90595: LIST
90596: PUSH
90597: LD_INT 101
90599: PUSH
90600: LD_INT 102
90602: PUSH
90603: LD_INT 103
90605: PUSH
90606: LD_INT 104
90608: PUSH
90609: LD_INT 105
90611: PUSH
90612: LD_INT 106
90614: PUSH
90615: LD_INT 107
90617: PUSH
90618: LD_INT 108
90620: PUSH
90621: LD_INT 109
90623: PUSH
90624: LD_INT 110
90626: PUSH
90627: LD_INT 111
90629: PUSH
90630: LD_INT 112
90632: PUSH
90633: LD_INT 114
90635: PUSH
90636: LD_INT 116
90638: PUSH
90639: LD_INT 117
90641: PUSH
90642: LD_INT 118
90644: PUSH
90645: EMPTY
90646: LIST
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: LIST
90652: LIST
90653: LIST
90654: LIST
90655: LIST
90656: LIST
90657: LIST
90658: LIST
90659: LIST
90660: LIST
90661: LIST
90662: PUSH
90663: EMPTY
90664: LIST
90665: LIST
90666: ST_TO_ADDR
90667: GO 92562
90669: LD_INT 11
90671: DOUBLE
90672: EQUAL
90673: IFTRUE 90677
90675: GO 90881
90677: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
90678: LD_ADDR_VAR 0 2
90682: PUSH
90683: LD_INT 2
90685: PUSH
90686: LD_INT 3
90688: PUSH
90689: LD_INT 4
90691: PUSH
90692: LD_INT 5
90694: PUSH
90695: LD_INT 6
90697: PUSH
90698: LD_INT 7
90700: PUSH
90701: LD_INT 8
90703: PUSH
90704: LD_INT 9
90706: PUSH
90707: LD_INT 10
90709: PUSH
90710: LD_INT 11
90712: PUSH
90713: LD_INT 12
90715: PUSH
90716: LD_INT 13
90718: PUSH
90719: LD_INT 14
90721: PUSH
90722: LD_INT 15
90724: PUSH
90725: LD_INT 16
90727: PUSH
90728: LD_INT 17
90730: PUSH
90731: LD_INT 18
90733: PUSH
90734: LD_INT 19
90736: PUSH
90737: LD_INT 20
90739: PUSH
90740: LD_INT 21
90742: PUSH
90743: LD_INT 22
90745: PUSH
90746: LD_INT 23
90748: PUSH
90749: LD_INT 24
90751: PUSH
90752: LD_INT 25
90754: PUSH
90755: LD_INT 26
90757: PUSH
90758: LD_INT 28
90760: PUSH
90761: LD_INT 30
90763: PUSH
90764: LD_INT 31
90766: PUSH
90767: LD_INT 32
90769: PUSH
90770: LD_INT 34
90772: PUSH
90773: LD_INT 36
90775: PUSH
90776: EMPTY
90777: LIST
90778: LIST
90779: LIST
90780: LIST
90781: LIST
90782: LIST
90783: LIST
90784: LIST
90785: LIST
90786: LIST
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: LIST
90794: LIST
90795: LIST
90796: LIST
90797: LIST
90798: LIST
90799: LIST
90800: LIST
90801: LIST
90802: LIST
90803: LIST
90804: LIST
90805: LIST
90806: LIST
90807: LIST
90808: PUSH
90809: LD_INT 101
90811: PUSH
90812: LD_INT 102
90814: PUSH
90815: LD_INT 103
90817: PUSH
90818: LD_INT 104
90820: PUSH
90821: LD_INT 105
90823: PUSH
90824: LD_INT 106
90826: PUSH
90827: LD_INT 107
90829: PUSH
90830: LD_INT 108
90832: PUSH
90833: LD_INT 109
90835: PUSH
90836: LD_INT 110
90838: PUSH
90839: LD_INT 111
90841: PUSH
90842: LD_INT 112
90844: PUSH
90845: LD_INT 114
90847: PUSH
90848: LD_INT 116
90850: PUSH
90851: LD_INT 117
90853: PUSH
90854: LD_INT 118
90856: PUSH
90857: EMPTY
90858: LIST
90859: LIST
90860: LIST
90861: LIST
90862: LIST
90863: LIST
90864: LIST
90865: LIST
90866: LIST
90867: LIST
90868: LIST
90869: LIST
90870: LIST
90871: LIST
90872: LIST
90873: LIST
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: ST_TO_ADDR
90879: GO 92562
90881: LD_INT 12
90883: DOUBLE
90884: EQUAL
90885: IFTRUE 90889
90887: GO 91109
90889: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
90890: LD_ADDR_VAR 0 2
90894: PUSH
90895: LD_INT 1
90897: PUSH
90898: LD_INT 2
90900: PUSH
90901: LD_INT 3
90903: PUSH
90904: LD_INT 4
90906: PUSH
90907: LD_INT 5
90909: PUSH
90910: LD_INT 6
90912: PUSH
90913: LD_INT 7
90915: PUSH
90916: LD_INT 8
90918: PUSH
90919: LD_INT 9
90921: PUSH
90922: LD_INT 10
90924: PUSH
90925: LD_INT 11
90927: PUSH
90928: LD_INT 12
90930: PUSH
90931: LD_INT 13
90933: PUSH
90934: LD_INT 14
90936: PUSH
90937: LD_INT 15
90939: PUSH
90940: LD_INT 16
90942: PUSH
90943: LD_INT 17
90945: PUSH
90946: LD_INT 18
90948: PUSH
90949: LD_INT 19
90951: PUSH
90952: LD_INT 20
90954: PUSH
90955: LD_INT 21
90957: PUSH
90958: LD_INT 22
90960: PUSH
90961: LD_INT 23
90963: PUSH
90964: LD_INT 24
90966: PUSH
90967: LD_INT 25
90969: PUSH
90970: LD_INT 26
90972: PUSH
90973: LD_INT 27
90975: PUSH
90976: LD_INT 28
90978: PUSH
90979: LD_INT 30
90981: PUSH
90982: LD_INT 31
90984: PUSH
90985: LD_INT 32
90987: PUSH
90988: LD_INT 33
90990: PUSH
90991: LD_INT 34
90993: PUSH
90994: LD_INT 36
90996: PUSH
90997: EMPTY
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: LIST
91003: LIST
91004: LIST
91005: LIST
91006: LIST
91007: LIST
91008: LIST
91009: LIST
91010: LIST
91011: LIST
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: LIST
91017: LIST
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: LIST
91026: LIST
91027: LIST
91028: LIST
91029: LIST
91030: LIST
91031: LIST
91032: PUSH
91033: LD_INT 101
91035: PUSH
91036: LD_INT 102
91038: PUSH
91039: LD_INT 103
91041: PUSH
91042: LD_INT 104
91044: PUSH
91045: LD_INT 105
91047: PUSH
91048: LD_INT 106
91050: PUSH
91051: LD_INT 107
91053: PUSH
91054: LD_INT 108
91056: PUSH
91057: LD_INT 109
91059: PUSH
91060: LD_INT 110
91062: PUSH
91063: LD_INT 111
91065: PUSH
91066: LD_INT 112
91068: PUSH
91069: LD_INT 113
91071: PUSH
91072: LD_INT 114
91074: PUSH
91075: LD_INT 116
91077: PUSH
91078: LD_INT 117
91080: PUSH
91081: LD_INT 118
91083: PUSH
91084: EMPTY
91085: LIST
91086: LIST
91087: LIST
91088: LIST
91089: LIST
91090: LIST
91091: LIST
91092: LIST
91093: LIST
91094: LIST
91095: LIST
91096: LIST
91097: LIST
91098: LIST
91099: LIST
91100: LIST
91101: LIST
91102: PUSH
91103: EMPTY
91104: LIST
91105: LIST
91106: ST_TO_ADDR
91107: GO 92562
91109: LD_INT 13
91111: DOUBLE
91112: EQUAL
91113: IFTRUE 91117
91115: GO 91325
91117: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
91118: LD_ADDR_VAR 0 2
91122: PUSH
91123: LD_INT 1
91125: PUSH
91126: LD_INT 2
91128: PUSH
91129: LD_INT 3
91131: PUSH
91132: LD_INT 4
91134: PUSH
91135: LD_INT 5
91137: PUSH
91138: LD_INT 8
91140: PUSH
91141: LD_INT 9
91143: PUSH
91144: LD_INT 10
91146: PUSH
91147: LD_INT 11
91149: PUSH
91150: LD_INT 12
91152: PUSH
91153: LD_INT 14
91155: PUSH
91156: LD_INT 15
91158: PUSH
91159: LD_INT 16
91161: PUSH
91162: LD_INT 17
91164: PUSH
91165: LD_INT 18
91167: PUSH
91168: LD_INT 19
91170: PUSH
91171: LD_INT 20
91173: PUSH
91174: LD_INT 21
91176: PUSH
91177: LD_INT 22
91179: PUSH
91180: LD_INT 23
91182: PUSH
91183: LD_INT 24
91185: PUSH
91186: LD_INT 25
91188: PUSH
91189: LD_INT 26
91191: PUSH
91192: LD_INT 27
91194: PUSH
91195: LD_INT 28
91197: PUSH
91198: LD_INT 30
91200: PUSH
91201: LD_INT 31
91203: PUSH
91204: LD_INT 32
91206: PUSH
91207: LD_INT 33
91209: PUSH
91210: LD_INT 34
91212: PUSH
91213: LD_INT 36
91215: PUSH
91216: EMPTY
91217: LIST
91218: LIST
91219: LIST
91220: LIST
91221: LIST
91222: LIST
91223: LIST
91224: LIST
91225: LIST
91226: LIST
91227: LIST
91228: LIST
91229: LIST
91230: LIST
91231: LIST
91232: LIST
91233: LIST
91234: LIST
91235: LIST
91236: LIST
91237: LIST
91238: LIST
91239: LIST
91240: LIST
91241: LIST
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: PUSH
91249: LD_INT 101
91251: PUSH
91252: LD_INT 102
91254: PUSH
91255: LD_INT 103
91257: PUSH
91258: LD_INT 104
91260: PUSH
91261: LD_INT 105
91263: PUSH
91264: LD_INT 106
91266: PUSH
91267: LD_INT 107
91269: PUSH
91270: LD_INT 108
91272: PUSH
91273: LD_INT 109
91275: PUSH
91276: LD_INT 110
91278: PUSH
91279: LD_INT 111
91281: PUSH
91282: LD_INT 112
91284: PUSH
91285: LD_INT 113
91287: PUSH
91288: LD_INT 114
91290: PUSH
91291: LD_INT 116
91293: PUSH
91294: LD_INT 117
91296: PUSH
91297: LD_INT 118
91299: PUSH
91300: EMPTY
91301: LIST
91302: LIST
91303: LIST
91304: LIST
91305: LIST
91306: LIST
91307: LIST
91308: LIST
91309: LIST
91310: LIST
91311: LIST
91312: LIST
91313: LIST
91314: LIST
91315: LIST
91316: LIST
91317: LIST
91318: PUSH
91319: EMPTY
91320: LIST
91321: LIST
91322: ST_TO_ADDR
91323: GO 92562
91325: LD_INT 14
91327: DOUBLE
91328: EQUAL
91329: IFTRUE 91333
91331: GO 91557
91333: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
91334: LD_ADDR_VAR 0 2
91338: PUSH
91339: LD_INT 1
91341: PUSH
91342: LD_INT 2
91344: PUSH
91345: LD_INT 3
91347: PUSH
91348: LD_INT 4
91350: PUSH
91351: LD_INT 5
91353: PUSH
91354: LD_INT 6
91356: PUSH
91357: LD_INT 7
91359: PUSH
91360: LD_INT 8
91362: PUSH
91363: LD_INT 9
91365: PUSH
91366: LD_INT 10
91368: PUSH
91369: LD_INT 11
91371: PUSH
91372: LD_INT 12
91374: PUSH
91375: LD_INT 13
91377: PUSH
91378: LD_INT 14
91380: PUSH
91381: LD_INT 15
91383: PUSH
91384: LD_INT 16
91386: PUSH
91387: LD_INT 17
91389: PUSH
91390: LD_INT 18
91392: PUSH
91393: LD_INT 19
91395: PUSH
91396: LD_INT 20
91398: PUSH
91399: LD_INT 21
91401: PUSH
91402: LD_INT 22
91404: PUSH
91405: LD_INT 23
91407: PUSH
91408: LD_INT 24
91410: PUSH
91411: LD_INT 25
91413: PUSH
91414: LD_INT 26
91416: PUSH
91417: LD_INT 27
91419: PUSH
91420: LD_INT 28
91422: PUSH
91423: LD_INT 29
91425: PUSH
91426: LD_INT 30
91428: PUSH
91429: LD_INT 31
91431: PUSH
91432: LD_INT 32
91434: PUSH
91435: LD_INT 33
91437: PUSH
91438: LD_INT 34
91440: PUSH
91441: LD_INT 36
91443: PUSH
91444: EMPTY
91445: LIST
91446: LIST
91447: LIST
91448: LIST
91449: LIST
91450: LIST
91451: LIST
91452: LIST
91453: LIST
91454: LIST
91455: LIST
91456: LIST
91457: LIST
91458: LIST
91459: LIST
91460: LIST
91461: LIST
91462: LIST
91463: LIST
91464: LIST
91465: LIST
91466: LIST
91467: LIST
91468: LIST
91469: LIST
91470: LIST
91471: LIST
91472: LIST
91473: LIST
91474: LIST
91475: LIST
91476: LIST
91477: LIST
91478: LIST
91479: LIST
91480: PUSH
91481: LD_INT 101
91483: PUSH
91484: LD_INT 102
91486: PUSH
91487: LD_INT 103
91489: PUSH
91490: LD_INT 104
91492: PUSH
91493: LD_INT 105
91495: PUSH
91496: LD_INT 106
91498: PUSH
91499: LD_INT 107
91501: PUSH
91502: LD_INT 108
91504: PUSH
91505: LD_INT 109
91507: PUSH
91508: LD_INT 110
91510: PUSH
91511: LD_INT 111
91513: PUSH
91514: LD_INT 112
91516: PUSH
91517: LD_INT 113
91519: PUSH
91520: LD_INT 114
91522: PUSH
91523: LD_INT 116
91525: PUSH
91526: LD_INT 117
91528: PUSH
91529: LD_INT 118
91531: PUSH
91532: EMPTY
91533: LIST
91534: LIST
91535: LIST
91536: LIST
91537: LIST
91538: LIST
91539: LIST
91540: LIST
91541: LIST
91542: LIST
91543: LIST
91544: LIST
91545: LIST
91546: LIST
91547: LIST
91548: LIST
91549: LIST
91550: PUSH
91551: EMPTY
91552: LIST
91553: LIST
91554: ST_TO_ADDR
91555: GO 92562
91557: LD_INT 15
91559: DOUBLE
91560: EQUAL
91561: IFTRUE 91565
91563: GO 91789
91565: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
91566: LD_ADDR_VAR 0 2
91570: PUSH
91571: LD_INT 1
91573: PUSH
91574: LD_INT 2
91576: PUSH
91577: LD_INT 3
91579: PUSH
91580: LD_INT 4
91582: PUSH
91583: LD_INT 5
91585: PUSH
91586: LD_INT 6
91588: PUSH
91589: LD_INT 7
91591: PUSH
91592: LD_INT 8
91594: PUSH
91595: LD_INT 9
91597: PUSH
91598: LD_INT 10
91600: PUSH
91601: LD_INT 11
91603: PUSH
91604: LD_INT 12
91606: PUSH
91607: LD_INT 13
91609: PUSH
91610: LD_INT 14
91612: PUSH
91613: LD_INT 15
91615: PUSH
91616: LD_INT 16
91618: PUSH
91619: LD_INT 17
91621: PUSH
91622: LD_INT 18
91624: PUSH
91625: LD_INT 19
91627: PUSH
91628: LD_INT 20
91630: PUSH
91631: LD_INT 21
91633: PUSH
91634: LD_INT 22
91636: PUSH
91637: LD_INT 23
91639: PUSH
91640: LD_INT 24
91642: PUSH
91643: LD_INT 25
91645: PUSH
91646: LD_INT 26
91648: PUSH
91649: LD_INT 27
91651: PUSH
91652: LD_INT 28
91654: PUSH
91655: LD_INT 29
91657: PUSH
91658: LD_INT 30
91660: PUSH
91661: LD_INT 31
91663: PUSH
91664: LD_INT 32
91666: PUSH
91667: LD_INT 33
91669: PUSH
91670: LD_INT 34
91672: PUSH
91673: LD_INT 36
91675: PUSH
91676: EMPTY
91677: LIST
91678: LIST
91679: LIST
91680: LIST
91681: LIST
91682: LIST
91683: LIST
91684: LIST
91685: LIST
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: LIST
91698: LIST
91699: LIST
91700: LIST
91701: LIST
91702: LIST
91703: LIST
91704: LIST
91705: LIST
91706: LIST
91707: LIST
91708: LIST
91709: LIST
91710: LIST
91711: LIST
91712: PUSH
91713: LD_INT 101
91715: PUSH
91716: LD_INT 102
91718: PUSH
91719: LD_INT 103
91721: PUSH
91722: LD_INT 104
91724: PUSH
91725: LD_INT 105
91727: PUSH
91728: LD_INT 106
91730: PUSH
91731: LD_INT 107
91733: PUSH
91734: LD_INT 108
91736: PUSH
91737: LD_INT 109
91739: PUSH
91740: LD_INT 110
91742: PUSH
91743: LD_INT 111
91745: PUSH
91746: LD_INT 112
91748: PUSH
91749: LD_INT 113
91751: PUSH
91752: LD_INT 114
91754: PUSH
91755: LD_INT 116
91757: PUSH
91758: LD_INT 117
91760: PUSH
91761: LD_INT 118
91763: PUSH
91764: EMPTY
91765: LIST
91766: LIST
91767: LIST
91768: LIST
91769: LIST
91770: LIST
91771: LIST
91772: LIST
91773: LIST
91774: LIST
91775: LIST
91776: LIST
91777: LIST
91778: LIST
91779: LIST
91780: LIST
91781: LIST
91782: PUSH
91783: EMPTY
91784: LIST
91785: LIST
91786: ST_TO_ADDR
91787: GO 92562
91789: LD_INT 16
91791: DOUBLE
91792: EQUAL
91793: IFTRUE 91797
91795: GO 91933
91797: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
91798: LD_ADDR_VAR 0 2
91802: PUSH
91803: LD_INT 2
91805: PUSH
91806: LD_INT 4
91808: PUSH
91809: LD_INT 5
91811: PUSH
91812: LD_INT 7
91814: PUSH
91815: LD_INT 11
91817: PUSH
91818: LD_INT 12
91820: PUSH
91821: LD_INT 15
91823: PUSH
91824: LD_INT 16
91826: PUSH
91827: LD_INT 20
91829: PUSH
91830: LD_INT 21
91832: PUSH
91833: LD_INT 22
91835: PUSH
91836: LD_INT 23
91838: PUSH
91839: LD_INT 25
91841: PUSH
91842: LD_INT 26
91844: PUSH
91845: LD_INT 30
91847: PUSH
91848: LD_INT 31
91850: PUSH
91851: LD_INT 32
91853: PUSH
91854: LD_INT 33
91856: PUSH
91857: LD_INT 34
91859: PUSH
91860: EMPTY
91861: LIST
91862: LIST
91863: LIST
91864: LIST
91865: LIST
91866: LIST
91867: LIST
91868: LIST
91869: LIST
91870: LIST
91871: LIST
91872: LIST
91873: LIST
91874: LIST
91875: LIST
91876: LIST
91877: LIST
91878: LIST
91879: LIST
91880: PUSH
91881: LD_INT 101
91883: PUSH
91884: LD_INT 102
91886: PUSH
91887: LD_INT 103
91889: PUSH
91890: LD_INT 106
91892: PUSH
91893: LD_INT 108
91895: PUSH
91896: LD_INT 112
91898: PUSH
91899: LD_INT 113
91901: PUSH
91902: LD_INT 114
91904: PUSH
91905: LD_INT 116
91907: PUSH
91908: LD_INT 117
91910: PUSH
91911: LD_INT 118
91913: PUSH
91914: EMPTY
91915: LIST
91916: LIST
91917: LIST
91918: LIST
91919: LIST
91920: LIST
91921: LIST
91922: LIST
91923: LIST
91924: LIST
91925: LIST
91926: PUSH
91927: EMPTY
91928: LIST
91929: LIST
91930: ST_TO_ADDR
91931: GO 92562
91933: LD_INT 17
91935: DOUBLE
91936: EQUAL
91937: IFTRUE 91941
91939: GO 92165
91941: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
91942: LD_ADDR_VAR 0 2
91946: PUSH
91947: LD_INT 1
91949: PUSH
91950: LD_INT 2
91952: PUSH
91953: LD_INT 3
91955: PUSH
91956: LD_INT 4
91958: PUSH
91959: LD_INT 5
91961: PUSH
91962: LD_INT 6
91964: PUSH
91965: LD_INT 7
91967: PUSH
91968: LD_INT 8
91970: PUSH
91971: LD_INT 9
91973: PUSH
91974: LD_INT 10
91976: PUSH
91977: LD_INT 11
91979: PUSH
91980: LD_INT 12
91982: PUSH
91983: LD_INT 13
91985: PUSH
91986: LD_INT 14
91988: PUSH
91989: LD_INT 15
91991: PUSH
91992: LD_INT 16
91994: PUSH
91995: LD_INT 17
91997: PUSH
91998: LD_INT 18
92000: PUSH
92001: LD_INT 19
92003: PUSH
92004: LD_INT 20
92006: PUSH
92007: LD_INT 21
92009: PUSH
92010: LD_INT 22
92012: PUSH
92013: LD_INT 23
92015: PUSH
92016: LD_INT 24
92018: PUSH
92019: LD_INT 25
92021: PUSH
92022: LD_INT 26
92024: PUSH
92025: LD_INT 27
92027: PUSH
92028: LD_INT 28
92030: PUSH
92031: LD_INT 29
92033: PUSH
92034: LD_INT 30
92036: PUSH
92037: LD_INT 31
92039: PUSH
92040: LD_INT 32
92042: PUSH
92043: LD_INT 33
92045: PUSH
92046: LD_INT 34
92048: PUSH
92049: LD_INT 36
92051: PUSH
92052: EMPTY
92053: LIST
92054: LIST
92055: LIST
92056: LIST
92057: LIST
92058: LIST
92059: LIST
92060: LIST
92061: LIST
92062: LIST
92063: LIST
92064: LIST
92065: LIST
92066: LIST
92067: LIST
92068: LIST
92069: LIST
92070: LIST
92071: LIST
92072: LIST
92073: LIST
92074: LIST
92075: LIST
92076: LIST
92077: LIST
92078: LIST
92079: LIST
92080: LIST
92081: LIST
92082: LIST
92083: LIST
92084: LIST
92085: LIST
92086: LIST
92087: LIST
92088: PUSH
92089: LD_INT 101
92091: PUSH
92092: LD_INT 102
92094: PUSH
92095: LD_INT 103
92097: PUSH
92098: LD_INT 104
92100: PUSH
92101: LD_INT 105
92103: PUSH
92104: LD_INT 106
92106: PUSH
92107: LD_INT 107
92109: PUSH
92110: LD_INT 108
92112: PUSH
92113: LD_INT 109
92115: PUSH
92116: LD_INT 110
92118: PUSH
92119: LD_INT 111
92121: PUSH
92122: LD_INT 112
92124: PUSH
92125: LD_INT 113
92127: PUSH
92128: LD_INT 114
92130: PUSH
92131: LD_INT 116
92133: PUSH
92134: LD_INT 117
92136: PUSH
92137: LD_INT 118
92139: PUSH
92140: EMPTY
92141: LIST
92142: LIST
92143: LIST
92144: LIST
92145: LIST
92146: LIST
92147: LIST
92148: LIST
92149: LIST
92150: LIST
92151: LIST
92152: LIST
92153: LIST
92154: LIST
92155: LIST
92156: LIST
92157: LIST
92158: PUSH
92159: EMPTY
92160: LIST
92161: LIST
92162: ST_TO_ADDR
92163: GO 92562
92165: LD_INT 18
92167: DOUBLE
92168: EQUAL
92169: IFTRUE 92173
92171: GO 92321
92173: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
92174: LD_ADDR_VAR 0 2
92178: PUSH
92179: LD_INT 2
92181: PUSH
92182: LD_INT 4
92184: PUSH
92185: LD_INT 5
92187: PUSH
92188: LD_INT 7
92190: PUSH
92191: LD_INT 11
92193: PUSH
92194: LD_INT 12
92196: PUSH
92197: LD_INT 15
92199: PUSH
92200: LD_INT 16
92202: PUSH
92203: LD_INT 20
92205: PUSH
92206: LD_INT 21
92208: PUSH
92209: LD_INT 22
92211: PUSH
92212: LD_INT 23
92214: PUSH
92215: LD_INT 25
92217: PUSH
92218: LD_INT 26
92220: PUSH
92221: LD_INT 30
92223: PUSH
92224: LD_INT 31
92226: PUSH
92227: LD_INT 32
92229: PUSH
92230: LD_INT 33
92232: PUSH
92233: LD_INT 34
92235: PUSH
92236: LD_INT 35
92238: PUSH
92239: LD_INT 36
92241: PUSH
92242: EMPTY
92243: LIST
92244: LIST
92245: LIST
92246: LIST
92247: LIST
92248: LIST
92249: LIST
92250: LIST
92251: LIST
92252: LIST
92253: LIST
92254: LIST
92255: LIST
92256: LIST
92257: LIST
92258: LIST
92259: LIST
92260: LIST
92261: LIST
92262: LIST
92263: LIST
92264: PUSH
92265: LD_INT 101
92267: PUSH
92268: LD_INT 102
92270: PUSH
92271: LD_INT 103
92273: PUSH
92274: LD_INT 106
92276: PUSH
92277: LD_INT 108
92279: PUSH
92280: LD_INT 112
92282: PUSH
92283: LD_INT 113
92285: PUSH
92286: LD_INT 114
92288: PUSH
92289: LD_INT 115
92291: PUSH
92292: LD_INT 116
92294: PUSH
92295: LD_INT 117
92297: PUSH
92298: LD_INT 118
92300: PUSH
92301: EMPTY
92302: LIST
92303: LIST
92304: LIST
92305: LIST
92306: LIST
92307: LIST
92308: LIST
92309: LIST
92310: LIST
92311: LIST
92312: LIST
92313: LIST
92314: PUSH
92315: EMPTY
92316: LIST
92317: LIST
92318: ST_TO_ADDR
92319: GO 92562
92321: LD_INT 19
92323: DOUBLE
92324: EQUAL
92325: IFTRUE 92329
92327: GO 92561
92329: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
92330: LD_ADDR_VAR 0 2
92334: PUSH
92335: LD_INT 1
92337: PUSH
92338: LD_INT 2
92340: PUSH
92341: LD_INT 3
92343: PUSH
92344: LD_INT 4
92346: PUSH
92347: LD_INT 5
92349: PUSH
92350: LD_INT 6
92352: PUSH
92353: LD_INT 7
92355: PUSH
92356: LD_INT 8
92358: PUSH
92359: LD_INT 9
92361: PUSH
92362: LD_INT 10
92364: PUSH
92365: LD_INT 11
92367: PUSH
92368: LD_INT 12
92370: PUSH
92371: LD_INT 13
92373: PUSH
92374: LD_INT 14
92376: PUSH
92377: LD_INT 15
92379: PUSH
92380: LD_INT 16
92382: PUSH
92383: LD_INT 17
92385: PUSH
92386: LD_INT 18
92388: PUSH
92389: LD_INT 19
92391: PUSH
92392: LD_INT 20
92394: PUSH
92395: LD_INT 21
92397: PUSH
92398: LD_INT 22
92400: PUSH
92401: LD_INT 23
92403: PUSH
92404: LD_INT 24
92406: PUSH
92407: LD_INT 25
92409: PUSH
92410: LD_INT 26
92412: PUSH
92413: LD_INT 27
92415: PUSH
92416: LD_INT 28
92418: PUSH
92419: LD_INT 29
92421: PUSH
92422: LD_INT 30
92424: PUSH
92425: LD_INT 31
92427: PUSH
92428: LD_INT 32
92430: PUSH
92431: LD_INT 33
92433: PUSH
92434: LD_INT 34
92436: PUSH
92437: LD_INT 35
92439: PUSH
92440: LD_INT 36
92442: PUSH
92443: EMPTY
92444: LIST
92445: LIST
92446: LIST
92447: LIST
92448: LIST
92449: LIST
92450: LIST
92451: LIST
92452: LIST
92453: LIST
92454: LIST
92455: LIST
92456: LIST
92457: LIST
92458: LIST
92459: LIST
92460: LIST
92461: LIST
92462: LIST
92463: LIST
92464: LIST
92465: LIST
92466: LIST
92467: LIST
92468: LIST
92469: LIST
92470: LIST
92471: LIST
92472: LIST
92473: LIST
92474: LIST
92475: LIST
92476: LIST
92477: LIST
92478: LIST
92479: LIST
92480: PUSH
92481: LD_INT 101
92483: PUSH
92484: LD_INT 102
92486: PUSH
92487: LD_INT 103
92489: PUSH
92490: LD_INT 104
92492: PUSH
92493: LD_INT 105
92495: PUSH
92496: LD_INT 106
92498: PUSH
92499: LD_INT 107
92501: PUSH
92502: LD_INT 108
92504: PUSH
92505: LD_INT 109
92507: PUSH
92508: LD_INT 110
92510: PUSH
92511: LD_INT 111
92513: PUSH
92514: LD_INT 112
92516: PUSH
92517: LD_INT 113
92519: PUSH
92520: LD_INT 114
92522: PUSH
92523: LD_INT 115
92525: PUSH
92526: LD_INT 116
92528: PUSH
92529: LD_INT 117
92531: PUSH
92532: LD_INT 118
92534: PUSH
92535: EMPTY
92536: LIST
92537: LIST
92538: LIST
92539: LIST
92540: LIST
92541: LIST
92542: LIST
92543: LIST
92544: LIST
92545: LIST
92546: LIST
92547: LIST
92548: LIST
92549: LIST
92550: LIST
92551: LIST
92552: LIST
92553: LIST
92554: PUSH
92555: EMPTY
92556: LIST
92557: LIST
92558: ST_TO_ADDR
92559: GO 92562
92561: POP
// end else
92562: GO 92793
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
92564: LD_ADDR_VAR 0 2
92568: PUSH
92569: LD_INT 1
92571: PUSH
92572: LD_INT 2
92574: PUSH
92575: LD_INT 3
92577: PUSH
92578: LD_INT 4
92580: PUSH
92581: LD_INT 5
92583: PUSH
92584: LD_INT 6
92586: PUSH
92587: LD_INT 7
92589: PUSH
92590: LD_INT 8
92592: PUSH
92593: LD_INT 9
92595: PUSH
92596: LD_INT 10
92598: PUSH
92599: LD_INT 11
92601: PUSH
92602: LD_INT 12
92604: PUSH
92605: LD_INT 13
92607: PUSH
92608: LD_INT 14
92610: PUSH
92611: LD_INT 15
92613: PUSH
92614: LD_INT 16
92616: PUSH
92617: LD_INT 17
92619: PUSH
92620: LD_INT 18
92622: PUSH
92623: LD_INT 19
92625: PUSH
92626: LD_INT 20
92628: PUSH
92629: LD_INT 21
92631: PUSH
92632: LD_INT 22
92634: PUSH
92635: LD_INT 23
92637: PUSH
92638: LD_INT 24
92640: PUSH
92641: LD_INT 25
92643: PUSH
92644: LD_INT 26
92646: PUSH
92647: LD_INT 27
92649: PUSH
92650: LD_INT 28
92652: PUSH
92653: LD_INT 29
92655: PUSH
92656: LD_INT 30
92658: PUSH
92659: LD_INT 31
92661: PUSH
92662: LD_INT 32
92664: PUSH
92665: LD_INT 33
92667: PUSH
92668: LD_INT 34
92670: PUSH
92671: LD_INT 35
92673: PUSH
92674: LD_INT 36
92676: PUSH
92677: EMPTY
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: LIST
92683: LIST
92684: LIST
92685: LIST
92686: LIST
92687: LIST
92688: LIST
92689: LIST
92690: LIST
92691: LIST
92692: LIST
92693: LIST
92694: LIST
92695: LIST
92696: LIST
92697: LIST
92698: LIST
92699: LIST
92700: LIST
92701: LIST
92702: LIST
92703: LIST
92704: LIST
92705: LIST
92706: LIST
92707: LIST
92708: LIST
92709: LIST
92710: LIST
92711: LIST
92712: LIST
92713: LIST
92714: PUSH
92715: LD_INT 101
92717: PUSH
92718: LD_INT 102
92720: PUSH
92721: LD_INT 103
92723: PUSH
92724: LD_INT 104
92726: PUSH
92727: LD_INT 105
92729: PUSH
92730: LD_INT 106
92732: PUSH
92733: LD_INT 107
92735: PUSH
92736: LD_INT 108
92738: PUSH
92739: LD_INT 109
92741: PUSH
92742: LD_INT 110
92744: PUSH
92745: LD_INT 111
92747: PUSH
92748: LD_INT 112
92750: PUSH
92751: LD_INT 113
92753: PUSH
92754: LD_INT 114
92756: PUSH
92757: LD_INT 115
92759: PUSH
92760: LD_INT 116
92762: PUSH
92763: LD_INT 117
92765: PUSH
92766: LD_INT 118
92768: PUSH
92769: EMPTY
92770: LIST
92771: LIST
92772: LIST
92773: LIST
92774: LIST
92775: LIST
92776: LIST
92777: LIST
92778: LIST
92779: LIST
92780: LIST
92781: LIST
92782: LIST
92783: LIST
92784: LIST
92785: LIST
92786: LIST
92787: LIST
92788: PUSH
92789: EMPTY
92790: LIST
92791: LIST
92792: ST_TO_ADDR
// if result then
92793: LD_VAR 0 2
92797: IFFALSE 93583
// begin normal :=  ;
92799: LD_ADDR_VAR 0 5
92803: PUSH
92804: LD_STRING 
92806: ST_TO_ADDR
// hardcore :=  ;
92807: LD_ADDR_VAR 0 6
92811: PUSH
92812: LD_STRING 
92814: ST_TO_ADDR
// active :=  ;
92815: LD_ADDR_VAR 0 7
92819: PUSH
92820: LD_STRING 
92822: ST_TO_ADDR
// for i = 1 to normalCounter do
92823: LD_ADDR_VAR 0 8
92827: PUSH
92828: DOUBLE
92829: LD_INT 1
92831: DEC
92832: ST_TO_ADDR
92833: LD_EXP 108
92837: PUSH
92838: FOR_TO
92839: IFFALSE 92940
// begin tmp := 0 ;
92841: LD_ADDR_VAR 0 3
92845: PUSH
92846: LD_STRING 0
92848: ST_TO_ADDR
// if result [ 1 ] then
92849: LD_VAR 0 2
92853: PUSH
92854: LD_INT 1
92856: ARRAY
92857: IFFALSE 92922
// if result [ 1 ] [ 1 ] = i then
92859: LD_VAR 0 2
92863: PUSH
92864: LD_INT 1
92866: ARRAY
92867: PUSH
92868: LD_INT 1
92870: ARRAY
92871: PUSH
92872: LD_VAR 0 8
92876: EQUAL
92877: IFFALSE 92922
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
92879: LD_ADDR_VAR 0 2
92883: PUSH
92884: LD_VAR 0 2
92888: PPUSH
92889: LD_INT 1
92891: PPUSH
92892: LD_VAR 0 2
92896: PUSH
92897: LD_INT 1
92899: ARRAY
92900: PPUSH
92901: LD_INT 1
92903: PPUSH
92904: CALL_OW 3
92908: PPUSH
92909: CALL_OW 1
92913: ST_TO_ADDR
// tmp := 1 ;
92914: LD_ADDR_VAR 0 3
92918: PUSH
92919: LD_STRING 1
92921: ST_TO_ADDR
// end ; normal := normal & tmp ;
92922: LD_ADDR_VAR 0 5
92926: PUSH
92927: LD_VAR 0 5
92931: PUSH
92932: LD_VAR 0 3
92936: STR
92937: ST_TO_ADDR
// end ;
92938: GO 92838
92940: POP
92941: POP
// for i = 1 to hardcoreCounter do
92942: LD_ADDR_VAR 0 8
92946: PUSH
92947: DOUBLE
92948: LD_INT 1
92950: DEC
92951: ST_TO_ADDR
92952: LD_EXP 109
92956: PUSH
92957: FOR_TO
92958: IFFALSE 93063
// begin tmp := 0 ;
92960: LD_ADDR_VAR 0 3
92964: PUSH
92965: LD_STRING 0
92967: ST_TO_ADDR
// if result [ 2 ] then
92968: LD_VAR 0 2
92972: PUSH
92973: LD_INT 2
92975: ARRAY
92976: IFFALSE 93045
// if result [ 2 ] [ 1 ] = 100 + i then
92978: LD_VAR 0 2
92982: PUSH
92983: LD_INT 2
92985: ARRAY
92986: PUSH
92987: LD_INT 1
92989: ARRAY
92990: PUSH
92991: LD_INT 100
92993: PUSH
92994: LD_VAR 0 8
92998: PLUS
92999: EQUAL
93000: IFFALSE 93045
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
93002: LD_ADDR_VAR 0 2
93006: PUSH
93007: LD_VAR 0 2
93011: PPUSH
93012: LD_INT 2
93014: PPUSH
93015: LD_VAR 0 2
93019: PUSH
93020: LD_INT 2
93022: ARRAY
93023: PPUSH
93024: LD_INT 1
93026: PPUSH
93027: CALL_OW 3
93031: PPUSH
93032: CALL_OW 1
93036: ST_TO_ADDR
// tmp := 1 ;
93037: LD_ADDR_VAR 0 3
93041: PUSH
93042: LD_STRING 1
93044: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
93045: LD_ADDR_VAR 0 6
93049: PUSH
93050: LD_VAR 0 6
93054: PUSH
93055: LD_VAR 0 3
93059: STR
93060: ST_TO_ADDR
// end ;
93061: GO 92957
93063: POP
93064: POP
// if isGameLoad then
93065: LD_VAR 0 1
93069: IFFALSE 93544
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
93071: LD_ADDR_VAR 0 4
93075: PUSH
93076: LD_EXP 112
93080: PUSH
93081: LD_EXP 111
93085: PUSH
93086: LD_EXP 113
93090: PUSH
93091: LD_EXP 110
93095: PUSH
93096: LD_EXP 114
93100: PUSH
93101: LD_EXP 115
93105: PUSH
93106: LD_EXP 116
93110: PUSH
93111: LD_EXP 117
93115: PUSH
93116: LD_EXP 118
93120: PUSH
93121: LD_EXP 119
93125: PUSH
93126: LD_EXP 120
93130: PUSH
93131: LD_EXP 121
93135: PUSH
93136: LD_EXP 122
93140: PUSH
93141: LD_EXP 123
93145: PUSH
93146: LD_EXP 131
93150: PUSH
93151: LD_EXP 132
93155: PUSH
93156: LD_EXP 133
93160: PUSH
93161: LD_EXP 134
93165: PUSH
93166: LD_EXP 136
93170: PUSH
93171: LD_EXP 137
93175: PUSH
93176: LD_EXP 138
93180: PUSH
93181: LD_EXP 141
93185: PUSH
93186: LD_EXP 143
93190: PUSH
93191: LD_EXP 144
93195: PUSH
93196: LD_EXP 145
93200: PUSH
93201: LD_EXP 147
93205: PUSH
93206: LD_EXP 148
93210: PUSH
93211: LD_EXP 151
93215: PUSH
93216: LD_EXP 152
93220: PUSH
93221: LD_EXP 153
93225: PUSH
93226: LD_EXP 154
93230: PUSH
93231: LD_EXP 155
93235: PUSH
93236: LD_EXP 156
93240: PUSH
93241: LD_EXP 157
93245: PUSH
93246: LD_EXP 158
93250: PUSH
93251: LD_EXP 159
93255: PUSH
93256: LD_EXP 124
93260: PUSH
93261: LD_EXP 125
93265: PUSH
93266: LD_EXP 128
93270: PUSH
93271: LD_EXP 129
93275: PUSH
93276: LD_EXP 130
93280: PUSH
93281: LD_EXP 126
93285: PUSH
93286: LD_EXP 127
93290: PUSH
93291: LD_EXP 135
93295: PUSH
93296: LD_EXP 139
93300: PUSH
93301: LD_EXP 140
93305: PUSH
93306: LD_EXP 142
93310: PUSH
93311: LD_EXP 146
93315: PUSH
93316: LD_EXP 149
93320: PUSH
93321: LD_EXP 150
93325: PUSH
93326: LD_EXP 160
93330: PUSH
93331: LD_EXP 161
93335: PUSH
93336: LD_EXP 162
93340: PUSH
93341: LD_EXP 163
93345: PUSH
93346: EMPTY
93347: LIST
93348: LIST
93349: LIST
93350: LIST
93351: LIST
93352: LIST
93353: LIST
93354: LIST
93355: LIST
93356: LIST
93357: LIST
93358: LIST
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: LIST
93376: LIST
93377: LIST
93378: LIST
93379: LIST
93380: LIST
93381: LIST
93382: LIST
93383: LIST
93384: LIST
93385: LIST
93386: LIST
93387: LIST
93388: LIST
93389: LIST
93390: LIST
93391: LIST
93392: LIST
93393: LIST
93394: LIST
93395: LIST
93396: LIST
93397: LIST
93398: LIST
93399: LIST
93400: LIST
93401: ST_TO_ADDR
// tmp :=  ;
93402: LD_ADDR_VAR 0 3
93406: PUSH
93407: LD_STRING 
93409: ST_TO_ADDR
// for i = 1 to normalCounter do
93410: LD_ADDR_VAR 0 8
93414: PUSH
93415: DOUBLE
93416: LD_INT 1
93418: DEC
93419: ST_TO_ADDR
93420: LD_EXP 108
93424: PUSH
93425: FOR_TO
93426: IFFALSE 93462
// begin if flags [ i ] then
93428: LD_VAR 0 4
93432: PUSH
93433: LD_VAR 0 8
93437: ARRAY
93438: IFFALSE 93460
// tmp := tmp & i & ; ;
93440: LD_ADDR_VAR 0 3
93444: PUSH
93445: LD_VAR 0 3
93449: PUSH
93450: LD_VAR 0 8
93454: STR
93455: PUSH
93456: LD_STRING ;
93458: STR
93459: ST_TO_ADDR
// end ;
93460: GO 93425
93462: POP
93463: POP
// for i = 1 to hardcoreCounter do
93464: LD_ADDR_VAR 0 8
93468: PUSH
93469: DOUBLE
93470: LD_INT 1
93472: DEC
93473: ST_TO_ADDR
93474: LD_EXP 109
93478: PUSH
93479: FOR_TO
93480: IFFALSE 93526
// begin if flags [ normalCounter + i ] then
93482: LD_VAR 0 4
93486: PUSH
93487: LD_EXP 108
93491: PUSH
93492: LD_VAR 0 8
93496: PLUS
93497: ARRAY
93498: IFFALSE 93524
// tmp := tmp & ( 100 + i ) & ; ;
93500: LD_ADDR_VAR 0 3
93504: PUSH
93505: LD_VAR 0 3
93509: PUSH
93510: LD_INT 100
93512: PUSH
93513: LD_VAR 0 8
93517: PLUS
93518: STR
93519: PUSH
93520: LD_STRING ;
93522: STR
93523: ST_TO_ADDR
// end ;
93524: GO 93479
93526: POP
93527: POP
// if tmp then
93528: LD_VAR 0 3
93532: IFFALSE 93544
// active := tmp ;
93534: LD_ADDR_VAR 0 7
93538: PUSH
93539: LD_VAR 0 3
93543: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
93544: LD_STRING getStreamItemsFromMission("
93546: PUSH
93547: LD_VAR 0 5
93551: STR
93552: PUSH
93553: LD_STRING ","
93555: STR
93556: PUSH
93557: LD_VAR 0 6
93561: STR
93562: PUSH
93563: LD_STRING ","
93565: STR
93566: PUSH
93567: LD_VAR 0 7
93571: STR
93572: PUSH
93573: LD_STRING ")
93575: STR
93576: PPUSH
93577: CALL_OW 559
// end else
93581: GO 93590
// ToLua ( getStreamItemsFromMission("","","") ) ;
93583: LD_STRING getStreamItemsFromMission("","","")
93585: PPUSH
93586: CALL_OW 559
// end ;
93590: LD_VAR 0 2
93594: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
93595: LD_EXP 107
93599: PUSH
93600: LD_EXP 112
93604: AND
93605: IFFALSE 93729
93607: GO 93609
93609: DISABLE
93610: LD_INT 0
93612: PPUSH
93613: PPUSH
// begin enable ;
93614: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
93615: LD_ADDR_VAR 0 2
93619: PUSH
93620: LD_INT 22
93622: PUSH
93623: LD_OWVAR 2
93627: PUSH
93628: EMPTY
93629: LIST
93630: LIST
93631: PUSH
93632: LD_INT 2
93634: PUSH
93635: LD_INT 34
93637: PUSH
93638: LD_INT 7
93640: PUSH
93641: EMPTY
93642: LIST
93643: LIST
93644: PUSH
93645: LD_INT 34
93647: PUSH
93648: LD_INT 45
93650: PUSH
93651: EMPTY
93652: LIST
93653: LIST
93654: PUSH
93655: LD_INT 34
93657: PUSH
93658: LD_INT 28
93660: PUSH
93661: EMPTY
93662: LIST
93663: LIST
93664: PUSH
93665: LD_INT 34
93667: PUSH
93668: LD_INT 47
93670: PUSH
93671: EMPTY
93672: LIST
93673: LIST
93674: PUSH
93675: EMPTY
93676: LIST
93677: LIST
93678: LIST
93679: LIST
93680: LIST
93681: PUSH
93682: EMPTY
93683: LIST
93684: LIST
93685: PPUSH
93686: CALL_OW 69
93690: ST_TO_ADDR
// if not tmp then
93691: LD_VAR 0 2
93695: NOT
93696: IFFALSE 93700
// exit ;
93698: GO 93729
// for i in tmp do
93700: LD_ADDR_VAR 0 1
93704: PUSH
93705: LD_VAR 0 2
93709: PUSH
93710: FOR_IN
93711: IFFALSE 93727
// begin SetLives ( i , 0 ) ;
93713: LD_VAR 0 1
93717: PPUSH
93718: LD_INT 0
93720: PPUSH
93721: CALL_OW 234
// end ;
93725: GO 93710
93727: POP
93728: POP
// end ;
93729: PPOPN 2
93731: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
93732: LD_EXP 107
93736: PUSH
93737: LD_EXP 113
93741: AND
93742: IFFALSE 93826
93744: GO 93746
93746: DISABLE
93747: LD_INT 0
93749: PPUSH
93750: PPUSH
// begin enable ;
93751: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
93752: LD_ADDR_VAR 0 2
93756: PUSH
93757: LD_INT 22
93759: PUSH
93760: LD_OWVAR 2
93764: PUSH
93765: EMPTY
93766: LIST
93767: LIST
93768: PUSH
93769: LD_INT 32
93771: PUSH
93772: LD_INT 3
93774: PUSH
93775: EMPTY
93776: LIST
93777: LIST
93778: PUSH
93779: EMPTY
93780: LIST
93781: LIST
93782: PPUSH
93783: CALL_OW 69
93787: ST_TO_ADDR
// if not tmp then
93788: LD_VAR 0 2
93792: NOT
93793: IFFALSE 93797
// exit ;
93795: GO 93826
// for i in tmp do
93797: LD_ADDR_VAR 0 1
93801: PUSH
93802: LD_VAR 0 2
93806: PUSH
93807: FOR_IN
93808: IFFALSE 93824
// begin SetLives ( i , 0 ) ;
93810: LD_VAR 0 1
93814: PPUSH
93815: LD_INT 0
93817: PPUSH
93818: CALL_OW 234
// end ;
93822: GO 93807
93824: POP
93825: POP
// end ;
93826: PPOPN 2
93828: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
93829: LD_EXP 107
93833: PUSH
93834: LD_EXP 110
93838: AND
93839: IFFALSE 93932
93841: GO 93843
93843: DISABLE
93844: LD_INT 0
93846: PPUSH
// begin enable ;
93847: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
93848: LD_ADDR_VAR 0 1
93852: PUSH
93853: LD_INT 22
93855: PUSH
93856: LD_OWVAR 2
93860: PUSH
93861: EMPTY
93862: LIST
93863: LIST
93864: PUSH
93865: LD_INT 2
93867: PUSH
93868: LD_INT 25
93870: PUSH
93871: LD_INT 5
93873: PUSH
93874: EMPTY
93875: LIST
93876: LIST
93877: PUSH
93878: LD_INT 25
93880: PUSH
93881: LD_INT 9
93883: PUSH
93884: EMPTY
93885: LIST
93886: LIST
93887: PUSH
93888: LD_INT 25
93890: PUSH
93891: LD_INT 8
93893: PUSH
93894: EMPTY
93895: LIST
93896: LIST
93897: PUSH
93898: EMPTY
93899: LIST
93900: LIST
93901: LIST
93902: LIST
93903: PUSH
93904: EMPTY
93905: LIST
93906: LIST
93907: PPUSH
93908: CALL_OW 69
93912: PUSH
93913: FOR_IN
93914: IFFALSE 93930
// begin SetClass ( i , 1 ) ;
93916: LD_VAR 0 1
93920: PPUSH
93921: LD_INT 1
93923: PPUSH
93924: CALL_OW 336
// end ;
93928: GO 93913
93930: POP
93931: POP
// end ;
93932: PPOPN 1
93934: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
93935: LD_EXP 107
93939: PUSH
93940: LD_EXP 111
93944: AND
93945: PUSH
93946: LD_OWVAR 65
93950: PUSH
93951: LD_INT 7
93953: LESS
93954: AND
93955: IFFALSE 93969
93957: GO 93959
93959: DISABLE
// begin enable ;
93960: ENABLE
// game_speed := 7 ;
93961: LD_ADDR_OWVAR 65
93965: PUSH
93966: LD_INT 7
93968: ST_TO_ADDR
// end ;
93969: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
93970: LD_EXP 107
93974: PUSH
93975: LD_EXP 114
93979: AND
93980: IFFALSE 94182
93982: GO 93984
93984: DISABLE
93985: LD_INT 0
93987: PPUSH
93988: PPUSH
93989: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
93990: LD_ADDR_VAR 0 3
93994: PUSH
93995: LD_INT 81
93997: PUSH
93998: LD_OWVAR 2
94002: PUSH
94003: EMPTY
94004: LIST
94005: LIST
94006: PUSH
94007: LD_INT 21
94009: PUSH
94010: LD_INT 1
94012: PUSH
94013: EMPTY
94014: LIST
94015: LIST
94016: PUSH
94017: EMPTY
94018: LIST
94019: LIST
94020: PPUSH
94021: CALL_OW 69
94025: ST_TO_ADDR
// if not tmp then
94026: LD_VAR 0 3
94030: NOT
94031: IFFALSE 94035
// exit ;
94033: GO 94182
// if tmp > 5 then
94035: LD_VAR 0 3
94039: PUSH
94040: LD_INT 5
94042: GREATER
94043: IFFALSE 94055
// k := 5 else
94045: LD_ADDR_VAR 0 2
94049: PUSH
94050: LD_INT 5
94052: ST_TO_ADDR
94053: GO 94065
// k := tmp ;
94055: LD_ADDR_VAR 0 2
94059: PUSH
94060: LD_VAR 0 3
94064: ST_TO_ADDR
// for i := 1 to k do
94065: LD_ADDR_VAR 0 1
94069: PUSH
94070: DOUBLE
94071: LD_INT 1
94073: DEC
94074: ST_TO_ADDR
94075: LD_VAR 0 2
94079: PUSH
94080: FOR_TO
94081: IFFALSE 94180
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
94083: LD_VAR 0 3
94087: PUSH
94088: LD_VAR 0 1
94092: ARRAY
94093: PPUSH
94094: LD_VAR 0 1
94098: PUSH
94099: LD_INT 4
94101: MOD
94102: PUSH
94103: LD_INT 1
94105: PLUS
94106: PPUSH
94107: CALL_OW 259
94111: PUSH
94112: LD_INT 10
94114: LESS
94115: IFFALSE 94178
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
94117: LD_VAR 0 3
94121: PUSH
94122: LD_VAR 0 1
94126: ARRAY
94127: PPUSH
94128: LD_VAR 0 1
94132: PUSH
94133: LD_INT 4
94135: MOD
94136: PUSH
94137: LD_INT 1
94139: PLUS
94140: PPUSH
94141: LD_VAR 0 3
94145: PUSH
94146: LD_VAR 0 1
94150: ARRAY
94151: PPUSH
94152: LD_VAR 0 1
94156: PUSH
94157: LD_INT 4
94159: MOD
94160: PUSH
94161: LD_INT 1
94163: PLUS
94164: PPUSH
94165: CALL_OW 259
94169: PUSH
94170: LD_INT 1
94172: PLUS
94173: PPUSH
94174: CALL_OW 237
94178: GO 94080
94180: POP
94181: POP
// end ;
94182: PPOPN 3
94184: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
94185: LD_EXP 107
94189: PUSH
94190: LD_EXP 115
94194: AND
94195: IFFALSE 94215
94197: GO 94199
94199: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
94200: LD_INT 4
94202: PPUSH
94203: LD_OWVAR 2
94207: PPUSH
94208: LD_INT 0
94210: PPUSH
94211: CALL_OW 324
94215: END
// every 0 0$1 trigger StreamModeActive and sShovel do
94216: LD_EXP 107
94220: PUSH
94221: LD_EXP 144
94225: AND
94226: IFFALSE 94246
94228: GO 94230
94230: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
94231: LD_INT 19
94233: PPUSH
94234: LD_OWVAR 2
94238: PPUSH
94239: LD_INT 0
94241: PPUSH
94242: CALL_OW 324
94246: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
94247: LD_EXP 107
94251: PUSH
94252: LD_EXP 116
94256: AND
94257: IFFALSE 94359
94259: GO 94261
94261: DISABLE
94262: LD_INT 0
94264: PPUSH
94265: PPUSH
// begin enable ;
94266: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
94267: LD_ADDR_VAR 0 2
94271: PUSH
94272: LD_INT 22
94274: PUSH
94275: LD_OWVAR 2
94279: PUSH
94280: EMPTY
94281: LIST
94282: LIST
94283: PUSH
94284: LD_INT 2
94286: PUSH
94287: LD_INT 34
94289: PUSH
94290: LD_INT 11
94292: PUSH
94293: EMPTY
94294: LIST
94295: LIST
94296: PUSH
94297: LD_INT 34
94299: PUSH
94300: LD_INT 30
94302: PUSH
94303: EMPTY
94304: LIST
94305: LIST
94306: PUSH
94307: EMPTY
94308: LIST
94309: LIST
94310: LIST
94311: PUSH
94312: EMPTY
94313: LIST
94314: LIST
94315: PPUSH
94316: CALL_OW 69
94320: ST_TO_ADDR
// if not tmp then
94321: LD_VAR 0 2
94325: NOT
94326: IFFALSE 94330
// exit ;
94328: GO 94359
// for i in tmp do
94330: LD_ADDR_VAR 0 1
94334: PUSH
94335: LD_VAR 0 2
94339: PUSH
94340: FOR_IN
94341: IFFALSE 94357
// begin SetLives ( i , 0 ) ;
94343: LD_VAR 0 1
94347: PPUSH
94348: LD_INT 0
94350: PPUSH
94351: CALL_OW 234
// end ;
94355: GO 94340
94357: POP
94358: POP
// end ;
94359: PPOPN 2
94361: END
// every 0 0$1 trigger StreamModeActive and sBunker do
94362: LD_EXP 107
94366: PUSH
94367: LD_EXP 117
94371: AND
94372: IFFALSE 94392
94374: GO 94376
94376: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
94377: LD_INT 32
94379: PPUSH
94380: LD_OWVAR 2
94384: PPUSH
94385: LD_INT 0
94387: PPUSH
94388: CALL_OW 324
94392: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
94393: LD_EXP 107
94397: PUSH
94398: LD_EXP 118
94402: AND
94403: IFFALSE 94584
94405: GO 94407
94407: DISABLE
94408: LD_INT 0
94410: PPUSH
94411: PPUSH
94412: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
94413: LD_ADDR_VAR 0 2
94417: PUSH
94418: LD_INT 22
94420: PUSH
94421: LD_OWVAR 2
94425: PUSH
94426: EMPTY
94427: LIST
94428: LIST
94429: PUSH
94430: LD_INT 33
94432: PUSH
94433: LD_INT 3
94435: PUSH
94436: EMPTY
94437: LIST
94438: LIST
94439: PUSH
94440: EMPTY
94441: LIST
94442: LIST
94443: PPUSH
94444: CALL_OW 69
94448: ST_TO_ADDR
// if not tmp then
94449: LD_VAR 0 2
94453: NOT
94454: IFFALSE 94458
// exit ;
94456: GO 94584
// side := 0 ;
94458: LD_ADDR_VAR 0 3
94462: PUSH
94463: LD_INT 0
94465: ST_TO_ADDR
// for i := 1 to 8 do
94466: LD_ADDR_VAR 0 1
94470: PUSH
94471: DOUBLE
94472: LD_INT 1
94474: DEC
94475: ST_TO_ADDR
94476: LD_INT 8
94478: PUSH
94479: FOR_TO
94480: IFFALSE 94528
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
94482: LD_OWVAR 2
94486: PUSH
94487: LD_VAR 0 1
94491: NONEQUAL
94492: PUSH
94493: LD_OWVAR 2
94497: PPUSH
94498: LD_VAR 0 1
94502: PPUSH
94503: CALL_OW 81
94507: PUSH
94508: LD_INT 2
94510: EQUAL
94511: AND
94512: IFFALSE 94526
// begin side := i ;
94514: LD_ADDR_VAR 0 3
94518: PUSH
94519: LD_VAR 0 1
94523: ST_TO_ADDR
// break ;
94524: GO 94528
// end ;
94526: GO 94479
94528: POP
94529: POP
// if not side then
94530: LD_VAR 0 3
94534: NOT
94535: IFFALSE 94539
// exit ;
94537: GO 94584
// for i := 1 to tmp do
94539: LD_ADDR_VAR 0 1
94543: PUSH
94544: DOUBLE
94545: LD_INT 1
94547: DEC
94548: ST_TO_ADDR
94549: LD_VAR 0 2
94553: PUSH
94554: FOR_TO
94555: IFFALSE 94582
// if Prob ( 60 ) then
94557: LD_INT 60
94559: PPUSH
94560: CALL_OW 13
94564: IFFALSE 94580
// SetSide ( i , side ) ;
94566: LD_VAR 0 1
94570: PPUSH
94571: LD_VAR 0 3
94575: PPUSH
94576: CALL_OW 235
94580: GO 94554
94582: POP
94583: POP
// end ;
94584: PPOPN 3
94586: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
94587: LD_EXP 107
94591: PUSH
94592: LD_EXP 120
94596: AND
94597: IFFALSE 94716
94599: GO 94601
94601: DISABLE
94602: LD_INT 0
94604: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
94605: LD_ADDR_VAR 0 1
94609: PUSH
94610: LD_INT 22
94612: PUSH
94613: LD_OWVAR 2
94617: PUSH
94618: EMPTY
94619: LIST
94620: LIST
94621: PUSH
94622: LD_INT 21
94624: PUSH
94625: LD_INT 1
94627: PUSH
94628: EMPTY
94629: LIST
94630: LIST
94631: PUSH
94632: LD_INT 3
94634: PUSH
94635: LD_INT 23
94637: PUSH
94638: LD_INT 0
94640: PUSH
94641: EMPTY
94642: LIST
94643: LIST
94644: PUSH
94645: EMPTY
94646: LIST
94647: LIST
94648: PUSH
94649: EMPTY
94650: LIST
94651: LIST
94652: LIST
94653: PPUSH
94654: CALL_OW 69
94658: PUSH
94659: FOR_IN
94660: IFFALSE 94714
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
94662: LD_VAR 0 1
94666: PPUSH
94667: CALL_OW 257
94671: PUSH
94672: LD_INT 1
94674: PUSH
94675: LD_INT 2
94677: PUSH
94678: LD_INT 3
94680: PUSH
94681: LD_INT 4
94683: PUSH
94684: EMPTY
94685: LIST
94686: LIST
94687: LIST
94688: LIST
94689: IN
94690: IFFALSE 94712
// SetClass ( un , rand ( 1 , 4 ) ) ;
94692: LD_VAR 0 1
94696: PPUSH
94697: LD_INT 1
94699: PPUSH
94700: LD_INT 4
94702: PPUSH
94703: CALL_OW 12
94707: PPUSH
94708: CALL_OW 336
94712: GO 94659
94714: POP
94715: POP
// end ;
94716: PPOPN 1
94718: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
94719: LD_EXP 107
94723: PUSH
94724: LD_EXP 119
94728: AND
94729: IFFALSE 94808
94731: GO 94733
94733: DISABLE
94734: LD_INT 0
94736: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94737: LD_ADDR_VAR 0 1
94741: PUSH
94742: LD_INT 22
94744: PUSH
94745: LD_OWVAR 2
94749: PUSH
94750: EMPTY
94751: LIST
94752: LIST
94753: PUSH
94754: LD_INT 21
94756: PUSH
94757: LD_INT 3
94759: PUSH
94760: EMPTY
94761: LIST
94762: LIST
94763: PUSH
94764: EMPTY
94765: LIST
94766: LIST
94767: PPUSH
94768: CALL_OW 69
94772: ST_TO_ADDR
// if not tmp then
94773: LD_VAR 0 1
94777: NOT
94778: IFFALSE 94782
// exit ;
94780: GO 94808
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
94782: LD_VAR 0 1
94786: PUSH
94787: LD_INT 1
94789: PPUSH
94790: LD_VAR 0 1
94794: PPUSH
94795: CALL_OW 12
94799: ARRAY
94800: PPUSH
94801: LD_INT 100
94803: PPUSH
94804: CALL_OW 234
// end ;
94808: PPOPN 1
94810: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
94811: LD_EXP 107
94815: PUSH
94816: LD_EXP 121
94820: AND
94821: IFFALSE 94919
94823: GO 94825
94825: DISABLE
94826: LD_INT 0
94828: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94829: LD_ADDR_VAR 0 1
94833: PUSH
94834: LD_INT 22
94836: PUSH
94837: LD_OWVAR 2
94841: PUSH
94842: EMPTY
94843: LIST
94844: LIST
94845: PUSH
94846: LD_INT 21
94848: PUSH
94849: LD_INT 1
94851: PUSH
94852: EMPTY
94853: LIST
94854: LIST
94855: PUSH
94856: EMPTY
94857: LIST
94858: LIST
94859: PPUSH
94860: CALL_OW 69
94864: ST_TO_ADDR
// if not tmp then
94865: LD_VAR 0 1
94869: NOT
94870: IFFALSE 94874
// exit ;
94872: GO 94919
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
94874: LD_VAR 0 1
94878: PUSH
94879: LD_INT 1
94881: PPUSH
94882: LD_VAR 0 1
94886: PPUSH
94887: CALL_OW 12
94891: ARRAY
94892: PPUSH
94893: LD_INT 1
94895: PPUSH
94896: LD_INT 4
94898: PPUSH
94899: CALL_OW 12
94903: PPUSH
94904: LD_INT 3000
94906: PPUSH
94907: LD_INT 9000
94909: PPUSH
94910: CALL_OW 12
94914: PPUSH
94915: CALL_OW 492
// end ;
94919: PPOPN 1
94921: END
// every 0 0$1 trigger StreamModeActive and sDepot do
94922: LD_EXP 107
94926: PUSH
94927: LD_EXP 122
94931: AND
94932: IFFALSE 94952
94934: GO 94936
94936: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
94937: LD_INT 1
94939: PPUSH
94940: LD_OWVAR 2
94944: PPUSH
94945: LD_INT 0
94947: PPUSH
94948: CALL_OW 324
94952: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
94953: LD_EXP 107
94957: PUSH
94958: LD_EXP 123
94962: AND
94963: IFFALSE 95046
94965: GO 94967
94967: DISABLE
94968: LD_INT 0
94970: PPUSH
94971: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94972: LD_ADDR_VAR 0 2
94976: PUSH
94977: LD_INT 22
94979: PUSH
94980: LD_OWVAR 2
94984: PUSH
94985: EMPTY
94986: LIST
94987: LIST
94988: PUSH
94989: LD_INT 21
94991: PUSH
94992: LD_INT 3
94994: PUSH
94995: EMPTY
94996: LIST
94997: LIST
94998: PUSH
94999: EMPTY
95000: LIST
95001: LIST
95002: PPUSH
95003: CALL_OW 69
95007: ST_TO_ADDR
// if not tmp then
95008: LD_VAR 0 2
95012: NOT
95013: IFFALSE 95017
// exit ;
95015: GO 95046
// for i in tmp do
95017: LD_ADDR_VAR 0 1
95021: PUSH
95022: LD_VAR 0 2
95026: PUSH
95027: FOR_IN
95028: IFFALSE 95044
// SetBLevel ( i , 10 ) ;
95030: LD_VAR 0 1
95034: PPUSH
95035: LD_INT 10
95037: PPUSH
95038: CALL_OW 241
95042: GO 95027
95044: POP
95045: POP
// end ;
95046: PPOPN 2
95048: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
95049: LD_EXP 107
95053: PUSH
95054: LD_EXP 124
95058: AND
95059: IFFALSE 95170
95061: GO 95063
95063: DISABLE
95064: LD_INT 0
95066: PPUSH
95067: PPUSH
95068: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95069: LD_ADDR_VAR 0 3
95073: PUSH
95074: LD_INT 22
95076: PUSH
95077: LD_OWVAR 2
95081: PUSH
95082: EMPTY
95083: LIST
95084: LIST
95085: PUSH
95086: LD_INT 25
95088: PUSH
95089: LD_INT 1
95091: PUSH
95092: EMPTY
95093: LIST
95094: LIST
95095: PUSH
95096: EMPTY
95097: LIST
95098: LIST
95099: PPUSH
95100: CALL_OW 69
95104: ST_TO_ADDR
// if not tmp then
95105: LD_VAR 0 3
95109: NOT
95110: IFFALSE 95114
// exit ;
95112: GO 95170
// un := tmp [ rand ( 1 , tmp ) ] ;
95114: LD_ADDR_VAR 0 2
95118: PUSH
95119: LD_VAR 0 3
95123: PUSH
95124: LD_INT 1
95126: PPUSH
95127: LD_VAR 0 3
95131: PPUSH
95132: CALL_OW 12
95136: ARRAY
95137: ST_TO_ADDR
// if Crawls ( un ) then
95138: LD_VAR 0 2
95142: PPUSH
95143: CALL_OW 318
95147: IFFALSE 95158
// ComWalk ( un ) ;
95149: LD_VAR 0 2
95153: PPUSH
95154: CALL_OW 138
// SetClass ( un , class_sniper ) ;
95158: LD_VAR 0 2
95162: PPUSH
95163: LD_INT 5
95165: PPUSH
95166: CALL_OW 336
// end ;
95170: PPOPN 3
95172: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
95173: LD_EXP 107
95177: PUSH
95178: LD_EXP 125
95182: AND
95183: PUSH
95184: LD_OWVAR 67
95188: PUSH
95189: LD_INT 4
95191: LESS
95192: AND
95193: IFFALSE 95212
95195: GO 95197
95197: DISABLE
// begin Difficulty := Difficulty + 1 ;
95198: LD_ADDR_OWVAR 67
95202: PUSH
95203: LD_OWVAR 67
95207: PUSH
95208: LD_INT 1
95210: PLUS
95211: ST_TO_ADDR
// end ;
95212: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
95213: LD_EXP 107
95217: PUSH
95218: LD_EXP 126
95222: AND
95223: IFFALSE 95326
95225: GO 95227
95227: DISABLE
95228: LD_INT 0
95230: PPUSH
// begin for i := 1 to 5 do
95231: LD_ADDR_VAR 0 1
95235: PUSH
95236: DOUBLE
95237: LD_INT 1
95239: DEC
95240: ST_TO_ADDR
95241: LD_INT 5
95243: PUSH
95244: FOR_TO
95245: IFFALSE 95324
// begin uc_nation := nation_nature ;
95247: LD_ADDR_OWVAR 21
95251: PUSH
95252: LD_INT 0
95254: ST_TO_ADDR
// uc_side := 0 ;
95255: LD_ADDR_OWVAR 20
95259: PUSH
95260: LD_INT 0
95262: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95263: LD_ADDR_OWVAR 29
95267: PUSH
95268: LD_INT 12
95270: PUSH
95271: LD_INT 12
95273: PUSH
95274: EMPTY
95275: LIST
95276: LIST
95277: ST_TO_ADDR
// hc_agressivity := 20 ;
95278: LD_ADDR_OWVAR 35
95282: PUSH
95283: LD_INT 20
95285: ST_TO_ADDR
// hc_class := class_tiger ;
95286: LD_ADDR_OWVAR 28
95290: PUSH
95291: LD_INT 14
95293: ST_TO_ADDR
// hc_gallery :=  ;
95294: LD_ADDR_OWVAR 33
95298: PUSH
95299: LD_STRING 
95301: ST_TO_ADDR
// hc_name :=  ;
95302: LD_ADDR_OWVAR 26
95306: PUSH
95307: LD_STRING 
95309: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
95310: CALL_OW 44
95314: PPUSH
95315: LD_INT 0
95317: PPUSH
95318: CALL_OW 51
// end ;
95322: GO 95244
95324: POP
95325: POP
// end ;
95326: PPOPN 1
95328: END
// every 0 0$1 trigger StreamModeActive and sBomb do
95329: LD_EXP 107
95333: PUSH
95334: LD_EXP 127
95338: AND
95339: IFFALSE 95348
95341: GO 95343
95343: DISABLE
// StreamSibBomb ;
95344: CALL 95349 0 0
95348: END
// export function StreamSibBomb ; var i , x , y ; begin
95349: LD_INT 0
95351: PPUSH
95352: PPUSH
95353: PPUSH
95354: PPUSH
// result := false ;
95355: LD_ADDR_VAR 0 1
95359: PUSH
95360: LD_INT 0
95362: ST_TO_ADDR
// for i := 1 to 16 do
95363: LD_ADDR_VAR 0 2
95367: PUSH
95368: DOUBLE
95369: LD_INT 1
95371: DEC
95372: ST_TO_ADDR
95373: LD_INT 16
95375: PUSH
95376: FOR_TO
95377: IFFALSE 95576
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95379: LD_ADDR_VAR 0 3
95383: PUSH
95384: LD_INT 10
95386: PUSH
95387: LD_INT 20
95389: PUSH
95390: LD_INT 30
95392: PUSH
95393: LD_INT 40
95395: PUSH
95396: LD_INT 50
95398: PUSH
95399: LD_INT 60
95401: PUSH
95402: LD_INT 70
95404: PUSH
95405: LD_INT 80
95407: PUSH
95408: LD_INT 90
95410: PUSH
95411: LD_INT 100
95413: PUSH
95414: LD_INT 110
95416: PUSH
95417: LD_INT 120
95419: PUSH
95420: LD_INT 130
95422: PUSH
95423: LD_INT 140
95425: PUSH
95426: LD_INT 150
95428: PUSH
95429: EMPTY
95430: LIST
95431: LIST
95432: LIST
95433: LIST
95434: LIST
95435: LIST
95436: LIST
95437: LIST
95438: LIST
95439: LIST
95440: LIST
95441: LIST
95442: LIST
95443: LIST
95444: LIST
95445: PUSH
95446: LD_INT 1
95448: PPUSH
95449: LD_INT 15
95451: PPUSH
95452: CALL_OW 12
95456: ARRAY
95457: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95458: LD_ADDR_VAR 0 4
95462: PUSH
95463: LD_INT 10
95465: PUSH
95466: LD_INT 20
95468: PUSH
95469: LD_INT 30
95471: PUSH
95472: LD_INT 40
95474: PUSH
95475: LD_INT 50
95477: PUSH
95478: LD_INT 60
95480: PUSH
95481: LD_INT 70
95483: PUSH
95484: LD_INT 80
95486: PUSH
95487: LD_INT 90
95489: PUSH
95490: LD_INT 100
95492: PUSH
95493: LD_INT 110
95495: PUSH
95496: LD_INT 120
95498: PUSH
95499: LD_INT 130
95501: PUSH
95502: LD_INT 140
95504: PUSH
95505: LD_INT 150
95507: PUSH
95508: EMPTY
95509: LIST
95510: LIST
95511: LIST
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: PUSH
95525: LD_INT 1
95527: PPUSH
95528: LD_INT 15
95530: PPUSH
95531: CALL_OW 12
95535: ARRAY
95536: ST_TO_ADDR
// if ValidHex ( x , y ) then
95537: LD_VAR 0 3
95541: PPUSH
95542: LD_VAR 0 4
95546: PPUSH
95547: CALL_OW 488
95551: IFFALSE 95574
// begin result := [ x , y ] ;
95553: LD_ADDR_VAR 0 1
95557: PUSH
95558: LD_VAR 0 3
95562: PUSH
95563: LD_VAR 0 4
95567: PUSH
95568: EMPTY
95569: LIST
95570: LIST
95571: ST_TO_ADDR
// break ;
95572: GO 95576
// end ; end ;
95574: GO 95376
95576: POP
95577: POP
// if result then
95578: LD_VAR 0 1
95582: IFFALSE 95642
// begin ToLua ( playSibBomb() ) ;
95584: LD_STRING playSibBomb()
95586: PPUSH
95587: CALL_OW 559
// wait ( 0 0$14 ) ;
95591: LD_INT 490
95593: PPUSH
95594: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
95598: LD_VAR 0 1
95602: PUSH
95603: LD_INT 1
95605: ARRAY
95606: PPUSH
95607: LD_VAR 0 1
95611: PUSH
95612: LD_INT 2
95614: ARRAY
95615: PPUSH
95616: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
95620: LD_VAR 0 1
95624: PUSH
95625: LD_INT 1
95627: ARRAY
95628: PPUSH
95629: LD_VAR 0 1
95633: PUSH
95634: LD_INT 2
95636: ARRAY
95637: PPUSH
95638: CALL_OW 429
// end ; end ;
95642: LD_VAR 0 1
95646: RET
// every 0 0$1 trigger StreamModeActive and sReset do
95647: LD_EXP 107
95651: PUSH
95652: LD_EXP 129
95656: AND
95657: IFFALSE 95669
95659: GO 95661
95661: DISABLE
// YouLost (  ) ;
95662: LD_STRING 
95664: PPUSH
95665: CALL_OW 104
95669: END
// every 0 0$1 trigger StreamModeActive and sFog do
95670: LD_EXP 107
95674: PUSH
95675: LD_EXP 128
95679: AND
95680: IFFALSE 95694
95682: GO 95684
95684: DISABLE
// FogOff ( your_side ) ;
95685: LD_OWVAR 2
95689: PPUSH
95690: CALL_OW 344
95694: END
// every 0 0$1 trigger StreamModeActive and sSun do
95695: LD_EXP 107
95699: PUSH
95700: LD_EXP 130
95704: AND
95705: IFFALSE 95733
95707: GO 95709
95709: DISABLE
// begin solar_recharge_percent := 0 ;
95710: LD_ADDR_OWVAR 79
95714: PUSH
95715: LD_INT 0
95717: ST_TO_ADDR
// wait ( 5 5$00 ) ;
95718: LD_INT 10500
95720: PPUSH
95721: CALL_OW 67
// solar_recharge_percent := 100 ;
95725: LD_ADDR_OWVAR 79
95729: PUSH
95730: LD_INT 100
95732: ST_TO_ADDR
// end ;
95733: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
95734: LD_EXP 107
95738: PUSH
95739: LD_EXP 131
95743: AND
95744: IFFALSE 95983
95746: GO 95748
95748: DISABLE
95749: LD_INT 0
95751: PPUSH
95752: PPUSH
95753: PPUSH
// begin tmp := [ ] ;
95754: LD_ADDR_VAR 0 3
95758: PUSH
95759: EMPTY
95760: ST_TO_ADDR
// for i := 1 to 6 do
95761: LD_ADDR_VAR 0 1
95765: PUSH
95766: DOUBLE
95767: LD_INT 1
95769: DEC
95770: ST_TO_ADDR
95771: LD_INT 6
95773: PUSH
95774: FOR_TO
95775: IFFALSE 95880
// begin uc_nation := nation_nature ;
95777: LD_ADDR_OWVAR 21
95781: PUSH
95782: LD_INT 0
95784: ST_TO_ADDR
// uc_side := 0 ;
95785: LD_ADDR_OWVAR 20
95789: PUSH
95790: LD_INT 0
95792: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95793: LD_ADDR_OWVAR 29
95797: PUSH
95798: LD_INT 12
95800: PUSH
95801: LD_INT 12
95803: PUSH
95804: EMPTY
95805: LIST
95806: LIST
95807: ST_TO_ADDR
// hc_agressivity := 20 ;
95808: LD_ADDR_OWVAR 35
95812: PUSH
95813: LD_INT 20
95815: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
95816: LD_ADDR_OWVAR 28
95820: PUSH
95821: LD_INT 17
95823: ST_TO_ADDR
// hc_gallery :=  ;
95824: LD_ADDR_OWVAR 33
95828: PUSH
95829: LD_STRING 
95831: ST_TO_ADDR
// hc_name :=  ;
95832: LD_ADDR_OWVAR 26
95836: PUSH
95837: LD_STRING 
95839: ST_TO_ADDR
// un := CreateHuman ;
95840: LD_ADDR_VAR 0 2
95844: PUSH
95845: CALL_OW 44
95849: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
95850: LD_VAR 0 2
95854: PPUSH
95855: LD_INT 1
95857: PPUSH
95858: CALL_OW 51
// tmp := tmp ^ un ;
95862: LD_ADDR_VAR 0 3
95866: PUSH
95867: LD_VAR 0 3
95871: PUSH
95872: LD_VAR 0 2
95876: ADD
95877: ST_TO_ADDR
// end ;
95878: GO 95774
95880: POP
95881: POP
// repeat wait ( 0 0$1 ) ;
95882: LD_INT 35
95884: PPUSH
95885: CALL_OW 67
// for un in tmp do
95889: LD_ADDR_VAR 0 2
95893: PUSH
95894: LD_VAR 0 3
95898: PUSH
95899: FOR_IN
95900: IFFALSE 95974
// begin if IsDead ( un ) then
95902: LD_VAR 0 2
95906: PPUSH
95907: CALL_OW 301
95911: IFFALSE 95931
// begin tmp := tmp diff un ;
95913: LD_ADDR_VAR 0 3
95917: PUSH
95918: LD_VAR 0 3
95922: PUSH
95923: LD_VAR 0 2
95927: DIFF
95928: ST_TO_ADDR
// continue ;
95929: GO 95899
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
95931: LD_VAR 0 2
95935: PPUSH
95936: LD_INT 3
95938: PUSH
95939: LD_INT 22
95941: PUSH
95942: LD_INT 0
95944: PUSH
95945: EMPTY
95946: LIST
95947: LIST
95948: PUSH
95949: EMPTY
95950: LIST
95951: LIST
95952: PPUSH
95953: CALL_OW 69
95957: PPUSH
95958: LD_VAR 0 2
95962: PPUSH
95963: CALL_OW 74
95967: PPUSH
95968: CALL_OW 115
// end ;
95972: GO 95899
95974: POP
95975: POP
// until not tmp ;
95976: LD_VAR 0 3
95980: NOT
95981: IFFALSE 95882
// end ;
95983: PPOPN 3
95985: END
// every 0 0$1 trigger StreamModeActive and sTroll do
95986: LD_EXP 107
95990: PUSH
95991: LD_EXP 132
95995: AND
95996: IFFALSE 96050
95998: GO 96000
96000: DISABLE
// begin ToLua ( displayTroll(); ) ;
96001: LD_STRING displayTroll();
96003: PPUSH
96004: CALL_OW 559
// wait ( 3 3$00 ) ;
96008: LD_INT 6300
96010: PPUSH
96011: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96015: LD_STRING hideTroll();
96017: PPUSH
96018: CALL_OW 559
// wait ( 1 1$00 ) ;
96022: LD_INT 2100
96024: PPUSH
96025: CALL_OW 67
// ToLua ( displayTroll(); ) ;
96029: LD_STRING displayTroll();
96031: PPUSH
96032: CALL_OW 559
// wait ( 1 1$00 ) ;
96036: LD_INT 2100
96038: PPUSH
96039: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96043: LD_STRING hideTroll();
96045: PPUSH
96046: CALL_OW 559
// end ;
96050: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
96051: LD_EXP 107
96055: PUSH
96056: LD_EXP 133
96060: AND
96061: IFFALSE 96124
96063: GO 96065
96065: DISABLE
96066: LD_INT 0
96068: PPUSH
// begin p := 0 ;
96069: LD_ADDR_VAR 0 1
96073: PUSH
96074: LD_INT 0
96076: ST_TO_ADDR
// repeat game_speed := 1 ;
96077: LD_ADDR_OWVAR 65
96081: PUSH
96082: LD_INT 1
96084: ST_TO_ADDR
// wait ( 0 0$1 ) ;
96085: LD_INT 35
96087: PPUSH
96088: CALL_OW 67
// p := p + 1 ;
96092: LD_ADDR_VAR 0 1
96096: PUSH
96097: LD_VAR 0 1
96101: PUSH
96102: LD_INT 1
96104: PLUS
96105: ST_TO_ADDR
// until p >= 60 ;
96106: LD_VAR 0 1
96110: PUSH
96111: LD_INT 60
96113: GREATEREQUAL
96114: IFFALSE 96077
// game_speed := 4 ;
96116: LD_ADDR_OWVAR 65
96120: PUSH
96121: LD_INT 4
96123: ST_TO_ADDR
// end ;
96124: PPOPN 1
96126: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
96127: LD_EXP 107
96131: PUSH
96132: LD_EXP 134
96136: AND
96137: IFFALSE 96283
96139: GO 96141
96141: DISABLE
96142: LD_INT 0
96144: PPUSH
96145: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96146: LD_ADDR_VAR 0 1
96150: PUSH
96151: LD_INT 22
96153: PUSH
96154: LD_OWVAR 2
96158: PUSH
96159: EMPTY
96160: LIST
96161: LIST
96162: PUSH
96163: LD_INT 2
96165: PUSH
96166: LD_INT 30
96168: PUSH
96169: LD_INT 0
96171: PUSH
96172: EMPTY
96173: LIST
96174: LIST
96175: PUSH
96176: LD_INT 30
96178: PUSH
96179: LD_INT 1
96181: PUSH
96182: EMPTY
96183: LIST
96184: LIST
96185: PUSH
96186: EMPTY
96187: LIST
96188: LIST
96189: LIST
96190: PUSH
96191: EMPTY
96192: LIST
96193: LIST
96194: PPUSH
96195: CALL_OW 69
96199: ST_TO_ADDR
// if not depot then
96200: LD_VAR 0 1
96204: NOT
96205: IFFALSE 96209
// exit ;
96207: GO 96283
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
96209: LD_ADDR_VAR 0 2
96213: PUSH
96214: LD_VAR 0 1
96218: PUSH
96219: LD_INT 1
96221: PPUSH
96222: LD_VAR 0 1
96226: PPUSH
96227: CALL_OW 12
96231: ARRAY
96232: PPUSH
96233: CALL_OW 274
96237: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
96238: LD_VAR 0 2
96242: PPUSH
96243: LD_INT 1
96245: PPUSH
96246: LD_INT 0
96248: PPUSH
96249: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
96253: LD_VAR 0 2
96257: PPUSH
96258: LD_INT 2
96260: PPUSH
96261: LD_INT 0
96263: PPUSH
96264: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
96268: LD_VAR 0 2
96272: PPUSH
96273: LD_INT 3
96275: PPUSH
96276: LD_INT 0
96278: PPUSH
96279: CALL_OW 277
// end ;
96283: PPOPN 2
96285: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
96286: LD_EXP 107
96290: PUSH
96291: LD_EXP 135
96295: AND
96296: IFFALSE 96393
96298: GO 96300
96300: DISABLE
96301: LD_INT 0
96303: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96304: LD_ADDR_VAR 0 1
96308: PUSH
96309: LD_INT 22
96311: PUSH
96312: LD_OWVAR 2
96316: PUSH
96317: EMPTY
96318: LIST
96319: LIST
96320: PUSH
96321: LD_INT 21
96323: PUSH
96324: LD_INT 1
96326: PUSH
96327: EMPTY
96328: LIST
96329: LIST
96330: PUSH
96331: LD_INT 3
96333: PUSH
96334: LD_INT 23
96336: PUSH
96337: LD_INT 0
96339: PUSH
96340: EMPTY
96341: LIST
96342: LIST
96343: PUSH
96344: EMPTY
96345: LIST
96346: LIST
96347: PUSH
96348: EMPTY
96349: LIST
96350: LIST
96351: LIST
96352: PPUSH
96353: CALL_OW 69
96357: ST_TO_ADDR
// if not tmp then
96358: LD_VAR 0 1
96362: NOT
96363: IFFALSE 96367
// exit ;
96365: GO 96393
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
96367: LD_VAR 0 1
96371: PUSH
96372: LD_INT 1
96374: PPUSH
96375: LD_VAR 0 1
96379: PPUSH
96380: CALL_OW 12
96384: ARRAY
96385: PPUSH
96386: LD_INT 200
96388: PPUSH
96389: CALL_OW 234
// end ;
96393: PPOPN 1
96395: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
96396: LD_EXP 107
96400: PUSH
96401: LD_EXP 136
96405: AND
96406: IFFALSE 96485
96408: GO 96410
96410: DISABLE
96411: LD_INT 0
96413: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
96414: LD_ADDR_VAR 0 1
96418: PUSH
96419: LD_INT 22
96421: PUSH
96422: LD_OWVAR 2
96426: PUSH
96427: EMPTY
96428: LIST
96429: LIST
96430: PUSH
96431: LD_INT 21
96433: PUSH
96434: LD_INT 2
96436: PUSH
96437: EMPTY
96438: LIST
96439: LIST
96440: PUSH
96441: EMPTY
96442: LIST
96443: LIST
96444: PPUSH
96445: CALL_OW 69
96449: ST_TO_ADDR
// if not tmp then
96450: LD_VAR 0 1
96454: NOT
96455: IFFALSE 96459
// exit ;
96457: GO 96485
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
96459: LD_VAR 0 1
96463: PUSH
96464: LD_INT 1
96466: PPUSH
96467: LD_VAR 0 1
96471: PPUSH
96472: CALL_OW 12
96476: ARRAY
96477: PPUSH
96478: LD_INT 60
96480: PPUSH
96481: CALL_OW 234
// end ;
96485: PPOPN 1
96487: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
96488: LD_EXP 107
96492: PUSH
96493: LD_EXP 137
96497: AND
96498: IFFALSE 96597
96500: GO 96502
96502: DISABLE
96503: LD_INT 0
96505: PPUSH
96506: PPUSH
// begin enable ;
96507: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
96508: LD_ADDR_VAR 0 1
96512: PUSH
96513: LD_INT 22
96515: PUSH
96516: LD_OWVAR 2
96520: PUSH
96521: EMPTY
96522: LIST
96523: LIST
96524: PUSH
96525: LD_INT 61
96527: PUSH
96528: EMPTY
96529: LIST
96530: PUSH
96531: LD_INT 33
96533: PUSH
96534: LD_INT 2
96536: PUSH
96537: EMPTY
96538: LIST
96539: LIST
96540: PUSH
96541: EMPTY
96542: LIST
96543: LIST
96544: LIST
96545: PPUSH
96546: CALL_OW 69
96550: ST_TO_ADDR
// if not tmp then
96551: LD_VAR 0 1
96555: NOT
96556: IFFALSE 96560
// exit ;
96558: GO 96597
// for i in tmp do
96560: LD_ADDR_VAR 0 2
96564: PUSH
96565: LD_VAR 0 1
96569: PUSH
96570: FOR_IN
96571: IFFALSE 96595
// if IsControledBy ( i ) then
96573: LD_VAR 0 2
96577: PPUSH
96578: CALL_OW 312
96582: IFFALSE 96593
// ComUnlink ( i ) ;
96584: LD_VAR 0 2
96588: PPUSH
96589: CALL_OW 136
96593: GO 96570
96595: POP
96596: POP
// end ;
96597: PPOPN 2
96599: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
96600: LD_EXP 107
96604: PUSH
96605: LD_EXP 138
96609: AND
96610: IFFALSE 96750
96612: GO 96614
96614: DISABLE
96615: LD_INT 0
96617: PPUSH
96618: PPUSH
// begin ToLua ( displayPowell(); ) ;
96619: LD_STRING displayPowell();
96621: PPUSH
96622: CALL_OW 559
// uc_side := 0 ;
96626: LD_ADDR_OWVAR 20
96630: PUSH
96631: LD_INT 0
96633: ST_TO_ADDR
// uc_nation := 2 ;
96634: LD_ADDR_OWVAR 21
96638: PUSH
96639: LD_INT 2
96641: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
96642: LD_ADDR_OWVAR 37
96646: PUSH
96647: LD_INT 14
96649: ST_TO_ADDR
// vc_engine := engine_siberite ;
96650: LD_ADDR_OWVAR 39
96654: PUSH
96655: LD_INT 3
96657: ST_TO_ADDR
// vc_control := control_apeman ;
96658: LD_ADDR_OWVAR 38
96662: PUSH
96663: LD_INT 5
96665: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
96666: LD_ADDR_OWVAR 40
96670: PUSH
96671: LD_INT 29
96673: ST_TO_ADDR
// un := CreateVehicle ;
96674: LD_ADDR_VAR 0 2
96678: PUSH
96679: CALL_OW 45
96683: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96684: LD_VAR 0 2
96688: PPUSH
96689: LD_INT 1
96691: PPUSH
96692: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96696: LD_INT 35
96698: PPUSH
96699: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96703: LD_VAR 0 2
96707: PPUSH
96708: LD_INT 22
96710: PUSH
96711: LD_OWVAR 2
96715: PUSH
96716: EMPTY
96717: LIST
96718: LIST
96719: PPUSH
96720: CALL_OW 69
96724: PPUSH
96725: LD_VAR 0 2
96729: PPUSH
96730: CALL_OW 74
96734: PPUSH
96735: CALL_OW 115
// until IsDead ( un ) ;
96739: LD_VAR 0 2
96743: PPUSH
96744: CALL_OW 301
96748: IFFALSE 96696
// end ;
96750: PPOPN 2
96752: END
// every 0 0$1 trigger StreamModeActive and sStu do
96753: LD_EXP 107
96757: PUSH
96758: LD_EXP 146
96762: AND
96763: IFFALSE 96779
96765: GO 96767
96767: DISABLE
// begin ToLua ( displayStucuk(); ) ;
96768: LD_STRING displayStucuk();
96770: PPUSH
96771: CALL_OW 559
// ResetFog ;
96775: CALL_OW 335
// end ;
96779: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
96780: LD_EXP 107
96784: PUSH
96785: LD_EXP 139
96789: AND
96790: IFFALSE 96931
96792: GO 96794
96794: DISABLE
96795: LD_INT 0
96797: PPUSH
96798: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96799: LD_ADDR_VAR 0 2
96803: PUSH
96804: LD_INT 22
96806: PUSH
96807: LD_OWVAR 2
96811: PUSH
96812: EMPTY
96813: LIST
96814: LIST
96815: PUSH
96816: LD_INT 21
96818: PUSH
96819: LD_INT 1
96821: PUSH
96822: EMPTY
96823: LIST
96824: LIST
96825: PUSH
96826: EMPTY
96827: LIST
96828: LIST
96829: PPUSH
96830: CALL_OW 69
96834: ST_TO_ADDR
// if not tmp then
96835: LD_VAR 0 2
96839: NOT
96840: IFFALSE 96844
// exit ;
96842: GO 96931
// un := tmp [ rand ( 1 , tmp ) ] ;
96844: LD_ADDR_VAR 0 1
96848: PUSH
96849: LD_VAR 0 2
96853: PUSH
96854: LD_INT 1
96856: PPUSH
96857: LD_VAR 0 2
96861: PPUSH
96862: CALL_OW 12
96866: ARRAY
96867: ST_TO_ADDR
// SetSide ( un , 0 ) ;
96868: LD_VAR 0 1
96872: PPUSH
96873: LD_INT 0
96875: PPUSH
96876: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
96880: LD_VAR 0 1
96884: PPUSH
96885: LD_OWVAR 3
96889: PUSH
96890: LD_VAR 0 1
96894: DIFF
96895: PPUSH
96896: LD_VAR 0 1
96900: PPUSH
96901: CALL_OW 74
96905: PPUSH
96906: CALL_OW 115
// wait ( 0 0$20 ) ;
96910: LD_INT 700
96912: PPUSH
96913: CALL_OW 67
// SetSide ( un , your_side ) ;
96917: LD_VAR 0 1
96921: PPUSH
96922: LD_OWVAR 2
96926: PPUSH
96927: CALL_OW 235
// end ;
96931: PPOPN 2
96933: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
96934: LD_EXP 107
96938: PUSH
96939: LD_EXP 140
96943: AND
96944: IFFALSE 97050
96946: GO 96948
96948: DISABLE
96949: LD_INT 0
96951: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96952: LD_ADDR_VAR 0 1
96956: PUSH
96957: LD_INT 22
96959: PUSH
96960: LD_OWVAR 2
96964: PUSH
96965: EMPTY
96966: LIST
96967: LIST
96968: PUSH
96969: LD_INT 2
96971: PUSH
96972: LD_INT 30
96974: PUSH
96975: LD_INT 0
96977: PUSH
96978: EMPTY
96979: LIST
96980: LIST
96981: PUSH
96982: LD_INT 30
96984: PUSH
96985: LD_INT 1
96987: PUSH
96988: EMPTY
96989: LIST
96990: LIST
96991: PUSH
96992: EMPTY
96993: LIST
96994: LIST
96995: LIST
96996: PUSH
96997: EMPTY
96998: LIST
96999: LIST
97000: PPUSH
97001: CALL_OW 69
97005: ST_TO_ADDR
// if not depot then
97006: LD_VAR 0 1
97010: NOT
97011: IFFALSE 97015
// exit ;
97013: GO 97050
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
97015: LD_VAR 0 1
97019: PUSH
97020: LD_INT 1
97022: ARRAY
97023: PPUSH
97024: CALL_OW 250
97028: PPUSH
97029: LD_VAR 0 1
97033: PUSH
97034: LD_INT 1
97036: ARRAY
97037: PPUSH
97038: CALL_OW 251
97042: PPUSH
97043: LD_INT 70
97045: PPUSH
97046: CALL_OW 495
// end ;
97050: PPOPN 1
97052: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
97053: LD_EXP 107
97057: PUSH
97058: LD_EXP 141
97062: AND
97063: IFFALSE 97274
97065: GO 97067
97067: DISABLE
97068: LD_INT 0
97070: PPUSH
97071: PPUSH
97072: PPUSH
97073: PPUSH
97074: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97075: LD_ADDR_VAR 0 5
97079: PUSH
97080: LD_INT 22
97082: PUSH
97083: LD_OWVAR 2
97087: PUSH
97088: EMPTY
97089: LIST
97090: LIST
97091: PUSH
97092: LD_INT 21
97094: PUSH
97095: LD_INT 1
97097: PUSH
97098: EMPTY
97099: LIST
97100: LIST
97101: PUSH
97102: EMPTY
97103: LIST
97104: LIST
97105: PPUSH
97106: CALL_OW 69
97110: ST_TO_ADDR
// if not tmp then
97111: LD_VAR 0 5
97115: NOT
97116: IFFALSE 97120
// exit ;
97118: GO 97274
// for i in tmp do
97120: LD_ADDR_VAR 0 1
97124: PUSH
97125: LD_VAR 0 5
97129: PUSH
97130: FOR_IN
97131: IFFALSE 97272
// begin d := rand ( 0 , 5 ) ;
97133: LD_ADDR_VAR 0 4
97137: PUSH
97138: LD_INT 0
97140: PPUSH
97141: LD_INT 5
97143: PPUSH
97144: CALL_OW 12
97148: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
97149: LD_ADDR_VAR 0 2
97153: PUSH
97154: LD_VAR 0 1
97158: PPUSH
97159: CALL_OW 250
97163: PPUSH
97164: LD_VAR 0 4
97168: PPUSH
97169: LD_INT 3
97171: PPUSH
97172: LD_INT 12
97174: PPUSH
97175: CALL_OW 12
97179: PPUSH
97180: CALL_OW 272
97184: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
97185: LD_ADDR_VAR 0 3
97189: PUSH
97190: LD_VAR 0 1
97194: PPUSH
97195: CALL_OW 251
97199: PPUSH
97200: LD_VAR 0 4
97204: PPUSH
97205: LD_INT 3
97207: PPUSH
97208: LD_INT 12
97210: PPUSH
97211: CALL_OW 12
97215: PPUSH
97216: CALL_OW 273
97220: ST_TO_ADDR
// if ValidHex ( x , y ) then
97221: LD_VAR 0 2
97225: PPUSH
97226: LD_VAR 0 3
97230: PPUSH
97231: CALL_OW 488
97235: IFFALSE 97270
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
97237: LD_VAR 0 1
97241: PPUSH
97242: LD_VAR 0 2
97246: PPUSH
97247: LD_VAR 0 3
97251: PPUSH
97252: LD_INT 3
97254: PPUSH
97255: LD_INT 6
97257: PPUSH
97258: CALL_OW 12
97262: PPUSH
97263: LD_INT 1
97265: PPUSH
97266: CALL_OW 483
// end ;
97270: GO 97130
97272: POP
97273: POP
// end ;
97274: PPOPN 5
97276: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
97277: LD_EXP 107
97281: PUSH
97282: LD_EXP 142
97286: AND
97287: IFFALSE 97381
97289: GO 97291
97291: DISABLE
97292: LD_INT 0
97294: PPUSH
97295: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
97296: LD_ADDR_VAR 0 2
97300: PUSH
97301: LD_INT 22
97303: PUSH
97304: LD_OWVAR 2
97308: PUSH
97309: EMPTY
97310: LIST
97311: LIST
97312: PUSH
97313: LD_INT 32
97315: PUSH
97316: LD_INT 1
97318: PUSH
97319: EMPTY
97320: LIST
97321: LIST
97322: PUSH
97323: LD_INT 21
97325: PUSH
97326: LD_INT 2
97328: PUSH
97329: EMPTY
97330: LIST
97331: LIST
97332: PUSH
97333: EMPTY
97334: LIST
97335: LIST
97336: LIST
97337: PPUSH
97338: CALL_OW 69
97342: ST_TO_ADDR
// if not tmp then
97343: LD_VAR 0 2
97347: NOT
97348: IFFALSE 97352
// exit ;
97350: GO 97381
// for i in tmp do
97352: LD_ADDR_VAR 0 1
97356: PUSH
97357: LD_VAR 0 2
97361: PUSH
97362: FOR_IN
97363: IFFALSE 97379
// SetFuel ( i , 0 ) ;
97365: LD_VAR 0 1
97369: PPUSH
97370: LD_INT 0
97372: PPUSH
97373: CALL_OW 240
97377: GO 97362
97379: POP
97380: POP
// end ;
97381: PPOPN 2
97383: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
97384: LD_EXP 107
97388: PUSH
97389: LD_EXP 143
97393: AND
97394: IFFALSE 97460
97396: GO 97398
97398: DISABLE
97399: LD_INT 0
97401: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97402: LD_ADDR_VAR 0 1
97406: PUSH
97407: LD_INT 22
97409: PUSH
97410: LD_OWVAR 2
97414: PUSH
97415: EMPTY
97416: LIST
97417: LIST
97418: PUSH
97419: LD_INT 30
97421: PUSH
97422: LD_INT 29
97424: PUSH
97425: EMPTY
97426: LIST
97427: LIST
97428: PUSH
97429: EMPTY
97430: LIST
97431: LIST
97432: PPUSH
97433: CALL_OW 69
97437: ST_TO_ADDR
// if not tmp then
97438: LD_VAR 0 1
97442: NOT
97443: IFFALSE 97447
// exit ;
97445: GO 97460
// DestroyUnit ( tmp [ 1 ] ) ;
97447: LD_VAR 0 1
97451: PUSH
97452: LD_INT 1
97454: ARRAY
97455: PPUSH
97456: CALL_OW 65
// end ;
97460: PPOPN 1
97462: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
97463: LD_EXP 107
97467: PUSH
97468: LD_EXP 145
97472: AND
97473: IFFALSE 97602
97475: GO 97477
97477: DISABLE
97478: LD_INT 0
97480: PPUSH
// begin uc_side := 0 ;
97481: LD_ADDR_OWVAR 20
97485: PUSH
97486: LD_INT 0
97488: ST_TO_ADDR
// uc_nation := nation_arabian ;
97489: LD_ADDR_OWVAR 21
97493: PUSH
97494: LD_INT 2
97496: ST_TO_ADDR
// hc_gallery :=  ;
97497: LD_ADDR_OWVAR 33
97501: PUSH
97502: LD_STRING 
97504: ST_TO_ADDR
// hc_name :=  ;
97505: LD_ADDR_OWVAR 26
97509: PUSH
97510: LD_STRING 
97512: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
97513: LD_INT 1
97515: PPUSH
97516: LD_INT 11
97518: PPUSH
97519: LD_INT 10
97521: PPUSH
97522: CALL_OW 380
// un := CreateHuman ;
97526: LD_ADDR_VAR 0 1
97530: PUSH
97531: CALL_OW 44
97535: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97536: LD_VAR 0 1
97540: PPUSH
97541: LD_INT 1
97543: PPUSH
97544: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97548: LD_INT 35
97550: PPUSH
97551: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97555: LD_VAR 0 1
97559: PPUSH
97560: LD_INT 22
97562: PUSH
97563: LD_OWVAR 2
97567: PUSH
97568: EMPTY
97569: LIST
97570: LIST
97571: PPUSH
97572: CALL_OW 69
97576: PPUSH
97577: LD_VAR 0 1
97581: PPUSH
97582: CALL_OW 74
97586: PPUSH
97587: CALL_OW 115
// until IsDead ( un ) ;
97591: LD_VAR 0 1
97595: PPUSH
97596: CALL_OW 301
97600: IFFALSE 97548
// end ;
97602: PPOPN 1
97604: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
97605: LD_EXP 107
97609: PUSH
97610: LD_EXP 147
97614: AND
97615: IFFALSE 97627
97617: GO 97619
97619: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
97620: LD_STRING earthquake(getX(game), 0, 32)
97622: PPUSH
97623: CALL_OW 559
97627: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
97628: LD_EXP 107
97632: PUSH
97633: LD_EXP 148
97637: AND
97638: IFFALSE 97729
97640: GO 97642
97642: DISABLE
97643: LD_INT 0
97645: PPUSH
// begin enable ;
97646: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
97647: LD_ADDR_VAR 0 1
97651: PUSH
97652: LD_INT 22
97654: PUSH
97655: LD_OWVAR 2
97659: PUSH
97660: EMPTY
97661: LIST
97662: LIST
97663: PUSH
97664: LD_INT 21
97666: PUSH
97667: LD_INT 2
97669: PUSH
97670: EMPTY
97671: LIST
97672: LIST
97673: PUSH
97674: LD_INT 33
97676: PUSH
97677: LD_INT 3
97679: PUSH
97680: EMPTY
97681: LIST
97682: LIST
97683: PUSH
97684: EMPTY
97685: LIST
97686: LIST
97687: LIST
97688: PPUSH
97689: CALL_OW 69
97693: ST_TO_ADDR
// if not tmp then
97694: LD_VAR 0 1
97698: NOT
97699: IFFALSE 97703
// exit ;
97701: GO 97729
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97703: LD_VAR 0 1
97707: PUSH
97708: LD_INT 1
97710: PPUSH
97711: LD_VAR 0 1
97715: PPUSH
97716: CALL_OW 12
97720: ARRAY
97721: PPUSH
97722: LD_INT 1
97724: PPUSH
97725: CALL_OW 234
// end ;
97729: PPOPN 1
97731: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
97732: LD_EXP 107
97736: PUSH
97737: LD_EXP 149
97741: AND
97742: IFFALSE 97883
97744: GO 97746
97746: DISABLE
97747: LD_INT 0
97749: PPUSH
97750: PPUSH
97751: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97752: LD_ADDR_VAR 0 3
97756: PUSH
97757: LD_INT 22
97759: PUSH
97760: LD_OWVAR 2
97764: PUSH
97765: EMPTY
97766: LIST
97767: LIST
97768: PUSH
97769: LD_INT 25
97771: PUSH
97772: LD_INT 1
97774: PUSH
97775: EMPTY
97776: LIST
97777: LIST
97778: PUSH
97779: EMPTY
97780: LIST
97781: LIST
97782: PPUSH
97783: CALL_OW 69
97787: ST_TO_ADDR
// if not tmp then
97788: LD_VAR 0 3
97792: NOT
97793: IFFALSE 97797
// exit ;
97795: GO 97883
// un := tmp [ rand ( 1 , tmp ) ] ;
97797: LD_ADDR_VAR 0 2
97801: PUSH
97802: LD_VAR 0 3
97806: PUSH
97807: LD_INT 1
97809: PPUSH
97810: LD_VAR 0 3
97814: PPUSH
97815: CALL_OW 12
97819: ARRAY
97820: ST_TO_ADDR
// if Crawls ( un ) then
97821: LD_VAR 0 2
97825: PPUSH
97826: CALL_OW 318
97830: IFFALSE 97841
// ComWalk ( un ) ;
97832: LD_VAR 0 2
97836: PPUSH
97837: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
97841: LD_VAR 0 2
97845: PPUSH
97846: LD_INT 9
97848: PPUSH
97849: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
97853: LD_INT 28
97855: PPUSH
97856: LD_OWVAR 2
97860: PPUSH
97861: LD_INT 2
97863: PPUSH
97864: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
97868: LD_INT 29
97870: PPUSH
97871: LD_OWVAR 2
97875: PPUSH
97876: LD_INT 2
97878: PPUSH
97879: CALL_OW 322
// end ;
97883: PPOPN 3
97885: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
97886: LD_EXP 107
97890: PUSH
97891: LD_EXP 150
97895: AND
97896: IFFALSE 98007
97898: GO 97900
97900: DISABLE
97901: LD_INT 0
97903: PPUSH
97904: PPUSH
97905: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97906: LD_ADDR_VAR 0 3
97910: PUSH
97911: LD_INT 22
97913: PUSH
97914: LD_OWVAR 2
97918: PUSH
97919: EMPTY
97920: LIST
97921: LIST
97922: PUSH
97923: LD_INT 25
97925: PUSH
97926: LD_INT 1
97928: PUSH
97929: EMPTY
97930: LIST
97931: LIST
97932: PUSH
97933: EMPTY
97934: LIST
97935: LIST
97936: PPUSH
97937: CALL_OW 69
97941: ST_TO_ADDR
// if not tmp then
97942: LD_VAR 0 3
97946: NOT
97947: IFFALSE 97951
// exit ;
97949: GO 98007
// un := tmp [ rand ( 1 , tmp ) ] ;
97951: LD_ADDR_VAR 0 2
97955: PUSH
97956: LD_VAR 0 3
97960: PUSH
97961: LD_INT 1
97963: PPUSH
97964: LD_VAR 0 3
97968: PPUSH
97969: CALL_OW 12
97973: ARRAY
97974: ST_TO_ADDR
// if Crawls ( un ) then
97975: LD_VAR 0 2
97979: PPUSH
97980: CALL_OW 318
97984: IFFALSE 97995
// ComWalk ( un ) ;
97986: LD_VAR 0 2
97990: PPUSH
97991: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97995: LD_VAR 0 2
97999: PPUSH
98000: LD_INT 8
98002: PPUSH
98003: CALL_OW 336
// end ;
98007: PPOPN 3
98009: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
98010: LD_EXP 107
98014: PUSH
98015: LD_EXP 151
98019: AND
98020: IFFALSE 98164
98022: GO 98024
98024: DISABLE
98025: LD_INT 0
98027: PPUSH
98028: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
98029: LD_ADDR_VAR 0 2
98033: PUSH
98034: LD_INT 22
98036: PUSH
98037: LD_OWVAR 2
98041: PUSH
98042: EMPTY
98043: LIST
98044: LIST
98045: PUSH
98046: LD_INT 21
98048: PUSH
98049: LD_INT 2
98051: PUSH
98052: EMPTY
98053: LIST
98054: LIST
98055: PUSH
98056: LD_INT 2
98058: PUSH
98059: LD_INT 34
98061: PUSH
98062: LD_INT 12
98064: PUSH
98065: EMPTY
98066: LIST
98067: LIST
98068: PUSH
98069: LD_INT 34
98071: PUSH
98072: LD_INT 51
98074: PUSH
98075: EMPTY
98076: LIST
98077: LIST
98078: PUSH
98079: LD_INT 34
98081: PUSH
98082: LD_INT 32
98084: PUSH
98085: EMPTY
98086: LIST
98087: LIST
98088: PUSH
98089: EMPTY
98090: LIST
98091: LIST
98092: LIST
98093: LIST
98094: PUSH
98095: EMPTY
98096: LIST
98097: LIST
98098: LIST
98099: PPUSH
98100: CALL_OW 69
98104: ST_TO_ADDR
// if not tmp then
98105: LD_VAR 0 2
98109: NOT
98110: IFFALSE 98114
// exit ;
98112: GO 98164
// for i in tmp do
98114: LD_ADDR_VAR 0 1
98118: PUSH
98119: LD_VAR 0 2
98123: PUSH
98124: FOR_IN
98125: IFFALSE 98162
// if GetCargo ( i , mat_artifact ) = 0 then
98127: LD_VAR 0 1
98131: PPUSH
98132: LD_INT 4
98134: PPUSH
98135: CALL_OW 289
98139: PUSH
98140: LD_INT 0
98142: EQUAL
98143: IFFALSE 98160
// SetCargo ( i , mat_siberit , 100 ) ;
98145: LD_VAR 0 1
98149: PPUSH
98150: LD_INT 3
98152: PPUSH
98153: LD_INT 100
98155: PPUSH
98156: CALL_OW 290
98160: GO 98124
98162: POP
98163: POP
// end ;
98164: PPOPN 2
98166: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
98167: LD_EXP 107
98171: PUSH
98172: LD_EXP 152
98176: AND
98177: IFFALSE 98360
98179: GO 98181
98181: DISABLE
98182: LD_INT 0
98184: PPUSH
98185: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
98186: LD_ADDR_VAR 0 2
98190: PUSH
98191: LD_INT 22
98193: PUSH
98194: LD_OWVAR 2
98198: PUSH
98199: EMPTY
98200: LIST
98201: LIST
98202: PPUSH
98203: CALL_OW 69
98207: ST_TO_ADDR
// if not tmp then
98208: LD_VAR 0 2
98212: NOT
98213: IFFALSE 98217
// exit ;
98215: GO 98360
// for i := 1 to 2 do
98217: LD_ADDR_VAR 0 1
98221: PUSH
98222: DOUBLE
98223: LD_INT 1
98225: DEC
98226: ST_TO_ADDR
98227: LD_INT 2
98229: PUSH
98230: FOR_TO
98231: IFFALSE 98358
// begin uc_side := your_side ;
98233: LD_ADDR_OWVAR 20
98237: PUSH
98238: LD_OWVAR 2
98242: ST_TO_ADDR
// uc_nation := nation_american ;
98243: LD_ADDR_OWVAR 21
98247: PUSH
98248: LD_INT 1
98250: ST_TO_ADDR
// vc_chassis := us_morphling ;
98251: LD_ADDR_OWVAR 37
98255: PUSH
98256: LD_INT 5
98258: ST_TO_ADDR
// vc_engine := engine_siberite ;
98259: LD_ADDR_OWVAR 39
98263: PUSH
98264: LD_INT 3
98266: ST_TO_ADDR
// vc_control := control_computer ;
98267: LD_ADDR_OWVAR 38
98271: PUSH
98272: LD_INT 3
98274: ST_TO_ADDR
// vc_weapon := us_double_laser ;
98275: LD_ADDR_OWVAR 40
98279: PUSH
98280: LD_INT 10
98282: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
98283: LD_VAR 0 2
98287: PUSH
98288: LD_INT 1
98290: ARRAY
98291: PPUSH
98292: CALL_OW 310
98296: NOT
98297: IFFALSE 98344
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
98299: CALL_OW 45
98303: PPUSH
98304: LD_VAR 0 2
98308: PUSH
98309: LD_INT 1
98311: ARRAY
98312: PPUSH
98313: CALL_OW 250
98317: PPUSH
98318: LD_VAR 0 2
98322: PUSH
98323: LD_INT 1
98325: ARRAY
98326: PPUSH
98327: CALL_OW 251
98331: PPUSH
98332: LD_INT 12
98334: PPUSH
98335: LD_INT 1
98337: PPUSH
98338: CALL_OW 50
98342: GO 98356
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
98344: CALL_OW 45
98348: PPUSH
98349: LD_INT 1
98351: PPUSH
98352: CALL_OW 51
// end ;
98356: GO 98230
98358: POP
98359: POP
// end ;
98360: PPOPN 2
98362: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
98363: LD_EXP 107
98367: PUSH
98368: LD_EXP 153
98372: AND
98373: IFFALSE 98595
98375: GO 98377
98377: DISABLE
98378: LD_INT 0
98380: PPUSH
98381: PPUSH
98382: PPUSH
98383: PPUSH
98384: PPUSH
98385: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98386: LD_ADDR_VAR 0 6
98390: PUSH
98391: LD_INT 22
98393: PUSH
98394: LD_OWVAR 2
98398: PUSH
98399: EMPTY
98400: LIST
98401: LIST
98402: PUSH
98403: LD_INT 21
98405: PUSH
98406: LD_INT 1
98408: PUSH
98409: EMPTY
98410: LIST
98411: LIST
98412: PUSH
98413: LD_INT 3
98415: PUSH
98416: LD_INT 23
98418: PUSH
98419: LD_INT 0
98421: PUSH
98422: EMPTY
98423: LIST
98424: LIST
98425: PUSH
98426: EMPTY
98427: LIST
98428: LIST
98429: PUSH
98430: EMPTY
98431: LIST
98432: LIST
98433: LIST
98434: PPUSH
98435: CALL_OW 69
98439: ST_TO_ADDR
// if not tmp then
98440: LD_VAR 0 6
98444: NOT
98445: IFFALSE 98449
// exit ;
98447: GO 98595
// s1 := rand ( 1 , 4 ) ;
98449: LD_ADDR_VAR 0 2
98453: PUSH
98454: LD_INT 1
98456: PPUSH
98457: LD_INT 4
98459: PPUSH
98460: CALL_OW 12
98464: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
98465: LD_ADDR_VAR 0 4
98469: PUSH
98470: LD_VAR 0 6
98474: PUSH
98475: LD_INT 1
98477: ARRAY
98478: PPUSH
98479: LD_VAR 0 2
98483: PPUSH
98484: CALL_OW 259
98488: ST_TO_ADDR
// if s1 = 1 then
98489: LD_VAR 0 2
98493: PUSH
98494: LD_INT 1
98496: EQUAL
98497: IFFALSE 98517
// s2 := rand ( 2 , 4 ) else
98499: LD_ADDR_VAR 0 3
98503: PUSH
98504: LD_INT 2
98506: PPUSH
98507: LD_INT 4
98509: PPUSH
98510: CALL_OW 12
98514: ST_TO_ADDR
98515: GO 98525
// s2 := 1 ;
98517: LD_ADDR_VAR 0 3
98521: PUSH
98522: LD_INT 1
98524: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
98525: LD_ADDR_VAR 0 5
98529: PUSH
98530: LD_VAR 0 6
98534: PUSH
98535: LD_INT 1
98537: ARRAY
98538: PPUSH
98539: LD_VAR 0 3
98543: PPUSH
98544: CALL_OW 259
98548: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
98549: LD_VAR 0 6
98553: PUSH
98554: LD_INT 1
98556: ARRAY
98557: PPUSH
98558: LD_VAR 0 2
98562: PPUSH
98563: LD_VAR 0 5
98567: PPUSH
98568: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
98572: LD_VAR 0 6
98576: PUSH
98577: LD_INT 1
98579: ARRAY
98580: PPUSH
98581: LD_VAR 0 3
98585: PPUSH
98586: LD_VAR 0 4
98590: PPUSH
98591: CALL_OW 237
// end ;
98595: PPOPN 6
98597: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
98598: LD_EXP 107
98602: PUSH
98603: LD_EXP 154
98607: AND
98608: IFFALSE 98687
98610: GO 98612
98612: DISABLE
98613: LD_INT 0
98615: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
98616: LD_ADDR_VAR 0 1
98620: PUSH
98621: LD_INT 22
98623: PUSH
98624: LD_OWVAR 2
98628: PUSH
98629: EMPTY
98630: LIST
98631: LIST
98632: PUSH
98633: LD_INT 30
98635: PUSH
98636: LD_INT 3
98638: PUSH
98639: EMPTY
98640: LIST
98641: LIST
98642: PUSH
98643: EMPTY
98644: LIST
98645: LIST
98646: PPUSH
98647: CALL_OW 69
98651: ST_TO_ADDR
// if not tmp then
98652: LD_VAR 0 1
98656: NOT
98657: IFFALSE 98661
// exit ;
98659: GO 98687
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98661: LD_VAR 0 1
98665: PUSH
98666: LD_INT 1
98668: PPUSH
98669: LD_VAR 0 1
98673: PPUSH
98674: CALL_OW 12
98678: ARRAY
98679: PPUSH
98680: LD_INT 1
98682: PPUSH
98683: CALL_OW 234
// end ;
98687: PPOPN 1
98689: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
98690: LD_EXP 107
98694: PUSH
98695: LD_EXP 155
98699: AND
98700: IFFALSE 98812
98702: GO 98704
98704: DISABLE
98705: LD_INT 0
98707: PPUSH
98708: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
98709: LD_ADDR_VAR 0 2
98713: PUSH
98714: LD_INT 22
98716: PUSH
98717: LD_OWVAR 2
98721: PUSH
98722: EMPTY
98723: LIST
98724: LIST
98725: PUSH
98726: LD_INT 2
98728: PUSH
98729: LD_INT 30
98731: PUSH
98732: LD_INT 27
98734: PUSH
98735: EMPTY
98736: LIST
98737: LIST
98738: PUSH
98739: LD_INT 30
98741: PUSH
98742: LD_INT 26
98744: PUSH
98745: EMPTY
98746: LIST
98747: LIST
98748: PUSH
98749: LD_INT 30
98751: PUSH
98752: LD_INT 28
98754: PUSH
98755: EMPTY
98756: LIST
98757: LIST
98758: PUSH
98759: EMPTY
98760: LIST
98761: LIST
98762: LIST
98763: LIST
98764: PUSH
98765: EMPTY
98766: LIST
98767: LIST
98768: PPUSH
98769: CALL_OW 69
98773: ST_TO_ADDR
// if not tmp then
98774: LD_VAR 0 2
98778: NOT
98779: IFFALSE 98783
// exit ;
98781: GO 98812
// for i in tmp do
98783: LD_ADDR_VAR 0 1
98787: PUSH
98788: LD_VAR 0 2
98792: PUSH
98793: FOR_IN
98794: IFFALSE 98810
// SetLives ( i , 1 ) ;
98796: LD_VAR 0 1
98800: PPUSH
98801: LD_INT 1
98803: PPUSH
98804: CALL_OW 234
98808: GO 98793
98810: POP
98811: POP
// end ;
98812: PPOPN 2
98814: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
98815: LD_EXP 107
98819: PUSH
98820: LD_EXP 156
98824: AND
98825: IFFALSE 99112
98827: GO 98829
98829: DISABLE
98830: LD_INT 0
98832: PPUSH
98833: PPUSH
98834: PPUSH
// begin i := rand ( 1 , 7 ) ;
98835: LD_ADDR_VAR 0 1
98839: PUSH
98840: LD_INT 1
98842: PPUSH
98843: LD_INT 7
98845: PPUSH
98846: CALL_OW 12
98850: ST_TO_ADDR
// case i of 1 :
98851: LD_VAR 0 1
98855: PUSH
98856: LD_INT 1
98858: DOUBLE
98859: EQUAL
98860: IFTRUE 98864
98862: GO 98874
98864: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
98865: LD_STRING earthquake(getX(game), 0, 32)
98867: PPUSH
98868: CALL_OW 559
98872: GO 99112
98874: LD_INT 2
98876: DOUBLE
98877: EQUAL
98878: IFTRUE 98882
98880: GO 98896
98882: POP
// begin ToLua ( displayStucuk(); ) ;
98883: LD_STRING displayStucuk();
98885: PPUSH
98886: CALL_OW 559
// ResetFog ;
98890: CALL_OW 335
// end ; 3 :
98894: GO 99112
98896: LD_INT 3
98898: DOUBLE
98899: EQUAL
98900: IFTRUE 98904
98902: GO 99008
98904: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98905: LD_ADDR_VAR 0 2
98909: PUSH
98910: LD_INT 22
98912: PUSH
98913: LD_OWVAR 2
98917: PUSH
98918: EMPTY
98919: LIST
98920: LIST
98921: PUSH
98922: LD_INT 25
98924: PUSH
98925: LD_INT 1
98927: PUSH
98928: EMPTY
98929: LIST
98930: LIST
98931: PUSH
98932: EMPTY
98933: LIST
98934: LIST
98935: PPUSH
98936: CALL_OW 69
98940: ST_TO_ADDR
// if not tmp then
98941: LD_VAR 0 2
98945: NOT
98946: IFFALSE 98950
// exit ;
98948: GO 99112
// un := tmp [ rand ( 1 , tmp ) ] ;
98950: LD_ADDR_VAR 0 3
98954: PUSH
98955: LD_VAR 0 2
98959: PUSH
98960: LD_INT 1
98962: PPUSH
98963: LD_VAR 0 2
98967: PPUSH
98968: CALL_OW 12
98972: ARRAY
98973: ST_TO_ADDR
// if Crawls ( un ) then
98974: LD_VAR 0 3
98978: PPUSH
98979: CALL_OW 318
98983: IFFALSE 98994
// ComWalk ( un ) ;
98985: LD_VAR 0 3
98989: PPUSH
98990: CALL_OW 138
// SetClass ( un , class_mortar ) ;
98994: LD_VAR 0 3
98998: PPUSH
98999: LD_INT 8
99001: PPUSH
99002: CALL_OW 336
// end ; 4 :
99006: GO 99112
99008: LD_INT 4
99010: DOUBLE
99011: EQUAL
99012: IFTRUE 99016
99014: GO 99090
99016: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99017: LD_ADDR_VAR 0 2
99021: PUSH
99022: LD_INT 22
99024: PUSH
99025: LD_OWVAR 2
99029: PUSH
99030: EMPTY
99031: LIST
99032: LIST
99033: PUSH
99034: LD_INT 30
99036: PUSH
99037: LD_INT 29
99039: PUSH
99040: EMPTY
99041: LIST
99042: LIST
99043: PUSH
99044: EMPTY
99045: LIST
99046: LIST
99047: PPUSH
99048: CALL_OW 69
99052: ST_TO_ADDR
// if not tmp then
99053: LD_VAR 0 2
99057: NOT
99058: IFFALSE 99062
// exit ;
99060: GO 99112
// CenterNowOnUnits ( tmp [ 1 ] ) ;
99062: LD_VAR 0 2
99066: PUSH
99067: LD_INT 1
99069: ARRAY
99070: PPUSH
99071: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
99075: LD_VAR 0 2
99079: PUSH
99080: LD_INT 1
99082: ARRAY
99083: PPUSH
99084: CALL_OW 65
// end ; 5 .. 7 :
99088: GO 99112
99090: LD_INT 5
99092: DOUBLE
99093: GREATEREQUAL
99094: IFFALSE 99102
99096: LD_INT 7
99098: DOUBLE
99099: LESSEQUAL
99100: IFTRUE 99104
99102: GO 99111
99104: POP
// StreamSibBomb ; end ;
99105: CALL 95349 0 0
99109: GO 99112
99111: POP
// end ;
99112: PPOPN 3
99114: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
99115: LD_EXP 107
99119: PUSH
99120: LD_EXP 157
99124: AND
99125: IFFALSE 99281
99127: GO 99129
99129: DISABLE
99130: LD_INT 0
99132: PPUSH
99133: PPUSH
99134: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
99135: LD_ADDR_VAR 0 2
99139: PUSH
99140: LD_INT 81
99142: PUSH
99143: LD_OWVAR 2
99147: PUSH
99148: EMPTY
99149: LIST
99150: LIST
99151: PUSH
99152: LD_INT 2
99154: PUSH
99155: LD_INT 21
99157: PUSH
99158: LD_INT 1
99160: PUSH
99161: EMPTY
99162: LIST
99163: LIST
99164: PUSH
99165: LD_INT 21
99167: PUSH
99168: LD_INT 2
99170: PUSH
99171: EMPTY
99172: LIST
99173: LIST
99174: PUSH
99175: EMPTY
99176: LIST
99177: LIST
99178: LIST
99179: PUSH
99180: EMPTY
99181: LIST
99182: LIST
99183: PPUSH
99184: CALL_OW 69
99188: ST_TO_ADDR
// if not tmp then
99189: LD_VAR 0 2
99193: NOT
99194: IFFALSE 99198
// exit ;
99196: GO 99281
// p := 0 ;
99198: LD_ADDR_VAR 0 3
99202: PUSH
99203: LD_INT 0
99205: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99206: LD_INT 35
99208: PPUSH
99209: CALL_OW 67
// p := p + 1 ;
99213: LD_ADDR_VAR 0 3
99217: PUSH
99218: LD_VAR 0 3
99222: PUSH
99223: LD_INT 1
99225: PLUS
99226: ST_TO_ADDR
// for i in tmp do
99227: LD_ADDR_VAR 0 1
99231: PUSH
99232: LD_VAR 0 2
99236: PUSH
99237: FOR_IN
99238: IFFALSE 99269
// if GetLives ( i ) < 1000 then
99240: LD_VAR 0 1
99244: PPUSH
99245: CALL_OW 256
99249: PUSH
99250: LD_INT 1000
99252: LESS
99253: IFFALSE 99267
// SetLives ( i , 1000 ) ;
99255: LD_VAR 0 1
99259: PPUSH
99260: LD_INT 1000
99262: PPUSH
99263: CALL_OW 234
99267: GO 99237
99269: POP
99270: POP
// until p > 20 ;
99271: LD_VAR 0 3
99275: PUSH
99276: LD_INT 20
99278: GREATER
99279: IFFALSE 99206
// end ;
99281: PPOPN 3
99283: END
// every 0 0$1 trigger StreamModeActive and sTime do
99284: LD_EXP 107
99288: PUSH
99289: LD_EXP 158
99293: AND
99294: IFFALSE 99329
99296: GO 99298
99298: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
99299: LD_INT 28
99301: PPUSH
99302: LD_OWVAR 2
99306: PPUSH
99307: LD_INT 2
99309: PPUSH
99310: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
99314: LD_INT 30
99316: PPUSH
99317: LD_OWVAR 2
99321: PPUSH
99322: LD_INT 2
99324: PPUSH
99325: CALL_OW 322
// end ;
99329: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
99330: LD_EXP 107
99334: PUSH
99335: LD_EXP 159
99339: AND
99340: IFFALSE 99461
99342: GO 99344
99344: DISABLE
99345: LD_INT 0
99347: PPUSH
99348: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99349: LD_ADDR_VAR 0 2
99353: PUSH
99354: LD_INT 22
99356: PUSH
99357: LD_OWVAR 2
99361: PUSH
99362: EMPTY
99363: LIST
99364: LIST
99365: PUSH
99366: LD_INT 21
99368: PUSH
99369: LD_INT 1
99371: PUSH
99372: EMPTY
99373: LIST
99374: LIST
99375: PUSH
99376: LD_INT 3
99378: PUSH
99379: LD_INT 23
99381: PUSH
99382: LD_INT 0
99384: PUSH
99385: EMPTY
99386: LIST
99387: LIST
99388: PUSH
99389: EMPTY
99390: LIST
99391: LIST
99392: PUSH
99393: EMPTY
99394: LIST
99395: LIST
99396: LIST
99397: PPUSH
99398: CALL_OW 69
99402: ST_TO_ADDR
// if not tmp then
99403: LD_VAR 0 2
99407: NOT
99408: IFFALSE 99412
// exit ;
99410: GO 99461
// for i in tmp do
99412: LD_ADDR_VAR 0 1
99416: PUSH
99417: LD_VAR 0 2
99421: PUSH
99422: FOR_IN
99423: IFFALSE 99459
// begin if Crawls ( i ) then
99425: LD_VAR 0 1
99429: PPUSH
99430: CALL_OW 318
99434: IFFALSE 99445
// ComWalk ( i ) ;
99436: LD_VAR 0 1
99440: PPUSH
99441: CALL_OW 138
// SetClass ( i , 2 ) ;
99445: LD_VAR 0 1
99449: PPUSH
99450: LD_INT 2
99452: PPUSH
99453: CALL_OW 336
// end ;
99457: GO 99422
99459: POP
99460: POP
// end ;
99461: PPOPN 2
99463: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
99464: LD_EXP 107
99468: PUSH
99469: LD_EXP 160
99473: AND
99474: IFFALSE 99762
99476: GO 99478
99478: DISABLE
99479: LD_INT 0
99481: PPUSH
99482: PPUSH
99483: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
99484: LD_OWVAR 2
99488: PPUSH
99489: LD_INT 9
99491: PPUSH
99492: LD_INT 1
99494: PPUSH
99495: LD_INT 1
99497: PPUSH
99498: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
99502: LD_INT 9
99504: PPUSH
99505: LD_OWVAR 2
99509: PPUSH
99510: CALL_OW 343
// uc_side := 9 ;
99514: LD_ADDR_OWVAR 20
99518: PUSH
99519: LD_INT 9
99521: ST_TO_ADDR
// uc_nation := 2 ;
99522: LD_ADDR_OWVAR 21
99526: PUSH
99527: LD_INT 2
99529: ST_TO_ADDR
// hc_name := Dark Warrior ;
99530: LD_ADDR_OWVAR 26
99534: PUSH
99535: LD_STRING Dark Warrior
99537: ST_TO_ADDR
// hc_gallery :=  ;
99538: LD_ADDR_OWVAR 33
99542: PUSH
99543: LD_STRING 
99545: ST_TO_ADDR
// hc_noskilllimit := true ;
99546: LD_ADDR_OWVAR 76
99550: PUSH
99551: LD_INT 1
99553: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
99554: LD_ADDR_OWVAR 31
99558: PUSH
99559: LD_INT 30
99561: PUSH
99562: LD_INT 30
99564: PUSH
99565: LD_INT 30
99567: PUSH
99568: LD_INT 30
99570: PUSH
99571: EMPTY
99572: LIST
99573: LIST
99574: LIST
99575: LIST
99576: ST_TO_ADDR
// un := CreateHuman ;
99577: LD_ADDR_VAR 0 3
99581: PUSH
99582: CALL_OW 44
99586: ST_TO_ADDR
// hc_noskilllimit := false ;
99587: LD_ADDR_OWVAR 76
99591: PUSH
99592: LD_INT 0
99594: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99595: LD_VAR 0 3
99599: PPUSH
99600: LD_INT 1
99602: PPUSH
99603: CALL_OW 51
// ToLua ( playRanger() ) ;
99607: LD_STRING playRanger()
99609: PPUSH
99610: CALL_OW 559
// p := 0 ;
99614: LD_ADDR_VAR 0 2
99618: PUSH
99619: LD_INT 0
99621: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99622: LD_INT 35
99624: PPUSH
99625: CALL_OW 67
// p := p + 1 ;
99629: LD_ADDR_VAR 0 2
99633: PUSH
99634: LD_VAR 0 2
99638: PUSH
99639: LD_INT 1
99641: PLUS
99642: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
99643: LD_VAR 0 3
99647: PPUSH
99648: CALL_OW 256
99652: PUSH
99653: LD_INT 1000
99655: LESS
99656: IFFALSE 99670
// SetLives ( un , 1000 ) ;
99658: LD_VAR 0 3
99662: PPUSH
99663: LD_INT 1000
99665: PPUSH
99666: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
99670: LD_VAR 0 3
99674: PPUSH
99675: LD_INT 81
99677: PUSH
99678: LD_OWVAR 2
99682: PUSH
99683: EMPTY
99684: LIST
99685: LIST
99686: PUSH
99687: LD_INT 91
99689: PUSH
99690: LD_VAR 0 3
99694: PUSH
99695: LD_INT 30
99697: PUSH
99698: EMPTY
99699: LIST
99700: LIST
99701: LIST
99702: PUSH
99703: EMPTY
99704: LIST
99705: LIST
99706: PPUSH
99707: CALL_OW 69
99711: PPUSH
99712: LD_VAR 0 3
99716: PPUSH
99717: CALL_OW 74
99721: PPUSH
99722: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
99726: LD_VAR 0 2
99730: PUSH
99731: LD_INT 80
99733: GREATER
99734: PUSH
99735: LD_VAR 0 3
99739: PPUSH
99740: CALL_OW 301
99744: OR
99745: IFFALSE 99622
// if un then
99747: LD_VAR 0 3
99751: IFFALSE 99762
// RemoveUnit ( un ) ;
99753: LD_VAR 0 3
99757: PPUSH
99758: CALL_OW 64
// end ;
99762: PPOPN 3
99764: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
99765: LD_EXP 161
99769: IFFALSE 99885
99771: GO 99773
99773: DISABLE
99774: LD_INT 0
99776: PPUSH
99777: PPUSH
99778: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
99779: LD_ADDR_VAR 0 2
99783: PUSH
99784: LD_INT 81
99786: PUSH
99787: LD_OWVAR 2
99791: PUSH
99792: EMPTY
99793: LIST
99794: LIST
99795: PUSH
99796: LD_INT 21
99798: PUSH
99799: LD_INT 1
99801: PUSH
99802: EMPTY
99803: LIST
99804: LIST
99805: PUSH
99806: EMPTY
99807: LIST
99808: LIST
99809: PPUSH
99810: CALL_OW 69
99814: ST_TO_ADDR
// ToLua ( playComputer() ) ;
99815: LD_STRING playComputer()
99817: PPUSH
99818: CALL_OW 559
// if not tmp then
99822: LD_VAR 0 2
99826: NOT
99827: IFFALSE 99831
// exit ;
99829: GO 99885
// for i in tmp do
99831: LD_ADDR_VAR 0 1
99835: PUSH
99836: LD_VAR 0 2
99840: PUSH
99841: FOR_IN
99842: IFFALSE 99883
// for j := 1 to 4 do
99844: LD_ADDR_VAR 0 3
99848: PUSH
99849: DOUBLE
99850: LD_INT 1
99852: DEC
99853: ST_TO_ADDR
99854: LD_INT 4
99856: PUSH
99857: FOR_TO
99858: IFFALSE 99879
// SetSkill ( i , j , 10 ) ;
99860: LD_VAR 0 1
99864: PPUSH
99865: LD_VAR 0 3
99869: PPUSH
99870: LD_INT 10
99872: PPUSH
99873: CALL_OW 237
99877: GO 99857
99879: POP
99880: POP
99881: GO 99841
99883: POP
99884: POP
// end ;
99885: PPOPN 3
99887: END
// every 0 0$1 trigger s30 do var i , tmp ;
99888: LD_EXP 162
99892: IFFALSE 99961
99894: GO 99896
99896: DISABLE
99897: LD_INT 0
99899: PPUSH
99900: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99901: LD_ADDR_VAR 0 2
99905: PUSH
99906: LD_INT 22
99908: PUSH
99909: LD_OWVAR 2
99913: PUSH
99914: EMPTY
99915: LIST
99916: LIST
99917: PPUSH
99918: CALL_OW 69
99922: ST_TO_ADDR
// if not tmp then
99923: LD_VAR 0 2
99927: NOT
99928: IFFALSE 99932
// exit ;
99930: GO 99961
// for i in tmp do
99932: LD_ADDR_VAR 0 1
99936: PUSH
99937: LD_VAR 0 2
99941: PUSH
99942: FOR_IN
99943: IFFALSE 99959
// SetLives ( i , 300 ) ;
99945: LD_VAR 0 1
99949: PPUSH
99950: LD_INT 300
99952: PPUSH
99953: CALL_OW 234
99957: GO 99942
99959: POP
99960: POP
// end ;
99961: PPOPN 2
99963: END
// every 0 0$1 trigger s60 do var i , tmp ;
99964: LD_EXP 163
99968: IFFALSE 100037
99970: GO 99972
99972: DISABLE
99973: LD_INT 0
99975: PPUSH
99976: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99977: LD_ADDR_VAR 0 2
99981: PUSH
99982: LD_INT 22
99984: PUSH
99985: LD_OWVAR 2
99989: PUSH
99990: EMPTY
99991: LIST
99992: LIST
99993: PPUSH
99994: CALL_OW 69
99998: ST_TO_ADDR
// if not tmp then
99999: LD_VAR 0 2
100003: NOT
100004: IFFALSE 100008
// exit ;
100006: GO 100037
// for i in tmp do
100008: LD_ADDR_VAR 0 1
100012: PUSH
100013: LD_VAR 0 2
100017: PUSH
100018: FOR_IN
100019: IFFALSE 100035
// SetLives ( i , 600 ) ;
100021: LD_VAR 0 1
100025: PPUSH
100026: LD_INT 600
100028: PPUSH
100029: CALL_OW 234
100033: GO 100018
100035: POP
100036: POP
// end ;
100037: PPOPN 2
100039: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
100040: LD_INT 0
100042: PPUSH
// case cmd of 301 :
100043: LD_VAR 0 1
100047: PUSH
100048: LD_INT 301
100050: DOUBLE
100051: EQUAL
100052: IFTRUE 100056
100054: GO 100088
100056: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
100057: LD_VAR 0 6
100061: PPUSH
100062: LD_VAR 0 7
100066: PPUSH
100067: LD_VAR 0 8
100071: PPUSH
100072: LD_VAR 0 4
100076: PPUSH
100077: LD_VAR 0 5
100081: PPUSH
100082: CALL 101297 0 5
100086: GO 100209
100088: LD_INT 302
100090: DOUBLE
100091: EQUAL
100092: IFTRUE 100096
100094: GO 100133
100096: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
100097: LD_VAR 0 6
100101: PPUSH
100102: LD_VAR 0 7
100106: PPUSH
100107: LD_VAR 0 8
100111: PPUSH
100112: LD_VAR 0 9
100116: PPUSH
100117: LD_VAR 0 4
100121: PPUSH
100122: LD_VAR 0 5
100126: PPUSH
100127: CALL 101388 0 6
100131: GO 100209
100133: LD_INT 303
100135: DOUBLE
100136: EQUAL
100137: IFTRUE 100141
100139: GO 100178
100141: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
100142: LD_VAR 0 6
100146: PPUSH
100147: LD_VAR 0 7
100151: PPUSH
100152: LD_VAR 0 8
100156: PPUSH
100157: LD_VAR 0 9
100161: PPUSH
100162: LD_VAR 0 4
100166: PPUSH
100167: LD_VAR 0 5
100171: PPUSH
100172: CALL 100214 0 6
100176: GO 100209
100178: LD_INT 304
100180: DOUBLE
100181: EQUAL
100182: IFTRUE 100186
100184: GO 100208
100186: POP
// hHackTeleport ( unit , x , y ) ; end ;
100187: LD_VAR 0 2
100191: PPUSH
100192: LD_VAR 0 4
100196: PPUSH
100197: LD_VAR 0 5
100201: PPUSH
100202: CALL 101981 0 3
100206: GO 100209
100208: POP
// end ;
100209: LD_VAR 0 12
100213: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
100214: LD_INT 0
100216: PPUSH
100217: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
100218: LD_VAR 0 1
100222: PUSH
100223: LD_INT 1
100225: LESS
100226: PUSH
100227: LD_VAR 0 1
100231: PUSH
100232: LD_INT 3
100234: GREATER
100235: OR
100236: PUSH
100237: LD_VAR 0 5
100241: PPUSH
100242: LD_VAR 0 6
100246: PPUSH
100247: CALL_OW 428
100251: OR
100252: IFFALSE 100256
// exit ;
100254: GO 100984
// uc_side := your_side ;
100256: LD_ADDR_OWVAR 20
100260: PUSH
100261: LD_OWVAR 2
100265: ST_TO_ADDR
// uc_nation := nation ;
100266: LD_ADDR_OWVAR 21
100270: PUSH
100271: LD_VAR 0 1
100275: ST_TO_ADDR
// bc_level = 1 ;
100276: LD_ADDR_OWVAR 43
100280: PUSH
100281: LD_INT 1
100283: ST_TO_ADDR
// case btype of 1 :
100284: LD_VAR 0 2
100288: PUSH
100289: LD_INT 1
100291: DOUBLE
100292: EQUAL
100293: IFTRUE 100297
100295: GO 100308
100297: POP
// bc_type := b_depot ; 2 :
100298: LD_ADDR_OWVAR 42
100302: PUSH
100303: LD_INT 0
100305: ST_TO_ADDR
100306: GO 100928
100308: LD_INT 2
100310: DOUBLE
100311: EQUAL
100312: IFTRUE 100316
100314: GO 100327
100316: POP
// bc_type := b_warehouse ; 3 :
100317: LD_ADDR_OWVAR 42
100321: PUSH
100322: LD_INT 1
100324: ST_TO_ADDR
100325: GO 100928
100327: LD_INT 3
100329: DOUBLE
100330: EQUAL
100331: IFTRUE 100335
100333: GO 100346
100335: POP
// bc_type := b_lab ; 4 .. 9 :
100336: LD_ADDR_OWVAR 42
100340: PUSH
100341: LD_INT 6
100343: ST_TO_ADDR
100344: GO 100928
100346: LD_INT 4
100348: DOUBLE
100349: GREATEREQUAL
100350: IFFALSE 100358
100352: LD_INT 9
100354: DOUBLE
100355: LESSEQUAL
100356: IFTRUE 100360
100358: GO 100420
100360: POP
// begin bc_type := b_lab_half ;
100361: LD_ADDR_OWVAR 42
100365: PUSH
100366: LD_INT 7
100368: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
100369: LD_ADDR_OWVAR 44
100373: PUSH
100374: LD_INT 10
100376: PUSH
100377: LD_INT 11
100379: PUSH
100380: LD_INT 12
100382: PUSH
100383: LD_INT 15
100385: PUSH
100386: LD_INT 14
100388: PUSH
100389: LD_INT 13
100391: PUSH
100392: EMPTY
100393: LIST
100394: LIST
100395: LIST
100396: LIST
100397: LIST
100398: LIST
100399: PUSH
100400: LD_VAR 0 2
100404: PUSH
100405: LD_INT 3
100407: MINUS
100408: ARRAY
100409: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
100410: LD_ADDR_OWVAR 45
100414: PUSH
100415: LD_INT 9
100417: ST_TO_ADDR
// end ; 10 .. 13 :
100418: GO 100928
100420: LD_INT 10
100422: DOUBLE
100423: GREATEREQUAL
100424: IFFALSE 100432
100426: LD_INT 13
100428: DOUBLE
100429: LESSEQUAL
100430: IFTRUE 100434
100432: GO 100511
100434: POP
// begin bc_type := b_lab_full ;
100435: LD_ADDR_OWVAR 42
100439: PUSH
100440: LD_INT 8
100442: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
100443: LD_ADDR_OWVAR 44
100447: PUSH
100448: LD_INT 10
100450: PUSH
100451: LD_INT 12
100453: PUSH
100454: LD_INT 14
100456: PUSH
100457: LD_INT 13
100459: PUSH
100460: EMPTY
100461: LIST
100462: LIST
100463: LIST
100464: LIST
100465: PUSH
100466: LD_VAR 0 2
100470: PUSH
100471: LD_INT 9
100473: MINUS
100474: ARRAY
100475: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
100476: LD_ADDR_OWVAR 45
100480: PUSH
100481: LD_INT 11
100483: PUSH
100484: LD_INT 15
100486: PUSH
100487: LD_INT 12
100489: PUSH
100490: LD_INT 15
100492: PUSH
100493: EMPTY
100494: LIST
100495: LIST
100496: LIST
100497: LIST
100498: PUSH
100499: LD_VAR 0 2
100503: PUSH
100504: LD_INT 9
100506: MINUS
100507: ARRAY
100508: ST_TO_ADDR
// end ; 14 :
100509: GO 100928
100511: LD_INT 14
100513: DOUBLE
100514: EQUAL
100515: IFTRUE 100519
100517: GO 100530
100519: POP
// bc_type := b_workshop ; 15 :
100520: LD_ADDR_OWVAR 42
100524: PUSH
100525: LD_INT 2
100527: ST_TO_ADDR
100528: GO 100928
100530: LD_INT 15
100532: DOUBLE
100533: EQUAL
100534: IFTRUE 100538
100536: GO 100549
100538: POP
// bc_type := b_factory ; 16 :
100539: LD_ADDR_OWVAR 42
100543: PUSH
100544: LD_INT 3
100546: ST_TO_ADDR
100547: GO 100928
100549: LD_INT 16
100551: DOUBLE
100552: EQUAL
100553: IFTRUE 100557
100555: GO 100568
100557: POP
// bc_type := b_ext_gun ; 17 :
100558: LD_ADDR_OWVAR 42
100562: PUSH
100563: LD_INT 17
100565: ST_TO_ADDR
100566: GO 100928
100568: LD_INT 17
100570: DOUBLE
100571: EQUAL
100572: IFTRUE 100576
100574: GO 100604
100576: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
100577: LD_ADDR_OWVAR 42
100581: PUSH
100582: LD_INT 19
100584: PUSH
100585: LD_INT 23
100587: PUSH
100588: LD_INT 19
100590: PUSH
100591: EMPTY
100592: LIST
100593: LIST
100594: LIST
100595: PUSH
100596: LD_VAR 0 1
100600: ARRAY
100601: ST_TO_ADDR
100602: GO 100928
100604: LD_INT 18
100606: DOUBLE
100607: EQUAL
100608: IFTRUE 100612
100610: GO 100623
100612: POP
// bc_type := b_ext_radar ; 19 :
100613: LD_ADDR_OWVAR 42
100617: PUSH
100618: LD_INT 20
100620: ST_TO_ADDR
100621: GO 100928
100623: LD_INT 19
100625: DOUBLE
100626: EQUAL
100627: IFTRUE 100631
100629: GO 100642
100631: POP
// bc_type := b_ext_radio ; 20 :
100632: LD_ADDR_OWVAR 42
100636: PUSH
100637: LD_INT 22
100639: ST_TO_ADDR
100640: GO 100928
100642: LD_INT 20
100644: DOUBLE
100645: EQUAL
100646: IFTRUE 100650
100648: GO 100661
100650: POP
// bc_type := b_ext_siberium ; 21 :
100651: LD_ADDR_OWVAR 42
100655: PUSH
100656: LD_INT 21
100658: ST_TO_ADDR
100659: GO 100928
100661: LD_INT 21
100663: DOUBLE
100664: EQUAL
100665: IFTRUE 100669
100667: GO 100680
100669: POP
// bc_type := b_ext_computer ; 22 :
100670: LD_ADDR_OWVAR 42
100674: PUSH
100675: LD_INT 24
100677: ST_TO_ADDR
100678: GO 100928
100680: LD_INT 22
100682: DOUBLE
100683: EQUAL
100684: IFTRUE 100688
100686: GO 100699
100688: POP
// bc_type := b_ext_track ; 23 :
100689: LD_ADDR_OWVAR 42
100693: PUSH
100694: LD_INT 16
100696: ST_TO_ADDR
100697: GO 100928
100699: LD_INT 23
100701: DOUBLE
100702: EQUAL
100703: IFTRUE 100707
100705: GO 100718
100707: POP
// bc_type := b_ext_laser ; 24 :
100708: LD_ADDR_OWVAR 42
100712: PUSH
100713: LD_INT 25
100715: ST_TO_ADDR
100716: GO 100928
100718: LD_INT 24
100720: DOUBLE
100721: EQUAL
100722: IFTRUE 100726
100724: GO 100737
100726: POP
// bc_type := b_control_tower ; 25 :
100727: LD_ADDR_OWVAR 42
100731: PUSH
100732: LD_INT 36
100734: ST_TO_ADDR
100735: GO 100928
100737: LD_INT 25
100739: DOUBLE
100740: EQUAL
100741: IFTRUE 100745
100743: GO 100756
100745: POP
// bc_type := b_breastwork ; 26 :
100746: LD_ADDR_OWVAR 42
100750: PUSH
100751: LD_INT 31
100753: ST_TO_ADDR
100754: GO 100928
100756: LD_INT 26
100758: DOUBLE
100759: EQUAL
100760: IFTRUE 100764
100762: GO 100775
100764: POP
// bc_type := b_bunker ; 27 :
100765: LD_ADDR_OWVAR 42
100769: PUSH
100770: LD_INT 32
100772: ST_TO_ADDR
100773: GO 100928
100775: LD_INT 27
100777: DOUBLE
100778: EQUAL
100779: IFTRUE 100783
100781: GO 100794
100783: POP
// bc_type := b_turret ; 28 :
100784: LD_ADDR_OWVAR 42
100788: PUSH
100789: LD_INT 33
100791: ST_TO_ADDR
100792: GO 100928
100794: LD_INT 28
100796: DOUBLE
100797: EQUAL
100798: IFTRUE 100802
100800: GO 100813
100802: POP
// bc_type := b_armoury ; 29 :
100803: LD_ADDR_OWVAR 42
100807: PUSH
100808: LD_INT 4
100810: ST_TO_ADDR
100811: GO 100928
100813: LD_INT 29
100815: DOUBLE
100816: EQUAL
100817: IFTRUE 100821
100819: GO 100832
100821: POP
// bc_type := b_barracks ; 30 :
100822: LD_ADDR_OWVAR 42
100826: PUSH
100827: LD_INT 5
100829: ST_TO_ADDR
100830: GO 100928
100832: LD_INT 30
100834: DOUBLE
100835: EQUAL
100836: IFTRUE 100840
100838: GO 100851
100840: POP
// bc_type := b_solar_power ; 31 :
100841: LD_ADDR_OWVAR 42
100845: PUSH
100846: LD_INT 27
100848: ST_TO_ADDR
100849: GO 100928
100851: LD_INT 31
100853: DOUBLE
100854: EQUAL
100855: IFTRUE 100859
100857: GO 100870
100859: POP
// bc_type := b_oil_power ; 32 :
100860: LD_ADDR_OWVAR 42
100864: PUSH
100865: LD_INT 26
100867: ST_TO_ADDR
100868: GO 100928
100870: LD_INT 32
100872: DOUBLE
100873: EQUAL
100874: IFTRUE 100878
100876: GO 100889
100878: POP
// bc_type := b_siberite_power ; 33 :
100879: LD_ADDR_OWVAR 42
100883: PUSH
100884: LD_INT 28
100886: ST_TO_ADDR
100887: GO 100928
100889: LD_INT 33
100891: DOUBLE
100892: EQUAL
100893: IFTRUE 100897
100895: GO 100908
100897: POP
// bc_type := b_oil_mine ; 34 :
100898: LD_ADDR_OWVAR 42
100902: PUSH
100903: LD_INT 29
100905: ST_TO_ADDR
100906: GO 100928
100908: LD_INT 34
100910: DOUBLE
100911: EQUAL
100912: IFTRUE 100916
100914: GO 100927
100916: POP
// bc_type := b_siberite_mine ; end ;
100917: LD_ADDR_OWVAR 42
100921: PUSH
100922: LD_INT 30
100924: ST_TO_ADDR
100925: GO 100928
100927: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
100928: LD_ADDR_VAR 0 8
100932: PUSH
100933: LD_VAR 0 5
100937: PPUSH
100938: LD_VAR 0 6
100942: PPUSH
100943: LD_VAR 0 3
100947: PPUSH
100948: CALL_OW 47
100952: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
100953: LD_OWVAR 42
100957: PUSH
100958: LD_INT 32
100960: PUSH
100961: LD_INT 33
100963: PUSH
100964: EMPTY
100965: LIST
100966: LIST
100967: IN
100968: IFFALSE 100984
// PlaceWeaponTurret ( b , weapon ) ;
100970: LD_VAR 0 8
100974: PPUSH
100975: LD_VAR 0 4
100979: PPUSH
100980: CALL_OW 431
// end ;
100984: LD_VAR 0 7
100988: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
100989: LD_INT 0
100991: PPUSH
100992: PPUSH
100993: PPUSH
100994: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100995: LD_ADDR_VAR 0 4
100999: PUSH
101000: LD_INT 22
101002: PUSH
101003: LD_OWVAR 2
101007: PUSH
101008: EMPTY
101009: LIST
101010: LIST
101011: PUSH
101012: LD_INT 2
101014: PUSH
101015: LD_INT 30
101017: PUSH
101018: LD_INT 0
101020: PUSH
101021: EMPTY
101022: LIST
101023: LIST
101024: PUSH
101025: LD_INT 30
101027: PUSH
101028: LD_INT 1
101030: PUSH
101031: EMPTY
101032: LIST
101033: LIST
101034: PUSH
101035: EMPTY
101036: LIST
101037: LIST
101038: LIST
101039: PUSH
101040: EMPTY
101041: LIST
101042: LIST
101043: PPUSH
101044: CALL_OW 69
101048: ST_TO_ADDR
// if not tmp then
101049: LD_VAR 0 4
101053: NOT
101054: IFFALSE 101058
// exit ;
101056: GO 101117
// for i in tmp do
101058: LD_ADDR_VAR 0 2
101062: PUSH
101063: LD_VAR 0 4
101067: PUSH
101068: FOR_IN
101069: IFFALSE 101115
// for j = 1 to 3 do
101071: LD_ADDR_VAR 0 3
101075: PUSH
101076: DOUBLE
101077: LD_INT 1
101079: DEC
101080: ST_TO_ADDR
101081: LD_INT 3
101083: PUSH
101084: FOR_TO
101085: IFFALSE 101111
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
101087: LD_VAR 0 2
101091: PPUSH
101092: CALL_OW 274
101096: PPUSH
101097: LD_VAR 0 3
101101: PPUSH
101102: LD_INT 99999
101104: PPUSH
101105: CALL_OW 277
101109: GO 101084
101111: POP
101112: POP
101113: GO 101068
101115: POP
101116: POP
// end ;
101117: LD_VAR 0 1
101121: RET
// export function hHackSetLevel10 ; var i , j ; begin
101122: LD_INT 0
101124: PPUSH
101125: PPUSH
101126: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101127: LD_ADDR_VAR 0 2
101131: PUSH
101132: LD_INT 21
101134: PUSH
101135: LD_INT 1
101137: PUSH
101138: EMPTY
101139: LIST
101140: LIST
101141: PPUSH
101142: CALL_OW 69
101146: PUSH
101147: FOR_IN
101148: IFFALSE 101200
// if IsSelected ( i ) then
101150: LD_VAR 0 2
101154: PPUSH
101155: CALL_OW 306
101159: IFFALSE 101198
// begin for j := 1 to 4 do
101161: LD_ADDR_VAR 0 3
101165: PUSH
101166: DOUBLE
101167: LD_INT 1
101169: DEC
101170: ST_TO_ADDR
101171: LD_INT 4
101173: PUSH
101174: FOR_TO
101175: IFFALSE 101196
// SetSkill ( i , j , 10 ) ;
101177: LD_VAR 0 2
101181: PPUSH
101182: LD_VAR 0 3
101186: PPUSH
101187: LD_INT 10
101189: PPUSH
101190: CALL_OW 237
101194: GO 101174
101196: POP
101197: POP
// end ;
101198: GO 101147
101200: POP
101201: POP
// end ;
101202: LD_VAR 0 1
101206: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
101207: LD_INT 0
101209: PPUSH
101210: PPUSH
101211: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
101212: LD_ADDR_VAR 0 2
101216: PUSH
101217: LD_INT 22
101219: PUSH
101220: LD_OWVAR 2
101224: PUSH
101225: EMPTY
101226: LIST
101227: LIST
101228: PUSH
101229: LD_INT 21
101231: PUSH
101232: LD_INT 1
101234: PUSH
101235: EMPTY
101236: LIST
101237: LIST
101238: PUSH
101239: EMPTY
101240: LIST
101241: LIST
101242: PPUSH
101243: CALL_OW 69
101247: PUSH
101248: FOR_IN
101249: IFFALSE 101290
// begin for j := 1 to 4 do
101251: LD_ADDR_VAR 0 3
101255: PUSH
101256: DOUBLE
101257: LD_INT 1
101259: DEC
101260: ST_TO_ADDR
101261: LD_INT 4
101263: PUSH
101264: FOR_TO
101265: IFFALSE 101286
// SetSkill ( i , j , 10 ) ;
101267: LD_VAR 0 2
101271: PPUSH
101272: LD_VAR 0 3
101276: PPUSH
101277: LD_INT 10
101279: PPUSH
101280: CALL_OW 237
101284: GO 101264
101286: POP
101287: POP
// end ;
101288: GO 101248
101290: POP
101291: POP
// end ;
101292: LD_VAR 0 1
101296: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
101297: LD_INT 0
101299: PPUSH
// uc_side := your_side ;
101300: LD_ADDR_OWVAR 20
101304: PUSH
101305: LD_OWVAR 2
101309: ST_TO_ADDR
// uc_nation := nation ;
101310: LD_ADDR_OWVAR 21
101314: PUSH
101315: LD_VAR 0 1
101319: ST_TO_ADDR
// InitHc ;
101320: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
101324: LD_INT 0
101326: PPUSH
101327: LD_VAR 0 2
101331: PPUSH
101332: LD_VAR 0 3
101336: PPUSH
101337: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
101341: LD_VAR 0 4
101345: PPUSH
101346: LD_VAR 0 5
101350: PPUSH
101351: CALL_OW 428
101355: PUSH
101356: LD_INT 0
101358: EQUAL
101359: IFFALSE 101383
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
101361: CALL_OW 44
101365: PPUSH
101366: LD_VAR 0 4
101370: PPUSH
101371: LD_VAR 0 5
101375: PPUSH
101376: LD_INT 1
101378: PPUSH
101379: CALL_OW 48
// end ;
101383: LD_VAR 0 6
101387: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
101388: LD_INT 0
101390: PPUSH
101391: PPUSH
// uc_side := your_side ;
101392: LD_ADDR_OWVAR 20
101396: PUSH
101397: LD_OWVAR 2
101401: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
101402: LD_VAR 0 1
101406: PUSH
101407: LD_INT 1
101409: PUSH
101410: LD_INT 2
101412: PUSH
101413: LD_INT 3
101415: PUSH
101416: LD_INT 4
101418: PUSH
101419: LD_INT 5
101421: PUSH
101422: EMPTY
101423: LIST
101424: LIST
101425: LIST
101426: LIST
101427: LIST
101428: IN
101429: IFFALSE 101441
// uc_nation := nation_american else
101431: LD_ADDR_OWVAR 21
101435: PUSH
101436: LD_INT 1
101438: ST_TO_ADDR
101439: GO 101484
// if chassis in [ 11 , 12 , 13 , 14 ] then
101441: LD_VAR 0 1
101445: PUSH
101446: LD_INT 11
101448: PUSH
101449: LD_INT 12
101451: PUSH
101452: LD_INT 13
101454: PUSH
101455: LD_INT 14
101457: PUSH
101458: EMPTY
101459: LIST
101460: LIST
101461: LIST
101462: LIST
101463: IN
101464: IFFALSE 101476
// uc_nation := nation_arabian else
101466: LD_ADDR_OWVAR 21
101470: PUSH
101471: LD_INT 2
101473: ST_TO_ADDR
101474: GO 101484
// uc_nation := nation_russian ;
101476: LD_ADDR_OWVAR 21
101480: PUSH
101481: LD_INT 3
101483: ST_TO_ADDR
// vc_chassis := chassis ;
101484: LD_ADDR_OWVAR 37
101488: PUSH
101489: LD_VAR 0 1
101493: ST_TO_ADDR
// vc_engine := engine ;
101494: LD_ADDR_OWVAR 39
101498: PUSH
101499: LD_VAR 0 2
101503: ST_TO_ADDR
// vc_control := control ;
101504: LD_ADDR_OWVAR 38
101508: PUSH
101509: LD_VAR 0 3
101513: ST_TO_ADDR
// vc_weapon := weapon ;
101514: LD_ADDR_OWVAR 40
101518: PUSH
101519: LD_VAR 0 4
101523: ST_TO_ADDR
// un := CreateVehicle ;
101524: LD_ADDR_VAR 0 8
101528: PUSH
101529: CALL_OW 45
101533: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
101534: LD_VAR 0 8
101538: PPUSH
101539: LD_INT 0
101541: PPUSH
101542: LD_INT 5
101544: PPUSH
101545: CALL_OW 12
101549: PPUSH
101550: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
101554: LD_VAR 0 8
101558: PPUSH
101559: LD_VAR 0 5
101563: PPUSH
101564: LD_VAR 0 6
101568: PPUSH
101569: LD_INT 1
101571: PPUSH
101572: CALL_OW 48
// end ;
101576: LD_VAR 0 7
101580: RET
// export hInvincible ; every 1 do
101581: GO 101583
101583: DISABLE
// hInvincible := [ ] ;
101584: LD_ADDR_EXP 164
101588: PUSH
101589: EMPTY
101590: ST_TO_ADDR
101591: END
// every 10 do var i ;
101592: GO 101594
101594: DISABLE
101595: LD_INT 0
101597: PPUSH
// begin enable ;
101598: ENABLE
// if not hInvincible then
101599: LD_EXP 164
101603: NOT
101604: IFFALSE 101608
// exit ;
101606: GO 101652
// for i in hInvincible do
101608: LD_ADDR_VAR 0 1
101612: PUSH
101613: LD_EXP 164
101617: PUSH
101618: FOR_IN
101619: IFFALSE 101650
// if GetLives ( i ) < 1000 then
101621: LD_VAR 0 1
101625: PPUSH
101626: CALL_OW 256
101630: PUSH
101631: LD_INT 1000
101633: LESS
101634: IFFALSE 101648
// SetLives ( i , 1000 ) ;
101636: LD_VAR 0 1
101640: PPUSH
101641: LD_INT 1000
101643: PPUSH
101644: CALL_OW 234
101648: GO 101618
101650: POP
101651: POP
// end ;
101652: PPOPN 1
101654: END
// export function hHackInvincible ; var i ; begin
101655: LD_INT 0
101657: PPUSH
101658: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
101659: LD_ADDR_VAR 0 2
101663: PUSH
101664: LD_INT 2
101666: PUSH
101667: LD_INT 21
101669: PUSH
101670: LD_INT 1
101672: PUSH
101673: EMPTY
101674: LIST
101675: LIST
101676: PUSH
101677: LD_INT 21
101679: PUSH
101680: LD_INT 2
101682: PUSH
101683: EMPTY
101684: LIST
101685: LIST
101686: PUSH
101687: EMPTY
101688: LIST
101689: LIST
101690: LIST
101691: PPUSH
101692: CALL_OW 69
101696: PUSH
101697: FOR_IN
101698: IFFALSE 101759
// if IsSelected ( i ) then
101700: LD_VAR 0 2
101704: PPUSH
101705: CALL_OW 306
101709: IFFALSE 101757
// begin if i in hInvincible then
101711: LD_VAR 0 2
101715: PUSH
101716: LD_EXP 164
101720: IN
101721: IFFALSE 101741
// hInvincible := hInvincible diff i else
101723: LD_ADDR_EXP 164
101727: PUSH
101728: LD_EXP 164
101732: PUSH
101733: LD_VAR 0 2
101737: DIFF
101738: ST_TO_ADDR
101739: GO 101757
// hInvincible := hInvincible union i ;
101741: LD_ADDR_EXP 164
101745: PUSH
101746: LD_EXP 164
101750: PUSH
101751: LD_VAR 0 2
101755: UNION
101756: ST_TO_ADDR
// end ;
101757: GO 101697
101759: POP
101760: POP
// end ;
101761: LD_VAR 0 1
101765: RET
// export function hHackInvisible ; var i , j ; begin
101766: LD_INT 0
101768: PPUSH
101769: PPUSH
101770: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101771: LD_ADDR_VAR 0 2
101775: PUSH
101776: LD_INT 21
101778: PUSH
101779: LD_INT 1
101781: PUSH
101782: EMPTY
101783: LIST
101784: LIST
101785: PPUSH
101786: CALL_OW 69
101790: PUSH
101791: FOR_IN
101792: IFFALSE 101816
// if IsSelected ( i ) then
101794: LD_VAR 0 2
101798: PPUSH
101799: CALL_OW 306
101803: IFFALSE 101814
// ComForceInvisible ( i ) ;
101805: LD_VAR 0 2
101809: PPUSH
101810: CALL_OW 496
101814: GO 101791
101816: POP
101817: POP
// end ;
101818: LD_VAR 0 1
101822: RET
// export function hHackChangeYourSide ; begin
101823: LD_INT 0
101825: PPUSH
// if your_side = 8 then
101826: LD_OWVAR 2
101830: PUSH
101831: LD_INT 8
101833: EQUAL
101834: IFFALSE 101846
// your_side := 0 else
101836: LD_ADDR_OWVAR 2
101840: PUSH
101841: LD_INT 0
101843: ST_TO_ADDR
101844: GO 101860
// your_side := your_side + 1 ;
101846: LD_ADDR_OWVAR 2
101850: PUSH
101851: LD_OWVAR 2
101855: PUSH
101856: LD_INT 1
101858: PLUS
101859: ST_TO_ADDR
// end ;
101860: LD_VAR 0 1
101864: RET
// export function hHackChangeUnitSide ; var i , j ; begin
101865: LD_INT 0
101867: PPUSH
101868: PPUSH
101869: PPUSH
// for i in all_units do
101870: LD_ADDR_VAR 0 2
101874: PUSH
101875: LD_OWVAR 3
101879: PUSH
101880: FOR_IN
101881: IFFALSE 101959
// if IsSelected ( i ) then
101883: LD_VAR 0 2
101887: PPUSH
101888: CALL_OW 306
101892: IFFALSE 101957
// begin j := GetSide ( i ) ;
101894: LD_ADDR_VAR 0 3
101898: PUSH
101899: LD_VAR 0 2
101903: PPUSH
101904: CALL_OW 255
101908: ST_TO_ADDR
// if j = 8 then
101909: LD_VAR 0 3
101913: PUSH
101914: LD_INT 8
101916: EQUAL
101917: IFFALSE 101929
// j := 0 else
101919: LD_ADDR_VAR 0 3
101923: PUSH
101924: LD_INT 0
101926: ST_TO_ADDR
101927: GO 101943
// j := j + 1 ;
101929: LD_ADDR_VAR 0 3
101933: PUSH
101934: LD_VAR 0 3
101938: PUSH
101939: LD_INT 1
101941: PLUS
101942: ST_TO_ADDR
// SetSide ( i , j ) ;
101943: LD_VAR 0 2
101947: PPUSH
101948: LD_VAR 0 3
101952: PPUSH
101953: CALL_OW 235
// end ;
101957: GO 101880
101959: POP
101960: POP
// end ;
101961: LD_VAR 0 1
101965: RET
// export function hHackFog ; begin
101966: LD_INT 0
101968: PPUSH
// FogOff ( true ) ;
101969: LD_INT 1
101971: PPUSH
101972: CALL_OW 344
// end ;
101976: LD_VAR 0 1
101980: RET
// export function hHackTeleport ( unit , x , y ) ; begin
101981: LD_INT 0
101983: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
101984: LD_VAR 0 1
101988: PPUSH
101989: LD_VAR 0 2
101993: PPUSH
101994: LD_VAR 0 3
101998: PPUSH
101999: LD_INT 1
102001: PPUSH
102002: LD_INT 1
102004: PPUSH
102005: CALL_OW 483
// CenterOnXY ( x , y ) ;
102009: LD_VAR 0 2
102013: PPUSH
102014: LD_VAR 0 3
102018: PPUSH
102019: CALL_OW 84
// end ;
102023: LD_VAR 0 4
102027: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
102028: LD_INT 0
102030: PPUSH
102031: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
102032: LD_VAR 0 1
102036: NOT
102037: PUSH
102038: LD_VAR 0 2
102042: PPUSH
102043: LD_VAR 0 3
102047: PPUSH
102048: CALL_OW 488
102052: NOT
102053: OR
102054: PUSH
102055: LD_VAR 0 1
102059: PPUSH
102060: CALL_OW 266
102064: PUSH
102065: LD_INT 3
102067: NONEQUAL
102068: PUSH
102069: LD_VAR 0 1
102073: PPUSH
102074: CALL_OW 247
102078: PUSH
102079: LD_INT 1
102081: EQUAL
102082: NOT
102083: AND
102084: OR
102085: IFFALSE 102089
// exit ;
102087: GO 102238
// if GetType ( factory ) = unit_human then
102089: LD_VAR 0 1
102093: PPUSH
102094: CALL_OW 247
102098: PUSH
102099: LD_INT 1
102101: EQUAL
102102: IFFALSE 102119
// factory := IsInUnit ( factory ) ;
102104: LD_ADDR_VAR 0 1
102108: PUSH
102109: LD_VAR 0 1
102113: PPUSH
102114: CALL_OW 310
102118: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
102119: LD_VAR 0 1
102123: PPUSH
102124: CALL_OW 266
102128: PUSH
102129: LD_INT 3
102131: NONEQUAL
102132: IFFALSE 102136
// exit ;
102134: GO 102238
// if HexInfo ( x , y ) = factory then
102136: LD_VAR 0 2
102140: PPUSH
102141: LD_VAR 0 3
102145: PPUSH
102146: CALL_OW 428
102150: PUSH
102151: LD_VAR 0 1
102155: EQUAL
102156: IFFALSE 102183
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
102158: LD_ADDR_EXP 165
102162: PUSH
102163: LD_EXP 165
102167: PPUSH
102168: LD_VAR 0 1
102172: PPUSH
102173: LD_INT 0
102175: PPUSH
102176: CALL_OW 1
102180: ST_TO_ADDR
102181: GO 102234
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
102183: LD_ADDR_EXP 165
102187: PUSH
102188: LD_EXP 165
102192: PPUSH
102193: LD_VAR 0 1
102197: PPUSH
102198: LD_VAR 0 1
102202: PPUSH
102203: CALL_OW 255
102207: PUSH
102208: LD_VAR 0 1
102212: PUSH
102213: LD_VAR 0 2
102217: PUSH
102218: LD_VAR 0 3
102222: PUSH
102223: EMPTY
102224: LIST
102225: LIST
102226: LIST
102227: LIST
102228: PPUSH
102229: CALL_OW 1
102233: ST_TO_ADDR
// UpdateFactoryWaypoints ;
102234: CALL 102243 0 0
// end ;
102238: LD_VAR 0 4
102242: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
102243: LD_INT 0
102245: PPUSH
102246: PPUSH
102247: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
102248: LD_STRING resetFactoryWaypoint();
102250: PPUSH
102251: CALL_OW 559
// if factoryWaypoints then
102255: LD_EXP 165
102259: IFFALSE 102385
// begin list := PrepareArray ( factoryWaypoints ) ;
102261: LD_ADDR_VAR 0 3
102265: PUSH
102266: LD_EXP 165
102270: PPUSH
102271: CALL 56529 0 1
102275: ST_TO_ADDR
// for i := 1 to list do
102276: LD_ADDR_VAR 0 2
102280: PUSH
102281: DOUBLE
102282: LD_INT 1
102284: DEC
102285: ST_TO_ADDR
102286: LD_VAR 0 3
102290: PUSH
102291: FOR_TO
102292: IFFALSE 102383
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
102294: LD_STRING setFactoryWaypointXY(
102296: PUSH
102297: LD_VAR 0 3
102301: PUSH
102302: LD_VAR 0 2
102306: ARRAY
102307: PUSH
102308: LD_INT 1
102310: ARRAY
102311: STR
102312: PUSH
102313: LD_STRING ,
102315: STR
102316: PUSH
102317: LD_VAR 0 3
102321: PUSH
102322: LD_VAR 0 2
102326: ARRAY
102327: PUSH
102328: LD_INT 2
102330: ARRAY
102331: STR
102332: PUSH
102333: LD_STRING ,
102335: STR
102336: PUSH
102337: LD_VAR 0 3
102341: PUSH
102342: LD_VAR 0 2
102346: ARRAY
102347: PUSH
102348: LD_INT 3
102350: ARRAY
102351: STR
102352: PUSH
102353: LD_STRING ,
102355: STR
102356: PUSH
102357: LD_VAR 0 3
102361: PUSH
102362: LD_VAR 0 2
102366: ARRAY
102367: PUSH
102368: LD_INT 4
102370: ARRAY
102371: STR
102372: PUSH
102373: LD_STRING )
102375: STR
102376: PPUSH
102377: CALL_OW 559
102381: GO 102291
102383: POP
102384: POP
// end ; end ;
102385: LD_VAR 0 1
102389: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
102390: LD_INT 0
102392: PPUSH
// if HexInfo ( x , y ) = warehouse then
102393: LD_VAR 0 2
102397: PPUSH
102398: LD_VAR 0 3
102402: PPUSH
102403: CALL_OW 428
102407: PUSH
102408: LD_VAR 0 1
102412: EQUAL
102413: IFFALSE 102440
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
102415: LD_ADDR_EXP 166
102419: PUSH
102420: LD_EXP 166
102424: PPUSH
102425: LD_VAR 0 1
102429: PPUSH
102430: LD_INT 0
102432: PPUSH
102433: CALL_OW 1
102437: ST_TO_ADDR
102438: GO 102491
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
102440: LD_ADDR_EXP 166
102444: PUSH
102445: LD_EXP 166
102449: PPUSH
102450: LD_VAR 0 1
102454: PPUSH
102455: LD_VAR 0 1
102459: PPUSH
102460: CALL_OW 255
102464: PUSH
102465: LD_VAR 0 1
102469: PUSH
102470: LD_VAR 0 2
102474: PUSH
102475: LD_VAR 0 3
102479: PUSH
102480: EMPTY
102481: LIST
102482: LIST
102483: LIST
102484: LIST
102485: PPUSH
102486: CALL_OW 1
102490: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
102491: CALL 102500 0 0
// end ;
102495: LD_VAR 0 4
102499: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
102500: LD_INT 0
102502: PPUSH
102503: PPUSH
102504: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
102505: LD_STRING resetWarehouseGatheringPoints();
102507: PPUSH
102508: CALL_OW 559
// if warehouseGatheringPoints then
102512: LD_EXP 166
102516: IFFALSE 102642
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
102518: LD_ADDR_VAR 0 3
102522: PUSH
102523: LD_EXP 166
102527: PPUSH
102528: CALL 56529 0 1
102532: ST_TO_ADDR
// for i := 1 to list do
102533: LD_ADDR_VAR 0 2
102537: PUSH
102538: DOUBLE
102539: LD_INT 1
102541: DEC
102542: ST_TO_ADDR
102543: LD_VAR 0 3
102547: PUSH
102548: FOR_TO
102549: IFFALSE 102640
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
102551: LD_STRING setWarehouseGatheringPointXY(
102553: PUSH
102554: LD_VAR 0 3
102558: PUSH
102559: LD_VAR 0 2
102563: ARRAY
102564: PUSH
102565: LD_INT 1
102567: ARRAY
102568: STR
102569: PUSH
102570: LD_STRING ,
102572: STR
102573: PUSH
102574: LD_VAR 0 3
102578: PUSH
102579: LD_VAR 0 2
102583: ARRAY
102584: PUSH
102585: LD_INT 2
102587: ARRAY
102588: STR
102589: PUSH
102590: LD_STRING ,
102592: STR
102593: PUSH
102594: LD_VAR 0 3
102598: PUSH
102599: LD_VAR 0 2
102603: ARRAY
102604: PUSH
102605: LD_INT 3
102607: ARRAY
102608: STR
102609: PUSH
102610: LD_STRING ,
102612: STR
102613: PUSH
102614: LD_VAR 0 3
102618: PUSH
102619: LD_VAR 0 2
102623: ARRAY
102624: PUSH
102625: LD_INT 4
102627: ARRAY
102628: STR
102629: PUSH
102630: LD_STRING )
102632: STR
102633: PPUSH
102634: CALL_OW 559
102638: GO 102548
102640: POP
102641: POP
// end ; end ;
102642: LD_VAR 0 1
102646: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
102647: LD_EXP 166
102651: IFFALSE 103336
102653: GO 102655
102655: DISABLE
102656: LD_INT 0
102658: PPUSH
102659: PPUSH
102660: PPUSH
102661: PPUSH
102662: PPUSH
102663: PPUSH
102664: PPUSH
102665: PPUSH
102666: PPUSH
// begin enable ;
102667: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
102668: LD_ADDR_VAR 0 3
102672: PUSH
102673: LD_EXP 166
102677: PPUSH
102678: CALL 56529 0 1
102682: ST_TO_ADDR
// if not list then
102683: LD_VAR 0 3
102687: NOT
102688: IFFALSE 102692
// exit ;
102690: GO 103336
// for i := 1 to list do
102692: LD_ADDR_VAR 0 1
102696: PUSH
102697: DOUBLE
102698: LD_INT 1
102700: DEC
102701: ST_TO_ADDR
102702: LD_VAR 0 3
102706: PUSH
102707: FOR_TO
102708: IFFALSE 103334
// begin depot := list [ i ] [ 2 ] ;
102710: LD_ADDR_VAR 0 8
102714: PUSH
102715: LD_VAR 0 3
102719: PUSH
102720: LD_VAR 0 1
102724: ARRAY
102725: PUSH
102726: LD_INT 2
102728: ARRAY
102729: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
102730: LD_ADDR_VAR 0 5
102734: PUSH
102735: LD_VAR 0 3
102739: PUSH
102740: LD_VAR 0 1
102744: ARRAY
102745: PUSH
102746: LD_INT 1
102748: ARRAY
102749: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
102750: LD_VAR 0 8
102754: PPUSH
102755: CALL_OW 301
102759: PUSH
102760: LD_VAR 0 5
102764: PUSH
102765: LD_VAR 0 8
102769: PPUSH
102770: CALL_OW 255
102774: NONEQUAL
102775: OR
102776: IFFALSE 102805
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
102778: LD_ADDR_EXP 166
102782: PUSH
102783: LD_EXP 166
102787: PPUSH
102788: LD_VAR 0 8
102792: PPUSH
102793: LD_INT 0
102795: PPUSH
102796: CALL_OW 1
102800: ST_TO_ADDR
// exit ;
102801: POP
102802: POP
102803: GO 103336
// end ; x := list [ i ] [ 3 ] ;
102805: LD_ADDR_VAR 0 6
102809: PUSH
102810: LD_VAR 0 3
102814: PUSH
102815: LD_VAR 0 1
102819: ARRAY
102820: PUSH
102821: LD_INT 3
102823: ARRAY
102824: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
102825: LD_ADDR_VAR 0 7
102829: PUSH
102830: LD_VAR 0 3
102834: PUSH
102835: LD_VAR 0 1
102839: ARRAY
102840: PUSH
102841: LD_INT 4
102843: ARRAY
102844: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
102845: LD_ADDR_VAR 0 9
102849: PUSH
102850: LD_VAR 0 6
102854: PPUSH
102855: LD_VAR 0 7
102859: PPUSH
102860: LD_INT 16
102862: PPUSH
102863: CALL 55117 0 3
102867: ST_TO_ADDR
// if not cratesNearbyPoint then
102868: LD_VAR 0 9
102872: NOT
102873: IFFALSE 102879
// exit ;
102875: POP
102876: POP
102877: GO 103336
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
102879: LD_ADDR_VAR 0 4
102883: PUSH
102884: LD_INT 22
102886: PUSH
102887: LD_VAR 0 5
102891: PUSH
102892: EMPTY
102893: LIST
102894: LIST
102895: PUSH
102896: LD_INT 3
102898: PUSH
102899: LD_INT 60
102901: PUSH
102902: EMPTY
102903: LIST
102904: PUSH
102905: EMPTY
102906: LIST
102907: LIST
102908: PUSH
102909: LD_INT 91
102911: PUSH
102912: LD_VAR 0 8
102916: PUSH
102917: LD_INT 6
102919: PUSH
102920: EMPTY
102921: LIST
102922: LIST
102923: LIST
102924: PUSH
102925: LD_INT 2
102927: PUSH
102928: LD_INT 25
102930: PUSH
102931: LD_INT 2
102933: PUSH
102934: EMPTY
102935: LIST
102936: LIST
102937: PUSH
102938: LD_INT 25
102940: PUSH
102941: LD_INT 16
102943: PUSH
102944: EMPTY
102945: LIST
102946: LIST
102947: PUSH
102948: EMPTY
102949: LIST
102950: LIST
102951: LIST
102952: PUSH
102953: EMPTY
102954: LIST
102955: LIST
102956: LIST
102957: LIST
102958: PPUSH
102959: CALL_OW 69
102963: PUSH
102964: LD_VAR 0 8
102968: PPUSH
102969: CALL_OW 313
102973: PPUSH
102974: LD_INT 3
102976: PUSH
102977: LD_INT 60
102979: PUSH
102980: EMPTY
102981: LIST
102982: PUSH
102983: EMPTY
102984: LIST
102985: LIST
102986: PUSH
102987: LD_INT 2
102989: PUSH
102990: LD_INT 25
102992: PUSH
102993: LD_INT 2
102995: PUSH
102996: EMPTY
102997: LIST
102998: LIST
102999: PUSH
103000: LD_INT 25
103002: PUSH
103003: LD_INT 16
103005: PUSH
103006: EMPTY
103007: LIST
103008: LIST
103009: PUSH
103010: EMPTY
103011: LIST
103012: LIST
103013: LIST
103014: PUSH
103015: EMPTY
103016: LIST
103017: LIST
103018: PPUSH
103019: CALL_OW 72
103023: UNION
103024: ST_TO_ADDR
// if tmp then
103025: LD_VAR 0 4
103029: IFFALSE 103109
// begin tmp := ShrinkArray ( tmp , 3 ) ;
103031: LD_ADDR_VAR 0 4
103035: PUSH
103036: LD_VAR 0 4
103040: PPUSH
103041: LD_INT 3
103043: PPUSH
103044: CALL 53086 0 2
103048: ST_TO_ADDR
// for j in tmp do
103049: LD_ADDR_VAR 0 2
103053: PUSH
103054: LD_VAR 0 4
103058: PUSH
103059: FOR_IN
103060: IFFALSE 103103
// begin if IsInUnit ( j ) then
103062: LD_VAR 0 2
103066: PPUSH
103067: CALL_OW 310
103071: IFFALSE 103082
// ComExit ( j ) ;
103073: LD_VAR 0 2
103077: PPUSH
103078: CALL 53169 0 1
// AddComCollect ( j , x , y ) ;
103082: LD_VAR 0 2
103086: PPUSH
103087: LD_VAR 0 6
103091: PPUSH
103092: LD_VAR 0 7
103096: PPUSH
103097: CALL_OW 177
// end ;
103101: GO 103059
103103: POP
103104: POP
// exit ;
103105: POP
103106: POP
103107: GO 103336
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
103109: LD_ADDR_VAR 0 4
103113: PUSH
103114: LD_INT 22
103116: PUSH
103117: LD_VAR 0 5
103121: PUSH
103122: EMPTY
103123: LIST
103124: LIST
103125: PUSH
103126: LD_INT 91
103128: PUSH
103129: LD_VAR 0 8
103133: PUSH
103134: LD_INT 8
103136: PUSH
103137: EMPTY
103138: LIST
103139: LIST
103140: LIST
103141: PUSH
103142: LD_INT 2
103144: PUSH
103145: LD_INT 34
103147: PUSH
103148: LD_INT 12
103150: PUSH
103151: EMPTY
103152: LIST
103153: LIST
103154: PUSH
103155: LD_INT 34
103157: PUSH
103158: LD_INT 51
103160: PUSH
103161: EMPTY
103162: LIST
103163: LIST
103164: PUSH
103165: LD_INT 34
103167: PUSH
103168: LD_INT 32
103170: PUSH
103171: EMPTY
103172: LIST
103173: LIST
103174: PUSH
103175: LD_INT 34
103177: PUSH
103178: LD_INT 89
103180: PUSH
103181: EMPTY
103182: LIST
103183: LIST
103184: PUSH
103185: EMPTY
103186: LIST
103187: LIST
103188: LIST
103189: LIST
103190: LIST
103191: PUSH
103192: EMPTY
103193: LIST
103194: LIST
103195: LIST
103196: PPUSH
103197: CALL_OW 69
103201: ST_TO_ADDR
// if tmp then
103202: LD_VAR 0 4
103206: IFFALSE 103332
// begin for j in tmp do
103208: LD_ADDR_VAR 0 2
103212: PUSH
103213: LD_VAR 0 4
103217: PUSH
103218: FOR_IN
103219: IFFALSE 103330
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
103221: LD_VAR 0 2
103225: PPUSH
103226: CALL_OW 262
103230: PUSH
103231: LD_INT 3
103233: EQUAL
103234: PUSH
103235: LD_VAR 0 2
103239: PPUSH
103240: CALL_OW 261
103244: PUSH
103245: LD_INT 20
103247: GREATER
103248: OR
103249: PUSH
103250: LD_VAR 0 2
103254: PPUSH
103255: CALL_OW 314
103259: NOT
103260: AND
103261: PUSH
103262: LD_VAR 0 2
103266: PPUSH
103267: CALL_OW 263
103271: PUSH
103272: LD_INT 1
103274: NONEQUAL
103275: PUSH
103276: LD_VAR 0 2
103280: PPUSH
103281: CALL_OW 311
103285: OR
103286: AND
103287: IFFALSE 103328
// begin ComCollect ( j , x , y ) ;
103289: LD_VAR 0 2
103293: PPUSH
103294: LD_VAR 0 6
103298: PPUSH
103299: LD_VAR 0 7
103303: PPUSH
103304: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
103308: LD_VAR 0 2
103312: PPUSH
103313: LD_VAR 0 8
103317: PPUSH
103318: CALL_OW 172
// exit ;
103322: POP
103323: POP
103324: POP
103325: POP
103326: GO 103336
// end ;
103328: GO 103218
103330: POP
103331: POP
// end ; end ;
103332: GO 102707
103334: POP
103335: POP
// end ; end_of_file
103336: PPOPN 9
103338: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
103339: LD_INT 0
103341: PPUSH
103342: PPUSH
103343: PPUSH
103344: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
103345: LD_VAR 0 1
103349: PPUSH
103350: CALL_OW 264
103354: PUSH
103355: LD_INT 91
103357: EQUAL
103358: IFFALSE 103430
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
103360: LD_INT 68
103362: PPUSH
103363: LD_VAR 0 1
103367: PPUSH
103368: CALL_OW 255
103372: PPUSH
103373: CALL_OW 321
103377: PUSH
103378: LD_INT 2
103380: EQUAL
103381: IFFALSE 103393
// eff := 70 else
103383: LD_ADDR_VAR 0 4
103387: PUSH
103388: LD_INT 70
103390: ST_TO_ADDR
103391: GO 103401
// eff := 30 ;
103393: LD_ADDR_VAR 0 4
103397: PUSH
103398: LD_INT 30
103400: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
103401: LD_VAR 0 1
103405: PPUSH
103406: CALL_OW 250
103410: PPUSH
103411: LD_VAR 0 1
103415: PPUSH
103416: CALL_OW 251
103420: PPUSH
103421: LD_VAR 0 4
103425: PPUSH
103426: CALL_OW 495
// end ; end ;
103430: LD_VAR 0 2
103434: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
103435: LD_INT 0
103437: PPUSH
// end ;
103438: LD_VAR 0 4
103442: RET
// export function SOS_Command ( cmd ) ; begin
103443: LD_INT 0
103445: PPUSH
// end ;
103446: LD_VAR 0 2
103450: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
103451: LD_INT 0
103453: PPUSH
// end ;
103454: LD_VAR 0 6
103458: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
103459: LD_INT 0
103461: PPUSH
103462: PPUSH
// if not vehicle or not factory then
103463: LD_VAR 0 1
103467: NOT
103468: PUSH
103469: LD_VAR 0 2
103473: NOT
103474: OR
103475: IFFALSE 103479
// exit ;
103477: GO 103710
// if factoryWaypoints >= factory then
103479: LD_EXP 165
103483: PUSH
103484: LD_VAR 0 2
103488: GREATEREQUAL
103489: IFFALSE 103710
// if factoryWaypoints [ factory ] then
103491: LD_EXP 165
103495: PUSH
103496: LD_VAR 0 2
103500: ARRAY
103501: IFFALSE 103710
// begin if GetControl ( vehicle ) = control_manual then
103503: LD_VAR 0 1
103507: PPUSH
103508: CALL_OW 263
103512: PUSH
103513: LD_INT 1
103515: EQUAL
103516: IFFALSE 103597
// begin driver := IsDrivenBy ( vehicle ) ;
103518: LD_ADDR_VAR 0 4
103522: PUSH
103523: LD_VAR 0 1
103527: PPUSH
103528: CALL_OW 311
103532: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103533: LD_VAR 0 4
103537: PPUSH
103538: LD_EXP 165
103542: PUSH
103543: LD_VAR 0 2
103547: ARRAY
103548: PUSH
103549: LD_INT 3
103551: ARRAY
103552: PPUSH
103553: LD_EXP 165
103557: PUSH
103558: LD_VAR 0 2
103562: ARRAY
103563: PUSH
103564: LD_INT 4
103566: ARRAY
103567: PPUSH
103568: CALL_OW 171
// AddComExitVehicle ( driver ) ;
103572: LD_VAR 0 4
103576: PPUSH
103577: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
103581: LD_VAR 0 4
103585: PPUSH
103586: LD_VAR 0 2
103590: PPUSH
103591: CALL_OW 180
// end else
103595: GO 103710
// if GetControl ( vehicle ) = control_remote then
103597: LD_VAR 0 1
103601: PPUSH
103602: CALL_OW 263
103606: PUSH
103607: LD_INT 2
103609: EQUAL
103610: IFFALSE 103671
// begin wait ( 0 0$2 ) ;
103612: LD_INT 70
103614: PPUSH
103615: CALL_OW 67
// if Connect ( vehicle ) then
103619: LD_VAR 0 1
103623: PPUSH
103624: CALL 23410 0 1
103628: IFFALSE 103669
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103630: LD_VAR 0 1
103634: PPUSH
103635: LD_EXP 165
103639: PUSH
103640: LD_VAR 0 2
103644: ARRAY
103645: PUSH
103646: LD_INT 3
103648: ARRAY
103649: PPUSH
103650: LD_EXP 165
103654: PUSH
103655: LD_VAR 0 2
103659: ARRAY
103660: PUSH
103661: LD_INT 4
103663: ARRAY
103664: PPUSH
103665: CALL_OW 171
// end else
103669: GO 103710
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103671: LD_VAR 0 1
103675: PPUSH
103676: LD_EXP 165
103680: PUSH
103681: LD_VAR 0 2
103685: ARRAY
103686: PUSH
103687: LD_INT 3
103689: ARRAY
103690: PPUSH
103691: LD_EXP 165
103695: PUSH
103696: LD_VAR 0 2
103700: ARRAY
103701: PUSH
103702: LD_INT 4
103704: ARRAY
103705: PPUSH
103706: CALL_OW 171
// end ; end ;
103710: LD_VAR 0 3
103714: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
103715: LD_INT 0
103717: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
103718: LD_VAR 0 1
103722: PUSH
103723: LD_INT 250
103725: EQUAL
103726: PUSH
103727: LD_VAR 0 2
103731: PPUSH
103732: CALL_OW 264
103736: PUSH
103737: LD_INT 81
103739: EQUAL
103740: AND
103741: IFFALSE 103762
// MinerPlaceMine ( unit , x , y ) ;
103743: LD_VAR 0 2
103747: PPUSH
103748: LD_VAR 0 4
103752: PPUSH
103753: LD_VAR 0 5
103757: PPUSH
103758: CALL 106147 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
103762: LD_VAR 0 1
103766: PUSH
103767: LD_INT 251
103769: EQUAL
103770: PUSH
103771: LD_VAR 0 2
103775: PPUSH
103776: CALL_OW 264
103780: PUSH
103781: LD_INT 81
103783: EQUAL
103784: AND
103785: IFFALSE 103806
// MinerDetonateMine ( unit , x , y ) ;
103787: LD_VAR 0 2
103791: PPUSH
103792: LD_VAR 0 4
103796: PPUSH
103797: LD_VAR 0 5
103801: PPUSH
103802: CALL 106422 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
103806: LD_VAR 0 1
103810: PUSH
103811: LD_INT 252
103813: EQUAL
103814: PUSH
103815: LD_VAR 0 2
103819: PPUSH
103820: CALL_OW 264
103824: PUSH
103825: LD_INT 81
103827: EQUAL
103828: AND
103829: IFFALSE 103850
// MinerCreateMinefield ( unit , x , y ) ;
103831: LD_VAR 0 2
103835: PPUSH
103836: LD_VAR 0 4
103840: PPUSH
103841: LD_VAR 0 5
103845: PPUSH
103846: CALL 106839 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
103850: LD_VAR 0 1
103854: PUSH
103855: LD_INT 253
103857: EQUAL
103858: PUSH
103859: LD_VAR 0 2
103863: PPUSH
103864: CALL_OW 257
103868: PUSH
103869: LD_INT 5
103871: EQUAL
103872: AND
103873: IFFALSE 103894
// ComBinocular ( unit , x , y ) ;
103875: LD_VAR 0 2
103879: PPUSH
103880: LD_VAR 0 4
103884: PPUSH
103885: LD_VAR 0 5
103889: PPUSH
103890: CALL 107208 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
103894: LD_VAR 0 1
103898: PUSH
103899: LD_INT 254
103901: EQUAL
103902: PUSH
103903: LD_VAR 0 2
103907: PPUSH
103908: CALL_OW 264
103912: PUSH
103913: LD_INT 99
103915: EQUAL
103916: AND
103917: PUSH
103918: LD_VAR 0 3
103922: PPUSH
103923: CALL_OW 263
103927: PUSH
103928: LD_INT 3
103930: EQUAL
103931: AND
103932: IFFALSE 103948
// HackDestroyVehicle ( unit , selectedUnit ) ;
103934: LD_VAR 0 2
103938: PPUSH
103939: LD_VAR 0 3
103943: PPUSH
103944: CALL 105511 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
103948: LD_VAR 0 1
103952: PUSH
103953: LD_INT 255
103955: EQUAL
103956: PUSH
103957: LD_VAR 0 2
103961: PPUSH
103962: CALL_OW 264
103966: PUSH
103967: LD_INT 14
103969: PUSH
103970: LD_INT 53
103972: PUSH
103973: EMPTY
103974: LIST
103975: LIST
103976: IN
103977: AND
103978: PUSH
103979: LD_VAR 0 4
103983: PPUSH
103984: LD_VAR 0 5
103988: PPUSH
103989: CALL_OW 488
103993: AND
103994: IFFALSE 104018
// CutTreeXYR ( unit , x , y , 12 ) ;
103996: LD_VAR 0 2
104000: PPUSH
104001: LD_VAR 0 4
104005: PPUSH
104006: LD_VAR 0 5
104010: PPUSH
104011: LD_INT 12
104013: PPUSH
104014: CALL 104081 0 4
// if cmd = 256 then
104018: LD_VAR 0 1
104022: PUSH
104023: LD_INT 256
104025: EQUAL
104026: IFFALSE 104047
// SetFactoryWaypoint ( unit , x , y ) ;
104028: LD_VAR 0 2
104032: PPUSH
104033: LD_VAR 0 4
104037: PPUSH
104038: LD_VAR 0 5
104042: PPUSH
104043: CALL 102028 0 3
// if cmd = 257 then
104047: LD_VAR 0 1
104051: PUSH
104052: LD_INT 257
104054: EQUAL
104055: IFFALSE 104076
// SetWarehouseGatheringPoint ( unit , x , y ) ;
104057: LD_VAR 0 2
104061: PPUSH
104062: LD_VAR 0 4
104066: PPUSH
104067: LD_VAR 0 5
104071: PPUSH
104072: CALL 102390 0 3
// end ;
104076: LD_VAR 0 6
104080: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
104081: LD_INT 0
104083: PPUSH
104084: PPUSH
104085: PPUSH
104086: PPUSH
104087: PPUSH
104088: PPUSH
104089: PPUSH
104090: PPUSH
104091: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
104092: LD_VAR 0 1
104096: NOT
104097: PUSH
104098: LD_VAR 0 2
104102: PPUSH
104103: LD_VAR 0 3
104107: PPUSH
104108: CALL_OW 488
104112: NOT
104113: OR
104114: PUSH
104115: LD_VAR 0 4
104119: NOT
104120: OR
104121: IFFALSE 104125
// exit ;
104123: GO 104465
// list := [ ] ;
104125: LD_ADDR_VAR 0 13
104129: PUSH
104130: EMPTY
104131: ST_TO_ADDR
// if x - r < 0 then
104132: LD_VAR 0 2
104136: PUSH
104137: LD_VAR 0 4
104141: MINUS
104142: PUSH
104143: LD_INT 0
104145: LESS
104146: IFFALSE 104158
// min_x := 0 else
104148: LD_ADDR_VAR 0 7
104152: PUSH
104153: LD_INT 0
104155: ST_TO_ADDR
104156: GO 104174
// min_x := x - r ;
104158: LD_ADDR_VAR 0 7
104162: PUSH
104163: LD_VAR 0 2
104167: PUSH
104168: LD_VAR 0 4
104172: MINUS
104173: ST_TO_ADDR
// if y - r < 0 then
104174: LD_VAR 0 3
104178: PUSH
104179: LD_VAR 0 4
104183: MINUS
104184: PUSH
104185: LD_INT 0
104187: LESS
104188: IFFALSE 104200
// min_y := 0 else
104190: LD_ADDR_VAR 0 8
104194: PUSH
104195: LD_INT 0
104197: ST_TO_ADDR
104198: GO 104216
// min_y := y - r ;
104200: LD_ADDR_VAR 0 8
104204: PUSH
104205: LD_VAR 0 3
104209: PUSH
104210: LD_VAR 0 4
104214: MINUS
104215: ST_TO_ADDR
// max_x := x + r ;
104216: LD_ADDR_VAR 0 9
104220: PUSH
104221: LD_VAR 0 2
104225: PUSH
104226: LD_VAR 0 4
104230: PLUS
104231: ST_TO_ADDR
// max_y := y + r ;
104232: LD_ADDR_VAR 0 10
104236: PUSH
104237: LD_VAR 0 3
104241: PUSH
104242: LD_VAR 0 4
104246: PLUS
104247: ST_TO_ADDR
// for _x = min_x to max_x do
104248: LD_ADDR_VAR 0 11
104252: PUSH
104253: DOUBLE
104254: LD_VAR 0 7
104258: DEC
104259: ST_TO_ADDR
104260: LD_VAR 0 9
104264: PUSH
104265: FOR_TO
104266: IFFALSE 104383
// for _y = min_y to max_y do
104268: LD_ADDR_VAR 0 12
104272: PUSH
104273: DOUBLE
104274: LD_VAR 0 8
104278: DEC
104279: ST_TO_ADDR
104280: LD_VAR 0 10
104284: PUSH
104285: FOR_TO
104286: IFFALSE 104379
// begin if not ValidHex ( _x , _y ) then
104288: LD_VAR 0 11
104292: PPUSH
104293: LD_VAR 0 12
104297: PPUSH
104298: CALL_OW 488
104302: NOT
104303: IFFALSE 104307
// continue ;
104305: GO 104285
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
104307: LD_VAR 0 11
104311: PPUSH
104312: LD_VAR 0 12
104316: PPUSH
104317: CALL_OW 351
104321: PUSH
104322: LD_VAR 0 11
104326: PPUSH
104327: LD_VAR 0 12
104331: PPUSH
104332: CALL_OW 554
104336: AND
104337: IFFALSE 104377
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
104339: LD_ADDR_VAR 0 13
104343: PUSH
104344: LD_VAR 0 13
104348: PPUSH
104349: LD_VAR 0 13
104353: PUSH
104354: LD_INT 1
104356: PLUS
104357: PPUSH
104358: LD_VAR 0 11
104362: PUSH
104363: LD_VAR 0 12
104367: PUSH
104368: EMPTY
104369: LIST
104370: LIST
104371: PPUSH
104372: CALL_OW 2
104376: ST_TO_ADDR
// end ;
104377: GO 104285
104379: POP
104380: POP
104381: GO 104265
104383: POP
104384: POP
// if not list then
104385: LD_VAR 0 13
104389: NOT
104390: IFFALSE 104394
// exit ;
104392: GO 104465
// for i in list do
104394: LD_ADDR_VAR 0 6
104398: PUSH
104399: LD_VAR 0 13
104403: PUSH
104404: FOR_IN
104405: IFFALSE 104463
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
104407: LD_VAR 0 1
104411: PPUSH
104412: LD_STRING M
104414: PUSH
104415: LD_VAR 0 6
104419: PUSH
104420: LD_INT 1
104422: ARRAY
104423: PUSH
104424: LD_VAR 0 6
104428: PUSH
104429: LD_INT 2
104431: ARRAY
104432: PUSH
104433: LD_INT 0
104435: PUSH
104436: LD_INT 0
104438: PUSH
104439: LD_INT 0
104441: PUSH
104442: LD_INT 0
104444: PUSH
104445: EMPTY
104446: LIST
104447: LIST
104448: LIST
104449: LIST
104450: LIST
104451: LIST
104452: LIST
104453: PUSH
104454: EMPTY
104455: LIST
104456: PPUSH
104457: CALL_OW 447
104461: GO 104404
104463: POP
104464: POP
// end ;
104465: LD_VAR 0 5
104469: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
104470: LD_EXP 168
104474: NOT
104475: IFFALSE 104525
104477: GO 104479
104479: DISABLE
// begin initHack := true ;
104480: LD_ADDR_EXP 168
104484: PUSH
104485: LD_INT 1
104487: ST_TO_ADDR
// hackTanks := [ ] ;
104488: LD_ADDR_EXP 169
104492: PUSH
104493: EMPTY
104494: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
104495: LD_ADDR_EXP 170
104499: PUSH
104500: EMPTY
104501: ST_TO_ADDR
// hackLimit := 3 ;
104502: LD_ADDR_EXP 171
104506: PUSH
104507: LD_INT 3
104509: ST_TO_ADDR
// hackDist := 12 ;
104510: LD_ADDR_EXP 172
104514: PUSH
104515: LD_INT 12
104517: ST_TO_ADDR
// hackCounter := [ ] ;
104518: LD_ADDR_EXP 173
104522: PUSH
104523: EMPTY
104524: ST_TO_ADDR
// end ;
104525: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
104526: LD_EXP 168
104530: PUSH
104531: LD_INT 34
104533: PUSH
104534: LD_INT 99
104536: PUSH
104537: EMPTY
104538: LIST
104539: LIST
104540: PPUSH
104541: CALL_OW 69
104545: AND
104546: IFFALSE 104799
104548: GO 104550
104550: DISABLE
104551: LD_INT 0
104553: PPUSH
104554: PPUSH
// begin enable ;
104555: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
104556: LD_ADDR_VAR 0 1
104560: PUSH
104561: LD_INT 34
104563: PUSH
104564: LD_INT 99
104566: PUSH
104567: EMPTY
104568: LIST
104569: LIST
104570: PPUSH
104571: CALL_OW 69
104575: PUSH
104576: FOR_IN
104577: IFFALSE 104797
// begin if not i in hackTanks then
104579: LD_VAR 0 1
104583: PUSH
104584: LD_EXP 169
104588: IN
104589: NOT
104590: IFFALSE 104673
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
104592: LD_ADDR_EXP 169
104596: PUSH
104597: LD_EXP 169
104601: PPUSH
104602: LD_EXP 169
104606: PUSH
104607: LD_INT 1
104609: PLUS
104610: PPUSH
104611: LD_VAR 0 1
104615: PPUSH
104616: CALL_OW 1
104620: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
104621: LD_ADDR_EXP 170
104625: PUSH
104626: LD_EXP 170
104630: PPUSH
104631: LD_EXP 170
104635: PUSH
104636: LD_INT 1
104638: PLUS
104639: PPUSH
104640: EMPTY
104641: PPUSH
104642: CALL_OW 1
104646: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
104647: LD_ADDR_EXP 173
104651: PUSH
104652: LD_EXP 173
104656: PPUSH
104657: LD_EXP 173
104661: PUSH
104662: LD_INT 1
104664: PLUS
104665: PPUSH
104666: EMPTY
104667: PPUSH
104668: CALL_OW 1
104672: ST_TO_ADDR
// end ; if not IsOk ( i ) then
104673: LD_VAR 0 1
104677: PPUSH
104678: CALL_OW 302
104682: NOT
104683: IFFALSE 104696
// begin HackUnlinkAll ( i ) ;
104685: LD_VAR 0 1
104689: PPUSH
104690: CALL 104802 0 1
// continue ;
104694: GO 104576
// end ; HackCheckCapturedStatus ( i ) ;
104696: LD_VAR 0 1
104700: PPUSH
104701: CALL 105245 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
104705: LD_ADDR_VAR 0 2
104709: PUSH
104710: LD_INT 81
104712: PUSH
104713: LD_VAR 0 1
104717: PPUSH
104718: CALL_OW 255
104722: PUSH
104723: EMPTY
104724: LIST
104725: LIST
104726: PUSH
104727: LD_INT 33
104729: PUSH
104730: LD_INT 3
104732: PUSH
104733: EMPTY
104734: LIST
104735: LIST
104736: PUSH
104737: LD_INT 91
104739: PUSH
104740: LD_VAR 0 1
104744: PUSH
104745: LD_EXP 172
104749: PUSH
104750: EMPTY
104751: LIST
104752: LIST
104753: LIST
104754: PUSH
104755: LD_INT 50
104757: PUSH
104758: EMPTY
104759: LIST
104760: PUSH
104761: EMPTY
104762: LIST
104763: LIST
104764: LIST
104765: LIST
104766: PPUSH
104767: CALL_OW 69
104771: ST_TO_ADDR
// if not tmp then
104772: LD_VAR 0 2
104776: NOT
104777: IFFALSE 104781
// continue ;
104779: GO 104576
// HackLink ( i , tmp ) ;
104781: LD_VAR 0 1
104785: PPUSH
104786: LD_VAR 0 2
104790: PPUSH
104791: CALL 104938 0 2
// end ;
104795: GO 104576
104797: POP
104798: POP
// end ;
104799: PPOPN 2
104801: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
104802: LD_INT 0
104804: PPUSH
104805: PPUSH
104806: PPUSH
// if not hack in hackTanks then
104807: LD_VAR 0 1
104811: PUSH
104812: LD_EXP 169
104816: IN
104817: NOT
104818: IFFALSE 104822
// exit ;
104820: GO 104933
// index := GetElementIndex ( hackTanks , hack ) ;
104822: LD_ADDR_VAR 0 4
104826: PUSH
104827: LD_EXP 169
104831: PPUSH
104832: LD_VAR 0 1
104836: PPUSH
104837: CALL 20226 0 2
104841: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
104842: LD_EXP 170
104846: PUSH
104847: LD_VAR 0 4
104851: ARRAY
104852: IFFALSE 104933
// begin for i in hackTanksCaptured [ index ] do
104854: LD_ADDR_VAR 0 3
104858: PUSH
104859: LD_EXP 170
104863: PUSH
104864: LD_VAR 0 4
104868: ARRAY
104869: PUSH
104870: FOR_IN
104871: IFFALSE 104897
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
104873: LD_VAR 0 3
104877: PUSH
104878: LD_INT 1
104880: ARRAY
104881: PPUSH
104882: LD_VAR 0 3
104886: PUSH
104887: LD_INT 2
104889: ARRAY
104890: PPUSH
104891: CALL_OW 235
104895: GO 104870
104897: POP
104898: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
104899: LD_ADDR_EXP 170
104903: PUSH
104904: LD_EXP 170
104908: PPUSH
104909: LD_VAR 0 4
104913: PPUSH
104914: EMPTY
104915: PPUSH
104916: CALL_OW 1
104920: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
104921: LD_VAR 0 1
104925: PPUSH
104926: LD_INT 0
104928: PPUSH
104929: CALL_OW 505
// end ; end ;
104933: LD_VAR 0 2
104937: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
104938: LD_INT 0
104940: PPUSH
104941: PPUSH
104942: PPUSH
// if not hack in hackTanks or not vehicles then
104943: LD_VAR 0 1
104947: PUSH
104948: LD_EXP 169
104952: IN
104953: NOT
104954: PUSH
104955: LD_VAR 0 2
104959: NOT
104960: OR
104961: IFFALSE 104965
// exit ;
104963: GO 105240
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
104965: LD_ADDR_VAR 0 2
104969: PUSH
104970: LD_VAR 0 1
104974: PPUSH
104975: LD_VAR 0 2
104979: PPUSH
104980: LD_INT 1
104982: PPUSH
104983: LD_INT 1
104985: PPUSH
104986: CALL 20876 0 4
104990: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
104991: LD_ADDR_VAR 0 5
104995: PUSH
104996: LD_EXP 169
105000: PPUSH
105001: LD_VAR 0 1
105005: PPUSH
105006: CALL 20226 0 2
105010: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
105011: LD_EXP 170
105015: PUSH
105016: LD_VAR 0 5
105020: ARRAY
105021: PUSH
105022: LD_EXP 171
105026: LESS
105027: IFFALSE 105216
// begin for i := 1 to vehicles do
105029: LD_ADDR_VAR 0 4
105033: PUSH
105034: DOUBLE
105035: LD_INT 1
105037: DEC
105038: ST_TO_ADDR
105039: LD_VAR 0 2
105043: PUSH
105044: FOR_TO
105045: IFFALSE 105214
// begin if hackTanksCaptured [ index ] = hackLimit then
105047: LD_EXP 170
105051: PUSH
105052: LD_VAR 0 5
105056: ARRAY
105057: PUSH
105058: LD_EXP 171
105062: EQUAL
105063: IFFALSE 105067
// break ;
105065: GO 105214
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
105067: LD_ADDR_EXP 173
105071: PUSH
105072: LD_EXP 173
105076: PPUSH
105077: LD_VAR 0 5
105081: PPUSH
105082: LD_EXP 173
105086: PUSH
105087: LD_VAR 0 5
105091: ARRAY
105092: PUSH
105093: LD_INT 1
105095: PLUS
105096: PPUSH
105097: CALL_OW 1
105101: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
105102: LD_ADDR_EXP 170
105106: PUSH
105107: LD_EXP 170
105111: PPUSH
105112: LD_VAR 0 5
105116: PUSH
105117: LD_EXP 170
105121: PUSH
105122: LD_VAR 0 5
105126: ARRAY
105127: PUSH
105128: LD_INT 1
105130: PLUS
105131: PUSH
105132: EMPTY
105133: LIST
105134: LIST
105135: PPUSH
105136: LD_VAR 0 2
105140: PUSH
105141: LD_VAR 0 4
105145: ARRAY
105146: PUSH
105147: LD_VAR 0 2
105151: PUSH
105152: LD_VAR 0 4
105156: ARRAY
105157: PPUSH
105158: CALL_OW 255
105162: PUSH
105163: EMPTY
105164: LIST
105165: LIST
105166: PPUSH
105167: CALL 20441 0 3
105171: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
105172: LD_VAR 0 2
105176: PUSH
105177: LD_VAR 0 4
105181: ARRAY
105182: PPUSH
105183: LD_VAR 0 1
105187: PPUSH
105188: CALL_OW 255
105192: PPUSH
105193: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
105197: LD_VAR 0 2
105201: PUSH
105202: LD_VAR 0 4
105206: ARRAY
105207: PPUSH
105208: CALL_OW 141
// end ;
105212: GO 105044
105214: POP
105215: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
105216: LD_VAR 0 1
105220: PPUSH
105221: LD_EXP 170
105225: PUSH
105226: LD_VAR 0 5
105230: ARRAY
105231: PUSH
105232: LD_INT 0
105234: PLUS
105235: PPUSH
105236: CALL_OW 505
// end ;
105240: LD_VAR 0 3
105244: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
105245: LD_INT 0
105247: PPUSH
105248: PPUSH
105249: PPUSH
105250: PPUSH
// if not hack in hackTanks then
105251: LD_VAR 0 1
105255: PUSH
105256: LD_EXP 169
105260: IN
105261: NOT
105262: IFFALSE 105266
// exit ;
105264: GO 105506
// index := GetElementIndex ( hackTanks , hack ) ;
105266: LD_ADDR_VAR 0 4
105270: PUSH
105271: LD_EXP 169
105275: PPUSH
105276: LD_VAR 0 1
105280: PPUSH
105281: CALL 20226 0 2
105285: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
105286: LD_ADDR_VAR 0 3
105290: PUSH
105291: DOUBLE
105292: LD_EXP 170
105296: PUSH
105297: LD_VAR 0 4
105301: ARRAY
105302: INC
105303: ST_TO_ADDR
105304: LD_INT 1
105306: PUSH
105307: FOR_DOWNTO
105308: IFFALSE 105480
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
105310: LD_ADDR_VAR 0 5
105314: PUSH
105315: LD_EXP 170
105319: PUSH
105320: LD_VAR 0 4
105324: ARRAY
105325: PUSH
105326: LD_VAR 0 3
105330: ARRAY
105331: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
105332: LD_VAR 0 5
105336: PUSH
105337: LD_INT 1
105339: ARRAY
105340: PPUSH
105341: CALL_OW 302
105345: NOT
105346: PUSH
105347: LD_VAR 0 5
105351: PUSH
105352: LD_INT 1
105354: ARRAY
105355: PPUSH
105356: CALL_OW 255
105360: PUSH
105361: LD_VAR 0 1
105365: PPUSH
105366: CALL_OW 255
105370: NONEQUAL
105371: OR
105372: IFFALSE 105478
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
105374: LD_VAR 0 5
105378: PUSH
105379: LD_INT 1
105381: ARRAY
105382: PPUSH
105383: CALL_OW 305
105387: PUSH
105388: LD_VAR 0 5
105392: PUSH
105393: LD_INT 1
105395: ARRAY
105396: PPUSH
105397: CALL_OW 255
105401: PUSH
105402: LD_VAR 0 1
105406: PPUSH
105407: CALL_OW 255
105411: EQUAL
105412: AND
105413: IFFALSE 105437
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
105415: LD_VAR 0 5
105419: PUSH
105420: LD_INT 1
105422: ARRAY
105423: PPUSH
105424: LD_VAR 0 5
105428: PUSH
105429: LD_INT 2
105431: ARRAY
105432: PPUSH
105433: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
105437: LD_ADDR_EXP 170
105441: PUSH
105442: LD_EXP 170
105446: PPUSH
105447: LD_VAR 0 4
105451: PPUSH
105452: LD_EXP 170
105456: PUSH
105457: LD_VAR 0 4
105461: ARRAY
105462: PPUSH
105463: LD_VAR 0 3
105467: PPUSH
105468: CALL_OW 3
105472: PPUSH
105473: CALL_OW 1
105477: ST_TO_ADDR
// end ; end ;
105478: GO 105307
105480: POP
105481: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
105482: LD_VAR 0 1
105486: PPUSH
105487: LD_EXP 170
105491: PUSH
105492: LD_VAR 0 4
105496: ARRAY
105497: PUSH
105498: LD_INT 0
105500: PLUS
105501: PPUSH
105502: CALL_OW 505
// end ;
105506: LD_VAR 0 2
105510: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
105511: LD_INT 0
105513: PPUSH
105514: PPUSH
105515: PPUSH
105516: PPUSH
// if not hack in hackTanks then
105517: LD_VAR 0 1
105521: PUSH
105522: LD_EXP 169
105526: IN
105527: NOT
105528: IFFALSE 105532
// exit ;
105530: GO 105617
// index := GetElementIndex ( hackTanks , hack ) ;
105532: LD_ADDR_VAR 0 5
105536: PUSH
105537: LD_EXP 169
105541: PPUSH
105542: LD_VAR 0 1
105546: PPUSH
105547: CALL 20226 0 2
105551: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
105552: LD_ADDR_VAR 0 4
105556: PUSH
105557: DOUBLE
105558: LD_INT 1
105560: DEC
105561: ST_TO_ADDR
105562: LD_EXP 170
105566: PUSH
105567: LD_VAR 0 5
105571: ARRAY
105572: PUSH
105573: FOR_TO
105574: IFFALSE 105615
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
105576: LD_EXP 170
105580: PUSH
105581: LD_VAR 0 5
105585: ARRAY
105586: PUSH
105587: LD_VAR 0 4
105591: ARRAY
105592: PUSH
105593: LD_INT 1
105595: ARRAY
105596: PUSH
105597: LD_VAR 0 2
105601: EQUAL
105602: IFFALSE 105613
// KillUnit ( vehicle ) ;
105604: LD_VAR 0 2
105608: PPUSH
105609: CALL_OW 66
105613: GO 105573
105615: POP
105616: POP
// end ;
105617: LD_VAR 0 3
105621: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
105622: LD_EXP 174
105626: NOT
105627: IFFALSE 105662
105629: GO 105631
105631: DISABLE
// begin initMiner := true ;
105632: LD_ADDR_EXP 174
105636: PUSH
105637: LD_INT 1
105639: ST_TO_ADDR
// minersList := [ ] ;
105640: LD_ADDR_EXP 175
105644: PUSH
105645: EMPTY
105646: ST_TO_ADDR
// minerMinesList := [ ] ;
105647: LD_ADDR_EXP 176
105651: PUSH
105652: EMPTY
105653: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
105654: LD_ADDR_EXP 177
105658: PUSH
105659: LD_INT 5
105661: ST_TO_ADDR
// end ;
105662: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
105663: LD_EXP 174
105667: PUSH
105668: LD_INT 34
105670: PUSH
105671: LD_INT 81
105673: PUSH
105674: EMPTY
105675: LIST
105676: LIST
105677: PPUSH
105678: CALL_OW 69
105682: AND
105683: IFFALSE 106144
105685: GO 105687
105687: DISABLE
105688: LD_INT 0
105690: PPUSH
105691: PPUSH
105692: PPUSH
105693: PPUSH
// begin enable ;
105694: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
105695: LD_ADDR_VAR 0 1
105699: PUSH
105700: LD_INT 34
105702: PUSH
105703: LD_INT 81
105705: PUSH
105706: EMPTY
105707: LIST
105708: LIST
105709: PPUSH
105710: CALL_OW 69
105714: PUSH
105715: FOR_IN
105716: IFFALSE 105788
// begin if not i in minersList then
105718: LD_VAR 0 1
105722: PUSH
105723: LD_EXP 175
105727: IN
105728: NOT
105729: IFFALSE 105786
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
105731: LD_ADDR_EXP 175
105735: PUSH
105736: LD_EXP 175
105740: PPUSH
105741: LD_EXP 175
105745: PUSH
105746: LD_INT 1
105748: PLUS
105749: PPUSH
105750: LD_VAR 0 1
105754: PPUSH
105755: CALL_OW 1
105759: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
105760: LD_ADDR_EXP 176
105764: PUSH
105765: LD_EXP 176
105769: PPUSH
105770: LD_EXP 176
105774: PUSH
105775: LD_INT 1
105777: PLUS
105778: PPUSH
105779: EMPTY
105780: PPUSH
105781: CALL_OW 1
105785: ST_TO_ADDR
// end end ;
105786: GO 105715
105788: POP
105789: POP
// for i := minerMinesList downto 1 do
105790: LD_ADDR_VAR 0 1
105794: PUSH
105795: DOUBLE
105796: LD_EXP 176
105800: INC
105801: ST_TO_ADDR
105802: LD_INT 1
105804: PUSH
105805: FOR_DOWNTO
105806: IFFALSE 106142
// begin if IsLive ( minersList [ i ] ) then
105808: LD_EXP 175
105812: PUSH
105813: LD_VAR 0 1
105817: ARRAY
105818: PPUSH
105819: CALL_OW 300
105823: IFFALSE 105851
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
105825: LD_EXP 175
105829: PUSH
105830: LD_VAR 0 1
105834: ARRAY
105835: PPUSH
105836: LD_EXP 176
105840: PUSH
105841: LD_VAR 0 1
105845: ARRAY
105846: PPUSH
105847: CALL_OW 505
// if not minerMinesList [ i ] then
105851: LD_EXP 176
105855: PUSH
105856: LD_VAR 0 1
105860: ARRAY
105861: NOT
105862: IFFALSE 105866
// continue ;
105864: GO 105805
// for j := minerMinesList [ i ] downto 1 do
105866: LD_ADDR_VAR 0 2
105870: PUSH
105871: DOUBLE
105872: LD_EXP 176
105876: PUSH
105877: LD_VAR 0 1
105881: ARRAY
105882: INC
105883: ST_TO_ADDR
105884: LD_INT 1
105886: PUSH
105887: FOR_DOWNTO
105888: IFFALSE 106138
// begin side := GetSide ( minersList [ i ] ) ;
105890: LD_ADDR_VAR 0 3
105894: PUSH
105895: LD_EXP 175
105899: PUSH
105900: LD_VAR 0 1
105904: ARRAY
105905: PPUSH
105906: CALL_OW 255
105910: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
105911: LD_ADDR_VAR 0 4
105915: PUSH
105916: LD_EXP 176
105920: PUSH
105921: LD_VAR 0 1
105925: ARRAY
105926: PUSH
105927: LD_VAR 0 2
105931: ARRAY
105932: PUSH
105933: LD_INT 1
105935: ARRAY
105936: PPUSH
105937: LD_EXP 176
105941: PUSH
105942: LD_VAR 0 1
105946: ARRAY
105947: PUSH
105948: LD_VAR 0 2
105952: ARRAY
105953: PUSH
105954: LD_INT 2
105956: ARRAY
105957: PPUSH
105958: CALL_OW 428
105962: ST_TO_ADDR
// if not tmp then
105963: LD_VAR 0 4
105967: NOT
105968: IFFALSE 105972
// continue ;
105970: GO 105887
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
105972: LD_VAR 0 4
105976: PUSH
105977: LD_INT 81
105979: PUSH
105980: LD_VAR 0 3
105984: PUSH
105985: EMPTY
105986: LIST
105987: LIST
105988: PPUSH
105989: CALL_OW 69
105993: IN
105994: PUSH
105995: LD_EXP 176
105999: PUSH
106000: LD_VAR 0 1
106004: ARRAY
106005: PUSH
106006: LD_VAR 0 2
106010: ARRAY
106011: PUSH
106012: LD_INT 1
106014: ARRAY
106015: PPUSH
106016: LD_EXP 176
106020: PUSH
106021: LD_VAR 0 1
106025: ARRAY
106026: PUSH
106027: LD_VAR 0 2
106031: ARRAY
106032: PUSH
106033: LD_INT 2
106035: ARRAY
106036: PPUSH
106037: CALL_OW 458
106041: AND
106042: IFFALSE 106136
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
106044: LD_EXP 176
106048: PUSH
106049: LD_VAR 0 1
106053: ARRAY
106054: PUSH
106055: LD_VAR 0 2
106059: ARRAY
106060: PUSH
106061: LD_INT 1
106063: ARRAY
106064: PPUSH
106065: LD_EXP 176
106069: PUSH
106070: LD_VAR 0 1
106074: ARRAY
106075: PUSH
106076: LD_VAR 0 2
106080: ARRAY
106081: PUSH
106082: LD_INT 2
106084: ARRAY
106085: PPUSH
106086: LD_VAR 0 3
106090: PPUSH
106091: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
106095: LD_ADDR_EXP 176
106099: PUSH
106100: LD_EXP 176
106104: PPUSH
106105: LD_VAR 0 1
106109: PPUSH
106110: LD_EXP 176
106114: PUSH
106115: LD_VAR 0 1
106119: ARRAY
106120: PPUSH
106121: LD_VAR 0 2
106125: PPUSH
106126: CALL_OW 3
106130: PPUSH
106131: CALL_OW 1
106135: ST_TO_ADDR
// end ; end ;
106136: GO 105887
106138: POP
106139: POP
// end ;
106140: GO 105805
106142: POP
106143: POP
// end ;
106144: PPOPN 4
106146: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
106147: LD_INT 0
106149: PPUSH
106150: PPUSH
// result := false ;
106151: LD_ADDR_VAR 0 4
106155: PUSH
106156: LD_INT 0
106158: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
106159: LD_VAR 0 1
106163: PPUSH
106164: CALL_OW 264
106168: PUSH
106169: LD_INT 81
106171: EQUAL
106172: NOT
106173: IFFALSE 106177
// exit ;
106175: GO 106417
// index := GetElementIndex ( minersList , unit ) ;
106177: LD_ADDR_VAR 0 5
106181: PUSH
106182: LD_EXP 175
106186: PPUSH
106187: LD_VAR 0 1
106191: PPUSH
106192: CALL 20226 0 2
106196: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
106197: LD_EXP 176
106201: PUSH
106202: LD_VAR 0 5
106206: ARRAY
106207: PUSH
106208: LD_EXP 177
106212: GREATEREQUAL
106213: IFFALSE 106217
// exit ;
106215: GO 106417
// ComMoveXY ( unit , x , y ) ;
106217: LD_VAR 0 1
106221: PPUSH
106222: LD_VAR 0 2
106226: PPUSH
106227: LD_VAR 0 3
106231: PPUSH
106232: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
106236: LD_INT 35
106238: PPUSH
106239: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
106243: LD_VAR 0 1
106247: PPUSH
106248: LD_VAR 0 2
106252: PPUSH
106253: LD_VAR 0 3
106257: PPUSH
106258: CALL 51581 0 3
106262: NOT
106263: PUSH
106264: LD_VAR 0 1
106268: PPUSH
106269: CALL_OW 314
106273: AND
106274: IFFALSE 106278
// exit ;
106276: GO 106417
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
106278: LD_VAR 0 2
106282: PPUSH
106283: LD_VAR 0 3
106287: PPUSH
106288: CALL_OW 428
106292: PUSH
106293: LD_VAR 0 1
106297: EQUAL
106298: PUSH
106299: LD_VAR 0 1
106303: PPUSH
106304: CALL_OW 314
106308: NOT
106309: AND
106310: IFFALSE 106236
// PlaySoundXY ( x , y , PlantMine ) ;
106312: LD_VAR 0 2
106316: PPUSH
106317: LD_VAR 0 3
106321: PPUSH
106322: LD_STRING PlantMine
106324: PPUSH
106325: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
106329: LD_VAR 0 2
106333: PPUSH
106334: LD_VAR 0 3
106338: PPUSH
106339: LD_VAR 0 1
106343: PPUSH
106344: CALL_OW 255
106348: PPUSH
106349: LD_INT 0
106351: PPUSH
106352: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
106356: LD_ADDR_EXP 176
106360: PUSH
106361: LD_EXP 176
106365: PPUSH
106366: LD_VAR 0 5
106370: PUSH
106371: LD_EXP 176
106375: PUSH
106376: LD_VAR 0 5
106380: ARRAY
106381: PUSH
106382: LD_INT 1
106384: PLUS
106385: PUSH
106386: EMPTY
106387: LIST
106388: LIST
106389: PPUSH
106390: LD_VAR 0 2
106394: PUSH
106395: LD_VAR 0 3
106399: PUSH
106400: EMPTY
106401: LIST
106402: LIST
106403: PPUSH
106404: CALL 20441 0 3
106408: ST_TO_ADDR
// result := true ;
106409: LD_ADDR_VAR 0 4
106413: PUSH
106414: LD_INT 1
106416: ST_TO_ADDR
// end ;
106417: LD_VAR 0 4
106421: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
106422: LD_INT 0
106424: PPUSH
106425: PPUSH
106426: PPUSH
// if not unit in minersList then
106427: LD_VAR 0 1
106431: PUSH
106432: LD_EXP 175
106436: IN
106437: NOT
106438: IFFALSE 106442
// exit ;
106440: GO 106834
// index := GetElementIndex ( minersList , unit ) ;
106442: LD_ADDR_VAR 0 6
106446: PUSH
106447: LD_EXP 175
106451: PPUSH
106452: LD_VAR 0 1
106456: PPUSH
106457: CALL 20226 0 2
106461: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
106462: LD_ADDR_VAR 0 5
106466: PUSH
106467: DOUBLE
106468: LD_EXP 176
106472: PUSH
106473: LD_VAR 0 6
106477: ARRAY
106478: INC
106479: ST_TO_ADDR
106480: LD_INT 1
106482: PUSH
106483: FOR_DOWNTO
106484: IFFALSE 106645
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
106486: LD_EXP 176
106490: PUSH
106491: LD_VAR 0 6
106495: ARRAY
106496: PUSH
106497: LD_VAR 0 5
106501: ARRAY
106502: PUSH
106503: LD_INT 1
106505: ARRAY
106506: PUSH
106507: LD_VAR 0 2
106511: EQUAL
106512: PUSH
106513: LD_EXP 176
106517: PUSH
106518: LD_VAR 0 6
106522: ARRAY
106523: PUSH
106524: LD_VAR 0 5
106528: ARRAY
106529: PUSH
106530: LD_INT 2
106532: ARRAY
106533: PUSH
106534: LD_VAR 0 3
106538: EQUAL
106539: AND
106540: IFFALSE 106643
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106542: LD_EXP 176
106546: PUSH
106547: LD_VAR 0 6
106551: ARRAY
106552: PUSH
106553: LD_VAR 0 5
106557: ARRAY
106558: PUSH
106559: LD_INT 1
106561: ARRAY
106562: PPUSH
106563: LD_EXP 176
106567: PUSH
106568: LD_VAR 0 6
106572: ARRAY
106573: PUSH
106574: LD_VAR 0 5
106578: ARRAY
106579: PUSH
106580: LD_INT 2
106582: ARRAY
106583: PPUSH
106584: LD_VAR 0 1
106588: PPUSH
106589: CALL_OW 255
106593: PPUSH
106594: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
106598: LD_ADDR_EXP 176
106602: PUSH
106603: LD_EXP 176
106607: PPUSH
106608: LD_VAR 0 6
106612: PPUSH
106613: LD_EXP 176
106617: PUSH
106618: LD_VAR 0 6
106622: ARRAY
106623: PPUSH
106624: LD_VAR 0 5
106628: PPUSH
106629: CALL_OW 3
106633: PPUSH
106634: CALL_OW 1
106638: ST_TO_ADDR
// exit ;
106639: POP
106640: POP
106641: GO 106834
// end ; end ;
106643: GO 106483
106645: POP
106646: POP
// for i := minerMinesList [ index ] downto 1 do
106647: LD_ADDR_VAR 0 5
106651: PUSH
106652: DOUBLE
106653: LD_EXP 176
106657: PUSH
106658: LD_VAR 0 6
106662: ARRAY
106663: INC
106664: ST_TO_ADDR
106665: LD_INT 1
106667: PUSH
106668: FOR_DOWNTO
106669: IFFALSE 106832
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
106671: LD_EXP 176
106675: PUSH
106676: LD_VAR 0 6
106680: ARRAY
106681: PUSH
106682: LD_VAR 0 5
106686: ARRAY
106687: PUSH
106688: LD_INT 1
106690: ARRAY
106691: PPUSH
106692: LD_EXP 176
106696: PUSH
106697: LD_VAR 0 6
106701: ARRAY
106702: PUSH
106703: LD_VAR 0 5
106707: ARRAY
106708: PUSH
106709: LD_INT 2
106711: ARRAY
106712: PPUSH
106713: LD_VAR 0 2
106717: PPUSH
106718: LD_VAR 0 3
106722: PPUSH
106723: CALL_OW 298
106727: PUSH
106728: LD_INT 6
106730: LESS
106731: IFFALSE 106830
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106733: LD_EXP 176
106737: PUSH
106738: LD_VAR 0 6
106742: ARRAY
106743: PUSH
106744: LD_VAR 0 5
106748: ARRAY
106749: PUSH
106750: LD_INT 1
106752: ARRAY
106753: PPUSH
106754: LD_EXP 176
106758: PUSH
106759: LD_VAR 0 6
106763: ARRAY
106764: PUSH
106765: LD_VAR 0 5
106769: ARRAY
106770: PUSH
106771: LD_INT 2
106773: ARRAY
106774: PPUSH
106775: LD_VAR 0 1
106779: PPUSH
106780: CALL_OW 255
106784: PPUSH
106785: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
106789: LD_ADDR_EXP 176
106793: PUSH
106794: LD_EXP 176
106798: PPUSH
106799: LD_VAR 0 6
106803: PPUSH
106804: LD_EXP 176
106808: PUSH
106809: LD_VAR 0 6
106813: ARRAY
106814: PPUSH
106815: LD_VAR 0 5
106819: PPUSH
106820: CALL_OW 3
106824: PPUSH
106825: CALL_OW 1
106829: ST_TO_ADDR
// end ; end ;
106830: GO 106668
106832: POP
106833: POP
// end ;
106834: LD_VAR 0 4
106838: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
106839: LD_INT 0
106841: PPUSH
106842: PPUSH
106843: PPUSH
106844: PPUSH
106845: PPUSH
106846: PPUSH
106847: PPUSH
106848: PPUSH
106849: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
106850: LD_VAR 0 1
106854: PPUSH
106855: CALL_OW 264
106859: PUSH
106860: LD_INT 81
106862: EQUAL
106863: NOT
106864: PUSH
106865: LD_VAR 0 1
106869: PUSH
106870: LD_EXP 175
106874: IN
106875: NOT
106876: OR
106877: IFFALSE 106881
// exit ;
106879: GO 107203
// index := GetElementIndex ( minersList , unit ) ;
106881: LD_ADDR_VAR 0 6
106885: PUSH
106886: LD_EXP 175
106890: PPUSH
106891: LD_VAR 0 1
106895: PPUSH
106896: CALL 20226 0 2
106900: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
106901: LD_ADDR_VAR 0 8
106905: PUSH
106906: LD_EXP 177
106910: PUSH
106911: LD_EXP 176
106915: PUSH
106916: LD_VAR 0 6
106920: ARRAY
106921: MINUS
106922: ST_TO_ADDR
// if not minesFreeAmount then
106923: LD_VAR 0 8
106927: NOT
106928: IFFALSE 106932
// exit ;
106930: GO 107203
// tmp := [ ] ;
106932: LD_ADDR_VAR 0 7
106936: PUSH
106937: EMPTY
106938: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
106939: LD_ADDR_VAR 0 5
106943: PUSH
106944: DOUBLE
106945: LD_INT 1
106947: DEC
106948: ST_TO_ADDR
106949: LD_VAR 0 8
106953: PUSH
106954: FOR_TO
106955: IFFALSE 107150
// begin _d := rand ( 0 , 5 ) ;
106957: LD_ADDR_VAR 0 11
106961: PUSH
106962: LD_INT 0
106964: PPUSH
106965: LD_INT 5
106967: PPUSH
106968: CALL_OW 12
106972: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
106973: LD_ADDR_VAR 0 12
106977: PUSH
106978: LD_INT 2
106980: PPUSH
106981: LD_INT 6
106983: PPUSH
106984: CALL_OW 12
106988: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
106989: LD_ADDR_VAR 0 9
106993: PUSH
106994: LD_VAR 0 2
106998: PPUSH
106999: LD_VAR 0 11
107003: PPUSH
107004: LD_VAR 0 12
107008: PPUSH
107009: CALL_OW 272
107013: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
107014: LD_ADDR_VAR 0 10
107018: PUSH
107019: LD_VAR 0 3
107023: PPUSH
107024: LD_VAR 0 11
107028: PPUSH
107029: LD_VAR 0 12
107033: PPUSH
107034: CALL_OW 273
107038: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
107039: LD_VAR 0 9
107043: PPUSH
107044: LD_VAR 0 10
107048: PPUSH
107049: CALL_OW 488
107053: PUSH
107054: LD_VAR 0 9
107058: PUSH
107059: LD_VAR 0 10
107063: PUSH
107064: EMPTY
107065: LIST
107066: LIST
107067: PUSH
107068: LD_VAR 0 7
107072: IN
107073: NOT
107074: AND
107075: PUSH
107076: LD_VAR 0 9
107080: PPUSH
107081: LD_VAR 0 10
107085: PPUSH
107086: CALL_OW 458
107090: NOT
107091: AND
107092: IFFALSE 107134
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
107094: LD_ADDR_VAR 0 7
107098: PUSH
107099: LD_VAR 0 7
107103: PPUSH
107104: LD_VAR 0 7
107108: PUSH
107109: LD_INT 1
107111: PLUS
107112: PPUSH
107113: LD_VAR 0 9
107117: PUSH
107118: LD_VAR 0 10
107122: PUSH
107123: EMPTY
107124: LIST
107125: LIST
107126: PPUSH
107127: CALL_OW 1
107131: ST_TO_ADDR
107132: GO 107148
// i := i - 1 ;
107134: LD_ADDR_VAR 0 5
107138: PUSH
107139: LD_VAR 0 5
107143: PUSH
107144: LD_INT 1
107146: MINUS
107147: ST_TO_ADDR
// end ;
107148: GO 106954
107150: POP
107151: POP
// for i in tmp do
107152: LD_ADDR_VAR 0 5
107156: PUSH
107157: LD_VAR 0 7
107161: PUSH
107162: FOR_IN
107163: IFFALSE 107201
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
107165: LD_VAR 0 1
107169: PPUSH
107170: LD_VAR 0 5
107174: PUSH
107175: LD_INT 1
107177: ARRAY
107178: PPUSH
107179: LD_VAR 0 5
107183: PUSH
107184: LD_INT 2
107186: ARRAY
107187: PPUSH
107188: CALL 106147 0 3
107192: NOT
107193: IFFALSE 107199
// exit ;
107195: POP
107196: POP
107197: GO 107203
107199: GO 107162
107201: POP
107202: POP
// end ;
107203: LD_VAR 0 4
107207: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
107208: LD_INT 0
107210: PPUSH
107211: PPUSH
107212: PPUSH
107213: PPUSH
107214: PPUSH
107215: PPUSH
107216: PPUSH
// if not GetClass ( unit ) = class_sniper then
107217: LD_VAR 0 1
107221: PPUSH
107222: CALL_OW 257
107226: PUSH
107227: LD_INT 5
107229: EQUAL
107230: NOT
107231: IFFALSE 107235
// exit ;
107233: GO 107623
// dist := 8 ;
107235: LD_ADDR_VAR 0 5
107239: PUSH
107240: LD_INT 8
107242: ST_TO_ADDR
// viewRange := 12 ;
107243: LD_ADDR_VAR 0 7
107247: PUSH
107248: LD_INT 12
107250: ST_TO_ADDR
// side := GetSide ( unit ) ;
107251: LD_ADDR_VAR 0 6
107255: PUSH
107256: LD_VAR 0 1
107260: PPUSH
107261: CALL_OW 255
107265: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
107266: LD_INT 61
107268: PPUSH
107269: LD_VAR 0 6
107273: PPUSH
107274: CALL_OW 321
107278: PUSH
107279: LD_INT 2
107281: EQUAL
107282: IFFALSE 107292
// viewRange := 16 ;
107284: LD_ADDR_VAR 0 7
107288: PUSH
107289: LD_INT 16
107291: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
107292: LD_VAR 0 1
107296: PPUSH
107297: LD_VAR 0 2
107301: PPUSH
107302: LD_VAR 0 3
107306: PPUSH
107307: CALL_OW 297
107311: PUSH
107312: LD_VAR 0 5
107316: GREATER
107317: IFFALSE 107396
// begin ComMoveXY ( unit , x , y ) ;
107319: LD_VAR 0 1
107323: PPUSH
107324: LD_VAR 0 2
107328: PPUSH
107329: LD_VAR 0 3
107333: PPUSH
107334: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
107338: LD_INT 35
107340: PPUSH
107341: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
107345: LD_VAR 0 1
107349: PPUSH
107350: LD_VAR 0 2
107354: PPUSH
107355: LD_VAR 0 3
107359: PPUSH
107360: CALL 51581 0 3
107364: NOT
107365: IFFALSE 107369
// exit ;
107367: GO 107623
// until GetDistUnitXY ( unit , x , y ) < dist ;
107369: LD_VAR 0 1
107373: PPUSH
107374: LD_VAR 0 2
107378: PPUSH
107379: LD_VAR 0 3
107383: PPUSH
107384: CALL_OW 297
107388: PUSH
107389: LD_VAR 0 5
107393: LESS
107394: IFFALSE 107338
// end ; ComTurnXY ( unit , x , y ) ;
107396: LD_VAR 0 1
107400: PPUSH
107401: LD_VAR 0 2
107405: PPUSH
107406: LD_VAR 0 3
107410: PPUSH
107411: CALL_OW 118
// wait ( 5 ) ;
107415: LD_INT 5
107417: PPUSH
107418: CALL_OW 67
// _d := GetDir ( unit ) ;
107422: LD_ADDR_VAR 0 10
107426: PUSH
107427: LD_VAR 0 1
107431: PPUSH
107432: CALL_OW 254
107436: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
107437: LD_ADDR_VAR 0 8
107441: PUSH
107442: LD_VAR 0 1
107446: PPUSH
107447: CALL_OW 250
107451: PPUSH
107452: LD_VAR 0 10
107456: PPUSH
107457: LD_VAR 0 5
107461: PPUSH
107462: CALL_OW 272
107466: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
107467: LD_ADDR_VAR 0 9
107471: PUSH
107472: LD_VAR 0 1
107476: PPUSH
107477: CALL_OW 251
107481: PPUSH
107482: LD_VAR 0 10
107486: PPUSH
107487: LD_VAR 0 5
107491: PPUSH
107492: CALL_OW 273
107496: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
107497: LD_VAR 0 8
107501: PPUSH
107502: LD_VAR 0 9
107506: PPUSH
107507: CALL_OW 488
107511: NOT
107512: IFFALSE 107516
// exit ;
107514: GO 107623
// ComAnimCustom ( unit , 1 ) ;
107516: LD_VAR 0 1
107520: PPUSH
107521: LD_INT 1
107523: PPUSH
107524: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
107528: LD_VAR 0 8
107532: PPUSH
107533: LD_VAR 0 9
107537: PPUSH
107538: LD_VAR 0 6
107542: PPUSH
107543: LD_VAR 0 7
107547: PPUSH
107548: CALL_OW 330
// repeat wait ( 1 ) ;
107552: LD_INT 1
107554: PPUSH
107555: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
107559: LD_VAR 0 1
107563: PPUSH
107564: CALL_OW 316
107568: PUSH
107569: LD_VAR 0 1
107573: PPUSH
107574: CALL_OW 314
107578: OR
107579: PUSH
107580: LD_VAR 0 1
107584: PPUSH
107585: CALL_OW 302
107589: NOT
107590: OR
107591: PUSH
107592: LD_VAR 0 1
107596: PPUSH
107597: CALL_OW 301
107601: OR
107602: IFFALSE 107552
// RemoveSeeing ( _x , _y , side ) ;
107604: LD_VAR 0 8
107608: PPUSH
107609: LD_VAR 0 9
107613: PPUSH
107614: LD_VAR 0 6
107618: PPUSH
107619: CALL_OW 331
// end ; end_of_file
107623: LD_VAR 0 4
107627: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
107628: LD_INT 0
107630: PPUSH
107631: PPUSH
107632: PPUSH
107633: PPUSH
107634: PPUSH
107635: PPUSH
107636: PPUSH
107637: PPUSH
107638: PPUSH
107639: PPUSH
107640: PPUSH
107641: PPUSH
107642: PPUSH
107643: PPUSH
107644: PPUSH
107645: PPUSH
107646: PPUSH
107647: PPUSH
107648: PPUSH
107649: PPUSH
107650: PPUSH
107651: PPUSH
107652: PPUSH
107653: PPUSH
107654: PPUSH
107655: PPUSH
107656: PPUSH
107657: PPUSH
107658: PPUSH
107659: PPUSH
107660: PPUSH
107661: PPUSH
107662: PPUSH
107663: PPUSH
// if not list then
107664: LD_VAR 0 1
107668: NOT
107669: IFFALSE 107673
// exit ;
107671: GO 112332
// base := list [ 1 ] ;
107673: LD_ADDR_VAR 0 3
107677: PUSH
107678: LD_VAR 0 1
107682: PUSH
107683: LD_INT 1
107685: ARRAY
107686: ST_TO_ADDR
// group := list [ 2 ] ;
107687: LD_ADDR_VAR 0 4
107691: PUSH
107692: LD_VAR 0 1
107696: PUSH
107697: LD_INT 2
107699: ARRAY
107700: ST_TO_ADDR
// path := list [ 3 ] ;
107701: LD_ADDR_VAR 0 5
107705: PUSH
107706: LD_VAR 0 1
107710: PUSH
107711: LD_INT 3
107713: ARRAY
107714: ST_TO_ADDR
// flags := list [ 4 ] ;
107715: LD_ADDR_VAR 0 6
107719: PUSH
107720: LD_VAR 0 1
107724: PUSH
107725: LD_INT 4
107727: ARRAY
107728: ST_TO_ADDR
// mined := [ ] ;
107729: LD_ADDR_VAR 0 27
107733: PUSH
107734: EMPTY
107735: ST_TO_ADDR
// bombed := [ ] ;
107736: LD_ADDR_VAR 0 28
107740: PUSH
107741: EMPTY
107742: ST_TO_ADDR
// healers := [ ] ;
107743: LD_ADDR_VAR 0 31
107747: PUSH
107748: EMPTY
107749: ST_TO_ADDR
// to_heal := [ ] ;
107750: LD_ADDR_VAR 0 30
107754: PUSH
107755: EMPTY
107756: ST_TO_ADDR
// repairs := [ ] ;
107757: LD_ADDR_VAR 0 33
107761: PUSH
107762: EMPTY
107763: ST_TO_ADDR
// to_repair := [ ] ;
107764: LD_ADDR_VAR 0 32
107768: PUSH
107769: EMPTY
107770: ST_TO_ADDR
// if not group or not path then
107771: LD_VAR 0 4
107775: NOT
107776: PUSH
107777: LD_VAR 0 5
107781: NOT
107782: OR
107783: IFFALSE 107787
// exit ;
107785: GO 112332
// side := GetSide ( group [ 1 ] ) ;
107787: LD_ADDR_VAR 0 35
107791: PUSH
107792: LD_VAR 0 4
107796: PUSH
107797: LD_INT 1
107799: ARRAY
107800: PPUSH
107801: CALL_OW 255
107805: ST_TO_ADDR
// if flags then
107806: LD_VAR 0 6
107810: IFFALSE 107954
// begin f_ignore_area := flags [ 1 ] ;
107812: LD_ADDR_VAR 0 17
107816: PUSH
107817: LD_VAR 0 6
107821: PUSH
107822: LD_INT 1
107824: ARRAY
107825: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
107826: LD_ADDR_VAR 0 18
107830: PUSH
107831: LD_VAR 0 6
107835: PUSH
107836: LD_INT 2
107838: ARRAY
107839: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
107840: LD_ADDR_VAR 0 19
107844: PUSH
107845: LD_VAR 0 6
107849: PUSH
107850: LD_INT 3
107852: ARRAY
107853: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
107854: LD_ADDR_VAR 0 20
107858: PUSH
107859: LD_VAR 0 6
107863: PUSH
107864: LD_INT 4
107866: ARRAY
107867: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
107868: LD_ADDR_VAR 0 21
107872: PUSH
107873: LD_VAR 0 6
107877: PUSH
107878: LD_INT 5
107880: ARRAY
107881: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
107882: LD_ADDR_VAR 0 22
107886: PUSH
107887: LD_VAR 0 6
107891: PUSH
107892: LD_INT 6
107894: ARRAY
107895: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
107896: LD_ADDR_VAR 0 23
107900: PUSH
107901: LD_VAR 0 6
107905: PUSH
107906: LD_INT 7
107908: ARRAY
107909: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
107910: LD_ADDR_VAR 0 24
107914: PUSH
107915: LD_VAR 0 6
107919: PUSH
107920: LD_INT 8
107922: ARRAY
107923: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
107924: LD_ADDR_VAR 0 25
107928: PUSH
107929: LD_VAR 0 6
107933: PUSH
107934: LD_INT 9
107936: ARRAY
107937: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
107938: LD_ADDR_VAR 0 26
107942: PUSH
107943: LD_VAR 0 6
107947: PUSH
107948: LD_INT 10
107950: ARRAY
107951: ST_TO_ADDR
// end else
107952: GO 108034
// begin f_ignore_area := false ;
107954: LD_ADDR_VAR 0 17
107958: PUSH
107959: LD_INT 0
107961: ST_TO_ADDR
// f_capture := false ;
107962: LD_ADDR_VAR 0 18
107966: PUSH
107967: LD_INT 0
107969: ST_TO_ADDR
// f_ignore_civ := false ;
107970: LD_ADDR_VAR 0 19
107974: PUSH
107975: LD_INT 0
107977: ST_TO_ADDR
// f_murder := false ;
107978: LD_ADDR_VAR 0 20
107982: PUSH
107983: LD_INT 0
107985: ST_TO_ADDR
// f_mines := false ;
107986: LD_ADDR_VAR 0 21
107990: PUSH
107991: LD_INT 0
107993: ST_TO_ADDR
// f_repair := false ;
107994: LD_ADDR_VAR 0 22
107998: PUSH
107999: LD_INT 0
108001: ST_TO_ADDR
// f_heal := false ;
108002: LD_ADDR_VAR 0 23
108006: PUSH
108007: LD_INT 0
108009: ST_TO_ADDR
// f_spacetime := false ;
108010: LD_ADDR_VAR 0 24
108014: PUSH
108015: LD_INT 0
108017: ST_TO_ADDR
// f_attack_depot := false ;
108018: LD_ADDR_VAR 0 25
108022: PUSH
108023: LD_INT 0
108025: ST_TO_ADDR
// f_crawl := false ;
108026: LD_ADDR_VAR 0 26
108030: PUSH
108031: LD_INT 0
108033: ST_TO_ADDR
// end ; if f_heal then
108034: LD_VAR 0 23
108038: IFFALSE 108065
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
108040: LD_ADDR_VAR 0 31
108044: PUSH
108045: LD_VAR 0 4
108049: PPUSH
108050: LD_INT 25
108052: PUSH
108053: LD_INT 4
108055: PUSH
108056: EMPTY
108057: LIST
108058: LIST
108059: PPUSH
108060: CALL_OW 72
108064: ST_TO_ADDR
// if f_repair then
108065: LD_VAR 0 22
108069: IFFALSE 108096
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
108071: LD_ADDR_VAR 0 33
108075: PUSH
108076: LD_VAR 0 4
108080: PPUSH
108081: LD_INT 25
108083: PUSH
108084: LD_INT 3
108086: PUSH
108087: EMPTY
108088: LIST
108089: LIST
108090: PPUSH
108091: CALL_OW 72
108095: ST_TO_ADDR
// units_path := [ ] ;
108096: LD_ADDR_VAR 0 16
108100: PUSH
108101: EMPTY
108102: ST_TO_ADDR
// for i = 1 to group do
108103: LD_ADDR_VAR 0 7
108107: PUSH
108108: DOUBLE
108109: LD_INT 1
108111: DEC
108112: ST_TO_ADDR
108113: LD_VAR 0 4
108117: PUSH
108118: FOR_TO
108119: IFFALSE 108148
// units_path := Replace ( units_path , i , path ) ;
108121: LD_ADDR_VAR 0 16
108125: PUSH
108126: LD_VAR 0 16
108130: PPUSH
108131: LD_VAR 0 7
108135: PPUSH
108136: LD_VAR 0 5
108140: PPUSH
108141: CALL_OW 1
108145: ST_TO_ADDR
108146: GO 108118
108148: POP
108149: POP
// repeat for i = group downto 1 do
108150: LD_ADDR_VAR 0 7
108154: PUSH
108155: DOUBLE
108156: LD_VAR 0 4
108160: INC
108161: ST_TO_ADDR
108162: LD_INT 1
108164: PUSH
108165: FOR_DOWNTO
108166: IFFALSE 112288
// begin wait ( 5 ) ;
108168: LD_INT 5
108170: PPUSH
108171: CALL_OW 67
// tmp := [ ] ;
108175: LD_ADDR_VAR 0 14
108179: PUSH
108180: EMPTY
108181: ST_TO_ADDR
// attacking := false ;
108182: LD_ADDR_VAR 0 29
108186: PUSH
108187: LD_INT 0
108189: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
108190: LD_VAR 0 4
108194: PUSH
108195: LD_VAR 0 7
108199: ARRAY
108200: PPUSH
108201: CALL_OW 301
108205: PUSH
108206: LD_VAR 0 4
108210: PUSH
108211: LD_VAR 0 7
108215: ARRAY
108216: NOT
108217: OR
108218: IFFALSE 108327
// begin if GetType ( group [ i ] ) = unit_human then
108220: LD_VAR 0 4
108224: PUSH
108225: LD_VAR 0 7
108229: ARRAY
108230: PPUSH
108231: CALL_OW 247
108235: PUSH
108236: LD_INT 1
108238: EQUAL
108239: IFFALSE 108285
// begin to_heal := to_heal diff group [ i ] ;
108241: LD_ADDR_VAR 0 30
108245: PUSH
108246: LD_VAR 0 30
108250: PUSH
108251: LD_VAR 0 4
108255: PUSH
108256: LD_VAR 0 7
108260: ARRAY
108261: DIFF
108262: ST_TO_ADDR
// healers := healers diff group [ i ] ;
108263: LD_ADDR_VAR 0 31
108267: PUSH
108268: LD_VAR 0 31
108272: PUSH
108273: LD_VAR 0 4
108277: PUSH
108278: LD_VAR 0 7
108282: ARRAY
108283: DIFF
108284: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
108285: LD_ADDR_VAR 0 4
108289: PUSH
108290: LD_VAR 0 4
108294: PPUSH
108295: LD_VAR 0 7
108299: PPUSH
108300: CALL_OW 3
108304: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
108305: LD_ADDR_VAR 0 16
108309: PUSH
108310: LD_VAR 0 16
108314: PPUSH
108315: LD_VAR 0 7
108319: PPUSH
108320: CALL_OW 3
108324: ST_TO_ADDR
// continue ;
108325: GO 108165
// end ; if f_repair then
108327: LD_VAR 0 22
108331: IFFALSE 108820
// begin if GetType ( group [ i ] ) = unit_vehicle then
108333: LD_VAR 0 4
108337: PUSH
108338: LD_VAR 0 7
108342: ARRAY
108343: PPUSH
108344: CALL_OW 247
108348: PUSH
108349: LD_INT 2
108351: EQUAL
108352: IFFALSE 108542
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
108354: LD_VAR 0 4
108358: PUSH
108359: LD_VAR 0 7
108363: ARRAY
108364: PPUSH
108365: CALL_OW 256
108369: PUSH
108370: LD_INT 700
108372: LESS
108373: PUSH
108374: LD_VAR 0 4
108378: PUSH
108379: LD_VAR 0 7
108383: ARRAY
108384: PUSH
108385: LD_VAR 0 32
108389: IN
108390: NOT
108391: AND
108392: IFFALSE 108416
// to_repair := to_repair union group [ i ] ;
108394: LD_ADDR_VAR 0 32
108398: PUSH
108399: LD_VAR 0 32
108403: PUSH
108404: LD_VAR 0 4
108408: PUSH
108409: LD_VAR 0 7
108413: ARRAY
108414: UNION
108415: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
108416: LD_VAR 0 4
108420: PUSH
108421: LD_VAR 0 7
108425: ARRAY
108426: PPUSH
108427: CALL_OW 256
108431: PUSH
108432: LD_INT 1000
108434: EQUAL
108435: PUSH
108436: LD_VAR 0 4
108440: PUSH
108441: LD_VAR 0 7
108445: ARRAY
108446: PUSH
108447: LD_VAR 0 32
108451: IN
108452: AND
108453: IFFALSE 108477
// to_repair := to_repair diff group [ i ] ;
108455: LD_ADDR_VAR 0 32
108459: PUSH
108460: LD_VAR 0 32
108464: PUSH
108465: LD_VAR 0 4
108469: PUSH
108470: LD_VAR 0 7
108474: ARRAY
108475: DIFF
108476: ST_TO_ADDR
// if group [ i ] in to_repair then
108477: LD_VAR 0 4
108481: PUSH
108482: LD_VAR 0 7
108486: ARRAY
108487: PUSH
108488: LD_VAR 0 32
108492: IN
108493: IFFALSE 108540
// begin if not IsInArea ( group [ i ] , f_repair ) then
108495: LD_VAR 0 4
108499: PUSH
108500: LD_VAR 0 7
108504: ARRAY
108505: PPUSH
108506: LD_VAR 0 22
108510: PPUSH
108511: CALL_OW 308
108515: NOT
108516: IFFALSE 108538
// ComMoveToArea ( group [ i ] , f_repair ) ;
108518: LD_VAR 0 4
108522: PUSH
108523: LD_VAR 0 7
108527: ARRAY
108528: PPUSH
108529: LD_VAR 0 22
108533: PPUSH
108534: CALL_OW 113
// continue ;
108538: GO 108165
// end ; end else
108540: GO 108820
// if group [ i ] in repairs then
108542: LD_VAR 0 4
108546: PUSH
108547: LD_VAR 0 7
108551: ARRAY
108552: PUSH
108553: LD_VAR 0 33
108557: IN
108558: IFFALSE 108820
// begin if IsInUnit ( group [ i ] ) then
108560: LD_VAR 0 4
108564: PUSH
108565: LD_VAR 0 7
108569: ARRAY
108570: PPUSH
108571: CALL_OW 310
108575: IFFALSE 108643
// begin z := IsInUnit ( group [ i ] ) ;
108577: LD_ADDR_VAR 0 13
108581: PUSH
108582: LD_VAR 0 4
108586: PUSH
108587: LD_VAR 0 7
108591: ARRAY
108592: PPUSH
108593: CALL_OW 310
108597: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
108598: LD_VAR 0 13
108602: PUSH
108603: LD_VAR 0 32
108607: IN
108608: PUSH
108609: LD_VAR 0 13
108613: PPUSH
108614: LD_VAR 0 22
108618: PPUSH
108619: CALL_OW 308
108623: AND
108624: IFFALSE 108641
// ComExitVehicle ( group [ i ] ) ;
108626: LD_VAR 0 4
108630: PUSH
108631: LD_VAR 0 7
108635: ARRAY
108636: PPUSH
108637: CALL_OW 121
// end else
108641: GO 108820
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
108643: LD_ADDR_VAR 0 13
108647: PUSH
108648: LD_VAR 0 4
108652: PPUSH
108653: LD_INT 95
108655: PUSH
108656: LD_VAR 0 22
108660: PUSH
108661: EMPTY
108662: LIST
108663: LIST
108664: PUSH
108665: LD_INT 58
108667: PUSH
108668: EMPTY
108669: LIST
108670: PUSH
108671: EMPTY
108672: LIST
108673: LIST
108674: PPUSH
108675: CALL_OW 72
108679: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
108680: LD_VAR 0 4
108684: PUSH
108685: LD_VAR 0 7
108689: ARRAY
108690: PPUSH
108691: CALL_OW 314
108695: NOT
108696: IFFALSE 108818
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
108698: LD_ADDR_VAR 0 10
108702: PUSH
108703: LD_VAR 0 13
108707: PPUSH
108708: LD_VAR 0 4
108712: PUSH
108713: LD_VAR 0 7
108717: ARRAY
108718: PPUSH
108719: CALL_OW 74
108723: ST_TO_ADDR
// if not x then
108724: LD_VAR 0 10
108728: NOT
108729: IFFALSE 108733
// continue ;
108731: GO 108165
// if GetLives ( x ) < 1000 then
108733: LD_VAR 0 10
108737: PPUSH
108738: CALL_OW 256
108742: PUSH
108743: LD_INT 1000
108745: LESS
108746: IFFALSE 108770
// ComRepairVehicle ( group [ i ] , x ) else
108748: LD_VAR 0 4
108752: PUSH
108753: LD_VAR 0 7
108757: ARRAY
108758: PPUSH
108759: LD_VAR 0 10
108763: PPUSH
108764: CALL_OW 129
108768: GO 108818
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
108770: LD_VAR 0 23
108774: PUSH
108775: LD_VAR 0 4
108779: PUSH
108780: LD_VAR 0 7
108784: ARRAY
108785: PPUSH
108786: CALL_OW 256
108790: PUSH
108791: LD_INT 1000
108793: LESS
108794: AND
108795: NOT
108796: IFFALSE 108818
// ComEnterUnit ( group [ i ] , x ) ;
108798: LD_VAR 0 4
108802: PUSH
108803: LD_VAR 0 7
108807: ARRAY
108808: PPUSH
108809: LD_VAR 0 10
108813: PPUSH
108814: CALL_OW 120
// end ; continue ;
108818: GO 108165
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
108820: LD_VAR 0 23
108824: PUSH
108825: LD_VAR 0 4
108829: PUSH
108830: LD_VAR 0 7
108834: ARRAY
108835: PPUSH
108836: CALL_OW 247
108840: PUSH
108841: LD_INT 1
108843: EQUAL
108844: AND
108845: IFFALSE 109323
// begin if group [ i ] in healers then
108847: LD_VAR 0 4
108851: PUSH
108852: LD_VAR 0 7
108856: ARRAY
108857: PUSH
108858: LD_VAR 0 31
108862: IN
108863: IFFALSE 109136
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
108865: LD_VAR 0 4
108869: PUSH
108870: LD_VAR 0 7
108874: ARRAY
108875: PPUSH
108876: LD_VAR 0 23
108880: PPUSH
108881: CALL_OW 308
108885: NOT
108886: PUSH
108887: LD_VAR 0 4
108891: PUSH
108892: LD_VAR 0 7
108896: ARRAY
108897: PPUSH
108898: CALL_OW 314
108902: NOT
108903: AND
108904: IFFALSE 108928
// ComMoveToArea ( group [ i ] , f_heal ) else
108906: LD_VAR 0 4
108910: PUSH
108911: LD_VAR 0 7
108915: ARRAY
108916: PPUSH
108917: LD_VAR 0 23
108921: PPUSH
108922: CALL_OW 113
108926: GO 109134
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
108928: LD_VAR 0 4
108932: PUSH
108933: LD_VAR 0 7
108937: ARRAY
108938: PPUSH
108939: CALL 50164 0 1
108943: PPUSH
108944: CALL_OW 256
108948: PUSH
108949: LD_INT 1000
108951: EQUAL
108952: IFFALSE 108971
// ComStop ( group [ i ] ) else
108954: LD_VAR 0 4
108958: PUSH
108959: LD_VAR 0 7
108963: ARRAY
108964: PPUSH
108965: CALL_OW 141
108969: GO 109134
// if not HasTask ( group [ i ] ) and to_heal then
108971: LD_VAR 0 4
108975: PUSH
108976: LD_VAR 0 7
108980: ARRAY
108981: PPUSH
108982: CALL_OW 314
108986: NOT
108987: PUSH
108988: LD_VAR 0 30
108992: AND
108993: IFFALSE 109134
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
108995: LD_ADDR_VAR 0 13
108999: PUSH
109000: LD_VAR 0 30
109004: PPUSH
109005: LD_INT 3
109007: PUSH
109008: LD_INT 54
109010: PUSH
109011: EMPTY
109012: LIST
109013: PUSH
109014: EMPTY
109015: LIST
109016: LIST
109017: PPUSH
109018: CALL_OW 72
109022: PPUSH
109023: LD_VAR 0 4
109027: PUSH
109028: LD_VAR 0 7
109032: ARRAY
109033: PPUSH
109034: CALL_OW 74
109038: ST_TO_ADDR
// if z then
109039: LD_VAR 0 13
109043: IFFALSE 109134
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
109045: LD_INT 91
109047: PUSH
109048: LD_VAR 0 13
109052: PUSH
109053: LD_INT 10
109055: PUSH
109056: EMPTY
109057: LIST
109058: LIST
109059: LIST
109060: PUSH
109061: LD_INT 81
109063: PUSH
109064: LD_VAR 0 13
109068: PPUSH
109069: CALL_OW 255
109073: PUSH
109074: EMPTY
109075: LIST
109076: LIST
109077: PUSH
109078: EMPTY
109079: LIST
109080: LIST
109081: PPUSH
109082: CALL_OW 69
109086: PUSH
109087: LD_INT 0
109089: EQUAL
109090: IFFALSE 109114
// ComHeal ( group [ i ] , z ) else
109092: LD_VAR 0 4
109096: PUSH
109097: LD_VAR 0 7
109101: ARRAY
109102: PPUSH
109103: LD_VAR 0 13
109107: PPUSH
109108: CALL_OW 128
109112: GO 109134
// ComMoveToArea ( group [ i ] , f_heal ) ;
109114: LD_VAR 0 4
109118: PUSH
109119: LD_VAR 0 7
109123: ARRAY
109124: PPUSH
109125: LD_VAR 0 23
109129: PPUSH
109130: CALL_OW 113
// end ; continue ;
109134: GO 108165
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
109136: LD_VAR 0 4
109140: PUSH
109141: LD_VAR 0 7
109145: ARRAY
109146: PPUSH
109147: CALL_OW 256
109151: PUSH
109152: LD_INT 700
109154: LESS
109155: PUSH
109156: LD_VAR 0 4
109160: PUSH
109161: LD_VAR 0 7
109165: ARRAY
109166: PUSH
109167: LD_VAR 0 30
109171: IN
109172: NOT
109173: AND
109174: IFFALSE 109198
// to_heal := to_heal union group [ i ] ;
109176: LD_ADDR_VAR 0 30
109180: PUSH
109181: LD_VAR 0 30
109185: PUSH
109186: LD_VAR 0 4
109190: PUSH
109191: LD_VAR 0 7
109195: ARRAY
109196: UNION
109197: ST_TO_ADDR
// if group [ i ] in to_heal then
109198: LD_VAR 0 4
109202: PUSH
109203: LD_VAR 0 7
109207: ARRAY
109208: PUSH
109209: LD_VAR 0 30
109213: IN
109214: IFFALSE 109323
// begin if GetLives ( group [ i ] ) = 1000 then
109216: LD_VAR 0 4
109220: PUSH
109221: LD_VAR 0 7
109225: ARRAY
109226: PPUSH
109227: CALL_OW 256
109231: PUSH
109232: LD_INT 1000
109234: EQUAL
109235: IFFALSE 109261
// to_heal := to_heal diff group [ i ] else
109237: LD_ADDR_VAR 0 30
109241: PUSH
109242: LD_VAR 0 30
109246: PUSH
109247: LD_VAR 0 4
109251: PUSH
109252: LD_VAR 0 7
109256: ARRAY
109257: DIFF
109258: ST_TO_ADDR
109259: GO 109323
// begin if not IsInArea ( group [ i ] , to_heal ) then
109261: LD_VAR 0 4
109265: PUSH
109266: LD_VAR 0 7
109270: ARRAY
109271: PPUSH
109272: LD_VAR 0 30
109276: PPUSH
109277: CALL_OW 308
109281: NOT
109282: IFFALSE 109306
// ComMoveToArea ( group [ i ] , f_heal ) else
109284: LD_VAR 0 4
109288: PUSH
109289: LD_VAR 0 7
109293: ARRAY
109294: PPUSH
109295: LD_VAR 0 23
109299: PPUSH
109300: CALL_OW 113
109304: GO 109321
// ComHold ( group [ i ] ) ;
109306: LD_VAR 0 4
109310: PUSH
109311: LD_VAR 0 7
109315: ARRAY
109316: PPUSH
109317: CALL_OW 140
// continue ;
109321: GO 108165
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
109323: LD_VAR 0 4
109327: PUSH
109328: LD_VAR 0 7
109332: ARRAY
109333: PPUSH
109334: LD_INT 10
109336: PPUSH
109337: CALL 47935 0 2
109341: NOT
109342: PUSH
109343: LD_VAR 0 16
109347: PUSH
109348: LD_VAR 0 7
109352: ARRAY
109353: PUSH
109354: EMPTY
109355: EQUAL
109356: NOT
109357: AND
109358: IFFALSE 109624
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
109360: LD_VAR 0 4
109364: PUSH
109365: LD_VAR 0 7
109369: ARRAY
109370: PPUSH
109371: CALL_OW 262
109375: PUSH
109376: LD_INT 1
109378: PUSH
109379: LD_INT 2
109381: PUSH
109382: EMPTY
109383: LIST
109384: LIST
109385: IN
109386: IFFALSE 109427
// if GetFuel ( group [ i ] ) < 10 then
109388: LD_VAR 0 4
109392: PUSH
109393: LD_VAR 0 7
109397: ARRAY
109398: PPUSH
109399: CALL_OW 261
109403: PUSH
109404: LD_INT 10
109406: LESS
109407: IFFALSE 109427
// SetFuel ( group [ i ] , 12 ) ;
109409: LD_VAR 0 4
109413: PUSH
109414: LD_VAR 0 7
109418: ARRAY
109419: PPUSH
109420: LD_INT 12
109422: PPUSH
109423: CALL_OW 240
// if units_path [ i ] then
109427: LD_VAR 0 16
109431: PUSH
109432: LD_VAR 0 7
109436: ARRAY
109437: IFFALSE 109622
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
109439: LD_VAR 0 4
109443: PUSH
109444: LD_VAR 0 7
109448: ARRAY
109449: PPUSH
109450: LD_VAR 0 16
109454: PUSH
109455: LD_VAR 0 7
109459: ARRAY
109460: PUSH
109461: LD_INT 1
109463: ARRAY
109464: PUSH
109465: LD_INT 1
109467: ARRAY
109468: PPUSH
109469: LD_VAR 0 16
109473: PUSH
109474: LD_VAR 0 7
109478: ARRAY
109479: PUSH
109480: LD_INT 1
109482: ARRAY
109483: PUSH
109484: LD_INT 2
109486: ARRAY
109487: PPUSH
109488: CALL_OW 297
109492: PUSH
109493: LD_INT 6
109495: GREATER
109496: IFFALSE 109571
// begin if not HasTask ( group [ i ] ) then
109498: LD_VAR 0 4
109502: PUSH
109503: LD_VAR 0 7
109507: ARRAY
109508: PPUSH
109509: CALL_OW 314
109513: NOT
109514: IFFALSE 109569
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
109516: LD_VAR 0 4
109520: PUSH
109521: LD_VAR 0 7
109525: ARRAY
109526: PPUSH
109527: LD_VAR 0 16
109531: PUSH
109532: LD_VAR 0 7
109536: ARRAY
109537: PUSH
109538: LD_INT 1
109540: ARRAY
109541: PUSH
109542: LD_INT 1
109544: ARRAY
109545: PPUSH
109546: LD_VAR 0 16
109550: PUSH
109551: LD_VAR 0 7
109555: ARRAY
109556: PUSH
109557: LD_INT 1
109559: ARRAY
109560: PUSH
109561: LD_INT 2
109563: ARRAY
109564: PPUSH
109565: CALL_OW 114
// end else
109569: GO 109622
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
109571: LD_ADDR_VAR 0 15
109575: PUSH
109576: LD_VAR 0 16
109580: PUSH
109581: LD_VAR 0 7
109585: ARRAY
109586: PPUSH
109587: LD_INT 1
109589: PPUSH
109590: CALL_OW 3
109594: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
109595: LD_ADDR_VAR 0 16
109599: PUSH
109600: LD_VAR 0 16
109604: PPUSH
109605: LD_VAR 0 7
109609: PPUSH
109610: LD_VAR 0 15
109614: PPUSH
109615: CALL_OW 1
109619: ST_TO_ADDR
// continue ;
109620: GO 108165
// end ; end ; end else
109622: GO 112286
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
109624: LD_ADDR_VAR 0 14
109628: PUSH
109629: LD_INT 81
109631: PUSH
109632: LD_VAR 0 4
109636: PUSH
109637: LD_VAR 0 7
109641: ARRAY
109642: PPUSH
109643: CALL_OW 255
109647: PUSH
109648: EMPTY
109649: LIST
109650: LIST
109651: PPUSH
109652: CALL_OW 69
109656: ST_TO_ADDR
// if not tmp then
109657: LD_VAR 0 14
109661: NOT
109662: IFFALSE 109666
// continue ;
109664: GO 108165
// if f_ignore_area then
109666: LD_VAR 0 17
109670: IFFALSE 109758
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
109672: LD_ADDR_VAR 0 15
109676: PUSH
109677: LD_VAR 0 14
109681: PPUSH
109682: LD_INT 3
109684: PUSH
109685: LD_INT 92
109687: PUSH
109688: LD_VAR 0 17
109692: PUSH
109693: LD_INT 1
109695: ARRAY
109696: PUSH
109697: LD_VAR 0 17
109701: PUSH
109702: LD_INT 2
109704: ARRAY
109705: PUSH
109706: LD_VAR 0 17
109710: PUSH
109711: LD_INT 3
109713: ARRAY
109714: PUSH
109715: EMPTY
109716: LIST
109717: LIST
109718: LIST
109719: LIST
109720: PUSH
109721: EMPTY
109722: LIST
109723: LIST
109724: PPUSH
109725: CALL_OW 72
109729: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109730: LD_VAR 0 14
109734: PUSH
109735: LD_VAR 0 15
109739: DIFF
109740: IFFALSE 109758
// tmp := tmp diff tmp2 ;
109742: LD_ADDR_VAR 0 14
109746: PUSH
109747: LD_VAR 0 14
109751: PUSH
109752: LD_VAR 0 15
109756: DIFF
109757: ST_TO_ADDR
// end ; if not f_murder then
109758: LD_VAR 0 20
109762: NOT
109763: IFFALSE 109821
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
109765: LD_ADDR_VAR 0 15
109769: PUSH
109770: LD_VAR 0 14
109774: PPUSH
109775: LD_INT 3
109777: PUSH
109778: LD_INT 50
109780: PUSH
109781: EMPTY
109782: LIST
109783: PUSH
109784: EMPTY
109785: LIST
109786: LIST
109787: PPUSH
109788: CALL_OW 72
109792: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109793: LD_VAR 0 14
109797: PUSH
109798: LD_VAR 0 15
109802: DIFF
109803: IFFALSE 109821
// tmp := tmp diff tmp2 ;
109805: LD_ADDR_VAR 0 14
109809: PUSH
109810: LD_VAR 0 14
109814: PUSH
109815: LD_VAR 0 15
109819: DIFF
109820: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
109821: LD_ADDR_VAR 0 14
109825: PUSH
109826: LD_VAR 0 4
109830: PUSH
109831: LD_VAR 0 7
109835: ARRAY
109836: PPUSH
109837: LD_VAR 0 14
109841: PPUSH
109842: LD_INT 1
109844: PPUSH
109845: LD_INT 1
109847: PPUSH
109848: CALL 20876 0 4
109852: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
109853: LD_VAR 0 4
109857: PUSH
109858: LD_VAR 0 7
109862: ARRAY
109863: PPUSH
109864: CALL_OW 257
109868: PUSH
109869: LD_INT 1
109871: EQUAL
109872: IFFALSE 110320
// begin if WantPlant ( group [ i ] ) then
109874: LD_VAR 0 4
109878: PUSH
109879: LD_VAR 0 7
109883: ARRAY
109884: PPUSH
109885: CALL 20377 0 1
109889: IFFALSE 109893
// continue ;
109891: GO 108165
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
109893: LD_VAR 0 18
109897: PUSH
109898: LD_VAR 0 4
109902: PUSH
109903: LD_VAR 0 7
109907: ARRAY
109908: PPUSH
109909: CALL_OW 310
109913: NOT
109914: AND
109915: PUSH
109916: LD_VAR 0 14
109920: PUSH
109921: LD_INT 1
109923: ARRAY
109924: PUSH
109925: LD_VAR 0 14
109929: PPUSH
109930: LD_INT 21
109932: PUSH
109933: LD_INT 2
109935: PUSH
109936: EMPTY
109937: LIST
109938: LIST
109939: PUSH
109940: LD_INT 58
109942: PUSH
109943: EMPTY
109944: LIST
109945: PUSH
109946: EMPTY
109947: LIST
109948: LIST
109949: PPUSH
109950: CALL_OW 72
109954: IN
109955: AND
109956: IFFALSE 109992
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
109958: LD_VAR 0 4
109962: PUSH
109963: LD_VAR 0 7
109967: ARRAY
109968: PPUSH
109969: LD_VAR 0 14
109973: PUSH
109974: LD_INT 1
109976: ARRAY
109977: PPUSH
109978: CALL_OW 120
// attacking := true ;
109982: LD_ADDR_VAR 0 29
109986: PUSH
109987: LD_INT 1
109989: ST_TO_ADDR
// continue ;
109990: GO 108165
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
109992: LD_VAR 0 26
109996: PUSH
109997: LD_VAR 0 4
110001: PUSH
110002: LD_VAR 0 7
110006: ARRAY
110007: PPUSH
110008: CALL_OW 257
110012: PUSH
110013: LD_INT 1
110015: EQUAL
110016: AND
110017: PUSH
110018: LD_VAR 0 4
110022: PUSH
110023: LD_VAR 0 7
110027: ARRAY
110028: PPUSH
110029: CALL_OW 256
110033: PUSH
110034: LD_INT 800
110036: LESS
110037: AND
110038: PUSH
110039: LD_VAR 0 4
110043: PUSH
110044: LD_VAR 0 7
110048: ARRAY
110049: PPUSH
110050: CALL_OW 318
110054: NOT
110055: AND
110056: IFFALSE 110073
// ComCrawl ( group [ i ] ) ;
110058: LD_VAR 0 4
110062: PUSH
110063: LD_VAR 0 7
110067: ARRAY
110068: PPUSH
110069: CALL_OW 137
// if f_mines then
110073: LD_VAR 0 21
110077: IFFALSE 110320
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
110079: LD_VAR 0 14
110083: PUSH
110084: LD_INT 1
110086: ARRAY
110087: PPUSH
110088: CALL_OW 247
110092: PUSH
110093: LD_INT 3
110095: EQUAL
110096: PUSH
110097: LD_VAR 0 14
110101: PUSH
110102: LD_INT 1
110104: ARRAY
110105: PUSH
110106: LD_VAR 0 27
110110: IN
110111: NOT
110112: AND
110113: IFFALSE 110320
// begin x := GetX ( tmp [ 1 ] ) ;
110115: LD_ADDR_VAR 0 10
110119: PUSH
110120: LD_VAR 0 14
110124: PUSH
110125: LD_INT 1
110127: ARRAY
110128: PPUSH
110129: CALL_OW 250
110133: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
110134: LD_ADDR_VAR 0 11
110138: PUSH
110139: LD_VAR 0 14
110143: PUSH
110144: LD_INT 1
110146: ARRAY
110147: PPUSH
110148: CALL_OW 251
110152: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
110153: LD_ADDR_VAR 0 12
110157: PUSH
110158: LD_VAR 0 4
110162: PUSH
110163: LD_VAR 0 7
110167: ARRAY
110168: PPUSH
110169: CALL 48020 0 1
110173: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
110174: LD_VAR 0 4
110178: PUSH
110179: LD_VAR 0 7
110183: ARRAY
110184: PPUSH
110185: LD_VAR 0 10
110189: PPUSH
110190: LD_VAR 0 11
110194: PPUSH
110195: LD_VAR 0 14
110199: PUSH
110200: LD_INT 1
110202: ARRAY
110203: PPUSH
110204: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
110208: LD_VAR 0 4
110212: PUSH
110213: LD_VAR 0 7
110217: ARRAY
110218: PPUSH
110219: LD_VAR 0 10
110223: PPUSH
110224: LD_VAR 0 12
110228: PPUSH
110229: LD_INT 7
110231: PPUSH
110232: CALL_OW 272
110236: PPUSH
110237: LD_VAR 0 11
110241: PPUSH
110242: LD_VAR 0 12
110246: PPUSH
110247: LD_INT 7
110249: PPUSH
110250: CALL_OW 273
110254: PPUSH
110255: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
110259: LD_VAR 0 4
110263: PUSH
110264: LD_VAR 0 7
110268: ARRAY
110269: PPUSH
110270: LD_INT 71
110272: PPUSH
110273: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
110277: LD_ADDR_VAR 0 27
110281: PUSH
110282: LD_VAR 0 27
110286: PPUSH
110287: LD_VAR 0 27
110291: PUSH
110292: LD_INT 1
110294: PLUS
110295: PPUSH
110296: LD_VAR 0 14
110300: PUSH
110301: LD_INT 1
110303: ARRAY
110304: PPUSH
110305: CALL_OW 1
110309: ST_TO_ADDR
// attacking := true ;
110310: LD_ADDR_VAR 0 29
110314: PUSH
110315: LD_INT 1
110317: ST_TO_ADDR
// continue ;
110318: GO 108165
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
110320: LD_VAR 0 4
110324: PUSH
110325: LD_VAR 0 7
110329: ARRAY
110330: PPUSH
110331: CALL_OW 257
110335: PUSH
110336: LD_INT 17
110338: EQUAL
110339: PUSH
110340: LD_VAR 0 4
110344: PUSH
110345: LD_VAR 0 7
110349: ARRAY
110350: PPUSH
110351: CALL_OW 110
110355: PUSH
110356: LD_INT 71
110358: EQUAL
110359: NOT
110360: AND
110361: IFFALSE 110507
// begin attacking := false ;
110363: LD_ADDR_VAR 0 29
110367: PUSH
110368: LD_INT 0
110370: ST_TO_ADDR
// k := 5 ;
110371: LD_ADDR_VAR 0 9
110375: PUSH
110376: LD_INT 5
110378: ST_TO_ADDR
// if tmp < k then
110379: LD_VAR 0 14
110383: PUSH
110384: LD_VAR 0 9
110388: LESS
110389: IFFALSE 110401
// k := tmp ;
110391: LD_ADDR_VAR 0 9
110395: PUSH
110396: LD_VAR 0 14
110400: ST_TO_ADDR
// for j = 1 to k do
110401: LD_ADDR_VAR 0 8
110405: PUSH
110406: DOUBLE
110407: LD_INT 1
110409: DEC
110410: ST_TO_ADDR
110411: LD_VAR 0 9
110415: PUSH
110416: FOR_TO
110417: IFFALSE 110505
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
110419: LD_VAR 0 14
110423: PUSH
110424: LD_VAR 0 8
110428: ARRAY
110429: PUSH
110430: LD_VAR 0 14
110434: PPUSH
110435: LD_INT 58
110437: PUSH
110438: EMPTY
110439: LIST
110440: PPUSH
110441: CALL_OW 72
110445: IN
110446: NOT
110447: IFFALSE 110503
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110449: LD_VAR 0 4
110453: PUSH
110454: LD_VAR 0 7
110458: ARRAY
110459: PPUSH
110460: LD_VAR 0 14
110464: PUSH
110465: LD_VAR 0 8
110469: ARRAY
110470: PPUSH
110471: CALL_OW 115
// attacking := true ;
110475: LD_ADDR_VAR 0 29
110479: PUSH
110480: LD_INT 1
110482: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
110483: LD_VAR 0 4
110487: PUSH
110488: LD_VAR 0 7
110492: ARRAY
110493: PPUSH
110494: LD_INT 71
110496: PPUSH
110497: CALL_OW 109
// continue ;
110501: GO 110416
// end ; end ;
110503: GO 110416
110505: POP
110506: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
110507: LD_VAR 0 4
110511: PUSH
110512: LD_VAR 0 7
110516: ARRAY
110517: PPUSH
110518: CALL_OW 257
110522: PUSH
110523: LD_INT 8
110525: EQUAL
110526: PUSH
110527: LD_VAR 0 4
110531: PUSH
110532: LD_VAR 0 7
110536: ARRAY
110537: PPUSH
110538: CALL_OW 264
110542: PUSH
110543: LD_INT 28
110545: PUSH
110546: LD_INT 45
110548: PUSH
110549: LD_INT 7
110551: PUSH
110552: LD_INT 47
110554: PUSH
110555: EMPTY
110556: LIST
110557: LIST
110558: LIST
110559: LIST
110560: IN
110561: OR
110562: IFFALSE 110818
// begin attacking := false ;
110564: LD_ADDR_VAR 0 29
110568: PUSH
110569: LD_INT 0
110571: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
110572: LD_VAR 0 14
110576: PUSH
110577: LD_INT 1
110579: ARRAY
110580: PPUSH
110581: CALL_OW 266
110585: PUSH
110586: LD_INT 32
110588: PUSH
110589: LD_INT 31
110591: PUSH
110592: LD_INT 33
110594: PUSH
110595: LD_INT 4
110597: PUSH
110598: LD_INT 5
110600: PUSH
110601: EMPTY
110602: LIST
110603: LIST
110604: LIST
110605: LIST
110606: LIST
110607: IN
110608: IFFALSE 110794
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
110610: LD_ADDR_VAR 0 9
110614: PUSH
110615: LD_VAR 0 14
110619: PUSH
110620: LD_INT 1
110622: ARRAY
110623: PPUSH
110624: CALL_OW 266
110628: PPUSH
110629: LD_VAR 0 14
110633: PUSH
110634: LD_INT 1
110636: ARRAY
110637: PPUSH
110638: CALL_OW 250
110642: PPUSH
110643: LD_VAR 0 14
110647: PUSH
110648: LD_INT 1
110650: ARRAY
110651: PPUSH
110652: CALL_OW 251
110656: PPUSH
110657: LD_VAR 0 14
110661: PUSH
110662: LD_INT 1
110664: ARRAY
110665: PPUSH
110666: CALL_OW 254
110670: PPUSH
110671: LD_VAR 0 14
110675: PUSH
110676: LD_INT 1
110678: ARRAY
110679: PPUSH
110680: CALL_OW 248
110684: PPUSH
110685: LD_INT 0
110687: PPUSH
110688: CALL 29390 0 6
110692: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
110693: LD_ADDR_VAR 0 8
110697: PUSH
110698: LD_VAR 0 4
110702: PUSH
110703: LD_VAR 0 7
110707: ARRAY
110708: PPUSH
110709: LD_VAR 0 9
110713: PPUSH
110714: CALL 48133 0 2
110718: ST_TO_ADDR
// if j then
110719: LD_VAR 0 8
110723: IFFALSE 110792
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
110725: LD_VAR 0 8
110729: PUSH
110730: LD_INT 1
110732: ARRAY
110733: PPUSH
110734: LD_VAR 0 8
110738: PUSH
110739: LD_INT 2
110741: ARRAY
110742: PPUSH
110743: CALL_OW 488
110747: IFFALSE 110792
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
110749: LD_VAR 0 4
110753: PUSH
110754: LD_VAR 0 7
110758: ARRAY
110759: PPUSH
110760: LD_VAR 0 8
110764: PUSH
110765: LD_INT 1
110767: ARRAY
110768: PPUSH
110769: LD_VAR 0 8
110773: PUSH
110774: LD_INT 2
110776: ARRAY
110777: PPUSH
110778: CALL_OW 116
// attacking := true ;
110782: LD_ADDR_VAR 0 29
110786: PUSH
110787: LD_INT 1
110789: ST_TO_ADDR
// continue ;
110790: GO 108165
// end ; end else
110792: GO 110818
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110794: LD_VAR 0 4
110798: PUSH
110799: LD_VAR 0 7
110803: ARRAY
110804: PPUSH
110805: LD_VAR 0 14
110809: PUSH
110810: LD_INT 1
110812: ARRAY
110813: PPUSH
110814: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
110818: LD_VAR 0 4
110822: PUSH
110823: LD_VAR 0 7
110827: ARRAY
110828: PPUSH
110829: CALL_OW 265
110833: PUSH
110834: LD_INT 11
110836: EQUAL
110837: IFFALSE 111115
// begin k := 10 ;
110839: LD_ADDR_VAR 0 9
110843: PUSH
110844: LD_INT 10
110846: ST_TO_ADDR
// x := 0 ;
110847: LD_ADDR_VAR 0 10
110851: PUSH
110852: LD_INT 0
110854: ST_TO_ADDR
// if tmp < k then
110855: LD_VAR 0 14
110859: PUSH
110860: LD_VAR 0 9
110864: LESS
110865: IFFALSE 110877
// k := tmp ;
110867: LD_ADDR_VAR 0 9
110871: PUSH
110872: LD_VAR 0 14
110876: ST_TO_ADDR
// for j = k downto 1 do
110877: LD_ADDR_VAR 0 8
110881: PUSH
110882: DOUBLE
110883: LD_VAR 0 9
110887: INC
110888: ST_TO_ADDR
110889: LD_INT 1
110891: PUSH
110892: FOR_DOWNTO
110893: IFFALSE 110968
// begin if GetType ( tmp [ j ] ) = unit_human then
110895: LD_VAR 0 14
110899: PUSH
110900: LD_VAR 0 8
110904: ARRAY
110905: PPUSH
110906: CALL_OW 247
110910: PUSH
110911: LD_INT 1
110913: EQUAL
110914: IFFALSE 110966
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
110916: LD_VAR 0 4
110920: PUSH
110921: LD_VAR 0 7
110925: ARRAY
110926: PPUSH
110927: LD_VAR 0 14
110931: PUSH
110932: LD_VAR 0 8
110936: ARRAY
110937: PPUSH
110938: CALL 48387 0 2
// x := tmp [ j ] ;
110942: LD_ADDR_VAR 0 10
110946: PUSH
110947: LD_VAR 0 14
110951: PUSH
110952: LD_VAR 0 8
110956: ARRAY
110957: ST_TO_ADDR
// attacking := true ;
110958: LD_ADDR_VAR 0 29
110962: PUSH
110963: LD_INT 1
110965: ST_TO_ADDR
// end ; end ;
110966: GO 110892
110968: POP
110969: POP
// if not x then
110970: LD_VAR 0 10
110974: NOT
110975: IFFALSE 111115
// begin attacking := true ;
110977: LD_ADDR_VAR 0 29
110981: PUSH
110982: LD_INT 1
110984: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
110985: LD_VAR 0 4
110989: PUSH
110990: LD_VAR 0 7
110994: ARRAY
110995: PPUSH
110996: CALL_OW 250
111000: PPUSH
111001: LD_VAR 0 4
111005: PUSH
111006: LD_VAR 0 7
111010: ARRAY
111011: PPUSH
111012: CALL_OW 251
111016: PPUSH
111017: CALL_OW 546
111021: PUSH
111022: LD_INT 2
111024: ARRAY
111025: PUSH
111026: LD_VAR 0 14
111030: PUSH
111031: LD_INT 1
111033: ARRAY
111034: PPUSH
111035: CALL_OW 250
111039: PPUSH
111040: LD_VAR 0 14
111044: PUSH
111045: LD_INT 1
111047: ARRAY
111048: PPUSH
111049: CALL_OW 251
111053: PPUSH
111054: CALL_OW 546
111058: PUSH
111059: LD_INT 2
111061: ARRAY
111062: EQUAL
111063: IFFALSE 111091
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
111065: LD_VAR 0 4
111069: PUSH
111070: LD_VAR 0 7
111074: ARRAY
111075: PPUSH
111076: LD_VAR 0 14
111080: PUSH
111081: LD_INT 1
111083: ARRAY
111084: PPUSH
111085: CALL 48387 0 2
111089: GO 111115
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111091: LD_VAR 0 4
111095: PUSH
111096: LD_VAR 0 7
111100: ARRAY
111101: PPUSH
111102: LD_VAR 0 14
111106: PUSH
111107: LD_INT 1
111109: ARRAY
111110: PPUSH
111111: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
111115: LD_VAR 0 4
111119: PUSH
111120: LD_VAR 0 7
111124: ARRAY
111125: PPUSH
111126: CALL_OW 264
111130: PUSH
111131: LD_INT 29
111133: EQUAL
111134: IFFALSE 111500
// begin if WantsToAttack ( group [ i ] ) in bombed then
111136: LD_VAR 0 4
111140: PUSH
111141: LD_VAR 0 7
111145: ARRAY
111146: PPUSH
111147: CALL_OW 319
111151: PUSH
111152: LD_VAR 0 28
111156: IN
111157: IFFALSE 111161
// continue ;
111159: GO 108165
// k := 8 ;
111161: LD_ADDR_VAR 0 9
111165: PUSH
111166: LD_INT 8
111168: ST_TO_ADDR
// x := 0 ;
111169: LD_ADDR_VAR 0 10
111173: PUSH
111174: LD_INT 0
111176: ST_TO_ADDR
// if tmp < k then
111177: LD_VAR 0 14
111181: PUSH
111182: LD_VAR 0 9
111186: LESS
111187: IFFALSE 111199
// k := tmp ;
111189: LD_ADDR_VAR 0 9
111193: PUSH
111194: LD_VAR 0 14
111198: ST_TO_ADDR
// for j = 1 to k do
111199: LD_ADDR_VAR 0 8
111203: PUSH
111204: DOUBLE
111205: LD_INT 1
111207: DEC
111208: ST_TO_ADDR
111209: LD_VAR 0 9
111213: PUSH
111214: FOR_TO
111215: IFFALSE 111347
// begin if GetType ( tmp [ j ] ) = unit_building then
111217: LD_VAR 0 14
111221: PUSH
111222: LD_VAR 0 8
111226: ARRAY
111227: PPUSH
111228: CALL_OW 247
111232: PUSH
111233: LD_INT 3
111235: EQUAL
111236: IFFALSE 111345
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
111238: LD_VAR 0 14
111242: PUSH
111243: LD_VAR 0 8
111247: ARRAY
111248: PUSH
111249: LD_VAR 0 28
111253: IN
111254: NOT
111255: PUSH
111256: LD_VAR 0 14
111260: PUSH
111261: LD_VAR 0 8
111265: ARRAY
111266: PPUSH
111267: CALL_OW 313
111271: AND
111272: IFFALSE 111345
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111274: LD_VAR 0 4
111278: PUSH
111279: LD_VAR 0 7
111283: ARRAY
111284: PPUSH
111285: LD_VAR 0 14
111289: PUSH
111290: LD_VAR 0 8
111294: ARRAY
111295: PPUSH
111296: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
111300: LD_ADDR_VAR 0 28
111304: PUSH
111305: LD_VAR 0 28
111309: PPUSH
111310: LD_VAR 0 28
111314: PUSH
111315: LD_INT 1
111317: PLUS
111318: PPUSH
111319: LD_VAR 0 14
111323: PUSH
111324: LD_VAR 0 8
111328: ARRAY
111329: PPUSH
111330: CALL_OW 1
111334: ST_TO_ADDR
// attacking := true ;
111335: LD_ADDR_VAR 0 29
111339: PUSH
111340: LD_INT 1
111342: ST_TO_ADDR
// break ;
111343: GO 111347
// end ; end ;
111345: GO 111214
111347: POP
111348: POP
// if not attacking and f_attack_depot then
111349: LD_VAR 0 29
111353: NOT
111354: PUSH
111355: LD_VAR 0 25
111359: AND
111360: IFFALSE 111455
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111362: LD_ADDR_VAR 0 13
111366: PUSH
111367: LD_VAR 0 14
111371: PPUSH
111372: LD_INT 2
111374: PUSH
111375: LD_INT 30
111377: PUSH
111378: LD_INT 0
111380: PUSH
111381: EMPTY
111382: LIST
111383: LIST
111384: PUSH
111385: LD_INT 30
111387: PUSH
111388: LD_INT 1
111390: PUSH
111391: EMPTY
111392: LIST
111393: LIST
111394: PUSH
111395: EMPTY
111396: LIST
111397: LIST
111398: LIST
111399: PPUSH
111400: CALL_OW 72
111404: ST_TO_ADDR
// if z then
111405: LD_VAR 0 13
111409: IFFALSE 111455
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
111411: LD_VAR 0 4
111415: PUSH
111416: LD_VAR 0 7
111420: ARRAY
111421: PPUSH
111422: LD_VAR 0 13
111426: PPUSH
111427: LD_VAR 0 4
111431: PUSH
111432: LD_VAR 0 7
111436: ARRAY
111437: PPUSH
111438: CALL_OW 74
111442: PPUSH
111443: CALL_OW 115
// attacking := true ;
111447: LD_ADDR_VAR 0 29
111451: PUSH
111452: LD_INT 1
111454: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
111455: LD_VAR 0 4
111459: PUSH
111460: LD_VAR 0 7
111464: ARRAY
111465: PPUSH
111466: CALL_OW 256
111470: PUSH
111471: LD_INT 500
111473: LESS
111474: IFFALSE 111500
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111476: LD_VAR 0 4
111480: PUSH
111481: LD_VAR 0 7
111485: ARRAY
111486: PPUSH
111487: LD_VAR 0 14
111491: PUSH
111492: LD_INT 1
111494: ARRAY
111495: PPUSH
111496: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
111500: LD_VAR 0 4
111504: PUSH
111505: LD_VAR 0 7
111509: ARRAY
111510: PPUSH
111511: CALL_OW 264
111515: PUSH
111516: LD_INT 49
111518: EQUAL
111519: IFFALSE 111640
// begin if not HasTask ( group [ i ] ) then
111521: LD_VAR 0 4
111525: PUSH
111526: LD_VAR 0 7
111530: ARRAY
111531: PPUSH
111532: CALL_OW 314
111536: NOT
111537: IFFALSE 111640
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
111539: LD_ADDR_VAR 0 9
111543: PUSH
111544: LD_INT 81
111546: PUSH
111547: LD_VAR 0 4
111551: PUSH
111552: LD_VAR 0 7
111556: ARRAY
111557: PPUSH
111558: CALL_OW 255
111562: PUSH
111563: EMPTY
111564: LIST
111565: LIST
111566: PPUSH
111567: CALL_OW 69
111571: PPUSH
111572: LD_VAR 0 4
111576: PUSH
111577: LD_VAR 0 7
111581: ARRAY
111582: PPUSH
111583: CALL_OW 74
111587: ST_TO_ADDR
// if k then
111588: LD_VAR 0 9
111592: IFFALSE 111640
// if GetDistUnits ( group [ i ] , k ) > 10 then
111594: LD_VAR 0 4
111598: PUSH
111599: LD_VAR 0 7
111603: ARRAY
111604: PPUSH
111605: LD_VAR 0 9
111609: PPUSH
111610: CALL_OW 296
111614: PUSH
111615: LD_INT 10
111617: GREATER
111618: IFFALSE 111640
// ComMoveUnit ( group [ i ] , k ) ;
111620: LD_VAR 0 4
111624: PUSH
111625: LD_VAR 0 7
111629: ARRAY
111630: PPUSH
111631: LD_VAR 0 9
111635: PPUSH
111636: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
111640: LD_VAR 0 4
111644: PUSH
111645: LD_VAR 0 7
111649: ARRAY
111650: PPUSH
111651: CALL_OW 256
111655: PUSH
111656: LD_INT 250
111658: LESS
111659: PUSH
111660: LD_VAR 0 4
111664: PUSH
111665: LD_VAR 0 7
111669: ARRAY
111670: PUSH
111671: LD_INT 21
111673: PUSH
111674: LD_INT 2
111676: PUSH
111677: EMPTY
111678: LIST
111679: LIST
111680: PUSH
111681: LD_INT 23
111683: PUSH
111684: LD_INT 2
111686: PUSH
111687: EMPTY
111688: LIST
111689: LIST
111690: PUSH
111691: EMPTY
111692: LIST
111693: LIST
111694: PPUSH
111695: CALL_OW 69
111699: IN
111700: AND
111701: IFFALSE 111826
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
111703: LD_ADDR_VAR 0 9
111707: PUSH
111708: LD_OWVAR 3
111712: PUSH
111713: LD_VAR 0 4
111717: PUSH
111718: LD_VAR 0 7
111722: ARRAY
111723: DIFF
111724: PPUSH
111725: LD_VAR 0 4
111729: PUSH
111730: LD_VAR 0 7
111734: ARRAY
111735: PPUSH
111736: CALL_OW 74
111740: ST_TO_ADDR
// if not k then
111741: LD_VAR 0 9
111745: NOT
111746: IFFALSE 111750
// continue ;
111748: GO 108165
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
111750: LD_VAR 0 9
111754: PUSH
111755: LD_INT 81
111757: PUSH
111758: LD_VAR 0 4
111762: PUSH
111763: LD_VAR 0 7
111767: ARRAY
111768: PPUSH
111769: CALL_OW 255
111773: PUSH
111774: EMPTY
111775: LIST
111776: LIST
111777: PPUSH
111778: CALL_OW 69
111782: IN
111783: PUSH
111784: LD_VAR 0 9
111788: PPUSH
111789: LD_VAR 0 4
111793: PUSH
111794: LD_VAR 0 7
111798: ARRAY
111799: PPUSH
111800: CALL_OW 296
111804: PUSH
111805: LD_INT 5
111807: LESS
111808: AND
111809: IFFALSE 111826
// ComAutodestruct ( group [ i ] ) ;
111811: LD_VAR 0 4
111815: PUSH
111816: LD_VAR 0 7
111820: ARRAY
111821: PPUSH
111822: CALL 48285 0 1
// end ; if f_attack_depot then
111826: LD_VAR 0 25
111830: IFFALSE 111942
// begin k := 6 ;
111832: LD_ADDR_VAR 0 9
111836: PUSH
111837: LD_INT 6
111839: ST_TO_ADDR
// if tmp < k then
111840: LD_VAR 0 14
111844: PUSH
111845: LD_VAR 0 9
111849: LESS
111850: IFFALSE 111862
// k := tmp ;
111852: LD_ADDR_VAR 0 9
111856: PUSH
111857: LD_VAR 0 14
111861: ST_TO_ADDR
// for j = 1 to k do
111862: LD_ADDR_VAR 0 8
111866: PUSH
111867: DOUBLE
111868: LD_INT 1
111870: DEC
111871: ST_TO_ADDR
111872: LD_VAR 0 9
111876: PUSH
111877: FOR_TO
111878: IFFALSE 111940
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
111880: LD_VAR 0 8
111884: PPUSH
111885: CALL_OW 266
111889: PUSH
111890: LD_INT 0
111892: PUSH
111893: LD_INT 1
111895: PUSH
111896: EMPTY
111897: LIST
111898: LIST
111899: IN
111900: IFFALSE 111938
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111902: LD_VAR 0 4
111906: PUSH
111907: LD_VAR 0 7
111911: ARRAY
111912: PPUSH
111913: LD_VAR 0 14
111917: PUSH
111918: LD_VAR 0 8
111922: ARRAY
111923: PPUSH
111924: CALL_OW 115
// attacking := true ;
111928: LD_ADDR_VAR 0 29
111932: PUSH
111933: LD_INT 1
111935: ST_TO_ADDR
// break ;
111936: GO 111940
// end ;
111938: GO 111877
111940: POP
111941: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
111942: LD_VAR 0 4
111946: PUSH
111947: LD_VAR 0 7
111951: ARRAY
111952: PPUSH
111953: CALL_OW 302
111957: PUSH
111958: LD_VAR 0 29
111962: NOT
111963: AND
111964: IFFALSE 112286
// begin if GetTag ( group [ i ] ) = 71 then
111966: LD_VAR 0 4
111970: PUSH
111971: LD_VAR 0 7
111975: ARRAY
111976: PPUSH
111977: CALL_OW 110
111981: PUSH
111982: LD_INT 71
111984: EQUAL
111985: IFFALSE 112026
// begin if HasTask ( group [ i ] ) then
111987: LD_VAR 0 4
111991: PUSH
111992: LD_VAR 0 7
111996: ARRAY
111997: PPUSH
111998: CALL_OW 314
112002: IFFALSE 112008
// continue else
112004: GO 108165
112006: GO 112026
// SetTag ( group [ i ] , 0 ) ;
112008: LD_VAR 0 4
112012: PUSH
112013: LD_VAR 0 7
112017: ARRAY
112018: PPUSH
112019: LD_INT 0
112021: PPUSH
112022: CALL_OW 109
// end ; k := 8 ;
112026: LD_ADDR_VAR 0 9
112030: PUSH
112031: LD_INT 8
112033: ST_TO_ADDR
// x := 0 ;
112034: LD_ADDR_VAR 0 10
112038: PUSH
112039: LD_INT 0
112041: ST_TO_ADDR
// if tmp < k then
112042: LD_VAR 0 14
112046: PUSH
112047: LD_VAR 0 9
112051: LESS
112052: IFFALSE 112064
// k := tmp ;
112054: LD_ADDR_VAR 0 9
112058: PUSH
112059: LD_VAR 0 14
112063: ST_TO_ADDR
// for j = 1 to k do
112064: LD_ADDR_VAR 0 8
112068: PUSH
112069: DOUBLE
112070: LD_INT 1
112072: DEC
112073: ST_TO_ADDR
112074: LD_VAR 0 9
112078: PUSH
112079: FOR_TO
112080: IFFALSE 112178
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
112082: LD_VAR 0 14
112086: PUSH
112087: LD_VAR 0 8
112091: ARRAY
112092: PPUSH
112093: CALL_OW 247
112097: PUSH
112098: LD_INT 1
112100: EQUAL
112101: PUSH
112102: LD_VAR 0 14
112106: PUSH
112107: LD_VAR 0 8
112111: ARRAY
112112: PPUSH
112113: CALL_OW 256
112117: PUSH
112118: LD_INT 250
112120: LESS
112121: PUSH
112122: LD_VAR 0 20
112126: AND
112127: PUSH
112128: LD_VAR 0 20
112132: NOT
112133: PUSH
112134: LD_VAR 0 14
112138: PUSH
112139: LD_VAR 0 8
112143: ARRAY
112144: PPUSH
112145: CALL_OW 256
112149: PUSH
112150: LD_INT 250
112152: GREATEREQUAL
112153: AND
112154: OR
112155: AND
112156: IFFALSE 112176
// begin x := tmp [ j ] ;
112158: LD_ADDR_VAR 0 10
112162: PUSH
112163: LD_VAR 0 14
112167: PUSH
112168: LD_VAR 0 8
112172: ARRAY
112173: ST_TO_ADDR
// break ;
112174: GO 112178
// end ;
112176: GO 112079
112178: POP
112179: POP
// if x then
112180: LD_VAR 0 10
112184: IFFALSE 112208
// ComAttackUnit ( group [ i ] , x ) else
112186: LD_VAR 0 4
112190: PUSH
112191: LD_VAR 0 7
112195: ARRAY
112196: PPUSH
112197: LD_VAR 0 10
112201: PPUSH
112202: CALL_OW 115
112206: GO 112232
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112208: LD_VAR 0 4
112212: PUSH
112213: LD_VAR 0 7
112217: ARRAY
112218: PPUSH
112219: LD_VAR 0 14
112223: PUSH
112224: LD_INT 1
112226: ARRAY
112227: PPUSH
112228: CALL_OW 115
// if not HasTask ( group [ i ] ) then
112232: LD_VAR 0 4
112236: PUSH
112237: LD_VAR 0 7
112241: ARRAY
112242: PPUSH
112243: CALL_OW 314
112247: NOT
112248: IFFALSE 112286
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
112250: LD_VAR 0 4
112254: PUSH
112255: LD_VAR 0 7
112259: ARRAY
112260: PPUSH
112261: LD_VAR 0 14
112265: PPUSH
112266: LD_VAR 0 4
112270: PUSH
112271: LD_VAR 0 7
112275: ARRAY
112276: PPUSH
112277: CALL_OW 74
112281: PPUSH
112282: CALL_OW 115
// end ; end ; end ;
112286: GO 108165
112288: POP
112289: POP
// wait ( 0 0$2 ) ;
112290: LD_INT 70
112292: PPUSH
112293: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
112297: LD_VAR 0 4
112301: NOT
112302: PUSH
112303: LD_VAR 0 4
112307: PUSH
112308: EMPTY
112309: EQUAL
112310: OR
112311: PUSH
112312: LD_INT 81
112314: PUSH
112315: LD_VAR 0 35
112319: PUSH
112320: EMPTY
112321: LIST
112322: LIST
112323: PPUSH
112324: CALL_OW 69
112328: NOT
112329: OR
112330: IFFALSE 108150
// end ;
112332: LD_VAR 0 2
112336: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
112337: LD_INT 0
112339: PPUSH
112340: PPUSH
112341: PPUSH
112342: PPUSH
112343: PPUSH
112344: PPUSH
// if not base or not mc_bases [ base ] or not solds then
112345: LD_VAR 0 1
112349: NOT
112350: PUSH
112351: LD_EXP 61
112355: PUSH
112356: LD_VAR 0 1
112360: ARRAY
112361: NOT
112362: OR
112363: PUSH
112364: LD_VAR 0 2
112368: NOT
112369: OR
112370: IFFALSE 112374
// exit ;
112372: GO 112928
// side := mc_sides [ base ] ;
112374: LD_ADDR_VAR 0 6
112378: PUSH
112379: LD_EXP 87
112383: PUSH
112384: LD_VAR 0 1
112388: ARRAY
112389: ST_TO_ADDR
// if not side then
112390: LD_VAR 0 6
112394: NOT
112395: IFFALSE 112399
// exit ;
112397: GO 112928
// for i in solds do
112399: LD_ADDR_VAR 0 7
112403: PUSH
112404: LD_VAR 0 2
112408: PUSH
112409: FOR_IN
112410: IFFALSE 112471
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
112412: LD_VAR 0 7
112416: PPUSH
112417: CALL_OW 310
112421: PPUSH
112422: CALL_OW 266
112426: PUSH
112427: LD_INT 32
112429: PUSH
112430: LD_INT 31
112432: PUSH
112433: EMPTY
112434: LIST
112435: LIST
112436: IN
112437: IFFALSE 112457
// solds := solds diff i else
112439: LD_ADDR_VAR 0 2
112443: PUSH
112444: LD_VAR 0 2
112448: PUSH
112449: LD_VAR 0 7
112453: DIFF
112454: ST_TO_ADDR
112455: GO 112469
// SetTag ( i , 18 ) ;
112457: LD_VAR 0 7
112461: PPUSH
112462: LD_INT 18
112464: PPUSH
112465: CALL_OW 109
112469: GO 112409
112471: POP
112472: POP
// if not solds then
112473: LD_VAR 0 2
112477: NOT
112478: IFFALSE 112482
// exit ;
112480: GO 112928
// repeat wait ( 0 0$2 ) ;
112482: LD_INT 70
112484: PPUSH
112485: CALL_OW 67
// enemy := mc_scan [ base ] ;
112489: LD_ADDR_VAR 0 4
112493: PUSH
112494: LD_EXP 84
112498: PUSH
112499: LD_VAR 0 1
112503: ARRAY
112504: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112505: LD_EXP 61
112509: PUSH
112510: LD_VAR 0 1
112514: ARRAY
112515: NOT
112516: PUSH
112517: LD_EXP 61
112521: PUSH
112522: LD_VAR 0 1
112526: ARRAY
112527: PUSH
112528: EMPTY
112529: EQUAL
112530: OR
112531: IFFALSE 112568
// begin for i in solds do
112533: LD_ADDR_VAR 0 7
112537: PUSH
112538: LD_VAR 0 2
112542: PUSH
112543: FOR_IN
112544: IFFALSE 112557
// ComStop ( i ) ;
112546: LD_VAR 0 7
112550: PPUSH
112551: CALL_OW 141
112555: GO 112543
112557: POP
112558: POP
// solds := [ ] ;
112559: LD_ADDR_VAR 0 2
112563: PUSH
112564: EMPTY
112565: ST_TO_ADDR
// exit ;
112566: GO 112928
// end ; for i in solds do
112568: LD_ADDR_VAR 0 7
112572: PUSH
112573: LD_VAR 0 2
112577: PUSH
112578: FOR_IN
112579: IFFALSE 112900
// begin if IsInUnit ( i ) then
112581: LD_VAR 0 7
112585: PPUSH
112586: CALL_OW 310
112590: IFFALSE 112601
// ComExitBuilding ( i ) ;
112592: LD_VAR 0 7
112596: PPUSH
112597: CALL_OW 122
// if GetLives ( i ) > 500 then
112601: LD_VAR 0 7
112605: PPUSH
112606: CALL_OW 256
112610: PUSH
112611: LD_INT 500
112613: GREATER
112614: IFFALSE 112667
// begin e := NearestUnitToUnit ( enemy , i ) ;
112616: LD_ADDR_VAR 0 5
112620: PUSH
112621: LD_VAR 0 4
112625: PPUSH
112626: LD_VAR 0 7
112630: PPUSH
112631: CALL_OW 74
112635: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
112636: LD_VAR 0 7
112640: PPUSH
112641: LD_VAR 0 5
112645: PPUSH
112646: CALL_OW 250
112650: PPUSH
112651: LD_VAR 0 5
112655: PPUSH
112656: CALL_OW 251
112660: PPUSH
112661: CALL_OW 114
// end else
112665: GO 112898
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
112667: LD_VAR 0 7
112671: PPUSH
112672: LD_EXP 61
112676: PUSH
112677: LD_VAR 0 1
112681: ARRAY
112682: PPUSH
112683: LD_INT 2
112685: PUSH
112686: LD_INT 30
112688: PUSH
112689: LD_INT 0
112691: PUSH
112692: EMPTY
112693: LIST
112694: LIST
112695: PUSH
112696: LD_INT 30
112698: PUSH
112699: LD_INT 1
112701: PUSH
112702: EMPTY
112703: LIST
112704: LIST
112705: PUSH
112706: LD_INT 30
112708: PUSH
112709: LD_INT 6
112711: PUSH
112712: EMPTY
112713: LIST
112714: LIST
112715: PUSH
112716: EMPTY
112717: LIST
112718: LIST
112719: LIST
112720: LIST
112721: PPUSH
112722: CALL_OW 72
112726: PPUSH
112727: LD_VAR 0 7
112731: PPUSH
112732: CALL_OW 74
112736: PPUSH
112737: CALL_OW 296
112741: PUSH
112742: LD_INT 10
112744: GREATER
112745: IFFALSE 112898
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
112747: LD_ADDR_VAR 0 8
112751: PUSH
112752: LD_EXP 61
112756: PUSH
112757: LD_VAR 0 1
112761: ARRAY
112762: PPUSH
112763: LD_INT 2
112765: PUSH
112766: LD_INT 30
112768: PUSH
112769: LD_INT 0
112771: PUSH
112772: EMPTY
112773: LIST
112774: LIST
112775: PUSH
112776: LD_INT 30
112778: PUSH
112779: LD_INT 1
112781: PUSH
112782: EMPTY
112783: LIST
112784: LIST
112785: PUSH
112786: LD_INT 30
112788: PUSH
112789: LD_INT 6
112791: PUSH
112792: EMPTY
112793: LIST
112794: LIST
112795: PUSH
112796: EMPTY
112797: LIST
112798: LIST
112799: LIST
112800: LIST
112801: PPUSH
112802: CALL_OW 72
112806: PPUSH
112807: LD_VAR 0 7
112811: PPUSH
112812: CALL_OW 74
112816: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
112817: LD_VAR 0 7
112821: PPUSH
112822: LD_VAR 0 8
112826: PPUSH
112827: CALL_OW 250
112831: PPUSH
112832: LD_INT 3
112834: PPUSH
112835: LD_INT 5
112837: PPUSH
112838: CALL_OW 272
112842: PPUSH
112843: LD_VAR 0 8
112847: PPUSH
112848: CALL_OW 251
112852: PPUSH
112853: LD_INT 3
112855: PPUSH
112856: LD_INT 5
112858: PPUSH
112859: CALL_OW 273
112863: PPUSH
112864: CALL_OW 111
// SetTag ( i , 0 ) ;
112868: LD_VAR 0 7
112872: PPUSH
112873: LD_INT 0
112875: PPUSH
112876: CALL_OW 109
// solds := solds diff i ;
112880: LD_ADDR_VAR 0 2
112884: PUSH
112885: LD_VAR 0 2
112889: PUSH
112890: LD_VAR 0 7
112894: DIFF
112895: ST_TO_ADDR
// continue ;
112896: GO 112578
// end ; end ;
112898: GO 112578
112900: POP
112901: POP
// until not solds or not enemy ;
112902: LD_VAR 0 2
112906: NOT
112907: PUSH
112908: LD_VAR 0 4
112912: NOT
112913: OR
112914: IFFALSE 112482
// MC_Reset ( base , 18 ) ;
112916: LD_VAR 0 1
112920: PPUSH
112921: LD_INT 18
112923: PPUSH
112924: CALL 61012 0 2
// end ;
112928: LD_VAR 0 3
112932: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
112933: LD_INT 0
112935: PPUSH
112936: PPUSH
112937: PPUSH
112938: PPUSH
112939: PPUSH
112940: PPUSH
112941: PPUSH
112942: PPUSH
112943: PPUSH
112944: PPUSH
112945: PPUSH
112946: PPUSH
112947: PPUSH
112948: PPUSH
112949: PPUSH
112950: PPUSH
112951: PPUSH
112952: PPUSH
112953: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
112954: LD_ADDR_VAR 0 12
112958: PUSH
112959: LD_EXP 61
112963: PUSH
112964: LD_VAR 0 1
112968: ARRAY
112969: PPUSH
112970: LD_INT 25
112972: PUSH
112973: LD_INT 3
112975: PUSH
112976: EMPTY
112977: LIST
112978: LIST
112979: PPUSH
112980: CALL_OW 72
112984: ST_TO_ADDR
// if mc_remote_driver [ base ] then
112985: LD_EXP 101
112989: PUSH
112990: LD_VAR 0 1
112994: ARRAY
112995: IFFALSE 113019
// mechs := mechs diff mc_remote_driver [ base ] ;
112997: LD_ADDR_VAR 0 12
113001: PUSH
113002: LD_VAR 0 12
113006: PUSH
113007: LD_EXP 101
113011: PUSH
113012: LD_VAR 0 1
113016: ARRAY
113017: DIFF
113018: ST_TO_ADDR
// for i in mechs do
113019: LD_ADDR_VAR 0 4
113023: PUSH
113024: LD_VAR 0 12
113028: PUSH
113029: FOR_IN
113030: IFFALSE 113065
// if GetTag ( i ) > 0 then
113032: LD_VAR 0 4
113036: PPUSH
113037: CALL_OW 110
113041: PUSH
113042: LD_INT 0
113044: GREATER
113045: IFFALSE 113063
// mechs := mechs diff i ;
113047: LD_ADDR_VAR 0 12
113051: PUSH
113052: LD_VAR 0 12
113056: PUSH
113057: LD_VAR 0 4
113061: DIFF
113062: ST_TO_ADDR
113063: GO 113029
113065: POP
113066: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
113067: LD_ADDR_VAR 0 8
113071: PUSH
113072: LD_EXP 61
113076: PUSH
113077: LD_VAR 0 1
113081: ARRAY
113082: PPUSH
113083: LD_INT 2
113085: PUSH
113086: LD_INT 25
113088: PUSH
113089: LD_INT 1
113091: PUSH
113092: EMPTY
113093: LIST
113094: LIST
113095: PUSH
113096: LD_INT 25
113098: PUSH
113099: LD_INT 5
113101: PUSH
113102: EMPTY
113103: LIST
113104: LIST
113105: PUSH
113106: LD_INT 25
113108: PUSH
113109: LD_INT 8
113111: PUSH
113112: EMPTY
113113: LIST
113114: LIST
113115: PUSH
113116: LD_INT 25
113118: PUSH
113119: LD_INT 9
113121: PUSH
113122: EMPTY
113123: LIST
113124: LIST
113125: PUSH
113126: EMPTY
113127: LIST
113128: LIST
113129: LIST
113130: LIST
113131: LIST
113132: PPUSH
113133: CALL_OW 72
113137: ST_TO_ADDR
// if not defenders and not solds then
113138: LD_VAR 0 2
113142: NOT
113143: PUSH
113144: LD_VAR 0 8
113148: NOT
113149: AND
113150: IFFALSE 113154
// exit ;
113152: GO 114924
// depot_under_attack := false ;
113154: LD_ADDR_VAR 0 16
113158: PUSH
113159: LD_INT 0
113161: ST_TO_ADDR
// sold_defenders := [ ] ;
113162: LD_ADDR_VAR 0 17
113166: PUSH
113167: EMPTY
113168: ST_TO_ADDR
// if mechs then
113169: LD_VAR 0 12
113173: IFFALSE 113326
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
113175: LD_ADDR_VAR 0 4
113179: PUSH
113180: LD_VAR 0 2
113184: PPUSH
113185: LD_INT 21
113187: PUSH
113188: LD_INT 2
113190: PUSH
113191: EMPTY
113192: LIST
113193: LIST
113194: PPUSH
113195: CALL_OW 72
113199: PUSH
113200: FOR_IN
113201: IFFALSE 113324
// begin if GetTag ( i ) <> 20 then
113203: LD_VAR 0 4
113207: PPUSH
113208: CALL_OW 110
113212: PUSH
113213: LD_INT 20
113215: NONEQUAL
113216: IFFALSE 113230
// SetTag ( i , 20 ) ;
113218: LD_VAR 0 4
113222: PPUSH
113223: LD_INT 20
113225: PPUSH
113226: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
113230: LD_VAR 0 4
113234: PPUSH
113235: CALL_OW 263
113239: PUSH
113240: LD_INT 1
113242: EQUAL
113243: PUSH
113244: LD_VAR 0 4
113248: PPUSH
113249: CALL_OW 311
113253: NOT
113254: AND
113255: IFFALSE 113322
// begin un := mechs [ 1 ] ;
113257: LD_ADDR_VAR 0 10
113261: PUSH
113262: LD_VAR 0 12
113266: PUSH
113267: LD_INT 1
113269: ARRAY
113270: ST_TO_ADDR
// ComExit ( un ) ;
113271: LD_VAR 0 10
113275: PPUSH
113276: CALL 53169 0 1
// AddComEnterUnit ( un , i ) ;
113280: LD_VAR 0 10
113284: PPUSH
113285: LD_VAR 0 4
113289: PPUSH
113290: CALL_OW 180
// SetTag ( un , 19 ) ;
113294: LD_VAR 0 10
113298: PPUSH
113299: LD_INT 19
113301: PPUSH
113302: CALL_OW 109
// mechs := mechs diff un ;
113306: LD_ADDR_VAR 0 12
113310: PUSH
113311: LD_VAR 0 12
113315: PUSH
113316: LD_VAR 0 10
113320: DIFF
113321: ST_TO_ADDR
// end ; end ;
113322: GO 113200
113324: POP
113325: POP
// if solds then
113326: LD_VAR 0 8
113330: IFFALSE 113389
// for i in solds do
113332: LD_ADDR_VAR 0 4
113336: PUSH
113337: LD_VAR 0 8
113341: PUSH
113342: FOR_IN
113343: IFFALSE 113387
// if not GetTag ( i ) then
113345: LD_VAR 0 4
113349: PPUSH
113350: CALL_OW 110
113354: NOT
113355: IFFALSE 113385
// begin defenders := defenders union i ;
113357: LD_ADDR_VAR 0 2
113361: PUSH
113362: LD_VAR 0 2
113366: PUSH
113367: LD_VAR 0 4
113371: UNION
113372: ST_TO_ADDR
// SetTag ( i , 18 ) ;
113373: LD_VAR 0 4
113377: PPUSH
113378: LD_INT 18
113380: PPUSH
113381: CALL_OW 109
// end ;
113385: GO 113342
113387: POP
113388: POP
// repeat wait ( 0 0$2 ) ;
113389: LD_INT 70
113391: PPUSH
113392: CALL_OW 67
// enemy := mc_scan [ base ] ;
113396: LD_ADDR_VAR 0 21
113400: PUSH
113401: LD_EXP 84
113405: PUSH
113406: LD_VAR 0 1
113410: ARRAY
113411: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
113412: LD_EXP 61
113416: PUSH
113417: LD_VAR 0 1
113421: ARRAY
113422: NOT
113423: PUSH
113424: LD_EXP 61
113428: PUSH
113429: LD_VAR 0 1
113433: ARRAY
113434: PUSH
113435: EMPTY
113436: EQUAL
113437: OR
113438: IFFALSE 113475
// begin for i in defenders do
113440: LD_ADDR_VAR 0 4
113444: PUSH
113445: LD_VAR 0 2
113449: PUSH
113450: FOR_IN
113451: IFFALSE 113464
// ComStop ( i ) ;
113453: LD_VAR 0 4
113457: PPUSH
113458: CALL_OW 141
113462: GO 113450
113464: POP
113465: POP
// defenders := [ ] ;
113466: LD_ADDR_VAR 0 2
113470: PUSH
113471: EMPTY
113472: ST_TO_ADDR
// exit ;
113473: GO 114924
// end ; for i in defenders do
113475: LD_ADDR_VAR 0 4
113479: PUSH
113480: LD_VAR 0 2
113484: PUSH
113485: FOR_IN
113486: IFFALSE 114384
// begin e := NearestUnitToUnit ( enemy , i ) ;
113488: LD_ADDR_VAR 0 13
113492: PUSH
113493: LD_VAR 0 21
113497: PPUSH
113498: LD_VAR 0 4
113502: PPUSH
113503: CALL_OW 74
113507: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113508: LD_ADDR_VAR 0 7
113512: PUSH
113513: LD_EXP 61
113517: PUSH
113518: LD_VAR 0 1
113522: ARRAY
113523: PPUSH
113524: LD_INT 2
113526: PUSH
113527: LD_INT 30
113529: PUSH
113530: LD_INT 0
113532: PUSH
113533: EMPTY
113534: LIST
113535: LIST
113536: PUSH
113537: LD_INT 30
113539: PUSH
113540: LD_INT 1
113542: PUSH
113543: EMPTY
113544: LIST
113545: LIST
113546: PUSH
113547: EMPTY
113548: LIST
113549: LIST
113550: LIST
113551: PPUSH
113552: CALL_OW 72
113556: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
113557: LD_ADDR_VAR 0 16
113561: PUSH
113562: LD_VAR 0 7
113566: NOT
113567: PUSH
113568: LD_VAR 0 7
113572: PPUSH
113573: LD_INT 3
113575: PUSH
113576: LD_INT 24
113578: PUSH
113579: LD_INT 600
113581: PUSH
113582: EMPTY
113583: LIST
113584: LIST
113585: PUSH
113586: EMPTY
113587: LIST
113588: LIST
113589: PPUSH
113590: CALL_OW 72
113594: OR
113595: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
113596: LD_VAR 0 4
113600: PPUSH
113601: CALL_OW 247
113605: PUSH
113606: LD_INT 2
113608: DOUBLE
113609: EQUAL
113610: IFTRUE 113614
113612: GO 114010
113614: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
113615: LD_VAR 0 4
113619: PPUSH
113620: CALL_OW 256
113624: PUSH
113625: LD_INT 1000
113627: EQUAL
113628: PUSH
113629: LD_VAR 0 4
113633: PPUSH
113634: LD_VAR 0 13
113638: PPUSH
113639: CALL_OW 296
113643: PUSH
113644: LD_INT 40
113646: LESS
113647: PUSH
113648: LD_VAR 0 13
113652: PPUSH
113653: LD_EXP 86
113657: PUSH
113658: LD_VAR 0 1
113662: ARRAY
113663: PPUSH
113664: CALL_OW 308
113668: OR
113669: AND
113670: IFFALSE 113792
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
113672: LD_VAR 0 4
113676: PPUSH
113677: CALL_OW 262
113681: PUSH
113682: LD_INT 1
113684: EQUAL
113685: PUSH
113686: LD_VAR 0 4
113690: PPUSH
113691: CALL_OW 261
113695: PUSH
113696: LD_INT 30
113698: LESS
113699: AND
113700: PUSH
113701: LD_VAR 0 7
113705: AND
113706: IFFALSE 113776
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
113708: LD_VAR 0 4
113712: PPUSH
113713: LD_VAR 0 7
113717: PPUSH
113718: LD_VAR 0 4
113722: PPUSH
113723: CALL_OW 74
113727: PPUSH
113728: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
113732: LD_VAR 0 4
113736: PPUSH
113737: LD_VAR 0 7
113741: PPUSH
113742: LD_VAR 0 4
113746: PPUSH
113747: CALL_OW 74
113751: PPUSH
113752: CALL_OW 296
113756: PUSH
113757: LD_INT 6
113759: LESS
113760: IFFALSE 113774
// SetFuel ( i , 100 ) ;
113762: LD_VAR 0 4
113766: PPUSH
113767: LD_INT 100
113769: PPUSH
113770: CALL_OW 240
// end else
113774: GO 113790
// ComAttackUnit ( i , e ) ;
113776: LD_VAR 0 4
113780: PPUSH
113781: LD_VAR 0 13
113785: PPUSH
113786: CALL_OW 115
// end else
113790: GO 113893
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
113792: LD_VAR 0 13
113796: PPUSH
113797: LD_EXP 86
113801: PUSH
113802: LD_VAR 0 1
113806: ARRAY
113807: PPUSH
113808: CALL_OW 308
113812: NOT
113813: PUSH
113814: LD_VAR 0 4
113818: PPUSH
113819: LD_VAR 0 13
113823: PPUSH
113824: CALL_OW 296
113828: PUSH
113829: LD_INT 40
113831: GREATEREQUAL
113832: AND
113833: PUSH
113834: LD_VAR 0 4
113838: PPUSH
113839: CALL_OW 256
113843: PUSH
113844: LD_INT 650
113846: LESSEQUAL
113847: OR
113848: PUSH
113849: LD_VAR 0 4
113853: PPUSH
113854: LD_EXP 85
113858: PUSH
113859: LD_VAR 0 1
113863: ARRAY
113864: PPUSH
113865: CALL_OW 308
113869: NOT
113870: AND
113871: IFFALSE 113893
// ComMoveToArea ( i , mc_parking [ base ] ) ;
113873: LD_VAR 0 4
113877: PPUSH
113878: LD_EXP 85
113882: PUSH
113883: LD_VAR 0 1
113887: ARRAY
113888: PPUSH
113889: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
113893: LD_VAR 0 4
113897: PPUSH
113898: CALL_OW 256
113902: PUSH
113903: LD_INT 1000
113905: LESS
113906: PUSH
113907: LD_VAR 0 4
113911: PPUSH
113912: CALL_OW 263
113916: PUSH
113917: LD_INT 1
113919: EQUAL
113920: AND
113921: PUSH
113922: LD_VAR 0 4
113926: PPUSH
113927: CALL_OW 311
113931: AND
113932: PUSH
113933: LD_VAR 0 4
113937: PPUSH
113938: LD_EXP 85
113942: PUSH
113943: LD_VAR 0 1
113947: ARRAY
113948: PPUSH
113949: CALL_OW 308
113953: AND
113954: IFFALSE 114008
// begin mech := IsDrivenBy ( i ) ;
113956: LD_ADDR_VAR 0 9
113960: PUSH
113961: LD_VAR 0 4
113965: PPUSH
113966: CALL_OW 311
113970: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
113971: LD_VAR 0 9
113975: PPUSH
113976: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
113980: LD_VAR 0 9
113984: PPUSH
113985: LD_VAR 0 4
113989: PPUSH
113990: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
113994: LD_VAR 0 9
113998: PPUSH
113999: LD_VAR 0 4
114003: PPUSH
114004: CALL_OW 180
// end ; end ; unit_human :
114008: GO 114355
114010: LD_INT 1
114012: DOUBLE
114013: EQUAL
114014: IFTRUE 114018
114016: GO 114354
114018: POP
// begin b := IsInUnit ( i ) ;
114019: LD_ADDR_VAR 0 18
114023: PUSH
114024: LD_VAR 0 4
114028: PPUSH
114029: CALL_OW 310
114033: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
114034: LD_ADDR_VAR 0 19
114038: PUSH
114039: LD_VAR 0 18
114043: NOT
114044: PUSH
114045: LD_VAR 0 18
114049: PPUSH
114050: CALL_OW 266
114054: PUSH
114055: LD_INT 32
114057: PUSH
114058: LD_INT 31
114060: PUSH
114061: EMPTY
114062: LIST
114063: LIST
114064: IN
114065: OR
114066: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
114067: LD_VAR 0 18
114071: PPUSH
114072: CALL_OW 266
114076: PUSH
114077: LD_INT 5
114079: EQUAL
114080: PUSH
114081: LD_VAR 0 4
114085: PPUSH
114086: CALL_OW 257
114090: PUSH
114091: LD_INT 1
114093: PUSH
114094: LD_INT 2
114096: PUSH
114097: LD_INT 3
114099: PUSH
114100: LD_INT 4
114102: PUSH
114103: EMPTY
114104: LIST
114105: LIST
114106: LIST
114107: LIST
114108: IN
114109: AND
114110: IFFALSE 114147
// begin class := AllowSpecClass ( i ) ;
114112: LD_ADDR_VAR 0 20
114116: PUSH
114117: LD_VAR 0 4
114121: PPUSH
114122: CALL 17265 0 1
114126: ST_TO_ADDR
// if class then
114127: LD_VAR 0 20
114131: IFFALSE 114147
// ComChangeProfession ( i , class ) ;
114133: LD_VAR 0 4
114137: PPUSH
114138: LD_VAR 0 20
114142: PPUSH
114143: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
114147: LD_VAR 0 16
114151: PUSH
114152: LD_VAR 0 2
114156: PPUSH
114157: LD_INT 21
114159: PUSH
114160: LD_INT 2
114162: PUSH
114163: EMPTY
114164: LIST
114165: LIST
114166: PPUSH
114167: CALL_OW 72
114171: PUSH
114172: LD_INT 1
114174: LESSEQUAL
114175: OR
114176: PUSH
114177: LD_VAR 0 19
114181: AND
114182: PUSH
114183: LD_VAR 0 4
114187: PUSH
114188: LD_VAR 0 17
114192: IN
114193: NOT
114194: AND
114195: IFFALSE 114288
// begin if b then
114197: LD_VAR 0 18
114201: IFFALSE 114250
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
114203: LD_VAR 0 18
114207: PPUSH
114208: LD_VAR 0 21
114212: PPUSH
114213: LD_VAR 0 18
114217: PPUSH
114218: CALL_OW 74
114222: PPUSH
114223: CALL_OW 296
114227: PUSH
114228: LD_INT 10
114230: LESS
114231: PUSH
114232: LD_VAR 0 18
114236: PPUSH
114237: CALL_OW 461
114241: PUSH
114242: LD_INT 7
114244: NONEQUAL
114245: AND
114246: IFFALSE 114250
// continue ;
114248: GO 113485
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
114250: LD_ADDR_VAR 0 17
114254: PUSH
114255: LD_VAR 0 17
114259: PPUSH
114260: LD_VAR 0 17
114264: PUSH
114265: LD_INT 1
114267: PLUS
114268: PPUSH
114269: LD_VAR 0 4
114273: PPUSH
114274: CALL_OW 1
114278: ST_TO_ADDR
// ComExitBuilding ( i ) ;
114279: LD_VAR 0 4
114283: PPUSH
114284: CALL_OW 122
// end ; if sold_defenders then
114288: LD_VAR 0 17
114292: IFFALSE 114352
// if i in sold_defenders then
114294: LD_VAR 0 4
114298: PUSH
114299: LD_VAR 0 17
114303: IN
114304: IFFALSE 114352
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
114306: LD_VAR 0 4
114310: PPUSH
114311: CALL_OW 314
114315: NOT
114316: PUSH
114317: LD_VAR 0 4
114321: PPUSH
114322: LD_VAR 0 13
114326: PPUSH
114327: CALL_OW 296
114331: PUSH
114332: LD_INT 30
114334: LESS
114335: AND
114336: IFFALSE 114352
// ComAttackUnit ( i , e ) ;
114338: LD_VAR 0 4
114342: PPUSH
114343: LD_VAR 0 13
114347: PPUSH
114348: CALL_OW 115
// end ; end ; end ;
114352: GO 114355
114354: POP
// if IsDead ( i ) then
114355: LD_VAR 0 4
114359: PPUSH
114360: CALL_OW 301
114364: IFFALSE 114382
// defenders := defenders diff i ;
114366: LD_ADDR_VAR 0 2
114370: PUSH
114371: LD_VAR 0 2
114375: PUSH
114376: LD_VAR 0 4
114380: DIFF
114381: ST_TO_ADDR
// end ;
114382: GO 113485
114384: POP
114385: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
114386: LD_VAR 0 21
114390: NOT
114391: PUSH
114392: LD_VAR 0 2
114396: NOT
114397: OR
114398: PUSH
114399: LD_EXP 61
114403: PUSH
114404: LD_VAR 0 1
114408: ARRAY
114409: NOT
114410: OR
114411: IFFALSE 113389
// MC_Reset ( base , 18 ) ;
114413: LD_VAR 0 1
114417: PPUSH
114418: LD_INT 18
114420: PPUSH
114421: CALL 61012 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
114425: LD_ADDR_VAR 0 2
114429: PUSH
114430: LD_VAR 0 2
114434: PUSH
114435: LD_VAR 0 2
114439: PPUSH
114440: LD_INT 2
114442: PUSH
114443: LD_INT 25
114445: PUSH
114446: LD_INT 1
114448: PUSH
114449: EMPTY
114450: LIST
114451: LIST
114452: PUSH
114453: LD_INT 25
114455: PUSH
114456: LD_INT 5
114458: PUSH
114459: EMPTY
114460: LIST
114461: LIST
114462: PUSH
114463: LD_INT 25
114465: PUSH
114466: LD_INT 8
114468: PUSH
114469: EMPTY
114470: LIST
114471: LIST
114472: PUSH
114473: LD_INT 25
114475: PUSH
114476: LD_INT 9
114478: PUSH
114479: EMPTY
114480: LIST
114481: LIST
114482: PUSH
114483: EMPTY
114484: LIST
114485: LIST
114486: LIST
114487: LIST
114488: LIST
114489: PPUSH
114490: CALL_OW 72
114494: DIFF
114495: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
114496: LD_VAR 0 21
114500: NOT
114501: PUSH
114502: LD_VAR 0 2
114506: PPUSH
114507: LD_INT 21
114509: PUSH
114510: LD_INT 2
114512: PUSH
114513: EMPTY
114514: LIST
114515: LIST
114516: PPUSH
114517: CALL_OW 72
114521: AND
114522: IFFALSE 114860
// begin tmp := FilterByTag ( defenders , 19 ) ;
114524: LD_ADDR_VAR 0 11
114528: PUSH
114529: LD_VAR 0 2
114533: PPUSH
114534: LD_INT 19
114536: PPUSH
114537: CALL 50353 0 2
114541: ST_TO_ADDR
// if tmp then
114542: LD_VAR 0 11
114546: IFFALSE 114616
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
114548: LD_ADDR_VAR 0 11
114552: PUSH
114553: LD_VAR 0 11
114557: PPUSH
114558: LD_INT 25
114560: PUSH
114561: LD_INT 3
114563: PUSH
114564: EMPTY
114565: LIST
114566: LIST
114567: PPUSH
114568: CALL_OW 72
114572: ST_TO_ADDR
// if tmp then
114573: LD_VAR 0 11
114577: IFFALSE 114616
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
114579: LD_ADDR_EXP 73
114583: PUSH
114584: LD_EXP 73
114588: PPUSH
114589: LD_VAR 0 1
114593: PPUSH
114594: LD_EXP 73
114598: PUSH
114599: LD_VAR 0 1
114603: ARRAY
114604: PUSH
114605: LD_VAR 0 11
114609: UNION
114610: PPUSH
114611: CALL_OW 1
114615: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
114616: LD_VAR 0 1
114620: PPUSH
114621: LD_INT 19
114623: PPUSH
114624: CALL 61012 0 2
// repeat wait ( 0 0$1 ) ;
114628: LD_INT 35
114630: PPUSH
114631: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114635: LD_EXP 61
114639: PUSH
114640: LD_VAR 0 1
114644: ARRAY
114645: NOT
114646: PUSH
114647: LD_EXP 61
114651: PUSH
114652: LD_VAR 0 1
114656: ARRAY
114657: PUSH
114658: EMPTY
114659: EQUAL
114660: OR
114661: IFFALSE 114698
// begin for i in defenders do
114663: LD_ADDR_VAR 0 4
114667: PUSH
114668: LD_VAR 0 2
114672: PUSH
114673: FOR_IN
114674: IFFALSE 114687
// ComStop ( i ) ;
114676: LD_VAR 0 4
114680: PPUSH
114681: CALL_OW 141
114685: GO 114673
114687: POP
114688: POP
// defenders := [ ] ;
114689: LD_ADDR_VAR 0 2
114693: PUSH
114694: EMPTY
114695: ST_TO_ADDR
// exit ;
114696: GO 114924
// end ; for i in defenders do
114698: LD_ADDR_VAR 0 4
114702: PUSH
114703: LD_VAR 0 2
114707: PUSH
114708: FOR_IN
114709: IFFALSE 114798
// begin if not IsInArea ( i , mc_parking [ base ] ) then
114711: LD_VAR 0 4
114715: PPUSH
114716: LD_EXP 85
114720: PUSH
114721: LD_VAR 0 1
114725: ARRAY
114726: PPUSH
114727: CALL_OW 308
114731: NOT
114732: IFFALSE 114756
// ComMoveToArea ( i , mc_parking [ base ] ) else
114734: LD_VAR 0 4
114738: PPUSH
114739: LD_EXP 85
114743: PUSH
114744: LD_VAR 0 1
114748: ARRAY
114749: PPUSH
114750: CALL_OW 113
114754: GO 114796
// if GetControl ( i ) = control_manual then
114756: LD_VAR 0 4
114760: PPUSH
114761: CALL_OW 263
114765: PUSH
114766: LD_INT 1
114768: EQUAL
114769: IFFALSE 114796
// if IsDrivenBy ( i ) then
114771: LD_VAR 0 4
114775: PPUSH
114776: CALL_OW 311
114780: IFFALSE 114796
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
114782: LD_VAR 0 4
114786: PPUSH
114787: CALL_OW 311
114791: PPUSH
114792: CALL_OW 121
// end ;
114796: GO 114708
114798: POP
114799: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
114800: LD_VAR 0 2
114804: PPUSH
114805: LD_INT 95
114807: PUSH
114808: LD_EXP 85
114812: PUSH
114813: LD_VAR 0 1
114817: ARRAY
114818: PUSH
114819: EMPTY
114820: LIST
114821: LIST
114822: PPUSH
114823: CALL_OW 72
114827: PUSH
114828: LD_VAR 0 2
114832: EQUAL
114833: PUSH
114834: LD_EXP 84
114838: PUSH
114839: LD_VAR 0 1
114843: ARRAY
114844: OR
114845: PUSH
114846: LD_EXP 61
114850: PUSH
114851: LD_VAR 0 1
114855: ARRAY
114856: NOT
114857: OR
114858: IFFALSE 114628
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
114860: LD_ADDR_EXP 83
114864: PUSH
114865: LD_EXP 83
114869: PPUSH
114870: LD_VAR 0 1
114874: PPUSH
114875: LD_VAR 0 2
114879: PPUSH
114880: LD_INT 21
114882: PUSH
114883: LD_INT 2
114885: PUSH
114886: EMPTY
114887: LIST
114888: LIST
114889: PPUSH
114890: CALL_OW 72
114894: PPUSH
114895: CALL_OW 1
114899: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
114900: LD_VAR 0 1
114904: PPUSH
114905: LD_INT 19
114907: PPUSH
114908: CALL 61012 0 2
// MC_Reset ( base , 20 ) ;
114912: LD_VAR 0 1
114916: PPUSH
114917: LD_INT 20
114919: PPUSH
114920: CALL 61012 0 2
// end ; end_of_file
114924: LD_VAR 0 3
114928: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
114929: LD_VAR 0 1
114933: PUSH
114934: LD_INT 200
114936: DOUBLE
114937: GREATEREQUAL
114938: IFFALSE 114946
114940: LD_INT 299
114942: DOUBLE
114943: LESSEQUAL
114944: IFTRUE 114948
114946: GO 114980
114948: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
114949: LD_VAR 0 1
114953: PPUSH
114954: LD_VAR 0 2
114958: PPUSH
114959: LD_VAR 0 3
114963: PPUSH
114964: LD_VAR 0 4
114968: PPUSH
114969: LD_VAR 0 5
114973: PPUSH
114974: CALL 103715 0 5
114978: GO 115057
114980: LD_INT 300
114982: DOUBLE
114983: GREATEREQUAL
114984: IFFALSE 114992
114986: LD_INT 399
114988: DOUBLE
114989: LESSEQUAL
114990: IFTRUE 114994
114992: GO 115056
114994: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
114995: LD_VAR 0 1
114999: PPUSH
115000: LD_VAR 0 2
115004: PPUSH
115005: LD_VAR 0 3
115009: PPUSH
115010: LD_VAR 0 4
115014: PPUSH
115015: LD_VAR 0 5
115019: PPUSH
115020: LD_VAR 0 6
115024: PPUSH
115025: LD_VAR 0 7
115029: PPUSH
115030: LD_VAR 0 8
115034: PPUSH
115035: LD_VAR 0 9
115039: PPUSH
115040: LD_VAR 0 10
115044: PPUSH
115045: LD_VAR 0 11
115049: PPUSH
115050: CALL 100040 0 11
115054: GO 115057
115056: POP
// end ;
115057: PPOPN 11
115059: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
115060: LD_VAR 0 1
115064: PPUSH
115065: LD_VAR 0 2
115069: PPUSH
115070: LD_VAR 0 3
115074: PPUSH
115075: LD_VAR 0 4
115079: PPUSH
115080: LD_VAR 0 5
115084: PPUSH
115085: CALL 103451 0 5
// end ; end_of_file
115089: PPOPN 5
115091: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
115092: LD_VAR 0 1
115096: PPUSH
115097: LD_VAR 0 2
115101: PPUSH
115102: LD_VAR 0 3
115106: PPUSH
115107: LD_VAR 0 4
115111: PPUSH
115112: LD_VAR 0 5
115116: PPUSH
115117: LD_VAR 0 6
115121: PPUSH
115122: CALL 87692 0 6
// end ;
115126: PPOPN 6
115128: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
115129: LD_INT 0
115131: PPUSH
// begin if not units then
115132: LD_VAR 0 1
115136: NOT
115137: IFFALSE 115141
// exit ;
115139: GO 115141
// end ;
115141: PPOPN 7
115143: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
115144: CALL 87596 0 0
// end ;
115148: PPOPN 1
115150: END
