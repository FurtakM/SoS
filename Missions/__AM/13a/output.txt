// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 701 0 0
// InitMacro ;
  19: CALL 56371 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 49107 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 49107 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 49107 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 49107 0 9
// if Difficulty < 4 then
 168: LD_OWVAR 67
 172: PUSH
 173: LD_INT 4
 175: LESS
 176: IFFALSE 185
// RemoveEnvironmentArea ( oilBlockArea ) ;
 178: LD_INT 24
 180: PPUSH
 181: CALL_OW 355
// PrepareArabian ;
 185: CALL 4018 0 0
// PrepareRussian ;
 189: CALL 2989 0 0
// PrepareAlliance ;
 193: CALL 911 0 0
// MC_Start ( ) ;
 197: CALL 58551 0 0
// if debug then
 201: LD_EXP 1
 205: IFFALSE 214
// FogOff ( 1 ) ;
 207: LD_INT 1
 209: PPUSH
 210: CALL_OW 344
// Action ;
 214: CALL 7376 0 0
// end ;
 218: END
// export function CustomInitMacro ; var i ; begin
 219: LD_INT 0
 221: PPUSH
 222: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 223: LD_ADDR_EXP 85
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 2
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 238: LD_ADDR_EXP 86
 242: PUSH
 243: LD_INT 3
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 12
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 18
 264: PUSH
 265: LD_INT 20
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: PUSH
 274: LD_OWVAR 67
 278: ARRAY
 279: PPUSH
 280: LD_INT 7
 282: PPUSH
 283: CALL 80289 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 287: LD_INT 1
 289: PPUSH
 290: LD_EXP 56
 294: PPUSH
 295: CALL 80715 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 6
 304: PPUSH
 305: CALL 81173 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 9
 314: PUSH
 315: EMPTY
 316: LIST
 317: PPUSH
 318: CALL 81442 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 322: LD_INT 1
 324: PPUSH
 325: LD_INT 13
 327: PUSH
 328: LD_INT 1
 330: PUSH
 331: LD_INT 2
 333: PUSH
 334: LD_INT 32
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: PUSH
 343: LD_INT 13
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 2
 351: PUSH
 352: LD_INT 88
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: PPUSH
 365: CALL 80655 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 369: LD_INT 2
 371: PPUSH
 372: LD_INT 12
 374: PUSH
 375: LD_INT 14
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL 81349 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 394: LD_INT 2
 396: PPUSH
 397: LD_EXP 53
 401: PPUSH
 402: CALL 80715 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 406: LD_INT 2
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: CALL 81173 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 416: LD_INT 2
 418: PPUSH
 419: LD_INT 10
 421: PUSH
 422: EMPTY
 423: LIST
 424: PPUSH
 425: CALL 81442 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 429: LD_INT 2
 431: PPUSH
 432: LD_INT 6
 434: PUSH
 435: LD_INT 71
 437: PUSH
 438: LD_INT 116
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: LD_INT 85
 455: PUSH
 456: LD_INT 116
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 32
 470: PUSH
 471: LD_INT 83
 473: PUSH
 474: LD_INT 111
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 87
 491: PUSH
 492: LD_INT 121
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 88
 509: PUSH
 510: LD_INT 128
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 32
 524: PUSH
 525: LD_INT 59
 527: PUSH
 528: LD_INT 89
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 69
 545: PUSH
 546: LD_INT 98
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 77
 563: PUSH
 564: LD_INT 103
 566: PUSH
 567: LD_INT 3
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 33
 578: PUSH
 579: LD_INT 83
 581: PUSH
 582: LD_INT 105
 584: PUSH
 585: LD_INT 3
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 33
 596: PUSH
 597: LD_INT 71
 599: PUSH
 600: LD_INT 125
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 80499 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 628: LD_INT 2
 630: PPUSH
 631: LD_INT 43
 633: PUSH
 634: LD_INT 47
 636: PUSH
 637: LD_INT 46
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL 81760 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 649: LD_INT 2
 651: PPUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 51
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 22
 672: PUSH
 673: LD_INT 1
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 52
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL 80655 0 2
// end ;
 696: LD_VAR 0 1
 700: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 701: LD_INT 0
 703: PPUSH
// debug := false ;
 704: LD_ADDR_EXP 1
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// game := true ;
 712: LD_ADDR_EXP 2
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// gossudarov_arrive := false ;
 720: LD_ADDR_EXP 4
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// ru_lab_builded := false ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_INT 0
 735: ST_TO_ADDR
// player_spotted := false ;
 736: LD_ADDR_EXP 6
 740: PUSH
 741: LD_INT 0
 743: ST_TO_ADDR
// first_attack := false ;
 744: LD_ADDR_EXP 7
 748: PUSH
 749: LD_INT 0
 751: ST_TO_ADDR
// ru_attackers := [ ] ;
 752: LD_ADDR_EXP 54
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// ar_base_spotted := false ;
 759: LD_ADDR_EXP 8
 763: PUSH
 764: LD_INT 0
 766: ST_TO_ADDR
// ar_active_attack := false ;
 767: LD_ADDR_EXP 9
 771: PUSH
 772: LD_INT 0
 774: ST_TO_ADDR
// ar_attackers := [ ] ;
 775: LD_ADDR_EXP 11
 779: PUSH
 780: EMPTY
 781: ST_TO_ADDR
// first_powell_attack := false ;
 782: LD_ADDR_EXP 12
 786: PUSH
 787: LD_INT 0
 789: ST_TO_ADDR
// masha_killed := false ;
 790: LD_ADDR_EXP 10
 794: PUSH
 795: LD_INT 0
 797: ST_TO_ADDR
// abdul_escaped := true ;
 798: LD_ADDR_EXP 13
 802: PUSH
 803: LD_INT 1
 805: ST_TO_ADDR
// loss_counter := 0 ;
 806: LD_ADDR_EXP 14
 810: PUSH
 811: LD_INT 0
 813: ST_TO_ADDR
// hack_counter := 0 ;
 814: LD_ADDR_EXP 15
 818: PUSH
 819: LD_INT 0
 821: ST_TO_ADDR
// end ;
 822: LD_VAR 0 1
 826: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 827: LD_EXP 50
 831: PPUSH
 832: CALL_OW 255
 836: PUSH
 837: LD_INT 7
 839: EQUAL
 840: PUSH
 841: LD_EXP 49
 845: PPUSH
 846: CALL_OW 255
 850: PUSH
 851: LD_INT 7
 853: EQUAL
 854: AND
 855: PUSH
 856: LD_EXP 50
 860: PPUSH
 861: CALL_OW 302
 865: AND
 866: PUSH
 867: LD_EXP 49
 871: PPUSH
 872: CALL_OW 302
 876: AND
 877: IFFALSE 889
 879: GO 881
 881: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 882: LD_STRING ACH_COMRADE
 884: PPUSH
 885: CALL_OW 543
 889: END
// every 0 0$1 trigger hack_counter >= 10 do
 890: LD_EXP 15
 894: PUSH
 895: LD_INT 10
 897: GREATEREQUAL
 898: IFFALSE 910
 900: GO 902
 902: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 903: LD_STRING ACH_HACK
 905: PPUSH
 906: CALL_OW 543
 910: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 911: LD_INT 0
 913: PPUSH
 914: PPUSH
 915: PPUSH
 916: PPUSH
// uc_side := 7 ;
 917: LD_ADDR_OWVAR 20
 921: PUSH
 922: LD_INT 7
 924: ST_TO_ADDR
// uc_nation := 1 ;
 925: LD_ADDR_OWVAR 21
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 933: LD_ADDR_EXP 16
 937: PUSH
 938: LD_STRING JMM
 940: PPUSH
 941: LD_EXP 1
 945: NOT
 946: PPUSH
 947: LD_STRING 12a_
 949: PPUSH
 950: CALL 14950 0 3
 954: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 955: LD_EXP 16
 959: PPUSH
 960: LD_INT 71
 962: PPUSH
 963: LD_INT 23
 965: PPUSH
 966: LD_INT 0
 968: PPUSH
 969: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 973: LD_EXP 16
 977: PPUSH
 978: LD_INT 2
 980: PPUSH
 981: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 985: LD_ADDR_EXP 17
 989: PUSH
 990: LD_STRING Roth
 992: PPUSH
 993: LD_EXP 1
 997: NOT
 998: PPUSH
 999: LD_STRING 12a_
1001: PPUSH
1002: CALL 14950 0 3
1006: ST_TO_ADDR
// if Roth then
1007: LD_EXP 17
1011: IFFALSE 1031
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1013: LD_EXP 17
1017: PPUSH
1018: LD_INT 71
1020: PPUSH
1021: LD_INT 21
1023: PPUSH
1024: LD_INT 0
1026: PPUSH
1027: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1031: LD_ADDR_EXP 33
1035: PUSH
1036: LD_STRING Mike
1038: PPUSH
1039: LD_EXP 1
1043: NOT
1044: PPUSH
1045: LD_STRING 12a_
1047: PPUSH
1048: CALL 14950 0 3
1052: ST_TO_ADDR
// if Mike then
1053: LD_EXP 33
1057: IFFALSE 1074
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1059: LD_EXP 33
1063: PPUSH
1064: LD_INT 13
1066: PPUSH
1067: LD_INT 0
1069: PPUSH
1070: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1074: LD_ADDR_EXP 18
1078: PUSH
1079: LD_STRING Lisa
1081: PPUSH
1082: LD_EXP 1
1086: NOT
1087: PPUSH
1088: LD_STRING 12a_
1090: PPUSH
1091: CALL 14950 0 3
1095: ST_TO_ADDR
// if Lisa then
1096: LD_EXP 18
1100: IFFALSE 1117
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1102: LD_EXP 18
1106: PPUSH
1107: LD_INT 13
1109: PPUSH
1110: LD_INT 0
1112: PPUSH
1113: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1117: LD_ADDR_EXP 19
1121: PUSH
1122: LD_STRING Donaldson
1124: PPUSH
1125: LD_EXP 1
1129: NOT
1130: PPUSH
1131: LD_STRING 12a_
1133: PPUSH
1134: CALL 14950 0 3
1138: ST_TO_ADDR
// if Donaldson then
1139: LD_EXP 19
1143: IFFALSE 1160
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1145: LD_EXP 19
1149: PPUSH
1150: LD_INT 13
1152: PPUSH
1153: LD_INT 0
1155: PPUSH
1156: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1160: LD_ADDR_EXP 20
1164: PUSH
1165: LD_STRING Bobby
1167: PPUSH
1168: LD_EXP 1
1172: NOT
1173: PPUSH
1174: LD_STRING 12a_
1176: PPUSH
1177: CALL 14950 0 3
1181: ST_TO_ADDR
// if Bobby then
1182: LD_EXP 20
1186: IFFALSE 1203
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1188: LD_EXP 20
1192: PPUSH
1193: LD_INT 13
1195: PPUSH
1196: LD_INT 0
1198: PPUSH
1199: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1203: LD_ADDR_EXP 21
1207: PUSH
1208: LD_STRING Cyrus
1210: PPUSH
1211: LD_EXP 1
1215: NOT
1216: PPUSH
1217: LD_STRING 12a_
1219: PPUSH
1220: CALL 14950 0 3
1224: ST_TO_ADDR
// if Cyrus then
1225: LD_EXP 21
1229: IFFALSE 1246
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1231: LD_EXP 21
1235: PPUSH
1236: LD_INT 13
1238: PPUSH
1239: LD_INT 0
1241: PPUSH
1242: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1246: LD_ADDR_EXP 22
1250: PUSH
1251: LD_STRING Denis
1253: PPUSH
1254: LD_EXP 1
1258: NOT
1259: PPUSH
1260: LD_STRING 12a_
1262: PPUSH
1263: CALL 14950 0 3
1267: ST_TO_ADDR
// if Denis then
1268: LD_EXP 22
1272: IFFALSE 1289
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1274: LD_EXP 22
1278: PPUSH
1279: LD_INT 13
1281: PPUSH
1282: LD_INT 0
1284: PPUSH
1285: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1289: LD_ADDR_EXP 23
1293: PUSH
1294: LD_STRING Brown
1296: PPUSH
1297: LD_EXP 1
1301: NOT
1302: PPUSH
1303: LD_STRING 12a_
1305: PPUSH
1306: CALL 14950 0 3
1310: ST_TO_ADDR
// if Brown then
1311: LD_EXP 23
1315: IFFALSE 1332
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1317: LD_EXP 23
1321: PPUSH
1322: LD_INT 13
1324: PPUSH
1325: LD_INT 0
1327: PPUSH
1328: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1332: LD_ADDR_EXP 24
1336: PUSH
1337: LD_STRING Gladstone
1339: PPUSH
1340: LD_EXP 1
1344: NOT
1345: PPUSH
1346: LD_STRING 12a_
1348: PPUSH
1349: CALL 14950 0 3
1353: ST_TO_ADDR
// if Gladstone then
1354: LD_EXP 24
1358: IFFALSE 1375
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1360: LD_EXP 24
1364: PPUSH
1365: LD_INT 13
1367: PPUSH
1368: LD_INT 0
1370: PPUSH
1371: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1375: LD_ADDR_EXP 25
1379: PUSH
1380: LD_STRING Houten
1382: PPUSH
1383: LD_EXP 1
1387: NOT
1388: PPUSH
1389: LD_STRING 12a_
1391: PPUSH
1392: CALL 14950 0 3
1396: ST_TO_ADDR
// if Houten then
1397: LD_EXP 25
1401: IFFALSE 1418
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1403: LD_EXP 25
1407: PPUSH
1408: LD_INT 13
1410: PPUSH
1411: LD_INT 0
1413: PPUSH
1414: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1418: LD_ADDR_EXP 26
1422: PUSH
1423: LD_STRING Cornell
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: LD_STRING 12a_
1434: PPUSH
1435: CALL 14950 0 3
1439: ST_TO_ADDR
// if Cornel then
1440: LD_EXP 26
1444: IFFALSE 1461
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1446: LD_EXP 26
1450: PPUSH
1451: LD_INT 13
1453: PPUSH
1454: LD_INT 0
1456: PPUSH
1457: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1461: LD_ADDR_EXP 27
1465: PUSH
1466: LD_STRING Gary
1468: PPUSH
1469: LD_EXP 1
1473: NOT
1474: PPUSH
1475: LD_STRING 12a_
1477: PPUSH
1478: CALL 14950 0 3
1482: ST_TO_ADDR
// if Gary then
1483: LD_EXP 27
1487: IFFALSE 1504
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1489: LD_EXP 27
1493: PPUSH
1494: LD_INT 13
1496: PPUSH
1497: LD_INT 0
1499: PPUSH
1500: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1504: LD_ADDR_EXP 28
1508: PUSH
1509: LD_STRING Frank
1511: PPUSH
1512: LD_EXP 1
1516: NOT
1517: PPUSH
1518: LD_STRING 12a_
1520: PPUSH
1521: CALL 14950 0 3
1525: ST_TO_ADDR
// if Frank then
1526: LD_EXP 28
1530: IFFALSE 1547
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1532: LD_EXP 28
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: LD_INT 0
1542: PPUSH
1543: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1547: LD_ADDR_EXP 29
1551: PUSH
1552: LD_STRING Kikuchi
1554: PPUSH
1555: LD_EXP 1
1559: NOT
1560: PPUSH
1561: LD_STRING 12a_
1563: PPUSH
1564: CALL 14950 0 3
1568: ST_TO_ADDR
// if Kikuchi then
1569: LD_EXP 29
1573: IFFALSE 1590
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1575: LD_EXP 29
1579: PPUSH
1580: LD_INT 13
1582: PPUSH
1583: LD_INT 0
1585: PPUSH
1586: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1590: LD_ADDR_EXP 30
1594: PUSH
1595: LD_STRING Simms
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 12a_
1606: PPUSH
1607: CALL 14950 0 3
1611: ST_TO_ADDR
// if Simms then
1612: LD_EXP 30
1616: IFFALSE 1633
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1618: LD_EXP 30
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1633: LD_ADDR_EXP 31
1637: PUSH
1638: LD_STRING Joan
1640: PPUSH
1641: LD_EXP 1
1645: NOT
1646: PPUSH
1647: LD_STRING 12a_
1649: PPUSH
1650: CALL 14950 0 3
1654: ST_TO_ADDR
// if Joan then
1655: LD_EXP 31
1659: IFFALSE 1676
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1661: LD_EXP 31
1665: PPUSH
1666: LD_INT 13
1668: PPUSH
1669: LD_INT 0
1671: PPUSH
1672: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1676: LD_ADDR_EXP 32
1680: PUSH
1681: LD_STRING DeltaDoctor
1683: PPUSH
1684: LD_EXP 1
1688: NOT
1689: PPUSH
1690: LD_STRING 12a_
1692: PPUSH
1693: CALL 14950 0 3
1697: ST_TO_ADDR
// if DeltaDoctor then
1698: LD_EXP 32
1702: IFFALSE 1719
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1704: LD_EXP 32
1708: PPUSH
1709: LD_INT 13
1711: PPUSH
1712: LD_INT 0
1714: PPUSH
1715: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1719: LD_ADDR_VAR 0 4
1723: PUSH
1724: LD_STRING 12a_others
1726: PPUSH
1727: CALL_OW 31
1731: ST_TO_ADDR
// if tmp then
1732: LD_VAR 0 4
1736: IFFALSE 1770
// for i in tmp do
1738: LD_ADDR_VAR 0 3
1742: PUSH
1743: LD_VAR 0 4
1747: PUSH
1748: FOR_IN
1749: IFFALSE 1768
// PlaceUnitArea ( i , alliance_start , false ) ;
1751: LD_VAR 0 3
1755: PPUSH
1756: LD_INT 13
1758: PPUSH
1759: LD_INT 0
1761: PPUSH
1762: CALL_OW 49
1766: GO 1748
1768: POP
1769: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1770: LD_INT 3
1772: PPUSH
1773: LD_INT 3
1775: PPUSH
1776: LD_INT 3
1778: PPUSH
1779: LD_INT 12
1781: PPUSH
1782: LD_INT 100
1784: PPUSH
1785: CALL 19965 0 5
// veh := CreateVehicle ;
1789: LD_ADDR_VAR 0 2
1793: PUSH
1794: CALL_OW 45
1798: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1799: LD_VAR 0 2
1803: PPUSH
1804: LD_INT 2
1806: PPUSH
1807: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1811: LD_VAR 0 2
1815: PPUSH
1816: LD_INT 60
1818: PPUSH
1819: LD_INT 6
1821: PPUSH
1822: LD_INT 0
1824: PPUSH
1825: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1829: LD_VAR 0 2
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: LD_INT 30
1839: PPUSH
1840: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1844: LD_STRING 11_artifact_captured
1846: PPUSH
1847: LD_INT 0
1849: PPUSH
1850: CALL_OW 30
1854: IFFALSE 1930
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1856: LD_INT 3
1858: PPUSH
1859: LD_INT 3
1861: PPUSH
1862: LD_INT 3
1864: PPUSH
1865: LD_INT 12
1867: PPUSH
1868: LD_INT 100
1870: PPUSH
1871: CALL 19965 0 5
// veh := CreateVehicle ;
1875: LD_ADDR_VAR 0 2
1879: PUSH
1880: CALL_OW 45
1884: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1885: LD_VAR 0 2
1889: PPUSH
1890: LD_INT 3
1892: PPUSH
1893: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1897: LD_VAR 0 2
1901: PPUSH
1902: LD_INT 75
1904: PPUSH
1905: LD_INT 6
1907: PPUSH
1908: LD_INT 0
1910: PPUSH
1911: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1915: LD_VAR 0 2
1919: PPUSH
1920: LD_INT 4
1922: PPUSH
1923: LD_INT 50
1925: PPUSH
1926: CALL_OW 290
// end ; end ;
1930: LD_VAR 0 1
1934: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1935: LD_INT 0
1937: PPUSH
1938: PPUSH
1939: PPUSH
1940: PPUSH
// uc_side := 6 ;
1941: LD_ADDR_OWVAR 20
1945: PUSH
1946: LD_INT 6
1948: ST_TO_ADDR
// uc_nation := 3 ;
1949: LD_ADDR_OWVAR 21
1953: PUSH
1954: LD_INT 3
1956: ST_TO_ADDR
// InitHc ;
1957: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1961: LD_ADDR_EXP 34
1965: PUSH
1966: LD_STRING Gossudarov
1968: PPUSH
1969: CALL_OW 25
1973: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1974: LD_ADDR_EXP 35
1978: PUSH
1979: LD_STRING Kirilenkova
1981: PPUSH
1982: CALL_OW 25
1986: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1987: LD_ADDR_EXP 36
1991: PUSH
1992: LD_STRING Titov
1994: PPUSH
1995: CALL_OW 25
1999: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
2000: LD_ADDR_EXP 41
2004: PUSH
2005: LD_STRING Oblukov
2007: PPUSH
2008: CALL_OW 25
2012: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
2013: LD_ADDR_EXP 38
2017: PUSH
2018: LD_STRING Dolgov
2020: PPUSH
2021: CALL_OW 25
2025: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2026: LD_ADDR_EXP 39
2030: PUSH
2031: LD_STRING Petrosyan
2033: PPUSH
2034: CALL_OW 25
2038: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2039: LD_ADDR_EXP 40
2043: PUSH
2044: LD_STRING Scholtze
2046: PPUSH
2047: CALL_OW 25
2051: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2052: LD_ADDR_EXP 42
2056: PUSH
2057: LD_STRING Kapitsova
2059: PPUSH
2060: CALL_OW 25
2064: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2065: LD_ADDR_VAR 0 2
2069: PUSH
2070: LD_EXP 34
2074: PUSH
2075: LD_EXP 35
2079: PUSH
2080: LD_EXP 36
2084: PUSH
2085: LD_EXP 41
2089: PUSH
2090: LD_EXP 38
2094: PUSH
2095: LD_EXP 39
2099: PUSH
2100: LD_EXP 40
2104: PUSH
2105: LD_EXP 42
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: LIST
2116: LIST
2117: LIST
2118: LIST
2119: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2120: LD_INT 1
2122: PPUSH
2123: LD_INT 4
2125: PPUSH
2126: LD_INT 8
2128: PPUSH
2129: CALL_OW 380
// un := CreateHuman ;
2133: LD_ADDR_VAR 0 4
2137: PUSH
2138: CALL_OW 44
2142: ST_TO_ADDR
// tmp := tmp ^ un ;
2143: LD_ADDR_VAR 0 2
2147: PUSH
2148: LD_VAR 0 2
2152: PUSH
2153: LD_VAR 0 4
2157: ADD
2158: ST_TO_ADDR
// for i in tmp do
2159: LD_ADDR_VAR 0 3
2163: PUSH
2164: LD_VAR 0 2
2168: PUSH
2169: FOR_IN
2170: IFFALSE 2189
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2172: LD_VAR 0 3
2176: PPUSH
2177: LD_INT 14
2179: PPUSH
2180: LD_INT 0
2182: PPUSH
2183: CALL_OW 49
2187: GO 2169
2189: POP
2190: POP
// if freedom then
2191: LD_EXP 3
2195: IFFALSE 2228
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2197: LD_VAR 0 2
2201: PPUSH
2202: LD_EXP 3
2206: PPUSH
2207: CALL_OW 250
2211: PPUSH
2212: LD_EXP 3
2216: PPUSH
2217: CALL_OW 251
2221: PPUSH
2222: CALL_OW 111
2226: GO 2243
// ComMoveXY ( tmp , 70 , 48 ) ;
2228: LD_VAR 0 2
2232: PPUSH
2233: LD_INT 70
2235: PPUSH
2236: LD_INT 48
2238: PPUSH
2239: CALL_OW 111
// end ;
2243: LD_VAR 0 1
2247: RET
// export function PrepareBelkov ; begin
2248: LD_INT 0
2250: PPUSH
// uc_side := 4 ;
2251: LD_ADDR_OWVAR 20
2255: PUSH
2256: LD_INT 4
2258: ST_TO_ADDR
// uc_nation := 3 ;
2259: LD_ADDR_OWVAR 21
2263: PUSH
2264: LD_INT 3
2266: ST_TO_ADDR
// InitHc ;
2267: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2271: LD_ADDR_EXP 49
2275: PUSH
2276: LD_STRING Belkov
2278: PPUSH
2279: CALL_OW 25
2283: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2284: LD_EXP 49
2288: PPUSH
2289: LD_INT 14
2291: PPUSH
2292: LD_INT 0
2294: PPUSH
2295: CALL_OW 49
// end ;
2299: LD_VAR 0 1
2303: RET
// export function PrepareGnyevko ; begin
2304: LD_INT 0
2306: PPUSH
// uc_side := 4 ;
2307: LD_ADDR_OWVAR 20
2311: PUSH
2312: LD_INT 4
2314: ST_TO_ADDR
// uc_nation := 3 ;
2315: LD_ADDR_OWVAR 21
2319: PUSH
2320: LD_INT 3
2322: ST_TO_ADDR
// InitHc ;
2323: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2327: LD_ADDR_EXP 50
2331: PUSH
2332: LD_STRING Gnyevko
2334: PPUSH
2335: CALL_OW 25
2339: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2340: LD_EXP 50
2344: PPUSH
2345: LD_INT 14
2347: PPUSH
2348: LD_INT 0
2350: PPUSH
2351: CALL_OW 49
// end ;
2355: LD_VAR 0 1
2359: RET
// export function PrepareBurlak ; var i , tmp ; begin
2360: LD_INT 0
2362: PPUSH
2363: PPUSH
2364: PPUSH
// uc_side := 4 ;
2365: LD_ADDR_OWVAR 20
2369: PUSH
2370: LD_INT 4
2372: ST_TO_ADDR
// uc_nation := 3 ;
2373: LD_ADDR_OWVAR 21
2377: PUSH
2378: LD_INT 3
2380: ST_TO_ADDR
// InitHc ;
2381: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2385: LD_ADDR_EXP 48
2389: PUSH
2390: LD_STRING Burlak
2392: PPUSH
2393: CALL_OW 25
2397: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2398: LD_INT 24
2400: PUSH
2401: LD_INT 23
2403: PUSH
2404: LD_INT 22
2406: PUSH
2407: LD_INT 22
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: LIST
2414: LIST
2415: PUSH
2416: LD_OWVAR 67
2420: ARRAY
2421: PPUSH
2422: LD_INT 1
2424: PPUSH
2425: LD_INT 1
2427: PPUSH
2428: LD_INT 45
2430: PUSH
2431: LD_INT 44
2433: PUSH
2434: LD_INT 43
2436: PUSH
2437: LD_INT 42
2439: PUSH
2440: EMPTY
2441: LIST
2442: LIST
2443: LIST
2444: LIST
2445: PUSH
2446: LD_OWVAR 67
2450: ARRAY
2451: PPUSH
2452: LD_INT 0
2454: PPUSH
2455: CALL 19965 0 5
// Masha := CreateVehicle ;
2459: LD_ADDR_EXP 51
2463: PUSH
2464: CALL_OW 45
2468: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2469: LD_EXP 51
2473: PUSH
2474: LD_EXP 48
2478: PUSH
2479: EMPTY
2480: LIST
2481: LIST
2482: PPUSH
2483: LD_INT 499
2485: PPUSH
2486: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2490: LD_EXP 51
2494: PPUSH
2495: LD_INT 3
2497: PPUSH
2498: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2502: LD_EXP 51
2506: PPUSH
2507: LD_INT 1
2509: PPUSH
2510: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2514: LD_INT 1
2516: PPUSH
2517: LD_INT 18
2519: PPUSH
2520: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2524: LD_INT 35
2526: PPUSH
2527: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2531: LD_ADDR_VAR 0 3
2535: PUSH
2536: LD_INT 18
2538: PPUSH
2539: EMPTY
2540: PPUSH
2541: CALL_OW 70
2545: ST_TO_ADDR
// if tmp then
2546: LD_VAR 0 3
2550: IFFALSE 2584
// for i in tmp do
2552: LD_ADDR_VAR 0 2
2556: PUSH
2557: LD_VAR 0 3
2561: PUSH
2562: FOR_IN
2563: IFFALSE 2582
// ComMoveXY ( i , 114 , 9 ) ;
2565: LD_VAR 0 2
2569: PPUSH
2570: LD_INT 114
2572: PPUSH
2573: LD_INT 9
2575: PPUSH
2576: CALL_OW 111
2580: GO 2562
2582: POP
2583: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2584: LD_INT 18
2586: PPUSH
2587: EMPTY
2588: PPUSH
2589: CALL_OW 70
2593: NOT
2594: PUSH
2595: LD_INT 123
2597: PPUSH
2598: LD_INT 3
2600: PPUSH
2601: CALL_OW 428
2605: PUSH
2606: LD_INT 0
2608: EQUAL
2609: AND
2610: IFFALSE 2524
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2612: LD_EXP 51
2616: PPUSH
2617: LD_INT 123
2619: PPUSH
2620: LD_INT 3
2622: PPUSH
2623: LD_INT 0
2625: PPUSH
2626: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2630: LD_EXP 48
2634: PPUSH
2635: LD_INT 125
2637: PPUSH
2638: LD_INT 1
2640: PPUSH
2641: LD_INT 0
2643: PPUSH
2644: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2648: LD_EXP 48
2652: PPUSH
2653: LD_EXP 51
2657: PPUSH
2658: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2662: LD_INT 10
2664: PPUSH
2665: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2669: LD_EXP 51
2673: PPUSH
2674: LD_INT 110
2676: PPUSH
2677: LD_INT 10
2679: PPUSH
2680: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2684: LD_ADDR_EXP 44
2688: PUSH
2689: LD_STRING Petrovova
2691: PPUSH
2692: CALL_OW 25
2696: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2697: LD_ADDR_EXP 46
2701: PUSH
2702: LD_STRING Kuzmov
2704: PPUSH
2705: CALL_OW 25
2709: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2710: LD_ADDR_EXP 45
2714: PUSH
2715: LD_STRING Kovalyuk
2717: PPUSH
2718: CALL_OW 25
2722: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2723: LD_ADDR_EXP 43
2727: PUSH
2728: LD_STRING Lipshchin
2730: PPUSH
2731: CALL_OW 25
2735: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2736: LD_ADDR_EXP 47
2740: PUSH
2741: LD_STRING Karamazov
2743: PPUSH
2744: CALL_OW 25
2748: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2749: LD_ADDR_VAR 0 3
2753: PUSH
2754: LD_EXP 44
2758: PUSH
2759: LD_EXP 46
2763: PUSH
2764: LD_EXP 45
2768: PUSH
2769: LD_EXP 43
2773: PUSH
2774: LD_EXP 47
2778: PUSH
2779: EMPTY
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: LIST
2785: ST_TO_ADDR
// for i in tmp do
2786: LD_ADDR_VAR 0 2
2790: PUSH
2791: LD_VAR 0 3
2795: PUSH
2796: FOR_IN
2797: IFFALSE 2836
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2799: LD_VAR 0 2
2803: PPUSH
2804: LD_INT 399
2806: PPUSH
2807: LD_INT 799
2809: PPUSH
2810: CALL_OW 12
2814: PPUSH
2815: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2819: LD_VAR 0 2
2823: PPUSH
2824: LD_INT 19
2826: PPUSH
2827: LD_INT 0
2829: PPUSH
2830: CALL_OW 49
// end ;
2834: GO 2796
2836: POP
2837: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2838: LD_VAR 0 3
2842: PPUSH
2843: LD_INT 112
2845: PPUSH
2846: LD_INT 5
2848: PPUSH
2849: CALL_OW 111
// AddComHold ( tmp ) ;
2853: LD_VAR 0 3
2857: PPUSH
2858: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2862: LD_ADDR_VAR 0 2
2866: PUSH
2867: LD_VAR 0 3
2871: PPUSH
2872: LD_INT 25
2874: PUSH
2875: LD_INT 1
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: PPUSH
2882: CALL_OW 72
2886: PUSH
2887: FOR_IN
2888: IFFALSE 2928
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2890: LD_VAR 0 2
2894: PPUSH
2895: LD_INT 20
2897: PPUSH
2898: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2902: LD_VAR 0 2
2906: PPUSH
2907: LD_INT 147
2909: PPUSH
2910: LD_INT 45
2912: PPUSH
2913: CALL_OW 178
// AddComCrawl ( i ) ;
2917: LD_VAR 0 2
2921: PPUSH
2922: CALL_OW 197
// end ;
2926: GO 2887
2928: POP
2929: POP
// repeat wait ( 0 0$1 ) ;
2930: LD_INT 35
2932: PPUSH
2933: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2937: LD_EXP 51
2941: PPUSH
2942: LD_INT 110
2944: PPUSH
2945: LD_INT 10
2947: PPUSH
2948: CALL_OW 307
2952: PUSH
2953: LD_EXP 51
2957: PPUSH
2958: CALL_OW 305
2962: NOT
2963: OR
2964: IFFALSE 2930
// ComStop ( Burlak ) ;
2966: LD_EXP 48
2970: PPUSH
2971: CALL_OW 141
// AddComHold ( Burlak ) ;
2975: LD_EXP 48
2979: PPUSH
2980: CALL_OW 200
// end ; end_of_file
2984: LD_VAR 0 1
2988: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2989: LD_INT 0
2991: PPUSH
2992: PPUSH
2993: PPUSH
2994: PPUSH
2995: PPUSH
// uc_side := 3 ;
2996: LD_ADDR_OWVAR 20
3000: PUSH
3001: LD_INT 3
3003: ST_TO_ADDR
// uc_nation := 3 ;
3004: LD_ADDR_OWVAR 21
3008: PUSH
3009: LD_INT 3
3011: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
3012: LD_ADDR_EXP 52
3016: PUSH
3017: LD_INT 47
3019: PPUSH
3020: LD_INT 4
3022: PPUSH
3023: LD_STRING 
3025: PPUSH
3026: LD_INT 7
3028: PUSH
3029: LD_INT 8
3031: PUSH
3032: LD_INT 9
3034: PUSH
3035: LD_INT 10
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: PUSH
3044: LD_OWVAR 67
3048: ARRAY
3049: PPUSH
3050: LD_INT 10000
3052: PUSH
3053: LD_INT 3000
3055: PUSH
3056: LD_INT 300
3058: PUSH
3059: EMPTY
3060: LIST
3061: LIST
3062: LIST
3063: PPUSH
3064: LD_INT 9
3066: PUSH
3067: LD_INT 5
3069: PUSH
3070: LD_INT 6
3072: PUSH
3073: LD_INT 6
3075: PUSH
3076: EMPTY
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PPUSH
3082: CALL 23409 0 6
3086: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3087: LD_ADDR_EXP 61
3091: PUSH
3092: LD_EXP 61
3096: PPUSH
3097: LD_INT 2
3099: PPUSH
3100: LD_EXP 52
3104: PPUSH
3105: CALL_OW 1
3109: ST_TO_ADDR
// tmp := [ ] ;
3110: LD_ADDR_VAR 0 4
3114: PUSH
3115: EMPTY
3116: ST_TO_ADDR
// for i = 1 to 4 do
3117: LD_ADDR_VAR 0 2
3121: PUSH
3122: DOUBLE
3123: LD_INT 1
3125: DEC
3126: ST_TO_ADDR
3127: LD_INT 4
3129: PUSH
3130: FOR_TO
3131: IFFALSE 3224
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3133: LD_INT 22
3135: PPUSH
3136: LD_INT 3
3138: PPUSH
3139: LD_INT 3
3141: PPUSH
3142: LD_INT 43
3144: PUSH
3145: LD_INT 45
3147: PUSH
3148: LD_INT 45
3150: PUSH
3151: LD_INT 44
3153: PUSH
3154: EMPTY
3155: LIST
3156: LIST
3157: LIST
3158: LIST
3159: PUSH
3160: LD_VAR 0 2
3164: PUSH
3165: LD_INT 4
3167: MOD
3168: PUSH
3169: LD_INT 1
3171: PLUS
3172: ARRAY
3173: PPUSH
3174: LD_INT 100
3176: PPUSH
3177: CALL 19965 0 5
// veh := CreateVehicle ;
3181: LD_ADDR_VAR 0 3
3185: PUSH
3186: CALL_OW 45
3190: ST_TO_ADDR
// tmp := tmp ^ veh ;
3191: LD_ADDR_VAR 0 4
3195: PUSH
3196: LD_VAR 0 4
3200: PUSH
3201: LD_VAR 0 3
3205: ADD
3206: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3207: LD_VAR 0 3
3211: PPUSH
3212: LD_INT 2
3214: PPUSH
3215: LD_INT 0
3217: PPUSH
3218: CALL_OW 49
// end ;
3222: GO 3130
3224: POP
3225: POP
// russian_guard := tmp ;
3226: LD_ADDR_EXP 53
3230: PUSH
3231: LD_VAR 0 4
3235: ST_TO_ADDR
// if Difficulty >= 3 then
3236: LD_OWVAR 67
3240: PUSH
3241: LD_INT 3
3243: GREATEREQUAL
3244: IFFALSE 3308
// begin bc_type := b_breastwork ;
3246: LD_ADDR_OWVAR 42
3250: PUSH
3251: LD_INT 31
3253: ST_TO_ADDR
// bc_level := 10 ;
3254: LD_ADDR_OWVAR 43
3258: PUSH
3259: LD_INT 10
3261: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3262: LD_ADDR_VAR 0 5
3266: PUSH
3267: LD_INT 96
3269: PPUSH
3270: LD_INT 105
3272: PPUSH
3273: LD_INT 3
3275: PPUSH
3276: CALL_OW 47
3280: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3281: LD_INT 0
3283: PPUSH
3284: LD_INT 9
3286: PPUSH
3287: LD_INT 10
3289: PPUSH
3290: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3294: CALL_OW 44
3298: PPUSH
3299: LD_VAR 0 5
3303: PPUSH
3304: CALL_OW 52
// end ; end ;
3308: LD_VAR 0 1
3312: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers , amount ;
3313: LD_INT 47
3315: PPUSH
3316: CALL_OW 302
3320: PUSH
3321: LD_EXP 6
3325: AND
3326: IFFALSE 4015
3328: GO 3330
3330: DISABLE
3331: LD_INT 0
3333: PPUSH
3334: PPUSH
3335: PPUSH
3336: PPUSH
3337: PPUSH
3338: PPUSH
3339: PPUSH
// begin enable ;
3340: ENABLE
// base := 2 ;
3341: LD_ADDR_VAR 0 2
3345: PUSH
3346: LD_INT 2
3348: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3349: LD_ADDR_VAR 0 4
3353: PUSH
3354: LD_INT 0
3356: PUSH
3357: LD_INT 0
3359: PUSH
3360: LD_INT 0
3362: PUSH
3363: LD_INT 0
3365: PUSH
3366: LD_INT 0
3368: PUSH
3369: LD_INT 0
3371: PUSH
3372: LD_INT 0
3374: PUSH
3375: LD_INT 0
3377: PUSH
3378: LD_INT 1
3380: PUSH
3381: LD_INT 0
3383: PUSH
3384: EMPTY
3385: LIST
3386: LIST
3387: LIST
3388: LIST
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: LIST
3394: LIST
3395: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3396: LD_ADDR_VAR 0 3
3400: PUSH
3401: LD_INT 22
3403: PUSH
3404: LD_INT 1
3406: PUSH
3407: LD_INT 3
3409: PUSH
3410: LD_INT 45
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: PUSH
3419: LD_INT 21
3421: PUSH
3422: LD_INT 1
3424: PUSH
3425: LD_INT 3
3427: PUSH
3428: LD_INT 45
3430: PUSH
3431: EMPTY
3432: LIST
3433: LIST
3434: LIST
3435: LIST
3436: PUSH
3437: LD_INT 22
3439: PUSH
3440: LD_INT 1
3442: PUSH
3443: LD_INT 3
3445: PUSH
3446: LD_INT 45
3448: PUSH
3449: EMPTY
3450: LIST
3451: LIST
3452: LIST
3453: LIST
3454: PUSH
3455: LD_INT 23
3457: PUSH
3458: LD_INT 1
3460: PUSH
3461: LD_INT 3
3463: PUSH
3464: LD_INT 46
3466: PUSH
3467: EMPTY
3468: LIST
3469: LIST
3470: LIST
3471: LIST
3472: PUSH
3473: EMPTY
3474: LIST
3475: LIST
3476: LIST
3477: LIST
3478: ST_TO_ADDR
// amount := Difficulty ;
3479: LD_ADDR_VAR 0 7
3483: PUSH
3484: LD_OWVAR 67
3488: ST_TO_ADDR
// if tick > 30 30$00 then
3489: LD_OWVAR 1
3493: PUSH
3494: LD_INT 63000
3496: GREATER
3497: IFFALSE 3534
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3499: LD_ADDR_VAR 0 7
3503: PUSH
3504: LD_VAR 0 7
3508: PUSH
3509: LD_INT 2
3511: PUSH
3512: LD_INT 3
3514: PUSH
3515: LD_INT 4
3517: PUSH
3518: LD_INT 4
3520: PUSH
3521: EMPTY
3522: LIST
3523: LIST
3524: LIST
3525: LIST
3526: PUSH
3527: LD_OWVAR 67
3531: ARRAY
3532: PLUS
3533: ST_TO_ADDR
// for i = 1 to amount do
3534: LD_ADDR_VAR 0 1
3538: PUSH
3539: DOUBLE
3540: LD_INT 1
3542: DEC
3543: ST_TO_ADDR
3544: LD_VAR 0 7
3548: PUSH
3549: FOR_TO
3550: IFFALSE 3638
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3552: LD_ADDR_VAR 0 3
3556: PUSH
3557: LD_VAR 0 3
3561: PPUSH
3562: LD_VAR 0 3
3566: PUSH
3567: LD_INT 1
3569: PLUS
3570: PPUSH
3571: LD_INT 23
3573: PUSH
3574: LD_INT 24
3576: PUSH
3577: EMPTY
3578: LIST
3579: LIST
3580: PUSH
3581: LD_INT 1
3583: PPUSH
3584: LD_INT 2
3586: PPUSH
3587: CALL_OW 12
3591: ARRAY
3592: PUSH
3593: LD_INT 1
3595: PUSH
3596: LD_INT 3
3598: PUSH
3599: LD_INT 46
3601: PUSH
3602: LD_INT 47
3604: PUSH
3605: LD_INT 45
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: LIST
3612: PUSH
3613: LD_INT 1
3615: PPUSH
3616: LD_INT 3
3618: PPUSH
3619: CALL_OW 12
3623: ARRAY
3624: PUSH
3625: EMPTY
3626: LIST
3627: LIST
3628: LIST
3629: LIST
3630: PPUSH
3631: CALL_OW 2
3635: ST_TO_ADDR
3636: GO 3549
3638: POP
3639: POP
// MC_InsertProduceList ( base , tmp ) ;
3640: LD_VAR 0 2
3644: PPUSH
3645: LD_VAR 0 3
3649: PPUSH
3650: CALL 80655 0 2
// repeat wait ( 0 0$1 ) ;
3654: LD_INT 35
3656: PPUSH
3657: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
3661: LD_VAR 0 2
3665: PPUSH
3666: LD_INT 1
3668: PPUSH
3669: CALL 82073 0 2
3673: PUSH
3674: LD_VAR 0 7
3678: GREATEREQUAL
3679: IFFALSE 3654
// wait ( 0 0$30 ) ;
3681: LD_INT 1050
3683: PPUSH
3684: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3688: LD_ADDR_VAR 0 5
3692: PUSH
3693: LD_INT 71
3695: PUSH
3696: LD_INT 19
3698: PUSH
3699: EMPTY
3700: LIST
3701: LIST
3702: PUSH
3703: LD_INT 91
3705: PUSH
3706: LD_INT 67
3708: PUSH
3709: EMPTY
3710: LIST
3711: LIST
3712: PUSH
3713: LD_INT 52
3715: PUSH
3716: LD_INT 44
3718: PUSH
3719: EMPTY
3720: LIST
3721: LIST
3722: PUSH
3723: LD_INT 68
3725: PUSH
3726: LD_INT 48
3728: PUSH
3729: EMPTY
3730: LIST
3731: LIST
3732: PUSH
3733: EMPTY
3734: LIST
3735: LIST
3736: LIST
3737: LIST
3738: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3739: LD_ADDR_VAR 0 6
3743: PUSH
3744: LD_EXP 80
3748: PUSH
3749: LD_VAR 0 2
3753: ARRAY
3754: PUSH
3755: LD_EXP 80
3759: PUSH
3760: LD_VAR 0 2
3764: ARRAY
3765: PPUSH
3766: LD_INT 2
3768: PUSH
3769: LD_INT 34
3771: PUSH
3772: LD_INT 51
3774: PUSH
3775: EMPTY
3776: LIST
3777: LIST
3778: PUSH
3779: LD_INT 34
3781: PUSH
3782: LD_INT 52
3784: PUSH
3785: EMPTY
3786: LIST
3787: LIST
3788: PUSH
3789: EMPTY
3790: LIST
3791: LIST
3792: LIST
3793: PPUSH
3794: CALL_OW 72
3798: DIFF
3799: ST_TO_ADDR
// if not attackers then
3800: LD_VAR 0 6
3804: NOT
3805: IFFALSE 3809
// exit ;
3807: GO 4015
// ru_attackers := attackers ;
3809: LD_ADDR_EXP 54
3813: PUSH
3814: LD_VAR 0 6
3818: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3819: LD_ADDR_EXP 80
3823: PUSH
3824: LD_EXP 80
3828: PPUSH
3829: LD_VAR 0 2
3833: PPUSH
3834: LD_EXP 80
3838: PUSH
3839: LD_VAR 0 2
3843: ARRAY
3844: PUSH
3845: LD_VAR 0 6
3849: DIFF
3850: PPUSH
3851: CALL_OW 1
3855: ST_TO_ADDR
// for i = 1 to attackers do
3856: LD_ADDR_VAR 0 1
3860: PUSH
3861: DOUBLE
3862: LD_INT 1
3864: DEC
3865: ST_TO_ADDR
3866: LD_VAR 0 6
3870: PUSH
3871: FOR_TO
3872: IFFALSE 3949
// begin case i mod 3 of 0 :
3874: LD_VAR 0 1
3878: PUSH
3879: LD_INT 3
3881: MOD
3882: PUSH
3883: LD_INT 0
3885: DOUBLE
3886: EQUAL
3887: IFTRUE 3891
3889: GO 3894
3891: POP
// ; 1 :
3892: GO 3947
3894: LD_INT 1
3896: DOUBLE
3897: EQUAL
3898: IFTRUE 3902
3900: GO 3920
3902: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3903: LD_VAR 0 1
3907: PPUSH
3908: LD_INT 32
3910: PPUSH
3911: LD_INT 49
3913: PPUSH
3914: CALL_OW 114
3918: GO 3947
3920: LD_INT 2
3922: DOUBLE
3923: EQUAL
3924: IFTRUE 3928
3926: GO 3946
3928: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3929: LD_VAR 0 1
3933: PPUSH
3934: LD_INT 117
3936: PPUSH
3937: LD_INT 107
3939: PPUSH
3940: CALL_OW 114
3944: GO 3947
3946: POP
// end ;
3947: GO 3871
3949: POP
3950: POP
// repeat wait ( 0 0$1 ) ;
3951: LD_INT 35
3953: PPUSH
3954: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3958: LD_VAR 0 6
3962: PPUSH
3963: LD_INT 60
3965: PUSH
3966: EMPTY
3967: LIST
3968: PPUSH
3969: CALL_OW 72
3973: NOT
3974: IFFALSE 3951
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3976: LD_VAR 0 2
3980: PPUSH
3981: LD_VAR 0 6
3985: PPUSH
3986: LD_VAR 0 5
3990: PPUSH
3991: LD_VAR 0 4
3995: PPUSH
3996: CALL 80840 0 4
// if not first_attack then
4000: LD_EXP 7
4004: NOT
4005: IFFALSE 4015
// first_attack := true ;
4007: LD_ADDR_EXP 7
4011: PUSH
4012: LD_INT 1
4014: ST_TO_ADDR
// end ; end_of_file
4015: PPOPN 7
4017: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
4018: LD_INT 0
4020: PPUSH
4021: PPUSH
4022: PPUSH
4023: PPUSH
4024: PPUSH
4025: PPUSH
4026: PPUSH
// uc_side := 2 ;
4027: LD_ADDR_OWVAR 20
4031: PUSH
4032: LD_INT 2
4034: ST_TO_ADDR
// uc_nation := 2 ;
4035: LD_ADDR_OWVAR 21
4039: PUSH
4040: LD_INT 2
4042: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
4043: LD_ADDR_EXP 57
4047: PUSH
4048: LD_STRING Abdul
4050: PPUSH
4051: CALL_OW 25
4055: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4056: LD_EXP 57
4060: PPUSH
4061: LD_INT 11
4063: PPUSH
4064: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4068: LD_EXP 57
4072: PPUSH
4073: LD_INT 1
4075: PPUSH
4076: CALL_OW 52
// vc_chassis := 31 ;
4080: LD_ADDR_OWVAR 37
4084: PUSH
4085: LD_INT 31
4087: ST_TO_ADDR
// vc_control := control_rider ;
4088: LD_ADDR_OWVAR 38
4092: PUSH
4093: LD_INT 4
4095: ST_TO_ADDR
// mastodont := CreateVehicle ;
4096: LD_ADDR_EXP 58
4100: PUSH
4101: CALL_OW 45
4105: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4106: LD_EXP 58
4110: PPUSH
4111: LD_INT 153
4113: PPUSH
4114: LD_INT 71
4116: PPUSH
4117: LD_INT 0
4119: PPUSH
4120: CALL_OW 48
// InitVc ;
4124: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
4128: LD_ADDR_EXP 55
4132: PUSH
4133: LD_INT 1
4135: PPUSH
4136: LD_INT 3
4138: PPUSH
4139: LD_STRING 
4141: PPUSH
4142: LD_INT 7
4144: PUSH
4145: LD_INT 8
4147: PUSH
4148: LD_INT 9
4150: PUSH
4151: LD_INT 10
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: LIST
4158: LIST
4159: PUSH
4160: LD_OWVAR 67
4164: ARRAY
4165: PPUSH
4166: LD_INT 5000
4168: PUSH
4169: LD_INT 1000
4171: PUSH
4172: LD_INT 300
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: LIST
4179: PPUSH
4180: LD_INT 18
4182: PUSH
4183: LD_INT 5
4185: PUSH
4186: LD_INT 6
4188: PUSH
4189: LD_INT 9
4191: PUSH
4192: EMPTY
4193: LIST
4194: LIST
4195: LIST
4196: LIST
4197: PPUSH
4198: CALL 23409 0 6
4202: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4203: LD_ADDR_EXP 61
4207: PUSH
4208: LD_EXP 61
4212: PPUSH
4213: LD_INT 1
4215: PPUSH
4216: LD_EXP 55
4220: PPUSH
4221: CALL_OW 1
4225: ST_TO_ADDR
// tmp := [ ] ;
4226: LD_ADDR_VAR 0 4
4230: PUSH
4231: EMPTY
4232: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
4233: LD_ADDR_OWVAR 37
4237: PUSH
4238: LD_INT 14
4240: ST_TO_ADDR
// vc_engine := engine_siberite ;
4241: LD_ADDR_OWVAR 39
4245: PUSH
4246: LD_INT 3
4248: ST_TO_ADDR
// vc_control := control_manual ;
4249: LD_ADDR_OWVAR 38
4253: PUSH
4254: LD_INT 1
4256: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4257: LD_ADDR_OWVAR 40
4261: PUSH
4262: LD_INT 31
4264: ST_TO_ADDR
// for i = 1 to 3 do
4265: LD_ADDR_VAR 0 2
4269: PUSH
4270: DOUBLE
4271: LD_INT 1
4273: DEC
4274: ST_TO_ADDR
4275: LD_INT 3
4277: PUSH
4278: FOR_TO
4279: IFFALSE 4527
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4281: LD_ADDR_VAR 0 5
4285: PUSH
4286: LD_INT 153
4288: PUSH
4289: LD_INT 71
4291: PUSH
4292: EMPTY
4293: LIST
4294: LIST
4295: PUSH
4296: LD_INT 155
4298: PUSH
4299: LD_INT 81
4301: PUSH
4302: EMPTY
4303: LIST
4304: LIST
4305: PUSH
4306: EMPTY
4307: LIST
4308: LIST
4309: PUSH
4310: LD_VAR 0 2
4314: PUSH
4315: LD_INT 2
4317: MOD
4318: PUSH
4319: LD_INT 1
4321: PLUS
4322: ARRAY
4323: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4324: LD_INT 0
4326: PPUSH
4327: LD_INT 3
4329: PPUSH
4330: LD_INT 7
4332: PUSH
4333: LD_INT 8
4335: PUSH
4336: LD_INT 10
4338: PUSH
4339: LD_INT 10
4341: PUSH
4342: EMPTY
4343: LIST
4344: LIST
4345: LIST
4346: LIST
4347: PUSH
4348: LD_OWVAR 67
4352: ARRAY
4353: PPUSH
4354: CALL_OW 380
// un := CreateVehicle ;
4358: LD_ADDR_VAR 0 6
4362: PUSH
4363: CALL_OW 45
4367: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4368: LD_VAR 0 6
4372: PPUSH
4373: LD_INT 0
4375: PPUSH
4376: LD_INT 5
4378: PPUSH
4379: CALL_OW 12
4383: PPUSH
4384: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4388: LD_VAR 0 6
4392: PPUSH
4393: LD_VAR 0 5
4397: PUSH
4398: LD_INT 1
4400: ARRAY
4401: PPUSH
4402: LD_VAR 0 5
4406: PUSH
4407: LD_INT 2
4409: ARRAY
4410: PPUSH
4411: LD_INT 6
4413: PPUSH
4414: LD_INT 0
4416: PPUSH
4417: CALL_OW 50
// un2 := CreateHuman ;
4421: LD_ADDR_VAR 0 7
4425: PUSH
4426: CALL_OW 44
4430: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4431: LD_VAR 0 7
4435: PPUSH
4436: LD_VAR 0 6
4440: PPUSH
4441: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4445: LD_ADDR_EXP 61
4449: PUSH
4450: LD_EXP 61
4454: PPUSH
4455: LD_INT 1
4457: PUSH
4458: LD_EXP 61
4462: PUSH
4463: LD_INT 1
4465: ARRAY
4466: PUSH
4467: LD_INT 1
4469: PLUS
4470: PUSH
4471: EMPTY
4472: LIST
4473: LIST
4474: PPUSH
4475: LD_VAR 0 6
4479: PPUSH
4480: CALL 20087 0 3
4484: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4485: LD_ADDR_EXP 61
4489: PUSH
4490: LD_EXP 61
4494: PPUSH
4495: LD_INT 1
4497: PUSH
4498: LD_EXP 61
4502: PUSH
4503: LD_INT 1
4505: ARRAY
4506: PUSH
4507: LD_INT 1
4509: PLUS
4510: PUSH
4511: EMPTY
4512: LIST
4513: LIST
4514: PPUSH
4515: LD_VAR 0 7
4519: PPUSH
4520: CALL 20087 0 3
4524: ST_TO_ADDR
// end ;
4525: GO 4278
4527: POP
4528: POP
// for i = 1 to 5 do
4529: LD_ADDR_VAR 0 2
4533: PUSH
4534: DOUBLE
4535: LD_INT 1
4537: DEC
4538: ST_TO_ADDR
4539: LD_INT 5
4541: PUSH
4542: FOR_TO
4543: IFFALSE 4636
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4545: LD_INT 14
4547: PPUSH
4548: LD_INT 3
4550: PPUSH
4551: LD_INT 1
4553: PPUSH
4554: LD_INT 25
4556: PUSH
4557: LD_INT 28
4559: PUSH
4560: LD_INT 28
4562: PUSH
4563: LD_INT 26
4565: PUSH
4566: EMPTY
4567: LIST
4568: LIST
4569: LIST
4570: LIST
4571: PUSH
4572: LD_VAR 0 2
4576: PUSH
4577: LD_INT 4
4579: MOD
4580: PUSH
4581: LD_INT 1
4583: PLUS
4584: ARRAY
4585: PPUSH
4586: LD_INT 100
4588: PPUSH
4589: CALL 19965 0 5
// veh := CreateVehicle ;
4593: LD_ADDR_VAR 0 3
4597: PUSH
4598: CALL_OW 45
4602: ST_TO_ADDR
// tmp := tmp ^ veh ;
4603: LD_ADDR_VAR 0 4
4607: PUSH
4608: LD_VAR 0 4
4612: PUSH
4613: LD_VAR 0 3
4617: ADD
4618: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4619: LD_VAR 0 3
4623: PPUSH
4624: LD_INT 1
4626: PPUSH
4627: LD_INT 0
4629: PPUSH
4630: CALL_OW 49
// end ;
4634: GO 4542
4636: POP
4637: POP
// arabian_guard := tmp ;
4638: LD_ADDR_EXP 56
4642: PUSH
4643: LD_VAR 0 4
4647: ST_TO_ADDR
// end ;
4648: LD_VAR 0 1
4652: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4653: LD_INT 22
4655: PUSH
4656: LD_INT 7
4658: PUSH
4659: EMPTY
4660: LIST
4661: LIST
4662: PUSH
4663: LD_INT 91
4665: PUSH
4666: LD_INT 1
4668: PUSH
4669: LD_INT 12
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: LIST
4676: PUSH
4677: EMPTY
4678: LIST
4679: LIST
4680: PPUSH
4681: CALL_OW 69
4685: PUSH
4686: LD_EXP 58
4690: PPUSH
4691: CALL_OW 256
4695: PUSH
4696: LD_INT 990
4698: LESS
4699: OR
4700: PUSH
4701: LD_EXP 57
4705: PPUSH
4706: CALL_OW 256
4710: PUSH
4711: LD_INT 990
4713: LESS
4714: OR
4715: IFFALSE 4858
4717: GO 4719
4719: DISABLE
// begin if IsInUnit ( Abdul ) then
4720: LD_EXP 57
4724: PPUSH
4725: CALL_OW 310
4729: IFFALSE 4740
// ComExitBuilding ( Abdul ) ;
4731: LD_EXP 57
4735: PPUSH
4736: CALL_OW 122
// if Mastodont then
4740: LD_EXP 58
4744: IFFALSE 4761
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4746: LD_EXP 58
4750: PPUSH
4751: LD_INT 205
4753: PPUSH
4754: LD_INT 132
4756: PPUSH
4757: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4761: LD_EXP 57
4765: PPUSH
4766: LD_INT 205
4768: PPUSH
4769: LD_INT 132
4771: PPUSH
4772: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4776: LD_INT 35
4778: PPUSH
4779: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4783: LD_EXP 57
4787: PPUSH
4788: LD_INT 21
4790: PPUSH
4791: CALL_OW 308
4795: IFFALSE 4776
// RemoveUnit ( Abdul ) ;
4797: LD_EXP 57
4801: PPUSH
4802: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4806: LD_INT 35
4808: PPUSH
4809: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4813: LD_EXP 58
4817: PPUSH
4818: LD_INT 21
4820: PPUSH
4821: CALL_OW 308
4825: PUSH
4826: LD_EXP 58
4830: PPUSH
4831: CALL_OW 301
4835: OR
4836: IFFALSE 4806
// if IsOk ( Mastodont ) then
4838: LD_EXP 58
4842: PPUSH
4843: CALL_OW 302
4847: IFFALSE 4858
// RemoveUnit ( Mastodont ) ;
4849: LD_EXP 58
4853: PPUSH
4854: CALL_OW 64
// end ;
4858: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4859: LD_EXP 57
4863: PPUSH
4864: CALL_OW 301
4868: PUSH
4869: LD_INT 22
4871: PUSH
4872: LD_INT 2
4874: PUSH
4875: EMPTY
4876: LIST
4877: LIST
4878: PUSH
4879: LD_INT 2
4881: PUSH
4882: LD_INT 25
4884: PUSH
4885: LD_INT 1
4887: PUSH
4888: EMPTY
4889: LIST
4890: LIST
4891: PUSH
4892: LD_INT 25
4894: PUSH
4895: LD_INT 2
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: PUSH
4902: LD_INT 25
4904: PUSH
4905: LD_INT 3
4907: PUSH
4908: EMPTY
4909: LIST
4910: LIST
4911: PUSH
4912: LD_INT 25
4914: PUSH
4915: LD_INT 4
4917: PUSH
4918: EMPTY
4919: LIST
4920: LIST
4921: PUSH
4922: LD_INT 25
4924: PUSH
4925: LD_INT 8
4927: PUSH
4928: EMPTY
4929: LIST
4930: LIST
4931: PUSH
4932: EMPTY
4933: LIST
4934: LIST
4935: LIST
4936: LIST
4937: LIST
4938: LIST
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: PPUSH
4944: CALL_OW 69
4948: PUSH
4949: LD_INT 16
4951: PUSH
4952: LD_INT 19
4954: PUSH
4955: LD_INT 22
4957: PUSH
4958: LD_INT 22
4960: PUSH
4961: EMPTY
4962: LIST
4963: LIST
4964: LIST
4965: LIST
4966: PUSH
4967: LD_OWVAR 67
4971: ARRAY
4972: LESS
4973: OR
4974: IFFALSE 5647
4976: GO 4978
4978: DISABLE
4979: LD_INT 0
4981: PPUSH
4982: PPUSH
4983: PPUSH
4984: PPUSH
4985: PPUSH
4986: PPUSH
// begin MC_Kill ( 1 ) ;
4987: LD_INT 1
4989: PPUSH
4990: CALL 56628 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4994: LD_ADDR_VAR 0 2
4998: PUSH
4999: LD_INT 22
5001: PUSH
5002: LD_INT 2
5004: PUSH
5005: EMPTY
5006: LIST
5007: LIST
5008: PUSH
5009: LD_INT 2
5011: PUSH
5012: LD_INT 25
5014: PUSH
5015: LD_INT 1
5017: PUSH
5018: EMPTY
5019: LIST
5020: LIST
5021: PUSH
5022: LD_INT 25
5024: PUSH
5025: LD_INT 2
5027: PUSH
5028: EMPTY
5029: LIST
5030: LIST
5031: PUSH
5032: LD_INT 25
5034: PUSH
5035: LD_INT 3
5037: PUSH
5038: EMPTY
5039: LIST
5040: LIST
5041: PUSH
5042: LD_INT 25
5044: PUSH
5045: LD_INT 4
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PUSH
5052: LD_INT 25
5054: PUSH
5055: LD_INT 8
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: PUSH
5062: EMPTY
5063: LIST
5064: LIST
5065: LIST
5066: LIST
5067: LIST
5068: LIST
5069: PUSH
5070: EMPTY
5071: LIST
5072: LIST
5073: PPUSH
5074: CALL_OW 69
5078: ST_TO_ADDR
// for i in tmp do
5079: LD_ADDR_VAR 0 5
5083: PUSH
5084: LD_VAR 0 2
5088: PUSH
5089: FOR_IN
5090: IFFALSE 5106
// SetTag ( i , 10 ) ;
5092: LD_VAR 0 5
5096: PPUSH
5097: LD_INT 10
5099: PPUSH
5100: CALL_OW 109
5104: GO 5089
5106: POP
5107: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5108: LD_ADDR_VAR 0 3
5112: PUSH
5113: LD_INT 22
5115: PUSH
5116: LD_INT 2
5118: PUSH
5119: EMPTY
5120: LIST
5121: LIST
5122: PUSH
5123: LD_INT 21
5125: PUSH
5126: LD_INT 1
5128: PUSH
5129: EMPTY
5130: LIST
5131: LIST
5132: PUSH
5133: EMPTY
5134: LIST
5135: LIST
5136: PPUSH
5137: CALL_OW 69
5141: PUSH
5142: LD_VAR 0 2
5146: DIFF
5147: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5148: LD_ADDR_VAR 0 1
5152: PUSH
5153: LD_INT 22
5155: PUSH
5156: LD_INT 2
5158: PUSH
5159: EMPTY
5160: LIST
5161: LIST
5162: PUSH
5163: LD_INT 21
5165: PUSH
5166: LD_INT 2
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: PUSH
5173: LD_INT 24
5175: PUSH
5176: LD_INT 300
5178: PUSH
5179: EMPTY
5180: LIST
5181: LIST
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: LIST
5187: PPUSH
5188: CALL_OW 69
5192: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5193: LD_ADDR_VAR 0 4
5197: PUSH
5198: LD_VAR 0 1
5202: PPUSH
5203: LD_INT 33
5205: PUSH
5206: LD_INT 1
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PUSH
5213: LD_INT 58
5215: PUSH
5216: EMPTY
5217: LIST
5218: PUSH
5219: EMPTY
5220: LIST
5221: LIST
5222: PPUSH
5223: CALL_OW 72
5227: ST_TO_ADDR
// for i in tmp do
5228: LD_ADDR_VAR 0 5
5232: PUSH
5233: LD_VAR 0 2
5237: PUSH
5238: FOR_IN
5239: IFFALSE 5423
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5241: LD_VAR 0 5
5245: PUSH
5246: LD_INT 55
5248: PUSH
5249: EMPTY
5250: LIST
5251: PPUSH
5252: CALL_OW 69
5256: IN
5257: IFFALSE 5276
// begin AddComMoveXY ( i , 209 , 132 ) ;
5259: LD_VAR 0 5
5263: PPUSH
5264: LD_INT 209
5266: PPUSH
5267: LD_INT 132
5269: PPUSH
5270: CALL_OW 171
// continue ;
5274: GO 5238
// end ; if IsInUnit ( i ) then
5276: LD_VAR 0 5
5280: PPUSH
5281: CALL_OW 310
5285: IFFALSE 5303
// begin ComExitBuilding ( i ) ;
5287: LD_VAR 0 5
5291: PPUSH
5292: CALL_OW 122
// wait ( 3 ) ;
5296: LD_INT 3
5298: PPUSH
5299: CALL_OW 67
// end ; if tmp_empty then
5303: LD_VAR 0 4
5307: IFFALSE 5406
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5309: LD_VAR 0 5
5313: PPUSH
5314: LD_VAR 0 4
5318: PPUSH
5319: LD_VAR 0 5
5323: PPUSH
5324: CALL_OW 74
5328: PPUSH
5329: CALL_OW 296
5333: PUSH
5334: LD_INT 25
5336: LESS
5337: IFFALSE 5406
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5339: LD_ADDR_VAR 0 6
5343: PUSH
5344: LD_VAR 0 4
5348: PPUSH
5349: LD_VAR 0 5
5353: PPUSH
5354: CALL_OW 74
5358: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5359: LD_VAR 0 5
5363: PPUSH
5364: LD_VAR 0 6
5368: PPUSH
5369: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5373: LD_VAR 0 5
5377: PPUSH
5378: LD_INT 209
5380: PPUSH
5381: LD_INT 132
5383: PPUSH
5384: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5388: LD_ADDR_VAR 0 4
5392: PUSH
5393: LD_VAR 0 4
5397: PUSH
5398: LD_VAR 0 6
5402: DIFF
5403: ST_TO_ADDR
// continue ;
5404: GO 5238
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5406: LD_VAR 0 5
5410: PPUSH
5411: LD_INT 201
5413: PPUSH
5414: LD_INT 132
5416: PPUSH
5417: CALL_OW 171
// end ;
5421: GO 5238
5423: POP
5424: POP
// for i in tmp_ape do
5425: LD_ADDR_VAR 0 5
5429: PUSH
5430: LD_VAR 0 3
5434: PUSH
5435: FOR_IN
5436: IFFALSE 5475
// begin if IsInUnit ( i ) then
5438: LD_VAR 0 5
5442: PPUSH
5443: CALL_OW 310
5447: IFFALSE 5458
// ComExitBuilding ( i ) ;
5449: LD_VAR 0 5
5453: PPUSH
5454: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5458: LD_VAR 0 5
5462: PPUSH
5463: LD_INT 201
5465: PPUSH
5466: LD_INT 132
5468: PPUSH
5469: CALL_OW 171
// end ;
5473: GO 5435
5475: POP
5476: POP
// repeat wait ( 0 0$1 ) ;
5477: LD_INT 35
5479: PPUSH
5480: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5484: LD_ADDR_VAR 0 5
5488: PUSH
5489: LD_VAR 0 2
5493: PUSH
5494: LD_VAR 0 3
5498: UNION
5499: PUSH
5500: LD_VAR 0 1
5504: UNION
5505: PUSH
5506: FOR_IN
5507: IFFALSE 5538
// if not HasTask ( i ) then
5509: LD_VAR 0 5
5513: PPUSH
5514: CALL_OW 314
5518: NOT
5519: IFFALSE 5536
// ComMoveXY ( i , 201 , 132 ) ;
5521: LD_VAR 0 5
5525: PPUSH
5526: LD_INT 201
5528: PPUSH
5529: LD_INT 132
5531: PPUSH
5532: CALL_OW 111
5536: GO 5506
5538: POP
5539: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5540: LD_INT 21
5542: PPUSH
5543: LD_INT 22
5545: PUSH
5546: LD_INT 2
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: PPUSH
5553: CALL_OW 70
5557: IFFALSE 5598
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5559: LD_ADDR_VAR 0 5
5563: PUSH
5564: LD_INT 21
5566: PPUSH
5567: LD_INT 22
5569: PUSH
5570: LD_INT 2
5572: PUSH
5573: EMPTY
5574: LIST
5575: LIST
5576: PPUSH
5577: CALL_OW 70
5581: PUSH
5582: FOR_IN
5583: IFFALSE 5596
// RemoveUnit ( i ) ;
5585: LD_VAR 0 5
5589: PPUSH
5590: CALL_OW 64
5594: GO 5582
5596: POP
5597: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5598: LD_INT 22
5600: PUSH
5601: LD_INT 2
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: PUSH
5608: LD_INT 2
5610: PUSH
5611: LD_INT 21
5613: PUSH
5614: LD_INT 1
5616: PUSH
5617: EMPTY
5618: LIST
5619: LIST
5620: PUSH
5621: LD_INT 21
5623: PUSH
5624: LD_INT 2
5626: PUSH
5627: EMPTY
5628: LIST
5629: LIST
5630: PUSH
5631: EMPTY
5632: LIST
5633: LIST
5634: LIST
5635: PUSH
5636: EMPTY
5637: LIST
5638: LIST
5639: PPUSH
5640: CALL_OW 69
5644: NOT
5645: IFFALSE 5477
// end ;
5647: PPOPN 6
5649: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5650: LD_EXP 9
5654: PUSH
5655: LD_INT 92
5657: PPUSH
5658: LD_INT 40
5660: PPUSH
5661: CALL_OW 428
5665: PPUSH
5666: CALL_OW 266
5670: PUSH
5671: LD_INT 30
5673: EQUAL
5674: AND
5675: IFFALSE 5871
5677: GO 5679
5679: DISABLE
5680: LD_INT 0
5682: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5683: LD_ADDR_VAR 0 1
5687: PUSH
5688: LD_EXP 61
5692: PUSH
5693: LD_INT 1
5695: ARRAY
5696: PPUSH
5697: LD_INT 25
5699: PUSH
5700: LD_INT 4
5702: PUSH
5703: EMPTY
5704: LIST
5705: LIST
5706: PPUSH
5707: CALL_OW 72
5711: ST_TO_ADDR
// if not sci then
5712: LD_VAR 0 1
5716: NOT
5717: IFFALSE 5721
// exit ;
5719: GO 5871
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5721: LD_ADDR_EXP 61
5725: PUSH
5726: LD_EXP 61
5730: PPUSH
5731: LD_INT 1
5733: PPUSH
5734: LD_EXP 61
5738: PUSH
5739: LD_INT 1
5741: ARRAY
5742: PUSH
5743: LD_VAR 0 1
5747: PUSH
5748: LD_INT 1
5750: ARRAY
5751: DIFF
5752: PPUSH
5753: CALL_OW 1
5757: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5758: LD_VAR 0 1
5762: PUSH
5763: LD_INT 1
5765: ARRAY
5766: PPUSH
5767: CALL_OW 310
5771: IFFALSE 5786
// ComExitBuilding ( sci [ 1 ] ) ;
5773: LD_VAR 0 1
5777: PUSH
5778: LD_INT 1
5780: ARRAY
5781: PPUSH
5782: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5786: LD_INT 2
5788: PPUSH
5789: LD_INT 105
5791: PPUSH
5792: LD_INT 14
5794: PPUSH
5795: LD_INT 20
5797: PPUSH
5798: CALL 20983 0 4
5802: PUSH
5803: LD_INT 4
5805: ARRAY
5806: PUSH
5807: LD_INT 10
5809: LESS
5810: IFFALSE 5833
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5812: LD_VAR 0 1
5816: PUSH
5817: LD_INT 1
5819: ARRAY
5820: PPUSH
5821: LD_INT 105
5823: PPUSH
5824: LD_INT 14
5826: PPUSH
5827: CALL_OW 171
5831: GO 5852
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5833: LD_VAR 0 1
5837: PUSH
5838: LD_INT 1
5840: ARRAY
5841: PPUSH
5842: LD_INT 118
5844: PPUSH
5845: LD_INT 77
5847: PPUSH
5848: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5852: LD_VAR 0 1
5856: PUSH
5857: LD_INT 1
5859: ARRAY
5860: PPUSH
5861: LD_INT 92
5863: PPUSH
5864: LD_INT 40
5866: PPUSH
5867: CALL_OW 218
// end ;
5871: PPOPN 1
5873: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5874: LD_INT 1
5876: PPUSH
5877: CALL_OW 302
5881: PUSH
5882: LD_EXP 9
5886: AND
5887: IFFALSE 6364
5889: GO 5891
5891: DISABLE
5892: LD_INT 0
5894: PPUSH
5895: PPUSH
5896: PPUSH
5897: PPUSH
5898: PPUSH
5899: PPUSH
// begin enable ;
5900: ENABLE
// base := 1 ;
5901: LD_ADDR_VAR 0 2
5905: PUSH
5906: LD_INT 1
5908: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5909: LD_ADDR_VAR 0 4
5913: PUSH
5914: LD_INT 0
5916: PUSH
5917: LD_INT 0
5919: PUSH
5920: LD_INT 0
5922: PUSH
5923: LD_INT 0
5925: PUSH
5926: LD_INT 0
5928: PUSH
5929: LD_INT 0
5931: PUSH
5932: LD_INT 0
5934: PUSH
5935: LD_INT 0
5937: PUSH
5938: LD_INT 1
5940: PUSH
5941: LD_INT 0
5943: PUSH
5944: EMPTY
5945: LIST
5946: LIST
5947: LIST
5948: LIST
5949: LIST
5950: LIST
5951: LIST
5952: LIST
5953: LIST
5954: LIST
5955: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5956: LD_ADDR_VAR 0 3
5960: PUSH
5961: LD_INT 14
5963: PUSH
5964: LD_INT 1
5966: PUSH
5967: LD_INT 2
5969: PUSH
5970: LD_INT 26
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: LIST
5977: LIST
5978: PUSH
5979: LD_INT 14
5981: PUSH
5982: LD_INT 1
5984: PUSH
5985: LD_INT 2
5987: PUSH
5988: LD_INT 28
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: LIST
5995: LIST
5996: PUSH
5997: LD_INT 13
5999: PUSH
6000: LD_INT 1
6002: PUSH
6003: LD_INT 2
6005: PUSH
6006: LD_INT 29
6008: PUSH
6009: EMPTY
6010: LIST
6011: LIST
6012: LIST
6013: LIST
6014: PUSH
6015: EMPTY
6016: LIST
6017: LIST
6018: LIST
6019: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6020: LD_ADDR_VAR 0 1
6024: PUSH
6025: DOUBLE
6026: LD_INT 1
6028: DEC
6029: ST_TO_ADDR
6030: LD_OWVAR 67
6034: PUSH
6035: LD_OWVAR 1
6039: PUSH
6040: LD_INT 21000
6042: DIV
6043: PLUS
6044: PUSH
6045: FOR_TO
6046: IFFALSE 6138
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6048: LD_ADDR_VAR 0 3
6052: PUSH
6053: LD_VAR 0 3
6057: PPUSH
6058: LD_VAR 0 3
6062: PUSH
6063: LD_INT 1
6065: PLUS
6066: PPUSH
6067: LD_INT 13
6069: PUSH
6070: LD_INT 14
6072: PUSH
6073: EMPTY
6074: LIST
6075: LIST
6076: PUSH
6077: LD_INT 1
6079: PPUSH
6080: LD_INT 2
6082: PPUSH
6083: CALL_OW 12
6087: ARRAY
6088: PUSH
6089: LD_INT 1
6091: PUSH
6092: LD_INT 2
6094: PUSH
6095: LD_INT 28
6097: PUSH
6098: LD_INT 29
6100: PUSH
6101: LD_INT 25
6103: PUSH
6104: LD_INT 26
6106: PUSH
6107: EMPTY
6108: LIST
6109: LIST
6110: LIST
6111: LIST
6112: PUSH
6113: LD_INT 1
6115: PPUSH
6116: LD_INT 4
6118: PPUSH
6119: CALL_OW 12
6123: ARRAY
6124: PUSH
6125: EMPTY
6126: LIST
6127: LIST
6128: LIST
6129: LIST
6130: PPUSH
6131: CALL_OW 2
6135: ST_TO_ADDR
6136: GO 6045
6138: POP
6139: POP
// MC_InsertProduceList ( base , tmp ) ;
6140: LD_VAR 0 2
6144: PPUSH
6145: LD_VAR 0 3
6149: PPUSH
6150: CALL 80655 0 2
// repeat wait ( 0 0$1 ) ;
6154: LD_INT 35
6156: PPUSH
6157: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
6161: LD_EXP 80
6165: PUSH
6166: LD_VAR 0 2
6170: ARRAY
6171: PUSH
6172: LD_INT 6
6174: GREATER
6175: IFFALSE 6154
// wait ( 0 0$20 ) ;
6177: LD_INT 700
6179: PPUSH
6180: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6184: LD_ADDR_VAR 0 5
6188: PUSH
6189: LD_INT 124
6191: PUSH
6192: LD_INT 85
6194: PUSH
6195: EMPTY
6196: LIST
6197: LIST
6198: PUSH
6199: LD_INT 90
6201: PUSH
6202: LD_INT 61
6204: PUSH
6205: EMPTY
6206: LIST
6207: LIST
6208: PUSH
6209: LD_INT 69
6211: PUSH
6212: LD_INT 48
6214: PUSH
6215: EMPTY
6216: LIST
6217: LIST
6218: PUSH
6219: LD_INT 68
6221: PUSH
6222: LD_INT 48
6224: PUSH
6225: EMPTY
6226: LIST
6227: LIST
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: LIST
6233: LIST
6234: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6235: LD_ADDR_VAR 0 6
6239: PUSH
6240: LD_EXP 80
6244: PUSH
6245: LD_VAR 0 2
6249: ARRAY
6250: PUSH
6251: LD_EXP 80
6255: PUSH
6256: LD_VAR 0 2
6260: ARRAY
6261: PPUSH
6262: LD_INT 2
6264: PUSH
6265: LD_INT 34
6267: PUSH
6268: LD_INT 32
6270: PUSH
6271: EMPTY
6272: LIST
6273: LIST
6274: PUSH
6275: LD_INT 34
6277: PUSH
6278: LD_INT 88
6280: PUSH
6281: EMPTY
6282: LIST
6283: LIST
6284: PUSH
6285: EMPTY
6286: LIST
6287: LIST
6288: LIST
6289: PPUSH
6290: CALL_OW 72
6294: DIFF
6295: ST_TO_ADDR
// if not attackers then
6296: LD_VAR 0 6
6300: NOT
6301: IFFALSE 6305
// exit ;
6303: GO 6364
// ar_attackers := attackers ;
6305: LD_ADDR_EXP 11
6309: PUSH
6310: LD_VAR 0 6
6314: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6315: LD_INT 35
6317: PPUSH
6318: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6322: LD_VAR 0 6
6326: PPUSH
6327: LD_INT 60
6329: PUSH
6330: EMPTY
6331: LIST
6332: PPUSH
6333: CALL_OW 72
6337: NOT
6338: IFFALSE 6315
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6340: LD_VAR 0 2
6344: PPUSH
6345: LD_VAR 0 6
6349: PPUSH
6350: LD_VAR 0 5
6354: PPUSH
6355: LD_VAR 0 4
6359: PPUSH
6360: CALL 80840 0 4
// end ;
6364: PPOPN 6
6366: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6367: LD_INT 1
6369: PPUSH
6370: CALL_OW 302
6374: PUSH
6375: LD_EXP 9
6379: AND
6380: PUSH
6381: LD_EXP 51
6385: PPUSH
6386: LD_INT 22
6388: PPUSH
6389: CALL_OW 308
6393: AND
6394: PUSH
6395: LD_INT 1
6397: PPUSH
6398: CALL 81003 0 1
6402: PUSH
6403: LD_INT 0
6405: EQUAL
6406: AND
6407: PUSH
6408: LD_EXP 11
6412: NOT
6413: AND
6414: IFFALSE 6900
6416: GO 6418
6418: DISABLE
6419: LD_INT 0
6421: PPUSH
6422: PPUSH
6423: PPUSH
6424: PPUSH
6425: PPUSH
6426: PPUSH
6427: PPUSH
// begin base := 1 ;
6428: LD_ADDR_VAR 0 2
6432: PUSH
6433: LD_INT 1
6435: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6436: LD_ADDR_VAR 0 4
6440: PUSH
6441: LD_INT 0
6443: PUSH
6444: LD_INT 0
6446: PUSH
6447: LD_INT 0
6449: PUSH
6450: LD_INT 0
6452: PUSH
6453: LD_INT 0
6455: PUSH
6456: LD_INT 0
6458: PUSH
6459: LD_INT 0
6461: PUSH
6462: LD_INT 0
6464: PUSH
6465: LD_INT 1
6467: PUSH
6468: LD_INT 0
6470: PUSH
6471: EMPTY
6472: LIST
6473: LIST
6474: LIST
6475: LIST
6476: LIST
6477: LIST
6478: LIST
6479: LIST
6480: LIST
6481: LIST
6482: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6483: LD_ADDR_VAR 0 3
6487: PUSH
6488: LD_INT 13
6490: PUSH
6491: LD_INT 1
6493: PUSH
6494: LD_INT 2
6496: PUSH
6497: LD_INT 28
6499: PUSH
6500: EMPTY
6501: LIST
6502: LIST
6503: LIST
6504: LIST
6505: PUSH
6506: LD_INT 13
6508: PUSH
6509: LD_INT 1
6511: PUSH
6512: LD_INT 2
6514: PUSH
6515: LD_INT 27
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: LIST
6522: LIST
6523: PUSH
6524: LD_INT 13
6526: PUSH
6527: LD_INT 1
6529: PUSH
6530: LD_INT 2
6532: PUSH
6533: LD_INT 25
6535: PUSH
6536: EMPTY
6537: LIST
6538: LIST
6539: LIST
6540: LIST
6541: PUSH
6542: LD_INT 11
6544: PUSH
6545: LD_INT 2
6547: PUSH
6548: LD_INT 2
6550: PUSH
6551: LD_INT 24
6553: PUSH
6554: EMPTY
6555: LIST
6556: LIST
6557: LIST
6558: LIST
6559: PUSH
6560: LD_INT 11
6562: PUSH
6563: LD_INT 2
6565: PUSH
6566: LD_INT 2
6568: PUSH
6569: LD_INT 24
6571: PUSH
6572: EMPTY
6573: LIST
6574: LIST
6575: LIST
6576: LIST
6577: PUSH
6578: EMPTY
6579: LIST
6580: LIST
6581: LIST
6582: LIST
6583: LIST
6584: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6585: LD_VAR 0 2
6589: PPUSH
6590: LD_VAR 0 3
6594: PPUSH
6595: CALL 80655 0 2
// repeat wait ( 0 0$1 ) ;
6599: LD_INT 35
6601: PPUSH
6602: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6606: LD_EXP 80
6610: PUSH
6611: LD_VAR 0 2
6615: ARRAY
6616: PUSH
6617: LD_INT 6
6619: GREATEREQUAL
6620: IFFALSE 6599
// wait ( 0 0$20 ) ;
6622: LD_INT 700
6624: PPUSH
6625: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6629: LD_ADDR_VAR 0 5
6633: PUSH
6634: LD_INT 119
6636: PUSH
6637: LD_INT 9
6639: PUSH
6640: EMPTY
6641: LIST
6642: LIST
6643: PUSH
6644: EMPTY
6645: LIST
6646: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6647: LD_ADDR_VAR 0 6
6651: PUSH
6652: LD_EXP 80
6656: PUSH
6657: LD_VAR 0 2
6661: ARRAY
6662: PUSH
6663: LD_EXP 80
6667: PUSH
6668: LD_VAR 0 2
6672: ARRAY
6673: PPUSH
6674: LD_INT 2
6676: PUSH
6677: LD_INT 34
6679: PUSH
6680: LD_INT 32
6682: PUSH
6683: EMPTY
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 34
6689: PUSH
6690: LD_INT 88
6692: PUSH
6693: EMPTY
6694: LIST
6695: LIST
6696: PUSH
6697: EMPTY
6698: LIST
6699: LIST
6700: LIST
6701: PPUSH
6702: CALL_OW 72
6706: DIFF
6707: ST_TO_ADDR
// if not attackers then
6708: LD_VAR 0 6
6712: NOT
6713: IFFALSE 6717
// exit ;
6715: GO 6900
// uc_side := 2 ;
6717: LD_ADDR_OWVAR 20
6721: PUSH
6722: LD_INT 2
6724: ST_TO_ADDR
// uc_nation := 2 ;
6725: LD_ADDR_OWVAR 21
6729: PUSH
6730: LD_INT 2
6732: ST_TO_ADDR
// InitHc ;
6733: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
6737: LD_ADDR_VAR 0 1
6741: PUSH
6742: DOUBLE
6743: LD_INT 1
6745: DEC
6746: ST_TO_ADDR
6747: LD_INT 4
6749: PUSH
6750: LD_INT 5
6752: PUSH
6753: LD_INT 6
6755: PUSH
6756: LD_INT 6
6758: PUSH
6759: EMPTY
6760: LIST
6761: LIST
6762: LIST
6763: LIST
6764: PUSH
6765: LD_OWVAR 67
6769: ARRAY
6770: PUSH
6771: FOR_TO
6772: IFFALSE 6849
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6774: LD_INT 0
6776: PPUSH
6777: LD_INT 15
6779: PUSH
6780: LD_INT 17
6782: PUSH
6783: EMPTY
6784: LIST
6785: LIST
6786: PUSH
6787: LD_INT 1
6789: PPUSH
6790: LD_INT 2
6792: PPUSH
6793: CALL_OW 12
6797: ARRAY
6798: PPUSH
6799: LD_INT 8
6801: PPUSH
6802: CALL_OW 380
// un := CreateHuman ;
6806: LD_ADDR_VAR 0 7
6810: PUSH
6811: CALL_OW 44
6815: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6816: LD_VAR 0 7
6820: PPUSH
6821: LD_INT 23
6823: PPUSH
6824: LD_INT 0
6826: PPUSH
6827: CALL_OW 49
// attackers := attackers union un ;
6831: LD_ADDR_VAR 0 6
6835: PUSH
6836: LD_VAR 0 6
6840: PUSH
6841: LD_VAR 0 7
6845: UNION
6846: ST_TO_ADDR
// end ;
6847: GO 6771
6849: POP
6850: POP
// repeat wait ( 0 0$1 ) ;
6851: LD_INT 35
6853: PPUSH
6854: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6858: LD_VAR 0 6
6862: PPUSH
6863: LD_INT 60
6865: PUSH
6866: EMPTY
6867: LIST
6868: PPUSH
6869: CALL_OW 72
6873: NOT
6874: IFFALSE 6851
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6876: LD_VAR 0 2
6880: PPUSH
6881: LD_VAR 0 6
6885: PPUSH
6886: LD_VAR 0 5
6890: PPUSH
6891: LD_VAR 0 4
6895: PPUSH
6896: CALL 80840 0 4
// end ; end_of_file
6900: PPOPN 7
6902: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
6903: LD_INT 0
6905: PPUSH
6906: PPUSH
6907: PPUSH
6908: PPUSH
6909: PPUSH
6910: PPUSH
// uc_side := 1 ;
6911: LD_ADDR_OWVAR 20
6915: PUSH
6916: LD_INT 1
6918: ST_TO_ADDR
// uc_nation := 1 ;
6919: LD_ADDR_OWVAR 21
6923: PUSH
6924: LD_INT 1
6926: ST_TO_ADDR
// InitHc ;
6927: CALL_OW 19
// InitVc ;
6931: CALL_OW 20
// tmp := [ ] ;
6935: LD_ADDR_VAR 0 3
6939: PUSH
6940: EMPTY
6941: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
6942: LD_ADDR_VAR 0 2
6946: PUSH
6947: DOUBLE
6948: LD_INT 1
6950: DEC
6951: ST_TO_ADDR
6952: LD_INT 6
6954: PUSH
6955: LD_INT 8
6957: PUSH
6958: LD_INT 10
6960: PUSH
6961: LD_INT 10
6963: PUSH
6964: EMPTY
6965: LIST
6966: LIST
6967: LIST
6968: LIST
6969: PUSH
6970: LD_OWVAR 67
6974: ARRAY
6975: PUSH
6976: FOR_TO
6977: IFFALSE 7251
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
6979: LD_ADDR_VAR 0 5
6983: PUSH
6984: LD_INT 2
6986: PUSH
6987: LD_INT 4
6989: PUSH
6990: LD_INT 5
6992: PUSH
6993: EMPTY
6994: LIST
6995: LIST
6996: LIST
6997: PUSH
6998: LD_INT 1
7000: PPUSH
7001: LD_INT 3
7003: PPUSH
7004: CALL_OW 12
7008: ARRAY
7009: ST_TO_ADDR
// case chassis of us_medium_wheeled :
7010: LD_VAR 0 5
7014: PUSH
7015: LD_INT 2
7017: DOUBLE
7018: EQUAL
7019: IFTRUE 7023
7021: GO 7057
7023: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
7024: LD_ADDR_VAR 0 6
7028: PUSH
7029: LD_INT 9
7031: PUSH
7032: LD_INT 5
7034: PUSH
7035: LD_INT 7
7037: PUSH
7038: EMPTY
7039: LIST
7040: LIST
7041: LIST
7042: PUSH
7043: LD_INT 1
7045: PPUSH
7046: LD_INT 3
7048: PPUSH
7049: CALL_OW 12
7053: ARRAY
7054: ST_TO_ADDR
7055: GO 7146
7057: LD_INT 4
7059: DOUBLE
7060: EQUAL
7061: IFTRUE 7065
7063: GO 7103
7065: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7066: LD_ADDR_VAR 0 6
7070: PUSH
7071: LD_INT 9
7073: PUSH
7074: LD_INT 6
7076: PUSH
7077: LD_INT 6
7079: PUSH
7080: LD_INT 7
7082: PUSH
7083: EMPTY
7084: LIST
7085: LIST
7086: LIST
7087: LIST
7088: PUSH
7089: LD_INT 1
7091: PPUSH
7092: LD_INT 4
7094: PPUSH
7095: CALL_OW 12
7099: ARRAY
7100: ST_TO_ADDR
7101: GO 7146
7103: LD_INT 5
7105: DOUBLE
7106: EQUAL
7107: IFTRUE 7111
7109: GO 7145
7111: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7112: LD_ADDR_VAR 0 6
7116: PUSH
7117: LD_INT 9
7119: PUSH
7120: LD_INT 6
7122: PUSH
7123: LD_INT 7
7125: PUSH
7126: EMPTY
7127: LIST
7128: LIST
7129: LIST
7130: PUSH
7131: LD_INT 1
7133: PPUSH
7134: LD_INT 3
7136: PPUSH
7137: CALL_OW 12
7141: ARRAY
7142: ST_TO_ADDR
7143: GO 7146
7145: POP
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7146: LD_VAR 0 5
7150: PPUSH
7151: LD_INT 1
7153: PUSH
7154: LD_INT 3
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: PUSH
7161: LD_INT 1
7163: PPUSH
7164: LD_INT 2
7166: PPUSH
7167: CALL_OW 12
7171: ARRAY
7172: PPUSH
7173: LD_INT 3
7175: PPUSH
7176: LD_VAR 0 6
7180: PPUSH
7181: LD_INT 70
7183: PPUSH
7184: LD_INT 90
7186: PPUSH
7187: CALL_OW 12
7191: PPUSH
7192: CALL 19965 0 5
// veh := CreateVehicle ;
7196: LD_ADDR_VAR 0 4
7200: PUSH
7201: CALL_OW 45
7205: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
7206: LD_VAR 0 4
7210: PPUSH
7211: LD_INT 2
7213: PPUSH
7214: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
7218: LD_VAR 0 4
7222: PPUSH
7223: LD_INT 17
7225: PPUSH
7226: LD_INT 0
7228: PPUSH
7229: CALL_OW 49
// tmp := tmp ^ veh ;
7233: LD_ADDR_VAR 0 3
7237: PUSH
7238: LD_VAR 0 3
7242: PUSH
7243: LD_VAR 0 4
7247: ADD
7248: ST_TO_ADDR
// end ;
7249: GO 6976
7251: POP
7252: POP
// if not tmp then
7253: LD_VAR 0 3
7257: NOT
7258: IFFALSE 7262
// exit ;
7260: GO 7371
// if not first_powell_attack then
7262: LD_EXP 12
7266: NOT
7267: IFFALSE 7277
// first_powell_attack := true ;
7269: LD_ADDR_EXP 12
7273: PUSH
7274: LD_INT 1
7276: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
7277: LD_INT 70
7279: PPUSH
7280: CALL_OW 67
// for i in tmp do
7284: LD_ADDR_VAR 0 2
7288: PUSH
7289: LD_VAR 0 3
7293: PUSH
7294: FOR_IN
7295: IFFALSE 7362
// if IsOk ( i ) then
7297: LD_VAR 0 2
7301: PPUSH
7302: CALL_OW 302
7306: IFFALSE 7344
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
7308: LD_VAR 0 2
7312: PPUSH
7313: LD_INT 81
7315: PUSH
7316: LD_INT 1
7318: PUSH
7319: EMPTY
7320: LIST
7321: LIST
7322: PPUSH
7323: CALL_OW 69
7327: PPUSH
7328: LD_VAR 0 2
7332: PPUSH
7333: CALL_OW 74
7337: PPUSH
7338: CALL_OW 115
7342: GO 7360
// tmp := tmp diff i ;
7344: LD_ADDR_VAR 0 3
7348: PUSH
7349: LD_VAR 0 3
7353: PUSH
7354: LD_VAR 0 2
7358: DIFF
7359: ST_TO_ADDR
7360: GO 7294
7362: POP
7363: POP
// until not tmp ;
7364: LD_VAR 0 3
7368: NOT
7369: IFFALSE 7277
// end ; end_of_file
7371: LD_VAR 0 1
7375: RET
// export function Action ; var tmp , i , un ; begin
7376: LD_INT 0
7378: PPUSH
7379: PPUSH
7380: PPUSH
7381: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
7382: LD_INT 68
7384: PPUSH
7385: LD_INT 39
7387: PPUSH
7388: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
7392: LD_ADDR_VAR 0 2
7396: PUSH
7397: LD_INT 22
7399: PUSH
7400: LD_INT 7
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: PPUSH
7407: CALL_OW 69
7411: ST_TO_ADDR
// InGameOn ;
7412: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
7416: LD_VAR 0 2
7420: PPUSH
7421: LD_INT 71
7423: PPUSH
7424: LD_INT 49
7426: PPUSH
7427: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7431: LD_INT 35
7433: PPUSH
7434: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
7438: LD_INT 7
7440: PPUSH
7441: LD_INT 71
7443: PPUSH
7444: LD_INT 51
7446: PPUSH
7447: CALL_OW 293
7451: IFFALSE 7431
// DialogueOn ;
7453: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7457: LD_EXP 16
7461: PPUSH
7462: LD_STRING D1-JMM-1
7464: PPUSH
7465: CALL_OW 88
// if Joan then
7469: LD_EXP 31
7473: IFFALSE 7487
// Say ( Joan , D1-Joan-1 ) ;
7475: LD_EXP 31
7479: PPUSH
7480: LD_STRING D1-Joan-1
7482: PPUSH
7483: CALL_OW 88
// if Lisa then
7487: LD_EXP 18
7491: IFFALSE 7505
// Say ( Lisa , D1-Lisa-1 ) ;
7493: LD_EXP 18
7497: PPUSH
7498: LD_STRING D1-Lisa-1
7500: PPUSH
7501: CALL_OW 88
// if Joan or Lisa then
7505: LD_EXP 31
7509: PUSH
7510: LD_EXP 18
7514: OR
7515: IFFALSE 7529
// Say ( JMM , D1-JMM-2 ) ;
7517: LD_EXP 16
7521: PPUSH
7522: LD_STRING D1-JMM-2
7524: PPUSH
7525: CALL_OW 88
// DialogueOff ;
7529: CALL_OW 7
// InGameOff ;
7533: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7537: LD_INT 71
7539: PPUSH
7540: LD_INT 50
7542: PPUSH
7543: LD_INT 7
7545: PPUSH
7546: LD_INT 30
7548: NEG
7549: PPUSH
7550: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7554: LD_INT 71
7556: PPUSH
7557: LD_INT 50
7559: PPUSH
7560: LD_INT 7
7562: PPUSH
7563: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7567: LD_STRING M1
7569: PPUSH
7570: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7574: LD_INT 35
7576: PPUSH
7577: CALL_OW 67
// until freedom or tick > 1 1$00 ;
7581: LD_EXP 3
7585: PUSH
7586: LD_OWVAR 1
7590: PUSH
7591: LD_INT 2100
7593: GREATER
7594: OR
7595: IFFALSE 7574
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7597: LD_INT 350
7599: PPUSH
7600: LD_INT 700
7602: PPUSH
7603: CALL_OW 12
7607: PPUSH
7608: CALL_OW 67
// PrepareGossudarov ;
7612: CALL 1935 0 0
// repeat wait ( 0 0$1 ) ;
7616: LD_INT 35
7618: PPUSH
7619: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7623: LD_INT 22
7625: PUSH
7626: LD_INT 6
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: PUSH
7633: LD_INT 3
7635: PUSH
7636: LD_INT 24
7638: PUSH
7639: LD_INT 1000
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: PUSH
7646: EMPTY
7647: LIST
7648: LIST
7649: PUSH
7650: EMPTY
7651: LIST
7652: LIST
7653: PPUSH
7654: CALL_OW 69
7658: PUSH
7659: LD_INT 7
7661: PPUSH
7662: LD_EXP 34
7666: PPUSH
7667: CALL_OW 292
7671: OR
7672: IFFALSE 7616
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7674: LD_ADDR_VAR 0 2
7678: PUSH
7679: LD_INT 22
7681: PUSH
7682: LD_INT 6
7684: PUSH
7685: EMPTY
7686: LIST
7687: LIST
7688: PPUSH
7689: CALL_OW 69
7693: ST_TO_ADDR
// for i in tmp do
7694: LD_ADDR_VAR 0 3
7698: PUSH
7699: LD_VAR 0 2
7703: PUSH
7704: FOR_IN
7705: IFFALSE 7721
// SetSide ( i , 7 ) ;
7707: LD_VAR 0 3
7711: PPUSH
7712: LD_INT 7
7714: PPUSH
7715: CALL_OW 235
7719: GO 7704
7721: POP
7722: POP
// DialogueOn ;
7723: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7727: LD_EXP 16
7731: PUSH
7732: LD_EXP 17
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: PPUSH
7741: LD_EXP 34
7745: PPUSH
7746: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7750: LD_EXP 34
7754: PPUSH
7755: CALL_OW 87
// if not Roth then
7759: LD_EXP 17
7763: NOT
7764: IFFALSE 7856
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7766: LD_VAR 0 2
7770: PPUSH
7771: LD_INT 3
7773: PUSH
7774: LD_INT 24
7776: PUSH
7777: LD_INT 1000
7779: PUSH
7780: EMPTY
7781: LIST
7782: LIST
7783: PUSH
7784: EMPTY
7785: LIST
7786: LIST
7787: PPUSH
7788: CALL_OW 72
7792: IFFALSE 7806
// Say ( JMM , D2-JMM-1 ) ;
7794: LD_EXP 16
7798: PPUSH
7799: LD_STRING D2-JMM-1
7801: PPUSH
7802: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7806: LD_EXP 16
7810: PPUSH
7811: LD_STRING D2-JMM-1b
7813: PPUSH
7814: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7818: LD_EXP 34
7822: PPUSH
7823: LD_STRING D2-Gos-1
7825: PPUSH
7826: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7830: LD_EXP 16
7834: PPUSH
7835: LD_STRING D2-JMM-2
7837: PPUSH
7838: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7842: LD_EXP 34
7846: PPUSH
7847: LD_STRING D2-Gos-2
7849: PPUSH
7850: CALL_OW 88
// end else
7854: GO 8008
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7856: LD_VAR 0 2
7860: PPUSH
7861: LD_INT 3
7863: PUSH
7864: LD_INT 24
7866: PUSH
7867: LD_INT 1000
7869: PUSH
7870: EMPTY
7871: LIST
7872: LIST
7873: PUSH
7874: EMPTY
7875: LIST
7876: LIST
7877: PPUSH
7878: CALL_OW 72
7882: IFFALSE 7908
// begin Say ( Roth , D2-Roth-2 ) ;
7884: LD_EXP 17
7888: PPUSH
7889: LD_STRING D2-Roth-2
7891: PPUSH
7892: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7896: LD_EXP 16
7900: PPUSH
7901: LD_STRING D2-JMM-1a
7903: PPUSH
7904: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7908: LD_EXP 17
7912: PPUSH
7913: LD_STRING D2-Roth-2a
7915: PPUSH
7916: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7920: LD_EXP 17
7924: PPUSH
7925: LD_STRING D2-Roth-2b
7927: PPUSH
7928: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7932: LD_EXP 16
7936: PPUSH
7937: LD_STRING D2-JMM-3
7939: PPUSH
7940: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7944: LD_VAR 0 2
7948: PPUSH
7949: LD_INT 3
7951: PUSH
7952: LD_INT 24
7954: PUSH
7955: LD_INT 1000
7957: PUSH
7958: EMPTY
7959: LIST
7960: LIST
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: PPUSH
7966: CALL_OW 72
7970: IFFALSE 8008
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7972: LD_EXP 34
7976: PPUSH
7977: LD_STRING D2-Gos-3
7979: PPUSH
7980: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7984: LD_EXP 16
7988: PPUSH
7989: LD_STRING D2-JMM-4
7991: PPUSH
7992: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7996: LD_EXP 34
8000: PPUSH
8001: LD_STRING D2-Gos-4
8003: PPUSH
8004: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
8008: LD_EXP 16
8012: PPUSH
8013: LD_STRING D2-JMM-5
8015: PPUSH
8016: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
8020: LD_EXP 34
8024: PPUSH
8025: LD_STRING D2-Gos-5
8027: PPUSH
8028: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
8032: LD_EXP 16
8036: PPUSH
8037: LD_STRING D2-JMM-6
8039: PPUSH
8040: CALL_OW 88
// DialogueOff ;
8044: CALL_OW 7
// wait ( 0 0$2 ) ;
8048: LD_INT 70
8050: PPUSH
8051: CALL_OW 67
// if Kirilenkova then
8055: LD_EXP 35
8059: IFFALSE 8073
// Say ( Kirilenkova , D3-Kir-1 ) ;
8061: LD_EXP 35
8065: PPUSH
8066: LD_STRING D3-Kir-1
8068: PPUSH
8069: CALL_OW 88
// gossudarov_arrive := true ;
8073: LD_ADDR_EXP 4
8077: PUSH
8078: LD_INT 1
8080: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8081: LD_INT 35
8083: PPUSH
8084: CALL_OW 67
// until ru_lab_builded ;
8088: LD_EXP 5
8092: IFFALSE 8081
// DialogueOn ;
8094: CALL_OW 6
// if Kirilenkova then
8098: LD_EXP 35
8102: IFFALSE 8118
// Say ( Kirilenkova , D3a-Kir-1 ) else
8104: LD_EXP 35
8108: PPUSH
8109: LD_STRING D3a-Kir-1
8111: PPUSH
8112: CALL_OW 88
8116: GO 8140
// begin un := SciRu ;
8118: LD_ADDR_VAR 0 4
8122: PUSH
8123: CALL 13334 0 0
8127: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8128: LD_VAR 0 4
8132: PPUSH
8133: LD_STRING D3a-Sci1-1
8135: PPUSH
8136: CALL_OW 88
// end ; if Kirilenkova or un then
8140: LD_EXP 35
8144: PUSH
8145: LD_VAR 0 4
8149: OR
8150: IFFALSE 8164
// Say ( JMM , D3a-JMM-1 ) ;
8152: LD_EXP 16
8156: PPUSH
8157: LD_STRING D3a-JMM-1
8159: PPUSH
8160: CALL_OW 88
// DialogueOff ;
8164: CALL_OW 7
// end ;
8168: LD_VAR 0 1
8172: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
8173: LD_EXP 4
8177: PUSH
8178: LD_INT 22
8180: PUSH
8181: LD_INT 7
8183: PUSH
8184: EMPTY
8185: LIST
8186: LIST
8187: PUSH
8188: LD_INT 2
8190: PUSH
8191: LD_INT 25
8193: PUSH
8194: LD_INT 1
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: LD_INT 25
8203: PUSH
8204: LD_INT 2
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: LD_INT 25
8213: PUSH
8214: LD_INT 3
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: PUSH
8221: LD_INT 25
8223: PUSH
8224: LD_INT 4
8226: PUSH
8227: EMPTY
8228: LIST
8229: LIST
8230: PUSH
8231: LD_INT 25
8233: PUSH
8234: LD_INT 5
8236: PUSH
8237: EMPTY
8238: LIST
8239: LIST
8240: PUSH
8241: LD_INT 25
8243: PUSH
8244: LD_INT 8
8246: PUSH
8247: EMPTY
8248: LIST
8249: LIST
8250: PUSH
8251: LD_INT 25
8253: PUSH
8254: LD_INT 9
8256: PUSH
8257: EMPTY
8258: LIST
8259: LIST
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: LIST
8270: PUSH
8271: EMPTY
8272: LIST
8273: LIST
8274: PPUSH
8275: CALL_OW 69
8279: PUSH
8280: LD_INT 7
8282: LESS
8283: AND
8284: IFFALSE 8296
8286: GO 8288
8288: DISABLE
// YouLost ( TooMany ) ;
8289: LD_STRING TooMany
8291: PPUSH
8292: CALL_OW 104
8296: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
8297: LD_EXP 34
8301: PPUSH
8302: CALL_OW 255
8306: PUSH
8307: LD_INT 7
8309: EQUAL
8310: IFFALSE 8527
8312: GO 8314
8314: DISABLE
8315: LD_INT 0
8317: PPUSH
8318: PPUSH
8319: PPUSH
// begin uc_side := 3 ;
8320: LD_ADDR_OWVAR 20
8324: PUSH
8325: LD_INT 3
8327: ST_TO_ADDR
// uc_nation := 3 ;
8328: LD_ADDR_OWVAR 21
8332: PUSH
8333: LD_INT 3
8335: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
8336: LD_INT 21
8338: PPUSH
8339: LD_INT 3
8341: PPUSH
8342: LD_INT 3
8344: PPUSH
8345: LD_INT 42
8347: PPUSH
8348: LD_INT 100
8350: PPUSH
8351: CALL 19965 0 5
// un := CreateVehicle ;
8355: LD_ADDR_VAR 0 3
8359: PUSH
8360: CALL_OW 45
8364: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
8365: LD_VAR 0 3
8369: PPUSH
8370: LD_INT 15
8372: PPUSH
8373: LD_INT 0
8375: PPUSH
8376: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
8380: LD_VAR 0 3
8384: PPUSH
8385: LD_INT 67
8387: PPUSH
8388: LD_INT 45
8390: PPUSH
8391: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
8395: LD_VAR 0 3
8399: PPUSH
8400: LD_INT 70
8402: PPUSH
8403: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
8407: LD_VAR 0 3
8411: PPUSH
8412: LD_INT 69
8414: PPUSH
8415: LD_INT 18
8417: PPUSH
8418: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
8422: LD_VAR 0 3
8426: PPUSH
8427: LD_INT 60
8429: PPUSH
8430: LD_INT 3
8432: PPUSH
8433: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8437: LD_INT 35
8439: PPUSH
8440: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
8444: LD_VAR 0 3
8448: PPUSH
8449: CALL_OW 302
8453: NOT
8454: PUSH
8455: LD_VAR 0 3
8459: PPUSH
8460: LD_INT 17
8462: PPUSH
8463: CALL_OW 308
8467: OR
8468: PUSH
8469: LD_VAR 0 3
8473: PPUSH
8474: LD_INT 60
8476: PPUSH
8477: LD_INT 3
8479: PPUSH
8480: CALL_OW 307
8484: OR
8485: IFFALSE 8437
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
8487: LD_VAR 0 3
8491: PPUSH
8492: LD_INT 17
8494: PPUSH
8495: CALL_OW 308
8499: PUSH
8500: LD_VAR 0 3
8504: PPUSH
8505: LD_INT 60
8507: PPUSH
8508: LD_INT 3
8510: PPUSH
8511: CALL_OW 307
8515: OR
8516: IFFALSE 8527
// RemoveUnit ( un ) ;
8518: LD_VAR 0 3
8522: PPUSH
8523: CALL_OW 64
// end ;
8527: PPOPN 3
8529: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8530: LD_EXP 4
8534: IFFALSE 8776
8536: GO 8538
8538: DISABLE
8539: LD_INT 0
8541: PPUSH
8542: PPUSH
8543: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8544: LD_INT 70
8546: PPUSH
8547: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8551: LD_ADDR_VAR 0 3
8555: PUSH
8556: LD_INT 22
8558: PUSH
8559: LD_INT 7
8561: PUSH
8562: EMPTY
8563: LIST
8564: LIST
8565: PUSH
8566: LD_INT 101
8568: PUSH
8569: LD_INT 3
8571: PUSH
8572: EMPTY
8573: LIST
8574: LIST
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: PPUSH
8580: CALL_OW 69
8584: ST_TO_ADDR
// until tmp ;
8585: LD_VAR 0 3
8589: IFFALSE 8544
// un := NearestUnitToUnit ( tmp , JMM ) ;
8591: LD_ADDR_VAR 0 2
8595: PUSH
8596: LD_VAR 0 3
8600: PPUSH
8601: LD_EXP 16
8605: PPUSH
8606: CALL_OW 74
8610: ST_TO_ADDR
// player_spotted := true ;
8611: LD_ADDR_EXP 6
8615: PUSH
8616: LD_INT 1
8618: ST_TO_ADDR
// tmp := SciRu ;
8619: LD_ADDR_VAR 0 3
8623: PUSH
8624: CALL 13334 0 0
8628: ST_TO_ADDR
// if not tmp then
8629: LD_VAR 0 3
8633: NOT
8634: IFFALSE 8646
// tmp := SolRu ;
8636: LD_ADDR_VAR 0 3
8640: PUSH
8641: CALL 13481 0 0
8645: ST_TO_ADDR
// DialogueOn ;
8646: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8650: LD_VAR 0 2
8654: PPUSH
8655: CALL_OW 250
8659: PPUSH
8660: LD_VAR 0 2
8664: PPUSH
8665: CALL_OW 251
8669: PPUSH
8670: LD_INT 7
8672: PPUSH
8673: LD_INT 8
8675: NEG
8676: PPUSH
8677: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8681: LD_VAR 0 2
8685: PPUSH
8686: CALL_OW 87
// if tmp then
8690: LD_VAR 0 3
8694: IFFALSE 8708
// Say ( tmp , D4-RSci1-1 ) ;
8696: LD_VAR 0 3
8700: PPUSH
8701: LD_STRING D4-RSci1-1
8703: PPUSH
8704: CALL_OW 88
// if Gossudarov then
8708: LD_EXP 34
8712: IFFALSE 8738
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8714: LD_EXP 34
8718: PPUSH
8719: LD_STRING D4-Gos-1
8721: PPUSH
8722: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8726: LD_EXP 16
8730: PPUSH
8731: LD_STRING D4-JMM-1
8733: PPUSH
8734: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8738: LD_VAR 0 2
8742: PPUSH
8743: CALL_OW 250
8747: PPUSH
8748: LD_VAR 0 2
8752: PPUSH
8753: CALL_OW 251
8757: PPUSH
8758: LD_INT 7
8760: PPUSH
8761: CALL_OW 331
// DialogueOff ;
8765: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8769: LD_STRING M5
8771: PPUSH
8772: CALL_OW 337
// end ;
8776: PPOPN 3
8778: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8779: LD_EXP 6
8783: IFFALSE 9376
8785: GO 8787
8787: DISABLE
8788: LD_INT 0
8790: PPUSH
8791: PPUSH
8792: PPUSH
// begin PrepareBelkov ;
8793: CALL 2248 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8797: LD_EXP 49
8801: PPUSH
8802: LD_INT 118
8804: PPUSH
8805: LD_INT 106
8807: PPUSH
8808: CALL_OW 111
// AddComHold ( Belkov ) ;
8812: LD_EXP 49
8816: PPUSH
8817: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8821: LD_INT 35
8823: PPUSH
8824: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8828: LD_EXP 49
8832: PPUSH
8833: LD_INT 118
8835: PPUSH
8836: LD_INT 106
8838: PPUSH
8839: CALL_OW 307
8843: IFFALSE 8821
// ChangeSideFog ( 4 , 7 ) ;
8845: LD_INT 4
8847: PPUSH
8848: LD_INT 7
8850: PPUSH
8851: CALL_OW 343
// if IsOk ( Belkov ) then
8855: LD_EXP 49
8859: PPUSH
8860: CALL_OW 302
8864: IFFALSE 8948
// begin InGameOn ;
8866: CALL_OW 8
// DialogueOn ;
8870: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8874: LD_EXP 49
8878: PPUSH
8879: LD_STRING D5-Bel-1
8881: PPUSH
8882: CALL_OW 94
// if Gossudarov then
8886: LD_EXP 34
8890: IFFALSE 8940
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8892: LD_EXP 34
8896: PPUSH
8897: LD_STRING D5-Gos-1
8899: PPUSH
8900: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8904: LD_EXP 16
8908: PPUSH
8909: LD_STRING D5-JMM-1
8911: PPUSH
8912: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8916: LD_EXP 34
8920: PPUSH
8921: LD_STRING D5-Gos-2
8923: PPUSH
8924: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8928: LD_EXP 16
8932: PPUSH
8933: LD_STRING D5-JMM-2
8935: PPUSH
8936: CALL_OW 88
// end ; DialogueOff ;
8940: CALL_OW 7
// InGameOff ;
8944: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8948: LD_STRING QSaveBelkov
8950: PPUSH
8951: CALL_OW 97
8955: PUSH
8956: LD_INT 1
8958: DOUBLE
8959: EQUAL
8960: IFTRUE 8964
8962: GO 9014
8964: POP
// begin DialogueOn ;
8965: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8969: LD_EXP 16
8973: PPUSH
8974: LD_STRING D5a-JMM-1
8976: PPUSH
8977: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8981: LD_EXP 49
8985: PPUSH
8986: LD_STRING D5a-Bel-1
8988: PPUSH
8989: CALL_OW 94
// DialogueOff ;
8993: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8997: LD_EXP 49
9001: PPUSH
9002: LD_INT 83
9004: PPUSH
9005: LD_INT 49
9007: PPUSH
9008: CALL_OW 111
// end ; 2 :
9012: GO 9047
9014: LD_INT 2
9016: DOUBLE
9017: EQUAL
9018: IFTRUE 9022
9020: GO 9046
9022: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
9023: LD_EXP 16
9027: PPUSH
9028: LD_STRING D5a-JMM-2
9030: PPUSH
9031: CALL_OW 88
// ComHold ( Belkov ) ;
9035: LD_EXP 49
9039: PPUSH
9040: CALL_OW 140
// end ; end ;
9044: GO 9047
9046: POP
// time := 0 0$00 ;
9047: LD_ADDR_VAR 0 1
9051: PUSH
9052: LD_INT 0
9054: ST_TO_ADDR
// vehSpawned := false ;
9055: LD_ADDR_VAR 0 3
9059: PUSH
9060: LD_INT 0
9062: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9063: LD_INT 35
9065: PPUSH
9066: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
9070: LD_VAR 0 1
9074: PUSH
9075: LD_INT 350
9077: PUSH
9078: LD_INT 175
9080: PUSH
9081: LD_INT 105
9083: PUSH
9084: LD_INT 70
9086: PUSH
9087: EMPTY
9088: LIST
9089: LIST
9090: LIST
9091: LIST
9092: PUSH
9093: LD_OWVAR 67
9097: ARRAY
9098: GREATEREQUAL
9099: PUSH
9100: LD_VAR 0 3
9104: NOT
9105: AND
9106: IFFALSE 9196
// begin vehSpawned := true ;
9108: LD_ADDR_VAR 0 3
9112: PUSH
9113: LD_INT 1
9115: ST_TO_ADDR
// uc_side := 3 ;
9116: LD_ADDR_OWVAR 20
9120: PUSH
9121: LD_INT 3
9123: ST_TO_ADDR
// uc_nation := 3 ;
9124: LD_ADDR_OWVAR 21
9128: PUSH
9129: LD_INT 3
9131: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9132: LD_INT 22
9134: PPUSH
9135: LD_INT 3
9137: PPUSH
9138: LD_INT 3
9140: PPUSH
9141: LD_INT 43
9143: PPUSH
9144: LD_INT 100
9146: PPUSH
9147: CALL 19965 0 5
// veh := CreateVehicle ;
9151: LD_ADDR_VAR 0 2
9155: PUSH
9156: CALL_OW 45
9160: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
9161: LD_VAR 0 2
9165: PPUSH
9166: LD_INT 130
9168: PPUSH
9169: LD_INT 131
9171: PPUSH
9172: LD_INT 0
9174: PPUSH
9175: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
9179: LD_VAR 0 2
9183: PPUSH
9184: LD_INT 100
9186: PPUSH
9187: LD_INT 82
9189: PPUSH
9190: CALL_OW 114
// end else
9194: GO 9210
// time := time + 0 0$1 ;
9196: LD_ADDR_VAR 0 1
9200: PUSH
9201: LD_VAR 0 1
9205: PUSH
9206: LD_INT 35
9208: PLUS
9209: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
9210: LD_EXP 49
9214: PPUSH
9215: CALL_OW 301
9219: PUSH
9220: LD_EXP 49
9224: PPUSH
9225: CALL_OW 255
9229: PUSH
9230: LD_INT 4
9232: EQUAL
9233: AND
9234: PUSH
9235: LD_INT 22
9237: PUSH
9238: LD_INT 7
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: PPUSH
9245: CALL_OW 69
9249: PPUSH
9250: LD_EXP 49
9254: PPUSH
9255: CALL_OW 74
9259: PPUSH
9260: LD_EXP 49
9264: PPUSH
9265: CALL_OW 296
9269: PUSH
9270: LD_INT 10
9272: LESS
9273: OR
9274: IFFALSE 9063
// if IsDead ( Belkov ) then
9276: LD_EXP 49
9280: PPUSH
9281: CALL_OW 301
9285: IFFALSE 9310
// begin CenterNowOnUnits ( Belkov ) ;
9287: LD_EXP 49
9291: PPUSH
9292: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
9296: LD_EXP 16
9300: PPUSH
9301: LD_STRING D5a-JMM-2a
9303: PPUSH
9304: CALL_OW 88
// exit ;
9308: GO 9376
// end ; if See ( 7 , Belkov ) then
9310: LD_INT 7
9312: PPUSH
9313: LD_EXP 49
9317: PPUSH
9318: CALL_OW 292
9322: IFFALSE 9336
// SetSide ( Belkov , 7 ) ;
9324: LD_EXP 49
9328: PPUSH
9329: LD_INT 7
9331: PPUSH
9332: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
9336: LD_INT 35
9338: PPUSH
9339: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
9343: LD_EXP 49
9347: PPUSH
9348: LD_INT 66
9350: PPUSH
9351: LD_INT 45
9353: PPUSH
9354: CALL_OW 297
9358: PUSH
9359: LD_INT 30
9361: LESS
9362: IFFALSE 9336
// Say ( Belkov , D6-Bel-1 ) ;
9364: LD_EXP 49
9368: PPUSH
9369: LD_STRING D6-Bel-1
9371: PPUSH
9372: CALL_OW 88
// end ;
9376: PPOPN 3
9378: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
9379: LD_EXP 49
9383: PPUSH
9384: CALL_OW 302
9388: PUSH
9389: LD_EXP 49
9393: PPUSH
9394: CALL_OW 504
9398: PUSH
9399: LD_INT 2
9401: PUSH
9402: LD_INT 34
9404: PUSH
9405: LD_INT 47
9407: PUSH
9408: EMPTY
9409: LIST
9410: LIST
9411: PUSH
9412: LD_INT 34
9414: PUSH
9415: LD_INT 45
9417: PUSH
9418: EMPTY
9419: LIST
9420: LIST
9421: PUSH
9422: EMPTY
9423: LIST
9424: LIST
9425: LIST
9426: PPUSH
9427: CALL_OW 69
9431: IN
9432: AND
9433: IFFALSE 9450
9435: GO 9437
9437: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
9438: LD_EXP 49
9442: PPUSH
9443: LD_STRING D7-Bel-1
9445: PPUSH
9446: CALL_OW 88
9450: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
9451: LD_INT 22
9453: PUSH
9454: LD_INT 7
9456: PUSH
9457: EMPTY
9458: LIST
9459: LIST
9460: PUSH
9461: LD_INT 101
9463: PUSH
9464: LD_INT 2
9466: PUSH
9467: EMPTY
9468: LIST
9469: LIST
9470: PUSH
9471: EMPTY
9472: LIST
9473: LIST
9474: PPUSH
9475: CALL_OW 69
9479: PUSH
9480: LD_EXP 8
9484: NOT
9485: AND
9486: PUSH
9487: LD_EXP 48
9491: PPUSH
9492: CALL_OW 305
9496: NOT
9497: AND
9498: IFFALSE 9968
9500: GO 9502
9502: DISABLE
9503: LD_INT 0
9505: PPUSH
// begin ar_base_spotted := true ;
9506: LD_ADDR_EXP 8
9510: PUSH
9511: LD_INT 1
9513: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9514: LD_ADDR_VAR 0 1
9518: PUSH
9519: LD_INT 22
9521: PUSH
9522: LD_INT 2
9524: PUSH
9525: EMPTY
9526: LIST
9527: LIST
9528: PUSH
9529: LD_INT 21
9531: PUSH
9532: LD_INT 3
9534: PUSH
9535: EMPTY
9536: LIST
9537: LIST
9538: PUSH
9539: EMPTY
9540: LIST
9541: LIST
9542: PPUSH
9543: CALL_OW 69
9547: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9548: LD_ADDR_VAR 0 1
9552: PUSH
9553: LD_VAR 0 1
9557: PPUSH
9558: LD_EXP 16
9562: PPUSH
9563: CALL_OW 74
9567: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9568: LD_INT 7
9570: PPUSH
9571: LD_INT 3
9573: PPUSH
9574: CALL_OW 332
// DialogueOn ;
9578: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9582: LD_VAR 0 1
9586: PPUSH
9587: CALL_OW 250
9591: PPUSH
9592: LD_VAR 0 1
9596: PPUSH
9597: CALL_OW 251
9601: PPUSH
9602: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9606: LD_ADDR_VAR 0 1
9610: PUSH
9611: LD_INT 22
9613: PUSH
9614: LD_INT 7
9616: PUSH
9617: EMPTY
9618: LIST
9619: LIST
9620: PUSH
9621: LD_INT 23
9623: PUSH
9624: LD_INT 1
9626: PUSH
9627: EMPTY
9628: LIST
9629: LIST
9630: PUSH
9631: LD_INT 26
9633: PUSH
9634: LD_INT 1
9636: PUSH
9637: EMPTY
9638: LIST
9639: LIST
9640: PUSH
9641: EMPTY
9642: LIST
9643: LIST
9644: LIST
9645: PPUSH
9646: CALL_OW 69
9650: PUSH
9651: LD_EXP 16
9655: PUSH
9656: LD_EXP 20
9660: PUSH
9661: LD_EXP 21
9665: PUSH
9666: LD_EXP 28
9670: PUSH
9671: LD_EXP 17
9675: PUSH
9676: LD_EXP 26
9680: PUSH
9681: LD_EXP 22
9685: PUSH
9686: LD_EXP 24
9690: PUSH
9691: EMPTY
9692: LIST
9693: LIST
9694: LIST
9695: LIST
9696: LIST
9697: LIST
9698: LIST
9699: LIST
9700: DIFF
9701: ST_TO_ADDR
// if not tmp then
9702: LD_VAR 0 1
9706: NOT
9707: IFFALSE 9781
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9709: LD_ADDR_VAR 0 1
9713: PUSH
9714: LD_INT 22
9716: PUSH
9717: LD_INT 7
9719: PUSH
9720: EMPTY
9721: LIST
9722: LIST
9723: PUSH
9724: LD_INT 23
9726: PUSH
9727: LD_INT 1
9729: PUSH
9730: EMPTY
9731: LIST
9732: LIST
9733: PUSH
9734: LD_INT 26
9736: PUSH
9737: LD_INT 2
9739: PUSH
9740: EMPTY
9741: LIST
9742: LIST
9743: PUSH
9744: EMPTY
9745: LIST
9746: LIST
9747: LIST
9748: PPUSH
9749: CALL_OW 69
9753: PUSH
9754: LD_EXP 31
9758: PUSH
9759: LD_EXP 18
9763: PUSH
9764: LD_EXP 29
9768: PUSH
9769: LD_EXP 30
9773: PUSH
9774: EMPTY
9775: LIST
9776: LIST
9777: LIST
9778: LIST
9779: DIFF
9780: ST_TO_ADDR
// if tmp then
9781: LD_VAR 0 1
9785: IFFALSE 9856
// case GetSex ( tmp [ 1 ] ) of sex_male :
9787: LD_VAR 0 1
9791: PUSH
9792: LD_INT 1
9794: ARRAY
9795: PPUSH
9796: CALL_OW 258
9800: PUSH
9801: LD_INT 1
9803: DOUBLE
9804: EQUAL
9805: IFTRUE 9809
9807: GO 9828
9809: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9810: LD_VAR 0 1
9814: PUSH
9815: LD_INT 1
9817: ARRAY
9818: PPUSH
9819: LD_STRING D9-Sol1-1
9821: PPUSH
9822: CALL_OW 88
9826: GO 9856
9828: LD_INT 2
9830: DOUBLE
9831: EQUAL
9832: IFTRUE 9836
9834: GO 9855
9836: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9837: LD_VAR 0 1
9841: PUSH
9842: LD_INT 1
9844: ARRAY
9845: PPUSH
9846: LD_STRING D9-FSol1-1
9848: PPUSH
9849: CALL_OW 88
9853: GO 9856
9855: POP
// if Frank then
9856: LD_EXP 28
9860: IFFALSE 9964
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9862: LD_EXP 58
9866: PPUSH
9867: CALL_OW 250
9871: PPUSH
9872: LD_EXP 58
9876: PPUSH
9877: CALL_OW 251
9881: PPUSH
9882: LD_INT 7
9884: PPUSH
9885: LD_INT 8
9887: PPUSH
9888: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9892: LD_EXP 58
9896: PPUSH
9897: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9901: LD_EXP 28
9905: PPUSH
9906: LD_STRING D9-Frank-1
9908: PPUSH
9909: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9913: LD_EXP 16
9917: PPUSH
9918: LD_STRING D9-JMM-1
9920: PPUSH
9921: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9925: LD_EXP 28
9929: PPUSH
9930: LD_STRING D9-Frank-2
9932: PPUSH
9933: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9937: LD_EXP 58
9941: PPUSH
9942: CALL_OW 250
9946: PPUSH
9947: LD_EXP 58
9951: PPUSH
9952: CALL_OW 251
9956: PPUSH
9957: LD_INT 7
9959: PPUSH
9960: CALL_OW 331
// end ; DialogueOff ;
9964: CALL_OW 7
// end ;
9968: PPOPN 1
9970: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9971: LD_EXP 7
9975: PUSH
9976: LD_OWVAR 1
9980: PUSH
9981: LD_INT 42000
9983: GREATEREQUAL
9984: OR
9985: IFFALSE 11012
9987: GO 9989
9989: DISABLE
9990: LD_INT 0
9992: PPUSH
9993: PPUSH
// begin selected_option := 1 ;
9994: LD_ADDR_VAR 0 2
9998: PUSH
9999: LD_INT 1
10001: ST_TO_ADDR
// wait ( 5 5$00 ) ;
10002: LD_INT 10500
10004: PPUSH
10005: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10009: LD_INT 35
10011: PPUSH
10012: CALL_OW 67
// until not ru_attackers ;
10016: LD_EXP 54
10020: NOT
10021: IFFALSE 10009
// PrepareBurlak ;
10023: CALL 2360 0 0
// repeat wait ( 0 0$2 ) ;
10027: LD_INT 70
10029: PPUSH
10030: CALL_OW 67
// until not HasTask ( Burlak ) ;
10034: LD_EXP 48
10038: PPUSH
10039: CALL_OW 314
10043: NOT
10044: IFFALSE 10027
// InGameOn ;
10046: CALL_OW 8
// DialogueOn ;
10050: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
10054: LD_EXP 51
10058: PPUSH
10059: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
10063: LD_EXP 48
10067: PPUSH
10068: LD_STRING D10-Bur-1
10070: PPUSH
10071: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
10075: LD_EXP 49
10079: PUSH
10080: LD_EXP 49
10084: PPUSH
10085: CALL_OW 255
10089: PUSH
10090: LD_INT 7
10092: EQUAL
10093: AND
10094: IFFALSE 10108
// Say ( Belkov , D10-Bel-1 ) ;
10096: LD_EXP 49
10100: PPUSH
10101: LD_STRING D10-Bel-1
10103: PPUSH
10104: CALL_OW 88
// if Gossudarov then
10108: LD_EXP 34
10112: IFFALSE 10126
// Say ( Gossudarov , D10-Gos-1 ) ;
10114: LD_EXP 34
10118: PPUSH
10119: LD_STRING D10-Gos-1
10121: PPUSH
10122: CALL_OW 88
// if Kirilenkova then
10126: LD_EXP 35
10130: IFFALSE 10144
// Say ( Kirilenkova , D10-Kir-1 ) ;
10132: LD_EXP 35
10136: PPUSH
10137: LD_STRING D10-Kir-1
10139: PPUSH
10140: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10144: CALL 13481 0 0
10148: PPUSH
10149: LD_STRING D10-RSol1-1
10151: PPUSH
10152: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
10156: LD_EXP 48
10160: PPUSH
10161: LD_STRING D10-Bur-2
10163: PPUSH
10164: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
10168: LD_EXP 16
10172: PPUSH
10173: LD_STRING D10-JMM-2
10175: PPUSH
10176: CALL_OW 88
// if Kirilenkova then
10180: LD_EXP 35
10184: IFFALSE 10200
// Say ( Kirilenkova , D10-Kir-2 ) else
10186: LD_EXP 35
10190: PPUSH
10191: LD_STRING D10-Kir-2
10193: PPUSH
10194: CALL_OW 88
10198: GO 10212
// Say ( SolRu , D10-RSol1-2 ) ;
10200: CALL 13481 0 0
10204: PPUSH
10205: LD_STRING D10-RSol1-2
10207: PPUSH
10208: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
10212: LD_EXP 16
10216: PPUSH
10217: LD_STRING D10-JMM-3
10219: PPUSH
10220: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
10224: LD_EXP 48
10228: PPUSH
10229: LD_STRING D10-Bur-3
10231: PPUSH
10232: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
10236: LD_EXP 16
10240: PPUSH
10241: LD_STRING D10-JMM-4
10243: PPUSH
10244: CALL_OW 88
// DialogueOff ;
10248: CALL_OW 7
// InGameOff ;
10252: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
10256: LD_STRING M2
10258: PPUSH
10259: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10263: LD_INT 35
10265: PPUSH
10266: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
10270: LD_INT 22
10272: PUSH
10273: LD_INT 7
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PUSH
10280: LD_INT 91
10282: PUSH
10283: LD_EXP 48
10287: PUSH
10288: LD_INT 8
10290: PUSH
10291: EMPTY
10292: LIST
10293: LIST
10294: LIST
10295: PUSH
10296: EMPTY
10297: LIST
10298: LIST
10299: PPUSH
10300: CALL_OW 69
10304: IFFALSE 10263
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
10306: LD_ADDR_VAR 0 1
10310: PUSH
10311: LD_INT 22
10313: PUSH
10314: LD_INT 4
10316: PUSH
10317: EMPTY
10318: LIST
10319: LIST
10320: PPUSH
10321: CALL_OW 69
10325: PUSH
10326: FOR_IN
10327: IFFALSE 10343
// SetSide ( i , 7 ) ;
10329: LD_VAR 0 1
10333: PPUSH
10334: LD_INT 7
10336: PPUSH
10337: CALL_OW 235
10341: GO 10326
10343: POP
10344: POP
// ChangeMissionObjectives ( M3 ) ;
10345: LD_STRING M3
10347: PPUSH
10348: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10352: LD_INT 35
10354: PPUSH
10355: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
10359: LD_EXP 16
10363: PPUSH
10364: LD_EXP 48
10368: PPUSH
10369: CALL_OW 296
10373: PUSH
10374: LD_INT 8
10376: LESS
10377: IFFALSE 10352
// ComTurnUnit ( JMM , Burlak ) ;
10379: LD_EXP 16
10383: PPUSH
10384: LD_EXP 48
10388: PPUSH
10389: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
10393: LD_EXP 48
10397: PPUSH
10398: LD_EXP 16
10402: PPUSH
10403: CALL_OW 119
// wait ( 0 0$0.3 ) ;
10407: LD_INT 10
10409: PPUSH
10410: CALL_OW 67
// DialogueOn ;
10414: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
10418: LD_EXP 16
10422: PPUSH
10423: LD_STRING D11-JMM-1
10425: PPUSH
10426: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
10430: LD_EXP 48
10434: PPUSH
10435: LD_STRING D11-Bur-1
10437: PPUSH
10438: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
10442: LD_EXP 16
10446: PPUSH
10447: LD_STRING D11-JMM-2
10449: PPUSH
10450: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
10454: LD_EXP 48
10458: PPUSH
10459: LD_STRING D11-Bur-2
10461: PPUSH
10462: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
10466: LD_EXP 16
10470: PPUSH
10471: LD_STRING D11-JMM-3
10473: PPUSH
10474: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
10478: LD_EXP 48
10482: PPUSH
10483: LD_STRING D11-Bur-3
10485: PPUSH
10486: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10490: LD_EXP 16
10494: PPUSH
10495: LD_STRING D11-JMM-4
10497: PPUSH
10498: CALL_OW 88
// if ar_base_spotted then
10502: LD_EXP 8
10506: IFFALSE 10522
// Say ( Burlak , D12-Bur-1 ) else
10508: LD_EXP 48
10512: PPUSH
10513: LD_STRING D12-Bur-1
10515: PPUSH
10516: CALL_OW 88
10520: GO 10561
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10522: LD_INT 7
10524: PPUSH
10525: LD_INT 3
10527: PPUSH
10528: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10532: LD_INT 127
10534: PPUSH
10535: LD_INT 45
10537: PPUSH
10538: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10542: LD_EXP 48
10546: PPUSH
10547: LD_STRING D12-Bur-1a
10549: PPUSH
10550: CALL_OW 88
// dwait ( 0 0$2 ) ;
10554: LD_INT 70
10556: PPUSH
10557: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10561: LD_EXP 48
10565: PPUSH
10566: LD_STRING D12-Bur-1b
10568: PPUSH
10569: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10573: LD_EXP 16
10577: PPUSH
10578: LD_STRING D12-JMM-1
10580: PPUSH
10581: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10585: LD_EXP 48
10589: PPUSH
10590: LD_STRING D12-Bur-2
10592: PPUSH
10593: CALL_OW 88
// if Roth then
10597: LD_EXP 17
10601: IFFALSE 10617
// Say ( Roth , D12-Roth-2 ) else
10603: LD_EXP 17
10607: PPUSH
10608: LD_STRING D12-Roth-2
10610: PPUSH
10611: CALL_OW 88
10615: GO 10629
// Say ( SciRu , D12-RSci1-2 ) ;
10617: CALL 13334 0 0
10621: PPUSH
10622: LD_STRING D12-RSci1-2
10624: PPUSH
10625: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10629: LD_EXP 16
10633: PPUSH
10634: LD_STRING D12-JMM-2
10636: PPUSH
10637: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10641: LD_EXP 48
10645: PPUSH
10646: LD_STRING D12-Bur-3
10648: PPUSH
10649: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10653: LD_EXP 16
10657: PPUSH
10658: LD_STRING D12-JMM-3
10660: PPUSH
10661: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10665: LD_EXP 48
10669: PPUSH
10670: LD_STRING D12-Bur-4
10672: PPUSH
10673: CALL_OW 88
// case Query ( QBase ) of 1 :
10677: LD_STRING QBase
10679: PPUSH
10680: CALL_OW 97
10684: PUSH
10685: LD_INT 1
10687: DOUBLE
10688: EQUAL
10689: IFTRUE 10693
10691: GO 10811
10693: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10694: LD_EXP 16
10698: PPUSH
10699: LD_STRING D13a-JMM-1
10701: PPUSH
10702: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10706: LD_EXP 48
10710: PPUSH
10711: LD_STRING D13a-Bur-1
10713: PPUSH
10714: CALL_OW 88
// if Roth then
10718: LD_EXP 17
10722: IFFALSE 10738
// Say ( Roth , D13a-Roth-1 ) else
10724: LD_EXP 17
10728: PPUSH
10729: LD_STRING D13a-Roth-1
10731: PPUSH
10732: CALL_OW 88
10736: GO 10750
// Say ( SciRu , D13a-RSci1-1 ) ;
10738: CALL 13334 0 0
10742: PPUSH
10743: LD_STRING D13a-RSci1-1
10745: PPUSH
10746: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10750: LD_EXP 16
10754: PPUSH
10755: LD_STRING D13a-JMM-2
10757: PPUSH
10758: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10762: LD_STRING QBaseAgain
10764: PPUSH
10765: CALL_OW 97
10769: PUSH
10770: LD_INT 1
10772: DOUBLE
10773: EQUAL
10774: IFTRUE 10778
10776: GO 10789
10778: POP
// selected_option := 2 ; 2 :
10779: LD_ADDR_VAR 0 2
10783: PUSH
10784: LD_INT 2
10786: ST_TO_ADDR
10787: GO 10809
10789: LD_INT 2
10791: DOUBLE
10792: EQUAL
10793: IFTRUE 10797
10795: GO 10808
10797: POP
// selected_option := 3 ; end ;
10798: LD_ADDR_VAR 0 2
10802: PUSH
10803: LD_INT 3
10805: ST_TO_ADDR
10806: GO 10809
10808: POP
// end ; 2 :
10809: GO 10850
10811: LD_INT 2
10813: DOUBLE
10814: EQUAL
10815: IFTRUE 10819
10817: GO 10830
10819: POP
// selected_option := 2 ; 3 :
10820: LD_ADDR_VAR 0 2
10824: PUSH
10825: LD_INT 2
10827: ST_TO_ADDR
10828: GO 10850
10830: LD_INT 3
10832: DOUBLE
10833: EQUAL
10834: IFTRUE 10838
10836: GO 10849
10838: POP
// selected_option := 3 ; end ;
10839: LD_ADDR_VAR 0 2
10843: PUSH
10844: LD_INT 3
10846: ST_TO_ADDR
10847: GO 10850
10849: POP
// if selected_option = 2 then
10850: LD_VAR 0 2
10854: PUSH
10855: LD_INT 2
10857: EQUAL
10858: IFFALSE 10952
// begin Say ( JMM , D13b-JMM-1 ) ;
10860: LD_EXP 16
10864: PPUSH
10865: LD_STRING D13b-JMM-1
10867: PPUSH
10868: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10872: LD_EXP 48
10876: PPUSH
10877: LD_STRING D13b-Bur-1
10879: PPUSH
10880: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10884: LD_EXP 16
10888: PPUSH
10889: LD_STRING D13b-JMM-2
10891: PPUSH
10892: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10896: LD_EXP 57
10900: PPUSH
10901: LD_STRING D13b-Abd-2
10903: PPUSH
10904: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10908: LD_EXP 16
10912: PPUSH
10913: LD_STRING D13b-JMM-3
10915: PPUSH
10916: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10920: LD_EXP 57
10924: PPUSH
10925: LD_STRING D13b-Abd-3
10927: PPUSH
10928: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10932: LD_EXP 16
10936: PPUSH
10937: LD_STRING D13b-JMM-4
10939: PPUSH
10940: CALL_OW 88
// ar_active_attack := true ;
10944: LD_ADDR_EXP 9
10948: PUSH
10949: LD_INT 1
10951: ST_TO_ADDR
// end ; if selected_option = 3 then
10952: LD_VAR 0 2
10956: PUSH
10957: LD_INT 3
10959: EQUAL
10960: IFFALSE 10986
// begin Say ( JMM , D13c-JMM-1 ) ;
10962: LD_EXP 16
10966: PPUSH
10967: LD_STRING D13c-JMM-1
10969: PPUSH
10970: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10974: LD_EXP 48
10978: PPUSH
10979: LD_STRING D13c-Bur-1
10981: PPUSH
10982: CALL_OW 88
// end ; DialogueOff ;
10986: CALL_OW 7
// if not ar_active_attack then
10990: LD_EXP 9
10994: NOT
10995: IFFALSE 11012
// begin wait ( 6 6$00 ) ;
10997: LD_INT 12600
10999: PPUSH
11000: CALL_OW 67
// ar_active_attack := true ;
11004: LD_ADDR_EXP 9
11008: PUSH
11009: LD_INT 1
11011: ST_TO_ADDR
// end ; end ;
11012: PPOPN 2
11014: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
11015: LD_EXP 48
11019: PPUSH
11020: CALL_OW 305
11024: PUSH
11025: LD_EXP 48
11029: PPUSH
11030: CALL_OW 255
11034: PUSH
11035: LD_INT 7
11037: EQUAL
11038: AND
11039: IFFALSE 11235
11041: GO 11043
11043: DISABLE
11044: LD_INT 0
11046: PPUSH
// begin wait ( 4 4$40 ) ;
11047: LD_INT 9800
11049: PPUSH
11050: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11054: LD_INT 35
11056: PPUSH
11057: CALL_OW 67
// until not ru_attackers ;
11061: LD_EXP 54
11065: NOT
11066: IFFALSE 11054
// PrepareGnyevko ;
11068: CALL 2304 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
11072: LD_EXP 50
11076: PPUSH
11077: LD_INT 124
11079: PPUSH
11080: LD_INT 118
11082: PPUSH
11083: CALL_OW 111
// AddComHold ( Gnyevko ) ;
11087: LD_EXP 50
11091: PPUSH
11092: CALL_OW 200
// time := 0 0$00 ;
11096: LD_ADDR_VAR 0 1
11100: PUSH
11101: LD_INT 0
11103: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11104: LD_INT 35
11106: PPUSH
11107: CALL_OW 67
// time := time + 0 0$1 ;
11111: LD_ADDR_VAR 0 1
11115: PUSH
11116: LD_VAR 0 1
11120: PUSH
11121: LD_INT 35
11123: PLUS
11124: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
11125: LD_EXP 50
11129: PPUSH
11130: LD_INT 124
11132: PPUSH
11133: LD_INT 118
11135: PPUSH
11136: CALL_OW 307
11140: PUSH
11141: LD_VAR 0 1
11145: PUSH
11146: LD_INT 1050
11148: GREATEREQUAL
11149: OR
11150: IFFALSE 11104
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
11152: LD_EXP 50
11156: PPUSH
11157: LD_STRING DBelkov-Gny-1
11159: PPUSH
11160: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
11164: LD_EXP 48
11168: PPUSH
11169: LD_STRING DBelkov-Bur-1a
11171: PPUSH
11172: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11176: LD_INT 35
11178: PPUSH
11179: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
11183: LD_EXP 50
11187: PPUSH
11188: LD_INT 22
11190: PUSH
11191: LD_INT 7
11193: PUSH
11194: EMPTY
11195: LIST
11196: LIST
11197: PPUSH
11198: CALL_OW 69
11202: PPUSH
11203: LD_EXP 50
11207: PPUSH
11208: CALL_OW 74
11212: PPUSH
11213: CALL_OW 296
11217: PUSH
11218: LD_INT 8
11220: LESS
11221: IFFALSE 11176
// SetSide ( Gnyevko , 7 ) ;
11223: LD_EXP 50
11227: PPUSH
11228: LD_INT 7
11230: PPUSH
11231: CALL_OW 235
// end ;
11235: PPOPN 1
11237: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
11238: LD_EXP 48
11242: PPUSH
11243: CALL_OW 255
11247: PUSH
11248: LD_INT 7
11250: EQUAL
11251: IFFALSE 11261
11253: GO 11255
11255: DISABLE
// begin enable ;
11256: ENABLE
// PrepareAmericanAttack ;
11257: CALL 6903 0 0
// end ;
11261: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
11262: LD_INT 22
11264: PUSH
11265: LD_INT 1
11267: PUSH
11268: EMPTY
11269: LIST
11270: LIST
11271: PPUSH
11272: CALL_OW 69
11276: IFFALSE 11460
11278: GO 11280
11280: DISABLE
11281: LD_INT 0
11283: PPUSH
11284: PPUSH
// begin while true do
11285: LD_INT 1
11287: IFFALSE 11344
// begin wait ( 0 0$1 ) ;
11289: LD_INT 35
11291: PPUSH
11292: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
11296: LD_ADDR_VAR 0 2
11300: PUSH
11301: LD_INT 22
11303: PUSH
11304: LD_INT 1
11306: PUSH
11307: EMPTY
11308: LIST
11309: LIST
11310: PPUSH
11311: CALL_OW 69
11315: PPUSH
11316: LD_EXP 16
11320: PPUSH
11321: CALL_OW 74
11325: ST_TO_ADDR
// if See ( 7 , tmp ) then
11326: LD_INT 7
11328: PPUSH
11329: LD_VAR 0 2
11333: PPUSH
11334: CALL_OW 292
11338: IFFALSE 11342
// break ;
11340: GO 11344
// end ;
11342: GO 11285
// DialogueOn ;
11344: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
11348: LD_VAR 0 2
11352: PPUSH
11353: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
11357: LD_VAR 0 2
11361: PPUSH
11362: CALL_OW 250
11366: PPUSH
11367: LD_VAR 0 2
11371: PPUSH
11372: CALL_OW 251
11376: PPUSH
11377: LD_INT 7
11379: PPUSH
11380: LD_INT 8
11382: PPUSH
11383: CALL_OW 330
// if Denis then
11387: LD_EXP 22
11391: IFFALSE 11405
// Say ( Denis , DAmerAttack-Pet-1 ) ;
11393: LD_EXP 22
11397: PPUSH
11398: LD_STRING DAmerAttack-Pet-1
11400: PPUSH
11401: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
11405: LD_EXP 16
11409: PPUSH
11410: LD_STRING DAmerAttack-JMM-1
11412: PPUSH
11413: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
11417: LD_EXP 48
11421: PPUSH
11422: LD_STRING DStop-Bur-1
11424: PPUSH
11425: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
11429: LD_VAR 0 2
11433: PPUSH
11434: CALL_OW 250
11438: PPUSH
11439: LD_VAR 0 2
11443: PPUSH
11444: CALL_OW 251
11448: PPUSH
11449: LD_INT 7
11451: PPUSH
11452: CALL_OW 331
// DialogueOff ;
11456: CALL_OW 7
// end ;
11460: PPOPN 2
11462: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11463: LD_INT 22
11465: PUSH
11466: LD_INT 3
11468: PUSH
11469: EMPTY
11470: LIST
11471: LIST
11472: PUSH
11473: LD_INT 21
11475: PUSH
11476: LD_INT 1
11478: PUSH
11479: EMPTY
11480: LIST
11481: LIST
11482: PUSH
11483: EMPTY
11484: LIST
11485: LIST
11486: PPUSH
11487: CALL_OW 69
11491: PUSH
11492: LD_INT 0
11494: EQUAL
11495: IFFALSE 11537
11497: GO 11499
11499: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11500: LD_STRING M5a
11502: PPUSH
11503: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11507: LD_EXP 16
11511: PPUSH
11512: LD_STRING D8-JMM-1
11514: PPUSH
11515: CALL_OW 88
// if Gossudarov then
11519: LD_EXP 34
11523: IFFALSE 11537
// Say ( Gossudarov , D8-Gos-1 ) ;
11525: LD_EXP 34
11529: PPUSH
11530: LD_STRING D8-Gos-1
11532: PPUSH
11533: CALL_OW 88
// end ;
11537: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11538: LD_INT 22
11540: PUSH
11541: LD_INT 2
11543: PUSH
11544: EMPTY
11545: LIST
11546: LIST
11547: PUSH
11548: LD_INT 21
11550: PUSH
11551: LD_INT 1
11553: PUSH
11554: EMPTY
11555: LIST
11556: LIST
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PPUSH
11562: CALL_OW 69
11566: PUSH
11567: LD_INT 0
11569: EQUAL
11570: IFFALSE 11620
11572: GO 11574
11574: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11575: LD_STRING M4c
11577: PPUSH
11578: CALL_OW 337
// if Roth then
11582: LD_EXP 17
11586: IFFALSE 11602
// Say ( Roth , DStop-Roth-1 ) else
11588: LD_EXP 17
11592: PPUSH
11593: LD_STRING DStop-Roth-1
11595: PPUSH
11596: CALL_OW 88
11600: GO 11620
// if Gossudarov then
11602: LD_EXP 34
11606: IFFALSE 11620
// Say ( Gossudarov , D8-Gos-1a ) ;
11608: LD_EXP 34
11612: PPUSH
11613: LD_STRING D8-Gos-1a
11615: PPUSH
11616: CALL_OW 88
// end ;
11620: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11621: LD_INT 7
11623: PPUSH
11624: LD_INT 1
11626: PPUSH
11627: LD_INT 1
11629: PPUSH
11630: CALL 15013 0 3
11634: PUSH
11635: LD_INT 0
11637: EQUAL
11638: PUSH
11639: LD_INT 7
11641: PPUSH
11642: LD_INT 3
11644: PPUSH
11645: LD_INT 1
11647: PPUSH
11648: CALL 15013 0 3
11652: PUSH
11653: LD_INT 0
11655: EQUAL
11656: AND
11657: IFFALSE 11669
11659: GO 11661
11661: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11662: LD_STRING M1a
11664: PPUSH
11665: CALL_OW 337
// end ;
11669: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
11670: LD_INT 22
11672: PUSH
11673: LD_INT 2
11675: PUSH
11676: EMPTY
11677: LIST
11678: LIST
11679: PUSH
11680: LD_INT 21
11682: PUSH
11683: LD_INT 1
11685: PUSH
11686: EMPTY
11687: LIST
11688: LIST
11689: PUSH
11690: EMPTY
11691: LIST
11692: LIST
11693: PPUSH
11694: CALL_OW 69
11698: PUSH
11699: LD_INT 0
11701: EQUAL
11702: PUSH
11703: LD_INT 22
11705: PUSH
11706: LD_INT 3
11708: PUSH
11709: EMPTY
11710: LIST
11711: LIST
11712: PUSH
11713: LD_INT 21
11715: PUSH
11716: LD_INT 1
11718: PUSH
11719: EMPTY
11720: LIST
11721: LIST
11722: PUSH
11723: EMPTY
11724: LIST
11725: LIST
11726: PPUSH
11727: CALL_OW 69
11731: PUSH
11732: LD_INT 0
11734: EQUAL
11735: AND
11736: PUSH
11737: LD_INT 22
11739: PUSH
11740: LD_INT 1
11742: PUSH
11743: EMPTY
11744: LIST
11745: LIST
11746: PPUSH
11747: CALL_OW 69
11751: PUSH
11752: LD_INT 0
11754: EQUAL
11755: AND
11756: PUSH
11757: LD_INT 7
11759: PPUSH
11760: LD_INT 1
11762: PPUSH
11763: LD_INT 1
11765: PPUSH
11766: CALL 15013 0 3
11770: PUSH
11771: LD_INT 0
11773: EQUAL
11774: AND
11775: PUSH
11776: LD_INT 7
11778: PPUSH
11779: LD_INT 3
11781: PPUSH
11782: LD_INT 1
11784: PPUSH
11785: CALL 15013 0 3
11789: PUSH
11790: LD_INT 0
11792: EQUAL
11793: AND
11794: PUSH
11795: LD_EXP 48
11799: PPUSH
11800: CALL_OW 255
11804: PUSH
11805: LD_INT 7
11807: EQUAL
11808: AND
11809: PUSH
11810: LD_EXP 48
11814: PPUSH
11815: CALL_OW 302
11819: AND
11820: IFFALSE 13331
11822: GO 11824
11824: DISABLE
11825: LD_INT 0
11827: PPUSH
11828: PPUSH
11829: PPUSH
11830: PPUSH
11831: PPUSH
11832: PPUSH
// begin m1 := false ;
11833: LD_ADDR_VAR 0 4
11837: PUSH
11838: LD_INT 0
11840: ST_TO_ADDR
// m2 := false ;
11841: LD_ADDR_VAR 0 5
11845: PUSH
11846: LD_INT 0
11848: ST_TO_ADDR
// m3 := false ;
11849: LD_ADDR_VAR 0 6
11853: PUSH
11854: LD_INT 0
11856: ST_TO_ADDR
// if tick < 40 40$00 then
11857: LD_OWVAR 1
11861: PUSH
11862: LD_INT 84000
11864: LESS
11865: IFFALSE 11874
// SetAchievement ( ACH_ASPEED_17 ) ;
11867: LD_STRING ACH_ASPEED_17
11869: PPUSH
11870: CALL_OW 543
// wait ( 0 0$5 ) ;
11874: LD_INT 175
11876: PPUSH
11877: CALL_OW 67
// if not masha_killed then
11881: LD_EXP 10
11885: NOT
11886: IFFALSE 11908
// begin m1 := true ;
11888: LD_ADDR_VAR 0 4
11892: PUSH
11893: LD_INT 1
11895: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11896: LD_STRING Masha
11898: PPUSH
11899: LD_INT 1
11901: PPUSH
11902: CALL_OW 101
// end else
11906: GO 11919
// AddMedal ( Masha , - 1 ) ;
11908: LD_STRING Masha
11910: PPUSH
11911: LD_INT 1
11913: NEG
11914: PPUSH
11915: CALL_OW 101
// if abdul_escaped then
11919: LD_EXP 13
11923: IFFALSE 11938
// AddMedal ( Abdul , - 1 ) else
11925: LD_STRING Abdul
11927: PPUSH
11928: LD_INT 1
11930: NEG
11931: PPUSH
11932: CALL_OW 101
11936: GO 11956
// begin m2 := true ;
11938: LD_ADDR_VAR 0 5
11942: PUSH
11943: LD_INT 1
11945: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11946: LD_STRING Abdul
11948: PPUSH
11949: LD_INT 1
11951: PPUSH
11952: CALL_OW 101
// end ; if loss_counter = 0 then
11956: LD_EXP 14
11960: PUSH
11961: LD_INT 0
11963: EQUAL
11964: IFFALSE 11986
// begin m3 := true ;
11966: LD_ADDR_VAR 0 6
11970: PUSH
11971: LD_INT 1
11973: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11974: LD_STRING People
11976: PPUSH
11977: LD_INT 2
11979: PPUSH
11980: CALL_OW 101
// end else
11984: GO 12048
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
11986: LD_EXP 14
11990: PUSH
11991: LD_INT 3
11993: PUSH
11994: LD_INT 2
11996: PUSH
11997: LD_INT 2
11999: PUSH
12000: LD_INT 1
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: PUSH
12009: LD_OWVAR 67
12013: ARRAY
12014: LESSEQUAL
12015: IFFALSE 12037
// begin AddMedal ( People , 1 ) ;
12017: LD_STRING People
12019: PPUSH
12020: LD_INT 1
12022: PPUSH
12023: CALL_OW 101
// m3 := true ;
12027: LD_ADDR_VAR 0 6
12031: PUSH
12032: LD_INT 1
12034: ST_TO_ADDR
// end else
12035: GO 12048
// AddMedal ( People , - 1 ) ;
12037: LD_STRING People
12039: PPUSH
12040: LD_INT 1
12042: NEG
12043: PPUSH
12044: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
12048: LD_OWVAR 67
12052: PUSH
12053: LD_INT 3
12055: GREATEREQUAL
12056: PUSH
12057: LD_VAR 0 4
12061: AND
12062: PUSH
12063: LD_VAR 0 5
12067: AND
12068: PUSH
12069: LD_VAR 0 6
12073: AND
12074: IFFALSE 12086
// SetAchievementEX ( ACH_AMER , 17 ) ;
12076: LD_STRING ACH_AMER
12078: PPUSH
12079: LD_INT 17
12081: PPUSH
12082: CALL_OW 564
// GiveMedals ( MAIN ) ;
12086: LD_STRING MAIN
12088: PPUSH
12089: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
12093: LD_ADDR_VAR 0 2
12097: PUSH
12098: LD_INT 22
12100: PUSH
12101: LD_INT 7
12103: PUSH
12104: EMPTY
12105: LIST
12106: LIST
12107: PUSH
12108: LD_INT 50
12110: PUSH
12111: EMPTY
12112: LIST
12113: PUSH
12114: LD_INT 2
12116: PUSH
12117: LD_INT 25
12119: PUSH
12120: LD_INT 1
12122: PUSH
12123: EMPTY
12124: LIST
12125: LIST
12126: PUSH
12127: LD_INT 25
12129: PUSH
12130: LD_INT 2
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: PUSH
12137: LD_INT 25
12139: PUSH
12140: LD_INT 3
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: PUSH
12147: LD_INT 25
12149: PUSH
12150: LD_INT 4
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: PUSH
12157: LD_INT 25
12159: PUSH
12160: LD_INT 5
12162: PUSH
12163: EMPTY
12164: LIST
12165: LIST
12166: PUSH
12167: LD_INT 25
12169: PUSH
12170: LD_INT 8
12172: PUSH
12173: EMPTY
12174: LIST
12175: LIST
12176: PUSH
12177: LD_INT 25
12179: PUSH
12180: LD_INT 9
12182: PUSH
12183: EMPTY
12184: LIST
12185: LIST
12186: PUSH
12187: EMPTY
12188: LIST
12189: LIST
12190: LIST
12191: LIST
12192: LIST
12193: LIST
12194: LIST
12195: LIST
12196: PUSH
12197: EMPTY
12198: LIST
12199: LIST
12200: LIST
12201: PPUSH
12202: CALL_OW 69
12206: ST_TO_ADDR
// RewardPeople ( tmp ) ;
12207: LD_VAR 0 2
12211: PPUSH
12212: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
12216: LD_ADDR_VAR 0 3
12220: PUSH
12221: LD_EXP 16
12225: PUSH
12226: LD_EXP 17
12230: PUSH
12231: LD_EXP 18
12235: PUSH
12236: LD_EXP 19
12240: PUSH
12241: LD_EXP 20
12245: PUSH
12246: LD_EXP 21
12250: PUSH
12251: LD_EXP 22
12255: PUSH
12256: LD_EXP 23
12260: PUSH
12261: LD_EXP 24
12265: PUSH
12266: LD_EXP 25
12270: PUSH
12271: LD_EXP 26
12275: PUSH
12276: LD_EXP 27
12280: PUSH
12281: LD_EXP 28
12285: PUSH
12286: LD_EXP 29
12290: PUSH
12291: LD_EXP 30
12295: PUSH
12296: LD_EXP 31
12300: PUSH
12301: LD_EXP 32
12305: PUSH
12306: LD_EXP 34
12310: PUSH
12311: LD_EXP 35
12315: PUSH
12316: LD_EXP 36
12320: PUSH
12321: LD_EXP 38
12325: PUSH
12326: LD_EXP 39
12330: PUSH
12331: LD_EXP 40
12335: PUSH
12336: LD_EXP 41
12340: PUSH
12341: LD_EXP 42
12345: PUSH
12346: LD_EXP 43
12350: PUSH
12351: LD_EXP 44
12355: PUSH
12356: LD_EXP 45
12360: PUSH
12361: LD_EXP 46
12365: PUSH
12366: LD_EXP 47
12370: PUSH
12371: LD_EXP 48
12375: PUSH
12376: LD_EXP 49
12380: PUSH
12381: LD_EXP 50
12385: PUSH
12386: LD_EXP 33
12390: PUSH
12391: EMPTY
12392: LIST
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: LIST
12398: LIST
12399: LIST
12400: LIST
12401: LIST
12402: LIST
12403: LIST
12404: LIST
12405: LIST
12406: LIST
12407: LIST
12408: LIST
12409: LIST
12410: LIST
12411: LIST
12412: LIST
12413: LIST
12414: LIST
12415: LIST
12416: LIST
12417: LIST
12418: LIST
12419: LIST
12420: LIST
12421: LIST
12422: LIST
12423: LIST
12424: LIST
12425: LIST
12426: ST_TO_ADDR
// if tmp diff tmp2 then
12427: LD_VAR 0 2
12431: PUSH
12432: LD_VAR 0 3
12436: DIFF
12437: IFFALSE 12457
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
12439: LD_VAR 0 2
12443: PUSH
12444: LD_VAR 0 3
12448: DIFF
12449: PPUSH
12450: LD_STRING 13a_others
12452: PPUSH
12453: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
12457: LD_EXP 16
12461: PPUSH
12462: LD_STRING 13a_JMM
12464: PPUSH
12465: CALL_OW 38
// if IsOk ( Mike ) then
12469: LD_EXP 33
12473: PPUSH
12474: CALL_OW 302
12478: IFFALSE 12492
// SaveCharacters ( Mike , 13a_Mike ) ;
12480: LD_EXP 33
12484: PPUSH
12485: LD_STRING 13a_Mike
12487: PPUSH
12488: CALL_OW 38
// if Titov then
12492: LD_EXP 36
12496: IFFALSE 12510
// SaveCharacters ( Titov , 13a_Titov ) ;
12498: LD_EXP 36
12502: PPUSH
12503: LD_STRING 13a_Titov
12505: PPUSH
12506: CALL_OW 38
// if Dolgov then
12510: LD_EXP 38
12514: IFFALSE 12528
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
12516: LD_EXP 38
12520: PPUSH
12521: LD_STRING 13a_Dolgov
12523: PPUSH
12524: CALL_OW 38
// if Petrosyan then
12528: LD_EXP 39
12532: IFFALSE 12546
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
12534: LD_EXP 39
12538: PPUSH
12539: LD_STRING 13a_Petrosyan
12541: PPUSH
12542: CALL_OW 38
// if Scholtze then
12546: LD_EXP 40
12550: IFFALSE 12564
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12552: LD_EXP 40
12556: PPUSH
12557: LD_STRING 13a_Scholtze
12559: PPUSH
12560: CALL_OW 38
// if Oblukov then
12564: LD_EXP 41
12568: IFFALSE 12582
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12570: LD_EXP 41
12574: PPUSH
12575: LD_STRING 13a_Oblukov
12577: PPUSH
12578: CALL_OW 38
// if Kapitsova then
12582: LD_EXP 42
12586: IFFALSE 12600
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
12588: LD_EXP 42
12592: PPUSH
12593: LD_STRING 13a_Kapitsova
12595: PPUSH
12596: CALL_OW 38
// if Lipshchin then
12600: LD_EXP 43
12604: IFFALSE 12618
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
12606: LD_EXP 43
12610: PPUSH
12611: LD_STRING 13a_Lipshchin
12613: PPUSH
12614: CALL_OW 38
// if Petrovova then
12618: LD_EXP 44
12622: IFFALSE 12636
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12624: LD_EXP 44
12628: PPUSH
12629: LD_STRING 13a_Petrovova
12631: PPUSH
12632: CALL_OW 38
// if Kovalyuk then
12636: LD_EXP 45
12640: IFFALSE 12654
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12642: LD_EXP 45
12646: PPUSH
12647: LD_STRING 13a_Kovalyuk
12649: PPUSH
12650: CALL_OW 38
// if Kuzmov then
12654: LD_EXP 46
12658: IFFALSE 12672
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12660: LD_EXP 46
12664: PPUSH
12665: LD_STRING 13a_Kuzmov
12667: PPUSH
12668: CALL_OW 38
// if Karamazov then
12672: LD_EXP 47
12676: IFFALSE 12690
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12678: LD_EXP 47
12682: PPUSH
12683: LD_STRING 13a_Karamazov
12685: PPUSH
12686: CALL_OW 38
// if Burlak then
12690: LD_EXP 48
12694: IFFALSE 12708
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12696: LD_EXP 48
12700: PPUSH
12701: LD_STRING 13a_Burlak
12703: PPUSH
12704: CALL_OW 38
// if Belkov then
12708: LD_EXP 49
12712: IFFALSE 12726
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12714: LD_EXP 49
12718: PPUSH
12719: LD_STRING 13a_Belkov
12721: PPUSH
12722: CALL_OW 38
// if Gnyevko then
12726: LD_EXP 50
12730: IFFALSE 12744
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12732: LD_EXP 50
12736: PPUSH
12737: LD_STRING 13a_Gnyevko
12739: PPUSH
12740: CALL_OW 38
// if Lisa then
12744: LD_EXP 18
12748: IFFALSE 12762
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12750: LD_EXP 18
12754: PPUSH
12755: LD_STRING 13a_Lisa
12757: PPUSH
12758: CALL_OW 38
// if Donaldson then
12762: LD_EXP 19
12766: IFFALSE 12780
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12768: LD_EXP 19
12772: PPUSH
12773: LD_STRING 13a_Donaldson
12775: PPUSH
12776: CALL_OW 38
// if Bobby then
12780: LD_EXP 20
12784: IFFALSE 12798
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12786: LD_EXP 20
12790: PPUSH
12791: LD_STRING 13a_Bobby
12793: PPUSH
12794: CALL_OW 38
// if Cyrus then
12798: LD_EXP 21
12802: IFFALSE 12816
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12804: LD_EXP 21
12808: PPUSH
12809: LD_STRING 13a_Cyrus
12811: PPUSH
12812: CALL_OW 38
// if Denis then
12816: LD_EXP 22
12820: IFFALSE 12834
// SaveCharacters ( Denis , 13a_Denis ) ;
12822: LD_EXP 22
12826: PPUSH
12827: LD_STRING 13a_Denis
12829: PPUSH
12830: CALL_OW 38
// if Brown then
12834: LD_EXP 23
12838: IFFALSE 12852
// SaveCharacters ( Brown , 13a_Brown ) ;
12840: LD_EXP 23
12844: PPUSH
12845: LD_STRING 13a_Brown
12847: PPUSH
12848: CALL_OW 38
// if Gladstone then
12852: LD_EXP 24
12856: IFFALSE 12870
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12858: LD_EXP 24
12862: PPUSH
12863: LD_STRING 13a_Gladstone
12865: PPUSH
12866: CALL_OW 38
// if Houten then
12870: LD_EXP 25
12874: IFFALSE 12888
// SaveCharacters ( Houten , 13a_Houten ) ;
12876: LD_EXP 25
12880: PPUSH
12881: LD_STRING 13a_Houten
12883: PPUSH
12884: CALL_OW 38
// if Cornel then
12888: LD_EXP 26
12892: IFFALSE 12906
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12894: LD_EXP 26
12898: PPUSH
12899: LD_STRING 13a_Cornel
12901: PPUSH
12902: CALL_OW 38
// if Gary then
12906: LD_EXP 27
12910: IFFALSE 12924
// SaveCharacters ( Gary , 13a_Gary ) ;
12912: LD_EXP 27
12916: PPUSH
12917: LD_STRING 13a_Gary
12919: PPUSH
12920: CALL_OW 38
// if Frank then
12924: LD_EXP 28
12928: IFFALSE 12942
// SaveCharacters ( Frank , 13a_Frank ) ;
12930: LD_EXP 28
12934: PPUSH
12935: LD_STRING 13a_Frank
12937: PPUSH
12938: CALL_OW 38
// if Kikuchi then
12942: LD_EXP 29
12946: IFFALSE 12960
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12948: LD_EXP 29
12952: PPUSH
12953: LD_STRING 13a_Kikuchi
12955: PPUSH
12956: CALL_OW 38
// if Simms then
12960: LD_EXP 30
12964: IFFALSE 12978
// SaveCharacters ( Simms , 13a_Simms ) ;
12966: LD_EXP 30
12970: PPUSH
12971: LD_STRING 13a_Simms
12973: PPUSH
12974: CALL_OW 38
// if Joan then
12978: LD_EXP 31
12982: IFFALSE 12996
// SaveCharacters ( Joan , 13a_Joan ) ;
12984: LD_EXP 31
12988: PPUSH
12989: LD_STRING 13a_Joan
12991: PPUSH
12992: CALL_OW 38
// if DeltaDoctor then
12996: LD_EXP 32
13000: IFFALSE 13014
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
13002: LD_EXP 32
13006: PPUSH
13007: LD_STRING 13a_DeltaDoctor
13009: PPUSH
13010: CALL_OW 38
// if Gossudarov then
13014: LD_EXP 34
13018: IFFALSE 13032
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
13020: LD_EXP 34
13024: PPUSH
13025: LD_STRING 13a_Gossudarov
13027: PPUSH
13028: CALL_OW 38
// if Kirilenkova then
13032: LD_EXP 35
13036: IFFALSE 13050
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
13038: LD_EXP 35
13042: PPUSH
13043: LD_STRING 13a_Kirilenkova
13045: PPUSH
13046: CALL_OW 38
// if Roth then
13050: LD_EXP 17
13054: IFFALSE 13068
// SaveCharacters ( Roth , 13a_Roth ) ;
13056: LD_EXP 17
13060: PPUSH
13061: LD_STRING 13a_Roth
13063: PPUSH
13064: CALL_OW 38
// if Masha then
13068: LD_EXP 51
13072: IFFALSE 13127
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
13074: LD_EXP 51
13078: PPUSH
13079: CALL_OW 265
13083: PUSH
13084: LD_EXP 51
13088: PPUSH
13089: CALL_OW 262
13093: PUSH
13094: LD_EXP 51
13098: PPUSH
13099: CALL_OW 263
13103: PUSH
13104: LD_EXP 51
13108: PPUSH
13109: CALL_OW 264
13113: PUSH
13114: EMPTY
13115: LIST
13116: LIST
13117: LIST
13118: LIST
13119: PPUSH
13120: LD_STRING 13a_Masha
13122: PPUSH
13123: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
13127: LD_ADDR_VAR 0 2
13131: PUSH
13132: LD_INT 21
13134: PUSH
13135: LD_INT 3
13137: PUSH
13138: EMPTY
13139: LIST
13140: LIST
13141: PPUSH
13142: CALL_OW 69
13146: ST_TO_ADDR
// tmp2 := [ ] ;
13147: LD_ADDR_VAR 0 3
13151: PUSH
13152: EMPTY
13153: ST_TO_ADDR
// if tmp then
13154: LD_VAR 0 2
13158: IFFALSE 13309
// for i in tmp do
13160: LD_ADDR_VAR 0 1
13164: PUSH
13165: LD_VAR 0 2
13169: PUSH
13170: FOR_IN
13171: IFFALSE 13307
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
13173: LD_ADDR_VAR 0 3
13177: PUSH
13178: LD_VAR 0 3
13182: PUSH
13183: LD_VAR 0 1
13187: PPUSH
13188: CALL_OW 255
13192: PUSH
13193: LD_VAR 0 1
13197: PPUSH
13198: CALL_OW 248
13202: PUSH
13203: LD_VAR 0 1
13207: PPUSH
13208: CALL_OW 266
13212: PUSH
13213: LD_VAR 0 1
13217: PPUSH
13218: CALL_OW 250
13222: PUSH
13223: LD_VAR 0 1
13227: PPUSH
13228: CALL_OW 251
13232: PUSH
13233: LD_VAR 0 1
13237: PPUSH
13238: CALL_OW 254
13242: PUSH
13243: LD_VAR 0 1
13247: PPUSH
13248: CALL_OW 267
13252: PUSH
13253: LD_VAR 0 1
13257: PPUSH
13258: LD_INT 1
13260: PPUSH
13261: CALL_OW 268
13265: PUSH
13266: LD_VAR 0 1
13270: PPUSH
13271: LD_INT 2
13273: PPUSH
13274: CALL_OW 268
13278: PUSH
13279: LD_VAR 0 1
13283: PPUSH
13284: CALL_OW 269
13288: PUSH
13289: EMPTY
13290: LIST
13291: LIST
13292: LIST
13293: LIST
13294: LIST
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: LIST
13300: PUSH
13301: EMPTY
13302: LIST
13303: ADD
13304: ST_TO_ADDR
13305: GO 13170
13307: POP
13308: POP
// if tmp2 then
13309: LD_VAR 0 3
13313: IFFALSE 13327
// SaveVariable ( tmp2 , 13a_buildings ) ;
13315: LD_VAR 0 3
13319: PPUSH
13320: LD_STRING 13a_buildings
13322: PPUSH
13323: CALL_OW 39
// YouWin ;
13327: CALL_OW 103
// end ;
13331: PPOPN 6
13333: END
// export function SciRu ; var tmp , t ; begin
13334: LD_INT 0
13336: PPUSH
13337: PPUSH
13338: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13339: LD_ADDR_VAR 0 3
13343: PUSH
13344: LD_EXP 34
13348: PUSH
13349: LD_EXP 48
13353: PUSH
13354: LD_EXP 36
13358: PUSH
13359: LD_EXP 49
13363: PUSH
13364: LD_EXP 50
13368: PUSH
13369: LD_EXP 39
13373: PUSH
13374: LD_EXP 40
13378: PUSH
13379: LD_EXP 38
13383: PUSH
13384: EMPTY
13385: LIST
13386: LIST
13387: LIST
13388: LIST
13389: LIST
13390: LIST
13391: LIST
13392: LIST
13393: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
13394: LD_ADDR_VAR 0 2
13398: PUSH
13399: LD_INT 22
13401: PUSH
13402: LD_INT 7
13404: PUSH
13405: EMPTY
13406: LIST
13407: LIST
13408: PUSH
13409: LD_INT 23
13411: PUSH
13412: LD_INT 3
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: PUSH
13419: LD_INT 25
13421: PUSH
13422: LD_INT 4
13424: PUSH
13425: EMPTY
13426: LIST
13427: LIST
13428: PUSH
13429: LD_INT 26
13431: PUSH
13432: LD_INT 1
13434: PUSH
13435: EMPTY
13436: LIST
13437: LIST
13438: PUSH
13439: EMPTY
13440: LIST
13441: LIST
13442: LIST
13443: LIST
13444: PPUSH
13445: CALL_OW 69
13449: PUSH
13450: LD_VAR 0 3
13454: DIFF
13455: ST_TO_ADDR
// if tmp then
13456: LD_VAR 0 2
13460: IFFALSE 13476
// result := tmp [ 1 ] ;
13462: LD_ADDR_VAR 0 1
13466: PUSH
13467: LD_VAR 0 2
13471: PUSH
13472: LD_INT 1
13474: ARRAY
13475: ST_TO_ADDR
// end ;
13476: LD_VAR 0 1
13480: RET
// export function SolRu ; var tmp , t ; begin
13481: LD_INT 0
13483: PPUSH
13484: PPUSH
13485: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13486: LD_ADDR_VAR 0 3
13490: PUSH
13491: LD_EXP 34
13495: PUSH
13496: LD_EXP 48
13500: PUSH
13501: LD_EXP 36
13505: PUSH
13506: LD_EXP 49
13510: PUSH
13511: LD_EXP 50
13515: PUSH
13516: LD_EXP 39
13520: PUSH
13521: LD_EXP 40
13525: PUSH
13526: LD_EXP 38
13530: PUSH
13531: EMPTY
13532: LIST
13533: LIST
13534: LIST
13535: LIST
13536: LIST
13537: LIST
13538: LIST
13539: LIST
13540: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
13541: LD_ADDR_VAR 0 2
13545: PUSH
13546: LD_INT 22
13548: PUSH
13549: LD_INT 7
13551: PUSH
13552: EMPTY
13553: LIST
13554: LIST
13555: PUSH
13556: LD_INT 23
13558: PUSH
13559: LD_INT 3
13561: PUSH
13562: EMPTY
13563: LIST
13564: LIST
13565: PUSH
13566: LD_INT 25
13568: PUSH
13569: LD_INT 1
13571: PUSH
13572: EMPTY
13573: LIST
13574: LIST
13575: PUSH
13576: LD_INT 26
13578: PUSH
13579: LD_INT 1
13581: PUSH
13582: EMPTY
13583: LIST
13584: LIST
13585: PUSH
13586: EMPTY
13587: LIST
13588: LIST
13589: LIST
13590: LIST
13591: PPUSH
13592: CALL_OW 69
13596: PUSH
13597: LD_VAR 0 3
13601: DIFF
13602: ST_TO_ADDR
// if tmp then
13603: LD_VAR 0 2
13607: IFFALSE 13623
// result := tmp [ 1 ] ;
13609: LD_ADDR_VAR 0 1
13613: PUSH
13614: LD_VAR 0 2
13618: PUSH
13619: LD_INT 1
13621: ARRAY
13622: ST_TO_ADDR
// end ; end_of_file
13623: LD_VAR 0 1
13627: RET
// export function CustomEvent ( event ) ; begin
13628: LD_INT 0
13630: PPUSH
// end ;
13631: LD_VAR 0 2
13635: RET
// on UnitDestroyed ( un ) do var i , side ;
13636: LD_INT 0
13638: PPUSH
13639: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
13640: LD_VAR 0 1
13644: PPUSH
13645: CALL 102875 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13649: LD_VAR 0 1
13653: PUSH
13654: LD_INT 22
13656: PUSH
13657: LD_INT 7
13659: PUSH
13660: EMPTY
13661: LIST
13662: LIST
13663: PUSH
13664: LD_INT 2
13666: PUSH
13667: LD_INT 25
13669: PUSH
13670: LD_INT 1
13672: PUSH
13673: EMPTY
13674: LIST
13675: LIST
13676: PUSH
13677: LD_INT 25
13679: PUSH
13680: LD_INT 2
13682: PUSH
13683: EMPTY
13684: LIST
13685: LIST
13686: PUSH
13687: LD_INT 25
13689: PUSH
13690: LD_INT 3
13692: PUSH
13693: EMPTY
13694: LIST
13695: LIST
13696: PUSH
13697: LD_INT 25
13699: PUSH
13700: LD_INT 4
13702: PUSH
13703: EMPTY
13704: LIST
13705: LIST
13706: PUSH
13707: LD_INT 25
13709: PUSH
13710: LD_INT 5
13712: PUSH
13713: EMPTY
13714: LIST
13715: LIST
13716: PUSH
13717: LD_INT 25
13719: PUSH
13720: LD_INT 8
13722: PUSH
13723: EMPTY
13724: LIST
13725: LIST
13726: PUSH
13727: LD_INT 25
13729: PUSH
13730: LD_INT 9
13732: PUSH
13733: EMPTY
13734: LIST
13735: LIST
13736: PUSH
13737: EMPTY
13738: LIST
13739: LIST
13740: LIST
13741: LIST
13742: LIST
13743: LIST
13744: LIST
13745: LIST
13746: PUSH
13747: EMPTY
13748: LIST
13749: LIST
13750: PPUSH
13751: CALL_OW 69
13755: IN
13756: IFFALSE 13772
// loss_counter := loss_counter + 1 ;
13758: LD_ADDR_EXP 14
13762: PUSH
13763: LD_EXP 14
13767: PUSH
13768: LD_INT 1
13770: PLUS
13771: ST_TO_ADDR
// if un = Abdul then
13772: LD_VAR 0 1
13776: PUSH
13777: LD_EXP 57
13781: EQUAL
13782: IFFALSE 13792
// abdul_escaped := false ;
13784: LD_ADDR_EXP 13
13788: PUSH
13789: LD_INT 0
13791: ST_TO_ADDR
// if un in ru_attackers then
13792: LD_VAR 0 1
13796: PUSH
13797: LD_EXP 54
13801: IN
13802: IFFALSE 13820
// ru_attackers := ru_attackers diff un ;
13804: LD_ADDR_EXP 54
13808: PUSH
13809: LD_EXP 54
13813: PUSH
13814: LD_VAR 0 1
13818: DIFF
13819: ST_TO_ADDR
// if un in ar_attackers then
13820: LD_VAR 0 1
13824: PUSH
13825: LD_EXP 11
13829: IN
13830: IFFALSE 13848
// ar_attackers := ar_attackers diff un ;
13832: LD_ADDR_EXP 11
13836: PUSH
13837: LD_EXP 11
13841: PUSH
13842: LD_VAR 0 1
13846: DIFF
13847: ST_TO_ADDR
// if un = JMM then
13848: LD_VAR 0 1
13852: PUSH
13853: LD_EXP 16
13857: EQUAL
13858: IFFALSE 13869
// begin YouLost ( JMM ) ;
13860: LD_STRING JMM
13862: PPUSH
13863: CALL_OW 104
// exit ;
13867: GO 13966
// end ; if un = Burlak then
13869: LD_VAR 0 1
13873: PUSH
13874: LD_EXP 48
13878: EQUAL
13879: IFFALSE 13890
// begin YouLost ( Burlak ) ;
13881: LD_STRING Burlak
13883: PPUSH
13884: CALL_OW 104
// exit ;
13888: GO 13966
// end ; if un = freedom then
13890: LD_VAR 0 1
13894: PUSH
13895: LD_EXP 3
13899: EQUAL
13900: IFFALSE 13911
// begin YouLost ( Destroyed ) ;
13902: LD_STRING Destroyed
13904: PPUSH
13905: CALL_OW 104
// exit ;
13909: GO 13966
// end ; if un = Masha then
13911: LD_VAR 0 1
13915: PUSH
13916: LD_EXP 51
13920: EQUAL
13921: IFFALSE 13938
// begin ChangeMissionObjectives ( M4b ) ;
13923: LD_STRING M4b
13925: PPUSH
13926: CALL_OW 337
// masha_killed := true ;
13930: LD_ADDR_EXP 10
13934: PUSH
13935: LD_INT 1
13937: ST_TO_ADDR
// end ; if un = Mastodont then
13938: LD_VAR 0 1
13942: PUSH
13943: LD_EXP 58
13947: EQUAL
13948: IFFALSE 13957
// ChangeMissionObjectives ( M4a ) ;
13950: LD_STRING M4a
13952: PPUSH
13953: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13957: LD_VAR 0 1
13961: PPUSH
13962: CALL 84097 0 1
// end ;
13966: PPOPN 3
13968: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13969: LD_VAR 0 1
13973: PPUSH
13974: LD_VAR 0 2
13978: PPUSH
13979: CALL 86429 0 2
// end ;
13983: PPOPN 2
13985: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13986: LD_VAR 0 1
13990: PPUSH
13991: CALL 85497 0 1
// end ;
13995: PPOPN 1
13997: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13998: LD_VAR 0 1
14002: PUSH
14003: LD_INT 22
14005: PUSH
14006: LD_INT 7
14008: PUSH
14009: EMPTY
14010: LIST
14011: LIST
14012: PUSH
14013: LD_INT 30
14015: PUSH
14016: LD_INT 0
14018: PUSH
14019: EMPTY
14020: LIST
14021: LIST
14022: PUSH
14023: EMPTY
14024: LIST
14025: LIST
14026: PPUSH
14027: CALL_OW 69
14031: IN
14032: IFFALSE 14071
// begin SetBName ( building , freedom ) ;
14034: LD_VAR 0 1
14038: PPUSH
14039: LD_STRING freedom
14041: PPUSH
14042: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
14046: LD_INT 0
14048: PPUSH
14049: LD_INT 7
14051: PPUSH
14052: LD_INT 0
14054: PPUSH
14055: CALL_OW 324
// freedom := building ;
14059: LD_ADDR_EXP 3
14063: PUSH
14064: LD_VAR 0 1
14068: ST_TO_ADDR
// exit ;
14069: GO 14137
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
14071: LD_VAR 0 1
14075: PUSH
14076: LD_INT 22
14078: PUSH
14079: LD_INT 7
14081: PUSH
14082: EMPTY
14083: LIST
14084: LIST
14085: PUSH
14086: LD_INT 23
14088: PUSH
14089: LD_INT 3
14091: PUSH
14092: EMPTY
14093: LIST
14094: LIST
14095: PUSH
14096: LD_INT 30
14098: PUSH
14099: LD_INT 6
14101: PUSH
14102: EMPTY
14103: LIST
14104: LIST
14105: PUSH
14106: EMPTY
14107: LIST
14108: LIST
14109: LIST
14110: PPUSH
14111: CALL_OW 69
14115: IN
14116: IFFALSE 14128
// begin ru_lab_builded := true ;
14118: LD_ADDR_EXP 5
14122: PUSH
14123: LD_INT 1
14125: ST_TO_ADDR
// exit ;
14126: GO 14137
// end ; MCE_BuildingComplete ( building ) ;
14128: LD_VAR 0 1
14132: PPUSH
14133: CALL 85738 0 1
// end ;
14137: PPOPN 1
14139: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
14140: LD_VAR 0 1
14144: PPUSH
14145: LD_VAR 0 2
14149: PPUSH
14150: CALL 83793 0 2
// end ;
14154: PPOPN 2
14156: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
14157: LD_VAR 0 1
14161: PPUSH
14162: LD_VAR 0 2
14166: PPUSH
14167: LD_VAR 0 3
14171: PPUSH
14172: LD_VAR 0 4
14176: PPUSH
14177: LD_VAR 0 5
14181: PPUSH
14182: CALL 83413 0 5
// end ;
14186: PPOPN 5
14188: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
14189: LD_VAR 0 1
14193: PPUSH
14194: LD_VAR 0 2
14198: PPUSH
14199: CALL 102995 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
14203: LD_VAR 0 1
14207: PPUSH
14208: LD_VAR 0 2
14212: PPUSH
14213: CALL 82966 0 2
// end ;
14217: PPOPN 2
14219: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
14220: LD_VAR 0 1
14224: PPUSH
14225: CALL_OW 263
14229: PUSH
14230: LD_INT 3
14232: EQUAL
14233: PUSH
14234: LD_VAR 0 2
14238: PPUSH
14239: CALL_OW 263
14243: PUSH
14244: LD_INT 3
14246: EQUAL
14247: OR
14248: IFFALSE 14264
// hack_counter := hack_counter + 1 ;
14250: LD_ADDR_EXP 15
14254: PUSH
14255: LD_EXP 15
14259: PUSH
14260: LD_INT 1
14262: PLUS
14263: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14264: LD_VAR 0 1
14268: PPUSH
14269: LD_VAR 0 2
14273: PPUSH
14274: LD_VAR 0 3
14278: PPUSH
14279: LD_VAR 0 4
14283: PPUSH
14284: CALL 82804 0 4
// end ;
14288: PPOPN 4
14290: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14291: LD_VAR 0 1
14295: PPUSH
14296: LD_VAR 0 2
14300: PPUSH
14301: LD_VAR 0 3
14305: PPUSH
14306: CALL 82579 0 3
// end ;
14310: PPOPN 3
14312: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14313: LD_VAR 0 1
14317: PPUSH
14318: LD_VAR 0 2
14322: PPUSH
14323: CALL 82464 0 2
// end ;
14327: PPOPN 2
14329: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14330: LD_VAR 0 1
14334: PPUSH
14335: LD_VAR 0 2
14339: PPUSH
14340: CALL 86724 0 2
// end ;
14344: PPOPN 2
14346: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14347: LD_VAR 0 1
14351: PPUSH
14352: LD_VAR 0 2
14356: PPUSH
14357: LD_VAR 0 3
14361: PPUSH
14362: LD_VAR 0 4
14366: PPUSH
14367: CALL 86940 0 4
// end ;
14371: PPOPN 4
14373: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14374: LD_VAR 0 1
14378: PPUSH
14379: LD_VAR 0 2
14383: PPUSH
14384: CALL 82273 0 2
// end ;
14388: PPOPN 2
14390: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
14391: LD_VAR 0 1
14395: PPUSH
14396: CALL 102979 0 1
// end ; end_of_file
14400: PPOPN 1
14402: END
// every 0 0$30 do var cr , time ;
14403: GO 14405
14405: DISABLE
14406: LD_INT 0
14408: PPUSH
14409: PPUSH
// begin time := 0 0$20 ;
14410: LD_ADDR_VAR 0 2
14414: PUSH
14415: LD_INT 700
14417: ST_TO_ADDR
// while game do
14418: LD_EXP 2
14422: IFFALSE 14525
// begin wait ( time ) ;
14424: LD_VAR 0 2
14428: PPUSH
14429: CALL_OW 67
// if tick > 2 2$00 then
14433: LD_OWVAR 1
14437: PUSH
14438: LD_INT 4200
14440: GREATER
14441: IFFALSE 14478
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14443: LD_ADDR_VAR 0 2
14447: PUSH
14448: LD_VAR 0 2
14452: PUSH
14453: LD_INT 140
14455: PUSH
14456: LD_INT 140
14458: PUSH
14459: LD_INT 210
14461: PUSH
14462: LD_INT 280
14464: PUSH
14465: EMPTY
14466: LIST
14467: LIST
14468: LIST
14469: LIST
14470: PUSH
14471: LD_OWVAR 67
14475: ARRAY
14476: PLUS
14477: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
14478: LD_INT 1
14480: PPUSH
14481: LD_INT 5
14483: PPUSH
14484: CALL_OW 12
14488: PPUSH
14489: LD_INT 70
14491: PPUSH
14492: LD_INT 49
14494: PPUSH
14495: LD_INT 25
14497: PPUSH
14498: LD_INT 1
14500: PPUSH
14501: CALL_OW 56
// if time > 3 3$00 then
14505: LD_VAR 0 2
14509: PUSH
14510: LD_INT 6300
14512: GREATER
14513: IFFALSE 14523
// time := 0 0$30 ;
14515: LD_ADDR_VAR 0 2
14519: PUSH
14520: LD_INT 1050
14522: ST_TO_ADDR
// end ;
14523: GO 14418
// end ;
14525: PPOPN 2
14527: END
// every 0 0$30 do var cr , time ;
14528: GO 14530
14530: DISABLE
14531: LD_INT 0
14533: PPUSH
14534: PPUSH
// begin time := 0 0$20 ;
14535: LD_ADDR_VAR 0 2
14539: PUSH
14540: LD_INT 700
14542: ST_TO_ADDR
// while game do
14543: LD_EXP 2
14547: IFFALSE 14640
// begin wait ( time ) ;
14549: LD_VAR 0 2
14553: PPUSH
14554: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14558: LD_ADDR_VAR 0 2
14562: PUSH
14563: LD_VAR 0 2
14567: PUSH
14568: LD_INT 140
14570: PUSH
14571: LD_INT 175
14573: PUSH
14574: LD_INT 210
14576: PUSH
14577: LD_INT 280
14579: PUSH
14580: EMPTY
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: PUSH
14586: LD_OWVAR 67
14590: ARRAY
14591: PLUS
14592: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
14593: LD_INT 3
14595: PPUSH
14596: LD_INT 5
14598: PPUSH
14599: CALL_OW 12
14603: PPUSH
14604: LD_INT 26
14606: PPUSH
14607: LD_INT 9
14609: PPUSH
14610: LD_INT 30
14612: PPUSH
14613: LD_INT 1
14615: PPUSH
14616: CALL_OW 56
// if time > 3 3$00 then
14620: LD_VAR 0 2
14624: PUSH
14625: LD_INT 6300
14627: GREATER
14628: IFFALSE 14638
// time := 0 0$20 ;
14630: LD_ADDR_VAR 0 2
14634: PUSH
14635: LD_INT 700
14637: ST_TO_ADDR
// end ;
14638: GO 14543
// end ;
14640: PPOPN 2
14642: END
// every 0 0$30 do var cr , time ;
14643: GO 14645
14645: DISABLE
14646: LD_INT 0
14648: PPUSH
14649: PPUSH
// begin time := 0 0$20 ;
14650: LD_ADDR_VAR 0 2
14654: PUSH
14655: LD_INT 700
14657: ST_TO_ADDR
// while game do
14658: LD_EXP 2
14662: IFFALSE 14791
// begin wait ( time ) ;
14664: LD_VAR 0 2
14668: PPUSH
14669: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
14673: LD_ADDR_VAR 0 2
14677: PUSH
14678: LD_VAR 0 2
14682: PUSH
14683: LD_INT 175
14685: PUSH
14686: LD_INT 210
14688: PUSH
14689: LD_INT 280
14691: PUSH
14692: LD_INT 350
14694: PUSH
14695: EMPTY
14696: LIST
14697: LIST
14698: LIST
14699: LIST
14700: PUSH
14701: LD_OWVAR 67
14705: ARRAY
14706: PLUS
14707: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14708: LD_INT 1
14710: PPUSH
14711: LD_INT 5
14713: PPUSH
14714: CALL_OW 12
14718: PPUSH
14719: LD_INT 179
14721: PPUSH
14722: LD_INT 101
14724: PPUSH
14725: LD_INT 20
14727: PPUSH
14728: LD_INT 1
14730: PPUSH
14731: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14735: LD_INT 350
14737: PPUSH
14738: LD_INT 525
14740: PPUSH
14741: CALL_OW 12
14745: PPUSH
14746: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14750: LD_INT 1
14752: PPUSH
14753: LD_INT 5
14755: PPUSH
14756: CALL_OW 12
14760: PPUSH
14761: LD_INT 9
14763: PPUSH
14764: LD_INT 1
14766: PPUSH
14767: CALL_OW 55
// if time > 4 4$00 then
14771: LD_VAR 0 2
14775: PUSH
14776: LD_INT 8400
14778: GREATER
14779: IFFALSE 14789
// time := 0 0$30 ;
14781: LD_ADDR_VAR 0 2
14785: PUSH
14786: LD_INT 1050
14788: ST_TO_ADDR
// end ;
14789: GO 14658
// end ;
14791: PPOPN 2
14793: END
// every 0 0$30 do var cr , time ;
14794: GO 14796
14796: DISABLE
14797: LD_INT 0
14799: PPUSH
14800: PPUSH
// begin time := 0 0$10 ;
14801: LD_ADDR_VAR 0 2
14805: PUSH
14806: LD_INT 350
14808: ST_TO_ADDR
// while game do
14809: LD_EXP 2
14813: IFFALSE 14947
// begin wait ( time ) ;
14815: LD_VAR 0 2
14819: PPUSH
14820: CALL_OW 67
// time := time + 0 0$10 ;
14824: LD_ADDR_VAR 0 2
14828: PUSH
14829: LD_VAR 0 2
14833: PUSH
14834: LD_INT 350
14836: PLUS
14837: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14838: LD_INT 1
14840: PPUSH
14841: LD_INT 5
14843: PPUSH
14844: CALL_OW 12
14848: PPUSH
14849: LD_INT 11
14851: PPUSH
14852: LD_INT 1
14854: PPUSH
14855: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14859: LD_ADDR_VAR 0 1
14863: PUSH
14864: LD_INT 1
14866: PPUSH
14867: LD_INT 3
14869: PPUSH
14870: CALL_OW 12
14874: ST_TO_ADDR
// if cr = 1 then
14875: LD_VAR 0 1
14879: PUSH
14880: LD_INT 1
14882: EQUAL
14883: IFFALSE 14927
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14885: LD_INT 700
14887: PPUSH
14888: LD_INT 1575
14890: PPUSH
14891: CALL_OW 12
14895: PPUSH
14896: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14900: LD_INT 1
14902: PPUSH
14903: LD_INT 5
14905: PPUSH
14906: CALL_OW 12
14910: PPUSH
14911: LD_INT 34
14913: PPUSH
14914: LD_INT 50
14916: PPUSH
14917: LD_INT 7
14919: PPUSH
14920: LD_INT 1
14922: PPUSH
14923: CALL_OW 56
// end ; if time > 4 4$00 then
14927: LD_VAR 0 2
14931: PUSH
14932: LD_INT 8400
14934: GREATER
14935: IFFALSE 14945
// time := 0 0$40 ;
14937: LD_ADDR_VAR 0 2
14941: PUSH
14942: LD_INT 1400
14944: ST_TO_ADDR
// end ;
14945: GO 14809
// end ; end_of_file
14947: PPOPN 2
14949: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14950: LD_INT 0
14952: PPUSH
14953: PPUSH
// if exist_mode then
14954: LD_VAR 0 2
14958: IFFALSE 14983
// unit := CreateCharacter ( prefix & ident ) else
14960: LD_ADDR_VAR 0 5
14964: PUSH
14965: LD_VAR 0 3
14969: PUSH
14970: LD_VAR 0 1
14974: STR
14975: PPUSH
14976: CALL_OW 34
14980: ST_TO_ADDR
14981: GO 14998
// unit := NewCharacter ( ident ) ;
14983: LD_ADDR_VAR 0 5
14987: PUSH
14988: LD_VAR 0 1
14992: PPUSH
14993: CALL_OW 25
14997: ST_TO_ADDR
// result := unit ;
14998: LD_ADDR_VAR 0 4
15002: PUSH
15003: LD_VAR 0 5
15007: ST_TO_ADDR
// end ;
15008: LD_VAR 0 4
15012: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
15013: LD_INT 0
15015: PPUSH
15016: PPUSH
// if not side or not nation then
15017: LD_VAR 0 1
15021: NOT
15022: PUSH
15023: LD_VAR 0 2
15027: NOT
15028: OR
15029: IFFALSE 15033
// exit ;
15031: GO 15801
// case nation of nation_american :
15033: LD_VAR 0 2
15037: PUSH
15038: LD_INT 1
15040: DOUBLE
15041: EQUAL
15042: IFTRUE 15046
15044: GO 15260
15046: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
15047: LD_ADDR_VAR 0 4
15051: PUSH
15052: LD_INT 35
15054: PUSH
15055: LD_INT 45
15057: PUSH
15058: LD_INT 46
15060: PUSH
15061: LD_INT 47
15063: PUSH
15064: LD_INT 82
15066: PUSH
15067: LD_INT 83
15069: PUSH
15070: LD_INT 84
15072: PUSH
15073: LD_INT 85
15075: PUSH
15076: LD_INT 86
15078: PUSH
15079: LD_INT 1
15081: PUSH
15082: LD_INT 2
15084: PUSH
15085: LD_INT 6
15087: PUSH
15088: LD_INT 15
15090: PUSH
15091: LD_INT 16
15093: PUSH
15094: LD_INT 7
15096: PUSH
15097: LD_INT 12
15099: PUSH
15100: LD_INT 13
15102: PUSH
15103: LD_INT 10
15105: PUSH
15106: LD_INT 14
15108: PUSH
15109: LD_INT 20
15111: PUSH
15112: LD_INT 21
15114: PUSH
15115: LD_INT 22
15117: PUSH
15118: LD_INT 25
15120: PUSH
15121: LD_INT 32
15123: PUSH
15124: LD_INT 27
15126: PUSH
15127: LD_INT 36
15129: PUSH
15130: LD_INT 69
15132: PUSH
15133: LD_INT 39
15135: PUSH
15136: LD_INT 34
15138: PUSH
15139: LD_INT 40
15141: PUSH
15142: LD_INT 48
15144: PUSH
15145: LD_INT 49
15147: PUSH
15148: LD_INT 50
15150: PUSH
15151: LD_INT 51
15153: PUSH
15154: LD_INT 52
15156: PUSH
15157: LD_INT 53
15159: PUSH
15160: LD_INT 54
15162: PUSH
15163: LD_INT 55
15165: PUSH
15166: LD_INT 56
15168: PUSH
15169: LD_INT 57
15171: PUSH
15172: LD_INT 58
15174: PUSH
15175: LD_INT 59
15177: PUSH
15178: LD_INT 60
15180: PUSH
15181: LD_INT 61
15183: PUSH
15184: LD_INT 62
15186: PUSH
15187: LD_INT 80
15189: PUSH
15190: LD_INT 82
15192: PUSH
15193: LD_INT 83
15195: PUSH
15196: LD_INT 84
15198: PUSH
15199: LD_INT 85
15201: PUSH
15202: LD_INT 86
15204: PUSH
15205: EMPTY
15206: LIST
15207: LIST
15208: LIST
15209: LIST
15210: LIST
15211: LIST
15212: LIST
15213: LIST
15214: LIST
15215: LIST
15216: LIST
15217: LIST
15218: LIST
15219: LIST
15220: LIST
15221: LIST
15222: LIST
15223: LIST
15224: LIST
15225: LIST
15226: LIST
15227: LIST
15228: LIST
15229: LIST
15230: LIST
15231: LIST
15232: LIST
15233: LIST
15234: LIST
15235: LIST
15236: LIST
15237: LIST
15238: LIST
15239: LIST
15240: LIST
15241: LIST
15242: LIST
15243: LIST
15244: LIST
15245: LIST
15246: LIST
15247: LIST
15248: LIST
15249: LIST
15250: LIST
15251: LIST
15252: LIST
15253: LIST
15254: LIST
15255: LIST
15256: LIST
15257: ST_TO_ADDR
15258: GO 15725
15260: LD_INT 2
15262: DOUBLE
15263: EQUAL
15264: IFTRUE 15268
15266: GO 15494
15268: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
15269: LD_ADDR_VAR 0 4
15273: PUSH
15274: LD_INT 35
15276: PUSH
15277: LD_INT 45
15279: PUSH
15280: LD_INT 46
15282: PUSH
15283: LD_INT 47
15285: PUSH
15286: LD_INT 82
15288: PUSH
15289: LD_INT 83
15291: PUSH
15292: LD_INT 84
15294: PUSH
15295: LD_INT 85
15297: PUSH
15298: LD_INT 87
15300: PUSH
15301: LD_INT 70
15303: PUSH
15304: LD_INT 1
15306: PUSH
15307: LD_INT 11
15309: PUSH
15310: LD_INT 3
15312: PUSH
15313: LD_INT 4
15315: PUSH
15316: LD_INT 5
15318: PUSH
15319: LD_INT 6
15321: PUSH
15322: LD_INT 15
15324: PUSH
15325: LD_INT 18
15327: PUSH
15328: LD_INT 7
15330: PUSH
15331: LD_INT 17
15333: PUSH
15334: LD_INT 8
15336: PUSH
15337: LD_INT 20
15339: PUSH
15340: LD_INT 21
15342: PUSH
15343: LD_INT 22
15345: PUSH
15346: LD_INT 72
15348: PUSH
15349: LD_INT 26
15351: PUSH
15352: LD_INT 69
15354: PUSH
15355: LD_INT 39
15357: PUSH
15358: LD_INT 40
15360: PUSH
15361: LD_INT 41
15363: PUSH
15364: LD_INT 42
15366: PUSH
15367: LD_INT 43
15369: PUSH
15370: LD_INT 48
15372: PUSH
15373: LD_INT 49
15375: PUSH
15376: LD_INT 50
15378: PUSH
15379: LD_INT 51
15381: PUSH
15382: LD_INT 52
15384: PUSH
15385: LD_INT 53
15387: PUSH
15388: LD_INT 54
15390: PUSH
15391: LD_INT 55
15393: PUSH
15394: LD_INT 56
15396: PUSH
15397: LD_INT 60
15399: PUSH
15400: LD_INT 61
15402: PUSH
15403: LD_INT 62
15405: PUSH
15406: LD_INT 66
15408: PUSH
15409: LD_INT 67
15411: PUSH
15412: LD_INT 68
15414: PUSH
15415: LD_INT 81
15417: PUSH
15418: LD_INT 82
15420: PUSH
15421: LD_INT 83
15423: PUSH
15424: LD_INT 84
15426: PUSH
15427: LD_INT 85
15429: PUSH
15430: LD_INT 87
15432: PUSH
15433: LD_INT 88
15435: PUSH
15436: EMPTY
15437: LIST
15438: LIST
15439: LIST
15440: LIST
15441: LIST
15442: LIST
15443: LIST
15444: LIST
15445: LIST
15446: LIST
15447: LIST
15448: LIST
15449: LIST
15450: LIST
15451: LIST
15452: LIST
15453: LIST
15454: LIST
15455: LIST
15456: LIST
15457: LIST
15458: LIST
15459: LIST
15460: LIST
15461: LIST
15462: LIST
15463: LIST
15464: LIST
15465: LIST
15466: LIST
15467: LIST
15468: LIST
15469: LIST
15470: LIST
15471: LIST
15472: LIST
15473: LIST
15474: LIST
15475: LIST
15476: LIST
15477: LIST
15478: LIST
15479: LIST
15480: LIST
15481: LIST
15482: LIST
15483: LIST
15484: LIST
15485: LIST
15486: LIST
15487: LIST
15488: LIST
15489: LIST
15490: LIST
15491: ST_TO_ADDR
15492: GO 15725
15494: LD_INT 3
15496: DOUBLE
15497: EQUAL
15498: IFTRUE 15502
15500: GO 15724
15502: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
15503: LD_ADDR_VAR 0 4
15507: PUSH
15508: LD_INT 46
15510: PUSH
15511: LD_INT 47
15513: PUSH
15514: LD_INT 1
15516: PUSH
15517: LD_INT 2
15519: PUSH
15520: LD_INT 82
15522: PUSH
15523: LD_INT 83
15525: PUSH
15526: LD_INT 84
15528: PUSH
15529: LD_INT 85
15531: PUSH
15532: LD_INT 86
15534: PUSH
15535: LD_INT 11
15537: PUSH
15538: LD_INT 9
15540: PUSH
15541: LD_INT 20
15543: PUSH
15544: LD_INT 19
15546: PUSH
15547: LD_INT 21
15549: PUSH
15550: LD_INT 24
15552: PUSH
15553: LD_INT 22
15555: PUSH
15556: LD_INT 25
15558: PUSH
15559: LD_INT 28
15561: PUSH
15562: LD_INT 29
15564: PUSH
15565: LD_INT 30
15567: PUSH
15568: LD_INT 31
15570: PUSH
15571: LD_INT 37
15573: PUSH
15574: LD_INT 38
15576: PUSH
15577: LD_INT 32
15579: PUSH
15580: LD_INT 27
15582: PUSH
15583: LD_INT 33
15585: PUSH
15586: LD_INT 69
15588: PUSH
15589: LD_INT 39
15591: PUSH
15592: LD_INT 34
15594: PUSH
15595: LD_INT 40
15597: PUSH
15598: LD_INT 71
15600: PUSH
15601: LD_INT 23
15603: PUSH
15604: LD_INT 44
15606: PUSH
15607: LD_INT 48
15609: PUSH
15610: LD_INT 49
15612: PUSH
15613: LD_INT 50
15615: PUSH
15616: LD_INT 51
15618: PUSH
15619: LD_INT 52
15621: PUSH
15622: LD_INT 53
15624: PUSH
15625: LD_INT 54
15627: PUSH
15628: LD_INT 55
15630: PUSH
15631: LD_INT 56
15633: PUSH
15634: LD_INT 57
15636: PUSH
15637: LD_INT 58
15639: PUSH
15640: LD_INT 59
15642: PUSH
15643: LD_INT 63
15645: PUSH
15646: LD_INT 64
15648: PUSH
15649: LD_INT 65
15651: PUSH
15652: LD_INT 82
15654: PUSH
15655: LD_INT 83
15657: PUSH
15658: LD_INT 84
15660: PUSH
15661: LD_INT 85
15663: PUSH
15664: LD_INT 86
15666: PUSH
15667: EMPTY
15668: LIST
15669: LIST
15670: LIST
15671: LIST
15672: LIST
15673: LIST
15674: LIST
15675: LIST
15676: LIST
15677: LIST
15678: LIST
15679: LIST
15680: LIST
15681: LIST
15682: LIST
15683: LIST
15684: LIST
15685: LIST
15686: LIST
15687: LIST
15688: LIST
15689: LIST
15690: LIST
15691: LIST
15692: LIST
15693: LIST
15694: LIST
15695: LIST
15696: LIST
15697: LIST
15698: LIST
15699: LIST
15700: LIST
15701: LIST
15702: LIST
15703: LIST
15704: LIST
15705: LIST
15706: LIST
15707: LIST
15708: LIST
15709: LIST
15710: LIST
15711: LIST
15712: LIST
15713: LIST
15714: LIST
15715: LIST
15716: LIST
15717: LIST
15718: LIST
15719: LIST
15720: LIST
15721: ST_TO_ADDR
15722: GO 15725
15724: POP
// if state > - 1 and state < 3 then
15725: LD_VAR 0 3
15729: PUSH
15730: LD_INT 1
15732: NEG
15733: GREATER
15734: PUSH
15735: LD_VAR 0 3
15739: PUSH
15740: LD_INT 3
15742: LESS
15743: AND
15744: IFFALSE 15801
// for i in result do
15746: LD_ADDR_VAR 0 5
15750: PUSH
15751: LD_VAR 0 4
15755: PUSH
15756: FOR_IN
15757: IFFALSE 15799
// if GetTech ( i , side ) <> state then
15759: LD_VAR 0 5
15763: PPUSH
15764: LD_VAR 0 1
15768: PPUSH
15769: CALL_OW 321
15773: PUSH
15774: LD_VAR 0 3
15778: NONEQUAL
15779: IFFALSE 15797
// result := result diff i ;
15781: LD_ADDR_VAR 0 4
15785: PUSH
15786: LD_VAR 0 4
15790: PUSH
15791: LD_VAR 0 5
15795: DIFF
15796: ST_TO_ADDR
15797: GO 15756
15799: POP
15800: POP
// end ;
15801: LD_VAR 0 4
15805: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15806: LD_INT 0
15808: PPUSH
15809: PPUSH
15810: PPUSH
// result := true ;
15811: LD_ADDR_VAR 0 3
15815: PUSH
15816: LD_INT 1
15818: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15819: LD_ADDR_VAR 0 5
15823: PUSH
15824: LD_VAR 0 2
15828: PPUSH
15829: CALL_OW 480
15833: ST_TO_ADDR
// if not tmp then
15834: LD_VAR 0 5
15838: NOT
15839: IFFALSE 15843
// exit ;
15841: GO 15892
// for i in tmp do
15843: LD_ADDR_VAR 0 4
15847: PUSH
15848: LD_VAR 0 5
15852: PUSH
15853: FOR_IN
15854: IFFALSE 15890
// if GetTech ( i , side ) <> state_researched then
15856: LD_VAR 0 4
15860: PPUSH
15861: LD_VAR 0 1
15865: PPUSH
15866: CALL_OW 321
15870: PUSH
15871: LD_INT 2
15873: NONEQUAL
15874: IFFALSE 15888
// begin result := false ;
15876: LD_ADDR_VAR 0 3
15880: PUSH
15881: LD_INT 0
15883: ST_TO_ADDR
// exit ;
15884: POP
15885: POP
15886: GO 15892
// end ;
15888: GO 15853
15890: POP
15891: POP
// end ;
15892: LD_VAR 0 3
15896: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15897: LD_INT 0
15899: PPUSH
15900: PPUSH
15901: PPUSH
15902: PPUSH
15903: PPUSH
15904: PPUSH
15905: PPUSH
15906: PPUSH
15907: PPUSH
15908: PPUSH
15909: PPUSH
15910: PPUSH
15911: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15912: LD_VAR 0 1
15916: NOT
15917: PUSH
15918: LD_VAR 0 1
15922: PPUSH
15923: CALL_OW 257
15927: PUSH
15928: LD_INT 9
15930: NONEQUAL
15931: OR
15932: IFFALSE 15936
// exit ;
15934: GO 16509
// side := GetSide ( unit ) ;
15936: LD_ADDR_VAR 0 9
15940: PUSH
15941: LD_VAR 0 1
15945: PPUSH
15946: CALL_OW 255
15950: ST_TO_ADDR
// tech_space := tech_spacanom ;
15951: LD_ADDR_VAR 0 12
15955: PUSH
15956: LD_INT 29
15958: ST_TO_ADDR
// tech_time := tech_taurad ;
15959: LD_ADDR_VAR 0 13
15963: PUSH
15964: LD_INT 28
15966: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15967: LD_ADDR_VAR 0 11
15971: PUSH
15972: LD_VAR 0 1
15976: PPUSH
15977: CALL_OW 310
15981: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15982: LD_VAR 0 11
15986: PPUSH
15987: CALL_OW 247
15991: PUSH
15992: LD_INT 2
15994: EQUAL
15995: IFFALSE 15999
// exit ;
15997: GO 16509
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15999: LD_ADDR_VAR 0 8
16003: PUSH
16004: LD_INT 81
16006: PUSH
16007: LD_VAR 0 9
16011: PUSH
16012: EMPTY
16013: LIST
16014: LIST
16015: PUSH
16016: LD_INT 3
16018: PUSH
16019: LD_INT 21
16021: PUSH
16022: LD_INT 3
16024: PUSH
16025: EMPTY
16026: LIST
16027: LIST
16028: PUSH
16029: EMPTY
16030: LIST
16031: LIST
16032: PUSH
16033: EMPTY
16034: LIST
16035: LIST
16036: PPUSH
16037: CALL_OW 69
16041: ST_TO_ADDR
// if not tmp then
16042: LD_VAR 0 8
16046: NOT
16047: IFFALSE 16051
// exit ;
16049: GO 16509
// if in_unit then
16051: LD_VAR 0 11
16055: IFFALSE 16079
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
16057: LD_ADDR_VAR 0 10
16061: PUSH
16062: LD_VAR 0 8
16066: PPUSH
16067: LD_VAR 0 11
16071: PPUSH
16072: CALL_OW 74
16076: ST_TO_ADDR
16077: GO 16099
// enemy := NearestUnitToUnit ( tmp , unit ) ;
16079: LD_ADDR_VAR 0 10
16083: PUSH
16084: LD_VAR 0 8
16088: PPUSH
16089: LD_VAR 0 1
16093: PPUSH
16094: CALL_OW 74
16098: ST_TO_ADDR
// if not enemy then
16099: LD_VAR 0 10
16103: NOT
16104: IFFALSE 16108
// exit ;
16106: GO 16509
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
16108: LD_VAR 0 11
16112: PUSH
16113: LD_VAR 0 11
16117: PPUSH
16118: LD_VAR 0 10
16122: PPUSH
16123: CALL_OW 296
16127: PUSH
16128: LD_INT 13
16130: GREATER
16131: AND
16132: PUSH
16133: LD_VAR 0 1
16137: PPUSH
16138: LD_VAR 0 10
16142: PPUSH
16143: CALL_OW 296
16147: PUSH
16148: LD_INT 12
16150: GREATER
16151: OR
16152: IFFALSE 16156
// exit ;
16154: GO 16509
// missile := [ 1 ] ;
16156: LD_ADDR_VAR 0 14
16160: PUSH
16161: LD_INT 1
16163: PUSH
16164: EMPTY
16165: LIST
16166: ST_TO_ADDR
// if Researched ( side , tech_space ) then
16167: LD_VAR 0 9
16171: PPUSH
16172: LD_VAR 0 12
16176: PPUSH
16177: CALL_OW 325
16181: IFFALSE 16210
// missile := Replace ( missile , missile + 1 , 2 ) ;
16183: LD_ADDR_VAR 0 14
16187: PUSH
16188: LD_VAR 0 14
16192: PPUSH
16193: LD_VAR 0 14
16197: PUSH
16198: LD_INT 1
16200: PLUS
16201: PPUSH
16202: LD_INT 2
16204: PPUSH
16205: CALL_OW 1
16209: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
16210: LD_VAR 0 9
16214: PPUSH
16215: LD_VAR 0 13
16219: PPUSH
16220: CALL_OW 325
16224: PUSH
16225: LD_VAR 0 10
16229: PPUSH
16230: CALL_OW 255
16234: PPUSH
16235: LD_VAR 0 13
16239: PPUSH
16240: CALL_OW 325
16244: NOT
16245: AND
16246: IFFALSE 16275
// missile := Replace ( missile , missile + 1 , 3 ) ;
16248: LD_ADDR_VAR 0 14
16252: PUSH
16253: LD_VAR 0 14
16257: PPUSH
16258: LD_VAR 0 14
16262: PUSH
16263: LD_INT 1
16265: PLUS
16266: PPUSH
16267: LD_INT 3
16269: PPUSH
16270: CALL_OW 1
16274: ST_TO_ADDR
// if missile < 2 then
16275: LD_VAR 0 14
16279: PUSH
16280: LD_INT 2
16282: LESS
16283: IFFALSE 16287
// exit ;
16285: GO 16509
// x := GetX ( enemy ) ;
16287: LD_ADDR_VAR 0 4
16291: PUSH
16292: LD_VAR 0 10
16296: PPUSH
16297: CALL_OW 250
16301: ST_TO_ADDR
// y := GetY ( enemy ) ;
16302: LD_ADDR_VAR 0 5
16306: PUSH
16307: LD_VAR 0 10
16311: PPUSH
16312: CALL_OW 251
16316: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
16317: LD_ADDR_VAR 0 6
16321: PUSH
16322: LD_VAR 0 4
16326: PUSH
16327: LD_INT 1
16329: NEG
16330: PPUSH
16331: LD_INT 1
16333: PPUSH
16334: CALL_OW 12
16338: PLUS
16339: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
16340: LD_ADDR_VAR 0 7
16344: PUSH
16345: LD_VAR 0 5
16349: PUSH
16350: LD_INT 1
16352: NEG
16353: PPUSH
16354: LD_INT 1
16356: PPUSH
16357: CALL_OW 12
16361: PLUS
16362: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16363: LD_VAR 0 6
16367: PPUSH
16368: LD_VAR 0 7
16372: PPUSH
16373: CALL_OW 488
16377: NOT
16378: IFFALSE 16400
// begin _x := x ;
16380: LD_ADDR_VAR 0 6
16384: PUSH
16385: LD_VAR 0 4
16389: ST_TO_ADDR
// _y := y ;
16390: LD_ADDR_VAR 0 7
16394: PUSH
16395: LD_VAR 0 5
16399: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
16400: LD_ADDR_VAR 0 3
16404: PUSH
16405: LD_INT 1
16407: PPUSH
16408: LD_VAR 0 14
16412: PPUSH
16413: CALL_OW 12
16417: ST_TO_ADDR
// case i of 1 :
16418: LD_VAR 0 3
16422: PUSH
16423: LD_INT 1
16425: DOUBLE
16426: EQUAL
16427: IFTRUE 16431
16429: GO 16448
16431: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
16432: LD_VAR 0 1
16436: PPUSH
16437: LD_VAR 0 10
16441: PPUSH
16442: CALL_OW 115
16446: GO 16509
16448: LD_INT 2
16450: DOUBLE
16451: EQUAL
16452: IFTRUE 16456
16454: GO 16478
16456: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
16457: LD_VAR 0 1
16461: PPUSH
16462: LD_VAR 0 6
16466: PPUSH
16467: LD_VAR 0 7
16471: PPUSH
16472: CALL_OW 153
16476: GO 16509
16478: LD_INT 3
16480: DOUBLE
16481: EQUAL
16482: IFTRUE 16486
16484: GO 16508
16486: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
16487: LD_VAR 0 1
16491: PPUSH
16492: LD_VAR 0 6
16496: PPUSH
16497: LD_VAR 0 7
16501: PPUSH
16502: CALL_OW 154
16506: GO 16509
16508: POP
// end ;
16509: LD_VAR 0 2
16513: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
16514: LD_INT 0
16516: PPUSH
16517: PPUSH
16518: PPUSH
16519: PPUSH
16520: PPUSH
16521: PPUSH
// if not unit or not building then
16522: LD_VAR 0 1
16526: NOT
16527: PUSH
16528: LD_VAR 0 2
16532: NOT
16533: OR
16534: IFFALSE 16538
// exit ;
16536: GO 16696
// x := GetX ( building ) ;
16538: LD_ADDR_VAR 0 5
16542: PUSH
16543: LD_VAR 0 2
16547: PPUSH
16548: CALL_OW 250
16552: ST_TO_ADDR
// y := GetY ( building ) ;
16553: LD_ADDR_VAR 0 6
16557: PUSH
16558: LD_VAR 0 2
16562: PPUSH
16563: CALL_OW 251
16567: ST_TO_ADDR
// for i = 0 to 5 do
16568: LD_ADDR_VAR 0 4
16572: PUSH
16573: DOUBLE
16574: LD_INT 0
16576: DEC
16577: ST_TO_ADDR
16578: LD_INT 5
16580: PUSH
16581: FOR_TO
16582: IFFALSE 16694
// begin _x := ShiftX ( x , i , 3 ) ;
16584: LD_ADDR_VAR 0 7
16588: PUSH
16589: LD_VAR 0 5
16593: PPUSH
16594: LD_VAR 0 4
16598: PPUSH
16599: LD_INT 3
16601: PPUSH
16602: CALL_OW 272
16606: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
16607: LD_ADDR_VAR 0 8
16611: PUSH
16612: LD_VAR 0 6
16616: PPUSH
16617: LD_VAR 0 4
16621: PPUSH
16622: LD_INT 3
16624: PPUSH
16625: CALL_OW 273
16629: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16630: LD_VAR 0 7
16634: PPUSH
16635: LD_VAR 0 8
16639: PPUSH
16640: CALL_OW 488
16644: NOT
16645: IFFALSE 16649
// continue ;
16647: GO 16581
// if HexInfo ( _x , _y ) = 0 then
16649: LD_VAR 0 7
16653: PPUSH
16654: LD_VAR 0 8
16658: PPUSH
16659: CALL_OW 428
16663: PUSH
16664: LD_INT 0
16666: EQUAL
16667: IFFALSE 16692
// begin ComMoveXY ( unit , _x , _y ) ;
16669: LD_VAR 0 1
16673: PPUSH
16674: LD_VAR 0 7
16678: PPUSH
16679: LD_VAR 0 8
16683: PPUSH
16684: CALL_OW 111
// exit ;
16688: POP
16689: POP
16690: GO 16696
// end ; end ;
16692: GO 16581
16694: POP
16695: POP
// end ;
16696: LD_VAR 0 3
16700: RET
// export function ScanBase ( side , base_area ) ; begin
16701: LD_INT 0
16703: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16704: LD_ADDR_VAR 0 3
16708: PUSH
16709: LD_VAR 0 2
16713: PPUSH
16714: LD_INT 81
16716: PUSH
16717: LD_VAR 0 1
16721: PUSH
16722: EMPTY
16723: LIST
16724: LIST
16725: PPUSH
16726: CALL_OW 70
16730: ST_TO_ADDR
// end ;
16731: LD_VAR 0 3
16735: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16736: LD_INT 0
16738: PPUSH
16739: PPUSH
16740: PPUSH
16741: PPUSH
// result := false ;
16742: LD_ADDR_VAR 0 2
16746: PUSH
16747: LD_INT 0
16749: ST_TO_ADDR
// side := GetSide ( unit ) ;
16750: LD_ADDR_VAR 0 3
16754: PUSH
16755: LD_VAR 0 1
16759: PPUSH
16760: CALL_OW 255
16764: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16765: LD_ADDR_VAR 0 4
16769: PUSH
16770: LD_VAR 0 1
16774: PPUSH
16775: CALL_OW 248
16779: ST_TO_ADDR
// case nat of 1 :
16780: LD_VAR 0 4
16784: PUSH
16785: LD_INT 1
16787: DOUBLE
16788: EQUAL
16789: IFTRUE 16793
16791: GO 16804
16793: POP
// tech := tech_lassight ; 2 :
16794: LD_ADDR_VAR 0 5
16798: PUSH
16799: LD_INT 12
16801: ST_TO_ADDR
16802: GO 16843
16804: LD_INT 2
16806: DOUBLE
16807: EQUAL
16808: IFTRUE 16812
16810: GO 16823
16812: POP
// tech := tech_mortar ; 3 :
16813: LD_ADDR_VAR 0 5
16817: PUSH
16818: LD_INT 41
16820: ST_TO_ADDR
16821: GO 16843
16823: LD_INT 3
16825: DOUBLE
16826: EQUAL
16827: IFTRUE 16831
16829: GO 16842
16831: POP
// tech := tech_bazooka ; end ;
16832: LD_ADDR_VAR 0 5
16836: PUSH
16837: LD_INT 44
16839: ST_TO_ADDR
16840: GO 16843
16842: POP
// if Researched ( side , tech ) then
16843: LD_VAR 0 3
16847: PPUSH
16848: LD_VAR 0 5
16852: PPUSH
16853: CALL_OW 325
16857: IFFALSE 16884
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16859: LD_ADDR_VAR 0 2
16863: PUSH
16864: LD_INT 5
16866: PUSH
16867: LD_INT 8
16869: PUSH
16870: LD_INT 9
16872: PUSH
16873: EMPTY
16874: LIST
16875: LIST
16876: LIST
16877: PUSH
16878: LD_VAR 0 4
16882: ARRAY
16883: ST_TO_ADDR
// end ;
16884: LD_VAR 0 2
16888: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16889: LD_INT 0
16891: PPUSH
16892: PPUSH
16893: PPUSH
// if not mines then
16894: LD_VAR 0 2
16898: NOT
16899: IFFALSE 16903
// exit ;
16901: GO 17047
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16903: LD_ADDR_VAR 0 5
16907: PUSH
16908: LD_INT 81
16910: PUSH
16911: LD_VAR 0 1
16915: PUSH
16916: EMPTY
16917: LIST
16918: LIST
16919: PUSH
16920: LD_INT 3
16922: PUSH
16923: LD_INT 21
16925: PUSH
16926: LD_INT 3
16928: PUSH
16929: EMPTY
16930: LIST
16931: LIST
16932: PUSH
16933: EMPTY
16934: LIST
16935: LIST
16936: PUSH
16937: EMPTY
16938: LIST
16939: LIST
16940: PPUSH
16941: CALL_OW 69
16945: ST_TO_ADDR
// for i in mines do
16946: LD_ADDR_VAR 0 4
16950: PUSH
16951: LD_VAR 0 2
16955: PUSH
16956: FOR_IN
16957: IFFALSE 17045
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16959: LD_VAR 0 4
16963: PUSH
16964: LD_INT 1
16966: ARRAY
16967: PPUSH
16968: LD_VAR 0 4
16972: PUSH
16973: LD_INT 2
16975: ARRAY
16976: PPUSH
16977: CALL_OW 458
16981: NOT
16982: IFFALSE 16986
// continue ;
16984: GO 16956
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16986: LD_VAR 0 4
16990: PUSH
16991: LD_INT 1
16993: ARRAY
16994: PPUSH
16995: LD_VAR 0 4
16999: PUSH
17000: LD_INT 2
17002: ARRAY
17003: PPUSH
17004: CALL_OW 428
17008: PUSH
17009: LD_VAR 0 5
17013: IN
17014: IFFALSE 17043
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17016: LD_VAR 0 4
17020: PUSH
17021: LD_INT 1
17023: ARRAY
17024: PPUSH
17025: LD_VAR 0 4
17029: PUSH
17030: LD_INT 2
17032: ARRAY
17033: PPUSH
17034: LD_VAR 0 1
17038: PPUSH
17039: CALL_OW 456
// end ;
17043: GO 16956
17045: POP
17046: POP
// end ;
17047: LD_VAR 0 3
17051: RET
// export function Count ( array ) ; var i ; begin
17052: LD_INT 0
17054: PPUSH
17055: PPUSH
// result := 0 ;
17056: LD_ADDR_VAR 0 2
17060: PUSH
17061: LD_INT 0
17063: ST_TO_ADDR
// for i in array do
17064: LD_ADDR_VAR 0 3
17068: PUSH
17069: LD_VAR 0 1
17073: PUSH
17074: FOR_IN
17075: IFFALSE 17099
// if i then
17077: LD_VAR 0 3
17081: IFFALSE 17097
// result := result + 1 ;
17083: LD_ADDR_VAR 0 2
17087: PUSH
17088: LD_VAR 0 2
17092: PUSH
17093: LD_INT 1
17095: PLUS
17096: ST_TO_ADDR
17097: GO 17074
17099: POP
17100: POP
// end ;
17101: LD_VAR 0 2
17105: RET
// export function IsEmpty ( building ) ; begin
17106: LD_INT 0
17108: PPUSH
// if not building then
17109: LD_VAR 0 1
17113: NOT
17114: IFFALSE 17118
// exit ;
17116: GO 17161
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17118: LD_ADDR_VAR 0 2
17122: PUSH
17123: LD_VAR 0 1
17127: PUSH
17128: LD_INT 22
17130: PUSH
17131: LD_VAR 0 1
17135: PPUSH
17136: CALL_OW 255
17140: PUSH
17141: EMPTY
17142: LIST
17143: LIST
17144: PUSH
17145: LD_INT 58
17147: PUSH
17148: EMPTY
17149: LIST
17150: PUSH
17151: EMPTY
17152: LIST
17153: LIST
17154: PPUSH
17155: CALL_OW 69
17159: IN
17160: ST_TO_ADDR
// end ;
17161: LD_VAR 0 2
17165: RET
// export function IsNotFull ( building ) ; var places ; begin
17166: LD_INT 0
17168: PPUSH
17169: PPUSH
// if not building then
17170: LD_VAR 0 1
17174: NOT
17175: IFFALSE 17179
// exit ;
17177: GO 17350
// result := false ;
17179: LD_ADDR_VAR 0 2
17183: PUSH
17184: LD_INT 0
17186: ST_TO_ADDR
// places := 0 ;
17187: LD_ADDR_VAR 0 3
17191: PUSH
17192: LD_INT 0
17194: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
17195: LD_VAR 0 1
17199: PPUSH
17200: CALL_OW 266
17204: PUSH
17205: LD_INT 0
17207: DOUBLE
17208: EQUAL
17209: IFTRUE 17267
17211: LD_INT 1
17213: DOUBLE
17214: EQUAL
17215: IFTRUE 17267
17217: LD_INT 6
17219: DOUBLE
17220: EQUAL
17221: IFTRUE 17267
17223: LD_INT 7
17225: DOUBLE
17226: EQUAL
17227: IFTRUE 17267
17229: LD_INT 8
17231: DOUBLE
17232: EQUAL
17233: IFTRUE 17267
17235: LD_INT 4
17237: DOUBLE
17238: EQUAL
17239: IFTRUE 17267
17241: LD_INT 5
17243: DOUBLE
17244: EQUAL
17245: IFTRUE 17267
17247: LD_INT 2
17249: DOUBLE
17250: EQUAL
17251: IFTRUE 17267
17253: LD_INT 3
17255: DOUBLE
17256: EQUAL
17257: IFTRUE 17267
17259: LD_INT 35
17261: DOUBLE
17262: EQUAL
17263: IFTRUE 17267
17265: GO 17278
17267: POP
// places := 6 ; b_bunker , b_breastwork :
17268: LD_ADDR_VAR 0 3
17272: PUSH
17273: LD_INT 6
17275: ST_TO_ADDR
17276: GO 17323
17278: LD_INT 32
17280: DOUBLE
17281: EQUAL
17282: IFTRUE 17292
17284: LD_INT 31
17286: DOUBLE
17287: EQUAL
17288: IFTRUE 17292
17290: GO 17303
17292: POP
// places := 1 ; b_control_tower :
17293: LD_ADDR_VAR 0 3
17297: PUSH
17298: LD_INT 1
17300: ST_TO_ADDR
17301: GO 17323
17303: LD_INT 36
17305: DOUBLE
17306: EQUAL
17307: IFTRUE 17311
17309: GO 17322
17311: POP
// places := 3 ; end ;
17312: LD_ADDR_VAR 0 3
17316: PUSH
17317: LD_INT 3
17319: ST_TO_ADDR
17320: GO 17323
17322: POP
// if places then
17323: LD_VAR 0 3
17327: IFFALSE 17350
// result := UnitsInside ( building ) < places ;
17329: LD_ADDR_VAR 0 2
17333: PUSH
17334: LD_VAR 0 1
17338: PPUSH
17339: CALL_OW 313
17343: PUSH
17344: LD_VAR 0 3
17348: LESS
17349: ST_TO_ADDR
// end ;
17350: LD_VAR 0 2
17354: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17355: LD_INT 0
17357: PPUSH
17358: PPUSH
17359: PPUSH
17360: PPUSH
// tmp := [ ] ;
17361: LD_ADDR_VAR 0 3
17365: PUSH
17366: EMPTY
17367: ST_TO_ADDR
// list := [ ] ;
17368: LD_ADDR_VAR 0 5
17372: PUSH
17373: EMPTY
17374: ST_TO_ADDR
// for i = 16 to 25 do
17375: LD_ADDR_VAR 0 4
17379: PUSH
17380: DOUBLE
17381: LD_INT 16
17383: DEC
17384: ST_TO_ADDR
17385: LD_INT 25
17387: PUSH
17388: FOR_TO
17389: IFFALSE 17462
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17391: LD_ADDR_VAR 0 3
17395: PUSH
17396: LD_VAR 0 3
17400: PUSH
17401: LD_INT 22
17403: PUSH
17404: LD_VAR 0 1
17408: PPUSH
17409: CALL_OW 255
17413: PUSH
17414: EMPTY
17415: LIST
17416: LIST
17417: PUSH
17418: LD_INT 91
17420: PUSH
17421: LD_VAR 0 1
17425: PUSH
17426: LD_INT 6
17428: PUSH
17429: EMPTY
17430: LIST
17431: LIST
17432: LIST
17433: PUSH
17434: LD_INT 30
17436: PUSH
17437: LD_VAR 0 4
17441: PUSH
17442: EMPTY
17443: LIST
17444: LIST
17445: PUSH
17446: EMPTY
17447: LIST
17448: LIST
17449: LIST
17450: PUSH
17451: EMPTY
17452: LIST
17453: PPUSH
17454: CALL_OW 69
17458: ADD
17459: ST_TO_ADDR
17460: GO 17388
17462: POP
17463: POP
// for i = 1 to tmp do
17464: LD_ADDR_VAR 0 4
17468: PUSH
17469: DOUBLE
17470: LD_INT 1
17472: DEC
17473: ST_TO_ADDR
17474: LD_VAR 0 3
17478: PUSH
17479: FOR_TO
17480: IFFALSE 17568
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17482: LD_ADDR_VAR 0 5
17486: PUSH
17487: LD_VAR 0 5
17491: PUSH
17492: LD_VAR 0 3
17496: PUSH
17497: LD_VAR 0 4
17501: ARRAY
17502: PPUSH
17503: CALL_OW 266
17507: PUSH
17508: LD_VAR 0 3
17512: PUSH
17513: LD_VAR 0 4
17517: ARRAY
17518: PPUSH
17519: CALL_OW 250
17523: PUSH
17524: LD_VAR 0 3
17528: PUSH
17529: LD_VAR 0 4
17533: ARRAY
17534: PPUSH
17535: CALL_OW 251
17539: PUSH
17540: LD_VAR 0 3
17544: PUSH
17545: LD_VAR 0 4
17549: ARRAY
17550: PPUSH
17551: CALL_OW 254
17555: PUSH
17556: EMPTY
17557: LIST
17558: LIST
17559: LIST
17560: LIST
17561: PUSH
17562: EMPTY
17563: LIST
17564: ADD
17565: ST_TO_ADDR
17566: GO 17479
17568: POP
17569: POP
// result := list ;
17570: LD_ADDR_VAR 0 2
17574: PUSH
17575: LD_VAR 0 5
17579: ST_TO_ADDR
// end ;
17580: LD_VAR 0 2
17584: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17585: LD_INT 0
17587: PPUSH
17588: PPUSH
17589: PPUSH
17590: PPUSH
17591: PPUSH
17592: PPUSH
17593: PPUSH
// if not factory then
17594: LD_VAR 0 1
17598: NOT
17599: IFFALSE 17603
// exit ;
17601: GO 18196
// if control = control_apeman then
17603: LD_VAR 0 4
17607: PUSH
17608: LD_INT 5
17610: EQUAL
17611: IFFALSE 17720
// begin tmp := UnitsInside ( factory ) ;
17613: LD_ADDR_VAR 0 8
17617: PUSH
17618: LD_VAR 0 1
17622: PPUSH
17623: CALL_OW 313
17627: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17628: LD_VAR 0 8
17632: PPUSH
17633: LD_INT 25
17635: PUSH
17636: LD_INT 12
17638: PUSH
17639: EMPTY
17640: LIST
17641: LIST
17642: PPUSH
17643: CALL_OW 72
17647: NOT
17648: IFFALSE 17658
// control := control_manual ;
17650: LD_ADDR_VAR 0 4
17654: PUSH
17655: LD_INT 1
17657: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17658: LD_ADDR_VAR 0 8
17662: PUSH
17663: LD_VAR 0 1
17667: PPUSH
17668: CALL 17355 0 1
17672: ST_TO_ADDR
// if tmp then
17673: LD_VAR 0 8
17677: IFFALSE 17720
// begin for i in tmp do
17679: LD_ADDR_VAR 0 7
17683: PUSH
17684: LD_VAR 0 8
17688: PUSH
17689: FOR_IN
17690: IFFALSE 17718
// if i [ 1 ] = b_ext_radio then
17692: LD_VAR 0 7
17696: PUSH
17697: LD_INT 1
17699: ARRAY
17700: PUSH
17701: LD_INT 22
17703: EQUAL
17704: IFFALSE 17716
// begin control := control_remote ;
17706: LD_ADDR_VAR 0 4
17710: PUSH
17711: LD_INT 2
17713: ST_TO_ADDR
// break ;
17714: GO 17718
// end ;
17716: GO 17689
17718: POP
17719: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17720: LD_VAR 0 1
17724: PPUSH
17725: LD_VAR 0 2
17729: PPUSH
17730: LD_VAR 0 3
17734: PPUSH
17735: LD_VAR 0 4
17739: PPUSH
17740: LD_VAR 0 5
17744: PPUSH
17745: CALL_OW 448
17749: IFFALSE 17784
// begin result := [ chassis , engine , control , weapon ] ;
17751: LD_ADDR_VAR 0 6
17755: PUSH
17756: LD_VAR 0 2
17760: PUSH
17761: LD_VAR 0 3
17765: PUSH
17766: LD_VAR 0 4
17770: PUSH
17771: LD_VAR 0 5
17775: PUSH
17776: EMPTY
17777: LIST
17778: LIST
17779: LIST
17780: LIST
17781: ST_TO_ADDR
// exit ;
17782: GO 18196
// end ; _chassis := AvailableChassisList ( factory ) ;
17784: LD_ADDR_VAR 0 9
17788: PUSH
17789: LD_VAR 0 1
17793: PPUSH
17794: CALL_OW 475
17798: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
17799: LD_ADDR_VAR 0 11
17803: PUSH
17804: LD_VAR 0 1
17808: PPUSH
17809: CALL_OW 476
17813: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
17814: LD_ADDR_VAR 0 12
17818: PUSH
17819: LD_VAR 0 1
17823: PPUSH
17824: CALL_OW 477
17828: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17829: LD_ADDR_VAR 0 10
17833: PUSH
17834: LD_VAR 0 1
17838: PPUSH
17839: CALL_OW 478
17843: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17844: LD_VAR 0 9
17848: NOT
17849: PUSH
17850: LD_VAR 0 11
17854: NOT
17855: OR
17856: PUSH
17857: LD_VAR 0 12
17861: NOT
17862: OR
17863: PUSH
17864: LD_VAR 0 10
17868: NOT
17869: OR
17870: IFFALSE 17905
// begin result := [ chassis , engine , control , weapon ] ;
17872: LD_ADDR_VAR 0 6
17876: PUSH
17877: LD_VAR 0 2
17881: PUSH
17882: LD_VAR 0 3
17886: PUSH
17887: LD_VAR 0 4
17891: PUSH
17892: LD_VAR 0 5
17896: PUSH
17897: EMPTY
17898: LIST
17899: LIST
17900: LIST
17901: LIST
17902: ST_TO_ADDR
// exit ;
17903: GO 18196
// end ; if not chassis in _chassis then
17905: LD_VAR 0 2
17909: PUSH
17910: LD_VAR 0 9
17914: IN
17915: NOT
17916: IFFALSE 17942
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17918: LD_ADDR_VAR 0 2
17922: PUSH
17923: LD_VAR 0 9
17927: PUSH
17928: LD_INT 1
17930: PPUSH
17931: LD_VAR 0 9
17935: PPUSH
17936: CALL_OW 12
17940: ARRAY
17941: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17942: LD_VAR 0 2
17946: PPUSH
17947: LD_VAR 0 3
17951: PPUSH
17952: CALL 18201 0 2
17956: NOT
17957: IFFALSE 18016
// repeat engine := _engine [ 1 ] ;
17959: LD_ADDR_VAR 0 3
17963: PUSH
17964: LD_VAR 0 11
17968: PUSH
17969: LD_INT 1
17971: ARRAY
17972: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17973: LD_ADDR_VAR 0 11
17977: PUSH
17978: LD_VAR 0 11
17982: PPUSH
17983: LD_INT 1
17985: PPUSH
17986: CALL_OW 3
17990: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17991: LD_VAR 0 2
17995: PPUSH
17996: LD_VAR 0 3
18000: PPUSH
18001: CALL 18201 0 2
18005: PUSH
18006: LD_VAR 0 11
18010: PUSH
18011: EMPTY
18012: EQUAL
18013: OR
18014: IFFALSE 17959
// if not control in _control then
18016: LD_VAR 0 4
18020: PUSH
18021: LD_VAR 0 12
18025: IN
18026: NOT
18027: IFFALSE 18053
// control := _control [ rand ( 1 , _control ) ] ;
18029: LD_ADDR_VAR 0 4
18033: PUSH
18034: LD_VAR 0 12
18038: PUSH
18039: LD_INT 1
18041: PPUSH
18042: LD_VAR 0 12
18046: PPUSH
18047: CALL_OW 12
18051: ARRAY
18052: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18053: LD_VAR 0 2
18057: PPUSH
18058: LD_VAR 0 5
18062: PPUSH
18063: CALL 18421 0 2
18067: NOT
18068: IFFALSE 18127
// repeat weapon := _weapon [ 1 ] ;
18070: LD_ADDR_VAR 0 5
18074: PUSH
18075: LD_VAR 0 10
18079: PUSH
18080: LD_INT 1
18082: ARRAY
18083: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18084: LD_ADDR_VAR 0 10
18088: PUSH
18089: LD_VAR 0 10
18093: PPUSH
18094: LD_INT 1
18096: PPUSH
18097: CALL_OW 3
18101: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18102: LD_VAR 0 2
18106: PPUSH
18107: LD_VAR 0 5
18111: PPUSH
18112: CALL 18421 0 2
18116: PUSH
18117: LD_VAR 0 10
18121: PUSH
18122: EMPTY
18123: EQUAL
18124: OR
18125: IFFALSE 18070
// result := [ ] ;
18127: LD_ADDR_VAR 0 6
18131: PUSH
18132: EMPTY
18133: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18134: LD_VAR 0 1
18138: PPUSH
18139: LD_VAR 0 2
18143: PPUSH
18144: LD_VAR 0 3
18148: PPUSH
18149: LD_VAR 0 4
18153: PPUSH
18154: LD_VAR 0 5
18158: PPUSH
18159: CALL_OW 448
18163: IFFALSE 18196
// result := [ chassis , engine , control , weapon ] ;
18165: LD_ADDR_VAR 0 6
18169: PUSH
18170: LD_VAR 0 2
18174: PUSH
18175: LD_VAR 0 3
18179: PUSH
18180: LD_VAR 0 4
18184: PUSH
18185: LD_VAR 0 5
18189: PUSH
18190: EMPTY
18191: LIST
18192: LIST
18193: LIST
18194: LIST
18195: ST_TO_ADDR
// end ;
18196: LD_VAR 0 6
18200: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18201: LD_INT 0
18203: PPUSH
// if not chassis or not engine then
18204: LD_VAR 0 1
18208: NOT
18209: PUSH
18210: LD_VAR 0 2
18214: NOT
18215: OR
18216: IFFALSE 18220
// exit ;
18218: GO 18416
// case engine of engine_solar :
18220: LD_VAR 0 2
18224: PUSH
18225: LD_INT 2
18227: DOUBLE
18228: EQUAL
18229: IFTRUE 18233
18231: GO 18271
18233: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18234: LD_ADDR_VAR 0 3
18238: PUSH
18239: LD_INT 11
18241: PUSH
18242: LD_INT 12
18244: PUSH
18245: LD_INT 13
18247: PUSH
18248: LD_INT 14
18250: PUSH
18251: LD_INT 1
18253: PUSH
18254: LD_INT 2
18256: PUSH
18257: LD_INT 3
18259: PUSH
18260: EMPTY
18261: LIST
18262: LIST
18263: LIST
18264: LIST
18265: LIST
18266: LIST
18267: LIST
18268: ST_TO_ADDR
18269: GO 18400
18271: LD_INT 1
18273: DOUBLE
18274: EQUAL
18275: IFTRUE 18279
18277: GO 18341
18279: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18280: LD_ADDR_VAR 0 3
18284: PUSH
18285: LD_INT 11
18287: PUSH
18288: LD_INT 12
18290: PUSH
18291: LD_INT 13
18293: PUSH
18294: LD_INT 14
18296: PUSH
18297: LD_INT 1
18299: PUSH
18300: LD_INT 2
18302: PUSH
18303: LD_INT 3
18305: PUSH
18306: LD_INT 4
18308: PUSH
18309: LD_INT 5
18311: PUSH
18312: LD_INT 21
18314: PUSH
18315: LD_INT 23
18317: PUSH
18318: LD_INT 22
18320: PUSH
18321: LD_INT 24
18323: PUSH
18324: EMPTY
18325: LIST
18326: LIST
18327: LIST
18328: LIST
18329: LIST
18330: LIST
18331: LIST
18332: LIST
18333: LIST
18334: LIST
18335: LIST
18336: LIST
18337: LIST
18338: ST_TO_ADDR
18339: GO 18400
18341: LD_INT 3
18343: DOUBLE
18344: EQUAL
18345: IFTRUE 18349
18347: GO 18399
18349: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18350: LD_ADDR_VAR 0 3
18354: PUSH
18355: LD_INT 13
18357: PUSH
18358: LD_INT 14
18360: PUSH
18361: LD_INT 2
18363: PUSH
18364: LD_INT 3
18366: PUSH
18367: LD_INT 4
18369: PUSH
18370: LD_INT 5
18372: PUSH
18373: LD_INT 21
18375: PUSH
18376: LD_INT 22
18378: PUSH
18379: LD_INT 23
18381: PUSH
18382: LD_INT 24
18384: PUSH
18385: EMPTY
18386: LIST
18387: LIST
18388: LIST
18389: LIST
18390: LIST
18391: LIST
18392: LIST
18393: LIST
18394: LIST
18395: LIST
18396: ST_TO_ADDR
18397: GO 18400
18399: POP
// result := ( chassis in result ) ;
18400: LD_ADDR_VAR 0 3
18404: PUSH
18405: LD_VAR 0 1
18409: PUSH
18410: LD_VAR 0 3
18414: IN
18415: ST_TO_ADDR
// end ;
18416: LD_VAR 0 3
18420: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18421: LD_INT 0
18423: PPUSH
// if not chassis or not weapon then
18424: LD_VAR 0 1
18428: NOT
18429: PUSH
18430: LD_VAR 0 2
18434: NOT
18435: OR
18436: IFFALSE 18440
// exit ;
18438: GO 19500
// case weapon of us_machine_gun :
18440: LD_VAR 0 2
18444: PUSH
18445: LD_INT 2
18447: DOUBLE
18448: EQUAL
18449: IFTRUE 18453
18451: GO 18483
18453: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18454: LD_ADDR_VAR 0 3
18458: PUSH
18459: LD_INT 1
18461: PUSH
18462: LD_INT 2
18464: PUSH
18465: LD_INT 3
18467: PUSH
18468: LD_INT 4
18470: PUSH
18471: LD_INT 5
18473: PUSH
18474: EMPTY
18475: LIST
18476: LIST
18477: LIST
18478: LIST
18479: LIST
18480: ST_TO_ADDR
18481: GO 19484
18483: LD_INT 3
18485: DOUBLE
18486: EQUAL
18487: IFTRUE 18491
18489: GO 18521
18491: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18492: LD_ADDR_VAR 0 3
18496: PUSH
18497: LD_INT 1
18499: PUSH
18500: LD_INT 2
18502: PUSH
18503: LD_INT 3
18505: PUSH
18506: LD_INT 4
18508: PUSH
18509: LD_INT 5
18511: PUSH
18512: EMPTY
18513: LIST
18514: LIST
18515: LIST
18516: LIST
18517: LIST
18518: ST_TO_ADDR
18519: GO 19484
18521: LD_INT 11
18523: DOUBLE
18524: EQUAL
18525: IFTRUE 18529
18527: GO 18559
18529: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18530: LD_ADDR_VAR 0 3
18534: PUSH
18535: LD_INT 1
18537: PUSH
18538: LD_INT 2
18540: PUSH
18541: LD_INT 3
18543: PUSH
18544: LD_INT 4
18546: PUSH
18547: LD_INT 5
18549: PUSH
18550: EMPTY
18551: LIST
18552: LIST
18553: LIST
18554: LIST
18555: LIST
18556: ST_TO_ADDR
18557: GO 19484
18559: LD_INT 4
18561: DOUBLE
18562: EQUAL
18563: IFTRUE 18567
18565: GO 18593
18567: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18568: LD_ADDR_VAR 0 3
18572: PUSH
18573: LD_INT 2
18575: PUSH
18576: LD_INT 3
18578: PUSH
18579: LD_INT 4
18581: PUSH
18582: LD_INT 5
18584: PUSH
18585: EMPTY
18586: LIST
18587: LIST
18588: LIST
18589: LIST
18590: ST_TO_ADDR
18591: GO 19484
18593: LD_INT 5
18595: DOUBLE
18596: EQUAL
18597: IFTRUE 18601
18599: GO 18627
18601: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18602: LD_ADDR_VAR 0 3
18606: PUSH
18607: LD_INT 2
18609: PUSH
18610: LD_INT 3
18612: PUSH
18613: LD_INT 4
18615: PUSH
18616: LD_INT 5
18618: PUSH
18619: EMPTY
18620: LIST
18621: LIST
18622: LIST
18623: LIST
18624: ST_TO_ADDR
18625: GO 19484
18627: LD_INT 9
18629: DOUBLE
18630: EQUAL
18631: IFTRUE 18635
18633: GO 18661
18635: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18636: LD_ADDR_VAR 0 3
18640: PUSH
18641: LD_INT 2
18643: PUSH
18644: LD_INT 3
18646: PUSH
18647: LD_INT 4
18649: PUSH
18650: LD_INT 5
18652: PUSH
18653: EMPTY
18654: LIST
18655: LIST
18656: LIST
18657: LIST
18658: ST_TO_ADDR
18659: GO 19484
18661: LD_INT 7
18663: DOUBLE
18664: EQUAL
18665: IFTRUE 18669
18667: GO 18695
18669: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18670: LD_ADDR_VAR 0 3
18674: PUSH
18675: LD_INT 2
18677: PUSH
18678: LD_INT 3
18680: PUSH
18681: LD_INT 4
18683: PUSH
18684: LD_INT 5
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: LIST
18691: LIST
18692: ST_TO_ADDR
18693: GO 19484
18695: LD_INT 12
18697: DOUBLE
18698: EQUAL
18699: IFTRUE 18703
18701: GO 18729
18703: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18704: LD_ADDR_VAR 0 3
18708: PUSH
18709: LD_INT 2
18711: PUSH
18712: LD_INT 3
18714: PUSH
18715: LD_INT 4
18717: PUSH
18718: LD_INT 5
18720: PUSH
18721: EMPTY
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: ST_TO_ADDR
18727: GO 19484
18729: LD_INT 13
18731: DOUBLE
18732: EQUAL
18733: IFTRUE 18737
18735: GO 18763
18737: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18738: LD_ADDR_VAR 0 3
18742: PUSH
18743: LD_INT 2
18745: PUSH
18746: LD_INT 3
18748: PUSH
18749: LD_INT 4
18751: PUSH
18752: LD_INT 5
18754: PUSH
18755: EMPTY
18756: LIST
18757: LIST
18758: LIST
18759: LIST
18760: ST_TO_ADDR
18761: GO 19484
18763: LD_INT 14
18765: DOUBLE
18766: EQUAL
18767: IFTRUE 18771
18769: GO 18789
18771: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18772: LD_ADDR_VAR 0 3
18776: PUSH
18777: LD_INT 4
18779: PUSH
18780: LD_INT 5
18782: PUSH
18783: EMPTY
18784: LIST
18785: LIST
18786: ST_TO_ADDR
18787: GO 19484
18789: LD_INT 6
18791: DOUBLE
18792: EQUAL
18793: IFTRUE 18797
18795: GO 18815
18797: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18798: LD_ADDR_VAR 0 3
18802: PUSH
18803: LD_INT 4
18805: PUSH
18806: LD_INT 5
18808: PUSH
18809: EMPTY
18810: LIST
18811: LIST
18812: ST_TO_ADDR
18813: GO 19484
18815: LD_INT 10
18817: DOUBLE
18818: EQUAL
18819: IFTRUE 18823
18821: GO 18841
18823: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18824: LD_ADDR_VAR 0 3
18828: PUSH
18829: LD_INT 4
18831: PUSH
18832: LD_INT 5
18834: PUSH
18835: EMPTY
18836: LIST
18837: LIST
18838: ST_TO_ADDR
18839: GO 19484
18841: LD_INT 22
18843: DOUBLE
18844: EQUAL
18845: IFTRUE 18849
18847: GO 18875
18849: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18850: LD_ADDR_VAR 0 3
18854: PUSH
18855: LD_INT 11
18857: PUSH
18858: LD_INT 12
18860: PUSH
18861: LD_INT 13
18863: PUSH
18864: LD_INT 14
18866: PUSH
18867: EMPTY
18868: LIST
18869: LIST
18870: LIST
18871: LIST
18872: ST_TO_ADDR
18873: GO 19484
18875: LD_INT 23
18877: DOUBLE
18878: EQUAL
18879: IFTRUE 18883
18881: GO 18909
18883: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18884: LD_ADDR_VAR 0 3
18888: PUSH
18889: LD_INT 11
18891: PUSH
18892: LD_INT 12
18894: PUSH
18895: LD_INT 13
18897: PUSH
18898: LD_INT 14
18900: PUSH
18901: EMPTY
18902: LIST
18903: LIST
18904: LIST
18905: LIST
18906: ST_TO_ADDR
18907: GO 19484
18909: LD_INT 24
18911: DOUBLE
18912: EQUAL
18913: IFTRUE 18917
18915: GO 18943
18917: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18918: LD_ADDR_VAR 0 3
18922: PUSH
18923: LD_INT 11
18925: PUSH
18926: LD_INT 12
18928: PUSH
18929: LD_INT 13
18931: PUSH
18932: LD_INT 14
18934: PUSH
18935: EMPTY
18936: LIST
18937: LIST
18938: LIST
18939: LIST
18940: ST_TO_ADDR
18941: GO 19484
18943: LD_INT 30
18945: DOUBLE
18946: EQUAL
18947: IFTRUE 18951
18949: GO 18977
18951: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18952: LD_ADDR_VAR 0 3
18956: PUSH
18957: LD_INT 11
18959: PUSH
18960: LD_INT 12
18962: PUSH
18963: LD_INT 13
18965: PUSH
18966: LD_INT 14
18968: PUSH
18969: EMPTY
18970: LIST
18971: LIST
18972: LIST
18973: LIST
18974: ST_TO_ADDR
18975: GO 19484
18977: LD_INT 25
18979: DOUBLE
18980: EQUAL
18981: IFTRUE 18985
18983: GO 19003
18985: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18986: LD_ADDR_VAR 0 3
18990: PUSH
18991: LD_INT 13
18993: PUSH
18994: LD_INT 14
18996: PUSH
18997: EMPTY
18998: LIST
18999: LIST
19000: ST_TO_ADDR
19001: GO 19484
19003: LD_INT 27
19005: DOUBLE
19006: EQUAL
19007: IFTRUE 19011
19009: GO 19029
19011: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
19012: LD_ADDR_VAR 0 3
19016: PUSH
19017: LD_INT 13
19019: PUSH
19020: LD_INT 14
19022: PUSH
19023: EMPTY
19024: LIST
19025: LIST
19026: ST_TO_ADDR
19027: GO 19484
19029: LD_INT 92
19031: DOUBLE
19032: EQUAL
19033: IFTRUE 19037
19035: GO 19063
19037: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19038: LD_ADDR_VAR 0 3
19042: PUSH
19043: LD_INT 11
19045: PUSH
19046: LD_INT 12
19048: PUSH
19049: LD_INT 13
19051: PUSH
19052: LD_INT 14
19054: PUSH
19055: EMPTY
19056: LIST
19057: LIST
19058: LIST
19059: LIST
19060: ST_TO_ADDR
19061: GO 19484
19063: LD_INT 28
19065: DOUBLE
19066: EQUAL
19067: IFTRUE 19071
19069: GO 19089
19071: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19072: LD_ADDR_VAR 0 3
19076: PUSH
19077: LD_INT 13
19079: PUSH
19080: LD_INT 14
19082: PUSH
19083: EMPTY
19084: LIST
19085: LIST
19086: ST_TO_ADDR
19087: GO 19484
19089: LD_INT 29
19091: DOUBLE
19092: EQUAL
19093: IFTRUE 19097
19095: GO 19115
19097: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19098: LD_ADDR_VAR 0 3
19102: PUSH
19103: LD_INT 13
19105: PUSH
19106: LD_INT 14
19108: PUSH
19109: EMPTY
19110: LIST
19111: LIST
19112: ST_TO_ADDR
19113: GO 19484
19115: LD_INT 31
19117: DOUBLE
19118: EQUAL
19119: IFTRUE 19123
19121: GO 19141
19123: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19124: LD_ADDR_VAR 0 3
19128: PUSH
19129: LD_INT 13
19131: PUSH
19132: LD_INT 14
19134: PUSH
19135: EMPTY
19136: LIST
19137: LIST
19138: ST_TO_ADDR
19139: GO 19484
19141: LD_INT 26
19143: DOUBLE
19144: EQUAL
19145: IFTRUE 19149
19147: GO 19167
19149: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19150: LD_ADDR_VAR 0 3
19154: PUSH
19155: LD_INT 13
19157: PUSH
19158: LD_INT 14
19160: PUSH
19161: EMPTY
19162: LIST
19163: LIST
19164: ST_TO_ADDR
19165: GO 19484
19167: LD_INT 42
19169: DOUBLE
19170: EQUAL
19171: IFTRUE 19175
19173: GO 19201
19175: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19176: LD_ADDR_VAR 0 3
19180: PUSH
19181: LD_INT 21
19183: PUSH
19184: LD_INT 22
19186: PUSH
19187: LD_INT 23
19189: PUSH
19190: LD_INT 24
19192: PUSH
19193: EMPTY
19194: LIST
19195: LIST
19196: LIST
19197: LIST
19198: ST_TO_ADDR
19199: GO 19484
19201: LD_INT 43
19203: DOUBLE
19204: EQUAL
19205: IFTRUE 19209
19207: GO 19235
19209: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19210: LD_ADDR_VAR 0 3
19214: PUSH
19215: LD_INT 21
19217: PUSH
19218: LD_INT 22
19220: PUSH
19221: LD_INT 23
19223: PUSH
19224: LD_INT 24
19226: PUSH
19227: EMPTY
19228: LIST
19229: LIST
19230: LIST
19231: LIST
19232: ST_TO_ADDR
19233: GO 19484
19235: LD_INT 44
19237: DOUBLE
19238: EQUAL
19239: IFTRUE 19243
19241: GO 19269
19243: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19244: LD_ADDR_VAR 0 3
19248: PUSH
19249: LD_INT 21
19251: PUSH
19252: LD_INT 22
19254: PUSH
19255: LD_INT 23
19257: PUSH
19258: LD_INT 24
19260: PUSH
19261: EMPTY
19262: LIST
19263: LIST
19264: LIST
19265: LIST
19266: ST_TO_ADDR
19267: GO 19484
19269: LD_INT 45
19271: DOUBLE
19272: EQUAL
19273: IFTRUE 19277
19275: GO 19303
19277: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19278: LD_ADDR_VAR 0 3
19282: PUSH
19283: LD_INT 21
19285: PUSH
19286: LD_INT 22
19288: PUSH
19289: LD_INT 23
19291: PUSH
19292: LD_INT 24
19294: PUSH
19295: EMPTY
19296: LIST
19297: LIST
19298: LIST
19299: LIST
19300: ST_TO_ADDR
19301: GO 19484
19303: LD_INT 49
19305: DOUBLE
19306: EQUAL
19307: IFTRUE 19311
19309: GO 19337
19311: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19312: LD_ADDR_VAR 0 3
19316: PUSH
19317: LD_INT 21
19319: PUSH
19320: LD_INT 22
19322: PUSH
19323: LD_INT 23
19325: PUSH
19326: LD_INT 24
19328: PUSH
19329: EMPTY
19330: LIST
19331: LIST
19332: LIST
19333: LIST
19334: ST_TO_ADDR
19335: GO 19484
19337: LD_INT 51
19339: DOUBLE
19340: EQUAL
19341: IFTRUE 19345
19343: GO 19371
19345: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19346: LD_ADDR_VAR 0 3
19350: PUSH
19351: LD_INT 21
19353: PUSH
19354: LD_INT 22
19356: PUSH
19357: LD_INT 23
19359: PUSH
19360: LD_INT 24
19362: PUSH
19363: EMPTY
19364: LIST
19365: LIST
19366: LIST
19367: LIST
19368: ST_TO_ADDR
19369: GO 19484
19371: LD_INT 52
19373: DOUBLE
19374: EQUAL
19375: IFTRUE 19379
19377: GO 19405
19379: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19380: LD_ADDR_VAR 0 3
19384: PUSH
19385: LD_INT 21
19387: PUSH
19388: LD_INT 22
19390: PUSH
19391: LD_INT 23
19393: PUSH
19394: LD_INT 24
19396: PUSH
19397: EMPTY
19398: LIST
19399: LIST
19400: LIST
19401: LIST
19402: ST_TO_ADDR
19403: GO 19484
19405: LD_INT 53
19407: DOUBLE
19408: EQUAL
19409: IFTRUE 19413
19411: GO 19431
19413: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19414: LD_ADDR_VAR 0 3
19418: PUSH
19419: LD_INT 23
19421: PUSH
19422: LD_INT 24
19424: PUSH
19425: EMPTY
19426: LIST
19427: LIST
19428: ST_TO_ADDR
19429: GO 19484
19431: LD_INT 46
19433: DOUBLE
19434: EQUAL
19435: IFTRUE 19439
19437: GO 19457
19439: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19440: LD_ADDR_VAR 0 3
19444: PUSH
19445: LD_INT 23
19447: PUSH
19448: LD_INT 24
19450: PUSH
19451: EMPTY
19452: LIST
19453: LIST
19454: ST_TO_ADDR
19455: GO 19484
19457: LD_INT 47
19459: DOUBLE
19460: EQUAL
19461: IFTRUE 19465
19463: GO 19483
19465: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19466: LD_ADDR_VAR 0 3
19470: PUSH
19471: LD_INT 23
19473: PUSH
19474: LD_INT 24
19476: PUSH
19477: EMPTY
19478: LIST
19479: LIST
19480: ST_TO_ADDR
19481: GO 19484
19483: POP
// result := ( chassis in result ) ;
19484: LD_ADDR_VAR 0 3
19488: PUSH
19489: LD_VAR 0 1
19493: PUSH
19494: LD_VAR 0 3
19498: IN
19499: ST_TO_ADDR
// end ;
19500: LD_VAR 0 3
19504: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19505: LD_INT 0
19507: PPUSH
19508: PPUSH
19509: PPUSH
19510: PPUSH
19511: PPUSH
19512: PPUSH
19513: PPUSH
// result := array ;
19514: LD_ADDR_VAR 0 5
19518: PUSH
19519: LD_VAR 0 1
19523: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19524: LD_VAR 0 1
19528: NOT
19529: PUSH
19530: LD_VAR 0 2
19534: NOT
19535: OR
19536: PUSH
19537: LD_VAR 0 3
19541: NOT
19542: OR
19543: PUSH
19544: LD_VAR 0 2
19548: PUSH
19549: LD_VAR 0 1
19553: GREATER
19554: OR
19555: PUSH
19556: LD_VAR 0 3
19560: PUSH
19561: LD_VAR 0 1
19565: GREATER
19566: OR
19567: IFFALSE 19571
// exit ;
19569: GO 19867
// if direction then
19571: LD_VAR 0 4
19575: IFFALSE 19639
// begin d := 1 ;
19577: LD_ADDR_VAR 0 9
19581: PUSH
19582: LD_INT 1
19584: ST_TO_ADDR
// if i_from > i_to then
19585: LD_VAR 0 2
19589: PUSH
19590: LD_VAR 0 3
19594: GREATER
19595: IFFALSE 19621
// length := ( array - i_from ) + i_to else
19597: LD_ADDR_VAR 0 11
19601: PUSH
19602: LD_VAR 0 1
19606: PUSH
19607: LD_VAR 0 2
19611: MINUS
19612: PUSH
19613: LD_VAR 0 3
19617: PLUS
19618: ST_TO_ADDR
19619: GO 19637
// length := i_to - i_from ;
19621: LD_ADDR_VAR 0 11
19625: PUSH
19626: LD_VAR 0 3
19630: PUSH
19631: LD_VAR 0 2
19635: MINUS
19636: ST_TO_ADDR
// end else
19637: GO 19700
// begin d := - 1 ;
19639: LD_ADDR_VAR 0 9
19643: PUSH
19644: LD_INT 1
19646: NEG
19647: ST_TO_ADDR
// if i_from > i_to then
19648: LD_VAR 0 2
19652: PUSH
19653: LD_VAR 0 3
19657: GREATER
19658: IFFALSE 19678
// length := i_from - i_to else
19660: LD_ADDR_VAR 0 11
19664: PUSH
19665: LD_VAR 0 2
19669: PUSH
19670: LD_VAR 0 3
19674: MINUS
19675: ST_TO_ADDR
19676: GO 19700
// length := ( array - i_to ) + i_from ;
19678: LD_ADDR_VAR 0 11
19682: PUSH
19683: LD_VAR 0 1
19687: PUSH
19688: LD_VAR 0 3
19692: MINUS
19693: PUSH
19694: LD_VAR 0 2
19698: PLUS
19699: ST_TO_ADDR
// end ; if not length then
19700: LD_VAR 0 11
19704: NOT
19705: IFFALSE 19709
// exit ;
19707: GO 19867
// tmp := array ;
19709: LD_ADDR_VAR 0 10
19713: PUSH
19714: LD_VAR 0 1
19718: ST_TO_ADDR
// for i = 1 to length do
19719: LD_ADDR_VAR 0 6
19723: PUSH
19724: DOUBLE
19725: LD_INT 1
19727: DEC
19728: ST_TO_ADDR
19729: LD_VAR 0 11
19733: PUSH
19734: FOR_TO
19735: IFFALSE 19855
// begin for j = 1 to array do
19737: LD_ADDR_VAR 0 7
19741: PUSH
19742: DOUBLE
19743: LD_INT 1
19745: DEC
19746: ST_TO_ADDR
19747: LD_VAR 0 1
19751: PUSH
19752: FOR_TO
19753: IFFALSE 19841
// begin k := j + d ;
19755: LD_ADDR_VAR 0 8
19759: PUSH
19760: LD_VAR 0 7
19764: PUSH
19765: LD_VAR 0 9
19769: PLUS
19770: ST_TO_ADDR
// if k > array then
19771: LD_VAR 0 8
19775: PUSH
19776: LD_VAR 0 1
19780: GREATER
19781: IFFALSE 19791
// k := 1 ;
19783: LD_ADDR_VAR 0 8
19787: PUSH
19788: LD_INT 1
19790: ST_TO_ADDR
// if not k then
19791: LD_VAR 0 8
19795: NOT
19796: IFFALSE 19808
// k := array ;
19798: LD_ADDR_VAR 0 8
19802: PUSH
19803: LD_VAR 0 1
19807: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19808: LD_ADDR_VAR 0 10
19812: PUSH
19813: LD_VAR 0 10
19817: PPUSH
19818: LD_VAR 0 8
19822: PPUSH
19823: LD_VAR 0 1
19827: PUSH
19828: LD_VAR 0 7
19832: ARRAY
19833: PPUSH
19834: CALL_OW 1
19838: ST_TO_ADDR
// end ;
19839: GO 19752
19841: POP
19842: POP
// array := tmp ;
19843: LD_ADDR_VAR 0 1
19847: PUSH
19848: LD_VAR 0 10
19852: ST_TO_ADDR
// end ;
19853: GO 19734
19855: POP
19856: POP
// result := array ;
19857: LD_ADDR_VAR 0 5
19861: PUSH
19862: LD_VAR 0 1
19866: ST_TO_ADDR
// end ;
19867: LD_VAR 0 5
19871: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19872: LD_INT 0
19874: PPUSH
19875: PPUSH
// result := 0 ;
19876: LD_ADDR_VAR 0 3
19880: PUSH
19881: LD_INT 0
19883: ST_TO_ADDR
// if not array or not value in array then
19884: LD_VAR 0 1
19888: NOT
19889: PUSH
19890: LD_VAR 0 2
19894: PUSH
19895: LD_VAR 0 1
19899: IN
19900: NOT
19901: OR
19902: IFFALSE 19906
// exit ;
19904: GO 19960
// for i = 1 to array do
19906: LD_ADDR_VAR 0 4
19910: PUSH
19911: DOUBLE
19912: LD_INT 1
19914: DEC
19915: ST_TO_ADDR
19916: LD_VAR 0 1
19920: PUSH
19921: FOR_TO
19922: IFFALSE 19958
// if value = array [ i ] then
19924: LD_VAR 0 2
19928: PUSH
19929: LD_VAR 0 1
19933: PUSH
19934: LD_VAR 0 4
19938: ARRAY
19939: EQUAL
19940: IFFALSE 19956
// begin result := i ;
19942: LD_ADDR_VAR 0 3
19946: PUSH
19947: LD_VAR 0 4
19951: ST_TO_ADDR
// exit ;
19952: POP
19953: POP
19954: GO 19960
// end ;
19956: GO 19921
19958: POP
19959: POP
// end ;
19960: LD_VAR 0 3
19964: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19965: LD_INT 0
19967: PPUSH
// vc_chassis := chassis ;
19968: LD_ADDR_OWVAR 37
19972: PUSH
19973: LD_VAR 0 1
19977: ST_TO_ADDR
// vc_engine := engine ;
19978: LD_ADDR_OWVAR 39
19982: PUSH
19983: LD_VAR 0 2
19987: ST_TO_ADDR
// vc_control := control ;
19988: LD_ADDR_OWVAR 38
19992: PUSH
19993: LD_VAR 0 3
19997: ST_TO_ADDR
// vc_weapon := weapon ;
19998: LD_ADDR_OWVAR 40
20002: PUSH
20003: LD_VAR 0 4
20007: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20008: LD_ADDR_OWVAR 41
20012: PUSH
20013: LD_VAR 0 5
20017: ST_TO_ADDR
// end ;
20018: LD_VAR 0 6
20022: RET
// export function WantPlant ( unit ) ; var task ; begin
20023: LD_INT 0
20025: PPUSH
20026: PPUSH
// result := false ;
20027: LD_ADDR_VAR 0 2
20031: PUSH
20032: LD_INT 0
20034: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20035: LD_ADDR_VAR 0 3
20039: PUSH
20040: LD_VAR 0 1
20044: PPUSH
20045: CALL_OW 437
20049: ST_TO_ADDR
// if task then
20050: LD_VAR 0 3
20054: IFFALSE 20082
// if task [ 1 ] [ 1 ] = p then
20056: LD_VAR 0 3
20060: PUSH
20061: LD_INT 1
20063: ARRAY
20064: PUSH
20065: LD_INT 1
20067: ARRAY
20068: PUSH
20069: LD_STRING p
20071: EQUAL
20072: IFFALSE 20082
// result := true ;
20074: LD_ADDR_VAR 0 2
20078: PUSH
20079: LD_INT 1
20081: ST_TO_ADDR
// end ;
20082: LD_VAR 0 2
20086: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20087: LD_INT 0
20089: PPUSH
20090: PPUSH
20091: PPUSH
20092: PPUSH
// if pos < 1 then
20093: LD_VAR 0 2
20097: PUSH
20098: LD_INT 1
20100: LESS
20101: IFFALSE 20105
// exit ;
20103: GO 20408
// if pos = 1 then
20105: LD_VAR 0 2
20109: PUSH
20110: LD_INT 1
20112: EQUAL
20113: IFFALSE 20146
// result := Replace ( arr , pos [ 1 ] , value ) else
20115: LD_ADDR_VAR 0 4
20119: PUSH
20120: LD_VAR 0 1
20124: PPUSH
20125: LD_VAR 0 2
20129: PUSH
20130: LD_INT 1
20132: ARRAY
20133: PPUSH
20134: LD_VAR 0 3
20138: PPUSH
20139: CALL_OW 1
20143: ST_TO_ADDR
20144: GO 20408
// begin tmp := arr ;
20146: LD_ADDR_VAR 0 6
20150: PUSH
20151: LD_VAR 0 1
20155: ST_TO_ADDR
// s_arr := [ tmp ] ;
20156: LD_ADDR_VAR 0 7
20160: PUSH
20161: LD_VAR 0 6
20165: PUSH
20166: EMPTY
20167: LIST
20168: ST_TO_ADDR
// for i = 1 to pos - 1 do
20169: LD_ADDR_VAR 0 5
20173: PUSH
20174: DOUBLE
20175: LD_INT 1
20177: DEC
20178: ST_TO_ADDR
20179: LD_VAR 0 2
20183: PUSH
20184: LD_INT 1
20186: MINUS
20187: PUSH
20188: FOR_TO
20189: IFFALSE 20234
// begin tmp := tmp [ pos [ i ] ] ;
20191: LD_ADDR_VAR 0 6
20195: PUSH
20196: LD_VAR 0 6
20200: PUSH
20201: LD_VAR 0 2
20205: PUSH
20206: LD_VAR 0 5
20210: ARRAY
20211: ARRAY
20212: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20213: LD_ADDR_VAR 0 7
20217: PUSH
20218: LD_VAR 0 7
20222: PUSH
20223: LD_VAR 0 6
20227: PUSH
20228: EMPTY
20229: LIST
20230: ADD
20231: ST_TO_ADDR
// end ;
20232: GO 20188
20234: POP
20235: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20236: LD_ADDR_VAR 0 6
20240: PUSH
20241: LD_VAR 0 6
20245: PPUSH
20246: LD_VAR 0 2
20250: PUSH
20251: LD_VAR 0 2
20255: ARRAY
20256: PPUSH
20257: LD_VAR 0 3
20261: PPUSH
20262: CALL_OW 1
20266: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20267: LD_ADDR_VAR 0 7
20271: PUSH
20272: LD_VAR 0 7
20276: PPUSH
20277: LD_VAR 0 7
20281: PPUSH
20282: LD_VAR 0 6
20286: PPUSH
20287: CALL_OW 1
20291: ST_TO_ADDR
// for i = s_arr downto 2 do
20292: LD_ADDR_VAR 0 5
20296: PUSH
20297: DOUBLE
20298: LD_VAR 0 7
20302: INC
20303: ST_TO_ADDR
20304: LD_INT 2
20306: PUSH
20307: FOR_DOWNTO
20308: IFFALSE 20392
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20310: LD_ADDR_VAR 0 6
20314: PUSH
20315: LD_VAR 0 7
20319: PUSH
20320: LD_VAR 0 5
20324: PUSH
20325: LD_INT 1
20327: MINUS
20328: ARRAY
20329: PPUSH
20330: LD_VAR 0 2
20334: PUSH
20335: LD_VAR 0 5
20339: PUSH
20340: LD_INT 1
20342: MINUS
20343: ARRAY
20344: PPUSH
20345: LD_VAR 0 7
20349: PUSH
20350: LD_VAR 0 5
20354: ARRAY
20355: PPUSH
20356: CALL_OW 1
20360: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20361: LD_ADDR_VAR 0 7
20365: PUSH
20366: LD_VAR 0 7
20370: PPUSH
20371: LD_VAR 0 5
20375: PUSH
20376: LD_INT 1
20378: MINUS
20379: PPUSH
20380: LD_VAR 0 6
20384: PPUSH
20385: CALL_OW 1
20389: ST_TO_ADDR
// end ;
20390: GO 20307
20392: POP
20393: POP
// result := s_arr [ 1 ] ;
20394: LD_ADDR_VAR 0 4
20398: PUSH
20399: LD_VAR 0 7
20403: PUSH
20404: LD_INT 1
20406: ARRAY
20407: ST_TO_ADDR
// end ; end ;
20408: LD_VAR 0 4
20412: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20413: LD_INT 0
20415: PPUSH
20416: PPUSH
// if not list then
20417: LD_VAR 0 1
20421: NOT
20422: IFFALSE 20426
// exit ;
20424: GO 20517
// i := list [ pos1 ] ;
20426: LD_ADDR_VAR 0 5
20430: PUSH
20431: LD_VAR 0 1
20435: PUSH
20436: LD_VAR 0 2
20440: ARRAY
20441: ST_TO_ADDR
// if not i then
20442: LD_VAR 0 5
20446: NOT
20447: IFFALSE 20451
// exit ;
20449: GO 20517
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20451: LD_ADDR_VAR 0 1
20455: PUSH
20456: LD_VAR 0 1
20460: PPUSH
20461: LD_VAR 0 2
20465: PPUSH
20466: LD_VAR 0 1
20470: PUSH
20471: LD_VAR 0 3
20475: ARRAY
20476: PPUSH
20477: CALL_OW 1
20481: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20482: LD_ADDR_VAR 0 1
20486: PUSH
20487: LD_VAR 0 1
20491: PPUSH
20492: LD_VAR 0 3
20496: PPUSH
20497: LD_VAR 0 5
20501: PPUSH
20502: CALL_OW 1
20506: ST_TO_ADDR
// result := list ;
20507: LD_ADDR_VAR 0 4
20511: PUSH
20512: LD_VAR 0 1
20516: ST_TO_ADDR
// end ;
20517: LD_VAR 0 4
20521: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20522: LD_INT 0
20524: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20525: LD_ADDR_VAR 0 5
20529: PUSH
20530: LD_VAR 0 1
20534: PPUSH
20535: CALL_OW 250
20539: PPUSH
20540: LD_VAR 0 1
20544: PPUSH
20545: CALL_OW 251
20549: PPUSH
20550: LD_VAR 0 2
20554: PPUSH
20555: LD_VAR 0 3
20559: PPUSH
20560: LD_VAR 0 4
20564: PPUSH
20565: CALL 20575 0 5
20569: ST_TO_ADDR
// end ;
20570: LD_VAR 0 5
20574: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20575: LD_INT 0
20577: PPUSH
20578: PPUSH
20579: PPUSH
20580: PPUSH
// if not list then
20581: LD_VAR 0 3
20585: NOT
20586: IFFALSE 20590
// exit ;
20588: GO 20978
// result := [ ] ;
20590: LD_ADDR_VAR 0 6
20594: PUSH
20595: EMPTY
20596: ST_TO_ADDR
// for i in list do
20597: LD_ADDR_VAR 0 7
20601: PUSH
20602: LD_VAR 0 3
20606: PUSH
20607: FOR_IN
20608: IFFALSE 20810
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20610: LD_ADDR_VAR 0 9
20614: PUSH
20615: LD_VAR 0 7
20619: PPUSH
20620: LD_VAR 0 1
20624: PPUSH
20625: LD_VAR 0 2
20629: PPUSH
20630: CALL_OW 297
20634: ST_TO_ADDR
// if not result then
20635: LD_VAR 0 6
20639: NOT
20640: IFFALSE 20666
// result := [ [ i , tmp ] ] else
20642: LD_ADDR_VAR 0 6
20646: PUSH
20647: LD_VAR 0 7
20651: PUSH
20652: LD_VAR 0 9
20656: PUSH
20657: EMPTY
20658: LIST
20659: LIST
20660: PUSH
20661: EMPTY
20662: LIST
20663: ST_TO_ADDR
20664: GO 20808
// begin if result [ result ] [ 2 ] < tmp then
20666: LD_VAR 0 6
20670: PUSH
20671: LD_VAR 0 6
20675: ARRAY
20676: PUSH
20677: LD_INT 2
20679: ARRAY
20680: PUSH
20681: LD_VAR 0 9
20685: LESS
20686: IFFALSE 20728
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20688: LD_ADDR_VAR 0 6
20692: PUSH
20693: LD_VAR 0 6
20697: PPUSH
20698: LD_VAR 0 6
20702: PUSH
20703: LD_INT 1
20705: PLUS
20706: PPUSH
20707: LD_VAR 0 7
20711: PUSH
20712: LD_VAR 0 9
20716: PUSH
20717: EMPTY
20718: LIST
20719: LIST
20720: PPUSH
20721: CALL_OW 2
20725: ST_TO_ADDR
20726: GO 20808
// for j = 1 to result do
20728: LD_ADDR_VAR 0 8
20732: PUSH
20733: DOUBLE
20734: LD_INT 1
20736: DEC
20737: ST_TO_ADDR
20738: LD_VAR 0 6
20742: PUSH
20743: FOR_TO
20744: IFFALSE 20806
// begin if tmp < result [ j ] [ 2 ] then
20746: LD_VAR 0 9
20750: PUSH
20751: LD_VAR 0 6
20755: PUSH
20756: LD_VAR 0 8
20760: ARRAY
20761: PUSH
20762: LD_INT 2
20764: ARRAY
20765: LESS
20766: IFFALSE 20804
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20768: LD_ADDR_VAR 0 6
20772: PUSH
20773: LD_VAR 0 6
20777: PPUSH
20778: LD_VAR 0 8
20782: PPUSH
20783: LD_VAR 0 7
20787: PUSH
20788: LD_VAR 0 9
20792: PUSH
20793: EMPTY
20794: LIST
20795: LIST
20796: PPUSH
20797: CALL_OW 2
20801: ST_TO_ADDR
// break ;
20802: GO 20806
// end ; end ;
20804: GO 20743
20806: POP
20807: POP
// end ; end ;
20808: GO 20607
20810: POP
20811: POP
// if result and not asc then
20812: LD_VAR 0 6
20816: PUSH
20817: LD_VAR 0 4
20821: NOT
20822: AND
20823: IFFALSE 20898
// begin tmp := result ;
20825: LD_ADDR_VAR 0 9
20829: PUSH
20830: LD_VAR 0 6
20834: ST_TO_ADDR
// for i = tmp downto 1 do
20835: LD_ADDR_VAR 0 7
20839: PUSH
20840: DOUBLE
20841: LD_VAR 0 9
20845: INC
20846: ST_TO_ADDR
20847: LD_INT 1
20849: PUSH
20850: FOR_DOWNTO
20851: IFFALSE 20896
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20853: LD_ADDR_VAR 0 6
20857: PUSH
20858: LD_VAR 0 6
20862: PPUSH
20863: LD_VAR 0 9
20867: PUSH
20868: LD_VAR 0 7
20872: MINUS
20873: PUSH
20874: LD_INT 1
20876: PLUS
20877: PPUSH
20878: LD_VAR 0 9
20882: PUSH
20883: LD_VAR 0 7
20887: ARRAY
20888: PPUSH
20889: CALL_OW 1
20893: ST_TO_ADDR
20894: GO 20850
20896: POP
20897: POP
// end ; tmp := [ ] ;
20898: LD_ADDR_VAR 0 9
20902: PUSH
20903: EMPTY
20904: ST_TO_ADDR
// if mode then
20905: LD_VAR 0 5
20909: IFFALSE 20978
// begin for i = 1 to result do
20911: LD_ADDR_VAR 0 7
20915: PUSH
20916: DOUBLE
20917: LD_INT 1
20919: DEC
20920: ST_TO_ADDR
20921: LD_VAR 0 6
20925: PUSH
20926: FOR_TO
20927: IFFALSE 20966
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20929: LD_ADDR_VAR 0 9
20933: PUSH
20934: LD_VAR 0 9
20938: PPUSH
20939: LD_VAR 0 7
20943: PPUSH
20944: LD_VAR 0 6
20948: PUSH
20949: LD_VAR 0 7
20953: ARRAY
20954: PUSH
20955: LD_INT 1
20957: ARRAY
20958: PPUSH
20959: CALL_OW 1
20963: ST_TO_ADDR
20964: GO 20926
20966: POP
20967: POP
// result := tmp ;
20968: LD_ADDR_VAR 0 6
20972: PUSH
20973: LD_VAR 0 9
20977: ST_TO_ADDR
// end ; end ;
20978: LD_VAR 0 6
20982: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20983: LD_INT 0
20985: PPUSH
20986: PPUSH
20987: PPUSH
20988: PPUSH
20989: PPUSH
20990: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20991: LD_ADDR_VAR 0 5
20995: PUSH
20996: LD_INT 0
20998: PUSH
20999: LD_INT 0
21001: PUSH
21002: LD_INT 0
21004: PUSH
21005: EMPTY
21006: PUSH
21007: EMPTY
21008: LIST
21009: LIST
21010: LIST
21011: LIST
21012: ST_TO_ADDR
// if not x or not y then
21013: LD_VAR 0 2
21017: NOT
21018: PUSH
21019: LD_VAR 0 3
21023: NOT
21024: OR
21025: IFFALSE 21029
// exit ;
21027: GO 22679
// if not range then
21029: LD_VAR 0 4
21033: NOT
21034: IFFALSE 21044
// range := 10 ;
21036: LD_ADDR_VAR 0 4
21040: PUSH
21041: LD_INT 10
21043: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21044: LD_ADDR_VAR 0 8
21048: PUSH
21049: LD_INT 81
21051: PUSH
21052: LD_VAR 0 1
21056: PUSH
21057: EMPTY
21058: LIST
21059: LIST
21060: PUSH
21061: LD_INT 92
21063: PUSH
21064: LD_VAR 0 2
21068: PUSH
21069: LD_VAR 0 3
21073: PUSH
21074: LD_VAR 0 4
21078: PUSH
21079: EMPTY
21080: LIST
21081: LIST
21082: LIST
21083: LIST
21084: PUSH
21085: LD_INT 3
21087: PUSH
21088: LD_INT 21
21090: PUSH
21091: LD_INT 3
21093: PUSH
21094: EMPTY
21095: LIST
21096: LIST
21097: PUSH
21098: EMPTY
21099: LIST
21100: LIST
21101: PUSH
21102: EMPTY
21103: LIST
21104: LIST
21105: LIST
21106: PPUSH
21107: CALL_OW 69
21111: ST_TO_ADDR
// if not tmp then
21112: LD_VAR 0 8
21116: NOT
21117: IFFALSE 21121
// exit ;
21119: GO 22679
// for i in tmp do
21121: LD_ADDR_VAR 0 6
21125: PUSH
21126: LD_VAR 0 8
21130: PUSH
21131: FOR_IN
21132: IFFALSE 22654
// begin points := [ 0 , 0 , 0 ] ;
21134: LD_ADDR_VAR 0 9
21138: PUSH
21139: LD_INT 0
21141: PUSH
21142: LD_INT 0
21144: PUSH
21145: LD_INT 0
21147: PUSH
21148: EMPTY
21149: LIST
21150: LIST
21151: LIST
21152: ST_TO_ADDR
// bpoints := 1 ;
21153: LD_ADDR_VAR 0 10
21157: PUSH
21158: LD_INT 1
21160: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21161: LD_VAR 0 6
21165: PPUSH
21166: CALL_OW 247
21170: PUSH
21171: LD_INT 1
21173: DOUBLE
21174: EQUAL
21175: IFTRUE 21179
21177: GO 21757
21179: POP
// begin if GetClass ( i ) = 1 then
21180: LD_VAR 0 6
21184: PPUSH
21185: CALL_OW 257
21189: PUSH
21190: LD_INT 1
21192: EQUAL
21193: IFFALSE 21214
// points := [ 10 , 5 , 3 ] ;
21195: LD_ADDR_VAR 0 9
21199: PUSH
21200: LD_INT 10
21202: PUSH
21203: LD_INT 5
21205: PUSH
21206: LD_INT 3
21208: PUSH
21209: EMPTY
21210: LIST
21211: LIST
21212: LIST
21213: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21214: LD_VAR 0 6
21218: PPUSH
21219: CALL_OW 257
21223: PUSH
21224: LD_INT 2
21226: PUSH
21227: LD_INT 3
21229: PUSH
21230: LD_INT 4
21232: PUSH
21233: EMPTY
21234: LIST
21235: LIST
21236: LIST
21237: IN
21238: IFFALSE 21259
// points := [ 3 , 2 , 1 ] ;
21240: LD_ADDR_VAR 0 9
21244: PUSH
21245: LD_INT 3
21247: PUSH
21248: LD_INT 2
21250: PUSH
21251: LD_INT 1
21253: PUSH
21254: EMPTY
21255: LIST
21256: LIST
21257: LIST
21258: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21259: LD_VAR 0 6
21263: PPUSH
21264: CALL_OW 257
21268: PUSH
21269: LD_INT 5
21271: EQUAL
21272: IFFALSE 21293
// points := [ 130 , 5 , 2 ] ;
21274: LD_ADDR_VAR 0 9
21278: PUSH
21279: LD_INT 130
21281: PUSH
21282: LD_INT 5
21284: PUSH
21285: LD_INT 2
21287: PUSH
21288: EMPTY
21289: LIST
21290: LIST
21291: LIST
21292: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21293: LD_VAR 0 6
21297: PPUSH
21298: CALL_OW 257
21302: PUSH
21303: LD_INT 8
21305: EQUAL
21306: IFFALSE 21327
// points := [ 35 , 35 , 30 ] ;
21308: LD_ADDR_VAR 0 9
21312: PUSH
21313: LD_INT 35
21315: PUSH
21316: LD_INT 35
21318: PUSH
21319: LD_INT 30
21321: PUSH
21322: EMPTY
21323: LIST
21324: LIST
21325: LIST
21326: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21327: LD_VAR 0 6
21331: PPUSH
21332: CALL_OW 257
21336: PUSH
21337: LD_INT 9
21339: EQUAL
21340: IFFALSE 21361
// points := [ 20 , 55 , 40 ] ;
21342: LD_ADDR_VAR 0 9
21346: PUSH
21347: LD_INT 20
21349: PUSH
21350: LD_INT 55
21352: PUSH
21353: LD_INT 40
21355: PUSH
21356: EMPTY
21357: LIST
21358: LIST
21359: LIST
21360: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21361: LD_VAR 0 6
21365: PPUSH
21366: CALL_OW 257
21370: PUSH
21371: LD_INT 12
21373: PUSH
21374: LD_INT 16
21376: PUSH
21377: EMPTY
21378: LIST
21379: LIST
21380: IN
21381: IFFALSE 21402
// points := [ 5 , 3 , 2 ] ;
21383: LD_ADDR_VAR 0 9
21387: PUSH
21388: LD_INT 5
21390: PUSH
21391: LD_INT 3
21393: PUSH
21394: LD_INT 2
21396: PUSH
21397: EMPTY
21398: LIST
21399: LIST
21400: LIST
21401: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21402: LD_VAR 0 6
21406: PPUSH
21407: CALL_OW 257
21411: PUSH
21412: LD_INT 17
21414: EQUAL
21415: IFFALSE 21436
// points := [ 100 , 50 , 75 ] ;
21417: LD_ADDR_VAR 0 9
21421: PUSH
21422: LD_INT 100
21424: PUSH
21425: LD_INT 50
21427: PUSH
21428: LD_INT 75
21430: PUSH
21431: EMPTY
21432: LIST
21433: LIST
21434: LIST
21435: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21436: LD_VAR 0 6
21440: PPUSH
21441: CALL_OW 257
21445: PUSH
21446: LD_INT 15
21448: EQUAL
21449: IFFALSE 21470
// points := [ 10 , 5 , 3 ] ;
21451: LD_ADDR_VAR 0 9
21455: PUSH
21456: LD_INT 10
21458: PUSH
21459: LD_INT 5
21461: PUSH
21462: LD_INT 3
21464: PUSH
21465: EMPTY
21466: LIST
21467: LIST
21468: LIST
21469: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21470: LD_VAR 0 6
21474: PPUSH
21475: CALL_OW 257
21479: PUSH
21480: LD_INT 14
21482: EQUAL
21483: IFFALSE 21504
// points := [ 10 , 0 , 0 ] ;
21485: LD_ADDR_VAR 0 9
21489: PUSH
21490: LD_INT 10
21492: PUSH
21493: LD_INT 0
21495: PUSH
21496: LD_INT 0
21498: PUSH
21499: EMPTY
21500: LIST
21501: LIST
21502: LIST
21503: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21504: LD_VAR 0 6
21508: PPUSH
21509: CALL_OW 257
21513: PUSH
21514: LD_INT 11
21516: EQUAL
21517: IFFALSE 21538
// points := [ 30 , 10 , 5 ] ;
21519: LD_ADDR_VAR 0 9
21523: PUSH
21524: LD_INT 30
21526: PUSH
21527: LD_INT 10
21529: PUSH
21530: LD_INT 5
21532: PUSH
21533: EMPTY
21534: LIST
21535: LIST
21536: LIST
21537: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21538: LD_VAR 0 1
21542: PPUSH
21543: LD_INT 5
21545: PPUSH
21546: CALL_OW 321
21550: PUSH
21551: LD_INT 2
21553: EQUAL
21554: IFFALSE 21571
// bpoints := bpoints * 1.8 ;
21556: LD_ADDR_VAR 0 10
21560: PUSH
21561: LD_VAR 0 10
21565: PUSH
21566: LD_REAL  1.80000000000000E+0000
21569: MUL
21570: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21571: LD_VAR 0 6
21575: PPUSH
21576: CALL_OW 257
21580: PUSH
21581: LD_INT 1
21583: PUSH
21584: LD_INT 2
21586: PUSH
21587: LD_INT 3
21589: PUSH
21590: LD_INT 4
21592: PUSH
21593: EMPTY
21594: LIST
21595: LIST
21596: LIST
21597: LIST
21598: IN
21599: PUSH
21600: LD_VAR 0 1
21604: PPUSH
21605: LD_INT 51
21607: PPUSH
21608: CALL_OW 321
21612: PUSH
21613: LD_INT 2
21615: EQUAL
21616: AND
21617: IFFALSE 21634
// bpoints := bpoints * 1.2 ;
21619: LD_ADDR_VAR 0 10
21623: PUSH
21624: LD_VAR 0 10
21628: PUSH
21629: LD_REAL  1.20000000000000E+0000
21632: MUL
21633: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21634: LD_VAR 0 6
21638: PPUSH
21639: CALL_OW 257
21643: PUSH
21644: LD_INT 5
21646: PUSH
21647: LD_INT 7
21649: PUSH
21650: LD_INT 9
21652: PUSH
21653: EMPTY
21654: LIST
21655: LIST
21656: LIST
21657: IN
21658: PUSH
21659: LD_VAR 0 1
21663: PPUSH
21664: LD_INT 52
21666: PPUSH
21667: CALL_OW 321
21671: PUSH
21672: LD_INT 2
21674: EQUAL
21675: AND
21676: IFFALSE 21693
// bpoints := bpoints * 1.5 ;
21678: LD_ADDR_VAR 0 10
21682: PUSH
21683: LD_VAR 0 10
21687: PUSH
21688: LD_REAL  1.50000000000000E+0000
21691: MUL
21692: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21693: LD_VAR 0 1
21697: PPUSH
21698: LD_INT 66
21700: PPUSH
21701: CALL_OW 321
21705: PUSH
21706: LD_INT 2
21708: EQUAL
21709: IFFALSE 21726
// bpoints := bpoints * 1.1 ;
21711: LD_ADDR_VAR 0 10
21715: PUSH
21716: LD_VAR 0 10
21720: PUSH
21721: LD_REAL  1.10000000000000E+0000
21724: MUL
21725: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21726: LD_ADDR_VAR 0 10
21730: PUSH
21731: LD_VAR 0 10
21735: PUSH
21736: LD_VAR 0 6
21740: PPUSH
21741: LD_INT 1
21743: PPUSH
21744: CALL_OW 259
21748: PUSH
21749: LD_REAL  1.15000000000000E+0000
21752: MUL
21753: MUL
21754: ST_TO_ADDR
// end ; unit_vehicle :
21755: GO 22583
21757: LD_INT 2
21759: DOUBLE
21760: EQUAL
21761: IFTRUE 21765
21763: GO 22571
21765: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21766: LD_VAR 0 6
21770: PPUSH
21771: CALL_OW 264
21775: PUSH
21776: LD_INT 2
21778: PUSH
21779: LD_INT 42
21781: PUSH
21782: LD_INT 24
21784: PUSH
21785: EMPTY
21786: LIST
21787: LIST
21788: LIST
21789: IN
21790: IFFALSE 21811
// points := [ 25 , 5 , 3 ] ;
21792: LD_ADDR_VAR 0 9
21796: PUSH
21797: LD_INT 25
21799: PUSH
21800: LD_INT 5
21802: PUSH
21803: LD_INT 3
21805: PUSH
21806: EMPTY
21807: LIST
21808: LIST
21809: LIST
21810: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21811: LD_VAR 0 6
21815: PPUSH
21816: CALL_OW 264
21820: PUSH
21821: LD_INT 4
21823: PUSH
21824: LD_INT 43
21826: PUSH
21827: LD_INT 25
21829: PUSH
21830: EMPTY
21831: LIST
21832: LIST
21833: LIST
21834: IN
21835: IFFALSE 21856
// points := [ 40 , 15 , 5 ] ;
21837: LD_ADDR_VAR 0 9
21841: PUSH
21842: LD_INT 40
21844: PUSH
21845: LD_INT 15
21847: PUSH
21848: LD_INT 5
21850: PUSH
21851: EMPTY
21852: LIST
21853: LIST
21854: LIST
21855: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21856: LD_VAR 0 6
21860: PPUSH
21861: CALL_OW 264
21865: PUSH
21866: LD_INT 3
21868: PUSH
21869: LD_INT 23
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: IN
21876: IFFALSE 21897
// points := [ 7 , 25 , 8 ] ;
21878: LD_ADDR_VAR 0 9
21882: PUSH
21883: LD_INT 7
21885: PUSH
21886: LD_INT 25
21888: PUSH
21889: LD_INT 8
21891: PUSH
21892: EMPTY
21893: LIST
21894: LIST
21895: LIST
21896: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21897: LD_VAR 0 6
21901: PPUSH
21902: CALL_OW 264
21906: PUSH
21907: LD_INT 5
21909: PUSH
21910: LD_INT 27
21912: PUSH
21913: LD_INT 44
21915: PUSH
21916: EMPTY
21917: LIST
21918: LIST
21919: LIST
21920: IN
21921: IFFALSE 21942
// points := [ 14 , 50 , 16 ] ;
21923: LD_ADDR_VAR 0 9
21927: PUSH
21928: LD_INT 14
21930: PUSH
21931: LD_INT 50
21933: PUSH
21934: LD_INT 16
21936: PUSH
21937: EMPTY
21938: LIST
21939: LIST
21940: LIST
21941: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21942: LD_VAR 0 6
21946: PPUSH
21947: CALL_OW 264
21951: PUSH
21952: LD_INT 6
21954: PUSH
21955: LD_INT 46
21957: PUSH
21958: EMPTY
21959: LIST
21960: LIST
21961: IN
21962: IFFALSE 21983
// points := [ 32 , 120 , 70 ] ;
21964: LD_ADDR_VAR 0 9
21968: PUSH
21969: LD_INT 32
21971: PUSH
21972: LD_INT 120
21974: PUSH
21975: LD_INT 70
21977: PUSH
21978: EMPTY
21979: LIST
21980: LIST
21981: LIST
21982: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
21983: LD_VAR 0 6
21987: PPUSH
21988: CALL_OW 264
21992: PUSH
21993: LD_INT 7
21995: PUSH
21996: LD_INT 28
21998: PUSH
21999: LD_INT 45
22001: PUSH
22002: LD_INT 92
22004: PUSH
22005: EMPTY
22006: LIST
22007: LIST
22008: LIST
22009: LIST
22010: IN
22011: IFFALSE 22032
// points := [ 35 , 20 , 45 ] ;
22013: LD_ADDR_VAR 0 9
22017: PUSH
22018: LD_INT 35
22020: PUSH
22021: LD_INT 20
22023: PUSH
22024: LD_INT 45
22026: PUSH
22027: EMPTY
22028: LIST
22029: LIST
22030: LIST
22031: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22032: LD_VAR 0 6
22036: PPUSH
22037: CALL_OW 264
22041: PUSH
22042: LD_INT 47
22044: PUSH
22045: EMPTY
22046: LIST
22047: IN
22048: IFFALSE 22069
// points := [ 67 , 45 , 75 ] ;
22050: LD_ADDR_VAR 0 9
22054: PUSH
22055: LD_INT 67
22057: PUSH
22058: LD_INT 45
22060: PUSH
22061: LD_INT 75
22063: PUSH
22064: EMPTY
22065: LIST
22066: LIST
22067: LIST
22068: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22069: LD_VAR 0 6
22073: PPUSH
22074: CALL_OW 264
22078: PUSH
22079: LD_INT 26
22081: PUSH
22082: EMPTY
22083: LIST
22084: IN
22085: IFFALSE 22106
// points := [ 120 , 30 , 80 ] ;
22087: LD_ADDR_VAR 0 9
22091: PUSH
22092: LD_INT 120
22094: PUSH
22095: LD_INT 30
22097: PUSH
22098: LD_INT 80
22100: PUSH
22101: EMPTY
22102: LIST
22103: LIST
22104: LIST
22105: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22106: LD_VAR 0 6
22110: PPUSH
22111: CALL_OW 264
22115: PUSH
22116: LD_INT 22
22118: PUSH
22119: EMPTY
22120: LIST
22121: IN
22122: IFFALSE 22143
// points := [ 40 , 1 , 1 ] ;
22124: LD_ADDR_VAR 0 9
22128: PUSH
22129: LD_INT 40
22131: PUSH
22132: LD_INT 1
22134: PUSH
22135: LD_INT 1
22137: PUSH
22138: EMPTY
22139: LIST
22140: LIST
22141: LIST
22142: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22143: LD_VAR 0 6
22147: PPUSH
22148: CALL_OW 264
22152: PUSH
22153: LD_INT 29
22155: PUSH
22156: EMPTY
22157: LIST
22158: IN
22159: IFFALSE 22180
// points := [ 70 , 200 , 400 ] ;
22161: LD_ADDR_VAR 0 9
22165: PUSH
22166: LD_INT 70
22168: PUSH
22169: LD_INT 200
22171: PUSH
22172: LD_INT 400
22174: PUSH
22175: EMPTY
22176: LIST
22177: LIST
22178: LIST
22179: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22180: LD_VAR 0 6
22184: PPUSH
22185: CALL_OW 264
22189: PUSH
22190: LD_INT 14
22192: PUSH
22193: LD_INT 53
22195: PUSH
22196: EMPTY
22197: LIST
22198: LIST
22199: IN
22200: IFFALSE 22221
// points := [ 40 , 10 , 20 ] ;
22202: LD_ADDR_VAR 0 9
22206: PUSH
22207: LD_INT 40
22209: PUSH
22210: LD_INT 10
22212: PUSH
22213: LD_INT 20
22215: PUSH
22216: EMPTY
22217: LIST
22218: LIST
22219: LIST
22220: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22221: LD_VAR 0 6
22225: PPUSH
22226: CALL_OW 264
22230: PUSH
22231: LD_INT 9
22233: PUSH
22234: EMPTY
22235: LIST
22236: IN
22237: IFFALSE 22258
// points := [ 5 , 70 , 20 ] ;
22239: LD_ADDR_VAR 0 9
22243: PUSH
22244: LD_INT 5
22246: PUSH
22247: LD_INT 70
22249: PUSH
22250: LD_INT 20
22252: PUSH
22253: EMPTY
22254: LIST
22255: LIST
22256: LIST
22257: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22258: LD_VAR 0 6
22262: PPUSH
22263: CALL_OW 264
22267: PUSH
22268: LD_INT 10
22270: PUSH
22271: EMPTY
22272: LIST
22273: IN
22274: IFFALSE 22295
// points := [ 35 , 110 , 70 ] ;
22276: LD_ADDR_VAR 0 9
22280: PUSH
22281: LD_INT 35
22283: PUSH
22284: LD_INT 110
22286: PUSH
22287: LD_INT 70
22289: PUSH
22290: EMPTY
22291: LIST
22292: LIST
22293: LIST
22294: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22295: LD_VAR 0 6
22299: PPUSH
22300: CALL_OW 265
22304: PUSH
22305: LD_INT 25
22307: EQUAL
22308: IFFALSE 22329
// points := [ 80 , 65 , 100 ] ;
22310: LD_ADDR_VAR 0 9
22314: PUSH
22315: LD_INT 80
22317: PUSH
22318: LD_INT 65
22320: PUSH
22321: LD_INT 100
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: LIST
22328: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22329: LD_VAR 0 6
22333: PPUSH
22334: CALL_OW 263
22338: PUSH
22339: LD_INT 1
22341: EQUAL
22342: IFFALSE 22377
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22344: LD_ADDR_VAR 0 10
22348: PUSH
22349: LD_VAR 0 10
22353: PUSH
22354: LD_VAR 0 6
22358: PPUSH
22359: CALL_OW 311
22363: PPUSH
22364: LD_INT 3
22366: PPUSH
22367: CALL_OW 259
22371: PUSH
22372: LD_INT 4
22374: MUL
22375: MUL
22376: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22377: LD_VAR 0 6
22381: PPUSH
22382: CALL_OW 263
22386: PUSH
22387: LD_INT 2
22389: EQUAL
22390: IFFALSE 22441
// begin j := IsControledBy ( i ) ;
22392: LD_ADDR_VAR 0 7
22396: PUSH
22397: LD_VAR 0 6
22401: PPUSH
22402: CALL_OW 312
22406: ST_TO_ADDR
// if j then
22407: LD_VAR 0 7
22411: IFFALSE 22441
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22413: LD_ADDR_VAR 0 10
22417: PUSH
22418: LD_VAR 0 10
22422: PUSH
22423: LD_VAR 0 7
22427: PPUSH
22428: LD_INT 3
22430: PPUSH
22431: CALL_OW 259
22435: PUSH
22436: LD_INT 3
22438: MUL
22439: MUL
22440: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22441: LD_VAR 0 6
22445: PPUSH
22446: CALL_OW 264
22450: PUSH
22451: LD_INT 5
22453: PUSH
22454: LD_INT 6
22456: PUSH
22457: LD_INT 46
22459: PUSH
22460: LD_INT 44
22462: PUSH
22463: LD_INT 47
22465: PUSH
22466: LD_INT 45
22468: PUSH
22469: LD_INT 28
22471: PUSH
22472: LD_INT 7
22474: PUSH
22475: LD_INT 27
22477: PUSH
22478: LD_INT 29
22480: PUSH
22481: EMPTY
22482: LIST
22483: LIST
22484: LIST
22485: LIST
22486: LIST
22487: LIST
22488: LIST
22489: LIST
22490: LIST
22491: LIST
22492: IN
22493: PUSH
22494: LD_VAR 0 1
22498: PPUSH
22499: LD_INT 52
22501: PPUSH
22502: CALL_OW 321
22506: PUSH
22507: LD_INT 2
22509: EQUAL
22510: AND
22511: IFFALSE 22528
// bpoints := bpoints * 1.2 ;
22513: LD_ADDR_VAR 0 10
22517: PUSH
22518: LD_VAR 0 10
22522: PUSH
22523: LD_REAL  1.20000000000000E+0000
22526: MUL
22527: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22528: LD_VAR 0 6
22532: PPUSH
22533: CALL_OW 264
22537: PUSH
22538: LD_INT 6
22540: PUSH
22541: LD_INT 46
22543: PUSH
22544: LD_INT 47
22546: PUSH
22547: EMPTY
22548: LIST
22549: LIST
22550: LIST
22551: IN
22552: IFFALSE 22569
// bpoints := bpoints * 1.2 ;
22554: LD_ADDR_VAR 0 10
22558: PUSH
22559: LD_VAR 0 10
22563: PUSH
22564: LD_REAL  1.20000000000000E+0000
22567: MUL
22568: ST_TO_ADDR
// end ; unit_building :
22569: GO 22583
22571: LD_INT 3
22573: DOUBLE
22574: EQUAL
22575: IFTRUE 22579
22577: GO 22582
22579: POP
// ; end ;
22580: GO 22583
22582: POP
// for j = 1 to 3 do
22583: LD_ADDR_VAR 0 7
22587: PUSH
22588: DOUBLE
22589: LD_INT 1
22591: DEC
22592: ST_TO_ADDR
22593: LD_INT 3
22595: PUSH
22596: FOR_TO
22597: IFFALSE 22650
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22599: LD_ADDR_VAR 0 5
22603: PUSH
22604: LD_VAR 0 5
22608: PPUSH
22609: LD_VAR 0 7
22613: PPUSH
22614: LD_VAR 0 5
22618: PUSH
22619: LD_VAR 0 7
22623: ARRAY
22624: PUSH
22625: LD_VAR 0 9
22629: PUSH
22630: LD_VAR 0 7
22634: ARRAY
22635: PUSH
22636: LD_VAR 0 10
22640: MUL
22641: PLUS
22642: PPUSH
22643: CALL_OW 1
22647: ST_TO_ADDR
22648: GO 22596
22650: POP
22651: POP
// end ;
22652: GO 21131
22654: POP
22655: POP
// result := Replace ( result , 4 , tmp ) ;
22656: LD_ADDR_VAR 0 5
22660: PUSH
22661: LD_VAR 0 5
22665: PPUSH
22666: LD_INT 4
22668: PPUSH
22669: LD_VAR 0 8
22673: PPUSH
22674: CALL_OW 1
22678: ST_TO_ADDR
// end ;
22679: LD_VAR 0 5
22683: RET
// export function DangerAtRange ( unit , range ) ; begin
22684: LD_INT 0
22686: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22687: LD_ADDR_VAR 0 3
22691: PUSH
22692: LD_VAR 0 1
22696: PPUSH
22697: CALL_OW 255
22701: PPUSH
22702: LD_VAR 0 1
22706: PPUSH
22707: CALL_OW 250
22711: PPUSH
22712: LD_VAR 0 1
22716: PPUSH
22717: CALL_OW 251
22721: PPUSH
22722: LD_VAR 0 2
22726: PPUSH
22727: CALL 20983 0 4
22731: ST_TO_ADDR
// end ;
22732: LD_VAR 0 3
22736: RET
// export function DangerInArea ( side , area ) ; begin
22737: LD_INT 0
22739: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22740: LD_ADDR_VAR 0 3
22744: PUSH
22745: LD_VAR 0 2
22749: PPUSH
22750: LD_INT 81
22752: PUSH
22753: LD_VAR 0 1
22757: PUSH
22758: EMPTY
22759: LIST
22760: LIST
22761: PPUSH
22762: CALL_OW 70
22766: ST_TO_ADDR
// end ;
22767: LD_VAR 0 3
22771: RET
// export function IsExtension ( b ) ; begin
22772: LD_INT 0
22774: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22775: LD_ADDR_VAR 0 2
22779: PUSH
22780: LD_VAR 0 1
22784: PUSH
22785: LD_INT 23
22787: PUSH
22788: LD_INT 20
22790: PUSH
22791: LD_INT 22
22793: PUSH
22794: LD_INT 17
22796: PUSH
22797: LD_INT 24
22799: PUSH
22800: LD_INT 21
22802: PUSH
22803: LD_INT 19
22805: PUSH
22806: LD_INT 16
22808: PUSH
22809: LD_INT 25
22811: PUSH
22812: LD_INT 18
22814: PUSH
22815: EMPTY
22816: LIST
22817: LIST
22818: LIST
22819: LIST
22820: LIST
22821: LIST
22822: LIST
22823: LIST
22824: LIST
22825: LIST
22826: IN
22827: ST_TO_ADDR
// end ;
22828: LD_VAR 0 2
22832: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
22833: LD_INT 0
22835: PPUSH
22836: PPUSH
22837: PPUSH
// result := [ ] ;
22838: LD_ADDR_VAR 0 4
22842: PUSH
22843: EMPTY
22844: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
22845: LD_ADDR_VAR 0 5
22849: PUSH
22850: LD_VAR 0 2
22854: PPUSH
22855: LD_INT 21
22857: PUSH
22858: LD_INT 3
22860: PUSH
22861: EMPTY
22862: LIST
22863: LIST
22864: PPUSH
22865: CALL_OW 70
22869: ST_TO_ADDR
// if not tmp then
22870: LD_VAR 0 5
22874: NOT
22875: IFFALSE 22879
// exit ;
22877: GO 22943
// if checkLink then
22879: LD_VAR 0 3
22883: IFFALSE 22933
// begin for i in tmp do
22885: LD_ADDR_VAR 0 6
22889: PUSH
22890: LD_VAR 0 5
22894: PUSH
22895: FOR_IN
22896: IFFALSE 22931
// if GetBase ( i ) <> base then
22898: LD_VAR 0 6
22902: PPUSH
22903: CALL_OW 274
22907: PUSH
22908: LD_VAR 0 1
22912: NONEQUAL
22913: IFFALSE 22929
// ComLinkToBase ( base , i ) ;
22915: LD_VAR 0 1
22919: PPUSH
22920: LD_VAR 0 6
22924: PPUSH
22925: CALL_OW 169
22929: GO 22895
22931: POP
22932: POP
// end ; result := tmp ;
22933: LD_ADDR_VAR 0 4
22937: PUSH
22938: LD_VAR 0 5
22942: ST_TO_ADDR
// end ;
22943: LD_VAR 0 4
22947: RET
// export function ComComplete ( units , b ) ; var i ; begin
22948: LD_INT 0
22950: PPUSH
22951: PPUSH
// if not units then
22952: LD_VAR 0 1
22956: NOT
22957: IFFALSE 22961
// exit ;
22959: GO 23051
// for i in units do
22961: LD_ADDR_VAR 0 4
22965: PUSH
22966: LD_VAR 0 1
22970: PUSH
22971: FOR_IN
22972: IFFALSE 23049
// if BuildingStatus ( b ) = bs_build then
22974: LD_VAR 0 2
22978: PPUSH
22979: CALL_OW 461
22983: PUSH
22984: LD_INT 1
22986: EQUAL
22987: IFFALSE 23047
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22989: LD_VAR 0 4
22993: PPUSH
22994: LD_STRING h
22996: PUSH
22997: LD_VAR 0 2
23001: PPUSH
23002: CALL_OW 250
23006: PUSH
23007: LD_VAR 0 2
23011: PPUSH
23012: CALL_OW 251
23016: PUSH
23017: LD_VAR 0 2
23021: PUSH
23022: LD_INT 0
23024: PUSH
23025: LD_INT 0
23027: PUSH
23028: LD_INT 0
23030: PUSH
23031: EMPTY
23032: LIST
23033: LIST
23034: LIST
23035: LIST
23036: LIST
23037: LIST
23038: LIST
23039: PUSH
23040: EMPTY
23041: LIST
23042: PPUSH
23043: CALL_OW 446
23047: GO 22971
23049: POP
23050: POP
// end ;
23051: LD_VAR 0 3
23055: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23056: LD_INT 0
23058: PPUSH
23059: PPUSH
23060: PPUSH
23061: PPUSH
23062: PPUSH
23063: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
23064: LD_VAR 0 1
23068: NOT
23069: PUSH
23070: LD_VAR 0 1
23074: PPUSH
23075: CALL_OW 263
23079: PUSH
23080: LD_INT 2
23082: NONEQUAL
23083: OR
23084: IFFALSE 23088
// exit ;
23086: GO 23404
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23088: LD_ADDR_VAR 0 6
23092: PUSH
23093: LD_INT 22
23095: PUSH
23096: LD_VAR 0 1
23100: PPUSH
23101: CALL_OW 255
23105: PUSH
23106: EMPTY
23107: LIST
23108: LIST
23109: PUSH
23110: LD_INT 2
23112: PUSH
23113: LD_INT 30
23115: PUSH
23116: LD_INT 36
23118: PUSH
23119: EMPTY
23120: LIST
23121: LIST
23122: PUSH
23123: LD_INT 34
23125: PUSH
23126: LD_INT 31
23128: PUSH
23129: EMPTY
23130: LIST
23131: LIST
23132: PUSH
23133: EMPTY
23134: LIST
23135: LIST
23136: LIST
23137: PUSH
23138: EMPTY
23139: LIST
23140: LIST
23141: PPUSH
23142: CALL_OW 69
23146: ST_TO_ADDR
// if not tmp then
23147: LD_VAR 0 6
23151: NOT
23152: IFFALSE 23156
// exit ;
23154: GO 23404
// result := [ ] ;
23156: LD_ADDR_VAR 0 2
23160: PUSH
23161: EMPTY
23162: ST_TO_ADDR
// for i in tmp do
23163: LD_ADDR_VAR 0 3
23167: PUSH
23168: LD_VAR 0 6
23172: PUSH
23173: FOR_IN
23174: IFFALSE 23245
// begin t := UnitsInside ( i ) ;
23176: LD_ADDR_VAR 0 4
23180: PUSH
23181: LD_VAR 0 3
23185: PPUSH
23186: CALL_OW 313
23190: ST_TO_ADDR
// if t then
23191: LD_VAR 0 4
23195: IFFALSE 23243
// for j in t do
23197: LD_ADDR_VAR 0 7
23201: PUSH
23202: LD_VAR 0 4
23206: PUSH
23207: FOR_IN
23208: IFFALSE 23241
// result := Replace ( result , result + 1 , j ) ;
23210: LD_ADDR_VAR 0 2
23214: PUSH
23215: LD_VAR 0 2
23219: PPUSH
23220: LD_VAR 0 2
23224: PUSH
23225: LD_INT 1
23227: PLUS
23228: PPUSH
23229: LD_VAR 0 7
23233: PPUSH
23234: CALL_OW 1
23238: ST_TO_ADDR
23239: GO 23207
23241: POP
23242: POP
// end ;
23243: GO 23173
23245: POP
23246: POP
// if not result then
23247: LD_VAR 0 2
23251: NOT
23252: IFFALSE 23256
// exit ;
23254: GO 23404
// mech := result [ 1 ] ;
23256: LD_ADDR_VAR 0 5
23260: PUSH
23261: LD_VAR 0 2
23265: PUSH
23266: LD_INT 1
23268: ARRAY
23269: ST_TO_ADDR
// if result > 1 then
23270: LD_VAR 0 2
23274: PUSH
23275: LD_INT 1
23277: GREATER
23278: IFFALSE 23390
// begin for i = 2 to result do
23280: LD_ADDR_VAR 0 3
23284: PUSH
23285: DOUBLE
23286: LD_INT 2
23288: DEC
23289: ST_TO_ADDR
23290: LD_VAR 0 2
23294: PUSH
23295: FOR_TO
23296: IFFALSE 23388
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23298: LD_ADDR_VAR 0 4
23302: PUSH
23303: LD_VAR 0 2
23307: PUSH
23308: LD_VAR 0 3
23312: ARRAY
23313: PPUSH
23314: LD_INT 3
23316: PPUSH
23317: CALL_OW 259
23321: PUSH
23322: LD_VAR 0 2
23326: PUSH
23327: LD_VAR 0 3
23331: ARRAY
23332: PPUSH
23333: CALL_OW 432
23337: MINUS
23338: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23339: LD_VAR 0 4
23343: PUSH
23344: LD_VAR 0 5
23348: PPUSH
23349: LD_INT 3
23351: PPUSH
23352: CALL_OW 259
23356: PUSH
23357: LD_VAR 0 5
23361: PPUSH
23362: CALL_OW 432
23366: MINUS
23367: GREATEREQUAL
23368: IFFALSE 23386
// mech := result [ i ] ;
23370: LD_ADDR_VAR 0 5
23374: PUSH
23375: LD_VAR 0 2
23379: PUSH
23380: LD_VAR 0 3
23384: ARRAY
23385: ST_TO_ADDR
// end ;
23386: GO 23295
23388: POP
23389: POP
// end ; ComLinkTo ( vehicle , mech ) ;
23390: LD_VAR 0 1
23394: PPUSH
23395: LD_VAR 0 5
23399: PPUSH
23400: CALL_OW 135
// end ;
23404: LD_VAR 0 2
23408: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23409: LD_INT 0
23411: PPUSH
23412: PPUSH
23413: PPUSH
23414: PPUSH
23415: PPUSH
23416: PPUSH
23417: PPUSH
23418: PPUSH
23419: PPUSH
23420: PPUSH
23421: PPUSH
23422: PPUSH
23423: PPUSH
// result := [ ] ;
23424: LD_ADDR_VAR 0 7
23428: PUSH
23429: EMPTY
23430: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23431: LD_VAR 0 1
23435: PPUSH
23436: CALL_OW 266
23440: PUSH
23441: LD_INT 0
23443: PUSH
23444: LD_INT 1
23446: PUSH
23447: EMPTY
23448: LIST
23449: LIST
23450: IN
23451: NOT
23452: IFFALSE 23456
// exit ;
23454: GO 25090
// if name then
23456: LD_VAR 0 3
23460: IFFALSE 23476
// SetBName ( base_dep , name ) ;
23462: LD_VAR 0 1
23466: PPUSH
23467: LD_VAR 0 3
23471: PPUSH
23472: CALL_OW 500
// base := GetBase ( base_dep ) ;
23476: LD_ADDR_VAR 0 15
23480: PUSH
23481: LD_VAR 0 1
23485: PPUSH
23486: CALL_OW 274
23490: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23491: LD_ADDR_VAR 0 16
23495: PUSH
23496: LD_VAR 0 1
23500: PPUSH
23501: CALL_OW 255
23505: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23506: LD_ADDR_VAR 0 17
23510: PUSH
23511: LD_VAR 0 1
23515: PPUSH
23516: CALL_OW 248
23520: ST_TO_ADDR
// if sources then
23521: LD_VAR 0 5
23525: IFFALSE 23572
// for i = 1 to 3 do
23527: LD_ADDR_VAR 0 8
23531: PUSH
23532: DOUBLE
23533: LD_INT 1
23535: DEC
23536: ST_TO_ADDR
23537: LD_INT 3
23539: PUSH
23540: FOR_TO
23541: IFFALSE 23570
// AddResourceType ( base , i , sources [ i ] ) ;
23543: LD_VAR 0 15
23547: PPUSH
23548: LD_VAR 0 8
23552: PPUSH
23553: LD_VAR 0 5
23557: PUSH
23558: LD_VAR 0 8
23562: ARRAY
23563: PPUSH
23564: CALL_OW 276
23568: GO 23540
23570: POP
23571: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
23572: LD_ADDR_VAR 0 18
23576: PUSH
23577: LD_VAR 0 15
23581: PPUSH
23582: LD_VAR 0 2
23586: PPUSH
23587: LD_INT 1
23589: PPUSH
23590: CALL 22833 0 3
23594: ST_TO_ADDR
// InitHc ;
23595: CALL_OW 19
// InitUc ;
23599: CALL_OW 18
// uc_side := side ;
23603: LD_ADDR_OWVAR 20
23607: PUSH
23608: LD_VAR 0 16
23612: ST_TO_ADDR
// uc_nation := nation ;
23613: LD_ADDR_OWVAR 21
23617: PUSH
23618: LD_VAR 0 17
23622: ST_TO_ADDR
// if buildings then
23623: LD_VAR 0 18
23627: IFFALSE 24949
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
23629: LD_ADDR_VAR 0 19
23633: PUSH
23634: LD_VAR 0 18
23638: PPUSH
23639: LD_INT 2
23641: PUSH
23642: LD_INT 30
23644: PUSH
23645: LD_INT 29
23647: PUSH
23648: EMPTY
23649: LIST
23650: LIST
23651: PUSH
23652: LD_INT 30
23654: PUSH
23655: LD_INT 30
23657: PUSH
23658: EMPTY
23659: LIST
23660: LIST
23661: PUSH
23662: EMPTY
23663: LIST
23664: LIST
23665: LIST
23666: PPUSH
23667: CALL_OW 72
23671: ST_TO_ADDR
// if tmp then
23672: LD_VAR 0 19
23676: IFFALSE 23724
// for i in tmp do
23678: LD_ADDR_VAR 0 8
23682: PUSH
23683: LD_VAR 0 19
23687: PUSH
23688: FOR_IN
23689: IFFALSE 23722
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
23691: LD_VAR 0 8
23695: PPUSH
23696: CALL_OW 250
23700: PPUSH
23701: LD_VAR 0 8
23705: PPUSH
23706: CALL_OW 251
23710: PPUSH
23711: LD_VAR 0 16
23715: PPUSH
23716: CALL_OW 441
23720: GO 23688
23722: POP
23723: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23724: LD_VAR 0 18
23728: PPUSH
23729: LD_INT 2
23731: PUSH
23732: LD_INT 30
23734: PUSH
23735: LD_INT 32
23737: PUSH
23738: EMPTY
23739: LIST
23740: LIST
23741: PUSH
23742: LD_INT 30
23744: PUSH
23745: LD_INT 33
23747: PUSH
23748: EMPTY
23749: LIST
23750: LIST
23751: PUSH
23752: EMPTY
23753: LIST
23754: LIST
23755: LIST
23756: PPUSH
23757: CALL_OW 72
23761: IFFALSE 23849
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23763: LD_ADDR_VAR 0 8
23767: PUSH
23768: LD_VAR 0 18
23772: PPUSH
23773: LD_INT 2
23775: PUSH
23776: LD_INT 30
23778: PUSH
23779: LD_INT 32
23781: PUSH
23782: EMPTY
23783: LIST
23784: LIST
23785: PUSH
23786: LD_INT 30
23788: PUSH
23789: LD_INT 33
23791: PUSH
23792: EMPTY
23793: LIST
23794: LIST
23795: PUSH
23796: EMPTY
23797: LIST
23798: LIST
23799: LIST
23800: PPUSH
23801: CALL_OW 72
23805: PUSH
23806: FOR_IN
23807: IFFALSE 23847
// begin if not GetBWeapon ( i ) then
23809: LD_VAR 0 8
23813: PPUSH
23814: CALL_OW 269
23818: NOT
23819: IFFALSE 23845
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23821: LD_VAR 0 8
23825: PPUSH
23826: LD_VAR 0 8
23830: PPUSH
23831: LD_VAR 0 2
23835: PPUSH
23836: CALL 25095 0 2
23840: PPUSH
23841: CALL_OW 431
// end ;
23845: GO 23806
23847: POP
23848: POP
// end ; for i = 1 to personel do
23849: LD_ADDR_VAR 0 8
23853: PUSH
23854: DOUBLE
23855: LD_INT 1
23857: DEC
23858: ST_TO_ADDR
23859: LD_VAR 0 6
23863: PUSH
23864: FOR_TO
23865: IFFALSE 24929
// begin if i > 4 then
23867: LD_VAR 0 8
23871: PUSH
23872: LD_INT 4
23874: GREATER
23875: IFFALSE 23879
// break ;
23877: GO 24929
// case i of 1 :
23879: LD_VAR 0 8
23883: PUSH
23884: LD_INT 1
23886: DOUBLE
23887: EQUAL
23888: IFTRUE 23892
23890: GO 23972
23892: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23893: LD_ADDR_VAR 0 12
23897: PUSH
23898: LD_VAR 0 18
23902: PPUSH
23903: LD_INT 22
23905: PUSH
23906: LD_VAR 0 16
23910: PUSH
23911: EMPTY
23912: LIST
23913: LIST
23914: PUSH
23915: LD_INT 58
23917: PUSH
23918: EMPTY
23919: LIST
23920: PUSH
23921: LD_INT 2
23923: PUSH
23924: LD_INT 30
23926: PUSH
23927: LD_INT 32
23929: PUSH
23930: EMPTY
23931: LIST
23932: LIST
23933: PUSH
23934: LD_INT 30
23936: PUSH
23937: LD_INT 4
23939: PUSH
23940: EMPTY
23941: LIST
23942: LIST
23943: PUSH
23944: LD_INT 30
23946: PUSH
23947: LD_INT 5
23949: PUSH
23950: EMPTY
23951: LIST
23952: LIST
23953: PUSH
23954: EMPTY
23955: LIST
23956: LIST
23957: LIST
23958: LIST
23959: PUSH
23960: EMPTY
23961: LIST
23962: LIST
23963: LIST
23964: PPUSH
23965: CALL_OW 72
23969: ST_TO_ADDR
23970: GO 24194
23972: LD_INT 2
23974: DOUBLE
23975: EQUAL
23976: IFTRUE 23980
23978: GO 24042
23980: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23981: LD_ADDR_VAR 0 12
23985: PUSH
23986: LD_VAR 0 18
23990: PPUSH
23991: LD_INT 22
23993: PUSH
23994: LD_VAR 0 16
23998: PUSH
23999: EMPTY
24000: LIST
24001: LIST
24002: PUSH
24003: LD_INT 2
24005: PUSH
24006: LD_INT 30
24008: PUSH
24009: LD_INT 0
24011: PUSH
24012: EMPTY
24013: LIST
24014: LIST
24015: PUSH
24016: LD_INT 30
24018: PUSH
24019: LD_INT 1
24021: PUSH
24022: EMPTY
24023: LIST
24024: LIST
24025: PUSH
24026: EMPTY
24027: LIST
24028: LIST
24029: LIST
24030: PUSH
24031: EMPTY
24032: LIST
24033: LIST
24034: PPUSH
24035: CALL_OW 72
24039: ST_TO_ADDR
24040: GO 24194
24042: LD_INT 3
24044: DOUBLE
24045: EQUAL
24046: IFTRUE 24050
24048: GO 24112
24050: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24051: LD_ADDR_VAR 0 12
24055: PUSH
24056: LD_VAR 0 18
24060: PPUSH
24061: LD_INT 22
24063: PUSH
24064: LD_VAR 0 16
24068: PUSH
24069: EMPTY
24070: LIST
24071: LIST
24072: PUSH
24073: LD_INT 2
24075: PUSH
24076: LD_INT 30
24078: PUSH
24079: LD_INT 2
24081: PUSH
24082: EMPTY
24083: LIST
24084: LIST
24085: PUSH
24086: LD_INT 30
24088: PUSH
24089: LD_INT 3
24091: PUSH
24092: EMPTY
24093: LIST
24094: LIST
24095: PUSH
24096: EMPTY
24097: LIST
24098: LIST
24099: LIST
24100: PUSH
24101: EMPTY
24102: LIST
24103: LIST
24104: PPUSH
24105: CALL_OW 72
24109: ST_TO_ADDR
24110: GO 24194
24112: LD_INT 4
24114: DOUBLE
24115: EQUAL
24116: IFTRUE 24120
24118: GO 24193
24120: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24121: LD_ADDR_VAR 0 12
24125: PUSH
24126: LD_VAR 0 18
24130: PPUSH
24131: LD_INT 22
24133: PUSH
24134: LD_VAR 0 16
24138: PUSH
24139: EMPTY
24140: LIST
24141: LIST
24142: PUSH
24143: LD_INT 2
24145: PUSH
24146: LD_INT 30
24148: PUSH
24149: LD_INT 6
24151: PUSH
24152: EMPTY
24153: LIST
24154: LIST
24155: PUSH
24156: LD_INT 30
24158: PUSH
24159: LD_INT 7
24161: PUSH
24162: EMPTY
24163: LIST
24164: LIST
24165: PUSH
24166: LD_INT 30
24168: PUSH
24169: LD_INT 8
24171: PUSH
24172: EMPTY
24173: LIST
24174: LIST
24175: PUSH
24176: EMPTY
24177: LIST
24178: LIST
24179: LIST
24180: LIST
24181: PUSH
24182: EMPTY
24183: LIST
24184: LIST
24185: PPUSH
24186: CALL_OW 72
24190: ST_TO_ADDR
24191: GO 24194
24193: POP
// if i = 1 then
24194: LD_VAR 0 8
24198: PUSH
24199: LD_INT 1
24201: EQUAL
24202: IFFALSE 24313
// begin tmp := [ ] ;
24204: LD_ADDR_VAR 0 19
24208: PUSH
24209: EMPTY
24210: ST_TO_ADDR
// for j in f do
24211: LD_ADDR_VAR 0 9
24215: PUSH
24216: LD_VAR 0 12
24220: PUSH
24221: FOR_IN
24222: IFFALSE 24295
// if GetBType ( j ) = b_bunker then
24224: LD_VAR 0 9
24228: PPUSH
24229: CALL_OW 266
24233: PUSH
24234: LD_INT 32
24236: EQUAL
24237: IFFALSE 24264
// tmp := Insert ( tmp , 1 , j ) else
24239: LD_ADDR_VAR 0 19
24243: PUSH
24244: LD_VAR 0 19
24248: PPUSH
24249: LD_INT 1
24251: PPUSH
24252: LD_VAR 0 9
24256: PPUSH
24257: CALL_OW 2
24261: ST_TO_ADDR
24262: GO 24293
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24264: LD_ADDR_VAR 0 19
24268: PUSH
24269: LD_VAR 0 19
24273: PPUSH
24274: LD_VAR 0 19
24278: PUSH
24279: LD_INT 1
24281: PLUS
24282: PPUSH
24283: LD_VAR 0 9
24287: PPUSH
24288: CALL_OW 2
24292: ST_TO_ADDR
24293: GO 24221
24295: POP
24296: POP
// if tmp then
24297: LD_VAR 0 19
24301: IFFALSE 24313
// f := tmp ;
24303: LD_ADDR_VAR 0 12
24307: PUSH
24308: LD_VAR 0 19
24312: ST_TO_ADDR
// end ; x := personel [ i ] ;
24313: LD_ADDR_VAR 0 13
24317: PUSH
24318: LD_VAR 0 6
24322: PUSH
24323: LD_VAR 0 8
24327: ARRAY
24328: ST_TO_ADDR
// if x = - 1 then
24329: LD_VAR 0 13
24333: PUSH
24334: LD_INT 1
24336: NEG
24337: EQUAL
24338: IFFALSE 24547
// begin for j in f do
24340: LD_ADDR_VAR 0 9
24344: PUSH
24345: LD_VAR 0 12
24349: PUSH
24350: FOR_IN
24351: IFFALSE 24543
// repeat InitHc ;
24353: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24357: LD_VAR 0 9
24361: PPUSH
24362: CALL_OW 266
24366: PUSH
24367: LD_INT 5
24369: EQUAL
24370: IFFALSE 24440
// begin if UnitsInside ( j ) < 3 then
24372: LD_VAR 0 9
24376: PPUSH
24377: CALL_OW 313
24381: PUSH
24382: LD_INT 3
24384: LESS
24385: IFFALSE 24421
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24387: LD_INT 0
24389: PPUSH
24390: LD_INT 5
24392: PUSH
24393: LD_INT 8
24395: PUSH
24396: LD_INT 9
24398: PUSH
24399: EMPTY
24400: LIST
24401: LIST
24402: LIST
24403: PUSH
24404: LD_VAR 0 17
24408: ARRAY
24409: PPUSH
24410: LD_VAR 0 4
24414: PPUSH
24415: CALL_OW 380
24419: GO 24438
// PrepareHuman ( false , i , skill ) ;
24421: LD_INT 0
24423: PPUSH
24424: LD_VAR 0 8
24428: PPUSH
24429: LD_VAR 0 4
24433: PPUSH
24434: CALL_OW 380
// end else
24438: GO 24457
// PrepareHuman ( false , i , skill ) ;
24440: LD_INT 0
24442: PPUSH
24443: LD_VAR 0 8
24447: PPUSH
24448: LD_VAR 0 4
24452: PPUSH
24453: CALL_OW 380
// un := CreateHuman ;
24457: LD_ADDR_VAR 0 14
24461: PUSH
24462: CALL_OW 44
24466: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24467: LD_ADDR_VAR 0 7
24471: PUSH
24472: LD_VAR 0 7
24476: PPUSH
24477: LD_INT 1
24479: PPUSH
24480: LD_VAR 0 14
24484: PPUSH
24485: CALL_OW 2
24489: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24490: LD_VAR 0 14
24494: PPUSH
24495: LD_VAR 0 9
24499: PPUSH
24500: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24504: LD_VAR 0 9
24508: PPUSH
24509: CALL_OW 313
24513: PUSH
24514: LD_INT 6
24516: EQUAL
24517: PUSH
24518: LD_VAR 0 9
24522: PPUSH
24523: CALL_OW 266
24527: PUSH
24528: LD_INT 32
24530: PUSH
24531: LD_INT 31
24533: PUSH
24534: EMPTY
24535: LIST
24536: LIST
24537: IN
24538: OR
24539: IFFALSE 24353
24541: GO 24350
24543: POP
24544: POP
// end else
24545: GO 24927
// for j = 1 to x do
24547: LD_ADDR_VAR 0 9
24551: PUSH
24552: DOUBLE
24553: LD_INT 1
24555: DEC
24556: ST_TO_ADDR
24557: LD_VAR 0 13
24561: PUSH
24562: FOR_TO
24563: IFFALSE 24925
// begin InitHc ;
24565: CALL_OW 19
// if not f then
24569: LD_VAR 0 12
24573: NOT
24574: IFFALSE 24663
// begin PrepareHuman ( false , i , skill ) ;
24576: LD_INT 0
24578: PPUSH
24579: LD_VAR 0 8
24583: PPUSH
24584: LD_VAR 0 4
24588: PPUSH
24589: CALL_OW 380
// un := CreateHuman ;
24593: LD_ADDR_VAR 0 14
24597: PUSH
24598: CALL_OW 44
24602: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24603: LD_ADDR_VAR 0 7
24607: PUSH
24608: LD_VAR 0 7
24612: PPUSH
24613: LD_INT 1
24615: PPUSH
24616: LD_VAR 0 14
24620: PPUSH
24621: CALL_OW 2
24625: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24626: LD_VAR 0 14
24630: PPUSH
24631: LD_VAR 0 1
24635: PPUSH
24636: CALL_OW 250
24640: PPUSH
24641: LD_VAR 0 1
24645: PPUSH
24646: CALL_OW 251
24650: PPUSH
24651: LD_INT 10
24653: PPUSH
24654: LD_INT 0
24656: PPUSH
24657: CALL_OW 50
// continue ;
24661: GO 24562
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24663: LD_VAR 0 12
24667: PUSH
24668: LD_INT 1
24670: ARRAY
24671: PPUSH
24672: CALL_OW 313
24676: PUSH
24677: LD_VAR 0 12
24681: PUSH
24682: LD_INT 1
24684: ARRAY
24685: PPUSH
24686: CALL_OW 266
24690: PUSH
24691: LD_INT 32
24693: PUSH
24694: LD_INT 31
24696: PUSH
24697: EMPTY
24698: LIST
24699: LIST
24700: IN
24701: AND
24702: PUSH
24703: LD_VAR 0 12
24707: PUSH
24708: LD_INT 1
24710: ARRAY
24711: PPUSH
24712: CALL_OW 313
24716: PUSH
24717: LD_INT 6
24719: EQUAL
24720: OR
24721: IFFALSE 24741
// f := Delete ( f , 1 ) ;
24723: LD_ADDR_VAR 0 12
24727: PUSH
24728: LD_VAR 0 12
24732: PPUSH
24733: LD_INT 1
24735: PPUSH
24736: CALL_OW 3
24740: ST_TO_ADDR
// if not f then
24741: LD_VAR 0 12
24745: NOT
24746: IFFALSE 24764
// begin x := x + 2 ;
24748: LD_ADDR_VAR 0 13
24752: PUSH
24753: LD_VAR 0 13
24757: PUSH
24758: LD_INT 2
24760: PLUS
24761: ST_TO_ADDR
// continue ;
24762: GO 24562
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24764: LD_VAR 0 12
24768: PUSH
24769: LD_INT 1
24771: ARRAY
24772: PPUSH
24773: CALL_OW 266
24777: PUSH
24778: LD_INT 5
24780: EQUAL
24781: IFFALSE 24855
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24783: LD_VAR 0 12
24787: PUSH
24788: LD_INT 1
24790: ARRAY
24791: PPUSH
24792: CALL_OW 313
24796: PUSH
24797: LD_INT 3
24799: LESS
24800: IFFALSE 24836
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24802: LD_INT 0
24804: PPUSH
24805: LD_INT 5
24807: PUSH
24808: LD_INT 8
24810: PUSH
24811: LD_INT 9
24813: PUSH
24814: EMPTY
24815: LIST
24816: LIST
24817: LIST
24818: PUSH
24819: LD_VAR 0 17
24823: ARRAY
24824: PPUSH
24825: LD_VAR 0 4
24829: PPUSH
24830: CALL_OW 380
24834: GO 24853
// PrepareHuman ( false , i , skill ) ;
24836: LD_INT 0
24838: PPUSH
24839: LD_VAR 0 8
24843: PPUSH
24844: LD_VAR 0 4
24848: PPUSH
24849: CALL_OW 380
// end else
24853: GO 24872
// PrepareHuman ( false , i , skill ) ;
24855: LD_INT 0
24857: PPUSH
24858: LD_VAR 0 8
24862: PPUSH
24863: LD_VAR 0 4
24867: PPUSH
24868: CALL_OW 380
// un := CreateHuman ;
24872: LD_ADDR_VAR 0 14
24876: PUSH
24877: CALL_OW 44
24881: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24882: LD_ADDR_VAR 0 7
24886: PUSH
24887: LD_VAR 0 7
24891: PPUSH
24892: LD_INT 1
24894: PPUSH
24895: LD_VAR 0 14
24899: PPUSH
24900: CALL_OW 2
24904: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24905: LD_VAR 0 14
24909: PPUSH
24910: LD_VAR 0 12
24914: PUSH
24915: LD_INT 1
24917: ARRAY
24918: PPUSH
24919: CALL_OW 52
// end ;
24923: GO 24562
24925: POP
24926: POP
// end ;
24927: GO 23864
24929: POP
24930: POP
// result := result ^ buildings ;
24931: LD_ADDR_VAR 0 7
24935: PUSH
24936: LD_VAR 0 7
24940: PUSH
24941: LD_VAR 0 18
24945: ADD
24946: ST_TO_ADDR
// end else
24947: GO 25090
// begin for i = 1 to personel do
24949: LD_ADDR_VAR 0 8
24953: PUSH
24954: DOUBLE
24955: LD_INT 1
24957: DEC
24958: ST_TO_ADDR
24959: LD_VAR 0 6
24963: PUSH
24964: FOR_TO
24965: IFFALSE 25088
// begin if i > 4 then
24967: LD_VAR 0 8
24971: PUSH
24972: LD_INT 4
24974: GREATER
24975: IFFALSE 24979
// break ;
24977: GO 25088
// x := personel [ i ] ;
24979: LD_ADDR_VAR 0 13
24983: PUSH
24984: LD_VAR 0 6
24988: PUSH
24989: LD_VAR 0 8
24993: ARRAY
24994: ST_TO_ADDR
// if x = - 1 then
24995: LD_VAR 0 13
24999: PUSH
25000: LD_INT 1
25002: NEG
25003: EQUAL
25004: IFFALSE 25008
// continue ;
25006: GO 24964
// PrepareHuman ( false , i , skill ) ;
25008: LD_INT 0
25010: PPUSH
25011: LD_VAR 0 8
25015: PPUSH
25016: LD_VAR 0 4
25020: PPUSH
25021: CALL_OW 380
// un := CreateHuman ;
25025: LD_ADDR_VAR 0 14
25029: PUSH
25030: CALL_OW 44
25034: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25035: LD_VAR 0 14
25039: PPUSH
25040: LD_VAR 0 1
25044: PPUSH
25045: CALL_OW 250
25049: PPUSH
25050: LD_VAR 0 1
25054: PPUSH
25055: CALL_OW 251
25059: PPUSH
25060: LD_INT 10
25062: PPUSH
25063: LD_INT 0
25065: PPUSH
25066: CALL_OW 50
// result := result ^ un ;
25070: LD_ADDR_VAR 0 7
25074: PUSH
25075: LD_VAR 0 7
25079: PUSH
25080: LD_VAR 0 14
25084: ADD
25085: ST_TO_ADDR
// end ;
25086: GO 24964
25088: POP
25089: POP
// end ; end ;
25090: LD_VAR 0 7
25094: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25095: LD_INT 0
25097: PPUSH
25098: PPUSH
25099: PPUSH
25100: PPUSH
25101: PPUSH
25102: PPUSH
25103: PPUSH
25104: PPUSH
25105: PPUSH
25106: PPUSH
25107: PPUSH
25108: PPUSH
25109: PPUSH
25110: PPUSH
25111: PPUSH
25112: PPUSH
// result := false ;
25113: LD_ADDR_VAR 0 3
25117: PUSH
25118: LD_INT 0
25120: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25121: LD_VAR 0 1
25125: NOT
25126: PUSH
25127: LD_VAR 0 1
25131: PPUSH
25132: CALL_OW 266
25136: PUSH
25137: LD_INT 32
25139: PUSH
25140: LD_INT 33
25142: PUSH
25143: EMPTY
25144: LIST
25145: LIST
25146: IN
25147: NOT
25148: OR
25149: IFFALSE 25153
// exit ;
25151: GO 26262
// nat := GetNation ( tower ) ;
25153: LD_ADDR_VAR 0 12
25157: PUSH
25158: LD_VAR 0 1
25162: PPUSH
25163: CALL_OW 248
25167: ST_TO_ADDR
// side := GetSide ( tower ) ;
25168: LD_ADDR_VAR 0 16
25172: PUSH
25173: LD_VAR 0 1
25177: PPUSH
25178: CALL_OW 255
25182: ST_TO_ADDR
// x := GetX ( tower ) ;
25183: LD_ADDR_VAR 0 10
25187: PUSH
25188: LD_VAR 0 1
25192: PPUSH
25193: CALL_OW 250
25197: ST_TO_ADDR
// y := GetY ( tower ) ;
25198: LD_ADDR_VAR 0 11
25202: PUSH
25203: LD_VAR 0 1
25207: PPUSH
25208: CALL_OW 251
25212: ST_TO_ADDR
// if not x or not y then
25213: LD_VAR 0 10
25217: NOT
25218: PUSH
25219: LD_VAR 0 11
25223: NOT
25224: OR
25225: IFFALSE 25229
// exit ;
25227: GO 26262
// weapon := 0 ;
25229: LD_ADDR_VAR 0 18
25233: PUSH
25234: LD_INT 0
25236: ST_TO_ADDR
// fac_list := [ ] ;
25237: LD_ADDR_VAR 0 17
25241: PUSH
25242: EMPTY
25243: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
25244: LD_ADDR_VAR 0 6
25248: PUSH
25249: LD_VAR 0 1
25253: PPUSH
25254: CALL_OW 274
25258: PPUSH
25259: LD_VAR 0 2
25263: PPUSH
25264: LD_INT 0
25266: PPUSH
25267: CALL 22833 0 3
25271: PPUSH
25272: LD_INT 30
25274: PUSH
25275: LD_INT 3
25277: PUSH
25278: EMPTY
25279: LIST
25280: LIST
25281: PPUSH
25282: CALL_OW 72
25286: ST_TO_ADDR
// if not factories then
25287: LD_VAR 0 6
25291: NOT
25292: IFFALSE 25296
// exit ;
25294: GO 26262
// for i in factories do
25296: LD_ADDR_VAR 0 8
25300: PUSH
25301: LD_VAR 0 6
25305: PUSH
25306: FOR_IN
25307: IFFALSE 25332
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25309: LD_ADDR_VAR 0 17
25313: PUSH
25314: LD_VAR 0 17
25318: PUSH
25319: LD_VAR 0 8
25323: PPUSH
25324: CALL_OW 478
25328: UNION
25329: ST_TO_ADDR
25330: GO 25306
25332: POP
25333: POP
// if not fac_list then
25334: LD_VAR 0 17
25338: NOT
25339: IFFALSE 25343
// exit ;
25341: GO 26262
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25343: LD_ADDR_VAR 0 5
25347: PUSH
25348: LD_INT 4
25350: PUSH
25351: LD_INT 5
25353: PUSH
25354: LD_INT 9
25356: PUSH
25357: LD_INT 10
25359: PUSH
25360: LD_INT 6
25362: PUSH
25363: LD_INT 7
25365: PUSH
25366: LD_INT 11
25368: PUSH
25369: EMPTY
25370: LIST
25371: LIST
25372: LIST
25373: LIST
25374: LIST
25375: LIST
25376: LIST
25377: PUSH
25378: LD_INT 27
25380: PUSH
25381: LD_INT 28
25383: PUSH
25384: LD_INT 26
25386: PUSH
25387: LD_INT 30
25389: PUSH
25390: EMPTY
25391: LIST
25392: LIST
25393: LIST
25394: LIST
25395: PUSH
25396: LD_INT 43
25398: PUSH
25399: LD_INT 44
25401: PUSH
25402: LD_INT 46
25404: PUSH
25405: LD_INT 45
25407: PUSH
25408: LD_INT 47
25410: PUSH
25411: LD_INT 49
25413: PUSH
25414: EMPTY
25415: LIST
25416: LIST
25417: LIST
25418: LIST
25419: LIST
25420: LIST
25421: PUSH
25422: EMPTY
25423: LIST
25424: LIST
25425: LIST
25426: PUSH
25427: LD_VAR 0 12
25431: ARRAY
25432: ST_TO_ADDR
// list := list isect fac_list ;
25433: LD_ADDR_VAR 0 5
25437: PUSH
25438: LD_VAR 0 5
25442: PUSH
25443: LD_VAR 0 17
25447: ISECT
25448: ST_TO_ADDR
// if not list then
25449: LD_VAR 0 5
25453: NOT
25454: IFFALSE 25458
// exit ;
25456: GO 26262
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25458: LD_VAR 0 12
25462: PUSH
25463: LD_INT 3
25465: EQUAL
25466: PUSH
25467: LD_INT 49
25469: PUSH
25470: LD_VAR 0 5
25474: IN
25475: AND
25476: PUSH
25477: LD_INT 31
25479: PPUSH
25480: LD_VAR 0 16
25484: PPUSH
25485: CALL_OW 321
25489: PUSH
25490: LD_INT 2
25492: EQUAL
25493: AND
25494: IFFALSE 25554
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25496: LD_INT 22
25498: PUSH
25499: LD_VAR 0 16
25503: PUSH
25504: EMPTY
25505: LIST
25506: LIST
25507: PUSH
25508: LD_INT 35
25510: PUSH
25511: LD_INT 49
25513: PUSH
25514: EMPTY
25515: LIST
25516: LIST
25517: PUSH
25518: LD_INT 91
25520: PUSH
25521: LD_VAR 0 1
25525: PUSH
25526: LD_INT 10
25528: PUSH
25529: EMPTY
25530: LIST
25531: LIST
25532: LIST
25533: PUSH
25534: EMPTY
25535: LIST
25536: LIST
25537: LIST
25538: PPUSH
25539: CALL_OW 69
25543: NOT
25544: IFFALSE 25554
// weapon := ru_time_lapser ;
25546: LD_ADDR_VAR 0 18
25550: PUSH
25551: LD_INT 49
25553: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25554: LD_VAR 0 12
25558: PUSH
25559: LD_INT 1
25561: PUSH
25562: LD_INT 2
25564: PUSH
25565: EMPTY
25566: LIST
25567: LIST
25568: IN
25569: PUSH
25570: LD_INT 11
25572: PUSH
25573: LD_VAR 0 5
25577: IN
25578: PUSH
25579: LD_INT 30
25581: PUSH
25582: LD_VAR 0 5
25586: IN
25587: OR
25588: AND
25589: PUSH
25590: LD_INT 6
25592: PPUSH
25593: LD_VAR 0 16
25597: PPUSH
25598: CALL_OW 321
25602: PUSH
25603: LD_INT 2
25605: EQUAL
25606: AND
25607: IFFALSE 25772
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25609: LD_INT 22
25611: PUSH
25612: LD_VAR 0 16
25616: PUSH
25617: EMPTY
25618: LIST
25619: LIST
25620: PUSH
25621: LD_INT 2
25623: PUSH
25624: LD_INT 35
25626: PUSH
25627: LD_INT 11
25629: PUSH
25630: EMPTY
25631: LIST
25632: LIST
25633: PUSH
25634: LD_INT 35
25636: PUSH
25637: LD_INT 30
25639: PUSH
25640: EMPTY
25641: LIST
25642: LIST
25643: PUSH
25644: EMPTY
25645: LIST
25646: LIST
25647: LIST
25648: PUSH
25649: LD_INT 91
25651: PUSH
25652: LD_VAR 0 1
25656: PUSH
25657: LD_INT 18
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: LIST
25664: PUSH
25665: EMPTY
25666: LIST
25667: LIST
25668: LIST
25669: PPUSH
25670: CALL_OW 69
25674: NOT
25675: PUSH
25676: LD_INT 22
25678: PUSH
25679: LD_VAR 0 16
25683: PUSH
25684: EMPTY
25685: LIST
25686: LIST
25687: PUSH
25688: LD_INT 2
25690: PUSH
25691: LD_INT 30
25693: PUSH
25694: LD_INT 32
25696: PUSH
25697: EMPTY
25698: LIST
25699: LIST
25700: PUSH
25701: LD_INT 30
25703: PUSH
25704: LD_INT 33
25706: PUSH
25707: EMPTY
25708: LIST
25709: LIST
25710: PUSH
25711: EMPTY
25712: LIST
25713: LIST
25714: LIST
25715: PUSH
25716: LD_INT 91
25718: PUSH
25719: LD_VAR 0 1
25723: PUSH
25724: LD_INT 12
25726: PUSH
25727: EMPTY
25728: LIST
25729: LIST
25730: LIST
25731: PUSH
25732: EMPTY
25733: LIST
25734: LIST
25735: LIST
25736: PUSH
25737: EMPTY
25738: LIST
25739: PPUSH
25740: CALL_OW 69
25744: PUSH
25745: LD_INT 2
25747: GREATER
25748: AND
25749: IFFALSE 25772
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25751: LD_ADDR_VAR 0 18
25755: PUSH
25756: LD_INT 11
25758: PUSH
25759: LD_INT 30
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PUSH
25766: LD_VAR 0 12
25770: ARRAY
25771: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25772: LD_VAR 0 18
25776: NOT
25777: PUSH
25778: LD_INT 40
25780: PPUSH
25781: LD_VAR 0 16
25785: PPUSH
25786: CALL_OW 321
25790: PUSH
25791: LD_INT 2
25793: EQUAL
25794: AND
25795: PUSH
25796: LD_INT 7
25798: PUSH
25799: LD_VAR 0 5
25803: IN
25804: PUSH
25805: LD_INT 28
25807: PUSH
25808: LD_VAR 0 5
25812: IN
25813: OR
25814: PUSH
25815: LD_INT 45
25817: PUSH
25818: LD_VAR 0 5
25822: IN
25823: OR
25824: AND
25825: IFFALSE 26079
// begin hex := GetHexInfo ( x , y ) ;
25827: LD_ADDR_VAR 0 4
25831: PUSH
25832: LD_VAR 0 10
25836: PPUSH
25837: LD_VAR 0 11
25841: PPUSH
25842: CALL_OW 546
25846: ST_TO_ADDR
// if hex [ 1 ] then
25847: LD_VAR 0 4
25851: PUSH
25852: LD_INT 1
25854: ARRAY
25855: IFFALSE 25859
// exit ;
25857: GO 26262
// height := hex [ 2 ] ;
25859: LD_ADDR_VAR 0 15
25863: PUSH
25864: LD_VAR 0 4
25868: PUSH
25869: LD_INT 2
25871: ARRAY
25872: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25873: LD_ADDR_VAR 0 14
25877: PUSH
25878: LD_INT 0
25880: PUSH
25881: LD_INT 2
25883: PUSH
25884: LD_INT 3
25886: PUSH
25887: LD_INT 5
25889: PUSH
25890: EMPTY
25891: LIST
25892: LIST
25893: LIST
25894: LIST
25895: ST_TO_ADDR
// for i in tmp do
25896: LD_ADDR_VAR 0 8
25900: PUSH
25901: LD_VAR 0 14
25905: PUSH
25906: FOR_IN
25907: IFFALSE 26077
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25909: LD_ADDR_VAR 0 9
25913: PUSH
25914: LD_VAR 0 10
25918: PPUSH
25919: LD_VAR 0 8
25923: PPUSH
25924: LD_INT 5
25926: PPUSH
25927: CALL_OW 272
25931: PUSH
25932: LD_VAR 0 11
25936: PPUSH
25937: LD_VAR 0 8
25941: PPUSH
25942: LD_INT 5
25944: PPUSH
25945: CALL_OW 273
25949: PUSH
25950: EMPTY
25951: LIST
25952: LIST
25953: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25954: LD_VAR 0 9
25958: PUSH
25959: LD_INT 1
25961: ARRAY
25962: PPUSH
25963: LD_VAR 0 9
25967: PUSH
25968: LD_INT 2
25970: ARRAY
25971: PPUSH
25972: CALL_OW 488
25976: IFFALSE 26075
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25978: LD_ADDR_VAR 0 4
25982: PUSH
25983: LD_VAR 0 9
25987: PUSH
25988: LD_INT 1
25990: ARRAY
25991: PPUSH
25992: LD_VAR 0 9
25996: PUSH
25997: LD_INT 2
25999: ARRAY
26000: PPUSH
26001: CALL_OW 546
26005: ST_TO_ADDR
// if hex [ 1 ] then
26006: LD_VAR 0 4
26010: PUSH
26011: LD_INT 1
26013: ARRAY
26014: IFFALSE 26018
// continue ;
26016: GO 25906
// h := hex [ 2 ] ;
26018: LD_ADDR_VAR 0 13
26022: PUSH
26023: LD_VAR 0 4
26027: PUSH
26028: LD_INT 2
26030: ARRAY
26031: ST_TO_ADDR
// if h + 7 < height then
26032: LD_VAR 0 13
26036: PUSH
26037: LD_INT 7
26039: PLUS
26040: PUSH
26041: LD_VAR 0 15
26045: LESS
26046: IFFALSE 26075
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26048: LD_ADDR_VAR 0 18
26052: PUSH
26053: LD_INT 7
26055: PUSH
26056: LD_INT 28
26058: PUSH
26059: LD_INT 45
26061: PUSH
26062: EMPTY
26063: LIST
26064: LIST
26065: LIST
26066: PUSH
26067: LD_VAR 0 12
26071: ARRAY
26072: ST_TO_ADDR
// break ;
26073: GO 26077
// end ; end ; end ;
26075: GO 25906
26077: POP
26078: POP
// end ; if not weapon then
26079: LD_VAR 0 18
26083: NOT
26084: IFFALSE 26144
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26086: LD_ADDR_VAR 0 5
26090: PUSH
26091: LD_VAR 0 5
26095: PUSH
26096: LD_INT 11
26098: PUSH
26099: LD_INT 30
26101: PUSH
26102: LD_INT 49
26104: PUSH
26105: EMPTY
26106: LIST
26107: LIST
26108: LIST
26109: DIFF
26110: ST_TO_ADDR
// if not list then
26111: LD_VAR 0 5
26115: NOT
26116: IFFALSE 26120
// exit ;
26118: GO 26262
// weapon := list [ rand ( 1 , list ) ] ;
26120: LD_ADDR_VAR 0 18
26124: PUSH
26125: LD_VAR 0 5
26129: PUSH
26130: LD_INT 1
26132: PPUSH
26133: LD_VAR 0 5
26137: PPUSH
26138: CALL_OW 12
26142: ARRAY
26143: ST_TO_ADDR
// end ; if weapon then
26144: LD_VAR 0 18
26148: IFFALSE 26262
// begin tmp := CostOfWeapon ( weapon ) ;
26150: LD_ADDR_VAR 0 14
26154: PUSH
26155: LD_VAR 0 18
26159: PPUSH
26160: CALL_OW 451
26164: ST_TO_ADDR
// j := GetBase ( tower ) ;
26165: LD_ADDR_VAR 0 9
26169: PUSH
26170: LD_VAR 0 1
26174: PPUSH
26175: CALL_OW 274
26179: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26180: LD_VAR 0 9
26184: PPUSH
26185: LD_INT 1
26187: PPUSH
26188: CALL_OW 275
26192: PUSH
26193: LD_VAR 0 14
26197: PUSH
26198: LD_INT 1
26200: ARRAY
26201: GREATEREQUAL
26202: PUSH
26203: LD_VAR 0 9
26207: PPUSH
26208: LD_INT 2
26210: PPUSH
26211: CALL_OW 275
26215: PUSH
26216: LD_VAR 0 14
26220: PUSH
26221: LD_INT 2
26223: ARRAY
26224: GREATEREQUAL
26225: AND
26226: PUSH
26227: LD_VAR 0 9
26231: PPUSH
26232: LD_INT 3
26234: PPUSH
26235: CALL_OW 275
26239: PUSH
26240: LD_VAR 0 14
26244: PUSH
26245: LD_INT 3
26247: ARRAY
26248: GREATEREQUAL
26249: AND
26250: IFFALSE 26262
// result := weapon ;
26252: LD_ADDR_VAR 0 3
26256: PUSH
26257: LD_VAR 0 18
26261: ST_TO_ADDR
// end ; end ;
26262: LD_VAR 0 3
26266: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26267: LD_INT 0
26269: PPUSH
26270: PPUSH
// result := true ;
26271: LD_ADDR_VAR 0 3
26275: PUSH
26276: LD_INT 1
26278: ST_TO_ADDR
// if array1 = array2 then
26279: LD_VAR 0 1
26283: PUSH
26284: LD_VAR 0 2
26288: EQUAL
26289: IFFALSE 26349
// begin for i = 1 to array1 do
26291: LD_ADDR_VAR 0 4
26295: PUSH
26296: DOUBLE
26297: LD_INT 1
26299: DEC
26300: ST_TO_ADDR
26301: LD_VAR 0 1
26305: PUSH
26306: FOR_TO
26307: IFFALSE 26345
// if array1 [ i ] <> array2 [ i ] then
26309: LD_VAR 0 1
26313: PUSH
26314: LD_VAR 0 4
26318: ARRAY
26319: PUSH
26320: LD_VAR 0 2
26324: PUSH
26325: LD_VAR 0 4
26329: ARRAY
26330: NONEQUAL
26331: IFFALSE 26343
// begin result := false ;
26333: LD_ADDR_VAR 0 3
26337: PUSH
26338: LD_INT 0
26340: ST_TO_ADDR
// break ;
26341: GO 26345
// end ;
26343: GO 26306
26345: POP
26346: POP
// end else
26347: GO 26357
// result := false ;
26349: LD_ADDR_VAR 0 3
26353: PUSH
26354: LD_INT 0
26356: ST_TO_ADDR
// end ;
26357: LD_VAR 0 3
26361: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
26362: LD_INT 0
26364: PPUSH
26365: PPUSH
// if not array1 or not array2 then
26366: LD_VAR 0 1
26370: NOT
26371: PUSH
26372: LD_VAR 0 2
26376: NOT
26377: OR
26378: IFFALSE 26382
// exit ;
26380: GO 26446
// result := true ;
26382: LD_ADDR_VAR 0 3
26386: PUSH
26387: LD_INT 1
26389: ST_TO_ADDR
// for i = 1 to array1 do
26390: LD_ADDR_VAR 0 4
26394: PUSH
26395: DOUBLE
26396: LD_INT 1
26398: DEC
26399: ST_TO_ADDR
26400: LD_VAR 0 1
26404: PUSH
26405: FOR_TO
26406: IFFALSE 26444
// if array1 [ i ] <> array2 [ i ] then
26408: LD_VAR 0 1
26412: PUSH
26413: LD_VAR 0 4
26417: ARRAY
26418: PUSH
26419: LD_VAR 0 2
26423: PUSH
26424: LD_VAR 0 4
26428: ARRAY
26429: NONEQUAL
26430: IFFALSE 26442
// begin result := false ;
26432: LD_ADDR_VAR 0 3
26436: PUSH
26437: LD_INT 0
26439: ST_TO_ADDR
// break ;
26440: GO 26444
// end ;
26442: GO 26405
26444: POP
26445: POP
// end ;
26446: LD_VAR 0 3
26450: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26451: LD_INT 0
26453: PPUSH
26454: PPUSH
26455: PPUSH
// pom := GetBase ( fac ) ;
26456: LD_ADDR_VAR 0 5
26460: PUSH
26461: LD_VAR 0 1
26465: PPUSH
26466: CALL_OW 274
26470: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26471: LD_ADDR_VAR 0 4
26475: PUSH
26476: LD_VAR 0 2
26480: PUSH
26481: LD_INT 1
26483: ARRAY
26484: PPUSH
26485: LD_VAR 0 2
26489: PUSH
26490: LD_INT 2
26492: ARRAY
26493: PPUSH
26494: LD_VAR 0 2
26498: PUSH
26499: LD_INT 3
26501: ARRAY
26502: PPUSH
26503: LD_VAR 0 2
26507: PUSH
26508: LD_INT 4
26510: ARRAY
26511: PPUSH
26512: CALL_OW 449
26516: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26517: LD_ADDR_VAR 0 3
26521: PUSH
26522: LD_VAR 0 5
26526: PPUSH
26527: LD_INT 1
26529: PPUSH
26530: CALL_OW 275
26534: PUSH
26535: LD_VAR 0 4
26539: PUSH
26540: LD_INT 1
26542: ARRAY
26543: GREATEREQUAL
26544: PUSH
26545: LD_VAR 0 5
26549: PPUSH
26550: LD_INT 2
26552: PPUSH
26553: CALL_OW 275
26557: PUSH
26558: LD_VAR 0 4
26562: PUSH
26563: LD_INT 2
26565: ARRAY
26566: GREATEREQUAL
26567: AND
26568: PUSH
26569: LD_VAR 0 5
26573: PPUSH
26574: LD_INT 3
26576: PPUSH
26577: CALL_OW 275
26581: PUSH
26582: LD_VAR 0 4
26586: PUSH
26587: LD_INT 3
26589: ARRAY
26590: GREATEREQUAL
26591: AND
26592: ST_TO_ADDR
// end ;
26593: LD_VAR 0 3
26597: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26598: LD_INT 0
26600: PPUSH
26601: PPUSH
26602: PPUSH
26603: PPUSH
// pom := GetBase ( building ) ;
26604: LD_ADDR_VAR 0 3
26608: PUSH
26609: LD_VAR 0 1
26613: PPUSH
26614: CALL_OW 274
26618: ST_TO_ADDR
// if not pom then
26619: LD_VAR 0 3
26623: NOT
26624: IFFALSE 26628
// exit ;
26626: GO 26798
// btype := GetBType ( building ) ;
26628: LD_ADDR_VAR 0 5
26632: PUSH
26633: LD_VAR 0 1
26637: PPUSH
26638: CALL_OW 266
26642: ST_TO_ADDR
// if btype = b_armoury then
26643: LD_VAR 0 5
26647: PUSH
26648: LD_INT 4
26650: EQUAL
26651: IFFALSE 26661
// btype := b_barracks ;
26653: LD_ADDR_VAR 0 5
26657: PUSH
26658: LD_INT 5
26660: ST_TO_ADDR
// if btype = b_depot then
26661: LD_VAR 0 5
26665: PUSH
26666: LD_INT 0
26668: EQUAL
26669: IFFALSE 26679
// btype := b_warehouse ;
26671: LD_ADDR_VAR 0 5
26675: PUSH
26676: LD_INT 1
26678: ST_TO_ADDR
// if btype = b_workshop then
26679: LD_VAR 0 5
26683: PUSH
26684: LD_INT 2
26686: EQUAL
26687: IFFALSE 26697
// btype := b_factory ;
26689: LD_ADDR_VAR 0 5
26693: PUSH
26694: LD_INT 3
26696: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26697: LD_ADDR_VAR 0 4
26701: PUSH
26702: LD_VAR 0 5
26706: PPUSH
26707: LD_VAR 0 1
26711: PPUSH
26712: CALL_OW 248
26716: PPUSH
26717: CALL_OW 450
26721: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26722: LD_ADDR_VAR 0 2
26726: PUSH
26727: LD_VAR 0 3
26731: PPUSH
26732: LD_INT 1
26734: PPUSH
26735: CALL_OW 275
26739: PUSH
26740: LD_VAR 0 4
26744: PUSH
26745: LD_INT 1
26747: ARRAY
26748: GREATEREQUAL
26749: PUSH
26750: LD_VAR 0 3
26754: PPUSH
26755: LD_INT 2
26757: PPUSH
26758: CALL_OW 275
26762: PUSH
26763: LD_VAR 0 4
26767: PUSH
26768: LD_INT 2
26770: ARRAY
26771: GREATEREQUAL
26772: AND
26773: PUSH
26774: LD_VAR 0 3
26778: PPUSH
26779: LD_INT 3
26781: PPUSH
26782: CALL_OW 275
26786: PUSH
26787: LD_VAR 0 4
26791: PUSH
26792: LD_INT 3
26794: ARRAY
26795: GREATEREQUAL
26796: AND
26797: ST_TO_ADDR
// end ;
26798: LD_VAR 0 2
26802: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26803: LD_INT 0
26805: PPUSH
26806: PPUSH
26807: PPUSH
// pom := GetBase ( building ) ;
26808: LD_ADDR_VAR 0 4
26812: PUSH
26813: LD_VAR 0 1
26817: PPUSH
26818: CALL_OW 274
26822: ST_TO_ADDR
// if not pom then
26823: LD_VAR 0 4
26827: NOT
26828: IFFALSE 26832
// exit ;
26830: GO 26933
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26832: LD_ADDR_VAR 0 5
26836: PUSH
26837: LD_VAR 0 2
26841: PPUSH
26842: LD_VAR 0 1
26846: PPUSH
26847: CALL_OW 248
26851: PPUSH
26852: CALL_OW 450
26856: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26857: LD_ADDR_VAR 0 3
26861: PUSH
26862: LD_VAR 0 4
26866: PPUSH
26867: LD_INT 1
26869: PPUSH
26870: CALL_OW 275
26874: PUSH
26875: LD_VAR 0 5
26879: PUSH
26880: LD_INT 1
26882: ARRAY
26883: GREATEREQUAL
26884: PUSH
26885: LD_VAR 0 4
26889: PPUSH
26890: LD_INT 2
26892: PPUSH
26893: CALL_OW 275
26897: PUSH
26898: LD_VAR 0 5
26902: PUSH
26903: LD_INT 2
26905: ARRAY
26906: GREATEREQUAL
26907: AND
26908: PUSH
26909: LD_VAR 0 4
26913: PPUSH
26914: LD_INT 3
26916: PPUSH
26917: CALL_OW 275
26921: PUSH
26922: LD_VAR 0 5
26926: PUSH
26927: LD_INT 3
26929: ARRAY
26930: GREATEREQUAL
26931: AND
26932: ST_TO_ADDR
// end ;
26933: LD_VAR 0 3
26937: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
26938: LD_INT 0
26940: PPUSH
26941: PPUSH
26942: PPUSH
26943: PPUSH
26944: PPUSH
26945: PPUSH
26946: PPUSH
26947: PPUSH
26948: PPUSH
26949: PPUSH
26950: PPUSH
// result := false ;
26951: LD_ADDR_VAR 0 8
26955: PUSH
26956: LD_INT 0
26958: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
26959: LD_VAR 0 5
26963: NOT
26964: PUSH
26965: LD_VAR 0 1
26969: NOT
26970: OR
26971: PUSH
26972: LD_VAR 0 2
26976: NOT
26977: OR
26978: PUSH
26979: LD_VAR 0 3
26983: NOT
26984: OR
26985: IFFALSE 26989
// exit ;
26987: GO 27803
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
26989: LD_ADDR_VAR 0 14
26993: PUSH
26994: LD_VAR 0 1
26998: PPUSH
26999: LD_VAR 0 2
27003: PPUSH
27004: LD_VAR 0 3
27008: PPUSH
27009: LD_VAR 0 4
27013: PPUSH
27014: LD_VAR 0 5
27018: PUSH
27019: LD_INT 1
27021: ARRAY
27022: PPUSH
27023: CALL_OW 248
27027: PPUSH
27028: LD_INT 0
27030: PPUSH
27031: CALL 29036 0 6
27035: ST_TO_ADDR
// if not hexes then
27036: LD_VAR 0 14
27040: NOT
27041: IFFALSE 27045
// exit ;
27043: GO 27803
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27045: LD_ADDR_VAR 0 17
27049: PUSH
27050: LD_VAR 0 5
27054: PPUSH
27055: LD_INT 22
27057: PUSH
27058: LD_VAR 0 13
27062: PPUSH
27063: CALL_OW 255
27067: PUSH
27068: EMPTY
27069: LIST
27070: LIST
27071: PUSH
27072: LD_INT 2
27074: PUSH
27075: LD_INT 30
27077: PUSH
27078: LD_INT 0
27080: PUSH
27081: EMPTY
27082: LIST
27083: LIST
27084: PUSH
27085: LD_INT 30
27087: PUSH
27088: LD_INT 1
27090: PUSH
27091: EMPTY
27092: LIST
27093: LIST
27094: PUSH
27095: EMPTY
27096: LIST
27097: LIST
27098: LIST
27099: PUSH
27100: EMPTY
27101: LIST
27102: LIST
27103: PPUSH
27104: CALL_OW 72
27108: ST_TO_ADDR
// for i = 1 to hexes do
27109: LD_ADDR_VAR 0 9
27113: PUSH
27114: DOUBLE
27115: LD_INT 1
27117: DEC
27118: ST_TO_ADDR
27119: LD_VAR 0 14
27123: PUSH
27124: FOR_TO
27125: IFFALSE 27801
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27127: LD_ADDR_VAR 0 13
27131: PUSH
27132: LD_VAR 0 14
27136: PUSH
27137: LD_VAR 0 9
27141: ARRAY
27142: PUSH
27143: LD_INT 1
27145: ARRAY
27146: PPUSH
27147: LD_VAR 0 14
27151: PUSH
27152: LD_VAR 0 9
27156: ARRAY
27157: PUSH
27158: LD_INT 2
27160: ARRAY
27161: PPUSH
27162: CALL_OW 428
27166: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27167: LD_VAR 0 14
27171: PUSH
27172: LD_VAR 0 9
27176: ARRAY
27177: PUSH
27178: LD_INT 1
27180: ARRAY
27181: PPUSH
27182: LD_VAR 0 14
27186: PUSH
27187: LD_VAR 0 9
27191: ARRAY
27192: PUSH
27193: LD_INT 2
27195: ARRAY
27196: PPUSH
27197: CALL_OW 351
27201: PUSH
27202: LD_VAR 0 14
27206: PUSH
27207: LD_VAR 0 9
27211: ARRAY
27212: PUSH
27213: LD_INT 1
27215: ARRAY
27216: PPUSH
27217: LD_VAR 0 14
27221: PUSH
27222: LD_VAR 0 9
27226: ARRAY
27227: PUSH
27228: LD_INT 2
27230: ARRAY
27231: PPUSH
27232: CALL_OW 488
27236: NOT
27237: OR
27238: PUSH
27239: LD_VAR 0 13
27243: PPUSH
27244: CALL_OW 247
27248: PUSH
27249: LD_INT 3
27251: EQUAL
27252: OR
27253: IFFALSE 27259
// exit ;
27255: POP
27256: POP
27257: GO 27803
// if not tmp then
27259: LD_VAR 0 13
27263: NOT
27264: IFFALSE 27268
// continue ;
27266: GO 27124
// result := true ;
27268: LD_ADDR_VAR 0 8
27272: PUSH
27273: LD_INT 1
27275: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
27276: LD_VAR 0 6
27280: PUSH
27281: LD_VAR 0 13
27285: PPUSH
27286: CALL_OW 247
27290: PUSH
27291: LD_INT 2
27293: EQUAL
27294: AND
27295: PUSH
27296: LD_VAR 0 13
27300: PPUSH
27301: CALL_OW 263
27305: PUSH
27306: LD_INT 1
27308: EQUAL
27309: AND
27310: IFFALSE 27474
// begin if IsDrivenBy ( tmp ) then
27312: LD_VAR 0 13
27316: PPUSH
27317: CALL_OW 311
27321: IFFALSE 27325
// continue ;
27323: GO 27124
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
27325: LD_VAR 0 6
27329: PPUSH
27330: LD_INT 3
27332: PUSH
27333: LD_INT 60
27335: PUSH
27336: EMPTY
27337: LIST
27338: PUSH
27339: EMPTY
27340: LIST
27341: LIST
27342: PUSH
27343: LD_INT 3
27345: PUSH
27346: LD_INT 55
27348: PUSH
27349: EMPTY
27350: LIST
27351: PUSH
27352: EMPTY
27353: LIST
27354: LIST
27355: PUSH
27356: EMPTY
27357: LIST
27358: LIST
27359: PPUSH
27360: CALL_OW 72
27364: IFFALSE 27472
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
27366: LD_ADDR_VAR 0 18
27370: PUSH
27371: LD_VAR 0 6
27375: PPUSH
27376: LD_INT 3
27378: PUSH
27379: LD_INT 60
27381: PUSH
27382: EMPTY
27383: LIST
27384: PUSH
27385: EMPTY
27386: LIST
27387: LIST
27388: PUSH
27389: LD_INT 3
27391: PUSH
27392: LD_INT 55
27394: PUSH
27395: EMPTY
27396: LIST
27397: PUSH
27398: EMPTY
27399: LIST
27400: LIST
27401: PUSH
27402: EMPTY
27403: LIST
27404: LIST
27405: PPUSH
27406: CALL_OW 72
27410: PUSH
27411: LD_INT 1
27413: ARRAY
27414: ST_TO_ADDR
// if IsInUnit ( driver ) then
27415: LD_VAR 0 18
27419: PPUSH
27420: CALL_OW 310
27424: IFFALSE 27435
// ComExit ( driver ) ;
27426: LD_VAR 0 18
27430: PPUSH
27431: CALL 52816 0 1
// AddComEnterUnit ( driver , tmp ) ;
27435: LD_VAR 0 18
27439: PPUSH
27440: LD_VAR 0 13
27444: PPUSH
27445: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
27449: LD_VAR 0 18
27453: PPUSH
27454: LD_VAR 0 7
27458: PPUSH
27459: CALL_OW 173
// AddComExitVehicle ( driver ) ;
27463: LD_VAR 0 18
27467: PPUSH
27468: CALL_OW 181
// end ; continue ;
27472: GO 27124
// end ; if not cleaners or not tmp in cleaners then
27474: LD_VAR 0 6
27478: NOT
27479: PUSH
27480: LD_VAR 0 13
27484: PUSH
27485: LD_VAR 0 6
27489: IN
27490: NOT
27491: OR
27492: IFFALSE 27799
// begin if dep then
27494: LD_VAR 0 17
27498: IFFALSE 27634
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27500: LD_ADDR_VAR 0 16
27504: PUSH
27505: LD_VAR 0 17
27509: PUSH
27510: LD_INT 1
27512: ARRAY
27513: PPUSH
27514: CALL_OW 250
27518: PPUSH
27519: LD_VAR 0 17
27523: PUSH
27524: LD_INT 1
27526: ARRAY
27527: PPUSH
27528: CALL_OW 254
27532: PPUSH
27533: LD_INT 5
27535: PPUSH
27536: CALL_OW 272
27540: PUSH
27541: LD_VAR 0 17
27545: PUSH
27546: LD_INT 1
27548: ARRAY
27549: PPUSH
27550: CALL_OW 251
27554: PPUSH
27555: LD_VAR 0 17
27559: PUSH
27560: LD_INT 1
27562: ARRAY
27563: PPUSH
27564: CALL_OW 254
27568: PPUSH
27569: LD_INT 5
27571: PPUSH
27572: CALL_OW 273
27576: PUSH
27577: EMPTY
27578: LIST
27579: LIST
27580: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27581: LD_VAR 0 16
27585: PUSH
27586: LD_INT 1
27588: ARRAY
27589: PPUSH
27590: LD_VAR 0 16
27594: PUSH
27595: LD_INT 2
27597: ARRAY
27598: PPUSH
27599: CALL_OW 488
27603: IFFALSE 27634
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27605: LD_VAR 0 13
27609: PPUSH
27610: LD_VAR 0 16
27614: PUSH
27615: LD_INT 1
27617: ARRAY
27618: PPUSH
27619: LD_VAR 0 16
27623: PUSH
27624: LD_INT 2
27626: ARRAY
27627: PPUSH
27628: CALL_OW 111
// continue ;
27632: GO 27124
// end ; end ; r := GetDir ( tmp ) ;
27634: LD_ADDR_VAR 0 15
27638: PUSH
27639: LD_VAR 0 13
27643: PPUSH
27644: CALL_OW 254
27648: ST_TO_ADDR
// if r = 5 then
27649: LD_VAR 0 15
27653: PUSH
27654: LD_INT 5
27656: EQUAL
27657: IFFALSE 27667
// r := 0 ;
27659: LD_ADDR_VAR 0 15
27663: PUSH
27664: LD_INT 0
27666: ST_TO_ADDR
// for j = r to 5 do
27667: LD_ADDR_VAR 0 10
27671: PUSH
27672: DOUBLE
27673: LD_VAR 0 15
27677: DEC
27678: ST_TO_ADDR
27679: LD_INT 5
27681: PUSH
27682: FOR_TO
27683: IFFALSE 27797
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27685: LD_ADDR_VAR 0 11
27689: PUSH
27690: LD_VAR 0 13
27694: PPUSH
27695: CALL_OW 250
27699: PPUSH
27700: LD_VAR 0 10
27704: PPUSH
27705: LD_INT 2
27707: PPUSH
27708: CALL_OW 272
27712: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27713: LD_ADDR_VAR 0 12
27717: PUSH
27718: LD_VAR 0 13
27722: PPUSH
27723: CALL_OW 251
27727: PPUSH
27728: LD_VAR 0 10
27732: PPUSH
27733: LD_INT 2
27735: PPUSH
27736: CALL_OW 273
27740: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27741: LD_VAR 0 11
27745: PPUSH
27746: LD_VAR 0 12
27750: PPUSH
27751: CALL_OW 488
27755: PUSH
27756: LD_VAR 0 11
27760: PPUSH
27761: LD_VAR 0 12
27765: PPUSH
27766: CALL_OW 428
27770: NOT
27771: AND
27772: IFFALSE 27795
// begin ComMoveXY ( tmp , _x , _y ) ;
27774: LD_VAR 0 13
27778: PPUSH
27779: LD_VAR 0 11
27783: PPUSH
27784: LD_VAR 0 12
27788: PPUSH
27789: CALL_OW 111
// break ;
27793: GO 27797
// end ; end ;
27795: GO 27682
27797: POP
27798: POP
// end ; end ;
27799: GO 27124
27801: POP
27802: POP
// end ;
27803: LD_VAR 0 8
27807: RET
// export function BuildingTechInvented ( side , btype ) ; begin
27808: LD_INT 0
27810: PPUSH
// result := true ;
27811: LD_ADDR_VAR 0 3
27815: PUSH
27816: LD_INT 1
27818: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
27819: LD_VAR 0 2
27823: PUSH
27824: LD_INT 24
27826: DOUBLE
27827: EQUAL
27828: IFTRUE 27838
27830: LD_INT 33
27832: DOUBLE
27833: EQUAL
27834: IFTRUE 27838
27836: GO 27863
27838: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
27839: LD_ADDR_VAR 0 3
27843: PUSH
27844: LD_INT 32
27846: PPUSH
27847: LD_VAR 0 1
27851: PPUSH
27852: CALL_OW 321
27856: PUSH
27857: LD_INT 2
27859: EQUAL
27860: ST_TO_ADDR
27861: GO 28179
27863: LD_INT 20
27865: DOUBLE
27866: EQUAL
27867: IFTRUE 27871
27869: GO 27896
27871: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
27872: LD_ADDR_VAR 0 3
27876: PUSH
27877: LD_INT 6
27879: PPUSH
27880: LD_VAR 0 1
27884: PPUSH
27885: CALL_OW 321
27889: PUSH
27890: LD_INT 2
27892: EQUAL
27893: ST_TO_ADDR
27894: GO 28179
27896: LD_INT 22
27898: DOUBLE
27899: EQUAL
27900: IFTRUE 27910
27902: LD_INT 36
27904: DOUBLE
27905: EQUAL
27906: IFTRUE 27910
27908: GO 27935
27910: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
27911: LD_ADDR_VAR 0 3
27915: PUSH
27916: LD_INT 15
27918: PPUSH
27919: LD_VAR 0 1
27923: PPUSH
27924: CALL_OW 321
27928: PUSH
27929: LD_INT 2
27931: EQUAL
27932: ST_TO_ADDR
27933: GO 28179
27935: LD_INT 30
27937: DOUBLE
27938: EQUAL
27939: IFTRUE 27943
27941: GO 27968
27943: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
27944: LD_ADDR_VAR 0 3
27948: PUSH
27949: LD_INT 20
27951: PPUSH
27952: LD_VAR 0 1
27956: PPUSH
27957: CALL_OW 321
27961: PUSH
27962: LD_INT 2
27964: EQUAL
27965: ST_TO_ADDR
27966: GO 28179
27968: LD_INT 28
27970: DOUBLE
27971: EQUAL
27972: IFTRUE 27982
27974: LD_INT 21
27976: DOUBLE
27977: EQUAL
27978: IFTRUE 27982
27980: GO 28007
27982: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
27983: LD_ADDR_VAR 0 3
27987: PUSH
27988: LD_INT 21
27990: PPUSH
27991: LD_VAR 0 1
27995: PPUSH
27996: CALL_OW 321
28000: PUSH
28001: LD_INT 2
28003: EQUAL
28004: ST_TO_ADDR
28005: GO 28179
28007: LD_INT 16
28009: DOUBLE
28010: EQUAL
28011: IFTRUE 28015
28013: GO 28040
28015: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
28016: LD_ADDR_VAR 0 3
28020: PUSH
28021: LD_INT 84
28023: PPUSH
28024: LD_VAR 0 1
28028: PPUSH
28029: CALL_OW 321
28033: PUSH
28034: LD_INT 2
28036: EQUAL
28037: ST_TO_ADDR
28038: GO 28179
28040: LD_INT 19
28042: DOUBLE
28043: EQUAL
28044: IFTRUE 28054
28046: LD_INT 23
28048: DOUBLE
28049: EQUAL
28050: IFTRUE 28054
28052: GO 28079
28054: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
28055: LD_ADDR_VAR 0 3
28059: PUSH
28060: LD_INT 83
28062: PPUSH
28063: LD_VAR 0 1
28067: PPUSH
28068: CALL_OW 321
28072: PUSH
28073: LD_INT 2
28075: EQUAL
28076: ST_TO_ADDR
28077: GO 28179
28079: LD_INT 17
28081: DOUBLE
28082: EQUAL
28083: IFTRUE 28087
28085: GO 28112
28087: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
28088: LD_ADDR_VAR 0 3
28092: PUSH
28093: LD_INT 39
28095: PPUSH
28096: LD_VAR 0 1
28100: PPUSH
28101: CALL_OW 321
28105: PUSH
28106: LD_INT 2
28108: EQUAL
28109: ST_TO_ADDR
28110: GO 28179
28112: LD_INT 18
28114: DOUBLE
28115: EQUAL
28116: IFTRUE 28120
28118: GO 28145
28120: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
28121: LD_ADDR_VAR 0 3
28125: PUSH
28126: LD_INT 40
28128: PPUSH
28129: LD_VAR 0 1
28133: PPUSH
28134: CALL_OW 321
28138: PUSH
28139: LD_INT 2
28141: EQUAL
28142: ST_TO_ADDR
28143: GO 28179
28145: LD_INT 27
28147: DOUBLE
28148: EQUAL
28149: IFTRUE 28153
28151: GO 28178
28153: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
28154: LD_ADDR_VAR 0 3
28158: PUSH
28159: LD_INT 35
28161: PPUSH
28162: LD_VAR 0 1
28166: PPUSH
28167: CALL_OW 321
28171: PUSH
28172: LD_INT 2
28174: EQUAL
28175: ST_TO_ADDR
28176: GO 28179
28178: POP
// end ;
28179: LD_VAR 0 3
28183: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
28184: LD_INT 0
28186: PPUSH
28187: PPUSH
28188: PPUSH
28189: PPUSH
28190: PPUSH
28191: PPUSH
28192: PPUSH
28193: PPUSH
28194: PPUSH
28195: PPUSH
28196: PPUSH
// result := false ;
28197: LD_ADDR_VAR 0 6
28201: PUSH
28202: LD_INT 0
28204: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28205: LD_VAR 0 1
28209: NOT
28210: PUSH
28211: LD_VAR 0 1
28215: PPUSH
28216: CALL_OW 266
28220: PUSH
28221: LD_INT 0
28223: PUSH
28224: LD_INT 1
28226: PUSH
28227: EMPTY
28228: LIST
28229: LIST
28230: IN
28231: NOT
28232: OR
28233: PUSH
28234: LD_VAR 0 2
28238: NOT
28239: OR
28240: PUSH
28241: LD_VAR 0 5
28245: PUSH
28246: LD_INT 0
28248: PUSH
28249: LD_INT 1
28251: PUSH
28252: LD_INT 2
28254: PUSH
28255: LD_INT 3
28257: PUSH
28258: LD_INT 4
28260: PUSH
28261: LD_INT 5
28263: PUSH
28264: EMPTY
28265: LIST
28266: LIST
28267: LIST
28268: LIST
28269: LIST
28270: LIST
28271: IN
28272: NOT
28273: OR
28274: PUSH
28275: LD_VAR 0 3
28279: PPUSH
28280: LD_VAR 0 4
28284: PPUSH
28285: CALL_OW 488
28289: NOT
28290: OR
28291: IFFALSE 28295
// exit ;
28293: GO 29031
// side := GetSide ( depot ) ;
28295: LD_ADDR_VAR 0 9
28299: PUSH
28300: LD_VAR 0 1
28304: PPUSH
28305: CALL_OW 255
28309: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
28310: LD_VAR 0 9
28314: PPUSH
28315: LD_VAR 0 2
28319: PPUSH
28320: CALL 27808 0 2
28324: NOT
28325: IFFALSE 28329
// exit ;
28327: GO 29031
// pom := GetBase ( depot ) ;
28329: LD_ADDR_VAR 0 10
28333: PUSH
28334: LD_VAR 0 1
28338: PPUSH
28339: CALL_OW 274
28343: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28344: LD_ADDR_VAR 0 11
28348: PUSH
28349: LD_VAR 0 2
28353: PPUSH
28354: LD_VAR 0 1
28358: PPUSH
28359: CALL_OW 248
28363: PPUSH
28364: CALL_OW 450
28368: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28369: LD_VAR 0 10
28373: PPUSH
28374: LD_INT 1
28376: PPUSH
28377: CALL_OW 275
28381: PUSH
28382: LD_VAR 0 11
28386: PUSH
28387: LD_INT 1
28389: ARRAY
28390: GREATEREQUAL
28391: PUSH
28392: LD_VAR 0 10
28396: PPUSH
28397: LD_INT 2
28399: PPUSH
28400: CALL_OW 275
28404: PUSH
28405: LD_VAR 0 11
28409: PUSH
28410: LD_INT 2
28412: ARRAY
28413: GREATEREQUAL
28414: AND
28415: PUSH
28416: LD_VAR 0 10
28420: PPUSH
28421: LD_INT 3
28423: PPUSH
28424: CALL_OW 275
28428: PUSH
28429: LD_VAR 0 11
28433: PUSH
28434: LD_INT 3
28436: ARRAY
28437: GREATEREQUAL
28438: AND
28439: NOT
28440: IFFALSE 28444
// exit ;
28442: GO 29031
// if GetBType ( depot ) = b_depot then
28444: LD_VAR 0 1
28448: PPUSH
28449: CALL_OW 266
28453: PUSH
28454: LD_INT 0
28456: EQUAL
28457: IFFALSE 28469
// dist := 28 else
28459: LD_ADDR_VAR 0 14
28463: PUSH
28464: LD_INT 28
28466: ST_TO_ADDR
28467: GO 28477
// dist := 36 ;
28469: LD_ADDR_VAR 0 14
28473: PUSH
28474: LD_INT 36
28476: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28477: LD_VAR 0 1
28481: PPUSH
28482: LD_VAR 0 3
28486: PPUSH
28487: LD_VAR 0 4
28491: PPUSH
28492: CALL_OW 297
28496: PUSH
28497: LD_VAR 0 14
28501: GREATER
28502: IFFALSE 28506
// exit ;
28504: GO 29031
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28506: LD_ADDR_VAR 0 12
28510: PUSH
28511: LD_VAR 0 2
28515: PPUSH
28516: LD_VAR 0 3
28520: PPUSH
28521: LD_VAR 0 4
28525: PPUSH
28526: LD_VAR 0 5
28530: PPUSH
28531: LD_VAR 0 1
28535: PPUSH
28536: CALL_OW 248
28540: PPUSH
28541: LD_INT 0
28543: PPUSH
28544: CALL 29036 0 6
28548: ST_TO_ADDR
// if not hexes then
28549: LD_VAR 0 12
28553: NOT
28554: IFFALSE 28558
// exit ;
28556: GO 29031
// hex := GetHexInfo ( x , y ) ;
28558: LD_ADDR_VAR 0 15
28562: PUSH
28563: LD_VAR 0 3
28567: PPUSH
28568: LD_VAR 0 4
28572: PPUSH
28573: CALL_OW 546
28577: ST_TO_ADDR
// if hex [ 1 ] then
28578: LD_VAR 0 15
28582: PUSH
28583: LD_INT 1
28585: ARRAY
28586: IFFALSE 28590
// exit ;
28588: GO 29031
// height := hex [ 2 ] ;
28590: LD_ADDR_VAR 0 13
28594: PUSH
28595: LD_VAR 0 15
28599: PUSH
28600: LD_INT 2
28602: ARRAY
28603: ST_TO_ADDR
// for i = 1 to hexes do
28604: LD_ADDR_VAR 0 7
28608: PUSH
28609: DOUBLE
28610: LD_INT 1
28612: DEC
28613: ST_TO_ADDR
28614: LD_VAR 0 12
28618: PUSH
28619: FOR_TO
28620: IFFALSE 28950
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28622: LD_VAR 0 12
28626: PUSH
28627: LD_VAR 0 7
28631: ARRAY
28632: PUSH
28633: LD_INT 1
28635: ARRAY
28636: PPUSH
28637: LD_VAR 0 12
28641: PUSH
28642: LD_VAR 0 7
28646: ARRAY
28647: PUSH
28648: LD_INT 2
28650: ARRAY
28651: PPUSH
28652: CALL_OW 488
28656: NOT
28657: PUSH
28658: LD_VAR 0 12
28662: PUSH
28663: LD_VAR 0 7
28667: ARRAY
28668: PUSH
28669: LD_INT 1
28671: ARRAY
28672: PPUSH
28673: LD_VAR 0 12
28677: PUSH
28678: LD_VAR 0 7
28682: ARRAY
28683: PUSH
28684: LD_INT 2
28686: ARRAY
28687: PPUSH
28688: CALL_OW 428
28692: PUSH
28693: LD_INT 0
28695: GREATER
28696: OR
28697: PUSH
28698: LD_VAR 0 12
28702: PUSH
28703: LD_VAR 0 7
28707: ARRAY
28708: PUSH
28709: LD_INT 1
28711: ARRAY
28712: PPUSH
28713: LD_VAR 0 12
28717: PUSH
28718: LD_VAR 0 7
28722: ARRAY
28723: PUSH
28724: LD_INT 2
28726: ARRAY
28727: PPUSH
28728: CALL_OW 351
28732: OR
28733: IFFALSE 28739
// exit ;
28735: POP
28736: POP
28737: GO 29031
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28739: LD_ADDR_VAR 0 8
28743: PUSH
28744: LD_VAR 0 12
28748: PUSH
28749: LD_VAR 0 7
28753: ARRAY
28754: PUSH
28755: LD_INT 1
28757: ARRAY
28758: PPUSH
28759: LD_VAR 0 12
28763: PUSH
28764: LD_VAR 0 7
28768: ARRAY
28769: PUSH
28770: LD_INT 2
28772: ARRAY
28773: PPUSH
28774: CALL_OW 546
28778: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28779: LD_VAR 0 8
28783: PUSH
28784: LD_INT 1
28786: ARRAY
28787: PUSH
28788: LD_VAR 0 8
28792: PUSH
28793: LD_INT 2
28795: ARRAY
28796: PUSH
28797: LD_VAR 0 13
28801: PUSH
28802: LD_INT 2
28804: PLUS
28805: GREATER
28806: OR
28807: PUSH
28808: LD_VAR 0 8
28812: PUSH
28813: LD_INT 2
28815: ARRAY
28816: PUSH
28817: LD_VAR 0 13
28821: PUSH
28822: LD_INT 2
28824: MINUS
28825: LESS
28826: OR
28827: PUSH
28828: LD_VAR 0 8
28832: PUSH
28833: LD_INT 3
28835: ARRAY
28836: PUSH
28837: LD_INT 0
28839: PUSH
28840: LD_INT 8
28842: PUSH
28843: LD_INT 9
28845: PUSH
28846: LD_INT 10
28848: PUSH
28849: LD_INT 11
28851: PUSH
28852: LD_INT 12
28854: PUSH
28855: LD_INT 13
28857: PUSH
28858: LD_INT 16
28860: PUSH
28861: LD_INT 17
28863: PUSH
28864: LD_INT 18
28866: PUSH
28867: LD_INT 19
28869: PUSH
28870: LD_INT 20
28872: PUSH
28873: LD_INT 21
28875: PUSH
28876: EMPTY
28877: LIST
28878: LIST
28879: LIST
28880: LIST
28881: LIST
28882: LIST
28883: LIST
28884: LIST
28885: LIST
28886: LIST
28887: LIST
28888: LIST
28889: LIST
28890: IN
28891: NOT
28892: OR
28893: PUSH
28894: LD_VAR 0 8
28898: PUSH
28899: LD_INT 5
28901: ARRAY
28902: NOT
28903: OR
28904: PUSH
28905: LD_VAR 0 8
28909: PUSH
28910: LD_INT 6
28912: ARRAY
28913: PUSH
28914: LD_INT 1
28916: PUSH
28917: LD_INT 2
28919: PUSH
28920: LD_INT 7
28922: PUSH
28923: LD_INT 9
28925: PUSH
28926: LD_INT 10
28928: PUSH
28929: LD_INT 11
28931: PUSH
28932: EMPTY
28933: LIST
28934: LIST
28935: LIST
28936: LIST
28937: LIST
28938: LIST
28939: IN
28940: NOT
28941: OR
28942: IFFALSE 28948
// exit ;
28944: POP
28945: POP
28946: GO 29031
// end ;
28948: GO 28619
28950: POP
28951: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28952: LD_VAR 0 9
28956: PPUSH
28957: LD_VAR 0 3
28961: PPUSH
28962: LD_VAR 0 4
28966: PPUSH
28967: LD_INT 20
28969: PPUSH
28970: CALL 20983 0 4
28974: PUSH
28975: LD_INT 4
28977: ARRAY
28978: IFFALSE 28982
// exit ;
28980: GO 29031
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28982: LD_VAR 0 2
28986: PUSH
28987: LD_INT 29
28989: PUSH
28990: LD_INT 30
28992: PUSH
28993: EMPTY
28994: LIST
28995: LIST
28996: IN
28997: PUSH
28998: LD_VAR 0 3
29002: PPUSH
29003: LD_VAR 0 4
29007: PPUSH
29008: LD_VAR 0 9
29012: PPUSH
29013: CALL_OW 440
29017: NOT
29018: AND
29019: IFFALSE 29023
// exit ;
29021: GO 29031
// result := true ;
29023: LD_ADDR_VAR 0 6
29027: PUSH
29028: LD_INT 1
29030: ST_TO_ADDR
// end ;
29031: LD_VAR 0 6
29035: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
29036: LD_INT 0
29038: PPUSH
29039: PPUSH
29040: PPUSH
29041: PPUSH
29042: PPUSH
29043: PPUSH
29044: PPUSH
29045: PPUSH
29046: PPUSH
29047: PPUSH
29048: PPUSH
29049: PPUSH
29050: PPUSH
29051: PPUSH
29052: PPUSH
29053: PPUSH
29054: PPUSH
29055: PPUSH
29056: PPUSH
29057: PPUSH
29058: PPUSH
29059: PPUSH
29060: PPUSH
29061: PPUSH
29062: PPUSH
29063: PPUSH
29064: PPUSH
29065: PPUSH
29066: PPUSH
29067: PPUSH
29068: PPUSH
29069: PPUSH
29070: PPUSH
29071: PPUSH
29072: PPUSH
29073: PPUSH
29074: PPUSH
29075: PPUSH
29076: PPUSH
29077: PPUSH
29078: PPUSH
29079: PPUSH
29080: PPUSH
29081: PPUSH
29082: PPUSH
29083: PPUSH
29084: PPUSH
29085: PPUSH
29086: PPUSH
29087: PPUSH
29088: PPUSH
29089: PPUSH
29090: PPUSH
29091: PPUSH
29092: PPUSH
29093: PPUSH
29094: PPUSH
29095: PPUSH
// result = [ ] ;
29096: LD_ADDR_VAR 0 7
29100: PUSH
29101: EMPTY
29102: ST_TO_ADDR
// temp_list = [ ] ;
29103: LD_ADDR_VAR 0 9
29107: PUSH
29108: EMPTY
29109: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29110: LD_VAR 0 4
29114: PUSH
29115: LD_INT 0
29117: PUSH
29118: LD_INT 1
29120: PUSH
29121: LD_INT 2
29123: PUSH
29124: LD_INT 3
29126: PUSH
29127: LD_INT 4
29129: PUSH
29130: LD_INT 5
29132: PUSH
29133: EMPTY
29134: LIST
29135: LIST
29136: LIST
29137: LIST
29138: LIST
29139: LIST
29140: IN
29141: NOT
29142: PUSH
29143: LD_VAR 0 1
29147: PUSH
29148: LD_INT 0
29150: PUSH
29151: LD_INT 1
29153: PUSH
29154: EMPTY
29155: LIST
29156: LIST
29157: IN
29158: PUSH
29159: LD_VAR 0 5
29163: PUSH
29164: LD_INT 1
29166: PUSH
29167: LD_INT 2
29169: PUSH
29170: LD_INT 3
29172: PUSH
29173: EMPTY
29174: LIST
29175: LIST
29176: LIST
29177: IN
29178: NOT
29179: AND
29180: OR
29181: IFFALSE 29185
// exit ;
29183: GO 47576
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29185: LD_VAR 0 1
29189: PUSH
29190: LD_INT 6
29192: PUSH
29193: LD_INT 7
29195: PUSH
29196: LD_INT 8
29198: PUSH
29199: LD_INT 13
29201: PUSH
29202: LD_INT 12
29204: PUSH
29205: LD_INT 15
29207: PUSH
29208: LD_INT 11
29210: PUSH
29211: LD_INT 14
29213: PUSH
29214: LD_INT 10
29216: PUSH
29217: EMPTY
29218: LIST
29219: LIST
29220: LIST
29221: LIST
29222: LIST
29223: LIST
29224: LIST
29225: LIST
29226: LIST
29227: IN
29228: IFFALSE 29238
// btype = b_lab ;
29230: LD_ADDR_VAR 0 1
29234: PUSH
29235: LD_INT 6
29237: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29238: LD_VAR 0 6
29242: PUSH
29243: LD_INT 0
29245: PUSH
29246: LD_INT 1
29248: PUSH
29249: LD_INT 2
29251: PUSH
29252: EMPTY
29253: LIST
29254: LIST
29255: LIST
29256: IN
29257: NOT
29258: PUSH
29259: LD_VAR 0 1
29263: PUSH
29264: LD_INT 0
29266: PUSH
29267: LD_INT 1
29269: PUSH
29270: LD_INT 2
29272: PUSH
29273: LD_INT 3
29275: PUSH
29276: LD_INT 6
29278: PUSH
29279: LD_INT 36
29281: PUSH
29282: LD_INT 4
29284: PUSH
29285: LD_INT 5
29287: PUSH
29288: LD_INT 31
29290: PUSH
29291: LD_INT 32
29293: PUSH
29294: LD_INT 33
29296: PUSH
29297: EMPTY
29298: LIST
29299: LIST
29300: LIST
29301: LIST
29302: LIST
29303: LIST
29304: LIST
29305: LIST
29306: LIST
29307: LIST
29308: LIST
29309: IN
29310: NOT
29311: PUSH
29312: LD_VAR 0 6
29316: PUSH
29317: LD_INT 1
29319: EQUAL
29320: AND
29321: OR
29322: PUSH
29323: LD_VAR 0 1
29327: PUSH
29328: LD_INT 2
29330: PUSH
29331: LD_INT 3
29333: PUSH
29334: EMPTY
29335: LIST
29336: LIST
29337: IN
29338: NOT
29339: PUSH
29340: LD_VAR 0 6
29344: PUSH
29345: LD_INT 2
29347: EQUAL
29348: AND
29349: OR
29350: IFFALSE 29360
// mode = 0 ;
29352: LD_ADDR_VAR 0 6
29356: PUSH
29357: LD_INT 0
29359: ST_TO_ADDR
// case mode of 0 :
29360: LD_VAR 0 6
29364: PUSH
29365: LD_INT 0
29367: DOUBLE
29368: EQUAL
29369: IFTRUE 29373
29371: GO 40826
29373: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29374: LD_ADDR_VAR 0 11
29378: PUSH
29379: LD_INT 0
29381: PUSH
29382: LD_INT 0
29384: PUSH
29385: EMPTY
29386: LIST
29387: LIST
29388: PUSH
29389: LD_INT 0
29391: PUSH
29392: LD_INT 1
29394: NEG
29395: PUSH
29396: EMPTY
29397: LIST
29398: LIST
29399: PUSH
29400: LD_INT 1
29402: PUSH
29403: LD_INT 0
29405: PUSH
29406: EMPTY
29407: LIST
29408: LIST
29409: PUSH
29410: LD_INT 1
29412: PUSH
29413: LD_INT 1
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: LD_INT 0
29422: PUSH
29423: LD_INT 1
29425: PUSH
29426: EMPTY
29427: LIST
29428: LIST
29429: PUSH
29430: LD_INT 1
29432: NEG
29433: PUSH
29434: LD_INT 0
29436: PUSH
29437: EMPTY
29438: LIST
29439: LIST
29440: PUSH
29441: LD_INT 1
29443: NEG
29444: PUSH
29445: LD_INT 1
29447: NEG
29448: PUSH
29449: EMPTY
29450: LIST
29451: LIST
29452: PUSH
29453: LD_INT 1
29455: NEG
29456: PUSH
29457: LD_INT 2
29459: NEG
29460: PUSH
29461: EMPTY
29462: LIST
29463: LIST
29464: PUSH
29465: LD_INT 0
29467: PUSH
29468: LD_INT 2
29470: NEG
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: PUSH
29476: LD_INT 1
29478: PUSH
29479: LD_INT 1
29481: NEG
29482: PUSH
29483: EMPTY
29484: LIST
29485: LIST
29486: PUSH
29487: LD_INT 1
29489: PUSH
29490: LD_INT 2
29492: PUSH
29493: EMPTY
29494: LIST
29495: LIST
29496: PUSH
29497: LD_INT 0
29499: PUSH
29500: LD_INT 2
29502: PUSH
29503: EMPTY
29504: LIST
29505: LIST
29506: PUSH
29507: LD_INT 1
29509: NEG
29510: PUSH
29511: LD_INT 1
29513: PUSH
29514: EMPTY
29515: LIST
29516: LIST
29517: PUSH
29518: LD_INT 1
29520: PUSH
29521: LD_INT 3
29523: PUSH
29524: EMPTY
29525: LIST
29526: LIST
29527: PUSH
29528: LD_INT 0
29530: PUSH
29531: LD_INT 3
29533: PUSH
29534: EMPTY
29535: LIST
29536: LIST
29537: PUSH
29538: LD_INT 1
29540: NEG
29541: PUSH
29542: LD_INT 2
29544: PUSH
29545: EMPTY
29546: LIST
29547: LIST
29548: PUSH
29549: EMPTY
29550: LIST
29551: LIST
29552: LIST
29553: LIST
29554: LIST
29555: LIST
29556: LIST
29557: LIST
29558: LIST
29559: LIST
29560: LIST
29561: LIST
29562: LIST
29563: LIST
29564: LIST
29565: LIST
29566: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29567: LD_ADDR_VAR 0 12
29571: PUSH
29572: LD_INT 0
29574: PUSH
29575: LD_INT 0
29577: PUSH
29578: EMPTY
29579: LIST
29580: LIST
29581: PUSH
29582: LD_INT 0
29584: PUSH
29585: LD_INT 1
29587: NEG
29588: PUSH
29589: EMPTY
29590: LIST
29591: LIST
29592: PUSH
29593: LD_INT 1
29595: PUSH
29596: LD_INT 0
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: LD_INT 1
29605: PUSH
29606: LD_INT 1
29608: PUSH
29609: EMPTY
29610: LIST
29611: LIST
29612: PUSH
29613: LD_INT 0
29615: PUSH
29616: LD_INT 1
29618: PUSH
29619: EMPTY
29620: LIST
29621: LIST
29622: PUSH
29623: LD_INT 1
29625: NEG
29626: PUSH
29627: LD_INT 0
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: LD_INT 1
29636: NEG
29637: PUSH
29638: LD_INT 1
29640: NEG
29641: PUSH
29642: EMPTY
29643: LIST
29644: LIST
29645: PUSH
29646: LD_INT 1
29648: PUSH
29649: LD_INT 1
29651: NEG
29652: PUSH
29653: EMPTY
29654: LIST
29655: LIST
29656: PUSH
29657: LD_INT 2
29659: PUSH
29660: LD_INT 0
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: LD_INT 2
29669: PUSH
29670: LD_INT 1
29672: PUSH
29673: EMPTY
29674: LIST
29675: LIST
29676: PUSH
29677: LD_INT 1
29679: NEG
29680: PUSH
29681: LD_INT 1
29683: PUSH
29684: EMPTY
29685: LIST
29686: LIST
29687: PUSH
29688: LD_INT 2
29690: NEG
29691: PUSH
29692: LD_INT 0
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: LD_INT 2
29701: NEG
29702: PUSH
29703: LD_INT 1
29705: NEG
29706: PUSH
29707: EMPTY
29708: LIST
29709: LIST
29710: PUSH
29711: LD_INT 2
29713: NEG
29714: PUSH
29715: LD_INT 1
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: PUSH
29722: LD_INT 3
29724: NEG
29725: PUSH
29726: LD_INT 0
29728: PUSH
29729: EMPTY
29730: LIST
29731: LIST
29732: PUSH
29733: LD_INT 3
29735: NEG
29736: PUSH
29737: LD_INT 1
29739: NEG
29740: PUSH
29741: EMPTY
29742: LIST
29743: LIST
29744: PUSH
29745: EMPTY
29746: LIST
29747: LIST
29748: LIST
29749: LIST
29750: LIST
29751: LIST
29752: LIST
29753: LIST
29754: LIST
29755: LIST
29756: LIST
29757: LIST
29758: LIST
29759: LIST
29760: LIST
29761: LIST
29762: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29763: LD_ADDR_VAR 0 13
29767: PUSH
29768: LD_INT 0
29770: PUSH
29771: LD_INT 0
29773: PUSH
29774: EMPTY
29775: LIST
29776: LIST
29777: PUSH
29778: LD_INT 0
29780: PUSH
29781: LD_INT 1
29783: NEG
29784: PUSH
29785: EMPTY
29786: LIST
29787: LIST
29788: PUSH
29789: LD_INT 1
29791: PUSH
29792: LD_INT 0
29794: PUSH
29795: EMPTY
29796: LIST
29797: LIST
29798: PUSH
29799: LD_INT 1
29801: PUSH
29802: LD_INT 1
29804: PUSH
29805: EMPTY
29806: LIST
29807: LIST
29808: PUSH
29809: LD_INT 0
29811: PUSH
29812: LD_INT 1
29814: PUSH
29815: EMPTY
29816: LIST
29817: LIST
29818: PUSH
29819: LD_INT 1
29821: NEG
29822: PUSH
29823: LD_INT 0
29825: PUSH
29826: EMPTY
29827: LIST
29828: LIST
29829: PUSH
29830: LD_INT 1
29832: NEG
29833: PUSH
29834: LD_INT 1
29836: NEG
29837: PUSH
29838: EMPTY
29839: LIST
29840: LIST
29841: PUSH
29842: LD_INT 1
29844: NEG
29845: PUSH
29846: LD_INT 2
29848: NEG
29849: PUSH
29850: EMPTY
29851: LIST
29852: LIST
29853: PUSH
29854: LD_INT 2
29856: PUSH
29857: LD_INT 1
29859: PUSH
29860: EMPTY
29861: LIST
29862: LIST
29863: PUSH
29864: LD_INT 2
29866: PUSH
29867: LD_INT 2
29869: PUSH
29870: EMPTY
29871: LIST
29872: LIST
29873: PUSH
29874: LD_INT 1
29876: PUSH
29877: LD_INT 2
29879: PUSH
29880: EMPTY
29881: LIST
29882: LIST
29883: PUSH
29884: LD_INT 2
29886: NEG
29887: PUSH
29888: LD_INT 1
29890: NEG
29891: PUSH
29892: EMPTY
29893: LIST
29894: LIST
29895: PUSH
29896: LD_INT 2
29898: NEG
29899: PUSH
29900: LD_INT 2
29902: NEG
29903: PUSH
29904: EMPTY
29905: LIST
29906: LIST
29907: PUSH
29908: LD_INT 2
29910: NEG
29911: PUSH
29912: LD_INT 3
29914: NEG
29915: PUSH
29916: EMPTY
29917: LIST
29918: LIST
29919: PUSH
29920: LD_INT 3
29922: NEG
29923: PUSH
29924: LD_INT 2
29926: NEG
29927: PUSH
29928: EMPTY
29929: LIST
29930: LIST
29931: PUSH
29932: LD_INT 3
29934: NEG
29935: PUSH
29936: LD_INT 3
29938: NEG
29939: PUSH
29940: EMPTY
29941: LIST
29942: LIST
29943: PUSH
29944: EMPTY
29945: LIST
29946: LIST
29947: LIST
29948: LIST
29949: LIST
29950: LIST
29951: LIST
29952: LIST
29953: LIST
29954: LIST
29955: LIST
29956: LIST
29957: LIST
29958: LIST
29959: LIST
29960: LIST
29961: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29962: LD_ADDR_VAR 0 14
29966: PUSH
29967: LD_INT 0
29969: PUSH
29970: LD_INT 0
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: PUSH
29977: LD_INT 0
29979: PUSH
29980: LD_INT 1
29982: NEG
29983: PUSH
29984: EMPTY
29985: LIST
29986: LIST
29987: PUSH
29988: LD_INT 1
29990: PUSH
29991: LD_INT 0
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: PUSH
29998: LD_INT 1
30000: PUSH
30001: LD_INT 1
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: LD_INT 0
30010: PUSH
30011: LD_INT 1
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: PUSH
30018: LD_INT 1
30020: NEG
30021: PUSH
30022: LD_INT 0
30024: PUSH
30025: EMPTY
30026: LIST
30027: LIST
30028: PUSH
30029: LD_INT 1
30031: NEG
30032: PUSH
30033: LD_INT 1
30035: NEG
30036: PUSH
30037: EMPTY
30038: LIST
30039: LIST
30040: PUSH
30041: LD_INT 1
30043: NEG
30044: PUSH
30045: LD_INT 2
30047: NEG
30048: PUSH
30049: EMPTY
30050: LIST
30051: LIST
30052: PUSH
30053: LD_INT 0
30055: PUSH
30056: LD_INT 2
30058: NEG
30059: PUSH
30060: EMPTY
30061: LIST
30062: LIST
30063: PUSH
30064: LD_INT 1
30066: PUSH
30067: LD_INT 1
30069: NEG
30070: PUSH
30071: EMPTY
30072: LIST
30073: LIST
30074: PUSH
30075: LD_INT 1
30077: PUSH
30078: LD_INT 2
30080: PUSH
30081: EMPTY
30082: LIST
30083: LIST
30084: PUSH
30085: LD_INT 0
30087: PUSH
30088: LD_INT 2
30090: PUSH
30091: EMPTY
30092: LIST
30093: LIST
30094: PUSH
30095: LD_INT 1
30097: NEG
30098: PUSH
30099: LD_INT 1
30101: PUSH
30102: EMPTY
30103: LIST
30104: LIST
30105: PUSH
30106: LD_INT 1
30108: NEG
30109: PUSH
30110: LD_INT 3
30112: NEG
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PUSH
30118: LD_INT 0
30120: PUSH
30121: LD_INT 3
30123: NEG
30124: PUSH
30125: EMPTY
30126: LIST
30127: LIST
30128: PUSH
30129: LD_INT 1
30131: PUSH
30132: LD_INT 2
30134: NEG
30135: PUSH
30136: EMPTY
30137: LIST
30138: LIST
30139: PUSH
30140: EMPTY
30141: LIST
30142: LIST
30143: LIST
30144: LIST
30145: LIST
30146: LIST
30147: LIST
30148: LIST
30149: LIST
30150: LIST
30151: LIST
30152: LIST
30153: LIST
30154: LIST
30155: LIST
30156: LIST
30157: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30158: LD_ADDR_VAR 0 15
30162: PUSH
30163: LD_INT 0
30165: PUSH
30166: LD_INT 0
30168: PUSH
30169: EMPTY
30170: LIST
30171: LIST
30172: PUSH
30173: LD_INT 0
30175: PUSH
30176: LD_INT 1
30178: NEG
30179: PUSH
30180: EMPTY
30181: LIST
30182: LIST
30183: PUSH
30184: LD_INT 1
30186: PUSH
30187: LD_INT 0
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: PUSH
30194: LD_INT 1
30196: PUSH
30197: LD_INT 1
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: LD_INT 0
30206: PUSH
30207: LD_INT 1
30209: PUSH
30210: EMPTY
30211: LIST
30212: LIST
30213: PUSH
30214: LD_INT 1
30216: NEG
30217: PUSH
30218: LD_INT 0
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PUSH
30225: LD_INT 1
30227: NEG
30228: PUSH
30229: LD_INT 1
30231: NEG
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: PUSH
30237: LD_INT 1
30239: PUSH
30240: LD_INT 1
30242: NEG
30243: PUSH
30244: EMPTY
30245: LIST
30246: LIST
30247: PUSH
30248: LD_INT 2
30250: PUSH
30251: LD_INT 0
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: PUSH
30258: LD_INT 2
30260: PUSH
30261: LD_INT 1
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PUSH
30268: LD_INT 1
30270: NEG
30271: PUSH
30272: LD_INT 1
30274: PUSH
30275: EMPTY
30276: LIST
30277: LIST
30278: PUSH
30279: LD_INT 2
30281: NEG
30282: PUSH
30283: LD_INT 0
30285: PUSH
30286: EMPTY
30287: LIST
30288: LIST
30289: PUSH
30290: LD_INT 2
30292: NEG
30293: PUSH
30294: LD_INT 1
30296: NEG
30297: PUSH
30298: EMPTY
30299: LIST
30300: LIST
30301: PUSH
30302: LD_INT 2
30304: PUSH
30305: LD_INT 1
30307: NEG
30308: PUSH
30309: EMPTY
30310: LIST
30311: LIST
30312: PUSH
30313: LD_INT 3
30315: PUSH
30316: LD_INT 0
30318: PUSH
30319: EMPTY
30320: LIST
30321: LIST
30322: PUSH
30323: LD_INT 3
30325: PUSH
30326: LD_INT 1
30328: PUSH
30329: EMPTY
30330: LIST
30331: LIST
30332: PUSH
30333: EMPTY
30334: LIST
30335: LIST
30336: LIST
30337: LIST
30338: LIST
30339: LIST
30340: LIST
30341: LIST
30342: LIST
30343: LIST
30344: LIST
30345: LIST
30346: LIST
30347: LIST
30348: LIST
30349: LIST
30350: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30351: LD_ADDR_VAR 0 16
30355: PUSH
30356: LD_INT 0
30358: PUSH
30359: LD_INT 0
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: PUSH
30366: LD_INT 0
30368: PUSH
30369: LD_INT 1
30371: NEG
30372: PUSH
30373: EMPTY
30374: LIST
30375: LIST
30376: PUSH
30377: LD_INT 1
30379: PUSH
30380: LD_INT 0
30382: PUSH
30383: EMPTY
30384: LIST
30385: LIST
30386: PUSH
30387: LD_INT 1
30389: PUSH
30390: LD_INT 1
30392: PUSH
30393: EMPTY
30394: LIST
30395: LIST
30396: PUSH
30397: LD_INT 0
30399: PUSH
30400: LD_INT 1
30402: PUSH
30403: EMPTY
30404: LIST
30405: LIST
30406: PUSH
30407: LD_INT 1
30409: NEG
30410: PUSH
30411: LD_INT 0
30413: PUSH
30414: EMPTY
30415: LIST
30416: LIST
30417: PUSH
30418: LD_INT 1
30420: NEG
30421: PUSH
30422: LD_INT 1
30424: NEG
30425: PUSH
30426: EMPTY
30427: LIST
30428: LIST
30429: PUSH
30430: LD_INT 1
30432: NEG
30433: PUSH
30434: LD_INT 2
30436: NEG
30437: PUSH
30438: EMPTY
30439: LIST
30440: LIST
30441: PUSH
30442: LD_INT 2
30444: PUSH
30445: LD_INT 1
30447: PUSH
30448: EMPTY
30449: LIST
30450: LIST
30451: PUSH
30452: LD_INT 2
30454: PUSH
30455: LD_INT 2
30457: PUSH
30458: EMPTY
30459: LIST
30460: LIST
30461: PUSH
30462: LD_INT 1
30464: PUSH
30465: LD_INT 2
30467: PUSH
30468: EMPTY
30469: LIST
30470: LIST
30471: PUSH
30472: LD_INT 2
30474: NEG
30475: PUSH
30476: LD_INT 1
30478: NEG
30479: PUSH
30480: EMPTY
30481: LIST
30482: LIST
30483: PUSH
30484: LD_INT 2
30486: NEG
30487: PUSH
30488: LD_INT 2
30490: NEG
30491: PUSH
30492: EMPTY
30493: LIST
30494: LIST
30495: PUSH
30496: LD_INT 3
30498: PUSH
30499: LD_INT 2
30501: PUSH
30502: EMPTY
30503: LIST
30504: LIST
30505: PUSH
30506: LD_INT 3
30508: PUSH
30509: LD_INT 3
30511: PUSH
30512: EMPTY
30513: LIST
30514: LIST
30515: PUSH
30516: LD_INT 2
30518: PUSH
30519: LD_INT 3
30521: PUSH
30522: EMPTY
30523: LIST
30524: LIST
30525: PUSH
30526: EMPTY
30527: LIST
30528: LIST
30529: LIST
30530: LIST
30531: LIST
30532: LIST
30533: LIST
30534: LIST
30535: LIST
30536: LIST
30537: LIST
30538: LIST
30539: LIST
30540: LIST
30541: LIST
30542: LIST
30543: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30544: LD_ADDR_VAR 0 17
30548: PUSH
30549: LD_INT 0
30551: PUSH
30552: LD_INT 0
30554: PUSH
30555: EMPTY
30556: LIST
30557: LIST
30558: PUSH
30559: LD_INT 0
30561: PUSH
30562: LD_INT 1
30564: NEG
30565: PUSH
30566: EMPTY
30567: LIST
30568: LIST
30569: PUSH
30570: LD_INT 1
30572: PUSH
30573: LD_INT 0
30575: PUSH
30576: EMPTY
30577: LIST
30578: LIST
30579: PUSH
30580: LD_INT 1
30582: PUSH
30583: LD_INT 1
30585: PUSH
30586: EMPTY
30587: LIST
30588: LIST
30589: PUSH
30590: LD_INT 0
30592: PUSH
30593: LD_INT 1
30595: PUSH
30596: EMPTY
30597: LIST
30598: LIST
30599: PUSH
30600: LD_INT 1
30602: NEG
30603: PUSH
30604: LD_INT 0
30606: PUSH
30607: EMPTY
30608: LIST
30609: LIST
30610: PUSH
30611: LD_INT 1
30613: NEG
30614: PUSH
30615: LD_INT 1
30617: NEG
30618: PUSH
30619: EMPTY
30620: LIST
30621: LIST
30622: PUSH
30623: LD_INT 1
30625: NEG
30626: PUSH
30627: LD_INT 2
30629: NEG
30630: PUSH
30631: EMPTY
30632: LIST
30633: LIST
30634: PUSH
30635: LD_INT 0
30637: PUSH
30638: LD_INT 2
30640: NEG
30641: PUSH
30642: EMPTY
30643: LIST
30644: LIST
30645: PUSH
30646: LD_INT 1
30648: PUSH
30649: LD_INT 1
30651: NEG
30652: PUSH
30653: EMPTY
30654: LIST
30655: LIST
30656: PUSH
30657: LD_INT 2
30659: PUSH
30660: LD_INT 0
30662: PUSH
30663: EMPTY
30664: LIST
30665: LIST
30666: PUSH
30667: LD_INT 2
30669: PUSH
30670: LD_INT 1
30672: PUSH
30673: EMPTY
30674: LIST
30675: LIST
30676: PUSH
30677: LD_INT 2
30679: PUSH
30680: LD_INT 2
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PUSH
30687: LD_INT 1
30689: PUSH
30690: LD_INT 2
30692: PUSH
30693: EMPTY
30694: LIST
30695: LIST
30696: PUSH
30697: LD_INT 0
30699: PUSH
30700: LD_INT 2
30702: PUSH
30703: EMPTY
30704: LIST
30705: LIST
30706: PUSH
30707: LD_INT 1
30709: NEG
30710: PUSH
30711: LD_INT 1
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: LD_INT 2
30720: NEG
30721: PUSH
30722: LD_INT 0
30724: PUSH
30725: EMPTY
30726: LIST
30727: LIST
30728: PUSH
30729: LD_INT 2
30731: NEG
30732: PUSH
30733: LD_INT 1
30735: NEG
30736: PUSH
30737: EMPTY
30738: LIST
30739: LIST
30740: PUSH
30741: LD_INT 2
30743: NEG
30744: PUSH
30745: LD_INT 2
30747: NEG
30748: PUSH
30749: EMPTY
30750: LIST
30751: LIST
30752: PUSH
30753: EMPTY
30754: LIST
30755: LIST
30756: LIST
30757: LIST
30758: LIST
30759: LIST
30760: LIST
30761: LIST
30762: LIST
30763: LIST
30764: LIST
30765: LIST
30766: LIST
30767: LIST
30768: LIST
30769: LIST
30770: LIST
30771: LIST
30772: LIST
30773: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30774: LD_ADDR_VAR 0 18
30778: PUSH
30779: LD_INT 0
30781: PUSH
30782: LD_INT 0
30784: PUSH
30785: EMPTY
30786: LIST
30787: LIST
30788: PUSH
30789: LD_INT 0
30791: PUSH
30792: LD_INT 1
30794: NEG
30795: PUSH
30796: EMPTY
30797: LIST
30798: LIST
30799: PUSH
30800: LD_INT 1
30802: PUSH
30803: LD_INT 0
30805: PUSH
30806: EMPTY
30807: LIST
30808: LIST
30809: PUSH
30810: LD_INT 1
30812: PUSH
30813: LD_INT 1
30815: PUSH
30816: EMPTY
30817: LIST
30818: LIST
30819: PUSH
30820: LD_INT 0
30822: PUSH
30823: LD_INT 1
30825: PUSH
30826: EMPTY
30827: LIST
30828: LIST
30829: PUSH
30830: LD_INT 1
30832: NEG
30833: PUSH
30834: LD_INT 0
30836: PUSH
30837: EMPTY
30838: LIST
30839: LIST
30840: PUSH
30841: LD_INT 1
30843: NEG
30844: PUSH
30845: LD_INT 1
30847: NEG
30848: PUSH
30849: EMPTY
30850: LIST
30851: LIST
30852: PUSH
30853: LD_INT 1
30855: NEG
30856: PUSH
30857: LD_INT 2
30859: NEG
30860: PUSH
30861: EMPTY
30862: LIST
30863: LIST
30864: PUSH
30865: LD_INT 0
30867: PUSH
30868: LD_INT 2
30870: NEG
30871: PUSH
30872: EMPTY
30873: LIST
30874: LIST
30875: PUSH
30876: LD_INT 1
30878: PUSH
30879: LD_INT 1
30881: NEG
30882: PUSH
30883: EMPTY
30884: LIST
30885: LIST
30886: PUSH
30887: LD_INT 2
30889: PUSH
30890: LD_INT 0
30892: PUSH
30893: EMPTY
30894: LIST
30895: LIST
30896: PUSH
30897: LD_INT 2
30899: PUSH
30900: LD_INT 1
30902: PUSH
30903: EMPTY
30904: LIST
30905: LIST
30906: PUSH
30907: LD_INT 2
30909: PUSH
30910: LD_INT 2
30912: PUSH
30913: EMPTY
30914: LIST
30915: LIST
30916: PUSH
30917: LD_INT 1
30919: PUSH
30920: LD_INT 2
30922: PUSH
30923: EMPTY
30924: LIST
30925: LIST
30926: PUSH
30927: LD_INT 0
30929: PUSH
30930: LD_INT 2
30932: PUSH
30933: EMPTY
30934: LIST
30935: LIST
30936: PUSH
30937: LD_INT 1
30939: NEG
30940: PUSH
30941: LD_INT 1
30943: PUSH
30944: EMPTY
30945: LIST
30946: LIST
30947: PUSH
30948: LD_INT 2
30950: NEG
30951: PUSH
30952: LD_INT 0
30954: PUSH
30955: EMPTY
30956: LIST
30957: LIST
30958: PUSH
30959: LD_INT 2
30961: NEG
30962: PUSH
30963: LD_INT 1
30965: NEG
30966: PUSH
30967: EMPTY
30968: LIST
30969: LIST
30970: PUSH
30971: LD_INT 2
30973: NEG
30974: PUSH
30975: LD_INT 2
30977: NEG
30978: PUSH
30979: EMPTY
30980: LIST
30981: LIST
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: LIST
30987: LIST
30988: LIST
30989: LIST
30990: LIST
30991: LIST
30992: LIST
30993: LIST
30994: LIST
30995: LIST
30996: LIST
30997: LIST
30998: LIST
30999: LIST
31000: LIST
31001: LIST
31002: LIST
31003: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31004: LD_ADDR_VAR 0 19
31008: PUSH
31009: LD_INT 0
31011: PUSH
31012: LD_INT 0
31014: PUSH
31015: EMPTY
31016: LIST
31017: LIST
31018: PUSH
31019: LD_INT 0
31021: PUSH
31022: LD_INT 1
31024: NEG
31025: PUSH
31026: EMPTY
31027: LIST
31028: LIST
31029: PUSH
31030: LD_INT 1
31032: PUSH
31033: LD_INT 0
31035: PUSH
31036: EMPTY
31037: LIST
31038: LIST
31039: PUSH
31040: LD_INT 1
31042: PUSH
31043: LD_INT 1
31045: PUSH
31046: EMPTY
31047: LIST
31048: LIST
31049: PUSH
31050: LD_INT 0
31052: PUSH
31053: LD_INT 1
31055: PUSH
31056: EMPTY
31057: LIST
31058: LIST
31059: PUSH
31060: LD_INT 1
31062: NEG
31063: PUSH
31064: LD_INT 0
31066: PUSH
31067: EMPTY
31068: LIST
31069: LIST
31070: PUSH
31071: LD_INT 1
31073: NEG
31074: PUSH
31075: LD_INT 1
31077: NEG
31078: PUSH
31079: EMPTY
31080: LIST
31081: LIST
31082: PUSH
31083: LD_INT 1
31085: NEG
31086: PUSH
31087: LD_INT 2
31089: NEG
31090: PUSH
31091: EMPTY
31092: LIST
31093: LIST
31094: PUSH
31095: LD_INT 0
31097: PUSH
31098: LD_INT 2
31100: NEG
31101: PUSH
31102: EMPTY
31103: LIST
31104: LIST
31105: PUSH
31106: LD_INT 1
31108: PUSH
31109: LD_INT 1
31111: NEG
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 2
31119: PUSH
31120: LD_INT 0
31122: PUSH
31123: EMPTY
31124: LIST
31125: LIST
31126: PUSH
31127: LD_INT 2
31129: PUSH
31130: LD_INT 1
31132: PUSH
31133: EMPTY
31134: LIST
31135: LIST
31136: PUSH
31137: LD_INT 2
31139: PUSH
31140: LD_INT 2
31142: PUSH
31143: EMPTY
31144: LIST
31145: LIST
31146: PUSH
31147: LD_INT 1
31149: PUSH
31150: LD_INT 2
31152: PUSH
31153: EMPTY
31154: LIST
31155: LIST
31156: PUSH
31157: LD_INT 0
31159: PUSH
31160: LD_INT 2
31162: PUSH
31163: EMPTY
31164: LIST
31165: LIST
31166: PUSH
31167: LD_INT 1
31169: NEG
31170: PUSH
31171: LD_INT 1
31173: PUSH
31174: EMPTY
31175: LIST
31176: LIST
31177: PUSH
31178: LD_INT 2
31180: NEG
31181: PUSH
31182: LD_INT 0
31184: PUSH
31185: EMPTY
31186: LIST
31187: LIST
31188: PUSH
31189: LD_INT 2
31191: NEG
31192: PUSH
31193: LD_INT 1
31195: NEG
31196: PUSH
31197: EMPTY
31198: LIST
31199: LIST
31200: PUSH
31201: LD_INT 2
31203: NEG
31204: PUSH
31205: LD_INT 2
31207: NEG
31208: PUSH
31209: EMPTY
31210: LIST
31211: LIST
31212: PUSH
31213: EMPTY
31214: LIST
31215: LIST
31216: LIST
31217: LIST
31218: LIST
31219: LIST
31220: LIST
31221: LIST
31222: LIST
31223: LIST
31224: LIST
31225: LIST
31226: LIST
31227: LIST
31228: LIST
31229: LIST
31230: LIST
31231: LIST
31232: LIST
31233: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31234: LD_ADDR_VAR 0 20
31238: PUSH
31239: LD_INT 0
31241: PUSH
31242: LD_INT 0
31244: PUSH
31245: EMPTY
31246: LIST
31247: LIST
31248: PUSH
31249: LD_INT 0
31251: PUSH
31252: LD_INT 1
31254: NEG
31255: PUSH
31256: EMPTY
31257: LIST
31258: LIST
31259: PUSH
31260: LD_INT 1
31262: PUSH
31263: LD_INT 0
31265: PUSH
31266: EMPTY
31267: LIST
31268: LIST
31269: PUSH
31270: LD_INT 1
31272: PUSH
31273: LD_INT 1
31275: PUSH
31276: EMPTY
31277: LIST
31278: LIST
31279: PUSH
31280: LD_INT 0
31282: PUSH
31283: LD_INT 1
31285: PUSH
31286: EMPTY
31287: LIST
31288: LIST
31289: PUSH
31290: LD_INT 1
31292: NEG
31293: PUSH
31294: LD_INT 0
31296: PUSH
31297: EMPTY
31298: LIST
31299: LIST
31300: PUSH
31301: LD_INT 1
31303: NEG
31304: PUSH
31305: LD_INT 1
31307: NEG
31308: PUSH
31309: EMPTY
31310: LIST
31311: LIST
31312: PUSH
31313: LD_INT 1
31315: NEG
31316: PUSH
31317: LD_INT 2
31319: NEG
31320: PUSH
31321: EMPTY
31322: LIST
31323: LIST
31324: PUSH
31325: LD_INT 0
31327: PUSH
31328: LD_INT 2
31330: NEG
31331: PUSH
31332: EMPTY
31333: LIST
31334: LIST
31335: PUSH
31336: LD_INT 1
31338: PUSH
31339: LD_INT 1
31341: NEG
31342: PUSH
31343: EMPTY
31344: LIST
31345: LIST
31346: PUSH
31347: LD_INT 2
31349: PUSH
31350: LD_INT 0
31352: PUSH
31353: EMPTY
31354: LIST
31355: LIST
31356: PUSH
31357: LD_INT 2
31359: PUSH
31360: LD_INT 1
31362: PUSH
31363: EMPTY
31364: LIST
31365: LIST
31366: PUSH
31367: LD_INT 2
31369: PUSH
31370: LD_INT 2
31372: PUSH
31373: EMPTY
31374: LIST
31375: LIST
31376: PUSH
31377: LD_INT 1
31379: PUSH
31380: LD_INT 2
31382: PUSH
31383: EMPTY
31384: LIST
31385: LIST
31386: PUSH
31387: LD_INT 0
31389: PUSH
31390: LD_INT 2
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: LD_INT 1
31399: NEG
31400: PUSH
31401: LD_INT 1
31403: PUSH
31404: EMPTY
31405: LIST
31406: LIST
31407: PUSH
31408: LD_INT 2
31410: NEG
31411: PUSH
31412: LD_INT 0
31414: PUSH
31415: EMPTY
31416: LIST
31417: LIST
31418: PUSH
31419: LD_INT 2
31421: NEG
31422: PUSH
31423: LD_INT 1
31425: NEG
31426: PUSH
31427: EMPTY
31428: LIST
31429: LIST
31430: PUSH
31431: LD_INT 2
31433: NEG
31434: PUSH
31435: LD_INT 2
31437: NEG
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: EMPTY
31444: LIST
31445: LIST
31446: LIST
31447: LIST
31448: LIST
31449: LIST
31450: LIST
31451: LIST
31452: LIST
31453: LIST
31454: LIST
31455: LIST
31456: LIST
31457: LIST
31458: LIST
31459: LIST
31460: LIST
31461: LIST
31462: LIST
31463: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31464: LD_ADDR_VAR 0 21
31468: PUSH
31469: LD_INT 0
31471: PUSH
31472: LD_INT 0
31474: PUSH
31475: EMPTY
31476: LIST
31477: LIST
31478: PUSH
31479: LD_INT 0
31481: PUSH
31482: LD_INT 1
31484: NEG
31485: PUSH
31486: EMPTY
31487: LIST
31488: LIST
31489: PUSH
31490: LD_INT 1
31492: PUSH
31493: LD_INT 0
31495: PUSH
31496: EMPTY
31497: LIST
31498: LIST
31499: PUSH
31500: LD_INT 1
31502: PUSH
31503: LD_INT 1
31505: PUSH
31506: EMPTY
31507: LIST
31508: LIST
31509: PUSH
31510: LD_INT 0
31512: PUSH
31513: LD_INT 1
31515: PUSH
31516: EMPTY
31517: LIST
31518: LIST
31519: PUSH
31520: LD_INT 1
31522: NEG
31523: PUSH
31524: LD_INT 0
31526: PUSH
31527: EMPTY
31528: LIST
31529: LIST
31530: PUSH
31531: LD_INT 1
31533: NEG
31534: PUSH
31535: LD_INT 1
31537: NEG
31538: PUSH
31539: EMPTY
31540: LIST
31541: LIST
31542: PUSH
31543: LD_INT 1
31545: NEG
31546: PUSH
31547: LD_INT 2
31549: NEG
31550: PUSH
31551: EMPTY
31552: LIST
31553: LIST
31554: PUSH
31555: LD_INT 0
31557: PUSH
31558: LD_INT 2
31560: NEG
31561: PUSH
31562: EMPTY
31563: LIST
31564: LIST
31565: PUSH
31566: LD_INT 1
31568: PUSH
31569: LD_INT 1
31571: NEG
31572: PUSH
31573: EMPTY
31574: LIST
31575: LIST
31576: PUSH
31577: LD_INT 2
31579: PUSH
31580: LD_INT 0
31582: PUSH
31583: EMPTY
31584: LIST
31585: LIST
31586: PUSH
31587: LD_INT 2
31589: PUSH
31590: LD_INT 1
31592: PUSH
31593: EMPTY
31594: LIST
31595: LIST
31596: PUSH
31597: LD_INT 2
31599: PUSH
31600: LD_INT 2
31602: PUSH
31603: EMPTY
31604: LIST
31605: LIST
31606: PUSH
31607: LD_INT 1
31609: PUSH
31610: LD_INT 2
31612: PUSH
31613: EMPTY
31614: LIST
31615: LIST
31616: PUSH
31617: LD_INT 0
31619: PUSH
31620: LD_INT 2
31622: PUSH
31623: EMPTY
31624: LIST
31625: LIST
31626: PUSH
31627: LD_INT 1
31629: NEG
31630: PUSH
31631: LD_INT 1
31633: PUSH
31634: EMPTY
31635: LIST
31636: LIST
31637: PUSH
31638: LD_INT 2
31640: NEG
31641: PUSH
31642: LD_INT 0
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: LD_INT 2
31651: NEG
31652: PUSH
31653: LD_INT 1
31655: NEG
31656: PUSH
31657: EMPTY
31658: LIST
31659: LIST
31660: PUSH
31661: LD_INT 2
31663: NEG
31664: PUSH
31665: LD_INT 2
31667: NEG
31668: PUSH
31669: EMPTY
31670: LIST
31671: LIST
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: LIST
31677: LIST
31678: LIST
31679: LIST
31680: LIST
31681: LIST
31682: LIST
31683: LIST
31684: LIST
31685: LIST
31686: LIST
31687: LIST
31688: LIST
31689: LIST
31690: LIST
31691: LIST
31692: LIST
31693: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31694: LD_ADDR_VAR 0 22
31698: PUSH
31699: LD_INT 0
31701: PUSH
31702: LD_INT 0
31704: PUSH
31705: EMPTY
31706: LIST
31707: LIST
31708: PUSH
31709: LD_INT 0
31711: PUSH
31712: LD_INT 1
31714: NEG
31715: PUSH
31716: EMPTY
31717: LIST
31718: LIST
31719: PUSH
31720: LD_INT 1
31722: PUSH
31723: LD_INT 0
31725: PUSH
31726: EMPTY
31727: LIST
31728: LIST
31729: PUSH
31730: LD_INT 1
31732: PUSH
31733: LD_INT 1
31735: PUSH
31736: EMPTY
31737: LIST
31738: LIST
31739: PUSH
31740: LD_INT 0
31742: PUSH
31743: LD_INT 1
31745: PUSH
31746: EMPTY
31747: LIST
31748: LIST
31749: PUSH
31750: LD_INT 1
31752: NEG
31753: PUSH
31754: LD_INT 0
31756: PUSH
31757: EMPTY
31758: LIST
31759: LIST
31760: PUSH
31761: LD_INT 1
31763: NEG
31764: PUSH
31765: LD_INT 1
31767: NEG
31768: PUSH
31769: EMPTY
31770: LIST
31771: LIST
31772: PUSH
31773: LD_INT 1
31775: NEG
31776: PUSH
31777: LD_INT 2
31779: NEG
31780: PUSH
31781: EMPTY
31782: LIST
31783: LIST
31784: PUSH
31785: LD_INT 0
31787: PUSH
31788: LD_INT 2
31790: NEG
31791: PUSH
31792: EMPTY
31793: LIST
31794: LIST
31795: PUSH
31796: LD_INT 1
31798: PUSH
31799: LD_INT 1
31801: NEG
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: LD_INT 2
31809: PUSH
31810: LD_INT 0
31812: PUSH
31813: EMPTY
31814: LIST
31815: LIST
31816: PUSH
31817: LD_INT 2
31819: PUSH
31820: LD_INT 1
31822: PUSH
31823: EMPTY
31824: LIST
31825: LIST
31826: PUSH
31827: LD_INT 2
31829: PUSH
31830: LD_INT 2
31832: PUSH
31833: EMPTY
31834: LIST
31835: LIST
31836: PUSH
31837: LD_INT 1
31839: PUSH
31840: LD_INT 2
31842: PUSH
31843: EMPTY
31844: LIST
31845: LIST
31846: PUSH
31847: LD_INT 0
31849: PUSH
31850: LD_INT 2
31852: PUSH
31853: EMPTY
31854: LIST
31855: LIST
31856: PUSH
31857: LD_INT 1
31859: NEG
31860: PUSH
31861: LD_INT 1
31863: PUSH
31864: EMPTY
31865: LIST
31866: LIST
31867: PUSH
31868: LD_INT 2
31870: NEG
31871: PUSH
31872: LD_INT 0
31874: PUSH
31875: EMPTY
31876: LIST
31877: LIST
31878: PUSH
31879: LD_INT 2
31881: NEG
31882: PUSH
31883: LD_INT 1
31885: NEG
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 2
31893: NEG
31894: PUSH
31895: LD_INT 2
31897: NEG
31898: PUSH
31899: EMPTY
31900: LIST
31901: LIST
31902: PUSH
31903: EMPTY
31904: LIST
31905: LIST
31906: LIST
31907: LIST
31908: LIST
31909: LIST
31910: LIST
31911: LIST
31912: LIST
31913: LIST
31914: LIST
31915: LIST
31916: LIST
31917: LIST
31918: LIST
31919: LIST
31920: LIST
31921: LIST
31922: LIST
31923: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31924: LD_ADDR_VAR 0 23
31928: PUSH
31929: LD_INT 0
31931: PUSH
31932: LD_INT 0
31934: PUSH
31935: EMPTY
31936: LIST
31937: LIST
31938: PUSH
31939: LD_INT 0
31941: PUSH
31942: LD_INT 1
31944: NEG
31945: PUSH
31946: EMPTY
31947: LIST
31948: LIST
31949: PUSH
31950: LD_INT 1
31952: PUSH
31953: LD_INT 0
31955: PUSH
31956: EMPTY
31957: LIST
31958: LIST
31959: PUSH
31960: LD_INT 1
31962: PUSH
31963: LD_INT 1
31965: PUSH
31966: EMPTY
31967: LIST
31968: LIST
31969: PUSH
31970: LD_INT 0
31972: PUSH
31973: LD_INT 1
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: PUSH
31980: LD_INT 1
31982: NEG
31983: PUSH
31984: LD_INT 0
31986: PUSH
31987: EMPTY
31988: LIST
31989: LIST
31990: PUSH
31991: LD_INT 1
31993: NEG
31994: PUSH
31995: LD_INT 1
31997: NEG
31998: PUSH
31999: EMPTY
32000: LIST
32001: LIST
32002: PUSH
32003: LD_INT 1
32005: NEG
32006: PUSH
32007: LD_INT 2
32009: NEG
32010: PUSH
32011: EMPTY
32012: LIST
32013: LIST
32014: PUSH
32015: LD_INT 0
32017: PUSH
32018: LD_INT 2
32020: NEG
32021: PUSH
32022: EMPTY
32023: LIST
32024: LIST
32025: PUSH
32026: LD_INT 1
32028: PUSH
32029: LD_INT 1
32031: NEG
32032: PUSH
32033: EMPTY
32034: LIST
32035: LIST
32036: PUSH
32037: LD_INT 2
32039: PUSH
32040: LD_INT 0
32042: PUSH
32043: EMPTY
32044: LIST
32045: LIST
32046: PUSH
32047: LD_INT 2
32049: PUSH
32050: LD_INT 1
32052: PUSH
32053: EMPTY
32054: LIST
32055: LIST
32056: PUSH
32057: LD_INT 2
32059: PUSH
32060: LD_INT 2
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: PUSH
32067: LD_INT 1
32069: PUSH
32070: LD_INT 2
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: PUSH
32077: LD_INT 0
32079: PUSH
32080: LD_INT 2
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: PUSH
32087: LD_INT 1
32089: NEG
32090: PUSH
32091: LD_INT 1
32093: PUSH
32094: EMPTY
32095: LIST
32096: LIST
32097: PUSH
32098: LD_INT 2
32100: NEG
32101: PUSH
32102: LD_INT 0
32104: PUSH
32105: EMPTY
32106: LIST
32107: LIST
32108: PUSH
32109: LD_INT 2
32111: NEG
32112: PUSH
32113: LD_INT 1
32115: NEG
32116: PUSH
32117: EMPTY
32118: LIST
32119: LIST
32120: PUSH
32121: LD_INT 2
32123: NEG
32124: PUSH
32125: LD_INT 2
32127: NEG
32128: PUSH
32129: EMPTY
32130: LIST
32131: LIST
32132: PUSH
32133: LD_INT 2
32135: NEG
32136: PUSH
32137: LD_INT 3
32139: NEG
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: PUSH
32145: LD_INT 1
32147: NEG
32148: PUSH
32149: LD_INT 3
32151: NEG
32152: PUSH
32153: EMPTY
32154: LIST
32155: LIST
32156: PUSH
32157: LD_INT 1
32159: PUSH
32160: LD_INT 2
32162: NEG
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: PUSH
32168: LD_INT 2
32170: PUSH
32171: LD_INT 1
32173: NEG
32174: PUSH
32175: EMPTY
32176: LIST
32177: LIST
32178: PUSH
32179: EMPTY
32180: LIST
32181: LIST
32182: LIST
32183: LIST
32184: LIST
32185: LIST
32186: LIST
32187: LIST
32188: LIST
32189: LIST
32190: LIST
32191: LIST
32192: LIST
32193: LIST
32194: LIST
32195: LIST
32196: LIST
32197: LIST
32198: LIST
32199: LIST
32200: LIST
32201: LIST
32202: LIST
32203: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32204: LD_ADDR_VAR 0 24
32208: PUSH
32209: LD_INT 0
32211: PUSH
32212: LD_INT 0
32214: PUSH
32215: EMPTY
32216: LIST
32217: LIST
32218: PUSH
32219: LD_INT 0
32221: PUSH
32222: LD_INT 1
32224: NEG
32225: PUSH
32226: EMPTY
32227: LIST
32228: LIST
32229: PUSH
32230: LD_INT 1
32232: PUSH
32233: LD_INT 0
32235: PUSH
32236: EMPTY
32237: LIST
32238: LIST
32239: PUSH
32240: LD_INT 1
32242: PUSH
32243: LD_INT 1
32245: PUSH
32246: EMPTY
32247: LIST
32248: LIST
32249: PUSH
32250: LD_INT 0
32252: PUSH
32253: LD_INT 1
32255: PUSH
32256: EMPTY
32257: LIST
32258: LIST
32259: PUSH
32260: LD_INT 1
32262: NEG
32263: PUSH
32264: LD_INT 0
32266: PUSH
32267: EMPTY
32268: LIST
32269: LIST
32270: PUSH
32271: LD_INT 1
32273: NEG
32274: PUSH
32275: LD_INT 1
32277: NEG
32278: PUSH
32279: EMPTY
32280: LIST
32281: LIST
32282: PUSH
32283: LD_INT 1
32285: NEG
32286: PUSH
32287: LD_INT 2
32289: NEG
32290: PUSH
32291: EMPTY
32292: LIST
32293: LIST
32294: PUSH
32295: LD_INT 0
32297: PUSH
32298: LD_INT 2
32300: NEG
32301: PUSH
32302: EMPTY
32303: LIST
32304: LIST
32305: PUSH
32306: LD_INT 1
32308: PUSH
32309: LD_INT 1
32311: NEG
32312: PUSH
32313: EMPTY
32314: LIST
32315: LIST
32316: PUSH
32317: LD_INT 2
32319: PUSH
32320: LD_INT 0
32322: PUSH
32323: EMPTY
32324: LIST
32325: LIST
32326: PUSH
32327: LD_INT 2
32329: PUSH
32330: LD_INT 1
32332: PUSH
32333: EMPTY
32334: LIST
32335: LIST
32336: PUSH
32337: LD_INT 2
32339: PUSH
32340: LD_INT 2
32342: PUSH
32343: EMPTY
32344: LIST
32345: LIST
32346: PUSH
32347: LD_INT 1
32349: PUSH
32350: LD_INT 2
32352: PUSH
32353: EMPTY
32354: LIST
32355: LIST
32356: PUSH
32357: LD_INT 0
32359: PUSH
32360: LD_INT 2
32362: PUSH
32363: EMPTY
32364: LIST
32365: LIST
32366: PUSH
32367: LD_INT 1
32369: NEG
32370: PUSH
32371: LD_INT 1
32373: PUSH
32374: EMPTY
32375: LIST
32376: LIST
32377: PUSH
32378: LD_INT 2
32380: NEG
32381: PUSH
32382: LD_INT 0
32384: PUSH
32385: EMPTY
32386: LIST
32387: LIST
32388: PUSH
32389: LD_INT 2
32391: NEG
32392: PUSH
32393: LD_INT 1
32395: NEG
32396: PUSH
32397: EMPTY
32398: LIST
32399: LIST
32400: PUSH
32401: LD_INT 2
32403: NEG
32404: PUSH
32405: LD_INT 2
32407: NEG
32408: PUSH
32409: EMPTY
32410: LIST
32411: LIST
32412: PUSH
32413: LD_INT 1
32415: PUSH
32416: LD_INT 2
32418: NEG
32419: PUSH
32420: EMPTY
32421: LIST
32422: LIST
32423: PUSH
32424: LD_INT 2
32426: PUSH
32427: LD_INT 1
32429: NEG
32430: PUSH
32431: EMPTY
32432: LIST
32433: LIST
32434: PUSH
32435: LD_INT 3
32437: PUSH
32438: LD_INT 1
32440: PUSH
32441: EMPTY
32442: LIST
32443: LIST
32444: PUSH
32445: LD_INT 3
32447: PUSH
32448: LD_INT 2
32450: PUSH
32451: EMPTY
32452: LIST
32453: LIST
32454: PUSH
32455: EMPTY
32456: LIST
32457: LIST
32458: LIST
32459: LIST
32460: LIST
32461: LIST
32462: LIST
32463: LIST
32464: LIST
32465: LIST
32466: LIST
32467: LIST
32468: LIST
32469: LIST
32470: LIST
32471: LIST
32472: LIST
32473: LIST
32474: LIST
32475: LIST
32476: LIST
32477: LIST
32478: LIST
32479: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32480: LD_ADDR_VAR 0 25
32484: PUSH
32485: LD_INT 0
32487: PUSH
32488: LD_INT 0
32490: PUSH
32491: EMPTY
32492: LIST
32493: LIST
32494: PUSH
32495: LD_INT 0
32497: PUSH
32498: LD_INT 1
32500: NEG
32501: PUSH
32502: EMPTY
32503: LIST
32504: LIST
32505: PUSH
32506: LD_INT 1
32508: PUSH
32509: LD_INT 0
32511: PUSH
32512: EMPTY
32513: LIST
32514: LIST
32515: PUSH
32516: LD_INT 1
32518: PUSH
32519: LD_INT 1
32521: PUSH
32522: EMPTY
32523: LIST
32524: LIST
32525: PUSH
32526: LD_INT 0
32528: PUSH
32529: LD_INT 1
32531: PUSH
32532: EMPTY
32533: LIST
32534: LIST
32535: PUSH
32536: LD_INT 1
32538: NEG
32539: PUSH
32540: LD_INT 0
32542: PUSH
32543: EMPTY
32544: LIST
32545: LIST
32546: PUSH
32547: LD_INT 1
32549: NEG
32550: PUSH
32551: LD_INT 1
32553: NEG
32554: PUSH
32555: EMPTY
32556: LIST
32557: LIST
32558: PUSH
32559: LD_INT 1
32561: NEG
32562: PUSH
32563: LD_INT 2
32565: NEG
32566: PUSH
32567: EMPTY
32568: LIST
32569: LIST
32570: PUSH
32571: LD_INT 0
32573: PUSH
32574: LD_INT 2
32576: NEG
32577: PUSH
32578: EMPTY
32579: LIST
32580: LIST
32581: PUSH
32582: LD_INT 1
32584: PUSH
32585: LD_INT 1
32587: NEG
32588: PUSH
32589: EMPTY
32590: LIST
32591: LIST
32592: PUSH
32593: LD_INT 2
32595: PUSH
32596: LD_INT 0
32598: PUSH
32599: EMPTY
32600: LIST
32601: LIST
32602: PUSH
32603: LD_INT 2
32605: PUSH
32606: LD_INT 1
32608: PUSH
32609: EMPTY
32610: LIST
32611: LIST
32612: PUSH
32613: LD_INT 2
32615: PUSH
32616: LD_INT 2
32618: PUSH
32619: EMPTY
32620: LIST
32621: LIST
32622: PUSH
32623: LD_INT 1
32625: PUSH
32626: LD_INT 2
32628: PUSH
32629: EMPTY
32630: LIST
32631: LIST
32632: PUSH
32633: LD_INT 0
32635: PUSH
32636: LD_INT 2
32638: PUSH
32639: EMPTY
32640: LIST
32641: LIST
32642: PUSH
32643: LD_INT 1
32645: NEG
32646: PUSH
32647: LD_INT 1
32649: PUSH
32650: EMPTY
32651: LIST
32652: LIST
32653: PUSH
32654: LD_INT 2
32656: NEG
32657: PUSH
32658: LD_INT 0
32660: PUSH
32661: EMPTY
32662: LIST
32663: LIST
32664: PUSH
32665: LD_INT 2
32667: NEG
32668: PUSH
32669: LD_INT 1
32671: NEG
32672: PUSH
32673: EMPTY
32674: LIST
32675: LIST
32676: PUSH
32677: LD_INT 2
32679: NEG
32680: PUSH
32681: LD_INT 2
32683: NEG
32684: PUSH
32685: EMPTY
32686: LIST
32687: LIST
32688: PUSH
32689: LD_INT 3
32691: PUSH
32692: LD_INT 1
32694: PUSH
32695: EMPTY
32696: LIST
32697: LIST
32698: PUSH
32699: LD_INT 3
32701: PUSH
32702: LD_INT 2
32704: PUSH
32705: EMPTY
32706: LIST
32707: LIST
32708: PUSH
32709: LD_INT 2
32711: PUSH
32712: LD_INT 3
32714: PUSH
32715: EMPTY
32716: LIST
32717: LIST
32718: PUSH
32719: LD_INT 1
32721: PUSH
32722: LD_INT 3
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: PUSH
32729: EMPTY
32730: LIST
32731: LIST
32732: LIST
32733: LIST
32734: LIST
32735: LIST
32736: LIST
32737: LIST
32738: LIST
32739: LIST
32740: LIST
32741: LIST
32742: LIST
32743: LIST
32744: LIST
32745: LIST
32746: LIST
32747: LIST
32748: LIST
32749: LIST
32750: LIST
32751: LIST
32752: LIST
32753: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32754: LD_ADDR_VAR 0 26
32758: PUSH
32759: LD_INT 0
32761: PUSH
32762: LD_INT 0
32764: PUSH
32765: EMPTY
32766: LIST
32767: LIST
32768: PUSH
32769: LD_INT 0
32771: PUSH
32772: LD_INT 1
32774: NEG
32775: PUSH
32776: EMPTY
32777: LIST
32778: LIST
32779: PUSH
32780: LD_INT 1
32782: PUSH
32783: LD_INT 0
32785: PUSH
32786: EMPTY
32787: LIST
32788: LIST
32789: PUSH
32790: LD_INT 1
32792: PUSH
32793: LD_INT 1
32795: PUSH
32796: EMPTY
32797: LIST
32798: LIST
32799: PUSH
32800: LD_INT 0
32802: PUSH
32803: LD_INT 1
32805: PUSH
32806: EMPTY
32807: LIST
32808: LIST
32809: PUSH
32810: LD_INT 1
32812: NEG
32813: PUSH
32814: LD_INT 0
32816: PUSH
32817: EMPTY
32818: LIST
32819: LIST
32820: PUSH
32821: LD_INT 1
32823: NEG
32824: PUSH
32825: LD_INT 1
32827: NEG
32828: PUSH
32829: EMPTY
32830: LIST
32831: LIST
32832: PUSH
32833: LD_INT 1
32835: NEG
32836: PUSH
32837: LD_INT 2
32839: NEG
32840: PUSH
32841: EMPTY
32842: LIST
32843: LIST
32844: PUSH
32845: LD_INT 0
32847: PUSH
32848: LD_INT 2
32850: NEG
32851: PUSH
32852: EMPTY
32853: LIST
32854: LIST
32855: PUSH
32856: LD_INT 1
32858: PUSH
32859: LD_INT 1
32861: NEG
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: PUSH
32867: LD_INT 2
32869: PUSH
32870: LD_INT 0
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: PUSH
32877: LD_INT 2
32879: PUSH
32880: LD_INT 1
32882: PUSH
32883: EMPTY
32884: LIST
32885: LIST
32886: PUSH
32887: LD_INT 2
32889: PUSH
32890: LD_INT 2
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: PUSH
32897: LD_INT 1
32899: PUSH
32900: LD_INT 2
32902: PUSH
32903: EMPTY
32904: LIST
32905: LIST
32906: PUSH
32907: LD_INT 0
32909: PUSH
32910: LD_INT 2
32912: PUSH
32913: EMPTY
32914: LIST
32915: LIST
32916: PUSH
32917: LD_INT 1
32919: NEG
32920: PUSH
32921: LD_INT 1
32923: PUSH
32924: EMPTY
32925: LIST
32926: LIST
32927: PUSH
32928: LD_INT 2
32930: NEG
32931: PUSH
32932: LD_INT 0
32934: PUSH
32935: EMPTY
32936: LIST
32937: LIST
32938: PUSH
32939: LD_INT 2
32941: NEG
32942: PUSH
32943: LD_INT 1
32945: NEG
32946: PUSH
32947: EMPTY
32948: LIST
32949: LIST
32950: PUSH
32951: LD_INT 2
32953: NEG
32954: PUSH
32955: LD_INT 2
32957: NEG
32958: PUSH
32959: EMPTY
32960: LIST
32961: LIST
32962: PUSH
32963: LD_INT 2
32965: PUSH
32966: LD_INT 3
32968: PUSH
32969: EMPTY
32970: LIST
32971: LIST
32972: PUSH
32973: LD_INT 1
32975: PUSH
32976: LD_INT 3
32978: PUSH
32979: EMPTY
32980: LIST
32981: LIST
32982: PUSH
32983: LD_INT 1
32985: NEG
32986: PUSH
32987: LD_INT 2
32989: PUSH
32990: EMPTY
32991: LIST
32992: LIST
32993: PUSH
32994: LD_INT 2
32996: NEG
32997: PUSH
32998: LD_INT 1
33000: PUSH
33001: EMPTY
33002: LIST
33003: LIST
33004: PUSH
33005: EMPTY
33006: LIST
33007: LIST
33008: LIST
33009: LIST
33010: LIST
33011: LIST
33012: LIST
33013: LIST
33014: LIST
33015: LIST
33016: LIST
33017: LIST
33018: LIST
33019: LIST
33020: LIST
33021: LIST
33022: LIST
33023: LIST
33024: LIST
33025: LIST
33026: LIST
33027: LIST
33028: LIST
33029: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33030: LD_ADDR_VAR 0 27
33034: PUSH
33035: LD_INT 0
33037: PUSH
33038: LD_INT 0
33040: PUSH
33041: EMPTY
33042: LIST
33043: LIST
33044: PUSH
33045: LD_INT 0
33047: PUSH
33048: LD_INT 1
33050: NEG
33051: PUSH
33052: EMPTY
33053: LIST
33054: LIST
33055: PUSH
33056: LD_INT 1
33058: PUSH
33059: LD_INT 0
33061: PUSH
33062: EMPTY
33063: LIST
33064: LIST
33065: PUSH
33066: LD_INT 1
33068: PUSH
33069: LD_INT 1
33071: PUSH
33072: EMPTY
33073: LIST
33074: LIST
33075: PUSH
33076: LD_INT 0
33078: PUSH
33079: LD_INT 1
33081: PUSH
33082: EMPTY
33083: LIST
33084: LIST
33085: PUSH
33086: LD_INT 1
33088: NEG
33089: PUSH
33090: LD_INT 0
33092: PUSH
33093: EMPTY
33094: LIST
33095: LIST
33096: PUSH
33097: LD_INT 1
33099: NEG
33100: PUSH
33101: LD_INT 1
33103: NEG
33104: PUSH
33105: EMPTY
33106: LIST
33107: LIST
33108: PUSH
33109: LD_INT 1
33111: NEG
33112: PUSH
33113: LD_INT 2
33115: NEG
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 0
33123: PUSH
33124: LD_INT 2
33126: NEG
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 1
33134: PUSH
33135: LD_INT 1
33137: NEG
33138: PUSH
33139: EMPTY
33140: LIST
33141: LIST
33142: PUSH
33143: LD_INT 2
33145: PUSH
33146: LD_INT 0
33148: PUSH
33149: EMPTY
33150: LIST
33151: LIST
33152: PUSH
33153: LD_INT 2
33155: PUSH
33156: LD_INT 1
33158: PUSH
33159: EMPTY
33160: LIST
33161: LIST
33162: PUSH
33163: LD_INT 2
33165: PUSH
33166: LD_INT 2
33168: PUSH
33169: EMPTY
33170: LIST
33171: LIST
33172: PUSH
33173: LD_INT 1
33175: PUSH
33176: LD_INT 2
33178: PUSH
33179: EMPTY
33180: LIST
33181: LIST
33182: PUSH
33183: LD_INT 0
33185: PUSH
33186: LD_INT 2
33188: PUSH
33189: EMPTY
33190: LIST
33191: LIST
33192: PUSH
33193: LD_INT 1
33195: NEG
33196: PUSH
33197: LD_INT 1
33199: PUSH
33200: EMPTY
33201: LIST
33202: LIST
33203: PUSH
33204: LD_INT 2
33206: NEG
33207: PUSH
33208: LD_INT 0
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PUSH
33215: LD_INT 2
33217: NEG
33218: PUSH
33219: LD_INT 1
33221: NEG
33222: PUSH
33223: EMPTY
33224: LIST
33225: LIST
33226: PUSH
33227: LD_INT 2
33229: NEG
33230: PUSH
33231: LD_INT 2
33233: NEG
33234: PUSH
33235: EMPTY
33236: LIST
33237: LIST
33238: PUSH
33239: LD_INT 1
33241: NEG
33242: PUSH
33243: LD_INT 2
33245: PUSH
33246: EMPTY
33247: LIST
33248: LIST
33249: PUSH
33250: LD_INT 2
33252: NEG
33253: PUSH
33254: LD_INT 1
33256: PUSH
33257: EMPTY
33258: LIST
33259: LIST
33260: PUSH
33261: LD_INT 3
33263: NEG
33264: PUSH
33265: LD_INT 1
33267: NEG
33268: PUSH
33269: EMPTY
33270: LIST
33271: LIST
33272: PUSH
33273: LD_INT 3
33275: NEG
33276: PUSH
33277: LD_INT 2
33279: NEG
33280: PUSH
33281: EMPTY
33282: LIST
33283: LIST
33284: PUSH
33285: EMPTY
33286: LIST
33287: LIST
33288: LIST
33289: LIST
33290: LIST
33291: LIST
33292: LIST
33293: LIST
33294: LIST
33295: LIST
33296: LIST
33297: LIST
33298: LIST
33299: LIST
33300: LIST
33301: LIST
33302: LIST
33303: LIST
33304: LIST
33305: LIST
33306: LIST
33307: LIST
33308: LIST
33309: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33310: LD_ADDR_VAR 0 28
33314: PUSH
33315: LD_INT 0
33317: PUSH
33318: LD_INT 0
33320: PUSH
33321: EMPTY
33322: LIST
33323: LIST
33324: PUSH
33325: LD_INT 0
33327: PUSH
33328: LD_INT 1
33330: NEG
33331: PUSH
33332: EMPTY
33333: LIST
33334: LIST
33335: PUSH
33336: LD_INT 1
33338: PUSH
33339: LD_INT 0
33341: PUSH
33342: EMPTY
33343: LIST
33344: LIST
33345: PUSH
33346: LD_INT 1
33348: PUSH
33349: LD_INT 1
33351: PUSH
33352: EMPTY
33353: LIST
33354: LIST
33355: PUSH
33356: LD_INT 0
33358: PUSH
33359: LD_INT 1
33361: PUSH
33362: EMPTY
33363: LIST
33364: LIST
33365: PUSH
33366: LD_INT 1
33368: NEG
33369: PUSH
33370: LD_INT 0
33372: PUSH
33373: EMPTY
33374: LIST
33375: LIST
33376: PUSH
33377: LD_INT 1
33379: NEG
33380: PUSH
33381: LD_INT 1
33383: NEG
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: PUSH
33389: LD_INT 1
33391: NEG
33392: PUSH
33393: LD_INT 2
33395: NEG
33396: PUSH
33397: EMPTY
33398: LIST
33399: LIST
33400: PUSH
33401: LD_INT 0
33403: PUSH
33404: LD_INT 2
33406: NEG
33407: PUSH
33408: EMPTY
33409: LIST
33410: LIST
33411: PUSH
33412: LD_INT 1
33414: PUSH
33415: LD_INT 1
33417: NEG
33418: PUSH
33419: EMPTY
33420: LIST
33421: LIST
33422: PUSH
33423: LD_INT 2
33425: PUSH
33426: LD_INT 0
33428: PUSH
33429: EMPTY
33430: LIST
33431: LIST
33432: PUSH
33433: LD_INT 2
33435: PUSH
33436: LD_INT 1
33438: PUSH
33439: EMPTY
33440: LIST
33441: LIST
33442: PUSH
33443: LD_INT 2
33445: PUSH
33446: LD_INT 2
33448: PUSH
33449: EMPTY
33450: LIST
33451: LIST
33452: PUSH
33453: LD_INT 1
33455: PUSH
33456: LD_INT 2
33458: PUSH
33459: EMPTY
33460: LIST
33461: LIST
33462: PUSH
33463: LD_INT 0
33465: PUSH
33466: LD_INT 2
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: PUSH
33473: LD_INT 1
33475: NEG
33476: PUSH
33477: LD_INT 1
33479: PUSH
33480: EMPTY
33481: LIST
33482: LIST
33483: PUSH
33484: LD_INT 2
33486: NEG
33487: PUSH
33488: LD_INT 0
33490: PUSH
33491: EMPTY
33492: LIST
33493: LIST
33494: PUSH
33495: LD_INT 2
33497: NEG
33498: PUSH
33499: LD_INT 1
33501: NEG
33502: PUSH
33503: EMPTY
33504: LIST
33505: LIST
33506: PUSH
33507: LD_INT 2
33509: NEG
33510: PUSH
33511: LD_INT 2
33513: NEG
33514: PUSH
33515: EMPTY
33516: LIST
33517: LIST
33518: PUSH
33519: LD_INT 2
33521: NEG
33522: PUSH
33523: LD_INT 3
33525: NEG
33526: PUSH
33527: EMPTY
33528: LIST
33529: LIST
33530: PUSH
33531: LD_INT 1
33533: NEG
33534: PUSH
33535: LD_INT 3
33537: NEG
33538: PUSH
33539: EMPTY
33540: LIST
33541: LIST
33542: PUSH
33543: LD_INT 3
33545: NEG
33546: PUSH
33547: LD_INT 1
33549: NEG
33550: PUSH
33551: EMPTY
33552: LIST
33553: LIST
33554: PUSH
33555: LD_INT 3
33557: NEG
33558: PUSH
33559: LD_INT 2
33561: NEG
33562: PUSH
33563: EMPTY
33564: LIST
33565: LIST
33566: PUSH
33567: EMPTY
33568: LIST
33569: LIST
33570: LIST
33571: LIST
33572: LIST
33573: LIST
33574: LIST
33575: LIST
33576: LIST
33577: LIST
33578: LIST
33579: LIST
33580: LIST
33581: LIST
33582: LIST
33583: LIST
33584: LIST
33585: LIST
33586: LIST
33587: LIST
33588: LIST
33589: LIST
33590: LIST
33591: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33592: LD_ADDR_VAR 0 29
33596: PUSH
33597: LD_INT 0
33599: PUSH
33600: LD_INT 0
33602: PUSH
33603: EMPTY
33604: LIST
33605: LIST
33606: PUSH
33607: LD_INT 0
33609: PUSH
33610: LD_INT 1
33612: NEG
33613: PUSH
33614: EMPTY
33615: LIST
33616: LIST
33617: PUSH
33618: LD_INT 1
33620: PUSH
33621: LD_INT 0
33623: PUSH
33624: EMPTY
33625: LIST
33626: LIST
33627: PUSH
33628: LD_INT 1
33630: PUSH
33631: LD_INT 1
33633: PUSH
33634: EMPTY
33635: LIST
33636: LIST
33637: PUSH
33638: LD_INT 0
33640: PUSH
33641: LD_INT 1
33643: PUSH
33644: EMPTY
33645: LIST
33646: LIST
33647: PUSH
33648: LD_INT 1
33650: NEG
33651: PUSH
33652: LD_INT 0
33654: PUSH
33655: EMPTY
33656: LIST
33657: LIST
33658: PUSH
33659: LD_INT 1
33661: NEG
33662: PUSH
33663: LD_INT 1
33665: NEG
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 1
33673: NEG
33674: PUSH
33675: LD_INT 2
33677: NEG
33678: PUSH
33679: EMPTY
33680: LIST
33681: LIST
33682: PUSH
33683: LD_INT 0
33685: PUSH
33686: LD_INT 2
33688: NEG
33689: PUSH
33690: EMPTY
33691: LIST
33692: LIST
33693: PUSH
33694: LD_INT 1
33696: PUSH
33697: LD_INT 1
33699: NEG
33700: PUSH
33701: EMPTY
33702: LIST
33703: LIST
33704: PUSH
33705: LD_INT 2
33707: PUSH
33708: LD_INT 0
33710: PUSH
33711: EMPTY
33712: LIST
33713: LIST
33714: PUSH
33715: LD_INT 2
33717: PUSH
33718: LD_INT 1
33720: PUSH
33721: EMPTY
33722: LIST
33723: LIST
33724: PUSH
33725: LD_INT 1
33727: PUSH
33728: LD_INT 2
33730: PUSH
33731: EMPTY
33732: LIST
33733: LIST
33734: PUSH
33735: LD_INT 0
33737: PUSH
33738: LD_INT 2
33740: PUSH
33741: EMPTY
33742: LIST
33743: LIST
33744: PUSH
33745: LD_INT 1
33747: NEG
33748: PUSH
33749: LD_INT 1
33751: PUSH
33752: EMPTY
33753: LIST
33754: LIST
33755: PUSH
33756: LD_INT 2
33758: NEG
33759: PUSH
33760: LD_INT 1
33762: NEG
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 2
33770: NEG
33771: PUSH
33772: LD_INT 2
33774: NEG
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PUSH
33780: LD_INT 2
33782: NEG
33783: PUSH
33784: LD_INT 3
33786: NEG
33787: PUSH
33788: EMPTY
33789: LIST
33790: LIST
33791: PUSH
33792: LD_INT 2
33794: PUSH
33795: LD_INT 1
33797: NEG
33798: PUSH
33799: EMPTY
33800: LIST
33801: LIST
33802: PUSH
33803: LD_INT 3
33805: PUSH
33806: LD_INT 1
33808: PUSH
33809: EMPTY
33810: LIST
33811: LIST
33812: PUSH
33813: LD_INT 1
33815: PUSH
33816: LD_INT 3
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: LD_INT 1
33825: NEG
33826: PUSH
33827: LD_INT 2
33829: PUSH
33830: EMPTY
33831: LIST
33832: LIST
33833: PUSH
33834: LD_INT 3
33836: NEG
33837: PUSH
33838: LD_INT 2
33840: NEG
33841: PUSH
33842: EMPTY
33843: LIST
33844: LIST
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: LIST
33850: LIST
33851: LIST
33852: LIST
33853: LIST
33854: LIST
33855: LIST
33856: LIST
33857: LIST
33858: LIST
33859: LIST
33860: LIST
33861: LIST
33862: LIST
33863: LIST
33864: LIST
33865: LIST
33866: LIST
33867: LIST
33868: LIST
33869: LIST
33870: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33871: LD_ADDR_VAR 0 30
33875: PUSH
33876: LD_INT 0
33878: PUSH
33879: LD_INT 0
33881: PUSH
33882: EMPTY
33883: LIST
33884: LIST
33885: PUSH
33886: LD_INT 0
33888: PUSH
33889: LD_INT 1
33891: NEG
33892: PUSH
33893: EMPTY
33894: LIST
33895: LIST
33896: PUSH
33897: LD_INT 1
33899: PUSH
33900: LD_INT 0
33902: PUSH
33903: EMPTY
33904: LIST
33905: LIST
33906: PUSH
33907: LD_INT 1
33909: PUSH
33910: LD_INT 1
33912: PUSH
33913: EMPTY
33914: LIST
33915: LIST
33916: PUSH
33917: LD_INT 0
33919: PUSH
33920: LD_INT 1
33922: PUSH
33923: EMPTY
33924: LIST
33925: LIST
33926: PUSH
33927: LD_INT 1
33929: NEG
33930: PUSH
33931: LD_INT 0
33933: PUSH
33934: EMPTY
33935: LIST
33936: LIST
33937: PUSH
33938: LD_INT 1
33940: NEG
33941: PUSH
33942: LD_INT 1
33944: NEG
33945: PUSH
33946: EMPTY
33947: LIST
33948: LIST
33949: PUSH
33950: LD_INT 1
33952: NEG
33953: PUSH
33954: LD_INT 2
33956: NEG
33957: PUSH
33958: EMPTY
33959: LIST
33960: LIST
33961: PUSH
33962: LD_INT 0
33964: PUSH
33965: LD_INT 2
33967: NEG
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PUSH
33973: LD_INT 1
33975: PUSH
33976: LD_INT 1
33978: NEG
33979: PUSH
33980: EMPTY
33981: LIST
33982: LIST
33983: PUSH
33984: LD_INT 2
33986: PUSH
33987: LD_INT 0
33989: PUSH
33990: EMPTY
33991: LIST
33992: LIST
33993: PUSH
33994: LD_INT 2
33996: PUSH
33997: LD_INT 1
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PUSH
34004: LD_INT 2
34006: PUSH
34007: LD_INT 2
34009: PUSH
34010: EMPTY
34011: LIST
34012: LIST
34013: PUSH
34014: LD_INT 1
34016: PUSH
34017: LD_INT 2
34019: PUSH
34020: EMPTY
34021: LIST
34022: LIST
34023: PUSH
34024: LD_INT 1
34026: NEG
34027: PUSH
34028: LD_INT 1
34030: PUSH
34031: EMPTY
34032: LIST
34033: LIST
34034: PUSH
34035: LD_INT 2
34037: NEG
34038: PUSH
34039: LD_INT 0
34041: PUSH
34042: EMPTY
34043: LIST
34044: LIST
34045: PUSH
34046: LD_INT 2
34048: NEG
34049: PUSH
34050: LD_INT 1
34052: NEG
34053: PUSH
34054: EMPTY
34055: LIST
34056: LIST
34057: PUSH
34058: LD_INT 1
34060: NEG
34061: PUSH
34062: LD_INT 3
34064: NEG
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: PUSH
34070: LD_INT 1
34072: PUSH
34073: LD_INT 2
34075: NEG
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 3
34083: PUSH
34084: LD_INT 2
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 2
34093: PUSH
34094: LD_INT 3
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: LD_INT 2
34103: NEG
34104: PUSH
34105: LD_INT 1
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: PUSH
34112: LD_INT 3
34114: NEG
34115: PUSH
34116: LD_INT 1
34118: NEG
34119: PUSH
34120: EMPTY
34121: LIST
34122: LIST
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: LIST
34128: LIST
34129: LIST
34130: LIST
34131: LIST
34132: LIST
34133: LIST
34134: LIST
34135: LIST
34136: LIST
34137: LIST
34138: LIST
34139: LIST
34140: LIST
34141: LIST
34142: LIST
34143: LIST
34144: LIST
34145: LIST
34146: LIST
34147: LIST
34148: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34149: LD_ADDR_VAR 0 31
34153: PUSH
34154: LD_INT 0
34156: PUSH
34157: LD_INT 0
34159: PUSH
34160: EMPTY
34161: LIST
34162: LIST
34163: PUSH
34164: LD_INT 0
34166: PUSH
34167: LD_INT 1
34169: NEG
34170: PUSH
34171: EMPTY
34172: LIST
34173: LIST
34174: PUSH
34175: LD_INT 1
34177: PUSH
34178: LD_INT 0
34180: PUSH
34181: EMPTY
34182: LIST
34183: LIST
34184: PUSH
34185: LD_INT 1
34187: PUSH
34188: LD_INT 1
34190: PUSH
34191: EMPTY
34192: LIST
34193: LIST
34194: PUSH
34195: LD_INT 0
34197: PUSH
34198: LD_INT 1
34200: PUSH
34201: EMPTY
34202: LIST
34203: LIST
34204: PUSH
34205: LD_INT 1
34207: NEG
34208: PUSH
34209: LD_INT 0
34211: PUSH
34212: EMPTY
34213: LIST
34214: LIST
34215: PUSH
34216: LD_INT 1
34218: NEG
34219: PUSH
34220: LD_INT 1
34222: NEG
34223: PUSH
34224: EMPTY
34225: LIST
34226: LIST
34227: PUSH
34228: LD_INT 1
34230: NEG
34231: PUSH
34232: LD_INT 2
34234: NEG
34235: PUSH
34236: EMPTY
34237: LIST
34238: LIST
34239: PUSH
34240: LD_INT 1
34242: PUSH
34243: LD_INT 1
34245: NEG
34246: PUSH
34247: EMPTY
34248: LIST
34249: LIST
34250: PUSH
34251: LD_INT 2
34253: PUSH
34254: LD_INT 0
34256: PUSH
34257: EMPTY
34258: LIST
34259: LIST
34260: PUSH
34261: LD_INT 2
34263: PUSH
34264: LD_INT 1
34266: PUSH
34267: EMPTY
34268: LIST
34269: LIST
34270: PUSH
34271: LD_INT 2
34273: PUSH
34274: LD_INT 2
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PUSH
34281: LD_INT 1
34283: PUSH
34284: LD_INT 2
34286: PUSH
34287: EMPTY
34288: LIST
34289: LIST
34290: PUSH
34291: LD_INT 0
34293: PUSH
34294: LD_INT 2
34296: PUSH
34297: EMPTY
34298: LIST
34299: LIST
34300: PUSH
34301: LD_INT 1
34303: NEG
34304: PUSH
34305: LD_INT 1
34307: PUSH
34308: EMPTY
34309: LIST
34310: LIST
34311: PUSH
34312: LD_INT 2
34314: NEG
34315: PUSH
34316: LD_INT 1
34318: NEG
34319: PUSH
34320: EMPTY
34321: LIST
34322: LIST
34323: PUSH
34324: LD_INT 2
34326: NEG
34327: PUSH
34328: LD_INT 2
34330: NEG
34331: PUSH
34332: EMPTY
34333: LIST
34334: LIST
34335: PUSH
34336: LD_INT 2
34338: NEG
34339: PUSH
34340: LD_INT 3
34342: NEG
34343: PUSH
34344: EMPTY
34345: LIST
34346: LIST
34347: PUSH
34348: LD_INT 2
34350: PUSH
34351: LD_INT 1
34353: NEG
34354: PUSH
34355: EMPTY
34356: LIST
34357: LIST
34358: PUSH
34359: LD_INT 3
34361: PUSH
34362: LD_INT 1
34364: PUSH
34365: EMPTY
34366: LIST
34367: LIST
34368: PUSH
34369: LD_INT 1
34371: PUSH
34372: LD_INT 3
34374: PUSH
34375: EMPTY
34376: LIST
34377: LIST
34378: PUSH
34379: LD_INT 1
34381: NEG
34382: PUSH
34383: LD_INT 2
34385: PUSH
34386: EMPTY
34387: LIST
34388: LIST
34389: PUSH
34390: LD_INT 3
34392: NEG
34393: PUSH
34394: LD_INT 2
34396: NEG
34397: PUSH
34398: EMPTY
34399: LIST
34400: LIST
34401: PUSH
34402: EMPTY
34403: LIST
34404: LIST
34405: LIST
34406: LIST
34407: LIST
34408: LIST
34409: LIST
34410: LIST
34411: LIST
34412: LIST
34413: LIST
34414: LIST
34415: LIST
34416: LIST
34417: LIST
34418: LIST
34419: LIST
34420: LIST
34421: LIST
34422: LIST
34423: LIST
34424: LIST
34425: LIST
34426: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34427: LD_ADDR_VAR 0 32
34431: PUSH
34432: LD_INT 0
34434: PUSH
34435: LD_INT 0
34437: PUSH
34438: EMPTY
34439: LIST
34440: LIST
34441: PUSH
34442: LD_INT 0
34444: PUSH
34445: LD_INT 1
34447: NEG
34448: PUSH
34449: EMPTY
34450: LIST
34451: LIST
34452: PUSH
34453: LD_INT 1
34455: PUSH
34456: LD_INT 0
34458: PUSH
34459: EMPTY
34460: LIST
34461: LIST
34462: PUSH
34463: LD_INT 1
34465: PUSH
34466: LD_INT 1
34468: PUSH
34469: EMPTY
34470: LIST
34471: LIST
34472: PUSH
34473: LD_INT 0
34475: PUSH
34476: LD_INT 1
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: PUSH
34483: LD_INT 1
34485: NEG
34486: PUSH
34487: LD_INT 0
34489: PUSH
34490: EMPTY
34491: LIST
34492: LIST
34493: PUSH
34494: LD_INT 1
34496: NEG
34497: PUSH
34498: LD_INT 1
34500: NEG
34501: PUSH
34502: EMPTY
34503: LIST
34504: LIST
34505: PUSH
34506: LD_INT 1
34508: NEG
34509: PUSH
34510: LD_INT 2
34512: NEG
34513: PUSH
34514: EMPTY
34515: LIST
34516: LIST
34517: PUSH
34518: LD_INT 0
34520: PUSH
34521: LD_INT 2
34523: NEG
34524: PUSH
34525: EMPTY
34526: LIST
34527: LIST
34528: PUSH
34529: LD_INT 1
34531: PUSH
34532: LD_INT 1
34534: NEG
34535: PUSH
34536: EMPTY
34537: LIST
34538: LIST
34539: PUSH
34540: LD_INT 2
34542: PUSH
34543: LD_INT 1
34545: PUSH
34546: EMPTY
34547: LIST
34548: LIST
34549: PUSH
34550: LD_INT 2
34552: PUSH
34553: LD_INT 2
34555: PUSH
34556: EMPTY
34557: LIST
34558: LIST
34559: PUSH
34560: LD_INT 1
34562: PUSH
34563: LD_INT 2
34565: PUSH
34566: EMPTY
34567: LIST
34568: LIST
34569: PUSH
34570: LD_INT 0
34572: PUSH
34573: LD_INT 2
34575: PUSH
34576: EMPTY
34577: LIST
34578: LIST
34579: PUSH
34580: LD_INT 1
34582: NEG
34583: PUSH
34584: LD_INT 1
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: PUSH
34591: LD_INT 2
34593: NEG
34594: PUSH
34595: LD_INT 0
34597: PUSH
34598: EMPTY
34599: LIST
34600: LIST
34601: PUSH
34602: LD_INT 2
34604: NEG
34605: PUSH
34606: LD_INT 1
34608: NEG
34609: PUSH
34610: EMPTY
34611: LIST
34612: LIST
34613: PUSH
34614: LD_INT 1
34616: NEG
34617: PUSH
34618: LD_INT 3
34620: NEG
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 1
34628: PUSH
34629: LD_INT 2
34631: NEG
34632: PUSH
34633: EMPTY
34634: LIST
34635: LIST
34636: PUSH
34637: LD_INT 3
34639: PUSH
34640: LD_INT 2
34642: PUSH
34643: EMPTY
34644: LIST
34645: LIST
34646: PUSH
34647: LD_INT 2
34649: PUSH
34650: LD_INT 3
34652: PUSH
34653: EMPTY
34654: LIST
34655: LIST
34656: PUSH
34657: LD_INT 2
34659: NEG
34660: PUSH
34661: LD_INT 1
34663: PUSH
34664: EMPTY
34665: LIST
34666: LIST
34667: PUSH
34668: LD_INT 3
34670: NEG
34671: PUSH
34672: LD_INT 1
34674: NEG
34675: PUSH
34676: EMPTY
34677: LIST
34678: LIST
34679: PUSH
34680: EMPTY
34681: LIST
34682: LIST
34683: LIST
34684: LIST
34685: LIST
34686: LIST
34687: LIST
34688: LIST
34689: LIST
34690: LIST
34691: LIST
34692: LIST
34693: LIST
34694: LIST
34695: LIST
34696: LIST
34697: LIST
34698: LIST
34699: LIST
34700: LIST
34701: LIST
34702: LIST
34703: LIST
34704: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34705: LD_ADDR_VAR 0 33
34709: PUSH
34710: LD_INT 0
34712: PUSH
34713: LD_INT 0
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: PUSH
34720: LD_INT 0
34722: PUSH
34723: LD_INT 1
34725: NEG
34726: PUSH
34727: EMPTY
34728: LIST
34729: LIST
34730: PUSH
34731: LD_INT 1
34733: PUSH
34734: LD_INT 0
34736: PUSH
34737: EMPTY
34738: LIST
34739: LIST
34740: PUSH
34741: LD_INT 1
34743: PUSH
34744: LD_INT 1
34746: PUSH
34747: EMPTY
34748: LIST
34749: LIST
34750: PUSH
34751: LD_INT 0
34753: PUSH
34754: LD_INT 1
34756: PUSH
34757: EMPTY
34758: LIST
34759: LIST
34760: PUSH
34761: LD_INT 1
34763: NEG
34764: PUSH
34765: LD_INT 0
34767: PUSH
34768: EMPTY
34769: LIST
34770: LIST
34771: PUSH
34772: LD_INT 1
34774: NEG
34775: PUSH
34776: LD_INT 1
34778: NEG
34779: PUSH
34780: EMPTY
34781: LIST
34782: LIST
34783: PUSH
34784: LD_INT 1
34786: NEG
34787: PUSH
34788: LD_INT 2
34790: NEG
34791: PUSH
34792: EMPTY
34793: LIST
34794: LIST
34795: PUSH
34796: LD_INT 1
34798: PUSH
34799: LD_INT 1
34801: NEG
34802: PUSH
34803: EMPTY
34804: LIST
34805: LIST
34806: PUSH
34807: LD_INT 2
34809: PUSH
34810: LD_INT 0
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PUSH
34817: LD_INT 2
34819: PUSH
34820: LD_INT 1
34822: PUSH
34823: EMPTY
34824: LIST
34825: LIST
34826: PUSH
34827: LD_INT 1
34829: PUSH
34830: LD_INT 2
34832: PUSH
34833: EMPTY
34834: LIST
34835: LIST
34836: PUSH
34837: LD_INT 0
34839: PUSH
34840: LD_INT 2
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PUSH
34847: LD_INT 1
34849: NEG
34850: PUSH
34851: LD_INT 1
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 2
34860: NEG
34861: PUSH
34862: LD_INT 0
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PUSH
34869: LD_INT 2
34871: NEG
34872: PUSH
34873: LD_INT 1
34875: NEG
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: PUSH
34881: LD_INT 2
34883: NEG
34884: PUSH
34885: LD_INT 2
34887: NEG
34888: PUSH
34889: EMPTY
34890: LIST
34891: LIST
34892: PUSH
34893: LD_INT 2
34895: NEG
34896: PUSH
34897: LD_INT 3
34899: NEG
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: PUSH
34905: LD_INT 2
34907: PUSH
34908: LD_INT 1
34910: NEG
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 3
34918: PUSH
34919: LD_INT 1
34921: PUSH
34922: EMPTY
34923: LIST
34924: LIST
34925: PUSH
34926: LD_INT 1
34928: PUSH
34929: LD_INT 3
34931: PUSH
34932: EMPTY
34933: LIST
34934: LIST
34935: PUSH
34936: LD_INT 1
34938: NEG
34939: PUSH
34940: LD_INT 2
34942: PUSH
34943: EMPTY
34944: LIST
34945: LIST
34946: PUSH
34947: LD_INT 3
34949: NEG
34950: PUSH
34951: LD_INT 2
34953: NEG
34954: PUSH
34955: EMPTY
34956: LIST
34957: LIST
34958: PUSH
34959: EMPTY
34960: LIST
34961: LIST
34962: LIST
34963: LIST
34964: LIST
34965: LIST
34966: LIST
34967: LIST
34968: LIST
34969: LIST
34970: LIST
34971: LIST
34972: LIST
34973: LIST
34974: LIST
34975: LIST
34976: LIST
34977: LIST
34978: LIST
34979: LIST
34980: LIST
34981: LIST
34982: LIST
34983: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34984: LD_ADDR_VAR 0 34
34988: PUSH
34989: LD_INT 0
34991: PUSH
34992: LD_INT 0
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: LD_INT 0
35001: PUSH
35002: LD_INT 1
35004: NEG
35005: PUSH
35006: EMPTY
35007: LIST
35008: LIST
35009: PUSH
35010: LD_INT 1
35012: PUSH
35013: LD_INT 0
35015: PUSH
35016: EMPTY
35017: LIST
35018: LIST
35019: PUSH
35020: LD_INT 1
35022: PUSH
35023: LD_INT 1
35025: PUSH
35026: EMPTY
35027: LIST
35028: LIST
35029: PUSH
35030: LD_INT 0
35032: PUSH
35033: LD_INT 1
35035: PUSH
35036: EMPTY
35037: LIST
35038: LIST
35039: PUSH
35040: LD_INT 1
35042: NEG
35043: PUSH
35044: LD_INT 0
35046: PUSH
35047: EMPTY
35048: LIST
35049: LIST
35050: PUSH
35051: LD_INT 1
35053: NEG
35054: PUSH
35055: LD_INT 1
35057: NEG
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PUSH
35063: LD_INT 1
35065: NEG
35066: PUSH
35067: LD_INT 2
35069: NEG
35070: PUSH
35071: EMPTY
35072: LIST
35073: LIST
35074: PUSH
35075: LD_INT 0
35077: PUSH
35078: LD_INT 2
35080: NEG
35081: PUSH
35082: EMPTY
35083: LIST
35084: LIST
35085: PUSH
35086: LD_INT 1
35088: PUSH
35089: LD_INT 1
35091: NEG
35092: PUSH
35093: EMPTY
35094: LIST
35095: LIST
35096: PUSH
35097: LD_INT 2
35099: PUSH
35100: LD_INT 1
35102: PUSH
35103: EMPTY
35104: LIST
35105: LIST
35106: PUSH
35107: LD_INT 2
35109: PUSH
35110: LD_INT 2
35112: PUSH
35113: EMPTY
35114: LIST
35115: LIST
35116: PUSH
35117: LD_INT 1
35119: PUSH
35120: LD_INT 2
35122: PUSH
35123: EMPTY
35124: LIST
35125: LIST
35126: PUSH
35127: LD_INT 1
35129: NEG
35130: PUSH
35131: LD_INT 1
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: LD_INT 2
35140: NEG
35141: PUSH
35142: LD_INT 0
35144: PUSH
35145: EMPTY
35146: LIST
35147: LIST
35148: PUSH
35149: LD_INT 2
35151: NEG
35152: PUSH
35153: LD_INT 1
35155: NEG
35156: PUSH
35157: EMPTY
35158: LIST
35159: LIST
35160: PUSH
35161: LD_INT 2
35163: NEG
35164: PUSH
35165: LD_INT 2
35167: NEG
35168: PUSH
35169: EMPTY
35170: LIST
35171: LIST
35172: PUSH
35173: LD_INT 1
35175: NEG
35176: PUSH
35177: LD_INT 3
35179: NEG
35180: PUSH
35181: EMPTY
35182: LIST
35183: LIST
35184: PUSH
35185: LD_INT 1
35187: PUSH
35188: LD_INT 2
35190: NEG
35191: PUSH
35192: EMPTY
35193: LIST
35194: LIST
35195: PUSH
35196: LD_INT 3
35198: PUSH
35199: LD_INT 2
35201: PUSH
35202: EMPTY
35203: LIST
35204: LIST
35205: PUSH
35206: LD_INT 2
35208: PUSH
35209: LD_INT 3
35211: PUSH
35212: EMPTY
35213: LIST
35214: LIST
35215: PUSH
35216: LD_INT 2
35218: NEG
35219: PUSH
35220: LD_INT 1
35222: PUSH
35223: EMPTY
35224: LIST
35225: LIST
35226: PUSH
35227: LD_INT 3
35229: NEG
35230: PUSH
35231: LD_INT 1
35233: NEG
35234: PUSH
35235: EMPTY
35236: LIST
35237: LIST
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: LIST
35243: LIST
35244: LIST
35245: LIST
35246: LIST
35247: LIST
35248: LIST
35249: LIST
35250: LIST
35251: LIST
35252: LIST
35253: LIST
35254: LIST
35255: LIST
35256: LIST
35257: LIST
35258: LIST
35259: LIST
35260: LIST
35261: LIST
35262: LIST
35263: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35264: LD_ADDR_VAR 0 35
35268: PUSH
35269: LD_INT 0
35271: PUSH
35272: LD_INT 0
35274: PUSH
35275: EMPTY
35276: LIST
35277: LIST
35278: PUSH
35279: LD_INT 0
35281: PUSH
35282: LD_INT 1
35284: NEG
35285: PUSH
35286: EMPTY
35287: LIST
35288: LIST
35289: PUSH
35290: LD_INT 1
35292: PUSH
35293: LD_INT 0
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: PUSH
35300: LD_INT 1
35302: PUSH
35303: LD_INT 1
35305: PUSH
35306: EMPTY
35307: LIST
35308: LIST
35309: PUSH
35310: LD_INT 0
35312: PUSH
35313: LD_INT 1
35315: PUSH
35316: EMPTY
35317: LIST
35318: LIST
35319: PUSH
35320: LD_INT 1
35322: NEG
35323: PUSH
35324: LD_INT 0
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 1
35333: NEG
35334: PUSH
35335: LD_INT 1
35337: NEG
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: PUSH
35343: LD_INT 2
35345: PUSH
35346: LD_INT 1
35348: PUSH
35349: EMPTY
35350: LIST
35351: LIST
35352: PUSH
35353: LD_INT 2
35355: NEG
35356: PUSH
35357: LD_INT 1
35359: NEG
35360: PUSH
35361: EMPTY
35362: LIST
35363: LIST
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: LIST
35369: LIST
35370: LIST
35371: LIST
35372: LIST
35373: LIST
35374: LIST
35375: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35376: LD_ADDR_VAR 0 36
35380: PUSH
35381: LD_INT 0
35383: PUSH
35384: LD_INT 0
35386: PUSH
35387: EMPTY
35388: LIST
35389: LIST
35390: PUSH
35391: LD_INT 0
35393: PUSH
35394: LD_INT 1
35396: NEG
35397: PUSH
35398: EMPTY
35399: LIST
35400: LIST
35401: PUSH
35402: LD_INT 1
35404: PUSH
35405: LD_INT 0
35407: PUSH
35408: EMPTY
35409: LIST
35410: LIST
35411: PUSH
35412: LD_INT 1
35414: PUSH
35415: LD_INT 1
35417: PUSH
35418: EMPTY
35419: LIST
35420: LIST
35421: PUSH
35422: LD_INT 0
35424: PUSH
35425: LD_INT 1
35427: PUSH
35428: EMPTY
35429: LIST
35430: LIST
35431: PUSH
35432: LD_INT 1
35434: NEG
35435: PUSH
35436: LD_INT 0
35438: PUSH
35439: EMPTY
35440: LIST
35441: LIST
35442: PUSH
35443: LD_INT 1
35445: NEG
35446: PUSH
35447: LD_INT 1
35449: NEG
35450: PUSH
35451: EMPTY
35452: LIST
35453: LIST
35454: PUSH
35455: LD_INT 1
35457: NEG
35458: PUSH
35459: LD_INT 2
35461: NEG
35462: PUSH
35463: EMPTY
35464: LIST
35465: LIST
35466: PUSH
35467: LD_INT 1
35469: PUSH
35470: LD_INT 2
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: EMPTY
35478: LIST
35479: LIST
35480: LIST
35481: LIST
35482: LIST
35483: LIST
35484: LIST
35485: LIST
35486: LIST
35487: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35488: LD_ADDR_VAR 0 37
35492: PUSH
35493: LD_INT 0
35495: PUSH
35496: LD_INT 0
35498: PUSH
35499: EMPTY
35500: LIST
35501: LIST
35502: PUSH
35503: LD_INT 0
35505: PUSH
35506: LD_INT 1
35508: NEG
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 1
35516: PUSH
35517: LD_INT 0
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 1
35526: PUSH
35527: LD_INT 1
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: PUSH
35534: LD_INT 0
35536: PUSH
35537: LD_INT 1
35539: PUSH
35540: EMPTY
35541: LIST
35542: LIST
35543: PUSH
35544: LD_INT 1
35546: NEG
35547: PUSH
35548: LD_INT 0
35550: PUSH
35551: EMPTY
35552: LIST
35553: LIST
35554: PUSH
35555: LD_INT 1
35557: NEG
35558: PUSH
35559: LD_INT 1
35561: NEG
35562: PUSH
35563: EMPTY
35564: LIST
35565: LIST
35566: PUSH
35567: LD_INT 1
35569: PUSH
35570: LD_INT 1
35572: NEG
35573: PUSH
35574: EMPTY
35575: LIST
35576: LIST
35577: PUSH
35578: LD_INT 1
35580: NEG
35581: PUSH
35582: LD_INT 1
35584: PUSH
35585: EMPTY
35586: LIST
35587: LIST
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: LIST
35593: LIST
35594: LIST
35595: LIST
35596: LIST
35597: LIST
35598: LIST
35599: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35600: LD_ADDR_VAR 0 38
35604: PUSH
35605: LD_INT 0
35607: PUSH
35608: LD_INT 0
35610: PUSH
35611: EMPTY
35612: LIST
35613: LIST
35614: PUSH
35615: LD_INT 0
35617: PUSH
35618: LD_INT 1
35620: NEG
35621: PUSH
35622: EMPTY
35623: LIST
35624: LIST
35625: PUSH
35626: LD_INT 1
35628: PUSH
35629: LD_INT 0
35631: PUSH
35632: EMPTY
35633: LIST
35634: LIST
35635: PUSH
35636: LD_INT 1
35638: PUSH
35639: LD_INT 1
35641: PUSH
35642: EMPTY
35643: LIST
35644: LIST
35645: PUSH
35646: LD_INT 0
35648: PUSH
35649: LD_INT 1
35651: PUSH
35652: EMPTY
35653: LIST
35654: LIST
35655: PUSH
35656: LD_INT 1
35658: NEG
35659: PUSH
35660: LD_INT 0
35662: PUSH
35663: EMPTY
35664: LIST
35665: LIST
35666: PUSH
35667: LD_INT 1
35669: NEG
35670: PUSH
35671: LD_INT 1
35673: NEG
35674: PUSH
35675: EMPTY
35676: LIST
35677: LIST
35678: PUSH
35679: LD_INT 2
35681: PUSH
35682: LD_INT 1
35684: PUSH
35685: EMPTY
35686: LIST
35687: LIST
35688: PUSH
35689: LD_INT 2
35691: NEG
35692: PUSH
35693: LD_INT 1
35695: NEG
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: LIST
35705: LIST
35706: LIST
35707: LIST
35708: LIST
35709: LIST
35710: LIST
35711: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35712: LD_ADDR_VAR 0 39
35716: PUSH
35717: LD_INT 0
35719: PUSH
35720: LD_INT 0
35722: PUSH
35723: EMPTY
35724: LIST
35725: LIST
35726: PUSH
35727: LD_INT 0
35729: PUSH
35730: LD_INT 1
35732: NEG
35733: PUSH
35734: EMPTY
35735: LIST
35736: LIST
35737: PUSH
35738: LD_INT 1
35740: PUSH
35741: LD_INT 0
35743: PUSH
35744: EMPTY
35745: LIST
35746: LIST
35747: PUSH
35748: LD_INT 1
35750: PUSH
35751: LD_INT 1
35753: PUSH
35754: EMPTY
35755: LIST
35756: LIST
35757: PUSH
35758: LD_INT 0
35760: PUSH
35761: LD_INT 1
35763: PUSH
35764: EMPTY
35765: LIST
35766: LIST
35767: PUSH
35768: LD_INT 1
35770: NEG
35771: PUSH
35772: LD_INT 0
35774: PUSH
35775: EMPTY
35776: LIST
35777: LIST
35778: PUSH
35779: LD_INT 1
35781: NEG
35782: PUSH
35783: LD_INT 1
35785: NEG
35786: PUSH
35787: EMPTY
35788: LIST
35789: LIST
35790: PUSH
35791: LD_INT 1
35793: NEG
35794: PUSH
35795: LD_INT 2
35797: NEG
35798: PUSH
35799: EMPTY
35800: LIST
35801: LIST
35802: PUSH
35803: LD_INT 1
35805: PUSH
35806: LD_INT 2
35808: PUSH
35809: EMPTY
35810: LIST
35811: LIST
35812: PUSH
35813: EMPTY
35814: LIST
35815: LIST
35816: LIST
35817: LIST
35818: LIST
35819: LIST
35820: LIST
35821: LIST
35822: LIST
35823: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35824: LD_ADDR_VAR 0 40
35828: PUSH
35829: LD_INT 0
35831: PUSH
35832: LD_INT 0
35834: PUSH
35835: EMPTY
35836: LIST
35837: LIST
35838: PUSH
35839: LD_INT 0
35841: PUSH
35842: LD_INT 1
35844: NEG
35845: PUSH
35846: EMPTY
35847: LIST
35848: LIST
35849: PUSH
35850: LD_INT 1
35852: PUSH
35853: LD_INT 0
35855: PUSH
35856: EMPTY
35857: LIST
35858: LIST
35859: PUSH
35860: LD_INT 1
35862: PUSH
35863: LD_INT 1
35865: PUSH
35866: EMPTY
35867: LIST
35868: LIST
35869: PUSH
35870: LD_INT 0
35872: PUSH
35873: LD_INT 1
35875: PUSH
35876: EMPTY
35877: LIST
35878: LIST
35879: PUSH
35880: LD_INT 1
35882: NEG
35883: PUSH
35884: LD_INT 0
35886: PUSH
35887: EMPTY
35888: LIST
35889: LIST
35890: PUSH
35891: LD_INT 1
35893: NEG
35894: PUSH
35895: LD_INT 1
35897: NEG
35898: PUSH
35899: EMPTY
35900: LIST
35901: LIST
35902: PUSH
35903: LD_INT 1
35905: PUSH
35906: LD_INT 1
35908: NEG
35909: PUSH
35910: EMPTY
35911: LIST
35912: LIST
35913: PUSH
35914: LD_INT 1
35916: NEG
35917: PUSH
35918: LD_INT 1
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: EMPTY
35926: LIST
35927: LIST
35928: LIST
35929: LIST
35930: LIST
35931: LIST
35932: LIST
35933: LIST
35934: LIST
35935: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35936: LD_ADDR_VAR 0 41
35940: PUSH
35941: LD_INT 0
35943: PUSH
35944: LD_INT 0
35946: PUSH
35947: EMPTY
35948: LIST
35949: LIST
35950: PUSH
35951: LD_INT 0
35953: PUSH
35954: LD_INT 1
35956: NEG
35957: PUSH
35958: EMPTY
35959: LIST
35960: LIST
35961: PUSH
35962: LD_INT 1
35964: PUSH
35965: LD_INT 0
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: LD_INT 1
35974: PUSH
35975: LD_INT 1
35977: PUSH
35978: EMPTY
35979: LIST
35980: LIST
35981: PUSH
35982: LD_INT 0
35984: PUSH
35985: LD_INT 1
35987: PUSH
35988: EMPTY
35989: LIST
35990: LIST
35991: PUSH
35992: LD_INT 1
35994: NEG
35995: PUSH
35996: LD_INT 0
35998: PUSH
35999: EMPTY
36000: LIST
36001: LIST
36002: PUSH
36003: LD_INT 1
36005: NEG
36006: PUSH
36007: LD_INT 1
36009: NEG
36010: PUSH
36011: EMPTY
36012: LIST
36013: LIST
36014: PUSH
36015: LD_INT 1
36017: NEG
36018: PUSH
36019: LD_INT 2
36021: NEG
36022: PUSH
36023: EMPTY
36024: LIST
36025: LIST
36026: PUSH
36027: LD_INT 1
36029: PUSH
36030: LD_INT 1
36032: NEG
36033: PUSH
36034: EMPTY
36035: LIST
36036: LIST
36037: PUSH
36038: LD_INT 2
36040: PUSH
36041: LD_INT 0
36043: PUSH
36044: EMPTY
36045: LIST
36046: LIST
36047: PUSH
36048: LD_INT 2
36050: PUSH
36051: LD_INT 1
36053: PUSH
36054: EMPTY
36055: LIST
36056: LIST
36057: PUSH
36058: LD_INT 2
36060: PUSH
36061: LD_INT 2
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: LD_INT 1
36070: PUSH
36071: LD_INT 2
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: PUSH
36078: LD_INT 1
36080: NEG
36081: PUSH
36082: LD_INT 1
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: LD_INT 2
36091: NEG
36092: PUSH
36093: LD_INT 0
36095: PUSH
36096: EMPTY
36097: LIST
36098: LIST
36099: PUSH
36100: LD_INT 2
36102: NEG
36103: PUSH
36104: LD_INT 1
36106: NEG
36107: PUSH
36108: EMPTY
36109: LIST
36110: LIST
36111: PUSH
36112: LD_INT 2
36114: NEG
36115: PUSH
36116: LD_INT 2
36118: NEG
36119: PUSH
36120: EMPTY
36121: LIST
36122: LIST
36123: PUSH
36124: LD_INT 2
36126: NEG
36127: PUSH
36128: LD_INT 3
36130: NEG
36131: PUSH
36132: EMPTY
36133: LIST
36134: LIST
36135: PUSH
36136: LD_INT 2
36138: PUSH
36139: LD_INT 1
36141: NEG
36142: PUSH
36143: EMPTY
36144: LIST
36145: LIST
36146: PUSH
36147: LD_INT 3
36149: PUSH
36150: LD_INT 0
36152: PUSH
36153: EMPTY
36154: LIST
36155: LIST
36156: PUSH
36157: LD_INT 3
36159: PUSH
36160: LD_INT 1
36162: PUSH
36163: EMPTY
36164: LIST
36165: LIST
36166: PUSH
36167: LD_INT 3
36169: PUSH
36170: LD_INT 2
36172: PUSH
36173: EMPTY
36174: LIST
36175: LIST
36176: PUSH
36177: LD_INT 3
36179: PUSH
36180: LD_INT 3
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 2
36189: PUSH
36190: LD_INT 3
36192: PUSH
36193: EMPTY
36194: LIST
36195: LIST
36196: PUSH
36197: LD_INT 2
36199: NEG
36200: PUSH
36201: LD_INT 1
36203: PUSH
36204: EMPTY
36205: LIST
36206: LIST
36207: PUSH
36208: LD_INT 3
36210: NEG
36211: PUSH
36212: LD_INT 0
36214: PUSH
36215: EMPTY
36216: LIST
36217: LIST
36218: PUSH
36219: LD_INT 3
36221: NEG
36222: PUSH
36223: LD_INT 1
36225: NEG
36226: PUSH
36227: EMPTY
36228: LIST
36229: LIST
36230: PUSH
36231: LD_INT 3
36233: NEG
36234: PUSH
36235: LD_INT 2
36237: NEG
36238: PUSH
36239: EMPTY
36240: LIST
36241: LIST
36242: PUSH
36243: LD_INT 3
36245: NEG
36246: PUSH
36247: LD_INT 3
36249: NEG
36250: PUSH
36251: EMPTY
36252: LIST
36253: LIST
36254: PUSH
36255: EMPTY
36256: LIST
36257: LIST
36258: LIST
36259: LIST
36260: LIST
36261: LIST
36262: LIST
36263: LIST
36264: LIST
36265: LIST
36266: LIST
36267: LIST
36268: LIST
36269: LIST
36270: LIST
36271: LIST
36272: LIST
36273: LIST
36274: LIST
36275: LIST
36276: LIST
36277: LIST
36278: LIST
36279: LIST
36280: LIST
36281: LIST
36282: LIST
36283: LIST
36284: LIST
36285: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36286: LD_ADDR_VAR 0 42
36290: PUSH
36291: LD_INT 0
36293: PUSH
36294: LD_INT 0
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: LD_INT 0
36303: PUSH
36304: LD_INT 1
36306: NEG
36307: PUSH
36308: EMPTY
36309: LIST
36310: LIST
36311: PUSH
36312: LD_INT 1
36314: PUSH
36315: LD_INT 0
36317: PUSH
36318: EMPTY
36319: LIST
36320: LIST
36321: PUSH
36322: LD_INT 1
36324: PUSH
36325: LD_INT 1
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PUSH
36332: LD_INT 0
36334: PUSH
36335: LD_INT 1
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: PUSH
36342: LD_INT 1
36344: NEG
36345: PUSH
36346: LD_INT 0
36348: PUSH
36349: EMPTY
36350: LIST
36351: LIST
36352: PUSH
36353: LD_INT 1
36355: NEG
36356: PUSH
36357: LD_INT 1
36359: NEG
36360: PUSH
36361: EMPTY
36362: LIST
36363: LIST
36364: PUSH
36365: LD_INT 1
36367: NEG
36368: PUSH
36369: LD_INT 2
36371: NEG
36372: PUSH
36373: EMPTY
36374: LIST
36375: LIST
36376: PUSH
36377: LD_INT 0
36379: PUSH
36380: LD_INT 2
36382: NEG
36383: PUSH
36384: EMPTY
36385: LIST
36386: LIST
36387: PUSH
36388: LD_INT 1
36390: PUSH
36391: LD_INT 1
36393: NEG
36394: PUSH
36395: EMPTY
36396: LIST
36397: LIST
36398: PUSH
36399: LD_INT 2
36401: PUSH
36402: LD_INT 1
36404: PUSH
36405: EMPTY
36406: LIST
36407: LIST
36408: PUSH
36409: LD_INT 2
36411: PUSH
36412: LD_INT 2
36414: PUSH
36415: EMPTY
36416: LIST
36417: LIST
36418: PUSH
36419: LD_INT 1
36421: PUSH
36422: LD_INT 2
36424: PUSH
36425: EMPTY
36426: LIST
36427: LIST
36428: PUSH
36429: LD_INT 0
36431: PUSH
36432: LD_INT 2
36434: PUSH
36435: EMPTY
36436: LIST
36437: LIST
36438: PUSH
36439: LD_INT 1
36441: NEG
36442: PUSH
36443: LD_INT 1
36445: PUSH
36446: EMPTY
36447: LIST
36448: LIST
36449: PUSH
36450: LD_INT 2
36452: NEG
36453: PUSH
36454: LD_INT 1
36456: NEG
36457: PUSH
36458: EMPTY
36459: LIST
36460: LIST
36461: PUSH
36462: LD_INT 2
36464: NEG
36465: PUSH
36466: LD_INT 2
36468: NEG
36469: PUSH
36470: EMPTY
36471: LIST
36472: LIST
36473: PUSH
36474: LD_INT 2
36476: NEG
36477: PUSH
36478: LD_INT 3
36480: NEG
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: PUSH
36486: LD_INT 1
36488: NEG
36489: PUSH
36490: LD_INT 3
36492: NEG
36493: PUSH
36494: EMPTY
36495: LIST
36496: LIST
36497: PUSH
36498: LD_INT 0
36500: PUSH
36501: LD_INT 3
36503: NEG
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: PUSH
36509: LD_INT 1
36511: PUSH
36512: LD_INT 2
36514: NEG
36515: PUSH
36516: EMPTY
36517: LIST
36518: LIST
36519: PUSH
36520: LD_INT 3
36522: PUSH
36523: LD_INT 2
36525: PUSH
36526: EMPTY
36527: LIST
36528: LIST
36529: PUSH
36530: LD_INT 3
36532: PUSH
36533: LD_INT 3
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PUSH
36540: LD_INT 2
36542: PUSH
36543: LD_INT 3
36545: PUSH
36546: EMPTY
36547: LIST
36548: LIST
36549: PUSH
36550: LD_INT 1
36552: PUSH
36553: LD_INT 3
36555: PUSH
36556: EMPTY
36557: LIST
36558: LIST
36559: PUSH
36560: LD_INT 0
36562: PUSH
36563: LD_INT 3
36565: PUSH
36566: EMPTY
36567: LIST
36568: LIST
36569: PUSH
36570: LD_INT 1
36572: NEG
36573: PUSH
36574: LD_INT 2
36576: PUSH
36577: EMPTY
36578: LIST
36579: LIST
36580: PUSH
36581: LD_INT 3
36583: NEG
36584: PUSH
36585: LD_INT 2
36587: NEG
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 3
36595: NEG
36596: PUSH
36597: LD_INT 3
36599: NEG
36600: PUSH
36601: EMPTY
36602: LIST
36603: LIST
36604: PUSH
36605: EMPTY
36606: LIST
36607: LIST
36608: LIST
36609: LIST
36610: LIST
36611: LIST
36612: LIST
36613: LIST
36614: LIST
36615: LIST
36616: LIST
36617: LIST
36618: LIST
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: LIST
36624: LIST
36625: LIST
36626: LIST
36627: LIST
36628: LIST
36629: LIST
36630: LIST
36631: LIST
36632: LIST
36633: LIST
36634: LIST
36635: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36636: LD_ADDR_VAR 0 43
36640: PUSH
36641: LD_INT 0
36643: PUSH
36644: LD_INT 0
36646: PUSH
36647: EMPTY
36648: LIST
36649: LIST
36650: PUSH
36651: LD_INT 0
36653: PUSH
36654: LD_INT 1
36656: NEG
36657: PUSH
36658: EMPTY
36659: LIST
36660: LIST
36661: PUSH
36662: LD_INT 1
36664: PUSH
36665: LD_INT 0
36667: PUSH
36668: EMPTY
36669: LIST
36670: LIST
36671: PUSH
36672: LD_INT 1
36674: PUSH
36675: LD_INT 1
36677: PUSH
36678: EMPTY
36679: LIST
36680: LIST
36681: PUSH
36682: LD_INT 0
36684: PUSH
36685: LD_INT 1
36687: PUSH
36688: EMPTY
36689: LIST
36690: LIST
36691: PUSH
36692: LD_INT 1
36694: NEG
36695: PUSH
36696: LD_INT 0
36698: PUSH
36699: EMPTY
36700: LIST
36701: LIST
36702: PUSH
36703: LD_INT 1
36705: NEG
36706: PUSH
36707: LD_INT 1
36709: NEG
36710: PUSH
36711: EMPTY
36712: LIST
36713: LIST
36714: PUSH
36715: LD_INT 1
36717: NEG
36718: PUSH
36719: LD_INT 2
36721: NEG
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 0
36729: PUSH
36730: LD_INT 2
36732: NEG
36733: PUSH
36734: EMPTY
36735: LIST
36736: LIST
36737: PUSH
36738: LD_INT 1
36740: PUSH
36741: LD_INT 1
36743: NEG
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PUSH
36749: LD_INT 2
36751: PUSH
36752: LD_INT 0
36754: PUSH
36755: EMPTY
36756: LIST
36757: LIST
36758: PUSH
36759: LD_INT 2
36761: PUSH
36762: LD_INT 1
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PUSH
36769: LD_INT 1
36771: PUSH
36772: LD_INT 2
36774: PUSH
36775: EMPTY
36776: LIST
36777: LIST
36778: PUSH
36779: LD_INT 0
36781: PUSH
36782: LD_INT 2
36784: PUSH
36785: EMPTY
36786: LIST
36787: LIST
36788: PUSH
36789: LD_INT 1
36791: NEG
36792: PUSH
36793: LD_INT 1
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: PUSH
36800: LD_INT 2
36802: NEG
36803: PUSH
36804: LD_INT 0
36806: PUSH
36807: EMPTY
36808: LIST
36809: LIST
36810: PUSH
36811: LD_INT 2
36813: NEG
36814: PUSH
36815: LD_INT 1
36817: NEG
36818: PUSH
36819: EMPTY
36820: LIST
36821: LIST
36822: PUSH
36823: LD_INT 1
36825: NEG
36826: PUSH
36827: LD_INT 3
36829: NEG
36830: PUSH
36831: EMPTY
36832: LIST
36833: LIST
36834: PUSH
36835: LD_INT 0
36837: PUSH
36838: LD_INT 3
36840: NEG
36841: PUSH
36842: EMPTY
36843: LIST
36844: LIST
36845: PUSH
36846: LD_INT 1
36848: PUSH
36849: LD_INT 2
36851: NEG
36852: PUSH
36853: EMPTY
36854: LIST
36855: LIST
36856: PUSH
36857: LD_INT 2
36859: PUSH
36860: LD_INT 1
36862: NEG
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: LD_INT 3
36870: PUSH
36871: LD_INT 0
36873: PUSH
36874: EMPTY
36875: LIST
36876: LIST
36877: PUSH
36878: LD_INT 3
36880: PUSH
36881: LD_INT 1
36883: PUSH
36884: EMPTY
36885: LIST
36886: LIST
36887: PUSH
36888: LD_INT 1
36890: PUSH
36891: LD_INT 3
36893: PUSH
36894: EMPTY
36895: LIST
36896: LIST
36897: PUSH
36898: LD_INT 0
36900: PUSH
36901: LD_INT 3
36903: PUSH
36904: EMPTY
36905: LIST
36906: LIST
36907: PUSH
36908: LD_INT 1
36910: NEG
36911: PUSH
36912: LD_INT 2
36914: PUSH
36915: EMPTY
36916: LIST
36917: LIST
36918: PUSH
36919: LD_INT 2
36921: NEG
36922: PUSH
36923: LD_INT 1
36925: PUSH
36926: EMPTY
36927: LIST
36928: LIST
36929: PUSH
36930: LD_INT 3
36932: NEG
36933: PUSH
36934: LD_INT 0
36936: PUSH
36937: EMPTY
36938: LIST
36939: LIST
36940: PUSH
36941: LD_INT 3
36943: NEG
36944: PUSH
36945: LD_INT 1
36947: NEG
36948: PUSH
36949: EMPTY
36950: LIST
36951: LIST
36952: PUSH
36953: EMPTY
36954: LIST
36955: LIST
36956: LIST
36957: LIST
36958: LIST
36959: LIST
36960: LIST
36961: LIST
36962: LIST
36963: LIST
36964: LIST
36965: LIST
36966: LIST
36967: LIST
36968: LIST
36969: LIST
36970: LIST
36971: LIST
36972: LIST
36973: LIST
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: LIST
36979: LIST
36980: LIST
36981: LIST
36982: LIST
36983: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36984: LD_ADDR_VAR 0 44
36988: PUSH
36989: LD_INT 0
36991: PUSH
36992: LD_INT 0
36994: PUSH
36995: EMPTY
36996: LIST
36997: LIST
36998: PUSH
36999: LD_INT 0
37001: PUSH
37002: LD_INT 1
37004: NEG
37005: PUSH
37006: EMPTY
37007: LIST
37008: LIST
37009: PUSH
37010: LD_INT 1
37012: PUSH
37013: LD_INT 0
37015: PUSH
37016: EMPTY
37017: LIST
37018: LIST
37019: PUSH
37020: LD_INT 1
37022: PUSH
37023: LD_INT 1
37025: PUSH
37026: EMPTY
37027: LIST
37028: LIST
37029: PUSH
37030: LD_INT 0
37032: PUSH
37033: LD_INT 1
37035: PUSH
37036: EMPTY
37037: LIST
37038: LIST
37039: PUSH
37040: LD_INT 1
37042: NEG
37043: PUSH
37044: LD_INT 0
37046: PUSH
37047: EMPTY
37048: LIST
37049: LIST
37050: PUSH
37051: LD_INT 1
37053: NEG
37054: PUSH
37055: LD_INT 1
37057: NEG
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: PUSH
37063: LD_INT 1
37065: NEG
37066: PUSH
37067: LD_INT 2
37069: NEG
37070: PUSH
37071: EMPTY
37072: LIST
37073: LIST
37074: PUSH
37075: LD_INT 1
37077: PUSH
37078: LD_INT 1
37080: NEG
37081: PUSH
37082: EMPTY
37083: LIST
37084: LIST
37085: PUSH
37086: LD_INT 2
37088: PUSH
37089: LD_INT 0
37091: PUSH
37092: EMPTY
37093: LIST
37094: LIST
37095: PUSH
37096: LD_INT 2
37098: PUSH
37099: LD_INT 1
37101: PUSH
37102: EMPTY
37103: LIST
37104: LIST
37105: PUSH
37106: LD_INT 2
37108: PUSH
37109: LD_INT 2
37111: PUSH
37112: EMPTY
37113: LIST
37114: LIST
37115: PUSH
37116: LD_INT 1
37118: PUSH
37119: LD_INT 2
37121: PUSH
37122: EMPTY
37123: LIST
37124: LIST
37125: PUSH
37126: LD_INT 1
37128: NEG
37129: PUSH
37130: LD_INT 1
37132: PUSH
37133: EMPTY
37134: LIST
37135: LIST
37136: PUSH
37137: LD_INT 2
37139: NEG
37140: PUSH
37141: LD_INT 0
37143: PUSH
37144: EMPTY
37145: LIST
37146: LIST
37147: PUSH
37148: LD_INT 2
37150: NEG
37151: PUSH
37152: LD_INT 1
37154: NEG
37155: PUSH
37156: EMPTY
37157: LIST
37158: LIST
37159: PUSH
37160: LD_INT 2
37162: NEG
37163: PUSH
37164: LD_INT 2
37166: NEG
37167: PUSH
37168: EMPTY
37169: LIST
37170: LIST
37171: PUSH
37172: LD_INT 2
37174: NEG
37175: PUSH
37176: LD_INT 3
37178: NEG
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: LD_INT 2
37186: PUSH
37187: LD_INT 1
37189: NEG
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: LD_INT 3
37197: PUSH
37198: LD_INT 0
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: LD_INT 3
37207: PUSH
37208: LD_INT 1
37210: PUSH
37211: EMPTY
37212: LIST
37213: LIST
37214: PUSH
37215: LD_INT 3
37217: PUSH
37218: LD_INT 2
37220: PUSH
37221: EMPTY
37222: LIST
37223: LIST
37224: PUSH
37225: LD_INT 3
37227: PUSH
37228: LD_INT 3
37230: PUSH
37231: EMPTY
37232: LIST
37233: LIST
37234: PUSH
37235: LD_INT 2
37237: PUSH
37238: LD_INT 3
37240: PUSH
37241: EMPTY
37242: LIST
37243: LIST
37244: PUSH
37245: LD_INT 2
37247: NEG
37248: PUSH
37249: LD_INT 1
37251: PUSH
37252: EMPTY
37253: LIST
37254: LIST
37255: PUSH
37256: LD_INT 3
37258: NEG
37259: PUSH
37260: LD_INT 0
37262: PUSH
37263: EMPTY
37264: LIST
37265: LIST
37266: PUSH
37267: LD_INT 3
37269: NEG
37270: PUSH
37271: LD_INT 1
37273: NEG
37274: PUSH
37275: EMPTY
37276: LIST
37277: LIST
37278: PUSH
37279: LD_INT 3
37281: NEG
37282: PUSH
37283: LD_INT 2
37285: NEG
37286: PUSH
37287: EMPTY
37288: LIST
37289: LIST
37290: PUSH
37291: LD_INT 3
37293: NEG
37294: PUSH
37295: LD_INT 3
37297: NEG
37298: PUSH
37299: EMPTY
37300: LIST
37301: LIST
37302: PUSH
37303: EMPTY
37304: LIST
37305: LIST
37306: LIST
37307: LIST
37308: LIST
37309: LIST
37310: LIST
37311: LIST
37312: LIST
37313: LIST
37314: LIST
37315: LIST
37316: LIST
37317: LIST
37318: LIST
37319: LIST
37320: LIST
37321: LIST
37322: LIST
37323: LIST
37324: LIST
37325: LIST
37326: LIST
37327: LIST
37328: LIST
37329: LIST
37330: LIST
37331: LIST
37332: LIST
37333: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37334: LD_ADDR_VAR 0 45
37338: PUSH
37339: LD_INT 0
37341: PUSH
37342: LD_INT 0
37344: PUSH
37345: EMPTY
37346: LIST
37347: LIST
37348: PUSH
37349: LD_INT 0
37351: PUSH
37352: LD_INT 1
37354: NEG
37355: PUSH
37356: EMPTY
37357: LIST
37358: LIST
37359: PUSH
37360: LD_INT 1
37362: PUSH
37363: LD_INT 0
37365: PUSH
37366: EMPTY
37367: LIST
37368: LIST
37369: PUSH
37370: LD_INT 1
37372: PUSH
37373: LD_INT 1
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: PUSH
37380: LD_INT 0
37382: PUSH
37383: LD_INT 1
37385: PUSH
37386: EMPTY
37387: LIST
37388: LIST
37389: PUSH
37390: LD_INT 1
37392: NEG
37393: PUSH
37394: LD_INT 0
37396: PUSH
37397: EMPTY
37398: LIST
37399: LIST
37400: PUSH
37401: LD_INT 1
37403: NEG
37404: PUSH
37405: LD_INT 1
37407: NEG
37408: PUSH
37409: EMPTY
37410: LIST
37411: LIST
37412: PUSH
37413: LD_INT 1
37415: NEG
37416: PUSH
37417: LD_INT 2
37419: NEG
37420: PUSH
37421: EMPTY
37422: LIST
37423: LIST
37424: PUSH
37425: LD_INT 0
37427: PUSH
37428: LD_INT 2
37430: NEG
37431: PUSH
37432: EMPTY
37433: LIST
37434: LIST
37435: PUSH
37436: LD_INT 1
37438: PUSH
37439: LD_INT 1
37441: NEG
37442: PUSH
37443: EMPTY
37444: LIST
37445: LIST
37446: PUSH
37447: LD_INT 2
37449: PUSH
37450: LD_INT 1
37452: PUSH
37453: EMPTY
37454: LIST
37455: LIST
37456: PUSH
37457: LD_INT 2
37459: PUSH
37460: LD_INT 2
37462: PUSH
37463: EMPTY
37464: LIST
37465: LIST
37466: PUSH
37467: LD_INT 1
37469: PUSH
37470: LD_INT 2
37472: PUSH
37473: EMPTY
37474: LIST
37475: LIST
37476: PUSH
37477: LD_INT 0
37479: PUSH
37480: LD_INT 2
37482: PUSH
37483: EMPTY
37484: LIST
37485: LIST
37486: PUSH
37487: LD_INT 1
37489: NEG
37490: PUSH
37491: LD_INT 1
37493: PUSH
37494: EMPTY
37495: LIST
37496: LIST
37497: PUSH
37498: LD_INT 2
37500: NEG
37501: PUSH
37502: LD_INT 1
37504: NEG
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 2
37512: NEG
37513: PUSH
37514: LD_INT 2
37516: NEG
37517: PUSH
37518: EMPTY
37519: LIST
37520: LIST
37521: PUSH
37522: LD_INT 2
37524: NEG
37525: PUSH
37526: LD_INT 3
37528: NEG
37529: PUSH
37530: EMPTY
37531: LIST
37532: LIST
37533: PUSH
37534: LD_INT 1
37536: NEG
37537: PUSH
37538: LD_INT 3
37540: NEG
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: PUSH
37546: LD_INT 0
37548: PUSH
37549: LD_INT 3
37551: NEG
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 1
37559: PUSH
37560: LD_INT 2
37562: NEG
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 3
37570: PUSH
37571: LD_INT 2
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: LD_INT 3
37580: PUSH
37581: LD_INT 3
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: PUSH
37588: LD_INT 2
37590: PUSH
37591: LD_INT 3
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: PUSH
37598: LD_INT 1
37600: PUSH
37601: LD_INT 3
37603: PUSH
37604: EMPTY
37605: LIST
37606: LIST
37607: PUSH
37608: LD_INT 0
37610: PUSH
37611: LD_INT 3
37613: PUSH
37614: EMPTY
37615: LIST
37616: LIST
37617: PUSH
37618: LD_INT 1
37620: NEG
37621: PUSH
37622: LD_INT 2
37624: PUSH
37625: EMPTY
37626: LIST
37627: LIST
37628: PUSH
37629: LD_INT 3
37631: NEG
37632: PUSH
37633: LD_INT 2
37635: NEG
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: LD_INT 3
37643: NEG
37644: PUSH
37645: LD_INT 3
37647: NEG
37648: PUSH
37649: EMPTY
37650: LIST
37651: LIST
37652: PUSH
37653: EMPTY
37654: LIST
37655: LIST
37656: LIST
37657: LIST
37658: LIST
37659: LIST
37660: LIST
37661: LIST
37662: LIST
37663: LIST
37664: LIST
37665: LIST
37666: LIST
37667: LIST
37668: LIST
37669: LIST
37670: LIST
37671: LIST
37672: LIST
37673: LIST
37674: LIST
37675: LIST
37676: LIST
37677: LIST
37678: LIST
37679: LIST
37680: LIST
37681: LIST
37682: LIST
37683: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37684: LD_ADDR_VAR 0 46
37688: PUSH
37689: LD_INT 0
37691: PUSH
37692: LD_INT 0
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PUSH
37699: LD_INT 0
37701: PUSH
37702: LD_INT 1
37704: NEG
37705: PUSH
37706: EMPTY
37707: LIST
37708: LIST
37709: PUSH
37710: LD_INT 1
37712: PUSH
37713: LD_INT 0
37715: PUSH
37716: EMPTY
37717: LIST
37718: LIST
37719: PUSH
37720: LD_INT 1
37722: PUSH
37723: LD_INT 1
37725: PUSH
37726: EMPTY
37727: LIST
37728: LIST
37729: PUSH
37730: LD_INT 0
37732: PUSH
37733: LD_INT 1
37735: PUSH
37736: EMPTY
37737: LIST
37738: LIST
37739: PUSH
37740: LD_INT 1
37742: NEG
37743: PUSH
37744: LD_INT 0
37746: PUSH
37747: EMPTY
37748: LIST
37749: LIST
37750: PUSH
37751: LD_INT 1
37753: NEG
37754: PUSH
37755: LD_INT 1
37757: NEG
37758: PUSH
37759: EMPTY
37760: LIST
37761: LIST
37762: PUSH
37763: LD_INT 1
37765: NEG
37766: PUSH
37767: LD_INT 2
37769: NEG
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 0
37777: PUSH
37778: LD_INT 2
37780: NEG
37781: PUSH
37782: EMPTY
37783: LIST
37784: LIST
37785: PUSH
37786: LD_INT 1
37788: PUSH
37789: LD_INT 1
37791: NEG
37792: PUSH
37793: EMPTY
37794: LIST
37795: LIST
37796: PUSH
37797: LD_INT 2
37799: PUSH
37800: LD_INT 0
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: LD_INT 2
37809: PUSH
37810: LD_INT 1
37812: PUSH
37813: EMPTY
37814: LIST
37815: LIST
37816: PUSH
37817: LD_INT 1
37819: PUSH
37820: LD_INT 2
37822: PUSH
37823: EMPTY
37824: LIST
37825: LIST
37826: PUSH
37827: LD_INT 0
37829: PUSH
37830: LD_INT 2
37832: PUSH
37833: EMPTY
37834: LIST
37835: LIST
37836: PUSH
37837: LD_INT 1
37839: NEG
37840: PUSH
37841: LD_INT 1
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: PUSH
37848: LD_INT 2
37850: NEG
37851: PUSH
37852: LD_INT 0
37854: PUSH
37855: EMPTY
37856: LIST
37857: LIST
37858: PUSH
37859: LD_INT 2
37861: NEG
37862: PUSH
37863: LD_INT 1
37865: NEG
37866: PUSH
37867: EMPTY
37868: LIST
37869: LIST
37870: PUSH
37871: LD_INT 1
37873: NEG
37874: PUSH
37875: LD_INT 3
37877: NEG
37878: PUSH
37879: EMPTY
37880: LIST
37881: LIST
37882: PUSH
37883: LD_INT 0
37885: PUSH
37886: LD_INT 3
37888: NEG
37889: PUSH
37890: EMPTY
37891: LIST
37892: LIST
37893: PUSH
37894: LD_INT 1
37896: PUSH
37897: LD_INT 2
37899: NEG
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: LD_INT 2
37907: PUSH
37908: LD_INT 1
37910: NEG
37911: PUSH
37912: EMPTY
37913: LIST
37914: LIST
37915: PUSH
37916: LD_INT 3
37918: PUSH
37919: LD_INT 0
37921: PUSH
37922: EMPTY
37923: LIST
37924: LIST
37925: PUSH
37926: LD_INT 3
37928: PUSH
37929: LD_INT 1
37931: PUSH
37932: EMPTY
37933: LIST
37934: LIST
37935: PUSH
37936: LD_INT 1
37938: PUSH
37939: LD_INT 3
37941: PUSH
37942: EMPTY
37943: LIST
37944: LIST
37945: PUSH
37946: LD_INT 0
37948: PUSH
37949: LD_INT 3
37951: PUSH
37952: EMPTY
37953: LIST
37954: LIST
37955: PUSH
37956: LD_INT 1
37958: NEG
37959: PUSH
37960: LD_INT 2
37962: PUSH
37963: EMPTY
37964: LIST
37965: LIST
37966: PUSH
37967: LD_INT 2
37969: NEG
37970: PUSH
37971: LD_INT 1
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: LD_INT 3
37980: NEG
37981: PUSH
37982: LD_INT 0
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: LD_INT 3
37991: NEG
37992: PUSH
37993: LD_INT 1
37995: NEG
37996: PUSH
37997: EMPTY
37998: LIST
37999: LIST
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: LIST
38005: LIST
38006: LIST
38007: LIST
38008: LIST
38009: LIST
38010: LIST
38011: LIST
38012: LIST
38013: LIST
38014: LIST
38015: LIST
38016: LIST
38017: LIST
38018: LIST
38019: LIST
38020: LIST
38021: LIST
38022: LIST
38023: LIST
38024: LIST
38025: LIST
38026: LIST
38027: LIST
38028: LIST
38029: LIST
38030: LIST
38031: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38032: LD_ADDR_VAR 0 47
38036: PUSH
38037: LD_INT 0
38039: PUSH
38040: LD_INT 0
38042: PUSH
38043: EMPTY
38044: LIST
38045: LIST
38046: PUSH
38047: LD_INT 0
38049: PUSH
38050: LD_INT 1
38052: NEG
38053: PUSH
38054: EMPTY
38055: LIST
38056: LIST
38057: PUSH
38058: LD_INT 1
38060: PUSH
38061: LD_INT 0
38063: PUSH
38064: EMPTY
38065: LIST
38066: LIST
38067: PUSH
38068: LD_INT 1
38070: PUSH
38071: LD_INT 1
38073: PUSH
38074: EMPTY
38075: LIST
38076: LIST
38077: PUSH
38078: LD_INT 0
38080: PUSH
38081: LD_INT 1
38083: PUSH
38084: EMPTY
38085: LIST
38086: LIST
38087: PUSH
38088: LD_INT 1
38090: NEG
38091: PUSH
38092: LD_INT 0
38094: PUSH
38095: EMPTY
38096: LIST
38097: LIST
38098: PUSH
38099: LD_INT 1
38101: NEG
38102: PUSH
38103: LD_INT 1
38105: NEG
38106: PUSH
38107: EMPTY
38108: LIST
38109: LIST
38110: PUSH
38111: LD_INT 1
38113: NEG
38114: PUSH
38115: LD_INT 2
38117: NEG
38118: PUSH
38119: EMPTY
38120: LIST
38121: LIST
38122: PUSH
38123: LD_INT 0
38125: PUSH
38126: LD_INT 2
38128: NEG
38129: PUSH
38130: EMPTY
38131: LIST
38132: LIST
38133: PUSH
38134: LD_INT 1
38136: PUSH
38137: LD_INT 1
38139: NEG
38140: PUSH
38141: EMPTY
38142: LIST
38143: LIST
38144: PUSH
38145: LD_INT 2
38147: NEG
38148: PUSH
38149: LD_INT 1
38151: NEG
38152: PUSH
38153: EMPTY
38154: LIST
38155: LIST
38156: PUSH
38157: LD_INT 2
38159: NEG
38160: PUSH
38161: LD_INT 2
38163: NEG
38164: PUSH
38165: EMPTY
38166: LIST
38167: LIST
38168: PUSH
38169: EMPTY
38170: LIST
38171: LIST
38172: LIST
38173: LIST
38174: LIST
38175: LIST
38176: LIST
38177: LIST
38178: LIST
38179: LIST
38180: LIST
38181: LIST
38182: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38183: LD_ADDR_VAR 0 48
38187: PUSH
38188: LD_INT 0
38190: PUSH
38191: LD_INT 0
38193: PUSH
38194: EMPTY
38195: LIST
38196: LIST
38197: PUSH
38198: LD_INT 0
38200: PUSH
38201: LD_INT 1
38203: NEG
38204: PUSH
38205: EMPTY
38206: LIST
38207: LIST
38208: PUSH
38209: LD_INT 1
38211: PUSH
38212: LD_INT 0
38214: PUSH
38215: EMPTY
38216: LIST
38217: LIST
38218: PUSH
38219: LD_INT 1
38221: PUSH
38222: LD_INT 1
38224: PUSH
38225: EMPTY
38226: LIST
38227: LIST
38228: PUSH
38229: LD_INT 0
38231: PUSH
38232: LD_INT 1
38234: PUSH
38235: EMPTY
38236: LIST
38237: LIST
38238: PUSH
38239: LD_INT 1
38241: NEG
38242: PUSH
38243: LD_INT 0
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: LD_INT 1
38252: NEG
38253: PUSH
38254: LD_INT 1
38256: NEG
38257: PUSH
38258: EMPTY
38259: LIST
38260: LIST
38261: PUSH
38262: LD_INT 1
38264: NEG
38265: PUSH
38266: LD_INT 2
38268: NEG
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PUSH
38274: LD_INT 0
38276: PUSH
38277: LD_INT 2
38279: NEG
38280: PUSH
38281: EMPTY
38282: LIST
38283: LIST
38284: PUSH
38285: LD_INT 1
38287: PUSH
38288: LD_INT 1
38290: NEG
38291: PUSH
38292: EMPTY
38293: LIST
38294: LIST
38295: PUSH
38296: LD_INT 2
38298: PUSH
38299: LD_INT 0
38301: PUSH
38302: EMPTY
38303: LIST
38304: LIST
38305: PUSH
38306: LD_INT 2
38308: PUSH
38309: LD_INT 1
38311: PUSH
38312: EMPTY
38313: LIST
38314: LIST
38315: PUSH
38316: EMPTY
38317: LIST
38318: LIST
38319: LIST
38320: LIST
38321: LIST
38322: LIST
38323: LIST
38324: LIST
38325: LIST
38326: LIST
38327: LIST
38328: LIST
38329: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38330: LD_ADDR_VAR 0 49
38334: PUSH
38335: LD_INT 0
38337: PUSH
38338: LD_INT 0
38340: PUSH
38341: EMPTY
38342: LIST
38343: LIST
38344: PUSH
38345: LD_INT 0
38347: PUSH
38348: LD_INT 1
38350: NEG
38351: PUSH
38352: EMPTY
38353: LIST
38354: LIST
38355: PUSH
38356: LD_INT 1
38358: PUSH
38359: LD_INT 0
38361: PUSH
38362: EMPTY
38363: LIST
38364: LIST
38365: PUSH
38366: LD_INT 1
38368: PUSH
38369: LD_INT 1
38371: PUSH
38372: EMPTY
38373: LIST
38374: LIST
38375: PUSH
38376: LD_INT 0
38378: PUSH
38379: LD_INT 1
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: PUSH
38386: LD_INT 1
38388: NEG
38389: PUSH
38390: LD_INT 0
38392: PUSH
38393: EMPTY
38394: LIST
38395: LIST
38396: PUSH
38397: LD_INT 1
38399: NEG
38400: PUSH
38401: LD_INT 1
38403: NEG
38404: PUSH
38405: EMPTY
38406: LIST
38407: LIST
38408: PUSH
38409: LD_INT 1
38411: PUSH
38412: LD_INT 1
38414: NEG
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 2
38422: PUSH
38423: LD_INT 0
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: PUSH
38430: LD_INT 2
38432: PUSH
38433: LD_INT 1
38435: PUSH
38436: EMPTY
38437: LIST
38438: LIST
38439: PUSH
38440: LD_INT 2
38442: PUSH
38443: LD_INT 2
38445: PUSH
38446: EMPTY
38447: LIST
38448: LIST
38449: PUSH
38450: LD_INT 1
38452: PUSH
38453: LD_INT 2
38455: PUSH
38456: EMPTY
38457: LIST
38458: LIST
38459: PUSH
38460: EMPTY
38461: LIST
38462: LIST
38463: LIST
38464: LIST
38465: LIST
38466: LIST
38467: LIST
38468: LIST
38469: LIST
38470: LIST
38471: LIST
38472: LIST
38473: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38474: LD_ADDR_VAR 0 50
38478: PUSH
38479: LD_INT 0
38481: PUSH
38482: LD_INT 0
38484: PUSH
38485: EMPTY
38486: LIST
38487: LIST
38488: PUSH
38489: LD_INT 0
38491: PUSH
38492: LD_INT 1
38494: NEG
38495: PUSH
38496: EMPTY
38497: LIST
38498: LIST
38499: PUSH
38500: LD_INT 1
38502: PUSH
38503: LD_INT 0
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 1
38512: PUSH
38513: LD_INT 1
38515: PUSH
38516: EMPTY
38517: LIST
38518: LIST
38519: PUSH
38520: LD_INT 0
38522: PUSH
38523: LD_INT 1
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: LD_INT 1
38532: NEG
38533: PUSH
38534: LD_INT 0
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 1
38543: NEG
38544: PUSH
38545: LD_INT 1
38547: NEG
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: LD_INT 2
38555: PUSH
38556: LD_INT 1
38558: PUSH
38559: EMPTY
38560: LIST
38561: LIST
38562: PUSH
38563: LD_INT 2
38565: PUSH
38566: LD_INT 2
38568: PUSH
38569: EMPTY
38570: LIST
38571: LIST
38572: PUSH
38573: LD_INT 1
38575: PUSH
38576: LD_INT 2
38578: PUSH
38579: EMPTY
38580: LIST
38581: LIST
38582: PUSH
38583: LD_INT 0
38585: PUSH
38586: LD_INT 2
38588: PUSH
38589: EMPTY
38590: LIST
38591: LIST
38592: PUSH
38593: LD_INT 1
38595: NEG
38596: PUSH
38597: LD_INT 1
38599: PUSH
38600: EMPTY
38601: LIST
38602: LIST
38603: PUSH
38604: EMPTY
38605: LIST
38606: LIST
38607: LIST
38608: LIST
38609: LIST
38610: LIST
38611: LIST
38612: LIST
38613: LIST
38614: LIST
38615: LIST
38616: LIST
38617: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38618: LD_ADDR_VAR 0 51
38622: PUSH
38623: LD_INT 0
38625: PUSH
38626: LD_INT 0
38628: PUSH
38629: EMPTY
38630: LIST
38631: LIST
38632: PUSH
38633: LD_INT 0
38635: PUSH
38636: LD_INT 1
38638: NEG
38639: PUSH
38640: EMPTY
38641: LIST
38642: LIST
38643: PUSH
38644: LD_INT 1
38646: PUSH
38647: LD_INT 0
38649: PUSH
38650: EMPTY
38651: LIST
38652: LIST
38653: PUSH
38654: LD_INT 1
38656: PUSH
38657: LD_INT 1
38659: PUSH
38660: EMPTY
38661: LIST
38662: LIST
38663: PUSH
38664: LD_INT 0
38666: PUSH
38667: LD_INT 1
38669: PUSH
38670: EMPTY
38671: LIST
38672: LIST
38673: PUSH
38674: LD_INT 1
38676: NEG
38677: PUSH
38678: LD_INT 0
38680: PUSH
38681: EMPTY
38682: LIST
38683: LIST
38684: PUSH
38685: LD_INT 1
38687: NEG
38688: PUSH
38689: LD_INT 1
38691: NEG
38692: PUSH
38693: EMPTY
38694: LIST
38695: LIST
38696: PUSH
38697: LD_INT 1
38699: PUSH
38700: LD_INT 2
38702: PUSH
38703: EMPTY
38704: LIST
38705: LIST
38706: PUSH
38707: LD_INT 0
38709: PUSH
38710: LD_INT 2
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: PUSH
38717: LD_INT 1
38719: NEG
38720: PUSH
38721: LD_INT 1
38723: PUSH
38724: EMPTY
38725: LIST
38726: LIST
38727: PUSH
38728: LD_INT 2
38730: NEG
38731: PUSH
38732: LD_INT 0
38734: PUSH
38735: EMPTY
38736: LIST
38737: LIST
38738: PUSH
38739: LD_INT 2
38741: NEG
38742: PUSH
38743: LD_INT 1
38745: NEG
38746: PUSH
38747: EMPTY
38748: LIST
38749: LIST
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: LIST
38755: LIST
38756: LIST
38757: LIST
38758: LIST
38759: LIST
38760: LIST
38761: LIST
38762: LIST
38763: LIST
38764: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38765: LD_ADDR_VAR 0 52
38769: PUSH
38770: LD_INT 0
38772: PUSH
38773: LD_INT 0
38775: PUSH
38776: EMPTY
38777: LIST
38778: LIST
38779: PUSH
38780: LD_INT 0
38782: PUSH
38783: LD_INT 1
38785: NEG
38786: PUSH
38787: EMPTY
38788: LIST
38789: LIST
38790: PUSH
38791: LD_INT 1
38793: PUSH
38794: LD_INT 0
38796: PUSH
38797: EMPTY
38798: LIST
38799: LIST
38800: PUSH
38801: LD_INT 1
38803: PUSH
38804: LD_INT 1
38806: PUSH
38807: EMPTY
38808: LIST
38809: LIST
38810: PUSH
38811: LD_INT 0
38813: PUSH
38814: LD_INT 1
38816: PUSH
38817: EMPTY
38818: LIST
38819: LIST
38820: PUSH
38821: LD_INT 1
38823: NEG
38824: PUSH
38825: LD_INT 0
38827: PUSH
38828: EMPTY
38829: LIST
38830: LIST
38831: PUSH
38832: LD_INT 1
38834: NEG
38835: PUSH
38836: LD_INT 1
38838: NEG
38839: PUSH
38840: EMPTY
38841: LIST
38842: LIST
38843: PUSH
38844: LD_INT 1
38846: NEG
38847: PUSH
38848: LD_INT 2
38850: NEG
38851: PUSH
38852: EMPTY
38853: LIST
38854: LIST
38855: PUSH
38856: LD_INT 1
38858: NEG
38859: PUSH
38860: LD_INT 1
38862: PUSH
38863: EMPTY
38864: LIST
38865: LIST
38866: PUSH
38867: LD_INT 2
38869: NEG
38870: PUSH
38871: LD_INT 0
38873: PUSH
38874: EMPTY
38875: LIST
38876: LIST
38877: PUSH
38878: LD_INT 2
38880: NEG
38881: PUSH
38882: LD_INT 1
38884: NEG
38885: PUSH
38886: EMPTY
38887: LIST
38888: LIST
38889: PUSH
38890: LD_INT 2
38892: NEG
38893: PUSH
38894: LD_INT 2
38896: NEG
38897: PUSH
38898: EMPTY
38899: LIST
38900: LIST
38901: PUSH
38902: EMPTY
38903: LIST
38904: LIST
38905: LIST
38906: LIST
38907: LIST
38908: LIST
38909: LIST
38910: LIST
38911: LIST
38912: LIST
38913: LIST
38914: LIST
38915: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38916: LD_ADDR_VAR 0 53
38920: PUSH
38921: LD_INT 0
38923: PUSH
38924: LD_INT 0
38926: PUSH
38927: EMPTY
38928: LIST
38929: LIST
38930: PUSH
38931: LD_INT 0
38933: PUSH
38934: LD_INT 1
38936: NEG
38937: PUSH
38938: EMPTY
38939: LIST
38940: LIST
38941: PUSH
38942: LD_INT 1
38944: PUSH
38945: LD_INT 0
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 1
38954: PUSH
38955: LD_INT 1
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: LD_INT 0
38964: PUSH
38965: LD_INT 1
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: LD_INT 1
38974: NEG
38975: PUSH
38976: LD_INT 0
38978: PUSH
38979: EMPTY
38980: LIST
38981: LIST
38982: PUSH
38983: LD_INT 1
38985: NEG
38986: PUSH
38987: LD_INT 1
38989: NEG
38990: PUSH
38991: EMPTY
38992: LIST
38993: LIST
38994: PUSH
38995: LD_INT 1
38997: NEG
38998: PUSH
38999: LD_INT 2
39001: NEG
39002: PUSH
39003: EMPTY
39004: LIST
39005: LIST
39006: PUSH
39007: LD_INT 0
39009: PUSH
39010: LD_INT 2
39012: NEG
39013: PUSH
39014: EMPTY
39015: LIST
39016: LIST
39017: PUSH
39018: LD_INT 1
39020: PUSH
39021: LD_INT 1
39023: NEG
39024: PUSH
39025: EMPTY
39026: LIST
39027: LIST
39028: PUSH
39029: LD_INT 2
39031: PUSH
39032: LD_INT 0
39034: PUSH
39035: EMPTY
39036: LIST
39037: LIST
39038: PUSH
39039: LD_INT 2
39041: PUSH
39042: LD_INT 1
39044: PUSH
39045: EMPTY
39046: LIST
39047: LIST
39048: PUSH
39049: LD_INT 2
39051: PUSH
39052: LD_INT 2
39054: PUSH
39055: EMPTY
39056: LIST
39057: LIST
39058: PUSH
39059: LD_INT 1
39061: PUSH
39062: LD_INT 2
39064: PUSH
39065: EMPTY
39066: LIST
39067: LIST
39068: PUSH
39069: LD_INT 0
39071: PUSH
39072: LD_INT 2
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: PUSH
39079: LD_INT 1
39081: NEG
39082: PUSH
39083: LD_INT 1
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PUSH
39090: LD_INT 2
39092: NEG
39093: PUSH
39094: LD_INT 0
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: LD_INT 2
39103: NEG
39104: PUSH
39105: LD_INT 1
39107: NEG
39108: PUSH
39109: EMPTY
39110: LIST
39111: LIST
39112: PUSH
39113: LD_INT 2
39115: NEG
39116: PUSH
39117: LD_INT 2
39119: NEG
39120: PUSH
39121: EMPTY
39122: LIST
39123: LIST
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: LIST
39129: LIST
39130: LIST
39131: LIST
39132: LIST
39133: LIST
39134: LIST
39135: LIST
39136: LIST
39137: LIST
39138: LIST
39139: LIST
39140: LIST
39141: LIST
39142: LIST
39143: LIST
39144: LIST
39145: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39146: LD_ADDR_VAR 0 54
39150: PUSH
39151: LD_INT 0
39153: PUSH
39154: LD_INT 0
39156: PUSH
39157: EMPTY
39158: LIST
39159: LIST
39160: PUSH
39161: LD_INT 0
39163: PUSH
39164: LD_INT 1
39166: NEG
39167: PUSH
39168: EMPTY
39169: LIST
39170: LIST
39171: PUSH
39172: LD_INT 1
39174: PUSH
39175: LD_INT 0
39177: PUSH
39178: EMPTY
39179: LIST
39180: LIST
39181: PUSH
39182: LD_INT 1
39184: PUSH
39185: LD_INT 1
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: PUSH
39192: LD_INT 0
39194: PUSH
39195: LD_INT 1
39197: PUSH
39198: EMPTY
39199: LIST
39200: LIST
39201: PUSH
39202: LD_INT 1
39204: NEG
39205: PUSH
39206: LD_INT 0
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PUSH
39213: LD_INT 1
39215: NEG
39216: PUSH
39217: LD_INT 1
39219: NEG
39220: PUSH
39221: EMPTY
39222: LIST
39223: LIST
39224: PUSH
39225: LD_INT 1
39227: NEG
39228: PUSH
39229: LD_INT 2
39231: NEG
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: PUSH
39237: LD_INT 0
39239: PUSH
39240: LD_INT 2
39242: NEG
39243: PUSH
39244: EMPTY
39245: LIST
39246: LIST
39247: PUSH
39248: LD_INT 1
39250: PUSH
39251: LD_INT 1
39253: NEG
39254: PUSH
39255: EMPTY
39256: LIST
39257: LIST
39258: PUSH
39259: LD_INT 2
39261: PUSH
39262: LD_INT 0
39264: PUSH
39265: EMPTY
39266: LIST
39267: LIST
39268: PUSH
39269: LD_INT 2
39271: PUSH
39272: LD_INT 1
39274: PUSH
39275: EMPTY
39276: LIST
39277: LIST
39278: PUSH
39279: LD_INT 2
39281: PUSH
39282: LD_INT 2
39284: PUSH
39285: EMPTY
39286: LIST
39287: LIST
39288: PUSH
39289: LD_INT 1
39291: PUSH
39292: LD_INT 2
39294: PUSH
39295: EMPTY
39296: LIST
39297: LIST
39298: PUSH
39299: LD_INT 0
39301: PUSH
39302: LD_INT 2
39304: PUSH
39305: EMPTY
39306: LIST
39307: LIST
39308: PUSH
39309: LD_INT 1
39311: NEG
39312: PUSH
39313: LD_INT 1
39315: PUSH
39316: EMPTY
39317: LIST
39318: LIST
39319: PUSH
39320: LD_INT 2
39322: NEG
39323: PUSH
39324: LD_INT 0
39326: PUSH
39327: EMPTY
39328: LIST
39329: LIST
39330: PUSH
39331: LD_INT 2
39333: NEG
39334: PUSH
39335: LD_INT 1
39337: NEG
39338: PUSH
39339: EMPTY
39340: LIST
39341: LIST
39342: PUSH
39343: LD_INT 2
39345: NEG
39346: PUSH
39347: LD_INT 2
39349: NEG
39350: PUSH
39351: EMPTY
39352: LIST
39353: LIST
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: LIST
39359: LIST
39360: LIST
39361: LIST
39362: LIST
39363: LIST
39364: LIST
39365: LIST
39366: LIST
39367: LIST
39368: LIST
39369: LIST
39370: LIST
39371: LIST
39372: LIST
39373: LIST
39374: LIST
39375: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39376: LD_ADDR_VAR 0 55
39380: PUSH
39381: LD_INT 0
39383: PUSH
39384: LD_INT 0
39386: PUSH
39387: EMPTY
39388: LIST
39389: LIST
39390: PUSH
39391: LD_INT 0
39393: PUSH
39394: LD_INT 1
39396: NEG
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PUSH
39402: LD_INT 1
39404: PUSH
39405: LD_INT 0
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: LD_INT 1
39414: PUSH
39415: LD_INT 1
39417: PUSH
39418: EMPTY
39419: LIST
39420: LIST
39421: PUSH
39422: LD_INT 0
39424: PUSH
39425: LD_INT 1
39427: PUSH
39428: EMPTY
39429: LIST
39430: LIST
39431: PUSH
39432: LD_INT 1
39434: NEG
39435: PUSH
39436: LD_INT 0
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: LD_INT 1
39445: NEG
39446: PUSH
39447: LD_INT 1
39449: NEG
39450: PUSH
39451: EMPTY
39452: LIST
39453: LIST
39454: PUSH
39455: LD_INT 1
39457: NEG
39458: PUSH
39459: LD_INT 2
39461: NEG
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PUSH
39467: LD_INT 0
39469: PUSH
39470: LD_INT 2
39472: NEG
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: PUSH
39478: LD_INT 1
39480: PUSH
39481: LD_INT 1
39483: NEG
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: LD_INT 2
39491: PUSH
39492: LD_INT 0
39494: PUSH
39495: EMPTY
39496: LIST
39497: LIST
39498: PUSH
39499: LD_INT 2
39501: PUSH
39502: LD_INT 1
39504: PUSH
39505: EMPTY
39506: LIST
39507: LIST
39508: PUSH
39509: LD_INT 2
39511: PUSH
39512: LD_INT 2
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: PUSH
39519: LD_INT 1
39521: PUSH
39522: LD_INT 2
39524: PUSH
39525: EMPTY
39526: LIST
39527: LIST
39528: PUSH
39529: LD_INT 0
39531: PUSH
39532: LD_INT 2
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: PUSH
39539: LD_INT 1
39541: NEG
39542: PUSH
39543: LD_INT 1
39545: PUSH
39546: EMPTY
39547: LIST
39548: LIST
39549: PUSH
39550: LD_INT 2
39552: NEG
39553: PUSH
39554: LD_INT 0
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 2
39563: NEG
39564: PUSH
39565: LD_INT 1
39567: NEG
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 2
39575: NEG
39576: PUSH
39577: LD_INT 2
39579: NEG
39580: PUSH
39581: EMPTY
39582: LIST
39583: LIST
39584: PUSH
39585: EMPTY
39586: LIST
39587: LIST
39588: LIST
39589: LIST
39590: LIST
39591: LIST
39592: LIST
39593: LIST
39594: LIST
39595: LIST
39596: LIST
39597: LIST
39598: LIST
39599: LIST
39600: LIST
39601: LIST
39602: LIST
39603: LIST
39604: LIST
39605: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39606: LD_ADDR_VAR 0 56
39610: PUSH
39611: LD_INT 0
39613: PUSH
39614: LD_INT 0
39616: PUSH
39617: EMPTY
39618: LIST
39619: LIST
39620: PUSH
39621: LD_INT 0
39623: PUSH
39624: LD_INT 1
39626: NEG
39627: PUSH
39628: EMPTY
39629: LIST
39630: LIST
39631: PUSH
39632: LD_INT 1
39634: PUSH
39635: LD_INT 0
39637: PUSH
39638: EMPTY
39639: LIST
39640: LIST
39641: PUSH
39642: LD_INT 1
39644: PUSH
39645: LD_INT 1
39647: PUSH
39648: EMPTY
39649: LIST
39650: LIST
39651: PUSH
39652: LD_INT 0
39654: PUSH
39655: LD_INT 1
39657: PUSH
39658: EMPTY
39659: LIST
39660: LIST
39661: PUSH
39662: LD_INT 1
39664: NEG
39665: PUSH
39666: LD_INT 0
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: LD_INT 1
39675: NEG
39676: PUSH
39677: LD_INT 1
39679: NEG
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 1
39687: NEG
39688: PUSH
39689: LD_INT 2
39691: NEG
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: PUSH
39697: LD_INT 0
39699: PUSH
39700: LD_INT 2
39702: NEG
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PUSH
39708: LD_INT 1
39710: PUSH
39711: LD_INT 1
39713: NEG
39714: PUSH
39715: EMPTY
39716: LIST
39717: LIST
39718: PUSH
39719: LD_INT 2
39721: PUSH
39722: LD_INT 0
39724: PUSH
39725: EMPTY
39726: LIST
39727: LIST
39728: PUSH
39729: LD_INT 2
39731: PUSH
39732: LD_INT 1
39734: PUSH
39735: EMPTY
39736: LIST
39737: LIST
39738: PUSH
39739: LD_INT 2
39741: PUSH
39742: LD_INT 2
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: PUSH
39749: LD_INT 1
39751: PUSH
39752: LD_INT 2
39754: PUSH
39755: EMPTY
39756: LIST
39757: LIST
39758: PUSH
39759: LD_INT 0
39761: PUSH
39762: LD_INT 2
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 1
39771: NEG
39772: PUSH
39773: LD_INT 1
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 2
39782: NEG
39783: PUSH
39784: LD_INT 0
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 2
39793: NEG
39794: PUSH
39795: LD_INT 1
39797: NEG
39798: PUSH
39799: EMPTY
39800: LIST
39801: LIST
39802: PUSH
39803: LD_INT 2
39805: NEG
39806: PUSH
39807: LD_INT 2
39809: NEG
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: EMPTY
39816: LIST
39817: LIST
39818: LIST
39819: LIST
39820: LIST
39821: LIST
39822: LIST
39823: LIST
39824: LIST
39825: LIST
39826: LIST
39827: LIST
39828: LIST
39829: LIST
39830: LIST
39831: LIST
39832: LIST
39833: LIST
39834: LIST
39835: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39836: LD_ADDR_VAR 0 57
39840: PUSH
39841: LD_INT 0
39843: PUSH
39844: LD_INT 0
39846: PUSH
39847: EMPTY
39848: LIST
39849: LIST
39850: PUSH
39851: LD_INT 0
39853: PUSH
39854: LD_INT 1
39856: NEG
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: PUSH
39862: LD_INT 1
39864: PUSH
39865: LD_INT 0
39867: PUSH
39868: EMPTY
39869: LIST
39870: LIST
39871: PUSH
39872: LD_INT 1
39874: PUSH
39875: LD_INT 1
39877: PUSH
39878: EMPTY
39879: LIST
39880: LIST
39881: PUSH
39882: LD_INT 0
39884: PUSH
39885: LD_INT 1
39887: PUSH
39888: EMPTY
39889: LIST
39890: LIST
39891: PUSH
39892: LD_INT 1
39894: NEG
39895: PUSH
39896: LD_INT 0
39898: PUSH
39899: EMPTY
39900: LIST
39901: LIST
39902: PUSH
39903: LD_INT 1
39905: NEG
39906: PUSH
39907: LD_INT 1
39909: NEG
39910: PUSH
39911: EMPTY
39912: LIST
39913: LIST
39914: PUSH
39915: LD_INT 1
39917: NEG
39918: PUSH
39919: LD_INT 2
39921: NEG
39922: PUSH
39923: EMPTY
39924: LIST
39925: LIST
39926: PUSH
39927: LD_INT 0
39929: PUSH
39930: LD_INT 2
39932: NEG
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: PUSH
39938: LD_INT 1
39940: PUSH
39941: LD_INT 1
39943: NEG
39944: PUSH
39945: EMPTY
39946: LIST
39947: LIST
39948: PUSH
39949: LD_INT 2
39951: PUSH
39952: LD_INT 0
39954: PUSH
39955: EMPTY
39956: LIST
39957: LIST
39958: PUSH
39959: LD_INT 2
39961: PUSH
39962: LD_INT 1
39964: PUSH
39965: EMPTY
39966: LIST
39967: LIST
39968: PUSH
39969: LD_INT 2
39971: PUSH
39972: LD_INT 2
39974: PUSH
39975: EMPTY
39976: LIST
39977: LIST
39978: PUSH
39979: LD_INT 1
39981: PUSH
39982: LD_INT 2
39984: PUSH
39985: EMPTY
39986: LIST
39987: LIST
39988: PUSH
39989: LD_INT 0
39991: PUSH
39992: LD_INT 2
39994: PUSH
39995: EMPTY
39996: LIST
39997: LIST
39998: PUSH
39999: LD_INT 1
40001: NEG
40002: PUSH
40003: LD_INT 1
40005: PUSH
40006: EMPTY
40007: LIST
40008: LIST
40009: PUSH
40010: LD_INT 2
40012: NEG
40013: PUSH
40014: LD_INT 0
40016: PUSH
40017: EMPTY
40018: LIST
40019: LIST
40020: PUSH
40021: LD_INT 2
40023: NEG
40024: PUSH
40025: LD_INT 1
40027: NEG
40028: PUSH
40029: EMPTY
40030: LIST
40031: LIST
40032: PUSH
40033: LD_INT 2
40035: NEG
40036: PUSH
40037: LD_INT 2
40039: NEG
40040: PUSH
40041: EMPTY
40042: LIST
40043: LIST
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: LIST
40049: LIST
40050: LIST
40051: LIST
40052: LIST
40053: LIST
40054: LIST
40055: LIST
40056: LIST
40057: LIST
40058: LIST
40059: LIST
40060: LIST
40061: LIST
40062: LIST
40063: LIST
40064: LIST
40065: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40066: LD_ADDR_VAR 0 58
40070: PUSH
40071: LD_INT 0
40073: PUSH
40074: LD_INT 0
40076: PUSH
40077: EMPTY
40078: LIST
40079: LIST
40080: PUSH
40081: LD_INT 0
40083: PUSH
40084: LD_INT 1
40086: NEG
40087: PUSH
40088: EMPTY
40089: LIST
40090: LIST
40091: PUSH
40092: LD_INT 1
40094: PUSH
40095: LD_INT 0
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: LD_INT 1
40104: PUSH
40105: LD_INT 1
40107: PUSH
40108: EMPTY
40109: LIST
40110: LIST
40111: PUSH
40112: LD_INT 0
40114: PUSH
40115: LD_INT 1
40117: PUSH
40118: EMPTY
40119: LIST
40120: LIST
40121: PUSH
40122: LD_INT 1
40124: NEG
40125: PUSH
40126: LD_INT 0
40128: PUSH
40129: EMPTY
40130: LIST
40131: LIST
40132: PUSH
40133: LD_INT 1
40135: NEG
40136: PUSH
40137: LD_INT 1
40139: NEG
40140: PUSH
40141: EMPTY
40142: LIST
40143: LIST
40144: PUSH
40145: LD_INT 1
40147: NEG
40148: PUSH
40149: LD_INT 2
40151: NEG
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 0
40159: PUSH
40160: LD_INT 2
40162: NEG
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PUSH
40168: LD_INT 1
40170: PUSH
40171: LD_INT 1
40173: NEG
40174: PUSH
40175: EMPTY
40176: LIST
40177: LIST
40178: PUSH
40179: LD_INT 2
40181: PUSH
40182: LD_INT 0
40184: PUSH
40185: EMPTY
40186: LIST
40187: LIST
40188: PUSH
40189: LD_INT 2
40191: PUSH
40192: LD_INT 1
40194: PUSH
40195: EMPTY
40196: LIST
40197: LIST
40198: PUSH
40199: LD_INT 2
40201: PUSH
40202: LD_INT 2
40204: PUSH
40205: EMPTY
40206: LIST
40207: LIST
40208: PUSH
40209: LD_INT 1
40211: PUSH
40212: LD_INT 2
40214: PUSH
40215: EMPTY
40216: LIST
40217: LIST
40218: PUSH
40219: LD_INT 0
40221: PUSH
40222: LD_INT 2
40224: PUSH
40225: EMPTY
40226: LIST
40227: LIST
40228: PUSH
40229: LD_INT 1
40231: NEG
40232: PUSH
40233: LD_INT 1
40235: PUSH
40236: EMPTY
40237: LIST
40238: LIST
40239: PUSH
40240: LD_INT 2
40242: NEG
40243: PUSH
40244: LD_INT 0
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: LD_INT 2
40253: NEG
40254: PUSH
40255: LD_INT 1
40257: NEG
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: PUSH
40263: LD_INT 2
40265: NEG
40266: PUSH
40267: LD_INT 2
40269: NEG
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: PUSH
40275: EMPTY
40276: LIST
40277: LIST
40278: LIST
40279: LIST
40280: LIST
40281: LIST
40282: LIST
40283: LIST
40284: LIST
40285: LIST
40286: LIST
40287: LIST
40288: LIST
40289: LIST
40290: LIST
40291: LIST
40292: LIST
40293: LIST
40294: LIST
40295: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40296: LD_ADDR_VAR 0 59
40300: PUSH
40301: LD_INT 0
40303: PUSH
40304: LD_INT 0
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: LD_INT 0
40313: PUSH
40314: LD_INT 1
40316: NEG
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: PUSH
40322: LD_INT 1
40324: PUSH
40325: LD_INT 0
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 1
40334: PUSH
40335: LD_INT 1
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: PUSH
40342: LD_INT 0
40344: PUSH
40345: LD_INT 1
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: PUSH
40352: LD_INT 1
40354: NEG
40355: PUSH
40356: LD_INT 0
40358: PUSH
40359: EMPTY
40360: LIST
40361: LIST
40362: PUSH
40363: LD_INT 1
40365: NEG
40366: PUSH
40367: LD_INT 1
40369: NEG
40370: PUSH
40371: EMPTY
40372: LIST
40373: LIST
40374: PUSH
40375: EMPTY
40376: LIST
40377: LIST
40378: LIST
40379: LIST
40380: LIST
40381: LIST
40382: LIST
40383: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40384: LD_ADDR_VAR 0 60
40388: PUSH
40389: LD_INT 0
40391: PUSH
40392: LD_INT 0
40394: PUSH
40395: EMPTY
40396: LIST
40397: LIST
40398: PUSH
40399: LD_INT 0
40401: PUSH
40402: LD_INT 1
40404: NEG
40405: PUSH
40406: EMPTY
40407: LIST
40408: LIST
40409: PUSH
40410: LD_INT 1
40412: PUSH
40413: LD_INT 0
40415: PUSH
40416: EMPTY
40417: LIST
40418: LIST
40419: PUSH
40420: LD_INT 1
40422: PUSH
40423: LD_INT 1
40425: PUSH
40426: EMPTY
40427: LIST
40428: LIST
40429: PUSH
40430: LD_INT 0
40432: PUSH
40433: LD_INT 1
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: PUSH
40440: LD_INT 1
40442: NEG
40443: PUSH
40444: LD_INT 0
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: LD_INT 1
40453: NEG
40454: PUSH
40455: LD_INT 1
40457: NEG
40458: PUSH
40459: EMPTY
40460: LIST
40461: LIST
40462: PUSH
40463: EMPTY
40464: LIST
40465: LIST
40466: LIST
40467: LIST
40468: LIST
40469: LIST
40470: LIST
40471: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40472: LD_ADDR_VAR 0 61
40476: PUSH
40477: LD_INT 0
40479: PUSH
40480: LD_INT 0
40482: PUSH
40483: EMPTY
40484: LIST
40485: LIST
40486: PUSH
40487: LD_INT 0
40489: PUSH
40490: LD_INT 1
40492: NEG
40493: PUSH
40494: EMPTY
40495: LIST
40496: LIST
40497: PUSH
40498: LD_INT 1
40500: PUSH
40501: LD_INT 0
40503: PUSH
40504: EMPTY
40505: LIST
40506: LIST
40507: PUSH
40508: LD_INT 1
40510: PUSH
40511: LD_INT 1
40513: PUSH
40514: EMPTY
40515: LIST
40516: LIST
40517: PUSH
40518: LD_INT 0
40520: PUSH
40521: LD_INT 1
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 1
40530: NEG
40531: PUSH
40532: LD_INT 0
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: PUSH
40539: LD_INT 1
40541: NEG
40542: PUSH
40543: LD_INT 1
40545: NEG
40546: PUSH
40547: EMPTY
40548: LIST
40549: LIST
40550: PUSH
40551: EMPTY
40552: LIST
40553: LIST
40554: LIST
40555: LIST
40556: LIST
40557: LIST
40558: LIST
40559: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40560: LD_ADDR_VAR 0 62
40564: PUSH
40565: LD_INT 0
40567: PUSH
40568: LD_INT 0
40570: PUSH
40571: EMPTY
40572: LIST
40573: LIST
40574: PUSH
40575: LD_INT 0
40577: PUSH
40578: LD_INT 1
40580: NEG
40581: PUSH
40582: EMPTY
40583: LIST
40584: LIST
40585: PUSH
40586: LD_INT 1
40588: PUSH
40589: LD_INT 0
40591: PUSH
40592: EMPTY
40593: LIST
40594: LIST
40595: PUSH
40596: LD_INT 1
40598: PUSH
40599: LD_INT 1
40601: PUSH
40602: EMPTY
40603: LIST
40604: LIST
40605: PUSH
40606: LD_INT 0
40608: PUSH
40609: LD_INT 1
40611: PUSH
40612: EMPTY
40613: LIST
40614: LIST
40615: PUSH
40616: LD_INT 1
40618: NEG
40619: PUSH
40620: LD_INT 0
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: PUSH
40627: LD_INT 1
40629: NEG
40630: PUSH
40631: LD_INT 1
40633: NEG
40634: PUSH
40635: EMPTY
40636: LIST
40637: LIST
40638: PUSH
40639: EMPTY
40640: LIST
40641: LIST
40642: LIST
40643: LIST
40644: LIST
40645: LIST
40646: LIST
40647: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40648: LD_ADDR_VAR 0 63
40652: PUSH
40653: LD_INT 0
40655: PUSH
40656: LD_INT 0
40658: PUSH
40659: EMPTY
40660: LIST
40661: LIST
40662: PUSH
40663: LD_INT 0
40665: PUSH
40666: LD_INT 1
40668: NEG
40669: PUSH
40670: EMPTY
40671: LIST
40672: LIST
40673: PUSH
40674: LD_INT 1
40676: PUSH
40677: LD_INT 0
40679: PUSH
40680: EMPTY
40681: LIST
40682: LIST
40683: PUSH
40684: LD_INT 1
40686: PUSH
40687: LD_INT 1
40689: PUSH
40690: EMPTY
40691: LIST
40692: LIST
40693: PUSH
40694: LD_INT 0
40696: PUSH
40697: LD_INT 1
40699: PUSH
40700: EMPTY
40701: LIST
40702: LIST
40703: PUSH
40704: LD_INT 1
40706: NEG
40707: PUSH
40708: LD_INT 0
40710: PUSH
40711: EMPTY
40712: LIST
40713: LIST
40714: PUSH
40715: LD_INT 1
40717: NEG
40718: PUSH
40719: LD_INT 1
40721: NEG
40722: PUSH
40723: EMPTY
40724: LIST
40725: LIST
40726: PUSH
40727: EMPTY
40728: LIST
40729: LIST
40730: LIST
40731: LIST
40732: LIST
40733: LIST
40734: LIST
40735: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40736: LD_ADDR_VAR 0 64
40740: PUSH
40741: LD_INT 0
40743: PUSH
40744: LD_INT 0
40746: PUSH
40747: EMPTY
40748: LIST
40749: LIST
40750: PUSH
40751: LD_INT 0
40753: PUSH
40754: LD_INT 1
40756: NEG
40757: PUSH
40758: EMPTY
40759: LIST
40760: LIST
40761: PUSH
40762: LD_INT 1
40764: PUSH
40765: LD_INT 0
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: PUSH
40772: LD_INT 1
40774: PUSH
40775: LD_INT 1
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: PUSH
40782: LD_INT 0
40784: PUSH
40785: LD_INT 1
40787: PUSH
40788: EMPTY
40789: LIST
40790: LIST
40791: PUSH
40792: LD_INT 1
40794: NEG
40795: PUSH
40796: LD_INT 0
40798: PUSH
40799: EMPTY
40800: LIST
40801: LIST
40802: PUSH
40803: LD_INT 1
40805: NEG
40806: PUSH
40807: LD_INT 1
40809: NEG
40810: PUSH
40811: EMPTY
40812: LIST
40813: LIST
40814: PUSH
40815: EMPTY
40816: LIST
40817: LIST
40818: LIST
40819: LIST
40820: LIST
40821: LIST
40822: LIST
40823: ST_TO_ADDR
// end ; 1 :
40824: GO 46721
40826: LD_INT 1
40828: DOUBLE
40829: EQUAL
40830: IFTRUE 40834
40832: GO 43457
40834: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40835: LD_ADDR_VAR 0 11
40839: PUSH
40840: LD_INT 1
40842: NEG
40843: PUSH
40844: LD_INT 3
40846: NEG
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: LD_INT 0
40854: PUSH
40855: LD_INT 3
40857: NEG
40858: PUSH
40859: EMPTY
40860: LIST
40861: LIST
40862: PUSH
40863: LD_INT 1
40865: PUSH
40866: LD_INT 2
40868: NEG
40869: PUSH
40870: EMPTY
40871: LIST
40872: LIST
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: LIST
40878: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40879: LD_ADDR_VAR 0 12
40883: PUSH
40884: LD_INT 2
40886: PUSH
40887: LD_INT 1
40889: NEG
40890: PUSH
40891: EMPTY
40892: LIST
40893: LIST
40894: PUSH
40895: LD_INT 3
40897: PUSH
40898: LD_INT 0
40900: PUSH
40901: EMPTY
40902: LIST
40903: LIST
40904: PUSH
40905: LD_INT 3
40907: PUSH
40908: LD_INT 1
40910: PUSH
40911: EMPTY
40912: LIST
40913: LIST
40914: PUSH
40915: EMPTY
40916: LIST
40917: LIST
40918: LIST
40919: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40920: LD_ADDR_VAR 0 13
40924: PUSH
40925: LD_INT 3
40927: PUSH
40928: LD_INT 2
40930: PUSH
40931: EMPTY
40932: LIST
40933: LIST
40934: PUSH
40935: LD_INT 3
40937: PUSH
40938: LD_INT 3
40940: PUSH
40941: EMPTY
40942: LIST
40943: LIST
40944: PUSH
40945: LD_INT 2
40947: PUSH
40948: LD_INT 3
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: PUSH
40955: EMPTY
40956: LIST
40957: LIST
40958: LIST
40959: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40960: LD_ADDR_VAR 0 14
40964: PUSH
40965: LD_INT 1
40967: PUSH
40968: LD_INT 3
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: PUSH
40975: LD_INT 0
40977: PUSH
40978: LD_INT 3
40980: PUSH
40981: EMPTY
40982: LIST
40983: LIST
40984: PUSH
40985: LD_INT 1
40987: NEG
40988: PUSH
40989: LD_INT 2
40991: PUSH
40992: EMPTY
40993: LIST
40994: LIST
40995: PUSH
40996: EMPTY
40997: LIST
40998: LIST
40999: LIST
41000: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41001: LD_ADDR_VAR 0 15
41005: PUSH
41006: LD_INT 2
41008: NEG
41009: PUSH
41010: LD_INT 1
41012: PUSH
41013: EMPTY
41014: LIST
41015: LIST
41016: PUSH
41017: LD_INT 3
41019: NEG
41020: PUSH
41021: LD_INT 0
41023: PUSH
41024: EMPTY
41025: LIST
41026: LIST
41027: PUSH
41028: LD_INT 3
41030: NEG
41031: PUSH
41032: LD_INT 1
41034: NEG
41035: PUSH
41036: EMPTY
41037: LIST
41038: LIST
41039: PUSH
41040: EMPTY
41041: LIST
41042: LIST
41043: LIST
41044: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41045: LD_ADDR_VAR 0 16
41049: PUSH
41050: LD_INT 2
41052: NEG
41053: PUSH
41054: LD_INT 3
41056: NEG
41057: PUSH
41058: EMPTY
41059: LIST
41060: LIST
41061: PUSH
41062: LD_INT 3
41064: NEG
41065: PUSH
41066: LD_INT 2
41068: NEG
41069: PUSH
41070: EMPTY
41071: LIST
41072: LIST
41073: PUSH
41074: LD_INT 3
41076: NEG
41077: PUSH
41078: LD_INT 3
41080: NEG
41081: PUSH
41082: EMPTY
41083: LIST
41084: LIST
41085: PUSH
41086: EMPTY
41087: LIST
41088: LIST
41089: LIST
41090: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41091: LD_ADDR_VAR 0 17
41095: PUSH
41096: LD_INT 1
41098: NEG
41099: PUSH
41100: LD_INT 3
41102: NEG
41103: PUSH
41104: EMPTY
41105: LIST
41106: LIST
41107: PUSH
41108: LD_INT 0
41110: PUSH
41111: LD_INT 3
41113: NEG
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: PUSH
41119: LD_INT 1
41121: PUSH
41122: LD_INT 2
41124: NEG
41125: PUSH
41126: EMPTY
41127: LIST
41128: LIST
41129: PUSH
41130: EMPTY
41131: LIST
41132: LIST
41133: LIST
41134: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41135: LD_ADDR_VAR 0 18
41139: PUSH
41140: LD_INT 2
41142: PUSH
41143: LD_INT 1
41145: NEG
41146: PUSH
41147: EMPTY
41148: LIST
41149: LIST
41150: PUSH
41151: LD_INT 3
41153: PUSH
41154: LD_INT 0
41156: PUSH
41157: EMPTY
41158: LIST
41159: LIST
41160: PUSH
41161: LD_INT 3
41163: PUSH
41164: LD_INT 1
41166: PUSH
41167: EMPTY
41168: LIST
41169: LIST
41170: PUSH
41171: EMPTY
41172: LIST
41173: LIST
41174: LIST
41175: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41176: LD_ADDR_VAR 0 19
41180: PUSH
41181: LD_INT 3
41183: PUSH
41184: LD_INT 2
41186: PUSH
41187: EMPTY
41188: LIST
41189: LIST
41190: PUSH
41191: LD_INT 3
41193: PUSH
41194: LD_INT 3
41196: PUSH
41197: EMPTY
41198: LIST
41199: LIST
41200: PUSH
41201: LD_INT 2
41203: PUSH
41204: LD_INT 3
41206: PUSH
41207: EMPTY
41208: LIST
41209: LIST
41210: PUSH
41211: EMPTY
41212: LIST
41213: LIST
41214: LIST
41215: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41216: LD_ADDR_VAR 0 20
41220: PUSH
41221: LD_INT 1
41223: PUSH
41224: LD_INT 3
41226: PUSH
41227: EMPTY
41228: LIST
41229: LIST
41230: PUSH
41231: LD_INT 0
41233: PUSH
41234: LD_INT 3
41236: PUSH
41237: EMPTY
41238: LIST
41239: LIST
41240: PUSH
41241: LD_INT 1
41243: NEG
41244: PUSH
41245: LD_INT 2
41247: PUSH
41248: EMPTY
41249: LIST
41250: LIST
41251: PUSH
41252: EMPTY
41253: LIST
41254: LIST
41255: LIST
41256: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41257: LD_ADDR_VAR 0 21
41261: PUSH
41262: LD_INT 2
41264: NEG
41265: PUSH
41266: LD_INT 1
41268: PUSH
41269: EMPTY
41270: LIST
41271: LIST
41272: PUSH
41273: LD_INT 3
41275: NEG
41276: PUSH
41277: LD_INT 0
41279: PUSH
41280: EMPTY
41281: LIST
41282: LIST
41283: PUSH
41284: LD_INT 3
41286: NEG
41287: PUSH
41288: LD_INT 1
41290: NEG
41291: PUSH
41292: EMPTY
41293: LIST
41294: LIST
41295: PUSH
41296: EMPTY
41297: LIST
41298: LIST
41299: LIST
41300: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41301: LD_ADDR_VAR 0 22
41305: PUSH
41306: LD_INT 2
41308: NEG
41309: PUSH
41310: LD_INT 3
41312: NEG
41313: PUSH
41314: EMPTY
41315: LIST
41316: LIST
41317: PUSH
41318: LD_INT 3
41320: NEG
41321: PUSH
41322: LD_INT 2
41324: NEG
41325: PUSH
41326: EMPTY
41327: LIST
41328: LIST
41329: PUSH
41330: LD_INT 3
41332: NEG
41333: PUSH
41334: LD_INT 3
41336: NEG
41337: PUSH
41338: EMPTY
41339: LIST
41340: LIST
41341: PUSH
41342: EMPTY
41343: LIST
41344: LIST
41345: LIST
41346: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41347: LD_ADDR_VAR 0 23
41351: PUSH
41352: LD_INT 0
41354: PUSH
41355: LD_INT 3
41357: NEG
41358: PUSH
41359: EMPTY
41360: LIST
41361: LIST
41362: PUSH
41363: LD_INT 1
41365: NEG
41366: PUSH
41367: LD_INT 4
41369: NEG
41370: PUSH
41371: EMPTY
41372: LIST
41373: LIST
41374: PUSH
41375: LD_INT 1
41377: PUSH
41378: LD_INT 3
41380: NEG
41381: PUSH
41382: EMPTY
41383: LIST
41384: LIST
41385: PUSH
41386: EMPTY
41387: LIST
41388: LIST
41389: LIST
41390: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41391: LD_ADDR_VAR 0 24
41395: PUSH
41396: LD_INT 3
41398: PUSH
41399: LD_INT 0
41401: PUSH
41402: EMPTY
41403: LIST
41404: LIST
41405: PUSH
41406: LD_INT 3
41408: PUSH
41409: LD_INT 1
41411: NEG
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: PUSH
41417: LD_INT 4
41419: PUSH
41420: LD_INT 1
41422: PUSH
41423: EMPTY
41424: LIST
41425: LIST
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: LIST
41431: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41432: LD_ADDR_VAR 0 25
41436: PUSH
41437: LD_INT 3
41439: PUSH
41440: LD_INT 3
41442: PUSH
41443: EMPTY
41444: LIST
41445: LIST
41446: PUSH
41447: LD_INT 4
41449: PUSH
41450: LD_INT 3
41452: PUSH
41453: EMPTY
41454: LIST
41455: LIST
41456: PUSH
41457: LD_INT 3
41459: PUSH
41460: LD_INT 4
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: PUSH
41467: EMPTY
41468: LIST
41469: LIST
41470: LIST
41471: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41472: LD_ADDR_VAR 0 26
41476: PUSH
41477: LD_INT 0
41479: PUSH
41480: LD_INT 3
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PUSH
41487: LD_INT 1
41489: PUSH
41490: LD_INT 4
41492: PUSH
41493: EMPTY
41494: LIST
41495: LIST
41496: PUSH
41497: LD_INT 1
41499: NEG
41500: PUSH
41501: LD_INT 3
41503: PUSH
41504: EMPTY
41505: LIST
41506: LIST
41507: PUSH
41508: EMPTY
41509: LIST
41510: LIST
41511: LIST
41512: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41513: LD_ADDR_VAR 0 27
41517: PUSH
41518: LD_INT 3
41520: NEG
41521: PUSH
41522: LD_INT 0
41524: PUSH
41525: EMPTY
41526: LIST
41527: LIST
41528: PUSH
41529: LD_INT 3
41531: NEG
41532: PUSH
41533: LD_INT 1
41535: PUSH
41536: EMPTY
41537: LIST
41538: LIST
41539: PUSH
41540: LD_INT 4
41542: NEG
41543: PUSH
41544: LD_INT 1
41546: NEG
41547: PUSH
41548: EMPTY
41549: LIST
41550: LIST
41551: PUSH
41552: EMPTY
41553: LIST
41554: LIST
41555: LIST
41556: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41557: LD_ADDR_VAR 0 28
41561: PUSH
41562: LD_INT 3
41564: NEG
41565: PUSH
41566: LD_INT 3
41568: NEG
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: PUSH
41574: LD_INT 3
41576: NEG
41577: PUSH
41578: LD_INT 4
41580: NEG
41581: PUSH
41582: EMPTY
41583: LIST
41584: LIST
41585: PUSH
41586: LD_INT 4
41588: NEG
41589: PUSH
41590: LD_INT 3
41592: NEG
41593: PUSH
41594: EMPTY
41595: LIST
41596: LIST
41597: PUSH
41598: EMPTY
41599: LIST
41600: LIST
41601: LIST
41602: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41603: LD_ADDR_VAR 0 29
41607: PUSH
41608: LD_INT 1
41610: NEG
41611: PUSH
41612: LD_INT 3
41614: NEG
41615: PUSH
41616: EMPTY
41617: LIST
41618: LIST
41619: PUSH
41620: LD_INT 0
41622: PUSH
41623: LD_INT 3
41625: NEG
41626: PUSH
41627: EMPTY
41628: LIST
41629: LIST
41630: PUSH
41631: LD_INT 1
41633: PUSH
41634: LD_INT 2
41636: NEG
41637: PUSH
41638: EMPTY
41639: LIST
41640: LIST
41641: PUSH
41642: LD_INT 1
41644: NEG
41645: PUSH
41646: LD_INT 4
41648: NEG
41649: PUSH
41650: EMPTY
41651: LIST
41652: LIST
41653: PUSH
41654: LD_INT 0
41656: PUSH
41657: LD_INT 4
41659: NEG
41660: PUSH
41661: EMPTY
41662: LIST
41663: LIST
41664: PUSH
41665: LD_INT 1
41667: PUSH
41668: LD_INT 3
41670: NEG
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 1
41678: NEG
41679: PUSH
41680: LD_INT 5
41682: NEG
41683: PUSH
41684: EMPTY
41685: LIST
41686: LIST
41687: PUSH
41688: LD_INT 0
41690: PUSH
41691: LD_INT 5
41693: NEG
41694: PUSH
41695: EMPTY
41696: LIST
41697: LIST
41698: PUSH
41699: LD_INT 1
41701: PUSH
41702: LD_INT 4
41704: NEG
41705: PUSH
41706: EMPTY
41707: LIST
41708: LIST
41709: PUSH
41710: LD_INT 1
41712: NEG
41713: PUSH
41714: LD_INT 6
41716: NEG
41717: PUSH
41718: EMPTY
41719: LIST
41720: LIST
41721: PUSH
41722: LD_INT 0
41724: PUSH
41725: LD_INT 6
41727: NEG
41728: PUSH
41729: EMPTY
41730: LIST
41731: LIST
41732: PUSH
41733: LD_INT 1
41735: PUSH
41736: LD_INT 5
41738: NEG
41739: PUSH
41740: EMPTY
41741: LIST
41742: LIST
41743: PUSH
41744: EMPTY
41745: LIST
41746: LIST
41747: LIST
41748: LIST
41749: LIST
41750: LIST
41751: LIST
41752: LIST
41753: LIST
41754: LIST
41755: LIST
41756: LIST
41757: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41758: LD_ADDR_VAR 0 30
41762: PUSH
41763: LD_INT 2
41765: PUSH
41766: LD_INT 1
41768: NEG
41769: PUSH
41770: EMPTY
41771: LIST
41772: LIST
41773: PUSH
41774: LD_INT 3
41776: PUSH
41777: LD_INT 0
41779: PUSH
41780: EMPTY
41781: LIST
41782: LIST
41783: PUSH
41784: LD_INT 3
41786: PUSH
41787: LD_INT 1
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: PUSH
41794: LD_INT 3
41796: PUSH
41797: LD_INT 1
41799: NEG
41800: PUSH
41801: EMPTY
41802: LIST
41803: LIST
41804: PUSH
41805: LD_INT 4
41807: PUSH
41808: LD_INT 0
41810: PUSH
41811: EMPTY
41812: LIST
41813: LIST
41814: PUSH
41815: LD_INT 4
41817: PUSH
41818: LD_INT 1
41820: PUSH
41821: EMPTY
41822: LIST
41823: LIST
41824: PUSH
41825: LD_INT 4
41827: PUSH
41828: LD_INT 1
41830: NEG
41831: PUSH
41832: EMPTY
41833: LIST
41834: LIST
41835: PUSH
41836: LD_INT 5
41838: PUSH
41839: LD_INT 0
41841: PUSH
41842: EMPTY
41843: LIST
41844: LIST
41845: PUSH
41846: LD_INT 5
41848: PUSH
41849: LD_INT 1
41851: PUSH
41852: EMPTY
41853: LIST
41854: LIST
41855: PUSH
41856: LD_INT 5
41858: PUSH
41859: LD_INT 1
41861: NEG
41862: PUSH
41863: EMPTY
41864: LIST
41865: LIST
41866: PUSH
41867: LD_INT 6
41869: PUSH
41870: LD_INT 0
41872: PUSH
41873: EMPTY
41874: LIST
41875: LIST
41876: PUSH
41877: LD_INT 6
41879: PUSH
41880: LD_INT 1
41882: PUSH
41883: EMPTY
41884: LIST
41885: LIST
41886: PUSH
41887: EMPTY
41888: LIST
41889: LIST
41890: LIST
41891: LIST
41892: LIST
41893: LIST
41894: LIST
41895: LIST
41896: LIST
41897: LIST
41898: LIST
41899: LIST
41900: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41901: LD_ADDR_VAR 0 31
41905: PUSH
41906: LD_INT 3
41908: PUSH
41909: LD_INT 2
41911: PUSH
41912: EMPTY
41913: LIST
41914: LIST
41915: PUSH
41916: LD_INT 3
41918: PUSH
41919: LD_INT 3
41921: PUSH
41922: EMPTY
41923: LIST
41924: LIST
41925: PUSH
41926: LD_INT 2
41928: PUSH
41929: LD_INT 3
41931: PUSH
41932: EMPTY
41933: LIST
41934: LIST
41935: PUSH
41936: LD_INT 4
41938: PUSH
41939: LD_INT 3
41941: PUSH
41942: EMPTY
41943: LIST
41944: LIST
41945: PUSH
41946: LD_INT 4
41948: PUSH
41949: LD_INT 4
41951: PUSH
41952: EMPTY
41953: LIST
41954: LIST
41955: PUSH
41956: LD_INT 3
41958: PUSH
41959: LD_INT 4
41961: PUSH
41962: EMPTY
41963: LIST
41964: LIST
41965: PUSH
41966: LD_INT 5
41968: PUSH
41969: LD_INT 4
41971: PUSH
41972: EMPTY
41973: LIST
41974: LIST
41975: PUSH
41976: LD_INT 5
41978: PUSH
41979: LD_INT 5
41981: PUSH
41982: EMPTY
41983: LIST
41984: LIST
41985: PUSH
41986: LD_INT 4
41988: PUSH
41989: LD_INT 5
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: PUSH
41996: LD_INT 6
41998: PUSH
41999: LD_INT 5
42001: PUSH
42002: EMPTY
42003: LIST
42004: LIST
42005: PUSH
42006: LD_INT 6
42008: PUSH
42009: LD_INT 6
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: PUSH
42016: LD_INT 5
42018: PUSH
42019: LD_INT 6
42021: PUSH
42022: EMPTY
42023: LIST
42024: LIST
42025: PUSH
42026: EMPTY
42027: LIST
42028: LIST
42029: LIST
42030: LIST
42031: LIST
42032: LIST
42033: LIST
42034: LIST
42035: LIST
42036: LIST
42037: LIST
42038: LIST
42039: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42040: LD_ADDR_VAR 0 32
42044: PUSH
42045: LD_INT 1
42047: PUSH
42048: LD_INT 3
42050: PUSH
42051: EMPTY
42052: LIST
42053: LIST
42054: PUSH
42055: LD_INT 0
42057: PUSH
42058: LD_INT 3
42060: PUSH
42061: EMPTY
42062: LIST
42063: LIST
42064: PUSH
42065: LD_INT 1
42067: NEG
42068: PUSH
42069: LD_INT 2
42071: PUSH
42072: EMPTY
42073: LIST
42074: LIST
42075: PUSH
42076: LD_INT 1
42078: PUSH
42079: LD_INT 4
42081: PUSH
42082: EMPTY
42083: LIST
42084: LIST
42085: PUSH
42086: LD_INT 0
42088: PUSH
42089: LD_INT 4
42091: PUSH
42092: EMPTY
42093: LIST
42094: LIST
42095: PUSH
42096: LD_INT 1
42098: NEG
42099: PUSH
42100: LD_INT 3
42102: PUSH
42103: EMPTY
42104: LIST
42105: LIST
42106: PUSH
42107: LD_INT 1
42109: PUSH
42110: LD_INT 5
42112: PUSH
42113: EMPTY
42114: LIST
42115: LIST
42116: PUSH
42117: LD_INT 0
42119: PUSH
42120: LD_INT 5
42122: PUSH
42123: EMPTY
42124: LIST
42125: LIST
42126: PUSH
42127: LD_INT 1
42129: NEG
42130: PUSH
42131: LD_INT 4
42133: PUSH
42134: EMPTY
42135: LIST
42136: LIST
42137: PUSH
42138: LD_INT 1
42140: PUSH
42141: LD_INT 6
42143: PUSH
42144: EMPTY
42145: LIST
42146: LIST
42147: PUSH
42148: LD_INT 0
42150: PUSH
42151: LD_INT 6
42153: PUSH
42154: EMPTY
42155: LIST
42156: LIST
42157: PUSH
42158: LD_INT 1
42160: NEG
42161: PUSH
42162: LD_INT 5
42164: PUSH
42165: EMPTY
42166: LIST
42167: LIST
42168: PUSH
42169: EMPTY
42170: LIST
42171: LIST
42172: LIST
42173: LIST
42174: LIST
42175: LIST
42176: LIST
42177: LIST
42178: LIST
42179: LIST
42180: LIST
42181: LIST
42182: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42183: LD_ADDR_VAR 0 33
42187: PUSH
42188: LD_INT 2
42190: NEG
42191: PUSH
42192: LD_INT 1
42194: PUSH
42195: EMPTY
42196: LIST
42197: LIST
42198: PUSH
42199: LD_INT 3
42201: NEG
42202: PUSH
42203: LD_INT 0
42205: PUSH
42206: EMPTY
42207: LIST
42208: LIST
42209: PUSH
42210: LD_INT 3
42212: NEG
42213: PUSH
42214: LD_INT 1
42216: NEG
42217: PUSH
42218: EMPTY
42219: LIST
42220: LIST
42221: PUSH
42222: LD_INT 3
42224: NEG
42225: PUSH
42226: LD_INT 1
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: LD_INT 4
42235: NEG
42236: PUSH
42237: LD_INT 0
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: PUSH
42244: LD_INT 4
42246: NEG
42247: PUSH
42248: LD_INT 1
42250: NEG
42251: PUSH
42252: EMPTY
42253: LIST
42254: LIST
42255: PUSH
42256: LD_INT 4
42258: NEG
42259: PUSH
42260: LD_INT 1
42262: PUSH
42263: EMPTY
42264: LIST
42265: LIST
42266: PUSH
42267: LD_INT 5
42269: NEG
42270: PUSH
42271: LD_INT 0
42273: PUSH
42274: EMPTY
42275: LIST
42276: LIST
42277: PUSH
42278: LD_INT 5
42280: NEG
42281: PUSH
42282: LD_INT 1
42284: NEG
42285: PUSH
42286: EMPTY
42287: LIST
42288: LIST
42289: PUSH
42290: LD_INT 5
42292: NEG
42293: PUSH
42294: LD_INT 1
42296: PUSH
42297: EMPTY
42298: LIST
42299: LIST
42300: PUSH
42301: LD_INT 6
42303: NEG
42304: PUSH
42305: LD_INT 0
42307: PUSH
42308: EMPTY
42309: LIST
42310: LIST
42311: PUSH
42312: LD_INT 6
42314: NEG
42315: PUSH
42316: LD_INT 1
42318: NEG
42319: PUSH
42320: EMPTY
42321: LIST
42322: LIST
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: LIST
42328: LIST
42329: LIST
42330: LIST
42331: LIST
42332: LIST
42333: LIST
42334: LIST
42335: LIST
42336: LIST
42337: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42338: LD_ADDR_VAR 0 34
42342: PUSH
42343: LD_INT 2
42345: NEG
42346: PUSH
42347: LD_INT 3
42349: NEG
42350: PUSH
42351: EMPTY
42352: LIST
42353: LIST
42354: PUSH
42355: LD_INT 3
42357: NEG
42358: PUSH
42359: LD_INT 2
42361: NEG
42362: PUSH
42363: EMPTY
42364: LIST
42365: LIST
42366: PUSH
42367: LD_INT 3
42369: NEG
42370: PUSH
42371: LD_INT 3
42373: NEG
42374: PUSH
42375: EMPTY
42376: LIST
42377: LIST
42378: PUSH
42379: LD_INT 3
42381: NEG
42382: PUSH
42383: LD_INT 4
42385: NEG
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: LD_INT 4
42393: NEG
42394: PUSH
42395: LD_INT 3
42397: NEG
42398: PUSH
42399: EMPTY
42400: LIST
42401: LIST
42402: PUSH
42403: LD_INT 4
42405: NEG
42406: PUSH
42407: LD_INT 4
42409: NEG
42410: PUSH
42411: EMPTY
42412: LIST
42413: LIST
42414: PUSH
42415: LD_INT 4
42417: NEG
42418: PUSH
42419: LD_INT 5
42421: NEG
42422: PUSH
42423: EMPTY
42424: LIST
42425: LIST
42426: PUSH
42427: LD_INT 5
42429: NEG
42430: PUSH
42431: LD_INT 4
42433: NEG
42434: PUSH
42435: EMPTY
42436: LIST
42437: LIST
42438: PUSH
42439: LD_INT 5
42441: NEG
42442: PUSH
42443: LD_INT 5
42445: NEG
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: PUSH
42451: LD_INT 5
42453: NEG
42454: PUSH
42455: LD_INT 6
42457: NEG
42458: PUSH
42459: EMPTY
42460: LIST
42461: LIST
42462: PUSH
42463: LD_INT 6
42465: NEG
42466: PUSH
42467: LD_INT 5
42469: NEG
42470: PUSH
42471: EMPTY
42472: LIST
42473: LIST
42474: PUSH
42475: LD_INT 6
42477: NEG
42478: PUSH
42479: LD_INT 6
42481: NEG
42482: PUSH
42483: EMPTY
42484: LIST
42485: LIST
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: LIST
42491: LIST
42492: LIST
42493: LIST
42494: LIST
42495: LIST
42496: LIST
42497: LIST
42498: LIST
42499: LIST
42500: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42501: LD_ADDR_VAR 0 41
42505: PUSH
42506: LD_INT 0
42508: PUSH
42509: LD_INT 2
42511: NEG
42512: PUSH
42513: EMPTY
42514: LIST
42515: LIST
42516: PUSH
42517: LD_INT 1
42519: NEG
42520: PUSH
42521: LD_INT 3
42523: NEG
42524: PUSH
42525: EMPTY
42526: LIST
42527: LIST
42528: PUSH
42529: LD_INT 1
42531: PUSH
42532: LD_INT 2
42534: NEG
42535: PUSH
42536: EMPTY
42537: LIST
42538: LIST
42539: PUSH
42540: EMPTY
42541: LIST
42542: LIST
42543: LIST
42544: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42545: LD_ADDR_VAR 0 42
42549: PUSH
42550: LD_INT 2
42552: PUSH
42553: LD_INT 0
42555: PUSH
42556: EMPTY
42557: LIST
42558: LIST
42559: PUSH
42560: LD_INT 2
42562: PUSH
42563: LD_INT 1
42565: NEG
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: PUSH
42571: LD_INT 3
42573: PUSH
42574: LD_INT 1
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: PUSH
42581: EMPTY
42582: LIST
42583: LIST
42584: LIST
42585: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42586: LD_ADDR_VAR 0 43
42590: PUSH
42591: LD_INT 2
42593: PUSH
42594: LD_INT 2
42596: PUSH
42597: EMPTY
42598: LIST
42599: LIST
42600: PUSH
42601: LD_INT 3
42603: PUSH
42604: LD_INT 2
42606: PUSH
42607: EMPTY
42608: LIST
42609: LIST
42610: PUSH
42611: LD_INT 2
42613: PUSH
42614: LD_INT 3
42616: PUSH
42617: EMPTY
42618: LIST
42619: LIST
42620: PUSH
42621: EMPTY
42622: LIST
42623: LIST
42624: LIST
42625: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42626: LD_ADDR_VAR 0 44
42630: PUSH
42631: LD_INT 0
42633: PUSH
42634: LD_INT 2
42636: PUSH
42637: EMPTY
42638: LIST
42639: LIST
42640: PUSH
42641: LD_INT 1
42643: PUSH
42644: LD_INT 3
42646: PUSH
42647: EMPTY
42648: LIST
42649: LIST
42650: PUSH
42651: LD_INT 1
42653: NEG
42654: PUSH
42655: LD_INT 2
42657: PUSH
42658: EMPTY
42659: LIST
42660: LIST
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: LIST
42666: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42667: LD_ADDR_VAR 0 45
42671: PUSH
42672: LD_INT 2
42674: NEG
42675: PUSH
42676: LD_INT 0
42678: PUSH
42679: EMPTY
42680: LIST
42681: LIST
42682: PUSH
42683: LD_INT 2
42685: NEG
42686: PUSH
42687: LD_INT 1
42689: PUSH
42690: EMPTY
42691: LIST
42692: LIST
42693: PUSH
42694: LD_INT 3
42696: NEG
42697: PUSH
42698: LD_INT 1
42700: NEG
42701: PUSH
42702: EMPTY
42703: LIST
42704: LIST
42705: PUSH
42706: EMPTY
42707: LIST
42708: LIST
42709: LIST
42710: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42711: LD_ADDR_VAR 0 46
42715: PUSH
42716: LD_INT 2
42718: NEG
42719: PUSH
42720: LD_INT 2
42722: NEG
42723: PUSH
42724: EMPTY
42725: LIST
42726: LIST
42727: PUSH
42728: LD_INT 2
42730: NEG
42731: PUSH
42732: LD_INT 3
42734: NEG
42735: PUSH
42736: EMPTY
42737: LIST
42738: LIST
42739: PUSH
42740: LD_INT 3
42742: NEG
42743: PUSH
42744: LD_INT 2
42746: NEG
42747: PUSH
42748: EMPTY
42749: LIST
42750: LIST
42751: PUSH
42752: EMPTY
42753: LIST
42754: LIST
42755: LIST
42756: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42757: LD_ADDR_VAR 0 47
42761: PUSH
42762: LD_INT 2
42764: NEG
42765: PUSH
42766: LD_INT 3
42768: NEG
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: PUSH
42774: LD_INT 1
42776: NEG
42777: PUSH
42778: LD_INT 3
42780: NEG
42781: PUSH
42782: EMPTY
42783: LIST
42784: LIST
42785: PUSH
42786: EMPTY
42787: LIST
42788: LIST
42789: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42790: LD_ADDR_VAR 0 48
42794: PUSH
42795: LD_INT 1
42797: PUSH
42798: LD_INT 2
42800: NEG
42801: PUSH
42802: EMPTY
42803: LIST
42804: LIST
42805: PUSH
42806: LD_INT 2
42808: PUSH
42809: LD_INT 1
42811: NEG
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: PUSH
42817: EMPTY
42818: LIST
42819: LIST
42820: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42821: LD_ADDR_VAR 0 49
42825: PUSH
42826: LD_INT 3
42828: PUSH
42829: LD_INT 1
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: PUSH
42836: LD_INT 3
42838: PUSH
42839: LD_INT 2
42841: PUSH
42842: EMPTY
42843: LIST
42844: LIST
42845: PUSH
42846: EMPTY
42847: LIST
42848: LIST
42849: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42850: LD_ADDR_VAR 0 50
42854: PUSH
42855: LD_INT 2
42857: PUSH
42858: LD_INT 3
42860: PUSH
42861: EMPTY
42862: LIST
42863: LIST
42864: PUSH
42865: LD_INT 1
42867: PUSH
42868: LD_INT 3
42870: PUSH
42871: EMPTY
42872: LIST
42873: LIST
42874: PUSH
42875: EMPTY
42876: LIST
42877: LIST
42878: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42879: LD_ADDR_VAR 0 51
42883: PUSH
42884: LD_INT 1
42886: NEG
42887: PUSH
42888: LD_INT 2
42890: PUSH
42891: EMPTY
42892: LIST
42893: LIST
42894: PUSH
42895: LD_INT 2
42897: NEG
42898: PUSH
42899: LD_INT 1
42901: PUSH
42902: EMPTY
42903: LIST
42904: LIST
42905: PUSH
42906: EMPTY
42907: LIST
42908: LIST
42909: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42910: LD_ADDR_VAR 0 52
42914: PUSH
42915: LD_INT 3
42917: NEG
42918: PUSH
42919: LD_INT 1
42921: NEG
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PUSH
42927: LD_INT 3
42929: NEG
42930: PUSH
42931: LD_INT 2
42933: NEG
42934: PUSH
42935: EMPTY
42936: LIST
42937: LIST
42938: PUSH
42939: EMPTY
42940: LIST
42941: LIST
42942: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42943: LD_ADDR_VAR 0 53
42947: PUSH
42948: LD_INT 1
42950: NEG
42951: PUSH
42952: LD_INT 3
42954: NEG
42955: PUSH
42956: EMPTY
42957: LIST
42958: LIST
42959: PUSH
42960: LD_INT 0
42962: PUSH
42963: LD_INT 3
42965: NEG
42966: PUSH
42967: EMPTY
42968: LIST
42969: LIST
42970: PUSH
42971: LD_INT 1
42973: PUSH
42974: LD_INT 2
42976: NEG
42977: PUSH
42978: EMPTY
42979: LIST
42980: LIST
42981: PUSH
42982: EMPTY
42983: LIST
42984: LIST
42985: LIST
42986: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42987: LD_ADDR_VAR 0 54
42991: PUSH
42992: LD_INT 2
42994: PUSH
42995: LD_INT 1
42997: NEG
42998: PUSH
42999: EMPTY
43000: LIST
43001: LIST
43002: PUSH
43003: LD_INT 3
43005: PUSH
43006: LD_INT 0
43008: PUSH
43009: EMPTY
43010: LIST
43011: LIST
43012: PUSH
43013: LD_INT 3
43015: PUSH
43016: LD_INT 1
43018: PUSH
43019: EMPTY
43020: LIST
43021: LIST
43022: PUSH
43023: EMPTY
43024: LIST
43025: LIST
43026: LIST
43027: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43028: LD_ADDR_VAR 0 55
43032: PUSH
43033: LD_INT 3
43035: PUSH
43036: LD_INT 2
43038: PUSH
43039: EMPTY
43040: LIST
43041: LIST
43042: PUSH
43043: LD_INT 3
43045: PUSH
43046: LD_INT 3
43048: PUSH
43049: EMPTY
43050: LIST
43051: LIST
43052: PUSH
43053: LD_INT 2
43055: PUSH
43056: LD_INT 3
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: PUSH
43063: EMPTY
43064: LIST
43065: LIST
43066: LIST
43067: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43068: LD_ADDR_VAR 0 56
43072: PUSH
43073: LD_INT 1
43075: PUSH
43076: LD_INT 3
43078: PUSH
43079: EMPTY
43080: LIST
43081: LIST
43082: PUSH
43083: LD_INT 0
43085: PUSH
43086: LD_INT 3
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: LD_INT 1
43095: NEG
43096: PUSH
43097: LD_INT 2
43099: PUSH
43100: EMPTY
43101: LIST
43102: LIST
43103: PUSH
43104: EMPTY
43105: LIST
43106: LIST
43107: LIST
43108: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43109: LD_ADDR_VAR 0 57
43113: PUSH
43114: LD_INT 2
43116: NEG
43117: PUSH
43118: LD_INT 1
43120: PUSH
43121: EMPTY
43122: LIST
43123: LIST
43124: PUSH
43125: LD_INT 3
43127: NEG
43128: PUSH
43129: LD_INT 0
43131: PUSH
43132: EMPTY
43133: LIST
43134: LIST
43135: PUSH
43136: LD_INT 3
43138: NEG
43139: PUSH
43140: LD_INT 1
43142: NEG
43143: PUSH
43144: EMPTY
43145: LIST
43146: LIST
43147: PUSH
43148: EMPTY
43149: LIST
43150: LIST
43151: LIST
43152: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43153: LD_ADDR_VAR 0 58
43157: PUSH
43158: LD_INT 2
43160: NEG
43161: PUSH
43162: LD_INT 3
43164: NEG
43165: PUSH
43166: EMPTY
43167: LIST
43168: LIST
43169: PUSH
43170: LD_INT 3
43172: NEG
43173: PUSH
43174: LD_INT 2
43176: NEG
43177: PUSH
43178: EMPTY
43179: LIST
43180: LIST
43181: PUSH
43182: LD_INT 3
43184: NEG
43185: PUSH
43186: LD_INT 3
43188: NEG
43189: PUSH
43190: EMPTY
43191: LIST
43192: LIST
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: LIST
43198: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43199: LD_ADDR_VAR 0 59
43203: PUSH
43204: LD_INT 1
43206: NEG
43207: PUSH
43208: LD_INT 2
43210: NEG
43211: PUSH
43212: EMPTY
43213: LIST
43214: LIST
43215: PUSH
43216: LD_INT 0
43218: PUSH
43219: LD_INT 2
43221: NEG
43222: PUSH
43223: EMPTY
43224: LIST
43225: LIST
43226: PUSH
43227: LD_INT 1
43229: PUSH
43230: LD_INT 1
43232: NEG
43233: PUSH
43234: EMPTY
43235: LIST
43236: LIST
43237: PUSH
43238: EMPTY
43239: LIST
43240: LIST
43241: LIST
43242: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43243: LD_ADDR_VAR 0 60
43247: PUSH
43248: LD_INT 1
43250: PUSH
43251: LD_INT 1
43253: NEG
43254: PUSH
43255: EMPTY
43256: LIST
43257: LIST
43258: PUSH
43259: LD_INT 2
43261: PUSH
43262: LD_INT 0
43264: PUSH
43265: EMPTY
43266: LIST
43267: LIST
43268: PUSH
43269: LD_INT 2
43271: PUSH
43272: LD_INT 1
43274: PUSH
43275: EMPTY
43276: LIST
43277: LIST
43278: PUSH
43279: EMPTY
43280: LIST
43281: LIST
43282: LIST
43283: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43284: LD_ADDR_VAR 0 61
43288: PUSH
43289: LD_INT 2
43291: PUSH
43292: LD_INT 1
43294: PUSH
43295: EMPTY
43296: LIST
43297: LIST
43298: PUSH
43299: LD_INT 2
43301: PUSH
43302: LD_INT 2
43304: PUSH
43305: EMPTY
43306: LIST
43307: LIST
43308: PUSH
43309: LD_INT 1
43311: PUSH
43312: LD_INT 2
43314: PUSH
43315: EMPTY
43316: LIST
43317: LIST
43318: PUSH
43319: EMPTY
43320: LIST
43321: LIST
43322: LIST
43323: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43324: LD_ADDR_VAR 0 62
43328: PUSH
43329: LD_INT 1
43331: PUSH
43332: LD_INT 2
43334: PUSH
43335: EMPTY
43336: LIST
43337: LIST
43338: PUSH
43339: LD_INT 0
43341: PUSH
43342: LD_INT 2
43344: PUSH
43345: EMPTY
43346: LIST
43347: LIST
43348: PUSH
43349: LD_INT 1
43351: NEG
43352: PUSH
43353: LD_INT 1
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: EMPTY
43361: LIST
43362: LIST
43363: LIST
43364: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43365: LD_ADDR_VAR 0 63
43369: PUSH
43370: LD_INT 1
43372: NEG
43373: PUSH
43374: LD_INT 1
43376: PUSH
43377: EMPTY
43378: LIST
43379: LIST
43380: PUSH
43381: LD_INT 2
43383: NEG
43384: PUSH
43385: LD_INT 0
43387: PUSH
43388: EMPTY
43389: LIST
43390: LIST
43391: PUSH
43392: LD_INT 2
43394: NEG
43395: PUSH
43396: LD_INT 1
43398: NEG
43399: PUSH
43400: EMPTY
43401: LIST
43402: LIST
43403: PUSH
43404: EMPTY
43405: LIST
43406: LIST
43407: LIST
43408: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43409: LD_ADDR_VAR 0 64
43413: PUSH
43414: LD_INT 1
43416: NEG
43417: PUSH
43418: LD_INT 2
43420: NEG
43421: PUSH
43422: EMPTY
43423: LIST
43424: LIST
43425: PUSH
43426: LD_INT 2
43428: NEG
43429: PUSH
43430: LD_INT 1
43432: NEG
43433: PUSH
43434: EMPTY
43435: LIST
43436: LIST
43437: PUSH
43438: LD_INT 2
43440: NEG
43441: PUSH
43442: LD_INT 2
43444: NEG
43445: PUSH
43446: EMPTY
43447: LIST
43448: LIST
43449: PUSH
43450: EMPTY
43451: LIST
43452: LIST
43453: LIST
43454: ST_TO_ADDR
// end ; 2 :
43455: GO 46721
43457: LD_INT 2
43459: DOUBLE
43460: EQUAL
43461: IFTRUE 43465
43463: GO 46720
43465: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43466: LD_ADDR_VAR 0 29
43470: PUSH
43471: LD_INT 4
43473: PUSH
43474: LD_INT 0
43476: PUSH
43477: EMPTY
43478: LIST
43479: LIST
43480: PUSH
43481: LD_INT 4
43483: PUSH
43484: LD_INT 1
43486: NEG
43487: PUSH
43488: EMPTY
43489: LIST
43490: LIST
43491: PUSH
43492: LD_INT 5
43494: PUSH
43495: LD_INT 0
43497: PUSH
43498: EMPTY
43499: LIST
43500: LIST
43501: PUSH
43502: LD_INT 5
43504: PUSH
43505: LD_INT 1
43507: PUSH
43508: EMPTY
43509: LIST
43510: LIST
43511: PUSH
43512: LD_INT 4
43514: PUSH
43515: LD_INT 1
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: LD_INT 3
43524: PUSH
43525: LD_INT 0
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: PUSH
43532: LD_INT 3
43534: PUSH
43535: LD_INT 1
43537: NEG
43538: PUSH
43539: EMPTY
43540: LIST
43541: LIST
43542: PUSH
43543: LD_INT 3
43545: PUSH
43546: LD_INT 2
43548: NEG
43549: PUSH
43550: EMPTY
43551: LIST
43552: LIST
43553: PUSH
43554: LD_INT 5
43556: PUSH
43557: LD_INT 2
43559: PUSH
43560: EMPTY
43561: LIST
43562: LIST
43563: PUSH
43564: LD_INT 3
43566: PUSH
43567: LD_INT 3
43569: PUSH
43570: EMPTY
43571: LIST
43572: LIST
43573: PUSH
43574: LD_INT 3
43576: PUSH
43577: LD_INT 2
43579: PUSH
43580: EMPTY
43581: LIST
43582: LIST
43583: PUSH
43584: LD_INT 4
43586: PUSH
43587: LD_INT 3
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: PUSH
43594: LD_INT 4
43596: PUSH
43597: LD_INT 4
43599: PUSH
43600: EMPTY
43601: LIST
43602: LIST
43603: PUSH
43604: LD_INT 3
43606: PUSH
43607: LD_INT 4
43609: PUSH
43610: EMPTY
43611: LIST
43612: LIST
43613: PUSH
43614: LD_INT 2
43616: PUSH
43617: LD_INT 3
43619: PUSH
43620: EMPTY
43621: LIST
43622: LIST
43623: PUSH
43624: LD_INT 2
43626: PUSH
43627: LD_INT 2
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: LD_INT 4
43636: PUSH
43637: LD_INT 2
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: PUSH
43644: LD_INT 2
43646: PUSH
43647: LD_INT 4
43649: PUSH
43650: EMPTY
43651: LIST
43652: LIST
43653: PUSH
43654: LD_INT 0
43656: PUSH
43657: LD_INT 4
43659: PUSH
43660: EMPTY
43661: LIST
43662: LIST
43663: PUSH
43664: LD_INT 0
43666: PUSH
43667: LD_INT 3
43669: PUSH
43670: EMPTY
43671: LIST
43672: LIST
43673: PUSH
43674: LD_INT 1
43676: PUSH
43677: LD_INT 4
43679: PUSH
43680: EMPTY
43681: LIST
43682: LIST
43683: PUSH
43684: LD_INT 1
43686: PUSH
43687: LD_INT 5
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 0
43696: PUSH
43697: LD_INT 5
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: LD_INT 1
43706: NEG
43707: PUSH
43708: LD_INT 4
43710: PUSH
43711: EMPTY
43712: LIST
43713: LIST
43714: PUSH
43715: LD_INT 1
43717: NEG
43718: PUSH
43719: LD_INT 3
43721: PUSH
43722: EMPTY
43723: LIST
43724: LIST
43725: PUSH
43726: LD_INT 2
43728: PUSH
43729: LD_INT 5
43731: PUSH
43732: EMPTY
43733: LIST
43734: LIST
43735: PUSH
43736: LD_INT 2
43738: NEG
43739: PUSH
43740: LD_INT 3
43742: PUSH
43743: EMPTY
43744: LIST
43745: LIST
43746: PUSH
43747: LD_INT 3
43749: NEG
43750: PUSH
43751: LD_INT 0
43753: PUSH
43754: EMPTY
43755: LIST
43756: LIST
43757: PUSH
43758: LD_INT 3
43760: NEG
43761: PUSH
43762: LD_INT 1
43764: NEG
43765: PUSH
43766: EMPTY
43767: LIST
43768: LIST
43769: PUSH
43770: LD_INT 2
43772: NEG
43773: PUSH
43774: LD_INT 0
43776: PUSH
43777: EMPTY
43778: LIST
43779: LIST
43780: PUSH
43781: LD_INT 2
43783: NEG
43784: PUSH
43785: LD_INT 1
43787: PUSH
43788: EMPTY
43789: LIST
43790: LIST
43791: PUSH
43792: LD_INT 3
43794: NEG
43795: PUSH
43796: LD_INT 1
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: PUSH
43803: LD_INT 4
43805: NEG
43806: PUSH
43807: LD_INT 0
43809: PUSH
43810: EMPTY
43811: LIST
43812: LIST
43813: PUSH
43814: LD_INT 4
43816: NEG
43817: PUSH
43818: LD_INT 1
43820: NEG
43821: PUSH
43822: EMPTY
43823: LIST
43824: LIST
43825: PUSH
43826: LD_INT 4
43828: NEG
43829: PUSH
43830: LD_INT 2
43832: NEG
43833: PUSH
43834: EMPTY
43835: LIST
43836: LIST
43837: PUSH
43838: LD_INT 2
43840: NEG
43841: PUSH
43842: LD_INT 2
43844: PUSH
43845: EMPTY
43846: LIST
43847: LIST
43848: PUSH
43849: LD_INT 4
43851: NEG
43852: PUSH
43853: LD_INT 4
43855: NEG
43856: PUSH
43857: EMPTY
43858: LIST
43859: LIST
43860: PUSH
43861: LD_INT 4
43863: NEG
43864: PUSH
43865: LD_INT 5
43867: NEG
43868: PUSH
43869: EMPTY
43870: LIST
43871: LIST
43872: PUSH
43873: LD_INT 3
43875: NEG
43876: PUSH
43877: LD_INT 4
43879: NEG
43880: PUSH
43881: EMPTY
43882: LIST
43883: LIST
43884: PUSH
43885: LD_INT 3
43887: NEG
43888: PUSH
43889: LD_INT 3
43891: NEG
43892: PUSH
43893: EMPTY
43894: LIST
43895: LIST
43896: PUSH
43897: LD_INT 4
43899: NEG
43900: PUSH
43901: LD_INT 3
43903: NEG
43904: PUSH
43905: EMPTY
43906: LIST
43907: LIST
43908: PUSH
43909: LD_INT 5
43911: NEG
43912: PUSH
43913: LD_INT 4
43915: NEG
43916: PUSH
43917: EMPTY
43918: LIST
43919: LIST
43920: PUSH
43921: LD_INT 5
43923: NEG
43924: PUSH
43925: LD_INT 5
43927: NEG
43928: PUSH
43929: EMPTY
43930: LIST
43931: LIST
43932: PUSH
43933: LD_INT 3
43935: NEG
43936: PUSH
43937: LD_INT 5
43939: NEG
43940: PUSH
43941: EMPTY
43942: LIST
43943: LIST
43944: PUSH
43945: LD_INT 5
43947: NEG
43948: PUSH
43949: LD_INT 3
43951: NEG
43952: PUSH
43953: EMPTY
43954: LIST
43955: LIST
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: LIST
43961: LIST
43962: LIST
43963: LIST
43964: LIST
43965: LIST
43966: LIST
43967: LIST
43968: LIST
43969: LIST
43970: LIST
43971: LIST
43972: LIST
43973: LIST
43974: LIST
43975: LIST
43976: LIST
43977: LIST
43978: LIST
43979: LIST
43980: LIST
43981: LIST
43982: LIST
43983: LIST
43984: LIST
43985: LIST
43986: LIST
43987: LIST
43988: LIST
43989: LIST
43990: LIST
43991: LIST
43992: LIST
43993: LIST
43994: LIST
43995: LIST
43996: LIST
43997: LIST
43998: LIST
43999: LIST
44000: LIST
44001: LIST
44002: LIST
44003: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
44004: LD_ADDR_VAR 0 30
44008: PUSH
44009: LD_INT 4
44011: PUSH
44012: LD_INT 4
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: PUSH
44019: LD_INT 4
44021: PUSH
44022: LD_INT 3
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PUSH
44029: LD_INT 5
44031: PUSH
44032: LD_INT 4
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PUSH
44039: LD_INT 5
44041: PUSH
44042: LD_INT 5
44044: PUSH
44045: EMPTY
44046: LIST
44047: LIST
44048: PUSH
44049: LD_INT 4
44051: PUSH
44052: LD_INT 5
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: LD_INT 3
44061: PUSH
44062: LD_INT 4
44064: PUSH
44065: EMPTY
44066: LIST
44067: LIST
44068: PUSH
44069: LD_INT 3
44071: PUSH
44072: LD_INT 3
44074: PUSH
44075: EMPTY
44076: LIST
44077: LIST
44078: PUSH
44079: LD_INT 5
44081: PUSH
44082: LD_INT 3
44084: PUSH
44085: EMPTY
44086: LIST
44087: LIST
44088: PUSH
44089: LD_INT 3
44091: PUSH
44092: LD_INT 5
44094: PUSH
44095: EMPTY
44096: LIST
44097: LIST
44098: PUSH
44099: LD_INT 0
44101: PUSH
44102: LD_INT 3
44104: PUSH
44105: EMPTY
44106: LIST
44107: LIST
44108: PUSH
44109: LD_INT 0
44111: PUSH
44112: LD_INT 2
44114: PUSH
44115: EMPTY
44116: LIST
44117: LIST
44118: PUSH
44119: LD_INT 1
44121: PUSH
44122: LD_INT 3
44124: PUSH
44125: EMPTY
44126: LIST
44127: LIST
44128: PUSH
44129: LD_INT 1
44131: PUSH
44132: LD_INT 4
44134: PUSH
44135: EMPTY
44136: LIST
44137: LIST
44138: PUSH
44139: LD_INT 0
44141: PUSH
44142: LD_INT 4
44144: PUSH
44145: EMPTY
44146: LIST
44147: LIST
44148: PUSH
44149: LD_INT 1
44151: NEG
44152: PUSH
44153: LD_INT 3
44155: PUSH
44156: EMPTY
44157: LIST
44158: LIST
44159: PUSH
44160: LD_INT 1
44162: NEG
44163: PUSH
44164: LD_INT 2
44166: PUSH
44167: EMPTY
44168: LIST
44169: LIST
44170: PUSH
44171: LD_INT 2
44173: PUSH
44174: LD_INT 4
44176: PUSH
44177: EMPTY
44178: LIST
44179: LIST
44180: PUSH
44181: LD_INT 2
44183: NEG
44184: PUSH
44185: LD_INT 2
44187: PUSH
44188: EMPTY
44189: LIST
44190: LIST
44191: PUSH
44192: LD_INT 4
44194: NEG
44195: PUSH
44196: LD_INT 0
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PUSH
44203: LD_INT 4
44205: NEG
44206: PUSH
44207: LD_INT 1
44209: NEG
44210: PUSH
44211: EMPTY
44212: LIST
44213: LIST
44214: PUSH
44215: LD_INT 3
44217: NEG
44218: PUSH
44219: LD_INT 0
44221: PUSH
44222: EMPTY
44223: LIST
44224: LIST
44225: PUSH
44226: LD_INT 3
44228: NEG
44229: PUSH
44230: LD_INT 1
44232: PUSH
44233: EMPTY
44234: LIST
44235: LIST
44236: PUSH
44237: LD_INT 4
44239: NEG
44240: PUSH
44241: LD_INT 1
44243: PUSH
44244: EMPTY
44245: LIST
44246: LIST
44247: PUSH
44248: LD_INT 5
44250: NEG
44251: PUSH
44252: LD_INT 0
44254: PUSH
44255: EMPTY
44256: LIST
44257: LIST
44258: PUSH
44259: LD_INT 5
44261: NEG
44262: PUSH
44263: LD_INT 1
44265: NEG
44266: PUSH
44267: EMPTY
44268: LIST
44269: LIST
44270: PUSH
44271: LD_INT 5
44273: NEG
44274: PUSH
44275: LD_INT 2
44277: NEG
44278: PUSH
44279: EMPTY
44280: LIST
44281: LIST
44282: PUSH
44283: LD_INT 3
44285: NEG
44286: PUSH
44287: LD_INT 2
44289: PUSH
44290: EMPTY
44291: LIST
44292: LIST
44293: PUSH
44294: LD_INT 3
44296: NEG
44297: PUSH
44298: LD_INT 3
44300: NEG
44301: PUSH
44302: EMPTY
44303: LIST
44304: LIST
44305: PUSH
44306: LD_INT 3
44308: NEG
44309: PUSH
44310: LD_INT 4
44312: NEG
44313: PUSH
44314: EMPTY
44315: LIST
44316: LIST
44317: PUSH
44318: LD_INT 2
44320: NEG
44321: PUSH
44322: LD_INT 3
44324: NEG
44325: PUSH
44326: EMPTY
44327: LIST
44328: LIST
44329: PUSH
44330: LD_INT 2
44332: NEG
44333: PUSH
44334: LD_INT 2
44336: NEG
44337: PUSH
44338: EMPTY
44339: LIST
44340: LIST
44341: PUSH
44342: LD_INT 3
44344: NEG
44345: PUSH
44346: LD_INT 2
44348: NEG
44349: PUSH
44350: EMPTY
44351: LIST
44352: LIST
44353: PUSH
44354: LD_INT 4
44356: NEG
44357: PUSH
44358: LD_INT 3
44360: NEG
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: PUSH
44366: LD_INT 4
44368: NEG
44369: PUSH
44370: LD_INT 4
44372: NEG
44373: PUSH
44374: EMPTY
44375: LIST
44376: LIST
44377: PUSH
44378: LD_INT 2
44380: NEG
44381: PUSH
44382: LD_INT 4
44384: NEG
44385: PUSH
44386: EMPTY
44387: LIST
44388: LIST
44389: PUSH
44390: LD_INT 4
44392: NEG
44393: PUSH
44394: LD_INT 2
44396: NEG
44397: PUSH
44398: EMPTY
44399: LIST
44400: LIST
44401: PUSH
44402: LD_INT 0
44404: PUSH
44405: LD_INT 4
44407: NEG
44408: PUSH
44409: EMPTY
44410: LIST
44411: LIST
44412: PUSH
44413: LD_INT 0
44415: PUSH
44416: LD_INT 5
44418: NEG
44419: PUSH
44420: EMPTY
44421: LIST
44422: LIST
44423: PUSH
44424: LD_INT 1
44426: PUSH
44427: LD_INT 4
44429: NEG
44430: PUSH
44431: EMPTY
44432: LIST
44433: LIST
44434: PUSH
44435: LD_INT 1
44437: PUSH
44438: LD_INT 3
44440: NEG
44441: PUSH
44442: EMPTY
44443: LIST
44444: LIST
44445: PUSH
44446: LD_INT 0
44448: PUSH
44449: LD_INT 3
44451: NEG
44452: PUSH
44453: EMPTY
44454: LIST
44455: LIST
44456: PUSH
44457: LD_INT 1
44459: NEG
44460: PUSH
44461: LD_INT 4
44463: NEG
44464: PUSH
44465: EMPTY
44466: LIST
44467: LIST
44468: PUSH
44469: LD_INT 1
44471: NEG
44472: PUSH
44473: LD_INT 5
44475: NEG
44476: PUSH
44477: EMPTY
44478: LIST
44479: LIST
44480: PUSH
44481: LD_INT 2
44483: PUSH
44484: LD_INT 3
44486: NEG
44487: PUSH
44488: EMPTY
44489: LIST
44490: LIST
44491: PUSH
44492: LD_INT 2
44494: NEG
44495: PUSH
44496: LD_INT 5
44498: NEG
44499: PUSH
44500: EMPTY
44501: LIST
44502: LIST
44503: PUSH
44504: EMPTY
44505: LIST
44506: LIST
44507: LIST
44508: LIST
44509: LIST
44510: LIST
44511: LIST
44512: LIST
44513: LIST
44514: LIST
44515: LIST
44516: LIST
44517: LIST
44518: LIST
44519: LIST
44520: LIST
44521: LIST
44522: LIST
44523: LIST
44524: LIST
44525: LIST
44526: LIST
44527: LIST
44528: LIST
44529: LIST
44530: LIST
44531: LIST
44532: LIST
44533: LIST
44534: LIST
44535: LIST
44536: LIST
44537: LIST
44538: LIST
44539: LIST
44540: LIST
44541: LIST
44542: LIST
44543: LIST
44544: LIST
44545: LIST
44546: LIST
44547: LIST
44548: LIST
44549: LIST
44550: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44551: LD_ADDR_VAR 0 31
44555: PUSH
44556: LD_INT 0
44558: PUSH
44559: LD_INT 4
44561: PUSH
44562: EMPTY
44563: LIST
44564: LIST
44565: PUSH
44566: LD_INT 0
44568: PUSH
44569: LD_INT 3
44571: PUSH
44572: EMPTY
44573: LIST
44574: LIST
44575: PUSH
44576: LD_INT 1
44578: PUSH
44579: LD_INT 4
44581: PUSH
44582: EMPTY
44583: LIST
44584: LIST
44585: PUSH
44586: LD_INT 1
44588: PUSH
44589: LD_INT 5
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: PUSH
44596: LD_INT 0
44598: PUSH
44599: LD_INT 5
44601: PUSH
44602: EMPTY
44603: LIST
44604: LIST
44605: PUSH
44606: LD_INT 1
44608: NEG
44609: PUSH
44610: LD_INT 4
44612: PUSH
44613: EMPTY
44614: LIST
44615: LIST
44616: PUSH
44617: LD_INT 1
44619: NEG
44620: PUSH
44621: LD_INT 3
44623: PUSH
44624: EMPTY
44625: LIST
44626: LIST
44627: PUSH
44628: LD_INT 2
44630: PUSH
44631: LD_INT 5
44633: PUSH
44634: EMPTY
44635: LIST
44636: LIST
44637: PUSH
44638: LD_INT 2
44640: NEG
44641: PUSH
44642: LD_INT 3
44644: PUSH
44645: EMPTY
44646: LIST
44647: LIST
44648: PUSH
44649: LD_INT 3
44651: NEG
44652: PUSH
44653: LD_INT 0
44655: PUSH
44656: EMPTY
44657: LIST
44658: LIST
44659: PUSH
44660: LD_INT 3
44662: NEG
44663: PUSH
44664: LD_INT 1
44666: NEG
44667: PUSH
44668: EMPTY
44669: LIST
44670: LIST
44671: PUSH
44672: LD_INT 2
44674: NEG
44675: PUSH
44676: LD_INT 0
44678: PUSH
44679: EMPTY
44680: LIST
44681: LIST
44682: PUSH
44683: LD_INT 2
44685: NEG
44686: PUSH
44687: LD_INT 1
44689: PUSH
44690: EMPTY
44691: LIST
44692: LIST
44693: PUSH
44694: LD_INT 3
44696: NEG
44697: PUSH
44698: LD_INT 1
44700: PUSH
44701: EMPTY
44702: LIST
44703: LIST
44704: PUSH
44705: LD_INT 4
44707: NEG
44708: PUSH
44709: LD_INT 0
44711: PUSH
44712: EMPTY
44713: LIST
44714: LIST
44715: PUSH
44716: LD_INT 4
44718: NEG
44719: PUSH
44720: LD_INT 1
44722: NEG
44723: PUSH
44724: EMPTY
44725: LIST
44726: LIST
44727: PUSH
44728: LD_INT 4
44730: NEG
44731: PUSH
44732: LD_INT 2
44734: NEG
44735: PUSH
44736: EMPTY
44737: LIST
44738: LIST
44739: PUSH
44740: LD_INT 2
44742: NEG
44743: PUSH
44744: LD_INT 2
44746: PUSH
44747: EMPTY
44748: LIST
44749: LIST
44750: PUSH
44751: LD_INT 4
44753: NEG
44754: PUSH
44755: LD_INT 4
44757: NEG
44758: PUSH
44759: EMPTY
44760: LIST
44761: LIST
44762: PUSH
44763: LD_INT 4
44765: NEG
44766: PUSH
44767: LD_INT 5
44769: NEG
44770: PUSH
44771: EMPTY
44772: LIST
44773: LIST
44774: PUSH
44775: LD_INT 3
44777: NEG
44778: PUSH
44779: LD_INT 4
44781: NEG
44782: PUSH
44783: EMPTY
44784: LIST
44785: LIST
44786: PUSH
44787: LD_INT 3
44789: NEG
44790: PUSH
44791: LD_INT 3
44793: NEG
44794: PUSH
44795: EMPTY
44796: LIST
44797: LIST
44798: PUSH
44799: LD_INT 4
44801: NEG
44802: PUSH
44803: LD_INT 3
44805: NEG
44806: PUSH
44807: EMPTY
44808: LIST
44809: LIST
44810: PUSH
44811: LD_INT 5
44813: NEG
44814: PUSH
44815: LD_INT 4
44817: NEG
44818: PUSH
44819: EMPTY
44820: LIST
44821: LIST
44822: PUSH
44823: LD_INT 5
44825: NEG
44826: PUSH
44827: LD_INT 5
44829: NEG
44830: PUSH
44831: EMPTY
44832: LIST
44833: LIST
44834: PUSH
44835: LD_INT 3
44837: NEG
44838: PUSH
44839: LD_INT 5
44841: NEG
44842: PUSH
44843: EMPTY
44844: LIST
44845: LIST
44846: PUSH
44847: LD_INT 5
44849: NEG
44850: PUSH
44851: LD_INT 3
44853: NEG
44854: PUSH
44855: EMPTY
44856: LIST
44857: LIST
44858: PUSH
44859: LD_INT 0
44861: PUSH
44862: LD_INT 3
44864: NEG
44865: PUSH
44866: EMPTY
44867: LIST
44868: LIST
44869: PUSH
44870: LD_INT 0
44872: PUSH
44873: LD_INT 4
44875: NEG
44876: PUSH
44877: EMPTY
44878: LIST
44879: LIST
44880: PUSH
44881: LD_INT 1
44883: PUSH
44884: LD_INT 3
44886: NEG
44887: PUSH
44888: EMPTY
44889: LIST
44890: LIST
44891: PUSH
44892: LD_INT 1
44894: PUSH
44895: LD_INT 2
44897: NEG
44898: PUSH
44899: EMPTY
44900: LIST
44901: LIST
44902: PUSH
44903: LD_INT 0
44905: PUSH
44906: LD_INT 2
44908: NEG
44909: PUSH
44910: EMPTY
44911: LIST
44912: LIST
44913: PUSH
44914: LD_INT 1
44916: NEG
44917: PUSH
44918: LD_INT 3
44920: NEG
44921: PUSH
44922: EMPTY
44923: LIST
44924: LIST
44925: PUSH
44926: LD_INT 1
44928: NEG
44929: PUSH
44930: LD_INT 4
44932: NEG
44933: PUSH
44934: EMPTY
44935: LIST
44936: LIST
44937: PUSH
44938: LD_INT 2
44940: PUSH
44941: LD_INT 2
44943: NEG
44944: PUSH
44945: EMPTY
44946: LIST
44947: LIST
44948: PUSH
44949: LD_INT 2
44951: NEG
44952: PUSH
44953: LD_INT 4
44955: NEG
44956: PUSH
44957: EMPTY
44958: LIST
44959: LIST
44960: PUSH
44961: LD_INT 4
44963: PUSH
44964: LD_INT 0
44966: PUSH
44967: EMPTY
44968: LIST
44969: LIST
44970: PUSH
44971: LD_INT 4
44973: PUSH
44974: LD_INT 1
44976: NEG
44977: PUSH
44978: EMPTY
44979: LIST
44980: LIST
44981: PUSH
44982: LD_INT 5
44984: PUSH
44985: LD_INT 0
44987: PUSH
44988: EMPTY
44989: LIST
44990: LIST
44991: PUSH
44992: LD_INT 5
44994: PUSH
44995: LD_INT 1
44997: PUSH
44998: EMPTY
44999: LIST
45000: LIST
45001: PUSH
45002: LD_INT 4
45004: PUSH
45005: LD_INT 1
45007: PUSH
45008: EMPTY
45009: LIST
45010: LIST
45011: PUSH
45012: LD_INT 3
45014: PUSH
45015: LD_INT 0
45017: PUSH
45018: EMPTY
45019: LIST
45020: LIST
45021: PUSH
45022: LD_INT 3
45024: PUSH
45025: LD_INT 1
45027: NEG
45028: PUSH
45029: EMPTY
45030: LIST
45031: LIST
45032: PUSH
45033: LD_INT 3
45035: PUSH
45036: LD_INT 2
45038: NEG
45039: PUSH
45040: EMPTY
45041: LIST
45042: LIST
45043: PUSH
45044: LD_INT 5
45046: PUSH
45047: LD_INT 2
45049: PUSH
45050: EMPTY
45051: LIST
45052: LIST
45053: PUSH
45054: EMPTY
45055: LIST
45056: LIST
45057: LIST
45058: LIST
45059: LIST
45060: LIST
45061: LIST
45062: LIST
45063: LIST
45064: LIST
45065: LIST
45066: LIST
45067: LIST
45068: LIST
45069: LIST
45070: LIST
45071: LIST
45072: LIST
45073: LIST
45074: LIST
45075: LIST
45076: LIST
45077: LIST
45078: LIST
45079: LIST
45080: LIST
45081: LIST
45082: LIST
45083: LIST
45084: LIST
45085: LIST
45086: LIST
45087: LIST
45088: LIST
45089: LIST
45090: LIST
45091: LIST
45092: LIST
45093: LIST
45094: LIST
45095: LIST
45096: LIST
45097: LIST
45098: LIST
45099: LIST
45100: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45101: LD_ADDR_VAR 0 32
45105: PUSH
45106: LD_INT 4
45108: NEG
45109: PUSH
45110: LD_INT 0
45112: PUSH
45113: EMPTY
45114: LIST
45115: LIST
45116: PUSH
45117: LD_INT 4
45119: NEG
45120: PUSH
45121: LD_INT 1
45123: NEG
45124: PUSH
45125: EMPTY
45126: LIST
45127: LIST
45128: PUSH
45129: LD_INT 3
45131: NEG
45132: PUSH
45133: LD_INT 0
45135: PUSH
45136: EMPTY
45137: LIST
45138: LIST
45139: PUSH
45140: LD_INT 3
45142: NEG
45143: PUSH
45144: LD_INT 1
45146: PUSH
45147: EMPTY
45148: LIST
45149: LIST
45150: PUSH
45151: LD_INT 4
45153: NEG
45154: PUSH
45155: LD_INT 1
45157: PUSH
45158: EMPTY
45159: LIST
45160: LIST
45161: PUSH
45162: LD_INT 5
45164: NEG
45165: PUSH
45166: LD_INT 0
45168: PUSH
45169: EMPTY
45170: LIST
45171: LIST
45172: PUSH
45173: LD_INT 5
45175: NEG
45176: PUSH
45177: LD_INT 1
45179: NEG
45180: PUSH
45181: EMPTY
45182: LIST
45183: LIST
45184: PUSH
45185: LD_INT 5
45187: NEG
45188: PUSH
45189: LD_INT 2
45191: NEG
45192: PUSH
45193: EMPTY
45194: LIST
45195: LIST
45196: PUSH
45197: LD_INT 3
45199: NEG
45200: PUSH
45201: LD_INT 2
45203: PUSH
45204: EMPTY
45205: LIST
45206: LIST
45207: PUSH
45208: LD_INT 3
45210: NEG
45211: PUSH
45212: LD_INT 3
45214: NEG
45215: PUSH
45216: EMPTY
45217: LIST
45218: LIST
45219: PUSH
45220: LD_INT 3
45222: NEG
45223: PUSH
45224: LD_INT 4
45226: NEG
45227: PUSH
45228: EMPTY
45229: LIST
45230: LIST
45231: PUSH
45232: LD_INT 2
45234: NEG
45235: PUSH
45236: LD_INT 3
45238: NEG
45239: PUSH
45240: EMPTY
45241: LIST
45242: LIST
45243: PUSH
45244: LD_INT 2
45246: NEG
45247: PUSH
45248: LD_INT 2
45250: NEG
45251: PUSH
45252: EMPTY
45253: LIST
45254: LIST
45255: PUSH
45256: LD_INT 3
45258: NEG
45259: PUSH
45260: LD_INT 2
45262: NEG
45263: PUSH
45264: EMPTY
45265: LIST
45266: LIST
45267: PUSH
45268: LD_INT 4
45270: NEG
45271: PUSH
45272: LD_INT 3
45274: NEG
45275: PUSH
45276: EMPTY
45277: LIST
45278: LIST
45279: PUSH
45280: LD_INT 4
45282: NEG
45283: PUSH
45284: LD_INT 4
45286: NEG
45287: PUSH
45288: EMPTY
45289: LIST
45290: LIST
45291: PUSH
45292: LD_INT 2
45294: NEG
45295: PUSH
45296: LD_INT 4
45298: NEG
45299: PUSH
45300: EMPTY
45301: LIST
45302: LIST
45303: PUSH
45304: LD_INT 4
45306: NEG
45307: PUSH
45308: LD_INT 2
45310: NEG
45311: PUSH
45312: EMPTY
45313: LIST
45314: LIST
45315: PUSH
45316: LD_INT 0
45318: PUSH
45319: LD_INT 4
45321: NEG
45322: PUSH
45323: EMPTY
45324: LIST
45325: LIST
45326: PUSH
45327: LD_INT 0
45329: PUSH
45330: LD_INT 5
45332: NEG
45333: PUSH
45334: EMPTY
45335: LIST
45336: LIST
45337: PUSH
45338: LD_INT 1
45340: PUSH
45341: LD_INT 4
45343: NEG
45344: PUSH
45345: EMPTY
45346: LIST
45347: LIST
45348: PUSH
45349: LD_INT 1
45351: PUSH
45352: LD_INT 3
45354: NEG
45355: PUSH
45356: EMPTY
45357: LIST
45358: LIST
45359: PUSH
45360: LD_INT 0
45362: PUSH
45363: LD_INT 3
45365: NEG
45366: PUSH
45367: EMPTY
45368: LIST
45369: LIST
45370: PUSH
45371: LD_INT 1
45373: NEG
45374: PUSH
45375: LD_INT 4
45377: NEG
45378: PUSH
45379: EMPTY
45380: LIST
45381: LIST
45382: PUSH
45383: LD_INT 1
45385: NEG
45386: PUSH
45387: LD_INT 5
45389: NEG
45390: PUSH
45391: EMPTY
45392: LIST
45393: LIST
45394: PUSH
45395: LD_INT 2
45397: PUSH
45398: LD_INT 3
45400: NEG
45401: PUSH
45402: EMPTY
45403: LIST
45404: LIST
45405: PUSH
45406: LD_INT 2
45408: NEG
45409: PUSH
45410: LD_INT 5
45412: NEG
45413: PUSH
45414: EMPTY
45415: LIST
45416: LIST
45417: PUSH
45418: LD_INT 3
45420: PUSH
45421: LD_INT 0
45423: PUSH
45424: EMPTY
45425: LIST
45426: LIST
45427: PUSH
45428: LD_INT 3
45430: PUSH
45431: LD_INT 1
45433: NEG
45434: PUSH
45435: EMPTY
45436: LIST
45437: LIST
45438: PUSH
45439: LD_INT 4
45441: PUSH
45442: LD_INT 0
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: PUSH
45449: LD_INT 4
45451: PUSH
45452: LD_INT 1
45454: PUSH
45455: EMPTY
45456: LIST
45457: LIST
45458: PUSH
45459: LD_INT 3
45461: PUSH
45462: LD_INT 1
45464: PUSH
45465: EMPTY
45466: LIST
45467: LIST
45468: PUSH
45469: LD_INT 2
45471: PUSH
45472: LD_INT 0
45474: PUSH
45475: EMPTY
45476: LIST
45477: LIST
45478: PUSH
45479: LD_INT 2
45481: PUSH
45482: LD_INT 1
45484: NEG
45485: PUSH
45486: EMPTY
45487: LIST
45488: LIST
45489: PUSH
45490: LD_INT 2
45492: PUSH
45493: LD_INT 2
45495: NEG
45496: PUSH
45497: EMPTY
45498: LIST
45499: LIST
45500: PUSH
45501: LD_INT 4
45503: PUSH
45504: LD_INT 2
45506: PUSH
45507: EMPTY
45508: LIST
45509: LIST
45510: PUSH
45511: LD_INT 4
45513: PUSH
45514: LD_INT 4
45516: PUSH
45517: EMPTY
45518: LIST
45519: LIST
45520: PUSH
45521: LD_INT 4
45523: PUSH
45524: LD_INT 3
45526: PUSH
45527: EMPTY
45528: LIST
45529: LIST
45530: PUSH
45531: LD_INT 5
45533: PUSH
45534: LD_INT 4
45536: PUSH
45537: EMPTY
45538: LIST
45539: LIST
45540: PUSH
45541: LD_INT 5
45543: PUSH
45544: LD_INT 5
45546: PUSH
45547: EMPTY
45548: LIST
45549: LIST
45550: PUSH
45551: LD_INT 4
45553: PUSH
45554: LD_INT 5
45556: PUSH
45557: EMPTY
45558: LIST
45559: LIST
45560: PUSH
45561: LD_INT 3
45563: PUSH
45564: LD_INT 4
45566: PUSH
45567: EMPTY
45568: LIST
45569: LIST
45570: PUSH
45571: LD_INT 3
45573: PUSH
45574: LD_INT 3
45576: PUSH
45577: EMPTY
45578: LIST
45579: LIST
45580: PUSH
45581: LD_INT 5
45583: PUSH
45584: LD_INT 3
45586: PUSH
45587: EMPTY
45588: LIST
45589: LIST
45590: PUSH
45591: LD_INT 3
45593: PUSH
45594: LD_INT 5
45596: PUSH
45597: EMPTY
45598: LIST
45599: LIST
45600: PUSH
45601: EMPTY
45602: LIST
45603: LIST
45604: LIST
45605: LIST
45606: LIST
45607: LIST
45608: LIST
45609: LIST
45610: LIST
45611: LIST
45612: LIST
45613: LIST
45614: LIST
45615: LIST
45616: LIST
45617: LIST
45618: LIST
45619: LIST
45620: LIST
45621: LIST
45622: LIST
45623: LIST
45624: LIST
45625: LIST
45626: LIST
45627: LIST
45628: LIST
45629: LIST
45630: LIST
45631: LIST
45632: LIST
45633: LIST
45634: LIST
45635: LIST
45636: LIST
45637: LIST
45638: LIST
45639: LIST
45640: LIST
45641: LIST
45642: LIST
45643: LIST
45644: LIST
45645: LIST
45646: LIST
45647: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45648: LD_ADDR_VAR 0 33
45652: PUSH
45653: LD_INT 4
45655: NEG
45656: PUSH
45657: LD_INT 4
45659: NEG
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: PUSH
45665: LD_INT 4
45667: NEG
45668: PUSH
45669: LD_INT 5
45671: NEG
45672: PUSH
45673: EMPTY
45674: LIST
45675: LIST
45676: PUSH
45677: LD_INT 3
45679: NEG
45680: PUSH
45681: LD_INT 4
45683: NEG
45684: PUSH
45685: EMPTY
45686: LIST
45687: LIST
45688: PUSH
45689: LD_INT 3
45691: NEG
45692: PUSH
45693: LD_INT 3
45695: NEG
45696: PUSH
45697: EMPTY
45698: LIST
45699: LIST
45700: PUSH
45701: LD_INT 4
45703: NEG
45704: PUSH
45705: LD_INT 3
45707: NEG
45708: PUSH
45709: EMPTY
45710: LIST
45711: LIST
45712: PUSH
45713: LD_INT 5
45715: NEG
45716: PUSH
45717: LD_INT 4
45719: NEG
45720: PUSH
45721: EMPTY
45722: LIST
45723: LIST
45724: PUSH
45725: LD_INT 5
45727: NEG
45728: PUSH
45729: LD_INT 5
45731: NEG
45732: PUSH
45733: EMPTY
45734: LIST
45735: LIST
45736: PUSH
45737: LD_INT 3
45739: NEG
45740: PUSH
45741: LD_INT 5
45743: NEG
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PUSH
45749: LD_INT 5
45751: NEG
45752: PUSH
45753: LD_INT 3
45755: NEG
45756: PUSH
45757: EMPTY
45758: LIST
45759: LIST
45760: PUSH
45761: LD_INT 0
45763: PUSH
45764: LD_INT 3
45766: NEG
45767: PUSH
45768: EMPTY
45769: LIST
45770: LIST
45771: PUSH
45772: LD_INT 0
45774: PUSH
45775: LD_INT 4
45777: NEG
45778: PUSH
45779: EMPTY
45780: LIST
45781: LIST
45782: PUSH
45783: LD_INT 1
45785: PUSH
45786: LD_INT 3
45788: NEG
45789: PUSH
45790: EMPTY
45791: LIST
45792: LIST
45793: PUSH
45794: LD_INT 1
45796: PUSH
45797: LD_INT 2
45799: NEG
45800: PUSH
45801: EMPTY
45802: LIST
45803: LIST
45804: PUSH
45805: LD_INT 0
45807: PUSH
45808: LD_INT 2
45810: NEG
45811: PUSH
45812: EMPTY
45813: LIST
45814: LIST
45815: PUSH
45816: LD_INT 1
45818: NEG
45819: PUSH
45820: LD_INT 3
45822: NEG
45823: PUSH
45824: EMPTY
45825: LIST
45826: LIST
45827: PUSH
45828: LD_INT 1
45830: NEG
45831: PUSH
45832: LD_INT 4
45834: NEG
45835: PUSH
45836: EMPTY
45837: LIST
45838: LIST
45839: PUSH
45840: LD_INT 2
45842: PUSH
45843: LD_INT 2
45845: NEG
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: PUSH
45851: LD_INT 2
45853: NEG
45854: PUSH
45855: LD_INT 4
45857: NEG
45858: PUSH
45859: EMPTY
45860: LIST
45861: LIST
45862: PUSH
45863: LD_INT 4
45865: PUSH
45866: LD_INT 0
45868: PUSH
45869: EMPTY
45870: LIST
45871: LIST
45872: PUSH
45873: LD_INT 4
45875: PUSH
45876: LD_INT 1
45878: NEG
45879: PUSH
45880: EMPTY
45881: LIST
45882: LIST
45883: PUSH
45884: LD_INT 5
45886: PUSH
45887: LD_INT 0
45889: PUSH
45890: EMPTY
45891: LIST
45892: LIST
45893: PUSH
45894: LD_INT 5
45896: PUSH
45897: LD_INT 1
45899: PUSH
45900: EMPTY
45901: LIST
45902: LIST
45903: PUSH
45904: LD_INT 4
45906: PUSH
45907: LD_INT 1
45909: PUSH
45910: EMPTY
45911: LIST
45912: LIST
45913: PUSH
45914: LD_INT 3
45916: PUSH
45917: LD_INT 0
45919: PUSH
45920: EMPTY
45921: LIST
45922: LIST
45923: PUSH
45924: LD_INT 3
45926: PUSH
45927: LD_INT 1
45929: NEG
45930: PUSH
45931: EMPTY
45932: LIST
45933: LIST
45934: PUSH
45935: LD_INT 3
45937: PUSH
45938: LD_INT 2
45940: NEG
45941: PUSH
45942: EMPTY
45943: LIST
45944: LIST
45945: PUSH
45946: LD_INT 5
45948: PUSH
45949: LD_INT 2
45951: PUSH
45952: EMPTY
45953: LIST
45954: LIST
45955: PUSH
45956: LD_INT 3
45958: PUSH
45959: LD_INT 3
45961: PUSH
45962: EMPTY
45963: LIST
45964: LIST
45965: PUSH
45966: LD_INT 3
45968: PUSH
45969: LD_INT 2
45971: PUSH
45972: EMPTY
45973: LIST
45974: LIST
45975: PUSH
45976: LD_INT 4
45978: PUSH
45979: LD_INT 3
45981: PUSH
45982: EMPTY
45983: LIST
45984: LIST
45985: PUSH
45986: LD_INT 4
45988: PUSH
45989: LD_INT 4
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: PUSH
45996: LD_INT 3
45998: PUSH
45999: LD_INT 4
46001: PUSH
46002: EMPTY
46003: LIST
46004: LIST
46005: PUSH
46006: LD_INT 2
46008: PUSH
46009: LD_INT 3
46011: PUSH
46012: EMPTY
46013: LIST
46014: LIST
46015: PUSH
46016: LD_INT 2
46018: PUSH
46019: LD_INT 2
46021: PUSH
46022: EMPTY
46023: LIST
46024: LIST
46025: PUSH
46026: LD_INT 4
46028: PUSH
46029: LD_INT 2
46031: PUSH
46032: EMPTY
46033: LIST
46034: LIST
46035: PUSH
46036: LD_INT 2
46038: PUSH
46039: LD_INT 4
46041: PUSH
46042: EMPTY
46043: LIST
46044: LIST
46045: PUSH
46046: LD_INT 0
46048: PUSH
46049: LD_INT 4
46051: PUSH
46052: EMPTY
46053: LIST
46054: LIST
46055: PUSH
46056: LD_INT 0
46058: PUSH
46059: LD_INT 3
46061: PUSH
46062: EMPTY
46063: LIST
46064: LIST
46065: PUSH
46066: LD_INT 1
46068: PUSH
46069: LD_INT 4
46071: PUSH
46072: EMPTY
46073: LIST
46074: LIST
46075: PUSH
46076: LD_INT 1
46078: PUSH
46079: LD_INT 5
46081: PUSH
46082: EMPTY
46083: LIST
46084: LIST
46085: PUSH
46086: LD_INT 0
46088: PUSH
46089: LD_INT 5
46091: PUSH
46092: EMPTY
46093: LIST
46094: LIST
46095: PUSH
46096: LD_INT 1
46098: NEG
46099: PUSH
46100: LD_INT 4
46102: PUSH
46103: EMPTY
46104: LIST
46105: LIST
46106: PUSH
46107: LD_INT 1
46109: NEG
46110: PUSH
46111: LD_INT 3
46113: PUSH
46114: EMPTY
46115: LIST
46116: LIST
46117: PUSH
46118: LD_INT 2
46120: PUSH
46121: LD_INT 5
46123: PUSH
46124: EMPTY
46125: LIST
46126: LIST
46127: PUSH
46128: LD_INT 2
46130: NEG
46131: PUSH
46132: LD_INT 3
46134: PUSH
46135: EMPTY
46136: LIST
46137: LIST
46138: PUSH
46139: EMPTY
46140: LIST
46141: LIST
46142: LIST
46143: LIST
46144: LIST
46145: LIST
46146: LIST
46147: LIST
46148: LIST
46149: LIST
46150: LIST
46151: LIST
46152: LIST
46153: LIST
46154: LIST
46155: LIST
46156: LIST
46157: LIST
46158: LIST
46159: LIST
46160: LIST
46161: LIST
46162: LIST
46163: LIST
46164: LIST
46165: LIST
46166: LIST
46167: LIST
46168: LIST
46169: LIST
46170: LIST
46171: LIST
46172: LIST
46173: LIST
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: LIST
46181: LIST
46182: LIST
46183: LIST
46184: LIST
46185: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46186: LD_ADDR_VAR 0 34
46190: PUSH
46191: LD_INT 0
46193: PUSH
46194: LD_INT 4
46196: NEG
46197: PUSH
46198: EMPTY
46199: LIST
46200: LIST
46201: PUSH
46202: LD_INT 0
46204: PUSH
46205: LD_INT 5
46207: NEG
46208: PUSH
46209: EMPTY
46210: LIST
46211: LIST
46212: PUSH
46213: LD_INT 1
46215: PUSH
46216: LD_INT 4
46218: NEG
46219: PUSH
46220: EMPTY
46221: LIST
46222: LIST
46223: PUSH
46224: LD_INT 1
46226: PUSH
46227: LD_INT 3
46229: NEG
46230: PUSH
46231: EMPTY
46232: LIST
46233: LIST
46234: PUSH
46235: LD_INT 0
46237: PUSH
46238: LD_INT 3
46240: NEG
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: PUSH
46246: LD_INT 1
46248: NEG
46249: PUSH
46250: LD_INT 4
46252: NEG
46253: PUSH
46254: EMPTY
46255: LIST
46256: LIST
46257: PUSH
46258: LD_INT 1
46260: NEG
46261: PUSH
46262: LD_INT 5
46264: NEG
46265: PUSH
46266: EMPTY
46267: LIST
46268: LIST
46269: PUSH
46270: LD_INT 2
46272: PUSH
46273: LD_INT 3
46275: NEG
46276: PUSH
46277: EMPTY
46278: LIST
46279: LIST
46280: PUSH
46281: LD_INT 2
46283: NEG
46284: PUSH
46285: LD_INT 5
46287: NEG
46288: PUSH
46289: EMPTY
46290: LIST
46291: LIST
46292: PUSH
46293: LD_INT 3
46295: PUSH
46296: LD_INT 0
46298: PUSH
46299: EMPTY
46300: LIST
46301: LIST
46302: PUSH
46303: LD_INT 3
46305: PUSH
46306: LD_INT 1
46308: NEG
46309: PUSH
46310: EMPTY
46311: LIST
46312: LIST
46313: PUSH
46314: LD_INT 4
46316: PUSH
46317: LD_INT 0
46319: PUSH
46320: EMPTY
46321: LIST
46322: LIST
46323: PUSH
46324: LD_INT 4
46326: PUSH
46327: LD_INT 1
46329: PUSH
46330: EMPTY
46331: LIST
46332: LIST
46333: PUSH
46334: LD_INT 3
46336: PUSH
46337: LD_INT 1
46339: PUSH
46340: EMPTY
46341: LIST
46342: LIST
46343: PUSH
46344: LD_INT 2
46346: PUSH
46347: LD_INT 0
46349: PUSH
46350: EMPTY
46351: LIST
46352: LIST
46353: PUSH
46354: LD_INT 2
46356: PUSH
46357: LD_INT 1
46359: NEG
46360: PUSH
46361: EMPTY
46362: LIST
46363: LIST
46364: PUSH
46365: LD_INT 2
46367: PUSH
46368: LD_INT 2
46370: NEG
46371: PUSH
46372: EMPTY
46373: LIST
46374: LIST
46375: PUSH
46376: LD_INT 4
46378: PUSH
46379: LD_INT 2
46381: PUSH
46382: EMPTY
46383: LIST
46384: LIST
46385: PUSH
46386: LD_INT 4
46388: PUSH
46389: LD_INT 4
46391: PUSH
46392: EMPTY
46393: LIST
46394: LIST
46395: PUSH
46396: LD_INT 4
46398: PUSH
46399: LD_INT 3
46401: PUSH
46402: EMPTY
46403: LIST
46404: LIST
46405: PUSH
46406: LD_INT 5
46408: PUSH
46409: LD_INT 4
46411: PUSH
46412: EMPTY
46413: LIST
46414: LIST
46415: PUSH
46416: LD_INT 5
46418: PUSH
46419: LD_INT 5
46421: PUSH
46422: EMPTY
46423: LIST
46424: LIST
46425: PUSH
46426: LD_INT 4
46428: PUSH
46429: LD_INT 5
46431: PUSH
46432: EMPTY
46433: LIST
46434: LIST
46435: PUSH
46436: LD_INT 3
46438: PUSH
46439: LD_INT 4
46441: PUSH
46442: EMPTY
46443: LIST
46444: LIST
46445: PUSH
46446: LD_INT 3
46448: PUSH
46449: LD_INT 3
46451: PUSH
46452: EMPTY
46453: LIST
46454: LIST
46455: PUSH
46456: LD_INT 5
46458: PUSH
46459: LD_INT 3
46461: PUSH
46462: EMPTY
46463: LIST
46464: LIST
46465: PUSH
46466: LD_INT 3
46468: PUSH
46469: LD_INT 5
46471: PUSH
46472: EMPTY
46473: LIST
46474: LIST
46475: PUSH
46476: LD_INT 0
46478: PUSH
46479: LD_INT 3
46481: PUSH
46482: EMPTY
46483: LIST
46484: LIST
46485: PUSH
46486: LD_INT 0
46488: PUSH
46489: LD_INT 2
46491: PUSH
46492: EMPTY
46493: LIST
46494: LIST
46495: PUSH
46496: LD_INT 1
46498: PUSH
46499: LD_INT 3
46501: PUSH
46502: EMPTY
46503: LIST
46504: LIST
46505: PUSH
46506: LD_INT 1
46508: PUSH
46509: LD_INT 4
46511: PUSH
46512: EMPTY
46513: LIST
46514: LIST
46515: PUSH
46516: LD_INT 0
46518: PUSH
46519: LD_INT 4
46521: PUSH
46522: EMPTY
46523: LIST
46524: LIST
46525: PUSH
46526: LD_INT 1
46528: NEG
46529: PUSH
46530: LD_INT 3
46532: PUSH
46533: EMPTY
46534: LIST
46535: LIST
46536: PUSH
46537: LD_INT 1
46539: NEG
46540: PUSH
46541: LD_INT 2
46543: PUSH
46544: EMPTY
46545: LIST
46546: LIST
46547: PUSH
46548: LD_INT 2
46550: PUSH
46551: LD_INT 4
46553: PUSH
46554: EMPTY
46555: LIST
46556: LIST
46557: PUSH
46558: LD_INT 2
46560: NEG
46561: PUSH
46562: LD_INT 2
46564: PUSH
46565: EMPTY
46566: LIST
46567: LIST
46568: PUSH
46569: LD_INT 4
46571: NEG
46572: PUSH
46573: LD_INT 0
46575: PUSH
46576: EMPTY
46577: LIST
46578: LIST
46579: PUSH
46580: LD_INT 4
46582: NEG
46583: PUSH
46584: LD_INT 1
46586: NEG
46587: PUSH
46588: EMPTY
46589: LIST
46590: LIST
46591: PUSH
46592: LD_INT 3
46594: NEG
46595: PUSH
46596: LD_INT 0
46598: PUSH
46599: EMPTY
46600: LIST
46601: LIST
46602: PUSH
46603: LD_INT 3
46605: NEG
46606: PUSH
46607: LD_INT 1
46609: PUSH
46610: EMPTY
46611: LIST
46612: LIST
46613: PUSH
46614: LD_INT 4
46616: NEG
46617: PUSH
46618: LD_INT 1
46620: PUSH
46621: EMPTY
46622: LIST
46623: LIST
46624: PUSH
46625: LD_INT 5
46627: NEG
46628: PUSH
46629: LD_INT 0
46631: PUSH
46632: EMPTY
46633: LIST
46634: LIST
46635: PUSH
46636: LD_INT 5
46638: NEG
46639: PUSH
46640: LD_INT 1
46642: NEG
46643: PUSH
46644: EMPTY
46645: LIST
46646: LIST
46647: PUSH
46648: LD_INT 5
46650: NEG
46651: PUSH
46652: LD_INT 2
46654: NEG
46655: PUSH
46656: EMPTY
46657: LIST
46658: LIST
46659: PUSH
46660: LD_INT 3
46662: NEG
46663: PUSH
46664: LD_INT 2
46666: PUSH
46667: EMPTY
46668: LIST
46669: LIST
46670: PUSH
46671: EMPTY
46672: LIST
46673: LIST
46674: LIST
46675: LIST
46676: LIST
46677: LIST
46678: LIST
46679: LIST
46680: LIST
46681: LIST
46682: LIST
46683: LIST
46684: LIST
46685: LIST
46686: LIST
46687: LIST
46688: LIST
46689: LIST
46690: LIST
46691: LIST
46692: LIST
46693: LIST
46694: LIST
46695: LIST
46696: LIST
46697: LIST
46698: LIST
46699: LIST
46700: LIST
46701: LIST
46702: LIST
46703: LIST
46704: LIST
46705: LIST
46706: LIST
46707: LIST
46708: LIST
46709: LIST
46710: LIST
46711: LIST
46712: LIST
46713: LIST
46714: LIST
46715: LIST
46716: LIST
46717: ST_TO_ADDR
// end ; end ;
46718: GO 46721
46720: POP
// case btype of b_depot , b_warehouse :
46721: LD_VAR 0 1
46725: PUSH
46726: LD_INT 0
46728: DOUBLE
46729: EQUAL
46730: IFTRUE 46740
46732: LD_INT 1
46734: DOUBLE
46735: EQUAL
46736: IFTRUE 46740
46738: GO 46941
46740: POP
// case nation of nation_american :
46741: LD_VAR 0 5
46745: PUSH
46746: LD_INT 1
46748: DOUBLE
46749: EQUAL
46750: IFTRUE 46754
46752: GO 46810
46754: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
46755: LD_ADDR_VAR 0 9
46759: PUSH
46760: LD_VAR 0 11
46764: PUSH
46765: LD_VAR 0 12
46769: PUSH
46770: LD_VAR 0 13
46774: PUSH
46775: LD_VAR 0 14
46779: PUSH
46780: LD_VAR 0 15
46784: PUSH
46785: LD_VAR 0 16
46789: PUSH
46790: EMPTY
46791: LIST
46792: LIST
46793: LIST
46794: LIST
46795: LIST
46796: LIST
46797: PUSH
46798: LD_VAR 0 4
46802: PUSH
46803: LD_INT 1
46805: PLUS
46806: ARRAY
46807: ST_TO_ADDR
46808: GO 46939
46810: LD_INT 2
46812: DOUBLE
46813: EQUAL
46814: IFTRUE 46818
46816: GO 46874
46818: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
46819: LD_ADDR_VAR 0 9
46823: PUSH
46824: LD_VAR 0 17
46828: PUSH
46829: LD_VAR 0 18
46833: PUSH
46834: LD_VAR 0 19
46838: PUSH
46839: LD_VAR 0 20
46843: PUSH
46844: LD_VAR 0 21
46848: PUSH
46849: LD_VAR 0 22
46853: PUSH
46854: EMPTY
46855: LIST
46856: LIST
46857: LIST
46858: LIST
46859: LIST
46860: LIST
46861: PUSH
46862: LD_VAR 0 4
46866: PUSH
46867: LD_INT 1
46869: PLUS
46870: ARRAY
46871: ST_TO_ADDR
46872: GO 46939
46874: LD_INT 3
46876: DOUBLE
46877: EQUAL
46878: IFTRUE 46882
46880: GO 46938
46882: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46883: LD_ADDR_VAR 0 9
46887: PUSH
46888: LD_VAR 0 23
46892: PUSH
46893: LD_VAR 0 24
46897: PUSH
46898: LD_VAR 0 25
46902: PUSH
46903: LD_VAR 0 26
46907: PUSH
46908: LD_VAR 0 27
46912: PUSH
46913: LD_VAR 0 28
46917: PUSH
46918: EMPTY
46919: LIST
46920: LIST
46921: LIST
46922: LIST
46923: LIST
46924: LIST
46925: PUSH
46926: LD_VAR 0 4
46930: PUSH
46931: LD_INT 1
46933: PLUS
46934: ARRAY
46935: ST_TO_ADDR
46936: GO 46939
46938: POP
46939: GO 47494
46941: LD_INT 2
46943: DOUBLE
46944: EQUAL
46945: IFTRUE 46955
46947: LD_INT 3
46949: DOUBLE
46950: EQUAL
46951: IFTRUE 46955
46953: GO 47011
46955: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46956: LD_ADDR_VAR 0 9
46960: PUSH
46961: LD_VAR 0 29
46965: PUSH
46966: LD_VAR 0 30
46970: PUSH
46971: LD_VAR 0 31
46975: PUSH
46976: LD_VAR 0 32
46980: PUSH
46981: LD_VAR 0 33
46985: PUSH
46986: LD_VAR 0 34
46990: PUSH
46991: EMPTY
46992: LIST
46993: LIST
46994: LIST
46995: LIST
46996: LIST
46997: LIST
46998: PUSH
46999: LD_VAR 0 4
47003: PUSH
47004: LD_INT 1
47006: PLUS
47007: ARRAY
47008: ST_TO_ADDR
47009: GO 47494
47011: LD_INT 16
47013: DOUBLE
47014: EQUAL
47015: IFTRUE 47073
47017: LD_INT 17
47019: DOUBLE
47020: EQUAL
47021: IFTRUE 47073
47023: LD_INT 18
47025: DOUBLE
47026: EQUAL
47027: IFTRUE 47073
47029: LD_INT 19
47031: DOUBLE
47032: EQUAL
47033: IFTRUE 47073
47035: LD_INT 22
47037: DOUBLE
47038: EQUAL
47039: IFTRUE 47073
47041: LD_INT 20
47043: DOUBLE
47044: EQUAL
47045: IFTRUE 47073
47047: LD_INT 21
47049: DOUBLE
47050: EQUAL
47051: IFTRUE 47073
47053: LD_INT 23
47055: DOUBLE
47056: EQUAL
47057: IFTRUE 47073
47059: LD_INT 24
47061: DOUBLE
47062: EQUAL
47063: IFTRUE 47073
47065: LD_INT 25
47067: DOUBLE
47068: EQUAL
47069: IFTRUE 47073
47071: GO 47129
47073: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47074: LD_ADDR_VAR 0 9
47078: PUSH
47079: LD_VAR 0 35
47083: PUSH
47084: LD_VAR 0 36
47088: PUSH
47089: LD_VAR 0 37
47093: PUSH
47094: LD_VAR 0 38
47098: PUSH
47099: LD_VAR 0 39
47103: PUSH
47104: LD_VAR 0 40
47108: PUSH
47109: EMPTY
47110: LIST
47111: LIST
47112: LIST
47113: LIST
47114: LIST
47115: LIST
47116: PUSH
47117: LD_VAR 0 4
47121: PUSH
47122: LD_INT 1
47124: PLUS
47125: ARRAY
47126: ST_TO_ADDR
47127: GO 47494
47129: LD_INT 6
47131: DOUBLE
47132: EQUAL
47133: IFTRUE 47185
47135: LD_INT 7
47137: DOUBLE
47138: EQUAL
47139: IFTRUE 47185
47141: LD_INT 8
47143: DOUBLE
47144: EQUAL
47145: IFTRUE 47185
47147: LD_INT 13
47149: DOUBLE
47150: EQUAL
47151: IFTRUE 47185
47153: LD_INT 12
47155: DOUBLE
47156: EQUAL
47157: IFTRUE 47185
47159: LD_INT 15
47161: DOUBLE
47162: EQUAL
47163: IFTRUE 47185
47165: LD_INT 11
47167: DOUBLE
47168: EQUAL
47169: IFTRUE 47185
47171: LD_INT 14
47173: DOUBLE
47174: EQUAL
47175: IFTRUE 47185
47177: LD_INT 10
47179: DOUBLE
47180: EQUAL
47181: IFTRUE 47185
47183: GO 47241
47185: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
47186: LD_ADDR_VAR 0 9
47190: PUSH
47191: LD_VAR 0 41
47195: PUSH
47196: LD_VAR 0 42
47200: PUSH
47201: LD_VAR 0 43
47205: PUSH
47206: LD_VAR 0 44
47210: PUSH
47211: LD_VAR 0 45
47215: PUSH
47216: LD_VAR 0 46
47220: PUSH
47221: EMPTY
47222: LIST
47223: LIST
47224: LIST
47225: LIST
47226: LIST
47227: LIST
47228: PUSH
47229: LD_VAR 0 4
47233: PUSH
47234: LD_INT 1
47236: PLUS
47237: ARRAY
47238: ST_TO_ADDR
47239: GO 47494
47241: LD_INT 36
47243: DOUBLE
47244: EQUAL
47245: IFTRUE 47249
47247: GO 47305
47249: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47250: LD_ADDR_VAR 0 9
47254: PUSH
47255: LD_VAR 0 47
47259: PUSH
47260: LD_VAR 0 48
47264: PUSH
47265: LD_VAR 0 49
47269: PUSH
47270: LD_VAR 0 50
47274: PUSH
47275: LD_VAR 0 51
47279: PUSH
47280: LD_VAR 0 52
47284: PUSH
47285: EMPTY
47286: LIST
47287: LIST
47288: LIST
47289: LIST
47290: LIST
47291: LIST
47292: PUSH
47293: LD_VAR 0 4
47297: PUSH
47298: LD_INT 1
47300: PLUS
47301: ARRAY
47302: ST_TO_ADDR
47303: GO 47494
47305: LD_INT 4
47307: DOUBLE
47308: EQUAL
47309: IFTRUE 47331
47311: LD_INT 5
47313: DOUBLE
47314: EQUAL
47315: IFTRUE 47331
47317: LD_INT 34
47319: DOUBLE
47320: EQUAL
47321: IFTRUE 47331
47323: LD_INT 37
47325: DOUBLE
47326: EQUAL
47327: IFTRUE 47331
47329: GO 47387
47331: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47332: LD_ADDR_VAR 0 9
47336: PUSH
47337: LD_VAR 0 53
47341: PUSH
47342: LD_VAR 0 54
47346: PUSH
47347: LD_VAR 0 55
47351: PUSH
47352: LD_VAR 0 56
47356: PUSH
47357: LD_VAR 0 57
47361: PUSH
47362: LD_VAR 0 58
47366: PUSH
47367: EMPTY
47368: LIST
47369: LIST
47370: LIST
47371: LIST
47372: LIST
47373: LIST
47374: PUSH
47375: LD_VAR 0 4
47379: PUSH
47380: LD_INT 1
47382: PLUS
47383: ARRAY
47384: ST_TO_ADDR
47385: GO 47494
47387: LD_INT 31
47389: DOUBLE
47390: EQUAL
47391: IFTRUE 47437
47393: LD_INT 32
47395: DOUBLE
47396: EQUAL
47397: IFTRUE 47437
47399: LD_INT 33
47401: DOUBLE
47402: EQUAL
47403: IFTRUE 47437
47405: LD_INT 27
47407: DOUBLE
47408: EQUAL
47409: IFTRUE 47437
47411: LD_INT 26
47413: DOUBLE
47414: EQUAL
47415: IFTRUE 47437
47417: LD_INT 28
47419: DOUBLE
47420: EQUAL
47421: IFTRUE 47437
47423: LD_INT 29
47425: DOUBLE
47426: EQUAL
47427: IFTRUE 47437
47429: LD_INT 30
47431: DOUBLE
47432: EQUAL
47433: IFTRUE 47437
47435: GO 47493
47437: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
47438: LD_ADDR_VAR 0 9
47442: PUSH
47443: LD_VAR 0 59
47447: PUSH
47448: LD_VAR 0 60
47452: PUSH
47453: LD_VAR 0 61
47457: PUSH
47458: LD_VAR 0 62
47462: PUSH
47463: LD_VAR 0 63
47467: PUSH
47468: LD_VAR 0 64
47472: PUSH
47473: EMPTY
47474: LIST
47475: LIST
47476: LIST
47477: LIST
47478: LIST
47479: LIST
47480: PUSH
47481: LD_VAR 0 4
47485: PUSH
47486: LD_INT 1
47488: PLUS
47489: ARRAY
47490: ST_TO_ADDR
47491: GO 47494
47493: POP
// temp_list2 = [ ] ;
47494: LD_ADDR_VAR 0 10
47498: PUSH
47499: EMPTY
47500: ST_TO_ADDR
// for i in temp_list do
47501: LD_ADDR_VAR 0 8
47505: PUSH
47506: LD_VAR 0 9
47510: PUSH
47511: FOR_IN
47512: IFFALSE 47564
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47514: LD_ADDR_VAR 0 10
47518: PUSH
47519: LD_VAR 0 10
47523: PUSH
47524: LD_VAR 0 8
47528: PUSH
47529: LD_INT 1
47531: ARRAY
47532: PUSH
47533: LD_VAR 0 2
47537: PLUS
47538: PUSH
47539: LD_VAR 0 8
47543: PUSH
47544: LD_INT 2
47546: ARRAY
47547: PUSH
47548: LD_VAR 0 3
47552: PLUS
47553: PUSH
47554: EMPTY
47555: LIST
47556: LIST
47557: PUSH
47558: EMPTY
47559: LIST
47560: ADD
47561: ST_TO_ADDR
47562: GO 47511
47564: POP
47565: POP
// result = temp_list2 ;
47566: LD_ADDR_VAR 0 7
47570: PUSH
47571: LD_VAR 0 10
47575: ST_TO_ADDR
// end ;
47576: LD_VAR 0 7
47580: RET
// export function EnemyInRange ( unit , dist ) ; begin
47581: LD_INT 0
47583: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47584: LD_ADDR_VAR 0 3
47588: PUSH
47589: LD_VAR 0 1
47593: PPUSH
47594: CALL_OW 255
47598: PPUSH
47599: LD_VAR 0 1
47603: PPUSH
47604: CALL_OW 250
47608: PPUSH
47609: LD_VAR 0 1
47613: PPUSH
47614: CALL_OW 251
47618: PPUSH
47619: LD_VAR 0 2
47623: PPUSH
47624: CALL 20983 0 4
47628: PUSH
47629: LD_INT 4
47631: ARRAY
47632: ST_TO_ADDR
// end ;
47633: LD_VAR 0 3
47637: RET
// export function PlayerSeeMe ( unit ) ; begin
47638: LD_INT 0
47640: PPUSH
// result := See ( your_side , unit ) ;
47641: LD_ADDR_VAR 0 2
47645: PUSH
47646: LD_OWVAR 2
47650: PPUSH
47651: LD_VAR 0 1
47655: PPUSH
47656: CALL_OW 292
47660: ST_TO_ADDR
// end ;
47661: LD_VAR 0 2
47665: RET
// export function ReverseDir ( unit ) ; begin
47666: LD_INT 0
47668: PPUSH
// if not unit then
47669: LD_VAR 0 1
47673: NOT
47674: IFFALSE 47678
// exit ;
47676: GO 47701
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
47678: LD_ADDR_VAR 0 2
47682: PUSH
47683: LD_VAR 0 1
47687: PPUSH
47688: CALL_OW 254
47692: PUSH
47693: LD_INT 3
47695: PLUS
47696: PUSH
47697: LD_INT 6
47699: MOD
47700: ST_TO_ADDR
// end ;
47701: LD_VAR 0 2
47705: RET
// export function ReverseArray ( array ) ; var i ; begin
47706: LD_INT 0
47708: PPUSH
47709: PPUSH
// if not array then
47710: LD_VAR 0 1
47714: NOT
47715: IFFALSE 47719
// exit ;
47717: GO 47774
// result := [ ] ;
47719: LD_ADDR_VAR 0 2
47723: PUSH
47724: EMPTY
47725: ST_TO_ADDR
// for i := array downto 1 do
47726: LD_ADDR_VAR 0 3
47730: PUSH
47731: DOUBLE
47732: LD_VAR 0 1
47736: INC
47737: ST_TO_ADDR
47738: LD_INT 1
47740: PUSH
47741: FOR_DOWNTO
47742: IFFALSE 47772
// result := Join ( result , array [ i ] ) ;
47744: LD_ADDR_VAR 0 2
47748: PUSH
47749: LD_VAR 0 2
47753: PPUSH
47754: LD_VAR 0 1
47758: PUSH
47759: LD_VAR 0 3
47763: ARRAY
47764: PPUSH
47765: CALL 52418 0 2
47769: ST_TO_ADDR
47770: GO 47741
47772: POP
47773: POP
// end ;
47774: LD_VAR 0 2
47778: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
47779: LD_INT 0
47781: PPUSH
47782: PPUSH
47783: PPUSH
47784: PPUSH
47785: PPUSH
47786: PPUSH
// if not unit or not hexes then
47787: LD_VAR 0 1
47791: NOT
47792: PUSH
47793: LD_VAR 0 2
47797: NOT
47798: OR
47799: IFFALSE 47803
// exit ;
47801: GO 47926
// dist := 9999 ;
47803: LD_ADDR_VAR 0 5
47807: PUSH
47808: LD_INT 9999
47810: ST_TO_ADDR
// for i = 1 to hexes do
47811: LD_ADDR_VAR 0 4
47815: PUSH
47816: DOUBLE
47817: LD_INT 1
47819: DEC
47820: ST_TO_ADDR
47821: LD_VAR 0 2
47825: PUSH
47826: FOR_TO
47827: IFFALSE 47914
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47829: LD_ADDR_VAR 0 6
47833: PUSH
47834: LD_VAR 0 1
47838: PPUSH
47839: LD_VAR 0 2
47843: PUSH
47844: LD_VAR 0 4
47848: ARRAY
47849: PUSH
47850: LD_INT 1
47852: ARRAY
47853: PPUSH
47854: LD_VAR 0 2
47858: PUSH
47859: LD_VAR 0 4
47863: ARRAY
47864: PUSH
47865: LD_INT 2
47867: ARRAY
47868: PPUSH
47869: CALL_OW 297
47873: ST_TO_ADDR
// if tdist < dist then
47874: LD_VAR 0 6
47878: PUSH
47879: LD_VAR 0 5
47883: LESS
47884: IFFALSE 47912
// begin hex := hexes [ i ] ;
47886: LD_ADDR_VAR 0 8
47890: PUSH
47891: LD_VAR 0 2
47895: PUSH
47896: LD_VAR 0 4
47900: ARRAY
47901: ST_TO_ADDR
// dist := tdist ;
47902: LD_ADDR_VAR 0 5
47906: PUSH
47907: LD_VAR 0 6
47911: ST_TO_ADDR
// end ; end ;
47912: GO 47826
47914: POP
47915: POP
// result := hex ;
47916: LD_ADDR_VAR 0 3
47920: PUSH
47921: LD_VAR 0 8
47925: ST_TO_ADDR
// end ;
47926: LD_VAR 0 3
47930: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47931: LD_INT 0
47933: PPUSH
47934: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47935: LD_VAR 0 1
47939: NOT
47940: PUSH
47941: LD_VAR 0 1
47945: PUSH
47946: LD_INT 21
47948: PUSH
47949: LD_INT 2
47951: PUSH
47952: EMPTY
47953: LIST
47954: LIST
47955: PUSH
47956: LD_INT 23
47958: PUSH
47959: LD_INT 2
47961: PUSH
47962: EMPTY
47963: LIST
47964: LIST
47965: PUSH
47966: EMPTY
47967: LIST
47968: LIST
47969: PPUSH
47970: CALL_OW 69
47974: IN
47975: NOT
47976: OR
47977: IFFALSE 47981
// exit ;
47979: GO 48028
// for i = 1 to 3 do
47981: LD_ADDR_VAR 0 3
47985: PUSH
47986: DOUBLE
47987: LD_INT 1
47989: DEC
47990: ST_TO_ADDR
47991: LD_INT 3
47993: PUSH
47994: FOR_TO
47995: IFFALSE 48026
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47997: LD_VAR 0 1
48001: PPUSH
48002: CALL_OW 250
48006: PPUSH
48007: LD_VAR 0 1
48011: PPUSH
48012: CALL_OW 251
48016: PPUSH
48017: LD_INT 1
48019: PPUSH
48020: CALL_OW 453
48024: GO 47994
48026: POP
48027: POP
// end ;
48028: LD_VAR 0 2
48032: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48033: LD_INT 0
48035: PPUSH
48036: PPUSH
48037: PPUSH
48038: PPUSH
48039: PPUSH
48040: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48041: LD_VAR 0 1
48045: NOT
48046: PUSH
48047: LD_VAR 0 2
48051: NOT
48052: OR
48053: PUSH
48054: LD_VAR 0 1
48058: PPUSH
48059: CALL_OW 314
48063: OR
48064: IFFALSE 48068
// exit ;
48066: GO 48535
// if GetLives ( i ) < 250 then
48068: LD_VAR 0 4
48072: PPUSH
48073: CALL_OW 256
48077: PUSH
48078: LD_INT 250
48080: LESS
48081: IFFALSE 48094
// begin ComAutodestruct ( i ) ;
48083: LD_VAR 0 4
48087: PPUSH
48088: CALL 47931 0 1
// exit ;
48092: GO 48535
// end ; x := GetX ( enemy_unit ) ;
48094: LD_ADDR_VAR 0 7
48098: PUSH
48099: LD_VAR 0 2
48103: PPUSH
48104: CALL_OW 250
48108: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48109: LD_ADDR_VAR 0 8
48113: PUSH
48114: LD_VAR 0 2
48118: PPUSH
48119: CALL_OW 251
48123: ST_TO_ADDR
// if not x or not y then
48124: LD_VAR 0 7
48128: NOT
48129: PUSH
48130: LD_VAR 0 8
48134: NOT
48135: OR
48136: IFFALSE 48140
// exit ;
48138: GO 48535
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48140: LD_ADDR_VAR 0 6
48144: PUSH
48145: LD_VAR 0 7
48149: PPUSH
48150: LD_INT 0
48152: PPUSH
48153: LD_INT 4
48155: PPUSH
48156: CALL_OW 272
48160: PUSH
48161: LD_VAR 0 8
48165: PPUSH
48166: LD_INT 0
48168: PPUSH
48169: LD_INT 4
48171: PPUSH
48172: CALL_OW 273
48176: PUSH
48177: EMPTY
48178: LIST
48179: LIST
48180: PUSH
48181: LD_VAR 0 7
48185: PPUSH
48186: LD_INT 1
48188: PPUSH
48189: LD_INT 4
48191: PPUSH
48192: CALL_OW 272
48196: PUSH
48197: LD_VAR 0 8
48201: PPUSH
48202: LD_INT 1
48204: PPUSH
48205: LD_INT 4
48207: PPUSH
48208: CALL_OW 273
48212: PUSH
48213: EMPTY
48214: LIST
48215: LIST
48216: PUSH
48217: LD_VAR 0 7
48221: PPUSH
48222: LD_INT 2
48224: PPUSH
48225: LD_INT 4
48227: PPUSH
48228: CALL_OW 272
48232: PUSH
48233: LD_VAR 0 8
48237: PPUSH
48238: LD_INT 2
48240: PPUSH
48241: LD_INT 4
48243: PPUSH
48244: CALL_OW 273
48248: PUSH
48249: EMPTY
48250: LIST
48251: LIST
48252: PUSH
48253: LD_VAR 0 7
48257: PPUSH
48258: LD_INT 3
48260: PPUSH
48261: LD_INT 4
48263: PPUSH
48264: CALL_OW 272
48268: PUSH
48269: LD_VAR 0 8
48273: PPUSH
48274: LD_INT 3
48276: PPUSH
48277: LD_INT 4
48279: PPUSH
48280: CALL_OW 273
48284: PUSH
48285: EMPTY
48286: LIST
48287: LIST
48288: PUSH
48289: LD_VAR 0 7
48293: PPUSH
48294: LD_INT 4
48296: PPUSH
48297: LD_INT 4
48299: PPUSH
48300: CALL_OW 272
48304: PUSH
48305: LD_VAR 0 8
48309: PPUSH
48310: LD_INT 4
48312: PPUSH
48313: LD_INT 4
48315: PPUSH
48316: CALL_OW 273
48320: PUSH
48321: EMPTY
48322: LIST
48323: LIST
48324: PUSH
48325: LD_VAR 0 7
48329: PPUSH
48330: LD_INT 5
48332: PPUSH
48333: LD_INT 4
48335: PPUSH
48336: CALL_OW 272
48340: PUSH
48341: LD_VAR 0 8
48345: PPUSH
48346: LD_INT 5
48348: PPUSH
48349: LD_INT 4
48351: PPUSH
48352: CALL_OW 273
48356: PUSH
48357: EMPTY
48358: LIST
48359: LIST
48360: PUSH
48361: EMPTY
48362: LIST
48363: LIST
48364: LIST
48365: LIST
48366: LIST
48367: LIST
48368: ST_TO_ADDR
// for i = tmp downto 1 do
48369: LD_ADDR_VAR 0 4
48373: PUSH
48374: DOUBLE
48375: LD_VAR 0 6
48379: INC
48380: ST_TO_ADDR
48381: LD_INT 1
48383: PUSH
48384: FOR_DOWNTO
48385: IFFALSE 48486
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48387: LD_VAR 0 6
48391: PUSH
48392: LD_VAR 0 4
48396: ARRAY
48397: PUSH
48398: LD_INT 1
48400: ARRAY
48401: PPUSH
48402: LD_VAR 0 6
48406: PUSH
48407: LD_VAR 0 4
48411: ARRAY
48412: PUSH
48413: LD_INT 2
48415: ARRAY
48416: PPUSH
48417: CALL_OW 488
48421: NOT
48422: PUSH
48423: LD_VAR 0 6
48427: PUSH
48428: LD_VAR 0 4
48432: ARRAY
48433: PUSH
48434: LD_INT 1
48436: ARRAY
48437: PPUSH
48438: LD_VAR 0 6
48442: PUSH
48443: LD_VAR 0 4
48447: ARRAY
48448: PUSH
48449: LD_INT 2
48451: ARRAY
48452: PPUSH
48453: CALL_OW 428
48457: PUSH
48458: LD_INT 0
48460: NONEQUAL
48461: OR
48462: IFFALSE 48484
// tmp := Delete ( tmp , i ) ;
48464: LD_ADDR_VAR 0 6
48468: PUSH
48469: LD_VAR 0 6
48473: PPUSH
48474: LD_VAR 0 4
48478: PPUSH
48479: CALL_OW 3
48483: ST_TO_ADDR
48484: GO 48384
48486: POP
48487: POP
// j := GetClosestHex ( unit , tmp ) ;
48488: LD_ADDR_VAR 0 5
48492: PUSH
48493: LD_VAR 0 1
48497: PPUSH
48498: LD_VAR 0 6
48502: PPUSH
48503: CALL 47779 0 2
48507: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48508: LD_VAR 0 1
48512: PPUSH
48513: LD_VAR 0 5
48517: PUSH
48518: LD_INT 1
48520: ARRAY
48521: PPUSH
48522: LD_VAR 0 5
48526: PUSH
48527: LD_INT 2
48529: ARRAY
48530: PPUSH
48531: CALL_OW 111
// end ;
48535: LD_VAR 0 3
48539: RET
// export function PrepareApemanSoldier ( ) ; begin
48540: LD_INT 0
48542: PPUSH
// uc_nation := 0 ;
48543: LD_ADDR_OWVAR 21
48547: PUSH
48548: LD_INT 0
48550: ST_TO_ADDR
// hc_sex := sex_male ;
48551: LD_ADDR_OWVAR 27
48555: PUSH
48556: LD_INT 1
48558: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
48559: LD_ADDR_OWVAR 28
48563: PUSH
48564: LD_INT 15
48566: ST_TO_ADDR
// hc_gallery :=  ;
48567: LD_ADDR_OWVAR 33
48571: PUSH
48572: LD_STRING 
48574: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48575: LD_ADDR_OWVAR 31
48579: PUSH
48580: LD_INT 0
48582: PPUSH
48583: LD_INT 3
48585: PPUSH
48586: CALL_OW 12
48590: PUSH
48591: LD_INT 0
48593: PPUSH
48594: LD_INT 3
48596: PPUSH
48597: CALL_OW 12
48601: PUSH
48602: LD_INT 0
48604: PUSH
48605: LD_INT 0
48607: PUSH
48608: EMPTY
48609: LIST
48610: LIST
48611: LIST
48612: LIST
48613: ST_TO_ADDR
// end ;
48614: LD_VAR 0 1
48618: RET
// export function PrepareApemanEngineer ( ) ; begin
48619: LD_INT 0
48621: PPUSH
// uc_nation := 0 ;
48622: LD_ADDR_OWVAR 21
48626: PUSH
48627: LD_INT 0
48629: ST_TO_ADDR
// hc_sex := sex_male ;
48630: LD_ADDR_OWVAR 27
48634: PUSH
48635: LD_INT 1
48637: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
48638: LD_ADDR_OWVAR 28
48642: PUSH
48643: LD_INT 16
48645: ST_TO_ADDR
// hc_gallery :=  ;
48646: LD_ADDR_OWVAR 33
48650: PUSH
48651: LD_STRING 
48653: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48654: LD_ADDR_OWVAR 31
48658: PUSH
48659: LD_INT 0
48661: PPUSH
48662: LD_INT 3
48664: PPUSH
48665: CALL_OW 12
48669: PUSH
48670: LD_INT 0
48672: PPUSH
48673: LD_INT 3
48675: PPUSH
48676: CALL_OW 12
48680: PUSH
48681: LD_INT 0
48683: PUSH
48684: LD_INT 0
48686: PUSH
48687: EMPTY
48688: LIST
48689: LIST
48690: LIST
48691: LIST
48692: ST_TO_ADDR
// end ;
48693: LD_VAR 0 1
48697: RET
// export function PrepareApeman ( agressivity ) ; begin
48698: LD_INT 0
48700: PPUSH
// uc_side := 0 ;
48701: LD_ADDR_OWVAR 20
48705: PUSH
48706: LD_INT 0
48708: ST_TO_ADDR
// uc_nation := 0 ;
48709: LD_ADDR_OWVAR 21
48713: PUSH
48714: LD_INT 0
48716: ST_TO_ADDR
// hc_sex := sex_male ;
48717: LD_ADDR_OWVAR 27
48721: PUSH
48722: LD_INT 1
48724: ST_TO_ADDR
// hc_class := class_apeman ;
48725: LD_ADDR_OWVAR 28
48729: PUSH
48730: LD_INT 12
48732: ST_TO_ADDR
// hc_gallery :=  ;
48733: LD_ADDR_OWVAR 33
48737: PUSH
48738: LD_STRING 
48740: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
48741: LD_ADDR_OWVAR 35
48745: PUSH
48746: LD_VAR 0 1
48750: NEG
48751: PPUSH
48752: LD_VAR 0 1
48756: PPUSH
48757: CALL_OW 12
48761: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48762: LD_ADDR_OWVAR 31
48766: PUSH
48767: LD_INT 0
48769: PPUSH
48770: LD_INT 3
48772: PPUSH
48773: CALL_OW 12
48777: PUSH
48778: LD_INT 0
48780: PPUSH
48781: LD_INT 3
48783: PPUSH
48784: CALL_OW 12
48788: PUSH
48789: LD_INT 0
48791: PUSH
48792: LD_INT 0
48794: PUSH
48795: EMPTY
48796: LIST
48797: LIST
48798: LIST
48799: LIST
48800: ST_TO_ADDR
// end ;
48801: LD_VAR 0 2
48805: RET
// export function PrepareTiger ( agressivity ) ; begin
48806: LD_INT 0
48808: PPUSH
// uc_side := 0 ;
48809: LD_ADDR_OWVAR 20
48813: PUSH
48814: LD_INT 0
48816: ST_TO_ADDR
// uc_nation := 0 ;
48817: LD_ADDR_OWVAR 21
48821: PUSH
48822: LD_INT 0
48824: ST_TO_ADDR
// hc_class := class_tiger ;
48825: LD_ADDR_OWVAR 28
48829: PUSH
48830: LD_INT 14
48832: ST_TO_ADDR
// hc_gallery :=  ;
48833: LD_ADDR_OWVAR 33
48837: PUSH
48838: LD_STRING 
48840: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
48841: LD_ADDR_OWVAR 35
48845: PUSH
48846: LD_VAR 0 1
48850: NEG
48851: PPUSH
48852: LD_VAR 0 1
48856: PPUSH
48857: CALL_OW 12
48861: ST_TO_ADDR
// end ;
48862: LD_VAR 0 2
48866: RET
// export function PrepareEnchidna ( ) ; begin
48867: LD_INT 0
48869: PPUSH
// uc_side := 0 ;
48870: LD_ADDR_OWVAR 20
48874: PUSH
48875: LD_INT 0
48877: ST_TO_ADDR
// uc_nation := 0 ;
48878: LD_ADDR_OWVAR 21
48882: PUSH
48883: LD_INT 0
48885: ST_TO_ADDR
// hc_class := class_baggie ;
48886: LD_ADDR_OWVAR 28
48890: PUSH
48891: LD_INT 13
48893: ST_TO_ADDR
// hc_gallery :=  ;
48894: LD_ADDR_OWVAR 33
48898: PUSH
48899: LD_STRING 
48901: ST_TO_ADDR
// end ;
48902: LD_VAR 0 1
48906: RET
// export function PrepareFrog ( ) ; begin
48907: LD_INT 0
48909: PPUSH
// uc_side := 0 ;
48910: LD_ADDR_OWVAR 20
48914: PUSH
48915: LD_INT 0
48917: ST_TO_ADDR
// uc_nation := 0 ;
48918: LD_ADDR_OWVAR 21
48922: PUSH
48923: LD_INT 0
48925: ST_TO_ADDR
// hc_class := class_frog ;
48926: LD_ADDR_OWVAR 28
48930: PUSH
48931: LD_INT 19
48933: ST_TO_ADDR
// hc_gallery :=  ;
48934: LD_ADDR_OWVAR 33
48938: PUSH
48939: LD_STRING 
48941: ST_TO_ADDR
// end ;
48942: LD_VAR 0 1
48946: RET
// export function PrepareFish ( ) ; begin
48947: LD_INT 0
48949: PPUSH
// uc_side := 0 ;
48950: LD_ADDR_OWVAR 20
48954: PUSH
48955: LD_INT 0
48957: ST_TO_ADDR
// uc_nation := 0 ;
48958: LD_ADDR_OWVAR 21
48962: PUSH
48963: LD_INT 0
48965: ST_TO_ADDR
// hc_class := class_fish ;
48966: LD_ADDR_OWVAR 28
48970: PUSH
48971: LD_INT 20
48973: ST_TO_ADDR
// hc_gallery :=  ;
48974: LD_ADDR_OWVAR 33
48978: PUSH
48979: LD_STRING 
48981: ST_TO_ADDR
// end ;
48982: LD_VAR 0 1
48986: RET
// export function PrepareBird ( ) ; begin
48987: LD_INT 0
48989: PPUSH
// uc_side := 0 ;
48990: LD_ADDR_OWVAR 20
48994: PUSH
48995: LD_INT 0
48997: ST_TO_ADDR
// uc_nation := 0 ;
48998: LD_ADDR_OWVAR 21
49002: PUSH
49003: LD_INT 0
49005: ST_TO_ADDR
// hc_class := class_phororhacos ;
49006: LD_ADDR_OWVAR 28
49010: PUSH
49011: LD_INT 18
49013: ST_TO_ADDR
// hc_gallery :=  ;
49014: LD_ADDR_OWVAR 33
49018: PUSH
49019: LD_STRING 
49021: ST_TO_ADDR
// end ;
49022: LD_VAR 0 1
49026: RET
// export function PrepareHorse ( ) ; begin
49027: LD_INT 0
49029: PPUSH
// uc_side := 0 ;
49030: LD_ADDR_OWVAR 20
49034: PUSH
49035: LD_INT 0
49037: ST_TO_ADDR
// uc_nation := 0 ;
49038: LD_ADDR_OWVAR 21
49042: PUSH
49043: LD_INT 0
49045: ST_TO_ADDR
// hc_class := class_horse ;
49046: LD_ADDR_OWVAR 28
49050: PUSH
49051: LD_INT 21
49053: ST_TO_ADDR
// hc_gallery :=  ;
49054: LD_ADDR_OWVAR 33
49058: PUSH
49059: LD_STRING 
49061: ST_TO_ADDR
// end ;
49062: LD_VAR 0 1
49066: RET
// export function PrepareMastodont ( ) ; begin
49067: LD_INT 0
49069: PPUSH
// uc_side := 0 ;
49070: LD_ADDR_OWVAR 20
49074: PUSH
49075: LD_INT 0
49077: ST_TO_ADDR
// uc_nation := 0 ;
49078: LD_ADDR_OWVAR 21
49082: PUSH
49083: LD_INT 0
49085: ST_TO_ADDR
// vc_chassis := class_mastodont ;
49086: LD_ADDR_OWVAR 37
49090: PUSH
49091: LD_INT 31
49093: ST_TO_ADDR
// vc_control := control_rider ;
49094: LD_ADDR_OWVAR 38
49098: PUSH
49099: LD_INT 4
49101: ST_TO_ADDR
// end ;
49102: LD_VAR 0 1
49106: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
49107: LD_INT 0
49109: PPUSH
49110: PPUSH
49111: PPUSH
// uc_side = 0 ;
49112: LD_ADDR_OWVAR 20
49116: PUSH
49117: LD_INT 0
49119: ST_TO_ADDR
// uc_nation = 0 ;
49120: LD_ADDR_OWVAR 21
49124: PUSH
49125: LD_INT 0
49127: ST_TO_ADDR
// InitHc_All ( ) ;
49128: CALL_OW 584
// InitVc ;
49132: CALL_OW 20
// if mastodonts then
49136: LD_VAR 0 6
49140: IFFALSE 49207
// for i = 1 to mastodonts do
49142: LD_ADDR_VAR 0 11
49146: PUSH
49147: DOUBLE
49148: LD_INT 1
49150: DEC
49151: ST_TO_ADDR
49152: LD_VAR 0 6
49156: PUSH
49157: FOR_TO
49158: IFFALSE 49205
// begin vc_chassis := 31 ;
49160: LD_ADDR_OWVAR 37
49164: PUSH
49165: LD_INT 31
49167: ST_TO_ADDR
// vc_control := control_rider ;
49168: LD_ADDR_OWVAR 38
49172: PUSH
49173: LD_INT 4
49175: ST_TO_ADDR
// animal := CreateVehicle ;
49176: LD_ADDR_VAR 0 12
49180: PUSH
49181: CALL_OW 45
49185: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49186: LD_VAR 0 12
49190: PPUSH
49191: LD_VAR 0 8
49195: PPUSH
49196: LD_INT 0
49198: PPUSH
49199: CALL 51335 0 3
// end ;
49203: GO 49157
49205: POP
49206: POP
// if horses then
49207: LD_VAR 0 5
49211: IFFALSE 49278
// for i = 1 to horses do
49213: LD_ADDR_VAR 0 11
49217: PUSH
49218: DOUBLE
49219: LD_INT 1
49221: DEC
49222: ST_TO_ADDR
49223: LD_VAR 0 5
49227: PUSH
49228: FOR_TO
49229: IFFALSE 49276
// begin hc_class := 21 ;
49231: LD_ADDR_OWVAR 28
49235: PUSH
49236: LD_INT 21
49238: ST_TO_ADDR
// hc_gallery :=  ;
49239: LD_ADDR_OWVAR 33
49243: PUSH
49244: LD_STRING 
49246: ST_TO_ADDR
// animal := CreateHuman ;
49247: LD_ADDR_VAR 0 12
49251: PUSH
49252: CALL_OW 44
49256: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49257: LD_VAR 0 12
49261: PPUSH
49262: LD_VAR 0 8
49266: PPUSH
49267: LD_INT 0
49269: PPUSH
49270: CALL 51335 0 3
// end ;
49274: GO 49228
49276: POP
49277: POP
// if birds then
49278: LD_VAR 0 1
49282: IFFALSE 49349
// for i = 1 to birds do
49284: LD_ADDR_VAR 0 11
49288: PUSH
49289: DOUBLE
49290: LD_INT 1
49292: DEC
49293: ST_TO_ADDR
49294: LD_VAR 0 1
49298: PUSH
49299: FOR_TO
49300: IFFALSE 49347
// begin hc_class = 18 ;
49302: LD_ADDR_OWVAR 28
49306: PUSH
49307: LD_INT 18
49309: ST_TO_ADDR
// hc_gallery =  ;
49310: LD_ADDR_OWVAR 33
49314: PUSH
49315: LD_STRING 
49317: ST_TO_ADDR
// animal := CreateHuman ;
49318: LD_ADDR_VAR 0 12
49322: PUSH
49323: CALL_OW 44
49327: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49328: LD_VAR 0 12
49332: PPUSH
49333: LD_VAR 0 8
49337: PPUSH
49338: LD_INT 0
49340: PPUSH
49341: CALL 51335 0 3
// end ;
49345: GO 49299
49347: POP
49348: POP
// if tigers then
49349: LD_VAR 0 2
49353: IFFALSE 49437
// for i = 1 to tigers do
49355: LD_ADDR_VAR 0 11
49359: PUSH
49360: DOUBLE
49361: LD_INT 1
49363: DEC
49364: ST_TO_ADDR
49365: LD_VAR 0 2
49369: PUSH
49370: FOR_TO
49371: IFFALSE 49435
// begin hc_class = class_tiger ;
49373: LD_ADDR_OWVAR 28
49377: PUSH
49378: LD_INT 14
49380: ST_TO_ADDR
// hc_gallery =  ;
49381: LD_ADDR_OWVAR 33
49385: PUSH
49386: LD_STRING 
49388: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49389: LD_ADDR_OWVAR 35
49393: PUSH
49394: LD_INT 7
49396: NEG
49397: PPUSH
49398: LD_INT 7
49400: PPUSH
49401: CALL_OW 12
49405: ST_TO_ADDR
// animal := CreateHuman ;
49406: LD_ADDR_VAR 0 12
49410: PUSH
49411: CALL_OW 44
49415: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49416: LD_VAR 0 12
49420: PPUSH
49421: LD_VAR 0 8
49425: PPUSH
49426: LD_INT 0
49428: PPUSH
49429: CALL 51335 0 3
// end ;
49433: GO 49370
49435: POP
49436: POP
// if apemans then
49437: LD_VAR 0 3
49441: IFFALSE 49564
// for i = 1 to apemans do
49443: LD_ADDR_VAR 0 11
49447: PUSH
49448: DOUBLE
49449: LD_INT 1
49451: DEC
49452: ST_TO_ADDR
49453: LD_VAR 0 3
49457: PUSH
49458: FOR_TO
49459: IFFALSE 49562
// begin hc_class = class_apeman ;
49461: LD_ADDR_OWVAR 28
49465: PUSH
49466: LD_INT 12
49468: ST_TO_ADDR
// hc_gallery =  ;
49469: LD_ADDR_OWVAR 33
49473: PUSH
49474: LD_STRING 
49476: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
49477: LD_ADDR_OWVAR 35
49481: PUSH
49482: LD_INT 2
49484: NEG
49485: PPUSH
49486: LD_INT 2
49488: PPUSH
49489: CALL_OW 12
49493: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49494: LD_ADDR_OWVAR 31
49498: PUSH
49499: LD_INT 1
49501: PPUSH
49502: LD_INT 3
49504: PPUSH
49505: CALL_OW 12
49509: PUSH
49510: LD_INT 1
49512: PPUSH
49513: LD_INT 3
49515: PPUSH
49516: CALL_OW 12
49520: PUSH
49521: LD_INT 0
49523: PUSH
49524: LD_INT 0
49526: PUSH
49527: EMPTY
49528: LIST
49529: LIST
49530: LIST
49531: LIST
49532: ST_TO_ADDR
// animal := CreateHuman ;
49533: LD_ADDR_VAR 0 12
49537: PUSH
49538: CALL_OW 44
49542: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49543: LD_VAR 0 12
49547: PPUSH
49548: LD_VAR 0 8
49552: PPUSH
49553: LD_INT 0
49555: PPUSH
49556: CALL 51335 0 3
// end ;
49560: GO 49458
49562: POP
49563: POP
// if enchidnas then
49564: LD_VAR 0 4
49568: IFFALSE 49635
// for i = 1 to enchidnas do
49570: LD_ADDR_VAR 0 11
49574: PUSH
49575: DOUBLE
49576: LD_INT 1
49578: DEC
49579: ST_TO_ADDR
49580: LD_VAR 0 4
49584: PUSH
49585: FOR_TO
49586: IFFALSE 49633
// begin hc_class = 13 ;
49588: LD_ADDR_OWVAR 28
49592: PUSH
49593: LD_INT 13
49595: ST_TO_ADDR
// hc_gallery =  ;
49596: LD_ADDR_OWVAR 33
49600: PUSH
49601: LD_STRING 
49603: ST_TO_ADDR
// animal := CreateHuman ;
49604: LD_ADDR_VAR 0 12
49608: PUSH
49609: CALL_OW 44
49613: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49614: LD_VAR 0 12
49618: PPUSH
49619: LD_VAR 0 8
49623: PPUSH
49624: LD_INT 0
49626: PPUSH
49627: CALL 51335 0 3
// end ;
49631: GO 49585
49633: POP
49634: POP
// if fishes then
49635: LD_VAR 0 7
49639: IFFALSE 49706
// for i = 1 to fishes do
49641: LD_ADDR_VAR 0 11
49645: PUSH
49646: DOUBLE
49647: LD_INT 1
49649: DEC
49650: ST_TO_ADDR
49651: LD_VAR 0 7
49655: PUSH
49656: FOR_TO
49657: IFFALSE 49704
// begin hc_class = 20 ;
49659: LD_ADDR_OWVAR 28
49663: PUSH
49664: LD_INT 20
49666: ST_TO_ADDR
// hc_gallery =  ;
49667: LD_ADDR_OWVAR 33
49671: PUSH
49672: LD_STRING 
49674: ST_TO_ADDR
// animal := CreateHuman ;
49675: LD_ADDR_VAR 0 12
49679: PUSH
49680: CALL_OW 44
49684: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49685: LD_VAR 0 12
49689: PPUSH
49690: LD_VAR 0 9
49694: PPUSH
49695: LD_INT 0
49697: PPUSH
49698: CALL 51335 0 3
// end ;
49702: GO 49656
49704: POP
49705: POP
// end ;
49706: LD_VAR 0 10
49710: RET
// export function WantHeal ( sci , unit ) ; begin
49711: LD_INT 0
49713: PPUSH
// if GetTaskList ( sci ) > 0 then
49714: LD_VAR 0 1
49718: PPUSH
49719: CALL_OW 437
49723: PUSH
49724: LD_INT 0
49726: GREATER
49727: IFFALSE 49797
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49729: LD_VAR 0 1
49733: PPUSH
49734: CALL_OW 437
49738: PUSH
49739: LD_INT 1
49741: ARRAY
49742: PUSH
49743: LD_INT 1
49745: ARRAY
49746: PUSH
49747: LD_STRING l
49749: EQUAL
49750: PUSH
49751: LD_VAR 0 1
49755: PPUSH
49756: CALL_OW 437
49760: PUSH
49761: LD_INT 1
49763: ARRAY
49764: PUSH
49765: LD_INT 4
49767: ARRAY
49768: PUSH
49769: LD_VAR 0 2
49773: EQUAL
49774: AND
49775: IFFALSE 49787
// result := true else
49777: LD_ADDR_VAR 0 3
49781: PUSH
49782: LD_INT 1
49784: ST_TO_ADDR
49785: GO 49795
// result := false ;
49787: LD_ADDR_VAR 0 3
49791: PUSH
49792: LD_INT 0
49794: ST_TO_ADDR
// end else
49795: GO 49805
// result := false ;
49797: LD_ADDR_VAR 0 3
49801: PUSH
49802: LD_INT 0
49804: ST_TO_ADDR
// end ;
49805: LD_VAR 0 3
49809: RET
// export function HealTarget ( sci ) ; begin
49810: LD_INT 0
49812: PPUSH
// if not sci then
49813: LD_VAR 0 1
49817: NOT
49818: IFFALSE 49822
// exit ;
49820: GO 49887
// result := 0 ;
49822: LD_ADDR_VAR 0 2
49826: PUSH
49827: LD_INT 0
49829: ST_TO_ADDR
// if GetTaskList ( sci ) then
49830: LD_VAR 0 1
49834: PPUSH
49835: CALL_OW 437
49839: IFFALSE 49887
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49841: LD_VAR 0 1
49845: PPUSH
49846: CALL_OW 437
49850: PUSH
49851: LD_INT 1
49853: ARRAY
49854: PUSH
49855: LD_INT 1
49857: ARRAY
49858: PUSH
49859: LD_STRING l
49861: EQUAL
49862: IFFALSE 49887
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49864: LD_ADDR_VAR 0 2
49868: PUSH
49869: LD_VAR 0 1
49873: PPUSH
49874: CALL_OW 437
49878: PUSH
49879: LD_INT 1
49881: ARRAY
49882: PUSH
49883: LD_INT 4
49885: ARRAY
49886: ST_TO_ADDR
// end ;
49887: LD_VAR 0 2
49891: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
49892: LD_INT 0
49894: PPUSH
49895: PPUSH
49896: PPUSH
49897: PPUSH
// if not base_units then
49898: LD_VAR 0 1
49902: NOT
49903: IFFALSE 49907
// exit ;
49905: GO 49994
// result := false ;
49907: LD_ADDR_VAR 0 2
49911: PUSH
49912: LD_INT 0
49914: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
49915: LD_ADDR_VAR 0 5
49919: PUSH
49920: LD_VAR 0 1
49924: PPUSH
49925: LD_INT 21
49927: PUSH
49928: LD_INT 3
49930: PUSH
49931: EMPTY
49932: LIST
49933: LIST
49934: PPUSH
49935: CALL_OW 72
49939: ST_TO_ADDR
// if not tmp then
49940: LD_VAR 0 5
49944: NOT
49945: IFFALSE 49949
// exit ;
49947: GO 49994
// for i in tmp do
49949: LD_ADDR_VAR 0 3
49953: PUSH
49954: LD_VAR 0 5
49958: PUSH
49959: FOR_IN
49960: IFFALSE 49992
// begin result := EnemyInRange ( i , 22 ) ;
49962: LD_ADDR_VAR 0 2
49966: PUSH
49967: LD_VAR 0 3
49971: PPUSH
49972: LD_INT 22
49974: PPUSH
49975: CALL 47581 0 2
49979: ST_TO_ADDR
// if result then
49980: LD_VAR 0 2
49984: IFFALSE 49990
// exit ;
49986: POP
49987: POP
49988: GO 49994
// end ;
49990: GO 49959
49992: POP
49993: POP
// end ;
49994: LD_VAR 0 2
49998: RET
// export function FilterByTag ( units , tag ) ; begin
49999: LD_INT 0
50001: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
50002: LD_ADDR_VAR 0 3
50006: PUSH
50007: LD_VAR 0 1
50011: PPUSH
50012: LD_INT 120
50014: PUSH
50015: LD_VAR 0 2
50019: PUSH
50020: EMPTY
50021: LIST
50022: LIST
50023: PPUSH
50024: CALL_OW 72
50028: ST_TO_ADDR
// end ;
50029: LD_VAR 0 3
50033: RET
// export function IsDriver ( un ) ; begin
50034: LD_INT 0
50036: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
50037: LD_ADDR_VAR 0 2
50041: PUSH
50042: LD_VAR 0 1
50046: PUSH
50047: LD_INT 55
50049: PUSH
50050: EMPTY
50051: LIST
50052: PPUSH
50053: CALL_OW 69
50057: IN
50058: ST_TO_ADDR
// end ;
50059: LD_VAR 0 2
50063: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
50064: LD_INT 0
50066: PPUSH
50067: PPUSH
// list := [ ] ;
50068: LD_ADDR_VAR 0 5
50072: PUSH
50073: EMPTY
50074: ST_TO_ADDR
// case d of 0 :
50075: LD_VAR 0 3
50079: PUSH
50080: LD_INT 0
50082: DOUBLE
50083: EQUAL
50084: IFTRUE 50088
50086: GO 50221
50088: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
50089: LD_ADDR_VAR 0 5
50093: PUSH
50094: LD_VAR 0 1
50098: PUSH
50099: LD_INT 4
50101: MINUS
50102: PUSH
50103: LD_VAR 0 2
50107: PUSH
50108: LD_INT 4
50110: MINUS
50111: PUSH
50112: LD_INT 2
50114: PUSH
50115: EMPTY
50116: LIST
50117: LIST
50118: LIST
50119: PUSH
50120: LD_VAR 0 1
50124: PUSH
50125: LD_INT 3
50127: MINUS
50128: PUSH
50129: LD_VAR 0 2
50133: PUSH
50134: LD_INT 1
50136: PUSH
50137: EMPTY
50138: LIST
50139: LIST
50140: LIST
50141: PUSH
50142: LD_VAR 0 1
50146: PUSH
50147: LD_INT 4
50149: PLUS
50150: PUSH
50151: LD_VAR 0 2
50155: PUSH
50156: LD_INT 4
50158: PUSH
50159: EMPTY
50160: LIST
50161: LIST
50162: LIST
50163: PUSH
50164: LD_VAR 0 1
50168: PUSH
50169: LD_INT 3
50171: PLUS
50172: PUSH
50173: LD_VAR 0 2
50177: PUSH
50178: LD_INT 3
50180: PLUS
50181: PUSH
50182: LD_INT 5
50184: PUSH
50185: EMPTY
50186: LIST
50187: LIST
50188: LIST
50189: PUSH
50190: LD_VAR 0 1
50194: PUSH
50195: LD_VAR 0 2
50199: PUSH
50200: LD_INT 4
50202: PLUS
50203: PUSH
50204: LD_INT 0
50206: PUSH
50207: EMPTY
50208: LIST
50209: LIST
50210: LIST
50211: PUSH
50212: EMPTY
50213: LIST
50214: LIST
50215: LIST
50216: LIST
50217: LIST
50218: ST_TO_ADDR
// end ; 1 :
50219: GO 50919
50221: LD_INT 1
50223: DOUBLE
50224: EQUAL
50225: IFTRUE 50229
50227: GO 50362
50229: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
50230: LD_ADDR_VAR 0 5
50234: PUSH
50235: LD_VAR 0 1
50239: PUSH
50240: LD_VAR 0 2
50244: PUSH
50245: LD_INT 4
50247: MINUS
50248: PUSH
50249: LD_INT 3
50251: PUSH
50252: EMPTY
50253: LIST
50254: LIST
50255: LIST
50256: PUSH
50257: LD_VAR 0 1
50261: PUSH
50262: LD_INT 3
50264: MINUS
50265: PUSH
50266: LD_VAR 0 2
50270: PUSH
50271: LD_INT 3
50273: MINUS
50274: PUSH
50275: LD_INT 2
50277: PUSH
50278: EMPTY
50279: LIST
50280: LIST
50281: LIST
50282: PUSH
50283: LD_VAR 0 1
50287: PUSH
50288: LD_INT 4
50290: MINUS
50291: PUSH
50292: LD_VAR 0 2
50296: PUSH
50297: LD_INT 1
50299: PUSH
50300: EMPTY
50301: LIST
50302: LIST
50303: LIST
50304: PUSH
50305: LD_VAR 0 1
50309: PUSH
50310: LD_VAR 0 2
50314: PUSH
50315: LD_INT 3
50317: PLUS
50318: PUSH
50319: LD_INT 0
50321: PUSH
50322: EMPTY
50323: LIST
50324: LIST
50325: LIST
50326: PUSH
50327: LD_VAR 0 1
50331: PUSH
50332: LD_INT 4
50334: PLUS
50335: PUSH
50336: LD_VAR 0 2
50340: PUSH
50341: LD_INT 4
50343: PLUS
50344: PUSH
50345: LD_INT 5
50347: PUSH
50348: EMPTY
50349: LIST
50350: LIST
50351: LIST
50352: PUSH
50353: EMPTY
50354: LIST
50355: LIST
50356: LIST
50357: LIST
50358: LIST
50359: ST_TO_ADDR
// end ; 2 :
50360: GO 50919
50362: LD_INT 2
50364: DOUBLE
50365: EQUAL
50366: IFTRUE 50370
50368: GO 50499
50370: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
50371: LD_ADDR_VAR 0 5
50375: PUSH
50376: LD_VAR 0 1
50380: PUSH
50381: LD_VAR 0 2
50385: PUSH
50386: LD_INT 3
50388: MINUS
50389: PUSH
50390: LD_INT 3
50392: PUSH
50393: EMPTY
50394: LIST
50395: LIST
50396: LIST
50397: PUSH
50398: LD_VAR 0 1
50402: PUSH
50403: LD_INT 4
50405: PLUS
50406: PUSH
50407: LD_VAR 0 2
50411: PUSH
50412: LD_INT 4
50414: PUSH
50415: EMPTY
50416: LIST
50417: LIST
50418: LIST
50419: PUSH
50420: LD_VAR 0 1
50424: PUSH
50425: LD_VAR 0 2
50429: PUSH
50430: LD_INT 4
50432: PLUS
50433: PUSH
50434: LD_INT 0
50436: PUSH
50437: EMPTY
50438: LIST
50439: LIST
50440: LIST
50441: PUSH
50442: LD_VAR 0 1
50446: PUSH
50447: LD_INT 3
50449: MINUS
50450: PUSH
50451: LD_VAR 0 2
50455: PUSH
50456: LD_INT 1
50458: PUSH
50459: EMPTY
50460: LIST
50461: LIST
50462: LIST
50463: PUSH
50464: LD_VAR 0 1
50468: PUSH
50469: LD_INT 4
50471: MINUS
50472: PUSH
50473: LD_VAR 0 2
50477: PUSH
50478: LD_INT 4
50480: MINUS
50481: PUSH
50482: LD_INT 2
50484: PUSH
50485: EMPTY
50486: LIST
50487: LIST
50488: LIST
50489: PUSH
50490: EMPTY
50491: LIST
50492: LIST
50493: LIST
50494: LIST
50495: LIST
50496: ST_TO_ADDR
// end ; 3 :
50497: GO 50919
50499: LD_INT 3
50501: DOUBLE
50502: EQUAL
50503: IFTRUE 50507
50505: GO 50640
50507: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
50508: LD_ADDR_VAR 0 5
50512: PUSH
50513: LD_VAR 0 1
50517: PUSH
50518: LD_INT 3
50520: PLUS
50521: PUSH
50522: LD_VAR 0 2
50526: PUSH
50527: LD_INT 4
50529: PUSH
50530: EMPTY
50531: LIST
50532: LIST
50533: LIST
50534: PUSH
50535: LD_VAR 0 1
50539: PUSH
50540: LD_INT 4
50542: PLUS
50543: PUSH
50544: LD_VAR 0 2
50548: PUSH
50549: LD_INT 4
50551: PLUS
50552: PUSH
50553: LD_INT 5
50555: PUSH
50556: EMPTY
50557: LIST
50558: LIST
50559: LIST
50560: PUSH
50561: LD_VAR 0 1
50565: PUSH
50566: LD_INT 4
50568: MINUS
50569: PUSH
50570: LD_VAR 0 2
50574: PUSH
50575: LD_INT 1
50577: PUSH
50578: EMPTY
50579: LIST
50580: LIST
50581: LIST
50582: PUSH
50583: LD_VAR 0 1
50587: PUSH
50588: LD_VAR 0 2
50592: PUSH
50593: LD_INT 4
50595: MINUS
50596: PUSH
50597: LD_INT 3
50599: PUSH
50600: EMPTY
50601: LIST
50602: LIST
50603: LIST
50604: PUSH
50605: LD_VAR 0 1
50609: PUSH
50610: LD_INT 3
50612: MINUS
50613: PUSH
50614: LD_VAR 0 2
50618: PUSH
50619: LD_INT 3
50621: MINUS
50622: PUSH
50623: LD_INT 2
50625: PUSH
50626: EMPTY
50627: LIST
50628: LIST
50629: LIST
50630: PUSH
50631: EMPTY
50632: LIST
50633: LIST
50634: LIST
50635: LIST
50636: LIST
50637: ST_TO_ADDR
// end ; 4 :
50638: GO 50919
50640: LD_INT 4
50642: DOUBLE
50643: EQUAL
50644: IFTRUE 50648
50646: GO 50781
50648: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
50649: LD_ADDR_VAR 0 5
50653: PUSH
50654: LD_VAR 0 1
50658: PUSH
50659: LD_VAR 0 2
50663: PUSH
50664: LD_INT 4
50666: PLUS
50667: PUSH
50668: LD_INT 0
50670: PUSH
50671: EMPTY
50672: LIST
50673: LIST
50674: LIST
50675: PUSH
50676: LD_VAR 0 1
50680: PUSH
50681: LD_INT 3
50683: PLUS
50684: PUSH
50685: LD_VAR 0 2
50689: PUSH
50690: LD_INT 3
50692: PLUS
50693: PUSH
50694: LD_INT 5
50696: PUSH
50697: EMPTY
50698: LIST
50699: LIST
50700: LIST
50701: PUSH
50702: LD_VAR 0 1
50706: PUSH
50707: LD_INT 4
50709: PLUS
50710: PUSH
50711: LD_VAR 0 2
50715: PUSH
50716: LD_INT 4
50718: PUSH
50719: EMPTY
50720: LIST
50721: LIST
50722: LIST
50723: PUSH
50724: LD_VAR 0 1
50728: PUSH
50729: LD_VAR 0 2
50733: PUSH
50734: LD_INT 3
50736: MINUS
50737: PUSH
50738: LD_INT 3
50740: PUSH
50741: EMPTY
50742: LIST
50743: LIST
50744: LIST
50745: PUSH
50746: LD_VAR 0 1
50750: PUSH
50751: LD_INT 4
50753: MINUS
50754: PUSH
50755: LD_VAR 0 2
50759: PUSH
50760: LD_INT 4
50762: MINUS
50763: PUSH
50764: LD_INT 2
50766: PUSH
50767: EMPTY
50768: LIST
50769: LIST
50770: LIST
50771: PUSH
50772: EMPTY
50773: LIST
50774: LIST
50775: LIST
50776: LIST
50777: LIST
50778: ST_TO_ADDR
// end ; 5 :
50779: GO 50919
50781: LD_INT 5
50783: DOUBLE
50784: EQUAL
50785: IFTRUE 50789
50787: GO 50918
50789: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
50790: LD_ADDR_VAR 0 5
50794: PUSH
50795: LD_VAR 0 1
50799: PUSH
50800: LD_INT 4
50802: MINUS
50803: PUSH
50804: LD_VAR 0 2
50808: PUSH
50809: LD_INT 1
50811: PUSH
50812: EMPTY
50813: LIST
50814: LIST
50815: LIST
50816: PUSH
50817: LD_VAR 0 1
50821: PUSH
50822: LD_VAR 0 2
50826: PUSH
50827: LD_INT 4
50829: MINUS
50830: PUSH
50831: LD_INT 3
50833: PUSH
50834: EMPTY
50835: LIST
50836: LIST
50837: LIST
50838: PUSH
50839: LD_VAR 0 1
50843: PUSH
50844: LD_INT 4
50846: PLUS
50847: PUSH
50848: LD_VAR 0 2
50852: PUSH
50853: LD_INT 4
50855: PLUS
50856: PUSH
50857: LD_INT 5
50859: PUSH
50860: EMPTY
50861: LIST
50862: LIST
50863: LIST
50864: PUSH
50865: LD_VAR 0 1
50869: PUSH
50870: LD_INT 3
50872: PLUS
50873: PUSH
50874: LD_VAR 0 2
50878: PUSH
50879: LD_INT 4
50881: PUSH
50882: EMPTY
50883: LIST
50884: LIST
50885: LIST
50886: PUSH
50887: LD_VAR 0 1
50891: PUSH
50892: LD_VAR 0 2
50896: PUSH
50897: LD_INT 3
50899: PLUS
50900: PUSH
50901: LD_INT 0
50903: PUSH
50904: EMPTY
50905: LIST
50906: LIST
50907: LIST
50908: PUSH
50909: EMPTY
50910: LIST
50911: LIST
50912: LIST
50913: LIST
50914: LIST
50915: ST_TO_ADDR
// end ; end ;
50916: GO 50919
50918: POP
// result := list ;
50919: LD_ADDR_VAR 0 4
50923: PUSH
50924: LD_VAR 0 5
50928: ST_TO_ADDR
// end ;
50929: LD_VAR 0 4
50933: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
50934: LD_INT 0
50936: PPUSH
50937: PPUSH
50938: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
50939: LD_VAR 0 1
50943: NOT
50944: PUSH
50945: LD_VAR 0 2
50949: PUSH
50950: LD_INT 1
50952: PUSH
50953: LD_INT 2
50955: PUSH
50956: LD_INT 3
50958: PUSH
50959: LD_INT 4
50961: PUSH
50962: EMPTY
50963: LIST
50964: LIST
50965: LIST
50966: LIST
50967: IN
50968: NOT
50969: OR
50970: IFFALSE 50974
// exit ;
50972: GO 51057
// tmp := [ ] ;
50974: LD_ADDR_VAR 0 5
50978: PUSH
50979: EMPTY
50980: ST_TO_ADDR
// for i in units do
50981: LD_ADDR_VAR 0 4
50985: PUSH
50986: LD_VAR 0 1
50990: PUSH
50991: FOR_IN
50992: IFFALSE 51026
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
50994: LD_ADDR_VAR 0 5
50998: PUSH
50999: LD_VAR 0 5
51003: PPUSH
51004: LD_VAR 0 4
51008: PPUSH
51009: LD_VAR 0 2
51013: PPUSH
51014: CALL_OW 259
51018: PPUSH
51019: CALL 52418 0 2
51023: ST_TO_ADDR
51024: GO 50991
51026: POP
51027: POP
// if not tmp then
51028: LD_VAR 0 5
51032: NOT
51033: IFFALSE 51037
// exit ;
51035: GO 51057
// result := SortListByListDesc ( units , tmp ) ;
51037: LD_ADDR_VAR 0 3
51041: PUSH
51042: LD_VAR 0 1
51046: PPUSH
51047: LD_VAR 0 5
51051: PPUSH
51052: CALL_OW 77
51056: ST_TO_ADDR
// end ;
51057: LD_VAR 0 3
51061: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
51062: LD_INT 0
51064: PPUSH
51065: PPUSH
51066: PPUSH
// result := false ;
51067: LD_ADDR_VAR 0 3
51071: PUSH
51072: LD_INT 0
51074: ST_TO_ADDR
// if not building then
51075: LD_VAR 0 2
51079: NOT
51080: IFFALSE 51084
// exit ;
51082: GO 51222
// x := GetX ( building ) ;
51084: LD_ADDR_VAR 0 4
51088: PUSH
51089: LD_VAR 0 2
51093: PPUSH
51094: CALL_OW 250
51098: ST_TO_ADDR
// y := GetY ( building ) ;
51099: LD_ADDR_VAR 0 5
51103: PUSH
51104: LD_VAR 0 2
51108: PPUSH
51109: CALL_OW 251
51113: ST_TO_ADDR
// if not x or not y then
51114: LD_VAR 0 4
51118: NOT
51119: PUSH
51120: LD_VAR 0 5
51124: NOT
51125: OR
51126: IFFALSE 51130
// exit ;
51128: GO 51222
// if GetTaskList ( unit ) then
51130: LD_VAR 0 1
51134: PPUSH
51135: CALL_OW 437
51139: IFFALSE 51222
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
51141: LD_STRING e
51143: PUSH
51144: LD_VAR 0 1
51148: PPUSH
51149: CALL_OW 437
51153: PUSH
51154: LD_INT 1
51156: ARRAY
51157: PUSH
51158: LD_INT 1
51160: ARRAY
51161: EQUAL
51162: PUSH
51163: LD_VAR 0 4
51167: PUSH
51168: LD_VAR 0 1
51172: PPUSH
51173: CALL_OW 437
51177: PUSH
51178: LD_INT 1
51180: ARRAY
51181: PUSH
51182: LD_INT 2
51184: ARRAY
51185: EQUAL
51186: AND
51187: PUSH
51188: LD_VAR 0 5
51192: PUSH
51193: LD_VAR 0 1
51197: PPUSH
51198: CALL_OW 437
51202: PUSH
51203: LD_INT 1
51205: ARRAY
51206: PUSH
51207: LD_INT 3
51209: ARRAY
51210: EQUAL
51211: AND
51212: IFFALSE 51222
// result := true end ;
51214: LD_ADDR_VAR 0 3
51218: PUSH
51219: LD_INT 1
51221: ST_TO_ADDR
// end ;
51222: LD_VAR 0 3
51226: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
51227: LD_INT 0
51229: PPUSH
// result := false ;
51230: LD_ADDR_VAR 0 4
51234: PUSH
51235: LD_INT 0
51237: ST_TO_ADDR
// if GetTaskList ( unit ) then
51238: LD_VAR 0 1
51242: PPUSH
51243: CALL_OW 437
51247: IFFALSE 51330
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
51249: LD_STRING M
51251: PUSH
51252: LD_VAR 0 1
51256: PPUSH
51257: CALL_OW 437
51261: PUSH
51262: LD_INT 1
51264: ARRAY
51265: PUSH
51266: LD_INT 1
51268: ARRAY
51269: EQUAL
51270: PUSH
51271: LD_VAR 0 2
51275: PUSH
51276: LD_VAR 0 1
51280: PPUSH
51281: CALL_OW 437
51285: PUSH
51286: LD_INT 1
51288: ARRAY
51289: PUSH
51290: LD_INT 2
51292: ARRAY
51293: EQUAL
51294: AND
51295: PUSH
51296: LD_VAR 0 3
51300: PUSH
51301: LD_VAR 0 1
51305: PPUSH
51306: CALL_OW 437
51310: PUSH
51311: LD_INT 1
51313: ARRAY
51314: PUSH
51315: LD_INT 3
51317: ARRAY
51318: EQUAL
51319: AND
51320: IFFALSE 51330
// result := true ;
51322: LD_ADDR_VAR 0 4
51326: PUSH
51327: LD_INT 1
51329: ST_TO_ADDR
// end ; end ;
51330: LD_VAR 0 4
51334: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
51335: LD_INT 0
51337: PPUSH
51338: PPUSH
51339: PPUSH
51340: PPUSH
// if not unit or not area then
51341: LD_VAR 0 1
51345: NOT
51346: PUSH
51347: LD_VAR 0 2
51351: NOT
51352: OR
51353: IFFALSE 51357
// exit ;
51355: GO 51521
// tmp := AreaToList ( area , i ) ;
51357: LD_ADDR_VAR 0 6
51361: PUSH
51362: LD_VAR 0 2
51366: PPUSH
51367: LD_VAR 0 5
51371: PPUSH
51372: CALL_OW 517
51376: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
51377: LD_ADDR_VAR 0 5
51381: PUSH
51382: DOUBLE
51383: LD_INT 1
51385: DEC
51386: ST_TO_ADDR
51387: LD_VAR 0 6
51391: PUSH
51392: LD_INT 1
51394: ARRAY
51395: PUSH
51396: FOR_TO
51397: IFFALSE 51519
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
51399: LD_ADDR_VAR 0 7
51403: PUSH
51404: LD_VAR 0 6
51408: PUSH
51409: LD_INT 1
51411: ARRAY
51412: PUSH
51413: LD_VAR 0 5
51417: ARRAY
51418: PUSH
51419: LD_VAR 0 6
51423: PUSH
51424: LD_INT 2
51426: ARRAY
51427: PUSH
51428: LD_VAR 0 5
51432: ARRAY
51433: PUSH
51434: EMPTY
51435: LIST
51436: LIST
51437: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
51438: LD_VAR 0 7
51442: PUSH
51443: LD_INT 1
51445: ARRAY
51446: PPUSH
51447: LD_VAR 0 7
51451: PUSH
51452: LD_INT 2
51454: ARRAY
51455: PPUSH
51456: CALL_OW 428
51460: PUSH
51461: LD_INT 0
51463: EQUAL
51464: IFFALSE 51517
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
51466: LD_VAR 0 1
51470: PPUSH
51471: LD_VAR 0 7
51475: PUSH
51476: LD_INT 1
51478: ARRAY
51479: PPUSH
51480: LD_VAR 0 7
51484: PUSH
51485: LD_INT 2
51487: ARRAY
51488: PPUSH
51489: LD_VAR 0 3
51493: PPUSH
51494: CALL_OW 48
// result := IsPlaced ( unit ) ;
51498: LD_ADDR_VAR 0 4
51502: PUSH
51503: LD_VAR 0 1
51507: PPUSH
51508: CALL_OW 305
51512: ST_TO_ADDR
// exit ;
51513: POP
51514: POP
51515: GO 51521
// end ; end ;
51517: GO 51396
51519: POP
51520: POP
// end ;
51521: LD_VAR 0 4
51525: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
51526: LD_INT 0
51528: PPUSH
51529: PPUSH
51530: PPUSH
// if not side or side > 8 then
51531: LD_VAR 0 1
51535: NOT
51536: PUSH
51537: LD_VAR 0 1
51541: PUSH
51542: LD_INT 8
51544: GREATER
51545: OR
51546: IFFALSE 51550
// exit ;
51548: GO 51737
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
51550: LD_ADDR_VAR 0 4
51554: PUSH
51555: LD_INT 22
51557: PUSH
51558: LD_VAR 0 1
51562: PUSH
51563: EMPTY
51564: LIST
51565: LIST
51566: PUSH
51567: LD_INT 21
51569: PUSH
51570: LD_INT 3
51572: PUSH
51573: EMPTY
51574: LIST
51575: LIST
51576: PUSH
51577: EMPTY
51578: LIST
51579: LIST
51580: PPUSH
51581: CALL_OW 69
51585: ST_TO_ADDR
// if not tmp then
51586: LD_VAR 0 4
51590: NOT
51591: IFFALSE 51595
// exit ;
51593: GO 51737
// enable_addtolog := true ;
51595: LD_ADDR_OWVAR 81
51599: PUSH
51600: LD_INT 1
51602: ST_TO_ADDR
// AddToLog ( [ ) ;
51603: LD_STRING [
51605: PPUSH
51606: CALL_OW 561
// for i in tmp do
51610: LD_ADDR_VAR 0 3
51614: PUSH
51615: LD_VAR 0 4
51619: PUSH
51620: FOR_IN
51621: IFFALSE 51728
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
51623: LD_STRING [
51625: PUSH
51626: LD_VAR 0 3
51630: PPUSH
51631: CALL_OW 266
51635: STR
51636: PUSH
51637: LD_STRING , 
51639: STR
51640: PUSH
51641: LD_VAR 0 3
51645: PPUSH
51646: CALL_OW 250
51650: STR
51651: PUSH
51652: LD_STRING , 
51654: STR
51655: PUSH
51656: LD_VAR 0 3
51660: PPUSH
51661: CALL_OW 251
51665: STR
51666: PUSH
51667: LD_STRING , 
51669: STR
51670: PUSH
51671: LD_VAR 0 3
51675: PPUSH
51676: CALL_OW 254
51680: STR
51681: PUSH
51682: LD_STRING , 
51684: STR
51685: PUSH
51686: LD_VAR 0 3
51690: PPUSH
51691: LD_INT 1
51693: PPUSH
51694: CALL_OW 268
51698: STR
51699: PUSH
51700: LD_STRING , 
51702: STR
51703: PUSH
51704: LD_VAR 0 3
51708: PPUSH
51709: LD_INT 2
51711: PPUSH
51712: CALL_OW 268
51716: STR
51717: PUSH
51718: LD_STRING ],
51720: STR
51721: PPUSH
51722: CALL_OW 561
// end ;
51726: GO 51620
51728: POP
51729: POP
// AddToLog ( ]; ) ;
51730: LD_STRING ];
51732: PPUSH
51733: CALL_OW 561
// end ;
51737: LD_VAR 0 2
51741: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
51742: LD_INT 0
51744: PPUSH
51745: PPUSH
51746: PPUSH
51747: PPUSH
51748: PPUSH
// if not area or not rate or not max then
51749: LD_VAR 0 1
51753: NOT
51754: PUSH
51755: LD_VAR 0 2
51759: NOT
51760: OR
51761: PUSH
51762: LD_VAR 0 4
51766: NOT
51767: OR
51768: IFFALSE 51772
// exit ;
51770: GO 51961
// while 1 do
51772: LD_INT 1
51774: IFFALSE 51961
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
51776: LD_ADDR_VAR 0 9
51780: PUSH
51781: LD_VAR 0 1
51785: PPUSH
51786: LD_INT 1
51788: PPUSH
51789: CALL_OW 287
51793: PUSH
51794: LD_INT 10
51796: MUL
51797: ST_TO_ADDR
// r := rate / 10 ;
51798: LD_ADDR_VAR 0 7
51802: PUSH
51803: LD_VAR 0 2
51807: PUSH
51808: LD_INT 10
51810: DIVREAL
51811: ST_TO_ADDR
// time := 1 1$00 ;
51812: LD_ADDR_VAR 0 8
51816: PUSH
51817: LD_INT 2100
51819: ST_TO_ADDR
// if amount < min then
51820: LD_VAR 0 9
51824: PUSH
51825: LD_VAR 0 3
51829: LESS
51830: IFFALSE 51848
// r := r * 2 else
51832: LD_ADDR_VAR 0 7
51836: PUSH
51837: LD_VAR 0 7
51841: PUSH
51842: LD_INT 2
51844: MUL
51845: ST_TO_ADDR
51846: GO 51874
// if amount > max then
51848: LD_VAR 0 9
51852: PUSH
51853: LD_VAR 0 4
51857: GREATER
51858: IFFALSE 51874
// r := r / 2 ;
51860: LD_ADDR_VAR 0 7
51864: PUSH
51865: LD_VAR 0 7
51869: PUSH
51870: LD_INT 2
51872: DIVREAL
51873: ST_TO_ADDR
// time := time / r ;
51874: LD_ADDR_VAR 0 8
51878: PUSH
51879: LD_VAR 0 8
51883: PUSH
51884: LD_VAR 0 7
51888: DIVREAL
51889: ST_TO_ADDR
// if time < 0 then
51890: LD_VAR 0 8
51894: PUSH
51895: LD_INT 0
51897: LESS
51898: IFFALSE 51915
// time := time * - 1 ;
51900: LD_ADDR_VAR 0 8
51904: PUSH
51905: LD_VAR 0 8
51909: PUSH
51910: LD_INT 1
51912: NEG
51913: MUL
51914: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
51915: LD_VAR 0 8
51919: PUSH
51920: LD_INT 35
51922: PPUSH
51923: LD_INT 875
51925: PPUSH
51926: CALL_OW 12
51930: PLUS
51931: PPUSH
51932: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
51936: LD_INT 1
51938: PPUSH
51939: LD_INT 5
51941: PPUSH
51942: CALL_OW 12
51946: PPUSH
51947: LD_VAR 0 1
51951: PPUSH
51952: LD_INT 1
51954: PPUSH
51955: CALL_OW 55
// end ;
51959: GO 51772
// end ;
51961: LD_VAR 0 5
51965: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
51966: LD_INT 0
51968: PPUSH
51969: PPUSH
51970: PPUSH
51971: PPUSH
51972: PPUSH
51973: PPUSH
51974: PPUSH
51975: PPUSH
// if not turrets or not factories then
51976: LD_VAR 0 1
51980: NOT
51981: PUSH
51982: LD_VAR 0 2
51986: NOT
51987: OR
51988: IFFALSE 51992
// exit ;
51990: GO 52299
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
51992: LD_ADDR_VAR 0 10
51996: PUSH
51997: LD_INT 5
51999: PUSH
52000: LD_INT 6
52002: PUSH
52003: EMPTY
52004: LIST
52005: LIST
52006: PUSH
52007: LD_INT 2
52009: PUSH
52010: LD_INT 4
52012: PUSH
52013: EMPTY
52014: LIST
52015: LIST
52016: PUSH
52017: LD_INT 3
52019: PUSH
52020: LD_INT 5
52022: PUSH
52023: EMPTY
52024: LIST
52025: LIST
52026: PUSH
52027: EMPTY
52028: LIST
52029: LIST
52030: LIST
52031: PUSH
52032: LD_INT 24
52034: PUSH
52035: LD_INT 25
52037: PUSH
52038: EMPTY
52039: LIST
52040: LIST
52041: PUSH
52042: LD_INT 23
52044: PUSH
52045: LD_INT 27
52047: PUSH
52048: EMPTY
52049: LIST
52050: LIST
52051: PUSH
52052: EMPTY
52053: LIST
52054: LIST
52055: PUSH
52056: LD_INT 42
52058: PUSH
52059: LD_INT 43
52061: PUSH
52062: EMPTY
52063: LIST
52064: LIST
52065: PUSH
52066: LD_INT 44
52068: PUSH
52069: LD_INT 46
52071: PUSH
52072: EMPTY
52073: LIST
52074: LIST
52075: PUSH
52076: LD_INT 45
52078: PUSH
52079: LD_INT 47
52081: PUSH
52082: EMPTY
52083: LIST
52084: LIST
52085: PUSH
52086: EMPTY
52087: LIST
52088: LIST
52089: LIST
52090: PUSH
52091: EMPTY
52092: LIST
52093: LIST
52094: LIST
52095: ST_TO_ADDR
// result := [ ] ;
52096: LD_ADDR_VAR 0 3
52100: PUSH
52101: EMPTY
52102: ST_TO_ADDR
// for i in turrets do
52103: LD_ADDR_VAR 0 4
52107: PUSH
52108: LD_VAR 0 1
52112: PUSH
52113: FOR_IN
52114: IFFALSE 52297
// begin nat := GetNation ( i ) ;
52116: LD_ADDR_VAR 0 7
52120: PUSH
52121: LD_VAR 0 4
52125: PPUSH
52126: CALL_OW 248
52130: ST_TO_ADDR
// weapon := 0 ;
52131: LD_ADDR_VAR 0 8
52135: PUSH
52136: LD_INT 0
52138: ST_TO_ADDR
// if not nat then
52139: LD_VAR 0 7
52143: NOT
52144: IFFALSE 52148
// continue ;
52146: GO 52113
// for j in list [ nat ] do
52148: LD_ADDR_VAR 0 5
52152: PUSH
52153: LD_VAR 0 10
52157: PUSH
52158: LD_VAR 0 7
52162: ARRAY
52163: PUSH
52164: FOR_IN
52165: IFFALSE 52206
// if GetBWeapon ( i ) = j [ 1 ] then
52167: LD_VAR 0 4
52171: PPUSH
52172: CALL_OW 269
52176: PUSH
52177: LD_VAR 0 5
52181: PUSH
52182: LD_INT 1
52184: ARRAY
52185: EQUAL
52186: IFFALSE 52204
// begin weapon := j [ 2 ] ;
52188: LD_ADDR_VAR 0 8
52192: PUSH
52193: LD_VAR 0 5
52197: PUSH
52198: LD_INT 2
52200: ARRAY
52201: ST_TO_ADDR
// break ;
52202: GO 52206
// end ;
52204: GO 52164
52206: POP
52207: POP
// if not weapon then
52208: LD_VAR 0 8
52212: NOT
52213: IFFALSE 52217
// continue ;
52215: GO 52113
// for k in factories do
52217: LD_ADDR_VAR 0 6
52221: PUSH
52222: LD_VAR 0 2
52226: PUSH
52227: FOR_IN
52228: IFFALSE 52293
// begin weapons := AvailableWeaponList ( k ) ;
52230: LD_ADDR_VAR 0 9
52234: PUSH
52235: LD_VAR 0 6
52239: PPUSH
52240: CALL_OW 478
52244: ST_TO_ADDR
// if not weapons then
52245: LD_VAR 0 9
52249: NOT
52250: IFFALSE 52254
// continue ;
52252: GO 52227
// if weapon in weapons then
52254: LD_VAR 0 8
52258: PUSH
52259: LD_VAR 0 9
52263: IN
52264: IFFALSE 52291
// begin result := [ i , weapon ] ;
52266: LD_ADDR_VAR 0 3
52270: PUSH
52271: LD_VAR 0 4
52275: PUSH
52276: LD_VAR 0 8
52280: PUSH
52281: EMPTY
52282: LIST
52283: LIST
52284: ST_TO_ADDR
// exit ;
52285: POP
52286: POP
52287: POP
52288: POP
52289: GO 52299
// end ; end ;
52291: GO 52227
52293: POP
52294: POP
// end ;
52295: GO 52113
52297: POP
52298: POP
// end ;
52299: LD_VAR 0 3
52303: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
52304: LD_INT 0
52306: PPUSH
// if not side or side > 8 then
52307: LD_VAR 0 3
52311: NOT
52312: PUSH
52313: LD_VAR 0 3
52317: PUSH
52318: LD_INT 8
52320: GREATER
52321: OR
52322: IFFALSE 52326
// exit ;
52324: GO 52385
// if not range then
52326: LD_VAR 0 4
52330: NOT
52331: IFFALSE 52342
// range := - 12 ;
52333: LD_ADDR_VAR 0 4
52337: PUSH
52338: LD_INT 12
52340: NEG
52341: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
52342: LD_VAR 0 1
52346: PPUSH
52347: LD_VAR 0 2
52351: PPUSH
52352: LD_VAR 0 3
52356: PPUSH
52357: LD_VAR 0 4
52361: PPUSH
52362: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
52366: LD_VAR 0 1
52370: PPUSH
52371: LD_VAR 0 2
52375: PPUSH
52376: LD_VAR 0 3
52380: PPUSH
52381: CALL_OW 331
// end ;
52385: LD_VAR 0 5
52389: RET
// export function Video ( mode ) ; begin
52390: LD_INT 0
52392: PPUSH
// ingame_video = mode ;
52393: LD_ADDR_OWVAR 52
52397: PUSH
52398: LD_VAR 0 1
52402: ST_TO_ADDR
// interface_hidden = mode ;
52403: LD_ADDR_OWVAR 54
52407: PUSH
52408: LD_VAR 0 1
52412: ST_TO_ADDR
// end ;
52413: LD_VAR 0 2
52417: RET
// export function Join ( array , element ) ; begin
52418: LD_INT 0
52420: PPUSH
// result := Replace ( array , array + 1 , element ) ;
52421: LD_ADDR_VAR 0 3
52425: PUSH
52426: LD_VAR 0 1
52430: PPUSH
52431: LD_VAR 0 1
52435: PUSH
52436: LD_INT 1
52438: PLUS
52439: PPUSH
52440: LD_VAR 0 2
52444: PPUSH
52445: CALL_OW 1
52449: ST_TO_ADDR
// end ;
52450: LD_VAR 0 3
52454: RET
// export function JoinUnion ( array , element ) ; begin
52455: LD_INT 0
52457: PPUSH
// result := array union element ;
52458: LD_ADDR_VAR 0 3
52462: PUSH
52463: LD_VAR 0 1
52467: PUSH
52468: LD_VAR 0 2
52472: UNION
52473: ST_TO_ADDR
// end ;
52474: LD_VAR 0 3
52478: RET
// export function GetBehemoths ( side ) ; begin
52479: LD_INT 0
52481: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
52482: LD_ADDR_VAR 0 2
52486: PUSH
52487: LD_INT 22
52489: PUSH
52490: LD_VAR 0 1
52494: PUSH
52495: EMPTY
52496: LIST
52497: LIST
52498: PUSH
52499: LD_INT 31
52501: PUSH
52502: LD_INT 25
52504: PUSH
52505: EMPTY
52506: LIST
52507: LIST
52508: PUSH
52509: EMPTY
52510: LIST
52511: LIST
52512: PPUSH
52513: CALL_OW 69
52517: ST_TO_ADDR
// end ;
52518: LD_VAR 0 2
52522: RET
// export function Shuffle ( array ) ; var i , index ; begin
52523: LD_INT 0
52525: PPUSH
52526: PPUSH
52527: PPUSH
// result := [ ] ;
52528: LD_ADDR_VAR 0 2
52532: PUSH
52533: EMPTY
52534: ST_TO_ADDR
// if not array then
52535: LD_VAR 0 1
52539: NOT
52540: IFFALSE 52544
// exit ;
52542: GO 52643
// Randomize ;
52544: CALL_OW 10
// for i = array downto 1 do
52548: LD_ADDR_VAR 0 3
52552: PUSH
52553: DOUBLE
52554: LD_VAR 0 1
52558: INC
52559: ST_TO_ADDR
52560: LD_INT 1
52562: PUSH
52563: FOR_DOWNTO
52564: IFFALSE 52641
// begin index := rand ( 1 , array ) ;
52566: LD_ADDR_VAR 0 4
52570: PUSH
52571: LD_INT 1
52573: PPUSH
52574: LD_VAR 0 1
52578: PPUSH
52579: CALL_OW 12
52583: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
52584: LD_ADDR_VAR 0 2
52588: PUSH
52589: LD_VAR 0 2
52593: PPUSH
52594: LD_VAR 0 2
52598: PUSH
52599: LD_INT 1
52601: PLUS
52602: PPUSH
52603: LD_VAR 0 1
52607: PUSH
52608: LD_VAR 0 4
52612: ARRAY
52613: PPUSH
52614: CALL_OW 2
52618: ST_TO_ADDR
// array := Delete ( array , index ) ;
52619: LD_ADDR_VAR 0 1
52623: PUSH
52624: LD_VAR 0 1
52628: PPUSH
52629: LD_VAR 0 4
52633: PPUSH
52634: CALL_OW 3
52638: ST_TO_ADDR
// end ;
52639: GO 52563
52641: POP
52642: POP
// end ;
52643: LD_VAR 0 2
52647: RET
// export function GetBaseMaterials ( base ) ; begin
52648: LD_INT 0
52650: PPUSH
// result := [ 0 , 0 , 0 ] ;
52651: LD_ADDR_VAR 0 2
52655: PUSH
52656: LD_INT 0
52658: PUSH
52659: LD_INT 0
52661: PUSH
52662: LD_INT 0
52664: PUSH
52665: EMPTY
52666: LIST
52667: LIST
52668: LIST
52669: ST_TO_ADDR
// if not base then
52670: LD_VAR 0 1
52674: NOT
52675: IFFALSE 52679
// exit ;
52677: GO 52728
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
52679: LD_ADDR_VAR 0 2
52683: PUSH
52684: LD_VAR 0 1
52688: PPUSH
52689: LD_INT 1
52691: PPUSH
52692: CALL_OW 275
52696: PUSH
52697: LD_VAR 0 1
52701: PPUSH
52702: LD_INT 2
52704: PPUSH
52705: CALL_OW 275
52709: PUSH
52710: LD_VAR 0 1
52714: PPUSH
52715: LD_INT 3
52717: PPUSH
52718: CALL_OW 275
52722: PUSH
52723: EMPTY
52724: LIST
52725: LIST
52726: LIST
52727: ST_TO_ADDR
// end ;
52728: LD_VAR 0 2
52732: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
52733: LD_INT 0
52735: PPUSH
52736: PPUSH
// result := array ;
52737: LD_ADDR_VAR 0 3
52741: PUSH
52742: LD_VAR 0 1
52746: ST_TO_ADDR
// if size >= result then
52747: LD_VAR 0 2
52751: PUSH
52752: LD_VAR 0 3
52756: GREATEREQUAL
52757: IFFALSE 52761
// exit ;
52759: GO 52811
// if size then
52761: LD_VAR 0 2
52765: IFFALSE 52811
// for i := array downto size do
52767: LD_ADDR_VAR 0 4
52771: PUSH
52772: DOUBLE
52773: LD_VAR 0 1
52777: INC
52778: ST_TO_ADDR
52779: LD_VAR 0 2
52783: PUSH
52784: FOR_DOWNTO
52785: IFFALSE 52809
// result := Delete ( result , result ) ;
52787: LD_ADDR_VAR 0 3
52791: PUSH
52792: LD_VAR 0 3
52796: PPUSH
52797: LD_VAR 0 3
52801: PPUSH
52802: CALL_OW 3
52806: ST_TO_ADDR
52807: GO 52784
52809: POP
52810: POP
// end ;
52811: LD_VAR 0 3
52815: RET
// export function ComExit ( unit ) ; var tmp ; begin
52816: LD_INT 0
52818: PPUSH
52819: PPUSH
// if not IsInUnit ( unit ) then
52820: LD_VAR 0 1
52824: PPUSH
52825: CALL_OW 310
52829: NOT
52830: IFFALSE 52834
// exit ;
52832: GO 52894
// tmp := IsInUnit ( unit ) ;
52834: LD_ADDR_VAR 0 3
52838: PUSH
52839: LD_VAR 0 1
52843: PPUSH
52844: CALL_OW 310
52848: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
52849: LD_VAR 0 3
52853: PPUSH
52854: CALL_OW 247
52858: PUSH
52859: LD_INT 2
52861: EQUAL
52862: IFFALSE 52875
// ComExitVehicle ( unit ) else
52864: LD_VAR 0 1
52868: PPUSH
52869: CALL_OW 121
52873: GO 52884
// ComExitBuilding ( unit ) ;
52875: LD_VAR 0 1
52879: PPUSH
52880: CALL_OW 122
// result := tmp ;
52884: LD_ADDR_VAR 0 2
52888: PUSH
52889: LD_VAR 0 3
52893: ST_TO_ADDR
// end ;
52894: LD_VAR 0 2
52898: RET
// export function ComExitAll ( units ) ; var i ; begin
52899: LD_INT 0
52901: PPUSH
52902: PPUSH
// if not units then
52903: LD_VAR 0 1
52907: NOT
52908: IFFALSE 52912
// exit ;
52910: GO 52938
// for i in units do
52912: LD_ADDR_VAR 0 3
52916: PUSH
52917: LD_VAR 0 1
52921: PUSH
52922: FOR_IN
52923: IFFALSE 52936
// ComExit ( i ) ;
52925: LD_VAR 0 3
52929: PPUSH
52930: CALL 52816 0 1
52934: GO 52922
52936: POP
52937: POP
// end ;
52938: LD_VAR 0 2
52942: RET
// export function ResetHc ; begin
52943: LD_INT 0
52945: PPUSH
// InitHc ;
52946: CALL_OW 19
// hc_importance := 0 ;
52950: LD_ADDR_OWVAR 32
52954: PUSH
52955: LD_INT 0
52957: ST_TO_ADDR
// end ;
52958: LD_VAR 0 1
52962: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
52963: LD_INT 0
52965: PPUSH
52966: PPUSH
52967: PPUSH
// _x := ( x1 + x2 ) div 2 ;
52968: LD_ADDR_VAR 0 6
52972: PUSH
52973: LD_VAR 0 1
52977: PUSH
52978: LD_VAR 0 3
52982: PLUS
52983: PUSH
52984: LD_INT 2
52986: DIV
52987: ST_TO_ADDR
// if _x < 0 then
52988: LD_VAR 0 6
52992: PUSH
52993: LD_INT 0
52995: LESS
52996: IFFALSE 53013
// _x := _x * - 1 ;
52998: LD_ADDR_VAR 0 6
53002: PUSH
53003: LD_VAR 0 6
53007: PUSH
53008: LD_INT 1
53010: NEG
53011: MUL
53012: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
53013: LD_ADDR_VAR 0 7
53017: PUSH
53018: LD_VAR 0 2
53022: PUSH
53023: LD_VAR 0 4
53027: PLUS
53028: PUSH
53029: LD_INT 2
53031: DIV
53032: ST_TO_ADDR
// if _y < 0 then
53033: LD_VAR 0 7
53037: PUSH
53038: LD_INT 0
53040: LESS
53041: IFFALSE 53058
// _y := _y * - 1 ;
53043: LD_ADDR_VAR 0 7
53047: PUSH
53048: LD_VAR 0 7
53052: PUSH
53053: LD_INT 1
53055: NEG
53056: MUL
53057: ST_TO_ADDR
// result := [ _x , _y ] ;
53058: LD_ADDR_VAR 0 5
53062: PUSH
53063: LD_VAR 0 6
53067: PUSH
53068: LD_VAR 0 7
53072: PUSH
53073: EMPTY
53074: LIST
53075: LIST
53076: ST_TO_ADDR
// end ;
53077: LD_VAR 0 5
53081: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
53082: LD_INT 0
53084: PPUSH
53085: PPUSH
53086: PPUSH
53087: PPUSH
// task := GetTaskList ( unit ) ;
53088: LD_ADDR_VAR 0 7
53092: PUSH
53093: LD_VAR 0 1
53097: PPUSH
53098: CALL_OW 437
53102: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
53103: LD_VAR 0 7
53107: NOT
53108: PUSH
53109: LD_VAR 0 1
53113: PPUSH
53114: LD_VAR 0 2
53118: PPUSH
53119: CALL_OW 308
53123: NOT
53124: AND
53125: IFFALSE 53129
// exit ;
53127: GO 53247
// if IsInArea ( unit , area ) then
53129: LD_VAR 0 1
53133: PPUSH
53134: LD_VAR 0 2
53138: PPUSH
53139: CALL_OW 308
53143: IFFALSE 53161
// begin ComMoveToArea ( unit , goAway ) ;
53145: LD_VAR 0 1
53149: PPUSH
53150: LD_VAR 0 3
53154: PPUSH
53155: CALL_OW 113
// exit ;
53159: GO 53247
// end ; if task [ 1 ] [ 1 ] <> M then
53161: LD_VAR 0 7
53165: PUSH
53166: LD_INT 1
53168: ARRAY
53169: PUSH
53170: LD_INT 1
53172: ARRAY
53173: PUSH
53174: LD_STRING M
53176: NONEQUAL
53177: IFFALSE 53181
// exit ;
53179: GO 53247
// x := task [ 1 ] [ 2 ] ;
53181: LD_ADDR_VAR 0 5
53185: PUSH
53186: LD_VAR 0 7
53190: PUSH
53191: LD_INT 1
53193: ARRAY
53194: PUSH
53195: LD_INT 2
53197: ARRAY
53198: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
53199: LD_ADDR_VAR 0 6
53203: PUSH
53204: LD_VAR 0 7
53208: PUSH
53209: LD_INT 1
53211: ARRAY
53212: PUSH
53213: LD_INT 3
53215: ARRAY
53216: ST_TO_ADDR
// if InArea ( x , y , area ) then
53217: LD_VAR 0 5
53221: PPUSH
53222: LD_VAR 0 6
53226: PPUSH
53227: LD_VAR 0 2
53231: PPUSH
53232: CALL_OW 309
53236: IFFALSE 53247
// ComStop ( unit ) ;
53238: LD_VAR 0 1
53242: PPUSH
53243: CALL_OW 141
// end ;
53247: LD_VAR 0 4
53251: RET
// export function Abs ( value ) ; begin
53252: LD_INT 0
53254: PPUSH
// result := value ;
53255: LD_ADDR_VAR 0 2
53259: PUSH
53260: LD_VAR 0 1
53264: ST_TO_ADDR
// if value < 0 then
53265: LD_VAR 0 1
53269: PUSH
53270: LD_INT 0
53272: LESS
53273: IFFALSE 53290
// result := value * - 1 ;
53275: LD_ADDR_VAR 0 2
53279: PUSH
53280: LD_VAR 0 1
53284: PUSH
53285: LD_INT 1
53287: NEG
53288: MUL
53289: ST_TO_ADDR
// end ;
53290: LD_VAR 0 2
53294: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
53295: LD_INT 0
53297: PPUSH
53298: PPUSH
53299: PPUSH
53300: PPUSH
53301: PPUSH
53302: PPUSH
53303: PPUSH
53304: PPUSH
// if not unit or not building then
53305: LD_VAR 0 1
53309: NOT
53310: PUSH
53311: LD_VAR 0 2
53315: NOT
53316: OR
53317: IFFALSE 53321
// exit ;
53319: GO 53547
// x := GetX ( building ) ;
53321: LD_ADDR_VAR 0 4
53325: PUSH
53326: LD_VAR 0 2
53330: PPUSH
53331: CALL_OW 250
53335: ST_TO_ADDR
// y := GetY ( building ) ;
53336: LD_ADDR_VAR 0 6
53340: PUSH
53341: LD_VAR 0 2
53345: PPUSH
53346: CALL_OW 251
53350: ST_TO_ADDR
// d := GetDir ( building ) ;
53351: LD_ADDR_VAR 0 8
53355: PUSH
53356: LD_VAR 0 2
53360: PPUSH
53361: CALL_OW 254
53365: ST_TO_ADDR
// r := 4 ;
53366: LD_ADDR_VAR 0 9
53370: PUSH
53371: LD_INT 4
53373: ST_TO_ADDR
// for i := 1 to 5 do
53374: LD_ADDR_VAR 0 10
53378: PUSH
53379: DOUBLE
53380: LD_INT 1
53382: DEC
53383: ST_TO_ADDR
53384: LD_INT 5
53386: PUSH
53387: FOR_TO
53388: IFFALSE 53545
// begin _x := ShiftX ( x , d , r + i ) ;
53390: LD_ADDR_VAR 0 5
53394: PUSH
53395: LD_VAR 0 4
53399: PPUSH
53400: LD_VAR 0 8
53404: PPUSH
53405: LD_VAR 0 9
53409: PUSH
53410: LD_VAR 0 10
53414: PLUS
53415: PPUSH
53416: CALL_OW 272
53420: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
53421: LD_ADDR_VAR 0 7
53425: PUSH
53426: LD_VAR 0 6
53430: PPUSH
53431: LD_VAR 0 8
53435: PPUSH
53436: LD_VAR 0 9
53440: PUSH
53441: LD_VAR 0 10
53445: PLUS
53446: PPUSH
53447: CALL_OW 273
53451: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
53452: LD_VAR 0 5
53456: PPUSH
53457: LD_VAR 0 7
53461: PPUSH
53462: CALL_OW 488
53466: PUSH
53467: LD_VAR 0 5
53471: PPUSH
53472: LD_VAR 0 7
53476: PPUSH
53477: CALL_OW 428
53481: PPUSH
53482: CALL_OW 247
53486: PUSH
53487: LD_INT 3
53489: PUSH
53490: LD_INT 2
53492: PUSH
53493: EMPTY
53494: LIST
53495: LIST
53496: IN
53497: NOT
53498: AND
53499: IFFALSE 53543
// begin ComMoveXY ( unit , _x , _y ) ;
53501: LD_VAR 0 1
53505: PPUSH
53506: LD_VAR 0 5
53510: PPUSH
53511: LD_VAR 0 7
53515: PPUSH
53516: CALL_OW 111
// result := [ _x , _y ] ;
53520: LD_ADDR_VAR 0 3
53524: PUSH
53525: LD_VAR 0 5
53529: PUSH
53530: LD_VAR 0 7
53534: PUSH
53535: EMPTY
53536: LIST
53537: LIST
53538: ST_TO_ADDR
// exit ;
53539: POP
53540: POP
53541: GO 53547
// end ; end ;
53543: GO 53387
53545: POP
53546: POP
// end ;
53547: LD_VAR 0 3
53551: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
53552: LD_INT 0
53554: PPUSH
53555: PPUSH
53556: PPUSH
// result := 0 ;
53557: LD_ADDR_VAR 0 3
53561: PUSH
53562: LD_INT 0
53564: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
53565: LD_VAR 0 1
53569: PUSH
53570: LD_INT 0
53572: LESS
53573: PUSH
53574: LD_VAR 0 1
53578: PUSH
53579: LD_INT 8
53581: GREATER
53582: OR
53583: PUSH
53584: LD_VAR 0 2
53588: PUSH
53589: LD_INT 0
53591: LESS
53592: OR
53593: PUSH
53594: LD_VAR 0 2
53598: PUSH
53599: LD_INT 8
53601: GREATER
53602: OR
53603: IFFALSE 53607
// exit ;
53605: GO 53682
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
53607: LD_ADDR_VAR 0 4
53611: PUSH
53612: LD_INT 22
53614: PUSH
53615: LD_VAR 0 2
53619: PUSH
53620: EMPTY
53621: LIST
53622: LIST
53623: PPUSH
53624: CALL_OW 69
53628: PUSH
53629: FOR_IN
53630: IFFALSE 53680
// begin un := UnitShoot ( i ) ;
53632: LD_ADDR_VAR 0 5
53636: PUSH
53637: LD_VAR 0 4
53641: PPUSH
53642: CALL_OW 504
53646: ST_TO_ADDR
// if GetSide ( un ) = side1 then
53647: LD_VAR 0 5
53651: PPUSH
53652: CALL_OW 255
53656: PUSH
53657: LD_VAR 0 1
53661: EQUAL
53662: IFFALSE 53678
// begin result := un ;
53664: LD_ADDR_VAR 0 3
53668: PUSH
53669: LD_VAR 0 5
53673: ST_TO_ADDR
// exit ;
53674: POP
53675: POP
53676: GO 53682
// end ; end ;
53678: GO 53629
53680: POP
53681: POP
// end ;
53682: LD_VAR 0 3
53686: RET
// export function GetCargoBay ( units ) ; begin
53687: LD_INT 0
53689: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
53690: LD_ADDR_VAR 0 2
53694: PUSH
53695: LD_VAR 0 1
53699: PPUSH
53700: LD_INT 2
53702: PUSH
53703: LD_INT 34
53705: PUSH
53706: LD_INT 12
53708: PUSH
53709: EMPTY
53710: LIST
53711: LIST
53712: PUSH
53713: LD_INT 34
53715: PUSH
53716: LD_INT 51
53718: PUSH
53719: EMPTY
53720: LIST
53721: LIST
53722: PUSH
53723: LD_INT 34
53725: PUSH
53726: LD_INT 32
53728: PUSH
53729: EMPTY
53730: LIST
53731: LIST
53732: PUSH
53733: LD_INT 34
53735: PUSH
53736: LD_INT 89
53738: PUSH
53739: EMPTY
53740: LIST
53741: LIST
53742: PUSH
53743: EMPTY
53744: LIST
53745: LIST
53746: LIST
53747: LIST
53748: LIST
53749: PPUSH
53750: CALL_OW 72
53754: ST_TO_ADDR
// end ;
53755: LD_VAR 0 2
53759: RET
// export function Negate ( value ) ; begin
53760: LD_INT 0
53762: PPUSH
// result := not value ;
53763: LD_ADDR_VAR 0 2
53767: PUSH
53768: LD_VAR 0 1
53772: NOT
53773: ST_TO_ADDR
// end ;
53774: LD_VAR 0 2
53778: RET
// export function Inc ( value ) ; begin
53779: LD_INT 0
53781: PPUSH
// result := value + 1 ;
53782: LD_ADDR_VAR 0 2
53786: PUSH
53787: LD_VAR 0 1
53791: PUSH
53792: LD_INT 1
53794: PLUS
53795: ST_TO_ADDR
// end ;
53796: LD_VAR 0 2
53800: RET
// export function Dec ( value ) ; begin
53801: LD_INT 0
53803: PPUSH
// result := value - 1 ;
53804: LD_ADDR_VAR 0 2
53808: PUSH
53809: LD_VAR 0 1
53813: PUSH
53814: LD_INT 1
53816: MINUS
53817: ST_TO_ADDR
// end ;
53818: LD_VAR 0 2
53822: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
53823: LD_INT 0
53825: PPUSH
53826: PPUSH
53827: PPUSH
53828: PPUSH
53829: PPUSH
53830: PPUSH
53831: PPUSH
53832: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
53833: LD_VAR 0 1
53837: PPUSH
53838: LD_VAR 0 2
53842: PPUSH
53843: CALL_OW 488
53847: NOT
53848: PUSH
53849: LD_VAR 0 3
53853: PPUSH
53854: LD_VAR 0 4
53858: PPUSH
53859: CALL_OW 488
53863: NOT
53864: OR
53865: IFFALSE 53878
// begin result := - 1 ;
53867: LD_ADDR_VAR 0 5
53871: PUSH
53872: LD_INT 1
53874: NEG
53875: ST_TO_ADDR
// exit ;
53876: GO 54113
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
53878: LD_ADDR_VAR 0 12
53882: PUSH
53883: LD_VAR 0 1
53887: PPUSH
53888: LD_VAR 0 2
53892: PPUSH
53893: LD_VAR 0 3
53897: PPUSH
53898: LD_VAR 0 4
53902: PPUSH
53903: CALL 52963 0 4
53907: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
53908: LD_ADDR_VAR 0 11
53912: PUSH
53913: LD_VAR 0 1
53917: PPUSH
53918: LD_VAR 0 2
53922: PPUSH
53923: LD_VAR 0 12
53927: PUSH
53928: LD_INT 1
53930: ARRAY
53931: PPUSH
53932: LD_VAR 0 12
53936: PUSH
53937: LD_INT 2
53939: ARRAY
53940: PPUSH
53941: CALL_OW 298
53945: ST_TO_ADDR
// distance := 9999 ;
53946: LD_ADDR_VAR 0 10
53950: PUSH
53951: LD_INT 9999
53953: ST_TO_ADDR
// for i := 0 to 5 do
53954: LD_ADDR_VAR 0 6
53958: PUSH
53959: DOUBLE
53960: LD_INT 0
53962: DEC
53963: ST_TO_ADDR
53964: LD_INT 5
53966: PUSH
53967: FOR_TO
53968: IFFALSE 54111
// begin _x := ShiftX ( x1 , i , centerDist ) ;
53970: LD_ADDR_VAR 0 7
53974: PUSH
53975: LD_VAR 0 1
53979: PPUSH
53980: LD_VAR 0 6
53984: PPUSH
53985: LD_VAR 0 11
53989: PPUSH
53990: CALL_OW 272
53994: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
53995: LD_ADDR_VAR 0 8
53999: PUSH
54000: LD_VAR 0 2
54004: PPUSH
54005: LD_VAR 0 6
54009: PPUSH
54010: LD_VAR 0 11
54014: PPUSH
54015: CALL_OW 273
54019: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54020: LD_VAR 0 7
54024: PPUSH
54025: LD_VAR 0 8
54029: PPUSH
54030: CALL_OW 488
54034: NOT
54035: IFFALSE 54039
// continue ;
54037: GO 53967
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
54039: LD_ADDR_VAR 0 9
54043: PUSH
54044: LD_VAR 0 12
54048: PUSH
54049: LD_INT 1
54051: ARRAY
54052: PPUSH
54053: LD_VAR 0 12
54057: PUSH
54058: LD_INT 2
54060: ARRAY
54061: PPUSH
54062: LD_VAR 0 7
54066: PPUSH
54067: LD_VAR 0 8
54071: PPUSH
54072: CALL_OW 298
54076: ST_TO_ADDR
// if tmp < distance then
54077: LD_VAR 0 9
54081: PUSH
54082: LD_VAR 0 10
54086: LESS
54087: IFFALSE 54109
// begin result := i ;
54089: LD_ADDR_VAR 0 5
54093: PUSH
54094: LD_VAR 0 6
54098: ST_TO_ADDR
// distance := tmp ;
54099: LD_ADDR_VAR 0 10
54103: PUSH
54104: LD_VAR 0 9
54108: ST_TO_ADDR
// end ; end ;
54109: GO 53967
54111: POP
54112: POP
// end ;
54113: LD_VAR 0 5
54117: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
54118: LD_INT 0
54120: PPUSH
54121: PPUSH
// if not driver or not IsInUnit ( driver ) then
54122: LD_VAR 0 1
54126: NOT
54127: PUSH
54128: LD_VAR 0 1
54132: PPUSH
54133: CALL_OW 310
54137: NOT
54138: OR
54139: IFFALSE 54143
// exit ;
54141: GO 54233
// vehicle := IsInUnit ( driver ) ;
54143: LD_ADDR_VAR 0 3
54147: PUSH
54148: LD_VAR 0 1
54152: PPUSH
54153: CALL_OW 310
54157: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
54158: LD_VAR 0 1
54162: PPUSH
54163: LD_STRING \
54165: PUSH
54166: LD_INT 0
54168: PUSH
54169: LD_INT 0
54171: PUSH
54172: LD_INT 0
54174: PUSH
54175: LD_INT 0
54177: PUSH
54178: LD_INT 0
54180: PUSH
54181: LD_INT 0
54183: PUSH
54184: EMPTY
54185: LIST
54186: LIST
54187: LIST
54188: LIST
54189: LIST
54190: LIST
54191: LIST
54192: PUSH
54193: LD_STRING E
54195: PUSH
54196: LD_INT 0
54198: PUSH
54199: LD_INT 0
54201: PUSH
54202: LD_VAR 0 3
54206: PUSH
54207: LD_INT 0
54209: PUSH
54210: LD_INT 0
54212: PUSH
54213: LD_INT 0
54215: PUSH
54216: EMPTY
54217: LIST
54218: LIST
54219: LIST
54220: LIST
54221: LIST
54222: LIST
54223: LIST
54224: PUSH
54225: EMPTY
54226: LIST
54227: LIST
54228: PPUSH
54229: CALL_OW 446
// end ;
54233: LD_VAR 0 2
54237: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
54238: LD_INT 0
54240: PPUSH
54241: PPUSH
// if not driver or not IsInUnit ( driver ) then
54242: LD_VAR 0 1
54246: NOT
54247: PUSH
54248: LD_VAR 0 1
54252: PPUSH
54253: CALL_OW 310
54257: NOT
54258: OR
54259: IFFALSE 54263
// exit ;
54261: GO 54353
// vehicle := IsInUnit ( driver ) ;
54263: LD_ADDR_VAR 0 3
54267: PUSH
54268: LD_VAR 0 1
54272: PPUSH
54273: CALL_OW 310
54277: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
54278: LD_VAR 0 1
54282: PPUSH
54283: LD_STRING \
54285: PUSH
54286: LD_INT 0
54288: PUSH
54289: LD_INT 0
54291: PUSH
54292: LD_INT 0
54294: PUSH
54295: LD_INT 0
54297: PUSH
54298: LD_INT 0
54300: PUSH
54301: LD_INT 0
54303: PUSH
54304: EMPTY
54305: LIST
54306: LIST
54307: LIST
54308: LIST
54309: LIST
54310: LIST
54311: LIST
54312: PUSH
54313: LD_STRING E
54315: PUSH
54316: LD_INT 0
54318: PUSH
54319: LD_INT 0
54321: PUSH
54322: LD_VAR 0 3
54326: PUSH
54327: LD_INT 0
54329: PUSH
54330: LD_INT 0
54332: PUSH
54333: LD_INT 0
54335: PUSH
54336: EMPTY
54337: LIST
54338: LIST
54339: LIST
54340: LIST
54341: LIST
54342: LIST
54343: LIST
54344: PUSH
54345: EMPTY
54346: LIST
54347: LIST
54348: PPUSH
54349: CALL_OW 447
// end ;
54353: LD_VAR 0 2
54357: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
54358: LD_INT 0
54360: PPUSH
54361: PPUSH
54362: PPUSH
// tmp := [ ] ;
54363: LD_ADDR_VAR 0 5
54367: PUSH
54368: EMPTY
54369: ST_TO_ADDR
// for i in units do
54370: LD_ADDR_VAR 0 4
54374: PUSH
54375: LD_VAR 0 1
54379: PUSH
54380: FOR_IN
54381: IFFALSE 54419
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
54383: LD_ADDR_VAR 0 5
54387: PUSH
54388: LD_VAR 0 5
54392: PPUSH
54393: LD_VAR 0 5
54397: PUSH
54398: LD_INT 1
54400: PLUS
54401: PPUSH
54402: LD_VAR 0 4
54406: PPUSH
54407: CALL_OW 256
54411: PPUSH
54412: CALL_OW 2
54416: ST_TO_ADDR
54417: GO 54380
54419: POP
54420: POP
// if not tmp then
54421: LD_VAR 0 5
54425: NOT
54426: IFFALSE 54430
// exit ;
54428: GO 54478
// if asc then
54430: LD_VAR 0 2
54434: IFFALSE 54458
// result := SortListByListAsc ( units , tmp ) else
54436: LD_ADDR_VAR 0 3
54440: PUSH
54441: LD_VAR 0 1
54445: PPUSH
54446: LD_VAR 0 5
54450: PPUSH
54451: CALL_OW 76
54455: ST_TO_ADDR
54456: GO 54478
// result := SortListByListDesc ( units , tmp ) ;
54458: LD_ADDR_VAR 0 3
54462: PUSH
54463: LD_VAR 0 1
54467: PPUSH
54468: LD_VAR 0 5
54472: PPUSH
54473: CALL_OW 77
54477: ST_TO_ADDR
// end ;
54478: LD_VAR 0 3
54482: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
54483: LD_INT 0
54485: PPUSH
54486: PPUSH
// task := GetTaskList ( mech ) ;
54487: LD_ADDR_VAR 0 4
54491: PUSH
54492: LD_VAR 0 1
54496: PPUSH
54497: CALL_OW 437
54501: ST_TO_ADDR
// if not task then
54502: LD_VAR 0 4
54506: NOT
54507: IFFALSE 54511
// exit ;
54509: GO 54553
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
54511: LD_ADDR_VAR 0 3
54515: PUSH
54516: LD_VAR 0 4
54520: PUSH
54521: LD_INT 1
54523: ARRAY
54524: PUSH
54525: LD_INT 1
54527: ARRAY
54528: PUSH
54529: LD_STRING r
54531: EQUAL
54532: PUSH
54533: LD_VAR 0 4
54537: PUSH
54538: LD_INT 1
54540: ARRAY
54541: PUSH
54542: LD_INT 4
54544: ARRAY
54545: PUSH
54546: LD_VAR 0 2
54550: EQUAL
54551: AND
54552: ST_TO_ADDR
// end ;
54553: LD_VAR 0 3
54557: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
54558: LD_INT 0
54560: PPUSH
// SetDir ( unit , d ) ;
54561: LD_VAR 0 1
54565: PPUSH
54566: LD_VAR 0 4
54570: PPUSH
54571: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
54575: LD_VAR 0 1
54579: PPUSH
54580: LD_VAR 0 2
54584: PPUSH
54585: LD_VAR 0 3
54589: PPUSH
54590: LD_VAR 0 5
54594: PPUSH
54595: CALL_OW 48
// end ;
54599: LD_VAR 0 6
54603: RET
// export function ToNaturalNumber ( number ) ; begin
54604: LD_INT 0
54606: PPUSH
// result := number div 1 ;
54607: LD_ADDR_VAR 0 2
54611: PUSH
54612: LD_VAR 0 1
54616: PUSH
54617: LD_INT 1
54619: DIV
54620: ST_TO_ADDR
// if number < 0 then
54621: LD_VAR 0 1
54625: PUSH
54626: LD_INT 0
54628: LESS
54629: IFFALSE 54639
// result := 0 ;
54631: LD_ADDR_VAR 0 2
54635: PUSH
54636: LD_INT 0
54638: ST_TO_ADDR
// end ;
54639: LD_VAR 0 2
54643: RET
// export function SortByClass ( units , class ) ; var un ; begin
54644: LD_INT 0
54646: PPUSH
54647: PPUSH
// if not units or not class then
54648: LD_VAR 0 1
54652: NOT
54653: PUSH
54654: LD_VAR 0 2
54658: NOT
54659: OR
54660: IFFALSE 54664
// exit ;
54662: GO 54759
// result := [ ] ;
54664: LD_ADDR_VAR 0 3
54668: PUSH
54669: EMPTY
54670: ST_TO_ADDR
// for un in units do
54671: LD_ADDR_VAR 0 4
54675: PUSH
54676: LD_VAR 0 1
54680: PUSH
54681: FOR_IN
54682: IFFALSE 54757
// if GetClass ( un ) = class then
54684: LD_VAR 0 4
54688: PPUSH
54689: CALL_OW 257
54693: PUSH
54694: LD_VAR 0 2
54698: EQUAL
54699: IFFALSE 54726
// result := Insert ( result , 1 , un ) else
54701: LD_ADDR_VAR 0 3
54705: PUSH
54706: LD_VAR 0 3
54710: PPUSH
54711: LD_INT 1
54713: PPUSH
54714: LD_VAR 0 4
54718: PPUSH
54719: CALL_OW 2
54723: ST_TO_ADDR
54724: GO 54755
// result := Replace ( result , result + 1 , un ) ;
54726: LD_ADDR_VAR 0 3
54730: PUSH
54731: LD_VAR 0 3
54735: PPUSH
54736: LD_VAR 0 3
54740: PUSH
54741: LD_INT 1
54743: PLUS
54744: PPUSH
54745: LD_VAR 0 4
54749: PPUSH
54750: CALL_OW 1
54754: ST_TO_ADDR
54755: GO 54681
54757: POP
54758: POP
// end ;
54759: LD_VAR 0 3
54763: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
54764: LD_INT 0
54766: PPUSH
54767: PPUSH
54768: PPUSH
54769: PPUSH
54770: PPUSH
54771: PPUSH
54772: PPUSH
// result := [ ] ;
54773: LD_ADDR_VAR 0 4
54777: PUSH
54778: EMPTY
54779: ST_TO_ADDR
// if x - r < 0 then
54780: LD_VAR 0 1
54784: PUSH
54785: LD_VAR 0 3
54789: MINUS
54790: PUSH
54791: LD_INT 0
54793: LESS
54794: IFFALSE 54806
// min_x := 0 else
54796: LD_ADDR_VAR 0 8
54800: PUSH
54801: LD_INT 0
54803: ST_TO_ADDR
54804: GO 54822
// min_x := x - r ;
54806: LD_ADDR_VAR 0 8
54810: PUSH
54811: LD_VAR 0 1
54815: PUSH
54816: LD_VAR 0 3
54820: MINUS
54821: ST_TO_ADDR
// if y - r < 0 then
54822: LD_VAR 0 2
54826: PUSH
54827: LD_VAR 0 3
54831: MINUS
54832: PUSH
54833: LD_INT 0
54835: LESS
54836: IFFALSE 54848
// min_y := 0 else
54838: LD_ADDR_VAR 0 7
54842: PUSH
54843: LD_INT 0
54845: ST_TO_ADDR
54846: GO 54864
// min_y := y - r ;
54848: LD_ADDR_VAR 0 7
54852: PUSH
54853: LD_VAR 0 2
54857: PUSH
54858: LD_VAR 0 3
54862: MINUS
54863: ST_TO_ADDR
// max_x := x + r ;
54864: LD_ADDR_VAR 0 9
54868: PUSH
54869: LD_VAR 0 1
54873: PUSH
54874: LD_VAR 0 3
54878: PLUS
54879: ST_TO_ADDR
// max_y := y + r ;
54880: LD_ADDR_VAR 0 10
54884: PUSH
54885: LD_VAR 0 2
54889: PUSH
54890: LD_VAR 0 3
54894: PLUS
54895: ST_TO_ADDR
// for _x = min_x to max_x do
54896: LD_ADDR_VAR 0 5
54900: PUSH
54901: DOUBLE
54902: LD_VAR 0 8
54906: DEC
54907: ST_TO_ADDR
54908: LD_VAR 0 9
54912: PUSH
54913: FOR_TO
54914: IFFALSE 55015
// for _y = min_y to max_y do
54916: LD_ADDR_VAR 0 6
54920: PUSH
54921: DOUBLE
54922: LD_VAR 0 7
54926: DEC
54927: ST_TO_ADDR
54928: LD_VAR 0 10
54932: PUSH
54933: FOR_TO
54934: IFFALSE 55011
// begin if not ValidHex ( _x , _y ) then
54936: LD_VAR 0 5
54940: PPUSH
54941: LD_VAR 0 6
54945: PPUSH
54946: CALL_OW 488
54950: NOT
54951: IFFALSE 54955
// continue ;
54953: GO 54933
// if GetResourceTypeXY ( _x , _y ) then
54955: LD_VAR 0 5
54959: PPUSH
54960: LD_VAR 0 6
54964: PPUSH
54965: CALL_OW 283
54969: IFFALSE 55009
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
54971: LD_ADDR_VAR 0 4
54975: PUSH
54976: LD_VAR 0 4
54980: PPUSH
54981: LD_VAR 0 4
54985: PUSH
54986: LD_INT 1
54988: PLUS
54989: PPUSH
54990: LD_VAR 0 5
54994: PUSH
54995: LD_VAR 0 6
54999: PUSH
55000: EMPTY
55001: LIST
55002: LIST
55003: PPUSH
55004: CALL_OW 1
55008: ST_TO_ADDR
// end ;
55009: GO 54933
55011: POP
55012: POP
55013: GO 54913
55015: POP
55016: POP
// end ;
55017: LD_VAR 0 4
55021: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
55022: LD_INT 0
55024: PPUSH
55025: PPUSH
55026: PPUSH
55027: PPUSH
55028: PPUSH
55029: PPUSH
55030: PPUSH
55031: PPUSH
// if not units then
55032: LD_VAR 0 1
55036: NOT
55037: IFFALSE 55041
// exit ;
55039: GO 55565
// result := UnitFilter ( units , [ f_ok ] ) ;
55041: LD_ADDR_VAR 0 3
55045: PUSH
55046: LD_VAR 0 1
55050: PPUSH
55051: LD_INT 50
55053: PUSH
55054: EMPTY
55055: LIST
55056: PPUSH
55057: CALL_OW 72
55061: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
55062: LD_ADDR_VAR 0 8
55066: PUSH
55067: LD_VAR 0 1
55071: PUSH
55072: LD_INT 1
55074: ARRAY
55075: PPUSH
55076: CALL_OW 255
55080: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
55081: LD_ADDR_VAR 0 10
55085: PUSH
55086: LD_INT 29
55088: PUSH
55089: LD_INT 91
55091: PUSH
55092: LD_INT 49
55094: PUSH
55095: EMPTY
55096: LIST
55097: LIST
55098: LIST
55099: ST_TO_ADDR
// if not result then
55100: LD_VAR 0 3
55104: NOT
55105: IFFALSE 55109
// exit ;
55107: GO 55565
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
55109: LD_ADDR_VAR 0 5
55113: PUSH
55114: LD_INT 81
55116: PUSH
55117: LD_VAR 0 8
55121: PUSH
55122: EMPTY
55123: LIST
55124: LIST
55125: PPUSH
55126: CALL_OW 69
55130: ST_TO_ADDR
// for i in result do
55131: LD_ADDR_VAR 0 4
55135: PUSH
55136: LD_VAR 0 3
55140: PUSH
55141: FOR_IN
55142: IFFALSE 55563
// begin tag := GetTag ( i ) + 1 ;
55144: LD_ADDR_VAR 0 9
55148: PUSH
55149: LD_VAR 0 4
55153: PPUSH
55154: CALL_OW 110
55158: PUSH
55159: LD_INT 1
55161: PLUS
55162: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
55163: LD_ADDR_VAR 0 7
55167: PUSH
55168: LD_VAR 0 4
55172: PPUSH
55173: CALL_OW 250
55177: PPUSH
55178: LD_VAR 0 4
55182: PPUSH
55183: CALL_OW 251
55187: PPUSH
55188: LD_INT 6
55190: PPUSH
55191: CALL 54764 0 3
55195: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
55196: LD_VAR 0 4
55200: PPUSH
55201: CALL_OW 247
55205: PUSH
55206: LD_INT 2
55208: EQUAL
55209: PUSH
55210: LD_VAR 0 7
55214: AND
55215: PUSH
55216: LD_VAR 0 4
55220: PPUSH
55221: CALL_OW 264
55225: PUSH
55226: LD_VAR 0 10
55230: IN
55231: NOT
55232: AND
55233: IFFALSE 55272
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
55235: LD_VAR 0 4
55239: PPUSH
55240: LD_VAR 0 7
55244: PUSH
55245: LD_INT 1
55247: ARRAY
55248: PUSH
55249: LD_INT 1
55251: ARRAY
55252: PPUSH
55253: LD_VAR 0 7
55257: PUSH
55258: LD_INT 1
55260: ARRAY
55261: PUSH
55262: LD_INT 2
55264: ARRAY
55265: PPUSH
55266: CALL_OW 116
55270: GO 55561
// if path > tag then
55272: LD_VAR 0 2
55276: PUSH
55277: LD_VAR 0 9
55281: GREATER
55282: IFFALSE 55490
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
55284: LD_ADDR_VAR 0 6
55288: PUSH
55289: LD_VAR 0 5
55293: PPUSH
55294: LD_INT 91
55296: PUSH
55297: LD_VAR 0 4
55301: PUSH
55302: LD_INT 8
55304: PUSH
55305: EMPTY
55306: LIST
55307: LIST
55308: LIST
55309: PPUSH
55310: CALL_OW 72
55314: ST_TO_ADDR
// if nearEnemy then
55315: LD_VAR 0 6
55319: IFFALSE 55388
// begin if GetWeapon ( i ) = ru_time_lapser then
55321: LD_VAR 0 4
55325: PPUSH
55326: CALL_OW 264
55330: PUSH
55331: LD_INT 49
55333: EQUAL
55334: IFFALSE 55362
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
55336: LD_VAR 0 4
55340: PPUSH
55341: LD_VAR 0 6
55345: PPUSH
55346: LD_VAR 0 4
55350: PPUSH
55351: CALL_OW 74
55355: PPUSH
55356: CALL_OW 112
55360: GO 55386
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
55362: LD_VAR 0 4
55366: PPUSH
55367: LD_VAR 0 6
55371: PPUSH
55372: LD_VAR 0 4
55376: PPUSH
55377: CALL_OW 74
55381: PPUSH
55382: CALL_OW 115
// end else
55386: GO 55488
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
55388: LD_VAR 0 4
55392: PPUSH
55393: LD_VAR 0 2
55397: PUSH
55398: LD_VAR 0 9
55402: ARRAY
55403: PUSH
55404: LD_INT 1
55406: ARRAY
55407: PPUSH
55408: LD_VAR 0 2
55412: PUSH
55413: LD_VAR 0 9
55417: ARRAY
55418: PUSH
55419: LD_INT 2
55421: ARRAY
55422: PPUSH
55423: CALL_OW 297
55427: PUSH
55428: LD_INT 6
55430: GREATER
55431: IFFALSE 55474
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
55433: LD_VAR 0 4
55437: PPUSH
55438: LD_VAR 0 2
55442: PUSH
55443: LD_VAR 0 9
55447: ARRAY
55448: PUSH
55449: LD_INT 1
55451: ARRAY
55452: PPUSH
55453: LD_VAR 0 2
55457: PUSH
55458: LD_VAR 0 9
55462: ARRAY
55463: PUSH
55464: LD_INT 2
55466: ARRAY
55467: PPUSH
55468: CALL_OW 114
55472: GO 55488
// SetTag ( i , tag ) ;
55474: LD_VAR 0 4
55478: PPUSH
55479: LD_VAR 0 9
55483: PPUSH
55484: CALL_OW 109
// end else
55488: GO 55561
// if enemy then
55490: LD_VAR 0 5
55494: IFFALSE 55561
// begin if GetWeapon ( i ) = ru_time_lapser then
55496: LD_VAR 0 4
55500: PPUSH
55501: CALL_OW 264
55505: PUSH
55506: LD_INT 49
55508: EQUAL
55509: IFFALSE 55537
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
55511: LD_VAR 0 4
55515: PPUSH
55516: LD_VAR 0 5
55520: PPUSH
55521: LD_VAR 0 4
55525: PPUSH
55526: CALL_OW 74
55530: PPUSH
55531: CALL_OW 112
55535: GO 55561
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
55537: LD_VAR 0 4
55541: PPUSH
55542: LD_VAR 0 5
55546: PPUSH
55547: LD_VAR 0 4
55551: PPUSH
55552: CALL_OW 74
55556: PPUSH
55557: CALL_OW 115
// end ; end ;
55561: GO 55141
55563: POP
55564: POP
// end ;
55565: LD_VAR 0 3
55569: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
55570: LD_INT 0
55572: PPUSH
55573: PPUSH
55574: PPUSH
// if not unit or IsInUnit ( unit ) then
55575: LD_VAR 0 1
55579: NOT
55580: PUSH
55581: LD_VAR 0 1
55585: PPUSH
55586: CALL_OW 310
55590: OR
55591: IFFALSE 55595
// exit ;
55593: GO 55686
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
55595: LD_ADDR_VAR 0 4
55599: PUSH
55600: LD_VAR 0 1
55604: PPUSH
55605: CALL_OW 250
55609: PPUSH
55610: LD_VAR 0 2
55614: PPUSH
55615: LD_INT 1
55617: PPUSH
55618: CALL_OW 272
55622: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
55623: LD_ADDR_VAR 0 5
55627: PUSH
55628: LD_VAR 0 1
55632: PPUSH
55633: CALL_OW 251
55637: PPUSH
55638: LD_VAR 0 2
55642: PPUSH
55643: LD_INT 1
55645: PPUSH
55646: CALL_OW 273
55650: ST_TO_ADDR
// if ValidHex ( x , y ) then
55651: LD_VAR 0 4
55655: PPUSH
55656: LD_VAR 0 5
55660: PPUSH
55661: CALL_OW 488
55665: IFFALSE 55686
// ComTurnXY ( unit , x , y ) ;
55667: LD_VAR 0 1
55671: PPUSH
55672: LD_VAR 0 4
55676: PPUSH
55677: LD_VAR 0 5
55681: PPUSH
55682: CALL_OW 118
// end ;
55686: LD_VAR 0 3
55690: RET
// export function SeeUnits ( side , units ) ; var i ; begin
55691: LD_INT 0
55693: PPUSH
55694: PPUSH
// result := false ;
55695: LD_ADDR_VAR 0 3
55699: PUSH
55700: LD_INT 0
55702: ST_TO_ADDR
// if not units then
55703: LD_VAR 0 2
55707: NOT
55708: IFFALSE 55712
// exit ;
55710: GO 55757
// for i in units do
55712: LD_ADDR_VAR 0 4
55716: PUSH
55717: LD_VAR 0 2
55721: PUSH
55722: FOR_IN
55723: IFFALSE 55755
// if See ( side , i ) then
55725: LD_VAR 0 1
55729: PPUSH
55730: LD_VAR 0 4
55734: PPUSH
55735: CALL_OW 292
55739: IFFALSE 55753
// begin result := true ;
55741: LD_ADDR_VAR 0 3
55745: PUSH
55746: LD_INT 1
55748: ST_TO_ADDR
// exit ;
55749: POP
55750: POP
55751: GO 55757
// end ;
55753: GO 55722
55755: POP
55756: POP
// end ;
55757: LD_VAR 0 3
55761: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
55762: LD_INT 0
55764: PPUSH
55765: PPUSH
55766: PPUSH
55767: PPUSH
// if not unit or not points then
55768: LD_VAR 0 1
55772: NOT
55773: PUSH
55774: LD_VAR 0 2
55778: NOT
55779: OR
55780: IFFALSE 55784
// exit ;
55782: GO 55874
// dist := 99999 ;
55784: LD_ADDR_VAR 0 5
55788: PUSH
55789: LD_INT 99999
55791: ST_TO_ADDR
// for i in points do
55792: LD_ADDR_VAR 0 4
55796: PUSH
55797: LD_VAR 0 2
55801: PUSH
55802: FOR_IN
55803: IFFALSE 55872
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
55805: LD_ADDR_VAR 0 6
55809: PUSH
55810: LD_VAR 0 1
55814: PPUSH
55815: LD_VAR 0 4
55819: PUSH
55820: LD_INT 1
55822: ARRAY
55823: PPUSH
55824: LD_VAR 0 4
55828: PUSH
55829: LD_INT 2
55831: ARRAY
55832: PPUSH
55833: CALL_OW 297
55837: ST_TO_ADDR
// if tmpDist < dist then
55838: LD_VAR 0 6
55842: PUSH
55843: LD_VAR 0 5
55847: LESS
55848: IFFALSE 55870
// begin result := i ;
55850: LD_ADDR_VAR 0 3
55854: PUSH
55855: LD_VAR 0 4
55859: ST_TO_ADDR
// dist := tmpDist ;
55860: LD_ADDR_VAR 0 5
55864: PUSH
55865: LD_VAR 0 6
55869: ST_TO_ADDR
// end ; end ;
55870: GO 55802
55872: POP
55873: POP
// end ;
55874: LD_VAR 0 3
55878: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
55879: LD_INT 0
55881: PPUSH
// uc_side := side ;
55882: LD_ADDR_OWVAR 20
55886: PUSH
55887: LD_VAR 0 1
55891: ST_TO_ADDR
// uc_nation := 3 ;
55892: LD_ADDR_OWVAR 21
55896: PUSH
55897: LD_INT 3
55899: ST_TO_ADDR
// vc_chassis := 25 ;
55900: LD_ADDR_OWVAR 37
55904: PUSH
55905: LD_INT 25
55907: ST_TO_ADDR
// vc_engine := engine_siberite ;
55908: LD_ADDR_OWVAR 39
55912: PUSH
55913: LD_INT 3
55915: ST_TO_ADDR
// vc_control := control_computer ;
55916: LD_ADDR_OWVAR 38
55920: PUSH
55921: LD_INT 3
55923: ST_TO_ADDR
// vc_weapon := 59 ;
55924: LD_ADDR_OWVAR 40
55928: PUSH
55929: LD_INT 59
55931: ST_TO_ADDR
// result := CreateVehicle ;
55932: LD_ADDR_VAR 0 5
55936: PUSH
55937: CALL_OW 45
55941: ST_TO_ADDR
// SetDir ( result , d ) ;
55942: LD_VAR 0 5
55946: PPUSH
55947: LD_VAR 0 4
55951: PPUSH
55952: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
55956: LD_VAR 0 5
55960: PPUSH
55961: LD_VAR 0 2
55965: PPUSH
55966: LD_VAR 0 3
55970: PPUSH
55971: LD_INT 0
55973: PPUSH
55974: CALL_OW 48
// end ;
55978: LD_VAR 0 5
55982: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
55983: LD_INT 0
55985: PPUSH
55986: PPUSH
55987: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
55988: LD_ADDR_VAR 0 2
55992: PUSH
55993: LD_INT 0
55995: PUSH
55996: LD_INT 0
55998: PUSH
55999: LD_INT 0
56001: PUSH
56002: LD_INT 0
56004: PUSH
56005: EMPTY
56006: LIST
56007: LIST
56008: LIST
56009: LIST
56010: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
56011: LD_VAR 0 1
56015: NOT
56016: PUSH
56017: LD_VAR 0 1
56021: PPUSH
56022: CALL_OW 264
56026: PUSH
56027: LD_INT 12
56029: PUSH
56030: LD_INT 51
56032: PUSH
56033: LD_INT 32
56035: PUSH
56036: LD_INT 89
56038: PUSH
56039: EMPTY
56040: LIST
56041: LIST
56042: LIST
56043: LIST
56044: IN
56045: NOT
56046: OR
56047: IFFALSE 56051
// exit ;
56049: GO 56149
// for i := 1 to 3 do
56051: LD_ADDR_VAR 0 3
56055: PUSH
56056: DOUBLE
56057: LD_INT 1
56059: DEC
56060: ST_TO_ADDR
56061: LD_INT 3
56063: PUSH
56064: FOR_TO
56065: IFFALSE 56147
// begin tmp := GetCargo ( cargo , i ) ;
56067: LD_ADDR_VAR 0 4
56071: PUSH
56072: LD_VAR 0 1
56076: PPUSH
56077: LD_VAR 0 3
56081: PPUSH
56082: CALL_OW 289
56086: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
56087: LD_ADDR_VAR 0 2
56091: PUSH
56092: LD_VAR 0 2
56096: PPUSH
56097: LD_VAR 0 3
56101: PPUSH
56102: LD_VAR 0 4
56106: PPUSH
56107: CALL_OW 1
56111: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
56112: LD_ADDR_VAR 0 2
56116: PUSH
56117: LD_VAR 0 2
56121: PPUSH
56122: LD_INT 4
56124: PPUSH
56125: LD_VAR 0 2
56129: PUSH
56130: LD_INT 4
56132: ARRAY
56133: PUSH
56134: LD_VAR 0 4
56138: PLUS
56139: PPUSH
56140: CALL_OW 1
56144: ST_TO_ADDR
// end ;
56145: GO 56064
56147: POP
56148: POP
// end ;
56149: LD_VAR 0 2
56153: RET
// export function Length ( array ) ; begin
56154: LD_INT 0
56156: PPUSH
// result := array + 0 ;
56157: LD_ADDR_VAR 0 2
56161: PUSH
56162: LD_VAR 0 1
56166: PUSH
56167: LD_INT 0
56169: PLUS
56170: ST_TO_ADDR
// end ;
56171: LD_VAR 0 2
56175: RET
// export function PrepareArray ( array ) ; begin
56176: LD_INT 0
56178: PPUSH
// result := array diff 0 ;
56179: LD_ADDR_VAR 0 2
56183: PUSH
56184: LD_VAR 0 1
56188: PUSH
56189: LD_INT 0
56191: DIFF
56192: ST_TO_ADDR
// if not result [ 1 ] then
56193: LD_VAR 0 2
56197: PUSH
56198: LD_INT 1
56200: ARRAY
56201: NOT
56202: IFFALSE 56222
// result := Delete ( result , 1 ) ;
56204: LD_ADDR_VAR 0 2
56208: PUSH
56209: LD_VAR 0 2
56213: PPUSH
56214: LD_INT 1
56216: PPUSH
56217: CALL_OW 3
56221: ST_TO_ADDR
// end ;
56222: LD_VAR 0 2
56226: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
56227: LD_INT 0
56229: PPUSH
56230: PPUSH
56231: PPUSH
56232: PPUSH
// sibRocketRange := 25 ;
56233: LD_ADDR_VAR 0 6
56237: PUSH
56238: LD_INT 25
56240: ST_TO_ADDR
// result := false ;
56241: LD_ADDR_VAR 0 4
56245: PUSH
56246: LD_INT 0
56248: ST_TO_ADDR
// for i := 0 to 5 do
56249: LD_ADDR_VAR 0 5
56253: PUSH
56254: DOUBLE
56255: LD_INT 0
56257: DEC
56258: ST_TO_ADDR
56259: LD_INT 5
56261: PUSH
56262: FOR_TO
56263: IFFALSE 56330
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
56265: LD_VAR 0 1
56269: PPUSH
56270: LD_VAR 0 5
56274: PPUSH
56275: LD_VAR 0 6
56279: PPUSH
56280: CALL_OW 272
56284: PPUSH
56285: LD_VAR 0 2
56289: PPUSH
56290: LD_VAR 0 5
56294: PPUSH
56295: LD_VAR 0 6
56299: PPUSH
56300: CALL_OW 273
56304: PPUSH
56305: LD_VAR 0 3
56309: PPUSH
56310: CALL_OW 309
56314: IFFALSE 56328
// begin result := true ;
56316: LD_ADDR_VAR 0 4
56320: PUSH
56321: LD_INT 1
56323: ST_TO_ADDR
// exit ;
56324: POP
56325: POP
56326: GO 56332
// end ;
56328: GO 56262
56330: POP
56331: POP
// end ;
56332: LD_VAR 0 4
56336: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
56337: LD_INT 0
56339: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
56340: LD_VAR 0 1
56344: PPUSH
56345: LD_VAR 0 2
56349: PPUSH
56350: LD_INT 0
56352: PPUSH
56353: LD_INT 0
56355: PPUSH
56356: LD_INT 1
56358: PPUSH
56359: LD_INT 0
56361: PPUSH
56362: CALL_OW 587
// end ; end_of_file
56366: LD_VAR 0 3
56370: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
56371: LD_INT 0
56373: PPUSH
56374: PPUSH
// skirmish := false ;
56375: LD_ADDR_EXP 59
56379: PUSH
56380: LD_INT 0
56382: ST_TO_ADDR
// debug_mc := false ;
56383: LD_ADDR_EXP 60
56387: PUSH
56388: LD_INT 0
56390: ST_TO_ADDR
// mc_bases := [ ] ;
56391: LD_ADDR_EXP 61
56395: PUSH
56396: EMPTY
56397: ST_TO_ADDR
// mc_sides := [ ] ;
56398: LD_ADDR_EXP 87
56402: PUSH
56403: EMPTY
56404: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
56405: LD_ADDR_EXP 62
56409: PUSH
56410: EMPTY
56411: ST_TO_ADDR
// mc_building_repairs := [ ] ;
56412: LD_ADDR_EXP 63
56416: PUSH
56417: EMPTY
56418: ST_TO_ADDR
// mc_need_heal := [ ] ;
56419: LD_ADDR_EXP 64
56423: PUSH
56424: EMPTY
56425: ST_TO_ADDR
// mc_healers := [ ] ;
56426: LD_ADDR_EXP 65
56430: PUSH
56431: EMPTY
56432: ST_TO_ADDR
// mc_build_list := [ ] ;
56433: LD_ADDR_EXP 66
56437: PUSH
56438: EMPTY
56439: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
56440: LD_ADDR_EXP 93
56444: PUSH
56445: EMPTY
56446: ST_TO_ADDR
// mc_builders := [ ] ;
56447: LD_ADDR_EXP 67
56451: PUSH
56452: EMPTY
56453: ST_TO_ADDR
// mc_construct_list := [ ] ;
56454: LD_ADDR_EXP 68
56458: PUSH
56459: EMPTY
56460: ST_TO_ADDR
// mc_turret_list := [ ] ;
56461: LD_ADDR_EXP 69
56465: PUSH
56466: EMPTY
56467: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
56468: LD_ADDR_EXP 70
56472: PUSH
56473: EMPTY
56474: ST_TO_ADDR
// mc_miners := [ ] ;
56475: LD_ADDR_EXP 75
56479: PUSH
56480: EMPTY
56481: ST_TO_ADDR
// mc_mines := [ ] ;
56482: LD_ADDR_EXP 74
56486: PUSH
56487: EMPTY
56488: ST_TO_ADDR
// mc_minefields := [ ] ;
56489: LD_ADDR_EXP 76
56493: PUSH
56494: EMPTY
56495: ST_TO_ADDR
// mc_crates := [ ] ;
56496: LD_ADDR_EXP 77
56500: PUSH
56501: EMPTY
56502: ST_TO_ADDR
// mc_crates_collector := [ ] ;
56503: LD_ADDR_EXP 78
56507: PUSH
56508: EMPTY
56509: ST_TO_ADDR
// mc_crates_area := [ ] ;
56510: LD_ADDR_EXP 79
56514: PUSH
56515: EMPTY
56516: ST_TO_ADDR
// mc_vehicles := [ ] ;
56517: LD_ADDR_EXP 80
56521: PUSH
56522: EMPTY
56523: ST_TO_ADDR
// mc_attack := [ ] ;
56524: LD_ADDR_EXP 81
56528: PUSH
56529: EMPTY
56530: ST_TO_ADDR
// mc_produce := [ ] ;
56531: LD_ADDR_EXP 82
56535: PUSH
56536: EMPTY
56537: ST_TO_ADDR
// mc_defender := [ ] ;
56538: LD_ADDR_EXP 83
56542: PUSH
56543: EMPTY
56544: ST_TO_ADDR
// mc_parking := [ ] ;
56545: LD_ADDR_EXP 85
56549: PUSH
56550: EMPTY
56551: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
56552: LD_ADDR_EXP 71
56556: PUSH
56557: EMPTY
56558: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
56559: LD_ADDR_EXP 73
56563: PUSH
56564: EMPTY
56565: ST_TO_ADDR
// mc_scan := [ ] ;
56566: LD_ADDR_EXP 84
56570: PUSH
56571: EMPTY
56572: ST_TO_ADDR
// mc_scan_area := [ ] ;
56573: LD_ADDR_EXP 86
56577: PUSH
56578: EMPTY
56579: ST_TO_ADDR
// mc_tech := [ ] ;
56580: LD_ADDR_EXP 88
56584: PUSH
56585: EMPTY
56586: ST_TO_ADDR
// mc_class := [ ] ;
56587: LD_ADDR_EXP 102
56591: PUSH
56592: EMPTY
56593: ST_TO_ADDR
// mc_class_case_use := [ ] ;
56594: LD_ADDR_EXP 103
56598: PUSH
56599: EMPTY
56600: ST_TO_ADDR
// mc_is_defending := [ ] ;
56601: LD_ADDR_EXP 104
56605: PUSH
56606: EMPTY
56607: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
56608: LD_ADDR_EXP 95
56612: PUSH
56613: EMPTY
56614: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
56615: LD_ADDR_EXP 105
56619: PUSH
56620: LD_INT 0
56622: ST_TO_ADDR
// end ;
56623: LD_VAR 0 1
56627: RET
// export function MC_Kill ( base ) ; begin
56628: LD_INT 0
56630: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
56631: LD_ADDR_EXP 61
56635: PUSH
56636: LD_EXP 61
56640: PPUSH
56641: LD_VAR 0 1
56645: PPUSH
56646: EMPTY
56647: PPUSH
56648: CALL_OW 1
56652: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56653: LD_ADDR_EXP 62
56657: PUSH
56658: LD_EXP 62
56662: PPUSH
56663: LD_VAR 0 1
56667: PPUSH
56668: EMPTY
56669: PPUSH
56670: CALL_OW 1
56674: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56675: LD_ADDR_EXP 63
56679: PUSH
56680: LD_EXP 63
56684: PPUSH
56685: LD_VAR 0 1
56689: PPUSH
56690: EMPTY
56691: PPUSH
56692: CALL_OW 1
56696: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56697: LD_ADDR_EXP 64
56701: PUSH
56702: LD_EXP 64
56706: PPUSH
56707: LD_VAR 0 1
56711: PPUSH
56712: EMPTY
56713: PPUSH
56714: CALL_OW 1
56718: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56719: LD_ADDR_EXP 65
56723: PUSH
56724: LD_EXP 65
56728: PPUSH
56729: LD_VAR 0 1
56733: PPUSH
56734: EMPTY
56735: PPUSH
56736: CALL_OW 1
56740: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56741: LD_ADDR_EXP 66
56745: PUSH
56746: LD_EXP 66
56750: PPUSH
56751: LD_VAR 0 1
56755: PPUSH
56756: EMPTY
56757: PPUSH
56758: CALL_OW 1
56762: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56763: LD_ADDR_EXP 67
56767: PUSH
56768: LD_EXP 67
56772: PPUSH
56773: LD_VAR 0 1
56777: PPUSH
56778: EMPTY
56779: PPUSH
56780: CALL_OW 1
56784: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56785: LD_ADDR_EXP 68
56789: PUSH
56790: LD_EXP 68
56794: PPUSH
56795: LD_VAR 0 1
56799: PPUSH
56800: EMPTY
56801: PPUSH
56802: CALL_OW 1
56806: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56807: LD_ADDR_EXP 69
56811: PUSH
56812: LD_EXP 69
56816: PPUSH
56817: LD_VAR 0 1
56821: PPUSH
56822: EMPTY
56823: PPUSH
56824: CALL_OW 1
56828: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56829: LD_ADDR_EXP 70
56833: PUSH
56834: LD_EXP 70
56838: PPUSH
56839: LD_VAR 0 1
56843: PPUSH
56844: EMPTY
56845: PPUSH
56846: CALL_OW 1
56850: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56851: LD_ADDR_EXP 71
56855: PUSH
56856: LD_EXP 71
56860: PPUSH
56861: LD_VAR 0 1
56865: PPUSH
56866: EMPTY
56867: PPUSH
56868: CALL_OW 1
56872: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56873: LD_ADDR_EXP 72
56877: PUSH
56878: LD_EXP 72
56882: PPUSH
56883: LD_VAR 0 1
56887: PPUSH
56888: LD_INT 0
56890: PPUSH
56891: CALL_OW 1
56895: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56896: LD_ADDR_EXP 73
56900: PUSH
56901: LD_EXP 73
56905: PPUSH
56906: LD_VAR 0 1
56910: PPUSH
56911: EMPTY
56912: PPUSH
56913: CALL_OW 1
56917: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56918: LD_ADDR_EXP 74
56922: PUSH
56923: LD_EXP 74
56927: PPUSH
56928: LD_VAR 0 1
56932: PPUSH
56933: EMPTY
56934: PPUSH
56935: CALL_OW 1
56939: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56940: LD_ADDR_EXP 75
56944: PUSH
56945: LD_EXP 75
56949: PPUSH
56950: LD_VAR 0 1
56954: PPUSH
56955: EMPTY
56956: PPUSH
56957: CALL_OW 1
56961: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56962: LD_ADDR_EXP 76
56966: PUSH
56967: LD_EXP 76
56971: PPUSH
56972: LD_VAR 0 1
56976: PPUSH
56977: EMPTY
56978: PPUSH
56979: CALL_OW 1
56983: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56984: LD_ADDR_EXP 77
56988: PUSH
56989: LD_EXP 77
56993: PPUSH
56994: LD_VAR 0 1
56998: PPUSH
56999: EMPTY
57000: PPUSH
57001: CALL_OW 1
57005: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57006: LD_ADDR_EXP 78
57010: PUSH
57011: LD_EXP 78
57015: PPUSH
57016: LD_VAR 0 1
57020: PPUSH
57021: EMPTY
57022: PPUSH
57023: CALL_OW 1
57027: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57028: LD_ADDR_EXP 79
57032: PUSH
57033: LD_EXP 79
57037: PPUSH
57038: LD_VAR 0 1
57042: PPUSH
57043: EMPTY
57044: PPUSH
57045: CALL_OW 1
57049: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57050: LD_ADDR_EXP 80
57054: PUSH
57055: LD_EXP 80
57059: PPUSH
57060: LD_VAR 0 1
57064: PPUSH
57065: EMPTY
57066: PPUSH
57067: CALL_OW 1
57071: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57072: LD_ADDR_EXP 81
57076: PUSH
57077: LD_EXP 81
57081: PPUSH
57082: LD_VAR 0 1
57086: PPUSH
57087: EMPTY
57088: PPUSH
57089: CALL_OW 1
57093: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57094: LD_ADDR_EXP 82
57098: PUSH
57099: LD_EXP 82
57103: PPUSH
57104: LD_VAR 0 1
57108: PPUSH
57109: EMPTY
57110: PPUSH
57111: CALL_OW 1
57115: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57116: LD_ADDR_EXP 83
57120: PUSH
57121: LD_EXP 83
57125: PPUSH
57126: LD_VAR 0 1
57130: PPUSH
57131: EMPTY
57132: PPUSH
57133: CALL_OW 1
57137: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57138: LD_ADDR_EXP 84
57142: PUSH
57143: LD_EXP 84
57147: PPUSH
57148: LD_VAR 0 1
57152: PPUSH
57153: EMPTY
57154: PPUSH
57155: CALL_OW 1
57159: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57160: LD_ADDR_EXP 85
57164: PUSH
57165: LD_EXP 85
57169: PPUSH
57170: LD_VAR 0 1
57174: PPUSH
57175: EMPTY
57176: PPUSH
57177: CALL_OW 1
57181: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57182: LD_ADDR_EXP 86
57186: PUSH
57187: LD_EXP 86
57191: PPUSH
57192: LD_VAR 0 1
57196: PPUSH
57197: EMPTY
57198: PPUSH
57199: CALL_OW 1
57203: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57204: LD_ADDR_EXP 88
57208: PUSH
57209: LD_EXP 88
57213: PPUSH
57214: LD_VAR 0 1
57218: PPUSH
57219: EMPTY
57220: PPUSH
57221: CALL_OW 1
57225: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57226: LD_ADDR_EXP 90
57230: PUSH
57231: LD_EXP 90
57235: PPUSH
57236: LD_VAR 0 1
57240: PPUSH
57241: EMPTY
57242: PPUSH
57243: CALL_OW 1
57247: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57248: LD_ADDR_EXP 91
57252: PUSH
57253: LD_EXP 91
57257: PPUSH
57258: LD_VAR 0 1
57262: PPUSH
57263: EMPTY
57264: PPUSH
57265: CALL_OW 1
57269: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57270: LD_ADDR_EXP 92
57274: PUSH
57275: LD_EXP 92
57279: PPUSH
57280: LD_VAR 0 1
57284: PPUSH
57285: EMPTY
57286: PPUSH
57287: CALL_OW 1
57291: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57292: LD_ADDR_EXP 93
57296: PUSH
57297: LD_EXP 93
57301: PPUSH
57302: LD_VAR 0 1
57306: PPUSH
57307: EMPTY
57308: PPUSH
57309: CALL_OW 1
57313: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57314: LD_ADDR_EXP 94
57318: PUSH
57319: LD_EXP 94
57323: PPUSH
57324: LD_VAR 0 1
57328: PPUSH
57329: EMPTY
57330: PPUSH
57331: CALL_OW 1
57335: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57336: LD_ADDR_EXP 95
57340: PUSH
57341: LD_EXP 95
57345: PPUSH
57346: LD_VAR 0 1
57350: PPUSH
57351: EMPTY
57352: PPUSH
57353: CALL_OW 1
57357: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57358: LD_ADDR_EXP 96
57362: PUSH
57363: LD_EXP 96
57367: PPUSH
57368: LD_VAR 0 1
57372: PPUSH
57373: EMPTY
57374: PPUSH
57375: CALL_OW 1
57379: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57380: LD_ADDR_EXP 97
57384: PUSH
57385: LD_EXP 97
57389: PPUSH
57390: LD_VAR 0 1
57394: PPUSH
57395: EMPTY
57396: PPUSH
57397: CALL_OW 1
57401: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57402: LD_ADDR_EXP 98
57406: PUSH
57407: LD_EXP 98
57411: PPUSH
57412: LD_VAR 0 1
57416: PPUSH
57417: EMPTY
57418: PPUSH
57419: CALL_OW 1
57423: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57424: LD_ADDR_EXP 99
57428: PUSH
57429: LD_EXP 99
57433: PPUSH
57434: LD_VAR 0 1
57438: PPUSH
57439: EMPTY
57440: PPUSH
57441: CALL_OW 1
57445: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57446: LD_ADDR_EXP 100
57450: PUSH
57451: LD_EXP 100
57455: PPUSH
57456: LD_VAR 0 1
57460: PPUSH
57461: EMPTY
57462: PPUSH
57463: CALL_OW 1
57467: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57468: LD_ADDR_EXP 101
57472: PUSH
57473: LD_EXP 101
57477: PPUSH
57478: LD_VAR 0 1
57482: PPUSH
57483: EMPTY
57484: PPUSH
57485: CALL_OW 1
57489: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57490: LD_ADDR_EXP 102
57494: PUSH
57495: LD_EXP 102
57499: PPUSH
57500: LD_VAR 0 1
57504: PPUSH
57505: EMPTY
57506: PPUSH
57507: CALL_OW 1
57511: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57512: LD_ADDR_EXP 103
57516: PUSH
57517: LD_EXP 103
57521: PPUSH
57522: LD_VAR 0 1
57526: PPUSH
57527: LD_INT 0
57529: PPUSH
57530: CALL_OW 1
57534: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
57535: LD_ADDR_EXP 104
57539: PUSH
57540: LD_EXP 104
57544: PPUSH
57545: LD_VAR 0 1
57549: PPUSH
57550: LD_INT 0
57552: PPUSH
57553: CALL_OW 1
57557: ST_TO_ADDR
// end ;
57558: LD_VAR 0 2
57562: RET
// export function MC_Add ( side , units ) ; var base ; begin
57563: LD_INT 0
57565: PPUSH
57566: PPUSH
// base := mc_bases + 1 ;
57567: LD_ADDR_VAR 0 4
57571: PUSH
57572: LD_EXP 61
57576: PUSH
57577: LD_INT 1
57579: PLUS
57580: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
57581: LD_ADDR_EXP 87
57585: PUSH
57586: LD_EXP 87
57590: PPUSH
57591: LD_VAR 0 4
57595: PPUSH
57596: LD_VAR 0 1
57600: PPUSH
57601: CALL_OW 1
57605: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
57606: LD_ADDR_EXP 61
57610: PUSH
57611: LD_EXP 61
57615: PPUSH
57616: LD_VAR 0 4
57620: PPUSH
57621: LD_VAR 0 2
57625: PPUSH
57626: CALL_OW 1
57630: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57631: LD_ADDR_EXP 62
57635: PUSH
57636: LD_EXP 62
57640: PPUSH
57641: LD_VAR 0 4
57645: PPUSH
57646: EMPTY
57647: PPUSH
57648: CALL_OW 1
57652: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57653: LD_ADDR_EXP 63
57657: PUSH
57658: LD_EXP 63
57662: PPUSH
57663: LD_VAR 0 4
57667: PPUSH
57668: EMPTY
57669: PPUSH
57670: CALL_OW 1
57674: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57675: LD_ADDR_EXP 64
57679: PUSH
57680: LD_EXP 64
57684: PPUSH
57685: LD_VAR 0 4
57689: PPUSH
57690: EMPTY
57691: PPUSH
57692: CALL_OW 1
57696: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57697: LD_ADDR_EXP 65
57701: PUSH
57702: LD_EXP 65
57706: PPUSH
57707: LD_VAR 0 4
57711: PPUSH
57712: EMPTY
57713: PPUSH
57714: CALL_OW 1
57718: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57719: LD_ADDR_EXP 66
57723: PUSH
57724: LD_EXP 66
57728: PPUSH
57729: LD_VAR 0 4
57733: PPUSH
57734: EMPTY
57735: PPUSH
57736: CALL_OW 1
57740: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57741: LD_ADDR_EXP 67
57745: PUSH
57746: LD_EXP 67
57750: PPUSH
57751: LD_VAR 0 4
57755: PPUSH
57756: EMPTY
57757: PPUSH
57758: CALL_OW 1
57762: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57763: LD_ADDR_EXP 68
57767: PUSH
57768: LD_EXP 68
57772: PPUSH
57773: LD_VAR 0 4
57777: PPUSH
57778: EMPTY
57779: PPUSH
57780: CALL_OW 1
57784: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57785: LD_ADDR_EXP 69
57789: PUSH
57790: LD_EXP 69
57794: PPUSH
57795: LD_VAR 0 4
57799: PPUSH
57800: EMPTY
57801: PPUSH
57802: CALL_OW 1
57806: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57807: LD_ADDR_EXP 70
57811: PUSH
57812: LD_EXP 70
57816: PPUSH
57817: LD_VAR 0 4
57821: PPUSH
57822: EMPTY
57823: PPUSH
57824: CALL_OW 1
57828: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57829: LD_ADDR_EXP 71
57833: PUSH
57834: LD_EXP 71
57838: PPUSH
57839: LD_VAR 0 4
57843: PPUSH
57844: EMPTY
57845: PPUSH
57846: CALL_OW 1
57850: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57851: LD_ADDR_EXP 72
57855: PUSH
57856: LD_EXP 72
57860: PPUSH
57861: LD_VAR 0 4
57865: PPUSH
57866: LD_INT 0
57868: PPUSH
57869: CALL_OW 1
57873: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57874: LD_ADDR_EXP 73
57878: PUSH
57879: LD_EXP 73
57883: PPUSH
57884: LD_VAR 0 4
57888: PPUSH
57889: EMPTY
57890: PPUSH
57891: CALL_OW 1
57895: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57896: LD_ADDR_EXP 74
57900: PUSH
57901: LD_EXP 74
57905: PPUSH
57906: LD_VAR 0 4
57910: PPUSH
57911: EMPTY
57912: PPUSH
57913: CALL_OW 1
57917: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57918: LD_ADDR_EXP 75
57922: PUSH
57923: LD_EXP 75
57927: PPUSH
57928: LD_VAR 0 4
57932: PPUSH
57933: EMPTY
57934: PPUSH
57935: CALL_OW 1
57939: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57940: LD_ADDR_EXP 76
57944: PUSH
57945: LD_EXP 76
57949: PPUSH
57950: LD_VAR 0 4
57954: PPUSH
57955: EMPTY
57956: PPUSH
57957: CALL_OW 1
57961: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57962: LD_ADDR_EXP 77
57966: PUSH
57967: LD_EXP 77
57971: PPUSH
57972: LD_VAR 0 4
57976: PPUSH
57977: EMPTY
57978: PPUSH
57979: CALL_OW 1
57983: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57984: LD_ADDR_EXP 78
57988: PUSH
57989: LD_EXP 78
57993: PPUSH
57994: LD_VAR 0 4
57998: PPUSH
57999: EMPTY
58000: PPUSH
58001: CALL_OW 1
58005: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58006: LD_ADDR_EXP 79
58010: PUSH
58011: LD_EXP 79
58015: PPUSH
58016: LD_VAR 0 4
58020: PPUSH
58021: EMPTY
58022: PPUSH
58023: CALL_OW 1
58027: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58028: LD_ADDR_EXP 80
58032: PUSH
58033: LD_EXP 80
58037: PPUSH
58038: LD_VAR 0 4
58042: PPUSH
58043: EMPTY
58044: PPUSH
58045: CALL_OW 1
58049: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58050: LD_ADDR_EXP 81
58054: PUSH
58055: LD_EXP 81
58059: PPUSH
58060: LD_VAR 0 4
58064: PPUSH
58065: EMPTY
58066: PPUSH
58067: CALL_OW 1
58071: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58072: LD_ADDR_EXP 82
58076: PUSH
58077: LD_EXP 82
58081: PPUSH
58082: LD_VAR 0 4
58086: PPUSH
58087: EMPTY
58088: PPUSH
58089: CALL_OW 1
58093: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58094: LD_ADDR_EXP 83
58098: PUSH
58099: LD_EXP 83
58103: PPUSH
58104: LD_VAR 0 4
58108: PPUSH
58109: EMPTY
58110: PPUSH
58111: CALL_OW 1
58115: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58116: LD_ADDR_EXP 84
58120: PUSH
58121: LD_EXP 84
58125: PPUSH
58126: LD_VAR 0 4
58130: PPUSH
58131: EMPTY
58132: PPUSH
58133: CALL_OW 1
58137: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58138: LD_ADDR_EXP 85
58142: PUSH
58143: LD_EXP 85
58147: PPUSH
58148: LD_VAR 0 4
58152: PPUSH
58153: EMPTY
58154: PPUSH
58155: CALL_OW 1
58159: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58160: LD_ADDR_EXP 86
58164: PUSH
58165: LD_EXP 86
58169: PPUSH
58170: LD_VAR 0 4
58174: PPUSH
58175: EMPTY
58176: PPUSH
58177: CALL_OW 1
58181: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58182: LD_ADDR_EXP 88
58186: PUSH
58187: LD_EXP 88
58191: PPUSH
58192: LD_VAR 0 4
58196: PPUSH
58197: EMPTY
58198: PPUSH
58199: CALL_OW 1
58203: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58204: LD_ADDR_EXP 90
58208: PUSH
58209: LD_EXP 90
58213: PPUSH
58214: LD_VAR 0 4
58218: PPUSH
58219: EMPTY
58220: PPUSH
58221: CALL_OW 1
58225: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58226: LD_ADDR_EXP 91
58230: PUSH
58231: LD_EXP 91
58235: PPUSH
58236: LD_VAR 0 4
58240: PPUSH
58241: EMPTY
58242: PPUSH
58243: CALL_OW 1
58247: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58248: LD_ADDR_EXP 92
58252: PUSH
58253: LD_EXP 92
58257: PPUSH
58258: LD_VAR 0 4
58262: PPUSH
58263: EMPTY
58264: PPUSH
58265: CALL_OW 1
58269: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58270: LD_ADDR_EXP 93
58274: PUSH
58275: LD_EXP 93
58279: PPUSH
58280: LD_VAR 0 4
58284: PPUSH
58285: EMPTY
58286: PPUSH
58287: CALL_OW 1
58291: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58292: LD_ADDR_EXP 94
58296: PUSH
58297: LD_EXP 94
58301: PPUSH
58302: LD_VAR 0 4
58306: PPUSH
58307: EMPTY
58308: PPUSH
58309: CALL_OW 1
58313: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58314: LD_ADDR_EXP 95
58318: PUSH
58319: LD_EXP 95
58323: PPUSH
58324: LD_VAR 0 4
58328: PPUSH
58329: EMPTY
58330: PPUSH
58331: CALL_OW 1
58335: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58336: LD_ADDR_EXP 96
58340: PUSH
58341: LD_EXP 96
58345: PPUSH
58346: LD_VAR 0 4
58350: PPUSH
58351: EMPTY
58352: PPUSH
58353: CALL_OW 1
58357: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58358: LD_ADDR_EXP 97
58362: PUSH
58363: LD_EXP 97
58367: PPUSH
58368: LD_VAR 0 4
58372: PPUSH
58373: EMPTY
58374: PPUSH
58375: CALL_OW 1
58379: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58380: LD_ADDR_EXP 98
58384: PUSH
58385: LD_EXP 98
58389: PPUSH
58390: LD_VAR 0 4
58394: PPUSH
58395: EMPTY
58396: PPUSH
58397: CALL_OW 1
58401: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58402: LD_ADDR_EXP 99
58406: PUSH
58407: LD_EXP 99
58411: PPUSH
58412: LD_VAR 0 4
58416: PPUSH
58417: EMPTY
58418: PPUSH
58419: CALL_OW 1
58423: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58424: LD_ADDR_EXP 100
58428: PUSH
58429: LD_EXP 100
58433: PPUSH
58434: LD_VAR 0 4
58438: PPUSH
58439: EMPTY
58440: PPUSH
58441: CALL_OW 1
58445: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58446: LD_ADDR_EXP 101
58450: PUSH
58451: LD_EXP 101
58455: PPUSH
58456: LD_VAR 0 4
58460: PPUSH
58461: EMPTY
58462: PPUSH
58463: CALL_OW 1
58467: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58468: LD_ADDR_EXP 102
58472: PUSH
58473: LD_EXP 102
58477: PPUSH
58478: LD_VAR 0 4
58482: PPUSH
58483: EMPTY
58484: PPUSH
58485: CALL_OW 1
58489: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58490: LD_ADDR_EXP 103
58494: PUSH
58495: LD_EXP 103
58499: PPUSH
58500: LD_VAR 0 4
58504: PPUSH
58505: LD_INT 0
58507: PPUSH
58508: CALL_OW 1
58512: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
58513: LD_ADDR_EXP 104
58517: PUSH
58518: LD_EXP 104
58522: PPUSH
58523: LD_VAR 0 4
58527: PPUSH
58528: LD_INT 0
58530: PPUSH
58531: CALL_OW 1
58535: ST_TO_ADDR
// result := base ;
58536: LD_ADDR_VAR 0 3
58540: PUSH
58541: LD_VAR 0 4
58545: ST_TO_ADDR
// end ;
58546: LD_VAR 0 3
58550: RET
// export function MC_Start ( ) ; var i ; begin
58551: LD_INT 0
58553: PPUSH
58554: PPUSH
// for i = 1 to mc_bases do
58555: LD_ADDR_VAR 0 2
58559: PUSH
58560: DOUBLE
58561: LD_INT 1
58563: DEC
58564: ST_TO_ADDR
58565: LD_EXP 61
58569: PUSH
58570: FOR_TO
58571: IFFALSE 59671
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
58573: LD_ADDR_EXP 61
58577: PUSH
58578: LD_EXP 61
58582: PPUSH
58583: LD_VAR 0 2
58587: PPUSH
58588: LD_EXP 61
58592: PUSH
58593: LD_VAR 0 2
58597: ARRAY
58598: PUSH
58599: LD_INT 0
58601: DIFF
58602: PPUSH
58603: CALL_OW 1
58607: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
58608: LD_ADDR_EXP 62
58612: PUSH
58613: LD_EXP 62
58617: PPUSH
58618: LD_VAR 0 2
58622: PPUSH
58623: EMPTY
58624: PPUSH
58625: CALL_OW 1
58629: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
58630: LD_ADDR_EXP 63
58634: PUSH
58635: LD_EXP 63
58639: PPUSH
58640: LD_VAR 0 2
58644: PPUSH
58645: EMPTY
58646: PPUSH
58647: CALL_OW 1
58651: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
58652: LD_ADDR_EXP 64
58656: PUSH
58657: LD_EXP 64
58661: PPUSH
58662: LD_VAR 0 2
58666: PPUSH
58667: EMPTY
58668: PPUSH
58669: CALL_OW 1
58673: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
58674: LD_ADDR_EXP 65
58678: PUSH
58679: LD_EXP 65
58683: PPUSH
58684: LD_VAR 0 2
58688: PPUSH
58689: EMPTY
58690: PUSH
58691: EMPTY
58692: PUSH
58693: EMPTY
58694: LIST
58695: LIST
58696: PPUSH
58697: CALL_OW 1
58701: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
58702: LD_ADDR_EXP 66
58706: PUSH
58707: LD_EXP 66
58711: PPUSH
58712: LD_VAR 0 2
58716: PPUSH
58717: EMPTY
58718: PPUSH
58719: CALL_OW 1
58723: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
58724: LD_ADDR_EXP 93
58728: PUSH
58729: LD_EXP 93
58733: PPUSH
58734: LD_VAR 0 2
58738: PPUSH
58739: EMPTY
58740: PPUSH
58741: CALL_OW 1
58745: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
58746: LD_ADDR_EXP 67
58750: PUSH
58751: LD_EXP 67
58755: PPUSH
58756: LD_VAR 0 2
58760: PPUSH
58761: EMPTY
58762: PPUSH
58763: CALL_OW 1
58767: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
58768: LD_ADDR_EXP 68
58772: PUSH
58773: LD_EXP 68
58777: PPUSH
58778: LD_VAR 0 2
58782: PPUSH
58783: EMPTY
58784: PPUSH
58785: CALL_OW 1
58789: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
58790: LD_ADDR_EXP 69
58794: PUSH
58795: LD_EXP 69
58799: PPUSH
58800: LD_VAR 0 2
58804: PPUSH
58805: LD_EXP 61
58809: PUSH
58810: LD_VAR 0 2
58814: ARRAY
58815: PPUSH
58816: LD_INT 2
58818: PUSH
58819: LD_INT 30
58821: PUSH
58822: LD_INT 32
58824: PUSH
58825: EMPTY
58826: LIST
58827: LIST
58828: PUSH
58829: LD_INT 30
58831: PUSH
58832: LD_INT 33
58834: PUSH
58835: EMPTY
58836: LIST
58837: LIST
58838: PUSH
58839: EMPTY
58840: LIST
58841: LIST
58842: LIST
58843: PPUSH
58844: CALL_OW 72
58848: PPUSH
58849: CALL_OW 1
58853: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
58854: LD_ADDR_EXP 70
58858: PUSH
58859: LD_EXP 70
58863: PPUSH
58864: LD_VAR 0 2
58868: PPUSH
58869: LD_EXP 61
58873: PUSH
58874: LD_VAR 0 2
58878: ARRAY
58879: PPUSH
58880: LD_INT 2
58882: PUSH
58883: LD_INT 30
58885: PUSH
58886: LD_INT 32
58888: PUSH
58889: EMPTY
58890: LIST
58891: LIST
58892: PUSH
58893: LD_INT 30
58895: PUSH
58896: LD_INT 31
58898: PUSH
58899: EMPTY
58900: LIST
58901: LIST
58902: PUSH
58903: EMPTY
58904: LIST
58905: LIST
58906: LIST
58907: PUSH
58908: LD_INT 58
58910: PUSH
58911: EMPTY
58912: LIST
58913: PUSH
58914: EMPTY
58915: LIST
58916: LIST
58917: PPUSH
58918: CALL_OW 72
58922: PPUSH
58923: CALL_OW 1
58927: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
58928: LD_ADDR_EXP 71
58932: PUSH
58933: LD_EXP 71
58937: PPUSH
58938: LD_VAR 0 2
58942: PPUSH
58943: EMPTY
58944: PPUSH
58945: CALL_OW 1
58949: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
58950: LD_ADDR_EXP 75
58954: PUSH
58955: LD_EXP 75
58959: PPUSH
58960: LD_VAR 0 2
58964: PPUSH
58965: EMPTY
58966: PPUSH
58967: CALL_OW 1
58971: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
58972: LD_ADDR_EXP 74
58976: PUSH
58977: LD_EXP 74
58981: PPUSH
58982: LD_VAR 0 2
58986: PPUSH
58987: EMPTY
58988: PPUSH
58989: CALL_OW 1
58993: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
58994: LD_ADDR_EXP 76
58998: PUSH
58999: LD_EXP 76
59003: PPUSH
59004: LD_VAR 0 2
59008: PPUSH
59009: EMPTY
59010: PPUSH
59011: CALL_OW 1
59015: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
59016: LD_ADDR_EXP 77
59020: PUSH
59021: LD_EXP 77
59025: PPUSH
59026: LD_VAR 0 2
59030: PPUSH
59031: EMPTY
59032: PPUSH
59033: CALL_OW 1
59037: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
59038: LD_ADDR_EXP 78
59042: PUSH
59043: LD_EXP 78
59047: PPUSH
59048: LD_VAR 0 2
59052: PPUSH
59053: EMPTY
59054: PPUSH
59055: CALL_OW 1
59059: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
59060: LD_ADDR_EXP 79
59064: PUSH
59065: LD_EXP 79
59069: PPUSH
59070: LD_VAR 0 2
59074: PPUSH
59075: EMPTY
59076: PPUSH
59077: CALL_OW 1
59081: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
59082: LD_ADDR_EXP 80
59086: PUSH
59087: LD_EXP 80
59091: PPUSH
59092: LD_VAR 0 2
59096: PPUSH
59097: EMPTY
59098: PPUSH
59099: CALL_OW 1
59103: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
59104: LD_ADDR_EXP 81
59108: PUSH
59109: LD_EXP 81
59113: PPUSH
59114: LD_VAR 0 2
59118: PPUSH
59119: EMPTY
59120: PPUSH
59121: CALL_OW 1
59125: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
59126: LD_ADDR_EXP 82
59130: PUSH
59131: LD_EXP 82
59135: PPUSH
59136: LD_VAR 0 2
59140: PPUSH
59141: EMPTY
59142: PPUSH
59143: CALL_OW 1
59147: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
59148: LD_ADDR_EXP 83
59152: PUSH
59153: LD_EXP 83
59157: PPUSH
59158: LD_VAR 0 2
59162: PPUSH
59163: EMPTY
59164: PPUSH
59165: CALL_OW 1
59169: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
59170: LD_ADDR_EXP 72
59174: PUSH
59175: LD_EXP 72
59179: PPUSH
59180: LD_VAR 0 2
59184: PPUSH
59185: LD_INT 0
59187: PPUSH
59188: CALL_OW 1
59192: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
59193: LD_ADDR_EXP 85
59197: PUSH
59198: LD_EXP 85
59202: PPUSH
59203: LD_VAR 0 2
59207: PPUSH
59208: LD_INT 0
59210: PPUSH
59211: CALL_OW 1
59215: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59216: LD_ADDR_EXP 73
59220: PUSH
59221: LD_EXP 73
59225: PPUSH
59226: LD_VAR 0 2
59230: PPUSH
59231: EMPTY
59232: PPUSH
59233: CALL_OW 1
59237: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
59238: LD_ADDR_EXP 84
59242: PUSH
59243: LD_EXP 84
59247: PPUSH
59248: LD_VAR 0 2
59252: PPUSH
59253: LD_INT 0
59255: PPUSH
59256: CALL_OW 1
59260: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
59261: LD_ADDR_EXP 86
59265: PUSH
59266: LD_EXP 86
59270: PPUSH
59271: LD_VAR 0 2
59275: PPUSH
59276: EMPTY
59277: PPUSH
59278: CALL_OW 1
59282: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
59283: LD_ADDR_EXP 89
59287: PUSH
59288: LD_EXP 89
59292: PPUSH
59293: LD_VAR 0 2
59297: PPUSH
59298: LD_INT 0
59300: PPUSH
59301: CALL_OW 1
59305: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
59306: LD_ADDR_EXP 90
59310: PUSH
59311: LD_EXP 90
59315: PPUSH
59316: LD_VAR 0 2
59320: PPUSH
59321: EMPTY
59322: PPUSH
59323: CALL_OW 1
59327: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
59328: LD_ADDR_EXP 91
59332: PUSH
59333: LD_EXP 91
59337: PPUSH
59338: LD_VAR 0 2
59342: PPUSH
59343: EMPTY
59344: PPUSH
59345: CALL_OW 1
59349: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59350: LD_ADDR_EXP 92
59354: PUSH
59355: LD_EXP 92
59359: PPUSH
59360: LD_VAR 0 2
59364: PPUSH
59365: EMPTY
59366: PPUSH
59367: CALL_OW 1
59371: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
59372: LD_ADDR_EXP 94
59376: PUSH
59377: LD_EXP 94
59381: PPUSH
59382: LD_VAR 0 2
59386: PPUSH
59387: LD_EXP 61
59391: PUSH
59392: LD_VAR 0 2
59396: ARRAY
59397: PPUSH
59398: LD_INT 2
59400: PUSH
59401: LD_INT 30
59403: PUSH
59404: LD_INT 6
59406: PUSH
59407: EMPTY
59408: LIST
59409: LIST
59410: PUSH
59411: LD_INT 30
59413: PUSH
59414: LD_INT 7
59416: PUSH
59417: EMPTY
59418: LIST
59419: LIST
59420: PUSH
59421: LD_INT 30
59423: PUSH
59424: LD_INT 8
59426: PUSH
59427: EMPTY
59428: LIST
59429: LIST
59430: PUSH
59431: EMPTY
59432: LIST
59433: LIST
59434: LIST
59435: LIST
59436: PPUSH
59437: CALL_OW 72
59441: PPUSH
59442: CALL_OW 1
59446: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
59447: LD_ADDR_EXP 95
59451: PUSH
59452: LD_EXP 95
59456: PPUSH
59457: LD_VAR 0 2
59461: PPUSH
59462: EMPTY
59463: PPUSH
59464: CALL_OW 1
59468: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
59469: LD_ADDR_EXP 96
59473: PUSH
59474: LD_EXP 96
59478: PPUSH
59479: LD_VAR 0 2
59483: PPUSH
59484: EMPTY
59485: PPUSH
59486: CALL_OW 1
59490: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
59491: LD_ADDR_EXP 97
59495: PUSH
59496: LD_EXP 97
59500: PPUSH
59501: LD_VAR 0 2
59505: PPUSH
59506: EMPTY
59507: PPUSH
59508: CALL_OW 1
59512: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
59513: LD_ADDR_EXP 98
59517: PUSH
59518: LD_EXP 98
59522: PPUSH
59523: LD_VAR 0 2
59527: PPUSH
59528: EMPTY
59529: PPUSH
59530: CALL_OW 1
59534: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59535: LD_ADDR_EXP 99
59539: PUSH
59540: LD_EXP 99
59544: PPUSH
59545: LD_VAR 0 2
59549: PPUSH
59550: EMPTY
59551: PPUSH
59552: CALL_OW 1
59556: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
59557: LD_ADDR_EXP 100
59561: PUSH
59562: LD_EXP 100
59566: PPUSH
59567: LD_VAR 0 2
59571: PPUSH
59572: EMPTY
59573: PPUSH
59574: CALL_OW 1
59578: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
59579: LD_ADDR_EXP 101
59583: PUSH
59584: LD_EXP 101
59588: PPUSH
59589: LD_VAR 0 2
59593: PPUSH
59594: EMPTY
59595: PPUSH
59596: CALL_OW 1
59600: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
59601: LD_ADDR_EXP 102
59605: PUSH
59606: LD_EXP 102
59610: PPUSH
59611: LD_VAR 0 2
59615: PPUSH
59616: EMPTY
59617: PPUSH
59618: CALL_OW 1
59622: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
59623: LD_ADDR_EXP 103
59627: PUSH
59628: LD_EXP 103
59632: PPUSH
59633: LD_VAR 0 2
59637: PPUSH
59638: LD_INT 0
59640: PPUSH
59641: CALL_OW 1
59645: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
59646: LD_ADDR_EXP 104
59650: PUSH
59651: LD_EXP 104
59655: PPUSH
59656: LD_VAR 0 2
59660: PPUSH
59661: LD_INT 0
59663: PPUSH
59664: CALL_OW 1
59668: ST_TO_ADDR
// end ;
59669: GO 58570
59671: POP
59672: POP
// MC_InitSides ( ) ;
59673: CALL 59959 0 0
// MC_InitResearch ( ) ;
59677: CALL 59698 0 0
// CustomInitMacro ( ) ;
59681: CALL 219 0 0
// skirmish := true ;
59685: LD_ADDR_EXP 59
59689: PUSH
59690: LD_INT 1
59692: ST_TO_ADDR
// end ;
59693: LD_VAR 0 1
59697: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
59698: LD_INT 0
59700: PPUSH
59701: PPUSH
59702: PPUSH
59703: PPUSH
59704: PPUSH
59705: PPUSH
// if not mc_bases then
59706: LD_EXP 61
59710: NOT
59711: IFFALSE 59715
// exit ;
59713: GO 59954
// for i = 1 to 8 do
59715: LD_ADDR_VAR 0 2
59719: PUSH
59720: DOUBLE
59721: LD_INT 1
59723: DEC
59724: ST_TO_ADDR
59725: LD_INT 8
59727: PUSH
59728: FOR_TO
59729: IFFALSE 59755
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
59731: LD_ADDR_EXP 88
59735: PUSH
59736: LD_EXP 88
59740: PPUSH
59741: LD_VAR 0 2
59745: PPUSH
59746: EMPTY
59747: PPUSH
59748: CALL_OW 1
59752: ST_TO_ADDR
59753: GO 59728
59755: POP
59756: POP
// tmp := [ ] ;
59757: LD_ADDR_VAR 0 5
59761: PUSH
59762: EMPTY
59763: ST_TO_ADDR
// for i = 1 to mc_sides do
59764: LD_ADDR_VAR 0 2
59768: PUSH
59769: DOUBLE
59770: LD_INT 1
59772: DEC
59773: ST_TO_ADDR
59774: LD_EXP 87
59778: PUSH
59779: FOR_TO
59780: IFFALSE 59838
// if not mc_sides [ i ] in tmp then
59782: LD_EXP 87
59786: PUSH
59787: LD_VAR 0 2
59791: ARRAY
59792: PUSH
59793: LD_VAR 0 5
59797: IN
59798: NOT
59799: IFFALSE 59836
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
59801: LD_ADDR_VAR 0 5
59805: PUSH
59806: LD_VAR 0 5
59810: PPUSH
59811: LD_VAR 0 5
59815: PUSH
59816: LD_INT 1
59818: PLUS
59819: PPUSH
59820: LD_EXP 87
59824: PUSH
59825: LD_VAR 0 2
59829: ARRAY
59830: PPUSH
59831: CALL_OW 2
59835: ST_TO_ADDR
59836: GO 59779
59838: POP
59839: POP
// if not tmp then
59840: LD_VAR 0 5
59844: NOT
59845: IFFALSE 59849
// exit ;
59847: GO 59954
// for j in tmp do
59849: LD_ADDR_VAR 0 3
59853: PUSH
59854: LD_VAR 0 5
59858: PUSH
59859: FOR_IN
59860: IFFALSE 59952
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
59862: LD_ADDR_VAR 0 6
59866: PUSH
59867: LD_INT 22
59869: PUSH
59870: LD_VAR 0 3
59874: PUSH
59875: EMPTY
59876: LIST
59877: LIST
59878: PPUSH
59879: CALL_OW 69
59883: ST_TO_ADDR
// if not un then
59884: LD_VAR 0 6
59888: NOT
59889: IFFALSE 59893
// continue ;
59891: GO 59859
// nation := GetNation ( un [ 1 ] ) ;
59893: LD_ADDR_VAR 0 4
59897: PUSH
59898: LD_VAR 0 6
59902: PUSH
59903: LD_INT 1
59905: ARRAY
59906: PPUSH
59907: CALL_OW 248
59911: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
59912: LD_ADDR_EXP 88
59916: PUSH
59917: LD_EXP 88
59921: PPUSH
59922: LD_VAR 0 3
59926: PPUSH
59927: LD_VAR 0 3
59931: PPUSH
59932: LD_VAR 0 4
59936: PPUSH
59937: LD_INT 1
59939: PPUSH
59940: CALL 15013 0 3
59944: PPUSH
59945: CALL_OW 1
59949: ST_TO_ADDR
// end ;
59950: GO 59859
59952: POP
59953: POP
// end ;
59954: LD_VAR 0 1
59958: RET
// export function MC_InitSides ( ) ; var i ; begin
59959: LD_INT 0
59961: PPUSH
59962: PPUSH
// if not mc_bases then
59963: LD_EXP 61
59967: NOT
59968: IFFALSE 59972
// exit ;
59970: GO 60046
// for i = 1 to mc_bases do
59972: LD_ADDR_VAR 0 2
59976: PUSH
59977: DOUBLE
59978: LD_INT 1
59980: DEC
59981: ST_TO_ADDR
59982: LD_EXP 61
59986: PUSH
59987: FOR_TO
59988: IFFALSE 60044
// if mc_bases [ i ] then
59990: LD_EXP 61
59994: PUSH
59995: LD_VAR 0 2
59999: ARRAY
60000: IFFALSE 60042
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
60002: LD_ADDR_EXP 87
60006: PUSH
60007: LD_EXP 87
60011: PPUSH
60012: LD_VAR 0 2
60016: PPUSH
60017: LD_EXP 61
60021: PUSH
60022: LD_VAR 0 2
60026: ARRAY
60027: PUSH
60028: LD_INT 1
60030: ARRAY
60031: PPUSH
60032: CALL_OW 255
60036: PPUSH
60037: CALL_OW 1
60041: ST_TO_ADDR
60042: GO 59987
60044: POP
60045: POP
// end ;
60046: LD_VAR 0 1
60050: RET
// every 0 0$03 trigger skirmish do
60051: LD_EXP 59
60055: IFFALSE 60209
60057: GO 60059
60059: DISABLE
// begin enable ;
60060: ENABLE
// MC_CheckBuildings ( ) ;
60061: CALL 64707 0 0
// MC_CheckPeopleLife ( ) ;
60065: CALL 64868 0 0
// RaiseSailEvent ( 100 ) ;
60069: LD_INT 100
60071: PPUSH
60072: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
60076: LD_INT 103
60078: PPUSH
60079: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
60083: LD_INT 104
60085: PPUSH
60086: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
60090: LD_INT 105
60092: PPUSH
60093: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
60097: LD_INT 106
60099: PPUSH
60100: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
60104: LD_INT 107
60106: PPUSH
60107: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
60111: LD_INT 108
60113: PPUSH
60114: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
60118: LD_INT 109
60120: PPUSH
60121: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
60125: LD_INT 110
60127: PPUSH
60128: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
60132: LD_INT 111
60134: PPUSH
60135: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
60139: LD_INT 112
60141: PPUSH
60142: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
60146: LD_INT 113
60148: PPUSH
60149: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
60153: LD_INT 120
60155: PPUSH
60156: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
60160: LD_INT 121
60162: PPUSH
60163: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
60167: LD_INT 122
60169: PPUSH
60170: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
60174: LD_INT 123
60176: PPUSH
60177: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
60181: LD_INT 124
60183: PPUSH
60184: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
60188: LD_INT 125
60190: PPUSH
60191: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
60195: LD_INT 126
60197: PPUSH
60198: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
60202: LD_INT 200
60204: PPUSH
60205: CALL_OW 427
// end ;
60209: END
// on SailEvent ( event ) do begin if event < 100 then
60210: LD_VAR 0 1
60214: PUSH
60215: LD_INT 100
60217: LESS
60218: IFFALSE 60229
// CustomEvent ( event ) ;
60220: LD_VAR 0 1
60224: PPUSH
60225: CALL 13628 0 1
// if event = 100 then
60229: LD_VAR 0 1
60233: PUSH
60234: LD_INT 100
60236: EQUAL
60237: IFFALSE 60243
// MC_ClassManager ( ) ;
60239: CALL 60635 0 0
// if event = 101 then
60243: LD_VAR 0 1
60247: PUSH
60248: LD_INT 101
60250: EQUAL
60251: IFFALSE 60257
// MC_RepairBuildings ( ) ;
60253: CALL 65453 0 0
// if event = 102 then
60257: LD_VAR 0 1
60261: PUSH
60262: LD_INT 102
60264: EQUAL
60265: IFFALSE 60271
// MC_Heal ( ) ;
60267: CALL 66388 0 0
// if event = 103 then
60271: LD_VAR 0 1
60275: PUSH
60276: LD_INT 103
60278: EQUAL
60279: IFFALSE 60285
// MC_Build ( ) ;
60281: CALL 66810 0 0
// if event = 104 then
60285: LD_VAR 0 1
60289: PUSH
60290: LD_INT 104
60292: EQUAL
60293: IFFALSE 60299
// MC_TurretWeapon ( ) ;
60295: CALL 68444 0 0
// if event = 105 then
60299: LD_VAR 0 1
60303: PUSH
60304: LD_INT 105
60306: EQUAL
60307: IFFALSE 60313
// MC_BuildUpgrade ( ) ;
60309: CALL 67995 0 0
// if event = 106 then
60313: LD_VAR 0 1
60317: PUSH
60318: LD_INT 106
60320: EQUAL
60321: IFFALSE 60327
// MC_PlantMines ( ) ;
60323: CALL 68874 0 0
// if event = 107 then
60327: LD_VAR 0 1
60331: PUSH
60332: LD_INT 107
60334: EQUAL
60335: IFFALSE 60341
// MC_CollectCrates ( ) ;
60337: CALL 69665 0 0
// if event = 108 then
60341: LD_VAR 0 1
60345: PUSH
60346: LD_INT 108
60348: EQUAL
60349: IFFALSE 60355
// MC_LinkRemoteControl ( ) ;
60351: CALL 71515 0 0
// if event = 109 then
60355: LD_VAR 0 1
60359: PUSH
60360: LD_INT 109
60362: EQUAL
60363: IFFALSE 60369
// MC_ProduceVehicle ( ) ;
60365: CALL 71696 0 0
// if event = 110 then
60369: LD_VAR 0 1
60373: PUSH
60374: LD_INT 110
60376: EQUAL
60377: IFFALSE 60383
// MC_SendAttack ( ) ;
60379: CALL 72162 0 0
// if event = 111 then
60383: LD_VAR 0 1
60387: PUSH
60388: LD_INT 111
60390: EQUAL
60391: IFFALSE 60397
// MC_Defend ( ) ;
60393: CALL 72270 0 0
// if event = 112 then
60397: LD_VAR 0 1
60401: PUSH
60402: LD_INT 112
60404: EQUAL
60405: IFFALSE 60411
// MC_Research ( ) ;
60407: CALL 73150 0 0
// if event = 113 then
60411: LD_VAR 0 1
60415: PUSH
60416: LD_INT 113
60418: EQUAL
60419: IFFALSE 60425
// MC_MinesTrigger ( ) ;
60421: CALL 74264 0 0
// if event = 120 then
60425: LD_VAR 0 1
60429: PUSH
60430: LD_INT 120
60432: EQUAL
60433: IFFALSE 60439
// MC_RepairVehicle ( ) ;
60435: CALL 74363 0 0
// if event = 121 then
60439: LD_VAR 0 1
60443: PUSH
60444: LD_INT 121
60446: EQUAL
60447: IFFALSE 60453
// MC_TameApe ( ) ;
60449: CALL 75132 0 0
// if event = 122 then
60453: LD_VAR 0 1
60457: PUSH
60458: LD_INT 122
60460: EQUAL
60461: IFFALSE 60467
// MC_ChangeApeClass ( ) ;
60463: CALL 75961 0 0
// if event = 123 then
60467: LD_VAR 0 1
60471: PUSH
60472: LD_INT 123
60474: EQUAL
60475: IFFALSE 60481
// MC_Bazooka ( ) ;
60477: CALL 76611 0 0
// if event = 124 then
60481: LD_VAR 0 1
60485: PUSH
60486: LD_INT 124
60488: EQUAL
60489: IFFALSE 60495
// MC_TeleportExit ( ) ;
60491: CALL 76809 0 0
// if event = 125 then
60495: LD_VAR 0 1
60499: PUSH
60500: LD_INT 125
60502: EQUAL
60503: IFFALSE 60509
// MC_Deposits ( ) ;
60505: CALL 77456 0 0
// if event = 126 then
60509: LD_VAR 0 1
60513: PUSH
60514: LD_INT 126
60516: EQUAL
60517: IFFALSE 60523
// MC_RemoteDriver ( ) ;
60519: CALL 78081 0 0
// if event = 200 then
60523: LD_VAR 0 1
60527: PUSH
60528: LD_INT 200
60530: EQUAL
60531: IFFALSE 60537
// MC_Idle ( ) ;
60533: CALL 80030 0 0
// end ;
60537: PPOPN 1
60539: END
// export function MC_Reset ( base , tag ) ; var i ; begin
60540: LD_INT 0
60542: PPUSH
60543: PPUSH
// if not mc_bases [ base ] or not tag then
60544: LD_EXP 61
60548: PUSH
60549: LD_VAR 0 1
60553: ARRAY
60554: NOT
60555: PUSH
60556: LD_VAR 0 2
60560: NOT
60561: OR
60562: IFFALSE 60566
// exit ;
60564: GO 60630
// for i in mc_bases [ base ] union mc_ape [ base ] do
60566: LD_ADDR_VAR 0 4
60570: PUSH
60571: LD_EXP 61
60575: PUSH
60576: LD_VAR 0 1
60580: ARRAY
60581: PUSH
60582: LD_EXP 90
60586: PUSH
60587: LD_VAR 0 1
60591: ARRAY
60592: UNION
60593: PUSH
60594: FOR_IN
60595: IFFALSE 60628
// if GetTag ( i ) = tag then
60597: LD_VAR 0 4
60601: PPUSH
60602: CALL_OW 110
60606: PUSH
60607: LD_VAR 0 2
60611: EQUAL
60612: IFFALSE 60626
// SetTag ( i , 0 ) ;
60614: LD_VAR 0 4
60618: PPUSH
60619: LD_INT 0
60621: PPUSH
60622: CALL_OW 109
60626: GO 60594
60628: POP
60629: POP
// end ;
60630: LD_VAR 0 3
60634: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
60635: LD_INT 0
60637: PPUSH
60638: PPUSH
60639: PPUSH
60640: PPUSH
60641: PPUSH
60642: PPUSH
60643: PPUSH
60644: PPUSH
// if not mc_bases then
60645: LD_EXP 61
60649: NOT
60650: IFFALSE 60654
// exit ;
60652: GO 61112
// for i = 1 to mc_bases do
60654: LD_ADDR_VAR 0 2
60658: PUSH
60659: DOUBLE
60660: LD_INT 1
60662: DEC
60663: ST_TO_ADDR
60664: LD_EXP 61
60668: PUSH
60669: FOR_TO
60670: IFFALSE 61110
// begin tmp := MC_ClassCheckReq ( i ) ;
60672: LD_ADDR_VAR 0 4
60676: PUSH
60677: LD_VAR 0 2
60681: PPUSH
60682: CALL 61117 0 1
60686: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
60687: LD_ADDR_EXP 102
60691: PUSH
60692: LD_EXP 102
60696: PPUSH
60697: LD_VAR 0 2
60701: PPUSH
60702: LD_VAR 0 4
60706: PPUSH
60707: CALL_OW 1
60711: ST_TO_ADDR
// if not tmp then
60712: LD_VAR 0 4
60716: NOT
60717: IFFALSE 60721
// continue ;
60719: GO 60669
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
60721: LD_ADDR_VAR 0 6
60725: PUSH
60726: LD_EXP 61
60730: PUSH
60731: LD_VAR 0 2
60735: ARRAY
60736: PPUSH
60737: LD_INT 2
60739: PUSH
60740: LD_INT 30
60742: PUSH
60743: LD_INT 4
60745: PUSH
60746: EMPTY
60747: LIST
60748: LIST
60749: PUSH
60750: LD_INT 30
60752: PUSH
60753: LD_INT 5
60755: PUSH
60756: EMPTY
60757: LIST
60758: LIST
60759: PUSH
60760: EMPTY
60761: LIST
60762: LIST
60763: LIST
60764: PPUSH
60765: CALL_OW 72
60769: PUSH
60770: LD_EXP 61
60774: PUSH
60775: LD_VAR 0 2
60779: ARRAY
60780: PPUSH
60781: LD_INT 2
60783: PUSH
60784: LD_INT 30
60786: PUSH
60787: LD_INT 0
60789: PUSH
60790: EMPTY
60791: LIST
60792: LIST
60793: PUSH
60794: LD_INT 30
60796: PUSH
60797: LD_INT 1
60799: PUSH
60800: EMPTY
60801: LIST
60802: LIST
60803: PUSH
60804: EMPTY
60805: LIST
60806: LIST
60807: LIST
60808: PPUSH
60809: CALL_OW 72
60813: PUSH
60814: LD_EXP 61
60818: PUSH
60819: LD_VAR 0 2
60823: ARRAY
60824: PPUSH
60825: LD_INT 30
60827: PUSH
60828: LD_INT 3
60830: PUSH
60831: EMPTY
60832: LIST
60833: LIST
60834: PPUSH
60835: CALL_OW 72
60839: PUSH
60840: LD_EXP 61
60844: PUSH
60845: LD_VAR 0 2
60849: ARRAY
60850: PPUSH
60851: LD_INT 2
60853: PUSH
60854: LD_INT 30
60856: PUSH
60857: LD_INT 6
60859: PUSH
60860: EMPTY
60861: LIST
60862: LIST
60863: PUSH
60864: LD_INT 30
60866: PUSH
60867: LD_INT 7
60869: PUSH
60870: EMPTY
60871: LIST
60872: LIST
60873: PUSH
60874: LD_INT 30
60876: PUSH
60877: LD_INT 8
60879: PUSH
60880: EMPTY
60881: LIST
60882: LIST
60883: PUSH
60884: EMPTY
60885: LIST
60886: LIST
60887: LIST
60888: LIST
60889: PPUSH
60890: CALL_OW 72
60894: PUSH
60895: EMPTY
60896: LIST
60897: LIST
60898: LIST
60899: LIST
60900: ST_TO_ADDR
// for j = 1 to 4 do
60901: LD_ADDR_VAR 0 3
60905: PUSH
60906: DOUBLE
60907: LD_INT 1
60909: DEC
60910: ST_TO_ADDR
60911: LD_INT 4
60913: PUSH
60914: FOR_TO
60915: IFFALSE 61106
// begin if not tmp [ j ] then
60917: LD_VAR 0 4
60921: PUSH
60922: LD_VAR 0 3
60926: ARRAY
60927: NOT
60928: IFFALSE 60932
// continue ;
60930: GO 60914
// for p in tmp [ j ] do
60932: LD_ADDR_VAR 0 5
60936: PUSH
60937: LD_VAR 0 4
60941: PUSH
60942: LD_VAR 0 3
60946: ARRAY
60947: PUSH
60948: FOR_IN
60949: IFFALSE 61102
// begin if not b [ j ] then
60951: LD_VAR 0 6
60955: PUSH
60956: LD_VAR 0 3
60960: ARRAY
60961: NOT
60962: IFFALSE 60966
// break ;
60964: GO 61102
// e := 0 ;
60966: LD_ADDR_VAR 0 7
60970: PUSH
60971: LD_INT 0
60973: ST_TO_ADDR
// for k in b [ j ] do
60974: LD_ADDR_VAR 0 8
60978: PUSH
60979: LD_VAR 0 6
60983: PUSH
60984: LD_VAR 0 3
60988: ARRAY
60989: PUSH
60990: FOR_IN
60991: IFFALSE 61018
// if IsNotFull ( k ) then
60993: LD_VAR 0 8
60997: PPUSH
60998: CALL 17166 0 1
61002: IFFALSE 61016
// begin e := k ;
61004: LD_ADDR_VAR 0 7
61008: PUSH
61009: LD_VAR 0 8
61013: ST_TO_ADDR
// break ;
61014: GO 61018
// end ;
61016: GO 60990
61018: POP
61019: POP
// if e and not UnitGoingToBuilding ( p , e ) then
61020: LD_VAR 0 7
61024: PUSH
61025: LD_VAR 0 5
61029: PPUSH
61030: LD_VAR 0 7
61034: PPUSH
61035: CALL 51062 0 2
61039: NOT
61040: AND
61041: IFFALSE 61100
// begin if IsInUnit ( p ) then
61043: LD_VAR 0 5
61047: PPUSH
61048: CALL_OW 310
61052: IFFALSE 61063
// ComExitBuilding ( p ) ;
61054: LD_VAR 0 5
61058: PPUSH
61059: CALL_OW 122
// ComEnterUnit ( p , e ) ;
61063: LD_VAR 0 5
61067: PPUSH
61068: LD_VAR 0 7
61072: PPUSH
61073: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
61077: LD_VAR 0 5
61081: PPUSH
61082: LD_VAR 0 3
61086: PPUSH
61087: CALL_OW 183
// AddComExitBuilding ( p ) ;
61091: LD_VAR 0 5
61095: PPUSH
61096: CALL_OW 182
// end ; end ;
61100: GO 60948
61102: POP
61103: POP
// end ;
61104: GO 60914
61106: POP
61107: POP
// end ;
61108: GO 60669
61110: POP
61111: POP
// end ;
61112: LD_VAR 0 1
61116: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
61117: LD_INT 0
61119: PPUSH
61120: PPUSH
61121: PPUSH
61122: PPUSH
61123: PPUSH
61124: PPUSH
61125: PPUSH
61126: PPUSH
61127: PPUSH
61128: PPUSH
61129: PPUSH
61130: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61131: LD_VAR 0 1
61135: NOT
61136: PUSH
61137: LD_EXP 61
61141: PUSH
61142: LD_VAR 0 1
61146: ARRAY
61147: NOT
61148: OR
61149: PUSH
61150: LD_EXP 61
61154: PUSH
61155: LD_VAR 0 1
61159: ARRAY
61160: PPUSH
61161: LD_INT 2
61163: PUSH
61164: LD_INT 30
61166: PUSH
61167: LD_INT 0
61169: PUSH
61170: EMPTY
61171: LIST
61172: LIST
61173: PUSH
61174: LD_INT 30
61176: PUSH
61177: LD_INT 1
61179: PUSH
61180: EMPTY
61181: LIST
61182: LIST
61183: PUSH
61184: EMPTY
61185: LIST
61186: LIST
61187: LIST
61188: PPUSH
61189: CALL_OW 72
61193: NOT
61194: OR
61195: IFFALSE 61199
// exit ;
61197: GO 64702
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61199: LD_ADDR_VAR 0 4
61203: PUSH
61204: LD_EXP 61
61208: PUSH
61209: LD_VAR 0 1
61213: ARRAY
61214: PPUSH
61215: LD_INT 2
61217: PUSH
61218: LD_INT 25
61220: PUSH
61221: LD_INT 1
61223: PUSH
61224: EMPTY
61225: LIST
61226: LIST
61227: PUSH
61228: LD_INT 25
61230: PUSH
61231: LD_INT 2
61233: PUSH
61234: EMPTY
61235: LIST
61236: LIST
61237: PUSH
61238: LD_INT 25
61240: PUSH
61241: LD_INT 3
61243: PUSH
61244: EMPTY
61245: LIST
61246: LIST
61247: PUSH
61248: LD_INT 25
61250: PUSH
61251: LD_INT 4
61253: PUSH
61254: EMPTY
61255: LIST
61256: LIST
61257: PUSH
61258: LD_INT 25
61260: PUSH
61261: LD_INT 5
61263: PUSH
61264: EMPTY
61265: LIST
61266: LIST
61267: PUSH
61268: LD_INT 25
61270: PUSH
61271: LD_INT 8
61273: PUSH
61274: EMPTY
61275: LIST
61276: LIST
61277: PUSH
61278: LD_INT 25
61280: PUSH
61281: LD_INT 9
61283: PUSH
61284: EMPTY
61285: LIST
61286: LIST
61287: PUSH
61288: EMPTY
61289: LIST
61290: LIST
61291: LIST
61292: LIST
61293: LIST
61294: LIST
61295: LIST
61296: LIST
61297: PPUSH
61298: CALL_OW 72
61302: ST_TO_ADDR
// if not tmp then
61303: LD_VAR 0 4
61307: NOT
61308: IFFALSE 61312
// exit ;
61310: GO 64702
// for i in tmp do
61312: LD_ADDR_VAR 0 3
61316: PUSH
61317: LD_VAR 0 4
61321: PUSH
61322: FOR_IN
61323: IFFALSE 61354
// if GetTag ( i ) then
61325: LD_VAR 0 3
61329: PPUSH
61330: CALL_OW 110
61334: IFFALSE 61352
// tmp := tmp diff i ;
61336: LD_ADDR_VAR 0 4
61340: PUSH
61341: LD_VAR 0 4
61345: PUSH
61346: LD_VAR 0 3
61350: DIFF
61351: ST_TO_ADDR
61352: GO 61322
61354: POP
61355: POP
// if not tmp then
61356: LD_VAR 0 4
61360: NOT
61361: IFFALSE 61365
// exit ;
61363: GO 64702
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61365: LD_ADDR_VAR 0 5
61369: PUSH
61370: LD_EXP 61
61374: PUSH
61375: LD_VAR 0 1
61379: ARRAY
61380: PPUSH
61381: LD_INT 2
61383: PUSH
61384: LD_INT 25
61386: PUSH
61387: LD_INT 1
61389: PUSH
61390: EMPTY
61391: LIST
61392: LIST
61393: PUSH
61394: LD_INT 25
61396: PUSH
61397: LD_INT 5
61399: PUSH
61400: EMPTY
61401: LIST
61402: LIST
61403: PUSH
61404: LD_INT 25
61406: PUSH
61407: LD_INT 8
61409: PUSH
61410: EMPTY
61411: LIST
61412: LIST
61413: PUSH
61414: LD_INT 25
61416: PUSH
61417: LD_INT 9
61419: PUSH
61420: EMPTY
61421: LIST
61422: LIST
61423: PUSH
61424: EMPTY
61425: LIST
61426: LIST
61427: LIST
61428: LIST
61429: LIST
61430: PPUSH
61431: CALL_OW 72
61435: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
61436: LD_ADDR_VAR 0 6
61440: PUSH
61441: LD_EXP 61
61445: PUSH
61446: LD_VAR 0 1
61450: ARRAY
61451: PPUSH
61452: LD_INT 25
61454: PUSH
61455: LD_INT 2
61457: PUSH
61458: EMPTY
61459: LIST
61460: LIST
61461: PPUSH
61462: CALL_OW 72
61466: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
61467: LD_ADDR_VAR 0 7
61471: PUSH
61472: LD_EXP 61
61476: PUSH
61477: LD_VAR 0 1
61481: ARRAY
61482: PPUSH
61483: LD_INT 25
61485: PUSH
61486: LD_INT 3
61488: PUSH
61489: EMPTY
61490: LIST
61491: LIST
61492: PPUSH
61493: CALL_OW 72
61497: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
61498: LD_ADDR_VAR 0 8
61502: PUSH
61503: LD_EXP 61
61507: PUSH
61508: LD_VAR 0 1
61512: ARRAY
61513: PPUSH
61514: LD_INT 25
61516: PUSH
61517: LD_INT 4
61519: PUSH
61520: EMPTY
61521: LIST
61522: LIST
61523: PUSH
61524: LD_INT 24
61526: PUSH
61527: LD_INT 251
61529: PUSH
61530: EMPTY
61531: LIST
61532: LIST
61533: PUSH
61534: EMPTY
61535: LIST
61536: LIST
61537: PPUSH
61538: CALL_OW 72
61542: ST_TO_ADDR
// if mc_is_defending [ base ] then
61543: LD_EXP 104
61547: PUSH
61548: LD_VAR 0 1
61552: ARRAY
61553: IFFALSE 62014
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
61555: LD_ADDR_EXP 103
61559: PUSH
61560: LD_EXP 103
61564: PPUSH
61565: LD_VAR 0 1
61569: PPUSH
61570: LD_INT 4
61572: PPUSH
61573: CALL_OW 1
61577: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
61578: LD_ADDR_VAR 0 12
61582: PUSH
61583: LD_EXP 61
61587: PUSH
61588: LD_VAR 0 1
61592: ARRAY
61593: PPUSH
61594: LD_INT 2
61596: PUSH
61597: LD_INT 30
61599: PUSH
61600: LD_INT 4
61602: PUSH
61603: EMPTY
61604: LIST
61605: LIST
61606: PUSH
61607: LD_INT 30
61609: PUSH
61610: LD_INT 5
61612: PUSH
61613: EMPTY
61614: LIST
61615: LIST
61616: PUSH
61617: EMPTY
61618: LIST
61619: LIST
61620: LIST
61621: PPUSH
61622: CALL_OW 72
61626: ST_TO_ADDR
// if not b then
61627: LD_VAR 0 12
61631: NOT
61632: IFFALSE 61636
// exit ;
61634: GO 64702
// p := [ ] ;
61636: LD_ADDR_VAR 0 11
61640: PUSH
61641: EMPTY
61642: ST_TO_ADDR
// if sci >= 2 then
61643: LD_VAR 0 8
61647: PUSH
61648: LD_INT 2
61650: GREATEREQUAL
61651: IFFALSE 61682
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
61653: LD_ADDR_VAR 0 8
61657: PUSH
61658: LD_VAR 0 8
61662: PUSH
61663: LD_INT 1
61665: ARRAY
61666: PUSH
61667: LD_VAR 0 8
61671: PUSH
61672: LD_INT 2
61674: ARRAY
61675: PUSH
61676: EMPTY
61677: LIST
61678: LIST
61679: ST_TO_ADDR
61680: GO 61743
// if sci = 1 then
61682: LD_VAR 0 8
61686: PUSH
61687: LD_INT 1
61689: EQUAL
61690: IFFALSE 61711
// sci := [ sci [ 1 ] ] else
61692: LD_ADDR_VAR 0 8
61696: PUSH
61697: LD_VAR 0 8
61701: PUSH
61702: LD_INT 1
61704: ARRAY
61705: PUSH
61706: EMPTY
61707: LIST
61708: ST_TO_ADDR
61709: GO 61743
// if sci = 0 then
61711: LD_VAR 0 8
61715: PUSH
61716: LD_INT 0
61718: EQUAL
61719: IFFALSE 61743
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
61721: LD_ADDR_VAR 0 11
61725: PUSH
61726: LD_VAR 0 4
61730: PPUSH
61731: LD_INT 4
61733: PPUSH
61734: CALL 50934 0 2
61738: PUSH
61739: LD_INT 1
61741: ARRAY
61742: ST_TO_ADDR
// if eng > 4 then
61743: LD_VAR 0 6
61747: PUSH
61748: LD_INT 4
61750: GREATER
61751: IFFALSE 61797
// for i = eng downto 4 do
61753: LD_ADDR_VAR 0 3
61757: PUSH
61758: DOUBLE
61759: LD_VAR 0 6
61763: INC
61764: ST_TO_ADDR
61765: LD_INT 4
61767: PUSH
61768: FOR_DOWNTO
61769: IFFALSE 61795
// eng := eng diff eng [ i ] ;
61771: LD_ADDR_VAR 0 6
61775: PUSH
61776: LD_VAR 0 6
61780: PUSH
61781: LD_VAR 0 6
61785: PUSH
61786: LD_VAR 0 3
61790: ARRAY
61791: DIFF
61792: ST_TO_ADDR
61793: GO 61768
61795: POP
61796: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
61797: LD_ADDR_VAR 0 4
61801: PUSH
61802: LD_VAR 0 4
61806: PUSH
61807: LD_VAR 0 5
61811: PUSH
61812: LD_VAR 0 6
61816: UNION
61817: PUSH
61818: LD_VAR 0 7
61822: UNION
61823: PUSH
61824: LD_VAR 0 8
61828: UNION
61829: DIFF
61830: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
61831: LD_ADDR_VAR 0 13
61835: PUSH
61836: LD_EXP 61
61840: PUSH
61841: LD_VAR 0 1
61845: ARRAY
61846: PPUSH
61847: LD_INT 2
61849: PUSH
61850: LD_INT 30
61852: PUSH
61853: LD_INT 32
61855: PUSH
61856: EMPTY
61857: LIST
61858: LIST
61859: PUSH
61860: LD_INT 30
61862: PUSH
61863: LD_INT 31
61865: PUSH
61866: EMPTY
61867: LIST
61868: LIST
61869: PUSH
61870: EMPTY
61871: LIST
61872: LIST
61873: LIST
61874: PPUSH
61875: CALL_OW 72
61879: PUSH
61880: LD_EXP 61
61884: PUSH
61885: LD_VAR 0 1
61889: ARRAY
61890: PPUSH
61891: LD_INT 2
61893: PUSH
61894: LD_INT 30
61896: PUSH
61897: LD_INT 4
61899: PUSH
61900: EMPTY
61901: LIST
61902: LIST
61903: PUSH
61904: LD_INT 30
61906: PUSH
61907: LD_INT 5
61909: PUSH
61910: EMPTY
61911: LIST
61912: LIST
61913: PUSH
61914: EMPTY
61915: LIST
61916: LIST
61917: LIST
61918: PPUSH
61919: CALL_OW 72
61923: PUSH
61924: LD_INT 6
61926: MUL
61927: PLUS
61928: ST_TO_ADDR
// if bcount < tmp then
61929: LD_VAR 0 13
61933: PUSH
61934: LD_VAR 0 4
61938: LESS
61939: IFFALSE 61985
// for i = tmp downto bcount do
61941: LD_ADDR_VAR 0 3
61945: PUSH
61946: DOUBLE
61947: LD_VAR 0 4
61951: INC
61952: ST_TO_ADDR
61953: LD_VAR 0 13
61957: PUSH
61958: FOR_DOWNTO
61959: IFFALSE 61983
// tmp := Delete ( tmp , tmp ) ;
61961: LD_ADDR_VAR 0 4
61965: PUSH
61966: LD_VAR 0 4
61970: PPUSH
61971: LD_VAR 0 4
61975: PPUSH
61976: CALL_OW 3
61980: ST_TO_ADDR
61981: GO 61958
61983: POP
61984: POP
// result := [ tmp , 0 , 0 , p ] ;
61985: LD_ADDR_VAR 0 2
61989: PUSH
61990: LD_VAR 0 4
61994: PUSH
61995: LD_INT 0
61997: PUSH
61998: LD_INT 0
62000: PUSH
62001: LD_VAR 0 11
62005: PUSH
62006: EMPTY
62007: LIST
62008: LIST
62009: LIST
62010: LIST
62011: ST_TO_ADDR
// exit ;
62012: GO 64702
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62014: LD_EXP 61
62018: PUSH
62019: LD_VAR 0 1
62023: ARRAY
62024: PPUSH
62025: LD_INT 2
62027: PUSH
62028: LD_INT 30
62030: PUSH
62031: LD_INT 6
62033: PUSH
62034: EMPTY
62035: LIST
62036: LIST
62037: PUSH
62038: LD_INT 30
62040: PUSH
62041: LD_INT 7
62043: PUSH
62044: EMPTY
62045: LIST
62046: LIST
62047: PUSH
62048: LD_INT 30
62050: PUSH
62051: LD_INT 8
62053: PUSH
62054: EMPTY
62055: LIST
62056: LIST
62057: PUSH
62058: EMPTY
62059: LIST
62060: LIST
62061: LIST
62062: LIST
62063: PPUSH
62064: CALL_OW 72
62068: NOT
62069: PUSH
62070: LD_EXP 61
62074: PUSH
62075: LD_VAR 0 1
62079: ARRAY
62080: PPUSH
62081: LD_INT 30
62083: PUSH
62084: LD_INT 3
62086: PUSH
62087: EMPTY
62088: LIST
62089: LIST
62090: PPUSH
62091: CALL_OW 72
62095: NOT
62096: AND
62097: IFFALSE 62169
// begin if eng = tmp then
62099: LD_VAR 0 6
62103: PUSH
62104: LD_VAR 0 4
62108: EQUAL
62109: IFFALSE 62113
// exit ;
62111: GO 64702
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
62113: LD_ADDR_EXP 103
62117: PUSH
62118: LD_EXP 103
62122: PPUSH
62123: LD_VAR 0 1
62127: PPUSH
62128: LD_INT 1
62130: PPUSH
62131: CALL_OW 1
62135: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
62136: LD_ADDR_VAR 0 2
62140: PUSH
62141: LD_INT 0
62143: PUSH
62144: LD_VAR 0 4
62148: PUSH
62149: LD_VAR 0 6
62153: DIFF
62154: PUSH
62155: LD_INT 0
62157: PUSH
62158: LD_INT 0
62160: PUSH
62161: EMPTY
62162: LIST
62163: LIST
62164: LIST
62165: LIST
62166: ST_TO_ADDR
// exit ;
62167: GO 64702
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62169: LD_EXP 88
62173: PUSH
62174: LD_EXP 87
62178: PUSH
62179: LD_VAR 0 1
62183: ARRAY
62184: ARRAY
62185: PUSH
62186: LD_EXP 61
62190: PUSH
62191: LD_VAR 0 1
62195: ARRAY
62196: PPUSH
62197: LD_INT 2
62199: PUSH
62200: LD_INT 30
62202: PUSH
62203: LD_INT 6
62205: PUSH
62206: EMPTY
62207: LIST
62208: LIST
62209: PUSH
62210: LD_INT 30
62212: PUSH
62213: LD_INT 7
62215: PUSH
62216: EMPTY
62217: LIST
62218: LIST
62219: PUSH
62220: LD_INT 30
62222: PUSH
62223: LD_INT 8
62225: PUSH
62226: EMPTY
62227: LIST
62228: LIST
62229: PUSH
62230: EMPTY
62231: LIST
62232: LIST
62233: LIST
62234: LIST
62235: PPUSH
62236: CALL_OW 72
62240: AND
62241: PUSH
62242: LD_EXP 61
62246: PUSH
62247: LD_VAR 0 1
62251: ARRAY
62252: PPUSH
62253: LD_INT 30
62255: PUSH
62256: LD_INT 3
62258: PUSH
62259: EMPTY
62260: LIST
62261: LIST
62262: PPUSH
62263: CALL_OW 72
62267: NOT
62268: AND
62269: IFFALSE 62483
// begin if sci >= 6 then
62271: LD_VAR 0 8
62275: PUSH
62276: LD_INT 6
62278: GREATEREQUAL
62279: IFFALSE 62283
// exit ;
62281: GO 64702
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
62283: LD_ADDR_EXP 103
62287: PUSH
62288: LD_EXP 103
62292: PPUSH
62293: LD_VAR 0 1
62297: PPUSH
62298: LD_INT 2
62300: PPUSH
62301: CALL_OW 1
62305: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
62306: LD_ADDR_VAR 0 9
62310: PUSH
62311: LD_VAR 0 4
62315: PUSH
62316: LD_VAR 0 8
62320: DIFF
62321: PPUSH
62322: LD_INT 4
62324: PPUSH
62325: CALL 50934 0 2
62329: ST_TO_ADDR
// p := [ ] ;
62330: LD_ADDR_VAR 0 11
62334: PUSH
62335: EMPTY
62336: ST_TO_ADDR
// if sci < 6 and sort > 6 then
62337: LD_VAR 0 8
62341: PUSH
62342: LD_INT 6
62344: LESS
62345: PUSH
62346: LD_VAR 0 9
62350: PUSH
62351: LD_INT 6
62353: GREATER
62354: AND
62355: IFFALSE 62436
// begin for i = 1 to 6 - sci do
62357: LD_ADDR_VAR 0 3
62361: PUSH
62362: DOUBLE
62363: LD_INT 1
62365: DEC
62366: ST_TO_ADDR
62367: LD_INT 6
62369: PUSH
62370: LD_VAR 0 8
62374: MINUS
62375: PUSH
62376: FOR_TO
62377: IFFALSE 62432
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
62379: LD_ADDR_VAR 0 11
62383: PUSH
62384: LD_VAR 0 11
62388: PPUSH
62389: LD_VAR 0 11
62393: PUSH
62394: LD_INT 1
62396: PLUS
62397: PPUSH
62398: LD_VAR 0 9
62402: PUSH
62403: LD_INT 1
62405: ARRAY
62406: PPUSH
62407: CALL_OW 2
62411: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
62412: LD_ADDR_VAR 0 9
62416: PUSH
62417: LD_VAR 0 9
62421: PPUSH
62422: LD_INT 1
62424: PPUSH
62425: CALL_OW 3
62429: ST_TO_ADDR
// end ;
62430: GO 62376
62432: POP
62433: POP
// end else
62434: GO 62456
// if sort then
62436: LD_VAR 0 9
62440: IFFALSE 62456
// p := sort [ 1 ] ;
62442: LD_ADDR_VAR 0 11
62446: PUSH
62447: LD_VAR 0 9
62451: PUSH
62452: LD_INT 1
62454: ARRAY
62455: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
62456: LD_ADDR_VAR 0 2
62460: PUSH
62461: LD_INT 0
62463: PUSH
62464: LD_INT 0
62466: PUSH
62467: LD_INT 0
62469: PUSH
62470: LD_VAR 0 11
62474: PUSH
62475: EMPTY
62476: LIST
62477: LIST
62478: LIST
62479: LIST
62480: ST_TO_ADDR
// exit ;
62481: GO 64702
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62483: LD_EXP 88
62487: PUSH
62488: LD_EXP 87
62492: PUSH
62493: LD_VAR 0 1
62497: ARRAY
62498: ARRAY
62499: PUSH
62500: LD_EXP 61
62504: PUSH
62505: LD_VAR 0 1
62509: ARRAY
62510: PPUSH
62511: LD_INT 2
62513: PUSH
62514: LD_INT 30
62516: PUSH
62517: LD_INT 6
62519: PUSH
62520: EMPTY
62521: LIST
62522: LIST
62523: PUSH
62524: LD_INT 30
62526: PUSH
62527: LD_INT 7
62529: PUSH
62530: EMPTY
62531: LIST
62532: LIST
62533: PUSH
62534: LD_INT 30
62536: PUSH
62537: LD_INT 8
62539: PUSH
62540: EMPTY
62541: LIST
62542: LIST
62543: PUSH
62544: EMPTY
62545: LIST
62546: LIST
62547: LIST
62548: LIST
62549: PPUSH
62550: CALL_OW 72
62554: AND
62555: PUSH
62556: LD_EXP 61
62560: PUSH
62561: LD_VAR 0 1
62565: ARRAY
62566: PPUSH
62567: LD_INT 30
62569: PUSH
62570: LD_INT 3
62572: PUSH
62573: EMPTY
62574: LIST
62575: LIST
62576: PPUSH
62577: CALL_OW 72
62581: AND
62582: IFFALSE 63316
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
62584: LD_ADDR_EXP 103
62588: PUSH
62589: LD_EXP 103
62593: PPUSH
62594: LD_VAR 0 1
62598: PPUSH
62599: LD_INT 3
62601: PPUSH
62602: CALL_OW 1
62606: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62607: LD_ADDR_VAR 0 2
62611: PUSH
62612: LD_INT 0
62614: PUSH
62615: LD_INT 0
62617: PUSH
62618: LD_INT 0
62620: PUSH
62621: LD_INT 0
62623: PUSH
62624: EMPTY
62625: LIST
62626: LIST
62627: LIST
62628: LIST
62629: ST_TO_ADDR
// if not eng then
62630: LD_VAR 0 6
62634: NOT
62635: IFFALSE 62698
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
62637: LD_ADDR_VAR 0 11
62641: PUSH
62642: LD_VAR 0 4
62646: PPUSH
62647: LD_INT 2
62649: PPUSH
62650: CALL 50934 0 2
62654: PUSH
62655: LD_INT 1
62657: ARRAY
62658: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
62659: LD_ADDR_VAR 0 2
62663: PUSH
62664: LD_VAR 0 2
62668: PPUSH
62669: LD_INT 2
62671: PPUSH
62672: LD_VAR 0 11
62676: PPUSH
62677: CALL_OW 1
62681: ST_TO_ADDR
// tmp := tmp diff p ;
62682: LD_ADDR_VAR 0 4
62686: PUSH
62687: LD_VAR 0 4
62691: PUSH
62692: LD_VAR 0 11
62696: DIFF
62697: ST_TO_ADDR
// end ; if tmp and sci < 6 then
62698: LD_VAR 0 4
62702: PUSH
62703: LD_VAR 0 8
62707: PUSH
62708: LD_INT 6
62710: LESS
62711: AND
62712: IFFALSE 62900
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
62714: LD_ADDR_VAR 0 9
62718: PUSH
62719: LD_VAR 0 4
62723: PUSH
62724: LD_VAR 0 8
62728: PUSH
62729: LD_VAR 0 7
62733: UNION
62734: DIFF
62735: PPUSH
62736: LD_INT 4
62738: PPUSH
62739: CALL 50934 0 2
62743: ST_TO_ADDR
// p := [ ] ;
62744: LD_ADDR_VAR 0 11
62748: PUSH
62749: EMPTY
62750: ST_TO_ADDR
// if sort then
62751: LD_VAR 0 9
62755: IFFALSE 62871
// for i = 1 to 6 - sci do
62757: LD_ADDR_VAR 0 3
62761: PUSH
62762: DOUBLE
62763: LD_INT 1
62765: DEC
62766: ST_TO_ADDR
62767: LD_INT 6
62769: PUSH
62770: LD_VAR 0 8
62774: MINUS
62775: PUSH
62776: FOR_TO
62777: IFFALSE 62869
// begin if i = sort then
62779: LD_VAR 0 3
62783: PUSH
62784: LD_VAR 0 9
62788: EQUAL
62789: IFFALSE 62793
// break ;
62791: GO 62869
// if GetClass ( i ) = 4 then
62793: LD_VAR 0 3
62797: PPUSH
62798: CALL_OW 257
62802: PUSH
62803: LD_INT 4
62805: EQUAL
62806: IFFALSE 62810
// continue ;
62808: GO 62776
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62810: LD_ADDR_VAR 0 11
62814: PUSH
62815: LD_VAR 0 11
62819: PPUSH
62820: LD_VAR 0 11
62824: PUSH
62825: LD_INT 1
62827: PLUS
62828: PPUSH
62829: LD_VAR 0 9
62833: PUSH
62834: LD_VAR 0 3
62838: ARRAY
62839: PPUSH
62840: CALL_OW 2
62844: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62845: LD_ADDR_VAR 0 4
62849: PUSH
62850: LD_VAR 0 4
62854: PUSH
62855: LD_VAR 0 9
62859: PUSH
62860: LD_VAR 0 3
62864: ARRAY
62865: DIFF
62866: ST_TO_ADDR
// end ;
62867: GO 62776
62869: POP
62870: POP
// if p then
62871: LD_VAR 0 11
62875: IFFALSE 62900
// result := Replace ( result , 4 , p ) ;
62877: LD_ADDR_VAR 0 2
62881: PUSH
62882: LD_VAR 0 2
62886: PPUSH
62887: LD_INT 4
62889: PPUSH
62890: LD_VAR 0 11
62894: PPUSH
62895: CALL_OW 1
62899: ST_TO_ADDR
// end ; if tmp and mech < 6 then
62900: LD_VAR 0 4
62904: PUSH
62905: LD_VAR 0 7
62909: PUSH
62910: LD_INT 6
62912: LESS
62913: AND
62914: IFFALSE 63102
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62916: LD_ADDR_VAR 0 9
62920: PUSH
62921: LD_VAR 0 4
62925: PUSH
62926: LD_VAR 0 8
62930: PUSH
62931: LD_VAR 0 7
62935: UNION
62936: DIFF
62937: PPUSH
62938: LD_INT 3
62940: PPUSH
62941: CALL 50934 0 2
62945: ST_TO_ADDR
// p := [ ] ;
62946: LD_ADDR_VAR 0 11
62950: PUSH
62951: EMPTY
62952: ST_TO_ADDR
// if sort then
62953: LD_VAR 0 9
62957: IFFALSE 63073
// for i = 1 to 6 - mech do
62959: LD_ADDR_VAR 0 3
62963: PUSH
62964: DOUBLE
62965: LD_INT 1
62967: DEC
62968: ST_TO_ADDR
62969: LD_INT 6
62971: PUSH
62972: LD_VAR 0 7
62976: MINUS
62977: PUSH
62978: FOR_TO
62979: IFFALSE 63071
// begin if i = sort then
62981: LD_VAR 0 3
62985: PUSH
62986: LD_VAR 0 9
62990: EQUAL
62991: IFFALSE 62995
// break ;
62993: GO 63071
// if GetClass ( i ) = 3 then
62995: LD_VAR 0 3
62999: PPUSH
63000: CALL_OW 257
63004: PUSH
63005: LD_INT 3
63007: EQUAL
63008: IFFALSE 63012
// continue ;
63010: GO 62978
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63012: LD_ADDR_VAR 0 11
63016: PUSH
63017: LD_VAR 0 11
63021: PPUSH
63022: LD_VAR 0 11
63026: PUSH
63027: LD_INT 1
63029: PLUS
63030: PPUSH
63031: LD_VAR 0 9
63035: PUSH
63036: LD_VAR 0 3
63040: ARRAY
63041: PPUSH
63042: CALL_OW 2
63046: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63047: LD_ADDR_VAR 0 4
63051: PUSH
63052: LD_VAR 0 4
63056: PUSH
63057: LD_VAR 0 9
63061: PUSH
63062: LD_VAR 0 3
63066: ARRAY
63067: DIFF
63068: ST_TO_ADDR
// end ;
63069: GO 62978
63071: POP
63072: POP
// if p then
63073: LD_VAR 0 11
63077: IFFALSE 63102
// result := Replace ( result , 3 , p ) ;
63079: LD_ADDR_VAR 0 2
63083: PUSH
63084: LD_VAR 0 2
63088: PPUSH
63089: LD_INT 3
63091: PPUSH
63092: LD_VAR 0 11
63096: PPUSH
63097: CALL_OW 1
63101: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
63102: LD_VAR 0 4
63106: PUSH
63107: LD_INT 6
63109: GREATER
63110: PUSH
63111: LD_VAR 0 6
63115: PUSH
63116: LD_INT 6
63118: LESS
63119: AND
63120: IFFALSE 63314
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63122: LD_ADDR_VAR 0 9
63126: PUSH
63127: LD_VAR 0 4
63131: PUSH
63132: LD_VAR 0 8
63136: PUSH
63137: LD_VAR 0 7
63141: UNION
63142: PUSH
63143: LD_VAR 0 6
63147: UNION
63148: DIFF
63149: PPUSH
63150: LD_INT 2
63152: PPUSH
63153: CALL 50934 0 2
63157: ST_TO_ADDR
// p := [ ] ;
63158: LD_ADDR_VAR 0 11
63162: PUSH
63163: EMPTY
63164: ST_TO_ADDR
// if sort then
63165: LD_VAR 0 9
63169: IFFALSE 63285
// for i = 1 to 6 - eng do
63171: LD_ADDR_VAR 0 3
63175: PUSH
63176: DOUBLE
63177: LD_INT 1
63179: DEC
63180: ST_TO_ADDR
63181: LD_INT 6
63183: PUSH
63184: LD_VAR 0 6
63188: MINUS
63189: PUSH
63190: FOR_TO
63191: IFFALSE 63283
// begin if i = sort then
63193: LD_VAR 0 3
63197: PUSH
63198: LD_VAR 0 9
63202: EQUAL
63203: IFFALSE 63207
// break ;
63205: GO 63283
// if GetClass ( i ) = 2 then
63207: LD_VAR 0 3
63211: PPUSH
63212: CALL_OW 257
63216: PUSH
63217: LD_INT 2
63219: EQUAL
63220: IFFALSE 63224
// continue ;
63222: GO 63190
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63224: LD_ADDR_VAR 0 11
63228: PUSH
63229: LD_VAR 0 11
63233: PPUSH
63234: LD_VAR 0 11
63238: PUSH
63239: LD_INT 1
63241: PLUS
63242: PPUSH
63243: LD_VAR 0 9
63247: PUSH
63248: LD_VAR 0 3
63252: ARRAY
63253: PPUSH
63254: CALL_OW 2
63258: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63259: LD_ADDR_VAR 0 4
63263: PUSH
63264: LD_VAR 0 4
63268: PUSH
63269: LD_VAR 0 9
63273: PUSH
63274: LD_VAR 0 3
63278: ARRAY
63279: DIFF
63280: ST_TO_ADDR
// end ;
63281: GO 63190
63283: POP
63284: POP
// if p then
63285: LD_VAR 0 11
63289: IFFALSE 63314
// result := Replace ( result , 2 , p ) ;
63291: LD_ADDR_VAR 0 2
63295: PUSH
63296: LD_VAR 0 2
63300: PPUSH
63301: LD_INT 2
63303: PPUSH
63304: LD_VAR 0 11
63308: PPUSH
63309: CALL_OW 1
63313: ST_TO_ADDR
// end ; exit ;
63314: GO 64702
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
63316: LD_EXP 88
63320: PUSH
63321: LD_EXP 87
63325: PUSH
63326: LD_VAR 0 1
63330: ARRAY
63331: ARRAY
63332: NOT
63333: PUSH
63334: LD_EXP 61
63338: PUSH
63339: LD_VAR 0 1
63343: ARRAY
63344: PPUSH
63345: LD_INT 30
63347: PUSH
63348: LD_INT 3
63350: PUSH
63351: EMPTY
63352: LIST
63353: LIST
63354: PPUSH
63355: CALL_OW 72
63359: AND
63360: PUSH
63361: LD_EXP 66
63365: PUSH
63366: LD_VAR 0 1
63370: ARRAY
63371: AND
63372: IFFALSE 63980
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
63374: LD_ADDR_EXP 103
63378: PUSH
63379: LD_EXP 103
63383: PPUSH
63384: LD_VAR 0 1
63388: PPUSH
63389: LD_INT 5
63391: PPUSH
63392: CALL_OW 1
63396: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63397: LD_ADDR_VAR 0 2
63401: PUSH
63402: LD_INT 0
63404: PUSH
63405: LD_INT 0
63407: PUSH
63408: LD_INT 0
63410: PUSH
63411: LD_INT 0
63413: PUSH
63414: EMPTY
63415: LIST
63416: LIST
63417: LIST
63418: LIST
63419: ST_TO_ADDR
// if sci > 1 then
63420: LD_VAR 0 8
63424: PUSH
63425: LD_INT 1
63427: GREATER
63428: IFFALSE 63456
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
63430: LD_ADDR_VAR 0 4
63434: PUSH
63435: LD_VAR 0 4
63439: PUSH
63440: LD_VAR 0 8
63444: PUSH
63445: LD_VAR 0 8
63449: PUSH
63450: LD_INT 1
63452: ARRAY
63453: DIFF
63454: DIFF
63455: ST_TO_ADDR
// if tmp and not sci then
63456: LD_VAR 0 4
63460: PUSH
63461: LD_VAR 0 8
63465: NOT
63466: AND
63467: IFFALSE 63536
// begin sort := SortBySkill ( tmp , 4 ) ;
63469: LD_ADDR_VAR 0 9
63473: PUSH
63474: LD_VAR 0 4
63478: PPUSH
63479: LD_INT 4
63481: PPUSH
63482: CALL 50934 0 2
63486: ST_TO_ADDR
// if sort then
63487: LD_VAR 0 9
63491: IFFALSE 63507
// p := sort [ 1 ] ;
63493: LD_ADDR_VAR 0 11
63497: PUSH
63498: LD_VAR 0 9
63502: PUSH
63503: LD_INT 1
63505: ARRAY
63506: ST_TO_ADDR
// if p then
63507: LD_VAR 0 11
63511: IFFALSE 63536
// result := Replace ( result , 4 , p ) ;
63513: LD_ADDR_VAR 0 2
63517: PUSH
63518: LD_VAR 0 2
63522: PPUSH
63523: LD_INT 4
63525: PPUSH
63526: LD_VAR 0 11
63530: PPUSH
63531: CALL_OW 1
63535: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
63536: LD_ADDR_VAR 0 4
63540: PUSH
63541: LD_VAR 0 4
63545: PUSH
63546: LD_VAR 0 7
63550: DIFF
63551: ST_TO_ADDR
// if tmp and mech < 6 then
63552: LD_VAR 0 4
63556: PUSH
63557: LD_VAR 0 7
63561: PUSH
63562: LD_INT 6
63564: LESS
63565: AND
63566: IFFALSE 63754
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63568: LD_ADDR_VAR 0 9
63572: PUSH
63573: LD_VAR 0 4
63577: PUSH
63578: LD_VAR 0 8
63582: PUSH
63583: LD_VAR 0 7
63587: UNION
63588: DIFF
63589: PPUSH
63590: LD_INT 3
63592: PPUSH
63593: CALL 50934 0 2
63597: ST_TO_ADDR
// p := [ ] ;
63598: LD_ADDR_VAR 0 11
63602: PUSH
63603: EMPTY
63604: ST_TO_ADDR
// if sort then
63605: LD_VAR 0 9
63609: IFFALSE 63725
// for i = 1 to 6 - mech do
63611: LD_ADDR_VAR 0 3
63615: PUSH
63616: DOUBLE
63617: LD_INT 1
63619: DEC
63620: ST_TO_ADDR
63621: LD_INT 6
63623: PUSH
63624: LD_VAR 0 7
63628: MINUS
63629: PUSH
63630: FOR_TO
63631: IFFALSE 63723
// begin if i = sort then
63633: LD_VAR 0 3
63637: PUSH
63638: LD_VAR 0 9
63642: EQUAL
63643: IFFALSE 63647
// break ;
63645: GO 63723
// if GetClass ( i ) = 3 then
63647: LD_VAR 0 3
63651: PPUSH
63652: CALL_OW 257
63656: PUSH
63657: LD_INT 3
63659: EQUAL
63660: IFFALSE 63664
// continue ;
63662: GO 63630
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63664: LD_ADDR_VAR 0 11
63668: PUSH
63669: LD_VAR 0 11
63673: PPUSH
63674: LD_VAR 0 11
63678: PUSH
63679: LD_INT 1
63681: PLUS
63682: PPUSH
63683: LD_VAR 0 9
63687: PUSH
63688: LD_VAR 0 3
63692: ARRAY
63693: PPUSH
63694: CALL_OW 2
63698: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63699: LD_ADDR_VAR 0 4
63703: PUSH
63704: LD_VAR 0 4
63708: PUSH
63709: LD_VAR 0 9
63713: PUSH
63714: LD_VAR 0 3
63718: ARRAY
63719: DIFF
63720: ST_TO_ADDR
// end ;
63721: GO 63630
63723: POP
63724: POP
// if p then
63725: LD_VAR 0 11
63729: IFFALSE 63754
// result := Replace ( result , 3 , p ) ;
63731: LD_ADDR_VAR 0 2
63735: PUSH
63736: LD_VAR 0 2
63740: PPUSH
63741: LD_INT 3
63743: PPUSH
63744: LD_VAR 0 11
63748: PPUSH
63749: CALL_OW 1
63753: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
63754: LD_ADDR_VAR 0 4
63758: PUSH
63759: LD_VAR 0 4
63763: PUSH
63764: LD_VAR 0 6
63768: DIFF
63769: ST_TO_ADDR
// if tmp and eng < 6 then
63770: LD_VAR 0 4
63774: PUSH
63775: LD_VAR 0 6
63779: PUSH
63780: LD_INT 6
63782: LESS
63783: AND
63784: IFFALSE 63978
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63786: LD_ADDR_VAR 0 9
63790: PUSH
63791: LD_VAR 0 4
63795: PUSH
63796: LD_VAR 0 8
63800: PUSH
63801: LD_VAR 0 7
63805: UNION
63806: PUSH
63807: LD_VAR 0 6
63811: UNION
63812: DIFF
63813: PPUSH
63814: LD_INT 2
63816: PPUSH
63817: CALL 50934 0 2
63821: ST_TO_ADDR
// p := [ ] ;
63822: LD_ADDR_VAR 0 11
63826: PUSH
63827: EMPTY
63828: ST_TO_ADDR
// if sort then
63829: LD_VAR 0 9
63833: IFFALSE 63949
// for i = 1 to 6 - eng do
63835: LD_ADDR_VAR 0 3
63839: PUSH
63840: DOUBLE
63841: LD_INT 1
63843: DEC
63844: ST_TO_ADDR
63845: LD_INT 6
63847: PUSH
63848: LD_VAR 0 6
63852: MINUS
63853: PUSH
63854: FOR_TO
63855: IFFALSE 63947
// begin if i = sort then
63857: LD_VAR 0 3
63861: PUSH
63862: LD_VAR 0 9
63866: EQUAL
63867: IFFALSE 63871
// break ;
63869: GO 63947
// if GetClass ( i ) = 2 then
63871: LD_VAR 0 3
63875: PPUSH
63876: CALL_OW 257
63880: PUSH
63881: LD_INT 2
63883: EQUAL
63884: IFFALSE 63888
// continue ;
63886: GO 63854
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63888: LD_ADDR_VAR 0 11
63892: PUSH
63893: LD_VAR 0 11
63897: PPUSH
63898: LD_VAR 0 11
63902: PUSH
63903: LD_INT 1
63905: PLUS
63906: PPUSH
63907: LD_VAR 0 9
63911: PUSH
63912: LD_VAR 0 3
63916: ARRAY
63917: PPUSH
63918: CALL_OW 2
63922: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63923: LD_ADDR_VAR 0 4
63927: PUSH
63928: LD_VAR 0 4
63932: PUSH
63933: LD_VAR 0 9
63937: PUSH
63938: LD_VAR 0 3
63942: ARRAY
63943: DIFF
63944: ST_TO_ADDR
// end ;
63945: GO 63854
63947: POP
63948: POP
// if p then
63949: LD_VAR 0 11
63953: IFFALSE 63978
// result := Replace ( result , 2 , p ) ;
63955: LD_ADDR_VAR 0 2
63959: PUSH
63960: LD_VAR 0 2
63964: PPUSH
63965: LD_INT 2
63967: PPUSH
63968: LD_VAR 0 11
63972: PPUSH
63973: CALL_OW 1
63977: ST_TO_ADDR
// end ; exit ;
63978: GO 64702
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
63980: LD_EXP 88
63984: PUSH
63985: LD_EXP 87
63989: PUSH
63990: LD_VAR 0 1
63994: ARRAY
63995: ARRAY
63996: NOT
63997: PUSH
63998: LD_EXP 61
64002: PUSH
64003: LD_VAR 0 1
64007: ARRAY
64008: PPUSH
64009: LD_INT 30
64011: PUSH
64012: LD_INT 3
64014: PUSH
64015: EMPTY
64016: LIST
64017: LIST
64018: PPUSH
64019: CALL_OW 72
64023: AND
64024: PUSH
64025: LD_EXP 66
64029: PUSH
64030: LD_VAR 0 1
64034: ARRAY
64035: NOT
64036: AND
64037: IFFALSE 64702
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
64039: LD_ADDR_EXP 103
64043: PUSH
64044: LD_EXP 103
64048: PPUSH
64049: LD_VAR 0 1
64053: PPUSH
64054: LD_INT 6
64056: PPUSH
64057: CALL_OW 1
64061: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64062: LD_ADDR_VAR 0 2
64066: PUSH
64067: LD_INT 0
64069: PUSH
64070: LD_INT 0
64072: PUSH
64073: LD_INT 0
64075: PUSH
64076: LD_INT 0
64078: PUSH
64079: EMPTY
64080: LIST
64081: LIST
64082: LIST
64083: LIST
64084: ST_TO_ADDR
// if sci >= 1 then
64085: LD_VAR 0 8
64089: PUSH
64090: LD_INT 1
64092: GREATEREQUAL
64093: IFFALSE 64115
// tmp := tmp diff sci [ 1 ] ;
64095: LD_ADDR_VAR 0 4
64099: PUSH
64100: LD_VAR 0 4
64104: PUSH
64105: LD_VAR 0 8
64109: PUSH
64110: LD_INT 1
64112: ARRAY
64113: DIFF
64114: ST_TO_ADDR
// if tmp and not sci then
64115: LD_VAR 0 4
64119: PUSH
64120: LD_VAR 0 8
64124: NOT
64125: AND
64126: IFFALSE 64195
// begin sort := SortBySkill ( tmp , 4 ) ;
64128: LD_ADDR_VAR 0 9
64132: PUSH
64133: LD_VAR 0 4
64137: PPUSH
64138: LD_INT 4
64140: PPUSH
64141: CALL 50934 0 2
64145: ST_TO_ADDR
// if sort then
64146: LD_VAR 0 9
64150: IFFALSE 64166
// p := sort [ 1 ] ;
64152: LD_ADDR_VAR 0 11
64156: PUSH
64157: LD_VAR 0 9
64161: PUSH
64162: LD_INT 1
64164: ARRAY
64165: ST_TO_ADDR
// if p then
64166: LD_VAR 0 11
64170: IFFALSE 64195
// result := Replace ( result , 4 , p ) ;
64172: LD_ADDR_VAR 0 2
64176: PUSH
64177: LD_VAR 0 2
64181: PPUSH
64182: LD_INT 4
64184: PPUSH
64185: LD_VAR 0 11
64189: PPUSH
64190: CALL_OW 1
64194: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64195: LD_ADDR_VAR 0 4
64199: PUSH
64200: LD_VAR 0 4
64204: PUSH
64205: LD_VAR 0 7
64209: DIFF
64210: ST_TO_ADDR
// if tmp and mech < 6 then
64211: LD_VAR 0 4
64215: PUSH
64216: LD_VAR 0 7
64220: PUSH
64221: LD_INT 6
64223: LESS
64224: AND
64225: IFFALSE 64407
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
64227: LD_ADDR_VAR 0 9
64231: PUSH
64232: LD_VAR 0 4
64236: PUSH
64237: LD_VAR 0 7
64241: DIFF
64242: PPUSH
64243: LD_INT 3
64245: PPUSH
64246: CALL 50934 0 2
64250: ST_TO_ADDR
// p := [ ] ;
64251: LD_ADDR_VAR 0 11
64255: PUSH
64256: EMPTY
64257: ST_TO_ADDR
// if sort then
64258: LD_VAR 0 9
64262: IFFALSE 64378
// for i = 1 to 6 - mech do
64264: LD_ADDR_VAR 0 3
64268: PUSH
64269: DOUBLE
64270: LD_INT 1
64272: DEC
64273: ST_TO_ADDR
64274: LD_INT 6
64276: PUSH
64277: LD_VAR 0 7
64281: MINUS
64282: PUSH
64283: FOR_TO
64284: IFFALSE 64376
// begin if i = sort then
64286: LD_VAR 0 3
64290: PUSH
64291: LD_VAR 0 9
64295: EQUAL
64296: IFFALSE 64300
// break ;
64298: GO 64376
// if GetClass ( i ) = 3 then
64300: LD_VAR 0 3
64304: PPUSH
64305: CALL_OW 257
64309: PUSH
64310: LD_INT 3
64312: EQUAL
64313: IFFALSE 64317
// continue ;
64315: GO 64283
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64317: LD_ADDR_VAR 0 11
64321: PUSH
64322: LD_VAR 0 11
64326: PPUSH
64327: LD_VAR 0 11
64331: PUSH
64332: LD_INT 1
64334: PLUS
64335: PPUSH
64336: LD_VAR 0 9
64340: PUSH
64341: LD_VAR 0 3
64345: ARRAY
64346: PPUSH
64347: CALL_OW 2
64351: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64352: LD_ADDR_VAR 0 4
64356: PUSH
64357: LD_VAR 0 4
64361: PUSH
64362: LD_VAR 0 9
64366: PUSH
64367: LD_VAR 0 3
64371: ARRAY
64372: DIFF
64373: ST_TO_ADDR
// end ;
64374: GO 64283
64376: POP
64377: POP
// if p then
64378: LD_VAR 0 11
64382: IFFALSE 64407
// result := Replace ( result , 3 , p ) ;
64384: LD_ADDR_VAR 0 2
64388: PUSH
64389: LD_VAR 0 2
64393: PPUSH
64394: LD_INT 3
64396: PPUSH
64397: LD_VAR 0 11
64401: PPUSH
64402: CALL_OW 1
64406: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64407: LD_ADDR_VAR 0 4
64411: PUSH
64412: LD_VAR 0 4
64416: PUSH
64417: LD_VAR 0 6
64421: DIFF
64422: ST_TO_ADDR
// if tmp and eng < 4 then
64423: LD_VAR 0 4
64427: PUSH
64428: LD_VAR 0 6
64432: PUSH
64433: LD_INT 4
64435: LESS
64436: AND
64437: IFFALSE 64627
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
64439: LD_ADDR_VAR 0 9
64443: PUSH
64444: LD_VAR 0 4
64448: PUSH
64449: LD_VAR 0 7
64453: PUSH
64454: LD_VAR 0 6
64458: UNION
64459: DIFF
64460: PPUSH
64461: LD_INT 2
64463: PPUSH
64464: CALL 50934 0 2
64468: ST_TO_ADDR
// p := [ ] ;
64469: LD_ADDR_VAR 0 11
64473: PUSH
64474: EMPTY
64475: ST_TO_ADDR
// if sort then
64476: LD_VAR 0 9
64480: IFFALSE 64596
// for i = 1 to 4 - eng do
64482: LD_ADDR_VAR 0 3
64486: PUSH
64487: DOUBLE
64488: LD_INT 1
64490: DEC
64491: ST_TO_ADDR
64492: LD_INT 4
64494: PUSH
64495: LD_VAR 0 6
64499: MINUS
64500: PUSH
64501: FOR_TO
64502: IFFALSE 64594
// begin if i = sort then
64504: LD_VAR 0 3
64508: PUSH
64509: LD_VAR 0 9
64513: EQUAL
64514: IFFALSE 64518
// break ;
64516: GO 64594
// if GetClass ( i ) = 2 then
64518: LD_VAR 0 3
64522: PPUSH
64523: CALL_OW 257
64527: PUSH
64528: LD_INT 2
64530: EQUAL
64531: IFFALSE 64535
// continue ;
64533: GO 64501
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64535: LD_ADDR_VAR 0 11
64539: PUSH
64540: LD_VAR 0 11
64544: PPUSH
64545: LD_VAR 0 11
64549: PUSH
64550: LD_INT 1
64552: PLUS
64553: PPUSH
64554: LD_VAR 0 9
64558: PUSH
64559: LD_VAR 0 3
64563: ARRAY
64564: PPUSH
64565: CALL_OW 2
64569: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64570: LD_ADDR_VAR 0 4
64574: PUSH
64575: LD_VAR 0 4
64579: PUSH
64580: LD_VAR 0 9
64584: PUSH
64585: LD_VAR 0 3
64589: ARRAY
64590: DIFF
64591: ST_TO_ADDR
// end ;
64592: GO 64501
64594: POP
64595: POP
// if p then
64596: LD_VAR 0 11
64600: IFFALSE 64625
// result := Replace ( result , 2 , p ) ;
64602: LD_ADDR_VAR 0 2
64606: PUSH
64607: LD_VAR 0 2
64611: PPUSH
64612: LD_INT 2
64614: PPUSH
64615: LD_VAR 0 11
64619: PPUSH
64620: CALL_OW 1
64624: ST_TO_ADDR
// end else
64625: GO 64671
// for i = eng downto 5 do
64627: LD_ADDR_VAR 0 3
64631: PUSH
64632: DOUBLE
64633: LD_VAR 0 6
64637: INC
64638: ST_TO_ADDR
64639: LD_INT 5
64641: PUSH
64642: FOR_DOWNTO
64643: IFFALSE 64669
// tmp := tmp union eng [ i ] ;
64645: LD_ADDR_VAR 0 4
64649: PUSH
64650: LD_VAR 0 4
64654: PUSH
64655: LD_VAR 0 6
64659: PUSH
64660: LD_VAR 0 3
64664: ARRAY
64665: UNION
64666: ST_TO_ADDR
64667: GO 64642
64669: POP
64670: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
64671: LD_ADDR_VAR 0 2
64675: PUSH
64676: LD_VAR 0 2
64680: PPUSH
64681: LD_INT 1
64683: PPUSH
64684: LD_VAR 0 4
64688: PUSH
64689: LD_VAR 0 5
64693: DIFF
64694: PPUSH
64695: CALL_OW 1
64699: ST_TO_ADDR
// exit ;
64700: GO 64702
// end ; end ;
64702: LD_VAR 0 2
64706: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
64707: LD_INT 0
64709: PPUSH
64710: PPUSH
64711: PPUSH
// if not mc_bases then
64712: LD_EXP 61
64716: NOT
64717: IFFALSE 64721
// exit ;
64719: GO 64863
// for i = 1 to mc_bases do
64721: LD_ADDR_VAR 0 2
64725: PUSH
64726: DOUBLE
64727: LD_INT 1
64729: DEC
64730: ST_TO_ADDR
64731: LD_EXP 61
64735: PUSH
64736: FOR_TO
64737: IFFALSE 64854
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64739: LD_ADDR_VAR 0 3
64743: PUSH
64744: LD_EXP 61
64748: PUSH
64749: LD_VAR 0 2
64753: ARRAY
64754: PPUSH
64755: LD_INT 21
64757: PUSH
64758: LD_INT 3
64760: PUSH
64761: EMPTY
64762: LIST
64763: LIST
64764: PUSH
64765: LD_INT 3
64767: PUSH
64768: LD_INT 2
64770: PUSH
64771: LD_INT 30
64773: PUSH
64774: LD_INT 29
64776: PUSH
64777: EMPTY
64778: LIST
64779: LIST
64780: PUSH
64781: LD_INT 30
64783: PUSH
64784: LD_INT 30
64786: PUSH
64787: EMPTY
64788: LIST
64789: LIST
64790: PUSH
64791: EMPTY
64792: LIST
64793: LIST
64794: LIST
64795: PUSH
64796: EMPTY
64797: LIST
64798: LIST
64799: PUSH
64800: LD_INT 3
64802: PUSH
64803: LD_INT 24
64805: PUSH
64806: LD_INT 1000
64808: PUSH
64809: EMPTY
64810: LIST
64811: LIST
64812: PUSH
64813: EMPTY
64814: LIST
64815: LIST
64816: PUSH
64817: EMPTY
64818: LIST
64819: LIST
64820: LIST
64821: PPUSH
64822: CALL_OW 72
64826: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
64827: LD_ADDR_EXP 62
64831: PUSH
64832: LD_EXP 62
64836: PPUSH
64837: LD_VAR 0 2
64841: PPUSH
64842: LD_VAR 0 3
64846: PPUSH
64847: CALL_OW 1
64851: ST_TO_ADDR
// end ;
64852: GO 64736
64854: POP
64855: POP
// RaiseSailEvent ( 101 ) ;
64856: LD_INT 101
64858: PPUSH
64859: CALL_OW 427
// end ;
64863: LD_VAR 0 1
64867: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
64868: LD_INT 0
64870: PPUSH
64871: PPUSH
64872: PPUSH
64873: PPUSH
64874: PPUSH
64875: PPUSH
64876: PPUSH
// if not mc_bases then
64877: LD_EXP 61
64881: NOT
64882: IFFALSE 64886
// exit ;
64884: GO 65448
// for i = 1 to mc_bases do
64886: LD_ADDR_VAR 0 2
64890: PUSH
64891: DOUBLE
64892: LD_INT 1
64894: DEC
64895: ST_TO_ADDR
64896: LD_EXP 61
64900: PUSH
64901: FOR_TO
64902: IFFALSE 65439
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
64904: LD_ADDR_VAR 0 5
64908: PUSH
64909: LD_EXP 61
64913: PUSH
64914: LD_VAR 0 2
64918: ARRAY
64919: PUSH
64920: LD_EXP 90
64924: PUSH
64925: LD_VAR 0 2
64929: ARRAY
64930: UNION
64931: PPUSH
64932: LD_INT 21
64934: PUSH
64935: LD_INT 1
64937: PUSH
64938: EMPTY
64939: LIST
64940: LIST
64941: PUSH
64942: LD_INT 1
64944: PUSH
64945: LD_INT 3
64947: PUSH
64948: LD_INT 54
64950: PUSH
64951: EMPTY
64952: LIST
64953: PUSH
64954: EMPTY
64955: LIST
64956: LIST
64957: PUSH
64958: LD_INT 3
64960: PUSH
64961: LD_INT 24
64963: PUSH
64964: LD_INT 1000
64966: PUSH
64967: EMPTY
64968: LIST
64969: LIST
64970: PUSH
64971: EMPTY
64972: LIST
64973: LIST
64974: PUSH
64975: EMPTY
64976: LIST
64977: LIST
64978: LIST
64979: PUSH
64980: EMPTY
64981: LIST
64982: LIST
64983: PPUSH
64984: CALL_OW 72
64988: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
64989: LD_ADDR_VAR 0 6
64993: PUSH
64994: LD_EXP 61
64998: PUSH
64999: LD_VAR 0 2
65003: ARRAY
65004: PPUSH
65005: LD_INT 21
65007: PUSH
65008: LD_INT 1
65010: PUSH
65011: EMPTY
65012: LIST
65013: LIST
65014: PUSH
65015: LD_INT 1
65017: PUSH
65018: LD_INT 3
65020: PUSH
65021: LD_INT 54
65023: PUSH
65024: EMPTY
65025: LIST
65026: PUSH
65027: EMPTY
65028: LIST
65029: LIST
65030: PUSH
65031: LD_INT 3
65033: PUSH
65034: LD_INT 24
65036: PUSH
65037: LD_INT 250
65039: PUSH
65040: EMPTY
65041: LIST
65042: LIST
65043: PUSH
65044: EMPTY
65045: LIST
65046: LIST
65047: PUSH
65048: EMPTY
65049: LIST
65050: LIST
65051: LIST
65052: PUSH
65053: EMPTY
65054: LIST
65055: LIST
65056: PPUSH
65057: CALL_OW 72
65061: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
65062: LD_ADDR_VAR 0 7
65066: PUSH
65067: LD_VAR 0 5
65071: PUSH
65072: LD_VAR 0 6
65076: DIFF
65077: ST_TO_ADDR
// if not need_heal_1 then
65078: LD_VAR 0 6
65082: NOT
65083: IFFALSE 65116
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
65085: LD_ADDR_EXP 64
65089: PUSH
65090: LD_EXP 64
65094: PPUSH
65095: LD_VAR 0 2
65099: PUSH
65100: LD_INT 1
65102: PUSH
65103: EMPTY
65104: LIST
65105: LIST
65106: PPUSH
65107: EMPTY
65108: PPUSH
65109: CALL 20087 0 3
65113: ST_TO_ADDR
65114: GO 65186
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
65116: LD_ADDR_EXP 64
65120: PUSH
65121: LD_EXP 64
65125: PPUSH
65126: LD_VAR 0 2
65130: PUSH
65131: LD_INT 1
65133: PUSH
65134: EMPTY
65135: LIST
65136: LIST
65137: PPUSH
65138: LD_EXP 64
65142: PUSH
65143: LD_VAR 0 2
65147: ARRAY
65148: PUSH
65149: LD_INT 1
65151: ARRAY
65152: PPUSH
65153: LD_INT 3
65155: PUSH
65156: LD_INT 24
65158: PUSH
65159: LD_INT 1000
65161: PUSH
65162: EMPTY
65163: LIST
65164: LIST
65165: PUSH
65166: EMPTY
65167: LIST
65168: LIST
65169: PPUSH
65170: CALL_OW 72
65174: PUSH
65175: LD_VAR 0 6
65179: UNION
65180: PPUSH
65181: CALL 20087 0 3
65185: ST_TO_ADDR
// if not need_heal_2 then
65186: LD_VAR 0 7
65190: NOT
65191: IFFALSE 65224
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
65193: LD_ADDR_EXP 64
65197: PUSH
65198: LD_EXP 64
65202: PPUSH
65203: LD_VAR 0 2
65207: PUSH
65208: LD_INT 2
65210: PUSH
65211: EMPTY
65212: LIST
65213: LIST
65214: PPUSH
65215: EMPTY
65216: PPUSH
65217: CALL 20087 0 3
65221: ST_TO_ADDR
65222: GO 65256
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
65224: LD_ADDR_EXP 64
65228: PUSH
65229: LD_EXP 64
65233: PPUSH
65234: LD_VAR 0 2
65238: PUSH
65239: LD_INT 2
65241: PUSH
65242: EMPTY
65243: LIST
65244: LIST
65245: PPUSH
65246: LD_VAR 0 7
65250: PPUSH
65251: CALL 20087 0 3
65255: ST_TO_ADDR
// if need_heal_2 then
65256: LD_VAR 0 7
65260: IFFALSE 65421
// for j in need_heal_2 do
65262: LD_ADDR_VAR 0 3
65266: PUSH
65267: LD_VAR 0 7
65271: PUSH
65272: FOR_IN
65273: IFFALSE 65419
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65275: LD_ADDR_VAR 0 5
65279: PUSH
65280: LD_EXP 61
65284: PUSH
65285: LD_VAR 0 2
65289: ARRAY
65290: PPUSH
65291: LD_INT 2
65293: PUSH
65294: LD_INT 30
65296: PUSH
65297: LD_INT 6
65299: PUSH
65300: EMPTY
65301: LIST
65302: LIST
65303: PUSH
65304: LD_INT 30
65306: PUSH
65307: LD_INT 7
65309: PUSH
65310: EMPTY
65311: LIST
65312: LIST
65313: PUSH
65314: LD_INT 30
65316: PUSH
65317: LD_INT 8
65319: PUSH
65320: EMPTY
65321: LIST
65322: LIST
65323: PUSH
65324: LD_INT 30
65326: PUSH
65327: LD_INT 0
65329: PUSH
65330: EMPTY
65331: LIST
65332: LIST
65333: PUSH
65334: LD_INT 30
65336: PUSH
65337: LD_INT 1
65339: PUSH
65340: EMPTY
65341: LIST
65342: LIST
65343: PUSH
65344: EMPTY
65345: LIST
65346: LIST
65347: LIST
65348: LIST
65349: LIST
65350: LIST
65351: PPUSH
65352: CALL_OW 72
65356: ST_TO_ADDR
// if tmp then
65357: LD_VAR 0 5
65361: IFFALSE 65417
// begin k := NearestUnitToUnit ( tmp , j ) ;
65363: LD_ADDR_VAR 0 4
65367: PUSH
65368: LD_VAR 0 5
65372: PPUSH
65373: LD_VAR 0 3
65377: PPUSH
65378: CALL_OW 74
65382: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
65383: LD_VAR 0 3
65387: PPUSH
65388: LD_VAR 0 4
65392: PPUSH
65393: CALL_OW 296
65397: PUSH
65398: LD_INT 5
65400: GREATER
65401: IFFALSE 65417
// ComMoveToNearbyEntrance ( j , k ) ;
65403: LD_VAR 0 3
65407: PPUSH
65408: LD_VAR 0 4
65412: PPUSH
65413: CALL 53295 0 2
// end ; end ;
65417: GO 65272
65419: POP
65420: POP
// if not need_heal_1 and not need_heal_2 then
65421: LD_VAR 0 6
65425: NOT
65426: PUSH
65427: LD_VAR 0 7
65431: NOT
65432: AND
65433: IFFALSE 65437
// continue ;
65435: GO 64901
// end ;
65437: GO 64901
65439: POP
65440: POP
// RaiseSailEvent ( 102 ) ;
65441: LD_INT 102
65443: PPUSH
65444: CALL_OW 427
// end ;
65448: LD_VAR 0 1
65452: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
65453: LD_INT 0
65455: PPUSH
65456: PPUSH
65457: PPUSH
65458: PPUSH
65459: PPUSH
65460: PPUSH
65461: PPUSH
65462: PPUSH
// if not mc_bases then
65463: LD_EXP 61
65467: NOT
65468: IFFALSE 65472
// exit ;
65470: GO 66383
// for i = 1 to mc_bases do
65472: LD_ADDR_VAR 0 2
65476: PUSH
65477: DOUBLE
65478: LD_INT 1
65480: DEC
65481: ST_TO_ADDR
65482: LD_EXP 61
65486: PUSH
65487: FOR_TO
65488: IFFALSE 66381
// begin if not mc_building_need_repair [ i ] then
65490: LD_EXP 62
65494: PUSH
65495: LD_VAR 0 2
65499: ARRAY
65500: NOT
65501: IFFALSE 65686
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
65503: LD_ADDR_VAR 0 6
65507: PUSH
65508: LD_EXP 80
65512: PUSH
65513: LD_VAR 0 2
65517: ARRAY
65518: PPUSH
65519: LD_INT 3
65521: PUSH
65522: LD_INT 24
65524: PUSH
65525: LD_INT 1000
65527: PUSH
65528: EMPTY
65529: LIST
65530: LIST
65531: PUSH
65532: EMPTY
65533: LIST
65534: LIST
65535: PUSH
65536: LD_INT 2
65538: PUSH
65539: LD_INT 34
65541: PUSH
65542: LD_INT 13
65544: PUSH
65545: EMPTY
65546: LIST
65547: LIST
65548: PUSH
65549: LD_INT 34
65551: PUSH
65552: LD_INT 52
65554: PUSH
65555: EMPTY
65556: LIST
65557: LIST
65558: PUSH
65559: LD_INT 34
65561: PUSH
65562: LD_INT 88
65564: PUSH
65565: EMPTY
65566: LIST
65567: LIST
65568: PUSH
65569: EMPTY
65570: LIST
65571: LIST
65572: LIST
65573: LIST
65574: PUSH
65575: EMPTY
65576: LIST
65577: LIST
65578: PPUSH
65579: CALL_OW 72
65583: ST_TO_ADDR
// if cranes then
65584: LD_VAR 0 6
65588: IFFALSE 65650
// for j in cranes do
65590: LD_ADDR_VAR 0 3
65594: PUSH
65595: LD_VAR 0 6
65599: PUSH
65600: FOR_IN
65601: IFFALSE 65648
// if not IsInArea ( j , mc_parking [ i ] ) then
65603: LD_VAR 0 3
65607: PPUSH
65608: LD_EXP 85
65612: PUSH
65613: LD_VAR 0 2
65617: ARRAY
65618: PPUSH
65619: CALL_OW 308
65623: NOT
65624: IFFALSE 65646
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65626: LD_VAR 0 3
65630: PPUSH
65631: LD_EXP 85
65635: PUSH
65636: LD_VAR 0 2
65640: ARRAY
65641: PPUSH
65642: CALL_OW 113
65646: GO 65600
65648: POP
65649: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
65650: LD_ADDR_EXP 63
65654: PUSH
65655: LD_EXP 63
65659: PPUSH
65660: LD_VAR 0 2
65664: PPUSH
65665: EMPTY
65666: PPUSH
65667: CALL_OW 1
65671: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
65672: LD_VAR 0 2
65676: PPUSH
65677: LD_INT 101
65679: PPUSH
65680: CALL 60540 0 2
// continue ;
65684: GO 65487
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
65686: LD_ADDR_EXP 67
65690: PUSH
65691: LD_EXP 67
65695: PPUSH
65696: LD_VAR 0 2
65700: PPUSH
65701: EMPTY
65702: PPUSH
65703: CALL_OW 1
65707: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65708: LD_VAR 0 2
65712: PPUSH
65713: LD_INT 103
65715: PPUSH
65716: CALL 60540 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
65720: LD_ADDR_VAR 0 5
65724: PUSH
65725: LD_EXP 61
65729: PUSH
65730: LD_VAR 0 2
65734: ARRAY
65735: PUSH
65736: LD_EXP 90
65740: PUSH
65741: LD_VAR 0 2
65745: ARRAY
65746: UNION
65747: PPUSH
65748: LD_INT 2
65750: PUSH
65751: LD_INT 25
65753: PUSH
65754: LD_INT 2
65756: PUSH
65757: EMPTY
65758: LIST
65759: LIST
65760: PUSH
65761: LD_INT 25
65763: PUSH
65764: LD_INT 16
65766: PUSH
65767: EMPTY
65768: LIST
65769: LIST
65770: PUSH
65771: EMPTY
65772: LIST
65773: LIST
65774: LIST
65775: PUSH
65776: EMPTY
65777: LIST
65778: PPUSH
65779: CALL_OW 72
65783: ST_TO_ADDR
// if mc_need_heal [ i ] then
65784: LD_EXP 64
65788: PUSH
65789: LD_VAR 0 2
65793: ARRAY
65794: IFFALSE 65838
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
65796: LD_ADDR_VAR 0 5
65800: PUSH
65801: LD_VAR 0 5
65805: PUSH
65806: LD_EXP 64
65810: PUSH
65811: LD_VAR 0 2
65815: ARRAY
65816: PUSH
65817: LD_INT 1
65819: ARRAY
65820: PUSH
65821: LD_EXP 64
65825: PUSH
65826: LD_VAR 0 2
65830: ARRAY
65831: PUSH
65832: LD_INT 2
65834: ARRAY
65835: UNION
65836: DIFF
65837: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
65838: LD_ADDR_VAR 0 6
65842: PUSH
65843: LD_EXP 80
65847: PUSH
65848: LD_VAR 0 2
65852: ARRAY
65853: PPUSH
65854: LD_INT 2
65856: PUSH
65857: LD_INT 34
65859: PUSH
65860: LD_INT 13
65862: PUSH
65863: EMPTY
65864: LIST
65865: LIST
65866: PUSH
65867: LD_INT 34
65869: PUSH
65870: LD_INT 52
65872: PUSH
65873: EMPTY
65874: LIST
65875: LIST
65876: PUSH
65877: LD_INT 34
65879: PUSH
65880: LD_INT 88
65882: PUSH
65883: EMPTY
65884: LIST
65885: LIST
65886: PUSH
65887: EMPTY
65888: LIST
65889: LIST
65890: LIST
65891: LIST
65892: PPUSH
65893: CALL_OW 72
65897: ST_TO_ADDR
// if cranes then
65898: LD_VAR 0 6
65902: IFFALSE 66070
// begin for j in cranes do
65904: LD_ADDR_VAR 0 3
65908: PUSH
65909: LD_VAR 0 6
65913: PUSH
65914: FOR_IN
65915: IFFALSE 66068
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
65917: LD_VAR 0 3
65921: PPUSH
65922: CALL_OW 256
65926: PUSH
65927: LD_INT 1000
65929: EQUAL
65930: PUSH
65931: LD_VAR 0 3
65935: PPUSH
65936: CALL_OW 314
65940: NOT
65941: AND
65942: IFFALSE 66008
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
65944: LD_ADDR_VAR 0 8
65948: PUSH
65949: LD_EXP 62
65953: PUSH
65954: LD_VAR 0 2
65958: ARRAY
65959: PPUSH
65960: LD_VAR 0 3
65964: PPUSH
65965: CALL_OW 74
65969: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
65970: LD_VAR 0 8
65974: PPUSH
65975: LD_INT 16
65977: PPUSH
65978: CALL 22684 0 2
65982: PUSH
65983: LD_INT 4
65985: ARRAY
65986: PUSH
65987: LD_INT 10
65989: LESS
65990: IFFALSE 66006
// ComRepairBuilding ( j , to_repair ) ;
65992: LD_VAR 0 3
65996: PPUSH
65997: LD_VAR 0 8
66001: PPUSH
66002: CALL_OW 130
// end else
66006: GO 66066
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
66008: LD_VAR 0 3
66012: PPUSH
66013: CALL_OW 256
66017: PUSH
66018: LD_INT 500
66020: LESS
66021: PUSH
66022: LD_VAR 0 3
66026: PPUSH
66027: LD_EXP 85
66031: PUSH
66032: LD_VAR 0 2
66036: ARRAY
66037: PPUSH
66038: CALL_OW 308
66042: NOT
66043: AND
66044: IFFALSE 66066
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66046: LD_VAR 0 3
66050: PPUSH
66051: LD_EXP 85
66055: PUSH
66056: LD_VAR 0 2
66060: ARRAY
66061: PPUSH
66062: CALL_OW 113
// end ;
66066: GO 65914
66068: POP
66069: POP
// end ; if tmp > 3 then
66070: LD_VAR 0 5
66074: PUSH
66075: LD_INT 3
66077: GREATER
66078: IFFALSE 66098
// tmp := ShrinkArray ( tmp , 4 ) ;
66080: LD_ADDR_VAR 0 5
66084: PUSH
66085: LD_VAR 0 5
66089: PPUSH
66090: LD_INT 4
66092: PPUSH
66093: CALL 52733 0 2
66097: ST_TO_ADDR
// if not tmp then
66098: LD_VAR 0 5
66102: NOT
66103: IFFALSE 66107
// continue ;
66105: GO 65487
// for j in tmp do
66107: LD_ADDR_VAR 0 3
66111: PUSH
66112: LD_VAR 0 5
66116: PUSH
66117: FOR_IN
66118: IFFALSE 66377
// begin if IsInUnit ( j ) then
66120: LD_VAR 0 3
66124: PPUSH
66125: CALL_OW 310
66129: IFFALSE 66140
// ComExitBuilding ( j ) ;
66131: LD_VAR 0 3
66135: PPUSH
66136: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
66140: LD_VAR 0 3
66144: PUSH
66145: LD_EXP 63
66149: PUSH
66150: LD_VAR 0 2
66154: ARRAY
66155: IN
66156: NOT
66157: IFFALSE 66215
// begin SetTag ( j , 101 ) ;
66159: LD_VAR 0 3
66163: PPUSH
66164: LD_INT 101
66166: PPUSH
66167: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
66171: LD_ADDR_EXP 63
66175: PUSH
66176: LD_EXP 63
66180: PPUSH
66181: LD_VAR 0 2
66185: PUSH
66186: LD_EXP 63
66190: PUSH
66191: LD_VAR 0 2
66195: ARRAY
66196: PUSH
66197: LD_INT 1
66199: PLUS
66200: PUSH
66201: EMPTY
66202: LIST
66203: LIST
66204: PPUSH
66205: LD_VAR 0 3
66209: PPUSH
66210: CALL 20087 0 3
66214: ST_TO_ADDR
// end ; wait ( 1 ) ;
66215: LD_INT 1
66217: PPUSH
66218: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
66222: LD_ADDR_VAR 0 7
66226: PUSH
66227: LD_EXP 62
66231: PUSH
66232: LD_VAR 0 2
66236: ARRAY
66237: ST_TO_ADDR
// if mc_scan [ i ] then
66238: LD_EXP 84
66242: PUSH
66243: LD_VAR 0 2
66247: ARRAY
66248: IFFALSE 66310
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
66250: LD_ADDR_VAR 0 7
66254: PUSH
66255: LD_EXP 62
66259: PUSH
66260: LD_VAR 0 2
66264: ARRAY
66265: PPUSH
66266: LD_INT 3
66268: PUSH
66269: LD_INT 30
66271: PUSH
66272: LD_INT 32
66274: PUSH
66275: EMPTY
66276: LIST
66277: LIST
66278: PUSH
66279: LD_INT 30
66281: PUSH
66282: LD_INT 33
66284: PUSH
66285: EMPTY
66286: LIST
66287: LIST
66288: PUSH
66289: LD_INT 30
66291: PUSH
66292: LD_INT 31
66294: PUSH
66295: EMPTY
66296: LIST
66297: LIST
66298: PUSH
66299: EMPTY
66300: LIST
66301: LIST
66302: LIST
66303: LIST
66304: PPUSH
66305: CALL_OW 72
66309: ST_TO_ADDR
// if not to_repair_tmp then
66310: LD_VAR 0 7
66314: NOT
66315: IFFALSE 66319
// continue ;
66317: GO 66117
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
66319: LD_ADDR_VAR 0 8
66323: PUSH
66324: LD_VAR 0 7
66328: PPUSH
66329: LD_VAR 0 3
66333: PPUSH
66334: CALL_OW 74
66338: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
66339: LD_VAR 0 8
66343: PPUSH
66344: LD_INT 16
66346: PPUSH
66347: CALL 22684 0 2
66351: PUSH
66352: LD_INT 4
66354: ARRAY
66355: PUSH
66356: LD_INT 14
66358: LESS
66359: IFFALSE 66375
// ComRepairBuilding ( j , to_repair ) ;
66361: LD_VAR 0 3
66365: PPUSH
66366: LD_VAR 0 8
66370: PPUSH
66371: CALL_OW 130
// end ;
66375: GO 66117
66377: POP
66378: POP
// end ;
66379: GO 65487
66381: POP
66382: POP
// end ;
66383: LD_VAR 0 1
66387: RET
// export function MC_Heal ; var i , j , tmp ; begin
66388: LD_INT 0
66390: PPUSH
66391: PPUSH
66392: PPUSH
66393: PPUSH
// if not mc_bases then
66394: LD_EXP 61
66398: NOT
66399: IFFALSE 66403
// exit ;
66401: GO 66805
// for i = 1 to mc_bases do
66403: LD_ADDR_VAR 0 2
66407: PUSH
66408: DOUBLE
66409: LD_INT 1
66411: DEC
66412: ST_TO_ADDR
66413: LD_EXP 61
66417: PUSH
66418: FOR_TO
66419: IFFALSE 66803
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
66421: LD_EXP 64
66425: PUSH
66426: LD_VAR 0 2
66430: ARRAY
66431: PUSH
66432: LD_INT 1
66434: ARRAY
66435: NOT
66436: PUSH
66437: LD_EXP 64
66441: PUSH
66442: LD_VAR 0 2
66446: ARRAY
66447: PUSH
66448: LD_INT 2
66450: ARRAY
66451: NOT
66452: AND
66453: IFFALSE 66491
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
66455: LD_ADDR_EXP 65
66459: PUSH
66460: LD_EXP 65
66464: PPUSH
66465: LD_VAR 0 2
66469: PPUSH
66470: EMPTY
66471: PPUSH
66472: CALL_OW 1
66476: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
66477: LD_VAR 0 2
66481: PPUSH
66482: LD_INT 102
66484: PPUSH
66485: CALL 60540 0 2
// continue ;
66489: GO 66418
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
66491: LD_ADDR_VAR 0 4
66495: PUSH
66496: LD_EXP 61
66500: PUSH
66501: LD_VAR 0 2
66505: ARRAY
66506: PPUSH
66507: LD_INT 25
66509: PUSH
66510: LD_INT 4
66512: PUSH
66513: EMPTY
66514: LIST
66515: LIST
66516: PPUSH
66517: CALL_OW 72
66521: ST_TO_ADDR
// if not tmp then
66522: LD_VAR 0 4
66526: NOT
66527: IFFALSE 66531
// continue ;
66529: GO 66418
// if mc_taming [ i ] then
66531: LD_EXP 92
66535: PUSH
66536: LD_VAR 0 2
66540: ARRAY
66541: IFFALSE 66565
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
66543: LD_ADDR_EXP 92
66547: PUSH
66548: LD_EXP 92
66552: PPUSH
66553: LD_VAR 0 2
66557: PPUSH
66558: EMPTY
66559: PPUSH
66560: CALL_OW 1
66564: ST_TO_ADDR
// for j in tmp do
66565: LD_ADDR_VAR 0 3
66569: PUSH
66570: LD_VAR 0 4
66574: PUSH
66575: FOR_IN
66576: IFFALSE 66799
// begin if IsInUnit ( j ) then
66578: LD_VAR 0 3
66582: PPUSH
66583: CALL_OW 310
66587: IFFALSE 66598
// ComExitBuilding ( j ) ;
66589: LD_VAR 0 3
66593: PPUSH
66594: CALL_OW 122
// if not j in mc_healers [ i ] then
66598: LD_VAR 0 3
66602: PUSH
66603: LD_EXP 65
66607: PUSH
66608: LD_VAR 0 2
66612: ARRAY
66613: IN
66614: NOT
66615: IFFALSE 66661
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
66617: LD_ADDR_EXP 65
66621: PUSH
66622: LD_EXP 65
66626: PPUSH
66627: LD_VAR 0 2
66631: PUSH
66632: LD_EXP 65
66636: PUSH
66637: LD_VAR 0 2
66641: ARRAY
66642: PUSH
66643: LD_INT 1
66645: PLUS
66646: PUSH
66647: EMPTY
66648: LIST
66649: LIST
66650: PPUSH
66651: LD_VAR 0 3
66655: PPUSH
66656: CALL 20087 0 3
66660: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
66661: LD_VAR 0 3
66665: PPUSH
66666: CALL_OW 110
66670: PUSH
66671: LD_INT 102
66673: NONEQUAL
66674: IFFALSE 66688
// SetTag ( j , 102 ) ;
66676: LD_VAR 0 3
66680: PPUSH
66681: LD_INT 102
66683: PPUSH
66684: CALL_OW 109
// Wait ( 3 ) ;
66688: LD_INT 3
66690: PPUSH
66691: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
66695: LD_EXP 64
66699: PUSH
66700: LD_VAR 0 2
66704: ARRAY
66705: PUSH
66706: LD_INT 1
66708: ARRAY
66709: IFFALSE 66741
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
66711: LD_VAR 0 3
66715: PPUSH
66716: LD_EXP 64
66720: PUSH
66721: LD_VAR 0 2
66725: ARRAY
66726: PUSH
66727: LD_INT 1
66729: ARRAY
66730: PUSH
66731: LD_INT 1
66733: ARRAY
66734: PPUSH
66735: CALL_OW 128
66739: GO 66797
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
66741: LD_VAR 0 3
66745: PPUSH
66746: CALL_OW 314
66750: NOT
66751: PUSH
66752: LD_EXP 64
66756: PUSH
66757: LD_VAR 0 2
66761: ARRAY
66762: PUSH
66763: LD_INT 2
66765: ARRAY
66766: AND
66767: IFFALSE 66797
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
66769: LD_VAR 0 3
66773: PPUSH
66774: LD_EXP 64
66778: PUSH
66779: LD_VAR 0 2
66783: ARRAY
66784: PUSH
66785: LD_INT 2
66787: ARRAY
66788: PUSH
66789: LD_INT 1
66791: ARRAY
66792: PPUSH
66793: CALL_OW 128
// end ;
66797: GO 66575
66799: POP
66800: POP
// end ;
66801: GO 66418
66803: POP
66804: POP
// end ;
66805: LD_VAR 0 1
66809: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
66810: LD_INT 0
66812: PPUSH
66813: PPUSH
66814: PPUSH
66815: PPUSH
66816: PPUSH
66817: PPUSH
// if not mc_bases then
66818: LD_EXP 61
66822: NOT
66823: IFFALSE 66827
// exit ;
66825: GO 67990
// for i = 1 to mc_bases do
66827: LD_ADDR_VAR 0 2
66831: PUSH
66832: DOUBLE
66833: LD_INT 1
66835: DEC
66836: ST_TO_ADDR
66837: LD_EXP 61
66841: PUSH
66842: FOR_TO
66843: IFFALSE 67988
// begin if mc_scan [ i ] then
66845: LD_EXP 84
66849: PUSH
66850: LD_VAR 0 2
66854: ARRAY
66855: IFFALSE 66859
// continue ;
66857: GO 66842
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
66859: LD_EXP 66
66863: PUSH
66864: LD_VAR 0 2
66868: ARRAY
66869: NOT
66870: PUSH
66871: LD_EXP 68
66875: PUSH
66876: LD_VAR 0 2
66880: ARRAY
66881: NOT
66882: AND
66883: PUSH
66884: LD_EXP 67
66888: PUSH
66889: LD_VAR 0 2
66893: ARRAY
66894: AND
66895: IFFALSE 66933
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
66897: LD_ADDR_EXP 67
66901: PUSH
66902: LD_EXP 67
66906: PPUSH
66907: LD_VAR 0 2
66911: PPUSH
66912: EMPTY
66913: PPUSH
66914: CALL_OW 1
66918: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66919: LD_VAR 0 2
66923: PPUSH
66924: LD_INT 103
66926: PPUSH
66927: CALL 60540 0 2
// continue ;
66931: GO 66842
// end ; if mc_construct_list [ i ] then
66933: LD_EXP 68
66937: PUSH
66938: LD_VAR 0 2
66942: ARRAY
66943: IFFALSE 67163
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
66945: LD_ADDR_VAR 0 5
66949: PUSH
66950: LD_EXP 61
66954: PUSH
66955: LD_VAR 0 2
66959: ARRAY
66960: PPUSH
66961: LD_INT 25
66963: PUSH
66964: LD_INT 2
66966: PUSH
66967: EMPTY
66968: LIST
66969: LIST
66970: PPUSH
66971: CALL_OW 72
66975: PUSH
66976: LD_EXP 63
66980: PUSH
66981: LD_VAR 0 2
66985: ARRAY
66986: DIFF
66987: ST_TO_ADDR
// if not tmp then
66988: LD_VAR 0 5
66992: NOT
66993: IFFALSE 66997
// continue ;
66995: GO 66842
// for j in tmp do
66997: LD_ADDR_VAR 0 3
67001: PUSH
67002: LD_VAR 0 5
67006: PUSH
67007: FOR_IN
67008: IFFALSE 67159
// begin if not mc_builders [ i ] then
67010: LD_EXP 67
67014: PUSH
67015: LD_VAR 0 2
67019: ARRAY
67020: NOT
67021: IFFALSE 67079
// begin SetTag ( j , 103 ) ;
67023: LD_VAR 0 3
67027: PPUSH
67028: LD_INT 103
67030: PPUSH
67031: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67035: LD_ADDR_EXP 67
67039: PUSH
67040: LD_EXP 67
67044: PPUSH
67045: LD_VAR 0 2
67049: PUSH
67050: LD_EXP 67
67054: PUSH
67055: LD_VAR 0 2
67059: ARRAY
67060: PUSH
67061: LD_INT 1
67063: PLUS
67064: PUSH
67065: EMPTY
67066: LIST
67067: LIST
67068: PPUSH
67069: LD_VAR 0 3
67073: PPUSH
67074: CALL 20087 0 3
67078: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67079: LD_VAR 0 3
67083: PPUSH
67084: CALL_OW 310
67088: IFFALSE 67099
// ComExitBuilding ( j ) ;
67090: LD_VAR 0 3
67094: PPUSH
67095: CALL_OW 122
// wait ( 3 ) ;
67099: LD_INT 3
67101: PPUSH
67102: CALL_OW 67
// if not mc_construct_list [ i ] then
67106: LD_EXP 68
67110: PUSH
67111: LD_VAR 0 2
67115: ARRAY
67116: NOT
67117: IFFALSE 67121
// break ;
67119: GO 67159
// if not HasTask ( j ) then
67121: LD_VAR 0 3
67125: PPUSH
67126: CALL_OW 314
67130: NOT
67131: IFFALSE 67157
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
67133: LD_VAR 0 3
67137: PPUSH
67138: LD_EXP 68
67142: PUSH
67143: LD_VAR 0 2
67147: ARRAY
67148: PUSH
67149: LD_INT 1
67151: ARRAY
67152: PPUSH
67153: CALL 22948 0 2
// end ;
67157: GO 67007
67159: POP
67160: POP
// end else
67161: GO 67986
// if mc_build_list [ i ] then
67163: LD_EXP 66
67167: PUSH
67168: LD_VAR 0 2
67172: ARRAY
67173: IFFALSE 67986
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
67175: LD_EXP 66
67179: PUSH
67180: LD_VAR 0 2
67184: ARRAY
67185: PUSH
67186: LD_INT 1
67188: ARRAY
67189: PUSH
67190: LD_INT 1
67192: ARRAY
67193: PPUSH
67194: CALL 22772 0 1
67198: PUSH
67199: LD_EXP 61
67203: PUSH
67204: LD_VAR 0 2
67208: ARRAY
67209: PPUSH
67210: LD_INT 2
67212: PUSH
67213: LD_INT 30
67215: PUSH
67216: LD_INT 2
67218: PUSH
67219: EMPTY
67220: LIST
67221: LIST
67222: PUSH
67223: LD_INT 30
67225: PUSH
67226: LD_INT 3
67228: PUSH
67229: EMPTY
67230: LIST
67231: LIST
67232: PUSH
67233: EMPTY
67234: LIST
67235: LIST
67236: LIST
67237: PPUSH
67238: CALL_OW 72
67242: NOT
67243: AND
67244: IFFALSE 67349
// begin for j = 1 to mc_build_list [ i ] do
67246: LD_ADDR_VAR 0 3
67250: PUSH
67251: DOUBLE
67252: LD_INT 1
67254: DEC
67255: ST_TO_ADDR
67256: LD_EXP 66
67260: PUSH
67261: LD_VAR 0 2
67265: ARRAY
67266: PUSH
67267: FOR_TO
67268: IFFALSE 67347
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
67270: LD_EXP 66
67274: PUSH
67275: LD_VAR 0 2
67279: ARRAY
67280: PUSH
67281: LD_VAR 0 3
67285: ARRAY
67286: PUSH
67287: LD_INT 1
67289: ARRAY
67290: PUSH
67291: LD_INT 2
67293: EQUAL
67294: IFFALSE 67345
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
67296: LD_ADDR_EXP 66
67300: PUSH
67301: LD_EXP 66
67305: PPUSH
67306: LD_VAR 0 2
67310: PPUSH
67311: LD_EXP 66
67315: PUSH
67316: LD_VAR 0 2
67320: ARRAY
67321: PPUSH
67322: LD_VAR 0 3
67326: PPUSH
67327: LD_INT 1
67329: PPUSH
67330: LD_INT 0
67332: PPUSH
67333: CALL 19505 0 4
67337: PPUSH
67338: CALL_OW 1
67342: ST_TO_ADDR
// break ;
67343: GO 67347
// end ;
67345: GO 67267
67347: POP
67348: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67349: LD_ADDR_VAR 0 6
67353: PUSH
67354: LD_EXP 61
67358: PUSH
67359: LD_VAR 0 2
67363: ARRAY
67364: PPUSH
67365: LD_INT 2
67367: PUSH
67368: LD_INT 30
67370: PUSH
67371: LD_INT 0
67373: PUSH
67374: EMPTY
67375: LIST
67376: LIST
67377: PUSH
67378: LD_INT 30
67380: PUSH
67381: LD_INT 1
67383: PUSH
67384: EMPTY
67385: LIST
67386: LIST
67387: PUSH
67388: EMPTY
67389: LIST
67390: LIST
67391: LIST
67392: PPUSH
67393: CALL_OW 72
67397: ST_TO_ADDR
// for k := 1 to depot do
67398: LD_ADDR_VAR 0 4
67402: PUSH
67403: DOUBLE
67404: LD_INT 1
67406: DEC
67407: ST_TO_ADDR
67408: LD_VAR 0 6
67412: PUSH
67413: FOR_TO
67414: IFFALSE 67984
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
67416: LD_EXP 66
67420: PUSH
67421: LD_VAR 0 2
67425: ARRAY
67426: PUSH
67427: LD_INT 1
67429: ARRAY
67430: PUSH
67431: LD_INT 1
67433: ARRAY
67434: PUSH
67435: LD_INT 0
67437: EQUAL
67438: PUSH
67439: LD_VAR 0 6
67443: PUSH
67444: LD_VAR 0 4
67448: ARRAY
67449: PPUSH
67450: LD_EXP 66
67454: PUSH
67455: LD_VAR 0 2
67459: ARRAY
67460: PUSH
67461: LD_INT 1
67463: ARRAY
67464: PUSH
67465: LD_INT 1
67467: ARRAY
67468: PPUSH
67469: LD_EXP 66
67473: PUSH
67474: LD_VAR 0 2
67478: ARRAY
67479: PUSH
67480: LD_INT 1
67482: ARRAY
67483: PUSH
67484: LD_INT 2
67486: ARRAY
67487: PPUSH
67488: LD_EXP 66
67492: PUSH
67493: LD_VAR 0 2
67497: ARRAY
67498: PUSH
67499: LD_INT 1
67501: ARRAY
67502: PUSH
67503: LD_INT 3
67505: ARRAY
67506: PPUSH
67507: LD_EXP 66
67511: PUSH
67512: LD_VAR 0 2
67516: ARRAY
67517: PUSH
67518: LD_INT 1
67520: ARRAY
67521: PUSH
67522: LD_INT 4
67524: ARRAY
67525: PPUSH
67526: CALL 28184 0 5
67530: OR
67531: IFFALSE 67812
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67533: LD_ADDR_VAR 0 5
67537: PUSH
67538: LD_EXP 61
67542: PUSH
67543: LD_VAR 0 2
67547: ARRAY
67548: PPUSH
67549: LD_INT 25
67551: PUSH
67552: LD_INT 2
67554: PUSH
67555: EMPTY
67556: LIST
67557: LIST
67558: PPUSH
67559: CALL_OW 72
67563: PUSH
67564: LD_EXP 63
67568: PUSH
67569: LD_VAR 0 2
67573: ARRAY
67574: DIFF
67575: ST_TO_ADDR
// if not tmp then
67576: LD_VAR 0 5
67580: NOT
67581: IFFALSE 67585
// continue ;
67583: GO 67413
// for j in tmp do
67585: LD_ADDR_VAR 0 3
67589: PUSH
67590: LD_VAR 0 5
67594: PUSH
67595: FOR_IN
67596: IFFALSE 67808
// begin if not mc_builders [ i ] then
67598: LD_EXP 67
67602: PUSH
67603: LD_VAR 0 2
67607: ARRAY
67608: NOT
67609: IFFALSE 67667
// begin SetTag ( j , 103 ) ;
67611: LD_VAR 0 3
67615: PPUSH
67616: LD_INT 103
67618: PPUSH
67619: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67623: LD_ADDR_EXP 67
67627: PUSH
67628: LD_EXP 67
67632: PPUSH
67633: LD_VAR 0 2
67637: PUSH
67638: LD_EXP 67
67642: PUSH
67643: LD_VAR 0 2
67647: ARRAY
67648: PUSH
67649: LD_INT 1
67651: PLUS
67652: PUSH
67653: EMPTY
67654: LIST
67655: LIST
67656: PPUSH
67657: LD_VAR 0 3
67661: PPUSH
67662: CALL 20087 0 3
67666: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67667: LD_VAR 0 3
67671: PPUSH
67672: CALL_OW 310
67676: IFFALSE 67687
// ComExitBuilding ( j ) ;
67678: LD_VAR 0 3
67682: PPUSH
67683: CALL_OW 122
// wait ( 3 ) ;
67687: LD_INT 3
67689: PPUSH
67690: CALL_OW 67
// if not mc_build_list [ i ] then
67694: LD_EXP 66
67698: PUSH
67699: LD_VAR 0 2
67703: ARRAY
67704: NOT
67705: IFFALSE 67709
// break ;
67707: GO 67808
// if not HasTask ( j ) then
67709: LD_VAR 0 3
67713: PPUSH
67714: CALL_OW 314
67718: NOT
67719: IFFALSE 67806
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
67721: LD_VAR 0 3
67725: PPUSH
67726: LD_EXP 66
67730: PUSH
67731: LD_VAR 0 2
67735: ARRAY
67736: PUSH
67737: LD_INT 1
67739: ARRAY
67740: PUSH
67741: LD_INT 1
67743: ARRAY
67744: PPUSH
67745: LD_EXP 66
67749: PUSH
67750: LD_VAR 0 2
67754: ARRAY
67755: PUSH
67756: LD_INT 1
67758: ARRAY
67759: PUSH
67760: LD_INT 2
67762: ARRAY
67763: PPUSH
67764: LD_EXP 66
67768: PUSH
67769: LD_VAR 0 2
67773: ARRAY
67774: PUSH
67775: LD_INT 1
67777: ARRAY
67778: PUSH
67779: LD_INT 3
67781: ARRAY
67782: PPUSH
67783: LD_EXP 66
67787: PUSH
67788: LD_VAR 0 2
67792: ARRAY
67793: PUSH
67794: LD_INT 1
67796: ARRAY
67797: PUSH
67798: LD_INT 4
67800: ARRAY
67801: PPUSH
67802: CALL_OW 145
// end ;
67806: GO 67595
67808: POP
67809: POP
// end else
67810: GO 67982
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
67812: LD_EXP 61
67816: PUSH
67817: LD_VAR 0 2
67821: ARRAY
67822: PPUSH
67823: LD_EXP 66
67827: PUSH
67828: LD_VAR 0 2
67832: ARRAY
67833: PUSH
67834: LD_INT 1
67836: ARRAY
67837: PUSH
67838: LD_INT 1
67840: ARRAY
67841: PPUSH
67842: LD_EXP 66
67846: PUSH
67847: LD_VAR 0 2
67851: ARRAY
67852: PUSH
67853: LD_INT 1
67855: ARRAY
67856: PUSH
67857: LD_INT 2
67859: ARRAY
67860: PPUSH
67861: LD_EXP 66
67865: PUSH
67866: LD_VAR 0 2
67870: ARRAY
67871: PUSH
67872: LD_INT 1
67874: ARRAY
67875: PUSH
67876: LD_INT 3
67878: ARRAY
67879: PPUSH
67880: LD_EXP 66
67884: PUSH
67885: LD_VAR 0 2
67889: ARRAY
67890: PUSH
67891: LD_INT 1
67893: ARRAY
67894: PUSH
67895: LD_INT 4
67897: ARRAY
67898: PPUSH
67899: LD_EXP 61
67903: PUSH
67904: LD_VAR 0 2
67908: ARRAY
67909: PPUSH
67910: LD_INT 21
67912: PUSH
67913: LD_INT 3
67915: PUSH
67916: EMPTY
67917: LIST
67918: LIST
67919: PPUSH
67920: CALL_OW 72
67924: PPUSH
67925: EMPTY
67926: PPUSH
67927: CALL 26938 0 7
67931: NOT
67932: IFFALSE 67982
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
67934: LD_ADDR_EXP 66
67938: PUSH
67939: LD_EXP 66
67943: PPUSH
67944: LD_VAR 0 2
67948: PPUSH
67949: LD_EXP 66
67953: PUSH
67954: LD_VAR 0 2
67958: ARRAY
67959: PPUSH
67960: LD_INT 1
67962: PPUSH
67963: LD_INT 1
67965: NEG
67966: PPUSH
67967: LD_INT 0
67969: PPUSH
67970: CALL 19505 0 4
67974: PPUSH
67975: CALL_OW 1
67979: ST_TO_ADDR
// continue ;
67980: GO 67413
// end ; end ;
67982: GO 67413
67984: POP
67985: POP
// end ; end ;
67986: GO 66842
67988: POP
67989: POP
// end ;
67990: LD_VAR 0 1
67994: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
67995: LD_INT 0
67997: PPUSH
67998: PPUSH
67999: PPUSH
68000: PPUSH
68001: PPUSH
68002: PPUSH
// if not mc_bases then
68003: LD_EXP 61
68007: NOT
68008: IFFALSE 68012
// exit ;
68010: GO 68439
// for i = 1 to mc_bases do
68012: LD_ADDR_VAR 0 2
68016: PUSH
68017: DOUBLE
68018: LD_INT 1
68020: DEC
68021: ST_TO_ADDR
68022: LD_EXP 61
68026: PUSH
68027: FOR_TO
68028: IFFALSE 68437
// begin tmp := mc_build_upgrade [ i ] ;
68030: LD_ADDR_VAR 0 4
68034: PUSH
68035: LD_EXP 93
68039: PUSH
68040: LD_VAR 0 2
68044: ARRAY
68045: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
68046: LD_ADDR_VAR 0 6
68050: PUSH
68051: LD_EXP 94
68055: PUSH
68056: LD_VAR 0 2
68060: ARRAY
68061: PPUSH
68062: LD_INT 2
68064: PUSH
68065: LD_INT 30
68067: PUSH
68068: LD_INT 6
68070: PUSH
68071: EMPTY
68072: LIST
68073: LIST
68074: PUSH
68075: LD_INT 30
68077: PUSH
68078: LD_INT 7
68080: PUSH
68081: EMPTY
68082: LIST
68083: LIST
68084: PUSH
68085: EMPTY
68086: LIST
68087: LIST
68088: LIST
68089: PPUSH
68090: CALL_OW 72
68094: ST_TO_ADDR
// if not tmp and not lab then
68095: LD_VAR 0 4
68099: NOT
68100: PUSH
68101: LD_VAR 0 6
68105: NOT
68106: AND
68107: IFFALSE 68111
// continue ;
68109: GO 68027
// if tmp then
68111: LD_VAR 0 4
68115: IFFALSE 68235
// for j in tmp do
68117: LD_ADDR_VAR 0 3
68121: PUSH
68122: LD_VAR 0 4
68126: PUSH
68127: FOR_IN
68128: IFFALSE 68233
// begin if UpgradeCost ( j ) then
68130: LD_VAR 0 3
68134: PPUSH
68135: CALL 26598 0 1
68139: IFFALSE 68231
// begin ComUpgrade ( j ) ;
68141: LD_VAR 0 3
68145: PPUSH
68146: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
68150: LD_ADDR_EXP 93
68154: PUSH
68155: LD_EXP 93
68159: PPUSH
68160: LD_VAR 0 2
68164: PPUSH
68165: LD_EXP 93
68169: PUSH
68170: LD_VAR 0 2
68174: ARRAY
68175: PUSH
68176: LD_VAR 0 3
68180: DIFF
68181: PPUSH
68182: CALL_OW 1
68186: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68187: LD_ADDR_EXP 68
68191: PUSH
68192: LD_EXP 68
68196: PPUSH
68197: LD_VAR 0 2
68201: PUSH
68202: LD_EXP 68
68206: PUSH
68207: LD_VAR 0 2
68211: ARRAY
68212: PUSH
68213: LD_INT 1
68215: PLUS
68216: PUSH
68217: EMPTY
68218: LIST
68219: LIST
68220: PPUSH
68221: LD_VAR 0 3
68225: PPUSH
68226: CALL 20087 0 3
68230: ST_TO_ADDR
// end ; end ;
68231: GO 68127
68233: POP
68234: POP
// if not lab or not mc_lab_upgrade [ i ] then
68235: LD_VAR 0 6
68239: NOT
68240: PUSH
68241: LD_EXP 95
68245: PUSH
68246: LD_VAR 0 2
68250: ARRAY
68251: NOT
68252: OR
68253: IFFALSE 68257
// continue ;
68255: GO 68027
// for j in lab do
68257: LD_ADDR_VAR 0 3
68261: PUSH
68262: LD_VAR 0 6
68266: PUSH
68267: FOR_IN
68268: IFFALSE 68433
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
68270: LD_VAR 0 3
68274: PPUSH
68275: CALL_OW 266
68279: PUSH
68280: LD_INT 6
68282: PUSH
68283: LD_INT 7
68285: PUSH
68286: EMPTY
68287: LIST
68288: LIST
68289: IN
68290: PUSH
68291: LD_VAR 0 3
68295: PPUSH
68296: CALL_OW 461
68300: PUSH
68301: LD_INT 1
68303: NONEQUAL
68304: AND
68305: IFFALSE 68431
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
68307: LD_VAR 0 3
68311: PPUSH
68312: LD_EXP 95
68316: PUSH
68317: LD_VAR 0 2
68321: ARRAY
68322: PUSH
68323: LD_INT 1
68325: ARRAY
68326: PPUSH
68327: CALL 26803 0 2
68331: IFFALSE 68431
// begin ComCancel ( j ) ;
68333: LD_VAR 0 3
68337: PPUSH
68338: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
68342: LD_VAR 0 3
68346: PPUSH
68347: LD_EXP 95
68351: PUSH
68352: LD_VAR 0 2
68356: ARRAY
68357: PUSH
68358: LD_INT 1
68360: ARRAY
68361: PPUSH
68362: CALL_OW 207
// if not j in mc_construct_list [ i ] then
68366: LD_VAR 0 3
68370: PUSH
68371: LD_EXP 68
68375: PUSH
68376: LD_VAR 0 2
68380: ARRAY
68381: IN
68382: NOT
68383: IFFALSE 68429
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68385: LD_ADDR_EXP 68
68389: PUSH
68390: LD_EXP 68
68394: PPUSH
68395: LD_VAR 0 2
68399: PUSH
68400: LD_EXP 68
68404: PUSH
68405: LD_VAR 0 2
68409: ARRAY
68410: PUSH
68411: LD_INT 1
68413: PLUS
68414: PUSH
68415: EMPTY
68416: LIST
68417: LIST
68418: PPUSH
68419: LD_VAR 0 3
68423: PPUSH
68424: CALL 20087 0 3
68428: ST_TO_ADDR
// break ;
68429: GO 68433
// end ; end ; end ;
68431: GO 68267
68433: POP
68434: POP
// end ;
68435: GO 68027
68437: POP
68438: POP
// end ;
68439: LD_VAR 0 1
68443: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
68444: LD_INT 0
68446: PPUSH
68447: PPUSH
68448: PPUSH
68449: PPUSH
68450: PPUSH
68451: PPUSH
68452: PPUSH
68453: PPUSH
68454: PPUSH
// if not mc_bases then
68455: LD_EXP 61
68459: NOT
68460: IFFALSE 68464
// exit ;
68462: GO 68869
// for i = 1 to mc_bases do
68464: LD_ADDR_VAR 0 2
68468: PUSH
68469: DOUBLE
68470: LD_INT 1
68472: DEC
68473: ST_TO_ADDR
68474: LD_EXP 61
68478: PUSH
68479: FOR_TO
68480: IFFALSE 68867
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
68482: LD_EXP 69
68486: PUSH
68487: LD_VAR 0 2
68491: ARRAY
68492: NOT
68493: PUSH
68494: LD_EXP 61
68498: PUSH
68499: LD_VAR 0 2
68503: ARRAY
68504: PPUSH
68505: LD_INT 30
68507: PUSH
68508: LD_INT 3
68510: PUSH
68511: EMPTY
68512: LIST
68513: LIST
68514: PPUSH
68515: CALL_OW 72
68519: NOT
68520: OR
68521: IFFALSE 68525
// continue ;
68523: GO 68479
// busy := false ;
68525: LD_ADDR_VAR 0 8
68529: PUSH
68530: LD_INT 0
68532: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68533: LD_ADDR_VAR 0 4
68537: PUSH
68538: LD_EXP 61
68542: PUSH
68543: LD_VAR 0 2
68547: ARRAY
68548: PPUSH
68549: LD_INT 30
68551: PUSH
68552: LD_INT 3
68554: PUSH
68555: EMPTY
68556: LIST
68557: LIST
68558: PPUSH
68559: CALL_OW 72
68563: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
68564: LD_ADDR_VAR 0 6
68568: PUSH
68569: LD_EXP 69
68573: PUSH
68574: LD_VAR 0 2
68578: ARRAY
68579: PPUSH
68580: LD_INT 2
68582: PUSH
68583: LD_INT 30
68585: PUSH
68586: LD_INT 32
68588: PUSH
68589: EMPTY
68590: LIST
68591: LIST
68592: PUSH
68593: LD_INT 30
68595: PUSH
68596: LD_INT 33
68598: PUSH
68599: EMPTY
68600: LIST
68601: LIST
68602: PUSH
68603: EMPTY
68604: LIST
68605: LIST
68606: LIST
68607: PPUSH
68608: CALL_OW 72
68612: ST_TO_ADDR
// if not t then
68613: LD_VAR 0 6
68617: NOT
68618: IFFALSE 68622
// continue ;
68620: GO 68479
// for j in tmp do
68622: LD_ADDR_VAR 0 3
68626: PUSH
68627: LD_VAR 0 4
68631: PUSH
68632: FOR_IN
68633: IFFALSE 68663
// if not BuildingStatus ( j ) = bs_idle then
68635: LD_VAR 0 3
68639: PPUSH
68640: CALL_OW 461
68644: PUSH
68645: LD_INT 2
68647: EQUAL
68648: NOT
68649: IFFALSE 68661
// begin busy := true ;
68651: LD_ADDR_VAR 0 8
68655: PUSH
68656: LD_INT 1
68658: ST_TO_ADDR
// break ;
68659: GO 68663
// end ;
68661: GO 68632
68663: POP
68664: POP
// if busy then
68665: LD_VAR 0 8
68669: IFFALSE 68673
// continue ;
68671: GO 68479
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
68673: LD_ADDR_VAR 0 7
68677: PUSH
68678: LD_VAR 0 6
68682: PPUSH
68683: LD_INT 35
68685: PUSH
68686: LD_INT 0
68688: PUSH
68689: EMPTY
68690: LIST
68691: LIST
68692: PPUSH
68693: CALL_OW 72
68697: ST_TO_ADDR
// if tw then
68698: LD_VAR 0 7
68702: IFFALSE 68779
// begin tw := tw [ 1 ] ;
68704: LD_ADDR_VAR 0 7
68708: PUSH
68709: LD_VAR 0 7
68713: PUSH
68714: LD_INT 1
68716: ARRAY
68717: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
68718: LD_ADDR_VAR 0 9
68722: PUSH
68723: LD_VAR 0 7
68727: PPUSH
68728: LD_EXP 86
68732: PUSH
68733: LD_VAR 0 2
68737: ARRAY
68738: PPUSH
68739: CALL 25095 0 2
68743: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
68744: LD_EXP 100
68748: PUSH
68749: LD_VAR 0 2
68753: ARRAY
68754: IFFALSE 68777
// if not weapon in mc_allowed_tower_weapons [ i ] then
68756: LD_VAR 0 9
68760: PUSH
68761: LD_EXP 100
68765: PUSH
68766: LD_VAR 0 2
68770: ARRAY
68771: IN
68772: NOT
68773: IFFALSE 68777
// continue ;
68775: GO 68479
// end else
68777: GO 68842
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
68779: LD_ADDR_VAR 0 5
68783: PUSH
68784: LD_EXP 69
68788: PUSH
68789: LD_VAR 0 2
68793: ARRAY
68794: PPUSH
68795: LD_VAR 0 4
68799: PPUSH
68800: CALL 51966 0 2
68804: ST_TO_ADDR
// if not tmp2 then
68805: LD_VAR 0 5
68809: NOT
68810: IFFALSE 68814
// continue ;
68812: GO 68479
// tw := tmp2 [ 1 ] ;
68814: LD_ADDR_VAR 0 7
68818: PUSH
68819: LD_VAR 0 5
68823: PUSH
68824: LD_INT 1
68826: ARRAY
68827: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
68828: LD_ADDR_VAR 0 9
68832: PUSH
68833: LD_VAR 0 5
68837: PUSH
68838: LD_INT 2
68840: ARRAY
68841: ST_TO_ADDR
// end ; if not weapon then
68842: LD_VAR 0 9
68846: NOT
68847: IFFALSE 68851
// continue ;
68849: GO 68479
// ComPlaceWeapon ( tw , weapon ) ;
68851: LD_VAR 0 7
68855: PPUSH
68856: LD_VAR 0 9
68860: PPUSH
68861: CALL_OW 148
// end ;
68865: GO 68479
68867: POP
68868: POP
// end ;
68869: LD_VAR 0 1
68873: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
68874: LD_INT 0
68876: PPUSH
68877: PPUSH
68878: PPUSH
68879: PPUSH
68880: PPUSH
68881: PPUSH
68882: PPUSH
// if not mc_bases then
68883: LD_EXP 61
68887: NOT
68888: IFFALSE 68892
// exit ;
68890: GO 69660
// for i = 1 to mc_bases do
68892: LD_ADDR_VAR 0 2
68896: PUSH
68897: DOUBLE
68898: LD_INT 1
68900: DEC
68901: ST_TO_ADDR
68902: LD_EXP 61
68906: PUSH
68907: FOR_TO
68908: IFFALSE 69658
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
68910: LD_EXP 74
68914: PUSH
68915: LD_VAR 0 2
68919: ARRAY
68920: NOT
68921: PUSH
68922: LD_EXP 74
68926: PUSH
68927: LD_VAR 0 2
68931: ARRAY
68932: PUSH
68933: LD_EXP 75
68937: PUSH
68938: LD_VAR 0 2
68942: ARRAY
68943: EQUAL
68944: OR
68945: PUSH
68946: LD_EXP 84
68950: PUSH
68951: LD_VAR 0 2
68955: ARRAY
68956: OR
68957: IFFALSE 68961
// continue ;
68959: GO 68907
// if mc_miners [ i ] then
68961: LD_EXP 75
68965: PUSH
68966: LD_VAR 0 2
68970: ARRAY
68971: IFFALSE 69345
// begin for j = mc_miners [ i ] downto 1 do
68973: LD_ADDR_VAR 0 3
68977: PUSH
68978: DOUBLE
68979: LD_EXP 75
68983: PUSH
68984: LD_VAR 0 2
68988: ARRAY
68989: INC
68990: ST_TO_ADDR
68991: LD_INT 1
68993: PUSH
68994: FOR_DOWNTO
68995: IFFALSE 69343
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
68997: LD_EXP 75
69001: PUSH
69002: LD_VAR 0 2
69006: ARRAY
69007: PUSH
69008: LD_VAR 0 3
69012: ARRAY
69013: PPUSH
69014: CALL_OW 301
69018: PUSH
69019: LD_EXP 75
69023: PUSH
69024: LD_VAR 0 2
69028: ARRAY
69029: PUSH
69030: LD_VAR 0 3
69034: ARRAY
69035: PPUSH
69036: CALL_OW 257
69040: PUSH
69041: LD_INT 1
69043: NONEQUAL
69044: OR
69045: IFFALSE 69108
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
69047: LD_ADDR_VAR 0 5
69051: PUSH
69052: LD_EXP 75
69056: PUSH
69057: LD_VAR 0 2
69061: ARRAY
69062: PUSH
69063: LD_EXP 75
69067: PUSH
69068: LD_VAR 0 2
69072: ARRAY
69073: PUSH
69074: LD_VAR 0 3
69078: ARRAY
69079: DIFF
69080: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
69081: LD_ADDR_EXP 75
69085: PUSH
69086: LD_EXP 75
69090: PPUSH
69091: LD_VAR 0 2
69095: PPUSH
69096: LD_VAR 0 5
69100: PPUSH
69101: CALL_OW 1
69105: ST_TO_ADDR
// continue ;
69106: GO 68994
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
69108: LD_EXP 75
69112: PUSH
69113: LD_VAR 0 2
69117: ARRAY
69118: PUSH
69119: LD_VAR 0 3
69123: ARRAY
69124: PPUSH
69125: CALL_OW 257
69129: PUSH
69130: LD_INT 1
69132: EQUAL
69133: PUSH
69134: LD_EXP 75
69138: PUSH
69139: LD_VAR 0 2
69143: ARRAY
69144: PUSH
69145: LD_VAR 0 3
69149: ARRAY
69150: PPUSH
69151: CALL_OW 459
69155: NOT
69156: AND
69157: PUSH
69158: LD_EXP 75
69162: PUSH
69163: LD_VAR 0 2
69167: ARRAY
69168: PUSH
69169: LD_VAR 0 3
69173: ARRAY
69174: PPUSH
69175: CALL_OW 314
69179: NOT
69180: AND
69181: IFFALSE 69341
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
69183: LD_EXP 75
69187: PUSH
69188: LD_VAR 0 2
69192: ARRAY
69193: PUSH
69194: LD_VAR 0 3
69198: ARRAY
69199: PPUSH
69200: CALL_OW 310
69204: IFFALSE 69227
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
69206: LD_EXP 75
69210: PUSH
69211: LD_VAR 0 2
69215: ARRAY
69216: PUSH
69217: LD_VAR 0 3
69221: ARRAY
69222: PPUSH
69223: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
69227: LD_EXP 75
69231: PUSH
69232: LD_VAR 0 2
69236: ARRAY
69237: PUSH
69238: LD_VAR 0 3
69242: ARRAY
69243: PPUSH
69244: CALL_OW 314
69248: NOT
69249: IFFALSE 69341
// begin r := rand ( 1 , mc_mines [ i ] ) ;
69251: LD_ADDR_VAR 0 7
69255: PUSH
69256: LD_INT 1
69258: PPUSH
69259: LD_EXP 74
69263: PUSH
69264: LD_VAR 0 2
69268: ARRAY
69269: PPUSH
69270: CALL_OW 12
69274: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
69275: LD_EXP 75
69279: PUSH
69280: LD_VAR 0 2
69284: ARRAY
69285: PUSH
69286: LD_VAR 0 3
69290: ARRAY
69291: PPUSH
69292: LD_EXP 74
69296: PUSH
69297: LD_VAR 0 2
69301: ARRAY
69302: PUSH
69303: LD_VAR 0 7
69307: ARRAY
69308: PUSH
69309: LD_INT 1
69311: ARRAY
69312: PPUSH
69313: LD_EXP 74
69317: PUSH
69318: LD_VAR 0 2
69322: ARRAY
69323: PUSH
69324: LD_VAR 0 7
69328: ARRAY
69329: PUSH
69330: LD_INT 2
69332: ARRAY
69333: PPUSH
69334: LD_INT 0
69336: PPUSH
69337: CALL_OW 193
// end ; end ; end ;
69341: GO 68994
69343: POP
69344: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
69345: LD_ADDR_VAR 0 5
69349: PUSH
69350: LD_EXP 61
69354: PUSH
69355: LD_VAR 0 2
69359: ARRAY
69360: PPUSH
69361: LD_INT 2
69363: PUSH
69364: LD_INT 30
69366: PUSH
69367: LD_INT 4
69369: PUSH
69370: EMPTY
69371: LIST
69372: LIST
69373: PUSH
69374: LD_INT 30
69376: PUSH
69377: LD_INT 5
69379: PUSH
69380: EMPTY
69381: LIST
69382: LIST
69383: PUSH
69384: LD_INT 30
69386: PUSH
69387: LD_INT 32
69389: PUSH
69390: EMPTY
69391: LIST
69392: LIST
69393: PUSH
69394: EMPTY
69395: LIST
69396: LIST
69397: LIST
69398: LIST
69399: PPUSH
69400: CALL_OW 72
69404: ST_TO_ADDR
// if not tmp then
69405: LD_VAR 0 5
69409: NOT
69410: IFFALSE 69414
// continue ;
69412: GO 68907
// list := [ ] ;
69414: LD_ADDR_VAR 0 6
69418: PUSH
69419: EMPTY
69420: ST_TO_ADDR
// for j in tmp do
69421: LD_ADDR_VAR 0 3
69425: PUSH
69426: LD_VAR 0 5
69430: PUSH
69431: FOR_IN
69432: IFFALSE 69501
// begin for k in UnitsInside ( j ) do
69434: LD_ADDR_VAR 0 4
69438: PUSH
69439: LD_VAR 0 3
69443: PPUSH
69444: CALL_OW 313
69448: PUSH
69449: FOR_IN
69450: IFFALSE 69497
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
69452: LD_VAR 0 4
69456: PPUSH
69457: CALL_OW 257
69461: PUSH
69462: LD_INT 1
69464: EQUAL
69465: PUSH
69466: LD_VAR 0 4
69470: PPUSH
69471: CALL_OW 459
69475: NOT
69476: AND
69477: IFFALSE 69495
// list := list ^ k ;
69479: LD_ADDR_VAR 0 6
69483: PUSH
69484: LD_VAR 0 6
69488: PUSH
69489: LD_VAR 0 4
69493: ADD
69494: ST_TO_ADDR
69495: GO 69449
69497: POP
69498: POP
// end ;
69499: GO 69431
69501: POP
69502: POP
// list := list diff mc_miners [ i ] ;
69503: LD_ADDR_VAR 0 6
69507: PUSH
69508: LD_VAR 0 6
69512: PUSH
69513: LD_EXP 75
69517: PUSH
69518: LD_VAR 0 2
69522: ARRAY
69523: DIFF
69524: ST_TO_ADDR
// if not list then
69525: LD_VAR 0 6
69529: NOT
69530: IFFALSE 69534
// continue ;
69532: GO 68907
// k := mc_mines [ i ] - mc_miners [ i ] ;
69534: LD_ADDR_VAR 0 4
69538: PUSH
69539: LD_EXP 74
69543: PUSH
69544: LD_VAR 0 2
69548: ARRAY
69549: PUSH
69550: LD_EXP 75
69554: PUSH
69555: LD_VAR 0 2
69559: ARRAY
69560: MINUS
69561: ST_TO_ADDR
// if k > list then
69562: LD_VAR 0 4
69566: PUSH
69567: LD_VAR 0 6
69571: GREATER
69572: IFFALSE 69584
// k := list ;
69574: LD_ADDR_VAR 0 4
69578: PUSH
69579: LD_VAR 0 6
69583: ST_TO_ADDR
// for j = 1 to k do
69584: LD_ADDR_VAR 0 3
69588: PUSH
69589: DOUBLE
69590: LD_INT 1
69592: DEC
69593: ST_TO_ADDR
69594: LD_VAR 0 4
69598: PUSH
69599: FOR_TO
69600: IFFALSE 69654
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
69602: LD_ADDR_EXP 75
69606: PUSH
69607: LD_EXP 75
69611: PPUSH
69612: LD_VAR 0 2
69616: PUSH
69617: LD_EXP 75
69621: PUSH
69622: LD_VAR 0 2
69626: ARRAY
69627: PUSH
69628: LD_INT 1
69630: PLUS
69631: PUSH
69632: EMPTY
69633: LIST
69634: LIST
69635: PPUSH
69636: LD_VAR 0 6
69640: PUSH
69641: LD_VAR 0 3
69645: ARRAY
69646: PPUSH
69647: CALL 20087 0 3
69651: ST_TO_ADDR
69652: GO 69599
69654: POP
69655: POP
// end ;
69656: GO 68907
69658: POP
69659: POP
// end ;
69660: LD_VAR 0 1
69664: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
69665: LD_INT 0
69667: PPUSH
69668: PPUSH
69669: PPUSH
69670: PPUSH
69671: PPUSH
69672: PPUSH
69673: PPUSH
69674: PPUSH
69675: PPUSH
69676: PPUSH
69677: PPUSH
// if not mc_bases then
69678: LD_EXP 61
69682: NOT
69683: IFFALSE 69687
// exit ;
69685: GO 71510
// for i = 1 to mc_bases do
69687: LD_ADDR_VAR 0 2
69691: PUSH
69692: DOUBLE
69693: LD_INT 1
69695: DEC
69696: ST_TO_ADDR
69697: LD_EXP 61
69701: PUSH
69702: FOR_TO
69703: IFFALSE 71508
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
69705: LD_EXP 61
69709: PUSH
69710: LD_VAR 0 2
69714: ARRAY
69715: NOT
69716: PUSH
69717: LD_EXP 68
69721: PUSH
69722: LD_VAR 0 2
69726: ARRAY
69727: OR
69728: IFFALSE 69732
// continue ;
69730: GO 69702
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
69732: LD_EXP 77
69736: PUSH
69737: LD_VAR 0 2
69741: ARRAY
69742: NOT
69743: PUSH
69744: LD_EXP 78
69748: PUSH
69749: LD_VAR 0 2
69753: ARRAY
69754: AND
69755: IFFALSE 69793
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
69757: LD_ADDR_EXP 78
69761: PUSH
69762: LD_EXP 78
69766: PPUSH
69767: LD_VAR 0 2
69771: PPUSH
69772: EMPTY
69773: PPUSH
69774: CALL_OW 1
69778: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
69779: LD_VAR 0 2
69783: PPUSH
69784: LD_INT 107
69786: PPUSH
69787: CALL 60540 0 2
// continue ;
69791: GO 69702
// end ; target := [ ] ;
69793: LD_ADDR_VAR 0 7
69797: PUSH
69798: EMPTY
69799: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
69800: LD_ADDR_VAR 0 6
69804: PUSH
69805: LD_EXP 61
69809: PUSH
69810: LD_VAR 0 2
69814: ARRAY
69815: PUSH
69816: LD_INT 1
69818: ARRAY
69819: PPUSH
69820: CALL_OW 255
69824: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69825: LD_ADDR_VAR 0 9
69829: PUSH
69830: LD_EXP 61
69834: PUSH
69835: LD_VAR 0 2
69839: ARRAY
69840: PPUSH
69841: LD_INT 2
69843: PUSH
69844: LD_INT 30
69846: PUSH
69847: LD_INT 0
69849: PUSH
69850: EMPTY
69851: LIST
69852: LIST
69853: PUSH
69854: LD_INT 30
69856: PUSH
69857: LD_INT 1
69859: PUSH
69860: EMPTY
69861: LIST
69862: LIST
69863: PUSH
69864: EMPTY
69865: LIST
69866: LIST
69867: LIST
69868: PPUSH
69869: CALL_OW 72
69873: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
69874: LD_ADDR_VAR 0 3
69878: PUSH
69879: DOUBLE
69880: LD_EXP 77
69884: PUSH
69885: LD_VAR 0 2
69889: ARRAY
69890: INC
69891: ST_TO_ADDR
69892: LD_INT 1
69894: PUSH
69895: FOR_DOWNTO
69896: IFFALSE 70141
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
69898: LD_EXP 77
69902: PUSH
69903: LD_VAR 0 2
69907: ARRAY
69908: PUSH
69909: LD_VAR 0 3
69913: ARRAY
69914: PUSH
69915: LD_INT 2
69917: ARRAY
69918: PPUSH
69919: LD_EXP 77
69923: PUSH
69924: LD_VAR 0 2
69928: ARRAY
69929: PUSH
69930: LD_VAR 0 3
69934: ARRAY
69935: PUSH
69936: LD_INT 3
69938: ARRAY
69939: PPUSH
69940: CALL_OW 488
69944: PUSH
69945: LD_EXP 77
69949: PUSH
69950: LD_VAR 0 2
69954: ARRAY
69955: PUSH
69956: LD_VAR 0 3
69960: ARRAY
69961: PUSH
69962: LD_INT 2
69964: ARRAY
69965: PPUSH
69966: LD_EXP 77
69970: PUSH
69971: LD_VAR 0 2
69975: ARRAY
69976: PUSH
69977: LD_VAR 0 3
69981: ARRAY
69982: PUSH
69983: LD_INT 3
69985: ARRAY
69986: PPUSH
69987: CALL_OW 284
69991: PUSH
69992: LD_INT 0
69994: EQUAL
69995: AND
69996: IFFALSE 70051
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
69998: LD_ADDR_VAR 0 5
70002: PUSH
70003: LD_EXP 77
70007: PUSH
70008: LD_VAR 0 2
70012: ARRAY
70013: PPUSH
70014: LD_VAR 0 3
70018: PPUSH
70019: CALL_OW 3
70023: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
70024: LD_ADDR_EXP 77
70028: PUSH
70029: LD_EXP 77
70033: PPUSH
70034: LD_VAR 0 2
70038: PPUSH
70039: LD_VAR 0 5
70043: PPUSH
70044: CALL_OW 1
70048: ST_TO_ADDR
// continue ;
70049: GO 69895
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70051: LD_VAR 0 6
70055: PPUSH
70056: LD_EXP 77
70060: PUSH
70061: LD_VAR 0 2
70065: ARRAY
70066: PUSH
70067: LD_VAR 0 3
70071: ARRAY
70072: PUSH
70073: LD_INT 2
70075: ARRAY
70076: PPUSH
70077: LD_EXP 77
70081: PUSH
70082: LD_VAR 0 2
70086: ARRAY
70087: PUSH
70088: LD_VAR 0 3
70092: ARRAY
70093: PUSH
70094: LD_INT 3
70096: ARRAY
70097: PPUSH
70098: LD_INT 30
70100: PPUSH
70101: CALL 20983 0 4
70105: PUSH
70106: LD_INT 4
70108: ARRAY
70109: PUSH
70110: LD_INT 0
70112: EQUAL
70113: IFFALSE 70139
// begin target := mc_crates [ i ] [ j ] ;
70115: LD_ADDR_VAR 0 7
70119: PUSH
70120: LD_EXP 77
70124: PUSH
70125: LD_VAR 0 2
70129: ARRAY
70130: PUSH
70131: LD_VAR 0 3
70135: ARRAY
70136: ST_TO_ADDR
// break ;
70137: GO 70141
// end ; end ;
70139: GO 69895
70141: POP
70142: POP
// if not target then
70143: LD_VAR 0 7
70147: NOT
70148: IFFALSE 70152
// continue ;
70150: GO 69702
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
70152: LD_ADDR_VAR 0 8
70156: PUSH
70157: LD_EXP 80
70161: PUSH
70162: LD_VAR 0 2
70166: ARRAY
70167: PPUSH
70168: LD_INT 2
70170: PUSH
70171: LD_INT 3
70173: PUSH
70174: LD_INT 58
70176: PUSH
70177: EMPTY
70178: LIST
70179: PUSH
70180: EMPTY
70181: LIST
70182: LIST
70183: PUSH
70184: LD_INT 61
70186: PUSH
70187: EMPTY
70188: LIST
70189: PUSH
70190: LD_INT 33
70192: PUSH
70193: LD_INT 5
70195: PUSH
70196: EMPTY
70197: LIST
70198: LIST
70199: PUSH
70200: LD_INT 33
70202: PUSH
70203: LD_INT 3
70205: PUSH
70206: EMPTY
70207: LIST
70208: LIST
70209: PUSH
70210: EMPTY
70211: LIST
70212: LIST
70213: LIST
70214: LIST
70215: LIST
70216: PUSH
70217: LD_INT 2
70219: PUSH
70220: LD_INT 34
70222: PUSH
70223: LD_INT 32
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: PUSH
70230: LD_INT 34
70232: PUSH
70233: LD_INT 51
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: PUSH
70240: LD_INT 34
70242: PUSH
70243: LD_INT 12
70245: PUSH
70246: EMPTY
70247: LIST
70248: LIST
70249: PUSH
70250: EMPTY
70251: LIST
70252: LIST
70253: LIST
70254: LIST
70255: PUSH
70256: EMPTY
70257: LIST
70258: LIST
70259: PPUSH
70260: CALL_OW 72
70264: ST_TO_ADDR
// if not cargo then
70265: LD_VAR 0 8
70269: NOT
70270: IFFALSE 70976
// begin if mc_crates_collector [ i ] < 5 then
70272: LD_EXP 78
70276: PUSH
70277: LD_VAR 0 2
70281: ARRAY
70282: PUSH
70283: LD_INT 5
70285: LESS
70286: IFFALSE 70652
// begin if mc_ape [ i ] then
70288: LD_EXP 90
70292: PUSH
70293: LD_VAR 0 2
70297: ARRAY
70298: IFFALSE 70345
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
70300: LD_ADDR_VAR 0 5
70304: PUSH
70305: LD_EXP 90
70309: PUSH
70310: LD_VAR 0 2
70314: ARRAY
70315: PPUSH
70316: LD_INT 25
70318: PUSH
70319: LD_INT 16
70321: PUSH
70322: EMPTY
70323: LIST
70324: LIST
70325: PUSH
70326: LD_INT 24
70328: PUSH
70329: LD_INT 750
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: PUSH
70336: EMPTY
70337: LIST
70338: LIST
70339: PPUSH
70340: CALL_OW 72
70344: ST_TO_ADDR
// if not tmp then
70345: LD_VAR 0 5
70349: NOT
70350: IFFALSE 70397
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
70352: LD_ADDR_VAR 0 5
70356: PUSH
70357: LD_EXP 61
70361: PUSH
70362: LD_VAR 0 2
70366: ARRAY
70367: PPUSH
70368: LD_INT 25
70370: PUSH
70371: LD_INT 2
70373: PUSH
70374: EMPTY
70375: LIST
70376: LIST
70377: PUSH
70378: LD_INT 24
70380: PUSH
70381: LD_INT 750
70383: PUSH
70384: EMPTY
70385: LIST
70386: LIST
70387: PUSH
70388: EMPTY
70389: LIST
70390: LIST
70391: PPUSH
70392: CALL_OW 72
70396: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
70397: LD_EXP 90
70401: PUSH
70402: LD_VAR 0 2
70406: ARRAY
70407: PUSH
70408: LD_EXP 61
70412: PUSH
70413: LD_VAR 0 2
70417: ARRAY
70418: PPUSH
70419: LD_INT 25
70421: PUSH
70422: LD_INT 2
70424: PUSH
70425: EMPTY
70426: LIST
70427: LIST
70428: PUSH
70429: LD_INT 24
70431: PUSH
70432: LD_INT 750
70434: PUSH
70435: EMPTY
70436: LIST
70437: LIST
70438: PUSH
70439: EMPTY
70440: LIST
70441: LIST
70442: PPUSH
70443: CALL_OW 72
70447: AND
70448: PUSH
70449: LD_VAR 0 5
70453: PUSH
70454: LD_INT 5
70456: LESS
70457: AND
70458: IFFALSE 70540
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
70460: LD_ADDR_VAR 0 3
70464: PUSH
70465: LD_EXP 61
70469: PUSH
70470: LD_VAR 0 2
70474: ARRAY
70475: PPUSH
70476: LD_INT 25
70478: PUSH
70479: LD_INT 2
70481: PUSH
70482: EMPTY
70483: LIST
70484: LIST
70485: PUSH
70486: LD_INT 24
70488: PUSH
70489: LD_INT 750
70491: PUSH
70492: EMPTY
70493: LIST
70494: LIST
70495: PUSH
70496: EMPTY
70497: LIST
70498: LIST
70499: PPUSH
70500: CALL_OW 72
70504: PUSH
70505: FOR_IN
70506: IFFALSE 70538
// begin tmp := tmp union j ;
70508: LD_ADDR_VAR 0 5
70512: PUSH
70513: LD_VAR 0 5
70517: PUSH
70518: LD_VAR 0 3
70522: UNION
70523: ST_TO_ADDR
// if tmp >= 5 then
70524: LD_VAR 0 5
70528: PUSH
70529: LD_INT 5
70531: GREATEREQUAL
70532: IFFALSE 70536
// break ;
70534: GO 70538
// end ;
70536: GO 70505
70538: POP
70539: POP
// end ; if not tmp then
70540: LD_VAR 0 5
70544: NOT
70545: IFFALSE 70549
// continue ;
70547: GO 69702
// for j in tmp do
70549: LD_ADDR_VAR 0 3
70553: PUSH
70554: LD_VAR 0 5
70558: PUSH
70559: FOR_IN
70560: IFFALSE 70650
// if not GetTag ( j ) then
70562: LD_VAR 0 3
70566: PPUSH
70567: CALL_OW 110
70571: NOT
70572: IFFALSE 70648
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
70574: LD_ADDR_EXP 78
70578: PUSH
70579: LD_EXP 78
70583: PPUSH
70584: LD_VAR 0 2
70588: PUSH
70589: LD_EXP 78
70593: PUSH
70594: LD_VAR 0 2
70598: ARRAY
70599: PUSH
70600: LD_INT 1
70602: PLUS
70603: PUSH
70604: EMPTY
70605: LIST
70606: LIST
70607: PPUSH
70608: LD_VAR 0 3
70612: PPUSH
70613: CALL 20087 0 3
70617: ST_TO_ADDR
// SetTag ( j , 107 ) ;
70618: LD_VAR 0 3
70622: PPUSH
70623: LD_INT 107
70625: PPUSH
70626: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
70630: LD_EXP 78
70634: PUSH
70635: LD_VAR 0 2
70639: ARRAY
70640: PUSH
70641: LD_INT 5
70643: GREATEREQUAL
70644: IFFALSE 70648
// break ;
70646: GO 70650
// end ;
70648: GO 70559
70650: POP
70651: POP
// end ; if mc_crates_collector [ i ] and target then
70652: LD_EXP 78
70656: PUSH
70657: LD_VAR 0 2
70661: ARRAY
70662: PUSH
70663: LD_VAR 0 7
70667: AND
70668: IFFALSE 70974
// begin if mc_crates_collector [ i ] < target [ 1 ] then
70670: LD_EXP 78
70674: PUSH
70675: LD_VAR 0 2
70679: ARRAY
70680: PUSH
70681: LD_VAR 0 7
70685: PUSH
70686: LD_INT 1
70688: ARRAY
70689: LESS
70690: IFFALSE 70710
// tmp := mc_crates_collector [ i ] else
70692: LD_ADDR_VAR 0 5
70696: PUSH
70697: LD_EXP 78
70701: PUSH
70702: LD_VAR 0 2
70706: ARRAY
70707: ST_TO_ADDR
70708: GO 70724
// tmp := target [ 1 ] ;
70710: LD_ADDR_VAR 0 5
70714: PUSH
70715: LD_VAR 0 7
70719: PUSH
70720: LD_INT 1
70722: ARRAY
70723: ST_TO_ADDR
// k := 0 ;
70724: LD_ADDR_VAR 0 4
70728: PUSH
70729: LD_INT 0
70731: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
70732: LD_ADDR_VAR 0 3
70736: PUSH
70737: LD_EXP 78
70741: PUSH
70742: LD_VAR 0 2
70746: ARRAY
70747: PUSH
70748: FOR_IN
70749: IFFALSE 70972
// begin k := k + 1 ;
70751: LD_ADDR_VAR 0 4
70755: PUSH
70756: LD_VAR 0 4
70760: PUSH
70761: LD_INT 1
70763: PLUS
70764: ST_TO_ADDR
// if k > tmp then
70765: LD_VAR 0 4
70769: PUSH
70770: LD_VAR 0 5
70774: GREATER
70775: IFFALSE 70779
// break ;
70777: GO 70972
// if not GetClass ( j ) in [ 2 , 16 ] then
70779: LD_VAR 0 3
70783: PPUSH
70784: CALL_OW 257
70788: PUSH
70789: LD_INT 2
70791: PUSH
70792: LD_INT 16
70794: PUSH
70795: EMPTY
70796: LIST
70797: LIST
70798: IN
70799: NOT
70800: IFFALSE 70853
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
70802: LD_ADDR_EXP 78
70806: PUSH
70807: LD_EXP 78
70811: PPUSH
70812: LD_VAR 0 2
70816: PPUSH
70817: LD_EXP 78
70821: PUSH
70822: LD_VAR 0 2
70826: ARRAY
70827: PUSH
70828: LD_VAR 0 3
70832: DIFF
70833: PPUSH
70834: CALL_OW 1
70838: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70839: LD_VAR 0 3
70843: PPUSH
70844: LD_INT 0
70846: PPUSH
70847: CALL_OW 109
// continue ;
70851: GO 70748
// end ; if IsInUnit ( j ) then
70853: LD_VAR 0 3
70857: PPUSH
70858: CALL_OW 310
70862: IFFALSE 70873
// ComExitBuilding ( j ) ;
70864: LD_VAR 0 3
70868: PPUSH
70869: CALL_OW 122
// wait ( 3 ) ;
70873: LD_INT 3
70875: PPUSH
70876: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
70880: LD_VAR 0 3
70884: PPUSH
70885: CALL_OW 314
70889: PUSH
70890: LD_VAR 0 6
70894: PPUSH
70895: LD_VAR 0 7
70899: PUSH
70900: LD_INT 2
70902: ARRAY
70903: PPUSH
70904: LD_VAR 0 7
70908: PUSH
70909: LD_INT 3
70911: ARRAY
70912: PPUSH
70913: LD_INT 30
70915: PPUSH
70916: CALL 20983 0 4
70920: PUSH
70921: LD_INT 4
70923: ARRAY
70924: AND
70925: IFFALSE 70943
// ComStandNearbyBuilding ( j , depot ) else
70927: LD_VAR 0 3
70931: PPUSH
70932: LD_VAR 0 9
70936: PPUSH
70937: CALL 16514 0 2
70941: GO 70970
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
70943: LD_VAR 0 3
70947: PPUSH
70948: LD_VAR 0 7
70952: PUSH
70953: LD_INT 2
70955: ARRAY
70956: PPUSH
70957: LD_VAR 0 7
70961: PUSH
70962: LD_INT 3
70964: ARRAY
70965: PPUSH
70966: CALL_OW 117
// end ;
70970: GO 70748
70972: POP
70973: POP
// end ; end else
70974: GO 71506
// begin for j in cargo do
70976: LD_ADDR_VAR 0 3
70980: PUSH
70981: LD_VAR 0 8
70985: PUSH
70986: FOR_IN
70987: IFFALSE 71504
// begin if GetTag ( j ) <> 0 then
70989: LD_VAR 0 3
70993: PPUSH
70994: CALL_OW 110
70998: PUSH
70999: LD_INT 0
71001: NONEQUAL
71002: IFFALSE 71006
// continue ;
71004: GO 70986
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
71006: LD_VAR 0 3
71010: PPUSH
71011: CALL_OW 256
71015: PUSH
71016: LD_INT 1000
71018: LESS
71019: PUSH
71020: LD_VAR 0 3
71024: PPUSH
71025: LD_EXP 85
71029: PUSH
71030: LD_VAR 0 2
71034: ARRAY
71035: PPUSH
71036: CALL_OW 308
71040: NOT
71041: AND
71042: IFFALSE 71064
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71044: LD_VAR 0 3
71048: PPUSH
71049: LD_EXP 85
71053: PUSH
71054: LD_VAR 0 2
71058: ARRAY
71059: PPUSH
71060: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71064: LD_VAR 0 3
71068: PPUSH
71069: CALL_OW 256
71073: PUSH
71074: LD_INT 1000
71076: LESS
71077: PUSH
71078: LD_VAR 0 3
71082: PPUSH
71083: LD_EXP 85
71087: PUSH
71088: LD_VAR 0 2
71092: ARRAY
71093: PPUSH
71094: CALL_OW 308
71098: AND
71099: IFFALSE 71103
// continue ;
71101: GO 70986
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71103: LD_VAR 0 3
71107: PPUSH
71108: CALL_OW 262
71112: PUSH
71113: LD_INT 2
71115: EQUAL
71116: PUSH
71117: LD_VAR 0 3
71121: PPUSH
71122: CALL_OW 261
71126: PUSH
71127: LD_INT 15
71129: LESS
71130: AND
71131: IFFALSE 71135
// continue ;
71133: GO 70986
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71135: LD_VAR 0 3
71139: PPUSH
71140: CALL_OW 262
71144: PUSH
71145: LD_INT 1
71147: EQUAL
71148: PUSH
71149: LD_VAR 0 3
71153: PPUSH
71154: CALL_OW 261
71158: PUSH
71159: LD_INT 10
71161: LESS
71162: AND
71163: IFFALSE 71443
// begin if not depot then
71165: LD_VAR 0 9
71169: NOT
71170: IFFALSE 71174
// continue ;
71172: GO 70986
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
71174: LD_VAR 0 3
71178: PPUSH
71179: LD_VAR 0 9
71183: PPUSH
71184: LD_VAR 0 3
71188: PPUSH
71189: CALL_OW 74
71193: PPUSH
71194: CALL_OW 296
71198: PUSH
71199: LD_INT 6
71201: LESS
71202: IFFALSE 71218
// SetFuel ( j , 100 ) else
71204: LD_VAR 0 3
71208: PPUSH
71209: LD_INT 100
71211: PPUSH
71212: CALL_OW 240
71216: GO 71443
// if GetFuel ( j ) = 0 then
71218: LD_VAR 0 3
71222: PPUSH
71223: CALL_OW 261
71227: PUSH
71228: LD_INT 0
71230: EQUAL
71231: IFFALSE 71443
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
71233: LD_ADDR_EXP 80
71237: PUSH
71238: LD_EXP 80
71242: PPUSH
71243: LD_VAR 0 2
71247: PPUSH
71248: LD_EXP 80
71252: PUSH
71253: LD_VAR 0 2
71257: ARRAY
71258: PUSH
71259: LD_VAR 0 3
71263: DIFF
71264: PPUSH
71265: CALL_OW 1
71269: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
71270: LD_VAR 0 3
71274: PPUSH
71275: CALL_OW 263
71279: PUSH
71280: LD_INT 1
71282: EQUAL
71283: IFFALSE 71299
// ComExitVehicle ( IsInUnit ( j ) ) ;
71285: LD_VAR 0 3
71289: PPUSH
71290: CALL_OW 310
71294: PPUSH
71295: CALL_OW 121
// if GetControl ( j ) = control_remote then
71299: LD_VAR 0 3
71303: PPUSH
71304: CALL_OW 263
71308: PUSH
71309: LD_INT 2
71311: EQUAL
71312: IFFALSE 71323
// ComUnlink ( j ) ;
71314: LD_VAR 0 3
71318: PPUSH
71319: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
71323: LD_ADDR_VAR 0 10
71327: PUSH
71328: LD_VAR 0 2
71332: PPUSH
71333: LD_INT 3
71335: PPUSH
71336: CALL 81110 0 2
71340: ST_TO_ADDR
// if fac then
71341: LD_VAR 0 10
71345: IFFALSE 71441
// begin for k in fac do
71347: LD_ADDR_VAR 0 4
71351: PUSH
71352: LD_VAR 0 10
71356: PUSH
71357: FOR_IN
71358: IFFALSE 71439
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
71360: LD_ADDR_VAR 0 11
71364: PUSH
71365: LD_VAR 0 10
71369: PPUSH
71370: LD_VAR 0 3
71374: PPUSH
71375: CALL_OW 265
71379: PPUSH
71380: LD_VAR 0 3
71384: PPUSH
71385: CALL_OW 262
71389: PPUSH
71390: LD_VAR 0 3
71394: PPUSH
71395: CALL_OW 263
71399: PPUSH
71400: LD_VAR 0 3
71404: PPUSH
71405: CALL_OW 264
71409: PPUSH
71410: CALL 17585 0 5
71414: ST_TO_ADDR
// if components then
71415: LD_VAR 0 11
71419: IFFALSE 71437
// begin MC_InsertProduceList ( i , components ) ;
71421: LD_VAR 0 2
71425: PPUSH
71426: LD_VAR 0 11
71430: PPUSH
71431: CALL 80655 0 2
// break ;
71435: GO 71439
// end ; end ;
71437: GO 71357
71439: POP
71440: POP
// end ; continue ;
71441: GO 70986
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
71443: LD_VAR 0 3
71447: PPUSH
71448: LD_INT 1
71450: PPUSH
71451: CALL_OW 289
71455: PUSH
71456: LD_INT 100
71458: LESS
71459: PUSH
71460: LD_VAR 0 3
71464: PPUSH
71465: CALL_OW 314
71469: NOT
71470: AND
71471: IFFALSE 71500
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71473: LD_VAR 0 3
71477: PPUSH
71478: LD_VAR 0 7
71482: PUSH
71483: LD_INT 2
71485: ARRAY
71486: PPUSH
71487: LD_VAR 0 7
71491: PUSH
71492: LD_INT 3
71494: ARRAY
71495: PPUSH
71496: CALL_OW 117
// break ;
71500: GO 71504
// end ;
71502: GO 70986
71504: POP
71505: POP
// end ; end ;
71506: GO 69702
71508: POP
71509: POP
// end ;
71510: LD_VAR 0 1
71514: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
71515: LD_INT 0
71517: PPUSH
71518: PPUSH
71519: PPUSH
71520: PPUSH
// if not mc_bases then
71521: LD_EXP 61
71525: NOT
71526: IFFALSE 71530
// exit ;
71528: GO 71691
// for i = 1 to mc_bases do
71530: LD_ADDR_VAR 0 2
71534: PUSH
71535: DOUBLE
71536: LD_INT 1
71538: DEC
71539: ST_TO_ADDR
71540: LD_EXP 61
71544: PUSH
71545: FOR_TO
71546: IFFALSE 71689
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
71548: LD_ADDR_VAR 0 4
71552: PUSH
71553: LD_EXP 80
71557: PUSH
71558: LD_VAR 0 2
71562: ARRAY
71563: PUSH
71564: LD_EXP 83
71568: PUSH
71569: LD_VAR 0 2
71573: ARRAY
71574: UNION
71575: PPUSH
71576: LD_INT 33
71578: PUSH
71579: LD_INT 2
71581: PUSH
71582: EMPTY
71583: LIST
71584: LIST
71585: PPUSH
71586: CALL_OW 72
71590: ST_TO_ADDR
// if tmp then
71591: LD_VAR 0 4
71595: IFFALSE 71687
// for j in tmp do
71597: LD_ADDR_VAR 0 3
71601: PUSH
71602: LD_VAR 0 4
71606: PUSH
71607: FOR_IN
71608: IFFALSE 71685
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
71610: LD_VAR 0 3
71614: PPUSH
71615: CALL_OW 312
71619: NOT
71620: PUSH
71621: LD_VAR 0 3
71625: PPUSH
71626: CALL_OW 256
71630: PUSH
71631: LD_INT 250
71633: GREATEREQUAL
71634: AND
71635: IFFALSE 71648
// Connect ( j ) else
71637: LD_VAR 0 3
71641: PPUSH
71642: CALL 23056 0 1
71646: GO 71683
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
71648: LD_VAR 0 3
71652: PPUSH
71653: CALL_OW 256
71657: PUSH
71658: LD_INT 250
71660: LESS
71661: PUSH
71662: LD_VAR 0 3
71666: PPUSH
71667: CALL_OW 312
71671: AND
71672: IFFALSE 71683
// ComUnlink ( j ) ;
71674: LD_VAR 0 3
71678: PPUSH
71679: CALL_OW 136
71683: GO 71607
71685: POP
71686: POP
// end ;
71687: GO 71545
71689: POP
71690: POP
// end ;
71691: LD_VAR 0 1
71695: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
71696: LD_INT 0
71698: PPUSH
71699: PPUSH
71700: PPUSH
71701: PPUSH
71702: PPUSH
// if not mc_bases then
71703: LD_EXP 61
71707: NOT
71708: IFFALSE 71712
// exit ;
71710: GO 72157
// for i = 1 to mc_bases do
71712: LD_ADDR_VAR 0 2
71716: PUSH
71717: DOUBLE
71718: LD_INT 1
71720: DEC
71721: ST_TO_ADDR
71722: LD_EXP 61
71726: PUSH
71727: FOR_TO
71728: IFFALSE 72155
// begin if not mc_produce [ i ] then
71730: LD_EXP 82
71734: PUSH
71735: LD_VAR 0 2
71739: ARRAY
71740: NOT
71741: IFFALSE 71745
// continue ;
71743: GO 71727
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71745: LD_ADDR_VAR 0 5
71749: PUSH
71750: LD_EXP 61
71754: PUSH
71755: LD_VAR 0 2
71759: ARRAY
71760: PPUSH
71761: LD_INT 30
71763: PUSH
71764: LD_INT 3
71766: PUSH
71767: EMPTY
71768: LIST
71769: LIST
71770: PPUSH
71771: CALL_OW 72
71775: ST_TO_ADDR
// if not fac then
71776: LD_VAR 0 5
71780: NOT
71781: IFFALSE 71785
// continue ;
71783: GO 71727
// for j in fac do
71785: LD_ADDR_VAR 0 3
71789: PUSH
71790: LD_VAR 0 5
71794: PUSH
71795: FOR_IN
71796: IFFALSE 72151
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
71798: LD_VAR 0 3
71802: PPUSH
71803: CALL_OW 461
71807: PUSH
71808: LD_INT 2
71810: NONEQUAL
71811: PUSH
71812: LD_VAR 0 3
71816: PPUSH
71817: LD_INT 15
71819: PPUSH
71820: CALL 22684 0 2
71824: PUSH
71825: LD_INT 4
71827: ARRAY
71828: OR
71829: IFFALSE 71833
// continue ;
71831: GO 71795
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
71833: LD_VAR 0 3
71837: PPUSH
71838: LD_EXP 82
71842: PUSH
71843: LD_VAR 0 2
71847: ARRAY
71848: PUSH
71849: LD_INT 1
71851: ARRAY
71852: PUSH
71853: LD_INT 1
71855: ARRAY
71856: PPUSH
71857: LD_EXP 82
71861: PUSH
71862: LD_VAR 0 2
71866: ARRAY
71867: PUSH
71868: LD_INT 1
71870: ARRAY
71871: PUSH
71872: LD_INT 2
71874: ARRAY
71875: PPUSH
71876: LD_EXP 82
71880: PUSH
71881: LD_VAR 0 2
71885: ARRAY
71886: PUSH
71887: LD_INT 1
71889: ARRAY
71890: PUSH
71891: LD_INT 3
71893: ARRAY
71894: PPUSH
71895: LD_EXP 82
71899: PUSH
71900: LD_VAR 0 2
71904: ARRAY
71905: PUSH
71906: LD_INT 1
71908: ARRAY
71909: PUSH
71910: LD_INT 4
71912: ARRAY
71913: PPUSH
71914: CALL_OW 448
71918: PUSH
71919: LD_VAR 0 3
71923: PPUSH
71924: LD_EXP 82
71928: PUSH
71929: LD_VAR 0 2
71933: ARRAY
71934: PUSH
71935: LD_INT 1
71937: ARRAY
71938: PUSH
71939: LD_INT 1
71941: ARRAY
71942: PUSH
71943: LD_EXP 82
71947: PUSH
71948: LD_VAR 0 2
71952: ARRAY
71953: PUSH
71954: LD_INT 1
71956: ARRAY
71957: PUSH
71958: LD_INT 2
71960: ARRAY
71961: PUSH
71962: LD_EXP 82
71966: PUSH
71967: LD_VAR 0 2
71971: ARRAY
71972: PUSH
71973: LD_INT 1
71975: ARRAY
71976: PUSH
71977: LD_INT 3
71979: ARRAY
71980: PUSH
71981: LD_EXP 82
71985: PUSH
71986: LD_VAR 0 2
71990: ARRAY
71991: PUSH
71992: LD_INT 1
71994: ARRAY
71995: PUSH
71996: LD_INT 4
71998: ARRAY
71999: PUSH
72000: EMPTY
72001: LIST
72002: LIST
72003: LIST
72004: LIST
72005: PPUSH
72006: CALL 26451 0 2
72010: AND
72011: IFFALSE 72149
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
72013: LD_VAR 0 3
72017: PPUSH
72018: LD_EXP 82
72022: PUSH
72023: LD_VAR 0 2
72027: ARRAY
72028: PUSH
72029: LD_INT 1
72031: ARRAY
72032: PUSH
72033: LD_INT 1
72035: ARRAY
72036: PPUSH
72037: LD_EXP 82
72041: PUSH
72042: LD_VAR 0 2
72046: ARRAY
72047: PUSH
72048: LD_INT 1
72050: ARRAY
72051: PUSH
72052: LD_INT 2
72054: ARRAY
72055: PPUSH
72056: LD_EXP 82
72060: PUSH
72061: LD_VAR 0 2
72065: ARRAY
72066: PUSH
72067: LD_INT 1
72069: ARRAY
72070: PUSH
72071: LD_INT 3
72073: ARRAY
72074: PPUSH
72075: LD_EXP 82
72079: PUSH
72080: LD_VAR 0 2
72084: ARRAY
72085: PUSH
72086: LD_INT 1
72088: ARRAY
72089: PUSH
72090: LD_INT 4
72092: ARRAY
72093: PPUSH
72094: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
72098: LD_ADDR_VAR 0 4
72102: PUSH
72103: LD_EXP 82
72107: PUSH
72108: LD_VAR 0 2
72112: ARRAY
72113: PPUSH
72114: LD_INT 1
72116: PPUSH
72117: CALL_OW 3
72121: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
72122: LD_ADDR_EXP 82
72126: PUSH
72127: LD_EXP 82
72131: PPUSH
72132: LD_VAR 0 2
72136: PPUSH
72137: LD_VAR 0 4
72141: PPUSH
72142: CALL_OW 1
72146: ST_TO_ADDR
// break ;
72147: GO 72151
// end ; end ;
72149: GO 71795
72151: POP
72152: POP
// end ;
72153: GO 71727
72155: POP
72156: POP
// end ;
72157: LD_VAR 0 1
72161: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
72162: LD_INT 0
72164: PPUSH
72165: PPUSH
72166: PPUSH
// if not mc_bases then
72167: LD_EXP 61
72171: NOT
72172: IFFALSE 72176
// exit ;
72174: GO 72265
// for i = 1 to mc_bases do
72176: LD_ADDR_VAR 0 2
72180: PUSH
72181: DOUBLE
72182: LD_INT 1
72184: DEC
72185: ST_TO_ADDR
72186: LD_EXP 61
72190: PUSH
72191: FOR_TO
72192: IFFALSE 72263
// begin if mc_attack [ i ] then
72194: LD_EXP 81
72198: PUSH
72199: LD_VAR 0 2
72203: ARRAY
72204: IFFALSE 72261
// begin tmp := mc_attack [ i ] [ 1 ] ;
72206: LD_ADDR_VAR 0 3
72210: PUSH
72211: LD_EXP 81
72215: PUSH
72216: LD_VAR 0 2
72220: ARRAY
72221: PUSH
72222: LD_INT 1
72224: ARRAY
72225: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
72226: LD_ADDR_EXP 81
72230: PUSH
72231: LD_EXP 81
72235: PPUSH
72236: LD_VAR 0 2
72240: PPUSH
72241: EMPTY
72242: PPUSH
72243: CALL_OW 1
72247: ST_TO_ADDR
// Attack ( tmp ) ;
72248: LD_VAR 0 3
72252: PPUSH
72253: CALL 107164 0 1
// exit ;
72257: POP
72258: POP
72259: GO 72265
// end ; end ;
72261: GO 72191
72263: POP
72264: POP
// end ;
72265: LD_VAR 0 1
72269: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
72270: LD_INT 0
72272: PPUSH
72273: PPUSH
72274: PPUSH
72275: PPUSH
72276: PPUSH
72277: PPUSH
72278: PPUSH
// if not mc_bases then
72279: LD_EXP 61
72283: NOT
72284: IFFALSE 72288
// exit ;
72286: GO 73145
// for i = 1 to mc_bases do
72288: LD_ADDR_VAR 0 2
72292: PUSH
72293: DOUBLE
72294: LD_INT 1
72296: DEC
72297: ST_TO_ADDR
72298: LD_EXP 61
72302: PUSH
72303: FOR_TO
72304: IFFALSE 73143
// begin if not mc_bases [ i ] then
72306: LD_EXP 61
72310: PUSH
72311: LD_VAR 0 2
72315: ARRAY
72316: NOT
72317: IFFALSE 72321
// continue ;
72319: GO 72303
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
72321: LD_ADDR_VAR 0 7
72325: PUSH
72326: LD_EXP 61
72330: PUSH
72331: LD_VAR 0 2
72335: ARRAY
72336: PUSH
72337: LD_INT 1
72339: ARRAY
72340: PPUSH
72341: CALL 16736 0 1
72345: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
72346: LD_ADDR_EXP 84
72350: PUSH
72351: LD_EXP 84
72355: PPUSH
72356: LD_VAR 0 2
72360: PPUSH
72361: LD_EXP 61
72365: PUSH
72366: LD_VAR 0 2
72370: ARRAY
72371: PUSH
72372: LD_INT 1
72374: ARRAY
72375: PPUSH
72376: CALL_OW 255
72380: PPUSH
72381: LD_EXP 86
72385: PUSH
72386: LD_VAR 0 2
72390: ARRAY
72391: PPUSH
72392: CALL 16701 0 2
72396: PPUSH
72397: CALL_OW 1
72401: ST_TO_ADDR
// if not mc_scan [ i ] then
72402: LD_EXP 84
72406: PUSH
72407: LD_VAR 0 2
72411: ARRAY
72412: NOT
72413: IFFALSE 72591
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
72415: LD_ADDR_EXP 104
72419: PUSH
72420: LD_EXP 104
72424: PPUSH
72425: LD_VAR 0 2
72429: PPUSH
72430: LD_INT 0
72432: PPUSH
72433: CALL_OW 1
72437: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72438: LD_ADDR_VAR 0 4
72442: PUSH
72443: LD_EXP 61
72447: PUSH
72448: LD_VAR 0 2
72452: ARRAY
72453: PPUSH
72454: LD_INT 2
72456: PUSH
72457: LD_INT 25
72459: PUSH
72460: LD_INT 5
72462: PUSH
72463: EMPTY
72464: LIST
72465: LIST
72466: PUSH
72467: LD_INT 25
72469: PUSH
72470: LD_INT 8
72472: PUSH
72473: EMPTY
72474: LIST
72475: LIST
72476: PUSH
72477: LD_INT 25
72479: PUSH
72480: LD_INT 9
72482: PUSH
72483: EMPTY
72484: LIST
72485: LIST
72486: PUSH
72487: EMPTY
72488: LIST
72489: LIST
72490: LIST
72491: LIST
72492: PPUSH
72493: CALL_OW 72
72497: ST_TO_ADDR
// if not tmp then
72498: LD_VAR 0 4
72502: NOT
72503: IFFALSE 72507
// continue ;
72505: GO 72303
// for j in tmp do
72507: LD_ADDR_VAR 0 3
72511: PUSH
72512: LD_VAR 0 4
72516: PUSH
72517: FOR_IN
72518: IFFALSE 72589
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
72520: LD_VAR 0 3
72524: PPUSH
72525: CALL_OW 310
72529: PPUSH
72530: CALL_OW 266
72534: PUSH
72535: LD_INT 5
72537: EQUAL
72538: PUSH
72539: LD_VAR 0 3
72543: PPUSH
72544: CALL_OW 257
72548: PUSH
72549: LD_INT 1
72551: EQUAL
72552: AND
72553: PUSH
72554: LD_VAR 0 3
72558: PPUSH
72559: CALL_OW 459
72563: NOT
72564: AND
72565: PUSH
72566: LD_VAR 0 7
72570: AND
72571: IFFALSE 72587
// ComChangeProfession ( j , class ) ;
72573: LD_VAR 0 3
72577: PPUSH
72578: LD_VAR 0 7
72582: PPUSH
72583: CALL_OW 123
72587: GO 72517
72589: POP
72590: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
72591: LD_EXP 84
72595: PUSH
72596: LD_VAR 0 2
72600: ARRAY
72601: PUSH
72602: LD_EXP 104
72606: PUSH
72607: LD_VAR 0 2
72611: ARRAY
72612: NOT
72613: AND
72614: PUSH
72615: LD_EXP 83
72619: PUSH
72620: LD_VAR 0 2
72624: ARRAY
72625: NOT
72626: AND
72627: PUSH
72628: LD_EXP 61
72632: PUSH
72633: LD_VAR 0 2
72637: ARRAY
72638: PPUSH
72639: LD_INT 50
72641: PUSH
72642: EMPTY
72643: LIST
72644: PUSH
72645: LD_INT 2
72647: PUSH
72648: LD_INT 30
72650: PUSH
72651: LD_INT 32
72653: PUSH
72654: EMPTY
72655: LIST
72656: LIST
72657: PUSH
72658: LD_INT 30
72660: PUSH
72661: LD_INT 33
72663: PUSH
72664: EMPTY
72665: LIST
72666: LIST
72667: PUSH
72668: LD_INT 30
72670: PUSH
72671: LD_INT 4
72673: PUSH
72674: EMPTY
72675: LIST
72676: LIST
72677: PUSH
72678: LD_INT 30
72680: PUSH
72681: LD_INT 5
72683: PUSH
72684: EMPTY
72685: LIST
72686: LIST
72687: PUSH
72688: EMPTY
72689: LIST
72690: LIST
72691: LIST
72692: LIST
72693: LIST
72694: PUSH
72695: EMPTY
72696: LIST
72697: LIST
72698: PPUSH
72699: CALL_OW 72
72703: PUSH
72704: LD_INT 4
72706: LESS
72707: PUSH
72708: LD_EXP 61
72712: PUSH
72713: LD_VAR 0 2
72717: ARRAY
72718: PPUSH
72719: LD_INT 3
72721: PUSH
72722: LD_INT 24
72724: PUSH
72725: LD_INT 1000
72727: PUSH
72728: EMPTY
72729: LIST
72730: LIST
72731: PUSH
72732: EMPTY
72733: LIST
72734: LIST
72735: PUSH
72736: LD_INT 2
72738: PUSH
72739: LD_INT 30
72741: PUSH
72742: LD_INT 0
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: PUSH
72749: LD_INT 30
72751: PUSH
72752: LD_INT 1
72754: PUSH
72755: EMPTY
72756: LIST
72757: LIST
72758: PUSH
72759: EMPTY
72760: LIST
72761: LIST
72762: LIST
72763: PUSH
72764: EMPTY
72765: LIST
72766: LIST
72767: PPUSH
72768: CALL_OW 72
72772: OR
72773: AND
72774: IFFALSE 73025
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
72776: LD_ADDR_EXP 104
72780: PUSH
72781: LD_EXP 104
72785: PPUSH
72786: LD_VAR 0 2
72790: PPUSH
72791: LD_INT 1
72793: PPUSH
72794: CALL_OW 1
72798: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72799: LD_ADDR_VAR 0 4
72803: PUSH
72804: LD_EXP 61
72808: PUSH
72809: LD_VAR 0 2
72813: ARRAY
72814: PPUSH
72815: LD_INT 2
72817: PUSH
72818: LD_INT 25
72820: PUSH
72821: LD_INT 1
72823: PUSH
72824: EMPTY
72825: LIST
72826: LIST
72827: PUSH
72828: LD_INT 25
72830: PUSH
72831: LD_INT 5
72833: PUSH
72834: EMPTY
72835: LIST
72836: LIST
72837: PUSH
72838: LD_INT 25
72840: PUSH
72841: LD_INT 8
72843: PUSH
72844: EMPTY
72845: LIST
72846: LIST
72847: PUSH
72848: LD_INT 25
72850: PUSH
72851: LD_INT 9
72853: PUSH
72854: EMPTY
72855: LIST
72856: LIST
72857: PUSH
72858: EMPTY
72859: LIST
72860: LIST
72861: LIST
72862: LIST
72863: LIST
72864: PPUSH
72865: CALL_OW 72
72869: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
72870: LD_ADDR_VAR 0 4
72874: PUSH
72875: LD_VAR 0 4
72879: PUSH
72880: LD_VAR 0 4
72884: PPUSH
72885: LD_INT 18
72887: PPUSH
72888: CALL 49999 0 2
72892: DIFF
72893: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
72894: LD_VAR 0 4
72898: NOT
72899: PUSH
72900: LD_EXP 61
72904: PUSH
72905: LD_VAR 0 2
72909: ARRAY
72910: PPUSH
72911: LD_INT 2
72913: PUSH
72914: LD_INT 30
72916: PUSH
72917: LD_INT 4
72919: PUSH
72920: EMPTY
72921: LIST
72922: LIST
72923: PUSH
72924: LD_INT 30
72926: PUSH
72927: LD_INT 5
72929: PUSH
72930: EMPTY
72931: LIST
72932: LIST
72933: PUSH
72934: EMPTY
72935: LIST
72936: LIST
72937: LIST
72938: PPUSH
72939: CALL_OW 72
72943: NOT
72944: AND
72945: IFFALSE 73007
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
72947: LD_ADDR_VAR 0 4
72951: PUSH
72952: LD_EXP 61
72956: PUSH
72957: LD_VAR 0 2
72961: ARRAY
72962: PPUSH
72963: LD_INT 2
72965: PUSH
72966: LD_INT 25
72968: PUSH
72969: LD_INT 2
72971: PUSH
72972: EMPTY
72973: LIST
72974: LIST
72975: PUSH
72976: LD_INT 25
72978: PUSH
72979: LD_INT 3
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: PUSH
72986: LD_INT 25
72988: PUSH
72989: LD_INT 4
72991: PUSH
72992: EMPTY
72993: LIST
72994: LIST
72995: PUSH
72996: EMPTY
72997: LIST
72998: LIST
72999: LIST
73000: LIST
73001: PPUSH
73002: CALL_OW 72
73006: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
73007: LD_VAR 0 2
73011: PPUSH
73012: LD_VAR 0 4
73016: PPUSH
73017: CALL 111873 0 2
// exit ;
73021: POP
73022: POP
73023: GO 73145
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
73025: LD_EXP 84
73029: PUSH
73030: LD_VAR 0 2
73034: ARRAY
73035: PUSH
73036: LD_EXP 104
73040: PUSH
73041: LD_VAR 0 2
73045: ARRAY
73046: NOT
73047: AND
73048: PUSH
73049: LD_EXP 83
73053: PUSH
73054: LD_VAR 0 2
73058: ARRAY
73059: AND
73060: IFFALSE 73141
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
73062: LD_ADDR_EXP 104
73066: PUSH
73067: LD_EXP 104
73071: PPUSH
73072: LD_VAR 0 2
73076: PPUSH
73077: LD_INT 1
73079: PPUSH
73080: CALL_OW 1
73084: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
73085: LD_ADDR_VAR 0 4
73089: PUSH
73090: LD_EXP 83
73094: PUSH
73095: LD_VAR 0 2
73099: ARRAY
73100: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
73101: LD_ADDR_EXP 83
73105: PUSH
73106: LD_EXP 83
73110: PPUSH
73111: LD_VAR 0 2
73115: PPUSH
73116: EMPTY
73117: PPUSH
73118: CALL_OW 1
73122: ST_TO_ADDR
// Defend ( i , tmp ) ;
73123: LD_VAR 0 2
73127: PPUSH
73128: LD_VAR 0 4
73132: PPUSH
73133: CALL 112469 0 2
// exit ;
73137: POP
73138: POP
73139: GO 73145
// end ; end ;
73141: GO 72303
73143: POP
73144: POP
// end ;
73145: LD_VAR 0 1
73149: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73150: LD_INT 0
73152: PPUSH
73153: PPUSH
73154: PPUSH
73155: PPUSH
73156: PPUSH
73157: PPUSH
73158: PPUSH
73159: PPUSH
73160: PPUSH
73161: PPUSH
73162: PPUSH
// if not mc_bases then
73163: LD_EXP 61
73167: NOT
73168: IFFALSE 73172
// exit ;
73170: GO 74259
// for i = 1 to mc_bases do
73172: LD_ADDR_VAR 0 2
73176: PUSH
73177: DOUBLE
73178: LD_INT 1
73180: DEC
73181: ST_TO_ADDR
73182: LD_EXP 61
73186: PUSH
73187: FOR_TO
73188: IFFALSE 74257
// begin tmp := mc_lab [ i ] ;
73190: LD_ADDR_VAR 0 6
73194: PUSH
73195: LD_EXP 94
73199: PUSH
73200: LD_VAR 0 2
73204: ARRAY
73205: ST_TO_ADDR
// if not tmp then
73206: LD_VAR 0 6
73210: NOT
73211: IFFALSE 73215
// continue ;
73213: GO 73187
// idle_lab := 0 ;
73215: LD_ADDR_VAR 0 11
73219: PUSH
73220: LD_INT 0
73222: ST_TO_ADDR
// for j in tmp do
73223: LD_ADDR_VAR 0 3
73227: PUSH
73228: LD_VAR 0 6
73232: PUSH
73233: FOR_IN
73234: IFFALSE 74253
// begin researching := false ;
73236: LD_ADDR_VAR 0 10
73240: PUSH
73241: LD_INT 0
73243: ST_TO_ADDR
// side := GetSide ( j ) ;
73244: LD_ADDR_VAR 0 4
73248: PUSH
73249: LD_VAR 0 3
73253: PPUSH
73254: CALL_OW 255
73258: ST_TO_ADDR
// if not mc_tech [ side ] then
73259: LD_EXP 88
73263: PUSH
73264: LD_VAR 0 4
73268: ARRAY
73269: NOT
73270: IFFALSE 73274
// continue ;
73272: GO 73233
// if BuildingStatus ( j ) = bs_idle then
73274: LD_VAR 0 3
73278: PPUSH
73279: CALL_OW 461
73283: PUSH
73284: LD_INT 2
73286: EQUAL
73287: IFFALSE 73475
// begin if idle_lab and UnitsInside ( j ) < 6 then
73289: LD_VAR 0 11
73293: PUSH
73294: LD_VAR 0 3
73298: PPUSH
73299: CALL_OW 313
73303: PUSH
73304: LD_INT 6
73306: LESS
73307: AND
73308: IFFALSE 73379
// begin tmp2 := UnitsInside ( idle_lab ) ;
73310: LD_ADDR_VAR 0 9
73314: PUSH
73315: LD_VAR 0 11
73319: PPUSH
73320: CALL_OW 313
73324: ST_TO_ADDR
// if tmp2 then
73325: LD_VAR 0 9
73329: IFFALSE 73371
// for x in tmp2 do
73331: LD_ADDR_VAR 0 7
73335: PUSH
73336: LD_VAR 0 9
73340: PUSH
73341: FOR_IN
73342: IFFALSE 73369
// begin ComExitBuilding ( x ) ;
73344: LD_VAR 0 7
73348: PPUSH
73349: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73353: LD_VAR 0 7
73357: PPUSH
73358: LD_VAR 0 3
73362: PPUSH
73363: CALL_OW 180
// end ;
73367: GO 73341
73369: POP
73370: POP
// idle_lab := 0 ;
73371: LD_ADDR_VAR 0 11
73375: PUSH
73376: LD_INT 0
73378: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
73379: LD_ADDR_VAR 0 5
73383: PUSH
73384: LD_EXP 88
73388: PUSH
73389: LD_VAR 0 4
73393: ARRAY
73394: PUSH
73395: FOR_IN
73396: IFFALSE 73456
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
73398: LD_VAR 0 3
73402: PPUSH
73403: LD_VAR 0 5
73407: PPUSH
73408: CALL_OW 430
73412: PUSH
73413: LD_VAR 0 4
73417: PPUSH
73418: LD_VAR 0 5
73422: PPUSH
73423: CALL 15806 0 2
73427: AND
73428: IFFALSE 73454
// begin researching := true ;
73430: LD_ADDR_VAR 0 10
73434: PUSH
73435: LD_INT 1
73437: ST_TO_ADDR
// ComResearch ( j , t ) ;
73438: LD_VAR 0 3
73442: PPUSH
73443: LD_VAR 0 5
73447: PPUSH
73448: CALL_OW 124
// break ;
73452: GO 73456
// end ;
73454: GO 73395
73456: POP
73457: POP
// if not researching then
73458: LD_VAR 0 10
73462: NOT
73463: IFFALSE 73475
// idle_lab := j ;
73465: LD_ADDR_VAR 0 11
73469: PUSH
73470: LD_VAR 0 3
73474: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
73475: LD_VAR 0 3
73479: PPUSH
73480: CALL_OW 461
73484: PUSH
73485: LD_INT 10
73487: EQUAL
73488: IFFALSE 74076
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
73490: LD_EXP 90
73494: PUSH
73495: LD_VAR 0 2
73499: ARRAY
73500: NOT
73501: PUSH
73502: LD_EXP 91
73506: PUSH
73507: LD_VAR 0 2
73511: ARRAY
73512: NOT
73513: AND
73514: PUSH
73515: LD_EXP 88
73519: PUSH
73520: LD_VAR 0 4
73524: ARRAY
73525: PUSH
73526: LD_INT 1
73528: GREATER
73529: AND
73530: IFFALSE 73661
// begin ComCancel ( j ) ;
73532: LD_VAR 0 3
73536: PPUSH
73537: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
73541: LD_ADDR_EXP 88
73545: PUSH
73546: LD_EXP 88
73550: PPUSH
73551: LD_VAR 0 4
73555: PPUSH
73556: LD_EXP 88
73560: PUSH
73561: LD_VAR 0 4
73565: ARRAY
73566: PPUSH
73567: LD_EXP 88
73571: PUSH
73572: LD_VAR 0 4
73576: ARRAY
73577: PUSH
73578: LD_INT 1
73580: MINUS
73581: PPUSH
73582: LD_EXP 88
73586: PUSH
73587: LD_VAR 0 4
73591: ARRAY
73592: PPUSH
73593: LD_INT 0
73595: PPUSH
73596: CALL 19505 0 4
73600: PPUSH
73601: CALL_OW 1
73605: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
73606: LD_ADDR_EXP 88
73610: PUSH
73611: LD_EXP 88
73615: PPUSH
73616: LD_VAR 0 4
73620: PPUSH
73621: LD_EXP 88
73625: PUSH
73626: LD_VAR 0 4
73630: ARRAY
73631: PPUSH
73632: LD_EXP 88
73636: PUSH
73637: LD_VAR 0 4
73641: ARRAY
73642: PPUSH
73643: LD_INT 1
73645: PPUSH
73646: LD_INT 0
73648: PPUSH
73649: CALL 19505 0 4
73653: PPUSH
73654: CALL_OW 1
73658: ST_TO_ADDR
// continue ;
73659: GO 73233
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
73661: LD_EXP 90
73665: PUSH
73666: LD_VAR 0 2
73670: ARRAY
73671: PUSH
73672: LD_EXP 91
73676: PUSH
73677: LD_VAR 0 2
73681: ARRAY
73682: NOT
73683: AND
73684: IFFALSE 73811
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
73686: LD_ADDR_EXP 91
73690: PUSH
73691: LD_EXP 91
73695: PPUSH
73696: LD_VAR 0 2
73700: PUSH
73701: LD_EXP 91
73705: PUSH
73706: LD_VAR 0 2
73710: ARRAY
73711: PUSH
73712: LD_INT 1
73714: PLUS
73715: PUSH
73716: EMPTY
73717: LIST
73718: LIST
73719: PPUSH
73720: LD_EXP 90
73724: PUSH
73725: LD_VAR 0 2
73729: ARRAY
73730: PUSH
73731: LD_INT 1
73733: ARRAY
73734: PPUSH
73735: CALL 20087 0 3
73739: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
73740: LD_EXP 90
73744: PUSH
73745: LD_VAR 0 2
73749: ARRAY
73750: PUSH
73751: LD_INT 1
73753: ARRAY
73754: PPUSH
73755: LD_INT 112
73757: PPUSH
73758: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
73762: LD_ADDR_VAR 0 9
73766: PUSH
73767: LD_EXP 90
73771: PUSH
73772: LD_VAR 0 2
73776: ARRAY
73777: PPUSH
73778: LD_INT 1
73780: PPUSH
73781: CALL_OW 3
73785: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
73786: LD_ADDR_EXP 90
73790: PUSH
73791: LD_EXP 90
73795: PPUSH
73796: LD_VAR 0 2
73800: PPUSH
73801: LD_VAR 0 9
73805: PPUSH
73806: CALL_OW 1
73810: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
73811: LD_EXP 90
73815: PUSH
73816: LD_VAR 0 2
73820: ARRAY
73821: PUSH
73822: LD_EXP 91
73826: PUSH
73827: LD_VAR 0 2
73831: ARRAY
73832: AND
73833: PUSH
73834: LD_EXP 91
73838: PUSH
73839: LD_VAR 0 2
73843: ARRAY
73844: PUSH
73845: LD_INT 1
73847: ARRAY
73848: PPUSH
73849: CALL_OW 310
73853: NOT
73854: AND
73855: PUSH
73856: LD_VAR 0 3
73860: PPUSH
73861: CALL_OW 313
73865: PUSH
73866: LD_INT 6
73868: EQUAL
73869: AND
73870: IFFALSE 73926
// begin tmp2 := UnitsInside ( j ) ;
73872: LD_ADDR_VAR 0 9
73876: PUSH
73877: LD_VAR 0 3
73881: PPUSH
73882: CALL_OW 313
73886: ST_TO_ADDR
// if tmp2 = 6 then
73887: LD_VAR 0 9
73891: PUSH
73892: LD_INT 6
73894: EQUAL
73895: IFFALSE 73926
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
73897: LD_VAR 0 9
73901: PUSH
73902: LD_INT 1
73904: ARRAY
73905: PPUSH
73906: LD_INT 112
73908: PPUSH
73909: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
73913: LD_VAR 0 9
73917: PUSH
73918: LD_INT 1
73920: ARRAY
73921: PPUSH
73922: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
73926: LD_EXP 91
73930: PUSH
73931: LD_VAR 0 2
73935: ARRAY
73936: PUSH
73937: LD_EXP 91
73941: PUSH
73942: LD_VAR 0 2
73946: ARRAY
73947: PUSH
73948: LD_INT 1
73950: ARRAY
73951: PPUSH
73952: CALL_OW 314
73956: NOT
73957: AND
73958: PUSH
73959: LD_EXP 91
73963: PUSH
73964: LD_VAR 0 2
73968: ARRAY
73969: PUSH
73970: LD_INT 1
73972: ARRAY
73973: PPUSH
73974: CALL_OW 310
73978: NOT
73979: AND
73980: IFFALSE 74006
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
73982: LD_EXP 91
73986: PUSH
73987: LD_VAR 0 2
73991: ARRAY
73992: PUSH
73993: LD_INT 1
73995: ARRAY
73996: PPUSH
73997: LD_VAR 0 3
74001: PPUSH
74002: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
74006: LD_EXP 91
74010: PUSH
74011: LD_VAR 0 2
74015: ARRAY
74016: PUSH
74017: LD_INT 1
74019: ARRAY
74020: PPUSH
74021: CALL_OW 310
74025: PUSH
74026: LD_EXP 91
74030: PUSH
74031: LD_VAR 0 2
74035: ARRAY
74036: PUSH
74037: LD_INT 1
74039: ARRAY
74040: PPUSH
74041: CALL_OW 310
74045: PPUSH
74046: CALL_OW 461
74050: PUSH
74051: LD_INT 3
74053: NONEQUAL
74054: AND
74055: IFFALSE 74076
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74057: LD_EXP 91
74061: PUSH
74062: LD_VAR 0 2
74066: ARRAY
74067: PUSH
74068: LD_INT 1
74070: ARRAY
74071: PPUSH
74072: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74076: LD_VAR 0 3
74080: PPUSH
74081: CALL_OW 461
74085: PUSH
74086: LD_INT 6
74088: EQUAL
74089: PUSH
74090: LD_VAR 0 6
74094: PUSH
74095: LD_INT 1
74097: GREATER
74098: AND
74099: IFFALSE 74251
// begin sci := [ ] ;
74101: LD_ADDR_VAR 0 8
74105: PUSH
74106: EMPTY
74107: ST_TO_ADDR
// for x in ( tmp diff j ) do
74108: LD_ADDR_VAR 0 7
74112: PUSH
74113: LD_VAR 0 6
74117: PUSH
74118: LD_VAR 0 3
74122: DIFF
74123: PUSH
74124: FOR_IN
74125: IFFALSE 74177
// begin if sci = 6 then
74127: LD_VAR 0 8
74131: PUSH
74132: LD_INT 6
74134: EQUAL
74135: IFFALSE 74139
// break ;
74137: GO 74177
// if BuildingStatus ( x ) = bs_idle then
74139: LD_VAR 0 7
74143: PPUSH
74144: CALL_OW 461
74148: PUSH
74149: LD_INT 2
74151: EQUAL
74152: IFFALSE 74175
// sci := sci ^ UnitsInside ( x ) ;
74154: LD_ADDR_VAR 0 8
74158: PUSH
74159: LD_VAR 0 8
74163: PUSH
74164: LD_VAR 0 7
74168: PPUSH
74169: CALL_OW 313
74173: ADD
74174: ST_TO_ADDR
// end ;
74175: GO 74124
74177: POP
74178: POP
// if not sci then
74179: LD_VAR 0 8
74183: NOT
74184: IFFALSE 74188
// continue ;
74186: GO 73233
// for x in sci do
74188: LD_ADDR_VAR 0 7
74192: PUSH
74193: LD_VAR 0 8
74197: PUSH
74198: FOR_IN
74199: IFFALSE 74249
// if IsInUnit ( x ) and not HasTask ( x ) then
74201: LD_VAR 0 7
74205: PPUSH
74206: CALL_OW 310
74210: PUSH
74211: LD_VAR 0 7
74215: PPUSH
74216: CALL_OW 314
74220: NOT
74221: AND
74222: IFFALSE 74247
// begin ComExitBuilding ( x ) ;
74224: LD_VAR 0 7
74228: PPUSH
74229: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74233: LD_VAR 0 7
74237: PPUSH
74238: LD_VAR 0 3
74242: PPUSH
74243: CALL_OW 180
// end ;
74247: GO 74198
74249: POP
74250: POP
// end ; end ;
74251: GO 73233
74253: POP
74254: POP
// end ;
74255: GO 73187
74257: POP
74258: POP
// end ;
74259: LD_VAR 0 1
74263: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74264: LD_INT 0
74266: PPUSH
74267: PPUSH
// if not mc_bases then
74268: LD_EXP 61
74272: NOT
74273: IFFALSE 74277
// exit ;
74275: GO 74358
// for i = 1 to mc_bases do
74277: LD_ADDR_VAR 0 2
74281: PUSH
74282: DOUBLE
74283: LD_INT 1
74285: DEC
74286: ST_TO_ADDR
74287: LD_EXP 61
74291: PUSH
74292: FOR_TO
74293: IFFALSE 74356
// if mc_mines [ i ] and mc_miners [ i ] then
74295: LD_EXP 74
74299: PUSH
74300: LD_VAR 0 2
74304: ARRAY
74305: PUSH
74306: LD_EXP 75
74310: PUSH
74311: LD_VAR 0 2
74315: ARRAY
74316: AND
74317: IFFALSE 74354
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74319: LD_EXP 75
74323: PUSH
74324: LD_VAR 0 2
74328: ARRAY
74329: PUSH
74330: LD_INT 1
74332: ARRAY
74333: PPUSH
74334: CALL_OW 255
74338: PPUSH
74339: LD_EXP 74
74343: PUSH
74344: LD_VAR 0 2
74348: ARRAY
74349: PPUSH
74350: CALL 16889 0 2
74354: GO 74292
74356: POP
74357: POP
// end ;
74358: LD_VAR 0 1
74362: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
74363: LD_INT 0
74365: PPUSH
74366: PPUSH
74367: PPUSH
74368: PPUSH
74369: PPUSH
74370: PPUSH
74371: PPUSH
74372: PPUSH
// if not mc_bases or not mc_parking then
74373: LD_EXP 61
74377: NOT
74378: PUSH
74379: LD_EXP 85
74383: NOT
74384: OR
74385: IFFALSE 74389
// exit ;
74387: GO 75127
// for i = 1 to mc_bases do
74389: LD_ADDR_VAR 0 2
74393: PUSH
74394: DOUBLE
74395: LD_INT 1
74397: DEC
74398: ST_TO_ADDR
74399: LD_EXP 61
74403: PUSH
74404: FOR_TO
74405: IFFALSE 75125
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
74407: LD_EXP 61
74411: PUSH
74412: LD_VAR 0 2
74416: ARRAY
74417: NOT
74418: PUSH
74419: LD_EXP 85
74423: PUSH
74424: LD_VAR 0 2
74428: ARRAY
74429: NOT
74430: OR
74431: IFFALSE 74435
// continue ;
74433: GO 74404
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74435: LD_ADDR_VAR 0 5
74439: PUSH
74440: LD_EXP 61
74444: PUSH
74445: LD_VAR 0 2
74449: ARRAY
74450: PUSH
74451: LD_INT 1
74453: ARRAY
74454: PPUSH
74455: CALL_OW 255
74459: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74460: LD_ADDR_VAR 0 6
74464: PUSH
74465: LD_EXP 61
74469: PUSH
74470: LD_VAR 0 2
74474: ARRAY
74475: PPUSH
74476: LD_INT 30
74478: PUSH
74479: LD_INT 3
74481: PUSH
74482: EMPTY
74483: LIST
74484: LIST
74485: PPUSH
74486: CALL_OW 72
74490: ST_TO_ADDR
// if not fac then
74491: LD_VAR 0 6
74495: NOT
74496: IFFALSE 74547
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74498: LD_ADDR_VAR 0 6
74502: PUSH
74503: LD_EXP 61
74507: PUSH
74508: LD_VAR 0 2
74512: ARRAY
74513: PPUSH
74514: LD_INT 2
74516: PUSH
74517: LD_INT 30
74519: PUSH
74520: LD_INT 0
74522: PUSH
74523: EMPTY
74524: LIST
74525: LIST
74526: PUSH
74527: LD_INT 30
74529: PUSH
74530: LD_INT 1
74532: PUSH
74533: EMPTY
74534: LIST
74535: LIST
74536: PUSH
74537: EMPTY
74538: LIST
74539: LIST
74540: LIST
74541: PPUSH
74542: CALL_OW 72
74546: ST_TO_ADDR
// if not fac then
74547: LD_VAR 0 6
74551: NOT
74552: IFFALSE 74556
// continue ;
74554: GO 74404
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74556: LD_ADDR_VAR 0 7
74560: PUSH
74561: LD_EXP 85
74565: PUSH
74566: LD_VAR 0 2
74570: ARRAY
74571: PPUSH
74572: LD_INT 22
74574: PUSH
74575: LD_VAR 0 5
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: PUSH
74584: LD_INT 21
74586: PUSH
74587: LD_INT 2
74589: PUSH
74590: EMPTY
74591: LIST
74592: LIST
74593: PUSH
74594: LD_INT 3
74596: PUSH
74597: LD_INT 60
74599: PUSH
74600: EMPTY
74601: LIST
74602: PUSH
74603: EMPTY
74604: LIST
74605: LIST
74606: PUSH
74607: LD_INT 3
74609: PUSH
74610: LD_INT 24
74612: PUSH
74613: LD_INT 1000
74615: PUSH
74616: EMPTY
74617: LIST
74618: LIST
74619: PUSH
74620: EMPTY
74621: LIST
74622: LIST
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: LIST
74628: LIST
74629: PPUSH
74630: CALL_OW 70
74634: ST_TO_ADDR
// for j in fac do
74635: LD_ADDR_VAR 0 3
74639: PUSH
74640: LD_VAR 0 6
74644: PUSH
74645: FOR_IN
74646: IFFALSE 74741
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74648: LD_ADDR_VAR 0 7
74652: PUSH
74653: LD_VAR 0 7
74657: PUSH
74658: LD_INT 22
74660: PUSH
74661: LD_VAR 0 5
74665: PUSH
74666: EMPTY
74667: LIST
74668: LIST
74669: PUSH
74670: LD_INT 91
74672: PUSH
74673: LD_VAR 0 3
74677: PUSH
74678: LD_INT 15
74680: PUSH
74681: EMPTY
74682: LIST
74683: LIST
74684: LIST
74685: PUSH
74686: LD_INT 21
74688: PUSH
74689: LD_INT 2
74691: PUSH
74692: EMPTY
74693: LIST
74694: LIST
74695: PUSH
74696: LD_INT 3
74698: PUSH
74699: LD_INT 60
74701: PUSH
74702: EMPTY
74703: LIST
74704: PUSH
74705: EMPTY
74706: LIST
74707: LIST
74708: PUSH
74709: LD_INT 3
74711: PUSH
74712: LD_INT 24
74714: PUSH
74715: LD_INT 1000
74717: PUSH
74718: EMPTY
74719: LIST
74720: LIST
74721: PUSH
74722: EMPTY
74723: LIST
74724: LIST
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: LIST
74730: LIST
74731: LIST
74732: PPUSH
74733: CALL_OW 69
74737: UNION
74738: ST_TO_ADDR
74739: GO 74645
74741: POP
74742: POP
// if not vehs then
74743: LD_VAR 0 7
74747: NOT
74748: IFFALSE 74774
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
74750: LD_ADDR_EXP 73
74754: PUSH
74755: LD_EXP 73
74759: PPUSH
74760: LD_VAR 0 2
74764: PPUSH
74765: EMPTY
74766: PPUSH
74767: CALL_OW 1
74771: ST_TO_ADDR
// continue ;
74772: GO 74404
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74774: LD_ADDR_VAR 0 8
74778: PUSH
74779: LD_EXP 61
74783: PUSH
74784: LD_VAR 0 2
74788: ARRAY
74789: PPUSH
74790: LD_INT 30
74792: PUSH
74793: LD_INT 3
74795: PUSH
74796: EMPTY
74797: LIST
74798: LIST
74799: PPUSH
74800: CALL_OW 72
74804: ST_TO_ADDR
// if tmp then
74805: LD_VAR 0 8
74809: IFFALSE 74912
// begin for j in tmp do
74811: LD_ADDR_VAR 0 3
74815: PUSH
74816: LD_VAR 0 8
74820: PUSH
74821: FOR_IN
74822: IFFALSE 74910
// for k in UnitsInside ( j ) do
74824: LD_ADDR_VAR 0 4
74828: PUSH
74829: LD_VAR 0 3
74833: PPUSH
74834: CALL_OW 313
74838: PUSH
74839: FOR_IN
74840: IFFALSE 74906
// if k then
74842: LD_VAR 0 4
74846: IFFALSE 74904
// if not k in mc_repair_vehicle [ i ] then
74848: LD_VAR 0 4
74852: PUSH
74853: LD_EXP 73
74857: PUSH
74858: LD_VAR 0 2
74862: ARRAY
74863: IN
74864: NOT
74865: IFFALSE 74904
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
74867: LD_ADDR_EXP 73
74871: PUSH
74872: LD_EXP 73
74876: PPUSH
74877: LD_VAR 0 2
74881: PPUSH
74882: LD_EXP 73
74886: PUSH
74887: LD_VAR 0 2
74891: ARRAY
74892: PUSH
74893: LD_VAR 0 4
74897: UNION
74898: PPUSH
74899: CALL_OW 1
74903: ST_TO_ADDR
74904: GO 74839
74906: POP
74907: POP
74908: GO 74821
74910: POP
74911: POP
// end ; if not mc_repair_vehicle [ i ] then
74912: LD_EXP 73
74916: PUSH
74917: LD_VAR 0 2
74921: ARRAY
74922: NOT
74923: IFFALSE 74927
// continue ;
74925: GO 74404
// for j in mc_repair_vehicle [ i ] do
74927: LD_ADDR_VAR 0 3
74931: PUSH
74932: LD_EXP 73
74936: PUSH
74937: LD_VAR 0 2
74941: ARRAY
74942: PUSH
74943: FOR_IN
74944: IFFALSE 75121
// begin if GetClass ( j ) <> 3 then
74946: LD_VAR 0 3
74950: PPUSH
74951: CALL_OW 257
74955: PUSH
74956: LD_INT 3
74958: NONEQUAL
74959: IFFALSE 75000
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
74961: LD_ADDR_EXP 73
74965: PUSH
74966: LD_EXP 73
74970: PPUSH
74971: LD_VAR 0 2
74975: PPUSH
74976: LD_EXP 73
74980: PUSH
74981: LD_VAR 0 2
74985: ARRAY
74986: PUSH
74987: LD_VAR 0 3
74991: DIFF
74992: PPUSH
74993: CALL_OW 1
74997: ST_TO_ADDR
// continue ;
74998: GO 74943
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75000: LD_VAR 0 3
75004: PPUSH
75005: CALL_OW 311
75009: NOT
75010: PUSH
75011: LD_VAR 0 3
75015: PUSH
75016: LD_EXP 64
75020: PUSH
75021: LD_VAR 0 2
75025: ARRAY
75026: PUSH
75027: LD_INT 1
75029: ARRAY
75030: IN
75031: NOT
75032: AND
75033: PUSH
75034: LD_VAR 0 3
75038: PUSH
75039: LD_EXP 64
75043: PUSH
75044: LD_VAR 0 2
75048: ARRAY
75049: PUSH
75050: LD_INT 2
75052: ARRAY
75053: IN
75054: NOT
75055: AND
75056: IFFALSE 75119
// begin if IsInUnit ( j ) then
75058: LD_VAR 0 3
75062: PPUSH
75063: CALL_OW 310
75067: IFFALSE 75080
// ComExitBuilding ( j ) else
75069: LD_VAR 0 3
75073: PPUSH
75074: CALL_OW 122
75078: GO 75119
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
75080: LD_VAR 0 3
75084: PPUSH
75085: LD_VAR 0 7
75089: PUSH
75090: LD_INT 1
75092: ARRAY
75093: PPUSH
75094: CALL 54483 0 2
75098: NOT
75099: IFFALSE 75119
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
75101: LD_VAR 0 3
75105: PPUSH
75106: LD_VAR 0 7
75110: PUSH
75111: LD_INT 1
75113: ARRAY
75114: PPUSH
75115: CALL_OW 129
// end ; end ;
75119: GO 74943
75121: POP
75122: POP
// end ;
75123: GO 74404
75125: POP
75126: POP
// end ;
75127: LD_VAR 0 1
75131: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75132: LD_INT 0
75134: PPUSH
75135: PPUSH
75136: PPUSH
75137: PPUSH
75138: PPUSH
75139: PPUSH
75140: PPUSH
75141: PPUSH
75142: PPUSH
75143: PPUSH
75144: PPUSH
// if not mc_bases then
75145: LD_EXP 61
75149: NOT
75150: IFFALSE 75154
// exit ;
75152: GO 75956
// for i = 1 to mc_bases do
75154: LD_ADDR_VAR 0 2
75158: PUSH
75159: DOUBLE
75160: LD_INT 1
75162: DEC
75163: ST_TO_ADDR
75164: LD_EXP 61
75168: PUSH
75169: FOR_TO
75170: IFFALSE 75954
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75172: LD_EXP 89
75176: PUSH
75177: LD_VAR 0 2
75181: ARRAY
75182: NOT
75183: PUSH
75184: LD_EXP 64
75188: PUSH
75189: LD_VAR 0 2
75193: ARRAY
75194: PUSH
75195: LD_INT 1
75197: ARRAY
75198: OR
75199: PUSH
75200: LD_EXP 64
75204: PUSH
75205: LD_VAR 0 2
75209: ARRAY
75210: PUSH
75211: LD_INT 2
75213: ARRAY
75214: OR
75215: PUSH
75216: LD_EXP 87
75220: PUSH
75221: LD_VAR 0 2
75225: ARRAY
75226: PPUSH
75227: LD_INT 1
75229: PPUSH
75230: CALL_OW 325
75234: NOT
75235: OR
75236: PUSH
75237: LD_EXP 84
75241: PUSH
75242: LD_VAR 0 2
75246: ARRAY
75247: OR
75248: IFFALSE 75252
// continue ;
75250: GO 75169
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75252: LD_ADDR_VAR 0 8
75256: PUSH
75257: LD_EXP 61
75261: PUSH
75262: LD_VAR 0 2
75266: ARRAY
75267: PPUSH
75268: LD_INT 25
75270: PUSH
75271: LD_INT 4
75273: PUSH
75274: EMPTY
75275: LIST
75276: LIST
75277: PUSH
75278: LD_INT 50
75280: PUSH
75281: EMPTY
75282: LIST
75283: PUSH
75284: LD_INT 3
75286: PUSH
75287: LD_INT 60
75289: PUSH
75290: EMPTY
75291: LIST
75292: PUSH
75293: EMPTY
75294: LIST
75295: LIST
75296: PUSH
75297: EMPTY
75298: LIST
75299: LIST
75300: LIST
75301: PPUSH
75302: CALL_OW 72
75306: PUSH
75307: LD_EXP 65
75311: PUSH
75312: LD_VAR 0 2
75316: ARRAY
75317: DIFF
75318: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75319: LD_ADDR_VAR 0 9
75323: PUSH
75324: LD_EXP 61
75328: PUSH
75329: LD_VAR 0 2
75333: ARRAY
75334: PPUSH
75335: LD_INT 2
75337: PUSH
75338: LD_INT 30
75340: PUSH
75341: LD_INT 0
75343: PUSH
75344: EMPTY
75345: LIST
75346: LIST
75347: PUSH
75348: LD_INT 30
75350: PUSH
75351: LD_INT 1
75353: PUSH
75354: EMPTY
75355: LIST
75356: LIST
75357: PUSH
75358: EMPTY
75359: LIST
75360: LIST
75361: LIST
75362: PPUSH
75363: CALL_OW 72
75367: ST_TO_ADDR
// if not tmp or not dep then
75368: LD_VAR 0 8
75372: NOT
75373: PUSH
75374: LD_VAR 0 9
75378: NOT
75379: OR
75380: IFFALSE 75384
// continue ;
75382: GO 75169
// side := GetSide ( tmp [ 1 ] ) ;
75384: LD_ADDR_VAR 0 11
75388: PUSH
75389: LD_VAR 0 8
75393: PUSH
75394: LD_INT 1
75396: ARRAY
75397: PPUSH
75398: CALL_OW 255
75402: ST_TO_ADDR
// dep := dep [ 1 ] ;
75403: LD_ADDR_VAR 0 9
75407: PUSH
75408: LD_VAR 0 9
75412: PUSH
75413: LD_INT 1
75415: ARRAY
75416: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
75417: LD_ADDR_VAR 0 7
75421: PUSH
75422: LD_EXP 89
75426: PUSH
75427: LD_VAR 0 2
75431: ARRAY
75432: PPUSH
75433: LD_INT 22
75435: PUSH
75436: LD_INT 0
75438: PUSH
75439: EMPTY
75440: LIST
75441: LIST
75442: PUSH
75443: LD_INT 25
75445: PUSH
75446: LD_INT 12
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: PUSH
75453: EMPTY
75454: LIST
75455: LIST
75456: PPUSH
75457: CALL_OW 70
75461: PUSH
75462: LD_INT 22
75464: PUSH
75465: LD_INT 0
75467: PUSH
75468: EMPTY
75469: LIST
75470: LIST
75471: PUSH
75472: LD_INT 25
75474: PUSH
75475: LD_INT 12
75477: PUSH
75478: EMPTY
75479: LIST
75480: LIST
75481: PUSH
75482: LD_INT 91
75484: PUSH
75485: LD_VAR 0 9
75489: PUSH
75490: LD_INT 20
75492: PUSH
75493: EMPTY
75494: LIST
75495: LIST
75496: LIST
75497: PUSH
75498: EMPTY
75499: LIST
75500: LIST
75501: LIST
75502: PPUSH
75503: CALL_OW 69
75507: UNION
75508: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
75509: LD_ADDR_VAR 0 10
75513: PUSH
75514: LD_EXP 89
75518: PUSH
75519: LD_VAR 0 2
75523: ARRAY
75524: PPUSH
75525: LD_INT 81
75527: PUSH
75528: LD_VAR 0 11
75532: PUSH
75533: EMPTY
75534: LIST
75535: LIST
75536: PPUSH
75537: CALL_OW 70
75541: ST_TO_ADDR
// if not apes or danger_at_area then
75542: LD_VAR 0 7
75546: NOT
75547: PUSH
75548: LD_VAR 0 10
75552: OR
75553: IFFALSE 75603
// begin if mc_taming [ i ] then
75555: LD_EXP 92
75559: PUSH
75560: LD_VAR 0 2
75564: ARRAY
75565: IFFALSE 75601
// begin MC_Reset ( i , 121 ) ;
75567: LD_VAR 0 2
75571: PPUSH
75572: LD_INT 121
75574: PPUSH
75575: CALL 60540 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
75579: LD_ADDR_EXP 92
75583: PUSH
75584: LD_EXP 92
75588: PPUSH
75589: LD_VAR 0 2
75593: PPUSH
75594: EMPTY
75595: PPUSH
75596: CALL_OW 1
75600: ST_TO_ADDR
// end ; continue ;
75601: GO 75169
// end ; for j in tmp do
75603: LD_ADDR_VAR 0 3
75607: PUSH
75608: LD_VAR 0 8
75612: PUSH
75613: FOR_IN
75614: IFFALSE 75950
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
75616: LD_VAR 0 3
75620: PUSH
75621: LD_EXP 92
75625: PUSH
75626: LD_VAR 0 2
75630: ARRAY
75631: IN
75632: NOT
75633: PUSH
75634: LD_EXP 92
75638: PUSH
75639: LD_VAR 0 2
75643: ARRAY
75644: PUSH
75645: LD_INT 3
75647: LESS
75648: AND
75649: IFFALSE 75707
// begin SetTag ( j , 121 ) ;
75651: LD_VAR 0 3
75655: PPUSH
75656: LD_INT 121
75658: PPUSH
75659: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
75663: LD_ADDR_EXP 92
75667: PUSH
75668: LD_EXP 92
75672: PPUSH
75673: LD_VAR 0 2
75677: PUSH
75678: LD_EXP 92
75682: PUSH
75683: LD_VAR 0 2
75687: ARRAY
75688: PUSH
75689: LD_INT 1
75691: PLUS
75692: PUSH
75693: EMPTY
75694: LIST
75695: LIST
75696: PPUSH
75697: LD_VAR 0 3
75701: PPUSH
75702: CALL 20087 0 3
75706: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
75707: LD_VAR 0 3
75711: PUSH
75712: LD_EXP 92
75716: PUSH
75717: LD_VAR 0 2
75721: ARRAY
75722: IN
75723: IFFALSE 75948
// begin if GetClass ( j ) <> 4 then
75725: LD_VAR 0 3
75729: PPUSH
75730: CALL_OW 257
75734: PUSH
75735: LD_INT 4
75737: NONEQUAL
75738: IFFALSE 75791
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
75740: LD_ADDR_EXP 92
75744: PUSH
75745: LD_EXP 92
75749: PPUSH
75750: LD_VAR 0 2
75754: PPUSH
75755: LD_EXP 92
75759: PUSH
75760: LD_VAR 0 2
75764: ARRAY
75765: PUSH
75766: LD_VAR 0 3
75770: DIFF
75771: PPUSH
75772: CALL_OW 1
75776: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75777: LD_VAR 0 3
75781: PPUSH
75782: LD_INT 0
75784: PPUSH
75785: CALL_OW 109
// continue ;
75789: GO 75613
// end ; if IsInUnit ( j ) then
75791: LD_VAR 0 3
75795: PPUSH
75796: CALL_OW 310
75800: IFFALSE 75811
// ComExitBuilding ( j ) ;
75802: LD_VAR 0 3
75806: PPUSH
75807: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
75811: LD_ADDR_VAR 0 6
75815: PUSH
75816: LD_VAR 0 7
75820: PPUSH
75821: LD_VAR 0 3
75825: PPUSH
75826: CALL_OW 74
75830: ST_TO_ADDR
// if not ape then
75831: LD_VAR 0 6
75835: NOT
75836: IFFALSE 75840
// break ;
75838: GO 75950
// x := GetX ( ape ) ;
75840: LD_ADDR_VAR 0 4
75844: PUSH
75845: LD_VAR 0 6
75849: PPUSH
75850: CALL_OW 250
75854: ST_TO_ADDR
// y := GetY ( ape ) ;
75855: LD_ADDR_VAR 0 5
75859: PUSH
75860: LD_VAR 0 6
75864: PPUSH
75865: CALL_OW 251
75869: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
75870: LD_VAR 0 4
75874: PPUSH
75875: LD_VAR 0 5
75879: PPUSH
75880: CALL_OW 488
75884: NOT
75885: PUSH
75886: LD_VAR 0 11
75890: PPUSH
75891: LD_VAR 0 4
75895: PPUSH
75896: LD_VAR 0 5
75900: PPUSH
75901: LD_INT 20
75903: PPUSH
75904: CALL 20983 0 4
75908: PUSH
75909: LD_INT 4
75911: ARRAY
75912: OR
75913: IFFALSE 75917
// break ;
75915: GO 75950
// if not HasTask ( j ) then
75917: LD_VAR 0 3
75921: PPUSH
75922: CALL_OW 314
75926: NOT
75927: IFFALSE 75948
// ComTameXY ( j , x , y ) ;
75929: LD_VAR 0 3
75933: PPUSH
75934: LD_VAR 0 4
75938: PPUSH
75939: LD_VAR 0 5
75943: PPUSH
75944: CALL_OW 131
// end ; end ;
75948: GO 75613
75950: POP
75951: POP
// end ;
75952: GO 75169
75954: POP
75955: POP
// end ;
75956: LD_VAR 0 1
75960: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
75961: LD_INT 0
75963: PPUSH
75964: PPUSH
75965: PPUSH
75966: PPUSH
75967: PPUSH
75968: PPUSH
75969: PPUSH
75970: PPUSH
// if not mc_bases then
75971: LD_EXP 61
75975: NOT
75976: IFFALSE 75980
// exit ;
75978: GO 76606
// for i = 1 to mc_bases do
75980: LD_ADDR_VAR 0 2
75984: PUSH
75985: DOUBLE
75986: LD_INT 1
75988: DEC
75989: ST_TO_ADDR
75990: LD_EXP 61
75994: PUSH
75995: FOR_TO
75996: IFFALSE 76604
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
75998: LD_EXP 90
76002: PUSH
76003: LD_VAR 0 2
76007: ARRAY
76008: NOT
76009: PUSH
76010: LD_EXP 90
76014: PUSH
76015: LD_VAR 0 2
76019: ARRAY
76020: PPUSH
76021: LD_INT 25
76023: PUSH
76024: LD_INT 12
76026: PUSH
76027: EMPTY
76028: LIST
76029: LIST
76030: PPUSH
76031: CALL_OW 72
76035: NOT
76036: OR
76037: IFFALSE 76041
// continue ;
76039: GO 75995
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
76041: LD_ADDR_VAR 0 5
76045: PUSH
76046: LD_EXP 90
76050: PUSH
76051: LD_VAR 0 2
76055: ARRAY
76056: PUSH
76057: LD_INT 1
76059: ARRAY
76060: PPUSH
76061: CALL_OW 255
76065: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
76066: LD_VAR 0 5
76070: PPUSH
76071: LD_INT 2
76073: PPUSH
76074: CALL_OW 325
76078: IFFALSE 76331
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76080: LD_ADDR_VAR 0 4
76084: PUSH
76085: LD_EXP 90
76089: PUSH
76090: LD_VAR 0 2
76094: ARRAY
76095: PPUSH
76096: LD_INT 25
76098: PUSH
76099: LD_INT 16
76101: PUSH
76102: EMPTY
76103: LIST
76104: LIST
76105: PPUSH
76106: CALL_OW 72
76110: ST_TO_ADDR
// if tmp < 6 then
76111: LD_VAR 0 4
76115: PUSH
76116: LD_INT 6
76118: LESS
76119: IFFALSE 76331
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76121: LD_ADDR_VAR 0 6
76125: PUSH
76126: LD_EXP 61
76130: PUSH
76131: LD_VAR 0 2
76135: ARRAY
76136: PPUSH
76137: LD_INT 2
76139: PUSH
76140: LD_INT 30
76142: PUSH
76143: LD_INT 0
76145: PUSH
76146: EMPTY
76147: LIST
76148: LIST
76149: PUSH
76150: LD_INT 30
76152: PUSH
76153: LD_INT 1
76155: PUSH
76156: EMPTY
76157: LIST
76158: LIST
76159: PUSH
76160: EMPTY
76161: LIST
76162: LIST
76163: LIST
76164: PPUSH
76165: CALL_OW 72
76169: ST_TO_ADDR
// if depot then
76170: LD_VAR 0 6
76174: IFFALSE 76331
// begin selected := 0 ;
76176: LD_ADDR_VAR 0 7
76180: PUSH
76181: LD_INT 0
76183: ST_TO_ADDR
// for j in depot do
76184: LD_ADDR_VAR 0 3
76188: PUSH
76189: LD_VAR 0 6
76193: PUSH
76194: FOR_IN
76195: IFFALSE 76226
// begin if UnitsInside ( j ) < 6 then
76197: LD_VAR 0 3
76201: PPUSH
76202: CALL_OW 313
76206: PUSH
76207: LD_INT 6
76209: LESS
76210: IFFALSE 76224
// begin selected := j ;
76212: LD_ADDR_VAR 0 7
76216: PUSH
76217: LD_VAR 0 3
76221: ST_TO_ADDR
// break ;
76222: GO 76226
// end ; end ;
76224: GO 76194
76226: POP
76227: POP
// if selected then
76228: LD_VAR 0 7
76232: IFFALSE 76331
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76234: LD_ADDR_VAR 0 3
76238: PUSH
76239: LD_EXP 90
76243: PUSH
76244: LD_VAR 0 2
76248: ARRAY
76249: PPUSH
76250: LD_INT 25
76252: PUSH
76253: LD_INT 12
76255: PUSH
76256: EMPTY
76257: LIST
76258: LIST
76259: PPUSH
76260: CALL_OW 72
76264: PUSH
76265: FOR_IN
76266: IFFALSE 76329
// if not HasTask ( j ) then
76268: LD_VAR 0 3
76272: PPUSH
76273: CALL_OW 314
76277: NOT
76278: IFFALSE 76327
// begin if not IsInUnit ( j ) then
76280: LD_VAR 0 3
76284: PPUSH
76285: CALL_OW 310
76289: NOT
76290: IFFALSE 76306
// ComEnterUnit ( j , selected ) ;
76292: LD_VAR 0 3
76296: PPUSH
76297: LD_VAR 0 7
76301: PPUSH
76302: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76306: LD_VAR 0 3
76310: PPUSH
76311: LD_INT 16
76313: PPUSH
76314: CALL_OW 183
// AddComExitBuilding ( j ) ;
76318: LD_VAR 0 3
76322: PPUSH
76323: CALL_OW 182
// end ;
76327: GO 76265
76329: POP
76330: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76331: LD_VAR 0 5
76335: PPUSH
76336: LD_INT 11
76338: PPUSH
76339: CALL_OW 325
76343: IFFALSE 76602
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76345: LD_ADDR_VAR 0 4
76349: PUSH
76350: LD_EXP 90
76354: PUSH
76355: LD_VAR 0 2
76359: ARRAY
76360: PPUSH
76361: LD_INT 25
76363: PUSH
76364: LD_INT 16
76366: PUSH
76367: EMPTY
76368: LIST
76369: LIST
76370: PPUSH
76371: CALL_OW 72
76375: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
76376: LD_VAR 0 4
76380: PUSH
76381: LD_INT 6
76383: GREATEREQUAL
76384: PUSH
76385: LD_VAR 0 5
76389: PPUSH
76390: LD_INT 2
76392: PPUSH
76393: CALL_OW 325
76397: NOT
76398: OR
76399: IFFALSE 76602
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76401: LD_ADDR_VAR 0 8
76405: PUSH
76406: LD_EXP 61
76410: PUSH
76411: LD_VAR 0 2
76415: ARRAY
76416: PPUSH
76417: LD_INT 2
76419: PUSH
76420: LD_INT 30
76422: PUSH
76423: LD_INT 4
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PUSH
76430: LD_INT 30
76432: PUSH
76433: LD_INT 5
76435: PUSH
76436: EMPTY
76437: LIST
76438: LIST
76439: PUSH
76440: EMPTY
76441: LIST
76442: LIST
76443: LIST
76444: PPUSH
76445: CALL_OW 72
76449: ST_TO_ADDR
// if barracks then
76450: LD_VAR 0 8
76454: IFFALSE 76602
// begin selected := 0 ;
76456: LD_ADDR_VAR 0 7
76460: PUSH
76461: LD_INT 0
76463: ST_TO_ADDR
// for j in barracks do
76464: LD_ADDR_VAR 0 3
76468: PUSH
76469: LD_VAR 0 8
76473: PUSH
76474: FOR_IN
76475: IFFALSE 76506
// begin if UnitsInside ( j ) < 6 then
76477: LD_VAR 0 3
76481: PPUSH
76482: CALL_OW 313
76486: PUSH
76487: LD_INT 6
76489: LESS
76490: IFFALSE 76504
// begin selected := j ;
76492: LD_ADDR_VAR 0 7
76496: PUSH
76497: LD_VAR 0 3
76501: ST_TO_ADDR
// break ;
76502: GO 76506
// end ; end ;
76504: GO 76474
76506: POP
76507: POP
// if selected then
76508: LD_VAR 0 7
76512: IFFALSE 76602
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76514: LD_ADDR_VAR 0 3
76518: PUSH
76519: LD_EXP 90
76523: PUSH
76524: LD_VAR 0 2
76528: ARRAY
76529: PPUSH
76530: LD_INT 25
76532: PUSH
76533: LD_INT 12
76535: PUSH
76536: EMPTY
76537: LIST
76538: LIST
76539: PPUSH
76540: CALL_OW 72
76544: PUSH
76545: FOR_IN
76546: IFFALSE 76600
// if not IsInUnit ( j ) and not HasTask ( j ) then
76548: LD_VAR 0 3
76552: PPUSH
76553: CALL_OW 310
76557: NOT
76558: PUSH
76559: LD_VAR 0 3
76563: PPUSH
76564: CALL_OW 314
76568: NOT
76569: AND
76570: IFFALSE 76598
// begin ComEnterUnit ( j , selected ) ;
76572: LD_VAR 0 3
76576: PPUSH
76577: LD_VAR 0 7
76581: PPUSH
76582: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
76586: LD_VAR 0 3
76590: PPUSH
76591: LD_INT 15
76593: PPUSH
76594: CALL_OW 183
// end ;
76598: GO 76545
76600: POP
76601: POP
// end ; end ; end ; end ; end ;
76602: GO 75995
76604: POP
76605: POP
// end ;
76606: LD_VAR 0 1
76610: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
76611: LD_INT 0
76613: PPUSH
76614: PPUSH
76615: PPUSH
76616: PPUSH
// if not mc_bases then
76617: LD_EXP 61
76621: NOT
76622: IFFALSE 76626
// exit ;
76624: GO 76804
// for i = 1 to mc_bases do
76626: LD_ADDR_VAR 0 2
76630: PUSH
76631: DOUBLE
76632: LD_INT 1
76634: DEC
76635: ST_TO_ADDR
76636: LD_EXP 61
76640: PUSH
76641: FOR_TO
76642: IFFALSE 76802
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
76644: LD_ADDR_VAR 0 4
76648: PUSH
76649: LD_EXP 61
76653: PUSH
76654: LD_VAR 0 2
76658: ARRAY
76659: PPUSH
76660: LD_INT 25
76662: PUSH
76663: LD_INT 9
76665: PUSH
76666: EMPTY
76667: LIST
76668: LIST
76669: PPUSH
76670: CALL_OW 72
76674: ST_TO_ADDR
// if not tmp then
76675: LD_VAR 0 4
76679: NOT
76680: IFFALSE 76684
// continue ;
76682: GO 76641
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
76684: LD_EXP 87
76688: PUSH
76689: LD_VAR 0 2
76693: ARRAY
76694: PPUSH
76695: LD_INT 29
76697: PPUSH
76698: CALL_OW 325
76702: NOT
76703: PUSH
76704: LD_EXP 87
76708: PUSH
76709: LD_VAR 0 2
76713: ARRAY
76714: PPUSH
76715: LD_INT 28
76717: PPUSH
76718: CALL_OW 325
76722: NOT
76723: AND
76724: IFFALSE 76728
// continue ;
76726: GO 76641
// for j in tmp do
76728: LD_ADDR_VAR 0 3
76732: PUSH
76733: LD_VAR 0 4
76737: PUSH
76738: FOR_IN
76739: IFFALSE 76798
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
76741: LD_VAR 0 3
76745: PUSH
76746: LD_EXP 64
76750: PUSH
76751: LD_VAR 0 2
76755: ARRAY
76756: PUSH
76757: LD_INT 1
76759: ARRAY
76760: IN
76761: NOT
76762: PUSH
76763: LD_VAR 0 3
76767: PUSH
76768: LD_EXP 64
76772: PUSH
76773: LD_VAR 0 2
76777: ARRAY
76778: PUSH
76779: LD_INT 2
76781: ARRAY
76782: IN
76783: NOT
76784: AND
76785: IFFALSE 76796
// ComSpaceTimeShoot ( j ) ;
76787: LD_VAR 0 3
76791: PPUSH
76792: CALL 15897 0 1
76796: GO 76738
76798: POP
76799: POP
// end ;
76800: GO 76641
76802: POP
76803: POP
// end ;
76804: LD_VAR 0 1
76808: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
76809: LD_INT 0
76811: PPUSH
76812: PPUSH
76813: PPUSH
76814: PPUSH
76815: PPUSH
76816: PPUSH
76817: PPUSH
76818: PPUSH
76819: PPUSH
// if not mc_bases then
76820: LD_EXP 61
76824: NOT
76825: IFFALSE 76829
// exit ;
76827: GO 77451
// for i = 1 to mc_bases do
76829: LD_ADDR_VAR 0 2
76833: PUSH
76834: DOUBLE
76835: LD_INT 1
76837: DEC
76838: ST_TO_ADDR
76839: LD_EXP 61
76843: PUSH
76844: FOR_TO
76845: IFFALSE 77449
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
76847: LD_EXP 96
76851: PUSH
76852: LD_VAR 0 2
76856: ARRAY
76857: NOT
76858: PUSH
76859: LD_INT 38
76861: PPUSH
76862: LD_EXP 87
76866: PUSH
76867: LD_VAR 0 2
76871: ARRAY
76872: PPUSH
76873: CALL_OW 321
76877: PUSH
76878: LD_INT 2
76880: NONEQUAL
76881: OR
76882: IFFALSE 76886
// continue ;
76884: GO 76844
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
76886: LD_ADDR_VAR 0 8
76890: PUSH
76891: LD_EXP 61
76895: PUSH
76896: LD_VAR 0 2
76900: ARRAY
76901: PPUSH
76902: LD_INT 30
76904: PUSH
76905: LD_INT 34
76907: PUSH
76908: EMPTY
76909: LIST
76910: LIST
76911: PPUSH
76912: CALL_OW 72
76916: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
76917: LD_ADDR_VAR 0 9
76921: PUSH
76922: LD_EXP 61
76926: PUSH
76927: LD_VAR 0 2
76931: ARRAY
76932: PPUSH
76933: LD_INT 25
76935: PUSH
76936: LD_INT 4
76938: PUSH
76939: EMPTY
76940: LIST
76941: LIST
76942: PPUSH
76943: CALL_OW 72
76947: PPUSH
76948: LD_INT 0
76950: PPUSH
76951: CALL 49999 0 2
76955: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
76956: LD_VAR 0 9
76960: NOT
76961: PUSH
76962: LD_VAR 0 8
76966: NOT
76967: OR
76968: PUSH
76969: LD_EXP 61
76973: PUSH
76974: LD_VAR 0 2
76978: ARRAY
76979: PPUSH
76980: LD_INT 124
76982: PPUSH
76983: CALL 49999 0 2
76987: OR
76988: IFFALSE 76992
// continue ;
76990: GO 76844
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
76992: LD_EXP 97
76996: PUSH
76997: LD_VAR 0 2
77001: ARRAY
77002: PUSH
77003: LD_EXP 96
77007: PUSH
77008: LD_VAR 0 2
77012: ARRAY
77013: LESS
77014: PUSH
77015: LD_EXP 97
77019: PUSH
77020: LD_VAR 0 2
77024: ARRAY
77025: PUSH
77026: LD_VAR 0 8
77030: LESS
77031: AND
77032: IFFALSE 77447
// begin tmp := sci [ 1 ] ;
77034: LD_ADDR_VAR 0 7
77038: PUSH
77039: LD_VAR 0 9
77043: PUSH
77044: LD_INT 1
77046: ARRAY
77047: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
77048: LD_VAR 0 7
77052: PPUSH
77053: LD_INT 124
77055: PPUSH
77056: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
77060: LD_ADDR_VAR 0 3
77064: PUSH
77065: DOUBLE
77066: LD_EXP 96
77070: PUSH
77071: LD_VAR 0 2
77075: ARRAY
77076: INC
77077: ST_TO_ADDR
77078: LD_EXP 96
77082: PUSH
77083: LD_VAR 0 2
77087: ARRAY
77088: PUSH
77089: FOR_DOWNTO
77090: IFFALSE 77433
// begin if IsInUnit ( tmp ) then
77092: LD_VAR 0 7
77096: PPUSH
77097: CALL_OW 310
77101: IFFALSE 77112
// ComExitBuilding ( tmp ) ;
77103: LD_VAR 0 7
77107: PPUSH
77108: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77112: LD_INT 35
77114: PPUSH
77115: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77119: LD_VAR 0 7
77123: PPUSH
77124: CALL_OW 310
77128: NOT
77129: PUSH
77130: LD_VAR 0 7
77134: PPUSH
77135: CALL_OW 314
77139: NOT
77140: AND
77141: IFFALSE 77112
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77143: LD_ADDR_VAR 0 6
77147: PUSH
77148: LD_VAR 0 7
77152: PPUSH
77153: CALL_OW 250
77157: PUSH
77158: LD_VAR 0 7
77162: PPUSH
77163: CALL_OW 251
77167: PUSH
77168: EMPTY
77169: LIST
77170: LIST
77171: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77172: LD_INT 35
77174: PPUSH
77175: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77179: LD_ADDR_VAR 0 4
77183: PUSH
77184: LD_EXP 96
77188: PUSH
77189: LD_VAR 0 2
77193: ARRAY
77194: PUSH
77195: LD_VAR 0 3
77199: ARRAY
77200: PUSH
77201: LD_INT 1
77203: ARRAY
77204: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77205: LD_ADDR_VAR 0 5
77209: PUSH
77210: LD_EXP 96
77214: PUSH
77215: LD_VAR 0 2
77219: ARRAY
77220: PUSH
77221: LD_VAR 0 3
77225: ARRAY
77226: PUSH
77227: LD_INT 2
77229: ARRAY
77230: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77231: LD_VAR 0 7
77235: PPUSH
77236: LD_INT 10
77238: PPUSH
77239: CALL 22684 0 2
77243: PUSH
77244: LD_INT 4
77246: ARRAY
77247: IFFALSE 77285
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77249: LD_VAR 0 7
77253: PPUSH
77254: LD_VAR 0 6
77258: PUSH
77259: LD_INT 1
77261: ARRAY
77262: PPUSH
77263: LD_VAR 0 6
77267: PUSH
77268: LD_INT 2
77270: ARRAY
77271: PPUSH
77272: CALL_OW 111
// wait ( 0 0$10 ) ;
77276: LD_INT 350
77278: PPUSH
77279: CALL_OW 67
// end else
77283: GO 77311
// begin ComMoveXY ( tmp , x , y ) ;
77285: LD_VAR 0 7
77289: PPUSH
77290: LD_VAR 0 4
77294: PPUSH
77295: LD_VAR 0 5
77299: PPUSH
77300: CALL_OW 111
// wait ( 0 0$3 ) ;
77304: LD_INT 105
77306: PPUSH
77307: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77311: LD_VAR 0 7
77315: PPUSH
77316: LD_VAR 0 4
77320: PPUSH
77321: LD_VAR 0 5
77325: PPUSH
77326: CALL_OW 307
77330: IFFALSE 77172
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77332: LD_VAR 0 7
77336: PPUSH
77337: LD_VAR 0 4
77341: PPUSH
77342: LD_VAR 0 5
77346: PPUSH
77347: LD_VAR 0 8
77351: PUSH
77352: LD_VAR 0 3
77356: ARRAY
77357: PPUSH
77358: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77362: LD_INT 35
77364: PPUSH
77365: CALL_OW 67
// until not HasTask ( tmp ) ;
77369: LD_VAR 0 7
77373: PPUSH
77374: CALL_OW 314
77378: NOT
77379: IFFALSE 77362
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
77381: LD_ADDR_EXP 97
77385: PUSH
77386: LD_EXP 97
77390: PPUSH
77391: LD_VAR 0 2
77395: PUSH
77396: LD_EXP 97
77400: PUSH
77401: LD_VAR 0 2
77405: ARRAY
77406: PUSH
77407: LD_INT 1
77409: PLUS
77410: PUSH
77411: EMPTY
77412: LIST
77413: LIST
77414: PPUSH
77415: LD_VAR 0 8
77419: PUSH
77420: LD_VAR 0 3
77424: ARRAY
77425: PPUSH
77426: CALL 20087 0 3
77430: ST_TO_ADDR
// end ;
77431: GO 77089
77433: POP
77434: POP
// MC_Reset ( i , 124 ) ;
77435: LD_VAR 0 2
77439: PPUSH
77440: LD_INT 124
77442: PPUSH
77443: CALL 60540 0 2
// end ; end ;
77447: GO 76844
77449: POP
77450: POP
// end ;
77451: LD_VAR 0 1
77455: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
77456: LD_INT 0
77458: PPUSH
77459: PPUSH
77460: PPUSH
// if not mc_bases then
77461: LD_EXP 61
77465: NOT
77466: IFFALSE 77470
// exit ;
77468: GO 78076
// for i = 1 to mc_bases do
77470: LD_ADDR_VAR 0 2
77474: PUSH
77475: DOUBLE
77476: LD_INT 1
77478: DEC
77479: ST_TO_ADDR
77480: LD_EXP 61
77484: PUSH
77485: FOR_TO
77486: IFFALSE 78074
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
77488: LD_ADDR_VAR 0 3
77492: PUSH
77493: LD_EXP 61
77497: PUSH
77498: LD_VAR 0 2
77502: ARRAY
77503: PPUSH
77504: LD_INT 25
77506: PUSH
77507: LD_INT 4
77509: PUSH
77510: EMPTY
77511: LIST
77512: LIST
77513: PPUSH
77514: CALL_OW 72
77518: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
77519: LD_VAR 0 3
77523: NOT
77524: PUSH
77525: LD_EXP 98
77529: PUSH
77530: LD_VAR 0 2
77534: ARRAY
77535: NOT
77536: OR
77537: PUSH
77538: LD_EXP 61
77542: PUSH
77543: LD_VAR 0 2
77547: ARRAY
77548: PPUSH
77549: LD_INT 2
77551: PUSH
77552: LD_INT 30
77554: PUSH
77555: LD_INT 0
77557: PUSH
77558: EMPTY
77559: LIST
77560: LIST
77561: PUSH
77562: LD_INT 30
77564: PUSH
77565: LD_INT 1
77567: PUSH
77568: EMPTY
77569: LIST
77570: LIST
77571: PUSH
77572: EMPTY
77573: LIST
77574: LIST
77575: LIST
77576: PPUSH
77577: CALL_OW 72
77581: NOT
77582: OR
77583: IFFALSE 77633
// begin if mc_deposits_finder [ i ] then
77585: LD_EXP 99
77589: PUSH
77590: LD_VAR 0 2
77594: ARRAY
77595: IFFALSE 77631
// begin MC_Reset ( i , 125 ) ;
77597: LD_VAR 0 2
77601: PPUSH
77602: LD_INT 125
77604: PPUSH
77605: CALL 60540 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77609: LD_ADDR_EXP 99
77613: PUSH
77614: LD_EXP 99
77618: PPUSH
77619: LD_VAR 0 2
77623: PPUSH
77624: EMPTY
77625: PPUSH
77626: CALL_OW 1
77630: ST_TO_ADDR
// end ; continue ;
77631: GO 77485
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
77633: LD_EXP 98
77637: PUSH
77638: LD_VAR 0 2
77642: ARRAY
77643: PUSH
77644: LD_INT 1
77646: ARRAY
77647: PUSH
77648: LD_INT 3
77650: ARRAY
77651: PUSH
77652: LD_INT 1
77654: EQUAL
77655: PUSH
77656: LD_INT 20
77658: PPUSH
77659: LD_EXP 87
77663: PUSH
77664: LD_VAR 0 2
77668: ARRAY
77669: PPUSH
77670: CALL_OW 321
77674: PUSH
77675: LD_INT 2
77677: NONEQUAL
77678: AND
77679: IFFALSE 77729
// begin if mc_deposits_finder [ i ] then
77681: LD_EXP 99
77685: PUSH
77686: LD_VAR 0 2
77690: ARRAY
77691: IFFALSE 77727
// begin MC_Reset ( i , 125 ) ;
77693: LD_VAR 0 2
77697: PPUSH
77698: LD_INT 125
77700: PPUSH
77701: CALL 60540 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77705: LD_ADDR_EXP 99
77709: PUSH
77710: LD_EXP 99
77714: PPUSH
77715: LD_VAR 0 2
77719: PPUSH
77720: EMPTY
77721: PPUSH
77722: CALL_OW 1
77726: ST_TO_ADDR
// end ; continue ;
77727: GO 77485
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
77729: LD_EXP 98
77733: PUSH
77734: LD_VAR 0 2
77738: ARRAY
77739: PUSH
77740: LD_INT 1
77742: ARRAY
77743: PUSH
77744: LD_INT 1
77746: ARRAY
77747: PPUSH
77748: LD_EXP 98
77752: PUSH
77753: LD_VAR 0 2
77757: ARRAY
77758: PUSH
77759: LD_INT 1
77761: ARRAY
77762: PUSH
77763: LD_INT 2
77765: ARRAY
77766: PPUSH
77767: LD_EXP 87
77771: PUSH
77772: LD_VAR 0 2
77776: ARRAY
77777: PPUSH
77778: CALL_OW 440
77782: IFFALSE 77825
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
77784: LD_ADDR_EXP 98
77788: PUSH
77789: LD_EXP 98
77793: PPUSH
77794: LD_VAR 0 2
77798: PPUSH
77799: LD_EXP 98
77803: PUSH
77804: LD_VAR 0 2
77808: ARRAY
77809: PPUSH
77810: LD_INT 1
77812: PPUSH
77813: CALL_OW 3
77817: PPUSH
77818: CALL_OW 1
77822: ST_TO_ADDR
77823: GO 78072
// begin if not mc_deposits_finder [ i ] then
77825: LD_EXP 99
77829: PUSH
77830: LD_VAR 0 2
77834: ARRAY
77835: NOT
77836: IFFALSE 77888
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
77838: LD_ADDR_EXP 99
77842: PUSH
77843: LD_EXP 99
77847: PPUSH
77848: LD_VAR 0 2
77852: PPUSH
77853: LD_VAR 0 3
77857: PUSH
77858: LD_INT 1
77860: ARRAY
77861: PUSH
77862: EMPTY
77863: LIST
77864: PPUSH
77865: CALL_OW 1
77869: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
77870: LD_VAR 0 3
77874: PUSH
77875: LD_INT 1
77877: ARRAY
77878: PPUSH
77879: LD_INT 125
77881: PPUSH
77882: CALL_OW 109
// end else
77886: GO 78072
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
77888: LD_EXP 99
77892: PUSH
77893: LD_VAR 0 2
77897: ARRAY
77898: PUSH
77899: LD_INT 1
77901: ARRAY
77902: PPUSH
77903: CALL_OW 310
77907: IFFALSE 77930
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
77909: LD_EXP 99
77913: PUSH
77914: LD_VAR 0 2
77918: ARRAY
77919: PUSH
77920: LD_INT 1
77922: ARRAY
77923: PPUSH
77924: CALL_OW 122
77928: GO 78072
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
77930: LD_EXP 99
77934: PUSH
77935: LD_VAR 0 2
77939: ARRAY
77940: PUSH
77941: LD_INT 1
77943: ARRAY
77944: PPUSH
77945: CALL_OW 314
77949: NOT
77950: PUSH
77951: LD_EXP 99
77955: PUSH
77956: LD_VAR 0 2
77960: ARRAY
77961: PUSH
77962: LD_INT 1
77964: ARRAY
77965: PPUSH
77966: LD_EXP 98
77970: PUSH
77971: LD_VAR 0 2
77975: ARRAY
77976: PUSH
77977: LD_INT 1
77979: ARRAY
77980: PUSH
77981: LD_INT 1
77983: ARRAY
77984: PPUSH
77985: LD_EXP 98
77989: PUSH
77990: LD_VAR 0 2
77994: ARRAY
77995: PUSH
77996: LD_INT 1
77998: ARRAY
77999: PUSH
78000: LD_INT 2
78002: ARRAY
78003: PPUSH
78004: CALL_OW 297
78008: PUSH
78009: LD_INT 6
78011: GREATER
78012: AND
78013: IFFALSE 78072
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
78015: LD_EXP 99
78019: PUSH
78020: LD_VAR 0 2
78024: ARRAY
78025: PUSH
78026: LD_INT 1
78028: ARRAY
78029: PPUSH
78030: LD_EXP 98
78034: PUSH
78035: LD_VAR 0 2
78039: ARRAY
78040: PUSH
78041: LD_INT 1
78043: ARRAY
78044: PUSH
78045: LD_INT 1
78047: ARRAY
78048: PPUSH
78049: LD_EXP 98
78053: PUSH
78054: LD_VAR 0 2
78058: ARRAY
78059: PUSH
78060: LD_INT 1
78062: ARRAY
78063: PUSH
78064: LD_INT 2
78066: ARRAY
78067: PPUSH
78068: CALL_OW 111
// end ; end ; end ;
78072: GO 77485
78074: POP
78075: POP
// end ;
78076: LD_VAR 0 1
78080: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
78081: LD_INT 0
78083: PPUSH
78084: PPUSH
78085: PPUSH
78086: PPUSH
78087: PPUSH
78088: PPUSH
78089: PPUSH
78090: PPUSH
78091: PPUSH
78092: PPUSH
78093: PPUSH
// if not mc_bases then
78094: LD_EXP 61
78098: NOT
78099: IFFALSE 78103
// exit ;
78101: GO 79043
// for i = 1 to mc_bases do
78103: LD_ADDR_VAR 0 2
78107: PUSH
78108: DOUBLE
78109: LD_INT 1
78111: DEC
78112: ST_TO_ADDR
78113: LD_EXP 61
78117: PUSH
78118: FOR_TO
78119: IFFALSE 79041
// begin if not mc_bases [ i ] or mc_scan [ i ] then
78121: LD_EXP 61
78125: PUSH
78126: LD_VAR 0 2
78130: ARRAY
78131: NOT
78132: PUSH
78133: LD_EXP 84
78137: PUSH
78138: LD_VAR 0 2
78142: ARRAY
78143: OR
78144: IFFALSE 78148
// continue ;
78146: GO 78118
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78148: LD_ADDR_VAR 0 7
78152: PUSH
78153: LD_EXP 61
78157: PUSH
78158: LD_VAR 0 2
78162: ARRAY
78163: PUSH
78164: LD_INT 1
78166: ARRAY
78167: PPUSH
78168: CALL_OW 248
78172: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78173: LD_VAR 0 7
78177: PUSH
78178: LD_INT 3
78180: EQUAL
78181: PUSH
78182: LD_EXP 80
78186: PUSH
78187: LD_VAR 0 2
78191: ARRAY
78192: PUSH
78193: LD_EXP 83
78197: PUSH
78198: LD_VAR 0 2
78202: ARRAY
78203: UNION
78204: PPUSH
78205: LD_INT 33
78207: PUSH
78208: LD_INT 2
78210: PUSH
78211: EMPTY
78212: LIST
78213: LIST
78214: PPUSH
78215: CALL_OW 72
78219: NOT
78220: OR
78221: IFFALSE 78225
// continue ;
78223: GO 78118
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78225: LD_ADDR_VAR 0 9
78229: PUSH
78230: LD_EXP 61
78234: PUSH
78235: LD_VAR 0 2
78239: ARRAY
78240: PPUSH
78241: LD_INT 30
78243: PUSH
78244: LD_INT 36
78246: PUSH
78247: EMPTY
78248: LIST
78249: LIST
78250: PPUSH
78251: CALL_OW 72
78255: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78256: LD_ADDR_VAR 0 10
78260: PUSH
78261: LD_EXP 80
78265: PUSH
78266: LD_VAR 0 2
78270: ARRAY
78271: PPUSH
78272: LD_INT 34
78274: PUSH
78275: LD_INT 31
78277: PUSH
78278: EMPTY
78279: LIST
78280: LIST
78281: PPUSH
78282: CALL_OW 72
78286: ST_TO_ADDR
// if not cts and not mcts then
78287: LD_VAR 0 9
78291: NOT
78292: PUSH
78293: LD_VAR 0 10
78297: NOT
78298: AND
78299: IFFALSE 78303
// continue ;
78301: GO 78118
// x := cts ;
78303: LD_ADDR_VAR 0 11
78307: PUSH
78308: LD_VAR 0 9
78312: ST_TO_ADDR
// if not x then
78313: LD_VAR 0 11
78317: NOT
78318: IFFALSE 78330
// x := mcts ;
78320: LD_ADDR_VAR 0 11
78324: PUSH
78325: LD_VAR 0 10
78329: ST_TO_ADDR
// if not x then
78330: LD_VAR 0 11
78334: NOT
78335: IFFALSE 78339
// continue ;
78337: GO 78118
// if mc_remote_driver [ i ] then
78339: LD_EXP 101
78343: PUSH
78344: LD_VAR 0 2
78348: ARRAY
78349: IFFALSE 78736
// for j in mc_remote_driver [ i ] do
78351: LD_ADDR_VAR 0 3
78355: PUSH
78356: LD_EXP 101
78360: PUSH
78361: LD_VAR 0 2
78365: ARRAY
78366: PUSH
78367: FOR_IN
78368: IFFALSE 78734
// begin if GetClass ( j ) <> 3 then
78370: LD_VAR 0 3
78374: PPUSH
78375: CALL_OW 257
78379: PUSH
78380: LD_INT 3
78382: NONEQUAL
78383: IFFALSE 78436
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
78385: LD_ADDR_EXP 101
78389: PUSH
78390: LD_EXP 101
78394: PPUSH
78395: LD_VAR 0 2
78399: PPUSH
78400: LD_EXP 101
78404: PUSH
78405: LD_VAR 0 2
78409: ARRAY
78410: PUSH
78411: LD_VAR 0 3
78415: DIFF
78416: PPUSH
78417: CALL_OW 1
78421: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78422: LD_VAR 0 3
78426: PPUSH
78427: LD_INT 0
78429: PPUSH
78430: CALL_OW 109
// continue ;
78434: GO 78367
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
78436: LD_EXP 80
78440: PUSH
78441: LD_VAR 0 2
78445: ARRAY
78446: PPUSH
78447: LD_INT 34
78449: PUSH
78450: LD_INT 31
78452: PUSH
78453: EMPTY
78454: LIST
78455: LIST
78456: PUSH
78457: LD_INT 58
78459: PUSH
78460: EMPTY
78461: LIST
78462: PUSH
78463: EMPTY
78464: LIST
78465: LIST
78466: PPUSH
78467: CALL_OW 72
78471: PUSH
78472: LD_VAR 0 3
78476: PPUSH
78477: CALL 50034 0 1
78481: NOT
78482: AND
78483: IFFALSE 78554
// begin if IsInUnit ( j ) then
78485: LD_VAR 0 3
78489: PPUSH
78490: CALL_OW 310
78494: IFFALSE 78505
// ComExitBuilding ( j ) ;
78496: LD_VAR 0 3
78500: PPUSH
78501: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
78505: LD_VAR 0 3
78509: PPUSH
78510: LD_EXP 80
78514: PUSH
78515: LD_VAR 0 2
78519: ARRAY
78520: PPUSH
78521: LD_INT 34
78523: PUSH
78524: LD_INT 31
78526: PUSH
78527: EMPTY
78528: LIST
78529: LIST
78530: PUSH
78531: LD_INT 58
78533: PUSH
78534: EMPTY
78535: LIST
78536: PUSH
78537: EMPTY
78538: LIST
78539: LIST
78540: PPUSH
78541: CALL_OW 72
78545: PUSH
78546: LD_INT 1
78548: ARRAY
78549: PPUSH
78550: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
78554: LD_VAR 0 3
78558: PPUSH
78559: CALL_OW 310
78563: NOT
78564: PUSH
78565: LD_VAR 0 3
78569: PPUSH
78570: CALL_OW 310
78574: PPUSH
78575: CALL_OW 266
78579: PUSH
78580: LD_INT 36
78582: NONEQUAL
78583: PUSH
78584: LD_VAR 0 3
78588: PPUSH
78589: CALL 50034 0 1
78593: NOT
78594: AND
78595: OR
78596: IFFALSE 78732
// begin if IsInUnit ( j ) then
78598: LD_VAR 0 3
78602: PPUSH
78603: CALL_OW 310
78607: IFFALSE 78618
// ComExitBuilding ( j ) ;
78609: LD_VAR 0 3
78613: PPUSH
78614: CALL_OW 122
// ct := 0 ;
78618: LD_ADDR_VAR 0 8
78622: PUSH
78623: LD_INT 0
78625: ST_TO_ADDR
// for k in x do
78626: LD_ADDR_VAR 0 4
78630: PUSH
78631: LD_VAR 0 11
78635: PUSH
78636: FOR_IN
78637: IFFALSE 78710
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
78639: LD_VAR 0 4
78643: PPUSH
78644: CALL_OW 264
78648: PUSH
78649: LD_INT 31
78651: EQUAL
78652: PUSH
78653: LD_VAR 0 4
78657: PPUSH
78658: CALL_OW 311
78662: NOT
78663: AND
78664: PUSH
78665: LD_VAR 0 4
78669: PPUSH
78670: CALL_OW 266
78674: PUSH
78675: LD_INT 36
78677: EQUAL
78678: PUSH
78679: LD_VAR 0 4
78683: PPUSH
78684: CALL_OW 313
78688: PUSH
78689: LD_INT 3
78691: LESS
78692: AND
78693: OR
78694: IFFALSE 78708
// begin ct := k ;
78696: LD_ADDR_VAR 0 8
78700: PUSH
78701: LD_VAR 0 4
78705: ST_TO_ADDR
// break ;
78706: GO 78710
// end ;
78708: GO 78636
78710: POP
78711: POP
// if ct then
78712: LD_VAR 0 8
78716: IFFALSE 78732
// ComEnterUnit ( j , ct ) ;
78718: LD_VAR 0 3
78722: PPUSH
78723: LD_VAR 0 8
78727: PPUSH
78728: CALL_OW 120
// end ; end ;
78732: GO 78367
78734: POP
78735: POP
// places := 0 ;
78736: LD_ADDR_VAR 0 5
78740: PUSH
78741: LD_INT 0
78743: ST_TO_ADDR
// for j = 1 to x do
78744: LD_ADDR_VAR 0 3
78748: PUSH
78749: DOUBLE
78750: LD_INT 1
78752: DEC
78753: ST_TO_ADDR
78754: LD_VAR 0 11
78758: PUSH
78759: FOR_TO
78760: IFFALSE 78836
// if GetWeapon ( x [ j ] ) = ar_control_tower then
78762: LD_VAR 0 11
78766: PUSH
78767: LD_VAR 0 3
78771: ARRAY
78772: PPUSH
78773: CALL_OW 264
78777: PUSH
78778: LD_INT 31
78780: EQUAL
78781: IFFALSE 78799
// places := places + 1 else
78783: LD_ADDR_VAR 0 5
78787: PUSH
78788: LD_VAR 0 5
78792: PUSH
78793: LD_INT 1
78795: PLUS
78796: ST_TO_ADDR
78797: GO 78834
// if GetBType ( x [ j ] ) = b_control_tower then
78799: LD_VAR 0 11
78803: PUSH
78804: LD_VAR 0 3
78808: ARRAY
78809: PPUSH
78810: CALL_OW 266
78814: PUSH
78815: LD_INT 36
78817: EQUAL
78818: IFFALSE 78834
// places := places + 3 ;
78820: LD_ADDR_VAR 0 5
78824: PUSH
78825: LD_VAR 0 5
78829: PUSH
78830: LD_INT 3
78832: PLUS
78833: ST_TO_ADDR
78834: GO 78759
78836: POP
78837: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
78838: LD_VAR 0 5
78842: PUSH
78843: LD_INT 0
78845: EQUAL
78846: PUSH
78847: LD_VAR 0 5
78851: PUSH
78852: LD_EXP 101
78856: PUSH
78857: LD_VAR 0 2
78861: ARRAY
78862: LESSEQUAL
78863: OR
78864: IFFALSE 78868
// continue ;
78866: GO 78118
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
78868: LD_ADDR_VAR 0 6
78872: PUSH
78873: LD_EXP 61
78877: PUSH
78878: LD_VAR 0 2
78882: ARRAY
78883: PPUSH
78884: LD_INT 25
78886: PUSH
78887: LD_INT 3
78889: PUSH
78890: EMPTY
78891: LIST
78892: LIST
78893: PPUSH
78894: CALL_OW 72
78898: PUSH
78899: LD_EXP 101
78903: PUSH
78904: LD_VAR 0 2
78908: ARRAY
78909: DIFF
78910: PPUSH
78911: LD_INT 3
78913: PPUSH
78914: CALL 50934 0 2
78918: ST_TO_ADDR
// for j in tmp do
78919: LD_ADDR_VAR 0 3
78923: PUSH
78924: LD_VAR 0 6
78928: PUSH
78929: FOR_IN
78930: IFFALSE 78965
// if GetTag ( j ) > 0 then
78932: LD_VAR 0 3
78936: PPUSH
78937: CALL_OW 110
78941: PUSH
78942: LD_INT 0
78944: GREATER
78945: IFFALSE 78963
// tmp := tmp diff j ;
78947: LD_ADDR_VAR 0 6
78951: PUSH
78952: LD_VAR 0 6
78956: PUSH
78957: LD_VAR 0 3
78961: DIFF
78962: ST_TO_ADDR
78963: GO 78929
78965: POP
78966: POP
// if not tmp then
78967: LD_VAR 0 6
78971: NOT
78972: IFFALSE 78976
// continue ;
78974: GO 78118
// if places then
78976: LD_VAR 0 5
78980: IFFALSE 79039
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
78982: LD_ADDR_EXP 101
78986: PUSH
78987: LD_EXP 101
78991: PPUSH
78992: LD_VAR 0 2
78996: PPUSH
78997: LD_EXP 101
79001: PUSH
79002: LD_VAR 0 2
79006: ARRAY
79007: PUSH
79008: LD_VAR 0 6
79012: PUSH
79013: LD_INT 1
79015: ARRAY
79016: UNION
79017: PPUSH
79018: CALL_OW 1
79022: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
79023: LD_VAR 0 6
79027: PUSH
79028: LD_INT 1
79030: ARRAY
79031: PPUSH
79032: LD_INT 126
79034: PPUSH
79035: CALL_OW 109
// end ; end ;
79039: GO 78118
79041: POP
79042: POP
// end ;
79043: LD_VAR 0 1
79047: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
79048: LD_INT 0
79050: PPUSH
79051: PPUSH
79052: PPUSH
79053: PPUSH
79054: PPUSH
79055: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
79056: LD_VAR 0 1
79060: NOT
79061: PUSH
79062: LD_VAR 0 2
79066: NOT
79067: OR
79068: PUSH
79069: LD_VAR 0 3
79073: NOT
79074: OR
79075: PUSH
79076: LD_VAR 0 4
79080: PUSH
79081: LD_INT 1
79083: PUSH
79084: LD_INT 2
79086: PUSH
79087: LD_INT 3
79089: PUSH
79090: LD_INT 4
79092: PUSH
79093: LD_INT 5
79095: PUSH
79096: LD_INT 8
79098: PUSH
79099: LD_INT 9
79101: PUSH
79102: LD_INT 15
79104: PUSH
79105: LD_INT 16
79107: PUSH
79108: EMPTY
79109: LIST
79110: LIST
79111: LIST
79112: LIST
79113: LIST
79114: LIST
79115: LIST
79116: LIST
79117: LIST
79118: IN
79119: NOT
79120: OR
79121: IFFALSE 79125
// exit ;
79123: GO 80025
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
79125: LD_ADDR_VAR 0 2
79129: PUSH
79130: LD_VAR 0 2
79134: PPUSH
79135: LD_INT 21
79137: PUSH
79138: LD_INT 3
79140: PUSH
79141: EMPTY
79142: LIST
79143: LIST
79144: PUSH
79145: LD_INT 24
79147: PUSH
79148: LD_INT 250
79150: PUSH
79151: EMPTY
79152: LIST
79153: LIST
79154: PUSH
79155: EMPTY
79156: LIST
79157: LIST
79158: PPUSH
79159: CALL_OW 72
79163: ST_TO_ADDR
// case class of 1 , 15 :
79164: LD_VAR 0 4
79168: PUSH
79169: LD_INT 1
79171: DOUBLE
79172: EQUAL
79173: IFTRUE 79183
79175: LD_INT 15
79177: DOUBLE
79178: EQUAL
79179: IFTRUE 79183
79181: GO 79268
79183: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
79184: LD_ADDR_VAR 0 8
79188: PUSH
79189: LD_VAR 0 2
79193: PPUSH
79194: LD_INT 2
79196: PUSH
79197: LD_INT 30
79199: PUSH
79200: LD_INT 32
79202: PUSH
79203: EMPTY
79204: LIST
79205: LIST
79206: PUSH
79207: LD_INT 30
79209: PUSH
79210: LD_INT 31
79212: PUSH
79213: EMPTY
79214: LIST
79215: LIST
79216: PUSH
79217: EMPTY
79218: LIST
79219: LIST
79220: LIST
79221: PPUSH
79222: CALL_OW 72
79226: PUSH
79227: LD_VAR 0 2
79231: PPUSH
79232: LD_INT 2
79234: PUSH
79235: LD_INT 30
79237: PUSH
79238: LD_INT 4
79240: PUSH
79241: EMPTY
79242: LIST
79243: LIST
79244: PUSH
79245: LD_INT 30
79247: PUSH
79248: LD_INT 5
79250: PUSH
79251: EMPTY
79252: LIST
79253: LIST
79254: PUSH
79255: EMPTY
79256: LIST
79257: LIST
79258: LIST
79259: PPUSH
79260: CALL_OW 72
79264: ADD
79265: ST_TO_ADDR
79266: GO 79514
79268: LD_INT 2
79270: DOUBLE
79271: EQUAL
79272: IFTRUE 79282
79274: LD_INT 16
79276: DOUBLE
79277: EQUAL
79278: IFTRUE 79282
79280: GO 79328
79282: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
79283: LD_ADDR_VAR 0 8
79287: PUSH
79288: LD_VAR 0 2
79292: PPUSH
79293: LD_INT 2
79295: PUSH
79296: LD_INT 30
79298: PUSH
79299: LD_INT 0
79301: PUSH
79302: EMPTY
79303: LIST
79304: LIST
79305: PUSH
79306: LD_INT 30
79308: PUSH
79309: LD_INT 1
79311: PUSH
79312: EMPTY
79313: LIST
79314: LIST
79315: PUSH
79316: EMPTY
79317: LIST
79318: LIST
79319: LIST
79320: PPUSH
79321: CALL_OW 72
79325: ST_TO_ADDR
79326: GO 79514
79328: LD_INT 3
79330: DOUBLE
79331: EQUAL
79332: IFTRUE 79336
79334: GO 79382
79336: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
79337: LD_ADDR_VAR 0 8
79341: PUSH
79342: LD_VAR 0 2
79346: PPUSH
79347: LD_INT 2
79349: PUSH
79350: LD_INT 30
79352: PUSH
79353: LD_INT 2
79355: PUSH
79356: EMPTY
79357: LIST
79358: LIST
79359: PUSH
79360: LD_INT 30
79362: PUSH
79363: LD_INT 3
79365: PUSH
79366: EMPTY
79367: LIST
79368: LIST
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: LIST
79374: PPUSH
79375: CALL_OW 72
79379: ST_TO_ADDR
79380: GO 79514
79382: LD_INT 4
79384: DOUBLE
79385: EQUAL
79386: IFTRUE 79390
79388: GO 79447
79390: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
79391: LD_ADDR_VAR 0 8
79395: PUSH
79396: LD_VAR 0 2
79400: PPUSH
79401: LD_INT 2
79403: PUSH
79404: LD_INT 30
79406: PUSH
79407: LD_INT 6
79409: PUSH
79410: EMPTY
79411: LIST
79412: LIST
79413: PUSH
79414: LD_INT 30
79416: PUSH
79417: LD_INT 7
79419: PUSH
79420: EMPTY
79421: LIST
79422: LIST
79423: PUSH
79424: LD_INT 30
79426: PUSH
79427: LD_INT 8
79429: PUSH
79430: EMPTY
79431: LIST
79432: LIST
79433: PUSH
79434: EMPTY
79435: LIST
79436: LIST
79437: LIST
79438: LIST
79439: PPUSH
79440: CALL_OW 72
79444: ST_TO_ADDR
79445: GO 79514
79447: LD_INT 5
79449: DOUBLE
79450: EQUAL
79451: IFTRUE 79467
79453: LD_INT 8
79455: DOUBLE
79456: EQUAL
79457: IFTRUE 79467
79459: LD_INT 9
79461: DOUBLE
79462: EQUAL
79463: IFTRUE 79467
79465: GO 79513
79467: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
79468: LD_ADDR_VAR 0 8
79472: PUSH
79473: LD_VAR 0 2
79477: PPUSH
79478: LD_INT 2
79480: PUSH
79481: LD_INT 30
79483: PUSH
79484: LD_INT 4
79486: PUSH
79487: EMPTY
79488: LIST
79489: LIST
79490: PUSH
79491: LD_INT 30
79493: PUSH
79494: LD_INT 5
79496: PUSH
79497: EMPTY
79498: LIST
79499: LIST
79500: PUSH
79501: EMPTY
79502: LIST
79503: LIST
79504: LIST
79505: PPUSH
79506: CALL_OW 72
79510: ST_TO_ADDR
79511: GO 79514
79513: POP
// if not tmp then
79514: LD_VAR 0 8
79518: NOT
79519: IFFALSE 79523
// exit ;
79521: GO 80025
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
79523: LD_VAR 0 4
79527: PUSH
79528: LD_INT 1
79530: PUSH
79531: LD_INT 15
79533: PUSH
79534: EMPTY
79535: LIST
79536: LIST
79537: IN
79538: PUSH
79539: LD_EXP 70
79543: PUSH
79544: LD_VAR 0 1
79548: ARRAY
79549: AND
79550: IFFALSE 79706
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
79552: LD_ADDR_VAR 0 9
79556: PUSH
79557: LD_EXP 70
79561: PUSH
79562: LD_VAR 0 1
79566: ARRAY
79567: PUSH
79568: LD_INT 1
79570: ARRAY
79571: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
79572: LD_VAR 0 9
79576: PUSH
79577: LD_EXP 71
79581: PUSH
79582: LD_VAR 0 1
79586: ARRAY
79587: IN
79588: NOT
79589: IFFALSE 79704
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
79591: LD_ADDR_EXP 71
79595: PUSH
79596: LD_EXP 71
79600: PPUSH
79601: LD_VAR 0 1
79605: PUSH
79606: LD_EXP 71
79610: PUSH
79611: LD_VAR 0 1
79615: ARRAY
79616: PUSH
79617: LD_INT 1
79619: PLUS
79620: PUSH
79621: EMPTY
79622: LIST
79623: LIST
79624: PPUSH
79625: LD_VAR 0 9
79629: PPUSH
79630: CALL 20087 0 3
79634: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
79635: LD_ADDR_EXP 70
79639: PUSH
79640: LD_EXP 70
79644: PPUSH
79645: LD_VAR 0 1
79649: PPUSH
79650: LD_EXP 70
79654: PUSH
79655: LD_VAR 0 1
79659: ARRAY
79660: PUSH
79661: LD_VAR 0 9
79665: DIFF
79666: PPUSH
79667: CALL_OW 1
79671: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
79672: LD_VAR 0 3
79676: PPUSH
79677: LD_EXP 71
79681: PUSH
79682: LD_VAR 0 1
79686: ARRAY
79687: PUSH
79688: LD_EXP 71
79692: PUSH
79693: LD_VAR 0 1
79697: ARRAY
79698: ARRAY
79699: PPUSH
79700: CALL_OW 120
// end ; exit ;
79704: GO 80025
// end ; if tmp > 1 then
79706: LD_VAR 0 8
79710: PUSH
79711: LD_INT 1
79713: GREATER
79714: IFFALSE 79818
// for i = 2 to tmp do
79716: LD_ADDR_VAR 0 6
79720: PUSH
79721: DOUBLE
79722: LD_INT 2
79724: DEC
79725: ST_TO_ADDR
79726: LD_VAR 0 8
79730: PUSH
79731: FOR_TO
79732: IFFALSE 79816
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
79734: LD_VAR 0 8
79738: PUSH
79739: LD_VAR 0 6
79743: ARRAY
79744: PPUSH
79745: CALL_OW 461
79749: PUSH
79750: LD_INT 6
79752: EQUAL
79753: IFFALSE 79814
// begin x := tmp [ i ] ;
79755: LD_ADDR_VAR 0 9
79759: PUSH
79760: LD_VAR 0 8
79764: PUSH
79765: LD_VAR 0 6
79769: ARRAY
79770: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
79771: LD_ADDR_VAR 0 8
79775: PUSH
79776: LD_VAR 0 8
79780: PPUSH
79781: LD_VAR 0 6
79785: PPUSH
79786: CALL_OW 3
79790: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
79791: LD_ADDR_VAR 0 8
79795: PUSH
79796: LD_VAR 0 8
79800: PPUSH
79801: LD_INT 1
79803: PPUSH
79804: LD_VAR 0 9
79808: PPUSH
79809: CALL_OW 2
79813: ST_TO_ADDR
// end ;
79814: GO 79731
79816: POP
79817: POP
// for i in tmp do
79818: LD_ADDR_VAR 0 6
79822: PUSH
79823: LD_VAR 0 8
79827: PUSH
79828: FOR_IN
79829: IFFALSE 79898
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
79831: LD_VAR 0 6
79835: PPUSH
79836: CALL_OW 313
79840: PUSH
79841: LD_INT 6
79843: LESS
79844: PUSH
79845: LD_VAR 0 6
79849: PPUSH
79850: CALL_OW 266
79854: PUSH
79855: LD_INT 31
79857: PUSH
79858: LD_INT 32
79860: PUSH
79861: EMPTY
79862: LIST
79863: LIST
79864: IN
79865: NOT
79866: AND
79867: PUSH
79868: LD_VAR 0 6
79872: PPUSH
79873: CALL_OW 313
79877: PUSH
79878: LD_INT 0
79880: EQUAL
79881: OR
79882: IFFALSE 79896
// begin j := i ;
79884: LD_ADDR_VAR 0 7
79888: PUSH
79889: LD_VAR 0 6
79893: ST_TO_ADDR
// break ;
79894: GO 79898
// end ; end ;
79896: GO 79828
79898: POP
79899: POP
// if j then
79900: LD_VAR 0 7
79904: IFFALSE 79922
// ComEnterUnit ( unit , j ) else
79906: LD_VAR 0 3
79910: PPUSH
79911: LD_VAR 0 7
79915: PPUSH
79916: CALL_OW 120
79920: GO 80025
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79922: LD_ADDR_VAR 0 10
79926: PUSH
79927: LD_VAR 0 2
79931: PPUSH
79932: LD_INT 2
79934: PUSH
79935: LD_INT 30
79937: PUSH
79938: LD_INT 0
79940: PUSH
79941: EMPTY
79942: LIST
79943: LIST
79944: PUSH
79945: LD_INT 30
79947: PUSH
79948: LD_INT 1
79950: PUSH
79951: EMPTY
79952: LIST
79953: LIST
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: LIST
79959: PPUSH
79960: CALL_OW 72
79964: ST_TO_ADDR
// if depot then
79965: LD_VAR 0 10
79969: IFFALSE 80025
// begin depot := NearestUnitToUnit ( depot , unit ) ;
79971: LD_ADDR_VAR 0 10
79975: PUSH
79976: LD_VAR 0 10
79980: PPUSH
79981: LD_VAR 0 3
79985: PPUSH
79986: CALL_OW 74
79990: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
79991: LD_VAR 0 3
79995: PPUSH
79996: LD_VAR 0 10
80000: PPUSH
80001: CALL_OW 296
80005: PUSH
80006: LD_INT 10
80008: GREATER
80009: IFFALSE 80025
// ComStandNearbyBuilding ( unit , depot ) ;
80011: LD_VAR 0 3
80015: PPUSH
80016: LD_VAR 0 10
80020: PPUSH
80021: CALL 16514 0 2
// end ; end ; end ;
80025: LD_VAR 0 5
80029: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
80030: LD_INT 0
80032: PPUSH
80033: PPUSH
80034: PPUSH
80035: PPUSH
// if not mc_bases then
80036: LD_EXP 61
80040: NOT
80041: IFFALSE 80045
// exit ;
80043: GO 80284
// for i = 1 to mc_bases do
80045: LD_ADDR_VAR 0 2
80049: PUSH
80050: DOUBLE
80051: LD_INT 1
80053: DEC
80054: ST_TO_ADDR
80055: LD_EXP 61
80059: PUSH
80060: FOR_TO
80061: IFFALSE 80282
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
80063: LD_ADDR_VAR 0 4
80067: PUSH
80068: LD_EXP 61
80072: PUSH
80073: LD_VAR 0 2
80077: ARRAY
80078: PPUSH
80079: LD_INT 21
80081: PUSH
80082: LD_INT 1
80084: PUSH
80085: EMPTY
80086: LIST
80087: LIST
80088: PPUSH
80089: CALL_OW 72
80093: PUSH
80094: LD_EXP 90
80098: PUSH
80099: LD_VAR 0 2
80103: ARRAY
80104: UNION
80105: ST_TO_ADDR
// if not tmp then
80106: LD_VAR 0 4
80110: NOT
80111: IFFALSE 80115
// continue ;
80113: GO 80060
// for j in tmp do
80115: LD_ADDR_VAR 0 3
80119: PUSH
80120: LD_VAR 0 4
80124: PUSH
80125: FOR_IN
80126: IFFALSE 80278
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
80128: LD_VAR 0 3
80132: PPUSH
80133: CALL_OW 110
80137: NOT
80138: PUSH
80139: LD_VAR 0 3
80143: PPUSH
80144: CALL_OW 314
80148: NOT
80149: AND
80150: PUSH
80151: LD_VAR 0 3
80155: PPUSH
80156: CALL_OW 311
80160: NOT
80161: AND
80162: PUSH
80163: LD_VAR 0 3
80167: PPUSH
80168: CALL_OW 310
80172: NOT
80173: AND
80174: PUSH
80175: LD_VAR 0 3
80179: PUSH
80180: LD_EXP 64
80184: PUSH
80185: LD_VAR 0 2
80189: ARRAY
80190: PUSH
80191: LD_INT 1
80193: ARRAY
80194: IN
80195: NOT
80196: AND
80197: PUSH
80198: LD_VAR 0 3
80202: PUSH
80203: LD_EXP 64
80207: PUSH
80208: LD_VAR 0 2
80212: ARRAY
80213: PUSH
80214: LD_INT 2
80216: ARRAY
80217: IN
80218: NOT
80219: AND
80220: PUSH
80221: LD_VAR 0 3
80225: PUSH
80226: LD_EXP 73
80230: PUSH
80231: LD_VAR 0 2
80235: ARRAY
80236: IN
80237: NOT
80238: AND
80239: IFFALSE 80276
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
80241: LD_VAR 0 2
80245: PPUSH
80246: LD_EXP 61
80250: PUSH
80251: LD_VAR 0 2
80255: ARRAY
80256: PPUSH
80257: LD_VAR 0 3
80261: PPUSH
80262: LD_VAR 0 3
80266: PPUSH
80267: CALL_OW 257
80271: PPUSH
80272: CALL 79048 0 4
// end ;
80276: GO 80125
80278: POP
80279: POP
// end ;
80280: GO 80060
80282: POP
80283: POP
// end ;
80284: LD_VAR 0 1
80288: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
80289: LD_INT 0
80291: PPUSH
80292: PPUSH
80293: PPUSH
80294: PPUSH
80295: PPUSH
80296: PPUSH
// if not mc_bases [ base ] then
80297: LD_EXP 61
80301: PUSH
80302: LD_VAR 0 1
80306: ARRAY
80307: NOT
80308: IFFALSE 80312
// exit ;
80310: GO 80494
// tmp := [ ] ;
80312: LD_ADDR_VAR 0 6
80316: PUSH
80317: EMPTY
80318: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80319: LD_ADDR_VAR 0 7
80323: PUSH
80324: LD_VAR 0 3
80328: PPUSH
80329: LD_INT 0
80331: PPUSH
80332: CALL_OW 517
80336: ST_TO_ADDR
// if not list then
80337: LD_VAR 0 7
80341: NOT
80342: IFFALSE 80346
// exit ;
80344: GO 80494
// for i = 1 to amount do
80346: LD_ADDR_VAR 0 5
80350: PUSH
80351: DOUBLE
80352: LD_INT 1
80354: DEC
80355: ST_TO_ADDR
80356: LD_VAR 0 2
80360: PUSH
80361: FOR_TO
80362: IFFALSE 80442
// begin x := rand ( 1 , list [ 1 ] ) ;
80364: LD_ADDR_VAR 0 8
80368: PUSH
80369: LD_INT 1
80371: PPUSH
80372: LD_VAR 0 7
80376: PUSH
80377: LD_INT 1
80379: ARRAY
80380: PPUSH
80381: CALL_OW 12
80385: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
80386: LD_ADDR_VAR 0 6
80390: PUSH
80391: LD_VAR 0 6
80395: PPUSH
80396: LD_VAR 0 5
80400: PPUSH
80401: LD_VAR 0 7
80405: PUSH
80406: LD_INT 1
80408: ARRAY
80409: PUSH
80410: LD_VAR 0 8
80414: ARRAY
80415: PUSH
80416: LD_VAR 0 7
80420: PUSH
80421: LD_INT 2
80423: ARRAY
80424: PUSH
80425: LD_VAR 0 8
80429: ARRAY
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PPUSH
80435: CALL_OW 1
80439: ST_TO_ADDR
// end ;
80440: GO 80361
80442: POP
80443: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
80444: LD_ADDR_EXP 74
80448: PUSH
80449: LD_EXP 74
80453: PPUSH
80454: LD_VAR 0 1
80458: PPUSH
80459: LD_VAR 0 6
80463: PPUSH
80464: CALL_OW 1
80468: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
80469: LD_ADDR_EXP 76
80473: PUSH
80474: LD_EXP 76
80478: PPUSH
80479: LD_VAR 0 1
80483: PPUSH
80484: LD_VAR 0 3
80488: PPUSH
80489: CALL_OW 1
80493: ST_TO_ADDR
// end ;
80494: LD_VAR 0 4
80498: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
80499: LD_INT 0
80501: PPUSH
// if not mc_bases [ base ] then
80502: LD_EXP 61
80506: PUSH
80507: LD_VAR 0 1
80511: ARRAY
80512: NOT
80513: IFFALSE 80517
// exit ;
80515: GO 80542
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
80517: LD_ADDR_EXP 66
80521: PUSH
80522: LD_EXP 66
80526: PPUSH
80527: LD_VAR 0 1
80531: PPUSH
80532: LD_VAR 0 2
80536: PPUSH
80537: CALL_OW 1
80541: ST_TO_ADDR
// end ;
80542: LD_VAR 0 3
80546: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
80547: LD_INT 0
80549: PPUSH
// if not mc_bases [ base ] then
80550: LD_EXP 61
80554: PUSH
80555: LD_VAR 0 1
80559: ARRAY
80560: NOT
80561: IFFALSE 80565
// exit ;
80563: GO 80602
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
80565: LD_ADDR_EXP 66
80569: PUSH
80570: LD_EXP 66
80574: PPUSH
80575: LD_VAR 0 1
80579: PPUSH
80580: LD_EXP 66
80584: PUSH
80585: LD_VAR 0 1
80589: ARRAY
80590: PUSH
80591: LD_VAR 0 2
80595: UNION
80596: PPUSH
80597: CALL_OW 1
80601: ST_TO_ADDR
// end ;
80602: LD_VAR 0 3
80606: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
80607: LD_INT 0
80609: PPUSH
// if not mc_bases [ base ] then
80610: LD_EXP 61
80614: PUSH
80615: LD_VAR 0 1
80619: ARRAY
80620: NOT
80621: IFFALSE 80625
// exit ;
80623: GO 80650
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
80625: LD_ADDR_EXP 82
80629: PUSH
80630: LD_EXP 82
80634: PPUSH
80635: LD_VAR 0 1
80639: PPUSH
80640: LD_VAR 0 2
80644: PPUSH
80645: CALL_OW 1
80649: ST_TO_ADDR
// end ;
80650: LD_VAR 0 3
80654: RET
// export function MC_InsertProduceList ( base , components ) ; begin
80655: LD_INT 0
80657: PPUSH
// if not mc_bases [ base ] then
80658: LD_EXP 61
80662: PUSH
80663: LD_VAR 0 1
80667: ARRAY
80668: NOT
80669: IFFALSE 80673
// exit ;
80671: GO 80710
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
80673: LD_ADDR_EXP 82
80677: PUSH
80678: LD_EXP 82
80682: PPUSH
80683: LD_VAR 0 1
80687: PPUSH
80688: LD_EXP 82
80692: PUSH
80693: LD_VAR 0 1
80697: ARRAY
80698: PUSH
80699: LD_VAR 0 2
80703: ADD
80704: PPUSH
80705: CALL_OW 1
80709: ST_TO_ADDR
// end ;
80710: LD_VAR 0 3
80714: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
80715: LD_INT 0
80717: PPUSH
// if not mc_bases [ base ] then
80718: LD_EXP 61
80722: PUSH
80723: LD_VAR 0 1
80727: ARRAY
80728: NOT
80729: IFFALSE 80733
// exit ;
80731: GO 80787
// mc_defender := Replace ( mc_defender , base , deflist ) ;
80733: LD_ADDR_EXP 83
80737: PUSH
80738: LD_EXP 83
80742: PPUSH
80743: LD_VAR 0 1
80747: PPUSH
80748: LD_VAR 0 2
80752: PPUSH
80753: CALL_OW 1
80757: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
80758: LD_ADDR_EXP 72
80762: PUSH
80763: LD_EXP 72
80767: PPUSH
80768: LD_VAR 0 1
80772: PPUSH
80773: LD_VAR 0 2
80777: PUSH
80778: LD_INT 0
80780: PLUS
80781: PPUSH
80782: CALL_OW 1
80786: ST_TO_ADDR
// end ;
80787: LD_VAR 0 3
80791: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
80792: LD_INT 0
80794: PPUSH
// if not mc_bases [ base ] then
80795: LD_EXP 61
80799: PUSH
80800: LD_VAR 0 1
80804: ARRAY
80805: NOT
80806: IFFALSE 80810
// exit ;
80808: GO 80835
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
80810: LD_ADDR_EXP 72
80814: PUSH
80815: LD_EXP 72
80819: PPUSH
80820: LD_VAR 0 1
80824: PPUSH
80825: LD_VAR 0 2
80829: PPUSH
80830: CALL_OW 1
80834: ST_TO_ADDR
// end ;
80835: LD_VAR 0 3
80839: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
80840: LD_INT 0
80842: PPUSH
80843: PPUSH
80844: PPUSH
80845: PPUSH
// if not mc_bases [ base ] then
80846: LD_EXP 61
80850: PUSH
80851: LD_VAR 0 1
80855: ARRAY
80856: NOT
80857: IFFALSE 80861
// exit ;
80859: GO 80926
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
80861: LD_ADDR_EXP 81
80865: PUSH
80866: LD_EXP 81
80870: PPUSH
80871: LD_VAR 0 1
80875: PUSH
80876: LD_EXP 81
80880: PUSH
80881: LD_VAR 0 1
80885: ARRAY
80886: PUSH
80887: LD_INT 1
80889: PLUS
80890: PUSH
80891: EMPTY
80892: LIST
80893: LIST
80894: PPUSH
80895: LD_VAR 0 1
80899: PUSH
80900: LD_VAR 0 2
80904: PUSH
80905: LD_VAR 0 3
80909: PUSH
80910: LD_VAR 0 4
80914: PUSH
80915: EMPTY
80916: LIST
80917: LIST
80918: LIST
80919: LIST
80920: PPUSH
80921: CALL 20087 0 3
80925: ST_TO_ADDR
// end ;
80926: LD_VAR 0 5
80930: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
80931: LD_INT 0
80933: PPUSH
// if not mc_bases [ base ] then
80934: LD_EXP 61
80938: PUSH
80939: LD_VAR 0 1
80943: ARRAY
80944: NOT
80945: IFFALSE 80949
// exit ;
80947: GO 80974
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
80949: LD_ADDR_EXP 98
80953: PUSH
80954: LD_EXP 98
80958: PPUSH
80959: LD_VAR 0 1
80963: PPUSH
80964: LD_VAR 0 2
80968: PPUSH
80969: CALL_OW 1
80973: ST_TO_ADDR
// end ;
80974: LD_VAR 0 3
80978: RET
// export function MC_GetMinesField ( base ) ; begin
80979: LD_INT 0
80981: PPUSH
// result := mc_mines [ base ] ;
80982: LD_ADDR_VAR 0 2
80986: PUSH
80987: LD_EXP 74
80991: PUSH
80992: LD_VAR 0 1
80996: ARRAY
80997: ST_TO_ADDR
// end ;
80998: LD_VAR 0 2
81002: RET
// export function MC_GetProduceList ( base ) ; begin
81003: LD_INT 0
81005: PPUSH
// result := mc_produce [ base ] ;
81006: LD_ADDR_VAR 0 2
81010: PUSH
81011: LD_EXP 82
81015: PUSH
81016: LD_VAR 0 1
81020: ARRAY
81021: ST_TO_ADDR
// end ;
81022: LD_VAR 0 2
81026: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
81027: LD_INT 0
81029: PPUSH
81030: PPUSH
// if not mc_bases then
81031: LD_EXP 61
81035: NOT
81036: IFFALSE 81040
// exit ;
81038: GO 81105
// if mc_bases [ base ] then
81040: LD_EXP 61
81044: PUSH
81045: LD_VAR 0 1
81049: ARRAY
81050: IFFALSE 81105
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81052: LD_ADDR_VAR 0 3
81056: PUSH
81057: LD_EXP 61
81061: PUSH
81062: LD_VAR 0 1
81066: ARRAY
81067: PPUSH
81068: LD_INT 30
81070: PUSH
81071: LD_VAR 0 2
81075: PUSH
81076: EMPTY
81077: LIST
81078: LIST
81079: PPUSH
81080: CALL_OW 72
81084: ST_TO_ADDR
// if result then
81085: LD_VAR 0 3
81089: IFFALSE 81105
// result := result [ 1 ] ;
81091: LD_ADDR_VAR 0 3
81095: PUSH
81096: LD_VAR 0 3
81100: PUSH
81101: LD_INT 1
81103: ARRAY
81104: ST_TO_ADDR
// end ; end ;
81105: LD_VAR 0 3
81109: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
81110: LD_INT 0
81112: PPUSH
81113: PPUSH
// if not mc_bases then
81114: LD_EXP 61
81118: NOT
81119: IFFALSE 81123
// exit ;
81121: GO 81168
// if mc_bases [ base ] then
81123: LD_EXP 61
81127: PUSH
81128: LD_VAR 0 1
81132: ARRAY
81133: IFFALSE 81168
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81135: LD_ADDR_VAR 0 3
81139: PUSH
81140: LD_EXP 61
81144: PUSH
81145: LD_VAR 0 1
81149: ARRAY
81150: PPUSH
81151: LD_INT 30
81153: PUSH
81154: LD_VAR 0 2
81158: PUSH
81159: EMPTY
81160: LIST
81161: LIST
81162: PPUSH
81163: CALL_OW 72
81167: ST_TO_ADDR
// end ;
81168: LD_VAR 0 3
81172: RET
// export function MC_SetTame ( base , area ) ; begin
81173: LD_INT 0
81175: PPUSH
// if not mc_bases or not base then
81176: LD_EXP 61
81180: NOT
81181: PUSH
81182: LD_VAR 0 1
81186: NOT
81187: OR
81188: IFFALSE 81192
// exit ;
81190: GO 81217
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
81192: LD_ADDR_EXP 89
81196: PUSH
81197: LD_EXP 89
81201: PPUSH
81202: LD_VAR 0 1
81206: PPUSH
81207: LD_VAR 0 2
81211: PPUSH
81212: CALL_OW 1
81216: ST_TO_ADDR
// end ;
81217: LD_VAR 0 3
81221: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
81222: LD_INT 0
81224: PPUSH
81225: PPUSH
// if not mc_bases or not base then
81226: LD_EXP 61
81230: NOT
81231: PUSH
81232: LD_VAR 0 1
81236: NOT
81237: OR
81238: IFFALSE 81242
// exit ;
81240: GO 81344
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81242: LD_ADDR_VAR 0 4
81246: PUSH
81247: LD_EXP 61
81251: PUSH
81252: LD_VAR 0 1
81256: ARRAY
81257: PPUSH
81258: LD_INT 30
81260: PUSH
81261: LD_VAR 0 2
81265: PUSH
81266: EMPTY
81267: LIST
81268: LIST
81269: PPUSH
81270: CALL_OW 72
81274: ST_TO_ADDR
// if not tmp then
81275: LD_VAR 0 4
81279: NOT
81280: IFFALSE 81284
// exit ;
81282: GO 81344
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
81284: LD_ADDR_EXP 93
81288: PUSH
81289: LD_EXP 93
81293: PPUSH
81294: LD_VAR 0 1
81298: PPUSH
81299: LD_EXP 93
81303: PUSH
81304: LD_VAR 0 1
81308: ARRAY
81309: PPUSH
81310: LD_EXP 93
81314: PUSH
81315: LD_VAR 0 1
81319: ARRAY
81320: PUSH
81321: LD_INT 1
81323: PLUS
81324: PPUSH
81325: LD_VAR 0 4
81329: PUSH
81330: LD_INT 1
81332: ARRAY
81333: PPUSH
81334: CALL_OW 2
81338: PPUSH
81339: CALL_OW 1
81343: ST_TO_ADDR
// end ;
81344: LD_VAR 0 3
81348: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
81349: LD_INT 0
81351: PPUSH
81352: PPUSH
// if not mc_bases or not base or not kinds then
81353: LD_EXP 61
81357: NOT
81358: PUSH
81359: LD_VAR 0 1
81363: NOT
81364: OR
81365: PUSH
81366: LD_VAR 0 2
81370: NOT
81371: OR
81372: IFFALSE 81376
// exit ;
81374: GO 81437
// for i in kinds do
81376: LD_ADDR_VAR 0 4
81380: PUSH
81381: LD_VAR 0 2
81385: PUSH
81386: FOR_IN
81387: IFFALSE 81435
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
81389: LD_ADDR_EXP 95
81393: PUSH
81394: LD_EXP 95
81398: PPUSH
81399: LD_VAR 0 1
81403: PUSH
81404: LD_EXP 95
81408: PUSH
81409: LD_VAR 0 1
81413: ARRAY
81414: PUSH
81415: LD_INT 1
81417: PLUS
81418: PUSH
81419: EMPTY
81420: LIST
81421: LIST
81422: PPUSH
81423: LD_VAR 0 4
81427: PPUSH
81428: CALL 20087 0 3
81432: ST_TO_ADDR
81433: GO 81386
81435: POP
81436: POP
// end ;
81437: LD_VAR 0 3
81441: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
81442: LD_INT 0
81444: PPUSH
// if not mc_bases or not base or not areas then
81445: LD_EXP 61
81449: NOT
81450: PUSH
81451: LD_VAR 0 1
81455: NOT
81456: OR
81457: PUSH
81458: LD_VAR 0 2
81462: NOT
81463: OR
81464: IFFALSE 81468
// exit ;
81466: GO 81493
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
81468: LD_ADDR_EXP 79
81472: PUSH
81473: LD_EXP 79
81477: PPUSH
81478: LD_VAR 0 1
81482: PPUSH
81483: LD_VAR 0 2
81487: PPUSH
81488: CALL_OW 1
81492: ST_TO_ADDR
// end ;
81493: LD_VAR 0 3
81497: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
81498: LD_INT 0
81500: PPUSH
// if not mc_bases or not base or not teleports_exit then
81501: LD_EXP 61
81505: NOT
81506: PUSH
81507: LD_VAR 0 1
81511: NOT
81512: OR
81513: PUSH
81514: LD_VAR 0 2
81518: NOT
81519: OR
81520: IFFALSE 81524
// exit ;
81522: GO 81549
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
81524: LD_ADDR_EXP 96
81528: PUSH
81529: LD_EXP 96
81533: PPUSH
81534: LD_VAR 0 1
81538: PPUSH
81539: LD_VAR 0 2
81543: PPUSH
81544: CALL_OW 1
81548: ST_TO_ADDR
// end ;
81549: LD_VAR 0 3
81553: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
81554: LD_INT 0
81556: PPUSH
81557: PPUSH
81558: PPUSH
// if not mc_bases or not base or not ext_list then
81559: LD_EXP 61
81563: NOT
81564: PUSH
81565: LD_VAR 0 1
81569: NOT
81570: OR
81571: PUSH
81572: LD_VAR 0 5
81576: NOT
81577: OR
81578: IFFALSE 81582
// exit ;
81580: GO 81755
// tmp := GetFacExtXYD ( x , y , d ) ;
81582: LD_ADDR_VAR 0 8
81586: PUSH
81587: LD_VAR 0 2
81591: PPUSH
81592: LD_VAR 0 3
81596: PPUSH
81597: LD_VAR 0 4
81601: PPUSH
81602: CALL 50064 0 3
81606: ST_TO_ADDR
// if not tmp then
81607: LD_VAR 0 8
81611: NOT
81612: IFFALSE 81616
// exit ;
81614: GO 81755
// for i in tmp do
81616: LD_ADDR_VAR 0 7
81620: PUSH
81621: LD_VAR 0 8
81625: PUSH
81626: FOR_IN
81627: IFFALSE 81753
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
81629: LD_ADDR_EXP 66
81633: PUSH
81634: LD_EXP 66
81638: PPUSH
81639: LD_VAR 0 1
81643: PPUSH
81644: LD_EXP 66
81648: PUSH
81649: LD_VAR 0 1
81653: ARRAY
81654: PPUSH
81655: LD_EXP 66
81659: PUSH
81660: LD_VAR 0 1
81664: ARRAY
81665: PUSH
81666: LD_INT 1
81668: PLUS
81669: PPUSH
81670: LD_VAR 0 5
81674: PUSH
81675: LD_INT 1
81677: ARRAY
81678: PUSH
81679: LD_VAR 0 7
81683: PUSH
81684: LD_INT 1
81686: ARRAY
81687: PUSH
81688: LD_VAR 0 7
81692: PUSH
81693: LD_INT 2
81695: ARRAY
81696: PUSH
81697: LD_VAR 0 7
81701: PUSH
81702: LD_INT 3
81704: ARRAY
81705: PUSH
81706: EMPTY
81707: LIST
81708: LIST
81709: LIST
81710: LIST
81711: PPUSH
81712: CALL_OW 2
81716: PPUSH
81717: CALL_OW 1
81721: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
81722: LD_ADDR_VAR 0 5
81726: PUSH
81727: LD_VAR 0 5
81731: PPUSH
81732: LD_INT 1
81734: PPUSH
81735: CALL_OW 3
81739: ST_TO_ADDR
// if not ext_list then
81740: LD_VAR 0 5
81744: NOT
81745: IFFALSE 81751
// exit ;
81747: POP
81748: POP
81749: GO 81755
// end ;
81751: GO 81626
81753: POP
81754: POP
// end ;
81755: LD_VAR 0 6
81759: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
81760: LD_INT 0
81762: PPUSH
// if not mc_bases or not base or not weapon_list then
81763: LD_EXP 61
81767: NOT
81768: PUSH
81769: LD_VAR 0 1
81773: NOT
81774: OR
81775: PUSH
81776: LD_VAR 0 2
81780: NOT
81781: OR
81782: IFFALSE 81786
// exit ;
81784: GO 81811
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
81786: LD_ADDR_EXP 100
81790: PUSH
81791: LD_EXP 100
81795: PPUSH
81796: LD_VAR 0 1
81800: PPUSH
81801: LD_VAR 0 2
81805: PPUSH
81806: CALL_OW 1
81810: ST_TO_ADDR
// end ;
81811: LD_VAR 0 3
81815: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
81816: LD_INT 0
81818: PPUSH
// if not mc_bases or not base or not tech_list then
81819: LD_EXP 61
81823: NOT
81824: PUSH
81825: LD_VAR 0 1
81829: NOT
81830: OR
81831: PUSH
81832: LD_VAR 0 2
81836: NOT
81837: OR
81838: IFFALSE 81842
// exit ;
81840: GO 81867
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
81842: LD_ADDR_EXP 88
81846: PUSH
81847: LD_EXP 88
81851: PPUSH
81852: LD_VAR 0 1
81856: PPUSH
81857: LD_VAR 0 2
81861: PPUSH
81862: CALL_OW 1
81866: ST_TO_ADDR
// end ;
81867: LD_VAR 0 3
81871: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
81872: LD_INT 0
81874: PPUSH
// if not mc_bases or not parking_area or not base then
81875: LD_EXP 61
81879: NOT
81880: PUSH
81881: LD_VAR 0 2
81885: NOT
81886: OR
81887: PUSH
81888: LD_VAR 0 1
81892: NOT
81893: OR
81894: IFFALSE 81898
// exit ;
81896: GO 81923
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
81898: LD_ADDR_EXP 85
81902: PUSH
81903: LD_EXP 85
81907: PPUSH
81908: LD_VAR 0 1
81912: PPUSH
81913: LD_VAR 0 2
81917: PPUSH
81918: CALL_OW 1
81922: ST_TO_ADDR
// end ;
81923: LD_VAR 0 3
81927: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
81928: LD_INT 0
81930: PPUSH
// if not mc_bases or not base or not scan_area then
81931: LD_EXP 61
81935: NOT
81936: PUSH
81937: LD_VAR 0 1
81941: NOT
81942: OR
81943: PUSH
81944: LD_VAR 0 2
81948: NOT
81949: OR
81950: IFFALSE 81954
// exit ;
81952: GO 81979
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
81954: LD_ADDR_EXP 86
81958: PUSH
81959: LD_EXP 86
81963: PPUSH
81964: LD_VAR 0 1
81968: PPUSH
81969: LD_VAR 0 2
81973: PPUSH
81974: CALL_OW 1
81978: ST_TO_ADDR
// end ;
81979: LD_VAR 0 3
81983: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
81984: LD_INT 0
81986: PPUSH
81987: PPUSH
// if not mc_bases or not base then
81988: LD_EXP 61
81992: NOT
81993: PUSH
81994: LD_VAR 0 1
81998: NOT
81999: OR
82000: IFFALSE 82004
// exit ;
82002: GO 82068
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
82004: LD_ADDR_VAR 0 3
82008: PUSH
82009: LD_INT 1
82011: PUSH
82012: LD_INT 2
82014: PUSH
82015: LD_INT 3
82017: PUSH
82018: LD_INT 4
82020: PUSH
82021: LD_INT 11
82023: PUSH
82024: EMPTY
82025: LIST
82026: LIST
82027: LIST
82028: LIST
82029: LIST
82030: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
82031: LD_ADDR_EXP 88
82035: PUSH
82036: LD_EXP 88
82040: PPUSH
82041: LD_VAR 0 1
82045: PPUSH
82046: LD_EXP 88
82050: PUSH
82051: LD_VAR 0 1
82055: ARRAY
82056: PUSH
82057: LD_VAR 0 3
82061: DIFF
82062: PPUSH
82063: CALL_OW 1
82067: ST_TO_ADDR
// end ;
82068: LD_VAR 0 2
82072: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
82073: LD_INT 0
82075: PPUSH
// result := mc_vehicles [ base ] ;
82076: LD_ADDR_VAR 0 3
82080: PUSH
82081: LD_EXP 80
82085: PUSH
82086: LD_VAR 0 1
82090: ARRAY
82091: ST_TO_ADDR
// if onlyCombat then
82092: LD_VAR 0 2
82096: IFFALSE 82268
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
82098: LD_ADDR_VAR 0 3
82102: PUSH
82103: LD_VAR 0 3
82107: PUSH
82108: LD_VAR 0 3
82112: PPUSH
82113: LD_INT 2
82115: PUSH
82116: LD_INT 34
82118: PUSH
82119: LD_INT 12
82121: PUSH
82122: EMPTY
82123: LIST
82124: LIST
82125: PUSH
82126: LD_INT 34
82128: PUSH
82129: LD_INT 51
82131: PUSH
82132: EMPTY
82133: LIST
82134: LIST
82135: PUSH
82136: LD_INT 34
82138: PUSH
82139: LD_INT 89
82141: PUSH
82142: EMPTY
82143: LIST
82144: LIST
82145: PUSH
82146: LD_INT 34
82148: PUSH
82149: LD_INT 32
82151: PUSH
82152: EMPTY
82153: LIST
82154: LIST
82155: PUSH
82156: LD_INT 34
82158: PUSH
82159: LD_INT 13
82161: PUSH
82162: EMPTY
82163: LIST
82164: LIST
82165: PUSH
82166: LD_INT 34
82168: PUSH
82169: LD_INT 52
82171: PUSH
82172: EMPTY
82173: LIST
82174: LIST
82175: PUSH
82176: LD_INT 34
82178: PUSH
82179: LD_INT 88
82181: PUSH
82182: EMPTY
82183: LIST
82184: LIST
82185: PUSH
82186: LD_INT 34
82188: PUSH
82189: LD_INT 14
82191: PUSH
82192: EMPTY
82193: LIST
82194: LIST
82195: PUSH
82196: LD_INT 34
82198: PUSH
82199: LD_INT 53
82201: PUSH
82202: EMPTY
82203: LIST
82204: LIST
82205: PUSH
82206: LD_INT 34
82208: PUSH
82209: LD_INT 98
82211: PUSH
82212: EMPTY
82213: LIST
82214: LIST
82215: PUSH
82216: LD_INT 34
82218: PUSH
82219: LD_INT 31
82221: PUSH
82222: EMPTY
82223: LIST
82224: LIST
82225: PUSH
82226: LD_INT 34
82228: PUSH
82229: LD_INT 48
82231: PUSH
82232: EMPTY
82233: LIST
82234: LIST
82235: PUSH
82236: LD_INT 34
82238: PUSH
82239: LD_INT 8
82241: PUSH
82242: EMPTY
82243: LIST
82244: LIST
82245: PUSH
82246: EMPTY
82247: LIST
82248: LIST
82249: LIST
82250: LIST
82251: LIST
82252: LIST
82253: LIST
82254: LIST
82255: LIST
82256: LIST
82257: LIST
82258: LIST
82259: LIST
82260: LIST
82261: PPUSH
82262: CALL_OW 72
82266: DIFF
82267: ST_TO_ADDR
// end ; end_of_file
82268: LD_VAR 0 3
82272: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
82273: LD_INT 0
82275: PPUSH
82276: PPUSH
82277: PPUSH
// if not mc_bases or not skirmish then
82278: LD_EXP 61
82282: NOT
82283: PUSH
82284: LD_EXP 59
82288: NOT
82289: OR
82290: IFFALSE 82294
// exit ;
82292: GO 82459
// for i = 1 to mc_bases do
82294: LD_ADDR_VAR 0 4
82298: PUSH
82299: DOUBLE
82300: LD_INT 1
82302: DEC
82303: ST_TO_ADDR
82304: LD_EXP 61
82308: PUSH
82309: FOR_TO
82310: IFFALSE 82457
// begin if sci in mc_bases [ i ] then
82312: LD_VAR 0 2
82316: PUSH
82317: LD_EXP 61
82321: PUSH
82322: LD_VAR 0 4
82326: ARRAY
82327: IN
82328: IFFALSE 82455
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
82330: LD_ADDR_EXP 90
82334: PUSH
82335: LD_EXP 90
82339: PPUSH
82340: LD_VAR 0 4
82344: PUSH
82345: LD_EXP 90
82349: PUSH
82350: LD_VAR 0 4
82354: ARRAY
82355: PUSH
82356: LD_INT 1
82358: PLUS
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PPUSH
82364: LD_VAR 0 1
82368: PPUSH
82369: CALL 20087 0 3
82373: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
82374: LD_ADDR_VAR 0 5
82378: PUSH
82379: LD_EXP 61
82383: PUSH
82384: LD_VAR 0 4
82388: ARRAY
82389: PPUSH
82390: LD_INT 2
82392: PUSH
82393: LD_INT 30
82395: PUSH
82396: LD_INT 0
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: PUSH
82403: LD_INT 30
82405: PUSH
82406: LD_INT 1
82408: PUSH
82409: EMPTY
82410: LIST
82411: LIST
82412: PUSH
82413: EMPTY
82414: LIST
82415: LIST
82416: LIST
82417: PPUSH
82418: CALL_OW 72
82422: PPUSH
82423: LD_VAR 0 1
82427: PPUSH
82428: CALL_OW 74
82432: ST_TO_ADDR
// if tmp then
82433: LD_VAR 0 5
82437: IFFALSE 82453
// ComStandNearbyBuilding ( ape , tmp ) ;
82439: LD_VAR 0 1
82443: PPUSH
82444: LD_VAR 0 5
82448: PPUSH
82449: CALL 16514 0 2
// break ;
82453: GO 82457
// end ; end ;
82455: GO 82309
82457: POP
82458: POP
// end ;
82459: LD_VAR 0 3
82463: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
82464: LD_INT 0
82466: PPUSH
82467: PPUSH
82468: PPUSH
// if not mc_bases or not skirmish then
82469: LD_EXP 61
82473: NOT
82474: PUSH
82475: LD_EXP 59
82479: NOT
82480: OR
82481: IFFALSE 82485
// exit ;
82483: GO 82574
// for i = 1 to mc_bases do
82485: LD_ADDR_VAR 0 4
82489: PUSH
82490: DOUBLE
82491: LD_INT 1
82493: DEC
82494: ST_TO_ADDR
82495: LD_EXP 61
82499: PUSH
82500: FOR_TO
82501: IFFALSE 82572
// begin if building in mc_busy_turret_list [ i ] then
82503: LD_VAR 0 1
82507: PUSH
82508: LD_EXP 71
82512: PUSH
82513: LD_VAR 0 4
82517: ARRAY
82518: IN
82519: IFFALSE 82570
// begin tmp := mc_busy_turret_list [ i ] diff building ;
82521: LD_ADDR_VAR 0 5
82525: PUSH
82526: LD_EXP 71
82530: PUSH
82531: LD_VAR 0 4
82535: ARRAY
82536: PUSH
82537: LD_VAR 0 1
82541: DIFF
82542: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
82543: LD_ADDR_EXP 71
82547: PUSH
82548: LD_EXP 71
82552: PPUSH
82553: LD_VAR 0 4
82557: PPUSH
82558: LD_VAR 0 5
82562: PPUSH
82563: CALL_OW 1
82567: ST_TO_ADDR
// break ;
82568: GO 82572
// end ; end ;
82570: GO 82500
82572: POP
82573: POP
// end ;
82574: LD_VAR 0 3
82578: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
82579: LD_INT 0
82581: PPUSH
82582: PPUSH
82583: PPUSH
// if not mc_bases or not skirmish then
82584: LD_EXP 61
82588: NOT
82589: PUSH
82590: LD_EXP 59
82594: NOT
82595: OR
82596: IFFALSE 82600
// exit ;
82598: GO 82799
// for i = 1 to mc_bases do
82600: LD_ADDR_VAR 0 5
82604: PUSH
82605: DOUBLE
82606: LD_INT 1
82608: DEC
82609: ST_TO_ADDR
82610: LD_EXP 61
82614: PUSH
82615: FOR_TO
82616: IFFALSE 82797
// if building in mc_bases [ i ] then
82618: LD_VAR 0 1
82622: PUSH
82623: LD_EXP 61
82627: PUSH
82628: LD_VAR 0 5
82632: ARRAY
82633: IN
82634: IFFALSE 82795
// begin tmp := mc_bases [ i ] diff building ;
82636: LD_ADDR_VAR 0 6
82640: PUSH
82641: LD_EXP 61
82645: PUSH
82646: LD_VAR 0 5
82650: ARRAY
82651: PUSH
82652: LD_VAR 0 1
82656: DIFF
82657: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
82658: LD_ADDR_EXP 61
82662: PUSH
82663: LD_EXP 61
82667: PPUSH
82668: LD_VAR 0 5
82672: PPUSH
82673: LD_VAR 0 6
82677: PPUSH
82678: CALL_OW 1
82682: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
82683: LD_VAR 0 1
82687: PUSH
82688: LD_EXP 69
82692: PUSH
82693: LD_VAR 0 5
82697: ARRAY
82698: IN
82699: IFFALSE 82738
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
82701: LD_ADDR_EXP 69
82705: PUSH
82706: LD_EXP 69
82710: PPUSH
82711: LD_VAR 0 5
82715: PPUSH
82716: LD_EXP 69
82720: PUSH
82721: LD_VAR 0 5
82725: ARRAY
82726: PUSH
82727: LD_VAR 0 1
82731: DIFF
82732: PPUSH
82733: CALL_OW 1
82737: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
82738: LD_VAR 0 1
82742: PUSH
82743: LD_EXP 70
82747: PUSH
82748: LD_VAR 0 5
82752: ARRAY
82753: IN
82754: IFFALSE 82793
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
82756: LD_ADDR_EXP 70
82760: PUSH
82761: LD_EXP 70
82765: PPUSH
82766: LD_VAR 0 5
82770: PPUSH
82771: LD_EXP 70
82775: PUSH
82776: LD_VAR 0 5
82780: ARRAY
82781: PUSH
82782: LD_VAR 0 1
82786: DIFF
82787: PPUSH
82788: CALL_OW 1
82792: ST_TO_ADDR
// break ;
82793: GO 82797
// end ;
82795: GO 82615
82797: POP
82798: POP
// end ;
82799: LD_VAR 0 4
82803: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
82804: LD_INT 0
82806: PPUSH
82807: PPUSH
82808: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
82809: LD_EXP 61
82813: NOT
82814: PUSH
82815: LD_EXP 59
82819: NOT
82820: OR
82821: PUSH
82822: LD_VAR 0 3
82826: PUSH
82827: LD_EXP 87
82831: IN
82832: NOT
82833: OR
82834: IFFALSE 82838
// exit ;
82836: GO 82961
// for i = 1 to mc_vehicles do
82838: LD_ADDR_VAR 0 6
82842: PUSH
82843: DOUBLE
82844: LD_INT 1
82846: DEC
82847: ST_TO_ADDR
82848: LD_EXP 80
82852: PUSH
82853: FOR_TO
82854: IFFALSE 82959
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
82856: LD_VAR 0 2
82860: PUSH
82861: LD_EXP 80
82865: PUSH
82866: LD_VAR 0 6
82870: ARRAY
82871: IN
82872: PUSH
82873: LD_VAR 0 1
82877: PUSH
82878: LD_EXP 80
82882: PUSH
82883: LD_VAR 0 6
82887: ARRAY
82888: IN
82889: OR
82890: IFFALSE 82957
// begin tmp := mc_vehicles [ i ] diff old ;
82892: LD_ADDR_VAR 0 7
82896: PUSH
82897: LD_EXP 80
82901: PUSH
82902: LD_VAR 0 6
82906: ARRAY
82907: PUSH
82908: LD_VAR 0 2
82912: DIFF
82913: ST_TO_ADDR
// tmp := tmp diff new ;
82914: LD_ADDR_VAR 0 7
82918: PUSH
82919: LD_VAR 0 7
82923: PUSH
82924: LD_VAR 0 1
82928: DIFF
82929: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
82930: LD_ADDR_EXP 80
82934: PUSH
82935: LD_EXP 80
82939: PPUSH
82940: LD_VAR 0 6
82944: PPUSH
82945: LD_VAR 0 7
82949: PPUSH
82950: CALL_OW 1
82954: ST_TO_ADDR
// break ;
82955: GO 82959
// end ;
82957: GO 82853
82959: POP
82960: POP
// end ;
82961: LD_VAR 0 5
82965: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
82966: LD_INT 0
82968: PPUSH
82969: PPUSH
82970: PPUSH
82971: PPUSH
// if not mc_bases or not skirmish then
82972: LD_EXP 61
82976: NOT
82977: PUSH
82978: LD_EXP 59
82982: NOT
82983: OR
82984: IFFALSE 82988
// exit ;
82986: GO 83408
// repeat wait ( 0 0$1 ) ;
82988: LD_INT 35
82990: PPUSH
82991: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
82995: LD_EXP 105
82999: NOT
83000: IFFALSE 82988
// mc_block_vehicle_constructed_thread := true ;
83002: LD_ADDR_EXP 105
83006: PUSH
83007: LD_INT 1
83009: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
83010: LD_ADDR_VAR 0 5
83014: PUSH
83015: LD_VAR 0 1
83019: PPUSH
83020: CALL_OW 255
83024: ST_TO_ADDR
// for i = 1 to mc_bases do
83025: LD_ADDR_VAR 0 4
83029: PUSH
83030: DOUBLE
83031: LD_INT 1
83033: DEC
83034: ST_TO_ADDR
83035: LD_EXP 61
83039: PUSH
83040: FOR_TO
83041: IFFALSE 83398
// begin if factory in mc_bases [ i ] then
83043: LD_VAR 0 2
83047: PUSH
83048: LD_EXP 61
83052: PUSH
83053: LD_VAR 0 4
83057: ARRAY
83058: IN
83059: IFFALSE 83396
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
83061: LD_EXP 83
83065: PUSH
83066: LD_VAR 0 4
83070: ARRAY
83071: PUSH
83072: LD_EXP 72
83076: PUSH
83077: LD_VAR 0 4
83081: ARRAY
83082: LESS
83083: PUSH
83084: LD_VAR 0 1
83088: PPUSH
83089: CALL_OW 264
83093: PUSH
83094: LD_INT 31
83096: PUSH
83097: LD_INT 32
83099: PUSH
83100: LD_INT 51
83102: PUSH
83103: LD_INT 89
83105: PUSH
83106: LD_INT 12
83108: PUSH
83109: LD_INT 30
83111: PUSH
83112: LD_INT 98
83114: PUSH
83115: LD_INT 11
83117: PUSH
83118: LD_INT 53
83120: PUSH
83121: LD_INT 14
83123: PUSH
83124: LD_INT 91
83126: PUSH
83127: LD_INT 29
83129: PUSH
83130: LD_INT 99
83132: PUSH
83133: LD_INT 13
83135: PUSH
83136: LD_INT 52
83138: PUSH
83139: LD_INT 88
83141: PUSH
83142: LD_INT 48
83144: PUSH
83145: LD_INT 8
83147: PUSH
83148: EMPTY
83149: LIST
83150: LIST
83151: LIST
83152: LIST
83153: LIST
83154: LIST
83155: LIST
83156: LIST
83157: LIST
83158: LIST
83159: LIST
83160: LIST
83161: LIST
83162: LIST
83163: LIST
83164: LIST
83165: LIST
83166: LIST
83167: IN
83168: NOT
83169: AND
83170: IFFALSE 83218
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
83172: LD_ADDR_EXP 83
83176: PUSH
83177: LD_EXP 83
83181: PPUSH
83182: LD_VAR 0 4
83186: PUSH
83187: LD_EXP 83
83191: PUSH
83192: LD_VAR 0 4
83196: ARRAY
83197: PUSH
83198: LD_INT 1
83200: PLUS
83201: PUSH
83202: EMPTY
83203: LIST
83204: LIST
83205: PPUSH
83206: LD_VAR 0 1
83210: PPUSH
83211: CALL 20087 0 3
83215: ST_TO_ADDR
83216: GO 83262
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
83218: LD_ADDR_EXP 80
83222: PUSH
83223: LD_EXP 80
83227: PPUSH
83228: LD_VAR 0 4
83232: PUSH
83233: LD_EXP 80
83237: PUSH
83238: LD_VAR 0 4
83242: ARRAY
83243: PUSH
83244: LD_INT 1
83246: PLUS
83247: PUSH
83248: EMPTY
83249: LIST
83250: LIST
83251: PPUSH
83252: LD_VAR 0 1
83256: PPUSH
83257: CALL 20087 0 3
83261: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
83262: LD_ADDR_EXP 105
83266: PUSH
83267: LD_INT 0
83269: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
83270: LD_VAR 0 1
83274: PPUSH
83275: CALL_OW 263
83279: PUSH
83280: LD_INT 2
83282: EQUAL
83283: IFFALSE 83312
// begin repeat wait ( 0 0$3 ) ;
83285: LD_INT 105
83287: PPUSH
83288: CALL_OW 67
// Connect ( vehicle ) ;
83292: LD_VAR 0 1
83296: PPUSH
83297: CALL 23056 0 1
// until IsControledBy ( vehicle ) ;
83301: LD_VAR 0 1
83305: PPUSH
83306: CALL_OW 312
83310: IFFALSE 83285
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
83312: LD_VAR 0 1
83316: PPUSH
83317: LD_EXP 85
83321: PUSH
83322: LD_VAR 0 4
83326: ARRAY
83327: PPUSH
83328: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
83332: LD_VAR 0 1
83336: PPUSH
83337: CALL_OW 263
83341: PUSH
83342: LD_INT 1
83344: NONEQUAL
83345: IFFALSE 83349
// break ;
83347: GO 83398
// repeat wait ( 0 0$1 ) ;
83349: LD_INT 35
83351: PPUSH
83352: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
83356: LD_VAR 0 1
83360: PPUSH
83361: LD_EXP 85
83365: PUSH
83366: LD_VAR 0 4
83370: ARRAY
83371: PPUSH
83372: CALL_OW 308
83376: IFFALSE 83349
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
83378: LD_VAR 0 1
83382: PPUSH
83383: CALL_OW 311
83387: PPUSH
83388: CALL_OW 121
// exit ;
83392: POP
83393: POP
83394: GO 83408
// end ; end ;
83396: GO 83040
83398: POP
83399: POP
// mc_block_vehicle_constructed_thread := false ;
83400: LD_ADDR_EXP 105
83404: PUSH
83405: LD_INT 0
83407: ST_TO_ADDR
// end ;
83408: LD_VAR 0 3
83412: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
83413: LD_INT 0
83415: PPUSH
83416: PPUSH
83417: PPUSH
83418: PPUSH
// if not mc_bases or not skirmish then
83419: LD_EXP 61
83423: NOT
83424: PUSH
83425: LD_EXP 59
83429: NOT
83430: OR
83431: IFFALSE 83435
// exit ;
83433: GO 83788
// repeat wait ( 0 0$1 ) ;
83435: LD_INT 35
83437: PPUSH
83438: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
83442: LD_VAR 0 2
83446: PPUSH
83447: LD_VAR 0 3
83451: PPUSH
83452: CALL_OW 284
83456: IFFALSE 83435
// if GetResourceTypeXY ( x , y ) = mat_artefact then
83458: LD_VAR 0 2
83462: PPUSH
83463: LD_VAR 0 3
83467: PPUSH
83468: CALL_OW 283
83472: PUSH
83473: LD_INT 4
83475: EQUAL
83476: IFFALSE 83480
// exit ;
83478: GO 83788
// for i = 1 to mc_bases do
83480: LD_ADDR_VAR 0 7
83484: PUSH
83485: DOUBLE
83486: LD_INT 1
83488: DEC
83489: ST_TO_ADDR
83490: LD_EXP 61
83494: PUSH
83495: FOR_TO
83496: IFFALSE 83786
// begin if mc_crates_area [ i ] then
83498: LD_EXP 79
83502: PUSH
83503: LD_VAR 0 7
83507: ARRAY
83508: IFFALSE 83619
// for j in mc_crates_area [ i ] do
83510: LD_ADDR_VAR 0 8
83514: PUSH
83515: LD_EXP 79
83519: PUSH
83520: LD_VAR 0 7
83524: ARRAY
83525: PUSH
83526: FOR_IN
83527: IFFALSE 83617
// if InArea ( x , y , j ) then
83529: LD_VAR 0 2
83533: PPUSH
83534: LD_VAR 0 3
83538: PPUSH
83539: LD_VAR 0 8
83543: PPUSH
83544: CALL_OW 309
83548: IFFALSE 83615
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83550: LD_ADDR_EXP 77
83554: PUSH
83555: LD_EXP 77
83559: PPUSH
83560: LD_VAR 0 7
83564: PUSH
83565: LD_EXP 77
83569: PUSH
83570: LD_VAR 0 7
83574: ARRAY
83575: PUSH
83576: LD_INT 1
83578: PLUS
83579: PUSH
83580: EMPTY
83581: LIST
83582: LIST
83583: PPUSH
83584: LD_VAR 0 4
83588: PUSH
83589: LD_VAR 0 2
83593: PUSH
83594: LD_VAR 0 3
83598: PUSH
83599: EMPTY
83600: LIST
83601: LIST
83602: LIST
83603: PPUSH
83604: CALL 20087 0 3
83608: ST_TO_ADDR
// exit ;
83609: POP
83610: POP
83611: POP
83612: POP
83613: GO 83788
// end ;
83615: GO 83526
83617: POP
83618: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83619: LD_ADDR_VAR 0 9
83623: PUSH
83624: LD_EXP 61
83628: PUSH
83629: LD_VAR 0 7
83633: ARRAY
83634: PPUSH
83635: LD_INT 2
83637: PUSH
83638: LD_INT 30
83640: PUSH
83641: LD_INT 0
83643: PUSH
83644: EMPTY
83645: LIST
83646: LIST
83647: PUSH
83648: LD_INT 30
83650: PUSH
83651: LD_INT 1
83653: PUSH
83654: EMPTY
83655: LIST
83656: LIST
83657: PUSH
83658: EMPTY
83659: LIST
83660: LIST
83661: LIST
83662: PPUSH
83663: CALL_OW 72
83667: ST_TO_ADDR
// if not depot then
83668: LD_VAR 0 9
83672: NOT
83673: IFFALSE 83677
// continue ;
83675: GO 83495
// for j in depot do
83677: LD_ADDR_VAR 0 8
83681: PUSH
83682: LD_VAR 0 9
83686: PUSH
83687: FOR_IN
83688: IFFALSE 83782
// if GetDistUnitXY ( j , x , y ) < 30 then
83690: LD_VAR 0 8
83694: PPUSH
83695: LD_VAR 0 2
83699: PPUSH
83700: LD_VAR 0 3
83704: PPUSH
83705: CALL_OW 297
83709: PUSH
83710: LD_INT 30
83712: LESS
83713: IFFALSE 83780
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83715: LD_ADDR_EXP 77
83719: PUSH
83720: LD_EXP 77
83724: PPUSH
83725: LD_VAR 0 7
83729: PUSH
83730: LD_EXP 77
83734: PUSH
83735: LD_VAR 0 7
83739: ARRAY
83740: PUSH
83741: LD_INT 1
83743: PLUS
83744: PUSH
83745: EMPTY
83746: LIST
83747: LIST
83748: PPUSH
83749: LD_VAR 0 4
83753: PUSH
83754: LD_VAR 0 2
83758: PUSH
83759: LD_VAR 0 3
83763: PUSH
83764: EMPTY
83765: LIST
83766: LIST
83767: LIST
83768: PPUSH
83769: CALL 20087 0 3
83773: ST_TO_ADDR
// exit ;
83774: POP
83775: POP
83776: POP
83777: POP
83778: GO 83788
// end ;
83780: GO 83687
83782: POP
83783: POP
// end ;
83784: GO 83495
83786: POP
83787: POP
// end ;
83788: LD_VAR 0 6
83792: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
83793: LD_INT 0
83795: PPUSH
83796: PPUSH
83797: PPUSH
83798: PPUSH
// if not mc_bases or not skirmish then
83799: LD_EXP 61
83803: NOT
83804: PUSH
83805: LD_EXP 59
83809: NOT
83810: OR
83811: IFFALSE 83815
// exit ;
83813: GO 84092
// side := GetSide ( lab ) ;
83815: LD_ADDR_VAR 0 4
83819: PUSH
83820: LD_VAR 0 2
83824: PPUSH
83825: CALL_OW 255
83829: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
83830: LD_VAR 0 4
83834: PUSH
83835: LD_EXP 87
83839: IN
83840: NOT
83841: PUSH
83842: LD_EXP 88
83846: NOT
83847: OR
83848: PUSH
83849: LD_EXP 61
83853: NOT
83854: OR
83855: IFFALSE 83859
// exit ;
83857: GO 84092
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
83859: LD_ADDR_EXP 88
83863: PUSH
83864: LD_EXP 88
83868: PPUSH
83869: LD_VAR 0 4
83873: PPUSH
83874: LD_EXP 88
83878: PUSH
83879: LD_VAR 0 4
83883: ARRAY
83884: PUSH
83885: LD_VAR 0 1
83889: DIFF
83890: PPUSH
83891: CALL_OW 1
83895: ST_TO_ADDR
// for i = 1 to mc_bases do
83896: LD_ADDR_VAR 0 5
83900: PUSH
83901: DOUBLE
83902: LD_INT 1
83904: DEC
83905: ST_TO_ADDR
83906: LD_EXP 61
83910: PUSH
83911: FOR_TO
83912: IFFALSE 84090
// begin if lab in mc_bases [ i ] then
83914: LD_VAR 0 2
83918: PUSH
83919: LD_EXP 61
83923: PUSH
83924: LD_VAR 0 5
83928: ARRAY
83929: IN
83930: IFFALSE 84088
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
83932: LD_VAR 0 1
83936: PUSH
83937: LD_INT 11
83939: PUSH
83940: LD_INT 4
83942: PUSH
83943: LD_INT 3
83945: PUSH
83946: LD_INT 2
83948: PUSH
83949: EMPTY
83950: LIST
83951: LIST
83952: LIST
83953: LIST
83954: IN
83955: PUSH
83956: LD_EXP 91
83960: PUSH
83961: LD_VAR 0 5
83965: ARRAY
83966: AND
83967: IFFALSE 84088
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
83969: LD_ADDR_VAR 0 6
83973: PUSH
83974: LD_EXP 91
83978: PUSH
83979: LD_VAR 0 5
83983: ARRAY
83984: PUSH
83985: LD_INT 1
83987: ARRAY
83988: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83989: LD_ADDR_EXP 91
83993: PUSH
83994: LD_EXP 91
83998: PPUSH
83999: LD_VAR 0 5
84003: PPUSH
84004: EMPTY
84005: PPUSH
84006: CALL_OW 1
84010: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
84011: LD_VAR 0 6
84015: PPUSH
84016: LD_INT 0
84018: PPUSH
84019: CALL_OW 109
// ComExitBuilding ( tmp ) ;
84023: LD_VAR 0 6
84027: PPUSH
84028: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
84032: LD_ADDR_EXP 90
84036: PUSH
84037: LD_EXP 90
84041: PPUSH
84042: LD_VAR 0 5
84046: PPUSH
84047: LD_EXP 90
84051: PUSH
84052: LD_VAR 0 5
84056: ARRAY
84057: PPUSH
84058: LD_INT 1
84060: PPUSH
84061: LD_VAR 0 6
84065: PPUSH
84066: CALL_OW 2
84070: PPUSH
84071: CALL_OW 1
84075: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
84076: LD_VAR 0 5
84080: PPUSH
84081: LD_INT 112
84083: PPUSH
84084: CALL 60540 0 2
// end ; end ; end ;
84088: GO 83911
84090: POP
84091: POP
// end ;
84092: LD_VAR 0 3
84096: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
84097: LD_INT 0
84099: PPUSH
84100: PPUSH
84101: PPUSH
84102: PPUSH
84103: PPUSH
84104: PPUSH
84105: PPUSH
84106: PPUSH
// if not mc_bases or not skirmish then
84107: LD_EXP 61
84111: NOT
84112: PUSH
84113: LD_EXP 59
84117: NOT
84118: OR
84119: IFFALSE 84123
// exit ;
84121: GO 85492
// for i = 1 to mc_bases do
84123: LD_ADDR_VAR 0 3
84127: PUSH
84128: DOUBLE
84129: LD_INT 1
84131: DEC
84132: ST_TO_ADDR
84133: LD_EXP 61
84137: PUSH
84138: FOR_TO
84139: IFFALSE 85490
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
84141: LD_VAR 0 1
84145: PUSH
84146: LD_EXP 61
84150: PUSH
84151: LD_VAR 0 3
84155: ARRAY
84156: IN
84157: PUSH
84158: LD_VAR 0 1
84162: PUSH
84163: LD_EXP 68
84167: PUSH
84168: LD_VAR 0 3
84172: ARRAY
84173: IN
84174: OR
84175: PUSH
84176: LD_VAR 0 1
84180: PUSH
84181: LD_EXP 83
84185: PUSH
84186: LD_VAR 0 3
84190: ARRAY
84191: IN
84192: OR
84193: PUSH
84194: LD_VAR 0 1
84198: PUSH
84199: LD_EXP 80
84203: PUSH
84204: LD_VAR 0 3
84208: ARRAY
84209: IN
84210: OR
84211: PUSH
84212: LD_VAR 0 1
84216: PUSH
84217: LD_EXP 90
84221: PUSH
84222: LD_VAR 0 3
84226: ARRAY
84227: IN
84228: OR
84229: PUSH
84230: LD_VAR 0 1
84234: PUSH
84235: LD_EXP 91
84239: PUSH
84240: LD_VAR 0 3
84244: ARRAY
84245: IN
84246: OR
84247: IFFALSE 85488
// begin if un in mc_ape [ i ] then
84249: LD_VAR 0 1
84253: PUSH
84254: LD_EXP 90
84258: PUSH
84259: LD_VAR 0 3
84263: ARRAY
84264: IN
84265: IFFALSE 84304
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
84267: LD_ADDR_EXP 90
84271: PUSH
84272: LD_EXP 90
84276: PPUSH
84277: LD_VAR 0 3
84281: PPUSH
84282: LD_EXP 90
84286: PUSH
84287: LD_VAR 0 3
84291: ARRAY
84292: PUSH
84293: LD_VAR 0 1
84297: DIFF
84298: PPUSH
84299: CALL_OW 1
84303: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
84304: LD_VAR 0 1
84308: PUSH
84309: LD_EXP 91
84313: PUSH
84314: LD_VAR 0 3
84318: ARRAY
84319: IN
84320: IFFALSE 84344
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84322: LD_ADDR_EXP 91
84326: PUSH
84327: LD_EXP 91
84331: PPUSH
84332: LD_VAR 0 3
84336: PPUSH
84337: EMPTY
84338: PPUSH
84339: CALL_OW 1
84343: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
84344: LD_VAR 0 1
84348: PPUSH
84349: CALL_OW 247
84353: PUSH
84354: LD_INT 2
84356: EQUAL
84357: PUSH
84358: LD_VAR 0 1
84362: PPUSH
84363: CALL_OW 110
84367: PUSH
84368: LD_INT 20
84370: EQUAL
84371: PUSH
84372: LD_VAR 0 1
84376: PUSH
84377: LD_EXP 83
84381: PUSH
84382: LD_VAR 0 3
84386: ARRAY
84387: IN
84388: OR
84389: PUSH
84390: LD_VAR 0 1
84394: PPUSH
84395: CALL_OW 264
84399: PUSH
84400: LD_INT 12
84402: PUSH
84403: LD_INT 51
84405: PUSH
84406: LD_INT 89
84408: PUSH
84409: LD_INT 32
84411: PUSH
84412: LD_INT 13
84414: PUSH
84415: LD_INT 52
84417: PUSH
84418: LD_INT 31
84420: PUSH
84421: EMPTY
84422: LIST
84423: LIST
84424: LIST
84425: LIST
84426: LIST
84427: LIST
84428: LIST
84429: IN
84430: OR
84431: AND
84432: IFFALSE 84740
// begin if un in mc_defender [ i ] then
84434: LD_VAR 0 1
84438: PUSH
84439: LD_EXP 83
84443: PUSH
84444: LD_VAR 0 3
84448: ARRAY
84449: IN
84450: IFFALSE 84489
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84452: LD_ADDR_EXP 83
84456: PUSH
84457: LD_EXP 83
84461: PPUSH
84462: LD_VAR 0 3
84466: PPUSH
84467: LD_EXP 83
84471: PUSH
84472: LD_VAR 0 3
84476: ARRAY
84477: PUSH
84478: LD_VAR 0 1
84482: DIFF
84483: PPUSH
84484: CALL_OW 1
84488: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
84489: LD_ADDR_VAR 0 8
84493: PUSH
84494: LD_VAR 0 3
84498: PPUSH
84499: LD_INT 3
84501: PPUSH
84502: CALL 81110 0 2
84506: ST_TO_ADDR
// if fac then
84507: LD_VAR 0 8
84511: IFFALSE 84740
// begin for j in fac do
84513: LD_ADDR_VAR 0 4
84517: PUSH
84518: LD_VAR 0 8
84522: PUSH
84523: FOR_IN
84524: IFFALSE 84738
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
84526: LD_ADDR_VAR 0 9
84530: PUSH
84531: LD_VAR 0 8
84535: PPUSH
84536: LD_VAR 0 1
84540: PPUSH
84541: CALL_OW 265
84545: PPUSH
84546: LD_VAR 0 1
84550: PPUSH
84551: CALL_OW 262
84555: PPUSH
84556: LD_VAR 0 1
84560: PPUSH
84561: CALL_OW 263
84565: PPUSH
84566: LD_VAR 0 1
84570: PPUSH
84571: CALL_OW 264
84575: PPUSH
84576: CALL 17585 0 5
84580: ST_TO_ADDR
// if components then
84581: LD_VAR 0 9
84585: IFFALSE 84736
// begin if GetWeapon ( un ) = ar_control_tower then
84587: LD_VAR 0 1
84591: PPUSH
84592: CALL_OW 264
84596: PUSH
84597: LD_INT 31
84599: EQUAL
84600: IFFALSE 84717
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
84602: LD_VAR 0 1
84606: PPUSH
84607: CALL_OW 311
84611: PPUSH
84612: LD_INT 0
84614: PPUSH
84615: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
84619: LD_ADDR_EXP 101
84623: PUSH
84624: LD_EXP 101
84628: PPUSH
84629: LD_VAR 0 3
84633: PPUSH
84634: LD_EXP 101
84638: PUSH
84639: LD_VAR 0 3
84643: ARRAY
84644: PUSH
84645: LD_VAR 0 1
84649: PPUSH
84650: CALL_OW 311
84654: DIFF
84655: PPUSH
84656: CALL_OW 1
84660: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
84661: LD_ADDR_VAR 0 7
84665: PUSH
84666: LD_EXP 82
84670: PUSH
84671: LD_VAR 0 3
84675: ARRAY
84676: PPUSH
84677: LD_INT 1
84679: PPUSH
84680: LD_VAR 0 9
84684: PPUSH
84685: CALL_OW 2
84689: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
84690: LD_ADDR_EXP 82
84694: PUSH
84695: LD_EXP 82
84699: PPUSH
84700: LD_VAR 0 3
84704: PPUSH
84705: LD_VAR 0 7
84709: PPUSH
84710: CALL_OW 1
84714: ST_TO_ADDR
// end else
84715: GO 84734
// MC_InsertProduceList ( i , [ components ] ) ;
84717: LD_VAR 0 3
84721: PPUSH
84722: LD_VAR 0 9
84726: PUSH
84727: EMPTY
84728: LIST
84729: PPUSH
84730: CALL 80655 0 2
// break ;
84734: GO 84738
// end ; end ;
84736: GO 84523
84738: POP
84739: POP
// end ; end ; if GetType ( un ) = unit_building then
84740: LD_VAR 0 1
84744: PPUSH
84745: CALL_OW 247
84749: PUSH
84750: LD_INT 3
84752: EQUAL
84753: IFFALSE 85156
// begin btype := GetBType ( un ) ;
84755: LD_ADDR_VAR 0 5
84759: PUSH
84760: LD_VAR 0 1
84764: PPUSH
84765: CALL_OW 266
84769: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
84770: LD_VAR 0 5
84774: PUSH
84775: LD_INT 29
84777: PUSH
84778: LD_INT 30
84780: PUSH
84781: EMPTY
84782: LIST
84783: LIST
84784: IN
84785: IFFALSE 84858
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
84787: LD_VAR 0 1
84791: PPUSH
84792: CALL_OW 250
84796: PPUSH
84797: LD_VAR 0 1
84801: PPUSH
84802: CALL_OW 251
84806: PPUSH
84807: LD_VAR 0 1
84811: PPUSH
84812: CALL_OW 255
84816: PPUSH
84817: CALL_OW 440
84821: NOT
84822: IFFALSE 84858
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
84824: LD_VAR 0 1
84828: PPUSH
84829: CALL_OW 250
84833: PPUSH
84834: LD_VAR 0 1
84838: PPUSH
84839: CALL_OW 251
84843: PPUSH
84844: LD_VAR 0 1
84848: PPUSH
84849: CALL_OW 255
84853: PPUSH
84854: CALL_OW 441
// end ; if btype = b_warehouse then
84858: LD_VAR 0 5
84862: PUSH
84863: LD_INT 1
84865: EQUAL
84866: IFFALSE 84884
// begin btype := b_depot ;
84868: LD_ADDR_VAR 0 5
84872: PUSH
84873: LD_INT 0
84875: ST_TO_ADDR
// pos := 1 ;
84876: LD_ADDR_VAR 0 6
84880: PUSH
84881: LD_INT 1
84883: ST_TO_ADDR
// end ; if btype = b_factory then
84884: LD_VAR 0 5
84888: PUSH
84889: LD_INT 3
84891: EQUAL
84892: IFFALSE 84910
// begin btype := b_workshop ;
84894: LD_ADDR_VAR 0 5
84898: PUSH
84899: LD_INT 2
84901: ST_TO_ADDR
// pos := 1 ;
84902: LD_ADDR_VAR 0 6
84906: PUSH
84907: LD_INT 1
84909: ST_TO_ADDR
// end ; if btype = b_barracks then
84910: LD_VAR 0 5
84914: PUSH
84915: LD_INT 5
84917: EQUAL
84918: IFFALSE 84928
// btype := b_armoury ;
84920: LD_ADDR_VAR 0 5
84924: PUSH
84925: LD_INT 4
84927: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
84928: LD_VAR 0 5
84932: PUSH
84933: LD_INT 7
84935: PUSH
84936: LD_INT 8
84938: PUSH
84939: EMPTY
84940: LIST
84941: LIST
84942: IN
84943: IFFALSE 84953
// btype := b_lab ;
84945: LD_ADDR_VAR 0 5
84949: PUSH
84950: LD_INT 6
84952: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
84953: LD_ADDR_EXP 66
84957: PUSH
84958: LD_EXP 66
84962: PPUSH
84963: LD_VAR 0 3
84967: PUSH
84968: LD_EXP 66
84972: PUSH
84973: LD_VAR 0 3
84977: ARRAY
84978: PUSH
84979: LD_INT 1
84981: PLUS
84982: PUSH
84983: EMPTY
84984: LIST
84985: LIST
84986: PPUSH
84987: LD_VAR 0 5
84991: PUSH
84992: LD_VAR 0 1
84996: PPUSH
84997: CALL_OW 250
85001: PUSH
85002: LD_VAR 0 1
85006: PPUSH
85007: CALL_OW 251
85011: PUSH
85012: LD_VAR 0 1
85016: PPUSH
85017: CALL_OW 254
85021: PUSH
85022: EMPTY
85023: LIST
85024: LIST
85025: LIST
85026: LIST
85027: PPUSH
85028: CALL 20087 0 3
85032: ST_TO_ADDR
// if pos = 1 then
85033: LD_VAR 0 6
85037: PUSH
85038: LD_INT 1
85040: EQUAL
85041: IFFALSE 85156
// begin tmp := mc_build_list [ i ] ;
85043: LD_ADDR_VAR 0 7
85047: PUSH
85048: LD_EXP 66
85052: PUSH
85053: LD_VAR 0 3
85057: ARRAY
85058: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
85059: LD_VAR 0 7
85063: PPUSH
85064: LD_INT 2
85066: PUSH
85067: LD_INT 30
85069: PUSH
85070: LD_INT 0
85072: PUSH
85073: EMPTY
85074: LIST
85075: LIST
85076: PUSH
85077: LD_INT 30
85079: PUSH
85080: LD_INT 1
85082: PUSH
85083: EMPTY
85084: LIST
85085: LIST
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: LIST
85091: PPUSH
85092: CALL_OW 72
85096: IFFALSE 85106
// pos := 2 ;
85098: LD_ADDR_VAR 0 6
85102: PUSH
85103: LD_INT 2
85105: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
85106: LD_ADDR_VAR 0 7
85110: PUSH
85111: LD_VAR 0 7
85115: PPUSH
85116: LD_VAR 0 6
85120: PPUSH
85121: LD_VAR 0 7
85125: PPUSH
85126: CALL 20413 0 3
85130: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
85131: LD_ADDR_EXP 66
85135: PUSH
85136: LD_EXP 66
85140: PPUSH
85141: LD_VAR 0 3
85145: PPUSH
85146: LD_VAR 0 7
85150: PPUSH
85151: CALL_OW 1
85155: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
85156: LD_VAR 0 1
85160: PUSH
85161: LD_EXP 61
85165: PUSH
85166: LD_VAR 0 3
85170: ARRAY
85171: IN
85172: IFFALSE 85211
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
85174: LD_ADDR_EXP 61
85178: PUSH
85179: LD_EXP 61
85183: PPUSH
85184: LD_VAR 0 3
85188: PPUSH
85189: LD_EXP 61
85193: PUSH
85194: LD_VAR 0 3
85198: ARRAY
85199: PUSH
85200: LD_VAR 0 1
85204: DIFF
85205: PPUSH
85206: CALL_OW 1
85210: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
85211: LD_VAR 0 1
85215: PUSH
85216: LD_EXP 68
85220: PUSH
85221: LD_VAR 0 3
85225: ARRAY
85226: IN
85227: IFFALSE 85266
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
85229: LD_ADDR_EXP 68
85233: PUSH
85234: LD_EXP 68
85238: PPUSH
85239: LD_VAR 0 3
85243: PPUSH
85244: LD_EXP 68
85248: PUSH
85249: LD_VAR 0 3
85253: ARRAY
85254: PUSH
85255: LD_VAR 0 1
85259: DIFF
85260: PPUSH
85261: CALL_OW 1
85265: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
85266: LD_VAR 0 1
85270: PUSH
85271: LD_EXP 80
85275: PUSH
85276: LD_VAR 0 3
85280: ARRAY
85281: IN
85282: IFFALSE 85321
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
85284: LD_ADDR_EXP 80
85288: PUSH
85289: LD_EXP 80
85293: PPUSH
85294: LD_VAR 0 3
85298: PPUSH
85299: LD_EXP 80
85303: PUSH
85304: LD_VAR 0 3
85308: ARRAY
85309: PUSH
85310: LD_VAR 0 1
85314: DIFF
85315: PPUSH
85316: CALL_OW 1
85320: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
85321: LD_VAR 0 1
85325: PUSH
85326: LD_EXP 83
85330: PUSH
85331: LD_VAR 0 3
85335: ARRAY
85336: IN
85337: IFFALSE 85376
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85339: LD_ADDR_EXP 83
85343: PUSH
85344: LD_EXP 83
85348: PPUSH
85349: LD_VAR 0 3
85353: PPUSH
85354: LD_EXP 83
85358: PUSH
85359: LD_VAR 0 3
85363: ARRAY
85364: PUSH
85365: LD_VAR 0 1
85369: DIFF
85370: PPUSH
85371: CALL_OW 1
85375: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
85376: LD_VAR 0 1
85380: PUSH
85381: LD_EXP 70
85385: PUSH
85386: LD_VAR 0 3
85390: ARRAY
85391: IN
85392: IFFALSE 85431
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
85394: LD_ADDR_EXP 70
85398: PUSH
85399: LD_EXP 70
85403: PPUSH
85404: LD_VAR 0 3
85408: PPUSH
85409: LD_EXP 70
85413: PUSH
85414: LD_VAR 0 3
85418: ARRAY
85419: PUSH
85420: LD_VAR 0 1
85424: DIFF
85425: PPUSH
85426: CALL_OW 1
85430: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
85431: LD_VAR 0 1
85435: PUSH
85436: LD_EXP 69
85440: PUSH
85441: LD_VAR 0 3
85445: ARRAY
85446: IN
85447: IFFALSE 85486
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
85449: LD_ADDR_EXP 69
85453: PUSH
85454: LD_EXP 69
85458: PPUSH
85459: LD_VAR 0 3
85463: PPUSH
85464: LD_EXP 69
85468: PUSH
85469: LD_VAR 0 3
85473: ARRAY
85474: PUSH
85475: LD_VAR 0 1
85479: DIFF
85480: PPUSH
85481: CALL_OW 1
85485: ST_TO_ADDR
// end ; break ;
85486: GO 85490
// end ;
85488: GO 84138
85490: POP
85491: POP
// end ;
85492: LD_VAR 0 2
85496: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
85497: LD_INT 0
85499: PPUSH
85500: PPUSH
85501: PPUSH
// if not mc_bases or not skirmish then
85502: LD_EXP 61
85506: NOT
85507: PUSH
85508: LD_EXP 59
85512: NOT
85513: OR
85514: IFFALSE 85518
// exit ;
85516: GO 85733
// for i = 1 to mc_bases do
85518: LD_ADDR_VAR 0 3
85522: PUSH
85523: DOUBLE
85524: LD_INT 1
85526: DEC
85527: ST_TO_ADDR
85528: LD_EXP 61
85532: PUSH
85533: FOR_TO
85534: IFFALSE 85731
// begin if building in mc_construct_list [ i ] then
85536: LD_VAR 0 1
85540: PUSH
85541: LD_EXP 68
85545: PUSH
85546: LD_VAR 0 3
85550: ARRAY
85551: IN
85552: IFFALSE 85729
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85554: LD_ADDR_EXP 68
85558: PUSH
85559: LD_EXP 68
85563: PPUSH
85564: LD_VAR 0 3
85568: PPUSH
85569: LD_EXP 68
85573: PUSH
85574: LD_VAR 0 3
85578: ARRAY
85579: PUSH
85580: LD_VAR 0 1
85584: DIFF
85585: PPUSH
85586: CALL_OW 1
85590: ST_TO_ADDR
// if building in mc_lab [ i ] then
85591: LD_VAR 0 1
85595: PUSH
85596: LD_EXP 94
85600: PUSH
85601: LD_VAR 0 3
85605: ARRAY
85606: IN
85607: IFFALSE 85662
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
85609: LD_ADDR_EXP 95
85613: PUSH
85614: LD_EXP 95
85618: PPUSH
85619: LD_VAR 0 3
85623: PPUSH
85624: LD_EXP 95
85628: PUSH
85629: LD_VAR 0 3
85633: ARRAY
85634: PPUSH
85635: LD_INT 1
85637: PPUSH
85638: LD_EXP 95
85642: PUSH
85643: LD_VAR 0 3
85647: ARRAY
85648: PPUSH
85649: LD_INT 0
85651: PPUSH
85652: CALL 19505 0 4
85656: PPUSH
85657: CALL_OW 1
85661: ST_TO_ADDR
// if not building in mc_bases [ i ] then
85662: LD_VAR 0 1
85666: PUSH
85667: LD_EXP 61
85671: PUSH
85672: LD_VAR 0 3
85676: ARRAY
85677: IN
85678: NOT
85679: IFFALSE 85725
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85681: LD_ADDR_EXP 61
85685: PUSH
85686: LD_EXP 61
85690: PPUSH
85691: LD_VAR 0 3
85695: PUSH
85696: LD_EXP 61
85700: PUSH
85701: LD_VAR 0 3
85705: ARRAY
85706: PUSH
85707: LD_INT 1
85709: PLUS
85710: PUSH
85711: EMPTY
85712: LIST
85713: LIST
85714: PPUSH
85715: LD_VAR 0 1
85719: PPUSH
85720: CALL 20087 0 3
85724: ST_TO_ADDR
// exit ;
85725: POP
85726: POP
85727: GO 85733
// end ; end ;
85729: GO 85533
85731: POP
85732: POP
// end ;
85733: LD_VAR 0 2
85737: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
85738: LD_INT 0
85740: PPUSH
85741: PPUSH
85742: PPUSH
85743: PPUSH
85744: PPUSH
85745: PPUSH
85746: PPUSH
// if not mc_bases or not skirmish then
85747: LD_EXP 61
85751: NOT
85752: PUSH
85753: LD_EXP 59
85757: NOT
85758: OR
85759: IFFALSE 85763
// exit ;
85761: GO 86424
// for i = 1 to mc_bases do
85763: LD_ADDR_VAR 0 3
85767: PUSH
85768: DOUBLE
85769: LD_INT 1
85771: DEC
85772: ST_TO_ADDR
85773: LD_EXP 61
85777: PUSH
85778: FOR_TO
85779: IFFALSE 86422
// begin if building in mc_construct_list [ i ] then
85781: LD_VAR 0 1
85785: PUSH
85786: LD_EXP 68
85790: PUSH
85791: LD_VAR 0 3
85795: ARRAY
85796: IN
85797: IFFALSE 86420
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85799: LD_ADDR_EXP 68
85803: PUSH
85804: LD_EXP 68
85808: PPUSH
85809: LD_VAR 0 3
85813: PPUSH
85814: LD_EXP 68
85818: PUSH
85819: LD_VAR 0 3
85823: ARRAY
85824: PUSH
85825: LD_VAR 0 1
85829: DIFF
85830: PPUSH
85831: CALL_OW 1
85835: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85836: LD_ADDR_EXP 61
85840: PUSH
85841: LD_EXP 61
85845: PPUSH
85846: LD_VAR 0 3
85850: PUSH
85851: LD_EXP 61
85855: PUSH
85856: LD_VAR 0 3
85860: ARRAY
85861: PUSH
85862: LD_INT 1
85864: PLUS
85865: PUSH
85866: EMPTY
85867: LIST
85868: LIST
85869: PPUSH
85870: LD_VAR 0 1
85874: PPUSH
85875: CALL 20087 0 3
85879: ST_TO_ADDR
// btype := GetBType ( building ) ;
85880: LD_ADDR_VAR 0 5
85884: PUSH
85885: LD_VAR 0 1
85889: PPUSH
85890: CALL_OW 266
85894: ST_TO_ADDR
// side := GetSide ( building ) ;
85895: LD_ADDR_VAR 0 8
85899: PUSH
85900: LD_VAR 0 1
85904: PPUSH
85905: CALL_OW 255
85909: ST_TO_ADDR
// if btype = b_lab then
85910: LD_VAR 0 5
85914: PUSH
85915: LD_INT 6
85917: EQUAL
85918: IFFALSE 85968
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
85920: LD_ADDR_EXP 94
85924: PUSH
85925: LD_EXP 94
85929: PPUSH
85930: LD_VAR 0 3
85934: PUSH
85935: LD_EXP 94
85939: PUSH
85940: LD_VAR 0 3
85944: ARRAY
85945: PUSH
85946: LD_INT 1
85948: PLUS
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: PPUSH
85954: LD_VAR 0 1
85958: PPUSH
85959: CALL 20087 0 3
85963: ST_TO_ADDR
// exit ;
85964: POP
85965: POP
85966: GO 86424
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
85968: LD_VAR 0 5
85972: PUSH
85973: LD_INT 0
85975: PUSH
85976: LD_INT 2
85978: PUSH
85979: LD_INT 4
85981: PUSH
85982: EMPTY
85983: LIST
85984: LIST
85985: LIST
85986: IN
85987: IFFALSE 86111
// begin if btype = b_armoury then
85989: LD_VAR 0 5
85993: PUSH
85994: LD_INT 4
85996: EQUAL
85997: IFFALSE 86007
// btype := b_barracks ;
85999: LD_ADDR_VAR 0 5
86003: PUSH
86004: LD_INT 5
86006: ST_TO_ADDR
// if btype = b_depot then
86007: LD_VAR 0 5
86011: PUSH
86012: LD_INT 0
86014: EQUAL
86015: IFFALSE 86025
// btype := b_warehouse ;
86017: LD_ADDR_VAR 0 5
86021: PUSH
86022: LD_INT 1
86024: ST_TO_ADDR
// if btype = b_workshop then
86025: LD_VAR 0 5
86029: PUSH
86030: LD_INT 2
86032: EQUAL
86033: IFFALSE 86043
// btype := b_factory ;
86035: LD_ADDR_VAR 0 5
86039: PUSH
86040: LD_INT 3
86042: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
86043: LD_VAR 0 5
86047: PPUSH
86048: LD_VAR 0 8
86052: PPUSH
86053: CALL_OW 323
86057: PUSH
86058: LD_INT 1
86060: EQUAL
86061: IFFALSE 86107
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
86063: LD_ADDR_EXP 93
86067: PUSH
86068: LD_EXP 93
86072: PPUSH
86073: LD_VAR 0 3
86077: PUSH
86078: LD_EXP 93
86082: PUSH
86083: LD_VAR 0 3
86087: ARRAY
86088: PUSH
86089: LD_INT 1
86091: PLUS
86092: PUSH
86093: EMPTY
86094: LIST
86095: LIST
86096: PPUSH
86097: LD_VAR 0 1
86101: PPUSH
86102: CALL 20087 0 3
86106: ST_TO_ADDR
// exit ;
86107: POP
86108: POP
86109: GO 86424
// end ; if btype in [ b_bunker , b_turret ] then
86111: LD_VAR 0 5
86115: PUSH
86116: LD_INT 32
86118: PUSH
86119: LD_INT 33
86121: PUSH
86122: EMPTY
86123: LIST
86124: LIST
86125: IN
86126: IFFALSE 86416
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
86128: LD_ADDR_EXP 69
86132: PUSH
86133: LD_EXP 69
86137: PPUSH
86138: LD_VAR 0 3
86142: PUSH
86143: LD_EXP 69
86147: PUSH
86148: LD_VAR 0 3
86152: ARRAY
86153: PUSH
86154: LD_INT 1
86156: PLUS
86157: PUSH
86158: EMPTY
86159: LIST
86160: LIST
86161: PPUSH
86162: LD_VAR 0 1
86166: PPUSH
86167: CALL 20087 0 3
86171: ST_TO_ADDR
// if btype = b_bunker then
86172: LD_VAR 0 5
86176: PUSH
86177: LD_INT 32
86179: EQUAL
86180: IFFALSE 86416
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86182: LD_ADDR_EXP 70
86186: PUSH
86187: LD_EXP 70
86191: PPUSH
86192: LD_VAR 0 3
86196: PUSH
86197: LD_EXP 70
86201: PUSH
86202: LD_VAR 0 3
86206: ARRAY
86207: PUSH
86208: LD_INT 1
86210: PLUS
86211: PUSH
86212: EMPTY
86213: LIST
86214: LIST
86215: PPUSH
86216: LD_VAR 0 1
86220: PPUSH
86221: CALL 20087 0 3
86225: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
86226: LD_ADDR_VAR 0 6
86230: PUSH
86231: LD_EXP 61
86235: PUSH
86236: LD_VAR 0 3
86240: ARRAY
86241: PPUSH
86242: LD_INT 25
86244: PUSH
86245: LD_INT 1
86247: PUSH
86248: EMPTY
86249: LIST
86250: LIST
86251: PUSH
86252: LD_INT 3
86254: PUSH
86255: LD_INT 54
86257: PUSH
86258: EMPTY
86259: LIST
86260: PUSH
86261: EMPTY
86262: LIST
86263: LIST
86264: PUSH
86265: EMPTY
86266: LIST
86267: LIST
86268: PPUSH
86269: CALL_OW 72
86273: ST_TO_ADDR
// if tmp then
86274: LD_VAR 0 6
86278: IFFALSE 86284
// exit ;
86280: POP
86281: POP
86282: GO 86424
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86284: LD_ADDR_VAR 0 6
86288: PUSH
86289: LD_EXP 61
86293: PUSH
86294: LD_VAR 0 3
86298: ARRAY
86299: PPUSH
86300: LD_INT 2
86302: PUSH
86303: LD_INT 30
86305: PUSH
86306: LD_INT 4
86308: PUSH
86309: EMPTY
86310: LIST
86311: LIST
86312: PUSH
86313: LD_INT 30
86315: PUSH
86316: LD_INT 5
86318: PUSH
86319: EMPTY
86320: LIST
86321: LIST
86322: PUSH
86323: EMPTY
86324: LIST
86325: LIST
86326: LIST
86327: PPUSH
86328: CALL_OW 72
86332: ST_TO_ADDR
// if not tmp then
86333: LD_VAR 0 6
86337: NOT
86338: IFFALSE 86344
// exit ;
86340: POP
86341: POP
86342: GO 86424
// for j in tmp do
86344: LD_ADDR_VAR 0 4
86348: PUSH
86349: LD_VAR 0 6
86353: PUSH
86354: FOR_IN
86355: IFFALSE 86414
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
86357: LD_ADDR_VAR 0 7
86361: PUSH
86362: LD_VAR 0 4
86366: PPUSH
86367: CALL_OW 313
86371: PPUSH
86372: LD_INT 25
86374: PUSH
86375: LD_INT 1
86377: PUSH
86378: EMPTY
86379: LIST
86380: LIST
86381: PPUSH
86382: CALL_OW 72
86386: ST_TO_ADDR
// if units then
86387: LD_VAR 0 7
86391: IFFALSE 86412
// begin ComExitBuilding ( units [ 1 ] ) ;
86393: LD_VAR 0 7
86397: PUSH
86398: LD_INT 1
86400: ARRAY
86401: PPUSH
86402: CALL_OW 122
// exit ;
86406: POP
86407: POP
86408: POP
86409: POP
86410: GO 86424
// end ; end ;
86412: GO 86354
86414: POP
86415: POP
// end ; end ; exit ;
86416: POP
86417: POP
86418: GO 86424
// end ; end ;
86420: GO 85778
86422: POP
86423: POP
// end ;
86424: LD_VAR 0 2
86428: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
86429: LD_INT 0
86431: PPUSH
86432: PPUSH
86433: PPUSH
86434: PPUSH
86435: PPUSH
86436: PPUSH
86437: PPUSH
// if not mc_bases or not skirmish then
86438: LD_EXP 61
86442: NOT
86443: PUSH
86444: LD_EXP 59
86448: NOT
86449: OR
86450: IFFALSE 86454
// exit ;
86452: GO 86719
// btype := GetBType ( building ) ;
86454: LD_ADDR_VAR 0 6
86458: PUSH
86459: LD_VAR 0 1
86463: PPUSH
86464: CALL_OW 266
86468: ST_TO_ADDR
// x := GetX ( building ) ;
86469: LD_ADDR_VAR 0 7
86473: PUSH
86474: LD_VAR 0 1
86478: PPUSH
86479: CALL_OW 250
86483: ST_TO_ADDR
// y := GetY ( building ) ;
86484: LD_ADDR_VAR 0 8
86488: PUSH
86489: LD_VAR 0 1
86493: PPUSH
86494: CALL_OW 251
86498: ST_TO_ADDR
// d := GetDir ( building ) ;
86499: LD_ADDR_VAR 0 9
86503: PUSH
86504: LD_VAR 0 1
86508: PPUSH
86509: CALL_OW 254
86513: ST_TO_ADDR
// for i = 1 to mc_bases do
86514: LD_ADDR_VAR 0 4
86518: PUSH
86519: DOUBLE
86520: LD_INT 1
86522: DEC
86523: ST_TO_ADDR
86524: LD_EXP 61
86528: PUSH
86529: FOR_TO
86530: IFFALSE 86717
// begin if not mc_build_list [ i ] then
86532: LD_EXP 66
86536: PUSH
86537: LD_VAR 0 4
86541: ARRAY
86542: NOT
86543: IFFALSE 86547
// continue ;
86545: GO 86529
// for j := 1 to mc_build_list [ i ] do
86547: LD_ADDR_VAR 0 5
86551: PUSH
86552: DOUBLE
86553: LD_INT 1
86555: DEC
86556: ST_TO_ADDR
86557: LD_EXP 66
86561: PUSH
86562: LD_VAR 0 4
86566: ARRAY
86567: PUSH
86568: FOR_TO
86569: IFFALSE 86713
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
86571: LD_VAR 0 6
86575: PUSH
86576: LD_VAR 0 7
86580: PUSH
86581: LD_VAR 0 8
86585: PUSH
86586: LD_VAR 0 9
86590: PUSH
86591: EMPTY
86592: LIST
86593: LIST
86594: LIST
86595: LIST
86596: PPUSH
86597: LD_EXP 66
86601: PUSH
86602: LD_VAR 0 4
86606: ARRAY
86607: PUSH
86608: LD_VAR 0 5
86612: ARRAY
86613: PPUSH
86614: CALL 26267 0 2
86618: IFFALSE 86711
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
86620: LD_ADDR_EXP 66
86624: PUSH
86625: LD_EXP 66
86629: PPUSH
86630: LD_VAR 0 4
86634: PPUSH
86635: LD_EXP 66
86639: PUSH
86640: LD_VAR 0 4
86644: ARRAY
86645: PPUSH
86646: LD_VAR 0 5
86650: PPUSH
86651: CALL_OW 3
86655: PPUSH
86656: CALL_OW 1
86660: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
86661: LD_ADDR_EXP 68
86665: PUSH
86666: LD_EXP 68
86670: PPUSH
86671: LD_VAR 0 4
86675: PUSH
86676: LD_EXP 68
86680: PUSH
86681: LD_VAR 0 4
86685: ARRAY
86686: PUSH
86687: LD_INT 1
86689: PLUS
86690: PUSH
86691: EMPTY
86692: LIST
86693: LIST
86694: PPUSH
86695: LD_VAR 0 1
86699: PPUSH
86700: CALL 20087 0 3
86704: ST_TO_ADDR
// exit ;
86705: POP
86706: POP
86707: POP
86708: POP
86709: GO 86719
// end ;
86711: GO 86568
86713: POP
86714: POP
// end ;
86715: GO 86529
86717: POP
86718: POP
// end ;
86719: LD_VAR 0 3
86723: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
86724: LD_INT 0
86726: PPUSH
86727: PPUSH
86728: PPUSH
// if not mc_bases or not skirmish then
86729: LD_EXP 61
86733: NOT
86734: PUSH
86735: LD_EXP 59
86739: NOT
86740: OR
86741: IFFALSE 86745
// exit ;
86743: GO 86935
// for i = 1 to mc_bases do
86745: LD_ADDR_VAR 0 4
86749: PUSH
86750: DOUBLE
86751: LD_INT 1
86753: DEC
86754: ST_TO_ADDR
86755: LD_EXP 61
86759: PUSH
86760: FOR_TO
86761: IFFALSE 86848
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
86763: LD_VAR 0 1
86767: PUSH
86768: LD_EXP 69
86772: PUSH
86773: LD_VAR 0 4
86777: ARRAY
86778: IN
86779: PUSH
86780: LD_VAR 0 1
86784: PUSH
86785: LD_EXP 70
86789: PUSH
86790: LD_VAR 0 4
86794: ARRAY
86795: IN
86796: NOT
86797: AND
86798: IFFALSE 86846
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86800: LD_ADDR_EXP 70
86804: PUSH
86805: LD_EXP 70
86809: PPUSH
86810: LD_VAR 0 4
86814: PUSH
86815: LD_EXP 70
86819: PUSH
86820: LD_VAR 0 4
86824: ARRAY
86825: PUSH
86826: LD_INT 1
86828: PLUS
86829: PUSH
86830: EMPTY
86831: LIST
86832: LIST
86833: PPUSH
86834: LD_VAR 0 1
86838: PPUSH
86839: CALL 20087 0 3
86843: ST_TO_ADDR
// break ;
86844: GO 86848
// end ; end ;
86846: GO 86760
86848: POP
86849: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
86850: LD_VAR 0 1
86854: PPUSH
86855: CALL_OW 257
86859: PUSH
86860: LD_EXP 87
86864: IN
86865: PUSH
86866: LD_VAR 0 1
86870: PPUSH
86871: CALL_OW 266
86875: PUSH
86876: LD_INT 5
86878: EQUAL
86879: AND
86880: PUSH
86881: LD_VAR 0 2
86885: PPUSH
86886: CALL_OW 110
86890: PUSH
86891: LD_INT 18
86893: NONEQUAL
86894: AND
86895: IFFALSE 86935
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
86897: LD_VAR 0 2
86901: PPUSH
86902: CALL_OW 257
86906: PUSH
86907: LD_INT 5
86909: PUSH
86910: LD_INT 8
86912: PUSH
86913: LD_INT 9
86915: PUSH
86916: EMPTY
86917: LIST
86918: LIST
86919: LIST
86920: IN
86921: IFFALSE 86935
// SetClass ( unit , 1 ) ;
86923: LD_VAR 0 2
86927: PPUSH
86928: LD_INT 1
86930: PPUSH
86931: CALL_OW 336
// end ;
86935: LD_VAR 0 3
86939: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
86940: LD_INT 0
86942: PPUSH
86943: PPUSH
// if not mc_bases or not skirmish then
86944: LD_EXP 61
86948: NOT
86949: PUSH
86950: LD_EXP 59
86954: NOT
86955: OR
86956: IFFALSE 86960
// exit ;
86958: GO 87076
// if GetLives ( abandoned_vehicle ) > 250 then
86960: LD_VAR 0 2
86964: PPUSH
86965: CALL_OW 256
86969: PUSH
86970: LD_INT 250
86972: GREATER
86973: IFFALSE 86977
// exit ;
86975: GO 87076
// for i = 1 to mc_bases do
86977: LD_ADDR_VAR 0 6
86981: PUSH
86982: DOUBLE
86983: LD_INT 1
86985: DEC
86986: ST_TO_ADDR
86987: LD_EXP 61
86991: PUSH
86992: FOR_TO
86993: IFFALSE 87074
// begin if driver in mc_bases [ i ] then
86995: LD_VAR 0 1
86999: PUSH
87000: LD_EXP 61
87004: PUSH
87005: LD_VAR 0 6
87009: ARRAY
87010: IN
87011: IFFALSE 87072
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
87013: LD_VAR 0 1
87017: PPUSH
87018: LD_EXP 61
87022: PUSH
87023: LD_VAR 0 6
87027: ARRAY
87028: PPUSH
87029: LD_INT 2
87031: PUSH
87032: LD_INT 30
87034: PUSH
87035: LD_INT 0
87037: PUSH
87038: EMPTY
87039: LIST
87040: LIST
87041: PUSH
87042: LD_INT 30
87044: PUSH
87045: LD_INT 1
87047: PUSH
87048: EMPTY
87049: LIST
87050: LIST
87051: PUSH
87052: EMPTY
87053: LIST
87054: LIST
87055: LIST
87056: PPUSH
87057: CALL_OW 72
87061: PUSH
87062: LD_INT 1
87064: ARRAY
87065: PPUSH
87066: CALL 53295 0 2
// break ;
87070: GO 87074
// end ; end ;
87072: GO 86992
87074: POP
87075: POP
// end ; end_of_file end_of_file
87076: LD_VAR 0 5
87080: RET
// export globalGameSaveCounter ; every 0 0$1 do
87081: GO 87083
87083: DISABLE
// begin enable ;
87084: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
87085: LD_STRING updateTimer(
87087: PUSH
87088: LD_OWVAR 1
87092: STR
87093: PUSH
87094: LD_STRING );
87096: STR
87097: PPUSH
87098: CALL_OW 559
// end ;
87102: END
// every 0 0$1 do
87103: GO 87105
87105: DISABLE
// begin globalGameSaveCounter := 0 ;
87106: LD_ADDR_EXP 106
87110: PUSH
87111: LD_INT 0
87113: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
87114: LD_STRING setGameSaveCounter(0)
87116: PPUSH
87117: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
87121: LD_STRING initStreamRollete();
87123: PPUSH
87124: CALL_OW 559
// InitStreamMode ;
87128: CALL 88454 0 0
// DefineStreamItems ( false ) ;
87132: LD_INT 0
87134: PPUSH
87135: CALL 88918 0 1
// end ;
87139: END
// export function SOS_MapStart ( ) ; begin
87140: LD_INT 0
87142: PPUSH
// if streamModeActive then
87143: LD_EXP 107
87147: IFFALSE 87156
// DefineStreamItems ( true ) ;
87149: LD_INT 1
87151: PPUSH
87152: CALL 88918 0 1
// UpdateLuaVariables ( ) ;
87156: CALL 87173 0 0
// UpdateFactoryWaypoints ( ) ;
87160: CALL 101779 0 0
// UpdateWarehouseGatheringPoints ( ) ;
87164: CALL 102036 0 0
// end ;
87168: LD_VAR 0 1
87172: RET
// function UpdateLuaVariables ( ) ; begin
87173: LD_INT 0
87175: PPUSH
// if globalGameSaveCounter then
87176: LD_EXP 106
87180: IFFALSE 87214
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
87182: LD_ADDR_EXP 106
87186: PUSH
87187: LD_EXP 106
87191: PPUSH
87192: CALL 53779 0 1
87196: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
87197: LD_STRING setGameSaveCounter(
87199: PUSH
87200: LD_EXP 106
87204: STR
87205: PUSH
87206: LD_STRING )
87208: STR
87209: PPUSH
87210: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
87214: LD_STRING setGameDifficulty(
87216: PUSH
87217: LD_OWVAR 67
87221: STR
87222: PUSH
87223: LD_STRING )
87225: STR
87226: PPUSH
87227: CALL_OW 559
// end ;
87231: LD_VAR 0 1
87235: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
87236: LD_INT 0
87238: PPUSH
// if p2 = stream_mode then
87239: LD_VAR 0 2
87243: PUSH
87244: LD_INT 100
87246: EQUAL
87247: IFFALSE 88250
// begin if not StreamModeActive then
87249: LD_EXP 107
87253: NOT
87254: IFFALSE 87264
// StreamModeActive := true ;
87256: LD_ADDR_EXP 107
87260: PUSH
87261: LD_INT 1
87263: ST_TO_ADDR
// if p3 = 0 then
87264: LD_VAR 0 3
87268: PUSH
87269: LD_INT 0
87271: EQUAL
87272: IFFALSE 87278
// InitStreamMode ;
87274: CALL 88454 0 0
// if p3 = 1 then
87278: LD_VAR 0 3
87282: PUSH
87283: LD_INT 1
87285: EQUAL
87286: IFFALSE 87296
// sRocket := true ;
87288: LD_ADDR_EXP 112
87292: PUSH
87293: LD_INT 1
87295: ST_TO_ADDR
// if p3 = 2 then
87296: LD_VAR 0 3
87300: PUSH
87301: LD_INT 2
87303: EQUAL
87304: IFFALSE 87314
// sSpeed := true ;
87306: LD_ADDR_EXP 111
87310: PUSH
87311: LD_INT 1
87313: ST_TO_ADDR
// if p3 = 3 then
87314: LD_VAR 0 3
87318: PUSH
87319: LD_INT 3
87321: EQUAL
87322: IFFALSE 87332
// sEngine := true ;
87324: LD_ADDR_EXP 113
87328: PUSH
87329: LD_INT 1
87331: ST_TO_ADDR
// if p3 = 4 then
87332: LD_VAR 0 3
87336: PUSH
87337: LD_INT 4
87339: EQUAL
87340: IFFALSE 87350
// sSpec := true ;
87342: LD_ADDR_EXP 110
87346: PUSH
87347: LD_INT 1
87349: ST_TO_ADDR
// if p3 = 5 then
87350: LD_VAR 0 3
87354: PUSH
87355: LD_INT 5
87357: EQUAL
87358: IFFALSE 87368
// sLevel := true ;
87360: LD_ADDR_EXP 114
87364: PUSH
87365: LD_INT 1
87367: ST_TO_ADDR
// if p3 = 6 then
87368: LD_VAR 0 3
87372: PUSH
87373: LD_INT 6
87375: EQUAL
87376: IFFALSE 87386
// sArmoury := true ;
87378: LD_ADDR_EXP 115
87382: PUSH
87383: LD_INT 1
87385: ST_TO_ADDR
// if p3 = 7 then
87386: LD_VAR 0 3
87390: PUSH
87391: LD_INT 7
87393: EQUAL
87394: IFFALSE 87404
// sRadar := true ;
87396: LD_ADDR_EXP 116
87400: PUSH
87401: LD_INT 1
87403: ST_TO_ADDR
// if p3 = 8 then
87404: LD_VAR 0 3
87408: PUSH
87409: LD_INT 8
87411: EQUAL
87412: IFFALSE 87422
// sBunker := true ;
87414: LD_ADDR_EXP 117
87418: PUSH
87419: LD_INT 1
87421: ST_TO_ADDR
// if p3 = 9 then
87422: LD_VAR 0 3
87426: PUSH
87427: LD_INT 9
87429: EQUAL
87430: IFFALSE 87440
// sHack := true ;
87432: LD_ADDR_EXP 118
87436: PUSH
87437: LD_INT 1
87439: ST_TO_ADDR
// if p3 = 10 then
87440: LD_VAR 0 3
87444: PUSH
87445: LD_INT 10
87447: EQUAL
87448: IFFALSE 87458
// sFire := true ;
87450: LD_ADDR_EXP 119
87454: PUSH
87455: LD_INT 1
87457: ST_TO_ADDR
// if p3 = 11 then
87458: LD_VAR 0 3
87462: PUSH
87463: LD_INT 11
87465: EQUAL
87466: IFFALSE 87476
// sRefresh := true ;
87468: LD_ADDR_EXP 120
87472: PUSH
87473: LD_INT 1
87475: ST_TO_ADDR
// if p3 = 12 then
87476: LD_VAR 0 3
87480: PUSH
87481: LD_INT 12
87483: EQUAL
87484: IFFALSE 87494
// sExp := true ;
87486: LD_ADDR_EXP 121
87490: PUSH
87491: LD_INT 1
87493: ST_TO_ADDR
// if p3 = 13 then
87494: LD_VAR 0 3
87498: PUSH
87499: LD_INT 13
87501: EQUAL
87502: IFFALSE 87512
// sDepot := true ;
87504: LD_ADDR_EXP 122
87508: PUSH
87509: LD_INT 1
87511: ST_TO_ADDR
// if p3 = 14 then
87512: LD_VAR 0 3
87516: PUSH
87517: LD_INT 14
87519: EQUAL
87520: IFFALSE 87530
// sFlag := true ;
87522: LD_ADDR_EXP 123
87526: PUSH
87527: LD_INT 1
87529: ST_TO_ADDR
// if p3 = 15 then
87530: LD_VAR 0 3
87534: PUSH
87535: LD_INT 15
87537: EQUAL
87538: IFFALSE 87548
// sKamikadze := true ;
87540: LD_ADDR_EXP 131
87544: PUSH
87545: LD_INT 1
87547: ST_TO_ADDR
// if p3 = 16 then
87548: LD_VAR 0 3
87552: PUSH
87553: LD_INT 16
87555: EQUAL
87556: IFFALSE 87566
// sTroll := true ;
87558: LD_ADDR_EXP 132
87562: PUSH
87563: LD_INT 1
87565: ST_TO_ADDR
// if p3 = 17 then
87566: LD_VAR 0 3
87570: PUSH
87571: LD_INT 17
87573: EQUAL
87574: IFFALSE 87584
// sSlow := true ;
87576: LD_ADDR_EXP 133
87580: PUSH
87581: LD_INT 1
87583: ST_TO_ADDR
// if p3 = 18 then
87584: LD_VAR 0 3
87588: PUSH
87589: LD_INT 18
87591: EQUAL
87592: IFFALSE 87602
// sLack := true ;
87594: LD_ADDR_EXP 134
87598: PUSH
87599: LD_INT 1
87601: ST_TO_ADDR
// if p3 = 19 then
87602: LD_VAR 0 3
87606: PUSH
87607: LD_INT 19
87609: EQUAL
87610: IFFALSE 87620
// sTank := true ;
87612: LD_ADDR_EXP 136
87616: PUSH
87617: LD_INT 1
87619: ST_TO_ADDR
// if p3 = 20 then
87620: LD_VAR 0 3
87624: PUSH
87625: LD_INT 20
87627: EQUAL
87628: IFFALSE 87638
// sRemote := true ;
87630: LD_ADDR_EXP 137
87634: PUSH
87635: LD_INT 1
87637: ST_TO_ADDR
// if p3 = 21 then
87638: LD_VAR 0 3
87642: PUSH
87643: LD_INT 21
87645: EQUAL
87646: IFFALSE 87656
// sPowell := true ;
87648: LD_ADDR_EXP 138
87652: PUSH
87653: LD_INT 1
87655: ST_TO_ADDR
// if p3 = 22 then
87656: LD_VAR 0 3
87660: PUSH
87661: LD_INT 22
87663: EQUAL
87664: IFFALSE 87674
// sTeleport := true ;
87666: LD_ADDR_EXP 141
87670: PUSH
87671: LD_INT 1
87673: ST_TO_ADDR
// if p3 = 23 then
87674: LD_VAR 0 3
87678: PUSH
87679: LD_INT 23
87681: EQUAL
87682: IFFALSE 87692
// sOilTower := true ;
87684: LD_ADDR_EXP 143
87688: PUSH
87689: LD_INT 1
87691: ST_TO_ADDR
// if p3 = 24 then
87692: LD_VAR 0 3
87696: PUSH
87697: LD_INT 24
87699: EQUAL
87700: IFFALSE 87710
// sShovel := true ;
87702: LD_ADDR_EXP 144
87706: PUSH
87707: LD_INT 1
87709: ST_TO_ADDR
// if p3 = 25 then
87710: LD_VAR 0 3
87714: PUSH
87715: LD_INT 25
87717: EQUAL
87718: IFFALSE 87728
// sSheik := true ;
87720: LD_ADDR_EXP 145
87724: PUSH
87725: LD_INT 1
87727: ST_TO_ADDR
// if p3 = 26 then
87728: LD_VAR 0 3
87732: PUSH
87733: LD_INT 26
87735: EQUAL
87736: IFFALSE 87746
// sEarthquake := true ;
87738: LD_ADDR_EXP 147
87742: PUSH
87743: LD_INT 1
87745: ST_TO_ADDR
// if p3 = 27 then
87746: LD_VAR 0 3
87750: PUSH
87751: LD_INT 27
87753: EQUAL
87754: IFFALSE 87764
// sAI := true ;
87756: LD_ADDR_EXP 148
87760: PUSH
87761: LD_INT 1
87763: ST_TO_ADDR
// if p3 = 28 then
87764: LD_VAR 0 3
87768: PUSH
87769: LD_INT 28
87771: EQUAL
87772: IFFALSE 87782
// sCargo := true ;
87774: LD_ADDR_EXP 151
87778: PUSH
87779: LD_INT 1
87781: ST_TO_ADDR
// if p3 = 29 then
87782: LD_VAR 0 3
87786: PUSH
87787: LD_INT 29
87789: EQUAL
87790: IFFALSE 87800
// sDLaser := true ;
87792: LD_ADDR_EXP 152
87796: PUSH
87797: LD_INT 1
87799: ST_TO_ADDR
// if p3 = 30 then
87800: LD_VAR 0 3
87804: PUSH
87805: LD_INT 30
87807: EQUAL
87808: IFFALSE 87818
// sExchange := true ;
87810: LD_ADDR_EXP 153
87814: PUSH
87815: LD_INT 1
87817: ST_TO_ADDR
// if p3 = 31 then
87818: LD_VAR 0 3
87822: PUSH
87823: LD_INT 31
87825: EQUAL
87826: IFFALSE 87836
// sFac := true ;
87828: LD_ADDR_EXP 154
87832: PUSH
87833: LD_INT 1
87835: ST_TO_ADDR
// if p3 = 32 then
87836: LD_VAR 0 3
87840: PUSH
87841: LD_INT 32
87843: EQUAL
87844: IFFALSE 87854
// sPower := true ;
87846: LD_ADDR_EXP 155
87850: PUSH
87851: LD_INT 1
87853: ST_TO_ADDR
// if p3 = 33 then
87854: LD_VAR 0 3
87858: PUSH
87859: LD_INT 33
87861: EQUAL
87862: IFFALSE 87872
// sRandom := true ;
87864: LD_ADDR_EXP 156
87868: PUSH
87869: LD_INT 1
87871: ST_TO_ADDR
// if p3 = 34 then
87872: LD_VAR 0 3
87876: PUSH
87877: LD_INT 34
87879: EQUAL
87880: IFFALSE 87890
// sShield := true ;
87882: LD_ADDR_EXP 157
87886: PUSH
87887: LD_INT 1
87889: ST_TO_ADDR
// if p3 = 35 then
87890: LD_VAR 0 3
87894: PUSH
87895: LD_INT 35
87897: EQUAL
87898: IFFALSE 87908
// sTime := true ;
87900: LD_ADDR_EXP 158
87904: PUSH
87905: LD_INT 1
87907: ST_TO_ADDR
// if p3 = 36 then
87908: LD_VAR 0 3
87912: PUSH
87913: LD_INT 36
87915: EQUAL
87916: IFFALSE 87926
// sTools := true ;
87918: LD_ADDR_EXP 159
87922: PUSH
87923: LD_INT 1
87925: ST_TO_ADDR
// if p3 = 101 then
87926: LD_VAR 0 3
87930: PUSH
87931: LD_INT 101
87933: EQUAL
87934: IFFALSE 87944
// sSold := true ;
87936: LD_ADDR_EXP 124
87940: PUSH
87941: LD_INT 1
87943: ST_TO_ADDR
// if p3 = 102 then
87944: LD_VAR 0 3
87948: PUSH
87949: LD_INT 102
87951: EQUAL
87952: IFFALSE 87962
// sDiff := true ;
87954: LD_ADDR_EXP 125
87958: PUSH
87959: LD_INT 1
87961: ST_TO_ADDR
// if p3 = 103 then
87962: LD_VAR 0 3
87966: PUSH
87967: LD_INT 103
87969: EQUAL
87970: IFFALSE 87980
// sFog := true ;
87972: LD_ADDR_EXP 128
87976: PUSH
87977: LD_INT 1
87979: ST_TO_ADDR
// if p3 = 104 then
87980: LD_VAR 0 3
87984: PUSH
87985: LD_INT 104
87987: EQUAL
87988: IFFALSE 87998
// sReset := true ;
87990: LD_ADDR_EXP 129
87994: PUSH
87995: LD_INT 1
87997: ST_TO_ADDR
// if p3 = 105 then
87998: LD_VAR 0 3
88002: PUSH
88003: LD_INT 105
88005: EQUAL
88006: IFFALSE 88016
// sSun := true ;
88008: LD_ADDR_EXP 130
88012: PUSH
88013: LD_INT 1
88015: ST_TO_ADDR
// if p3 = 106 then
88016: LD_VAR 0 3
88020: PUSH
88021: LD_INT 106
88023: EQUAL
88024: IFFALSE 88034
// sTiger := true ;
88026: LD_ADDR_EXP 126
88030: PUSH
88031: LD_INT 1
88033: ST_TO_ADDR
// if p3 = 107 then
88034: LD_VAR 0 3
88038: PUSH
88039: LD_INT 107
88041: EQUAL
88042: IFFALSE 88052
// sBomb := true ;
88044: LD_ADDR_EXP 127
88048: PUSH
88049: LD_INT 1
88051: ST_TO_ADDR
// if p3 = 108 then
88052: LD_VAR 0 3
88056: PUSH
88057: LD_INT 108
88059: EQUAL
88060: IFFALSE 88070
// sWound := true ;
88062: LD_ADDR_EXP 135
88066: PUSH
88067: LD_INT 1
88069: ST_TO_ADDR
// if p3 = 109 then
88070: LD_VAR 0 3
88074: PUSH
88075: LD_INT 109
88077: EQUAL
88078: IFFALSE 88088
// sBetray := true ;
88080: LD_ADDR_EXP 139
88084: PUSH
88085: LD_INT 1
88087: ST_TO_ADDR
// if p3 = 110 then
88088: LD_VAR 0 3
88092: PUSH
88093: LD_INT 110
88095: EQUAL
88096: IFFALSE 88106
// sContamin := true ;
88098: LD_ADDR_EXP 140
88102: PUSH
88103: LD_INT 1
88105: ST_TO_ADDR
// if p3 = 111 then
88106: LD_VAR 0 3
88110: PUSH
88111: LD_INT 111
88113: EQUAL
88114: IFFALSE 88124
// sOil := true ;
88116: LD_ADDR_EXP 142
88120: PUSH
88121: LD_INT 1
88123: ST_TO_ADDR
// if p3 = 112 then
88124: LD_VAR 0 3
88128: PUSH
88129: LD_INT 112
88131: EQUAL
88132: IFFALSE 88142
// sStu := true ;
88134: LD_ADDR_EXP 146
88138: PUSH
88139: LD_INT 1
88141: ST_TO_ADDR
// if p3 = 113 then
88142: LD_VAR 0 3
88146: PUSH
88147: LD_INT 113
88149: EQUAL
88150: IFFALSE 88160
// sBazooka := true ;
88152: LD_ADDR_EXP 149
88156: PUSH
88157: LD_INT 1
88159: ST_TO_ADDR
// if p3 = 114 then
88160: LD_VAR 0 3
88164: PUSH
88165: LD_INT 114
88167: EQUAL
88168: IFFALSE 88178
// sMortar := true ;
88170: LD_ADDR_EXP 150
88174: PUSH
88175: LD_INT 1
88177: ST_TO_ADDR
// if p3 = 115 then
88178: LD_VAR 0 3
88182: PUSH
88183: LD_INT 115
88185: EQUAL
88186: IFFALSE 88196
// sRanger := true ;
88188: LD_ADDR_EXP 160
88192: PUSH
88193: LD_INT 1
88195: ST_TO_ADDR
// if p3 = 116 then
88196: LD_VAR 0 3
88200: PUSH
88201: LD_INT 116
88203: EQUAL
88204: IFFALSE 88214
// sComputer := true ;
88206: LD_ADDR_EXP 161
88210: PUSH
88211: LD_INT 1
88213: ST_TO_ADDR
// if p3 = 117 then
88214: LD_VAR 0 3
88218: PUSH
88219: LD_INT 117
88221: EQUAL
88222: IFFALSE 88232
// s30 := true ;
88224: LD_ADDR_EXP 162
88228: PUSH
88229: LD_INT 1
88231: ST_TO_ADDR
// if p3 = 118 then
88232: LD_VAR 0 3
88236: PUSH
88237: LD_INT 118
88239: EQUAL
88240: IFFALSE 88250
// s60 := true ;
88242: LD_ADDR_EXP 163
88246: PUSH
88247: LD_INT 1
88249: ST_TO_ADDR
// end ; if p2 = hack_mode then
88250: LD_VAR 0 2
88254: PUSH
88255: LD_INT 101
88257: EQUAL
88258: IFFALSE 88386
// begin case p3 of 1 :
88260: LD_VAR 0 3
88264: PUSH
88265: LD_INT 1
88267: DOUBLE
88268: EQUAL
88269: IFTRUE 88273
88271: GO 88280
88273: POP
// hHackUnlimitedResources ; 2 :
88274: CALL 100525 0 0
88278: GO 88386
88280: LD_INT 2
88282: DOUBLE
88283: EQUAL
88284: IFTRUE 88288
88286: GO 88295
88288: POP
// hHackSetLevel10 ; 3 :
88289: CALL 100658 0 0
88293: GO 88386
88295: LD_INT 3
88297: DOUBLE
88298: EQUAL
88299: IFTRUE 88303
88301: GO 88310
88303: POP
// hHackSetLevel10YourUnits ; 4 :
88304: CALL 100743 0 0
88308: GO 88386
88310: LD_INT 4
88312: DOUBLE
88313: EQUAL
88314: IFTRUE 88318
88316: GO 88325
88318: POP
// hHackInvincible ; 5 :
88319: CALL 101191 0 0
88323: GO 88386
88325: LD_INT 5
88327: DOUBLE
88328: EQUAL
88329: IFTRUE 88333
88331: GO 88340
88333: POP
// hHackInvisible ; 6 :
88334: CALL 101302 0 0
88338: GO 88386
88340: LD_INT 6
88342: DOUBLE
88343: EQUAL
88344: IFTRUE 88348
88346: GO 88355
88348: POP
// hHackChangeYourSide ; 7 :
88349: CALL 101359 0 0
88353: GO 88386
88355: LD_INT 7
88357: DOUBLE
88358: EQUAL
88359: IFTRUE 88363
88361: GO 88370
88363: POP
// hHackChangeUnitSide ; 8 :
88364: CALL 101401 0 0
88368: GO 88386
88370: LD_INT 8
88372: DOUBLE
88373: EQUAL
88374: IFTRUE 88378
88376: GO 88385
88378: POP
// hHackFog ; end ;
88379: CALL 101502 0 0
88383: GO 88386
88385: POP
// end ; if p2 = game_save_mode then
88386: LD_VAR 0 2
88390: PUSH
88391: LD_INT 102
88393: EQUAL
88394: IFFALSE 88449
// begin if p3 = 1 then
88396: LD_VAR 0 3
88400: PUSH
88401: LD_INT 1
88403: EQUAL
88404: IFFALSE 88416
// globalGameSaveCounter := p4 ;
88406: LD_ADDR_EXP 106
88410: PUSH
88411: LD_VAR 0 4
88415: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
88416: LD_VAR 0 3
88420: PUSH
88421: LD_INT 2
88423: EQUAL
88424: PUSH
88425: LD_EXP 106
88429: AND
88430: IFFALSE 88449
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
88432: LD_STRING setGameSaveCounter(
88434: PUSH
88435: LD_EXP 106
88439: STR
88440: PUSH
88441: LD_STRING )
88443: STR
88444: PPUSH
88445: CALL_OW 559
// end ; end ;
88449: LD_VAR 0 7
88453: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
88454: LD_INT 0
88456: PPUSH
// streamModeActive := false ;
88457: LD_ADDR_EXP 107
88461: PUSH
88462: LD_INT 0
88464: ST_TO_ADDR
// normalCounter := 36 ;
88465: LD_ADDR_EXP 108
88469: PUSH
88470: LD_INT 36
88472: ST_TO_ADDR
// hardcoreCounter := 18 ;
88473: LD_ADDR_EXP 109
88477: PUSH
88478: LD_INT 18
88480: ST_TO_ADDR
// sRocket := false ;
88481: LD_ADDR_EXP 112
88485: PUSH
88486: LD_INT 0
88488: ST_TO_ADDR
// sSpeed := false ;
88489: LD_ADDR_EXP 111
88493: PUSH
88494: LD_INT 0
88496: ST_TO_ADDR
// sEngine := false ;
88497: LD_ADDR_EXP 113
88501: PUSH
88502: LD_INT 0
88504: ST_TO_ADDR
// sSpec := false ;
88505: LD_ADDR_EXP 110
88509: PUSH
88510: LD_INT 0
88512: ST_TO_ADDR
// sLevel := false ;
88513: LD_ADDR_EXP 114
88517: PUSH
88518: LD_INT 0
88520: ST_TO_ADDR
// sArmoury := false ;
88521: LD_ADDR_EXP 115
88525: PUSH
88526: LD_INT 0
88528: ST_TO_ADDR
// sRadar := false ;
88529: LD_ADDR_EXP 116
88533: PUSH
88534: LD_INT 0
88536: ST_TO_ADDR
// sBunker := false ;
88537: LD_ADDR_EXP 117
88541: PUSH
88542: LD_INT 0
88544: ST_TO_ADDR
// sHack := false ;
88545: LD_ADDR_EXP 118
88549: PUSH
88550: LD_INT 0
88552: ST_TO_ADDR
// sFire := false ;
88553: LD_ADDR_EXP 119
88557: PUSH
88558: LD_INT 0
88560: ST_TO_ADDR
// sRefresh := false ;
88561: LD_ADDR_EXP 120
88565: PUSH
88566: LD_INT 0
88568: ST_TO_ADDR
// sExp := false ;
88569: LD_ADDR_EXP 121
88573: PUSH
88574: LD_INT 0
88576: ST_TO_ADDR
// sDepot := false ;
88577: LD_ADDR_EXP 122
88581: PUSH
88582: LD_INT 0
88584: ST_TO_ADDR
// sFlag := false ;
88585: LD_ADDR_EXP 123
88589: PUSH
88590: LD_INT 0
88592: ST_TO_ADDR
// sKamikadze := false ;
88593: LD_ADDR_EXP 131
88597: PUSH
88598: LD_INT 0
88600: ST_TO_ADDR
// sTroll := false ;
88601: LD_ADDR_EXP 132
88605: PUSH
88606: LD_INT 0
88608: ST_TO_ADDR
// sSlow := false ;
88609: LD_ADDR_EXP 133
88613: PUSH
88614: LD_INT 0
88616: ST_TO_ADDR
// sLack := false ;
88617: LD_ADDR_EXP 134
88621: PUSH
88622: LD_INT 0
88624: ST_TO_ADDR
// sTank := false ;
88625: LD_ADDR_EXP 136
88629: PUSH
88630: LD_INT 0
88632: ST_TO_ADDR
// sRemote := false ;
88633: LD_ADDR_EXP 137
88637: PUSH
88638: LD_INT 0
88640: ST_TO_ADDR
// sPowell := false ;
88641: LD_ADDR_EXP 138
88645: PUSH
88646: LD_INT 0
88648: ST_TO_ADDR
// sTeleport := false ;
88649: LD_ADDR_EXP 141
88653: PUSH
88654: LD_INT 0
88656: ST_TO_ADDR
// sOilTower := false ;
88657: LD_ADDR_EXP 143
88661: PUSH
88662: LD_INT 0
88664: ST_TO_ADDR
// sShovel := false ;
88665: LD_ADDR_EXP 144
88669: PUSH
88670: LD_INT 0
88672: ST_TO_ADDR
// sSheik := false ;
88673: LD_ADDR_EXP 145
88677: PUSH
88678: LD_INT 0
88680: ST_TO_ADDR
// sEarthquake := false ;
88681: LD_ADDR_EXP 147
88685: PUSH
88686: LD_INT 0
88688: ST_TO_ADDR
// sAI := false ;
88689: LD_ADDR_EXP 148
88693: PUSH
88694: LD_INT 0
88696: ST_TO_ADDR
// sCargo := false ;
88697: LD_ADDR_EXP 151
88701: PUSH
88702: LD_INT 0
88704: ST_TO_ADDR
// sDLaser := false ;
88705: LD_ADDR_EXP 152
88709: PUSH
88710: LD_INT 0
88712: ST_TO_ADDR
// sExchange := false ;
88713: LD_ADDR_EXP 153
88717: PUSH
88718: LD_INT 0
88720: ST_TO_ADDR
// sFac := false ;
88721: LD_ADDR_EXP 154
88725: PUSH
88726: LD_INT 0
88728: ST_TO_ADDR
// sPower := false ;
88729: LD_ADDR_EXP 155
88733: PUSH
88734: LD_INT 0
88736: ST_TO_ADDR
// sRandom := false ;
88737: LD_ADDR_EXP 156
88741: PUSH
88742: LD_INT 0
88744: ST_TO_ADDR
// sShield := false ;
88745: LD_ADDR_EXP 157
88749: PUSH
88750: LD_INT 0
88752: ST_TO_ADDR
// sTime := false ;
88753: LD_ADDR_EXP 158
88757: PUSH
88758: LD_INT 0
88760: ST_TO_ADDR
// sTools := false ;
88761: LD_ADDR_EXP 159
88765: PUSH
88766: LD_INT 0
88768: ST_TO_ADDR
// sSold := false ;
88769: LD_ADDR_EXP 124
88773: PUSH
88774: LD_INT 0
88776: ST_TO_ADDR
// sDiff := false ;
88777: LD_ADDR_EXP 125
88781: PUSH
88782: LD_INT 0
88784: ST_TO_ADDR
// sFog := false ;
88785: LD_ADDR_EXP 128
88789: PUSH
88790: LD_INT 0
88792: ST_TO_ADDR
// sReset := false ;
88793: LD_ADDR_EXP 129
88797: PUSH
88798: LD_INT 0
88800: ST_TO_ADDR
// sSun := false ;
88801: LD_ADDR_EXP 130
88805: PUSH
88806: LD_INT 0
88808: ST_TO_ADDR
// sTiger := false ;
88809: LD_ADDR_EXP 126
88813: PUSH
88814: LD_INT 0
88816: ST_TO_ADDR
// sBomb := false ;
88817: LD_ADDR_EXP 127
88821: PUSH
88822: LD_INT 0
88824: ST_TO_ADDR
// sWound := false ;
88825: LD_ADDR_EXP 135
88829: PUSH
88830: LD_INT 0
88832: ST_TO_ADDR
// sBetray := false ;
88833: LD_ADDR_EXP 139
88837: PUSH
88838: LD_INT 0
88840: ST_TO_ADDR
// sContamin := false ;
88841: LD_ADDR_EXP 140
88845: PUSH
88846: LD_INT 0
88848: ST_TO_ADDR
// sOil := false ;
88849: LD_ADDR_EXP 142
88853: PUSH
88854: LD_INT 0
88856: ST_TO_ADDR
// sStu := false ;
88857: LD_ADDR_EXP 146
88861: PUSH
88862: LD_INT 0
88864: ST_TO_ADDR
// sBazooka := false ;
88865: LD_ADDR_EXP 149
88869: PUSH
88870: LD_INT 0
88872: ST_TO_ADDR
// sMortar := false ;
88873: LD_ADDR_EXP 150
88877: PUSH
88878: LD_INT 0
88880: ST_TO_ADDR
// sRanger := false ;
88881: LD_ADDR_EXP 160
88885: PUSH
88886: LD_INT 0
88888: ST_TO_ADDR
// sComputer := false ;
88889: LD_ADDR_EXP 161
88893: PUSH
88894: LD_INT 0
88896: ST_TO_ADDR
// s30 := false ;
88897: LD_ADDR_EXP 162
88901: PUSH
88902: LD_INT 0
88904: ST_TO_ADDR
// s60 := false ;
88905: LD_ADDR_EXP 163
88909: PUSH
88910: LD_INT 0
88912: ST_TO_ADDR
// end ;
88913: LD_VAR 0 1
88917: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
88918: LD_INT 0
88920: PPUSH
88921: PPUSH
88922: PPUSH
88923: PPUSH
88924: PPUSH
88925: PPUSH
88926: PPUSH
// result := [ ] ;
88927: LD_ADDR_VAR 0 2
88931: PUSH
88932: EMPTY
88933: ST_TO_ADDR
// if campaign_id = 1 then
88934: LD_OWVAR 69
88938: PUSH
88939: LD_INT 1
88941: EQUAL
88942: IFFALSE 92108
// begin case mission_number of 1 :
88944: LD_OWVAR 70
88948: PUSH
88949: LD_INT 1
88951: DOUBLE
88952: EQUAL
88953: IFTRUE 88957
88955: GO 89033
88957: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
88958: LD_ADDR_VAR 0 2
88962: PUSH
88963: LD_INT 2
88965: PUSH
88966: LD_INT 4
88968: PUSH
88969: LD_INT 11
88971: PUSH
88972: LD_INT 12
88974: PUSH
88975: LD_INT 15
88977: PUSH
88978: LD_INT 16
88980: PUSH
88981: LD_INT 22
88983: PUSH
88984: LD_INT 23
88986: PUSH
88987: LD_INT 26
88989: PUSH
88990: EMPTY
88991: LIST
88992: LIST
88993: LIST
88994: LIST
88995: LIST
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: PUSH
89001: LD_INT 101
89003: PUSH
89004: LD_INT 102
89006: PUSH
89007: LD_INT 106
89009: PUSH
89010: LD_INT 116
89012: PUSH
89013: LD_INT 117
89015: PUSH
89016: LD_INT 118
89018: PUSH
89019: EMPTY
89020: LIST
89021: LIST
89022: LIST
89023: LIST
89024: LIST
89025: LIST
89026: PUSH
89027: EMPTY
89028: LIST
89029: LIST
89030: ST_TO_ADDR
89031: GO 92106
89033: LD_INT 2
89035: DOUBLE
89036: EQUAL
89037: IFTRUE 89041
89039: GO 89125
89041: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
89042: LD_ADDR_VAR 0 2
89046: PUSH
89047: LD_INT 2
89049: PUSH
89050: LD_INT 4
89052: PUSH
89053: LD_INT 11
89055: PUSH
89056: LD_INT 12
89058: PUSH
89059: LD_INT 15
89061: PUSH
89062: LD_INT 16
89064: PUSH
89065: LD_INT 22
89067: PUSH
89068: LD_INT 23
89070: PUSH
89071: LD_INT 26
89073: PUSH
89074: EMPTY
89075: LIST
89076: LIST
89077: LIST
89078: LIST
89079: LIST
89080: LIST
89081: LIST
89082: LIST
89083: LIST
89084: PUSH
89085: LD_INT 101
89087: PUSH
89088: LD_INT 102
89090: PUSH
89091: LD_INT 105
89093: PUSH
89094: LD_INT 106
89096: PUSH
89097: LD_INT 108
89099: PUSH
89100: LD_INT 116
89102: PUSH
89103: LD_INT 117
89105: PUSH
89106: LD_INT 118
89108: PUSH
89109: EMPTY
89110: LIST
89111: LIST
89112: LIST
89113: LIST
89114: LIST
89115: LIST
89116: LIST
89117: LIST
89118: PUSH
89119: EMPTY
89120: LIST
89121: LIST
89122: ST_TO_ADDR
89123: GO 92106
89125: LD_INT 3
89127: DOUBLE
89128: EQUAL
89129: IFTRUE 89133
89131: GO 89221
89133: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
89134: LD_ADDR_VAR 0 2
89138: PUSH
89139: LD_INT 2
89141: PUSH
89142: LD_INT 4
89144: PUSH
89145: LD_INT 5
89147: PUSH
89148: LD_INT 11
89150: PUSH
89151: LD_INT 12
89153: PUSH
89154: LD_INT 15
89156: PUSH
89157: LD_INT 16
89159: PUSH
89160: LD_INT 22
89162: PUSH
89163: LD_INT 26
89165: PUSH
89166: LD_INT 36
89168: PUSH
89169: EMPTY
89170: LIST
89171: LIST
89172: LIST
89173: LIST
89174: LIST
89175: LIST
89176: LIST
89177: LIST
89178: LIST
89179: LIST
89180: PUSH
89181: LD_INT 101
89183: PUSH
89184: LD_INT 102
89186: PUSH
89187: LD_INT 105
89189: PUSH
89190: LD_INT 106
89192: PUSH
89193: LD_INT 108
89195: PUSH
89196: LD_INT 116
89198: PUSH
89199: LD_INT 117
89201: PUSH
89202: LD_INT 118
89204: PUSH
89205: EMPTY
89206: LIST
89207: LIST
89208: LIST
89209: LIST
89210: LIST
89211: LIST
89212: LIST
89213: LIST
89214: PUSH
89215: EMPTY
89216: LIST
89217: LIST
89218: ST_TO_ADDR
89219: GO 92106
89221: LD_INT 4
89223: DOUBLE
89224: EQUAL
89225: IFTRUE 89229
89227: GO 89325
89229: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
89230: LD_ADDR_VAR 0 2
89234: PUSH
89235: LD_INT 2
89237: PUSH
89238: LD_INT 4
89240: PUSH
89241: LD_INT 5
89243: PUSH
89244: LD_INT 8
89246: PUSH
89247: LD_INT 11
89249: PUSH
89250: LD_INT 12
89252: PUSH
89253: LD_INT 15
89255: PUSH
89256: LD_INT 16
89258: PUSH
89259: LD_INT 22
89261: PUSH
89262: LD_INT 23
89264: PUSH
89265: LD_INT 26
89267: PUSH
89268: LD_INT 36
89270: PUSH
89271: EMPTY
89272: LIST
89273: LIST
89274: LIST
89275: LIST
89276: LIST
89277: LIST
89278: LIST
89279: LIST
89280: LIST
89281: LIST
89282: LIST
89283: LIST
89284: PUSH
89285: LD_INT 101
89287: PUSH
89288: LD_INT 102
89290: PUSH
89291: LD_INT 105
89293: PUSH
89294: LD_INT 106
89296: PUSH
89297: LD_INT 108
89299: PUSH
89300: LD_INT 116
89302: PUSH
89303: LD_INT 117
89305: PUSH
89306: LD_INT 118
89308: PUSH
89309: EMPTY
89310: LIST
89311: LIST
89312: LIST
89313: LIST
89314: LIST
89315: LIST
89316: LIST
89317: LIST
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: ST_TO_ADDR
89323: GO 92106
89325: LD_INT 5
89327: DOUBLE
89328: EQUAL
89329: IFTRUE 89333
89331: GO 89445
89333: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
89334: LD_ADDR_VAR 0 2
89338: PUSH
89339: LD_INT 2
89341: PUSH
89342: LD_INT 4
89344: PUSH
89345: LD_INT 5
89347: PUSH
89348: LD_INT 6
89350: PUSH
89351: LD_INT 8
89353: PUSH
89354: LD_INT 11
89356: PUSH
89357: LD_INT 12
89359: PUSH
89360: LD_INT 15
89362: PUSH
89363: LD_INT 16
89365: PUSH
89366: LD_INT 22
89368: PUSH
89369: LD_INT 23
89371: PUSH
89372: LD_INT 25
89374: PUSH
89375: LD_INT 26
89377: PUSH
89378: LD_INT 36
89380: PUSH
89381: EMPTY
89382: LIST
89383: LIST
89384: LIST
89385: LIST
89386: LIST
89387: LIST
89388: LIST
89389: LIST
89390: LIST
89391: LIST
89392: LIST
89393: LIST
89394: LIST
89395: LIST
89396: PUSH
89397: LD_INT 101
89399: PUSH
89400: LD_INT 102
89402: PUSH
89403: LD_INT 105
89405: PUSH
89406: LD_INT 106
89408: PUSH
89409: LD_INT 108
89411: PUSH
89412: LD_INT 109
89414: PUSH
89415: LD_INT 112
89417: PUSH
89418: LD_INT 116
89420: PUSH
89421: LD_INT 117
89423: PUSH
89424: LD_INT 118
89426: PUSH
89427: EMPTY
89428: LIST
89429: LIST
89430: LIST
89431: LIST
89432: LIST
89433: LIST
89434: LIST
89435: LIST
89436: LIST
89437: LIST
89438: PUSH
89439: EMPTY
89440: LIST
89441: LIST
89442: ST_TO_ADDR
89443: GO 92106
89445: LD_INT 6
89447: DOUBLE
89448: EQUAL
89449: IFTRUE 89453
89451: GO 89585
89453: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
89454: LD_ADDR_VAR 0 2
89458: PUSH
89459: LD_INT 2
89461: PUSH
89462: LD_INT 4
89464: PUSH
89465: LD_INT 5
89467: PUSH
89468: LD_INT 6
89470: PUSH
89471: LD_INT 8
89473: PUSH
89474: LD_INT 11
89476: PUSH
89477: LD_INT 12
89479: PUSH
89480: LD_INT 15
89482: PUSH
89483: LD_INT 16
89485: PUSH
89486: LD_INT 20
89488: PUSH
89489: LD_INT 21
89491: PUSH
89492: LD_INT 22
89494: PUSH
89495: LD_INT 23
89497: PUSH
89498: LD_INT 25
89500: PUSH
89501: LD_INT 26
89503: PUSH
89504: LD_INT 30
89506: PUSH
89507: LD_INT 31
89509: PUSH
89510: LD_INT 32
89512: PUSH
89513: LD_INT 36
89515: PUSH
89516: EMPTY
89517: LIST
89518: LIST
89519: LIST
89520: LIST
89521: LIST
89522: LIST
89523: LIST
89524: LIST
89525: LIST
89526: LIST
89527: LIST
89528: LIST
89529: LIST
89530: LIST
89531: LIST
89532: LIST
89533: LIST
89534: LIST
89535: LIST
89536: PUSH
89537: LD_INT 101
89539: PUSH
89540: LD_INT 102
89542: PUSH
89543: LD_INT 105
89545: PUSH
89546: LD_INT 106
89548: PUSH
89549: LD_INT 108
89551: PUSH
89552: LD_INT 109
89554: PUSH
89555: LD_INT 112
89557: PUSH
89558: LD_INT 116
89560: PUSH
89561: LD_INT 117
89563: PUSH
89564: LD_INT 118
89566: PUSH
89567: EMPTY
89568: LIST
89569: LIST
89570: LIST
89571: LIST
89572: LIST
89573: LIST
89574: LIST
89575: LIST
89576: LIST
89577: LIST
89578: PUSH
89579: EMPTY
89580: LIST
89581: LIST
89582: ST_TO_ADDR
89583: GO 92106
89585: LD_INT 7
89587: DOUBLE
89588: EQUAL
89589: IFTRUE 89593
89591: GO 89705
89593: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
89594: LD_ADDR_VAR 0 2
89598: PUSH
89599: LD_INT 2
89601: PUSH
89602: LD_INT 4
89604: PUSH
89605: LD_INT 5
89607: PUSH
89608: LD_INT 7
89610: PUSH
89611: LD_INT 11
89613: PUSH
89614: LD_INT 12
89616: PUSH
89617: LD_INT 15
89619: PUSH
89620: LD_INT 16
89622: PUSH
89623: LD_INT 20
89625: PUSH
89626: LD_INT 21
89628: PUSH
89629: LD_INT 22
89631: PUSH
89632: LD_INT 23
89634: PUSH
89635: LD_INT 25
89637: PUSH
89638: LD_INT 26
89640: PUSH
89641: EMPTY
89642: LIST
89643: LIST
89644: LIST
89645: LIST
89646: LIST
89647: LIST
89648: LIST
89649: LIST
89650: LIST
89651: LIST
89652: LIST
89653: LIST
89654: LIST
89655: LIST
89656: PUSH
89657: LD_INT 101
89659: PUSH
89660: LD_INT 102
89662: PUSH
89663: LD_INT 103
89665: PUSH
89666: LD_INT 105
89668: PUSH
89669: LD_INT 106
89671: PUSH
89672: LD_INT 108
89674: PUSH
89675: LD_INT 112
89677: PUSH
89678: LD_INT 116
89680: PUSH
89681: LD_INT 117
89683: PUSH
89684: LD_INT 118
89686: PUSH
89687: EMPTY
89688: LIST
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: LIST
89698: PUSH
89699: EMPTY
89700: LIST
89701: LIST
89702: ST_TO_ADDR
89703: GO 92106
89705: LD_INT 8
89707: DOUBLE
89708: EQUAL
89709: IFTRUE 89713
89711: GO 89853
89713: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
89714: LD_ADDR_VAR 0 2
89718: PUSH
89719: LD_INT 2
89721: PUSH
89722: LD_INT 4
89724: PUSH
89725: LD_INT 5
89727: PUSH
89728: LD_INT 6
89730: PUSH
89731: LD_INT 7
89733: PUSH
89734: LD_INT 8
89736: PUSH
89737: LD_INT 11
89739: PUSH
89740: LD_INT 12
89742: PUSH
89743: LD_INT 15
89745: PUSH
89746: LD_INT 16
89748: PUSH
89749: LD_INT 20
89751: PUSH
89752: LD_INT 21
89754: PUSH
89755: LD_INT 22
89757: PUSH
89758: LD_INT 23
89760: PUSH
89761: LD_INT 25
89763: PUSH
89764: LD_INT 26
89766: PUSH
89767: LD_INT 30
89769: PUSH
89770: LD_INT 31
89772: PUSH
89773: LD_INT 32
89775: PUSH
89776: LD_INT 36
89778: PUSH
89779: EMPTY
89780: LIST
89781: LIST
89782: LIST
89783: LIST
89784: LIST
89785: LIST
89786: LIST
89787: LIST
89788: LIST
89789: LIST
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: LIST
89795: LIST
89796: LIST
89797: LIST
89798: LIST
89799: LIST
89800: PUSH
89801: LD_INT 101
89803: PUSH
89804: LD_INT 102
89806: PUSH
89807: LD_INT 103
89809: PUSH
89810: LD_INT 105
89812: PUSH
89813: LD_INT 106
89815: PUSH
89816: LD_INT 108
89818: PUSH
89819: LD_INT 109
89821: PUSH
89822: LD_INT 112
89824: PUSH
89825: LD_INT 116
89827: PUSH
89828: LD_INT 117
89830: PUSH
89831: LD_INT 118
89833: PUSH
89834: EMPTY
89835: LIST
89836: LIST
89837: LIST
89838: LIST
89839: LIST
89840: LIST
89841: LIST
89842: LIST
89843: LIST
89844: LIST
89845: LIST
89846: PUSH
89847: EMPTY
89848: LIST
89849: LIST
89850: ST_TO_ADDR
89851: GO 92106
89853: LD_INT 9
89855: DOUBLE
89856: EQUAL
89857: IFTRUE 89861
89859: GO 90009
89861: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
89862: LD_ADDR_VAR 0 2
89866: PUSH
89867: LD_INT 2
89869: PUSH
89870: LD_INT 4
89872: PUSH
89873: LD_INT 5
89875: PUSH
89876: LD_INT 6
89878: PUSH
89879: LD_INT 7
89881: PUSH
89882: LD_INT 8
89884: PUSH
89885: LD_INT 11
89887: PUSH
89888: LD_INT 12
89890: PUSH
89891: LD_INT 15
89893: PUSH
89894: LD_INT 16
89896: PUSH
89897: LD_INT 20
89899: PUSH
89900: LD_INT 21
89902: PUSH
89903: LD_INT 22
89905: PUSH
89906: LD_INT 23
89908: PUSH
89909: LD_INT 25
89911: PUSH
89912: LD_INT 26
89914: PUSH
89915: LD_INT 28
89917: PUSH
89918: LD_INT 30
89920: PUSH
89921: LD_INT 31
89923: PUSH
89924: LD_INT 32
89926: PUSH
89927: LD_INT 36
89929: PUSH
89930: EMPTY
89931: LIST
89932: LIST
89933: LIST
89934: LIST
89935: LIST
89936: LIST
89937: LIST
89938: LIST
89939: LIST
89940: LIST
89941: LIST
89942: LIST
89943: LIST
89944: LIST
89945: LIST
89946: LIST
89947: LIST
89948: LIST
89949: LIST
89950: LIST
89951: LIST
89952: PUSH
89953: LD_INT 101
89955: PUSH
89956: LD_INT 102
89958: PUSH
89959: LD_INT 103
89961: PUSH
89962: LD_INT 105
89964: PUSH
89965: LD_INT 106
89967: PUSH
89968: LD_INT 108
89970: PUSH
89971: LD_INT 109
89973: PUSH
89974: LD_INT 112
89976: PUSH
89977: LD_INT 114
89979: PUSH
89980: LD_INT 116
89982: PUSH
89983: LD_INT 117
89985: PUSH
89986: LD_INT 118
89988: PUSH
89989: EMPTY
89990: LIST
89991: LIST
89992: LIST
89993: LIST
89994: LIST
89995: LIST
89996: LIST
89997: LIST
89998: LIST
89999: LIST
90000: LIST
90001: LIST
90002: PUSH
90003: EMPTY
90004: LIST
90005: LIST
90006: ST_TO_ADDR
90007: GO 92106
90009: LD_INT 10
90011: DOUBLE
90012: EQUAL
90013: IFTRUE 90017
90015: GO 90213
90017: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
90018: LD_ADDR_VAR 0 2
90022: PUSH
90023: LD_INT 2
90025: PUSH
90026: LD_INT 4
90028: PUSH
90029: LD_INT 5
90031: PUSH
90032: LD_INT 6
90034: PUSH
90035: LD_INT 7
90037: PUSH
90038: LD_INT 8
90040: PUSH
90041: LD_INT 9
90043: PUSH
90044: LD_INT 10
90046: PUSH
90047: LD_INT 11
90049: PUSH
90050: LD_INT 12
90052: PUSH
90053: LD_INT 13
90055: PUSH
90056: LD_INT 14
90058: PUSH
90059: LD_INT 15
90061: PUSH
90062: LD_INT 16
90064: PUSH
90065: LD_INT 17
90067: PUSH
90068: LD_INT 18
90070: PUSH
90071: LD_INT 19
90073: PUSH
90074: LD_INT 20
90076: PUSH
90077: LD_INT 21
90079: PUSH
90080: LD_INT 22
90082: PUSH
90083: LD_INT 23
90085: PUSH
90086: LD_INT 24
90088: PUSH
90089: LD_INT 25
90091: PUSH
90092: LD_INT 26
90094: PUSH
90095: LD_INT 28
90097: PUSH
90098: LD_INT 30
90100: PUSH
90101: LD_INT 31
90103: PUSH
90104: LD_INT 32
90106: PUSH
90107: LD_INT 36
90109: PUSH
90110: EMPTY
90111: LIST
90112: LIST
90113: LIST
90114: LIST
90115: LIST
90116: LIST
90117: LIST
90118: LIST
90119: LIST
90120: LIST
90121: LIST
90122: LIST
90123: LIST
90124: LIST
90125: LIST
90126: LIST
90127: LIST
90128: LIST
90129: LIST
90130: LIST
90131: LIST
90132: LIST
90133: LIST
90134: LIST
90135: LIST
90136: LIST
90137: LIST
90138: LIST
90139: LIST
90140: PUSH
90141: LD_INT 101
90143: PUSH
90144: LD_INT 102
90146: PUSH
90147: LD_INT 103
90149: PUSH
90150: LD_INT 104
90152: PUSH
90153: LD_INT 105
90155: PUSH
90156: LD_INT 106
90158: PUSH
90159: LD_INT 107
90161: PUSH
90162: LD_INT 108
90164: PUSH
90165: LD_INT 109
90167: PUSH
90168: LD_INT 110
90170: PUSH
90171: LD_INT 111
90173: PUSH
90174: LD_INT 112
90176: PUSH
90177: LD_INT 114
90179: PUSH
90180: LD_INT 116
90182: PUSH
90183: LD_INT 117
90185: PUSH
90186: LD_INT 118
90188: PUSH
90189: EMPTY
90190: LIST
90191: LIST
90192: LIST
90193: LIST
90194: LIST
90195: LIST
90196: LIST
90197: LIST
90198: LIST
90199: LIST
90200: LIST
90201: LIST
90202: LIST
90203: LIST
90204: LIST
90205: LIST
90206: PUSH
90207: EMPTY
90208: LIST
90209: LIST
90210: ST_TO_ADDR
90211: GO 92106
90213: LD_INT 11
90215: DOUBLE
90216: EQUAL
90217: IFTRUE 90221
90219: GO 90425
90221: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
90222: LD_ADDR_VAR 0 2
90226: PUSH
90227: LD_INT 2
90229: PUSH
90230: LD_INT 3
90232: PUSH
90233: LD_INT 4
90235: PUSH
90236: LD_INT 5
90238: PUSH
90239: LD_INT 6
90241: PUSH
90242: LD_INT 7
90244: PUSH
90245: LD_INT 8
90247: PUSH
90248: LD_INT 9
90250: PUSH
90251: LD_INT 10
90253: PUSH
90254: LD_INT 11
90256: PUSH
90257: LD_INT 12
90259: PUSH
90260: LD_INT 13
90262: PUSH
90263: LD_INT 14
90265: PUSH
90266: LD_INT 15
90268: PUSH
90269: LD_INT 16
90271: PUSH
90272: LD_INT 17
90274: PUSH
90275: LD_INT 18
90277: PUSH
90278: LD_INT 19
90280: PUSH
90281: LD_INT 20
90283: PUSH
90284: LD_INT 21
90286: PUSH
90287: LD_INT 22
90289: PUSH
90290: LD_INT 23
90292: PUSH
90293: LD_INT 24
90295: PUSH
90296: LD_INT 25
90298: PUSH
90299: LD_INT 26
90301: PUSH
90302: LD_INT 28
90304: PUSH
90305: LD_INT 30
90307: PUSH
90308: LD_INT 31
90310: PUSH
90311: LD_INT 32
90313: PUSH
90314: LD_INT 34
90316: PUSH
90317: LD_INT 36
90319: PUSH
90320: EMPTY
90321: LIST
90322: LIST
90323: LIST
90324: LIST
90325: LIST
90326: LIST
90327: LIST
90328: LIST
90329: LIST
90330: LIST
90331: LIST
90332: LIST
90333: LIST
90334: LIST
90335: LIST
90336: LIST
90337: LIST
90338: LIST
90339: LIST
90340: LIST
90341: LIST
90342: LIST
90343: LIST
90344: LIST
90345: LIST
90346: LIST
90347: LIST
90348: LIST
90349: LIST
90350: LIST
90351: LIST
90352: PUSH
90353: LD_INT 101
90355: PUSH
90356: LD_INT 102
90358: PUSH
90359: LD_INT 103
90361: PUSH
90362: LD_INT 104
90364: PUSH
90365: LD_INT 105
90367: PUSH
90368: LD_INT 106
90370: PUSH
90371: LD_INT 107
90373: PUSH
90374: LD_INT 108
90376: PUSH
90377: LD_INT 109
90379: PUSH
90380: LD_INT 110
90382: PUSH
90383: LD_INT 111
90385: PUSH
90386: LD_INT 112
90388: PUSH
90389: LD_INT 114
90391: PUSH
90392: LD_INT 116
90394: PUSH
90395: LD_INT 117
90397: PUSH
90398: LD_INT 118
90400: PUSH
90401: EMPTY
90402: LIST
90403: LIST
90404: LIST
90405: LIST
90406: LIST
90407: LIST
90408: LIST
90409: LIST
90410: LIST
90411: LIST
90412: LIST
90413: LIST
90414: LIST
90415: LIST
90416: LIST
90417: LIST
90418: PUSH
90419: EMPTY
90420: LIST
90421: LIST
90422: ST_TO_ADDR
90423: GO 92106
90425: LD_INT 12
90427: DOUBLE
90428: EQUAL
90429: IFTRUE 90433
90431: GO 90653
90433: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
90434: LD_ADDR_VAR 0 2
90438: PUSH
90439: LD_INT 1
90441: PUSH
90442: LD_INT 2
90444: PUSH
90445: LD_INT 3
90447: PUSH
90448: LD_INT 4
90450: PUSH
90451: LD_INT 5
90453: PUSH
90454: LD_INT 6
90456: PUSH
90457: LD_INT 7
90459: PUSH
90460: LD_INT 8
90462: PUSH
90463: LD_INT 9
90465: PUSH
90466: LD_INT 10
90468: PUSH
90469: LD_INT 11
90471: PUSH
90472: LD_INT 12
90474: PUSH
90475: LD_INT 13
90477: PUSH
90478: LD_INT 14
90480: PUSH
90481: LD_INT 15
90483: PUSH
90484: LD_INT 16
90486: PUSH
90487: LD_INT 17
90489: PUSH
90490: LD_INT 18
90492: PUSH
90493: LD_INT 19
90495: PUSH
90496: LD_INT 20
90498: PUSH
90499: LD_INT 21
90501: PUSH
90502: LD_INT 22
90504: PUSH
90505: LD_INT 23
90507: PUSH
90508: LD_INT 24
90510: PUSH
90511: LD_INT 25
90513: PUSH
90514: LD_INT 26
90516: PUSH
90517: LD_INT 27
90519: PUSH
90520: LD_INT 28
90522: PUSH
90523: LD_INT 30
90525: PUSH
90526: LD_INT 31
90528: PUSH
90529: LD_INT 32
90531: PUSH
90532: LD_INT 33
90534: PUSH
90535: LD_INT 34
90537: PUSH
90538: LD_INT 36
90540: PUSH
90541: EMPTY
90542: LIST
90543: LIST
90544: LIST
90545: LIST
90546: LIST
90547: LIST
90548: LIST
90549: LIST
90550: LIST
90551: LIST
90552: LIST
90553: LIST
90554: LIST
90555: LIST
90556: LIST
90557: LIST
90558: LIST
90559: LIST
90560: LIST
90561: LIST
90562: LIST
90563: LIST
90564: LIST
90565: LIST
90566: LIST
90567: LIST
90568: LIST
90569: LIST
90570: LIST
90571: LIST
90572: LIST
90573: LIST
90574: LIST
90575: LIST
90576: PUSH
90577: LD_INT 101
90579: PUSH
90580: LD_INT 102
90582: PUSH
90583: LD_INT 103
90585: PUSH
90586: LD_INT 104
90588: PUSH
90589: LD_INT 105
90591: PUSH
90592: LD_INT 106
90594: PUSH
90595: LD_INT 107
90597: PUSH
90598: LD_INT 108
90600: PUSH
90601: LD_INT 109
90603: PUSH
90604: LD_INT 110
90606: PUSH
90607: LD_INT 111
90609: PUSH
90610: LD_INT 112
90612: PUSH
90613: LD_INT 113
90615: PUSH
90616: LD_INT 114
90618: PUSH
90619: LD_INT 116
90621: PUSH
90622: LD_INT 117
90624: PUSH
90625: LD_INT 118
90627: PUSH
90628: EMPTY
90629: LIST
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: LIST
90636: LIST
90637: LIST
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: PUSH
90647: EMPTY
90648: LIST
90649: LIST
90650: ST_TO_ADDR
90651: GO 92106
90653: LD_INT 13
90655: DOUBLE
90656: EQUAL
90657: IFTRUE 90661
90659: GO 90869
90661: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
90662: LD_ADDR_VAR 0 2
90666: PUSH
90667: LD_INT 1
90669: PUSH
90670: LD_INT 2
90672: PUSH
90673: LD_INT 3
90675: PUSH
90676: LD_INT 4
90678: PUSH
90679: LD_INT 5
90681: PUSH
90682: LD_INT 8
90684: PUSH
90685: LD_INT 9
90687: PUSH
90688: LD_INT 10
90690: PUSH
90691: LD_INT 11
90693: PUSH
90694: LD_INT 12
90696: PUSH
90697: LD_INT 14
90699: PUSH
90700: LD_INT 15
90702: PUSH
90703: LD_INT 16
90705: PUSH
90706: LD_INT 17
90708: PUSH
90709: LD_INT 18
90711: PUSH
90712: LD_INT 19
90714: PUSH
90715: LD_INT 20
90717: PUSH
90718: LD_INT 21
90720: PUSH
90721: LD_INT 22
90723: PUSH
90724: LD_INT 23
90726: PUSH
90727: LD_INT 24
90729: PUSH
90730: LD_INT 25
90732: PUSH
90733: LD_INT 26
90735: PUSH
90736: LD_INT 27
90738: PUSH
90739: LD_INT 28
90741: PUSH
90742: LD_INT 30
90744: PUSH
90745: LD_INT 31
90747: PUSH
90748: LD_INT 32
90750: PUSH
90751: LD_INT 33
90753: PUSH
90754: LD_INT 34
90756: PUSH
90757: LD_INT 36
90759: PUSH
90760: EMPTY
90761: LIST
90762: LIST
90763: LIST
90764: LIST
90765: LIST
90766: LIST
90767: LIST
90768: LIST
90769: LIST
90770: LIST
90771: LIST
90772: LIST
90773: LIST
90774: LIST
90775: LIST
90776: LIST
90777: LIST
90778: LIST
90779: LIST
90780: LIST
90781: LIST
90782: LIST
90783: LIST
90784: LIST
90785: LIST
90786: LIST
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: PUSH
90793: LD_INT 101
90795: PUSH
90796: LD_INT 102
90798: PUSH
90799: LD_INT 103
90801: PUSH
90802: LD_INT 104
90804: PUSH
90805: LD_INT 105
90807: PUSH
90808: LD_INT 106
90810: PUSH
90811: LD_INT 107
90813: PUSH
90814: LD_INT 108
90816: PUSH
90817: LD_INT 109
90819: PUSH
90820: LD_INT 110
90822: PUSH
90823: LD_INT 111
90825: PUSH
90826: LD_INT 112
90828: PUSH
90829: LD_INT 113
90831: PUSH
90832: LD_INT 114
90834: PUSH
90835: LD_INT 116
90837: PUSH
90838: LD_INT 117
90840: PUSH
90841: LD_INT 118
90843: PUSH
90844: EMPTY
90845: LIST
90846: LIST
90847: LIST
90848: LIST
90849: LIST
90850: LIST
90851: LIST
90852: LIST
90853: LIST
90854: LIST
90855: LIST
90856: LIST
90857: LIST
90858: LIST
90859: LIST
90860: LIST
90861: LIST
90862: PUSH
90863: EMPTY
90864: LIST
90865: LIST
90866: ST_TO_ADDR
90867: GO 92106
90869: LD_INT 14
90871: DOUBLE
90872: EQUAL
90873: IFTRUE 90877
90875: GO 91101
90877: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
90878: LD_ADDR_VAR 0 2
90882: PUSH
90883: LD_INT 1
90885: PUSH
90886: LD_INT 2
90888: PUSH
90889: LD_INT 3
90891: PUSH
90892: LD_INT 4
90894: PUSH
90895: LD_INT 5
90897: PUSH
90898: LD_INT 6
90900: PUSH
90901: LD_INT 7
90903: PUSH
90904: LD_INT 8
90906: PUSH
90907: LD_INT 9
90909: PUSH
90910: LD_INT 10
90912: PUSH
90913: LD_INT 11
90915: PUSH
90916: LD_INT 12
90918: PUSH
90919: LD_INT 13
90921: PUSH
90922: LD_INT 14
90924: PUSH
90925: LD_INT 15
90927: PUSH
90928: LD_INT 16
90930: PUSH
90931: LD_INT 17
90933: PUSH
90934: LD_INT 18
90936: PUSH
90937: LD_INT 19
90939: PUSH
90940: LD_INT 20
90942: PUSH
90943: LD_INT 21
90945: PUSH
90946: LD_INT 22
90948: PUSH
90949: LD_INT 23
90951: PUSH
90952: LD_INT 24
90954: PUSH
90955: LD_INT 25
90957: PUSH
90958: LD_INT 26
90960: PUSH
90961: LD_INT 27
90963: PUSH
90964: LD_INT 28
90966: PUSH
90967: LD_INT 29
90969: PUSH
90970: LD_INT 30
90972: PUSH
90973: LD_INT 31
90975: PUSH
90976: LD_INT 32
90978: PUSH
90979: LD_INT 33
90981: PUSH
90982: LD_INT 34
90984: PUSH
90985: LD_INT 36
90987: PUSH
90988: EMPTY
90989: LIST
90990: LIST
90991: LIST
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: LIST
90997: LIST
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: LIST
91003: LIST
91004: LIST
91005: LIST
91006: LIST
91007: LIST
91008: LIST
91009: LIST
91010: LIST
91011: LIST
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: LIST
91017: LIST
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: PUSH
91025: LD_INT 101
91027: PUSH
91028: LD_INT 102
91030: PUSH
91031: LD_INT 103
91033: PUSH
91034: LD_INT 104
91036: PUSH
91037: LD_INT 105
91039: PUSH
91040: LD_INT 106
91042: PUSH
91043: LD_INT 107
91045: PUSH
91046: LD_INT 108
91048: PUSH
91049: LD_INT 109
91051: PUSH
91052: LD_INT 110
91054: PUSH
91055: LD_INT 111
91057: PUSH
91058: LD_INT 112
91060: PUSH
91061: LD_INT 113
91063: PUSH
91064: LD_INT 114
91066: PUSH
91067: LD_INT 116
91069: PUSH
91070: LD_INT 117
91072: PUSH
91073: LD_INT 118
91075: PUSH
91076: EMPTY
91077: LIST
91078: LIST
91079: LIST
91080: LIST
91081: LIST
91082: LIST
91083: LIST
91084: LIST
91085: LIST
91086: LIST
91087: LIST
91088: LIST
91089: LIST
91090: LIST
91091: LIST
91092: LIST
91093: LIST
91094: PUSH
91095: EMPTY
91096: LIST
91097: LIST
91098: ST_TO_ADDR
91099: GO 92106
91101: LD_INT 15
91103: DOUBLE
91104: EQUAL
91105: IFTRUE 91109
91107: GO 91333
91109: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
91110: LD_ADDR_VAR 0 2
91114: PUSH
91115: LD_INT 1
91117: PUSH
91118: LD_INT 2
91120: PUSH
91121: LD_INT 3
91123: PUSH
91124: LD_INT 4
91126: PUSH
91127: LD_INT 5
91129: PUSH
91130: LD_INT 6
91132: PUSH
91133: LD_INT 7
91135: PUSH
91136: LD_INT 8
91138: PUSH
91139: LD_INT 9
91141: PUSH
91142: LD_INT 10
91144: PUSH
91145: LD_INT 11
91147: PUSH
91148: LD_INT 12
91150: PUSH
91151: LD_INT 13
91153: PUSH
91154: LD_INT 14
91156: PUSH
91157: LD_INT 15
91159: PUSH
91160: LD_INT 16
91162: PUSH
91163: LD_INT 17
91165: PUSH
91166: LD_INT 18
91168: PUSH
91169: LD_INT 19
91171: PUSH
91172: LD_INT 20
91174: PUSH
91175: LD_INT 21
91177: PUSH
91178: LD_INT 22
91180: PUSH
91181: LD_INT 23
91183: PUSH
91184: LD_INT 24
91186: PUSH
91187: LD_INT 25
91189: PUSH
91190: LD_INT 26
91192: PUSH
91193: LD_INT 27
91195: PUSH
91196: LD_INT 28
91198: PUSH
91199: LD_INT 29
91201: PUSH
91202: LD_INT 30
91204: PUSH
91205: LD_INT 31
91207: PUSH
91208: LD_INT 32
91210: PUSH
91211: LD_INT 33
91213: PUSH
91214: LD_INT 34
91216: PUSH
91217: LD_INT 36
91219: PUSH
91220: EMPTY
91221: LIST
91222: LIST
91223: LIST
91224: LIST
91225: LIST
91226: LIST
91227: LIST
91228: LIST
91229: LIST
91230: LIST
91231: LIST
91232: LIST
91233: LIST
91234: LIST
91235: LIST
91236: LIST
91237: LIST
91238: LIST
91239: LIST
91240: LIST
91241: LIST
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: LIST
91254: LIST
91255: LIST
91256: PUSH
91257: LD_INT 101
91259: PUSH
91260: LD_INT 102
91262: PUSH
91263: LD_INT 103
91265: PUSH
91266: LD_INT 104
91268: PUSH
91269: LD_INT 105
91271: PUSH
91272: LD_INT 106
91274: PUSH
91275: LD_INT 107
91277: PUSH
91278: LD_INT 108
91280: PUSH
91281: LD_INT 109
91283: PUSH
91284: LD_INT 110
91286: PUSH
91287: LD_INT 111
91289: PUSH
91290: LD_INT 112
91292: PUSH
91293: LD_INT 113
91295: PUSH
91296: LD_INT 114
91298: PUSH
91299: LD_INT 116
91301: PUSH
91302: LD_INT 117
91304: PUSH
91305: LD_INT 118
91307: PUSH
91308: EMPTY
91309: LIST
91310: LIST
91311: LIST
91312: LIST
91313: LIST
91314: LIST
91315: LIST
91316: LIST
91317: LIST
91318: LIST
91319: LIST
91320: LIST
91321: LIST
91322: LIST
91323: LIST
91324: LIST
91325: LIST
91326: PUSH
91327: EMPTY
91328: LIST
91329: LIST
91330: ST_TO_ADDR
91331: GO 92106
91333: LD_INT 16
91335: DOUBLE
91336: EQUAL
91337: IFTRUE 91341
91339: GO 91477
91341: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
91342: LD_ADDR_VAR 0 2
91346: PUSH
91347: LD_INT 2
91349: PUSH
91350: LD_INT 4
91352: PUSH
91353: LD_INT 5
91355: PUSH
91356: LD_INT 7
91358: PUSH
91359: LD_INT 11
91361: PUSH
91362: LD_INT 12
91364: PUSH
91365: LD_INT 15
91367: PUSH
91368: LD_INT 16
91370: PUSH
91371: LD_INT 20
91373: PUSH
91374: LD_INT 21
91376: PUSH
91377: LD_INT 22
91379: PUSH
91380: LD_INT 23
91382: PUSH
91383: LD_INT 25
91385: PUSH
91386: LD_INT 26
91388: PUSH
91389: LD_INT 30
91391: PUSH
91392: LD_INT 31
91394: PUSH
91395: LD_INT 32
91397: PUSH
91398: LD_INT 33
91400: PUSH
91401: LD_INT 34
91403: PUSH
91404: EMPTY
91405: LIST
91406: LIST
91407: LIST
91408: LIST
91409: LIST
91410: LIST
91411: LIST
91412: LIST
91413: LIST
91414: LIST
91415: LIST
91416: LIST
91417: LIST
91418: LIST
91419: LIST
91420: LIST
91421: LIST
91422: LIST
91423: LIST
91424: PUSH
91425: LD_INT 101
91427: PUSH
91428: LD_INT 102
91430: PUSH
91431: LD_INT 103
91433: PUSH
91434: LD_INT 106
91436: PUSH
91437: LD_INT 108
91439: PUSH
91440: LD_INT 112
91442: PUSH
91443: LD_INT 113
91445: PUSH
91446: LD_INT 114
91448: PUSH
91449: LD_INT 116
91451: PUSH
91452: LD_INT 117
91454: PUSH
91455: LD_INT 118
91457: PUSH
91458: EMPTY
91459: LIST
91460: LIST
91461: LIST
91462: LIST
91463: LIST
91464: LIST
91465: LIST
91466: LIST
91467: LIST
91468: LIST
91469: LIST
91470: PUSH
91471: EMPTY
91472: LIST
91473: LIST
91474: ST_TO_ADDR
91475: GO 92106
91477: LD_INT 17
91479: DOUBLE
91480: EQUAL
91481: IFTRUE 91485
91483: GO 91709
91485: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
91486: LD_ADDR_VAR 0 2
91490: PUSH
91491: LD_INT 1
91493: PUSH
91494: LD_INT 2
91496: PUSH
91497: LD_INT 3
91499: PUSH
91500: LD_INT 4
91502: PUSH
91503: LD_INT 5
91505: PUSH
91506: LD_INT 6
91508: PUSH
91509: LD_INT 7
91511: PUSH
91512: LD_INT 8
91514: PUSH
91515: LD_INT 9
91517: PUSH
91518: LD_INT 10
91520: PUSH
91521: LD_INT 11
91523: PUSH
91524: LD_INT 12
91526: PUSH
91527: LD_INT 13
91529: PUSH
91530: LD_INT 14
91532: PUSH
91533: LD_INT 15
91535: PUSH
91536: LD_INT 16
91538: PUSH
91539: LD_INT 17
91541: PUSH
91542: LD_INT 18
91544: PUSH
91545: LD_INT 19
91547: PUSH
91548: LD_INT 20
91550: PUSH
91551: LD_INT 21
91553: PUSH
91554: LD_INT 22
91556: PUSH
91557: LD_INT 23
91559: PUSH
91560: LD_INT 24
91562: PUSH
91563: LD_INT 25
91565: PUSH
91566: LD_INT 26
91568: PUSH
91569: LD_INT 27
91571: PUSH
91572: LD_INT 28
91574: PUSH
91575: LD_INT 29
91577: PUSH
91578: LD_INT 30
91580: PUSH
91581: LD_INT 31
91583: PUSH
91584: LD_INT 32
91586: PUSH
91587: LD_INT 33
91589: PUSH
91590: LD_INT 34
91592: PUSH
91593: LD_INT 36
91595: PUSH
91596: EMPTY
91597: LIST
91598: LIST
91599: LIST
91600: LIST
91601: LIST
91602: LIST
91603: LIST
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: LIST
91614: LIST
91615: LIST
91616: LIST
91617: LIST
91618: LIST
91619: LIST
91620: LIST
91621: LIST
91622: LIST
91623: LIST
91624: LIST
91625: LIST
91626: LIST
91627: LIST
91628: LIST
91629: LIST
91630: LIST
91631: LIST
91632: PUSH
91633: LD_INT 101
91635: PUSH
91636: LD_INT 102
91638: PUSH
91639: LD_INT 103
91641: PUSH
91642: LD_INT 104
91644: PUSH
91645: LD_INT 105
91647: PUSH
91648: LD_INT 106
91650: PUSH
91651: LD_INT 107
91653: PUSH
91654: LD_INT 108
91656: PUSH
91657: LD_INT 109
91659: PUSH
91660: LD_INT 110
91662: PUSH
91663: LD_INT 111
91665: PUSH
91666: LD_INT 112
91668: PUSH
91669: LD_INT 113
91671: PUSH
91672: LD_INT 114
91674: PUSH
91675: LD_INT 116
91677: PUSH
91678: LD_INT 117
91680: PUSH
91681: LD_INT 118
91683: PUSH
91684: EMPTY
91685: LIST
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: LIST
91698: LIST
91699: LIST
91700: LIST
91701: LIST
91702: PUSH
91703: EMPTY
91704: LIST
91705: LIST
91706: ST_TO_ADDR
91707: GO 92106
91709: LD_INT 18
91711: DOUBLE
91712: EQUAL
91713: IFTRUE 91717
91715: GO 91865
91717: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
91718: LD_ADDR_VAR 0 2
91722: PUSH
91723: LD_INT 2
91725: PUSH
91726: LD_INT 4
91728: PUSH
91729: LD_INT 5
91731: PUSH
91732: LD_INT 7
91734: PUSH
91735: LD_INT 11
91737: PUSH
91738: LD_INT 12
91740: PUSH
91741: LD_INT 15
91743: PUSH
91744: LD_INT 16
91746: PUSH
91747: LD_INT 20
91749: PUSH
91750: LD_INT 21
91752: PUSH
91753: LD_INT 22
91755: PUSH
91756: LD_INT 23
91758: PUSH
91759: LD_INT 25
91761: PUSH
91762: LD_INT 26
91764: PUSH
91765: LD_INT 30
91767: PUSH
91768: LD_INT 31
91770: PUSH
91771: LD_INT 32
91773: PUSH
91774: LD_INT 33
91776: PUSH
91777: LD_INT 34
91779: PUSH
91780: LD_INT 35
91782: PUSH
91783: LD_INT 36
91785: PUSH
91786: EMPTY
91787: LIST
91788: LIST
91789: LIST
91790: LIST
91791: LIST
91792: LIST
91793: LIST
91794: LIST
91795: LIST
91796: LIST
91797: LIST
91798: LIST
91799: LIST
91800: LIST
91801: LIST
91802: LIST
91803: LIST
91804: LIST
91805: LIST
91806: LIST
91807: LIST
91808: PUSH
91809: LD_INT 101
91811: PUSH
91812: LD_INT 102
91814: PUSH
91815: LD_INT 103
91817: PUSH
91818: LD_INT 106
91820: PUSH
91821: LD_INT 108
91823: PUSH
91824: LD_INT 112
91826: PUSH
91827: LD_INT 113
91829: PUSH
91830: LD_INT 114
91832: PUSH
91833: LD_INT 115
91835: PUSH
91836: LD_INT 116
91838: PUSH
91839: LD_INT 117
91841: PUSH
91842: LD_INT 118
91844: PUSH
91845: EMPTY
91846: LIST
91847: LIST
91848: LIST
91849: LIST
91850: LIST
91851: LIST
91852: LIST
91853: LIST
91854: LIST
91855: LIST
91856: LIST
91857: LIST
91858: PUSH
91859: EMPTY
91860: LIST
91861: LIST
91862: ST_TO_ADDR
91863: GO 92106
91865: LD_INT 19
91867: DOUBLE
91868: EQUAL
91869: IFTRUE 91873
91871: GO 92105
91873: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
91874: LD_ADDR_VAR 0 2
91878: PUSH
91879: LD_INT 1
91881: PUSH
91882: LD_INT 2
91884: PUSH
91885: LD_INT 3
91887: PUSH
91888: LD_INT 4
91890: PUSH
91891: LD_INT 5
91893: PUSH
91894: LD_INT 6
91896: PUSH
91897: LD_INT 7
91899: PUSH
91900: LD_INT 8
91902: PUSH
91903: LD_INT 9
91905: PUSH
91906: LD_INT 10
91908: PUSH
91909: LD_INT 11
91911: PUSH
91912: LD_INT 12
91914: PUSH
91915: LD_INT 13
91917: PUSH
91918: LD_INT 14
91920: PUSH
91921: LD_INT 15
91923: PUSH
91924: LD_INT 16
91926: PUSH
91927: LD_INT 17
91929: PUSH
91930: LD_INT 18
91932: PUSH
91933: LD_INT 19
91935: PUSH
91936: LD_INT 20
91938: PUSH
91939: LD_INT 21
91941: PUSH
91942: LD_INT 22
91944: PUSH
91945: LD_INT 23
91947: PUSH
91948: LD_INT 24
91950: PUSH
91951: LD_INT 25
91953: PUSH
91954: LD_INT 26
91956: PUSH
91957: LD_INT 27
91959: PUSH
91960: LD_INT 28
91962: PUSH
91963: LD_INT 29
91965: PUSH
91966: LD_INT 30
91968: PUSH
91969: LD_INT 31
91971: PUSH
91972: LD_INT 32
91974: PUSH
91975: LD_INT 33
91977: PUSH
91978: LD_INT 34
91980: PUSH
91981: LD_INT 35
91983: PUSH
91984: LD_INT 36
91986: PUSH
91987: EMPTY
91988: LIST
91989: LIST
91990: LIST
91991: LIST
91992: LIST
91993: LIST
91994: LIST
91995: LIST
91996: LIST
91997: LIST
91998: LIST
91999: LIST
92000: LIST
92001: LIST
92002: LIST
92003: LIST
92004: LIST
92005: LIST
92006: LIST
92007: LIST
92008: LIST
92009: LIST
92010: LIST
92011: LIST
92012: LIST
92013: LIST
92014: LIST
92015: LIST
92016: LIST
92017: LIST
92018: LIST
92019: LIST
92020: LIST
92021: LIST
92022: LIST
92023: LIST
92024: PUSH
92025: LD_INT 101
92027: PUSH
92028: LD_INT 102
92030: PUSH
92031: LD_INT 103
92033: PUSH
92034: LD_INT 104
92036: PUSH
92037: LD_INT 105
92039: PUSH
92040: LD_INT 106
92042: PUSH
92043: LD_INT 107
92045: PUSH
92046: LD_INT 108
92048: PUSH
92049: LD_INT 109
92051: PUSH
92052: LD_INT 110
92054: PUSH
92055: LD_INT 111
92057: PUSH
92058: LD_INT 112
92060: PUSH
92061: LD_INT 113
92063: PUSH
92064: LD_INT 114
92066: PUSH
92067: LD_INT 115
92069: PUSH
92070: LD_INT 116
92072: PUSH
92073: LD_INT 117
92075: PUSH
92076: LD_INT 118
92078: PUSH
92079: EMPTY
92080: LIST
92081: LIST
92082: LIST
92083: LIST
92084: LIST
92085: LIST
92086: LIST
92087: LIST
92088: LIST
92089: LIST
92090: LIST
92091: LIST
92092: LIST
92093: LIST
92094: LIST
92095: LIST
92096: LIST
92097: LIST
92098: PUSH
92099: EMPTY
92100: LIST
92101: LIST
92102: ST_TO_ADDR
92103: GO 92106
92105: POP
// end else
92106: GO 92337
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
92108: LD_ADDR_VAR 0 2
92112: PUSH
92113: LD_INT 1
92115: PUSH
92116: LD_INT 2
92118: PUSH
92119: LD_INT 3
92121: PUSH
92122: LD_INT 4
92124: PUSH
92125: LD_INT 5
92127: PUSH
92128: LD_INT 6
92130: PUSH
92131: LD_INT 7
92133: PUSH
92134: LD_INT 8
92136: PUSH
92137: LD_INT 9
92139: PUSH
92140: LD_INT 10
92142: PUSH
92143: LD_INT 11
92145: PUSH
92146: LD_INT 12
92148: PUSH
92149: LD_INT 13
92151: PUSH
92152: LD_INT 14
92154: PUSH
92155: LD_INT 15
92157: PUSH
92158: LD_INT 16
92160: PUSH
92161: LD_INT 17
92163: PUSH
92164: LD_INT 18
92166: PUSH
92167: LD_INT 19
92169: PUSH
92170: LD_INT 20
92172: PUSH
92173: LD_INT 21
92175: PUSH
92176: LD_INT 22
92178: PUSH
92179: LD_INT 23
92181: PUSH
92182: LD_INT 24
92184: PUSH
92185: LD_INT 25
92187: PUSH
92188: LD_INT 26
92190: PUSH
92191: LD_INT 27
92193: PUSH
92194: LD_INT 28
92196: PUSH
92197: LD_INT 29
92199: PUSH
92200: LD_INT 30
92202: PUSH
92203: LD_INT 31
92205: PUSH
92206: LD_INT 32
92208: PUSH
92209: LD_INT 33
92211: PUSH
92212: LD_INT 34
92214: PUSH
92215: LD_INT 35
92217: PUSH
92218: LD_INT 36
92220: PUSH
92221: EMPTY
92222: LIST
92223: LIST
92224: LIST
92225: LIST
92226: LIST
92227: LIST
92228: LIST
92229: LIST
92230: LIST
92231: LIST
92232: LIST
92233: LIST
92234: LIST
92235: LIST
92236: LIST
92237: LIST
92238: LIST
92239: LIST
92240: LIST
92241: LIST
92242: LIST
92243: LIST
92244: LIST
92245: LIST
92246: LIST
92247: LIST
92248: LIST
92249: LIST
92250: LIST
92251: LIST
92252: LIST
92253: LIST
92254: LIST
92255: LIST
92256: LIST
92257: LIST
92258: PUSH
92259: LD_INT 101
92261: PUSH
92262: LD_INT 102
92264: PUSH
92265: LD_INT 103
92267: PUSH
92268: LD_INT 104
92270: PUSH
92271: LD_INT 105
92273: PUSH
92274: LD_INT 106
92276: PUSH
92277: LD_INT 107
92279: PUSH
92280: LD_INT 108
92282: PUSH
92283: LD_INT 109
92285: PUSH
92286: LD_INT 110
92288: PUSH
92289: LD_INT 111
92291: PUSH
92292: LD_INT 112
92294: PUSH
92295: LD_INT 113
92297: PUSH
92298: LD_INT 114
92300: PUSH
92301: LD_INT 115
92303: PUSH
92304: LD_INT 116
92306: PUSH
92307: LD_INT 117
92309: PUSH
92310: LD_INT 118
92312: PUSH
92313: EMPTY
92314: LIST
92315: LIST
92316: LIST
92317: LIST
92318: LIST
92319: LIST
92320: LIST
92321: LIST
92322: LIST
92323: LIST
92324: LIST
92325: LIST
92326: LIST
92327: LIST
92328: LIST
92329: LIST
92330: LIST
92331: LIST
92332: PUSH
92333: EMPTY
92334: LIST
92335: LIST
92336: ST_TO_ADDR
// if result then
92337: LD_VAR 0 2
92341: IFFALSE 93127
// begin normal :=  ;
92343: LD_ADDR_VAR 0 5
92347: PUSH
92348: LD_STRING 
92350: ST_TO_ADDR
// hardcore :=  ;
92351: LD_ADDR_VAR 0 6
92355: PUSH
92356: LD_STRING 
92358: ST_TO_ADDR
// active :=  ;
92359: LD_ADDR_VAR 0 7
92363: PUSH
92364: LD_STRING 
92366: ST_TO_ADDR
// for i = 1 to normalCounter do
92367: LD_ADDR_VAR 0 8
92371: PUSH
92372: DOUBLE
92373: LD_INT 1
92375: DEC
92376: ST_TO_ADDR
92377: LD_EXP 108
92381: PUSH
92382: FOR_TO
92383: IFFALSE 92484
// begin tmp := 0 ;
92385: LD_ADDR_VAR 0 3
92389: PUSH
92390: LD_STRING 0
92392: ST_TO_ADDR
// if result [ 1 ] then
92393: LD_VAR 0 2
92397: PUSH
92398: LD_INT 1
92400: ARRAY
92401: IFFALSE 92466
// if result [ 1 ] [ 1 ] = i then
92403: LD_VAR 0 2
92407: PUSH
92408: LD_INT 1
92410: ARRAY
92411: PUSH
92412: LD_INT 1
92414: ARRAY
92415: PUSH
92416: LD_VAR 0 8
92420: EQUAL
92421: IFFALSE 92466
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
92423: LD_ADDR_VAR 0 2
92427: PUSH
92428: LD_VAR 0 2
92432: PPUSH
92433: LD_INT 1
92435: PPUSH
92436: LD_VAR 0 2
92440: PUSH
92441: LD_INT 1
92443: ARRAY
92444: PPUSH
92445: LD_INT 1
92447: PPUSH
92448: CALL_OW 3
92452: PPUSH
92453: CALL_OW 1
92457: ST_TO_ADDR
// tmp := 1 ;
92458: LD_ADDR_VAR 0 3
92462: PUSH
92463: LD_STRING 1
92465: ST_TO_ADDR
// end ; normal := normal & tmp ;
92466: LD_ADDR_VAR 0 5
92470: PUSH
92471: LD_VAR 0 5
92475: PUSH
92476: LD_VAR 0 3
92480: STR
92481: ST_TO_ADDR
// end ;
92482: GO 92382
92484: POP
92485: POP
// for i = 1 to hardcoreCounter do
92486: LD_ADDR_VAR 0 8
92490: PUSH
92491: DOUBLE
92492: LD_INT 1
92494: DEC
92495: ST_TO_ADDR
92496: LD_EXP 109
92500: PUSH
92501: FOR_TO
92502: IFFALSE 92607
// begin tmp := 0 ;
92504: LD_ADDR_VAR 0 3
92508: PUSH
92509: LD_STRING 0
92511: ST_TO_ADDR
// if result [ 2 ] then
92512: LD_VAR 0 2
92516: PUSH
92517: LD_INT 2
92519: ARRAY
92520: IFFALSE 92589
// if result [ 2 ] [ 1 ] = 100 + i then
92522: LD_VAR 0 2
92526: PUSH
92527: LD_INT 2
92529: ARRAY
92530: PUSH
92531: LD_INT 1
92533: ARRAY
92534: PUSH
92535: LD_INT 100
92537: PUSH
92538: LD_VAR 0 8
92542: PLUS
92543: EQUAL
92544: IFFALSE 92589
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
92546: LD_ADDR_VAR 0 2
92550: PUSH
92551: LD_VAR 0 2
92555: PPUSH
92556: LD_INT 2
92558: PPUSH
92559: LD_VAR 0 2
92563: PUSH
92564: LD_INT 2
92566: ARRAY
92567: PPUSH
92568: LD_INT 1
92570: PPUSH
92571: CALL_OW 3
92575: PPUSH
92576: CALL_OW 1
92580: ST_TO_ADDR
// tmp := 1 ;
92581: LD_ADDR_VAR 0 3
92585: PUSH
92586: LD_STRING 1
92588: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
92589: LD_ADDR_VAR 0 6
92593: PUSH
92594: LD_VAR 0 6
92598: PUSH
92599: LD_VAR 0 3
92603: STR
92604: ST_TO_ADDR
// end ;
92605: GO 92501
92607: POP
92608: POP
// if isGameLoad then
92609: LD_VAR 0 1
92613: IFFALSE 93088
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
92615: LD_ADDR_VAR 0 4
92619: PUSH
92620: LD_EXP 112
92624: PUSH
92625: LD_EXP 111
92629: PUSH
92630: LD_EXP 113
92634: PUSH
92635: LD_EXP 110
92639: PUSH
92640: LD_EXP 114
92644: PUSH
92645: LD_EXP 115
92649: PUSH
92650: LD_EXP 116
92654: PUSH
92655: LD_EXP 117
92659: PUSH
92660: LD_EXP 118
92664: PUSH
92665: LD_EXP 119
92669: PUSH
92670: LD_EXP 120
92674: PUSH
92675: LD_EXP 121
92679: PUSH
92680: LD_EXP 122
92684: PUSH
92685: LD_EXP 123
92689: PUSH
92690: LD_EXP 131
92694: PUSH
92695: LD_EXP 132
92699: PUSH
92700: LD_EXP 133
92704: PUSH
92705: LD_EXP 134
92709: PUSH
92710: LD_EXP 136
92714: PUSH
92715: LD_EXP 137
92719: PUSH
92720: LD_EXP 138
92724: PUSH
92725: LD_EXP 141
92729: PUSH
92730: LD_EXP 143
92734: PUSH
92735: LD_EXP 144
92739: PUSH
92740: LD_EXP 145
92744: PUSH
92745: LD_EXP 147
92749: PUSH
92750: LD_EXP 148
92754: PUSH
92755: LD_EXP 151
92759: PUSH
92760: LD_EXP 152
92764: PUSH
92765: LD_EXP 153
92769: PUSH
92770: LD_EXP 154
92774: PUSH
92775: LD_EXP 155
92779: PUSH
92780: LD_EXP 156
92784: PUSH
92785: LD_EXP 157
92789: PUSH
92790: LD_EXP 158
92794: PUSH
92795: LD_EXP 159
92799: PUSH
92800: LD_EXP 124
92804: PUSH
92805: LD_EXP 125
92809: PUSH
92810: LD_EXP 128
92814: PUSH
92815: LD_EXP 129
92819: PUSH
92820: LD_EXP 130
92824: PUSH
92825: LD_EXP 126
92829: PUSH
92830: LD_EXP 127
92834: PUSH
92835: LD_EXP 135
92839: PUSH
92840: LD_EXP 139
92844: PUSH
92845: LD_EXP 140
92849: PUSH
92850: LD_EXP 142
92854: PUSH
92855: LD_EXP 146
92859: PUSH
92860: LD_EXP 149
92864: PUSH
92865: LD_EXP 150
92869: PUSH
92870: LD_EXP 160
92874: PUSH
92875: LD_EXP 161
92879: PUSH
92880: LD_EXP 162
92884: PUSH
92885: LD_EXP 163
92889: PUSH
92890: EMPTY
92891: LIST
92892: LIST
92893: LIST
92894: LIST
92895: LIST
92896: LIST
92897: LIST
92898: LIST
92899: LIST
92900: LIST
92901: LIST
92902: LIST
92903: LIST
92904: LIST
92905: LIST
92906: LIST
92907: LIST
92908: LIST
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: LIST
92915: LIST
92916: LIST
92917: LIST
92918: LIST
92919: LIST
92920: LIST
92921: LIST
92922: LIST
92923: LIST
92924: LIST
92925: LIST
92926: LIST
92927: LIST
92928: LIST
92929: LIST
92930: LIST
92931: LIST
92932: LIST
92933: LIST
92934: LIST
92935: LIST
92936: LIST
92937: LIST
92938: LIST
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: LIST
92944: LIST
92945: ST_TO_ADDR
// tmp :=  ;
92946: LD_ADDR_VAR 0 3
92950: PUSH
92951: LD_STRING 
92953: ST_TO_ADDR
// for i = 1 to normalCounter do
92954: LD_ADDR_VAR 0 8
92958: PUSH
92959: DOUBLE
92960: LD_INT 1
92962: DEC
92963: ST_TO_ADDR
92964: LD_EXP 108
92968: PUSH
92969: FOR_TO
92970: IFFALSE 93006
// begin if flags [ i ] then
92972: LD_VAR 0 4
92976: PUSH
92977: LD_VAR 0 8
92981: ARRAY
92982: IFFALSE 93004
// tmp := tmp & i & ; ;
92984: LD_ADDR_VAR 0 3
92988: PUSH
92989: LD_VAR 0 3
92993: PUSH
92994: LD_VAR 0 8
92998: STR
92999: PUSH
93000: LD_STRING ;
93002: STR
93003: ST_TO_ADDR
// end ;
93004: GO 92969
93006: POP
93007: POP
// for i = 1 to hardcoreCounter do
93008: LD_ADDR_VAR 0 8
93012: PUSH
93013: DOUBLE
93014: LD_INT 1
93016: DEC
93017: ST_TO_ADDR
93018: LD_EXP 109
93022: PUSH
93023: FOR_TO
93024: IFFALSE 93070
// begin if flags [ normalCounter + i ] then
93026: LD_VAR 0 4
93030: PUSH
93031: LD_EXP 108
93035: PUSH
93036: LD_VAR 0 8
93040: PLUS
93041: ARRAY
93042: IFFALSE 93068
// tmp := tmp & ( 100 + i ) & ; ;
93044: LD_ADDR_VAR 0 3
93048: PUSH
93049: LD_VAR 0 3
93053: PUSH
93054: LD_INT 100
93056: PUSH
93057: LD_VAR 0 8
93061: PLUS
93062: STR
93063: PUSH
93064: LD_STRING ;
93066: STR
93067: ST_TO_ADDR
// end ;
93068: GO 93023
93070: POP
93071: POP
// if tmp then
93072: LD_VAR 0 3
93076: IFFALSE 93088
// active := tmp ;
93078: LD_ADDR_VAR 0 7
93082: PUSH
93083: LD_VAR 0 3
93087: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
93088: LD_STRING getStreamItemsFromMission("
93090: PUSH
93091: LD_VAR 0 5
93095: STR
93096: PUSH
93097: LD_STRING ","
93099: STR
93100: PUSH
93101: LD_VAR 0 6
93105: STR
93106: PUSH
93107: LD_STRING ","
93109: STR
93110: PUSH
93111: LD_VAR 0 7
93115: STR
93116: PUSH
93117: LD_STRING ")
93119: STR
93120: PPUSH
93121: CALL_OW 559
// end else
93125: GO 93134
// ToLua ( getStreamItemsFromMission("","","") ) ;
93127: LD_STRING getStreamItemsFromMission("","","")
93129: PPUSH
93130: CALL_OW 559
// end ;
93134: LD_VAR 0 2
93138: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
93139: LD_EXP 107
93143: PUSH
93144: LD_EXP 112
93148: AND
93149: IFFALSE 93273
93151: GO 93153
93153: DISABLE
93154: LD_INT 0
93156: PPUSH
93157: PPUSH
// begin enable ;
93158: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
93159: LD_ADDR_VAR 0 2
93163: PUSH
93164: LD_INT 22
93166: PUSH
93167: LD_OWVAR 2
93171: PUSH
93172: EMPTY
93173: LIST
93174: LIST
93175: PUSH
93176: LD_INT 2
93178: PUSH
93179: LD_INT 34
93181: PUSH
93182: LD_INT 7
93184: PUSH
93185: EMPTY
93186: LIST
93187: LIST
93188: PUSH
93189: LD_INT 34
93191: PUSH
93192: LD_INT 45
93194: PUSH
93195: EMPTY
93196: LIST
93197: LIST
93198: PUSH
93199: LD_INT 34
93201: PUSH
93202: LD_INT 28
93204: PUSH
93205: EMPTY
93206: LIST
93207: LIST
93208: PUSH
93209: LD_INT 34
93211: PUSH
93212: LD_INT 47
93214: PUSH
93215: EMPTY
93216: LIST
93217: LIST
93218: PUSH
93219: EMPTY
93220: LIST
93221: LIST
93222: LIST
93223: LIST
93224: LIST
93225: PUSH
93226: EMPTY
93227: LIST
93228: LIST
93229: PPUSH
93230: CALL_OW 69
93234: ST_TO_ADDR
// if not tmp then
93235: LD_VAR 0 2
93239: NOT
93240: IFFALSE 93244
// exit ;
93242: GO 93273
// for i in tmp do
93244: LD_ADDR_VAR 0 1
93248: PUSH
93249: LD_VAR 0 2
93253: PUSH
93254: FOR_IN
93255: IFFALSE 93271
// begin SetLives ( i , 0 ) ;
93257: LD_VAR 0 1
93261: PPUSH
93262: LD_INT 0
93264: PPUSH
93265: CALL_OW 234
// end ;
93269: GO 93254
93271: POP
93272: POP
// end ;
93273: PPOPN 2
93275: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
93276: LD_EXP 107
93280: PUSH
93281: LD_EXP 113
93285: AND
93286: IFFALSE 93370
93288: GO 93290
93290: DISABLE
93291: LD_INT 0
93293: PPUSH
93294: PPUSH
// begin enable ;
93295: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
93296: LD_ADDR_VAR 0 2
93300: PUSH
93301: LD_INT 22
93303: PUSH
93304: LD_OWVAR 2
93308: PUSH
93309: EMPTY
93310: LIST
93311: LIST
93312: PUSH
93313: LD_INT 32
93315: PUSH
93316: LD_INT 3
93318: PUSH
93319: EMPTY
93320: LIST
93321: LIST
93322: PUSH
93323: EMPTY
93324: LIST
93325: LIST
93326: PPUSH
93327: CALL_OW 69
93331: ST_TO_ADDR
// if not tmp then
93332: LD_VAR 0 2
93336: NOT
93337: IFFALSE 93341
// exit ;
93339: GO 93370
// for i in tmp do
93341: LD_ADDR_VAR 0 1
93345: PUSH
93346: LD_VAR 0 2
93350: PUSH
93351: FOR_IN
93352: IFFALSE 93368
// begin SetLives ( i , 0 ) ;
93354: LD_VAR 0 1
93358: PPUSH
93359: LD_INT 0
93361: PPUSH
93362: CALL_OW 234
// end ;
93366: GO 93351
93368: POP
93369: POP
// end ;
93370: PPOPN 2
93372: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
93373: LD_EXP 107
93377: PUSH
93378: LD_EXP 110
93382: AND
93383: IFFALSE 93476
93385: GO 93387
93387: DISABLE
93388: LD_INT 0
93390: PPUSH
// begin enable ;
93391: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
93392: LD_ADDR_VAR 0 1
93396: PUSH
93397: LD_INT 22
93399: PUSH
93400: LD_OWVAR 2
93404: PUSH
93405: EMPTY
93406: LIST
93407: LIST
93408: PUSH
93409: LD_INT 2
93411: PUSH
93412: LD_INT 25
93414: PUSH
93415: LD_INT 5
93417: PUSH
93418: EMPTY
93419: LIST
93420: LIST
93421: PUSH
93422: LD_INT 25
93424: PUSH
93425: LD_INT 9
93427: PUSH
93428: EMPTY
93429: LIST
93430: LIST
93431: PUSH
93432: LD_INT 25
93434: PUSH
93435: LD_INT 8
93437: PUSH
93438: EMPTY
93439: LIST
93440: LIST
93441: PUSH
93442: EMPTY
93443: LIST
93444: LIST
93445: LIST
93446: LIST
93447: PUSH
93448: EMPTY
93449: LIST
93450: LIST
93451: PPUSH
93452: CALL_OW 69
93456: PUSH
93457: FOR_IN
93458: IFFALSE 93474
// begin SetClass ( i , 1 ) ;
93460: LD_VAR 0 1
93464: PPUSH
93465: LD_INT 1
93467: PPUSH
93468: CALL_OW 336
// end ;
93472: GO 93457
93474: POP
93475: POP
// end ;
93476: PPOPN 1
93478: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
93479: LD_EXP 107
93483: PUSH
93484: LD_EXP 111
93488: AND
93489: PUSH
93490: LD_OWVAR 65
93494: PUSH
93495: LD_INT 7
93497: LESS
93498: AND
93499: IFFALSE 93513
93501: GO 93503
93503: DISABLE
// begin enable ;
93504: ENABLE
// game_speed := 7 ;
93505: LD_ADDR_OWVAR 65
93509: PUSH
93510: LD_INT 7
93512: ST_TO_ADDR
// end ;
93513: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
93514: LD_EXP 107
93518: PUSH
93519: LD_EXP 114
93523: AND
93524: IFFALSE 93726
93526: GO 93528
93528: DISABLE
93529: LD_INT 0
93531: PPUSH
93532: PPUSH
93533: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
93534: LD_ADDR_VAR 0 3
93538: PUSH
93539: LD_INT 81
93541: PUSH
93542: LD_OWVAR 2
93546: PUSH
93547: EMPTY
93548: LIST
93549: LIST
93550: PUSH
93551: LD_INT 21
93553: PUSH
93554: LD_INT 1
93556: PUSH
93557: EMPTY
93558: LIST
93559: LIST
93560: PUSH
93561: EMPTY
93562: LIST
93563: LIST
93564: PPUSH
93565: CALL_OW 69
93569: ST_TO_ADDR
// if not tmp then
93570: LD_VAR 0 3
93574: NOT
93575: IFFALSE 93579
// exit ;
93577: GO 93726
// if tmp > 5 then
93579: LD_VAR 0 3
93583: PUSH
93584: LD_INT 5
93586: GREATER
93587: IFFALSE 93599
// k := 5 else
93589: LD_ADDR_VAR 0 2
93593: PUSH
93594: LD_INT 5
93596: ST_TO_ADDR
93597: GO 93609
// k := tmp ;
93599: LD_ADDR_VAR 0 2
93603: PUSH
93604: LD_VAR 0 3
93608: ST_TO_ADDR
// for i := 1 to k do
93609: LD_ADDR_VAR 0 1
93613: PUSH
93614: DOUBLE
93615: LD_INT 1
93617: DEC
93618: ST_TO_ADDR
93619: LD_VAR 0 2
93623: PUSH
93624: FOR_TO
93625: IFFALSE 93724
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
93627: LD_VAR 0 3
93631: PUSH
93632: LD_VAR 0 1
93636: ARRAY
93637: PPUSH
93638: LD_VAR 0 1
93642: PUSH
93643: LD_INT 4
93645: MOD
93646: PUSH
93647: LD_INT 1
93649: PLUS
93650: PPUSH
93651: CALL_OW 259
93655: PUSH
93656: LD_INT 10
93658: LESS
93659: IFFALSE 93722
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
93661: LD_VAR 0 3
93665: PUSH
93666: LD_VAR 0 1
93670: ARRAY
93671: PPUSH
93672: LD_VAR 0 1
93676: PUSH
93677: LD_INT 4
93679: MOD
93680: PUSH
93681: LD_INT 1
93683: PLUS
93684: PPUSH
93685: LD_VAR 0 3
93689: PUSH
93690: LD_VAR 0 1
93694: ARRAY
93695: PPUSH
93696: LD_VAR 0 1
93700: PUSH
93701: LD_INT 4
93703: MOD
93704: PUSH
93705: LD_INT 1
93707: PLUS
93708: PPUSH
93709: CALL_OW 259
93713: PUSH
93714: LD_INT 1
93716: PLUS
93717: PPUSH
93718: CALL_OW 237
93722: GO 93624
93724: POP
93725: POP
// end ;
93726: PPOPN 3
93728: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
93729: LD_EXP 107
93733: PUSH
93734: LD_EXP 115
93738: AND
93739: IFFALSE 93759
93741: GO 93743
93743: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
93744: LD_INT 4
93746: PPUSH
93747: LD_OWVAR 2
93751: PPUSH
93752: LD_INT 0
93754: PPUSH
93755: CALL_OW 324
93759: END
// every 0 0$1 trigger StreamModeActive and sShovel do
93760: LD_EXP 107
93764: PUSH
93765: LD_EXP 144
93769: AND
93770: IFFALSE 93790
93772: GO 93774
93774: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
93775: LD_INT 19
93777: PPUSH
93778: LD_OWVAR 2
93782: PPUSH
93783: LD_INT 0
93785: PPUSH
93786: CALL_OW 324
93790: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
93791: LD_EXP 107
93795: PUSH
93796: LD_EXP 116
93800: AND
93801: IFFALSE 93903
93803: GO 93805
93805: DISABLE
93806: LD_INT 0
93808: PPUSH
93809: PPUSH
// begin enable ;
93810: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
93811: LD_ADDR_VAR 0 2
93815: PUSH
93816: LD_INT 22
93818: PUSH
93819: LD_OWVAR 2
93823: PUSH
93824: EMPTY
93825: LIST
93826: LIST
93827: PUSH
93828: LD_INT 2
93830: PUSH
93831: LD_INT 34
93833: PUSH
93834: LD_INT 11
93836: PUSH
93837: EMPTY
93838: LIST
93839: LIST
93840: PUSH
93841: LD_INT 34
93843: PUSH
93844: LD_INT 30
93846: PUSH
93847: EMPTY
93848: LIST
93849: LIST
93850: PUSH
93851: EMPTY
93852: LIST
93853: LIST
93854: LIST
93855: PUSH
93856: EMPTY
93857: LIST
93858: LIST
93859: PPUSH
93860: CALL_OW 69
93864: ST_TO_ADDR
// if not tmp then
93865: LD_VAR 0 2
93869: NOT
93870: IFFALSE 93874
// exit ;
93872: GO 93903
// for i in tmp do
93874: LD_ADDR_VAR 0 1
93878: PUSH
93879: LD_VAR 0 2
93883: PUSH
93884: FOR_IN
93885: IFFALSE 93901
// begin SetLives ( i , 0 ) ;
93887: LD_VAR 0 1
93891: PPUSH
93892: LD_INT 0
93894: PPUSH
93895: CALL_OW 234
// end ;
93899: GO 93884
93901: POP
93902: POP
// end ;
93903: PPOPN 2
93905: END
// every 0 0$1 trigger StreamModeActive and sBunker do
93906: LD_EXP 107
93910: PUSH
93911: LD_EXP 117
93915: AND
93916: IFFALSE 93936
93918: GO 93920
93920: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
93921: LD_INT 32
93923: PPUSH
93924: LD_OWVAR 2
93928: PPUSH
93929: LD_INT 0
93931: PPUSH
93932: CALL_OW 324
93936: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
93937: LD_EXP 107
93941: PUSH
93942: LD_EXP 118
93946: AND
93947: IFFALSE 94128
93949: GO 93951
93951: DISABLE
93952: LD_INT 0
93954: PPUSH
93955: PPUSH
93956: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
93957: LD_ADDR_VAR 0 2
93961: PUSH
93962: LD_INT 22
93964: PUSH
93965: LD_OWVAR 2
93969: PUSH
93970: EMPTY
93971: LIST
93972: LIST
93973: PUSH
93974: LD_INT 33
93976: PUSH
93977: LD_INT 3
93979: PUSH
93980: EMPTY
93981: LIST
93982: LIST
93983: PUSH
93984: EMPTY
93985: LIST
93986: LIST
93987: PPUSH
93988: CALL_OW 69
93992: ST_TO_ADDR
// if not tmp then
93993: LD_VAR 0 2
93997: NOT
93998: IFFALSE 94002
// exit ;
94000: GO 94128
// side := 0 ;
94002: LD_ADDR_VAR 0 3
94006: PUSH
94007: LD_INT 0
94009: ST_TO_ADDR
// for i := 1 to 8 do
94010: LD_ADDR_VAR 0 1
94014: PUSH
94015: DOUBLE
94016: LD_INT 1
94018: DEC
94019: ST_TO_ADDR
94020: LD_INT 8
94022: PUSH
94023: FOR_TO
94024: IFFALSE 94072
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
94026: LD_OWVAR 2
94030: PUSH
94031: LD_VAR 0 1
94035: NONEQUAL
94036: PUSH
94037: LD_OWVAR 2
94041: PPUSH
94042: LD_VAR 0 1
94046: PPUSH
94047: CALL_OW 81
94051: PUSH
94052: LD_INT 2
94054: EQUAL
94055: AND
94056: IFFALSE 94070
// begin side := i ;
94058: LD_ADDR_VAR 0 3
94062: PUSH
94063: LD_VAR 0 1
94067: ST_TO_ADDR
// break ;
94068: GO 94072
// end ;
94070: GO 94023
94072: POP
94073: POP
// if not side then
94074: LD_VAR 0 3
94078: NOT
94079: IFFALSE 94083
// exit ;
94081: GO 94128
// for i := 1 to tmp do
94083: LD_ADDR_VAR 0 1
94087: PUSH
94088: DOUBLE
94089: LD_INT 1
94091: DEC
94092: ST_TO_ADDR
94093: LD_VAR 0 2
94097: PUSH
94098: FOR_TO
94099: IFFALSE 94126
// if Prob ( 60 ) then
94101: LD_INT 60
94103: PPUSH
94104: CALL_OW 13
94108: IFFALSE 94124
// SetSide ( i , side ) ;
94110: LD_VAR 0 1
94114: PPUSH
94115: LD_VAR 0 3
94119: PPUSH
94120: CALL_OW 235
94124: GO 94098
94126: POP
94127: POP
// end ;
94128: PPOPN 3
94130: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
94131: LD_EXP 107
94135: PUSH
94136: LD_EXP 120
94140: AND
94141: IFFALSE 94260
94143: GO 94145
94145: DISABLE
94146: LD_INT 0
94148: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
94149: LD_ADDR_VAR 0 1
94153: PUSH
94154: LD_INT 22
94156: PUSH
94157: LD_OWVAR 2
94161: PUSH
94162: EMPTY
94163: LIST
94164: LIST
94165: PUSH
94166: LD_INT 21
94168: PUSH
94169: LD_INT 1
94171: PUSH
94172: EMPTY
94173: LIST
94174: LIST
94175: PUSH
94176: LD_INT 3
94178: PUSH
94179: LD_INT 23
94181: PUSH
94182: LD_INT 0
94184: PUSH
94185: EMPTY
94186: LIST
94187: LIST
94188: PUSH
94189: EMPTY
94190: LIST
94191: LIST
94192: PUSH
94193: EMPTY
94194: LIST
94195: LIST
94196: LIST
94197: PPUSH
94198: CALL_OW 69
94202: PUSH
94203: FOR_IN
94204: IFFALSE 94258
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
94206: LD_VAR 0 1
94210: PPUSH
94211: CALL_OW 257
94215: PUSH
94216: LD_INT 1
94218: PUSH
94219: LD_INT 2
94221: PUSH
94222: LD_INT 3
94224: PUSH
94225: LD_INT 4
94227: PUSH
94228: EMPTY
94229: LIST
94230: LIST
94231: LIST
94232: LIST
94233: IN
94234: IFFALSE 94256
// SetClass ( un , rand ( 1 , 4 ) ) ;
94236: LD_VAR 0 1
94240: PPUSH
94241: LD_INT 1
94243: PPUSH
94244: LD_INT 4
94246: PPUSH
94247: CALL_OW 12
94251: PPUSH
94252: CALL_OW 336
94256: GO 94203
94258: POP
94259: POP
// end ;
94260: PPOPN 1
94262: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
94263: LD_EXP 107
94267: PUSH
94268: LD_EXP 119
94272: AND
94273: IFFALSE 94352
94275: GO 94277
94277: DISABLE
94278: LD_INT 0
94280: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94281: LD_ADDR_VAR 0 1
94285: PUSH
94286: LD_INT 22
94288: PUSH
94289: LD_OWVAR 2
94293: PUSH
94294: EMPTY
94295: LIST
94296: LIST
94297: PUSH
94298: LD_INT 21
94300: PUSH
94301: LD_INT 3
94303: PUSH
94304: EMPTY
94305: LIST
94306: LIST
94307: PUSH
94308: EMPTY
94309: LIST
94310: LIST
94311: PPUSH
94312: CALL_OW 69
94316: ST_TO_ADDR
// if not tmp then
94317: LD_VAR 0 1
94321: NOT
94322: IFFALSE 94326
// exit ;
94324: GO 94352
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
94326: LD_VAR 0 1
94330: PUSH
94331: LD_INT 1
94333: PPUSH
94334: LD_VAR 0 1
94338: PPUSH
94339: CALL_OW 12
94343: ARRAY
94344: PPUSH
94345: LD_INT 100
94347: PPUSH
94348: CALL_OW 234
// end ;
94352: PPOPN 1
94354: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
94355: LD_EXP 107
94359: PUSH
94360: LD_EXP 121
94364: AND
94365: IFFALSE 94463
94367: GO 94369
94369: DISABLE
94370: LD_INT 0
94372: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94373: LD_ADDR_VAR 0 1
94377: PUSH
94378: LD_INT 22
94380: PUSH
94381: LD_OWVAR 2
94385: PUSH
94386: EMPTY
94387: LIST
94388: LIST
94389: PUSH
94390: LD_INT 21
94392: PUSH
94393: LD_INT 1
94395: PUSH
94396: EMPTY
94397: LIST
94398: LIST
94399: PUSH
94400: EMPTY
94401: LIST
94402: LIST
94403: PPUSH
94404: CALL_OW 69
94408: ST_TO_ADDR
// if not tmp then
94409: LD_VAR 0 1
94413: NOT
94414: IFFALSE 94418
// exit ;
94416: GO 94463
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
94418: LD_VAR 0 1
94422: PUSH
94423: LD_INT 1
94425: PPUSH
94426: LD_VAR 0 1
94430: PPUSH
94431: CALL_OW 12
94435: ARRAY
94436: PPUSH
94437: LD_INT 1
94439: PPUSH
94440: LD_INT 4
94442: PPUSH
94443: CALL_OW 12
94447: PPUSH
94448: LD_INT 3000
94450: PPUSH
94451: LD_INT 9000
94453: PPUSH
94454: CALL_OW 12
94458: PPUSH
94459: CALL_OW 492
// end ;
94463: PPOPN 1
94465: END
// every 0 0$1 trigger StreamModeActive and sDepot do
94466: LD_EXP 107
94470: PUSH
94471: LD_EXP 122
94475: AND
94476: IFFALSE 94496
94478: GO 94480
94480: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
94481: LD_INT 1
94483: PPUSH
94484: LD_OWVAR 2
94488: PPUSH
94489: LD_INT 0
94491: PPUSH
94492: CALL_OW 324
94496: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
94497: LD_EXP 107
94501: PUSH
94502: LD_EXP 123
94506: AND
94507: IFFALSE 94590
94509: GO 94511
94511: DISABLE
94512: LD_INT 0
94514: PPUSH
94515: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94516: LD_ADDR_VAR 0 2
94520: PUSH
94521: LD_INT 22
94523: PUSH
94524: LD_OWVAR 2
94528: PUSH
94529: EMPTY
94530: LIST
94531: LIST
94532: PUSH
94533: LD_INT 21
94535: PUSH
94536: LD_INT 3
94538: PUSH
94539: EMPTY
94540: LIST
94541: LIST
94542: PUSH
94543: EMPTY
94544: LIST
94545: LIST
94546: PPUSH
94547: CALL_OW 69
94551: ST_TO_ADDR
// if not tmp then
94552: LD_VAR 0 2
94556: NOT
94557: IFFALSE 94561
// exit ;
94559: GO 94590
// for i in tmp do
94561: LD_ADDR_VAR 0 1
94565: PUSH
94566: LD_VAR 0 2
94570: PUSH
94571: FOR_IN
94572: IFFALSE 94588
// SetBLevel ( i , 10 ) ;
94574: LD_VAR 0 1
94578: PPUSH
94579: LD_INT 10
94581: PPUSH
94582: CALL_OW 241
94586: GO 94571
94588: POP
94589: POP
// end ;
94590: PPOPN 2
94592: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
94593: LD_EXP 107
94597: PUSH
94598: LD_EXP 124
94602: AND
94603: IFFALSE 94714
94605: GO 94607
94607: DISABLE
94608: LD_INT 0
94610: PPUSH
94611: PPUSH
94612: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94613: LD_ADDR_VAR 0 3
94617: PUSH
94618: LD_INT 22
94620: PUSH
94621: LD_OWVAR 2
94625: PUSH
94626: EMPTY
94627: LIST
94628: LIST
94629: PUSH
94630: LD_INT 25
94632: PUSH
94633: LD_INT 1
94635: PUSH
94636: EMPTY
94637: LIST
94638: LIST
94639: PUSH
94640: EMPTY
94641: LIST
94642: LIST
94643: PPUSH
94644: CALL_OW 69
94648: ST_TO_ADDR
// if not tmp then
94649: LD_VAR 0 3
94653: NOT
94654: IFFALSE 94658
// exit ;
94656: GO 94714
// un := tmp [ rand ( 1 , tmp ) ] ;
94658: LD_ADDR_VAR 0 2
94662: PUSH
94663: LD_VAR 0 3
94667: PUSH
94668: LD_INT 1
94670: PPUSH
94671: LD_VAR 0 3
94675: PPUSH
94676: CALL_OW 12
94680: ARRAY
94681: ST_TO_ADDR
// if Crawls ( un ) then
94682: LD_VAR 0 2
94686: PPUSH
94687: CALL_OW 318
94691: IFFALSE 94702
// ComWalk ( un ) ;
94693: LD_VAR 0 2
94697: PPUSH
94698: CALL_OW 138
// SetClass ( un , class_sniper ) ;
94702: LD_VAR 0 2
94706: PPUSH
94707: LD_INT 5
94709: PPUSH
94710: CALL_OW 336
// end ;
94714: PPOPN 3
94716: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
94717: LD_EXP 107
94721: PUSH
94722: LD_EXP 125
94726: AND
94727: PUSH
94728: LD_OWVAR 67
94732: PUSH
94733: LD_INT 4
94735: LESS
94736: AND
94737: IFFALSE 94756
94739: GO 94741
94741: DISABLE
// begin Difficulty := Difficulty + 1 ;
94742: LD_ADDR_OWVAR 67
94746: PUSH
94747: LD_OWVAR 67
94751: PUSH
94752: LD_INT 1
94754: PLUS
94755: ST_TO_ADDR
// end ;
94756: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
94757: LD_EXP 107
94761: PUSH
94762: LD_EXP 126
94766: AND
94767: IFFALSE 94870
94769: GO 94771
94771: DISABLE
94772: LD_INT 0
94774: PPUSH
// begin for i := 1 to 5 do
94775: LD_ADDR_VAR 0 1
94779: PUSH
94780: DOUBLE
94781: LD_INT 1
94783: DEC
94784: ST_TO_ADDR
94785: LD_INT 5
94787: PUSH
94788: FOR_TO
94789: IFFALSE 94868
// begin uc_nation := nation_nature ;
94791: LD_ADDR_OWVAR 21
94795: PUSH
94796: LD_INT 0
94798: ST_TO_ADDR
// uc_side := 0 ;
94799: LD_ADDR_OWVAR 20
94803: PUSH
94804: LD_INT 0
94806: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94807: LD_ADDR_OWVAR 29
94811: PUSH
94812: LD_INT 12
94814: PUSH
94815: LD_INT 12
94817: PUSH
94818: EMPTY
94819: LIST
94820: LIST
94821: ST_TO_ADDR
// hc_agressivity := 20 ;
94822: LD_ADDR_OWVAR 35
94826: PUSH
94827: LD_INT 20
94829: ST_TO_ADDR
// hc_class := class_tiger ;
94830: LD_ADDR_OWVAR 28
94834: PUSH
94835: LD_INT 14
94837: ST_TO_ADDR
// hc_gallery :=  ;
94838: LD_ADDR_OWVAR 33
94842: PUSH
94843: LD_STRING 
94845: ST_TO_ADDR
// hc_name :=  ;
94846: LD_ADDR_OWVAR 26
94850: PUSH
94851: LD_STRING 
94853: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
94854: CALL_OW 44
94858: PPUSH
94859: LD_INT 0
94861: PPUSH
94862: CALL_OW 51
// end ;
94866: GO 94788
94868: POP
94869: POP
// end ;
94870: PPOPN 1
94872: END
// every 0 0$1 trigger StreamModeActive and sBomb do
94873: LD_EXP 107
94877: PUSH
94878: LD_EXP 127
94882: AND
94883: IFFALSE 94892
94885: GO 94887
94887: DISABLE
// StreamSibBomb ;
94888: CALL 94893 0 0
94892: END
// export function StreamSibBomb ; var i , x , y ; begin
94893: LD_INT 0
94895: PPUSH
94896: PPUSH
94897: PPUSH
94898: PPUSH
// result := false ;
94899: LD_ADDR_VAR 0 1
94903: PUSH
94904: LD_INT 0
94906: ST_TO_ADDR
// for i := 1 to 16 do
94907: LD_ADDR_VAR 0 2
94911: PUSH
94912: DOUBLE
94913: LD_INT 1
94915: DEC
94916: ST_TO_ADDR
94917: LD_INT 16
94919: PUSH
94920: FOR_TO
94921: IFFALSE 95120
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94923: LD_ADDR_VAR 0 3
94927: PUSH
94928: LD_INT 10
94930: PUSH
94931: LD_INT 20
94933: PUSH
94934: LD_INT 30
94936: PUSH
94937: LD_INT 40
94939: PUSH
94940: LD_INT 50
94942: PUSH
94943: LD_INT 60
94945: PUSH
94946: LD_INT 70
94948: PUSH
94949: LD_INT 80
94951: PUSH
94952: LD_INT 90
94954: PUSH
94955: LD_INT 100
94957: PUSH
94958: LD_INT 110
94960: PUSH
94961: LD_INT 120
94963: PUSH
94964: LD_INT 130
94966: PUSH
94967: LD_INT 140
94969: PUSH
94970: LD_INT 150
94972: PUSH
94973: EMPTY
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: LIST
94988: LIST
94989: PUSH
94990: LD_INT 1
94992: PPUSH
94993: LD_INT 15
94995: PPUSH
94996: CALL_OW 12
95000: ARRAY
95001: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95002: LD_ADDR_VAR 0 4
95006: PUSH
95007: LD_INT 10
95009: PUSH
95010: LD_INT 20
95012: PUSH
95013: LD_INT 30
95015: PUSH
95016: LD_INT 40
95018: PUSH
95019: LD_INT 50
95021: PUSH
95022: LD_INT 60
95024: PUSH
95025: LD_INT 70
95027: PUSH
95028: LD_INT 80
95030: PUSH
95031: LD_INT 90
95033: PUSH
95034: LD_INT 100
95036: PUSH
95037: LD_INT 110
95039: PUSH
95040: LD_INT 120
95042: PUSH
95043: LD_INT 130
95045: PUSH
95046: LD_INT 140
95048: PUSH
95049: LD_INT 150
95051: PUSH
95052: EMPTY
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: LIST
95059: LIST
95060: LIST
95061: LIST
95062: LIST
95063: LIST
95064: LIST
95065: LIST
95066: LIST
95067: LIST
95068: PUSH
95069: LD_INT 1
95071: PPUSH
95072: LD_INT 15
95074: PPUSH
95075: CALL_OW 12
95079: ARRAY
95080: ST_TO_ADDR
// if ValidHex ( x , y ) then
95081: LD_VAR 0 3
95085: PPUSH
95086: LD_VAR 0 4
95090: PPUSH
95091: CALL_OW 488
95095: IFFALSE 95118
// begin result := [ x , y ] ;
95097: LD_ADDR_VAR 0 1
95101: PUSH
95102: LD_VAR 0 3
95106: PUSH
95107: LD_VAR 0 4
95111: PUSH
95112: EMPTY
95113: LIST
95114: LIST
95115: ST_TO_ADDR
// break ;
95116: GO 95120
// end ; end ;
95118: GO 94920
95120: POP
95121: POP
// if result then
95122: LD_VAR 0 1
95126: IFFALSE 95186
// begin ToLua ( playSibBomb() ) ;
95128: LD_STRING playSibBomb()
95130: PPUSH
95131: CALL_OW 559
// wait ( 0 0$14 ) ;
95135: LD_INT 490
95137: PPUSH
95138: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
95142: LD_VAR 0 1
95146: PUSH
95147: LD_INT 1
95149: ARRAY
95150: PPUSH
95151: LD_VAR 0 1
95155: PUSH
95156: LD_INT 2
95158: ARRAY
95159: PPUSH
95160: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
95164: LD_VAR 0 1
95168: PUSH
95169: LD_INT 1
95171: ARRAY
95172: PPUSH
95173: LD_VAR 0 1
95177: PUSH
95178: LD_INT 2
95180: ARRAY
95181: PPUSH
95182: CALL_OW 429
// end ; end ;
95186: LD_VAR 0 1
95190: RET
// every 0 0$1 trigger StreamModeActive and sReset do
95191: LD_EXP 107
95195: PUSH
95196: LD_EXP 129
95200: AND
95201: IFFALSE 95213
95203: GO 95205
95205: DISABLE
// YouLost (  ) ;
95206: LD_STRING 
95208: PPUSH
95209: CALL_OW 104
95213: END
// every 0 0$1 trigger StreamModeActive and sFog do
95214: LD_EXP 107
95218: PUSH
95219: LD_EXP 128
95223: AND
95224: IFFALSE 95238
95226: GO 95228
95228: DISABLE
// FogOff ( your_side ) ;
95229: LD_OWVAR 2
95233: PPUSH
95234: CALL_OW 344
95238: END
// every 0 0$1 trigger StreamModeActive and sSun do
95239: LD_EXP 107
95243: PUSH
95244: LD_EXP 130
95248: AND
95249: IFFALSE 95277
95251: GO 95253
95253: DISABLE
// begin solar_recharge_percent := 0 ;
95254: LD_ADDR_OWVAR 79
95258: PUSH
95259: LD_INT 0
95261: ST_TO_ADDR
// wait ( 5 5$00 ) ;
95262: LD_INT 10500
95264: PPUSH
95265: CALL_OW 67
// solar_recharge_percent := 100 ;
95269: LD_ADDR_OWVAR 79
95273: PUSH
95274: LD_INT 100
95276: ST_TO_ADDR
// end ;
95277: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
95278: LD_EXP 107
95282: PUSH
95283: LD_EXP 131
95287: AND
95288: IFFALSE 95527
95290: GO 95292
95292: DISABLE
95293: LD_INT 0
95295: PPUSH
95296: PPUSH
95297: PPUSH
// begin tmp := [ ] ;
95298: LD_ADDR_VAR 0 3
95302: PUSH
95303: EMPTY
95304: ST_TO_ADDR
// for i := 1 to 6 do
95305: LD_ADDR_VAR 0 1
95309: PUSH
95310: DOUBLE
95311: LD_INT 1
95313: DEC
95314: ST_TO_ADDR
95315: LD_INT 6
95317: PUSH
95318: FOR_TO
95319: IFFALSE 95424
// begin uc_nation := nation_nature ;
95321: LD_ADDR_OWVAR 21
95325: PUSH
95326: LD_INT 0
95328: ST_TO_ADDR
// uc_side := 0 ;
95329: LD_ADDR_OWVAR 20
95333: PUSH
95334: LD_INT 0
95336: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95337: LD_ADDR_OWVAR 29
95341: PUSH
95342: LD_INT 12
95344: PUSH
95345: LD_INT 12
95347: PUSH
95348: EMPTY
95349: LIST
95350: LIST
95351: ST_TO_ADDR
// hc_agressivity := 20 ;
95352: LD_ADDR_OWVAR 35
95356: PUSH
95357: LD_INT 20
95359: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
95360: LD_ADDR_OWVAR 28
95364: PUSH
95365: LD_INT 17
95367: ST_TO_ADDR
// hc_gallery :=  ;
95368: LD_ADDR_OWVAR 33
95372: PUSH
95373: LD_STRING 
95375: ST_TO_ADDR
// hc_name :=  ;
95376: LD_ADDR_OWVAR 26
95380: PUSH
95381: LD_STRING 
95383: ST_TO_ADDR
// un := CreateHuman ;
95384: LD_ADDR_VAR 0 2
95388: PUSH
95389: CALL_OW 44
95393: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
95394: LD_VAR 0 2
95398: PPUSH
95399: LD_INT 1
95401: PPUSH
95402: CALL_OW 51
// tmp := tmp ^ un ;
95406: LD_ADDR_VAR 0 3
95410: PUSH
95411: LD_VAR 0 3
95415: PUSH
95416: LD_VAR 0 2
95420: ADD
95421: ST_TO_ADDR
// end ;
95422: GO 95318
95424: POP
95425: POP
// repeat wait ( 0 0$1 ) ;
95426: LD_INT 35
95428: PPUSH
95429: CALL_OW 67
// for un in tmp do
95433: LD_ADDR_VAR 0 2
95437: PUSH
95438: LD_VAR 0 3
95442: PUSH
95443: FOR_IN
95444: IFFALSE 95518
// begin if IsDead ( un ) then
95446: LD_VAR 0 2
95450: PPUSH
95451: CALL_OW 301
95455: IFFALSE 95475
// begin tmp := tmp diff un ;
95457: LD_ADDR_VAR 0 3
95461: PUSH
95462: LD_VAR 0 3
95466: PUSH
95467: LD_VAR 0 2
95471: DIFF
95472: ST_TO_ADDR
// continue ;
95473: GO 95443
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
95475: LD_VAR 0 2
95479: PPUSH
95480: LD_INT 3
95482: PUSH
95483: LD_INT 22
95485: PUSH
95486: LD_INT 0
95488: PUSH
95489: EMPTY
95490: LIST
95491: LIST
95492: PUSH
95493: EMPTY
95494: LIST
95495: LIST
95496: PPUSH
95497: CALL_OW 69
95501: PPUSH
95502: LD_VAR 0 2
95506: PPUSH
95507: CALL_OW 74
95511: PPUSH
95512: CALL_OW 115
// end ;
95516: GO 95443
95518: POP
95519: POP
// until not tmp ;
95520: LD_VAR 0 3
95524: NOT
95525: IFFALSE 95426
// end ;
95527: PPOPN 3
95529: END
// every 0 0$1 trigger StreamModeActive and sTroll do
95530: LD_EXP 107
95534: PUSH
95535: LD_EXP 132
95539: AND
95540: IFFALSE 95594
95542: GO 95544
95544: DISABLE
// begin ToLua ( displayTroll(); ) ;
95545: LD_STRING displayTroll();
95547: PPUSH
95548: CALL_OW 559
// wait ( 3 3$00 ) ;
95552: LD_INT 6300
95554: PPUSH
95555: CALL_OW 67
// ToLua ( hideTroll(); ) ;
95559: LD_STRING hideTroll();
95561: PPUSH
95562: CALL_OW 559
// wait ( 1 1$00 ) ;
95566: LD_INT 2100
95568: PPUSH
95569: CALL_OW 67
// ToLua ( displayTroll(); ) ;
95573: LD_STRING displayTroll();
95575: PPUSH
95576: CALL_OW 559
// wait ( 1 1$00 ) ;
95580: LD_INT 2100
95582: PPUSH
95583: CALL_OW 67
// ToLua ( hideTroll(); ) ;
95587: LD_STRING hideTroll();
95589: PPUSH
95590: CALL_OW 559
// end ;
95594: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
95595: LD_EXP 107
95599: PUSH
95600: LD_EXP 133
95604: AND
95605: IFFALSE 95668
95607: GO 95609
95609: DISABLE
95610: LD_INT 0
95612: PPUSH
// begin p := 0 ;
95613: LD_ADDR_VAR 0 1
95617: PUSH
95618: LD_INT 0
95620: ST_TO_ADDR
// repeat game_speed := 1 ;
95621: LD_ADDR_OWVAR 65
95625: PUSH
95626: LD_INT 1
95628: ST_TO_ADDR
// wait ( 0 0$1 ) ;
95629: LD_INT 35
95631: PPUSH
95632: CALL_OW 67
// p := p + 1 ;
95636: LD_ADDR_VAR 0 1
95640: PUSH
95641: LD_VAR 0 1
95645: PUSH
95646: LD_INT 1
95648: PLUS
95649: ST_TO_ADDR
// until p >= 60 ;
95650: LD_VAR 0 1
95654: PUSH
95655: LD_INT 60
95657: GREATEREQUAL
95658: IFFALSE 95621
// game_speed := 4 ;
95660: LD_ADDR_OWVAR 65
95664: PUSH
95665: LD_INT 4
95667: ST_TO_ADDR
// end ;
95668: PPOPN 1
95670: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
95671: LD_EXP 107
95675: PUSH
95676: LD_EXP 134
95680: AND
95681: IFFALSE 95827
95683: GO 95685
95685: DISABLE
95686: LD_INT 0
95688: PPUSH
95689: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95690: LD_ADDR_VAR 0 1
95694: PUSH
95695: LD_INT 22
95697: PUSH
95698: LD_OWVAR 2
95702: PUSH
95703: EMPTY
95704: LIST
95705: LIST
95706: PUSH
95707: LD_INT 2
95709: PUSH
95710: LD_INT 30
95712: PUSH
95713: LD_INT 0
95715: PUSH
95716: EMPTY
95717: LIST
95718: LIST
95719: PUSH
95720: LD_INT 30
95722: PUSH
95723: LD_INT 1
95725: PUSH
95726: EMPTY
95727: LIST
95728: LIST
95729: PUSH
95730: EMPTY
95731: LIST
95732: LIST
95733: LIST
95734: PUSH
95735: EMPTY
95736: LIST
95737: LIST
95738: PPUSH
95739: CALL_OW 69
95743: ST_TO_ADDR
// if not depot then
95744: LD_VAR 0 1
95748: NOT
95749: IFFALSE 95753
// exit ;
95751: GO 95827
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
95753: LD_ADDR_VAR 0 2
95757: PUSH
95758: LD_VAR 0 1
95762: PUSH
95763: LD_INT 1
95765: PPUSH
95766: LD_VAR 0 1
95770: PPUSH
95771: CALL_OW 12
95775: ARRAY
95776: PPUSH
95777: CALL_OW 274
95781: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
95782: LD_VAR 0 2
95786: PPUSH
95787: LD_INT 1
95789: PPUSH
95790: LD_INT 0
95792: PPUSH
95793: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
95797: LD_VAR 0 2
95801: PPUSH
95802: LD_INT 2
95804: PPUSH
95805: LD_INT 0
95807: PPUSH
95808: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
95812: LD_VAR 0 2
95816: PPUSH
95817: LD_INT 3
95819: PPUSH
95820: LD_INT 0
95822: PPUSH
95823: CALL_OW 277
// end ;
95827: PPOPN 2
95829: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
95830: LD_EXP 107
95834: PUSH
95835: LD_EXP 135
95839: AND
95840: IFFALSE 95937
95842: GO 95844
95844: DISABLE
95845: LD_INT 0
95847: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95848: LD_ADDR_VAR 0 1
95852: PUSH
95853: LD_INT 22
95855: PUSH
95856: LD_OWVAR 2
95860: PUSH
95861: EMPTY
95862: LIST
95863: LIST
95864: PUSH
95865: LD_INT 21
95867: PUSH
95868: LD_INT 1
95870: PUSH
95871: EMPTY
95872: LIST
95873: LIST
95874: PUSH
95875: LD_INT 3
95877: PUSH
95878: LD_INT 23
95880: PUSH
95881: LD_INT 0
95883: PUSH
95884: EMPTY
95885: LIST
95886: LIST
95887: PUSH
95888: EMPTY
95889: LIST
95890: LIST
95891: PUSH
95892: EMPTY
95893: LIST
95894: LIST
95895: LIST
95896: PPUSH
95897: CALL_OW 69
95901: ST_TO_ADDR
// if not tmp then
95902: LD_VAR 0 1
95906: NOT
95907: IFFALSE 95911
// exit ;
95909: GO 95937
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
95911: LD_VAR 0 1
95915: PUSH
95916: LD_INT 1
95918: PPUSH
95919: LD_VAR 0 1
95923: PPUSH
95924: CALL_OW 12
95928: ARRAY
95929: PPUSH
95930: LD_INT 200
95932: PPUSH
95933: CALL_OW 234
// end ;
95937: PPOPN 1
95939: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
95940: LD_EXP 107
95944: PUSH
95945: LD_EXP 136
95949: AND
95950: IFFALSE 96029
95952: GO 95954
95954: DISABLE
95955: LD_INT 0
95957: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
95958: LD_ADDR_VAR 0 1
95962: PUSH
95963: LD_INT 22
95965: PUSH
95966: LD_OWVAR 2
95970: PUSH
95971: EMPTY
95972: LIST
95973: LIST
95974: PUSH
95975: LD_INT 21
95977: PUSH
95978: LD_INT 2
95980: PUSH
95981: EMPTY
95982: LIST
95983: LIST
95984: PUSH
95985: EMPTY
95986: LIST
95987: LIST
95988: PPUSH
95989: CALL_OW 69
95993: ST_TO_ADDR
// if not tmp then
95994: LD_VAR 0 1
95998: NOT
95999: IFFALSE 96003
// exit ;
96001: GO 96029
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
96003: LD_VAR 0 1
96007: PUSH
96008: LD_INT 1
96010: PPUSH
96011: LD_VAR 0 1
96015: PPUSH
96016: CALL_OW 12
96020: ARRAY
96021: PPUSH
96022: LD_INT 60
96024: PPUSH
96025: CALL_OW 234
// end ;
96029: PPOPN 1
96031: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
96032: LD_EXP 107
96036: PUSH
96037: LD_EXP 137
96041: AND
96042: IFFALSE 96141
96044: GO 96046
96046: DISABLE
96047: LD_INT 0
96049: PPUSH
96050: PPUSH
// begin enable ;
96051: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
96052: LD_ADDR_VAR 0 1
96056: PUSH
96057: LD_INT 22
96059: PUSH
96060: LD_OWVAR 2
96064: PUSH
96065: EMPTY
96066: LIST
96067: LIST
96068: PUSH
96069: LD_INT 61
96071: PUSH
96072: EMPTY
96073: LIST
96074: PUSH
96075: LD_INT 33
96077: PUSH
96078: LD_INT 2
96080: PUSH
96081: EMPTY
96082: LIST
96083: LIST
96084: PUSH
96085: EMPTY
96086: LIST
96087: LIST
96088: LIST
96089: PPUSH
96090: CALL_OW 69
96094: ST_TO_ADDR
// if not tmp then
96095: LD_VAR 0 1
96099: NOT
96100: IFFALSE 96104
// exit ;
96102: GO 96141
// for i in tmp do
96104: LD_ADDR_VAR 0 2
96108: PUSH
96109: LD_VAR 0 1
96113: PUSH
96114: FOR_IN
96115: IFFALSE 96139
// if IsControledBy ( i ) then
96117: LD_VAR 0 2
96121: PPUSH
96122: CALL_OW 312
96126: IFFALSE 96137
// ComUnlink ( i ) ;
96128: LD_VAR 0 2
96132: PPUSH
96133: CALL_OW 136
96137: GO 96114
96139: POP
96140: POP
// end ;
96141: PPOPN 2
96143: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
96144: LD_EXP 107
96148: PUSH
96149: LD_EXP 138
96153: AND
96154: IFFALSE 96294
96156: GO 96158
96158: DISABLE
96159: LD_INT 0
96161: PPUSH
96162: PPUSH
// begin ToLua ( displayPowell(); ) ;
96163: LD_STRING displayPowell();
96165: PPUSH
96166: CALL_OW 559
// uc_side := 0 ;
96170: LD_ADDR_OWVAR 20
96174: PUSH
96175: LD_INT 0
96177: ST_TO_ADDR
// uc_nation := 2 ;
96178: LD_ADDR_OWVAR 21
96182: PUSH
96183: LD_INT 2
96185: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
96186: LD_ADDR_OWVAR 37
96190: PUSH
96191: LD_INT 14
96193: ST_TO_ADDR
// vc_engine := engine_siberite ;
96194: LD_ADDR_OWVAR 39
96198: PUSH
96199: LD_INT 3
96201: ST_TO_ADDR
// vc_control := control_apeman ;
96202: LD_ADDR_OWVAR 38
96206: PUSH
96207: LD_INT 5
96209: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
96210: LD_ADDR_OWVAR 40
96214: PUSH
96215: LD_INT 29
96217: ST_TO_ADDR
// un := CreateVehicle ;
96218: LD_ADDR_VAR 0 2
96222: PUSH
96223: CALL_OW 45
96227: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96228: LD_VAR 0 2
96232: PPUSH
96233: LD_INT 1
96235: PPUSH
96236: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96240: LD_INT 35
96242: PPUSH
96243: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96247: LD_VAR 0 2
96251: PPUSH
96252: LD_INT 22
96254: PUSH
96255: LD_OWVAR 2
96259: PUSH
96260: EMPTY
96261: LIST
96262: LIST
96263: PPUSH
96264: CALL_OW 69
96268: PPUSH
96269: LD_VAR 0 2
96273: PPUSH
96274: CALL_OW 74
96278: PPUSH
96279: CALL_OW 115
// until IsDead ( un ) ;
96283: LD_VAR 0 2
96287: PPUSH
96288: CALL_OW 301
96292: IFFALSE 96240
// end ;
96294: PPOPN 2
96296: END
// every 0 0$1 trigger StreamModeActive and sStu do
96297: LD_EXP 107
96301: PUSH
96302: LD_EXP 146
96306: AND
96307: IFFALSE 96323
96309: GO 96311
96311: DISABLE
// begin ToLua ( displayStucuk(); ) ;
96312: LD_STRING displayStucuk();
96314: PPUSH
96315: CALL_OW 559
// ResetFog ;
96319: CALL_OW 335
// end ;
96323: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
96324: LD_EXP 107
96328: PUSH
96329: LD_EXP 139
96333: AND
96334: IFFALSE 96475
96336: GO 96338
96338: DISABLE
96339: LD_INT 0
96341: PPUSH
96342: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96343: LD_ADDR_VAR 0 2
96347: PUSH
96348: LD_INT 22
96350: PUSH
96351: LD_OWVAR 2
96355: PUSH
96356: EMPTY
96357: LIST
96358: LIST
96359: PUSH
96360: LD_INT 21
96362: PUSH
96363: LD_INT 1
96365: PUSH
96366: EMPTY
96367: LIST
96368: LIST
96369: PUSH
96370: EMPTY
96371: LIST
96372: LIST
96373: PPUSH
96374: CALL_OW 69
96378: ST_TO_ADDR
// if not tmp then
96379: LD_VAR 0 2
96383: NOT
96384: IFFALSE 96388
// exit ;
96386: GO 96475
// un := tmp [ rand ( 1 , tmp ) ] ;
96388: LD_ADDR_VAR 0 1
96392: PUSH
96393: LD_VAR 0 2
96397: PUSH
96398: LD_INT 1
96400: PPUSH
96401: LD_VAR 0 2
96405: PPUSH
96406: CALL_OW 12
96410: ARRAY
96411: ST_TO_ADDR
// SetSide ( un , 0 ) ;
96412: LD_VAR 0 1
96416: PPUSH
96417: LD_INT 0
96419: PPUSH
96420: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
96424: LD_VAR 0 1
96428: PPUSH
96429: LD_OWVAR 3
96433: PUSH
96434: LD_VAR 0 1
96438: DIFF
96439: PPUSH
96440: LD_VAR 0 1
96444: PPUSH
96445: CALL_OW 74
96449: PPUSH
96450: CALL_OW 115
// wait ( 0 0$20 ) ;
96454: LD_INT 700
96456: PPUSH
96457: CALL_OW 67
// SetSide ( un , your_side ) ;
96461: LD_VAR 0 1
96465: PPUSH
96466: LD_OWVAR 2
96470: PPUSH
96471: CALL_OW 235
// end ;
96475: PPOPN 2
96477: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
96478: LD_EXP 107
96482: PUSH
96483: LD_EXP 140
96487: AND
96488: IFFALSE 96594
96490: GO 96492
96492: DISABLE
96493: LD_INT 0
96495: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96496: LD_ADDR_VAR 0 1
96500: PUSH
96501: LD_INT 22
96503: PUSH
96504: LD_OWVAR 2
96508: PUSH
96509: EMPTY
96510: LIST
96511: LIST
96512: PUSH
96513: LD_INT 2
96515: PUSH
96516: LD_INT 30
96518: PUSH
96519: LD_INT 0
96521: PUSH
96522: EMPTY
96523: LIST
96524: LIST
96525: PUSH
96526: LD_INT 30
96528: PUSH
96529: LD_INT 1
96531: PUSH
96532: EMPTY
96533: LIST
96534: LIST
96535: PUSH
96536: EMPTY
96537: LIST
96538: LIST
96539: LIST
96540: PUSH
96541: EMPTY
96542: LIST
96543: LIST
96544: PPUSH
96545: CALL_OW 69
96549: ST_TO_ADDR
// if not depot then
96550: LD_VAR 0 1
96554: NOT
96555: IFFALSE 96559
// exit ;
96557: GO 96594
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
96559: LD_VAR 0 1
96563: PUSH
96564: LD_INT 1
96566: ARRAY
96567: PPUSH
96568: CALL_OW 250
96572: PPUSH
96573: LD_VAR 0 1
96577: PUSH
96578: LD_INT 1
96580: ARRAY
96581: PPUSH
96582: CALL_OW 251
96586: PPUSH
96587: LD_INT 70
96589: PPUSH
96590: CALL_OW 495
// end ;
96594: PPOPN 1
96596: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
96597: LD_EXP 107
96601: PUSH
96602: LD_EXP 141
96606: AND
96607: IFFALSE 96818
96609: GO 96611
96611: DISABLE
96612: LD_INT 0
96614: PPUSH
96615: PPUSH
96616: PPUSH
96617: PPUSH
96618: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96619: LD_ADDR_VAR 0 5
96623: PUSH
96624: LD_INT 22
96626: PUSH
96627: LD_OWVAR 2
96631: PUSH
96632: EMPTY
96633: LIST
96634: LIST
96635: PUSH
96636: LD_INT 21
96638: PUSH
96639: LD_INT 1
96641: PUSH
96642: EMPTY
96643: LIST
96644: LIST
96645: PUSH
96646: EMPTY
96647: LIST
96648: LIST
96649: PPUSH
96650: CALL_OW 69
96654: ST_TO_ADDR
// if not tmp then
96655: LD_VAR 0 5
96659: NOT
96660: IFFALSE 96664
// exit ;
96662: GO 96818
// for i in tmp do
96664: LD_ADDR_VAR 0 1
96668: PUSH
96669: LD_VAR 0 5
96673: PUSH
96674: FOR_IN
96675: IFFALSE 96816
// begin d := rand ( 0 , 5 ) ;
96677: LD_ADDR_VAR 0 4
96681: PUSH
96682: LD_INT 0
96684: PPUSH
96685: LD_INT 5
96687: PPUSH
96688: CALL_OW 12
96692: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
96693: LD_ADDR_VAR 0 2
96697: PUSH
96698: LD_VAR 0 1
96702: PPUSH
96703: CALL_OW 250
96707: PPUSH
96708: LD_VAR 0 4
96712: PPUSH
96713: LD_INT 3
96715: PPUSH
96716: LD_INT 12
96718: PPUSH
96719: CALL_OW 12
96723: PPUSH
96724: CALL_OW 272
96728: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
96729: LD_ADDR_VAR 0 3
96733: PUSH
96734: LD_VAR 0 1
96738: PPUSH
96739: CALL_OW 251
96743: PPUSH
96744: LD_VAR 0 4
96748: PPUSH
96749: LD_INT 3
96751: PPUSH
96752: LD_INT 12
96754: PPUSH
96755: CALL_OW 12
96759: PPUSH
96760: CALL_OW 273
96764: ST_TO_ADDR
// if ValidHex ( x , y ) then
96765: LD_VAR 0 2
96769: PPUSH
96770: LD_VAR 0 3
96774: PPUSH
96775: CALL_OW 488
96779: IFFALSE 96814
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
96781: LD_VAR 0 1
96785: PPUSH
96786: LD_VAR 0 2
96790: PPUSH
96791: LD_VAR 0 3
96795: PPUSH
96796: LD_INT 3
96798: PPUSH
96799: LD_INT 6
96801: PPUSH
96802: CALL_OW 12
96806: PPUSH
96807: LD_INT 1
96809: PPUSH
96810: CALL_OW 483
// end ;
96814: GO 96674
96816: POP
96817: POP
// end ;
96818: PPOPN 5
96820: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
96821: LD_EXP 107
96825: PUSH
96826: LD_EXP 142
96830: AND
96831: IFFALSE 96925
96833: GO 96835
96835: DISABLE
96836: LD_INT 0
96838: PPUSH
96839: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
96840: LD_ADDR_VAR 0 2
96844: PUSH
96845: LD_INT 22
96847: PUSH
96848: LD_OWVAR 2
96852: PUSH
96853: EMPTY
96854: LIST
96855: LIST
96856: PUSH
96857: LD_INT 32
96859: PUSH
96860: LD_INT 1
96862: PUSH
96863: EMPTY
96864: LIST
96865: LIST
96866: PUSH
96867: LD_INT 21
96869: PUSH
96870: LD_INT 2
96872: PUSH
96873: EMPTY
96874: LIST
96875: LIST
96876: PUSH
96877: EMPTY
96878: LIST
96879: LIST
96880: LIST
96881: PPUSH
96882: CALL_OW 69
96886: ST_TO_ADDR
// if not tmp then
96887: LD_VAR 0 2
96891: NOT
96892: IFFALSE 96896
// exit ;
96894: GO 96925
// for i in tmp do
96896: LD_ADDR_VAR 0 1
96900: PUSH
96901: LD_VAR 0 2
96905: PUSH
96906: FOR_IN
96907: IFFALSE 96923
// SetFuel ( i , 0 ) ;
96909: LD_VAR 0 1
96913: PPUSH
96914: LD_INT 0
96916: PPUSH
96917: CALL_OW 240
96921: GO 96906
96923: POP
96924: POP
// end ;
96925: PPOPN 2
96927: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
96928: LD_EXP 107
96932: PUSH
96933: LD_EXP 143
96937: AND
96938: IFFALSE 97004
96940: GO 96942
96942: DISABLE
96943: LD_INT 0
96945: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96946: LD_ADDR_VAR 0 1
96950: PUSH
96951: LD_INT 22
96953: PUSH
96954: LD_OWVAR 2
96958: PUSH
96959: EMPTY
96960: LIST
96961: LIST
96962: PUSH
96963: LD_INT 30
96965: PUSH
96966: LD_INT 29
96968: PUSH
96969: EMPTY
96970: LIST
96971: LIST
96972: PUSH
96973: EMPTY
96974: LIST
96975: LIST
96976: PPUSH
96977: CALL_OW 69
96981: ST_TO_ADDR
// if not tmp then
96982: LD_VAR 0 1
96986: NOT
96987: IFFALSE 96991
// exit ;
96989: GO 97004
// DestroyUnit ( tmp [ 1 ] ) ;
96991: LD_VAR 0 1
96995: PUSH
96996: LD_INT 1
96998: ARRAY
96999: PPUSH
97000: CALL_OW 65
// end ;
97004: PPOPN 1
97006: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
97007: LD_EXP 107
97011: PUSH
97012: LD_EXP 145
97016: AND
97017: IFFALSE 97146
97019: GO 97021
97021: DISABLE
97022: LD_INT 0
97024: PPUSH
// begin uc_side := 0 ;
97025: LD_ADDR_OWVAR 20
97029: PUSH
97030: LD_INT 0
97032: ST_TO_ADDR
// uc_nation := nation_arabian ;
97033: LD_ADDR_OWVAR 21
97037: PUSH
97038: LD_INT 2
97040: ST_TO_ADDR
// hc_gallery :=  ;
97041: LD_ADDR_OWVAR 33
97045: PUSH
97046: LD_STRING 
97048: ST_TO_ADDR
// hc_name :=  ;
97049: LD_ADDR_OWVAR 26
97053: PUSH
97054: LD_STRING 
97056: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
97057: LD_INT 1
97059: PPUSH
97060: LD_INT 11
97062: PPUSH
97063: LD_INT 10
97065: PPUSH
97066: CALL_OW 380
// un := CreateHuman ;
97070: LD_ADDR_VAR 0 1
97074: PUSH
97075: CALL_OW 44
97079: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97080: LD_VAR 0 1
97084: PPUSH
97085: LD_INT 1
97087: PPUSH
97088: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97092: LD_INT 35
97094: PPUSH
97095: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97099: LD_VAR 0 1
97103: PPUSH
97104: LD_INT 22
97106: PUSH
97107: LD_OWVAR 2
97111: PUSH
97112: EMPTY
97113: LIST
97114: LIST
97115: PPUSH
97116: CALL_OW 69
97120: PPUSH
97121: LD_VAR 0 1
97125: PPUSH
97126: CALL_OW 74
97130: PPUSH
97131: CALL_OW 115
// until IsDead ( un ) ;
97135: LD_VAR 0 1
97139: PPUSH
97140: CALL_OW 301
97144: IFFALSE 97092
// end ;
97146: PPOPN 1
97148: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
97149: LD_EXP 107
97153: PUSH
97154: LD_EXP 147
97158: AND
97159: IFFALSE 97171
97161: GO 97163
97163: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
97164: LD_STRING earthquake(getX(game), 0, 32)
97166: PPUSH
97167: CALL_OW 559
97171: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
97172: LD_EXP 107
97176: PUSH
97177: LD_EXP 148
97181: AND
97182: IFFALSE 97273
97184: GO 97186
97186: DISABLE
97187: LD_INT 0
97189: PPUSH
// begin enable ;
97190: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
97191: LD_ADDR_VAR 0 1
97195: PUSH
97196: LD_INT 22
97198: PUSH
97199: LD_OWVAR 2
97203: PUSH
97204: EMPTY
97205: LIST
97206: LIST
97207: PUSH
97208: LD_INT 21
97210: PUSH
97211: LD_INT 2
97213: PUSH
97214: EMPTY
97215: LIST
97216: LIST
97217: PUSH
97218: LD_INT 33
97220: PUSH
97221: LD_INT 3
97223: PUSH
97224: EMPTY
97225: LIST
97226: LIST
97227: PUSH
97228: EMPTY
97229: LIST
97230: LIST
97231: LIST
97232: PPUSH
97233: CALL_OW 69
97237: ST_TO_ADDR
// if not tmp then
97238: LD_VAR 0 1
97242: NOT
97243: IFFALSE 97247
// exit ;
97245: GO 97273
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97247: LD_VAR 0 1
97251: PUSH
97252: LD_INT 1
97254: PPUSH
97255: LD_VAR 0 1
97259: PPUSH
97260: CALL_OW 12
97264: ARRAY
97265: PPUSH
97266: LD_INT 1
97268: PPUSH
97269: CALL_OW 234
// end ;
97273: PPOPN 1
97275: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
97276: LD_EXP 107
97280: PUSH
97281: LD_EXP 149
97285: AND
97286: IFFALSE 97427
97288: GO 97290
97290: DISABLE
97291: LD_INT 0
97293: PPUSH
97294: PPUSH
97295: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97296: LD_ADDR_VAR 0 3
97300: PUSH
97301: LD_INT 22
97303: PUSH
97304: LD_OWVAR 2
97308: PUSH
97309: EMPTY
97310: LIST
97311: LIST
97312: PUSH
97313: LD_INT 25
97315: PUSH
97316: LD_INT 1
97318: PUSH
97319: EMPTY
97320: LIST
97321: LIST
97322: PUSH
97323: EMPTY
97324: LIST
97325: LIST
97326: PPUSH
97327: CALL_OW 69
97331: ST_TO_ADDR
// if not tmp then
97332: LD_VAR 0 3
97336: NOT
97337: IFFALSE 97341
// exit ;
97339: GO 97427
// un := tmp [ rand ( 1 , tmp ) ] ;
97341: LD_ADDR_VAR 0 2
97345: PUSH
97346: LD_VAR 0 3
97350: PUSH
97351: LD_INT 1
97353: PPUSH
97354: LD_VAR 0 3
97358: PPUSH
97359: CALL_OW 12
97363: ARRAY
97364: ST_TO_ADDR
// if Crawls ( un ) then
97365: LD_VAR 0 2
97369: PPUSH
97370: CALL_OW 318
97374: IFFALSE 97385
// ComWalk ( un ) ;
97376: LD_VAR 0 2
97380: PPUSH
97381: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
97385: LD_VAR 0 2
97389: PPUSH
97390: LD_INT 9
97392: PPUSH
97393: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
97397: LD_INT 28
97399: PPUSH
97400: LD_OWVAR 2
97404: PPUSH
97405: LD_INT 2
97407: PPUSH
97408: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
97412: LD_INT 29
97414: PPUSH
97415: LD_OWVAR 2
97419: PPUSH
97420: LD_INT 2
97422: PPUSH
97423: CALL_OW 322
// end ;
97427: PPOPN 3
97429: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
97430: LD_EXP 107
97434: PUSH
97435: LD_EXP 150
97439: AND
97440: IFFALSE 97551
97442: GO 97444
97444: DISABLE
97445: LD_INT 0
97447: PPUSH
97448: PPUSH
97449: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97450: LD_ADDR_VAR 0 3
97454: PUSH
97455: LD_INT 22
97457: PUSH
97458: LD_OWVAR 2
97462: PUSH
97463: EMPTY
97464: LIST
97465: LIST
97466: PUSH
97467: LD_INT 25
97469: PUSH
97470: LD_INT 1
97472: PUSH
97473: EMPTY
97474: LIST
97475: LIST
97476: PUSH
97477: EMPTY
97478: LIST
97479: LIST
97480: PPUSH
97481: CALL_OW 69
97485: ST_TO_ADDR
// if not tmp then
97486: LD_VAR 0 3
97490: NOT
97491: IFFALSE 97495
// exit ;
97493: GO 97551
// un := tmp [ rand ( 1 , tmp ) ] ;
97495: LD_ADDR_VAR 0 2
97499: PUSH
97500: LD_VAR 0 3
97504: PUSH
97505: LD_INT 1
97507: PPUSH
97508: LD_VAR 0 3
97512: PPUSH
97513: CALL_OW 12
97517: ARRAY
97518: ST_TO_ADDR
// if Crawls ( un ) then
97519: LD_VAR 0 2
97523: PPUSH
97524: CALL_OW 318
97528: IFFALSE 97539
// ComWalk ( un ) ;
97530: LD_VAR 0 2
97534: PPUSH
97535: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97539: LD_VAR 0 2
97543: PPUSH
97544: LD_INT 8
97546: PPUSH
97547: CALL_OW 336
// end ;
97551: PPOPN 3
97553: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
97554: LD_EXP 107
97558: PUSH
97559: LD_EXP 151
97563: AND
97564: IFFALSE 97708
97566: GO 97568
97568: DISABLE
97569: LD_INT 0
97571: PPUSH
97572: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
97573: LD_ADDR_VAR 0 2
97577: PUSH
97578: LD_INT 22
97580: PUSH
97581: LD_OWVAR 2
97585: PUSH
97586: EMPTY
97587: LIST
97588: LIST
97589: PUSH
97590: LD_INT 21
97592: PUSH
97593: LD_INT 2
97595: PUSH
97596: EMPTY
97597: LIST
97598: LIST
97599: PUSH
97600: LD_INT 2
97602: PUSH
97603: LD_INT 34
97605: PUSH
97606: LD_INT 12
97608: PUSH
97609: EMPTY
97610: LIST
97611: LIST
97612: PUSH
97613: LD_INT 34
97615: PUSH
97616: LD_INT 51
97618: PUSH
97619: EMPTY
97620: LIST
97621: LIST
97622: PUSH
97623: LD_INT 34
97625: PUSH
97626: LD_INT 32
97628: PUSH
97629: EMPTY
97630: LIST
97631: LIST
97632: PUSH
97633: EMPTY
97634: LIST
97635: LIST
97636: LIST
97637: LIST
97638: PUSH
97639: EMPTY
97640: LIST
97641: LIST
97642: LIST
97643: PPUSH
97644: CALL_OW 69
97648: ST_TO_ADDR
// if not tmp then
97649: LD_VAR 0 2
97653: NOT
97654: IFFALSE 97658
// exit ;
97656: GO 97708
// for i in tmp do
97658: LD_ADDR_VAR 0 1
97662: PUSH
97663: LD_VAR 0 2
97667: PUSH
97668: FOR_IN
97669: IFFALSE 97706
// if GetCargo ( i , mat_artifact ) = 0 then
97671: LD_VAR 0 1
97675: PPUSH
97676: LD_INT 4
97678: PPUSH
97679: CALL_OW 289
97683: PUSH
97684: LD_INT 0
97686: EQUAL
97687: IFFALSE 97704
// SetCargo ( i , mat_siberit , 100 ) ;
97689: LD_VAR 0 1
97693: PPUSH
97694: LD_INT 3
97696: PPUSH
97697: LD_INT 100
97699: PPUSH
97700: CALL_OW 290
97704: GO 97668
97706: POP
97707: POP
// end ;
97708: PPOPN 2
97710: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
97711: LD_EXP 107
97715: PUSH
97716: LD_EXP 152
97720: AND
97721: IFFALSE 97904
97723: GO 97725
97725: DISABLE
97726: LD_INT 0
97728: PPUSH
97729: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97730: LD_ADDR_VAR 0 2
97734: PUSH
97735: LD_INT 22
97737: PUSH
97738: LD_OWVAR 2
97742: PUSH
97743: EMPTY
97744: LIST
97745: LIST
97746: PPUSH
97747: CALL_OW 69
97751: ST_TO_ADDR
// if not tmp then
97752: LD_VAR 0 2
97756: NOT
97757: IFFALSE 97761
// exit ;
97759: GO 97904
// for i := 1 to 2 do
97761: LD_ADDR_VAR 0 1
97765: PUSH
97766: DOUBLE
97767: LD_INT 1
97769: DEC
97770: ST_TO_ADDR
97771: LD_INT 2
97773: PUSH
97774: FOR_TO
97775: IFFALSE 97902
// begin uc_side := your_side ;
97777: LD_ADDR_OWVAR 20
97781: PUSH
97782: LD_OWVAR 2
97786: ST_TO_ADDR
// uc_nation := nation_american ;
97787: LD_ADDR_OWVAR 21
97791: PUSH
97792: LD_INT 1
97794: ST_TO_ADDR
// vc_chassis := us_morphling ;
97795: LD_ADDR_OWVAR 37
97799: PUSH
97800: LD_INT 5
97802: ST_TO_ADDR
// vc_engine := engine_siberite ;
97803: LD_ADDR_OWVAR 39
97807: PUSH
97808: LD_INT 3
97810: ST_TO_ADDR
// vc_control := control_computer ;
97811: LD_ADDR_OWVAR 38
97815: PUSH
97816: LD_INT 3
97818: ST_TO_ADDR
// vc_weapon := us_double_laser ;
97819: LD_ADDR_OWVAR 40
97823: PUSH
97824: LD_INT 10
97826: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
97827: LD_VAR 0 2
97831: PUSH
97832: LD_INT 1
97834: ARRAY
97835: PPUSH
97836: CALL_OW 310
97840: NOT
97841: IFFALSE 97888
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
97843: CALL_OW 45
97847: PPUSH
97848: LD_VAR 0 2
97852: PUSH
97853: LD_INT 1
97855: ARRAY
97856: PPUSH
97857: CALL_OW 250
97861: PPUSH
97862: LD_VAR 0 2
97866: PUSH
97867: LD_INT 1
97869: ARRAY
97870: PPUSH
97871: CALL_OW 251
97875: PPUSH
97876: LD_INT 12
97878: PPUSH
97879: LD_INT 1
97881: PPUSH
97882: CALL_OW 50
97886: GO 97900
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
97888: CALL_OW 45
97892: PPUSH
97893: LD_INT 1
97895: PPUSH
97896: CALL_OW 51
// end ;
97900: GO 97774
97902: POP
97903: POP
// end ;
97904: PPOPN 2
97906: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
97907: LD_EXP 107
97911: PUSH
97912: LD_EXP 153
97916: AND
97917: IFFALSE 98139
97919: GO 97921
97921: DISABLE
97922: LD_INT 0
97924: PPUSH
97925: PPUSH
97926: PPUSH
97927: PPUSH
97928: PPUSH
97929: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97930: LD_ADDR_VAR 0 6
97934: PUSH
97935: LD_INT 22
97937: PUSH
97938: LD_OWVAR 2
97942: PUSH
97943: EMPTY
97944: LIST
97945: LIST
97946: PUSH
97947: LD_INT 21
97949: PUSH
97950: LD_INT 1
97952: PUSH
97953: EMPTY
97954: LIST
97955: LIST
97956: PUSH
97957: LD_INT 3
97959: PUSH
97960: LD_INT 23
97962: PUSH
97963: LD_INT 0
97965: PUSH
97966: EMPTY
97967: LIST
97968: LIST
97969: PUSH
97970: EMPTY
97971: LIST
97972: LIST
97973: PUSH
97974: EMPTY
97975: LIST
97976: LIST
97977: LIST
97978: PPUSH
97979: CALL_OW 69
97983: ST_TO_ADDR
// if not tmp then
97984: LD_VAR 0 6
97988: NOT
97989: IFFALSE 97993
// exit ;
97991: GO 98139
// s1 := rand ( 1 , 4 ) ;
97993: LD_ADDR_VAR 0 2
97997: PUSH
97998: LD_INT 1
98000: PPUSH
98001: LD_INT 4
98003: PPUSH
98004: CALL_OW 12
98008: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
98009: LD_ADDR_VAR 0 4
98013: PUSH
98014: LD_VAR 0 6
98018: PUSH
98019: LD_INT 1
98021: ARRAY
98022: PPUSH
98023: LD_VAR 0 2
98027: PPUSH
98028: CALL_OW 259
98032: ST_TO_ADDR
// if s1 = 1 then
98033: LD_VAR 0 2
98037: PUSH
98038: LD_INT 1
98040: EQUAL
98041: IFFALSE 98061
// s2 := rand ( 2 , 4 ) else
98043: LD_ADDR_VAR 0 3
98047: PUSH
98048: LD_INT 2
98050: PPUSH
98051: LD_INT 4
98053: PPUSH
98054: CALL_OW 12
98058: ST_TO_ADDR
98059: GO 98069
// s2 := 1 ;
98061: LD_ADDR_VAR 0 3
98065: PUSH
98066: LD_INT 1
98068: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
98069: LD_ADDR_VAR 0 5
98073: PUSH
98074: LD_VAR 0 6
98078: PUSH
98079: LD_INT 1
98081: ARRAY
98082: PPUSH
98083: LD_VAR 0 3
98087: PPUSH
98088: CALL_OW 259
98092: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
98093: LD_VAR 0 6
98097: PUSH
98098: LD_INT 1
98100: ARRAY
98101: PPUSH
98102: LD_VAR 0 2
98106: PPUSH
98107: LD_VAR 0 5
98111: PPUSH
98112: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
98116: LD_VAR 0 6
98120: PUSH
98121: LD_INT 1
98123: ARRAY
98124: PPUSH
98125: LD_VAR 0 3
98129: PPUSH
98130: LD_VAR 0 4
98134: PPUSH
98135: CALL_OW 237
// end ;
98139: PPOPN 6
98141: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
98142: LD_EXP 107
98146: PUSH
98147: LD_EXP 154
98151: AND
98152: IFFALSE 98231
98154: GO 98156
98156: DISABLE
98157: LD_INT 0
98159: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
98160: LD_ADDR_VAR 0 1
98164: PUSH
98165: LD_INT 22
98167: PUSH
98168: LD_OWVAR 2
98172: PUSH
98173: EMPTY
98174: LIST
98175: LIST
98176: PUSH
98177: LD_INT 30
98179: PUSH
98180: LD_INT 3
98182: PUSH
98183: EMPTY
98184: LIST
98185: LIST
98186: PUSH
98187: EMPTY
98188: LIST
98189: LIST
98190: PPUSH
98191: CALL_OW 69
98195: ST_TO_ADDR
// if not tmp then
98196: LD_VAR 0 1
98200: NOT
98201: IFFALSE 98205
// exit ;
98203: GO 98231
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98205: LD_VAR 0 1
98209: PUSH
98210: LD_INT 1
98212: PPUSH
98213: LD_VAR 0 1
98217: PPUSH
98218: CALL_OW 12
98222: ARRAY
98223: PPUSH
98224: LD_INT 1
98226: PPUSH
98227: CALL_OW 234
// end ;
98231: PPOPN 1
98233: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
98234: LD_EXP 107
98238: PUSH
98239: LD_EXP 155
98243: AND
98244: IFFALSE 98356
98246: GO 98248
98248: DISABLE
98249: LD_INT 0
98251: PPUSH
98252: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
98253: LD_ADDR_VAR 0 2
98257: PUSH
98258: LD_INT 22
98260: PUSH
98261: LD_OWVAR 2
98265: PUSH
98266: EMPTY
98267: LIST
98268: LIST
98269: PUSH
98270: LD_INT 2
98272: PUSH
98273: LD_INT 30
98275: PUSH
98276: LD_INT 27
98278: PUSH
98279: EMPTY
98280: LIST
98281: LIST
98282: PUSH
98283: LD_INT 30
98285: PUSH
98286: LD_INT 26
98288: PUSH
98289: EMPTY
98290: LIST
98291: LIST
98292: PUSH
98293: LD_INT 30
98295: PUSH
98296: LD_INT 28
98298: PUSH
98299: EMPTY
98300: LIST
98301: LIST
98302: PUSH
98303: EMPTY
98304: LIST
98305: LIST
98306: LIST
98307: LIST
98308: PUSH
98309: EMPTY
98310: LIST
98311: LIST
98312: PPUSH
98313: CALL_OW 69
98317: ST_TO_ADDR
// if not tmp then
98318: LD_VAR 0 2
98322: NOT
98323: IFFALSE 98327
// exit ;
98325: GO 98356
// for i in tmp do
98327: LD_ADDR_VAR 0 1
98331: PUSH
98332: LD_VAR 0 2
98336: PUSH
98337: FOR_IN
98338: IFFALSE 98354
// SetLives ( i , 1 ) ;
98340: LD_VAR 0 1
98344: PPUSH
98345: LD_INT 1
98347: PPUSH
98348: CALL_OW 234
98352: GO 98337
98354: POP
98355: POP
// end ;
98356: PPOPN 2
98358: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
98359: LD_EXP 107
98363: PUSH
98364: LD_EXP 156
98368: AND
98369: IFFALSE 98656
98371: GO 98373
98373: DISABLE
98374: LD_INT 0
98376: PPUSH
98377: PPUSH
98378: PPUSH
// begin i := rand ( 1 , 7 ) ;
98379: LD_ADDR_VAR 0 1
98383: PUSH
98384: LD_INT 1
98386: PPUSH
98387: LD_INT 7
98389: PPUSH
98390: CALL_OW 12
98394: ST_TO_ADDR
// case i of 1 :
98395: LD_VAR 0 1
98399: PUSH
98400: LD_INT 1
98402: DOUBLE
98403: EQUAL
98404: IFTRUE 98408
98406: GO 98418
98408: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
98409: LD_STRING earthquake(getX(game), 0, 32)
98411: PPUSH
98412: CALL_OW 559
98416: GO 98656
98418: LD_INT 2
98420: DOUBLE
98421: EQUAL
98422: IFTRUE 98426
98424: GO 98440
98426: POP
// begin ToLua ( displayStucuk(); ) ;
98427: LD_STRING displayStucuk();
98429: PPUSH
98430: CALL_OW 559
// ResetFog ;
98434: CALL_OW 335
// end ; 3 :
98438: GO 98656
98440: LD_INT 3
98442: DOUBLE
98443: EQUAL
98444: IFTRUE 98448
98446: GO 98552
98448: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98449: LD_ADDR_VAR 0 2
98453: PUSH
98454: LD_INT 22
98456: PUSH
98457: LD_OWVAR 2
98461: PUSH
98462: EMPTY
98463: LIST
98464: LIST
98465: PUSH
98466: LD_INT 25
98468: PUSH
98469: LD_INT 1
98471: PUSH
98472: EMPTY
98473: LIST
98474: LIST
98475: PUSH
98476: EMPTY
98477: LIST
98478: LIST
98479: PPUSH
98480: CALL_OW 69
98484: ST_TO_ADDR
// if not tmp then
98485: LD_VAR 0 2
98489: NOT
98490: IFFALSE 98494
// exit ;
98492: GO 98656
// un := tmp [ rand ( 1 , tmp ) ] ;
98494: LD_ADDR_VAR 0 3
98498: PUSH
98499: LD_VAR 0 2
98503: PUSH
98504: LD_INT 1
98506: PPUSH
98507: LD_VAR 0 2
98511: PPUSH
98512: CALL_OW 12
98516: ARRAY
98517: ST_TO_ADDR
// if Crawls ( un ) then
98518: LD_VAR 0 3
98522: PPUSH
98523: CALL_OW 318
98527: IFFALSE 98538
// ComWalk ( un ) ;
98529: LD_VAR 0 3
98533: PPUSH
98534: CALL_OW 138
// SetClass ( un , class_mortar ) ;
98538: LD_VAR 0 3
98542: PPUSH
98543: LD_INT 8
98545: PPUSH
98546: CALL_OW 336
// end ; 4 :
98550: GO 98656
98552: LD_INT 4
98554: DOUBLE
98555: EQUAL
98556: IFTRUE 98560
98558: GO 98634
98560: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
98561: LD_ADDR_VAR 0 2
98565: PUSH
98566: LD_INT 22
98568: PUSH
98569: LD_OWVAR 2
98573: PUSH
98574: EMPTY
98575: LIST
98576: LIST
98577: PUSH
98578: LD_INT 30
98580: PUSH
98581: LD_INT 29
98583: PUSH
98584: EMPTY
98585: LIST
98586: LIST
98587: PUSH
98588: EMPTY
98589: LIST
98590: LIST
98591: PPUSH
98592: CALL_OW 69
98596: ST_TO_ADDR
// if not tmp then
98597: LD_VAR 0 2
98601: NOT
98602: IFFALSE 98606
// exit ;
98604: GO 98656
// CenterNowOnUnits ( tmp [ 1 ] ) ;
98606: LD_VAR 0 2
98610: PUSH
98611: LD_INT 1
98613: ARRAY
98614: PPUSH
98615: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
98619: LD_VAR 0 2
98623: PUSH
98624: LD_INT 1
98626: ARRAY
98627: PPUSH
98628: CALL_OW 65
// end ; 5 .. 7 :
98632: GO 98656
98634: LD_INT 5
98636: DOUBLE
98637: GREATEREQUAL
98638: IFFALSE 98646
98640: LD_INT 7
98642: DOUBLE
98643: LESSEQUAL
98644: IFTRUE 98648
98646: GO 98655
98648: POP
// StreamSibBomb ; end ;
98649: CALL 94893 0 0
98653: GO 98656
98655: POP
// end ;
98656: PPOPN 3
98658: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
98659: LD_EXP 107
98663: PUSH
98664: LD_EXP 157
98668: AND
98669: IFFALSE 98825
98671: GO 98673
98673: DISABLE
98674: LD_INT 0
98676: PPUSH
98677: PPUSH
98678: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
98679: LD_ADDR_VAR 0 2
98683: PUSH
98684: LD_INT 81
98686: PUSH
98687: LD_OWVAR 2
98691: PUSH
98692: EMPTY
98693: LIST
98694: LIST
98695: PUSH
98696: LD_INT 2
98698: PUSH
98699: LD_INT 21
98701: PUSH
98702: LD_INT 1
98704: PUSH
98705: EMPTY
98706: LIST
98707: LIST
98708: PUSH
98709: LD_INT 21
98711: PUSH
98712: LD_INT 2
98714: PUSH
98715: EMPTY
98716: LIST
98717: LIST
98718: PUSH
98719: EMPTY
98720: LIST
98721: LIST
98722: LIST
98723: PUSH
98724: EMPTY
98725: LIST
98726: LIST
98727: PPUSH
98728: CALL_OW 69
98732: ST_TO_ADDR
// if not tmp then
98733: LD_VAR 0 2
98737: NOT
98738: IFFALSE 98742
// exit ;
98740: GO 98825
// p := 0 ;
98742: LD_ADDR_VAR 0 3
98746: PUSH
98747: LD_INT 0
98749: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98750: LD_INT 35
98752: PPUSH
98753: CALL_OW 67
// p := p + 1 ;
98757: LD_ADDR_VAR 0 3
98761: PUSH
98762: LD_VAR 0 3
98766: PUSH
98767: LD_INT 1
98769: PLUS
98770: ST_TO_ADDR
// for i in tmp do
98771: LD_ADDR_VAR 0 1
98775: PUSH
98776: LD_VAR 0 2
98780: PUSH
98781: FOR_IN
98782: IFFALSE 98813
// if GetLives ( i ) < 1000 then
98784: LD_VAR 0 1
98788: PPUSH
98789: CALL_OW 256
98793: PUSH
98794: LD_INT 1000
98796: LESS
98797: IFFALSE 98811
// SetLives ( i , 1000 ) ;
98799: LD_VAR 0 1
98803: PPUSH
98804: LD_INT 1000
98806: PPUSH
98807: CALL_OW 234
98811: GO 98781
98813: POP
98814: POP
// until p > 20 ;
98815: LD_VAR 0 3
98819: PUSH
98820: LD_INT 20
98822: GREATER
98823: IFFALSE 98750
// end ;
98825: PPOPN 3
98827: END
// every 0 0$1 trigger StreamModeActive and sTime do
98828: LD_EXP 107
98832: PUSH
98833: LD_EXP 158
98837: AND
98838: IFFALSE 98873
98840: GO 98842
98842: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
98843: LD_INT 28
98845: PPUSH
98846: LD_OWVAR 2
98850: PPUSH
98851: LD_INT 2
98853: PPUSH
98854: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
98858: LD_INT 30
98860: PPUSH
98861: LD_OWVAR 2
98865: PPUSH
98866: LD_INT 2
98868: PPUSH
98869: CALL_OW 322
// end ;
98873: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
98874: LD_EXP 107
98878: PUSH
98879: LD_EXP 159
98883: AND
98884: IFFALSE 99005
98886: GO 98888
98888: DISABLE
98889: LD_INT 0
98891: PPUSH
98892: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98893: LD_ADDR_VAR 0 2
98897: PUSH
98898: LD_INT 22
98900: PUSH
98901: LD_OWVAR 2
98905: PUSH
98906: EMPTY
98907: LIST
98908: LIST
98909: PUSH
98910: LD_INT 21
98912: PUSH
98913: LD_INT 1
98915: PUSH
98916: EMPTY
98917: LIST
98918: LIST
98919: PUSH
98920: LD_INT 3
98922: PUSH
98923: LD_INT 23
98925: PUSH
98926: LD_INT 0
98928: PUSH
98929: EMPTY
98930: LIST
98931: LIST
98932: PUSH
98933: EMPTY
98934: LIST
98935: LIST
98936: PUSH
98937: EMPTY
98938: LIST
98939: LIST
98940: LIST
98941: PPUSH
98942: CALL_OW 69
98946: ST_TO_ADDR
// if not tmp then
98947: LD_VAR 0 2
98951: NOT
98952: IFFALSE 98956
// exit ;
98954: GO 99005
// for i in tmp do
98956: LD_ADDR_VAR 0 1
98960: PUSH
98961: LD_VAR 0 2
98965: PUSH
98966: FOR_IN
98967: IFFALSE 99003
// begin if Crawls ( i ) then
98969: LD_VAR 0 1
98973: PPUSH
98974: CALL_OW 318
98978: IFFALSE 98989
// ComWalk ( i ) ;
98980: LD_VAR 0 1
98984: PPUSH
98985: CALL_OW 138
// SetClass ( i , 2 ) ;
98989: LD_VAR 0 1
98993: PPUSH
98994: LD_INT 2
98996: PPUSH
98997: CALL_OW 336
// end ;
99001: GO 98966
99003: POP
99004: POP
// end ;
99005: PPOPN 2
99007: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
99008: LD_EXP 107
99012: PUSH
99013: LD_EXP 160
99017: AND
99018: IFFALSE 99306
99020: GO 99022
99022: DISABLE
99023: LD_INT 0
99025: PPUSH
99026: PPUSH
99027: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
99028: LD_OWVAR 2
99032: PPUSH
99033: LD_INT 9
99035: PPUSH
99036: LD_INT 1
99038: PPUSH
99039: LD_INT 1
99041: PPUSH
99042: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
99046: LD_INT 9
99048: PPUSH
99049: LD_OWVAR 2
99053: PPUSH
99054: CALL_OW 343
// uc_side := 9 ;
99058: LD_ADDR_OWVAR 20
99062: PUSH
99063: LD_INT 9
99065: ST_TO_ADDR
// uc_nation := 2 ;
99066: LD_ADDR_OWVAR 21
99070: PUSH
99071: LD_INT 2
99073: ST_TO_ADDR
// hc_name := Dark Warrior ;
99074: LD_ADDR_OWVAR 26
99078: PUSH
99079: LD_STRING Dark Warrior
99081: ST_TO_ADDR
// hc_gallery :=  ;
99082: LD_ADDR_OWVAR 33
99086: PUSH
99087: LD_STRING 
99089: ST_TO_ADDR
// hc_noskilllimit := true ;
99090: LD_ADDR_OWVAR 76
99094: PUSH
99095: LD_INT 1
99097: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
99098: LD_ADDR_OWVAR 31
99102: PUSH
99103: LD_INT 30
99105: PUSH
99106: LD_INT 30
99108: PUSH
99109: LD_INT 30
99111: PUSH
99112: LD_INT 30
99114: PUSH
99115: EMPTY
99116: LIST
99117: LIST
99118: LIST
99119: LIST
99120: ST_TO_ADDR
// un := CreateHuman ;
99121: LD_ADDR_VAR 0 3
99125: PUSH
99126: CALL_OW 44
99130: ST_TO_ADDR
// hc_noskilllimit := false ;
99131: LD_ADDR_OWVAR 76
99135: PUSH
99136: LD_INT 0
99138: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99139: LD_VAR 0 3
99143: PPUSH
99144: LD_INT 1
99146: PPUSH
99147: CALL_OW 51
// ToLua ( playRanger() ) ;
99151: LD_STRING playRanger()
99153: PPUSH
99154: CALL_OW 559
// p := 0 ;
99158: LD_ADDR_VAR 0 2
99162: PUSH
99163: LD_INT 0
99165: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99166: LD_INT 35
99168: PPUSH
99169: CALL_OW 67
// p := p + 1 ;
99173: LD_ADDR_VAR 0 2
99177: PUSH
99178: LD_VAR 0 2
99182: PUSH
99183: LD_INT 1
99185: PLUS
99186: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
99187: LD_VAR 0 3
99191: PPUSH
99192: CALL_OW 256
99196: PUSH
99197: LD_INT 1000
99199: LESS
99200: IFFALSE 99214
// SetLives ( un , 1000 ) ;
99202: LD_VAR 0 3
99206: PPUSH
99207: LD_INT 1000
99209: PPUSH
99210: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
99214: LD_VAR 0 3
99218: PPUSH
99219: LD_INT 81
99221: PUSH
99222: LD_OWVAR 2
99226: PUSH
99227: EMPTY
99228: LIST
99229: LIST
99230: PUSH
99231: LD_INT 91
99233: PUSH
99234: LD_VAR 0 3
99238: PUSH
99239: LD_INT 30
99241: PUSH
99242: EMPTY
99243: LIST
99244: LIST
99245: LIST
99246: PUSH
99247: EMPTY
99248: LIST
99249: LIST
99250: PPUSH
99251: CALL_OW 69
99255: PPUSH
99256: LD_VAR 0 3
99260: PPUSH
99261: CALL_OW 74
99265: PPUSH
99266: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
99270: LD_VAR 0 2
99274: PUSH
99275: LD_INT 80
99277: GREATER
99278: PUSH
99279: LD_VAR 0 3
99283: PPUSH
99284: CALL_OW 301
99288: OR
99289: IFFALSE 99166
// if un then
99291: LD_VAR 0 3
99295: IFFALSE 99306
// RemoveUnit ( un ) ;
99297: LD_VAR 0 3
99301: PPUSH
99302: CALL_OW 64
// end ;
99306: PPOPN 3
99308: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
99309: LD_EXP 161
99313: IFFALSE 99429
99315: GO 99317
99317: DISABLE
99318: LD_INT 0
99320: PPUSH
99321: PPUSH
99322: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
99323: LD_ADDR_VAR 0 2
99327: PUSH
99328: LD_INT 81
99330: PUSH
99331: LD_OWVAR 2
99335: PUSH
99336: EMPTY
99337: LIST
99338: LIST
99339: PUSH
99340: LD_INT 21
99342: PUSH
99343: LD_INT 1
99345: PUSH
99346: EMPTY
99347: LIST
99348: LIST
99349: PUSH
99350: EMPTY
99351: LIST
99352: LIST
99353: PPUSH
99354: CALL_OW 69
99358: ST_TO_ADDR
// ToLua ( playComputer() ) ;
99359: LD_STRING playComputer()
99361: PPUSH
99362: CALL_OW 559
// if not tmp then
99366: LD_VAR 0 2
99370: NOT
99371: IFFALSE 99375
// exit ;
99373: GO 99429
// for i in tmp do
99375: LD_ADDR_VAR 0 1
99379: PUSH
99380: LD_VAR 0 2
99384: PUSH
99385: FOR_IN
99386: IFFALSE 99427
// for j := 1 to 4 do
99388: LD_ADDR_VAR 0 3
99392: PUSH
99393: DOUBLE
99394: LD_INT 1
99396: DEC
99397: ST_TO_ADDR
99398: LD_INT 4
99400: PUSH
99401: FOR_TO
99402: IFFALSE 99423
// SetSkill ( i , j , 10 ) ;
99404: LD_VAR 0 1
99408: PPUSH
99409: LD_VAR 0 3
99413: PPUSH
99414: LD_INT 10
99416: PPUSH
99417: CALL_OW 237
99421: GO 99401
99423: POP
99424: POP
99425: GO 99385
99427: POP
99428: POP
// end ;
99429: PPOPN 3
99431: END
// every 0 0$1 trigger s30 do var i , tmp ;
99432: LD_EXP 162
99436: IFFALSE 99505
99438: GO 99440
99440: DISABLE
99441: LD_INT 0
99443: PPUSH
99444: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99445: LD_ADDR_VAR 0 2
99449: PUSH
99450: LD_INT 22
99452: PUSH
99453: LD_OWVAR 2
99457: PUSH
99458: EMPTY
99459: LIST
99460: LIST
99461: PPUSH
99462: CALL_OW 69
99466: ST_TO_ADDR
// if not tmp then
99467: LD_VAR 0 2
99471: NOT
99472: IFFALSE 99476
// exit ;
99474: GO 99505
// for i in tmp do
99476: LD_ADDR_VAR 0 1
99480: PUSH
99481: LD_VAR 0 2
99485: PUSH
99486: FOR_IN
99487: IFFALSE 99503
// SetLives ( i , 300 ) ;
99489: LD_VAR 0 1
99493: PPUSH
99494: LD_INT 300
99496: PPUSH
99497: CALL_OW 234
99501: GO 99486
99503: POP
99504: POP
// end ;
99505: PPOPN 2
99507: END
// every 0 0$1 trigger s60 do var i , tmp ;
99508: LD_EXP 163
99512: IFFALSE 99581
99514: GO 99516
99516: DISABLE
99517: LD_INT 0
99519: PPUSH
99520: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99521: LD_ADDR_VAR 0 2
99525: PUSH
99526: LD_INT 22
99528: PUSH
99529: LD_OWVAR 2
99533: PUSH
99534: EMPTY
99535: LIST
99536: LIST
99537: PPUSH
99538: CALL_OW 69
99542: ST_TO_ADDR
// if not tmp then
99543: LD_VAR 0 2
99547: NOT
99548: IFFALSE 99552
// exit ;
99550: GO 99581
// for i in tmp do
99552: LD_ADDR_VAR 0 1
99556: PUSH
99557: LD_VAR 0 2
99561: PUSH
99562: FOR_IN
99563: IFFALSE 99579
// SetLives ( i , 600 ) ;
99565: LD_VAR 0 1
99569: PPUSH
99570: LD_INT 600
99572: PPUSH
99573: CALL_OW 234
99577: GO 99562
99579: POP
99580: POP
// end ;
99581: PPOPN 2
99583: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
99584: LD_INT 0
99586: PPUSH
// case cmd of 301 :
99587: LD_VAR 0 1
99591: PUSH
99592: LD_INT 301
99594: DOUBLE
99595: EQUAL
99596: IFTRUE 99600
99598: GO 99632
99600: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
99601: LD_VAR 0 6
99605: PPUSH
99606: LD_VAR 0 7
99610: PPUSH
99611: LD_VAR 0 8
99615: PPUSH
99616: LD_VAR 0 4
99620: PPUSH
99621: LD_VAR 0 5
99625: PPUSH
99626: CALL 100833 0 5
99630: GO 99753
99632: LD_INT 302
99634: DOUBLE
99635: EQUAL
99636: IFTRUE 99640
99638: GO 99677
99640: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
99641: LD_VAR 0 6
99645: PPUSH
99646: LD_VAR 0 7
99650: PPUSH
99651: LD_VAR 0 8
99655: PPUSH
99656: LD_VAR 0 9
99660: PPUSH
99661: LD_VAR 0 4
99665: PPUSH
99666: LD_VAR 0 5
99670: PPUSH
99671: CALL 100924 0 6
99675: GO 99753
99677: LD_INT 303
99679: DOUBLE
99680: EQUAL
99681: IFTRUE 99685
99683: GO 99722
99685: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
99686: LD_VAR 0 6
99690: PPUSH
99691: LD_VAR 0 7
99695: PPUSH
99696: LD_VAR 0 8
99700: PPUSH
99701: LD_VAR 0 9
99705: PPUSH
99706: LD_VAR 0 4
99710: PPUSH
99711: LD_VAR 0 5
99715: PPUSH
99716: CALL 99758 0 6
99720: GO 99753
99722: LD_INT 304
99724: DOUBLE
99725: EQUAL
99726: IFTRUE 99730
99728: GO 99752
99730: POP
// hHackTeleport ( unit , x , y ) ; end ;
99731: LD_VAR 0 2
99735: PPUSH
99736: LD_VAR 0 4
99740: PPUSH
99741: LD_VAR 0 5
99745: PPUSH
99746: CALL 101517 0 3
99750: GO 99753
99752: POP
// end ;
99753: LD_VAR 0 12
99757: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
99758: LD_INT 0
99760: PPUSH
99761: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
99762: LD_VAR 0 1
99766: PUSH
99767: LD_INT 1
99769: LESS
99770: PUSH
99771: LD_VAR 0 1
99775: PUSH
99776: LD_INT 3
99778: GREATER
99779: OR
99780: PUSH
99781: LD_VAR 0 5
99785: PPUSH
99786: LD_VAR 0 6
99790: PPUSH
99791: CALL_OW 428
99795: OR
99796: IFFALSE 99800
// exit ;
99798: GO 100520
// uc_side := your_side ;
99800: LD_ADDR_OWVAR 20
99804: PUSH
99805: LD_OWVAR 2
99809: ST_TO_ADDR
// uc_nation := nation ;
99810: LD_ADDR_OWVAR 21
99814: PUSH
99815: LD_VAR 0 1
99819: ST_TO_ADDR
// bc_level = 1 ;
99820: LD_ADDR_OWVAR 43
99824: PUSH
99825: LD_INT 1
99827: ST_TO_ADDR
// case btype of 1 :
99828: LD_VAR 0 2
99832: PUSH
99833: LD_INT 1
99835: DOUBLE
99836: EQUAL
99837: IFTRUE 99841
99839: GO 99852
99841: POP
// bc_type := b_depot ; 2 :
99842: LD_ADDR_OWVAR 42
99846: PUSH
99847: LD_INT 0
99849: ST_TO_ADDR
99850: GO 100464
99852: LD_INT 2
99854: DOUBLE
99855: EQUAL
99856: IFTRUE 99860
99858: GO 99871
99860: POP
// bc_type := b_warehouse ; 3 :
99861: LD_ADDR_OWVAR 42
99865: PUSH
99866: LD_INT 1
99868: ST_TO_ADDR
99869: GO 100464
99871: LD_INT 3
99873: DOUBLE
99874: EQUAL
99875: IFTRUE 99879
99877: GO 99890
99879: POP
// bc_type := b_lab ; 4 .. 9 :
99880: LD_ADDR_OWVAR 42
99884: PUSH
99885: LD_INT 6
99887: ST_TO_ADDR
99888: GO 100464
99890: LD_INT 4
99892: DOUBLE
99893: GREATEREQUAL
99894: IFFALSE 99902
99896: LD_INT 9
99898: DOUBLE
99899: LESSEQUAL
99900: IFTRUE 99904
99902: GO 99956
99904: POP
// begin bc_type := b_lab_half ;
99905: LD_ADDR_OWVAR 42
99909: PUSH
99910: LD_INT 7
99912: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
99913: LD_ADDR_OWVAR 44
99917: PUSH
99918: LD_INT 10
99920: PUSH
99921: LD_INT 11
99923: PUSH
99924: LD_INT 12
99926: PUSH
99927: LD_INT 15
99929: PUSH
99930: LD_INT 14
99932: PUSH
99933: LD_INT 13
99935: PUSH
99936: EMPTY
99937: LIST
99938: LIST
99939: LIST
99940: LIST
99941: LIST
99942: LIST
99943: PUSH
99944: LD_VAR 0 2
99948: PUSH
99949: LD_INT 3
99951: MINUS
99952: ARRAY
99953: ST_TO_ADDR
// end ; 10 .. 13 :
99954: GO 100464
99956: LD_INT 10
99958: DOUBLE
99959: GREATEREQUAL
99960: IFFALSE 99968
99962: LD_INT 13
99964: DOUBLE
99965: LESSEQUAL
99966: IFTRUE 99970
99968: GO 100047
99970: POP
// begin bc_type := b_lab_full ;
99971: LD_ADDR_OWVAR 42
99975: PUSH
99976: LD_INT 8
99978: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
99979: LD_ADDR_OWVAR 44
99983: PUSH
99984: LD_INT 10
99986: PUSH
99987: LD_INT 12
99989: PUSH
99990: LD_INT 14
99992: PUSH
99993: LD_INT 13
99995: PUSH
99996: EMPTY
99997: LIST
99998: LIST
99999: LIST
100000: LIST
100001: PUSH
100002: LD_VAR 0 2
100006: PUSH
100007: LD_INT 9
100009: MINUS
100010: ARRAY
100011: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
100012: LD_ADDR_OWVAR 45
100016: PUSH
100017: LD_INT 11
100019: PUSH
100020: LD_INT 15
100022: PUSH
100023: LD_INT 12
100025: PUSH
100026: LD_INT 15
100028: PUSH
100029: EMPTY
100030: LIST
100031: LIST
100032: LIST
100033: LIST
100034: PUSH
100035: LD_VAR 0 2
100039: PUSH
100040: LD_INT 9
100042: MINUS
100043: ARRAY
100044: ST_TO_ADDR
// end ; 14 :
100045: GO 100464
100047: LD_INT 14
100049: DOUBLE
100050: EQUAL
100051: IFTRUE 100055
100053: GO 100066
100055: POP
// bc_type := b_workshop ; 15 :
100056: LD_ADDR_OWVAR 42
100060: PUSH
100061: LD_INT 2
100063: ST_TO_ADDR
100064: GO 100464
100066: LD_INT 15
100068: DOUBLE
100069: EQUAL
100070: IFTRUE 100074
100072: GO 100085
100074: POP
// bc_type := b_factory ; 16 :
100075: LD_ADDR_OWVAR 42
100079: PUSH
100080: LD_INT 3
100082: ST_TO_ADDR
100083: GO 100464
100085: LD_INT 16
100087: DOUBLE
100088: EQUAL
100089: IFTRUE 100093
100091: GO 100104
100093: POP
// bc_type := b_ext_gun ; 17 :
100094: LD_ADDR_OWVAR 42
100098: PUSH
100099: LD_INT 17
100101: ST_TO_ADDR
100102: GO 100464
100104: LD_INT 17
100106: DOUBLE
100107: EQUAL
100108: IFTRUE 100112
100110: GO 100140
100112: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
100113: LD_ADDR_OWVAR 42
100117: PUSH
100118: LD_INT 19
100120: PUSH
100121: LD_INT 23
100123: PUSH
100124: LD_INT 19
100126: PUSH
100127: EMPTY
100128: LIST
100129: LIST
100130: LIST
100131: PUSH
100132: LD_VAR 0 1
100136: ARRAY
100137: ST_TO_ADDR
100138: GO 100464
100140: LD_INT 18
100142: DOUBLE
100143: EQUAL
100144: IFTRUE 100148
100146: GO 100159
100148: POP
// bc_type := b_ext_radar ; 19 :
100149: LD_ADDR_OWVAR 42
100153: PUSH
100154: LD_INT 20
100156: ST_TO_ADDR
100157: GO 100464
100159: LD_INT 19
100161: DOUBLE
100162: EQUAL
100163: IFTRUE 100167
100165: GO 100178
100167: POP
// bc_type := b_ext_radio ; 20 :
100168: LD_ADDR_OWVAR 42
100172: PUSH
100173: LD_INT 22
100175: ST_TO_ADDR
100176: GO 100464
100178: LD_INT 20
100180: DOUBLE
100181: EQUAL
100182: IFTRUE 100186
100184: GO 100197
100186: POP
// bc_type := b_ext_siberium ; 21 :
100187: LD_ADDR_OWVAR 42
100191: PUSH
100192: LD_INT 21
100194: ST_TO_ADDR
100195: GO 100464
100197: LD_INT 21
100199: DOUBLE
100200: EQUAL
100201: IFTRUE 100205
100203: GO 100216
100205: POP
// bc_type := b_ext_computer ; 22 :
100206: LD_ADDR_OWVAR 42
100210: PUSH
100211: LD_INT 24
100213: ST_TO_ADDR
100214: GO 100464
100216: LD_INT 22
100218: DOUBLE
100219: EQUAL
100220: IFTRUE 100224
100222: GO 100235
100224: POP
// bc_type := b_ext_track ; 23 :
100225: LD_ADDR_OWVAR 42
100229: PUSH
100230: LD_INT 16
100232: ST_TO_ADDR
100233: GO 100464
100235: LD_INT 23
100237: DOUBLE
100238: EQUAL
100239: IFTRUE 100243
100241: GO 100254
100243: POP
// bc_type := b_ext_laser ; 24 :
100244: LD_ADDR_OWVAR 42
100248: PUSH
100249: LD_INT 25
100251: ST_TO_ADDR
100252: GO 100464
100254: LD_INT 24
100256: DOUBLE
100257: EQUAL
100258: IFTRUE 100262
100260: GO 100273
100262: POP
// bc_type := b_control_tower ; 25 :
100263: LD_ADDR_OWVAR 42
100267: PUSH
100268: LD_INT 36
100270: ST_TO_ADDR
100271: GO 100464
100273: LD_INT 25
100275: DOUBLE
100276: EQUAL
100277: IFTRUE 100281
100279: GO 100292
100281: POP
// bc_type := b_breastwork ; 26 :
100282: LD_ADDR_OWVAR 42
100286: PUSH
100287: LD_INT 31
100289: ST_TO_ADDR
100290: GO 100464
100292: LD_INT 26
100294: DOUBLE
100295: EQUAL
100296: IFTRUE 100300
100298: GO 100311
100300: POP
// bc_type := b_bunker ; 27 :
100301: LD_ADDR_OWVAR 42
100305: PUSH
100306: LD_INT 32
100308: ST_TO_ADDR
100309: GO 100464
100311: LD_INT 27
100313: DOUBLE
100314: EQUAL
100315: IFTRUE 100319
100317: GO 100330
100319: POP
// bc_type := b_turret ; 28 :
100320: LD_ADDR_OWVAR 42
100324: PUSH
100325: LD_INT 33
100327: ST_TO_ADDR
100328: GO 100464
100330: LD_INT 28
100332: DOUBLE
100333: EQUAL
100334: IFTRUE 100338
100336: GO 100349
100338: POP
// bc_type := b_armoury ; 29 :
100339: LD_ADDR_OWVAR 42
100343: PUSH
100344: LD_INT 4
100346: ST_TO_ADDR
100347: GO 100464
100349: LD_INT 29
100351: DOUBLE
100352: EQUAL
100353: IFTRUE 100357
100355: GO 100368
100357: POP
// bc_type := b_barracks ; 30 :
100358: LD_ADDR_OWVAR 42
100362: PUSH
100363: LD_INT 5
100365: ST_TO_ADDR
100366: GO 100464
100368: LD_INT 30
100370: DOUBLE
100371: EQUAL
100372: IFTRUE 100376
100374: GO 100387
100376: POP
// bc_type := b_solar_power ; 31 :
100377: LD_ADDR_OWVAR 42
100381: PUSH
100382: LD_INT 27
100384: ST_TO_ADDR
100385: GO 100464
100387: LD_INT 31
100389: DOUBLE
100390: EQUAL
100391: IFTRUE 100395
100393: GO 100406
100395: POP
// bc_type := b_oil_power ; 32 :
100396: LD_ADDR_OWVAR 42
100400: PUSH
100401: LD_INT 26
100403: ST_TO_ADDR
100404: GO 100464
100406: LD_INT 32
100408: DOUBLE
100409: EQUAL
100410: IFTRUE 100414
100412: GO 100425
100414: POP
// bc_type := b_siberite_power ; 33 :
100415: LD_ADDR_OWVAR 42
100419: PUSH
100420: LD_INT 28
100422: ST_TO_ADDR
100423: GO 100464
100425: LD_INT 33
100427: DOUBLE
100428: EQUAL
100429: IFTRUE 100433
100431: GO 100444
100433: POP
// bc_type := b_oil_mine ; 34 :
100434: LD_ADDR_OWVAR 42
100438: PUSH
100439: LD_INT 29
100441: ST_TO_ADDR
100442: GO 100464
100444: LD_INT 34
100446: DOUBLE
100447: EQUAL
100448: IFTRUE 100452
100450: GO 100463
100452: POP
// bc_type := b_siberite_mine ; end ;
100453: LD_ADDR_OWVAR 42
100457: PUSH
100458: LD_INT 30
100460: ST_TO_ADDR
100461: GO 100464
100463: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
100464: LD_ADDR_VAR 0 8
100468: PUSH
100469: LD_VAR 0 5
100473: PPUSH
100474: LD_VAR 0 6
100478: PPUSH
100479: LD_VAR 0 3
100483: PPUSH
100484: CALL_OW 47
100488: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
100489: LD_OWVAR 42
100493: PUSH
100494: LD_INT 32
100496: PUSH
100497: LD_INT 33
100499: PUSH
100500: EMPTY
100501: LIST
100502: LIST
100503: IN
100504: IFFALSE 100520
// PlaceWeaponTurret ( b , weapon ) ;
100506: LD_VAR 0 8
100510: PPUSH
100511: LD_VAR 0 4
100515: PPUSH
100516: CALL_OW 431
// end ;
100520: LD_VAR 0 7
100524: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
100525: LD_INT 0
100527: PPUSH
100528: PPUSH
100529: PPUSH
100530: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100531: LD_ADDR_VAR 0 4
100535: PUSH
100536: LD_INT 22
100538: PUSH
100539: LD_OWVAR 2
100543: PUSH
100544: EMPTY
100545: LIST
100546: LIST
100547: PUSH
100548: LD_INT 2
100550: PUSH
100551: LD_INT 30
100553: PUSH
100554: LD_INT 0
100556: PUSH
100557: EMPTY
100558: LIST
100559: LIST
100560: PUSH
100561: LD_INT 30
100563: PUSH
100564: LD_INT 1
100566: PUSH
100567: EMPTY
100568: LIST
100569: LIST
100570: PUSH
100571: EMPTY
100572: LIST
100573: LIST
100574: LIST
100575: PUSH
100576: EMPTY
100577: LIST
100578: LIST
100579: PPUSH
100580: CALL_OW 69
100584: ST_TO_ADDR
// if not tmp then
100585: LD_VAR 0 4
100589: NOT
100590: IFFALSE 100594
// exit ;
100592: GO 100653
// for i in tmp do
100594: LD_ADDR_VAR 0 2
100598: PUSH
100599: LD_VAR 0 4
100603: PUSH
100604: FOR_IN
100605: IFFALSE 100651
// for j = 1 to 3 do
100607: LD_ADDR_VAR 0 3
100611: PUSH
100612: DOUBLE
100613: LD_INT 1
100615: DEC
100616: ST_TO_ADDR
100617: LD_INT 3
100619: PUSH
100620: FOR_TO
100621: IFFALSE 100647
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
100623: LD_VAR 0 2
100627: PPUSH
100628: CALL_OW 274
100632: PPUSH
100633: LD_VAR 0 3
100637: PPUSH
100638: LD_INT 99999
100640: PPUSH
100641: CALL_OW 277
100645: GO 100620
100647: POP
100648: POP
100649: GO 100604
100651: POP
100652: POP
// end ;
100653: LD_VAR 0 1
100657: RET
// export function hHackSetLevel10 ; var i , j ; begin
100658: LD_INT 0
100660: PPUSH
100661: PPUSH
100662: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100663: LD_ADDR_VAR 0 2
100667: PUSH
100668: LD_INT 21
100670: PUSH
100671: LD_INT 1
100673: PUSH
100674: EMPTY
100675: LIST
100676: LIST
100677: PPUSH
100678: CALL_OW 69
100682: PUSH
100683: FOR_IN
100684: IFFALSE 100736
// if IsSelected ( i ) then
100686: LD_VAR 0 2
100690: PPUSH
100691: CALL_OW 306
100695: IFFALSE 100734
// begin for j := 1 to 4 do
100697: LD_ADDR_VAR 0 3
100701: PUSH
100702: DOUBLE
100703: LD_INT 1
100705: DEC
100706: ST_TO_ADDR
100707: LD_INT 4
100709: PUSH
100710: FOR_TO
100711: IFFALSE 100732
// SetSkill ( i , j , 10 ) ;
100713: LD_VAR 0 2
100717: PPUSH
100718: LD_VAR 0 3
100722: PPUSH
100723: LD_INT 10
100725: PPUSH
100726: CALL_OW 237
100730: GO 100710
100732: POP
100733: POP
// end ;
100734: GO 100683
100736: POP
100737: POP
// end ;
100738: LD_VAR 0 1
100742: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
100743: LD_INT 0
100745: PPUSH
100746: PPUSH
100747: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
100748: LD_ADDR_VAR 0 2
100752: PUSH
100753: LD_INT 22
100755: PUSH
100756: LD_OWVAR 2
100760: PUSH
100761: EMPTY
100762: LIST
100763: LIST
100764: PUSH
100765: LD_INT 21
100767: PUSH
100768: LD_INT 1
100770: PUSH
100771: EMPTY
100772: LIST
100773: LIST
100774: PUSH
100775: EMPTY
100776: LIST
100777: LIST
100778: PPUSH
100779: CALL_OW 69
100783: PUSH
100784: FOR_IN
100785: IFFALSE 100826
// begin for j := 1 to 4 do
100787: LD_ADDR_VAR 0 3
100791: PUSH
100792: DOUBLE
100793: LD_INT 1
100795: DEC
100796: ST_TO_ADDR
100797: LD_INT 4
100799: PUSH
100800: FOR_TO
100801: IFFALSE 100822
// SetSkill ( i , j , 10 ) ;
100803: LD_VAR 0 2
100807: PPUSH
100808: LD_VAR 0 3
100812: PPUSH
100813: LD_INT 10
100815: PPUSH
100816: CALL_OW 237
100820: GO 100800
100822: POP
100823: POP
// end ;
100824: GO 100784
100826: POP
100827: POP
// end ;
100828: LD_VAR 0 1
100832: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
100833: LD_INT 0
100835: PPUSH
// uc_side := your_side ;
100836: LD_ADDR_OWVAR 20
100840: PUSH
100841: LD_OWVAR 2
100845: ST_TO_ADDR
// uc_nation := nation ;
100846: LD_ADDR_OWVAR 21
100850: PUSH
100851: LD_VAR 0 1
100855: ST_TO_ADDR
// InitHc ;
100856: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
100860: LD_INT 0
100862: PPUSH
100863: LD_VAR 0 2
100867: PPUSH
100868: LD_VAR 0 3
100872: PPUSH
100873: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
100877: LD_VAR 0 4
100881: PPUSH
100882: LD_VAR 0 5
100886: PPUSH
100887: CALL_OW 428
100891: PUSH
100892: LD_INT 0
100894: EQUAL
100895: IFFALSE 100919
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
100897: CALL_OW 44
100901: PPUSH
100902: LD_VAR 0 4
100906: PPUSH
100907: LD_VAR 0 5
100911: PPUSH
100912: LD_INT 1
100914: PPUSH
100915: CALL_OW 48
// end ;
100919: LD_VAR 0 6
100923: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
100924: LD_INT 0
100926: PPUSH
100927: PPUSH
// uc_side := your_side ;
100928: LD_ADDR_OWVAR 20
100932: PUSH
100933: LD_OWVAR 2
100937: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
100938: LD_VAR 0 1
100942: PUSH
100943: LD_INT 1
100945: PUSH
100946: LD_INT 2
100948: PUSH
100949: LD_INT 3
100951: PUSH
100952: LD_INT 4
100954: PUSH
100955: LD_INT 5
100957: PUSH
100958: EMPTY
100959: LIST
100960: LIST
100961: LIST
100962: LIST
100963: LIST
100964: IN
100965: IFFALSE 100977
// uc_nation := nation_american else
100967: LD_ADDR_OWVAR 21
100971: PUSH
100972: LD_INT 1
100974: ST_TO_ADDR
100975: GO 101020
// if chassis in [ 11 , 12 , 13 , 14 ] then
100977: LD_VAR 0 1
100981: PUSH
100982: LD_INT 11
100984: PUSH
100985: LD_INT 12
100987: PUSH
100988: LD_INT 13
100990: PUSH
100991: LD_INT 14
100993: PUSH
100994: EMPTY
100995: LIST
100996: LIST
100997: LIST
100998: LIST
100999: IN
101000: IFFALSE 101012
// uc_nation := nation_arabian else
101002: LD_ADDR_OWVAR 21
101006: PUSH
101007: LD_INT 2
101009: ST_TO_ADDR
101010: GO 101020
// uc_nation := nation_russian ;
101012: LD_ADDR_OWVAR 21
101016: PUSH
101017: LD_INT 3
101019: ST_TO_ADDR
// vc_chassis := chassis ;
101020: LD_ADDR_OWVAR 37
101024: PUSH
101025: LD_VAR 0 1
101029: ST_TO_ADDR
// vc_engine := engine ;
101030: LD_ADDR_OWVAR 39
101034: PUSH
101035: LD_VAR 0 2
101039: ST_TO_ADDR
// vc_control := control ;
101040: LD_ADDR_OWVAR 38
101044: PUSH
101045: LD_VAR 0 3
101049: ST_TO_ADDR
// vc_weapon := weapon ;
101050: LD_ADDR_OWVAR 40
101054: PUSH
101055: LD_VAR 0 4
101059: ST_TO_ADDR
// un := CreateVehicle ;
101060: LD_ADDR_VAR 0 8
101064: PUSH
101065: CALL_OW 45
101069: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
101070: LD_VAR 0 8
101074: PPUSH
101075: LD_INT 0
101077: PPUSH
101078: LD_INT 5
101080: PPUSH
101081: CALL_OW 12
101085: PPUSH
101086: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
101090: LD_VAR 0 8
101094: PPUSH
101095: LD_VAR 0 5
101099: PPUSH
101100: LD_VAR 0 6
101104: PPUSH
101105: LD_INT 1
101107: PPUSH
101108: CALL_OW 48
// end ;
101112: LD_VAR 0 7
101116: RET
// export hInvincible ; every 1 do
101117: GO 101119
101119: DISABLE
// hInvincible := [ ] ;
101120: LD_ADDR_EXP 164
101124: PUSH
101125: EMPTY
101126: ST_TO_ADDR
101127: END
// every 10 do var i ;
101128: GO 101130
101130: DISABLE
101131: LD_INT 0
101133: PPUSH
// begin enable ;
101134: ENABLE
// if not hInvincible then
101135: LD_EXP 164
101139: NOT
101140: IFFALSE 101144
// exit ;
101142: GO 101188
// for i in hInvincible do
101144: LD_ADDR_VAR 0 1
101148: PUSH
101149: LD_EXP 164
101153: PUSH
101154: FOR_IN
101155: IFFALSE 101186
// if GetLives ( i ) < 1000 then
101157: LD_VAR 0 1
101161: PPUSH
101162: CALL_OW 256
101166: PUSH
101167: LD_INT 1000
101169: LESS
101170: IFFALSE 101184
// SetLives ( i , 1000 ) ;
101172: LD_VAR 0 1
101176: PPUSH
101177: LD_INT 1000
101179: PPUSH
101180: CALL_OW 234
101184: GO 101154
101186: POP
101187: POP
// end ;
101188: PPOPN 1
101190: END
// export function hHackInvincible ; var i ; begin
101191: LD_INT 0
101193: PPUSH
101194: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
101195: LD_ADDR_VAR 0 2
101199: PUSH
101200: LD_INT 2
101202: PUSH
101203: LD_INT 21
101205: PUSH
101206: LD_INT 1
101208: PUSH
101209: EMPTY
101210: LIST
101211: LIST
101212: PUSH
101213: LD_INT 21
101215: PUSH
101216: LD_INT 2
101218: PUSH
101219: EMPTY
101220: LIST
101221: LIST
101222: PUSH
101223: EMPTY
101224: LIST
101225: LIST
101226: LIST
101227: PPUSH
101228: CALL_OW 69
101232: PUSH
101233: FOR_IN
101234: IFFALSE 101295
// if IsSelected ( i ) then
101236: LD_VAR 0 2
101240: PPUSH
101241: CALL_OW 306
101245: IFFALSE 101293
// begin if i in hInvincible then
101247: LD_VAR 0 2
101251: PUSH
101252: LD_EXP 164
101256: IN
101257: IFFALSE 101277
// hInvincible := hInvincible diff i else
101259: LD_ADDR_EXP 164
101263: PUSH
101264: LD_EXP 164
101268: PUSH
101269: LD_VAR 0 2
101273: DIFF
101274: ST_TO_ADDR
101275: GO 101293
// hInvincible := hInvincible union i ;
101277: LD_ADDR_EXP 164
101281: PUSH
101282: LD_EXP 164
101286: PUSH
101287: LD_VAR 0 2
101291: UNION
101292: ST_TO_ADDR
// end ;
101293: GO 101233
101295: POP
101296: POP
// end ;
101297: LD_VAR 0 1
101301: RET
// export function hHackInvisible ; var i , j ; begin
101302: LD_INT 0
101304: PPUSH
101305: PPUSH
101306: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101307: LD_ADDR_VAR 0 2
101311: PUSH
101312: LD_INT 21
101314: PUSH
101315: LD_INT 1
101317: PUSH
101318: EMPTY
101319: LIST
101320: LIST
101321: PPUSH
101322: CALL_OW 69
101326: PUSH
101327: FOR_IN
101328: IFFALSE 101352
// if IsSelected ( i ) then
101330: LD_VAR 0 2
101334: PPUSH
101335: CALL_OW 306
101339: IFFALSE 101350
// ComForceInvisible ( i ) ;
101341: LD_VAR 0 2
101345: PPUSH
101346: CALL_OW 496
101350: GO 101327
101352: POP
101353: POP
// end ;
101354: LD_VAR 0 1
101358: RET
// export function hHackChangeYourSide ; begin
101359: LD_INT 0
101361: PPUSH
// if your_side = 8 then
101362: LD_OWVAR 2
101366: PUSH
101367: LD_INT 8
101369: EQUAL
101370: IFFALSE 101382
// your_side := 0 else
101372: LD_ADDR_OWVAR 2
101376: PUSH
101377: LD_INT 0
101379: ST_TO_ADDR
101380: GO 101396
// your_side := your_side + 1 ;
101382: LD_ADDR_OWVAR 2
101386: PUSH
101387: LD_OWVAR 2
101391: PUSH
101392: LD_INT 1
101394: PLUS
101395: ST_TO_ADDR
// end ;
101396: LD_VAR 0 1
101400: RET
// export function hHackChangeUnitSide ; var i , j ; begin
101401: LD_INT 0
101403: PPUSH
101404: PPUSH
101405: PPUSH
// for i in all_units do
101406: LD_ADDR_VAR 0 2
101410: PUSH
101411: LD_OWVAR 3
101415: PUSH
101416: FOR_IN
101417: IFFALSE 101495
// if IsSelected ( i ) then
101419: LD_VAR 0 2
101423: PPUSH
101424: CALL_OW 306
101428: IFFALSE 101493
// begin j := GetSide ( i ) ;
101430: LD_ADDR_VAR 0 3
101434: PUSH
101435: LD_VAR 0 2
101439: PPUSH
101440: CALL_OW 255
101444: ST_TO_ADDR
// if j = 8 then
101445: LD_VAR 0 3
101449: PUSH
101450: LD_INT 8
101452: EQUAL
101453: IFFALSE 101465
// j := 0 else
101455: LD_ADDR_VAR 0 3
101459: PUSH
101460: LD_INT 0
101462: ST_TO_ADDR
101463: GO 101479
// j := j + 1 ;
101465: LD_ADDR_VAR 0 3
101469: PUSH
101470: LD_VAR 0 3
101474: PUSH
101475: LD_INT 1
101477: PLUS
101478: ST_TO_ADDR
// SetSide ( i , j ) ;
101479: LD_VAR 0 2
101483: PPUSH
101484: LD_VAR 0 3
101488: PPUSH
101489: CALL_OW 235
// end ;
101493: GO 101416
101495: POP
101496: POP
// end ;
101497: LD_VAR 0 1
101501: RET
// export function hHackFog ; begin
101502: LD_INT 0
101504: PPUSH
// FogOff ( true ) ;
101505: LD_INT 1
101507: PPUSH
101508: CALL_OW 344
// end ;
101512: LD_VAR 0 1
101516: RET
// export function hHackTeleport ( unit , x , y ) ; begin
101517: LD_INT 0
101519: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
101520: LD_VAR 0 1
101524: PPUSH
101525: LD_VAR 0 2
101529: PPUSH
101530: LD_VAR 0 3
101534: PPUSH
101535: LD_INT 1
101537: PPUSH
101538: LD_INT 1
101540: PPUSH
101541: CALL_OW 483
// CenterOnXY ( x , y ) ;
101545: LD_VAR 0 2
101549: PPUSH
101550: LD_VAR 0 3
101554: PPUSH
101555: CALL_OW 84
// end ;
101559: LD_VAR 0 4
101563: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
101564: LD_INT 0
101566: PPUSH
101567: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
101568: LD_VAR 0 1
101572: NOT
101573: PUSH
101574: LD_VAR 0 2
101578: PPUSH
101579: LD_VAR 0 3
101583: PPUSH
101584: CALL_OW 488
101588: NOT
101589: OR
101590: PUSH
101591: LD_VAR 0 1
101595: PPUSH
101596: CALL_OW 266
101600: PUSH
101601: LD_INT 3
101603: NONEQUAL
101604: PUSH
101605: LD_VAR 0 1
101609: PPUSH
101610: CALL_OW 247
101614: PUSH
101615: LD_INT 1
101617: EQUAL
101618: NOT
101619: AND
101620: OR
101621: IFFALSE 101625
// exit ;
101623: GO 101774
// if GetType ( factory ) = unit_human then
101625: LD_VAR 0 1
101629: PPUSH
101630: CALL_OW 247
101634: PUSH
101635: LD_INT 1
101637: EQUAL
101638: IFFALSE 101655
// factory := IsInUnit ( factory ) ;
101640: LD_ADDR_VAR 0 1
101644: PUSH
101645: LD_VAR 0 1
101649: PPUSH
101650: CALL_OW 310
101654: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
101655: LD_VAR 0 1
101659: PPUSH
101660: CALL_OW 266
101664: PUSH
101665: LD_INT 3
101667: NONEQUAL
101668: IFFALSE 101672
// exit ;
101670: GO 101774
// if HexInfo ( x , y ) = factory then
101672: LD_VAR 0 2
101676: PPUSH
101677: LD_VAR 0 3
101681: PPUSH
101682: CALL_OW 428
101686: PUSH
101687: LD_VAR 0 1
101691: EQUAL
101692: IFFALSE 101719
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
101694: LD_ADDR_EXP 165
101698: PUSH
101699: LD_EXP 165
101703: PPUSH
101704: LD_VAR 0 1
101708: PPUSH
101709: LD_INT 0
101711: PPUSH
101712: CALL_OW 1
101716: ST_TO_ADDR
101717: GO 101770
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
101719: LD_ADDR_EXP 165
101723: PUSH
101724: LD_EXP 165
101728: PPUSH
101729: LD_VAR 0 1
101733: PPUSH
101734: LD_VAR 0 1
101738: PPUSH
101739: CALL_OW 255
101743: PUSH
101744: LD_VAR 0 1
101748: PUSH
101749: LD_VAR 0 2
101753: PUSH
101754: LD_VAR 0 3
101758: PUSH
101759: EMPTY
101760: LIST
101761: LIST
101762: LIST
101763: LIST
101764: PPUSH
101765: CALL_OW 1
101769: ST_TO_ADDR
// UpdateFactoryWaypoints ;
101770: CALL 101779 0 0
// end ;
101774: LD_VAR 0 4
101778: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
101779: LD_INT 0
101781: PPUSH
101782: PPUSH
101783: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
101784: LD_STRING resetFactoryWaypoint();
101786: PPUSH
101787: CALL_OW 559
// if factoryWaypoints then
101791: LD_EXP 165
101795: IFFALSE 101921
// begin list := PrepareArray ( factoryWaypoints ) ;
101797: LD_ADDR_VAR 0 3
101801: PUSH
101802: LD_EXP 165
101806: PPUSH
101807: CALL 56176 0 1
101811: ST_TO_ADDR
// for i := 1 to list do
101812: LD_ADDR_VAR 0 2
101816: PUSH
101817: DOUBLE
101818: LD_INT 1
101820: DEC
101821: ST_TO_ADDR
101822: LD_VAR 0 3
101826: PUSH
101827: FOR_TO
101828: IFFALSE 101919
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
101830: LD_STRING setFactoryWaypointXY(
101832: PUSH
101833: LD_VAR 0 3
101837: PUSH
101838: LD_VAR 0 2
101842: ARRAY
101843: PUSH
101844: LD_INT 1
101846: ARRAY
101847: STR
101848: PUSH
101849: LD_STRING ,
101851: STR
101852: PUSH
101853: LD_VAR 0 3
101857: PUSH
101858: LD_VAR 0 2
101862: ARRAY
101863: PUSH
101864: LD_INT 2
101866: ARRAY
101867: STR
101868: PUSH
101869: LD_STRING ,
101871: STR
101872: PUSH
101873: LD_VAR 0 3
101877: PUSH
101878: LD_VAR 0 2
101882: ARRAY
101883: PUSH
101884: LD_INT 3
101886: ARRAY
101887: STR
101888: PUSH
101889: LD_STRING ,
101891: STR
101892: PUSH
101893: LD_VAR 0 3
101897: PUSH
101898: LD_VAR 0 2
101902: ARRAY
101903: PUSH
101904: LD_INT 4
101906: ARRAY
101907: STR
101908: PUSH
101909: LD_STRING )
101911: STR
101912: PPUSH
101913: CALL_OW 559
101917: GO 101827
101919: POP
101920: POP
// end ; end ;
101921: LD_VAR 0 1
101925: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
101926: LD_INT 0
101928: PPUSH
// if HexInfo ( x , y ) = warehouse then
101929: LD_VAR 0 2
101933: PPUSH
101934: LD_VAR 0 3
101938: PPUSH
101939: CALL_OW 428
101943: PUSH
101944: LD_VAR 0 1
101948: EQUAL
101949: IFFALSE 101976
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
101951: LD_ADDR_EXP 166
101955: PUSH
101956: LD_EXP 166
101960: PPUSH
101961: LD_VAR 0 1
101965: PPUSH
101966: LD_INT 0
101968: PPUSH
101969: CALL_OW 1
101973: ST_TO_ADDR
101974: GO 102027
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
101976: LD_ADDR_EXP 166
101980: PUSH
101981: LD_EXP 166
101985: PPUSH
101986: LD_VAR 0 1
101990: PPUSH
101991: LD_VAR 0 1
101995: PPUSH
101996: CALL_OW 255
102000: PUSH
102001: LD_VAR 0 1
102005: PUSH
102006: LD_VAR 0 2
102010: PUSH
102011: LD_VAR 0 3
102015: PUSH
102016: EMPTY
102017: LIST
102018: LIST
102019: LIST
102020: LIST
102021: PPUSH
102022: CALL_OW 1
102026: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
102027: CALL 102036 0 0
// end ;
102031: LD_VAR 0 4
102035: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
102036: LD_INT 0
102038: PPUSH
102039: PPUSH
102040: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
102041: LD_STRING resetWarehouseGatheringPoints();
102043: PPUSH
102044: CALL_OW 559
// if warehouseGatheringPoints then
102048: LD_EXP 166
102052: IFFALSE 102178
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
102054: LD_ADDR_VAR 0 3
102058: PUSH
102059: LD_EXP 166
102063: PPUSH
102064: CALL 56176 0 1
102068: ST_TO_ADDR
// for i := 1 to list do
102069: LD_ADDR_VAR 0 2
102073: PUSH
102074: DOUBLE
102075: LD_INT 1
102077: DEC
102078: ST_TO_ADDR
102079: LD_VAR 0 3
102083: PUSH
102084: FOR_TO
102085: IFFALSE 102176
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
102087: LD_STRING setWarehouseGatheringPointXY(
102089: PUSH
102090: LD_VAR 0 3
102094: PUSH
102095: LD_VAR 0 2
102099: ARRAY
102100: PUSH
102101: LD_INT 1
102103: ARRAY
102104: STR
102105: PUSH
102106: LD_STRING ,
102108: STR
102109: PUSH
102110: LD_VAR 0 3
102114: PUSH
102115: LD_VAR 0 2
102119: ARRAY
102120: PUSH
102121: LD_INT 2
102123: ARRAY
102124: STR
102125: PUSH
102126: LD_STRING ,
102128: STR
102129: PUSH
102130: LD_VAR 0 3
102134: PUSH
102135: LD_VAR 0 2
102139: ARRAY
102140: PUSH
102141: LD_INT 3
102143: ARRAY
102144: STR
102145: PUSH
102146: LD_STRING ,
102148: STR
102149: PUSH
102150: LD_VAR 0 3
102154: PUSH
102155: LD_VAR 0 2
102159: ARRAY
102160: PUSH
102161: LD_INT 4
102163: ARRAY
102164: STR
102165: PUSH
102166: LD_STRING )
102168: STR
102169: PPUSH
102170: CALL_OW 559
102174: GO 102084
102176: POP
102177: POP
// end ; end ;
102178: LD_VAR 0 1
102182: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
102183: LD_EXP 166
102187: IFFALSE 102872
102189: GO 102191
102191: DISABLE
102192: LD_INT 0
102194: PPUSH
102195: PPUSH
102196: PPUSH
102197: PPUSH
102198: PPUSH
102199: PPUSH
102200: PPUSH
102201: PPUSH
102202: PPUSH
// begin enable ;
102203: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
102204: LD_ADDR_VAR 0 3
102208: PUSH
102209: LD_EXP 166
102213: PPUSH
102214: CALL 56176 0 1
102218: ST_TO_ADDR
// if not list then
102219: LD_VAR 0 3
102223: NOT
102224: IFFALSE 102228
// exit ;
102226: GO 102872
// for i := 1 to list do
102228: LD_ADDR_VAR 0 1
102232: PUSH
102233: DOUBLE
102234: LD_INT 1
102236: DEC
102237: ST_TO_ADDR
102238: LD_VAR 0 3
102242: PUSH
102243: FOR_TO
102244: IFFALSE 102870
// begin depot := list [ i ] [ 2 ] ;
102246: LD_ADDR_VAR 0 8
102250: PUSH
102251: LD_VAR 0 3
102255: PUSH
102256: LD_VAR 0 1
102260: ARRAY
102261: PUSH
102262: LD_INT 2
102264: ARRAY
102265: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
102266: LD_ADDR_VAR 0 5
102270: PUSH
102271: LD_VAR 0 3
102275: PUSH
102276: LD_VAR 0 1
102280: ARRAY
102281: PUSH
102282: LD_INT 1
102284: ARRAY
102285: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
102286: LD_VAR 0 8
102290: PPUSH
102291: CALL_OW 301
102295: PUSH
102296: LD_VAR 0 5
102300: PUSH
102301: LD_VAR 0 8
102305: PPUSH
102306: CALL_OW 255
102310: NONEQUAL
102311: OR
102312: IFFALSE 102341
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
102314: LD_ADDR_EXP 166
102318: PUSH
102319: LD_EXP 166
102323: PPUSH
102324: LD_VAR 0 8
102328: PPUSH
102329: LD_INT 0
102331: PPUSH
102332: CALL_OW 1
102336: ST_TO_ADDR
// exit ;
102337: POP
102338: POP
102339: GO 102872
// end ; x := list [ i ] [ 3 ] ;
102341: LD_ADDR_VAR 0 6
102345: PUSH
102346: LD_VAR 0 3
102350: PUSH
102351: LD_VAR 0 1
102355: ARRAY
102356: PUSH
102357: LD_INT 3
102359: ARRAY
102360: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
102361: LD_ADDR_VAR 0 7
102365: PUSH
102366: LD_VAR 0 3
102370: PUSH
102371: LD_VAR 0 1
102375: ARRAY
102376: PUSH
102377: LD_INT 4
102379: ARRAY
102380: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
102381: LD_ADDR_VAR 0 9
102385: PUSH
102386: LD_VAR 0 6
102390: PPUSH
102391: LD_VAR 0 7
102395: PPUSH
102396: LD_INT 16
102398: PPUSH
102399: CALL 54764 0 3
102403: ST_TO_ADDR
// if not cratesNearbyPoint then
102404: LD_VAR 0 9
102408: NOT
102409: IFFALSE 102415
// exit ;
102411: POP
102412: POP
102413: GO 102872
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
102415: LD_ADDR_VAR 0 4
102419: PUSH
102420: LD_INT 22
102422: PUSH
102423: LD_VAR 0 5
102427: PUSH
102428: EMPTY
102429: LIST
102430: LIST
102431: PUSH
102432: LD_INT 3
102434: PUSH
102435: LD_INT 60
102437: PUSH
102438: EMPTY
102439: LIST
102440: PUSH
102441: EMPTY
102442: LIST
102443: LIST
102444: PUSH
102445: LD_INT 91
102447: PUSH
102448: LD_VAR 0 8
102452: PUSH
102453: LD_INT 6
102455: PUSH
102456: EMPTY
102457: LIST
102458: LIST
102459: LIST
102460: PUSH
102461: LD_INT 2
102463: PUSH
102464: LD_INT 25
102466: PUSH
102467: LD_INT 2
102469: PUSH
102470: EMPTY
102471: LIST
102472: LIST
102473: PUSH
102474: LD_INT 25
102476: PUSH
102477: LD_INT 16
102479: PUSH
102480: EMPTY
102481: LIST
102482: LIST
102483: PUSH
102484: EMPTY
102485: LIST
102486: LIST
102487: LIST
102488: PUSH
102489: EMPTY
102490: LIST
102491: LIST
102492: LIST
102493: LIST
102494: PPUSH
102495: CALL_OW 69
102499: PUSH
102500: LD_VAR 0 8
102504: PPUSH
102505: CALL_OW 313
102509: PPUSH
102510: LD_INT 3
102512: PUSH
102513: LD_INT 60
102515: PUSH
102516: EMPTY
102517: LIST
102518: PUSH
102519: EMPTY
102520: LIST
102521: LIST
102522: PUSH
102523: LD_INT 2
102525: PUSH
102526: LD_INT 25
102528: PUSH
102529: LD_INT 2
102531: PUSH
102532: EMPTY
102533: LIST
102534: LIST
102535: PUSH
102536: LD_INT 25
102538: PUSH
102539: LD_INT 16
102541: PUSH
102542: EMPTY
102543: LIST
102544: LIST
102545: PUSH
102546: EMPTY
102547: LIST
102548: LIST
102549: LIST
102550: PUSH
102551: EMPTY
102552: LIST
102553: LIST
102554: PPUSH
102555: CALL_OW 72
102559: UNION
102560: ST_TO_ADDR
// if tmp then
102561: LD_VAR 0 4
102565: IFFALSE 102645
// begin tmp := ShrinkArray ( tmp , 3 ) ;
102567: LD_ADDR_VAR 0 4
102571: PUSH
102572: LD_VAR 0 4
102576: PPUSH
102577: LD_INT 3
102579: PPUSH
102580: CALL 52733 0 2
102584: ST_TO_ADDR
// for j in tmp do
102585: LD_ADDR_VAR 0 2
102589: PUSH
102590: LD_VAR 0 4
102594: PUSH
102595: FOR_IN
102596: IFFALSE 102639
// begin if IsInUnit ( j ) then
102598: LD_VAR 0 2
102602: PPUSH
102603: CALL_OW 310
102607: IFFALSE 102618
// ComExit ( j ) ;
102609: LD_VAR 0 2
102613: PPUSH
102614: CALL 52816 0 1
// AddComCollect ( j , x , y ) ;
102618: LD_VAR 0 2
102622: PPUSH
102623: LD_VAR 0 6
102627: PPUSH
102628: LD_VAR 0 7
102632: PPUSH
102633: CALL_OW 177
// end ;
102637: GO 102595
102639: POP
102640: POP
// exit ;
102641: POP
102642: POP
102643: GO 102872
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
102645: LD_ADDR_VAR 0 4
102649: PUSH
102650: LD_INT 22
102652: PUSH
102653: LD_VAR 0 5
102657: PUSH
102658: EMPTY
102659: LIST
102660: LIST
102661: PUSH
102662: LD_INT 91
102664: PUSH
102665: LD_VAR 0 8
102669: PUSH
102670: LD_INT 8
102672: PUSH
102673: EMPTY
102674: LIST
102675: LIST
102676: LIST
102677: PUSH
102678: LD_INT 2
102680: PUSH
102681: LD_INT 34
102683: PUSH
102684: LD_INT 12
102686: PUSH
102687: EMPTY
102688: LIST
102689: LIST
102690: PUSH
102691: LD_INT 34
102693: PUSH
102694: LD_INT 51
102696: PUSH
102697: EMPTY
102698: LIST
102699: LIST
102700: PUSH
102701: LD_INT 34
102703: PUSH
102704: LD_INT 32
102706: PUSH
102707: EMPTY
102708: LIST
102709: LIST
102710: PUSH
102711: LD_INT 34
102713: PUSH
102714: LD_INT 89
102716: PUSH
102717: EMPTY
102718: LIST
102719: LIST
102720: PUSH
102721: EMPTY
102722: LIST
102723: LIST
102724: LIST
102725: LIST
102726: LIST
102727: PUSH
102728: EMPTY
102729: LIST
102730: LIST
102731: LIST
102732: PPUSH
102733: CALL_OW 69
102737: ST_TO_ADDR
// if tmp then
102738: LD_VAR 0 4
102742: IFFALSE 102868
// begin for j in tmp do
102744: LD_ADDR_VAR 0 2
102748: PUSH
102749: LD_VAR 0 4
102753: PUSH
102754: FOR_IN
102755: IFFALSE 102866
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
102757: LD_VAR 0 2
102761: PPUSH
102762: CALL_OW 262
102766: PUSH
102767: LD_INT 3
102769: EQUAL
102770: PUSH
102771: LD_VAR 0 2
102775: PPUSH
102776: CALL_OW 261
102780: PUSH
102781: LD_INT 20
102783: GREATER
102784: OR
102785: PUSH
102786: LD_VAR 0 2
102790: PPUSH
102791: CALL_OW 314
102795: NOT
102796: AND
102797: PUSH
102798: LD_VAR 0 2
102802: PPUSH
102803: CALL_OW 263
102807: PUSH
102808: LD_INT 1
102810: NONEQUAL
102811: PUSH
102812: LD_VAR 0 2
102816: PPUSH
102817: CALL_OW 311
102821: OR
102822: AND
102823: IFFALSE 102864
// begin ComCollect ( j , x , y ) ;
102825: LD_VAR 0 2
102829: PPUSH
102830: LD_VAR 0 6
102834: PPUSH
102835: LD_VAR 0 7
102839: PPUSH
102840: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
102844: LD_VAR 0 2
102848: PPUSH
102849: LD_VAR 0 8
102853: PPUSH
102854: CALL_OW 172
// exit ;
102858: POP
102859: POP
102860: POP
102861: POP
102862: GO 102872
// end ;
102864: GO 102754
102866: POP
102867: POP
// end ; end ;
102868: GO 102243
102870: POP
102871: POP
// end ; end_of_file
102872: PPOPN 9
102874: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
102875: LD_INT 0
102877: PPUSH
102878: PPUSH
102879: PPUSH
102880: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
102881: LD_VAR 0 1
102885: PPUSH
102886: CALL_OW 264
102890: PUSH
102891: LD_INT 91
102893: EQUAL
102894: IFFALSE 102966
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
102896: LD_INT 68
102898: PPUSH
102899: LD_VAR 0 1
102903: PPUSH
102904: CALL_OW 255
102908: PPUSH
102909: CALL_OW 321
102913: PUSH
102914: LD_INT 2
102916: EQUAL
102917: IFFALSE 102929
// eff := 70 else
102919: LD_ADDR_VAR 0 4
102923: PUSH
102924: LD_INT 70
102926: ST_TO_ADDR
102927: GO 102937
// eff := 30 ;
102929: LD_ADDR_VAR 0 4
102933: PUSH
102934: LD_INT 30
102936: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
102937: LD_VAR 0 1
102941: PPUSH
102942: CALL_OW 250
102946: PPUSH
102947: LD_VAR 0 1
102951: PPUSH
102952: CALL_OW 251
102956: PPUSH
102957: LD_VAR 0 4
102961: PPUSH
102962: CALL_OW 495
// end ; end ;
102966: LD_VAR 0 2
102970: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
102971: LD_INT 0
102973: PPUSH
// end ;
102974: LD_VAR 0 4
102978: RET
// export function SOS_Command ( cmd ) ; begin
102979: LD_INT 0
102981: PPUSH
// end ;
102982: LD_VAR 0 2
102986: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
102987: LD_INT 0
102989: PPUSH
// end ;
102990: LD_VAR 0 6
102994: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
102995: LD_INT 0
102997: PPUSH
102998: PPUSH
// if not vehicle or not factory then
102999: LD_VAR 0 1
103003: NOT
103004: PUSH
103005: LD_VAR 0 2
103009: NOT
103010: OR
103011: IFFALSE 103015
// exit ;
103013: GO 103246
// if factoryWaypoints >= factory then
103015: LD_EXP 165
103019: PUSH
103020: LD_VAR 0 2
103024: GREATEREQUAL
103025: IFFALSE 103246
// if factoryWaypoints [ factory ] then
103027: LD_EXP 165
103031: PUSH
103032: LD_VAR 0 2
103036: ARRAY
103037: IFFALSE 103246
// begin if GetControl ( vehicle ) = control_manual then
103039: LD_VAR 0 1
103043: PPUSH
103044: CALL_OW 263
103048: PUSH
103049: LD_INT 1
103051: EQUAL
103052: IFFALSE 103133
// begin driver := IsDrivenBy ( vehicle ) ;
103054: LD_ADDR_VAR 0 4
103058: PUSH
103059: LD_VAR 0 1
103063: PPUSH
103064: CALL_OW 311
103068: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103069: LD_VAR 0 4
103073: PPUSH
103074: LD_EXP 165
103078: PUSH
103079: LD_VAR 0 2
103083: ARRAY
103084: PUSH
103085: LD_INT 3
103087: ARRAY
103088: PPUSH
103089: LD_EXP 165
103093: PUSH
103094: LD_VAR 0 2
103098: ARRAY
103099: PUSH
103100: LD_INT 4
103102: ARRAY
103103: PPUSH
103104: CALL_OW 171
// AddComExitVehicle ( driver ) ;
103108: LD_VAR 0 4
103112: PPUSH
103113: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
103117: LD_VAR 0 4
103121: PPUSH
103122: LD_VAR 0 2
103126: PPUSH
103127: CALL_OW 180
// end else
103131: GO 103246
// if GetControl ( vehicle ) = control_remote then
103133: LD_VAR 0 1
103137: PPUSH
103138: CALL_OW 263
103142: PUSH
103143: LD_INT 2
103145: EQUAL
103146: IFFALSE 103207
// begin wait ( 0 0$2 ) ;
103148: LD_INT 70
103150: PPUSH
103151: CALL_OW 67
// if Connect ( vehicle ) then
103155: LD_VAR 0 1
103159: PPUSH
103160: CALL 23056 0 1
103164: IFFALSE 103205
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103166: LD_VAR 0 1
103170: PPUSH
103171: LD_EXP 165
103175: PUSH
103176: LD_VAR 0 2
103180: ARRAY
103181: PUSH
103182: LD_INT 3
103184: ARRAY
103185: PPUSH
103186: LD_EXP 165
103190: PUSH
103191: LD_VAR 0 2
103195: ARRAY
103196: PUSH
103197: LD_INT 4
103199: ARRAY
103200: PPUSH
103201: CALL_OW 171
// end else
103205: GO 103246
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103207: LD_VAR 0 1
103211: PPUSH
103212: LD_EXP 165
103216: PUSH
103217: LD_VAR 0 2
103221: ARRAY
103222: PUSH
103223: LD_INT 3
103225: ARRAY
103226: PPUSH
103227: LD_EXP 165
103231: PUSH
103232: LD_VAR 0 2
103236: ARRAY
103237: PUSH
103238: LD_INT 4
103240: ARRAY
103241: PPUSH
103242: CALL_OW 171
// end ; end ;
103246: LD_VAR 0 3
103250: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
103251: LD_INT 0
103253: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
103254: LD_VAR 0 1
103258: PUSH
103259: LD_INT 250
103261: EQUAL
103262: PUSH
103263: LD_VAR 0 2
103267: PPUSH
103268: CALL_OW 264
103272: PUSH
103273: LD_INT 81
103275: EQUAL
103276: AND
103277: IFFALSE 103298
// MinerPlaceMine ( unit , x , y ) ;
103279: LD_VAR 0 2
103283: PPUSH
103284: LD_VAR 0 4
103288: PPUSH
103289: LD_VAR 0 5
103293: PPUSH
103294: CALL 105683 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
103298: LD_VAR 0 1
103302: PUSH
103303: LD_INT 251
103305: EQUAL
103306: PUSH
103307: LD_VAR 0 2
103311: PPUSH
103312: CALL_OW 264
103316: PUSH
103317: LD_INT 81
103319: EQUAL
103320: AND
103321: IFFALSE 103342
// MinerDetonateMine ( unit , x , y ) ;
103323: LD_VAR 0 2
103327: PPUSH
103328: LD_VAR 0 4
103332: PPUSH
103333: LD_VAR 0 5
103337: PPUSH
103338: CALL 105958 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
103342: LD_VAR 0 1
103346: PUSH
103347: LD_INT 252
103349: EQUAL
103350: PUSH
103351: LD_VAR 0 2
103355: PPUSH
103356: CALL_OW 264
103360: PUSH
103361: LD_INT 81
103363: EQUAL
103364: AND
103365: IFFALSE 103386
// MinerCreateMinefield ( unit , x , y ) ;
103367: LD_VAR 0 2
103371: PPUSH
103372: LD_VAR 0 4
103376: PPUSH
103377: LD_VAR 0 5
103381: PPUSH
103382: CALL 106375 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
103386: LD_VAR 0 1
103390: PUSH
103391: LD_INT 253
103393: EQUAL
103394: PUSH
103395: LD_VAR 0 2
103399: PPUSH
103400: CALL_OW 257
103404: PUSH
103405: LD_INT 5
103407: EQUAL
103408: AND
103409: IFFALSE 103430
// ComBinocular ( unit , x , y ) ;
103411: LD_VAR 0 2
103415: PPUSH
103416: LD_VAR 0 4
103420: PPUSH
103421: LD_VAR 0 5
103425: PPUSH
103426: CALL 106744 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
103430: LD_VAR 0 1
103434: PUSH
103435: LD_INT 254
103437: EQUAL
103438: PUSH
103439: LD_VAR 0 2
103443: PPUSH
103444: CALL_OW 264
103448: PUSH
103449: LD_INT 99
103451: EQUAL
103452: AND
103453: PUSH
103454: LD_VAR 0 3
103458: PPUSH
103459: CALL_OW 263
103463: PUSH
103464: LD_INT 3
103466: EQUAL
103467: AND
103468: IFFALSE 103484
// HackDestroyVehicle ( unit , selectedUnit ) ;
103470: LD_VAR 0 2
103474: PPUSH
103475: LD_VAR 0 3
103479: PPUSH
103480: CALL 105047 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
103484: LD_VAR 0 1
103488: PUSH
103489: LD_INT 255
103491: EQUAL
103492: PUSH
103493: LD_VAR 0 2
103497: PPUSH
103498: CALL_OW 264
103502: PUSH
103503: LD_INT 14
103505: PUSH
103506: LD_INT 53
103508: PUSH
103509: EMPTY
103510: LIST
103511: LIST
103512: IN
103513: AND
103514: PUSH
103515: LD_VAR 0 4
103519: PPUSH
103520: LD_VAR 0 5
103524: PPUSH
103525: CALL_OW 488
103529: AND
103530: IFFALSE 103554
// CutTreeXYR ( unit , x , y , 12 ) ;
103532: LD_VAR 0 2
103536: PPUSH
103537: LD_VAR 0 4
103541: PPUSH
103542: LD_VAR 0 5
103546: PPUSH
103547: LD_INT 12
103549: PPUSH
103550: CALL 103617 0 4
// if cmd = 256 then
103554: LD_VAR 0 1
103558: PUSH
103559: LD_INT 256
103561: EQUAL
103562: IFFALSE 103583
// SetFactoryWaypoint ( unit , x , y ) ;
103564: LD_VAR 0 2
103568: PPUSH
103569: LD_VAR 0 4
103573: PPUSH
103574: LD_VAR 0 5
103578: PPUSH
103579: CALL 101564 0 3
// if cmd = 257 then
103583: LD_VAR 0 1
103587: PUSH
103588: LD_INT 257
103590: EQUAL
103591: IFFALSE 103612
// SetWarehouseGatheringPoint ( unit , x , y ) ;
103593: LD_VAR 0 2
103597: PPUSH
103598: LD_VAR 0 4
103602: PPUSH
103603: LD_VAR 0 5
103607: PPUSH
103608: CALL 101926 0 3
// end ;
103612: LD_VAR 0 6
103616: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
103617: LD_INT 0
103619: PPUSH
103620: PPUSH
103621: PPUSH
103622: PPUSH
103623: PPUSH
103624: PPUSH
103625: PPUSH
103626: PPUSH
103627: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
103628: LD_VAR 0 1
103632: NOT
103633: PUSH
103634: LD_VAR 0 2
103638: PPUSH
103639: LD_VAR 0 3
103643: PPUSH
103644: CALL_OW 488
103648: NOT
103649: OR
103650: PUSH
103651: LD_VAR 0 4
103655: NOT
103656: OR
103657: IFFALSE 103661
// exit ;
103659: GO 104001
// list := [ ] ;
103661: LD_ADDR_VAR 0 13
103665: PUSH
103666: EMPTY
103667: ST_TO_ADDR
// if x - r < 0 then
103668: LD_VAR 0 2
103672: PUSH
103673: LD_VAR 0 4
103677: MINUS
103678: PUSH
103679: LD_INT 0
103681: LESS
103682: IFFALSE 103694
// min_x := 0 else
103684: LD_ADDR_VAR 0 7
103688: PUSH
103689: LD_INT 0
103691: ST_TO_ADDR
103692: GO 103710
// min_x := x - r ;
103694: LD_ADDR_VAR 0 7
103698: PUSH
103699: LD_VAR 0 2
103703: PUSH
103704: LD_VAR 0 4
103708: MINUS
103709: ST_TO_ADDR
// if y - r < 0 then
103710: LD_VAR 0 3
103714: PUSH
103715: LD_VAR 0 4
103719: MINUS
103720: PUSH
103721: LD_INT 0
103723: LESS
103724: IFFALSE 103736
// min_y := 0 else
103726: LD_ADDR_VAR 0 8
103730: PUSH
103731: LD_INT 0
103733: ST_TO_ADDR
103734: GO 103752
// min_y := y - r ;
103736: LD_ADDR_VAR 0 8
103740: PUSH
103741: LD_VAR 0 3
103745: PUSH
103746: LD_VAR 0 4
103750: MINUS
103751: ST_TO_ADDR
// max_x := x + r ;
103752: LD_ADDR_VAR 0 9
103756: PUSH
103757: LD_VAR 0 2
103761: PUSH
103762: LD_VAR 0 4
103766: PLUS
103767: ST_TO_ADDR
// max_y := y + r ;
103768: LD_ADDR_VAR 0 10
103772: PUSH
103773: LD_VAR 0 3
103777: PUSH
103778: LD_VAR 0 4
103782: PLUS
103783: ST_TO_ADDR
// for _x = min_x to max_x do
103784: LD_ADDR_VAR 0 11
103788: PUSH
103789: DOUBLE
103790: LD_VAR 0 7
103794: DEC
103795: ST_TO_ADDR
103796: LD_VAR 0 9
103800: PUSH
103801: FOR_TO
103802: IFFALSE 103919
// for _y = min_y to max_y do
103804: LD_ADDR_VAR 0 12
103808: PUSH
103809: DOUBLE
103810: LD_VAR 0 8
103814: DEC
103815: ST_TO_ADDR
103816: LD_VAR 0 10
103820: PUSH
103821: FOR_TO
103822: IFFALSE 103915
// begin if not ValidHex ( _x , _y ) then
103824: LD_VAR 0 11
103828: PPUSH
103829: LD_VAR 0 12
103833: PPUSH
103834: CALL_OW 488
103838: NOT
103839: IFFALSE 103843
// continue ;
103841: GO 103821
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
103843: LD_VAR 0 11
103847: PPUSH
103848: LD_VAR 0 12
103852: PPUSH
103853: CALL_OW 351
103857: PUSH
103858: LD_VAR 0 11
103862: PPUSH
103863: LD_VAR 0 12
103867: PPUSH
103868: CALL_OW 554
103872: AND
103873: IFFALSE 103913
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
103875: LD_ADDR_VAR 0 13
103879: PUSH
103880: LD_VAR 0 13
103884: PPUSH
103885: LD_VAR 0 13
103889: PUSH
103890: LD_INT 1
103892: PLUS
103893: PPUSH
103894: LD_VAR 0 11
103898: PUSH
103899: LD_VAR 0 12
103903: PUSH
103904: EMPTY
103905: LIST
103906: LIST
103907: PPUSH
103908: CALL_OW 2
103912: ST_TO_ADDR
// end ;
103913: GO 103821
103915: POP
103916: POP
103917: GO 103801
103919: POP
103920: POP
// if not list then
103921: LD_VAR 0 13
103925: NOT
103926: IFFALSE 103930
// exit ;
103928: GO 104001
// for i in list do
103930: LD_ADDR_VAR 0 6
103934: PUSH
103935: LD_VAR 0 13
103939: PUSH
103940: FOR_IN
103941: IFFALSE 103999
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
103943: LD_VAR 0 1
103947: PPUSH
103948: LD_STRING M
103950: PUSH
103951: LD_VAR 0 6
103955: PUSH
103956: LD_INT 1
103958: ARRAY
103959: PUSH
103960: LD_VAR 0 6
103964: PUSH
103965: LD_INT 2
103967: ARRAY
103968: PUSH
103969: LD_INT 0
103971: PUSH
103972: LD_INT 0
103974: PUSH
103975: LD_INT 0
103977: PUSH
103978: LD_INT 0
103980: PUSH
103981: EMPTY
103982: LIST
103983: LIST
103984: LIST
103985: LIST
103986: LIST
103987: LIST
103988: LIST
103989: PUSH
103990: EMPTY
103991: LIST
103992: PPUSH
103993: CALL_OW 447
103997: GO 103940
103999: POP
104000: POP
// end ;
104001: LD_VAR 0 5
104005: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
104006: LD_EXP 168
104010: NOT
104011: IFFALSE 104061
104013: GO 104015
104015: DISABLE
// begin initHack := true ;
104016: LD_ADDR_EXP 168
104020: PUSH
104021: LD_INT 1
104023: ST_TO_ADDR
// hackTanks := [ ] ;
104024: LD_ADDR_EXP 169
104028: PUSH
104029: EMPTY
104030: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
104031: LD_ADDR_EXP 170
104035: PUSH
104036: EMPTY
104037: ST_TO_ADDR
// hackLimit := 3 ;
104038: LD_ADDR_EXP 171
104042: PUSH
104043: LD_INT 3
104045: ST_TO_ADDR
// hackDist := 12 ;
104046: LD_ADDR_EXP 172
104050: PUSH
104051: LD_INT 12
104053: ST_TO_ADDR
// hackCounter := [ ] ;
104054: LD_ADDR_EXP 173
104058: PUSH
104059: EMPTY
104060: ST_TO_ADDR
// end ;
104061: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
104062: LD_EXP 168
104066: PUSH
104067: LD_INT 34
104069: PUSH
104070: LD_INT 99
104072: PUSH
104073: EMPTY
104074: LIST
104075: LIST
104076: PPUSH
104077: CALL_OW 69
104081: AND
104082: IFFALSE 104335
104084: GO 104086
104086: DISABLE
104087: LD_INT 0
104089: PPUSH
104090: PPUSH
// begin enable ;
104091: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
104092: LD_ADDR_VAR 0 1
104096: PUSH
104097: LD_INT 34
104099: PUSH
104100: LD_INT 99
104102: PUSH
104103: EMPTY
104104: LIST
104105: LIST
104106: PPUSH
104107: CALL_OW 69
104111: PUSH
104112: FOR_IN
104113: IFFALSE 104333
// begin if not i in hackTanks then
104115: LD_VAR 0 1
104119: PUSH
104120: LD_EXP 169
104124: IN
104125: NOT
104126: IFFALSE 104209
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
104128: LD_ADDR_EXP 169
104132: PUSH
104133: LD_EXP 169
104137: PPUSH
104138: LD_EXP 169
104142: PUSH
104143: LD_INT 1
104145: PLUS
104146: PPUSH
104147: LD_VAR 0 1
104151: PPUSH
104152: CALL_OW 1
104156: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
104157: LD_ADDR_EXP 170
104161: PUSH
104162: LD_EXP 170
104166: PPUSH
104167: LD_EXP 170
104171: PUSH
104172: LD_INT 1
104174: PLUS
104175: PPUSH
104176: EMPTY
104177: PPUSH
104178: CALL_OW 1
104182: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
104183: LD_ADDR_EXP 173
104187: PUSH
104188: LD_EXP 173
104192: PPUSH
104193: LD_EXP 173
104197: PUSH
104198: LD_INT 1
104200: PLUS
104201: PPUSH
104202: EMPTY
104203: PPUSH
104204: CALL_OW 1
104208: ST_TO_ADDR
// end ; if not IsOk ( i ) then
104209: LD_VAR 0 1
104213: PPUSH
104214: CALL_OW 302
104218: NOT
104219: IFFALSE 104232
// begin HackUnlinkAll ( i ) ;
104221: LD_VAR 0 1
104225: PPUSH
104226: CALL 104338 0 1
// continue ;
104230: GO 104112
// end ; HackCheckCapturedStatus ( i ) ;
104232: LD_VAR 0 1
104236: PPUSH
104237: CALL 104781 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
104241: LD_ADDR_VAR 0 2
104245: PUSH
104246: LD_INT 81
104248: PUSH
104249: LD_VAR 0 1
104253: PPUSH
104254: CALL_OW 255
104258: PUSH
104259: EMPTY
104260: LIST
104261: LIST
104262: PUSH
104263: LD_INT 33
104265: PUSH
104266: LD_INT 3
104268: PUSH
104269: EMPTY
104270: LIST
104271: LIST
104272: PUSH
104273: LD_INT 91
104275: PUSH
104276: LD_VAR 0 1
104280: PUSH
104281: LD_EXP 172
104285: PUSH
104286: EMPTY
104287: LIST
104288: LIST
104289: LIST
104290: PUSH
104291: LD_INT 50
104293: PUSH
104294: EMPTY
104295: LIST
104296: PUSH
104297: EMPTY
104298: LIST
104299: LIST
104300: LIST
104301: LIST
104302: PPUSH
104303: CALL_OW 69
104307: ST_TO_ADDR
// if not tmp then
104308: LD_VAR 0 2
104312: NOT
104313: IFFALSE 104317
// continue ;
104315: GO 104112
// HackLink ( i , tmp ) ;
104317: LD_VAR 0 1
104321: PPUSH
104322: LD_VAR 0 2
104326: PPUSH
104327: CALL 104474 0 2
// end ;
104331: GO 104112
104333: POP
104334: POP
// end ;
104335: PPOPN 2
104337: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
104338: LD_INT 0
104340: PPUSH
104341: PPUSH
104342: PPUSH
// if not hack in hackTanks then
104343: LD_VAR 0 1
104347: PUSH
104348: LD_EXP 169
104352: IN
104353: NOT
104354: IFFALSE 104358
// exit ;
104356: GO 104469
// index := GetElementIndex ( hackTanks , hack ) ;
104358: LD_ADDR_VAR 0 4
104362: PUSH
104363: LD_EXP 169
104367: PPUSH
104368: LD_VAR 0 1
104372: PPUSH
104373: CALL 19872 0 2
104377: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
104378: LD_EXP 170
104382: PUSH
104383: LD_VAR 0 4
104387: ARRAY
104388: IFFALSE 104469
// begin for i in hackTanksCaptured [ index ] do
104390: LD_ADDR_VAR 0 3
104394: PUSH
104395: LD_EXP 170
104399: PUSH
104400: LD_VAR 0 4
104404: ARRAY
104405: PUSH
104406: FOR_IN
104407: IFFALSE 104433
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
104409: LD_VAR 0 3
104413: PUSH
104414: LD_INT 1
104416: ARRAY
104417: PPUSH
104418: LD_VAR 0 3
104422: PUSH
104423: LD_INT 2
104425: ARRAY
104426: PPUSH
104427: CALL_OW 235
104431: GO 104406
104433: POP
104434: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
104435: LD_ADDR_EXP 170
104439: PUSH
104440: LD_EXP 170
104444: PPUSH
104445: LD_VAR 0 4
104449: PPUSH
104450: EMPTY
104451: PPUSH
104452: CALL_OW 1
104456: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
104457: LD_VAR 0 1
104461: PPUSH
104462: LD_INT 0
104464: PPUSH
104465: CALL_OW 505
// end ; end ;
104469: LD_VAR 0 2
104473: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
104474: LD_INT 0
104476: PPUSH
104477: PPUSH
104478: PPUSH
// if not hack in hackTanks or not vehicles then
104479: LD_VAR 0 1
104483: PUSH
104484: LD_EXP 169
104488: IN
104489: NOT
104490: PUSH
104491: LD_VAR 0 2
104495: NOT
104496: OR
104497: IFFALSE 104501
// exit ;
104499: GO 104776
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
104501: LD_ADDR_VAR 0 2
104505: PUSH
104506: LD_VAR 0 1
104510: PPUSH
104511: LD_VAR 0 2
104515: PPUSH
104516: LD_INT 1
104518: PPUSH
104519: LD_INT 1
104521: PPUSH
104522: CALL 20522 0 4
104526: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
104527: LD_ADDR_VAR 0 5
104531: PUSH
104532: LD_EXP 169
104536: PPUSH
104537: LD_VAR 0 1
104541: PPUSH
104542: CALL 19872 0 2
104546: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
104547: LD_EXP 170
104551: PUSH
104552: LD_VAR 0 5
104556: ARRAY
104557: PUSH
104558: LD_EXP 171
104562: LESS
104563: IFFALSE 104752
// begin for i := 1 to vehicles do
104565: LD_ADDR_VAR 0 4
104569: PUSH
104570: DOUBLE
104571: LD_INT 1
104573: DEC
104574: ST_TO_ADDR
104575: LD_VAR 0 2
104579: PUSH
104580: FOR_TO
104581: IFFALSE 104750
// begin if hackTanksCaptured [ index ] = hackLimit then
104583: LD_EXP 170
104587: PUSH
104588: LD_VAR 0 5
104592: ARRAY
104593: PUSH
104594: LD_EXP 171
104598: EQUAL
104599: IFFALSE 104603
// break ;
104601: GO 104750
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
104603: LD_ADDR_EXP 173
104607: PUSH
104608: LD_EXP 173
104612: PPUSH
104613: LD_VAR 0 5
104617: PPUSH
104618: LD_EXP 173
104622: PUSH
104623: LD_VAR 0 5
104627: ARRAY
104628: PUSH
104629: LD_INT 1
104631: PLUS
104632: PPUSH
104633: CALL_OW 1
104637: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
104638: LD_ADDR_EXP 170
104642: PUSH
104643: LD_EXP 170
104647: PPUSH
104648: LD_VAR 0 5
104652: PUSH
104653: LD_EXP 170
104657: PUSH
104658: LD_VAR 0 5
104662: ARRAY
104663: PUSH
104664: LD_INT 1
104666: PLUS
104667: PUSH
104668: EMPTY
104669: LIST
104670: LIST
104671: PPUSH
104672: LD_VAR 0 2
104676: PUSH
104677: LD_VAR 0 4
104681: ARRAY
104682: PUSH
104683: LD_VAR 0 2
104687: PUSH
104688: LD_VAR 0 4
104692: ARRAY
104693: PPUSH
104694: CALL_OW 255
104698: PUSH
104699: EMPTY
104700: LIST
104701: LIST
104702: PPUSH
104703: CALL 20087 0 3
104707: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
104708: LD_VAR 0 2
104712: PUSH
104713: LD_VAR 0 4
104717: ARRAY
104718: PPUSH
104719: LD_VAR 0 1
104723: PPUSH
104724: CALL_OW 255
104728: PPUSH
104729: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
104733: LD_VAR 0 2
104737: PUSH
104738: LD_VAR 0 4
104742: ARRAY
104743: PPUSH
104744: CALL_OW 141
// end ;
104748: GO 104580
104750: POP
104751: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
104752: LD_VAR 0 1
104756: PPUSH
104757: LD_EXP 170
104761: PUSH
104762: LD_VAR 0 5
104766: ARRAY
104767: PUSH
104768: LD_INT 0
104770: PLUS
104771: PPUSH
104772: CALL_OW 505
// end ;
104776: LD_VAR 0 3
104780: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
104781: LD_INT 0
104783: PPUSH
104784: PPUSH
104785: PPUSH
104786: PPUSH
// if not hack in hackTanks then
104787: LD_VAR 0 1
104791: PUSH
104792: LD_EXP 169
104796: IN
104797: NOT
104798: IFFALSE 104802
// exit ;
104800: GO 105042
// index := GetElementIndex ( hackTanks , hack ) ;
104802: LD_ADDR_VAR 0 4
104806: PUSH
104807: LD_EXP 169
104811: PPUSH
104812: LD_VAR 0 1
104816: PPUSH
104817: CALL 19872 0 2
104821: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
104822: LD_ADDR_VAR 0 3
104826: PUSH
104827: DOUBLE
104828: LD_EXP 170
104832: PUSH
104833: LD_VAR 0 4
104837: ARRAY
104838: INC
104839: ST_TO_ADDR
104840: LD_INT 1
104842: PUSH
104843: FOR_DOWNTO
104844: IFFALSE 105016
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
104846: LD_ADDR_VAR 0 5
104850: PUSH
104851: LD_EXP 170
104855: PUSH
104856: LD_VAR 0 4
104860: ARRAY
104861: PUSH
104862: LD_VAR 0 3
104866: ARRAY
104867: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
104868: LD_VAR 0 5
104872: PUSH
104873: LD_INT 1
104875: ARRAY
104876: PPUSH
104877: CALL_OW 302
104881: NOT
104882: PUSH
104883: LD_VAR 0 5
104887: PUSH
104888: LD_INT 1
104890: ARRAY
104891: PPUSH
104892: CALL_OW 255
104896: PUSH
104897: LD_VAR 0 1
104901: PPUSH
104902: CALL_OW 255
104906: NONEQUAL
104907: OR
104908: IFFALSE 105014
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
104910: LD_VAR 0 5
104914: PUSH
104915: LD_INT 1
104917: ARRAY
104918: PPUSH
104919: CALL_OW 305
104923: PUSH
104924: LD_VAR 0 5
104928: PUSH
104929: LD_INT 1
104931: ARRAY
104932: PPUSH
104933: CALL_OW 255
104937: PUSH
104938: LD_VAR 0 1
104942: PPUSH
104943: CALL_OW 255
104947: EQUAL
104948: AND
104949: IFFALSE 104973
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
104951: LD_VAR 0 5
104955: PUSH
104956: LD_INT 1
104958: ARRAY
104959: PPUSH
104960: LD_VAR 0 5
104964: PUSH
104965: LD_INT 2
104967: ARRAY
104968: PPUSH
104969: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
104973: LD_ADDR_EXP 170
104977: PUSH
104978: LD_EXP 170
104982: PPUSH
104983: LD_VAR 0 4
104987: PPUSH
104988: LD_EXP 170
104992: PUSH
104993: LD_VAR 0 4
104997: ARRAY
104998: PPUSH
104999: LD_VAR 0 3
105003: PPUSH
105004: CALL_OW 3
105008: PPUSH
105009: CALL_OW 1
105013: ST_TO_ADDR
// end ; end ;
105014: GO 104843
105016: POP
105017: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
105018: LD_VAR 0 1
105022: PPUSH
105023: LD_EXP 170
105027: PUSH
105028: LD_VAR 0 4
105032: ARRAY
105033: PUSH
105034: LD_INT 0
105036: PLUS
105037: PPUSH
105038: CALL_OW 505
// end ;
105042: LD_VAR 0 2
105046: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
105047: LD_INT 0
105049: PPUSH
105050: PPUSH
105051: PPUSH
105052: PPUSH
// if not hack in hackTanks then
105053: LD_VAR 0 1
105057: PUSH
105058: LD_EXP 169
105062: IN
105063: NOT
105064: IFFALSE 105068
// exit ;
105066: GO 105153
// index := GetElementIndex ( hackTanks , hack ) ;
105068: LD_ADDR_VAR 0 5
105072: PUSH
105073: LD_EXP 169
105077: PPUSH
105078: LD_VAR 0 1
105082: PPUSH
105083: CALL 19872 0 2
105087: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
105088: LD_ADDR_VAR 0 4
105092: PUSH
105093: DOUBLE
105094: LD_INT 1
105096: DEC
105097: ST_TO_ADDR
105098: LD_EXP 170
105102: PUSH
105103: LD_VAR 0 5
105107: ARRAY
105108: PUSH
105109: FOR_TO
105110: IFFALSE 105151
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
105112: LD_EXP 170
105116: PUSH
105117: LD_VAR 0 5
105121: ARRAY
105122: PUSH
105123: LD_VAR 0 4
105127: ARRAY
105128: PUSH
105129: LD_INT 1
105131: ARRAY
105132: PUSH
105133: LD_VAR 0 2
105137: EQUAL
105138: IFFALSE 105149
// KillUnit ( vehicle ) ;
105140: LD_VAR 0 2
105144: PPUSH
105145: CALL_OW 66
105149: GO 105109
105151: POP
105152: POP
// end ;
105153: LD_VAR 0 3
105157: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
105158: LD_EXP 174
105162: NOT
105163: IFFALSE 105198
105165: GO 105167
105167: DISABLE
// begin initMiner := true ;
105168: LD_ADDR_EXP 174
105172: PUSH
105173: LD_INT 1
105175: ST_TO_ADDR
// minersList := [ ] ;
105176: LD_ADDR_EXP 175
105180: PUSH
105181: EMPTY
105182: ST_TO_ADDR
// minerMinesList := [ ] ;
105183: LD_ADDR_EXP 176
105187: PUSH
105188: EMPTY
105189: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
105190: LD_ADDR_EXP 177
105194: PUSH
105195: LD_INT 5
105197: ST_TO_ADDR
// end ;
105198: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
105199: LD_EXP 174
105203: PUSH
105204: LD_INT 34
105206: PUSH
105207: LD_INT 81
105209: PUSH
105210: EMPTY
105211: LIST
105212: LIST
105213: PPUSH
105214: CALL_OW 69
105218: AND
105219: IFFALSE 105680
105221: GO 105223
105223: DISABLE
105224: LD_INT 0
105226: PPUSH
105227: PPUSH
105228: PPUSH
105229: PPUSH
// begin enable ;
105230: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
105231: LD_ADDR_VAR 0 1
105235: PUSH
105236: LD_INT 34
105238: PUSH
105239: LD_INT 81
105241: PUSH
105242: EMPTY
105243: LIST
105244: LIST
105245: PPUSH
105246: CALL_OW 69
105250: PUSH
105251: FOR_IN
105252: IFFALSE 105324
// begin if not i in minersList then
105254: LD_VAR 0 1
105258: PUSH
105259: LD_EXP 175
105263: IN
105264: NOT
105265: IFFALSE 105322
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
105267: LD_ADDR_EXP 175
105271: PUSH
105272: LD_EXP 175
105276: PPUSH
105277: LD_EXP 175
105281: PUSH
105282: LD_INT 1
105284: PLUS
105285: PPUSH
105286: LD_VAR 0 1
105290: PPUSH
105291: CALL_OW 1
105295: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
105296: LD_ADDR_EXP 176
105300: PUSH
105301: LD_EXP 176
105305: PPUSH
105306: LD_EXP 176
105310: PUSH
105311: LD_INT 1
105313: PLUS
105314: PPUSH
105315: EMPTY
105316: PPUSH
105317: CALL_OW 1
105321: ST_TO_ADDR
// end end ;
105322: GO 105251
105324: POP
105325: POP
// for i := minerMinesList downto 1 do
105326: LD_ADDR_VAR 0 1
105330: PUSH
105331: DOUBLE
105332: LD_EXP 176
105336: INC
105337: ST_TO_ADDR
105338: LD_INT 1
105340: PUSH
105341: FOR_DOWNTO
105342: IFFALSE 105678
// begin if IsLive ( minersList [ i ] ) then
105344: LD_EXP 175
105348: PUSH
105349: LD_VAR 0 1
105353: ARRAY
105354: PPUSH
105355: CALL_OW 300
105359: IFFALSE 105387
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
105361: LD_EXP 175
105365: PUSH
105366: LD_VAR 0 1
105370: ARRAY
105371: PPUSH
105372: LD_EXP 176
105376: PUSH
105377: LD_VAR 0 1
105381: ARRAY
105382: PPUSH
105383: CALL_OW 505
// if not minerMinesList [ i ] then
105387: LD_EXP 176
105391: PUSH
105392: LD_VAR 0 1
105396: ARRAY
105397: NOT
105398: IFFALSE 105402
// continue ;
105400: GO 105341
// for j := minerMinesList [ i ] downto 1 do
105402: LD_ADDR_VAR 0 2
105406: PUSH
105407: DOUBLE
105408: LD_EXP 176
105412: PUSH
105413: LD_VAR 0 1
105417: ARRAY
105418: INC
105419: ST_TO_ADDR
105420: LD_INT 1
105422: PUSH
105423: FOR_DOWNTO
105424: IFFALSE 105674
// begin side := GetSide ( minersList [ i ] ) ;
105426: LD_ADDR_VAR 0 3
105430: PUSH
105431: LD_EXP 175
105435: PUSH
105436: LD_VAR 0 1
105440: ARRAY
105441: PPUSH
105442: CALL_OW 255
105446: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
105447: LD_ADDR_VAR 0 4
105451: PUSH
105452: LD_EXP 176
105456: PUSH
105457: LD_VAR 0 1
105461: ARRAY
105462: PUSH
105463: LD_VAR 0 2
105467: ARRAY
105468: PUSH
105469: LD_INT 1
105471: ARRAY
105472: PPUSH
105473: LD_EXP 176
105477: PUSH
105478: LD_VAR 0 1
105482: ARRAY
105483: PUSH
105484: LD_VAR 0 2
105488: ARRAY
105489: PUSH
105490: LD_INT 2
105492: ARRAY
105493: PPUSH
105494: CALL_OW 428
105498: ST_TO_ADDR
// if not tmp then
105499: LD_VAR 0 4
105503: NOT
105504: IFFALSE 105508
// continue ;
105506: GO 105423
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
105508: LD_VAR 0 4
105512: PUSH
105513: LD_INT 81
105515: PUSH
105516: LD_VAR 0 3
105520: PUSH
105521: EMPTY
105522: LIST
105523: LIST
105524: PPUSH
105525: CALL_OW 69
105529: IN
105530: PUSH
105531: LD_EXP 176
105535: PUSH
105536: LD_VAR 0 1
105540: ARRAY
105541: PUSH
105542: LD_VAR 0 2
105546: ARRAY
105547: PUSH
105548: LD_INT 1
105550: ARRAY
105551: PPUSH
105552: LD_EXP 176
105556: PUSH
105557: LD_VAR 0 1
105561: ARRAY
105562: PUSH
105563: LD_VAR 0 2
105567: ARRAY
105568: PUSH
105569: LD_INT 2
105571: ARRAY
105572: PPUSH
105573: CALL_OW 458
105577: AND
105578: IFFALSE 105672
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
105580: LD_EXP 176
105584: PUSH
105585: LD_VAR 0 1
105589: ARRAY
105590: PUSH
105591: LD_VAR 0 2
105595: ARRAY
105596: PUSH
105597: LD_INT 1
105599: ARRAY
105600: PPUSH
105601: LD_EXP 176
105605: PUSH
105606: LD_VAR 0 1
105610: ARRAY
105611: PUSH
105612: LD_VAR 0 2
105616: ARRAY
105617: PUSH
105618: LD_INT 2
105620: ARRAY
105621: PPUSH
105622: LD_VAR 0 3
105626: PPUSH
105627: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
105631: LD_ADDR_EXP 176
105635: PUSH
105636: LD_EXP 176
105640: PPUSH
105641: LD_VAR 0 1
105645: PPUSH
105646: LD_EXP 176
105650: PUSH
105651: LD_VAR 0 1
105655: ARRAY
105656: PPUSH
105657: LD_VAR 0 2
105661: PPUSH
105662: CALL_OW 3
105666: PPUSH
105667: CALL_OW 1
105671: ST_TO_ADDR
// end ; end ;
105672: GO 105423
105674: POP
105675: POP
// end ;
105676: GO 105341
105678: POP
105679: POP
// end ;
105680: PPOPN 4
105682: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
105683: LD_INT 0
105685: PPUSH
105686: PPUSH
// result := false ;
105687: LD_ADDR_VAR 0 4
105691: PUSH
105692: LD_INT 0
105694: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
105695: LD_VAR 0 1
105699: PPUSH
105700: CALL_OW 264
105704: PUSH
105705: LD_INT 81
105707: EQUAL
105708: NOT
105709: IFFALSE 105713
// exit ;
105711: GO 105953
// index := GetElementIndex ( minersList , unit ) ;
105713: LD_ADDR_VAR 0 5
105717: PUSH
105718: LD_EXP 175
105722: PPUSH
105723: LD_VAR 0 1
105727: PPUSH
105728: CALL 19872 0 2
105732: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
105733: LD_EXP 176
105737: PUSH
105738: LD_VAR 0 5
105742: ARRAY
105743: PUSH
105744: LD_EXP 177
105748: GREATEREQUAL
105749: IFFALSE 105753
// exit ;
105751: GO 105953
// ComMoveXY ( unit , x , y ) ;
105753: LD_VAR 0 1
105757: PPUSH
105758: LD_VAR 0 2
105762: PPUSH
105763: LD_VAR 0 3
105767: PPUSH
105768: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
105772: LD_INT 35
105774: PPUSH
105775: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
105779: LD_VAR 0 1
105783: PPUSH
105784: LD_VAR 0 2
105788: PPUSH
105789: LD_VAR 0 3
105793: PPUSH
105794: CALL 51227 0 3
105798: NOT
105799: PUSH
105800: LD_VAR 0 1
105804: PPUSH
105805: CALL_OW 314
105809: AND
105810: IFFALSE 105814
// exit ;
105812: GO 105953
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
105814: LD_VAR 0 2
105818: PPUSH
105819: LD_VAR 0 3
105823: PPUSH
105824: CALL_OW 428
105828: PUSH
105829: LD_VAR 0 1
105833: EQUAL
105834: PUSH
105835: LD_VAR 0 1
105839: PPUSH
105840: CALL_OW 314
105844: NOT
105845: AND
105846: IFFALSE 105772
// PlaySoundXY ( x , y , PlantMine ) ;
105848: LD_VAR 0 2
105852: PPUSH
105853: LD_VAR 0 3
105857: PPUSH
105858: LD_STRING PlantMine
105860: PPUSH
105861: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
105865: LD_VAR 0 2
105869: PPUSH
105870: LD_VAR 0 3
105874: PPUSH
105875: LD_VAR 0 1
105879: PPUSH
105880: CALL_OW 255
105884: PPUSH
105885: LD_INT 0
105887: PPUSH
105888: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
105892: LD_ADDR_EXP 176
105896: PUSH
105897: LD_EXP 176
105901: PPUSH
105902: LD_VAR 0 5
105906: PUSH
105907: LD_EXP 176
105911: PUSH
105912: LD_VAR 0 5
105916: ARRAY
105917: PUSH
105918: LD_INT 1
105920: PLUS
105921: PUSH
105922: EMPTY
105923: LIST
105924: LIST
105925: PPUSH
105926: LD_VAR 0 2
105930: PUSH
105931: LD_VAR 0 3
105935: PUSH
105936: EMPTY
105937: LIST
105938: LIST
105939: PPUSH
105940: CALL 20087 0 3
105944: ST_TO_ADDR
// result := true ;
105945: LD_ADDR_VAR 0 4
105949: PUSH
105950: LD_INT 1
105952: ST_TO_ADDR
// end ;
105953: LD_VAR 0 4
105957: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
105958: LD_INT 0
105960: PPUSH
105961: PPUSH
105962: PPUSH
// if not unit in minersList then
105963: LD_VAR 0 1
105967: PUSH
105968: LD_EXP 175
105972: IN
105973: NOT
105974: IFFALSE 105978
// exit ;
105976: GO 106370
// index := GetElementIndex ( minersList , unit ) ;
105978: LD_ADDR_VAR 0 6
105982: PUSH
105983: LD_EXP 175
105987: PPUSH
105988: LD_VAR 0 1
105992: PPUSH
105993: CALL 19872 0 2
105997: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
105998: LD_ADDR_VAR 0 5
106002: PUSH
106003: DOUBLE
106004: LD_EXP 176
106008: PUSH
106009: LD_VAR 0 6
106013: ARRAY
106014: INC
106015: ST_TO_ADDR
106016: LD_INT 1
106018: PUSH
106019: FOR_DOWNTO
106020: IFFALSE 106181
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
106022: LD_EXP 176
106026: PUSH
106027: LD_VAR 0 6
106031: ARRAY
106032: PUSH
106033: LD_VAR 0 5
106037: ARRAY
106038: PUSH
106039: LD_INT 1
106041: ARRAY
106042: PUSH
106043: LD_VAR 0 2
106047: EQUAL
106048: PUSH
106049: LD_EXP 176
106053: PUSH
106054: LD_VAR 0 6
106058: ARRAY
106059: PUSH
106060: LD_VAR 0 5
106064: ARRAY
106065: PUSH
106066: LD_INT 2
106068: ARRAY
106069: PUSH
106070: LD_VAR 0 3
106074: EQUAL
106075: AND
106076: IFFALSE 106179
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106078: LD_EXP 176
106082: PUSH
106083: LD_VAR 0 6
106087: ARRAY
106088: PUSH
106089: LD_VAR 0 5
106093: ARRAY
106094: PUSH
106095: LD_INT 1
106097: ARRAY
106098: PPUSH
106099: LD_EXP 176
106103: PUSH
106104: LD_VAR 0 6
106108: ARRAY
106109: PUSH
106110: LD_VAR 0 5
106114: ARRAY
106115: PUSH
106116: LD_INT 2
106118: ARRAY
106119: PPUSH
106120: LD_VAR 0 1
106124: PPUSH
106125: CALL_OW 255
106129: PPUSH
106130: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
106134: LD_ADDR_EXP 176
106138: PUSH
106139: LD_EXP 176
106143: PPUSH
106144: LD_VAR 0 6
106148: PPUSH
106149: LD_EXP 176
106153: PUSH
106154: LD_VAR 0 6
106158: ARRAY
106159: PPUSH
106160: LD_VAR 0 5
106164: PPUSH
106165: CALL_OW 3
106169: PPUSH
106170: CALL_OW 1
106174: ST_TO_ADDR
// exit ;
106175: POP
106176: POP
106177: GO 106370
// end ; end ;
106179: GO 106019
106181: POP
106182: POP
// for i := minerMinesList [ index ] downto 1 do
106183: LD_ADDR_VAR 0 5
106187: PUSH
106188: DOUBLE
106189: LD_EXP 176
106193: PUSH
106194: LD_VAR 0 6
106198: ARRAY
106199: INC
106200: ST_TO_ADDR
106201: LD_INT 1
106203: PUSH
106204: FOR_DOWNTO
106205: IFFALSE 106368
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
106207: LD_EXP 176
106211: PUSH
106212: LD_VAR 0 6
106216: ARRAY
106217: PUSH
106218: LD_VAR 0 5
106222: ARRAY
106223: PUSH
106224: LD_INT 1
106226: ARRAY
106227: PPUSH
106228: LD_EXP 176
106232: PUSH
106233: LD_VAR 0 6
106237: ARRAY
106238: PUSH
106239: LD_VAR 0 5
106243: ARRAY
106244: PUSH
106245: LD_INT 2
106247: ARRAY
106248: PPUSH
106249: LD_VAR 0 2
106253: PPUSH
106254: LD_VAR 0 3
106258: PPUSH
106259: CALL_OW 298
106263: PUSH
106264: LD_INT 6
106266: LESS
106267: IFFALSE 106366
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106269: LD_EXP 176
106273: PUSH
106274: LD_VAR 0 6
106278: ARRAY
106279: PUSH
106280: LD_VAR 0 5
106284: ARRAY
106285: PUSH
106286: LD_INT 1
106288: ARRAY
106289: PPUSH
106290: LD_EXP 176
106294: PUSH
106295: LD_VAR 0 6
106299: ARRAY
106300: PUSH
106301: LD_VAR 0 5
106305: ARRAY
106306: PUSH
106307: LD_INT 2
106309: ARRAY
106310: PPUSH
106311: LD_VAR 0 1
106315: PPUSH
106316: CALL_OW 255
106320: PPUSH
106321: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
106325: LD_ADDR_EXP 176
106329: PUSH
106330: LD_EXP 176
106334: PPUSH
106335: LD_VAR 0 6
106339: PPUSH
106340: LD_EXP 176
106344: PUSH
106345: LD_VAR 0 6
106349: ARRAY
106350: PPUSH
106351: LD_VAR 0 5
106355: PPUSH
106356: CALL_OW 3
106360: PPUSH
106361: CALL_OW 1
106365: ST_TO_ADDR
// end ; end ;
106366: GO 106204
106368: POP
106369: POP
// end ;
106370: LD_VAR 0 4
106374: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
106375: LD_INT 0
106377: PPUSH
106378: PPUSH
106379: PPUSH
106380: PPUSH
106381: PPUSH
106382: PPUSH
106383: PPUSH
106384: PPUSH
106385: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
106386: LD_VAR 0 1
106390: PPUSH
106391: CALL_OW 264
106395: PUSH
106396: LD_INT 81
106398: EQUAL
106399: NOT
106400: PUSH
106401: LD_VAR 0 1
106405: PUSH
106406: LD_EXP 175
106410: IN
106411: NOT
106412: OR
106413: IFFALSE 106417
// exit ;
106415: GO 106739
// index := GetElementIndex ( minersList , unit ) ;
106417: LD_ADDR_VAR 0 6
106421: PUSH
106422: LD_EXP 175
106426: PPUSH
106427: LD_VAR 0 1
106431: PPUSH
106432: CALL 19872 0 2
106436: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
106437: LD_ADDR_VAR 0 8
106441: PUSH
106442: LD_EXP 177
106446: PUSH
106447: LD_EXP 176
106451: PUSH
106452: LD_VAR 0 6
106456: ARRAY
106457: MINUS
106458: ST_TO_ADDR
// if not minesFreeAmount then
106459: LD_VAR 0 8
106463: NOT
106464: IFFALSE 106468
// exit ;
106466: GO 106739
// tmp := [ ] ;
106468: LD_ADDR_VAR 0 7
106472: PUSH
106473: EMPTY
106474: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
106475: LD_ADDR_VAR 0 5
106479: PUSH
106480: DOUBLE
106481: LD_INT 1
106483: DEC
106484: ST_TO_ADDR
106485: LD_VAR 0 8
106489: PUSH
106490: FOR_TO
106491: IFFALSE 106686
// begin _d := rand ( 0 , 5 ) ;
106493: LD_ADDR_VAR 0 11
106497: PUSH
106498: LD_INT 0
106500: PPUSH
106501: LD_INT 5
106503: PPUSH
106504: CALL_OW 12
106508: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
106509: LD_ADDR_VAR 0 12
106513: PUSH
106514: LD_INT 2
106516: PPUSH
106517: LD_INT 6
106519: PPUSH
106520: CALL_OW 12
106524: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
106525: LD_ADDR_VAR 0 9
106529: PUSH
106530: LD_VAR 0 2
106534: PPUSH
106535: LD_VAR 0 11
106539: PPUSH
106540: LD_VAR 0 12
106544: PPUSH
106545: CALL_OW 272
106549: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
106550: LD_ADDR_VAR 0 10
106554: PUSH
106555: LD_VAR 0 3
106559: PPUSH
106560: LD_VAR 0 11
106564: PPUSH
106565: LD_VAR 0 12
106569: PPUSH
106570: CALL_OW 273
106574: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
106575: LD_VAR 0 9
106579: PPUSH
106580: LD_VAR 0 10
106584: PPUSH
106585: CALL_OW 488
106589: PUSH
106590: LD_VAR 0 9
106594: PUSH
106595: LD_VAR 0 10
106599: PUSH
106600: EMPTY
106601: LIST
106602: LIST
106603: PUSH
106604: LD_VAR 0 7
106608: IN
106609: NOT
106610: AND
106611: PUSH
106612: LD_VAR 0 9
106616: PPUSH
106617: LD_VAR 0 10
106621: PPUSH
106622: CALL_OW 458
106626: NOT
106627: AND
106628: IFFALSE 106670
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
106630: LD_ADDR_VAR 0 7
106634: PUSH
106635: LD_VAR 0 7
106639: PPUSH
106640: LD_VAR 0 7
106644: PUSH
106645: LD_INT 1
106647: PLUS
106648: PPUSH
106649: LD_VAR 0 9
106653: PUSH
106654: LD_VAR 0 10
106658: PUSH
106659: EMPTY
106660: LIST
106661: LIST
106662: PPUSH
106663: CALL_OW 1
106667: ST_TO_ADDR
106668: GO 106684
// i := i - 1 ;
106670: LD_ADDR_VAR 0 5
106674: PUSH
106675: LD_VAR 0 5
106679: PUSH
106680: LD_INT 1
106682: MINUS
106683: ST_TO_ADDR
// end ;
106684: GO 106490
106686: POP
106687: POP
// for i in tmp do
106688: LD_ADDR_VAR 0 5
106692: PUSH
106693: LD_VAR 0 7
106697: PUSH
106698: FOR_IN
106699: IFFALSE 106737
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
106701: LD_VAR 0 1
106705: PPUSH
106706: LD_VAR 0 5
106710: PUSH
106711: LD_INT 1
106713: ARRAY
106714: PPUSH
106715: LD_VAR 0 5
106719: PUSH
106720: LD_INT 2
106722: ARRAY
106723: PPUSH
106724: CALL 105683 0 3
106728: NOT
106729: IFFALSE 106735
// exit ;
106731: POP
106732: POP
106733: GO 106739
106735: GO 106698
106737: POP
106738: POP
// end ;
106739: LD_VAR 0 4
106743: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
106744: LD_INT 0
106746: PPUSH
106747: PPUSH
106748: PPUSH
106749: PPUSH
106750: PPUSH
106751: PPUSH
106752: PPUSH
// if not GetClass ( unit ) = class_sniper then
106753: LD_VAR 0 1
106757: PPUSH
106758: CALL_OW 257
106762: PUSH
106763: LD_INT 5
106765: EQUAL
106766: NOT
106767: IFFALSE 106771
// exit ;
106769: GO 107159
// dist := 8 ;
106771: LD_ADDR_VAR 0 5
106775: PUSH
106776: LD_INT 8
106778: ST_TO_ADDR
// viewRange := 12 ;
106779: LD_ADDR_VAR 0 7
106783: PUSH
106784: LD_INT 12
106786: ST_TO_ADDR
// side := GetSide ( unit ) ;
106787: LD_ADDR_VAR 0 6
106791: PUSH
106792: LD_VAR 0 1
106796: PPUSH
106797: CALL_OW 255
106801: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
106802: LD_INT 61
106804: PPUSH
106805: LD_VAR 0 6
106809: PPUSH
106810: CALL_OW 321
106814: PUSH
106815: LD_INT 2
106817: EQUAL
106818: IFFALSE 106828
// viewRange := 16 ;
106820: LD_ADDR_VAR 0 7
106824: PUSH
106825: LD_INT 16
106827: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
106828: LD_VAR 0 1
106832: PPUSH
106833: LD_VAR 0 2
106837: PPUSH
106838: LD_VAR 0 3
106842: PPUSH
106843: CALL_OW 297
106847: PUSH
106848: LD_VAR 0 5
106852: GREATER
106853: IFFALSE 106932
// begin ComMoveXY ( unit , x , y ) ;
106855: LD_VAR 0 1
106859: PPUSH
106860: LD_VAR 0 2
106864: PPUSH
106865: LD_VAR 0 3
106869: PPUSH
106870: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
106874: LD_INT 35
106876: PPUSH
106877: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
106881: LD_VAR 0 1
106885: PPUSH
106886: LD_VAR 0 2
106890: PPUSH
106891: LD_VAR 0 3
106895: PPUSH
106896: CALL 51227 0 3
106900: NOT
106901: IFFALSE 106905
// exit ;
106903: GO 107159
// until GetDistUnitXY ( unit , x , y ) < dist ;
106905: LD_VAR 0 1
106909: PPUSH
106910: LD_VAR 0 2
106914: PPUSH
106915: LD_VAR 0 3
106919: PPUSH
106920: CALL_OW 297
106924: PUSH
106925: LD_VAR 0 5
106929: LESS
106930: IFFALSE 106874
// end ; ComTurnXY ( unit , x , y ) ;
106932: LD_VAR 0 1
106936: PPUSH
106937: LD_VAR 0 2
106941: PPUSH
106942: LD_VAR 0 3
106946: PPUSH
106947: CALL_OW 118
// wait ( 5 ) ;
106951: LD_INT 5
106953: PPUSH
106954: CALL_OW 67
// _d := GetDir ( unit ) ;
106958: LD_ADDR_VAR 0 10
106962: PUSH
106963: LD_VAR 0 1
106967: PPUSH
106968: CALL_OW 254
106972: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
106973: LD_ADDR_VAR 0 8
106977: PUSH
106978: LD_VAR 0 1
106982: PPUSH
106983: CALL_OW 250
106987: PPUSH
106988: LD_VAR 0 10
106992: PPUSH
106993: LD_VAR 0 5
106997: PPUSH
106998: CALL_OW 272
107002: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
107003: LD_ADDR_VAR 0 9
107007: PUSH
107008: LD_VAR 0 1
107012: PPUSH
107013: CALL_OW 251
107017: PPUSH
107018: LD_VAR 0 10
107022: PPUSH
107023: LD_VAR 0 5
107027: PPUSH
107028: CALL_OW 273
107032: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
107033: LD_VAR 0 8
107037: PPUSH
107038: LD_VAR 0 9
107042: PPUSH
107043: CALL_OW 488
107047: NOT
107048: IFFALSE 107052
// exit ;
107050: GO 107159
// ComAnimCustom ( unit , 1 ) ;
107052: LD_VAR 0 1
107056: PPUSH
107057: LD_INT 1
107059: PPUSH
107060: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
107064: LD_VAR 0 8
107068: PPUSH
107069: LD_VAR 0 9
107073: PPUSH
107074: LD_VAR 0 6
107078: PPUSH
107079: LD_VAR 0 7
107083: PPUSH
107084: CALL_OW 330
// repeat wait ( 1 ) ;
107088: LD_INT 1
107090: PPUSH
107091: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
107095: LD_VAR 0 1
107099: PPUSH
107100: CALL_OW 316
107104: PUSH
107105: LD_VAR 0 1
107109: PPUSH
107110: CALL_OW 314
107114: OR
107115: PUSH
107116: LD_VAR 0 1
107120: PPUSH
107121: CALL_OW 302
107125: NOT
107126: OR
107127: PUSH
107128: LD_VAR 0 1
107132: PPUSH
107133: CALL_OW 301
107137: OR
107138: IFFALSE 107088
// RemoveSeeing ( _x , _y , side ) ;
107140: LD_VAR 0 8
107144: PPUSH
107145: LD_VAR 0 9
107149: PPUSH
107150: LD_VAR 0 6
107154: PPUSH
107155: CALL_OW 331
// end ; end_of_file
107159: LD_VAR 0 4
107163: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
107164: LD_INT 0
107166: PPUSH
107167: PPUSH
107168: PPUSH
107169: PPUSH
107170: PPUSH
107171: PPUSH
107172: PPUSH
107173: PPUSH
107174: PPUSH
107175: PPUSH
107176: PPUSH
107177: PPUSH
107178: PPUSH
107179: PPUSH
107180: PPUSH
107181: PPUSH
107182: PPUSH
107183: PPUSH
107184: PPUSH
107185: PPUSH
107186: PPUSH
107187: PPUSH
107188: PPUSH
107189: PPUSH
107190: PPUSH
107191: PPUSH
107192: PPUSH
107193: PPUSH
107194: PPUSH
107195: PPUSH
107196: PPUSH
107197: PPUSH
107198: PPUSH
107199: PPUSH
// if not list then
107200: LD_VAR 0 1
107204: NOT
107205: IFFALSE 107209
// exit ;
107207: GO 111868
// base := list [ 1 ] ;
107209: LD_ADDR_VAR 0 3
107213: PUSH
107214: LD_VAR 0 1
107218: PUSH
107219: LD_INT 1
107221: ARRAY
107222: ST_TO_ADDR
// group := list [ 2 ] ;
107223: LD_ADDR_VAR 0 4
107227: PUSH
107228: LD_VAR 0 1
107232: PUSH
107233: LD_INT 2
107235: ARRAY
107236: ST_TO_ADDR
// path := list [ 3 ] ;
107237: LD_ADDR_VAR 0 5
107241: PUSH
107242: LD_VAR 0 1
107246: PUSH
107247: LD_INT 3
107249: ARRAY
107250: ST_TO_ADDR
// flags := list [ 4 ] ;
107251: LD_ADDR_VAR 0 6
107255: PUSH
107256: LD_VAR 0 1
107260: PUSH
107261: LD_INT 4
107263: ARRAY
107264: ST_TO_ADDR
// mined := [ ] ;
107265: LD_ADDR_VAR 0 27
107269: PUSH
107270: EMPTY
107271: ST_TO_ADDR
// bombed := [ ] ;
107272: LD_ADDR_VAR 0 28
107276: PUSH
107277: EMPTY
107278: ST_TO_ADDR
// healers := [ ] ;
107279: LD_ADDR_VAR 0 31
107283: PUSH
107284: EMPTY
107285: ST_TO_ADDR
// to_heal := [ ] ;
107286: LD_ADDR_VAR 0 30
107290: PUSH
107291: EMPTY
107292: ST_TO_ADDR
// repairs := [ ] ;
107293: LD_ADDR_VAR 0 33
107297: PUSH
107298: EMPTY
107299: ST_TO_ADDR
// to_repair := [ ] ;
107300: LD_ADDR_VAR 0 32
107304: PUSH
107305: EMPTY
107306: ST_TO_ADDR
// if not group or not path then
107307: LD_VAR 0 4
107311: NOT
107312: PUSH
107313: LD_VAR 0 5
107317: NOT
107318: OR
107319: IFFALSE 107323
// exit ;
107321: GO 111868
// side := GetSide ( group [ 1 ] ) ;
107323: LD_ADDR_VAR 0 35
107327: PUSH
107328: LD_VAR 0 4
107332: PUSH
107333: LD_INT 1
107335: ARRAY
107336: PPUSH
107337: CALL_OW 255
107341: ST_TO_ADDR
// if flags then
107342: LD_VAR 0 6
107346: IFFALSE 107490
// begin f_ignore_area := flags [ 1 ] ;
107348: LD_ADDR_VAR 0 17
107352: PUSH
107353: LD_VAR 0 6
107357: PUSH
107358: LD_INT 1
107360: ARRAY
107361: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
107362: LD_ADDR_VAR 0 18
107366: PUSH
107367: LD_VAR 0 6
107371: PUSH
107372: LD_INT 2
107374: ARRAY
107375: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
107376: LD_ADDR_VAR 0 19
107380: PUSH
107381: LD_VAR 0 6
107385: PUSH
107386: LD_INT 3
107388: ARRAY
107389: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
107390: LD_ADDR_VAR 0 20
107394: PUSH
107395: LD_VAR 0 6
107399: PUSH
107400: LD_INT 4
107402: ARRAY
107403: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
107404: LD_ADDR_VAR 0 21
107408: PUSH
107409: LD_VAR 0 6
107413: PUSH
107414: LD_INT 5
107416: ARRAY
107417: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
107418: LD_ADDR_VAR 0 22
107422: PUSH
107423: LD_VAR 0 6
107427: PUSH
107428: LD_INT 6
107430: ARRAY
107431: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
107432: LD_ADDR_VAR 0 23
107436: PUSH
107437: LD_VAR 0 6
107441: PUSH
107442: LD_INT 7
107444: ARRAY
107445: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
107446: LD_ADDR_VAR 0 24
107450: PUSH
107451: LD_VAR 0 6
107455: PUSH
107456: LD_INT 8
107458: ARRAY
107459: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
107460: LD_ADDR_VAR 0 25
107464: PUSH
107465: LD_VAR 0 6
107469: PUSH
107470: LD_INT 9
107472: ARRAY
107473: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
107474: LD_ADDR_VAR 0 26
107478: PUSH
107479: LD_VAR 0 6
107483: PUSH
107484: LD_INT 10
107486: ARRAY
107487: ST_TO_ADDR
// end else
107488: GO 107570
// begin f_ignore_area := false ;
107490: LD_ADDR_VAR 0 17
107494: PUSH
107495: LD_INT 0
107497: ST_TO_ADDR
// f_capture := false ;
107498: LD_ADDR_VAR 0 18
107502: PUSH
107503: LD_INT 0
107505: ST_TO_ADDR
// f_ignore_civ := false ;
107506: LD_ADDR_VAR 0 19
107510: PUSH
107511: LD_INT 0
107513: ST_TO_ADDR
// f_murder := false ;
107514: LD_ADDR_VAR 0 20
107518: PUSH
107519: LD_INT 0
107521: ST_TO_ADDR
// f_mines := false ;
107522: LD_ADDR_VAR 0 21
107526: PUSH
107527: LD_INT 0
107529: ST_TO_ADDR
// f_repair := false ;
107530: LD_ADDR_VAR 0 22
107534: PUSH
107535: LD_INT 0
107537: ST_TO_ADDR
// f_heal := false ;
107538: LD_ADDR_VAR 0 23
107542: PUSH
107543: LD_INT 0
107545: ST_TO_ADDR
// f_spacetime := false ;
107546: LD_ADDR_VAR 0 24
107550: PUSH
107551: LD_INT 0
107553: ST_TO_ADDR
// f_attack_depot := false ;
107554: LD_ADDR_VAR 0 25
107558: PUSH
107559: LD_INT 0
107561: ST_TO_ADDR
// f_crawl := false ;
107562: LD_ADDR_VAR 0 26
107566: PUSH
107567: LD_INT 0
107569: ST_TO_ADDR
// end ; if f_heal then
107570: LD_VAR 0 23
107574: IFFALSE 107601
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
107576: LD_ADDR_VAR 0 31
107580: PUSH
107581: LD_VAR 0 4
107585: PPUSH
107586: LD_INT 25
107588: PUSH
107589: LD_INT 4
107591: PUSH
107592: EMPTY
107593: LIST
107594: LIST
107595: PPUSH
107596: CALL_OW 72
107600: ST_TO_ADDR
// if f_repair then
107601: LD_VAR 0 22
107605: IFFALSE 107632
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
107607: LD_ADDR_VAR 0 33
107611: PUSH
107612: LD_VAR 0 4
107616: PPUSH
107617: LD_INT 25
107619: PUSH
107620: LD_INT 3
107622: PUSH
107623: EMPTY
107624: LIST
107625: LIST
107626: PPUSH
107627: CALL_OW 72
107631: ST_TO_ADDR
// units_path := [ ] ;
107632: LD_ADDR_VAR 0 16
107636: PUSH
107637: EMPTY
107638: ST_TO_ADDR
// for i = 1 to group do
107639: LD_ADDR_VAR 0 7
107643: PUSH
107644: DOUBLE
107645: LD_INT 1
107647: DEC
107648: ST_TO_ADDR
107649: LD_VAR 0 4
107653: PUSH
107654: FOR_TO
107655: IFFALSE 107684
// units_path := Replace ( units_path , i , path ) ;
107657: LD_ADDR_VAR 0 16
107661: PUSH
107662: LD_VAR 0 16
107666: PPUSH
107667: LD_VAR 0 7
107671: PPUSH
107672: LD_VAR 0 5
107676: PPUSH
107677: CALL_OW 1
107681: ST_TO_ADDR
107682: GO 107654
107684: POP
107685: POP
// repeat for i = group downto 1 do
107686: LD_ADDR_VAR 0 7
107690: PUSH
107691: DOUBLE
107692: LD_VAR 0 4
107696: INC
107697: ST_TO_ADDR
107698: LD_INT 1
107700: PUSH
107701: FOR_DOWNTO
107702: IFFALSE 111824
// begin wait ( 5 ) ;
107704: LD_INT 5
107706: PPUSH
107707: CALL_OW 67
// tmp := [ ] ;
107711: LD_ADDR_VAR 0 14
107715: PUSH
107716: EMPTY
107717: ST_TO_ADDR
// attacking := false ;
107718: LD_ADDR_VAR 0 29
107722: PUSH
107723: LD_INT 0
107725: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
107726: LD_VAR 0 4
107730: PUSH
107731: LD_VAR 0 7
107735: ARRAY
107736: PPUSH
107737: CALL_OW 301
107741: PUSH
107742: LD_VAR 0 4
107746: PUSH
107747: LD_VAR 0 7
107751: ARRAY
107752: NOT
107753: OR
107754: IFFALSE 107863
// begin if GetType ( group [ i ] ) = unit_human then
107756: LD_VAR 0 4
107760: PUSH
107761: LD_VAR 0 7
107765: ARRAY
107766: PPUSH
107767: CALL_OW 247
107771: PUSH
107772: LD_INT 1
107774: EQUAL
107775: IFFALSE 107821
// begin to_heal := to_heal diff group [ i ] ;
107777: LD_ADDR_VAR 0 30
107781: PUSH
107782: LD_VAR 0 30
107786: PUSH
107787: LD_VAR 0 4
107791: PUSH
107792: LD_VAR 0 7
107796: ARRAY
107797: DIFF
107798: ST_TO_ADDR
// healers := healers diff group [ i ] ;
107799: LD_ADDR_VAR 0 31
107803: PUSH
107804: LD_VAR 0 31
107808: PUSH
107809: LD_VAR 0 4
107813: PUSH
107814: LD_VAR 0 7
107818: ARRAY
107819: DIFF
107820: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
107821: LD_ADDR_VAR 0 4
107825: PUSH
107826: LD_VAR 0 4
107830: PPUSH
107831: LD_VAR 0 7
107835: PPUSH
107836: CALL_OW 3
107840: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
107841: LD_ADDR_VAR 0 16
107845: PUSH
107846: LD_VAR 0 16
107850: PPUSH
107851: LD_VAR 0 7
107855: PPUSH
107856: CALL_OW 3
107860: ST_TO_ADDR
// continue ;
107861: GO 107701
// end ; if f_repair then
107863: LD_VAR 0 22
107867: IFFALSE 108356
// begin if GetType ( group [ i ] ) = unit_vehicle then
107869: LD_VAR 0 4
107873: PUSH
107874: LD_VAR 0 7
107878: ARRAY
107879: PPUSH
107880: CALL_OW 247
107884: PUSH
107885: LD_INT 2
107887: EQUAL
107888: IFFALSE 108078
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
107890: LD_VAR 0 4
107894: PUSH
107895: LD_VAR 0 7
107899: ARRAY
107900: PPUSH
107901: CALL_OW 256
107905: PUSH
107906: LD_INT 700
107908: LESS
107909: PUSH
107910: LD_VAR 0 4
107914: PUSH
107915: LD_VAR 0 7
107919: ARRAY
107920: PUSH
107921: LD_VAR 0 32
107925: IN
107926: NOT
107927: AND
107928: IFFALSE 107952
// to_repair := to_repair union group [ i ] ;
107930: LD_ADDR_VAR 0 32
107934: PUSH
107935: LD_VAR 0 32
107939: PUSH
107940: LD_VAR 0 4
107944: PUSH
107945: LD_VAR 0 7
107949: ARRAY
107950: UNION
107951: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
107952: LD_VAR 0 4
107956: PUSH
107957: LD_VAR 0 7
107961: ARRAY
107962: PPUSH
107963: CALL_OW 256
107967: PUSH
107968: LD_INT 1000
107970: EQUAL
107971: PUSH
107972: LD_VAR 0 4
107976: PUSH
107977: LD_VAR 0 7
107981: ARRAY
107982: PUSH
107983: LD_VAR 0 32
107987: IN
107988: AND
107989: IFFALSE 108013
// to_repair := to_repair diff group [ i ] ;
107991: LD_ADDR_VAR 0 32
107995: PUSH
107996: LD_VAR 0 32
108000: PUSH
108001: LD_VAR 0 4
108005: PUSH
108006: LD_VAR 0 7
108010: ARRAY
108011: DIFF
108012: ST_TO_ADDR
// if group [ i ] in to_repair then
108013: LD_VAR 0 4
108017: PUSH
108018: LD_VAR 0 7
108022: ARRAY
108023: PUSH
108024: LD_VAR 0 32
108028: IN
108029: IFFALSE 108076
// begin if not IsInArea ( group [ i ] , f_repair ) then
108031: LD_VAR 0 4
108035: PUSH
108036: LD_VAR 0 7
108040: ARRAY
108041: PPUSH
108042: LD_VAR 0 22
108046: PPUSH
108047: CALL_OW 308
108051: NOT
108052: IFFALSE 108074
// ComMoveToArea ( group [ i ] , f_repair ) ;
108054: LD_VAR 0 4
108058: PUSH
108059: LD_VAR 0 7
108063: ARRAY
108064: PPUSH
108065: LD_VAR 0 22
108069: PPUSH
108070: CALL_OW 113
// continue ;
108074: GO 107701
// end ; end else
108076: GO 108356
// if group [ i ] in repairs then
108078: LD_VAR 0 4
108082: PUSH
108083: LD_VAR 0 7
108087: ARRAY
108088: PUSH
108089: LD_VAR 0 33
108093: IN
108094: IFFALSE 108356
// begin if IsInUnit ( group [ i ] ) then
108096: LD_VAR 0 4
108100: PUSH
108101: LD_VAR 0 7
108105: ARRAY
108106: PPUSH
108107: CALL_OW 310
108111: IFFALSE 108179
// begin z := IsInUnit ( group [ i ] ) ;
108113: LD_ADDR_VAR 0 13
108117: PUSH
108118: LD_VAR 0 4
108122: PUSH
108123: LD_VAR 0 7
108127: ARRAY
108128: PPUSH
108129: CALL_OW 310
108133: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
108134: LD_VAR 0 13
108138: PUSH
108139: LD_VAR 0 32
108143: IN
108144: PUSH
108145: LD_VAR 0 13
108149: PPUSH
108150: LD_VAR 0 22
108154: PPUSH
108155: CALL_OW 308
108159: AND
108160: IFFALSE 108177
// ComExitVehicle ( group [ i ] ) ;
108162: LD_VAR 0 4
108166: PUSH
108167: LD_VAR 0 7
108171: ARRAY
108172: PPUSH
108173: CALL_OW 121
// end else
108177: GO 108356
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
108179: LD_ADDR_VAR 0 13
108183: PUSH
108184: LD_VAR 0 4
108188: PPUSH
108189: LD_INT 95
108191: PUSH
108192: LD_VAR 0 22
108196: PUSH
108197: EMPTY
108198: LIST
108199: LIST
108200: PUSH
108201: LD_INT 58
108203: PUSH
108204: EMPTY
108205: LIST
108206: PUSH
108207: EMPTY
108208: LIST
108209: LIST
108210: PPUSH
108211: CALL_OW 72
108215: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
108216: LD_VAR 0 4
108220: PUSH
108221: LD_VAR 0 7
108225: ARRAY
108226: PPUSH
108227: CALL_OW 314
108231: NOT
108232: IFFALSE 108354
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
108234: LD_ADDR_VAR 0 10
108238: PUSH
108239: LD_VAR 0 13
108243: PPUSH
108244: LD_VAR 0 4
108248: PUSH
108249: LD_VAR 0 7
108253: ARRAY
108254: PPUSH
108255: CALL_OW 74
108259: ST_TO_ADDR
// if not x then
108260: LD_VAR 0 10
108264: NOT
108265: IFFALSE 108269
// continue ;
108267: GO 107701
// if GetLives ( x ) < 1000 then
108269: LD_VAR 0 10
108273: PPUSH
108274: CALL_OW 256
108278: PUSH
108279: LD_INT 1000
108281: LESS
108282: IFFALSE 108306
// ComRepairVehicle ( group [ i ] , x ) else
108284: LD_VAR 0 4
108288: PUSH
108289: LD_VAR 0 7
108293: ARRAY
108294: PPUSH
108295: LD_VAR 0 10
108299: PPUSH
108300: CALL_OW 129
108304: GO 108354
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
108306: LD_VAR 0 23
108310: PUSH
108311: LD_VAR 0 4
108315: PUSH
108316: LD_VAR 0 7
108320: ARRAY
108321: PPUSH
108322: CALL_OW 256
108326: PUSH
108327: LD_INT 1000
108329: LESS
108330: AND
108331: NOT
108332: IFFALSE 108354
// ComEnterUnit ( group [ i ] , x ) ;
108334: LD_VAR 0 4
108338: PUSH
108339: LD_VAR 0 7
108343: ARRAY
108344: PPUSH
108345: LD_VAR 0 10
108349: PPUSH
108350: CALL_OW 120
// end ; continue ;
108354: GO 107701
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
108356: LD_VAR 0 23
108360: PUSH
108361: LD_VAR 0 4
108365: PUSH
108366: LD_VAR 0 7
108370: ARRAY
108371: PPUSH
108372: CALL_OW 247
108376: PUSH
108377: LD_INT 1
108379: EQUAL
108380: AND
108381: IFFALSE 108859
// begin if group [ i ] in healers then
108383: LD_VAR 0 4
108387: PUSH
108388: LD_VAR 0 7
108392: ARRAY
108393: PUSH
108394: LD_VAR 0 31
108398: IN
108399: IFFALSE 108672
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
108401: LD_VAR 0 4
108405: PUSH
108406: LD_VAR 0 7
108410: ARRAY
108411: PPUSH
108412: LD_VAR 0 23
108416: PPUSH
108417: CALL_OW 308
108421: NOT
108422: PUSH
108423: LD_VAR 0 4
108427: PUSH
108428: LD_VAR 0 7
108432: ARRAY
108433: PPUSH
108434: CALL_OW 314
108438: NOT
108439: AND
108440: IFFALSE 108464
// ComMoveToArea ( group [ i ] , f_heal ) else
108442: LD_VAR 0 4
108446: PUSH
108447: LD_VAR 0 7
108451: ARRAY
108452: PPUSH
108453: LD_VAR 0 23
108457: PPUSH
108458: CALL_OW 113
108462: GO 108670
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
108464: LD_VAR 0 4
108468: PUSH
108469: LD_VAR 0 7
108473: ARRAY
108474: PPUSH
108475: CALL 49810 0 1
108479: PPUSH
108480: CALL_OW 256
108484: PUSH
108485: LD_INT 1000
108487: EQUAL
108488: IFFALSE 108507
// ComStop ( group [ i ] ) else
108490: LD_VAR 0 4
108494: PUSH
108495: LD_VAR 0 7
108499: ARRAY
108500: PPUSH
108501: CALL_OW 141
108505: GO 108670
// if not HasTask ( group [ i ] ) and to_heal then
108507: LD_VAR 0 4
108511: PUSH
108512: LD_VAR 0 7
108516: ARRAY
108517: PPUSH
108518: CALL_OW 314
108522: NOT
108523: PUSH
108524: LD_VAR 0 30
108528: AND
108529: IFFALSE 108670
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
108531: LD_ADDR_VAR 0 13
108535: PUSH
108536: LD_VAR 0 30
108540: PPUSH
108541: LD_INT 3
108543: PUSH
108544: LD_INT 54
108546: PUSH
108547: EMPTY
108548: LIST
108549: PUSH
108550: EMPTY
108551: LIST
108552: LIST
108553: PPUSH
108554: CALL_OW 72
108558: PPUSH
108559: LD_VAR 0 4
108563: PUSH
108564: LD_VAR 0 7
108568: ARRAY
108569: PPUSH
108570: CALL_OW 74
108574: ST_TO_ADDR
// if z then
108575: LD_VAR 0 13
108579: IFFALSE 108670
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
108581: LD_INT 91
108583: PUSH
108584: LD_VAR 0 13
108588: PUSH
108589: LD_INT 10
108591: PUSH
108592: EMPTY
108593: LIST
108594: LIST
108595: LIST
108596: PUSH
108597: LD_INT 81
108599: PUSH
108600: LD_VAR 0 13
108604: PPUSH
108605: CALL_OW 255
108609: PUSH
108610: EMPTY
108611: LIST
108612: LIST
108613: PUSH
108614: EMPTY
108615: LIST
108616: LIST
108617: PPUSH
108618: CALL_OW 69
108622: PUSH
108623: LD_INT 0
108625: EQUAL
108626: IFFALSE 108650
// ComHeal ( group [ i ] , z ) else
108628: LD_VAR 0 4
108632: PUSH
108633: LD_VAR 0 7
108637: ARRAY
108638: PPUSH
108639: LD_VAR 0 13
108643: PPUSH
108644: CALL_OW 128
108648: GO 108670
// ComMoveToArea ( group [ i ] , f_heal ) ;
108650: LD_VAR 0 4
108654: PUSH
108655: LD_VAR 0 7
108659: ARRAY
108660: PPUSH
108661: LD_VAR 0 23
108665: PPUSH
108666: CALL_OW 113
// end ; continue ;
108670: GO 107701
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
108672: LD_VAR 0 4
108676: PUSH
108677: LD_VAR 0 7
108681: ARRAY
108682: PPUSH
108683: CALL_OW 256
108687: PUSH
108688: LD_INT 700
108690: LESS
108691: PUSH
108692: LD_VAR 0 4
108696: PUSH
108697: LD_VAR 0 7
108701: ARRAY
108702: PUSH
108703: LD_VAR 0 30
108707: IN
108708: NOT
108709: AND
108710: IFFALSE 108734
// to_heal := to_heal union group [ i ] ;
108712: LD_ADDR_VAR 0 30
108716: PUSH
108717: LD_VAR 0 30
108721: PUSH
108722: LD_VAR 0 4
108726: PUSH
108727: LD_VAR 0 7
108731: ARRAY
108732: UNION
108733: ST_TO_ADDR
// if group [ i ] in to_heal then
108734: LD_VAR 0 4
108738: PUSH
108739: LD_VAR 0 7
108743: ARRAY
108744: PUSH
108745: LD_VAR 0 30
108749: IN
108750: IFFALSE 108859
// begin if GetLives ( group [ i ] ) = 1000 then
108752: LD_VAR 0 4
108756: PUSH
108757: LD_VAR 0 7
108761: ARRAY
108762: PPUSH
108763: CALL_OW 256
108767: PUSH
108768: LD_INT 1000
108770: EQUAL
108771: IFFALSE 108797
// to_heal := to_heal diff group [ i ] else
108773: LD_ADDR_VAR 0 30
108777: PUSH
108778: LD_VAR 0 30
108782: PUSH
108783: LD_VAR 0 4
108787: PUSH
108788: LD_VAR 0 7
108792: ARRAY
108793: DIFF
108794: ST_TO_ADDR
108795: GO 108859
// begin if not IsInArea ( group [ i ] , to_heal ) then
108797: LD_VAR 0 4
108801: PUSH
108802: LD_VAR 0 7
108806: ARRAY
108807: PPUSH
108808: LD_VAR 0 30
108812: PPUSH
108813: CALL_OW 308
108817: NOT
108818: IFFALSE 108842
// ComMoveToArea ( group [ i ] , f_heal ) else
108820: LD_VAR 0 4
108824: PUSH
108825: LD_VAR 0 7
108829: ARRAY
108830: PPUSH
108831: LD_VAR 0 23
108835: PPUSH
108836: CALL_OW 113
108840: GO 108857
// ComHold ( group [ i ] ) ;
108842: LD_VAR 0 4
108846: PUSH
108847: LD_VAR 0 7
108851: ARRAY
108852: PPUSH
108853: CALL_OW 140
// continue ;
108857: GO 107701
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
108859: LD_VAR 0 4
108863: PUSH
108864: LD_VAR 0 7
108868: ARRAY
108869: PPUSH
108870: LD_INT 10
108872: PPUSH
108873: CALL 47581 0 2
108877: NOT
108878: PUSH
108879: LD_VAR 0 16
108883: PUSH
108884: LD_VAR 0 7
108888: ARRAY
108889: PUSH
108890: EMPTY
108891: EQUAL
108892: NOT
108893: AND
108894: IFFALSE 109160
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
108896: LD_VAR 0 4
108900: PUSH
108901: LD_VAR 0 7
108905: ARRAY
108906: PPUSH
108907: CALL_OW 262
108911: PUSH
108912: LD_INT 1
108914: PUSH
108915: LD_INT 2
108917: PUSH
108918: EMPTY
108919: LIST
108920: LIST
108921: IN
108922: IFFALSE 108963
// if GetFuel ( group [ i ] ) < 10 then
108924: LD_VAR 0 4
108928: PUSH
108929: LD_VAR 0 7
108933: ARRAY
108934: PPUSH
108935: CALL_OW 261
108939: PUSH
108940: LD_INT 10
108942: LESS
108943: IFFALSE 108963
// SetFuel ( group [ i ] , 12 ) ;
108945: LD_VAR 0 4
108949: PUSH
108950: LD_VAR 0 7
108954: ARRAY
108955: PPUSH
108956: LD_INT 12
108958: PPUSH
108959: CALL_OW 240
// if units_path [ i ] then
108963: LD_VAR 0 16
108967: PUSH
108968: LD_VAR 0 7
108972: ARRAY
108973: IFFALSE 109158
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
108975: LD_VAR 0 4
108979: PUSH
108980: LD_VAR 0 7
108984: ARRAY
108985: PPUSH
108986: LD_VAR 0 16
108990: PUSH
108991: LD_VAR 0 7
108995: ARRAY
108996: PUSH
108997: LD_INT 1
108999: ARRAY
109000: PUSH
109001: LD_INT 1
109003: ARRAY
109004: PPUSH
109005: LD_VAR 0 16
109009: PUSH
109010: LD_VAR 0 7
109014: ARRAY
109015: PUSH
109016: LD_INT 1
109018: ARRAY
109019: PUSH
109020: LD_INT 2
109022: ARRAY
109023: PPUSH
109024: CALL_OW 297
109028: PUSH
109029: LD_INT 6
109031: GREATER
109032: IFFALSE 109107
// begin if not HasTask ( group [ i ] ) then
109034: LD_VAR 0 4
109038: PUSH
109039: LD_VAR 0 7
109043: ARRAY
109044: PPUSH
109045: CALL_OW 314
109049: NOT
109050: IFFALSE 109105
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
109052: LD_VAR 0 4
109056: PUSH
109057: LD_VAR 0 7
109061: ARRAY
109062: PPUSH
109063: LD_VAR 0 16
109067: PUSH
109068: LD_VAR 0 7
109072: ARRAY
109073: PUSH
109074: LD_INT 1
109076: ARRAY
109077: PUSH
109078: LD_INT 1
109080: ARRAY
109081: PPUSH
109082: LD_VAR 0 16
109086: PUSH
109087: LD_VAR 0 7
109091: ARRAY
109092: PUSH
109093: LD_INT 1
109095: ARRAY
109096: PUSH
109097: LD_INT 2
109099: ARRAY
109100: PPUSH
109101: CALL_OW 114
// end else
109105: GO 109158
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
109107: LD_ADDR_VAR 0 15
109111: PUSH
109112: LD_VAR 0 16
109116: PUSH
109117: LD_VAR 0 7
109121: ARRAY
109122: PPUSH
109123: LD_INT 1
109125: PPUSH
109126: CALL_OW 3
109130: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
109131: LD_ADDR_VAR 0 16
109135: PUSH
109136: LD_VAR 0 16
109140: PPUSH
109141: LD_VAR 0 7
109145: PPUSH
109146: LD_VAR 0 15
109150: PPUSH
109151: CALL_OW 1
109155: ST_TO_ADDR
// continue ;
109156: GO 107701
// end ; end ; end else
109158: GO 111822
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
109160: LD_ADDR_VAR 0 14
109164: PUSH
109165: LD_INT 81
109167: PUSH
109168: LD_VAR 0 4
109172: PUSH
109173: LD_VAR 0 7
109177: ARRAY
109178: PPUSH
109179: CALL_OW 255
109183: PUSH
109184: EMPTY
109185: LIST
109186: LIST
109187: PPUSH
109188: CALL_OW 69
109192: ST_TO_ADDR
// if not tmp then
109193: LD_VAR 0 14
109197: NOT
109198: IFFALSE 109202
// continue ;
109200: GO 107701
// if f_ignore_area then
109202: LD_VAR 0 17
109206: IFFALSE 109294
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
109208: LD_ADDR_VAR 0 15
109212: PUSH
109213: LD_VAR 0 14
109217: PPUSH
109218: LD_INT 3
109220: PUSH
109221: LD_INT 92
109223: PUSH
109224: LD_VAR 0 17
109228: PUSH
109229: LD_INT 1
109231: ARRAY
109232: PUSH
109233: LD_VAR 0 17
109237: PUSH
109238: LD_INT 2
109240: ARRAY
109241: PUSH
109242: LD_VAR 0 17
109246: PUSH
109247: LD_INT 3
109249: ARRAY
109250: PUSH
109251: EMPTY
109252: LIST
109253: LIST
109254: LIST
109255: LIST
109256: PUSH
109257: EMPTY
109258: LIST
109259: LIST
109260: PPUSH
109261: CALL_OW 72
109265: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109266: LD_VAR 0 14
109270: PUSH
109271: LD_VAR 0 15
109275: DIFF
109276: IFFALSE 109294
// tmp := tmp diff tmp2 ;
109278: LD_ADDR_VAR 0 14
109282: PUSH
109283: LD_VAR 0 14
109287: PUSH
109288: LD_VAR 0 15
109292: DIFF
109293: ST_TO_ADDR
// end ; if not f_murder then
109294: LD_VAR 0 20
109298: NOT
109299: IFFALSE 109357
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
109301: LD_ADDR_VAR 0 15
109305: PUSH
109306: LD_VAR 0 14
109310: PPUSH
109311: LD_INT 3
109313: PUSH
109314: LD_INT 50
109316: PUSH
109317: EMPTY
109318: LIST
109319: PUSH
109320: EMPTY
109321: LIST
109322: LIST
109323: PPUSH
109324: CALL_OW 72
109328: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109329: LD_VAR 0 14
109333: PUSH
109334: LD_VAR 0 15
109338: DIFF
109339: IFFALSE 109357
// tmp := tmp diff tmp2 ;
109341: LD_ADDR_VAR 0 14
109345: PUSH
109346: LD_VAR 0 14
109350: PUSH
109351: LD_VAR 0 15
109355: DIFF
109356: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
109357: LD_ADDR_VAR 0 14
109361: PUSH
109362: LD_VAR 0 4
109366: PUSH
109367: LD_VAR 0 7
109371: ARRAY
109372: PPUSH
109373: LD_VAR 0 14
109377: PPUSH
109378: LD_INT 1
109380: PPUSH
109381: LD_INT 1
109383: PPUSH
109384: CALL 20522 0 4
109388: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
109389: LD_VAR 0 4
109393: PUSH
109394: LD_VAR 0 7
109398: ARRAY
109399: PPUSH
109400: CALL_OW 257
109404: PUSH
109405: LD_INT 1
109407: EQUAL
109408: IFFALSE 109856
// begin if WantPlant ( group [ i ] ) then
109410: LD_VAR 0 4
109414: PUSH
109415: LD_VAR 0 7
109419: ARRAY
109420: PPUSH
109421: CALL 20023 0 1
109425: IFFALSE 109429
// continue ;
109427: GO 107701
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
109429: LD_VAR 0 18
109433: PUSH
109434: LD_VAR 0 4
109438: PUSH
109439: LD_VAR 0 7
109443: ARRAY
109444: PPUSH
109445: CALL_OW 310
109449: NOT
109450: AND
109451: PUSH
109452: LD_VAR 0 14
109456: PUSH
109457: LD_INT 1
109459: ARRAY
109460: PUSH
109461: LD_VAR 0 14
109465: PPUSH
109466: LD_INT 21
109468: PUSH
109469: LD_INT 2
109471: PUSH
109472: EMPTY
109473: LIST
109474: LIST
109475: PUSH
109476: LD_INT 58
109478: PUSH
109479: EMPTY
109480: LIST
109481: PUSH
109482: EMPTY
109483: LIST
109484: LIST
109485: PPUSH
109486: CALL_OW 72
109490: IN
109491: AND
109492: IFFALSE 109528
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
109494: LD_VAR 0 4
109498: PUSH
109499: LD_VAR 0 7
109503: ARRAY
109504: PPUSH
109505: LD_VAR 0 14
109509: PUSH
109510: LD_INT 1
109512: ARRAY
109513: PPUSH
109514: CALL_OW 120
// attacking := true ;
109518: LD_ADDR_VAR 0 29
109522: PUSH
109523: LD_INT 1
109525: ST_TO_ADDR
// continue ;
109526: GO 107701
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
109528: LD_VAR 0 26
109532: PUSH
109533: LD_VAR 0 4
109537: PUSH
109538: LD_VAR 0 7
109542: ARRAY
109543: PPUSH
109544: CALL_OW 257
109548: PUSH
109549: LD_INT 1
109551: EQUAL
109552: AND
109553: PUSH
109554: LD_VAR 0 4
109558: PUSH
109559: LD_VAR 0 7
109563: ARRAY
109564: PPUSH
109565: CALL_OW 256
109569: PUSH
109570: LD_INT 800
109572: LESS
109573: AND
109574: PUSH
109575: LD_VAR 0 4
109579: PUSH
109580: LD_VAR 0 7
109584: ARRAY
109585: PPUSH
109586: CALL_OW 318
109590: NOT
109591: AND
109592: IFFALSE 109609
// ComCrawl ( group [ i ] ) ;
109594: LD_VAR 0 4
109598: PUSH
109599: LD_VAR 0 7
109603: ARRAY
109604: PPUSH
109605: CALL_OW 137
// if f_mines then
109609: LD_VAR 0 21
109613: IFFALSE 109856
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
109615: LD_VAR 0 14
109619: PUSH
109620: LD_INT 1
109622: ARRAY
109623: PPUSH
109624: CALL_OW 247
109628: PUSH
109629: LD_INT 3
109631: EQUAL
109632: PUSH
109633: LD_VAR 0 14
109637: PUSH
109638: LD_INT 1
109640: ARRAY
109641: PUSH
109642: LD_VAR 0 27
109646: IN
109647: NOT
109648: AND
109649: IFFALSE 109856
// begin x := GetX ( tmp [ 1 ] ) ;
109651: LD_ADDR_VAR 0 10
109655: PUSH
109656: LD_VAR 0 14
109660: PUSH
109661: LD_INT 1
109663: ARRAY
109664: PPUSH
109665: CALL_OW 250
109669: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
109670: LD_ADDR_VAR 0 11
109674: PUSH
109675: LD_VAR 0 14
109679: PUSH
109680: LD_INT 1
109682: ARRAY
109683: PPUSH
109684: CALL_OW 251
109688: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
109689: LD_ADDR_VAR 0 12
109693: PUSH
109694: LD_VAR 0 4
109698: PUSH
109699: LD_VAR 0 7
109703: ARRAY
109704: PPUSH
109705: CALL 47666 0 1
109709: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
109710: LD_VAR 0 4
109714: PUSH
109715: LD_VAR 0 7
109719: ARRAY
109720: PPUSH
109721: LD_VAR 0 10
109725: PPUSH
109726: LD_VAR 0 11
109730: PPUSH
109731: LD_VAR 0 14
109735: PUSH
109736: LD_INT 1
109738: ARRAY
109739: PPUSH
109740: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
109744: LD_VAR 0 4
109748: PUSH
109749: LD_VAR 0 7
109753: ARRAY
109754: PPUSH
109755: LD_VAR 0 10
109759: PPUSH
109760: LD_VAR 0 12
109764: PPUSH
109765: LD_INT 7
109767: PPUSH
109768: CALL_OW 272
109772: PPUSH
109773: LD_VAR 0 11
109777: PPUSH
109778: LD_VAR 0 12
109782: PPUSH
109783: LD_INT 7
109785: PPUSH
109786: CALL_OW 273
109790: PPUSH
109791: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
109795: LD_VAR 0 4
109799: PUSH
109800: LD_VAR 0 7
109804: ARRAY
109805: PPUSH
109806: LD_INT 71
109808: PPUSH
109809: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
109813: LD_ADDR_VAR 0 27
109817: PUSH
109818: LD_VAR 0 27
109822: PPUSH
109823: LD_VAR 0 27
109827: PUSH
109828: LD_INT 1
109830: PLUS
109831: PPUSH
109832: LD_VAR 0 14
109836: PUSH
109837: LD_INT 1
109839: ARRAY
109840: PPUSH
109841: CALL_OW 1
109845: ST_TO_ADDR
// attacking := true ;
109846: LD_ADDR_VAR 0 29
109850: PUSH
109851: LD_INT 1
109853: ST_TO_ADDR
// continue ;
109854: GO 107701
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
109856: LD_VAR 0 4
109860: PUSH
109861: LD_VAR 0 7
109865: ARRAY
109866: PPUSH
109867: CALL_OW 257
109871: PUSH
109872: LD_INT 17
109874: EQUAL
109875: PUSH
109876: LD_VAR 0 4
109880: PUSH
109881: LD_VAR 0 7
109885: ARRAY
109886: PPUSH
109887: CALL_OW 110
109891: PUSH
109892: LD_INT 71
109894: EQUAL
109895: NOT
109896: AND
109897: IFFALSE 110043
// begin attacking := false ;
109899: LD_ADDR_VAR 0 29
109903: PUSH
109904: LD_INT 0
109906: ST_TO_ADDR
// k := 5 ;
109907: LD_ADDR_VAR 0 9
109911: PUSH
109912: LD_INT 5
109914: ST_TO_ADDR
// if tmp < k then
109915: LD_VAR 0 14
109919: PUSH
109920: LD_VAR 0 9
109924: LESS
109925: IFFALSE 109937
// k := tmp ;
109927: LD_ADDR_VAR 0 9
109931: PUSH
109932: LD_VAR 0 14
109936: ST_TO_ADDR
// for j = 1 to k do
109937: LD_ADDR_VAR 0 8
109941: PUSH
109942: DOUBLE
109943: LD_INT 1
109945: DEC
109946: ST_TO_ADDR
109947: LD_VAR 0 9
109951: PUSH
109952: FOR_TO
109953: IFFALSE 110041
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
109955: LD_VAR 0 14
109959: PUSH
109960: LD_VAR 0 8
109964: ARRAY
109965: PUSH
109966: LD_VAR 0 14
109970: PPUSH
109971: LD_INT 58
109973: PUSH
109974: EMPTY
109975: LIST
109976: PPUSH
109977: CALL_OW 72
109981: IN
109982: NOT
109983: IFFALSE 110039
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109985: LD_VAR 0 4
109989: PUSH
109990: LD_VAR 0 7
109994: ARRAY
109995: PPUSH
109996: LD_VAR 0 14
110000: PUSH
110001: LD_VAR 0 8
110005: ARRAY
110006: PPUSH
110007: CALL_OW 115
// attacking := true ;
110011: LD_ADDR_VAR 0 29
110015: PUSH
110016: LD_INT 1
110018: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
110019: LD_VAR 0 4
110023: PUSH
110024: LD_VAR 0 7
110028: ARRAY
110029: PPUSH
110030: LD_INT 71
110032: PPUSH
110033: CALL_OW 109
// continue ;
110037: GO 109952
// end ; end ;
110039: GO 109952
110041: POP
110042: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
110043: LD_VAR 0 4
110047: PUSH
110048: LD_VAR 0 7
110052: ARRAY
110053: PPUSH
110054: CALL_OW 257
110058: PUSH
110059: LD_INT 8
110061: EQUAL
110062: PUSH
110063: LD_VAR 0 4
110067: PUSH
110068: LD_VAR 0 7
110072: ARRAY
110073: PPUSH
110074: CALL_OW 264
110078: PUSH
110079: LD_INT 28
110081: PUSH
110082: LD_INT 45
110084: PUSH
110085: LD_INT 7
110087: PUSH
110088: LD_INT 47
110090: PUSH
110091: EMPTY
110092: LIST
110093: LIST
110094: LIST
110095: LIST
110096: IN
110097: OR
110098: IFFALSE 110354
// begin attacking := false ;
110100: LD_ADDR_VAR 0 29
110104: PUSH
110105: LD_INT 0
110107: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
110108: LD_VAR 0 14
110112: PUSH
110113: LD_INT 1
110115: ARRAY
110116: PPUSH
110117: CALL_OW 266
110121: PUSH
110122: LD_INT 32
110124: PUSH
110125: LD_INT 31
110127: PUSH
110128: LD_INT 33
110130: PUSH
110131: LD_INT 4
110133: PUSH
110134: LD_INT 5
110136: PUSH
110137: EMPTY
110138: LIST
110139: LIST
110140: LIST
110141: LIST
110142: LIST
110143: IN
110144: IFFALSE 110330
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
110146: LD_ADDR_VAR 0 9
110150: PUSH
110151: LD_VAR 0 14
110155: PUSH
110156: LD_INT 1
110158: ARRAY
110159: PPUSH
110160: CALL_OW 266
110164: PPUSH
110165: LD_VAR 0 14
110169: PUSH
110170: LD_INT 1
110172: ARRAY
110173: PPUSH
110174: CALL_OW 250
110178: PPUSH
110179: LD_VAR 0 14
110183: PUSH
110184: LD_INT 1
110186: ARRAY
110187: PPUSH
110188: CALL_OW 251
110192: PPUSH
110193: LD_VAR 0 14
110197: PUSH
110198: LD_INT 1
110200: ARRAY
110201: PPUSH
110202: CALL_OW 254
110206: PPUSH
110207: LD_VAR 0 14
110211: PUSH
110212: LD_INT 1
110214: ARRAY
110215: PPUSH
110216: CALL_OW 248
110220: PPUSH
110221: LD_INT 0
110223: PPUSH
110224: CALL 29036 0 6
110228: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
110229: LD_ADDR_VAR 0 8
110233: PUSH
110234: LD_VAR 0 4
110238: PUSH
110239: LD_VAR 0 7
110243: ARRAY
110244: PPUSH
110245: LD_VAR 0 9
110249: PPUSH
110250: CALL 47779 0 2
110254: ST_TO_ADDR
// if j then
110255: LD_VAR 0 8
110259: IFFALSE 110328
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
110261: LD_VAR 0 8
110265: PUSH
110266: LD_INT 1
110268: ARRAY
110269: PPUSH
110270: LD_VAR 0 8
110274: PUSH
110275: LD_INT 2
110277: ARRAY
110278: PPUSH
110279: CALL_OW 488
110283: IFFALSE 110328
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
110285: LD_VAR 0 4
110289: PUSH
110290: LD_VAR 0 7
110294: ARRAY
110295: PPUSH
110296: LD_VAR 0 8
110300: PUSH
110301: LD_INT 1
110303: ARRAY
110304: PPUSH
110305: LD_VAR 0 8
110309: PUSH
110310: LD_INT 2
110312: ARRAY
110313: PPUSH
110314: CALL_OW 116
// attacking := true ;
110318: LD_ADDR_VAR 0 29
110322: PUSH
110323: LD_INT 1
110325: ST_TO_ADDR
// continue ;
110326: GO 107701
// end ; end else
110328: GO 110354
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110330: LD_VAR 0 4
110334: PUSH
110335: LD_VAR 0 7
110339: ARRAY
110340: PPUSH
110341: LD_VAR 0 14
110345: PUSH
110346: LD_INT 1
110348: ARRAY
110349: PPUSH
110350: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
110354: LD_VAR 0 4
110358: PUSH
110359: LD_VAR 0 7
110363: ARRAY
110364: PPUSH
110365: CALL_OW 265
110369: PUSH
110370: LD_INT 11
110372: EQUAL
110373: IFFALSE 110651
// begin k := 10 ;
110375: LD_ADDR_VAR 0 9
110379: PUSH
110380: LD_INT 10
110382: ST_TO_ADDR
// x := 0 ;
110383: LD_ADDR_VAR 0 10
110387: PUSH
110388: LD_INT 0
110390: ST_TO_ADDR
// if tmp < k then
110391: LD_VAR 0 14
110395: PUSH
110396: LD_VAR 0 9
110400: LESS
110401: IFFALSE 110413
// k := tmp ;
110403: LD_ADDR_VAR 0 9
110407: PUSH
110408: LD_VAR 0 14
110412: ST_TO_ADDR
// for j = k downto 1 do
110413: LD_ADDR_VAR 0 8
110417: PUSH
110418: DOUBLE
110419: LD_VAR 0 9
110423: INC
110424: ST_TO_ADDR
110425: LD_INT 1
110427: PUSH
110428: FOR_DOWNTO
110429: IFFALSE 110504
// begin if GetType ( tmp [ j ] ) = unit_human then
110431: LD_VAR 0 14
110435: PUSH
110436: LD_VAR 0 8
110440: ARRAY
110441: PPUSH
110442: CALL_OW 247
110446: PUSH
110447: LD_INT 1
110449: EQUAL
110450: IFFALSE 110502
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
110452: LD_VAR 0 4
110456: PUSH
110457: LD_VAR 0 7
110461: ARRAY
110462: PPUSH
110463: LD_VAR 0 14
110467: PUSH
110468: LD_VAR 0 8
110472: ARRAY
110473: PPUSH
110474: CALL 48033 0 2
// x := tmp [ j ] ;
110478: LD_ADDR_VAR 0 10
110482: PUSH
110483: LD_VAR 0 14
110487: PUSH
110488: LD_VAR 0 8
110492: ARRAY
110493: ST_TO_ADDR
// attacking := true ;
110494: LD_ADDR_VAR 0 29
110498: PUSH
110499: LD_INT 1
110501: ST_TO_ADDR
// end ; end ;
110502: GO 110428
110504: POP
110505: POP
// if not x then
110506: LD_VAR 0 10
110510: NOT
110511: IFFALSE 110651
// begin attacking := true ;
110513: LD_ADDR_VAR 0 29
110517: PUSH
110518: LD_INT 1
110520: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
110521: LD_VAR 0 4
110525: PUSH
110526: LD_VAR 0 7
110530: ARRAY
110531: PPUSH
110532: CALL_OW 250
110536: PPUSH
110537: LD_VAR 0 4
110541: PUSH
110542: LD_VAR 0 7
110546: ARRAY
110547: PPUSH
110548: CALL_OW 251
110552: PPUSH
110553: CALL_OW 546
110557: PUSH
110558: LD_INT 2
110560: ARRAY
110561: PUSH
110562: LD_VAR 0 14
110566: PUSH
110567: LD_INT 1
110569: ARRAY
110570: PPUSH
110571: CALL_OW 250
110575: PPUSH
110576: LD_VAR 0 14
110580: PUSH
110581: LD_INT 1
110583: ARRAY
110584: PPUSH
110585: CALL_OW 251
110589: PPUSH
110590: CALL_OW 546
110594: PUSH
110595: LD_INT 2
110597: ARRAY
110598: EQUAL
110599: IFFALSE 110627
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
110601: LD_VAR 0 4
110605: PUSH
110606: LD_VAR 0 7
110610: ARRAY
110611: PPUSH
110612: LD_VAR 0 14
110616: PUSH
110617: LD_INT 1
110619: ARRAY
110620: PPUSH
110621: CALL 48033 0 2
110625: GO 110651
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110627: LD_VAR 0 4
110631: PUSH
110632: LD_VAR 0 7
110636: ARRAY
110637: PPUSH
110638: LD_VAR 0 14
110642: PUSH
110643: LD_INT 1
110645: ARRAY
110646: PPUSH
110647: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
110651: LD_VAR 0 4
110655: PUSH
110656: LD_VAR 0 7
110660: ARRAY
110661: PPUSH
110662: CALL_OW 264
110666: PUSH
110667: LD_INT 29
110669: EQUAL
110670: IFFALSE 111036
// begin if WantsToAttack ( group [ i ] ) in bombed then
110672: LD_VAR 0 4
110676: PUSH
110677: LD_VAR 0 7
110681: ARRAY
110682: PPUSH
110683: CALL_OW 319
110687: PUSH
110688: LD_VAR 0 28
110692: IN
110693: IFFALSE 110697
// continue ;
110695: GO 107701
// k := 8 ;
110697: LD_ADDR_VAR 0 9
110701: PUSH
110702: LD_INT 8
110704: ST_TO_ADDR
// x := 0 ;
110705: LD_ADDR_VAR 0 10
110709: PUSH
110710: LD_INT 0
110712: ST_TO_ADDR
// if tmp < k then
110713: LD_VAR 0 14
110717: PUSH
110718: LD_VAR 0 9
110722: LESS
110723: IFFALSE 110735
// k := tmp ;
110725: LD_ADDR_VAR 0 9
110729: PUSH
110730: LD_VAR 0 14
110734: ST_TO_ADDR
// for j = 1 to k do
110735: LD_ADDR_VAR 0 8
110739: PUSH
110740: DOUBLE
110741: LD_INT 1
110743: DEC
110744: ST_TO_ADDR
110745: LD_VAR 0 9
110749: PUSH
110750: FOR_TO
110751: IFFALSE 110883
// begin if GetType ( tmp [ j ] ) = unit_building then
110753: LD_VAR 0 14
110757: PUSH
110758: LD_VAR 0 8
110762: ARRAY
110763: PPUSH
110764: CALL_OW 247
110768: PUSH
110769: LD_INT 3
110771: EQUAL
110772: IFFALSE 110881
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
110774: LD_VAR 0 14
110778: PUSH
110779: LD_VAR 0 8
110783: ARRAY
110784: PUSH
110785: LD_VAR 0 28
110789: IN
110790: NOT
110791: PUSH
110792: LD_VAR 0 14
110796: PUSH
110797: LD_VAR 0 8
110801: ARRAY
110802: PPUSH
110803: CALL_OW 313
110807: AND
110808: IFFALSE 110881
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110810: LD_VAR 0 4
110814: PUSH
110815: LD_VAR 0 7
110819: ARRAY
110820: PPUSH
110821: LD_VAR 0 14
110825: PUSH
110826: LD_VAR 0 8
110830: ARRAY
110831: PPUSH
110832: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
110836: LD_ADDR_VAR 0 28
110840: PUSH
110841: LD_VAR 0 28
110845: PPUSH
110846: LD_VAR 0 28
110850: PUSH
110851: LD_INT 1
110853: PLUS
110854: PPUSH
110855: LD_VAR 0 14
110859: PUSH
110860: LD_VAR 0 8
110864: ARRAY
110865: PPUSH
110866: CALL_OW 1
110870: ST_TO_ADDR
// attacking := true ;
110871: LD_ADDR_VAR 0 29
110875: PUSH
110876: LD_INT 1
110878: ST_TO_ADDR
// break ;
110879: GO 110883
// end ; end ;
110881: GO 110750
110883: POP
110884: POP
// if not attacking and f_attack_depot then
110885: LD_VAR 0 29
110889: NOT
110890: PUSH
110891: LD_VAR 0 25
110895: AND
110896: IFFALSE 110991
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
110898: LD_ADDR_VAR 0 13
110902: PUSH
110903: LD_VAR 0 14
110907: PPUSH
110908: LD_INT 2
110910: PUSH
110911: LD_INT 30
110913: PUSH
110914: LD_INT 0
110916: PUSH
110917: EMPTY
110918: LIST
110919: LIST
110920: PUSH
110921: LD_INT 30
110923: PUSH
110924: LD_INT 1
110926: PUSH
110927: EMPTY
110928: LIST
110929: LIST
110930: PUSH
110931: EMPTY
110932: LIST
110933: LIST
110934: LIST
110935: PPUSH
110936: CALL_OW 72
110940: ST_TO_ADDR
// if z then
110941: LD_VAR 0 13
110945: IFFALSE 110991
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
110947: LD_VAR 0 4
110951: PUSH
110952: LD_VAR 0 7
110956: ARRAY
110957: PPUSH
110958: LD_VAR 0 13
110962: PPUSH
110963: LD_VAR 0 4
110967: PUSH
110968: LD_VAR 0 7
110972: ARRAY
110973: PPUSH
110974: CALL_OW 74
110978: PPUSH
110979: CALL_OW 115
// attacking := true ;
110983: LD_ADDR_VAR 0 29
110987: PUSH
110988: LD_INT 1
110990: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
110991: LD_VAR 0 4
110995: PUSH
110996: LD_VAR 0 7
111000: ARRAY
111001: PPUSH
111002: CALL_OW 256
111006: PUSH
111007: LD_INT 500
111009: LESS
111010: IFFALSE 111036
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111012: LD_VAR 0 4
111016: PUSH
111017: LD_VAR 0 7
111021: ARRAY
111022: PPUSH
111023: LD_VAR 0 14
111027: PUSH
111028: LD_INT 1
111030: ARRAY
111031: PPUSH
111032: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
111036: LD_VAR 0 4
111040: PUSH
111041: LD_VAR 0 7
111045: ARRAY
111046: PPUSH
111047: CALL_OW 264
111051: PUSH
111052: LD_INT 49
111054: EQUAL
111055: IFFALSE 111176
// begin if not HasTask ( group [ i ] ) then
111057: LD_VAR 0 4
111061: PUSH
111062: LD_VAR 0 7
111066: ARRAY
111067: PPUSH
111068: CALL_OW 314
111072: NOT
111073: IFFALSE 111176
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
111075: LD_ADDR_VAR 0 9
111079: PUSH
111080: LD_INT 81
111082: PUSH
111083: LD_VAR 0 4
111087: PUSH
111088: LD_VAR 0 7
111092: ARRAY
111093: PPUSH
111094: CALL_OW 255
111098: PUSH
111099: EMPTY
111100: LIST
111101: LIST
111102: PPUSH
111103: CALL_OW 69
111107: PPUSH
111108: LD_VAR 0 4
111112: PUSH
111113: LD_VAR 0 7
111117: ARRAY
111118: PPUSH
111119: CALL_OW 74
111123: ST_TO_ADDR
// if k then
111124: LD_VAR 0 9
111128: IFFALSE 111176
// if GetDistUnits ( group [ i ] , k ) > 10 then
111130: LD_VAR 0 4
111134: PUSH
111135: LD_VAR 0 7
111139: ARRAY
111140: PPUSH
111141: LD_VAR 0 9
111145: PPUSH
111146: CALL_OW 296
111150: PUSH
111151: LD_INT 10
111153: GREATER
111154: IFFALSE 111176
// ComMoveUnit ( group [ i ] , k ) ;
111156: LD_VAR 0 4
111160: PUSH
111161: LD_VAR 0 7
111165: ARRAY
111166: PPUSH
111167: LD_VAR 0 9
111171: PPUSH
111172: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
111176: LD_VAR 0 4
111180: PUSH
111181: LD_VAR 0 7
111185: ARRAY
111186: PPUSH
111187: CALL_OW 256
111191: PUSH
111192: LD_INT 250
111194: LESS
111195: PUSH
111196: LD_VAR 0 4
111200: PUSH
111201: LD_VAR 0 7
111205: ARRAY
111206: PUSH
111207: LD_INT 21
111209: PUSH
111210: LD_INT 2
111212: PUSH
111213: EMPTY
111214: LIST
111215: LIST
111216: PUSH
111217: LD_INT 23
111219: PUSH
111220: LD_INT 2
111222: PUSH
111223: EMPTY
111224: LIST
111225: LIST
111226: PUSH
111227: EMPTY
111228: LIST
111229: LIST
111230: PPUSH
111231: CALL_OW 69
111235: IN
111236: AND
111237: IFFALSE 111362
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
111239: LD_ADDR_VAR 0 9
111243: PUSH
111244: LD_OWVAR 3
111248: PUSH
111249: LD_VAR 0 4
111253: PUSH
111254: LD_VAR 0 7
111258: ARRAY
111259: DIFF
111260: PPUSH
111261: LD_VAR 0 4
111265: PUSH
111266: LD_VAR 0 7
111270: ARRAY
111271: PPUSH
111272: CALL_OW 74
111276: ST_TO_ADDR
// if not k then
111277: LD_VAR 0 9
111281: NOT
111282: IFFALSE 111286
// continue ;
111284: GO 107701
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
111286: LD_VAR 0 9
111290: PUSH
111291: LD_INT 81
111293: PUSH
111294: LD_VAR 0 4
111298: PUSH
111299: LD_VAR 0 7
111303: ARRAY
111304: PPUSH
111305: CALL_OW 255
111309: PUSH
111310: EMPTY
111311: LIST
111312: LIST
111313: PPUSH
111314: CALL_OW 69
111318: IN
111319: PUSH
111320: LD_VAR 0 9
111324: PPUSH
111325: LD_VAR 0 4
111329: PUSH
111330: LD_VAR 0 7
111334: ARRAY
111335: PPUSH
111336: CALL_OW 296
111340: PUSH
111341: LD_INT 5
111343: LESS
111344: AND
111345: IFFALSE 111362
// ComAutodestruct ( group [ i ] ) ;
111347: LD_VAR 0 4
111351: PUSH
111352: LD_VAR 0 7
111356: ARRAY
111357: PPUSH
111358: CALL 47931 0 1
// end ; if f_attack_depot then
111362: LD_VAR 0 25
111366: IFFALSE 111478
// begin k := 6 ;
111368: LD_ADDR_VAR 0 9
111372: PUSH
111373: LD_INT 6
111375: ST_TO_ADDR
// if tmp < k then
111376: LD_VAR 0 14
111380: PUSH
111381: LD_VAR 0 9
111385: LESS
111386: IFFALSE 111398
// k := tmp ;
111388: LD_ADDR_VAR 0 9
111392: PUSH
111393: LD_VAR 0 14
111397: ST_TO_ADDR
// for j = 1 to k do
111398: LD_ADDR_VAR 0 8
111402: PUSH
111403: DOUBLE
111404: LD_INT 1
111406: DEC
111407: ST_TO_ADDR
111408: LD_VAR 0 9
111412: PUSH
111413: FOR_TO
111414: IFFALSE 111476
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
111416: LD_VAR 0 8
111420: PPUSH
111421: CALL_OW 266
111425: PUSH
111426: LD_INT 0
111428: PUSH
111429: LD_INT 1
111431: PUSH
111432: EMPTY
111433: LIST
111434: LIST
111435: IN
111436: IFFALSE 111474
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111438: LD_VAR 0 4
111442: PUSH
111443: LD_VAR 0 7
111447: ARRAY
111448: PPUSH
111449: LD_VAR 0 14
111453: PUSH
111454: LD_VAR 0 8
111458: ARRAY
111459: PPUSH
111460: CALL_OW 115
// attacking := true ;
111464: LD_ADDR_VAR 0 29
111468: PUSH
111469: LD_INT 1
111471: ST_TO_ADDR
// break ;
111472: GO 111476
// end ;
111474: GO 111413
111476: POP
111477: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
111478: LD_VAR 0 4
111482: PUSH
111483: LD_VAR 0 7
111487: ARRAY
111488: PPUSH
111489: CALL_OW 302
111493: PUSH
111494: LD_VAR 0 29
111498: NOT
111499: AND
111500: IFFALSE 111822
// begin if GetTag ( group [ i ] ) = 71 then
111502: LD_VAR 0 4
111506: PUSH
111507: LD_VAR 0 7
111511: ARRAY
111512: PPUSH
111513: CALL_OW 110
111517: PUSH
111518: LD_INT 71
111520: EQUAL
111521: IFFALSE 111562
// begin if HasTask ( group [ i ] ) then
111523: LD_VAR 0 4
111527: PUSH
111528: LD_VAR 0 7
111532: ARRAY
111533: PPUSH
111534: CALL_OW 314
111538: IFFALSE 111544
// continue else
111540: GO 107701
111542: GO 111562
// SetTag ( group [ i ] , 0 ) ;
111544: LD_VAR 0 4
111548: PUSH
111549: LD_VAR 0 7
111553: ARRAY
111554: PPUSH
111555: LD_INT 0
111557: PPUSH
111558: CALL_OW 109
// end ; k := 8 ;
111562: LD_ADDR_VAR 0 9
111566: PUSH
111567: LD_INT 8
111569: ST_TO_ADDR
// x := 0 ;
111570: LD_ADDR_VAR 0 10
111574: PUSH
111575: LD_INT 0
111577: ST_TO_ADDR
// if tmp < k then
111578: LD_VAR 0 14
111582: PUSH
111583: LD_VAR 0 9
111587: LESS
111588: IFFALSE 111600
// k := tmp ;
111590: LD_ADDR_VAR 0 9
111594: PUSH
111595: LD_VAR 0 14
111599: ST_TO_ADDR
// for j = 1 to k do
111600: LD_ADDR_VAR 0 8
111604: PUSH
111605: DOUBLE
111606: LD_INT 1
111608: DEC
111609: ST_TO_ADDR
111610: LD_VAR 0 9
111614: PUSH
111615: FOR_TO
111616: IFFALSE 111714
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
111618: LD_VAR 0 14
111622: PUSH
111623: LD_VAR 0 8
111627: ARRAY
111628: PPUSH
111629: CALL_OW 247
111633: PUSH
111634: LD_INT 1
111636: EQUAL
111637: PUSH
111638: LD_VAR 0 14
111642: PUSH
111643: LD_VAR 0 8
111647: ARRAY
111648: PPUSH
111649: CALL_OW 256
111653: PUSH
111654: LD_INT 250
111656: LESS
111657: PUSH
111658: LD_VAR 0 20
111662: AND
111663: PUSH
111664: LD_VAR 0 20
111668: NOT
111669: PUSH
111670: LD_VAR 0 14
111674: PUSH
111675: LD_VAR 0 8
111679: ARRAY
111680: PPUSH
111681: CALL_OW 256
111685: PUSH
111686: LD_INT 250
111688: GREATEREQUAL
111689: AND
111690: OR
111691: AND
111692: IFFALSE 111712
// begin x := tmp [ j ] ;
111694: LD_ADDR_VAR 0 10
111698: PUSH
111699: LD_VAR 0 14
111703: PUSH
111704: LD_VAR 0 8
111708: ARRAY
111709: ST_TO_ADDR
// break ;
111710: GO 111714
// end ;
111712: GO 111615
111714: POP
111715: POP
// if x then
111716: LD_VAR 0 10
111720: IFFALSE 111744
// ComAttackUnit ( group [ i ] , x ) else
111722: LD_VAR 0 4
111726: PUSH
111727: LD_VAR 0 7
111731: ARRAY
111732: PPUSH
111733: LD_VAR 0 10
111737: PPUSH
111738: CALL_OW 115
111742: GO 111768
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111744: LD_VAR 0 4
111748: PUSH
111749: LD_VAR 0 7
111753: ARRAY
111754: PPUSH
111755: LD_VAR 0 14
111759: PUSH
111760: LD_INT 1
111762: ARRAY
111763: PPUSH
111764: CALL_OW 115
// if not HasTask ( group [ i ] ) then
111768: LD_VAR 0 4
111772: PUSH
111773: LD_VAR 0 7
111777: ARRAY
111778: PPUSH
111779: CALL_OW 314
111783: NOT
111784: IFFALSE 111822
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
111786: LD_VAR 0 4
111790: PUSH
111791: LD_VAR 0 7
111795: ARRAY
111796: PPUSH
111797: LD_VAR 0 14
111801: PPUSH
111802: LD_VAR 0 4
111806: PUSH
111807: LD_VAR 0 7
111811: ARRAY
111812: PPUSH
111813: CALL_OW 74
111817: PPUSH
111818: CALL_OW 115
// end ; end ; end ;
111822: GO 107701
111824: POP
111825: POP
// wait ( 0 0$2 ) ;
111826: LD_INT 70
111828: PPUSH
111829: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
111833: LD_VAR 0 4
111837: NOT
111838: PUSH
111839: LD_VAR 0 4
111843: PUSH
111844: EMPTY
111845: EQUAL
111846: OR
111847: PUSH
111848: LD_INT 81
111850: PUSH
111851: LD_VAR 0 35
111855: PUSH
111856: EMPTY
111857: LIST
111858: LIST
111859: PPUSH
111860: CALL_OW 69
111864: NOT
111865: OR
111866: IFFALSE 107686
// end ;
111868: LD_VAR 0 2
111872: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
111873: LD_INT 0
111875: PPUSH
111876: PPUSH
111877: PPUSH
111878: PPUSH
111879: PPUSH
111880: PPUSH
// if not base or not mc_bases [ base ] or not solds then
111881: LD_VAR 0 1
111885: NOT
111886: PUSH
111887: LD_EXP 61
111891: PUSH
111892: LD_VAR 0 1
111896: ARRAY
111897: NOT
111898: OR
111899: PUSH
111900: LD_VAR 0 2
111904: NOT
111905: OR
111906: IFFALSE 111910
// exit ;
111908: GO 112464
// side := mc_sides [ base ] ;
111910: LD_ADDR_VAR 0 6
111914: PUSH
111915: LD_EXP 87
111919: PUSH
111920: LD_VAR 0 1
111924: ARRAY
111925: ST_TO_ADDR
// if not side then
111926: LD_VAR 0 6
111930: NOT
111931: IFFALSE 111935
// exit ;
111933: GO 112464
// for i in solds do
111935: LD_ADDR_VAR 0 7
111939: PUSH
111940: LD_VAR 0 2
111944: PUSH
111945: FOR_IN
111946: IFFALSE 112007
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
111948: LD_VAR 0 7
111952: PPUSH
111953: CALL_OW 310
111957: PPUSH
111958: CALL_OW 266
111962: PUSH
111963: LD_INT 32
111965: PUSH
111966: LD_INT 31
111968: PUSH
111969: EMPTY
111970: LIST
111971: LIST
111972: IN
111973: IFFALSE 111993
// solds := solds diff i else
111975: LD_ADDR_VAR 0 2
111979: PUSH
111980: LD_VAR 0 2
111984: PUSH
111985: LD_VAR 0 7
111989: DIFF
111990: ST_TO_ADDR
111991: GO 112005
// SetTag ( i , 18 ) ;
111993: LD_VAR 0 7
111997: PPUSH
111998: LD_INT 18
112000: PPUSH
112001: CALL_OW 109
112005: GO 111945
112007: POP
112008: POP
// if not solds then
112009: LD_VAR 0 2
112013: NOT
112014: IFFALSE 112018
// exit ;
112016: GO 112464
// repeat wait ( 0 0$2 ) ;
112018: LD_INT 70
112020: PPUSH
112021: CALL_OW 67
// enemy := mc_scan [ base ] ;
112025: LD_ADDR_VAR 0 4
112029: PUSH
112030: LD_EXP 84
112034: PUSH
112035: LD_VAR 0 1
112039: ARRAY
112040: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112041: LD_EXP 61
112045: PUSH
112046: LD_VAR 0 1
112050: ARRAY
112051: NOT
112052: PUSH
112053: LD_EXP 61
112057: PUSH
112058: LD_VAR 0 1
112062: ARRAY
112063: PUSH
112064: EMPTY
112065: EQUAL
112066: OR
112067: IFFALSE 112104
// begin for i in solds do
112069: LD_ADDR_VAR 0 7
112073: PUSH
112074: LD_VAR 0 2
112078: PUSH
112079: FOR_IN
112080: IFFALSE 112093
// ComStop ( i ) ;
112082: LD_VAR 0 7
112086: PPUSH
112087: CALL_OW 141
112091: GO 112079
112093: POP
112094: POP
// solds := [ ] ;
112095: LD_ADDR_VAR 0 2
112099: PUSH
112100: EMPTY
112101: ST_TO_ADDR
// exit ;
112102: GO 112464
// end ; for i in solds do
112104: LD_ADDR_VAR 0 7
112108: PUSH
112109: LD_VAR 0 2
112113: PUSH
112114: FOR_IN
112115: IFFALSE 112436
// begin if IsInUnit ( i ) then
112117: LD_VAR 0 7
112121: PPUSH
112122: CALL_OW 310
112126: IFFALSE 112137
// ComExitBuilding ( i ) ;
112128: LD_VAR 0 7
112132: PPUSH
112133: CALL_OW 122
// if GetLives ( i ) > 500 then
112137: LD_VAR 0 7
112141: PPUSH
112142: CALL_OW 256
112146: PUSH
112147: LD_INT 500
112149: GREATER
112150: IFFALSE 112203
// begin e := NearestUnitToUnit ( enemy , i ) ;
112152: LD_ADDR_VAR 0 5
112156: PUSH
112157: LD_VAR 0 4
112161: PPUSH
112162: LD_VAR 0 7
112166: PPUSH
112167: CALL_OW 74
112171: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
112172: LD_VAR 0 7
112176: PPUSH
112177: LD_VAR 0 5
112181: PPUSH
112182: CALL_OW 250
112186: PPUSH
112187: LD_VAR 0 5
112191: PPUSH
112192: CALL_OW 251
112196: PPUSH
112197: CALL_OW 114
// end else
112201: GO 112434
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
112203: LD_VAR 0 7
112207: PPUSH
112208: LD_EXP 61
112212: PUSH
112213: LD_VAR 0 1
112217: ARRAY
112218: PPUSH
112219: LD_INT 2
112221: PUSH
112222: LD_INT 30
112224: PUSH
112225: LD_INT 0
112227: PUSH
112228: EMPTY
112229: LIST
112230: LIST
112231: PUSH
112232: LD_INT 30
112234: PUSH
112235: LD_INT 1
112237: PUSH
112238: EMPTY
112239: LIST
112240: LIST
112241: PUSH
112242: LD_INT 30
112244: PUSH
112245: LD_INT 6
112247: PUSH
112248: EMPTY
112249: LIST
112250: LIST
112251: PUSH
112252: EMPTY
112253: LIST
112254: LIST
112255: LIST
112256: LIST
112257: PPUSH
112258: CALL_OW 72
112262: PPUSH
112263: LD_VAR 0 7
112267: PPUSH
112268: CALL_OW 74
112272: PPUSH
112273: CALL_OW 296
112277: PUSH
112278: LD_INT 10
112280: GREATER
112281: IFFALSE 112434
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
112283: LD_ADDR_VAR 0 8
112287: PUSH
112288: LD_EXP 61
112292: PUSH
112293: LD_VAR 0 1
112297: ARRAY
112298: PPUSH
112299: LD_INT 2
112301: PUSH
112302: LD_INT 30
112304: PUSH
112305: LD_INT 0
112307: PUSH
112308: EMPTY
112309: LIST
112310: LIST
112311: PUSH
112312: LD_INT 30
112314: PUSH
112315: LD_INT 1
112317: PUSH
112318: EMPTY
112319: LIST
112320: LIST
112321: PUSH
112322: LD_INT 30
112324: PUSH
112325: LD_INT 6
112327: PUSH
112328: EMPTY
112329: LIST
112330: LIST
112331: PUSH
112332: EMPTY
112333: LIST
112334: LIST
112335: LIST
112336: LIST
112337: PPUSH
112338: CALL_OW 72
112342: PPUSH
112343: LD_VAR 0 7
112347: PPUSH
112348: CALL_OW 74
112352: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
112353: LD_VAR 0 7
112357: PPUSH
112358: LD_VAR 0 8
112362: PPUSH
112363: CALL_OW 250
112367: PPUSH
112368: LD_INT 3
112370: PPUSH
112371: LD_INT 5
112373: PPUSH
112374: CALL_OW 272
112378: PPUSH
112379: LD_VAR 0 8
112383: PPUSH
112384: CALL_OW 251
112388: PPUSH
112389: LD_INT 3
112391: PPUSH
112392: LD_INT 5
112394: PPUSH
112395: CALL_OW 273
112399: PPUSH
112400: CALL_OW 111
// SetTag ( i , 0 ) ;
112404: LD_VAR 0 7
112408: PPUSH
112409: LD_INT 0
112411: PPUSH
112412: CALL_OW 109
// solds := solds diff i ;
112416: LD_ADDR_VAR 0 2
112420: PUSH
112421: LD_VAR 0 2
112425: PUSH
112426: LD_VAR 0 7
112430: DIFF
112431: ST_TO_ADDR
// continue ;
112432: GO 112114
// end ; end ;
112434: GO 112114
112436: POP
112437: POP
// until not solds or not enemy ;
112438: LD_VAR 0 2
112442: NOT
112443: PUSH
112444: LD_VAR 0 4
112448: NOT
112449: OR
112450: IFFALSE 112018
// MC_Reset ( base , 18 ) ;
112452: LD_VAR 0 1
112456: PPUSH
112457: LD_INT 18
112459: PPUSH
112460: CALL 60540 0 2
// end ;
112464: LD_VAR 0 3
112468: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
112469: LD_INT 0
112471: PPUSH
112472: PPUSH
112473: PPUSH
112474: PPUSH
112475: PPUSH
112476: PPUSH
112477: PPUSH
112478: PPUSH
112479: PPUSH
112480: PPUSH
112481: PPUSH
112482: PPUSH
112483: PPUSH
112484: PPUSH
112485: PPUSH
112486: PPUSH
112487: PPUSH
112488: PPUSH
112489: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
112490: LD_ADDR_VAR 0 12
112494: PUSH
112495: LD_EXP 61
112499: PUSH
112500: LD_VAR 0 1
112504: ARRAY
112505: PPUSH
112506: LD_INT 25
112508: PUSH
112509: LD_INT 3
112511: PUSH
112512: EMPTY
112513: LIST
112514: LIST
112515: PPUSH
112516: CALL_OW 72
112520: ST_TO_ADDR
// if mc_remote_driver [ base ] then
112521: LD_EXP 101
112525: PUSH
112526: LD_VAR 0 1
112530: ARRAY
112531: IFFALSE 112555
// mechs := mechs diff mc_remote_driver [ base ] ;
112533: LD_ADDR_VAR 0 12
112537: PUSH
112538: LD_VAR 0 12
112542: PUSH
112543: LD_EXP 101
112547: PUSH
112548: LD_VAR 0 1
112552: ARRAY
112553: DIFF
112554: ST_TO_ADDR
// for i in mechs do
112555: LD_ADDR_VAR 0 4
112559: PUSH
112560: LD_VAR 0 12
112564: PUSH
112565: FOR_IN
112566: IFFALSE 112601
// if GetTag ( i ) > 0 then
112568: LD_VAR 0 4
112572: PPUSH
112573: CALL_OW 110
112577: PUSH
112578: LD_INT 0
112580: GREATER
112581: IFFALSE 112599
// mechs := mechs diff i ;
112583: LD_ADDR_VAR 0 12
112587: PUSH
112588: LD_VAR 0 12
112592: PUSH
112593: LD_VAR 0 4
112597: DIFF
112598: ST_TO_ADDR
112599: GO 112565
112601: POP
112602: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
112603: LD_ADDR_VAR 0 8
112607: PUSH
112608: LD_EXP 61
112612: PUSH
112613: LD_VAR 0 1
112617: ARRAY
112618: PPUSH
112619: LD_INT 2
112621: PUSH
112622: LD_INT 25
112624: PUSH
112625: LD_INT 1
112627: PUSH
112628: EMPTY
112629: LIST
112630: LIST
112631: PUSH
112632: LD_INT 25
112634: PUSH
112635: LD_INT 5
112637: PUSH
112638: EMPTY
112639: LIST
112640: LIST
112641: PUSH
112642: LD_INT 25
112644: PUSH
112645: LD_INT 8
112647: PUSH
112648: EMPTY
112649: LIST
112650: LIST
112651: PUSH
112652: LD_INT 25
112654: PUSH
112655: LD_INT 9
112657: PUSH
112658: EMPTY
112659: LIST
112660: LIST
112661: PUSH
112662: EMPTY
112663: LIST
112664: LIST
112665: LIST
112666: LIST
112667: LIST
112668: PPUSH
112669: CALL_OW 72
112673: ST_TO_ADDR
// if not defenders and not solds then
112674: LD_VAR 0 2
112678: NOT
112679: PUSH
112680: LD_VAR 0 8
112684: NOT
112685: AND
112686: IFFALSE 112690
// exit ;
112688: GO 114460
// depot_under_attack := false ;
112690: LD_ADDR_VAR 0 16
112694: PUSH
112695: LD_INT 0
112697: ST_TO_ADDR
// sold_defenders := [ ] ;
112698: LD_ADDR_VAR 0 17
112702: PUSH
112703: EMPTY
112704: ST_TO_ADDR
// if mechs then
112705: LD_VAR 0 12
112709: IFFALSE 112862
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
112711: LD_ADDR_VAR 0 4
112715: PUSH
112716: LD_VAR 0 2
112720: PPUSH
112721: LD_INT 21
112723: PUSH
112724: LD_INT 2
112726: PUSH
112727: EMPTY
112728: LIST
112729: LIST
112730: PPUSH
112731: CALL_OW 72
112735: PUSH
112736: FOR_IN
112737: IFFALSE 112860
// begin if GetTag ( i ) <> 20 then
112739: LD_VAR 0 4
112743: PPUSH
112744: CALL_OW 110
112748: PUSH
112749: LD_INT 20
112751: NONEQUAL
112752: IFFALSE 112766
// SetTag ( i , 20 ) ;
112754: LD_VAR 0 4
112758: PPUSH
112759: LD_INT 20
112761: PPUSH
112762: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
112766: LD_VAR 0 4
112770: PPUSH
112771: CALL_OW 263
112775: PUSH
112776: LD_INT 1
112778: EQUAL
112779: PUSH
112780: LD_VAR 0 4
112784: PPUSH
112785: CALL_OW 311
112789: NOT
112790: AND
112791: IFFALSE 112858
// begin un := mechs [ 1 ] ;
112793: LD_ADDR_VAR 0 10
112797: PUSH
112798: LD_VAR 0 12
112802: PUSH
112803: LD_INT 1
112805: ARRAY
112806: ST_TO_ADDR
// ComExit ( un ) ;
112807: LD_VAR 0 10
112811: PPUSH
112812: CALL 52816 0 1
// AddComEnterUnit ( un , i ) ;
112816: LD_VAR 0 10
112820: PPUSH
112821: LD_VAR 0 4
112825: PPUSH
112826: CALL_OW 180
// SetTag ( un , 19 ) ;
112830: LD_VAR 0 10
112834: PPUSH
112835: LD_INT 19
112837: PPUSH
112838: CALL_OW 109
// mechs := mechs diff un ;
112842: LD_ADDR_VAR 0 12
112846: PUSH
112847: LD_VAR 0 12
112851: PUSH
112852: LD_VAR 0 10
112856: DIFF
112857: ST_TO_ADDR
// end ; end ;
112858: GO 112736
112860: POP
112861: POP
// if solds then
112862: LD_VAR 0 8
112866: IFFALSE 112925
// for i in solds do
112868: LD_ADDR_VAR 0 4
112872: PUSH
112873: LD_VAR 0 8
112877: PUSH
112878: FOR_IN
112879: IFFALSE 112923
// if not GetTag ( i ) then
112881: LD_VAR 0 4
112885: PPUSH
112886: CALL_OW 110
112890: NOT
112891: IFFALSE 112921
// begin defenders := defenders union i ;
112893: LD_ADDR_VAR 0 2
112897: PUSH
112898: LD_VAR 0 2
112902: PUSH
112903: LD_VAR 0 4
112907: UNION
112908: ST_TO_ADDR
// SetTag ( i , 18 ) ;
112909: LD_VAR 0 4
112913: PPUSH
112914: LD_INT 18
112916: PPUSH
112917: CALL_OW 109
// end ;
112921: GO 112878
112923: POP
112924: POP
// repeat wait ( 0 0$2 ) ;
112925: LD_INT 70
112927: PPUSH
112928: CALL_OW 67
// enemy := mc_scan [ base ] ;
112932: LD_ADDR_VAR 0 21
112936: PUSH
112937: LD_EXP 84
112941: PUSH
112942: LD_VAR 0 1
112946: ARRAY
112947: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112948: LD_EXP 61
112952: PUSH
112953: LD_VAR 0 1
112957: ARRAY
112958: NOT
112959: PUSH
112960: LD_EXP 61
112964: PUSH
112965: LD_VAR 0 1
112969: ARRAY
112970: PUSH
112971: EMPTY
112972: EQUAL
112973: OR
112974: IFFALSE 113011
// begin for i in defenders do
112976: LD_ADDR_VAR 0 4
112980: PUSH
112981: LD_VAR 0 2
112985: PUSH
112986: FOR_IN
112987: IFFALSE 113000
// ComStop ( i ) ;
112989: LD_VAR 0 4
112993: PPUSH
112994: CALL_OW 141
112998: GO 112986
113000: POP
113001: POP
// defenders := [ ] ;
113002: LD_ADDR_VAR 0 2
113006: PUSH
113007: EMPTY
113008: ST_TO_ADDR
// exit ;
113009: GO 114460
// end ; for i in defenders do
113011: LD_ADDR_VAR 0 4
113015: PUSH
113016: LD_VAR 0 2
113020: PUSH
113021: FOR_IN
113022: IFFALSE 113920
// begin e := NearestUnitToUnit ( enemy , i ) ;
113024: LD_ADDR_VAR 0 13
113028: PUSH
113029: LD_VAR 0 21
113033: PPUSH
113034: LD_VAR 0 4
113038: PPUSH
113039: CALL_OW 74
113043: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113044: LD_ADDR_VAR 0 7
113048: PUSH
113049: LD_EXP 61
113053: PUSH
113054: LD_VAR 0 1
113058: ARRAY
113059: PPUSH
113060: LD_INT 2
113062: PUSH
113063: LD_INT 30
113065: PUSH
113066: LD_INT 0
113068: PUSH
113069: EMPTY
113070: LIST
113071: LIST
113072: PUSH
113073: LD_INT 30
113075: PUSH
113076: LD_INT 1
113078: PUSH
113079: EMPTY
113080: LIST
113081: LIST
113082: PUSH
113083: EMPTY
113084: LIST
113085: LIST
113086: LIST
113087: PPUSH
113088: CALL_OW 72
113092: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
113093: LD_ADDR_VAR 0 16
113097: PUSH
113098: LD_VAR 0 7
113102: NOT
113103: PUSH
113104: LD_VAR 0 7
113108: PPUSH
113109: LD_INT 3
113111: PUSH
113112: LD_INT 24
113114: PUSH
113115: LD_INT 600
113117: PUSH
113118: EMPTY
113119: LIST
113120: LIST
113121: PUSH
113122: EMPTY
113123: LIST
113124: LIST
113125: PPUSH
113126: CALL_OW 72
113130: OR
113131: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
113132: LD_VAR 0 4
113136: PPUSH
113137: CALL_OW 247
113141: PUSH
113142: LD_INT 2
113144: DOUBLE
113145: EQUAL
113146: IFTRUE 113150
113148: GO 113546
113150: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
113151: LD_VAR 0 4
113155: PPUSH
113156: CALL_OW 256
113160: PUSH
113161: LD_INT 1000
113163: EQUAL
113164: PUSH
113165: LD_VAR 0 4
113169: PPUSH
113170: LD_VAR 0 13
113174: PPUSH
113175: CALL_OW 296
113179: PUSH
113180: LD_INT 40
113182: LESS
113183: PUSH
113184: LD_VAR 0 13
113188: PPUSH
113189: LD_EXP 86
113193: PUSH
113194: LD_VAR 0 1
113198: ARRAY
113199: PPUSH
113200: CALL_OW 308
113204: OR
113205: AND
113206: IFFALSE 113328
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
113208: LD_VAR 0 4
113212: PPUSH
113213: CALL_OW 262
113217: PUSH
113218: LD_INT 1
113220: EQUAL
113221: PUSH
113222: LD_VAR 0 4
113226: PPUSH
113227: CALL_OW 261
113231: PUSH
113232: LD_INT 30
113234: LESS
113235: AND
113236: PUSH
113237: LD_VAR 0 7
113241: AND
113242: IFFALSE 113312
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
113244: LD_VAR 0 4
113248: PPUSH
113249: LD_VAR 0 7
113253: PPUSH
113254: LD_VAR 0 4
113258: PPUSH
113259: CALL_OW 74
113263: PPUSH
113264: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
113268: LD_VAR 0 4
113272: PPUSH
113273: LD_VAR 0 7
113277: PPUSH
113278: LD_VAR 0 4
113282: PPUSH
113283: CALL_OW 74
113287: PPUSH
113288: CALL_OW 296
113292: PUSH
113293: LD_INT 6
113295: LESS
113296: IFFALSE 113310
// SetFuel ( i , 100 ) ;
113298: LD_VAR 0 4
113302: PPUSH
113303: LD_INT 100
113305: PPUSH
113306: CALL_OW 240
// end else
113310: GO 113326
// ComAttackUnit ( i , e ) ;
113312: LD_VAR 0 4
113316: PPUSH
113317: LD_VAR 0 13
113321: PPUSH
113322: CALL_OW 115
// end else
113326: GO 113429
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
113328: LD_VAR 0 13
113332: PPUSH
113333: LD_EXP 86
113337: PUSH
113338: LD_VAR 0 1
113342: ARRAY
113343: PPUSH
113344: CALL_OW 308
113348: NOT
113349: PUSH
113350: LD_VAR 0 4
113354: PPUSH
113355: LD_VAR 0 13
113359: PPUSH
113360: CALL_OW 296
113364: PUSH
113365: LD_INT 40
113367: GREATEREQUAL
113368: AND
113369: PUSH
113370: LD_VAR 0 4
113374: PPUSH
113375: CALL_OW 256
113379: PUSH
113380: LD_INT 650
113382: LESSEQUAL
113383: OR
113384: PUSH
113385: LD_VAR 0 4
113389: PPUSH
113390: LD_EXP 85
113394: PUSH
113395: LD_VAR 0 1
113399: ARRAY
113400: PPUSH
113401: CALL_OW 308
113405: NOT
113406: AND
113407: IFFALSE 113429
// ComMoveToArea ( i , mc_parking [ base ] ) ;
113409: LD_VAR 0 4
113413: PPUSH
113414: LD_EXP 85
113418: PUSH
113419: LD_VAR 0 1
113423: ARRAY
113424: PPUSH
113425: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
113429: LD_VAR 0 4
113433: PPUSH
113434: CALL_OW 256
113438: PUSH
113439: LD_INT 1000
113441: LESS
113442: PUSH
113443: LD_VAR 0 4
113447: PPUSH
113448: CALL_OW 263
113452: PUSH
113453: LD_INT 1
113455: EQUAL
113456: AND
113457: PUSH
113458: LD_VAR 0 4
113462: PPUSH
113463: CALL_OW 311
113467: AND
113468: PUSH
113469: LD_VAR 0 4
113473: PPUSH
113474: LD_EXP 85
113478: PUSH
113479: LD_VAR 0 1
113483: ARRAY
113484: PPUSH
113485: CALL_OW 308
113489: AND
113490: IFFALSE 113544
// begin mech := IsDrivenBy ( i ) ;
113492: LD_ADDR_VAR 0 9
113496: PUSH
113497: LD_VAR 0 4
113501: PPUSH
113502: CALL_OW 311
113506: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
113507: LD_VAR 0 9
113511: PPUSH
113512: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
113516: LD_VAR 0 9
113520: PPUSH
113521: LD_VAR 0 4
113525: PPUSH
113526: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
113530: LD_VAR 0 9
113534: PPUSH
113535: LD_VAR 0 4
113539: PPUSH
113540: CALL_OW 180
// end ; end ; unit_human :
113544: GO 113891
113546: LD_INT 1
113548: DOUBLE
113549: EQUAL
113550: IFTRUE 113554
113552: GO 113890
113554: POP
// begin b := IsInUnit ( i ) ;
113555: LD_ADDR_VAR 0 18
113559: PUSH
113560: LD_VAR 0 4
113564: PPUSH
113565: CALL_OW 310
113569: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
113570: LD_ADDR_VAR 0 19
113574: PUSH
113575: LD_VAR 0 18
113579: NOT
113580: PUSH
113581: LD_VAR 0 18
113585: PPUSH
113586: CALL_OW 266
113590: PUSH
113591: LD_INT 32
113593: PUSH
113594: LD_INT 31
113596: PUSH
113597: EMPTY
113598: LIST
113599: LIST
113600: IN
113601: OR
113602: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
113603: LD_VAR 0 18
113607: PPUSH
113608: CALL_OW 266
113612: PUSH
113613: LD_INT 5
113615: EQUAL
113616: PUSH
113617: LD_VAR 0 4
113621: PPUSH
113622: CALL_OW 257
113626: PUSH
113627: LD_INT 1
113629: PUSH
113630: LD_INT 2
113632: PUSH
113633: LD_INT 3
113635: PUSH
113636: LD_INT 4
113638: PUSH
113639: EMPTY
113640: LIST
113641: LIST
113642: LIST
113643: LIST
113644: IN
113645: AND
113646: IFFALSE 113683
// begin class := AllowSpecClass ( i ) ;
113648: LD_ADDR_VAR 0 20
113652: PUSH
113653: LD_VAR 0 4
113657: PPUSH
113658: CALL 16736 0 1
113662: ST_TO_ADDR
// if class then
113663: LD_VAR 0 20
113667: IFFALSE 113683
// ComChangeProfession ( i , class ) ;
113669: LD_VAR 0 4
113673: PPUSH
113674: LD_VAR 0 20
113678: PPUSH
113679: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
113683: LD_VAR 0 16
113687: PUSH
113688: LD_VAR 0 2
113692: PPUSH
113693: LD_INT 21
113695: PUSH
113696: LD_INT 2
113698: PUSH
113699: EMPTY
113700: LIST
113701: LIST
113702: PPUSH
113703: CALL_OW 72
113707: PUSH
113708: LD_INT 1
113710: LESSEQUAL
113711: OR
113712: PUSH
113713: LD_VAR 0 19
113717: AND
113718: PUSH
113719: LD_VAR 0 4
113723: PUSH
113724: LD_VAR 0 17
113728: IN
113729: NOT
113730: AND
113731: IFFALSE 113824
// begin if b then
113733: LD_VAR 0 18
113737: IFFALSE 113786
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
113739: LD_VAR 0 18
113743: PPUSH
113744: LD_VAR 0 21
113748: PPUSH
113749: LD_VAR 0 18
113753: PPUSH
113754: CALL_OW 74
113758: PPUSH
113759: CALL_OW 296
113763: PUSH
113764: LD_INT 10
113766: LESS
113767: PUSH
113768: LD_VAR 0 18
113772: PPUSH
113773: CALL_OW 461
113777: PUSH
113778: LD_INT 7
113780: NONEQUAL
113781: AND
113782: IFFALSE 113786
// continue ;
113784: GO 113021
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
113786: LD_ADDR_VAR 0 17
113790: PUSH
113791: LD_VAR 0 17
113795: PPUSH
113796: LD_VAR 0 17
113800: PUSH
113801: LD_INT 1
113803: PLUS
113804: PPUSH
113805: LD_VAR 0 4
113809: PPUSH
113810: CALL_OW 1
113814: ST_TO_ADDR
// ComExitBuilding ( i ) ;
113815: LD_VAR 0 4
113819: PPUSH
113820: CALL_OW 122
// end ; if sold_defenders then
113824: LD_VAR 0 17
113828: IFFALSE 113888
// if i in sold_defenders then
113830: LD_VAR 0 4
113834: PUSH
113835: LD_VAR 0 17
113839: IN
113840: IFFALSE 113888
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
113842: LD_VAR 0 4
113846: PPUSH
113847: CALL_OW 314
113851: NOT
113852: PUSH
113853: LD_VAR 0 4
113857: PPUSH
113858: LD_VAR 0 13
113862: PPUSH
113863: CALL_OW 296
113867: PUSH
113868: LD_INT 30
113870: LESS
113871: AND
113872: IFFALSE 113888
// ComAttackUnit ( i , e ) ;
113874: LD_VAR 0 4
113878: PPUSH
113879: LD_VAR 0 13
113883: PPUSH
113884: CALL_OW 115
// end ; end ; end ;
113888: GO 113891
113890: POP
// if IsDead ( i ) then
113891: LD_VAR 0 4
113895: PPUSH
113896: CALL_OW 301
113900: IFFALSE 113918
// defenders := defenders diff i ;
113902: LD_ADDR_VAR 0 2
113906: PUSH
113907: LD_VAR 0 2
113911: PUSH
113912: LD_VAR 0 4
113916: DIFF
113917: ST_TO_ADDR
// end ;
113918: GO 113021
113920: POP
113921: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
113922: LD_VAR 0 21
113926: NOT
113927: PUSH
113928: LD_VAR 0 2
113932: NOT
113933: OR
113934: PUSH
113935: LD_EXP 61
113939: PUSH
113940: LD_VAR 0 1
113944: ARRAY
113945: NOT
113946: OR
113947: IFFALSE 112925
// MC_Reset ( base , 18 ) ;
113949: LD_VAR 0 1
113953: PPUSH
113954: LD_INT 18
113956: PPUSH
113957: CALL 60540 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
113961: LD_ADDR_VAR 0 2
113965: PUSH
113966: LD_VAR 0 2
113970: PUSH
113971: LD_VAR 0 2
113975: PPUSH
113976: LD_INT 2
113978: PUSH
113979: LD_INT 25
113981: PUSH
113982: LD_INT 1
113984: PUSH
113985: EMPTY
113986: LIST
113987: LIST
113988: PUSH
113989: LD_INT 25
113991: PUSH
113992: LD_INT 5
113994: PUSH
113995: EMPTY
113996: LIST
113997: LIST
113998: PUSH
113999: LD_INT 25
114001: PUSH
114002: LD_INT 8
114004: PUSH
114005: EMPTY
114006: LIST
114007: LIST
114008: PUSH
114009: LD_INT 25
114011: PUSH
114012: LD_INT 9
114014: PUSH
114015: EMPTY
114016: LIST
114017: LIST
114018: PUSH
114019: EMPTY
114020: LIST
114021: LIST
114022: LIST
114023: LIST
114024: LIST
114025: PPUSH
114026: CALL_OW 72
114030: DIFF
114031: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
114032: LD_VAR 0 21
114036: NOT
114037: PUSH
114038: LD_VAR 0 2
114042: PPUSH
114043: LD_INT 21
114045: PUSH
114046: LD_INT 2
114048: PUSH
114049: EMPTY
114050: LIST
114051: LIST
114052: PPUSH
114053: CALL_OW 72
114057: AND
114058: IFFALSE 114396
// begin tmp := FilterByTag ( defenders , 19 ) ;
114060: LD_ADDR_VAR 0 11
114064: PUSH
114065: LD_VAR 0 2
114069: PPUSH
114070: LD_INT 19
114072: PPUSH
114073: CALL 49999 0 2
114077: ST_TO_ADDR
// if tmp then
114078: LD_VAR 0 11
114082: IFFALSE 114152
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
114084: LD_ADDR_VAR 0 11
114088: PUSH
114089: LD_VAR 0 11
114093: PPUSH
114094: LD_INT 25
114096: PUSH
114097: LD_INT 3
114099: PUSH
114100: EMPTY
114101: LIST
114102: LIST
114103: PPUSH
114104: CALL_OW 72
114108: ST_TO_ADDR
// if tmp then
114109: LD_VAR 0 11
114113: IFFALSE 114152
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
114115: LD_ADDR_EXP 73
114119: PUSH
114120: LD_EXP 73
114124: PPUSH
114125: LD_VAR 0 1
114129: PPUSH
114130: LD_EXP 73
114134: PUSH
114135: LD_VAR 0 1
114139: ARRAY
114140: PUSH
114141: LD_VAR 0 11
114145: UNION
114146: PPUSH
114147: CALL_OW 1
114151: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
114152: LD_VAR 0 1
114156: PPUSH
114157: LD_INT 19
114159: PPUSH
114160: CALL 60540 0 2
// repeat wait ( 0 0$1 ) ;
114164: LD_INT 35
114166: PPUSH
114167: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114171: LD_EXP 61
114175: PUSH
114176: LD_VAR 0 1
114180: ARRAY
114181: NOT
114182: PUSH
114183: LD_EXP 61
114187: PUSH
114188: LD_VAR 0 1
114192: ARRAY
114193: PUSH
114194: EMPTY
114195: EQUAL
114196: OR
114197: IFFALSE 114234
// begin for i in defenders do
114199: LD_ADDR_VAR 0 4
114203: PUSH
114204: LD_VAR 0 2
114208: PUSH
114209: FOR_IN
114210: IFFALSE 114223
// ComStop ( i ) ;
114212: LD_VAR 0 4
114216: PPUSH
114217: CALL_OW 141
114221: GO 114209
114223: POP
114224: POP
// defenders := [ ] ;
114225: LD_ADDR_VAR 0 2
114229: PUSH
114230: EMPTY
114231: ST_TO_ADDR
// exit ;
114232: GO 114460
// end ; for i in defenders do
114234: LD_ADDR_VAR 0 4
114238: PUSH
114239: LD_VAR 0 2
114243: PUSH
114244: FOR_IN
114245: IFFALSE 114334
// begin if not IsInArea ( i , mc_parking [ base ] ) then
114247: LD_VAR 0 4
114251: PPUSH
114252: LD_EXP 85
114256: PUSH
114257: LD_VAR 0 1
114261: ARRAY
114262: PPUSH
114263: CALL_OW 308
114267: NOT
114268: IFFALSE 114292
// ComMoveToArea ( i , mc_parking [ base ] ) else
114270: LD_VAR 0 4
114274: PPUSH
114275: LD_EXP 85
114279: PUSH
114280: LD_VAR 0 1
114284: ARRAY
114285: PPUSH
114286: CALL_OW 113
114290: GO 114332
// if GetControl ( i ) = control_manual then
114292: LD_VAR 0 4
114296: PPUSH
114297: CALL_OW 263
114301: PUSH
114302: LD_INT 1
114304: EQUAL
114305: IFFALSE 114332
// if IsDrivenBy ( i ) then
114307: LD_VAR 0 4
114311: PPUSH
114312: CALL_OW 311
114316: IFFALSE 114332
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
114318: LD_VAR 0 4
114322: PPUSH
114323: CALL_OW 311
114327: PPUSH
114328: CALL_OW 121
// end ;
114332: GO 114244
114334: POP
114335: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
114336: LD_VAR 0 2
114340: PPUSH
114341: LD_INT 95
114343: PUSH
114344: LD_EXP 85
114348: PUSH
114349: LD_VAR 0 1
114353: ARRAY
114354: PUSH
114355: EMPTY
114356: LIST
114357: LIST
114358: PPUSH
114359: CALL_OW 72
114363: PUSH
114364: LD_VAR 0 2
114368: EQUAL
114369: PUSH
114370: LD_EXP 84
114374: PUSH
114375: LD_VAR 0 1
114379: ARRAY
114380: OR
114381: PUSH
114382: LD_EXP 61
114386: PUSH
114387: LD_VAR 0 1
114391: ARRAY
114392: NOT
114393: OR
114394: IFFALSE 114164
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
114396: LD_ADDR_EXP 83
114400: PUSH
114401: LD_EXP 83
114405: PPUSH
114406: LD_VAR 0 1
114410: PPUSH
114411: LD_VAR 0 2
114415: PPUSH
114416: LD_INT 21
114418: PUSH
114419: LD_INT 2
114421: PUSH
114422: EMPTY
114423: LIST
114424: LIST
114425: PPUSH
114426: CALL_OW 72
114430: PPUSH
114431: CALL_OW 1
114435: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
114436: LD_VAR 0 1
114440: PPUSH
114441: LD_INT 19
114443: PPUSH
114444: CALL 60540 0 2
// MC_Reset ( base , 20 ) ;
114448: LD_VAR 0 1
114452: PPUSH
114453: LD_INT 20
114455: PPUSH
114456: CALL 60540 0 2
// end ; end_of_file
114460: LD_VAR 0 3
114464: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
114465: LD_VAR 0 1
114469: PUSH
114470: LD_INT 200
114472: DOUBLE
114473: GREATEREQUAL
114474: IFFALSE 114482
114476: LD_INT 299
114478: DOUBLE
114479: LESSEQUAL
114480: IFTRUE 114484
114482: GO 114516
114484: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
114485: LD_VAR 0 1
114489: PPUSH
114490: LD_VAR 0 2
114494: PPUSH
114495: LD_VAR 0 3
114499: PPUSH
114500: LD_VAR 0 4
114504: PPUSH
114505: LD_VAR 0 5
114509: PPUSH
114510: CALL 103251 0 5
114514: GO 114593
114516: LD_INT 300
114518: DOUBLE
114519: GREATEREQUAL
114520: IFFALSE 114528
114522: LD_INT 399
114524: DOUBLE
114525: LESSEQUAL
114526: IFTRUE 114530
114528: GO 114592
114530: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
114531: LD_VAR 0 1
114535: PPUSH
114536: LD_VAR 0 2
114540: PPUSH
114541: LD_VAR 0 3
114545: PPUSH
114546: LD_VAR 0 4
114550: PPUSH
114551: LD_VAR 0 5
114555: PPUSH
114556: LD_VAR 0 6
114560: PPUSH
114561: LD_VAR 0 7
114565: PPUSH
114566: LD_VAR 0 8
114570: PPUSH
114571: LD_VAR 0 9
114575: PPUSH
114576: LD_VAR 0 10
114580: PPUSH
114581: LD_VAR 0 11
114585: PPUSH
114586: CALL 99584 0 11
114590: GO 114593
114592: POP
// end ;
114593: PPOPN 11
114595: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
114596: LD_VAR 0 1
114600: PPUSH
114601: LD_VAR 0 2
114605: PPUSH
114606: LD_VAR 0 3
114610: PPUSH
114611: LD_VAR 0 4
114615: PPUSH
114616: LD_VAR 0 5
114620: PPUSH
114621: CALL 102987 0 5
// end ; end_of_file
114625: PPOPN 5
114627: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
114628: LD_VAR 0 1
114632: PPUSH
114633: LD_VAR 0 2
114637: PPUSH
114638: LD_VAR 0 3
114642: PPUSH
114643: LD_VAR 0 4
114647: PPUSH
114648: LD_VAR 0 5
114652: PPUSH
114653: LD_VAR 0 6
114657: PPUSH
114658: CALL 87236 0 6
// end ;
114662: PPOPN 6
114664: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
114665: LD_INT 0
114667: PPUSH
// begin if not units then
114668: LD_VAR 0 1
114672: NOT
114673: IFFALSE 114677
// exit ;
114675: GO 114677
// end ;
114677: PPOPN 7
114679: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
114680: CALL 87140 0 0
// end ;
114684: PPOPN 1
114686: END
