// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 701 0 0
// InitMacro ;
  19: CALL 60051 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 51644 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 51644 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 51644 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 51644 0 9
// if Difficulty < 4 then
 168: LD_OWVAR 67
 172: PUSH
 173: LD_INT 4
 175: LESS
 176: IFFALSE 185
// RemoveEnvironmentArea ( oilBlockArea ) ;
 178: LD_INT 24
 180: PPUSH
 181: CALL_OW 355
// PrepareArabian ;
 185: CALL 4572 0 0
// PrepareRussian ;
 189: CALL 2997 0 0
// PrepareAlliance ;
 193: CALL 919 0 0
// MC_Start ( ) ;
 197: CALL 62231 0 0
// if debug then
 201: LD_EXP 1
 205: IFFALSE 214
// FogOff ( 1 ) ;
 207: LD_INT 1
 209: PPUSH
 210: CALL_OW 344
// Action ;
 214: CALL 9322 0 0
// end ;
 218: END
// export function CustomInitMacro ; var i ; begin
 219: LD_INT 0
 221: PPUSH
 222: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 223: LD_ADDR_EXP 87
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 2
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 238: LD_ADDR_EXP 88
 242: PUSH
 243: LD_INT 3
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 12
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 18
 264: PUSH
 265: LD_INT 20
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: PUSH
 274: LD_OWVAR 67
 278: ARRAY
 279: PPUSH
 280: LD_INT 7
 282: PPUSH
 283: CALL 83948 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 287: LD_INT 1
 289: PPUSH
 290: LD_EXP 57
 294: PPUSH
 295: CALL 84393 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 6
 304: PPUSH
 305: CALL 84851 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 9
 314: PUSH
 315: EMPTY
 316: LIST
 317: PPUSH
 318: CALL 85120 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 322: LD_INT 1
 324: PPUSH
 325: LD_INT 13
 327: PUSH
 328: LD_INT 1
 330: PUSH
 331: LD_INT 2
 333: PUSH
 334: LD_INT 32
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: PUSH
 343: LD_INT 13
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 2
 351: PUSH
 352: LD_INT 88
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: PPUSH
 365: CALL 84333 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 369: LD_INT 2
 371: PPUSH
 372: LD_INT 12
 374: PUSH
 375: LD_INT 14
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL 85027 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 394: LD_INT 2
 396: PPUSH
 397: LD_EXP 54
 401: PPUSH
 402: CALL 84393 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 406: LD_INT 2
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: CALL 84851 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 416: LD_INT 2
 418: PPUSH
 419: LD_INT 10
 421: PUSH
 422: EMPTY
 423: LIST
 424: PPUSH
 425: CALL 85120 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 429: LD_INT 2
 431: PPUSH
 432: LD_INT 6
 434: PUSH
 435: LD_INT 71
 437: PUSH
 438: LD_INT 116
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: LD_INT 85
 455: PUSH
 456: LD_INT 116
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 32
 470: PUSH
 471: LD_INT 83
 473: PUSH
 474: LD_INT 111
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 87
 491: PUSH
 492: LD_INT 121
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 88
 509: PUSH
 510: LD_INT 128
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 32
 524: PUSH
 525: LD_INT 59
 527: PUSH
 528: LD_INT 89
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 69
 545: PUSH
 546: LD_INT 98
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 77
 563: PUSH
 564: LD_INT 103
 566: PUSH
 567: LD_INT 3
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 33
 578: PUSH
 579: LD_INT 83
 581: PUSH
 582: LD_INT 105
 584: PUSH
 585: LD_INT 3
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 33
 596: PUSH
 597: LD_INT 71
 599: PUSH
 600: LD_INT 125
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 84177 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 628: LD_INT 2
 630: PPUSH
 631: LD_INT 43
 633: PUSH
 634: LD_INT 47
 636: PUSH
 637: LD_INT 46
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL 85438 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 649: LD_INT 2
 651: PPUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 51
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 22
 672: PUSH
 673: LD_INT 1
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 52
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL 84333 0 2
// end ;
 696: LD_VAR 0 1
 700: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , ru_active_attack , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 701: LD_INT 0
 703: PPUSH
// debug := false ;
 704: LD_ADDR_EXP 1
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// game := true ;
 712: LD_ADDR_EXP 2
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// gossudarov_arrive := false ;
 720: LD_ADDR_EXP 4
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// ru_lab_builded := false ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_INT 0
 735: ST_TO_ADDR
// player_spotted := false ;
 736: LD_ADDR_EXP 7
 740: PUSH
 741: LD_INT 0
 743: ST_TO_ADDR
// first_attack := false ;
 744: LD_ADDR_EXP 8
 748: PUSH
 749: LD_INT 0
 751: ST_TO_ADDR
// ru_attackers := [ ] ;
 752: LD_ADDR_EXP 55
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// ar_base_spotted := false ;
 759: LD_ADDR_EXP 9
 763: PUSH
 764: LD_INT 0
 766: ST_TO_ADDR
// ar_active_attack := false ;
 767: LD_ADDR_EXP 10
 771: PUSH
 772: LD_INT 0
 774: ST_TO_ADDR
// ru_active_attack := true ;
 775: LD_ADDR_EXP 6
 779: PUSH
 780: LD_INT 1
 782: ST_TO_ADDR
// ar_attackers := [ ] ;
 783: LD_ADDR_EXP 12
 787: PUSH
 788: EMPTY
 789: ST_TO_ADDR
// first_powell_attack := false ;
 790: LD_ADDR_EXP 13
 794: PUSH
 795: LD_INT 0
 797: ST_TO_ADDR
// masha_killed := false ;
 798: LD_ADDR_EXP 11
 802: PUSH
 803: LD_INT 0
 805: ST_TO_ADDR
// abdul_escaped := true ;
 806: LD_ADDR_EXP 14
 810: PUSH
 811: LD_INT 1
 813: ST_TO_ADDR
// loss_counter := 0 ;
 814: LD_ADDR_EXP 15
 818: PUSH
 819: LD_INT 0
 821: ST_TO_ADDR
// hack_counter := 0 ;
 822: LD_ADDR_EXP 16
 826: PUSH
 827: LD_INT 0
 829: ST_TO_ADDR
// end ;
 830: LD_VAR 0 1
 834: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 835: LD_EXP 51
 839: PPUSH
 840: CALL_OW 255
 844: PUSH
 845: LD_INT 7
 847: EQUAL
 848: PUSH
 849: LD_EXP 50
 853: PPUSH
 854: CALL_OW 255
 858: PUSH
 859: LD_INT 7
 861: EQUAL
 862: AND
 863: PUSH
 864: LD_EXP 51
 868: PPUSH
 869: CALL_OW 302
 873: AND
 874: PUSH
 875: LD_EXP 50
 879: PPUSH
 880: CALL_OW 302
 884: AND
 885: IFFALSE 897
 887: GO 889
 889: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 890: LD_STRING ACH_COMRADE
 892: PPUSH
 893: CALL_OW 543
 897: END
// every 0 0$1 trigger hack_counter >= 10 do
 898: LD_EXP 16
 902: PUSH
 903: LD_INT 10
 905: GREATEREQUAL
 906: IFFALSE 918
 908: GO 910
 910: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 911: LD_STRING ACH_HACK
 913: PPUSH
 914: CALL_OW 543
 918: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 919: LD_INT 0
 921: PPUSH
 922: PPUSH
 923: PPUSH
 924: PPUSH
// uc_side := 7 ;
 925: LD_ADDR_OWVAR 20
 929: PUSH
 930: LD_INT 7
 932: ST_TO_ADDR
// uc_nation := 1 ;
 933: LD_ADDR_OWVAR 21
 937: PUSH
 938: LD_INT 1
 940: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 941: LD_ADDR_EXP 17
 945: PUSH
 946: LD_STRING JMM
 948: PPUSH
 949: LD_EXP 1
 953: NOT
 954: PPUSH
 955: LD_STRING 12a_
 957: PPUSH
 958: CALL 17276 0 3
 962: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 963: LD_EXP 17
 967: PPUSH
 968: LD_INT 71
 970: PPUSH
 971: LD_INT 23
 973: PPUSH
 974: LD_INT 0
 976: PPUSH
 977: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 981: LD_EXP 17
 985: PPUSH
 986: LD_INT 2
 988: PPUSH
 989: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 993: LD_ADDR_EXP 18
 997: PUSH
 998: LD_STRING Roth
1000: PPUSH
1001: LD_EXP 1
1005: NOT
1006: PPUSH
1007: LD_STRING 12a_
1009: PPUSH
1010: CALL 17276 0 3
1014: ST_TO_ADDR
// if Roth then
1015: LD_EXP 18
1019: IFFALSE 1039
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1021: LD_EXP 18
1025: PPUSH
1026: LD_INT 71
1028: PPUSH
1029: LD_INT 21
1031: PPUSH
1032: LD_INT 0
1034: PPUSH
1035: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1039: LD_ADDR_EXP 34
1043: PUSH
1044: LD_STRING Mike
1046: PPUSH
1047: LD_EXP 1
1051: NOT
1052: PPUSH
1053: LD_STRING 12a_
1055: PPUSH
1056: CALL 17276 0 3
1060: ST_TO_ADDR
// if Mike then
1061: LD_EXP 34
1065: IFFALSE 1082
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1067: LD_EXP 34
1071: PPUSH
1072: LD_INT 13
1074: PPUSH
1075: LD_INT 0
1077: PPUSH
1078: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1082: LD_ADDR_EXP 19
1086: PUSH
1087: LD_STRING Lisa
1089: PPUSH
1090: LD_EXP 1
1094: NOT
1095: PPUSH
1096: LD_STRING 12a_
1098: PPUSH
1099: CALL 17276 0 3
1103: ST_TO_ADDR
// if Lisa then
1104: LD_EXP 19
1108: IFFALSE 1125
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1110: LD_EXP 19
1114: PPUSH
1115: LD_INT 13
1117: PPUSH
1118: LD_INT 0
1120: PPUSH
1121: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1125: LD_ADDR_EXP 20
1129: PUSH
1130: LD_STRING Donaldson
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_STRING 12a_
1141: PPUSH
1142: CALL 17276 0 3
1146: ST_TO_ADDR
// if Donaldson then
1147: LD_EXP 20
1151: IFFALSE 1168
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1153: LD_EXP 20
1157: PPUSH
1158: LD_INT 13
1160: PPUSH
1161: LD_INT 0
1163: PPUSH
1164: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1168: LD_ADDR_EXP 21
1172: PUSH
1173: LD_STRING Bobby
1175: PPUSH
1176: LD_EXP 1
1180: NOT
1181: PPUSH
1182: LD_STRING 12a_
1184: PPUSH
1185: CALL 17276 0 3
1189: ST_TO_ADDR
// if Bobby then
1190: LD_EXP 21
1194: IFFALSE 1211
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1196: LD_EXP 21
1200: PPUSH
1201: LD_INT 13
1203: PPUSH
1204: LD_INT 0
1206: PPUSH
1207: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1211: LD_ADDR_EXP 22
1215: PUSH
1216: LD_STRING Cyrus
1218: PPUSH
1219: LD_EXP 1
1223: NOT
1224: PPUSH
1225: LD_STRING 12a_
1227: PPUSH
1228: CALL 17276 0 3
1232: ST_TO_ADDR
// if Cyrus then
1233: LD_EXP 22
1237: IFFALSE 1254
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1239: LD_EXP 22
1243: PPUSH
1244: LD_INT 13
1246: PPUSH
1247: LD_INT 0
1249: PPUSH
1250: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1254: LD_ADDR_EXP 23
1258: PUSH
1259: LD_STRING Denis
1261: PPUSH
1262: LD_EXP 1
1266: NOT
1267: PPUSH
1268: LD_STRING 12a_
1270: PPUSH
1271: CALL 17276 0 3
1275: ST_TO_ADDR
// if Denis then
1276: LD_EXP 23
1280: IFFALSE 1297
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1282: LD_EXP 23
1286: PPUSH
1287: LD_INT 13
1289: PPUSH
1290: LD_INT 0
1292: PPUSH
1293: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1297: LD_ADDR_EXP 24
1301: PUSH
1302: LD_STRING Brown
1304: PPUSH
1305: LD_EXP 1
1309: NOT
1310: PPUSH
1311: LD_STRING 12a_
1313: PPUSH
1314: CALL 17276 0 3
1318: ST_TO_ADDR
// if Brown then
1319: LD_EXP 24
1323: IFFALSE 1340
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1325: LD_EXP 24
1329: PPUSH
1330: LD_INT 13
1332: PPUSH
1333: LD_INT 0
1335: PPUSH
1336: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1340: LD_ADDR_EXP 25
1344: PUSH
1345: LD_STRING Gladstone
1347: PPUSH
1348: LD_EXP 1
1352: NOT
1353: PPUSH
1354: LD_STRING 12a_
1356: PPUSH
1357: CALL 17276 0 3
1361: ST_TO_ADDR
// if Gladstone then
1362: LD_EXP 25
1366: IFFALSE 1383
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1368: LD_EXP 25
1372: PPUSH
1373: LD_INT 13
1375: PPUSH
1376: LD_INT 0
1378: PPUSH
1379: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1383: LD_ADDR_EXP 26
1387: PUSH
1388: LD_STRING Houten
1390: PPUSH
1391: LD_EXP 1
1395: NOT
1396: PPUSH
1397: LD_STRING 12a_
1399: PPUSH
1400: CALL 17276 0 3
1404: ST_TO_ADDR
// if Houten then
1405: LD_EXP 26
1409: IFFALSE 1426
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1411: LD_EXP 26
1415: PPUSH
1416: LD_INT 13
1418: PPUSH
1419: LD_INT 0
1421: PPUSH
1422: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1426: LD_ADDR_EXP 27
1430: PUSH
1431: LD_STRING Cornell
1433: PPUSH
1434: LD_EXP 1
1438: NOT
1439: PPUSH
1440: LD_STRING 12a_
1442: PPUSH
1443: CALL 17276 0 3
1447: ST_TO_ADDR
// if Cornel then
1448: LD_EXP 27
1452: IFFALSE 1469
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1454: LD_EXP 27
1458: PPUSH
1459: LD_INT 13
1461: PPUSH
1462: LD_INT 0
1464: PPUSH
1465: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1469: LD_ADDR_EXP 28
1473: PUSH
1474: LD_STRING Gary
1476: PPUSH
1477: LD_EXP 1
1481: NOT
1482: PPUSH
1483: LD_STRING 12a_
1485: PPUSH
1486: CALL 17276 0 3
1490: ST_TO_ADDR
// if Gary then
1491: LD_EXP 28
1495: IFFALSE 1512
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1497: LD_EXP 28
1501: PPUSH
1502: LD_INT 13
1504: PPUSH
1505: LD_INT 0
1507: PPUSH
1508: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1512: LD_ADDR_EXP 29
1516: PUSH
1517: LD_STRING Frank
1519: PPUSH
1520: LD_EXP 1
1524: NOT
1525: PPUSH
1526: LD_STRING 12a_
1528: PPUSH
1529: CALL 17276 0 3
1533: ST_TO_ADDR
// if Frank then
1534: LD_EXP 29
1538: IFFALSE 1555
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1540: LD_EXP 29
1544: PPUSH
1545: LD_INT 13
1547: PPUSH
1548: LD_INT 0
1550: PPUSH
1551: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1555: LD_ADDR_EXP 30
1559: PUSH
1560: LD_STRING Kikuchi
1562: PPUSH
1563: LD_EXP 1
1567: NOT
1568: PPUSH
1569: LD_STRING 12a_
1571: PPUSH
1572: CALL 17276 0 3
1576: ST_TO_ADDR
// if Kikuchi then
1577: LD_EXP 30
1581: IFFALSE 1598
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1583: LD_EXP 30
1587: PPUSH
1588: LD_INT 13
1590: PPUSH
1591: LD_INT 0
1593: PPUSH
1594: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1598: LD_ADDR_EXP 31
1602: PUSH
1603: LD_STRING Simms
1605: PPUSH
1606: LD_EXP 1
1610: NOT
1611: PPUSH
1612: LD_STRING 12a_
1614: PPUSH
1615: CALL 17276 0 3
1619: ST_TO_ADDR
// if Simms then
1620: LD_EXP 31
1624: IFFALSE 1641
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1626: LD_EXP 31
1630: PPUSH
1631: LD_INT 13
1633: PPUSH
1634: LD_INT 0
1636: PPUSH
1637: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1641: LD_ADDR_EXP 32
1645: PUSH
1646: LD_STRING Joan
1648: PPUSH
1649: LD_EXP 1
1653: NOT
1654: PPUSH
1655: LD_STRING 12a_
1657: PPUSH
1658: CALL 17276 0 3
1662: ST_TO_ADDR
// if Joan then
1663: LD_EXP 32
1667: IFFALSE 1684
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1669: LD_EXP 32
1673: PPUSH
1674: LD_INT 13
1676: PPUSH
1677: LD_INT 0
1679: PPUSH
1680: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1684: LD_ADDR_EXP 33
1688: PUSH
1689: LD_STRING DeltaDoctor
1691: PPUSH
1692: LD_EXP 1
1696: NOT
1697: PPUSH
1698: LD_STRING 12a_
1700: PPUSH
1701: CALL 17276 0 3
1705: ST_TO_ADDR
// if DeltaDoctor then
1706: LD_EXP 33
1710: IFFALSE 1727
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1712: LD_EXP 33
1716: PPUSH
1717: LD_INT 13
1719: PPUSH
1720: LD_INT 0
1722: PPUSH
1723: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1727: LD_ADDR_VAR 0 4
1731: PUSH
1732: LD_STRING 12a_others
1734: PPUSH
1735: CALL_OW 31
1739: ST_TO_ADDR
// if tmp then
1740: LD_VAR 0 4
1744: IFFALSE 1778
// for i in tmp do
1746: LD_ADDR_VAR 0 3
1750: PUSH
1751: LD_VAR 0 4
1755: PUSH
1756: FOR_IN
1757: IFFALSE 1776
// PlaceUnitArea ( i , alliance_start , false ) ;
1759: LD_VAR 0 3
1763: PPUSH
1764: LD_INT 13
1766: PPUSH
1767: LD_INT 0
1769: PPUSH
1770: CALL_OW 49
1774: GO 1756
1776: POP
1777: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1778: LD_INT 3
1780: PPUSH
1781: LD_INT 3
1783: PPUSH
1784: LD_INT 3
1786: PPUSH
1787: LD_INT 12
1789: PPUSH
1790: LD_INT 100
1792: PPUSH
1793: CALL 22116 0 5
// veh := CreateVehicle ;
1797: LD_ADDR_VAR 0 2
1801: PUSH
1802: CALL_OW 45
1806: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1807: LD_VAR 0 2
1811: PPUSH
1812: LD_INT 2
1814: PPUSH
1815: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1819: LD_VAR 0 2
1823: PPUSH
1824: LD_INT 60
1826: PPUSH
1827: LD_INT 6
1829: PPUSH
1830: LD_INT 0
1832: PPUSH
1833: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1837: LD_VAR 0 2
1841: PPUSH
1842: LD_INT 4
1844: PPUSH
1845: LD_INT 30
1847: PPUSH
1848: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1852: LD_STRING 11_artifact_captured
1854: PPUSH
1855: LD_INT 0
1857: PPUSH
1858: CALL_OW 30
1862: IFFALSE 1938
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1864: LD_INT 3
1866: PPUSH
1867: LD_INT 3
1869: PPUSH
1870: LD_INT 3
1872: PPUSH
1873: LD_INT 12
1875: PPUSH
1876: LD_INT 100
1878: PPUSH
1879: CALL 22116 0 5
// veh := CreateVehicle ;
1883: LD_ADDR_VAR 0 2
1887: PUSH
1888: CALL_OW 45
1892: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1893: LD_VAR 0 2
1897: PPUSH
1898: LD_INT 3
1900: PPUSH
1901: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1905: LD_VAR 0 2
1909: PPUSH
1910: LD_INT 75
1912: PPUSH
1913: LD_INT 6
1915: PPUSH
1916: LD_INT 0
1918: PPUSH
1919: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1923: LD_VAR 0 2
1927: PPUSH
1928: LD_INT 4
1930: PPUSH
1931: LD_INT 50
1933: PPUSH
1934: CALL_OW 290
// end ; end ;
1938: LD_VAR 0 1
1942: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1943: LD_INT 0
1945: PPUSH
1946: PPUSH
1947: PPUSH
1948: PPUSH
// uc_side := 6 ;
1949: LD_ADDR_OWVAR 20
1953: PUSH
1954: LD_INT 6
1956: ST_TO_ADDR
// uc_nation := 3 ;
1957: LD_ADDR_OWVAR 21
1961: PUSH
1962: LD_INT 3
1964: ST_TO_ADDR
// InitHc ;
1965: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1969: LD_ADDR_EXP 35
1973: PUSH
1974: LD_STRING Gossudarov
1976: PPUSH
1977: CALL_OW 25
1981: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1982: LD_ADDR_EXP 36
1986: PUSH
1987: LD_STRING Kirilenkova
1989: PPUSH
1990: CALL_OW 25
1994: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1995: LD_ADDR_EXP 37
1999: PUSH
2000: LD_STRING Titov
2002: PPUSH
2003: CALL_OW 25
2007: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
2008: LD_ADDR_EXP 42
2012: PUSH
2013: LD_STRING Oblukov
2015: PPUSH
2016: CALL_OW 25
2020: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
2021: LD_ADDR_EXP 39
2025: PUSH
2026: LD_STRING Dolgov
2028: PPUSH
2029: CALL_OW 25
2033: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2034: LD_ADDR_EXP 40
2038: PUSH
2039: LD_STRING Petrosyan
2041: PPUSH
2042: CALL_OW 25
2046: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2047: LD_ADDR_EXP 41
2051: PUSH
2052: LD_STRING Scholtze
2054: PPUSH
2055: CALL_OW 25
2059: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2060: LD_ADDR_EXP 43
2064: PUSH
2065: LD_STRING Kapitsova
2067: PPUSH
2068: CALL_OW 25
2072: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2073: LD_ADDR_VAR 0 2
2077: PUSH
2078: LD_EXP 35
2082: PUSH
2083: LD_EXP 36
2087: PUSH
2088: LD_EXP 37
2092: PUSH
2093: LD_EXP 42
2097: PUSH
2098: LD_EXP 39
2102: PUSH
2103: LD_EXP 40
2107: PUSH
2108: LD_EXP 41
2112: PUSH
2113: LD_EXP 43
2117: PUSH
2118: EMPTY
2119: LIST
2120: LIST
2121: LIST
2122: LIST
2123: LIST
2124: LIST
2125: LIST
2126: LIST
2127: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2128: LD_INT 1
2130: PPUSH
2131: LD_INT 4
2133: PPUSH
2134: LD_INT 8
2136: PPUSH
2137: CALL_OW 380
// un := CreateHuman ;
2141: LD_ADDR_VAR 0 4
2145: PUSH
2146: CALL_OW 44
2150: ST_TO_ADDR
// tmp := tmp ^ un ;
2151: LD_ADDR_VAR 0 2
2155: PUSH
2156: LD_VAR 0 2
2160: PUSH
2161: LD_VAR 0 4
2165: ADD
2166: ST_TO_ADDR
// for i in tmp do
2167: LD_ADDR_VAR 0 3
2171: PUSH
2172: LD_VAR 0 2
2176: PUSH
2177: FOR_IN
2178: IFFALSE 2197
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2180: LD_VAR 0 3
2184: PPUSH
2185: LD_INT 14
2187: PPUSH
2188: LD_INT 0
2190: PPUSH
2191: CALL_OW 49
2195: GO 2177
2197: POP
2198: POP
// if freedom then
2199: LD_EXP 3
2203: IFFALSE 2236
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2205: LD_VAR 0 2
2209: PPUSH
2210: LD_EXP 3
2214: PPUSH
2215: CALL_OW 250
2219: PPUSH
2220: LD_EXP 3
2224: PPUSH
2225: CALL_OW 251
2229: PPUSH
2230: CALL_OW 111
2234: GO 2251
// ComMoveXY ( tmp , 70 , 48 ) ;
2236: LD_VAR 0 2
2240: PPUSH
2241: LD_INT 70
2243: PPUSH
2244: LD_INT 48
2246: PPUSH
2247: CALL_OW 111
// end ;
2251: LD_VAR 0 1
2255: RET
// export function PrepareBelkov ; begin
2256: LD_INT 0
2258: PPUSH
// uc_side := 4 ;
2259: LD_ADDR_OWVAR 20
2263: PUSH
2264: LD_INT 4
2266: ST_TO_ADDR
// uc_nation := 3 ;
2267: LD_ADDR_OWVAR 21
2271: PUSH
2272: LD_INT 3
2274: ST_TO_ADDR
// InitHc ;
2275: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2279: LD_ADDR_EXP 50
2283: PUSH
2284: LD_STRING Belkov
2286: PPUSH
2287: CALL_OW 25
2291: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2292: LD_EXP 50
2296: PPUSH
2297: LD_INT 14
2299: PPUSH
2300: LD_INT 0
2302: PPUSH
2303: CALL_OW 49
// end ;
2307: LD_VAR 0 1
2311: RET
// export function PrepareGnyevko ; begin
2312: LD_INT 0
2314: PPUSH
// uc_side := 4 ;
2315: LD_ADDR_OWVAR 20
2319: PUSH
2320: LD_INT 4
2322: ST_TO_ADDR
// uc_nation := 3 ;
2323: LD_ADDR_OWVAR 21
2327: PUSH
2328: LD_INT 3
2330: ST_TO_ADDR
// InitHc ;
2331: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2335: LD_ADDR_EXP 51
2339: PUSH
2340: LD_STRING Gnyevko
2342: PPUSH
2343: CALL_OW 25
2347: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2348: LD_EXP 51
2352: PPUSH
2353: LD_INT 14
2355: PPUSH
2356: LD_INT 0
2358: PPUSH
2359: CALL_OW 49
// end ;
2363: LD_VAR 0 1
2367: RET
// export function PrepareBurlak ; var i , tmp ; begin
2368: LD_INT 0
2370: PPUSH
2371: PPUSH
2372: PPUSH
// uc_side := 4 ;
2373: LD_ADDR_OWVAR 20
2377: PUSH
2378: LD_INT 4
2380: ST_TO_ADDR
// uc_nation := 3 ;
2381: LD_ADDR_OWVAR 21
2385: PUSH
2386: LD_INT 3
2388: ST_TO_ADDR
// InitHc ;
2389: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2393: LD_ADDR_EXP 49
2397: PUSH
2398: LD_STRING Burlak
2400: PPUSH
2401: CALL_OW 25
2405: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2406: LD_INT 24
2408: PUSH
2409: LD_INT 23
2411: PUSH
2412: LD_INT 22
2414: PUSH
2415: LD_INT 22
2417: PUSH
2418: EMPTY
2419: LIST
2420: LIST
2421: LIST
2422: LIST
2423: PUSH
2424: LD_OWVAR 67
2428: ARRAY
2429: PPUSH
2430: LD_INT 1
2432: PPUSH
2433: LD_INT 1
2435: PPUSH
2436: LD_INT 45
2438: PUSH
2439: LD_INT 44
2441: PUSH
2442: LD_INT 43
2444: PUSH
2445: LD_INT 42
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: LIST
2452: LIST
2453: PUSH
2454: LD_OWVAR 67
2458: ARRAY
2459: PPUSH
2460: LD_INT 0
2462: PPUSH
2463: CALL 22116 0 5
// Masha := CreateVehicle ;
2467: LD_ADDR_EXP 52
2471: PUSH
2472: CALL_OW 45
2476: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2477: LD_EXP 52
2481: PUSH
2482: LD_EXP 49
2486: PUSH
2487: EMPTY
2488: LIST
2489: LIST
2490: PPUSH
2491: LD_INT 499
2493: PPUSH
2494: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2498: LD_EXP 52
2502: PPUSH
2503: LD_INT 3
2505: PPUSH
2506: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2510: LD_EXP 52
2514: PPUSH
2515: LD_INT 1
2517: PPUSH
2518: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2522: LD_INT 1
2524: PPUSH
2525: LD_INT 18
2527: PPUSH
2528: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2532: LD_INT 35
2534: PPUSH
2535: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2539: LD_ADDR_VAR 0 3
2543: PUSH
2544: LD_INT 18
2546: PPUSH
2547: EMPTY
2548: PPUSH
2549: CALL_OW 70
2553: ST_TO_ADDR
// if tmp then
2554: LD_VAR 0 3
2558: IFFALSE 2592
// for i in tmp do
2560: LD_ADDR_VAR 0 2
2564: PUSH
2565: LD_VAR 0 3
2569: PUSH
2570: FOR_IN
2571: IFFALSE 2590
// ComMoveXY ( i , 114 , 9 ) ;
2573: LD_VAR 0 2
2577: PPUSH
2578: LD_INT 114
2580: PPUSH
2581: LD_INT 9
2583: PPUSH
2584: CALL_OW 111
2588: GO 2570
2590: POP
2591: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2592: LD_INT 18
2594: PPUSH
2595: EMPTY
2596: PPUSH
2597: CALL_OW 70
2601: NOT
2602: PUSH
2603: LD_INT 123
2605: PPUSH
2606: LD_INT 3
2608: PPUSH
2609: CALL_OW 428
2613: PUSH
2614: LD_INT 0
2616: EQUAL
2617: AND
2618: IFFALSE 2532
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2620: LD_EXP 52
2624: PPUSH
2625: LD_INT 123
2627: PPUSH
2628: LD_INT 3
2630: PPUSH
2631: LD_INT 0
2633: PPUSH
2634: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2638: LD_EXP 49
2642: PPUSH
2643: LD_INT 125
2645: PPUSH
2646: LD_INT 1
2648: PPUSH
2649: LD_INT 0
2651: PPUSH
2652: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2656: LD_EXP 49
2660: PPUSH
2661: LD_EXP 52
2665: PPUSH
2666: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2670: LD_INT 10
2672: PPUSH
2673: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2677: LD_EXP 52
2681: PPUSH
2682: LD_INT 110
2684: PPUSH
2685: LD_INT 10
2687: PPUSH
2688: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2692: LD_ADDR_EXP 45
2696: PUSH
2697: LD_STRING Petrovova
2699: PPUSH
2700: CALL_OW 25
2704: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2705: LD_ADDR_EXP 47
2709: PUSH
2710: LD_STRING Kuzmov
2712: PPUSH
2713: CALL_OW 25
2717: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2718: LD_ADDR_EXP 46
2722: PUSH
2723: LD_STRING Kovalyuk
2725: PPUSH
2726: CALL_OW 25
2730: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2731: LD_ADDR_EXP 44
2735: PUSH
2736: LD_STRING Lipshchin
2738: PPUSH
2739: CALL_OW 25
2743: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2744: LD_ADDR_EXP 48
2748: PUSH
2749: LD_STRING Karamazov
2751: PPUSH
2752: CALL_OW 25
2756: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2757: LD_ADDR_VAR 0 3
2761: PUSH
2762: LD_EXP 45
2766: PUSH
2767: LD_EXP 47
2771: PUSH
2772: LD_EXP 46
2776: PUSH
2777: LD_EXP 44
2781: PUSH
2782: LD_EXP 48
2786: PUSH
2787: EMPTY
2788: LIST
2789: LIST
2790: LIST
2791: LIST
2792: LIST
2793: ST_TO_ADDR
// for i in tmp do
2794: LD_ADDR_VAR 0 2
2798: PUSH
2799: LD_VAR 0 3
2803: PUSH
2804: FOR_IN
2805: IFFALSE 2844
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2807: LD_VAR 0 2
2811: PPUSH
2812: LD_INT 399
2814: PPUSH
2815: LD_INT 799
2817: PPUSH
2818: CALL_OW 12
2822: PPUSH
2823: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2827: LD_VAR 0 2
2831: PPUSH
2832: LD_INT 19
2834: PPUSH
2835: LD_INT 0
2837: PPUSH
2838: CALL_OW 49
// end ;
2842: GO 2804
2844: POP
2845: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2846: LD_VAR 0 3
2850: PPUSH
2851: LD_INT 112
2853: PPUSH
2854: LD_INT 5
2856: PPUSH
2857: CALL_OW 111
// AddComHold ( tmp ) ;
2861: LD_VAR 0 3
2865: PPUSH
2866: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2870: LD_ADDR_VAR 0 2
2874: PUSH
2875: LD_VAR 0 3
2879: PPUSH
2880: LD_INT 25
2882: PUSH
2883: LD_INT 1
2885: PUSH
2886: EMPTY
2887: LIST
2888: LIST
2889: PPUSH
2890: CALL_OW 72
2894: PUSH
2895: FOR_IN
2896: IFFALSE 2936
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2898: LD_VAR 0 2
2902: PPUSH
2903: LD_INT 20
2905: PPUSH
2906: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2910: LD_VAR 0 2
2914: PPUSH
2915: LD_INT 147
2917: PPUSH
2918: LD_INT 45
2920: PPUSH
2921: CALL_OW 178
// AddComCrawl ( i ) ;
2925: LD_VAR 0 2
2929: PPUSH
2930: CALL_OW 197
// end ;
2934: GO 2895
2936: POP
2937: POP
// repeat wait ( 0 0$1 ) ;
2938: LD_INT 35
2940: PPUSH
2941: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2945: LD_EXP 52
2949: PPUSH
2950: LD_INT 110
2952: PPUSH
2953: LD_INT 10
2955: PPUSH
2956: CALL_OW 307
2960: PUSH
2961: LD_EXP 52
2965: PPUSH
2966: CALL_OW 305
2970: NOT
2971: OR
2972: IFFALSE 2938
// ComStop ( Burlak ) ;
2974: LD_EXP 49
2978: PPUSH
2979: CALL_OW 141
// AddComHold ( Burlak ) ;
2983: LD_EXP 49
2987: PPUSH
2988: CALL_OW 200
// end ; end_of_file
2992: LD_VAR 0 1
2996: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2997: LD_INT 0
2999: PPUSH
3000: PPUSH
3001: PPUSH
3002: PPUSH
3003: PPUSH
// uc_side := 3 ;
3004: LD_ADDR_OWVAR 20
3008: PUSH
3009: LD_INT 3
3011: ST_TO_ADDR
// uc_nation := 3 ;
3012: LD_ADDR_OWVAR 21
3016: PUSH
3017: LD_INT 3
3019: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
3020: LD_ADDR_EXP 53
3024: PUSH
3025: LD_INT 47
3027: PPUSH
3028: LD_INT 4
3030: PPUSH
3031: LD_STRING 
3033: PPUSH
3034: LD_INT 7
3036: PUSH
3037: LD_INT 8
3039: PUSH
3040: LD_INT 9
3042: PUSH
3043: LD_INT 10
3045: PUSH
3046: EMPTY
3047: LIST
3048: LIST
3049: LIST
3050: LIST
3051: PUSH
3052: LD_OWVAR 67
3056: ARRAY
3057: PPUSH
3058: LD_INT 10000
3060: PUSH
3061: LD_INT 3000
3063: PUSH
3064: LD_INT 300
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: LIST
3071: PPUSH
3072: LD_INT 9
3074: PUSH
3075: LD_INT 5
3077: PUSH
3078: LD_INT 6
3080: PUSH
3081: LD_INT 6
3083: PUSH
3084: EMPTY
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: PPUSH
3090: CALL 25937 0 6
3094: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3095: LD_ADDR_EXP 63
3099: PUSH
3100: LD_EXP 63
3104: PPUSH
3105: LD_INT 2
3107: PPUSH
3108: LD_EXP 53
3112: PPUSH
3113: CALL_OW 1
3117: ST_TO_ADDR
// tmp := [ ] ;
3118: LD_ADDR_VAR 0 4
3122: PUSH
3123: EMPTY
3124: ST_TO_ADDR
// for i = 1 to 4 do
3125: LD_ADDR_VAR 0 2
3129: PUSH
3130: DOUBLE
3131: LD_INT 1
3133: DEC
3134: ST_TO_ADDR
3135: LD_INT 4
3137: PUSH
3138: FOR_TO
3139: IFFALSE 3232
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3141: LD_INT 22
3143: PPUSH
3144: LD_INT 3
3146: PPUSH
3147: LD_INT 3
3149: PPUSH
3150: LD_INT 43
3152: PUSH
3153: LD_INT 45
3155: PUSH
3156: LD_INT 45
3158: PUSH
3159: LD_INT 44
3161: PUSH
3162: EMPTY
3163: LIST
3164: LIST
3165: LIST
3166: LIST
3167: PUSH
3168: LD_VAR 0 2
3172: PUSH
3173: LD_INT 4
3175: MOD
3176: PUSH
3177: LD_INT 1
3179: PLUS
3180: ARRAY
3181: PPUSH
3182: LD_INT 100
3184: PPUSH
3185: CALL 22116 0 5
// veh := CreateVehicle ;
3189: LD_ADDR_VAR 0 3
3193: PUSH
3194: CALL_OW 45
3198: ST_TO_ADDR
// tmp := tmp ^ veh ;
3199: LD_ADDR_VAR 0 4
3203: PUSH
3204: LD_VAR 0 4
3208: PUSH
3209: LD_VAR 0 3
3213: ADD
3214: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3215: LD_VAR 0 3
3219: PPUSH
3220: LD_INT 2
3222: PPUSH
3223: LD_INT 0
3225: PPUSH
3226: CALL_OW 49
// end ;
3230: GO 3138
3232: POP
3233: POP
// russian_guard := tmp ;
3234: LD_ADDR_EXP 54
3238: PUSH
3239: LD_VAR 0 4
3243: ST_TO_ADDR
// if Difficulty >= 3 then
3244: LD_OWVAR 67
3248: PUSH
3249: LD_INT 3
3251: GREATEREQUAL
3252: IFFALSE 3316
// begin bc_type := b_breastwork ;
3254: LD_ADDR_OWVAR 42
3258: PUSH
3259: LD_INT 31
3261: ST_TO_ADDR
// bc_level := 10 ;
3262: LD_ADDR_OWVAR 43
3266: PUSH
3267: LD_INT 10
3269: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3270: LD_ADDR_VAR 0 5
3274: PUSH
3275: LD_INT 96
3277: PPUSH
3278: LD_INT 105
3280: PPUSH
3281: LD_INT 3
3283: PPUSH
3284: CALL_OW 47
3288: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3289: LD_INT 0
3291: PPUSH
3292: LD_INT 9
3294: PPUSH
3295: LD_INT 10
3297: PPUSH
3298: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3302: CALL_OW 44
3306: PPUSH
3307: LD_VAR 0 5
3311: PPUSH
3312: CALL_OW 52
// end ; end ;
3316: LD_VAR 0 1
3320: RET
// every 5 5$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , p , base , tmp , _target , attackers , amount ;
3321: LD_INT 47
3323: PPUSH
3324: CALL_OW 302
3328: PUSH
3329: LD_EXP 7
3333: AND
3334: IFFALSE 4088
3336: GO 3338
3338: DISABLE
3339: LD_INT 0
3341: PPUSH
3342: PPUSH
3343: PPUSH
3344: PPUSH
3345: PPUSH
3346: PPUSH
3347: PPUSH
// begin enable ;
3348: ENABLE
// base := 2 ;
3349: LD_ADDR_VAR 0 3
3353: PUSH
3354: LD_INT 2
3356: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3357: LD_ADDR_VAR 0 4
3361: PUSH
3362: LD_INT 22
3364: PUSH
3365: LD_INT 1
3367: PUSH
3368: LD_INT 3
3370: PUSH
3371: LD_INT 45
3373: PUSH
3374: EMPTY
3375: LIST
3376: LIST
3377: LIST
3378: LIST
3379: PUSH
3380: LD_INT 21
3382: PUSH
3383: LD_INT 1
3385: PUSH
3386: LD_INT 3
3388: PUSH
3389: LD_INT 45
3391: PUSH
3392: EMPTY
3393: LIST
3394: LIST
3395: LIST
3396: LIST
3397: PUSH
3398: LD_INT 22
3400: PUSH
3401: LD_INT 1
3403: PUSH
3404: LD_INT 3
3406: PUSH
3407: LD_INT 45
3409: PUSH
3410: EMPTY
3411: LIST
3412: LIST
3413: LIST
3414: LIST
3415: PUSH
3416: LD_INT 23
3418: PUSH
3419: LD_INT 1
3421: PUSH
3422: LD_INT 3
3424: PUSH
3425: LD_INT 46
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: LIST
3432: LIST
3433: PUSH
3434: EMPTY
3435: LIST
3436: LIST
3437: LIST
3438: LIST
3439: ST_TO_ADDR
// amount := Difficulty ;
3440: LD_ADDR_VAR 0 7
3444: PUSH
3445: LD_OWVAR 67
3449: ST_TO_ADDR
// if tick > 30 30$00 then
3450: LD_OWVAR 1
3454: PUSH
3455: LD_INT 63000
3457: GREATER
3458: IFFALSE 3495
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3460: LD_ADDR_VAR 0 7
3464: PUSH
3465: LD_VAR 0 7
3469: PUSH
3470: LD_INT 2
3472: PUSH
3473: LD_INT 3
3475: PUSH
3476: LD_INT 4
3478: PUSH
3479: LD_INT 4
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: LIST
3486: LIST
3487: PUSH
3488: LD_OWVAR 67
3492: ARRAY
3493: PLUS
3494: ST_TO_ADDR
// for i = 1 to amount do
3495: LD_ADDR_VAR 0 1
3499: PUSH
3500: DOUBLE
3501: LD_INT 1
3503: DEC
3504: ST_TO_ADDR
3505: LD_VAR 0 7
3509: PUSH
3510: FOR_TO
3511: IFFALSE 3599
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3513: LD_ADDR_VAR 0 4
3517: PUSH
3518: LD_VAR 0 4
3522: PPUSH
3523: LD_VAR 0 4
3527: PUSH
3528: LD_INT 1
3530: PLUS
3531: PPUSH
3532: LD_INT 23
3534: PUSH
3535: LD_INT 24
3537: PUSH
3538: EMPTY
3539: LIST
3540: LIST
3541: PUSH
3542: LD_INT 1
3544: PPUSH
3545: LD_INT 2
3547: PPUSH
3548: CALL_OW 12
3552: ARRAY
3553: PUSH
3554: LD_INT 1
3556: PUSH
3557: LD_INT 3
3559: PUSH
3560: LD_INT 46
3562: PUSH
3563: LD_INT 47
3565: PUSH
3566: LD_INT 45
3568: PUSH
3569: EMPTY
3570: LIST
3571: LIST
3572: LIST
3573: PUSH
3574: LD_INT 1
3576: PPUSH
3577: LD_INT 3
3579: PPUSH
3580: CALL_OW 12
3584: ARRAY
3585: PUSH
3586: EMPTY
3587: LIST
3588: LIST
3589: LIST
3590: LIST
3591: PPUSH
3592: CALL_OW 2
3596: ST_TO_ADDR
3597: GO 3510
3599: POP
3600: POP
// p := 1 ;
3601: LD_ADDR_VAR 0 2
3605: PUSH
3606: LD_INT 1
3608: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
3609: LD_VAR 0 3
3613: PPUSH
3614: LD_VAR 0 4
3618: PPUSH
3619: CALL 84333 0 2
// repeat wait ( 0 0$1 ) ;
3623: LD_INT 35
3625: PPUSH
3626: CALL_OW 67
// p := Inc ( p ) ;
3630: LD_ADDR_VAR 0 2
3634: PUSH
3635: LD_VAR 0 2
3639: PPUSH
3640: CALL 56328 0 1
3644: ST_TO_ADDR
// until MC_GetVehicles ( base , true ) >= amount or p >= 60 ;
3645: LD_VAR 0 3
3649: PPUSH
3650: LD_INT 1
3652: PPUSH
3653: CALL 85751 0 2
3657: PUSH
3658: LD_VAR 0 7
3662: GREATEREQUAL
3663: PUSH
3664: LD_VAR 0 2
3668: PUSH
3669: LD_INT 60
3671: GREATEREQUAL
3672: OR
3673: IFFALSE 3623
// wait ( 0 0$30 ) ;
3675: LD_INT 1050
3677: PPUSH
3678: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3682: LD_ADDR_VAR 0 5
3686: PUSH
3687: LD_INT 71
3689: PUSH
3690: LD_INT 19
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: PUSH
3697: LD_INT 91
3699: PUSH
3700: LD_INT 67
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: PUSH
3707: LD_INT 52
3709: PUSH
3710: LD_INT 44
3712: PUSH
3713: EMPTY
3714: LIST
3715: LIST
3716: PUSH
3717: LD_INT 68
3719: PUSH
3720: LD_INT 48
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: LIST
3731: LIST
3732: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] ] ] ] ) diff mc_defender [ base ] ;
3733: LD_ADDR_VAR 0 6
3737: PUSH
3738: LD_INT 22
3740: PUSH
3741: LD_INT 3
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PUSH
3748: LD_INT 21
3750: PUSH
3751: LD_INT 2
3753: PUSH
3754: EMPTY
3755: LIST
3756: LIST
3757: PUSH
3758: LD_INT 3
3760: PUSH
3761: LD_INT 2
3763: PUSH
3764: LD_INT 34
3766: PUSH
3767: LD_INT 52
3769: PUSH
3770: EMPTY
3771: LIST
3772: LIST
3773: PUSH
3774: LD_INT 34
3776: PUSH
3777: LD_INT 51
3779: PUSH
3780: EMPTY
3781: LIST
3782: LIST
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: LIST
3788: PUSH
3789: EMPTY
3790: LIST
3791: LIST
3792: PUSH
3793: EMPTY
3794: LIST
3795: LIST
3796: LIST
3797: PPUSH
3798: CALL_OW 69
3802: PUSH
3803: LD_EXP 85
3807: PUSH
3808: LD_VAR 0 3
3812: ARRAY
3813: DIFF
3814: ST_TO_ADDR
// if not attackers then
3815: LD_VAR 0 6
3819: NOT
3820: IFFALSE 3824
// exit ;
3822: GO 4088
// ru_attackers := attackers ;
3824: LD_ADDR_EXP 55
3828: PUSH
3829: LD_VAR 0 6
3833: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3834: LD_ADDR_EXP 82
3838: PUSH
3839: LD_EXP 82
3843: PPUSH
3844: LD_VAR 0 3
3848: PPUSH
3849: LD_EXP 82
3853: PUSH
3854: LD_VAR 0 3
3858: ARRAY
3859: PUSH
3860: LD_VAR 0 6
3864: DIFF
3865: PPUSH
3866: CALL_OW 1
3870: ST_TO_ADDR
// for i = 1 to attackers do
3871: LD_ADDR_VAR 0 1
3875: PUSH
3876: DOUBLE
3877: LD_INT 1
3879: DEC
3880: ST_TO_ADDR
3881: LD_VAR 0 6
3885: PUSH
3886: FOR_TO
3887: IFFALSE 3964
// begin case i mod 3 of 0 :
3889: LD_VAR 0 1
3893: PUSH
3894: LD_INT 3
3896: MOD
3897: PUSH
3898: LD_INT 0
3900: DOUBLE
3901: EQUAL
3902: IFTRUE 3906
3904: GO 3909
3906: POP
// ; 1 :
3907: GO 3962
3909: LD_INT 1
3911: DOUBLE
3912: EQUAL
3913: IFTRUE 3917
3915: GO 3935
3917: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3918: LD_VAR 0 1
3922: PPUSH
3923: LD_INT 32
3925: PPUSH
3926: LD_INT 49
3928: PPUSH
3929: CALL_OW 114
3933: GO 3962
3935: LD_INT 2
3937: DOUBLE
3938: EQUAL
3939: IFTRUE 3943
3941: GO 3961
3943: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3944: LD_VAR 0 1
3948: PPUSH
3949: LD_INT 117
3951: PPUSH
3952: LD_INT 107
3954: PPUSH
3955: CALL_OW 114
3959: GO 3962
3961: POP
// end ;
3962: GO 3886
3964: POP
3965: POP
// p := 0 ;
3966: LD_ADDR_VAR 0 2
3970: PUSH
3971: LD_INT 0
3973: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3974: LD_INT 35
3976: PPUSH
3977: CALL_OW 67
// p := Inc ( p ) ;
3981: LD_ADDR_VAR 0 2
3985: PUSH
3986: LD_VAR 0 2
3990: PPUSH
3991: CALL 56328 0 1
3995: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
3996: LD_VAR 0 6
4000: PPUSH
4001: LD_INT 60
4003: PUSH
4004: EMPTY
4005: LIST
4006: PPUSH
4007: CALL_OW 72
4011: NOT
4012: PUSH
4013: LD_VAR 0 2
4017: PUSH
4018: LD_INT 30
4020: GREATER
4021: OR
4022: IFFALSE 3974
// if not first_attack then
4024: LD_EXP 8
4028: NOT
4029: IFFALSE 4039
// first_attack := true ;
4031: LD_ADDR_EXP 8
4035: PUSH
4036: LD_INT 1
4038: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4039: LD_INT 35
4041: PPUSH
4042: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
4046: LD_ADDR_VAR 0 6
4050: PUSH
4051: LD_VAR 0 6
4055: PPUSH
4056: LD_INT 50
4058: PUSH
4059: EMPTY
4060: LIST
4061: PPUSH
4062: CALL_OW 72
4066: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
4067: LD_VAR 0 6
4071: PPUSH
4072: LD_VAR 0 5
4076: PPUSH
4077: CALL 57571 0 2
// until not attackers ;
4081: LD_VAR 0 6
4085: NOT
4086: IFFALSE 4039
// end ;
4088: PPOPN 7
4090: END
// export function PrepareRussianAttack ; var i , tmp , veh , chassis , weapon ; begin
4091: LD_INT 0
4093: PPUSH
4094: PPUSH
4095: PPUSH
4096: PPUSH
4097: PPUSH
4098: PPUSH
// uc_side := 6 ;
4099: LD_ADDR_OWVAR 20
4103: PUSH
4104: LD_INT 6
4106: ST_TO_ADDR
// uc_nation := 3 ;
4107: LD_ADDR_OWVAR 21
4111: PUSH
4112: LD_INT 3
4114: ST_TO_ADDR
// InitHc ;
4115: CALL_OW 19
// InitVc ;
4119: CALL_OW 20
// tmp := [ ] ;
4123: LD_ADDR_VAR 0 3
4127: PUSH
4128: EMPTY
4129: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
4130: LD_ADDR_VAR 0 2
4134: PUSH
4135: DOUBLE
4136: LD_INT 1
4138: DEC
4139: ST_TO_ADDR
4140: LD_INT 4
4142: PUSH
4143: LD_INT 5
4145: PUSH
4146: LD_INT 6
4148: PUSH
4149: LD_INT 7
4151: PUSH
4152: EMPTY
4153: LIST
4154: LIST
4155: LIST
4156: LIST
4157: PUSH
4158: LD_OWVAR 67
4162: ARRAY
4163: PUSH
4164: FOR_TO
4165: IFFALSE 4419
// begin chassis := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 3 ) ] ;
4167: LD_ADDR_VAR 0 5
4171: PUSH
4172: LD_INT 21
4174: PUSH
4175: LD_INT 22
4177: PUSH
4178: LD_INT 24
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: LIST
4185: PUSH
4186: LD_INT 1
4188: PPUSH
4189: LD_INT 3
4191: PPUSH
4192: CALL_OW 12
4196: ARRAY
4197: ST_TO_ADDR
// case chassis of ru_medium_wheeled , ru_medium_tracked :
4198: LD_VAR 0 5
4202: PUSH
4203: LD_INT 21
4205: DOUBLE
4206: EQUAL
4207: IFTRUE 4217
4209: LD_INT 22
4211: DOUBLE
4212: EQUAL
4213: IFTRUE 4217
4215: GO 4251
4217: POP
// weapon := [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ rand ( 1 , 3 ) ] ; ru_heavy_tracked :
4218: LD_ADDR_VAR 0 6
4222: PUSH
4223: LD_INT 45
4225: PUSH
4226: LD_INT 44
4228: PUSH
4229: LD_INT 43
4231: PUSH
4232: EMPTY
4233: LIST
4234: LIST
4235: LIST
4236: PUSH
4237: LD_INT 1
4239: PPUSH
4240: LD_INT 3
4242: PPUSH
4243: CALL_OW 12
4247: ARRAY
4248: ST_TO_ADDR
4249: GO 4298
4251: LD_INT 24
4253: DOUBLE
4254: EQUAL
4255: IFTRUE 4259
4257: GO 4297
4259: POP
// weapon := [ ru_heavy_gun , ru_rocket , ru_rocket_launcher , ru_heavy_gun ] [ rand ( 1 , 4 ) ] ; end ;
4260: LD_ADDR_VAR 0 6
4264: PUSH
4265: LD_INT 46
4267: PUSH
4268: LD_INT 47
4270: PUSH
4271: LD_INT 45
4273: PUSH
4274: LD_INT 46
4276: PUSH
4277: EMPTY
4278: LIST
4279: LIST
4280: LIST
4281: LIST
4282: PUSH
4283: LD_INT 1
4285: PPUSH
4286: LD_INT 4
4288: PPUSH
4289: CALL_OW 12
4293: ARRAY
4294: ST_TO_ADDR
4295: GO 4298
4297: POP
// uc_side := 6 ;
4298: LD_ADDR_OWVAR 20
4302: PUSH
4303: LD_INT 6
4305: ST_TO_ADDR
// uc_nation := 3 ;
4306: LD_ADDR_OWVAR 21
4310: PUSH
4311: LD_INT 3
4313: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
4314: LD_VAR 0 5
4318: PPUSH
4319: LD_INT 1
4321: PUSH
4322: LD_INT 3
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: PUSH
4329: LD_INT 1
4331: PPUSH
4332: LD_INT 2
4334: PPUSH
4335: CALL_OW 12
4339: ARRAY
4340: PPUSH
4341: LD_INT 3
4343: PPUSH
4344: LD_VAR 0 6
4348: PPUSH
4349: LD_INT 70
4351: PPUSH
4352: LD_INT 90
4354: PPUSH
4355: CALL_OW 12
4359: PPUSH
4360: CALL 22116 0 5
// veh := CreateVehicle ;
4364: LD_ADDR_VAR 0 4
4368: PUSH
4369: CALL_OW 45
4373: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
4374: LD_VAR 0 4
4378: PPUSH
4379: LD_INT 5
4381: PPUSH
4382: CALL_OW 233
// PlaceUnitArea ( veh , south_spawn , false ) ;
4386: LD_VAR 0 4
4390: PPUSH
4391: LD_INT 16
4393: PPUSH
4394: LD_INT 0
4396: PPUSH
4397: CALL_OW 49
// tmp := tmp ^ veh ;
4401: LD_ADDR_VAR 0 3
4405: PUSH
4406: LD_VAR 0 3
4410: PUSH
4411: LD_VAR 0 4
4415: ADD
4416: ST_TO_ADDR
// end ;
4417: GO 4164
4419: POP
4420: POP
// if not tmp then
4421: LD_VAR 0 3
4425: NOT
4426: IFFALSE 4430
// exit ;
4428: GO 4524
// repeat wait ( 0 0$2 ) ;
4430: LD_INT 70
4432: PPUSH
4433: CALL_OW 67
// for i in tmp do
4437: LD_ADDR_VAR 0 2
4441: PUSH
4442: LD_VAR 0 3
4446: PUSH
4447: FOR_IN
4448: IFFALSE 4515
// if IsOk ( i ) then
4450: LD_VAR 0 2
4454: PPUSH
4455: CALL_OW 302
4459: IFFALSE 4497
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) else
4461: LD_VAR 0 2
4465: PPUSH
4466: LD_INT 22
4468: PUSH
4469: LD_INT 7
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: PPUSH
4476: CALL_OW 69
4480: PPUSH
4481: LD_VAR 0 2
4485: PPUSH
4486: CALL_OW 74
4490: PPUSH
4491: CALL_OW 115
4495: GO 4513
// tmp := tmp diff i ;
4497: LD_ADDR_VAR 0 3
4501: PUSH
4502: LD_VAR 0 3
4506: PUSH
4507: LD_VAR 0 2
4511: DIFF
4512: ST_TO_ADDR
4513: GO 4447
4515: POP
4516: POP
// until not tmp ;
4517: LD_VAR 0 3
4521: NOT
4522: IFFALSE 4430
// end ;
4524: LD_VAR 0 1
4528: RET
// every 10 10$00 + 3 3$00 trigger first_attack and IsOk ( ru_depot ) and GetSide ( ru_depot ) = 3 and ru_active_attack do
4529: LD_EXP 8
4533: PUSH
4534: LD_INT 47
4536: PPUSH
4537: CALL_OW 302
4541: AND
4542: PUSH
4543: LD_INT 47
4545: PPUSH
4546: CALL_OW 255
4550: PUSH
4551: LD_INT 3
4553: EQUAL
4554: AND
4555: PUSH
4556: LD_EXP 6
4560: AND
4561: IFFALSE 4571
4563: GO 4565
4565: DISABLE
// begin enable ;
4566: ENABLE
// PrepareRussianAttack ;
4567: CALL 4091 0 0
// end ; end_of_file
4571: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , b , veh , area , tmp , xy , un , un2 ; begin
4572: LD_INT 0
4574: PPUSH
4575: PPUSH
4576: PPUSH
4577: PPUSH
4578: PPUSH
4579: PPUSH
4580: PPUSH
4581: PPUSH
4582: PPUSH
// uc_side := 2 ;
4583: LD_ADDR_OWVAR 20
4587: PUSH
4588: LD_INT 2
4590: ST_TO_ADDR
// uc_nation := 2 ;
4591: LD_ADDR_OWVAR 21
4595: PUSH
4596: LD_INT 2
4598: ST_TO_ADDR
// PlaceHiddenCamerasInArea ( 2 , camArea ) ;
4599: LD_INT 2
4601: PPUSH
4602: LD_INT 28
4604: PPUSH
4605: CALL 59906 0 2
// PlaceMines ( minefieldExtraNorthArea , [ 0 , 0 , 6 , 8 ] [ Difficulty ] ) ;
4609: LD_INT 25
4611: PPUSH
4612: LD_INT 0
4614: PUSH
4615: LD_INT 0
4617: PUSH
4618: LD_INT 6
4620: PUSH
4621: LD_INT 8
4623: PUSH
4624: EMPTY
4625: LIST
4626: LIST
4627: LIST
4628: LIST
4629: PUSH
4630: LD_OWVAR 67
4634: ARRAY
4635: PPUSH
4636: CALL 8103 0 2
// PlaceMines ( minefieldExtraSouthArea , [ 0 , 4 , 8 , 12 ] [ Difficulty ] ) ;
4640: LD_INT 26
4642: PPUSH
4643: LD_INT 0
4645: PUSH
4646: LD_INT 4
4648: PUSH
4649: LD_INT 8
4651: PUSH
4652: LD_INT 12
4654: PUSH
4655: EMPTY
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: PUSH
4661: LD_OWVAR 67
4665: ARRAY
4666: PPUSH
4667: CALL 8103 0 2
// if Difficulty > 2 then
4671: LD_OWVAR 67
4675: PUSH
4676: LD_INT 2
4678: GREATER
4679: IFFALSE 4849
// begin bc_type := b_breastwork ;
4681: LD_ADDR_OWVAR 42
4685: PUSH
4686: LD_INT 31
4688: ST_TO_ADDR
// bc_level := 8 ;
4689: LD_ADDR_OWVAR 43
4693: PUSH
4694: LD_INT 8
4696: ST_TO_ADDR
// for area in [ extraBunkerArArea , extraBunkerArArea2 ] do
4697: LD_ADDR_VAR 0 5
4701: PUSH
4702: LD_INT 27
4704: PUSH
4705: LD_INT 29
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: FOR_IN
4713: IFFALSE 4847
// begin tmp := GetBuildingFromArea ( area , 1 ) ;
4715: LD_ADDR_VAR 0 6
4719: PUSH
4720: LD_VAR 0 5
4724: PPUSH
4725: LD_INT 1
4727: PPUSH
4728: CALL 59506 0 2
4732: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( tmp [ 1 ] , tmp [ 2 ] , tmp [ 3 ] ) ;
4733: LD_ADDR_VAR 0 3
4737: PUSH
4738: LD_VAR 0 6
4742: PUSH
4743: LD_INT 1
4745: ARRAY
4746: PPUSH
4747: LD_VAR 0 6
4751: PUSH
4752: LD_INT 2
4754: ARRAY
4755: PPUSH
4756: LD_VAR 0 6
4760: PUSH
4761: LD_INT 3
4763: ARRAY
4764: PPUSH
4765: CALL_OW 47
4769: ST_TO_ADDR
// PrepareSoldier ( false , 5 + Difficulty ) ;
4770: LD_INT 0
4772: PPUSH
4773: LD_INT 5
4775: PUSH
4776: LD_OWVAR 67
4780: PLUS
4781: PPUSH
4782: CALL_OW 381
// un := CreateHuman ;
4786: LD_ADDR_VAR 0 8
4790: PUSH
4791: CALL_OW 44
4795: ST_TO_ADDR
// SetDir ( un , GetDir ( b ) - 3 ) ;
4796: LD_VAR 0 8
4800: PPUSH
4801: LD_VAR 0 3
4805: PPUSH
4806: CALL_OW 254
4810: PUSH
4811: LD_INT 3
4813: MINUS
4814: PPUSH
4815: CALL_OW 233
// SetClass ( un , class_sniper ) ;
4819: LD_VAR 0 8
4823: PPUSH
4824: LD_INT 5
4826: PPUSH
4827: CALL_OW 336
// PlaceHumanInUnit ( un , b ) ;
4831: LD_VAR 0 8
4835: PPUSH
4836: LD_VAR 0 3
4840: PPUSH
4841: CALL_OW 52
// end ;
4845: GO 4712
4847: POP
4848: POP
// end ; Abdul := NewCharacter ( Abdul ) ;
4849: LD_ADDR_EXP 58
4853: PUSH
4854: LD_STRING Abdul
4856: PPUSH
4857: CALL_OW 25
4861: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4862: LD_EXP 58
4866: PPUSH
4867: LD_INT 11
4869: PPUSH
4870: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4874: LD_EXP 58
4878: PPUSH
4879: LD_INT 1
4881: PPUSH
4882: CALL_OW 52
// vc_chassis := 31 ;
4886: LD_ADDR_OWVAR 37
4890: PUSH
4891: LD_INT 31
4893: ST_TO_ADDR
// vc_control := control_rider ;
4894: LD_ADDR_OWVAR 38
4898: PUSH
4899: LD_INT 4
4901: ST_TO_ADDR
// mastodont := CreateVehicle ;
4902: LD_ADDR_EXP 59
4906: PUSH
4907: CALL_OW 45
4911: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4912: LD_EXP 59
4916: PPUSH
4917: LD_INT 153
4919: PPUSH
4920: LD_INT 71
4922: PPUSH
4923: LD_INT 0
4925: PPUSH
4926: CALL_OW 48
// InitVc ;
4930: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian , kaba , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 11 , 5 , 6 , 7 ] ) ;
4934: LD_ADDR_EXP 56
4938: PUSH
4939: LD_INT 1
4941: PPUSH
4942: LD_INT 3
4944: PPUSH
4945: LD_STRING kaba
4947: PPUSH
4948: LD_INT 7
4950: PUSH
4951: LD_INT 8
4953: PUSH
4954: LD_INT 9
4956: PUSH
4957: LD_INT 10
4959: PUSH
4960: EMPTY
4961: LIST
4962: LIST
4963: LIST
4964: LIST
4965: PUSH
4966: LD_OWVAR 67
4970: ARRAY
4971: PPUSH
4972: LD_INT 5000
4974: PUSH
4975: LD_INT 1000
4977: PUSH
4978: LD_INT 300
4980: PUSH
4981: EMPTY
4982: LIST
4983: LIST
4984: LIST
4985: PPUSH
4986: LD_INT 11
4988: PUSH
4989: LD_INT 5
4991: PUSH
4992: LD_INT 6
4994: PUSH
4995: LD_INT 7
4997: PUSH
4998: EMPTY
4999: LIST
5000: LIST
5001: LIST
5002: LIST
5003: PPUSH
5004: CALL 25937 0 6
5008: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
5009: LD_ADDR_EXP 63
5013: PUSH
5014: LD_EXP 63
5018: PPUSH
5019: LD_INT 1
5021: PPUSH
5022: LD_EXP 56
5026: PPUSH
5027: CALL_OW 1
5031: ST_TO_ADDR
// tmp := [ ] ;
5032: LD_ADDR_VAR 0 6
5036: PUSH
5037: EMPTY
5038: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
5039: LD_ADDR_OWVAR 37
5043: PUSH
5044: LD_INT 13
5046: ST_TO_ADDR
// vc_engine := engine_siberite ;
5047: LD_ADDR_OWVAR 39
5051: PUSH
5052: LD_INT 3
5054: ST_TO_ADDR
// vc_control := control_manual ;
5055: LD_ADDR_OWVAR 38
5059: PUSH
5060: LD_INT 1
5062: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
5063: LD_ADDR_OWVAR 40
5067: PUSH
5068: LD_INT 31
5070: ST_TO_ADDR
// for i = 1 to 3 do
5071: LD_ADDR_VAR 0 2
5075: PUSH
5076: DOUBLE
5077: LD_INT 1
5079: DEC
5080: ST_TO_ADDR
5081: LD_INT 3
5083: PUSH
5084: FOR_TO
5085: IFFALSE 5333
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
5087: LD_ADDR_VAR 0 7
5091: PUSH
5092: LD_INT 153
5094: PUSH
5095: LD_INT 71
5097: PUSH
5098: EMPTY
5099: LIST
5100: LIST
5101: PUSH
5102: LD_INT 155
5104: PUSH
5105: LD_INT 81
5107: PUSH
5108: EMPTY
5109: LIST
5110: LIST
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: PUSH
5116: LD_VAR 0 2
5120: PUSH
5121: LD_INT 2
5123: MOD
5124: PUSH
5125: LD_INT 1
5127: PLUS
5128: ARRAY
5129: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
5130: LD_INT 0
5132: PPUSH
5133: LD_INT 3
5135: PPUSH
5136: LD_INT 7
5138: PUSH
5139: LD_INT 8
5141: PUSH
5142: LD_INT 10
5144: PUSH
5145: LD_INT 10
5147: PUSH
5148: EMPTY
5149: LIST
5150: LIST
5151: LIST
5152: LIST
5153: PUSH
5154: LD_OWVAR 67
5158: ARRAY
5159: PPUSH
5160: CALL_OW 380
// un := CreateVehicle ;
5164: LD_ADDR_VAR 0 8
5168: PUSH
5169: CALL_OW 45
5173: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
5174: LD_VAR 0 8
5178: PPUSH
5179: LD_INT 0
5181: PPUSH
5182: LD_INT 5
5184: PPUSH
5185: CALL_OW 12
5189: PPUSH
5190: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
5194: LD_VAR 0 8
5198: PPUSH
5199: LD_VAR 0 7
5203: PUSH
5204: LD_INT 1
5206: ARRAY
5207: PPUSH
5208: LD_VAR 0 7
5212: PUSH
5213: LD_INT 2
5215: ARRAY
5216: PPUSH
5217: LD_INT 6
5219: PPUSH
5220: LD_INT 0
5222: PPUSH
5223: CALL_OW 50
// un2 := CreateHuman ;
5227: LD_ADDR_VAR 0 9
5231: PUSH
5232: CALL_OW 44
5236: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
5237: LD_VAR 0 9
5241: PPUSH
5242: LD_VAR 0 8
5246: PPUSH
5247: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
5251: LD_ADDR_EXP 63
5255: PUSH
5256: LD_EXP 63
5260: PPUSH
5261: LD_INT 1
5263: PUSH
5264: LD_EXP 63
5268: PUSH
5269: LD_INT 1
5271: ARRAY
5272: PUSH
5273: LD_INT 1
5275: PLUS
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: PPUSH
5281: LD_VAR 0 8
5285: PPUSH
5286: CALL 22238 0 3
5290: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
5291: LD_ADDR_EXP 63
5295: PUSH
5296: LD_EXP 63
5300: PPUSH
5301: LD_INT 1
5303: PUSH
5304: LD_EXP 63
5308: PUSH
5309: LD_INT 1
5311: ARRAY
5312: PUSH
5313: LD_INT 1
5315: PLUS
5316: PUSH
5317: EMPTY
5318: LIST
5319: LIST
5320: PPUSH
5321: LD_VAR 0 9
5325: PPUSH
5326: CALL 22238 0 3
5330: ST_TO_ADDR
// end ;
5331: GO 5084
5333: POP
5334: POP
// for i = 1 to 5 do
5335: LD_ADDR_VAR 0 2
5339: PUSH
5340: DOUBLE
5341: LD_INT 1
5343: DEC
5344: ST_TO_ADDR
5345: LD_INT 5
5347: PUSH
5348: FOR_TO
5349: IFFALSE 5442
// begin PrepareVehicle ( ar_medium_trike , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
5351: LD_INT 13
5353: PPUSH
5354: LD_INT 3
5356: PPUSH
5357: LD_INT 1
5359: PPUSH
5360: LD_INT 25
5362: PUSH
5363: LD_INT 28
5365: PUSH
5366: LD_INT 28
5368: PUSH
5369: LD_INT 26
5371: PUSH
5372: EMPTY
5373: LIST
5374: LIST
5375: LIST
5376: LIST
5377: PUSH
5378: LD_VAR 0 2
5382: PUSH
5383: LD_INT 4
5385: MOD
5386: PUSH
5387: LD_INT 1
5389: PLUS
5390: ARRAY
5391: PPUSH
5392: LD_INT 100
5394: PPUSH
5395: CALL 22116 0 5
// veh := CreateVehicle ;
5399: LD_ADDR_VAR 0 4
5403: PUSH
5404: CALL_OW 45
5408: ST_TO_ADDR
// tmp := tmp ^ veh ;
5409: LD_ADDR_VAR 0 6
5413: PUSH
5414: LD_VAR 0 6
5418: PUSH
5419: LD_VAR 0 4
5423: ADD
5424: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
5425: LD_VAR 0 4
5429: PPUSH
5430: LD_INT 1
5432: PPUSH
5433: LD_INT 0
5435: PPUSH
5436: CALL_OW 49
// end ;
5440: GO 5348
5442: POP
5443: POP
// arabian_guard := tmp ;
5444: LD_ADDR_EXP 57
5448: PUSH
5449: LD_VAR 0 6
5453: ST_TO_ADDR
// end ;
5454: LD_VAR 0 1
5458: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
5459: LD_INT 22
5461: PUSH
5462: LD_INT 7
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: PUSH
5469: LD_INT 91
5471: PUSH
5472: LD_INT 1
5474: PUSH
5475: LD_INT 12
5477: PUSH
5478: EMPTY
5479: LIST
5480: LIST
5481: LIST
5482: PUSH
5483: EMPTY
5484: LIST
5485: LIST
5486: PPUSH
5487: CALL_OW 69
5491: PUSH
5492: LD_EXP 59
5496: PPUSH
5497: CALL_OW 256
5501: PUSH
5502: LD_INT 990
5504: LESS
5505: OR
5506: PUSH
5507: LD_EXP 58
5511: PPUSH
5512: CALL_OW 256
5516: PUSH
5517: LD_INT 990
5519: LESS
5520: OR
5521: IFFALSE 5664
5523: GO 5525
5525: DISABLE
// begin if IsInUnit ( Abdul ) then
5526: LD_EXP 58
5530: PPUSH
5531: CALL_OW 310
5535: IFFALSE 5546
// ComExitBuilding ( Abdul ) ;
5537: LD_EXP 58
5541: PPUSH
5542: CALL_OW 122
// if Mastodont then
5546: LD_EXP 59
5550: IFFALSE 5567
// ComMoveXY ( Mastodont , 205 , 132 ) ;
5552: LD_EXP 59
5556: PPUSH
5557: LD_INT 205
5559: PPUSH
5560: LD_INT 132
5562: PPUSH
5563: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
5567: LD_EXP 58
5571: PPUSH
5572: LD_INT 205
5574: PPUSH
5575: LD_INT 132
5577: PPUSH
5578: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
5582: LD_INT 35
5584: PPUSH
5585: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
5589: LD_EXP 58
5593: PPUSH
5594: LD_INT 21
5596: PPUSH
5597: CALL_OW 308
5601: IFFALSE 5582
// RemoveUnit ( Abdul ) ;
5603: LD_EXP 58
5607: PPUSH
5608: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
5612: LD_INT 35
5614: PPUSH
5615: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
5619: LD_EXP 59
5623: PPUSH
5624: LD_INT 21
5626: PPUSH
5627: CALL_OW 308
5631: PUSH
5632: LD_EXP 59
5636: PPUSH
5637: CALL_OW 301
5641: OR
5642: IFFALSE 5612
// if IsOk ( Mastodont ) then
5644: LD_EXP 59
5648: PPUSH
5649: CALL_OW 302
5653: IFFALSE 5664
// RemoveUnit ( Mastodont ) ;
5655: LD_EXP 59
5659: PPUSH
5660: CALL_OW 64
// end ;
5664: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
5665: LD_EXP 58
5669: PPUSH
5670: CALL_OW 301
5674: PUSH
5675: LD_INT 22
5677: PUSH
5678: LD_INT 2
5680: PUSH
5681: EMPTY
5682: LIST
5683: LIST
5684: PUSH
5685: LD_INT 2
5687: PUSH
5688: LD_INT 25
5690: PUSH
5691: LD_INT 1
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: PUSH
5698: LD_INT 25
5700: PUSH
5701: LD_INT 2
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: PUSH
5708: LD_INT 25
5710: PUSH
5711: LD_INT 3
5713: PUSH
5714: EMPTY
5715: LIST
5716: LIST
5717: PUSH
5718: LD_INT 25
5720: PUSH
5721: LD_INT 4
5723: PUSH
5724: EMPTY
5725: LIST
5726: LIST
5727: PUSH
5728: LD_INT 25
5730: PUSH
5731: LD_INT 8
5733: PUSH
5734: EMPTY
5735: LIST
5736: LIST
5737: PUSH
5738: EMPTY
5739: LIST
5740: LIST
5741: LIST
5742: LIST
5743: LIST
5744: LIST
5745: PUSH
5746: EMPTY
5747: LIST
5748: LIST
5749: PPUSH
5750: CALL_OW 69
5754: PUSH
5755: LD_INT 16
5757: PUSH
5758: LD_INT 19
5760: PUSH
5761: LD_INT 22
5763: PUSH
5764: LD_INT 22
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: PUSH
5773: LD_OWVAR 67
5777: ARRAY
5778: LESS
5779: OR
5780: IFFALSE 6453
5782: GO 5784
5784: DISABLE
5785: LD_INT 0
5787: PPUSH
5788: PPUSH
5789: PPUSH
5790: PPUSH
5791: PPUSH
5792: PPUSH
// begin MC_Kill ( 1 ) ;
5793: LD_INT 1
5795: PPUSH
5796: CALL 60308 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
5800: LD_ADDR_VAR 0 2
5804: PUSH
5805: LD_INT 22
5807: PUSH
5808: LD_INT 2
5810: PUSH
5811: EMPTY
5812: LIST
5813: LIST
5814: PUSH
5815: LD_INT 2
5817: PUSH
5818: LD_INT 25
5820: PUSH
5821: LD_INT 1
5823: PUSH
5824: EMPTY
5825: LIST
5826: LIST
5827: PUSH
5828: LD_INT 25
5830: PUSH
5831: LD_INT 2
5833: PUSH
5834: EMPTY
5835: LIST
5836: LIST
5837: PUSH
5838: LD_INT 25
5840: PUSH
5841: LD_INT 3
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: PUSH
5848: LD_INT 25
5850: PUSH
5851: LD_INT 4
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: PUSH
5858: LD_INT 25
5860: PUSH
5861: LD_INT 8
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: LIST
5872: LIST
5873: LIST
5874: LIST
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: PPUSH
5880: CALL_OW 69
5884: ST_TO_ADDR
// for i in tmp do
5885: LD_ADDR_VAR 0 5
5889: PUSH
5890: LD_VAR 0 2
5894: PUSH
5895: FOR_IN
5896: IFFALSE 5912
// SetTag ( i , 10 ) ;
5898: LD_VAR 0 5
5902: PPUSH
5903: LD_INT 10
5905: PPUSH
5906: CALL_OW 109
5910: GO 5895
5912: POP
5913: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5914: LD_ADDR_VAR 0 3
5918: PUSH
5919: LD_INT 22
5921: PUSH
5922: LD_INT 2
5924: PUSH
5925: EMPTY
5926: LIST
5927: LIST
5928: PUSH
5929: LD_INT 21
5931: PUSH
5932: LD_INT 1
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: PUSH
5939: EMPTY
5940: LIST
5941: LIST
5942: PPUSH
5943: CALL_OW 69
5947: PUSH
5948: LD_VAR 0 2
5952: DIFF
5953: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5954: LD_ADDR_VAR 0 1
5958: PUSH
5959: LD_INT 22
5961: PUSH
5962: LD_INT 2
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: PUSH
5969: LD_INT 21
5971: PUSH
5972: LD_INT 2
5974: PUSH
5975: EMPTY
5976: LIST
5977: LIST
5978: PUSH
5979: LD_INT 24
5981: PUSH
5982: LD_INT 300
5984: PUSH
5985: EMPTY
5986: LIST
5987: LIST
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: PPUSH
5994: CALL_OW 69
5998: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5999: LD_ADDR_VAR 0 4
6003: PUSH
6004: LD_VAR 0 1
6008: PPUSH
6009: LD_INT 33
6011: PUSH
6012: LD_INT 1
6014: PUSH
6015: EMPTY
6016: LIST
6017: LIST
6018: PUSH
6019: LD_INT 58
6021: PUSH
6022: EMPTY
6023: LIST
6024: PUSH
6025: EMPTY
6026: LIST
6027: LIST
6028: PPUSH
6029: CALL_OW 72
6033: ST_TO_ADDR
// for i in tmp do
6034: LD_ADDR_VAR 0 5
6038: PUSH
6039: LD_VAR 0 2
6043: PUSH
6044: FOR_IN
6045: IFFALSE 6229
// begin if i in FilterAllUnits ( [ f_driving ] ) then
6047: LD_VAR 0 5
6051: PUSH
6052: LD_INT 55
6054: PUSH
6055: EMPTY
6056: LIST
6057: PPUSH
6058: CALL_OW 69
6062: IN
6063: IFFALSE 6082
// begin AddComMoveXY ( i , 209 , 132 ) ;
6065: LD_VAR 0 5
6069: PPUSH
6070: LD_INT 209
6072: PPUSH
6073: LD_INT 132
6075: PPUSH
6076: CALL_OW 171
// continue ;
6080: GO 6044
// end ; if IsInUnit ( i ) then
6082: LD_VAR 0 5
6086: PPUSH
6087: CALL_OW 310
6091: IFFALSE 6109
// begin ComExitBuilding ( i ) ;
6093: LD_VAR 0 5
6097: PPUSH
6098: CALL_OW 122
// wait ( 3 ) ;
6102: LD_INT 3
6104: PPUSH
6105: CALL_OW 67
// end ; if tmp_empty then
6109: LD_VAR 0 4
6113: IFFALSE 6212
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
6115: LD_VAR 0 5
6119: PPUSH
6120: LD_VAR 0 4
6124: PPUSH
6125: LD_VAR 0 5
6129: PPUSH
6130: CALL_OW 74
6134: PPUSH
6135: CALL_OW 296
6139: PUSH
6140: LD_INT 25
6142: LESS
6143: IFFALSE 6212
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
6145: LD_ADDR_VAR 0 6
6149: PUSH
6150: LD_VAR 0 4
6154: PPUSH
6155: LD_VAR 0 5
6159: PPUSH
6160: CALL_OW 74
6164: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
6165: LD_VAR 0 5
6169: PPUSH
6170: LD_VAR 0 6
6174: PPUSH
6175: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
6179: LD_VAR 0 5
6183: PPUSH
6184: LD_INT 209
6186: PPUSH
6187: LD_INT 132
6189: PPUSH
6190: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
6194: LD_ADDR_VAR 0 4
6198: PUSH
6199: LD_VAR 0 4
6203: PUSH
6204: LD_VAR 0 6
6208: DIFF
6209: ST_TO_ADDR
// continue ;
6210: GO 6044
// end ; AddComMoveXY ( i , 201 , 132 ) ;
6212: LD_VAR 0 5
6216: PPUSH
6217: LD_INT 201
6219: PPUSH
6220: LD_INT 132
6222: PPUSH
6223: CALL_OW 171
// end ;
6227: GO 6044
6229: POP
6230: POP
// for i in tmp_ape do
6231: LD_ADDR_VAR 0 5
6235: PUSH
6236: LD_VAR 0 3
6240: PUSH
6241: FOR_IN
6242: IFFALSE 6281
// begin if IsInUnit ( i ) then
6244: LD_VAR 0 5
6248: PPUSH
6249: CALL_OW 310
6253: IFFALSE 6264
// ComExitBuilding ( i ) ;
6255: LD_VAR 0 5
6259: PPUSH
6260: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
6264: LD_VAR 0 5
6268: PPUSH
6269: LD_INT 201
6271: PPUSH
6272: LD_INT 132
6274: PPUSH
6275: CALL_OW 171
// end ;
6279: GO 6241
6281: POP
6282: POP
// repeat wait ( 0 0$1 ) ;
6283: LD_INT 35
6285: PPUSH
6286: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
6290: LD_ADDR_VAR 0 5
6294: PUSH
6295: LD_VAR 0 2
6299: PUSH
6300: LD_VAR 0 3
6304: UNION
6305: PUSH
6306: LD_VAR 0 1
6310: UNION
6311: PUSH
6312: FOR_IN
6313: IFFALSE 6344
// if not HasTask ( i ) then
6315: LD_VAR 0 5
6319: PPUSH
6320: CALL_OW 314
6324: NOT
6325: IFFALSE 6342
// ComMoveXY ( i , 201 , 132 ) ;
6327: LD_VAR 0 5
6331: PPUSH
6332: LD_INT 201
6334: PPUSH
6335: LD_INT 132
6337: PPUSH
6338: CALL_OW 111
6342: GO 6312
6344: POP
6345: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
6346: LD_INT 21
6348: PPUSH
6349: LD_INT 22
6351: PUSH
6352: LD_INT 2
6354: PUSH
6355: EMPTY
6356: LIST
6357: LIST
6358: PPUSH
6359: CALL_OW 70
6363: IFFALSE 6404
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
6365: LD_ADDR_VAR 0 5
6369: PUSH
6370: LD_INT 21
6372: PPUSH
6373: LD_INT 22
6375: PUSH
6376: LD_INT 2
6378: PUSH
6379: EMPTY
6380: LIST
6381: LIST
6382: PPUSH
6383: CALL_OW 70
6387: PUSH
6388: FOR_IN
6389: IFFALSE 6402
// RemoveUnit ( i ) ;
6391: LD_VAR 0 5
6395: PPUSH
6396: CALL_OW 64
6400: GO 6388
6402: POP
6403: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
6404: LD_INT 22
6406: PUSH
6407: LD_INT 2
6409: PUSH
6410: EMPTY
6411: LIST
6412: LIST
6413: PUSH
6414: LD_INT 2
6416: PUSH
6417: LD_INT 21
6419: PUSH
6420: LD_INT 1
6422: PUSH
6423: EMPTY
6424: LIST
6425: LIST
6426: PUSH
6427: LD_INT 21
6429: PUSH
6430: LD_INT 2
6432: PUSH
6433: EMPTY
6434: LIST
6435: LIST
6436: PUSH
6437: EMPTY
6438: LIST
6439: LIST
6440: LIST
6441: PUSH
6442: EMPTY
6443: LIST
6444: LIST
6445: PPUSH
6446: CALL_OW 69
6450: NOT
6451: IFFALSE 6283
// end ;
6453: PPOPN 6
6455: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
6456: LD_EXP 10
6460: PUSH
6461: LD_INT 92
6463: PPUSH
6464: LD_INT 40
6466: PPUSH
6467: CALL_OW 428
6471: PPUSH
6472: CALL_OW 266
6476: PUSH
6477: LD_INT 30
6479: EQUAL
6480: AND
6481: IFFALSE 6677
6483: GO 6485
6485: DISABLE
6486: LD_INT 0
6488: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
6489: LD_ADDR_VAR 0 1
6493: PUSH
6494: LD_EXP 63
6498: PUSH
6499: LD_INT 1
6501: ARRAY
6502: PPUSH
6503: LD_INT 25
6505: PUSH
6506: LD_INT 4
6508: PUSH
6509: EMPTY
6510: LIST
6511: LIST
6512: PPUSH
6513: CALL_OW 72
6517: ST_TO_ADDR
// if not sci then
6518: LD_VAR 0 1
6522: NOT
6523: IFFALSE 6527
// exit ;
6525: GO 6677
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
6527: LD_ADDR_EXP 63
6531: PUSH
6532: LD_EXP 63
6536: PPUSH
6537: LD_INT 1
6539: PPUSH
6540: LD_EXP 63
6544: PUSH
6545: LD_INT 1
6547: ARRAY
6548: PUSH
6549: LD_VAR 0 1
6553: PUSH
6554: LD_INT 1
6556: ARRAY
6557: DIFF
6558: PPUSH
6559: CALL_OW 1
6563: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
6564: LD_VAR 0 1
6568: PUSH
6569: LD_INT 1
6571: ARRAY
6572: PPUSH
6573: CALL_OW 310
6577: IFFALSE 6592
// ComExitBuilding ( sci [ 1 ] ) ;
6579: LD_VAR 0 1
6583: PUSH
6584: LD_INT 1
6586: ARRAY
6587: PPUSH
6588: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
6592: LD_INT 2
6594: PPUSH
6595: LD_INT 105
6597: PPUSH
6598: LD_INT 14
6600: PPUSH
6601: LD_INT 20
6603: PPUSH
6604: CALL 23502 0 4
6608: PUSH
6609: LD_INT 4
6611: ARRAY
6612: PUSH
6613: LD_INT 10
6615: LESS
6616: IFFALSE 6639
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
6618: LD_VAR 0 1
6622: PUSH
6623: LD_INT 1
6625: ARRAY
6626: PPUSH
6627: LD_INT 105
6629: PPUSH
6630: LD_INT 14
6632: PPUSH
6633: CALL_OW 171
6637: GO 6658
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
6639: LD_VAR 0 1
6643: PUSH
6644: LD_INT 1
6646: ARRAY
6647: PPUSH
6648: LD_INT 118
6650: PPUSH
6651: LD_INT 77
6653: PPUSH
6654: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
6658: LD_VAR 0 1
6662: PUSH
6663: LD_INT 1
6665: ARRAY
6666: PPUSH
6667: LD_INT 92
6669: PPUSH
6670: LD_INT 40
6672: PPUSH
6673: CALL_OW 218
// end ;
6677: PPOPN 1
6679: END
// every 6 6$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , un , base , tmp , flags , _target , attackers , p ;
6680: LD_INT 1
6682: PPUSH
6683: CALL_OW 302
6687: PUSH
6688: LD_EXP 10
6692: AND
6693: IFFALSE 7582
6695: GO 6697
6697: DISABLE
6698: LD_INT 0
6700: PPUSH
6701: PPUSH
6702: PPUSH
6703: PPUSH
6704: PPUSH
6705: PPUSH
6706: PPUSH
6707: PPUSH
// begin enable ;
6708: ENABLE
// base := 1 ;
6709: LD_ADDR_VAR 0 3
6713: PUSH
6714: LD_INT 1
6716: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6717: LD_ADDR_VAR 0 5
6721: PUSH
6722: LD_INT 0
6724: PUSH
6725: LD_INT 0
6727: PUSH
6728: LD_INT 0
6730: PUSH
6731: LD_INT 0
6733: PUSH
6734: LD_INT 0
6736: PUSH
6737: LD_INT 0
6739: PUSH
6740: LD_INT 0
6742: PUSH
6743: LD_INT 0
6745: PUSH
6746: LD_INT 1
6748: PUSH
6749: LD_INT 0
6751: PUSH
6752: EMPTY
6753: LIST
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: LIST
6759: LIST
6760: LIST
6761: LIST
6762: LIST
6763: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
6764: LD_ADDR_VAR 0 4
6768: PUSH
6769: LD_INT 13
6771: PUSH
6772: LD_INT 1
6774: PUSH
6775: LD_INT 2
6777: PUSH
6778: LD_INT 26
6780: PUSH
6781: EMPTY
6782: LIST
6783: LIST
6784: LIST
6785: LIST
6786: PUSH
6787: LD_INT 13
6789: PUSH
6790: LD_INT 1
6792: PUSH
6793: LD_INT 2
6795: PUSH
6796: LD_INT 28
6798: PUSH
6799: EMPTY
6800: LIST
6801: LIST
6802: LIST
6803: LIST
6804: PUSH
6805: LD_INT 13
6807: PUSH
6808: LD_INT 1
6810: PUSH
6811: LD_INT 2
6813: PUSH
6814: LD_INT 29
6816: PUSH
6817: EMPTY
6818: LIST
6819: LIST
6820: LIST
6821: LIST
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: LIST
6827: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6828: LD_ADDR_VAR 0 1
6832: PUSH
6833: DOUBLE
6834: LD_INT 1
6836: DEC
6837: ST_TO_ADDR
6838: LD_OWVAR 67
6842: PUSH
6843: LD_OWVAR 1
6847: PUSH
6848: LD_INT 21000
6850: DIV
6851: PLUS
6852: PUSH
6853: FOR_TO
6854: IFFALSE 6927
// tmp := Insert ( tmp , tmp + 1 , [ ar_medium_trike , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6856: LD_ADDR_VAR 0 4
6860: PUSH
6861: LD_VAR 0 4
6865: PPUSH
6866: LD_VAR 0 4
6870: PUSH
6871: LD_INT 1
6873: PLUS
6874: PPUSH
6875: LD_INT 13
6877: PUSH
6878: LD_INT 1
6880: PUSH
6881: LD_INT 2
6883: PUSH
6884: LD_INT 28
6886: PUSH
6887: LD_INT 29
6889: PUSH
6890: LD_INT 25
6892: PUSH
6893: LD_INT 26
6895: PUSH
6896: EMPTY
6897: LIST
6898: LIST
6899: LIST
6900: LIST
6901: PUSH
6902: LD_INT 1
6904: PPUSH
6905: LD_INT 4
6907: PPUSH
6908: CALL_OW 12
6912: ARRAY
6913: PUSH
6914: EMPTY
6915: LIST
6916: LIST
6917: LIST
6918: LIST
6919: PPUSH
6920: CALL_OW 2
6924: ST_TO_ADDR
6925: GO 6853
6927: POP
6928: POP
// MC_InsertProduceList ( base , tmp ) ;
6929: LD_VAR 0 3
6933: PPUSH
6934: LD_VAR 0 4
6938: PPUSH
6939: CALL 84333 0 2
// wait ( 3 3$20 ) ;
6943: LD_INT 7000
6945: PPUSH
6946: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6950: LD_ADDR_VAR 0 6
6954: PUSH
6955: LD_INT 124
6957: PUSH
6958: LD_INT 85
6960: PUSH
6961: EMPTY
6962: LIST
6963: LIST
6964: PUSH
6965: LD_INT 90
6967: PUSH
6968: LD_INT 61
6970: PUSH
6971: EMPTY
6972: LIST
6973: LIST
6974: PUSH
6975: LD_INT 69
6977: PUSH
6978: LD_INT 48
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: PUSH
6985: LD_INT 68
6987: PUSH
6988: LD_INT 48
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PUSH
6995: EMPTY
6996: LIST
6997: LIST
6998: LIST
6999: LIST
7000: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ] ] ) diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7001: LD_ADDR_VAR 0 7
7005: PUSH
7006: LD_INT 22
7008: PUSH
7009: LD_INT 2
7011: PUSH
7012: EMPTY
7013: LIST
7014: LIST
7015: PUSH
7016: LD_INT 23
7018: PUSH
7019: LD_INT 2
7021: PUSH
7022: EMPTY
7023: LIST
7024: LIST
7025: PUSH
7026: LD_INT 21
7028: PUSH
7029: LD_INT 2
7031: PUSH
7032: EMPTY
7033: LIST
7034: LIST
7035: PUSH
7036: LD_INT 3
7038: PUSH
7039: LD_INT 2
7041: PUSH
7042: LD_INT 34
7044: PUSH
7045: LD_INT 31
7047: PUSH
7048: EMPTY
7049: LIST
7050: LIST
7051: PUSH
7052: LD_INT 34
7054: PUSH
7055: LD_INT 88
7057: PUSH
7058: EMPTY
7059: LIST
7060: LIST
7061: PUSH
7062: LD_INT 34
7064: PUSH
7065: LD_INT 32
7067: PUSH
7068: EMPTY
7069: LIST
7070: LIST
7071: PUSH
7072: EMPTY
7073: LIST
7074: LIST
7075: LIST
7076: LIST
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: LIST
7086: LIST
7087: PPUSH
7088: CALL_OW 69
7092: PUSH
7093: LD_EXP 82
7097: PUSH
7098: LD_VAR 0 3
7102: ARRAY
7103: PPUSH
7104: LD_INT 2
7106: PUSH
7107: LD_INT 34
7109: PUSH
7110: LD_INT 32
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: PUSH
7117: LD_INT 34
7119: PUSH
7120: LD_INT 88
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: PUSH
7127: EMPTY
7128: LIST
7129: LIST
7130: LIST
7131: PPUSH
7132: CALL_OW 72
7136: DIFF
7137: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7138: LD_INT 0
7140: PPUSH
7141: LD_INT 1
7143: PPUSH
7144: CALL_OW 12
7148: IFFALSE 7298
// begin for i := 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
7150: LD_ADDR_VAR 0 1
7154: PUSH
7155: DOUBLE
7156: LD_INT 1
7158: DEC
7159: ST_TO_ADDR
7160: LD_INT 3
7162: PUSH
7163: LD_INT 4
7165: PUSH
7166: LD_INT 5
7168: PUSH
7169: LD_INT 6
7171: PUSH
7172: EMPTY
7173: LIST
7174: LIST
7175: LIST
7176: LIST
7177: PUSH
7178: LD_OWVAR 67
7182: ARRAY
7183: PUSH
7184: FOR_TO
7185: IFFALSE 7294
// begin uc_side := 2 ;
7187: LD_ADDR_OWVAR 20
7191: PUSH
7192: LD_INT 2
7194: ST_TO_ADDR
// uc_nation := 2 ;
7195: LD_ADDR_OWVAR 21
7199: PUSH
7200: LD_INT 2
7202: ST_TO_ADDR
// InitHc ;
7203: CALL_OW 19
// PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7207: LD_INT 0
7209: PPUSH
7210: LD_INT 15
7212: PUSH
7213: LD_INT 17
7215: PUSH
7216: EMPTY
7217: LIST
7218: LIST
7219: PUSH
7220: LD_INT 1
7222: PPUSH
7223: LD_INT 2
7225: PPUSH
7226: CALL_OW 12
7230: ARRAY
7231: PPUSH
7232: LD_INT 8
7234: PPUSH
7235: CALL_OW 380
// un := CreateHuman ;
7239: LD_ADDR_VAR 0 2
7243: PUSH
7244: CALL_OW 44
7248: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7249: LD_VAR 0 2
7253: PPUSH
7254: LD_INT 4
7256: PPUSH
7257: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
7261: LD_VAR 0 2
7265: PPUSH
7266: LD_INT 23
7268: PPUSH
7269: LD_INT 0
7271: PPUSH
7272: CALL_OW 49
// attackers := attackers union un ;
7276: LD_ADDR_VAR 0 7
7280: PUSH
7281: LD_VAR 0 7
7285: PUSH
7286: LD_VAR 0 2
7290: UNION
7291: ST_TO_ADDR
// end ;
7292: GO 7184
7294: POP
7295: POP
// end else
7296: GO 7456
// begin for i := 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
7298: LD_ADDR_VAR 0 1
7302: PUSH
7303: DOUBLE
7304: LD_INT 1
7306: DEC
7307: ST_TO_ADDR
7308: LD_INT 2
7310: PUSH
7311: LD_INT 3
7313: PUSH
7314: LD_INT 4
7316: PUSH
7317: LD_INT 5
7319: PUSH
7320: EMPTY
7321: LIST
7322: LIST
7323: LIST
7324: LIST
7325: PUSH
7326: LD_OWVAR 67
7330: ARRAY
7331: PUSH
7332: FOR_TO
7333: IFFALSE 7454
// begin uc_side := 2 ;
7335: LD_ADDR_OWVAR 20
7339: PUSH
7340: LD_INT 2
7342: ST_TO_ADDR
// uc_nation := 2 ;
7343: LD_ADDR_OWVAR 21
7347: PUSH
7348: LD_INT 2
7350: ST_TO_ADDR
// InitHc ;
7351: CALL_OW 19
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_flame_thrower ] [ i mod 3 + 1 ] , 100 ) ;
7355: LD_INT 14
7357: PPUSH
7358: LD_INT 3
7360: PPUSH
7361: LD_INT 5
7363: PPUSH
7364: LD_INT 29
7366: PUSH
7367: LD_INT 29
7369: PUSH
7370: LD_INT 26
7372: PUSH
7373: EMPTY
7374: LIST
7375: LIST
7376: LIST
7377: PUSH
7378: LD_VAR 0 1
7382: PUSH
7383: LD_INT 3
7385: MOD
7386: PUSH
7387: LD_INT 1
7389: PLUS
7390: ARRAY
7391: PPUSH
7392: LD_INT 100
7394: PPUSH
7395: CALL 22116 0 5
// un := CreateVehicle ;
7399: LD_ADDR_VAR 0 2
7403: PUSH
7404: CALL_OW 45
7408: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7409: LD_VAR 0 2
7413: PPUSH
7414: LD_INT 4
7416: PPUSH
7417: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
7421: LD_VAR 0 2
7425: PPUSH
7426: LD_INT 23
7428: PPUSH
7429: LD_INT 0
7431: PPUSH
7432: CALL_OW 49
// attackers := attackers union un ;
7436: LD_ADDR_VAR 0 7
7440: PUSH
7441: LD_VAR 0 7
7445: PUSH
7446: LD_VAR 0 2
7450: UNION
7451: ST_TO_ADDR
// end ;
7452: GO 7332
7454: POP
7455: POP
// end ; if not attackers then
7456: LD_VAR 0 7
7460: NOT
7461: IFFALSE 7465
// exit ;
7463: GO 7582
// ar_attackers := attackers ;
7465: LD_ADDR_EXP 12
7469: PUSH
7470: LD_VAR 0 7
7474: ST_TO_ADDR
// p := 0 ;
7475: LD_ADDR_VAR 0 8
7479: PUSH
7480: LD_INT 0
7482: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7483: LD_INT 35
7485: PPUSH
7486: CALL_OW 67
// p := Inc ( p ) ;
7490: LD_ADDR_VAR 0 8
7494: PUSH
7495: LD_VAR 0 8
7499: PPUSH
7500: CALL 56328 0 1
7504: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7505: LD_VAR 0 7
7509: PPUSH
7510: LD_INT 60
7512: PUSH
7513: EMPTY
7514: LIST
7515: PPUSH
7516: CALL_OW 72
7520: NOT
7521: PUSH
7522: LD_VAR 0 8
7526: PUSH
7527: LD_INT 30
7529: GREATER
7530: OR
7531: IFFALSE 7483
// repeat wait ( 0 0$1 ) ;
7533: LD_INT 35
7535: PPUSH
7536: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
7540: LD_ADDR_VAR 0 7
7544: PUSH
7545: LD_VAR 0 7
7549: PPUSH
7550: LD_INT 50
7552: PUSH
7553: EMPTY
7554: LIST
7555: PPUSH
7556: CALL_OW 72
7560: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
7561: LD_VAR 0 7
7565: PPUSH
7566: LD_VAR 0 6
7570: PPUSH
7571: CALL 57571 0 2
// until not attackers ;
7575: LD_VAR 0 7
7579: NOT
7580: IFFALSE 7533
// end ;
7582: PPOPN 8
7584: END
// every 5 5$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) do var i , base , tmp , flags , _target , attackers , un , p ;
7585: LD_INT 1
7587: PPUSH
7588: CALL_OW 302
7592: PUSH
7593: LD_EXP 10
7597: AND
7598: PUSH
7599: LD_EXP 52
7603: PPUSH
7604: LD_INT 22
7606: PPUSH
7607: CALL_OW 308
7611: AND
7612: IFFALSE 8100
7614: GO 7616
7616: DISABLE
7617: LD_INT 0
7619: PPUSH
7620: PPUSH
7621: PPUSH
7622: PPUSH
7623: PPUSH
7624: PPUSH
7625: PPUSH
7626: PPUSH
// begin base := 1 ;
7627: LD_ADDR_VAR 0 2
7631: PUSH
7632: LD_INT 1
7634: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7635: LD_ADDR_VAR 0 4
7639: PUSH
7640: LD_INT 0
7642: PUSH
7643: LD_INT 0
7645: PUSH
7646: LD_INT 0
7648: PUSH
7649: LD_INT 0
7651: PUSH
7652: LD_INT 0
7654: PUSH
7655: LD_INT 0
7657: PUSH
7658: LD_INT 0
7660: PUSH
7661: LD_INT 0
7663: PUSH
7664: LD_INT 1
7666: PUSH
7667: LD_INT 0
7669: PUSH
7670: EMPTY
7671: LIST
7672: LIST
7673: LIST
7674: LIST
7675: LIST
7676: LIST
7677: LIST
7678: LIST
7679: LIST
7680: LIST
7681: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
7682: LD_ADDR_VAR 0 3
7686: PUSH
7687: LD_INT 13
7689: PUSH
7690: LD_INT 1
7692: PUSH
7693: LD_INT 2
7695: PUSH
7696: LD_INT 28
7698: PUSH
7699: EMPTY
7700: LIST
7701: LIST
7702: LIST
7703: LIST
7704: PUSH
7705: LD_INT 13
7707: PUSH
7708: LD_INT 1
7710: PUSH
7711: LD_INT 2
7713: PUSH
7714: LD_INT 27
7716: PUSH
7717: EMPTY
7718: LIST
7719: LIST
7720: LIST
7721: LIST
7722: PUSH
7723: LD_INT 13
7725: PUSH
7726: LD_INT 1
7728: PUSH
7729: LD_INT 2
7731: PUSH
7732: LD_INT 25
7734: PUSH
7735: EMPTY
7736: LIST
7737: LIST
7738: LIST
7739: LIST
7740: PUSH
7741: LD_INT 11
7743: PUSH
7744: LD_INT 2
7746: PUSH
7747: LD_INT 2
7749: PUSH
7750: LD_INT 24
7752: PUSH
7753: EMPTY
7754: LIST
7755: LIST
7756: LIST
7757: LIST
7758: PUSH
7759: LD_INT 11
7761: PUSH
7762: LD_INT 2
7764: PUSH
7765: LD_INT 2
7767: PUSH
7768: LD_INT 24
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: LIST
7775: LIST
7776: PUSH
7777: EMPTY
7778: LIST
7779: LIST
7780: LIST
7781: LIST
7782: LIST
7783: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7784: LD_VAR 0 2
7788: PPUSH
7789: LD_VAR 0 3
7793: PPUSH
7794: CALL 84333 0 2
// wait ( 4 4$20 ) ;
7798: LD_INT 9100
7800: PPUSH
7801: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
7805: LD_ADDR_VAR 0 5
7809: PUSH
7810: LD_INT 119
7812: PUSH
7813: LD_INT 9
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: PUSH
7820: EMPTY
7821: LIST
7822: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7823: LD_ADDR_VAR 0 6
7827: PUSH
7828: LD_EXP 82
7832: PUSH
7833: LD_VAR 0 2
7837: ARRAY
7838: PUSH
7839: LD_EXP 82
7843: PUSH
7844: LD_VAR 0 2
7848: ARRAY
7849: PPUSH
7850: LD_INT 2
7852: PUSH
7853: LD_INT 34
7855: PUSH
7856: LD_INT 32
7858: PUSH
7859: EMPTY
7860: LIST
7861: LIST
7862: PUSH
7863: LD_INT 34
7865: PUSH
7866: LD_INT 88
7868: PUSH
7869: EMPTY
7870: LIST
7871: LIST
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: LIST
7877: PPUSH
7878: CALL_OW 72
7882: DIFF
7883: ST_TO_ADDR
// uc_side := 2 ;
7884: LD_ADDR_OWVAR 20
7888: PUSH
7889: LD_INT 2
7891: ST_TO_ADDR
// uc_nation := 2 ;
7892: LD_ADDR_OWVAR 21
7896: PUSH
7897: LD_INT 2
7899: ST_TO_ADDR
// InitHc ;
7900: CALL_OW 19
// for i := 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
7904: LD_ADDR_VAR 0 1
7908: PUSH
7909: DOUBLE
7910: LD_INT 1
7912: DEC
7913: ST_TO_ADDR
7914: LD_INT 4
7916: PUSH
7917: LD_INT 5
7919: PUSH
7920: LD_INT 6
7922: PUSH
7923: LD_INT 6
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: LIST
7930: LIST
7931: PUSH
7932: LD_OWVAR 67
7936: ARRAY
7937: PUSH
7938: FOR_TO
7939: IFFALSE 8016
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7941: LD_INT 0
7943: PPUSH
7944: LD_INT 15
7946: PUSH
7947: LD_INT 17
7949: PUSH
7950: EMPTY
7951: LIST
7952: LIST
7953: PUSH
7954: LD_INT 1
7956: PPUSH
7957: LD_INT 2
7959: PPUSH
7960: CALL_OW 12
7964: ARRAY
7965: PPUSH
7966: LD_INT 8
7968: PPUSH
7969: CALL_OW 380
// un := CreateHuman ;
7973: LD_ADDR_VAR 0 7
7977: PUSH
7978: CALL_OW 44
7982: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
7983: LD_VAR 0 7
7987: PPUSH
7988: LD_INT 23
7990: PPUSH
7991: LD_INT 0
7993: PPUSH
7994: CALL_OW 49
// attackers := attackers union un ;
7998: LD_ADDR_VAR 0 6
8002: PUSH
8003: LD_VAR 0 6
8007: PUSH
8008: LD_VAR 0 7
8012: UNION
8013: ST_TO_ADDR
// end ;
8014: GO 7938
8016: POP
8017: POP
// p := 0 ;
8018: LD_ADDR_VAR 0 8
8022: PUSH
8023: LD_INT 0
8025: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8026: LD_INT 35
8028: PPUSH
8029: CALL_OW 67
// p := Inc ( p ) ;
8033: LD_ADDR_VAR 0 8
8037: PUSH
8038: LD_VAR 0 8
8042: PPUSH
8043: CALL 56328 0 1
8047: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
8048: LD_VAR 0 6
8052: PPUSH
8053: LD_INT 60
8055: PUSH
8056: EMPTY
8057: LIST
8058: PPUSH
8059: CALL_OW 72
8063: NOT
8064: PUSH
8065: LD_VAR 0 8
8069: PUSH
8070: LD_INT 30
8072: GREATER
8073: OR
8074: IFFALSE 8026
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
8076: LD_VAR 0 2
8080: PPUSH
8081: LD_VAR 0 6
8085: PPUSH
8086: LD_VAR 0 5
8090: PPUSH
8091: LD_VAR 0 4
8095: PPUSH
8096: CALL 84518 0 4
// end ;
8100: PPOPN 8
8102: END
// export function PlaceMines ( area , n ) ; var i , tmp , r ; begin
8103: LD_INT 0
8105: PPUSH
8106: PPUSH
8107: PPUSH
8108: PPUSH
// tmp := AreaToList ( area , 0 ) ;
8109: LD_ADDR_VAR 0 5
8113: PUSH
8114: LD_VAR 0 1
8118: PPUSH
8119: LD_INT 0
8121: PPUSH
8122: CALL_OW 517
8126: ST_TO_ADDR
// if not tmp then
8127: LD_VAR 0 5
8131: NOT
8132: IFFALSE 8136
// exit ;
8134: GO 8386
// arMinesList := arMinesList diff 0 ;
8136: LD_ADDR_EXP 60
8140: PUSH
8141: LD_EXP 60
8145: PUSH
8146: LD_INT 0
8148: DIFF
8149: ST_TO_ADDR
// for i := 1 to n do
8150: LD_ADDR_VAR 0 4
8154: PUSH
8155: DOUBLE
8156: LD_INT 1
8158: DEC
8159: ST_TO_ADDR
8160: LD_VAR 0 2
8164: PUSH
8165: FOR_TO
8166: IFFALSE 8384
// begin r := rand ( 1 , tmp [ 1 ] ) ;
8168: LD_ADDR_VAR 0 6
8172: PUSH
8173: LD_INT 1
8175: PPUSH
8176: LD_VAR 0 5
8180: PUSH
8181: LD_INT 1
8183: ARRAY
8184: PPUSH
8185: CALL_OW 12
8189: ST_TO_ADDR
// PlaceMine ( tmp [ 1 ] [ r ] , tmp [ 2 ] [ r ] , 2 , 0 ) ;
8190: LD_VAR 0 5
8194: PUSH
8195: LD_INT 1
8197: ARRAY
8198: PUSH
8199: LD_VAR 0 6
8203: ARRAY
8204: PPUSH
8205: LD_VAR 0 5
8209: PUSH
8210: LD_INT 2
8212: ARRAY
8213: PUSH
8214: LD_VAR 0 6
8218: ARRAY
8219: PPUSH
8220: LD_INT 2
8222: PPUSH
8223: LD_INT 0
8225: PPUSH
8226: CALL_OW 454
// arMinesList := Insert ( arMinesList , arMinesList + 1 , tmp [ 1 ] [ r ] ) ;
8230: LD_ADDR_EXP 60
8234: PUSH
8235: LD_EXP 60
8239: PPUSH
8240: LD_EXP 60
8244: PUSH
8245: LD_INT 1
8247: PLUS
8248: PPUSH
8249: LD_VAR 0 5
8253: PUSH
8254: LD_INT 1
8256: ARRAY
8257: PUSH
8258: LD_VAR 0 6
8262: ARRAY
8263: PPUSH
8264: CALL_OW 2
8268: ST_TO_ADDR
// arMinesList := Insert ( arMinesList , arMinesList + 1 , tmp [ 2 ] [ r ] ) ;
8269: LD_ADDR_EXP 60
8273: PUSH
8274: LD_EXP 60
8278: PPUSH
8279: LD_EXP 60
8283: PUSH
8284: LD_INT 1
8286: PLUS
8287: PPUSH
8288: LD_VAR 0 5
8292: PUSH
8293: LD_INT 2
8295: ARRAY
8296: PUSH
8297: LD_VAR 0 6
8301: ARRAY
8302: PPUSH
8303: CALL_OW 2
8307: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , Delete ( tmp [ 1 ] , r ) ) ;
8308: LD_ADDR_VAR 0 5
8312: PUSH
8313: LD_VAR 0 5
8317: PPUSH
8318: LD_INT 1
8320: PPUSH
8321: LD_VAR 0 5
8325: PUSH
8326: LD_INT 1
8328: ARRAY
8329: PPUSH
8330: LD_VAR 0 6
8334: PPUSH
8335: CALL_OW 3
8339: PPUSH
8340: CALL_OW 1
8344: ST_TO_ADDR
// tmp := Replace ( tmp , 2 , Delete ( tmp [ 2 ] , r ) ) ;
8345: LD_ADDR_VAR 0 5
8349: PUSH
8350: LD_VAR 0 5
8354: PPUSH
8355: LD_INT 2
8357: PPUSH
8358: LD_VAR 0 5
8362: PUSH
8363: LD_INT 2
8365: ARRAY
8366: PPUSH
8367: LD_VAR 0 6
8371: PPUSH
8372: CALL_OW 3
8376: PPUSH
8377: CALL_OW 1
8381: ST_TO_ADDR
// end ;
8382: GO 8165
8384: POP
8385: POP
// end ;
8386: LD_VAR 0 3
8390: RET
// export arMinesList ; every 0 0$01 + 0 0$3 trigger arMinesList do var i , p , tmp , side ;
8391: LD_EXP 60
8395: IFFALSE 8624
8397: GO 8399
8399: DISABLE
8400: LD_INT 0
8402: PPUSH
8403: PPUSH
8404: PPUSH
8405: PPUSH
// begin enable ;
8406: ENABLE
// p := 1 ;
8407: LD_ADDR_VAR 0 2
8411: PUSH
8412: LD_INT 1
8414: ST_TO_ADDR
// for i := 1 to Count ( arMinesList ) div 2 do
8415: LD_ADDR_VAR 0 1
8419: PUSH
8420: DOUBLE
8421: LD_INT 1
8423: DEC
8424: ST_TO_ADDR
8425: LD_EXP 60
8429: PPUSH
8430: CALL 19378 0 1
8434: PUSH
8435: LD_INT 2
8437: DIV
8438: PUSH
8439: FOR_TO
8440: IFFALSE 8622
// begin tmp := HexInfo ( arMinesList [ p ] , arMinesList [ p + 1 ] ) ;
8442: LD_ADDR_VAR 0 3
8446: PUSH
8447: LD_EXP 60
8451: PUSH
8452: LD_VAR 0 2
8456: ARRAY
8457: PPUSH
8458: LD_EXP 60
8462: PUSH
8463: LD_VAR 0 2
8467: PUSH
8468: LD_INT 1
8470: PLUS
8471: ARRAY
8472: PPUSH
8473: CALL_OW 428
8477: ST_TO_ADDR
// if tmp then
8478: LD_VAR 0 3
8482: IFFALSE 8606
// begin side := GetSide ( tmp ) ;
8484: LD_ADDR_VAR 0 4
8488: PUSH
8489: LD_VAR 0 3
8493: PPUSH
8494: CALL_OW 255
8498: ST_TO_ADDR
// if side <> 2 and side > 0 then
8499: LD_VAR 0 4
8503: PUSH
8504: LD_INT 2
8506: NONEQUAL
8507: PUSH
8508: LD_VAR 0 4
8512: PUSH
8513: LD_INT 0
8515: GREATER
8516: AND
8517: IFFALSE 8606
// begin LaunchMineAtPos ( arMinesList [ p ] , arMinesList [ p + 1 ] , 2 ) ;
8519: LD_EXP 60
8523: PUSH
8524: LD_VAR 0 2
8528: ARRAY
8529: PPUSH
8530: LD_EXP 60
8534: PUSH
8535: LD_VAR 0 2
8539: PUSH
8540: LD_INT 1
8542: PLUS
8543: ARRAY
8544: PPUSH
8545: LD_INT 2
8547: PPUSH
8548: CALL_OW 456
// arMinesList := Delete ( arMinesList , p ) ;
8552: LD_ADDR_EXP 60
8556: PUSH
8557: LD_EXP 60
8561: PPUSH
8562: LD_VAR 0 2
8566: PPUSH
8567: CALL_OW 3
8571: ST_TO_ADDR
// arMinesList := Delete ( arMinesList , p ) ;
8572: LD_ADDR_EXP 60
8576: PUSH
8577: LD_EXP 60
8581: PPUSH
8582: LD_VAR 0 2
8586: PPUSH
8587: CALL_OW 3
8591: ST_TO_ADDR
// p := p - 2 ;
8592: LD_ADDR_VAR 0 2
8596: PUSH
8597: LD_VAR 0 2
8601: PUSH
8602: LD_INT 2
8604: MINUS
8605: ST_TO_ADDR
// end ; end ; p := p + 2 ;
8606: LD_ADDR_VAR 0 2
8610: PUSH
8611: LD_VAR 0 2
8615: PUSH
8616: LD_INT 2
8618: PLUS
8619: ST_TO_ADDR
// end ;
8620: GO 8439
8622: POP
8623: POP
// end ; end_of_file
8624: PPOPN 4
8626: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
8627: LD_INT 0
8629: PPUSH
8630: PPUSH
8631: PPUSH
8632: PPUSH
8633: PPUSH
8634: PPUSH
// uc_side := 1 ;
8635: LD_ADDR_OWVAR 20
8639: PUSH
8640: LD_INT 1
8642: ST_TO_ADDR
// uc_nation := 1 ;
8643: LD_ADDR_OWVAR 21
8647: PUSH
8648: LD_INT 1
8650: ST_TO_ADDR
// InitHc ;
8651: CALL_OW 19
// InitVc ;
8655: CALL_OW 20
// tmp := [ ] ;
8659: LD_ADDR_VAR 0 3
8663: PUSH
8664: EMPTY
8665: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
8666: LD_ADDR_VAR 0 2
8670: PUSH
8671: DOUBLE
8672: LD_INT 1
8674: DEC
8675: ST_TO_ADDR
8676: LD_INT 6
8678: PUSH
8679: LD_INT 8
8681: PUSH
8682: LD_INT 10
8684: PUSH
8685: LD_INT 10
8687: PUSH
8688: EMPTY
8689: LIST
8690: LIST
8691: LIST
8692: LIST
8693: PUSH
8694: LD_OWVAR 67
8698: ARRAY
8699: PUSH
8700: FOR_TO
8701: IFFALSE 8991
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
8703: LD_ADDR_VAR 0 5
8707: PUSH
8708: LD_INT 2
8710: PUSH
8711: LD_INT 4
8713: PUSH
8714: LD_INT 5
8716: PUSH
8717: EMPTY
8718: LIST
8719: LIST
8720: LIST
8721: PUSH
8722: LD_INT 1
8724: PPUSH
8725: LD_INT 3
8727: PPUSH
8728: CALL_OW 12
8732: ARRAY
8733: ST_TO_ADDR
// case chassis of us_medium_wheeled :
8734: LD_VAR 0 5
8738: PUSH
8739: LD_INT 2
8741: DOUBLE
8742: EQUAL
8743: IFTRUE 8747
8745: GO 8781
8747: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
8748: LD_ADDR_VAR 0 6
8752: PUSH
8753: LD_INT 9
8755: PUSH
8756: LD_INT 5
8758: PUSH
8759: LD_INT 7
8761: PUSH
8762: EMPTY
8763: LIST
8764: LIST
8765: LIST
8766: PUSH
8767: LD_INT 1
8769: PPUSH
8770: LD_INT 3
8772: PPUSH
8773: CALL_OW 12
8777: ARRAY
8778: ST_TO_ADDR
8779: GO 8870
8781: LD_INT 4
8783: DOUBLE
8784: EQUAL
8785: IFTRUE 8789
8787: GO 8827
8789: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
8790: LD_ADDR_VAR 0 6
8794: PUSH
8795: LD_INT 9
8797: PUSH
8798: LD_INT 6
8800: PUSH
8801: LD_INT 6
8803: PUSH
8804: LD_INT 7
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: LIST
8811: LIST
8812: PUSH
8813: LD_INT 1
8815: PPUSH
8816: LD_INT 4
8818: PPUSH
8819: CALL_OW 12
8823: ARRAY
8824: ST_TO_ADDR
8825: GO 8870
8827: LD_INT 5
8829: DOUBLE
8830: EQUAL
8831: IFTRUE 8835
8833: GO 8869
8835: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
8836: LD_ADDR_VAR 0 6
8840: PUSH
8841: LD_INT 9
8843: PUSH
8844: LD_INT 6
8846: PUSH
8847: LD_INT 7
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: LIST
8854: PUSH
8855: LD_INT 1
8857: PPUSH
8858: LD_INT 3
8860: PPUSH
8861: CALL_OW 12
8865: ARRAY
8866: ST_TO_ADDR
8867: GO 8870
8869: POP
// uc_side := 1 ;
8870: LD_ADDR_OWVAR 20
8874: PUSH
8875: LD_INT 1
8877: ST_TO_ADDR
// uc_nation := 1 ;
8878: LD_ADDR_OWVAR 21
8882: PUSH
8883: LD_INT 1
8885: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
8886: LD_VAR 0 5
8890: PPUSH
8891: LD_INT 1
8893: PUSH
8894: LD_INT 3
8896: PUSH
8897: EMPTY
8898: LIST
8899: LIST
8900: PUSH
8901: LD_INT 1
8903: PPUSH
8904: LD_INT 2
8906: PPUSH
8907: CALL_OW 12
8911: ARRAY
8912: PPUSH
8913: LD_INT 3
8915: PPUSH
8916: LD_VAR 0 6
8920: PPUSH
8921: LD_INT 70
8923: PPUSH
8924: LD_INT 90
8926: PPUSH
8927: CALL_OW 12
8931: PPUSH
8932: CALL 22116 0 5
// veh := CreateVehicle ;
8936: LD_ADDR_VAR 0 4
8940: PUSH
8941: CALL_OW 45
8945: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
8946: LD_VAR 0 4
8950: PPUSH
8951: LD_INT 2
8953: PPUSH
8954: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
8958: LD_VAR 0 4
8962: PPUSH
8963: LD_INT 17
8965: PPUSH
8966: LD_INT 0
8968: PPUSH
8969: CALL_OW 49
// tmp := tmp ^ veh ;
8973: LD_ADDR_VAR 0 3
8977: PUSH
8978: LD_VAR 0 3
8982: PUSH
8983: LD_VAR 0 4
8987: ADD
8988: ST_TO_ADDR
// end ;
8989: GO 8700
8991: POP
8992: POP
// if not tmp then
8993: LD_VAR 0 3
8997: NOT
8998: IFFALSE 9002
// exit ;
9000: GO 9111
// if not first_powell_attack then
9002: LD_EXP 13
9006: NOT
9007: IFFALSE 9017
// first_powell_attack := true ;
9009: LD_ADDR_EXP 13
9013: PUSH
9014: LD_INT 1
9016: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
9017: LD_INT 70
9019: PPUSH
9020: CALL_OW 67
// for i in tmp do
9024: LD_ADDR_VAR 0 2
9028: PUSH
9029: LD_VAR 0 3
9033: PUSH
9034: FOR_IN
9035: IFFALSE 9102
// if IsOk ( i ) then
9037: LD_VAR 0 2
9041: PPUSH
9042: CALL_OW 302
9046: IFFALSE 9084
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
9048: LD_VAR 0 2
9052: PPUSH
9053: LD_INT 81
9055: PUSH
9056: LD_INT 1
9058: PUSH
9059: EMPTY
9060: LIST
9061: LIST
9062: PPUSH
9063: CALL_OW 69
9067: PPUSH
9068: LD_VAR 0 2
9072: PPUSH
9073: CALL_OW 74
9077: PPUSH
9078: CALL_OW 115
9082: GO 9100
// tmp := tmp diff i ;
9084: LD_ADDR_VAR 0 3
9088: PUSH
9089: LD_VAR 0 3
9093: PUSH
9094: LD_VAR 0 2
9098: DIFF
9099: ST_TO_ADDR
9100: GO 9034
9102: POP
9103: POP
// until not tmp ;
9104: LD_VAR 0 3
9108: NOT
9109: IFFALSE 9017
// end ;
9111: LD_VAR 0 1
9115: RET
// export function TryToStoleArtifact ( artifact ) ; var veh ; begin
9116: LD_INT 0
9118: PPUSH
9119: PPUSH
// uc_side := 1 ;
9120: LD_ADDR_OWVAR 20
9124: PUSH
9125: LD_INT 1
9127: ST_TO_ADDR
// uc_nation := 1 ;
9128: LD_ADDR_OWVAR 21
9132: PUSH
9133: LD_INT 1
9135: ST_TO_ADDR
// InitHc ;
9136: CALL_OW 19
// InitVc ;
9140: CALL_OW 20
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
9144: LD_INT 5
9146: PPUSH
9147: LD_INT 3
9149: PPUSH
9150: LD_INT 3
9152: PPUSH
9153: LD_INT 12
9155: PPUSH
9156: LD_INT 100
9158: PPUSH
9159: CALL 22116 0 5
// veh := CreateVehicle ;
9163: LD_ADDR_VAR 0 3
9167: PUSH
9168: CALL_OW 45
9172: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
9173: LD_VAR 0 3
9177: PPUSH
9178: LD_INT 2
9180: PPUSH
9181: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
9185: LD_VAR 0 3
9189: PPUSH
9190: LD_INT 17
9192: PPUSH
9193: LD_INT 0
9195: PPUSH
9196: CALL_OW 49
// ComGet ( veh , artifact [ 1 ] , artifact [ 2 ] ) ;
9200: LD_VAR 0 3
9204: PPUSH
9205: LD_VAR 0 1
9209: PUSH
9210: LD_INT 1
9212: ARRAY
9213: PPUSH
9214: LD_VAR 0 1
9218: PUSH
9219: LD_INT 2
9221: ARRAY
9222: PPUSH
9223: CALL_OW 160
// AddComMoveXY ( veh , 59 , 2 ) ;
9227: LD_VAR 0 3
9231: PPUSH
9232: LD_INT 59
9234: PPUSH
9235: LD_INT 2
9237: PPUSH
9238: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
9242: LD_INT 35
9244: PPUSH
9245: CALL_OW 67
// if not IsOk ( veh ) then
9249: LD_VAR 0 3
9253: PPUSH
9254: CALL_OW 302
9258: NOT
9259: IFFALSE 9263
// exit ;
9261: GO 9317
// until IsAt ( veh , 59 , 2 ) ;
9263: LD_VAR 0 3
9267: PPUSH
9268: LD_INT 59
9270: PPUSH
9271: LD_INT 2
9273: PPUSH
9274: CALL_OW 307
9278: IFFALSE 9242
// RemoveUnit ( veh ) ;
9280: LD_VAR 0 3
9284: PPUSH
9285: CALL_OW 64
// if GetCargo ( veh , mat_artifact ) then
9289: LD_VAR 0 3
9293: PPUSH
9294: LD_INT 4
9296: PPUSH
9297: CALL_OW 289
9301: IFFALSE 9317
// begin wait ( 0 0$2 ) ;
9303: LD_INT 70
9305: PPUSH
9306: CALL_OW 67
// YouLost ( Artifact ) ;
9310: LD_STRING Artifact
9312: PPUSH
9313: CALL_OW 104
// end ; end ; end_of_file
9317: LD_VAR 0 2
9321: RET
// export function Action ; var tmp , i , un ; begin
9322: LD_INT 0
9324: PPUSH
9325: PPUSH
9326: PPUSH
9327: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
9328: LD_INT 68
9330: PPUSH
9331: LD_INT 39
9333: PPUSH
9334: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
9338: LD_ADDR_VAR 0 2
9342: PUSH
9343: LD_INT 22
9345: PUSH
9346: LD_INT 7
9348: PUSH
9349: EMPTY
9350: LIST
9351: LIST
9352: PPUSH
9353: CALL_OW 69
9357: ST_TO_ADDR
// InGameOn ;
9358: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
9362: LD_VAR 0 2
9366: PPUSH
9367: LD_INT 71
9369: PPUSH
9370: LD_INT 49
9372: PPUSH
9373: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
9377: LD_INT 35
9379: PPUSH
9380: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
9384: LD_INT 7
9386: PPUSH
9387: LD_INT 71
9389: PPUSH
9390: LD_INT 51
9392: PPUSH
9393: CALL_OW 293
9397: IFFALSE 9377
// DialogueOn ;
9399: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
9403: LD_EXP 17
9407: PPUSH
9408: LD_STRING D1-JMM-1
9410: PPUSH
9411: CALL_OW 88
// if Joan then
9415: LD_EXP 32
9419: IFFALSE 9433
// Say ( Joan , D1-Joan-1 ) ;
9421: LD_EXP 32
9425: PPUSH
9426: LD_STRING D1-Joan-1
9428: PPUSH
9429: CALL_OW 88
// if Lisa then
9433: LD_EXP 19
9437: IFFALSE 9451
// Say ( Lisa , D1-Lisa-1 ) ;
9439: LD_EXP 19
9443: PPUSH
9444: LD_STRING D1-Lisa-1
9446: PPUSH
9447: CALL_OW 88
// if Joan or Lisa then
9451: LD_EXP 32
9455: PUSH
9456: LD_EXP 19
9460: OR
9461: IFFALSE 9475
// Say ( JMM , D1-JMM-2 ) ;
9463: LD_EXP 17
9467: PPUSH
9468: LD_STRING D1-JMM-2
9470: PPUSH
9471: CALL_OW 88
// DialogueOff ;
9475: CALL_OW 7
// InGameOff ;
9479: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
9483: LD_INT 71
9485: PPUSH
9486: LD_INT 50
9488: PPUSH
9489: LD_INT 7
9491: PPUSH
9492: LD_INT 30
9494: NEG
9495: PPUSH
9496: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
9500: LD_INT 71
9502: PPUSH
9503: LD_INT 50
9505: PPUSH
9506: LD_INT 7
9508: PPUSH
9509: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
9513: LD_STRING M1
9515: PPUSH
9516: CALL_OW 337
// SaveForQuickRestart ;
9520: CALL_OW 22
// repeat wait ( 0 0$1 ) ;
9524: LD_INT 35
9526: PPUSH
9527: CALL_OW 67
// until freedom or tick > 1 1$00 ;
9531: LD_EXP 3
9535: PUSH
9536: LD_OWVAR 1
9540: PUSH
9541: LD_INT 2100
9543: GREATER
9544: OR
9545: IFFALSE 9524
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
9547: LD_INT 350
9549: PPUSH
9550: LD_INT 700
9552: PPUSH
9553: CALL_OW 12
9557: PPUSH
9558: CALL_OW 67
// PrepareGossudarov ;
9562: CALL 1943 0 0
// repeat wait ( 0 0$1 ) ;
9566: LD_INT 35
9568: PPUSH
9569: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
9573: LD_INT 22
9575: PUSH
9576: LD_INT 6
9578: PUSH
9579: EMPTY
9580: LIST
9581: LIST
9582: PUSH
9583: LD_INT 3
9585: PUSH
9586: LD_INT 24
9588: PUSH
9589: LD_INT 1000
9591: PUSH
9592: EMPTY
9593: LIST
9594: LIST
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: PUSH
9600: EMPTY
9601: LIST
9602: LIST
9603: PPUSH
9604: CALL_OW 69
9608: PUSH
9609: LD_INT 7
9611: PPUSH
9612: LD_EXP 35
9616: PPUSH
9617: CALL_OW 292
9621: OR
9622: IFFALSE 9566
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
9624: LD_ADDR_VAR 0 2
9628: PUSH
9629: LD_INT 22
9631: PUSH
9632: LD_INT 6
9634: PUSH
9635: EMPTY
9636: LIST
9637: LIST
9638: PPUSH
9639: CALL_OW 69
9643: ST_TO_ADDR
// for i in tmp do
9644: LD_ADDR_VAR 0 3
9648: PUSH
9649: LD_VAR 0 2
9653: PUSH
9654: FOR_IN
9655: IFFALSE 9671
// SetSide ( i , 7 ) ;
9657: LD_VAR 0 3
9661: PPUSH
9662: LD_INT 7
9664: PPUSH
9665: CALL_OW 235
9669: GO 9654
9671: POP
9672: POP
// DialogueOn ;
9673: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
9677: LD_EXP 17
9681: PUSH
9682: LD_EXP 18
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: PPUSH
9691: LD_EXP 35
9695: PPUSH
9696: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
9700: LD_EXP 35
9704: PPUSH
9705: CALL_OW 87
// if not Roth then
9709: LD_EXP 18
9713: NOT
9714: IFFALSE 9806
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9716: LD_VAR 0 2
9720: PPUSH
9721: LD_INT 3
9723: PUSH
9724: LD_INT 24
9726: PUSH
9727: LD_INT 1000
9729: PUSH
9730: EMPTY
9731: LIST
9732: LIST
9733: PUSH
9734: EMPTY
9735: LIST
9736: LIST
9737: PPUSH
9738: CALL_OW 72
9742: IFFALSE 9756
// Say ( JMM , D2-JMM-1 ) ;
9744: LD_EXP 17
9748: PPUSH
9749: LD_STRING D2-JMM-1
9751: PPUSH
9752: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
9756: LD_EXP 17
9760: PPUSH
9761: LD_STRING D2-JMM-1b
9763: PPUSH
9764: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
9768: LD_EXP 35
9772: PPUSH
9773: LD_STRING D2-Gos-1
9775: PPUSH
9776: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
9780: LD_EXP 17
9784: PPUSH
9785: LD_STRING D2-JMM-2
9787: PPUSH
9788: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
9792: LD_EXP 35
9796: PPUSH
9797: LD_STRING D2-Gos-2
9799: PPUSH
9800: CALL_OW 88
// end else
9804: GO 9958
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9806: LD_VAR 0 2
9810: PPUSH
9811: LD_INT 3
9813: PUSH
9814: LD_INT 24
9816: PUSH
9817: LD_INT 1000
9819: PUSH
9820: EMPTY
9821: LIST
9822: LIST
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: PPUSH
9828: CALL_OW 72
9832: IFFALSE 9858
// begin Say ( Roth , D2-Roth-2 ) ;
9834: LD_EXP 18
9838: PPUSH
9839: LD_STRING D2-Roth-2
9841: PPUSH
9842: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
9846: LD_EXP 17
9850: PPUSH
9851: LD_STRING D2-JMM-1a
9853: PPUSH
9854: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
9858: LD_EXP 18
9862: PPUSH
9863: LD_STRING D2-Roth-2a
9865: PPUSH
9866: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
9870: LD_EXP 18
9874: PPUSH
9875: LD_STRING D2-Roth-2b
9877: PPUSH
9878: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
9882: LD_EXP 17
9886: PPUSH
9887: LD_STRING D2-JMM-3
9889: PPUSH
9890: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9894: LD_VAR 0 2
9898: PPUSH
9899: LD_INT 3
9901: PUSH
9902: LD_INT 24
9904: PUSH
9905: LD_INT 1000
9907: PUSH
9908: EMPTY
9909: LIST
9910: LIST
9911: PUSH
9912: EMPTY
9913: LIST
9914: LIST
9915: PPUSH
9916: CALL_OW 72
9920: IFFALSE 9958
// begin Say ( Gossudarov , D2-Gos-3 ) ;
9922: LD_EXP 35
9926: PPUSH
9927: LD_STRING D2-Gos-3
9929: PPUSH
9930: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
9934: LD_EXP 17
9938: PPUSH
9939: LD_STRING D2-JMM-4
9941: PPUSH
9942: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
9946: LD_EXP 35
9950: PPUSH
9951: LD_STRING D2-Gos-4
9953: PPUSH
9954: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
9958: LD_EXP 17
9962: PPUSH
9963: LD_STRING D2-JMM-5
9965: PPUSH
9966: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
9970: LD_EXP 35
9974: PPUSH
9975: LD_STRING D2-Gos-5
9977: PPUSH
9978: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
9982: LD_EXP 17
9986: PPUSH
9987: LD_STRING D2-JMM-6
9989: PPUSH
9990: CALL_OW 88
// DialogueOff ;
9994: CALL_OW 7
// wait ( 0 0$2 ) ;
9998: LD_INT 70
10000: PPUSH
10001: CALL_OW 67
// if Kirilenkova then
10005: LD_EXP 36
10009: IFFALSE 10023
// Say ( Kirilenkova , D3-Kir-1 ) ;
10011: LD_EXP 36
10015: PPUSH
10016: LD_STRING D3-Kir-1
10018: PPUSH
10019: CALL_OW 88
// gossudarov_arrive := true ;
10023: LD_ADDR_EXP 4
10027: PUSH
10028: LD_INT 1
10030: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10031: LD_INT 35
10033: PPUSH
10034: CALL_OW 67
// until ru_lab_builded ;
10038: LD_EXP 5
10042: IFFALSE 10031
// DialogueOn ;
10044: CALL_OW 6
// if Kirilenkova then
10048: LD_EXP 36
10052: IFFALSE 10068
// Say ( Kirilenkova , D3a-Kir-1 ) else
10054: LD_EXP 36
10058: PPUSH
10059: LD_STRING D3a-Kir-1
10061: PPUSH
10062: CALL_OW 88
10066: GO 10090
// begin un := SciRu ;
10068: LD_ADDR_VAR 0 4
10072: PUSH
10073: CALL 15630 0 0
10077: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
10078: LD_VAR 0 4
10082: PPUSH
10083: LD_STRING D3a-Sci1-1
10085: PPUSH
10086: CALL_OW 88
// end ; if Kirilenkova or un then
10090: LD_EXP 36
10094: PUSH
10095: LD_VAR 0 4
10099: OR
10100: IFFALSE 10114
// Say ( JMM , D3a-JMM-1 ) ;
10102: LD_EXP 17
10106: PPUSH
10107: LD_STRING D3a-JMM-1
10109: PPUSH
10110: CALL_OW 88
// DialogueOff ;
10114: CALL_OW 7
// end ;
10118: LD_VAR 0 1
10122: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
10123: LD_EXP 4
10127: PUSH
10128: LD_INT 22
10130: PUSH
10131: LD_INT 7
10133: PUSH
10134: EMPTY
10135: LIST
10136: LIST
10137: PUSH
10138: LD_INT 2
10140: PUSH
10141: LD_INT 25
10143: PUSH
10144: LD_INT 1
10146: PUSH
10147: EMPTY
10148: LIST
10149: LIST
10150: PUSH
10151: LD_INT 25
10153: PUSH
10154: LD_INT 2
10156: PUSH
10157: EMPTY
10158: LIST
10159: LIST
10160: PUSH
10161: LD_INT 25
10163: PUSH
10164: LD_INT 3
10166: PUSH
10167: EMPTY
10168: LIST
10169: LIST
10170: PUSH
10171: LD_INT 25
10173: PUSH
10174: LD_INT 4
10176: PUSH
10177: EMPTY
10178: LIST
10179: LIST
10180: PUSH
10181: LD_INT 25
10183: PUSH
10184: LD_INT 5
10186: PUSH
10187: EMPTY
10188: LIST
10189: LIST
10190: PUSH
10191: LD_INT 25
10193: PUSH
10194: LD_INT 8
10196: PUSH
10197: EMPTY
10198: LIST
10199: LIST
10200: PUSH
10201: LD_INT 25
10203: PUSH
10204: LD_INT 9
10206: PUSH
10207: EMPTY
10208: LIST
10209: LIST
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: LIST
10215: LIST
10216: LIST
10217: LIST
10218: LIST
10219: LIST
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: PPUSH
10225: CALL_OW 69
10229: PUSH
10230: LD_INT 7
10232: LESS
10233: AND
10234: IFFALSE 10246
10236: GO 10238
10238: DISABLE
// YouLost ( TooMany ) ;
10239: LD_STRING TooMany
10241: PPUSH
10242: CALL_OW 104
10246: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
10247: LD_EXP 35
10251: PPUSH
10252: CALL_OW 255
10256: PUSH
10257: LD_INT 7
10259: EQUAL
10260: IFFALSE 10477
10262: GO 10264
10264: DISABLE
10265: LD_INT 0
10267: PPUSH
10268: PPUSH
10269: PPUSH
// begin uc_side := 3 ;
10270: LD_ADDR_OWVAR 20
10274: PUSH
10275: LD_INT 3
10277: ST_TO_ADDR
// uc_nation := 3 ;
10278: LD_ADDR_OWVAR 21
10282: PUSH
10283: LD_INT 3
10285: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
10286: LD_INT 21
10288: PPUSH
10289: LD_INT 3
10291: PPUSH
10292: LD_INT 3
10294: PPUSH
10295: LD_INT 42
10297: PPUSH
10298: LD_INT 100
10300: PPUSH
10301: CALL 22116 0 5
// un := CreateVehicle ;
10305: LD_ADDR_VAR 0 3
10309: PUSH
10310: CALL_OW 45
10314: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
10315: LD_VAR 0 3
10319: PPUSH
10320: LD_INT 15
10322: PPUSH
10323: LD_INT 0
10325: PPUSH
10326: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
10330: LD_VAR 0 3
10334: PPUSH
10335: LD_INT 67
10337: PPUSH
10338: LD_INT 45
10340: PPUSH
10341: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
10345: LD_VAR 0 3
10349: PPUSH
10350: LD_INT 70
10352: PPUSH
10353: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
10357: LD_VAR 0 3
10361: PPUSH
10362: LD_INT 69
10364: PPUSH
10365: LD_INT 18
10367: PPUSH
10368: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
10372: LD_VAR 0 3
10376: PPUSH
10377: LD_INT 60
10379: PPUSH
10380: LD_INT 3
10382: PPUSH
10383: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10387: LD_INT 35
10389: PPUSH
10390: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
10394: LD_VAR 0 3
10398: PPUSH
10399: CALL_OW 302
10403: NOT
10404: PUSH
10405: LD_VAR 0 3
10409: PPUSH
10410: LD_INT 17
10412: PPUSH
10413: CALL_OW 308
10417: OR
10418: PUSH
10419: LD_VAR 0 3
10423: PPUSH
10424: LD_INT 60
10426: PPUSH
10427: LD_INT 3
10429: PPUSH
10430: CALL_OW 307
10434: OR
10435: IFFALSE 10387
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
10437: LD_VAR 0 3
10441: PPUSH
10442: LD_INT 17
10444: PPUSH
10445: CALL_OW 308
10449: PUSH
10450: LD_VAR 0 3
10454: PPUSH
10455: LD_INT 60
10457: PPUSH
10458: LD_INT 3
10460: PPUSH
10461: CALL_OW 307
10465: OR
10466: IFFALSE 10477
// RemoveUnit ( un ) ;
10468: LD_VAR 0 3
10472: PPUSH
10473: CALL_OW 64
// end ;
10477: PPOPN 3
10479: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
10480: LD_EXP 4
10484: IFFALSE 10726
10486: GO 10488
10488: DISABLE
10489: LD_INT 0
10491: PPUSH
10492: PPUSH
10493: PPUSH
// begin repeat wait ( 0 0$2 ) ;
10494: LD_INT 70
10496: PPUSH
10497: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
10501: LD_ADDR_VAR 0 3
10505: PUSH
10506: LD_INT 22
10508: PUSH
10509: LD_INT 7
10511: PUSH
10512: EMPTY
10513: LIST
10514: LIST
10515: PUSH
10516: LD_INT 101
10518: PUSH
10519: LD_INT 3
10521: PUSH
10522: EMPTY
10523: LIST
10524: LIST
10525: PUSH
10526: EMPTY
10527: LIST
10528: LIST
10529: PPUSH
10530: CALL_OW 69
10534: ST_TO_ADDR
// until tmp ;
10535: LD_VAR 0 3
10539: IFFALSE 10494
// un := NearestUnitToUnit ( tmp , JMM ) ;
10541: LD_ADDR_VAR 0 2
10545: PUSH
10546: LD_VAR 0 3
10550: PPUSH
10551: LD_EXP 17
10555: PPUSH
10556: CALL_OW 74
10560: ST_TO_ADDR
// player_spotted := true ;
10561: LD_ADDR_EXP 7
10565: PUSH
10566: LD_INT 1
10568: ST_TO_ADDR
// tmp := SciRu ;
10569: LD_ADDR_VAR 0 3
10573: PUSH
10574: CALL 15630 0 0
10578: ST_TO_ADDR
// if not tmp then
10579: LD_VAR 0 3
10583: NOT
10584: IFFALSE 10596
// tmp := SolRu ;
10586: LD_ADDR_VAR 0 3
10590: PUSH
10591: CALL 15777 0 0
10595: ST_TO_ADDR
// DialogueOn ;
10596: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
10600: LD_VAR 0 2
10604: PPUSH
10605: CALL_OW 250
10609: PPUSH
10610: LD_VAR 0 2
10614: PPUSH
10615: CALL_OW 251
10619: PPUSH
10620: LD_INT 7
10622: PPUSH
10623: LD_INT 8
10625: NEG
10626: PPUSH
10627: CALL_OW 330
// CenterNowOnUnits ( un ) ;
10631: LD_VAR 0 2
10635: PPUSH
10636: CALL_OW 87
// if tmp then
10640: LD_VAR 0 3
10644: IFFALSE 10658
// Say ( tmp , D4-RSci1-1 ) ;
10646: LD_VAR 0 3
10650: PPUSH
10651: LD_STRING D4-RSci1-1
10653: PPUSH
10654: CALL_OW 88
// if Gossudarov then
10658: LD_EXP 35
10662: IFFALSE 10688
// begin Say ( Gossudarov , D4-Gos-1 ) ;
10664: LD_EXP 35
10668: PPUSH
10669: LD_STRING D4-Gos-1
10671: PPUSH
10672: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
10676: LD_EXP 17
10680: PPUSH
10681: LD_STRING D4-JMM-1
10683: PPUSH
10684: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
10688: LD_VAR 0 2
10692: PPUSH
10693: CALL_OW 250
10697: PPUSH
10698: LD_VAR 0 2
10702: PPUSH
10703: CALL_OW 251
10707: PPUSH
10708: LD_INT 7
10710: PPUSH
10711: CALL_OW 331
// DialogueOff ;
10715: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
10719: LD_STRING M5
10721: PPUSH
10722: CALL_OW 337
// end ;
10726: PPOPN 3
10728: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
10729: LD_EXP 7
10733: IFFALSE 11326
10735: GO 10737
10737: DISABLE
10738: LD_INT 0
10740: PPUSH
10741: PPUSH
10742: PPUSH
// begin PrepareBelkov ;
10743: CALL 2256 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
10747: LD_EXP 50
10751: PPUSH
10752: LD_INT 118
10754: PPUSH
10755: LD_INT 106
10757: PPUSH
10758: CALL_OW 111
// AddComHold ( Belkov ) ;
10762: LD_EXP 50
10766: PPUSH
10767: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10771: LD_INT 35
10773: PPUSH
10774: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
10778: LD_EXP 50
10782: PPUSH
10783: LD_INT 118
10785: PPUSH
10786: LD_INT 106
10788: PPUSH
10789: CALL_OW 307
10793: IFFALSE 10771
// ChangeSideFog ( 4 , 7 ) ;
10795: LD_INT 4
10797: PPUSH
10798: LD_INT 7
10800: PPUSH
10801: CALL_OW 343
// if IsOk ( Belkov ) then
10805: LD_EXP 50
10809: PPUSH
10810: CALL_OW 302
10814: IFFALSE 10898
// begin InGameOn ;
10816: CALL_OW 8
// DialogueOn ;
10820: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
10824: LD_EXP 50
10828: PPUSH
10829: LD_STRING D5-Bel-1
10831: PPUSH
10832: CALL_OW 94
// if Gossudarov then
10836: LD_EXP 35
10840: IFFALSE 10890
// begin Say ( Gossudarov , D5-Gos-1 ) ;
10842: LD_EXP 35
10846: PPUSH
10847: LD_STRING D5-Gos-1
10849: PPUSH
10850: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
10854: LD_EXP 17
10858: PPUSH
10859: LD_STRING D5-JMM-1
10861: PPUSH
10862: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
10866: LD_EXP 35
10870: PPUSH
10871: LD_STRING D5-Gos-2
10873: PPUSH
10874: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
10878: LD_EXP 17
10882: PPUSH
10883: LD_STRING D5-JMM-2
10885: PPUSH
10886: CALL_OW 88
// end ; DialogueOff ;
10890: CALL_OW 7
// InGameOff ;
10894: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
10898: LD_STRING QSaveBelkov
10900: PPUSH
10901: CALL_OW 97
10905: PUSH
10906: LD_INT 1
10908: DOUBLE
10909: EQUAL
10910: IFTRUE 10914
10912: GO 10964
10914: POP
// begin DialogueOn ;
10915: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
10919: LD_EXP 17
10923: PPUSH
10924: LD_STRING D5a-JMM-1
10926: PPUSH
10927: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
10931: LD_EXP 50
10935: PPUSH
10936: LD_STRING D5a-Bel-1
10938: PPUSH
10939: CALL_OW 94
// DialogueOff ;
10943: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
10947: LD_EXP 50
10951: PPUSH
10952: LD_INT 83
10954: PPUSH
10955: LD_INT 49
10957: PPUSH
10958: CALL_OW 111
// end ; 2 :
10962: GO 10997
10964: LD_INT 2
10966: DOUBLE
10967: EQUAL
10968: IFTRUE 10972
10970: GO 10996
10972: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
10973: LD_EXP 17
10977: PPUSH
10978: LD_STRING D5a-JMM-2
10980: PPUSH
10981: CALL_OW 88
// ComHold ( Belkov ) ;
10985: LD_EXP 50
10989: PPUSH
10990: CALL_OW 140
// end ; end ;
10994: GO 10997
10996: POP
// time := 0 0$00 ;
10997: LD_ADDR_VAR 0 1
11001: PUSH
11002: LD_INT 0
11004: ST_TO_ADDR
// vehSpawned := false ;
11005: LD_ADDR_VAR 0 3
11009: PUSH
11010: LD_INT 0
11012: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11013: LD_INT 35
11015: PPUSH
11016: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
11020: LD_VAR 0 1
11024: PUSH
11025: LD_INT 350
11027: PUSH
11028: LD_INT 175
11030: PUSH
11031: LD_INT 105
11033: PUSH
11034: LD_INT 70
11036: PUSH
11037: EMPTY
11038: LIST
11039: LIST
11040: LIST
11041: LIST
11042: PUSH
11043: LD_OWVAR 67
11047: ARRAY
11048: GREATEREQUAL
11049: PUSH
11050: LD_VAR 0 3
11054: NOT
11055: AND
11056: IFFALSE 11146
// begin vehSpawned := true ;
11058: LD_ADDR_VAR 0 3
11062: PUSH
11063: LD_INT 1
11065: ST_TO_ADDR
// uc_side := 3 ;
11066: LD_ADDR_OWVAR 20
11070: PUSH
11071: LD_INT 3
11073: ST_TO_ADDR
// uc_nation := 3 ;
11074: LD_ADDR_OWVAR 21
11078: PUSH
11079: LD_INT 3
11081: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
11082: LD_INT 22
11084: PPUSH
11085: LD_INT 3
11087: PPUSH
11088: LD_INT 3
11090: PPUSH
11091: LD_INT 43
11093: PPUSH
11094: LD_INT 100
11096: PPUSH
11097: CALL 22116 0 5
// veh := CreateVehicle ;
11101: LD_ADDR_VAR 0 2
11105: PUSH
11106: CALL_OW 45
11110: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
11111: LD_VAR 0 2
11115: PPUSH
11116: LD_INT 130
11118: PPUSH
11119: LD_INT 131
11121: PPUSH
11122: LD_INT 0
11124: PPUSH
11125: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
11129: LD_VAR 0 2
11133: PPUSH
11134: LD_INT 100
11136: PPUSH
11137: LD_INT 82
11139: PPUSH
11140: CALL_OW 114
// end else
11144: GO 11160
// time := time + 0 0$1 ;
11146: LD_ADDR_VAR 0 1
11150: PUSH
11151: LD_VAR 0 1
11155: PUSH
11156: LD_INT 35
11158: PLUS
11159: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
11160: LD_EXP 50
11164: PPUSH
11165: CALL_OW 301
11169: PUSH
11170: LD_EXP 50
11174: PPUSH
11175: CALL_OW 255
11179: PUSH
11180: LD_INT 4
11182: EQUAL
11183: AND
11184: PUSH
11185: LD_INT 22
11187: PUSH
11188: LD_INT 7
11190: PUSH
11191: EMPTY
11192: LIST
11193: LIST
11194: PPUSH
11195: CALL_OW 69
11199: PPUSH
11200: LD_EXP 50
11204: PPUSH
11205: CALL_OW 74
11209: PPUSH
11210: LD_EXP 50
11214: PPUSH
11215: CALL_OW 296
11219: PUSH
11220: LD_INT 10
11222: LESS
11223: OR
11224: IFFALSE 11013
// if IsDead ( Belkov ) then
11226: LD_EXP 50
11230: PPUSH
11231: CALL_OW 301
11235: IFFALSE 11260
// begin CenterNowOnUnits ( Belkov ) ;
11237: LD_EXP 50
11241: PPUSH
11242: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
11246: LD_EXP 17
11250: PPUSH
11251: LD_STRING D5a-JMM-2a
11253: PPUSH
11254: CALL_OW 88
// exit ;
11258: GO 11326
// end ; if See ( 7 , Belkov ) then
11260: LD_INT 7
11262: PPUSH
11263: LD_EXP 50
11267: PPUSH
11268: CALL_OW 292
11272: IFFALSE 11286
// SetSide ( Belkov , 7 ) ;
11274: LD_EXP 50
11278: PPUSH
11279: LD_INT 7
11281: PPUSH
11282: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
11286: LD_INT 35
11288: PPUSH
11289: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
11293: LD_EXP 50
11297: PPUSH
11298: LD_INT 66
11300: PPUSH
11301: LD_INT 45
11303: PPUSH
11304: CALL_OW 297
11308: PUSH
11309: LD_INT 30
11311: LESS
11312: IFFALSE 11286
// Say ( Belkov , D6-Bel-1 ) ;
11314: LD_EXP 50
11318: PPUSH
11319: LD_STRING D6-Bel-1
11321: PPUSH
11322: CALL_OW 88
// end ;
11326: PPOPN 3
11328: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
11329: LD_EXP 50
11333: PPUSH
11334: CALL_OW 302
11338: PUSH
11339: LD_EXP 50
11343: PPUSH
11344: CALL_OW 504
11348: PUSH
11349: LD_INT 2
11351: PUSH
11352: LD_INT 34
11354: PUSH
11355: LD_INT 47
11357: PUSH
11358: EMPTY
11359: LIST
11360: LIST
11361: PUSH
11362: LD_INT 34
11364: PUSH
11365: LD_INT 45
11367: PUSH
11368: EMPTY
11369: LIST
11370: LIST
11371: PUSH
11372: EMPTY
11373: LIST
11374: LIST
11375: LIST
11376: PPUSH
11377: CALL_OW 69
11381: IN
11382: AND
11383: IFFALSE 11400
11385: GO 11387
11387: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
11388: LD_EXP 50
11392: PPUSH
11393: LD_STRING D7-Bel-1
11395: PPUSH
11396: CALL_OW 88
11400: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
11401: LD_INT 22
11403: PUSH
11404: LD_INT 7
11406: PUSH
11407: EMPTY
11408: LIST
11409: LIST
11410: PUSH
11411: LD_INT 101
11413: PUSH
11414: LD_INT 2
11416: PUSH
11417: EMPTY
11418: LIST
11419: LIST
11420: PUSH
11421: EMPTY
11422: LIST
11423: LIST
11424: PPUSH
11425: CALL_OW 69
11429: PUSH
11430: LD_EXP 9
11434: NOT
11435: AND
11436: PUSH
11437: LD_EXP 49
11441: PPUSH
11442: CALL_OW 305
11446: NOT
11447: AND
11448: IFFALSE 11933
11450: GO 11452
11452: DISABLE
11453: LD_INT 0
11455: PPUSH
// begin ar_base_spotted := true ;
11456: LD_ADDR_EXP 9
11460: PUSH
11461: LD_INT 1
11463: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
11464: LD_ADDR_VAR 0 1
11468: PUSH
11469: LD_INT 22
11471: PUSH
11472: LD_INT 2
11474: PUSH
11475: EMPTY
11476: LIST
11477: LIST
11478: PUSH
11479: LD_INT 21
11481: PUSH
11482: LD_INT 3
11484: PUSH
11485: EMPTY
11486: LIST
11487: LIST
11488: PUSH
11489: EMPTY
11490: LIST
11491: LIST
11492: PPUSH
11493: CALL_OW 69
11497: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
11498: LD_ADDR_VAR 0 1
11502: PUSH
11503: LD_VAR 0 1
11507: PPUSH
11508: LD_EXP 17
11512: PPUSH
11513: CALL_OW 74
11517: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
11518: LD_INT 7
11520: PPUSH
11521: LD_INT 3
11523: PPUSH
11524: CALL_OW 332
// DialogueOn ;
11528: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
11532: LD_VAR 0 1
11536: PPUSH
11537: CALL_OW 250
11541: PPUSH
11542: LD_VAR 0 1
11546: PPUSH
11547: CALL_OW 251
11551: PPUSH
11552: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
11556: LD_ADDR_VAR 0 1
11560: PUSH
11561: LD_INT 22
11563: PUSH
11564: LD_INT 7
11566: PUSH
11567: EMPTY
11568: LIST
11569: LIST
11570: PUSH
11571: LD_INT 23
11573: PUSH
11574: LD_INT 1
11576: PUSH
11577: EMPTY
11578: LIST
11579: LIST
11580: PUSH
11581: LD_INT 26
11583: PUSH
11584: LD_INT 1
11586: PUSH
11587: EMPTY
11588: LIST
11589: LIST
11590: PUSH
11591: EMPTY
11592: LIST
11593: LIST
11594: LIST
11595: PPUSH
11596: CALL_OW 69
11600: PUSH
11601: LD_EXP 17
11605: PUSH
11606: LD_EXP 21
11610: PUSH
11611: LD_EXP 22
11615: PUSH
11616: LD_EXP 29
11620: PUSH
11621: LD_EXP 18
11625: PUSH
11626: LD_EXP 27
11630: PUSH
11631: LD_EXP 23
11635: PUSH
11636: LD_EXP 25
11640: PUSH
11641: EMPTY
11642: LIST
11643: LIST
11644: LIST
11645: LIST
11646: LIST
11647: LIST
11648: LIST
11649: LIST
11650: DIFF
11651: ST_TO_ADDR
// if not tmp then
11652: LD_VAR 0 1
11656: NOT
11657: IFFALSE 11731
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
11659: LD_ADDR_VAR 0 1
11663: PUSH
11664: LD_INT 22
11666: PUSH
11667: LD_INT 7
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 23
11676: PUSH
11677: LD_INT 1
11679: PUSH
11680: EMPTY
11681: LIST
11682: LIST
11683: PUSH
11684: LD_INT 26
11686: PUSH
11687: LD_INT 2
11689: PUSH
11690: EMPTY
11691: LIST
11692: LIST
11693: PUSH
11694: EMPTY
11695: LIST
11696: LIST
11697: LIST
11698: PPUSH
11699: CALL_OW 69
11703: PUSH
11704: LD_EXP 32
11708: PUSH
11709: LD_EXP 19
11713: PUSH
11714: LD_EXP 30
11718: PUSH
11719: LD_EXP 31
11723: PUSH
11724: EMPTY
11725: LIST
11726: LIST
11727: LIST
11728: LIST
11729: DIFF
11730: ST_TO_ADDR
// if tmp then
11731: LD_VAR 0 1
11735: IFFALSE 11806
// case GetSex ( tmp [ 1 ] ) of sex_male :
11737: LD_VAR 0 1
11741: PUSH
11742: LD_INT 1
11744: ARRAY
11745: PPUSH
11746: CALL_OW 258
11750: PUSH
11751: LD_INT 1
11753: DOUBLE
11754: EQUAL
11755: IFTRUE 11759
11757: GO 11778
11759: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
11760: LD_VAR 0 1
11764: PUSH
11765: LD_INT 1
11767: ARRAY
11768: PPUSH
11769: LD_STRING D9-Sol1-1
11771: PPUSH
11772: CALL_OW 88
11776: GO 11806
11778: LD_INT 2
11780: DOUBLE
11781: EQUAL
11782: IFTRUE 11786
11784: GO 11805
11786: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
11787: LD_VAR 0 1
11791: PUSH
11792: LD_INT 1
11794: ARRAY
11795: PPUSH
11796: LD_STRING D9-FSol1-1
11798: PPUSH
11799: CALL_OW 88
11803: GO 11806
11805: POP
// if Frank then
11806: LD_EXP 29
11810: IFFALSE 11914
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
11812: LD_EXP 59
11816: PPUSH
11817: CALL_OW 250
11821: PPUSH
11822: LD_EXP 59
11826: PPUSH
11827: CALL_OW 251
11831: PPUSH
11832: LD_INT 7
11834: PPUSH
11835: LD_INT 8
11837: PPUSH
11838: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
11842: LD_EXP 59
11846: PPUSH
11847: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
11851: LD_EXP 29
11855: PPUSH
11856: LD_STRING D9-Frank-1
11858: PPUSH
11859: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
11863: LD_EXP 17
11867: PPUSH
11868: LD_STRING D9-JMM-1
11870: PPUSH
11871: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
11875: LD_EXP 29
11879: PPUSH
11880: LD_STRING D9-Frank-2
11882: PPUSH
11883: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
11887: LD_EXP 59
11891: PPUSH
11892: CALL_OW 250
11896: PPUSH
11897: LD_EXP 59
11901: PPUSH
11902: CALL_OW 251
11906: PPUSH
11907: LD_INT 7
11909: PPUSH
11910: CALL_OW 331
// end ; DialogueOff ;
11914: CALL_OW 7
// wait ( 1 1$00 ) ;
11918: LD_INT 2100
11920: PPUSH
11921: CALL_OW 67
// ar_active_attack := true ;
11925: LD_ADDR_EXP 10
11929: PUSH
11930: LD_INT 1
11932: ST_TO_ADDR
// end ;
11933: PPOPN 1
11935: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
11936: LD_EXP 8
11940: PUSH
11941: LD_OWVAR 1
11945: PUSH
11946: LD_INT 42000
11948: GREATEREQUAL
11949: OR
11950: IFFALSE 13012
11952: GO 11954
11954: DISABLE
11955: LD_INT 0
11957: PPUSH
11958: PPUSH
// begin selected_option := 1 ;
11959: LD_ADDR_VAR 0 2
11963: PUSH
11964: LD_INT 1
11966: ST_TO_ADDR
// wait ( 5 5$00 ) ;
11967: LD_INT 10500
11969: PPUSH
11970: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11974: LD_INT 35
11976: PPUSH
11977: CALL_OW 67
// until not ru_attackers ;
11981: LD_EXP 55
11985: NOT
11986: IFFALSE 11974
// PrepareBurlak ;
11988: CALL 2368 0 0
// repeat wait ( 0 0$2 ) ;
11992: LD_INT 70
11994: PPUSH
11995: CALL_OW 67
// until not HasTask ( Burlak ) ;
11999: LD_EXP 49
12003: PPUSH
12004: CALL_OW 314
12008: NOT
12009: IFFALSE 11992
// InGameOn ;
12011: CALL_OW 8
// DialogueOn ;
12015: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
12019: LD_EXP 52
12023: PPUSH
12024: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
12028: LD_EXP 49
12032: PPUSH
12033: LD_STRING D10-Bur-1
12035: PPUSH
12036: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
12040: LD_EXP 50
12044: PUSH
12045: LD_EXP 50
12049: PPUSH
12050: CALL_OW 255
12054: PUSH
12055: LD_INT 7
12057: EQUAL
12058: AND
12059: IFFALSE 12073
// Say ( Belkov , D10-Bel-1 ) ;
12061: LD_EXP 50
12065: PPUSH
12066: LD_STRING D10-Bel-1
12068: PPUSH
12069: CALL_OW 88
// if Gossudarov then
12073: LD_EXP 35
12077: IFFALSE 12091
// Say ( Gossudarov , D10-Gos-1 ) ;
12079: LD_EXP 35
12083: PPUSH
12084: LD_STRING D10-Gos-1
12086: PPUSH
12087: CALL_OW 88
// if Kirilenkova then
12091: LD_EXP 36
12095: IFFALSE 12109
// Say ( Kirilenkova , D10-Kir-1 ) ;
12097: LD_EXP 36
12101: PPUSH
12102: LD_STRING D10-Kir-1
12104: PPUSH
12105: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
12109: CALL 15777 0 0
12113: PPUSH
12114: LD_STRING D10-RSol1-1
12116: PPUSH
12117: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
12121: LD_EXP 49
12125: PPUSH
12126: LD_STRING D10-Bur-2
12128: PPUSH
12129: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
12133: LD_EXP 17
12137: PPUSH
12138: LD_STRING D10-JMM-2
12140: PPUSH
12141: CALL_OW 88
// if Kirilenkova then
12145: LD_EXP 36
12149: IFFALSE 12165
// Say ( Kirilenkova , D10-Kir-2 ) else
12151: LD_EXP 36
12155: PPUSH
12156: LD_STRING D10-Kir-2
12158: PPUSH
12159: CALL_OW 88
12163: GO 12177
// Say ( SolRu , D10-RSol1-2 ) ;
12165: CALL 15777 0 0
12169: PPUSH
12170: LD_STRING D10-RSol1-2
12172: PPUSH
12173: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
12177: LD_EXP 17
12181: PPUSH
12182: LD_STRING D10-JMM-3
12184: PPUSH
12185: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
12189: LD_EXP 49
12193: PPUSH
12194: LD_STRING D10-Bur-3
12196: PPUSH
12197: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
12201: LD_EXP 17
12205: PPUSH
12206: LD_STRING D10-JMM-4
12208: PPUSH
12209: CALL_OW 88
// DialogueOff ;
12213: CALL_OW 7
// InGameOff ;
12217: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
12221: LD_STRING M2
12223: PPUSH
12224: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
12228: LD_INT 35
12230: PPUSH
12231: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
12235: LD_INT 22
12237: PUSH
12238: LD_INT 7
12240: PUSH
12241: EMPTY
12242: LIST
12243: LIST
12244: PUSH
12245: LD_INT 91
12247: PUSH
12248: LD_EXP 49
12252: PUSH
12253: LD_INT 8
12255: PUSH
12256: EMPTY
12257: LIST
12258: LIST
12259: LIST
12260: PUSH
12261: EMPTY
12262: LIST
12263: LIST
12264: PPUSH
12265: CALL_OW 69
12269: IFFALSE 12228
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
12271: LD_ADDR_VAR 0 1
12275: PUSH
12276: LD_INT 22
12278: PUSH
12279: LD_INT 4
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: PPUSH
12286: CALL_OW 69
12290: PUSH
12291: FOR_IN
12292: IFFALSE 12308
// SetSide ( i , 7 ) ;
12294: LD_VAR 0 1
12298: PPUSH
12299: LD_INT 7
12301: PPUSH
12302: CALL_OW 235
12306: GO 12291
12308: POP
12309: POP
// ChangeMissionObjectives ( M3 ) ;
12310: LD_STRING M3
12312: PPUSH
12313: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
12317: LD_INT 35
12319: PPUSH
12320: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
12324: LD_EXP 17
12328: PPUSH
12329: LD_EXP 49
12333: PPUSH
12334: CALL_OW 296
12338: PUSH
12339: LD_INT 8
12341: LESS
12342: IFFALSE 12317
// ComTurnUnit ( JMM , Burlak ) ;
12344: LD_EXP 17
12348: PPUSH
12349: LD_EXP 49
12353: PPUSH
12354: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
12358: LD_EXP 49
12362: PPUSH
12363: LD_EXP 17
12367: PPUSH
12368: CALL_OW 119
// wait ( 0 0$0.3 ) ;
12372: LD_INT 10
12374: PPUSH
12375: CALL_OW 67
// DialogueOn ;
12379: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
12383: LD_EXP 17
12387: PPUSH
12388: LD_STRING D11-JMM-1
12390: PPUSH
12391: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
12395: LD_EXP 49
12399: PPUSH
12400: LD_STRING D11-Bur-1
12402: PPUSH
12403: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
12407: LD_EXP 17
12411: PPUSH
12412: LD_STRING D11-JMM-2
12414: PPUSH
12415: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
12419: LD_EXP 49
12423: PPUSH
12424: LD_STRING D11-Bur-2
12426: PPUSH
12427: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
12431: LD_EXP 17
12435: PPUSH
12436: LD_STRING D11-JMM-3
12438: PPUSH
12439: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
12443: LD_EXP 49
12447: PPUSH
12448: LD_STRING D11-Bur-3
12450: PPUSH
12451: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
12455: LD_EXP 17
12459: PPUSH
12460: LD_STRING D11-JMM-4
12462: PPUSH
12463: CALL_OW 88
// if ar_base_spotted then
12467: LD_EXP 9
12471: IFFALSE 12487
// Say ( Burlak , D12-Bur-1 ) else
12473: LD_EXP 49
12477: PPUSH
12478: LD_STRING D12-Bur-1
12480: PPUSH
12481: CALL_OW 88
12485: GO 12526
// begin RevealFogArea ( 7 , area_base_arabian ) ;
12487: LD_INT 7
12489: PPUSH
12490: LD_INT 3
12492: PPUSH
12493: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
12497: LD_INT 127
12499: PPUSH
12500: LD_INT 45
12502: PPUSH
12503: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
12507: LD_EXP 49
12511: PPUSH
12512: LD_STRING D12-Bur-1a
12514: PPUSH
12515: CALL_OW 88
// dwait ( 0 0$2 ) ;
12519: LD_INT 70
12521: PPUSH
12522: CALL_OW 68
// end ; if not IsOk ( Abdul ) then
12526: LD_EXP 58
12530: PPUSH
12531: CALL_OW 302
12535: NOT
12536: IFFALSE 12544
// begin DialogueOff ;
12538: CALL_OW 7
// exit ;
12542: GO 13012
// end ; Say ( Burlak , D12-Bur-1b ) ;
12544: LD_EXP 49
12548: PPUSH
12549: LD_STRING D12-Bur-1b
12551: PPUSH
12552: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
12556: LD_EXP 17
12560: PPUSH
12561: LD_STRING D12-JMM-1
12563: PPUSH
12564: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
12568: LD_EXP 49
12572: PPUSH
12573: LD_STRING D12-Bur-2
12575: PPUSH
12576: CALL_OW 88
// if Roth then
12580: LD_EXP 18
12584: IFFALSE 12600
// Say ( Roth , D12-Roth-2 ) else
12586: LD_EXP 18
12590: PPUSH
12591: LD_STRING D12-Roth-2
12593: PPUSH
12594: CALL_OW 88
12598: GO 12612
// Say ( SciRu , D12-RSci1-2 ) ;
12600: CALL 15630 0 0
12604: PPUSH
12605: LD_STRING D12-RSci1-2
12607: PPUSH
12608: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
12612: LD_EXP 17
12616: PPUSH
12617: LD_STRING D12-JMM-2
12619: PPUSH
12620: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
12624: LD_EXP 49
12628: PPUSH
12629: LD_STRING D12-Bur-3
12631: PPUSH
12632: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
12636: LD_EXP 17
12640: PPUSH
12641: LD_STRING D12-JMM-3
12643: PPUSH
12644: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
12648: LD_EXP 49
12652: PPUSH
12653: LD_STRING D12-Bur-4
12655: PPUSH
12656: CALL_OW 88
// case Query ( QBase ) of 1 :
12660: LD_STRING QBase
12662: PPUSH
12663: CALL_OW 97
12667: PUSH
12668: LD_INT 1
12670: DOUBLE
12671: EQUAL
12672: IFTRUE 12676
12674: GO 12794
12676: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
12677: LD_EXP 17
12681: PPUSH
12682: LD_STRING D13a-JMM-1
12684: PPUSH
12685: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
12689: LD_EXP 49
12693: PPUSH
12694: LD_STRING D13a-Bur-1
12696: PPUSH
12697: CALL_OW 88
// if Roth then
12701: LD_EXP 18
12705: IFFALSE 12721
// Say ( Roth , D13a-Roth-1 ) else
12707: LD_EXP 18
12711: PPUSH
12712: LD_STRING D13a-Roth-1
12714: PPUSH
12715: CALL_OW 88
12719: GO 12733
// Say ( SciRu , D13a-RSci1-1 ) ;
12721: CALL 15630 0 0
12725: PPUSH
12726: LD_STRING D13a-RSci1-1
12728: PPUSH
12729: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
12733: LD_EXP 17
12737: PPUSH
12738: LD_STRING D13a-JMM-2
12740: PPUSH
12741: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
12745: LD_STRING QBaseAgain
12747: PPUSH
12748: CALL_OW 97
12752: PUSH
12753: LD_INT 1
12755: DOUBLE
12756: EQUAL
12757: IFTRUE 12761
12759: GO 12772
12761: POP
// selected_option := 2 ; 2 :
12762: LD_ADDR_VAR 0 2
12766: PUSH
12767: LD_INT 2
12769: ST_TO_ADDR
12770: GO 12792
12772: LD_INT 2
12774: DOUBLE
12775: EQUAL
12776: IFTRUE 12780
12778: GO 12791
12780: POP
// selected_option := 3 ; end ;
12781: LD_ADDR_VAR 0 2
12785: PUSH
12786: LD_INT 3
12788: ST_TO_ADDR
12789: GO 12792
12791: POP
// end ; 2 :
12792: GO 12833
12794: LD_INT 2
12796: DOUBLE
12797: EQUAL
12798: IFTRUE 12802
12800: GO 12813
12802: POP
// selected_option := 2 ; 3 :
12803: LD_ADDR_VAR 0 2
12807: PUSH
12808: LD_INT 2
12810: ST_TO_ADDR
12811: GO 12833
12813: LD_INT 3
12815: DOUBLE
12816: EQUAL
12817: IFTRUE 12821
12819: GO 12832
12821: POP
// selected_option := 3 ; end ;
12822: LD_ADDR_VAR 0 2
12826: PUSH
12827: LD_INT 3
12829: ST_TO_ADDR
12830: GO 12833
12832: POP
// if selected_option = 2 then
12833: LD_VAR 0 2
12837: PUSH
12838: LD_INT 2
12840: EQUAL
12841: IFFALSE 12945
// begin Say ( JMM , D13b-JMM-1 ) ;
12843: LD_EXP 17
12847: PPUSH
12848: LD_STRING D13b-JMM-1
12850: PPUSH
12851: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
12855: LD_EXP 49
12859: PPUSH
12860: LD_STRING D13b-Bur-1
12862: PPUSH
12863: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
12867: LD_EXP 17
12871: PPUSH
12872: LD_STRING D13b-JMM-2
12874: PPUSH
12875: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
12879: LD_EXP 58
12883: PPUSH
12884: LD_STRING D13b-Abd-2
12886: PPUSH
12887: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
12891: LD_EXP 17
12895: PPUSH
12896: LD_STRING D13b-JMM-3
12898: PPUSH
12899: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
12903: LD_EXP 58
12907: PPUSH
12908: LD_STRING D13b-Abd-3
12910: PPUSH
12911: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
12915: LD_EXP 17
12919: PPUSH
12920: LD_STRING D13b-JMM-4
12922: PPUSH
12923: CALL_OW 88
// ar_active_attack := true ;
12927: LD_ADDR_EXP 10
12931: PUSH
12932: LD_INT 1
12934: ST_TO_ADDR
// SaveVariable ( true , 13a_negotiationWithArabs ) ;
12935: LD_INT 1
12937: PPUSH
12938: LD_STRING 13a_negotiationWithArabs
12940: PPUSH
12941: CALL_OW 39
// end ; if selected_option = 3 then
12945: LD_VAR 0 2
12949: PUSH
12950: LD_INT 3
12952: EQUAL
12953: IFFALSE 12979
// begin Say ( JMM , D13c-JMM-1 ) ;
12955: LD_EXP 17
12959: PPUSH
12960: LD_STRING D13c-JMM-1
12962: PPUSH
12963: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
12967: LD_EXP 49
12971: PPUSH
12972: LD_STRING D13c-Bur-1
12974: PPUSH
12975: CALL_OW 88
// end ; DialogueOff ;
12979: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
12983: LD_STRING M4
12985: PPUSH
12986: CALL_OW 337
// if not ar_active_attack then
12990: LD_EXP 10
12994: NOT
12995: IFFALSE 13012
// begin wait ( 6 6$00 ) ;
12997: LD_INT 12600
12999: PPUSH
13000: CALL_OW 67
// ar_active_attack := true ;
13004: LD_ADDR_EXP 10
13008: PUSH
13009: LD_INT 1
13011: ST_TO_ADDR
// end ; end ;
13012: PPOPN 2
13014: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
13015: LD_EXP 49
13019: PPUSH
13020: CALL_OW 305
13024: PUSH
13025: LD_EXP 49
13029: PPUSH
13030: CALL_OW 255
13034: PUSH
13035: LD_INT 7
13037: EQUAL
13038: AND
13039: IFFALSE 13262
13041: GO 13043
13043: DISABLE
13044: LD_INT 0
13046: PPUSH
// begin wait ( 4 4$40 ) ;
13047: LD_INT 9800
13049: PPUSH
13050: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
13054: LD_INT 35
13056: PPUSH
13057: CALL_OW 67
// until not ru_attackers and not FilterAllUnits ( [ [ f_side , 6 ] , [ f_ok ] ] ) ;
13061: LD_EXP 55
13065: NOT
13066: PUSH
13067: LD_INT 22
13069: PUSH
13070: LD_INT 6
13072: PUSH
13073: EMPTY
13074: LIST
13075: LIST
13076: PUSH
13077: LD_INT 50
13079: PUSH
13080: EMPTY
13081: LIST
13082: PUSH
13083: EMPTY
13084: LIST
13085: LIST
13086: PPUSH
13087: CALL_OW 69
13091: NOT
13092: AND
13093: IFFALSE 13054
// PrepareGnyevko ;
13095: CALL 2312 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
13099: LD_EXP 51
13103: PPUSH
13104: LD_INT 124
13106: PPUSH
13107: LD_INT 118
13109: PPUSH
13110: CALL_OW 111
// AddComHold ( Gnyevko ) ;
13114: LD_EXP 51
13118: PPUSH
13119: CALL_OW 200
// time := 0 0$00 ;
13123: LD_ADDR_VAR 0 1
13127: PUSH
13128: LD_INT 0
13130: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
13131: LD_INT 35
13133: PPUSH
13134: CALL_OW 67
// time := time + 0 0$1 ;
13138: LD_ADDR_VAR 0 1
13142: PUSH
13143: LD_VAR 0 1
13147: PUSH
13148: LD_INT 35
13150: PLUS
13151: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
13152: LD_EXP 51
13156: PPUSH
13157: LD_INT 124
13159: PPUSH
13160: LD_INT 118
13162: PPUSH
13163: CALL_OW 307
13167: PUSH
13168: LD_VAR 0 1
13172: PUSH
13173: LD_INT 1050
13175: GREATEREQUAL
13176: OR
13177: IFFALSE 13131
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
13179: LD_EXP 51
13183: PPUSH
13184: LD_STRING DBelkov-Gny-1
13186: PPUSH
13187: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
13191: LD_EXP 49
13195: PPUSH
13196: LD_STRING DBelkov-Bur-1a
13198: PPUSH
13199: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
13203: LD_INT 35
13205: PPUSH
13206: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
13210: LD_EXP 51
13214: PPUSH
13215: LD_INT 22
13217: PUSH
13218: LD_INT 7
13220: PUSH
13221: EMPTY
13222: LIST
13223: LIST
13224: PPUSH
13225: CALL_OW 69
13229: PPUSH
13230: LD_EXP 51
13234: PPUSH
13235: CALL_OW 74
13239: PPUSH
13240: CALL_OW 296
13244: PUSH
13245: LD_INT 8
13247: LESS
13248: IFFALSE 13203
// SetSide ( Gnyevko , 7 ) ;
13250: LD_EXP 51
13254: PPUSH
13255: LD_INT 7
13257: PPUSH
13258: CALL_OW 235
// end ;
13262: PPOPN 1
13264: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
13265: LD_EXP 49
13269: PPUSH
13270: CALL_OW 255
13274: PUSH
13275: LD_INT 7
13277: EQUAL
13278: IFFALSE 13288
13280: GO 13282
13282: DISABLE
// begin enable ;
13283: ENABLE
// PrepareAmericanAttack ;
13284: CALL 8627 0 0
// end ;
13288: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
13289: LD_INT 22
13291: PUSH
13292: LD_INT 1
13294: PUSH
13295: EMPTY
13296: LIST
13297: LIST
13298: PPUSH
13299: CALL_OW 69
13303: IFFALSE 13487
13305: GO 13307
13307: DISABLE
13308: LD_INT 0
13310: PPUSH
13311: PPUSH
// begin while true do
13312: LD_INT 1
13314: IFFALSE 13371
// begin wait ( 0 0$1 ) ;
13316: LD_INT 35
13318: PPUSH
13319: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
13323: LD_ADDR_VAR 0 2
13327: PUSH
13328: LD_INT 22
13330: PUSH
13331: LD_INT 1
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: PPUSH
13338: CALL_OW 69
13342: PPUSH
13343: LD_EXP 17
13347: PPUSH
13348: CALL_OW 74
13352: ST_TO_ADDR
// if See ( 7 , tmp ) then
13353: LD_INT 7
13355: PPUSH
13356: LD_VAR 0 2
13360: PPUSH
13361: CALL_OW 292
13365: IFFALSE 13369
// break ;
13367: GO 13371
// end ;
13369: GO 13312
// DialogueOn ;
13371: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
13375: LD_VAR 0 2
13379: PPUSH
13380: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
13384: LD_VAR 0 2
13388: PPUSH
13389: CALL_OW 250
13393: PPUSH
13394: LD_VAR 0 2
13398: PPUSH
13399: CALL_OW 251
13403: PPUSH
13404: LD_INT 7
13406: PPUSH
13407: LD_INT 8
13409: PPUSH
13410: CALL_OW 330
// if Denis then
13414: LD_EXP 23
13418: IFFALSE 13432
// Say ( Denis , DAmerAttack-Pet-1 ) ;
13420: LD_EXP 23
13424: PPUSH
13425: LD_STRING DAmerAttack-Pet-1
13427: PPUSH
13428: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
13432: LD_EXP 17
13436: PPUSH
13437: LD_STRING DAmerAttack-JMM-1
13439: PPUSH
13440: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
13444: LD_EXP 49
13448: PPUSH
13449: LD_STRING DStop-Bur-1
13451: PPUSH
13452: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
13456: LD_VAR 0 2
13460: PPUSH
13461: CALL_OW 250
13465: PPUSH
13466: LD_VAR 0 2
13470: PPUSH
13471: CALL_OW 251
13475: PPUSH
13476: LD_INT 7
13478: PPUSH
13479: CALL_OW 331
// DialogueOff ;
13483: CALL_OW 7
// end ;
13487: PPOPN 2
13489: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
13490: LD_INT 22
13492: PUSH
13493: LD_INT 3
13495: PUSH
13496: EMPTY
13497: LIST
13498: LIST
13499: PUSH
13500: LD_INT 21
13502: PUSH
13503: LD_INT 1
13505: PUSH
13506: EMPTY
13507: LIST
13508: LIST
13509: PUSH
13510: EMPTY
13511: LIST
13512: LIST
13513: PPUSH
13514: CALL_OW 69
13518: PUSH
13519: LD_INT 0
13521: EQUAL
13522: IFFALSE 13572
13524: GO 13526
13526: DISABLE
// begin ru_active_attack := false ;
13527: LD_ADDR_EXP 6
13531: PUSH
13532: LD_INT 0
13534: ST_TO_ADDR
// ChangeMissionObjectives ( M5a ) ;
13535: LD_STRING M5a
13537: PPUSH
13538: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
13542: LD_EXP 17
13546: PPUSH
13547: LD_STRING D8-JMM-1
13549: PPUSH
13550: CALL_OW 88
// if Gossudarov then
13554: LD_EXP 35
13558: IFFALSE 13572
// Say ( Gossudarov , D8-Gos-1 ) ;
13560: LD_EXP 35
13564: PPUSH
13565: LD_STRING D8-Gos-1
13567: PPUSH
13568: CALL_OW 88
// end ;
13572: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
13573: LD_INT 22
13575: PUSH
13576: LD_INT 2
13578: PUSH
13579: EMPTY
13580: LIST
13581: LIST
13582: PUSH
13583: LD_INT 21
13585: PUSH
13586: LD_INT 1
13588: PUSH
13589: EMPTY
13590: LIST
13591: LIST
13592: PUSH
13593: EMPTY
13594: LIST
13595: LIST
13596: PPUSH
13597: CALL_OW 69
13601: PUSH
13602: LD_INT 0
13604: EQUAL
13605: IFFALSE 13663
13607: GO 13609
13609: DISABLE
// begin ar_active_attack := false ;
13610: LD_ADDR_EXP 10
13614: PUSH
13615: LD_INT 0
13617: ST_TO_ADDR
// ChangeMissionObjectives ( M4c ) ;
13618: LD_STRING M4c
13620: PPUSH
13621: CALL_OW 337
// if Roth then
13625: LD_EXP 18
13629: IFFALSE 13645
// Say ( Roth , DStop-Roth-1 ) else
13631: LD_EXP 18
13635: PPUSH
13636: LD_STRING DStop-Roth-1
13638: PPUSH
13639: CALL_OW 88
13643: GO 13663
// if Gossudarov then
13645: LD_EXP 35
13649: IFFALSE 13663
// Say ( Gossudarov , D8-Gos-1a ) ;
13651: LD_EXP 35
13655: PPUSH
13656: LD_STRING D8-Gos-1a
13658: PPUSH
13659: CALL_OW 88
// end ;
13663: END
// every 1 1$00 trigger FindArtifact ( 3 ) and first_powell_attack do
13664: LD_INT 3
13666: PPUSH
13667: CALL_OW 469
13671: PUSH
13672: LD_EXP 13
13676: AND
13677: IFFALSE 13732
13679: GO 13681
13681: DISABLE
// begin TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
13682: LD_INT 3
13684: PPUSH
13685: CALL_OW 469
13689: PPUSH
13690: CALL 9116 0 1
// if Difficulty > 2 then
13694: LD_OWVAR 67
13698: PUSH
13699: LD_INT 2
13701: GREATER
13702: IFFALSE 13732
// begin wait ( 5 5$00 ) ;
13704: LD_INT 10500
13706: PPUSH
13707: CALL_OW 67
// if FindArtifact ( 3 ) then
13711: LD_INT 3
13713: PPUSH
13714: CALL_OW 469
13718: IFFALSE 13732
// TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
13720: LD_INT 3
13722: PPUSH
13723: CALL_OW 469
13727: PPUSH
13728: CALL 9116 0 1
// end ; end ;
13732: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
13733: LD_INT 7
13735: PPUSH
13736: LD_INT 1
13738: PPUSH
13739: LD_INT 1
13741: PPUSH
13742: CALL 17339 0 3
13746: PUSH
13747: LD_INT 0
13749: EQUAL
13750: PUSH
13751: LD_INT 7
13753: PPUSH
13754: LD_INT 3
13756: PPUSH
13757: LD_INT 1
13759: PPUSH
13760: CALL 17339 0 3
13764: PUSH
13765: LD_INT 0
13767: EQUAL
13768: AND
13769: IFFALSE 13781
13771: GO 13773
13773: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
13774: LD_STRING M1a
13776: PPUSH
13777: CALL_OW 337
// end ;
13781: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , nation_arabian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
13782: LD_INT 22
13784: PUSH
13785: LD_INT 2
13787: PUSH
13788: EMPTY
13789: LIST
13790: LIST
13791: PUSH
13792: LD_INT 23
13794: PUSH
13795: LD_INT 2
13797: PUSH
13798: EMPTY
13799: LIST
13800: LIST
13801: PUSH
13802: LD_INT 21
13804: PUSH
13805: LD_INT 1
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: LIST
13816: PPUSH
13817: CALL_OW 69
13821: PUSH
13822: LD_INT 0
13824: EQUAL
13825: PUSH
13826: LD_INT 22
13828: PUSH
13829: LD_INT 3
13831: PUSH
13832: EMPTY
13833: LIST
13834: LIST
13835: PUSH
13836: LD_INT 23
13838: PUSH
13839: LD_INT 3
13841: PUSH
13842: EMPTY
13843: LIST
13844: LIST
13845: PUSH
13846: LD_INT 21
13848: PUSH
13849: LD_INT 1
13851: PUSH
13852: EMPTY
13853: LIST
13854: LIST
13855: PUSH
13856: EMPTY
13857: LIST
13858: LIST
13859: LIST
13860: PPUSH
13861: CALL_OW 69
13865: PUSH
13866: LD_INT 0
13868: EQUAL
13869: AND
13870: PUSH
13871: LD_INT 22
13873: PUSH
13874: LD_INT 1
13876: PUSH
13877: EMPTY
13878: LIST
13879: LIST
13880: PPUSH
13881: CALL_OW 69
13885: PUSH
13886: LD_INT 0
13888: EQUAL
13889: AND
13890: PUSH
13891: LD_INT 7
13893: PPUSH
13894: LD_INT 1
13896: PPUSH
13897: LD_INT 1
13899: PPUSH
13900: CALL 17339 0 3
13904: PUSH
13905: LD_INT 0
13907: EQUAL
13908: AND
13909: PUSH
13910: LD_INT 7
13912: PPUSH
13913: LD_INT 3
13915: PPUSH
13916: LD_INT 1
13918: PPUSH
13919: CALL 17339 0 3
13923: PUSH
13924: LD_INT 0
13926: EQUAL
13927: AND
13928: PUSH
13929: LD_EXP 49
13933: PPUSH
13934: CALL_OW 255
13938: PUSH
13939: LD_INT 7
13941: EQUAL
13942: AND
13943: PUSH
13944: LD_EXP 49
13948: PPUSH
13949: CALL_OW 302
13953: AND
13954: IFFALSE 15627
13956: GO 13958
13958: DISABLE
13959: LD_INT 0
13961: PPUSH
13962: PPUSH
13963: PPUSH
13964: PPUSH
13965: PPUSH
13966: PPUSH
// begin m1 := false ;
13967: LD_ADDR_VAR 0 4
13971: PUSH
13972: LD_INT 0
13974: ST_TO_ADDR
// m2 := false ;
13975: LD_ADDR_VAR 0 5
13979: PUSH
13980: LD_INT 0
13982: ST_TO_ADDR
// m3 := false ;
13983: LD_ADDR_VAR 0 6
13987: PUSH
13988: LD_INT 0
13990: ST_TO_ADDR
// if tick < 40 40$00 then
13991: LD_OWVAR 1
13995: PUSH
13996: LD_INT 84000
13998: LESS
13999: IFFALSE 14008
// SetAchievement ( ACH_ASPEED_17 ) ;
14001: LD_STRING ACH_ASPEED_17
14003: PPUSH
14004: CALL_OW 543
// wait ( 0 0$5 ) ;
14008: LD_INT 175
14010: PPUSH
14011: CALL_OW 67
// if not masha_killed then
14015: LD_EXP 11
14019: NOT
14020: IFFALSE 14042
// begin m1 := true ;
14022: LD_ADDR_VAR 0 4
14026: PUSH
14027: LD_INT 1
14029: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
14030: LD_STRING Masha
14032: PPUSH
14033: LD_INT 1
14035: PPUSH
14036: CALL_OW 101
// end else
14040: GO 14053
// AddMedal ( Masha , - 1 ) ;
14042: LD_STRING Masha
14044: PPUSH
14045: LD_INT 1
14047: NEG
14048: PPUSH
14049: CALL_OW 101
// if abdul_escaped then
14053: LD_EXP 14
14057: IFFALSE 14072
// AddMedal ( Abdul , - 1 ) else
14059: LD_STRING Abdul
14061: PPUSH
14062: LD_INT 1
14064: NEG
14065: PPUSH
14066: CALL_OW 101
14070: GO 14090
// begin m2 := true ;
14072: LD_ADDR_VAR 0 5
14076: PUSH
14077: LD_INT 1
14079: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
14080: LD_STRING Abdul
14082: PPUSH
14083: LD_INT 1
14085: PPUSH
14086: CALL_OW 101
// end ; if loss_counter = 0 then
14090: LD_EXP 15
14094: PUSH
14095: LD_INT 0
14097: EQUAL
14098: IFFALSE 14120
// begin m3 := true ;
14100: LD_ADDR_VAR 0 6
14104: PUSH
14105: LD_INT 1
14107: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
14108: LD_STRING People
14110: PPUSH
14111: LD_INT 2
14113: PPUSH
14114: CALL_OW 101
// end else
14118: GO 14182
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
14120: LD_EXP 15
14124: PUSH
14125: LD_INT 3
14127: PUSH
14128: LD_INT 2
14130: PUSH
14131: LD_INT 2
14133: PUSH
14134: LD_INT 1
14136: PUSH
14137: EMPTY
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: PUSH
14143: LD_OWVAR 67
14147: ARRAY
14148: LESSEQUAL
14149: IFFALSE 14171
// begin AddMedal ( People , 1 ) ;
14151: LD_STRING People
14153: PPUSH
14154: LD_INT 1
14156: PPUSH
14157: CALL_OW 101
// m3 := true ;
14161: LD_ADDR_VAR 0 6
14165: PUSH
14166: LD_INT 1
14168: ST_TO_ADDR
// end else
14169: GO 14182
// AddMedal ( People , - 1 ) ;
14171: LD_STRING People
14173: PPUSH
14174: LD_INT 1
14176: NEG
14177: PPUSH
14178: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
14182: LD_OWVAR 67
14186: PUSH
14187: LD_INT 3
14189: GREATEREQUAL
14190: PUSH
14191: LD_VAR 0 4
14195: AND
14196: PUSH
14197: LD_VAR 0 5
14201: AND
14202: PUSH
14203: LD_VAR 0 6
14207: AND
14208: IFFALSE 14220
// SetAchievementEX ( ACH_AMER , 17 ) ;
14210: LD_STRING ACH_AMER
14212: PPUSH
14213: LD_INT 17
14215: PPUSH
14216: CALL_OW 564
// GiveMedals ( MAIN ) ;
14220: LD_STRING MAIN
14222: PPUSH
14223: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
14227: LD_ADDR_VAR 0 2
14231: PUSH
14232: LD_INT 22
14234: PUSH
14235: LD_INT 7
14237: PUSH
14238: EMPTY
14239: LIST
14240: LIST
14241: PUSH
14242: LD_INT 50
14244: PUSH
14245: EMPTY
14246: LIST
14247: PUSH
14248: LD_INT 2
14250: PUSH
14251: LD_INT 25
14253: PUSH
14254: LD_INT 1
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: PUSH
14261: LD_INT 25
14263: PUSH
14264: LD_INT 2
14266: PUSH
14267: EMPTY
14268: LIST
14269: LIST
14270: PUSH
14271: LD_INT 25
14273: PUSH
14274: LD_INT 3
14276: PUSH
14277: EMPTY
14278: LIST
14279: LIST
14280: PUSH
14281: LD_INT 25
14283: PUSH
14284: LD_INT 4
14286: PUSH
14287: EMPTY
14288: LIST
14289: LIST
14290: PUSH
14291: LD_INT 25
14293: PUSH
14294: LD_INT 5
14296: PUSH
14297: EMPTY
14298: LIST
14299: LIST
14300: PUSH
14301: LD_INT 25
14303: PUSH
14304: LD_INT 8
14306: PUSH
14307: EMPTY
14308: LIST
14309: LIST
14310: PUSH
14311: LD_INT 25
14313: PUSH
14314: LD_INT 9
14316: PUSH
14317: EMPTY
14318: LIST
14319: LIST
14320: PUSH
14321: EMPTY
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: PUSH
14331: EMPTY
14332: LIST
14333: LIST
14334: LIST
14335: PPUSH
14336: CALL_OW 69
14340: ST_TO_ADDR
// RewardPeople ( tmp ) ;
14341: LD_VAR 0 2
14345: PPUSH
14346: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
14350: LD_ADDR_VAR 0 3
14354: PUSH
14355: LD_EXP 17
14359: PUSH
14360: LD_EXP 18
14364: PUSH
14365: LD_EXP 19
14369: PUSH
14370: LD_EXP 20
14374: PUSH
14375: LD_EXP 21
14379: PUSH
14380: LD_EXP 22
14384: PUSH
14385: LD_EXP 23
14389: PUSH
14390: LD_EXP 24
14394: PUSH
14395: LD_EXP 25
14399: PUSH
14400: LD_EXP 26
14404: PUSH
14405: LD_EXP 27
14409: PUSH
14410: LD_EXP 28
14414: PUSH
14415: LD_EXP 29
14419: PUSH
14420: LD_EXP 30
14424: PUSH
14425: LD_EXP 31
14429: PUSH
14430: LD_EXP 32
14434: PUSH
14435: LD_EXP 33
14439: PUSH
14440: LD_EXP 35
14444: PUSH
14445: LD_EXP 36
14449: PUSH
14450: LD_EXP 37
14454: PUSH
14455: LD_EXP 39
14459: PUSH
14460: LD_EXP 40
14464: PUSH
14465: LD_EXP 41
14469: PUSH
14470: LD_EXP 42
14474: PUSH
14475: LD_EXP 43
14479: PUSH
14480: LD_EXP 44
14484: PUSH
14485: LD_EXP 45
14489: PUSH
14490: LD_EXP 46
14494: PUSH
14495: LD_EXP 47
14499: PUSH
14500: LD_EXP 48
14504: PUSH
14505: LD_EXP 49
14509: PUSH
14510: LD_EXP 50
14514: PUSH
14515: LD_EXP 51
14519: PUSH
14520: LD_EXP 34
14524: PUSH
14525: EMPTY
14526: LIST
14527: LIST
14528: LIST
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: LIST
14534: LIST
14535: LIST
14536: LIST
14537: LIST
14538: LIST
14539: LIST
14540: LIST
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: LIST
14560: ST_TO_ADDR
// if tmp diff tmp2 then
14561: LD_VAR 0 2
14565: PUSH
14566: LD_VAR 0 3
14570: DIFF
14571: IFFALSE 14591
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
14573: LD_VAR 0 2
14577: PUSH
14578: LD_VAR 0 3
14582: DIFF
14583: PPUSH
14584: LD_STRING 13a_others
14586: PPUSH
14587: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
14591: LD_EXP 17
14595: PPUSH
14596: LD_STRING 13a_JMM
14598: PPUSH
14599: CALL_OW 38
// if IsOk ( Mike ) then
14603: LD_EXP 34
14607: PPUSH
14608: CALL_OW 302
14612: IFFALSE 14626
// SaveCharacters ( Mike , 13a_Mike ) ;
14614: LD_EXP 34
14618: PPUSH
14619: LD_STRING 13a_Mike
14621: PPUSH
14622: CALL_OW 38
// if IsOk ( Titov ) then
14626: LD_EXP 37
14630: PPUSH
14631: CALL_OW 302
14635: IFFALSE 14649
// SaveCharacters ( Titov , 13a_Titov ) ;
14637: LD_EXP 37
14641: PPUSH
14642: LD_STRING 13a_Titov
14644: PPUSH
14645: CALL_OW 38
// if IsOk ( Dolgov ) then
14649: LD_EXP 39
14653: PPUSH
14654: CALL_OW 302
14658: IFFALSE 14672
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
14660: LD_EXP 39
14664: PPUSH
14665: LD_STRING 13a_Dolgov
14667: PPUSH
14668: CALL_OW 38
// if IsOk ( Petrosyan ) then
14672: LD_EXP 40
14676: PPUSH
14677: CALL_OW 302
14681: IFFALSE 14695
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
14683: LD_EXP 40
14687: PPUSH
14688: LD_STRING 13a_Petrosyan
14690: PPUSH
14691: CALL_OW 38
// if IsOk ( Scholtze ) then
14695: LD_EXP 41
14699: PPUSH
14700: CALL_OW 302
14704: IFFALSE 14718
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
14706: LD_EXP 41
14710: PPUSH
14711: LD_STRING 13a_Scholtze
14713: PPUSH
14714: CALL_OW 38
// if IsOk ( Oblukov ) then
14718: LD_EXP 42
14722: PPUSH
14723: CALL_OW 302
14727: IFFALSE 14741
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
14729: LD_EXP 42
14733: PPUSH
14734: LD_STRING 13a_Oblukov
14736: PPUSH
14737: CALL_OW 38
// if IsOk ( Kapitsova ) then
14741: LD_EXP 43
14745: PPUSH
14746: CALL_OW 302
14750: IFFALSE 14764
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
14752: LD_EXP 43
14756: PPUSH
14757: LD_STRING 13a_Kapitsova
14759: PPUSH
14760: CALL_OW 38
// if IsOk ( Lipshchin ) then
14764: LD_EXP 44
14768: PPUSH
14769: CALL_OW 302
14773: IFFALSE 14787
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
14775: LD_EXP 44
14779: PPUSH
14780: LD_STRING 13a_Lipshchin
14782: PPUSH
14783: CALL_OW 38
// if IsOk ( Petrovova ) then
14787: LD_EXP 45
14791: PPUSH
14792: CALL_OW 302
14796: IFFALSE 14810
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
14798: LD_EXP 45
14802: PPUSH
14803: LD_STRING 13a_Petrovova
14805: PPUSH
14806: CALL_OW 38
// if IsOk ( Kovalyuk ) then
14810: LD_EXP 46
14814: PPUSH
14815: CALL_OW 302
14819: IFFALSE 14833
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
14821: LD_EXP 46
14825: PPUSH
14826: LD_STRING 13a_Kovalyuk
14828: PPUSH
14829: CALL_OW 38
// if IsOk ( Kuzmov ) then
14833: LD_EXP 47
14837: PPUSH
14838: CALL_OW 302
14842: IFFALSE 14856
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
14844: LD_EXP 47
14848: PPUSH
14849: LD_STRING 13a_Kuzmov
14851: PPUSH
14852: CALL_OW 38
// if IsOk ( Karamazov ) then
14856: LD_EXP 48
14860: PPUSH
14861: CALL_OW 302
14865: IFFALSE 14879
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
14867: LD_EXP 48
14871: PPUSH
14872: LD_STRING 13a_Karamazov
14874: PPUSH
14875: CALL_OW 38
// if Burlak then
14879: LD_EXP 49
14883: IFFALSE 14904
// begin ToLua ( enableBioCharacter(BIO_GORKI) ) ;
14885: LD_STRING enableBioCharacter(BIO_GORKI)
14887: PPUSH
14888: CALL_OW 559
// SaveCharacters ( Burlak , 13a_Burlak ) ;
14892: LD_EXP 49
14896: PPUSH
14897: LD_STRING 13a_Burlak
14899: PPUSH
14900: CALL_OW 38
// end ; if IsOk ( Belkov ) then
14904: LD_EXP 50
14908: PPUSH
14909: CALL_OW 302
14913: IFFALSE 14927
// SaveCharacters ( Belkov , 13a_Belkov ) ;
14915: LD_EXP 50
14919: PPUSH
14920: LD_STRING 13a_Belkov
14922: PPUSH
14923: CALL_OW 38
// if IsOk ( Gnyevko ) then
14927: LD_EXP 51
14931: PPUSH
14932: CALL_OW 302
14936: IFFALSE 14950
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
14938: LD_EXP 51
14942: PPUSH
14943: LD_STRING 13a_Gnyevko
14945: PPUSH
14946: CALL_OW 38
// if IsOk ( Lisa ) then
14950: LD_EXP 19
14954: PPUSH
14955: CALL_OW 302
14959: IFFALSE 14973
// SaveCharacters ( Lisa , 13a_Lisa ) ;
14961: LD_EXP 19
14965: PPUSH
14966: LD_STRING 13a_Lisa
14968: PPUSH
14969: CALL_OW 38
// if IsOk ( Donaldson ) then
14973: LD_EXP 20
14977: PPUSH
14978: CALL_OW 302
14982: IFFALSE 14996
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
14984: LD_EXP 20
14988: PPUSH
14989: LD_STRING 13a_Donaldson
14991: PPUSH
14992: CALL_OW 38
// if IsOk ( Bobby ) then
14996: LD_EXP 21
15000: PPUSH
15001: CALL_OW 302
15005: IFFALSE 15019
// SaveCharacters ( Bobby , 13a_Bobby ) ;
15007: LD_EXP 21
15011: PPUSH
15012: LD_STRING 13a_Bobby
15014: PPUSH
15015: CALL_OW 38
// if IsOk ( Cyrus ) then
15019: LD_EXP 22
15023: PPUSH
15024: CALL_OW 302
15028: IFFALSE 15042
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
15030: LD_EXP 22
15034: PPUSH
15035: LD_STRING 13a_Cyrus
15037: PPUSH
15038: CALL_OW 38
// if IsOk ( Denis ) then
15042: LD_EXP 23
15046: PPUSH
15047: CALL_OW 302
15051: IFFALSE 15065
// SaveCharacters ( Denis , 13a_Denis ) ;
15053: LD_EXP 23
15057: PPUSH
15058: LD_STRING 13a_Denis
15060: PPUSH
15061: CALL_OW 38
// if IsOk ( Brown ) then
15065: LD_EXP 24
15069: PPUSH
15070: CALL_OW 302
15074: IFFALSE 15088
// SaveCharacters ( Brown , 13a_Brown ) ;
15076: LD_EXP 24
15080: PPUSH
15081: LD_STRING 13a_Brown
15083: PPUSH
15084: CALL_OW 38
// if IsOk ( Gladstone ) then
15088: LD_EXP 25
15092: PPUSH
15093: CALL_OW 302
15097: IFFALSE 15111
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
15099: LD_EXP 25
15103: PPUSH
15104: LD_STRING 13a_Gladstone
15106: PPUSH
15107: CALL_OW 38
// if IsOk ( Houten ) then
15111: LD_EXP 26
15115: PPUSH
15116: CALL_OW 302
15120: IFFALSE 15134
// SaveCharacters ( Houten , 13a_Houten ) ;
15122: LD_EXP 26
15126: PPUSH
15127: LD_STRING 13a_Houten
15129: PPUSH
15130: CALL_OW 38
// if IsOk ( Cornel ) then
15134: LD_EXP 27
15138: PPUSH
15139: CALL_OW 302
15143: IFFALSE 15157
// SaveCharacters ( Cornel , 13a_Cornel ) ;
15145: LD_EXP 27
15149: PPUSH
15150: LD_STRING 13a_Cornel
15152: PPUSH
15153: CALL_OW 38
// if IsOk ( Gary ) then
15157: LD_EXP 28
15161: PPUSH
15162: CALL_OW 302
15166: IFFALSE 15180
// SaveCharacters ( Gary , 13a_Gary ) ;
15168: LD_EXP 28
15172: PPUSH
15173: LD_STRING 13a_Gary
15175: PPUSH
15176: CALL_OW 38
// if IsOk ( Frank ) then
15180: LD_EXP 29
15184: PPUSH
15185: CALL_OW 302
15189: IFFALSE 15203
// SaveCharacters ( Frank , 13a_Frank ) ;
15191: LD_EXP 29
15195: PPUSH
15196: LD_STRING 13a_Frank
15198: PPUSH
15199: CALL_OW 38
// if IsOk ( Kikuchi ) then
15203: LD_EXP 30
15207: PPUSH
15208: CALL_OW 302
15212: IFFALSE 15226
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
15214: LD_EXP 30
15218: PPUSH
15219: LD_STRING 13a_Kikuchi
15221: PPUSH
15222: CALL_OW 38
// if IsOk ( Simms ) then
15226: LD_EXP 31
15230: PPUSH
15231: CALL_OW 302
15235: IFFALSE 15249
// SaveCharacters ( Simms , 13a_Simms ) ;
15237: LD_EXP 31
15241: PPUSH
15242: LD_STRING 13a_Simms
15244: PPUSH
15245: CALL_OW 38
// if IsOk ( Joan ) then
15249: LD_EXP 32
15253: PPUSH
15254: CALL_OW 302
15258: IFFALSE 15272
// SaveCharacters ( Joan , 13a_Joan ) ;
15260: LD_EXP 32
15264: PPUSH
15265: LD_STRING 13a_Joan
15267: PPUSH
15268: CALL_OW 38
// if IsOk ( DeltaDoctor ) then
15272: LD_EXP 33
15276: PPUSH
15277: CALL_OW 302
15281: IFFALSE 15295
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
15283: LD_EXP 33
15287: PPUSH
15288: LD_STRING 13a_DeltaDoctor
15290: PPUSH
15291: CALL_OW 38
// if IsOk ( Gossudarov ) then
15295: LD_EXP 35
15299: PPUSH
15300: CALL_OW 302
15304: IFFALSE 15318
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
15306: LD_EXP 35
15310: PPUSH
15311: LD_STRING 13a_Gossudarov
15313: PPUSH
15314: CALL_OW 38
// if IsOk ( Kirilenkova ) then
15318: LD_EXP 36
15322: PPUSH
15323: CALL_OW 302
15327: IFFALSE 15341
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
15329: LD_EXP 36
15333: PPUSH
15334: LD_STRING 13a_Kirilenkova
15336: PPUSH
15337: CALL_OW 38
// if IsOk ( Roth ) then
15341: LD_EXP 18
15345: PPUSH
15346: CALL_OW 302
15350: IFFALSE 15364
// SaveCharacters ( Roth , 13a_Roth ) ;
15352: LD_EXP 18
15356: PPUSH
15357: LD_STRING 13a_Roth
15359: PPUSH
15360: CALL_OW 38
// if Masha then
15364: LD_EXP 52
15368: IFFALSE 15423
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
15370: LD_EXP 52
15374: PPUSH
15375: CALL_OW 265
15379: PUSH
15380: LD_EXP 52
15384: PPUSH
15385: CALL_OW 262
15389: PUSH
15390: LD_EXP 52
15394: PPUSH
15395: CALL_OW 263
15399: PUSH
15400: LD_EXP 52
15404: PPUSH
15405: CALL_OW 264
15409: PUSH
15410: EMPTY
15411: LIST
15412: LIST
15413: LIST
15414: LIST
15415: PPUSH
15416: LD_STRING 13a_Masha
15418: PPUSH
15419: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
15423: LD_ADDR_VAR 0 2
15427: PUSH
15428: LD_INT 21
15430: PUSH
15431: LD_INT 3
15433: PUSH
15434: EMPTY
15435: LIST
15436: LIST
15437: PPUSH
15438: CALL_OW 69
15442: ST_TO_ADDR
// tmp2 := [ ] ;
15443: LD_ADDR_VAR 0 3
15447: PUSH
15448: EMPTY
15449: ST_TO_ADDR
// if tmp then
15450: LD_VAR 0 2
15454: IFFALSE 15605
// for i in tmp do
15456: LD_ADDR_VAR 0 1
15460: PUSH
15461: LD_VAR 0 2
15465: PUSH
15466: FOR_IN
15467: IFFALSE 15603
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
15469: LD_ADDR_VAR 0 3
15473: PUSH
15474: LD_VAR 0 3
15478: PUSH
15479: LD_VAR 0 1
15483: PPUSH
15484: CALL_OW 255
15488: PUSH
15489: LD_VAR 0 1
15493: PPUSH
15494: CALL_OW 248
15498: PUSH
15499: LD_VAR 0 1
15503: PPUSH
15504: CALL_OW 266
15508: PUSH
15509: LD_VAR 0 1
15513: PPUSH
15514: CALL_OW 250
15518: PUSH
15519: LD_VAR 0 1
15523: PPUSH
15524: CALL_OW 251
15528: PUSH
15529: LD_VAR 0 1
15533: PPUSH
15534: CALL_OW 254
15538: PUSH
15539: LD_VAR 0 1
15543: PPUSH
15544: CALL_OW 267
15548: PUSH
15549: LD_VAR 0 1
15553: PPUSH
15554: LD_INT 1
15556: PPUSH
15557: CALL_OW 268
15561: PUSH
15562: LD_VAR 0 1
15566: PPUSH
15567: LD_INT 2
15569: PPUSH
15570: CALL_OW 268
15574: PUSH
15575: LD_VAR 0 1
15579: PPUSH
15580: CALL_OW 269
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: LIST
15589: LIST
15590: LIST
15591: LIST
15592: LIST
15593: LIST
15594: LIST
15595: LIST
15596: PUSH
15597: EMPTY
15598: LIST
15599: ADD
15600: ST_TO_ADDR
15601: GO 15466
15603: POP
15604: POP
// if tmp2 then
15605: LD_VAR 0 3
15609: IFFALSE 15623
// SaveVariable ( tmp2 , 13a_buildings ) ;
15611: LD_VAR 0 3
15615: PPUSH
15616: LD_STRING 13a_buildings
15618: PPUSH
15619: CALL_OW 39
// YouWin ;
15623: CALL_OW 103
// end ;
15627: PPOPN 6
15629: END
// export function SciRu ; var tmp , t ; begin
15630: LD_INT 0
15632: PPUSH
15633: PPUSH
15634: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
15635: LD_ADDR_VAR 0 3
15639: PUSH
15640: LD_EXP 35
15644: PUSH
15645: LD_EXP 49
15649: PUSH
15650: LD_EXP 37
15654: PUSH
15655: LD_EXP 50
15659: PUSH
15660: LD_EXP 51
15664: PUSH
15665: LD_EXP 40
15669: PUSH
15670: LD_EXP 41
15674: PUSH
15675: LD_EXP 39
15679: PUSH
15680: EMPTY
15681: LIST
15682: LIST
15683: LIST
15684: LIST
15685: LIST
15686: LIST
15687: LIST
15688: LIST
15689: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
15690: LD_ADDR_VAR 0 2
15694: PUSH
15695: LD_INT 22
15697: PUSH
15698: LD_INT 7
15700: PUSH
15701: EMPTY
15702: LIST
15703: LIST
15704: PUSH
15705: LD_INT 23
15707: PUSH
15708: LD_INT 3
15710: PUSH
15711: EMPTY
15712: LIST
15713: LIST
15714: PUSH
15715: LD_INT 25
15717: PUSH
15718: LD_INT 4
15720: PUSH
15721: EMPTY
15722: LIST
15723: LIST
15724: PUSH
15725: LD_INT 26
15727: PUSH
15728: LD_INT 1
15730: PUSH
15731: EMPTY
15732: LIST
15733: LIST
15734: PUSH
15735: EMPTY
15736: LIST
15737: LIST
15738: LIST
15739: LIST
15740: PPUSH
15741: CALL_OW 69
15745: PUSH
15746: LD_VAR 0 3
15750: DIFF
15751: ST_TO_ADDR
// if tmp then
15752: LD_VAR 0 2
15756: IFFALSE 15772
// result := tmp [ 1 ] ;
15758: LD_ADDR_VAR 0 1
15762: PUSH
15763: LD_VAR 0 2
15767: PUSH
15768: LD_INT 1
15770: ARRAY
15771: ST_TO_ADDR
// end ;
15772: LD_VAR 0 1
15776: RET
// export function SolRu ; var tmp , t ; begin
15777: LD_INT 0
15779: PPUSH
15780: PPUSH
15781: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
15782: LD_ADDR_VAR 0 3
15786: PUSH
15787: LD_EXP 35
15791: PUSH
15792: LD_EXP 49
15796: PUSH
15797: LD_EXP 37
15801: PUSH
15802: LD_EXP 50
15806: PUSH
15807: LD_EXP 51
15811: PUSH
15812: LD_EXP 40
15816: PUSH
15817: LD_EXP 41
15821: PUSH
15822: LD_EXP 39
15826: PUSH
15827: EMPTY
15828: LIST
15829: LIST
15830: LIST
15831: LIST
15832: LIST
15833: LIST
15834: LIST
15835: LIST
15836: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
15837: LD_ADDR_VAR 0 2
15841: PUSH
15842: LD_INT 22
15844: PUSH
15845: LD_INT 7
15847: PUSH
15848: EMPTY
15849: LIST
15850: LIST
15851: PUSH
15852: LD_INT 23
15854: PUSH
15855: LD_INT 3
15857: PUSH
15858: EMPTY
15859: LIST
15860: LIST
15861: PUSH
15862: LD_INT 25
15864: PUSH
15865: LD_INT 1
15867: PUSH
15868: EMPTY
15869: LIST
15870: LIST
15871: PUSH
15872: LD_INT 26
15874: PUSH
15875: LD_INT 1
15877: PUSH
15878: EMPTY
15879: LIST
15880: LIST
15881: PUSH
15882: EMPTY
15883: LIST
15884: LIST
15885: LIST
15886: LIST
15887: PPUSH
15888: CALL_OW 69
15892: PUSH
15893: LD_VAR 0 3
15897: DIFF
15898: ST_TO_ADDR
// if tmp then
15899: LD_VAR 0 2
15903: IFFALSE 15919
// result := tmp [ 1 ] ;
15905: LD_ADDR_VAR 0 1
15909: PUSH
15910: LD_VAR 0 2
15914: PUSH
15915: LD_INT 1
15917: ARRAY
15918: ST_TO_ADDR
// end ; end_of_file
15919: LD_VAR 0 1
15923: RET
// export function CustomEvent ( event ) ; begin
15924: LD_INT 0
15926: PPUSH
// end ;
15927: LD_VAR 0 2
15931: RET
// on UnitDestroyed ( un ) do var i , side ;
15932: LD_INT 0
15934: PPUSH
15935: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
15936: LD_VAR 0 1
15940: PPUSH
15941: CALL 106578 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
15945: LD_VAR 0 1
15949: PUSH
15950: LD_INT 22
15952: PUSH
15953: LD_INT 7
15955: PUSH
15956: EMPTY
15957: LIST
15958: LIST
15959: PUSH
15960: LD_INT 2
15962: PUSH
15963: LD_INT 25
15965: PUSH
15966: LD_INT 1
15968: PUSH
15969: EMPTY
15970: LIST
15971: LIST
15972: PUSH
15973: LD_INT 25
15975: PUSH
15976: LD_INT 2
15978: PUSH
15979: EMPTY
15980: LIST
15981: LIST
15982: PUSH
15983: LD_INT 25
15985: PUSH
15986: LD_INT 3
15988: PUSH
15989: EMPTY
15990: LIST
15991: LIST
15992: PUSH
15993: LD_INT 25
15995: PUSH
15996: LD_INT 4
15998: PUSH
15999: EMPTY
16000: LIST
16001: LIST
16002: PUSH
16003: LD_INT 25
16005: PUSH
16006: LD_INT 5
16008: PUSH
16009: EMPTY
16010: LIST
16011: LIST
16012: PUSH
16013: LD_INT 25
16015: PUSH
16016: LD_INT 8
16018: PUSH
16019: EMPTY
16020: LIST
16021: LIST
16022: PUSH
16023: LD_INT 25
16025: PUSH
16026: LD_INT 9
16028: PUSH
16029: EMPTY
16030: LIST
16031: LIST
16032: PUSH
16033: EMPTY
16034: LIST
16035: LIST
16036: LIST
16037: LIST
16038: LIST
16039: LIST
16040: LIST
16041: LIST
16042: PUSH
16043: EMPTY
16044: LIST
16045: LIST
16046: PPUSH
16047: CALL_OW 69
16051: IN
16052: IFFALSE 16068
// loss_counter := loss_counter + 1 ;
16054: LD_ADDR_EXP 15
16058: PUSH
16059: LD_EXP 15
16063: PUSH
16064: LD_INT 1
16066: PLUS
16067: ST_TO_ADDR
// if un = Abdul then
16068: LD_VAR 0 1
16072: PUSH
16073: LD_EXP 58
16077: EQUAL
16078: IFFALSE 16088
// abdul_escaped := false ;
16080: LD_ADDR_EXP 14
16084: PUSH
16085: LD_INT 0
16087: ST_TO_ADDR
// if un in ru_attackers then
16088: LD_VAR 0 1
16092: PUSH
16093: LD_EXP 55
16097: IN
16098: IFFALSE 16116
// ru_attackers := ru_attackers diff un ;
16100: LD_ADDR_EXP 55
16104: PUSH
16105: LD_EXP 55
16109: PUSH
16110: LD_VAR 0 1
16114: DIFF
16115: ST_TO_ADDR
// if un in ar_attackers then
16116: LD_VAR 0 1
16120: PUSH
16121: LD_EXP 12
16125: IN
16126: IFFALSE 16144
// ar_attackers := ar_attackers diff un ;
16128: LD_ADDR_EXP 12
16132: PUSH
16133: LD_EXP 12
16137: PUSH
16138: LD_VAR 0 1
16142: DIFF
16143: ST_TO_ADDR
// if un = JMM then
16144: LD_VAR 0 1
16148: PUSH
16149: LD_EXP 17
16153: EQUAL
16154: IFFALSE 16165
// begin YouLost ( JMM ) ;
16156: LD_STRING JMM
16158: PPUSH
16159: CALL_OW 104
// exit ;
16163: GO 16262
// end ; if un = Burlak then
16165: LD_VAR 0 1
16169: PUSH
16170: LD_EXP 49
16174: EQUAL
16175: IFFALSE 16186
// begin YouLost ( Burlak ) ;
16177: LD_STRING Burlak
16179: PPUSH
16180: CALL_OW 104
// exit ;
16184: GO 16262
// end ; if un = freedom then
16186: LD_VAR 0 1
16190: PUSH
16191: LD_EXP 3
16195: EQUAL
16196: IFFALSE 16207
// begin YouLost ( Destroyed ) ;
16198: LD_STRING Destroyed
16200: PPUSH
16201: CALL_OW 104
// exit ;
16205: GO 16262
// end ; if un = Masha then
16207: LD_VAR 0 1
16211: PUSH
16212: LD_EXP 52
16216: EQUAL
16217: IFFALSE 16234
// begin ChangeMissionObjectives ( M4b ) ;
16219: LD_STRING M4b
16221: PPUSH
16222: CALL_OW 337
// masha_killed := true ;
16226: LD_ADDR_EXP 11
16230: PUSH
16231: LD_INT 1
16233: ST_TO_ADDR
// end ; if un = Mastodont then
16234: LD_VAR 0 1
16238: PUSH
16239: LD_EXP 59
16243: EQUAL
16244: IFFALSE 16253
// ChangeMissionObjectives ( M4a ) ;
16246: LD_STRING M4a
16248: PPUSH
16249: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
16253: LD_VAR 0 1
16257: PPUSH
16258: CALL 87775 0 1
// end ;
16262: PPOPN 3
16264: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16265: LD_VAR 0 1
16269: PPUSH
16270: LD_VAR 0 2
16274: PPUSH
16275: CALL 90107 0 2
// end ;
16279: PPOPN 2
16281: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
16282: LD_VAR 0 1
16286: PPUSH
16287: CALL 89175 0 1
// end ;
16291: PPOPN 1
16293: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
16294: LD_VAR 0 1
16298: PUSH
16299: LD_INT 22
16301: PUSH
16302: LD_INT 7
16304: PUSH
16305: EMPTY
16306: LIST
16307: LIST
16308: PUSH
16309: LD_INT 30
16311: PUSH
16312: LD_INT 0
16314: PUSH
16315: EMPTY
16316: LIST
16317: LIST
16318: PUSH
16319: EMPTY
16320: LIST
16321: LIST
16322: PPUSH
16323: CALL_OW 69
16327: IN
16328: IFFALSE 16367
// begin SetBName ( building , freedom ) ;
16330: LD_VAR 0 1
16334: PPUSH
16335: LD_STRING freedom
16337: PPUSH
16338: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
16342: LD_INT 0
16344: PPUSH
16345: LD_INT 7
16347: PPUSH
16348: LD_INT 0
16350: PPUSH
16351: CALL_OW 324
// freedom := building ;
16355: LD_ADDR_EXP 3
16359: PUSH
16360: LD_VAR 0 1
16364: ST_TO_ADDR
// exit ;
16365: GO 16433
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
16367: LD_VAR 0 1
16371: PUSH
16372: LD_INT 22
16374: PUSH
16375: LD_INT 7
16377: PUSH
16378: EMPTY
16379: LIST
16380: LIST
16381: PUSH
16382: LD_INT 23
16384: PUSH
16385: LD_INT 3
16387: PUSH
16388: EMPTY
16389: LIST
16390: LIST
16391: PUSH
16392: LD_INT 30
16394: PUSH
16395: LD_INT 6
16397: PUSH
16398: EMPTY
16399: LIST
16400: LIST
16401: PUSH
16402: EMPTY
16403: LIST
16404: LIST
16405: LIST
16406: PPUSH
16407: CALL_OW 69
16411: IN
16412: IFFALSE 16424
// begin ru_lab_builded := true ;
16414: LD_ADDR_EXP 5
16418: PUSH
16419: LD_INT 1
16421: ST_TO_ADDR
// exit ;
16422: GO 16433
// end ; MCE_BuildingComplete ( building ) ;
16424: LD_VAR 0 1
16428: PPUSH
16429: CALL 89416 0 1
// end ;
16433: PPOPN 1
16435: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
16436: LD_VAR 0 1
16440: PPUSH
16441: LD_VAR 0 2
16445: PPUSH
16446: CALL 87471 0 2
// end ;
16450: PPOPN 2
16452: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16453: LD_VAR 0 1
16457: PPUSH
16458: LD_VAR 0 2
16462: PPUSH
16463: LD_VAR 0 3
16467: PPUSH
16468: LD_VAR 0 4
16472: PPUSH
16473: LD_VAR 0 5
16477: PPUSH
16478: CALL 87091 0 5
// end ;
16482: PPOPN 5
16484: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
16485: LD_VAR 0 1
16489: PPUSH
16490: LD_VAR 0 2
16494: PPUSH
16495: CALL 106698 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
16499: LD_VAR 0 1
16503: PPUSH
16504: LD_VAR 0 2
16508: PPUSH
16509: CALL 86644 0 2
// end ;
16513: PPOPN 2
16515: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
16516: LD_VAR 0 1
16520: PPUSH
16521: CALL_OW 263
16525: PUSH
16526: LD_INT 3
16528: EQUAL
16529: PUSH
16530: LD_VAR 0 2
16534: PPUSH
16535: CALL_OW 263
16539: PUSH
16540: LD_INT 3
16542: EQUAL
16543: OR
16544: IFFALSE 16560
// hack_counter := hack_counter + 1 ;
16546: LD_ADDR_EXP 16
16550: PUSH
16551: LD_EXP 16
16555: PUSH
16556: LD_INT 1
16558: PLUS
16559: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
16560: LD_VAR 0 1
16564: PPUSH
16565: LD_VAR 0 2
16569: PPUSH
16570: LD_VAR 0 3
16574: PPUSH
16575: LD_VAR 0 4
16579: PPUSH
16580: CALL 86482 0 4
// end ;
16584: PPOPN 4
16586: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin if building = ru_depot then
16587: LD_VAR 0 1
16591: PUSH
16592: LD_INT 47
16594: EQUAL
16595: IFFALSE 16617
// SetResourceType ( GetBase ( building ) , mat_cans , 600 ) ;
16597: LD_VAR 0 1
16601: PPUSH
16602: CALL_OW 274
16606: PPUSH
16607: LD_INT 1
16609: PPUSH
16610: LD_INT 600
16612: PPUSH
16613: CALL_OW 277
// MCE_BuildingCaptured ( building , side , capturning_unit ) ;
16617: LD_VAR 0 1
16621: PPUSH
16622: LD_VAR 0 2
16626: PPUSH
16627: LD_VAR 0 3
16631: PPUSH
16632: CALL 86257 0 3
// end ;
16636: PPOPN 3
16638: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
16639: LD_VAR 0 1
16643: PPUSH
16644: LD_VAR 0 2
16648: PPUSH
16649: CALL 86142 0 2
// end ;
16653: PPOPN 2
16655: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
16656: LD_VAR 0 1
16660: PPUSH
16661: LD_VAR 0 2
16665: PPUSH
16666: CALL 90402 0 2
// end ;
16670: PPOPN 2
16672: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
16673: LD_VAR 0 1
16677: PPUSH
16678: LD_VAR 0 2
16682: PPUSH
16683: LD_VAR 0 3
16687: PPUSH
16688: LD_VAR 0 4
16692: PPUSH
16693: CALL 90618 0 4
// end ;
16697: PPOPN 4
16699: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
16700: LD_VAR 0 1
16704: PPUSH
16705: LD_VAR 0 2
16709: PPUSH
16710: CALL 85951 0 2
// end ;
16714: PPOPN 2
16716: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
16717: LD_VAR 0 1
16721: PPUSH
16722: CALL 106682 0 1
// end ; end_of_file
16726: PPOPN 1
16728: END
// every 0 0$30 do var cr , time ;
16729: GO 16731
16731: DISABLE
16732: LD_INT 0
16734: PPUSH
16735: PPUSH
// begin time := 0 0$20 ;
16736: LD_ADDR_VAR 0 2
16740: PUSH
16741: LD_INT 700
16743: ST_TO_ADDR
// while game do
16744: LD_EXP 2
16748: IFFALSE 16851
// begin wait ( time ) ;
16750: LD_VAR 0 2
16754: PPUSH
16755: CALL_OW 67
// if tick > 2 2$00 then
16759: LD_OWVAR 1
16763: PUSH
16764: LD_INT 4200
16766: GREATER
16767: IFFALSE 16804
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
16769: LD_ADDR_VAR 0 2
16773: PUSH
16774: LD_VAR 0 2
16778: PUSH
16779: LD_INT 140
16781: PUSH
16782: LD_INT 140
16784: PUSH
16785: LD_INT 210
16787: PUSH
16788: LD_INT 280
16790: PUSH
16791: EMPTY
16792: LIST
16793: LIST
16794: LIST
16795: LIST
16796: PUSH
16797: LD_OWVAR 67
16801: ARRAY
16802: PLUS
16803: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
16804: LD_INT 1
16806: PPUSH
16807: LD_INT 5
16809: PPUSH
16810: CALL_OW 12
16814: PPUSH
16815: LD_INT 70
16817: PPUSH
16818: LD_INT 49
16820: PPUSH
16821: LD_INT 25
16823: PPUSH
16824: LD_INT 1
16826: PPUSH
16827: CALL_OW 56
// if time > 3 3$00 then
16831: LD_VAR 0 2
16835: PUSH
16836: LD_INT 6300
16838: GREATER
16839: IFFALSE 16849
// time := 0 0$30 ;
16841: LD_ADDR_VAR 0 2
16845: PUSH
16846: LD_INT 1050
16848: ST_TO_ADDR
// end ;
16849: GO 16744
// end ;
16851: PPOPN 2
16853: END
// every 0 0$30 do var cr , time ;
16854: GO 16856
16856: DISABLE
16857: LD_INT 0
16859: PPUSH
16860: PPUSH
// begin time := 0 0$20 ;
16861: LD_ADDR_VAR 0 2
16865: PUSH
16866: LD_INT 700
16868: ST_TO_ADDR
// while game do
16869: LD_EXP 2
16873: IFFALSE 16966
// begin wait ( time ) ;
16875: LD_VAR 0 2
16879: PPUSH
16880: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
16884: LD_ADDR_VAR 0 2
16888: PUSH
16889: LD_VAR 0 2
16893: PUSH
16894: LD_INT 140
16896: PUSH
16897: LD_INT 175
16899: PUSH
16900: LD_INT 210
16902: PUSH
16903: LD_INT 280
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: LIST
16910: LIST
16911: PUSH
16912: LD_OWVAR 67
16916: ARRAY
16917: PLUS
16918: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
16919: LD_INT 3
16921: PPUSH
16922: LD_INT 5
16924: PPUSH
16925: CALL_OW 12
16929: PPUSH
16930: LD_INT 26
16932: PPUSH
16933: LD_INT 9
16935: PPUSH
16936: LD_INT 30
16938: PPUSH
16939: LD_INT 1
16941: PPUSH
16942: CALL_OW 56
// if time > 3 3$00 then
16946: LD_VAR 0 2
16950: PUSH
16951: LD_INT 6300
16953: GREATER
16954: IFFALSE 16964
// time := 0 0$20 ;
16956: LD_ADDR_VAR 0 2
16960: PUSH
16961: LD_INT 700
16963: ST_TO_ADDR
// end ;
16964: GO 16869
// end ;
16966: PPOPN 2
16968: END
// every 0 0$30 do var cr , time ;
16969: GO 16971
16971: DISABLE
16972: LD_INT 0
16974: PPUSH
16975: PPUSH
// begin time := 0 0$20 ;
16976: LD_ADDR_VAR 0 2
16980: PUSH
16981: LD_INT 700
16983: ST_TO_ADDR
// while game do
16984: LD_EXP 2
16988: IFFALSE 17117
// begin wait ( time ) ;
16990: LD_VAR 0 2
16994: PPUSH
16995: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
16999: LD_ADDR_VAR 0 2
17003: PUSH
17004: LD_VAR 0 2
17008: PUSH
17009: LD_INT 175
17011: PUSH
17012: LD_INT 210
17014: PUSH
17015: LD_INT 280
17017: PUSH
17018: LD_INT 350
17020: PUSH
17021: EMPTY
17022: LIST
17023: LIST
17024: LIST
17025: LIST
17026: PUSH
17027: LD_OWVAR 67
17031: ARRAY
17032: PLUS
17033: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
17034: LD_INT 1
17036: PPUSH
17037: LD_INT 5
17039: PPUSH
17040: CALL_OW 12
17044: PPUSH
17045: LD_INT 179
17047: PPUSH
17048: LD_INT 101
17050: PPUSH
17051: LD_INT 20
17053: PPUSH
17054: LD_INT 1
17056: PPUSH
17057: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17061: LD_INT 350
17063: PPUSH
17064: LD_INT 525
17066: PPUSH
17067: CALL_OW 12
17071: PPUSH
17072: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
17076: LD_INT 1
17078: PPUSH
17079: LD_INT 5
17081: PPUSH
17082: CALL_OW 12
17086: PPUSH
17087: LD_INT 9
17089: PPUSH
17090: LD_INT 1
17092: PPUSH
17093: CALL_OW 55
// if time > 4 4$00 then
17097: LD_VAR 0 2
17101: PUSH
17102: LD_INT 8400
17104: GREATER
17105: IFFALSE 17115
// time := 0 0$30 ;
17107: LD_ADDR_VAR 0 2
17111: PUSH
17112: LD_INT 1050
17114: ST_TO_ADDR
// end ;
17115: GO 16984
// end ;
17117: PPOPN 2
17119: END
// every 0 0$30 do var cr , time ;
17120: GO 17122
17122: DISABLE
17123: LD_INT 0
17125: PPUSH
17126: PPUSH
// begin time := 0 0$10 ;
17127: LD_ADDR_VAR 0 2
17131: PUSH
17132: LD_INT 350
17134: ST_TO_ADDR
// while game do
17135: LD_EXP 2
17139: IFFALSE 17273
// begin wait ( time ) ;
17141: LD_VAR 0 2
17145: PPUSH
17146: CALL_OW 67
// time := time + 0 0$10 ;
17150: LD_ADDR_VAR 0 2
17154: PUSH
17155: LD_VAR 0 2
17159: PUSH
17160: LD_INT 350
17162: PLUS
17163: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
17164: LD_INT 1
17166: PPUSH
17167: LD_INT 5
17169: PPUSH
17170: CALL_OW 12
17174: PPUSH
17175: LD_INT 11
17177: PPUSH
17178: LD_INT 1
17180: PPUSH
17181: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
17185: LD_ADDR_VAR 0 1
17189: PUSH
17190: LD_INT 1
17192: PPUSH
17193: LD_INT 3
17195: PPUSH
17196: CALL_OW 12
17200: ST_TO_ADDR
// if cr = 1 then
17201: LD_VAR 0 1
17205: PUSH
17206: LD_INT 1
17208: EQUAL
17209: IFFALSE 17253
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
17211: LD_INT 700
17213: PPUSH
17214: LD_INT 1575
17216: PPUSH
17217: CALL_OW 12
17221: PPUSH
17222: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
17226: LD_INT 1
17228: PPUSH
17229: LD_INT 5
17231: PPUSH
17232: CALL_OW 12
17236: PPUSH
17237: LD_INT 34
17239: PPUSH
17240: LD_INT 50
17242: PPUSH
17243: LD_INT 7
17245: PPUSH
17246: LD_INT 1
17248: PPUSH
17249: CALL_OW 56
// end ; if time > 4 4$00 then
17253: LD_VAR 0 2
17257: PUSH
17258: LD_INT 8400
17260: GREATER
17261: IFFALSE 17271
// time := 0 0$40 ;
17263: LD_ADDR_VAR 0 2
17267: PUSH
17268: LD_INT 1400
17270: ST_TO_ADDR
// end ;
17271: GO 17135
// end ; end_of_file
17273: PPOPN 2
17275: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
17276: LD_INT 0
17278: PPUSH
17279: PPUSH
// if exist_mode then
17280: LD_VAR 0 2
17284: IFFALSE 17309
// unit := CreateCharacter ( prefix & ident ) else
17286: LD_ADDR_VAR 0 5
17290: PUSH
17291: LD_VAR 0 3
17295: PUSH
17296: LD_VAR 0 1
17300: STR
17301: PPUSH
17302: CALL_OW 34
17306: ST_TO_ADDR
17307: GO 17324
// unit := NewCharacter ( ident ) ;
17309: LD_ADDR_VAR 0 5
17313: PUSH
17314: LD_VAR 0 1
17318: PPUSH
17319: CALL_OW 25
17323: ST_TO_ADDR
// result := unit ;
17324: LD_ADDR_VAR 0 4
17328: PUSH
17329: LD_VAR 0 5
17333: ST_TO_ADDR
// end ;
17334: LD_VAR 0 4
17338: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
17339: LD_INT 0
17341: PPUSH
17342: PPUSH
// if not side or not nation then
17343: LD_VAR 0 1
17347: NOT
17348: PUSH
17349: LD_VAR 0 2
17353: NOT
17354: OR
17355: IFFALSE 17359
// exit ;
17357: GO 18127
// case nation of nation_american :
17359: LD_VAR 0 2
17363: PUSH
17364: LD_INT 1
17366: DOUBLE
17367: EQUAL
17368: IFTRUE 17372
17370: GO 17586
17372: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
17373: LD_ADDR_VAR 0 4
17377: PUSH
17378: LD_INT 35
17380: PUSH
17381: LD_INT 45
17383: PUSH
17384: LD_INT 46
17386: PUSH
17387: LD_INT 47
17389: PUSH
17390: LD_INT 82
17392: PUSH
17393: LD_INT 83
17395: PUSH
17396: LD_INT 84
17398: PUSH
17399: LD_INT 85
17401: PUSH
17402: LD_INT 86
17404: PUSH
17405: LD_INT 1
17407: PUSH
17408: LD_INT 2
17410: PUSH
17411: LD_INT 6
17413: PUSH
17414: LD_INT 15
17416: PUSH
17417: LD_INT 16
17419: PUSH
17420: LD_INT 7
17422: PUSH
17423: LD_INT 12
17425: PUSH
17426: LD_INT 13
17428: PUSH
17429: LD_INT 10
17431: PUSH
17432: LD_INT 14
17434: PUSH
17435: LD_INT 20
17437: PUSH
17438: LD_INT 21
17440: PUSH
17441: LD_INT 22
17443: PUSH
17444: LD_INT 25
17446: PUSH
17447: LD_INT 32
17449: PUSH
17450: LD_INT 27
17452: PUSH
17453: LD_INT 36
17455: PUSH
17456: LD_INT 69
17458: PUSH
17459: LD_INT 39
17461: PUSH
17462: LD_INT 34
17464: PUSH
17465: LD_INT 40
17467: PUSH
17468: LD_INT 48
17470: PUSH
17471: LD_INT 49
17473: PUSH
17474: LD_INT 50
17476: PUSH
17477: LD_INT 51
17479: PUSH
17480: LD_INT 52
17482: PUSH
17483: LD_INT 53
17485: PUSH
17486: LD_INT 54
17488: PUSH
17489: LD_INT 55
17491: PUSH
17492: LD_INT 56
17494: PUSH
17495: LD_INT 57
17497: PUSH
17498: LD_INT 58
17500: PUSH
17501: LD_INT 59
17503: PUSH
17504: LD_INT 60
17506: PUSH
17507: LD_INT 61
17509: PUSH
17510: LD_INT 62
17512: PUSH
17513: LD_INT 80
17515: PUSH
17516: LD_INT 82
17518: PUSH
17519: LD_INT 83
17521: PUSH
17522: LD_INT 84
17524: PUSH
17525: LD_INT 85
17527: PUSH
17528: LD_INT 86
17530: PUSH
17531: EMPTY
17532: LIST
17533: LIST
17534: LIST
17535: LIST
17536: LIST
17537: LIST
17538: LIST
17539: LIST
17540: LIST
17541: LIST
17542: LIST
17543: LIST
17544: LIST
17545: LIST
17546: LIST
17547: LIST
17548: LIST
17549: LIST
17550: LIST
17551: LIST
17552: LIST
17553: LIST
17554: LIST
17555: LIST
17556: LIST
17557: LIST
17558: LIST
17559: LIST
17560: LIST
17561: LIST
17562: LIST
17563: LIST
17564: LIST
17565: LIST
17566: LIST
17567: LIST
17568: LIST
17569: LIST
17570: LIST
17571: LIST
17572: LIST
17573: LIST
17574: LIST
17575: LIST
17576: LIST
17577: LIST
17578: LIST
17579: LIST
17580: LIST
17581: LIST
17582: LIST
17583: ST_TO_ADDR
17584: GO 18051
17586: LD_INT 2
17588: DOUBLE
17589: EQUAL
17590: IFTRUE 17594
17592: GO 17820
17594: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
17595: LD_ADDR_VAR 0 4
17599: PUSH
17600: LD_INT 35
17602: PUSH
17603: LD_INT 45
17605: PUSH
17606: LD_INT 46
17608: PUSH
17609: LD_INT 47
17611: PUSH
17612: LD_INT 82
17614: PUSH
17615: LD_INT 83
17617: PUSH
17618: LD_INT 84
17620: PUSH
17621: LD_INT 85
17623: PUSH
17624: LD_INT 87
17626: PUSH
17627: LD_INT 70
17629: PUSH
17630: LD_INT 1
17632: PUSH
17633: LD_INT 11
17635: PUSH
17636: LD_INT 3
17638: PUSH
17639: LD_INT 4
17641: PUSH
17642: LD_INT 5
17644: PUSH
17645: LD_INT 6
17647: PUSH
17648: LD_INT 15
17650: PUSH
17651: LD_INT 18
17653: PUSH
17654: LD_INT 7
17656: PUSH
17657: LD_INT 17
17659: PUSH
17660: LD_INT 8
17662: PUSH
17663: LD_INT 20
17665: PUSH
17666: LD_INT 21
17668: PUSH
17669: LD_INT 22
17671: PUSH
17672: LD_INT 72
17674: PUSH
17675: LD_INT 26
17677: PUSH
17678: LD_INT 69
17680: PUSH
17681: LD_INT 39
17683: PUSH
17684: LD_INT 40
17686: PUSH
17687: LD_INT 41
17689: PUSH
17690: LD_INT 42
17692: PUSH
17693: LD_INT 43
17695: PUSH
17696: LD_INT 48
17698: PUSH
17699: LD_INT 49
17701: PUSH
17702: LD_INT 50
17704: PUSH
17705: LD_INT 51
17707: PUSH
17708: LD_INT 52
17710: PUSH
17711: LD_INT 53
17713: PUSH
17714: LD_INT 54
17716: PUSH
17717: LD_INT 55
17719: PUSH
17720: LD_INT 56
17722: PUSH
17723: LD_INT 60
17725: PUSH
17726: LD_INT 61
17728: PUSH
17729: LD_INT 62
17731: PUSH
17732: LD_INT 66
17734: PUSH
17735: LD_INT 67
17737: PUSH
17738: LD_INT 68
17740: PUSH
17741: LD_INT 81
17743: PUSH
17744: LD_INT 82
17746: PUSH
17747: LD_INT 83
17749: PUSH
17750: LD_INT 84
17752: PUSH
17753: LD_INT 85
17755: PUSH
17756: LD_INT 87
17758: PUSH
17759: LD_INT 88
17761: PUSH
17762: EMPTY
17763: LIST
17764: LIST
17765: LIST
17766: LIST
17767: LIST
17768: LIST
17769: LIST
17770: LIST
17771: LIST
17772: LIST
17773: LIST
17774: LIST
17775: LIST
17776: LIST
17777: LIST
17778: LIST
17779: LIST
17780: LIST
17781: LIST
17782: LIST
17783: LIST
17784: LIST
17785: LIST
17786: LIST
17787: LIST
17788: LIST
17789: LIST
17790: LIST
17791: LIST
17792: LIST
17793: LIST
17794: LIST
17795: LIST
17796: LIST
17797: LIST
17798: LIST
17799: LIST
17800: LIST
17801: LIST
17802: LIST
17803: LIST
17804: LIST
17805: LIST
17806: LIST
17807: LIST
17808: LIST
17809: LIST
17810: LIST
17811: LIST
17812: LIST
17813: LIST
17814: LIST
17815: LIST
17816: LIST
17817: ST_TO_ADDR
17818: GO 18051
17820: LD_INT 3
17822: DOUBLE
17823: EQUAL
17824: IFTRUE 17828
17826: GO 18050
17828: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
17829: LD_ADDR_VAR 0 4
17833: PUSH
17834: LD_INT 46
17836: PUSH
17837: LD_INT 47
17839: PUSH
17840: LD_INT 1
17842: PUSH
17843: LD_INT 2
17845: PUSH
17846: LD_INT 82
17848: PUSH
17849: LD_INT 83
17851: PUSH
17852: LD_INT 84
17854: PUSH
17855: LD_INT 85
17857: PUSH
17858: LD_INT 86
17860: PUSH
17861: LD_INT 11
17863: PUSH
17864: LD_INT 9
17866: PUSH
17867: LD_INT 20
17869: PUSH
17870: LD_INT 19
17872: PUSH
17873: LD_INT 21
17875: PUSH
17876: LD_INT 24
17878: PUSH
17879: LD_INT 22
17881: PUSH
17882: LD_INT 25
17884: PUSH
17885: LD_INT 28
17887: PUSH
17888: LD_INT 29
17890: PUSH
17891: LD_INT 30
17893: PUSH
17894: LD_INT 31
17896: PUSH
17897: LD_INT 37
17899: PUSH
17900: LD_INT 38
17902: PUSH
17903: LD_INT 32
17905: PUSH
17906: LD_INT 27
17908: PUSH
17909: LD_INT 33
17911: PUSH
17912: LD_INT 69
17914: PUSH
17915: LD_INT 39
17917: PUSH
17918: LD_INT 34
17920: PUSH
17921: LD_INT 40
17923: PUSH
17924: LD_INT 71
17926: PUSH
17927: LD_INT 23
17929: PUSH
17930: LD_INT 44
17932: PUSH
17933: LD_INT 48
17935: PUSH
17936: LD_INT 49
17938: PUSH
17939: LD_INT 50
17941: PUSH
17942: LD_INT 51
17944: PUSH
17945: LD_INT 52
17947: PUSH
17948: LD_INT 53
17950: PUSH
17951: LD_INT 54
17953: PUSH
17954: LD_INT 55
17956: PUSH
17957: LD_INT 56
17959: PUSH
17960: LD_INT 57
17962: PUSH
17963: LD_INT 58
17965: PUSH
17966: LD_INT 59
17968: PUSH
17969: LD_INT 63
17971: PUSH
17972: LD_INT 64
17974: PUSH
17975: LD_INT 65
17977: PUSH
17978: LD_INT 82
17980: PUSH
17981: LD_INT 83
17983: PUSH
17984: LD_INT 84
17986: PUSH
17987: LD_INT 85
17989: PUSH
17990: LD_INT 86
17992: PUSH
17993: EMPTY
17994: LIST
17995: LIST
17996: LIST
17997: LIST
17998: LIST
17999: LIST
18000: LIST
18001: LIST
18002: LIST
18003: LIST
18004: LIST
18005: LIST
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: LIST
18017: LIST
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: LIST
18023: LIST
18024: LIST
18025: LIST
18026: LIST
18027: LIST
18028: LIST
18029: LIST
18030: LIST
18031: LIST
18032: LIST
18033: LIST
18034: LIST
18035: LIST
18036: LIST
18037: LIST
18038: LIST
18039: LIST
18040: LIST
18041: LIST
18042: LIST
18043: LIST
18044: LIST
18045: LIST
18046: LIST
18047: ST_TO_ADDR
18048: GO 18051
18050: POP
// if state > - 1 and state < 3 then
18051: LD_VAR 0 3
18055: PUSH
18056: LD_INT 1
18058: NEG
18059: GREATER
18060: PUSH
18061: LD_VAR 0 3
18065: PUSH
18066: LD_INT 3
18068: LESS
18069: AND
18070: IFFALSE 18127
// for i in result do
18072: LD_ADDR_VAR 0 5
18076: PUSH
18077: LD_VAR 0 4
18081: PUSH
18082: FOR_IN
18083: IFFALSE 18125
// if GetTech ( i , side ) <> state then
18085: LD_VAR 0 5
18089: PPUSH
18090: LD_VAR 0 1
18094: PPUSH
18095: CALL_OW 321
18099: PUSH
18100: LD_VAR 0 3
18104: NONEQUAL
18105: IFFALSE 18123
// result := result diff i ;
18107: LD_ADDR_VAR 0 4
18111: PUSH
18112: LD_VAR 0 4
18116: PUSH
18117: LD_VAR 0 5
18121: DIFF
18122: ST_TO_ADDR
18123: GO 18082
18125: POP
18126: POP
// end ;
18127: LD_VAR 0 4
18131: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
18132: LD_INT 0
18134: PPUSH
18135: PPUSH
18136: PPUSH
// result := true ;
18137: LD_ADDR_VAR 0 3
18141: PUSH
18142: LD_INT 1
18144: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
18145: LD_ADDR_VAR 0 5
18149: PUSH
18150: LD_VAR 0 2
18154: PPUSH
18155: CALL_OW 480
18159: ST_TO_ADDR
// if not tmp then
18160: LD_VAR 0 5
18164: NOT
18165: IFFALSE 18169
// exit ;
18167: GO 18218
// for i in tmp do
18169: LD_ADDR_VAR 0 4
18173: PUSH
18174: LD_VAR 0 5
18178: PUSH
18179: FOR_IN
18180: IFFALSE 18216
// if GetTech ( i , side ) <> state_researched then
18182: LD_VAR 0 4
18186: PPUSH
18187: LD_VAR 0 1
18191: PPUSH
18192: CALL_OW 321
18196: PUSH
18197: LD_INT 2
18199: NONEQUAL
18200: IFFALSE 18214
// begin result := false ;
18202: LD_ADDR_VAR 0 3
18206: PUSH
18207: LD_INT 0
18209: ST_TO_ADDR
// exit ;
18210: POP
18211: POP
18212: GO 18218
// end ;
18214: GO 18179
18216: POP
18217: POP
// end ;
18218: LD_VAR 0 3
18222: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
18223: LD_INT 0
18225: PPUSH
18226: PPUSH
18227: PPUSH
18228: PPUSH
18229: PPUSH
18230: PPUSH
18231: PPUSH
18232: PPUSH
18233: PPUSH
18234: PPUSH
18235: PPUSH
18236: PPUSH
18237: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
18238: LD_VAR 0 1
18242: NOT
18243: PUSH
18244: LD_VAR 0 1
18248: PPUSH
18249: CALL_OW 257
18253: PUSH
18254: LD_INT 9
18256: NONEQUAL
18257: OR
18258: IFFALSE 18262
// exit ;
18260: GO 18835
// side := GetSide ( unit ) ;
18262: LD_ADDR_VAR 0 9
18266: PUSH
18267: LD_VAR 0 1
18271: PPUSH
18272: CALL_OW 255
18276: ST_TO_ADDR
// tech_space := tech_spacanom ;
18277: LD_ADDR_VAR 0 12
18281: PUSH
18282: LD_INT 29
18284: ST_TO_ADDR
// tech_time := tech_taurad ;
18285: LD_ADDR_VAR 0 13
18289: PUSH
18290: LD_INT 28
18292: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
18293: LD_ADDR_VAR 0 11
18297: PUSH
18298: LD_VAR 0 1
18302: PPUSH
18303: CALL_OW 310
18307: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
18308: LD_VAR 0 11
18312: PPUSH
18313: CALL_OW 247
18317: PUSH
18318: LD_INT 2
18320: EQUAL
18321: IFFALSE 18325
// exit ;
18323: GO 18835
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18325: LD_ADDR_VAR 0 8
18329: PUSH
18330: LD_INT 81
18332: PUSH
18333: LD_VAR 0 9
18337: PUSH
18338: EMPTY
18339: LIST
18340: LIST
18341: PUSH
18342: LD_INT 3
18344: PUSH
18345: LD_INT 21
18347: PUSH
18348: LD_INT 3
18350: PUSH
18351: EMPTY
18352: LIST
18353: LIST
18354: PUSH
18355: EMPTY
18356: LIST
18357: LIST
18358: PUSH
18359: EMPTY
18360: LIST
18361: LIST
18362: PPUSH
18363: CALL_OW 69
18367: ST_TO_ADDR
// if not tmp then
18368: LD_VAR 0 8
18372: NOT
18373: IFFALSE 18377
// exit ;
18375: GO 18835
// if in_unit then
18377: LD_VAR 0 11
18381: IFFALSE 18405
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
18383: LD_ADDR_VAR 0 10
18387: PUSH
18388: LD_VAR 0 8
18392: PPUSH
18393: LD_VAR 0 11
18397: PPUSH
18398: CALL_OW 74
18402: ST_TO_ADDR
18403: GO 18425
// enemy := NearestUnitToUnit ( tmp , unit ) ;
18405: LD_ADDR_VAR 0 10
18409: PUSH
18410: LD_VAR 0 8
18414: PPUSH
18415: LD_VAR 0 1
18419: PPUSH
18420: CALL_OW 74
18424: ST_TO_ADDR
// if not enemy then
18425: LD_VAR 0 10
18429: NOT
18430: IFFALSE 18434
// exit ;
18432: GO 18835
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
18434: LD_VAR 0 11
18438: PUSH
18439: LD_VAR 0 11
18443: PPUSH
18444: LD_VAR 0 10
18448: PPUSH
18449: CALL_OW 296
18453: PUSH
18454: LD_INT 13
18456: GREATER
18457: AND
18458: PUSH
18459: LD_VAR 0 1
18463: PPUSH
18464: LD_VAR 0 10
18468: PPUSH
18469: CALL_OW 296
18473: PUSH
18474: LD_INT 12
18476: GREATER
18477: OR
18478: IFFALSE 18482
// exit ;
18480: GO 18835
// missile := [ 1 ] ;
18482: LD_ADDR_VAR 0 14
18486: PUSH
18487: LD_INT 1
18489: PUSH
18490: EMPTY
18491: LIST
18492: ST_TO_ADDR
// if Researched ( side , tech_space ) then
18493: LD_VAR 0 9
18497: PPUSH
18498: LD_VAR 0 12
18502: PPUSH
18503: CALL_OW 325
18507: IFFALSE 18536
// missile := Replace ( missile , missile + 1 , 2 ) ;
18509: LD_ADDR_VAR 0 14
18513: PUSH
18514: LD_VAR 0 14
18518: PPUSH
18519: LD_VAR 0 14
18523: PUSH
18524: LD_INT 1
18526: PLUS
18527: PPUSH
18528: LD_INT 2
18530: PPUSH
18531: CALL_OW 1
18535: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
18536: LD_VAR 0 9
18540: PPUSH
18541: LD_VAR 0 13
18545: PPUSH
18546: CALL_OW 325
18550: PUSH
18551: LD_VAR 0 10
18555: PPUSH
18556: CALL_OW 255
18560: PPUSH
18561: LD_VAR 0 13
18565: PPUSH
18566: CALL_OW 325
18570: NOT
18571: AND
18572: IFFALSE 18601
// missile := Replace ( missile , missile + 1 , 3 ) ;
18574: LD_ADDR_VAR 0 14
18578: PUSH
18579: LD_VAR 0 14
18583: PPUSH
18584: LD_VAR 0 14
18588: PUSH
18589: LD_INT 1
18591: PLUS
18592: PPUSH
18593: LD_INT 3
18595: PPUSH
18596: CALL_OW 1
18600: ST_TO_ADDR
// if missile < 2 then
18601: LD_VAR 0 14
18605: PUSH
18606: LD_INT 2
18608: LESS
18609: IFFALSE 18613
// exit ;
18611: GO 18835
// x := GetX ( enemy ) ;
18613: LD_ADDR_VAR 0 4
18617: PUSH
18618: LD_VAR 0 10
18622: PPUSH
18623: CALL_OW 250
18627: ST_TO_ADDR
// y := GetY ( enemy ) ;
18628: LD_ADDR_VAR 0 5
18632: PUSH
18633: LD_VAR 0 10
18637: PPUSH
18638: CALL_OW 251
18642: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
18643: LD_ADDR_VAR 0 6
18647: PUSH
18648: LD_VAR 0 4
18652: PUSH
18653: LD_INT 1
18655: NEG
18656: PPUSH
18657: LD_INT 1
18659: PPUSH
18660: CALL_OW 12
18664: PLUS
18665: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
18666: LD_ADDR_VAR 0 7
18670: PUSH
18671: LD_VAR 0 5
18675: PUSH
18676: LD_INT 1
18678: NEG
18679: PPUSH
18680: LD_INT 1
18682: PPUSH
18683: CALL_OW 12
18687: PLUS
18688: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
18689: LD_VAR 0 6
18693: PPUSH
18694: LD_VAR 0 7
18698: PPUSH
18699: CALL_OW 488
18703: NOT
18704: IFFALSE 18726
// begin _x := x ;
18706: LD_ADDR_VAR 0 6
18710: PUSH
18711: LD_VAR 0 4
18715: ST_TO_ADDR
// _y := y ;
18716: LD_ADDR_VAR 0 7
18720: PUSH
18721: LD_VAR 0 5
18725: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
18726: LD_ADDR_VAR 0 3
18730: PUSH
18731: LD_INT 1
18733: PPUSH
18734: LD_VAR 0 14
18738: PPUSH
18739: CALL_OW 12
18743: ST_TO_ADDR
// case i of 1 :
18744: LD_VAR 0 3
18748: PUSH
18749: LD_INT 1
18751: DOUBLE
18752: EQUAL
18753: IFTRUE 18757
18755: GO 18774
18757: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
18758: LD_VAR 0 1
18762: PPUSH
18763: LD_VAR 0 10
18767: PPUSH
18768: CALL_OW 115
18772: GO 18835
18774: LD_INT 2
18776: DOUBLE
18777: EQUAL
18778: IFTRUE 18782
18780: GO 18804
18782: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
18783: LD_VAR 0 1
18787: PPUSH
18788: LD_VAR 0 6
18792: PPUSH
18793: LD_VAR 0 7
18797: PPUSH
18798: CALL_OW 153
18802: GO 18835
18804: LD_INT 3
18806: DOUBLE
18807: EQUAL
18808: IFTRUE 18812
18810: GO 18834
18812: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
18813: LD_VAR 0 1
18817: PPUSH
18818: LD_VAR 0 6
18822: PPUSH
18823: LD_VAR 0 7
18827: PPUSH
18828: CALL_OW 154
18832: GO 18835
18834: POP
// end ;
18835: LD_VAR 0 2
18839: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
18840: LD_INT 0
18842: PPUSH
18843: PPUSH
18844: PPUSH
18845: PPUSH
18846: PPUSH
18847: PPUSH
// if not unit or not building then
18848: LD_VAR 0 1
18852: NOT
18853: PUSH
18854: LD_VAR 0 2
18858: NOT
18859: OR
18860: IFFALSE 18864
// exit ;
18862: GO 19022
// x := GetX ( building ) ;
18864: LD_ADDR_VAR 0 5
18868: PUSH
18869: LD_VAR 0 2
18873: PPUSH
18874: CALL_OW 250
18878: ST_TO_ADDR
// y := GetY ( building ) ;
18879: LD_ADDR_VAR 0 6
18883: PUSH
18884: LD_VAR 0 2
18888: PPUSH
18889: CALL_OW 251
18893: ST_TO_ADDR
// for i = 0 to 5 do
18894: LD_ADDR_VAR 0 4
18898: PUSH
18899: DOUBLE
18900: LD_INT 0
18902: DEC
18903: ST_TO_ADDR
18904: LD_INT 5
18906: PUSH
18907: FOR_TO
18908: IFFALSE 19020
// begin _x := ShiftX ( x , i , 3 ) ;
18910: LD_ADDR_VAR 0 7
18914: PUSH
18915: LD_VAR 0 5
18919: PPUSH
18920: LD_VAR 0 4
18924: PPUSH
18925: LD_INT 3
18927: PPUSH
18928: CALL_OW 272
18932: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
18933: LD_ADDR_VAR 0 8
18937: PUSH
18938: LD_VAR 0 6
18942: PPUSH
18943: LD_VAR 0 4
18947: PPUSH
18948: LD_INT 3
18950: PPUSH
18951: CALL_OW 273
18955: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
18956: LD_VAR 0 7
18960: PPUSH
18961: LD_VAR 0 8
18965: PPUSH
18966: CALL_OW 488
18970: NOT
18971: IFFALSE 18975
// continue ;
18973: GO 18907
// if HexInfo ( _x , _y ) = 0 then
18975: LD_VAR 0 7
18979: PPUSH
18980: LD_VAR 0 8
18984: PPUSH
18985: CALL_OW 428
18989: PUSH
18990: LD_INT 0
18992: EQUAL
18993: IFFALSE 19018
// begin ComMoveXY ( unit , _x , _y ) ;
18995: LD_VAR 0 1
18999: PPUSH
19000: LD_VAR 0 7
19004: PPUSH
19005: LD_VAR 0 8
19009: PPUSH
19010: CALL_OW 111
// exit ;
19014: POP
19015: POP
19016: GO 19022
// end ; end ;
19018: GO 18907
19020: POP
19021: POP
// end ;
19022: LD_VAR 0 3
19026: RET
// export function ScanBase ( side , base_area ) ; begin
19027: LD_INT 0
19029: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
19030: LD_ADDR_VAR 0 3
19034: PUSH
19035: LD_VAR 0 2
19039: PPUSH
19040: LD_INT 81
19042: PUSH
19043: LD_VAR 0 1
19047: PUSH
19048: EMPTY
19049: LIST
19050: LIST
19051: PPUSH
19052: CALL_OW 70
19056: ST_TO_ADDR
// end ;
19057: LD_VAR 0 3
19061: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
19062: LD_INT 0
19064: PPUSH
19065: PPUSH
19066: PPUSH
19067: PPUSH
// result := false ;
19068: LD_ADDR_VAR 0 2
19072: PUSH
19073: LD_INT 0
19075: ST_TO_ADDR
// side := GetSide ( unit ) ;
19076: LD_ADDR_VAR 0 3
19080: PUSH
19081: LD_VAR 0 1
19085: PPUSH
19086: CALL_OW 255
19090: ST_TO_ADDR
// nat := GetNation ( unit ) ;
19091: LD_ADDR_VAR 0 4
19095: PUSH
19096: LD_VAR 0 1
19100: PPUSH
19101: CALL_OW 248
19105: ST_TO_ADDR
// case nat of 1 :
19106: LD_VAR 0 4
19110: PUSH
19111: LD_INT 1
19113: DOUBLE
19114: EQUAL
19115: IFTRUE 19119
19117: GO 19130
19119: POP
// tech := tech_lassight ; 2 :
19120: LD_ADDR_VAR 0 5
19124: PUSH
19125: LD_INT 12
19127: ST_TO_ADDR
19128: GO 19169
19130: LD_INT 2
19132: DOUBLE
19133: EQUAL
19134: IFTRUE 19138
19136: GO 19149
19138: POP
// tech := tech_mortar ; 3 :
19139: LD_ADDR_VAR 0 5
19143: PUSH
19144: LD_INT 41
19146: ST_TO_ADDR
19147: GO 19169
19149: LD_INT 3
19151: DOUBLE
19152: EQUAL
19153: IFTRUE 19157
19155: GO 19168
19157: POP
// tech := tech_bazooka ; end ;
19158: LD_ADDR_VAR 0 5
19162: PUSH
19163: LD_INT 44
19165: ST_TO_ADDR
19166: GO 19169
19168: POP
// if Researched ( side , tech ) then
19169: LD_VAR 0 3
19173: PPUSH
19174: LD_VAR 0 5
19178: PPUSH
19179: CALL_OW 325
19183: IFFALSE 19210
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
19185: LD_ADDR_VAR 0 2
19189: PUSH
19190: LD_INT 5
19192: PUSH
19193: LD_INT 8
19195: PUSH
19196: LD_INT 9
19198: PUSH
19199: EMPTY
19200: LIST
19201: LIST
19202: LIST
19203: PUSH
19204: LD_VAR 0 4
19208: ARRAY
19209: ST_TO_ADDR
// end ;
19210: LD_VAR 0 2
19214: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
19215: LD_INT 0
19217: PPUSH
19218: PPUSH
19219: PPUSH
// if not mines then
19220: LD_VAR 0 2
19224: NOT
19225: IFFALSE 19229
// exit ;
19227: GO 19373
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19229: LD_ADDR_VAR 0 5
19233: PUSH
19234: LD_INT 81
19236: PUSH
19237: LD_VAR 0 1
19241: PUSH
19242: EMPTY
19243: LIST
19244: LIST
19245: PUSH
19246: LD_INT 3
19248: PUSH
19249: LD_INT 21
19251: PUSH
19252: LD_INT 3
19254: PUSH
19255: EMPTY
19256: LIST
19257: LIST
19258: PUSH
19259: EMPTY
19260: LIST
19261: LIST
19262: PUSH
19263: EMPTY
19264: LIST
19265: LIST
19266: PPUSH
19267: CALL_OW 69
19271: ST_TO_ADDR
// for i in mines do
19272: LD_ADDR_VAR 0 4
19276: PUSH
19277: LD_VAR 0 2
19281: PUSH
19282: FOR_IN
19283: IFFALSE 19371
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
19285: LD_VAR 0 4
19289: PUSH
19290: LD_INT 1
19292: ARRAY
19293: PPUSH
19294: LD_VAR 0 4
19298: PUSH
19299: LD_INT 2
19301: ARRAY
19302: PPUSH
19303: CALL_OW 458
19307: NOT
19308: IFFALSE 19312
// continue ;
19310: GO 19282
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
19312: LD_VAR 0 4
19316: PUSH
19317: LD_INT 1
19319: ARRAY
19320: PPUSH
19321: LD_VAR 0 4
19325: PUSH
19326: LD_INT 2
19328: ARRAY
19329: PPUSH
19330: CALL_OW 428
19334: PUSH
19335: LD_VAR 0 5
19339: IN
19340: IFFALSE 19369
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
19342: LD_VAR 0 4
19346: PUSH
19347: LD_INT 1
19349: ARRAY
19350: PPUSH
19351: LD_VAR 0 4
19355: PUSH
19356: LD_INT 2
19358: ARRAY
19359: PPUSH
19360: LD_VAR 0 1
19364: PPUSH
19365: CALL_OW 456
// end ;
19369: GO 19282
19371: POP
19372: POP
// end ;
19373: LD_VAR 0 3
19377: RET
// export function Count ( array ) ; begin
19378: LD_INT 0
19380: PPUSH
// result := array + 0 ;
19381: LD_ADDR_VAR 0 2
19385: PUSH
19386: LD_VAR 0 1
19390: PUSH
19391: LD_INT 0
19393: PLUS
19394: ST_TO_ADDR
// end ;
19395: LD_VAR 0 2
19399: RET
// export function IsEmpty ( building ) ; begin
19400: LD_INT 0
19402: PPUSH
// if not building then
19403: LD_VAR 0 1
19407: NOT
19408: IFFALSE 19412
// exit ;
19410: GO 19455
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
19412: LD_ADDR_VAR 0 2
19416: PUSH
19417: LD_VAR 0 1
19421: PUSH
19422: LD_INT 22
19424: PUSH
19425: LD_VAR 0 1
19429: PPUSH
19430: CALL_OW 255
19434: PUSH
19435: EMPTY
19436: LIST
19437: LIST
19438: PUSH
19439: LD_INT 58
19441: PUSH
19442: EMPTY
19443: LIST
19444: PUSH
19445: EMPTY
19446: LIST
19447: LIST
19448: PPUSH
19449: CALL_OW 69
19453: IN
19454: ST_TO_ADDR
// end ;
19455: LD_VAR 0 2
19459: RET
// export function IsNotFull ( building ) ; var places ; begin
19460: LD_INT 0
19462: PPUSH
19463: PPUSH
// if not building then
19464: LD_VAR 0 1
19468: NOT
19469: IFFALSE 19473
// exit ;
19471: GO 19501
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
19473: LD_ADDR_VAR 0 2
19477: PUSH
19478: LD_VAR 0 1
19482: PPUSH
19483: LD_INT 3
19485: PUSH
19486: LD_INT 62
19488: PUSH
19489: EMPTY
19490: LIST
19491: PUSH
19492: EMPTY
19493: LIST
19494: LIST
19495: PPUSH
19496: CALL_OW 72
19500: ST_TO_ADDR
// end ;
19501: LD_VAR 0 2
19505: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
19506: LD_INT 0
19508: PPUSH
19509: PPUSH
19510: PPUSH
19511: PPUSH
// tmp := [ ] ;
19512: LD_ADDR_VAR 0 3
19516: PUSH
19517: EMPTY
19518: ST_TO_ADDR
// list := [ ] ;
19519: LD_ADDR_VAR 0 5
19523: PUSH
19524: EMPTY
19525: ST_TO_ADDR
// for i = 16 to 25 do
19526: LD_ADDR_VAR 0 4
19530: PUSH
19531: DOUBLE
19532: LD_INT 16
19534: DEC
19535: ST_TO_ADDR
19536: LD_INT 25
19538: PUSH
19539: FOR_TO
19540: IFFALSE 19613
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
19542: LD_ADDR_VAR 0 3
19546: PUSH
19547: LD_VAR 0 3
19551: PUSH
19552: LD_INT 22
19554: PUSH
19555: LD_VAR 0 1
19559: PPUSH
19560: CALL_OW 255
19564: PUSH
19565: EMPTY
19566: LIST
19567: LIST
19568: PUSH
19569: LD_INT 91
19571: PUSH
19572: LD_VAR 0 1
19576: PUSH
19577: LD_INT 6
19579: PUSH
19580: EMPTY
19581: LIST
19582: LIST
19583: LIST
19584: PUSH
19585: LD_INT 30
19587: PUSH
19588: LD_VAR 0 4
19592: PUSH
19593: EMPTY
19594: LIST
19595: LIST
19596: PUSH
19597: EMPTY
19598: LIST
19599: LIST
19600: LIST
19601: PUSH
19602: EMPTY
19603: LIST
19604: PPUSH
19605: CALL_OW 69
19609: ADD
19610: ST_TO_ADDR
19611: GO 19539
19613: POP
19614: POP
// for i = 1 to tmp do
19615: LD_ADDR_VAR 0 4
19619: PUSH
19620: DOUBLE
19621: LD_INT 1
19623: DEC
19624: ST_TO_ADDR
19625: LD_VAR 0 3
19629: PUSH
19630: FOR_TO
19631: IFFALSE 19719
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
19633: LD_ADDR_VAR 0 5
19637: PUSH
19638: LD_VAR 0 5
19642: PUSH
19643: LD_VAR 0 3
19647: PUSH
19648: LD_VAR 0 4
19652: ARRAY
19653: PPUSH
19654: CALL_OW 266
19658: PUSH
19659: LD_VAR 0 3
19663: PUSH
19664: LD_VAR 0 4
19668: ARRAY
19669: PPUSH
19670: CALL_OW 250
19674: PUSH
19675: LD_VAR 0 3
19679: PUSH
19680: LD_VAR 0 4
19684: ARRAY
19685: PPUSH
19686: CALL_OW 251
19690: PUSH
19691: LD_VAR 0 3
19695: PUSH
19696: LD_VAR 0 4
19700: ARRAY
19701: PPUSH
19702: CALL_OW 254
19706: PUSH
19707: EMPTY
19708: LIST
19709: LIST
19710: LIST
19711: LIST
19712: PUSH
19713: EMPTY
19714: LIST
19715: ADD
19716: ST_TO_ADDR
19717: GO 19630
19719: POP
19720: POP
// result := list ;
19721: LD_ADDR_VAR 0 2
19725: PUSH
19726: LD_VAR 0 5
19730: ST_TO_ADDR
// end ;
19731: LD_VAR 0 2
19735: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
19736: LD_INT 0
19738: PPUSH
19739: PPUSH
19740: PPUSH
19741: PPUSH
19742: PPUSH
19743: PPUSH
19744: PPUSH
// if not factory then
19745: LD_VAR 0 1
19749: NOT
19750: IFFALSE 19754
// exit ;
19752: GO 20347
// if control = control_apeman then
19754: LD_VAR 0 4
19758: PUSH
19759: LD_INT 5
19761: EQUAL
19762: IFFALSE 19871
// begin tmp := UnitsInside ( factory ) ;
19764: LD_ADDR_VAR 0 8
19768: PUSH
19769: LD_VAR 0 1
19773: PPUSH
19774: CALL_OW 313
19778: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
19779: LD_VAR 0 8
19783: PPUSH
19784: LD_INT 25
19786: PUSH
19787: LD_INT 12
19789: PUSH
19790: EMPTY
19791: LIST
19792: LIST
19793: PPUSH
19794: CALL_OW 72
19798: NOT
19799: IFFALSE 19809
// control := control_manual ;
19801: LD_ADDR_VAR 0 4
19805: PUSH
19806: LD_INT 1
19808: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
19809: LD_ADDR_VAR 0 8
19813: PUSH
19814: LD_VAR 0 1
19818: PPUSH
19819: CALL 19506 0 1
19823: ST_TO_ADDR
// if tmp then
19824: LD_VAR 0 8
19828: IFFALSE 19871
// begin for i in tmp do
19830: LD_ADDR_VAR 0 7
19834: PUSH
19835: LD_VAR 0 8
19839: PUSH
19840: FOR_IN
19841: IFFALSE 19869
// if i [ 1 ] = b_ext_radio then
19843: LD_VAR 0 7
19847: PUSH
19848: LD_INT 1
19850: ARRAY
19851: PUSH
19852: LD_INT 22
19854: EQUAL
19855: IFFALSE 19867
// begin control := control_remote ;
19857: LD_ADDR_VAR 0 4
19861: PUSH
19862: LD_INT 2
19864: ST_TO_ADDR
// break ;
19865: GO 19869
// end ;
19867: GO 19840
19869: POP
19870: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19871: LD_VAR 0 1
19875: PPUSH
19876: LD_VAR 0 2
19880: PPUSH
19881: LD_VAR 0 3
19885: PPUSH
19886: LD_VAR 0 4
19890: PPUSH
19891: LD_VAR 0 5
19895: PPUSH
19896: CALL_OW 448
19900: IFFALSE 19935
// begin result := [ chassis , engine , control , weapon ] ;
19902: LD_ADDR_VAR 0 6
19906: PUSH
19907: LD_VAR 0 2
19911: PUSH
19912: LD_VAR 0 3
19916: PUSH
19917: LD_VAR 0 4
19921: PUSH
19922: LD_VAR 0 5
19926: PUSH
19927: EMPTY
19928: LIST
19929: LIST
19930: LIST
19931: LIST
19932: ST_TO_ADDR
// exit ;
19933: GO 20347
// end ; _chassis := AvailableChassisList ( factory ) ;
19935: LD_ADDR_VAR 0 9
19939: PUSH
19940: LD_VAR 0 1
19944: PPUSH
19945: CALL_OW 475
19949: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
19950: LD_ADDR_VAR 0 11
19954: PUSH
19955: LD_VAR 0 1
19959: PPUSH
19960: CALL_OW 476
19964: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
19965: LD_ADDR_VAR 0 12
19969: PUSH
19970: LD_VAR 0 1
19974: PPUSH
19975: CALL_OW 477
19979: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
19980: LD_ADDR_VAR 0 10
19984: PUSH
19985: LD_VAR 0 1
19989: PPUSH
19990: CALL_OW 478
19994: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
19995: LD_VAR 0 9
19999: NOT
20000: PUSH
20001: LD_VAR 0 11
20005: NOT
20006: OR
20007: PUSH
20008: LD_VAR 0 12
20012: NOT
20013: OR
20014: PUSH
20015: LD_VAR 0 10
20019: NOT
20020: OR
20021: IFFALSE 20056
// begin result := [ chassis , engine , control , weapon ] ;
20023: LD_ADDR_VAR 0 6
20027: PUSH
20028: LD_VAR 0 2
20032: PUSH
20033: LD_VAR 0 3
20037: PUSH
20038: LD_VAR 0 4
20042: PUSH
20043: LD_VAR 0 5
20047: PUSH
20048: EMPTY
20049: LIST
20050: LIST
20051: LIST
20052: LIST
20053: ST_TO_ADDR
// exit ;
20054: GO 20347
// end ; if not chassis in _chassis then
20056: LD_VAR 0 2
20060: PUSH
20061: LD_VAR 0 9
20065: IN
20066: NOT
20067: IFFALSE 20093
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
20069: LD_ADDR_VAR 0 2
20073: PUSH
20074: LD_VAR 0 9
20078: PUSH
20079: LD_INT 1
20081: PPUSH
20082: LD_VAR 0 9
20086: PPUSH
20087: CALL_OW 12
20091: ARRAY
20092: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
20093: LD_VAR 0 2
20097: PPUSH
20098: LD_VAR 0 3
20102: PPUSH
20103: CALL 20352 0 2
20107: NOT
20108: IFFALSE 20167
// repeat engine := _engine [ 1 ] ;
20110: LD_ADDR_VAR 0 3
20114: PUSH
20115: LD_VAR 0 11
20119: PUSH
20120: LD_INT 1
20122: ARRAY
20123: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
20124: LD_ADDR_VAR 0 11
20128: PUSH
20129: LD_VAR 0 11
20133: PPUSH
20134: LD_INT 1
20136: PPUSH
20137: CALL_OW 3
20141: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
20142: LD_VAR 0 2
20146: PPUSH
20147: LD_VAR 0 3
20151: PPUSH
20152: CALL 20352 0 2
20156: PUSH
20157: LD_VAR 0 11
20161: PUSH
20162: EMPTY
20163: EQUAL
20164: OR
20165: IFFALSE 20110
// if not control in _control then
20167: LD_VAR 0 4
20171: PUSH
20172: LD_VAR 0 12
20176: IN
20177: NOT
20178: IFFALSE 20204
// control := _control [ rand ( 1 , _control ) ] ;
20180: LD_ADDR_VAR 0 4
20184: PUSH
20185: LD_VAR 0 12
20189: PUSH
20190: LD_INT 1
20192: PPUSH
20193: LD_VAR 0 12
20197: PPUSH
20198: CALL_OW 12
20202: ARRAY
20203: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
20204: LD_VAR 0 2
20208: PPUSH
20209: LD_VAR 0 5
20213: PPUSH
20214: CALL 20572 0 2
20218: NOT
20219: IFFALSE 20278
// repeat weapon := _weapon [ 1 ] ;
20221: LD_ADDR_VAR 0 5
20225: PUSH
20226: LD_VAR 0 10
20230: PUSH
20231: LD_INT 1
20233: ARRAY
20234: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
20235: LD_ADDR_VAR 0 10
20239: PUSH
20240: LD_VAR 0 10
20244: PPUSH
20245: LD_INT 1
20247: PPUSH
20248: CALL_OW 3
20252: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
20253: LD_VAR 0 2
20257: PPUSH
20258: LD_VAR 0 5
20262: PPUSH
20263: CALL 20572 0 2
20267: PUSH
20268: LD_VAR 0 10
20272: PUSH
20273: EMPTY
20274: EQUAL
20275: OR
20276: IFFALSE 20221
// result := [ ] ;
20278: LD_ADDR_VAR 0 6
20282: PUSH
20283: EMPTY
20284: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
20285: LD_VAR 0 1
20289: PPUSH
20290: LD_VAR 0 2
20294: PPUSH
20295: LD_VAR 0 3
20299: PPUSH
20300: LD_VAR 0 4
20304: PPUSH
20305: LD_VAR 0 5
20309: PPUSH
20310: CALL_OW 448
20314: IFFALSE 20347
// result := [ chassis , engine , control , weapon ] ;
20316: LD_ADDR_VAR 0 6
20320: PUSH
20321: LD_VAR 0 2
20325: PUSH
20326: LD_VAR 0 3
20330: PUSH
20331: LD_VAR 0 4
20335: PUSH
20336: LD_VAR 0 5
20340: PUSH
20341: EMPTY
20342: LIST
20343: LIST
20344: LIST
20345: LIST
20346: ST_TO_ADDR
// end ;
20347: LD_VAR 0 6
20351: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
20352: LD_INT 0
20354: PPUSH
// if not chassis or not engine then
20355: LD_VAR 0 1
20359: NOT
20360: PUSH
20361: LD_VAR 0 2
20365: NOT
20366: OR
20367: IFFALSE 20371
// exit ;
20369: GO 20567
// case engine of engine_solar :
20371: LD_VAR 0 2
20375: PUSH
20376: LD_INT 2
20378: DOUBLE
20379: EQUAL
20380: IFTRUE 20384
20382: GO 20422
20384: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
20385: LD_ADDR_VAR 0 3
20389: PUSH
20390: LD_INT 11
20392: PUSH
20393: LD_INT 12
20395: PUSH
20396: LD_INT 13
20398: PUSH
20399: LD_INT 14
20401: PUSH
20402: LD_INT 1
20404: PUSH
20405: LD_INT 2
20407: PUSH
20408: LD_INT 3
20410: PUSH
20411: EMPTY
20412: LIST
20413: LIST
20414: LIST
20415: LIST
20416: LIST
20417: LIST
20418: LIST
20419: ST_TO_ADDR
20420: GO 20551
20422: LD_INT 1
20424: DOUBLE
20425: EQUAL
20426: IFTRUE 20430
20428: GO 20492
20430: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
20431: LD_ADDR_VAR 0 3
20435: PUSH
20436: LD_INT 11
20438: PUSH
20439: LD_INT 12
20441: PUSH
20442: LD_INT 13
20444: PUSH
20445: LD_INT 14
20447: PUSH
20448: LD_INT 1
20450: PUSH
20451: LD_INT 2
20453: PUSH
20454: LD_INT 3
20456: PUSH
20457: LD_INT 4
20459: PUSH
20460: LD_INT 5
20462: PUSH
20463: LD_INT 21
20465: PUSH
20466: LD_INT 23
20468: PUSH
20469: LD_INT 22
20471: PUSH
20472: LD_INT 24
20474: PUSH
20475: EMPTY
20476: LIST
20477: LIST
20478: LIST
20479: LIST
20480: LIST
20481: LIST
20482: LIST
20483: LIST
20484: LIST
20485: LIST
20486: LIST
20487: LIST
20488: LIST
20489: ST_TO_ADDR
20490: GO 20551
20492: LD_INT 3
20494: DOUBLE
20495: EQUAL
20496: IFTRUE 20500
20498: GO 20550
20500: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20501: LD_ADDR_VAR 0 3
20505: PUSH
20506: LD_INT 13
20508: PUSH
20509: LD_INT 14
20511: PUSH
20512: LD_INT 2
20514: PUSH
20515: LD_INT 3
20517: PUSH
20518: LD_INT 4
20520: PUSH
20521: LD_INT 5
20523: PUSH
20524: LD_INT 21
20526: PUSH
20527: LD_INT 22
20529: PUSH
20530: LD_INT 23
20532: PUSH
20533: LD_INT 24
20535: PUSH
20536: EMPTY
20537: LIST
20538: LIST
20539: LIST
20540: LIST
20541: LIST
20542: LIST
20543: LIST
20544: LIST
20545: LIST
20546: LIST
20547: ST_TO_ADDR
20548: GO 20551
20550: POP
// result := ( chassis in result ) ;
20551: LD_ADDR_VAR 0 3
20555: PUSH
20556: LD_VAR 0 1
20560: PUSH
20561: LD_VAR 0 3
20565: IN
20566: ST_TO_ADDR
// end ;
20567: LD_VAR 0 3
20571: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
20572: LD_INT 0
20574: PPUSH
// if not chassis or not weapon then
20575: LD_VAR 0 1
20579: NOT
20580: PUSH
20581: LD_VAR 0 2
20585: NOT
20586: OR
20587: IFFALSE 20591
// exit ;
20589: GO 21651
// case weapon of us_machine_gun :
20591: LD_VAR 0 2
20595: PUSH
20596: LD_INT 2
20598: DOUBLE
20599: EQUAL
20600: IFTRUE 20604
20602: GO 20634
20604: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
20605: LD_ADDR_VAR 0 3
20609: PUSH
20610: LD_INT 1
20612: PUSH
20613: LD_INT 2
20615: PUSH
20616: LD_INT 3
20618: PUSH
20619: LD_INT 4
20621: PUSH
20622: LD_INT 5
20624: PUSH
20625: EMPTY
20626: LIST
20627: LIST
20628: LIST
20629: LIST
20630: LIST
20631: ST_TO_ADDR
20632: GO 21635
20634: LD_INT 3
20636: DOUBLE
20637: EQUAL
20638: IFTRUE 20642
20640: GO 20672
20642: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
20643: LD_ADDR_VAR 0 3
20647: PUSH
20648: LD_INT 1
20650: PUSH
20651: LD_INT 2
20653: PUSH
20654: LD_INT 3
20656: PUSH
20657: LD_INT 4
20659: PUSH
20660: LD_INT 5
20662: PUSH
20663: EMPTY
20664: LIST
20665: LIST
20666: LIST
20667: LIST
20668: LIST
20669: ST_TO_ADDR
20670: GO 21635
20672: LD_INT 11
20674: DOUBLE
20675: EQUAL
20676: IFTRUE 20680
20678: GO 20710
20680: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
20681: LD_ADDR_VAR 0 3
20685: PUSH
20686: LD_INT 1
20688: PUSH
20689: LD_INT 2
20691: PUSH
20692: LD_INT 3
20694: PUSH
20695: LD_INT 4
20697: PUSH
20698: LD_INT 5
20700: PUSH
20701: EMPTY
20702: LIST
20703: LIST
20704: LIST
20705: LIST
20706: LIST
20707: ST_TO_ADDR
20708: GO 21635
20710: LD_INT 4
20712: DOUBLE
20713: EQUAL
20714: IFTRUE 20718
20716: GO 20744
20718: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
20719: LD_ADDR_VAR 0 3
20723: PUSH
20724: LD_INT 2
20726: PUSH
20727: LD_INT 3
20729: PUSH
20730: LD_INT 4
20732: PUSH
20733: LD_INT 5
20735: PUSH
20736: EMPTY
20737: LIST
20738: LIST
20739: LIST
20740: LIST
20741: ST_TO_ADDR
20742: GO 21635
20744: LD_INT 5
20746: DOUBLE
20747: EQUAL
20748: IFTRUE 20752
20750: GO 20778
20752: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
20753: LD_ADDR_VAR 0 3
20757: PUSH
20758: LD_INT 2
20760: PUSH
20761: LD_INT 3
20763: PUSH
20764: LD_INT 4
20766: PUSH
20767: LD_INT 5
20769: PUSH
20770: EMPTY
20771: LIST
20772: LIST
20773: LIST
20774: LIST
20775: ST_TO_ADDR
20776: GO 21635
20778: LD_INT 9
20780: DOUBLE
20781: EQUAL
20782: IFTRUE 20786
20784: GO 20812
20786: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
20787: LD_ADDR_VAR 0 3
20791: PUSH
20792: LD_INT 2
20794: PUSH
20795: LD_INT 3
20797: PUSH
20798: LD_INT 4
20800: PUSH
20801: LD_INT 5
20803: PUSH
20804: EMPTY
20805: LIST
20806: LIST
20807: LIST
20808: LIST
20809: ST_TO_ADDR
20810: GO 21635
20812: LD_INT 7
20814: DOUBLE
20815: EQUAL
20816: IFTRUE 20820
20818: GO 20846
20820: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
20821: LD_ADDR_VAR 0 3
20825: PUSH
20826: LD_INT 2
20828: PUSH
20829: LD_INT 3
20831: PUSH
20832: LD_INT 4
20834: PUSH
20835: LD_INT 5
20837: PUSH
20838: EMPTY
20839: LIST
20840: LIST
20841: LIST
20842: LIST
20843: ST_TO_ADDR
20844: GO 21635
20846: LD_INT 12
20848: DOUBLE
20849: EQUAL
20850: IFTRUE 20854
20852: GO 20880
20854: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
20855: LD_ADDR_VAR 0 3
20859: PUSH
20860: LD_INT 2
20862: PUSH
20863: LD_INT 3
20865: PUSH
20866: LD_INT 4
20868: PUSH
20869: LD_INT 5
20871: PUSH
20872: EMPTY
20873: LIST
20874: LIST
20875: LIST
20876: LIST
20877: ST_TO_ADDR
20878: GO 21635
20880: LD_INT 13
20882: DOUBLE
20883: EQUAL
20884: IFTRUE 20888
20886: GO 20914
20888: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
20889: LD_ADDR_VAR 0 3
20893: PUSH
20894: LD_INT 2
20896: PUSH
20897: LD_INT 3
20899: PUSH
20900: LD_INT 4
20902: PUSH
20903: LD_INT 5
20905: PUSH
20906: EMPTY
20907: LIST
20908: LIST
20909: LIST
20910: LIST
20911: ST_TO_ADDR
20912: GO 21635
20914: LD_INT 14
20916: DOUBLE
20917: EQUAL
20918: IFTRUE 20922
20920: GO 20940
20922: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
20923: LD_ADDR_VAR 0 3
20927: PUSH
20928: LD_INT 4
20930: PUSH
20931: LD_INT 5
20933: PUSH
20934: EMPTY
20935: LIST
20936: LIST
20937: ST_TO_ADDR
20938: GO 21635
20940: LD_INT 6
20942: DOUBLE
20943: EQUAL
20944: IFTRUE 20948
20946: GO 20966
20948: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
20949: LD_ADDR_VAR 0 3
20953: PUSH
20954: LD_INT 4
20956: PUSH
20957: LD_INT 5
20959: PUSH
20960: EMPTY
20961: LIST
20962: LIST
20963: ST_TO_ADDR
20964: GO 21635
20966: LD_INT 10
20968: DOUBLE
20969: EQUAL
20970: IFTRUE 20974
20972: GO 20992
20974: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
20975: LD_ADDR_VAR 0 3
20979: PUSH
20980: LD_INT 4
20982: PUSH
20983: LD_INT 5
20985: PUSH
20986: EMPTY
20987: LIST
20988: LIST
20989: ST_TO_ADDR
20990: GO 21635
20992: LD_INT 22
20994: DOUBLE
20995: EQUAL
20996: IFTRUE 21000
20998: GO 21026
21000: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
21001: LD_ADDR_VAR 0 3
21005: PUSH
21006: LD_INT 11
21008: PUSH
21009: LD_INT 12
21011: PUSH
21012: LD_INT 13
21014: PUSH
21015: LD_INT 14
21017: PUSH
21018: EMPTY
21019: LIST
21020: LIST
21021: LIST
21022: LIST
21023: ST_TO_ADDR
21024: GO 21635
21026: LD_INT 23
21028: DOUBLE
21029: EQUAL
21030: IFTRUE 21034
21032: GO 21060
21034: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
21035: LD_ADDR_VAR 0 3
21039: PUSH
21040: LD_INT 11
21042: PUSH
21043: LD_INT 12
21045: PUSH
21046: LD_INT 13
21048: PUSH
21049: LD_INT 14
21051: PUSH
21052: EMPTY
21053: LIST
21054: LIST
21055: LIST
21056: LIST
21057: ST_TO_ADDR
21058: GO 21635
21060: LD_INT 24
21062: DOUBLE
21063: EQUAL
21064: IFTRUE 21068
21066: GO 21094
21068: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
21069: LD_ADDR_VAR 0 3
21073: PUSH
21074: LD_INT 11
21076: PUSH
21077: LD_INT 12
21079: PUSH
21080: LD_INT 13
21082: PUSH
21083: LD_INT 14
21085: PUSH
21086: EMPTY
21087: LIST
21088: LIST
21089: LIST
21090: LIST
21091: ST_TO_ADDR
21092: GO 21635
21094: LD_INT 30
21096: DOUBLE
21097: EQUAL
21098: IFTRUE 21102
21100: GO 21128
21102: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
21103: LD_ADDR_VAR 0 3
21107: PUSH
21108: LD_INT 11
21110: PUSH
21111: LD_INT 12
21113: PUSH
21114: LD_INT 13
21116: PUSH
21117: LD_INT 14
21119: PUSH
21120: EMPTY
21121: LIST
21122: LIST
21123: LIST
21124: LIST
21125: ST_TO_ADDR
21126: GO 21635
21128: LD_INT 25
21130: DOUBLE
21131: EQUAL
21132: IFTRUE 21136
21134: GO 21154
21136: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
21137: LD_ADDR_VAR 0 3
21141: PUSH
21142: LD_INT 13
21144: PUSH
21145: LD_INT 14
21147: PUSH
21148: EMPTY
21149: LIST
21150: LIST
21151: ST_TO_ADDR
21152: GO 21635
21154: LD_INT 27
21156: DOUBLE
21157: EQUAL
21158: IFTRUE 21162
21160: GO 21180
21162: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
21163: LD_ADDR_VAR 0 3
21167: PUSH
21168: LD_INT 13
21170: PUSH
21171: LD_INT 14
21173: PUSH
21174: EMPTY
21175: LIST
21176: LIST
21177: ST_TO_ADDR
21178: GO 21635
21180: LD_INT 92
21182: DOUBLE
21183: EQUAL
21184: IFTRUE 21188
21186: GO 21214
21188: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
21189: LD_ADDR_VAR 0 3
21193: PUSH
21194: LD_INT 11
21196: PUSH
21197: LD_INT 12
21199: PUSH
21200: LD_INT 13
21202: PUSH
21203: LD_INT 14
21205: PUSH
21206: EMPTY
21207: LIST
21208: LIST
21209: LIST
21210: LIST
21211: ST_TO_ADDR
21212: GO 21635
21214: LD_INT 28
21216: DOUBLE
21217: EQUAL
21218: IFTRUE 21222
21220: GO 21240
21222: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
21223: LD_ADDR_VAR 0 3
21227: PUSH
21228: LD_INT 13
21230: PUSH
21231: LD_INT 14
21233: PUSH
21234: EMPTY
21235: LIST
21236: LIST
21237: ST_TO_ADDR
21238: GO 21635
21240: LD_INT 29
21242: DOUBLE
21243: EQUAL
21244: IFTRUE 21248
21246: GO 21266
21248: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
21249: LD_ADDR_VAR 0 3
21253: PUSH
21254: LD_INT 13
21256: PUSH
21257: LD_INT 14
21259: PUSH
21260: EMPTY
21261: LIST
21262: LIST
21263: ST_TO_ADDR
21264: GO 21635
21266: LD_INT 31
21268: DOUBLE
21269: EQUAL
21270: IFTRUE 21274
21272: GO 21292
21274: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
21275: LD_ADDR_VAR 0 3
21279: PUSH
21280: LD_INT 13
21282: PUSH
21283: LD_INT 14
21285: PUSH
21286: EMPTY
21287: LIST
21288: LIST
21289: ST_TO_ADDR
21290: GO 21635
21292: LD_INT 26
21294: DOUBLE
21295: EQUAL
21296: IFTRUE 21300
21298: GO 21318
21300: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
21301: LD_ADDR_VAR 0 3
21305: PUSH
21306: LD_INT 13
21308: PUSH
21309: LD_INT 14
21311: PUSH
21312: EMPTY
21313: LIST
21314: LIST
21315: ST_TO_ADDR
21316: GO 21635
21318: LD_INT 42
21320: DOUBLE
21321: EQUAL
21322: IFTRUE 21326
21324: GO 21352
21326: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
21327: LD_ADDR_VAR 0 3
21331: PUSH
21332: LD_INT 21
21334: PUSH
21335: LD_INT 22
21337: PUSH
21338: LD_INT 23
21340: PUSH
21341: LD_INT 24
21343: PUSH
21344: EMPTY
21345: LIST
21346: LIST
21347: LIST
21348: LIST
21349: ST_TO_ADDR
21350: GO 21635
21352: LD_INT 43
21354: DOUBLE
21355: EQUAL
21356: IFTRUE 21360
21358: GO 21386
21360: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
21361: LD_ADDR_VAR 0 3
21365: PUSH
21366: LD_INT 21
21368: PUSH
21369: LD_INT 22
21371: PUSH
21372: LD_INT 23
21374: PUSH
21375: LD_INT 24
21377: PUSH
21378: EMPTY
21379: LIST
21380: LIST
21381: LIST
21382: LIST
21383: ST_TO_ADDR
21384: GO 21635
21386: LD_INT 44
21388: DOUBLE
21389: EQUAL
21390: IFTRUE 21394
21392: GO 21420
21394: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
21395: LD_ADDR_VAR 0 3
21399: PUSH
21400: LD_INT 21
21402: PUSH
21403: LD_INT 22
21405: PUSH
21406: LD_INT 23
21408: PUSH
21409: LD_INT 24
21411: PUSH
21412: EMPTY
21413: LIST
21414: LIST
21415: LIST
21416: LIST
21417: ST_TO_ADDR
21418: GO 21635
21420: LD_INT 45
21422: DOUBLE
21423: EQUAL
21424: IFTRUE 21428
21426: GO 21454
21428: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
21429: LD_ADDR_VAR 0 3
21433: PUSH
21434: LD_INT 21
21436: PUSH
21437: LD_INT 22
21439: PUSH
21440: LD_INT 23
21442: PUSH
21443: LD_INT 24
21445: PUSH
21446: EMPTY
21447: LIST
21448: LIST
21449: LIST
21450: LIST
21451: ST_TO_ADDR
21452: GO 21635
21454: LD_INT 49
21456: DOUBLE
21457: EQUAL
21458: IFTRUE 21462
21460: GO 21488
21462: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
21463: LD_ADDR_VAR 0 3
21467: PUSH
21468: LD_INT 21
21470: PUSH
21471: LD_INT 22
21473: PUSH
21474: LD_INT 23
21476: PUSH
21477: LD_INT 24
21479: PUSH
21480: EMPTY
21481: LIST
21482: LIST
21483: LIST
21484: LIST
21485: ST_TO_ADDR
21486: GO 21635
21488: LD_INT 51
21490: DOUBLE
21491: EQUAL
21492: IFTRUE 21496
21494: GO 21522
21496: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
21497: LD_ADDR_VAR 0 3
21501: PUSH
21502: LD_INT 21
21504: PUSH
21505: LD_INT 22
21507: PUSH
21508: LD_INT 23
21510: PUSH
21511: LD_INT 24
21513: PUSH
21514: EMPTY
21515: LIST
21516: LIST
21517: LIST
21518: LIST
21519: ST_TO_ADDR
21520: GO 21635
21522: LD_INT 52
21524: DOUBLE
21525: EQUAL
21526: IFTRUE 21530
21528: GO 21556
21530: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
21531: LD_ADDR_VAR 0 3
21535: PUSH
21536: LD_INT 21
21538: PUSH
21539: LD_INT 22
21541: PUSH
21542: LD_INT 23
21544: PUSH
21545: LD_INT 24
21547: PUSH
21548: EMPTY
21549: LIST
21550: LIST
21551: LIST
21552: LIST
21553: ST_TO_ADDR
21554: GO 21635
21556: LD_INT 53
21558: DOUBLE
21559: EQUAL
21560: IFTRUE 21564
21562: GO 21582
21564: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
21565: LD_ADDR_VAR 0 3
21569: PUSH
21570: LD_INT 23
21572: PUSH
21573: LD_INT 24
21575: PUSH
21576: EMPTY
21577: LIST
21578: LIST
21579: ST_TO_ADDR
21580: GO 21635
21582: LD_INT 46
21584: DOUBLE
21585: EQUAL
21586: IFTRUE 21590
21588: GO 21608
21590: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
21591: LD_ADDR_VAR 0 3
21595: PUSH
21596: LD_INT 23
21598: PUSH
21599: LD_INT 24
21601: PUSH
21602: EMPTY
21603: LIST
21604: LIST
21605: ST_TO_ADDR
21606: GO 21635
21608: LD_INT 47
21610: DOUBLE
21611: EQUAL
21612: IFTRUE 21616
21614: GO 21634
21616: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
21617: LD_ADDR_VAR 0 3
21621: PUSH
21622: LD_INT 23
21624: PUSH
21625: LD_INT 24
21627: PUSH
21628: EMPTY
21629: LIST
21630: LIST
21631: ST_TO_ADDR
21632: GO 21635
21634: POP
// result := ( chassis in result ) ;
21635: LD_ADDR_VAR 0 3
21639: PUSH
21640: LD_VAR 0 1
21644: PUSH
21645: LD_VAR 0 3
21649: IN
21650: ST_TO_ADDR
// end ;
21651: LD_VAR 0 3
21655: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
21656: LD_INT 0
21658: PPUSH
21659: PPUSH
21660: PPUSH
21661: PPUSH
21662: PPUSH
21663: PPUSH
21664: PPUSH
// result := array ;
21665: LD_ADDR_VAR 0 5
21669: PUSH
21670: LD_VAR 0 1
21674: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
21675: LD_VAR 0 1
21679: NOT
21680: PUSH
21681: LD_VAR 0 2
21685: NOT
21686: OR
21687: PUSH
21688: LD_VAR 0 3
21692: NOT
21693: OR
21694: PUSH
21695: LD_VAR 0 2
21699: PUSH
21700: LD_VAR 0 1
21704: GREATER
21705: OR
21706: PUSH
21707: LD_VAR 0 3
21711: PUSH
21712: LD_VAR 0 1
21716: GREATER
21717: OR
21718: IFFALSE 21722
// exit ;
21720: GO 22018
// if direction then
21722: LD_VAR 0 4
21726: IFFALSE 21790
// begin d := 1 ;
21728: LD_ADDR_VAR 0 9
21732: PUSH
21733: LD_INT 1
21735: ST_TO_ADDR
// if i_from > i_to then
21736: LD_VAR 0 2
21740: PUSH
21741: LD_VAR 0 3
21745: GREATER
21746: IFFALSE 21772
// length := ( array - i_from ) + i_to else
21748: LD_ADDR_VAR 0 11
21752: PUSH
21753: LD_VAR 0 1
21757: PUSH
21758: LD_VAR 0 2
21762: MINUS
21763: PUSH
21764: LD_VAR 0 3
21768: PLUS
21769: ST_TO_ADDR
21770: GO 21788
// length := i_to - i_from ;
21772: LD_ADDR_VAR 0 11
21776: PUSH
21777: LD_VAR 0 3
21781: PUSH
21782: LD_VAR 0 2
21786: MINUS
21787: ST_TO_ADDR
// end else
21788: GO 21851
// begin d := - 1 ;
21790: LD_ADDR_VAR 0 9
21794: PUSH
21795: LD_INT 1
21797: NEG
21798: ST_TO_ADDR
// if i_from > i_to then
21799: LD_VAR 0 2
21803: PUSH
21804: LD_VAR 0 3
21808: GREATER
21809: IFFALSE 21829
// length := i_from - i_to else
21811: LD_ADDR_VAR 0 11
21815: PUSH
21816: LD_VAR 0 2
21820: PUSH
21821: LD_VAR 0 3
21825: MINUS
21826: ST_TO_ADDR
21827: GO 21851
// length := ( array - i_to ) + i_from ;
21829: LD_ADDR_VAR 0 11
21833: PUSH
21834: LD_VAR 0 1
21838: PUSH
21839: LD_VAR 0 3
21843: MINUS
21844: PUSH
21845: LD_VAR 0 2
21849: PLUS
21850: ST_TO_ADDR
// end ; if not length then
21851: LD_VAR 0 11
21855: NOT
21856: IFFALSE 21860
// exit ;
21858: GO 22018
// tmp := array ;
21860: LD_ADDR_VAR 0 10
21864: PUSH
21865: LD_VAR 0 1
21869: ST_TO_ADDR
// for i = 1 to length do
21870: LD_ADDR_VAR 0 6
21874: PUSH
21875: DOUBLE
21876: LD_INT 1
21878: DEC
21879: ST_TO_ADDR
21880: LD_VAR 0 11
21884: PUSH
21885: FOR_TO
21886: IFFALSE 22006
// begin for j = 1 to array do
21888: LD_ADDR_VAR 0 7
21892: PUSH
21893: DOUBLE
21894: LD_INT 1
21896: DEC
21897: ST_TO_ADDR
21898: LD_VAR 0 1
21902: PUSH
21903: FOR_TO
21904: IFFALSE 21992
// begin k := j + d ;
21906: LD_ADDR_VAR 0 8
21910: PUSH
21911: LD_VAR 0 7
21915: PUSH
21916: LD_VAR 0 9
21920: PLUS
21921: ST_TO_ADDR
// if k > array then
21922: LD_VAR 0 8
21926: PUSH
21927: LD_VAR 0 1
21931: GREATER
21932: IFFALSE 21942
// k := 1 ;
21934: LD_ADDR_VAR 0 8
21938: PUSH
21939: LD_INT 1
21941: ST_TO_ADDR
// if not k then
21942: LD_VAR 0 8
21946: NOT
21947: IFFALSE 21959
// k := array ;
21949: LD_ADDR_VAR 0 8
21953: PUSH
21954: LD_VAR 0 1
21958: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
21959: LD_ADDR_VAR 0 10
21963: PUSH
21964: LD_VAR 0 10
21968: PPUSH
21969: LD_VAR 0 8
21973: PPUSH
21974: LD_VAR 0 1
21978: PUSH
21979: LD_VAR 0 7
21983: ARRAY
21984: PPUSH
21985: CALL_OW 1
21989: ST_TO_ADDR
// end ;
21990: GO 21903
21992: POP
21993: POP
// array := tmp ;
21994: LD_ADDR_VAR 0 1
21998: PUSH
21999: LD_VAR 0 10
22003: ST_TO_ADDR
// end ;
22004: GO 21885
22006: POP
22007: POP
// result := array ;
22008: LD_ADDR_VAR 0 5
22012: PUSH
22013: LD_VAR 0 1
22017: ST_TO_ADDR
// end ;
22018: LD_VAR 0 5
22022: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
22023: LD_INT 0
22025: PPUSH
22026: PPUSH
// result := 0 ;
22027: LD_ADDR_VAR 0 3
22031: PUSH
22032: LD_INT 0
22034: ST_TO_ADDR
// if not array or not value in array then
22035: LD_VAR 0 1
22039: NOT
22040: PUSH
22041: LD_VAR 0 2
22045: PUSH
22046: LD_VAR 0 1
22050: IN
22051: NOT
22052: OR
22053: IFFALSE 22057
// exit ;
22055: GO 22111
// for i = 1 to array do
22057: LD_ADDR_VAR 0 4
22061: PUSH
22062: DOUBLE
22063: LD_INT 1
22065: DEC
22066: ST_TO_ADDR
22067: LD_VAR 0 1
22071: PUSH
22072: FOR_TO
22073: IFFALSE 22109
// if value = array [ i ] then
22075: LD_VAR 0 2
22079: PUSH
22080: LD_VAR 0 1
22084: PUSH
22085: LD_VAR 0 4
22089: ARRAY
22090: EQUAL
22091: IFFALSE 22107
// begin result := i ;
22093: LD_ADDR_VAR 0 3
22097: PUSH
22098: LD_VAR 0 4
22102: ST_TO_ADDR
// exit ;
22103: POP
22104: POP
22105: GO 22111
// end ;
22107: GO 22072
22109: POP
22110: POP
// end ;
22111: LD_VAR 0 3
22115: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
22116: LD_INT 0
22118: PPUSH
// vc_chassis := chassis ;
22119: LD_ADDR_OWVAR 37
22123: PUSH
22124: LD_VAR 0 1
22128: ST_TO_ADDR
// vc_engine := engine ;
22129: LD_ADDR_OWVAR 39
22133: PUSH
22134: LD_VAR 0 2
22138: ST_TO_ADDR
// vc_control := control ;
22139: LD_ADDR_OWVAR 38
22143: PUSH
22144: LD_VAR 0 3
22148: ST_TO_ADDR
// vc_weapon := weapon ;
22149: LD_ADDR_OWVAR 40
22153: PUSH
22154: LD_VAR 0 4
22158: ST_TO_ADDR
// vc_fuel_battery := fuel ;
22159: LD_ADDR_OWVAR 41
22163: PUSH
22164: LD_VAR 0 5
22168: ST_TO_ADDR
// end ;
22169: LD_VAR 0 6
22173: RET
// export function WantPlant ( unit ) ; var task ; begin
22174: LD_INT 0
22176: PPUSH
22177: PPUSH
// result := false ;
22178: LD_ADDR_VAR 0 2
22182: PUSH
22183: LD_INT 0
22185: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
22186: LD_ADDR_VAR 0 3
22190: PUSH
22191: LD_VAR 0 1
22195: PPUSH
22196: CALL_OW 437
22200: ST_TO_ADDR
// if task then
22201: LD_VAR 0 3
22205: IFFALSE 22233
// if task [ 1 ] [ 1 ] = p then
22207: LD_VAR 0 3
22211: PUSH
22212: LD_INT 1
22214: ARRAY
22215: PUSH
22216: LD_INT 1
22218: ARRAY
22219: PUSH
22220: LD_STRING p
22222: EQUAL
22223: IFFALSE 22233
// result := true ;
22225: LD_ADDR_VAR 0 2
22229: PUSH
22230: LD_INT 1
22232: ST_TO_ADDR
// end ;
22233: LD_VAR 0 2
22237: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
22238: LD_INT 0
22240: PPUSH
22241: PPUSH
22242: PPUSH
22243: PPUSH
// if pos < 1 then
22244: LD_VAR 0 2
22248: PUSH
22249: LD_INT 1
22251: LESS
22252: IFFALSE 22256
// exit ;
22254: GO 22559
// if pos = 1 then
22256: LD_VAR 0 2
22260: PUSH
22261: LD_INT 1
22263: EQUAL
22264: IFFALSE 22297
// result := Replace ( arr , pos [ 1 ] , value ) else
22266: LD_ADDR_VAR 0 4
22270: PUSH
22271: LD_VAR 0 1
22275: PPUSH
22276: LD_VAR 0 2
22280: PUSH
22281: LD_INT 1
22283: ARRAY
22284: PPUSH
22285: LD_VAR 0 3
22289: PPUSH
22290: CALL_OW 1
22294: ST_TO_ADDR
22295: GO 22559
// begin tmp := arr ;
22297: LD_ADDR_VAR 0 6
22301: PUSH
22302: LD_VAR 0 1
22306: ST_TO_ADDR
// s_arr := [ tmp ] ;
22307: LD_ADDR_VAR 0 7
22311: PUSH
22312: LD_VAR 0 6
22316: PUSH
22317: EMPTY
22318: LIST
22319: ST_TO_ADDR
// for i = 1 to pos - 1 do
22320: LD_ADDR_VAR 0 5
22324: PUSH
22325: DOUBLE
22326: LD_INT 1
22328: DEC
22329: ST_TO_ADDR
22330: LD_VAR 0 2
22334: PUSH
22335: LD_INT 1
22337: MINUS
22338: PUSH
22339: FOR_TO
22340: IFFALSE 22385
// begin tmp := tmp [ pos [ i ] ] ;
22342: LD_ADDR_VAR 0 6
22346: PUSH
22347: LD_VAR 0 6
22351: PUSH
22352: LD_VAR 0 2
22356: PUSH
22357: LD_VAR 0 5
22361: ARRAY
22362: ARRAY
22363: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
22364: LD_ADDR_VAR 0 7
22368: PUSH
22369: LD_VAR 0 7
22373: PUSH
22374: LD_VAR 0 6
22378: PUSH
22379: EMPTY
22380: LIST
22381: ADD
22382: ST_TO_ADDR
// end ;
22383: GO 22339
22385: POP
22386: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
22387: LD_ADDR_VAR 0 6
22391: PUSH
22392: LD_VAR 0 6
22396: PPUSH
22397: LD_VAR 0 2
22401: PUSH
22402: LD_VAR 0 2
22406: ARRAY
22407: PPUSH
22408: LD_VAR 0 3
22412: PPUSH
22413: CALL_OW 1
22417: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
22418: LD_ADDR_VAR 0 7
22422: PUSH
22423: LD_VAR 0 7
22427: PPUSH
22428: LD_VAR 0 7
22432: PPUSH
22433: LD_VAR 0 6
22437: PPUSH
22438: CALL_OW 1
22442: ST_TO_ADDR
// for i = s_arr downto 2 do
22443: LD_ADDR_VAR 0 5
22447: PUSH
22448: DOUBLE
22449: LD_VAR 0 7
22453: INC
22454: ST_TO_ADDR
22455: LD_INT 2
22457: PUSH
22458: FOR_DOWNTO
22459: IFFALSE 22543
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
22461: LD_ADDR_VAR 0 6
22465: PUSH
22466: LD_VAR 0 7
22470: PUSH
22471: LD_VAR 0 5
22475: PUSH
22476: LD_INT 1
22478: MINUS
22479: ARRAY
22480: PPUSH
22481: LD_VAR 0 2
22485: PUSH
22486: LD_VAR 0 5
22490: PUSH
22491: LD_INT 1
22493: MINUS
22494: ARRAY
22495: PPUSH
22496: LD_VAR 0 7
22500: PUSH
22501: LD_VAR 0 5
22505: ARRAY
22506: PPUSH
22507: CALL_OW 1
22511: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
22512: LD_ADDR_VAR 0 7
22516: PUSH
22517: LD_VAR 0 7
22521: PPUSH
22522: LD_VAR 0 5
22526: PUSH
22527: LD_INT 1
22529: MINUS
22530: PPUSH
22531: LD_VAR 0 6
22535: PPUSH
22536: CALL_OW 1
22540: ST_TO_ADDR
// end ;
22541: GO 22458
22543: POP
22544: POP
// result := s_arr [ 1 ] ;
22545: LD_ADDR_VAR 0 4
22549: PUSH
22550: LD_VAR 0 7
22554: PUSH
22555: LD_INT 1
22557: ARRAY
22558: ST_TO_ADDR
// end ; end ;
22559: LD_VAR 0 4
22563: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
22564: LD_INT 0
22566: PPUSH
22567: PPUSH
// if not list then
22568: LD_VAR 0 1
22572: NOT
22573: IFFALSE 22577
// exit ;
22575: GO 22668
// i := list [ pos1 ] ;
22577: LD_ADDR_VAR 0 5
22581: PUSH
22582: LD_VAR 0 1
22586: PUSH
22587: LD_VAR 0 2
22591: ARRAY
22592: ST_TO_ADDR
// if not i then
22593: LD_VAR 0 5
22597: NOT
22598: IFFALSE 22602
// exit ;
22600: GO 22668
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
22602: LD_ADDR_VAR 0 1
22606: PUSH
22607: LD_VAR 0 1
22611: PPUSH
22612: LD_VAR 0 2
22616: PPUSH
22617: LD_VAR 0 1
22621: PUSH
22622: LD_VAR 0 3
22626: ARRAY
22627: PPUSH
22628: CALL_OW 1
22632: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
22633: LD_ADDR_VAR 0 1
22637: PUSH
22638: LD_VAR 0 1
22642: PPUSH
22643: LD_VAR 0 3
22647: PPUSH
22648: LD_VAR 0 5
22652: PPUSH
22653: CALL_OW 1
22657: ST_TO_ADDR
// result := list ;
22658: LD_ADDR_VAR 0 4
22662: PUSH
22663: LD_VAR 0 1
22667: ST_TO_ADDR
// end ;
22668: LD_VAR 0 4
22672: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
22673: LD_INT 0
22675: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
22676: LD_ADDR_VAR 0 5
22680: PUSH
22681: LD_VAR 0 1
22685: PPUSH
22686: CALL_OW 250
22690: PPUSH
22691: LD_VAR 0 1
22695: PPUSH
22696: CALL_OW 251
22700: PPUSH
22701: LD_VAR 0 2
22705: PPUSH
22706: LD_VAR 0 3
22710: PPUSH
22711: LD_VAR 0 4
22715: PPUSH
22716: CALL 23094 0 5
22720: ST_TO_ADDR
// end ;
22721: LD_VAR 0 5
22725: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
22726: LD_INT 0
22728: PPUSH
22729: PPUSH
22730: PPUSH
22731: PPUSH
// if not list or not unit then
22732: LD_VAR 0 2
22736: NOT
22737: PUSH
22738: LD_VAR 0 1
22742: NOT
22743: OR
22744: IFFALSE 22748
// exit ;
22746: GO 23089
// result := [ ] ;
22748: LD_ADDR_VAR 0 5
22752: PUSH
22753: EMPTY
22754: ST_TO_ADDR
// for i in list do
22755: LD_ADDR_VAR 0 6
22759: PUSH
22760: LD_VAR 0 2
22764: PUSH
22765: FOR_IN
22766: IFFALSE 22984
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
22768: LD_ADDR_VAR 0 8
22772: PUSH
22773: LD_VAR 0 1
22777: PPUSH
22778: LD_VAR 0 6
22782: PUSH
22783: LD_INT 1
22785: ARRAY
22786: PPUSH
22787: LD_VAR 0 6
22791: PUSH
22792: LD_INT 2
22794: ARRAY
22795: PPUSH
22796: CALL_OW 297
22800: ST_TO_ADDR
// if not Count ( result ) then
22801: LD_VAR 0 5
22805: PPUSH
22806: CALL 19378 0 1
22810: NOT
22811: IFFALSE 22844
// begin result := Join ( result , [ i , tmp ] ) ;
22813: LD_ADDR_VAR 0 5
22817: PUSH
22818: LD_VAR 0 5
22822: PPUSH
22823: LD_VAR 0 6
22827: PUSH
22828: LD_VAR 0 8
22832: PUSH
22833: EMPTY
22834: LIST
22835: LIST
22836: PPUSH
22837: CALL 54967 0 2
22841: ST_TO_ADDR
// continue ;
22842: GO 22765
// end ; if result [ result ] [ 2 ] <= tmp then
22844: LD_VAR 0 5
22848: PUSH
22849: LD_VAR 0 5
22853: ARRAY
22854: PUSH
22855: LD_INT 2
22857: ARRAY
22858: PUSH
22859: LD_VAR 0 8
22863: LESSEQUAL
22864: IFFALSE 22897
// result := Join ( result , [ i , tmp ] ) else
22866: LD_ADDR_VAR 0 5
22870: PUSH
22871: LD_VAR 0 5
22875: PPUSH
22876: LD_VAR 0 6
22880: PUSH
22881: LD_VAR 0 8
22885: PUSH
22886: EMPTY
22887: LIST
22888: LIST
22889: PPUSH
22890: CALL 54967 0 2
22894: ST_TO_ADDR
22895: GO 22982
// begin for j := 1 to Count ( result ) do
22897: LD_ADDR_VAR 0 7
22901: PUSH
22902: DOUBLE
22903: LD_INT 1
22905: DEC
22906: ST_TO_ADDR
22907: LD_VAR 0 5
22911: PPUSH
22912: CALL 19378 0 1
22916: PUSH
22917: FOR_TO
22918: IFFALSE 22980
// begin if tmp < result [ j ] [ 2 ] then
22920: LD_VAR 0 8
22924: PUSH
22925: LD_VAR 0 5
22929: PUSH
22930: LD_VAR 0 7
22934: ARRAY
22935: PUSH
22936: LD_INT 2
22938: ARRAY
22939: LESS
22940: IFFALSE 22978
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22942: LD_ADDR_VAR 0 5
22946: PUSH
22947: LD_VAR 0 5
22951: PPUSH
22952: LD_VAR 0 7
22956: PPUSH
22957: LD_VAR 0 6
22961: PUSH
22962: LD_VAR 0 8
22966: PUSH
22967: EMPTY
22968: LIST
22969: LIST
22970: PPUSH
22971: CALL_OW 2
22975: ST_TO_ADDR
// break ;
22976: GO 22980
// end ; end ;
22978: GO 22917
22980: POP
22981: POP
// end ; end ;
22982: GO 22765
22984: POP
22985: POP
// if result and not asc then
22986: LD_VAR 0 5
22990: PUSH
22991: LD_VAR 0 3
22995: NOT
22996: AND
22997: IFFALSE 23014
// result := ReverseArray ( result ) ;
22999: LD_ADDR_VAR 0 5
23003: PUSH
23004: LD_VAR 0 5
23008: PPUSH
23009: CALL 50254 0 1
23013: ST_TO_ADDR
// tmp := [ ] ;
23014: LD_ADDR_VAR 0 8
23018: PUSH
23019: EMPTY
23020: ST_TO_ADDR
// if mode then
23021: LD_VAR 0 4
23025: IFFALSE 23089
// begin for i := 1 to result do
23027: LD_ADDR_VAR 0 6
23031: PUSH
23032: DOUBLE
23033: LD_INT 1
23035: DEC
23036: ST_TO_ADDR
23037: LD_VAR 0 5
23041: PUSH
23042: FOR_TO
23043: IFFALSE 23077
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
23045: LD_ADDR_VAR 0 8
23049: PUSH
23050: LD_VAR 0 8
23054: PPUSH
23055: LD_VAR 0 5
23059: PUSH
23060: LD_VAR 0 6
23064: ARRAY
23065: PUSH
23066: LD_INT 1
23068: ARRAY
23069: PPUSH
23070: CALL 54967 0 2
23074: ST_TO_ADDR
23075: GO 23042
23077: POP
23078: POP
// result := tmp ;
23079: LD_ADDR_VAR 0 5
23083: PUSH
23084: LD_VAR 0 8
23088: ST_TO_ADDR
// end ; end ;
23089: LD_VAR 0 5
23093: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
23094: LD_INT 0
23096: PPUSH
23097: PPUSH
23098: PPUSH
23099: PPUSH
// if not list then
23100: LD_VAR 0 3
23104: NOT
23105: IFFALSE 23109
// exit ;
23107: GO 23497
// result := [ ] ;
23109: LD_ADDR_VAR 0 6
23113: PUSH
23114: EMPTY
23115: ST_TO_ADDR
// for i in list do
23116: LD_ADDR_VAR 0 7
23120: PUSH
23121: LD_VAR 0 3
23125: PUSH
23126: FOR_IN
23127: IFFALSE 23329
// begin tmp := GetDistUnitXY ( i , x , y ) ;
23129: LD_ADDR_VAR 0 9
23133: PUSH
23134: LD_VAR 0 7
23138: PPUSH
23139: LD_VAR 0 1
23143: PPUSH
23144: LD_VAR 0 2
23148: PPUSH
23149: CALL_OW 297
23153: ST_TO_ADDR
// if not result then
23154: LD_VAR 0 6
23158: NOT
23159: IFFALSE 23185
// result := [ [ i , tmp ] ] else
23161: LD_ADDR_VAR 0 6
23165: PUSH
23166: LD_VAR 0 7
23170: PUSH
23171: LD_VAR 0 9
23175: PUSH
23176: EMPTY
23177: LIST
23178: LIST
23179: PUSH
23180: EMPTY
23181: LIST
23182: ST_TO_ADDR
23183: GO 23327
// begin if result [ result ] [ 2 ] < tmp then
23185: LD_VAR 0 6
23189: PUSH
23190: LD_VAR 0 6
23194: ARRAY
23195: PUSH
23196: LD_INT 2
23198: ARRAY
23199: PUSH
23200: LD_VAR 0 9
23204: LESS
23205: IFFALSE 23247
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
23207: LD_ADDR_VAR 0 6
23211: PUSH
23212: LD_VAR 0 6
23216: PPUSH
23217: LD_VAR 0 6
23221: PUSH
23222: LD_INT 1
23224: PLUS
23225: PPUSH
23226: LD_VAR 0 7
23230: PUSH
23231: LD_VAR 0 9
23235: PUSH
23236: EMPTY
23237: LIST
23238: LIST
23239: PPUSH
23240: CALL_OW 2
23244: ST_TO_ADDR
23245: GO 23327
// for j = 1 to result do
23247: LD_ADDR_VAR 0 8
23251: PUSH
23252: DOUBLE
23253: LD_INT 1
23255: DEC
23256: ST_TO_ADDR
23257: LD_VAR 0 6
23261: PUSH
23262: FOR_TO
23263: IFFALSE 23325
// begin if tmp < result [ j ] [ 2 ] then
23265: LD_VAR 0 9
23269: PUSH
23270: LD_VAR 0 6
23274: PUSH
23275: LD_VAR 0 8
23279: ARRAY
23280: PUSH
23281: LD_INT 2
23283: ARRAY
23284: LESS
23285: IFFALSE 23323
// begin result := Insert ( result , j , [ i , tmp ] ) ;
23287: LD_ADDR_VAR 0 6
23291: PUSH
23292: LD_VAR 0 6
23296: PPUSH
23297: LD_VAR 0 8
23301: PPUSH
23302: LD_VAR 0 7
23306: PUSH
23307: LD_VAR 0 9
23311: PUSH
23312: EMPTY
23313: LIST
23314: LIST
23315: PPUSH
23316: CALL_OW 2
23320: ST_TO_ADDR
// break ;
23321: GO 23325
// end ; end ;
23323: GO 23262
23325: POP
23326: POP
// end ; end ;
23327: GO 23126
23329: POP
23330: POP
// if result and not asc then
23331: LD_VAR 0 6
23335: PUSH
23336: LD_VAR 0 4
23340: NOT
23341: AND
23342: IFFALSE 23417
// begin tmp := result ;
23344: LD_ADDR_VAR 0 9
23348: PUSH
23349: LD_VAR 0 6
23353: ST_TO_ADDR
// for i = tmp downto 1 do
23354: LD_ADDR_VAR 0 7
23358: PUSH
23359: DOUBLE
23360: LD_VAR 0 9
23364: INC
23365: ST_TO_ADDR
23366: LD_INT 1
23368: PUSH
23369: FOR_DOWNTO
23370: IFFALSE 23415
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
23372: LD_ADDR_VAR 0 6
23376: PUSH
23377: LD_VAR 0 6
23381: PPUSH
23382: LD_VAR 0 9
23386: PUSH
23387: LD_VAR 0 7
23391: MINUS
23392: PUSH
23393: LD_INT 1
23395: PLUS
23396: PPUSH
23397: LD_VAR 0 9
23401: PUSH
23402: LD_VAR 0 7
23406: ARRAY
23407: PPUSH
23408: CALL_OW 1
23412: ST_TO_ADDR
23413: GO 23369
23415: POP
23416: POP
// end ; tmp := [ ] ;
23417: LD_ADDR_VAR 0 9
23421: PUSH
23422: EMPTY
23423: ST_TO_ADDR
// if mode then
23424: LD_VAR 0 5
23428: IFFALSE 23497
// begin for i = 1 to result do
23430: LD_ADDR_VAR 0 7
23434: PUSH
23435: DOUBLE
23436: LD_INT 1
23438: DEC
23439: ST_TO_ADDR
23440: LD_VAR 0 6
23444: PUSH
23445: FOR_TO
23446: IFFALSE 23485
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
23448: LD_ADDR_VAR 0 9
23452: PUSH
23453: LD_VAR 0 9
23457: PPUSH
23458: LD_VAR 0 7
23462: PPUSH
23463: LD_VAR 0 6
23467: PUSH
23468: LD_VAR 0 7
23472: ARRAY
23473: PUSH
23474: LD_INT 1
23476: ARRAY
23477: PPUSH
23478: CALL_OW 1
23482: ST_TO_ADDR
23483: GO 23445
23485: POP
23486: POP
// result := tmp ;
23487: LD_ADDR_VAR 0 6
23491: PUSH
23492: LD_VAR 0 9
23496: ST_TO_ADDR
// end ; end ;
23497: LD_VAR 0 6
23501: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
23502: LD_INT 0
23504: PPUSH
23505: PPUSH
23506: PPUSH
23507: PPUSH
23508: PPUSH
23509: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
23510: LD_ADDR_VAR 0 5
23514: PUSH
23515: LD_INT 0
23517: PUSH
23518: LD_INT 0
23520: PUSH
23521: LD_INT 0
23523: PUSH
23524: EMPTY
23525: PUSH
23526: EMPTY
23527: LIST
23528: LIST
23529: LIST
23530: LIST
23531: ST_TO_ADDR
// if not x or not y then
23532: LD_VAR 0 2
23536: NOT
23537: PUSH
23538: LD_VAR 0 3
23542: NOT
23543: OR
23544: IFFALSE 23548
// exit ;
23546: GO 25198
// if not range then
23548: LD_VAR 0 4
23552: NOT
23553: IFFALSE 23563
// range := 10 ;
23555: LD_ADDR_VAR 0 4
23559: PUSH
23560: LD_INT 10
23562: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
23563: LD_ADDR_VAR 0 8
23567: PUSH
23568: LD_INT 81
23570: PUSH
23571: LD_VAR 0 1
23575: PUSH
23576: EMPTY
23577: LIST
23578: LIST
23579: PUSH
23580: LD_INT 92
23582: PUSH
23583: LD_VAR 0 2
23587: PUSH
23588: LD_VAR 0 3
23592: PUSH
23593: LD_VAR 0 4
23597: PUSH
23598: EMPTY
23599: LIST
23600: LIST
23601: LIST
23602: LIST
23603: PUSH
23604: LD_INT 3
23606: PUSH
23607: LD_INT 21
23609: PUSH
23610: LD_INT 3
23612: PUSH
23613: EMPTY
23614: LIST
23615: LIST
23616: PUSH
23617: EMPTY
23618: LIST
23619: LIST
23620: PUSH
23621: EMPTY
23622: LIST
23623: LIST
23624: LIST
23625: PPUSH
23626: CALL_OW 69
23630: ST_TO_ADDR
// if not tmp then
23631: LD_VAR 0 8
23635: NOT
23636: IFFALSE 23640
// exit ;
23638: GO 25198
// for i in tmp do
23640: LD_ADDR_VAR 0 6
23644: PUSH
23645: LD_VAR 0 8
23649: PUSH
23650: FOR_IN
23651: IFFALSE 25173
// begin points := [ 0 , 0 , 0 ] ;
23653: LD_ADDR_VAR 0 9
23657: PUSH
23658: LD_INT 0
23660: PUSH
23661: LD_INT 0
23663: PUSH
23664: LD_INT 0
23666: PUSH
23667: EMPTY
23668: LIST
23669: LIST
23670: LIST
23671: ST_TO_ADDR
// bpoints := 1 ;
23672: LD_ADDR_VAR 0 10
23676: PUSH
23677: LD_INT 1
23679: ST_TO_ADDR
// case GetType ( i ) of unit_human :
23680: LD_VAR 0 6
23684: PPUSH
23685: CALL_OW 247
23689: PUSH
23690: LD_INT 1
23692: DOUBLE
23693: EQUAL
23694: IFTRUE 23698
23696: GO 24276
23698: POP
// begin if GetClass ( i ) = 1 then
23699: LD_VAR 0 6
23703: PPUSH
23704: CALL_OW 257
23708: PUSH
23709: LD_INT 1
23711: EQUAL
23712: IFFALSE 23733
// points := [ 10 , 5 , 3 ] ;
23714: LD_ADDR_VAR 0 9
23718: PUSH
23719: LD_INT 10
23721: PUSH
23722: LD_INT 5
23724: PUSH
23725: LD_INT 3
23727: PUSH
23728: EMPTY
23729: LIST
23730: LIST
23731: LIST
23732: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
23733: LD_VAR 0 6
23737: PPUSH
23738: CALL_OW 257
23742: PUSH
23743: LD_INT 2
23745: PUSH
23746: LD_INT 3
23748: PUSH
23749: LD_INT 4
23751: PUSH
23752: EMPTY
23753: LIST
23754: LIST
23755: LIST
23756: IN
23757: IFFALSE 23778
// points := [ 3 , 2 , 1 ] ;
23759: LD_ADDR_VAR 0 9
23763: PUSH
23764: LD_INT 3
23766: PUSH
23767: LD_INT 2
23769: PUSH
23770: LD_INT 1
23772: PUSH
23773: EMPTY
23774: LIST
23775: LIST
23776: LIST
23777: ST_TO_ADDR
// if GetClass ( i ) = 5 then
23778: LD_VAR 0 6
23782: PPUSH
23783: CALL_OW 257
23787: PUSH
23788: LD_INT 5
23790: EQUAL
23791: IFFALSE 23812
// points := [ 130 , 5 , 2 ] ;
23793: LD_ADDR_VAR 0 9
23797: PUSH
23798: LD_INT 130
23800: PUSH
23801: LD_INT 5
23803: PUSH
23804: LD_INT 2
23806: PUSH
23807: EMPTY
23808: LIST
23809: LIST
23810: LIST
23811: ST_TO_ADDR
// if GetClass ( i ) = 8 then
23812: LD_VAR 0 6
23816: PPUSH
23817: CALL_OW 257
23821: PUSH
23822: LD_INT 8
23824: EQUAL
23825: IFFALSE 23846
// points := [ 35 , 35 , 30 ] ;
23827: LD_ADDR_VAR 0 9
23831: PUSH
23832: LD_INT 35
23834: PUSH
23835: LD_INT 35
23837: PUSH
23838: LD_INT 30
23840: PUSH
23841: EMPTY
23842: LIST
23843: LIST
23844: LIST
23845: ST_TO_ADDR
// if GetClass ( i ) = 9 then
23846: LD_VAR 0 6
23850: PPUSH
23851: CALL_OW 257
23855: PUSH
23856: LD_INT 9
23858: EQUAL
23859: IFFALSE 23880
// points := [ 20 , 55 , 40 ] ;
23861: LD_ADDR_VAR 0 9
23865: PUSH
23866: LD_INT 20
23868: PUSH
23869: LD_INT 55
23871: PUSH
23872: LD_INT 40
23874: PUSH
23875: EMPTY
23876: LIST
23877: LIST
23878: LIST
23879: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
23880: LD_VAR 0 6
23884: PPUSH
23885: CALL_OW 257
23889: PUSH
23890: LD_INT 12
23892: PUSH
23893: LD_INT 16
23895: PUSH
23896: EMPTY
23897: LIST
23898: LIST
23899: IN
23900: IFFALSE 23921
// points := [ 5 , 3 , 2 ] ;
23902: LD_ADDR_VAR 0 9
23906: PUSH
23907: LD_INT 5
23909: PUSH
23910: LD_INT 3
23912: PUSH
23913: LD_INT 2
23915: PUSH
23916: EMPTY
23917: LIST
23918: LIST
23919: LIST
23920: ST_TO_ADDR
// if GetClass ( i ) = 17 then
23921: LD_VAR 0 6
23925: PPUSH
23926: CALL_OW 257
23930: PUSH
23931: LD_INT 17
23933: EQUAL
23934: IFFALSE 23955
// points := [ 100 , 50 , 75 ] ;
23936: LD_ADDR_VAR 0 9
23940: PUSH
23941: LD_INT 100
23943: PUSH
23944: LD_INT 50
23946: PUSH
23947: LD_INT 75
23949: PUSH
23950: EMPTY
23951: LIST
23952: LIST
23953: LIST
23954: ST_TO_ADDR
// if GetClass ( i ) = 15 then
23955: LD_VAR 0 6
23959: PPUSH
23960: CALL_OW 257
23964: PUSH
23965: LD_INT 15
23967: EQUAL
23968: IFFALSE 23989
// points := [ 10 , 5 , 3 ] ;
23970: LD_ADDR_VAR 0 9
23974: PUSH
23975: LD_INT 10
23977: PUSH
23978: LD_INT 5
23980: PUSH
23981: LD_INT 3
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: LIST
23988: ST_TO_ADDR
// if GetClass ( i ) = 14 then
23989: LD_VAR 0 6
23993: PPUSH
23994: CALL_OW 257
23998: PUSH
23999: LD_INT 14
24001: EQUAL
24002: IFFALSE 24023
// points := [ 10 , 0 , 0 ] ;
24004: LD_ADDR_VAR 0 9
24008: PUSH
24009: LD_INT 10
24011: PUSH
24012: LD_INT 0
24014: PUSH
24015: LD_INT 0
24017: PUSH
24018: EMPTY
24019: LIST
24020: LIST
24021: LIST
24022: ST_TO_ADDR
// if GetClass ( i ) = 11 then
24023: LD_VAR 0 6
24027: PPUSH
24028: CALL_OW 257
24032: PUSH
24033: LD_INT 11
24035: EQUAL
24036: IFFALSE 24057
// points := [ 30 , 10 , 5 ] ;
24038: LD_ADDR_VAR 0 9
24042: PUSH
24043: LD_INT 30
24045: PUSH
24046: LD_INT 10
24048: PUSH
24049: LD_INT 5
24051: PUSH
24052: EMPTY
24053: LIST
24054: LIST
24055: LIST
24056: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
24057: LD_VAR 0 1
24061: PPUSH
24062: LD_INT 5
24064: PPUSH
24065: CALL_OW 321
24069: PUSH
24070: LD_INT 2
24072: EQUAL
24073: IFFALSE 24090
// bpoints := bpoints * 1.8 ;
24075: LD_ADDR_VAR 0 10
24079: PUSH
24080: LD_VAR 0 10
24084: PUSH
24085: LD_REAL  1.80000000000000E+0000
24088: MUL
24089: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
24090: LD_VAR 0 6
24094: PPUSH
24095: CALL_OW 257
24099: PUSH
24100: LD_INT 1
24102: PUSH
24103: LD_INT 2
24105: PUSH
24106: LD_INT 3
24108: PUSH
24109: LD_INT 4
24111: PUSH
24112: EMPTY
24113: LIST
24114: LIST
24115: LIST
24116: LIST
24117: IN
24118: PUSH
24119: LD_VAR 0 1
24123: PPUSH
24124: LD_INT 51
24126: PPUSH
24127: CALL_OW 321
24131: PUSH
24132: LD_INT 2
24134: EQUAL
24135: AND
24136: IFFALSE 24153
// bpoints := bpoints * 1.2 ;
24138: LD_ADDR_VAR 0 10
24142: PUSH
24143: LD_VAR 0 10
24147: PUSH
24148: LD_REAL  1.20000000000000E+0000
24151: MUL
24152: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
24153: LD_VAR 0 6
24157: PPUSH
24158: CALL_OW 257
24162: PUSH
24163: LD_INT 5
24165: PUSH
24166: LD_INT 7
24168: PUSH
24169: LD_INT 9
24171: PUSH
24172: EMPTY
24173: LIST
24174: LIST
24175: LIST
24176: IN
24177: PUSH
24178: LD_VAR 0 1
24182: PPUSH
24183: LD_INT 52
24185: PPUSH
24186: CALL_OW 321
24190: PUSH
24191: LD_INT 2
24193: EQUAL
24194: AND
24195: IFFALSE 24212
// bpoints := bpoints * 1.5 ;
24197: LD_ADDR_VAR 0 10
24201: PUSH
24202: LD_VAR 0 10
24206: PUSH
24207: LD_REAL  1.50000000000000E+0000
24210: MUL
24211: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
24212: LD_VAR 0 1
24216: PPUSH
24217: LD_INT 66
24219: PPUSH
24220: CALL_OW 321
24224: PUSH
24225: LD_INT 2
24227: EQUAL
24228: IFFALSE 24245
// bpoints := bpoints * 1.1 ;
24230: LD_ADDR_VAR 0 10
24234: PUSH
24235: LD_VAR 0 10
24239: PUSH
24240: LD_REAL  1.10000000000000E+0000
24243: MUL
24244: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
24245: LD_ADDR_VAR 0 10
24249: PUSH
24250: LD_VAR 0 10
24254: PUSH
24255: LD_VAR 0 6
24259: PPUSH
24260: LD_INT 1
24262: PPUSH
24263: CALL_OW 259
24267: PUSH
24268: LD_REAL  1.15000000000000E+0000
24271: MUL
24272: MUL
24273: ST_TO_ADDR
// end ; unit_vehicle :
24274: GO 25102
24276: LD_INT 2
24278: DOUBLE
24279: EQUAL
24280: IFTRUE 24284
24282: GO 25090
24284: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
24285: LD_VAR 0 6
24289: PPUSH
24290: CALL_OW 264
24294: PUSH
24295: LD_INT 2
24297: PUSH
24298: LD_INT 42
24300: PUSH
24301: LD_INT 24
24303: PUSH
24304: EMPTY
24305: LIST
24306: LIST
24307: LIST
24308: IN
24309: IFFALSE 24330
// points := [ 25 , 5 , 3 ] ;
24311: LD_ADDR_VAR 0 9
24315: PUSH
24316: LD_INT 25
24318: PUSH
24319: LD_INT 5
24321: PUSH
24322: LD_INT 3
24324: PUSH
24325: EMPTY
24326: LIST
24327: LIST
24328: LIST
24329: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
24330: LD_VAR 0 6
24334: PPUSH
24335: CALL_OW 264
24339: PUSH
24340: LD_INT 4
24342: PUSH
24343: LD_INT 43
24345: PUSH
24346: LD_INT 25
24348: PUSH
24349: EMPTY
24350: LIST
24351: LIST
24352: LIST
24353: IN
24354: IFFALSE 24375
// points := [ 40 , 15 , 5 ] ;
24356: LD_ADDR_VAR 0 9
24360: PUSH
24361: LD_INT 40
24363: PUSH
24364: LD_INT 15
24366: PUSH
24367: LD_INT 5
24369: PUSH
24370: EMPTY
24371: LIST
24372: LIST
24373: LIST
24374: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
24375: LD_VAR 0 6
24379: PPUSH
24380: CALL_OW 264
24384: PUSH
24385: LD_INT 3
24387: PUSH
24388: LD_INT 23
24390: PUSH
24391: EMPTY
24392: LIST
24393: LIST
24394: IN
24395: IFFALSE 24416
// points := [ 7 , 25 , 8 ] ;
24397: LD_ADDR_VAR 0 9
24401: PUSH
24402: LD_INT 7
24404: PUSH
24405: LD_INT 25
24407: PUSH
24408: LD_INT 8
24410: PUSH
24411: EMPTY
24412: LIST
24413: LIST
24414: LIST
24415: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
24416: LD_VAR 0 6
24420: PPUSH
24421: CALL_OW 264
24425: PUSH
24426: LD_INT 5
24428: PUSH
24429: LD_INT 27
24431: PUSH
24432: LD_INT 44
24434: PUSH
24435: EMPTY
24436: LIST
24437: LIST
24438: LIST
24439: IN
24440: IFFALSE 24461
// points := [ 14 , 50 , 16 ] ;
24442: LD_ADDR_VAR 0 9
24446: PUSH
24447: LD_INT 14
24449: PUSH
24450: LD_INT 50
24452: PUSH
24453: LD_INT 16
24455: PUSH
24456: EMPTY
24457: LIST
24458: LIST
24459: LIST
24460: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
24461: LD_VAR 0 6
24465: PPUSH
24466: CALL_OW 264
24470: PUSH
24471: LD_INT 6
24473: PUSH
24474: LD_INT 46
24476: PUSH
24477: EMPTY
24478: LIST
24479: LIST
24480: IN
24481: IFFALSE 24502
// points := [ 32 , 120 , 70 ] ;
24483: LD_ADDR_VAR 0 9
24487: PUSH
24488: LD_INT 32
24490: PUSH
24491: LD_INT 120
24493: PUSH
24494: LD_INT 70
24496: PUSH
24497: EMPTY
24498: LIST
24499: LIST
24500: LIST
24501: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
24502: LD_VAR 0 6
24506: PPUSH
24507: CALL_OW 264
24511: PUSH
24512: LD_INT 7
24514: PUSH
24515: LD_INT 28
24517: PUSH
24518: LD_INT 45
24520: PUSH
24521: LD_INT 92
24523: PUSH
24524: EMPTY
24525: LIST
24526: LIST
24527: LIST
24528: LIST
24529: IN
24530: IFFALSE 24551
// points := [ 35 , 20 , 45 ] ;
24532: LD_ADDR_VAR 0 9
24536: PUSH
24537: LD_INT 35
24539: PUSH
24540: LD_INT 20
24542: PUSH
24543: LD_INT 45
24545: PUSH
24546: EMPTY
24547: LIST
24548: LIST
24549: LIST
24550: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
24551: LD_VAR 0 6
24555: PPUSH
24556: CALL_OW 264
24560: PUSH
24561: LD_INT 47
24563: PUSH
24564: EMPTY
24565: LIST
24566: IN
24567: IFFALSE 24588
// points := [ 67 , 45 , 75 ] ;
24569: LD_ADDR_VAR 0 9
24573: PUSH
24574: LD_INT 67
24576: PUSH
24577: LD_INT 45
24579: PUSH
24580: LD_INT 75
24582: PUSH
24583: EMPTY
24584: LIST
24585: LIST
24586: LIST
24587: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
24588: LD_VAR 0 6
24592: PPUSH
24593: CALL_OW 264
24597: PUSH
24598: LD_INT 26
24600: PUSH
24601: EMPTY
24602: LIST
24603: IN
24604: IFFALSE 24625
// points := [ 120 , 30 , 80 ] ;
24606: LD_ADDR_VAR 0 9
24610: PUSH
24611: LD_INT 120
24613: PUSH
24614: LD_INT 30
24616: PUSH
24617: LD_INT 80
24619: PUSH
24620: EMPTY
24621: LIST
24622: LIST
24623: LIST
24624: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
24625: LD_VAR 0 6
24629: PPUSH
24630: CALL_OW 264
24634: PUSH
24635: LD_INT 22
24637: PUSH
24638: EMPTY
24639: LIST
24640: IN
24641: IFFALSE 24662
// points := [ 40 , 1 , 1 ] ;
24643: LD_ADDR_VAR 0 9
24647: PUSH
24648: LD_INT 40
24650: PUSH
24651: LD_INT 1
24653: PUSH
24654: LD_INT 1
24656: PUSH
24657: EMPTY
24658: LIST
24659: LIST
24660: LIST
24661: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
24662: LD_VAR 0 6
24666: PPUSH
24667: CALL_OW 264
24671: PUSH
24672: LD_INT 29
24674: PUSH
24675: EMPTY
24676: LIST
24677: IN
24678: IFFALSE 24699
// points := [ 70 , 200 , 400 ] ;
24680: LD_ADDR_VAR 0 9
24684: PUSH
24685: LD_INT 70
24687: PUSH
24688: LD_INT 200
24690: PUSH
24691: LD_INT 400
24693: PUSH
24694: EMPTY
24695: LIST
24696: LIST
24697: LIST
24698: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
24699: LD_VAR 0 6
24703: PPUSH
24704: CALL_OW 264
24708: PUSH
24709: LD_INT 14
24711: PUSH
24712: LD_INT 53
24714: PUSH
24715: EMPTY
24716: LIST
24717: LIST
24718: IN
24719: IFFALSE 24740
// points := [ 40 , 10 , 20 ] ;
24721: LD_ADDR_VAR 0 9
24725: PUSH
24726: LD_INT 40
24728: PUSH
24729: LD_INT 10
24731: PUSH
24732: LD_INT 20
24734: PUSH
24735: EMPTY
24736: LIST
24737: LIST
24738: LIST
24739: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
24740: LD_VAR 0 6
24744: PPUSH
24745: CALL_OW 264
24749: PUSH
24750: LD_INT 9
24752: PUSH
24753: EMPTY
24754: LIST
24755: IN
24756: IFFALSE 24777
// points := [ 5 , 70 , 20 ] ;
24758: LD_ADDR_VAR 0 9
24762: PUSH
24763: LD_INT 5
24765: PUSH
24766: LD_INT 70
24768: PUSH
24769: LD_INT 20
24771: PUSH
24772: EMPTY
24773: LIST
24774: LIST
24775: LIST
24776: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
24777: LD_VAR 0 6
24781: PPUSH
24782: CALL_OW 264
24786: PUSH
24787: LD_INT 10
24789: PUSH
24790: EMPTY
24791: LIST
24792: IN
24793: IFFALSE 24814
// points := [ 35 , 110 , 70 ] ;
24795: LD_ADDR_VAR 0 9
24799: PUSH
24800: LD_INT 35
24802: PUSH
24803: LD_INT 110
24805: PUSH
24806: LD_INT 70
24808: PUSH
24809: EMPTY
24810: LIST
24811: LIST
24812: LIST
24813: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
24814: LD_VAR 0 6
24818: PPUSH
24819: CALL_OW 265
24823: PUSH
24824: LD_INT 25
24826: EQUAL
24827: IFFALSE 24848
// points := [ 80 , 65 , 100 ] ;
24829: LD_ADDR_VAR 0 9
24833: PUSH
24834: LD_INT 80
24836: PUSH
24837: LD_INT 65
24839: PUSH
24840: LD_INT 100
24842: PUSH
24843: EMPTY
24844: LIST
24845: LIST
24846: LIST
24847: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
24848: LD_VAR 0 6
24852: PPUSH
24853: CALL_OW 263
24857: PUSH
24858: LD_INT 1
24860: EQUAL
24861: IFFALSE 24896
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
24863: LD_ADDR_VAR 0 10
24867: PUSH
24868: LD_VAR 0 10
24872: PUSH
24873: LD_VAR 0 6
24877: PPUSH
24878: CALL_OW 311
24882: PPUSH
24883: LD_INT 3
24885: PPUSH
24886: CALL_OW 259
24890: PUSH
24891: LD_INT 4
24893: MUL
24894: MUL
24895: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
24896: LD_VAR 0 6
24900: PPUSH
24901: CALL_OW 263
24905: PUSH
24906: LD_INT 2
24908: EQUAL
24909: IFFALSE 24960
// begin j := IsControledBy ( i ) ;
24911: LD_ADDR_VAR 0 7
24915: PUSH
24916: LD_VAR 0 6
24920: PPUSH
24921: CALL_OW 312
24925: ST_TO_ADDR
// if j then
24926: LD_VAR 0 7
24930: IFFALSE 24960
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
24932: LD_ADDR_VAR 0 10
24936: PUSH
24937: LD_VAR 0 10
24941: PUSH
24942: LD_VAR 0 7
24946: PPUSH
24947: LD_INT 3
24949: PPUSH
24950: CALL_OW 259
24954: PUSH
24955: LD_INT 3
24957: MUL
24958: MUL
24959: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
24960: LD_VAR 0 6
24964: PPUSH
24965: CALL_OW 264
24969: PUSH
24970: LD_INT 5
24972: PUSH
24973: LD_INT 6
24975: PUSH
24976: LD_INT 46
24978: PUSH
24979: LD_INT 44
24981: PUSH
24982: LD_INT 47
24984: PUSH
24985: LD_INT 45
24987: PUSH
24988: LD_INT 28
24990: PUSH
24991: LD_INT 7
24993: PUSH
24994: LD_INT 27
24996: PUSH
24997: LD_INT 29
24999: PUSH
25000: EMPTY
25001: LIST
25002: LIST
25003: LIST
25004: LIST
25005: LIST
25006: LIST
25007: LIST
25008: LIST
25009: LIST
25010: LIST
25011: IN
25012: PUSH
25013: LD_VAR 0 1
25017: PPUSH
25018: LD_INT 52
25020: PPUSH
25021: CALL_OW 321
25025: PUSH
25026: LD_INT 2
25028: EQUAL
25029: AND
25030: IFFALSE 25047
// bpoints := bpoints * 1.2 ;
25032: LD_ADDR_VAR 0 10
25036: PUSH
25037: LD_VAR 0 10
25041: PUSH
25042: LD_REAL  1.20000000000000E+0000
25045: MUL
25046: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
25047: LD_VAR 0 6
25051: PPUSH
25052: CALL_OW 264
25056: PUSH
25057: LD_INT 6
25059: PUSH
25060: LD_INT 46
25062: PUSH
25063: LD_INT 47
25065: PUSH
25066: EMPTY
25067: LIST
25068: LIST
25069: LIST
25070: IN
25071: IFFALSE 25088
// bpoints := bpoints * 1.2 ;
25073: LD_ADDR_VAR 0 10
25077: PUSH
25078: LD_VAR 0 10
25082: PUSH
25083: LD_REAL  1.20000000000000E+0000
25086: MUL
25087: ST_TO_ADDR
// end ; unit_building :
25088: GO 25102
25090: LD_INT 3
25092: DOUBLE
25093: EQUAL
25094: IFTRUE 25098
25096: GO 25101
25098: POP
// ; end ;
25099: GO 25102
25101: POP
// for j = 1 to 3 do
25102: LD_ADDR_VAR 0 7
25106: PUSH
25107: DOUBLE
25108: LD_INT 1
25110: DEC
25111: ST_TO_ADDR
25112: LD_INT 3
25114: PUSH
25115: FOR_TO
25116: IFFALSE 25169
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
25118: LD_ADDR_VAR 0 5
25122: PUSH
25123: LD_VAR 0 5
25127: PPUSH
25128: LD_VAR 0 7
25132: PPUSH
25133: LD_VAR 0 5
25137: PUSH
25138: LD_VAR 0 7
25142: ARRAY
25143: PUSH
25144: LD_VAR 0 9
25148: PUSH
25149: LD_VAR 0 7
25153: ARRAY
25154: PUSH
25155: LD_VAR 0 10
25159: MUL
25160: PLUS
25161: PPUSH
25162: CALL_OW 1
25166: ST_TO_ADDR
25167: GO 25115
25169: POP
25170: POP
// end ;
25171: GO 23650
25173: POP
25174: POP
// result := Replace ( result , 4 , tmp ) ;
25175: LD_ADDR_VAR 0 5
25179: PUSH
25180: LD_VAR 0 5
25184: PPUSH
25185: LD_INT 4
25187: PPUSH
25188: LD_VAR 0 8
25192: PPUSH
25193: CALL_OW 1
25197: ST_TO_ADDR
// end ;
25198: LD_VAR 0 5
25202: RET
// export function DangerAtRange ( unit , range ) ; begin
25203: LD_INT 0
25205: PPUSH
// if not unit then
25206: LD_VAR 0 1
25210: NOT
25211: IFFALSE 25215
// exit ;
25213: GO 25260
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
25215: LD_ADDR_VAR 0 3
25219: PUSH
25220: LD_VAR 0 1
25224: PPUSH
25225: CALL_OW 255
25229: PPUSH
25230: LD_VAR 0 1
25234: PPUSH
25235: CALL_OW 250
25239: PPUSH
25240: LD_VAR 0 1
25244: PPUSH
25245: CALL_OW 251
25249: PPUSH
25250: LD_VAR 0 2
25254: PPUSH
25255: CALL 23502 0 4
25259: ST_TO_ADDR
// end ;
25260: LD_VAR 0 3
25264: RET
// export function DangerInArea ( side , area ) ; begin
25265: LD_INT 0
25267: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
25268: LD_ADDR_VAR 0 3
25272: PUSH
25273: LD_VAR 0 2
25277: PPUSH
25278: LD_INT 81
25280: PUSH
25281: LD_VAR 0 1
25285: PUSH
25286: EMPTY
25287: LIST
25288: LIST
25289: PPUSH
25290: CALL_OW 70
25294: ST_TO_ADDR
// end ;
25295: LD_VAR 0 3
25299: RET
// export function IsExtension ( b ) ; begin
25300: LD_INT 0
25302: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
25303: LD_ADDR_VAR 0 2
25307: PUSH
25308: LD_VAR 0 1
25312: PUSH
25313: LD_INT 23
25315: PUSH
25316: LD_INT 20
25318: PUSH
25319: LD_INT 22
25321: PUSH
25322: LD_INT 17
25324: PUSH
25325: LD_INT 24
25327: PUSH
25328: LD_INT 21
25330: PUSH
25331: LD_INT 19
25333: PUSH
25334: LD_INT 16
25336: PUSH
25337: LD_INT 25
25339: PUSH
25340: LD_INT 18
25342: PUSH
25343: EMPTY
25344: LIST
25345: LIST
25346: LIST
25347: LIST
25348: LIST
25349: LIST
25350: LIST
25351: LIST
25352: LIST
25353: LIST
25354: IN
25355: ST_TO_ADDR
// end ;
25356: LD_VAR 0 2
25360: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
25361: LD_INT 0
25363: PPUSH
25364: PPUSH
25365: PPUSH
// result := [ ] ;
25366: LD_ADDR_VAR 0 4
25370: PUSH
25371: EMPTY
25372: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
25373: LD_ADDR_VAR 0 5
25377: PUSH
25378: LD_VAR 0 2
25382: PPUSH
25383: LD_INT 21
25385: PUSH
25386: LD_INT 3
25388: PUSH
25389: EMPTY
25390: LIST
25391: LIST
25392: PPUSH
25393: CALL_OW 70
25397: ST_TO_ADDR
// if not tmp then
25398: LD_VAR 0 5
25402: NOT
25403: IFFALSE 25407
// exit ;
25405: GO 25471
// if checkLink then
25407: LD_VAR 0 3
25411: IFFALSE 25461
// begin for i in tmp do
25413: LD_ADDR_VAR 0 6
25417: PUSH
25418: LD_VAR 0 5
25422: PUSH
25423: FOR_IN
25424: IFFALSE 25459
// if GetBase ( i ) <> base then
25426: LD_VAR 0 6
25430: PPUSH
25431: CALL_OW 274
25435: PUSH
25436: LD_VAR 0 1
25440: NONEQUAL
25441: IFFALSE 25457
// ComLinkToBase ( base , i ) ;
25443: LD_VAR 0 1
25447: PPUSH
25448: LD_VAR 0 6
25452: PPUSH
25453: CALL_OW 169
25457: GO 25423
25459: POP
25460: POP
// end ; result := tmp ;
25461: LD_ADDR_VAR 0 4
25465: PUSH
25466: LD_VAR 0 5
25470: ST_TO_ADDR
// end ;
25471: LD_VAR 0 4
25475: RET
// export function ComComplete ( units , b ) ; var i ; begin
25476: LD_INT 0
25478: PPUSH
25479: PPUSH
// if not units then
25480: LD_VAR 0 1
25484: NOT
25485: IFFALSE 25489
// exit ;
25487: GO 25579
// for i in units do
25489: LD_ADDR_VAR 0 4
25493: PUSH
25494: LD_VAR 0 1
25498: PUSH
25499: FOR_IN
25500: IFFALSE 25577
// if BuildingStatus ( b ) = bs_build then
25502: LD_VAR 0 2
25506: PPUSH
25507: CALL_OW 461
25511: PUSH
25512: LD_INT 1
25514: EQUAL
25515: IFFALSE 25575
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
25517: LD_VAR 0 4
25521: PPUSH
25522: LD_STRING h
25524: PUSH
25525: LD_VAR 0 2
25529: PPUSH
25530: CALL_OW 250
25534: PUSH
25535: LD_VAR 0 2
25539: PPUSH
25540: CALL_OW 251
25544: PUSH
25545: LD_VAR 0 2
25549: PUSH
25550: LD_INT 0
25552: PUSH
25553: LD_INT 0
25555: PUSH
25556: LD_INT 0
25558: PUSH
25559: EMPTY
25560: LIST
25561: LIST
25562: LIST
25563: LIST
25564: LIST
25565: LIST
25566: LIST
25567: PUSH
25568: EMPTY
25569: LIST
25570: PPUSH
25571: CALL_OW 446
25575: GO 25499
25577: POP
25578: POP
// end ;
25579: LD_VAR 0 3
25583: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
25584: LD_INT 0
25586: PPUSH
25587: PPUSH
25588: PPUSH
25589: PPUSH
25590: PPUSH
25591: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
25592: LD_VAR 0 1
25596: NOT
25597: PUSH
25598: LD_VAR 0 1
25602: PPUSH
25603: CALL_OW 263
25607: PUSH
25608: LD_INT 2
25610: NONEQUAL
25611: OR
25612: IFFALSE 25616
// exit ;
25614: GO 25932
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
25616: LD_ADDR_VAR 0 6
25620: PUSH
25621: LD_INT 22
25623: PUSH
25624: LD_VAR 0 1
25628: PPUSH
25629: CALL_OW 255
25633: PUSH
25634: EMPTY
25635: LIST
25636: LIST
25637: PUSH
25638: LD_INT 2
25640: PUSH
25641: LD_INT 30
25643: PUSH
25644: LD_INT 36
25646: PUSH
25647: EMPTY
25648: LIST
25649: LIST
25650: PUSH
25651: LD_INT 34
25653: PUSH
25654: LD_INT 31
25656: PUSH
25657: EMPTY
25658: LIST
25659: LIST
25660: PUSH
25661: EMPTY
25662: LIST
25663: LIST
25664: LIST
25665: PUSH
25666: EMPTY
25667: LIST
25668: LIST
25669: PPUSH
25670: CALL_OW 69
25674: ST_TO_ADDR
// if not tmp then
25675: LD_VAR 0 6
25679: NOT
25680: IFFALSE 25684
// exit ;
25682: GO 25932
// result := [ ] ;
25684: LD_ADDR_VAR 0 2
25688: PUSH
25689: EMPTY
25690: ST_TO_ADDR
// for i in tmp do
25691: LD_ADDR_VAR 0 3
25695: PUSH
25696: LD_VAR 0 6
25700: PUSH
25701: FOR_IN
25702: IFFALSE 25773
// begin t := UnitsInside ( i ) ;
25704: LD_ADDR_VAR 0 4
25708: PUSH
25709: LD_VAR 0 3
25713: PPUSH
25714: CALL_OW 313
25718: ST_TO_ADDR
// if t then
25719: LD_VAR 0 4
25723: IFFALSE 25771
// for j in t do
25725: LD_ADDR_VAR 0 7
25729: PUSH
25730: LD_VAR 0 4
25734: PUSH
25735: FOR_IN
25736: IFFALSE 25769
// result := Replace ( result , result + 1 , j ) ;
25738: LD_ADDR_VAR 0 2
25742: PUSH
25743: LD_VAR 0 2
25747: PPUSH
25748: LD_VAR 0 2
25752: PUSH
25753: LD_INT 1
25755: PLUS
25756: PPUSH
25757: LD_VAR 0 7
25761: PPUSH
25762: CALL_OW 1
25766: ST_TO_ADDR
25767: GO 25735
25769: POP
25770: POP
// end ;
25771: GO 25701
25773: POP
25774: POP
// if not result then
25775: LD_VAR 0 2
25779: NOT
25780: IFFALSE 25784
// exit ;
25782: GO 25932
// mech := result [ 1 ] ;
25784: LD_ADDR_VAR 0 5
25788: PUSH
25789: LD_VAR 0 2
25793: PUSH
25794: LD_INT 1
25796: ARRAY
25797: ST_TO_ADDR
// if result > 1 then
25798: LD_VAR 0 2
25802: PUSH
25803: LD_INT 1
25805: GREATER
25806: IFFALSE 25918
// begin for i = 2 to result do
25808: LD_ADDR_VAR 0 3
25812: PUSH
25813: DOUBLE
25814: LD_INT 2
25816: DEC
25817: ST_TO_ADDR
25818: LD_VAR 0 2
25822: PUSH
25823: FOR_TO
25824: IFFALSE 25916
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
25826: LD_ADDR_VAR 0 4
25830: PUSH
25831: LD_VAR 0 2
25835: PUSH
25836: LD_VAR 0 3
25840: ARRAY
25841: PPUSH
25842: LD_INT 3
25844: PPUSH
25845: CALL_OW 259
25849: PUSH
25850: LD_VAR 0 2
25854: PUSH
25855: LD_VAR 0 3
25859: ARRAY
25860: PPUSH
25861: CALL_OW 432
25865: MINUS
25866: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
25867: LD_VAR 0 4
25871: PUSH
25872: LD_VAR 0 5
25876: PPUSH
25877: LD_INT 3
25879: PPUSH
25880: CALL_OW 259
25884: PUSH
25885: LD_VAR 0 5
25889: PPUSH
25890: CALL_OW 432
25894: MINUS
25895: GREATEREQUAL
25896: IFFALSE 25914
// mech := result [ i ] ;
25898: LD_ADDR_VAR 0 5
25902: PUSH
25903: LD_VAR 0 2
25907: PUSH
25908: LD_VAR 0 3
25912: ARRAY
25913: ST_TO_ADDR
// end ;
25914: GO 25823
25916: POP
25917: POP
// end ; ComLinkTo ( vehicle , mech ) ;
25918: LD_VAR 0 1
25922: PPUSH
25923: LD_VAR 0 5
25927: PPUSH
25928: CALL_OW 135
// end ;
25932: LD_VAR 0 2
25936: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
25937: LD_INT 0
25939: PPUSH
25940: PPUSH
25941: PPUSH
25942: PPUSH
25943: PPUSH
25944: PPUSH
25945: PPUSH
25946: PPUSH
25947: PPUSH
25948: PPUSH
25949: PPUSH
25950: PPUSH
25951: PPUSH
// result := [ ] ;
25952: LD_ADDR_VAR 0 7
25956: PUSH
25957: EMPTY
25958: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
25959: LD_VAR 0 1
25963: PPUSH
25964: CALL_OW 266
25968: PUSH
25969: LD_INT 0
25971: PUSH
25972: LD_INT 1
25974: PUSH
25975: EMPTY
25976: LIST
25977: LIST
25978: IN
25979: NOT
25980: IFFALSE 25984
// exit ;
25982: GO 27618
// if name then
25984: LD_VAR 0 3
25988: IFFALSE 26004
// SetBName ( base_dep , name ) ;
25990: LD_VAR 0 1
25994: PPUSH
25995: LD_VAR 0 3
25999: PPUSH
26000: CALL_OW 500
// base := GetBase ( base_dep ) ;
26004: LD_ADDR_VAR 0 15
26008: PUSH
26009: LD_VAR 0 1
26013: PPUSH
26014: CALL_OW 274
26018: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
26019: LD_ADDR_VAR 0 16
26023: PUSH
26024: LD_VAR 0 1
26028: PPUSH
26029: CALL_OW 255
26033: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
26034: LD_ADDR_VAR 0 17
26038: PUSH
26039: LD_VAR 0 1
26043: PPUSH
26044: CALL_OW 248
26048: ST_TO_ADDR
// if sources then
26049: LD_VAR 0 5
26053: IFFALSE 26100
// for i = 1 to 3 do
26055: LD_ADDR_VAR 0 8
26059: PUSH
26060: DOUBLE
26061: LD_INT 1
26063: DEC
26064: ST_TO_ADDR
26065: LD_INT 3
26067: PUSH
26068: FOR_TO
26069: IFFALSE 26098
// AddResourceType ( base , i , sources [ i ] ) ;
26071: LD_VAR 0 15
26075: PPUSH
26076: LD_VAR 0 8
26080: PPUSH
26081: LD_VAR 0 5
26085: PUSH
26086: LD_VAR 0 8
26090: ARRAY
26091: PPUSH
26092: CALL_OW 276
26096: GO 26068
26098: POP
26099: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
26100: LD_ADDR_VAR 0 18
26104: PUSH
26105: LD_VAR 0 15
26109: PPUSH
26110: LD_VAR 0 2
26114: PPUSH
26115: LD_INT 1
26117: PPUSH
26118: CALL 25361 0 3
26122: ST_TO_ADDR
// InitHc ;
26123: CALL_OW 19
// InitUc ;
26127: CALL_OW 18
// uc_side := side ;
26131: LD_ADDR_OWVAR 20
26135: PUSH
26136: LD_VAR 0 16
26140: ST_TO_ADDR
// uc_nation := nation ;
26141: LD_ADDR_OWVAR 21
26145: PUSH
26146: LD_VAR 0 17
26150: ST_TO_ADDR
// if buildings then
26151: LD_VAR 0 18
26155: IFFALSE 27477
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
26157: LD_ADDR_VAR 0 19
26161: PUSH
26162: LD_VAR 0 18
26166: PPUSH
26167: LD_INT 2
26169: PUSH
26170: LD_INT 30
26172: PUSH
26173: LD_INT 29
26175: PUSH
26176: EMPTY
26177: LIST
26178: LIST
26179: PUSH
26180: LD_INT 30
26182: PUSH
26183: LD_INT 30
26185: PUSH
26186: EMPTY
26187: LIST
26188: LIST
26189: PUSH
26190: EMPTY
26191: LIST
26192: LIST
26193: LIST
26194: PPUSH
26195: CALL_OW 72
26199: ST_TO_ADDR
// if tmp then
26200: LD_VAR 0 19
26204: IFFALSE 26252
// for i in tmp do
26206: LD_ADDR_VAR 0 8
26210: PUSH
26211: LD_VAR 0 19
26215: PUSH
26216: FOR_IN
26217: IFFALSE 26250
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
26219: LD_VAR 0 8
26223: PPUSH
26224: CALL_OW 250
26228: PPUSH
26229: LD_VAR 0 8
26233: PPUSH
26234: CALL_OW 251
26238: PPUSH
26239: LD_VAR 0 16
26243: PPUSH
26244: CALL_OW 441
26248: GO 26216
26250: POP
26251: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
26252: LD_VAR 0 18
26256: PPUSH
26257: LD_INT 2
26259: PUSH
26260: LD_INT 30
26262: PUSH
26263: LD_INT 32
26265: PUSH
26266: EMPTY
26267: LIST
26268: LIST
26269: PUSH
26270: LD_INT 30
26272: PUSH
26273: LD_INT 33
26275: PUSH
26276: EMPTY
26277: LIST
26278: LIST
26279: PUSH
26280: EMPTY
26281: LIST
26282: LIST
26283: LIST
26284: PPUSH
26285: CALL_OW 72
26289: IFFALSE 26377
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
26291: LD_ADDR_VAR 0 8
26295: PUSH
26296: LD_VAR 0 18
26300: PPUSH
26301: LD_INT 2
26303: PUSH
26304: LD_INT 30
26306: PUSH
26307: LD_INT 32
26309: PUSH
26310: EMPTY
26311: LIST
26312: LIST
26313: PUSH
26314: LD_INT 30
26316: PUSH
26317: LD_INT 33
26319: PUSH
26320: EMPTY
26321: LIST
26322: LIST
26323: PUSH
26324: EMPTY
26325: LIST
26326: LIST
26327: LIST
26328: PPUSH
26329: CALL_OW 72
26333: PUSH
26334: FOR_IN
26335: IFFALSE 26375
// begin if not GetBWeapon ( i ) then
26337: LD_VAR 0 8
26341: PPUSH
26342: CALL_OW 269
26346: NOT
26347: IFFALSE 26373
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
26349: LD_VAR 0 8
26353: PPUSH
26354: LD_VAR 0 8
26358: PPUSH
26359: LD_VAR 0 2
26363: PPUSH
26364: CALL 27623 0 2
26368: PPUSH
26369: CALL_OW 431
// end ;
26373: GO 26334
26375: POP
26376: POP
// end ; for i = 1 to personel do
26377: LD_ADDR_VAR 0 8
26381: PUSH
26382: DOUBLE
26383: LD_INT 1
26385: DEC
26386: ST_TO_ADDR
26387: LD_VAR 0 6
26391: PUSH
26392: FOR_TO
26393: IFFALSE 27457
// begin if i > 4 then
26395: LD_VAR 0 8
26399: PUSH
26400: LD_INT 4
26402: GREATER
26403: IFFALSE 26407
// break ;
26405: GO 27457
// case i of 1 :
26407: LD_VAR 0 8
26411: PUSH
26412: LD_INT 1
26414: DOUBLE
26415: EQUAL
26416: IFTRUE 26420
26418: GO 26500
26420: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
26421: LD_ADDR_VAR 0 12
26425: PUSH
26426: LD_VAR 0 18
26430: PPUSH
26431: LD_INT 22
26433: PUSH
26434: LD_VAR 0 16
26438: PUSH
26439: EMPTY
26440: LIST
26441: LIST
26442: PUSH
26443: LD_INT 58
26445: PUSH
26446: EMPTY
26447: LIST
26448: PUSH
26449: LD_INT 2
26451: PUSH
26452: LD_INT 30
26454: PUSH
26455: LD_INT 32
26457: PUSH
26458: EMPTY
26459: LIST
26460: LIST
26461: PUSH
26462: LD_INT 30
26464: PUSH
26465: LD_INT 4
26467: PUSH
26468: EMPTY
26469: LIST
26470: LIST
26471: PUSH
26472: LD_INT 30
26474: PUSH
26475: LD_INT 5
26477: PUSH
26478: EMPTY
26479: LIST
26480: LIST
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: LIST
26486: LIST
26487: PUSH
26488: EMPTY
26489: LIST
26490: LIST
26491: LIST
26492: PPUSH
26493: CALL_OW 72
26497: ST_TO_ADDR
26498: GO 26722
26500: LD_INT 2
26502: DOUBLE
26503: EQUAL
26504: IFTRUE 26508
26506: GO 26570
26508: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
26509: LD_ADDR_VAR 0 12
26513: PUSH
26514: LD_VAR 0 18
26518: PPUSH
26519: LD_INT 22
26521: PUSH
26522: LD_VAR 0 16
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: PUSH
26531: LD_INT 2
26533: PUSH
26534: LD_INT 30
26536: PUSH
26537: LD_INT 0
26539: PUSH
26540: EMPTY
26541: LIST
26542: LIST
26543: PUSH
26544: LD_INT 30
26546: PUSH
26547: LD_INT 1
26549: PUSH
26550: EMPTY
26551: LIST
26552: LIST
26553: PUSH
26554: EMPTY
26555: LIST
26556: LIST
26557: LIST
26558: PUSH
26559: EMPTY
26560: LIST
26561: LIST
26562: PPUSH
26563: CALL_OW 72
26567: ST_TO_ADDR
26568: GO 26722
26570: LD_INT 3
26572: DOUBLE
26573: EQUAL
26574: IFTRUE 26578
26576: GO 26640
26578: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
26579: LD_ADDR_VAR 0 12
26583: PUSH
26584: LD_VAR 0 18
26588: PPUSH
26589: LD_INT 22
26591: PUSH
26592: LD_VAR 0 16
26596: PUSH
26597: EMPTY
26598: LIST
26599: LIST
26600: PUSH
26601: LD_INT 2
26603: PUSH
26604: LD_INT 30
26606: PUSH
26607: LD_INT 2
26609: PUSH
26610: EMPTY
26611: LIST
26612: LIST
26613: PUSH
26614: LD_INT 30
26616: PUSH
26617: LD_INT 3
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: PUSH
26624: EMPTY
26625: LIST
26626: LIST
26627: LIST
26628: PUSH
26629: EMPTY
26630: LIST
26631: LIST
26632: PPUSH
26633: CALL_OW 72
26637: ST_TO_ADDR
26638: GO 26722
26640: LD_INT 4
26642: DOUBLE
26643: EQUAL
26644: IFTRUE 26648
26646: GO 26721
26648: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
26649: LD_ADDR_VAR 0 12
26653: PUSH
26654: LD_VAR 0 18
26658: PPUSH
26659: LD_INT 22
26661: PUSH
26662: LD_VAR 0 16
26666: PUSH
26667: EMPTY
26668: LIST
26669: LIST
26670: PUSH
26671: LD_INT 2
26673: PUSH
26674: LD_INT 30
26676: PUSH
26677: LD_INT 6
26679: PUSH
26680: EMPTY
26681: LIST
26682: LIST
26683: PUSH
26684: LD_INT 30
26686: PUSH
26687: LD_INT 7
26689: PUSH
26690: EMPTY
26691: LIST
26692: LIST
26693: PUSH
26694: LD_INT 30
26696: PUSH
26697: LD_INT 8
26699: PUSH
26700: EMPTY
26701: LIST
26702: LIST
26703: PUSH
26704: EMPTY
26705: LIST
26706: LIST
26707: LIST
26708: LIST
26709: PUSH
26710: EMPTY
26711: LIST
26712: LIST
26713: PPUSH
26714: CALL_OW 72
26718: ST_TO_ADDR
26719: GO 26722
26721: POP
// if i = 1 then
26722: LD_VAR 0 8
26726: PUSH
26727: LD_INT 1
26729: EQUAL
26730: IFFALSE 26841
// begin tmp := [ ] ;
26732: LD_ADDR_VAR 0 19
26736: PUSH
26737: EMPTY
26738: ST_TO_ADDR
// for j in f do
26739: LD_ADDR_VAR 0 9
26743: PUSH
26744: LD_VAR 0 12
26748: PUSH
26749: FOR_IN
26750: IFFALSE 26823
// if GetBType ( j ) = b_bunker then
26752: LD_VAR 0 9
26756: PPUSH
26757: CALL_OW 266
26761: PUSH
26762: LD_INT 32
26764: EQUAL
26765: IFFALSE 26792
// tmp := Insert ( tmp , 1 , j ) else
26767: LD_ADDR_VAR 0 19
26771: PUSH
26772: LD_VAR 0 19
26776: PPUSH
26777: LD_INT 1
26779: PPUSH
26780: LD_VAR 0 9
26784: PPUSH
26785: CALL_OW 2
26789: ST_TO_ADDR
26790: GO 26821
// tmp := Insert ( tmp , tmp + 1 , j ) ;
26792: LD_ADDR_VAR 0 19
26796: PUSH
26797: LD_VAR 0 19
26801: PPUSH
26802: LD_VAR 0 19
26806: PUSH
26807: LD_INT 1
26809: PLUS
26810: PPUSH
26811: LD_VAR 0 9
26815: PPUSH
26816: CALL_OW 2
26820: ST_TO_ADDR
26821: GO 26749
26823: POP
26824: POP
// if tmp then
26825: LD_VAR 0 19
26829: IFFALSE 26841
// f := tmp ;
26831: LD_ADDR_VAR 0 12
26835: PUSH
26836: LD_VAR 0 19
26840: ST_TO_ADDR
// end ; x := personel [ i ] ;
26841: LD_ADDR_VAR 0 13
26845: PUSH
26846: LD_VAR 0 6
26850: PUSH
26851: LD_VAR 0 8
26855: ARRAY
26856: ST_TO_ADDR
// if x = - 1 then
26857: LD_VAR 0 13
26861: PUSH
26862: LD_INT 1
26864: NEG
26865: EQUAL
26866: IFFALSE 27075
// begin for j in f do
26868: LD_ADDR_VAR 0 9
26872: PUSH
26873: LD_VAR 0 12
26877: PUSH
26878: FOR_IN
26879: IFFALSE 27071
// repeat InitHc ;
26881: CALL_OW 19
// if GetBType ( j ) = b_barracks then
26885: LD_VAR 0 9
26889: PPUSH
26890: CALL_OW 266
26894: PUSH
26895: LD_INT 5
26897: EQUAL
26898: IFFALSE 26968
// begin if UnitsInside ( j ) < 3 then
26900: LD_VAR 0 9
26904: PPUSH
26905: CALL_OW 313
26909: PUSH
26910: LD_INT 3
26912: LESS
26913: IFFALSE 26949
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26915: LD_INT 0
26917: PPUSH
26918: LD_INT 5
26920: PUSH
26921: LD_INT 8
26923: PUSH
26924: LD_INT 9
26926: PUSH
26927: EMPTY
26928: LIST
26929: LIST
26930: LIST
26931: PUSH
26932: LD_VAR 0 17
26936: ARRAY
26937: PPUSH
26938: LD_VAR 0 4
26942: PPUSH
26943: CALL_OW 380
26947: GO 26966
// PrepareHuman ( false , i , skill ) ;
26949: LD_INT 0
26951: PPUSH
26952: LD_VAR 0 8
26956: PPUSH
26957: LD_VAR 0 4
26961: PPUSH
26962: CALL_OW 380
// end else
26966: GO 26985
// PrepareHuman ( false , i , skill ) ;
26968: LD_INT 0
26970: PPUSH
26971: LD_VAR 0 8
26975: PPUSH
26976: LD_VAR 0 4
26980: PPUSH
26981: CALL_OW 380
// un := CreateHuman ;
26985: LD_ADDR_VAR 0 14
26989: PUSH
26990: CALL_OW 44
26994: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26995: LD_ADDR_VAR 0 7
26999: PUSH
27000: LD_VAR 0 7
27004: PPUSH
27005: LD_INT 1
27007: PPUSH
27008: LD_VAR 0 14
27012: PPUSH
27013: CALL_OW 2
27017: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
27018: LD_VAR 0 14
27022: PPUSH
27023: LD_VAR 0 9
27027: PPUSH
27028: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
27032: LD_VAR 0 9
27036: PPUSH
27037: CALL_OW 313
27041: PUSH
27042: LD_INT 6
27044: EQUAL
27045: PUSH
27046: LD_VAR 0 9
27050: PPUSH
27051: CALL_OW 266
27055: PUSH
27056: LD_INT 32
27058: PUSH
27059: LD_INT 31
27061: PUSH
27062: EMPTY
27063: LIST
27064: LIST
27065: IN
27066: OR
27067: IFFALSE 26881
27069: GO 26878
27071: POP
27072: POP
// end else
27073: GO 27455
// for j = 1 to x do
27075: LD_ADDR_VAR 0 9
27079: PUSH
27080: DOUBLE
27081: LD_INT 1
27083: DEC
27084: ST_TO_ADDR
27085: LD_VAR 0 13
27089: PUSH
27090: FOR_TO
27091: IFFALSE 27453
// begin InitHc ;
27093: CALL_OW 19
// if not f then
27097: LD_VAR 0 12
27101: NOT
27102: IFFALSE 27191
// begin PrepareHuman ( false , i , skill ) ;
27104: LD_INT 0
27106: PPUSH
27107: LD_VAR 0 8
27111: PPUSH
27112: LD_VAR 0 4
27116: PPUSH
27117: CALL_OW 380
// un := CreateHuman ;
27121: LD_ADDR_VAR 0 14
27125: PUSH
27126: CALL_OW 44
27130: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27131: LD_ADDR_VAR 0 7
27135: PUSH
27136: LD_VAR 0 7
27140: PPUSH
27141: LD_INT 1
27143: PPUSH
27144: LD_VAR 0 14
27148: PPUSH
27149: CALL_OW 2
27153: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
27154: LD_VAR 0 14
27158: PPUSH
27159: LD_VAR 0 1
27163: PPUSH
27164: CALL_OW 250
27168: PPUSH
27169: LD_VAR 0 1
27173: PPUSH
27174: CALL_OW 251
27178: PPUSH
27179: LD_INT 10
27181: PPUSH
27182: LD_INT 0
27184: PPUSH
27185: CALL_OW 50
// continue ;
27189: GO 27090
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
27191: LD_VAR 0 12
27195: PUSH
27196: LD_INT 1
27198: ARRAY
27199: PPUSH
27200: CALL_OW 313
27204: PUSH
27205: LD_VAR 0 12
27209: PUSH
27210: LD_INT 1
27212: ARRAY
27213: PPUSH
27214: CALL_OW 266
27218: PUSH
27219: LD_INT 32
27221: PUSH
27222: LD_INT 31
27224: PUSH
27225: EMPTY
27226: LIST
27227: LIST
27228: IN
27229: AND
27230: PUSH
27231: LD_VAR 0 12
27235: PUSH
27236: LD_INT 1
27238: ARRAY
27239: PPUSH
27240: CALL_OW 313
27244: PUSH
27245: LD_INT 6
27247: EQUAL
27248: OR
27249: IFFALSE 27269
// f := Delete ( f , 1 ) ;
27251: LD_ADDR_VAR 0 12
27255: PUSH
27256: LD_VAR 0 12
27260: PPUSH
27261: LD_INT 1
27263: PPUSH
27264: CALL_OW 3
27268: ST_TO_ADDR
// if not f then
27269: LD_VAR 0 12
27273: NOT
27274: IFFALSE 27292
// begin x := x + 2 ;
27276: LD_ADDR_VAR 0 13
27280: PUSH
27281: LD_VAR 0 13
27285: PUSH
27286: LD_INT 2
27288: PLUS
27289: ST_TO_ADDR
// continue ;
27290: GO 27090
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
27292: LD_VAR 0 12
27296: PUSH
27297: LD_INT 1
27299: ARRAY
27300: PPUSH
27301: CALL_OW 266
27305: PUSH
27306: LD_INT 5
27308: EQUAL
27309: IFFALSE 27383
// begin if UnitsInside ( f [ 1 ] ) < 3 then
27311: LD_VAR 0 12
27315: PUSH
27316: LD_INT 1
27318: ARRAY
27319: PPUSH
27320: CALL_OW 313
27324: PUSH
27325: LD_INT 3
27327: LESS
27328: IFFALSE 27364
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
27330: LD_INT 0
27332: PPUSH
27333: LD_INT 5
27335: PUSH
27336: LD_INT 8
27338: PUSH
27339: LD_INT 9
27341: PUSH
27342: EMPTY
27343: LIST
27344: LIST
27345: LIST
27346: PUSH
27347: LD_VAR 0 17
27351: ARRAY
27352: PPUSH
27353: LD_VAR 0 4
27357: PPUSH
27358: CALL_OW 380
27362: GO 27381
// PrepareHuman ( false , i , skill ) ;
27364: LD_INT 0
27366: PPUSH
27367: LD_VAR 0 8
27371: PPUSH
27372: LD_VAR 0 4
27376: PPUSH
27377: CALL_OW 380
// end else
27381: GO 27400
// PrepareHuman ( false , i , skill ) ;
27383: LD_INT 0
27385: PPUSH
27386: LD_VAR 0 8
27390: PPUSH
27391: LD_VAR 0 4
27395: PPUSH
27396: CALL_OW 380
// un := CreateHuman ;
27400: LD_ADDR_VAR 0 14
27404: PUSH
27405: CALL_OW 44
27409: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27410: LD_ADDR_VAR 0 7
27414: PUSH
27415: LD_VAR 0 7
27419: PPUSH
27420: LD_INT 1
27422: PPUSH
27423: LD_VAR 0 14
27427: PPUSH
27428: CALL_OW 2
27432: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
27433: LD_VAR 0 14
27437: PPUSH
27438: LD_VAR 0 12
27442: PUSH
27443: LD_INT 1
27445: ARRAY
27446: PPUSH
27447: CALL_OW 52
// end ;
27451: GO 27090
27453: POP
27454: POP
// end ;
27455: GO 26392
27457: POP
27458: POP
// result := result ^ buildings ;
27459: LD_ADDR_VAR 0 7
27463: PUSH
27464: LD_VAR 0 7
27468: PUSH
27469: LD_VAR 0 18
27473: ADD
27474: ST_TO_ADDR
// end else
27475: GO 27618
// begin for i = 1 to personel do
27477: LD_ADDR_VAR 0 8
27481: PUSH
27482: DOUBLE
27483: LD_INT 1
27485: DEC
27486: ST_TO_ADDR
27487: LD_VAR 0 6
27491: PUSH
27492: FOR_TO
27493: IFFALSE 27616
// begin if i > 4 then
27495: LD_VAR 0 8
27499: PUSH
27500: LD_INT 4
27502: GREATER
27503: IFFALSE 27507
// break ;
27505: GO 27616
// x := personel [ i ] ;
27507: LD_ADDR_VAR 0 13
27511: PUSH
27512: LD_VAR 0 6
27516: PUSH
27517: LD_VAR 0 8
27521: ARRAY
27522: ST_TO_ADDR
// if x = - 1 then
27523: LD_VAR 0 13
27527: PUSH
27528: LD_INT 1
27530: NEG
27531: EQUAL
27532: IFFALSE 27536
// continue ;
27534: GO 27492
// PrepareHuman ( false , i , skill ) ;
27536: LD_INT 0
27538: PPUSH
27539: LD_VAR 0 8
27543: PPUSH
27544: LD_VAR 0 4
27548: PPUSH
27549: CALL_OW 380
// un := CreateHuman ;
27553: LD_ADDR_VAR 0 14
27557: PUSH
27558: CALL_OW 44
27562: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
27563: LD_VAR 0 14
27567: PPUSH
27568: LD_VAR 0 1
27572: PPUSH
27573: CALL_OW 250
27577: PPUSH
27578: LD_VAR 0 1
27582: PPUSH
27583: CALL_OW 251
27587: PPUSH
27588: LD_INT 10
27590: PPUSH
27591: LD_INT 0
27593: PPUSH
27594: CALL_OW 50
// result := result ^ un ;
27598: LD_ADDR_VAR 0 7
27602: PUSH
27603: LD_VAR 0 7
27607: PUSH
27608: LD_VAR 0 14
27612: ADD
27613: ST_TO_ADDR
// end ;
27614: GO 27492
27616: POP
27617: POP
// end ; end ;
27618: LD_VAR 0 7
27622: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
27623: LD_INT 0
27625: PPUSH
27626: PPUSH
27627: PPUSH
27628: PPUSH
27629: PPUSH
27630: PPUSH
27631: PPUSH
27632: PPUSH
27633: PPUSH
27634: PPUSH
27635: PPUSH
27636: PPUSH
27637: PPUSH
27638: PPUSH
27639: PPUSH
27640: PPUSH
// result := false ;
27641: LD_ADDR_VAR 0 3
27645: PUSH
27646: LD_INT 0
27648: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
27649: LD_VAR 0 1
27653: NOT
27654: PUSH
27655: LD_VAR 0 1
27659: PPUSH
27660: CALL_OW 266
27664: PUSH
27665: LD_INT 32
27667: PUSH
27668: LD_INT 33
27670: PUSH
27671: EMPTY
27672: LIST
27673: LIST
27674: IN
27675: NOT
27676: OR
27677: IFFALSE 27681
// exit ;
27679: GO 28790
// nat := GetNation ( tower ) ;
27681: LD_ADDR_VAR 0 12
27685: PUSH
27686: LD_VAR 0 1
27690: PPUSH
27691: CALL_OW 248
27695: ST_TO_ADDR
// side := GetSide ( tower ) ;
27696: LD_ADDR_VAR 0 16
27700: PUSH
27701: LD_VAR 0 1
27705: PPUSH
27706: CALL_OW 255
27710: ST_TO_ADDR
// x := GetX ( tower ) ;
27711: LD_ADDR_VAR 0 10
27715: PUSH
27716: LD_VAR 0 1
27720: PPUSH
27721: CALL_OW 250
27725: ST_TO_ADDR
// y := GetY ( tower ) ;
27726: LD_ADDR_VAR 0 11
27730: PUSH
27731: LD_VAR 0 1
27735: PPUSH
27736: CALL_OW 251
27740: ST_TO_ADDR
// if not x or not y then
27741: LD_VAR 0 10
27745: NOT
27746: PUSH
27747: LD_VAR 0 11
27751: NOT
27752: OR
27753: IFFALSE 27757
// exit ;
27755: GO 28790
// weapon := 0 ;
27757: LD_ADDR_VAR 0 18
27761: PUSH
27762: LD_INT 0
27764: ST_TO_ADDR
// fac_list := [ ] ;
27765: LD_ADDR_VAR 0 17
27769: PUSH
27770: EMPTY
27771: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
27772: LD_ADDR_VAR 0 6
27776: PUSH
27777: LD_VAR 0 1
27781: PPUSH
27782: CALL_OW 274
27786: PPUSH
27787: LD_VAR 0 2
27791: PPUSH
27792: LD_INT 0
27794: PPUSH
27795: CALL 25361 0 3
27799: PPUSH
27800: LD_INT 30
27802: PUSH
27803: LD_INT 3
27805: PUSH
27806: EMPTY
27807: LIST
27808: LIST
27809: PPUSH
27810: CALL_OW 72
27814: ST_TO_ADDR
// if not factories then
27815: LD_VAR 0 6
27819: NOT
27820: IFFALSE 27824
// exit ;
27822: GO 28790
// for i in factories do
27824: LD_ADDR_VAR 0 8
27828: PUSH
27829: LD_VAR 0 6
27833: PUSH
27834: FOR_IN
27835: IFFALSE 27860
// fac_list := fac_list union AvailableWeaponList ( i ) ;
27837: LD_ADDR_VAR 0 17
27841: PUSH
27842: LD_VAR 0 17
27846: PUSH
27847: LD_VAR 0 8
27851: PPUSH
27852: CALL_OW 478
27856: UNION
27857: ST_TO_ADDR
27858: GO 27834
27860: POP
27861: POP
// if not fac_list then
27862: LD_VAR 0 17
27866: NOT
27867: IFFALSE 27871
// exit ;
27869: GO 28790
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
27871: LD_ADDR_VAR 0 5
27875: PUSH
27876: LD_INT 4
27878: PUSH
27879: LD_INT 5
27881: PUSH
27882: LD_INT 9
27884: PUSH
27885: LD_INT 10
27887: PUSH
27888: LD_INT 6
27890: PUSH
27891: LD_INT 7
27893: PUSH
27894: LD_INT 11
27896: PUSH
27897: EMPTY
27898: LIST
27899: LIST
27900: LIST
27901: LIST
27902: LIST
27903: LIST
27904: LIST
27905: PUSH
27906: LD_INT 27
27908: PUSH
27909: LD_INT 28
27911: PUSH
27912: LD_INT 26
27914: PUSH
27915: LD_INT 30
27917: PUSH
27918: EMPTY
27919: LIST
27920: LIST
27921: LIST
27922: LIST
27923: PUSH
27924: LD_INT 43
27926: PUSH
27927: LD_INT 44
27929: PUSH
27930: LD_INT 46
27932: PUSH
27933: LD_INT 45
27935: PUSH
27936: LD_INT 47
27938: PUSH
27939: LD_INT 49
27941: PUSH
27942: EMPTY
27943: LIST
27944: LIST
27945: LIST
27946: LIST
27947: LIST
27948: LIST
27949: PUSH
27950: EMPTY
27951: LIST
27952: LIST
27953: LIST
27954: PUSH
27955: LD_VAR 0 12
27959: ARRAY
27960: ST_TO_ADDR
// list := list isect fac_list ;
27961: LD_ADDR_VAR 0 5
27965: PUSH
27966: LD_VAR 0 5
27970: PUSH
27971: LD_VAR 0 17
27975: ISECT
27976: ST_TO_ADDR
// if not list then
27977: LD_VAR 0 5
27981: NOT
27982: IFFALSE 27986
// exit ;
27984: GO 28790
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
27986: LD_VAR 0 12
27990: PUSH
27991: LD_INT 3
27993: EQUAL
27994: PUSH
27995: LD_INT 49
27997: PUSH
27998: LD_VAR 0 5
28002: IN
28003: AND
28004: PUSH
28005: LD_INT 31
28007: PPUSH
28008: LD_VAR 0 16
28012: PPUSH
28013: CALL_OW 321
28017: PUSH
28018: LD_INT 2
28020: EQUAL
28021: AND
28022: IFFALSE 28082
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
28024: LD_INT 22
28026: PUSH
28027: LD_VAR 0 16
28031: PUSH
28032: EMPTY
28033: LIST
28034: LIST
28035: PUSH
28036: LD_INT 35
28038: PUSH
28039: LD_INT 49
28041: PUSH
28042: EMPTY
28043: LIST
28044: LIST
28045: PUSH
28046: LD_INT 91
28048: PUSH
28049: LD_VAR 0 1
28053: PUSH
28054: LD_INT 10
28056: PUSH
28057: EMPTY
28058: LIST
28059: LIST
28060: LIST
28061: PUSH
28062: EMPTY
28063: LIST
28064: LIST
28065: LIST
28066: PPUSH
28067: CALL_OW 69
28071: NOT
28072: IFFALSE 28082
// weapon := ru_time_lapser ;
28074: LD_ADDR_VAR 0 18
28078: PUSH
28079: LD_INT 49
28081: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
28082: LD_VAR 0 12
28086: PUSH
28087: LD_INT 1
28089: PUSH
28090: LD_INT 2
28092: PUSH
28093: EMPTY
28094: LIST
28095: LIST
28096: IN
28097: PUSH
28098: LD_INT 11
28100: PUSH
28101: LD_VAR 0 5
28105: IN
28106: PUSH
28107: LD_INT 30
28109: PUSH
28110: LD_VAR 0 5
28114: IN
28115: OR
28116: AND
28117: PUSH
28118: LD_INT 6
28120: PPUSH
28121: LD_VAR 0 16
28125: PPUSH
28126: CALL_OW 321
28130: PUSH
28131: LD_INT 2
28133: EQUAL
28134: AND
28135: IFFALSE 28300
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
28137: LD_INT 22
28139: PUSH
28140: LD_VAR 0 16
28144: PUSH
28145: EMPTY
28146: LIST
28147: LIST
28148: PUSH
28149: LD_INT 2
28151: PUSH
28152: LD_INT 35
28154: PUSH
28155: LD_INT 11
28157: PUSH
28158: EMPTY
28159: LIST
28160: LIST
28161: PUSH
28162: LD_INT 35
28164: PUSH
28165: LD_INT 30
28167: PUSH
28168: EMPTY
28169: LIST
28170: LIST
28171: PUSH
28172: EMPTY
28173: LIST
28174: LIST
28175: LIST
28176: PUSH
28177: LD_INT 91
28179: PUSH
28180: LD_VAR 0 1
28184: PUSH
28185: LD_INT 18
28187: PUSH
28188: EMPTY
28189: LIST
28190: LIST
28191: LIST
28192: PUSH
28193: EMPTY
28194: LIST
28195: LIST
28196: LIST
28197: PPUSH
28198: CALL_OW 69
28202: NOT
28203: PUSH
28204: LD_INT 22
28206: PUSH
28207: LD_VAR 0 16
28211: PUSH
28212: EMPTY
28213: LIST
28214: LIST
28215: PUSH
28216: LD_INT 2
28218: PUSH
28219: LD_INT 30
28221: PUSH
28222: LD_INT 32
28224: PUSH
28225: EMPTY
28226: LIST
28227: LIST
28228: PUSH
28229: LD_INT 30
28231: PUSH
28232: LD_INT 33
28234: PUSH
28235: EMPTY
28236: LIST
28237: LIST
28238: PUSH
28239: EMPTY
28240: LIST
28241: LIST
28242: LIST
28243: PUSH
28244: LD_INT 91
28246: PUSH
28247: LD_VAR 0 1
28251: PUSH
28252: LD_INT 12
28254: PUSH
28255: EMPTY
28256: LIST
28257: LIST
28258: LIST
28259: PUSH
28260: EMPTY
28261: LIST
28262: LIST
28263: LIST
28264: PUSH
28265: EMPTY
28266: LIST
28267: PPUSH
28268: CALL_OW 69
28272: PUSH
28273: LD_INT 2
28275: GREATER
28276: AND
28277: IFFALSE 28300
// weapon := [ us_radar , ar_radar ] [ nat ] ;
28279: LD_ADDR_VAR 0 18
28283: PUSH
28284: LD_INT 11
28286: PUSH
28287: LD_INT 30
28289: PUSH
28290: EMPTY
28291: LIST
28292: LIST
28293: PUSH
28294: LD_VAR 0 12
28298: ARRAY
28299: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
28300: LD_VAR 0 18
28304: NOT
28305: PUSH
28306: LD_INT 40
28308: PPUSH
28309: LD_VAR 0 16
28313: PPUSH
28314: CALL_OW 321
28318: PUSH
28319: LD_INT 2
28321: EQUAL
28322: AND
28323: PUSH
28324: LD_INT 7
28326: PUSH
28327: LD_VAR 0 5
28331: IN
28332: PUSH
28333: LD_INT 28
28335: PUSH
28336: LD_VAR 0 5
28340: IN
28341: OR
28342: PUSH
28343: LD_INT 45
28345: PUSH
28346: LD_VAR 0 5
28350: IN
28351: OR
28352: AND
28353: IFFALSE 28607
// begin hex := GetHexInfo ( x , y ) ;
28355: LD_ADDR_VAR 0 4
28359: PUSH
28360: LD_VAR 0 10
28364: PPUSH
28365: LD_VAR 0 11
28369: PPUSH
28370: CALL_OW 546
28374: ST_TO_ADDR
// if hex [ 1 ] then
28375: LD_VAR 0 4
28379: PUSH
28380: LD_INT 1
28382: ARRAY
28383: IFFALSE 28387
// exit ;
28385: GO 28790
// height := hex [ 2 ] ;
28387: LD_ADDR_VAR 0 15
28391: PUSH
28392: LD_VAR 0 4
28396: PUSH
28397: LD_INT 2
28399: ARRAY
28400: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
28401: LD_ADDR_VAR 0 14
28405: PUSH
28406: LD_INT 0
28408: PUSH
28409: LD_INT 2
28411: PUSH
28412: LD_INT 3
28414: PUSH
28415: LD_INT 5
28417: PUSH
28418: EMPTY
28419: LIST
28420: LIST
28421: LIST
28422: LIST
28423: ST_TO_ADDR
// for i in tmp do
28424: LD_ADDR_VAR 0 8
28428: PUSH
28429: LD_VAR 0 14
28433: PUSH
28434: FOR_IN
28435: IFFALSE 28605
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
28437: LD_ADDR_VAR 0 9
28441: PUSH
28442: LD_VAR 0 10
28446: PPUSH
28447: LD_VAR 0 8
28451: PPUSH
28452: LD_INT 5
28454: PPUSH
28455: CALL_OW 272
28459: PUSH
28460: LD_VAR 0 11
28464: PPUSH
28465: LD_VAR 0 8
28469: PPUSH
28470: LD_INT 5
28472: PPUSH
28473: CALL_OW 273
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
28482: LD_VAR 0 9
28486: PUSH
28487: LD_INT 1
28489: ARRAY
28490: PPUSH
28491: LD_VAR 0 9
28495: PUSH
28496: LD_INT 2
28498: ARRAY
28499: PPUSH
28500: CALL_OW 488
28504: IFFALSE 28603
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
28506: LD_ADDR_VAR 0 4
28510: PUSH
28511: LD_VAR 0 9
28515: PUSH
28516: LD_INT 1
28518: ARRAY
28519: PPUSH
28520: LD_VAR 0 9
28524: PUSH
28525: LD_INT 2
28527: ARRAY
28528: PPUSH
28529: CALL_OW 546
28533: ST_TO_ADDR
// if hex [ 1 ] then
28534: LD_VAR 0 4
28538: PUSH
28539: LD_INT 1
28541: ARRAY
28542: IFFALSE 28546
// continue ;
28544: GO 28434
// h := hex [ 2 ] ;
28546: LD_ADDR_VAR 0 13
28550: PUSH
28551: LD_VAR 0 4
28555: PUSH
28556: LD_INT 2
28558: ARRAY
28559: ST_TO_ADDR
// if h + 7 < height then
28560: LD_VAR 0 13
28564: PUSH
28565: LD_INT 7
28567: PLUS
28568: PUSH
28569: LD_VAR 0 15
28573: LESS
28574: IFFALSE 28603
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
28576: LD_ADDR_VAR 0 18
28580: PUSH
28581: LD_INT 7
28583: PUSH
28584: LD_INT 28
28586: PUSH
28587: LD_INT 45
28589: PUSH
28590: EMPTY
28591: LIST
28592: LIST
28593: LIST
28594: PUSH
28595: LD_VAR 0 12
28599: ARRAY
28600: ST_TO_ADDR
// break ;
28601: GO 28605
// end ; end ; end ;
28603: GO 28434
28605: POP
28606: POP
// end ; if not weapon then
28607: LD_VAR 0 18
28611: NOT
28612: IFFALSE 28672
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
28614: LD_ADDR_VAR 0 5
28618: PUSH
28619: LD_VAR 0 5
28623: PUSH
28624: LD_INT 11
28626: PUSH
28627: LD_INT 30
28629: PUSH
28630: LD_INT 49
28632: PUSH
28633: EMPTY
28634: LIST
28635: LIST
28636: LIST
28637: DIFF
28638: ST_TO_ADDR
// if not list then
28639: LD_VAR 0 5
28643: NOT
28644: IFFALSE 28648
// exit ;
28646: GO 28790
// weapon := list [ rand ( 1 , list ) ] ;
28648: LD_ADDR_VAR 0 18
28652: PUSH
28653: LD_VAR 0 5
28657: PUSH
28658: LD_INT 1
28660: PPUSH
28661: LD_VAR 0 5
28665: PPUSH
28666: CALL_OW 12
28670: ARRAY
28671: ST_TO_ADDR
// end ; if weapon then
28672: LD_VAR 0 18
28676: IFFALSE 28790
// begin tmp := CostOfWeapon ( weapon ) ;
28678: LD_ADDR_VAR 0 14
28682: PUSH
28683: LD_VAR 0 18
28687: PPUSH
28688: CALL_OW 451
28692: ST_TO_ADDR
// j := GetBase ( tower ) ;
28693: LD_ADDR_VAR 0 9
28697: PUSH
28698: LD_VAR 0 1
28702: PPUSH
28703: CALL_OW 274
28707: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
28708: LD_VAR 0 9
28712: PPUSH
28713: LD_INT 1
28715: PPUSH
28716: CALL_OW 275
28720: PUSH
28721: LD_VAR 0 14
28725: PUSH
28726: LD_INT 1
28728: ARRAY
28729: GREATEREQUAL
28730: PUSH
28731: LD_VAR 0 9
28735: PPUSH
28736: LD_INT 2
28738: PPUSH
28739: CALL_OW 275
28743: PUSH
28744: LD_VAR 0 14
28748: PUSH
28749: LD_INT 2
28751: ARRAY
28752: GREATEREQUAL
28753: AND
28754: PUSH
28755: LD_VAR 0 9
28759: PPUSH
28760: LD_INT 3
28762: PPUSH
28763: CALL_OW 275
28767: PUSH
28768: LD_VAR 0 14
28772: PUSH
28773: LD_INT 3
28775: ARRAY
28776: GREATEREQUAL
28777: AND
28778: IFFALSE 28790
// result := weapon ;
28780: LD_ADDR_VAR 0 3
28784: PUSH
28785: LD_VAR 0 18
28789: ST_TO_ADDR
// end ; end ;
28790: LD_VAR 0 3
28794: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
28795: LD_INT 0
28797: PPUSH
28798: PPUSH
// result := true ;
28799: LD_ADDR_VAR 0 3
28803: PUSH
28804: LD_INT 1
28806: ST_TO_ADDR
// if array1 = array2 then
28807: LD_VAR 0 1
28811: PUSH
28812: LD_VAR 0 2
28816: EQUAL
28817: IFFALSE 28877
// begin for i = 1 to array1 do
28819: LD_ADDR_VAR 0 4
28823: PUSH
28824: DOUBLE
28825: LD_INT 1
28827: DEC
28828: ST_TO_ADDR
28829: LD_VAR 0 1
28833: PUSH
28834: FOR_TO
28835: IFFALSE 28873
// if array1 [ i ] <> array2 [ i ] then
28837: LD_VAR 0 1
28841: PUSH
28842: LD_VAR 0 4
28846: ARRAY
28847: PUSH
28848: LD_VAR 0 2
28852: PUSH
28853: LD_VAR 0 4
28857: ARRAY
28858: NONEQUAL
28859: IFFALSE 28871
// begin result := false ;
28861: LD_ADDR_VAR 0 3
28865: PUSH
28866: LD_INT 0
28868: ST_TO_ADDR
// break ;
28869: GO 28873
// end ;
28871: GO 28834
28873: POP
28874: POP
// end else
28875: GO 28885
// result := false ;
28877: LD_ADDR_VAR 0 3
28881: PUSH
28882: LD_INT 0
28884: ST_TO_ADDR
// end ;
28885: LD_VAR 0 3
28889: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
28890: LD_INT 0
28892: PPUSH
28893: PPUSH
// if not array1 or not array2 then
28894: LD_VAR 0 1
28898: NOT
28899: PUSH
28900: LD_VAR 0 2
28904: NOT
28905: OR
28906: IFFALSE 28910
// exit ;
28908: GO 28974
// result := true ;
28910: LD_ADDR_VAR 0 3
28914: PUSH
28915: LD_INT 1
28917: ST_TO_ADDR
// for i = 1 to array1 do
28918: LD_ADDR_VAR 0 4
28922: PUSH
28923: DOUBLE
28924: LD_INT 1
28926: DEC
28927: ST_TO_ADDR
28928: LD_VAR 0 1
28932: PUSH
28933: FOR_TO
28934: IFFALSE 28972
// if array1 [ i ] <> array2 [ i ] then
28936: LD_VAR 0 1
28940: PUSH
28941: LD_VAR 0 4
28945: ARRAY
28946: PUSH
28947: LD_VAR 0 2
28951: PUSH
28952: LD_VAR 0 4
28956: ARRAY
28957: NONEQUAL
28958: IFFALSE 28970
// begin result := false ;
28960: LD_ADDR_VAR 0 3
28964: PUSH
28965: LD_INT 0
28967: ST_TO_ADDR
// break ;
28968: GO 28972
// end ;
28970: GO 28933
28972: POP
28973: POP
// end ;
28974: LD_VAR 0 3
28978: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
28979: LD_INT 0
28981: PPUSH
28982: PPUSH
28983: PPUSH
// pom := GetBase ( fac ) ;
28984: LD_ADDR_VAR 0 5
28988: PUSH
28989: LD_VAR 0 1
28993: PPUSH
28994: CALL_OW 274
28998: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
28999: LD_ADDR_VAR 0 4
29003: PUSH
29004: LD_VAR 0 2
29008: PUSH
29009: LD_INT 1
29011: ARRAY
29012: PPUSH
29013: LD_VAR 0 2
29017: PUSH
29018: LD_INT 2
29020: ARRAY
29021: PPUSH
29022: LD_VAR 0 2
29026: PUSH
29027: LD_INT 3
29029: ARRAY
29030: PPUSH
29031: LD_VAR 0 2
29035: PUSH
29036: LD_INT 4
29038: ARRAY
29039: PPUSH
29040: CALL_OW 449
29044: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29045: LD_ADDR_VAR 0 3
29049: PUSH
29050: LD_VAR 0 5
29054: PPUSH
29055: LD_INT 1
29057: PPUSH
29058: CALL_OW 275
29062: PUSH
29063: LD_VAR 0 4
29067: PUSH
29068: LD_INT 1
29070: ARRAY
29071: GREATEREQUAL
29072: PUSH
29073: LD_VAR 0 5
29077: PPUSH
29078: LD_INT 2
29080: PPUSH
29081: CALL_OW 275
29085: PUSH
29086: LD_VAR 0 4
29090: PUSH
29091: LD_INT 2
29093: ARRAY
29094: GREATEREQUAL
29095: AND
29096: PUSH
29097: LD_VAR 0 5
29101: PPUSH
29102: LD_INT 3
29104: PPUSH
29105: CALL_OW 275
29109: PUSH
29110: LD_VAR 0 4
29114: PUSH
29115: LD_INT 3
29117: ARRAY
29118: GREATEREQUAL
29119: AND
29120: ST_TO_ADDR
// end ;
29121: LD_VAR 0 3
29125: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
29126: LD_INT 0
29128: PPUSH
29129: PPUSH
29130: PPUSH
29131: PPUSH
// pom := GetBase ( building ) ;
29132: LD_ADDR_VAR 0 3
29136: PUSH
29137: LD_VAR 0 1
29141: PPUSH
29142: CALL_OW 274
29146: ST_TO_ADDR
// if not pom then
29147: LD_VAR 0 3
29151: NOT
29152: IFFALSE 29156
// exit ;
29154: GO 29326
// btype := GetBType ( building ) ;
29156: LD_ADDR_VAR 0 5
29160: PUSH
29161: LD_VAR 0 1
29165: PPUSH
29166: CALL_OW 266
29170: ST_TO_ADDR
// if btype = b_armoury then
29171: LD_VAR 0 5
29175: PUSH
29176: LD_INT 4
29178: EQUAL
29179: IFFALSE 29189
// btype := b_barracks ;
29181: LD_ADDR_VAR 0 5
29185: PUSH
29186: LD_INT 5
29188: ST_TO_ADDR
// if btype = b_depot then
29189: LD_VAR 0 5
29193: PUSH
29194: LD_INT 0
29196: EQUAL
29197: IFFALSE 29207
// btype := b_warehouse ;
29199: LD_ADDR_VAR 0 5
29203: PUSH
29204: LD_INT 1
29206: ST_TO_ADDR
// if btype = b_workshop then
29207: LD_VAR 0 5
29211: PUSH
29212: LD_INT 2
29214: EQUAL
29215: IFFALSE 29225
// btype := b_factory ;
29217: LD_ADDR_VAR 0 5
29221: PUSH
29222: LD_INT 3
29224: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
29225: LD_ADDR_VAR 0 4
29229: PUSH
29230: LD_VAR 0 5
29234: PPUSH
29235: LD_VAR 0 1
29239: PPUSH
29240: CALL_OW 248
29244: PPUSH
29245: CALL_OW 450
29249: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29250: LD_ADDR_VAR 0 2
29254: PUSH
29255: LD_VAR 0 3
29259: PPUSH
29260: LD_INT 1
29262: PPUSH
29263: CALL_OW 275
29267: PUSH
29268: LD_VAR 0 4
29272: PUSH
29273: LD_INT 1
29275: ARRAY
29276: GREATEREQUAL
29277: PUSH
29278: LD_VAR 0 3
29282: PPUSH
29283: LD_INT 2
29285: PPUSH
29286: CALL_OW 275
29290: PUSH
29291: LD_VAR 0 4
29295: PUSH
29296: LD_INT 2
29298: ARRAY
29299: GREATEREQUAL
29300: AND
29301: PUSH
29302: LD_VAR 0 3
29306: PPUSH
29307: LD_INT 3
29309: PPUSH
29310: CALL_OW 275
29314: PUSH
29315: LD_VAR 0 4
29319: PUSH
29320: LD_INT 3
29322: ARRAY
29323: GREATEREQUAL
29324: AND
29325: ST_TO_ADDR
// end ;
29326: LD_VAR 0 2
29330: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
29331: LD_INT 0
29333: PPUSH
29334: PPUSH
29335: PPUSH
// pom := GetBase ( building ) ;
29336: LD_ADDR_VAR 0 4
29340: PUSH
29341: LD_VAR 0 1
29345: PPUSH
29346: CALL_OW 274
29350: ST_TO_ADDR
// if not pom then
29351: LD_VAR 0 4
29355: NOT
29356: IFFALSE 29360
// exit ;
29358: GO 29461
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
29360: LD_ADDR_VAR 0 5
29364: PUSH
29365: LD_VAR 0 2
29369: PPUSH
29370: LD_VAR 0 1
29374: PPUSH
29375: CALL_OW 248
29379: PPUSH
29380: CALL_OW 450
29384: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29385: LD_ADDR_VAR 0 3
29389: PUSH
29390: LD_VAR 0 4
29394: PPUSH
29395: LD_INT 1
29397: PPUSH
29398: CALL_OW 275
29402: PUSH
29403: LD_VAR 0 5
29407: PUSH
29408: LD_INT 1
29410: ARRAY
29411: GREATEREQUAL
29412: PUSH
29413: LD_VAR 0 4
29417: PPUSH
29418: LD_INT 2
29420: PPUSH
29421: CALL_OW 275
29425: PUSH
29426: LD_VAR 0 5
29430: PUSH
29431: LD_INT 2
29433: ARRAY
29434: GREATEREQUAL
29435: AND
29436: PUSH
29437: LD_VAR 0 4
29441: PPUSH
29442: LD_INT 3
29444: PPUSH
29445: CALL_OW 275
29449: PUSH
29450: LD_VAR 0 5
29454: PUSH
29455: LD_INT 3
29457: ARRAY
29458: GREATEREQUAL
29459: AND
29460: ST_TO_ADDR
// end ;
29461: LD_VAR 0 3
29465: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
29466: LD_INT 0
29468: PPUSH
29469: PPUSH
29470: PPUSH
29471: PPUSH
29472: PPUSH
29473: PPUSH
29474: PPUSH
29475: PPUSH
29476: PPUSH
29477: PPUSH
29478: PPUSH
// result := false ;
29479: LD_ADDR_VAR 0 8
29483: PUSH
29484: LD_INT 0
29486: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
29487: LD_VAR 0 5
29491: NOT
29492: PUSH
29493: LD_VAR 0 1
29497: NOT
29498: OR
29499: PUSH
29500: LD_VAR 0 2
29504: NOT
29505: OR
29506: PUSH
29507: LD_VAR 0 3
29511: NOT
29512: OR
29513: IFFALSE 29517
// exit ;
29515: GO 30331
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
29517: LD_ADDR_VAR 0 14
29521: PUSH
29522: LD_VAR 0 1
29526: PPUSH
29527: LD_VAR 0 2
29531: PPUSH
29532: LD_VAR 0 3
29536: PPUSH
29537: LD_VAR 0 4
29541: PPUSH
29542: LD_VAR 0 5
29546: PUSH
29547: LD_INT 1
29549: ARRAY
29550: PPUSH
29551: CALL_OW 248
29555: PPUSH
29556: LD_INT 0
29558: PPUSH
29559: CALL 31584 0 6
29563: ST_TO_ADDR
// if not hexes then
29564: LD_VAR 0 14
29568: NOT
29569: IFFALSE 29573
// exit ;
29571: GO 30331
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
29573: LD_ADDR_VAR 0 17
29577: PUSH
29578: LD_VAR 0 5
29582: PPUSH
29583: LD_INT 22
29585: PUSH
29586: LD_VAR 0 13
29590: PPUSH
29591: CALL_OW 255
29595: PUSH
29596: EMPTY
29597: LIST
29598: LIST
29599: PUSH
29600: LD_INT 2
29602: PUSH
29603: LD_INT 30
29605: PUSH
29606: LD_INT 0
29608: PUSH
29609: EMPTY
29610: LIST
29611: LIST
29612: PUSH
29613: LD_INT 30
29615: PUSH
29616: LD_INT 1
29618: PUSH
29619: EMPTY
29620: LIST
29621: LIST
29622: PUSH
29623: EMPTY
29624: LIST
29625: LIST
29626: LIST
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: PPUSH
29632: CALL_OW 72
29636: ST_TO_ADDR
// for i = 1 to hexes do
29637: LD_ADDR_VAR 0 9
29641: PUSH
29642: DOUBLE
29643: LD_INT 1
29645: DEC
29646: ST_TO_ADDR
29647: LD_VAR 0 14
29651: PUSH
29652: FOR_TO
29653: IFFALSE 30329
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29655: LD_ADDR_VAR 0 13
29659: PUSH
29660: LD_VAR 0 14
29664: PUSH
29665: LD_VAR 0 9
29669: ARRAY
29670: PUSH
29671: LD_INT 1
29673: ARRAY
29674: PPUSH
29675: LD_VAR 0 14
29679: PUSH
29680: LD_VAR 0 9
29684: ARRAY
29685: PUSH
29686: LD_INT 2
29688: ARRAY
29689: PPUSH
29690: CALL_OW 428
29694: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
29695: LD_VAR 0 14
29699: PUSH
29700: LD_VAR 0 9
29704: ARRAY
29705: PUSH
29706: LD_INT 1
29708: ARRAY
29709: PPUSH
29710: LD_VAR 0 14
29714: PUSH
29715: LD_VAR 0 9
29719: ARRAY
29720: PUSH
29721: LD_INT 2
29723: ARRAY
29724: PPUSH
29725: CALL_OW 351
29729: PUSH
29730: LD_VAR 0 14
29734: PUSH
29735: LD_VAR 0 9
29739: ARRAY
29740: PUSH
29741: LD_INT 1
29743: ARRAY
29744: PPUSH
29745: LD_VAR 0 14
29749: PUSH
29750: LD_VAR 0 9
29754: ARRAY
29755: PUSH
29756: LD_INT 2
29758: ARRAY
29759: PPUSH
29760: CALL_OW 488
29764: NOT
29765: OR
29766: PUSH
29767: LD_VAR 0 13
29771: PPUSH
29772: CALL_OW 247
29776: PUSH
29777: LD_INT 3
29779: EQUAL
29780: OR
29781: IFFALSE 29787
// exit ;
29783: POP
29784: POP
29785: GO 30331
// if not tmp then
29787: LD_VAR 0 13
29791: NOT
29792: IFFALSE 29796
// continue ;
29794: GO 29652
// result := true ;
29796: LD_ADDR_VAR 0 8
29800: PUSH
29801: LD_INT 1
29803: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
29804: LD_VAR 0 6
29808: PUSH
29809: LD_VAR 0 13
29813: PPUSH
29814: CALL_OW 247
29818: PUSH
29819: LD_INT 2
29821: EQUAL
29822: AND
29823: PUSH
29824: LD_VAR 0 13
29828: PPUSH
29829: CALL_OW 263
29833: PUSH
29834: LD_INT 1
29836: EQUAL
29837: AND
29838: IFFALSE 30002
// begin if IsDrivenBy ( tmp ) then
29840: LD_VAR 0 13
29844: PPUSH
29845: CALL_OW 311
29849: IFFALSE 29853
// continue ;
29851: GO 29652
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
29853: LD_VAR 0 6
29857: PPUSH
29858: LD_INT 3
29860: PUSH
29861: LD_INT 60
29863: PUSH
29864: EMPTY
29865: LIST
29866: PUSH
29867: EMPTY
29868: LIST
29869: LIST
29870: PUSH
29871: LD_INT 3
29873: PUSH
29874: LD_INT 55
29876: PUSH
29877: EMPTY
29878: LIST
29879: PUSH
29880: EMPTY
29881: LIST
29882: LIST
29883: PUSH
29884: EMPTY
29885: LIST
29886: LIST
29887: PPUSH
29888: CALL_OW 72
29892: IFFALSE 30000
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
29894: LD_ADDR_VAR 0 18
29898: PUSH
29899: LD_VAR 0 6
29903: PPUSH
29904: LD_INT 3
29906: PUSH
29907: LD_INT 60
29909: PUSH
29910: EMPTY
29911: LIST
29912: PUSH
29913: EMPTY
29914: LIST
29915: LIST
29916: PUSH
29917: LD_INT 3
29919: PUSH
29920: LD_INT 55
29922: PUSH
29923: EMPTY
29924: LIST
29925: PUSH
29926: EMPTY
29927: LIST
29928: LIST
29929: PUSH
29930: EMPTY
29931: LIST
29932: LIST
29933: PPUSH
29934: CALL_OW 72
29938: PUSH
29939: LD_INT 1
29941: ARRAY
29942: ST_TO_ADDR
// if IsInUnit ( driver ) then
29943: LD_VAR 0 18
29947: PPUSH
29948: CALL_OW 310
29952: IFFALSE 29963
// ComExit ( driver ) ;
29954: LD_VAR 0 18
29958: PPUSH
29959: CALL 55365 0 1
// AddComEnterUnit ( driver , tmp ) ;
29963: LD_VAR 0 18
29967: PPUSH
29968: LD_VAR 0 13
29972: PPUSH
29973: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
29977: LD_VAR 0 18
29981: PPUSH
29982: LD_VAR 0 7
29986: PPUSH
29987: CALL_OW 173
// AddComExitVehicle ( driver ) ;
29991: LD_VAR 0 18
29995: PPUSH
29996: CALL_OW 181
// end ; continue ;
30000: GO 29652
// end ; if not cleaners or not tmp in cleaners then
30002: LD_VAR 0 6
30006: NOT
30007: PUSH
30008: LD_VAR 0 13
30012: PUSH
30013: LD_VAR 0 6
30017: IN
30018: NOT
30019: OR
30020: IFFALSE 30327
// begin if dep then
30022: LD_VAR 0 17
30026: IFFALSE 30162
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
30028: LD_ADDR_VAR 0 16
30032: PUSH
30033: LD_VAR 0 17
30037: PUSH
30038: LD_INT 1
30040: ARRAY
30041: PPUSH
30042: CALL_OW 250
30046: PPUSH
30047: LD_VAR 0 17
30051: PUSH
30052: LD_INT 1
30054: ARRAY
30055: PPUSH
30056: CALL_OW 254
30060: PPUSH
30061: LD_INT 5
30063: PPUSH
30064: CALL_OW 272
30068: PUSH
30069: LD_VAR 0 17
30073: PUSH
30074: LD_INT 1
30076: ARRAY
30077: PPUSH
30078: CALL_OW 251
30082: PPUSH
30083: LD_VAR 0 17
30087: PUSH
30088: LD_INT 1
30090: ARRAY
30091: PPUSH
30092: CALL_OW 254
30096: PPUSH
30097: LD_INT 5
30099: PPUSH
30100: CALL_OW 273
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
30109: LD_VAR 0 16
30113: PUSH
30114: LD_INT 1
30116: ARRAY
30117: PPUSH
30118: LD_VAR 0 16
30122: PUSH
30123: LD_INT 2
30125: ARRAY
30126: PPUSH
30127: CALL_OW 488
30131: IFFALSE 30162
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
30133: LD_VAR 0 13
30137: PPUSH
30138: LD_VAR 0 16
30142: PUSH
30143: LD_INT 1
30145: ARRAY
30146: PPUSH
30147: LD_VAR 0 16
30151: PUSH
30152: LD_INT 2
30154: ARRAY
30155: PPUSH
30156: CALL_OW 111
// continue ;
30160: GO 29652
// end ; end ; r := GetDir ( tmp ) ;
30162: LD_ADDR_VAR 0 15
30166: PUSH
30167: LD_VAR 0 13
30171: PPUSH
30172: CALL_OW 254
30176: ST_TO_ADDR
// if r = 5 then
30177: LD_VAR 0 15
30181: PUSH
30182: LD_INT 5
30184: EQUAL
30185: IFFALSE 30195
// r := 0 ;
30187: LD_ADDR_VAR 0 15
30191: PUSH
30192: LD_INT 0
30194: ST_TO_ADDR
// for j = r to 5 do
30195: LD_ADDR_VAR 0 10
30199: PUSH
30200: DOUBLE
30201: LD_VAR 0 15
30205: DEC
30206: ST_TO_ADDR
30207: LD_INT 5
30209: PUSH
30210: FOR_TO
30211: IFFALSE 30325
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
30213: LD_ADDR_VAR 0 11
30217: PUSH
30218: LD_VAR 0 13
30222: PPUSH
30223: CALL_OW 250
30227: PPUSH
30228: LD_VAR 0 10
30232: PPUSH
30233: LD_INT 2
30235: PPUSH
30236: CALL_OW 272
30240: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
30241: LD_ADDR_VAR 0 12
30245: PUSH
30246: LD_VAR 0 13
30250: PPUSH
30251: CALL_OW 251
30255: PPUSH
30256: LD_VAR 0 10
30260: PPUSH
30261: LD_INT 2
30263: PPUSH
30264: CALL_OW 273
30268: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
30269: LD_VAR 0 11
30273: PPUSH
30274: LD_VAR 0 12
30278: PPUSH
30279: CALL_OW 488
30283: PUSH
30284: LD_VAR 0 11
30288: PPUSH
30289: LD_VAR 0 12
30293: PPUSH
30294: CALL_OW 428
30298: NOT
30299: AND
30300: IFFALSE 30323
// begin ComMoveXY ( tmp , _x , _y ) ;
30302: LD_VAR 0 13
30306: PPUSH
30307: LD_VAR 0 11
30311: PPUSH
30312: LD_VAR 0 12
30316: PPUSH
30317: CALL_OW 111
// break ;
30321: GO 30325
// end ; end ;
30323: GO 30210
30325: POP
30326: POP
// end ; end ;
30327: GO 29652
30329: POP
30330: POP
// end ;
30331: LD_VAR 0 8
30335: RET
// export function BuildingTechInvented ( side , btype ) ; begin
30336: LD_INT 0
30338: PPUSH
// result := true ;
30339: LD_ADDR_VAR 0 3
30343: PUSH
30344: LD_INT 1
30346: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
30347: LD_VAR 0 2
30351: PUSH
30352: LD_INT 24
30354: DOUBLE
30355: EQUAL
30356: IFTRUE 30366
30358: LD_INT 33
30360: DOUBLE
30361: EQUAL
30362: IFTRUE 30366
30364: GO 30391
30366: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
30367: LD_ADDR_VAR 0 3
30371: PUSH
30372: LD_INT 32
30374: PPUSH
30375: LD_VAR 0 1
30379: PPUSH
30380: CALL_OW 321
30384: PUSH
30385: LD_INT 2
30387: EQUAL
30388: ST_TO_ADDR
30389: GO 30707
30391: LD_INT 20
30393: DOUBLE
30394: EQUAL
30395: IFTRUE 30399
30397: GO 30424
30399: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
30400: LD_ADDR_VAR 0 3
30404: PUSH
30405: LD_INT 6
30407: PPUSH
30408: LD_VAR 0 1
30412: PPUSH
30413: CALL_OW 321
30417: PUSH
30418: LD_INT 2
30420: EQUAL
30421: ST_TO_ADDR
30422: GO 30707
30424: LD_INT 22
30426: DOUBLE
30427: EQUAL
30428: IFTRUE 30438
30430: LD_INT 36
30432: DOUBLE
30433: EQUAL
30434: IFTRUE 30438
30436: GO 30463
30438: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
30439: LD_ADDR_VAR 0 3
30443: PUSH
30444: LD_INT 15
30446: PPUSH
30447: LD_VAR 0 1
30451: PPUSH
30452: CALL_OW 321
30456: PUSH
30457: LD_INT 2
30459: EQUAL
30460: ST_TO_ADDR
30461: GO 30707
30463: LD_INT 30
30465: DOUBLE
30466: EQUAL
30467: IFTRUE 30471
30469: GO 30496
30471: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
30472: LD_ADDR_VAR 0 3
30476: PUSH
30477: LD_INT 20
30479: PPUSH
30480: LD_VAR 0 1
30484: PPUSH
30485: CALL_OW 321
30489: PUSH
30490: LD_INT 2
30492: EQUAL
30493: ST_TO_ADDR
30494: GO 30707
30496: LD_INT 28
30498: DOUBLE
30499: EQUAL
30500: IFTRUE 30510
30502: LD_INT 21
30504: DOUBLE
30505: EQUAL
30506: IFTRUE 30510
30508: GO 30535
30510: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
30511: LD_ADDR_VAR 0 3
30515: PUSH
30516: LD_INT 21
30518: PPUSH
30519: LD_VAR 0 1
30523: PPUSH
30524: CALL_OW 321
30528: PUSH
30529: LD_INT 2
30531: EQUAL
30532: ST_TO_ADDR
30533: GO 30707
30535: LD_INT 16
30537: DOUBLE
30538: EQUAL
30539: IFTRUE 30543
30541: GO 30568
30543: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
30544: LD_ADDR_VAR 0 3
30548: PUSH
30549: LD_INT 84
30551: PPUSH
30552: LD_VAR 0 1
30556: PPUSH
30557: CALL_OW 321
30561: PUSH
30562: LD_INT 2
30564: EQUAL
30565: ST_TO_ADDR
30566: GO 30707
30568: LD_INT 19
30570: DOUBLE
30571: EQUAL
30572: IFTRUE 30582
30574: LD_INT 23
30576: DOUBLE
30577: EQUAL
30578: IFTRUE 30582
30580: GO 30607
30582: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
30583: LD_ADDR_VAR 0 3
30587: PUSH
30588: LD_INT 83
30590: PPUSH
30591: LD_VAR 0 1
30595: PPUSH
30596: CALL_OW 321
30600: PUSH
30601: LD_INT 2
30603: EQUAL
30604: ST_TO_ADDR
30605: GO 30707
30607: LD_INT 17
30609: DOUBLE
30610: EQUAL
30611: IFTRUE 30615
30613: GO 30640
30615: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
30616: LD_ADDR_VAR 0 3
30620: PUSH
30621: LD_INT 39
30623: PPUSH
30624: LD_VAR 0 1
30628: PPUSH
30629: CALL_OW 321
30633: PUSH
30634: LD_INT 2
30636: EQUAL
30637: ST_TO_ADDR
30638: GO 30707
30640: LD_INT 18
30642: DOUBLE
30643: EQUAL
30644: IFTRUE 30648
30646: GO 30673
30648: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
30649: LD_ADDR_VAR 0 3
30653: PUSH
30654: LD_INT 40
30656: PPUSH
30657: LD_VAR 0 1
30661: PPUSH
30662: CALL_OW 321
30666: PUSH
30667: LD_INT 2
30669: EQUAL
30670: ST_TO_ADDR
30671: GO 30707
30673: LD_INT 27
30675: DOUBLE
30676: EQUAL
30677: IFTRUE 30681
30679: GO 30706
30681: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
30682: LD_ADDR_VAR 0 3
30686: PUSH
30687: LD_INT 35
30689: PPUSH
30690: LD_VAR 0 1
30694: PPUSH
30695: CALL_OW 321
30699: PUSH
30700: LD_INT 2
30702: EQUAL
30703: ST_TO_ADDR
30704: GO 30707
30706: POP
// end ;
30707: LD_VAR 0 3
30711: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
30712: LD_INT 0
30714: PPUSH
30715: PPUSH
30716: PPUSH
30717: PPUSH
30718: PPUSH
30719: PPUSH
30720: PPUSH
30721: PPUSH
30722: PPUSH
30723: PPUSH
30724: PPUSH
// result := false ;
30725: LD_ADDR_VAR 0 6
30729: PUSH
30730: LD_INT 0
30732: ST_TO_ADDR
// if btype = b_depot then
30733: LD_VAR 0 2
30737: PUSH
30738: LD_INT 0
30740: EQUAL
30741: IFFALSE 30753
// begin result := true ;
30743: LD_ADDR_VAR 0 6
30747: PUSH
30748: LD_INT 1
30750: ST_TO_ADDR
// exit ;
30751: GO 31579
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
30753: LD_VAR 0 1
30757: NOT
30758: PUSH
30759: LD_VAR 0 1
30763: PPUSH
30764: CALL_OW 266
30768: PUSH
30769: LD_INT 0
30771: PUSH
30772: LD_INT 1
30774: PUSH
30775: EMPTY
30776: LIST
30777: LIST
30778: IN
30779: NOT
30780: OR
30781: PUSH
30782: LD_VAR 0 2
30786: NOT
30787: OR
30788: PUSH
30789: LD_VAR 0 5
30793: PUSH
30794: LD_INT 0
30796: PUSH
30797: LD_INT 1
30799: PUSH
30800: LD_INT 2
30802: PUSH
30803: LD_INT 3
30805: PUSH
30806: LD_INT 4
30808: PUSH
30809: LD_INT 5
30811: PUSH
30812: EMPTY
30813: LIST
30814: LIST
30815: LIST
30816: LIST
30817: LIST
30818: LIST
30819: IN
30820: NOT
30821: OR
30822: PUSH
30823: LD_VAR 0 3
30827: PPUSH
30828: LD_VAR 0 4
30832: PPUSH
30833: CALL_OW 488
30837: NOT
30838: OR
30839: IFFALSE 30843
// exit ;
30841: GO 31579
// side := GetSide ( depot ) ;
30843: LD_ADDR_VAR 0 9
30847: PUSH
30848: LD_VAR 0 1
30852: PPUSH
30853: CALL_OW 255
30857: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
30858: LD_VAR 0 9
30862: PPUSH
30863: LD_VAR 0 2
30867: PPUSH
30868: CALL 30336 0 2
30872: NOT
30873: IFFALSE 30877
// exit ;
30875: GO 31579
// pom := GetBase ( depot ) ;
30877: LD_ADDR_VAR 0 10
30881: PUSH
30882: LD_VAR 0 1
30886: PPUSH
30887: CALL_OW 274
30891: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
30892: LD_ADDR_VAR 0 11
30896: PUSH
30897: LD_VAR 0 2
30901: PPUSH
30902: LD_VAR 0 1
30906: PPUSH
30907: CALL_OW 248
30911: PPUSH
30912: CALL_OW 450
30916: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
30917: LD_VAR 0 10
30921: PPUSH
30922: LD_INT 1
30924: PPUSH
30925: CALL_OW 275
30929: PUSH
30930: LD_VAR 0 11
30934: PUSH
30935: LD_INT 1
30937: ARRAY
30938: GREATEREQUAL
30939: PUSH
30940: LD_VAR 0 10
30944: PPUSH
30945: LD_INT 2
30947: PPUSH
30948: CALL_OW 275
30952: PUSH
30953: LD_VAR 0 11
30957: PUSH
30958: LD_INT 2
30960: ARRAY
30961: GREATEREQUAL
30962: AND
30963: PUSH
30964: LD_VAR 0 10
30968: PPUSH
30969: LD_INT 3
30971: PPUSH
30972: CALL_OW 275
30976: PUSH
30977: LD_VAR 0 11
30981: PUSH
30982: LD_INT 3
30984: ARRAY
30985: GREATEREQUAL
30986: AND
30987: NOT
30988: IFFALSE 30992
// exit ;
30990: GO 31579
// if GetBType ( depot ) = b_depot then
30992: LD_VAR 0 1
30996: PPUSH
30997: CALL_OW 266
31001: PUSH
31002: LD_INT 0
31004: EQUAL
31005: IFFALSE 31017
// dist := 28 else
31007: LD_ADDR_VAR 0 14
31011: PUSH
31012: LD_INT 28
31014: ST_TO_ADDR
31015: GO 31025
// dist := 36 ;
31017: LD_ADDR_VAR 0 14
31021: PUSH
31022: LD_INT 36
31024: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
31025: LD_VAR 0 1
31029: PPUSH
31030: LD_VAR 0 3
31034: PPUSH
31035: LD_VAR 0 4
31039: PPUSH
31040: CALL_OW 297
31044: PUSH
31045: LD_VAR 0 14
31049: GREATER
31050: IFFALSE 31054
// exit ;
31052: GO 31579
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
31054: LD_ADDR_VAR 0 12
31058: PUSH
31059: LD_VAR 0 2
31063: PPUSH
31064: LD_VAR 0 3
31068: PPUSH
31069: LD_VAR 0 4
31073: PPUSH
31074: LD_VAR 0 5
31078: PPUSH
31079: LD_VAR 0 1
31083: PPUSH
31084: CALL_OW 248
31088: PPUSH
31089: LD_INT 0
31091: PPUSH
31092: CALL 31584 0 6
31096: ST_TO_ADDR
// if not hexes then
31097: LD_VAR 0 12
31101: NOT
31102: IFFALSE 31106
// exit ;
31104: GO 31579
// hex := GetHexInfo ( x , y ) ;
31106: LD_ADDR_VAR 0 15
31110: PUSH
31111: LD_VAR 0 3
31115: PPUSH
31116: LD_VAR 0 4
31120: PPUSH
31121: CALL_OW 546
31125: ST_TO_ADDR
// if hex [ 1 ] then
31126: LD_VAR 0 15
31130: PUSH
31131: LD_INT 1
31133: ARRAY
31134: IFFALSE 31138
// exit ;
31136: GO 31579
// height := hex [ 2 ] ;
31138: LD_ADDR_VAR 0 13
31142: PUSH
31143: LD_VAR 0 15
31147: PUSH
31148: LD_INT 2
31150: ARRAY
31151: ST_TO_ADDR
// for i = 1 to hexes do
31152: LD_ADDR_VAR 0 7
31156: PUSH
31157: DOUBLE
31158: LD_INT 1
31160: DEC
31161: ST_TO_ADDR
31162: LD_VAR 0 12
31166: PUSH
31167: FOR_TO
31168: IFFALSE 31498
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
31170: LD_VAR 0 12
31174: PUSH
31175: LD_VAR 0 7
31179: ARRAY
31180: PUSH
31181: LD_INT 1
31183: ARRAY
31184: PPUSH
31185: LD_VAR 0 12
31189: PUSH
31190: LD_VAR 0 7
31194: ARRAY
31195: PUSH
31196: LD_INT 2
31198: ARRAY
31199: PPUSH
31200: CALL_OW 488
31204: NOT
31205: PUSH
31206: LD_VAR 0 12
31210: PUSH
31211: LD_VAR 0 7
31215: ARRAY
31216: PUSH
31217: LD_INT 1
31219: ARRAY
31220: PPUSH
31221: LD_VAR 0 12
31225: PUSH
31226: LD_VAR 0 7
31230: ARRAY
31231: PUSH
31232: LD_INT 2
31234: ARRAY
31235: PPUSH
31236: CALL_OW 428
31240: PUSH
31241: LD_INT 0
31243: GREATER
31244: OR
31245: PUSH
31246: LD_VAR 0 12
31250: PUSH
31251: LD_VAR 0 7
31255: ARRAY
31256: PUSH
31257: LD_INT 1
31259: ARRAY
31260: PPUSH
31261: LD_VAR 0 12
31265: PUSH
31266: LD_VAR 0 7
31270: ARRAY
31271: PUSH
31272: LD_INT 2
31274: ARRAY
31275: PPUSH
31276: CALL_OW 351
31280: OR
31281: IFFALSE 31287
// exit ;
31283: POP
31284: POP
31285: GO 31579
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
31287: LD_ADDR_VAR 0 8
31291: PUSH
31292: LD_VAR 0 12
31296: PUSH
31297: LD_VAR 0 7
31301: ARRAY
31302: PUSH
31303: LD_INT 1
31305: ARRAY
31306: PPUSH
31307: LD_VAR 0 12
31311: PUSH
31312: LD_VAR 0 7
31316: ARRAY
31317: PUSH
31318: LD_INT 2
31320: ARRAY
31321: PPUSH
31322: CALL_OW 546
31326: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
31327: LD_VAR 0 8
31331: PUSH
31332: LD_INT 1
31334: ARRAY
31335: PUSH
31336: LD_VAR 0 8
31340: PUSH
31341: LD_INT 2
31343: ARRAY
31344: PUSH
31345: LD_VAR 0 13
31349: PUSH
31350: LD_INT 2
31352: PLUS
31353: GREATER
31354: OR
31355: PUSH
31356: LD_VAR 0 8
31360: PUSH
31361: LD_INT 2
31363: ARRAY
31364: PUSH
31365: LD_VAR 0 13
31369: PUSH
31370: LD_INT 2
31372: MINUS
31373: LESS
31374: OR
31375: PUSH
31376: LD_VAR 0 8
31380: PUSH
31381: LD_INT 3
31383: ARRAY
31384: PUSH
31385: LD_INT 0
31387: PUSH
31388: LD_INT 8
31390: PUSH
31391: LD_INT 9
31393: PUSH
31394: LD_INT 10
31396: PUSH
31397: LD_INT 11
31399: PUSH
31400: LD_INT 12
31402: PUSH
31403: LD_INT 13
31405: PUSH
31406: LD_INT 16
31408: PUSH
31409: LD_INT 17
31411: PUSH
31412: LD_INT 18
31414: PUSH
31415: LD_INT 19
31417: PUSH
31418: LD_INT 20
31420: PUSH
31421: LD_INT 21
31423: PUSH
31424: EMPTY
31425: LIST
31426: LIST
31427: LIST
31428: LIST
31429: LIST
31430: LIST
31431: LIST
31432: LIST
31433: LIST
31434: LIST
31435: LIST
31436: LIST
31437: LIST
31438: IN
31439: NOT
31440: OR
31441: PUSH
31442: LD_VAR 0 8
31446: PUSH
31447: LD_INT 5
31449: ARRAY
31450: NOT
31451: OR
31452: PUSH
31453: LD_VAR 0 8
31457: PUSH
31458: LD_INT 6
31460: ARRAY
31461: PUSH
31462: LD_INT 1
31464: PUSH
31465: LD_INT 2
31467: PUSH
31468: LD_INT 7
31470: PUSH
31471: LD_INT 9
31473: PUSH
31474: LD_INT 10
31476: PUSH
31477: LD_INT 11
31479: PUSH
31480: EMPTY
31481: LIST
31482: LIST
31483: LIST
31484: LIST
31485: LIST
31486: LIST
31487: IN
31488: NOT
31489: OR
31490: IFFALSE 31496
// exit ;
31492: POP
31493: POP
31494: GO 31579
// end ;
31496: GO 31167
31498: POP
31499: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
31500: LD_VAR 0 9
31504: PPUSH
31505: LD_VAR 0 3
31509: PPUSH
31510: LD_VAR 0 4
31514: PPUSH
31515: LD_INT 20
31517: PPUSH
31518: CALL 23502 0 4
31522: PUSH
31523: LD_INT 4
31525: ARRAY
31526: IFFALSE 31530
// exit ;
31528: GO 31579
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
31530: LD_VAR 0 2
31534: PUSH
31535: LD_INT 29
31537: PUSH
31538: LD_INT 30
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: IN
31545: PUSH
31546: LD_VAR 0 3
31550: PPUSH
31551: LD_VAR 0 4
31555: PPUSH
31556: LD_VAR 0 9
31560: PPUSH
31561: CALL_OW 440
31565: NOT
31566: AND
31567: IFFALSE 31571
// exit ;
31569: GO 31579
// result := true ;
31571: LD_ADDR_VAR 0 6
31575: PUSH
31576: LD_INT 1
31578: ST_TO_ADDR
// end ;
31579: LD_VAR 0 6
31583: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
31584: LD_INT 0
31586: PPUSH
31587: PPUSH
31588: PPUSH
31589: PPUSH
31590: PPUSH
31591: PPUSH
31592: PPUSH
31593: PPUSH
31594: PPUSH
31595: PPUSH
31596: PPUSH
31597: PPUSH
31598: PPUSH
31599: PPUSH
31600: PPUSH
31601: PPUSH
31602: PPUSH
31603: PPUSH
31604: PPUSH
31605: PPUSH
31606: PPUSH
31607: PPUSH
31608: PPUSH
31609: PPUSH
31610: PPUSH
31611: PPUSH
31612: PPUSH
31613: PPUSH
31614: PPUSH
31615: PPUSH
31616: PPUSH
31617: PPUSH
31618: PPUSH
31619: PPUSH
31620: PPUSH
31621: PPUSH
31622: PPUSH
31623: PPUSH
31624: PPUSH
31625: PPUSH
31626: PPUSH
31627: PPUSH
31628: PPUSH
31629: PPUSH
31630: PPUSH
31631: PPUSH
31632: PPUSH
31633: PPUSH
31634: PPUSH
31635: PPUSH
31636: PPUSH
31637: PPUSH
31638: PPUSH
31639: PPUSH
31640: PPUSH
31641: PPUSH
31642: PPUSH
31643: PPUSH
// result = [ ] ;
31644: LD_ADDR_VAR 0 7
31648: PUSH
31649: EMPTY
31650: ST_TO_ADDR
// temp_list = [ ] ;
31651: LD_ADDR_VAR 0 9
31655: PUSH
31656: EMPTY
31657: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
31658: LD_VAR 0 4
31662: PUSH
31663: LD_INT 0
31665: PUSH
31666: LD_INT 1
31668: PUSH
31669: LD_INT 2
31671: PUSH
31672: LD_INT 3
31674: PUSH
31675: LD_INT 4
31677: PUSH
31678: LD_INT 5
31680: PUSH
31681: EMPTY
31682: LIST
31683: LIST
31684: LIST
31685: LIST
31686: LIST
31687: LIST
31688: IN
31689: NOT
31690: PUSH
31691: LD_VAR 0 1
31695: PUSH
31696: LD_INT 0
31698: PUSH
31699: LD_INT 1
31701: PUSH
31702: EMPTY
31703: LIST
31704: LIST
31705: IN
31706: PUSH
31707: LD_VAR 0 5
31711: PUSH
31712: LD_INT 1
31714: PUSH
31715: LD_INT 2
31717: PUSH
31718: LD_INT 3
31720: PUSH
31721: EMPTY
31722: LIST
31723: LIST
31724: LIST
31725: IN
31726: NOT
31727: AND
31728: OR
31729: IFFALSE 31733
// exit ;
31731: GO 50124
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
31733: LD_VAR 0 1
31737: PUSH
31738: LD_INT 6
31740: PUSH
31741: LD_INT 7
31743: PUSH
31744: LD_INT 8
31746: PUSH
31747: LD_INT 13
31749: PUSH
31750: LD_INT 12
31752: PUSH
31753: LD_INT 15
31755: PUSH
31756: LD_INT 11
31758: PUSH
31759: LD_INT 14
31761: PUSH
31762: LD_INT 10
31764: PUSH
31765: EMPTY
31766: LIST
31767: LIST
31768: LIST
31769: LIST
31770: LIST
31771: LIST
31772: LIST
31773: LIST
31774: LIST
31775: IN
31776: IFFALSE 31786
// btype = b_lab ;
31778: LD_ADDR_VAR 0 1
31782: PUSH
31783: LD_INT 6
31785: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
31786: LD_VAR 0 6
31790: PUSH
31791: LD_INT 0
31793: PUSH
31794: LD_INT 1
31796: PUSH
31797: LD_INT 2
31799: PUSH
31800: EMPTY
31801: LIST
31802: LIST
31803: LIST
31804: IN
31805: NOT
31806: PUSH
31807: LD_VAR 0 1
31811: PUSH
31812: LD_INT 0
31814: PUSH
31815: LD_INT 1
31817: PUSH
31818: LD_INT 2
31820: PUSH
31821: LD_INT 3
31823: PUSH
31824: LD_INT 6
31826: PUSH
31827: LD_INT 36
31829: PUSH
31830: LD_INT 4
31832: PUSH
31833: LD_INT 5
31835: PUSH
31836: LD_INT 31
31838: PUSH
31839: LD_INT 32
31841: PUSH
31842: LD_INT 33
31844: PUSH
31845: EMPTY
31846: LIST
31847: LIST
31848: LIST
31849: LIST
31850: LIST
31851: LIST
31852: LIST
31853: LIST
31854: LIST
31855: LIST
31856: LIST
31857: IN
31858: NOT
31859: PUSH
31860: LD_VAR 0 6
31864: PUSH
31865: LD_INT 1
31867: EQUAL
31868: AND
31869: OR
31870: PUSH
31871: LD_VAR 0 1
31875: PUSH
31876: LD_INT 2
31878: PUSH
31879: LD_INT 3
31881: PUSH
31882: EMPTY
31883: LIST
31884: LIST
31885: IN
31886: NOT
31887: PUSH
31888: LD_VAR 0 6
31892: PUSH
31893: LD_INT 2
31895: EQUAL
31896: AND
31897: OR
31898: IFFALSE 31908
// mode = 0 ;
31900: LD_ADDR_VAR 0 6
31904: PUSH
31905: LD_INT 0
31907: ST_TO_ADDR
// case mode of 0 :
31908: LD_VAR 0 6
31912: PUSH
31913: LD_INT 0
31915: DOUBLE
31916: EQUAL
31917: IFTRUE 31921
31919: GO 43374
31921: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
31922: LD_ADDR_VAR 0 11
31926: PUSH
31927: LD_INT 0
31929: PUSH
31930: LD_INT 0
31932: PUSH
31933: EMPTY
31934: LIST
31935: LIST
31936: PUSH
31937: LD_INT 0
31939: PUSH
31940: LD_INT 1
31942: NEG
31943: PUSH
31944: EMPTY
31945: LIST
31946: LIST
31947: PUSH
31948: LD_INT 1
31950: PUSH
31951: LD_INT 0
31953: PUSH
31954: EMPTY
31955: LIST
31956: LIST
31957: PUSH
31958: LD_INT 1
31960: PUSH
31961: LD_INT 1
31963: PUSH
31964: EMPTY
31965: LIST
31966: LIST
31967: PUSH
31968: LD_INT 0
31970: PUSH
31971: LD_INT 1
31973: PUSH
31974: EMPTY
31975: LIST
31976: LIST
31977: PUSH
31978: LD_INT 1
31980: NEG
31981: PUSH
31982: LD_INT 0
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 1
31991: NEG
31992: PUSH
31993: LD_INT 1
31995: NEG
31996: PUSH
31997: EMPTY
31998: LIST
31999: LIST
32000: PUSH
32001: LD_INT 1
32003: NEG
32004: PUSH
32005: LD_INT 2
32007: NEG
32008: PUSH
32009: EMPTY
32010: LIST
32011: LIST
32012: PUSH
32013: LD_INT 0
32015: PUSH
32016: LD_INT 2
32018: NEG
32019: PUSH
32020: EMPTY
32021: LIST
32022: LIST
32023: PUSH
32024: LD_INT 1
32026: PUSH
32027: LD_INT 1
32029: NEG
32030: PUSH
32031: EMPTY
32032: LIST
32033: LIST
32034: PUSH
32035: LD_INT 1
32037: PUSH
32038: LD_INT 2
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: PUSH
32045: LD_INT 0
32047: PUSH
32048: LD_INT 2
32050: PUSH
32051: EMPTY
32052: LIST
32053: LIST
32054: PUSH
32055: LD_INT 1
32057: NEG
32058: PUSH
32059: LD_INT 1
32061: PUSH
32062: EMPTY
32063: LIST
32064: LIST
32065: PUSH
32066: LD_INT 1
32068: PUSH
32069: LD_INT 3
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 0
32078: PUSH
32079: LD_INT 3
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: LD_INT 1
32088: NEG
32089: PUSH
32090: LD_INT 2
32092: PUSH
32093: EMPTY
32094: LIST
32095: LIST
32096: PUSH
32097: EMPTY
32098: LIST
32099: LIST
32100: LIST
32101: LIST
32102: LIST
32103: LIST
32104: LIST
32105: LIST
32106: LIST
32107: LIST
32108: LIST
32109: LIST
32110: LIST
32111: LIST
32112: LIST
32113: LIST
32114: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32115: LD_ADDR_VAR 0 12
32119: PUSH
32120: LD_INT 0
32122: PUSH
32123: LD_INT 0
32125: PUSH
32126: EMPTY
32127: LIST
32128: LIST
32129: PUSH
32130: LD_INT 0
32132: PUSH
32133: LD_INT 1
32135: NEG
32136: PUSH
32137: EMPTY
32138: LIST
32139: LIST
32140: PUSH
32141: LD_INT 1
32143: PUSH
32144: LD_INT 0
32146: PUSH
32147: EMPTY
32148: LIST
32149: LIST
32150: PUSH
32151: LD_INT 1
32153: PUSH
32154: LD_INT 1
32156: PUSH
32157: EMPTY
32158: LIST
32159: LIST
32160: PUSH
32161: LD_INT 0
32163: PUSH
32164: LD_INT 1
32166: PUSH
32167: EMPTY
32168: LIST
32169: LIST
32170: PUSH
32171: LD_INT 1
32173: NEG
32174: PUSH
32175: LD_INT 0
32177: PUSH
32178: EMPTY
32179: LIST
32180: LIST
32181: PUSH
32182: LD_INT 1
32184: NEG
32185: PUSH
32186: LD_INT 1
32188: NEG
32189: PUSH
32190: EMPTY
32191: LIST
32192: LIST
32193: PUSH
32194: LD_INT 1
32196: PUSH
32197: LD_INT 1
32199: NEG
32200: PUSH
32201: EMPTY
32202: LIST
32203: LIST
32204: PUSH
32205: LD_INT 2
32207: PUSH
32208: LD_INT 0
32210: PUSH
32211: EMPTY
32212: LIST
32213: LIST
32214: PUSH
32215: LD_INT 2
32217: PUSH
32218: LD_INT 1
32220: PUSH
32221: EMPTY
32222: LIST
32223: LIST
32224: PUSH
32225: LD_INT 1
32227: NEG
32228: PUSH
32229: LD_INT 1
32231: PUSH
32232: EMPTY
32233: LIST
32234: LIST
32235: PUSH
32236: LD_INT 2
32238: NEG
32239: PUSH
32240: LD_INT 0
32242: PUSH
32243: EMPTY
32244: LIST
32245: LIST
32246: PUSH
32247: LD_INT 2
32249: NEG
32250: PUSH
32251: LD_INT 1
32253: NEG
32254: PUSH
32255: EMPTY
32256: LIST
32257: LIST
32258: PUSH
32259: LD_INT 2
32261: NEG
32262: PUSH
32263: LD_INT 1
32265: PUSH
32266: EMPTY
32267: LIST
32268: LIST
32269: PUSH
32270: LD_INT 3
32272: NEG
32273: PUSH
32274: LD_INT 0
32276: PUSH
32277: EMPTY
32278: LIST
32279: LIST
32280: PUSH
32281: LD_INT 3
32283: NEG
32284: PUSH
32285: LD_INT 1
32287: NEG
32288: PUSH
32289: EMPTY
32290: LIST
32291: LIST
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: LIST
32297: LIST
32298: LIST
32299: LIST
32300: LIST
32301: LIST
32302: LIST
32303: LIST
32304: LIST
32305: LIST
32306: LIST
32307: LIST
32308: LIST
32309: LIST
32310: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32311: LD_ADDR_VAR 0 13
32315: PUSH
32316: LD_INT 0
32318: PUSH
32319: LD_INT 0
32321: PUSH
32322: EMPTY
32323: LIST
32324: LIST
32325: PUSH
32326: LD_INT 0
32328: PUSH
32329: LD_INT 1
32331: NEG
32332: PUSH
32333: EMPTY
32334: LIST
32335: LIST
32336: PUSH
32337: LD_INT 1
32339: PUSH
32340: LD_INT 0
32342: PUSH
32343: EMPTY
32344: LIST
32345: LIST
32346: PUSH
32347: LD_INT 1
32349: PUSH
32350: LD_INT 1
32352: PUSH
32353: EMPTY
32354: LIST
32355: LIST
32356: PUSH
32357: LD_INT 0
32359: PUSH
32360: LD_INT 1
32362: PUSH
32363: EMPTY
32364: LIST
32365: LIST
32366: PUSH
32367: LD_INT 1
32369: NEG
32370: PUSH
32371: LD_INT 0
32373: PUSH
32374: EMPTY
32375: LIST
32376: LIST
32377: PUSH
32378: LD_INT 1
32380: NEG
32381: PUSH
32382: LD_INT 1
32384: NEG
32385: PUSH
32386: EMPTY
32387: LIST
32388: LIST
32389: PUSH
32390: LD_INT 1
32392: NEG
32393: PUSH
32394: LD_INT 2
32396: NEG
32397: PUSH
32398: EMPTY
32399: LIST
32400: LIST
32401: PUSH
32402: LD_INT 2
32404: PUSH
32405: LD_INT 1
32407: PUSH
32408: EMPTY
32409: LIST
32410: LIST
32411: PUSH
32412: LD_INT 2
32414: PUSH
32415: LD_INT 2
32417: PUSH
32418: EMPTY
32419: LIST
32420: LIST
32421: PUSH
32422: LD_INT 1
32424: PUSH
32425: LD_INT 2
32427: PUSH
32428: EMPTY
32429: LIST
32430: LIST
32431: PUSH
32432: LD_INT 2
32434: NEG
32435: PUSH
32436: LD_INT 1
32438: NEG
32439: PUSH
32440: EMPTY
32441: LIST
32442: LIST
32443: PUSH
32444: LD_INT 2
32446: NEG
32447: PUSH
32448: LD_INT 2
32450: NEG
32451: PUSH
32452: EMPTY
32453: LIST
32454: LIST
32455: PUSH
32456: LD_INT 2
32458: NEG
32459: PUSH
32460: LD_INT 3
32462: NEG
32463: PUSH
32464: EMPTY
32465: LIST
32466: LIST
32467: PUSH
32468: LD_INT 3
32470: NEG
32471: PUSH
32472: LD_INT 2
32474: NEG
32475: PUSH
32476: EMPTY
32477: LIST
32478: LIST
32479: PUSH
32480: LD_INT 3
32482: NEG
32483: PUSH
32484: LD_INT 3
32486: NEG
32487: PUSH
32488: EMPTY
32489: LIST
32490: LIST
32491: PUSH
32492: EMPTY
32493: LIST
32494: LIST
32495: LIST
32496: LIST
32497: LIST
32498: LIST
32499: LIST
32500: LIST
32501: LIST
32502: LIST
32503: LIST
32504: LIST
32505: LIST
32506: LIST
32507: LIST
32508: LIST
32509: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
32510: LD_ADDR_VAR 0 14
32514: PUSH
32515: LD_INT 0
32517: PUSH
32518: LD_INT 0
32520: PUSH
32521: EMPTY
32522: LIST
32523: LIST
32524: PUSH
32525: LD_INT 0
32527: PUSH
32528: LD_INT 1
32530: NEG
32531: PUSH
32532: EMPTY
32533: LIST
32534: LIST
32535: PUSH
32536: LD_INT 1
32538: PUSH
32539: LD_INT 0
32541: PUSH
32542: EMPTY
32543: LIST
32544: LIST
32545: PUSH
32546: LD_INT 1
32548: PUSH
32549: LD_INT 1
32551: PUSH
32552: EMPTY
32553: LIST
32554: LIST
32555: PUSH
32556: LD_INT 0
32558: PUSH
32559: LD_INT 1
32561: PUSH
32562: EMPTY
32563: LIST
32564: LIST
32565: PUSH
32566: LD_INT 1
32568: NEG
32569: PUSH
32570: LD_INT 0
32572: PUSH
32573: EMPTY
32574: LIST
32575: LIST
32576: PUSH
32577: LD_INT 1
32579: NEG
32580: PUSH
32581: LD_INT 1
32583: NEG
32584: PUSH
32585: EMPTY
32586: LIST
32587: LIST
32588: PUSH
32589: LD_INT 1
32591: NEG
32592: PUSH
32593: LD_INT 2
32595: NEG
32596: PUSH
32597: EMPTY
32598: LIST
32599: LIST
32600: PUSH
32601: LD_INT 0
32603: PUSH
32604: LD_INT 2
32606: NEG
32607: PUSH
32608: EMPTY
32609: LIST
32610: LIST
32611: PUSH
32612: LD_INT 1
32614: PUSH
32615: LD_INT 1
32617: NEG
32618: PUSH
32619: EMPTY
32620: LIST
32621: LIST
32622: PUSH
32623: LD_INT 1
32625: PUSH
32626: LD_INT 2
32628: PUSH
32629: EMPTY
32630: LIST
32631: LIST
32632: PUSH
32633: LD_INT 0
32635: PUSH
32636: LD_INT 2
32638: PUSH
32639: EMPTY
32640: LIST
32641: LIST
32642: PUSH
32643: LD_INT 1
32645: NEG
32646: PUSH
32647: LD_INT 1
32649: PUSH
32650: EMPTY
32651: LIST
32652: LIST
32653: PUSH
32654: LD_INT 1
32656: NEG
32657: PUSH
32658: LD_INT 3
32660: NEG
32661: PUSH
32662: EMPTY
32663: LIST
32664: LIST
32665: PUSH
32666: LD_INT 0
32668: PUSH
32669: LD_INT 3
32671: NEG
32672: PUSH
32673: EMPTY
32674: LIST
32675: LIST
32676: PUSH
32677: LD_INT 1
32679: PUSH
32680: LD_INT 2
32682: NEG
32683: PUSH
32684: EMPTY
32685: LIST
32686: LIST
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: LIST
32692: LIST
32693: LIST
32694: LIST
32695: LIST
32696: LIST
32697: LIST
32698: LIST
32699: LIST
32700: LIST
32701: LIST
32702: LIST
32703: LIST
32704: LIST
32705: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
32706: LD_ADDR_VAR 0 15
32710: PUSH
32711: LD_INT 0
32713: PUSH
32714: LD_INT 0
32716: PUSH
32717: EMPTY
32718: LIST
32719: LIST
32720: PUSH
32721: LD_INT 0
32723: PUSH
32724: LD_INT 1
32726: NEG
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: PUSH
32732: LD_INT 1
32734: PUSH
32735: LD_INT 0
32737: PUSH
32738: EMPTY
32739: LIST
32740: LIST
32741: PUSH
32742: LD_INT 1
32744: PUSH
32745: LD_INT 1
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: PUSH
32752: LD_INT 0
32754: PUSH
32755: LD_INT 1
32757: PUSH
32758: EMPTY
32759: LIST
32760: LIST
32761: PUSH
32762: LD_INT 1
32764: NEG
32765: PUSH
32766: LD_INT 0
32768: PUSH
32769: EMPTY
32770: LIST
32771: LIST
32772: PUSH
32773: LD_INT 1
32775: NEG
32776: PUSH
32777: LD_INT 1
32779: NEG
32780: PUSH
32781: EMPTY
32782: LIST
32783: LIST
32784: PUSH
32785: LD_INT 1
32787: PUSH
32788: LD_INT 1
32790: NEG
32791: PUSH
32792: EMPTY
32793: LIST
32794: LIST
32795: PUSH
32796: LD_INT 2
32798: PUSH
32799: LD_INT 0
32801: PUSH
32802: EMPTY
32803: LIST
32804: LIST
32805: PUSH
32806: LD_INT 2
32808: PUSH
32809: LD_INT 1
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: PUSH
32816: LD_INT 1
32818: NEG
32819: PUSH
32820: LD_INT 1
32822: PUSH
32823: EMPTY
32824: LIST
32825: LIST
32826: PUSH
32827: LD_INT 2
32829: NEG
32830: PUSH
32831: LD_INT 0
32833: PUSH
32834: EMPTY
32835: LIST
32836: LIST
32837: PUSH
32838: LD_INT 2
32840: NEG
32841: PUSH
32842: LD_INT 1
32844: NEG
32845: PUSH
32846: EMPTY
32847: LIST
32848: LIST
32849: PUSH
32850: LD_INT 2
32852: PUSH
32853: LD_INT 1
32855: NEG
32856: PUSH
32857: EMPTY
32858: LIST
32859: LIST
32860: PUSH
32861: LD_INT 3
32863: PUSH
32864: LD_INT 0
32866: PUSH
32867: EMPTY
32868: LIST
32869: LIST
32870: PUSH
32871: LD_INT 3
32873: PUSH
32874: LD_INT 1
32876: PUSH
32877: EMPTY
32878: LIST
32879: LIST
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: LIST
32885: LIST
32886: LIST
32887: LIST
32888: LIST
32889: LIST
32890: LIST
32891: LIST
32892: LIST
32893: LIST
32894: LIST
32895: LIST
32896: LIST
32897: LIST
32898: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
32899: LD_ADDR_VAR 0 16
32903: PUSH
32904: LD_INT 0
32906: PUSH
32907: LD_INT 0
32909: PUSH
32910: EMPTY
32911: LIST
32912: LIST
32913: PUSH
32914: LD_INT 0
32916: PUSH
32917: LD_INT 1
32919: NEG
32920: PUSH
32921: EMPTY
32922: LIST
32923: LIST
32924: PUSH
32925: LD_INT 1
32927: PUSH
32928: LD_INT 0
32930: PUSH
32931: EMPTY
32932: LIST
32933: LIST
32934: PUSH
32935: LD_INT 1
32937: PUSH
32938: LD_INT 1
32940: PUSH
32941: EMPTY
32942: LIST
32943: LIST
32944: PUSH
32945: LD_INT 0
32947: PUSH
32948: LD_INT 1
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 1
32957: NEG
32958: PUSH
32959: LD_INT 0
32961: PUSH
32962: EMPTY
32963: LIST
32964: LIST
32965: PUSH
32966: LD_INT 1
32968: NEG
32969: PUSH
32970: LD_INT 1
32972: NEG
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 1
32980: NEG
32981: PUSH
32982: LD_INT 2
32984: NEG
32985: PUSH
32986: EMPTY
32987: LIST
32988: LIST
32989: PUSH
32990: LD_INT 2
32992: PUSH
32993: LD_INT 1
32995: PUSH
32996: EMPTY
32997: LIST
32998: LIST
32999: PUSH
33000: LD_INT 2
33002: PUSH
33003: LD_INT 2
33005: PUSH
33006: EMPTY
33007: LIST
33008: LIST
33009: PUSH
33010: LD_INT 1
33012: PUSH
33013: LD_INT 2
33015: PUSH
33016: EMPTY
33017: LIST
33018: LIST
33019: PUSH
33020: LD_INT 2
33022: NEG
33023: PUSH
33024: LD_INT 1
33026: NEG
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: PUSH
33032: LD_INT 2
33034: NEG
33035: PUSH
33036: LD_INT 2
33038: NEG
33039: PUSH
33040: EMPTY
33041: LIST
33042: LIST
33043: PUSH
33044: LD_INT 3
33046: PUSH
33047: LD_INT 2
33049: PUSH
33050: EMPTY
33051: LIST
33052: LIST
33053: PUSH
33054: LD_INT 3
33056: PUSH
33057: LD_INT 3
33059: PUSH
33060: EMPTY
33061: LIST
33062: LIST
33063: PUSH
33064: LD_INT 2
33066: PUSH
33067: LD_INT 3
33069: PUSH
33070: EMPTY
33071: LIST
33072: LIST
33073: PUSH
33074: EMPTY
33075: LIST
33076: LIST
33077: LIST
33078: LIST
33079: LIST
33080: LIST
33081: LIST
33082: LIST
33083: LIST
33084: LIST
33085: LIST
33086: LIST
33087: LIST
33088: LIST
33089: LIST
33090: LIST
33091: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33092: LD_ADDR_VAR 0 17
33096: PUSH
33097: LD_INT 0
33099: PUSH
33100: LD_INT 0
33102: PUSH
33103: EMPTY
33104: LIST
33105: LIST
33106: PUSH
33107: LD_INT 0
33109: PUSH
33110: LD_INT 1
33112: NEG
33113: PUSH
33114: EMPTY
33115: LIST
33116: LIST
33117: PUSH
33118: LD_INT 1
33120: PUSH
33121: LD_INT 0
33123: PUSH
33124: EMPTY
33125: LIST
33126: LIST
33127: PUSH
33128: LD_INT 1
33130: PUSH
33131: LD_INT 1
33133: PUSH
33134: EMPTY
33135: LIST
33136: LIST
33137: PUSH
33138: LD_INT 0
33140: PUSH
33141: LD_INT 1
33143: PUSH
33144: EMPTY
33145: LIST
33146: LIST
33147: PUSH
33148: LD_INT 1
33150: NEG
33151: PUSH
33152: LD_INT 0
33154: PUSH
33155: EMPTY
33156: LIST
33157: LIST
33158: PUSH
33159: LD_INT 1
33161: NEG
33162: PUSH
33163: LD_INT 1
33165: NEG
33166: PUSH
33167: EMPTY
33168: LIST
33169: LIST
33170: PUSH
33171: LD_INT 1
33173: NEG
33174: PUSH
33175: LD_INT 2
33177: NEG
33178: PUSH
33179: EMPTY
33180: LIST
33181: LIST
33182: PUSH
33183: LD_INT 0
33185: PUSH
33186: LD_INT 2
33188: NEG
33189: PUSH
33190: EMPTY
33191: LIST
33192: LIST
33193: PUSH
33194: LD_INT 1
33196: PUSH
33197: LD_INT 1
33199: NEG
33200: PUSH
33201: EMPTY
33202: LIST
33203: LIST
33204: PUSH
33205: LD_INT 2
33207: PUSH
33208: LD_INT 0
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PUSH
33215: LD_INT 2
33217: PUSH
33218: LD_INT 1
33220: PUSH
33221: EMPTY
33222: LIST
33223: LIST
33224: PUSH
33225: LD_INT 2
33227: PUSH
33228: LD_INT 2
33230: PUSH
33231: EMPTY
33232: LIST
33233: LIST
33234: PUSH
33235: LD_INT 1
33237: PUSH
33238: LD_INT 2
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: PUSH
33245: LD_INT 0
33247: PUSH
33248: LD_INT 2
33250: PUSH
33251: EMPTY
33252: LIST
33253: LIST
33254: PUSH
33255: LD_INT 1
33257: NEG
33258: PUSH
33259: LD_INT 1
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 2
33268: NEG
33269: PUSH
33270: LD_INT 0
33272: PUSH
33273: EMPTY
33274: LIST
33275: LIST
33276: PUSH
33277: LD_INT 2
33279: NEG
33280: PUSH
33281: LD_INT 1
33283: NEG
33284: PUSH
33285: EMPTY
33286: LIST
33287: LIST
33288: PUSH
33289: LD_INT 2
33291: NEG
33292: PUSH
33293: LD_INT 2
33295: NEG
33296: PUSH
33297: EMPTY
33298: LIST
33299: LIST
33300: PUSH
33301: EMPTY
33302: LIST
33303: LIST
33304: LIST
33305: LIST
33306: LIST
33307: LIST
33308: LIST
33309: LIST
33310: LIST
33311: LIST
33312: LIST
33313: LIST
33314: LIST
33315: LIST
33316: LIST
33317: LIST
33318: LIST
33319: LIST
33320: LIST
33321: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33322: LD_ADDR_VAR 0 18
33326: PUSH
33327: LD_INT 0
33329: PUSH
33330: LD_INT 0
33332: PUSH
33333: EMPTY
33334: LIST
33335: LIST
33336: PUSH
33337: LD_INT 0
33339: PUSH
33340: LD_INT 1
33342: NEG
33343: PUSH
33344: EMPTY
33345: LIST
33346: LIST
33347: PUSH
33348: LD_INT 1
33350: PUSH
33351: LD_INT 0
33353: PUSH
33354: EMPTY
33355: LIST
33356: LIST
33357: PUSH
33358: LD_INT 1
33360: PUSH
33361: LD_INT 1
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: LD_INT 0
33370: PUSH
33371: LD_INT 1
33373: PUSH
33374: EMPTY
33375: LIST
33376: LIST
33377: PUSH
33378: LD_INT 1
33380: NEG
33381: PUSH
33382: LD_INT 0
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: PUSH
33389: LD_INT 1
33391: NEG
33392: PUSH
33393: LD_INT 1
33395: NEG
33396: PUSH
33397: EMPTY
33398: LIST
33399: LIST
33400: PUSH
33401: LD_INT 1
33403: NEG
33404: PUSH
33405: LD_INT 2
33407: NEG
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 0
33415: PUSH
33416: LD_INT 2
33418: NEG
33419: PUSH
33420: EMPTY
33421: LIST
33422: LIST
33423: PUSH
33424: LD_INT 1
33426: PUSH
33427: LD_INT 1
33429: NEG
33430: PUSH
33431: EMPTY
33432: LIST
33433: LIST
33434: PUSH
33435: LD_INT 2
33437: PUSH
33438: LD_INT 0
33440: PUSH
33441: EMPTY
33442: LIST
33443: LIST
33444: PUSH
33445: LD_INT 2
33447: PUSH
33448: LD_INT 1
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: LD_INT 2
33457: PUSH
33458: LD_INT 2
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: PUSH
33465: LD_INT 1
33467: PUSH
33468: LD_INT 2
33470: PUSH
33471: EMPTY
33472: LIST
33473: LIST
33474: PUSH
33475: LD_INT 0
33477: PUSH
33478: LD_INT 2
33480: PUSH
33481: EMPTY
33482: LIST
33483: LIST
33484: PUSH
33485: LD_INT 1
33487: NEG
33488: PUSH
33489: LD_INT 1
33491: PUSH
33492: EMPTY
33493: LIST
33494: LIST
33495: PUSH
33496: LD_INT 2
33498: NEG
33499: PUSH
33500: LD_INT 0
33502: PUSH
33503: EMPTY
33504: LIST
33505: LIST
33506: PUSH
33507: LD_INT 2
33509: NEG
33510: PUSH
33511: LD_INT 1
33513: NEG
33514: PUSH
33515: EMPTY
33516: LIST
33517: LIST
33518: PUSH
33519: LD_INT 2
33521: NEG
33522: PUSH
33523: LD_INT 2
33525: NEG
33526: PUSH
33527: EMPTY
33528: LIST
33529: LIST
33530: PUSH
33531: EMPTY
33532: LIST
33533: LIST
33534: LIST
33535: LIST
33536: LIST
33537: LIST
33538: LIST
33539: LIST
33540: LIST
33541: LIST
33542: LIST
33543: LIST
33544: LIST
33545: LIST
33546: LIST
33547: LIST
33548: LIST
33549: LIST
33550: LIST
33551: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33552: LD_ADDR_VAR 0 19
33556: PUSH
33557: LD_INT 0
33559: PUSH
33560: LD_INT 0
33562: PUSH
33563: EMPTY
33564: LIST
33565: LIST
33566: PUSH
33567: LD_INT 0
33569: PUSH
33570: LD_INT 1
33572: NEG
33573: PUSH
33574: EMPTY
33575: LIST
33576: LIST
33577: PUSH
33578: LD_INT 1
33580: PUSH
33581: LD_INT 0
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: PUSH
33588: LD_INT 1
33590: PUSH
33591: LD_INT 1
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PUSH
33598: LD_INT 0
33600: PUSH
33601: LD_INT 1
33603: PUSH
33604: EMPTY
33605: LIST
33606: LIST
33607: PUSH
33608: LD_INT 1
33610: NEG
33611: PUSH
33612: LD_INT 0
33614: PUSH
33615: EMPTY
33616: LIST
33617: LIST
33618: PUSH
33619: LD_INT 1
33621: NEG
33622: PUSH
33623: LD_INT 1
33625: NEG
33626: PUSH
33627: EMPTY
33628: LIST
33629: LIST
33630: PUSH
33631: LD_INT 1
33633: NEG
33634: PUSH
33635: LD_INT 2
33637: NEG
33638: PUSH
33639: EMPTY
33640: LIST
33641: LIST
33642: PUSH
33643: LD_INT 0
33645: PUSH
33646: LD_INT 2
33648: NEG
33649: PUSH
33650: EMPTY
33651: LIST
33652: LIST
33653: PUSH
33654: LD_INT 1
33656: PUSH
33657: LD_INT 1
33659: NEG
33660: PUSH
33661: EMPTY
33662: LIST
33663: LIST
33664: PUSH
33665: LD_INT 2
33667: PUSH
33668: LD_INT 0
33670: PUSH
33671: EMPTY
33672: LIST
33673: LIST
33674: PUSH
33675: LD_INT 2
33677: PUSH
33678: LD_INT 1
33680: PUSH
33681: EMPTY
33682: LIST
33683: LIST
33684: PUSH
33685: LD_INT 2
33687: PUSH
33688: LD_INT 2
33690: PUSH
33691: EMPTY
33692: LIST
33693: LIST
33694: PUSH
33695: LD_INT 1
33697: PUSH
33698: LD_INT 2
33700: PUSH
33701: EMPTY
33702: LIST
33703: LIST
33704: PUSH
33705: LD_INT 0
33707: PUSH
33708: LD_INT 2
33710: PUSH
33711: EMPTY
33712: LIST
33713: LIST
33714: PUSH
33715: LD_INT 1
33717: NEG
33718: PUSH
33719: LD_INT 1
33721: PUSH
33722: EMPTY
33723: LIST
33724: LIST
33725: PUSH
33726: LD_INT 2
33728: NEG
33729: PUSH
33730: LD_INT 0
33732: PUSH
33733: EMPTY
33734: LIST
33735: LIST
33736: PUSH
33737: LD_INT 2
33739: NEG
33740: PUSH
33741: LD_INT 1
33743: NEG
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: PUSH
33749: LD_INT 2
33751: NEG
33752: PUSH
33753: LD_INT 2
33755: NEG
33756: PUSH
33757: EMPTY
33758: LIST
33759: LIST
33760: PUSH
33761: EMPTY
33762: LIST
33763: LIST
33764: LIST
33765: LIST
33766: LIST
33767: LIST
33768: LIST
33769: LIST
33770: LIST
33771: LIST
33772: LIST
33773: LIST
33774: LIST
33775: LIST
33776: LIST
33777: LIST
33778: LIST
33779: LIST
33780: LIST
33781: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33782: LD_ADDR_VAR 0 20
33786: PUSH
33787: LD_INT 0
33789: PUSH
33790: LD_INT 0
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PUSH
33797: LD_INT 0
33799: PUSH
33800: LD_INT 1
33802: NEG
33803: PUSH
33804: EMPTY
33805: LIST
33806: LIST
33807: PUSH
33808: LD_INT 1
33810: PUSH
33811: LD_INT 0
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PUSH
33818: LD_INT 1
33820: PUSH
33821: LD_INT 1
33823: PUSH
33824: EMPTY
33825: LIST
33826: LIST
33827: PUSH
33828: LD_INT 0
33830: PUSH
33831: LD_INT 1
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: PUSH
33838: LD_INT 1
33840: NEG
33841: PUSH
33842: LD_INT 0
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: PUSH
33849: LD_INT 1
33851: NEG
33852: PUSH
33853: LD_INT 1
33855: NEG
33856: PUSH
33857: EMPTY
33858: LIST
33859: LIST
33860: PUSH
33861: LD_INT 1
33863: NEG
33864: PUSH
33865: LD_INT 2
33867: NEG
33868: PUSH
33869: EMPTY
33870: LIST
33871: LIST
33872: PUSH
33873: LD_INT 0
33875: PUSH
33876: LD_INT 2
33878: NEG
33879: PUSH
33880: EMPTY
33881: LIST
33882: LIST
33883: PUSH
33884: LD_INT 1
33886: PUSH
33887: LD_INT 1
33889: NEG
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 2
33897: PUSH
33898: LD_INT 0
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 2
33907: PUSH
33908: LD_INT 1
33910: PUSH
33911: EMPTY
33912: LIST
33913: LIST
33914: PUSH
33915: LD_INT 2
33917: PUSH
33918: LD_INT 2
33920: PUSH
33921: EMPTY
33922: LIST
33923: LIST
33924: PUSH
33925: LD_INT 1
33927: PUSH
33928: LD_INT 2
33930: PUSH
33931: EMPTY
33932: LIST
33933: LIST
33934: PUSH
33935: LD_INT 0
33937: PUSH
33938: LD_INT 2
33940: PUSH
33941: EMPTY
33942: LIST
33943: LIST
33944: PUSH
33945: LD_INT 1
33947: NEG
33948: PUSH
33949: LD_INT 1
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: PUSH
33956: LD_INT 2
33958: NEG
33959: PUSH
33960: LD_INT 0
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 2
33969: NEG
33970: PUSH
33971: LD_INT 1
33973: NEG
33974: PUSH
33975: EMPTY
33976: LIST
33977: LIST
33978: PUSH
33979: LD_INT 2
33981: NEG
33982: PUSH
33983: LD_INT 2
33985: NEG
33986: PUSH
33987: EMPTY
33988: LIST
33989: LIST
33990: PUSH
33991: EMPTY
33992: LIST
33993: LIST
33994: LIST
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: LIST
34000: LIST
34001: LIST
34002: LIST
34003: LIST
34004: LIST
34005: LIST
34006: LIST
34007: LIST
34008: LIST
34009: LIST
34010: LIST
34011: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34012: LD_ADDR_VAR 0 21
34016: PUSH
34017: LD_INT 0
34019: PUSH
34020: LD_INT 0
34022: PUSH
34023: EMPTY
34024: LIST
34025: LIST
34026: PUSH
34027: LD_INT 0
34029: PUSH
34030: LD_INT 1
34032: NEG
34033: PUSH
34034: EMPTY
34035: LIST
34036: LIST
34037: PUSH
34038: LD_INT 1
34040: PUSH
34041: LD_INT 0
34043: PUSH
34044: EMPTY
34045: LIST
34046: LIST
34047: PUSH
34048: LD_INT 1
34050: PUSH
34051: LD_INT 1
34053: PUSH
34054: EMPTY
34055: LIST
34056: LIST
34057: PUSH
34058: LD_INT 0
34060: PUSH
34061: LD_INT 1
34063: PUSH
34064: EMPTY
34065: LIST
34066: LIST
34067: PUSH
34068: LD_INT 1
34070: NEG
34071: PUSH
34072: LD_INT 0
34074: PUSH
34075: EMPTY
34076: LIST
34077: LIST
34078: PUSH
34079: LD_INT 1
34081: NEG
34082: PUSH
34083: LD_INT 1
34085: NEG
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 1
34093: NEG
34094: PUSH
34095: LD_INT 2
34097: NEG
34098: PUSH
34099: EMPTY
34100: LIST
34101: LIST
34102: PUSH
34103: LD_INT 0
34105: PUSH
34106: LD_INT 2
34108: NEG
34109: PUSH
34110: EMPTY
34111: LIST
34112: LIST
34113: PUSH
34114: LD_INT 1
34116: PUSH
34117: LD_INT 1
34119: NEG
34120: PUSH
34121: EMPTY
34122: LIST
34123: LIST
34124: PUSH
34125: LD_INT 2
34127: PUSH
34128: LD_INT 0
34130: PUSH
34131: EMPTY
34132: LIST
34133: LIST
34134: PUSH
34135: LD_INT 2
34137: PUSH
34138: LD_INT 1
34140: PUSH
34141: EMPTY
34142: LIST
34143: LIST
34144: PUSH
34145: LD_INT 2
34147: PUSH
34148: LD_INT 2
34150: PUSH
34151: EMPTY
34152: LIST
34153: LIST
34154: PUSH
34155: LD_INT 1
34157: PUSH
34158: LD_INT 2
34160: PUSH
34161: EMPTY
34162: LIST
34163: LIST
34164: PUSH
34165: LD_INT 0
34167: PUSH
34168: LD_INT 2
34170: PUSH
34171: EMPTY
34172: LIST
34173: LIST
34174: PUSH
34175: LD_INT 1
34177: NEG
34178: PUSH
34179: LD_INT 1
34181: PUSH
34182: EMPTY
34183: LIST
34184: LIST
34185: PUSH
34186: LD_INT 2
34188: NEG
34189: PUSH
34190: LD_INT 0
34192: PUSH
34193: EMPTY
34194: LIST
34195: LIST
34196: PUSH
34197: LD_INT 2
34199: NEG
34200: PUSH
34201: LD_INT 1
34203: NEG
34204: PUSH
34205: EMPTY
34206: LIST
34207: LIST
34208: PUSH
34209: LD_INT 2
34211: NEG
34212: PUSH
34213: LD_INT 2
34215: NEG
34216: PUSH
34217: EMPTY
34218: LIST
34219: LIST
34220: PUSH
34221: EMPTY
34222: LIST
34223: LIST
34224: LIST
34225: LIST
34226: LIST
34227: LIST
34228: LIST
34229: LIST
34230: LIST
34231: LIST
34232: LIST
34233: LIST
34234: LIST
34235: LIST
34236: LIST
34237: LIST
34238: LIST
34239: LIST
34240: LIST
34241: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34242: LD_ADDR_VAR 0 22
34246: PUSH
34247: LD_INT 0
34249: PUSH
34250: LD_INT 0
34252: PUSH
34253: EMPTY
34254: LIST
34255: LIST
34256: PUSH
34257: LD_INT 0
34259: PUSH
34260: LD_INT 1
34262: NEG
34263: PUSH
34264: EMPTY
34265: LIST
34266: LIST
34267: PUSH
34268: LD_INT 1
34270: PUSH
34271: LD_INT 0
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: PUSH
34278: LD_INT 1
34280: PUSH
34281: LD_INT 1
34283: PUSH
34284: EMPTY
34285: LIST
34286: LIST
34287: PUSH
34288: LD_INT 0
34290: PUSH
34291: LD_INT 1
34293: PUSH
34294: EMPTY
34295: LIST
34296: LIST
34297: PUSH
34298: LD_INT 1
34300: NEG
34301: PUSH
34302: LD_INT 0
34304: PUSH
34305: EMPTY
34306: LIST
34307: LIST
34308: PUSH
34309: LD_INT 1
34311: NEG
34312: PUSH
34313: LD_INT 1
34315: NEG
34316: PUSH
34317: EMPTY
34318: LIST
34319: LIST
34320: PUSH
34321: LD_INT 1
34323: NEG
34324: PUSH
34325: LD_INT 2
34327: NEG
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: PUSH
34333: LD_INT 0
34335: PUSH
34336: LD_INT 2
34338: NEG
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PUSH
34344: LD_INT 1
34346: PUSH
34347: LD_INT 1
34349: NEG
34350: PUSH
34351: EMPTY
34352: LIST
34353: LIST
34354: PUSH
34355: LD_INT 2
34357: PUSH
34358: LD_INT 0
34360: PUSH
34361: EMPTY
34362: LIST
34363: LIST
34364: PUSH
34365: LD_INT 2
34367: PUSH
34368: LD_INT 1
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: PUSH
34375: LD_INT 2
34377: PUSH
34378: LD_INT 2
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: PUSH
34385: LD_INT 1
34387: PUSH
34388: LD_INT 2
34390: PUSH
34391: EMPTY
34392: LIST
34393: LIST
34394: PUSH
34395: LD_INT 0
34397: PUSH
34398: LD_INT 2
34400: PUSH
34401: EMPTY
34402: LIST
34403: LIST
34404: PUSH
34405: LD_INT 1
34407: NEG
34408: PUSH
34409: LD_INT 1
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PUSH
34416: LD_INT 2
34418: NEG
34419: PUSH
34420: LD_INT 0
34422: PUSH
34423: EMPTY
34424: LIST
34425: LIST
34426: PUSH
34427: LD_INT 2
34429: NEG
34430: PUSH
34431: LD_INT 1
34433: NEG
34434: PUSH
34435: EMPTY
34436: LIST
34437: LIST
34438: PUSH
34439: LD_INT 2
34441: NEG
34442: PUSH
34443: LD_INT 2
34445: NEG
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: EMPTY
34452: LIST
34453: LIST
34454: LIST
34455: LIST
34456: LIST
34457: LIST
34458: LIST
34459: LIST
34460: LIST
34461: LIST
34462: LIST
34463: LIST
34464: LIST
34465: LIST
34466: LIST
34467: LIST
34468: LIST
34469: LIST
34470: LIST
34471: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
34472: LD_ADDR_VAR 0 23
34476: PUSH
34477: LD_INT 0
34479: PUSH
34480: LD_INT 0
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: PUSH
34487: LD_INT 0
34489: PUSH
34490: LD_INT 1
34492: NEG
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: PUSH
34498: LD_INT 1
34500: PUSH
34501: LD_INT 0
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: PUSH
34508: LD_INT 1
34510: PUSH
34511: LD_INT 1
34513: PUSH
34514: EMPTY
34515: LIST
34516: LIST
34517: PUSH
34518: LD_INT 0
34520: PUSH
34521: LD_INT 1
34523: PUSH
34524: EMPTY
34525: LIST
34526: LIST
34527: PUSH
34528: LD_INT 1
34530: NEG
34531: PUSH
34532: LD_INT 0
34534: PUSH
34535: EMPTY
34536: LIST
34537: LIST
34538: PUSH
34539: LD_INT 1
34541: NEG
34542: PUSH
34543: LD_INT 1
34545: NEG
34546: PUSH
34547: EMPTY
34548: LIST
34549: LIST
34550: PUSH
34551: LD_INT 1
34553: NEG
34554: PUSH
34555: LD_INT 2
34557: NEG
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 0
34565: PUSH
34566: LD_INT 2
34568: NEG
34569: PUSH
34570: EMPTY
34571: LIST
34572: LIST
34573: PUSH
34574: LD_INT 1
34576: PUSH
34577: LD_INT 1
34579: NEG
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 2
34587: PUSH
34588: LD_INT 0
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: LD_INT 2
34597: PUSH
34598: LD_INT 1
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: LD_INT 2
34607: PUSH
34608: LD_INT 2
34610: PUSH
34611: EMPTY
34612: LIST
34613: LIST
34614: PUSH
34615: LD_INT 1
34617: PUSH
34618: LD_INT 2
34620: PUSH
34621: EMPTY
34622: LIST
34623: LIST
34624: PUSH
34625: LD_INT 0
34627: PUSH
34628: LD_INT 2
34630: PUSH
34631: EMPTY
34632: LIST
34633: LIST
34634: PUSH
34635: LD_INT 1
34637: NEG
34638: PUSH
34639: LD_INT 1
34641: PUSH
34642: EMPTY
34643: LIST
34644: LIST
34645: PUSH
34646: LD_INT 2
34648: NEG
34649: PUSH
34650: LD_INT 0
34652: PUSH
34653: EMPTY
34654: LIST
34655: LIST
34656: PUSH
34657: LD_INT 2
34659: NEG
34660: PUSH
34661: LD_INT 1
34663: NEG
34664: PUSH
34665: EMPTY
34666: LIST
34667: LIST
34668: PUSH
34669: LD_INT 2
34671: NEG
34672: PUSH
34673: LD_INT 2
34675: NEG
34676: PUSH
34677: EMPTY
34678: LIST
34679: LIST
34680: PUSH
34681: LD_INT 2
34683: NEG
34684: PUSH
34685: LD_INT 3
34687: NEG
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: PUSH
34693: LD_INT 1
34695: NEG
34696: PUSH
34697: LD_INT 3
34699: NEG
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: LD_INT 1
34707: PUSH
34708: LD_INT 2
34710: NEG
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: PUSH
34716: LD_INT 2
34718: PUSH
34719: LD_INT 1
34721: NEG
34722: PUSH
34723: EMPTY
34724: LIST
34725: LIST
34726: PUSH
34727: EMPTY
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: LIST
34735: LIST
34736: LIST
34737: LIST
34738: LIST
34739: LIST
34740: LIST
34741: LIST
34742: LIST
34743: LIST
34744: LIST
34745: LIST
34746: LIST
34747: LIST
34748: LIST
34749: LIST
34750: LIST
34751: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
34752: LD_ADDR_VAR 0 24
34756: PUSH
34757: LD_INT 0
34759: PUSH
34760: LD_INT 0
34762: PUSH
34763: EMPTY
34764: LIST
34765: LIST
34766: PUSH
34767: LD_INT 0
34769: PUSH
34770: LD_INT 1
34772: NEG
34773: PUSH
34774: EMPTY
34775: LIST
34776: LIST
34777: PUSH
34778: LD_INT 1
34780: PUSH
34781: LD_INT 0
34783: PUSH
34784: EMPTY
34785: LIST
34786: LIST
34787: PUSH
34788: LD_INT 1
34790: PUSH
34791: LD_INT 1
34793: PUSH
34794: EMPTY
34795: LIST
34796: LIST
34797: PUSH
34798: LD_INT 0
34800: PUSH
34801: LD_INT 1
34803: PUSH
34804: EMPTY
34805: LIST
34806: LIST
34807: PUSH
34808: LD_INT 1
34810: NEG
34811: PUSH
34812: LD_INT 0
34814: PUSH
34815: EMPTY
34816: LIST
34817: LIST
34818: PUSH
34819: LD_INT 1
34821: NEG
34822: PUSH
34823: LD_INT 1
34825: NEG
34826: PUSH
34827: EMPTY
34828: LIST
34829: LIST
34830: PUSH
34831: LD_INT 1
34833: NEG
34834: PUSH
34835: LD_INT 2
34837: NEG
34838: PUSH
34839: EMPTY
34840: LIST
34841: LIST
34842: PUSH
34843: LD_INT 0
34845: PUSH
34846: LD_INT 2
34848: NEG
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PUSH
34854: LD_INT 1
34856: PUSH
34857: LD_INT 1
34859: NEG
34860: PUSH
34861: EMPTY
34862: LIST
34863: LIST
34864: PUSH
34865: LD_INT 2
34867: PUSH
34868: LD_INT 0
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 2
34877: PUSH
34878: LD_INT 1
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 2
34887: PUSH
34888: LD_INT 2
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 1
34897: PUSH
34898: LD_INT 2
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: PUSH
34905: LD_INT 0
34907: PUSH
34908: LD_INT 2
34910: PUSH
34911: EMPTY
34912: LIST
34913: LIST
34914: PUSH
34915: LD_INT 1
34917: NEG
34918: PUSH
34919: LD_INT 1
34921: PUSH
34922: EMPTY
34923: LIST
34924: LIST
34925: PUSH
34926: LD_INT 2
34928: NEG
34929: PUSH
34930: LD_INT 0
34932: PUSH
34933: EMPTY
34934: LIST
34935: LIST
34936: PUSH
34937: LD_INT 2
34939: NEG
34940: PUSH
34941: LD_INT 1
34943: NEG
34944: PUSH
34945: EMPTY
34946: LIST
34947: LIST
34948: PUSH
34949: LD_INT 2
34951: NEG
34952: PUSH
34953: LD_INT 2
34955: NEG
34956: PUSH
34957: EMPTY
34958: LIST
34959: LIST
34960: PUSH
34961: LD_INT 1
34963: PUSH
34964: LD_INT 2
34966: NEG
34967: PUSH
34968: EMPTY
34969: LIST
34970: LIST
34971: PUSH
34972: LD_INT 2
34974: PUSH
34975: LD_INT 1
34977: NEG
34978: PUSH
34979: EMPTY
34980: LIST
34981: LIST
34982: PUSH
34983: LD_INT 3
34985: PUSH
34986: LD_INT 1
34988: PUSH
34989: EMPTY
34990: LIST
34991: LIST
34992: PUSH
34993: LD_INT 3
34995: PUSH
34996: LD_INT 2
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: LIST
35007: LIST
35008: LIST
35009: LIST
35010: LIST
35011: LIST
35012: LIST
35013: LIST
35014: LIST
35015: LIST
35016: LIST
35017: LIST
35018: LIST
35019: LIST
35020: LIST
35021: LIST
35022: LIST
35023: LIST
35024: LIST
35025: LIST
35026: LIST
35027: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
35028: LD_ADDR_VAR 0 25
35032: PUSH
35033: LD_INT 0
35035: PUSH
35036: LD_INT 0
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: LD_INT 0
35045: PUSH
35046: LD_INT 1
35048: NEG
35049: PUSH
35050: EMPTY
35051: LIST
35052: LIST
35053: PUSH
35054: LD_INT 1
35056: PUSH
35057: LD_INT 0
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PUSH
35064: LD_INT 1
35066: PUSH
35067: LD_INT 1
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: LD_INT 0
35076: PUSH
35077: LD_INT 1
35079: PUSH
35080: EMPTY
35081: LIST
35082: LIST
35083: PUSH
35084: LD_INT 1
35086: NEG
35087: PUSH
35088: LD_INT 0
35090: PUSH
35091: EMPTY
35092: LIST
35093: LIST
35094: PUSH
35095: LD_INT 1
35097: NEG
35098: PUSH
35099: LD_INT 1
35101: NEG
35102: PUSH
35103: EMPTY
35104: LIST
35105: LIST
35106: PUSH
35107: LD_INT 1
35109: NEG
35110: PUSH
35111: LD_INT 2
35113: NEG
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 0
35121: PUSH
35122: LD_INT 2
35124: NEG
35125: PUSH
35126: EMPTY
35127: LIST
35128: LIST
35129: PUSH
35130: LD_INT 1
35132: PUSH
35133: LD_INT 1
35135: NEG
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PUSH
35141: LD_INT 2
35143: PUSH
35144: LD_INT 0
35146: PUSH
35147: EMPTY
35148: LIST
35149: LIST
35150: PUSH
35151: LD_INT 2
35153: PUSH
35154: LD_INT 1
35156: PUSH
35157: EMPTY
35158: LIST
35159: LIST
35160: PUSH
35161: LD_INT 2
35163: PUSH
35164: LD_INT 2
35166: PUSH
35167: EMPTY
35168: LIST
35169: LIST
35170: PUSH
35171: LD_INT 1
35173: PUSH
35174: LD_INT 2
35176: PUSH
35177: EMPTY
35178: LIST
35179: LIST
35180: PUSH
35181: LD_INT 0
35183: PUSH
35184: LD_INT 2
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PUSH
35191: LD_INT 1
35193: NEG
35194: PUSH
35195: LD_INT 1
35197: PUSH
35198: EMPTY
35199: LIST
35200: LIST
35201: PUSH
35202: LD_INT 2
35204: NEG
35205: PUSH
35206: LD_INT 0
35208: PUSH
35209: EMPTY
35210: LIST
35211: LIST
35212: PUSH
35213: LD_INT 2
35215: NEG
35216: PUSH
35217: LD_INT 1
35219: NEG
35220: PUSH
35221: EMPTY
35222: LIST
35223: LIST
35224: PUSH
35225: LD_INT 2
35227: NEG
35228: PUSH
35229: LD_INT 2
35231: NEG
35232: PUSH
35233: EMPTY
35234: LIST
35235: LIST
35236: PUSH
35237: LD_INT 3
35239: PUSH
35240: LD_INT 1
35242: PUSH
35243: EMPTY
35244: LIST
35245: LIST
35246: PUSH
35247: LD_INT 3
35249: PUSH
35250: LD_INT 2
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: LD_INT 2
35259: PUSH
35260: LD_INT 3
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: LD_INT 1
35269: PUSH
35270: LD_INT 3
35272: PUSH
35273: EMPTY
35274: LIST
35275: LIST
35276: PUSH
35277: EMPTY
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: LIST
35285: LIST
35286: LIST
35287: LIST
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: LIST
35297: LIST
35298: LIST
35299: LIST
35300: LIST
35301: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
35302: LD_ADDR_VAR 0 26
35306: PUSH
35307: LD_INT 0
35309: PUSH
35310: LD_INT 0
35312: PUSH
35313: EMPTY
35314: LIST
35315: LIST
35316: PUSH
35317: LD_INT 0
35319: PUSH
35320: LD_INT 1
35322: NEG
35323: PUSH
35324: EMPTY
35325: LIST
35326: LIST
35327: PUSH
35328: LD_INT 1
35330: PUSH
35331: LD_INT 0
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: PUSH
35338: LD_INT 1
35340: PUSH
35341: LD_INT 1
35343: PUSH
35344: EMPTY
35345: LIST
35346: LIST
35347: PUSH
35348: LD_INT 0
35350: PUSH
35351: LD_INT 1
35353: PUSH
35354: EMPTY
35355: LIST
35356: LIST
35357: PUSH
35358: LD_INT 1
35360: NEG
35361: PUSH
35362: LD_INT 0
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: PUSH
35369: LD_INT 1
35371: NEG
35372: PUSH
35373: LD_INT 1
35375: NEG
35376: PUSH
35377: EMPTY
35378: LIST
35379: LIST
35380: PUSH
35381: LD_INT 1
35383: NEG
35384: PUSH
35385: LD_INT 2
35387: NEG
35388: PUSH
35389: EMPTY
35390: LIST
35391: LIST
35392: PUSH
35393: LD_INT 0
35395: PUSH
35396: LD_INT 2
35398: NEG
35399: PUSH
35400: EMPTY
35401: LIST
35402: LIST
35403: PUSH
35404: LD_INT 1
35406: PUSH
35407: LD_INT 1
35409: NEG
35410: PUSH
35411: EMPTY
35412: LIST
35413: LIST
35414: PUSH
35415: LD_INT 2
35417: PUSH
35418: LD_INT 0
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 2
35427: PUSH
35428: LD_INT 1
35430: PUSH
35431: EMPTY
35432: LIST
35433: LIST
35434: PUSH
35435: LD_INT 2
35437: PUSH
35438: LD_INT 2
35440: PUSH
35441: EMPTY
35442: LIST
35443: LIST
35444: PUSH
35445: LD_INT 1
35447: PUSH
35448: LD_INT 2
35450: PUSH
35451: EMPTY
35452: LIST
35453: LIST
35454: PUSH
35455: LD_INT 0
35457: PUSH
35458: LD_INT 2
35460: PUSH
35461: EMPTY
35462: LIST
35463: LIST
35464: PUSH
35465: LD_INT 1
35467: NEG
35468: PUSH
35469: LD_INT 1
35471: PUSH
35472: EMPTY
35473: LIST
35474: LIST
35475: PUSH
35476: LD_INT 2
35478: NEG
35479: PUSH
35480: LD_INT 0
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: LD_INT 2
35489: NEG
35490: PUSH
35491: LD_INT 1
35493: NEG
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: PUSH
35499: LD_INT 2
35501: NEG
35502: PUSH
35503: LD_INT 2
35505: NEG
35506: PUSH
35507: EMPTY
35508: LIST
35509: LIST
35510: PUSH
35511: LD_INT 2
35513: PUSH
35514: LD_INT 3
35516: PUSH
35517: EMPTY
35518: LIST
35519: LIST
35520: PUSH
35521: LD_INT 1
35523: PUSH
35524: LD_INT 3
35526: PUSH
35527: EMPTY
35528: LIST
35529: LIST
35530: PUSH
35531: LD_INT 1
35533: NEG
35534: PUSH
35535: LD_INT 2
35537: PUSH
35538: EMPTY
35539: LIST
35540: LIST
35541: PUSH
35542: LD_INT 2
35544: NEG
35545: PUSH
35546: LD_INT 1
35548: PUSH
35549: EMPTY
35550: LIST
35551: LIST
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: LIST
35557: LIST
35558: LIST
35559: LIST
35560: LIST
35561: LIST
35562: LIST
35563: LIST
35564: LIST
35565: LIST
35566: LIST
35567: LIST
35568: LIST
35569: LIST
35570: LIST
35571: LIST
35572: LIST
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
35578: LD_ADDR_VAR 0 27
35582: PUSH
35583: LD_INT 0
35585: PUSH
35586: LD_INT 0
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: PUSH
35593: LD_INT 0
35595: PUSH
35596: LD_INT 1
35598: NEG
35599: PUSH
35600: EMPTY
35601: LIST
35602: LIST
35603: PUSH
35604: LD_INT 1
35606: PUSH
35607: LD_INT 0
35609: PUSH
35610: EMPTY
35611: LIST
35612: LIST
35613: PUSH
35614: LD_INT 1
35616: PUSH
35617: LD_INT 1
35619: PUSH
35620: EMPTY
35621: LIST
35622: LIST
35623: PUSH
35624: LD_INT 0
35626: PUSH
35627: LD_INT 1
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: PUSH
35634: LD_INT 1
35636: NEG
35637: PUSH
35638: LD_INT 0
35640: PUSH
35641: EMPTY
35642: LIST
35643: LIST
35644: PUSH
35645: LD_INT 1
35647: NEG
35648: PUSH
35649: LD_INT 1
35651: NEG
35652: PUSH
35653: EMPTY
35654: LIST
35655: LIST
35656: PUSH
35657: LD_INT 1
35659: NEG
35660: PUSH
35661: LD_INT 2
35663: NEG
35664: PUSH
35665: EMPTY
35666: LIST
35667: LIST
35668: PUSH
35669: LD_INT 0
35671: PUSH
35672: LD_INT 2
35674: NEG
35675: PUSH
35676: EMPTY
35677: LIST
35678: LIST
35679: PUSH
35680: LD_INT 1
35682: PUSH
35683: LD_INT 1
35685: NEG
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 2
35693: PUSH
35694: LD_INT 0
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 2
35703: PUSH
35704: LD_INT 1
35706: PUSH
35707: EMPTY
35708: LIST
35709: LIST
35710: PUSH
35711: LD_INT 2
35713: PUSH
35714: LD_INT 2
35716: PUSH
35717: EMPTY
35718: LIST
35719: LIST
35720: PUSH
35721: LD_INT 1
35723: PUSH
35724: LD_INT 2
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: PUSH
35731: LD_INT 0
35733: PUSH
35734: LD_INT 2
35736: PUSH
35737: EMPTY
35738: LIST
35739: LIST
35740: PUSH
35741: LD_INT 1
35743: NEG
35744: PUSH
35745: LD_INT 1
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: LD_INT 2
35754: NEG
35755: PUSH
35756: LD_INT 0
35758: PUSH
35759: EMPTY
35760: LIST
35761: LIST
35762: PUSH
35763: LD_INT 2
35765: NEG
35766: PUSH
35767: LD_INT 1
35769: NEG
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: LD_INT 2
35777: NEG
35778: PUSH
35779: LD_INT 2
35781: NEG
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: PUSH
35787: LD_INT 1
35789: NEG
35790: PUSH
35791: LD_INT 2
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 2
35800: NEG
35801: PUSH
35802: LD_INT 1
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 3
35811: NEG
35812: PUSH
35813: LD_INT 1
35815: NEG
35816: PUSH
35817: EMPTY
35818: LIST
35819: LIST
35820: PUSH
35821: LD_INT 3
35823: NEG
35824: PUSH
35825: LD_INT 2
35827: NEG
35828: PUSH
35829: EMPTY
35830: LIST
35831: LIST
35832: PUSH
35833: EMPTY
35834: LIST
35835: LIST
35836: LIST
35837: LIST
35838: LIST
35839: LIST
35840: LIST
35841: LIST
35842: LIST
35843: LIST
35844: LIST
35845: LIST
35846: LIST
35847: LIST
35848: LIST
35849: LIST
35850: LIST
35851: LIST
35852: LIST
35853: LIST
35854: LIST
35855: LIST
35856: LIST
35857: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
35858: LD_ADDR_VAR 0 28
35862: PUSH
35863: LD_INT 0
35865: PUSH
35866: LD_INT 0
35868: PUSH
35869: EMPTY
35870: LIST
35871: LIST
35872: PUSH
35873: LD_INT 0
35875: PUSH
35876: LD_INT 1
35878: NEG
35879: PUSH
35880: EMPTY
35881: LIST
35882: LIST
35883: PUSH
35884: LD_INT 1
35886: PUSH
35887: LD_INT 0
35889: PUSH
35890: EMPTY
35891: LIST
35892: LIST
35893: PUSH
35894: LD_INT 1
35896: PUSH
35897: LD_INT 1
35899: PUSH
35900: EMPTY
35901: LIST
35902: LIST
35903: PUSH
35904: LD_INT 0
35906: PUSH
35907: LD_INT 1
35909: PUSH
35910: EMPTY
35911: LIST
35912: LIST
35913: PUSH
35914: LD_INT 1
35916: NEG
35917: PUSH
35918: LD_INT 0
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 1
35927: NEG
35928: PUSH
35929: LD_INT 1
35931: NEG
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PUSH
35937: LD_INT 1
35939: NEG
35940: PUSH
35941: LD_INT 2
35943: NEG
35944: PUSH
35945: EMPTY
35946: LIST
35947: LIST
35948: PUSH
35949: LD_INT 0
35951: PUSH
35952: LD_INT 2
35954: NEG
35955: PUSH
35956: EMPTY
35957: LIST
35958: LIST
35959: PUSH
35960: LD_INT 1
35962: PUSH
35963: LD_INT 1
35965: NEG
35966: PUSH
35967: EMPTY
35968: LIST
35969: LIST
35970: PUSH
35971: LD_INT 2
35973: PUSH
35974: LD_INT 0
35976: PUSH
35977: EMPTY
35978: LIST
35979: LIST
35980: PUSH
35981: LD_INT 2
35983: PUSH
35984: LD_INT 1
35986: PUSH
35987: EMPTY
35988: LIST
35989: LIST
35990: PUSH
35991: LD_INT 2
35993: PUSH
35994: LD_INT 2
35996: PUSH
35997: EMPTY
35998: LIST
35999: LIST
36000: PUSH
36001: LD_INT 1
36003: PUSH
36004: LD_INT 2
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 0
36013: PUSH
36014: LD_INT 2
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 1
36023: NEG
36024: PUSH
36025: LD_INT 1
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: LD_INT 2
36034: NEG
36035: PUSH
36036: LD_INT 0
36038: PUSH
36039: EMPTY
36040: LIST
36041: LIST
36042: PUSH
36043: LD_INT 2
36045: NEG
36046: PUSH
36047: LD_INT 1
36049: NEG
36050: PUSH
36051: EMPTY
36052: LIST
36053: LIST
36054: PUSH
36055: LD_INT 2
36057: NEG
36058: PUSH
36059: LD_INT 2
36061: NEG
36062: PUSH
36063: EMPTY
36064: LIST
36065: LIST
36066: PUSH
36067: LD_INT 2
36069: NEG
36070: PUSH
36071: LD_INT 3
36073: NEG
36074: PUSH
36075: EMPTY
36076: LIST
36077: LIST
36078: PUSH
36079: LD_INT 1
36081: NEG
36082: PUSH
36083: LD_INT 3
36085: NEG
36086: PUSH
36087: EMPTY
36088: LIST
36089: LIST
36090: PUSH
36091: LD_INT 3
36093: NEG
36094: PUSH
36095: LD_INT 1
36097: NEG
36098: PUSH
36099: EMPTY
36100: LIST
36101: LIST
36102: PUSH
36103: LD_INT 3
36105: NEG
36106: PUSH
36107: LD_INT 2
36109: NEG
36110: PUSH
36111: EMPTY
36112: LIST
36113: LIST
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: LIST
36122: LIST
36123: LIST
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: LIST
36133: LIST
36134: LIST
36135: LIST
36136: LIST
36137: LIST
36138: LIST
36139: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
36140: LD_ADDR_VAR 0 29
36144: PUSH
36145: LD_INT 0
36147: PUSH
36148: LD_INT 0
36150: PUSH
36151: EMPTY
36152: LIST
36153: LIST
36154: PUSH
36155: LD_INT 0
36157: PUSH
36158: LD_INT 1
36160: NEG
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PUSH
36166: LD_INT 1
36168: PUSH
36169: LD_INT 0
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PUSH
36176: LD_INT 1
36178: PUSH
36179: LD_INT 1
36181: PUSH
36182: EMPTY
36183: LIST
36184: LIST
36185: PUSH
36186: LD_INT 0
36188: PUSH
36189: LD_INT 1
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PUSH
36196: LD_INT 1
36198: NEG
36199: PUSH
36200: LD_INT 0
36202: PUSH
36203: EMPTY
36204: LIST
36205: LIST
36206: PUSH
36207: LD_INT 1
36209: NEG
36210: PUSH
36211: LD_INT 1
36213: NEG
36214: PUSH
36215: EMPTY
36216: LIST
36217: LIST
36218: PUSH
36219: LD_INT 1
36221: NEG
36222: PUSH
36223: LD_INT 2
36225: NEG
36226: PUSH
36227: EMPTY
36228: LIST
36229: LIST
36230: PUSH
36231: LD_INT 0
36233: PUSH
36234: LD_INT 2
36236: NEG
36237: PUSH
36238: EMPTY
36239: LIST
36240: LIST
36241: PUSH
36242: LD_INT 1
36244: PUSH
36245: LD_INT 1
36247: NEG
36248: PUSH
36249: EMPTY
36250: LIST
36251: LIST
36252: PUSH
36253: LD_INT 2
36255: PUSH
36256: LD_INT 0
36258: PUSH
36259: EMPTY
36260: LIST
36261: LIST
36262: PUSH
36263: LD_INT 2
36265: PUSH
36266: LD_INT 1
36268: PUSH
36269: EMPTY
36270: LIST
36271: LIST
36272: PUSH
36273: LD_INT 1
36275: PUSH
36276: LD_INT 2
36278: PUSH
36279: EMPTY
36280: LIST
36281: LIST
36282: PUSH
36283: LD_INT 0
36285: PUSH
36286: LD_INT 2
36288: PUSH
36289: EMPTY
36290: LIST
36291: LIST
36292: PUSH
36293: LD_INT 1
36295: NEG
36296: PUSH
36297: LD_INT 1
36299: PUSH
36300: EMPTY
36301: LIST
36302: LIST
36303: PUSH
36304: LD_INT 2
36306: NEG
36307: PUSH
36308: LD_INT 1
36310: NEG
36311: PUSH
36312: EMPTY
36313: LIST
36314: LIST
36315: PUSH
36316: LD_INT 2
36318: NEG
36319: PUSH
36320: LD_INT 2
36322: NEG
36323: PUSH
36324: EMPTY
36325: LIST
36326: LIST
36327: PUSH
36328: LD_INT 2
36330: NEG
36331: PUSH
36332: LD_INT 3
36334: NEG
36335: PUSH
36336: EMPTY
36337: LIST
36338: LIST
36339: PUSH
36340: LD_INT 2
36342: PUSH
36343: LD_INT 1
36345: NEG
36346: PUSH
36347: EMPTY
36348: LIST
36349: LIST
36350: PUSH
36351: LD_INT 3
36353: PUSH
36354: LD_INT 1
36356: PUSH
36357: EMPTY
36358: LIST
36359: LIST
36360: PUSH
36361: LD_INT 1
36363: PUSH
36364: LD_INT 3
36366: PUSH
36367: EMPTY
36368: LIST
36369: LIST
36370: PUSH
36371: LD_INT 1
36373: NEG
36374: PUSH
36375: LD_INT 2
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: PUSH
36382: LD_INT 3
36384: NEG
36385: PUSH
36386: LD_INT 2
36388: NEG
36389: PUSH
36390: EMPTY
36391: LIST
36392: LIST
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: LIST
36398: LIST
36399: LIST
36400: LIST
36401: LIST
36402: LIST
36403: LIST
36404: LIST
36405: LIST
36406: LIST
36407: LIST
36408: LIST
36409: LIST
36410: LIST
36411: LIST
36412: LIST
36413: LIST
36414: LIST
36415: LIST
36416: LIST
36417: LIST
36418: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36419: LD_ADDR_VAR 0 30
36423: PUSH
36424: LD_INT 0
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: EMPTY
36431: LIST
36432: LIST
36433: PUSH
36434: LD_INT 0
36436: PUSH
36437: LD_INT 1
36439: NEG
36440: PUSH
36441: EMPTY
36442: LIST
36443: LIST
36444: PUSH
36445: LD_INT 1
36447: PUSH
36448: LD_INT 0
36450: PUSH
36451: EMPTY
36452: LIST
36453: LIST
36454: PUSH
36455: LD_INT 1
36457: PUSH
36458: LD_INT 1
36460: PUSH
36461: EMPTY
36462: LIST
36463: LIST
36464: PUSH
36465: LD_INT 0
36467: PUSH
36468: LD_INT 1
36470: PUSH
36471: EMPTY
36472: LIST
36473: LIST
36474: PUSH
36475: LD_INT 1
36477: NEG
36478: PUSH
36479: LD_INT 0
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: PUSH
36486: LD_INT 1
36488: NEG
36489: PUSH
36490: LD_INT 1
36492: NEG
36493: PUSH
36494: EMPTY
36495: LIST
36496: LIST
36497: PUSH
36498: LD_INT 1
36500: NEG
36501: PUSH
36502: LD_INT 2
36504: NEG
36505: PUSH
36506: EMPTY
36507: LIST
36508: LIST
36509: PUSH
36510: LD_INT 0
36512: PUSH
36513: LD_INT 2
36515: NEG
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: PUSH
36521: LD_INT 1
36523: PUSH
36524: LD_INT 1
36526: NEG
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 2
36534: PUSH
36535: LD_INT 0
36537: PUSH
36538: EMPTY
36539: LIST
36540: LIST
36541: PUSH
36542: LD_INT 2
36544: PUSH
36545: LD_INT 1
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: LD_INT 2
36554: PUSH
36555: LD_INT 2
36557: PUSH
36558: EMPTY
36559: LIST
36560: LIST
36561: PUSH
36562: LD_INT 1
36564: PUSH
36565: LD_INT 2
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 1
36574: NEG
36575: PUSH
36576: LD_INT 1
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 2
36585: NEG
36586: PUSH
36587: LD_INT 0
36589: PUSH
36590: EMPTY
36591: LIST
36592: LIST
36593: PUSH
36594: LD_INT 2
36596: NEG
36597: PUSH
36598: LD_INT 1
36600: NEG
36601: PUSH
36602: EMPTY
36603: LIST
36604: LIST
36605: PUSH
36606: LD_INT 1
36608: NEG
36609: PUSH
36610: LD_INT 3
36612: NEG
36613: PUSH
36614: EMPTY
36615: LIST
36616: LIST
36617: PUSH
36618: LD_INT 1
36620: PUSH
36621: LD_INT 2
36623: NEG
36624: PUSH
36625: EMPTY
36626: LIST
36627: LIST
36628: PUSH
36629: LD_INT 3
36631: PUSH
36632: LD_INT 2
36634: PUSH
36635: EMPTY
36636: LIST
36637: LIST
36638: PUSH
36639: LD_INT 2
36641: PUSH
36642: LD_INT 3
36644: PUSH
36645: EMPTY
36646: LIST
36647: LIST
36648: PUSH
36649: LD_INT 2
36651: NEG
36652: PUSH
36653: LD_INT 1
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: PUSH
36660: LD_INT 3
36662: NEG
36663: PUSH
36664: LD_INT 1
36666: NEG
36667: PUSH
36668: EMPTY
36669: LIST
36670: LIST
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: LIST
36676: LIST
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: LIST
36687: LIST
36688: LIST
36689: LIST
36690: LIST
36691: LIST
36692: LIST
36693: LIST
36694: LIST
36695: LIST
36696: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
36697: LD_ADDR_VAR 0 31
36701: PUSH
36702: LD_INT 0
36704: PUSH
36705: LD_INT 0
36707: PUSH
36708: EMPTY
36709: LIST
36710: LIST
36711: PUSH
36712: LD_INT 0
36714: PUSH
36715: LD_INT 1
36717: NEG
36718: PUSH
36719: EMPTY
36720: LIST
36721: LIST
36722: PUSH
36723: LD_INT 1
36725: PUSH
36726: LD_INT 0
36728: PUSH
36729: EMPTY
36730: LIST
36731: LIST
36732: PUSH
36733: LD_INT 1
36735: PUSH
36736: LD_INT 1
36738: PUSH
36739: EMPTY
36740: LIST
36741: LIST
36742: PUSH
36743: LD_INT 0
36745: PUSH
36746: LD_INT 1
36748: PUSH
36749: EMPTY
36750: LIST
36751: LIST
36752: PUSH
36753: LD_INT 1
36755: NEG
36756: PUSH
36757: LD_INT 0
36759: PUSH
36760: EMPTY
36761: LIST
36762: LIST
36763: PUSH
36764: LD_INT 1
36766: NEG
36767: PUSH
36768: LD_INT 1
36770: NEG
36771: PUSH
36772: EMPTY
36773: LIST
36774: LIST
36775: PUSH
36776: LD_INT 1
36778: NEG
36779: PUSH
36780: LD_INT 2
36782: NEG
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PUSH
36788: LD_INT 1
36790: PUSH
36791: LD_INT 1
36793: NEG
36794: PUSH
36795: EMPTY
36796: LIST
36797: LIST
36798: PUSH
36799: LD_INT 2
36801: PUSH
36802: LD_INT 0
36804: PUSH
36805: EMPTY
36806: LIST
36807: LIST
36808: PUSH
36809: LD_INT 2
36811: PUSH
36812: LD_INT 1
36814: PUSH
36815: EMPTY
36816: LIST
36817: LIST
36818: PUSH
36819: LD_INT 2
36821: PUSH
36822: LD_INT 2
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PUSH
36829: LD_INT 1
36831: PUSH
36832: LD_INT 2
36834: PUSH
36835: EMPTY
36836: LIST
36837: LIST
36838: PUSH
36839: LD_INT 0
36841: PUSH
36842: LD_INT 2
36844: PUSH
36845: EMPTY
36846: LIST
36847: LIST
36848: PUSH
36849: LD_INT 1
36851: NEG
36852: PUSH
36853: LD_INT 1
36855: PUSH
36856: EMPTY
36857: LIST
36858: LIST
36859: PUSH
36860: LD_INT 2
36862: NEG
36863: PUSH
36864: LD_INT 1
36866: NEG
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PUSH
36872: LD_INT 2
36874: NEG
36875: PUSH
36876: LD_INT 2
36878: NEG
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PUSH
36884: LD_INT 2
36886: NEG
36887: PUSH
36888: LD_INT 3
36890: NEG
36891: PUSH
36892: EMPTY
36893: LIST
36894: LIST
36895: PUSH
36896: LD_INT 2
36898: PUSH
36899: LD_INT 1
36901: NEG
36902: PUSH
36903: EMPTY
36904: LIST
36905: LIST
36906: PUSH
36907: LD_INT 3
36909: PUSH
36910: LD_INT 1
36912: PUSH
36913: EMPTY
36914: LIST
36915: LIST
36916: PUSH
36917: LD_INT 1
36919: PUSH
36920: LD_INT 3
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PUSH
36927: LD_INT 1
36929: NEG
36930: PUSH
36931: LD_INT 2
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: LD_INT 3
36940: NEG
36941: PUSH
36942: LD_INT 2
36944: NEG
36945: PUSH
36946: EMPTY
36947: LIST
36948: LIST
36949: PUSH
36950: EMPTY
36951: LIST
36952: LIST
36953: LIST
36954: LIST
36955: LIST
36956: LIST
36957: LIST
36958: LIST
36959: LIST
36960: LIST
36961: LIST
36962: LIST
36963: LIST
36964: LIST
36965: LIST
36966: LIST
36967: LIST
36968: LIST
36969: LIST
36970: LIST
36971: LIST
36972: LIST
36973: LIST
36974: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36975: LD_ADDR_VAR 0 32
36979: PUSH
36980: LD_INT 0
36982: PUSH
36983: LD_INT 0
36985: PUSH
36986: EMPTY
36987: LIST
36988: LIST
36989: PUSH
36990: LD_INT 0
36992: PUSH
36993: LD_INT 1
36995: NEG
36996: PUSH
36997: EMPTY
36998: LIST
36999: LIST
37000: PUSH
37001: LD_INT 1
37003: PUSH
37004: LD_INT 0
37006: PUSH
37007: EMPTY
37008: LIST
37009: LIST
37010: PUSH
37011: LD_INT 1
37013: PUSH
37014: LD_INT 1
37016: PUSH
37017: EMPTY
37018: LIST
37019: LIST
37020: PUSH
37021: LD_INT 0
37023: PUSH
37024: LD_INT 1
37026: PUSH
37027: EMPTY
37028: LIST
37029: LIST
37030: PUSH
37031: LD_INT 1
37033: NEG
37034: PUSH
37035: LD_INT 0
37037: PUSH
37038: EMPTY
37039: LIST
37040: LIST
37041: PUSH
37042: LD_INT 1
37044: NEG
37045: PUSH
37046: LD_INT 1
37048: NEG
37049: PUSH
37050: EMPTY
37051: LIST
37052: LIST
37053: PUSH
37054: LD_INT 1
37056: NEG
37057: PUSH
37058: LD_INT 2
37060: NEG
37061: PUSH
37062: EMPTY
37063: LIST
37064: LIST
37065: PUSH
37066: LD_INT 0
37068: PUSH
37069: LD_INT 2
37071: NEG
37072: PUSH
37073: EMPTY
37074: LIST
37075: LIST
37076: PUSH
37077: LD_INT 1
37079: PUSH
37080: LD_INT 1
37082: NEG
37083: PUSH
37084: EMPTY
37085: LIST
37086: LIST
37087: PUSH
37088: LD_INT 2
37090: PUSH
37091: LD_INT 1
37093: PUSH
37094: EMPTY
37095: LIST
37096: LIST
37097: PUSH
37098: LD_INT 2
37100: PUSH
37101: LD_INT 2
37103: PUSH
37104: EMPTY
37105: LIST
37106: LIST
37107: PUSH
37108: LD_INT 1
37110: PUSH
37111: LD_INT 2
37113: PUSH
37114: EMPTY
37115: LIST
37116: LIST
37117: PUSH
37118: LD_INT 0
37120: PUSH
37121: LD_INT 2
37123: PUSH
37124: EMPTY
37125: LIST
37126: LIST
37127: PUSH
37128: LD_INT 1
37130: NEG
37131: PUSH
37132: LD_INT 1
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: PUSH
37139: LD_INT 2
37141: NEG
37142: PUSH
37143: LD_INT 0
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PUSH
37150: LD_INT 2
37152: NEG
37153: PUSH
37154: LD_INT 1
37156: NEG
37157: PUSH
37158: EMPTY
37159: LIST
37160: LIST
37161: PUSH
37162: LD_INT 1
37164: NEG
37165: PUSH
37166: LD_INT 3
37168: NEG
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 1
37176: PUSH
37177: LD_INT 2
37179: NEG
37180: PUSH
37181: EMPTY
37182: LIST
37183: LIST
37184: PUSH
37185: LD_INT 3
37187: PUSH
37188: LD_INT 2
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: LD_INT 2
37197: PUSH
37198: LD_INT 3
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: LD_INT 2
37207: NEG
37208: PUSH
37209: LD_INT 1
37211: PUSH
37212: EMPTY
37213: LIST
37214: LIST
37215: PUSH
37216: LD_INT 3
37218: NEG
37219: PUSH
37220: LD_INT 1
37222: NEG
37223: PUSH
37224: EMPTY
37225: LIST
37226: LIST
37227: PUSH
37228: EMPTY
37229: LIST
37230: LIST
37231: LIST
37232: LIST
37233: LIST
37234: LIST
37235: LIST
37236: LIST
37237: LIST
37238: LIST
37239: LIST
37240: LIST
37241: LIST
37242: LIST
37243: LIST
37244: LIST
37245: LIST
37246: LIST
37247: LIST
37248: LIST
37249: LIST
37250: LIST
37251: LIST
37252: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37253: LD_ADDR_VAR 0 33
37257: PUSH
37258: LD_INT 0
37260: PUSH
37261: LD_INT 0
37263: PUSH
37264: EMPTY
37265: LIST
37266: LIST
37267: PUSH
37268: LD_INT 0
37270: PUSH
37271: LD_INT 1
37273: NEG
37274: PUSH
37275: EMPTY
37276: LIST
37277: LIST
37278: PUSH
37279: LD_INT 1
37281: PUSH
37282: LD_INT 0
37284: PUSH
37285: EMPTY
37286: LIST
37287: LIST
37288: PUSH
37289: LD_INT 1
37291: PUSH
37292: LD_INT 1
37294: PUSH
37295: EMPTY
37296: LIST
37297: LIST
37298: PUSH
37299: LD_INT 0
37301: PUSH
37302: LD_INT 1
37304: PUSH
37305: EMPTY
37306: LIST
37307: LIST
37308: PUSH
37309: LD_INT 1
37311: NEG
37312: PUSH
37313: LD_INT 0
37315: PUSH
37316: EMPTY
37317: LIST
37318: LIST
37319: PUSH
37320: LD_INT 1
37322: NEG
37323: PUSH
37324: LD_INT 1
37326: NEG
37327: PUSH
37328: EMPTY
37329: LIST
37330: LIST
37331: PUSH
37332: LD_INT 1
37334: NEG
37335: PUSH
37336: LD_INT 2
37338: NEG
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: PUSH
37344: LD_INT 1
37346: PUSH
37347: LD_INT 1
37349: NEG
37350: PUSH
37351: EMPTY
37352: LIST
37353: LIST
37354: PUSH
37355: LD_INT 2
37357: PUSH
37358: LD_INT 0
37360: PUSH
37361: EMPTY
37362: LIST
37363: LIST
37364: PUSH
37365: LD_INT 2
37367: PUSH
37368: LD_INT 1
37370: PUSH
37371: EMPTY
37372: LIST
37373: LIST
37374: PUSH
37375: LD_INT 1
37377: PUSH
37378: LD_INT 2
37380: PUSH
37381: EMPTY
37382: LIST
37383: LIST
37384: PUSH
37385: LD_INT 0
37387: PUSH
37388: LD_INT 2
37390: PUSH
37391: EMPTY
37392: LIST
37393: LIST
37394: PUSH
37395: LD_INT 1
37397: NEG
37398: PUSH
37399: LD_INT 1
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: PUSH
37406: LD_INT 2
37408: NEG
37409: PUSH
37410: LD_INT 0
37412: PUSH
37413: EMPTY
37414: LIST
37415: LIST
37416: PUSH
37417: LD_INT 2
37419: NEG
37420: PUSH
37421: LD_INT 1
37423: NEG
37424: PUSH
37425: EMPTY
37426: LIST
37427: LIST
37428: PUSH
37429: LD_INT 2
37431: NEG
37432: PUSH
37433: LD_INT 2
37435: NEG
37436: PUSH
37437: EMPTY
37438: LIST
37439: LIST
37440: PUSH
37441: LD_INT 2
37443: NEG
37444: PUSH
37445: LD_INT 3
37447: NEG
37448: PUSH
37449: EMPTY
37450: LIST
37451: LIST
37452: PUSH
37453: LD_INT 2
37455: PUSH
37456: LD_INT 1
37458: NEG
37459: PUSH
37460: EMPTY
37461: LIST
37462: LIST
37463: PUSH
37464: LD_INT 3
37466: PUSH
37467: LD_INT 1
37469: PUSH
37470: EMPTY
37471: LIST
37472: LIST
37473: PUSH
37474: LD_INT 1
37476: PUSH
37477: LD_INT 3
37479: PUSH
37480: EMPTY
37481: LIST
37482: LIST
37483: PUSH
37484: LD_INT 1
37486: NEG
37487: PUSH
37488: LD_INT 2
37490: PUSH
37491: EMPTY
37492: LIST
37493: LIST
37494: PUSH
37495: LD_INT 3
37497: NEG
37498: PUSH
37499: LD_INT 2
37501: NEG
37502: PUSH
37503: EMPTY
37504: LIST
37505: LIST
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: LIST
37511: LIST
37512: LIST
37513: LIST
37514: LIST
37515: LIST
37516: LIST
37517: LIST
37518: LIST
37519: LIST
37520: LIST
37521: LIST
37522: LIST
37523: LIST
37524: LIST
37525: LIST
37526: LIST
37527: LIST
37528: LIST
37529: LIST
37530: LIST
37531: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37532: LD_ADDR_VAR 0 34
37536: PUSH
37537: LD_INT 0
37539: PUSH
37540: LD_INT 0
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: LD_INT 0
37549: PUSH
37550: LD_INT 1
37552: NEG
37553: PUSH
37554: EMPTY
37555: LIST
37556: LIST
37557: PUSH
37558: LD_INT 1
37560: PUSH
37561: LD_INT 0
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 1
37570: PUSH
37571: LD_INT 1
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: LD_INT 0
37580: PUSH
37581: LD_INT 1
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: PUSH
37588: LD_INT 1
37590: NEG
37591: PUSH
37592: LD_INT 0
37594: PUSH
37595: EMPTY
37596: LIST
37597: LIST
37598: PUSH
37599: LD_INT 1
37601: NEG
37602: PUSH
37603: LD_INT 1
37605: NEG
37606: PUSH
37607: EMPTY
37608: LIST
37609: LIST
37610: PUSH
37611: LD_INT 1
37613: NEG
37614: PUSH
37615: LD_INT 2
37617: NEG
37618: PUSH
37619: EMPTY
37620: LIST
37621: LIST
37622: PUSH
37623: LD_INT 0
37625: PUSH
37626: LD_INT 2
37628: NEG
37629: PUSH
37630: EMPTY
37631: LIST
37632: LIST
37633: PUSH
37634: LD_INT 1
37636: PUSH
37637: LD_INT 1
37639: NEG
37640: PUSH
37641: EMPTY
37642: LIST
37643: LIST
37644: PUSH
37645: LD_INT 2
37647: PUSH
37648: LD_INT 1
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PUSH
37655: LD_INT 2
37657: PUSH
37658: LD_INT 2
37660: PUSH
37661: EMPTY
37662: LIST
37663: LIST
37664: PUSH
37665: LD_INT 1
37667: PUSH
37668: LD_INT 2
37670: PUSH
37671: EMPTY
37672: LIST
37673: LIST
37674: PUSH
37675: LD_INT 1
37677: NEG
37678: PUSH
37679: LD_INT 1
37681: PUSH
37682: EMPTY
37683: LIST
37684: LIST
37685: PUSH
37686: LD_INT 2
37688: NEG
37689: PUSH
37690: LD_INT 0
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: PUSH
37697: LD_INT 2
37699: NEG
37700: PUSH
37701: LD_INT 1
37703: NEG
37704: PUSH
37705: EMPTY
37706: LIST
37707: LIST
37708: PUSH
37709: LD_INT 2
37711: NEG
37712: PUSH
37713: LD_INT 2
37715: NEG
37716: PUSH
37717: EMPTY
37718: LIST
37719: LIST
37720: PUSH
37721: LD_INT 1
37723: NEG
37724: PUSH
37725: LD_INT 3
37727: NEG
37728: PUSH
37729: EMPTY
37730: LIST
37731: LIST
37732: PUSH
37733: LD_INT 1
37735: PUSH
37736: LD_INT 2
37738: NEG
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PUSH
37744: LD_INT 3
37746: PUSH
37747: LD_INT 2
37749: PUSH
37750: EMPTY
37751: LIST
37752: LIST
37753: PUSH
37754: LD_INT 2
37756: PUSH
37757: LD_INT 3
37759: PUSH
37760: EMPTY
37761: LIST
37762: LIST
37763: PUSH
37764: LD_INT 2
37766: NEG
37767: PUSH
37768: LD_INT 1
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 3
37777: NEG
37778: PUSH
37779: LD_INT 1
37781: NEG
37782: PUSH
37783: EMPTY
37784: LIST
37785: LIST
37786: PUSH
37787: EMPTY
37788: LIST
37789: LIST
37790: LIST
37791: LIST
37792: LIST
37793: LIST
37794: LIST
37795: LIST
37796: LIST
37797: LIST
37798: LIST
37799: LIST
37800: LIST
37801: LIST
37802: LIST
37803: LIST
37804: LIST
37805: LIST
37806: LIST
37807: LIST
37808: LIST
37809: LIST
37810: LIST
37811: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
37812: LD_ADDR_VAR 0 35
37816: PUSH
37817: LD_INT 0
37819: PUSH
37820: LD_INT 0
37822: PUSH
37823: EMPTY
37824: LIST
37825: LIST
37826: PUSH
37827: LD_INT 0
37829: PUSH
37830: LD_INT 1
37832: NEG
37833: PUSH
37834: EMPTY
37835: LIST
37836: LIST
37837: PUSH
37838: LD_INT 1
37840: PUSH
37841: LD_INT 0
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: PUSH
37848: LD_INT 1
37850: PUSH
37851: LD_INT 1
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: PUSH
37858: LD_INT 0
37860: PUSH
37861: LD_INT 1
37863: PUSH
37864: EMPTY
37865: LIST
37866: LIST
37867: PUSH
37868: LD_INT 1
37870: NEG
37871: PUSH
37872: LD_INT 0
37874: PUSH
37875: EMPTY
37876: LIST
37877: LIST
37878: PUSH
37879: LD_INT 1
37881: NEG
37882: PUSH
37883: LD_INT 1
37885: NEG
37886: PUSH
37887: EMPTY
37888: LIST
37889: LIST
37890: PUSH
37891: LD_INT 2
37893: PUSH
37894: LD_INT 1
37896: PUSH
37897: EMPTY
37898: LIST
37899: LIST
37900: PUSH
37901: LD_INT 2
37903: NEG
37904: PUSH
37905: LD_INT 1
37907: NEG
37908: PUSH
37909: EMPTY
37910: LIST
37911: LIST
37912: PUSH
37913: EMPTY
37914: LIST
37915: LIST
37916: LIST
37917: LIST
37918: LIST
37919: LIST
37920: LIST
37921: LIST
37922: LIST
37923: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
37924: LD_ADDR_VAR 0 36
37928: PUSH
37929: LD_INT 0
37931: PUSH
37932: LD_INT 0
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: LD_INT 0
37941: PUSH
37942: LD_INT 1
37944: NEG
37945: PUSH
37946: EMPTY
37947: LIST
37948: LIST
37949: PUSH
37950: LD_INT 1
37952: PUSH
37953: LD_INT 0
37955: PUSH
37956: EMPTY
37957: LIST
37958: LIST
37959: PUSH
37960: LD_INT 1
37962: PUSH
37963: LD_INT 1
37965: PUSH
37966: EMPTY
37967: LIST
37968: LIST
37969: PUSH
37970: LD_INT 0
37972: PUSH
37973: LD_INT 1
37975: PUSH
37976: EMPTY
37977: LIST
37978: LIST
37979: PUSH
37980: LD_INT 1
37982: NEG
37983: PUSH
37984: LD_INT 0
37986: PUSH
37987: EMPTY
37988: LIST
37989: LIST
37990: PUSH
37991: LD_INT 1
37993: NEG
37994: PUSH
37995: LD_INT 1
37997: NEG
37998: PUSH
37999: EMPTY
38000: LIST
38001: LIST
38002: PUSH
38003: LD_INT 1
38005: NEG
38006: PUSH
38007: LD_INT 2
38009: NEG
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 1
38017: PUSH
38018: LD_INT 2
38020: PUSH
38021: EMPTY
38022: LIST
38023: LIST
38024: PUSH
38025: EMPTY
38026: LIST
38027: LIST
38028: LIST
38029: LIST
38030: LIST
38031: LIST
38032: LIST
38033: LIST
38034: LIST
38035: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
38036: LD_ADDR_VAR 0 37
38040: PUSH
38041: LD_INT 0
38043: PUSH
38044: LD_INT 0
38046: PUSH
38047: EMPTY
38048: LIST
38049: LIST
38050: PUSH
38051: LD_INT 0
38053: PUSH
38054: LD_INT 1
38056: NEG
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: PUSH
38062: LD_INT 1
38064: PUSH
38065: LD_INT 0
38067: PUSH
38068: EMPTY
38069: LIST
38070: LIST
38071: PUSH
38072: LD_INT 1
38074: PUSH
38075: LD_INT 1
38077: PUSH
38078: EMPTY
38079: LIST
38080: LIST
38081: PUSH
38082: LD_INT 0
38084: PUSH
38085: LD_INT 1
38087: PUSH
38088: EMPTY
38089: LIST
38090: LIST
38091: PUSH
38092: LD_INT 1
38094: NEG
38095: PUSH
38096: LD_INT 0
38098: PUSH
38099: EMPTY
38100: LIST
38101: LIST
38102: PUSH
38103: LD_INT 1
38105: NEG
38106: PUSH
38107: LD_INT 1
38109: NEG
38110: PUSH
38111: EMPTY
38112: LIST
38113: LIST
38114: PUSH
38115: LD_INT 1
38117: PUSH
38118: LD_INT 1
38120: NEG
38121: PUSH
38122: EMPTY
38123: LIST
38124: LIST
38125: PUSH
38126: LD_INT 1
38128: NEG
38129: PUSH
38130: LD_INT 1
38132: PUSH
38133: EMPTY
38134: LIST
38135: LIST
38136: PUSH
38137: EMPTY
38138: LIST
38139: LIST
38140: LIST
38141: LIST
38142: LIST
38143: LIST
38144: LIST
38145: LIST
38146: LIST
38147: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
38148: LD_ADDR_VAR 0 38
38152: PUSH
38153: LD_INT 0
38155: PUSH
38156: LD_INT 0
38158: PUSH
38159: EMPTY
38160: LIST
38161: LIST
38162: PUSH
38163: LD_INT 0
38165: PUSH
38166: LD_INT 1
38168: NEG
38169: PUSH
38170: EMPTY
38171: LIST
38172: LIST
38173: PUSH
38174: LD_INT 1
38176: PUSH
38177: LD_INT 0
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: PUSH
38184: LD_INT 1
38186: PUSH
38187: LD_INT 1
38189: PUSH
38190: EMPTY
38191: LIST
38192: LIST
38193: PUSH
38194: LD_INT 0
38196: PUSH
38197: LD_INT 1
38199: PUSH
38200: EMPTY
38201: LIST
38202: LIST
38203: PUSH
38204: LD_INT 1
38206: NEG
38207: PUSH
38208: LD_INT 0
38210: PUSH
38211: EMPTY
38212: LIST
38213: LIST
38214: PUSH
38215: LD_INT 1
38217: NEG
38218: PUSH
38219: LD_INT 1
38221: NEG
38222: PUSH
38223: EMPTY
38224: LIST
38225: LIST
38226: PUSH
38227: LD_INT 2
38229: PUSH
38230: LD_INT 1
38232: PUSH
38233: EMPTY
38234: LIST
38235: LIST
38236: PUSH
38237: LD_INT 2
38239: NEG
38240: PUSH
38241: LD_INT 1
38243: NEG
38244: PUSH
38245: EMPTY
38246: LIST
38247: LIST
38248: PUSH
38249: EMPTY
38250: LIST
38251: LIST
38252: LIST
38253: LIST
38254: LIST
38255: LIST
38256: LIST
38257: LIST
38258: LIST
38259: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
38260: LD_ADDR_VAR 0 39
38264: PUSH
38265: LD_INT 0
38267: PUSH
38268: LD_INT 0
38270: PUSH
38271: EMPTY
38272: LIST
38273: LIST
38274: PUSH
38275: LD_INT 0
38277: PUSH
38278: LD_INT 1
38280: NEG
38281: PUSH
38282: EMPTY
38283: LIST
38284: LIST
38285: PUSH
38286: LD_INT 1
38288: PUSH
38289: LD_INT 0
38291: PUSH
38292: EMPTY
38293: LIST
38294: LIST
38295: PUSH
38296: LD_INT 1
38298: PUSH
38299: LD_INT 1
38301: PUSH
38302: EMPTY
38303: LIST
38304: LIST
38305: PUSH
38306: LD_INT 0
38308: PUSH
38309: LD_INT 1
38311: PUSH
38312: EMPTY
38313: LIST
38314: LIST
38315: PUSH
38316: LD_INT 1
38318: NEG
38319: PUSH
38320: LD_INT 0
38322: PUSH
38323: EMPTY
38324: LIST
38325: LIST
38326: PUSH
38327: LD_INT 1
38329: NEG
38330: PUSH
38331: LD_INT 1
38333: NEG
38334: PUSH
38335: EMPTY
38336: LIST
38337: LIST
38338: PUSH
38339: LD_INT 1
38341: NEG
38342: PUSH
38343: LD_INT 2
38345: NEG
38346: PUSH
38347: EMPTY
38348: LIST
38349: LIST
38350: PUSH
38351: LD_INT 1
38353: PUSH
38354: LD_INT 2
38356: PUSH
38357: EMPTY
38358: LIST
38359: LIST
38360: PUSH
38361: EMPTY
38362: LIST
38363: LIST
38364: LIST
38365: LIST
38366: LIST
38367: LIST
38368: LIST
38369: LIST
38370: LIST
38371: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
38372: LD_ADDR_VAR 0 40
38376: PUSH
38377: LD_INT 0
38379: PUSH
38380: LD_INT 0
38382: PUSH
38383: EMPTY
38384: LIST
38385: LIST
38386: PUSH
38387: LD_INT 0
38389: PUSH
38390: LD_INT 1
38392: NEG
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: LD_INT 1
38400: PUSH
38401: LD_INT 0
38403: PUSH
38404: EMPTY
38405: LIST
38406: LIST
38407: PUSH
38408: LD_INT 1
38410: PUSH
38411: LD_INT 1
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 0
38420: PUSH
38421: LD_INT 1
38423: PUSH
38424: EMPTY
38425: LIST
38426: LIST
38427: PUSH
38428: LD_INT 1
38430: NEG
38431: PUSH
38432: LD_INT 0
38434: PUSH
38435: EMPTY
38436: LIST
38437: LIST
38438: PUSH
38439: LD_INT 1
38441: NEG
38442: PUSH
38443: LD_INT 1
38445: NEG
38446: PUSH
38447: EMPTY
38448: LIST
38449: LIST
38450: PUSH
38451: LD_INT 1
38453: PUSH
38454: LD_INT 1
38456: NEG
38457: PUSH
38458: EMPTY
38459: LIST
38460: LIST
38461: PUSH
38462: LD_INT 1
38464: NEG
38465: PUSH
38466: LD_INT 1
38468: PUSH
38469: EMPTY
38470: LIST
38471: LIST
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: LIST
38477: LIST
38478: LIST
38479: LIST
38480: LIST
38481: LIST
38482: LIST
38483: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38484: LD_ADDR_VAR 0 41
38488: PUSH
38489: LD_INT 0
38491: PUSH
38492: LD_INT 0
38494: PUSH
38495: EMPTY
38496: LIST
38497: LIST
38498: PUSH
38499: LD_INT 0
38501: PUSH
38502: LD_INT 1
38504: NEG
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 1
38512: PUSH
38513: LD_INT 0
38515: PUSH
38516: EMPTY
38517: LIST
38518: LIST
38519: PUSH
38520: LD_INT 1
38522: PUSH
38523: LD_INT 1
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: LD_INT 0
38532: PUSH
38533: LD_INT 1
38535: PUSH
38536: EMPTY
38537: LIST
38538: LIST
38539: PUSH
38540: LD_INT 1
38542: NEG
38543: PUSH
38544: LD_INT 0
38546: PUSH
38547: EMPTY
38548: LIST
38549: LIST
38550: PUSH
38551: LD_INT 1
38553: NEG
38554: PUSH
38555: LD_INT 1
38557: NEG
38558: PUSH
38559: EMPTY
38560: LIST
38561: LIST
38562: PUSH
38563: LD_INT 1
38565: NEG
38566: PUSH
38567: LD_INT 2
38569: NEG
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: PUSH
38575: LD_INT 1
38577: PUSH
38578: LD_INT 1
38580: NEG
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 2
38588: PUSH
38589: LD_INT 0
38591: PUSH
38592: EMPTY
38593: LIST
38594: LIST
38595: PUSH
38596: LD_INT 2
38598: PUSH
38599: LD_INT 1
38601: PUSH
38602: EMPTY
38603: LIST
38604: LIST
38605: PUSH
38606: LD_INT 2
38608: PUSH
38609: LD_INT 2
38611: PUSH
38612: EMPTY
38613: LIST
38614: LIST
38615: PUSH
38616: LD_INT 1
38618: PUSH
38619: LD_INT 2
38621: PUSH
38622: EMPTY
38623: LIST
38624: LIST
38625: PUSH
38626: LD_INT 1
38628: NEG
38629: PUSH
38630: LD_INT 1
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 2
38639: NEG
38640: PUSH
38641: LD_INT 0
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: LD_INT 2
38650: NEG
38651: PUSH
38652: LD_INT 1
38654: NEG
38655: PUSH
38656: EMPTY
38657: LIST
38658: LIST
38659: PUSH
38660: LD_INT 2
38662: NEG
38663: PUSH
38664: LD_INT 2
38666: NEG
38667: PUSH
38668: EMPTY
38669: LIST
38670: LIST
38671: PUSH
38672: LD_INT 2
38674: NEG
38675: PUSH
38676: LD_INT 3
38678: NEG
38679: PUSH
38680: EMPTY
38681: LIST
38682: LIST
38683: PUSH
38684: LD_INT 2
38686: PUSH
38687: LD_INT 1
38689: NEG
38690: PUSH
38691: EMPTY
38692: LIST
38693: LIST
38694: PUSH
38695: LD_INT 3
38697: PUSH
38698: LD_INT 0
38700: PUSH
38701: EMPTY
38702: LIST
38703: LIST
38704: PUSH
38705: LD_INT 3
38707: PUSH
38708: LD_INT 1
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 3
38717: PUSH
38718: LD_INT 2
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: PUSH
38725: LD_INT 3
38727: PUSH
38728: LD_INT 3
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: PUSH
38735: LD_INT 2
38737: PUSH
38738: LD_INT 3
38740: PUSH
38741: EMPTY
38742: LIST
38743: LIST
38744: PUSH
38745: LD_INT 2
38747: NEG
38748: PUSH
38749: LD_INT 1
38751: PUSH
38752: EMPTY
38753: LIST
38754: LIST
38755: PUSH
38756: LD_INT 3
38758: NEG
38759: PUSH
38760: LD_INT 0
38762: PUSH
38763: EMPTY
38764: LIST
38765: LIST
38766: PUSH
38767: LD_INT 3
38769: NEG
38770: PUSH
38771: LD_INT 1
38773: NEG
38774: PUSH
38775: EMPTY
38776: LIST
38777: LIST
38778: PUSH
38779: LD_INT 3
38781: NEG
38782: PUSH
38783: LD_INT 2
38785: NEG
38786: PUSH
38787: EMPTY
38788: LIST
38789: LIST
38790: PUSH
38791: LD_INT 3
38793: NEG
38794: PUSH
38795: LD_INT 3
38797: NEG
38798: PUSH
38799: EMPTY
38800: LIST
38801: LIST
38802: PUSH
38803: EMPTY
38804: LIST
38805: LIST
38806: LIST
38807: LIST
38808: LIST
38809: LIST
38810: LIST
38811: LIST
38812: LIST
38813: LIST
38814: LIST
38815: LIST
38816: LIST
38817: LIST
38818: LIST
38819: LIST
38820: LIST
38821: LIST
38822: LIST
38823: LIST
38824: LIST
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: LIST
38833: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38834: LD_ADDR_VAR 0 42
38838: PUSH
38839: LD_INT 0
38841: PUSH
38842: LD_INT 0
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: PUSH
38849: LD_INT 0
38851: PUSH
38852: LD_INT 1
38854: NEG
38855: PUSH
38856: EMPTY
38857: LIST
38858: LIST
38859: PUSH
38860: LD_INT 1
38862: PUSH
38863: LD_INT 0
38865: PUSH
38866: EMPTY
38867: LIST
38868: LIST
38869: PUSH
38870: LD_INT 1
38872: PUSH
38873: LD_INT 1
38875: PUSH
38876: EMPTY
38877: LIST
38878: LIST
38879: PUSH
38880: LD_INT 0
38882: PUSH
38883: LD_INT 1
38885: PUSH
38886: EMPTY
38887: LIST
38888: LIST
38889: PUSH
38890: LD_INT 1
38892: NEG
38893: PUSH
38894: LD_INT 0
38896: PUSH
38897: EMPTY
38898: LIST
38899: LIST
38900: PUSH
38901: LD_INT 1
38903: NEG
38904: PUSH
38905: LD_INT 1
38907: NEG
38908: PUSH
38909: EMPTY
38910: LIST
38911: LIST
38912: PUSH
38913: LD_INT 1
38915: NEG
38916: PUSH
38917: LD_INT 2
38919: NEG
38920: PUSH
38921: EMPTY
38922: LIST
38923: LIST
38924: PUSH
38925: LD_INT 0
38927: PUSH
38928: LD_INT 2
38930: NEG
38931: PUSH
38932: EMPTY
38933: LIST
38934: LIST
38935: PUSH
38936: LD_INT 1
38938: PUSH
38939: LD_INT 1
38941: NEG
38942: PUSH
38943: EMPTY
38944: LIST
38945: LIST
38946: PUSH
38947: LD_INT 2
38949: PUSH
38950: LD_INT 1
38952: PUSH
38953: EMPTY
38954: LIST
38955: LIST
38956: PUSH
38957: LD_INT 2
38959: PUSH
38960: LD_INT 2
38962: PUSH
38963: EMPTY
38964: LIST
38965: LIST
38966: PUSH
38967: LD_INT 1
38969: PUSH
38970: LD_INT 2
38972: PUSH
38973: EMPTY
38974: LIST
38975: LIST
38976: PUSH
38977: LD_INT 0
38979: PUSH
38980: LD_INT 2
38982: PUSH
38983: EMPTY
38984: LIST
38985: LIST
38986: PUSH
38987: LD_INT 1
38989: NEG
38990: PUSH
38991: LD_INT 1
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 2
39000: NEG
39001: PUSH
39002: LD_INT 1
39004: NEG
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: PUSH
39010: LD_INT 2
39012: NEG
39013: PUSH
39014: LD_INT 2
39016: NEG
39017: PUSH
39018: EMPTY
39019: LIST
39020: LIST
39021: PUSH
39022: LD_INT 2
39024: NEG
39025: PUSH
39026: LD_INT 3
39028: NEG
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: PUSH
39034: LD_INT 1
39036: NEG
39037: PUSH
39038: LD_INT 3
39040: NEG
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: LD_INT 0
39048: PUSH
39049: LD_INT 3
39051: NEG
39052: PUSH
39053: EMPTY
39054: LIST
39055: LIST
39056: PUSH
39057: LD_INT 1
39059: PUSH
39060: LD_INT 2
39062: NEG
39063: PUSH
39064: EMPTY
39065: LIST
39066: LIST
39067: PUSH
39068: LD_INT 3
39070: PUSH
39071: LD_INT 2
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 3
39080: PUSH
39081: LD_INT 3
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: LD_INT 2
39090: PUSH
39091: LD_INT 3
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: PUSH
39098: LD_INT 1
39100: PUSH
39101: LD_INT 3
39103: PUSH
39104: EMPTY
39105: LIST
39106: LIST
39107: PUSH
39108: LD_INT 0
39110: PUSH
39111: LD_INT 3
39113: PUSH
39114: EMPTY
39115: LIST
39116: LIST
39117: PUSH
39118: LD_INT 1
39120: NEG
39121: PUSH
39122: LD_INT 2
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: LD_INT 3
39131: NEG
39132: PUSH
39133: LD_INT 2
39135: NEG
39136: PUSH
39137: EMPTY
39138: LIST
39139: LIST
39140: PUSH
39141: LD_INT 3
39143: NEG
39144: PUSH
39145: LD_INT 3
39147: NEG
39148: PUSH
39149: EMPTY
39150: LIST
39151: LIST
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: LIST
39157: LIST
39158: LIST
39159: LIST
39160: LIST
39161: LIST
39162: LIST
39163: LIST
39164: LIST
39165: LIST
39166: LIST
39167: LIST
39168: LIST
39169: LIST
39170: LIST
39171: LIST
39172: LIST
39173: LIST
39174: LIST
39175: LIST
39176: LIST
39177: LIST
39178: LIST
39179: LIST
39180: LIST
39181: LIST
39182: LIST
39183: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39184: LD_ADDR_VAR 0 43
39188: PUSH
39189: LD_INT 0
39191: PUSH
39192: LD_INT 0
39194: PUSH
39195: EMPTY
39196: LIST
39197: LIST
39198: PUSH
39199: LD_INT 0
39201: PUSH
39202: LD_INT 1
39204: NEG
39205: PUSH
39206: EMPTY
39207: LIST
39208: LIST
39209: PUSH
39210: LD_INT 1
39212: PUSH
39213: LD_INT 0
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: PUSH
39220: LD_INT 1
39222: PUSH
39223: LD_INT 1
39225: PUSH
39226: EMPTY
39227: LIST
39228: LIST
39229: PUSH
39230: LD_INT 0
39232: PUSH
39233: LD_INT 1
39235: PUSH
39236: EMPTY
39237: LIST
39238: LIST
39239: PUSH
39240: LD_INT 1
39242: NEG
39243: PUSH
39244: LD_INT 0
39246: PUSH
39247: EMPTY
39248: LIST
39249: LIST
39250: PUSH
39251: LD_INT 1
39253: NEG
39254: PUSH
39255: LD_INT 1
39257: NEG
39258: PUSH
39259: EMPTY
39260: LIST
39261: LIST
39262: PUSH
39263: LD_INT 1
39265: NEG
39266: PUSH
39267: LD_INT 2
39269: NEG
39270: PUSH
39271: EMPTY
39272: LIST
39273: LIST
39274: PUSH
39275: LD_INT 0
39277: PUSH
39278: LD_INT 2
39280: NEG
39281: PUSH
39282: EMPTY
39283: LIST
39284: LIST
39285: PUSH
39286: LD_INT 1
39288: PUSH
39289: LD_INT 1
39291: NEG
39292: PUSH
39293: EMPTY
39294: LIST
39295: LIST
39296: PUSH
39297: LD_INT 2
39299: PUSH
39300: LD_INT 0
39302: PUSH
39303: EMPTY
39304: LIST
39305: LIST
39306: PUSH
39307: LD_INT 2
39309: PUSH
39310: LD_INT 1
39312: PUSH
39313: EMPTY
39314: LIST
39315: LIST
39316: PUSH
39317: LD_INT 1
39319: PUSH
39320: LD_INT 2
39322: PUSH
39323: EMPTY
39324: LIST
39325: LIST
39326: PUSH
39327: LD_INT 0
39329: PUSH
39330: LD_INT 2
39332: PUSH
39333: EMPTY
39334: LIST
39335: LIST
39336: PUSH
39337: LD_INT 1
39339: NEG
39340: PUSH
39341: LD_INT 1
39343: PUSH
39344: EMPTY
39345: LIST
39346: LIST
39347: PUSH
39348: LD_INT 2
39350: NEG
39351: PUSH
39352: LD_INT 0
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PUSH
39359: LD_INT 2
39361: NEG
39362: PUSH
39363: LD_INT 1
39365: NEG
39366: PUSH
39367: EMPTY
39368: LIST
39369: LIST
39370: PUSH
39371: LD_INT 1
39373: NEG
39374: PUSH
39375: LD_INT 3
39377: NEG
39378: PUSH
39379: EMPTY
39380: LIST
39381: LIST
39382: PUSH
39383: LD_INT 0
39385: PUSH
39386: LD_INT 3
39388: NEG
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 1
39396: PUSH
39397: LD_INT 2
39399: NEG
39400: PUSH
39401: EMPTY
39402: LIST
39403: LIST
39404: PUSH
39405: LD_INT 2
39407: PUSH
39408: LD_INT 1
39410: NEG
39411: PUSH
39412: EMPTY
39413: LIST
39414: LIST
39415: PUSH
39416: LD_INT 3
39418: PUSH
39419: LD_INT 0
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: PUSH
39426: LD_INT 3
39428: PUSH
39429: LD_INT 1
39431: PUSH
39432: EMPTY
39433: LIST
39434: LIST
39435: PUSH
39436: LD_INT 1
39438: PUSH
39439: LD_INT 3
39441: PUSH
39442: EMPTY
39443: LIST
39444: LIST
39445: PUSH
39446: LD_INT 0
39448: PUSH
39449: LD_INT 3
39451: PUSH
39452: EMPTY
39453: LIST
39454: LIST
39455: PUSH
39456: LD_INT 1
39458: NEG
39459: PUSH
39460: LD_INT 2
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PUSH
39467: LD_INT 2
39469: NEG
39470: PUSH
39471: LD_INT 1
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: PUSH
39478: LD_INT 3
39480: NEG
39481: PUSH
39482: LD_INT 0
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: LD_INT 3
39491: NEG
39492: PUSH
39493: LD_INT 1
39495: NEG
39496: PUSH
39497: EMPTY
39498: LIST
39499: LIST
39500: PUSH
39501: EMPTY
39502: LIST
39503: LIST
39504: LIST
39505: LIST
39506: LIST
39507: LIST
39508: LIST
39509: LIST
39510: LIST
39511: LIST
39512: LIST
39513: LIST
39514: LIST
39515: LIST
39516: LIST
39517: LIST
39518: LIST
39519: LIST
39520: LIST
39521: LIST
39522: LIST
39523: LIST
39524: LIST
39525: LIST
39526: LIST
39527: LIST
39528: LIST
39529: LIST
39530: LIST
39531: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39532: LD_ADDR_VAR 0 44
39536: PUSH
39537: LD_INT 0
39539: PUSH
39540: LD_INT 0
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: PUSH
39547: LD_INT 0
39549: PUSH
39550: LD_INT 1
39552: NEG
39553: PUSH
39554: EMPTY
39555: LIST
39556: LIST
39557: PUSH
39558: LD_INT 1
39560: PUSH
39561: LD_INT 0
39563: PUSH
39564: EMPTY
39565: LIST
39566: LIST
39567: PUSH
39568: LD_INT 1
39570: PUSH
39571: LD_INT 1
39573: PUSH
39574: EMPTY
39575: LIST
39576: LIST
39577: PUSH
39578: LD_INT 0
39580: PUSH
39581: LD_INT 1
39583: PUSH
39584: EMPTY
39585: LIST
39586: LIST
39587: PUSH
39588: LD_INT 1
39590: NEG
39591: PUSH
39592: LD_INT 0
39594: PUSH
39595: EMPTY
39596: LIST
39597: LIST
39598: PUSH
39599: LD_INT 1
39601: NEG
39602: PUSH
39603: LD_INT 1
39605: NEG
39606: PUSH
39607: EMPTY
39608: LIST
39609: LIST
39610: PUSH
39611: LD_INT 1
39613: NEG
39614: PUSH
39615: LD_INT 2
39617: NEG
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 1
39625: PUSH
39626: LD_INT 1
39628: NEG
39629: PUSH
39630: EMPTY
39631: LIST
39632: LIST
39633: PUSH
39634: LD_INT 2
39636: PUSH
39637: LD_INT 0
39639: PUSH
39640: EMPTY
39641: LIST
39642: LIST
39643: PUSH
39644: LD_INT 2
39646: PUSH
39647: LD_INT 1
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PUSH
39654: LD_INT 2
39656: PUSH
39657: LD_INT 2
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: PUSH
39664: LD_INT 1
39666: PUSH
39667: LD_INT 2
39669: PUSH
39670: EMPTY
39671: LIST
39672: LIST
39673: PUSH
39674: LD_INT 1
39676: NEG
39677: PUSH
39678: LD_INT 1
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 2
39687: NEG
39688: PUSH
39689: LD_INT 0
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: PUSH
39696: LD_INT 2
39698: NEG
39699: PUSH
39700: LD_INT 1
39702: NEG
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PUSH
39708: LD_INT 2
39710: NEG
39711: PUSH
39712: LD_INT 2
39714: NEG
39715: PUSH
39716: EMPTY
39717: LIST
39718: LIST
39719: PUSH
39720: LD_INT 2
39722: NEG
39723: PUSH
39724: LD_INT 3
39726: NEG
39727: PUSH
39728: EMPTY
39729: LIST
39730: LIST
39731: PUSH
39732: LD_INT 2
39734: PUSH
39735: LD_INT 1
39737: NEG
39738: PUSH
39739: EMPTY
39740: LIST
39741: LIST
39742: PUSH
39743: LD_INT 3
39745: PUSH
39746: LD_INT 0
39748: PUSH
39749: EMPTY
39750: LIST
39751: LIST
39752: PUSH
39753: LD_INT 3
39755: PUSH
39756: LD_INT 1
39758: PUSH
39759: EMPTY
39760: LIST
39761: LIST
39762: PUSH
39763: LD_INT 3
39765: PUSH
39766: LD_INT 2
39768: PUSH
39769: EMPTY
39770: LIST
39771: LIST
39772: PUSH
39773: LD_INT 3
39775: PUSH
39776: LD_INT 3
39778: PUSH
39779: EMPTY
39780: LIST
39781: LIST
39782: PUSH
39783: LD_INT 2
39785: PUSH
39786: LD_INT 3
39788: PUSH
39789: EMPTY
39790: LIST
39791: LIST
39792: PUSH
39793: LD_INT 2
39795: NEG
39796: PUSH
39797: LD_INT 1
39799: PUSH
39800: EMPTY
39801: LIST
39802: LIST
39803: PUSH
39804: LD_INT 3
39806: NEG
39807: PUSH
39808: LD_INT 0
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: LD_INT 3
39817: NEG
39818: PUSH
39819: LD_INT 1
39821: NEG
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 3
39829: NEG
39830: PUSH
39831: LD_INT 2
39833: NEG
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: PUSH
39839: LD_INT 3
39841: NEG
39842: PUSH
39843: LD_INT 3
39845: NEG
39846: PUSH
39847: EMPTY
39848: LIST
39849: LIST
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: LIST
39855: LIST
39856: LIST
39857: LIST
39858: LIST
39859: LIST
39860: LIST
39861: LIST
39862: LIST
39863: LIST
39864: LIST
39865: LIST
39866: LIST
39867: LIST
39868: LIST
39869: LIST
39870: LIST
39871: LIST
39872: LIST
39873: LIST
39874: LIST
39875: LIST
39876: LIST
39877: LIST
39878: LIST
39879: LIST
39880: LIST
39881: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39882: LD_ADDR_VAR 0 45
39886: PUSH
39887: LD_INT 0
39889: PUSH
39890: LD_INT 0
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 0
39899: PUSH
39900: LD_INT 1
39902: NEG
39903: PUSH
39904: EMPTY
39905: LIST
39906: LIST
39907: PUSH
39908: LD_INT 1
39910: PUSH
39911: LD_INT 0
39913: PUSH
39914: EMPTY
39915: LIST
39916: LIST
39917: PUSH
39918: LD_INT 1
39920: PUSH
39921: LD_INT 1
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: PUSH
39928: LD_INT 0
39930: PUSH
39931: LD_INT 1
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: PUSH
39938: LD_INT 1
39940: NEG
39941: PUSH
39942: LD_INT 0
39944: PUSH
39945: EMPTY
39946: LIST
39947: LIST
39948: PUSH
39949: LD_INT 1
39951: NEG
39952: PUSH
39953: LD_INT 1
39955: NEG
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: PUSH
39961: LD_INT 1
39963: NEG
39964: PUSH
39965: LD_INT 2
39967: NEG
39968: PUSH
39969: EMPTY
39970: LIST
39971: LIST
39972: PUSH
39973: LD_INT 0
39975: PUSH
39976: LD_INT 2
39978: NEG
39979: PUSH
39980: EMPTY
39981: LIST
39982: LIST
39983: PUSH
39984: LD_INT 1
39986: PUSH
39987: LD_INT 1
39989: NEG
39990: PUSH
39991: EMPTY
39992: LIST
39993: LIST
39994: PUSH
39995: LD_INT 2
39997: PUSH
39998: LD_INT 1
40000: PUSH
40001: EMPTY
40002: LIST
40003: LIST
40004: PUSH
40005: LD_INT 2
40007: PUSH
40008: LD_INT 2
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: PUSH
40015: LD_INT 1
40017: PUSH
40018: LD_INT 2
40020: PUSH
40021: EMPTY
40022: LIST
40023: LIST
40024: PUSH
40025: LD_INT 0
40027: PUSH
40028: LD_INT 2
40030: PUSH
40031: EMPTY
40032: LIST
40033: LIST
40034: PUSH
40035: LD_INT 1
40037: NEG
40038: PUSH
40039: LD_INT 1
40041: PUSH
40042: EMPTY
40043: LIST
40044: LIST
40045: PUSH
40046: LD_INT 2
40048: NEG
40049: PUSH
40050: LD_INT 1
40052: NEG
40053: PUSH
40054: EMPTY
40055: LIST
40056: LIST
40057: PUSH
40058: LD_INT 2
40060: NEG
40061: PUSH
40062: LD_INT 2
40064: NEG
40065: PUSH
40066: EMPTY
40067: LIST
40068: LIST
40069: PUSH
40070: LD_INT 2
40072: NEG
40073: PUSH
40074: LD_INT 3
40076: NEG
40077: PUSH
40078: EMPTY
40079: LIST
40080: LIST
40081: PUSH
40082: LD_INT 1
40084: NEG
40085: PUSH
40086: LD_INT 3
40088: NEG
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: LD_INT 0
40096: PUSH
40097: LD_INT 3
40099: NEG
40100: PUSH
40101: EMPTY
40102: LIST
40103: LIST
40104: PUSH
40105: LD_INT 1
40107: PUSH
40108: LD_INT 2
40110: NEG
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 3
40118: PUSH
40119: LD_INT 2
40121: PUSH
40122: EMPTY
40123: LIST
40124: LIST
40125: PUSH
40126: LD_INT 3
40128: PUSH
40129: LD_INT 3
40131: PUSH
40132: EMPTY
40133: LIST
40134: LIST
40135: PUSH
40136: LD_INT 2
40138: PUSH
40139: LD_INT 3
40141: PUSH
40142: EMPTY
40143: LIST
40144: LIST
40145: PUSH
40146: LD_INT 1
40148: PUSH
40149: LD_INT 3
40151: PUSH
40152: EMPTY
40153: LIST
40154: LIST
40155: PUSH
40156: LD_INT 0
40158: PUSH
40159: LD_INT 3
40161: PUSH
40162: EMPTY
40163: LIST
40164: LIST
40165: PUSH
40166: LD_INT 1
40168: NEG
40169: PUSH
40170: LD_INT 2
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PUSH
40177: LD_INT 3
40179: NEG
40180: PUSH
40181: LD_INT 2
40183: NEG
40184: PUSH
40185: EMPTY
40186: LIST
40187: LIST
40188: PUSH
40189: LD_INT 3
40191: NEG
40192: PUSH
40193: LD_INT 3
40195: NEG
40196: PUSH
40197: EMPTY
40198: LIST
40199: LIST
40200: PUSH
40201: EMPTY
40202: LIST
40203: LIST
40204: LIST
40205: LIST
40206: LIST
40207: LIST
40208: LIST
40209: LIST
40210: LIST
40211: LIST
40212: LIST
40213: LIST
40214: LIST
40215: LIST
40216: LIST
40217: LIST
40218: LIST
40219: LIST
40220: LIST
40221: LIST
40222: LIST
40223: LIST
40224: LIST
40225: LIST
40226: LIST
40227: LIST
40228: LIST
40229: LIST
40230: LIST
40231: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40232: LD_ADDR_VAR 0 46
40236: PUSH
40237: LD_INT 0
40239: PUSH
40240: LD_INT 0
40242: PUSH
40243: EMPTY
40244: LIST
40245: LIST
40246: PUSH
40247: LD_INT 0
40249: PUSH
40250: LD_INT 1
40252: NEG
40253: PUSH
40254: EMPTY
40255: LIST
40256: LIST
40257: PUSH
40258: LD_INT 1
40260: PUSH
40261: LD_INT 0
40263: PUSH
40264: EMPTY
40265: LIST
40266: LIST
40267: PUSH
40268: LD_INT 1
40270: PUSH
40271: LD_INT 1
40273: PUSH
40274: EMPTY
40275: LIST
40276: LIST
40277: PUSH
40278: LD_INT 0
40280: PUSH
40281: LD_INT 1
40283: PUSH
40284: EMPTY
40285: LIST
40286: LIST
40287: PUSH
40288: LD_INT 1
40290: NEG
40291: PUSH
40292: LD_INT 0
40294: PUSH
40295: EMPTY
40296: LIST
40297: LIST
40298: PUSH
40299: LD_INT 1
40301: NEG
40302: PUSH
40303: LD_INT 1
40305: NEG
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: LD_INT 1
40313: NEG
40314: PUSH
40315: LD_INT 2
40317: NEG
40318: PUSH
40319: EMPTY
40320: LIST
40321: LIST
40322: PUSH
40323: LD_INT 0
40325: PUSH
40326: LD_INT 2
40328: NEG
40329: PUSH
40330: EMPTY
40331: LIST
40332: LIST
40333: PUSH
40334: LD_INT 1
40336: PUSH
40337: LD_INT 1
40339: NEG
40340: PUSH
40341: EMPTY
40342: LIST
40343: LIST
40344: PUSH
40345: LD_INT 2
40347: PUSH
40348: LD_INT 0
40350: PUSH
40351: EMPTY
40352: LIST
40353: LIST
40354: PUSH
40355: LD_INT 2
40357: PUSH
40358: LD_INT 1
40360: PUSH
40361: EMPTY
40362: LIST
40363: LIST
40364: PUSH
40365: LD_INT 1
40367: PUSH
40368: LD_INT 2
40370: PUSH
40371: EMPTY
40372: LIST
40373: LIST
40374: PUSH
40375: LD_INT 0
40377: PUSH
40378: LD_INT 2
40380: PUSH
40381: EMPTY
40382: LIST
40383: LIST
40384: PUSH
40385: LD_INT 1
40387: NEG
40388: PUSH
40389: LD_INT 1
40391: PUSH
40392: EMPTY
40393: LIST
40394: LIST
40395: PUSH
40396: LD_INT 2
40398: NEG
40399: PUSH
40400: LD_INT 0
40402: PUSH
40403: EMPTY
40404: LIST
40405: LIST
40406: PUSH
40407: LD_INT 2
40409: NEG
40410: PUSH
40411: LD_INT 1
40413: NEG
40414: PUSH
40415: EMPTY
40416: LIST
40417: LIST
40418: PUSH
40419: LD_INT 1
40421: NEG
40422: PUSH
40423: LD_INT 3
40425: NEG
40426: PUSH
40427: EMPTY
40428: LIST
40429: LIST
40430: PUSH
40431: LD_INT 0
40433: PUSH
40434: LD_INT 3
40436: NEG
40437: PUSH
40438: EMPTY
40439: LIST
40440: LIST
40441: PUSH
40442: LD_INT 1
40444: PUSH
40445: LD_INT 2
40447: NEG
40448: PUSH
40449: EMPTY
40450: LIST
40451: LIST
40452: PUSH
40453: LD_INT 2
40455: PUSH
40456: LD_INT 1
40458: NEG
40459: PUSH
40460: EMPTY
40461: LIST
40462: LIST
40463: PUSH
40464: LD_INT 3
40466: PUSH
40467: LD_INT 0
40469: PUSH
40470: EMPTY
40471: LIST
40472: LIST
40473: PUSH
40474: LD_INT 3
40476: PUSH
40477: LD_INT 1
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: PUSH
40484: LD_INT 1
40486: PUSH
40487: LD_INT 3
40489: PUSH
40490: EMPTY
40491: LIST
40492: LIST
40493: PUSH
40494: LD_INT 0
40496: PUSH
40497: LD_INT 3
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: LD_INT 1
40506: NEG
40507: PUSH
40508: LD_INT 2
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 2
40517: NEG
40518: PUSH
40519: LD_INT 1
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: PUSH
40526: LD_INT 3
40528: NEG
40529: PUSH
40530: LD_INT 0
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: PUSH
40537: LD_INT 3
40539: NEG
40540: PUSH
40541: LD_INT 1
40543: NEG
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: EMPTY
40550: LIST
40551: LIST
40552: LIST
40553: LIST
40554: LIST
40555: LIST
40556: LIST
40557: LIST
40558: LIST
40559: LIST
40560: LIST
40561: LIST
40562: LIST
40563: LIST
40564: LIST
40565: LIST
40566: LIST
40567: LIST
40568: LIST
40569: LIST
40570: LIST
40571: LIST
40572: LIST
40573: LIST
40574: LIST
40575: LIST
40576: LIST
40577: LIST
40578: LIST
40579: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40580: LD_ADDR_VAR 0 47
40584: PUSH
40585: LD_INT 0
40587: PUSH
40588: LD_INT 0
40590: PUSH
40591: EMPTY
40592: LIST
40593: LIST
40594: PUSH
40595: LD_INT 0
40597: PUSH
40598: LD_INT 1
40600: NEG
40601: PUSH
40602: EMPTY
40603: LIST
40604: LIST
40605: PUSH
40606: LD_INT 1
40608: PUSH
40609: LD_INT 0
40611: PUSH
40612: EMPTY
40613: LIST
40614: LIST
40615: PUSH
40616: LD_INT 1
40618: PUSH
40619: LD_INT 1
40621: PUSH
40622: EMPTY
40623: LIST
40624: LIST
40625: PUSH
40626: LD_INT 0
40628: PUSH
40629: LD_INT 1
40631: PUSH
40632: EMPTY
40633: LIST
40634: LIST
40635: PUSH
40636: LD_INT 1
40638: NEG
40639: PUSH
40640: LD_INT 0
40642: PUSH
40643: EMPTY
40644: LIST
40645: LIST
40646: PUSH
40647: LD_INT 1
40649: NEG
40650: PUSH
40651: LD_INT 1
40653: NEG
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 1
40661: NEG
40662: PUSH
40663: LD_INT 2
40665: NEG
40666: PUSH
40667: EMPTY
40668: LIST
40669: LIST
40670: PUSH
40671: LD_INT 0
40673: PUSH
40674: LD_INT 2
40676: NEG
40677: PUSH
40678: EMPTY
40679: LIST
40680: LIST
40681: PUSH
40682: LD_INT 1
40684: PUSH
40685: LD_INT 1
40687: NEG
40688: PUSH
40689: EMPTY
40690: LIST
40691: LIST
40692: PUSH
40693: LD_INT 2
40695: NEG
40696: PUSH
40697: LD_INT 1
40699: NEG
40700: PUSH
40701: EMPTY
40702: LIST
40703: LIST
40704: PUSH
40705: LD_INT 2
40707: NEG
40708: PUSH
40709: LD_INT 2
40711: NEG
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: LIST
40721: LIST
40722: LIST
40723: LIST
40724: LIST
40725: LIST
40726: LIST
40727: LIST
40728: LIST
40729: LIST
40730: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
40731: LD_ADDR_VAR 0 48
40735: PUSH
40736: LD_INT 0
40738: PUSH
40739: LD_INT 0
40741: PUSH
40742: EMPTY
40743: LIST
40744: LIST
40745: PUSH
40746: LD_INT 0
40748: PUSH
40749: LD_INT 1
40751: NEG
40752: PUSH
40753: EMPTY
40754: LIST
40755: LIST
40756: PUSH
40757: LD_INT 1
40759: PUSH
40760: LD_INT 0
40762: PUSH
40763: EMPTY
40764: LIST
40765: LIST
40766: PUSH
40767: LD_INT 1
40769: PUSH
40770: LD_INT 1
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: PUSH
40777: LD_INT 0
40779: PUSH
40780: LD_INT 1
40782: PUSH
40783: EMPTY
40784: LIST
40785: LIST
40786: PUSH
40787: LD_INT 1
40789: NEG
40790: PUSH
40791: LD_INT 0
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: PUSH
40798: LD_INT 1
40800: NEG
40801: PUSH
40802: LD_INT 1
40804: NEG
40805: PUSH
40806: EMPTY
40807: LIST
40808: LIST
40809: PUSH
40810: LD_INT 1
40812: NEG
40813: PUSH
40814: LD_INT 2
40816: NEG
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: PUSH
40822: LD_INT 0
40824: PUSH
40825: LD_INT 2
40827: NEG
40828: PUSH
40829: EMPTY
40830: LIST
40831: LIST
40832: PUSH
40833: LD_INT 1
40835: PUSH
40836: LD_INT 1
40838: NEG
40839: PUSH
40840: EMPTY
40841: LIST
40842: LIST
40843: PUSH
40844: LD_INT 2
40846: PUSH
40847: LD_INT 0
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: PUSH
40854: LD_INT 2
40856: PUSH
40857: LD_INT 1
40859: PUSH
40860: EMPTY
40861: LIST
40862: LIST
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: LIST
40868: LIST
40869: LIST
40870: LIST
40871: LIST
40872: LIST
40873: LIST
40874: LIST
40875: LIST
40876: LIST
40877: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
40878: LD_ADDR_VAR 0 49
40882: PUSH
40883: LD_INT 0
40885: PUSH
40886: LD_INT 0
40888: PUSH
40889: EMPTY
40890: LIST
40891: LIST
40892: PUSH
40893: LD_INT 0
40895: PUSH
40896: LD_INT 1
40898: NEG
40899: PUSH
40900: EMPTY
40901: LIST
40902: LIST
40903: PUSH
40904: LD_INT 1
40906: PUSH
40907: LD_INT 0
40909: PUSH
40910: EMPTY
40911: LIST
40912: LIST
40913: PUSH
40914: LD_INT 1
40916: PUSH
40917: LD_INT 1
40919: PUSH
40920: EMPTY
40921: LIST
40922: LIST
40923: PUSH
40924: LD_INT 0
40926: PUSH
40927: LD_INT 1
40929: PUSH
40930: EMPTY
40931: LIST
40932: LIST
40933: PUSH
40934: LD_INT 1
40936: NEG
40937: PUSH
40938: LD_INT 0
40940: PUSH
40941: EMPTY
40942: LIST
40943: LIST
40944: PUSH
40945: LD_INT 1
40947: NEG
40948: PUSH
40949: LD_INT 1
40951: NEG
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: PUSH
40957: LD_INT 1
40959: PUSH
40960: LD_INT 1
40962: NEG
40963: PUSH
40964: EMPTY
40965: LIST
40966: LIST
40967: PUSH
40968: LD_INT 2
40970: PUSH
40971: LD_INT 0
40973: PUSH
40974: EMPTY
40975: LIST
40976: LIST
40977: PUSH
40978: LD_INT 2
40980: PUSH
40981: LD_INT 1
40983: PUSH
40984: EMPTY
40985: LIST
40986: LIST
40987: PUSH
40988: LD_INT 2
40990: PUSH
40991: LD_INT 2
40993: PUSH
40994: EMPTY
40995: LIST
40996: LIST
40997: PUSH
40998: LD_INT 1
41000: PUSH
41001: LD_INT 2
41003: PUSH
41004: EMPTY
41005: LIST
41006: LIST
41007: PUSH
41008: EMPTY
41009: LIST
41010: LIST
41011: LIST
41012: LIST
41013: LIST
41014: LIST
41015: LIST
41016: LIST
41017: LIST
41018: LIST
41019: LIST
41020: LIST
41021: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41022: LD_ADDR_VAR 0 50
41026: PUSH
41027: LD_INT 0
41029: PUSH
41030: LD_INT 0
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 0
41039: PUSH
41040: LD_INT 1
41042: NEG
41043: PUSH
41044: EMPTY
41045: LIST
41046: LIST
41047: PUSH
41048: LD_INT 1
41050: PUSH
41051: LD_INT 0
41053: PUSH
41054: EMPTY
41055: LIST
41056: LIST
41057: PUSH
41058: LD_INT 1
41060: PUSH
41061: LD_INT 1
41063: PUSH
41064: EMPTY
41065: LIST
41066: LIST
41067: PUSH
41068: LD_INT 0
41070: PUSH
41071: LD_INT 1
41073: PUSH
41074: EMPTY
41075: LIST
41076: LIST
41077: PUSH
41078: LD_INT 1
41080: NEG
41081: PUSH
41082: LD_INT 0
41084: PUSH
41085: EMPTY
41086: LIST
41087: LIST
41088: PUSH
41089: LD_INT 1
41091: NEG
41092: PUSH
41093: LD_INT 1
41095: NEG
41096: PUSH
41097: EMPTY
41098: LIST
41099: LIST
41100: PUSH
41101: LD_INT 2
41103: PUSH
41104: LD_INT 1
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: LD_INT 2
41113: PUSH
41114: LD_INT 2
41116: PUSH
41117: EMPTY
41118: LIST
41119: LIST
41120: PUSH
41121: LD_INT 1
41123: PUSH
41124: LD_INT 2
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: PUSH
41131: LD_INT 0
41133: PUSH
41134: LD_INT 2
41136: PUSH
41137: EMPTY
41138: LIST
41139: LIST
41140: PUSH
41141: LD_INT 1
41143: NEG
41144: PUSH
41145: LD_INT 1
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: EMPTY
41153: LIST
41154: LIST
41155: LIST
41156: LIST
41157: LIST
41158: LIST
41159: LIST
41160: LIST
41161: LIST
41162: LIST
41163: LIST
41164: LIST
41165: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41166: LD_ADDR_VAR 0 51
41170: PUSH
41171: LD_INT 0
41173: PUSH
41174: LD_INT 0
41176: PUSH
41177: EMPTY
41178: LIST
41179: LIST
41180: PUSH
41181: LD_INT 0
41183: PUSH
41184: LD_INT 1
41186: NEG
41187: PUSH
41188: EMPTY
41189: LIST
41190: LIST
41191: PUSH
41192: LD_INT 1
41194: PUSH
41195: LD_INT 0
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: LD_INT 1
41204: PUSH
41205: LD_INT 1
41207: PUSH
41208: EMPTY
41209: LIST
41210: LIST
41211: PUSH
41212: LD_INT 0
41214: PUSH
41215: LD_INT 1
41217: PUSH
41218: EMPTY
41219: LIST
41220: LIST
41221: PUSH
41222: LD_INT 1
41224: NEG
41225: PUSH
41226: LD_INT 0
41228: PUSH
41229: EMPTY
41230: LIST
41231: LIST
41232: PUSH
41233: LD_INT 1
41235: NEG
41236: PUSH
41237: LD_INT 1
41239: NEG
41240: PUSH
41241: EMPTY
41242: LIST
41243: LIST
41244: PUSH
41245: LD_INT 1
41247: PUSH
41248: LD_INT 2
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: PUSH
41255: LD_INT 0
41257: PUSH
41258: LD_INT 2
41260: PUSH
41261: EMPTY
41262: LIST
41263: LIST
41264: PUSH
41265: LD_INT 1
41267: NEG
41268: PUSH
41269: LD_INT 1
41271: PUSH
41272: EMPTY
41273: LIST
41274: LIST
41275: PUSH
41276: LD_INT 2
41278: NEG
41279: PUSH
41280: LD_INT 0
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: PUSH
41287: LD_INT 2
41289: NEG
41290: PUSH
41291: LD_INT 1
41293: NEG
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: PUSH
41299: EMPTY
41300: LIST
41301: LIST
41302: LIST
41303: LIST
41304: LIST
41305: LIST
41306: LIST
41307: LIST
41308: LIST
41309: LIST
41310: LIST
41311: LIST
41312: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41313: LD_ADDR_VAR 0 52
41317: PUSH
41318: LD_INT 0
41320: PUSH
41321: LD_INT 0
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: PUSH
41328: LD_INT 0
41330: PUSH
41331: LD_INT 1
41333: NEG
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PUSH
41339: LD_INT 1
41341: PUSH
41342: LD_INT 0
41344: PUSH
41345: EMPTY
41346: LIST
41347: LIST
41348: PUSH
41349: LD_INT 1
41351: PUSH
41352: LD_INT 1
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: PUSH
41359: LD_INT 0
41361: PUSH
41362: LD_INT 1
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: LD_INT 1
41371: NEG
41372: PUSH
41373: LD_INT 0
41375: PUSH
41376: EMPTY
41377: LIST
41378: LIST
41379: PUSH
41380: LD_INT 1
41382: NEG
41383: PUSH
41384: LD_INT 1
41386: NEG
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: PUSH
41392: LD_INT 1
41394: NEG
41395: PUSH
41396: LD_INT 2
41398: NEG
41399: PUSH
41400: EMPTY
41401: LIST
41402: LIST
41403: PUSH
41404: LD_INT 1
41406: NEG
41407: PUSH
41408: LD_INT 1
41410: PUSH
41411: EMPTY
41412: LIST
41413: LIST
41414: PUSH
41415: LD_INT 2
41417: NEG
41418: PUSH
41419: LD_INT 0
41421: PUSH
41422: EMPTY
41423: LIST
41424: LIST
41425: PUSH
41426: LD_INT 2
41428: NEG
41429: PUSH
41430: LD_INT 1
41432: NEG
41433: PUSH
41434: EMPTY
41435: LIST
41436: LIST
41437: PUSH
41438: LD_INT 2
41440: NEG
41441: PUSH
41442: LD_INT 2
41444: NEG
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: PUSH
41450: EMPTY
41451: LIST
41452: LIST
41453: LIST
41454: LIST
41455: LIST
41456: LIST
41457: LIST
41458: LIST
41459: LIST
41460: LIST
41461: LIST
41462: LIST
41463: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41464: LD_ADDR_VAR 0 53
41468: PUSH
41469: LD_INT 0
41471: PUSH
41472: LD_INT 0
41474: PUSH
41475: EMPTY
41476: LIST
41477: LIST
41478: PUSH
41479: LD_INT 0
41481: PUSH
41482: LD_INT 1
41484: NEG
41485: PUSH
41486: EMPTY
41487: LIST
41488: LIST
41489: PUSH
41490: LD_INT 1
41492: PUSH
41493: LD_INT 0
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: PUSH
41500: LD_INT 1
41502: PUSH
41503: LD_INT 1
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PUSH
41510: LD_INT 0
41512: PUSH
41513: LD_INT 1
41515: PUSH
41516: EMPTY
41517: LIST
41518: LIST
41519: PUSH
41520: LD_INT 1
41522: NEG
41523: PUSH
41524: LD_INT 0
41526: PUSH
41527: EMPTY
41528: LIST
41529: LIST
41530: PUSH
41531: LD_INT 1
41533: NEG
41534: PUSH
41535: LD_INT 1
41537: NEG
41538: PUSH
41539: EMPTY
41540: LIST
41541: LIST
41542: PUSH
41543: LD_INT 1
41545: NEG
41546: PUSH
41547: LD_INT 2
41549: NEG
41550: PUSH
41551: EMPTY
41552: LIST
41553: LIST
41554: PUSH
41555: LD_INT 0
41557: PUSH
41558: LD_INT 2
41560: NEG
41561: PUSH
41562: EMPTY
41563: LIST
41564: LIST
41565: PUSH
41566: LD_INT 1
41568: PUSH
41569: LD_INT 1
41571: NEG
41572: PUSH
41573: EMPTY
41574: LIST
41575: LIST
41576: PUSH
41577: LD_INT 2
41579: PUSH
41580: LD_INT 0
41582: PUSH
41583: EMPTY
41584: LIST
41585: LIST
41586: PUSH
41587: LD_INT 2
41589: PUSH
41590: LD_INT 1
41592: PUSH
41593: EMPTY
41594: LIST
41595: LIST
41596: PUSH
41597: LD_INT 2
41599: PUSH
41600: LD_INT 2
41602: PUSH
41603: EMPTY
41604: LIST
41605: LIST
41606: PUSH
41607: LD_INT 1
41609: PUSH
41610: LD_INT 2
41612: PUSH
41613: EMPTY
41614: LIST
41615: LIST
41616: PUSH
41617: LD_INT 0
41619: PUSH
41620: LD_INT 2
41622: PUSH
41623: EMPTY
41624: LIST
41625: LIST
41626: PUSH
41627: LD_INT 1
41629: NEG
41630: PUSH
41631: LD_INT 1
41633: PUSH
41634: EMPTY
41635: LIST
41636: LIST
41637: PUSH
41638: LD_INT 2
41640: NEG
41641: PUSH
41642: LD_INT 0
41644: PUSH
41645: EMPTY
41646: LIST
41647: LIST
41648: PUSH
41649: LD_INT 2
41651: NEG
41652: PUSH
41653: LD_INT 1
41655: NEG
41656: PUSH
41657: EMPTY
41658: LIST
41659: LIST
41660: PUSH
41661: LD_INT 2
41663: NEG
41664: PUSH
41665: LD_INT 2
41667: NEG
41668: PUSH
41669: EMPTY
41670: LIST
41671: LIST
41672: PUSH
41673: EMPTY
41674: LIST
41675: LIST
41676: LIST
41677: LIST
41678: LIST
41679: LIST
41680: LIST
41681: LIST
41682: LIST
41683: LIST
41684: LIST
41685: LIST
41686: LIST
41687: LIST
41688: LIST
41689: LIST
41690: LIST
41691: LIST
41692: LIST
41693: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41694: LD_ADDR_VAR 0 54
41698: PUSH
41699: LD_INT 0
41701: PUSH
41702: LD_INT 0
41704: PUSH
41705: EMPTY
41706: LIST
41707: LIST
41708: PUSH
41709: LD_INT 0
41711: PUSH
41712: LD_INT 1
41714: NEG
41715: PUSH
41716: EMPTY
41717: LIST
41718: LIST
41719: PUSH
41720: LD_INT 1
41722: PUSH
41723: LD_INT 0
41725: PUSH
41726: EMPTY
41727: LIST
41728: LIST
41729: PUSH
41730: LD_INT 1
41732: PUSH
41733: LD_INT 1
41735: PUSH
41736: EMPTY
41737: LIST
41738: LIST
41739: PUSH
41740: LD_INT 0
41742: PUSH
41743: LD_INT 1
41745: PUSH
41746: EMPTY
41747: LIST
41748: LIST
41749: PUSH
41750: LD_INT 1
41752: NEG
41753: PUSH
41754: LD_INT 0
41756: PUSH
41757: EMPTY
41758: LIST
41759: LIST
41760: PUSH
41761: LD_INT 1
41763: NEG
41764: PUSH
41765: LD_INT 1
41767: NEG
41768: PUSH
41769: EMPTY
41770: LIST
41771: LIST
41772: PUSH
41773: LD_INT 1
41775: NEG
41776: PUSH
41777: LD_INT 2
41779: NEG
41780: PUSH
41781: EMPTY
41782: LIST
41783: LIST
41784: PUSH
41785: LD_INT 0
41787: PUSH
41788: LD_INT 2
41790: NEG
41791: PUSH
41792: EMPTY
41793: LIST
41794: LIST
41795: PUSH
41796: LD_INT 1
41798: PUSH
41799: LD_INT 1
41801: NEG
41802: PUSH
41803: EMPTY
41804: LIST
41805: LIST
41806: PUSH
41807: LD_INT 2
41809: PUSH
41810: LD_INT 0
41812: PUSH
41813: EMPTY
41814: LIST
41815: LIST
41816: PUSH
41817: LD_INT 2
41819: PUSH
41820: LD_INT 1
41822: PUSH
41823: EMPTY
41824: LIST
41825: LIST
41826: PUSH
41827: LD_INT 2
41829: PUSH
41830: LD_INT 2
41832: PUSH
41833: EMPTY
41834: LIST
41835: LIST
41836: PUSH
41837: LD_INT 1
41839: PUSH
41840: LD_INT 2
41842: PUSH
41843: EMPTY
41844: LIST
41845: LIST
41846: PUSH
41847: LD_INT 0
41849: PUSH
41850: LD_INT 2
41852: PUSH
41853: EMPTY
41854: LIST
41855: LIST
41856: PUSH
41857: LD_INT 1
41859: NEG
41860: PUSH
41861: LD_INT 1
41863: PUSH
41864: EMPTY
41865: LIST
41866: LIST
41867: PUSH
41868: LD_INT 2
41870: NEG
41871: PUSH
41872: LD_INT 0
41874: PUSH
41875: EMPTY
41876: LIST
41877: LIST
41878: PUSH
41879: LD_INT 2
41881: NEG
41882: PUSH
41883: LD_INT 1
41885: NEG
41886: PUSH
41887: EMPTY
41888: LIST
41889: LIST
41890: PUSH
41891: LD_INT 2
41893: NEG
41894: PUSH
41895: LD_INT 2
41897: NEG
41898: PUSH
41899: EMPTY
41900: LIST
41901: LIST
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: LIST
41907: LIST
41908: LIST
41909: LIST
41910: LIST
41911: LIST
41912: LIST
41913: LIST
41914: LIST
41915: LIST
41916: LIST
41917: LIST
41918: LIST
41919: LIST
41920: LIST
41921: LIST
41922: LIST
41923: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41924: LD_ADDR_VAR 0 55
41928: PUSH
41929: LD_INT 0
41931: PUSH
41932: LD_INT 0
41934: PUSH
41935: EMPTY
41936: LIST
41937: LIST
41938: PUSH
41939: LD_INT 0
41941: PUSH
41942: LD_INT 1
41944: NEG
41945: PUSH
41946: EMPTY
41947: LIST
41948: LIST
41949: PUSH
41950: LD_INT 1
41952: PUSH
41953: LD_INT 0
41955: PUSH
41956: EMPTY
41957: LIST
41958: LIST
41959: PUSH
41960: LD_INT 1
41962: PUSH
41963: LD_INT 1
41965: PUSH
41966: EMPTY
41967: LIST
41968: LIST
41969: PUSH
41970: LD_INT 0
41972: PUSH
41973: LD_INT 1
41975: PUSH
41976: EMPTY
41977: LIST
41978: LIST
41979: PUSH
41980: LD_INT 1
41982: NEG
41983: PUSH
41984: LD_INT 0
41986: PUSH
41987: EMPTY
41988: LIST
41989: LIST
41990: PUSH
41991: LD_INT 1
41993: NEG
41994: PUSH
41995: LD_INT 1
41997: NEG
41998: PUSH
41999: EMPTY
42000: LIST
42001: LIST
42002: PUSH
42003: LD_INT 1
42005: NEG
42006: PUSH
42007: LD_INT 2
42009: NEG
42010: PUSH
42011: EMPTY
42012: LIST
42013: LIST
42014: PUSH
42015: LD_INT 0
42017: PUSH
42018: LD_INT 2
42020: NEG
42021: PUSH
42022: EMPTY
42023: LIST
42024: LIST
42025: PUSH
42026: LD_INT 1
42028: PUSH
42029: LD_INT 1
42031: NEG
42032: PUSH
42033: EMPTY
42034: LIST
42035: LIST
42036: PUSH
42037: LD_INT 2
42039: PUSH
42040: LD_INT 0
42042: PUSH
42043: EMPTY
42044: LIST
42045: LIST
42046: PUSH
42047: LD_INT 2
42049: PUSH
42050: LD_INT 1
42052: PUSH
42053: EMPTY
42054: LIST
42055: LIST
42056: PUSH
42057: LD_INT 2
42059: PUSH
42060: LD_INT 2
42062: PUSH
42063: EMPTY
42064: LIST
42065: LIST
42066: PUSH
42067: LD_INT 1
42069: PUSH
42070: LD_INT 2
42072: PUSH
42073: EMPTY
42074: LIST
42075: LIST
42076: PUSH
42077: LD_INT 0
42079: PUSH
42080: LD_INT 2
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: PUSH
42087: LD_INT 1
42089: NEG
42090: PUSH
42091: LD_INT 1
42093: PUSH
42094: EMPTY
42095: LIST
42096: LIST
42097: PUSH
42098: LD_INT 2
42100: NEG
42101: PUSH
42102: LD_INT 0
42104: PUSH
42105: EMPTY
42106: LIST
42107: LIST
42108: PUSH
42109: LD_INT 2
42111: NEG
42112: PUSH
42113: LD_INT 1
42115: NEG
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 2
42123: NEG
42124: PUSH
42125: LD_INT 2
42127: NEG
42128: PUSH
42129: EMPTY
42130: LIST
42131: LIST
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: LIST
42137: LIST
42138: LIST
42139: LIST
42140: LIST
42141: LIST
42142: LIST
42143: LIST
42144: LIST
42145: LIST
42146: LIST
42147: LIST
42148: LIST
42149: LIST
42150: LIST
42151: LIST
42152: LIST
42153: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42154: LD_ADDR_VAR 0 56
42158: PUSH
42159: LD_INT 0
42161: PUSH
42162: LD_INT 0
42164: PUSH
42165: EMPTY
42166: LIST
42167: LIST
42168: PUSH
42169: LD_INT 0
42171: PUSH
42172: LD_INT 1
42174: NEG
42175: PUSH
42176: EMPTY
42177: LIST
42178: LIST
42179: PUSH
42180: LD_INT 1
42182: PUSH
42183: LD_INT 0
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 1
42192: PUSH
42193: LD_INT 1
42195: PUSH
42196: EMPTY
42197: LIST
42198: LIST
42199: PUSH
42200: LD_INT 0
42202: PUSH
42203: LD_INT 1
42205: PUSH
42206: EMPTY
42207: LIST
42208: LIST
42209: PUSH
42210: LD_INT 1
42212: NEG
42213: PUSH
42214: LD_INT 0
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 1
42223: NEG
42224: PUSH
42225: LD_INT 1
42227: NEG
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: LD_INT 1
42235: NEG
42236: PUSH
42237: LD_INT 2
42239: NEG
42240: PUSH
42241: EMPTY
42242: LIST
42243: LIST
42244: PUSH
42245: LD_INT 0
42247: PUSH
42248: LD_INT 2
42250: NEG
42251: PUSH
42252: EMPTY
42253: LIST
42254: LIST
42255: PUSH
42256: LD_INT 1
42258: PUSH
42259: LD_INT 1
42261: NEG
42262: PUSH
42263: EMPTY
42264: LIST
42265: LIST
42266: PUSH
42267: LD_INT 2
42269: PUSH
42270: LD_INT 0
42272: PUSH
42273: EMPTY
42274: LIST
42275: LIST
42276: PUSH
42277: LD_INT 2
42279: PUSH
42280: LD_INT 1
42282: PUSH
42283: EMPTY
42284: LIST
42285: LIST
42286: PUSH
42287: LD_INT 2
42289: PUSH
42290: LD_INT 2
42292: PUSH
42293: EMPTY
42294: LIST
42295: LIST
42296: PUSH
42297: LD_INT 1
42299: PUSH
42300: LD_INT 2
42302: PUSH
42303: EMPTY
42304: LIST
42305: LIST
42306: PUSH
42307: LD_INT 0
42309: PUSH
42310: LD_INT 2
42312: PUSH
42313: EMPTY
42314: LIST
42315: LIST
42316: PUSH
42317: LD_INT 1
42319: NEG
42320: PUSH
42321: LD_INT 1
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: PUSH
42328: LD_INT 2
42330: NEG
42331: PUSH
42332: LD_INT 0
42334: PUSH
42335: EMPTY
42336: LIST
42337: LIST
42338: PUSH
42339: LD_INT 2
42341: NEG
42342: PUSH
42343: LD_INT 1
42345: NEG
42346: PUSH
42347: EMPTY
42348: LIST
42349: LIST
42350: PUSH
42351: LD_INT 2
42353: NEG
42354: PUSH
42355: LD_INT 2
42357: NEG
42358: PUSH
42359: EMPTY
42360: LIST
42361: LIST
42362: PUSH
42363: EMPTY
42364: LIST
42365: LIST
42366: LIST
42367: LIST
42368: LIST
42369: LIST
42370: LIST
42371: LIST
42372: LIST
42373: LIST
42374: LIST
42375: LIST
42376: LIST
42377: LIST
42378: LIST
42379: LIST
42380: LIST
42381: LIST
42382: LIST
42383: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42384: LD_ADDR_VAR 0 57
42388: PUSH
42389: LD_INT 0
42391: PUSH
42392: LD_INT 0
42394: PUSH
42395: EMPTY
42396: LIST
42397: LIST
42398: PUSH
42399: LD_INT 0
42401: PUSH
42402: LD_INT 1
42404: NEG
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: PUSH
42410: LD_INT 1
42412: PUSH
42413: LD_INT 0
42415: PUSH
42416: EMPTY
42417: LIST
42418: LIST
42419: PUSH
42420: LD_INT 1
42422: PUSH
42423: LD_INT 1
42425: PUSH
42426: EMPTY
42427: LIST
42428: LIST
42429: PUSH
42430: LD_INT 0
42432: PUSH
42433: LD_INT 1
42435: PUSH
42436: EMPTY
42437: LIST
42438: LIST
42439: PUSH
42440: LD_INT 1
42442: NEG
42443: PUSH
42444: LD_INT 0
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: PUSH
42451: LD_INT 1
42453: NEG
42454: PUSH
42455: LD_INT 1
42457: NEG
42458: PUSH
42459: EMPTY
42460: LIST
42461: LIST
42462: PUSH
42463: LD_INT 1
42465: NEG
42466: PUSH
42467: LD_INT 2
42469: NEG
42470: PUSH
42471: EMPTY
42472: LIST
42473: LIST
42474: PUSH
42475: LD_INT 0
42477: PUSH
42478: LD_INT 2
42480: NEG
42481: PUSH
42482: EMPTY
42483: LIST
42484: LIST
42485: PUSH
42486: LD_INT 1
42488: PUSH
42489: LD_INT 1
42491: NEG
42492: PUSH
42493: EMPTY
42494: LIST
42495: LIST
42496: PUSH
42497: LD_INT 2
42499: PUSH
42500: LD_INT 0
42502: PUSH
42503: EMPTY
42504: LIST
42505: LIST
42506: PUSH
42507: LD_INT 2
42509: PUSH
42510: LD_INT 1
42512: PUSH
42513: EMPTY
42514: LIST
42515: LIST
42516: PUSH
42517: LD_INT 2
42519: PUSH
42520: LD_INT 2
42522: PUSH
42523: EMPTY
42524: LIST
42525: LIST
42526: PUSH
42527: LD_INT 1
42529: PUSH
42530: LD_INT 2
42532: PUSH
42533: EMPTY
42534: LIST
42535: LIST
42536: PUSH
42537: LD_INT 0
42539: PUSH
42540: LD_INT 2
42542: PUSH
42543: EMPTY
42544: LIST
42545: LIST
42546: PUSH
42547: LD_INT 1
42549: NEG
42550: PUSH
42551: LD_INT 1
42553: PUSH
42554: EMPTY
42555: LIST
42556: LIST
42557: PUSH
42558: LD_INT 2
42560: NEG
42561: PUSH
42562: LD_INT 0
42564: PUSH
42565: EMPTY
42566: LIST
42567: LIST
42568: PUSH
42569: LD_INT 2
42571: NEG
42572: PUSH
42573: LD_INT 1
42575: NEG
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: PUSH
42581: LD_INT 2
42583: NEG
42584: PUSH
42585: LD_INT 2
42587: NEG
42588: PUSH
42589: EMPTY
42590: LIST
42591: LIST
42592: PUSH
42593: EMPTY
42594: LIST
42595: LIST
42596: LIST
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: LIST
42603: LIST
42604: LIST
42605: LIST
42606: LIST
42607: LIST
42608: LIST
42609: LIST
42610: LIST
42611: LIST
42612: LIST
42613: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42614: LD_ADDR_VAR 0 58
42618: PUSH
42619: LD_INT 0
42621: PUSH
42622: LD_INT 0
42624: PUSH
42625: EMPTY
42626: LIST
42627: LIST
42628: PUSH
42629: LD_INT 0
42631: PUSH
42632: LD_INT 1
42634: NEG
42635: PUSH
42636: EMPTY
42637: LIST
42638: LIST
42639: PUSH
42640: LD_INT 1
42642: PUSH
42643: LD_INT 0
42645: PUSH
42646: EMPTY
42647: LIST
42648: LIST
42649: PUSH
42650: LD_INT 1
42652: PUSH
42653: LD_INT 1
42655: PUSH
42656: EMPTY
42657: LIST
42658: LIST
42659: PUSH
42660: LD_INT 0
42662: PUSH
42663: LD_INT 1
42665: PUSH
42666: EMPTY
42667: LIST
42668: LIST
42669: PUSH
42670: LD_INT 1
42672: NEG
42673: PUSH
42674: LD_INT 0
42676: PUSH
42677: EMPTY
42678: LIST
42679: LIST
42680: PUSH
42681: LD_INT 1
42683: NEG
42684: PUSH
42685: LD_INT 1
42687: NEG
42688: PUSH
42689: EMPTY
42690: LIST
42691: LIST
42692: PUSH
42693: LD_INT 1
42695: NEG
42696: PUSH
42697: LD_INT 2
42699: NEG
42700: PUSH
42701: EMPTY
42702: LIST
42703: LIST
42704: PUSH
42705: LD_INT 0
42707: PUSH
42708: LD_INT 2
42710: NEG
42711: PUSH
42712: EMPTY
42713: LIST
42714: LIST
42715: PUSH
42716: LD_INT 1
42718: PUSH
42719: LD_INT 1
42721: NEG
42722: PUSH
42723: EMPTY
42724: LIST
42725: LIST
42726: PUSH
42727: LD_INT 2
42729: PUSH
42730: LD_INT 0
42732: PUSH
42733: EMPTY
42734: LIST
42735: LIST
42736: PUSH
42737: LD_INT 2
42739: PUSH
42740: LD_INT 1
42742: PUSH
42743: EMPTY
42744: LIST
42745: LIST
42746: PUSH
42747: LD_INT 2
42749: PUSH
42750: LD_INT 2
42752: PUSH
42753: EMPTY
42754: LIST
42755: LIST
42756: PUSH
42757: LD_INT 1
42759: PUSH
42760: LD_INT 2
42762: PUSH
42763: EMPTY
42764: LIST
42765: LIST
42766: PUSH
42767: LD_INT 0
42769: PUSH
42770: LD_INT 2
42772: PUSH
42773: EMPTY
42774: LIST
42775: LIST
42776: PUSH
42777: LD_INT 1
42779: NEG
42780: PUSH
42781: LD_INT 1
42783: PUSH
42784: EMPTY
42785: LIST
42786: LIST
42787: PUSH
42788: LD_INT 2
42790: NEG
42791: PUSH
42792: LD_INT 0
42794: PUSH
42795: EMPTY
42796: LIST
42797: LIST
42798: PUSH
42799: LD_INT 2
42801: NEG
42802: PUSH
42803: LD_INT 1
42805: NEG
42806: PUSH
42807: EMPTY
42808: LIST
42809: LIST
42810: PUSH
42811: LD_INT 2
42813: NEG
42814: PUSH
42815: LD_INT 2
42817: NEG
42818: PUSH
42819: EMPTY
42820: LIST
42821: LIST
42822: PUSH
42823: EMPTY
42824: LIST
42825: LIST
42826: LIST
42827: LIST
42828: LIST
42829: LIST
42830: LIST
42831: LIST
42832: LIST
42833: LIST
42834: LIST
42835: LIST
42836: LIST
42837: LIST
42838: LIST
42839: LIST
42840: LIST
42841: LIST
42842: LIST
42843: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42844: LD_ADDR_VAR 0 59
42848: PUSH
42849: LD_INT 0
42851: PUSH
42852: LD_INT 0
42854: PUSH
42855: EMPTY
42856: LIST
42857: LIST
42858: PUSH
42859: LD_INT 0
42861: PUSH
42862: LD_INT 1
42864: NEG
42865: PUSH
42866: EMPTY
42867: LIST
42868: LIST
42869: PUSH
42870: LD_INT 1
42872: PUSH
42873: LD_INT 0
42875: PUSH
42876: EMPTY
42877: LIST
42878: LIST
42879: PUSH
42880: LD_INT 1
42882: PUSH
42883: LD_INT 1
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: PUSH
42890: LD_INT 0
42892: PUSH
42893: LD_INT 1
42895: PUSH
42896: EMPTY
42897: LIST
42898: LIST
42899: PUSH
42900: LD_INT 1
42902: NEG
42903: PUSH
42904: LD_INT 0
42906: PUSH
42907: EMPTY
42908: LIST
42909: LIST
42910: PUSH
42911: LD_INT 1
42913: NEG
42914: PUSH
42915: LD_INT 1
42917: NEG
42918: PUSH
42919: EMPTY
42920: LIST
42921: LIST
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: LIST
42927: LIST
42928: LIST
42929: LIST
42930: LIST
42931: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42932: LD_ADDR_VAR 0 60
42936: PUSH
42937: LD_INT 0
42939: PUSH
42940: LD_INT 0
42942: PUSH
42943: EMPTY
42944: LIST
42945: LIST
42946: PUSH
42947: LD_INT 0
42949: PUSH
42950: LD_INT 1
42952: NEG
42953: PUSH
42954: EMPTY
42955: LIST
42956: LIST
42957: PUSH
42958: LD_INT 1
42960: PUSH
42961: LD_INT 0
42963: PUSH
42964: EMPTY
42965: LIST
42966: LIST
42967: PUSH
42968: LD_INT 1
42970: PUSH
42971: LD_INT 1
42973: PUSH
42974: EMPTY
42975: LIST
42976: LIST
42977: PUSH
42978: LD_INT 0
42980: PUSH
42981: LD_INT 1
42983: PUSH
42984: EMPTY
42985: LIST
42986: LIST
42987: PUSH
42988: LD_INT 1
42990: NEG
42991: PUSH
42992: LD_INT 0
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PUSH
42999: LD_INT 1
43001: NEG
43002: PUSH
43003: LD_INT 1
43005: NEG
43006: PUSH
43007: EMPTY
43008: LIST
43009: LIST
43010: PUSH
43011: EMPTY
43012: LIST
43013: LIST
43014: LIST
43015: LIST
43016: LIST
43017: LIST
43018: LIST
43019: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43020: LD_ADDR_VAR 0 61
43024: PUSH
43025: LD_INT 0
43027: PUSH
43028: LD_INT 0
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: LD_INT 0
43037: PUSH
43038: LD_INT 1
43040: NEG
43041: PUSH
43042: EMPTY
43043: LIST
43044: LIST
43045: PUSH
43046: LD_INT 1
43048: PUSH
43049: LD_INT 0
43051: PUSH
43052: EMPTY
43053: LIST
43054: LIST
43055: PUSH
43056: LD_INT 1
43058: PUSH
43059: LD_INT 1
43061: PUSH
43062: EMPTY
43063: LIST
43064: LIST
43065: PUSH
43066: LD_INT 0
43068: PUSH
43069: LD_INT 1
43071: PUSH
43072: EMPTY
43073: LIST
43074: LIST
43075: PUSH
43076: LD_INT 1
43078: NEG
43079: PUSH
43080: LD_INT 0
43082: PUSH
43083: EMPTY
43084: LIST
43085: LIST
43086: PUSH
43087: LD_INT 1
43089: NEG
43090: PUSH
43091: LD_INT 1
43093: NEG
43094: PUSH
43095: EMPTY
43096: LIST
43097: LIST
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: LIST
43103: LIST
43104: LIST
43105: LIST
43106: LIST
43107: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43108: LD_ADDR_VAR 0 62
43112: PUSH
43113: LD_INT 0
43115: PUSH
43116: LD_INT 0
43118: PUSH
43119: EMPTY
43120: LIST
43121: LIST
43122: PUSH
43123: LD_INT 0
43125: PUSH
43126: LD_INT 1
43128: NEG
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: PUSH
43134: LD_INT 1
43136: PUSH
43137: LD_INT 0
43139: PUSH
43140: EMPTY
43141: LIST
43142: LIST
43143: PUSH
43144: LD_INT 1
43146: PUSH
43147: LD_INT 1
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PUSH
43154: LD_INT 0
43156: PUSH
43157: LD_INT 1
43159: PUSH
43160: EMPTY
43161: LIST
43162: LIST
43163: PUSH
43164: LD_INT 1
43166: NEG
43167: PUSH
43168: LD_INT 0
43170: PUSH
43171: EMPTY
43172: LIST
43173: LIST
43174: PUSH
43175: LD_INT 1
43177: NEG
43178: PUSH
43179: LD_INT 1
43181: NEG
43182: PUSH
43183: EMPTY
43184: LIST
43185: LIST
43186: PUSH
43187: EMPTY
43188: LIST
43189: LIST
43190: LIST
43191: LIST
43192: LIST
43193: LIST
43194: LIST
43195: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43196: LD_ADDR_VAR 0 63
43200: PUSH
43201: LD_INT 0
43203: PUSH
43204: LD_INT 0
43206: PUSH
43207: EMPTY
43208: LIST
43209: LIST
43210: PUSH
43211: LD_INT 0
43213: PUSH
43214: LD_INT 1
43216: NEG
43217: PUSH
43218: EMPTY
43219: LIST
43220: LIST
43221: PUSH
43222: LD_INT 1
43224: PUSH
43225: LD_INT 0
43227: PUSH
43228: EMPTY
43229: LIST
43230: LIST
43231: PUSH
43232: LD_INT 1
43234: PUSH
43235: LD_INT 1
43237: PUSH
43238: EMPTY
43239: LIST
43240: LIST
43241: PUSH
43242: LD_INT 0
43244: PUSH
43245: LD_INT 1
43247: PUSH
43248: EMPTY
43249: LIST
43250: LIST
43251: PUSH
43252: LD_INT 1
43254: NEG
43255: PUSH
43256: LD_INT 0
43258: PUSH
43259: EMPTY
43260: LIST
43261: LIST
43262: PUSH
43263: LD_INT 1
43265: NEG
43266: PUSH
43267: LD_INT 1
43269: NEG
43270: PUSH
43271: EMPTY
43272: LIST
43273: LIST
43274: PUSH
43275: EMPTY
43276: LIST
43277: LIST
43278: LIST
43279: LIST
43280: LIST
43281: LIST
43282: LIST
43283: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43284: LD_ADDR_VAR 0 64
43288: PUSH
43289: LD_INT 0
43291: PUSH
43292: LD_INT 0
43294: PUSH
43295: EMPTY
43296: LIST
43297: LIST
43298: PUSH
43299: LD_INT 0
43301: PUSH
43302: LD_INT 1
43304: NEG
43305: PUSH
43306: EMPTY
43307: LIST
43308: LIST
43309: PUSH
43310: LD_INT 1
43312: PUSH
43313: LD_INT 0
43315: PUSH
43316: EMPTY
43317: LIST
43318: LIST
43319: PUSH
43320: LD_INT 1
43322: PUSH
43323: LD_INT 1
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 0
43332: PUSH
43333: LD_INT 1
43335: PUSH
43336: EMPTY
43337: LIST
43338: LIST
43339: PUSH
43340: LD_INT 1
43342: NEG
43343: PUSH
43344: LD_INT 0
43346: PUSH
43347: EMPTY
43348: LIST
43349: LIST
43350: PUSH
43351: LD_INT 1
43353: NEG
43354: PUSH
43355: LD_INT 1
43357: NEG
43358: PUSH
43359: EMPTY
43360: LIST
43361: LIST
43362: PUSH
43363: EMPTY
43364: LIST
43365: LIST
43366: LIST
43367: LIST
43368: LIST
43369: LIST
43370: LIST
43371: ST_TO_ADDR
// end ; 1 :
43372: GO 49269
43374: LD_INT 1
43376: DOUBLE
43377: EQUAL
43378: IFTRUE 43382
43380: GO 46005
43382: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43383: LD_ADDR_VAR 0 11
43387: PUSH
43388: LD_INT 1
43390: NEG
43391: PUSH
43392: LD_INT 3
43394: NEG
43395: PUSH
43396: EMPTY
43397: LIST
43398: LIST
43399: PUSH
43400: LD_INT 0
43402: PUSH
43403: LD_INT 3
43405: NEG
43406: PUSH
43407: EMPTY
43408: LIST
43409: LIST
43410: PUSH
43411: LD_INT 1
43413: PUSH
43414: LD_INT 2
43416: NEG
43417: PUSH
43418: EMPTY
43419: LIST
43420: LIST
43421: PUSH
43422: EMPTY
43423: LIST
43424: LIST
43425: LIST
43426: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43427: LD_ADDR_VAR 0 12
43431: PUSH
43432: LD_INT 2
43434: PUSH
43435: LD_INT 1
43437: NEG
43438: PUSH
43439: EMPTY
43440: LIST
43441: LIST
43442: PUSH
43443: LD_INT 3
43445: PUSH
43446: LD_INT 0
43448: PUSH
43449: EMPTY
43450: LIST
43451: LIST
43452: PUSH
43453: LD_INT 3
43455: PUSH
43456: LD_INT 1
43458: PUSH
43459: EMPTY
43460: LIST
43461: LIST
43462: PUSH
43463: EMPTY
43464: LIST
43465: LIST
43466: LIST
43467: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43468: LD_ADDR_VAR 0 13
43472: PUSH
43473: LD_INT 3
43475: PUSH
43476: LD_INT 2
43478: PUSH
43479: EMPTY
43480: LIST
43481: LIST
43482: PUSH
43483: LD_INT 3
43485: PUSH
43486: LD_INT 3
43488: PUSH
43489: EMPTY
43490: LIST
43491: LIST
43492: PUSH
43493: LD_INT 2
43495: PUSH
43496: LD_INT 3
43498: PUSH
43499: EMPTY
43500: LIST
43501: LIST
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: LIST
43507: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43508: LD_ADDR_VAR 0 14
43512: PUSH
43513: LD_INT 1
43515: PUSH
43516: LD_INT 3
43518: PUSH
43519: EMPTY
43520: LIST
43521: LIST
43522: PUSH
43523: LD_INT 0
43525: PUSH
43526: LD_INT 3
43528: PUSH
43529: EMPTY
43530: LIST
43531: LIST
43532: PUSH
43533: LD_INT 1
43535: NEG
43536: PUSH
43537: LD_INT 2
43539: PUSH
43540: EMPTY
43541: LIST
43542: LIST
43543: PUSH
43544: EMPTY
43545: LIST
43546: LIST
43547: LIST
43548: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43549: LD_ADDR_VAR 0 15
43553: PUSH
43554: LD_INT 2
43556: NEG
43557: PUSH
43558: LD_INT 1
43560: PUSH
43561: EMPTY
43562: LIST
43563: LIST
43564: PUSH
43565: LD_INT 3
43567: NEG
43568: PUSH
43569: LD_INT 0
43571: PUSH
43572: EMPTY
43573: LIST
43574: LIST
43575: PUSH
43576: LD_INT 3
43578: NEG
43579: PUSH
43580: LD_INT 1
43582: NEG
43583: PUSH
43584: EMPTY
43585: LIST
43586: LIST
43587: PUSH
43588: EMPTY
43589: LIST
43590: LIST
43591: LIST
43592: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43593: LD_ADDR_VAR 0 16
43597: PUSH
43598: LD_INT 2
43600: NEG
43601: PUSH
43602: LD_INT 3
43604: NEG
43605: PUSH
43606: EMPTY
43607: LIST
43608: LIST
43609: PUSH
43610: LD_INT 3
43612: NEG
43613: PUSH
43614: LD_INT 2
43616: NEG
43617: PUSH
43618: EMPTY
43619: LIST
43620: LIST
43621: PUSH
43622: LD_INT 3
43624: NEG
43625: PUSH
43626: LD_INT 3
43628: NEG
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: LIST
43638: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43639: LD_ADDR_VAR 0 17
43643: PUSH
43644: LD_INT 1
43646: NEG
43647: PUSH
43648: LD_INT 3
43650: NEG
43651: PUSH
43652: EMPTY
43653: LIST
43654: LIST
43655: PUSH
43656: LD_INT 0
43658: PUSH
43659: LD_INT 3
43661: NEG
43662: PUSH
43663: EMPTY
43664: LIST
43665: LIST
43666: PUSH
43667: LD_INT 1
43669: PUSH
43670: LD_INT 2
43672: NEG
43673: PUSH
43674: EMPTY
43675: LIST
43676: LIST
43677: PUSH
43678: EMPTY
43679: LIST
43680: LIST
43681: LIST
43682: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43683: LD_ADDR_VAR 0 18
43687: PUSH
43688: LD_INT 2
43690: PUSH
43691: LD_INT 1
43693: NEG
43694: PUSH
43695: EMPTY
43696: LIST
43697: LIST
43698: PUSH
43699: LD_INT 3
43701: PUSH
43702: LD_INT 0
43704: PUSH
43705: EMPTY
43706: LIST
43707: LIST
43708: PUSH
43709: LD_INT 3
43711: PUSH
43712: LD_INT 1
43714: PUSH
43715: EMPTY
43716: LIST
43717: LIST
43718: PUSH
43719: EMPTY
43720: LIST
43721: LIST
43722: LIST
43723: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43724: LD_ADDR_VAR 0 19
43728: PUSH
43729: LD_INT 3
43731: PUSH
43732: LD_INT 2
43734: PUSH
43735: EMPTY
43736: LIST
43737: LIST
43738: PUSH
43739: LD_INT 3
43741: PUSH
43742: LD_INT 3
43744: PUSH
43745: EMPTY
43746: LIST
43747: LIST
43748: PUSH
43749: LD_INT 2
43751: PUSH
43752: LD_INT 3
43754: PUSH
43755: EMPTY
43756: LIST
43757: LIST
43758: PUSH
43759: EMPTY
43760: LIST
43761: LIST
43762: LIST
43763: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43764: LD_ADDR_VAR 0 20
43768: PUSH
43769: LD_INT 1
43771: PUSH
43772: LD_INT 3
43774: PUSH
43775: EMPTY
43776: LIST
43777: LIST
43778: PUSH
43779: LD_INT 0
43781: PUSH
43782: LD_INT 3
43784: PUSH
43785: EMPTY
43786: LIST
43787: LIST
43788: PUSH
43789: LD_INT 1
43791: NEG
43792: PUSH
43793: LD_INT 2
43795: PUSH
43796: EMPTY
43797: LIST
43798: LIST
43799: PUSH
43800: EMPTY
43801: LIST
43802: LIST
43803: LIST
43804: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43805: LD_ADDR_VAR 0 21
43809: PUSH
43810: LD_INT 2
43812: NEG
43813: PUSH
43814: LD_INT 1
43816: PUSH
43817: EMPTY
43818: LIST
43819: LIST
43820: PUSH
43821: LD_INT 3
43823: NEG
43824: PUSH
43825: LD_INT 0
43827: PUSH
43828: EMPTY
43829: LIST
43830: LIST
43831: PUSH
43832: LD_INT 3
43834: NEG
43835: PUSH
43836: LD_INT 1
43838: NEG
43839: PUSH
43840: EMPTY
43841: LIST
43842: LIST
43843: PUSH
43844: EMPTY
43845: LIST
43846: LIST
43847: LIST
43848: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43849: LD_ADDR_VAR 0 22
43853: PUSH
43854: LD_INT 2
43856: NEG
43857: PUSH
43858: LD_INT 3
43860: NEG
43861: PUSH
43862: EMPTY
43863: LIST
43864: LIST
43865: PUSH
43866: LD_INT 3
43868: NEG
43869: PUSH
43870: LD_INT 2
43872: NEG
43873: PUSH
43874: EMPTY
43875: LIST
43876: LIST
43877: PUSH
43878: LD_INT 3
43880: NEG
43881: PUSH
43882: LD_INT 3
43884: NEG
43885: PUSH
43886: EMPTY
43887: LIST
43888: LIST
43889: PUSH
43890: EMPTY
43891: LIST
43892: LIST
43893: LIST
43894: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
43895: LD_ADDR_VAR 0 23
43899: PUSH
43900: LD_INT 0
43902: PUSH
43903: LD_INT 3
43905: NEG
43906: PUSH
43907: EMPTY
43908: LIST
43909: LIST
43910: PUSH
43911: LD_INT 1
43913: NEG
43914: PUSH
43915: LD_INT 4
43917: NEG
43918: PUSH
43919: EMPTY
43920: LIST
43921: LIST
43922: PUSH
43923: LD_INT 1
43925: PUSH
43926: LD_INT 3
43928: NEG
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: PUSH
43934: EMPTY
43935: LIST
43936: LIST
43937: LIST
43938: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
43939: LD_ADDR_VAR 0 24
43943: PUSH
43944: LD_INT 3
43946: PUSH
43947: LD_INT 0
43949: PUSH
43950: EMPTY
43951: LIST
43952: LIST
43953: PUSH
43954: LD_INT 3
43956: PUSH
43957: LD_INT 1
43959: NEG
43960: PUSH
43961: EMPTY
43962: LIST
43963: LIST
43964: PUSH
43965: LD_INT 4
43967: PUSH
43968: LD_INT 1
43970: PUSH
43971: EMPTY
43972: LIST
43973: LIST
43974: PUSH
43975: EMPTY
43976: LIST
43977: LIST
43978: LIST
43979: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
43980: LD_ADDR_VAR 0 25
43984: PUSH
43985: LD_INT 3
43987: PUSH
43988: LD_INT 3
43990: PUSH
43991: EMPTY
43992: LIST
43993: LIST
43994: PUSH
43995: LD_INT 4
43997: PUSH
43998: LD_INT 3
44000: PUSH
44001: EMPTY
44002: LIST
44003: LIST
44004: PUSH
44005: LD_INT 3
44007: PUSH
44008: LD_INT 4
44010: PUSH
44011: EMPTY
44012: LIST
44013: LIST
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: LIST
44019: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
44020: LD_ADDR_VAR 0 26
44024: PUSH
44025: LD_INT 0
44027: PUSH
44028: LD_INT 3
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: PUSH
44035: LD_INT 1
44037: PUSH
44038: LD_INT 4
44040: PUSH
44041: EMPTY
44042: LIST
44043: LIST
44044: PUSH
44045: LD_INT 1
44047: NEG
44048: PUSH
44049: LD_INT 3
44051: PUSH
44052: EMPTY
44053: LIST
44054: LIST
44055: PUSH
44056: EMPTY
44057: LIST
44058: LIST
44059: LIST
44060: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
44061: LD_ADDR_VAR 0 27
44065: PUSH
44066: LD_INT 3
44068: NEG
44069: PUSH
44070: LD_INT 0
44072: PUSH
44073: EMPTY
44074: LIST
44075: LIST
44076: PUSH
44077: LD_INT 3
44079: NEG
44080: PUSH
44081: LD_INT 1
44083: PUSH
44084: EMPTY
44085: LIST
44086: LIST
44087: PUSH
44088: LD_INT 4
44090: NEG
44091: PUSH
44092: LD_INT 1
44094: NEG
44095: PUSH
44096: EMPTY
44097: LIST
44098: LIST
44099: PUSH
44100: EMPTY
44101: LIST
44102: LIST
44103: LIST
44104: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
44105: LD_ADDR_VAR 0 28
44109: PUSH
44110: LD_INT 3
44112: NEG
44113: PUSH
44114: LD_INT 3
44116: NEG
44117: PUSH
44118: EMPTY
44119: LIST
44120: LIST
44121: PUSH
44122: LD_INT 3
44124: NEG
44125: PUSH
44126: LD_INT 4
44128: NEG
44129: PUSH
44130: EMPTY
44131: LIST
44132: LIST
44133: PUSH
44134: LD_INT 4
44136: NEG
44137: PUSH
44138: LD_INT 3
44140: NEG
44141: PUSH
44142: EMPTY
44143: LIST
44144: LIST
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: LIST
44150: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
44151: LD_ADDR_VAR 0 29
44155: PUSH
44156: LD_INT 1
44158: NEG
44159: PUSH
44160: LD_INT 3
44162: NEG
44163: PUSH
44164: EMPTY
44165: LIST
44166: LIST
44167: PUSH
44168: LD_INT 0
44170: PUSH
44171: LD_INT 3
44173: NEG
44174: PUSH
44175: EMPTY
44176: LIST
44177: LIST
44178: PUSH
44179: LD_INT 1
44181: PUSH
44182: LD_INT 2
44184: NEG
44185: PUSH
44186: EMPTY
44187: LIST
44188: LIST
44189: PUSH
44190: LD_INT 1
44192: NEG
44193: PUSH
44194: LD_INT 4
44196: NEG
44197: PUSH
44198: EMPTY
44199: LIST
44200: LIST
44201: PUSH
44202: LD_INT 0
44204: PUSH
44205: LD_INT 4
44207: NEG
44208: PUSH
44209: EMPTY
44210: LIST
44211: LIST
44212: PUSH
44213: LD_INT 1
44215: PUSH
44216: LD_INT 3
44218: NEG
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: PUSH
44224: LD_INT 1
44226: NEG
44227: PUSH
44228: LD_INT 5
44230: NEG
44231: PUSH
44232: EMPTY
44233: LIST
44234: LIST
44235: PUSH
44236: LD_INT 0
44238: PUSH
44239: LD_INT 5
44241: NEG
44242: PUSH
44243: EMPTY
44244: LIST
44245: LIST
44246: PUSH
44247: LD_INT 1
44249: PUSH
44250: LD_INT 4
44252: NEG
44253: PUSH
44254: EMPTY
44255: LIST
44256: LIST
44257: PUSH
44258: LD_INT 1
44260: NEG
44261: PUSH
44262: LD_INT 6
44264: NEG
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: PUSH
44270: LD_INT 0
44272: PUSH
44273: LD_INT 6
44275: NEG
44276: PUSH
44277: EMPTY
44278: LIST
44279: LIST
44280: PUSH
44281: LD_INT 1
44283: PUSH
44284: LD_INT 5
44286: NEG
44287: PUSH
44288: EMPTY
44289: LIST
44290: LIST
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: LIST
44296: LIST
44297: LIST
44298: LIST
44299: LIST
44300: LIST
44301: LIST
44302: LIST
44303: LIST
44304: LIST
44305: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
44306: LD_ADDR_VAR 0 30
44310: PUSH
44311: LD_INT 2
44313: PUSH
44314: LD_INT 1
44316: NEG
44317: PUSH
44318: EMPTY
44319: LIST
44320: LIST
44321: PUSH
44322: LD_INT 3
44324: PUSH
44325: LD_INT 0
44327: PUSH
44328: EMPTY
44329: LIST
44330: LIST
44331: PUSH
44332: LD_INT 3
44334: PUSH
44335: LD_INT 1
44337: PUSH
44338: EMPTY
44339: LIST
44340: LIST
44341: PUSH
44342: LD_INT 3
44344: PUSH
44345: LD_INT 1
44347: NEG
44348: PUSH
44349: EMPTY
44350: LIST
44351: LIST
44352: PUSH
44353: LD_INT 4
44355: PUSH
44356: LD_INT 0
44358: PUSH
44359: EMPTY
44360: LIST
44361: LIST
44362: PUSH
44363: LD_INT 4
44365: PUSH
44366: LD_INT 1
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 4
44375: PUSH
44376: LD_INT 1
44378: NEG
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 5
44386: PUSH
44387: LD_INT 0
44389: PUSH
44390: EMPTY
44391: LIST
44392: LIST
44393: PUSH
44394: LD_INT 5
44396: PUSH
44397: LD_INT 1
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: PUSH
44404: LD_INT 5
44406: PUSH
44407: LD_INT 1
44409: NEG
44410: PUSH
44411: EMPTY
44412: LIST
44413: LIST
44414: PUSH
44415: LD_INT 6
44417: PUSH
44418: LD_INT 0
44420: PUSH
44421: EMPTY
44422: LIST
44423: LIST
44424: PUSH
44425: LD_INT 6
44427: PUSH
44428: LD_INT 1
44430: PUSH
44431: EMPTY
44432: LIST
44433: LIST
44434: PUSH
44435: EMPTY
44436: LIST
44437: LIST
44438: LIST
44439: LIST
44440: LIST
44441: LIST
44442: LIST
44443: LIST
44444: LIST
44445: LIST
44446: LIST
44447: LIST
44448: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
44449: LD_ADDR_VAR 0 31
44453: PUSH
44454: LD_INT 3
44456: PUSH
44457: LD_INT 2
44459: PUSH
44460: EMPTY
44461: LIST
44462: LIST
44463: PUSH
44464: LD_INT 3
44466: PUSH
44467: LD_INT 3
44469: PUSH
44470: EMPTY
44471: LIST
44472: LIST
44473: PUSH
44474: LD_INT 2
44476: PUSH
44477: LD_INT 3
44479: PUSH
44480: EMPTY
44481: LIST
44482: LIST
44483: PUSH
44484: LD_INT 4
44486: PUSH
44487: LD_INT 3
44489: PUSH
44490: EMPTY
44491: LIST
44492: LIST
44493: PUSH
44494: LD_INT 4
44496: PUSH
44497: LD_INT 4
44499: PUSH
44500: EMPTY
44501: LIST
44502: LIST
44503: PUSH
44504: LD_INT 3
44506: PUSH
44507: LD_INT 4
44509: PUSH
44510: EMPTY
44511: LIST
44512: LIST
44513: PUSH
44514: LD_INT 5
44516: PUSH
44517: LD_INT 4
44519: PUSH
44520: EMPTY
44521: LIST
44522: LIST
44523: PUSH
44524: LD_INT 5
44526: PUSH
44527: LD_INT 5
44529: PUSH
44530: EMPTY
44531: LIST
44532: LIST
44533: PUSH
44534: LD_INT 4
44536: PUSH
44537: LD_INT 5
44539: PUSH
44540: EMPTY
44541: LIST
44542: LIST
44543: PUSH
44544: LD_INT 6
44546: PUSH
44547: LD_INT 5
44549: PUSH
44550: EMPTY
44551: LIST
44552: LIST
44553: PUSH
44554: LD_INT 6
44556: PUSH
44557: LD_INT 6
44559: PUSH
44560: EMPTY
44561: LIST
44562: LIST
44563: PUSH
44564: LD_INT 5
44566: PUSH
44567: LD_INT 6
44569: PUSH
44570: EMPTY
44571: LIST
44572: LIST
44573: PUSH
44574: EMPTY
44575: LIST
44576: LIST
44577: LIST
44578: LIST
44579: LIST
44580: LIST
44581: LIST
44582: LIST
44583: LIST
44584: LIST
44585: LIST
44586: LIST
44587: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
44588: LD_ADDR_VAR 0 32
44592: PUSH
44593: LD_INT 1
44595: PUSH
44596: LD_INT 3
44598: PUSH
44599: EMPTY
44600: LIST
44601: LIST
44602: PUSH
44603: LD_INT 0
44605: PUSH
44606: LD_INT 3
44608: PUSH
44609: EMPTY
44610: LIST
44611: LIST
44612: PUSH
44613: LD_INT 1
44615: NEG
44616: PUSH
44617: LD_INT 2
44619: PUSH
44620: EMPTY
44621: LIST
44622: LIST
44623: PUSH
44624: LD_INT 1
44626: PUSH
44627: LD_INT 4
44629: PUSH
44630: EMPTY
44631: LIST
44632: LIST
44633: PUSH
44634: LD_INT 0
44636: PUSH
44637: LD_INT 4
44639: PUSH
44640: EMPTY
44641: LIST
44642: LIST
44643: PUSH
44644: LD_INT 1
44646: NEG
44647: PUSH
44648: LD_INT 3
44650: PUSH
44651: EMPTY
44652: LIST
44653: LIST
44654: PUSH
44655: LD_INT 1
44657: PUSH
44658: LD_INT 5
44660: PUSH
44661: EMPTY
44662: LIST
44663: LIST
44664: PUSH
44665: LD_INT 0
44667: PUSH
44668: LD_INT 5
44670: PUSH
44671: EMPTY
44672: LIST
44673: LIST
44674: PUSH
44675: LD_INT 1
44677: NEG
44678: PUSH
44679: LD_INT 4
44681: PUSH
44682: EMPTY
44683: LIST
44684: LIST
44685: PUSH
44686: LD_INT 1
44688: PUSH
44689: LD_INT 6
44691: PUSH
44692: EMPTY
44693: LIST
44694: LIST
44695: PUSH
44696: LD_INT 0
44698: PUSH
44699: LD_INT 6
44701: PUSH
44702: EMPTY
44703: LIST
44704: LIST
44705: PUSH
44706: LD_INT 1
44708: NEG
44709: PUSH
44710: LD_INT 5
44712: PUSH
44713: EMPTY
44714: LIST
44715: LIST
44716: PUSH
44717: EMPTY
44718: LIST
44719: LIST
44720: LIST
44721: LIST
44722: LIST
44723: LIST
44724: LIST
44725: LIST
44726: LIST
44727: LIST
44728: LIST
44729: LIST
44730: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
44731: LD_ADDR_VAR 0 33
44735: PUSH
44736: LD_INT 2
44738: NEG
44739: PUSH
44740: LD_INT 1
44742: PUSH
44743: EMPTY
44744: LIST
44745: LIST
44746: PUSH
44747: LD_INT 3
44749: NEG
44750: PUSH
44751: LD_INT 0
44753: PUSH
44754: EMPTY
44755: LIST
44756: LIST
44757: PUSH
44758: LD_INT 3
44760: NEG
44761: PUSH
44762: LD_INT 1
44764: NEG
44765: PUSH
44766: EMPTY
44767: LIST
44768: LIST
44769: PUSH
44770: LD_INT 3
44772: NEG
44773: PUSH
44774: LD_INT 1
44776: PUSH
44777: EMPTY
44778: LIST
44779: LIST
44780: PUSH
44781: LD_INT 4
44783: NEG
44784: PUSH
44785: LD_INT 0
44787: PUSH
44788: EMPTY
44789: LIST
44790: LIST
44791: PUSH
44792: LD_INT 4
44794: NEG
44795: PUSH
44796: LD_INT 1
44798: NEG
44799: PUSH
44800: EMPTY
44801: LIST
44802: LIST
44803: PUSH
44804: LD_INT 4
44806: NEG
44807: PUSH
44808: LD_INT 1
44810: PUSH
44811: EMPTY
44812: LIST
44813: LIST
44814: PUSH
44815: LD_INT 5
44817: NEG
44818: PUSH
44819: LD_INT 0
44821: PUSH
44822: EMPTY
44823: LIST
44824: LIST
44825: PUSH
44826: LD_INT 5
44828: NEG
44829: PUSH
44830: LD_INT 1
44832: NEG
44833: PUSH
44834: EMPTY
44835: LIST
44836: LIST
44837: PUSH
44838: LD_INT 5
44840: NEG
44841: PUSH
44842: LD_INT 1
44844: PUSH
44845: EMPTY
44846: LIST
44847: LIST
44848: PUSH
44849: LD_INT 6
44851: NEG
44852: PUSH
44853: LD_INT 0
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 6
44862: NEG
44863: PUSH
44864: LD_INT 1
44866: NEG
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: PUSH
44872: EMPTY
44873: LIST
44874: LIST
44875: LIST
44876: LIST
44877: LIST
44878: LIST
44879: LIST
44880: LIST
44881: LIST
44882: LIST
44883: LIST
44884: LIST
44885: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
44886: LD_ADDR_VAR 0 34
44890: PUSH
44891: LD_INT 2
44893: NEG
44894: PUSH
44895: LD_INT 3
44897: NEG
44898: PUSH
44899: EMPTY
44900: LIST
44901: LIST
44902: PUSH
44903: LD_INT 3
44905: NEG
44906: PUSH
44907: LD_INT 2
44909: NEG
44910: PUSH
44911: EMPTY
44912: LIST
44913: LIST
44914: PUSH
44915: LD_INT 3
44917: NEG
44918: PUSH
44919: LD_INT 3
44921: NEG
44922: PUSH
44923: EMPTY
44924: LIST
44925: LIST
44926: PUSH
44927: LD_INT 3
44929: NEG
44930: PUSH
44931: LD_INT 4
44933: NEG
44934: PUSH
44935: EMPTY
44936: LIST
44937: LIST
44938: PUSH
44939: LD_INT 4
44941: NEG
44942: PUSH
44943: LD_INT 3
44945: NEG
44946: PUSH
44947: EMPTY
44948: LIST
44949: LIST
44950: PUSH
44951: LD_INT 4
44953: NEG
44954: PUSH
44955: LD_INT 4
44957: NEG
44958: PUSH
44959: EMPTY
44960: LIST
44961: LIST
44962: PUSH
44963: LD_INT 4
44965: NEG
44966: PUSH
44967: LD_INT 5
44969: NEG
44970: PUSH
44971: EMPTY
44972: LIST
44973: LIST
44974: PUSH
44975: LD_INT 5
44977: NEG
44978: PUSH
44979: LD_INT 4
44981: NEG
44982: PUSH
44983: EMPTY
44984: LIST
44985: LIST
44986: PUSH
44987: LD_INT 5
44989: NEG
44990: PUSH
44991: LD_INT 5
44993: NEG
44994: PUSH
44995: EMPTY
44996: LIST
44997: LIST
44998: PUSH
44999: LD_INT 5
45001: NEG
45002: PUSH
45003: LD_INT 6
45005: NEG
45006: PUSH
45007: EMPTY
45008: LIST
45009: LIST
45010: PUSH
45011: LD_INT 6
45013: NEG
45014: PUSH
45015: LD_INT 5
45017: NEG
45018: PUSH
45019: EMPTY
45020: LIST
45021: LIST
45022: PUSH
45023: LD_INT 6
45025: NEG
45026: PUSH
45027: LD_INT 6
45029: NEG
45030: PUSH
45031: EMPTY
45032: LIST
45033: LIST
45034: PUSH
45035: EMPTY
45036: LIST
45037: LIST
45038: LIST
45039: LIST
45040: LIST
45041: LIST
45042: LIST
45043: LIST
45044: LIST
45045: LIST
45046: LIST
45047: LIST
45048: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
45049: LD_ADDR_VAR 0 41
45053: PUSH
45054: LD_INT 0
45056: PUSH
45057: LD_INT 2
45059: NEG
45060: PUSH
45061: EMPTY
45062: LIST
45063: LIST
45064: PUSH
45065: LD_INT 1
45067: NEG
45068: PUSH
45069: LD_INT 3
45071: NEG
45072: PUSH
45073: EMPTY
45074: LIST
45075: LIST
45076: PUSH
45077: LD_INT 1
45079: PUSH
45080: LD_INT 2
45082: NEG
45083: PUSH
45084: EMPTY
45085: LIST
45086: LIST
45087: PUSH
45088: EMPTY
45089: LIST
45090: LIST
45091: LIST
45092: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
45093: LD_ADDR_VAR 0 42
45097: PUSH
45098: LD_INT 2
45100: PUSH
45101: LD_INT 0
45103: PUSH
45104: EMPTY
45105: LIST
45106: LIST
45107: PUSH
45108: LD_INT 2
45110: PUSH
45111: LD_INT 1
45113: NEG
45114: PUSH
45115: EMPTY
45116: LIST
45117: LIST
45118: PUSH
45119: LD_INT 3
45121: PUSH
45122: LD_INT 1
45124: PUSH
45125: EMPTY
45126: LIST
45127: LIST
45128: PUSH
45129: EMPTY
45130: LIST
45131: LIST
45132: LIST
45133: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
45134: LD_ADDR_VAR 0 43
45138: PUSH
45139: LD_INT 2
45141: PUSH
45142: LD_INT 2
45144: PUSH
45145: EMPTY
45146: LIST
45147: LIST
45148: PUSH
45149: LD_INT 3
45151: PUSH
45152: LD_INT 2
45154: PUSH
45155: EMPTY
45156: LIST
45157: LIST
45158: PUSH
45159: LD_INT 2
45161: PUSH
45162: LD_INT 3
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: PUSH
45169: EMPTY
45170: LIST
45171: LIST
45172: LIST
45173: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
45174: LD_ADDR_VAR 0 44
45178: PUSH
45179: LD_INT 0
45181: PUSH
45182: LD_INT 2
45184: PUSH
45185: EMPTY
45186: LIST
45187: LIST
45188: PUSH
45189: LD_INT 1
45191: PUSH
45192: LD_INT 3
45194: PUSH
45195: EMPTY
45196: LIST
45197: LIST
45198: PUSH
45199: LD_INT 1
45201: NEG
45202: PUSH
45203: LD_INT 2
45205: PUSH
45206: EMPTY
45207: LIST
45208: LIST
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: LIST
45214: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
45215: LD_ADDR_VAR 0 45
45219: PUSH
45220: LD_INT 2
45222: NEG
45223: PUSH
45224: LD_INT 0
45226: PUSH
45227: EMPTY
45228: LIST
45229: LIST
45230: PUSH
45231: LD_INT 2
45233: NEG
45234: PUSH
45235: LD_INT 1
45237: PUSH
45238: EMPTY
45239: LIST
45240: LIST
45241: PUSH
45242: LD_INT 3
45244: NEG
45245: PUSH
45246: LD_INT 1
45248: NEG
45249: PUSH
45250: EMPTY
45251: LIST
45252: LIST
45253: PUSH
45254: EMPTY
45255: LIST
45256: LIST
45257: LIST
45258: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
45259: LD_ADDR_VAR 0 46
45263: PUSH
45264: LD_INT 2
45266: NEG
45267: PUSH
45268: LD_INT 2
45270: NEG
45271: PUSH
45272: EMPTY
45273: LIST
45274: LIST
45275: PUSH
45276: LD_INT 2
45278: NEG
45279: PUSH
45280: LD_INT 3
45282: NEG
45283: PUSH
45284: EMPTY
45285: LIST
45286: LIST
45287: PUSH
45288: LD_INT 3
45290: NEG
45291: PUSH
45292: LD_INT 2
45294: NEG
45295: PUSH
45296: EMPTY
45297: LIST
45298: LIST
45299: PUSH
45300: EMPTY
45301: LIST
45302: LIST
45303: LIST
45304: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
45305: LD_ADDR_VAR 0 47
45309: PUSH
45310: LD_INT 2
45312: NEG
45313: PUSH
45314: LD_INT 3
45316: NEG
45317: PUSH
45318: EMPTY
45319: LIST
45320: LIST
45321: PUSH
45322: LD_INT 1
45324: NEG
45325: PUSH
45326: LD_INT 3
45328: NEG
45329: PUSH
45330: EMPTY
45331: LIST
45332: LIST
45333: PUSH
45334: EMPTY
45335: LIST
45336: LIST
45337: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
45338: LD_ADDR_VAR 0 48
45342: PUSH
45343: LD_INT 1
45345: PUSH
45346: LD_INT 2
45348: NEG
45349: PUSH
45350: EMPTY
45351: LIST
45352: LIST
45353: PUSH
45354: LD_INT 2
45356: PUSH
45357: LD_INT 1
45359: NEG
45360: PUSH
45361: EMPTY
45362: LIST
45363: LIST
45364: PUSH
45365: EMPTY
45366: LIST
45367: LIST
45368: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
45369: LD_ADDR_VAR 0 49
45373: PUSH
45374: LD_INT 3
45376: PUSH
45377: LD_INT 1
45379: PUSH
45380: EMPTY
45381: LIST
45382: LIST
45383: PUSH
45384: LD_INT 3
45386: PUSH
45387: LD_INT 2
45389: PUSH
45390: EMPTY
45391: LIST
45392: LIST
45393: PUSH
45394: EMPTY
45395: LIST
45396: LIST
45397: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
45398: LD_ADDR_VAR 0 50
45402: PUSH
45403: LD_INT 2
45405: PUSH
45406: LD_INT 3
45408: PUSH
45409: EMPTY
45410: LIST
45411: LIST
45412: PUSH
45413: LD_INT 1
45415: PUSH
45416: LD_INT 3
45418: PUSH
45419: EMPTY
45420: LIST
45421: LIST
45422: PUSH
45423: EMPTY
45424: LIST
45425: LIST
45426: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
45427: LD_ADDR_VAR 0 51
45431: PUSH
45432: LD_INT 1
45434: NEG
45435: PUSH
45436: LD_INT 2
45438: PUSH
45439: EMPTY
45440: LIST
45441: LIST
45442: PUSH
45443: LD_INT 2
45445: NEG
45446: PUSH
45447: LD_INT 1
45449: PUSH
45450: EMPTY
45451: LIST
45452: LIST
45453: PUSH
45454: EMPTY
45455: LIST
45456: LIST
45457: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
45458: LD_ADDR_VAR 0 52
45462: PUSH
45463: LD_INT 3
45465: NEG
45466: PUSH
45467: LD_INT 1
45469: NEG
45470: PUSH
45471: EMPTY
45472: LIST
45473: LIST
45474: PUSH
45475: LD_INT 3
45477: NEG
45478: PUSH
45479: LD_INT 2
45481: NEG
45482: PUSH
45483: EMPTY
45484: LIST
45485: LIST
45486: PUSH
45487: EMPTY
45488: LIST
45489: LIST
45490: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45491: LD_ADDR_VAR 0 53
45495: PUSH
45496: LD_INT 1
45498: NEG
45499: PUSH
45500: LD_INT 3
45502: NEG
45503: PUSH
45504: EMPTY
45505: LIST
45506: LIST
45507: PUSH
45508: LD_INT 0
45510: PUSH
45511: LD_INT 3
45513: NEG
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: PUSH
45519: LD_INT 1
45521: PUSH
45522: LD_INT 2
45524: NEG
45525: PUSH
45526: EMPTY
45527: LIST
45528: LIST
45529: PUSH
45530: EMPTY
45531: LIST
45532: LIST
45533: LIST
45534: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45535: LD_ADDR_VAR 0 54
45539: PUSH
45540: LD_INT 2
45542: PUSH
45543: LD_INT 1
45545: NEG
45546: PUSH
45547: EMPTY
45548: LIST
45549: LIST
45550: PUSH
45551: LD_INT 3
45553: PUSH
45554: LD_INT 0
45556: PUSH
45557: EMPTY
45558: LIST
45559: LIST
45560: PUSH
45561: LD_INT 3
45563: PUSH
45564: LD_INT 1
45566: PUSH
45567: EMPTY
45568: LIST
45569: LIST
45570: PUSH
45571: EMPTY
45572: LIST
45573: LIST
45574: LIST
45575: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45576: LD_ADDR_VAR 0 55
45580: PUSH
45581: LD_INT 3
45583: PUSH
45584: LD_INT 2
45586: PUSH
45587: EMPTY
45588: LIST
45589: LIST
45590: PUSH
45591: LD_INT 3
45593: PUSH
45594: LD_INT 3
45596: PUSH
45597: EMPTY
45598: LIST
45599: LIST
45600: PUSH
45601: LD_INT 2
45603: PUSH
45604: LD_INT 3
45606: PUSH
45607: EMPTY
45608: LIST
45609: LIST
45610: PUSH
45611: EMPTY
45612: LIST
45613: LIST
45614: LIST
45615: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45616: LD_ADDR_VAR 0 56
45620: PUSH
45621: LD_INT 1
45623: PUSH
45624: LD_INT 3
45626: PUSH
45627: EMPTY
45628: LIST
45629: LIST
45630: PUSH
45631: LD_INT 0
45633: PUSH
45634: LD_INT 3
45636: PUSH
45637: EMPTY
45638: LIST
45639: LIST
45640: PUSH
45641: LD_INT 1
45643: NEG
45644: PUSH
45645: LD_INT 2
45647: PUSH
45648: EMPTY
45649: LIST
45650: LIST
45651: PUSH
45652: EMPTY
45653: LIST
45654: LIST
45655: LIST
45656: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45657: LD_ADDR_VAR 0 57
45661: PUSH
45662: LD_INT 2
45664: NEG
45665: PUSH
45666: LD_INT 1
45668: PUSH
45669: EMPTY
45670: LIST
45671: LIST
45672: PUSH
45673: LD_INT 3
45675: NEG
45676: PUSH
45677: LD_INT 0
45679: PUSH
45680: EMPTY
45681: LIST
45682: LIST
45683: PUSH
45684: LD_INT 3
45686: NEG
45687: PUSH
45688: LD_INT 1
45690: NEG
45691: PUSH
45692: EMPTY
45693: LIST
45694: LIST
45695: PUSH
45696: EMPTY
45697: LIST
45698: LIST
45699: LIST
45700: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45701: LD_ADDR_VAR 0 58
45705: PUSH
45706: LD_INT 2
45708: NEG
45709: PUSH
45710: LD_INT 3
45712: NEG
45713: PUSH
45714: EMPTY
45715: LIST
45716: LIST
45717: PUSH
45718: LD_INT 3
45720: NEG
45721: PUSH
45722: LD_INT 2
45724: NEG
45725: PUSH
45726: EMPTY
45727: LIST
45728: LIST
45729: PUSH
45730: LD_INT 3
45732: NEG
45733: PUSH
45734: LD_INT 3
45736: NEG
45737: PUSH
45738: EMPTY
45739: LIST
45740: LIST
45741: PUSH
45742: EMPTY
45743: LIST
45744: LIST
45745: LIST
45746: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
45747: LD_ADDR_VAR 0 59
45751: PUSH
45752: LD_INT 1
45754: NEG
45755: PUSH
45756: LD_INT 2
45758: NEG
45759: PUSH
45760: EMPTY
45761: LIST
45762: LIST
45763: PUSH
45764: LD_INT 0
45766: PUSH
45767: LD_INT 2
45769: NEG
45770: PUSH
45771: EMPTY
45772: LIST
45773: LIST
45774: PUSH
45775: LD_INT 1
45777: PUSH
45778: LD_INT 1
45780: NEG
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PUSH
45786: EMPTY
45787: LIST
45788: LIST
45789: LIST
45790: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
45791: LD_ADDR_VAR 0 60
45795: PUSH
45796: LD_INT 1
45798: PUSH
45799: LD_INT 1
45801: NEG
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: PUSH
45807: LD_INT 2
45809: PUSH
45810: LD_INT 0
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: PUSH
45817: LD_INT 2
45819: PUSH
45820: LD_INT 1
45822: PUSH
45823: EMPTY
45824: LIST
45825: LIST
45826: PUSH
45827: EMPTY
45828: LIST
45829: LIST
45830: LIST
45831: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
45832: LD_ADDR_VAR 0 61
45836: PUSH
45837: LD_INT 2
45839: PUSH
45840: LD_INT 1
45842: PUSH
45843: EMPTY
45844: LIST
45845: LIST
45846: PUSH
45847: LD_INT 2
45849: PUSH
45850: LD_INT 2
45852: PUSH
45853: EMPTY
45854: LIST
45855: LIST
45856: PUSH
45857: LD_INT 1
45859: PUSH
45860: LD_INT 2
45862: PUSH
45863: EMPTY
45864: LIST
45865: LIST
45866: PUSH
45867: EMPTY
45868: LIST
45869: LIST
45870: LIST
45871: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
45872: LD_ADDR_VAR 0 62
45876: PUSH
45877: LD_INT 1
45879: PUSH
45880: LD_INT 2
45882: PUSH
45883: EMPTY
45884: LIST
45885: LIST
45886: PUSH
45887: LD_INT 0
45889: PUSH
45890: LD_INT 2
45892: PUSH
45893: EMPTY
45894: LIST
45895: LIST
45896: PUSH
45897: LD_INT 1
45899: NEG
45900: PUSH
45901: LD_INT 1
45903: PUSH
45904: EMPTY
45905: LIST
45906: LIST
45907: PUSH
45908: EMPTY
45909: LIST
45910: LIST
45911: LIST
45912: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
45913: LD_ADDR_VAR 0 63
45917: PUSH
45918: LD_INT 1
45920: NEG
45921: PUSH
45922: LD_INT 1
45924: PUSH
45925: EMPTY
45926: LIST
45927: LIST
45928: PUSH
45929: LD_INT 2
45931: NEG
45932: PUSH
45933: LD_INT 0
45935: PUSH
45936: EMPTY
45937: LIST
45938: LIST
45939: PUSH
45940: LD_INT 2
45942: NEG
45943: PUSH
45944: LD_INT 1
45946: NEG
45947: PUSH
45948: EMPTY
45949: LIST
45950: LIST
45951: PUSH
45952: EMPTY
45953: LIST
45954: LIST
45955: LIST
45956: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45957: LD_ADDR_VAR 0 64
45961: PUSH
45962: LD_INT 1
45964: NEG
45965: PUSH
45966: LD_INT 2
45968: NEG
45969: PUSH
45970: EMPTY
45971: LIST
45972: LIST
45973: PUSH
45974: LD_INT 2
45976: NEG
45977: PUSH
45978: LD_INT 1
45980: NEG
45981: PUSH
45982: EMPTY
45983: LIST
45984: LIST
45985: PUSH
45986: LD_INT 2
45988: NEG
45989: PUSH
45990: LD_INT 2
45992: NEG
45993: PUSH
45994: EMPTY
45995: LIST
45996: LIST
45997: PUSH
45998: EMPTY
45999: LIST
46000: LIST
46001: LIST
46002: ST_TO_ADDR
// end ; 2 :
46003: GO 49269
46005: LD_INT 2
46007: DOUBLE
46008: EQUAL
46009: IFTRUE 46013
46011: GO 49268
46013: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
46014: LD_ADDR_VAR 0 29
46018: PUSH
46019: LD_INT 4
46021: PUSH
46022: LD_INT 0
46024: PUSH
46025: EMPTY
46026: LIST
46027: LIST
46028: PUSH
46029: LD_INT 4
46031: PUSH
46032: LD_INT 1
46034: NEG
46035: PUSH
46036: EMPTY
46037: LIST
46038: LIST
46039: PUSH
46040: LD_INT 5
46042: PUSH
46043: LD_INT 0
46045: PUSH
46046: EMPTY
46047: LIST
46048: LIST
46049: PUSH
46050: LD_INT 5
46052: PUSH
46053: LD_INT 1
46055: PUSH
46056: EMPTY
46057: LIST
46058: LIST
46059: PUSH
46060: LD_INT 4
46062: PUSH
46063: LD_INT 1
46065: PUSH
46066: EMPTY
46067: LIST
46068: LIST
46069: PUSH
46070: LD_INT 3
46072: PUSH
46073: LD_INT 0
46075: PUSH
46076: EMPTY
46077: LIST
46078: LIST
46079: PUSH
46080: LD_INT 3
46082: PUSH
46083: LD_INT 1
46085: NEG
46086: PUSH
46087: EMPTY
46088: LIST
46089: LIST
46090: PUSH
46091: LD_INT 3
46093: PUSH
46094: LD_INT 2
46096: NEG
46097: PUSH
46098: EMPTY
46099: LIST
46100: LIST
46101: PUSH
46102: LD_INT 5
46104: PUSH
46105: LD_INT 2
46107: PUSH
46108: EMPTY
46109: LIST
46110: LIST
46111: PUSH
46112: LD_INT 3
46114: PUSH
46115: LD_INT 3
46117: PUSH
46118: EMPTY
46119: LIST
46120: LIST
46121: PUSH
46122: LD_INT 3
46124: PUSH
46125: LD_INT 2
46127: PUSH
46128: EMPTY
46129: LIST
46130: LIST
46131: PUSH
46132: LD_INT 4
46134: PUSH
46135: LD_INT 3
46137: PUSH
46138: EMPTY
46139: LIST
46140: LIST
46141: PUSH
46142: LD_INT 4
46144: PUSH
46145: LD_INT 4
46147: PUSH
46148: EMPTY
46149: LIST
46150: LIST
46151: PUSH
46152: LD_INT 3
46154: PUSH
46155: LD_INT 4
46157: PUSH
46158: EMPTY
46159: LIST
46160: LIST
46161: PUSH
46162: LD_INT 2
46164: PUSH
46165: LD_INT 3
46167: PUSH
46168: EMPTY
46169: LIST
46170: LIST
46171: PUSH
46172: LD_INT 2
46174: PUSH
46175: LD_INT 2
46177: PUSH
46178: EMPTY
46179: LIST
46180: LIST
46181: PUSH
46182: LD_INT 4
46184: PUSH
46185: LD_INT 2
46187: PUSH
46188: EMPTY
46189: LIST
46190: LIST
46191: PUSH
46192: LD_INT 2
46194: PUSH
46195: LD_INT 4
46197: PUSH
46198: EMPTY
46199: LIST
46200: LIST
46201: PUSH
46202: LD_INT 0
46204: PUSH
46205: LD_INT 4
46207: PUSH
46208: EMPTY
46209: LIST
46210: LIST
46211: PUSH
46212: LD_INT 0
46214: PUSH
46215: LD_INT 3
46217: PUSH
46218: EMPTY
46219: LIST
46220: LIST
46221: PUSH
46222: LD_INT 1
46224: PUSH
46225: LD_INT 4
46227: PUSH
46228: EMPTY
46229: LIST
46230: LIST
46231: PUSH
46232: LD_INT 1
46234: PUSH
46235: LD_INT 5
46237: PUSH
46238: EMPTY
46239: LIST
46240: LIST
46241: PUSH
46242: LD_INT 0
46244: PUSH
46245: LD_INT 5
46247: PUSH
46248: EMPTY
46249: LIST
46250: LIST
46251: PUSH
46252: LD_INT 1
46254: NEG
46255: PUSH
46256: LD_INT 4
46258: PUSH
46259: EMPTY
46260: LIST
46261: LIST
46262: PUSH
46263: LD_INT 1
46265: NEG
46266: PUSH
46267: LD_INT 3
46269: PUSH
46270: EMPTY
46271: LIST
46272: LIST
46273: PUSH
46274: LD_INT 2
46276: PUSH
46277: LD_INT 5
46279: PUSH
46280: EMPTY
46281: LIST
46282: LIST
46283: PUSH
46284: LD_INT 2
46286: NEG
46287: PUSH
46288: LD_INT 3
46290: PUSH
46291: EMPTY
46292: LIST
46293: LIST
46294: PUSH
46295: LD_INT 3
46297: NEG
46298: PUSH
46299: LD_INT 0
46301: PUSH
46302: EMPTY
46303: LIST
46304: LIST
46305: PUSH
46306: LD_INT 3
46308: NEG
46309: PUSH
46310: LD_INT 1
46312: NEG
46313: PUSH
46314: EMPTY
46315: LIST
46316: LIST
46317: PUSH
46318: LD_INT 2
46320: NEG
46321: PUSH
46322: LD_INT 0
46324: PUSH
46325: EMPTY
46326: LIST
46327: LIST
46328: PUSH
46329: LD_INT 2
46331: NEG
46332: PUSH
46333: LD_INT 1
46335: PUSH
46336: EMPTY
46337: LIST
46338: LIST
46339: PUSH
46340: LD_INT 3
46342: NEG
46343: PUSH
46344: LD_INT 1
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 4
46353: NEG
46354: PUSH
46355: LD_INT 0
46357: PUSH
46358: EMPTY
46359: LIST
46360: LIST
46361: PUSH
46362: LD_INT 4
46364: NEG
46365: PUSH
46366: LD_INT 1
46368: NEG
46369: PUSH
46370: EMPTY
46371: LIST
46372: LIST
46373: PUSH
46374: LD_INT 4
46376: NEG
46377: PUSH
46378: LD_INT 2
46380: NEG
46381: PUSH
46382: EMPTY
46383: LIST
46384: LIST
46385: PUSH
46386: LD_INT 2
46388: NEG
46389: PUSH
46390: LD_INT 2
46392: PUSH
46393: EMPTY
46394: LIST
46395: LIST
46396: PUSH
46397: LD_INT 4
46399: NEG
46400: PUSH
46401: LD_INT 4
46403: NEG
46404: PUSH
46405: EMPTY
46406: LIST
46407: LIST
46408: PUSH
46409: LD_INT 4
46411: NEG
46412: PUSH
46413: LD_INT 5
46415: NEG
46416: PUSH
46417: EMPTY
46418: LIST
46419: LIST
46420: PUSH
46421: LD_INT 3
46423: NEG
46424: PUSH
46425: LD_INT 4
46427: NEG
46428: PUSH
46429: EMPTY
46430: LIST
46431: LIST
46432: PUSH
46433: LD_INT 3
46435: NEG
46436: PUSH
46437: LD_INT 3
46439: NEG
46440: PUSH
46441: EMPTY
46442: LIST
46443: LIST
46444: PUSH
46445: LD_INT 4
46447: NEG
46448: PUSH
46449: LD_INT 3
46451: NEG
46452: PUSH
46453: EMPTY
46454: LIST
46455: LIST
46456: PUSH
46457: LD_INT 5
46459: NEG
46460: PUSH
46461: LD_INT 4
46463: NEG
46464: PUSH
46465: EMPTY
46466: LIST
46467: LIST
46468: PUSH
46469: LD_INT 5
46471: NEG
46472: PUSH
46473: LD_INT 5
46475: NEG
46476: PUSH
46477: EMPTY
46478: LIST
46479: LIST
46480: PUSH
46481: LD_INT 3
46483: NEG
46484: PUSH
46485: LD_INT 5
46487: NEG
46488: PUSH
46489: EMPTY
46490: LIST
46491: LIST
46492: PUSH
46493: LD_INT 5
46495: NEG
46496: PUSH
46497: LD_INT 3
46499: NEG
46500: PUSH
46501: EMPTY
46502: LIST
46503: LIST
46504: PUSH
46505: EMPTY
46506: LIST
46507: LIST
46508: LIST
46509: LIST
46510: LIST
46511: LIST
46512: LIST
46513: LIST
46514: LIST
46515: LIST
46516: LIST
46517: LIST
46518: LIST
46519: LIST
46520: LIST
46521: LIST
46522: LIST
46523: LIST
46524: LIST
46525: LIST
46526: LIST
46527: LIST
46528: LIST
46529: LIST
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: LIST
46546: LIST
46547: LIST
46548: LIST
46549: LIST
46550: LIST
46551: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
46552: LD_ADDR_VAR 0 30
46556: PUSH
46557: LD_INT 4
46559: PUSH
46560: LD_INT 4
46562: PUSH
46563: EMPTY
46564: LIST
46565: LIST
46566: PUSH
46567: LD_INT 4
46569: PUSH
46570: LD_INT 3
46572: PUSH
46573: EMPTY
46574: LIST
46575: LIST
46576: PUSH
46577: LD_INT 5
46579: PUSH
46580: LD_INT 4
46582: PUSH
46583: EMPTY
46584: LIST
46585: LIST
46586: PUSH
46587: LD_INT 5
46589: PUSH
46590: LD_INT 5
46592: PUSH
46593: EMPTY
46594: LIST
46595: LIST
46596: PUSH
46597: LD_INT 4
46599: PUSH
46600: LD_INT 5
46602: PUSH
46603: EMPTY
46604: LIST
46605: LIST
46606: PUSH
46607: LD_INT 3
46609: PUSH
46610: LD_INT 4
46612: PUSH
46613: EMPTY
46614: LIST
46615: LIST
46616: PUSH
46617: LD_INT 3
46619: PUSH
46620: LD_INT 3
46622: PUSH
46623: EMPTY
46624: LIST
46625: LIST
46626: PUSH
46627: LD_INT 5
46629: PUSH
46630: LD_INT 3
46632: PUSH
46633: EMPTY
46634: LIST
46635: LIST
46636: PUSH
46637: LD_INT 3
46639: PUSH
46640: LD_INT 5
46642: PUSH
46643: EMPTY
46644: LIST
46645: LIST
46646: PUSH
46647: LD_INT 0
46649: PUSH
46650: LD_INT 3
46652: PUSH
46653: EMPTY
46654: LIST
46655: LIST
46656: PUSH
46657: LD_INT 0
46659: PUSH
46660: LD_INT 2
46662: PUSH
46663: EMPTY
46664: LIST
46665: LIST
46666: PUSH
46667: LD_INT 1
46669: PUSH
46670: LD_INT 3
46672: PUSH
46673: EMPTY
46674: LIST
46675: LIST
46676: PUSH
46677: LD_INT 1
46679: PUSH
46680: LD_INT 4
46682: PUSH
46683: EMPTY
46684: LIST
46685: LIST
46686: PUSH
46687: LD_INT 0
46689: PUSH
46690: LD_INT 4
46692: PUSH
46693: EMPTY
46694: LIST
46695: LIST
46696: PUSH
46697: LD_INT 1
46699: NEG
46700: PUSH
46701: LD_INT 3
46703: PUSH
46704: EMPTY
46705: LIST
46706: LIST
46707: PUSH
46708: LD_INT 1
46710: NEG
46711: PUSH
46712: LD_INT 2
46714: PUSH
46715: EMPTY
46716: LIST
46717: LIST
46718: PUSH
46719: LD_INT 2
46721: PUSH
46722: LD_INT 4
46724: PUSH
46725: EMPTY
46726: LIST
46727: LIST
46728: PUSH
46729: LD_INT 2
46731: NEG
46732: PUSH
46733: LD_INT 2
46735: PUSH
46736: EMPTY
46737: LIST
46738: LIST
46739: PUSH
46740: LD_INT 4
46742: NEG
46743: PUSH
46744: LD_INT 0
46746: PUSH
46747: EMPTY
46748: LIST
46749: LIST
46750: PUSH
46751: LD_INT 4
46753: NEG
46754: PUSH
46755: LD_INT 1
46757: NEG
46758: PUSH
46759: EMPTY
46760: LIST
46761: LIST
46762: PUSH
46763: LD_INT 3
46765: NEG
46766: PUSH
46767: LD_INT 0
46769: PUSH
46770: EMPTY
46771: LIST
46772: LIST
46773: PUSH
46774: LD_INT 3
46776: NEG
46777: PUSH
46778: LD_INT 1
46780: PUSH
46781: EMPTY
46782: LIST
46783: LIST
46784: PUSH
46785: LD_INT 4
46787: NEG
46788: PUSH
46789: LD_INT 1
46791: PUSH
46792: EMPTY
46793: LIST
46794: LIST
46795: PUSH
46796: LD_INT 5
46798: NEG
46799: PUSH
46800: LD_INT 0
46802: PUSH
46803: EMPTY
46804: LIST
46805: LIST
46806: PUSH
46807: LD_INT 5
46809: NEG
46810: PUSH
46811: LD_INT 1
46813: NEG
46814: PUSH
46815: EMPTY
46816: LIST
46817: LIST
46818: PUSH
46819: LD_INT 5
46821: NEG
46822: PUSH
46823: LD_INT 2
46825: NEG
46826: PUSH
46827: EMPTY
46828: LIST
46829: LIST
46830: PUSH
46831: LD_INT 3
46833: NEG
46834: PUSH
46835: LD_INT 2
46837: PUSH
46838: EMPTY
46839: LIST
46840: LIST
46841: PUSH
46842: LD_INT 3
46844: NEG
46845: PUSH
46846: LD_INT 3
46848: NEG
46849: PUSH
46850: EMPTY
46851: LIST
46852: LIST
46853: PUSH
46854: LD_INT 3
46856: NEG
46857: PUSH
46858: LD_INT 4
46860: NEG
46861: PUSH
46862: EMPTY
46863: LIST
46864: LIST
46865: PUSH
46866: LD_INT 2
46868: NEG
46869: PUSH
46870: LD_INT 3
46872: NEG
46873: PUSH
46874: EMPTY
46875: LIST
46876: LIST
46877: PUSH
46878: LD_INT 2
46880: NEG
46881: PUSH
46882: LD_INT 2
46884: NEG
46885: PUSH
46886: EMPTY
46887: LIST
46888: LIST
46889: PUSH
46890: LD_INT 3
46892: NEG
46893: PUSH
46894: LD_INT 2
46896: NEG
46897: PUSH
46898: EMPTY
46899: LIST
46900: LIST
46901: PUSH
46902: LD_INT 4
46904: NEG
46905: PUSH
46906: LD_INT 3
46908: NEG
46909: PUSH
46910: EMPTY
46911: LIST
46912: LIST
46913: PUSH
46914: LD_INT 4
46916: NEG
46917: PUSH
46918: LD_INT 4
46920: NEG
46921: PUSH
46922: EMPTY
46923: LIST
46924: LIST
46925: PUSH
46926: LD_INT 2
46928: NEG
46929: PUSH
46930: LD_INT 4
46932: NEG
46933: PUSH
46934: EMPTY
46935: LIST
46936: LIST
46937: PUSH
46938: LD_INT 4
46940: NEG
46941: PUSH
46942: LD_INT 2
46944: NEG
46945: PUSH
46946: EMPTY
46947: LIST
46948: LIST
46949: PUSH
46950: LD_INT 0
46952: PUSH
46953: LD_INT 4
46955: NEG
46956: PUSH
46957: EMPTY
46958: LIST
46959: LIST
46960: PUSH
46961: LD_INT 0
46963: PUSH
46964: LD_INT 5
46966: NEG
46967: PUSH
46968: EMPTY
46969: LIST
46970: LIST
46971: PUSH
46972: LD_INT 1
46974: PUSH
46975: LD_INT 4
46977: NEG
46978: PUSH
46979: EMPTY
46980: LIST
46981: LIST
46982: PUSH
46983: LD_INT 1
46985: PUSH
46986: LD_INT 3
46988: NEG
46989: PUSH
46990: EMPTY
46991: LIST
46992: LIST
46993: PUSH
46994: LD_INT 0
46996: PUSH
46997: LD_INT 3
46999: NEG
47000: PUSH
47001: EMPTY
47002: LIST
47003: LIST
47004: PUSH
47005: LD_INT 1
47007: NEG
47008: PUSH
47009: LD_INT 4
47011: NEG
47012: PUSH
47013: EMPTY
47014: LIST
47015: LIST
47016: PUSH
47017: LD_INT 1
47019: NEG
47020: PUSH
47021: LD_INT 5
47023: NEG
47024: PUSH
47025: EMPTY
47026: LIST
47027: LIST
47028: PUSH
47029: LD_INT 2
47031: PUSH
47032: LD_INT 3
47034: NEG
47035: PUSH
47036: EMPTY
47037: LIST
47038: LIST
47039: PUSH
47040: LD_INT 2
47042: NEG
47043: PUSH
47044: LD_INT 5
47046: NEG
47047: PUSH
47048: EMPTY
47049: LIST
47050: LIST
47051: PUSH
47052: EMPTY
47053: LIST
47054: LIST
47055: LIST
47056: LIST
47057: LIST
47058: LIST
47059: LIST
47060: LIST
47061: LIST
47062: LIST
47063: LIST
47064: LIST
47065: LIST
47066: LIST
47067: LIST
47068: LIST
47069: LIST
47070: LIST
47071: LIST
47072: LIST
47073: LIST
47074: LIST
47075: LIST
47076: LIST
47077: LIST
47078: LIST
47079: LIST
47080: LIST
47081: LIST
47082: LIST
47083: LIST
47084: LIST
47085: LIST
47086: LIST
47087: LIST
47088: LIST
47089: LIST
47090: LIST
47091: LIST
47092: LIST
47093: LIST
47094: LIST
47095: LIST
47096: LIST
47097: LIST
47098: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
47099: LD_ADDR_VAR 0 31
47103: PUSH
47104: LD_INT 0
47106: PUSH
47107: LD_INT 4
47109: PUSH
47110: EMPTY
47111: LIST
47112: LIST
47113: PUSH
47114: LD_INT 0
47116: PUSH
47117: LD_INT 3
47119: PUSH
47120: EMPTY
47121: LIST
47122: LIST
47123: PUSH
47124: LD_INT 1
47126: PUSH
47127: LD_INT 4
47129: PUSH
47130: EMPTY
47131: LIST
47132: LIST
47133: PUSH
47134: LD_INT 1
47136: PUSH
47137: LD_INT 5
47139: PUSH
47140: EMPTY
47141: LIST
47142: LIST
47143: PUSH
47144: LD_INT 0
47146: PUSH
47147: LD_INT 5
47149: PUSH
47150: EMPTY
47151: LIST
47152: LIST
47153: PUSH
47154: LD_INT 1
47156: NEG
47157: PUSH
47158: LD_INT 4
47160: PUSH
47161: EMPTY
47162: LIST
47163: LIST
47164: PUSH
47165: LD_INT 1
47167: NEG
47168: PUSH
47169: LD_INT 3
47171: PUSH
47172: EMPTY
47173: LIST
47174: LIST
47175: PUSH
47176: LD_INT 2
47178: PUSH
47179: LD_INT 5
47181: PUSH
47182: EMPTY
47183: LIST
47184: LIST
47185: PUSH
47186: LD_INT 2
47188: NEG
47189: PUSH
47190: LD_INT 3
47192: PUSH
47193: EMPTY
47194: LIST
47195: LIST
47196: PUSH
47197: LD_INT 3
47199: NEG
47200: PUSH
47201: LD_INT 0
47203: PUSH
47204: EMPTY
47205: LIST
47206: LIST
47207: PUSH
47208: LD_INT 3
47210: NEG
47211: PUSH
47212: LD_INT 1
47214: NEG
47215: PUSH
47216: EMPTY
47217: LIST
47218: LIST
47219: PUSH
47220: LD_INT 2
47222: NEG
47223: PUSH
47224: LD_INT 0
47226: PUSH
47227: EMPTY
47228: LIST
47229: LIST
47230: PUSH
47231: LD_INT 2
47233: NEG
47234: PUSH
47235: LD_INT 1
47237: PUSH
47238: EMPTY
47239: LIST
47240: LIST
47241: PUSH
47242: LD_INT 3
47244: NEG
47245: PUSH
47246: LD_INT 1
47248: PUSH
47249: EMPTY
47250: LIST
47251: LIST
47252: PUSH
47253: LD_INT 4
47255: NEG
47256: PUSH
47257: LD_INT 0
47259: PUSH
47260: EMPTY
47261: LIST
47262: LIST
47263: PUSH
47264: LD_INT 4
47266: NEG
47267: PUSH
47268: LD_INT 1
47270: NEG
47271: PUSH
47272: EMPTY
47273: LIST
47274: LIST
47275: PUSH
47276: LD_INT 4
47278: NEG
47279: PUSH
47280: LD_INT 2
47282: NEG
47283: PUSH
47284: EMPTY
47285: LIST
47286: LIST
47287: PUSH
47288: LD_INT 2
47290: NEG
47291: PUSH
47292: LD_INT 2
47294: PUSH
47295: EMPTY
47296: LIST
47297: LIST
47298: PUSH
47299: LD_INT 4
47301: NEG
47302: PUSH
47303: LD_INT 4
47305: NEG
47306: PUSH
47307: EMPTY
47308: LIST
47309: LIST
47310: PUSH
47311: LD_INT 4
47313: NEG
47314: PUSH
47315: LD_INT 5
47317: NEG
47318: PUSH
47319: EMPTY
47320: LIST
47321: LIST
47322: PUSH
47323: LD_INT 3
47325: NEG
47326: PUSH
47327: LD_INT 4
47329: NEG
47330: PUSH
47331: EMPTY
47332: LIST
47333: LIST
47334: PUSH
47335: LD_INT 3
47337: NEG
47338: PUSH
47339: LD_INT 3
47341: NEG
47342: PUSH
47343: EMPTY
47344: LIST
47345: LIST
47346: PUSH
47347: LD_INT 4
47349: NEG
47350: PUSH
47351: LD_INT 3
47353: NEG
47354: PUSH
47355: EMPTY
47356: LIST
47357: LIST
47358: PUSH
47359: LD_INT 5
47361: NEG
47362: PUSH
47363: LD_INT 4
47365: NEG
47366: PUSH
47367: EMPTY
47368: LIST
47369: LIST
47370: PUSH
47371: LD_INT 5
47373: NEG
47374: PUSH
47375: LD_INT 5
47377: NEG
47378: PUSH
47379: EMPTY
47380: LIST
47381: LIST
47382: PUSH
47383: LD_INT 3
47385: NEG
47386: PUSH
47387: LD_INT 5
47389: NEG
47390: PUSH
47391: EMPTY
47392: LIST
47393: LIST
47394: PUSH
47395: LD_INT 5
47397: NEG
47398: PUSH
47399: LD_INT 3
47401: NEG
47402: PUSH
47403: EMPTY
47404: LIST
47405: LIST
47406: PUSH
47407: LD_INT 0
47409: PUSH
47410: LD_INT 3
47412: NEG
47413: PUSH
47414: EMPTY
47415: LIST
47416: LIST
47417: PUSH
47418: LD_INT 0
47420: PUSH
47421: LD_INT 4
47423: NEG
47424: PUSH
47425: EMPTY
47426: LIST
47427: LIST
47428: PUSH
47429: LD_INT 1
47431: PUSH
47432: LD_INT 3
47434: NEG
47435: PUSH
47436: EMPTY
47437: LIST
47438: LIST
47439: PUSH
47440: LD_INT 1
47442: PUSH
47443: LD_INT 2
47445: NEG
47446: PUSH
47447: EMPTY
47448: LIST
47449: LIST
47450: PUSH
47451: LD_INT 0
47453: PUSH
47454: LD_INT 2
47456: NEG
47457: PUSH
47458: EMPTY
47459: LIST
47460: LIST
47461: PUSH
47462: LD_INT 1
47464: NEG
47465: PUSH
47466: LD_INT 3
47468: NEG
47469: PUSH
47470: EMPTY
47471: LIST
47472: LIST
47473: PUSH
47474: LD_INT 1
47476: NEG
47477: PUSH
47478: LD_INT 4
47480: NEG
47481: PUSH
47482: EMPTY
47483: LIST
47484: LIST
47485: PUSH
47486: LD_INT 2
47488: PUSH
47489: LD_INT 2
47491: NEG
47492: PUSH
47493: EMPTY
47494: LIST
47495: LIST
47496: PUSH
47497: LD_INT 2
47499: NEG
47500: PUSH
47501: LD_INT 4
47503: NEG
47504: PUSH
47505: EMPTY
47506: LIST
47507: LIST
47508: PUSH
47509: LD_INT 4
47511: PUSH
47512: LD_INT 0
47514: PUSH
47515: EMPTY
47516: LIST
47517: LIST
47518: PUSH
47519: LD_INT 4
47521: PUSH
47522: LD_INT 1
47524: NEG
47525: PUSH
47526: EMPTY
47527: LIST
47528: LIST
47529: PUSH
47530: LD_INT 5
47532: PUSH
47533: LD_INT 0
47535: PUSH
47536: EMPTY
47537: LIST
47538: LIST
47539: PUSH
47540: LD_INT 5
47542: PUSH
47543: LD_INT 1
47545: PUSH
47546: EMPTY
47547: LIST
47548: LIST
47549: PUSH
47550: LD_INT 4
47552: PUSH
47553: LD_INT 1
47555: PUSH
47556: EMPTY
47557: LIST
47558: LIST
47559: PUSH
47560: LD_INT 3
47562: PUSH
47563: LD_INT 0
47565: PUSH
47566: EMPTY
47567: LIST
47568: LIST
47569: PUSH
47570: LD_INT 3
47572: PUSH
47573: LD_INT 1
47575: NEG
47576: PUSH
47577: EMPTY
47578: LIST
47579: LIST
47580: PUSH
47581: LD_INT 3
47583: PUSH
47584: LD_INT 2
47586: NEG
47587: PUSH
47588: EMPTY
47589: LIST
47590: LIST
47591: PUSH
47592: LD_INT 5
47594: PUSH
47595: LD_INT 2
47597: PUSH
47598: EMPTY
47599: LIST
47600: LIST
47601: PUSH
47602: EMPTY
47603: LIST
47604: LIST
47605: LIST
47606: LIST
47607: LIST
47608: LIST
47609: LIST
47610: LIST
47611: LIST
47612: LIST
47613: LIST
47614: LIST
47615: LIST
47616: LIST
47617: LIST
47618: LIST
47619: LIST
47620: LIST
47621: LIST
47622: LIST
47623: LIST
47624: LIST
47625: LIST
47626: LIST
47627: LIST
47628: LIST
47629: LIST
47630: LIST
47631: LIST
47632: LIST
47633: LIST
47634: LIST
47635: LIST
47636: LIST
47637: LIST
47638: LIST
47639: LIST
47640: LIST
47641: LIST
47642: LIST
47643: LIST
47644: LIST
47645: LIST
47646: LIST
47647: LIST
47648: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
47649: LD_ADDR_VAR 0 32
47653: PUSH
47654: LD_INT 4
47656: NEG
47657: PUSH
47658: LD_INT 0
47660: PUSH
47661: EMPTY
47662: LIST
47663: LIST
47664: PUSH
47665: LD_INT 4
47667: NEG
47668: PUSH
47669: LD_INT 1
47671: NEG
47672: PUSH
47673: EMPTY
47674: LIST
47675: LIST
47676: PUSH
47677: LD_INT 3
47679: NEG
47680: PUSH
47681: LD_INT 0
47683: PUSH
47684: EMPTY
47685: LIST
47686: LIST
47687: PUSH
47688: LD_INT 3
47690: NEG
47691: PUSH
47692: LD_INT 1
47694: PUSH
47695: EMPTY
47696: LIST
47697: LIST
47698: PUSH
47699: LD_INT 4
47701: NEG
47702: PUSH
47703: LD_INT 1
47705: PUSH
47706: EMPTY
47707: LIST
47708: LIST
47709: PUSH
47710: LD_INT 5
47712: NEG
47713: PUSH
47714: LD_INT 0
47716: PUSH
47717: EMPTY
47718: LIST
47719: LIST
47720: PUSH
47721: LD_INT 5
47723: NEG
47724: PUSH
47725: LD_INT 1
47727: NEG
47728: PUSH
47729: EMPTY
47730: LIST
47731: LIST
47732: PUSH
47733: LD_INT 5
47735: NEG
47736: PUSH
47737: LD_INT 2
47739: NEG
47740: PUSH
47741: EMPTY
47742: LIST
47743: LIST
47744: PUSH
47745: LD_INT 3
47747: NEG
47748: PUSH
47749: LD_INT 2
47751: PUSH
47752: EMPTY
47753: LIST
47754: LIST
47755: PUSH
47756: LD_INT 3
47758: NEG
47759: PUSH
47760: LD_INT 3
47762: NEG
47763: PUSH
47764: EMPTY
47765: LIST
47766: LIST
47767: PUSH
47768: LD_INT 3
47770: NEG
47771: PUSH
47772: LD_INT 4
47774: NEG
47775: PUSH
47776: EMPTY
47777: LIST
47778: LIST
47779: PUSH
47780: LD_INT 2
47782: NEG
47783: PUSH
47784: LD_INT 3
47786: NEG
47787: PUSH
47788: EMPTY
47789: LIST
47790: LIST
47791: PUSH
47792: LD_INT 2
47794: NEG
47795: PUSH
47796: LD_INT 2
47798: NEG
47799: PUSH
47800: EMPTY
47801: LIST
47802: LIST
47803: PUSH
47804: LD_INT 3
47806: NEG
47807: PUSH
47808: LD_INT 2
47810: NEG
47811: PUSH
47812: EMPTY
47813: LIST
47814: LIST
47815: PUSH
47816: LD_INT 4
47818: NEG
47819: PUSH
47820: LD_INT 3
47822: NEG
47823: PUSH
47824: EMPTY
47825: LIST
47826: LIST
47827: PUSH
47828: LD_INT 4
47830: NEG
47831: PUSH
47832: LD_INT 4
47834: NEG
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: PUSH
47840: LD_INT 2
47842: NEG
47843: PUSH
47844: LD_INT 4
47846: NEG
47847: PUSH
47848: EMPTY
47849: LIST
47850: LIST
47851: PUSH
47852: LD_INT 4
47854: NEG
47855: PUSH
47856: LD_INT 2
47858: NEG
47859: PUSH
47860: EMPTY
47861: LIST
47862: LIST
47863: PUSH
47864: LD_INT 0
47866: PUSH
47867: LD_INT 4
47869: NEG
47870: PUSH
47871: EMPTY
47872: LIST
47873: LIST
47874: PUSH
47875: LD_INT 0
47877: PUSH
47878: LD_INT 5
47880: NEG
47881: PUSH
47882: EMPTY
47883: LIST
47884: LIST
47885: PUSH
47886: LD_INT 1
47888: PUSH
47889: LD_INT 4
47891: NEG
47892: PUSH
47893: EMPTY
47894: LIST
47895: LIST
47896: PUSH
47897: LD_INT 1
47899: PUSH
47900: LD_INT 3
47902: NEG
47903: PUSH
47904: EMPTY
47905: LIST
47906: LIST
47907: PUSH
47908: LD_INT 0
47910: PUSH
47911: LD_INT 3
47913: NEG
47914: PUSH
47915: EMPTY
47916: LIST
47917: LIST
47918: PUSH
47919: LD_INT 1
47921: NEG
47922: PUSH
47923: LD_INT 4
47925: NEG
47926: PUSH
47927: EMPTY
47928: LIST
47929: LIST
47930: PUSH
47931: LD_INT 1
47933: NEG
47934: PUSH
47935: LD_INT 5
47937: NEG
47938: PUSH
47939: EMPTY
47940: LIST
47941: LIST
47942: PUSH
47943: LD_INT 2
47945: PUSH
47946: LD_INT 3
47948: NEG
47949: PUSH
47950: EMPTY
47951: LIST
47952: LIST
47953: PUSH
47954: LD_INT 2
47956: NEG
47957: PUSH
47958: LD_INT 5
47960: NEG
47961: PUSH
47962: EMPTY
47963: LIST
47964: LIST
47965: PUSH
47966: LD_INT 3
47968: PUSH
47969: LD_INT 0
47971: PUSH
47972: EMPTY
47973: LIST
47974: LIST
47975: PUSH
47976: LD_INT 3
47978: PUSH
47979: LD_INT 1
47981: NEG
47982: PUSH
47983: EMPTY
47984: LIST
47985: LIST
47986: PUSH
47987: LD_INT 4
47989: PUSH
47990: LD_INT 0
47992: PUSH
47993: EMPTY
47994: LIST
47995: LIST
47996: PUSH
47997: LD_INT 4
47999: PUSH
48000: LD_INT 1
48002: PUSH
48003: EMPTY
48004: LIST
48005: LIST
48006: PUSH
48007: LD_INT 3
48009: PUSH
48010: LD_INT 1
48012: PUSH
48013: EMPTY
48014: LIST
48015: LIST
48016: PUSH
48017: LD_INT 2
48019: PUSH
48020: LD_INT 0
48022: PUSH
48023: EMPTY
48024: LIST
48025: LIST
48026: PUSH
48027: LD_INT 2
48029: PUSH
48030: LD_INT 1
48032: NEG
48033: PUSH
48034: EMPTY
48035: LIST
48036: LIST
48037: PUSH
48038: LD_INT 2
48040: PUSH
48041: LD_INT 2
48043: NEG
48044: PUSH
48045: EMPTY
48046: LIST
48047: LIST
48048: PUSH
48049: LD_INT 4
48051: PUSH
48052: LD_INT 2
48054: PUSH
48055: EMPTY
48056: LIST
48057: LIST
48058: PUSH
48059: LD_INT 4
48061: PUSH
48062: LD_INT 4
48064: PUSH
48065: EMPTY
48066: LIST
48067: LIST
48068: PUSH
48069: LD_INT 4
48071: PUSH
48072: LD_INT 3
48074: PUSH
48075: EMPTY
48076: LIST
48077: LIST
48078: PUSH
48079: LD_INT 5
48081: PUSH
48082: LD_INT 4
48084: PUSH
48085: EMPTY
48086: LIST
48087: LIST
48088: PUSH
48089: LD_INT 5
48091: PUSH
48092: LD_INT 5
48094: PUSH
48095: EMPTY
48096: LIST
48097: LIST
48098: PUSH
48099: LD_INT 4
48101: PUSH
48102: LD_INT 5
48104: PUSH
48105: EMPTY
48106: LIST
48107: LIST
48108: PUSH
48109: LD_INT 3
48111: PUSH
48112: LD_INT 4
48114: PUSH
48115: EMPTY
48116: LIST
48117: LIST
48118: PUSH
48119: LD_INT 3
48121: PUSH
48122: LD_INT 3
48124: PUSH
48125: EMPTY
48126: LIST
48127: LIST
48128: PUSH
48129: LD_INT 5
48131: PUSH
48132: LD_INT 3
48134: PUSH
48135: EMPTY
48136: LIST
48137: LIST
48138: PUSH
48139: LD_INT 3
48141: PUSH
48142: LD_INT 5
48144: PUSH
48145: EMPTY
48146: LIST
48147: LIST
48148: PUSH
48149: EMPTY
48150: LIST
48151: LIST
48152: LIST
48153: LIST
48154: LIST
48155: LIST
48156: LIST
48157: LIST
48158: LIST
48159: LIST
48160: LIST
48161: LIST
48162: LIST
48163: LIST
48164: LIST
48165: LIST
48166: LIST
48167: LIST
48168: LIST
48169: LIST
48170: LIST
48171: LIST
48172: LIST
48173: LIST
48174: LIST
48175: LIST
48176: LIST
48177: LIST
48178: LIST
48179: LIST
48180: LIST
48181: LIST
48182: LIST
48183: LIST
48184: LIST
48185: LIST
48186: LIST
48187: LIST
48188: LIST
48189: LIST
48190: LIST
48191: LIST
48192: LIST
48193: LIST
48194: LIST
48195: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
48196: LD_ADDR_VAR 0 33
48200: PUSH
48201: LD_INT 4
48203: NEG
48204: PUSH
48205: LD_INT 4
48207: NEG
48208: PUSH
48209: EMPTY
48210: LIST
48211: LIST
48212: PUSH
48213: LD_INT 4
48215: NEG
48216: PUSH
48217: LD_INT 5
48219: NEG
48220: PUSH
48221: EMPTY
48222: LIST
48223: LIST
48224: PUSH
48225: LD_INT 3
48227: NEG
48228: PUSH
48229: LD_INT 4
48231: NEG
48232: PUSH
48233: EMPTY
48234: LIST
48235: LIST
48236: PUSH
48237: LD_INT 3
48239: NEG
48240: PUSH
48241: LD_INT 3
48243: NEG
48244: PUSH
48245: EMPTY
48246: LIST
48247: LIST
48248: PUSH
48249: LD_INT 4
48251: NEG
48252: PUSH
48253: LD_INT 3
48255: NEG
48256: PUSH
48257: EMPTY
48258: LIST
48259: LIST
48260: PUSH
48261: LD_INT 5
48263: NEG
48264: PUSH
48265: LD_INT 4
48267: NEG
48268: PUSH
48269: EMPTY
48270: LIST
48271: LIST
48272: PUSH
48273: LD_INT 5
48275: NEG
48276: PUSH
48277: LD_INT 5
48279: NEG
48280: PUSH
48281: EMPTY
48282: LIST
48283: LIST
48284: PUSH
48285: LD_INT 3
48287: NEG
48288: PUSH
48289: LD_INT 5
48291: NEG
48292: PUSH
48293: EMPTY
48294: LIST
48295: LIST
48296: PUSH
48297: LD_INT 5
48299: NEG
48300: PUSH
48301: LD_INT 3
48303: NEG
48304: PUSH
48305: EMPTY
48306: LIST
48307: LIST
48308: PUSH
48309: LD_INT 0
48311: PUSH
48312: LD_INT 3
48314: NEG
48315: PUSH
48316: EMPTY
48317: LIST
48318: LIST
48319: PUSH
48320: LD_INT 0
48322: PUSH
48323: LD_INT 4
48325: NEG
48326: PUSH
48327: EMPTY
48328: LIST
48329: LIST
48330: PUSH
48331: LD_INT 1
48333: PUSH
48334: LD_INT 3
48336: NEG
48337: PUSH
48338: EMPTY
48339: LIST
48340: LIST
48341: PUSH
48342: LD_INT 1
48344: PUSH
48345: LD_INT 2
48347: NEG
48348: PUSH
48349: EMPTY
48350: LIST
48351: LIST
48352: PUSH
48353: LD_INT 0
48355: PUSH
48356: LD_INT 2
48358: NEG
48359: PUSH
48360: EMPTY
48361: LIST
48362: LIST
48363: PUSH
48364: LD_INT 1
48366: NEG
48367: PUSH
48368: LD_INT 3
48370: NEG
48371: PUSH
48372: EMPTY
48373: LIST
48374: LIST
48375: PUSH
48376: LD_INT 1
48378: NEG
48379: PUSH
48380: LD_INT 4
48382: NEG
48383: PUSH
48384: EMPTY
48385: LIST
48386: LIST
48387: PUSH
48388: LD_INT 2
48390: PUSH
48391: LD_INT 2
48393: NEG
48394: PUSH
48395: EMPTY
48396: LIST
48397: LIST
48398: PUSH
48399: LD_INT 2
48401: NEG
48402: PUSH
48403: LD_INT 4
48405: NEG
48406: PUSH
48407: EMPTY
48408: LIST
48409: LIST
48410: PUSH
48411: LD_INT 4
48413: PUSH
48414: LD_INT 0
48416: PUSH
48417: EMPTY
48418: LIST
48419: LIST
48420: PUSH
48421: LD_INT 4
48423: PUSH
48424: LD_INT 1
48426: NEG
48427: PUSH
48428: EMPTY
48429: LIST
48430: LIST
48431: PUSH
48432: LD_INT 5
48434: PUSH
48435: LD_INT 0
48437: PUSH
48438: EMPTY
48439: LIST
48440: LIST
48441: PUSH
48442: LD_INT 5
48444: PUSH
48445: LD_INT 1
48447: PUSH
48448: EMPTY
48449: LIST
48450: LIST
48451: PUSH
48452: LD_INT 4
48454: PUSH
48455: LD_INT 1
48457: PUSH
48458: EMPTY
48459: LIST
48460: LIST
48461: PUSH
48462: LD_INT 3
48464: PUSH
48465: LD_INT 0
48467: PUSH
48468: EMPTY
48469: LIST
48470: LIST
48471: PUSH
48472: LD_INT 3
48474: PUSH
48475: LD_INT 1
48477: NEG
48478: PUSH
48479: EMPTY
48480: LIST
48481: LIST
48482: PUSH
48483: LD_INT 3
48485: PUSH
48486: LD_INT 2
48488: NEG
48489: PUSH
48490: EMPTY
48491: LIST
48492: LIST
48493: PUSH
48494: LD_INT 5
48496: PUSH
48497: LD_INT 2
48499: PUSH
48500: EMPTY
48501: LIST
48502: LIST
48503: PUSH
48504: LD_INT 3
48506: PUSH
48507: LD_INT 3
48509: PUSH
48510: EMPTY
48511: LIST
48512: LIST
48513: PUSH
48514: LD_INT 3
48516: PUSH
48517: LD_INT 2
48519: PUSH
48520: EMPTY
48521: LIST
48522: LIST
48523: PUSH
48524: LD_INT 4
48526: PUSH
48527: LD_INT 3
48529: PUSH
48530: EMPTY
48531: LIST
48532: LIST
48533: PUSH
48534: LD_INT 4
48536: PUSH
48537: LD_INT 4
48539: PUSH
48540: EMPTY
48541: LIST
48542: LIST
48543: PUSH
48544: LD_INT 3
48546: PUSH
48547: LD_INT 4
48549: PUSH
48550: EMPTY
48551: LIST
48552: LIST
48553: PUSH
48554: LD_INT 2
48556: PUSH
48557: LD_INT 3
48559: PUSH
48560: EMPTY
48561: LIST
48562: LIST
48563: PUSH
48564: LD_INT 2
48566: PUSH
48567: LD_INT 2
48569: PUSH
48570: EMPTY
48571: LIST
48572: LIST
48573: PUSH
48574: LD_INT 4
48576: PUSH
48577: LD_INT 2
48579: PUSH
48580: EMPTY
48581: LIST
48582: LIST
48583: PUSH
48584: LD_INT 2
48586: PUSH
48587: LD_INT 4
48589: PUSH
48590: EMPTY
48591: LIST
48592: LIST
48593: PUSH
48594: LD_INT 0
48596: PUSH
48597: LD_INT 4
48599: PUSH
48600: EMPTY
48601: LIST
48602: LIST
48603: PUSH
48604: LD_INT 0
48606: PUSH
48607: LD_INT 3
48609: PUSH
48610: EMPTY
48611: LIST
48612: LIST
48613: PUSH
48614: LD_INT 1
48616: PUSH
48617: LD_INT 4
48619: PUSH
48620: EMPTY
48621: LIST
48622: LIST
48623: PUSH
48624: LD_INT 1
48626: PUSH
48627: LD_INT 5
48629: PUSH
48630: EMPTY
48631: LIST
48632: LIST
48633: PUSH
48634: LD_INT 0
48636: PUSH
48637: LD_INT 5
48639: PUSH
48640: EMPTY
48641: LIST
48642: LIST
48643: PUSH
48644: LD_INT 1
48646: NEG
48647: PUSH
48648: LD_INT 4
48650: PUSH
48651: EMPTY
48652: LIST
48653: LIST
48654: PUSH
48655: LD_INT 1
48657: NEG
48658: PUSH
48659: LD_INT 3
48661: PUSH
48662: EMPTY
48663: LIST
48664: LIST
48665: PUSH
48666: LD_INT 2
48668: PUSH
48669: LD_INT 5
48671: PUSH
48672: EMPTY
48673: LIST
48674: LIST
48675: PUSH
48676: LD_INT 2
48678: NEG
48679: PUSH
48680: LD_INT 3
48682: PUSH
48683: EMPTY
48684: LIST
48685: LIST
48686: PUSH
48687: EMPTY
48688: LIST
48689: LIST
48690: LIST
48691: LIST
48692: LIST
48693: LIST
48694: LIST
48695: LIST
48696: LIST
48697: LIST
48698: LIST
48699: LIST
48700: LIST
48701: LIST
48702: LIST
48703: LIST
48704: LIST
48705: LIST
48706: LIST
48707: LIST
48708: LIST
48709: LIST
48710: LIST
48711: LIST
48712: LIST
48713: LIST
48714: LIST
48715: LIST
48716: LIST
48717: LIST
48718: LIST
48719: LIST
48720: LIST
48721: LIST
48722: LIST
48723: LIST
48724: LIST
48725: LIST
48726: LIST
48727: LIST
48728: LIST
48729: LIST
48730: LIST
48731: LIST
48732: LIST
48733: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
48734: LD_ADDR_VAR 0 34
48738: PUSH
48739: LD_INT 0
48741: PUSH
48742: LD_INT 4
48744: NEG
48745: PUSH
48746: EMPTY
48747: LIST
48748: LIST
48749: PUSH
48750: LD_INT 0
48752: PUSH
48753: LD_INT 5
48755: NEG
48756: PUSH
48757: EMPTY
48758: LIST
48759: LIST
48760: PUSH
48761: LD_INT 1
48763: PUSH
48764: LD_INT 4
48766: NEG
48767: PUSH
48768: EMPTY
48769: LIST
48770: LIST
48771: PUSH
48772: LD_INT 1
48774: PUSH
48775: LD_INT 3
48777: NEG
48778: PUSH
48779: EMPTY
48780: LIST
48781: LIST
48782: PUSH
48783: LD_INT 0
48785: PUSH
48786: LD_INT 3
48788: NEG
48789: PUSH
48790: EMPTY
48791: LIST
48792: LIST
48793: PUSH
48794: LD_INT 1
48796: NEG
48797: PUSH
48798: LD_INT 4
48800: NEG
48801: PUSH
48802: EMPTY
48803: LIST
48804: LIST
48805: PUSH
48806: LD_INT 1
48808: NEG
48809: PUSH
48810: LD_INT 5
48812: NEG
48813: PUSH
48814: EMPTY
48815: LIST
48816: LIST
48817: PUSH
48818: LD_INT 2
48820: PUSH
48821: LD_INT 3
48823: NEG
48824: PUSH
48825: EMPTY
48826: LIST
48827: LIST
48828: PUSH
48829: LD_INT 2
48831: NEG
48832: PUSH
48833: LD_INT 5
48835: NEG
48836: PUSH
48837: EMPTY
48838: LIST
48839: LIST
48840: PUSH
48841: LD_INT 3
48843: PUSH
48844: LD_INT 0
48846: PUSH
48847: EMPTY
48848: LIST
48849: LIST
48850: PUSH
48851: LD_INT 3
48853: PUSH
48854: LD_INT 1
48856: NEG
48857: PUSH
48858: EMPTY
48859: LIST
48860: LIST
48861: PUSH
48862: LD_INT 4
48864: PUSH
48865: LD_INT 0
48867: PUSH
48868: EMPTY
48869: LIST
48870: LIST
48871: PUSH
48872: LD_INT 4
48874: PUSH
48875: LD_INT 1
48877: PUSH
48878: EMPTY
48879: LIST
48880: LIST
48881: PUSH
48882: LD_INT 3
48884: PUSH
48885: LD_INT 1
48887: PUSH
48888: EMPTY
48889: LIST
48890: LIST
48891: PUSH
48892: LD_INT 2
48894: PUSH
48895: LD_INT 0
48897: PUSH
48898: EMPTY
48899: LIST
48900: LIST
48901: PUSH
48902: LD_INT 2
48904: PUSH
48905: LD_INT 1
48907: NEG
48908: PUSH
48909: EMPTY
48910: LIST
48911: LIST
48912: PUSH
48913: LD_INT 2
48915: PUSH
48916: LD_INT 2
48918: NEG
48919: PUSH
48920: EMPTY
48921: LIST
48922: LIST
48923: PUSH
48924: LD_INT 4
48926: PUSH
48927: LD_INT 2
48929: PUSH
48930: EMPTY
48931: LIST
48932: LIST
48933: PUSH
48934: LD_INT 4
48936: PUSH
48937: LD_INT 4
48939: PUSH
48940: EMPTY
48941: LIST
48942: LIST
48943: PUSH
48944: LD_INT 4
48946: PUSH
48947: LD_INT 3
48949: PUSH
48950: EMPTY
48951: LIST
48952: LIST
48953: PUSH
48954: LD_INT 5
48956: PUSH
48957: LD_INT 4
48959: PUSH
48960: EMPTY
48961: LIST
48962: LIST
48963: PUSH
48964: LD_INT 5
48966: PUSH
48967: LD_INT 5
48969: PUSH
48970: EMPTY
48971: LIST
48972: LIST
48973: PUSH
48974: LD_INT 4
48976: PUSH
48977: LD_INT 5
48979: PUSH
48980: EMPTY
48981: LIST
48982: LIST
48983: PUSH
48984: LD_INT 3
48986: PUSH
48987: LD_INT 4
48989: PUSH
48990: EMPTY
48991: LIST
48992: LIST
48993: PUSH
48994: LD_INT 3
48996: PUSH
48997: LD_INT 3
48999: PUSH
49000: EMPTY
49001: LIST
49002: LIST
49003: PUSH
49004: LD_INT 5
49006: PUSH
49007: LD_INT 3
49009: PUSH
49010: EMPTY
49011: LIST
49012: LIST
49013: PUSH
49014: LD_INT 3
49016: PUSH
49017: LD_INT 5
49019: PUSH
49020: EMPTY
49021: LIST
49022: LIST
49023: PUSH
49024: LD_INT 0
49026: PUSH
49027: LD_INT 3
49029: PUSH
49030: EMPTY
49031: LIST
49032: LIST
49033: PUSH
49034: LD_INT 0
49036: PUSH
49037: LD_INT 2
49039: PUSH
49040: EMPTY
49041: LIST
49042: LIST
49043: PUSH
49044: LD_INT 1
49046: PUSH
49047: LD_INT 3
49049: PUSH
49050: EMPTY
49051: LIST
49052: LIST
49053: PUSH
49054: LD_INT 1
49056: PUSH
49057: LD_INT 4
49059: PUSH
49060: EMPTY
49061: LIST
49062: LIST
49063: PUSH
49064: LD_INT 0
49066: PUSH
49067: LD_INT 4
49069: PUSH
49070: EMPTY
49071: LIST
49072: LIST
49073: PUSH
49074: LD_INT 1
49076: NEG
49077: PUSH
49078: LD_INT 3
49080: PUSH
49081: EMPTY
49082: LIST
49083: LIST
49084: PUSH
49085: LD_INT 1
49087: NEG
49088: PUSH
49089: LD_INT 2
49091: PUSH
49092: EMPTY
49093: LIST
49094: LIST
49095: PUSH
49096: LD_INT 2
49098: PUSH
49099: LD_INT 4
49101: PUSH
49102: EMPTY
49103: LIST
49104: LIST
49105: PUSH
49106: LD_INT 2
49108: NEG
49109: PUSH
49110: LD_INT 2
49112: PUSH
49113: EMPTY
49114: LIST
49115: LIST
49116: PUSH
49117: LD_INT 4
49119: NEG
49120: PUSH
49121: LD_INT 0
49123: PUSH
49124: EMPTY
49125: LIST
49126: LIST
49127: PUSH
49128: LD_INT 4
49130: NEG
49131: PUSH
49132: LD_INT 1
49134: NEG
49135: PUSH
49136: EMPTY
49137: LIST
49138: LIST
49139: PUSH
49140: LD_INT 3
49142: NEG
49143: PUSH
49144: LD_INT 0
49146: PUSH
49147: EMPTY
49148: LIST
49149: LIST
49150: PUSH
49151: LD_INT 3
49153: NEG
49154: PUSH
49155: LD_INT 1
49157: PUSH
49158: EMPTY
49159: LIST
49160: LIST
49161: PUSH
49162: LD_INT 4
49164: NEG
49165: PUSH
49166: LD_INT 1
49168: PUSH
49169: EMPTY
49170: LIST
49171: LIST
49172: PUSH
49173: LD_INT 5
49175: NEG
49176: PUSH
49177: LD_INT 0
49179: PUSH
49180: EMPTY
49181: LIST
49182: LIST
49183: PUSH
49184: LD_INT 5
49186: NEG
49187: PUSH
49188: LD_INT 1
49190: NEG
49191: PUSH
49192: EMPTY
49193: LIST
49194: LIST
49195: PUSH
49196: LD_INT 5
49198: NEG
49199: PUSH
49200: LD_INT 2
49202: NEG
49203: PUSH
49204: EMPTY
49205: LIST
49206: LIST
49207: PUSH
49208: LD_INT 3
49210: NEG
49211: PUSH
49212: LD_INT 2
49214: PUSH
49215: EMPTY
49216: LIST
49217: LIST
49218: PUSH
49219: EMPTY
49220: LIST
49221: LIST
49222: LIST
49223: LIST
49224: LIST
49225: LIST
49226: LIST
49227: LIST
49228: LIST
49229: LIST
49230: LIST
49231: LIST
49232: LIST
49233: LIST
49234: LIST
49235: LIST
49236: LIST
49237: LIST
49238: LIST
49239: LIST
49240: LIST
49241: LIST
49242: LIST
49243: LIST
49244: LIST
49245: LIST
49246: LIST
49247: LIST
49248: LIST
49249: LIST
49250: LIST
49251: LIST
49252: LIST
49253: LIST
49254: LIST
49255: LIST
49256: LIST
49257: LIST
49258: LIST
49259: LIST
49260: LIST
49261: LIST
49262: LIST
49263: LIST
49264: LIST
49265: ST_TO_ADDR
// end ; end ;
49266: GO 49269
49268: POP
// case btype of b_depot , b_warehouse :
49269: LD_VAR 0 1
49273: PUSH
49274: LD_INT 0
49276: DOUBLE
49277: EQUAL
49278: IFTRUE 49288
49280: LD_INT 1
49282: DOUBLE
49283: EQUAL
49284: IFTRUE 49288
49286: GO 49489
49288: POP
// case nation of nation_american :
49289: LD_VAR 0 5
49293: PUSH
49294: LD_INT 1
49296: DOUBLE
49297: EQUAL
49298: IFTRUE 49302
49300: GO 49358
49302: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
49303: LD_ADDR_VAR 0 9
49307: PUSH
49308: LD_VAR 0 11
49312: PUSH
49313: LD_VAR 0 12
49317: PUSH
49318: LD_VAR 0 13
49322: PUSH
49323: LD_VAR 0 14
49327: PUSH
49328: LD_VAR 0 15
49332: PUSH
49333: LD_VAR 0 16
49337: PUSH
49338: EMPTY
49339: LIST
49340: LIST
49341: LIST
49342: LIST
49343: LIST
49344: LIST
49345: PUSH
49346: LD_VAR 0 4
49350: PUSH
49351: LD_INT 1
49353: PLUS
49354: ARRAY
49355: ST_TO_ADDR
49356: GO 49487
49358: LD_INT 2
49360: DOUBLE
49361: EQUAL
49362: IFTRUE 49366
49364: GO 49422
49366: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
49367: LD_ADDR_VAR 0 9
49371: PUSH
49372: LD_VAR 0 17
49376: PUSH
49377: LD_VAR 0 18
49381: PUSH
49382: LD_VAR 0 19
49386: PUSH
49387: LD_VAR 0 20
49391: PUSH
49392: LD_VAR 0 21
49396: PUSH
49397: LD_VAR 0 22
49401: PUSH
49402: EMPTY
49403: LIST
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: LIST
49409: PUSH
49410: LD_VAR 0 4
49414: PUSH
49415: LD_INT 1
49417: PLUS
49418: ARRAY
49419: ST_TO_ADDR
49420: GO 49487
49422: LD_INT 3
49424: DOUBLE
49425: EQUAL
49426: IFTRUE 49430
49428: GO 49486
49430: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
49431: LD_ADDR_VAR 0 9
49435: PUSH
49436: LD_VAR 0 23
49440: PUSH
49441: LD_VAR 0 24
49445: PUSH
49446: LD_VAR 0 25
49450: PUSH
49451: LD_VAR 0 26
49455: PUSH
49456: LD_VAR 0 27
49460: PUSH
49461: LD_VAR 0 28
49465: PUSH
49466: EMPTY
49467: LIST
49468: LIST
49469: LIST
49470: LIST
49471: LIST
49472: LIST
49473: PUSH
49474: LD_VAR 0 4
49478: PUSH
49479: LD_INT 1
49481: PLUS
49482: ARRAY
49483: ST_TO_ADDR
49484: GO 49487
49486: POP
49487: GO 50042
49489: LD_INT 2
49491: DOUBLE
49492: EQUAL
49493: IFTRUE 49503
49495: LD_INT 3
49497: DOUBLE
49498: EQUAL
49499: IFTRUE 49503
49501: GO 49559
49503: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
49504: LD_ADDR_VAR 0 9
49508: PUSH
49509: LD_VAR 0 29
49513: PUSH
49514: LD_VAR 0 30
49518: PUSH
49519: LD_VAR 0 31
49523: PUSH
49524: LD_VAR 0 32
49528: PUSH
49529: LD_VAR 0 33
49533: PUSH
49534: LD_VAR 0 34
49538: PUSH
49539: EMPTY
49540: LIST
49541: LIST
49542: LIST
49543: LIST
49544: LIST
49545: LIST
49546: PUSH
49547: LD_VAR 0 4
49551: PUSH
49552: LD_INT 1
49554: PLUS
49555: ARRAY
49556: ST_TO_ADDR
49557: GO 50042
49559: LD_INT 16
49561: DOUBLE
49562: EQUAL
49563: IFTRUE 49621
49565: LD_INT 17
49567: DOUBLE
49568: EQUAL
49569: IFTRUE 49621
49571: LD_INT 18
49573: DOUBLE
49574: EQUAL
49575: IFTRUE 49621
49577: LD_INT 19
49579: DOUBLE
49580: EQUAL
49581: IFTRUE 49621
49583: LD_INT 22
49585: DOUBLE
49586: EQUAL
49587: IFTRUE 49621
49589: LD_INT 20
49591: DOUBLE
49592: EQUAL
49593: IFTRUE 49621
49595: LD_INT 21
49597: DOUBLE
49598: EQUAL
49599: IFTRUE 49621
49601: LD_INT 23
49603: DOUBLE
49604: EQUAL
49605: IFTRUE 49621
49607: LD_INT 24
49609: DOUBLE
49610: EQUAL
49611: IFTRUE 49621
49613: LD_INT 25
49615: DOUBLE
49616: EQUAL
49617: IFTRUE 49621
49619: GO 49677
49621: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
49622: LD_ADDR_VAR 0 9
49626: PUSH
49627: LD_VAR 0 35
49631: PUSH
49632: LD_VAR 0 36
49636: PUSH
49637: LD_VAR 0 37
49641: PUSH
49642: LD_VAR 0 38
49646: PUSH
49647: LD_VAR 0 39
49651: PUSH
49652: LD_VAR 0 40
49656: PUSH
49657: EMPTY
49658: LIST
49659: LIST
49660: LIST
49661: LIST
49662: LIST
49663: LIST
49664: PUSH
49665: LD_VAR 0 4
49669: PUSH
49670: LD_INT 1
49672: PLUS
49673: ARRAY
49674: ST_TO_ADDR
49675: GO 50042
49677: LD_INT 6
49679: DOUBLE
49680: EQUAL
49681: IFTRUE 49733
49683: LD_INT 7
49685: DOUBLE
49686: EQUAL
49687: IFTRUE 49733
49689: LD_INT 8
49691: DOUBLE
49692: EQUAL
49693: IFTRUE 49733
49695: LD_INT 13
49697: DOUBLE
49698: EQUAL
49699: IFTRUE 49733
49701: LD_INT 12
49703: DOUBLE
49704: EQUAL
49705: IFTRUE 49733
49707: LD_INT 15
49709: DOUBLE
49710: EQUAL
49711: IFTRUE 49733
49713: LD_INT 11
49715: DOUBLE
49716: EQUAL
49717: IFTRUE 49733
49719: LD_INT 14
49721: DOUBLE
49722: EQUAL
49723: IFTRUE 49733
49725: LD_INT 10
49727: DOUBLE
49728: EQUAL
49729: IFTRUE 49733
49731: GO 49789
49733: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
49734: LD_ADDR_VAR 0 9
49738: PUSH
49739: LD_VAR 0 41
49743: PUSH
49744: LD_VAR 0 42
49748: PUSH
49749: LD_VAR 0 43
49753: PUSH
49754: LD_VAR 0 44
49758: PUSH
49759: LD_VAR 0 45
49763: PUSH
49764: LD_VAR 0 46
49768: PUSH
49769: EMPTY
49770: LIST
49771: LIST
49772: LIST
49773: LIST
49774: LIST
49775: LIST
49776: PUSH
49777: LD_VAR 0 4
49781: PUSH
49782: LD_INT 1
49784: PLUS
49785: ARRAY
49786: ST_TO_ADDR
49787: GO 50042
49789: LD_INT 36
49791: DOUBLE
49792: EQUAL
49793: IFTRUE 49797
49795: GO 49853
49797: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
49798: LD_ADDR_VAR 0 9
49802: PUSH
49803: LD_VAR 0 47
49807: PUSH
49808: LD_VAR 0 48
49812: PUSH
49813: LD_VAR 0 49
49817: PUSH
49818: LD_VAR 0 50
49822: PUSH
49823: LD_VAR 0 51
49827: PUSH
49828: LD_VAR 0 52
49832: PUSH
49833: EMPTY
49834: LIST
49835: LIST
49836: LIST
49837: LIST
49838: LIST
49839: LIST
49840: PUSH
49841: LD_VAR 0 4
49845: PUSH
49846: LD_INT 1
49848: PLUS
49849: ARRAY
49850: ST_TO_ADDR
49851: GO 50042
49853: LD_INT 4
49855: DOUBLE
49856: EQUAL
49857: IFTRUE 49879
49859: LD_INT 5
49861: DOUBLE
49862: EQUAL
49863: IFTRUE 49879
49865: LD_INT 34
49867: DOUBLE
49868: EQUAL
49869: IFTRUE 49879
49871: LD_INT 37
49873: DOUBLE
49874: EQUAL
49875: IFTRUE 49879
49877: GO 49935
49879: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
49880: LD_ADDR_VAR 0 9
49884: PUSH
49885: LD_VAR 0 53
49889: PUSH
49890: LD_VAR 0 54
49894: PUSH
49895: LD_VAR 0 55
49899: PUSH
49900: LD_VAR 0 56
49904: PUSH
49905: LD_VAR 0 57
49909: PUSH
49910: LD_VAR 0 58
49914: PUSH
49915: EMPTY
49916: LIST
49917: LIST
49918: LIST
49919: LIST
49920: LIST
49921: LIST
49922: PUSH
49923: LD_VAR 0 4
49927: PUSH
49928: LD_INT 1
49930: PLUS
49931: ARRAY
49932: ST_TO_ADDR
49933: GO 50042
49935: LD_INT 31
49937: DOUBLE
49938: EQUAL
49939: IFTRUE 49985
49941: LD_INT 32
49943: DOUBLE
49944: EQUAL
49945: IFTRUE 49985
49947: LD_INT 33
49949: DOUBLE
49950: EQUAL
49951: IFTRUE 49985
49953: LD_INT 27
49955: DOUBLE
49956: EQUAL
49957: IFTRUE 49985
49959: LD_INT 26
49961: DOUBLE
49962: EQUAL
49963: IFTRUE 49985
49965: LD_INT 28
49967: DOUBLE
49968: EQUAL
49969: IFTRUE 49985
49971: LD_INT 29
49973: DOUBLE
49974: EQUAL
49975: IFTRUE 49985
49977: LD_INT 30
49979: DOUBLE
49980: EQUAL
49981: IFTRUE 49985
49983: GO 50041
49985: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
49986: LD_ADDR_VAR 0 9
49990: PUSH
49991: LD_VAR 0 59
49995: PUSH
49996: LD_VAR 0 60
50000: PUSH
50001: LD_VAR 0 61
50005: PUSH
50006: LD_VAR 0 62
50010: PUSH
50011: LD_VAR 0 63
50015: PUSH
50016: LD_VAR 0 64
50020: PUSH
50021: EMPTY
50022: LIST
50023: LIST
50024: LIST
50025: LIST
50026: LIST
50027: LIST
50028: PUSH
50029: LD_VAR 0 4
50033: PUSH
50034: LD_INT 1
50036: PLUS
50037: ARRAY
50038: ST_TO_ADDR
50039: GO 50042
50041: POP
// temp_list2 = [ ] ;
50042: LD_ADDR_VAR 0 10
50046: PUSH
50047: EMPTY
50048: ST_TO_ADDR
// for i in temp_list do
50049: LD_ADDR_VAR 0 8
50053: PUSH
50054: LD_VAR 0 9
50058: PUSH
50059: FOR_IN
50060: IFFALSE 50112
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
50062: LD_ADDR_VAR 0 10
50066: PUSH
50067: LD_VAR 0 10
50071: PUSH
50072: LD_VAR 0 8
50076: PUSH
50077: LD_INT 1
50079: ARRAY
50080: PUSH
50081: LD_VAR 0 2
50085: PLUS
50086: PUSH
50087: LD_VAR 0 8
50091: PUSH
50092: LD_INT 2
50094: ARRAY
50095: PUSH
50096: LD_VAR 0 3
50100: PLUS
50101: PUSH
50102: EMPTY
50103: LIST
50104: LIST
50105: PUSH
50106: EMPTY
50107: LIST
50108: ADD
50109: ST_TO_ADDR
50110: GO 50059
50112: POP
50113: POP
// result = temp_list2 ;
50114: LD_ADDR_VAR 0 7
50118: PUSH
50119: LD_VAR 0 10
50123: ST_TO_ADDR
// end ;
50124: LD_VAR 0 7
50128: RET
// export function EnemyInRange ( unit , dist ) ; begin
50129: LD_INT 0
50131: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
50132: LD_ADDR_VAR 0 3
50136: PUSH
50137: LD_VAR 0 1
50141: PPUSH
50142: CALL_OW 255
50146: PPUSH
50147: LD_VAR 0 1
50151: PPUSH
50152: CALL_OW 250
50156: PPUSH
50157: LD_VAR 0 1
50161: PPUSH
50162: CALL_OW 251
50166: PPUSH
50167: LD_VAR 0 2
50171: PPUSH
50172: CALL 23502 0 4
50176: PUSH
50177: LD_INT 4
50179: ARRAY
50180: ST_TO_ADDR
// end ;
50181: LD_VAR 0 3
50185: RET
// export function PlayerSeeMe ( unit ) ; begin
50186: LD_INT 0
50188: PPUSH
// result := See ( your_side , unit ) ;
50189: LD_ADDR_VAR 0 2
50193: PUSH
50194: LD_OWVAR 2
50198: PPUSH
50199: LD_VAR 0 1
50203: PPUSH
50204: CALL_OW 292
50208: ST_TO_ADDR
// end ;
50209: LD_VAR 0 2
50213: RET
// export function ReverseDir ( unit ) ; begin
50214: LD_INT 0
50216: PPUSH
// if not unit then
50217: LD_VAR 0 1
50221: NOT
50222: IFFALSE 50226
// exit ;
50224: GO 50249
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
50226: LD_ADDR_VAR 0 2
50230: PUSH
50231: LD_VAR 0 1
50235: PPUSH
50236: CALL_OW 254
50240: PUSH
50241: LD_INT 3
50243: PLUS
50244: PUSH
50245: LD_INT 6
50247: MOD
50248: ST_TO_ADDR
// end ;
50249: LD_VAR 0 2
50253: RET
// export function ReverseArray ( array ) ; var i ; begin
50254: LD_INT 0
50256: PPUSH
50257: PPUSH
// if not array then
50258: LD_VAR 0 1
50262: NOT
50263: IFFALSE 50267
// exit ;
50265: GO 50322
// result := [ ] ;
50267: LD_ADDR_VAR 0 2
50271: PUSH
50272: EMPTY
50273: ST_TO_ADDR
// for i := array downto 1 do
50274: LD_ADDR_VAR 0 3
50278: PUSH
50279: DOUBLE
50280: LD_VAR 0 1
50284: INC
50285: ST_TO_ADDR
50286: LD_INT 1
50288: PUSH
50289: FOR_DOWNTO
50290: IFFALSE 50320
// result := Join ( result , array [ i ] ) ;
50292: LD_ADDR_VAR 0 2
50296: PUSH
50297: LD_VAR 0 2
50301: PPUSH
50302: LD_VAR 0 1
50306: PUSH
50307: LD_VAR 0 3
50311: ARRAY
50312: PPUSH
50313: CALL 54967 0 2
50317: ST_TO_ADDR
50318: GO 50289
50320: POP
50321: POP
// end ;
50322: LD_VAR 0 2
50326: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
50327: LD_INT 0
50329: PPUSH
50330: PPUSH
50331: PPUSH
50332: PPUSH
50333: PPUSH
50334: PPUSH
// if not unit or not hexes then
50335: LD_VAR 0 1
50339: NOT
50340: PUSH
50341: LD_VAR 0 2
50345: NOT
50346: OR
50347: IFFALSE 50351
// exit ;
50349: GO 50474
// dist := 9999 ;
50351: LD_ADDR_VAR 0 5
50355: PUSH
50356: LD_INT 9999
50358: ST_TO_ADDR
// for i = 1 to hexes do
50359: LD_ADDR_VAR 0 4
50363: PUSH
50364: DOUBLE
50365: LD_INT 1
50367: DEC
50368: ST_TO_ADDR
50369: LD_VAR 0 2
50373: PUSH
50374: FOR_TO
50375: IFFALSE 50462
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
50377: LD_ADDR_VAR 0 6
50381: PUSH
50382: LD_VAR 0 1
50386: PPUSH
50387: LD_VAR 0 2
50391: PUSH
50392: LD_VAR 0 4
50396: ARRAY
50397: PUSH
50398: LD_INT 1
50400: ARRAY
50401: PPUSH
50402: LD_VAR 0 2
50406: PUSH
50407: LD_VAR 0 4
50411: ARRAY
50412: PUSH
50413: LD_INT 2
50415: ARRAY
50416: PPUSH
50417: CALL_OW 297
50421: ST_TO_ADDR
// if tdist < dist then
50422: LD_VAR 0 6
50426: PUSH
50427: LD_VAR 0 5
50431: LESS
50432: IFFALSE 50460
// begin hex := hexes [ i ] ;
50434: LD_ADDR_VAR 0 8
50438: PUSH
50439: LD_VAR 0 2
50443: PUSH
50444: LD_VAR 0 4
50448: ARRAY
50449: ST_TO_ADDR
// dist := tdist ;
50450: LD_ADDR_VAR 0 5
50454: PUSH
50455: LD_VAR 0 6
50459: ST_TO_ADDR
// end ; end ;
50460: GO 50374
50462: POP
50463: POP
// result := hex ;
50464: LD_ADDR_VAR 0 3
50468: PUSH
50469: LD_VAR 0 8
50473: ST_TO_ADDR
// end ;
50474: LD_VAR 0 3
50478: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
50479: LD_INT 0
50481: PPUSH
50482: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
50483: LD_VAR 0 1
50487: NOT
50488: PUSH
50489: LD_VAR 0 1
50493: PUSH
50494: LD_INT 21
50496: PUSH
50497: LD_INT 2
50499: PUSH
50500: EMPTY
50501: LIST
50502: LIST
50503: PUSH
50504: LD_INT 23
50506: PUSH
50507: LD_INT 2
50509: PUSH
50510: EMPTY
50511: LIST
50512: LIST
50513: PUSH
50514: EMPTY
50515: LIST
50516: LIST
50517: PPUSH
50518: CALL_OW 69
50522: IN
50523: NOT
50524: OR
50525: IFFALSE 50529
// exit ;
50527: GO 50576
// for i = 1 to 3 do
50529: LD_ADDR_VAR 0 3
50533: PUSH
50534: DOUBLE
50535: LD_INT 1
50537: DEC
50538: ST_TO_ADDR
50539: LD_INT 3
50541: PUSH
50542: FOR_TO
50543: IFFALSE 50574
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
50545: LD_VAR 0 1
50549: PPUSH
50550: CALL_OW 250
50554: PPUSH
50555: LD_VAR 0 1
50559: PPUSH
50560: CALL_OW 251
50564: PPUSH
50565: LD_INT 1
50567: PPUSH
50568: CALL_OW 453
50572: GO 50542
50574: POP
50575: POP
// end ;
50576: LD_VAR 0 2
50580: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
50581: LD_INT 0
50583: PPUSH
50584: PPUSH
50585: PPUSH
50586: PPUSH
50587: PPUSH
50588: PPUSH
// if not unit or not enemy_unit then
50589: LD_VAR 0 1
50593: NOT
50594: PUSH
50595: LD_VAR 0 2
50599: NOT
50600: OR
50601: IFFALSE 50605
// exit ;
50603: GO 51072
// if GetLives ( i ) < 250 then
50605: LD_VAR 0 4
50609: PPUSH
50610: CALL_OW 256
50614: PUSH
50615: LD_INT 250
50617: LESS
50618: IFFALSE 50631
// begin ComAutodestruct ( i ) ;
50620: LD_VAR 0 4
50624: PPUSH
50625: CALL 50479 0 1
// exit ;
50629: GO 51072
// end ; x := GetX ( enemy_unit ) ;
50631: LD_ADDR_VAR 0 7
50635: PUSH
50636: LD_VAR 0 2
50640: PPUSH
50641: CALL_OW 250
50645: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
50646: LD_ADDR_VAR 0 8
50650: PUSH
50651: LD_VAR 0 2
50655: PPUSH
50656: CALL_OW 251
50660: ST_TO_ADDR
// if not x or not y then
50661: LD_VAR 0 7
50665: NOT
50666: PUSH
50667: LD_VAR 0 8
50671: NOT
50672: OR
50673: IFFALSE 50677
// exit ;
50675: GO 51072
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
50677: LD_ADDR_VAR 0 6
50681: PUSH
50682: LD_VAR 0 7
50686: PPUSH
50687: LD_INT 0
50689: PPUSH
50690: LD_INT 4
50692: PPUSH
50693: CALL_OW 272
50697: PUSH
50698: LD_VAR 0 8
50702: PPUSH
50703: LD_INT 0
50705: PPUSH
50706: LD_INT 4
50708: PPUSH
50709: CALL_OW 273
50713: PUSH
50714: EMPTY
50715: LIST
50716: LIST
50717: PUSH
50718: LD_VAR 0 7
50722: PPUSH
50723: LD_INT 1
50725: PPUSH
50726: LD_INT 4
50728: PPUSH
50729: CALL_OW 272
50733: PUSH
50734: LD_VAR 0 8
50738: PPUSH
50739: LD_INT 1
50741: PPUSH
50742: LD_INT 4
50744: PPUSH
50745: CALL_OW 273
50749: PUSH
50750: EMPTY
50751: LIST
50752: LIST
50753: PUSH
50754: LD_VAR 0 7
50758: PPUSH
50759: LD_INT 2
50761: PPUSH
50762: LD_INT 4
50764: PPUSH
50765: CALL_OW 272
50769: PUSH
50770: LD_VAR 0 8
50774: PPUSH
50775: LD_INT 2
50777: PPUSH
50778: LD_INT 4
50780: PPUSH
50781: CALL_OW 273
50785: PUSH
50786: EMPTY
50787: LIST
50788: LIST
50789: PUSH
50790: LD_VAR 0 7
50794: PPUSH
50795: LD_INT 3
50797: PPUSH
50798: LD_INT 4
50800: PPUSH
50801: CALL_OW 272
50805: PUSH
50806: LD_VAR 0 8
50810: PPUSH
50811: LD_INT 3
50813: PPUSH
50814: LD_INT 4
50816: PPUSH
50817: CALL_OW 273
50821: PUSH
50822: EMPTY
50823: LIST
50824: LIST
50825: PUSH
50826: LD_VAR 0 7
50830: PPUSH
50831: LD_INT 4
50833: PPUSH
50834: LD_INT 4
50836: PPUSH
50837: CALL_OW 272
50841: PUSH
50842: LD_VAR 0 8
50846: PPUSH
50847: LD_INT 4
50849: PPUSH
50850: LD_INT 4
50852: PPUSH
50853: CALL_OW 273
50857: PUSH
50858: EMPTY
50859: LIST
50860: LIST
50861: PUSH
50862: LD_VAR 0 7
50866: PPUSH
50867: LD_INT 5
50869: PPUSH
50870: LD_INT 4
50872: PPUSH
50873: CALL_OW 272
50877: PUSH
50878: LD_VAR 0 8
50882: PPUSH
50883: LD_INT 5
50885: PPUSH
50886: LD_INT 4
50888: PPUSH
50889: CALL_OW 273
50893: PUSH
50894: EMPTY
50895: LIST
50896: LIST
50897: PUSH
50898: EMPTY
50899: LIST
50900: LIST
50901: LIST
50902: LIST
50903: LIST
50904: LIST
50905: ST_TO_ADDR
// for i = tmp downto 1 do
50906: LD_ADDR_VAR 0 4
50910: PUSH
50911: DOUBLE
50912: LD_VAR 0 6
50916: INC
50917: ST_TO_ADDR
50918: LD_INT 1
50920: PUSH
50921: FOR_DOWNTO
50922: IFFALSE 51023
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
50924: LD_VAR 0 6
50928: PUSH
50929: LD_VAR 0 4
50933: ARRAY
50934: PUSH
50935: LD_INT 1
50937: ARRAY
50938: PPUSH
50939: LD_VAR 0 6
50943: PUSH
50944: LD_VAR 0 4
50948: ARRAY
50949: PUSH
50950: LD_INT 2
50952: ARRAY
50953: PPUSH
50954: CALL_OW 488
50958: NOT
50959: PUSH
50960: LD_VAR 0 6
50964: PUSH
50965: LD_VAR 0 4
50969: ARRAY
50970: PUSH
50971: LD_INT 1
50973: ARRAY
50974: PPUSH
50975: LD_VAR 0 6
50979: PUSH
50980: LD_VAR 0 4
50984: ARRAY
50985: PUSH
50986: LD_INT 2
50988: ARRAY
50989: PPUSH
50990: CALL_OW 428
50994: PUSH
50995: LD_INT 0
50997: NONEQUAL
50998: OR
50999: IFFALSE 51021
// tmp := Delete ( tmp , i ) ;
51001: LD_ADDR_VAR 0 6
51005: PUSH
51006: LD_VAR 0 6
51010: PPUSH
51011: LD_VAR 0 4
51015: PPUSH
51016: CALL_OW 3
51020: ST_TO_ADDR
51021: GO 50921
51023: POP
51024: POP
// j := GetClosestHex ( unit , tmp ) ;
51025: LD_ADDR_VAR 0 5
51029: PUSH
51030: LD_VAR 0 1
51034: PPUSH
51035: LD_VAR 0 6
51039: PPUSH
51040: CALL 50327 0 2
51044: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
51045: LD_VAR 0 1
51049: PPUSH
51050: LD_VAR 0 5
51054: PUSH
51055: LD_INT 1
51057: ARRAY
51058: PPUSH
51059: LD_VAR 0 5
51063: PUSH
51064: LD_INT 2
51066: ARRAY
51067: PPUSH
51068: CALL_OW 111
// end ;
51072: LD_VAR 0 3
51076: RET
// export function PrepareApemanSoldier ( ) ; begin
51077: LD_INT 0
51079: PPUSH
// uc_nation := 0 ;
51080: LD_ADDR_OWVAR 21
51084: PUSH
51085: LD_INT 0
51087: ST_TO_ADDR
// hc_sex := sex_male ;
51088: LD_ADDR_OWVAR 27
51092: PUSH
51093: LD_INT 1
51095: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
51096: LD_ADDR_OWVAR 28
51100: PUSH
51101: LD_INT 15
51103: ST_TO_ADDR
// hc_gallery :=  ;
51104: LD_ADDR_OWVAR 33
51108: PUSH
51109: LD_STRING 
51111: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
51112: LD_ADDR_OWVAR 31
51116: PUSH
51117: LD_INT 0
51119: PPUSH
51120: LD_INT 3
51122: PPUSH
51123: CALL_OW 12
51127: PUSH
51128: LD_INT 0
51130: PPUSH
51131: LD_INT 3
51133: PPUSH
51134: CALL_OW 12
51138: PUSH
51139: LD_INT 0
51141: PUSH
51142: LD_INT 0
51144: PUSH
51145: EMPTY
51146: LIST
51147: LIST
51148: LIST
51149: LIST
51150: ST_TO_ADDR
// end ;
51151: LD_VAR 0 1
51155: RET
// export function PrepareApemanEngineer ( ) ; begin
51156: LD_INT 0
51158: PPUSH
// uc_nation := 0 ;
51159: LD_ADDR_OWVAR 21
51163: PUSH
51164: LD_INT 0
51166: ST_TO_ADDR
// hc_sex := sex_male ;
51167: LD_ADDR_OWVAR 27
51171: PUSH
51172: LD_INT 1
51174: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
51175: LD_ADDR_OWVAR 28
51179: PUSH
51180: LD_INT 16
51182: ST_TO_ADDR
// hc_gallery :=  ;
51183: LD_ADDR_OWVAR 33
51187: PUSH
51188: LD_STRING 
51190: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
51191: LD_ADDR_OWVAR 31
51195: PUSH
51196: LD_INT 0
51198: PPUSH
51199: LD_INT 3
51201: PPUSH
51202: CALL_OW 12
51206: PUSH
51207: LD_INT 0
51209: PPUSH
51210: LD_INT 3
51212: PPUSH
51213: CALL_OW 12
51217: PUSH
51218: LD_INT 0
51220: PUSH
51221: LD_INT 0
51223: PUSH
51224: EMPTY
51225: LIST
51226: LIST
51227: LIST
51228: LIST
51229: ST_TO_ADDR
// end ;
51230: LD_VAR 0 1
51234: RET
// export function PrepareApeman ( agressivity ) ; begin
51235: LD_INT 0
51237: PPUSH
// uc_side := 0 ;
51238: LD_ADDR_OWVAR 20
51242: PUSH
51243: LD_INT 0
51245: ST_TO_ADDR
// uc_nation := 0 ;
51246: LD_ADDR_OWVAR 21
51250: PUSH
51251: LD_INT 0
51253: ST_TO_ADDR
// hc_sex := sex_male ;
51254: LD_ADDR_OWVAR 27
51258: PUSH
51259: LD_INT 1
51261: ST_TO_ADDR
// hc_class := class_apeman ;
51262: LD_ADDR_OWVAR 28
51266: PUSH
51267: LD_INT 12
51269: ST_TO_ADDR
// hc_gallery :=  ;
51270: LD_ADDR_OWVAR 33
51274: PUSH
51275: LD_STRING 
51277: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
51278: LD_ADDR_OWVAR 35
51282: PUSH
51283: LD_VAR 0 1
51287: NEG
51288: PPUSH
51289: LD_VAR 0 1
51293: PPUSH
51294: CALL_OW 12
51298: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
51299: LD_ADDR_OWVAR 31
51303: PUSH
51304: LD_INT 0
51306: PPUSH
51307: LD_INT 3
51309: PPUSH
51310: CALL_OW 12
51314: PUSH
51315: LD_INT 0
51317: PPUSH
51318: LD_INT 3
51320: PPUSH
51321: CALL_OW 12
51325: PUSH
51326: LD_INT 0
51328: PUSH
51329: LD_INT 0
51331: PUSH
51332: EMPTY
51333: LIST
51334: LIST
51335: LIST
51336: LIST
51337: ST_TO_ADDR
// end ;
51338: LD_VAR 0 2
51342: RET
// export function PrepareTiger ( agressivity ) ; begin
51343: LD_INT 0
51345: PPUSH
// uc_side := 0 ;
51346: LD_ADDR_OWVAR 20
51350: PUSH
51351: LD_INT 0
51353: ST_TO_ADDR
// uc_nation := 0 ;
51354: LD_ADDR_OWVAR 21
51358: PUSH
51359: LD_INT 0
51361: ST_TO_ADDR
// hc_class := class_tiger ;
51362: LD_ADDR_OWVAR 28
51366: PUSH
51367: LD_INT 14
51369: ST_TO_ADDR
// hc_gallery :=  ;
51370: LD_ADDR_OWVAR 33
51374: PUSH
51375: LD_STRING 
51377: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
51378: LD_ADDR_OWVAR 35
51382: PUSH
51383: LD_VAR 0 1
51387: NEG
51388: PPUSH
51389: LD_VAR 0 1
51393: PPUSH
51394: CALL_OW 12
51398: ST_TO_ADDR
// end ;
51399: LD_VAR 0 2
51403: RET
// export function PrepareEnchidna ( ) ; begin
51404: LD_INT 0
51406: PPUSH
// uc_side := 0 ;
51407: LD_ADDR_OWVAR 20
51411: PUSH
51412: LD_INT 0
51414: ST_TO_ADDR
// uc_nation := 0 ;
51415: LD_ADDR_OWVAR 21
51419: PUSH
51420: LD_INT 0
51422: ST_TO_ADDR
// hc_class := class_baggie ;
51423: LD_ADDR_OWVAR 28
51427: PUSH
51428: LD_INT 13
51430: ST_TO_ADDR
// hc_gallery :=  ;
51431: LD_ADDR_OWVAR 33
51435: PUSH
51436: LD_STRING 
51438: ST_TO_ADDR
// end ;
51439: LD_VAR 0 1
51443: RET
// export function PrepareFrog ( ) ; begin
51444: LD_INT 0
51446: PPUSH
// uc_side := 0 ;
51447: LD_ADDR_OWVAR 20
51451: PUSH
51452: LD_INT 0
51454: ST_TO_ADDR
// uc_nation := 0 ;
51455: LD_ADDR_OWVAR 21
51459: PUSH
51460: LD_INT 0
51462: ST_TO_ADDR
// hc_class := class_frog ;
51463: LD_ADDR_OWVAR 28
51467: PUSH
51468: LD_INT 19
51470: ST_TO_ADDR
// hc_gallery :=  ;
51471: LD_ADDR_OWVAR 33
51475: PUSH
51476: LD_STRING 
51478: ST_TO_ADDR
// end ;
51479: LD_VAR 0 1
51483: RET
// export function PrepareFish ( ) ; begin
51484: LD_INT 0
51486: PPUSH
// uc_side := 0 ;
51487: LD_ADDR_OWVAR 20
51491: PUSH
51492: LD_INT 0
51494: ST_TO_ADDR
// uc_nation := 0 ;
51495: LD_ADDR_OWVAR 21
51499: PUSH
51500: LD_INT 0
51502: ST_TO_ADDR
// hc_class := class_fish ;
51503: LD_ADDR_OWVAR 28
51507: PUSH
51508: LD_INT 20
51510: ST_TO_ADDR
// hc_gallery :=  ;
51511: LD_ADDR_OWVAR 33
51515: PUSH
51516: LD_STRING 
51518: ST_TO_ADDR
// end ;
51519: LD_VAR 0 1
51523: RET
// export function PrepareBird ( ) ; begin
51524: LD_INT 0
51526: PPUSH
// uc_side := 0 ;
51527: LD_ADDR_OWVAR 20
51531: PUSH
51532: LD_INT 0
51534: ST_TO_ADDR
// uc_nation := 0 ;
51535: LD_ADDR_OWVAR 21
51539: PUSH
51540: LD_INT 0
51542: ST_TO_ADDR
// hc_class := class_phororhacos ;
51543: LD_ADDR_OWVAR 28
51547: PUSH
51548: LD_INT 18
51550: ST_TO_ADDR
// hc_gallery :=  ;
51551: LD_ADDR_OWVAR 33
51555: PUSH
51556: LD_STRING 
51558: ST_TO_ADDR
// end ;
51559: LD_VAR 0 1
51563: RET
// export function PrepareHorse ( ) ; begin
51564: LD_INT 0
51566: PPUSH
// uc_side := 0 ;
51567: LD_ADDR_OWVAR 20
51571: PUSH
51572: LD_INT 0
51574: ST_TO_ADDR
// uc_nation := 0 ;
51575: LD_ADDR_OWVAR 21
51579: PUSH
51580: LD_INT 0
51582: ST_TO_ADDR
// hc_class := class_horse ;
51583: LD_ADDR_OWVAR 28
51587: PUSH
51588: LD_INT 21
51590: ST_TO_ADDR
// hc_gallery :=  ;
51591: LD_ADDR_OWVAR 33
51595: PUSH
51596: LD_STRING 
51598: ST_TO_ADDR
// end ;
51599: LD_VAR 0 1
51603: RET
// export function PrepareMastodont ( ) ; begin
51604: LD_INT 0
51606: PPUSH
// uc_side := 0 ;
51607: LD_ADDR_OWVAR 20
51611: PUSH
51612: LD_INT 0
51614: ST_TO_ADDR
// uc_nation := 0 ;
51615: LD_ADDR_OWVAR 21
51619: PUSH
51620: LD_INT 0
51622: ST_TO_ADDR
// vc_chassis := class_mastodont ;
51623: LD_ADDR_OWVAR 37
51627: PUSH
51628: LD_INT 31
51630: ST_TO_ADDR
// vc_control := control_rider ;
51631: LD_ADDR_OWVAR 38
51635: PUSH
51636: LD_INT 4
51638: ST_TO_ADDR
// end ;
51639: LD_VAR 0 1
51643: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
51644: LD_INT 0
51646: PPUSH
51647: PPUSH
51648: PPUSH
// uc_side = 0 ;
51649: LD_ADDR_OWVAR 20
51653: PUSH
51654: LD_INT 0
51656: ST_TO_ADDR
// uc_nation = 0 ;
51657: LD_ADDR_OWVAR 21
51661: PUSH
51662: LD_INT 0
51664: ST_TO_ADDR
// InitHc_All ( ) ;
51665: CALL_OW 584
// InitVc ;
51669: CALL_OW 20
// if mastodonts then
51673: LD_VAR 0 6
51677: IFFALSE 51744
// for i = 1 to mastodonts do
51679: LD_ADDR_VAR 0 11
51683: PUSH
51684: DOUBLE
51685: LD_INT 1
51687: DEC
51688: ST_TO_ADDR
51689: LD_VAR 0 6
51693: PUSH
51694: FOR_TO
51695: IFFALSE 51742
// begin vc_chassis := 31 ;
51697: LD_ADDR_OWVAR 37
51701: PUSH
51702: LD_INT 31
51704: ST_TO_ADDR
// vc_control := control_rider ;
51705: LD_ADDR_OWVAR 38
51709: PUSH
51710: LD_INT 4
51712: ST_TO_ADDR
// animal := CreateVehicle ;
51713: LD_ADDR_VAR 0 12
51717: PUSH
51718: CALL_OW 45
51722: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51723: LD_VAR 0 12
51727: PPUSH
51728: LD_VAR 0 8
51732: PPUSH
51733: LD_INT 0
51735: PPUSH
51736: CALL 53872 0 3
// end ;
51740: GO 51694
51742: POP
51743: POP
// if horses then
51744: LD_VAR 0 5
51748: IFFALSE 51815
// for i = 1 to horses do
51750: LD_ADDR_VAR 0 11
51754: PUSH
51755: DOUBLE
51756: LD_INT 1
51758: DEC
51759: ST_TO_ADDR
51760: LD_VAR 0 5
51764: PUSH
51765: FOR_TO
51766: IFFALSE 51813
// begin hc_class := 21 ;
51768: LD_ADDR_OWVAR 28
51772: PUSH
51773: LD_INT 21
51775: ST_TO_ADDR
// hc_gallery :=  ;
51776: LD_ADDR_OWVAR 33
51780: PUSH
51781: LD_STRING 
51783: ST_TO_ADDR
// animal := CreateHuman ;
51784: LD_ADDR_VAR 0 12
51788: PUSH
51789: CALL_OW 44
51793: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51794: LD_VAR 0 12
51798: PPUSH
51799: LD_VAR 0 8
51803: PPUSH
51804: LD_INT 0
51806: PPUSH
51807: CALL 53872 0 3
// end ;
51811: GO 51765
51813: POP
51814: POP
// if birds then
51815: LD_VAR 0 1
51819: IFFALSE 51886
// for i = 1 to birds do
51821: LD_ADDR_VAR 0 11
51825: PUSH
51826: DOUBLE
51827: LD_INT 1
51829: DEC
51830: ST_TO_ADDR
51831: LD_VAR 0 1
51835: PUSH
51836: FOR_TO
51837: IFFALSE 51884
// begin hc_class := 18 ;
51839: LD_ADDR_OWVAR 28
51843: PUSH
51844: LD_INT 18
51846: ST_TO_ADDR
// hc_gallery =  ;
51847: LD_ADDR_OWVAR 33
51851: PUSH
51852: LD_STRING 
51854: ST_TO_ADDR
// animal := CreateHuman ;
51855: LD_ADDR_VAR 0 12
51859: PUSH
51860: CALL_OW 44
51864: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51865: LD_VAR 0 12
51869: PPUSH
51870: LD_VAR 0 8
51874: PPUSH
51875: LD_INT 0
51877: PPUSH
51878: CALL 53872 0 3
// end ;
51882: GO 51836
51884: POP
51885: POP
// if tigers then
51886: LD_VAR 0 2
51890: IFFALSE 51974
// for i = 1 to tigers do
51892: LD_ADDR_VAR 0 11
51896: PUSH
51897: DOUBLE
51898: LD_INT 1
51900: DEC
51901: ST_TO_ADDR
51902: LD_VAR 0 2
51906: PUSH
51907: FOR_TO
51908: IFFALSE 51972
// begin hc_class = class_tiger ;
51910: LD_ADDR_OWVAR 28
51914: PUSH
51915: LD_INT 14
51917: ST_TO_ADDR
// hc_gallery =  ;
51918: LD_ADDR_OWVAR 33
51922: PUSH
51923: LD_STRING 
51925: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
51926: LD_ADDR_OWVAR 35
51930: PUSH
51931: LD_INT 7
51933: NEG
51934: PPUSH
51935: LD_INT 7
51937: PPUSH
51938: CALL_OW 12
51942: ST_TO_ADDR
// animal := CreateHuman ;
51943: LD_ADDR_VAR 0 12
51947: PUSH
51948: CALL_OW 44
51952: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51953: LD_VAR 0 12
51957: PPUSH
51958: LD_VAR 0 8
51962: PPUSH
51963: LD_INT 0
51965: PPUSH
51966: CALL 53872 0 3
// end ;
51970: GO 51907
51972: POP
51973: POP
// if apemans then
51974: LD_VAR 0 3
51978: IFFALSE 52101
// for i = 1 to apemans do
51980: LD_ADDR_VAR 0 11
51984: PUSH
51985: DOUBLE
51986: LD_INT 1
51988: DEC
51989: ST_TO_ADDR
51990: LD_VAR 0 3
51994: PUSH
51995: FOR_TO
51996: IFFALSE 52099
// begin hc_class = class_apeman ;
51998: LD_ADDR_OWVAR 28
52002: PUSH
52003: LD_INT 12
52005: ST_TO_ADDR
// hc_gallery =  ;
52006: LD_ADDR_OWVAR 33
52010: PUSH
52011: LD_STRING 
52013: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
52014: LD_ADDR_OWVAR 35
52018: PUSH
52019: LD_INT 2
52021: NEG
52022: PPUSH
52023: LD_INT 2
52025: PPUSH
52026: CALL_OW 12
52030: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
52031: LD_ADDR_OWVAR 31
52035: PUSH
52036: LD_INT 1
52038: PPUSH
52039: LD_INT 3
52041: PPUSH
52042: CALL_OW 12
52046: PUSH
52047: LD_INT 1
52049: PPUSH
52050: LD_INT 3
52052: PPUSH
52053: CALL_OW 12
52057: PUSH
52058: LD_INT 0
52060: PUSH
52061: LD_INT 0
52063: PUSH
52064: EMPTY
52065: LIST
52066: LIST
52067: LIST
52068: LIST
52069: ST_TO_ADDR
// animal := CreateHuman ;
52070: LD_ADDR_VAR 0 12
52074: PUSH
52075: CALL_OW 44
52079: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52080: LD_VAR 0 12
52084: PPUSH
52085: LD_VAR 0 8
52089: PPUSH
52090: LD_INT 0
52092: PPUSH
52093: CALL 53872 0 3
// end ;
52097: GO 51995
52099: POP
52100: POP
// if enchidnas then
52101: LD_VAR 0 4
52105: IFFALSE 52172
// for i = 1 to enchidnas do
52107: LD_ADDR_VAR 0 11
52111: PUSH
52112: DOUBLE
52113: LD_INT 1
52115: DEC
52116: ST_TO_ADDR
52117: LD_VAR 0 4
52121: PUSH
52122: FOR_TO
52123: IFFALSE 52170
// begin hc_class = 13 ;
52125: LD_ADDR_OWVAR 28
52129: PUSH
52130: LD_INT 13
52132: ST_TO_ADDR
// hc_gallery =  ;
52133: LD_ADDR_OWVAR 33
52137: PUSH
52138: LD_STRING 
52140: ST_TO_ADDR
// animal := CreateHuman ;
52141: LD_ADDR_VAR 0 12
52145: PUSH
52146: CALL_OW 44
52150: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52151: LD_VAR 0 12
52155: PPUSH
52156: LD_VAR 0 8
52160: PPUSH
52161: LD_INT 0
52163: PPUSH
52164: CALL 53872 0 3
// end ;
52168: GO 52122
52170: POP
52171: POP
// if fishes then
52172: LD_VAR 0 7
52176: IFFALSE 52243
// for i = 1 to fishes do
52178: LD_ADDR_VAR 0 11
52182: PUSH
52183: DOUBLE
52184: LD_INT 1
52186: DEC
52187: ST_TO_ADDR
52188: LD_VAR 0 7
52192: PUSH
52193: FOR_TO
52194: IFFALSE 52241
// begin hc_class = 20 ;
52196: LD_ADDR_OWVAR 28
52200: PUSH
52201: LD_INT 20
52203: ST_TO_ADDR
// hc_gallery =  ;
52204: LD_ADDR_OWVAR 33
52208: PUSH
52209: LD_STRING 
52211: ST_TO_ADDR
// animal := CreateHuman ;
52212: LD_ADDR_VAR 0 12
52216: PUSH
52217: CALL_OW 44
52221: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
52222: LD_VAR 0 12
52226: PPUSH
52227: LD_VAR 0 9
52231: PPUSH
52232: LD_INT 0
52234: PPUSH
52235: CALL 53872 0 3
// end ;
52239: GO 52193
52241: POP
52242: POP
// end ;
52243: LD_VAR 0 10
52247: RET
// export function WantHeal ( sci , unit ) ; begin
52248: LD_INT 0
52250: PPUSH
// if GetTaskList ( sci ) > 0 then
52251: LD_VAR 0 1
52255: PPUSH
52256: CALL_OW 437
52260: PUSH
52261: LD_INT 0
52263: GREATER
52264: IFFALSE 52334
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
52266: LD_VAR 0 1
52270: PPUSH
52271: CALL_OW 437
52275: PUSH
52276: LD_INT 1
52278: ARRAY
52279: PUSH
52280: LD_INT 1
52282: ARRAY
52283: PUSH
52284: LD_STRING l
52286: EQUAL
52287: PUSH
52288: LD_VAR 0 1
52292: PPUSH
52293: CALL_OW 437
52297: PUSH
52298: LD_INT 1
52300: ARRAY
52301: PUSH
52302: LD_INT 4
52304: ARRAY
52305: PUSH
52306: LD_VAR 0 2
52310: EQUAL
52311: AND
52312: IFFALSE 52324
// result := true else
52314: LD_ADDR_VAR 0 3
52318: PUSH
52319: LD_INT 1
52321: ST_TO_ADDR
52322: GO 52332
// result := false ;
52324: LD_ADDR_VAR 0 3
52328: PUSH
52329: LD_INT 0
52331: ST_TO_ADDR
// end else
52332: GO 52342
// result := false ;
52334: LD_ADDR_VAR 0 3
52338: PUSH
52339: LD_INT 0
52341: ST_TO_ADDR
// end ;
52342: LD_VAR 0 3
52346: RET
// export function HealTarget ( sci ) ; begin
52347: LD_INT 0
52349: PPUSH
// if not sci then
52350: LD_VAR 0 1
52354: NOT
52355: IFFALSE 52359
// exit ;
52357: GO 52424
// result := 0 ;
52359: LD_ADDR_VAR 0 2
52363: PUSH
52364: LD_INT 0
52366: ST_TO_ADDR
// if GetTaskList ( sci ) then
52367: LD_VAR 0 1
52371: PPUSH
52372: CALL_OW 437
52376: IFFALSE 52424
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
52378: LD_VAR 0 1
52382: PPUSH
52383: CALL_OW 437
52387: PUSH
52388: LD_INT 1
52390: ARRAY
52391: PUSH
52392: LD_INT 1
52394: ARRAY
52395: PUSH
52396: LD_STRING l
52398: EQUAL
52399: IFFALSE 52424
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
52401: LD_ADDR_VAR 0 2
52405: PUSH
52406: LD_VAR 0 1
52410: PPUSH
52411: CALL_OW 437
52415: PUSH
52416: LD_INT 1
52418: ARRAY
52419: PUSH
52420: LD_INT 4
52422: ARRAY
52423: ST_TO_ADDR
// end ;
52424: LD_VAR 0 2
52428: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
52429: LD_INT 0
52431: PPUSH
52432: PPUSH
52433: PPUSH
52434: PPUSH
// if not base_units then
52435: LD_VAR 0 1
52439: NOT
52440: IFFALSE 52444
// exit ;
52442: GO 52531
// result := false ;
52444: LD_ADDR_VAR 0 2
52448: PUSH
52449: LD_INT 0
52451: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
52452: LD_ADDR_VAR 0 5
52456: PUSH
52457: LD_VAR 0 1
52461: PPUSH
52462: LD_INT 21
52464: PUSH
52465: LD_INT 3
52467: PUSH
52468: EMPTY
52469: LIST
52470: LIST
52471: PPUSH
52472: CALL_OW 72
52476: ST_TO_ADDR
// if not tmp then
52477: LD_VAR 0 5
52481: NOT
52482: IFFALSE 52486
// exit ;
52484: GO 52531
// for i in tmp do
52486: LD_ADDR_VAR 0 3
52490: PUSH
52491: LD_VAR 0 5
52495: PUSH
52496: FOR_IN
52497: IFFALSE 52529
// begin result := EnemyInRange ( i , 22 ) ;
52499: LD_ADDR_VAR 0 2
52503: PUSH
52504: LD_VAR 0 3
52508: PPUSH
52509: LD_INT 22
52511: PPUSH
52512: CALL 50129 0 2
52516: ST_TO_ADDR
// if result then
52517: LD_VAR 0 2
52521: IFFALSE 52527
// exit ;
52523: POP
52524: POP
52525: GO 52531
// end ;
52527: GO 52496
52529: POP
52530: POP
// end ;
52531: LD_VAR 0 2
52535: RET
// export function FilterByTag ( units , tag ) ; begin
52536: LD_INT 0
52538: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
52539: LD_ADDR_VAR 0 3
52543: PUSH
52544: LD_VAR 0 1
52548: PPUSH
52549: LD_INT 120
52551: PUSH
52552: LD_VAR 0 2
52556: PUSH
52557: EMPTY
52558: LIST
52559: LIST
52560: PPUSH
52561: CALL_OW 72
52565: ST_TO_ADDR
// end ;
52566: LD_VAR 0 3
52570: RET
// export function IsDriver ( un ) ; begin
52571: LD_INT 0
52573: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
52574: LD_ADDR_VAR 0 2
52578: PUSH
52579: LD_VAR 0 1
52583: PUSH
52584: LD_INT 55
52586: PUSH
52587: EMPTY
52588: LIST
52589: PPUSH
52590: CALL_OW 69
52594: IN
52595: ST_TO_ADDR
// end ;
52596: LD_VAR 0 2
52600: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
52601: LD_INT 0
52603: PPUSH
52604: PPUSH
// list := [ ] ;
52605: LD_ADDR_VAR 0 5
52609: PUSH
52610: EMPTY
52611: ST_TO_ADDR
// case d of 0 :
52612: LD_VAR 0 3
52616: PUSH
52617: LD_INT 0
52619: DOUBLE
52620: EQUAL
52621: IFTRUE 52625
52623: GO 52758
52625: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
52626: LD_ADDR_VAR 0 5
52630: PUSH
52631: LD_VAR 0 1
52635: PUSH
52636: LD_INT 4
52638: MINUS
52639: PUSH
52640: LD_VAR 0 2
52644: PUSH
52645: LD_INT 4
52647: MINUS
52648: PUSH
52649: LD_INT 2
52651: PUSH
52652: EMPTY
52653: LIST
52654: LIST
52655: LIST
52656: PUSH
52657: LD_VAR 0 1
52661: PUSH
52662: LD_INT 3
52664: MINUS
52665: PUSH
52666: LD_VAR 0 2
52670: PUSH
52671: LD_INT 1
52673: PUSH
52674: EMPTY
52675: LIST
52676: LIST
52677: LIST
52678: PUSH
52679: LD_VAR 0 1
52683: PUSH
52684: LD_INT 4
52686: PLUS
52687: PUSH
52688: LD_VAR 0 2
52692: PUSH
52693: LD_INT 4
52695: PUSH
52696: EMPTY
52697: LIST
52698: LIST
52699: LIST
52700: PUSH
52701: LD_VAR 0 1
52705: PUSH
52706: LD_INT 3
52708: PLUS
52709: PUSH
52710: LD_VAR 0 2
52714: PUSH
52715: LD_INT 3
52717: PLUS
52718: PUSH
52719: LD_INT 5
52721: PUSH
52722: EMPTY
52723: LIST
52724: LIST
52725: LIST
52726: PUSH
52727: LD_VAR 0 1
52731: PUSH
52732: LD_VAR 0 2
52736: PUSH
52737: LD_INT 4
52739: PLUS
52740: PUSH
52741: LD_INT 0
52743: PUSH
52744: EMPTY
52745: LIST
52746: LIST
52747: LIST
52748: PUSH
52749: EMPTY
52750: LIST
52751: LIST
52752: LIST
52753: LIST
52754: LIST
52755: ST_TO_ADDR
// end ; 1 :
52756: GO 53456
52758: LD_INT 1
52760: DOUBLE
52761: EQUAL
52762: IFTRUE 52766
52764: GO 52899
52766: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
52767: LD_ADDR_VAR 0 5
52771: PUSH
52772: LD_VAR 0 1
52776: PUSH
52777: LD_VAR 0 2
52781: PUSH
52782: LD_INT 4
52784: MINUS
52785: PUSH
52786: LD_INT 3
52788: PUSH
52789: EMPTY
52790: LIST
52791: LIST
52792: LIST
52793: PUSH
52794: LD_VAR 0 1
52798: PUSH
52799: LD_INT 3
52801: MINUS
52802: PUSH
52803: LD_VAR 0 2
52807: PUSH
52808: LD_INT 3
52810: MINUS
52811: PUSH
52812: LD_INT 2
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: LIST
52819: PUSH
52820: LD_VAR 0 1
52824: PUSH
52825: LD_INT 4
52827: MINUS
52828: PUSH
52829: LD_VAR 0 2
52833: PUSH
52834: LD_INT 1
52836: PUSH
52837: EMPTY
52838: LIST
52839: LIST
52840: LIST
52841: PUSH
52842: LD_VAR 0 1
52846: PUSH
52847: LD_VAR 0 2
52851: PUSH
52852: LD_INT 3
52854: PLUS
52855: PUSH
52856: LD_INT 0
52858: PUSH
52859: EMPTY
52860: LIST
52861: LIST
52862: LIST
52863: PUSH
52864: LD_VAR 0 1
52868: PUSH
52869: LD_INT 4
52871: PLUS
52872: PUSH
52873: LD_VAR 0 2
52877: PUSH
52878: LD_INT 4
52880: PLUS
52881: PUSH
52882: LD_INT 5
52884: PUSH
52885: EMPTY
52886: LIST
52887: LIST
52888: LIST
52889: PUSH
52890: EMPTY
52891: LIST
52892: LIST
52893: LIST
52894: LIST
52895: LIST
52896: ST_TO_ADDR
// end ; 2 :
52897: GO 53456
52899: LD_INT 2
52901: DOUBLE
52902: EQUAL
52903: IFTRUE 52907
52905: GO 53036
52907: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
52908: LD_ADDR_VAR 0 5
52912: PUSH
52913: LD_VAR 0 1
52917: PUSH
52918: LD_VAR 0 2
52922: PUSH
52923: LD_INT 3
52925: MINUS
52926: PUSH
52927: LD_INT 3
52929: PUSH
52930: EMPTY
52931: LIST
52932: LIST
52933: LIST
52934: PUSH
52935: LD_VAR 0 1
52939: PUSH
52940: LD_INT 4
52942: PLUS
52943: PUSH
52944: LD_VAR 0 2
52948: PUSH
52949: LD_INT 4
52951: PUSH
52952: EMPTY
52953: LIST
52954: LIST
52955: LIST
52956: PUSH
52957: LD_VAR 0 1
52961: PUSH
52962: LD_VAR 0 2
52966: PUSH
52967: LD_INT 4
52969: PLUS
52970: PUSH
52971: LD_INT 0
52973: PUSH
52974: EMPTY
52975: LIST
52976: LIST
52977: LIST
52978: PUSH
52979: LD_VAR 0 1
52983: PUSH
52984: LD_INT 3
52986: MINUS
52987: PUSH
52988: LD_VAR 0 2
52992: PUSH
52993: LD_INT 1
52995: PUSH
52996: EMPTY
52997: LIST
52998: LIST
52999: LIST
53000: PUSH
53001: LD_VAR 0 1
53005: PUSH
53006: LD_INT 4
53008: MINUS
53009: PUSH
53010: LD_VAR 0 2
53014: PUSH
53015: LD_INT 4
53017: MINUS
53018: PUSH
53019: LD_INT 2
53021: PUSH
53022: EMPTY
53023: LIST
53024: LIST
53025: LIST
53026: PUSH
53027: EMPTY
53028: LIST
53029: LIST
53030: LIST
53031: LIST
53032: LIST
53033: ST_TO_ADDR
// end ; 3 :
53034: GO 53456
53036: LD_INT 3
53038: DOUBLE
53039: EQUAL
53040: IFTRUE 53044
53042: GO 53177
53044: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
53045: LD_ADDR_VAR 0 5
53049: PUSH
53050: LD_VAR 0 1
53054: PUSH
53055: LD_INT 3
53057: PLUS
53058: PUSH
53059: LD_VAR 0 2
53063: PUSH
53064: LD_INT 4
53066: PUSH
53067: EMPTY
53068: LIST
53069: LIST
53070: LIST
53071: PUSH
53072: LD_VAR 0 1
53076: PUSH
53077: LD_INT 4
53079: PLUS
53080: PUSH
53081: LD_VAR 0 2
53085: PUSH
53086: LD_INT 4
53088: PLUS
53089: PUSH
53090: LD_INT 5
53092: PUSH
53093: EMPTY
53094: LIST
53095: LIST
53096: LIST
53097: PUSH
53098: LD_VAR 0 1
53102: PUSH
53103: LD_INT 4
53105: MINUS
53106: PUSH
53107: LD_VAR 0 2
53111: PUSH
53112: LD_INT 1
53114: PUSH
53115: EMPTY
53116: LIST
53117: LIST
53118: LIST
53119: PUSH
53120: LD_VAR 0 1
53124: PUSH
53125: LD_VAR 0 2
53129: PUSH
53130: LD_INT 4
53132: MINUS
53133: PUSH
53134: LD_INT 3
53136: PUSH
53137: EMPTY
53138: LIST
53139: LIST
53140: LIST
53141: PUSH
53142: LD_VAR 0 1
53146: PUSH
53147: LD_INT 3
53149: MINUS
53150: PUSH
53151: LD_VAR 0 2
53155: PUSH
53156: LD_INT 3
53158: MINUS
53159: PUSH
53160: LD_INT 2
53162: PUSH
53163: EMPTY
53164: LIST
53165: LIST
53166: LIST
53167: PUSH
53168: EMPTY
53169: LIST
53170: LIST
53171: LIST
53172: LIST
53173: LIST
53174: ST_TO_ADDR
// end ; 4 :
53175: GO 53456
53177: LD_INT 4
53179: DOUBLE
53180: EQUAL
53181: IFTRUE 53185
53183: GO 53318
53185: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
53186: LD_ADDR_VAR 0 5
53190: PUSH
53191: LD_VAR 0 1
53195: PUSH
53196: LD_VAR 0 2
53200: PUSH
53201: LD_INT 4
53203: PLUS
53204: PUSH
53205: LD_INT 0
53207: PUSH
53208: EMPTY
53209: LIST
53210: LIST
53211: LIST
53212: PUSH
53213: LD_VAR 0 1
53217: PUSH
53218: LD_INT 3
53220: PLUS
53221: PUSH
53222: LD_VAR 0 2
53226: PUSH
53227: LD_INT 3
53229: PLUS
53230: PUSH
53231: LD_INT 5
53233: PUSH
53234: EMPTY
53235: LIST
53236: LIST
53237: LIST
53238: PUSH
53239: LD_VAR 0 1
53243: PUSH
53244: LD_INT 4
53246: PLUS
53247: PUSH
53248: LD_VAR 0 2
53252: PUSH
53253: LD_INT 4
53255: PUSH
53256: EMPTY
53257: LIST
53258: LIST
53259: LIST
53260: PUSH
53261: LD_VAR 0 1
53265: PUSH
53266: LD_VAR 0 2
53270: PUSH
53271: LD_INT 3
53273: MINUS
53274: PUSH
53275: LD_INT 3
53277: PUSH
53278: EMPTY
53279: LIST
53280: LIST
53281: LIST
53282: PUSH
53283: LD_VAR 0 1
53287: PUSH
53288: LD_INT 4
53290: MINUS
53291: PUSH
53292: LD_VAR 0 2
53296: PUSH
53297: LD_INT 4
53299: MINUS
53300: PUSH
53301: LD_INT 2
53303: PUSH
53304: EMPTY
53305: LIST
53306: LIST
53307: LIST
53308: PUSH
53309: EMPTY
53310: LIST
53311: LIST
53312: LIST
53313: LIST
53314: LIST
53315: ST_TO_ADDR
// end ; 5 :
53316: GO 53456
53318: LD_INT 5
53320: DOUBLE
53321: EQUAL
53322: IFTRUE 53326
53324: GO 53455
53326: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
53327: LD_ADDR_VAR 0 5
53331: PUSH
53332: LD_VAR 0 1
53336: PUSH
53337: LD_INT 4
53339: MINUS
53340: PUSH
53341: LD_VAR 0 2
53345: PUSH
53346: LD_INT 1
53348: PUSH
53349: EMPTY
53350: LIST
53351: LIST
53352: LIST
53353: PUSH
53354: LD_VAR 0 1
53358: PUSH
53359: LD_VAR 0 2
53363: PUSH
53364: LD_INT 4
53366: MINUS
53367: PUSH
53368: LD_INT 3
53370: PUSH
53371: EMPTY
53372: LIST
53373: LIST
53374: LIST
53375: PUSH
53376: LD_VAR 0 1
53380: PUSH
53381: LD_INT 4
53383: PLUS
53384: PUSH
53385: LD_VAR 0 2
53389: PUSH
53390: LD_INT 4
53392: PLUS
53393: PUSH
53394: LD_INT 5
53396: PUSH
53397: EMPTY
53398: LIST
53399: LIST
53400: LIST
53401: PUSH
53402: LD_VAR 0 1
53406: PUSH
53407: LD_INT 3
53409: PLUS
53410: PUSH
53411: LD_VAR 0 2
53415: PUSH
53416: LD_INT 4
53418: PUSH
53419: EMPTY
53420: LIST
53421: LIST
53422: LIST
53423: PUSH
53424: LD_VAR 0 1
53428: PUSH
53429: LD_VAR 0 2
53433: PUSH
53434: LD_INT 3
53436: PLUS
53437: PUSH
53438: LD_INT 0
53440: PUSH
53441: EMPTY
53442: LIST
53443: LIST
53444: LIST
53445: PUSH
53446: EMPTY
53447: LIST
53448: LIST
53449: LIST
53450: LIST
53451: LIST
53452: ST_TO_ADDR
// end ; end ;
53453: GO 53456
53455: POP
// result := list ;
53456: LD_ADDR_VAR 0 4
53460: PUSH
53461: LD_VAR 0 5
53465: ST_TO_ADDR
// end ;
53466: LD_VAR 0 4
53470: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
53471: LD_INT 0
53473: PPUSH
53474: PPUSH
53475: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
53476: LD_VAR 0 1
53480: NOT
53481: PUSH
53482: LD_VAR 0 2
53486: PUSH
53487: LD_INT 1
53489: PUSH
53490: LD_INT 2
53492: PUSH
53493: LD_INT 3
53495: PUSH
53496: LD_INT 4
53498: PUSH
53499: EMPTY
53500: LIST
53501: LIST
53502: LIST
53503: LIST
53504: IN
53505: NOT
53506: OR
53507: IFFALSE 53511
// exit ;
53509: GO 53594
// tmp := [ ] ;
53511: LD_ADDR_VAR 0 5
53515: PUSH
53516: EMPTY
53517: ST_TO_ADDR
// for i in units do
53518: LD_ADDR_VAR 0 4
53522: PUSH
53523: LD_VAR 0 1
53527: PUSH
53528: FOR_IN
53529: IFFALSE 53563
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
53531: LD_ADDR_VAR 0 5
53535: PUSH
53536: LD_VAR 0 5
53540: PPUSH
53541: LD_VAR 0 4
53545: PPUSH
53546: LD_VAR 0 2
53550: PPUSH
53551: CALL_OW 259
53555: PPUSH
53556: CALL 54967 0 2
53560: ST_TO_ADDR
53561: GO 53528
53563: POP
53564: POP
// if not tmp then
53565: LD_VAR 0 5
53569: NOT
53570: IFFALSE 53574
// exit ;
53572: GO 53594
// result := SortListByListDesc ( units , tmp ) ;
53574: LD_ADDR_VAR 0 3
53578: PUSH
53579: LD_VAR 0 1
53583: PPUSH
53584: LD_VAR 0 5
53588: PPUSH
53589: CALL_OW 77
53593: ST_TO_ADDR
// end ;
53594: LD_VAR 0 3
53598: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
53599: LD_INT 0
53601: PPUSH
53602: PPUSH
53603: PPUSH
// result := false ;
53604: LD_ADDR_VAR 0 3
53608: PUSH
53609: LD_INT 0
53611: ST_TO_ADDR
// if not building then
53612: LD_VAR 0 2
53616: NOT
53617: IFFALSE 53621
// exit ;
53619: GO 53759
// x := GetX ( building ) ;
53621: LD_ADDR_VAR 0 4
53625: PUSH
53626: LD_VAR 0 2
53630: PPUSH
53631: CALL_OW 250
53635: ST_TO_ADDR
// y := GetY ( building ) ;
53636: LD_ADDR_VAR 0 5
53640: PUSH
53641: LD_VAR 0 2
53645: PPUSH
53646: CALL_OW 251
53650: ST_TO_ADDR
// if not x or not y then
53651: LD_VAR 0 4
53655: NOT
53656: PUSH
53657: LD_VAR 0 5
53661: NOT
53662: OR
53663: IFFALSE 53667
// exit ;
53665: GO 53759
// if GetTaskList ( unit ) then
53667: LD_VAR 0 1
53671: PPUSH
53672: CALL_OW 437
53676: IFFALSE 53759
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
53678: LD_STRING e
53680: PUSH
53681: LD_VAR 0 1
53685: PPUSH
53686: CALL_OW 437
53690: PUSH
53691: LD_INT 1
53693: ARRAY
53694: PUSH
53695: LD_INT 1
53697: ARRAY
53698: EQUAL
53699: PUSH
53700: LD_VAR 0 4
53704: PUSH
53705: LD_VAR 0 1
53709: PPUSH
53710: CALL_OW 437
53714: PUSH
53715: LD_INT 1
53717: ARRAY
53718: PUSH
53719: LD_INT 2
53721: ARRAY
53722: EQUAL
53723: AND
53724: PUSH
53725: LD_VAR 0 5
53729: PUSH
53730: LD_VAR 0 1
53734: PPUSH
53735: CALL_OW 437
53739: PUSH
53740: LD_INT 1
53742: ARRAY
53743: PUSH
53744: LD_INT 3
53746: ARRAY
53747: EQUAL
53748: AND
53749: IFFALSE 53759
// result := true end ;
53751: LD_ADDR_VAR 0 3
53755: PUSH
53756: LD_INT 1
53758: ST_TO_ADDR
// end ;
53759: LD_VAR 0 3
53763: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
53764: LD_INT 0
53766: PPUSH
// result := false ;
53767: LD_ADDR_VAR 0 4
53771: PUSH
53772: LD_INT 0
53774: ST_TO_ADDR
// if GetTaskList ( unit ) then
53775: LD_VAR 0 1
53779: PPUSH
53780: CALL_OW 437
53784: IFFALSE 53867
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
53786: LD_STRING M
53788: PUSH
53789: LD_VAR 0 1
53793: PPUSH
53794: CALL_OW 437
53798: PUSH
53799: LD_INT 1
53801: ARRAY
53802: PUSH
53803: LD_INT 1
53805: ARRAY
53806: EQUAL
53807: PUSH
53808: LD_VAR 0 2
53812: PUSH
53813: LD_VAR 0 1
53817: PPUSH
53818: CALL_OW 437
53822: PUSH
53823: LD_INT 1
53825: ARRAY
53826: PUSH
53827: LD_INT 2
53829: ARRAY
53830: EQUAL
53831: AND
53832: PUSH
53833: LD_VAR 0 3
53837: PUSH
53838: LD_VAR 0 1
53842: PPUSH
53843: CALL_OW 437
53847: PUSH
53848: LD_INT 1
53850: ARRAY
53851: PUSH
53852: LD_INT 3
53854: ARRAY
53855: EQUAL
53856: AND
53857: IFFALSE 53867
// result := true ;
53859: LD_ADDR_VAR 0 4
53863: PUSH
53864: LD_INT 1
53866: ST_TO_ADDR
// end ; end ;
53867: LD_VAR 0 4
53871: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
53872: LD_INT 0
53874: PPUSH
53875: PPUSH
53876: PPUSH
53877: PPUSH
// if not unit or not area then
53878: LD_VAR 0 1
53882: NOT
53883: PUSH
53884: LD_VAR 0 2
53888: NOT
53889: OR
53890: IFFALSE 53894
// exit ;
53892: GO 54070
// tmp := AreaToList ( area , i ) ;
53894: LD_ADDR_VAR 0 6
53898: PUSH
53899: LD_VAR 0 2
53903: PPUSH
53904: LD_VAR 0 5
53908: PPUSH
53909: CALL_OW 517
53913: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
53914: LD_ADDR_VAR 0 5
53918: PUSH
53919: DOUBLE
53920: LD_INT 1
53922: DEC
53923: ST_TO_ADDR
53924: LD_VAR 0 6
53928: PUSH
53929: LD_INT 1
53931: ARRAY
53932: PUSH
53933: FOR_TO
53934: IFFALSE 54068
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
53936: LD_ADDR_VAR 0 7
53940: PUSH
53941: LD_VAR 0 6
53945: PUSH
53946: LD_INT 1
53948: ARRAY
53949: PUSH
53950: LD_VAR 0 5
53954: ARRAY
53955: PUSH
53956: LD_VAR 0 6
53960: PUSH
53961: LD_INT 2
53963: ARRAY
53964: PUSH
53965: LD_VAR 0 5
53969: ARRAY
53970: PUSH
53971: EMPTY
53972: LIST
53973: LIST
53974: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
53975: LD_INT 92
53977: PUSH
53978: LD_VAR 0 7
53982: PUSH
53983: LD_INT 1
53985: ARRAY
53986: PUSH
53987: LD_VAR 0 7
53991: PUSH
53992: LD_INT 2
53994: ARRAY
53995: PUSH
53996: LD_INT 2
53998: PUSH
53999: EMPTY
54000: LIST
54001: LIST
54002: LIST
54003: LIST
54004: PPUSH
54005: CALL_OW 69
54009: PUSH
54010: LD_INT 0
54012: EQUAL
54013: IFFALSE 54066
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
54015: LD_VAR 0 1
54019: PPUSH
54020: LD_VAR 0 7
54024: PUSH
54025: LD_INT 1
54027: ARRAY
54028: PPUSH
54029: LD_VAR 0 7
54033: PUSH
54034: LD_INT 2
54036: ARRAY
54037: PPUSH
54038: LD_VAR 0 3
54042: PPUSH
54043: CALL_OW 48
// result := IsPlaced ( unit ) ;
54047: LD_ADDR_VAR 0 4
54051: PUSH
54052: LD_VAR 0 1
54056: PPUSH
54057: CALL_OW 305
54061: ST_TO_ADDR
// exit ;
54062: POP
54063: POP
54064: GO 54070
// end ; end ;
54066: GO 53933
54068: POP
54069: POP
// end ;
54070: LD_VAR 0 4
54074: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
54075: LD_INT 0
54077: PPUSH
54078: PPUSH
54079: PPUSH
// if not side or side > 8 then
54080: LD_VAR 0 1
54084: NOT
54085: PUSH
54086: LD_VAR 0 1
54090: PUSH
54091: LD_INT 8
54093: GREATER
54094: OR
54095: IFFALSE 54099
// exit ;
54097: GO 54286
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
54099: LD_ADDR_VAR 0 4
54103: PUSH
54104: LD_INT 22
54106: PUSH
54107: LD_VAR 0 1
54111: PUSH
54112: EMPTY
54113: LIST
54114: LIST
54115: PUSH
54116: LD_INT 21
54118: PUSH
54119: LD_INT 3
54121: PUSH
54122: EMPTY
54123: LIST
54124: LIST
54125: PUSH
54126: EMPTY
54127: LIST
54128: LIST
54129: PPUSH
54130: CALL_OW 69
54134: ST_TO_ADDR
// if not tmp then
54135: LD_VAR 0 4
54139: NOT
54140: IFFALSE 54144
// exit ;
54142: GO 54286
// enable_addtolog := true ;
54144: LD_ADDR_OWVAR 81
54148: PUSH
54149: LD_INT 1
54151: ST_TO_ADDR
// AddToLog ( [ ) ;
54152: LD_STRING [
54154: PPUSH
54155: CALL_OW 561
// for i in tmp do
54159: LD_ADDR_VAR 0 3
54163: PUSH
54164: LD_VAR 0 4
54168: PUSH
54169: FOR_IN
54170: IFFALSE 54277
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
54172: LD_STRING [
54174: PUSH
54175: LD_VAR 0 3
54179: PPUSH
54180: CALL_OW 266
54184: STR
54185: PUSH
54186: LD_STRING , 
54188: STR
54189: PUSH
54190: LD_VAR 0 3
54194: PPUSH
54195: CALL_OW 250
54199: STR
54200: PUSH
54201: LD_STRING , 
54203: STR
54204: PUSH
54205: LD_VAR 0 3
54209: PPUSH
54210: CALL_OW 251
54214: STR
54215: PUSH
54216: LD_STRING , 
54218: STR
54219: PUSH
54220: LD_VAR 0 3
54224: PPUSH
54225: CALL_OW 254
54229: STR
54230: PUSH
54231: LD_STRING , 
54233: STR
54234: PUSH
54235: LD_VAR 0 3
54239: PPUSH
54240: LD_INT 1
54242: PPUSH
54243: CALL_OW 268
54247: STR
54248: PUSH
54249: LD_STRING , 
54251: STR
54252: PUSH
54253: LD_VAR 0 3
54257: PPUSH
54258: LD_INT 2
54260: PPUSH
54261: CALL_OW 268
54265: STR
54266: PUSH
54267: LD_STRING ],
54269: STR
54270: PPUSH
54271: CALL_OW 561
// end ;
54275: GO 54169
54277: POP
54278: POP
// AddToLog ( ]; ) ;
54279: LD_STRING ];
54281: PPUSH
54282: CALL_OW 561
// end ;
54286: LD_VAR 0 2
54290: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
54291: LD_INT 0
54293: PPUSH
54294: PPUSH
54295: PPUSH
54296: PPUSH
54297: PPUSH
// if not area or not rate or not max then
54298: LD_VAR 0 1
54302: NOT
54303: PUSH
54304: LD_VAR 0 2
54308: NOT
54309: OR
54310: PUSH
54311: LD_VAR 0 4
54315: NOT
54316: OR
54317: IFFALSE 54321
// exit ;
54319: GO 54510
// while 1 do
54321: LD_INT 1
54323: IFFALSE 54510
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
54325: LD_ADDR_VAR 0 9
54329: PUSH
54330: LD_VAR 0 1
54334: PPUSH
54335: LD_INT 1
54337: PPUSH
54338: CALL_OW 287
54342: PUSH
54343: LD_INT 10
54345: MUL
54346: ST_TO_ADDR
// r := rate / 10 ;
54347: LD_ADDR_VAR 0 7
54351: PUSH
54352: LD_VAR 0 2
54356: PUSH
54357: LD_INT 10
54359: DIVREAL
54360: ST_TO_ADDR
// time := 1 1$00 ;
54361: LD_ADDR_VAR 0 8
54365: PUSH
54366: LD_INT 2100
54368: ST_TO_ADDR
// if amount < min then
54369: LD_VAR 0 9
54373: PUSH
54374: LD_VAR 0 3
54378: LESS
54379: IFFALSE 54397
// r := r * 2 else
54381: LD_ADDR_VAR 0 7
54385: PUSH
54386: LD_VAR 0 7
54390: PUSH
54391: LD_INT 2
54393: MUL
54394: ST_TO_ADDR
54395: GO 54423
// if amount > max then
54397: LD_VAR 0 9
54401: PUSH
54402: LD_VAR 0 4
54406: GREATER
54407: IFFALSE 54423
// r := r / 2 ;
54409: LD_ADDR_VAR 0 7
54413: PUSH
54414: LD_VAR 0 7
54418: PUSH
54419: LD_INT 2
54421: DIVREAL
54422: ST_TO_ADDR
// time := time / r ;
54423: LD_ADDR_VAR 0 8
54427: PUSH
54428: LD_VAR 0 8
54432: PUSH
54433: LD_VAR 0 7
54437: DIVREAL
54438: ST_TO_ADDR
// if time < 0 then
54439: LD_VAR 0 8
54443: PUSH
54444: LD_INT 0
54446: LESS
54447: IFFALSE 54464
// time := time * - 1 ;
54449: LD_ADDR_VAR 0 8
54453: PUSH
54454: LD_VAR 0 8
54458: PUSH
54459: LD_INT 1
54461: NEG
54462: MUL
54463: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
54464: LD_VAR 0 8
54468: PUSH
54469: LD_INT 35
54471: PPUSH
54472: LD_INT 875
54474: PPUSH
54475: CALL_OW 12
54479: PLUS
54480: PPUSH
54481: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
54485: LD_INT 1
54487: PPUSH
54488: LD_INT 5
54490: PPUSH
54491: CALL_OW 12
54495: PPUSH
54496: LD_VAR 0 1
54500: PPUSH
54501: LD_INT 1
54503: PPUSH
54504: CALL_OW 55
// end ;
54508: GO 54321
// end ;
54510: LD_VAR 0 5
54514: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
54515: LD_INT 0
54517: PPUSH
54518: PPUSH
54519: PPUSH
54520: PPUSH
54521: PPUSH
54522: PPUSH
54523: PPUSH
54524: PPUSH
// if not turrets or not factories then
54525: LD_VAR 0 1
54529: NOT
54530: PUSH
54531: LD_VAR 0 2
54535: NOT
54536: OR
54537: IFFALSE 54541
// exit ;
54539: GO 54848
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
54541: LD_ADDR_VAR 0 10
54545: PUSH
54546: LD_INT 5
54548: PUSH
54549: LD_INT 6
54551: PUSH
54552: EMPTY
54553: LIST
54554: LIST
54555: PUSH
54556: LD_INT 2
54558: PUSH
54559: LD_INT 4
54561: PUSH
54562: EMPTY
54563: LIST
54564: LIST
54565: PUSH
54566: LD_INT 3
54568: PUSH
54569: LD_INT 5
54571: PUSH
54572: EMPTY
54573: LIST
54574: LIST
54575: PUSH
54576: EMPTY
54577: LIST
54578: LIST
54579: LIST
54580: PUSH
54581: LD_INT 24
54583: PUSH
54584: LD_INT 25
54586: PUSH
54587: EMPTY
54588: LIST
54589: LIST
54590: PUSH
54591: LD_INT 23
54593: PUSH
54594: LD_INT 27
54596: PUSH
54597: EMPTY
54598: LIST
54599: LIST
54600: PUSH
54601: EMPTY
54602: LIST
54603: LIST
54604: PUSH
54605: LD_INT 42
54607: PUSH
54608: LD_INT 43
54610: PUSH
54611: EMPTY
54612: LIST
54613: LIST
54614: PUSH
54615: LD_INT 44
54617: PUSH
54618: LD_INT 46
54620: PUSH
54621: EMPTY
54622: LIST
54623: LIST
54624: PUSH
54625: LD_INT 45
54627: PUSH
54628: LD_INT 47
54630: PUSH
54631: EMPTY
54632: LIST
54633: LIST
54634: PUSH
54635: EMPTY
54636: LIST
54637: LIST
54638: LIST
54639: PUSH
54640: EMPTY
54641: LIST
54642: LIST
54643: LIST
54644: ST_TO_ADDR
// result := [ ] ;
54645: LD_ADDR_VAR 0 3
54649: PUSH
54650: EMPTY
54651: ST_TO_ADDR
// for i in turrets do
54652: LD_ADDR_VAR 0 4
54656: PUSH
54657: LD_VAR 0 1
54661: PUSH
54662: FOR_IN
54663: IFFALSE 54846
// begin nat := GetNation ( i ) ;
54665: LD_ADDR_VAR 0 7
54669: PUSH
54670: LD_VAR 0 4
54674: PPUSH
54675: CALL_OW 248
54679: ST_TO_ADDR
// weapon := 0 ;
54680: LD_ADDR_VAR 0 8
54684: PUSH
54685: LD_INT 0
54687: ST_TO_ADDR
// if not nat then
54688: LD_VAR 0 7
54692: NOT
54693: IFFALSE 54697
// continue ;
54695: GO 54662
// for j in list [ nat ] do
54697: LD_ADDR_VAR 0 5
54701: PUSH
54702: LD_VAR 0 10
54706: PUSH
54707: LD_VAR 0 7
54711: ARRAY
54712: PUSH
54713: FOR_IN
54714: IFFALSE 54755
// if GetBWeapon ( i ) = j [ 1 ] then
54716: LD_VAR 0 4
54720: PPUSH
54721: CALL_OW 269
54725: PUSH
54726: LD_VAR 0 5
54730: PUSH
54731: LD_INT 1
54733: ARRAY
54734: EQUAL
54735: IFFALSE 54753
// begin weapon := j [ 2 ] ;
54737: LD_ADDR_VAR 0 8
54741: PUSH
54742: LD_VAR 0 5
54746: PUSH
54747: LD_INT 2
54749: ARRAY
54750: ST_TO_ADDR
// break ;
54751: GO 54755
// end ;
54753: GO 54713
54755: POP
54756: POP
// if not weapon then
54757: LD_VAR 0 8
54761: NOT
54762: IFFALSE 54766
// continue ;
54764: GO 54662
// for k in factories do
54766: LD_ADDR_VAR 0 6
54770: PUSH
54771: LD_VAR 0 2
54775: PUSH
54776: FOR_IN
54777: IFFALSE 54842
// begin weapons := AvailableWeaponList ( k ) ;
54779: LD_ADDR_VAR 0 9
54783: PUSH
54784: LD_VAR 0 6
54788: PPUSH
54789: CALL_OW 478
54793: ST_TO_ADDR
// if not weapons then
54794: LD_VAR 0 9
54798: NOT
54799: IFFALSE 54803
// continue ;
54801: GO 54776
// if weapon in weapons then
54803: LD_VAR 0 8
54807: PUSH
54808: LD_VAR 0 9
54812: IN
54813: IFFALSE 54840
// begin result := [ i , weapon ] ;
54815: LD_ADDR_VAR 0 3
54819: PUSH
54820: LD_VAR 0 4
54824: PUSH
54825: LD_VAR 0 8
54829: PUSH
54830: EMPTY
54831: LIST
54832: LIST
54833: ST_TO_ADDR
// exit ;
54834: POP
54835: POP
54836: POP
54837: POP
54838: GO 54848
// end ; end ;
54840: GO 54776
54842: POP
54843: POP
// end ;
54844: GO 54662
54846: POP
54847: POP
// end ;
54848: LD_VAR 0 3
54852: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
54853: LD_INT 0
54855: PPUSH
// if not side or side > 8 then
54856: LD_VAR 0 3
54860: NOT
54861: PUSH
54862: LD_VAR 0 3
54866: PUSH
54867: LD_INT 8
54869: GREATER
54870: OR
54871: IFFALSE 54875
// exit ;
54873: GO 54934
// if not range then
54875: LD_VAR 0 4
54879: NOT
54880: IFFALSE 54891
// range := - 12 ;
54882: LD_ADDR_VAR 0 4
54886: PUSH
54887: LD_INT 12
54889: NEG
54890: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
54891: LD_VAR 0 1
54895: PPUSH
54896: LD_VAR 0 2
54900: PPUSH
54901: LD_VAR 0 3
54905: PPUSH
54906: LD_VAR 0 4
54910: PPUSH
54911: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
54915: LD_VAR 0 1
54919: PPUSH
54920: LD_VAR 0 2
54924: PPUSH
54925: LD_VAR 0 3
54929: PPUSH
54930: CALL_OW 331
// end ;
54934: LD_VAR 0 5
54938: RET
// export function Video ( mode ) ; begin
54939: LD_INT 0
54941: PPUSH
// ingame_video = mode ;
54942: LD_ADDR_OWVAR 52
54946: PUSH
54947: LD_VAR 0 1
54951: ST_TO_ADDR
// interface_hidden = mode ;
54952: LD_ADDR_OWVAR 54
54956: PUSH
54957: LD_VAR 0 1
54961: ST_TO_ADDR
// end ;
54962: LD_VAR 0 2
54966: RET
// export function Join ( array , element ) ; begin
54967: LD_INT 0
54969: PPUSH
// result := Replace ( array , array + 1 , element ) ;
54970: LD_ADDR_VAR 0 3
54974: PUSH
54975: LD_VAR 0 1
54979: PPUSH
54980: LD_VAR 0 1
54984: PUSH
54985: LD_INT 1
54987: PLUS
54988: PPUSH
54989: LD_VAR 0 2
54993: PPUSH
54994: CALL_OW 1
54998: ST_TO_ADDR
// end ;
54999: LD_VAR 0 3
55003: RET
// export function JoinUnion ( array , element ) ; begin
55004: LD_INT 0
55006: PPUSH
// result := array union element ;
55007: LD_ADDR_VAR 0 3
55011: PUSH
55012: LD_VAR 0 1
55016: PUSH
55017: LD_VAR 0 2
55021: UNION
55022: ST_TO_ADDR
// end ;
55023: LD_VAR 0 3
55027: RET
// export function GetBehemoths ( side ) ; begin
55028: LD_INT 0
55030: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
55031: LD_ADDR_VAR 0 2
55035: PUSH
55036: LD_INT 22
55038: PUSH
55039: LD_VAR 0 1
55043: PUSH
55044: EMPTY
55045: LIST
55046: LIST
55047: PUSH
55048: LD_INT 31
55050: PUSH
55051: LD_INT 25
55053: PUSH
55054: EMPTY
55055: LIST
55056: LIST
55057: PUSH
55058: EMPTY
55059: LIST
55060: LIST
55061: PPUSH
55062: CALL_OW 69
55066: ST_TO_ADDR
// end ;
55067: LD_VAR 0 2
55071: RET
// export function Shuffle ( array ) ; var i , index ; begin
55072: LD_INT 0
55074: PPUSH
55075: PPUSH
55076: PPUSH
// result := [ ] ;
55077: LD_ADDR_VAR 0 2
55081: PUSH
55082: EMPTY
55083: ST_TO_ADDR
// if not array then
55084: LD_VAR 0 1
55088: NOT
55089: IFFALSE 55093
// exit ;
55091: GO 55192
// Randomize ;
55093: CALL_OW 10
// for i = array downto 1 do
55097: LD_ADDR_VAR 0 3
55101: PUSH
55102: DOUBLE
55103: LD_VAR 0 1
55107: INC
55108: ST_TO_ADDR
55109: LD_INT 1
55111: PUSH
55112: FOR_DOWNTO
55113: IFFALSE 55190
// begin index := rand ( 1 , array ) ;
55115: LD_ADDR_VAR 0 4
55119: PUSH
55120: LD_INT 1
55122: PPUSH
55123: LD_VAR 0 1
55127: PPUSH
55128: CALL_OW 12
55132: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
55133: LD_ADDR_VAR 0 2
55137: PUSH
55138: LD_VAR 0 2
55142: PPUSH
55143: LD_VAR 0 2
55147: PUSH
55148: LD_INT 1
55150: PLUS
55151: PPUSH
55152: LD_VAR 0 1
55156: PUSH
55157: LD_VAR 0 4
55161: ARRAY
55162: PPUSH
55163: CALL_OW 2
55167: ST_TO_ADDR
// array := Delete ( array , index ) ;
55168: LD_ADDR_VAR 0 1
55172: PUSH
55173: LD_VAR 0 1
55177: PPUSH
55178: LD_VAR 0 4
55182: PPUSH
55183: CALL_OW 3
55187: ST_TO_ADDR
// end ;
55188: GO 55112
55190: POP
55191: POP
// end ;
55192: LD_VAR 0 2
55196: RET
// export function GetBaseMaterials ( base ) ; begin
55197: LD_INT 0
55199: PPUSH
// result := [ 0 , 0 , 0 ] ;
55200: LD_ADDR_VAR 0 2
55204: PUSH
55205: LD_INT 0
55207: PUSH
55208: LD_INT 0
55210: PUSH
55211: LD_INT 0
55213: PUSH
55214: EMPTY
55215: LIST
55216: LIST
55217: LIST
55218: ST_TO_ADDR
// if not base then
55219: LD_VAR 0 1
55223: NOT
55224: IFFALSE 55228
// exit ;
55226: GO 55277
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
55228: LD_ADDR_VAR 0 2
55232: PUSH
55233: LD_VAR 0 1
55237: PPUSH
55238: LD_INT 1
55240: PPUSH
55241: CALL_OW 275
55245: PUSH
55246: LD_VAR 0 1
55250: PPUSH
55251: LD_INT 2
55253: PPUSH
55254: CALL_OW 275
55258: PUSH
55259: LD_VAR 0 1
55263: PPUSH
55264: LD_INT 3
55266: PPUSH
55267: CALL_OW 275
55271: PUSH
55272: EMPTY
55273: LIST
55274: LIST
55275: LIST
55276: ST_TO_ADDR
// end ;
55277: LD_VAR 0 2
55281: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
55282: LD_INT 0
55284: PPUSH
55285: PPUSH
// result := array ;
55286: LD_ADDR_VAR 0 3
55290: PUSH
55291: LD_VAR 0 1
55295: ST_TO_ADDR
// if size >= result then
55296: LD_VAR 0 2
55300: PUSH
55301: LD_VAR 0 3
55305: GREATEREQUAL
55306: IFFALSE 55310
// exit ;
55308: GO 55360
// if size then
55310: LD_VAR 0 2
55314: IFFALSE 55360
// for i := array downto size do
55316: LD_ADDR_VAR 0 4
55320: PUSH
55321: DOUBLE
55322: LD_VAR 0 1
55326: INC
55327: ST_TO_ADDR
55328: LD_VAR 0 2
55332: PUSH
55333: FOR_DOWNTO
55334: IFFALSE 55358
// result := Delete ( result , result ) ;
55336: LD_ADDR_VAR 0 3
55340: PUSH
55341: LD_VAR 0 3
55345: PPUSH
55346: LD_VAR 0 3
55350: PPUSH
55351: CALL_OW 3
55355: ST_TO_ADDR
55356: GO 55333
55358: POP
55359: POP
// end ;
55360: LD_VAR 0 3
55364: RET
// export function ComExit ( unit ) ; var tmp ; begin
55365: LD_INT 0
55367: PPUSH
55368: PPUSH
// if not IsInUnit ( unit ) then
55369: LD_VAR 0 1
55373: PPUSH
55374: CALL_OW 310
55378: NOT
55379: IFFALSE 55383
// exit ;
55381: GO 55443
// tmp := IsInUnit ( unit ) ;
55383: LD_ADDR_VAR 0 3
55387: PUSH
55388: LD_VAR 0 1
55392: PPUSH
55393: CALL_OW 310
55397: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
55398: LD_VAR 0 3
55402: PPUSH
55403: CALL_OW 247
55407: PUSH
55408: LD_INT 2
55410: EQUAL
55411: IFFALSE 55424
// ComExitVehicle ( unit ) else
55413: LD_VAR 0 1
55417: PPUSH
55418: CALL_OW 121
55422: GO 55433
// ComExitBuilding ( unit ) ;
55424: LD_VAR 0 1
55428: PPUSH
55429: CALL_OW 122
// result := tmp ;
55433: LD_ADDR_VAR 0 2
55437: PUSH
55438: LD_VAR 0 3
55442: ST_TO_ADDR
// end ;
55443: LD_VAR 0 2
55447: RET
// export function ComExitAll ( units ) ; var i ; begin
55448: LD_INT 0
55450: PPUSH
55451: PPUSH
// if not units then
55452: LD_VAR 0 1
55456: NOT
55457: IFFALSE 55461
// exit ;
55459: GO 55487
// for i in units do
55461: LD_ADDR_VAR 0 3
55465: PUSH
55466: LD_VAR 0 1
55470: PUSH
55471: FOR_IN
55472: IFFALSE 55485
// ComExit ( i ) ;
55474: LD_VAR 0 3
55478: PPUSH
55479: CALL 55365 0 1
55483: GO 55471
55485: POP
55486: POP
// end ;
55487: LD_VAR 0 2
55491: RET
// export function ResetHc ; begin
55492: LD_INT 0
55494: PPUSH
// InitHc ;
55495: CALL_OW 19
// hc_importance := 0 ;
55499: LD_ADDR_OWVAR 32
55503: PUSH
55504: LD_INT 0
55506: ST_TO_ADDR
// end ;
55507: LD_VAR 0 1
55511: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
55512: LD_INT 0
55514: PPUSH
55515: PPUSH
55516: PPUSH
// _x := ( x1 + x2 ) div 2 ;
55517: LD_ADDR_VAR 0 6
55521: PUSH
55522: LD_VAR 0 1
55526: PUSH
55527: LD_VAR 0 3
55531: PLUS
55532: PUSH
55533: LD_INT 2
55535: DIV
55536: ST_TO_ADDR
// if _x < 0 then
55537: LD_VAR 0 6
55541: PUSH
55542: LD_INT 0
55544: LESS
55545: IFFALSE 55562
// _x := _x * - 1 ;
55547: LD_ADDR_VAR 0 6
55551: PUSH
55552: LD_VAR 0 6
55556: PUSH
55557: LD_INT 1
55559: NEG
55560: MUL
55561: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
55562: LD_ADDR_VAR 0 7
55566: PUSH
55567: LD_VAR 0 2
55571: PUSH
55572: LD_VAR 0 4
55576: PLUS
55577: PUSH
55578: LD_INT 2
55580: DIV
55581: ST_TO_ADDR
// if _y < 0 then
55582: LD_VAR 0 7
55586: PUSH
55587: LD_INT 0
55589: LESS
55590: IFFALSE 55607
// _y := _y * - 1 ;
55592: LD_ADDR_VAR 0 7
55596: PUSH
55597: LD_VAR 0 7
55601: PUSH
55602: LD_INT 1
55604: NEG
55605: MUL
55606: ST_TO_ADDR
// result := [ _x , _y ] ;
55607: LD_ADDR_VAR 0 5
55611: PUSH
55612: LD_VAR 0 6
55616: PUSH
55617: LD_VAR 0 7
55621: PUSH
55622: EMPTY
55623: LIST
55624: LIST
55625: ST_TO_ADDR
// end ;
55626: LD_VAR 0 5
55630: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
55631: LD_INT 0
55633: PPUSH
55634: PPUSH
55635: PPUSH
55636: PPUSH
// task := GetTaskList ( unit ) ;
55637: LD_ADDR_VAR 0 7
55641: PUSH
55642: LD_VAR 0 1
55646: PPUSH
55647: CALL_OW 437
55651: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
55652: LD_VAR 0 7
55656: NOT
55657: PUSH
55658: LD_VAR 0 1
55662: PPUSH
55663: LD_VAR 0 2
55667: PPUSH
55668: CALL_OW 308
55672: NOT
55673: AND
55674: IFFALSE 55678
// exit ;
55676: GO 55796
// if IsInArea ( unit , area ) then
55678: LD_VAR 0 1
55682: PPUSH
55683: LD_VAR 0 2
55687: PPUSH
55688: CALL_OW 308
55692: IFFALSE 55710
// begin ComMoveToArea ( unit , goAway ) ;
55694: LD_VAR 0 1
55698: PPUSH
55699: LD_VAR 0 3
55703: PPUSH
55704: CALL_OW 113
// exit ;
55708: GO 55796
// end ; if task [ 1 ] [ 1 ] <> M then
55710: LD_VAR 0 7
55714: PUSH
55715: LD_INT 1
55717: ARRAY
55718: PUSH
55719: LD_INT 1
55721: ARRAY
55722: PUSH
55723: LD_STRING M
55725: NONEQUAL
55726: IFFALSE 55730
// exit ;
55728: GO 55796
// x := task [ 1 ] [ 2 ] ;
55730: LD_ADDR_VAR 0 5
55734: PUSH
55735: LD_VAR 0 7
55739: PUSH
55740: LD_INT 1
55742: ARRAY
55743: PUSH
55744: LD_INT 2
55746: ARRAY
55747: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
55748: LD_ADDR_VAR 0 6
55752: PUSH
55753: LD_VAR 0 7
55757: PUSH
55758: LD_INT 1
55760: ARRAY
55761: PUSH
55762: LD_INT 3
55764: ARRAY
55765: ST_TO_ADDR
// if InArea ( x , y , area ) then
55766: LD_VAR 0 5
55770: PPUSH
55771: LD_VAR 0 6
55775: PPUSH
55776: LD_VAR 0 2
55780: PPUSH
55781: CALL_OW 309
55785: IFFALSE 55796
// ComStop ( unit ) ;
55787: LD_VAR 0 1
55791: PPUSH
55792: CALL_OW 141
// end ;
55796: LD_VAR 0 4
55800: RET
// export function Abs ( value ) ; begin
55801: LD_INT 0
55803: PPUSH
// result := value ;
55804: LD_ADDR_VAR 0 2
55808: PUSH
55809: LD_VAR 0 1
55813: ST_TO_ADDR
// if value < 0 then
55814: LD_VAR 0 1
55818: PUSH
55819: LD_INT 0
55821: LESS
55822: IFFALSE 55839
// result := value * - 1 ;
55824: LD_ADDR_VAR 0 2
55828: PUSH
55829: LD_VAR 0 1
55833: PUSH
55834: LD_INT 1
55836: NEG
55837: MUL
55838: ST_TO_ADDR
// end ;
55839: LD_VAR 0 2
55843: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
55844: LD_INT 0
55846: PPUSH
55847: PPUSH
55848: PPUSH
55849: PPUSH
55850: PPUSH
55851: PPUSH
55852: PPUSH
55853: PPUSH
// if not unit or not building then
55854: LD_VAR 0 1
55858: NOT
55859: PUSH
55860: LD_VAR 0 2
55864: NOT
55865: OR
55866: IFFALSE 55870
// exit ;
55868: GO 56096
// x := GetX ( building ) ;
55870: LD_ADDR_VAR 0 4
55874: PUSH
55875: LD_VAR 0 2
55879: PPUSH
55880: CALL_OW 250
55884: ST_TO_ADDR
// y := GetY ( building ) ;
55885: LD_ADDR_VAR 0 6
55889: PUSH
55890: LD_VAR 0 2
55894: PPUSH
55895: CALL_OW 251
55899: ST_TO_ADDR
// d := GetDir ( building ) ;
55900: LD_ADDR_VAR 0 8
55904: PUSH
55905: LD_VAR 0 2
55909: PPUSH
55910: CALL_OW 254
55914: ST_TO_ADDR
// r := 4 ;
55915: LD_ADDR_VAR 0 9
55919: PUSH
55920: LD_INT 4
55922: ST_TO_ADDR
// for i := 1 to 5 do
55923: LD_ADDR_VAR 0 10
55927: PUSH
55928: DOUBLE
55929: LD_INT 1
55931: DEC
55932: ST_TO_ADDR
55933: LD_INT 5
55935: PUSH
55936: FOR_TO
55937: IFFALSE 56094
// begin _x := ShiftX ( x , d , r + i ) ;
55939: LD_ADDR_VAR 0 5
55943: PUSH
55944: LD_VAR 0 4
55948: PPUSH
55949: LD_VAR 0 8
55953: PPUSH
55954: LD_VAR 0 9
55958: PUSH
55959: LD_VAR 0 10
55963: PLUS
55964: PPUSH
55965: CALL_OW 272
55969: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
55970: LD_ADDR_VAR 0 7
55974: PUSH
55975: LD_VAR 0 6
55979: PPUSH
55980: LD_VAR 0 8
55984: PPUSH
55985: LD_VAR 0 9
55989: PUSH
55990: LD_VAR 0 10
55994: PLUS
55995: PPUSH
55996: CALL_OW 273
56000: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
56001: LD_VAR 0 5
56005: PPUSH
56006: LD_VAR 0 7
56010: PPUSH
56011: CALL_OW 488
56015: PUSH
56016: LD_VAR 0 5
56020: PPUSH
56021: LD_VAR 0 7
56025: PPUSH
56026: CALL_OW 428
56030: PPUSH
56031: CALL_OW 247
56035: PUSH
56036: LD_INT 3
56038: PUSH
56039: LD_INT 2
56041: PUSH
56042: EMPTY
56043: LIST
56044: LIST
56045: IN
56046: NOT
56047: AND
56048: IFFALSE 56092
// begin ComMoveXY ( unit , _x , _y ) ;
56050: LD_VAR 0 1
56054: PPUSH
56055: LD_VAR 0 5
56059: PPUSH
56060: LD_VAR 0 7
56064: PPUSH
56065: CALL_OW 111
// result := [ _x , _y ] ;
56069: LD_ADDR_VAR 0 3
56073: PUSH
56074: LD_VAR 0 5
56078: PUSH
56079: LD_VAR 0 7
56083: PUSH
56084: EMPTY
56085: LIST
56086: LIST
56087: ST_TO_ADDR
// exit ;
56088: POP
56089: POP
56090: GO 56096
// end ; end ;
56092: GO 55936
56094: POP
56095: POP
// end ;
56096: LD_VAR 0 3
56100: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
56101: LD_INT 0
56103: PPUSH
56104: PPUSH
56105: PPUSH
// result := 0 ;
56106: LD_ADDR_VAR 0 3
56110: PUSH
56111: LD_INT 0
56113: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
56114: LD_VAR 0 1
56118: PUSH
56119: LD_INT 0
56121: LESS
56122: PUSH
56123: LD_VAR 0 1
56127: PUSH
56128: LD_INT 8
56130: GREATER
56131: OR
56132: PUSH
56133: LD_VAR 0 2
56137: PUSH
56138: LD_INT 0
56140: LESS
56141: OR
56142: PUSH
56143: LD_VAR 0 2
56147: PUSH
56148: LD_INT 8
56150: GREATER
56151: OR
56152: IFFALSE 56156
// exit ;
56154: GO 56231
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
56156: LD_ADDR_VAR 0 4
56160: PUSH
56161: LD_INT 22
56163: PUSH
56164: LD_VAR 0 2
56168: PUSH
56169: EMPTY
56170: LIST
56171: LIST
56172: PPUSH
56173: CALL_OW 69
56177: PUSH
56178: FOR_IN
56179: IFFALSE 56229
// begin un := UnitShoot ( i ) ;
56181: LD_ADDR_VAR 0 5
56185: PUSH
56186: LD_VAR 0 4
56190: PPUSH
56191: CALL_OW 504
56195: ST_TO_ADDR
// if GetSide ( un ) = side1 then
56196: LD_VAR 0 5
56200: PPUSH
56201: CALL_OW 255
56205: PUSH
56206: LD_VAR 0 1
56210: EQUAL
56211: IFFALSE 56227
// begin result := un ;
56213: LD_ADDR_VAR 0 3
56217: PUSH
56218: LD_VAR 0 5
56222: ST_TO_ADDR
// exit ;
56223: POP
56224: POP
56225: GO 56231
// end ; end ;
56227: GO 56178
56229: POP
56230: POP
// end ;
56231: LD_VAR 0 3
56235: RET
// export function GetCargoBay ( units ) ; begin
56236: LD_INT 0
56238: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
56239: LD_ADDR_VAR 0 2
56243: PUSH
56244: LD_VAR 0 1
56248: PPUSH
56249: LD_INT 2
56251: PUSH
56252: LD_INT 34
56254: PUSH
56255: LD_INT 12
56257: PUSH
56258: EMPTY
56259: LIST
56260: LIST
56261: PUSH
56262: LD_INT 34
56264: PUSH
56265: LD_INT 51
56267: PUSH
56268: EMPTY
56269: LIST
56270: LIST
56271: PUSH
56272: LD_INT 34
56274: PUSH
56275: LD_INT 32
56277: PUSH
56278: EMPTY
56279: LIST
56280: LIST
56281: PUSH
56282: LD_INT 34
56284: PUSH
56285: LD_INT 89
56287: PUSH
56288: EMPTY
56289: LIST
56290: LIST
56291: PUSH
56292: EMPTY
56293: LIST
56294: LIST
56295: LIST
56296: LIST
56297: LIST
56298: PPUSH
56299: CALL_OW 72
56303: ST_TO_ADDR
// end ;
56304: LD_VAR 0 2
56308: RET
// export function Negate ( value ) ; begin
56309: LD_INT 0
56311: PPUSH
// result := not value ;
56312: LD_ADDR_VAR 0 2
56316: PUSH
56317: LD_VAR 0 1
56321: NOT
56322: ST_TO_ADDR
// end ;
56323: LD_VAR 0 2
56327: RET
// export function Inc ( value ) ; begin
56328: LD_INT 0
56330: PPUSH
// result := value + 1 ;
56331: LD_ADDR_VAR 0 2
56335: PUSH
56336: LD_VAR 0 1
56340: PUSH
56341: LD_INT 1
56343: PLUS
56344: ST_TO_ADDR
// end ;
56345: LD_VAR 0 2
56349: RET
// export function Dec ( value ) ; begin
56350: LD_INT 0
56352: PPUSH
// result := value - 1 ;
56353: LD_ADDR_VAR 0 2
56357: PUSH
56358: LD_VAR 0 1
56362: PUSH
56363: LD_INT 1
56365: MINUS
56366: ST_TO_ADDR
// end ;
56367: LD_VAR 0 2
56371: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
56372: LD_INT 0
56374: PPUSH
56375: PPUSH
56376: PPUSH
56377: PPUSH
56378: PPUSH
56379: PPUSH
56380: PPUSH
56381: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
56382: LD_VAR 0 1
56386: PPUSH
56387: LD_VAR 0 2
56391: PPUSH
56392: CALL_OW 488
56396: NOT
56397: PUSH
56398: LD_VAR 0 3
56402: PPUSH
56403: LD_VAR 0 4
56407: PPUSH
56408: CALL_OW 488
56412: NOT
56413: OR
56414: IFFALSE 56427
// begin result := - 1 ;
56416: LD_ADDR_VAR 0 5
56420: PUSH
56421: LD_INT 1
56423: NEG
56424: ST_TO_ADDR
// exit ;
56425: GO 56662
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
56427: LD_ADDR_VAR 0 12
56431: PUSH
56432: LD_VAR 0 1
56436: PPUSH
56437: LD_VAR 0 2
56441: PPUSH
56442: LD_VAR 0 3
56446: PPUSH
56447: LD_VAR 0 4
56451: PPUSH
56452: CALL 55512 0 4
56456: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
56457: LD_ADDR_VAR 0 11
56461: PUSH
56462: LD_VAR 0 1
56466: PPUSH
56467: LD_VAR 0 2
56471: PPUSH
56472: LD_VAR 0 12
56476: PUSH
56477: LD_INT 1
56479: ARRAY
56480: PPUSH
56481: LD_VAR 0 12
56485: PUSH
56486: LD_INT 2
56488: ARRAY
56489: PPUSH
56490: CALL_OW 298
56494: ST_TO_ADDR
// distance := 9999 ;
56495: LD_ADDR_VAR 0 10
56499: PUSH
56500: LD_INT 9999
56502: ST_TO_ADDR
// for i := 0 to 5 do
56503: LD_ADDR_VAR 0 6
56507: PUSH
56508: DOUBLE
56509: LD_INT 0
56511: DEC
56512: ST_TO_ADDR
56513: LD_INT 5
56515: PUSH
56516: FOR_TO
56517: IFFALSE 56660
// begin _x := ShiftX ( x1 , i , centerDist ) ;
56519: LD_ADDR_VAR 0 7
56523: PUSH
56524: LD_VAR 0 1
56528: PPUSH
56529: LD_VAR 0 6
56533: PPUSH
56534: LD_VAR 0 11
56538: PPUSH
56539: CALL_OW 272
56543: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
56544: LD_ADDR_VAR 0 8
56548: PUSH
56549: LD_VAR 0 2
56553: PPUSH
56554: LD_VAR 0 6
56558: PPUSH
56559: LD_VAR 0 11
56563: PPUSH
56564: CALL_OW 273
56568: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
56569: LD_VAR 0 7
56573: PPUSH
56574: LD_VAR 0 8
56578: PPUSH
56579: CALL_OW 488
56583: NOT
56584: IFFALSE 56588
// continue ;
56586: GO 56516
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
56588: LD_ADDR_VAR 0 9
56592: PUSH
56593: LD_VAR 0 12
56597: PUSH
56598: LD_INT 1
56600: ARRAY
56601: PPUSH
56602: LD_VAR 0 12
56606: PUSH
56607: LD_INT 2
56609: ARRAY
56610: PPUSH
56611: LD_VAR 0 7
56615: PPUSH
56616: LD_VAR 0 8
56620: PPUSH
56621: CALL_OW 298
56625: ST_TO_ADDR
// if tmp < distance then
56626: LD_VAR 0 9
56630: PUSH
56631: LD_VAR 0 10
56635: LESS
56636: IFFALSE 56658
// begin result := i ;
56638: LD_ADDR_VAR 0 5
56642: PUSH
56643: LD_VAR 0 6
56647: ST_TO_ADDR
// distance := tmp ;
56648: LD_ADDR_VAR 0 10
56652: PUSH
56653: LD_VAR 0 9
56657: ST_TO_ADDR
// end ; end ;
56658: GO 56516
56660: POP
56661: POP
// end ;
56662: LD_VAR 0 5
56666: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
56667: LD_INT 0
56669: PPUSH
56670: PPUSH
// if not driver or not IsInUnit ( driver ) then
56671: LD_VAR 0 1
56675: NOT
56676: PUSH
56677: LD_VAR 0 1
56681: PPUSH
56682: CALL_OW 310
56686: NOT
56687: OR
56688: IFFALSE 56692
// exit ;
56690: GO 56782
// vehicle := IsInUnit ( driver ) ;
56692: LD_ADDR_VAR 0 3
56696: PUSH
56697: LD_VAR 0 1
56701: PPUSH
56702: CALL_OW 310
56706: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
56707: LD_VAR 0 1
56711: PPUSH
56712: LD_STRING \
56714: PUSH
56715: LD_INT 0
56717: PUSH
56718: LD_INT 0
56720: PUSH
56721: LD_INT 0
56723: PUSH
56724: LD_INT 0
56726: PUSH
56727: LD_INT 0
56729: PUSH
56730: LD_INT 0
56732: PUSH
56733: EMPTY
56734: LIST
56735: LIST
56736: LIST
56737: LIST
56738: LIST
56739: LIST
56740: LIST
56741: PUSH
56742: LD_STRING E
56744: PUSH
56745: LD_INT 0
56747: PUSH
56748: LD_INT 0
56750: PUSH
56751: LD_VAR 0 3
56755: PUSH
56756: LD_INT 0
56758: PUSH
56759: LD_INT 0
56761: PUSH
56762: LD_INT 0
56764: PUSH
56765: EMPTY
56766: LIST
56767: LIST
56768: LIST
56769: LIST
56770: LIST
56771: LIST
56772: LIST
56773: PUSH
56774: EMPTY
56775: LIST
56776: LIST
56777: PPUSH
56778: CALL_OW 446
// end ;
56782: LD_VAR 0 2
56786: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
56787: LD_INT 0
56789: PPUSH
56790: PPUSH
// if not driver or not IsInUnit ( driver ) then
56791: LD_VAR 0 1
56795: NOT
56796: PUSH
56797: LD_VAR 0 1
56801: PPUSH
56802: CALL_OW 310
56806: NOT
56807: OR
56808: IFFALSE 56812
// exit ;
56810: GO 56902
// vehicle := IsInUnit ( driver ) ;
56812: LD_ADDR_VAR 0 3
56816: PUSH
56817: LD_VAR 0 1
56821: PPUSH
56822: CALL_OW 310
56826: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
56827: LD_VAR 0 1
56831: PPUSH
56832: LD_STRING \
56834: PUSH
56835: LD_INT 0
56837: PUSH
56838: LD_INT 0
56840: PUSH
56841: LD_INT 0
56843: PUSH
56844: LD_INT 0
56846: PUSH
56847: LD_INT 0
56849: PUSH
56850: LD_INT 0
56852: PUSH
56853: EMPTY
56854: LIST
56855: LIST
56856: LIST
56857: LIST
56858: LIST
56859: LIST
56860: LIST
56861: PUSH
56862: LD_STRING E
56864: PUSH
56865: LD_INT 0
56867: PUSH
56868: LD_INT 0
56870: PUSH
56871: LD_VAR 0 3
56875: PUSH
56876: LD_INT 0
56878: PUSH
56879: LD_INT 0
56881: PUSH
56882: LD_INT 0
56884: PUSH
56885: EMPTY
56886: LIST
56887: LIST
56888: LIST
56889: LIST
56890: LIST
56891: LIST
56892: LIST
56893: PUSH
56894: EMPTY
56895: LIST
56896: LIST
56897: PPUSH
56898: CALL_OW 447
// end ;
56902: LD_VAR 0 2
56906: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
56907: LD_INT 0
56909: PPUSH
56910: PPUSH
56911: PPUSH
// tmp := [ ] ;
56912: LD_ADDR_VAR 0 5
56916: PUSH
56917: EMPTY
56918: ST_TO_ADDR
// for i in units do
56919: LD_ADDR_VAR 0 4
56923: PUSH
56924: LD_VAR 0 1
56928: PUSH
56929: FOR_IN
56930: IFFALSE 56968
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
56932: LD_ADDR_VAR 0 5
56936: PUSH
56937: LD_VAR 0 5
56941: PPUSH
56942: LD_VAR 0 5
56946: PUSH
56947: LD_INT 1
56949: PLUS
56950: PPUSH
56951: LD_VAR 0 4
56955: PPUSH
56956: CALL_OW 256
56960: PPUSH
56961: CALL_OW 2
56965: ST_TO_ADDR
56966: GO 56929
56968: POP
56969: POP
// if not tmp then
56970: LD_VAR 0 5
56974: NOT
56975: IFFALSE 56979
// exit ;
56977: GO 57027
// if asc then
56979: LD_VAR 0 2
56983: IFFALSE 57007
// result := SortListByListAsc ( units , tmp ) else
56985: LD_ADDR_VAR 0 3
56989: PUSH
56990: LD_VAR 0 1
56994: PPUSH
56995: LD_VAR 0 5
56999: PPUSH
57000: CALL_OW 76
57004: ST_TO_ADDR
57005: GO 57027
// result := SortListByListDesc ( units , tmp ) ;
57007: LD_ADDR_VAR 0 3
57011: PUSH
57012: LD_VAR 0 1
57016: PPUSH
57017: LD_VAR 0 5
57021: PPUSH
57022: CALL_OW 77
57026: ST_TO_ADDR
// end ;
57027: LD_VAR 0 3
57031: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
57032: LD_INT 0
57034: PPUSH
57035: PPUSH
// task := GetTaskList ( mech ) ;
57036: LD_ADDR_VAR 0 4
57040: PUSH
57041: LD_VAR 0 1
57045: PPUSH
57046: CALL_OW 437
57050: ST_TO_ADDR
// if not task then
57051: LD_VAR 0 4
57055: NOT
57056: IFFALSE 57060
// exit ;
57058: GO 57102
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
57060: LD_ADDR_VAR 0 3
57064: PUSH
57065: LD_VAR 0 4
57069: PUSH
57070: LD_INT 1
57072: ARRAY
57073: PUSH
57074: LD_INT 1
57076: ARRAY
57077: PUSH
57078: LD_STRING r
57080: EQUAL
57081: PUSH
57082: LD_VAR 0 4
57086: PUSH
57087: LD_INT 1
57089: ARRAY
57090: PUSH
57091: LD_INT 4
57093: ARRAY
57094: PUSH
57095: LD_VAR 0 2
57099: EQUAL
57100: AND
57101: ST_TO_ADDR
// end ;
57102: LD_VAR 0 3
57106: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
57107: LD_INT 0
57109: PPUSH
// SetDir ( unit , d ) ;
57110: LD_VAR 0 1
57114: PPUSH
57115: LD_VAR 0 4
57119: PPUSH
57120: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
57124: LD_VAR 0 1
57128: PPUSH
57129: LD_VAR 0 2
57133: PPUSH
57134: LD_VAR 0 3
57138: PPUSH
57139: LD_VAR 0 5
57143: PPUSH
57144: CALL_OW 48
// end ;
57148: LD_VAR 0 6
57152: RET
// export function ToNaturalNumber ( number ) ; begin
57153: LD_INT 0
57155: PPUSH
// result := number div 1 ;
57156: LD_ADDR_VAR 0 2
57160: PUSH
57161: LD_VAR 0 1
57165: PUSH
57166: LD_INT 1
57168: DIV
57169: ST_TO_ADDR
// if number < 0 then
57170: LD_VAR 0 1
57174: PUSH
57175: LD_INT 0
57177: LESS
57178: IFFALSE 57188
// result := 0 ;
57180: LD_ADDR_VAR 0 2
57184: PUSH
57185: LD_INT 0
57187: ST_TO_ADDR
// end ;
57188: LD_VAR 0 2
57192: RET
// export function SortByClass ( units , class ) ; var un ; begin
57193: LD_INT 0
57195: PPUSH
57196: PPUSH
// if not units or not class then
57197: LD_VAR 0 1
57201: NOT
57202: PUSH
57203: LD_VAR 0 2
57207: NOT
57208: OR
57209: IFFALSE 57213
// exit ;
57211: GO 57308
// result := [ ] ;
57213: LD_ADDR_VAR 0 3
57217: PUSH
57218: EMPTY
57219: ST_TO_ADDR
// for un in units do
57220: LD_ADDR_VAR 0 4
57224: PUSH
57225: LD_VAR 0 1
57229: PUSH
57230: FOR_IN
57231: IFFALSE 57306
// if GetClass ( un ) = class then
57233: LD_VAR 0 4
57237: PPUSH
57238: CALL_OW 257
57242: PUSH
57243: LD_VAR 0 2
57247: EQUAL
57248: IFFALSE 57275
// result := Insert ( result , 1 , un ) else
57250: LD_ADDR_VAR 0 3
57254: PUSH
57255: LD_VAR 0 3
57259: PPUSH
57260: LD_INT 1
57262: PPUSH
57263: LD_VAR 0 4
57267: PPUSH
57268: CALL_OW 2
57272: ST_TO_ADDR
57273: GO 57304
// result := Replace ( result , result + 1 , un ) ;
57275: LD_ADDR_VAR 0 3
57279: PUSH
57280: LD_VAR 0 3
57284: PPUSH
57285: LD_VAR 0 3
57289: PUSH
57290: LD_INT 1
57292: PLUS
57293: PPUSH
57294: LD_VAR 0 4
57298: PPUSH
57299: CALL_OW 1
57303: ST_TO_ADDR
57304: GO 57230
57306: POP
57307: POP
// end ;
57308: LD_VAR 0 3
57312: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
57313: LD_INT 0
57315: PPUSH
57316: PPUSH
57317: PPUSH
57318: PPUSH
57319: PPUSH
57320: PPUSH
57321: PPUSH
// result := [ ] ;
57322: LD_ADDR_VAR 0 4
57326: PUSH
57327: EMPTY
57328: ST_TO_ADDR
// if x - r < 0 then
57329: LD_VAR 0 1
57333: PUSH
57334: LD_VAR 0 3
57338: MINUS
57339: PUSH
57340: LD_INT 0
57342: LESS
57343: IFFALSE 57355
// min_x := 0 else
57345: LD_ADDR_VAR 0 8
57349: PUSH
57350: LD_INT 0
57352: ST_TO_ADDR
57353: GO 57371
// min_x := x - r ;
57355: LD_ADDR_VAR 0 8
57359: PUSH
57360: LD_VAR 0 1
57364: PUSH
57365: LD_VAR 0 3
57369: MINUS
57370: ST_TO_ADDR
// if y - r < 0 then
57371: LD_VAR 0 2
57375: PUSH
57376: LD_VAR 0 3
57380: MINUS
57381: PUSH
57382: LD_INT 0
57384: LESS
57385: IFFALSE 57397
// min_y := 0 else
57387: LD_ADDR_VAR 0 7
57391: PUSH
57392: LD_INT 0
57394: ST_TO_ADDR
57395: GO 57413
// min_y := y - r ;
57397: LD_ADDR_VAR 0 7
57401: PUSH
57402: LD_VAR 0 2
57406: PUSH
57407: LD_VAR 0 3
57411: MINUS
57412: ST_TO_ADDR
// max_x := x + r ;
57413: LD_ADDR_VAR 0 9
57417: PUSH
57418: LD_VAR 0 1
57422: PUSH
57423: LD_VAR 0 3
57427: PLUS
57428: ST_TO_ADDR
// max_y := y + r ;
57429: LD_ADDR_VAR 0 10
57433: PUSH
57434: LD_VAR 0 2
57438: PUSH
57439: LD_VAR 0 3
57443: PLUS
57444: ST_TO_ADDR
// for _x = min_x to max_x do
57445: LD_ADDR_VAR 0 5
57449: PUSH
57450: DOUBLE
57451: LD_VAR 0 8
57455: DEC
57456: ST_TO_ADDR
57457: LD_VAR 0 9
57461: PUSH
57462: FOR_TO
57463: IFFALSE 57564
// for _y = min_y to max_y do
57465: LD_ADDR_VAR 0 6
57469: PUSH
57470: DOUBLE
57471: LD_VAR 0 7
57475: DEC
57476: ST_TO_ADDR
57477: LD_VAR 0 10
57481: PUSH
57482: FOR_TO
57483: IFFALSE 57560
// begin if not ValidHex ( _x , _y ) then
57485: LD_VAR 0 5
57489: PPUSH
57490: LD_VAR 0 6
57494: PPUSH
57495: CALL_OW 488
57499: NOT
57500: IFFALSE 57504
// continue ;
57502: GO 57482
// if GetResourceTypeXY ( _x , _y ) then
57504: LD_VAR 0 5
57508: PPUSH
57509: LD_VAR 0 6
57513: PPUSH
57514: CALL_OW 283
57518: IFFALSE 57558
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
57520: LD_ADDR_VAR 0 4
57524: PUSH
57525: LD_VAR 0 4
57529: PPUSH
57530: LD_VAR 0 4
57534: PUSH
57535: LD_INT 1
57537: PLUS
57538: PPUSH
57539: LD_VAR 0 5
57543: PUSH
57544: LD_VAR 0 6
57548: PUSH
57549: EMPTY
57550: LIST
57551: LIST
57552: PPUSH
57553: CALL_OW 1
57557: ST_TO_ADDR
// end ;
57558: GO 57482
57560: POP
57561: POP
57562: GO 57462
57564: POP
57565: POP
// end ;
57566: LD_VAR 0 4
57570: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
57571: LD_INT 0
57573: PPUSH
57574: PPUSH
57575: PPUSH
57576: PPUSH
57577: PPUSH
57578: PPUSH
57579: PPUSH
57580: PPUSH
// if not units then
57581: LD_VAR 0 1
57585: NOT
57586: IFFALSE 57590
// exit ;
57588: GO 58118
// result := UnitFilter ( units , [ f_ok ] ) ;
57590: LD_ADDR_VAR 0 3
57594: PUSH
57595: LD_VAR 0 1
57599: PPUSH
57600: LD_INT 50
57602: PUSH
57603: EMPTY
57604: LIST
57605: PPUSH
57606: CALL_OW 72
57610: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
57611: LD_ADDR_VAR 0 8
57615: PUSH
57616: LD_VAR 0 1
57620: PUSH
57621: LD_INT 1
57623: ARRAY
57624: PPUSH
57625: CALL_OW 255
57629: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
57630: LD_ADDR_VAR 0 10
57634: PUSH
57635: LD_INT 29
57637: PUSH
57638: LD_INT 91
57640: PUSH
57641: LD_INT 49
57643: PUSH
57644: EMPTY
57645: LIST
57646: LIST
57647: LIST
57648: ST_TO_ADDR
// if not result then
57649: LD_VAR 0 3
57653: NOT
57654: IFFALSE 57658
// exit ;
57656: GO 58118
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
57658: LD_ADDR_VAR 0 5
57662: PUSH
57663: LD_INT 81
57665: PUSH
57666: LD_VAR 0 8
57670: PUSH
57671: EMPTY
57672: LIST
57673: LIST
57674: PPUSH
57675: CALL_OW 69
57679: ST_TO_ADDR
// for i in result do
57680: LD_ADDR_VAR 0 4
57684: PUSH
57685: LD_VAR 0 3
57689: PUSH
57690: FOR_IN
57691: IFFALSE 58116
// begin tag := GetTag ( i ) + 1 ;
57693: LD_ADDR_VAR 0 9
57697: PUSH
57698: LD_VAR 0 4
57702: PPUSH
57703: CALL_OW 110
57707: PUSH
57708: LD_INT 1
57710: PLUS
57711: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
57712: LD_ADDR_VAR 0 7
57716: PUSH
57717: LD_VAR 0 4
57721: PPUSH
57722: CALL_OW 250
57726: PPUSH
57727: LD_VAR 0 4
57731: PPUSH
57732: CALL_OW 251
57736: PPUSH
57737: LD_INT 4
57739: PPUSH
57740: CALL 57313 0 3
57744: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
57745: LD_VAR 0 4
57749: PPUSH
57750: CALL_OW 247
57754: PUSH
57755: LD_INT 2
57757: EQUAL
57758: PUSH
57759: LD_VAR 0 7
57763: PUSH
57764: LD_INT 2
57766: GREATER
57767: AND
57768: PUSH
57769: LD_VAR 0 4
57773: PPUSH
57774: CALL_OW 264
57778: PUSH
57779: LD_VAR 0 10
57783: IN
57784: NOT
57785: AND
57786: IFFALSE 57825
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
57788: LD_VAR 0 4
57792: PPUSH
57793: LD_VAR 0 7
57797: PUSH
57798: LD_INT 1
57800: ARRAY
57801: PUSH
57802: LD_INT 1
57804: ARRAY
57805: PPUSH
57806: LD_VAR 0 7
57810: PUSH
57811: LD_INT 1
57813: ARRAY
57814: PUSH
57815: LD_INT 2
57817: ARRAY
57818: PPUSH
57819: CALL_OW 116
57823: GO 58114
// if path > tag then
57825: LD_VAR 0 2
57829: PUSH
57830: LD_VAR 0 9
57834: GREATER
57835: IFFALSE 58043
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
57837: LD_ADDR_VAR 0 6
57841: PUSH
57842: LD_VAR 0 5
57846: PPUSH
57847: LD_INT 91
57849: PUSH
57850: LD_VAR 0 4
57854: PUSH
57855: LD_INT 8
57857: PUSH
57858: EMPTY
57859: LIST
57860: LIST
57861: LIST
57862: PPUSH
57863: CALL_OW 72
57867: ST_TO_ADDR
// if nearEnemy then
57868: LD_VAR 0 6
57872: IFFALSE 57941
// begin if GetWeapon ( i ) = ru_time_lapser then
57874: LD_VAR 0 4
57878: PPUSH
57879: CALL_OW 264
57883: PUSH
57884: LD_INT 49
57886: EQUAL
57887: IFFALSE 57915
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
57889: LD_VAR 0 4
57893: PPUSH
57894: LD_VAR 0 6
57898: PPUSH
57899: LD_VAR 0 4
57903: PPUSH
57904: CALL_OW 74
57908: PPUSH
57909: CALL_OW 112
57913: GO 57939
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
57915: LD_VAR 0 4
57919: PPUSH
57920: LD_VAR 0 6
57924: PPUSH
57925: LD_VAR 0 4
57929: PPUSH
57930: CALL_OW 74
57934: PPUSH
57935: CALL 59189 0 2
// end else
57939: GO 58041
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
57941: LD_VAR 0 4
57945: PPUSH
57946: LD_VAR 0 2
57950: PUSH
57951: LD_VAR 0 9
57955: ARRAY
57956: PUSH
57957: LD_INT 1
57959: ARRAY
57960: PPUSH
57961: LD_VAR 0 2
57965: PUSH
57966: LD_VAR 0 9
57970: ARRAY
57971: PUSH
57972: LD_INT 2
57974: ARRAY
57975: PPUSH
57976: CALL_OW 297
57980: PUSH
57981: LD_INT 6
57983: GREATER
57984: IFFALSE 58027
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
57986: LD_VAR 0 4
57990: PPUSH
57991: LD_VAR 0 2
57995: PUSH
57996: LD_VAR 0 9
58000: ARRAY
58001: PUSH
58002: LD_INT 1
58004: ARRAY
58005: PPUSH
58006: LD_VAR 0 2
58010: PUSH
58011: LD_VAR 0 9
58015: ARRAY
58016: PUSH
58017: LD_INT 2
58019: ARRAY
58020: PPUSH
58021: CALL_OW 114
58025: GO 58041
// SetTag ( i , tag ) ;
58027: LD_VAR 0 4
58031: PPUSH
58032: LD_VAR 0 9
58036: PPUSH
58037: CALL_OW 109
// end else
58041: GO 58114
// if enemy then
58043: LD_VAR 0 5
58047: IFFALSE 58114
// begin if GetWeapon ( i ) = ru_time_lapser then
58049: LD_VAR 0 4
58053: PPUSH
58054: CALL_OW 264
58058: PUSH
58059: LD_INT 49
58061: EQUAL
58062: IFFALSE 58090
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
58064: LD_VAR 0 4
58068: PPUSH
58069: LD_VAR 0 5
58073: PPUSH
58074: LD_VAR 0 4
58078: PPUSH
58079: CALL_OW 74
58083: PPUSH
58084: CALL_OW 112
58088: GO 58114
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
58090: LD_VAR 0 4
58094: PPUSH
58095: LD_VAR 0 5
58099: PPUSH
58100: LD_VAR 0 4
58104: PPUSH
58105: CALL_OW 74
58109: PPUSH
58110: CALL 59189 0 2
// end ; end ;
58114: GO 57690
58116: POP
58117: POP
// end ;
58118: LD_VAR 0 3
58122: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
58123: LD_INT 0
58125: PPUSH
58126: PPUSH
58127: PPUSH
// if not unit or IsInUnit ( unit ) then
58128: LD_VAR 0 1
58132: NOT
58133: PUSH
58134: LD_VAR 0 1
58138: PPUSH
58139: CALL_OW 310
58143: OR
58144: IFFALSE 58148
// exit ;
58146: GO 58239
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
58148: LD_ADDR_VAR 0 4
58152: PUSH
58153: LD_VAR 0 1
58157: PPUSH
58158: CALL_OW 250
58162: PPUSH
58163: LD_VAR 0 2
58167: PPUSH
58168: LD_INT 1
58170: PPUSH
58171: CALL_OW 272
58175: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
58176: LD_ADDR_VAR 0 5
58180: PUSH
58181: LD_VAR 0 1
58185: PPUSH
58186: CALL_OW 251
58190: PPUSH
58191: LD_VAR 0 2
58195: PPUSH
58196: LD_INT 1
58198: PPUSH
58199: CALL_OW 273
58203: ST_TO_ADDR
// if ValidHex ( x , y ) then
58204: LD_VAR 0 4
58208: PPUSH
58209: LD_VAR 0 5
58213: PPUSH
58214: CALL_OW 488
58218: IFFALSE 58239
// ComTurnXY ( unit , x , y ) ;
58220: LD_VAR 0 1
58224: PPUSH
58225: LD_VAR 0 4
58229: PPUSH
58230: LD_VAR 0 5
58234: PPUSH
58235: CALL_OW 118
// end ;
58239: LD_VAR 0 3
58243: RET
// export function SeeUnits ( side , units ) ; var i ; begin
58244: LD_INT 0
58246: PPUSH
58247: PPUSH
// result := false ;
58248: LD_ADDR_VAR 0 3
58252: PUSH
58253: LD_INT 0
58255: ST_TO_ADDR
// if not units then
58256: LD_VAR 0 2
58260: NOT
58261: IFFALSE 58265
// exit ;
58263: GO 58310
// for i in units do
58265: LD_ADDR_VAR 0 4
58269: PUSH
58270: LD_VAR 0 2
58274: PUSH
58275: FOR_IN
58276: IFFALSE 58308
// if See ( side , i ) then
58278: LD_VAR 0 1
58282: PPUSH
58283: LD_VAR 0 4
58287: PPUSH
58288: CALL_OW 292
58292: IFFALSE 58306
// begin result := true ;
58294: LD_ADDR_VAR 0 3
58298: PUSH
58299: LD_INT 1
58301: ST_TO_ADDR
// exit ;
58302: POP
58303: POP
58304: GO 58310
// end ;
58306: GO 58275
58308: POP
58309: POP
// end ;
58310: LD_VAR 0 3
58314: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
58315: LD_INT 0
58317: PPUSH
58318: PPUSH
58319: PPUSH
58320: PPUSH
// if not unit or not points then
58321: LD_VAR 0 1
58325: NOT
58326: PUSH
58327: LD_VAR 0 2
58331: NOT
58332: OR
58333: IFFALSE 58337
// exit ;
58335: GO 58427
// dist := 99999 ;
58337: LD_ADDR_VAR 0 5
58341: PUSH
58342: LD_INT 99999
58344: ST_TO_ADDR
// for i in points do
58345: LD_ADDR_VAR 0 4
58349: PUSH
58350: LD_VAR 0 2
58354: PUSH
58355: FOR_IN
58356: IFFALSE 58425
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
58358: LD_ADDR_VAR 0 6
58362: PUSH
58363: LD_VAR 0 1
58367: PPUSH
58368: LD_VAR 0 4
58372: PUSH
58373: LD_INT 1
58375: ARRAY
58376: PPUSH
58377: LD_VAR 0 4
58381: PUSH
58382: LD_INT 2
58384: ARRAY
58385: PPUSH
58386: CALL_OW 297
58390: ST_TO_ADDR
// if tmpDist < dist then
58391: LD_VAR 0 6
58395: PUSH
58396: LD_VAR 0 5
58400: LESS
58401: IFFALSE 58423
// begin result := i ;
58403: LD_ADDR_VAR 0 3
58407: PUSH
58408: LD_VAR 0 4
58412: ST_TO_ADDR
// dist := tmpDist ;
58413: LD_ADDR_VAR 0 5
58417: PUSH
58418: LD_VAR 0 6
58422: ST_TO_ADDR
// end ; end ;
58423: GO 58355
58425: POP
58426: POP
// end ;
58427: LD_VAR 0 3
58431: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
58432: LD_INT 0
58434: PPUSH
// uc_side := side ;
58435: LD_ADDR_OWVAR 20
58439: PUSH
58440: LD_VAR 0 1
58444: ST_TO_ADDR
// uc_nation := 3 ;
58445: LD_ADDR_OWVAR 21
58449: PUSH
58450: LD_INT 3
58452: ST_TO_ADDR
// vc_chassis := 25 ;
58453: LD_ADDR_OWVAR 37
58457: PUSH
58458: LD_INT 25
58460: ST_TO_ADDR
// vc_engine := engine_siberite ;
58461: LD_ADDR_OWVAR 39
58465: PUSH
58466: LD_INT 3
58468: ST_TO_ADDR
// vc_control := control_computer ;
58469: LD_ADDR_OWVAR 38
58473: PUSH
58474: LD_INT 3
58476: ST_TO_ADDR
// vc_weapon := 59 ;
58477: LD_ADDR_OWVAR 40
58481: PUSH
58482: LD_INT 59
58484: ST_TO_ADDR
// result := CreateVehicle ;
58485: LD_ADDR_VAR 0 5
58489: PUSH
58490: CALL_OW 45
58494: ST_TO_ADDR
// SetDir ( result , d ) ;
58495: LD_VAR 0 5
58499: PPUSH
58500: LD_VAR 0 4
58504: PPUSH
58505: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
58509: LD_VAR 0 5
58513: PPUSH
58514: LD_VAR 0 2
58518: PPUSH
58519: LD_VAR 0 3
58523: PPUSH
58524: LD_INT 0
58526: PPUSH
58527: CALL_OW 48
// end ;
58531: LD_VAR 0 5
58535: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
58536: LD_INT 0
58538: PPUSH
58539: PPUSH
58540: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
58541: LD_ADDR_VAR 0 2
58545: PUSH
58546: LD_INT 0
58548: PUSH
58549: LD_INT 0
58551: PUSH
58552: LD_INT 0
58554: PUSH
58555: LD_INT 0
58557: PUSH
58558: EMPTY
58559: LIST
58560: LIST
58561: LIST
58562: LIST
58563: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
58564: LD_VAR 0 1
58568: NOT
58569: PUSH
58570: LD_VAR 0 1
58574: PPUSH
58575: CALL_OW 264
58579: PUSH
58580: LD_INT 12
58582: PUSH
58583: LD_INT 51
58585: PUSH
58586: LD_INT 32
58588: PUSH
58589: LD_INT 89
58591: PUSH
58592: EMPTY
58593: LIST
58594: LIST
58595: LIST
58596: LIST
58597: IN
58598: NOT
58599: OR
58600: IFFALSE 58604
// exit ;
58602: GO 58702
// for i := 1 to 3 do
58604: LD_ADDR_VAR 0 3
58608: PUSH
58609: DOUBLE
58610: LD_INT 1
58612: DEC
58613: ST_TO_ADDR
58614: LD_INT 3
58616: PUSH
58617: FOR_TO
58618: IFFALSE 58700
// begin tmp := GetCargo ( cargo , i ) ;
58620: LD_ADDR_VAR 0 4
58624: PUSH
58625: LD_VAR 0 1
58629: PPUSH
58630: LD_VAR 0 3
58634: PPUSH
58635: CALL_OW 289
58639: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
58640: LD_ADDR_VAR 0 2
58644: PUSH
58645: LD_VAR 0 2
58649: PPUSH
58650: LD_VAR 0 3
58654: PPUSH
58655: LD_VAR 0 4
58659: PPUSH
58660: CALL_OW 1
58664: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
58665: LD_ADDR_VAR 0 2
58669: PUSH
58670: LD_VAR 0 2
58674: PPUSH
58675: LD_INT 4
58677: PPUSH
58678: LD_VAR 0 2
58682: PUSH
58683: LD_INT 4
58685: ARRAY
58686: PUSH
58687: LD_VAR 0 4
58691: PLUS
58692: PPUSH
58693: CALL_OW 1
58697: ST_TO_ADDR
// end ;
58698: GO 58617
58700: POP
58701: POP
// end ;
58702: LD_VAR 0 2
58706: RET
// export function Length ( array ) ; begin
58707: LD_INT 0
58709: PPUSH
// result := array + 0 ;
58710: LD_ADDR_VAR 0 2
58714: PUSH
58715: LD_VAR 0 1
58719: PUSH
58720: LD_INT 0
58722: PLUS
58723: ST_TO_ADDR
// end ;
58724: LD_VAR 0 2
58728: RET
// export function PrepareArray ( array ) ; begin
58729: LD_INT 0
58731: PPUSH
// result := array diff 0 ;
58732: LD_ADDR_VAR 0 2
58736: PUSH
58737: LD_VAR 0 1
58741: PUSH
58742: LD_INT 0
58744: DIFF
58745: ST_TO_ADDR
// if not result [ 1 ] then
58746: LD_VAR 0 2
58750: PUSH
58751: LD_INT 1
58753: ARRAY
58754: NOT
58755: IFFALSE 58775
// result := Delete ( result , 1 ) ;
58757: LD_ADDR_VAR 0 2
58761: PUSH
58762: LD_VAR 0 2
58766: PPUSH
58767: LD_INT 1
58769: PPUSH
58770: CALL_OW 3
58774: ST_TO_ADDR
// end ;
58775: LD_VAR 0 2
58779: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
58780: LD_INT 0
58782: PPUSH
58783: PPUSH
58784: PPUSH
58785: PPUSH
// sibRocketRange := 25 ;
58786: LD_ADDR_VAR 0 6
58790: PUSH
58791: LD_INT 25
58793: ST_TO_ADDR
// result := false ;
58794: LD_ADDR_VAR 0 4
58798: PUSH
58799: LD_INT 0
58801: ST_TO_ADDR
// for i := 0 to 5 do
58802: LD_ADDR_VAR 0 5
58806: PUSH
58807: DOUBLE
58808: LD_INT 0
58810: DEC
58811: ST_TO_ADDR
58812: LD_INT 5
58814: PUSH
58815: FOR_TO
58816: IFFALSE 58883
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
58818: LD_VAR 0 1
58822: PPUSH
58823: LD_VAR 0 5
58827: PPUSH
58828: LD_VAR 0 6
58832: PPUSH
58833: CALL_OW 272
58837: PPUSH
58838: LD_VAR 0 2
58842: PPUSH
58843: LD_VAR 0 5
58847: PPUSH
58848: LD_VAR 0 6
58852: PPUSH
58853: CALL_OW 273
58857: PPUSH
58858: LD_VAR 0 3
58862: PPUSH
58863: CALL_OW 309
58867: IFFALSE 58881
// begin result := true ;
58869: LD_ADDR_VAR 0 4
58873: PUSH
58874: LD_INT 1
58876: ST_TO_ADDR
// exit ;
58877: POP
58878: POP
58879: GO 58885
// end ;
58881: GO 58815
58883: POP
58884: POP
// end ;
58885: LD_VAR 0 4
58889: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
58890: LD_INT 0
58892: PPUSH
58893: PPUSH
58894: PPUSH
// if btype = b_depot then
58895: LD_VAR 0 2
58899: PUSH
58900: LD_INT 0
58902: EQUAL
58903: IFFALSE 58915
// begin result := true ;
58905: LD_ADDR_VAR 0 3
58909: PUSH
58910: LD_INT 1
58912: ST_TO_ADDR
// exit ;
58913: GO 59031
// end ; pom := GetBase ( depot ) ;
58915: LD_ADDR_VAR 0 4
58919: PUSH
58920: LD_VAR 0 1
58924: PPUSH
58925: CALL_OW 274
58929: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
58930: LD_ADDR_VAR 0 5
58934: PUSH
58935: LD_VAR 0 2
58939: PPUSH
58940: LD_VAR 0 1
58944: PPUSH
58945: CALL_OW 248
58949: PPUSH
58950: CALL_OW 450
58954: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
58955: LD_ADDR_VAR 0 3
58959: PUSH
58960: LD_VAR 0 4
58964: PPUSH
58965: LD_INT 1
58967: PPUSH
58968: CALL_OW 275
58972: PUSH
58973: LD_VAR 0 5
58977: PUSH
58978: LD_INT 1
58980: ARRAY
58981: GREATEREQUAL
58982: PUSH
58983: LD_VAR 0 4
58987: PPUSH
58988: LD_INT 2
58990: PPUSH
58991: CALL_OW 275
58995: PUSH
58996: LD_VAR 0 5
59000: PUSH
59001: LD_INT 2
59003: ARRAY
59004: GREATEREQUAL
59005: AND
59006: PUSH
59007: LD_VAR 0 4
59011: PPUSH
59012: LD_INT 3
59014: PPUSH
59015: CALL_OW 275
59019: PUSH
59020: LD_VAR 0 5
59024: PUSH
59025: LD_INT 3
59027: ARRAY
59028: GREATEREQUAL
59029: AND
59030: ST_TO_ADDR
// end ;
59031: LD_VAR 0 3
59035: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
59036: LD_INT 0
59038: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
59039: LD_VAR 0 1
59043: PPUSH
59044: LD_VAR 0 2
59048: PPUSH
59049: LD_INT 0
59051: PPUSH
59052: LD_INT 0
59054: PPUSH
59055: LD_INT 1
59057: PPUSH
59058: LD_INT 0
59060: PPUSH
59061: CALL_OW 587
// end ;
59065: LD_VAR 0 3
59069: RET
// export function CenterOnNow ( unit ) ; begin
59070: LD_INT 0
59072: PPUSH
// result := IsInUnit ( unit ) ;
59073: LD_ADDR_VAR 0 2
59077: PUSH
59078: LD_VAR 0 1
59082: PPUSH
59083: CALL_OW 310
59087: ST_TO_ADDR
// if not result then
59088: LD_VAR 0 2
59092: NOT
59093: IFFALSE 59105
// result := unit ;
59095: LD_ADDR_VAR 0 2
59099: PUSH
59100: LD_VAR 0 1
59104: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
59105: LD_VAR 0 1
59109: PPUSH
59110: CALL_OW 87
// end ;
59114: LD_VAR 0 2
59118: RET
// export function ComMoveHex ( unit , hex ) ; begin
59119: LD_INT 0
59121: PPUSH
// if not hex then
59122: LD_VAR 0 2
59126: NOT
59127: IFFALSE 59131
// exit ;
59129: GO 59184
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
59131: LD_VAR 0 2
59135: PUSH
59136: LD_INT 1
59138: ARRAY
59139: PPUSH
59140: LD_VAR 0 2
59144: PUSH
59145: LD_INT 2
59147: ARRAY
59148: PPUSH
59149: CALL_OW 428
59153: IFFALSE 59157
// exit ;
59155: GO 59184
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
59157: LD_VAR 0 1
59161: PPUSH
59162: LD_VAR 0 2
59166: PUSH
59167: LD_INT 1
59169: ARRAY
59170: PPUSH
59171: LD_VAR 0 2
59175: PUSH
59176: LD_INT 2
59178: ARRAY
59179: PPUSH
59180: CALL_OW 111
// end ;
59184: LD_VAR 0 3
59188: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
59189: LD_INT 0
59191: PPUSH
59192: PPUSH
59193: PPUSH
// if not unit or not enemy then
59194: LD_VAR 0 1
59198: NOT
59199: PUSH
59200: LD_VAR 0 2
59204: NOT
59205: OR
59206: IFFALSE 59210
// exit ;
59208: GO 59334
// x := GetX ( enemy ) ;
59210: LD_ADDR_VAR 0 4
59214: PUSH
59215: LD_VAR 0 2
59219: PPUSH
59220: CALL_OW 250
59224: ST_TO_ADDR
// y := GetY ( enemy ) ;
59225: LD_ADDR_VAR 0 5
59229: PUSH
59230: LD_VAR 0 2
59234: PPUSH
59235: CALL_OW 251
59239: ST_TO_ADDR
// if ValidHex ( x , y ) then
59240: LD_VAR 0 4
59244: PPUSH
59245: LD_VAR 0 5
59249: PPUSH
59250: CALL_OW 488
59254: IFFALSE 59334
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
59256: LD_VAR 0 2
59260: PPUSH
59261: CALL_OW 247
59265: PUSH
59266: LD_INT 3
59268: PUSH
59269: LD_INT 2
59271: PUSH
59272: EMPTY
59273: LIST
59274: LIST
59275: IN
59276: PUSH
59277: LD_VAR 0 1
59281: PPUSH
59282: CALL_OW 255
59286: PPUSH
59287: LD_VAR 0 2
59291: PPUSH
59292: CALL_OW 292
59296: OR
59297: IFFALSE 59315
// ComAttackUnit ( unit , enemy ) else
59299: LD_VAR 0 1
59303: PPUSH
59304: LD_VAR 0 2
59308: PPUSH
59309: CALL_OW 115
59313: GO 59334
// ComAgressiveMove ( unit , x , y ) ;
59315: LD_VAR 0 1
59319: PPUSH
59320: LD_VAR 0 4
59324: PPUSH
59325: LD_VAR 0 5
59329: PPUSH
59330: CALL_OW 114
// end ;
59334: LD_VAR 0 3
59338: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
59339: LD_INT 0
59341: PPUSH
59342: PPUSH
59343: PPUSH
// list := AreaToList ( area , 0 ) ;
59344: LD_ADDR_VAR 0 5
59348: PUSH
59349: LD_VAR 0 1
59353: PPUSH
59354: LD_INT 0
59356: PPUSH
59357: CALL_OW 517
59361: ST_TO_ADDR
// if not list then
59362: LD_VAR 0 5
59366: NOT
59367: IFFALSE 59371
// exit ;
59369: GO 59501
// if all then
59371: LD_VAR 0 2
59375: IFFALSE 59463
// begin for i := 1 to list [ 1 ] do
59377: LD_ADDR_VAR 0 4
59381: PUSH
59382: DOUBLE
59383: LD_INT 1
59385: DEC
59386: ST_TO_ADDR
59387: LD_VAR 0 5
59391: PUSH
59392: LD_INT 1
59394: ARRAY
59395: PUSH
59396: FOR_TO
59397: IFFALSE 59459
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
59399: LD_ADDR_VAR 0 3
59403: PUSH
59404: LD_VAR 0 3
59408: PPUSH
59409: LD_VAR 0 3
59413: PUSH
59414: LD_INT 1
59416: PLUS
59417: PPUSH
59418: LD_VAR 0 5
59422: PUSH
59423: LD_INT 1
59425: ARRAY
59426: PUSH
59427: LD_VAR 0 4
59431: ARRAY
59432: PUSH
59433: LD_VAR 0 5
59437: PUSH
59438: LD_INT 2
59440: ARRAY
59441: PUSH
59442: LD_VAR 0 4
59446: ARRAY
59447: PUSH
59448: EMPTY
59449: LIST
59450: LIST
59451: PPUSH
59452: CALL_OW 1
59456: ST_TO_ADDR
59457: GO 59396
59459: POP
59460: POP
// exit ;
59461: GO 59501
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
59463: LD_ADDR_VAR 0 3
59467: PUSH
59468: LD_VAR 0 5
59472: PUSH
59473: LD_INT 1
59475: ARRAY
59476: PUSH
59477: LD_INT 1
59479: ARRAY
59480: PUSH
59481: LD_VAR 0 5
59485: PUSH
59486: LD_INT 2
59488: ARRAY
59489: PUSH
59490: LD_INT 1
59492: ARRAY
59493: PUSH
59494: EMPTY
59495: LIST
59496: LIST
59497: PUSH
59498: EMPTY
59499: LIST
59500: ST_TO_ADDR
// end ;
59501: LD_VAR 0 3
59505: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
59506: LD_INT 0
59508: PPUSH
59509: PPUSH
// list := AreaToList ( area , 0 ) ;
59510: LD_ADDR_VAR 0 4
59514: PUSH
59515: LD_VAR 0 1
59519: PPUSH
59520: LD_INT 0
59522: PPUSH
59523: CALL_OW 517
59527: ST_TO_ADDR
// if not list then
59528: LD_VAR 0 4
59532: NOT
59533: IFFALSE 59537
// exit ;
59535: GO 59578
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
59537: LD_ADDR_VAR 0 3
59541: PUSH
59542: LD_VAR 0 4
59546: PUSH
59547: LD_INT 1
59549: ARRAY
59550: PUSH
59551: LD_INT 1
59553: ARRAY
59554: PUSH
59555: LD_VAR 0 4
59559: PUSH
59560: LD_INT 2
59562: ARRAY
59563: PUSH
59564: LD_INT 1
59566: ARRAY
59567: PUSH
59568: LD_VAR 0 2
59572: PUSH
59573: EMPTY
59574: LIST
59575: LIST
59576: LIST
59577: ST_TO_ADDR
// end ;
59578: LD_VAR 0 3
59582: RET
// export function First ( array ) ; begin
59583: LD_INT 0
59585: PPUSH
// if not array then
59586: LD_VAR 0 1
59590: NOT
59591: IFFALSE 59595
// exit ;
59593: GO 59609
// result := array [ 1 ] ;
59595: LD_ADDR_VAR 0 2
59599: PUSH
59600: LD_VAR 0 1
59604: PUSH
59605: LD_INT 1
59607: ARRAY
59608: ST_TO_ADDR
// end ;
59609: LD_VAR 0 2
59613: RET
// export function Last ( array ) ; begin
59614: LD_INT 0
59616: PPUSH
// if not array then
59617: LD_VAR 0 1
59621: NOT
59622: IFFALSE 59626
// exit ;
59624: GO 59642
// result := array [ array ] ;
59626: LD_ADDR_VAR 0 2
59630: PUSH
59631: LD_VAR 0 1
59635: PUSH
59636: LD_VAR 0 1
59640: ARRAY
59641: ST_TO_ADDR
// end ;
59642: LD_VAR 0 2
59646: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
59647: LD_INT 0
59649: PPUSH
59650: PPUSH
// result := [ ] ;
59651: LD_ADDR_VAR 0 5
59655: PUSH
59656: EMPTY
59657: ST_TO_ADDR
// if not array then
59658: LD_VAR 0 1
59662: NOT
59663: IFFALSE 59667
// exit ;
59665: GO 59779
// for i := 1 to array do
59667: LD_ADDR_VAR 0 6
59671: PUSH
59672: DOUBLE
59673: LD_INT 1
59675: DEC
59676: ST_TO_ADDR
59677: LD_VAR 0 1
59681: PUSH
59682: FOR_TO
59683: IFFALSE 59777
// if array [ i ] [ index ] = value then
59685: LD_VAR 0 1
59689: PUSH
59690: LD_VAR 0 6
59694: ARRAY
59695: PUSH
59696: LD_VAR 0 2
59700: ARRAY
59701: PUSH
59702: LD_VAR 0 3
59706: EQUAL
59707: IFFALSE 59775
// begin if indexColumn then
59709: LD_VAR 0 4
59713: IFFALSE 59749
// result := Join ( result , array [ i ] [ indexColumn ] ) else
59715: LD_ADDR_VAR 0 5
59719: PUSH
59720: LD_VAR 0 5
59724: PPUSH
59725: LD_VAR 0 1
59729: PUSH
59730: LD_VAR 0 6
59734: ARRAY
59735: PUSH
59736: LD_VAR 0 4
59740: ARRAY
59741: PPUSH
59742: CALL 54967 0 2
59746: ST_TO_ADDR
59747: GO 59775
// result := Join ( result , array [ i ] ) ;
59749: LD_ADDR_VAR 0 5
59753: PUSH
59754: LD_VAR 0 5
59758: PPUSH
59759: LD_VAR 0 1
59763: PUSH
59764: LD_VAR 0 6
59768: ARRAY
59769: PPUSH
59770: CALL 54967 0 2
59774: ST_TO_ADDR
// end ;
59775: GO 59682
59777: POP
59778: POP
// end ;
59779: LD_VAR 0 5
59783: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
59784: LD_INT 0
59786: PPUSH
// if not vehicles or not parkingPoint then
59787: LD_VAR 0 1
59791: NOT
59792: PUSH
59793: LD_VAR 0 2
59797: NOT
59798: OR
59799: IFFALSE 59803
// exit ;
59801: GO 59901
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
59803: LD_ADDR_VAR 0 1
59807: PUSH
59808: LD_VAR 0 1
59812: PPUSH
59813: LD_INT 50
59815: PUSH
59816: EMPTY
59817: LIST
59818: PUSH
59819: LD_INT 3
59821: PUSH
59822: LD_INT 92
59824: PUSH
59825: LD_VAR 0 2
59829: PUSH
59830: LD_INT 1
59832: ARRAY
59833: PUSH
59834: LD_VAR 0 2
59838: PUSH
59839: LD_INT 2
59841: ARRAY
59842: PUSH
59843: LD_INT 8
59845: PUSH
59846: EMPTY
59847: LIST
59848: LIST
59849: LIST
59850: LIST
59851: PUSH
59852: EMPTY
59853: LIST
59854: LIST
59855: PUSH
59856: EMPTY
59857: LIST
59858: LIST
59859: PPUSH
59860: CALL_OW 72
59864: ST_TO_ADDR
// if not vehicles then
59865: LD_VAR 0 1
59869: NOT
59870: IFFALSE 59874
// exit ;
59872: GO 59901
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
59874: LD_VAR 0 1
59878: PPUSH
59879: LD_VAR 0 2
59883: PUSH
59884: LD_INT 1
59886: ARRAY
59887: PPUSH
59888: LD_VAR 0 2
59892: PUSH
59893: LD_INT 2
59895: ARRAY
59896: PPUSH
59897: CALL_OW 111
// end ;
59901: LD_VAR 0 3
59905: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
59906: LD_INT 0
59908: PPUSH
59909: PPUSH
59910: PPUSH
// if not side or not area then
59911: LD_VAR 0 1
59915: NOT
59916: PUSH
59917: LD_VAR 0 2
59921: NOT
59922: OR
59923: IFFALSE 59927
// exit ;
59925: GO 60046
// tmp := AreaToList ( area , 0 ) ;
59927: LD_ADDR_VAR 0 5
59931: PUSH
59932: LD_VAR 0 2
59936: PPUSH
59937: LD_INT 0
59939: PPUSH
59940: CALL_OW 517
59944: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
59945: LD_ADDR_VAR 0 4
59949: PUSH
59950: DOUBLE
59951: LD_INT 1
59953: DEC
59954: ST_TO_ADDR
59955: LD_VAR 0 5
59959: PUSH
59960: LD_INT 1
59962: ARRAY
59963: PUSH
59964: FOR_TO
59965: IFFALSE 60044
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
59967: LD_VAR 0 5
59971: PUSH
59972: LD_INT 1
59974: ARRAY
59975: PUSH
59976: LD_VAR 0 4
59980: ARRAY
59981: PPUSH
59982: LD_VAR 0 5
59986: PUSH
59987: LD_INT 2
59989: ARRAY
59990: PUSH
59991: LD_VAR 0 4
59995: ARRAY
59996: PPUSH
59997: CALL_OW 351
60001: IFFALSE 60042
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
60003: LD_VAR 0 5
60007: PUSH
60008: LD_INT 1
60010: ARRAY
60011: PUSH
60012: LD_VAR 0 4
60016: ARRAY
60017: PPUSH
60018: LD_VAR 0 5
60022: PUSH
60023: LD_INT 2
60025: ARRAY
60026: PUSH
60027: LD_VAR 0 4
60031: ARRAY
60032: PPUSH
60033: LD_VAR 0 1
60037: PPUSH
60038: CALL_OW 244
// end ;
60042: GO 59964
60044: POP
60045: POP
// end ; end_of_file
60046: LD_VAR 0 3
60050: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
60051: LD_INT 0
60053: PPUSH
60054: PPUSH
// skirmish := false ;
60055: LD_ADDR_EXP 61
60059: PUSH
60060: LD_INT 0
60062: ST_TO_ADDR
// debug_mc := false ;
60063: LD_ADDR_EXP 62
60067: PUSH
60068: LD_INT 0
60070: ST_TO_ADDR
// mc_bases := [ ] ;
60071: LD_ADDR_EXP 63
60075: PUSH
60076: EMPTY
60077: ST_TO_ADDR
// mc_sides := [ ] ;
60078: LD_ADDR_EXP 89
60082: PUSH
60083: EMPTY
60084: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
60085: LD_ADDR_EXP 64
60089: PUSH
60090: EMPTY
60091: ST_TO_ADDR
// mc_building_repairs := [ ] ;
60092: LD_ADDR_EXP 65
60096: PUSH
60097: EMPTY
60098: ST_TO_ADDR
// mc_need_heal := [ ] ;
60099: LD_ADDR_EXP 66
60103: PUSH
60104: EMPTY
60105: ST_TO_ADDR
// mc_healers := [ ] ;
60106: LD_ADDR_EXP 67
60110: PUSH
60111: EMPTY
60112: ST_TO_ADDR
// mc_build_list := [ ] ;
60113: LD_ADDR_EXP 68
60117: PUSH
60118: EMPTY
60119: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
60120: LD_ADDR_EXP 95
60124: PUSH
60125: EMPTY
60126: ST_TO_ADDR
// mc_builders := [ ] ;
60127: LD_ADDR_EXP 69
60131: PUSH
60132: EMPTY
60133: ST_TO_ADDR
// mc_construct_list := [ ] ;
60134: LD_ADDR_EXP 70
60138: PUSH
60139: EMPTY
60140: ST_TO_ADDR
// mc_turret_list := [ ] ;
60141: LD_ADDR_EXP 71
60145: PUSH
60146: EMPTY
60147: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
60148: LD_ADDR_EXP 72
60152: PUSH
60153: EMPTY
60154: ST_TO_ADDR
// mc_miners := [ ] ;
60155: LD_ADDR_EXP 77
60159: PUSH
60160: EMPTY
60161: ST_TO_ADDR
// mc_mines := [ ] ;
60162: LD_ADDR_EXP 76
60166: PUSH
60167: EMPTY
60168: ST_TO_ADDR
// mc_minefields := [ ] ;
60169: LD_ADDR_EXP 78
60173: PUSH
60174: EMPTY
60175: ST_TO_ADDR
// mc_crates := [ ] ;
60176: LD_ADDR_EXP 79
60180: PUSH
60181: EMPTY
60182: ST_TO_ADDR
// mc_crates_collector := [ ] ;
60183: LD_ADDR_EXP 80
60187: PUSH
60188: EMPTY
60189: ST_TO_ADDR
// mc_crates_area := [ ] ;
60190: LD_ADDR_EXP 81
60194: PUSH
60195: EMPTY
60196: ST_TO_ADDR
// mc_vehicles := [ ] ;
60197: LD_ADDR_EXP 82
60201: PUSH
60202: EMPTY
60203: ST_TO_ADDR
// mc_attack := [ ] ;
60204: LD_ADDR_EXP 83
60208: PUSH
60209: EMPTY
60210: ST_TO_ADDR
// mc_produce := [ ] ;
60211: LD_ADDR_EXP 84
60215: PUSH
60216: EMPTY
60217: ST_TO_ADDR
// mc_defender := [ ] ;
60218: LD_ADDR_EXP 85
60222: PUSH
60223: EMPTY
60224: ST_TO_ADDR
// mc_parking := [ ] ;
60225: LD_ADDR_EXP 87
60229: PUSH
60230: EMPTY
60231: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
60232: LD_ADDR_EXP 73
60236: PUSH
60237: EMPTY
60238: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
60239: LD_ADDR_EXP 75
60243: PUSH
60244: EMPTY
60245: ST_TO_ADDR
// mc_scan := [ ] ;
60246: LD_ADDR_EXP 86
60250: PUSH
60251: EMPTY
60252: ST_TO_ADDR
// mc_scan_area := [ ] ;
60253: LD_ADDR_EXP 88
60257: PUSH
60258: EMPTY
60259: ST_TO_ADDR
// mc_tech := [ ] ;
60260: LD_ADDR_EXP 90
60264: PUSH
60265: EMPTY
60266: ST_TO_ADDR
// mc_class := [ ] ;
60267: LD_ADDR_EXP 104
60271: PUSH
60272: EMPTY
60273: ST_TO_ADDR
// mc_class_case_use := [ ] ;
60274: LD_ADDR_EXP 105
60278: PUSH
60279: EMPTY
60280: ST_TO_ADDR
// mc_is_defending := [ ] ;
60281: LD_ADDR_EXP 106
60285: PUSH
60286: EMPTY
60287: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
60288: LD_ADDR_EXP 97
60292: PUSH
60293: EMPTY
60294: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
60295: LD_ADDR_EXP 107
60299: PUSH
60300: LD_INT 0
60302: ST_TO_ADDR
// end ;
60303: LD_VAR 0 1
60307: RET
// export function MC_Kill ( base ) ; begin
60308: LD_INT 0
60310: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
60311: LD_ADDR_EXP 63
60315: PUSH
60316: LD_EXP 63
60320: PPUSH
60321: LD_VAR 0 1
60325: PPUSH
60326: EMPTY
60327: PPUSH
60328: CALL_OW 1
60332: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
60333: LD_ADDR_EXP 64
60337: PUSH
60338: LD_EXP 64
60342: PPUSH
60343: LD_VAR 0 1
60347: PPUSH
60348: EMPTY
60349: PPUSH
60350: CALL_OW 1
60354: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
60355: LD_ADDR_EXP 65
60359: PUSH
60360: LD_EXP 65
60364: PPUSH
60365: LD_VAR 0 1
60369: PPUSH
60370: EMPTY
60371: PPUSH
60372: CALL_OW 1
60376: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
60377: LD_ADDR_EXP 66
60381: PUSH
60382: LD_EXP 66
60386: PPUSH
60387: LD_VAR 0 1
60391: PPUSH
60392: EMPTY
60393: PPUSH
60394: CALL_OW 1
60398: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
60399: LD_ADDR_EXP 67
60403: PUSH
60404: LD_EXP 67
60408: PPUSH
60409: LD_VAR 0 1
60413: PPUSH
60414: EMPTY
60415: PPUSH
60416: CALL_OW 1
60420: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
60421: LD_ADDR_EXP 68
60425: PUSH
60426: LD_EXP 68
60430: PPUSH
60431: LD_VAR 0 1
60435: PPUSH
60436: EMPTY
60437: PPUSH
60438: CALL_OW 1
60442: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
60443: LD_ADDR_EXP 69
60447: PUSH
60448: LD_EXP 69
60452: PPUSH
60453: LD_VAR 0 1
60457: PPUSH
60458: EMPTY
60459: PPUSH
60460: CALL_OW 1
60464: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
60465: LD_ADDR_EXP 70
60469: PUSH
60470: LD_EXP 70
60474: PPUSH
60475: LD_VAR 0 1
60479: PPUSH
60480: EMPTY
60481: PPUSH
60482: CALL_OW 1
60486: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
60487: LD_ADDR_EXP 71
60491: PUSH
60492: LD_EXP 71
60496: PPUSH
60497: LD_VAR 0 1
60501: PPUSH
60502: EMPTY
60503: PPUSH
60504: CALL_OW 1
60508: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
60509: LD_ADDR_EXP 72
60513: PUSH
60514: LD_EXP 72
60518: PPUSH
60519: LD_VAR 0 1
60523: PPUSH
60524: EMPTY
60525: PPUSH
60526: CALL_OW 1
60530: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
60531: LD_ADDR_EXP 73
60535: PUSH
60536: LD_EXP 73
60540: PPUSH
60541: LD_VAR 0 1
60545: PPUSH
60546: EMPTY
60547: PPUSH
60548: CALL_OW 1
60552: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
60553: LD_ADDR_EXP 74
60557: PUSH
60558: LD_EXP 74
60562: PPUSH
60563: LD_VAR 0 1
60567: PPUSH
60568: LD_INT 0
60570: PPUSH
60571: CALL_OW 1
60575: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
60576: LD_ADDR_EXP 75
60580: PUSH
60581: LD_EXP 75
60585: PPUSH
60586: LD_VAR 0 1
60590: PPUSH
60591: EMPTY
60592: PPUSH
60593: CALL_OW 1
60597: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
60598: LD_ADDR_EXP 76
60602: PUSH
60603: LD_EXP 76
60607: PPUSH
60608: LD_VAR 0 1
60612: PPUSH
60613: EMPTY
60614: PPUSH
60615: CALL_OW 1
60619: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
60620: LD_ADDR_EXP 77
60624: PUSH
60625: LD_EXP 77
60629: PPUSH
60630: LD_VAR 0 1
60634: PPUSH
60635: EMPTY
60636: PPUSH
60637: CALL_OW 1
60641: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
60642: LD_ADDR_EXP 78
60646: PUSH
60647: LD_EXP 78
60651: PPUSH
60652: LD_VAR 0 1
60656: PPUSH
60657: EMPTY
60658: PPUSH
60659: CALL_OW 1
60663: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
60664: LD_ADDR_EXP 79
60668: PUSH
60669: LD_EXP 79
60673: PPUSH
60674: LD_VAR 0 1
60678: PPUSH
60679: EMPTY
60680: PPUSH
60681: CALL_OW 1
60685: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
60686: LD_ADDR_EXP 80
60690: PUSH
60691: LD_EXP 80
60695: PPUSH
60696: LD_VAR 0 1
60700: PPUSH
60701: EMPTY
60702: PPUSH
60703: CALL_OW 1
60707: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
60708: LD_ADDR_EXP 81
60712: PUSH
60713: LD_EXP 81
60717: PPUSH
60718: LD_VAR 0 1
60722: PPUSH
60723: EMPTY
60724: PPUSH
60725: CALL_OW 1
60729: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
60730: LD_ADDR_EXP 82
60734: PUSH
60735: LD_EXP 82
60739: PPUSH
60740: LD_VAR 0 1
60744: PPUSH
60745: EMPTY
60746: PPUSH
60747: CALL_OW 1
60751: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
60752: LD_ADDR_EXP 83
60756: PUSH
60757: LD_EXP 83
60761: PPUSH
60762: LD_VAR 0 1
60766: PPUSH
60767: EMPTY
60768: PPUSH
60769: CALL_OW 1
60773: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
60774: LD_ADDR_EXP 84
60778: PUSH
60779: LD_EXP 84
60783: PPUSH
60784: LD_VAR 0 1
60788: PPUSH
60789: EMPTY
60790: PPUSH
60791: CALL_OW 1
60795: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
60796: LD_ADDR_EXP 85
60800: PUSH
60801: LD_EXP 85
60805: PPUSH
60806: LD_VAR 0 1
60810: PPUSH
60811: EMPTY
60812: PPUSH
60813: CALL_OW 1
60817: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
60818: LD_ADDR_EXP 86
60822: PUSH
60823: LD_EXP 86
60827: PPUSH
60828: LD_VAR 0 1
60832: PPUSH
60833: EMPTY
60834: PPUSH
60835: CALL_OW 1
60839: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
60840: LD_ADDR_EXP 87
60844: PUSH
60845: LD_EXP 87
60849: PPUSH
60850: LD_VAR 0 1
60854: PPUSH
60855: EMPTY
60856: PPUSH
60857: CALL_OW 1
60861: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
60862: LD_ADDR_EXP 88
60866: PUSH
60867: LD_EXP 88
60871: PPUSH
60872: LD_VAR 0 1
60876: PPUSH
60877: EMPTY
60878: PPUSH
60879: CALL_OW 1
60883: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
60884: LD_ADDR_EXP 90
60888: PUSH
60889: LD_EXP 90
60893: PPUSH
60894: LD_VAR 0 1
60898: PPUSH
60899: EMPTY
60900: PPUSH
60901: CALL_OW 1
60905: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
60906: LD_ADDR_EXP 92
60910: PUSH
60911: LD_EXP 92
60915: PPUSH
60916: LD_VAR 0 1
60920: PPUSH
60921: EMPTY
60922: PPUSH
60923: CALL_OW 1
60927: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
60928: LD_ADDR_EXP 93
60932: PUSH
60933: LD_EXP 93
60937: PPUSH
60938: LD_VAR 0 1
60942: PPUSH
60943: EMPTY
60944: PPUSH
60945: CALL_OW 1
60949: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
60950: LD_ADDR_EXP 94
60954: PUSH
60955: LD_EXP 94
60959: PPUSH
60960: LD_VAR 0 1
60964: PPUSH
60965: EMPTY
60966: PPUSH
60967: CALL_OW 1
60971: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
60972: LD_ADDR_EXP 95
60976: PUSH
60977: LD_EXP 95
60981: PPUSH
60982: LD_VAR 0 1
60986: PPUSH
60987: EMPTY
60988: PPUSH
60989: CALL_OW 1
60993: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
60994: LD_ADDR_EXP 96
60998: PUSH
60999: LD_EXP 96
61003: PPUSH
61004: LD_VAR 0 1
61008: PPUSH
61009: EMPTY
61010: PPUSH
61011: CALL_OW 1
61015: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
61016: LD_ADDR_EXP 97
61020: PUSH
61021: LD_EXP 97
61025: PPUSH
61026: LD_VAR 0 1
61030: PPUSH
61031: EMPTY
61032: PPUSH
61033: CALL_OW 1
61037: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
61038: LD_ADDR_EXP 98
61042: PUSH
61043: LD_EXP 98
61047: PPUSH
61048: LD_VAR 0 1
61052: PPUSH
61053: EMPTY
61054: PPUSH
61055: CALL_OW 1
61059: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
61060: LD_ADDR_EXP 99
61064: PUSH
61065: LD_EXP 99
61069: PPUSH
61070: LD_VAR 0 1
61074: PPUSH
61075: EMPTY
61076: PPUSH
61077: CALL_OW 1
61081: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
61082: LD_ADDR_EXP 100
61086: PUSH
61087: LD_EXP 100
61091: PPUSH
61092: LD_VAR 0 1
61096: PPUSH
61097: EMPTY
61098: PPUSH
61099: CALL_OW 1
61103: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
61104: LD_ADDR_EXP 101
61108: PUSH
61109: LD_EXP 101
61113: PPUSH
61114: LD_VAR 0 1
61118: PPUSH
61119: EMPTY
61120: PPUSH
61121: CALL_OW 1
61125: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
61126: LD_ADDR_EXP 102
61130: PUSH
61131: LD_EXP 102
61135: PPUSH
61136: LD_VAR 0 1
61140: PPUSH
61141: EMPTY
61142: PPUSH
61143: CALL_OW 1
61147: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
61148: LD_ADDR_EXP 103
61152: PUSH
61153: LD_EXP 103
61157: PPUSH
61158: LD_VAR 0 1
61162: PPUSH
61163: EMPTY
61164: PPUSH
61165: CALL_OW 1
61169: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
61170: LD_ADDR_EXP 104
61174: PUSH
61175: LD_EXP 104
61179: PPUSH
61180: LD_VAR 0 1
61184: PPUSH
61185: EMPTY
61186: PPUSH
61187: CALL_OW 1
61191: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
61192: LD_ADDR_EXP 105
61196: PUSH
61197: LD_EXP 105
61201: PPUSH
61202: LD_VAR 0 1
61206: PPUSH
61207: LD_INT 0
61209: PPUSH
61210: CALL_OW 1
61214: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
61215: LD_ADDR_EXP 106
61219: PUSH
61220: LD_EXP 106
61224: PPUSH
61225: LD_VAR 0 1
61229: PPUSH
61230: LD_INT 0
61232: PPUSH
61233: CALL_OW 1
61237: ST_TO_ADDR
// end ;
61238: LD_VAR 0 2
61242: RET
// export function MC_Add ( side , units ) ; var base ; begin
61243: LD_INT 0
61245: PPUSH
61246: PPUSH
// base := mc_bases + 1 ;
61247: LD_ADDR_VAR 0 4
61251: PUSH
61252: LD_EXP 63
61256: PUSH
61257: LD_INT 1
61259: PLUS
61260: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
61261: LD_ADDR_EXP 89
61265: PUSH
61266: LD_EXP 89
61270: PPUSH
61271: LD_VAR 0 4
61275: PPUSH
61276: LD_VAR 0 1
61280: PPUSH
61281: CALL_OW 1
61285: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
61286: LD_ADDR_EXP 63
61290: PUSH
61291: LD_EXP 63
61295: PPUSH
61296: LD_VAR 0 4
61300: PPUSH
61301: LD_VAR 0 2
61305: PPUSH
61306: CALL_OW 1
61310: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
61311: LD_ADDR_EXP 64
61315: PUSH
61316: LD_EXP 64
61320: PPUSH
61321: LD_VAR 0 4
61325: PPUSH
61326: EMPTY
61327: PPUSH
61328: CALL_OW 1
61332: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
61333: LD_ADDR_EXP 65
61337: PUSH
61338: LD_EXP 65
61342: PPUSH
61343: LD_VAR 0 4
61347: PPUSH
61348: EMPTY
61349: PPUSH
61350: CALL_OW 1
61354: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
61355: LD_ADDR_EXP 66
61359: PUSH
61360: LD_EXP 66
61364: PPUSH
61365: LD_VAR 0 4
61369: PPUSH
61370: EMPTY
61371: PPUSH
61372: CALL_OW 1
61376: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
61377: LD_ADDR_EXP 67
61381: PUSH
61382: LD_EXP 67
61386: PPUSH
61387: LD_VAR 0 4
61391: PPUSH
61392: EMPTY
61393: PPUSH
61394: CALL_OW 1
61398: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
61399: LD_ADDR_EXP 68
61403: PUSH
61404: LD_EXP 68
61408: PPUSH
61409: LD_VAR 0 4
61413: PPUSH
61414: EMPTY
61415: PPUSH
61416: CALL_OW 1
61420: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
61421: LD_ADDR_EXP 69
61425: PUSH
61426: LD_EXP 69
61430: PPUSH
61431: LD_VAR 0 4
61435: PPUSH
61436: EMPTY
61437: PPUSH
61438: CALL_OW 1
61442: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
61443: LD_ADDR_EXP 70
61447: PUSH
61448: LD_EXP 70
61452: PPUSH
61453: LD_VAR 0 4
61457: PPUSH
61458: EMPTY
61459: PPUSH
61460: CALL_OW 1
61464: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
61465: LD_ADDR_EXP 71
61469: PUSH
61470: LD_EXP 71
61474: PPUSH
61475: LD_VAR 0 4
61479: PPUSH
61480: EMPTY
61481: PPUSH
61482: CALL_OW 1
61486: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
61487: LD_ADDR_EXP 72
61491: PUSH
61492: LD_EXP 72
61496: PPUSH
61497: LD_VAR 0 4
61501: PPUSH
61502: EMPTY
61503: PPUSH
61504: CALL_OW 1
61508: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
61509: LD_ADDR_EXP 73
61513: PUSH
61514: LD_EXP 73
61518: PPUSH
61519: LD_VAR 0 4
61523: PPUSH
61524: EMPTY
61525: PPUSH
61526: CALL_OW 1
61530: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
61531: LD_ADDR_EXP 74
61535: PUSH
61536: LD_EXP 74
61540: PPUSH
61541: LD_VAR 0 4
61545: PPUSH
61546: LD_INT 0
61548: PPUSH
61549: CALL_OW 1
61553: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
61554: LD_ADDR_EXP 75
61558: PUSH
61559: LD_EXP 75
61563: PPUSH
61564: LD_VAR 0 4
61568: PPUSH
61569: EMPTY
61570: PPUSH
61571: CALL_OW 1
61575: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
61576: LD_ADDR_EXP 76
61580: PUSH
61581: LD_EXP 76
61585: PPUSH
61586: LD_VAR 0 4
61590: PPUSH
61591: EMPTY
61592: PPUSH
61593: CALL_OW 1
61597: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
61598: LD_ADDR_EXP 77
61602: PUSH
61603: LD_EXP 77
61607: PPUSH
61608: LD_VAR 0 4
61612: PPUSH
61613: EMPTY
61614: PPUSH
61615: CALL_OW 1
61619: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
61620: LD_ADDR_EXP 78
61624: PUSH
61625: LD_EXP 78
61629: PPUSH
61630: LD_VAR 0 4
61634: PPUSH
61635: EMPTY
61636: PPUSH
61637: CALL_OW 1
61641: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
61642: LD_ADDR_EXP 79
61646: PUSH
61647: LD_EXP 79
61651: PPUSH
61652: LD_VAR 0 4
61656: PPUSH
61657: EMPTY
61658: PPUSH
61659: CALL_OW 1
61663: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
61664: LD_ADDR_EXP 80
61668: PUSH
61669: LD_EXP 80
61673: PPUSH
61674: LD_VAR 0 4
61678: PPUSH
61679: EMPTY
61680: PPUSH
61681: CALL_OW 1
61685: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
61686: LD_ADDR_EXP 81
61690: PUSH
61691: LD_EXP 81
61695: PPUSH
61696: LD_VAR 0 4
61700: PPUSH
61701: EMPTY
61702: PPUSH
61703: CALL_OW 1
61707: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
61708: LD_ADDR_EXP 82
61712: PUSH
61713: LD_EXP 82
61717: PPUSH
61718: LD_VAR 0 4
61722: PPUSH
61723: EMPTY
61724: PPUSH
61725: CALL_OW 1
61729: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
61730: LD_ADDR_EXP 83
61734: PUSH
61735: LD_EXP 83
61739: PPUSH
61740: LD_VAR 0 4
61744: PPUSH
61745: EMPTY
61746: PPUSH
61747: CALL_OW 1
61751: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
61752: LD_ADDR_EXP 84
61756: PUSH
61757: LD_EXP 84
61761: PPUSH
61762: LD_VAR 0 4
61766: PPUSH
61767: EMPTY
61768: PPUSH
61769: CALL_OW 1
61773: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
61774: LD_ADDR_EXP 85
61778: PUSH
61779: LD_EXP 85
61783: PPUSH
61784: LD_VAR 0 4
61788: PPUSH
61789: EMPTY
61790: PPUSH
61791: CALL_OW 1
61795: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
61796: LD_ADDR_EXP 86
61800: PUSH
61801: LD_EXP 86
61805: PPUSH
61806: LD_VAR 0 4
61810: PPUSH
61811: EMPTY
61812: PPUSH
61813: CALL_OW 1
61817: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
61818: LD_ADDR_EXP 87
61822: PUSH
61823: LD_EXP 87
61827: PPUSH
61828: LD_VAR 0 4
61832: PPUSH
61833: EMPTY
61834: PPUSH
61835: CALL_OW 1
61839: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
61840: LD_ADDR_EXP 88
61844: PUSH
61845: LD_EXP 88
61849: PPUSH
61850: LD_VAR 0 4
61854: PPUSH
61855: EMPTY
61856: PPUSH
61857: CALL_OW 1
61861: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
61862: LD_ADDR_EXP 90
61866: PUSH
61867: LD_EXP 90
61871: PPUSH
61872: LD_VAR 0 4
61876: PPUSH
61877: EMPTY
61878: PPUSH
61879: CALL_OW 1
61883: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
61884: LD_ADDR_EXP 92
61888: PUSH
61889: LD_EXP 92
61893: PPUSH
61894: LD_VAR 0 4
61898: PPUSH
61899: EMPTY
61900: PPUSH
61901: CALL_OW 1
61905: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
61906: LD_ADDR_EXP 93
61910: PUSH
61911: LD_EXP 93
61915: PPUSH
61916: LD_VAR 0 4
61920: PPUSH
61921: EMPTY
61922: PPUSH
61923: CALL_OW 1
61927: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
61928: LD_ADDR_EXP 94
61932: PUSH
61933: LD_EXP 94
61937: PPUSH
61938: LD_VAR 0 4
61942: PPUSH
61943: EMPTY
61944: PPUSH
61945: CALL_OW 1
61949: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
61950: LD_ADDR_EXP 95
61954: PUSH
61955: LD_EXP 95
61959: PPUSH
61960: LD_VAR 0 4
61964: PPUSH
61965: EMPTY
61966: PPUSH
61967: CALL_OW 1
61971: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
61972: LD_ADDR_EXP 96
61976: PUSH
61977: LD_EXP 96
61981: PPUSH
61982: LD_VAR 0 4
61986: PPUSH
61987: EMPTY
61988: PPUSH
61989: CALL_OW 1
61993: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
61994: LD_ADDR_EXP 97
61998: PUSH
61999: LD_EXP 97
62003: PPUSH
62004: LD_VAR 0 4
62008: PPUSH
62009: EMPTY
62010: PPUSH
62011: CALL_OW 1
62015: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
62016: LD_ADDR_EXP 98
62020: PUSH
62021: LD_EXP 98
62025: PPUSH
62026: LD_VAR 0 4
62030: PPUSH
62031: EMPTY
62032: PPUSH
62033: CALL_OW 1
62037: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
62038: LD_ADDR_EXP 99
62042: PUSH
62043: LD_EXP 99
62047: PPUSH
62048: LD_VAR 0 4
62052: PPUSH
62053: EMPTY
62054: PPUSH
62055: CALL_OW 1
62059: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
62060: LD_ADDR_EXP 100
62064: PUSH
62065: LD_EXP 100
62069: PPUSH
62070: LD_VAR 0 4
62074: PPUSH
62075: EMPTY
62076: PPUSH
62077: CALL_OW 1
62081: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
62082: LD_ADDR_EXP 101
62086: PUSH
62087: LD_EXP 101
62091: PPUSH
62092: LD_VAR 0 4
62096: PPUSH
62097: EMPTY
62098: PPUSH
62099: CALL_OW 1
62103: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
62104: LD_ADDR_EXP 102
62108: PUSH
62109: LD_EXP 102
62113: PPUSH
62114: LD_VAR 0 4
62118: PPUSH
62119: EMPTY
62120: PPUSH
62121: CALL_OW 1
62125: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
62126: LD_ADDR_EXP 103
62130: PUSH
62131: LD_EXP 103
62135: PPUSH
62136: LD_VAR 0 4
62140: PPUSH
62141: EMPTY
62142: PPUSH
62143: CALL_OW 1
62147: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
62148: LD_ADDR_EXP 104
62152: PUSH
62153: LD_EXP 104
62157: PPUSH
62158: LD_VAR 0 4
62162: PPUSH
62163: EMPTY
62164: PPUSH
62165: CALL_OW 1
62169: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
62170: LD_ADDR_EXP 105
62174: PUSH
62175: LD_EXP 105
62179: PPUSH
62180: LD_VAR 0 4
62184: PPUSH
62185: LD_INT 0
62187: PPUSH
62188: CALL_OW 1
62192: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
62193: LD_ADDR_EXP 106
62197: PUSH
62198: LD_EXP 106
62202: PPUSH
62203: LD_VAR 0 4
62207: PPUSH
62208: LD_INT 0
62210: PPUSH
62211: CALL_OW 1
62215: ST_TO_ADDR
// result := base ;
62216: LD_ADDR_VAR 0 3
62220: PUSH
62221: LD_VAR 0 4
62225: ST_TO_ADDR
// end ;
62226: LD_VAR 0 3
62230: RET
// export function MC_Start ( ) ; var i ; begin
62231: LD_INT 0
62233: PPUSH
62234: PPUSH
// for i = 1 to mc_bases do
62235: LD_ADDR_VAR 0 2
62239: PUSH
62240: DOUBLE
62241: LD_INT 1
62243: DEC
62244: ST_TO_ADDR
62245: LD_EXP 63
62249: PUSH
62250: FOR_TO
62251: IFFALSE 63351
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
62253: LD_ADDR_EXP 63
62257: PUSH
62258: LD_EXP 63
62262: PPUSH
62263: LD_VAR 0 2
62267: PPUSH
62268: LD_EXP 63
62272: PUSH
62273: LD_VAR 0 2
62277: ARRAY
62278: PUSH
62279: LD_INT 0
62281: DIFF
62282: PPUSH
62283: CALL_OW 1
62287: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
62288: LD_ADDR_EXP 64
62292: PUSH
62293: LD_EXP 64
62297: PPUSH
62298: LD_VAR 0 2
62302: PPUSH
62303: EMPTY
62304: PPUSH
62305: CALL_OW 1
62309: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
62310: LD_ADDR_EXP 65
62314: PUSH
62315: LD_EXP 65
62319: PPUSH
62320: LD_VAR 0 2
62324: PPUSH
62325: EMPTY
62326: PPUSH
62327: CALL_OW 1
62331: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
62332: LD_ADDR_EXP 66
62336: PUSH
62337: LD_EXP 66
62341: PPUSH
62342: LD_VAR 0 2
62346: PPUSH
62347: EMPTY
62348: PPUSH
62349: CALL_OW 1
62353: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
62354: LD_ADDR_EXP 67
62358: PUSH
62359: LD_EXP 67
62363: PPUSH
62364: LD_VAR 0 2
62368: PPUSH
62369: EMPTY
62370: PUSH
62371: EMPTY
62372: PUSH
62373: EMPTY
62374: LIST
62375: LIST
62376: PPUSH
62377: CALL_OW 1
62381: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
62382: LD_ADDR_EXP 68
62386: PUSH
62387: LD_EXP 68
62391: PPUSH
62392: LD_VAR 0 2
62396: PPUSH
62397: EMPTY
62398: PPUSH
62399: CALL_OW 1
62403: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
62404: LD_ADDR_EXP 95
62408: PUSH
62409: LD_EXP 95
62413: PPUSH
62414: LD_VAR 0 2
62418: PPUSH
62419: EMPTY
62420: PPUSH
62421: CALL_OW 1
62425: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
62426: LD_ADDR_EXP 69
62430: PUSH
62431: LD_EXP 69
62435: PPUSH
62436: LD_VAR 0 2
62440: PPUSH
62441: EMPTY
62442: PPUSH
62443: CALL_OW 1
62447: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
62448: LD_ADDR_EXP 70
62452: PUSH
62453: LD_EXP 70
62457: PPUSH
62458: LD_VAR 0 2
62462: PPUSH
62463: EMPTY
62464: PPUSH
62465: CALL_OW 1
62469: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
62470: LD_ADDR_EXP 71
62474: PUSH
62475: LD_EXP 71
62479: PPUSH
62480: LD_VAR 0 2
62484: PPUSH
62485: LD_EXP 63
62489: PUSH
62490: LD_VAR 0 2
62494: ARRAY
62495: PPUSH
62496: LD_INT 2
62498: PUSH
62499: LD_INT 30
62501: PUSH
62502: LD_INT 32
62504: PUSH
62505: EMPTY
62506: LIST
62507: LIST
62508: PUSH
62509: LD_INT 30
62511: PUSH
62512: LD_INT 33
62514: PUSH
62515: EMPTY
62516: LIST
62517: LIST
62518: PUSH
62519: EMPTY
62520: LIST
62521: LIST
62522: LIST
62523: PPUSH
62524: CALL_OW 72
62528: PPUSH
62529: CALL_OW 1
62533: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
62534: LD_ADDR_EXP 72
62538: PUSH
62539: LD_EXP 72
62543: PPUSH
62544: LD_VAR 0 2
62548: PPUSH
62549: LD_EXP 63
62553: PUSH
62554: LD_VAR 0 2
62558: ARRAY
62559: PPUSH
62560: LD_INT 2
62562: PUSH
62563: LD_INT 30
62565: PUSH
62566: LD_INT 32
62568: PUSH
62569: EMPTY
62570: LIST
62571: LIST
62572: PUSH
62573: LD_INT 30
62575: PUSH
62576: LD_INT 31
62578: PUSH
62579: EMPTY
62580: LIST
62581: LIST
62582: PUSH
62583: EMPTY
62584: LIST
62585: LIST
62586: LIST
62587: PUSH
62588: LD_INT 58
62590: PUSH
62591: EMPTY
62592: LIST
62593: PUSH
62594: EMPTY
62595: LIST
62596: LIST
62597: PPUSH
62598: CALL_OW 72
62602: PPUSH
62603: CALL_OW 1
62607: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
62608: LD_ADDR_EXP 73
62612: PUSH
62613: LD_EXP 73
62617: PPUSH
62618: LD_VAR 0 2
62622: PPUSH
62623: EMPTY
62624: PPUSH
62625: CALL_OW 1
62629: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
62630: LD_ADDR_EXP 77
62634: PUSH
62635: LD_EXP 77
62639: PPUSH
62640: LD_VAR 0 2
62644: PPUSH
62645: EMPTY
62646: PPUSH
62647: CALL_OW 1
62651: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
62652: LD_ADDR_EXP 76
62656: PUSH
62657: LD_EXP 76
62661: PPUSH
62662: LD_VAR 0 2
62666: PPUSH
62667: EMPTY
62668: PPUSH
62669: CALL_OW 1
62673: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
62674: LD_ADDR_EXP 78
62678: PUSH
62679: LD_EXP 78
62683: PPUSH
62684: LD_VAR 0 2
62688: PPUSH
62689: EMPTY
62690: PPUSH
62691: CALL_OW 1
62695: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
62696: LD_ADDR_EXP 79
62700: PUSH
62701: LD_EXP 79
62705: PPUSH
62706: LD_VAR 0 2
62710: PPUSH
62711: EMPTY
62712: PPUSH
62713: CALL_OW 1
62717: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
62718: LD_ADDR_EXP 80
62722: PUSH
62723: LD_EXP 80
62727: PPUSH
62728: LD_VAR 0 2
62732: PPUSH
62733: EMPTY
62734: PPUSH
62735: CALL_OW 1
62739: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
62740: LD_ADDR_EXP 81
62744: PUSH
62745: LD_EXP 81
62749: PPUSH
62750: LD_VAR 0 2
62754: PPUSH
62755: EMPTY
62756: PPUSH
62757: CALL_OW 1
62761: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
62762: LD_ADDR_EXP 82
62766: PUSH
62767: LD_EXP 82
62771: PPUSH
62772: LD_VAR 0 2
62776: PPUSH
62777: EMPTY
62778: PPUSH
62779: CALL_OW 1
62783: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
62784: LD_ADDR_EXP 83
62788: PUSH
62789: LD_EXP 83
62793: PPUSH
62794: LD_VAR 0 2
62798: PPUSH
62799: EMPTY
62800: PPUSH
62801: CALL_OW 1
62805: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
62806: LD_ADDR_EXP 84
62810: PUSH
62811: LD_EXP 84
62815: PPUSH
62816: LD_VAR 0 2
62820: PPUSH
62821: EMPTY
62822: PPUSH
62823: CALL_OW 1
62827: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
62828: LD_ADDR_EXP 85
62832: PUSH
62833: LD_EXP 85
62837: PPUSH
62838: LD_VAR 0 2
62842: PPUSH
62843: EMPTY
62844: PPUSH
62845: CALL_OW 1
62849: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
62850: LD_ADDR_EXP 74
62854: PUSH
62855: LD_EXP 74
62859: PPUSH
62860: LD_VAR 0 2
62864: PPUSH
62865: LD_INT 0
62867: PPUSH
62868: CALL_OW 1
62872: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
62873: LD_ADDR_EXP 87
62877: PUSH
62878: LD_EXP 87
62882: PPUSH
62883: LD_VAR 0 2
62887: PPUSH
62888: LD_INT 0
62890: PPUSH
62891: CALL_OW 1
62895: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
62896: LD_ADDR_EXP 75
62900: PUSH
62901: LD_EXP 75
62905: PPUSH
62906: LD_VAR 0 2
62910: PPUSH
62911: EMPTY
62912: PPUSH
62913: CALL_OW 1
62917: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
62918: LD_ADDR_EXP 86
62922: PUSH
62923: LD_EXP 86
62927: PPUSH
62928: LD_VAR 0 2
62932: PPUSH
62933: LD_INT 0
62935: PPUSH
62936: CALL_OW 1
62940: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
62941: LD_ADDR_EXP 88
62945: PUSH
62946: LD_EXP 88
62950: PPUSH
62951: LD_VAR 0 2
62955: PPUSH
62956: EMPTY
62957: PPUSH
62958: CALL_OW 1
62962: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
62963: LD_ADDR_EXP 91
62967: PUSH
62968: LD_EXP 91
62972: PPUSH
62973: LD_VAR 0 2
62977: PPUSH
62978: LD_INT 0
62980: PPUSH
62981: CALL_OW 1
62985: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
62986: LD_ADDR_EXP 92
62990: PUSH
62991: LD_EXP 92
62995: PPUSH
62996: LD_VAR 0 2
63000: PPUSH
63001: EMPTY
63002: PPUSH
63003: CALL_OW 1
63007: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
63008: LD_ADDR_EXP 93
63012: PUSH
63013: LD_EXP 93
63017: PPUSH
63018: LD_VAR 0 2
63022: PPUSH
63023: EMPTY
63024: PPUSH
63025: CALL_OW 1
63029: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
63030: LD_ADDR_EXP 94
63034: PUSH
63035: LD_EXP 94
63039: PPUSH
63040: LD_VAR 0 2
63044: PPUSH
63045: EMPTY
63046: PPUSH
63047: CALL_OW 1
63051: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
63052: LD_ADDR_EXP 96
63056: PUSH
63057: LD_EXP 96
63061: PPUSH
63062: LD_VAR 0 2
63066: PPUSH
63067: LD_EXP 63
63071: PUSH
63072: LD_VAR 0 2
63076: ARRAY
63077: PPUSH
63078: LD_INT 2
63080: PUSH
63081: LD_INT 30
63083: PUSH
63084: LD_INT 6
63086: PUSH
63087: EMPTY
63088: LIST
63089: LIST
63090: PUSH
63091: LD_INT 30
63093: PUSH
63094: LD_INT 7
63096: PUSH
63097: EMPTY
63098: LIST
63099: LIST
63100: PUSH
63101: LD_INT 30
63103: PUSH
63104: LD_INT 8
63106: PUSH
63107: EMPTY
63108: LIST
63109: LIST
63110: PUSH
63111: EMPTY
63112: LIST
63113: LIST
63114: LIST
63115: LIST
63116: PPUSH
63117: CALL_OW 72
63121: PPUSH
63122: CALL_OW 1
63126: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
63127: LD_ADDR_EXP 97
63131: PUSH
63132: LD_EXP 97
63136: PPUSH
63137: LD_VAR 0 2
63141: PPUSH
63142: EMPTY
63143: PPUSH
63144: CALL_OW 1
63148: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
63149: LD_ADDR_EXP 98
63153: PUSH
63154: LD_EXP 98
63158: PPUSH
63159: LD_VAR 0 2
63163: PPUSH
63164: EMPTY
63165: PPUSH
63166: CALL_OW 1
63170: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
63171: LD_ADDR_EXP 99
63175: PUSH
63176: LD_EXP 99
63180: PPUSH
63181: LD_VAR 0 2
63185: PPUSH
63186: EMPTY
63187: PPUSH
63188: CALL_OW 1
63192: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
63193: LD_ADDR_EXP 100
63197: PUSH
63198: LD_EXP 100
63202: PPUSH
63203: LD_VAR 0 2
63207: PPUSH
63208: EMPTY
63209: PPUSH
63210: CALL_OW 1
63214: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
63215: LD_ADDR_EXP 101
63219: PUSH
63220: LD_EXP 101
63224: PPUSH
63225: LD_VAR 0 2
63229: PPUSH
63230: EMPTY
63231: PPUSH
63232: CALL_OW 1
63236: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
63237: LD_ADDR_EXP 102
63241: PUSH
63242: LD_EXP 102
63246: PPUSH
63247: LD_VAR 0 2
63251: PPUSH
63252: EMPTY
63253: PPUSH
63254: CALL_OW 1
63258: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
63259: LD_ADDR_EXP 103
63263: PUSH
63264: LD_EXP 103
63268: PPUSH
63269: LD_VAR 0 2
63273: PPUSH
63274: EMPTY
63275: PPUSH
63276: CALL_OW 1
63280: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
63281: LD_ADDR_EXP 104
63285: PUSH
63286: LD_EXP 104
63290: PPUSH
63291: LD_VAR 0 2
63295: PPUSH
63296: EMPTY
63297: PPUSH
63298: CALL_OW 1
63302: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
63303: LD_ADDR_EXP 105
63307: PUSH
63308: LD_EXP 105
63312: PPUSH
63313: LD_VAR 0 2
63317: PPUSH
63318: LD_INT 0
63320: PPUSH
63321: CALL_OW 1
63325: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
63326: LD_ADDR_EXP 106
63330: PUSH
63331: LD_EXP 106
63335: PPUSH
63336: LD_VAR 0 2
63340: PPUSH
63341: LD_INT 0
63343: PPUSH
63344: CALL_OW 1
63348: ST_TO_ADDR
// end ;
63349: GO 62250
63351: POP
63352: POP
// MC_InitSides ( ) ;
63353: CALL 63639 0 0
// MC_InitResearch ( ) ;
63357: CALL 63378 0 0
// CustomInitMacro ( ) ;
63361: CALL 219 0 0
// skirmish := true ;
63365: LD_ADDR_EXP 61
63369: PUSH
63370: LD_INT 1
63372: ST_TO_ADDR
// end ;
63373: LD_VAR 0 1
63377: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
63378: LD_INT 0
63380: PPUSH
63381: PPUSH
63382: PPUSH
63383: PPUSH
63384: PPUSH
63385: PPUSH
// if not mc_bases then
63386: LD_EXP 63
63390: NOT
63391: IFFALSE 63395
// exit ;
63393: GO 63634
// for i = 1 to 8 do
63395: LD_ADDR_VAR 0 2
63399: PUSH
63400: DOUBLE
63401: LD_INT 1
63403: DEC
63404: ST_TO_ADDR
63405: LD_INT 8
63407: PUSH
63408: FOR_TO
63409: IFFALSE 63435
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
63411: LD_ADDR_EXP 90
63415: PUSH
63416: LD_EXP 90
63420: PPUSH
63421: LD_VAR 0 2
63425: PPUSH
63426: EMPTY
63427: PPUSH
63428: CALL_OW 1
63432: ST_TO_ADDR
63433: GO 63408
63435: POP
63436: POP
// tmp := [ ] ;
63437: LD_ADDR_VAR 0 5
63441: PUSH
63442: EMPTY
63443: ST_TO_ADDR
// for i = 1 to mc_sides do
63444: LD_ADDR_VAR 0 2
63448: PUSH
63449: DOUBLE
63450: LD_INT 1
63452: DEC
63453: ST_TO_ADDR
63454: LD_EXP 89
63458: PUSH
63459: FOR_TO
63460: IFFALSE 63518
// if not mc_sides [ i ] in tmp then
63462: LD_EXP 89
63466: PUSH
63467: LD_VAR 0 2
63471: ARRAY
63472: PUSH
63473: LD_VAR 0 5
63477: IN
63478: NOT
63479: IFFALSE 63516
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
63481: LD_ADDR_VAR 0 5
63485: PUSH
63486: LD_VAR 0 5
63490: PPUSH
63491: LD_VAR 0 5
63495: PUSH
63496: LD_INT 1
63498: PLUS
63499: PPUSH
63500: LD_EXP 89
63504: PUSH
63505: LD_VAR 0 2
63509: ARRAY
63510: PPUSH
63511: CALL_OW 2
63515: ST_TO_ADDR
63516: GO 63459
63518: POP
63519: POP
// if not tmp then
63520: LD_VAR 0 5
63524: NOT
63525: IFFALSE 63529
// exit ;
63527: GO 63634
// for j in tmp do
63529: LD_ADDR_VAR 0 3
63533: PUSH
63534: LD_VAR 0 5
63538: PUSH
63539: FOR_IN
63540: IFFALSE 63632
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
63542: LD_ADDR_VAR 0 6
63546: PUSH
63547: LD_INT 22
63549: PUSH
63550: LD_VAR 0 3
63554: PUSH
63555: EMPTY
63556: LIST
63557: LIST
63558: PPUSH
63559: CALL_OW 69
63563: ST_TO_ADDR
// if not un then
63564: LD_VAR 0 6
63568: NOT
63569: IFFALSE 63573
// continue ;
63571: GO 63539
// nation := GetNation ( un [ 1 ] ) ;
63573: LD_ADDR_VAR 0 4
63577: PUSH
63578: LD_VAR 0 6
63582: PUSH
63583: LD_INT 1
63585: ARRAY
63586: PPUSH
63587: CALL_OW 248
63591: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
63592: LD_ADDR_EXP 90
63596: PUSH
63597: LD_EXP 90
63601: PPUSH
63602: LD_VAR 0 3
63606: PPUSH
63607: LD_VAR 0 3
63611: PPUSH
63612: LD_VAR 0 4
63616: PPUSH
63617: LD_INT 1
63619: PPUSH
63620: CALL 17339 0 3
63624: PPUSH
63625: CALL_OW 1
63629: ST_TO_ADDR
// end ;
63630: GO 63539
63632: POP
63633: POP
// end ;
63634: LD_VAR 0 1
63638: RET
// export function MC_InitSides ( ) ; var i ; begin
63639: LD_INT 0
63641: PPUSH
63642: PPUSH
// if not mc_bases then
63643: LD_EXP 63
63647: NOT
63648: IFFALSE 63652
// exit ;
63650: GO 63726
// for i = 1 to mc_bases do
63652: LD_ADDR_VAR 0 2
63656: PUSH
63657: DOUBLE
63658: LD_INT 1
63660: DEC
63661: ST_TO_ADDR
63662: LD_EXP 63
63666: PUSH
63667: FOR_TO
63668: IFFALSE 63724
// if mc_bases [ i ] then
63670: LD_EXP 63
63674: PUSH
63675: LD_VAR 0 2
63679: ARRAY
63680: IFFALSE 63722
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
63682: LD_ADDR_EXP 89
63686: PUSH
63687: LD_EXP 89
63691: PPUSH
63692: LD_VAR 0 2
63696: PPUSH
63697: LD_EXP 63
63701: PUSH
63702: LD_VAR 0 2
63706: ARRAY
63707: PUSH
63708: LD_INT 1
63710: ARRAY
63711: PPUSH
63712: CALL_OW 255
63716: PPUSH
63717: CALL_OW 1
63721: ST_TO_ADDR
63722: GO 63667
63724: POP
63725: POP
// end ;
63726: LD_VAR 0 1
63730: RET
// every 0 0$03 trigger skirmish do
63731: LD_EXP 61
63735: IFFALSE 63889
63737: GO 63739
63739: DISABLE
// begin enable ;
63740: ENABLE
// MC_CheckBuildings ( ) ;
63741: CALL 68401 0 0
// MC_CheckPeopleLife ( ) ;
63745: CALL 68562 0 0
// RaiseSailEvent ( 100 ) ;
63749: LD_INT 100
63751: PPUSH
63752: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
63756: LD_INT 103
63758: PPUSH
63759: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
63763: LD_INT 104
63765: PPUSH
63766: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
63770: LD_INT 105
63772: PPUSH
63773: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
63777: LD_INT 106
63779: PPUSH
63780: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
63784: LD_INT 107
63786: PPUSH
63787: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
63791: LD_INT 108
63793: PPUSH
63794: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
63798: LD_INT 109
63800: PPUSH
63801: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
63805: LD_INT 110
63807: PPUSH
63808: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
63812: LD_INT 111
63814: PPUSH
63815: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
63819: LD_INT 112
63821: PPUSH
63822: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
63826: LD_INT 113
63828: PPUSH
63829: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
63833: LD_INT 120
63835: PPUSH
63836: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
63840: LD_INT 121
63842: PPUSH
63843: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
63847: LD_INT 122
63849: PPUSH
63850: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
63854: LD_INT 123
63856: PPUSH
63857: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
63861: LD_INT 124
63863: PPUSH
63864: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
63868: LD_INT 125
63870: PPUSH
63871: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
63875: LD_INT 126
63877: PPUSH
63878: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
63882: LD_INT 200
63884: PPUSH
63885: CALL_OW 427
// end ;
63889: END
// on SailEvent ( event ) do begin if event < 100 then
63890: LD_VAR 0 1
63894: PUSH
63895: LD_INT 100
63897: LESS
63898: IFFALSE 63909
// CustomEvent ( event ) ;
63900: LD_VAR 0 1
63904: PPUSH
63905: CALL 15924 0 1
// if event = 100 then
63909: LD_VAR 0 1
63913: PUSH
63914: LD_INT 100
63916: EQUAL
63917: IFFALSE 63923
// MC_ClassManager ( ) ;
63919: CALL 64315 0 0
// if event = 101 then
63923: LD_VAR 0 1
63927: PUSH
63928: LD_INT 101
63930: EQUAL
63931: IFFALSE 63937
// MC_RepairBuildings ( ) ;
63933: CALL 69147 0 0
// if event = 102 then
63937: LD_VAR 0 1
63941: PUSH
63942: LD_INT 102
63944: EQUAL
63945: IFFALSE 63951
// MC_Heal ( ) ;
63947: CALL 70082 0 0
// if event = 103 then
63951: LD_VAR 0 1
63955: PUSH
63956: LD_INT 103
63958: EQUAL
63959: IFFALSE 63965
// MC_Build ( ) ;
63961: CALL 70504 0 0
// if event = 104 then
63965: LD_VAR 0 1
63969: PUSH
63970: LD_INT 104
63972: EQUAL
63973: IFFALSE 63979
// MC_TurretWeapon ( ) ;
63975: CALL 72138 0 0
// if event = 105 then
63979: LD_VAR 0 1
63983: PUSH
63984: LD_INT 105
63986: EQUAL
63987: IFFALSE 63993
// MC_BuildUpgrade ( ) ;
63989: CALL 71689 0 0
// if event = 106 then
63993: LD_VAR 0 1
63997: PUSH
63998: LD_INT 106
64000: EQUAL
64001: IFFALSE 64007
// MC_PlantMines ( ) ;
64003: CALL 72568 0 0
// if event = 107 then
64007: LD_VAR 0 1
64011: PUSH
64012: LD_INT 107
64014: EQUAL
64015: IFFALSE 64021
// MC_CollectCrates ( ) ;
64017: CALL 73366 0 0
// if event = 108 then
64021: LD_VAR 0 1
64025: PUSH
64026: LD_INT 108
64028: EQUAL
64029: IFFALSE 64035
// MC_LinkRemoteControl ( ) ;
64031: CALL 75216 0 0
// if event = 109 then
64035: LD_VAR 0 1
64039: PUSH
64040: LD_INT 109
64042: EQUAL
64043: IFFALSE 64049
// MC_ProduceVehicle ( ) ;
64045: CALL 75397 0 0
// if event = 110 then
64049: LD_VAR 0 1
64053: PUSH
64054: LD_INT 110
64056: EQUAL
64057: IFFALSE 64063
// MC_SendAttack ( ) ;
64059: CALL 75863 0 0
// if event = 111 then
64063: LD_VAR 0 1
64067: PUSH
64068: LD_INT 111
64070: EQUAL
64071: IFFALSE 64077
// MC_Defend ( ) ;
64073: CALL 75971 0 0
// if event = 112 then
64077: LD_VAR 0 1
64081: PUSH
64082: LD_INT 112
64084: EQUAL
64085: IFFALSE 64091
// MC_Research ( ) ;
64087: CALL 76851 0 0
// if event = 113 then
64091: LD_VAR 0 1
64095: PUSH
64096: LD_INT 113
64098: EQUAL
64099: IFFALSE 64105
// MC_MinesTrigger ( ) ;
64101: CALL 77965 0 0
// if event = 120 then
64105: LD_VAR 0 1
64109: PUSH
64110: LD_INT 120
64112: EQUAL
64113: IFFALSE 64119
// MC_RepairVehicle ( ) ;
64115: CALL 78064 0 0
// if event = 121 then
64119: LD_VAR 0 1
64123: PUSH
64124: LD_INT 121
64126: EQUAL
64127: IFFALSE 64133
// MC_TameApe ( ) ;
64129: CALL 78833 0 0
// if event = 122 then
64133: LD_VAR 0 1
64137: PUSH
64138: LD_INT 122
64140: EQUAL
64141: IFFALSE 64147
// MC_ChangeApeClass ( ) ;
64143: CALL 79662 0 0
// if event = 123 then
64147: LD_VAR 0 1
64151: PUSH
64152: LD_INT 123
64154: EQUAL
64155: IFFALSE 64161
// MC_Bazooka ( ) ;
64157: CALL 80312 0 0
// if event = 124 then
64161: LD_VAR 0 1
64165: PUSH
64166: LD_INT 124
64168: EQUAL
64169: IFFALSE 64175
// MC_TeleportExit ( ) ;
64171: CALL 80510 0 0
// if event = 125 then
64175: LD_VAR 0 1
64179: PUSH
64180: LD_INT 125
64182: EQUAL
64183: IFFALSE 64189
// MC_Deposits ( ) ;
64185: CALL 81157 0 0
// if event = 126 then
64189: LD_VAR 0 1
64193: PUSH
64194: LD_INT 126
64196: EQUAL
64197: IFFALSE 64203
// MC_RemoteDriver ( ) ;
64199: CALL 81782 0 0
// if event = 200 then
64203: LD_VAR 0 1
64207: PUSH
64208: LD_INT 200
64210: EQUAL
64211: IFFALSE 64217
// MC_Idle ( ) ;
64213: CALL 83689 0 0
// end ;
64217: PPOPN 1
64219: END
// export function MC_Reset ( base , tag ) ; var i ; begin
64220: LD_INT 0
64222: PPUSH
64223: PPUSH
// if not mc_bases [ base ] or not tag then
64224: LD_EXP 63
64228: PUSH
64229: LD_VAR 0 1
64233: ARRAY
64234: NOT
64235: PUSH
64236: LD_VAR 0 2
64240: NOT
64241: OR
64242: IFFALSE 64246
// exit ;
64244: GO 64310
// for i in mc_bases [ base ] union mc_ape [ base ] do
64246: LD_ADDR_VAR 0 4
64250: PUSH
64251: LD_EXP 63
64255: PUSH
64256: LD_VAR 0 1
64260: ARRAY
64261: PUSH
64262: LD_EXP 92
64266: PUSH
64267: LD_VAR 0 1
64271: ARRAY
64272: UNION
64273: PUSH
64274: FOR_IN
64275: IFFALSE 64308
// if GetTag ( i ) = tag then
64277: LD_VAR 0 4
64281: PPUSH
64282: CALL_OW 110
64286: PUSH
64287: LD_VAR 0 2
64291: EQUAL
64292: IFFALSE 64306
// SetTag ( i , 0 ) ;
64294: LD_VAR 0 4
64298: PPUSH
64299: LD_INT 0
64301: PPUSH
64302: CALL_OW 109
64306: GO 64274
64308: POP
64309: POP
// end ;
64310: LD_VAR 0 3
64314: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
64315: LD_INT 0
64317: PPUSH
64318: PPUSH
64319: PPUSH
64320: PPUSH
64321: PPUSH
64322: PPUSH
64323: PPUSH
64324: PPUSH
// if not mc_bases then
64325: LD_EXP 63
64329: NOT
64330: IFFALSE 64334
// exit ;
64332: GO 64783
// for i = 1 to mc_bases do
64334: LD_ADDR_VAR 0 2
64338: PUSH
64339: DOUBLE
64340: LD_INT 1
64342: DEC
64343: ST_TO_ADDR
64344: LD_EXP 63
64348: PUSH
64349: FOR_TO
64350: IFFALSE 64781
// begin tmp := MC_ClassCheckReq ( i ) ;
64352: LD_ADDR_VAR 0 4
64356: PUSH
64357: LD_VAR 0 2
64361: PPUSH
64362: CALL 64788 0 1
64366: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
64367: LD_ADDR_EXP 104
64371: PUSH
64372: LD_EXP 104
64376: PPUSH
64377: LD_VAR 0 2
64381: PPUSH
64382: LD_VAR 0 4
64386: PPUSH
64387: CALL_OW 1
64391: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
64392: LD_ADDR_VAR 0 6
64396: PUSH
64397: LD_EXP 63
64401: PUSH
64402: LD_VAR 0 2
64406: ARRAY
64407: PPUSH
64408: LD_INT 2
64410: PUSH
64411: LD_INT 30
64413: PUSH
64414: LD_INT 4
64416: PUSH
64417: EMPTY
64418: LIST
64419: LIST
64420: PUSH
64421: LD_INT 30
64423: PUSH
64424: LD_INT 5
64426: PUSH
64427: EMPTY
64428: LIST
64429: LIST
64430: PUSH
64431: EMPTY
64432: LIST
64433: LIST
64434: LIST
64435: PPUSH
64436: CALL_OW 72
64440: PUSH
64441: LD_EXP 63
64445: PUSH
64446: LD_VAR 0 2
64450: ARRAY
64451: PPUSH
64452: LD_INT 2
64454: PUSH
64455: LD_INT 30
64457: PUSH
64458: LD_INT 0
64460: PUSH
64461: EMPTY
64462: LIST
64463: LIST
64464: PUSH
64465: LD_INT 30
64467: PUSH
64468: LD_INT 1
64470: PUSH
64471: EMPTY
64472: LIST
64473: LIST
64474: PUSH
64475: EMPTY
64476: LIST
64477: LIST
64478: LIST
64479: PPUSH
64480: CALL_OW 72
64484: PUSH
64485: LD_EXP 63
64489: PUSH
64490: LD_VAR 0 2
64494: ARRAY
64495: PPUSH
64496: LD_INT 30
64498: PUSH
64499: LD_INT 3
64501: PUSH
64502: EMPTY
64503: LIST
64504: LIST
64505: PPUSH
64506: CALL_OW 72
64510: PUSH
64511: LD_EXP 63
64515: PUSH
64516: LD_VAR 0 2
64520: ARRAY
64521: PPUSH
64522: LD_INT 2
64524: PUSH
64525: LD_INT 30
64527: PUSH
64528: LD_INT 6
64530: PUSH
64531: EMPTY
64532: LIST
64533: LIST
64534: PUSH
64535: LD_INT 30
64537: PUSH
64538: LD_INT 7
64540: PUSH
64541: EMPTY
64542: LIST
64543: LIST
64544: PUSH
64545: LD_INT 30
64547: PUSH
64548: LD_INT 8
64550: PUSH
64551: EMPTY
64552: LIST
64553: LIST
64554: PUSH
64555: EMPTY
64556: LIST
64557: LIST
64558: LIST
64559: LIST
64560: PPUSH
64561: CALL_OW 72
64565: PUSH
64566: EMPTY
64567: LIST
64568: LIST
64569: LIST
64570: LIST
64571: ST_TO_ADDR
// for j := 1 to 4 do
64572: LD_ADDR_VAR 0 3
64576: PUSH
64577: DOUBLE
64578: LD_INT 1
64580: DEC
64581: ST_TO_ADDR
64582: LD_INT 4
64584: PUSH
64585: FOR_TO
64586: IFFALSE 64777
// begin if not tmp [ j ] then
64588: LD_VAR 0 4
64592: PUSH
64593: LD_VAR 0 3
64597: ARRAY
64598: NOT
64599: IFFALSE 64603
// continue ;
64601: GO 64585
// for p in tmp [ j ] do
64603: LD_ADDR_VAR 0 5
64607: PUSH
64608: LD_VAR 0 4
64612: PUSH
64613: LD_VAR 0 3
64617: ARRAY
64618: PUSH
64619: FOR_IN
64620: IFFALSE 64773
// begin if not b [ j ] then
64622: LD_VAR 0 6
64626: PUSH
64627: LD_VAR 0 3
64631: ARRAY
64632: NOT
64633: IFFALSE 64637
// break ;
64635: GO 64773
// e := 0 ;
64637: LD_ADDR_VAR 0 7
64641: PUSH
64642: LD_INT 0
64644: ST_TO_ADDR
// for k in b [ j ] do
64645: LD_ADDR_VAR 0 8
64649: PUSH
64650: LD_VAR 0 6
64654: PUSH
64655: LD_VAR 0 3
64659: ARRAY
64660: PUSH
64661: FOR_IN
64662: IFFALSE 64689
// if IsNotFull ( k ) then
64664: LD_VAR 0 8
64668: PPUSH
64669: CALL 19460 0 1
64673: IFFALSE 64687
// begin e := k ;
64675: LD_ADDR_VAR 0 7
64679: PUSH
64680: LD_VAR 0 8
64684: ST_TO_ADDR
// break ;
64685: GO 64689
// end ;
64687: GO 64661
64689: POP
64690: POP
// if e and not UnitGoingToBuilding ( p , e ) then
64691: LD_VAR 0 7
64695: PUSH
64696: LD_VAR 0 5
64700: PPUSH
64701: LD_VAR 0 7
64705: PPUSH
64706: CALL 53599 0 2
64710: NOT
64711: AND
64712: IFFALSE 64771
// begin if IsInUnit ( p ) then
64714: LD_VAR 0 5
64718: PPUSH
64719: CALL_OW 310
64723: IFFALSE 64734
// ComExitBuilding ( p ) ;
64725: LD_VAR 0 5
64729: PPUSH
64730: CALL_OW 122
// ComEnterUnit ( p , e ) ;
64734: LD_VAR 0 5
64738: PPUSH
64739: LD_VAR 0 7
64743: PPUSH
64744: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
64748: LD_VAR 0 5
64752: PPUSH
64753: LD_VAR 0 3
64757: PPUSH
64758: CALL_OW 183
// AddComExitBuilding ( p ) ;
64762: LD_VAR 0 5
64766: PPUSH
64767: CALL_OW 182
// end ; end ;
64771: GO 64619
64773: POP
64774: POP
// end ;
64775: GO 64585
64777: POP
64778: POP
// end ;
64779: GO 64349
64781: POP
64782: POP
// end ;
64783: LD_VAR 0 1
64787: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
64788: LD_INT 0
64790: PPUSH
64791: PPUSH
64792: PPUSH
64793: PPUSH
64794: PPUSH
64795: PPUSH
64796: PPUSH
64797: PPUSH
64798: PPUSH
64799: PPUSH
64800: PPUSH
64801: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
64802: LD_ADDR_VAR 0 2
64806: PUSH
64807: LD_INT 0
64809: PUSH
64810: LD_INT 0
64812: PUSH
64813: LD_INT 0
64815: PUSH
64816: LD_INT 0
64818: PUSH
64819: EMPTY
64820: LIST
64821: LIST
64822: LIST
64823: LIST
64824: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
64825: LD_VAR 0 1
64829: NOT
64830: PUSH
64831: LD_EXP 63
64835: PUSH
64836: LD_VAR 0 1
64840: ARRAY
64841: NOT
64842: OR
64843: PUSH
64844: LD_EXP 63
64848: PUSH
64849: LD_VAR 0 1
64853: ARRAY
64854: PPUSH
64855: LD_INT 2
64857: PUSH
64858: LD_INT 30
64860: PUSH
64861: LD_INT 0
64863: PUSH
64864: EMPTY
64865: LIST
64866: LIST
64867: PUSH
64868: LD_INT 30
64870: PUSH
64871: LD_INT 1
64873: PUSH
64874: EMPTY
64875: LIST
64876: LIST
64877: PUSH
64878: EMPTY
64879: LIST
64880: LIST
64881: LIST
64882: PPUSH
64883: CALL_OW 72
64887: NOT
64888: OR
64889: IFFALSE 64893
// exit ;
64891: GO 68396
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
64893: LD_ADDR_VAR 0 4
64897: PUSH
64898: LD_EXP 63
64902: PUSH
64903: LD_VAR 0 1
64907: ARRAY
64908: PPUSH
64909: LD_INT 2
64911: PUSH
64912: LD_INT 25
64914: PUSH
64915: LD_INT 1
64917: PUSH
64918: EMPTY
64919: LIST
64920: LIST
64921: PUSH
64922: LD_INT 25
64924: PUSH
64925: LD_INT 2
64927: PUSH
64928: EMPTY
64929: LIST
64930: LIST
64931: PUSH
64932: LD_INT 25
64934: PUSH
64935: LD_INT 3
64937: PUSH
64938: EMPTY
64939: LIST
64940: LIST
64941: PUSH
64942: LD_INT 25
64944: PUSH
64945: LD_INT 4
64947: PUSH
64948: EMPTY
64949: LIST
64950: LIST
64951: PUSH
64952: LD_INT 25
64954: PUSH
64955: LD_INT 5
64957: PUSH
64958: EMPTY
64959: LIST
64960: LIST
64961: PUSH
64962: LD_INT 25
64964: PUSH
64965: LD_INT 8
64967: PUSH
64968: EMPTY
64969: LIST
64970: LIST
64971: PUSH
64972: LD_INT 25
64974: PUSH
64975: LD_INT 9
64977: PUSH
64978: EMPTY
64979: LIST
64980: LIST
64981: PUSH
64982: EMPTY
64983: LIST
64984: LIST
64985: LIST
64986: LIST
64987: LIST
64988: LIST
64989: LIST
64990: LIST
64991: PPUSH
64992: CALL_OW 72
64996: ST_TO_ADDR
// if not tmp then
64997: LD_VAR 0 4
65001: NOT
65002: IFFALSE 65006
// exit ;
65004: GO 68396
// for i in tmp do
65006: LD_ADDR_VAR 0 3
65010: PUSH
65011: LD_VAR 0 4
65015: PUSH
65016: FOR_IN
65017: IFFALSE 65048
// if GetTag ( i ) then
65019: LD_VAR 0 3
65023: PPUSH
65024: CALL_OW 110
65028: IFFALSE 65046
// tmp := tmp diff i ;
65030: LD_ADDR_VAR 0 4
65034: PUSH
65035: LD_VAR 0 4
65039: PUSH
65040: LD_VAR 0 3
65044: DIFF
65045: ST_TO_ADDR
65046: GO 65016
65048: POP
65049: POP
// if not tmp then
65050: LD_VAR 0 4
65054: NOT
65055: IFFALSE 65059
// exit ;
65057: GO 68396
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65059: LD_ADDR_VAR 0 5
65063: PUSH
65064: LD_EXP 63
65068: PUSH
65069: LD_VAR 0 1
65073: ARRAY
65074: PPUSH
65075: LD_INT 2
65077: PUSH
65078: LD_INT 25
65080: PUSH
65081: LD_INT 1
65083: PUSH
65084: EMPTY
65085: LIST
65086: LIST
65087: PUSH
65088: LD_INT 25
65090: PUSH
65091: LD_INT 5
65093: PUSH
65094: EMPTY
65095: LIST
65096: LIST
65097: PUSH
65098: LD_INT 25
65100: PUSH
65101: LD_INT 8
65103: PUSH
65104: EMPTY
65105: LIST
65106: LIST
65107: PUSH
65108: LD_INT 25
65110: PUSH
65111: LD_INT 9
65113: PUSH
65114: EMPTY
65115: LIST
65116: LIST
65117: PUSH
65118: EMPTY
65119: LIST
65120: LIST
65121: LIST
65122: LIST
65123: LIST
65124: PPUSH
65125: CALL_OW 72
65129: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
65130: LD_ADDR_VAR 0 6
65134: PUSH
65135: LD_EXP 63
65139: PUSH
65140: LD_VAR 0 1
65144: ARRAY
65145: PPUSH
65146: LD_INT 25
65148: PUSH
65149: LD_INT 2
65151: PUSH
65152: EMPTY
65153: LIST
65154: LIST
65155: PPUSH
65156: CALL_OW 72
65160: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
65161: LD_ADDR_VAR 0 7
65165: PUSH
65166: LD_EXP 63
65170: PUSH
65171: LD_VAR 0 1
65175: ARRAY
65176: PPUSH
65177: LD_INT 25
65179: PUSH
65180: LD_INT 3
65182: PUSH
65183: EMPTY
65184: LIST
65185: LIST
65186: PPUSH
65187: CALL_OW 72
65191: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
65192: LD_ADDR_VAR 0 8
65196: PUSH
65197: LD_EXP 63
65201: PUSH
65202: LD_VAR 0 1
65206: ARRAY
65207: PPUSH
65208: LD_INT 25
65210: PUSH
65211: LD_INT 4
65213: PUSH
65214: EMPTY
65215: LIST
65216: LIST
65217: PUSH
65218: LD_INT 24
65220: PUSH
65221: LD_INT 251
65223: PUSH
65224: EMPTY
65225: LIST
65226: LIST
65227: PUSH
65228: EMPTY
65229: LIST
65230: LIST
65231: PPUSH
65232: CALL_OW 72
65236: ST_TO_ADDR
// if mc_is_defending [ base ] then
65237: LD_EXP 106
65241: PUSH
65242: LD_VAR 0 1
65246: ARRAY
65247: IFFALSE 65708
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
65249: LD_ADDR_EXP 105
65253: PUSH
65254: LD_EXP 105
65258: PPUSH
65259: LD_VAR 0 1
65263: PPUSH
65264: LD_INT 4
65266: PPUSH
65267: CALL_OW 1
65271: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
65272: LD_ADDR_VAR 0 12
65276: PUSH
65277: LD_EXP 63
65281: PUSH
65282: LD_VAR 0 1
65286: ARRAY
65287: PPUSH
65288: LD_INT 2
65290: PUSH
65291: LD_INT 30
65293: PUSH
65294: LD_INT 4
65296: PUSH
65297: EMPTY
65298: LIST
65299: LIST
65300: PUSH
65301: LD_INT 30
65303: PUSH
65304: LD_INT 5
65306: PUSH
65307: EMPTY
65308: LIST
65309: LIST
65310: PUSH
65311: EMPTY
65312: LIST
65313: LIST
65314: LIST
65315: PPUSH
65316: CALL_OW 72
65320: ST_TO_ADDR
// if not b then
65321: LD_VAR 0 12
65325: NOT
65326: IFFALSE 65330
// exit ;
65328: GO 68396
// p := [ ] ;
65330: LD_ADDR_VAR 0 11
65334: PUSH
65335: EMPTY
65336: ST_TO_ADDR
// if sci >= 2 then
65337: LD_VAR 0 8
65341: PUSH
65342: LD_INT 2
65344: GREATEREQUAL
65345: IFFALSE 65376
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
65347: LD_ADDR_VAR 0 8
65351: PUSH
65352: LD_VAR 0 8
65356: PUSH
65357: LD_INT 1
65359: ARRAY
65360: PUSH
65361: LD_VAR 0 8
65365: PUSH
65366: LD_INT 2
65368: ARRAY
65369: PUSH
65370: EMPTY
65371: LIST
65372: LIST
65373: ST_TO_ADDR
65374: GO 65437
// if sci = 1 then
65376: LD_VAR 0 8
65380: PUSH
65381: LD_INT 1
65383: EQUAL
65384: IFFALSE 65405
// sci := [ sci [ 1 ] ] else
65386: LD_ADDR_VAR 0 8
65390: PUSH
65391: LD_VAR 0 8
65395: PUSH
65396: LD_INT 1
65398: ARRAY
65399: PUSH
65400: EMPTY
65401: LIST
65402: ST_TO_ADDR
65403: GO 65437
// if sci = 0 then
65405: LD_VAR 0 8
65409: PUSH
65410: LD_INT 0
65412: EQUAL
65413: IFFALSE 65437
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
65415: LD_ADDR_VAR 0 11
65419: PUSH
65420: LD_VAR 0 4
65424: PPUSH
65425: LD_INT 4
65427: PPUSH
65428: CALL 53471 0 2
65432: PUSH
65433: LD_INT 1
65435: ARRAY
65436: ST_TO_ADDR
// if eng > 4 then
65437: LD_VAR 0 6
65441: PUSH
65442: LD_INT 4
65444: GREATER
65445: IFFALSE 65491
// for i = eng downto 4 do
65447: LD_ADDR_VAR 0 3
65451: PUSH
65452: DOUBLE
65453: LD_VAR 0 6
65457: INC
65458: ST_TO_ADDR
65459: LD_INT 4
65461: PUSH
65462: FOR_DOWNTO
65463: IFFALSE 65489
// eng := eng diff eng [ i ] ;
65465: LD_ADDR_VAR 0 6
65469: PUSH
65470: LD_VAR 0 6
65474: PUSH
65475: LD_VAR 0 6
65479: PUSH
65480: LD_VAR 0 3
65484: ARRAY
65485: DIFF
65486: ST_TO_ADDR
65487: GO 65462
65489: POP
65490: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
65491: LD_ADDR_VAR 0 4
65495: PUSH
65496: LD_VAR 0 4
65500: PUSH
65501: LD_VAR 0 5
65505: PUSH
65506: LD_VAR 0 6
65510: UNION
65511: PUSH
65512: LD_VAR 0 7
65516: UNION
65517: PUSH
65518: LD_VAR 0 8
65522: UNION
65523: DIFF
65524: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
65525: LD_ADDR_VAR 0 13
65529: PUSH
65530: LD_EXP 63
65534: PUSH
65535: LD_VAR 0 1
65539: ARRAY
65540: PPUSH
65541: LD_INT 2
65543: PUSH
65544: LD_INT 30
65546: PUSH
65547: LD_INT 32
65549: PUSH
65550: EMPTY
65551: LIST
65552: LIST
65553: PUSH
65554: LD_INT 30
65556: PUSH
65557: LD_INT 31
65559: PUSH
65560: EMPTY
65561: LIST
65562: LIST
65563: PUSH
65564: EMPTY
65565: LIST
65566: LIST
65567: LIST
65568: PPUSH
65569: CALL_OW 72
65573: PUSH
65574: LD_EXP 63
65578: PUSH
65579: LD_VAR 0 1
65583: ARRAY
65584: PPUSH
65585: LD_INT 2
65587: PUSH
65588: LD_INT 30
65590: PUSH
65591: LD_INT 4
65593: PUSH
65594: EMPTY
65595: LIST
65596: LIST
65597: PUSH
65598: LD_INT 30
65600: PUSH
65601: LD_INT 5
65603: PUSH
65604: EMPTY
65605: LIST
65606: LIST
65607: PUSH
65608: EMPTY
65609: LIST
65610: LIST
65611: LIST
65612: PPUSH
65613: CALL_OW 72
65617: PUSH
65618: LD_INT 6
65620: MUL
65621: PLUS
65622: ST_TO_ADDR
// if bcount < tmp then
65623: LD_VAR 0 13
65627: PUSH
65628: LD_VAR 0 4
65632: LESS
65633: IFFALSE 65679
// for i = tmp downto bcount do
65635: LD_ADDR_VAR 0 3
65639: PUSH
65640: DOUBLE
65641: LD_VAR 0 4
65645: INC
65646: ST_TO_ADDR
65647: LD_VAR 0 13
65651: PUSH
65652: FOR_DOWNTO
65653: IFFALSE 65677
// tmp := Delete ( tmp , tmp ) ;
65655: LD_ADDR_VAR 0 4
65659: PUSH
65660: LD_VAR 0 4
65664: PPUSH
65665: LD_VAR 0 4
65669: PPUSH
65670: CALL_OW 3
65674: ST_TO_ADDR
65675: GO 65652
65677: POP
65678: POP
// result := [ tmp , 0 , 0 , p ] ;
65679: LD_ADDR_VAR 0 2
65683: PUSH
65684: LD_VAR 0 4
65688: PUSH
65689: LD_INT 0
65691: PUSH
65692: LD_INT 0
65694: PUSH
65695: LD_VAR 0 11
65699: PUSH
65700: EMPTY
65701: LIST
65702: LIST
65703: LIST
65704: LIST
65705: ST_TO_ADDR
// exit ;
65706: GO 68396
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
65708: LD_EXP 63
65712: PUSH
65713: LD_VAR 0 1
65717: ARRAY
65718: PPUSH
65719: LD_INT 2
65721: PUSH
65722: LD_INT 30
65724: PUSH
65725: LD_INT 6
65727: PUSH
65728: EMPTY
65729: LIST
65730: LIST
65731: PUSH
65732: LD_INT 30
65734: PUSH
65735: LD_INT 7
65737: PUSH
65738: EMPTY
65739: LIST
65740: LIST
65741: PUSH
65742: LD_INT 30
65744: PUSH
65745: LD_INT 8
65747: PUSH
65748: EMPTY
65749: LIST
65750: LIST
65751: PUSH
65752: EMPTY
65753: LIST
65754: LIST
65755: LIST
65756: LIST
65757: PPUSH
65758: CALL_OW 72
65762: NOT
65763: PUSH
65764: LD_EXP 63
65768: PUSH
65769: LD_VAR 0 1
65773: ARRAY
65774: PPUSH
65775: LD_INT 30
65777: PUSH
65778: LD_INT 3
65780: PUSH
65781: EMPTY
65782: LIST
65783: LIST
65784: PPUSH
65785: CALL_OW 72
65789: NOT
65790: AND
65791: IFFALSE 65863
// begin if eng = tmp then
65793: LD_VAR 0 6
65797: PUSH
65798: LD_VAR 0 4
65802: EQUAL
65803: IFFALSE 65807
// exit ;
65805: GO 68396
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
65807: LD_ADDR_EXP 105
65811: PUSH
65812: LD_EXP 105
65816: PPUSH
65817: LD_VAR 0 1
65821: PPUSH
65822: LD_INT 1
65824: PPUSH
65825: CALL_OW 1
65829: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
65830: LD_ADDR_VAR 0 2
65834: PUSH
65835: LD_INT 0
65837: PUSH
65838: LD_VAR 0 4
65842: PUSH
65843: LD_VAR 0 6
65847: DIFF
65848: PUSH
65849: LD_INT 0
65851: PUSH
65852: LD_INT 0
65854: PUSH
65855: EMPTY
65856: LIST
65857: LIST
65858: LIST
65859: LIST
65860: ST_TO_ADDR
// exit ;
65861: GO 68396
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
65863: LD_EXP 90
65867: PUSH
65868: LD_EXP 89
65872: PUSH
65873: LD_VAR 0 1
65877: ARRAY
65878: ARRAY
65879: PUSH
65880: LD_EXP 63
65884: PUSH
65885: LD_VAR 0 1
65889: ARRAY
65890: PPUSH
65891: LD_INT 2
65893: PUSH
65894: LD_INT 30
65896: PUSH
65897: LD_INT 6
65899: PUSH
65900: EMPTY
65901: LIST
65902: LIST
65903: PUSH
65904: LD_INT 30
65906: PUSH
65907: LD_INT 7
65909: PUSH
65910: EMPTY
65911: LIST
65912: LIST
65913: PUSH
65914: LD_INT 30
65916: PUSH
65917: LD_INT 8
65919: PUSH
65920: EMPTY
65921: LIST
65922: LIST
65923: PUSH
65924: EMPTY
65925: LIST
65926: LIST
65927: LIST
65928: LIST
65929: PPUSH
65930: CALL_OW 72
65934: AND
65935: PUSH
65936: LD_EXP 63
65940: PUSH
65941: LD_VAR 0 1
65945: ARRAY
65946: PPUSH
65947: LD_INT 30
65949: PUSH
65950: LD_INT 3
65952: PUSH
65953: EMPTY
65954: LIST
65955: LIST
65956: PPUSH
65957: CALL_OW 72
65961: NOT
65962: AND
65963: IFFALSE 66177
// begin if sci >= 6 then
65965: LD_VAR 0 8
65969: PUSH
65970: LD_INT 6
65972: GREATEREQUAL
65973: IFFALSE 65977
// exit ;
65975: GO 68396
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
65977: LD_ADDR_EXP 105
65981: PUSH
65982: LD_EXP 105
65986: PPUSH
65987: LD_VAR 0 1
65991: PPUSH
65992: LD_INT 2
65994: PPUSH
65995: CALL_OW 1
65999: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
66000: LD_ADDR_VAR 0 9
66004: PUSH
66005: LD_VAR 0 4
66009: PUSH
66010: LD_VAR 0 8
66014: DIFF
66015: PPUSH
66016: LD_INT 4
66018: PPUSH
66019: CALL 53471 0 2
66023: ST_TO_ADDR
// p := [ ] ;
66024: LD_ADDR_VAR 0 11
66028: PUSH
66029: EMPTY
66030: ST_TO_ADDR
// if sci < 6 and sort > 6 then
66031: LD_VAR 0 8
66035: PUSH
66036: LD_INT 6
66038: LESS
66039: PUSH
66040: LD_VAR 0 9
66044: PUSH
66045: LD_INT 6
66047: GREATER
66048: AND
66049: IFFALSE 66130
// begin for i = 1 to 6 - sci do
66051: LD_ADDR_VAR 0 3
66055: PUSH
66056: DOUBLE
66057: LD_INT 1
66059: DEC
66060: ST_TO_ADDR
66061: LD_INT 6
66063: PUSH
66064: LD_VAR 0 8
66068: MINUS
66069: PUSH
66070: FOR_TO
66071: IFFALSE 66126
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
66073: LD_ADDR_VAR 0 11
66077: PUSH
66078: LD_VAR 0 11
66082: PPUSH
66083: LD_VAR 0 11
66087: PUSH
66088: LD_INT 1
66090: PLUS
66091: PPUSH
66092: LD_VAR 0 9
66096: PUSH
66097: LD_INT 1
66099: ARRAY
66100: PPUSH
66101: CALL_OW 2
66105: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
66106: LD_ADDR_VAR 0 9
66110: PUSH
66111: LD_VAR 0 9
66115: PPUSH
66116: LD_INT 1
66118: PPUSH
66119: CALL_OW 3
66123: ST_TO_ADDR
// end ;
66124: GO 66070
66126: POP
66127: POP
// end else
66128: GO 66150
// if sort then
66130: LD_VAR 0 9
66134: IFFALSE 66150
// p := sort [ 1 ] ;
66136: LD_ADDR_VAR 0 11
66140: PUSH
66141: LD_VAR 0 9
66145: PUSH
66146: LD_INT 1
66148: ARRAY
66149: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
66150: LD_ADDR_VAR 0 2
66154: PUSH
66155: LD_INT 0
66157: PUSH
66158: LD_INT 0
66160: PUSH
66161: LD_INT 0
66163: PUSH
66164: LD_VAR 0 11
66168: PUSH
66169: EMPTY
66170: LIST
66171: LIST
66172: LIST
66173: LIST
66174: ST_TO_ADDR
// exit ;
66175: GO 68396
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
66177: LD_EXP 90
66181: PUSH
66182: LD_EXP 89
66186: PUSH
66187: LD_VAR 0 1
66191: ARRAY
66192: ARRAY
66193: PUSH
66194: LD_EXP 63
66198: PUSH
66199: LD_VAR 0 1
66203: ARRAY
66204: PPUSH
66205: LD_INT 2
66207: PUSH
66208: LD_INT 30
66210: PUSH
66211: LD_INT 6
66213: PUSH
66214: EMPTY
66215: LIST
66216: LIST
66217: PUSH
66218: LD_INT 30
66220: PUSH
66221: LD_INT 7
66223: PUSH
66224: EMPTY
66225: LIST
66226: LIST
66227: PUSH
66228: LD_INT 30
66230: PUSH
66231: LD_INT 8
66233: PUSH
66234: EMPTY
66235: LIST
66236: LIST
66237: PUSH
66238: EMPTY
66239: LIST
66240: LIST
66241: LIST
66242: LIST
66243: PPUSH
66244: CALL_OW 72
66248: AND
66249: PUSH
66250: LD_EXP 63
66254: PUSH
66255: LD_VAR 0 1
66259: ARRAY
66260: PPUSH
66261: LD_INT 30
66263: PUSH
66264: LD_INT 3
66266: PUSH
66267: EMPTY
66268: LIST
66269: LIST
66270: PPUSH
66271: CALL_OW 72
66275: AND
66276: IFFALSE 67010
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
66278: LD_ADDR_EXP 105
66282: PUSH
66283: LD_EXP 105
66287: PPUSH
66288: LD_VAR 0 1
66292: PPUSH
66293: LD_INT 3
66295: PPUSH
66296: CALL_OW 1
66300: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
66301: LD_ADDR_VAR 0 2
66305: PUSH
66306: LD_INT 0
66308: PUSH
66309: LD_INT 0
66311: PUSH
66312: LD_INT 0
66314: PUSH
66315: LD_INT 0
66317: PUSH
66318: EMPTY
66319: LIST
66320: LIST
66321: LIST
66322: LIST
66323: ST_TO_ADDR
// if not eng then
66324: LD_VAR 0 6
66328: NOT
66329: IFFALSE 66392
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
66331: LD_ADDR_VAR 0 11
66335: PUSH
66336: LD_VAR 0 4
66340: PPUSH
66341: LD_INT 2
66343: PPUSH
66344: CALL 53471 0 2
66348: PUSH
66349: LD_INT 1
66351: ARRAY
66352: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
66353: LD_ADDR_VAR 0 2
66357: PUSH
66358: LD_VAR 0 2
66362: PPUSH
66363: LD_INT 2
66365: PPUSH
66366: LD_VAR 0 11
66370: PPUSH
66371: CALL_OW 1
66375: ST_TO_ADDR
// tmp := tmp diff p ;
66376: LD_ADDR_VAR 0 4
66380: PUSH
66381: LD_VAR 0 4
66385: PUSH
66386: LD_VAR 0 11
66390: DIFF
66391: ST_TO_ADDR
// end ; if tmp and sci < 6 then
66392: LD_VAR 0 4
66396: PUSH
66397: LD_VAR 0 8
66401: PUSH
66402: LD_INT 6
66404: LESS
66405: AND
66406: IFFALSE 66594
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
66408: LD_ADDR_VAR 0 9
66412: PUSH
66413: LD_VAR 0 4
66417: PUSH
66418: LD_VAR 0 8
66422: PUSH
66423: LD_VAR 0 7
66427: UNION
66428: DIFF
66429: PPUSH
66430: LD_INT 4
66432: PPUSH
66433: CALL 53471 0 2
66437: ST_TO_ADDR
// p := [ ] ;
66438: LD_ADDR_VAR 0 11
66442: PUSH
66443: EMPTY
66444: ST_TO_ADDR
// if sort then
66445: LD_VAR 0 9
66449: IFFALSE 66565
// for i = 1 to 6 - sci do
66451: LD_ADDR_VAR 0 3
66455: PUSH
66456: DOUBLE
66457: LD_INT 1
66459: DEC
66460: ST_TO_ADDR
66461: LD_INT 6
66463: PUSH
66464: LD_VAR 0 8
66468: MINUS
66469: PUSH
66470: FOR_TO
66471: IFFALSE 66563
// begin if i = sort then
66473: LD_VAR 0 3
66477: PUSH
66478: LD_VAR 0 9
66482: EQUAL
66483: IFFALSE 66487
// break ;
66485: GO 66563
// if GetClass ( i ) = 4 then
66487: LD_VAR 0 3
66491: PPUSH
66492: CALL_OW 257
66496: PUSH
66497: LD_INT 4
66499: EQUAL
66500: IFFALSE 66504
// continue ;
66502: GO 66470
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66504: LD_ADDR_VAR 0 11
66508: PUSH
66509: LD_VAR 0 11
66513: PPUSH
66514: LD_VAR 0 11
66518: PUSH
66519: LD_INT 1
66521: PLUS
66522: PPUSH
66523: LD_VAR 0 9
66527: PUSH
66528: LD_VAR 0 3
66532: ARRAY
66533: PPUSH
66534: CALL_OW 2
66538: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66539: LD_ADDR_VAR 0 4
66543: PUSH
66544: LD_VAR 0 4
66548: PUSH
66549: LD_VAR 0 9
66553: PUSH
66554: LD_VAR 0 3
66558: ARRAY
66559: DIFF
66560: ST_TO_ADDR
// end ;
66561: GO 66470
66563: POP
66564: POP
// if p then
66565: LD_VAR 0 11
66569: IFFALSE 66594
// result := Replace ( result , 4 , p ) ;
66571: LD_ADDR_VAR 0 2
66575: PUSH
66576: LD_VAR 0 2
66580: PPUSH
66581: LD_INT 4
66583: PPUSH
66584: LD_VAR 0 11
66588: PPUSH
66589: CALL_OW 1
66593: ST_TO_ADDR
// end ; if tmp and mech < 6 then
66594: LD_VAR 0 4
66598: PUSH
66599: LD_VAR 0 7
66603: PUSH
66604: LD_INT 6
66606: LESS
66607: AND
66608: IFFALSE 66796
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
66610: LD_ADDR_VAR 0 9
66614: PUSH
66615: LD_VAR 0 4
66619: PUSH
66620: LD_VAR 0 8
66624: PUSH
66625: LD_VAR 0 7
66629: UNION
66630: DIFF
66631: PPUSH
66632: LD_INT 3
66634: PPUSH
66635: CALL 53471 0 2
66639: ST_TO_ADDR
// p := [ ] ;
66640: LD_ADDR_VAR 0 11
66644: PUSH
66645: EMPTY
66646: ST_TO_ADDR
// if sort then
66647: LD_VAR 0 9
66651: IFFALSE 66767
// for i = 1 to 6 - mech do
66653: LD_ADDR_VAR 0 3
66657: PUSH
66658: DOUBLE
66659: LD_INT 1
66661: DEC
66662: ST_TO_ADDR
66663: LD_INT 6
66665: PUSH
66666: LD_VAR 0 7
66670: MINUS
66671: PUSH
66672: FOR_TO
66673: IFFALSE 66765
// begin if i = sort then
66675: LD_VAR 0 3
66679: PUSH
66680: LD_VAR 0 9
66684: EQUAL
66685: IFFALSE 66689
// break ;
66687: GO 66765
// if GetClass ( i ) = 3 then
66689: LD_VAR 0 3
66693: PPUSH
66694: CALL_OW 257
66698: PUSH
66699: LD_INT 3
66701: EQUAL
66702: IFFALSE 66706
// continue ;
66704: GO 66672
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66706: LD_ADDR_VAR 0 11
66710: PUSH
66711: LD_VAR 0 11
66715: PPUSH
66716: LD_VAR 0 11
66720: PUSH
66721: LD_INT 1
66723: PLUS
66724: PPUSH
66725: LD_VAR 0 9
66729: PUSH
66730: LD_VAR 0 3
66734: ARRAY
66735: PPUSH
66736: CALL_OW 2
66740: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66741: LD_ADDR_VAR 0 4
66745: PUSH
66746: LD_VAR 0 4
66750: PUSH
66751: LD_VAR 0 9
66755: PUSH
66756: LD_VAR 0 3
66760: ARRAY
66761: DIFF
66762: ST_TO_ADDR
// end ;
66763: GO 66672
66765: POP
66766: POP
// if p then
66767: LD_VAR 0 11
66771: IFFALSE 66796
// result := Replace ( result , 3 , p ) ;
66773: LD_ADDR_VAR 0 2
66777: PUSH
66778: LD_VAR 0 2
66782: PPUSH
66783: LD_INT 3
66785: PPUSH
66786: LD_VAR 0 11
66790: PPUSH
66791: CALL_OW 1
66795: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
66796: LD_VAR 0 4
66800: PUSH
66801: LD_INT 6
66803: GREATER
66804: PUSH
66805: LD_VAR 0 6
66809: PUSH
66810: LD_INT 6
66812: LESS
66813: AND
66814: IFFALSE 67008
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
66816: LD_ADDR_VAR 0 9
66820: PUSH
66821: LD_VAR 0 4
66825: PUSH
66826: LD_VAR 0 8
66830: PUSH
66831: LD_VAR 0 7
66835: UNION
66836: PUSH
66837: LD_VAR 0 6
66841: UNION
66842: DIFF
66843: PPUSH
66844: LD_INT 2
66846: PPUSH
66847: CALL 53471 0 2
66851: ST_TO_ADDR
// p := [ ] ;
66852: LD_ADDR_VAR 0 11
66856: PUSH
66857: EMPTY
66858: ST_TO_ADDR
// if sort then
66859: LD_VAR 0 9
66863: IFFALSE 66979
// for i = 1 to 6 - eng do
66865: LD_ADDR_VAR 0 3
66869: PUSH
66870: DOUBLE
66871: LD_INT 1
66873: DEC
66874: ST_TO_ADDR
66875: LD_INT 6
66877: PUSH
66878: LD_VAR 0 6
66882: MINUS
66883: PUSH
66884: FOR_TO
66885: IFFALSE 66977
// begin if i = sort then
66887: LD_VAR 0 3
66891: PUSH
66892: LD_VAR 0 9
66896: EQUAL
66897: IFFALSE 66901
// break ;
66899: GO 66977
// if GetClass ( i ) = 2 then
66901: LD_VAR 0 3
66905: PPUSH
66906: CALL_OW 257
66910: PUSH
66911: LD_INT 2
66913: EQUAL
66914: IFFALSE 66918
// continue ;
66916: GO 66884
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66918: LD_ADDR_VAR 0 11
66922: PUSH
66923: LD_VAR 0 11
66927: PPUSH
66928: LD_VAR 0 11
66932: PUSH
66933: LD_INT 1
66935: PLUS
66936: PPUSH
66937: LD_VAR 0 9
66941: PUSH
66942: LD_VAR 0 3
66946: ARRAY
66947: PPUSH
66948: CALL_OW 2
66952: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66953: LD_ADDR_VAR 0 4
66957: PUSH
66958: LD_VAR 0 4
66962: PUSH
66963: LD_VAR 0 9
66967: PUSH
66968: LD_VAR 0 3
66972: ARRAY
66973: DIFF
66974: ST_TO_ADDR
// end ;
66975: GO 66884
66977: POP
66978: POP
// if p then
66979: LD_VAR 0 11
66983: IFFALSE 67008
// result := Replace ( result , 2 , p ) ;
66985: LD_ADDR_VAR 0 2
66989: PUSH
66990: LD_VAR 0 2
66994: PPUSH
66995: LD_INT 2
66997: PPUSH
66998: LD_VAR 0 11
67002: PPUSH
67003: CALL_OW 1
67007: ST_TO_ADDR
// end ; exit ;
67008: GO 68396
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
67010: LD_EXP 90
67014: PUSH
67015: LD_EXP 89
67019: PUSH
67020: LD_VAR 0 1
67024: ARRAY
67025: ARRAY
67026: NOT
67027: PUSH
67028: LD_EXP 63
67032: PUSH
67033: LD_VAR 0 1
67037: ARRAY
67038: PPUSH
67039: LD_INT 30
67041: PUSH
67042: LD_INT 3
67044: PUSH
67045: EMPTY
67046: LIST
67047: LIST
67048: PPUSH
67049: CALL_OW 72
67053: AND
67054: PUSH
67055: LD_EXP 68
67059: PUSH
67060: LD_VAR 0 1
67064: ARRAY
67065: AND
67066: IFFALSE 67674
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
67068: LD_ADDR_EXP 105
67072: PUSH
67073: LD_EXP 105
67077: PPUSH
67078: LD_VAR 0 1
67082: PPUSH
67083: LD_INT 5
67085: PPUSH
67086: CALL_OW 1
67090: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67091: LD_ADDR_VAR 0 2
67095: PUSH
67096: LD_INT 0
67098: PUSH
67099: LD_INT 0
67101: PUSH
67102: LD_INT 0
67104: PUSH
67105: LD_INT 0
67107: PUSH
67108: EMPTY
67109: LIST
67110: LIST
67111: LIST
67112: LIST
67113: ST_TO_ADDR
// if sci > 1 then
67114: LD_VAR 0 8
67118: PUSH
67119: LD_INT 1
67121: GREATER
67122: IFFALSE 67150
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
67124: LD_ADDR_VAR 0 4
67128: PUSH
67129: LD_VAR 0 4
67133: PUSH
67134: LD_VAR 0 8
67138: PUSH
67139: LD_VAR 0 8
67143: PUSH
67144: LD_INT 1
67146: ARRAY
67147: DIFF
67148: DIFF
67149: ST_TO_ADDR
// if tmp and not sci then
67150: LD_VAR 0 4
67154: PUSH
67155: LD_VAR 0 8
67159: NOT
67160: AND
67161: IFFALSE 67230
// begin sort := SortBySkill ( tmp , 4 ) ;
67163: LD_ADDR_VAR 0 9
67167: PUSH
67168: LD_VAR 0 4
67172: PPUSH
67173: LD_INT 4
67175: PPUSH
67176: CALL 53471 0 2
67180: ST_TO_ADDR
// if sort then
67181: LD_VAR 0 9
67185: IFFALSE 67201
// p := sort [ 1 ] ;
67187: LD_ADDR_VAR 0 11
67191: PUSH
67192: LD_VAR 0 9
67196: PUSH
67197: LD_INT 1
67199: ARRAY
67200: ST_TO_ADDR
// if p then
67201: LD_VAR 0 11
67205: IFFALSE 67230
// result := Replace ( result , 4 , p ) ;
67207: LD_ADDR_VAR 0 2
67211: PUSH
67212: LD_VAR 0 2
67216: PPUSH
67217: LD_INT 4
67219: PPUSH
67220: LD_VAR 0 11
67224: PPUSH
67225: CALL_OW 1
67229: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
67230: LD_ADDR_VAR 0 4
67234: PUSH
67235: LD_VAR 0 4
67239: PUSH
67240: LD_VAR 0 7
67244: DIFF
67245: ST_TO_ADDR
// if tmp and mech < 6 then
67246: LD_VAR 0 4
67250: PUSH
67251: LD_VAR 0 7
67255: PUSH
67256: LD_INT 6
67258: LESS
67259: AND
67260: IFFALSE 67448
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
67262: LD_ADDR_VAR 0 9
67266: PUSH
67267: LD_VAR 0 4
67271: PUSH
67272: LD_VAR 0 8
67276: PUSH
67277: LD_VAR 0 7
67281: UNION
67282: DIFF
67283: PPUSH
67284: LD_INT 3
67286: PPUSH
67287: CALL 53471 0 2
67291: ST_TO_ADDR
// p := [ ] ;
67292: LD_ADDR_VAR 0 11
67296: PUSH
67297: EMPTY
67298: ST_TO_ADDR
// if sort then
67299: LD_VAR 0 9
67303: IFFALSE 67419
// for i = 1 to 6 - mech do
67305: LD_ADDR_VAR 0 3
67309: PUSH
67310: DOUBLE
67311: LD_INT 1
67313: DEC
67314: ST_TO_ADDR
67315: LD_INT 6
67317: PUSH
67318: LD_VAR 0 7
67322: MINUS
67323: PUSH
67324: FOR_TO
67325: IFFALSE 67417
// begin if i = sort then
67327: LD_VAR 0 3
67331: PUSH
67332: LD_VAR 0 9
67336: EQUAL
67337: IFFALSE 67341
// break ;
67339: GO 67417
// if GetClass ( i ) = 3 then
67341: LD_VAR 0 3
67345: PPUSH
67346: CALL_OW 257
67350: PUSH
67351: LD_INT 3
67353: EQUAL
67354: IFFALSE 67358
// continue ;
67356: GO 67324
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67358: LD_ADDR_VAR 0 11
67362: PUSH
67363: LD_VAR 0 11
67367: PPUSH
67368: LD_VAR 0 11
67372: PUSH
67373: LD_INT 1
67375: PLUS
67376: PPUSH
67377: LD_VAR 0 9
67381: PUSH
67382: LD_VAR 0 3
67386: ARRAY
67387: PPUSH
67388: CALL_OW 2
67392: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67393: LD_ADDR_VAR 0 4
67397: PUSH
67398: LD_VAR 0 4
67402: PUSH
67403: LD_VAR 0 9
67407: PUSH
67408: LD_VAR 0 3
67412: ARRAY
67413: DIFF
67414: ST_TO_ADDR
// end ;
67415: GO 67324
67417: POP
67418: POP
// if p then
67419: LD_VAR 0 11
67423: IFFALSE 67448
// result := Replace ( result , 3 , p ) ;
67425: LD_ADDR_VAR 0 2
67429: PUSH
67430: LD_VAR 0 2
67434: PPUSH
67435: LD_INT 3
67437: PPUSH
67438: LD_VAR 0 11
67442: PPUSH
67443: CALL_OW 1
67447: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
67448: LD_ADDR_VAR 0 4
67452: PUSH
67453: LD_VAR 0 4
67457: PUSH
67458: LD_VAR 0 6
67462: DIFF
67463: ST_TO_ADDR
// if tmp and eng < 6 then
67464: LD_VAR 0 4
67468: PUSH
67469: LD_VAR 0 6
67473: PUSH
67474: LD_INT 6
67476: LESS
67477: AND
67478: IFFALSE 67672
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
67480: LD_ADDR_VAR 0 9
67484: PUSH
67485: LD_VAR 0 4
67489: PUSH
67490: LD_VAR 0 8
67494: PUSH
67495: LD_VAR 0 7
67499: UNION
67500: PUSH
67501: LD_VAR 0 6
67505: UNION
67506: DIFF
67507: PPUSH
67508: LD_INT 2
67510: PPUSH
67511: CALL 53471 0 2
67515: ST_TO_ADDR
// p := [ ] ;
67516: LD_ADDR_VAR 0 11
67520: PUSH
67521: EMPTY
67522: ST_TO_ADDR
// if sort then
67523: LD_VAR 0 9
67527: IFFALSE 67643
// for i = 1 to 6 - eng do
67529: LD_ADDR_VAR 0 3
67533: PUSH
67534: DOUBLE
67535: LD_INT 1
67537: DEC
67538: ST_TO_ADDR
67539: LD_INT 6
67541: PUSH
67542: LD_VAR 0 6
67546: MINUS
67547: PUSH
67548: FOR_TO
67549: IFFALSE 67641
// begin if i = sort then
67551: LD_VAR 0 3
67555: PUSH
67556: LD_VAR 0 9
67560: EQUAL
67561: IFFALSE 67565
// break ;
67563: GO 67641
// if GetClass ( i ) = 2 then
67565: LD_VAR 0 3
67569: PPUSH
67570: CALL_OW 257
67574: PUSH
67575: LD_INT 2
67577: EQUAL
67578: IFFALSE 67582
// continue ;
67580: GO 67548
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67582: LD_ADDR_VAR 0 11
67586: PUSH
67587: LD_VAR 0 11
67591: PPUSH
67592: LD_VAR 0 11
67596: PUSH
67597: LD_INT 1
67599: PLUS
67600: PPUSH
67601: LD_VAR 0 9
67605: PUSH
67606: LD_VAR 0 3
67610: ARRAY
67611: PPUSH
67612: CALL_OW 2
67616: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67617: LD_ADDR_VAR 0 4
67621: PUSH
67622: LD_VAR 0 4
67626: PUSH
67627: LD_VAR 0 9
67631: PUSH
67632: LD_VAR 0 3
67636: ARRAY
67637: DIFF
67638: ST_TO_ADDR
// end ;
67639: GO 67548
67641: POP
67642: POP
// if p then
67643: LD_VAR 0 11
67647: IFFALSE 67672
// result := Replace ( result , 2 , p ) ;
67649: LD_ADDR_VAR 0 2
67653: PUSH
67654: LD_VAR 0 2
67658: PPUSH
67659: LD_INT 2
67661: PPUSH
67662: LD_VAR 0 11
67666: PPUSH
67667: CALL_OW 1
67671: ST_TO_ADDR
// end ; exit ;
67672: GO 68396
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
67674: LD_EXP 90
67678: PUSH
67679: LD_EXP 89
67683: PUSH
67684: LD_VAR 0 1
67688: ARRAY
67689: ARRAY
67690: NOT
67691: PUSH
67692: LD_EXP 63
67696: PUSH
67697: LD_VAR 0 1
67701: ARRAY
67702: PPUSH
67703: LD_INT 30
67705: PUSH
67706: LD_INT 3
67708: PUSH
67709: EMPTY
67710: LIST
67711: LIST
67712: PPUSH
67713: CALL_OW 72
67717: AND
67718: PUSH
67719: LD_EXP 68
67723: PUSH
67724: LD_VAR 0 1
67728: ARRAY
67729: NOT
67730: AND
67731: IFFALSE 68396
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
67733: LD_ADDR_EXP 105
67737: PUSH
67738: LD_EXP 105
67742: PPUSH
67743: LD_VAR 0 1
67747: PPUSH
67748: LD_INT 6
67750: PPUSH
67751: CALL_OW 1
67755: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67756: LD_ADDR_VAR 0 2
67760: PUSH
67761: LD_INT 0
67763: PUSH
67764: LD_INT 0
67766: PUSH
67767: LD_INT 0
67769: PUSH
67770: LD_INT 0
67772: PUSH
67773: EMPTY
67774: LIST
67775: LIST
67776: LIST
67777: LIST
67778: ST_TO_ADDR
// if sci >= 1 then
67779: LD_VAR 0 8
67783: PUSH
67784: LD_INT 1
67786: GREATEREQUAL
67787: IFFALSE 67809
// tmp := tmp diff sci [ 1 ] ;
67789: LD_ADDR_VAR 0 4
67793: PUSH
67794: LD_VAR 0 4
67798: PUSH
67799: LD_VAR 0 8
67803: PUSH
67804: LD_INT 1
67806: ARRAY
67807: DIFF
67808: ST_TO_ADDR
// if tmp and not sci then
67809: LD_VAR 0 4
67813: PUSH
67814: LD_VAR 0 8
67818: NOT
67819: AND
67820: IFFALSE 67889
// begin sort := SortBySkill ( tmp , 4 ) ;
67822: LD_ADDR_VAR 0 9
67826: PUSH
67827: LD_VAR 0 4
67831: PPUSH
67832: LD_INT 4
67834: PPUSH
67835: CALL 53471 0 2
67839: ST_TO_ADDR
// if sort then
67840: LD_VAR 0 9
67844: IFFALSE 67860
// p := sort [ 1 ] ;
67846: LD_ADDR_VAR 0 11
67850: PUSH
67851: LD_VAR 0 9
67855: PUSH
67856: LD_INT 1
67858: ARRAY
67859: ST_TO_ADDR
// if p then
67860: LD_VAR 0 11
67864: IFFALSE 67889
// result := Replace ( result , 4 , p ) ;
67866: LD_ADDR_VAR 0 2
67870: PUSH
67871: LD_VAR 0 2
67875: PPUSH
67876: LD_INT 4
67878: PPUSH
67879: LD_VAR 0 11
67883: PPUSH
67884: CALL_OW 1
67888: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
67889: LD_ADDR_VAR 0 4
67893: PUSH
67894: LD_VAR 0 4
67898: PUSH
67899: LD_VAR 0 7
67903: DIFF
67904: ST_TO_ADDR
// if tmp and mech < 6 then
67905: LD_VAR 0 4
67909: PUSH
67910: LD_VAR 0 7
67914: PUSH
67915: LD_INT 6
67917: LESS
67918: AND
67919: IFFALSE 68101
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
67921: LD_ADDR_VAR 0 9
67925: PUSH
67926: LD_VAR 0 4
67930: PUSH
67931: LD_VAR 0 7
67935: DIFF
67936: PPUSH
67937: LD_INT 3
67939: PPUSH
67940: CALL 53471 0 2
67944: ST_TO_ADDR
// p := [ ] ;
67945: LD_ADDR_VAR 0 11
67949: PUSH
67950: EMPTY
67951: ST_TO_ADDR
// if sort then
67952: LD_VAR 0 9
67956: IFFALSE 68072
// for i = 1 to 6 - mech do
67958: LD_ADDR_VAR 0 3
67962: PUSH
67963: DOUBLE
67964: LD_INT 1
67966: DEC
67967: ST_TO_ADDR
67968: LD_INT 6
67970: PUSH
67971: LD_VAR 0 7
67975: MINUS
67976: PUSH
67977: FOR_TO
67978: IFFALSE 68070
// begin if i = sort then
67980: LD_VAR 0 3
67984: PUSH
67985: LD_VAR 0 9
67989: EQUAL
67990: IFFALSE 67994
// break ;
67992: GO 68070
// if GetClass ( i ) = 3 then
67994: LD_VAR 0 3
67998: PPUSH
67999: CALL_OW 257
68003: PUSH
68004: LD_INT 3
68006: EQUAL
68007: IFFALSE 68011
// continue ;
68009: GO 67977
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68011: LD_ADDR_VAR 0 11
68015: PUSH
68016: LD_VAR 0 11
68020: PPUSH
68021: LD_VAR 0 11
68025: PUSH
68026: LD_INT 1
68028: PLUS
68029: PPUSH
68030: LD_VAR 0 9
68034: PUSH
68035: LD_VAR 0 3
68039: ARRAY
68040: PPUSH
68041: CALL_OW 2
68045: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68046: LD_ADDR_VAR 0 4
68050: PUSH
68051: LD_VAR 0 4
68055: PUSH
68056: LD_VAR 0 9
68060: PUSH
68061: LD_VAR 0 3
68065: ARRAY
68066: DIFF
68067: ST_TO_ADDR
// end ;
68068: GO 67977
68070: POP
68071: POP
// if p then
68072: LD_VAR 0 11
68076: IFFALSE 68101
// result := Replace ( result , 3 , p ) ;
68078: LD_ADDR_VAR 0 2
68082: PUSH
68083: LD_VAR 0 2
68087: PPUSH
68088: LD_INT 3
68090: PPUSH
68091: LD_VAR 0 11
68095: PPUSH
68096: CALL_OW 1
68100: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
68101: LD_ADDR_VAR 0 4
68105: PUSH
68106: LD_VAR 0 4
68110: PUSH
68111: LD_VAR 0 6
68115: DIFF
68116: ST_TO_ADDR
// if tmp and eng < 4 then
68117: LD_VAR 0 4
68121: PUSH
68122: LD_VAR 0 6
68126: PUSH
68127: LD_INT 4
68129: LESS
68130: AND
68131: IFFALSE 68321
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
68133: LD_ADDR_VAR 0 9
68137: PUSH
68138: LD_VAR 0 4
68142: PUSH
68143: LD_VAR 0 7
68147: PUSH
68148: LD_VAR 0 6
68152: UNION
68153: DIFF
68154: PPUSH
68155: LD_INT 2
68157: PPUSH
68158: CALL 53471 0 2
68162: ST_TO_ADDR
// p := [ ] ;
68163: LD_ADDR_VAR 0 11
68167: PUSH
68168: EMPTY
68169: ST_TO_ADDR
// if sort then
68170: LD_VAR 0 9
68174: IFFALSE 68290
// for i = 1 to 4 - eng do
68176: LD_ADDR_VAR 0 3
68180: PUSH
68181: DOUBLE
68182: LD_INT 1
68184: DEC
68185: ST_TO_ADDR
68186: LD_INT 4
68188: PUSH
68189: LD_VAR 0 6
68193: MINUS
68194: PUSH
68195: FOR_TO
68196: IFFALSE 68288
// begin if i = sort then
68198: LD_VAR 0 3
68202: PUSH
68203: LD_VAR 0 9
68207: EQUAL
68208: IFFALSE 68212
// break ;
68210: GO 68288
// if GetClass ( i ) = 2 then
68212: LD_VAR 0 3
68216: PPUSH
68217: CALL_OW 257
68221: PUSH
68222: LD_INT 2
68224: EQUAL
68225: IFFALSE 68229
// continue ;
68227: GO 68195
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68229: LD_ADDR_VAR 0 11
68233: PUSH
68234: LD_VAR 0 11
68238: PPUSH
68239: LD_VAR 0 11
68243: PUSH
68244: LD_INT 1
68246: PLUS
68247: PPUSH
68248: LD_VAR 0 9
68252: PUSH
68253: LD_VAR 0 3
68257: ARRAY
68258: PPUSH
68259: CALL_OW 2
68263: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68264: LD_ADDR_VAR 0 4
68268: PUSH
68269: LD_VAR 0 4
68273: PUSH
68274: LD_VAR 0 9
68278: PUSH
68279: LD_VAR 0 3
68283: ARRAY
68284: DIFF
68285: ST_TO_ADDR
// end ;
68286: GO 68195
68288: POP
68289: POP
// if p then
68290: LD_VAR 0 11
68294: IFFALSE 68319
// result := Replace ( result , 2 , p ) ;
68296: LD_ADDR_VAR 0 2
68300: PUSH
68301: LD_VAR 0 2
68305: PPUSH
68306: LD_INT 2
68308: PPUSH
68309: LD_VAR 0 11
68313: PPUSH
68314: CALL_OW 1
68318: ST_TO_ADDR
// end else
68319: GO 68365
// for i = eng downto 5 do
68321: LD_ADDR_VAR 0 3
68325: PUSH
68326: DOUBLE
68327: LD_VAR 0 6
68331: INC
68332: ST_TO_ADDR
68333: LD_INT 5
68335: PUSH
68336: FOR_DOWNTO
68337: IFFALSE 68363
// tmp := tmp union eng [ i ] ;
68339: LD_ADDR_VAR 0 4
68343: PUSH
68344: LD_VAR 0 4
68348: PUSH
68349: LD_VAR 0 6
68353: PUSH
68354: LD_VAR 0 3
68358: ARRAY
68359: UNION
68360: ST_TO_ADDR
68361: GO 68336
68363: POP
68364: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
68365: LD_ADDR_VAR 0 2
68369: PUSH
68370: LD_VAR 0 2
68374: PPUSH
68375: LD_INT 1
68377: PPUSH
68378: LD_VAR 0 4
68382: PUSH
68383: LD_VAR 0 5
68387: DIFF
68388: PPUSH
68389: CALL_OW 1
68393: ST_TO_ADDR
// exit ;
68394: GO 68396
// end ; end ;
68396: LD_VAR 0 2
68400: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
68401: LD_INT 0
68403: PPUSH
68404: PPUSH
68405: PPUSH
// if not mc_bases then
68406: LD_EXP 63
68410: NOT
68411: IFFALSE 68415
// exit ;
68413: GO 68557
// for i = 1 to mc_bases do
68415: LD_ADDR_VAR 0 2
68419: PUSH
68420: DOUBLE
68421: LD_INT 1
68423: DEC
68424: ST_TO_ADDR
68425: LD_EXP 63
68429: PUSH
68430: FOR_TO
68431: IFFALSE 68548
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68433: LD_ADDR_VAR 0 3
68437: PUSH
68438: LD_EXP 63
68442: PUSH
68443: LD_VAR 0 2
68447: ARRAY
68448: PPUSH
68449: LD_INT 21
68451: PUSH
68452: LD_INT 3
68454: PUSH
68455: EMPTY
68456: LIST
68457: LIST
68458: PUSH
68459: LD_INT 3
68461: PUSH
68462: LD_INT 2
68464: PUSH
68465: LD_INT 30
68467: PUSH
68468: LD_INT 29
68470: PUSH
68471: EMPTY
68472: LIST
68473: LIST
68474: PUSH
68475: LD_INT 30
68477: PUSH
68478: LD_INT 30
68480: PUSH
68481: EMPTY
68482: LIST
68483: LIST
68484: PUSH
68485: EMPTY
68486: LIST
68487: LIST
68488: LIST
68489: PUSH
68490: EMPTY
68491: LIST
68492: LIST
68493: PUSH
68494: LD_INT 3
68496: PUSH
68497: LD_INT 24
68499: PUSH
68500: LD_INT 1000
68502: PUSH
68503: EMPTY
68504: LIST
68505: LIST
68506: PUSH
68507: EMPTY
68508: LIST
68509: LIST
68510: PUSH
68511: EMPTY
68512: LIST
68513: LIST
68514: LIST
68515: PPUSH
68516: CALL_OW 72
68520: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
68521: LD_ADDR_EXP 64
68525: PUSH
68526: LD_EXP 64
68530: PPUSH
68531: LD_VAR 0 2
68535: PPUSH
68536: LD_VAR 0 3
68540: PPUSH
68541: CALL_OW 1
68545: ST_TO_ADDR
// end ;
68546: GO 68430
68548: POP
68549: POP
// RaiseSailEvent ( 101 ) ;
68550: LD_INT 101
68552: PPUSH
68553: CALL_OW 427
// end ;
68557: LD_VAR 0 1
68561: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
68562: LD_INT 0
68564: PPUSH
68565: PPUSH
68566: PPUSH
68567: PPUSH
68568: PPUSH
68569: PPUSH
68570: PPUSH
// if not mc_bases then
68571: LD_EXP 63
68575: NOT
68576: IFFALSE 68580
// exit ;
68578: GO 69142
// for i = 1 to mc_bases do
68580: LD_ADDR_VAR 0 2
68584: PUSH
68585: DOUBLE
68586: LD_INT 1
68588: DEC
68589: ST_TO_ADDR
68590: LD_EXP 63
68594: PUSH
68595: FOR_TO
68596: IFFALSE 69133
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
68598: LD_ADDR_VAR 0 5
68602: PUSH
68603: LD_EXP 63
68607: PUSH
68608: LD_VAR 0 2
68612: ARRAY
68613: PUSH
68614: LD_EXP 92
68618: PUSH
68619: LD_VAR 0 2
68623: ARRAY
68624: UNION
68625: PPUSH
68626: LD_INT 21
68628: PUSH
68629: LD_INT 1
68631: PUSH
68632: EMPTY
68633: LIST
68634: LIST
68635: PUSH
68636: LD_INT 1
68638: PUSH
68639: LD_INT 3
68641: PUSH
68642: LD_INT 54
68644: PUSH
68645: EMPTY
68646: LIST
68647: PUSH
68648: EMPTY
68649: LIST
68650: LIST
68651: PUSH
68652: LD_INT 3
68654: PUSH
68655: LD_INT 24
68657: PUSH
68658: LD_INT 1000
68660: PUSH
68661: EMPTY
68662: LIST
68663: LIST
68664: PUSH
68665: EMPTY
68666: LIST
68667: LIST
68668: PUSH
68669: EMPTY
68670: LIST
68671: LIST
68672: LIST
68673: PUSH
68674: EMPTY
68675: LIST
68676: LIST
68677: PPUSH
68678: CALL_OW 72
68682: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
68683: LD_ADDR_VAR 0 6
68687: PUSH
68688: LD_EXP 63
68692: PUSH
68693: LD_VAR 0 2
68697: ARRAY
68698: PPUSH
68699: LD_INT 21
68701: PUSH
68702: LD_INT 1
68704: PUSH
68705: EMPTY
68706: LIST
68707: LIST
68708: PUSH
68709: LD_INT 1
68711: PUSH
68712: LD_INT 3
68714: PUSH
68715: LD_INT 54
68717: PUSH
68718: EMPTY
68719: LIST
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: PUSH
68725: LD_INT 3
68727: PUSH
68728: LD_INT 24
68730: PUSH
68731: LD_INT 250
68733: PUSH
68734: EMPTY
68735: LIST
68736: LIST
68737: PUSH
68738: EMPTY
68739: LIST
68740: LIST
68741: PUSH
68742: EMPTY
68743: LIST
68744: LIST
68745: LIST
68746: PUSH
68747: EMPTY
68748: LIST
68749: LIST
68750: PPUSH
68751: CALL_OW 72
68755: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
68756: LD_ADDR_VAR 0 7
68760: PUSH
68761: LD_VAR 0 5
68765: PUSH
68766: LD_VAR 0 6
68770: DIFF
68771: ST_TO_ADDR
// if not need_heal_1 then
68772: LD_VAR 0 6
68776: NOT
68777: IFFALSE 68810
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
68779: LD_ADDR_EXP 66
68783: PUSH
68784: LD_EXP 66
68788: PPUSH
68789: LD_VAR 0 2
68793: PUSH
68794: LD_INT 1
68796: PUSH
68797: EMPTY
68798: LIST
68799: LIST
68800: PPUSH
68801: EMPTY
68802: PPUSH
68803: CALL 22238 0 3
68807: ST_TO_ADDR
68808: GO 68880
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
68810: LD_ADDR_EXP 66
68814: PUSH
68815: LD_EXP 66
68819: PPUSH
68820: LD_VAR 0 2
68824: PUSH
68825: LD_INT 1
68827: PUSH
68828: EMPTY
68829: LIST
68830: LIST
68831: PPUSH
68832: LD_EXP 66
68836: PUSH
68837: LD_VAR 0 2
68841: ARRAY
68842: PUSH
68843: LD_INT 1
68845: ARRAY
68846: PPUSH
68847: LD_INT 3
68849: PUSH
68850: LD_INT 24
68852: PUSH
68853: LD_INT 1000
68855: PUSH
68856: EMPTY
68857: LIST
68858: LIST
68859: PUSH
68860: EMPTY
68861: LIST
68862: LIST
68863: PPUSH
68864: CALL_OW 72
68868: PUSH
68869: LD_VAR 0 6
68873: UNION
68874: PPUSH
68875: CALL 22238 0 3
68879: ST_TO_ADDR
// if not need_heal_2 then
68880: LD_VAR 0 7
68884: NOT
68885: IFFALSE 68918
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
68887: LD_ADDR_EXP 66
68891: PUSH
68892: LD_EXP 66
68896: PPUSH
68897: LD_VAR 0 2
68901: PUSH
68902: LD_INT 2
68904: PUSH
68905: EMPTY
68906: LIST
68907: LIST
68908: PPUSH
68909: EMPTY
68910: PPUSH
68911: CALL 22238 0 3
68915: ST_TO_ADDR
68916: GO 68950
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
68918: LD_ADDR_EXP 66
68922: PUSH
68923: LD_EXP 66
68927: PPUSH
68928: LD_VAR 0 2
68932: PUSH
68933: LD_INT 2
68935: PUSH
68936: EMPTY
68937: LIST
68938: LIST
68939: PPUSH
68940: LD_VAR 0 7
68944: PPUSH
68945: CALL 22238 0 3
68949: ST_TO_ADDR
// if need_heal_2 then
68950: LD_VAR 0 7
68954: IFFALSE 69115
// for j in need_heal_2 do
68956: LD_ADDR_VAR 0 3
68960: PUSH
68961: LD_VAR 0 7
68965: PUSH
68966: FOR_IN
68967: IFFALSE 69113
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68969: LD_ADDR_VAR 0 5
68973: PUSH
68974: LD_EXP 63
68978: PUSH
68979: LD_VAR 0 2
68983: ARRAY
68984: PPUSH
68985: LD_INT 2
68987: PUSH
68988: LD_INT 30
68990: PUSH
68991: LD_INT 6
68993: PUSH
68994: EMPTY
68995: LIST
68996: LIST
68997: PUSH
68998: LD_INT 30
69000: PUSH
69001: LD_INT 7
69003: PUSH
69004: EMPTY
69005: LIST
69006: LIST
69007: PUSH
69008: LD_INT 30
69010: PUSH
69011: LD_INT 8
69013: PUSH
69014: EMPTY
69015: LIST
69016: LIST
69017: PUSH
69018: LD_INT 30
69020: PUSH
69021: LD_INT 0
69023: PUSH
69024: EMPTY
69025: LIST
69026: LIST
69027: PUSH
69028: LD_INT 30
69030: PUSH
69031: LD_INT 1
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: PUSH
69038: EMPTY
69039: LIST
69040: LIST
69041: LIST
69042: LIST
69043: LIST
69044: LIST
69045: PPUSH
69046: CALL_OW 72
69050: ST_TO_ADDR
// if tmp then
69051: LD_VAR 0 5
69055: IFFALSE 69111
// begin k := NearestUnitToUnit ( tmp , j ) ;
69057: LD_ADDR_VAR 0 4
69061: PUSH
69062: LD_VAR 0 5
69066: PPUSH
69067: LD_VAR 0 3
69071: PPUSH
69072: CALL_OW 74
69076: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
69077: LD_VAR 0 3
69081: PPUSH
69082: LD_VAR 0 4
69086: PPUSH
69087: CALL_OW 296
69091: PUSH
69092: LD_INT 5
69094: GREATER
69095: IFFALSE 69111
// ComMoveToNearbyEntrance ( j , k ) ;
69097: LD_VAR 0 3
69101: PPUSH
69102: LD_VAR 0 4
69106: PPUSH
69107: CALL 55844 0 2
// end ; end ;
69111: GO 68966
69113: POP
69114: POP
// if not need_heal_1 and not need_heal_2 then
69115: LD_VAR 0 6
69119: NOT
69120: PUSH
69121: LD_VAR 0 7
69125: NOT
69126: AND
69127: IFFALSE 69131
// continue ;
69129: GO 68595
// end ;
69131: GO 68595
69133: POP
69134: POP
// RaiseSailEvent ( 102 ) ;
69135: LD_INT 102
69137: PPUSH
69138: CALL_OW 427
// end ;
69142: LD_VAR 0 1
69146: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
69147: LD_INT 0
69149: PPUSH
69150: PPUSH
69151: PPUSH
69152: PPUSH
69153: PPUSH
69154: PPUSH
69155: PPUSH
69156: PPUSH
// if not mc_bases then
69157: LD_EXP 63
69161: NOT
69162: IFFALSE 69166
// exit ;
69164: GO 70077
// for i = 1 to mc_bases do
69166: LD_ADDR_VAR 0 2
69170: PUSH
69171: DOUBLE
69172: LD_INT 1
69174: DEC
69175: ST_TO_ADDR
69176: LD_EXP 63
69180: PUSH
69181: FOR_TO
69182: IFFALSE 70075
// begin if not mc_building_need_repair [ i ] then
69184: LD_EXP 64
69188: PUSH
69189: LD_VAR 0 2
69193: ARRAY
69194: NOT
69195: IFFALSE 69380
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
69197: LD_ADDR_VAR 0 6
69201: PUSH
69202: LD_EXP 82
69206: PUSH
69207: LD_VAR 0 2
69211: ARRAY
69212: PPUSH
69213: LD_INT 3
69215: PUSH
69216: LD_INT 24
69218: PUSH
69219: LD_INT 1000
69221: PUSH
69222: EMPTY
69223: LIST
69224: LIST
69225: PUSH
69226: EMPTY
69227: LIST
69228: LIST
69229: PUSH
69230: LD_INT 2
69232: PUSH
69233: LD_INT 34
69235: PUSH
69236: LD_INT 13
69238: PUSH
69239: EMPTY
69240: LIST
69241: LIST
69242: PUSH
69243: LD_INT 34
69245: PUSH
69246: LD_INT 52
69248: PUSH
69249: EMPTY
69250: LIST
69251: LIST
69252: PUSH
69253: LD_INT 34
69255: PUSH
69256: LD_INT 88
69258: PUSH
69259: EMPTY
69260: LIST
69261: LIST
69262: PUSH
69263: EMPTY
69264: LIST
69265: LIST
69266: LIST
69267: LIST
69268: PUSH
69269: EMPTY
69270: LIST
69271: LIST
69272: PPUSH
69273: CALL_OW 72
69277: ST_TO_ADDR
// if cranes then
69278: LD_VAR 0 6
69282: IFFALSE 69344
// for j in cranes do
69284: LD_ADDR_VAR 0 3
69288: PUSH
69289: LD_VAR 0 6
69293: PUSH
69294: FOR_IN
69295: IFFALSE 69342
// if not IsInArea ( j , mc_parking [ i ] ) then
69297: LD_VAR 0 3
69301: PPUSH
69302: LD_EXP 87
69306: PUSH
69307: LD_VAR 0 2
69311: ARRAY
69312: PPUSH
69313: CALL_OW 308
69317: NOT
69318: IFFALSE 69340
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69320: LD_VAR 0 3
69324: PPUSH
69325: LD_EXP 87
69329: PUSH
69330: LD_VAR 0 2
69334: ARRAY
69335: PPUSH
69336: CALL_OW 113
69340: GO 69294
69342: POP
69343: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
69344: LD_ADDR_EXP 65
69348: PUSH
69349: LD_EXP 65
69353: PPUSH
69354: LD_VAR 0 2
69358: PPUSH
69359: EMPTY
69360: PPUSH
69361: CALL_OW 1
69365: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
69366: LD_VAR 0 2
69370: PPUSH
69371: LD_INT 101
69373: PPUSH
69374: CALL 64220 0 2
// continue ;
69378: GO 69181
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
69380: LD_ADDR_EXP 69
69384: PUSH
69385: LD_EXP 69
69389: PPUSH
69390: LD_VAR 0 2
69394: PPUSH
69395: EMPTY
69396: PPUSH
69397: CALL_OW 1
69401: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
69402: LD_VAR 0 2
69406: PPUSH
69407: LD_INT 103
69409: PPUSH
69410: CALL 64220 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
69414: LD_ADDR_VAR 0 5
69418: PUSH
69419: LD_EXP 63
69423: PUSH
69424: LD_VAR 0 2
69428: ARRAY
69429: PUSH
69430: LD_EXP 92
69434: PUSH
69435: LD_VAR 0 2
69439: ARRAY
69440: UNION
69441: PPUSH
69442: LD_INT 2
69444: PUSH
69445: LD_INT 25
69447: PUSH
69448: LD_INT 2
69450: PUSH
69451: EMPTY
69452: LIST
69453: LIST
69454: PUSH
69455: LD_INT 25
69457: PUSH
69458: LD_INT 16
69460: PUSH
69461: EMPTY
69462: LIST
69463: LIST
69464: PUSH
69465: EMPTY
69466: LIST
69467: LIST
69468: LIST
69469: PUSH
69470: EMPTY
69471: LIST
69472: PPUSH
69473: CALL_OW 72
69477: ST_TO_ADDR
// if mc_need_heal [ i ] then
69478: LD_EXP 66
69482: PUSH
69483: LD_VAR 0 2
69487: ARRAY
69488: IFFALSE 69532
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
69490: LD_ADDR_VAR 0 5
69494: PUSH
69495: LD_VAR 0 5
69499: PUSH
69500: LD_EXP 66
69504: PUSH
69505: LD_VAR 0 2
69509: ARRAY
69510: PUSH
69511: LD_INT 1
69513: ARRAY
69514: PUSH
69515: LD_EXP 66
69519: PUSH
69520: LD_VAR 0 2
69524: ARRAY
69525: PUSH
69526: LD_INT 2
69528: ARRAY
69529: UNION
69530: DIFF
69531: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
69532: LD_ADDR_VAR 0 6
69536: PUSH
69537: LD_EXP 82
69541: PUSH
69542: LD_VAR 0 2
69546: ARRAY
69547: PPUSH
69548: LD_INT 2
69550: PUSH
69551: LD_INT 34
69553: PUSH
69554: LD_INT 13
69556: PUSH
69557: EMPTY
69558: LIST
69559: LIST
69560: PUSH
69561: LD_INT 34
69563: PUSH
69564: LD_INT 52
69566: PUSH
69567: EMPTY
69568: LIST
69569: LIST
69570: PUSH
69571: LD_INT 34
69573: PUSH
69574: LD_INT 88
69576: PUSH
69577: EMPTY
69578: LIST
69579: LIST
69580: PUSH
69581: EMPTY
69582: LIST
69583: LIST
69584: LIST
69585: LIST
69586: PPUSH
69587: CALL_OW 72
69591: ST_TO_ADDR
// if cranes then
69592: LD_VAR 0 6
69596: IFFALSE 69764
// begin for j in cranes do
69598: LD_ADDR_VAR 0 3
69602: PUSH
69603: LD_VAR 0 6
69607: PUSH
69608: FOR_IN
69609: IFFALSE 69762
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
69611: LD_VAR 0 3
69615: PPUSH
69616: CALL_OW 256
69620: PUSH
69621: LD_INT 1000
69623: EQUAL
69624: PUSH
69625: LD_VAR 0 3
69629: PPUSH
69630: CALL_OW 314
69634: NOT
69635: AND
69636: IFFALSE 69702
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
69638: LD_ADDR_VAR 0 8
69642: PUSH
69643: LD_EXP 64
69647: PUSH
69648: LD_VAR 0 2
69652: ARRAY
69653: PPUSH
69654: LD_VAR 0 3
69658: PPUSH
69659: CALL_OW 74
69663: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
69664: LD_VAR 0 8
69668: PPUSH
69669: LD_INT 16
69671: PPUSH
69672: CALL 25203 0 2
69676: PUSH
69677: LD_INT 4
69679: ARRAY
69680: PUSH
69681: LD_INT 10
69683: LESS
69684: IFFALSE 69700
// ComRepairBuilding ( j , to_repair ) ;
69686: LD_VAR 0 3
69690: PPUSH
69691: LD_VAR 0 8
69695: PPUSH
69696: CALL_OW 130
// end else
69700: GO 69760
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
69702: LD_VAR 0 3
69706: PPUSH
69707: CALL_OW 256
69711: PUSH
69712: LD_INT 500
69714: LESS
69715: PUSH
69716: LD_VAR 0 3
69720: PPUSH
69721: LD_EXP 87
69725: PUSH
69726: LD_VAR 0 2
69730: ARRAY
69731: PPUSH
69732: CALL_OW 308
69736: NOT
69737: AND
69738: IFFALSE 69760
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69740: LD_VAR 0 3
69744: PPUSH
69745: LD_EXP 87
69749: PUSH
69750: LD_VAR 0 2
69754: ARRAY
69755: PPUSH
69756: CALL_OW 113
// end ;
69760: GO 69608
69762: POP
69763: POP
// end ; if tmp > 3 then
69764: LD_VAR 0 5
69768: PUSH
69769: LD_INT 3
69771: GREATER
69772: IFFALSE 69792
// tmp := ShrinkArray ( tmp , 4 ) ;
69774: LD_ADDR_VAR 0 5
69778: PUSH
69779: LD_VAR 0 5
69783: PPUSH
69784: LD_INT 4
69786: PPUSH
69787: CALL 55282 0 2
69791: ST_TO_ADDR
// if not tmp then
69792: LD_VAR 0 5
69796: NOT
69797: IFFALSE 69801
// continue ;
69799: GO 69181
// for j in tmp do
69801: LD_ADDR_VAR 0 3
69805: PUSH
69806: LD_VAR 0 5
69810: PUSH
69811: FOR_IN
69812: IFFALSE 70071
// begin if IsInUnit ( j ) then
69814: LD_VAR 0 3
69818: PPUSH
69819: CALL_OW 310
69823: IFFALSE 69834
// ComExitBuilding ( j ) ;
69825: LD_VAR 0 3
69829: PPUSH
69830: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
69834: LD_VAR 0 3
69838: PUSH
69839: LD_EXP 65
69843: PUSH
69844: LD_VAR 0 2
69848: ARRAY
69849: IN
69850: NOT
69851: IFFALSE 69909
// begin SetTag ( j , 101 ) ;
69853: LD_VAR 0 3
69857: PPUSH
69858: LD_INT 101
69860: PPUSH
69861: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
69865: LD_ADDR_EXP 65
69869: PUSH
69870: LD_EXP 65
69874: PPUSH
69875: LD_VAR 0 2
69879: PUSH
69880: LD_EXP 65
69884: PUSH
69885: LD_VAR 0 2
69889: ARRAY
69890: PUSH
69891: LD_INT 1
69893: PLUS
69894: PUSH
69895: EMPTY
69896: LIST
69897: LIST
69898: PPUSH
69899: LD_VAR 0 3
69903: PPUSH
69904: CALL 22238 0 3
69908: ST_TO_ADDR
// end ; wait ( 1 ) ;
69909: LD_INT 1
69911: PPUSH
69912: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
69916: LD_ADDR_VAR 0 7
69920: PUSH
69921: LD_EXP 64
69925: PUSH
69926: LD_VAR 0 2
69930: ARRAY
69931: ST_TO_ADDR
// if mc_scan [ i ] then
69932: LD_EXP 86
69936: PUSH
69937: LD_VAR 0 2
69941: ARRAY
69942: IFFALSE 70004
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
69944: LD_ADDR_VAR 0 7
69948: PUSH
69949: LD_EXP 64
69953: PUSH
69954: LD_VAR 0 2
69958: ARRAY
69959: PPUSH
69960: LD_INT 3
69962: PUSH
69963: LD_INT 30
69965: PUSH
69966: LD_INT 32
69968: PUSH
69969: EMPTY
69970: LIST
69971: LIST
69972: PUSH
69973: LD_INT 30
69975: PUSH
69976: LD_INT 33
69978: PUSH
69979: EMPTY
69980: LIST
69981: LIST
69982: PUSH
69983: LD_INT 30
69985: PUSH
69986: LD_INT 31
69988: PUSH
69989: EMPTY
69990: LIST
69991: LIST
69992: PUSH
69993: EMPTY
69994: LIST
69995: LIST
69996: LIST
69997: LIST
69998: PPUSH
69999: CALL_OW 72
70003: ST_TO_ADDR
// if not to_repair_tmp then
70004: LD_VAR 0 7
70008: NOT
70009: IFFALSE 70013
// continue ;
70011: GO 69811
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
70013: LD_ADDR_VAR 0 8
70017: PUSH
70018: LD_VAR 0 7
70022: PPUSH
70023: LD_VAR 0 3
70027: PPUSH
70028: CALL_OW 74
70032: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
70033: LD_VAR 0 8
70037: PPUSH
70038: LD_INT 16
70040: PPUSH
70041: CALL 25203 0 2
70045: PUSH
70046: LD_INT 4
70048: ARRAY
70049: PUSH
70050: LD_INT 14
70052: LESS
70053: IFFALSE 70069
// ComRepairBuilding ( j , to_repair ) ;
70055: LD_VAR 0 3
70059: PPUSH
70060: LD_VAR 0 8
70064: PPUSH
70065: CALL_OW 130
// end ;
70069: GO 69811
70071: POP
70072: POP
// end ;
70073: GO 69181
70075: POP
70076: POP
// end ;
70077: LD_VAR 0 1
70081: RET
// export function MC_Heal ; var i , j , tmp ; begin
70082: LD_INT 0
70084: PPUSH
70085: PPUSH
70086: PPUSH
70087: PPUSH
// if not mc_bases then
70088: LD_EXP 63
70092: NOT
70093: IFFALSE 70097
// exit ;
70095: GO 70499
// for i = 1 to mc_bases do
70097: LD_ADDR_VAR 0 2
70101: PUSH
70102: DOUBLE
70103: LD_INT 1
70105: DEC
70106: ST_TO_ADDR
70107: LD_EXP 63
70111: PUSH
70112: FOR_TO
70113: IFFALSE 70497
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
70115: LD_EXP 66
70119: PUSH
70120: LD_VAR 0 2
70124: ARRAY
70125: PUSH
70126: LD_INT 1
70128: ARRAY
70129: NOT
70130: PUSH
70131: LD_EXP 66
70135: PUSH
70136: LD_VAR 0 2
70140: ARRAY
70141: PUSH
70142: LD_INT 2
70144: ARRAY
70145: NOT
70146: AND
70147: IFFALSE 70185
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
70149: LD_ADDR_EXP 67
70153: PUSH
70154: LD_EXP 67
70158: PPUSH
70159: LD_VAR 0 2
70163: PPUSH
70164: EMPTY
70165: PPUSH
70166: CALL_OW 1
70170: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
70171: LD_VAR 0 2
70175: PPUSH
70176: LD_INT 102
70178: PPUSH
70179: CALL 64220 0 2
// continue ;
70183: GO 70112
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
70185: LD_ADDR_VAR 0 4
70189: PUSH
70190: LD_EXP 63
70194: PUSH
70195: LD_VAR 0 2
70199: ARRAY
70200: PPUSH
70201: LD_INT 25
70203: PUSH
70204: LD_INT 4
70206: PUSH
70207: EMPTY
70208: LIST
70209: LIST
70210: PPUSH
70211: CALL_OW 72
70215: ST_TO_ADDR
// if not tmp then
70216: LD_VAR 0 4
70220: NOT
70221: IFFALSE 70225
// continue ;
70223: GO 70112
// if mc_taming [ i ] then
70225: LD_EXP 94
70229: PUSH
70230: LD_VAR 0 2
70234: ARRAY
70235: IFFALSE 70259
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70237: LD_ADDR_EXP 94
70241: PUSH
70242: LD_EXP 94
70246: PPUSH
70247: LD_VAR 0 2
70251: PPUSH
70252: EMPTY
70253: PPUSH
70254: CALL_OW 1
70258: ST_TO_ADDR
// for j in tmp do
70259: LD_ADDR_VAR 0 3
70263: PUSH
70264: LD_VAR 0 4
70268: PUSH
70269: FOR_IN
70270: IFFALSE 70493
// begin if IsInUnit ( j ) then
70272: LD_VAR 0 3
70276: PPUSH
70277: CALL_OW 310
70281: IFFALSE 70292
// ComExitBuilding ( j ) ;
70283: LD_VAR 0 3
70287: PPUSH
70288: CALL_OW 122
// if not j in mc_healers [ i ] then
70292: LD_VAR 0 3
70296: PUSH
70297: LD_EXP 67
70301: PUSH
70302: LD_VAR 0 2
70306: ARRAY
70307: IN
70308: NOT
70309: IFFALSE 70355
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
70311: LD_ADDR_EXP 67
70315: PUSH
70316: LD_EXP 67
70320: PPUSH
70321: LD_VAR 0 2
70325: PUSH
70326: LD_EXP 67
70330: PUSH
70331: LD_VAR 0 2
70335: ARRAY
70336: PUSH
70337: LD_INT 1
70339: PLUS
70340: PUSH
70341: EMPTY
70342: LIST
70343: LIST
70344: PPUSH
70345: LD_VAR 0 3
70349: PPUSH
70350: CALL 22238 0 3
70354: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
70355: LD_VAR 0 3
70359: PPUSH
70360: CALL_OW 110
70364: PUSH
70365: LD_INT 102
70367: NONEQUAL
70368: IFFALSE 70382
// SetTag ( j , 102 ) ;
70370: LD_VAR 0 3
70374: PPUSH
70375: LD_INT 102
70377: PPUSH
70378: CALL_OW 109
// Wait ( 3 ) ;
70382: LD_INT 3
70384: PPUSH
70385: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
70389: LD_EXP 66
70393: PUSH
70394: LD_VAR 0 2
70398: ARRAY
70399: PUSH
70400: LD_INT 1
70402: ARRAY
70403: IFFALSE 70435
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
70405: LD_VAR 0 3
70409: PPUSH
70410: LD_EXP 66
70414: PUSH
70415: LD_VAR 0 2
70419: ARRAY
70420: PUSH
70421: LD_INT 1
70423: ARRAY
70424: PUSH
70425: LD_INT 1
70427: ARRAY
70428: PPUSH
70429: CALL_OW 128
70433: GO 70491
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
70435: LD_VAR 0 3
70439: PPUSH
70440: CALL_OW 314
70444: NOT
70445: PUSH
70446: LD_EXP 66
70450: PUSH
70451: LD_VAR 0 2
70455: ARRAY
70456: PUSH
70457: LD_INT 2
70459: ARRAY
70460: AND
70461: IFFALSE 70491
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
70463: LD_VAR 0 3
70467: PPUSH
70468: LD_EXP 66
70472: PUSH
70473: LD_VAR 0 2
70477: ARRAY
70478: PUSH
70479: LD_INT 2
70481: ARRAY
70482: PUSH
70483: LD_INT 1
70485: ARRAY
70486: PPUSH
70487: CALL_OW 128
// end ;
70491: GO 70269
70493: POP
70494: POP
// end ;
70495: GO 70112
70497: POP
70498: POP
// end ;
70499: LD_VAR 0 1
70503: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
70504: LD_INT 0
70506: PPUSH
70507: PPUSH
70508: PPUSH
70509: PPUSH
70510: PPUSH
70511: PPUSH
// if not mc_bases then
70512: LD_EXP 63
70516: NOT
70517: IFFALSE 70521
// exit ;
70519: GO 71684
// for i = 1 to mc_bases do
70521: LD_ADDR_VAR 0 2
70525: PUSH
70526: DOUBLE
70527: LD_INT 1
70529: DEC
70530: ST_TO_ADDR
70531: LD_EXP 63
70535: PUSH
70536: FOR_TO
70537: IFFALSE 71682
// begin if mc_scan [ i ] then
70539: LD_EXP 86
70543: PUSH
70544: LD_VAR 0 2
70548: ARRAY
70549: IFFALSE 70553
// continue ;
70551: GO 70536
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
70553: LD_EXP 68
70557: PUSH
70558: LD_VAR 0 2
70562: ARRAY
70563: NOT
70564: PUSH
70565: LD_EXP 70
70569: PUSH
70570: LD_VAR 0 2
70574: ARRAY
70575: NOT
70576: AND
70577: PUSH
70578: LD_EXP 69
70582: PUSH
70583: LD_VAR 0 2
70587: ARRAY
70588: AND
70589: IFFALSE 70627
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
70591: LD_ADDR_EXP 69
70595: PUSH
70596: LD_EXP 69
70600: PPUSH
70601: LD_VAR 0 2
70605: PPUSH
70606: EMPTY
70607: PPUSH
70608: CALL_OW 1
70612: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
70613: LD_VAR 0 2
70617: PPUSH
70618: LD_INT 103
70620: PPUSH
70621: CALL 64220 0 2
// continue ;
70625: GO 70536
// end ; if mc_construct_list [ i ] then
70627: LD_EXP 70
70631: PUSH
70632: LD_VAR 0 2
70636: ARRAY
70637: IFFALSE 70857
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
70639: LD_ADDR_VAR 0 5
70643: PUSH
70644: LD_EXP 63
70648: PUSH
70649: LD_VAR 0 2
70653: ARRAY
70654: PPUSH
70655: LD_INT 25
70657: PUSH
70658: LD_INT 2
70660: PUSH
70661: EMPTY
70662: LIST
70663: LIST
70664: PPUSH
70665: CALL_OW 72
70669: PUSH
70670: LD_EXP 65
70674: PUSH
70675: LD_VAR 0 2
70679: ARRAY
70680: DIFF
70681: ST_TO_ADDR
// if not tmp then
70682: LD_VAR 0 5
70686: NOT
70687: IFFALSE 70691
// continue ;
70689: GO 70536
// for j in tmp do
70691: LD_ADDR_VAR 0 3
70695: PUSH
70696: LD_VAR 0 5
70700: PUSH
70701: FOR_IN
70702: IFFALSE 70853
// begin if not mc_builders [ i ] then
70704: LD_EXP 69
70708: PUSH
70709: LD_VAR 0 2
70713: ARRAY
70714: NOT
70715: IFFALSE 70773
// begin SetTag ( j , 103 ) ;
70717: LD_VAR 0 3
70721: PPUSH
70722: LD_INT 103
70724: PPUSH
70725: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
70729: LD_ADDR_EXP 69
70733: PUSH
70734: LD_EXP 69
70738: PPUSH
70739: LD_VAR 0 2
70743: PUSH
70744: LD_EXP 69
70748: PUSH
70749: LD_VAR 0 2
70753: ARRAY
70754: PUSH
70755: LD_INT 1
70757: PLUS
70758: PUSH
70759: EMPTY
70760: LIST
70761: LIST
70762: PPUSH
70763: LD_VAR 0 3
70767: PPUSH
70768: CALL 22238 0 3
70772: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
70773: LD_VAR 0 3
70777: PPUSH
70778: CALL_OW 310
70782: IFFALSE 70793
// ComExitBuilding ( j ) ;
70784: LD_VAR 0 3
70788: PPUSH
70789: CALL_OW 122
// wait ( 3 ) ;
70793: LD_INT 3
70795: PPUSH
70796: CALL_OW 67
// if not mc_construct_list [ i ] then
70800: LD_EXP 70
70804: PUSH
70805: LD_VAR 0 2
70809: ARRAY
70810: NOT
70811: IFFALSE 70815
// break ;
70813: GO 70853
// if not HasTask ( j ) then
70815: LD_VAR 0 3
70819: PPUSH
70820: CALL_OW 314
70824: NOT
70825: IFFALSE 70851
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
70827: LD_VAR 0 3
70831: PPUSH
70832: LD_EXP 70
70836: PUSH
70837: LD_VAR 0 2
70841: ARRAY
70842: PUSH
70843: LD_INT 1
70845: ARRAY
70846: PPUSH
70847: CALL 25476 0 2
// end ;
70851: GO 70701
70853: POP
70854: POP
// end else
70855: GO 71680
// if mc_build_list [ i ] then
70857: LD_EXP 68
70861: PUSH
70862: LD_VAR 0 2
70866: ARRAY
70867: IFFALSE 71680
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
70869: LD_EXP 68
70873: PUSH
70874: LD_VAR 0 2
70878: ARRAY
70879: PUSH
70880: LD_INT 1
70882: ARRAY
70883: PUSH
70884: LD_INT 1
70886: ARRAY
70887: PPUSH
70888: CALL 25300 0 1
70892: PUSH
70893: LD_EXP 63
70897: PUSH
70898: LD_VAR 0 2
70902: ARRAY
70903: PPUSH
70904: LD_INT 2
70906: PUSH
70907: LD_INT 30
70909: PUSH
70910: LD_INT 2
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 30
70919: PUSH
70920: LD_INT 3
70922: PUSH
70923: EMPTY
70924: LIST
70925: LIST
70926: PUSH
70927: EMPTY
70928: LIST
70929: LIST
70930: LIST
70931: PPUSH
70932: CALL_OW 72
70936: NOT
70937: AND
70938: IFFALSE 71043
// begin for j = 1 to mc_build_list [ i ] do
70940: LD_ADDR_VAR 0 3
70944: PUSH
70945: DOUBLE
70946: LD_INT 1
70948: DEC
70949: ST_TO_ADDR
70950: LD_EXP 68
70954: PUSH
70955: LD_VAR 0 2
70959: ARRAY
70960: PUSH
70961: FOR_TO
70962: IFFALSE 71041
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
70964: LD_EXP 68
70968: PUSH
70969: LD_VAR 0 2
70973: ARRAY
70974: PUSH
70975: LD_VAR 0 3
70979: ARRAY
70980: PUSH
70981: LD_INT 1
70983: ARRAY
70984: PUSH
70985: LD_INT 2
70987: EQUAL
70988: IFFALSE 71039
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
70990: LD_ADDR_EXP 68
70994: PUSH
70995: LD_EXP 68
70999: PPUSH
71000: LD_VAR 0 2
71004: PPUSH
71005: LD_EXP 68
71009: PUSH
71010: LD_VAR 0 2
71014: ARRAY
71015: PPUSH
71016: LD_VAR 0 3
71020: PPUSH
71021: LD_INT 1
71023: PPUSH
71024: LD_INT 0
71026: PPUSH
71027: CALL 21656 0 4
71031: PPUSH
71032: CALL_OW 1
71036: ST_TO_ADDR
// break ;
71037: GO 71041
// end ;
71039: GO 70961
71041: POP
71042: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71043: LD_ADDR_VAR 0 6
71047: PUSH
71048: LD_EXP 63
71052: PUSH
71053: LD_VAR 0 2
71057: ARRAY
71058: PPUSH
71059: LD_INT 2
71061: PUSH
71062: LD_INT 30
71064: PUSH
71065: LD_INT 0
71067: PUSH
71068: EMPTY
71069: LIST
71070: LIST
71071: PUSH
71072: LD_INT 30
71074: PUSH
71075: LD_INT 1
71077: PUSH
71078: EMPTY
71079: LIST
71080: LIST
71081: PUSH
71082: EMPTY
71083: LIST
71084: LIST
71085: LIST
71086: PPUSH
71087: CALL_OW 72
71091: ST_TO_ADDR
// for k := 1 to depot do
71092: LD_ADDR_VAR 0 4
71096: PUSH
71097: DOUBLE
71098: LD_INT 1
71100: DEC
71101: ST_TO_ADDR
71102: LD_VAR 0 6
71106: PUSH
71107: FOR_TO
71108: IFFALSE 71678
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
71110: LD_EXP 68
71114: PUSH
71115: LD_VAR 0 2
71119: ARRAY
71120: PUSH
71121: LD_INT 1
71123: ARRAY
71124: PUSH
71125: LD_INT 1
71127: ARRAY
71128: PUSH
71129: LD_INT 0
71131: EQUAL
71132: PUSH
71133: LD_VAR 0 6
71137: PUSH
71138: LD_VAR 0 4
71142: ARRAY
71143: PPUSH
71144: LD_EXP 68
71148: PUSH
71149: LD_VAR 0 2
71153: ARRAY
71154: PUSH
71155: LD_INT 1
71157: ARRAY
71158: PUSH
71159: LD_INT 1
71161: ARRAY
71162: PPUSH
71163: LD_EXP 68
71167: PUSH
71168: LD_VAR 0 2
71172: ARRAY
71173: PUSH
71174: LD_INT 1
71176: ARRAY
71177: PUSH
71178: LD_INT 2
71180: ARRAY
71181: PPUSH
71182: LD_EXP 68
71186: PUSH
71187: LD_VAR 0 2
71191: ARRAY
71192: PUSH
71193: LD_INT 1
71195: ARRAY
71196: PUSH
71197: LD_INT 3
71199: ARRAY
71200: PPUSH
71201: LD_EXP 68
71205: PUSH
71206: LD_VAR 0 2
71210: ARRAY
71211: PUSH
71212: LD_INT 1
71214: ARRAY
71215: PUSH
71216: LD_INT 4
71218: ARRAY
71219: PPUSH
71220: CALL 30712 0 5
71224: OR
71225: IFFALSE 71506
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
71227: LD_ADDR_VAR 0 5
71231: PUSH
71232: LD_EXP 63
71236: PUSH
71237: LD_VAR 0 2
71241: ARRAY
71242: PPUSH
71243: LD_INT 25
71245: PUSH
71246: LD_INT 2
71248: PUSH
71249: EMPTY
71250: LIST
71251: LIST
71252: PPUSH
71253: CALL_OW 72
71257: PUSH
71258: LD_EXP 65
71262: PUSH
71263: LD_VAR 0 2
71267: ARRAY
71268: DIFF
71269: ST_TO_ADDR
// if not tmp then
71270: LD_VAR 0 5
71274: NOT
71275: IFFALSE 71279
// continue ;
71277: GO 71107
// for j in tmp do
71279: LD_ADDR_VAR 0 3
71283: PUSH
71284: LD_VAR 0 5
71288: PUSH
71289: FOR_IN
71290: IFFALSE 71502
// begin if not mc_builders [ i ] then
71292: LD_EXP 69
71296: PUSH
71297: LD_VAR 0 2
71301: ARRAY
71302: NOT
71303: IFFALSE 71361
// begin SetTag ( j , 103 ) ;
71305: LD_VAR 0 3
71309: PPUSH
71310: LD_INT 103
71312: PPUSH
71313: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
71317: LD_ADDR_EXP 69
71321: PUSH
71322: LD_EXP 69
71326: PPUSH
71327: LD_VAR 0 2
71331: PUSH
71332: LD_EXP 69
71336: PUSH
71337: LD_VAR 0 2
71341: ARRAY
71342: PUSH
71343: LD_INT 1
71345: PLUS
71346: PUSH
71347: EMPTY
71348: LIST
71349: LIST
71350: PPUSH
71351: LD_VAR 0 3
71355: PPUSH
71356: CALL 22238 0 3
71360: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
71361: LD_VAR 0 3
71365: PPUSH
71366: CALL_OW 310
71370: IFFALSE 71381
// ComExitBuilding ( j ) ;
71372: LD_VAR 0 3
71376: PPUSH
71377: CALL_OW 122
// wait ( 3 ) ;
71381: LD_INT 3
71383: PPUSH
71384: CALL_OW 67
// if not mc_build_list [ i ] then
71388: LD_EXP 68
71392: PUSH
71393: LD_VAR 0 2
71397: ARRAY
71398: NOT
71399: IFFALSE 71403
// break ;
71401: GO 71502
// if not HasTask ( j ) then
71403: LD_VAR 0 3
71407: PPUSH
71408: CALL_OW 314
71412: NOT
71413: IFFALSE 71500
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
71415: LD_VAR 0 3
71419: PPUSH
71420: LD_EXP 68
71424: PUSH
71425: LD_VAR 0 2
71429: ARRAY
71430: PUSH
71431: LD_INT 1
71433: ARRAY
71434: PUSH
71435: LD_INT 1
71437: ARRAY
71438: PPUSH
71439: LD_EXP 68
71443: PUSH
71444: LD_VAR 0 2
71448: ARRAY
71449: PUSH
71450: LD_INT 1
71452: ARRAY
71453: PUSH
71454: LD_INT 2
71456: ARRAY
71457: PPUSH
71458: LD_EXP 68
71462: PUSH
71463: LD_VAR 0 2
71467: ARRAY
71468: PUSH
71469: LD_INT 1
71471: ARRAY
71472: PUSH
71473: LD_INT 3
71475: ARRAY
71476: PPUSH
71477: LD_EXP 68
71481: PUSH
71482: LD_VAR 0 2
71486: ARRAY
71487: PUSH
71488: LD_INT 1
71490: ARRAY
71491: PUSH
71492: LD_INT 4
71494: ARRAY
71495: PPUSH
71496: CALL_OW 145
// end ;
71500: GO 71289
71502: POP
71503: POP
// end else
71504: GO 71676
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
71506: LD_EXP 63
71510: PUSH
71511: LD_VAR 0 2
71515: ARRAY
71516: PPUSH
71517: LD_EXP 68
71521: PUSH
71522: LD_VAR 0 2
71526: ARRAY
71527: PUSH
71528: LD_INT 1
71530: ARRAY
71531: PUSH
71532: LD_INT 1
71534: ARRAY
71535: PPUSH
71536: LD_EXP 68
71540: PUSH
71541: LD_VAR 0 2
71545: ARRAY
71546: PUSH
71547: LD_INT 1
71549: ARRAY
71550: PUSH
71551: LD_INT 2
71553: ARRAY
71554: PPUSH
71555: LD_EXP 68
71559: PUSH
71560: LD_VAR 0 2
71564: ARRAY
71565: PUSH
71566: LD_INT 1
71568: ARRAY
71569: PUSH
71570: LD_INT 3
71572: ARRAY
71573: PPUSH
71574: LD_EXP 68
71578: PUSH
71579: LD_VAR 0 2
71583: ARRAY
71584: PUSH
71585: LD_INT 1
71587: ARRAY
71588: PUSH
71589: LD_INT 4
71591: ARRAY
71592: PPUSH
71593: LD_EXP 63
71597: PUSH
71598: LD_VAR 0 2
71602: ARRAY
71603: PPUSH
71604: LD_INT 21
71606: PUSH
71607: LD_INT 3
71609: PUSH
71610: EMPTY
71611: LIST
71612: LIST
71613: PPUSH
71614: CALL_OW 72
71618: PPUSH
71619: EMPTY
71620: PPUSH
71621: CALL 29466 0 7
71625: NOT
71626: IFFALSE 71676
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
71628: LD_ADDR_EXP 68
71632: PUSH
71633: LD_EXP 68
71637: PPUSH
71638: LD_VAR 0 2
71642: PPUSH
71643: LD_EXP 68
71647: PUSH
71648: LD_VAR 0 2
71652: ARRAY
71653: PPUSH
71654: LD_INT 1
71656: PPUSH
71657: LD_INT 1
71659: NEG
71660: PPUSH
71661: LD_INT 0
71663: PPUSH
71664: CALL 21656 0 4
71668: PPUSH
71669: CALL_OW 1
71673: ST_TO_ADDR
// continue ;
71674: GO 71107
// end ; end ;
71676: GO 71107
71678: POP
71679: POP
// end ; end ;
71680: GO 70536
71682: POP
71683: POP
// end ;
71684: LD_VAR 0 1
71688: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
71689: LD_INT 0
71691: PPUSH
71692: PPUSH
71693: PPUSH
71694: PPUSH
71695: PPUSH
71696: PPUSH
// if not mc_bases then
71697: LD_EXP 63
71701: NOT
71702: IFFALSE 71706
// exit ;
71704: GO 72133
// for i = 1 to mc_bases do
71706: LD_ADDR_VAR 0 2
71710: PUSH
71711: DOUBLE
71712: LD_INT 1
71714: DEC
71715: ST_TO_ADDR
71716: LD_EXP 63
71720: PUSH
71721: FOR_TO
71722: IFFALSE 72131
// begin tmp := mc_build_upgrade [ i ] ;
71724: LD_ADDR_VAR 0 4
71728: PUSH
71729: LD_EXP 95
71733: PUSH
71734: LD_VAR 0 2
71738: ARRAY
71739: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
71740: LD_ADDR_VAR 0 6
71744: PUSH
71745: LD_EXP 96
71749: PUSH
71750: LD_VAR 0 2
71754: ARRAY
71755: PPUSH
71756: LD_INT 2
71758: PUSH
71759: LD_INT 30
71761: PUSH
71762: LD_INT 6
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: PUSH
71769: LD_INT 30
71771: PUSH
71772: LD_INT 7
71774: PUSH
71775: EMPTY
71776: LIST
71777: LIST
71778: PUSH
71779: EMPTY
71780: LIST
71781: LIST
71782: LIST
71783: PPUSH
71784: CALL_OW 72
71788: ST_TO_ADDR
// if not tmp and not lab then
71789: LD_VAR 0 4
71793: NOT
71794: PUSH
71795: LD_VAR 0 6
71799: NOT
71800: AND
71801: IFFALSE 71805
// continue ;
71803: GO 71721
// if tmp then
71805: LD_VAR 0 4
71809: IFFALSE 71929
// for j in tmp do
71811: LD_ADDR_VAR 0 3
71815: PUSH
71816: LD_VAR 0 4
71820: PUSH
71821: FOR_IN
71822: IFFALSE 71927
// begin if UpgradeCost ( j ) then
71824: LD_VAR 0 3
71828: PPUSH
71829: CALL 29126 0 1
71833: IFFALSE 71925
// begin ComUpgrade ( j ) ;
71835: LD_VAR 0 3
71839: PPUSH
71840: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
71844: LD_ADDR_EXP 95
71848: PUSH
71849: LD_EXP 95
71853: PPUSH
71854: LD_VAR 0 2
71858: PPUSH
71859: LD_EXP 95
71863: PUSH
71864: LD_VAR 0 2
71868: ARRAY
71869: PUSH
71870: LD_VAR 0 3
71874: DIFF
71875: PPUSH
71876: CALL_OW 1
71880: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
71881: LD_ADDR_EXP 70
71885: PUSH
71886: LD_EXP 70
71890: PPUSH
71891: LD_VAR 0 2
71895: PUSH
71896: LD_EXP 70
71900: PUSH
71901: LD_VAR 0 2
71905: ARRAY
71906: PUSH
71907: LD_INT 1
71909: PLUS
71910: PUSH
71911: EMPTY
71912: LIST
71913: LIST
71914: PPUSH
71915: LD_VAR 0 3
71919: PPUSH
71920: CALL 22238 0 3
71924: ST_TO_ADDR
// end ; end ;
71925: GO 71821
71927: POP
71928: POP
// if not lab or not mc_lab_upgrade [ i ] then
71929: LD_VAR 0 6
71933: NOT
71934: PUSH
71935: LD_EXP 97
71939: PUSH
71940: LD_VAR 0 2
71944: ARRAY
71945: NOT
71946: OR
71947: IFFALSE 71951
// continue ;
71949: GO 71721
// for j in lab do
71951: LD_ADDR_VAR 0 3
71955: PUSH
71956: LD_VAR 0 6
71960: PUSH
71961: FOR_IN
71962: IFFALSE 72127
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
71964: LD_VAR 0 3
71968: PPUSH
71969: CALL_OW 266
71973: PUSH
71974: LD_INT 6
71976: PUSH
71977: LD_INT 7
71979: PUSH
71980: EMPTY
71981: LIST
71982: LIST
71983: IN
71984: PUSH
71985: LD_VAR 0 3
71989: PPUSH
71990: CALL_OW 461
71994: PUSH
71995: LD_INT 1
71997: NONEQUAL
71998: AND
71999: IFFALSE 72125
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
72001: LD_VAR 0 3
72005: PPUSH
72006: LD_EXP 97
72010: PUSH
72011: LD_VAR 0 2
72015: ARRAY
72016: PUSH
72017: LD_INT 1
72019: ARRAY
72020: PPUSH
72021: CALL 29331 0 2
72025: IFFALSE 72125
// begin ComCancel ( j ) ;
72027: LD_VAR 0 3
72031: PPUSH
72032: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
72036: LD_VAR 0 3
72040: PPUSH
72041: LD_EXP 97
72045: PUSH
72046: LD_VAR 0 2
72050: ARRAY
72051: PUSH
72052: LD_INT 1
72054: ARRAY
72055: PPUSH
72056: CALL_OW 207
// if not j in mc_construct_list [ i ] then
72060: LD_VAR 0 3
72064: PUSH
72065: LD_EXP 70
72069: PUSH
72070: LD_VAR 0 2
72074: ARRAY
72075: IN
72076: NOT
72077: IFFALSE 72123
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
72079: LD_ADDR_EXP 70
72083: PUSH
72084: LD_EXP 70
72088: PPUSH
72089: LD_VAR 0 2
72093: PUSH
72094: LD_EXP 70
72098: PUSH
72099: LD_VAR 0 2
72103: ARRAY
72104: PUSH
72105: LD_INT 1
72107: PLUS
72108: PUSH
72109: EMPTY
72110: LIST
72111: LIST
72112: PPUSH
72113: LD_VAR 0 3
72117: PPUSH
72118: CALL 22238 0 3
72122: ST_TO_ADDR
// break ;
72123: GO 72127
// end ; end ; end ;
72125: GO 71961
72127: POP
72128: POP
// end ;
72129: GO 71721
72131: POP
72132: POP
// end ;
72133: LD_VAR 0 1
72137: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
72138: LD_INT 0
72140: PPUSH
72141: PPUSH
72142: PPUSH
72143: PPUSH
72144: PPUSH
72145: PPUSH
72146: PPUSH
72147: PPUSH
72148: PPUSH
// if not mc_bases then
72149: LD_EXP 63
72153: NOT
72154: IFFALSE 72158
// exit ;
72156: GO 72563
// for i = 1 to mc_bases do
72158: LD_ADDR_VAR 0 2
72162: PUSH
72163: DOUBLE
72164: LD_INT 1
72166: DEC
72167: ST_TO_ADDR
72168: LD_EXP 63
72172: PUSH
72173: FOR_TO
72174: IFFALSE 72561
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
72176: LD_EXP 71
72180: PUSH
72181: LD_VAR 0 2
72185: ARRAY
72186: NOT
72187: PUSH
72188: LD_EXP 63
72192: PUSH
72193: LD_VAR 0 2
72197: ARRAY
72198: PPUSH
72199: LD_INT 30
72201: PUSH
72202: LD_INT 3
72204: PUSH
72205: EMPTY
72206: LIST
72207: LIST
72208: PPUSH
72209: CALL_OW 72
72213: NOT
72214: OR
72215: IFFALSE 72219
// continue ;
72217: GO 72173
// busy := false ;
72219: LD_ADDR_VAR 0 8
72223: PUSH
72224: LD_INT 0
72226: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72227: LD_ADDR_VAR 0 4
72231: PUSH
72232: LD_EXP 63
72236: PUSH
72237: LD_VAR 0 2
72241: ARRAY
72242: PPUSH
72243: LD_INT 30
72245: PUSH
72246: LD_INT 3
72248: PUSH
72249: EMPTY
72250: LIST
72251: LIST
72252: PPUSH
72253: CALL_OW 72
72257: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
72258: LD_ADDR_VAR 0 6
72262: PUSH
72263: LD_EXP 71
72267: PUSH
72268: LD_VAR 0 2
72272: ARRAY
72273: PPUSH
72274: LD_INT 2
72276: PUSH
72277: LD_INT 30
72279: PUSH
72280: LD_INT 32
72282: PUSH
72283: EMPTY
72284: LIST
72285: LIST
72286: PUSH
72287: LD_INT 30
72289: PUSH
72290: LD_INT 33
72292: PUSH
72293: EMPTY
72294: LIST
72295: LIST
72296: PUSH
72297: EMPTY
72298: LIST
72299: LIST
72300: LIST
72301: PPUSH
72302: CALL_OW 72
72306: ST_TO_ADDR
// if not t then
72307: LD_VAR 0 6
72311: NOT
72312: IFFALSE 72316
// continue ;
72314: GO 72173
// for j in tmp do
72316: LD_ADDR_VAR 0 3
72320: PUSH
72321: LD_VAR 0 4
72325: PUSH
72326: FOR_IN
72327: IFFALSE 72357
// if not BuildingStatus ( j ) = bs_idle then
72329: LD_VAR 0 3
72333: PPUSH
72334: CALL_OW 461
72338: PUSH
72339: LD_INT 2
72341: EQUAL
72342: NOT
72343: IFFALSE 72355
// begin busy := true ;
72345: LD_ADDR_VAR 0 8
72349: PUSH
72350: LD_INT 1
72352: ST_TO_ADDR
// break ;
72353: GO 72357
// end ;
72355: GO 72326
72357: POP
72358: POP
// if busy then
72359: LD_VAR 0 8
72363: IFFALSE 72367
// continue ;
72365: GO 72173
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
72367: LD_ADDR_VAR 0 7
72371: PUSH
72372: LD_VAR 0 6
72376: PPUSH
72377: LD_INT 35
72379: PUSH
72380: LD_INT 0
72382: PUSH
72383: EMPTY
72384: LIST
72385: LIST
72386: PPUSH
72387: CALL_OW 72
72391: ST_TO_ADDR
// if tw then
72392: LD_VAR 0 7
72396: IFFALSE 72473
// begin tw := tw [ 1 ] ;
72398: LD_ADDR_VAR 0 7
72402: PUSH
72403: LD_VAR 0 7
72407: PUSH
72408: LD_INT 1
72410: ARRAY
72411: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
72412: LD_ADDR_VAR 0 9
72416: PUSH
72417: LD_VAR 0 7
72421: PPUSH
72422: LD_EXP 88
72426: PUSH
72427: LD_VAR 0 2
72431: ARRAY
72432: PPUSH
72433: CALL 27623 0 2
72437: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
72438: LD_EXP 102
72442: PUSH
72443: LD_VAR 0 2
72447: ARRAY
72448: IFFALSE 72471
// if not weapon in mc_allowed_tower_weapons [ i ] then
72450: LD_VAR 0 9
72454: PUSH
72455: LD_EXP 102
72459: PUSH
72460: LD_VAR 0 2
72464: ARRAY
72465: IN
72466: NOT
72467: IFFALSE 72471
// continue ;
72469: GO 72173
// end else
72471: GO 72536
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
72473: LD_ADDR_VAR 0 5
72477: PUSH
72478: LD_EXP 71
72482: PUSH
72483: LD_VAR 0 2
72487: ARRAY
72488: PPUSH
72489: LD_VAR 0 4
72493: PPUSH
72494: CALL 54515 0 2
72498: ST_TO_ADDR
// if not tmp2 then
72499: LD_VAR 0 5
72503: NOT
72504: IFFALSE 72508
// continue ;
72506: GO 72173
// tw := tmp2 [ 1 ] ;
72508: LD_ADDR_VAR 0 7
72512: PUSH
72513: LD_VAR 0 5
72517: PUSH
72518: LD_INT 1
72520: ARRAY
72521: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
72522: LD_ADDR_VAR 0 9
72526: PUSH
72527: LD_VAR 0 5
72531: PUSH
72532: LD_INT 2
72534: ARRAY
72535: ST_TO_ADDR
// end ; if not weapon then
72536: LD_VAR 0 9
72540: NOT
72541: IFFALSE 72545
// continue ;
72543: GO 72173
// ComPlaceWeapon ( tw , weapon ) ;
72545: LD_VAR 0 7
72549: PPUSH
72550: LD_VAR 0 9
72554: PPUSH
72555: CALL_OW 148
// end ;
72559: GO 72173
72561: POP
72562: POP
// end ;
72563: LD_VAR 0 1
72567: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
72568: LD_INT 0
72570: PPUSH
72571: PPUSH
72572: PPUSH
72573: PPUSH
72574: PPUSH
72575: PPUSH
72576: PPUSH
// if not mc_bases then
72577: LD_EXP 63
72581: NOT
72582: IFFALSE 72586
// exit ;
72584: GO 73361
// for i = 1 to mc_bases do
72586: LD_ADDR_VAR 0 2
72590: PUSH
72591: DOUBLE
72592: LD_INT 1
72594: DEC
72595: ST_TO_ADDR
72596: LD_EXP 63
72600: PUSH
72601: FOR_TO
72602: IFFALSE 73359
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
72604: LD_EXP 76
72608: PUSH
72609: LD_VAR 0 2
72613: ARRAY
72614: NOT
72615: PUSH
72616: LD_EXP 76
72620: PUSH
72621: LD_VAR 0 2
72625: ARRAY
72626: PUSH
72627: LD_EXP 77
72631: PUSH
72632: LD_VAR 0 2
72636: ARRAY
72637: EQUAL
72638: OR
72639: PUSH
72640: LD_EXP 86
72644: PUSH
72645: LD_VAR 0 2
72649: ARRAY
72650: OR
72651: IFFALSE 72655
// continue ;
72653: GO 72601
// if mc_miners [ i ] then
72655: LD_EXP 77
72659: PUSH
72660: LD_VAR 0 2
72664: ARRAY
72665: IFFALSE 73046
// begin for j = mc_miners [ i ] downto 1 do
72667: LD_ADDR_VAR 0 3
72671: PUSH
72672: DOUBLE
72673: LD_EXP 77
72677: PUSH
72678: LD_VAR 0 2
72682: ARRAY
72683: INC
72684: ST_TO_ADDR
72685: LD_INT 1
72687: PUSH
72688: FOR_DOWNTO
72689: IFFALSE 73044
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
72691: LD_EXP 77
72695: PUSH
72696: LD_VAR 0 2
72700: ARRAY
72701: PUSH
72702: LD_VAR 0 3
72706: ARRAY
72707: PPUSH
72708: CALL_OW 301
72712: PUSH
72713: LD_EXP 77
72717: PUSH
72718: LD_VAR 0 2
72722: ARRAY
72723: PUSH
72724: LD_VAR 0 3
72728: ARRAY
72729: PPUSH
72730: CALL_OW 257
72734: PUSH
72735: LD_INT 1
72737: NONEQUAL
72738: OR
72739: IFFALSE 72802
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
72741: LD_ADDR_VAR 0 5
72745: PUSH
72746: LD_EXP 77
72750: PUSH
72751: LD_VAR 0 2
72755: ARRAY
72756: PUSH
72757: LD_EXP 77
72761: PUSH
72762: LD_VAR 0 2
72766: ARRAY
72767: PUSH
72768: LD_VAR 0 3
72772: ARRAY
72773: DIFF
72774: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
72775: LD_ADDR_EXP 77
72779: PUSH
72780: LD_EXP 77
72784: PPUSH
72785: LD_VAR 0 2
72789: PPUSH
72790: LD_VAR 0 5
72794: PPUSH
72795: CALL_OW 1
72799: ST_TO_ADDR
// continue ;
72800: GO 72688
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
72802: LD_EXP 77
72806: PUSH
72807: LD_VAR 0 2
72811: ARRAY
72812: PUSH
72813: LD_VAR 0 3
72817: ARRAY
72818: PPUSH
72819: CALL_OW 257
72823: PUSH
72824: LD_INT 1
72826: EQUAL
72827: PUSH
72828: LD_EXP 77
72832: PUSH
72833: LD_VAR 0 2
72837: ARRAY
72838: PUSH
72839: LD_VAR 0 3
72843: ARRAY
72844: PPUSH
72845: CALL_OW 459
72849: NOT
72850: AND
72851: PUSH
72852: LD_EXP 77
72856: PUSH
72857: LD_VAR 0 2
72861: ARRAY
72862: PUSH
72863: LD_VAR 0 3
72867: ARRAY
72868: PPUSH
72869: CALL_OW 314
72873: NOT
72874: AND
72875: IFFALSE 73042
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
72877: LD_EXP 77
72881: PUSH
72882: LD_VAR 0 2
72886: ARRAY
72887: PUSH
72888: LD_VAR 0 3
72892: ARRAY
72893: PPUSH
72894: CALL_OW 310
72898: IFFALSE 72921
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
72900: LD_EXP 77
72904: PUSH
72905: LD_VAR 0 2
72909: ARRAY
72910: PUSH
72911: LD_VAR 0 3
72915: ARRAY
72916: PPUSH
72917: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
72921: LD_EXP 77
72925: PUSH
72926: LD_VAR 0 2
72930: ARRAY
72931: PUSH
72932: LD_VAR 0 3
72936: ARRAY
72937: PPUSH
72938: CALL_OW 314
72942: NOT
72943: IFFALSE 73042
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
72945: LD_ADDR_VAR 0 7
72949: PUSH
72950: LD_VAR 0 3
72954: PUSH
72955: LD_EXP 76
72959: PUSH
72960: LD_VAR 0 2
72964: ARRAY
72965: PPUSH
72966: CALL 19378 0 1
72970: MOD
72971: PUSH
72972: LD_INT 1
72974: PLUS
72975: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
72976: LD_EXP 77
72980: PUSH
72981: LD_VAR 0 2
72985: ARRAY
72986: PUSH
72987: LD_VAR 0 3
72991: ARRAY
72992: PPUSH
72993: LD_EXP 76
72997: PUSH
72998: LD_VAR 0 2
73002: ARRAY
73003: PUSH
73004: LD_VAR 0 7
73008: ARRAY
73009: PUSH
73010: LD_INT 1
73012: ARRAY
73013: PPUSH
73014: LD_EXP 76
73018: PUSH
73019: LD_VAR 0 2
73023: ARRAY
73024: PUSH
73025: LD_VAR 0 7
73029: ARRAY
73030: PUSH
73031: LD_INT 2
73033: ARRAY
73034: PPUSH
73035: LD_INT 0
73037: PPUSH
73038: CALL_OW 193
// end ; end ; end ;
73042: GO 72688
73044: POP
73045: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
73046: LD_ADDR_VAR 0 5
73050: PUSH
73051: LD_EXP 63
73055: PUSH
73056: LD_VAR 0 2
73060: ARRAY
73061: PPUSH
73062: LD_INT 2
73064: PUSH
73065: LD_INT 30
73067: PUSH
73068: LD_INT 4
73070: PUSH
73071: EMPTY
73072: LIST
73073: LIST
73074: PUSH
73075: LD_INT 30
73077: PUSH
73078: LD_INT 5
73080: PUSH
73081: EMPTY
73082: LIST
73083: LIST
73084: PUSH
73085: LD_INT 30
73087: PUSH
73088: LD_INT 32
73090: PUSH
73091: EMPTY
73092: LIST
73093: LIST
73094: PUSH
73095: EMPTY
73096: LIST
73097: LIST
73098: LIST
73099: LIST
73100: PPUSH
73101: CALL_OW 72
73105: ST_TO_ADDR
// if not tmp then
73106: LD_VAR 0 5
73110: NOT
73111: IFFALSE 73115
// continue ;
73113: GO 72601
// list := [ ] ;
73115: LD_ADDR_VAR 0 6
73119: PUSH
73120: EMPTY
73121: ST_TO_ADDR
// for j in tmp do
73122: LD_ADDR_VAR 0 3
73126: PUSH
73127: LD_VAR 0 5
73131: PUSH
73132: FOR_IN
73133: IFFALSE 73202
// begin for k in UnitsInside ( j ) do
73135: LD_ADDR_VAR 0 4
73139: PUSH
73140: LD_VAR 0 3
73144: PPUSH
73145: CALL_OW 313
73149: PUSH
73150: FOR_IN
73151: IFFALSE 73198
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
73153: LD_VAR 0 4
73157: PPUSH
73158: CALL_OW 257
73162: PUSH
73163: LD_INT 1
73165: EQUAL
73166: PUSH
73167: LD_VAR 0 4
73171: PPUSH
73172: CALL_OW 459
73176: NOT
73177: AND
73178: IFFALSE 73196
// list := list ^ k ;
73180: LD_ADDR_VAR 0 6
73184: PUSH
73185: LD_VAR 0 6
73189: PUSH
73190: LD_VAR 0 4
73194: ADD
73195: ST_TO_ADDR
73196: GO 73150
73198: POP
73199: POP
// end ;
73200: GO 73132
73202: POP
73203: POP
// list := list diff mc_miners [ i ] ;
73204: LD_ADDR_VAR 0 6
73208: PUSH
73209: LD_VAR 0 6
73213: PUSH
73214: LD_EXP 77
73218: PUSH
73219: LD_VAR 0 2
73223: ARRAY
73224: DIFF
73225: ST_TO_ADDR
// if not list then
73226: LD_VAR 0 6
73230: NOT
73231: IFFALSE 73235
// continue ;
73233: GO 72601
// k := mc_mines [ i ] - mc_miners [ i ] ;
73235: LD_ADDR_VAR 0 4
73239: PUSH
73240: LD_EXP 76
73244: PUSH
73245: LD_VAR 0 2
73249: ARRAY
73250: PUSH
73251: LD_EXP 77
73255: PUSH
73256: LD_VAR 0 2
73260: ARRAY
73261: MINUS
73262: ST_TO_ADDR
// if k > list then
73263: LD_VAR 0 4
73267: PUSH
73268: LD_VAR 0 6
73272: GREATER
73273: IFFALSE 73285
// k := list ;
73275: LD_ADDR_VAR 0 4
73279: PUSH
73280: LD_VAR 0 6
73284: ST_TO_ADDR
// for j = 1 to k do
73285: LD_ADDR_VAR 0 3
73289: PUSH
73290: DOUBLE
73291: LD_INT 1
73293: DEC
73294: ST_TO_ADDR
73295: LD_VAR 0 4
73299: PUSH
73300: FOR_TO
73301: IFFALSE 73355
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
73303: LD_ADDR_EXP 77
73307: PUSH
73308: LD_EXP 77
73312: PPUSH
73313: LD_VAR 0 2
73317: PUSH
73318: LD_EXP 77
73322: PUSH
73323: LD_VAR 0 2
73327: ARRAY
73328: PUSH
73329: LD_INT 1
73331: PLUS
73332: PUSH
73333: EMPTY
73334: LIST
73335: LIST
73336: PPUSH
73337: LD_VAR 0 6
73341: PUSH
73342: LD_VAR 0 3
73346: ARRAY
73347: PPUSH
73348: CALL 22238 0 3
73352: ST_TO_ADDR
73353: GO 73300
73355: POP
73356: POP
// end ;
73357: GO 72601
73359: POP
73360: POP
// end ;
73361: LD_VAR 0 1
73365: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
73366: LD_INT 0
73368: PPUSH
73369: PPUSH
73370: PPUSH
73371: PPUSH
73372: PPUSH
73373: PPUSH
73374: PPUSH
73375: PPUSH
73376: PPUSH
73377: PPUSH
73378: PPUSH
// if not mc_bases then
73379: LD_EXP 63
73383: NOT
73384: IFFALSE 73388
// exit ;
73386: GO 75211
// for i = 1 to mc_bases do
73388: LD_ADDR_VAR 0 2
73392: PUSH
73393: DOUBLE
73394: LD_INT 1
73396: DEC
73397: ST_TO_ADDR
73398: LD_EXP 63
73402: PUSH
73403: FOR_TO
73404: IFFALSE 75209
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
73406: LD_EXP 63
73410: PUSH
73411: LD_VAR 0 2
73415: ARRAY
73416: NOT
73417: PUSH
73418: LD_EXP 70
73422: PUSH
73423: LD_VAR 0 2
73427: ARRAY
73428: OR
73429: IFFALSE 73433
// continue ;
73431: GO 73403
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
73433: LD_EXP 79
73437: PUSH
73438: LD_VAR 0 2
73442: ARRAY
73443: NOT
73444: PUSH
73445: LD_EXP 80
73449: PUSH
73450: LD_VAR 0 2
73454: ARRAY
73455: AND
73456: IFFALSE 73494
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
73458: LD_ADDR_EXP 80
73462: PUSH
73463: LD_EXP 80
73467: PPUSH
73468: LD_VAR 0 2
73472: PPUSH
73473: EMPTY
73474: PPUSH
73475: CALL_OW 1
73479: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
73480: LD_VAR 0 2
73484: PPUSH
73485: LD_INT 107
73487: PPUSH
73488: CALL 64220 0 2
// continue ;
73492: GO 73403
// end ; target := [ ] ;
73494: LD_ADDR_VAR 0 7
73498: PUSH
73499: EMPTY
73500: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
73501: LD_ADDR_VAR 0 6
73505: PUSH
73506: LD_EXP 63
73510: PUSH
73511: LD_VAR 0 2
73515: ARRAY
73516: PUSH
73517: LD_INT 1
73519: ARRAY
73520: PPUSH
73521: CALL_OW 255
73525: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73526: LD_ADDR_VAR 0 9
73530: PUSH
73531: LD_EXP 63
73535: PUSH
73536: LD_VAR 0 2
73540: ARRAY
73541: PPUSH
73542: LD_INT 2
73544: PUSH
73545: LD_INT 30
73547: PUSH
73548: LD_INT 0
73550: PUSH
73551: EMPTY
73552: LIST
73553: LIST
73554: PUSH
73555: LD_INT 30
73557: PUSH
73558: LD_INT 1
73560: PUSH
73561: EMPTY
73562: LIST
73563: LIST
73564: PUSH
73565: EMPTY
73566: LIST
73567: LIST
73568: LIST
73569: PPUSH
73570: CALL_OW 72
73574: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
73575: LD_ADDR_VAR 0 3
73579: PUSH
73580: DOUBLE
73581: LD_EXP 79
73585: PUSH
73586: LD_VAR 0 2
73590: ARRAY
73591: INC
73592: ST_TO_ADDR
73593: LD_INT 1
73595: PUSH
73596: FOR_DOWNTO
73597: IFFALSE 73842
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
73599: LD_EXP 79
73603: PUSH
73604: LD_VAR 0 2
73608: ARRAY
73609: PUSH
73610: LD_VAR 0 3
73614: ARRAY
73615: PUSH
73616: LD_INT 2
73618: ARRAY
73619: PPUSH
73620: LD_EXP 79
73624: PUSH
73625: LD_VAR 0 2
73629: ARRAY
73630: PUSH
73631: LD_VAR 0 3
73635: ARRAY
73636: PUSH
73637: LD_INT 3
73639: ARRAY
73640: PPUSH
73641: CALL_OW 488
73645: PUSH
73646: LD_EXP 79
73650: PUSH
73651: LD_VAR 0 2
73655: ARRAY
73656: PUSH
73657: LD_VAR 0 3
73661: ARRAY
73662: PUSH
73663: LD_INT 2
73665: ARRAY
73666: PPUSH
73667: LD_EXP 79
73671: PUSH
73672: LD_VAR 0 2
73676: ARRAY
73677: PUSH
73678: LD_VAR 0 3
73682: ARRAY
73683: PUSH
73684: LD_INT 3
73686: ARRAY
73687: PPUSH
73688: CALL_OW 284
73692: PUSH
73693: LD_INT 0
73695: EQUAL
73696: AND
73697: IFFALSE 73752
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
73699: LD_ADDR_VAR 0 5
73703: PUSH
73704: LD_EXP 79
73708: PUSH
73709: LD_VAR 0 2
73713: ARRAY
73714: PPUSH
73715: LD_VAR 0 3
73719: PPUSH
73720: CALL_OW 3
73724: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
73725: LD_ADDR_EXP 79
73729: PUSH
73730: LD_EXP 79
73734: PPUSH
73735: LD_VAR 0 2
73739: PPUSH
73740: LD_VAR 0 5
73744: PPUSH
73745: CALL_OW 1
73749: ST_TO_ADDR
// continue ;
73750: GO 73596
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
73752: LD_VAR 0 6
73756: PPUSH
73757: LD_EXP 79
73761: PUSH
73762: LD_VAR 0 2
73766: ARRAY
73767: PUSH
73768: LD_VAR 0 3
73772: ARRAY
73773: PUSH
73774: LD_INT 2
73776: ARRAY
73777: PPUSH
73778: LD_EXP 79
73782: PUSH
73783: LD_VAR 0 2
73787: ARRAY
73788: PUSH
73789: LD_VAR 0 3
73793: ARRAY
73794: PUSH
73795: LD_INT 3
73797: ARRAY
73798: PPUSH
73799: LD_INT 30
73801: PPUSH
73802: CALL 23502 0 4
73806: PUSH
73807: LD_INT 4
73809: ARRAY
73810: PUSH
73811: LD_INT 0
73813: EQUAL
73814: IFFALSE 73840
// begin target := mc_crates [ i ] [ j ] ;
73816: LD_ADDR_VAR 0 7
73820: PUSH
73821: LD_EXP 79
73825: PUSH
73826: LD_VAR 0 2
73830: ARRAY
73831: PUSH
73832: LD_VAR 0 3
73836: ARRAY
73837: ST_TO_ADDR
// break ;
73838: GO 73842
// end ; end ;
73840: GO 73596
73842: POP
73843: POP
// if not target then
73844: LD_VAR 0 7
73848: NOT
73849: IFFALSE 73853
// continue ;
73851: GO 73403
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
73853: LD_ADDR_VAR 0 8
73857: PUSH
73858: LD_EXP 82
73862: PUSH
73863: LD_VAR 0 2
73867: ARRAY
73868: PPUSH
73869: LD_INT 2
73871: PUSH
73872: LD_INT 3
73874: PUSH
73875: LD_INT 58
73877: PUSH
73878: EMPTY
73879: LIST
73880: PUSH
73881: EMPTY
73882: LIST
73883: LIST
73884: PUSH
73885: LD_INT 61
73887: PUSH
73888: EMPTY
73889: LIST
73890: PUSH
73891: LD_INT 33
73893: PUSH
73894: LD_INT 5
73896: PUSH
73897: EMPTY
73898: LIST
73899: LIST
73900: PUSH
73901: LD_INT 33
73903: PUSH
73904: LD_INT 3
73906: PUSH
73907: EMPTY
73908: LIST
73909: LIST
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: LIST
73915: LIST
73916: LIST
73917: PUSH
73918: LD_INT 2
73920: PUSH
73921: LD_INT 34
73923: PUSH
73924: LD_INT 32
73926: PUSH
73927: EMPTY
73928: LIST
73929: LIST
73930: PUSH
73931: LD_INT 34
73933: PUSH
73934: LD_INT 51
73936: PUSH
73937: EMPTY
73938: LIST
73939: LIST
73940: PUSH
73941: LD_INT 34
73943: PUSH
73944: LD_INT 12
73946: PUSH
73947: EMPTY
73948: LIST
73949: LIST
73950: PUSH
73951: EMPTY
73952: LIST
73953: LIST
73954: LIST
73955: LIST
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: PPUSH
73961: CALL_OW 72
73965: ST_TO_ADDR
// if not cargo then
73966: LD_VAR 0 8
73970: NOT
73971: IFFALSE 74677
// begin if mc_crates_collector [ i ] < 5 then
73973: LD_EXP 80
73977: PUSH
73978: LD_VAR 0 2
73982: ARRAY
73983: PUSH
73984: LD_INT 5
73986: LESS
73987: IFFALSE 74353
// begin if mc_ape [ i ] then
73989: LD_EXP 92
73993: PUSH
73994: LD_VAR 0 2
73998: ARRAY
73999: IFFALSE 74046
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
74001: LD_ADDR_VAR 0 5
74005: PUSH
74006: LD_EXP 92
74010: PUSH
74011: LD_VAR 0 2
74015: ARRAY
74016: PPUSH
74017: LD_INT 25
74019: PUSH
74020: LD_INT 16
74022: PUSH
74023: EMPTY
74024: LIST
74025: LIST
74026: PUSH
74027: LD_INT 24
74029: PUSH
74030: LD_INT 750
74032: PUSH
74033: EMPTY
74034: LIST
74035: LIST
74036: PUSH
74037: EMPTY
74038: LIST
74039: LIST
74040: PPUSH
74041: CALL_OW 72
74045: ST_TO_ADDR
// if not tmp then
74046: LD_VAR 0 5
74050: NOT
74051: IFFALSE 74098
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
74053: LD_ADDR_VAR 0 5
74057: PUSH
74058: LD_EXP 63
74062: PUSH
74063: LD_VAR 0 2
74067: ARRAY
74068: PPUSH
74069: LD_INT 25
74071: PUSH
74072: LD_INT 2
74074: PUSH
74075: EMPTY
74076: LIST
74077: LIST
74078: PUSH
74079: LD_INT 24
74081: PUSH
74082: LD_INT 750
74084: PUSH
74085: EMPTY
74086: LIST
74087: LIST
74088: PUSH
74089: EMPTY
74090: LIST
74091: LIST
74092: PPUSH
74093: CALL_OW 72
74097: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
74098: LD_EXP 92
74102: PUSH
74103: LD_VAR 0 2
74107: ARRAY
74108: PUSH
74109: LD_EXP 63
74113: PUSH
74114: LD_VAR 0 2
74118: ARRAY
74119: PPUSH
74120: LD_INT 25
74122: PUSH
74123: LD_INT 2
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: PUSH
74130: LD_INT 24
74132: PUSH
74133: LD_INT 750
74135: PUSH
74136: EMPTY
74137: LIST
74138: LIST
74139: PUSH
74140: EMPTY
74141: LIST
74142: LIST
74143: PPUSH
74144: CALL_OW 72
74148: AND
74149: PUSH
74150: LD_VAR 0 5
74154: PUSH
74155: LD_INT 5
74157: LESS
74158: AND
74159: IFFALSE 74241
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
74161: LD_ADDR_VAR 0 3
74165: PUSH
74166: LD_EXP 63
74170: PUSH
74171: LD_VAR 0 2
74175: ARRAY
74176: PPUSH
74177: LD_INT 25
74179: PUSH
74180: LD_INT 2
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: PUSH
74187: LD_INT 24
74189: PUSH
74190: LD_INT 750
74192: PUSH
74193: EMPTY
74194: LIST
74195: LIST
74196: PUSH
74197: EMPTY
74198: LIST
74199: LIST
74200: PPUSH
74201: CALL_OW 72
74205: PUSH
74206: FOR_IN
74207: IFFALSE 74239
// begin tmp := tmp union j ;
74209: LD_ADDR_VAR 0 5
74213: PUSH
74214: LD_VAR 0 5
74218: PUSH
74219: LD_VAR 0 3
74223: UNION
74224: ST_TO_ADDR
// if tmp >= 5 then
74225: LD_VAR 0 5
74229: PUSH
74230: LD_INT 5
74232: GREATEREQUAL
74233: IFFALSE 74237
// break ;
74235: GO 74239
// end ;
74237: GO 74206
74239: POP
74240: POP
// end ; if not tmp then
74241: LD_VAR 0 5
74245: NOT
74246: IFFALSE 74250
// continue ;
74248: GO 73403
// for j in tmp do
74250: LD_ADDR_VAR 0 3
74254: PUSH
74255: LD_VAR 0 5
74259: PUSH
74260: FOR_IN
74261: IFFALSE 74351
// if not GetTag ( j ) then
74263: LD_VAR 0 3
74267: PPUSH
74268: CALL_OW 110
74272: NOT
74273: IFFALSE 74349
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
74275: LD_ADDR_EXP 80
74279: PUSH
74280: LD_EXP 80
74284: PPUSH
74285: LD_VAR 0 2
74289: PUSH
74290: LD_EXP 80
74294: PUSH
74295: LD_VAR 0 2
74299: ARRAY
74300: PUSH
74301: LD_INT 1
74303: PLUS
74304: PUSH
74305: EMPTY
74306: LIST
74307: LIST
74308: PPUSH
74309: LD_VAR 0 3
74313: PPUSH
74314: CALL 22238 0 3
74318: ST_TO_ADDR
// SetTag ( j , 107 ) ;
74319: LD_VAR 0 3
74323: PPUSH
74324: LD_INT 107
74326: PPUSH
74327: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
74331: LD_EXP 80
74335: PUSH
74336: LD_VAR 0 2
74340: ARRAY
74341: PUSH
74342: LD_INT 5
74344: GREATEREQUAL
74345: IFFALSE 74349
// break ;
74347: GO 74351
// end ;
74349: GO 74260
74351: POP
74352: POP
// end ; if mc_crates_collector [ i ] and target then
74353: LD_EXP 80
74357: PUSH
74358: LD_VAR 0 2
74362: ARRAY
74363: PUSH
74364: LD_VAR 0 7
74368: AND
74369: IFFALSE 74675
// begin if mc_crates_collector [ i ] < target [ 1 ] then
74371: LD_EXP 80
74375: PUSH
74376: LD_VAR 0 2
74380: ARRAY
74381: PUSH
74382: LD_VAR 0 7
74386: PUSH
74387: LD_INT 1
74389: ARRAY
74390: LESS
74391: IFFALSE 74411
// tmp := mc_crates_collector [ i ] else
74393: LD_ADDR_VAR 0 5
74397: PUSH
74398: LD_EXP 80
74402: PUSH
74403: LD_VAR 0 2
74407: ARRAY
74408: ST_TO_ADDR
74409: GO 74425
// tmp := target [ 1 ] ;
74411: LD_ADDR_VAR 0 5
74415: PUSH
74416: LD_VAR 0 7
74420: PUSH
74421: LD_INT 1
74423: ARRAY
74424: ST_TO_ADDR
// k := 0 ;
74425: LD_ADDR_VAR 0 4
74429: PUSH
74430: LD_INT 0
74432: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
74433: LD_ADDR_VAR 0 3
74437: PUSH
74438: LD_EXP 80
74442: PUSH
74443: LD_VAR 0 2
74447: ARRAY
74448: PUSH
74449: FOR_IN
74450: IFFALSE 74673
// begin k := k + 1 ;
74452: LD_ADDR_VAR 0 4
74456: PUSH
74457: LD_VAR 0 4
74461: PUSH
74462: LD_INT 1
74464: PLUS
74465: ST_TO_ADDR
// if k > tmp then
74466: LD_VAR 0 4
74470: PUSH
74471: LD_VAR 0 5
74475: GREATER
74476: IFFALSE 74480
// break ;
74478: GO 74673
// if not GetClass ( j ) in [ 2 , 16 ] then
74480: LD_VAR 0 3
74484: PPUSH
74485: CALL_OW 257
74489: PUSH
74490: LD_INT 2
74492: PUSH
74493: LD_INT 16
74495: PUSH
74496: EMPTY
74497: LIST
74498: LIST
74499: IN
74500: NOT
74501: IFFALSE 74554
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
74503: LD_ADDR_EXP 80
74507: PUSH
74508: LD_EXP 80
74512: PPUSH
74513: LD_VAR 0 2
74517: PPUSH
74518: LD_EXP 80
74522: PUSH
74523: LD_VAR 0 2
74527: ARRAY
74528: PUSH
74529: LD_VAR 0 3
74533: DIFF
74534: PPUSH
74535: CALL_OW 1
74539: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74540: LD_VAR 0 3
74544: PPUSH
74545: LD_INT 0
74547: PPUSH
74548: CALL_OW 109
// continue ;
74552: GO 74449
// end ; if IsInUnit ( j ) then
74554: LD_VAR 0 3
74558: PPUSH
74559: CALL_OW 310
74563: IFFALSE 74574
// ComExitBuilding ( j ) ;
74565: LD_VAR 0 3
74569: PPUSH
74570: CALL_OW 122
// wait ( 3 ) ;
74574: LD_INT 3
74576: PPUSH
74577: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
74581: LD_VAR 0 3
74585: PPUSH
74586: CALL_OW 314
74590: PUSH
74591: LD_VAR 0 6
74595: PPUSH
74596: LD_VAR 0 7
74600: PUSH
74601: LD_INT 2
74603: ARRAY
74604: PPUSH
74605: LD_VAR 0 7
74609: PUSH
74610: LD_INT 3
74612: ARRAY
74613: PPUSH
74614: LD_INT 30
74616: PPUSH
74617: CALL 23502 0 4
74621: PUSH
74622: LD_INT 4
74624: ARRAY
74625: AND
74626: IFFALSE 74644
// ComStandNearbyBuilding ( j , depot ) else
74628: LD_VAR 0 3
74632: PPUSH
74633: LD_VAR 0 9
74637: PPUSH
74638: CALL 18840 0 2
74642: GO 74671
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
74644: LD_VAR 0 3
74648: PPUSH
74649: LD_VAR 0 7
74653: PUSH
74654: LD_INT 2
74656: ARRAY
74657: PPUSH
74658: LD_VAR 0 7
74662: PUSH
74663: LD_INT 3
74665: ARRAY
74666: PPUSH
74667: CALL_OW 117
// end ;
74671: GO 74449
74673: POP
74674: POP
// end ; end else
74675: GO 75207
// begin for j in cargo do
74677: LD_ADDR_VAR 0 3
74681: PUSH
74682: LD_VAR 0 8
74686: PUSH
74687: FOR_IN
74688: IFFALSE 75205
// begin if GetTag ( j ) <> 0 then
74690: LD_VAR 0 3
74694: PPUSH
74695: CALL_OW 110
74699: PUSH
74700: LD_INT 0
74702: NONEQUAL
74703: IFFALSE 74707
// continue ;
74705: GO 74687
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
74707: LD_VAR 0 3
74711: PPUSH
74712: CALL_OW 256
74716: PUSH
74717: LD_INT 1000
74719: LESS
74720: PUSH
74721: LD_VAR 0 3
74725: PPUSH
74726: LD_EXP 87
74730: PUSH
74731: LD_VAR 0 2
74735: ARRAY
74736: PPUSH
74737: CALL_OW 308
74741: NOT
74742: AND
74743: IFFALSE 74765
// ComMoveToArea ( j , mc_parking [ i ] ) ;
74745: LD_VAR 0 3
74749: PPUSH
74750: LD_EXP 87
74754: PUSH
74755: LD_VAR 0 2
74759: ARRAY
74760: PPUSH
74761: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
74765: LD_VAR 0 3
74769: PPUSH
74770: CALL_OW 256
74774: PUSH
74775: LD_INT 1000
74777: LESS
74778: PUSH
74779: LD_VAR 0 3
74783: PPUSH
74784: LD_EXP 87
74788: PUSH
74789: LD_VAR 0 2
74793: ARRAY
74794: PPUSH
74795: CALL_OW 308
74799: AND
74800: IFFALSE 74804
// continue ;
74802: GO 74687
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
74804: LD_VAR 0 3
74808: PPUSH
74809: CALL_OW 262
74813: PUSH
74814: LD_INT 2
74816: EQUAL
74817: PUSH
74818: LD_VAR 0 3
74822: PPUSH
74823: CALL_OW 261
74827: PUSH
74828: LD_INT 15
74830: LESS
74831: AND
74832: IFFALSE 74836
// continue ;
74834: GO 74687
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
74836: LD_VAR 0 3
74840: PPUSH
74841: CALL_OW 262
74845: PUSH
74846: LD_INT 1
74848: EQUAL
74849: PUSH
74850: LD_VAR 0 3
74854: PPUSH
74855: CALL_OW 261
74859: PUSH
74860: LD_INT 10
74862: LESS
74863: AND
74864: IFFALSE 75144
// begin if not depot then
74866: LD_VAR 0 9
74870: NOT
74871: IFFALSE 74875
// continue ;
74873: GO 74687
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
74875: LD_VAR 0 3
74879: PPUSH
74880: LD_VAR 0 9
74884: PPUSH
74885: LD_VAR 0 3
74889: PPUSH
74890: CALL_OW 74
74894: PPUSH
74895: CALL_OW 296
74899: PUSH
74900: LD_INT 6
74902: LESS
74903: IFFALSE 74919
// SetFuel ( j , 100 ) else
74905: LD_VAR 0 3
74909: PPUSH
74910: LD_INT 100
74912: PPUSH
74913: CALL_OW 240
74917: GO 75144
// if GetFuel ( j ) = 0 then
74919: LD_VAR 0 3
74923: PPUSH
74924: CALL_OW 261
74928: PUSH
74929: LD_INT 0
74931: EQUAL
74932: IFFALSE 75144
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
74934: LD_ADDR_EXP 82
74938: PUSH
74939: LD_EXP 82
74943: PPUSH
74944: LD_VAR 0 2
74948: PPUSH
74949: LD_EXP 82
74953: PUSH
74954: LD_VAR 0 2
74958: ARRAY
74959: PUSH
74960: LD_VAR 0 3
74964: DIFF
74965: PPUSH
74966: CALL_OW 1
74970: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
74971: LD_VAR 0 3
74975: PPUSH
74976: CALL_OW 263
74980: PUSH
74981: LD_INT 1
74983: EQUAL
74984: IFFALSE 75000
// ComExitVehicle ( IsInUnit ( j ) ) ;
74986: LD_VAR 0 3
74990: PPUSH
74991: CALL_OW 310
74995: PPUSH
74996: CALL_OW 121
// if GetControl ( j ) = control_remote then
75000: LD_VAR 0 3
75004: PPUSH
75005: CALL_OW 263
75009: PUSH
75010: LD_INT 2
75012: EQUAL
75013: IFFALSE 75024
// ComUnlink ( j ) ;
75015: LD_VAR 0 3
75019: PPUSH
75020: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
75024: LD_ADDR_VAR 0 10
75028: PUSH
75029: LD_VAR 0 2
75033: PPUSH
75034: LD_INT 3
75036: PPUSH
75037: CALL 84788 0 2
75041: ST_TO_ADDR
// if fac then
75042: LD_VAR 0 10
75046: IFFALSE 75142
// begin for k in fac do
75048: LD_ADDR_VAR 0 4
75052: PUSH
75053: LD_VAR 0 10
75057: PUSH
75058: FOR_IN
75059: IFFALSE 75140
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
75061: LD_ADDR_VAR 0 11
75065: PUSH
75066: LD_VAR 0 10
75070: PPUSH
75071: LD_VAR 0 3
75075: PPUSH
75076: CALL_OW 265
75080: PPUSH
75081: LD_VAR 0 3
75085: PPUSH
75086: CALL_OW 262
75090: PPUSH
75091: LD_VAR 0 3
75095: PPUSH
75096: CALL_OW 263
75100: PPUSH
75101: LD_VAR 0 3
75105: PPUSH
75106: CALL_OW 264
75110: PPUSH
75111: CALL 19736 0 5
75115: ST_TO_ADDR
// if components then
75116: LD_VAR 0 11
75120: IFFALSE 75138
// begin MC_InsertProduceList ( i , components ) ;
75122: LD_VAR 0 2
75126: PPUSH
75127: LD_VAR 0 11
75131: PPUSH
75132: CALL 84333 0 2
// break ;
75136: GO 75140
// end ; end ;
75138: GO 75058
75140: POP
75141: POP
// end ; continue ;
75142: GO 74687
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
75144: LD_VAR 0 3
75148: PPUSH
75149: LD_INT 1
75151: PPUSH
75152: CALL_OW 289
75156: PUSH
75157: LD_INT 100
75159: LESS
75160: PUSH
75161: LD_VAR 0 3
75165: PPUSH
75166: CALL_OW 314
75170: NOT
75171: AND
75172: IFFALSE 75201
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
75174: LD_VAR 0 3
75178: PPUSH
75179: LD_VAR 0 7
75183: PUSH
75184: LD_INT 2
75186: ARRAY
75187: PPUSH
75188: LD_VAR 0 7
75192: PUSH
75193: LD_INT 3
75195: ARRAY
75196: PPUSH
75197: CALL_OW 117
// break ;
75201: GO 75205
// end ;
75203: GO 74687
75205: POP
75206: POP
// end ; end ;
75207: GO 73403
75209: POP
75210: POP
// end ;
75211: LD_VAR 0 1
75215: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
75216: LD_INT 0
75218: PPUSH
75219: PPUSH
75220: PPUSH
75221: PPUSH
// if not mc_bases then
75222: LD_EXP 63
75226: NOT
75227: IFFALSE 75231
// exit ;
75229: GO 75392
// for i = 1 to mc_bases do
75231: LD_ADDR_VAR 0 2
75235: PUSH
75236: DOUBLE
75237: LD_INT 1
75239: DEC
75240: ST_TO_ADDR
75241: LD_EXP 63
75245: PUSH
75246: FOR_TO
75247: IFFALSE 75390
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
75249: LD_ADDR_VAR 0 4
75253: PUSH
75254: LD_EXP 82
75258: PUSH
75259: LD_VAR 0 2
75263: ARRAY
75264: PUSH
75265: LD_EXP 85
75269: PUSH
75270: LD_VAR 0 2
75274: ARRAY
75275: UNION
75276: PPUSH
75277: LD_INT 33
75279: PUSH
75280: LD_INT 2
75282: PUSH
75283: EMPTY
75284: LIST
75285: LIST
75286: PPUSH
75287: CALL_OW 72
75291: ST_TO_ADDR
// if tmp then
75292: LD_VAR 0 4
75296: IFFALSE 75388
// for j in tmp do
75298: LD_ADDR_VAR 0 3
75302: PUSH
75303: LD_VAR 0 4
75307: PUSH
75308: FOR_IN
75309: IFFALSE 75386
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
75311: LD_VAR 0 3
75315: PPUSH
75316: CALL_OW 312
75320: NOT
75321: PUSH
75322: LD_VAR 0 3
75326: PPUSH
75327: CALL_OW 256
75331: PUSH
75332: LD_INT 250
75334: GREATEREQUAL
75335: AND
75336: IFFALSE 75349
// Connect ( j ) else
75338: LD_VAR 0 3
75342: PPUSH
75343: CALL 25584 0 1
75347: GO 75384
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
75349: LD_VAR 0 3
75353: PPUSH
75354: CALL_OW 256
75358: PUSH
75359: LD_INT 250
75361: LESS
75362: PUSH
75363: LD_VAR 0 3
75367: PPUSH
75368: CALL_OW 312
75372: AND
75373: IFFALSE 75384
// ComUnlink ( j ) ;
75375: LD_VAR 0 3
75379: PPUSH
75380: CALL_OW 136
75384: GO 75308
75386: POP
75387: POP
// end ;
75388: GO 75246
75390: POP
75391: POP
// end ;
75392: LD_VAR 0 1
75396: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
75397: LD_INT 0
75399: PPUSH
75400: PPUSH
75401: PPUSH
75402: PPUSH
75403: PPUSH
// if not mc_bases then
75404: LD_EXP 63
75408: NOT
75409: IFFALSE 75413
// exit ;
75411: GO 75858
// for i = 1 to mc_bases do
75413: LD_ADDR_VAR 0 2
75417: PUSH
75418: DOUBLE
75419: LD_INT 1
75421: DEC
75422: ST_TO_ADDR
75423: LD_EXP 63
75427: PUSH
75428: FOR_TO
75429: IFFALSE 75856
// begin if not mc_produce [ i ] then
75431: LD_EXP 84
75435: PUSH
75436: LD_VAR 0 2
75440: ARRAY
75441: NOT
75442: IFFALSE 75446
// continue ;
75444: GO 75428
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75446: LD_ADDR_VAR 0 5
75450: PUSH
75451: LD_EXP 63
75455: PUSH
75456: LD_VAR 0 2
75460: ARRAY
75461: PPUSH
75462: LD_INT 30
75464: PUSH
75465: LD_INT 3
75467: PUSH
75468: EMPTY
75469: LIST
75470: LIST
75471: PPUSH
75472: CALL_OW 72
75476: ST_TO_ADDR
// if not fac then
75477: LD_VAR 0 5
75481: NOT
75482: IFFALSE 75486
// continue ;
75484: GO 75428
// for j in fac do
75486: LD_ADDR_VAR 0 3
75490: PUSH
75491: LD_VAR 0 5
75495: PUSH
75496: FOR_IN
75497: IFFALSE 75852
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
75499: LD_VAR 0 3
75503: PPUSH
75504: CALL_OW 461
75508: PUSH
75509: LD_INT 2
75511: NONEQUAL
75512: PUSH
75513: LD_VAR 0 3
75517: PPUSH
75518: LD_INT 15
75520: PPUSH
75521: CALL 25203 0 2
75525: PUSH
75526: LD_INT 4
75528: ARRAY
75529: OR
75530: IFFALSE 75534
// continue ;
75532: GO 75496
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
75534: LD_VAR 0 3
75538: PPUSH
75539: LD_EXP 84
75543: PUSH
75544: LD_VAR 0 2
75548: ARRAY
75549: PUSH
75550: LD_INT 1
75552: ARRAY
75553: PUSH
75554: LD_INT 1
75556: ARRAY
75557: PPUSH
75558: LD_EXP 84
75562: PUSH
75563: LD_VAR 0 2
75567: ARRAY
75568: PUSH
75569: LD_INT 1
75571: ARRAY
75572: PUSH
75573: LD_INT 2
75575: ARRAY
75576: PPUSH
75577: LD_EXP 84
75581: PUSH
75582: LD_VAR 0 2
75586: ARRAY
75587: PUSH
75588: LD_INT 1
75590: ARRAY
75591: PUSH
75592: LD_INT 3
75594: ARRAY
75595: PPUSH
75596: LD_EXP 84
75600: PUSH
75601: LD_VAR 0 2
75605: ARRAY
75606: PUSH
75607: LD_INT 1
75609: ARRAY
75610: PUSH
75611: LD_INT 4
75613: ARRAY
75614: PPUSH
75615: CALL_OW 448
75619: PUSH
75620: LD_VAR 0 3
75624: PPUSH
75625: LD_EXP 84
75629: PUSH
75630: LD_VAR 0 2
75634: ARRAY
75635: PUSH
75636: LD_INT 1
75638: ARRAY
75639: PUSH
75640: LD_INT 1
75642: ARRAY
75643: PUSH
75644: LD_EXP 84
75648: PUSH
75649: LD_VAR 0 2
75653: ARRAY
75654: PUSH
75655: LD_INT 1
75657: ARRAY
75658: PUSH
75659: LD_INT 2
75661: ARRAY
75662: PUSH
75663: LD_EXP 84
75667: PUSH
75668: LD_VAR 0 2
75672: ARRAY
75673: PUSH
75674: LD_INT 1
75676: ARRAY
75677: PUSH
75678: LD_INT 3
75680: ARRAY
75681: PUSH
75682: LD_EXP 84
75686: PUSH
75687: LD_VAR 0 2
75691: ARRAY
75692: PUSH
75693: LD_INT 1
75695: ARRAY
75696: PUSH
75697: LD_INT 4
75699: ARRAY
75700: PUSH
75701: EMPTY
75702: LIST
75703: LIST
75704: LIST
75705: LIST
75706: PPUSH
75707: CALL 28979 0 2
75711: AND
75712: IFFALSE 75850
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
75714: LD_VAR 0 3
75718: PPUSH
75719: LD_EXP 84
75723: PUSH
75724: LD_VAR 0 2
75728: ARRAY
75729: PUSH
75730: LD_INT 1
75732: ARRAY
75733: PUSH
75734: LD_INT 1
75736: ARRAY
75737: PPUSH
75738: LD_EXP 84
75742: PUSH
75743: LD_VAR 0 2
75747: ARRAY
75748: PUSH
75749: LD_INT 1
75751: ARRAY
75752: PUSH
75753: LD_INT 2
75755: ARRAY
75756: PPUSH
75757: LD_EXP 84
75761: PUSH
75762: LD_VAR 0 2
75766: ARRAY
75767: PUSH
75768: LD_INT 1
75770: ARRAY
75771: PUSH
75772: LD_INT 3
75774: ARRAY
75775: PPUSH
75776: LD_EXP 84
75780: PUSH
75781: LD_VAR 0 2
75785: ARRAY
75786: PUSH
75787: LD_INT 1
75789: ARRAY
75790: PUSH
75791: LD_INT 4
75793: ARRAY
75794: PPUSH
75795: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
75799: LD_ADDR_VAR 0 4
75803: PUSH
75804: LD_EXP 84
75808: PUSH
75809: LD_VAR 0 2
75813: ARRAY
75814: PPUSH
75815: LD_INT 1
75817: PPUSH
75818: CALL_OW 3
75822: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
75823: LD_ADDR_EXP 84
75827: PUSH
75828: LD_EXP 84
75832: PPUSH
75833: LD_VAR 0 2
75837: PPUSH
75838: LD_VAR 0 4
75842: PPUSH
75843: CALL_OW 1
75847: ST_TO_ADDR
// break ;
75848: GO 75852
// end ; end ;
75850: GO 75496
75852: POP
75853: POP
// end ;
75854: GO 75428
75856: POP
75857: POP
// end ;
75858: LD_VAR 0 1
75862: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
75863: LD_INT 0
75865: PPUSH
75866: PPUSH
75867: PPUSH
// if not mc_bases then
75868: LD_EXP 63
75872: NOT
75873: IFFALSE 75877
// exit ;
75875: GO 75966
// for i = 1 to mc_bases do
75877: LD_ADDR_VAR 0 2
75881: PUSH
75882: DOUBLE
75883: LD_INT 1
75885: DEC
75886: ST_TO_ADDR
75887: LD_EXP 63
75891: PUSH
75892: FOR_TO
75893: IFFALSE 75964
// begin if mc_attack [ i ] then
75895: LD_EXP 83
75899: PUSH
75900: LD_VAR 0 2
75904: ARRAY
75905: IFFALSE 75962
// begin tmp := mc_attack [ i ] [ 1 ] ;
75907: LD_ADDR_VAR 0 3
75911: PUSH
75912: LD_EXP 83
75916: PUSH
75917: LD_VAR 0 2
75921: ARRAY
75922: PUSH
75923: LD_INT 1
75925: ARRAY
75926: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
75927: LD_ADDR_EXP 83
75931: PUSH
75932: LD_EXP 83
75936: PPUSH
75937: LD_VAR 0 2
75941: PPUSH
75942: EMPTY
75943: PPUSH
75944: CALL_OW 1
75948: ST_TO_ADDR
// Attack ( tmp ) ;
75949: LD_VAR 0 3
75953: PPUSH
75954: CALL 111545 0 1
// exit ;
75958: POP
75959: POP
75960: GO 75966
// end ; end ;
75962: GO 75892
75964: POP
75965: POP
// end ;
75966: LD_VAR 0 1
75970: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
75971: LD_INT 0
75973: PPUSH
75974: PPUSH
75975: PPUSH
75976: PPUSH
75977: PPUSH
75978: PPUSH
75979: PPUSH
// if not mc_bases then
75980: LD_EXP 63
75984: NOT
75985: IFFALSE 75989
// exit ;
75987: GO 76846
// for i = 1 to mc_bases do
75989: LD_ADDR_VAR 0 2
75993: PUSH
75994: DOUBLE
75995: LD_INT 1
75997: DEC
75998: ST_TO_ADDR
75999: LD_EXP 63
76003: PUSH
76004: FOR_TO
76005: IFFALSE 76844
// begin if not mc_bases [ i ] then
76007: LD_EXP 63
76011: PUSH
76012: LD_VAR 0 2
76016: ARRAY
76017: NOT
76018: IFFALSE 76022
// continue ;
76020: GO 76004
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
76022: LD_ADDR_VAR 0 7
76026: PUSH
76027: LD_EXP 63
76031: PUSH
76032: LD_VAR 0 2
76036: ARRAY
76037: PUSH
76038: LD_INT 1
76040: ARRAY
76041: PPUSH
76042: CALL 19062 0 1
76046: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
76047: LD_ADDR_EXP 86
76051: PUSH
76052: LD_EXP 86
76056: PPUSH
76057: LD_VAR 0 2
76061: PPUSH
76062: LD_EXP 63
76066: PUSH
76067: LD_VAR 0 2
76071: ARRAY
76072: PUSH
76073: LD_INT 1
76075: ARRAY
76076: PPUSH
76077: CALL_OW 255
76081: PPUSH
76082: LD_EXP 88
76086: PUSH
76087: LD_VAR 0 2
76091: ARRAY
76092: PPUSH
76093: CALL 19027 0 2
76097: PPUSH
76098: CALL_OW 1
76102: ST_TO_ADDR
// if not mc_scan [ i ] then
76103: LD_EXP 86
76107: PUSH
76108: LD_VAR 0 2
76112: ARRAY
76113: NOT
76114: IFFALSE 76292
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
76116: LD_ADDR_EXP 106
76120: PUSH
76121: LD_EXP 106
76125: PPUSH
76126: LD_VAR 0 2
76130: PPUSH
76131: LD_INT 0
76133: PPUSH
76134: CALL_OW 1
76138: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
76139: LD_ADDR_VAR 0 4
76143: PUSH
76144: LD_EXP 63
76148: PUSH
76149: LD_VAR 0 2
76153: ARRAY
76154: PPUSH
76155: LD_INT 2
76157: PUSH
76158: LD_INT 25
76160: PUSH
76161: LD_INT 5
76163: PUSH
76164: EMPTY
76165: LIST
76166: LIST
76167: PUSH
76168: LD_INT 25
76170: PUSH
76171: LD_INT 8
76173: PUSH
76174: EMPTY
76175: LIST
76176: LIST
76177: PUSH
76178: LD_INT 25
76180: PUSH
76181: LD_INT 9
76183: PUSH
76184: EMPTY
76185: LIST
76186: LIST
76187: PUSH
76188: EMPTY
76189: LIST
76190: LIST
76191: LIST
76192: LIST
76193: PPUSH
76194: CALL_OW 72
76198: ST_TO_ADDR
// if not tmp then
76199: LD_VAR 0 4
76203: NOT
76204: IFFALSE 76208
// continue ;
76206: GO 76004
// for j in tmp do
76208: LD_ADDR_VAR 0 3
76212: PUSH
76213: LD_VAR 0 4
76217: PUSH
76218: FOR_IN
76219: IFFALSE 76290
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
76221: LD_VAR 0 3
76225: PPUSH
76226: CALL_OW 310
76230: PPUSH
76231: CALL_OW 266
76235: PUSH
76236: LD_INT 5
76238: EQUAL
76239: PUSH
76240: LD_VAR 0 3
76244: PPUSH
76245: CALL_OW 257
76249: PUSH
76250: LD_INT 1
76252: EQUAL
76253: AND
76254: PUSH
76255: LD_VAR 0 3
76259: PPUSH
76260: CALL_OW 459
76264: NOT
76265: AND
76266: PUSH
76267: LD_VAR 0 7
76271: AND
76272: IFFALSE 76288
// ComChangeProfession ( j , class ) ;
76274: LD_VAR 0 3
76278: PPUSH
76279: LD_VAR 0 7
76283: PPUSH
76284: CALL_OW 123
76288: GO 76218
76290: POP
76291: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
76292: LD_EXP 86
76296: PUSH
76297: LD_VAR 0 2
76301: ARRAY
76302: PUSH
76303: LD_EXP 106
76307: PUSH
76308: LD_VAR 0 2
76312: ARRAY
76313: NOT
76314: AND
76315: PUSH
76316: LD_EXP 85
76320: PUSH
76321: LD_VAR 0 2
76325: ARRAY
76326: NOT
76327: AND
76328: PUSH
76329: LD_EXP 63
76333: PUSH
76334: LD_VAR 0 2
76338: ARRAY
76339: PPUSH
76340: LD_INT 50
76342: PUSH
76343: EMPTY
76344: LIST
76345: PUSH
76346: LD_INT 2
76348: PUSH
76349: LD_INT 30
76351: PUSH
76352: LD_INT 32
76354: PUSH
76355: EMPTY
76356: LIST
76357: LIST
76358: PUSH
76359: LD_INT 30
76361: PUSH
76362: LD_INT 33
76364: PUSH
76365: EMPTY
76366: LIST
76367: LIST
76368: PUSH
76369: LD_INT 30
76371: PUSH
76372: LD_INT 4
76374: PUSH
76375: EMPTY
76376: LIST
76377: LIST
76378: PUSH
76379: LD_INT 30
76381: PUSH
76382: LD_INT 5
76384: PUSH
76385: EMPTY
76386: LIST
76387: LIST
76388: PUSH
76389: EMPTY
76390: LIST
76391: LIST
76392: LIST
76393: LIST
76394: LIST
76395: PUSH
76396: EMPTY
76397: LIST
76398: LIST
76399: PPUSH
76400: CALL_OW 72
76404: PUSH
76405: LD_INT 4
76407: LESS
76408: PUSH
76409: LD_EXP 63
76413: PUSH
76414: LD_VAR 0 2
76418: ARRAY
76419: PPUSH
76420: LD_INT 3
76422: PUSH
76423: LD_INT 24
76425: PUSH
76426: LD_INT 1000
76428: PUSH
76429: EMPTY
76430: LIST
76431: LIST
76432: PUSH
76433: EMPTY
76434: LIST
76435: LIST
76436: PUSH
76437: LD_INT 2
76439: PUSH
76440: LD_INT 30
76442: PUSH
76443: LD_INT 0
76445: PUSH
76446: EMPTY
76447: LIST
76448: LIST
76449: PUSH
76450: LD_INT 30
76452: PUSH
76453: LD_INT 1
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: EMPTY
76461: LIST
76462: LIST
76463: LIST
76464: PUSH
76465: EMPTY
76466: LIST
76467: LIST
76468: PPUSH
76469: CALL_OW 72
76473: OR
76474: AND
76475: IFFALSE 76726
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
76477: LD_ADDR_EXP 106
76481: PUSH
76482: LD_EXP 106
76486: PPUSH
76487: LD_VAR 0 2
76491: PPUSH
76492: LD_INT 1
76494: PPUSH
76495: CALL_OW 1
76499: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
76500: LD_ADDR_VAR 0 4
76504: PUSH
76505: LD_EXP 63
76509: PUSH
76510: LD_VAR 0 2
76514: ARRAY
76515: PPUSH
76516: LD_INT 2
76518: PUSH
76519: LD_INT 25
76521: PUSH
76522: LD_INT 1
76524: PUSH
76525: EMPTY
76526: LIST
76527: LIST
76528: PUSH
76529: LD_INT 25
76531: PUSH
76532: LD_INT 5
76534: PUSH
76535: EMPTY
76536: LIST
76537: LIST
76538: PUSH
76539: LD_INT 25
76541: PUSH
76542: LD_INT 8
76544: PUSH
76545: EMPTY
76546: LIST
76547: LIST
76548: PUSH
76549: LD_INT 25
76551: PUSH
76552: LD_INT 9
76554: PUSH
76555: EMPTY
76556: LIST
76557: LIST
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: LIST
76563: LIST
76564: LIST
76565: PPUSH
76566: CALL_OW 72
76570: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
76571: LD_ADDR_VAR 0 4
76575: PUSH
76576: LD_VAR 0 4
76580: PUSH
76581: LD_VAR 0 4
76585: PPUSH
76586: LD_INT 18
76588: PPUSH
76589: CALL 52536 0 2
76593: DIFF
76594: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
76595: LD_VAR 0 4
76599: NOT
76600: PUSH
76601: LD_EXP 63
76605: PUSH
76606: LD_VAR 0 2
76610: ARRAY
76611: PPUSH
76612: LD_INT 2
76614: PUSH
76615: LD_INT 30
76617: PUSH
76618: LD_INT 4
76620: PUSH
76621: EMPTY
76622: LIST
76623: LIST
76624: PUSH
76625: LD_INT 30
76627: PUSH
76628: LD_INT 5
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: PUSH
76635: EMPTY
76636: LIST
76637: LIST
76638: LIST
76639: PPUSH
76640: CALL_OW 72
76644: NOT
76645: AND
76646: IFFALSE 76708
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
76648: LD_ADDR_VAR 0 4
76652: PUSH
76653: LD_EXP 63
76657: PUSH
76658: LD_VAR 0 2
76662: ARRAY
76663: PPUSH
76664: LD_INT 2
76666: PUSH
76667: LD_INT 25
76669: PUSH
76670: LD_INT 2
76672: PUSH
76673: EMPTY
76674: LIST
76675: LIST
76676: PUSH
76677: LD_INT 25
76679: PUSH
76680: LD_INT 3
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: PUSH
76687: LD_INT 25
76689: PUSH
76690: LD_INT 4
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: EMPTY
76698: LIST
76699: LIST
76700: LIST
76701: LIST
76702: PPUSH
76703: CALL_OW 72
76707: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
76708: LD_VAR 0 2
76712: PPUSH
76713: LD_VAR 0 4
76717: PPUSH
76718: CALL 116254 0 2
// exit ;
76722: POP
76723: POP
76724: GO 76846
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
76726: LD_EXP 86
76730: PUSH
76731: LD_VAR 0 2
76735: ARRAY
76736: PUSH
76737: LD_EXP 106
76741: PUSH
76742: LD_VAR 0 2
76746: ARRAY
76747: NOT
76748: AND
76749: PUSH
76750: LD_EXP 85
76754: PUSH
76755: LD_VAR 0 2
76759: ARRAY
76760: AND
76761: IFFALSE 76842
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
76763: LD_ADDR_EXP 106
76767: PUSH
76768: LD_EXP 106
76772: PPUSH
76773: LD_VAR 0 2
76777: PPUSH
76778: LD_INT 1
76780: PPUSH
76781: CALL_OW 1
76785: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
76786: LD_ADDR_VAR 0 4
76790: PUSH
76791: LD_EXP 85
76795: PUSH
76796: LD_VAR 0 2
76800: ARRAY
76801: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
76802: LD_ADDR_EXP 85
76806: PUSH
76807: LD_EXP 85
76811: PPUSH
76812: LD_VAR 0 2
76816: PPUSH
76817: EMPTY
76818: PPUSH
76819: CALL_OW 1
76823: ST_TO_ADDR
// Defend ( i , tmp ) ;
76824: LD_VAR 0 2
76828: PPUSH
76829: LD_VAR 0 4
76833: PPUSH
76834: CALL 116850 0 2
// exit ;
76838: POP
76839: POP
76840: GO 76846
// end ; end ;
76842: GO 76004
76844: POP
76845: POP
// end ;
76846: LD_VAR 0 1
76850: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
76851: LD_INT 0
76853: PPUSH
76854: PPUSH
76855: PPUSH
76856: PPUSH
76857: PPUSH
76858: PPUSH
76859: PPUSH
76860: PPUSH
76861: PPUSH
76862: PPUSH
76863: PPUSH
// if not mc_bases then
76864: LD_EXP 63
76868: NOT
76869: IFFALSE 76873
// exit ;
76871: GO 77960
// for i = 1 to mc_bases do
76873: LD_ADDR_VAR 0 2
76877: PUSH
76878: DOUBLE
76879: LD_INT 1
76881: DEC
76882: ST_TO_ADDR
76883: LD_EXP 63
76887: PUSH
76888: FOR_TO
76889: IFFALSE 77958
// begin tmp := mc_lab [ i ] ;
76891: LD_ADDR_VAR 0 6
76895: PUSH
76896: LD_EXP 96
76900: PUSH
76901: LD_VAR 0 2
76905: ARRAY
76906: ST_TO_ADDR
// if not tmp then
76907: LD_VAR 0 6
76911: NOT
76912: IFFALSE 76916
// continue ;
76914: GO 76888
// idle_lab := 0 ;
76916: LD_ADDR_VAR 0 11
76920: PUSH
76921: LD_INT 0
76923: ST_TO_ADDR
// for j in tmp do
76924: LD_ADDR_VAR 0 3
76928: PUSH
76929: LD_VAR 0 6
76933: PUSH
76934: FOR_IN
76935: IFFALSE 77954
// begin researching := false ;
76937: LD_ADDR_VAR 0 10
76941: PUSH
76942: LD_INT 0
76944: ST_TO_ADDR
// side := GetSide ( j ) ;
76945: LD_ADDR_VAR 0 4
76949: PUSH
76950: LD_VAR 0 3
76954: PPUSH
76955: CALL_OW 255
76959: ST_TO_ADDR
// if not mc_tech [ side ] then
76960: LD_EXP 90
76964: PUSH
76965: LD_VAR 0 4
76969: ARRAY
76970: NOT
76971: IFFALSE 76975
// continue ;
76973: GO 76934
// if BuildingStatus ( j ) = bs_idle then
76975: LD_VAR 0 3
76979: PPUSH
76980: CALL_OW 461
76984: PUSH
76985: LD_INT 2
76987: EQUAL
76988: IFFALSE 77176
// begin if idle_lab and UnitsInside ( j ) < 6 then
76990: LD_VAR 0 11
76994: PUSH
76995: LD_VAR 0 3
76999: PPUSH
77000: CALL_OW 313
77004: PUSH
77005: LD_INT 6
77007: LESS
77008: AND
77009: IFFALSE 77080
// begin tmp2 := UnitsInside ( idle_lab ) ;
77011: LD_ADDR_VAR 0 9
77015: PUSH
77016: LD_VAR 0 11
77020: PPUSH
77021: CALL_OW 313
77025: ST_TO_ADDR
// if tmp2 then
77026: LD_VAR 0 9
77030: IFFALSE 77072
// for x in tmp2 do
77032: LD_ADDR_VAR 0 7
77036: PUSH
77037: LD_VAR 0 9
77041: PUSH
77042: FOR_IN
77043: IFFALSE 77070
// begin ComExitBuilding ( x ) ;
77045: LD_VAR 0 7
77049: PPUSH
77050: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
77054: LD_VAR 0 7
77058: PPUSH
77059: LD_VAR 0 3
77063: PPUSH
77064: CALL_OW 180
// end ;
77068: GO 77042
77070: POP
77071: POP
// idle_lab := 0 ;
77072: LD_ADDR_VAR 0 11
77076: PUSH
77077: LD_INT 0
77079: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
77080: LD_ADDR_VAR 0 5
77084: PUSH
77085: LD_EXP 90
77089: PUSH
77090: LD_VAR 0 4
77094: ARRAY
77095: PUSH
77096: FOR_IN
77097: IFFALSE 77157
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
77099: LD_VAR 0 3
77103: PPUSH
77104: LD_VAR 0 5
77108: PPUSH
77109: CALL_OW 430
77113: PUSH
77114: LD_VAR 0 4
77118: PPUSH
77119: LD_VAR 0 5
77123: PPUSH
77124: CALL 18132 0 2
77128: AND
77129: IFFALSE 77155
// begin researching := true ;
77131: LD_ADDR_VAR 0 10
77135: PUSH
77136: LD_INT 1
77138: ST_TO_ADDR
// ComResearch ( j , t ) ;
77139: LD_VAR 0 3
77143: PPUSH
77144: LD_VAR 0 5
77148: PPUSH
77149: CALL_OW 124
// break ;
77153: GO 77157
// end ;
77155: GO 77096
77157: POP
77158: POP
// if not researching then
77159: LD_VAR 0 10
77163: NOT
77164: IFFALSE 77176
// idle_lab := j ;
77166: LD_ADDR_VAR 0 11
77170: PUSH
77171: LD_VAR 0 3
77175: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
77176: LD_VAR 0 3
77180: PPUSH
77181: CALL_OW 461
77185: PUSH
77186: LD_INT 10
77188: EQUAL
77189: IFFALSE 77777
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
77191: LD_EXP 92
77195: PUSH
77196: LD_VAR 0 2
77200: ARRAY
77201: NOT
77202: PUSH
77203: LD_EXP 93
77207: PUSH
77208: LD_VAR 0 2
77212: ARRAY
77213: NOT
77214: AND
77215: PUSH
77216: LD_EXP 90
77220: PUSH
77221: LD_VAR 0 4
77225: ARRAY
77226: PUSH
77227: LD_INT 1
77229: GREATER
77230: AND
77231: IFFALSE 77362
// begin ComCancel ( j ) ;
77233: LD_VAR 0 3
77237: PPUSH
77238: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
77242: LD_ADDR_EXP 90
77246: PUSH
77247: LD_EXP 90
77251: PPUSH
77252: LD_VAR 0 4
77256: PPUSH
77257: LD_EXP 90
77261: PUSH
77262: LD_VAR 0 4
77266: ARRAY
77267: PPUSH
77268: LD_EXP 90
77272: PUSH
77273: LD_VAR 0 4
77277: ARRAY
77278: PUSH
77279: LD_INT 1
77281: MINUS
77282: PPUSH
77283: LD_EXP 90
77287: PUSH
77288: LD_VAR 0 4
77292: ARRAY
77293: PPUSH
77294: LD_INT 0
77296: PPUSH
77297: CALL 21656 0 4
77301: PPUSH
77302: CALL_OW 1
77306: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
77307: LD_ADDR_EXP 90
77311: PUSH
77312: LD_EXP 90
77316: PPUSH
77317: LD_VAR 0 4
77321: PPUSH
77322: LD_EXP 90
77326: PUSH
77327: LD_VAR 0 4
77331: ARRAY
77332: PPUSH
77333: LD_EXP 90
77337: PUSH
77338: LD_VAR 0 4
77342: ARRAY
77343: PPUSH
77344: LD_INT 1
77346: PPUSH
77347: LD_INT 0
77349: PPUSH
77350: CALL 21656 0 4
77354: PPUSH
77355: CALL_OW 1
77359: ST_TO_ADDR
// continue ;
77360: GO 76934
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
77362: LD_EXP 92
77366: PUSH
77367: LD_VAR 0 2
77371: ARRAY
77372: PUSH
77373: LD_EXP 93
77377: PUSH
77378: LD_VAR 0 2
77382: ARRAY
77383: NOT
77384: AND
77385: IFFALSE 77512
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
77387: LD_ADDR_EXP 93
77391: PUSH
77392: LD_EXP 93
77396: PPUSH
77397: LD_VAR 0 2
77401: PUSH
77402: LD_EXP 93
77406: PUSH
77407: LD_VAR 0 2
77411: ARRAY
77412: PUSH
77413: LD_INT 1
77415: PLUS
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: PPUSH
77421: LD_EXP 92
77425: PUSH
77426: LD_VAR 0 2
77430: ARRAY
77431: PUSH
77432: LD_INT 1
77434: ARRAY
77435: PPUSH
77436: CALL 22238 0 3
77440: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
77441: LD_EXP 92
77445: PUSH
77446: LD_VAR 0 2
77450: ARRAY
77451: PUSH
77452: LD_INT 1
77454: ARRAY
77455: PPUSH
77456: LD_INT 112
77458: PPUSH
77459: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
77463: LD_ADDR_VAR 0 9
77467: PUSH
77468: LD_EXP 92
77472: PUSH
77473: LD_VAR 0 2
77477: ARRAY
77478: PPUSH
77479: LD_INT 1
77481: PPUSH
77482: CALL_OW 3
77486: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
77487: LD_ADDR_EXP 92
77491: PUSH
77492: LD_EXP 92
77496: PPUSH
77497: LD_VAR 0 2
77501: PPUSH
77502: LD_VAR 0 9
77506: PPUSH
77507: CALL_OW 1
77511: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
77512: LD_EXP 92
77516: PUSH
77517: LD_VAR 0 2
77521: ARRAY
77522: PUSH
77523: LD_EXP 93
77527: PUSH
77528: LD_VAR 0 2
77532: ARRAY
77533: AND
77534: PUSH
77535: LD_EXP 93
77539: PUSH
77540: LD_VAR 0 2
77544: ARRAY
77545: PUSH
77546: LD_INT 1
77548: ARRAY
77549: PPUSH
77550: CALL_OW 310
77554: NOT
77555: AND
77556: PUSH
77557: LD_VAR 0 3
77561: PPUSH
77562: CALL_OW 313
77566: PUSH
77567: LD_INT 6
77569: EQUAL
77570: AND
77571: IFFALSE 77627
// begin tmp2 := UnitsInside ( j ) ;
77573: LD_ADDR_VAR 0 9
77577: PUSH
77578: LD_VAR 0 3
77582: PPUSH
77583: CALL_OW 313
77587: ST_TO_ADDR
// if tmp2 = 6 then
77588: LD_VAR 0 9
77592: PUSH
77593: LD_INT 6
77595: EQUAL
77596: IFFALSE 77627
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
77598: LD_VAR 0 9
77602: PUSH
77603: LD_INT 1
77605: ARRAY
77606: PPUSH
77607: LD_INT 112
77609: PPUSH
77610: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
77614: LD_VAR 0 9
77618: PUSH
77619: LD_INT 1
77621: ARRAY
77622: PPUSH
77623: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
77627: LD_EXP 93
77631: PUSH
77632: LD_VAR 0 2
77636: ARRAY
77637: PUSH
77638: LD_EXP 93
77642: PUSH
77643: LD_VAR 0 2
77647: ARRAY
77648: PUSH
77649: LD_INT 1
77651: ARRAY
77652: PPUSH
77653: CALL_OW 314
77657: NOT
77658: AND
77659: PUSH
77660: LD_EXP 93
77664: PUSH
77665: LD_VAR 0 2
77669: ARRAY
77670: PUSH
77671: LD_INT 1
77673: ARRAY
77674: PPUSH
77675: CALL_OW 310
77679: NOT
77680: AND
77681: IFFALSE 77707
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
77683: LD_EXP 93
77687: PUSH
77688: LD_VAR 0 2
77692: ARRAY
77693: PUSH
77694: LD_INT 1
77696: ARRAY
77697: PPUSH
77698: LD_VAR 0 3
77702: PPUSH
77703: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
77707: LD_EXP 93
77711: PUSH
77712: LD_VAR 0 2
77716: ARRAY
77717: PUSH
77718: LD_INT 1
77720: ARRAY
77721: PPUSH
77722: CALL_OW 310
77726: PUSH
77727: LD_EXP 93
77731: PUSH
77732: LD_VAR 0 2
77736: ARRAY
77737: PUSH
77738: LD_INT 1
77740: ARRAY
77741: PPUSH
77742: CALL_OW 310
77746: PPUSH
77747: CALL_OW 461
77751: PUSH
77752: LD_INT 3
77754: NONEQUAL
77755: AND
77756: IFFALSE 77777
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
77758: LD_EXP 93
77762: PUSH
77763: LD_VAR 0 2
77767: ARRAY
77768: PUSH
77769: LD_INT 1
77771: ARRAY
77772: PPUSH
77773: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
77777: LD_VAR 0 3
77781: PPUSH
77782: CALL_OW 461
77786: PUSH
77787: LD_INT 6
77789: EQUAL
77790: PUSH
77791: LD_VAR 0 6
77795: PUSH
77796: LD_INT 1
77798: GREATER
77799: AND
77800: IFFALSE 77952
// begin sci := [ ] ;
77802: LD_ADDR_VAR 0 8
77806: PUSH
77807: EMPTY
77808: ST_TO_ADDR
// for x in ( tmp diff j ) do
77809: LD_ADDR_VAR 0 7
77813: PUSH
77814: LD_VAR 0 6
77818: PUSH
77819: LD_VAR 0 3
77823: DIFF
77824: PUSH
77825: FOR_IN
77826: IFFALSE 77878
// begin if sci = 6 then
77828: LD_VAR 0 8
77832: PUSH
77833: LD_INT 6
77835: EQUAL
77836: IFFALSE 77840
// break ;
77838: GO 77878
// if BuildingStatus ( x ) = bs_idle then
77840: LD_VAR 0 7
77844: PPUSH
77845: CALL_OW 461
77849: PUSH
77850: LD_INT 2
77852: EQUAL
77853: IFFALSE 77876
// sci := sci ^ UnitsInside ( x ) ;
77855: LD_ADDR_VAR 0 8
77859: PUSH
77860: LD_VAR 0 8
77864: PUSH
77865: LD_VAR 0 7
77869: PPUSH
77870: CALL_OW 313
77874: ADD
77875: ST_TO_ADDR
// end ;
77876: GO 77825
77878: POP
77879: POP
// if not sci then
77880: LD_VAR 0 8
77884: NOT
77885: IFFALSE 77889
// continue ;
77887: GO 76934
// for x in sci do
77889: LD_ADDR_VAR 0 7
77893: PUSH
77894: LD_VAR 0 8
77898: PUSH
77899: FOR_IN
77900: IFFALSE 77950
// if IsInUnit ( x ) and not HasTask ( x ) then
77902: LD_VAR 0 7
77906: PPUSH
77907: CALL_OW 310
77911: PUSH
77912: LD_VAR 0 7
77916: PPUSH
77917: CALL_OW 314
77921: NOT
77922: AND
77923: IFFALSE 77948
// begin ComExitBuilding ( x ) ;
77925: LD_VAR 0 7
77929: PPUSH
77930: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
77934: LD_VAR 0 7
77938: PPUSH
77939: LD_VAR 0 3
77943: PPUSH
77944: CALL_OW 180
// end ;
77948: GO 77899
77950: POP
77951: POP
// end ; end ;
77952: GO 76934
77954: POP
77955: POP
// end ;
77956: GO 76888
77958: POP
77959: POP
// end ;
77960: LD_VAR 0 1
77964: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
77965: LD_INT 0
77967: PPUSH
77968: PPUSH
// if not mc_bases then
77969: LD_EXP 63
77973: NOT
77974: IFFALSE 77978
// exit ;
77976: GO 78059
// for i = 1 to mc_bases do
77978: LD_ADDR_VAR 0 2
77982: PUSH
77983: DOUBLE
77984: LD_INT 1
77986: DEC
77987: ST_TO_ADDR
77988: LD_EXP 63
77992: PUSH
77993: FOR_TO
77994: IFFALSE 78057
// if mc_mines [ i ] and mc_miners [ i ] then
77996: LD_EXP 76
78000: PUSH
78001: LD_VAR 0 2
78005: ARRAY
78006: PUSH
78007: LD_EXP 77
78011: PUSH
78012: LD_VAR 0 2
78016: ARRAY
78017: AND
78018: IFFALSE 78055
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
78020: LD_EXP 77
78024: PUSH
78025: LD_VAR 0 2
78029: ARRAY
78030: PUSH
78031: LD_INT 1
78033: ARRAY
78034: PPUSH
78035: CALL_OW 255
78039: PPUSH
78040: LD_EXP 76
78044: PUSH
78045: LD_VAR 0 2
78049: ARRAY
78050: PPUSH
78051: CALL 19215 0 2
78055: GO 77993
78057: POP
78058: POP
// end ;
78059: LD_VAR 0 1
78063: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
78064: LD_INT 0
78066: PPUSH
78067: PPUSH
78068: PPUSH
78069: PPUSH
78070: PPUSH
78071: PPUSH
78072: PPUSH
78073: PPUSH
// if not mc_bases or not mc_parking then
78074: LD_EXP 63
78078: NOT
78079: PUSH
78080: LD_EXP 87
78084: NOT
78085: OR
78086: IFFALSE 78090
// exit ;
78088: GO 78828
// for i = 1 to mc_bases do
78090: LD_ADDR_VAR 0 2
78094: PUSH
78095: DOUBLE
78096: LD_INT 1
78098: DEC
78099: ST_TO_ADDR
78100: LD_EXP 63
78104: PUSH
78105: FOR_TO
78106: IFFALSE 78826
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
78108: LD_EXP 63
78112: PUSH
78113: LD_VAR 0 2
78117: ARRAY
78118: NOT
78119: PUSH
78120: LD_EXP 87
78124: PUSH
78125: LD_VAR 0 2
78129: ARRAY
78130: NOT
78131: OR
78132: IFFALSE 78136
// continue ;
78134: GO 78105
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
78136: LD_ADDR_VAR 0 5
78140: PUSH
78141: LD_EXP 63
78145: PUSH
78146: LD_VAR 0 2
78150: ARRAY
78151: PUSH
78152: LD_INT 1
78154: ARRAY
78155: PPUSH
78156: CALL_OW 255
78160: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
78161: LD_ADDR_VAR 0 6
78165: PUSH
78166: LD_EXP 63
78170: PUSH
78171: LD_VAR 0 2
78175: ARRAY
78176: PPUSH
78177: LD_INT 30
78179: PUSH
78180: LD_INT 3
78182: PUSH
78183: EMPTY
78184: LIST
78185: LIST
78186: PPUSH
78187: CALL_OW 72
78191: ST_TO_ADDR
// if not fac then
78192: LD_VAR 0 6
78196: NOT
78197: IFFALSE 78248
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78199: LD_ADDR_VAR 0 6
78203: PUSH
78204: LD_EXP 63
78208: PUSH
78209: LD_VAR 0 2
78213: ARRAY
78214: PPUSH
78215: LD_INT 2
78217: PUSH
78218: LD_INT 30
78220: PUSH
78221: LD_INT 0
78223: PUSH
78224: EMPTY
78225: LIST
78226: LIST
78227: PUSH
78228: LD_INT 30
78230: PUSH
78231: LD_INT 1
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: PUSH
78238: EMPTY
78239: LIST
78240: LIST
78241: LIST
78242: PPUSH
78243: CALL_OW 72
78247: ST_TO_ADDR
// if not fac then
78248: LD_VAR 0 6
78252: NOT
78253: IFFALSE 78257
// continue ;
78255: GO 78105
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
78257: LD_ADDR_VAR 0 7
78261: PUSH
78262: LD_EXP 87
78266: PUSH
78267: LD_VAR 0 2
78271: ARRAY
78272: PPUSH
78273: LD_INT 22
78275: PUSH
78276: LD_VAR 0 5
78280: PUSH
78281: EMPTY
78282: LIST
78283: LIST
78284: PUSH
78285: LD_INT 21
78287: PUSH
78288: LD_INT 2
78290: PUSH
78291: EMPTY
78292: LIST
78293: LIST
78294: PUSH
78295: LD_INT 3
78297: PUSH
78298: LD_INT 60
78300: PUSH
78301: EMPTY
78302: LIST
78303: PUSH
78304: EMPTY
78305: LIST
78306: LIST
78307: PUSH
78308: LD_INT 3
78310: PUSH
78311: LD_INT 24
78313: PUSH
78314: LD_INT 1000
78316: PUSH
78317: EMPTY
78318: LIST
78319: LIST
78320: PUSH
78321: EMPTY
78322: LIST
78323: LIST
78324: PUSH
78325: EMPTY
78326: LIST
78327: LIST
78328: LIST
78329: LIST
78330: PPUSH
78331: CALL_OW 70
78335: ST_TO_ADDR
// for j in fac do
78336: LD_ADDR_VAR 0 3
78340: PUSH
78341: LD_VAR 0 6
78345: PUSH
78346: FOR_IN
78347: IFFALSE 78442
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
78349: LD_ADDR_VAR 0 7
78353: PUSH
78354: LD_VAR 0 7
78358: PUSH
78359: LD_INT 22
78361: PUSH
78362: LD_VAR 0 5
78366: PUSH
78367: EMPTY
78368: LIST
78369: LIST
78370: PUSH
78371: LD_INT 91
78373: PUSH
78374: LD_VAR 0 3
78378: PUSH
78379: LD_INT 15
78381: PUSH
78382: EMPTY
78383: LIST
78384: LIST
78385: LIST
78386: PUSH
78387: LD_INT 21
78389: PUSH
78390: LD_INT 2
78392: PUSH
78393: EMPTY
78394: LIST
78395: LIST
78396: PUSH
78397: LD_INT 3
78399: PUSH
78400: LD_INT 60
78402: PUSH
78403: EMPTY
78404: LIST
78405: PUSH
78406: EMPTY
78407: LIST
78408: LIST
78409: PUSH
78410: LD_INT 3
78412: PUSH
78413: LD_INT 24
78415: PUSH
78416: LD_INT 1000
78418: PUSH
78419: EMPTY
78420: LIST
78421: LIST
78422: PUSH
78423: EMPTY
78424: LIST
78425: LIST
78426: PUSH
78427: EMPTY
78428: LIST
78429: LIST
78430: LIST
78431: LIST
78432: LIST
78433: PPUSH
78434: CALL_OW 69
78438: UNION
78439: ST_TO_ADDR
78440: GO 78346
78442: POP
78443: POP
// if not vehs then
78444: LD_VAR 0 7
78448: NOT
78449: IFFALSE 78475
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
78451: LD_ADDR_EXP 75
78455: PUSH
78456: LD_EXP 75
78460: PPUSH
78461: LD_VAR 0 2
78465: PPUSH
78466: EMPTY
78467: PPUSH
78468: CALL_OW 1
78472: ST_TO_ADDR
// continue ;
78473: GO 78105
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
78475: LD_ADDR_VAR 0 8
78479: PUSH
78480: LD_EXP 63
78484: PUSH
78485: LD_VAR 0 2
78489: ARRAY
78490: PPUSH
78491: LD_INT 30
78493: PUSH
78494: LD_INT 3
78496: PUSH
78497: EMPTY
78498: LIST
78499: LIST
78500: PPUSH
78501: CALL_OW 72
78505: ST_TO_ADDR
// if tmp then
78506: LD_VAR 0 8
78510: IFFALSE 78613
// begin for j in tmp do
78512: LD_ADDR_VAR 0 3
78516: PUSH
78517: LD_VAR 0 8
78521: PUSH
78522: FOR_IN
78523: IFFALSE 78611
// for k in UnitsInside ( j ) do
78525: LD_ADDR_VAR 0 4
78529: PUSH
78530: LD_VAR 0 3
78534: PPUSH
78535: CALL_OW 313
78539: PUSH
78540: FOR_IN
78541: IFFALSE 78607
// if k then
78543: LD_VAR 0 4
78547: IFFALSE 78605
// if not k in mc_repair_vehicle [ i ] then
78549: LD_VAR 0 4
78553: PUSH
78554: LD_EXP 75
78558: PUSH
78559: LD_VAR 0 2
78563: ARRAY
78564: IN
78565: NOT
78566: IFFALSE 78605
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
78568: LD_ADDR_EXP 75
78572: PUSH
78573: LD_EXP 75
78577: PPUSH
78578: LD_VAR 0 2
78582: PPUSH
78583: LD_EXP 75
78587: PUSH
78588: LD_VAR 0 2
78592: ARRAY
78593: PUSH
78594: LD_VAR 0 4
78598: UNION
78599: PPUSH
78600: CALL_OW 1
78604: ST_TO_ADDR
78605: GO 78540
78607: POP
78608: POP
78609: GO 78522
78611: POP
78612: POP
// end ; if not mc_repair_vehicle [ i ] then
78613: LD_EXP 75
78617: PUSH
78618: LD_VAR 0 2
78622: ARRAY
78623: NOT
78624: IFFALSE 78628
// continue ;
78626: GO 78105
// for j in mc_repair_vehicle [ i ] do
78628: LD_ADDR_VAR 0 3
78632: PUSH
78633: LD_EXP 75
78637: PUSH
78638: LD_VAR 0 2
78642: ARRAY
78643: PUSH
78644: FOR_IN
78645: IFFALSE 78822
// begin if GetClass ( j ) <> 3 then
78647: LD_VAR 0 3
78651: PPUSH
78652: CALL_OW 257
78656: PUSH
78657: LD_INT 3
78659: NONEQUAL
78660: IFFALSE 78701
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
78662: LD_ADDR_EXP 75
78666: PUSH
78667: LD_EXP 75
78671: PPUSH
78672: LD_VAR 0 2
78676: PPUSH
78677: LD_EXP 75
78681: PUSH
78682: LD_VAR 0 2
78686: ARRAY
78687: PUSH
78688: LD_VAR 0 3
78692: DIFF
78693: PPUSH
78694: CALL_OW 1
78698: ST_TO_ADDR
// continue ;
78699: GO 78644
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
78701: LD_VAR 0 3
78705: PPUSH
78706: CALL_OW 311
78710: NOT
78711: PUSH
78712: LD_VAR 0 3
78716: PUSH
78717: LD_EXP 66
78721: PUSH
78722: LD_VAR 0 2
78726: ARRAY
78727: PUSH
78728: LD_INT 1
78730: ARRAY
78731: IN
78732: NOT
78733: AND
78734: PUSH
78735: LD_VAR 0 3
78739: PUSH
78740: LD_EXP 66
78744: PUSH
78745: LD_VAR 0 2
78749: ARRAY
78750: PUSH
78751: LD_INT 2
78753: ARRAY
78754: IN
78755: NOT
78756: AND
78757: IFFALSE 78820
// begin if IsInUnit ( j ) then
78759: LD_VAR 0 3
78763: PPUSH
78764: CALL_OW 310
78768: IFFALSE 78781
// ComExitBuilding ( j ) else
78770: LD_VAR 0 3
78774: PPUSH
78775: CALL_OW 122
78779: GO 78820
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
78781: LD_VAR 0 3
78785: PPUSH
78786: LD_VAR 0 7
78790: PUSH
78791: LD_INT 1
78793: ARRAY
78794: PPUSH
78795: CALL 57032 0 2
78799: NOT
78800: IFFALSE 78820
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
78802: LD_VAR 0 3
78806: PPUSH
78807: LD_VAR 0 7
78811: PUSH
78812: LD_INT 1
78814: ARRAY
78815: PPUSH
78816: CALL_OW 129
// end ; end ;
78820: GO 78644
78822: POP
78823: POP
// end ;
78824: GO 78105
78826: POP
78827: POP
// end ;
78828: LD_VAR 0 1
78832: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
78833: LD_INT 0
78835: PPUSH
78836: PPUSH
78837: PPUSH
78838: PPUSH
78839: PPUSH
78840: PPUSH
78841: PPUSH
78842: PPUSH
78843: PPUSH
78844: PPUSH
78845: PPUSH
// if not mc_bases then
78846: LD_EXP 63
78850: NOT
78851: IFFALSE 78855
// exit ;
78853: GO 79657
// for i = 1 to mc_bases do
78855: LD_ADDR_VAR 0 2
78859: PUSH
78860: DOUBLE
78861: LD_INT 1
78863: DEC
78864: ST_TO_ADDR
78865: LD_EXP 63
78869: PUSH
78870: FOR_TO
78871: IFFALSE 79655
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
78873: LD_EXP 91
78877: PUSH
78878: LD_VAR 0 2
78882: ARRAY
78883: NOT
78884: PUSH
78885: LD_EXP 66
78889: PUSH
78890: LD_VAR 0 2
78894: ARRAY
78895: PUSH
78896: LD_INT 1
78898: ARRAY
78899: OR
78900: PUSH
78901: LD_EXP 66
78905: PUSH
78906: LD_VAR 0 2
78910: ARRAY
78911: PUSH
78912: LD_INT 2
78914: ARRAY
78915: OR
78916: PUSH
78917: LD_EXP 89
78921: PUSH
78922: LD_VAR 0 2
78926: ARRAY
78927: PPUSH
78928: LD_INT 1
78930: PPUSH
78931: CALL_OW 325
78935: NOT
78936: OR
78937: PUSH
78938: LD_EXP 86
78942: PUSH
78943: LD_VAR 0 2
78947: ARRAY
78948: OR
78949: IFFALSE 78953
// continue ;
78951: GO 78870
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
78953: LD_ADDR_VAR 0 8
78957: PUSH
78958: LD_EXP 63
78962: PUSH
78963: LD_VAR 0 2
78967: ARRAY
78968: PPUSH
78969: LD_INT 25
78971: PUSH
78972: LD_INT 4
78974: PUSH
78975: EMPTY
78976: LIST
78977: LIST
78978: PUSH
78979: LD_INT 50
78981: PUSH
78982: EMPTY
78983: LIST
78984: PUSH
78985: LD_INT 3
78987: PUSH
78988: LD_INT 60
78990: PUSH
78991: EMPTY
78992: LIST
78993: PUSH
78994: EMPTY
78995: LIST
78996: LIST
78997: PUSH
78998: EMPTY
78999: LIST
79000: LIST
79001: LIST
79002: PPUSH
79003: CALL_OW 72
79007: PUSH
79008: LD_EXP 67
79012: PUSH
79013: LD_VAR 0 2
79017: ARRAY
79018: DIFF
79019: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79020: LD_ADDR_VAR 0 9
79024: PUSH
79025: LD_EXP 63
79029: PUSH
79030: LD_VAR 0 2
79034: ARRAY
79035: PPUSH
79036: LD_INT 2
79038: PUSH
79039: LD_INT 30
79041: PUSH
79042: LD_INT 0
79044: PUSH
79045: EMPTY
79046: LIST
79047: LIST
79048: PUSH
79049: LD_INT 30
79051: PUSH
79052: LD_INT 1
79054: PUSH
79055: EMPTY
79056: LIST
79057: LIST
79058: PUSH
79059: EMPTY
79060: LIST
79061: LIST
79062: LIST
79063: PPUSH
79064: CALL_OW 72
79068: ST_TO_ADDR
// if not tmp or not dep then
79069: LD_VAR 0 8
79073: NOT
79074: PUSH
79075: LD_VAR 0 9
79079: NOT
79080: OR
79081: IFFALSE 79085
// continue ;
79083: GO 78870
// side := GetSide ( tmp [ 1 ] ) ;
79085: LD_ADDR_VAR 0 11
79089: PUSH
79090: LD_VAR 0 8
79094: PUSH
79095: LD_INT 1
79097: ARRAY
79098: PPUSH
79099: CALL_OW 255
79103: ST_TO_ADDR
// dep := dep [ 1 ] ;
79104: LD_ADDR_VAR 0 9
79108: PUSH
79109: LD_VAR 0 9
79113: PUSH
79114: LD_INT 1
79116: ARRAY
79117: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
79118: LD_ADDR_VAR 0 7
79122: PUSH
79123: LD_EXP 91
79127: PUSH
79128: LD_VAR 0 2
79132: ARRAY
79133: PPUSH
79134: LD_INT 22
79136: PUSH
79137: LD_INT 0
79139: PUSH
79140: EMPTY
79141: LIST
79142: LIST
79143: PUSH
79144: LD_INT 25
79146: PUSH
79147: LD_INT 12
79149: PUSH
79150: EMPTY
79151: LIST
79152: LIST
79153: PUSH
79154: EMPTY
79155: LIST
79156: LIST
79157: PPUSH
79158: CALL_OW 70
79162: PUSH
79163: LD_INT 22
79165: PUSH
79166: LD_INT 0
79168: PUSH
79169: EMPTY
79170: LIST
79171: LIST
79172: PUSH
79173: LD_INT 25
79175: PUSH
79176: LD_INT 12
79178: PUSH
79179: EMPTY
79180: LIST
79181: LIST
79182: PUSH
79183: LD_INT 91
79185: PUSH
79186: LD_VAR 0 9
79190: PUSH
79191: LD_INT 20
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: LIST
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: LIST
79203: PPUSH
79204: CALL_OW 69
79208: UNION
79209: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
79210: LD_ADDR_VAR 0 10
79214: PUSH
79215: LD_EXP 91
79219: PUSH
79220: LD_VAR 0 2
79224: ARRAY
79225: PPUSH
79226: LD_INT 81
79228: PUSH
79229: LD_VAR 0 11
79233: PUSH
79234: EMPTY
79235: LIST
79236: LIST
79237: PPUSH
79238: CALL_OW 70
79242: ST_TO_ADDR
// if not apes or danger_at_area then
79243: LD_VAR 0 7
79247: NOT
79248: PUSH
79249: LD_VAR 0 10
79253: OR
79254: IFFALSE 79304
// begin if mc_taming [ i ] then
79256: LD_EXP 94
79260: PUSH
79261: LD_VAR 0 2
79265: ARRAY
79266: IFFALSE 79302
// begin MC_Reset ( i , 121 ) ;
79268: LD_VAR 0 2
79272: PPUSH
79273: LD_INT 121
79275: PPUSH
79276: CALL 64220 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
79280: LD_ADDR_EXP 94
79284: PUSH
79285: LD_EXP 94
79289: PPUSH
79290: LD_VAR 0 2
79294: PPUSH
79295: EMPTY
79296: PPUSH
79297: CALL_OW 1
79301: ST_TO_ADDR
// end ; continue ;
79302: GO 78870
// end ; for j in tmp do
79304: LD_ADDR_VAR 0 3
79308: PUSH
79309: LD_VAR 0 8
79313: PUSH
79314: FOR_IN
79315: IFFALSE 79651
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
79317: LD_VAR 0 3
79321: PUSH
79322: LD_EXP 94
79326: PUSH
79327: LD_VAR 0 2
79331: ARRAY
79332: IN
79333: NOT
79334: PUSH
79335: LD_EXP 94
79339: PUSH
79340: LD_VAR 0 2
79344: ARRAY
79345: PUSH
79346: LD_INT 3
79348: LESS
79349: AND
79350: IFFALSE 79408
// begin SetTag ( j , 121 ) ;
79352: LD_VAR 0 3
79356: PPUSH
79357: LD_INT 121
79359: PPUSH
79360: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
79364: LD_ADDR_EXP 94
79368: PUSH
79369: LD_EXP 94
79373: PPUSH
79374: LD_VAR 0 2
79378: PUSH
79379: LD_EXP 94
79383: PUSH
79384: LD_VAR 0 2
79388: ARRAY
79389: PUSH
79390: LD_INT 1
79392: PLUS
79393: PUSH
79394: EMPTY
79395: LIST
79396: LIST
79397: PPUSH
79398: LD_VAR 0 3
79402: PPUSH
79403: CALL 22238 0 3
79407: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
79408: LD_VAR 0 3
79412: PUSH
79413: LD_EXP 94
79417: PUSH
79418: LD_VAR 0 2
79422: ARRAY
79423: IN
79424: IFFALSE 79649
// begin if GetClass ( j ) <> 4 then
79426: LD_VAR 0 3
79430: PPUSH
79431: CALL_OW 257
79435: PUSH
79436: LD_INT 4
79438: NONEQUAL
79439: IFFALSE 79492
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
79441: LD_ADDR_EXP 94
79445: PUSH
79446: LD_EXP 94
79450: PPUSH
79451: LD_VAR 0 2
79455: PPUSH
79456: LD_EXP 94
79460: PUSH
79461: LD_VAR 0 2
79465: ARRAY
79466: PUSH
79467: LD_VAR 0 3
79471: DIFF
79472: PPUSH
79473: CALL_OW 1
79477: ST_TO_ADDR
// SetTag ( j , 0 ) ;
79478: LD_VAR 0 3
79482: PPUSH
79483: LD_INT 0
79485: PPUSH
79486: CALL_OW 109
// continue ;
79490: GO 79314
// end ; if IsInUnit ( j ) then
79492: LD_VAR 0 3
79496: PPUSH
79497: CALL_OW 310
79501: IFFALSE 79512
// ComExitBuilding ( j ) ;
79503: LD_VAR 0 3
79507: PPUSH
79508: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
79512: LD_ADDR_VAR 0 6
79516: PUSH
79517: LD_VAR 0 7
79521: PPUSH
79522: LD_VAR 0 3
79526: PPUSH
79527: CALL_OW 74
79531: ST_TO_ADDR
// if not ape then
79532: LD_VAR 0 6
79536: NOT
79537: IFFALSE 79541
// break ;
79539: GO 79651
// x := GetX ( ape ) ;
79541: LD_ADDR_VAR 0 4
79545: PUSH
79546: LD_VAR 0 6
79550: PPUSH
79551: CALL_OW 250
79555: ST_TO_ADDR
// y := GetY ( ape ) ;
79556: LD_ADDR_VAR 0 5
79560: PUSH
79561: LD_VAR 0 6
79565: PPUSH
79566: CALL_OW 251
79570: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79571: LD_VAR 0 4
79575: PPUSH
79576: LD_VAR 0 5
79580: PPUSH
79581: CALL_OW 488
79585: NOT
79586: PUSH
79587: LD_VAR 0 11
79591: PPUSH
79592: LD_VAR 0 4
79596: PPUSH
79597: LD_VAR 0 5
79601: PPUSH
79602: LD_INT 20
79604: PPUSH
79605: CALL 23502 0 4
79609: PUSH
79610: LD_INT 4
79612: ARRAY
79613: OR
79614: IFFALSE 79618
// break ;
79616: GO 79651
// if not HasTask ( j ) then
79618: LD_VAR 0 3
79622: PPUSH
79623: CALL_OW 314
79627: NOT
79628: IFFALSE 79649
// ComTameXY ( j , x , y ) ;
79630: LD_VAR 0 3
79634: PPUSH
79635: LD_VAR 0 4
79639: PPUSH
79640: LD_VAR 0 5
79644: PPUSH
79645: CALL_OW 131
// end ; end ;
79649: GO 79314
79651: POP
79652: POP
// end ;
79653: GO 78870
79655: POP
79656: POP
// end ;
79657: LD_VAR 0 1
79661: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
79662: LD_INT 0
79664: PPUSH
79665: PPUSH
79666: PPUSH
79667: PPUSH
79668: PPUSH
79669: PPUSH
79670: PPUSH
79671: PPUSH
// if not mc_bases then
79672: LD_EXP 63
79676: NOT
79677: IFFALSE 79681
// exit ;
79679: GO 80307
// for i = 1 to mc_bases do
79681: LD_ADDR_VAR 0 2
79685: PUSH
79686: DOUBLE
79687: LD_INT 1
79689: DEC
79690: ST_TO_ADDR
79691: LD_EXP 63
79695: PUSH
79696: FOR_TO
79697: IFFALSE 80305
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
79699: LD_EXP 92
79703: PUSH
79704: LD_VAR 0 2
79708: ARRAY
79709: NOT
79710: PUSH
79711: LD_EXP 92
79715: PUSH
79716: LD_VAR 0 2
79720: ARRAY
79721: PPUSH
79722: LD_INT 25
79724: PUSH
79725: LD_INT 12
79727: PUSH
79728: EMPTY
79729: LIST
79730: LIST
79731: PPUSH
79732: CALL_OW 72
79736: NOT
79737: OR
79738: IFFALSE 79742
// continue ;
79740: GO 79696
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
79742: LD_ADDR_VAR 0 5
79746: PUSH
79747: LD_EXP 92
79751: PUSH
79752: LD_VAR 0 2
79756: ARRAY
79757: PUSH
79758: LD_INT 1
79760: ARRAY
79761: PPUSH
79762: CALL_OW 255
79766: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
79767: LD_VAR 0 5
79771: PPUSH
79772: LD_INT 2
79774: PPUSH
79775: CALL_OW 325
79779: IFFALSE 80032
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
79781: LD_ADDR_VAR 0 4
79785: PUSH
79786: LD_EXP 92
79790: PUSH
79791: LD_VAR 0 2
79795: ARRAY
79796: PPUSH
79797: LD_INT 25
79799: PUSH
79800: LD_INT 16
79802: PUSH
79803: EMPTY
79804: LIST
79805: LIST
79806: PPUSH
79807: CALL_OW 72
79811: ST_TO_ADDR
// if tmp < 6 then
79812: LD_VAR 0 4
79816: PUSH
79817: LD_INT 6
79819: LESS
79820: IFFALSE 80032
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79822: LD_ADDR_VAR 0 6
79826: PUSH
79827: LD_EXP 63
79831: PUSH
79832: LD_VAR 0 2
79836: ARRAY
79837: PPUSH
79838: LD_INT 2
79840: PUSH
79841: LD_INT 30
79843: PUSH
79844: LD_INT 0
79846: PUSH
79847: EMPTY
79848: LIST
79849: LIST
79850: PUSH
79851: LD_INT 30
79853: PUSH
79854: LD_INT 1
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: PUSH
79861: EMPTY
79862: LIST
79863: LIST
79864: LIST
79865: PPUSH
79866: CALL_OW 72
79870: ST_TO_ADDR
// if depot then
79871: LD_VAR 0 6
79875: IFFALSE 80032
// begin selected := 0 ;
79877: LD_ADDR_VAR 0 7
79881: PUSH
79882: LD_INT 0
79884: ST_TO_ADDR
// for j in depot do
79885: LD_ADDR_VAR 0 3
79889: PUSH
79890: LD_VAR 0 6
79894: PUSH
79895: FOR_IN
79896: IFFALSE 79927
// begin if UnitsInside ( j ) < 6 then
79898: LD_VAR 0 3
79902: PPUSH
79903: CALL_OW 313
79907: PUSH
79908: LD_INT 6
79910: LESS
79911: IFFALSE 79925
// begin selected := j ;
79913: LD_ADDR_VAR 0 7
79917: PUSH
79918: LD_VAR 0 3
79922: ST_TO_ADDR
// break ;
79923: GO 79927
// end ; end ;
79925: GO 79895
79927: POP
79928: POP
// if selected then
79929: LD_VAR 0 7
79933: IFFALSE 80032
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
79935: LD_ADDR_VAR 0 3
79939: PUSH
79940: LD_EXP 92
79944: PUSH
79945: LD_VAR 0 2
79949: ARRAY
79950: PPUSH
79951: LD_INT 25
79953: PUSH
79954: LD_INT 12
79956: PUSH
79957: EMPTY
79958: LIST
79959: LIST
79960: PPUSH
79961: CALL_OW 72
79965: PUSH
79966: FOR_IN
79967: IFFALSE 80030
// if not HasTask ( j ) then
79969: LD_VAR 0 3
79973: PPUSH
79974: CALL_OW 314
79978: NOT
79979: IFFALSE 80028
// begin if not IsInUnit ( j ) then
79981: LD_VAR 0 3
79985: PPUSH
79986: CALL_OW 310
79990: NOT
79991: IFFALSE 80007
// ComEnterUnit ( j , selected ) ;
79993: LD_VAR 0 3
79997: PPUSH
79998: LD_VAR 0 7
80002: PPUSH
80003: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
80007: LD_VAR 0 3
80011: PPUSH
80012: LD_INT 16
80014: PPUSH
80015: CALL_OW 183
// AddComExitBuilding ( j ) ;
80019: LD_VAR 0 3
80023: PPUSH
80024: CALL_OW 182
// end ;
80028: GO 79966
80030: POP
80031: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
80032: LD_VAR 0 5
80036: PPUSH
80037: LD_INT 11
80039: PPUSH
80040: CALL_OW 325
80044: IFFALSE 80303
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
80046: LD_ADDR_VAR 0 4
80050: PUSH
80051: LD_EXP 92
80055: PUSH
80056: LD_VAR 0 2
80060: ARRAY
80061: PPUSH
80062: LD_INT 25
80064: PUSH
80065: LD_INT 16
80067: PUSH
80068: EMPTY
80069: LIST
80070: LIST
80071: PPUSH
80072: CALL_OW 72
80076: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
80077: LD_VAR 0 4
80081: PUSH
80082: LD_INT 6
80084: GREATEREQUAL
80085: PUSH
80086: LD_VAR 0 5
80090: PPUSH
80091: LD_INT 2
80093: PPUSH
80094: CALL_OW 325
80098: NOT
80099: OR
80100: IFFALSE 80303
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
80102: LD_ADDR_VAR 0 8
80106: PUSH
80107: LD_EXP 63
80111: PUSH
80112: LD_VAR 0 2
80116: ARRAY
80117: PPUSH
80118: LD_INT 2
80120: PUSH
80121: LD_INT 30
80123: PUSH
80124: LD_INT 4
80126: PUSH
80127: EMPTY
80128: LIST
80129: LIST
80130: PUSH
80131: LD_INT 30
80133: PUSH
80134: LD_INT 5
80136: PUSH
80137: EMPTY
80138: LIST
80139: LIST
80140: PUSH
80141: EMPTY
80142: LIST
80143: LIST
80144: LIST
80145: PPUSH
80146: CALL_OW 72
80150: ST_TO_ADDR
// if barracks then
80151: LD_VAR 0 8
80155: IFFALSE 80303
// begin selected := 0 ;
80157: LD_ADDR_VAR 0 7
80161: PUSH
80162: LD_INT 0
80164: ST_TO_ADDR
// for j in barracks do
80165: LD_ADDR_VAR 0 3
80169: PUSH
80170: LD_VAR 0 8
80174: PUSH
80175: FOR_IN
80176: IFFALSE 80207
// begin if UnitsInside ( j ) < 6 then
80178: LD_VAR 0 3
80182: PPUSH
80183: CALL_OW 313
80187: PUSH
80188: LD_INT 6
80190: LESS
80191: IFFALSE 80205
// begin selected := j ;
80193: LD_ADDR_VAR 0 7
80197: PUSH
80198: LD_VAR 0 3
80202: ST_TO_ADDR
// break ;
80203: GO 80207
// end ; end ;
80205: GO 80175
80207: POP
80208: POP
// if selected then
80209: LD_VAR 0 7
80213: IFFALSE 80303
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
80215: LD_ADDR_VAR 0 3
80219: PUSH
80220: LD_EXP 92
80224: PUSH
80225: LD_VAR 0 2
80229: ARRAY
80230: PPUSH
80231: LD_INT 25
80233: PUSH
80234: LD_INT 12
80236: PUSH
80237: EMPTY
80238: LIST
80239: LIST
80240: PPUSH
80241: CALL_OW 72
80245: PUSH
80246: FOR_IN
80247: IFFALSE 80301
// if not IsInUnit ( j ) and not HasTask ( j ) then
80249: LD_VAR 0 3
80253: PPUSH
80254: CALL_OW 310
80258: NOT
80259: PUSH
80260: LD_VAR 0 3
80264: PPUSH
80265: CALL_OW 314
80269: NOT
80270: AND
80271: IFFALSE 80299
// begin ComEnterUnit ( j , selected ) ;
80273: LD_VAR 0 3
80277: PPUSH
80278: LD_VAR 0 7
80282: PPUSH
80283: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
80287: LD_VAR 0 3
80291: PPUSH
80292: LD_INT 15
80294: PPUSH
80295: CALL_OW 183
// end ;
80299: GO 80246
80301: POP
80302: POP
// end ; end ; end ; end ; end ;
80303: GO 79696
80305: POP
80306: POP
// end ;
80307: LD_VAR 0 1
80311: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
80312: LD_INT 0
80314: PPUSH
80315: PPUSH
80316: PPUSH
80317: PPUSH
// if not mc_bases then
80318: LD_EXP 63
80322: NOT
80323: IFFALSE 80327
// exit ;
80325: GO 80505
// for i = 1 to mc_bases do
80327: LD_ADDR_VAR 0 2
80331: PUSH
80332: DOUBLE
80333: LD_INT 1
80335: DEC
80336: ST_TO_ADDR
80337: LD_EXP 63
80341: PUSH
80342: FOR_TO
80343: IFFALSE 80503
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
80345: LD_ADDR_VAR 0 4
80349: PUSH
80350: LD_EXP 63
80354: PUSH
80355: LD_VAR 0 2
80359: ARRAY
80360: PPUSH
80361: LD_INT 25
80363: PUSH
80364: LD_INT 9
80366: PUSH
80367: EMPTY
80368: LIST
80369: LIST
80370: PPUSH
80371: CALL_OW 72
80375: ST_TO_ADDR
// if not tmp then
80376: LD_VAR 0 4
80380: NOT
80381: IFFALSE 80385
// continue ;
80383: GO 80342
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
80385: LD_EXP 89
80389: PUSH
80390: LD_VAR 0 2
80394: ARRAY
80395: PPUSH
80396: LD_INT 29
80398: PPUSH
80399: CALL_OW 325
80403: NOT
80404: PUSH
80405: LD_EXP 89
80409: PUSH
80410: LD_VAR 0 2
80414: ARRAY
80415: PPUSH
80416: LD_INT 28
80418: PPUSH
80419: CALL_OW 325
80423: NOT
80424: AND
80425: IFFALSE 80429
// continue ;
80427: GO 80342
// for j in tmp do
80429: LD_ADDR_VAR 0 3
80433: PUSH
80434: LD_VAR 0 4
80438: PUSH
80439: FOR_IN
80440: IFFALSE 80499
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
80442: LD_VAR 0 3
80446: PUSH
80447: LD_EXP 66
80451: PUSH
80452: LD_VAR 0 2
80456: ARRAY
80457: PUSH
80458: LD_INT 1
80460: ARRAY
80461: IN
80462: NOT
80463: PUSH
80464: LD_VAR 0 3
80468: PUSH
80469: LD_EXP 66
80473: PUSH
80474: LD_VAR 0 2
80478: ARRAY
80479: PUSH
80480: LD_INT 2
80482: ARRAY
80483: IN
80484: NOT
80485: AND
80486: IFFALSE 80497
// ComSpaceTimeShoot ( j ) ;
80488: LD_VAR 0 3
80492: PPUSH
80493: CALL 18223 0 1
80497: GO 80439
80499: POP
80500: POP
// end ;
80501: GO 80342
80503: POP
80504: POP
// end ;
80505: LD_VAR 0 1
80509: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
80510: LD_INT 0
80512: PPUSH
80513: PPUSH
80514: PPUSH
80515: PPUSH
80516: PPUSH
80517: PPUSH
80518: PPUSH
80519: PPUSH
80520: PPUSH
// if not mc_bases then
80521: LD_EXP 63
80525: NOT
80526: IFFALSE 80530
// exit ;
80528: GO 81152
// for i = 1 to mc_bases do
80530: LD_ADDR_VAR 0 2
80534: PUSH
80535: DOUBLE
80536: LD_INT 1
80538: DEC
80539: ST_TO_ADDR
80540: LD_EXP 63
80544: PUSH
80545: FOR_TO
80546: IFFALSE 81150
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
80548: LD_EXP 98
80552: PUSH
80553: LD_VAR 0 2
80557: ARRAY
80558: NOT
80559: PUSH
80560: LD_INT 38
80562: PPUSH
80563: LD_EXP 89
80567: PUSH
80568: LD_VAR 0 2
80572: ARRAY
80573: PPUSH
80574: CALL_OW 321
80578: PUSH
80579: LD_INT 2
80581: NONEQUAL
80582: OR
80583: IFFALSE 80587
// continue ;
80585: GO 80545
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
80587: LD_ADDR_VAR 0 8
80591: PUSH
80592: LD_EXP 63
80596: PUSH
80597: LD_VAR 0 2
80601: ARRAY
80602: PPUSH
80603: LD_INT 30
80605: PUSH
80606: LD_INT 34
80608: PUSH
80609: EMPTY
80610: LIST
80611: LIST
80612: PPUSH
80613: CALL_OW 72
80617: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
80618: LD_ADDR_VAR 0 9
80622: PUSH
80623: LD_EXP 63
80627: PUSH
80628: LD_VAR 0 2
80632: ARRAY
80633: PPUSH
80634: LD_INT 25
80636: PUSH
80637: LD_INT 4
80639: PUSH
80640: EMPTY
80641: LIST
80642: LIST
80643: PPUSH
80644: CALL_OW 72
80648: PPUSH
80649: LD_INT 0
80651: PPUSH
80652: CALL 52536 0 2
80656: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
80657: LD_VAR 0 9
80661: NOT
80662: PUSH
80663: LD_VAR 0 8
80667: NOT
80668: OR
80669: PUSH
80670: LD_EXP 63
80674: PUSH
80675: LD_VAR 0 2
80679: ARRAY
80680: PPUSH
80681: LD_INT 124
80683: PPUSH
80684: CALL 52536 0 2
80688: OR
80689: IFFALSE 80693
// continue ;
80691: GO 80545
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
80693: LD_EXP 99
80697: PUSH
80698: LD_VAR 0 2
80702: ARRAY
80703: PUSH
80704: LD_EXP 98
80708: PUSH
80709: LD_VAR 0 2
80713: ARRAY
80714: LESS
80715: PUSH
80716: LD_EXP 99
80720: PUSH
80721: LD_VAR 0 2
80725: ARRAY
80726: PUSH
80727: LD_VAR 0 8
80731: LESS
80732: AND
80733: IFFALSE 81148
// begin tmp := sci [ 1 ] ;
80735: LD_ADDR_VAR 0 7
80739: PUSH
80740: LD_VAR 0 9
80744: PUSH
80745: LD_INT 1
80747: ARRAY
80748: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
80749: LD_VAR 0 7
80753: PPUSH
80754: LD_INT 124
80756: PPUSH
80757: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
80761: LD_ADDR_VAR 0 3
80765: PUSH
80766: DOUBLE
80767: LD_EXP 98
80771: PUSH
80772: LD_VAR 0 2
80776: ARRAY
80777: INC
80778: ST_TO_ADDR
80779: LD_EXP 98
80783: PUSH
80784: LD_VAR 0 2
80788: ARRAY
80789: PUSH
80790: FOR_DOWNTO
80791: IFFALSE 81134
// begin if IsInUnit ( tmp ) then
80793: LD_VAR 0 7
80797: PPUSH
80798: CALL_OW 310
80802: IFFALSE 80813
// ComExitBuilding ( tmp ) ;
80804: LD_VAR 0 7
80808: PPUSH
80809: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
80813: LD_INT 35
80815: PPUSH
80816: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
80820: LD_VAR 0 7
80824: PPUSH
80825: CALL_OW 310
80829: NOT
80830: PUSH
80831: LD_VAR 0 7
80835: PPUSH
80836: CALL_OW 314
80840: NOT
80841: AND
80842: IFFALSE 80813
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
80844: LD_ADDR_VAR 0 6
80848: PUSH
80849: LD_VAR 0 7
80853: PPUSH
80854: CALL_OW 250
80858: PUSH
80859: LD_VAR 0 7
80863: PPUSH
80864: CALL_OW 251
80868: PUSH
80869: EMPTY
80870: LIST
80871: LIST
80872: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
80873: LD_INT 35
80875: PPUSH
80876: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
80880: LD_ADDR_VAR 0 4
80884: PUSH
80885: LD_EXP 98
80889: PUSH
80890: LD_VAR 0 2
80894: ARRAY
80895: PUSH
80896: LD_VAR 0 3
80900: ARRAY
80901: PUSH
80902: LD_INT 1
80904: ARRAY
80905: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
80906: LD_ADDR_VAR 0 5
80910: PUSH
80911: LD_EXP 98
80915: PUSH
80916: LD_VAR 0 2
80920: ARRAY
80921: PUSH
80922: LD_VAR 0 3
80926: ARRAY
80927: PUSH
80928: LD_INT 2
80930: ARRAY
80931: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
80932: LD_VAR 0 7
80936: PPUSH
80937: LD_INT 10
80939: PPUSH
80940: CALL 25203 0 2
80944: PUSH
80945: LD_INT 4
80947: ARRAY
80948: IFFALSE 80986
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
80950: LD_VAR 0 7
80954: PPUSH
80955: LD_VAR 0 6
80959: PUSH
80960: LD_INT 1
80962: ARRAY
80963: PPUSH
80964: LD_VAR 0 6
80968: PUSH
80969: LD_INT 2
80971: ARRAY
80972: PPUSH
80973: CALL_OW 111
// wait ( 0 0$10 ) ;
80977: LD_INT 350
80979: PPUSH
80980: CALL_OW 67
// end else
80984: GO 81012
// begin ComMoveXY ( tmp , x , y ) ;
80986: LD_VAR 0 7
80990: PPUSH
80991: LD_VAR 0 4
80995: PPUSH
80996: LD_VAR 0 5
81000: PPUSH
81001: CALL_OW 111
// wait ( 0 0$3 ) ;
81005: LD_INT 105
81007: PPUSH
81008: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
81012: LD_VAR 0 7
81016: PPUSH
81017: LD_VAR 0 4
81021: PPUSH
81022: LD_VAR 0 5
81026: PPUSH
81027: CALL_OW 307
81031: IFFALSE 80873
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
81033: LD_VAR 0 7
81037: PPUSH
81038: LD_VAR 0 4
81042: PPUSH
81043: LD_VAR 0 5
81047: PPUSH
81048: LD_VAR 0 8
81052: PUSH
81053: LD_VAR 0 3
81057: ARRAY
81058: PPUSH
81059: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
81063: LD_INT 35
81065: PPUSH
81066: CALL_OW 67
// until not HasTask ( tmp ) ;
81070: LD_VAR 0 7
81074: PPUSH
81075: CALL_OW 314
81079: NOT
81080: IFFALSE 81063
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
81082: LD_ADDR_EXP 99
81086: PUSH
81087: LD_EXP 99
81091: PPUSH
81092: LD_VAR 0 2
81096: PUSH
81097: LD_EXP 99
81101: PUSH
81102: LD_VAR 0 2
81106: ARRAY
81107: PUSH
81108: LD_INT 1
81110: PLUS
81111: PUSH
81112: EMPTY
81113: LIST
81114: LIST
81115: PPUSH
81116: LD_VAR 0 8
81120: PUSH
81121: LD_VAR 0 3
81125: ARRAY
81126: PPUSH
81127: CALL 22238 0 3
81131: ST_TO_ADDR
// end ;
81132: GO 80790
81134: POP
81135: POP
// MC_Reset ( i , 124 ) ;
81136: LD_VAR 0 2
81140: PPUSH
81141: LD_INT 124
81143: PPUSH
81144: CALL 64220 0 2
// end ; end ;
81148: GO 80545
81150: POP
81151: POP
// end ;
81152: LD_VAR 0 1
81156: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
81157: LD_INT 0
81159: PPUSH
81160: PPUSH
81161: PPUSH
// if not mc_bases then
81162: LD_EXP 63
81166: NOT
81167: IFFALSE 81171
// exit ;
81169: GO 81777
// for i = 1 to mc_bases do
81171: LD_ADDR_VAR 0 2
81175: PUSH
81176: DOUBLE
81177: LD_INT 1
81179: DEC
81180: ST_TO_ADDR
81181: LD_EXP 63
81185: PUSH
81186: FOR_TO
81187: IFFALSE 81775
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
81189: LD_ADDR_VAR 0 3
81193: PUSH
81194: LD_EXP 63
81198: PUSH
81199: LD_VAR 0 2
81203: ARRAY
81204: PPUSH
81205: LD_INT 25
81207: PUSH
81208: LD_INT 4
81210: PUSH
81211: EMPTY
81212: LIST
81213: LIST
81214: PPUSH
81215: CALL_OW 72
81219: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
81220: LD_VAR 0 3
81224: NOT
81225: PUSH
81226: LD_EXP 100
81230: PUSH
81231: LD_VAR 0 2
81235: ARRAY
81236: NOT
81237: OR
81238: PUSH
81239: LD_EXP 63
81243: PUSH
81244: LD_VAR 0 2
81248: ARRAY
81249: PPUSH
81250: LD_INT 2
81252: PUSH
81253: LD_INT 30
81255: PUSH
81256: LD_INT 0
81258: PUSH
81259: EMPTY
81260: LIST
81261: LIST
81262: PUSH
81263: LD_INT 30
81265: PUSH
81266: LD_INT 1
81268: PUSH
81269: EMPTY
81270: LIST
81271: LIST
81272: PUSH
81273: EMPTY
81274: LIST
81275: LIST
81276: LIST
81277: PPUSH
81278: CALL_OW 72
81282: NOT
81283: OR
81284: IFFALSE 81334
// begin if mc_deposits_finder [ i ] then
81286: LD_EXP 101
81290: PUSH
81291: LD_VAR 0 2
81295: ARRAY
81296: IFFALSE 81332
// begin MC_Reset ( i , 125 ) ;
81298: LD_VAR 0 2
81302: PPUSH
81303: LD_INT 125
81305: PPUSH
81306: CALL 64220 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
81310: LD_ADDR_EXP 101
81314: PUSH
81315: LD_EXP 101
81319: PPUSH
81320: LD_VAR 0 2
81324: PPUSH
81325: EMPTY
81326: PPUSH
81327: CALL_OW 1
81331: ST_TO_ADDR
// end ; continue ;
81332: GO 81186
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
81334: LD_EXP 100
81338: PUSH
81339: LD_VAR 0 2
81343: ARRAY
81344: PUSH
81345: LD_INT 1
81347: ARRAY
81348: PUSH
81349: LD_INT 3
81351: ARRAY
81352: PUSH
81353: LD_INT 1
81355: EQUAL
81356: PUSH
81357: LD_INT 20
81359: PPUSH
81360: LD_EXP 89
81364: PUSH
81365: LD_VAR 0 2
81369: ARRAY
81370: PPUSH
81371: CALL_OW 321
81375: PUSH
81376: LD_INT 2
81378: NONEQUAL
81379: AND
81380: IFFALSE 81430
// begin if mc_deposits_finder [ i ] then
81382: LD_EXP 101
81386: PUSH
81387: LD_VAR 0 2
81391: ARRAY
81392: IFFALSE 81428
// begin MC_Reset ( i , 125 ) ;
81394: LD_VAR 0 2
81398: PPUSH
81399: LD_INT 125
81401: PPUSH
81402: CALL 64220 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
81406: LD_ADDR_EXP 101
81410: PUSH
81411: LD_EXP 101
81415: PPUSH
81416: LD_VAR 0 2
81420: PPUSH
81421: EMPTY
81422: PPUSH
81423: CALL_OW 1
81427: ST_TO_ADDR
// end ; continue ;
81428: GO 81186
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
81430: LD_EXP 100
81434: PUSH
81435: LD_VAR 0 2
81439: ARRAY
81440: PUSH
81441: LD_INT 1
81443: ARRAY
81444: PUSH
81445: LD_INT 1
81447: ARRAY
81448: PPUSH
81449: LD_EXP 100
81453: PUSH
81454: LD_VAR 0 2
81458: ARRAY
81459: PUSH
81460: LD_INT 1
81462: ARRAY
81463: PUSH
81464: LD_INT 2
81466: ARRAY
81467: PPUSH
81468: LD_EXP 89
81472: PUSH
81473: LD_VAR 0 2
81477: ARRAY
81478: PPUSH
81479: CALL_OW 440
81483: IFFALSE 81526
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
81485: LD_ADDR_EXP 100
81489: PUSH
81490: LD_EXP 100
81494: PPUSH
81495: LD_VAR 0 2
81499: PPUSH
81500: LD_EXP 100
81504: PUSH
81505: LD_VAR 0 2
81509: ARRAY
81510: PPUSH
81511: LD_INT 1
81513: PPUSH
81514: CALL_OW 3
81518: PPUSH
81519: CALL_OW 1
81523: ST_TO_ADDR
81524: GO 81773
// begin if not mc_deposits_finder [ i ] then
81526: LD_EXP 101
81530: PUSH
81531: LD_VAR 0 2
81535: ARRAY
81536: NOT
81537: IFFALSE 81589
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
81539: LD_ADDR_EXP 101
81543: PUSH
81544: LD_EXP 101
81548: PPUSH
81549: LD_VAR 0 2
81553: PPUSH
81554: LD_VAR 0 3
81558: PUSH
81559: LD_INT 1
81561: ARRAY
81562: PUSH
81563: EMPTY
81564: LIST
81565: PPUSH
81566: CALL_OW 1
81570: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
81571: LD_VAR 0 3
81575: PUSH
81576: LD_INT 1
81578: ARRAY
81579: PPUSH
81580: LD_INT 125
81582: PPUSH
81583: CALL_OW 109
// end else
81587: GO 81773
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
81589: LD_EXP 101
81593: PUSH
81594: LD_VAR 0 2
81598: ARRAY
81599: PUSH
81600: LD_INT 1
81602: ARRAY
81603: PPUSH
81604: CALL_OW 310
81608: IFFALSE 81631
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
81610: LD_EXP 101
81614: PUSH
81615: LD_VAR 0 2
81619: ARRAY
81620: PUSH
81621: LD_INT 1
81623: ARRAY
81624: PPUSH
81625: CALL_OW 122
81629: GO 81773
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
81631: LD_EXP 101
81635: PUSH
81636: LD_VAR 0 2
81640: ARRAY
81641: PUSH
81642: LD_INT 1
81644: ARRAY
81645: PPUSH
81646: CALL_OW 314
81650: NOT
81651: PUSH
81652: LD_EXP 101
81656: PUSH
81657: LD_VAR 0 2
81661: ARRAY
81662: PUSH
81663: LD_INT 1
81665: ARRAY
81666: PPUSH
81667: LD_EXP 100
81671: PUSH
81672: LD_VAR 0 2
81676: ARRAY
81677: PUSH
81678: LD_INT 1
81680: ARRAY
81681: PUSH
81682: LD_INT 1
81684: ARRAY
81685: PPUSH
81686: LD_EXP 100
81690: PUSH
81691: LD_VAR 0 2
81695: ARRAY
81696: PUSH
81697: LD_INT 1
81699: ARRAY
81700: PUSH
81701: LD_INT 2
81703: ARRAY
81704: PPUSH
81705: CALL_OW 297
81709: PUSH
81710: LD_INT 6
81712: GREATER
81713: AND
81714: IFFALSE 81773
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
81716: LD_EXP 101
81720: PUSH
81721: LD_VAR 0 2
81725: ARRAY
81726: PUSH
81727: LD_INT 1
81729: ARRAY
81730: PPUSH
81731: LD_EXP 100
81735: PUSH
81736: LD_VAR 0 2
81740: ARRAY
81741: PUSH
81742: LD_INT 1
81744: ARRAY
81745: PUSH
81746: LD_INT 1
81748: ARRAY
81749: PPUSH
81750: LD_EXP 100
81754: PUSH
81755: LD_VAR 0 2
81759: ARRAY
81760: PUSH
81761: LD_INT 1
81763: ARRAY
81764: PUSH
81765: LD_INT 2
81767: ARRAY
81768: PPUSH
81769: CALL_OW 111
// end ; end ; end ;
81773: GO 81186
81775: POP
81776: POP
// end ;
81777: LD_VAR 0 1
81781: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
81782: LD_INT 0
81784: PPUSH
81785: PPUSH
81786: PPUSH
81787: PPUSH
81788: PPUSH
81789: PPUSH
81790: PPUSH
81791: PPUSH
81792: PPUSH
81793: PPUSH
81794: PPUSH
// if not mc_bases then
81795: LD_EXP 63
81799: NOT
81800: IFFALSE 81804
// exit ;
81802: GO 82744
// for i = 1 to mc_bases do
81804: LD_ADDR_VAR 0 2
81808: PUSH
81809: DOUBLE
81810: LD_INT 1
81812: DEC
81813: ST_TO_ADDR
81814: LD_EXP 63
81818: PUSH
81819: FOR_TO
81820: IFFALSE 82742
// begin if not mc_bases [ i ] or mc_scan [ i ] then
81822: LD_EXP 63
81826: PUSH
81827: LD_VAR 0 2
81831: ARRAY
81832: NOT
81833: PUSH
81834: LD_EXP 86
81838: PUSH
81839: LD_VAR 0 2
81843: ARRAY
81844: OR
81845: IFFALSE 81849
// continue ;
81847: GO 81819
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
81849: LD_ADDR_VAR 0 7
81853: PUSH
81854: LD_EXP 63
81858: PUSH
81859: LD_VAR 0 2
81863: ARRAY
81864: PUSH
81865: LD_INT 1
81867: ARRAY
81868: PPUSH
81869: CALL_OW 248
81873: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
81874: LD_VAR 0 7
81878: PUSH
81879: LD_INT 3
81881: EQUAL
81882: PUSH
81883: LD_EXP 82
81887: PUSH
81888: LD_VAR 0 2
81892: ARRAY
81893: PUSH
81894: LD_EXP 85
81898: PUSH
81899: LD_VAR 0 2
81903: ARRAY
81904: UNION
81905: PPUSH
81906: LD_INT 33
81908: PUSH
81909: LD_INT 2
81911: PUSH
81912: EMPTY
81913: LIST
81914: LIST
81915: PPUSH
81916: CALL_OW 72
81920: NOT
81921: OR
81922: IFFALSE 81926
// continue ;
81924: GO 81819
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
81926: LD_ADDR_VAR 0 9
81930: PUSH
81931: LD_EXP 63
81935: PUSH
81936: LD_VAR 0 2
81940: ARRAY
81941: PPUSH
81942: LD_INT 30
81944: PUSH
81945: LD_INT 36
81947: PUSH
81948: EMPTY
81949: LIST
81950: LIST
81951: PPUSH
81952: CALL_OW 72
81956: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
81957: LD_ADDR_VAR 0 10
81961: PUSH
81962: LD_EXP 82
81966: PUSH
81967: LD_VAR 0 2
81971: ARRAY
81972: PPUSH
81973: LD_INT 34
81975: PUSH
81976: LD_INT 31
81978: PUSH
81979: EMPTY
81980: LIST
81981: LIST
81982: PPUSH
81983: CALL_OW 72
81987: ST_TO_ADDR
// if not cts and not mcts then
81988: LD_VAR 0 9
81992: NOT
81993: PUSH
81994: LD_VAR 0 10
81998: NOT
81999: AND
82000: IFFALSE 82004
// continue ;
82002: GO 81819
// x := cts ;
82004: LD_ADDR_VAR 0 11
82008: PUSH
82009: LD_VAR 0 9
82013: ST_TO_ADDR
// if not x then
82014: LD_VAR 0 11
82018: NOT
82019: IFFALSE 82031
// x := mcts ;
82021: LD_ADDR_VAR 0 11
82025: PUSH
82026: LD_VAR 0 10
82030: ST_TO_ADDR
// if not x then
82031: LD_VAR 0 11
82035: NOT
82036: IFFALSE 82040
// continue ;
82038: GO 81819
// if mc_remote_driver [ i ] then
82040: LD_EXP 103
82044: PUSH
82045: LD_VAR 0 2
82049: ARRAY
82050: IFFALSE 82437
// for j in mc_remote_driver [ i ] do
82052: LD_ADDR_VAR 0 3
82056: PUSH
82057: LD_EXP 103
82061: PUSH
82062: LD_VAR 0 2
82066: ARRAY
82067: PUSH
82068: FOR_IN
82069: IFFALSE 82435
// begin if GetClass ( j ) <> 3 then
82071: LD_VAR 0 3
82075: PPUSH
82076: CALL_OW 257
82080: PUSH
82081: LD_INT 3
82083: NONEQUAL
82084: IFFALSE 82137
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
82086: LD_ADDR_EXP 103
82090: PUSH
82091: LD_EXP 103
82095: PPUSH
82096: LD_VAR 0 2
82100: PPUSH
82101: LD_EXP 103
82105: PUSH
82106: LD_VAR 0 2
82110: ARRAY
82111: PUSH
82112: LD_VAR 0 3
82116: DIFF
82117: PPUSH
82118: CALL_OW 1
82122: ST_TO_ADDR
// SetTag ( j , 0 ) ;
82123: LD_VAR 0 3
82127: PPUSH
82128: LD_INT 0
82130: PPUSH
82131: CALL_OW 109
// continue ;
82135: GO 82068
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
82137: LD_EXP 82
82141: PUSH
82142: LD_VAR 0 2
82146: ARRAY
82147: PPUSH
82148: LD_INT 34
82150: PUSH
82151: LD_INT 31
82153: PUSH
82154: EMPTY
82155: LIST
82156: LIST
82157: PUSH
82158: LD_INT 58
82160: PUSH
82161: EMPTY
82162: LIST
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: PPUSH
82168: CALL_OW 72
82172: PUSH
82173: LD_VAR 0 3
82177: PPUSH
82178: CALL 52571 0 1
82182: NOT
82183: AND
82184: IFFALSE 82255
// begin if IsInUnit ( j ) then
82186: LD_VAR 0 3
82190: PPUSH
82191: CALL_OW 310
82195: IFFALSE 82206
// ComExitBuilding ( j ) ;
82197: LD_VAR 0 3
82201: PPUSH
82202: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
82206: LD_VAR 0 3
82210: PPUSH
82211: LD_EXP 82
82215: PUSH
82216: LD_VAR 0 2
82220: ARRAY
82221: PPUSH
82222: LD_INT 34
82224: PUSH
82225: LD_INT 31
82227: PUSH
82228: EMPTY
82229: LIST
82230: LIST
82231: PUSH
82232: LD_INT 58
82234: PUSH
82235: EMPTY
82236: LIST
82237: PUSH
82238: EMPTY
82239: LIST
82240: LIST
82241: PPUSH
82242: CALL_OW 72
82246: PUSH
82247: LD_INT 1
82249: ARRAY
82250: PPUSH
82251: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
82255: LD_VAR 0 3
82259: PPUSH
82260: CALL_OW 310
82264: NOT
82265: PUSH
82266: LD_VAR 0 3
82270: PPUSH
82271: CALL_OW 310
82275: PPUSH
82276: CALL_OW 266
82280: PUSH
82281: LD_INT 36
82283: NONEQUAL
82284: PUSH
82285: LD_VAR 0 3
82289: PPUSH
82290: CALL 52571 0 1
82294: NOT
82295: AND
82296: OR
82297: IFFALSE 82433
// begin if IsInUnit ( j ) then
82299: LD_VAR 0 3
82303: PPUSH
82304: CALL_OW 310
82308: IFFALSE 82319
// ComExitBuilding ( j ) ;
82310: LD_VAR 0 3
82314: PPUSH
82315: CALL_OW 122
// ct := 0 ;
82319: LD_ADDR_VAR 0 8
82323: PUSH
82324: LD_INT 0
82326: ST_TO_ADDR
// for k in x do
82327: LD_ADDR_VAR 0 4
82331: PUSH
82332: LD_VAR 0 11
82336: PUSH
82337: FOR_IN
82338: IFFALSE 82411
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
82340: LD_VAR 0 4
82344: PPUSH
82345: CALL_OW 264
82349: PUSH
82350: LD_INT 31
82352: EQUAL
82353: PUSH
82354: LD_VAR 0 4
82358: PPUSH
82359: CALL_OW 311
82363: NOT
82364: AND
82365: PUSH
82366: LD_VAR 0 4
82370: PPUSH
82371: CALL_OW 266
82375: PUSH
82376: LD_INT 36
82378: EQUAL
82379: PUSH
82380: LD_VAR 0 4
82384: PPUSH
82385: CALL_OW 313
82389: PUSH
82390: LD_INT 3
82392: LESS
82393: AND
82394: OR
82395: IFFALSE 82409
// begin ct := k ;
82397: LD_ADDR_VAR 0 8
82401: PUSH
82402: LD_VAR 0 4
82406: ST_TO_ADDR
// break ;
82407: GO 82411
// end ;
82409: GO 82337
82411: POP
82412: POP
// if ct then
82413: LD_VAR 0 8
82417: IFFALSE 82433
// ComEnterUnit ( j , ct ) ;
82419: LD_VAR 0 3
82423: PPUSH
82424: LD_VAR 0 8
82428: PPUSH
82429: CALL_OW 120
// end ; end ;
82433: GO 82068
82435: POP
82436: POP
// places := 0 ;
82437: LD_ADDR_VAR 0 5
82441: PUSH
82442: LD_INT 0
82444: ST_TO_ADDR
// for j = 1 to x do
82445: LD_ADDR_VAR 0 3
82449: PUSH
82450: DOUBLE
82451: LD_INT 1
82453: DEC
82454: ST_TO_ADDR
82455: LD_VAR 0 11
82459: PUSH
82460: FOR_TO
82461: IFFALSE 82537
// if GetWeapon ( x [ j ] ) = ar_control_tower then
82463: LD_VAR 0 11
82467: PUSH
82468: LD_VAR 0 3
82472: ARRAY
82473: PPUSH
82474: CALL_OW 264
82478: PUSH
82479: LD_INT 31
82481: EQUAL
82482: IFFALSE 82500
// places := places + 1 else
82484: LD_ADDR_VAR 0 5
82488: PUSH
82489: LD_VAR 0 5
82493: PUSH
82494: LD_INT 1
82496: PLUS
82497: ST_TO_ADDR
82498: GO 82535
// if GetBType ( x [ j ] ) = b_control_tower then
82500: LD_VAR 0 11
82504: PUSH
82505: LD_VAR 0 3
82509: ARRAY
82510: PPUSH
82511: CALL_OW 266
82515: PUSH
82516: LD_INT 36
82518: EQUAL
82519: IFFALSE 82535
// places := places + 3 ;
82521: LD_ADDR_VAR 0 5
82525: PUSH
82526: LD_VAR 0 5
82530: PUSH
82531: LD_INT 3
82533: PLUS
82534: ST_TO_ADDR
82535: GO 82460
82537: POP
82538: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
82539: LD_VAR 0 5
82543: PUSH
82544: LD_INT 0
82546: EQUAL
82547: PUSH
82548: LD_VAR 0 5
82552: PUSH
82553: LD_EXP 103
82557: PUSH
82558: LD_VAR 0 2
82562: ARRAY
82563: LESSEQUAL
82564: OR
82565: IFFALSE 82569
// continue ;
82567: GO 81819
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
82569: LD_ADDR_VAR 0 6
82573: PUSH
82574: LD_EXP 63
82578: PUSH
82579: LD_VAR 0 2
82583: ARRAY
82584: PPUSH
82585: LD_INT 25
82587: PUSH
82588: LD_INT 3
82590: PUSH
82591: EMPTY
82592: LIST
82593: LIST
82594: PPUSH
82595: CALL_OW 72
82599: PUSH
82600: LD_EXP 103
82604: PUSH
82605: LD_VAR 0 2
82609: ARRAY
82610: DIFF
82611: PPUSH
82612: LD_INT 3
82614: PPUSH
82615: CALL 53471 0 2
82619: ST_TO_ADDR
// for j in tmp do
82620: LD_ADDR_VAR 0 3
82624: PUSH
82625: LD_VAR 0 6
82629: PUSH
82630: FOR_IN
82631: IFFALSE 82666
// if GetTag ( j ) > 0 then
82633: LD_VAR 0 3
82637: PPUSH
82638: CALL_OW 110
82642: PUSH
82643: LD_INT 0
82645: GREATER
82646: IFFALSE 82664
// tmp := tmp diff j ;
82648: LD_ADDR_VAR 0 6
82652: PUSH
82653: LD_VAR 0 6
82657: PUSH
82658: LD_VAR 0 3
82662: DIFF
82663: ST_TO_ADDR
82664: GO 82630
82666: POP
82667: POP
// if not tmp then
82668: LD_VAR 0 6
82672: NOT
82673: IFFALSE 82677
// continue ;
82675: GO 81819
// if places then
82677: LD_VAR 0 5
82681: IFFALSE 82740
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
82683: LD_ADDR_EXP 103
82687: PUSH
82688: LD_EXP 103
82692: PPUSH
82693: LD_VAR 0 2
82697: PPUSH
82698: LD_EXP 103
82702: PUSH
82703: LD_VAR 0 2
82707: ARRAY
82708: PUSH
82709: LD_VAR 0 6
82713: PUSH
82714: LD_INT 1
82716: ARRAY
82717: UNION
82718: PPUSH
82719: CALL_OW 1
82723: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
82724: LD_VAR 0 6
82728: PUSH
82729: LD_INT 1
82731: ARRAY
82732: PPUSH
82733: LD_INT 126
82735: PPUSH
82736: CALL_OW 109
// end ; end ;
82740: GO 81819
82742: POP
82743: POP
// end ;
82744: LD_VAR 0 1
82748: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
82749: LD_INT 0
82751: PPUSH
82752: PPUSH
82753: PPUSH
82754: PPUSH
82755: PPUSH
82756: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
82757: LD_VAR 0 1
82761: NOT
82762: PUSH
82763: LD_VAR 0 2
82767: NOT
82768: OR
82769: PUSH
82770: LD_VAR 0 3
82774: NOT
82775: OR
82776: PUSH
82777: LD_VAR 0 4
82781: PUSH
82782: LD_INT 1
82784: PUSH
82785: LD_INT 2
82787: PUSH
82788: LD_INT 3
82790: PUSH
82791: LD_INT 4
82793: PUSH
82794: LD_INT 5
82796: PUSH
82797: LD_INT 8
82799: PUSH
82800: LD_INT 9
82802: PUSH
82803: LD_INT 15
82805: PUSH
82806: LD_INT 16
82808: PUSH
82809: EMPTY
82810: LIST
82811: LIST
82812: LIST
82813: LIST
82814: LIST
82815: LIST
82816: LIST
82817: LIST
82818: LIST
82819: IN
82820: NOT
82821: OR
82822: IFFALSE 82826
// exit ;
82824: GO 83684
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
82826: LD_ADDR_VAR 0 2
82830: PUSH
82831: LD_VAR 0 2
82835: PPUSH
82836: LD_INT 21
82838: PUSH
82839: LD_INT 3
82841: PUSH
82842: EMPTY
82843: LIST
82844: LIST
82845: PUSH
82846: LD_INT 24
82848: PUSH
82849: LD_INT 250
82851: PUSH
82852: EMPTY
82853: LIST
82854: LIST
82855: PUSH
82856: EMPTY
82857: LIST
82858: LIST
82859: PPUSH
82860: CALL_OW 72
82864: ST_TO_ADDR
// case class of 1 , 15 :
82865: LD_VAR 0 4
82869: PUSH
82870: LD_INT 1
82872: DOUBLE
82873: EQUAL
82874: IFTRUE 82884
82876: LD_INT 15
82878: DOUBLE
82879: EQUAL
82880: IFTRUE 82884
82882: GO 82969
82884: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
82885: LD_ADDR_VAR 0 8
82889: PUSH
82890: LD_VAR 0 2
82894: PPUSH
82895: LD_INT 2
82897: PUSH
82898: LD_INT 30
82900: PUSH
82901: LD_INT 32
82903: PUSH
82904: EMPTY
82905: LIST
82906: LIST
82907: PUSH
82908: LD_INT 30
82910: PUSH
82911: LD_INT 31
82913: PUSH
82914: EMPTY
82915: LIST
82916: LIST
82917: PUSH
82918: EMPTY
82919: LIST
82920: LIST
82921: LIST
82922: PPUSH
82923: CALL_OW 72
82927: PUSH
82928: LD_VAR 0 2
82932: PPUSH
82933: LD_INT 2
82935: PUSH
82936: LD_INT 30
82938: PUSH
82939: LD_INT 4
82941: PUSH
82942: EMPTY
82943: LIST
82944: LIST
82945: PUSH
82946: LD_INT 30
82948: PUSH
82949: LD_INT 5
82951: PUSH
82952: EMPTY
82953: LIST
82954: LIST
82955: PUSH
82956: EMPTY
82957: LIST
82958: LIST
82959: LIST
82960: PPUSH
82961: CALL_OW 72
82965: ADD
82966: ST_TO_ADDR
82967: GO 83215
82969: LD_INT 2
82971: DOUBLE
82972: EQUAL
82973: IFTRUE 82983
82975: LD_INT 16
82977: DOUBLE
82978: EQUAL
82979: IFTRUE 82983
82981: GO 83029
82983: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
82984: LD_ADDR_VAR 0 8
82988: PUSH
82989: LD_VAR 0 2
82993: PPUSH
82994: LD_INT 2
82996: PUSH
82997: LD_INT 30
82999: PUSH
83000: LD_INT 0
83002: PUSH
83003: EMPTY
83004: LIST
83005: LIST
83006: PUSH
83007: LD_INT 30
83009: PUSH
83010: LD_INT 1
83012: PUSH
83013: EMPTY
83014: LIST
83015: LIST
83016: PUSH
83017: EMPTY
83018: LIST
83019: LIST
83020: LIST
83021: PPUSH
83022: CALL_OW 72
83026: ST_TO_ADDR
83027: GO 83215
83029: LD_INT 3
83031: DOUBLE
83032: EQUAL
83033: IFTRUE 83037
83035: GO 83083
83037: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
83038: LD_ADDR_VAR 0 8
83042: PUSH
83043: LD_VAR 0 2
83047: PPUSH
83048: LD_INT 2
83050: PUSH
83051: LD_INT 30
83053: PUSH
83054: LD_INT 2
83056: PUSH
83057: EMPTY
83058: LIST
83059: LIST
83060: PUSH
83061: LD_INT 30
83063: PUSH
83064: LD_INT 3
83066: PUSH
83067: EMPTY
83068: LIST
83069: LIST
83070: PUSH
83071: EMPTY
83072: LIST
83073: LIST
83074: LIST
83075: PPUSH
83076: CALL_OW 72
83080: ST_TO_ADDR
83081: GO 83215
83083: LD_INT 4
83085: DOUBLE
83086: EQUAL
83087: IFTRUE 83091
83089: GO 83148
83091: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
83092: LD_ADDR_VAR 0 8
83096: PUSH
83097: LD_VAR 0 2
83101: PPUSH
83102: LD_INT 2
83104: PUSH
83105: LD_INT 30
83107: PUSH
83108: LD_INT 6
83110: PUSH
83111: EMPTY
83112: LIST
83113: LIST
83114: PUSH
83115: LD_INT 30
83117: PUSH
83118: LD_INT 7
83120: PUSH
83121: EMPTY
83122: LIST
83123: LIST
83124: PUSH
83125: LD_INT 30
83127: PUSH
83128: LD_INT 8
83130: PUSH
83131: EMPTY
83132: LIST
83133: LIST
83134: PUSH
83135: EMPTY
83136: LIST
83137: LIST
83138: LIST
83139: LIST
83140: PPUSH
83141: CALL_OW 72
83145: ST_TO_ADDR
83146: GO 83215
83148: LD_INT 5
83150: DOUBLE
83151: EQUAL
83152: IFTRUE 83168
83154: LD_INT 8
83156: DOUBLE
83157: EQUAL
83158: IFTRUE 83168
83160: LD_INT 9
83162: DOUBLE
83163: EQUAL
83164: IFTRUE 83168
83166: GO 83214
83168: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
83169: LD_ADDR_VAR 0 8
83173: PUSH
83174: LD_VAR 0 2
83178: PPUSH
83179: LD_INT 2
83181: PUSH
83182: LD_INT 30
83184: PUSH
83185: LD_INT 4
83187: PUSH
83188: EMPTY
83189: LIST
83190: LIST
83191: PUSH
83192: LD_INT 30
83194: PUSH
83195: LD_INT 5
83197: PUSH
83198: EMPTY
83199: LIST
83200: LIST
83201: PUSH
83202: EMPTY
83203: LIST
83204: LIST
83205: LIST
83206: PPUSH
83207: CALL_OW 72
83211: ST_TO_ADDR
83212: GO 83215
83214: POP
// if not tmp then
83215: LD_VAR 0 8
83219: NOT
83220: IFFALSE 83224
// exit ;
83222: GO 83684
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
83224: LD_VAR 0 4
83228: PUSH
83229: LD_INT 1
83231: PUSH
83232: LD_INT 15
83234: PUSH
83235: EMPTY
83236: LIST
83237: LIST
83238: IN
83239: PUSH
83240: LD_EXP 72
83244: PUSH
83245: LD_VAR 0 1
83249: ARRAY
83250: AND
83251: IFFALSE 83407
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
83253: LD_ADDR_VAR 0 9
83257: PUSH
83258: LD_EXP 72
83262: PUSH
83263: LD_VAR 0 1
83267: ARRAY
83268: PUSH
83269: LD_INT 1
83271: ARRAY
83272: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
83273: LD_VAR 0 9
83277: PUSH
83278: LD_EXP 73
83282: PUSH
83283: LD_VAR 0 1
83287: ARRAY
83288: IN
83289: NOT
83290: IFFALSE 83405
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
83292: LD_ADDR_EXP 73
83296: PUSH
83297: LD_EXP 73
83301: PPUSH
83302: LD_VAR 0 1
83306: PUSH
83307: LD_EXP 73
83311: PUSH
83312: LD_VAR 0 1
83316: ARRAY
83317: PUSH
83318: LD_INT 1
83320: PLUS
83321: PUSH
83322: EMPTY
83323: LIST
83324: LIST
83325: PPUSH
83326: LD_VAR 0 9
83330: PPUSH
83331: CALL 22238 0 3
83335: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
83336: LD_ADDR_EXP 72
83340: PUSH
83341: LD_EXP 72
83345: PPUSH
83346: LD_VAR 0 1
83350: PPUSH
83351: LD_EXP 72
83355: PUSH
83356: LD_VAR 0 1
83360: ARRAY
83361: PUSH
83362: LD_VAR 0 9
83366: DIFF
83367: PPUSH
83368: CALL_OW 1
83372: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
83373: LD_VAR 0 3
83377: PPUSH
83378: LD_EXP 73
83382: PUSH
83383: LD_VAR 0 1
83387: ARRAY
83388: PUSH
83389: LD_EXP 73
83393: PUSH
83394: LD_VAR 0 1
83398: ARRAY
83399: ARRAY
83400: PPUSH
83401: CALL_OW 120
// end ; exit ;
83405: GO 83684
// end ; if tmp > 1 then
83407: LD_VAR 0 8
83411: PUSH
83412: LD_INT 1
83414: GREATER
83415: IFFALSE 83519
// for i = 2 to tmp do
83417: LD_ADDR_VAR 0 6
83421: PUSH
83422: DOUBLE
83423: LD_INT 2
83425: DEC
83426: ST_TO_ADDR
83427: LD_VAR 0 8
83431: PUSH
83432: FOR_TO
83433: IFFALSE 83517
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
83435: LD_VAR 0 8
83439: PUSH
83440: LD_VAR 0 6
83444: ARRAY
83445: PPUSH
83446: CALL_OW 461
83450: PUSH
83451: LD_INT 6
83453: EQUAL
83454: IFFALSE 83515
// begin x := tmp [ i ] ;
83456: LD_ADDR_VAR 0 9
83460: PUSH
83461: LD_VAR 0 8
83465: PUSH
83466: LD_VAR 0 6
83470: ARRAY
83471: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
83472: LD_ADDR_VAR 0 8
83476: PUSH
83477: LD_VAR 0 8
83481: PPUSH
83482: LD_VAR 0 6
83486: PPUSH
83487: CALL_OW 3
83491: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
83492: LD_ADDR_VAR 0 8
83496: PUSH
83497: LD_VAR 0 8
83501: PPUSH
83502: LD_INT 1
83504: PPUSH
83505: LD_VAR 0 9
83509: PPUSH
83510: CALL_OW 2
83514: ST_TO_ADDR
// end ;
83515: GO 83432
83517: POP
83518: POP
// for i in tmp do
83519: LD_ADDR_VAR 0 6
83523: PUSH
83524: LD_VAR 0 8
83528: PUSH
83529: FOR_IN
83530: IFFALSE 83557
// begin if IsNotFull ( i ) then
83532: LD_VAR 0 6
83536: PPUSH
83537: CALL 19460 0 1
83541: IFFALSE 83555
// begin j := i ;
83543: LD_ADDR_VAR 0 7
83547: PUSH
83548: LD_VAR 0 6
83552: ST_TO_ADDR
// break ;
83553: GO 83557
// end ; end ;
83555: GO 83529
83557: POP
83558: POP
// if j then
83559: LD_VAR 0 7
83563: IFFALSE 83581
// ComEnterUnit ( unit , j ) else
83565: LD_VAR 0 3
83569: PPUSH
83570: LD_VAR 0 7
83574: PPUSH
83575: CALL_OW 120
83579: GO 83684
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83581: LD_ADDR_VAR 0 10
83585: PUSH
83586: LD_VAR 0 2
83590: PPUSH
83591: LD_INT 2
83593: PUSH
83594: LD_INT 30
83596: PUSH
83597: LD_INT 0
83599: PUSH
83600: EMPTY
83601: LIST
83602: LIST
83603: PUSH
83604: LD_INT 30
83606: PUSH
83607: LD_INT 1
83609: PUSH
83610: EMPTY
83611: LIST
83612: LIST
83613: PUSH
83614: EMPTY
83615: LIST
83616: LIST
83617: LIST
83618: PPUSH
83619: CALL_OW 72
83623: ST_TO_ADDR
// if depot then
83624: LD_VAR 0 10
83628: IFFALSE 83684
// begin depot := NearestUnitToUnit ( depot , unit ) ;
83630: LD_ADDR_VAR 0 10
83634: PUSH
83635: LD_VAR 0 10
83639: PPUSH
83640: LD_VAR 0 3
83644: PPUSH
83645: CALL_OW 74
83649: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
83650: LD_VAR 0 3
83654: PPUSH
83655: LD_VAR 0 10
83659: PPUSH
83660: CALL_OW 296
83664: PUSH
83665: LD_INT 10
83667: GREATER
83668: IFFALSE 83684
// ComStandNearbyBuilding ( unit , depot ) ;
83670: LD_VAR 0 3
83674: PPUSH
83675: LD_VAR 0 10
83679: PPUSH
83680: CALL 18840 0 2
// end ; end ; end ;
83684: LD_VAR 0 5
83688: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
83689: LD_INT 0
83691: PPUSH
83692: PPUSH
83693: PPUSH
83694: PPUSH
// if not mc_bases then
83695: LD_EXP 63
83699: NOT
83700: IFFALSE 83704
// exit ;
83702: GO 83943
// for i = 1 to mc_bases do
83704: LD_ADDR_VAR 0 2
83708: PUSH
83709: DOUBLE
83710: LD_INT 1
83712: DEC
83713: ST_TO_ADDR
83714: LD_EXP 63
83718: PUSH
83719: FOR_TO
83720: IFFALSE 83941
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
83722: LD_ADDR_VAR 0 4
83726: PUSH
83727: LD_EXP 63
83731: PUSH
83732: LD_VAR 0 2
83736: ARRAY
83737: PPUSH
83738: LD_INT 21
83740: PUSH
83741: LD_INT 1
83743: PUSH
83744: EMPTY
83745: LIST
83746: LIST
83747: PPUSH
83748: CALL_OW 72
83752: PUSH
83753: LD_EXP 92
83757: PUSH
83758: LD_VAR 0 2
83762: ARRAY
83763: UNION
83764: ST_TO_ADDR
// if not tmp then
83765: LD_VAR 0 4
83769: NOT
83770: IFFALSE 83774
// continue ;
83772: GO 83719
// for j in tmp do
83774: LD_ADDR_VAR 0 3
83778: PUSH
83779: LD_VAR 0 4
83783: PUSH
83784: FOR_IN
83785: IFFALSE 83937
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
83787: LD_VAR 0 3
83791: PPUSH
83792: CALL_OW 110
83796: NOT
83797: PUSH
83798: LD_VAR 0 3
83802: PPUSH
83803: CALL_OW 314
83807: NOT
83808: AND
83809: PUSH
83810: LD_VAR 0 3
83814: PPUSH
83815: CALL_OW 311
83819: NOT
83820: AND
83821: PUSH
83822: LD_VAR 0 3
83826: PPUSH
83827: CALL_OW 310
83831: NOT
83832: AND
83833: PUSH
83834: LD_VAR 0 3
83838: PUSH
83839: LD_EXP 66
83843: PUSH
83844: LD_VAR 0 2
83848: ARRAY
83849: PUSH
83850: LD_INT 1
83852: ARRAY
83853: IN
83854: NOT
83855: AND
83856: PUSH
83857: LD_VAR 0 3
83861: PUSH
83862: LD_EXP 66
83866: PUSH
83867: LD_VAR 0 2
83871: ARRAY
83872: PUSH
83873: LD_INT 2
83875: ARRAY
83876: IN
83877: NOT
83878: AND
83879: PUSH
83880: LD_VAR 0 3
83884: PUSH
83885: LD_EXP 75
83889: PUSH
83890: LD_VAR 0 2
83894: ARRAY
83895: IN
83896: NOT
83897: AND
83898: IFFALSE 83935
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
83900: LD_VAR 0 2
83904: PPUSH
83905: LD_EXP 63
83909: PUSH
83910: LD_VAR 0 2
83914: ARRAY
83915: PPUSH
83916: LD_VAR 0 3
83920: PPUSH
83921: LD_VAR 0 3
83925: PPUSH
83926: CALL_OW 257
83930: PPUSH
83931: CALL 82749 0 4
// end ;
83935: GO 83784
83937: POP
83938: POP
// end ;
83939: GO 83719
83941: POP
83942: POP
// end ;
83943: LD_VAR 0 1
83947: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
83948: LD_INT 0
83950: PPUSH
83951: PPUSH
83952: PPUSH
83953: PPUSH
83954: PPUSH
83955: PPUSH
// if not mc_bases [ base ] then
83956: LD_EXP 63
83960: PUSH
83961: LD_VAR 0 1
83965: ARRAY
83966: NOT
83967: IFFALSE 83971
// exit ;
83969: GO 84172
// tmp := [ ] ;
83971: LD_ADDR_VAR 0 6
83975: PUSH
83976: EMPTY
83977: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
83978: LD_ADDR_VAR 0 7
83982: PUSH
83983: LD_VAR 0 3
83987: PPUSH
83988: LD_INT 0
83990: PPUSH
83991: CALL_OW 517
83995: ST_TO_ADDR
// if not list then
83996: LD_VAR 0 7
84000: NOT
84001: IFFALSE 84005
// exit ;
84003: GO 84172
// c := Count ( list [ 1 ] ) ;
84005: LD_ADDR_VAR 0 9
84009: PUSH
84010: LD_VAR 0 7
84014: PUSH
84015: LD_INT 1
84017: ARRAY
84018: PPUSH
84019: CALL 19378 0 1
84023: ST_TO_ADDR
// if amount > c then
84024: LD_VAR 0 2
84028: PUSH
84029: LD_VAR 0 9
84033: GREATER
84034: IFFALSE 84046
// amount := c ;
84036: LD_ADDR_VAR 0 2
84040: PUSH
84041: LD_VAR 0 9
84045: ST_TO_ADDR
// for i := 1 to amount do
84046: LD_ADDR_VAR 0 5
84050: PUSH
84051: DOUBLE
84052: LD_INT 1
84054: DEC
84055: ST_TO_ADDR
84056: LD_VAR 0 2
84060: PUSH
84061: FOR_TO
84062: IFFALSE 84120
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
84064: LD_ADDR_VAR 0 6
84068: PUSH
84069: LD_VAR 0 6
84073: PPUSH
84074: LD_VAR 0 5
84078: PPUSH
84079: LD_VAR 0 7
84083: PUSH
84084: LD_INT 1
84086: ARRAY
84087: PUSH
84088: LD_VAR 0 5
84092: ARRAY
84093: PUSH
84094: LD_VAR 0 7
84098: PUSH
84099: LD_INT 2
84101: ARRAY
84102: PUSH
84103: LD_VAR 0 5
84107: ARRAY
84108: PUSH
84109: EMPTY
84110: LIST
84111: LIST
84112: PPUSH
84113: CALL_OW 1
84117: ST_TO_ADDR
84118: GO 84061
84120: POP
84121: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
84122: LD_ADDR_EXP 76
84126: PUSH
84127: LD_EXP 76
84131: PPUSH
84132: LD_VAR 0 1
84136: PPUSH
84137: LD_VAR 0 6
84141: PPUSH
84142: CALL_OW 1
84146: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
84147: LD_ADDR_EXP 78
84151: PUSH
84152: LD_EXP 78
84156: PPUSH
84157: LD_VAR 0 1
84161: PPUSH
84162: LD_VAR 0 3
84166: PPUSH
84167: CALL_OW 1
84171: ST_TO_ADDR
// end ;
84172: LD_VAR 0 4
84176: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
84177: LD_INT 0
84179: PPUSH
// if not mc_bases [ base ] then
84180: LD_EXP 63
84184: PUSH
84185: LD_VAR 0 1
84189: ARRAY
84190: NOT
84191: IFFALSE 84195
// exit ;
84193: GO 84220
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
84195: LD_ADDR_EXP 68
84199: PUSH
84200: LD_EXP 68
84204: PPUSH
84205: LD_VAR 0 1
84209: PPUSH
84210: LD_VAR 0 2
84214: PPUSH
84215: CALL_OW 1
84219: ST_TO_ADDR
// end ;
84220: LD_VAR 0 3
84224: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
84225: LD_INT 0
84227: PPUSH
// if not mc_bases [ base ] then
84228: LD_EXP 63
84232: PUSH
84233: LD_VAR 0 1
84237: ARRAY
84238: NOT
84239: IFFALSE 84243
// exit ;
84241: GO 84280
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
84243: LD_ADDR_EXP 68
84247: PUSH
84248: LD_EXP 68
84252: PPUSH
84253: LD_VAR 0 1
84257: PPUSH
84258: LD_EXP 68
84262: PUSH
84263: LD_VAR 0 1
84267: ARRAY
84268: PUSH
84269: LD_VAR 0 2
84273: UNION
84274: PPUSH
84275: CALL_OW 1
84279: ST_TO_ADDR
// end ;
84280: LD_VAR 0 3
84284: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
84285: LD_INT 0
84287: PPUSH
// if not mc_bases [ base ] then
84288: LD_EXP 63
84292: PUSH
84293: LD_VAR 0 1
84297: ARRAY
84298: NOT
84299: IFFALSE 84303
// exit ;
84301: GO 84328
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
84303: LD_ADDR_EXP 84
84307: PUSH
84308: LD_EXP 84
84312: PPUSH
84313: LD_VAR 0 1
84317: PPUSH
84318: LD_VAR 0 2
84322: PPUSH
84323: CALL_OW 1
84327: ST_TO_ADDR
// end ;
84328: LD_VAR 0 3
84332: RET
// export function MC_InsertProduceList ( base , components ) ; begin
84333: LD_INT 0
84335: PPUSH
// if not mc_bases [ base ] then
84336: LD_EXP 63
84340: PUSH
84341: LD_VAR 0 1
84345: ARRAY
84346: NOT
84347: IFFALSE 84351
// exit ;
84349: GO 84388
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
84351: LD_ADDR_EXP 84
84355: PUSH
84356: LD_EXP 84
84360: PPUSH
84361: LD_VAR 0 1
84365: PPUSH
84366: LD_EXP 84
84370: PUSH
84371: LD_VAR 0 1
84375: ARRAY
84376: PUSH
84377: LD_VAR 0 2
84381: ADD
84382: PPUSH
84383: CALL_OW 1
84387: ST_TO_ADDR
// end ;
84388: LD_VAR 0 3
84392: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
84393: LD_INT 0
84395: PPUSH
// if not mc_bases [ base ] then
84396: LD_EXP 63
84400: PUSH
84401: LD_VAR 0 1
84405: ARRAY
84406: NOT
84407: IFFALSE 84411
// exit ;
84409: GO 84465
// mc_defender := Replace ( mc_defender , base , deflist ) ;
84411: LD_ADDR_EXP 85
84415: PUSH
84416: LD_EXP 85
84420: PPUSH
84421: LD_VAR 0 1
84425: PPUSH
84426: LD_VAR 0 2
84430: PPUSH
84431: CALL_OW 1
84435: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
84436: LD_ADDR_EXP 74
84440: PUSH
84441: LD_EXP 74
84445: PPUSH
84446: LD_VAR 0 1
84450: PPUSH
84451: LD_VAR 0 2
84455: PUSH
84456: LD_INT 0
84458: PLUS
84459: PPUSH
84460: CALL_OW 1
84464: ST_TO_ADDR
// end ;
84465: LD_VAR 0 3
84469: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
84470: LD_INT 0
84472: PPUSH
// if not mc_bases [ base ] then
84473: LD_EXP 63
84477: PUSH
84478: LD_VAR 0 1
84482: ARRAY
84483: NOT
84484: IFFALSE 84488
// exit ;
84486: GO 84513
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
84488: LD_ADDR_EXP 74
84492: PUSH
84493: LD_EXP 74
84497: PPUSH
84498: LD_VAR 0 1
84502: PPUSH
84503: LD_VAR 0 2
84507: PPUSH
84508: CALL_OW 1
84512: ST_TO_ADDR
// end ;
84513: LD_VAR 0 3
84517: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
84518: LD_INT 0
84520: PPUSH
84521: PPUSH
84522: PPUSH
84523: PPUSH
// if not mc_bases [ base ] then
84524: LD_EXP 63
84528: PUSH
84529: LD_VAR 0 1
84533: ARRAY
84534: NOT
84535: IFFALSE 84539
// exit ;
84537: GO 84604
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
84539: LD_ADDR_EXP 83
84543: PUSH
84544: LD_EXP 83
84548: PPUSH
84549: LD_VAR 0 1
84553: PUSH
84554: LD_EXP 83
84558: PUSH
84559: LD_VAR 0 1
84563: ARRAY
84564: PUSH
84565: LD_INT 1
84567: PLUS
84568: PUSH
84569: EMPTY
84570: LIST
84571: LIST
84572: PPUSH
84573: LD_VAR 0 1
84577: PUSH
84578: LD_VAR 0 2
84582: PUSH
84583: LD_VAR 0 3
84587: PUSH
84588: LD_VAR 0 4
84592: PUSH
84593: EMPTY
84594: LIST
84595: LIST
84596: LIST
84597: LIST
84598: PPUSH
84599: CALL 22238 0 3
84603: ST_TO_ADDR
// end ;
84604: LD_VAR 0 5
84608: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
84609: LD_INT 0
84611: PPUSH
// if not mc_bases [ base ] then
84612: LD_EXP 63
84616: PUSH
84617: LD_VAR 0 1
84621: ARRAY
84622: NOT
84623: IFFALSE 84627
// exit ;
84625: GO 84652
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
84627: LD_ADDR_EXP 100
84631: PUSH
84632: LD_EXP 100
84636: PPUSH
84637: LD_VAR 0 1
84641: PPUSH
84642: LD_VAR 0 2
84646: PPUSH
84647: CALL_OW 1
84651: ST_TO_ADDR
// end ;
84652: LD_VAR 0 3
84656: RET
// export function MC_GetMinesField ( base ) ; begin
84657: LD_INT 0
84659: PPUSH
// result := mc_mines [ base ] ;
84660: LD_ADDR_VAR 0 2
84664: PUSH
84665: LD_EXP 76
84669: PUSH
84670: LD_VAR 0 1
84674: ARRAY
84675: ST_TO_ADDR
// end ;
84676: LD_VAR 0 2
84680: RET
// export function MC_GetProduceList ( base ) ; begin
84681: LD_INT 0
84683: PPUSH
// result := mc_produce [ base ] ;
84684: LD_ADDR_VAR 0 2
84688: PUSH
84689: LD_EXP 84
84693: PUSH
84694: LD_VAR 0 1
84698: ARRAY
84699: ST_TO_ADDR
// end ;
84700: LD_VAR 0 2
84704: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
84705: LD_INT 0
84707: PPUSH
84708: PPUSH
// if not mc_bases then
84709: LD_EXP 63
84713: NOT
84714: IFFALSE 84718
// exit ;
84716: GO 84783
// if mc_bases [ base ] then
84718: LD_EXP 63
84722: PUSH
84723: LD_VAR 0 1
84727: ARRAY
84728: IFFALSE 84783
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
84730: LD_ADDR_VAR 0 3
84734: PUSH
84735: LD_EXP 63
84739: PUSH
84740: LD_VAR 0 1
84744: ARRAY
84745: PPUSH
84746: LD_INT 30
84748: PUSH
84749: LD_VAR 0 2
84753: PUSH
84754: EMPTY
84755: LIST
84756: LIST
84757: PPUSH
84758: CALL_OW 72
84762: ST_TO_ADDR
// if result then
84763: LD_VAR 0 3
84767: IFFALSE 84783
// result := result [ 1 ] ;
84769: LD_ADDR_VAR 0 3
84773: PUSH
84774: LD_VAR 0 3
84778: PUSH
84779: LD_INT 1
84781: ARRAY
84782: ST_TO_ADDR
// end ; end ;
84783: LD_VAR 0 3
84787: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
84788: LD_INT 0
84790: PPUSH
84791: PPUSH
// if not mc_bases then
84792: LD_EXP 63
84796: NOT
84797: IFFALSE 84801
// exit ;
84799: GO 84846
// if mc_bases [ base ] then
84801: LD_EXP 63
84805: PUSH
84806: LD_VAR 0 1
84810: ARRAY
84811: IFFALSE 84846
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
84813: LD_ADDR_VAR 0 3
84817: PUSH
84818: LD_EXP 63
84822: PUSH
84823: LD_VAR 0 1
84827: ARRAY
84828: PPUSH
84829: LD_INT 30
84831: PUSH
84832: LD_VAR 0 2
84836: PUSH
84837: EMPTY
84838: LIST
84839: LIST
84840: PPUSH
84841: CALL_OW 72
84845: ST_TO_ADDR
// end ;
84846: LD_VAR 0 3
84850: RET
// export function MC_SetTame ( base , area ) ; begin
84851: LD_INT 0
84853: PPUSH
// if not mc_bases or not base then
84854: LD_EXP 63
84858: NOT
84859: PUSH
84860: LD_VAR 0 1
84864: NOT
84865: OR
84866: IFFALSE 84870
// exit ;
84868: GO 84895
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
84870: LD_ADDR_EXP 91
84874: PUSH
84875: LD_EXP 91
84879: PPUSH
84880: LD_VAR 0 1
84884: PPUSH
84885: LD_VAR 0 2
84889: PPUSH
84890: CALL_OW 1
84894: ST_TO_ADDR
// end ;
84895: LD_VAR 0 3
84899: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
84900: LD_INT 0
84902: PPUSH
84903: PPUSH
// if not mc_bases or not base then
84904: LD_EXP 63
84908: NOT
84909: PUSH
84910: LD_VAR 0 1
84914: NOT
84915: OR
84916: IFFALSE 84920
// exit ;
84918: GO 85022
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
84920: LD_ADDR_VAR 0 4
84924: PUSH
84925: LD_EXP 63
84929: PUSH
84930: LD_VAR 0 1
84934: ARRAY
84935: PPUSH
84936: LD_INT 30
84938: PUSH
84939: LD_VAR 0 2
84943: PUSH
84944: EMPTY
84945: LIST
84946: LIST
84947: PPUSH
84948: CALL_OW 72
84952: ST_TO_ADDR
// if not tmp then
84953: LD_VAR 0 4
84957: NOT
84958: IFFALSE 84962
// exit ;
84960: GO 85022
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
84962: LD_ADDR_EXP 95
84966: PUSH
84967: LD_EXP 95
84971: PPUSH
84972: LD_VAR 0 1
84976: PPUSH
84977: LD_EXP 95
84981: PUSH
84982: LD_VAR 0 1
84986: ARRAY
84987: PPUSH
84988: LD_EXP 95
84992: PUSH
84993: LD_VAR 0 1
84997: ARRAY
84998: PUSH
84999: LD_INT 1
85001: PLUS
85002: PPUSH
85003: LD_VAR 0 4
85007: PUSH
85008: LD_INT 1
85010: ARRAY
85011: PPUSH
85012: CALL_OW 2
85016: PPUSH
85017: CALL_OW 1
85021: ST_TO_ADDR
// end ;
85022: LD_VAR 0 3
85026: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
85027: LD_INT 0
85029: PPUSH
85030: PPUSH
// if not mc_bases or not base or not kinds then
85031: LD_EXP 63
85035: NOT
85036: PUSH
85037: LD_VAR 0 1
85041: NOT
85042: OR
85043: PUSH
85044: LD_VAR 0 2
85048: NOT
85049: OR
85050: IFFALSE 85054
// exit ;
85052: GO 85115
// for i in kinds do
85054: LD_ADDR_VAR 0 4
85058: PUSH
85059: LD_VAR 0 2
85063: PUSH
85064: FOR_IN
85065: IFFALSE 85113
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
85067: LD_ADDR_EXP 97
85071: PUSH
85072: LD_EXP 97
85076: PPUSH
85077: LD_VAR 0 1
85081: PUSH
85082: LD_EXP 97
85086: PUSH
85087: LD_VAR 0 1
85091: ARRAY
85092: PUSH
85093: LD_INT 1
85095: PLUS
85096: PUSH
85097: EMPTY
85098: LIST
85099: LIST
85100: PPUSH
85101: LD_VAR 0 4
85105: PPUSH
85106: CALL 22238 0 3
85110: ST_TO_ADDR
85111: GO 85064
85113: POP
85114: POP
// end ;
85115: LD_VAR 0 3
85119: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
85120: LD_INT 0
85122: PPUSH
// if not mc_bases or not base or not areas then
85123: LD_EXP 63
85127: NOT
85128: PUSH
85129: LD_VAR 0 1
85133: NOT
85134: OR
85135: PUSH
85136: LD_VAR 0 2
85140: NOT
85141: OR
85142: IFFALSE 85146
// exit ;
85144: GO 85171
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
85146: LD_ADDR_EXP 81
85150: PUSH
85151: LD_EXP 81
85155: PPUSH
85156: LD_VAR 0 1
85160: PPUSH
85161: LD_VAR 0 2
85165: PPUSH
85166: CALL_OW 1
85170: ST_TO_ADDR
// end ;
85171: LD_VAR 0 3
85175: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
85176: LD_INT 0
85178: PPUSH
// if not mc_bases or not base or not teleports_exit then
85179: LD_EXP 63
85183: NOT
85184: PUSH
85185: LD_VAR 0 1
85189: NOT
85190: OR
85191: PUSH
85192: LD_VAR 0 2
85196: NOT
85197: OR
85198: IFFALSE 85202
// exit ;
85200: GO 85227
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
85202: LD_ADDR_EXP 98
85206: PUSH
85207: LD_EXP 98
85211: PPUSH
85212: LD_VAR 0 1
85216: PPUSH
85217: LD_VAR 0 2
85221: PPUSH
85222: CALL_OW 1
85226: ST_TO_ADDR
// end ;
85227: LD_VAR 0 3
85231: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
85232: LD_INT 0
85234: PPUSH
85235: PPUSH
85236: PPUSH
// if not mc_bases or not base or not ext_list then
85237: LD_EXP 63
85241: NOT
85242: PUSH
85243: LD_VAR 0 1
85247: NOT
85248: OR
85249: PUSH
85250: LD_VAR 0 5
85254: NOT
85255: OR
85256: IFFALSE 85260
// exit ;
85258: GO 85433
// tmp := GetFacExtXYD ( x , y , d ) ;
85260: LD_ADDR_VAR 0 8
85264: PUSH
85265: LD_VAR 0 2
85269: PPUSH
85270: LD_VAR 0 3
85274: PPUSH
85275: LD_VAR 0 4
85279: PPUSH
85280: CALL 52601 0 3
85284: ST_TO_ADDR
// if not tmp then
85285: LD_VAR 0 8
85289: NOT
85290: IFFALSE 85294
// exit ;
85292: GO 85433
// for i in tmp do
85294: LD_ADDR_VAR 0 7
85298: PUSH
85299: LD_VAR 0 8
85303: PUSH
85304: FOR_IN
85305: IFFALSE 85431
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
85307: LD_ADDR_EXP 68
85311: PUSH
85312: LD_EXP 68
85316: PPUSH
85317: LD_VAR 0 1
85321: PPUSH
85322: LD_EXP 68
85326: PUSH
85327: LD_VAR 0 1
85331: ARRAY
85332: PPUSH
85333: LD_EXP 68
85337: PUSH
85338: LD_VAR 0 1
85342: ARRAY
85343: PUSH
85344: LD_INT 1
85346: PLUS
85347: PPUSH
85348: LD_VAR 0 5
85352: PUSH
85353: LD_INT 1
85355: ARRAY
85356: PUSH
85357: LD_VAR 0 7
85361: PUSH
85362: LD_INT 1
85364: ARRAY
85365: PUSH
85366: LD_VAR 0 7
85370: PUSH
85371: LD_INT 2
85373: ARRAY
85374: PUSH
85375: LD_VAR 0 7
85379: PUSH
85380: LD_INT 3
85382: ARRAY
85383: PUSH
85384: EMPTY
85385: LIST
85386: LIST
85387: LIST
85388: LIST
85389: PPUSH
85390: CALL_OW 2
85394: PPUSH
85395: CALL_OW 1
85399: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
85400: LD_ADDR_VAR 0 5
85404: PUSH
85405: LD_VAR 0 5
85409: PPUSH
85410: LD_INT 1
85412: PPUSH
85413: CALL_OW 3
85417: ST_TO_ADDR
// if not ext_list then
85418: LD_VAR 0 5
85422: NOT
85423: IFFALSE 85429
// exit ;
85425: POP
85426: POP
85427: GO 85433
// end ;
85429: GO 85304
85431: POP
85432: POP
// end ;
85433: LD_VAR 0 6
85437: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
85438: LD_INT 0
85440: PPUSH
// if not mc_bases or not base or not weapon_list then
85441: LD_EXP 63
85445: NOT
85446: PUSH
85447: LD_VAR 0 1
85451: NOT
85452: OR
85453: PUSH
85454: LD_VAR 0 2
85458: NOT
85459: OR
85460: IFFALSE 85464
// exit ;
85462: GO 85489
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
85464: LD_ADDR_EXP 102
85468: PUSH
85469: LD_EXP 102
85473: PPUSH
85474: LD_VAR 0 1
85478: PPUSH
85479: LD_VAR 0 2
85483: PPUSH
85484: CALL_OW 1
85488: ST_TO_ADDR
// end ;
85489: LD_VAR 0 3
85493: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
85494: LD_INT 0
85496: PPUSH
// if not mc_bases or not base or not tech_list then
85497: LD_EXP 63
85501: NOT
85502: PUSH
85503: LD_VAR 0 1
85507: NOT
85508: OR
85509: PUSH
85510: LD_VAR 0 2
85514: NOT
85515: OR
85516: IFFALSE 85520
// exit ;
85518: GO 85545
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
85520: LD_ADDR_EXP 90
85524: PUSH
85525: LD_EXP 90
85529: PPUSH
85530: LD_VAR 0 1
85534: PPUSH
85535: LD_VAR 0 2
85539: PPUSH
85540: CALL_OW 1
85544: ST_TO_ADDR
// end ;
85545: LD_VAR 0 3
85549: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
85550: LD_INT 0
85552: PPUSH
// if not mc_bases or not parking_area or not base then
85553: LD_EXP 63
85557: NOT
85558: PUSH
85559: LD_VAR 0 2
85563: NOT
85564: OR
85565: PUSH
85566: LD_VAR 0 1
85570: NOT
85571: OR
85572: IFFALSE 85576
// exit ;
85574: GO 85601
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
85576: LD_ADDR_EXP 87
85580: PUSH
85581: LD_EXP 87
85585: PPUSH
85586: LD_VAR 0 1
85590: PPUSH
85591: LD_VAR 0 2
85595: PPUSH
85596: CALL_OW 1
85600: ST_TO_ADDR
// end ;
85601: LD_VAR 0 3
85605: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
85606: LD_INT 0
85608: PPUSH
// if not mc_bases or not base or not scan_area then
85609: LD_EXP 63
85613: NOT
85614: PUSH
85615: LD_VAR 0 1
85619: NOT
85620: OR
85621: PUSH
85622: LD_VAR 0 2
85626: NOT
85627: OR
85628: IFFALSE 85632
// exit ;
85630: GO 85657
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
85632: LD_ADDR_EXP 88
85636: PUSH
85637: LD_EXP 88
85641: PPUSH
85642: LD_VAR 0 1
85646: PPUSH
85647: LD_VAR 0 2
85651: PPUSH
85652: CALL_OW 1
85656: ST_TO_ADDR
// end ;
85657: LD_VAR 0 3
85661: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
85662: LD_INT 0
85664: PPUSH
85665: PPUSH
// if not mc_bases or not base then
85666: LD_EXP 63
85670: NOT
85671: PUSH
85672: LD_VAR 0 1
85676: NOT
85677: OR
85678: IFFALSE 85682
// exit ;
85680: GO 85746
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
85682: LD_ADDR_VAR 0 3
85686: PUSH
85687: LD_INT 1
85689: PUSH
85690: LD_INT 2
85692: PUSH
85693: LD_INT 3
85695: PUSH
85696: LD_INT 4
85698: PUSH
85699: LD_INT 11
85701: PUSH
85702: EMPTY
85703: LIST
85704: LIST
85705: LIST
85706: LIST
85707: LIST
85708: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
85709: LD_ADDR_EXP 90
85713: PUSH
85714: LD_EXP 90
85718: PPUSH
85719: LD_VAR 0 1
85723: PPUSH
85724: LD_EXP 90
85728: PUSH
85729: LD_VAR 0 1
85733: ARRAY
85734: PUSH
85735: LD_VAR 0 3
85739: DIFF
85740: PPUSH
85741: CALL_OW 1
85745: ST_TO_ADDR
// end ;
85746: LD_VAR 0 2
85750: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
85751: LD_INT 0
85753: PPUSH
// result := mc_vehicles [ base ] ;
85754: LD_ADDR_VAR 0 3
85758: PUSH
85759: LD_EXP 82
85763: PUSH
85764: LD_VAR 0 1
85768: ARRAY
85769: ST_TO_ADDR
// if onlyCombat then
85770: LD_VAR 0 2
85774: IFFALSE 85946
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
85776: LD_ADDR_VAR 0 3
85780: PUSH
85781: LD_VAR 0 3
85785: PUSH
85786: LD_VAR 0 3
85790: PPUSH
85791: LD_INT 2
85793: PUSH
85794: LD_INT 34
85796: PUSH
85797: LD_INT 12
85799: PUSH
85800: EMPTY
85801: LIST
85802: LIST
85803: PUSH
85804: LD_INT 34
85806: PUSH
85807: LD_INT 51
85809: PUSH
85810: EMPTY
85811: LIST
85812: LIST
85813: PUSH
85814: LD_INT 34
85816: PUSH
85817: LD_INT 89
85819: PUSH
85820: EMPTY
85821: LIST
85822: LIST
85823: PUSH
85824: LD_INT 34
85826: PUSH
85827: LD_INT 32
85829: PUSH
85830: EMPTY
85831: LIST
85832: LIST
85833: PUSH
85834: LD_INT 34
85836: PUSH
85837: LD_INT 13
85839: PUSH
85840: EMPTY
85841: LIST
85842: LIST
85843: PUSH
85844: LD_INT 34
85846: PUSH
85847: LD_INT 52
85849: PUSH
85850: EMPTY
85851: LIST
85852: LIST
85853: PUSH
85854: LD_INT 34
85856: PUSH
85857: LD_INT 88
85859: PUSH
85860: EMPTY
85861: LIST
85862: LIST
85863: PUSH
85864: LD_INT 34
85866: PUSH
85867: LD_INT 14
85869: PUSH
85870: EMPTY
85871: LIST
85872: LIST
85873: PUSH
85874: LD_INT 34
85876: PUSH
85877: LD_INT 53
85879: PUSH
85880: EMPTY
85881: LIST
85882: LIST
85883: PUSH
85884: LD_INT 34
85886: PUSH
85887: LD_INT 98
85889: PUSH
85890: EMPTY
85891: LIST
85892: LIST
85893: PUSH
85894: LD_INT 34
85896: PUSH
85897: LD_INT 31
85899: PUSH
85900: EMPTY
85901: LIST
85902: LIST
85903: PUSH
85904: LD_INT 34
85906: PUSH
85907: LD_INT 48
85909: PUSH
85910: EMPTY
85911: LIST
85912: LIST
85913: PUSH
85914: LD_INT 34
85916: PUSH
85917: LD_INT 8
85919: PUSH
85920: EMPTY
85921: LIST
85922: LIST
85923: PUSH
85924: EMPTY
85925: LIST
85926: LIST
85927: LIST
85928: LIST
85929: LIST
85930: LIST
85931: LIST
85932: LIST
85933: LIST
85934: LIST
85935: LIST
85936: LIST
85937: LIST
85938: LIST
85939: PPUSH
85940: CALL_OW 72
85944: DIFF
85945: ST_TO_ADDR
// end ; end_of_file
85946: LD_VAR 0 3
85950: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
85951: LD_INT 0
85953: PPUSH
85954: PPUSH
85955: PPUSH
// if not mc_bases or not skirmish then
85956: LD_EXP 63
85960: NOT
85961: PUSH
85962: LD_EXP 61
85966: NOT
85967: OR
85968: IFFALSE 85972
// exit ;
85970: GO 86137
// for i = 1 to mc_bases do
85972: LD_ADDR_VAR 0 4
85976: PUSH
85977: DOUBLE
85978: LD_INT 1
85980: DEC
85981: ST_TO_ADDR
85982: LD_EXP 63
85986: PUSH
85987: FOR_TO
85988: IFFALSE 86135
// begin if sci in mc_bases [ i ] then
85990: LD_VAR 0 2
85994: PUSH
85995: LD_EXP 63
85999: PUSH
86000: LD_VAR 0 4
86004: ARRAY
86005: IN
86006: IFFALSE 86133
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
86008: LD_ADDR_EXP 92
86012: PUSH
86013: LD_EXP 92
86017: PPUSH
86018: LD_VAR 0 4
86022: PUSH
86023: LD_EXP 92
86027: PUSH
86028: LD_VAR 0 4
86032: ARRAY
86033: PUSH
86034: LD_INT 1
86036: PLUS
86037: PUSH
86038: EMPTY
86039: LIST
86040: LIST
86041: PPUSH
86042: LD_VAR 0 1
86046: PPUSH
86047: CALL 22238 0 3
86051: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
86052: LD_ADDR_VAR 0 5
86056: PUSH
86057: LD_EXP 63
86061: PUSH
86062: LD_VAR 0 4
86066: ARRAY
86067: PPUSH
86068: LD_INT 2
86070: PUSH
86071: LD_INT 30
86073: PUSH
86074: LD_INT 0
86076: PUSH
86077: EMPTY
86078: LIST
86079: LIST
86080: PUSH
86081: LD_INT 30
86083: PUSH
86084: LD_INT 1
86086: PUSH
86087: EMPTY
86088: LIST
86089: LIST
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: LIST
86095: PPUSH
86096: CALL_OW 72
86100: PPUSH
86101: LD_VAR 0 1
86105: PPUSH
86106: CALL_OW 74
86110: ST_TO_ADDR
// if tmp then
86111: LD_VAR 0 5
86115: IFFALSE 86131
// ComStandNearbyBuilding ( ape , tmp ) ;
86117: LD_VAR 0 1
86121: PPUSH
86122: LD_VAR 0 5
86126: PPUSH
86127: CALL 18840 0 2
// break ;
86131: GO 86135
// end ; end ;
86133: GO 85987
86135: POP
86136: POP
// end ;
86137: LD_VAR 0 3
86141: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
86142: LD_INT 0
86144: PPUSH
86145: PPUSH
86146: PPUSH
// if not mc_bases or not skirmish then
86147: LD_EXP 63
86151: NOT
86152: PUSH
86153: LD_EXP 61
86157: NOT
86158: OR
86159: IFFALSE 86163
// exit ;
86161: GO 86252
// for i = 1 to mc_bases do
86163: LD_ADDR_VAR 0 4
86167: PUSH
86168: DOUBLE
86169: LD_INT 1
86171: DEC
86172: ST_TO_ADDR
86173: LD_EXP 63
86177: PUSH
86178: FOR_TO
86179: IFFALSE 86250
// begin if building in mc_busy_turret_list [ i ] then
86181: LD_VAR 0 1
86185: PUSH
86186: LD_EXP 73
86190: PUSH
86191: LD_VAR 0 4
86195: ARRAY
86196: IN
86197: IFFALSE 86248
// begin tmp := mc_busy_turret_list [ i ] diff building ;
86199: LD_ADDR_VAR 0 5
86203: PUSH
86204: LD_EXP 73
86208: PUSH
86209: LD_VAR 0 4
86213: ARRAY
86214: PUSH
86215: LD_VAR 0 1
86219: DIFF
86220: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
86221: LD_ADDR_EXP 73
86225: PUSH
86226: LD_EXP 73
86230: PPUSH
86231: LD_VAR 0 4
86235: PPUSH
86236: LD_VAR 0 5
86240: PPUSH
86241: CALL_OW 1
86245: ST_TO_ADDR
// break ;
86246: GO 86250
// end ; end ;
86248: GO 86178
86250: POP
86251: POP
// end ;
86252: LD_VAR 0 3
86256: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
86257: LD_INT 0
86259: PPUSH
86260: PPUSH
86261: PPUSH
// if not mc_bases or not skirmish then
86262: LD_EXP 63
86266: NOT
86267: PUSH
86268: LD_EXP 61
86272: NOT
86273: OR
86274: IFFALSE 86278
// exit ;
86276: GO 86477
// for i = 1 to mc_bases do
86278: LD_ADDR_VAR 0 5
86282: PUSH
86283: DOUBLE
86284: LD_INT 1
86286: DEC
86287: ST_TO_ADDR
86288: LD_EXP 63
86292: PUSH
86293: FOR_TO
86294: IFFALSE 86475
// if building in mc_bases [ i ] then
86296: LD_VAR 0 1
86300: PUSH
86301: LD_EXP 63
86305: PUSH
86306: LD_VAR 0 5
86310: ARRAY
86311: IN
86312: IFFALSE 86473
// begin tmp := mc_bases [ i ] diff building ;
86314: LD_ADDR_VAR 0 6
86318: PUSH
86319: LD_EXP 63
86323: PUSH
86324: LD_VAR 0 5
86328: ARRAY
86329: PUSH
86330: LD_VAR 0 1
86334: DIFF
86335: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
86336: LD_ADDR_EXP 63
86340: PUSH
86341: LD_EXP 63
86345: PPUSH
86346: LD_VAR 0 5
86350: PPUSH
86351: LD_VAR 0 6
86355: PPUSH
86356: CALL_OW 1
86360: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
86361: LD_VAR 0 1
86365: PUSH
86366: LD_EXP 71
86370: PUSH
86371: LD_VAR 0 5
86375: ARRAY
86376: IN
86377: IFFALSE 86416
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
86379: LD_ADDR_EXP 71
86383: PUSH
86384: LD_EXP 71
86388: PPUSH
86389: LD_VAR 0 5
86393: PPUSH
86394: LD_EXP 71
86398: PUSH
86399: LD_VAR 0 5
86403: ARRAY
86404: PUSH
86405: LD_VAR 0 1
86409: DIFF
86410: PPUSH
86411: CALL_OW 1
86415: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
86416: LD_VAR 0 1
86420: PUSH
86421: LD_EXP 72
86425: PUSH
86426: LD_VAR 0 5
86430: ARRAY
86431: IN
86432: IFFALSE 86471
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
86434: LD_ADDR_EXP 72
86438: PUSH
86439: LD_EXP 72
86443: PPUSH
86444: LD_VAR 0 5
86448: PPUSH
86449: LD_EXP 72
86453: PUSH
86454: LD_VAR 0 5
86458: ARRAY
86459: PUSH
86460: LD_VAR 0 1
86464: DIFF
86465: PPUSH
86466: CALL_OW 1
86470: ST_TO_ADDR
// break ;
86471: GO 86475
// end ;
86473: GO 86293
86475: POP
86476: POP
// end ;
86477: LD_VAR 0 4
86481: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
86482: LD_INT 0
86484: PPUSH
86485: PPUSH
86486: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
86487: LD_EXP 63
86491: NOT
86492: PUSH
86493: LD_EXP 61
86497: NOT
86498: OR
86499: PUSH
86500: LD_VAR 0 3
86504: PUSH
86505: LD_EXP 89
86509: IN
86510: NOT
86511: OR
86512: IFFALSE 86516
// exit ;
86514: GO 86639
// for i = 1 to mc_vehicles do
86516: LD_ADDR_VAR 0 6
86520: PUSH
86521: DOUBLE
86522: LD_INT 1
86524: DEC
86525: ST_TO_ADDR
86526: LD_EXP 82
86530: PUSH
86531: FOR_TO
86532: IFFALSE 86637
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
86534: LD_VAR 0 2
86538: PUSH
86539: LD_EXP 82
86543: PUSH
86544: LD_VAR 0 6
86548: ARRAY
86549: IN
86550: PUSH
86551: LD_VAR 0 1
86555: PUSH
86556: LD_EXP 82
86560: PUSH
86561: LD_VAR 0 6
86565: ARRAY
86566: IN
86567: OR
86568: IFFALSE 86635
// begin tmp := mc_vehicles [ i ] diff old ;
86570: LD_ADDR_VAR 0 7
86574: PUSH
86575: LD_EXP 82
86579: PUSH
86580: LD_VAR 0 6
86584: ARRAY
86585: PUSH
86586: LD_VAR 0 2
86590: DIFF
86591: ST_TO_ADDR
// tmp := tmp diff new ;
86592: LD_ADDR_VAR 0 7
86596: PUSH
86597: LD_VAR 0 7
86601: PUSH
86602: LD_VAR 0 1
86606: DIFF
86607: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
86608: LD_ADDR_EXP 82
86612: PUSH
86613: LD_EXP 82
86617: PPUSH
86618: LD_VAR 0 6
86622: PPUSH
86623: LD_VAR 0 7
86627: PPUSH
86628: CALL_OW 1
86632: ST_TO_ADDR
// break ;
86633: GO 86637
// end ;
86635: GO 86531
86637: POP
86638: POP
// end ;
86639: LD_VAR 0 5
86643: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
86644: LD_INT 0
86646: PPUSH
86647: PPUSH
86648: PPUSH
86649: PPUSH
// if not mc_bases or not skirmish then
86650: LD_EXP 63
86654: NOT
86655: PUSH
86656: LD_EXP 61
86660: NOT
86661: OR
86662: IFFALSE 86666
// exit ;
86664: GO 87086
// repeat wait ( 0 0$1 ) ;
86666: LD_INT 35
86668: PPUSH
86669: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
86673: LD_EXP 107
86677: NOT
86678: IFFALSE 86666
// mc_block_vehicle_constructed_thread := true ;
86680: LD_ADDR_EXP 107
86684: PUSH
86685: LD_INT 1
86687: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
86688: LD_ADDR_VAR 0 5
86692: PUSH
86693: LD_VAR 0 1
86697: PPUSH
86698: CALL_OW 255
86702: ST_TO_ADDR
// for i = 1 to mc_bases do
86703: LD_ADDR_VAR 0 4
86707: PUSH
86708: DOUBLE
86709: LD_INT 1
86711: DEC
86712: ST_TO_ADDR
86713: LD_EXP 63
86717: PUSH
86718: FOR_TO
86719: IFFALSE 87076
// begin if factory in mc_bases [ i ] then
86721: LD_VAR 0 2
86725: PUSH
86726: LD_EXP 63
86730: PUSH
86731: LD_VAR 0 4
86735: ARRAY
86736: IN
86737: IFFALSE 87074
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
86739: LD_EXP 85
86743: PUSH
86744: LD_VAR 0 4
86748: ARRAY
86749: PUSH
86750: LD_EXP 74
86754: PUSH
86755: LD_VAR 0 4
86759: ARRAY
86760: LESS
86761: PUSH
86762: LD_VAR 0 1
86766: PPUSH
86767: CALL_OW 264
86771: PUSH
86772: LD_INT 31
86774: PUSH
86775: LD_INT 32
86777: PUSH
86778: LD_INT 51
86780: PUSH
86781: LD_INT 89
86783: PUSH
86784: LD_INT 12
86786: PUSH
86787: LD_INT 30
86789: PUSH
86790: LD_INT 98
86792: PUSH
86793: LD_INT 11
86795: PUSH
86796: LD_INT 53
86798: PUSH
86799: LD_INT 14
86801: PUSH
86802: LD_INT 91
86804: PUSH
86805: LD_INT 29
86807: PUSH
86808: LD_INT 99
86810: PUSH
86811: LD_INT 13
86813: PUSH
86814: LD_INT 52
86816: PUSH
86817: LD_INT 88
86819: PUSH
86820: LD_INT 48
86822: PUSH
86823: LD_INT 8
86825: PUSH
86826: EMPTY
86827: LIST
86828: LIST
86829: LIST
86830: LIST
86831: LIST
86832: LIST
86833: LIST
86834: LIST
86835: LIST
86836: LIST
86837: LIST
86838: LIST
86839: LIST
86840: LIST
86841: LIST
86842: LIST
86843: LIST
86844: LIST
86845: IN
86846: NOT
86847: AND
86848: IFFALSE 86896
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
86850: LD_ADDR_EXP 85
86854: PUSH
86855: LD_EXP 85
86859: PPUSH
86860: LD_VAR 0 4
86864: PUSH
86865: LD_EXP 85
86869: PUSH
86870: LD_VAR 0 4
86874: ARRAY
86875: PUSH
86876: LD_INT 1
86878: PLUS
86879: PUSH
86880: EMPTY
86881: LIST
86882: LIST
86883: PPUSH
86884: LD_VAR 0 1
86888: PPUSH
86889: CALL 22238 0 3
86893: ST_TO_ADDR
86894: GO 86940
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
86896: LD_ADDR_EXP 82
86900: PUSH
86901: LD_EXP 82
86905: PPUSH
86906: LD_VAR 0 4
86910: PUSH
86911: LD_EXP 82
86915: PUSH
86916: LD_VAR 0 4
86920: ARRAY
86921: PUSH
86922: LD_INT 1
86924: PLUS
86925: PUSH
86926: EMPTY
86927: LIST
86928: LIST
86929: PPUSH
86930: LD_VAR 0 1
86934: PPUSH
86935: CALL 22238 0 3
86939: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
86940: LD_ADDR_EXP 107
86944: PUSH
86945: LD_INT 0
86947: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
86948: LD_VAR 0 1
86952: PPUSH
86953: CALL_OW 263
86957: PUSH
86958: LD_INT 2
86960: EQUAL
86961: IFFALSE 86990
// begin repeat wait ( 0 0$3 ) ;
86963: LD_INT 105
86965: PPUSH
86966: CALL_OW 67
// Connect ( vehicle ) ;
86970: LD_VAR 0 1
86974: PPUSH
86975: CALL 25584 0 1
// until IsControledBy ( vehicle ) ;
86979: LD_VAR 0 1
86983: PPUSH
86984: CALL_OW 312
86988: IFFALSE 86963
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
86990: LD_VAR 0 1
86994: PPUSH
86995: LD_EXP 87
86999: PUSH
87000: LD_VAR 0 4
87004: ARRAY
87005: PPUSH
87006: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
87010: LD_VAR 0 1
87014: PPUSH
87015: CALL_OW 263
87019: PUSH
87020: LD_INT 1
87022: NONEQUAL
87023: IFFALSE 87027
// break ;
87025: GO 87076
// repeat wait ( 0 0$1 ) ;
87027: LD_INT 35
87029: PPUSH
87030: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
87034: LD_VAR 0 1
87038: PPUSH
87039: LD_EXP 87
87043: PUSH
87044: LD_VAR 0 4
87048: ARRAY
87049: PPUSH
87050: CALL_OW 308
87054: IFFALSE 87027
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
87056: LD_VAR 0 1
87060: PPUSH
87061: CALL_OW 311
87065: PPUSH
87066: CALL_OW 121
// exit ;
87070: POP
87071: POP
87072: GO 87086
// end ; end ;
87074: GO 86718
87076: POP
87077: POP
// mc_block_vehicle_constructed_thread := false ;
87078: LD_ADDR_EXP 107
87082: PUSH
87083: LD_INT 0
87085: ST_TO_ADDR
// end ;
87086: LD_VAR 0 3
87090: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
87091: LD_INT 0
87093: PPUSH
87094: PPUSH
87095: PPUSH
87096: PPUSH
// if not mc_bases or not skirmish then
87097: LD_EXP 63
87101: NOT
87102: PUSH
87103: LD_EXP 61
87107: NOT
87108: OR
87109: IFFALSE 87113
// exit ;
87111: GO 87466
// repeat wait ( 0 0$1 ) ;
87113: LD_INT 35
87115: PPUSH
87116: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
87120: LD_VAR 0 2
87124: PPUSH
87125: LD_VAR 0 3
87129: PPUSH
87130: CALL_OW 284
87134: IFFALSE 87113
// if GetResourceTypeXY ( x , y ) = mat_artefact then
87136: LD_VAR 0 2
87140: PPUSH
87141: LD_VAR 0 3
87145: PPUSH
87146: CALL_OW 283
87150: PUSH
87151: LD_INT 4
87153: EQUAL
87154: IFFALSE 87158
// exit ;
87156: GO 87466
// for i = 1 to mc_bases do
87158: LD_ADDR_VAR 0 7
87162: PUSH
87163: DOUBLE
87164: LD_INT 1
87166: DEC
87167: ST_TO_ADDR
87168: LD_EXP 63
87172: PUSH
87173: FOR_TO
87174: IFFALSE 87464
// begin if mc_crates_area [ i ] then
87176: LD_EXP 81
87180: PUSH
87181: LD_VAR 0 7
87185: ARRAY
87186: IFFALSE 87297
// for j in mc_crates_area [ i ] do
87188: LD_ADDR_VAR 0 8
87192: PUSH
87193: LD_EXP 81
87197: PUSH
87198: LD_VAR 0 7
87202: ARRAY
87203: PUSH
87204: FOR_IN
87205: IFFALSE 87295
// if InArea ( x , y , j ) then
87207: LD_VAR 0 2
87211: PPUSH
87212: LD_VAR 0 3
87216: PPUSH
87217: LD_VAR 0 8
87221: PPUSH
87222: CALL_OW 309
87226: IFFALSE 87293
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
87228: LD_ADDR_EXP 79
87232: PUSH
87233: LD_EXP 79
87237: PPUSH
87238: LD_VAR 0 7
87242: PUSH
87243: LD_EXP 79
87247: PUSH
87248: LD_VAR 0 7
87252: ARRAY
87253: PUSH
87254: LD_INT 1
87256: PLUS
87257: PUSH
87258: EMPTY
87259: LIST
87260: LIST
87261: PPUSH
87262: LD_VAR 0 4
87266: PUSH
87267: LD_VAR 0 2
87271: PUSH
87272: LD_VAR 0 3
87276: PUSH
87277: EMPTY
87278: LIST
87279: LIST
87280: LIST
87281: PPUSH
87282: CALL 22238 0 3
87286: ST_TO_ADDR
// exit ;
87287: POP
87288: POP
87289: POP
87290: POP
87291: GO 87466
// end ;
87293: GO 87204
87295: POP
87296: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
87297: LD_ADDR_VAR 0 9
87301: PUSH
87302: LD_EXP 63
87306: PUSH
87307: LD_VAR 0 7
87311: ARRAY
87312: PPUSH
87313: LD_INT 2
87315: PUSH
87316: LD_INT 30
87318: PUSH
87319: LD_INT 0
87321: PUSH
87322: EMPTY
87323: LIST
87324: LIST
87325: PUSH
87326: LD_INT 30
87328: PUSH
87329: LD_INT 1
87331: PUSH
87332: EMPTY
87333: LIST
87334: LIST
87335: PUSH
87336: EMPTY
87337: LIST
87338: LIST
87339: LIST
87340: PPUSH
87341: CALL_OW 72
87345: ST_TO_ADDR
// if not depot then
87346: LD_VAR 0 9
87350: NOT
87351: IFFALSE 87355
// continue ;
87353: GO 87173
// for j in depot do
87355: LD_ADDR_VAR 0 8
87359: PUSH
87360: LD_VAR 0 9
87364: PUSH
87365: FOR_IN
87366: IFFALSE 87460
// if GetDistUnitXY ( j , x , y ) < 30 then
87368: LD_VAR 0 8
87372: PPUSH
87373: LD_VAR 0 2
87377: PPUSH
87378: LD_VAR 0 3
87382: PPUSH
87383: CALL_OW 297
87387: PUSH
87388: LD_INT 30
87390: LESS
87391: IFFALSE 87458
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
87393: LD_ADDR_EXP 79
87397: PUSH
87398: LD_EXP 79
87402: PPUSH
87403: LD_VAR 0 7
87407: PUSH
87408: LD_EXP 79
87412: PUSH
87413: LD_VAR 0 7
87417: ARRAY
87418: PUSH
87419: LD_INT 1
87421: PLUS
87422: PUSH
87423: EMPTY
87424: LIST
87425: LIST
87426: PPUSH
87427: LD_VAR 0 4
87431: PUSH
87432: LD_VAR 0 2
87436: PUSH
87437: LD_VAR 0 3
87441: PUSH
87442: EMPTY
87443: LIST
87444: LIST
87445: LIST
87446: PPUSH
87447: CALL 22238 0 3
87451: ST_TO_ADDR
// exit ;
87452: POP
87453: POP
87454: POP
87455: POP
87456: GO 87466
// end ;
87458: GO 87365
87460: POP
87461: POP
// end ;
87462: GO 87173
87464: POP
87465: POP
// end ;
87466: LD_VAR 0 6
87470: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
87471: LD_INT 0
87473: PPUSH
87474: PPUSH
87475: PPUSH
87476: PPUSH
// if not mc_bases or not skirmish then
87477: LD_EXP 63
87481: NOT
87482: PUSH
87483: LD_EXP 61
87487: NOT
87488: OR
87489: IFFALSE 87493
// exit ;
87491: GO 87770
// side := GetSide ( lab ) ;
87493: LD_ADDR_VAR 0 4
87497: PUSH
87498: LD_VAR 0 2
87502: PPUSH
87503: CALL_OW 255
87507: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
87508: LD_VAR 0 4
87512: PUSH
87513: LD_EXP 89
87517: IN
87518: NOT
87519: PUSH
87520: LD_EXP 90
87524: NOT
87525: OR
87526: PUSH
87527: LD_EXP 63
87531: NOT
87532: OR
87533: IFFALSE 87537
// exit ;
87535: GO 87770
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
87537: LD_ADDR_EXP 90
87541: PUSH
87542: LD_EXP 90
87546: PPUSH
87547: LD_VAR 0 4
87551: PPUSH
87552: LD_EXP 90
87556: PUSH
87557: LD_VAR 0 4
87561: ARRAY
87562: PUSH
87563: LD_VAR 0 1
87567: DIFF
87568: PPUSH
87569: CALL_OW 1
87573: ST_TO_ADDR
// for i = 1 to mc_bases do
87574: LD_ADDR_VAR 0 5
87578: PUSH
87579: DOUBLE
87580: LD_INT 1
87582: DEC
87583: ST_TO_ADDR
87584: LD_EXP 63
87588: PUSH
87589: FOR_TO
87590: IFFALSE 87768
// begin if lab in mc_bases [ i ] then
87592: LD_VAR 0 2
87596: PUSH
87597: LD_EXP 63
87601: PUSH
87602: LD_VAR 0 5
87606: ARRAY
87607: IN
87608: IFFALSE 87766
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
87610: LD_VAR 0 1
87614: PUSH
87615: LD_INT 11
87617: PUSH
87618: LD_INT 4
87620: PUSH
87621: LD_INT 3
87623: PUSH
87624: LD_INT 2
87626: PUSH
87627: EMPTY
87628: LIST
87629: LIST
87630: LIST
87631: LIST
87632: IN
87633: PUSH
87634: LD_EXP 93
87638: PUSH
87639: LD_VAR 0 5
87643: ARRAY
87644: AND
87645: IFFALSE 87766
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
87647: LD_ADDR_VAR 0 6
87651: PUSH
87652: LD_EXP 93
87656: PUSH
87657: LD_VAR 0 5
87661: ARRAY
87662: PUSH
87663: LD_INT 1
87665: ARRAY
87666: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
87667: LD_ADDR_EXP 93
87671: PUSH
87672: LD_EXP 93
87676: PPUSH
87677: LD_VAR 0 5
87681: PPUSH
87682: EMPTY
87683: PPUSH
87684: CALL_OW 1
87688: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
87689: LD_VAR 0 6
87693: PPUSH
87694: LD_INT 0
87696: PPUSH
87697: CALL_OW 109
// ComExitBuilding ( tmp ) ;
87701: LD_VAR 0 6
87705: PPUSH
87706: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
87710: LD_ADDR_EXP 92
87714: PUSH
87715: LD_EXP 92
87719: PPUSH
87720: LD_VAR 0 5
87724: PPUSH
87725: LD_EXP 92
87729: PUSH
87730: LD_VAR 0 5
87734: ARRAY
87735: PPUSH
87736: LD_INT 1
87738: PPUSH
87739: LD_VAR 0 6
87743: PPUSH
87744: CALL_OW 2
87748: PPUSH
87749: CALL_OW 1
87753: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
87754: LD_VAR 0 5
87758: PPUSH
87759: LD_INT 112
87761: PPUSH
87762: CALL 64220 0 2
// end ; end ; end ;
87766: GO 87589
87768: POP
87769: POP
// end ;
87770: LD_VAR 0 3
87774: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
87775: LD_INT 0
87777: PPUSH
87778: PPUSH
87779: PPUSH
87780: PPUSH
87781: PPUSH
87782: PPUSH
87783: PPUSH
87784: PPUSH
// if not mc_bases or not skirmish then
87785: LD_EXP 63
87789: NOT
87790: PUSH
87791: LD_EXP 61
87795: NOT
87796: OR
87797: IFFALSE 87801
// exit ;
87799: GO 89170
// for i = 1 to mc_bases do
87801: LD_ADDR_VAR 0 3
87805: PUSH
87806: DOUBLE
87807: LD_INT 1
87809: DEC
87810: ST_TO_ADDR
87811: LD_EXP 63
87815: PUSH
87816: FOR_TO
87817: IFFALSE 89168
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
87819: LD_VAR 0 1
87823: PUSH
87824: LD_EXP 63
87828: PUSH
87829: LD_VAR 0 3
87833: ARRAY
87834: IN
87835: PUSH
87836: LD_VAR 0 1
87840: PUSH
87841: LD_EXP 70
87845: PUSH
87846: LD_VAR 0 3
87850: ARRAY
87851: IN
87852: OR
87853: PUSH
87854: LD_VAR 0 1
87858: PUSH
87859: LD_EXP 85
87863: PUSH
87864: LD_VAR 0 3
87868: ARRAY
87869: IN
87870: OR
87871: PUSH
87872: LD_VAR 0 1
87876: PUSH
87877: LD_EXP 82
87881: PUSH
87882: LD_VAR 0 3
87886: ARRAY
87887: IN
87888: OR
87889: PUSH
87890: LD_VAR 0 1
87894: PUSH
87895: LD_EXP 92
87899: PUSH
87900: LD_VAR 0 3
87904: ARRAY
87905: IN
87906: OR
87907: PUSH
87908: LD_VAR 0 1
87912: PUSH
87913: LD_EXP 93
87917: PUSH
87918: LD_VAR 0 3
87922: ARRAY
87923: IN
87924: OR
87925: IFFALSE 89166
// begin if un in mc_ape [ i ] then
87927: LD_VAR 0 1
87931: PUSH
87932: LD_EXP 92
87936: PUSH
87937: LD_VAR 0 3
87941: ARRAY
87942: IN
87943: IFFALSE 87982
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
87945: LD_ADDR_EXP 92
87949: PUSH
87950: LD_EXP 92
87954: PPUSH
87955: LD_VAR 0 3
87959: PPUSH
87960: LD_EXP 92
87964: PUSH
87965: LD_VAR 0 3
87969: ARRAY
87970: PUSH
87971: LD_VAR 0 1
87975: DIFF
87976: PPUSH
87977: CALL_OW 1
87981: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
87982: LD_VAR 0 1
87986: PUSH
87987: LD_EXP 93
87991: PUSH
87992: LD_VAR 0 3
87996: ARRAY
87997: IN
87998: IFFALSE 88022
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
88000: LD_ADDR_EXP 93
88004: PUSH
88005: LD_EXP 93
88009: PPUSH
88010: LD_VAR 0 3
88014: PPUSH
88015: EMPTY
88016: PPUSH
88017: CALL_OW 1
88021: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
88022: LD_VAR 0 1
88026: PPUSH
88027: CALL_OW 247
88031: PUSH
88032: LD_INT 2
88034: EQUAL
88035: PUSH
88036: LD_VAR 0 1
88040: PPUSH
88041: CALL_OW 110
88045: PUSH
88046: LD_INT 20
88048: EQUAL
88049: PUSH
88050: LD_VAR 0 1
88054: PUSH
88055: LD_EXP 85
88059: PUSH
88060: LD_VAR 0 3
88064: ARRAY
88065: IN
88066: OR
88067: PUSH
88068: LD_VAR 0 1
88072: PPUSH
88073: CALL_OW 264
88077: PUSH
88078: LD_INT 12
88080: PUSH
88081: LD_INT 51
88083: PUSH
88084: LD_INT 89
88086: PUSH
88087: LD_INT 32
88089: PUSH
88090: LD_INT 13
88092: PUSH
88093: LD_INT 52
88095: PUSH
88096: LD_INT 31
88098: PUSH
88099: EMPTY
88100: LIST
88101: LIST
88102: LIST
88103: LIST
88104: LIST
88105: LIST
88106: LIST
88107: IN
88108: OR
88109: AND
88110: IFFALSE 88418
// begin if un in mc_defender [ i ] then
88112: LD_VAR 0 1
88116: PUSH
88117: LD_EXP 85
88121: PUSH
88122: LD_VAR 0 3
88126: ARRAY
88127: IN
88128: IFFALSE 88167
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
88130: LD_ADDR_EXP 85
88134: PUSH
88135: LD_EXP 85
88139: PPUSH
88140: LD_VAR 0 3
88144: PPUSH
88145: LD_EXP 85
88149: PUSH
88150: LD_VAR 0 3
88154: ARRAY
88155: PUSH
88156: LD_VAR 0 1
88160: DIFF
88161: PPUSH
88162: CALL_OW 1
88166: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
88167: LD_ADDR_VAR 0 8
88171: PUSH
88172: LD_VAR 0 3
88176: PPUSH
88177: LD_INT 3
88179: PPUSH
88180: CALL 84788 0 2
88184: ST_TO_ADDR
// if fac then
88185: LD_VAR 0 8
88189: IFFALSE 88418
// begin for j in fac do
88191: LD_ADDR_VAR 0 4
88195: PUSH
88196: LD_VAR 0 8
88200: PUSH
88201: FOR_IN
88202: IFFALSE 88416
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
88204: LD_ADDR_VAR 0 9
88208: PUSH
88209: LD_VAR 0 8
88213: PPUSH
88214: LD_VAR 0 1
88218: PPUSH
88219: CALL_OW 265
88223: PPUSH
88224: LD_VAR 0 1
88228: PPUSH
88229: CALL_OW 262
88233: PPUSH
88234: LD_VAR 0 1
88238: PPUSH
88239: CALL_OW 263
88243: PPUSH
88244: LD_VAR 0 1
88248: PPUSH
88249: CALL_OW 264
88253: PPUSH
88254: CALL 19736 0 5
88258: ST_TO_ADDR
// if components then
88259: LD_VAR 0 9
88263: IFFALSE 88414
// begin if GetWeapon ( un ) = ar_control_tower then
88265: LD_VAR 0 1
88269: PPUSH
88270: CALL_OW 264
88274: PUSH
88275: LD_INT 31
88277: EQUAL
88278: IFFALSE 88395
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
88280: LD_VAR 0 1
88284: PPUSH
88285: CALL_OW 311
88289: PPUSH
88290: LD_INT 0
88292: PPUSH
88293: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
88297: LD_ADDR_EXP 103
88301: PUSH
88302: LD_EXP 103
88306: PPUSH
88307: LD_VAR 0 3
88311: PPUSH
88312: LD_EXP 103
88316: PUSH
88317: LD_VAR 0 3
88321: ARRAY
88322: PUSH
88323: LD_VAR 0 1
88327: PPUSH
88328: CALL_OW 311
88332: DIFF
88333: PPUSH
88334: CALL_OW 1
88338: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
88339: LD_ADDR_VAR 0 7
88343: PUSH
88344: LD_EXP 84
88348: PUSH
88349: LD_VAR 0 3
88353: ARRAY
88354: PPUSH
88355: LD_INT 1
88357: PPUSH
88358: LD_VAR 0 9
88362: PPUSH
88363: CALL_OW 2
88367: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
88368: LD_ADDR_EXP 84
88372: PUSH
88373: LD_EXP 84
88377: PPUSH
88378: LD_VAR 0 3
88382: PPUSH
88383: LD_VAR 0 7
88387: PPUSH
88388: CALL_OW 1
88392: ST_TO_ADDR
// end else
88393: GO 88412
// MC_InsertProduceList ( i , [ components ] ) ;
88395: LD_VAR 0 3
88399: PPUSH
88400: LD_VAR 0 9
88404: PUSH
88405: EMPTY
88406: LIST
88407: PPUSH
88408: CALL 84333 0 2
// break ;
88412: GO 88416
// end ; end ;
88414: GO 88201
88416: POP
88417: POP
// end ; end ; if GetType ( un ) = unit_building then
88418: LD_VAR 0 1
88422: PPUSH
88423: CALL_OW 247
88427: PUSH
88428: LD_INT 3
88430: EQUAL
88431: IFFALSE 88834
// begin btype := GetBType ( un ) ;
88433: LD_ADDR_VAR 0 5
88437: PUSH
88438: LD_VAR 0 1
88442: PPUSH
88443: CALL_OW 266
88447: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
88448: LD_VAR 0 5
88452: PUSH
88453: LD_INT 29
88455: PUSH
88456: LD_INT 30
88458: PUSH
88459: EMPTY
88460: LIST
88461: LIST
88462: IN
88463: IFFALSE 88536
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
88465: LD_VAR 0 1
88469: PPUSH
88470: CALL_OW 250
88474: PPUSH
88475: LD_VAR 0 1
88479: PPUSH
88480: CALL_OW 251
88484: PPUSH
88485: LD_VAR 0 1
88489: PPUSH
88490: CALL_OW 255
88494: PPUSH
88495: CALL_OW 440
88499: NOT
88500: IFFALSE 88536
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
88502: LD_VAR 0 1
88506: PPUSH
88507: CALL_OW 250
88511: PPUSH
88512: LD_VAR 0 1
88516: PPUSH
88517: CALL_OW 251
88521: PPUSH
88522: LD_VAR 0 1
88526: PPUSH
88527: CALL_OW 255
88531: PPUSH
88532: CALL_OW 441
// end ; if btype = b_warehouse then
88536: LD_VAR 0 5
88540: PUSH
88541: LD_INT 1
88543: EQUAL
88544: IFFALSE 88562
// begin btype := b_depot ;
88546: LD_ADDR_VAR 0 5
88550: PUSH
88551: LD_INT 0
88553: ST_TO_ADDR
// pos := 1 ;
88554: LD_ADDR_VAR 0 6
88558: PUSH
88559: LD_INT 1
88561: ST_TO_ADDR
// end ; if btype = b_factory then
88562: LD_VAR 0 5
88566: PUSH
88567: LD_INT 3
88569: EQUAL
88570: IFFALSE 88588
// begin btype := b_workshop ;
88572: LD_ADDR_VAR 0 5
88576: PUSH
88577: LD_INT 2
88579: ST_TO_ADDR
// pos := 1 ;
88580: LD_ADDR_VAR 0 6
88584: PUSH
88585: LD_INT 1
88587: ST_TO_ADDR
// end ; if btype = b_barracks then
88588: LD_VAR 0 5
88592: PUSH
88593: LD_INT 5
88595: EQUAL
88596: IFFALSE 88606
// btype := b_armoury ;
88598: LD_ADDR_VAR 0 5
88602: PUSH
88603: LD_INT 4
88605: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
88606: LD_VAR 0 5
88610: PUSH
88611: LD_INT 7
88613: PUSH
88614: LD_INT 8
88616: PUSH
88617: EMPTY
88618: LIST
88619: LIST
88620: IN
88621: IFFALSE 88631
// btype := b_lab ;
88623: LD_ADDR_VAR 0 5
88627: PUSH
88628: LD_INT 6
88630: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
88631: LD_ADDR_EXP 68
88635: PUSH
88636: LD_EXP 68
88640: PPUSH
88641: LD_VAR 0 3
88645: PUSH
88646: LD_EXP 68
88650: PUSH
88651: LD_VAR 0 3
88655: ARRAY
88656: PUSH
88657: LD_INT 1
88659: PLUS
88660: PUSH
88661: EMPTY
88662: LIST
88663: LIST
88664: PPUSH
88665: LD_VAR 0 5
88669: PUSH
88670: LD_VAR 0 1
88674: PPUSH
88675: CALL_OW 250
88679: PUSH
88680: LD_VAR 0 1
88684: PPUSH
88685: CALL_OW 251
88689: PUSH
88690: LD_VAR 0 1
88694: PPUSH
88695: CALL_OW 254
88699: PUSH
88700: EMPTY
88701: LIST
88702: LIST
88703: LIST
88704: LIST
88705: PPUSH
88706: CALL 22238 0 3
88710: ST_TO_ADDR
// if pos = 1 then
88711: LD_VAR 0 6
88715: PUSH
88716: LD_INT 1
88718: EQUAL
88719: IFFALSE 88834
// begin tmp := mc_build_list [ i ] ;
88721: LD_ADDR_VAR 0 7
88725: PUSH
88726: LD_EXP 68
88730: PUSH
88731: LD_VAR 0 3
88735: ARRAY
88736: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
88737: LD_VAR 0 7
88741: PPUSH
88742: LD_INT 2
88744: PUSH
88745: LD_INT 30
88747: PUSH
88748: LD_INT 0
88750: PUSH
88751: EMPTY
88752: LIST
88753: LIST
88754: PUSH
88755: LD_INT 30
88757: PUSH
88758: LD_INT 1
88760: PUSH
88761: EMPTY
88762: LIST
88763: LIST
88764: PUSH
88765: EMPTY
88766: LIST
88767: LIST
88768: LIST
88769: PPUSH
88770: CALL_OW 72
88774: IFFALSE 88784
// pos := 2 ;
88776: LD_ADDR_VAR 0 6
88780: PUSH
88781: LD_INT 2
88783: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
88784: LD_ADDR_VAR 0 7
88788: PUSH
88789: LD_VAR 0 7
88793: PPUSH
88794: LD_VAR 0 6
88798: PPUSH
88799: LD_VAR 0 7
88803: PPUSH
88804: CALL 22564 0 3
88808: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
88809: LD_ADDR_EXP 68
88813: PUSH
88814: LD_EXP 68
88818: PPUSH
88819: LD_VAR 0 3
88823: PPUSH
88824: LD_VAR 0 7
88828: PPUSH
88829: CALL_OW 1
88833: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
88834: LD_VAR 0 1
88838: PUSH
88839: LD_EXP 63
88843: PUSH
88844: LD_VAR 0 3
88848: ARRAY
88849: IN
88850: IFFALSE 88889
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
88852: LD_ADDR_EXP 63
88856: PUSH
88857: LD_EXP 63
88861: PPUSH
88862: LD_VAR 0 3
88866: PPUSH
88867: LD_EXP 63
88871: PUSH
88872: LD_VAR 0 3
88876: ARRAY
88877: PUSH
88878: LD_VAR 0 1
88882: DIFF
88883: PPUSH
88884: CALL_OW 1
88888: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
88889: LD_VAR 0 1
88893: PUSH
88894: LD_EXP 70
88898: PUSH
88899: LD_VAR 0 3
88903: ARRAY
88904: IN
88905: IFFALSE 88944
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
88907: LD_ADDR_EXP 70
88911: PUSH
88912: LD_EXP 70
88916: PPUSH
88917: LD_VAR 0 3
88921: PPUSH
88922: LD_EXP 70
88926: PUSH
88927: LD_VAR 0 3
88931: ARRAY
88932: PUSH
88933: LD_VAR 0 1
88937: DIFF
88938: PPUSH
88939: CALL_OW 1
88943: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
88944: LD_VAR 0 1
88948: PUSH
88949: LD_EXP 82
88953: PUSH
88954: LD_VAR 0 3
88958: ARRAY
88959: IN
88960: IFFALSE 88999
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
88962: LD_ADDR_EXP 82
88966: PUSH
88967: LD_EXP 82
88971: PPUSH
88972: LD_VAR 0 3
88976: PPUSH
88977: LD_EXP 82
88981: PUSH
88982: LD_VAR 0 3
88986: ARRAY
88987: PUSH
88988: LD_VAR 0 1
88992: DIFF
88993: PPUSH
88994: CALL_OW 1
88998: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
88999: LD_VAR 0 1
89003: PUSH
89004: LD_EXP 85
89008: PUSH
89009: LD_VAR 0 3
89013: ARRAY
89014: IN
89015: IFFALSE 89054
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
89017: LD_ADDR_EXP 85
89021: PUSH
89022: LD_EXP 85
89026: PPUSH
89027: LD_VAR 0 3
89031: PPUSH
89032: LD_EXP 85
89036: PUSH
89037: LD_VAR 0 3
89041: ARRAY
89042: PUSH
89043: LD_VAR 0 1
89047: DIFF
89048: PPUSH
89049: CALL_OW 1
89053: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
89054: LD_VAR 0 1
89058: PUSH
89059: LD_EXP 72
89063: PUSH
89064: LD_VAR 0 3
89068: ARRAY
89069: IN
89070: IFFALSE 89109
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
89072: LD_ADDR_EXP 72
89076: PUSH
89077: LD_EXP 72
89081: PPUSH
89082: LD_VAR 0 3
89086: PPUSH
89087: LD_EXP 72
89091: PUSH
89092: LD_VAR 0 3
89096: ARRAY
89097: PUSH
89098: LD_VAR 0 1
89102: DIFF
89103: PPUSH
89104: CALL_OW 1
89108: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
89109: LD_VAR 0 1
89113: PUSH
89114: LD_EXP 71
89118: PUSH
89119: LD_VAR 0 3
89123: ARRAY
89124: IN
89125: IFFALSE 89164
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
89127: LD_ADDR_EXP 71
89131: PUSH
89132: LD_EXP 71
89136: PPUSH
89137: LD_VAR 0 3
89141: PPUSH
89142: LD_EXP 71
89146: PUSH
89147: LD_VAR 0 3
89151: ARRAY
89152: PUSH
89153: LD_VAR 0 1
89157: DIFF
89158: PPUSH
89159: CALL_OW 1
89163: ST_TO_ADDR
// end ; break ;
89164: GO 89168
// end ;
89166: GO 87816
89168: POP
89169: POP
// end ;
89170: LD_VAR 0 2
89174: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
89175: LD_INT 0
89177: PPUSH
89178: PPUSH
89179: PPUSH
// if not mc_bases or not skirmish then
89180: LD_EXP 63
89184: NOT
89185: PUSH
89186: LD_EXP 61
89190: NOT
89191: OR
89192: IFFALSE 89196
// exit ;
89194: GO 89411
// for i = 1 to mc_bases do
89196: LD_ADDR_VAR 0 3
89200: PUSH
89201: DOUBLE
89202: LD_INT 1
89204: DEC
89205: ST_TO_ADDR
89206: LD_EXP 63
89210: PUSH
89211: FOR_TO
89212: IFFALSE 89409
// begin if building in mc_construct_list [ i ] then
89214: LD_VAR 0 1
89218: PUSH
89219: LD_EXP 70
89223: PUSH
89224: LD_VAR 0 3
89228: ARRAY
89229: IN
89230: IFFALSE 89407
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
89232: LD_ADDR_EXP 70
89236: PUSH
89237: LD_EXP 70
89241: PPUSH
89242: LD_VAR 0 3
89246: PPUSH
89247: LD_EXP 70
89251: PUSH
89252: LD_VAR 0 3
89256: ARRAY
89257: PUSH
89258: LD_VAR 0 1
89262: DIFF
89263: PPUSH
89264: CALL_OW 1
89268: ST_TO_ADDR
// if building in mc_lab [ i ] then
89269: LD_VAR 0 1
89273: PUSH
89274: LD_EXP 96
89278: PUSH
89279: LD_VAR 0 3
89283: ARRAY
89284: IN
89285: IFFALSE 89340
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
89287: LD_ADDR_EXP 97
89291: PUSH
89292: LD_EXP 97
89296: PPUSH
89297: LD_VAR 0 3
89301: PPUSH
89302: LD_EXP 97
89306: PUSH
89307: LD_VAR 0 3
89311: ARRAY
89312: PPUSH
89313: LD_INT 1
89315: PPUSH
89316: LD_EXP 97
89320: PUSH
89321: LD_VAR 0 3
89325: ARRAY
89326: PPUSH
89327: LD_INT 0
89329: PPUSH
89330: CALL 21656 0 4
89334: PPUSH
89335: CALL_OW 1
89339: ST_TO_ADDR
// if not building in mc_bases [ i ] then
89340: LD_VAR 0 1
89344: PUSH
89345: LD_EXP 63
89349: PUSH
89350: LD_VAR 0 3
89354: ARRAY
89355: IN
89356: NOT
89357: IFFALSE 89403
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
89359: LD_ADDR_EXP 63
89363: PUSH
89364: LD_EXP 63
89368: PPUSH
89369: LD_VAR 0 3
89373: PUSH
89374: LD_EXP 63
89378: PUSH
89379: LD_VAR 0 3
89383: ARRAY
89384: PUSH
89385: LD_INT 1
89387: PLUS
89388: PUSH
89389: EMPTY
89390: LIST
89391: LIST
89392: PPUSH
89393: LD_VAR 0 1
89397: PPUSH
89398: CALL 22238 0 3
89402: ST_TO_ADDR
// exit ;
89403: POP
89404: POP
89405: GO 89411
// end ; end ;
89407: GO 89211
89409: POP
89410: POP
// end ;
89411: LD_VAR 0 2
89415: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
89416: LD_INT 0
89418: PPUSH
89419: PPUSH
89420: PPUSH
89421: PPUSH
89422: PPUSH
89423: PPUSH
89424: PPUSH
// if not mc_bases or not skirmish then
89425: LD_EXP 63
89429: NOT
89430: PUSH
89431: LD_EXP 61
89435: NOT
89436: OR
89437: IFFALSE 89441
// exit ;
89439: GO 90102
// for i = 1 to mc_bases do
89441: LD_ADDR_VAR 0 3
89445: PUSH
89446: DOUBLE
89447: LD_INT 1
89449: DEC
89450: ST_TO_ADDR
89451: LD_EXP 63
89455: PUSH
89456: FOR_TO
89457: IFFALSE 90100
// begin if building in mc_construct_list [ i ] then
89459: LD_VAR 0 1
89463: PUSH
89464: LD_EXP 70
89468: PUSH
89469: LD_VAR 0 3
89473: ARRAY
89474: IN
89475: IFFALSE 90098
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
89477: LD_ADDR_EXP 70
89481: PUSH
89482: LD_EXP 70
89486: PPUSH
89487: LD_VAR 0 3
89491: PPUSH
89492: LD_EXP 70
89496: PUSH
89497: LD_VAR 0 3
89501: ARRAY
89502: PUSH
89503: LD_VAR 0 1
89507: DIFF
89508: PPUSH
89509: CALL_OW 1
89513: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
89514: LD_ADDR_EXP 63
89518: PUSH
89519: LD_EXP 63
89523: PPUSH
89524: LD_VAR 0 3
89528: PUSH
89529: LD_EXP 63
89533: PUSH
89534: LD_VAR 0 3
89538: ARRAY
89539: PUSH
89540: LD_INT 1
89542: PLUS
89543: PUSH
89544: EMPTY
89545: LIST
89546: LIST
89547: PPUSH
89548: LD_VAR 0 1
89552: PPUSH
89553: CALL 22238 0 3
89557: ST_TO_ADDR
// btype := GetBType ( building ) ;
89558: LD_ADDR_VAR 0 5
89562: PUSH
89563: LD_VAR 0 1
89567: PPUSH
89568: CALL_OW 266
89572: ST_TO_ADDR
// side := GetSide ( building ) ;
89573: LD_ADDR_VAR 0 8
89577: PUSH
89578: LD_VAR 0 1
89582: PPUSH
89583: CALL_OW 255
89587: ST_TO_ADDR
// if btype = b_lab then
89588: LD_VAR 0 5
89592: PUSH
89593: LD_INT 6
89595: EQUAL
89596: IFFALSE 89646
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
89598: LD_ADDR_EXP 96
89602: PUSH
89603: LD_EXP 96
89607: PPUSH
89608: LD_VAR 0 3
89612: PUSH
89613: LD_EXP 96
89617: PUSH
89618: LD_VAR 0 3
89622: ARRAY
89623: PUSH
89624: LD_INT 1
89626: PLUS
89627: PUSH
89628: EMPTY
89629: LIST
89630: LIST
89631: PPUSH
89632: LD_VAR 0 1
89636: PPUSH
89637: CALL 22238 0 3
89641: ST_TO_ADDR
// exit ;
89642: POP
89643: POP
89644: GO 90102
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
89646: LD_VAR 0 5
89650: PUSH
89651: LD_INT 0
89653: PUSH
89654: LD_INT 2
89656: PUSH
89657: LD_INT 4
89659: PUSH
89660: EMPTY
89661: LIST
89662: LIST
89663: LIST
89664: IN
89665: IFFALSE 89789
// begin if btype = b_armoury then
89667: LD_VAR 0 5
89671: PUSH
89672: LD_INT 4
89674: EQUAL
89675: IFFALSE 89685
// btype := b_barracks ;
89677: LD_ADDR_VAR 0 5
89681: PUSH
89682: LD_INT 5
89684: ST_TO_ADDR
// if btype = b_depot then
89685: LD_VAR 0 5
89689: PUSH
89690: LD_INT 0
89692: EQUAL
89693: IFFALSE 89703
// btype := b_warehouse ;
89695: LD_ADDR_VAR 0 5
89699: PUSH
89700: LD_INT 1
89702: ST_TO_ADDR
// if btype = b_workshop then
89703: LD_VAR 0 5
89707: PUSH
89708: LD_INT 2
89710: EQUAL
89711: IFFALSE 89721
// btype := b_factory ;
89713: LD_ADDR_VAR 0 5
89717: PUSH
89718: LD_INT 3
89720: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
89721: LD_VAR 0 5
89725: PPUSH
89726: LD_VAR 0 8
89730: PPUSH
89731: CALL_OW 323
89735: PUSH
89736: LD_INT 1
89738: EQUAL
89739: IFFALSE 89785
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
89741: LD_ADDR_EXP 95
89745: PUSH
89746: LD_EXP 95
89750: PPUSH
89751: LD_VAR 0 3
89755: PUSH
89756: LD_EXP 95
89760: PUSH
89761: LD_VAR 0 3
89765: ARRAY
89766: PUSH
89767: LD_INT 1
89769: PLUS
89770: PUSH
89771: EMPTY
89772: LIST
89773: LIST
89774: PPUSH
89775: LD_VAR 0 1
89779: PPUSH
89780: CALL 22238 0 3
89784: ST_TO_ADDR
// exit ;
89785: POP
89786: POP
89787: GO 90102
// end ; if btype in [ b_bunker , b_turret ] then
89789: LD_VAR 0 5
89793: PUSH
89794: LD_INT 32
89796: PUSH
89797: LD_INT 33
89799: PUSH
89800: EMPTY
89801: LIST
89802: LIST
89803: IN
89804: IFFALSE 90094
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
89806: LD_ADDR_EXP 71
89810: PUSH
89811: LD_EXP 71
89815: PPUSH
89816: LD_VAR 0 3
89820: PUSH
89821: LD_EXP 71
89825: PUSH
89826: LD_VAR 0 3
89830: ARRAY
89831: PUSH
89832: LD_INT 1
89834: PLUS
89835: PUSH
89836: EMPTY
89837: LIST
89838: LIST
89839: PPUSH
89840: LD_VAR 0 1
89844: PPUSH
89845: CALL 22238 0 3
89849: ST_TO_ADDR
// if btype = b_bunker then
89850: LD_VAR 0 5
89854: PUSH
89855: LD_INT 32
89857: EQUAL
89858: IFFALSE 90094
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
89860: LD_ADDR_EXP 72
89864: PUSH
89865: LD_EXP 72
89869: PPUSH
89870: LD_VAR 0 3
89874: PUSH
89875: LD_EXP 72
89879: PUSH
89880: LD_VAR 0 3
89884: ARRAY
89885: PUSH
89886: LD_INT 1
89888: PLUS
89889: PUSH
89890: EMPTY
89891: LIST
89892: LIST
89893: PPUSH
89894: LD_VAR 0 1
89898: PPUSH
89899: CALL 22238 0 3
89903: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
89904: LD_ADDR_VAR 0 6
89908: PUSH
89909: LD_EXP 63
89913: PUSH
89914: LD_VAR 0 3
89918: ARRAY
89919: PPUSH
89920: LD_INT 25
89922: PUSH
89923: LD_INT 1
89925: PUSH
89926: EMPTY
89927: LIST
89928: LIST
89929: PUSH
89930: LD_INT 3
89932: PUSH
89933: LD_INT 54
89935: PUSH
89936: EMPTY
89937: LIST
89938: PUSH
89939: EMPTY
89940: LIST
89941: LIST
89942: PUSH
89943: EMPTY
89944: LIST
89945: LIST
89946: PPUSH
89947: CALL_OW 72
89951: ST_TO_ADDR
// if tmp then
89952: LD_VAR 0 6
89956: IFFALSE 89962
// exit ;
89958: POP
89959: POP
89960: GO 90102
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
89962: LD_ADDR_VAR 0 6
89966: PUSH
89967: LD_EXP 63
89971: PUSH
89972: LD_VAR 0 3
89976: ARRAY
89977: PPUSH
89978: LD_INT 2
89980: PUSH
89981: LD_INT 30
89983: PUSH
89984: LD_INT 4
89986: PUSH
89987: EMPTY
89988: LIST
89989: LIST
89990: PUSH
89991: LD_INT 30
89993: PUSH
89994: LD_INT 5
89996: PUSH
89997: EMPTY
89998: LIST
89999: LIST
90000: PUSH
90001: EMPTY
90002: LIST
90003: LIST
90004: LIST
90005: PPUSH
90006: CALL_OW 72
90010: ST_TO_ADDR
// if not tmp then
90011: LD_VAR 0 6
90015: NOT
90016: IFFALSE 90022
// exit ;
90018: POP
90019: POP
90020: GO 90102
// for j in tmp do
90022: LD_ADDR_VAR 0 4
90026: PUSH
90027: LD_VAR 0 6
90031: PUSH
90032: FOR_IN
90033: IFFALSE 90092
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
90035: LD_ADDR_VAR 0 7
90039: PUSH
90040: LD_VAR 0 4
90044: PPUSH
90045: CALL_OW 313
90049: PPUSH
90050: LD_INT 25
90052: PUSH
90053: LD_INT 1
90055: PUSH
90056: EMPTY
90057: LIST
90058: LIST
90059: PPUSH
90060: CALL_OW 72
90064: ST_TO_ADDR
// if units then
90065: LD_VAR 0 7
90069: IFFALSE 90090
// begin ComExitBuilding ( units [ 1 ] ) ;
90071: LD_VAR 0 7
90075: PUSH
90076: LD_INT 1
90078: ARRAY
90079: PPUSH
90080: CALL_OW 122
// exit ;
90084: POP
90085: POP
90086: POP
90087: POP
90088: GO 90102
// end ; end ;
90090: GO 90032
90092: POP
90093: POP
// end ; end ; exit ;
90094: POP
90095: POP
90096: GO 90102
// end ; end ;
90098: GO 89456
90100: POP
90101: POP
// end ;
90102: LD_VAR 0 2
90106: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
90107: LD_INT 0
90109: PPUSH
90110: PPUSH
90111: PPUSH
90112: PPUSH
90113: PPUSH
90114: PPUSH
90115: PPUSH
// if not mc_bases or not skirmish then
90116: LD_EXP 63
90120: NOT
90121: PUSH
90122: LD_EXP 61
90126: NOT
90127: OR
90128: IFFALSE 90132
// exit ;
90130: GO 90397
// btype := GetBType ( building ) ;
90132: LD_ADDR_VAR 0 6
90136: PUSH
90137: LD_VAR 0 1
90141: PPUSH
90142: CALL_OW 266
90146: ST_TO_ADDR
// x := GetX ( building ) ;
90147: LD_ADDR_VAR 0 7
90151: PUSH
90152: LD_VAR 0 1
90156: PPUSH
90157: CALL_OW 250
90161: ST_TO_ADDR
// y := GetY ( building ) ;
90162: LD_ADDR_VAR 0 8
90166: PUSH
90167: LD_VAR 0 1
90171: PPUSH
90172: CALL_OW 251
90176: ST_TO_ADDR
// d := GetDir ( building ) ;
90177: LD_ADDR_VAR 0 9
90181: PUSH
90182: LD_VAR 0 1
90186: PPUSH
90187: CALL_OW 254
90191: ST_TO_ADDR
// for i = 1 to mc_bases do
90192: LD_ADDR_VAR 0 4
90196: PUSH
90197: DOUBLE
90198: LD_INT 1
90200: DEC
90201: ST_TO_ADDR
90202: LD_EXP 63
90206: PUSH
90207: FOR_TO
90208: IFFALSE 90395
// begin if not mc_build_list [ i ] then
90210: LD_EXP 68
90214: PUSH
90215: LD_VAR 0 4
90219: ARRAY
90220: NOT
90221: IFFALSE 90225
// continue ;
90223: GO 90207
// for j := 1 to mc_build_list [ i ] do
90225: LD_ADDR_VAR 0 5
90229: PUSH
90230: DOUBLE
90231: LD_INT 1
90233: DEC
90234: ST_TO_ADDR
90235: LD_EXP 68
90239: PUSH
90240: LD_VAR 0 4
90244: ARRAY
90245: PUSH
90246: FOR_TO
90247: IFFALSE 90391
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
90249: LD_VAR 0 6
90253: PUSH
90254: LD_VAR 0 7
90258: PUSH
90259: LD_VAR 0 8
90263: PUSH
90264: LD_VAR 0 9
90268: PUSH
90269: EMPTY
90270: LIST
90271: LIST
90272: LIST
90273: LIST
90274: PPUSH
90275: LD_EXP 68
90279: PUSH
90280: LD_VAR 0 4
90284: ARRAY
90285: PUSH
90286: LD_VAR 0 5
90290: ARRAY
90291: PPUSH
90292: CALL 28795 0 2
90296: IFFALSE 90389
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
90298: LD_ADDR_EXP 68
90302: PUSH
90303: LD_EXP 68
90307: PPUSH
90308: LD_VAR 0 4
90312: PPUSH
90313: LD_EXP 68
90317: PUSH
90318: LD_VAR 0 4
90322: ARRAY
90323: PPUSH
90324: LD_VAR 0 5
90328: PPUSH
90329: CALL_OW 3
90333: PPUSH
90334: CALL_OW 1
90338: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
90339: LD_ADDR_EXP 70
90343: PUSH
90344: LD_EXP 70
90348: PPUSH
90349: LD_VAR 0 4
90353: PUSH
90354: LD_EXP 70
90358: PUSH
90359: LD_VAR 0 4
90363: ARRAY
90364: PUSH
90365: LD_INT 1
90367: PLUS
90368: PUSH
90369: EMPTY
90370: LIST
90371: LIST
90372: PPUSH
90373: LD_VAR 0 1
90377: PPUSH
90378: CALL 22238 0 3
90382: ST_TO_ADDR
// exit ;
90383: POP
90384: POP
90385: POP
90386: POP
90387: GO 90397
// end ;
90389: GO 90246
90391: POP
90392: POP
// end ;
90393: GO 90207
90395: POP
90396: POP
// end ;
90397: LD_VAR 0 3
90401: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
90402: LD_INT 0
90404: PPUSH
90405: PPUSH
90406: PPUSH
// if not mc_bases or not skirmish then
90407: LD_EXP 63
90411: NOT
90412: PUSH
90413: LD_EXP 61
90417: NOT
90418: OR
90419: IFFALSE 90423
// exit ;
90421: GO 90613
// for i = 1 to mc_bases do
90423: LD_ADDR_VAR 0 4
90427: PUSH
90428: DOUBLE
90429: LD_INT 1
90431: DEC
90432: ST_TO_ADDR
90433: LD_EXP 63
90437: PUSH
90438: FOR_TO
90439: IFFALSE 90526
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
90441: LD_VAR 0 1
90445: PUSH
90446: LD_EXP 71
90450: PUSH
90451: LD_VAR 0 4
90455: ARRAY
90456: IN
90457: PUSH
90458: LD_VAR 0 1
90462: PUSH
90463: LD_EXP 72
90467: PUSH
90468: LD_VAR 0 4
90472: ARRAY
90473: IN
90474: NOT
90475: AND
90476: IFFALSE 90524
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
90478: LD_ADDR_EXP 72
90482: PUSH
90483: LD_EXP 72
90487: PPUSH
90488: LD_VAR 0 4
90492: PUSH
90493: LD_EXP 72
90497: PUSH
90498: LD_VAR 0 4
90502: ARRAY
90503: PUSH
90504: LD_INT 1
90506: PLUS
90507: PUSH
90508: EMPTY
90509: LIST
90510: LIST
90511: PPUSH
90512: LD_VAR 0 1
90516: PPUSH
90517: CALL 22238 0 3
90521: ST_TO_ADDR
// break ;
90522: GO 90526
// end ; end ;
90524: GO 90438
90526: POP
90527: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
90528: LD_VAR 0 1
90532: PPUSH
90533: CALL_OW 257
90537: PUSH
90538: LD_EXP 89
90542: IN
90543: PUSH
90544: LD_VAR 0 1
90548: PPUSH
90549: CALL_OW 266
90553: PUSH
90554: LD_INT 5
90556: EQUAL
90557: AND
90558: PUSH
90559: LD_VAR 0 2
90563: PPUSH
90564: CALL_OW 110
90568: PUSH
90569: LD_INT 18
90571: NONEQUAL
90572: AND
90573: IFFALSE 90613
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
90575: LD_VAR 0 2
90579: PPUSH
90580: CALL_OW 257
90584: PUSH
90585: LD_INT 5
90587: PUSH
90588: LD_INT 8
90590: PUSH
90591: LD_INT 9
90593: PUSH
90594: EMPTY
90595: LIST
90596: LIST
90597: LIST
90598: IN
90599: IFFALSE 90613
// SetClass ( unit , 1 ) ;
90601: LD_VAR 0 2
90605: PPUSH
90606: LD_INT 1
90608: PPUSH
90609: CALL_OW 336
// end ;
90613: LD_VAR 0 3
90617: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
90618: LD_INT 0
90620: PPUSH
90621: PPUSH
// if not mc_bases or not skirmish then
90622: LD_EXP 63
90626: NOT
90627: PUSH
90628: LD_EXP 61
90632: NOT
90633: OR
90634: IFFALSE 90638
// exit ;
90636: GO 90754
// if GetLives ( abandoned_vehicle ) > 250 then
90638: LD_VAR 0 2
90642: PPUSH
90643: CALL_OW 256
90647: PUSH
90648: LD_INT 250
90650: GREATER
90651: IFFALSE 90655
// exit ;
90653: GO 90754
// for i = 1 to mc_bases do
90655: LD_ADDR_VAR 0 6
90659: PUSH
90660: DOUBLE
90661: LD_INT 1
90663: DEC
90664: ST_TO_ADDR
90665: LD_EXP 63
90669: PUSH
90670: FOR_TO
90671: IFFALSE 90752
// begin if driver in mc_bases [ i ] then
90673: LD_VAR 0 1
90677: PUSH
90678: LD_EXP 63
90682: PUSH
90683: LD_VAR 0 6
90687: ARRAY
90688: IN
90689: IFFALSE 90750
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
90691: LD_VAR 0 1
90695: PPUSH
90696: LD_EXP 63
90700: PUSH
90701: LD_VAR 0 6
90705: ARRAY
90706: PPUSH
90707: LD_INT 2
90709: PUSH
90710: LD_INT 30
90712: PUSH
90713: LD_INT 0
90715: PUSH
90716: EMPTY
90717: LIST
90718: LIST
90719: PUSH
90720: LD_INT 30
90722: PUSH
90723: LD_INT 1
90725: PUSH
90726: EMPTY
90727: LIST
90728: LIST
90729: PUSH
90730: EMPTY
90731: LIST
90732: LIST
90733: LIST
90734: PPUSH
90735: CALL_OW 72
90739: PUSH
90740: LD_INT 1
90742: ARRAY
90743: PPUSH
90744: CALL 55844 0 2
// break ;
90748: GO 90752
// end ; end ;
90750: GO 90670
90752: POP
90753: POP
// end ; end_of_file end_of_file
90754: LD_VAR 0 5
90758: RET
// export globalGameSaveCounter ; every 0 0$1 do
90759: GO 90761
90761: DISABLE
// begin enable ;
90762: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
90763: LD_STRING updateTimer(
90765: PUSH
90766: LD_OWVAR 1
90770: STR
90771: PUSH
90772: LD_STRING );
90774: STR
90775: PPUSH
90776: CALL_OW 559
// end ;
90780: END
// every 0 0$1 do
90781: GO 90783
90783: DISABLE
// begin globalGameSaveCounter := 0 ;
90784: LD_ADDR_EXP 108
90788: PUSH
90789: LD_INT 0
90791: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
90792: LD_STRING setGameSaveCounter(0)
90794: PPUSH
90795: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
90799: LD_STRING initStreamRollete();
90801: PPUSH
90802: CALL_OW 559
// InitStreamMode ;
90806: CALL 92149 0 0
// DefineStreamItems ( false ) ;
90810: LD_INT 0
90812: PPUSH
90813: CALL 92613 0 1
// end ;
90817: END
// export function SOS_MapStart ( ) ; begin
90818: LD_INT 0
90820: PPUSH
// if streamModeActive then
90821: LD_EXP 109
90825: IFFALSE 90834
// DefineStreamItems ( true ) ;
90827: LD_INT 1
90829: PPUSH
90830: CALL 92613 0 1
// UpdateLuaVariables ( ) ;
90834: CALL 90851 0 0
// UpdateFactoryWaypoints ( ) ;
90838: CALL 105482 0 0
// UpdateWarehouseGatheringPoints ( ) ;
90842: CALL 105739 0 0
// end ;
90846: LD_VAR 0 1
90850: RET
// function UpdateLuaVariables ( ) ; begin
90851: LD_INT 0
90853: PPUSH
// if globalGameSaveCounter then
90854: LD_EXP 108
90858: IFFALSE 90892
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
90860: LD_ADDR_EXP 108
90864: PUSH
90865: LD_EXP 108
90869: PPUSH
90870: CALL 56328 0 1
90874: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
90875: LD_STRING setGameSaveCounter(
90877: PUSH
90878: LD_EXP 108
90882: STR
90883: PUSH
90884: LD_STRING )
90886: STR
90887: PPUSH
90888: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
90892: LD_STRING setGameDifficulty(
90894: PUSH
90895: LD_OWVAR 67
90899: STR
90900: PUSH
90901: LD_STRING )
90903: STR
90904: PPUSH
90905: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
90909: LD_STRING displayDifficulty(
90911: PUSH
90912: LD_OWVAR 67
90916: STR
90917: PUSH
90918: LD_STRING )
90920: STR
90921: PPUSH
90922: CALL_OW 559
// end ;
90926: LD_VAR 0 1
90930: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90931: LD_INT 0
90933: PPUSH
// if p2 = stream_mode then
90934: LD_VAR 0 2
90938: PUSH
90939: LD_INT 100
90941: EQUAL
90942: IFFALSE 91945
// begin if not StreamModeActive then
90944: LD_EXP 109
90948: NOT
90949: IFFALSE 90959
// StreamModeActive := true ;
90951: LD_ADDR_EXP 109
90955: PUSH
90956: LD_INT 1
90958: ST_TO_ADDR
// if p3 = 0 then
90959: LD_VAR 0 3
90963: PUSH
90964: LD_INT 0
90966: EQUAL
90967: IFFALSE 90973
// InitStreamMode ;
90969: CALL 92149 0 0
// if p3 = 1 then
90973: LD_VAR 0 3
90977: PUSH
90978: LD_INT 1
90980: EQUAL
90981: IFFALSE 90991
// sRocket := true ;
90983: LD_ADDR_EXP 114
90987: PUSH
90988: LD_INT 1
90990: ST_TO_ADDR
// if p3 = 2 then
90991: LD_VAR 0 3
90995: PUSH
90996: LD_INT 2
90998: EQUAL
90999: IFFALSE 91009
// sSpeed := true ;
91001: LD_ADDR_EXP 113
91005: PUSH
91006: LD_INT 1
91008: ST_TO_ADDR
// if p3 = 3 then
91009: LD_VAR 0 3
91013: PUSH
91014: LD_INT 3
91016: EQUAL
91017: IFFALSE 91027
// sEngine := true ;
91019: LD_ADDR_EXP 115
91023: PUSH
91024: LD_INT 1
91026: ST_TO_ADDR
// if p3 = 4 then
91027: LD_VAR 0 3
91031: PUSH
91032: LD_INT 4
91034: EQUAL
91035: IFFALSE 91045
// sSpec := true ;
91037: LD_ADDR_EXP 112
91041: PUSH
91042: LD_INT 1
91044: ST_TO_ADDR
// if p3 = 5 then
91045: LD_VAR 0 3
91049: PUSH
91050: LD_INT 5
91052: EQUAL
91053: IFFALSE 91063
// sLevel := true ;
91055: LD_ADDR_EXP 116
91059: PUSH
91060: LD_INT 1
91062: ST_TO_ADDR
// if p3 = 6 then
91063: LD_VAR 0 3
91067: PUSH
91068: LD_INT 6
91070: EQUAL
91071: IFFALSE 91081
// sArmoury := true ;
91073: LD_ADDR_EXP 117
91077: PUSH
91078: LD_INT 1
91080: ST_TO_ADDR
// if p3 = 7 then
91081: LD_VAR 0 3
91085: PUSH
91086: LD_INT 7
91088: EQUAL
91089: IFFALSE 91099
// sRadar := true ;
91091: LD_ADDR_EXP 118
91095: PUSH
91096: LD_INT 1
91098: ST_TO_ADDR
// if p3 = 8 then
91099: LD_VAR 0 3
91103: PUSH
91104: LD_INT 8
91106: EQUAL
91107: IFFALSE 91117
// sBunker := true ;
91109: LD_ADDR_EXP 119
91113: PUSH
91114: LD_INT 1
91116: ST_TO_ADDR
// if p3 = 9 then
91117: LD_VAR 0 3
91121: PUSH
91122: LD_INT 9
91124: EQUAL
91125: IFFALSE 91135
// sHack := true ;
91127: LD_ADDR_EXP 120
91131: PUSH
91132: LD_INT 1
91134: ST_TO_ADDR
// if p3 = 10 then
91135: LD_VAR 0 3
91139: PUSH
91140: LD_INT 10
91142: EQUAL
91143: IFFALSE 91153
// sFire := true ;
91145: LD_ADDR_EXP 121
91149: PUSH
91150: LD_INT 1
91152: ST_TO_ADDR
// if p3 = 11 then
91153: LD_VAR 0 3
91157: PUSH
91158: LD_INT 11
91160: EQUAL
91161: IFFALSE 91171
// sRefresh := true ;
91163: LD_ADDR_EXP 122
91167: PUSH
91168: LD_INT 1
91170: ST_TO_ADDR
// if p3 = 12 then
91171: LD_VAR 0 3
91175: PUSH
91176: LD_INT 12
91178: EQUAL
91179: IFFALSE 91189
// sExp := true ;
91181: LD_ADDR_EXP 123
91185: PUSH
91186: LD_INT 1
91188: ST_TO_ADDR
// if p3 = 13 then
91189: LD_VAR 0 3
91193: PUSH
91194: LD_INT 13
91196: EQUAL
91197: IFFALSE 91207
// sDepot := true ;
91199: LD_ADDR_EXP 124
91203: PUSH
91204: LD_INT 1
91206: ST_TO_ADDR
// if p3 = 14 then
91207: LD_VAR 0 3
91211: PUSH
91212: LD_INT 14
91214: EQUAL
91215: IFFALSE 91225
// sFlag := true ;
91217: LD_ADDR_EXP 125
91221: PUSH
91222: LD_INT 1
91224: ST_TO_ADDR
// if p3 = 15 then
91225: LD_VAR 0 3
91229: PUSH
91230: LD_INT 15
91232: EQUAL
91233: IFFALSE 91243
// sKamikadze := true ;
91235: LD_ADDR_EXP 133
91239: PUSH
91240: LD_INT 1
91242: ST_TO_ADDR
// if p3 = 16 then
91243: LD_VAR 0 3
91247: PUSH
91248: LD_INT 16
91250: EQUAL
91251: IFFALSE 91261
// sTroll := true ;
91253: LD_ADDR_EXP 134
91257: PUSH
91258: LD_INT 1
91260: ST_TO_ADDR
// if p3 = 17 then
91261: LD_VAR 0 3
91265: PUSH
91266: LD_INT 17
91268: EQUAL
91269: IFFALSE 91279
// sSlow := true ;
91271: LD_ADDR_EXP 135
91275: PUSH
91276: LD_INT 1
91278: ST_TO_ADDR
// if p3 = 18 then
91279: LD_VAR 0 3
91283: PUSH
91284: LD_INT 18
91286: EQUAL
91287: IFFALSE 91297
// sLack := true ;
91289: LD_ADDR_EXP 136
91293: PUSH
91294: LD_INT 1
91296: ST_TO_ADDR
// if p3 = 19 then
91297: LD_VAR 0 3
91301: PUSH
91302: LD_INT 19
91304: EQUAL
91305: IFFALSE 91315
// sTank := true ;
91307: LD_ADDR_EXP 138
91311: PUSH
91312: LD_INT 1
91314: ST_TO_ADDR
// if p3 = 20 then
91315: LD_VAR 0 3
91319: PUSH
91320: LD_INT 20
91322: EQUAL
91323: IFFALSE 91333
// sRemote := true ;
91325: LD_ADDR_EXP 139
91329: PUSH
91330: LD_INT 1
91332: ST_TO_ADDR
// if p3 = 21 then
91333: LD_VAR 0 3
91337: PUSH
91338: LD_INT 21
91340: EQUAL
91341: IFFALSE 91351
// sPowell := true ;
91343: LD_ADDR_EXP 140
91347: PUSH
91348: LD_INT 1
91350: ST_TO_ADDR
// if p3 = 22 then
91351: LD_VAR 0 3
91355: PUSH
91356: LD_INT 22
91358: EQUAL
91359: IFFALSE 91369
// sTeleport := true ;
91361: LD_ADDR_EXP 143
91365: PUSH
91366: LD_INT 1
91368: ST_TO_ADDR
// if p3 = 23 then
91369: LD_VAR 0 3
91373: PUSH
91374: LD_INT 23
91376: EQUAL
91377: IFFALSE 91387
// sOilTower := true ;
91379: LD_ADDR_EXP 145
91383: PUSH
91384: LD_INT 1
91386: ST_TO_ADDR
// if p3 = 24 then
91387: LD_VAR 0 3
91391: PUSH
91392: LD_INT 24
91394: EQUAL
91395: IFFALSE 91405
// sShovel := true ;
91397: LD_ADDR_EXP 146
91401: PUSH
91402: LD_INT 1
91404: ST_TO_ADDR
// if p3 = 25 then
91405: LD_VAR 0 3
91409: PUSH
91410: LD_INT 25
91412: EQUAL
91413: IFFALSE 91423
// sSheik := true ;
91415: LD_ADDR_EXP 147
91419: PUSH
91420: LD_INT 1
91422: ST_TO_ADDR
// if p3 = 26 then
91423: LD_VAR 0 3
91427: PUSH
91428: LD_INT 26
91430: EQUAL
91431: IFFALSE 91441
// sEarthquake := true ;
91433: LD_ADDR_EXP 149
91437: PUSH
91438: LD_INT 1
91440: ST_TO_ADDR
// if p3 = 27 then
91441: LD_VAR 0 3
91445: PUSH
91446: LD_INT 27
91448: EQUAL
91449: IFFALSE 91459
// sAI := true ;
91451: LD_ADDR_EXP 150
91455: PUSH
91456: LD_INT 1
91458: ST_TO_ADDR
// if p3 = 28 then
91459: LD_VAR 0 3
91463: PUSH
91464: LD_INT 28
91466: EQUAL
91467: IFFALSE 91477
// sCargo := true ;
91469: LD_ADDR_EXP 153
91473: PUSH
91474: LD_INT 1
91476: ST_TO_ADDR
// if p3 = 29 then
91477: LD_VAR 0 3
91481: PUSH
91482: LD_INT 29
91484: EQUAL
91485: IFFALSE 91495
// sDLaser := true ;
91487: LD_ADDR_EXP 154
91491: PUSH
91492: LD_INT 1
91494: ST_TO_ADDR
// if p3 = 30 then
91495: LD_VAR 0 3
91499: PUSH
91500: LD_INT 30
91502: EQUAL
91503: IFFALSE 91513
// sExchange := true ;
91505: LD_ADDR_EXP 155
91509: PUSH
91510: LD_INT 1
91512: ST_TO_ADDR
// if p3 = 31 then
91513: LD_VAR 0 3
91517: PUSH
91518: LD_INT 31
91520: EQUAL
91521: IFFALSE 91531
// sFac := true ;
91523: LD_ADDR_EXP 156
91527: PUSH
91528: LD_INT 1
91530: ST_TO_ADDR
// if p3 = 32 then
91531: LD_VAR 0 3
91535: PUSH
91536: LD_INT 32
91538: EQUAL
91539: IFFALSE 91549
// sPower := true ;
91541: LD_ADDR_EXP 157
91545: PUSH
91546: LD_INT 1
91548: ST_TO_ADDR
// if p3 = 33 then
91549: LD_VAR 0 3
91553: PUSH
91554: LD_INT 33
91556: EQUAL
91557: IFFALSE 91567
// sRandom := true ;
91559: LD_ADDR_EXP 158
91563: PUSH
91564: LD_INT 1
91566: ST_TO_ADDR
// if p3 = 34 then
91567: LD_VAR 0 3
91571: PUSH
91572: LD_INT 34
91574: EQUAL
91575: IFFALSE 91585
// sShield := true ;
91577: LD_ADDR_EXP 159
91581: PUSH
91582: LD_INT 1
91584: ST_TO_ADDR
// if p3 = 35 then
91585: LD_VAR 0 3
91589: PUSH
91590: LD_INT 35
91592: EQUAL
91593: IFFALSE 91603
// sTime := true ;
91595: LD_ADDR_EXP 160
91599: PUSH
91600: LD_INT 1
91602: ST_TO_ADDR
// if p3 = 36 then
91603: LD_VAR 0 3
91607: PUSH
91608: LD_INT 36
91610: EQUAL
91611: IFFALSE 91621
// sTools := true ;
91613: LD_ADDR_EXP 161
91617: PUSH
91618: LD_INT 1
91620: ST_TO_ADDR
// if p3 = 101 then
91621: LD_VAR 0 3
91625: PUSH
91626: LD_INT 101
91628: EQUAL
91629: IFFALSE 91639
// sSold := true ;
91631: LD_ADDR_EXP 126
91635: PUSH
91636: LD_INT 1
91638: ST_TO_ADDR
// if p3 = 102 then
91639: LD_VAR 0 3
91643: PUSH
91644: LD_INT 102
91646: EQUAL
91647: IFFALSE 91657
// sDiff := true ;
91649: LD_ADDR_EXP 127
91653: PUSH
91654: LD_INT 1
91656: ST_TO_ADDR
// if p3 = 103 then
91657: LD_VAR 0 3
91661: PUSH
91662: LD_INT 103
91664: EQUAL
91665: IFFALSE 91675
// sFog := true ;
91667: LD_ADDR_EXP 130
91671: PUSH
91672: LD_INT 1
91674: ST_TO_ADDR
// if p3 = 104 then
91675: LD_VAR 0 3
91679: PUSH
91680: LD_INT 104
91682: EQUAL
91683: IFFALSE 91693
// sReset := true ;
91685: LD_ADDR_EXP 131
91689: PUSH
91690: LD_INT 1
91692: ST_TO_ADDR
// if p3 = 105 then
91693: LD_VAR 0 3
91697: PUSH
91698: LD_INT 105
91700: EQUAL
91701: IFFALSE 91711
// sSun := true ;
91703: LD_ADDR_EXP 132
91707: PUSH
91708: LD_INT 1
91710: ST_TO_ADDR
// if p3 = 106 then
91711: LD_VAR 0 3
91715: PUSH
91716: LD_INT 106
91718: EQUAL
91719: IFFALSE 91729
// sTiger := true ;
91721: LD_ADDR_EXP 128
91725: PUSH
91726: LD_INT 1
91728: ST_TO_ADDR
// if p3 = 107 then
91729: LD_VAR 0 3
91733: PUSH
91734: LD_INT 107
91736: EQUAL
91737: IFFALSE 91747
// sBomb := true ;
91739: LD_ADDR_EXP 129
91743: PUSH
91744: LD_INT 1
91746: ST_TO_ADDR
// if p3 = 108 then
91747: LD_VAR 0 3
91751: PUSH
91752: LD_INT 108
91754: EQUAL
91755: IFFALSE 91765
// sWound := true ;
91757: LD_ADDR_EXP 137
91761: PUSH
91762: LD_INT 1
91764: ST_TO_ADDR
// if p3 = 109 then
91765: LD_VAR 0 3
91769: PUSH
91770: LD_INT 109
91772: EQUAL
91773: IFFALSE 91783
// sBetray := true ;
91775: LD_ADDR_EXP 141
91779: PUSH
91780: LD_INT 1
91782: ST_TO_ADDR
// if p3 = 110 then
91783: LD_VAR 0 3
91787: PUSH
91788: LD_INT 110
91790: EQUAL
91791: IFFALSE 91801
// sContamin := true ;
91793: LD_ADDR_EXP 142
91797: PUSH
91798: LD_INT 1
91800: ST_TO_ADDR
// if p3 = 111 then
91801: LD_VAR 0 3
91805: PUSH
91806: LD_INT 111
91808: EQUAL
91809: IFFALSE 91819
// sOil := true ;
91811: LD_ADDR_EXP 144
91815: PUSH
91816: LD_INT 1
91818: ST_TO_ADDR
// if p3 = 112 then
91819: LD_VAR 0 3
91823: PUSH
91824: LD_INT 112
91826: EQUAL
91827: IFFALSE 91837
// sStu := true ;
91829: LD_ADDR_EXP 148
91833: PUSH
91834: LD_INT 1
91836: ST_TO_ADDR
// if p3 = 113 then
91837: LD_VAR 0 3
91841: PUSH
91842: LD_INT 113
91844: EQUAL
91845: IFFALSE 91855
// sBazooka := true ;
91847: LD_ADDR_EXP 151
91851: PUSH
91852: LD_INT 1
91854: ST_TO_ADDR
// if p3 = 114 then
91855: LD_VAR 0 3
91859: PUSH
91860: LD_INT 114
91862: EQUAL
91863: IFFALSE 91873
// sMortar := true ;
91865: LD_ADDR_EXP 152
91869: PUSH
91870: LD_INT 1
91872: ST_TO_ADDR
// if p3 = 115 then
91873: LD_VAR 0 3
91877: PUSH
91878: LD_INT 115
91880: EQUAL
91881: IFFALSE 91891
// sRanger := true ;
91883: LD_ADDR_EXP 162
91887: PUSH
91888: LD_INT 1
91890: ST_TO_ADDR
// if p3 = 116 then
91891: LD_VAR 0 3
91895: PUSH
91896: LD_INT 116
91898: EQUAL
91899: IFFALSE 91909
// sComputer := true ;
91901: LD_ADDR_EXP 163
91905: PUSH
91906: LD_INT 1
91908: ST_TO_ADDR
// if p3 = 117 then
91909: LD_VAR 0 3
91913: PUSH
91914: LD_INT 117
91916: EQUAL
91917: IFFALSE 91927
// s30 := true ;
91919: LD_ADDR_EXP 164
91923: PUSH
91924: LD_INT 1
91926: ST_TO_ADDR
// if p3 = 118 then
91927: LD_VAR 0 3
91931: PUSH
91932: LD_INT 118
91934: EQUAL
91935: IFFALSE 91945
// s60 := true ;
91937: LD_ADDR_EXP 165
91941: PUSH
91942: LD_INT 1
91944: ST_TO_ADDR
// end ; if p2 = hack_mode then
91945: LD_VAR 0 2
91949: PUSH
91950: LD_INT 101
91952: EQUAL
91953: IFFALSE 92081
// begin case p3 of 1 :
91955: LD_VAR 0 3
91959: PUSH
91960: LD_INT 1
91962: DOUBLE
91963: EQUAL
91964: IFTRUE 91968
91966: GO 91975
91968: POP
// hHackUnlimitedResources ; 2 :
91969: CALL 104228 0 0
91973: GO 92081
91975: LD_INT 2
91977: DOUBLE
91978: EQUAL
91979: IFTRUE 91983
91981: GO 91990
91983: POP
// hHackSetLevel10 ; 3 :
91984: CALL 104361 0 0
91988: GO 92081
91990: LD_INT 3
91992: DOUBLE
91993: EQUAL
91994: IFTRUE 91998
91996: GO 92005
91998: POP
// hHackSetLevel10YourUnits ; 4 :
91999: CALL 104446 0 0
92003: GO 92081
92005: LD_INT 4
92007: DOUBLE
92008: EQUAL
92009: IFTRUE 92013
92011: GO 92020
92013: POP
// hHackInvincible ; 5 :
92014: CALL 104894 0 0
92018: GO 92081
92020: LD_INT 5
92022: DOUBLE
92023: EQUAL
92024: IFTRUE 92028
92026: GO 92035
92028: POP
// hHackInvisible ; 6 :
92029: CALL 105005 0 0
92033: GO 92081
92035: LD_INT 6
92037: DOUBLE
92038: EQUAL
92039: IFTRUE 92043
92041: GO 92050
92043: POP
// hHackChangeYourSide ; 7 :
92044: CALL 105062 0 0
92048: GO 92081
92050: LD_INT 7
92052: DOUBLE
92053: EQUAL
92054: IFTRUE 92058
92056: GO 92065
92058: POP
// hHackChangeUnitSide ; 8 :
92059: CALL 105104 0 0
92063: GO 92081
92065: LD_INT 8
92067: DOUBLE
92068: EQUAL
92069: IFTRUE 92073
92071: GO 92080
92073: POP
// hHackFog ; end ;
92074: CALL 105205 0 0
92078: GO 92081
92080: POP
// end ; if p2 = game_save_mode then
92081: LD_VAR 0 2
92085: PUSH
92086: LD_INT 102
92088: EQUAL
92089: IFFALSE 92144
// begin if p3 = 1 then
92091: LD_VAR 0 3
92095: PUSH
92096: LD_INT 1
92098: EQUAL
92099: IFFALSE 92111
// globalGameSaveCounter := p4 ;
92101: LD_ADDR_EXP 108
92105: PUSH
92106: LD_VAR 0 4
92110: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
92111: LD_VAR 0 3
92115: PUSH
92116: LD_INT 2
92118: EQUAL
92119: PUSH
92120: LD_EXP 108
92124: AND
92125: IFFALSE 92144
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
92127: LD_STRING setGameSaveCounter(
92129: PUSH
92130: LD_EXP 108
92134: STR
92135: PUSH
92136: LD_STRING )
92138: STR
92139: PPUSH
92140: CALL_OW 559
// end ; end ;
92144: LD_VAR 0 7
92148: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
92149: LD_INT 0
92151: PPUSH
// streamModeActive := false ;
92152: LD_ADDR_EXP 109
92156: PUSH
92157: LD_INT 0
92159: ST_TO_ADDR
// normalCounter := 36 ;
92160: LD_ADDR_EXP 110
92164: PUSH
92165: LD_INT 36
92167: ST_TO_ADDR
// hardcoreCounter := 18 ;
92168: LD_ADDR_EXP 111
92172: PUSH
92173: LD_INT 18
92175: ST_TO_ADDR
// sRocket := false ;
92176: LD_ADDR_EXP 114
92180: PUSH
92181: LD_INT 0
92183: ST_TO_ADDR
// sSpeed := false ;
92184: LD_ADDR_EXP 113
92188: PUSH
92189: LD_INT 0
92191: ST_TO_ADDR
// sEngine := false ;
92192: LD_ADDR_EXP 115
92196: PUSH
92197: LD_INT 0
92199: ST_TO_ADDR
// sSpec := false ;
92200: LD_ADDR_EXP 112
92204: PUSH
92205: LD_INT 0
92207: ST_TO_ADDR
// sLevel := false ;
92208: LD_ADDR_EXP 116
92212: PUSH
92213: LD_INT 0
92215: ST_TO_ADDR
// sArmoury := false ;
92216: LD_ADDR_EXP 117
92220: PUSH
92221: LD_INT 0
92223: ST_TO_ADDR
// sRadar := false ;
92224: LD_ADDR_EXP 118
92228: PUSH
92229: LD_INT 0
92231: ST_TO_ADDR
// sBunker := false ;
92232: LD_ADDR_EXP 119
92236: PUSH
92237: LD_INT 0
92239: ST_TO_ADDR
// sHack := false ;
92240: LD_ADDR_EXP 120
92244: PUSH
92245: LD_INT 0
92247: ST_TO_ADDR
// sFire := false ;
92248: LD_ADDR_EXP 121
92252: PUSH
92253: LD_INT 0
92255: ST_TO_ADDR
// sRefresh := false ;
92256: LD_ADDR_EXP 122
92260: PUSH
92261: LD_INT 0
92263: ST_TO_ADDR
// sExp := false ;
92264: LD_ADDR_EXP 123
92268: PUSH
92269: LD_INT 0
92271: ST_TO_ADDR
// sDepot := false ;
92272: LD_ADDR_EXP 124
92276: PUSH
92277: LD_INT 0
92279: ST_TO_ADDR
// sFlag := false ;
92280: LD_ADDR_EXP 125
92284: PUSH
92285: LD_INT 0
92287: ST_TO_ADDR
// sKamikadze := false ;
92288: LD_ADDR_EXP 133
92292: PUSH
92293: LD_INT 0
92295: ST_TO_ADDR
// sTroll := false ;
92296: LD_ADDR_EXP 134
92300: PUSH
92301: LD_INT 0
92303: ST_TO_ADDR
// sSlow := false ;
92304: LD_ADDR_EXP 135
92308: PUSH
92309: LD_INT 0
92311: ST_TO_ADDR
// sLack := false ;
92312: LD_ADDR_EXP 136
92316: PUSH
92317: LD_INT 0
92319: ST_TO_ADDR
// sTank := false ;
92320: LD_ADDR_EXP 138
92324: PUSH
92325: LD_INT 0
92327: ST_TO_ADDR
// sRemote := false ;
92328: LD_ADDR_EXP 139
92332: PUSH
92333: LD_INT 0
92335: ST_TO_ADDR
// sPowell := false ;
92336: LD_ADDR_EXP 140
92340: PUSH
92341: LD_INT 0
92343: ST_TO_ADDR
// sTeleport := false ;
92344: LD_ADDR_EXP 143
92348: PUSH
92349: LD_INT 0
92351: ST_TO_ADDR
// sOilTower := false ;
92352: LD_ADDR_EXP 145
92356: PUSH
92357: LD_INT 0
92359: ST_TO_ADDR
// sShovel := false ;
92360: LD_ADDR_EXP 146
92364: PUSH
92365: LD_INT 0
92367: ST_TO_ADDR
// sSheik := false ;
92368: LD_ADDR_EXP 147
92372: PUSH
92373: LD_INT 0
92375: ST_TO_ADDR
// sEarthquake := false ;
92376: LD_ADDR_EXP 149
92380: PUSH
92381: LD_INT 0
92383: ST_TO_ADDR
// sAI := false ;
92384: LD_ADDR_EXP 150
92388: PUSH
92389: LD_INT 0
92391: ST_TO_ADDR
// sCargo := false ;
92392: LD_ADDR_EXP 153
92396: PUSH
92397: LD_INT 0
92399: ST_TO_ADDR
// sDLaser := false ;
92400: LD_ADDR_EXP 154
92404: PUSH
92405: LD_INT 0
92407: ST_TO_ADDR
// sExchange := false ;
92408: LD_ADDR_EXP 155
92412: PUSH
92413: LD_INT 0
92415: ST_TO_ADDR
// sFac := false ;
92416: LD_ADDR_EXP 156
92420: PUSH
92421: LD_INT 0
92423: ST_TO_ADDR
// sPower := false ;
92424: LD_ADDR_EXP 157
92428: PUSH
92429: LD_INT 0
92431: ST_TO_ADDR
// sRandom := false ;
92432: LD_ADDR_EXP 158
92436: PUSH
92437: LD_INT 0
92439: ST_TO_ADDR
// sShield := false ;
92440: LD_ADDR_EXP 159
92444: PUSH
92445: LD_INT 0
92447: ST_TO_ADDR
// sTime := false ;
92448: LD_ADDR_EXP 160
92452: PUSH
92453: LD_INT 0
92455: ST_TO_ADDR
// sTools := false ;
92456: LD_ADDR_EXP 161
92460: PUSH
92461: LD_INT 0
92463: ST_TO_ADDR
// sSold := false ;
92464: LD_ADDR_EXP 126
92468: PUSH
92469: LD_INT 0
92471: ST_TO_ADDR
// sDiff := false ;
92472: LD_ADDR_EXP 127
92476: PUSH
92477: LD_INT 0
92479: ST_TO_ADDR
// sFog := false ;
92480: LD_ADDR_EXP 130
92484: PUSH
92485: LD_INT 0
92487: ST_TO_ADDR
// sReset := false ;
92488: LD_ADDR_EXP 131
92492: PUSH
92493: LD_INT 0
92495: ST_TO_ADDR
// sSun := false ;
92496: LD_ADDR_EXP 132
92500: PUSH
92501: LD_INT 0
92503: ST_TO_ADDR
// sTiger := false ;
92504: LD_ADDR_EXP 128
92508: PUSH
92509: LD_INT 0
92511: ST_TO_ADDR
// sBomb := false ;
92512: LD_ADDR_EXP 129
92516: PUSH
92517: LD_INT 0
92519: ST_TO_ADDR
// sWound := false ;
92520: LD_ADDR_EXP 137
92524: PUSH
92525: LD_INT 0
92527: ST_TO_ADDR
// sBetray := false ;
92528: LD_ADDR_EXP 141
92532: PUSH
92533: LD_INT 0
92535: ST_TO_ADDR
// sContamin := false ;
92536: LD_ADDR_EXP 142
92540: PUSH
92541: LD_INT 0
92543: ST_TO_ADDR
// sOil := false ;
92544: LD_ADDR_EXP 144
92548: PUSH
92549: LD_INT 0
92551: ST_TO_ADDR
// sStu := false ;
92552: LD_ADDR_EXP 148
92556: PUSH
92557: LD_INT 0
92559: ST_TO_ADDR
// sBazooka := false ;
92560: LD_ADDR_EXP 151
92564: PUSH
92565: LD_INT 0
92567: ST_TO_ADDR
// sMortar := false ;
92568: LD_ADDR_EXP 152
92572: PUSH
92573: LD_INT 0
92575: ST_TO_ADDR
// sRanger := false ;
92576: LD_ADDR_EXP 162
92580: PUSH
92581: LD_INT 0
92583: ST_TO_ADDR
// sComputer := false ;
92584: LD_ADDR_EXP 163
92588: PUSH
92589: LD_INT 0
92591: ST_TO_ADDR
// s30 := false ;
92592: LD_ADDR_EXP 164
92596: PUSH
92597: LD_INT 0
92599: ST_TO_ADDR
// s60 := false ;
92600: LD_ADDR_EXP 165
92604: PUSH
92605: LD_INT 0
92607: ST_TO_ADDR
// end ;
92608: LD_VAR 0 1
92612: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
92613: LD_INT 0
92615: PPUSH
92616: PPUSH
92617: PPUSH
92618: PPUSH
92619: PPUSH
92620: PPUSH
92621: PPUSH
// result := [ ] ;
92622: LD_ADDR_VAR 0 2
92626: PUSH
92627: EMPTY
92628: ST_TO_ADDR
// if campaign_id = 1 then
92629: LD_OWVAR 69
92633: PUSH
92634: LD_INT 1
92636: EQUAL
92637: IFFALSE 95803
// begin case mission_number of 1 :
92639: LD_OWVAR 70
92643: PUSH
92644: LD_INT 1
92646: DOUBLE
92647: EQUAL
92648: IFTRUE 92652
92650: GO 92728
92652: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
92653: LD_ADDR_VAR 0 2
92657: PUSH
92658: LD_INT 2
92660: PUSH
92661: LD_INT 4
92663: PUSH
92664: LD_INT 11
92666: PUSH
92667: LD_INT 12
92669: PUSH
92670: LD_INT 15
92672: PUSH
92673: LD_INT 16
92675: PUSH
92676: LD_INT 22
92678: PUSH
92679: LD_INT 23
92681: PUSH
92682: LD_INT 26
92684: PUSH
92685: EMPTY
92686: LIST
92687: LIST
92688: LIST
92689: LIST
92690: LIST
92691: LIST
92692: LIST
92693: LIST
92694: LIST
92695: PUSH
92696: LD_INT 101
92698: PUSH
92699: LD_INT 102
92701: PUSH
92702: LD_INT 106
92704: PUSH
92705: LD_INT 116
92707: PUSH
92708: LD_INT 117
92710: PUSH
92711: LD_INT 118
92713: PUSH
92714: EMPTY
92715: LIST
92716: LIST
92717: LIST
92718: LIST
92719: LIST
92720: LIST
92721: PUSH
92722: EMPTY
92723: LIST
92724: LIST
92725: ST_TO_ADDR
92726: GO 95801
92728: LD_INT 2
92730: DOUBLE
92731: EQUAL
92732: IFTRUE 92736
92734: GO 92820
92736: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
92737: LD_ADDR_VAR 0 2
92741: PUSH
92742: LD_INT 2
92744: PUSH
92745: LD_INT 4
92747: PUSH
92748: LD_INT 11
92750: PUSH
92751: LD_INT 12
92753: PUSH
92754: LD_INT 15
92756: PUSH
92757: LD_INT 16
92759: PUSH
92760: LD_INT 22
92762: PUSH
92763: LD_INT 23
92765: PUSH
92766: LD_INT 26
92768: PUSH
92769: EMPTY
92770: LIST
92771: LIST
92772: LIST
92773: LIST
92774: LIST
92775: LIST
92776: LIST
92777: LIST
92778: LIST
92779: PUSH
92780: LD_INT 101
92782: PUSH
92783: LD_INT 102
92785: PUSH
92786: LD_INT 105
92788: PUSH
92789: LD_INT 106
92791: PUSH
92792: LD_INT 108
92794: PUSH
92795: LD_INT 116
92797: PUSH
92798: LD_INT 117
92800: PUSH
92801: LD_INT 118
92803: PUSH
92804: EMPTY
92805: LIST
92806: LIST
92807: LIST
92808: LIST
92809: LIST
92810: LIST
92811: LIST
92812: LIST
92813: PUSH
92814: EMPTY
92815: LIST
92816: LIST
92817: ST_TO_ADDR
92818: GO 95801
92820: LD_INT 3
92822: DOUBLE
92823: EQUAL
92824: IFTRUE 92828
92826: GO 92916
92828: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
92829: LD_ADDR_VAR 0 2
92833: PUSH
92834: LD_INT 2
92836: PUSH
92837: LD_INT 4
92839: PUSH
92840: LD_INT 5
92842: PUSH
92843: LD_INT 11
92845: PUSH
92846: LD_INT 12
92848: PUSH
92849: LD_INT 15
92851: PUSH
92852: LD_INT 16
92854: PUSH
92855: LD_INT 22
92857: PUSH
92858: LD_INT 26
92860: PUSH
92861: LD_INT 36
92863: PUSH
92864: EMPTY
92865: LIST
92866: LIST
92867: LIST
92868: LIST
92869: LIST
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: PUSH
92876: LD_INT 101
92878: PUSH
92879: LD_INT 102
92881: PUSH
92882: LD_INT 105
92884: PUSH
92885: LD_INT 106
92887: PUSH
92888: LD_INT 108
92890: PUSH
92891: LD_INT 116
92893: PUSH
92894: LD_INT 117
92896: PUSH
92897: LD_INT 118
92899: PUSH
92900: EMPTY
92901: LIST
92902: LIST
92903: LIST
92904: LIST
92905: LIST
92906: LIST
92907: LIST
92908: LIST
92909: PUSH
92910: EMPTY
92911: LIST
92912: LIST
92913: ST_TO_ADDR
92914: GO 95801
92916: LD_INT 4
92918: DOUBLE
92919: EQUAL
92920: IFTRUE 92924
92922: GO 93020
92924: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
92925: LD_ADDR_VAR 0 2
92929: PUSH
92930: LD_INT 2
92932: PUSH
92933: LD_INT 4
92935: PUSH
92936: LD_INT 5
92938: PUSH
92939: LD_INT 8
92941: PUSH
92942: LD_INT 11
92944: PUSH
92945: LD_INT 12
92947: PUSH
92948: LD_INT 15
92950: PUSH
92951: LD_INT 16
92953: PUSH
92954: LD_INT 22
92956: PUSH
92957: LD_INT 23
92959: PUSH
92960: LD_INT 26
92962: PUSH
92963: LD_INT 36
92965: PUSH
92966: EMPTY
92967: LIST
92968: LIST
92969: LIST
92970: LIST
92971: LIST
92972: LIST
92973: LIST
92974: LIST
92975: LIST
92976: LIST
92977: LIST
92978: LIST
92979: PUSH
92980: LD_INT 101
92982: PUSH
92983: LD_INT 102
92985: PUSH
92986: LD_INT 105
92988: PUSH
92989: LD_INT 106
92991: PUSH
92992: LD_INT 108
92994: PUSH
92995: LD_INT 116
92997: PUSH
92998: LD_INT 117
93000: PUSH
93001: LD_INT 118
93003: PUSH
93004: EMPTY
93005: LIST
93006: LIST
93007: LIST
93008: LIST
93009: LIST
93010: LIST
93011: LIST
93012: LIST
93013: PUSH
93014: EMPTY
93015: LIST
93016: LIST
93017: ST_TO_ADDR
93018: GO 95801
93020: LD_INT 5
93022: DOUBLE
93023: EQUAL
93024: IFTRUE 93028
93026: GO 93140
93028: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
93029: LD_ADDR_VAR 0 2
93033: PUSH
93034: LD_INT 2
93036: PUSH
93037: LD_INT 4
93039: PUSH
93040: LD_INT 5
93042: PUSH
93043: LD_INT 6
93045: PUSH
93046: LD_INT 8
93048: PUSH
93049: LD_INT 11
93051: PUSH
93052: LD_INT 12
93054: PUSH
93055: LD_INT 15
93057: PUSH
93058: LD_INT 16
93060: PUSH
93061: LD_INT 22
93063: PUSH
93064: LD_INT 23
93066: PUSH
93067: LD_INT 25
93069: PUSH
93070: LD_INT 26
93072: PUSH
93073: LD_INT 36
93075: PUSH
93076: EMPTY
93077: LIST
93078: LIST
93079: LIST
93080: LIST
93081: LIST
93082: LIST
93083: LIST
93084: LIST
93085: LIST
93086: LIST
93087: LIST
93088: LIST
93089: LIST
93090: LIST
93091: PUSH
93092: LD_INT 101
93094: PUSH
93095: LD_INT 102
93097: PUSH
93098: LD_INT 105
93100: PUSH
93101: LD_INT 106
93103: PUSH
93104: LD_INT 108
93106: PUSH
93107: LD_INT 109
93109: PUSH
93110: LD_INT 112
93112: PUSH
93113: LD_INT 116
93115: PUSH
93116: LD_INT 117
93118: PUSH
93119: LD_INT 118
93121: PUSH
93122: EMPTY
93123: LIST
93124: LIST
93125: LIST
93126: LIST
93127: LIST
93128: LIST
93129: LIST
93130: LIST
93131: LIST
93132: LIST
93133: PUSH
93134: EMPTY
93135: LIST
93136: LIST
93137: ST_TO_ADDR
93138: GO 95801
93140: LD_INT 6
93142: DOUBLE
93143: EQUAL
93144: IFTRUE 93148
93146: GO 93280
93148: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
93149: LD_ADDR_VAR 0 2
93153: PUSH
93154: LD_INT 2
93156: PUSH
93157: LD_INT 4
93159: PUSH
93160: LD_INT 5
93162: PUSH
93163: LD_INT 6
93165: PUSH
93166: LD_INT 8
93168: PUSH
93169: LD_INT 11
93171: PUSH
93172: LD_INT 12
93174: PUSH
93175: LD_INT 15
93177: PUSH
93178: LD_INT 16
93180: PUSH
93181: LD_INT 20
93183: PUSH
93184: LD_INT 21
93186: PUSH
93187: LD_INT 22
93189: PUSH
93190: LD_INT 23
93192: PUSH
93193: LD_INT 25
93195: PUSH
93196: LD_INT 26
93198: PUSH
93199: LD_INT 30
93201: PUSH
93202: LD_INT 31
93204: PUSH
93205: LD_INT 32
93207: PUSH
93208: LD_INT 36
93210: PUSH
93211: EMPTY
93212: LIST
93213: LIST
93214: LIST
93215: LIST
93216: LIST
93217: LIST
93218: LIST
93219: LIST
93220: LIST
93221: LIST
93222: LIST
93223: LIST
93224: LIST
93225: LIST
93226: LIST
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: PUSH
93232: LD_INT 101
93234: PUSH
93235: LD_INT 102
93237: PUSH
93238: LD_INT 105
93240: PUSH
93241: LD_INT 106
93243: PUSH
93244: LD_INT 108
93246: PUSH
93247: LD_INT 109
93249: PUSH
93250: LD_INT 112
93252: PUSH
93253: LD_INT 116
93255: PUSH
93256: LD_INT 117
93258: PUSH
93259: LD_INT 118
93261: PUSH
93262: EMPTY
93263: LIST
93264: LIST
93265: LIST
93266: LIST
93267: LIST
93268: LIST
93269: LIST
93270: LIST
93271: LIST
93272: LIST
93273: PUSH
93274: EMPTY
93275: LIST
93276: LIST
93277: ST_TO_ADDR
93278: GO 95801
93280: LD_INT 7
93282: DOUBLE
93283: EQUAL
93284: IFTRUE 93288
93286: GO 93400
93288: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
93289: LD_ADDR_VAR 0 2
93293: PUSH
93294: LD_INT 2
93296: PUSH
93297: LD_INT 4
93299: PUSH
93300: LD_INT 5
93302: PUSH
93303: LD_INT 7
93305: PUSH
93306: LD_INT 11
93308: PUSH
93309: LD_INT 12
93311: PUSH
93312: LD_INT 15
93314: PUSH
93315: LD_INT 16
93317: PUSH
93318: LD_INT 20
93320: PUSH
93321: LD_INT 21
93323: PUSH
93324: LD_INT 22
93326: PUSH
93327: LD_INT 23
93329: PUSH
93330: LD_INT 25
93332: PUSH
93333: LD_INT 26
93335: PUSH
93336: EMPTY
93337: LIST
93338: LIST
93339: LIST
93340: LIST
93341: LIST
93342: LIST
93343: LIST
93344: LIST
93345: LIST
93346: LIST
93347: LIST
93348: LIST
93349: LIST
93350: LIST
93351: PUSH
93352: LD_INT 101
93354: PUSH
93355: LD_INT 102
93357: PUSH
93358: LD_INT 103
93360: PUSH
93361: LD_INT 105
93363: PUSH
93364: LD_INT 106
93366: PUSH
93367: LD_INT 108
93369: PUSH
93370: LD_INT 112
93372: PUSH
93373: LD_INT 116
93375: PUSH
93376: LD_INT 117
93378: PUSH
93379: LD_INT 118
93381: PUSH
93382: EMPTY
93383: LIST
93384: LIST
93385: LIST
93386: LIST
93387: LIST
93388: LIST
93389: LIST
93390: LIST
93391: LIST
93392: LIST
93393: PUSH
93394: EMPTY
93395: LIST
93396: LIST
93397: ST_TO_ADDR
93398: GO 95801
93400: LD_INT 8
93402: DOUBLE
93403: EQUAL
93404: IFTRUE 93408
93406: GO 93548
93408: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
93409: LD_ADDR_VAR 0 2
93413: PUSH
93414: LD_INT 2
93416: PUSH
93417: LD_INT 4
93419: PUSH
93420: LD_INT 5
93422: PUSH
93423: LD_INT 6
93425: PUSH
93426: LD_INT 7
93428: PUSH
93429: LD_INT 8
93431: PUSH
93432: LD_INT 11
93434: PUSH
93435: LD_INT 12
93437: PUSH
93438: LD_INT 15
93440: PUSH
93441: LD_INT 16
93443: PUSH
93444: LD_INT 20
93446: PUSH
93447: LD_INT 21
93449: PUSH
93450: LD_INT 22
93452: PUSH
93453: LD_INT 23
93455: PUSH
93456: LD_INT 25
93458: PUSH
93459: LD_INT 26
93461: PUSH
93462: LD_INT 30
93464: PUSH
93465: LD_INT 31
93467: PUSH
93468: LD_INT 32
93470: PUSH
93471: LD_INT 36
93473: PUSH
93474: EMPTY
93475: LIST
93476: LIST
93477: LIST
93478: LIST
93479: LIST
93480: LIST
93481: LIST
93482: LIST
93483: LIST
93484: LIST
93485: LIST
93486: LIST
93487: LIST
93488: LIST
93489: LIST
93490: LIST
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: PUSH
93496: LD_INT 101
93498: PUSH
93499: LD_INT 102
93501: PUSH
93502: LD_INT 103
93504: PUSH
93505: LD_INT 105
93507: PUSH
93508: LD_INT 106
93510: PUSH
93511: LD_INT 108
93513: PUSH
93514: LD_INT 109
93516: PUSH
93517: LD_INT 112
93519: PUSH
93520: LD_INT 116
93522: PUSH
93523: LD_INT 117
93525: PUSH
93526: LD_INT 118
93528: PUSH
93529: EMPTY
93530: LIST
93531: LIST
93532: LIST
93533: LIST
93534: LIST
93535: LIST
93536: LIST
93537: LIST
93538: LIST
93539: LIST
93540: LIST
93541: PUSH
93542: EMPTY
93543: LIST
93544: LIST
93545: ST_TO_ADDR
93546: GO 95801
93548: LD_INT 9
93550: DOUBLE
93551: EQUAL
93552: IFTRUE 93556
93554: GO 93704
93556: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
93557: LD_ADDR_VAR 0 2
93561: PUSH
93562: LD_INT 2
93564: PUSH
93565: LD_INT 4
93567: PUSH
93568: LD_INT 5
93570: PUSH
93571: LD_INT 6
93573: PUSH
93574: LD_INT 7
93576: PUSH
93577: LD_INT 8
93579: PUSH
93580: LD_INT 11
93582: PUSH
93583: LD_INT 12
93585: PUSH
93586: LD_INT 15
93588: PUSH
93589: LD_INT 16
93591: PUSH
93592: LD_INT 20
93594: PUSH
93595: LD_INT 21
93597: PUSH
93598: LD_INT 22
93600: PUSH
93601: LD_INT 23
93603: PUSH
93604: LD_INT 25
93606: PUSH
93607: LD_INT 26
93609: PUSH
93610: LD_INT 28
93612: PUSH
93613: LD_INT 30
93615: PUSH
93616: LD_INT 31
93618: PUSH
93619: LD_INT 32
93621: PUSH
93622: LD_INT 36
93624: PUSH
93625: EMPTY
93626: LIST
93627: LIST
93628: LIST
93629: LIST
93630: LIST
93631: LIST
93632: LIST
93633: LIST
93634: LIST
93635: LIST
93636: LIST
93637: LIST
93638: LIST
93639: LIST
93640: LIST
93641: LIST
93642: LIST
93643: LIST
93644: LIST
93645: LIST
93646: LIST
93647: PUSH
93648: LD_INT 101
93650: PUSH
93651: LD_INT 102
93653: PUSH
93654: LD_INT 103
93656: PUSH
93657: LD_INT 105
93659: PUSH
93660: LD_INT 106
93662: PUSH
93663: LD_INT 108
93665: PUSH
93666: LD_INT 109
93668: PUSH
93669: LD_INT 112
93671: PUSH
93672: LD_INT 114
93674: PUSH
93675: LD_INT 116
93677: PUSH
93678: LD_INT 117
93680: PUSH
93681: LD_INT 118
93683: PUSH
93684: EMPTY
93685: LIST
93686: LIST
93687: LIST
93688: LIST
93689: LIST
93690: LIST
93691: LIST
93692: LIST
93693: LIST
93694: LIST
93695: LIST
93696: LIST
93697: PUSH
93698: EMPTY
93699: LIST
93700: LIST
93701: ST_TO_ADDR
93702: GO 95801
93704: LD_INT 10
93706: DOUBLE
93707: EQUAL
93708: IFTRUE 93712
93710: GO 93908
93712: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
93713: LD_ADDR_VAR 0 2
93717: PUSH
93718: LD_INT 2
93720: PUSH
93721: LD_INT 4
93723: PUSH
93724: LD_INT 5
93726: PUSH
93727: LD_INT 6
93729: PUSH
93730: LD_INT 7
93732: PUSH
93733: LD_INT 8
93735: PUSH
93736: LD_INT 9
93738: PUSH
93739: LD_INT 10
93741: PUSH
93742: LD_INT 11
93744: PUSH
93745: LD_INT 12
93747: PUSH
93748: LD_INT 13
93750: PUSH
93751: LD_INT 14
93753: PUSH
93754: LD_INT 15
93756: PUSH
93757: LD_INT 16
93759: PUSH
93760: LD_INT 17
93762: PUSH
93763: LD_INT 18
93765: PUSH
93766: LD_INT 19
93768: PUSH
93769: LD_INT 20
93771: PUSH
93772: LD_INT 21
93774: PUSH
93775: LD_INT 22
93777: PUSH
93778: LD_INT 23
93780: PUSH
93781: LD_INT 24
93783: PUSH
93784: LD_INT 25
93786: PUSH
93787: LD_INT 26
93789: PUSH
93790: LD_INT 28
93792: PUSH
93793: LD_INT 30
93795: PUSH
93796: LD_INT 31
93798: PUSH
93799: LD_INT 32
93801: PUSH
93802: LD_INT 36
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: LIST
93809: LIST
93810: LIST
93811: LIST
93812: LIST
93813: LIST
93814: LIST
93815: LIST
93816: LIST
93817: LIST
93818: LIST
93819: LIST
93820: LIST
93821: LIST
93822: LIST
93823: LIST
93824: LIST
93825: LIST
93826: LIST
93827: LIST
93828: LIST
93829: LIST
93830: LIST
93831: LIST
93832: LIST
93833: LIST
93834: LIST
93835: PUSH
93836: LD_INT 101
93838: PUSH
93839: LD_INT 102
93841: PUSH
93842: LD_INT 103
93844: PUSH
93845: LD_INT 104
93847: PUSH
93848: LD_INT 105
93850: PUSH
93851: LD_INT 106
93853: PUSH
93854: LD_INT 107
93856: PUSH
93857: LD_INT 108
93859: PUSH
93860: LD_INT 109
93862: PUSH
93863: LD_INT 110
93865: PUSH
93866: LD_INT 111
93868: PUSH
93869: LD_INT 112
93871: PUSH
93872: LD_INT 114
93874: PUSH
93875: LD_INT 116
93877: PUSH
93878: LD_INT 117
93880: PUSH
93881: LD_INT 118
93883: PUSH
93884: EMPTY
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: LIST
93891: LIST
93892: LIST
93893: LIST
93894: LIST
93895: LIST
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: LIST
93901: PUSH
93902: EMPTY
93903: LIST
93904: LIST
93905: ST_TO_ADDR
93906: GO 95801
93908: LD_INT 11
93910: DOUBLE
93911: EQUAL
93912: IFTRUE 93916
93914: GO 94120
93916: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
93917: LD_ADDR_VAR 0 2
93921: PUSH
93922: LD_INT 2
93924: PUSH
93925: LD_INT 3
93927: PUSH
93928: LD_INT 4
93930: PUSH
93931: LD_INT 5
93933: PUSH
93934: LD_INT 6
93936: PUSH
93937: LD_INT 7
93939: PUSH
93940: LD_INT 8
93942: PUSH
93943: LD_INT 9
93945: PUSH
93946: LD_INT 10
93948: PUSH
93949: LD_INT 11
93951: PUSH
93952: LD_INT 12
93954: PUSH
93955: LD_INT 13
93957: PUSH
93958: LD_INT 14
93960: PUSH
93961: LD_INT 15
93963: PUSH
93964: LD_INT 16
93966: PUSH
93967: LD_INT 17
93969: PUSH
93970: LD_INT 18
93972: PUSH
93973: LD_INT 19
93975: PUSH
93976: LD_INT 20
93978: PUSH
93979: LD_INT 21
93981: PUSH
93982: LD_INT 22
93984: PUSH
93985: LD_INT 23
93987: PUSH
93988: LD_INT 24
93990: PUSH
93991: LD_INT 25
93993: PUSH
93994: LD_INT 26
93996: PUSH
93997: LD_INT 28
93999: PUSH
94000: LD_INT 30
94002: PUSH
94003: LD_INT 31
94005: PUSH
94006: LD_INT 32
94008: PUSH
94009: LD_INT 34
94011: PUSH
94012: LD_INT 36
94014: PUSH
94015: EMPTY
94016: LIST
94017: LIST
94018: LIST
94019: LIST
94020: LIST
94021: LIST
94022: LIST
94023: LIST
94024: LIST
94025: LIST
94026: LIST
94027: LIST
94028: LIST
94029: LIST
94030: LIST
94031: LIST
94032: LIST
94033: LIST
94034: LIST
94035: LIST
94036: LIST
94037: LIST
94038: LIST
94039: LIST
94040: LIST
94041: LIST
94042: LIST
94043: LIST
94044: LIST
94045: LIST
94046: LIST
94047: PUSH
94048: LD_INT 101
94050: PUSH
94051: LD_INT 102
94053: PUSH
94054: LD_INT 103
94056: PUSH
94057: LD_INT 104
94059: PUSH
94060: LD_INT 105
94062: PUSH
94063: LD_INT 106
94065: PUSH
94066: LD_INT 107
94068: PUSH
94069: LD_INT 108
94071: PUSH
94072: LD_INT 109
94074: PUSH
94075: LD_INT 110
94077: PUSH
94078: LD_INT 111
94080: PUSH
94081: LD_INT 112
94083: PUSH
94084: LD_INT 114
94086: PUSH
94087: LD_INT 116
94089: PUSH
94090: LD_INT 117
94092: PUSH
94093: LD_INT 118
94095: PUSH
94096: EMPTY
94097: LIST
94098: LIST
94099: LIST
94100: LIST
94101: LIST
94102: LIST
94103: LIST
94104: LIST
94105: LIST
94106: LIST
94107: LIST
94108: LIST
94109: LIST
94110: LIST
94111: LIST
94112: LIST
94113: PUSH
94114: EMPTY
94115: LIST
94116: LIST
94117: ST_TO_ADDR
94118: GO 95801
94120: LD_INT 12
94122: DOUBLE
94123: EQUAL
94124: IFTRUE 94128
94126: GO 94348
94128: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
94129: LD_ADDR_VAR 0 2
94133: PUSH
94134: LD_INT 1
94136: PUSH
94137: LD_INT 2
94139: PUSH
94140: LD_INT 3
94142: PUSH
94143: LD_INT 4
94145: PUSH
94146: LD_INT 5
94148: PUSH
94149: LD_INT 6
94151: PUSH
94152: LD_INT 7
94154: PUSH
94155: LD_INT 8
94157: PUSH
94158: LD_INT 9
94160: PUSH
94161: LD_INT 10
94163: PUSH
94164: LD_INT 11
94166: PUSH
94167: LD_INT 12
94169: PUSH
94170: LD_INT 13
94172: PUSH
94173: LD_INT 14
94175: PUSH
94176: LD_INT 15
94178: PUSH
94179: LD_INT 16
94181: PUSH
94182: LD_INT 17
94184: PUSH
94185: LD_INT 18
94187: PUSH
94188: LD_INT 19
94190: PUSH
94191: LD_INT 20
94193: PUSH
94194: LD_INT 21
94196: PUSH
94197: LD_INT 22
94199: PUSH
94200: LD_INT 23
94202: PUSH
94203: LD_INT 24
94205: PUSH
94206: LD_INT 25
94208: PUSH
94209: LD_INT 26
94211: PUSH
94212: LD_INT 27
94214: PUSH
94215: LD_INT 28
94217: PUSH
94218: LD_INT 30
94220: PUSH
94221: LD_INT 31
94223: PUSH
94224: LD_INT 32
94226: PUSH
94227: LD_INT 33
94229: PUSH
94230: LD_INT 34
94232: PUSH
94233: LD_INT 36
94235: PUSH
94236: EMPTY
94237: LIST
94238: LIST
94239: LIST
94240: LIST
94241: LIST
94242: LIST
94243: LIST
94244: LIST
94245: LIST
94246: LIST
94247: LIST
94248: LIST
94249: LIST
94250: LIST
94251: LIST
94252: LIST
94253: LIST
94254: LIST
94255: LIST
94256: LIST
94257: LIST
94258: LIST
94259: LIST
94260: LIST
94261: LIST
94262: LIST
94263: LIST
94264: LIST
94265: LIST
94266: LIST
94267: LIST
94268: LIST
94269: LIST
94270: LIST
94271: PUSH
94272: LD_INT 101
94274: PUSH
94275: LD_INT 102
94277: PUSH
94278: LD_INT 103
94280: PUSH
94281: LD_INT 104
94283: PUSH
94284: LD_INT 105
94286: PUSH
94287: LD_INT 106
94289: PUSH
94290: LD_INT 107
94292: PUSH
94293: LD_INT 108
94295: PUSH
94296: LD_INT 109
94298: PUSH
94299: LD_INT 110
94301: PUSH
94302: LD_INT 111
94304: PUSH
94305: LD_INT 112
94307: PUSH
94308: LD_INT 113
94310: PUSH
94311: LD_INT 114
94313: PUSH
94314: LD_INT 116
94316: PUSH
94317: LD_INT 117
94319: PUSH
94320: LD_INT 118
94322: PUSH
94323: EMPTY
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: LIST
94331: LIST
94332: LIST
94333: LIST
94334: LIST
94335: LIST
94336: LIST
94337: LIST
94338: LIST
94339: LIST
94340: LIST
94341: PUSH
94342: EMPTY
94343: LIST
94344: LIST
94345: ST_TO_ADDR
94346: GO 95801
94348: LD_INT 13
94350: DOUBLE
94351: EQUAL
94352: IFTRUE 94356
94354: GO 94564
94356: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
94357: LD_ADDR_VAR 0 2
94361: PUSH
94362: LD_INT 1
94364: PUSH
94365: LD_INT 2
94367: PUSH
94368: LD_INT 3
94370: PUSH
94371: LD_INT 4
94373: PUSH
94374: LD_INT 5
94376: PUSH
94377: LD_INT 8
94379: PUSH
94380: LD_INT 9
94382: PUSH
94383: LD_INT 10
94385: PUSH
94386: LD_INT 11
94388: PUSH
94389: LD_INT 12
94391: PUSH
94392: LD_INT 14
94394: PUSH
94395: LD_INT 15
94397: PUSH
94398: LD_INT 16
94400: PUSH
94401: LD_INT 17
94403: PUSH
94404: LD_INT 18
94406: PUSH
94407: LD_INT 19
94409: PUSH
94410: LD_INT 20
94412: PUSH
94413: LD_INT 21
94415: PUSH
94416: LD_INT 22
94418: PUSH
94419: LD_INT 23
94421: PUSH
94422: LD_INT 24
94424: PUSH
94425: LD_INT 25
94427: PUSH
94428: LD_INT 26
94430: PUSH
94431: LD_INT 27
94433: PUSH
94434: LD_INT 28
94436: PUSH
94437: LD_INT 30
94439: PUSH
94440: LD_INT 31
94442: PUSH
94443: LD_INT 32
94445: PUSH
94446: LD_INT 33
94448: PUSH
94449: LD_INT 34
94451: PUSH
94452: LD_INT 36
94454: PUSH
94455: EMPTY
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: LIST
94468: LIST
94469: LIST
94470: LIST
94471: LIST
94472: LIST
94473: LIST
94474: LIST
94475: LIST
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: LIST
94487: PUSH
94488: LD_INT 101
94490: PUSH
94491: LD_INT 102
94493: PUSH
94494: LD_INT 103
94496: PUSH
94497: LD_INT 104
94499: PUSH
94500: LD_INT 105
94502: PUSH
94503: LD_INT 106
94505: PUSH
94506: LD_INT 107
94508: PUSH
94509: LD_INT 108
94511: PUSH
94512: LD_INT 109
94514: PUSH
94515: LD_INT 110
94517: PUSH
94518: LD_INT 111
94520: PUSH
94521: LD_INT 112
94523: PUSH
94524: LD_INT 113
94526: PUSH
94527: LD_INT 114
94529: PUSH
94530: LD_INT 116
94532: PUSH
94533: LD_INT 117
94535: PUSH
94536: LD_INT 118
94538: PUSH
94539: EMPTY
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: LIST
94548: LIST
94549: LIST
94550: LIST
94551: LIST
94552: LIST
94553: LIST
94554: LIST
94555: LIST
94556: LIST
94557: PUSH
94558: EMPTY
94559: LIST
94560: LIST
94561: ST_TO_ADDR
94562: GO 95801
94564: LD_INT 14
94566: DOUBLE
94567: EQUAL
94568: IFTRUE 94572
94570: GO 94796
94572: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
94573: LD_ADDR_VAR 0 2
94577: PUSH
94578: LD_INT 1
94580: PUSH
94581: LD_INT 2
94583: PUSH
94584: LD_INT 3
94586: PUSH
94587: LD_INT 4
94589: PUSH
94590: LD_INT 5
94592: PUSH
94593: LD_INT 6
94595: PUSH
94596: LD_INT 7
94598: PUSH
94599: LD_INT 8
94601: PUSH
94602: LD_INT 9
94604: PUSH
94605: LD_INT 10
94607: PUSH
94608: LD_INT 11
94610: PUSH
94611: LD_INT 12
94613: PUSH
94614: LD_INT 13
94616: PUSH
94617: LD_INT 14
94619: PUSH
94620: LD_INT 15
94622: PUSH
94623: LD_INT 16
94625: PUSH
94626: LD_INT 17
94628: PUSH
94629: LD_INT 18
94631: PUSH
94632: LD_INT 19
94634: PUSH
94635: LD_INT 20
94637: PUSH
94638: LD_INT 21
94640: PUSH
94641: LD_INT 22
94643: PUSH
94644: LD_INT 23
94646: PUSH
94647: LD_INT 24
94649: PUSH
94650: LD_INT 25
94652: PUSH
94653: LD_INT 26
94655: PUSH
94656: LD_INT 27
94658: PUSH
94659: LD_INT 28
94661: PUSH
94662: LD_INT 29
94664: PUSH
94665: LD_INT 30
94667: PUSH
94668: LD_INT 31
94670: PUSH
94671: LD_INT 32
94673: PUSH
94674: LD_INT 33
94676: PUSH
94677: LD_INT 34
94679: PUSH
94680: LD_INT 36
94682: PUSH
94683: EMPTY
94684: LIST
94685: LIST
94686: LIST
94687: LIST
94688: LIST
94689: LIST
94690: LIST
94691: LIST
94692: LIST
94693: LIST
94694: LIST
94695: LIST
94696: LIST
94697: LIST
94698: LIST
94699: LIST
94700: LIST
94701: LIST
94702: LIST
94703: LIST
94704: LIST
94705: LIST
94706: LIST
94707: LIST
94708: LIST
94709: LIST
94710: LIST
94711: LIST
94712: LIST
94713: LIST
94714: LIST
94715: LIST
94716: LIST
94717: LIST
94718: LIST
94719: PUSH
94720: LD_INT 101
94722: PUSH
94723: LD_INT 102
94725: PUSH
94726: LD_INT 103
94728: PUSH
94729: LD_INT 104
94731: PUSH
94732: LD_INT 105
94734: PUSH
94735: LD_INT 106
94737: PUSH
94738: LD_INT 107
94740: PUSH
94741: LD_INT 108
94743: PUSH
94744: LD_INT 109
94746: PUSH
94747: LD_INT 110
94749: PUSH
94750: LD_INT 111
94752: PUSH
94753: LD_INT 112
94755: PUSH
94756: LD_INT 113
94758: PUSH
94759: LD_INT 114
94761: PUSH
94762: LD_INT 116
94764: PUSH
94765: LD_INT 117
94767: PUSH
94768: LD_INT 118
94770: PUSH
94771: EMPTY
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: LIST
94787: LIST
94788: LIST
94789: PUSH
94790: EMPTY
94791: LIST
94792: LIST
94793: ST_TO_ADDR
94794: GO 95801
94796: LD_INT 15
94798: DOUBLE
94799: EQUAL
94800: IFTRUE 94804
94802: GO 95028
94804: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
94805: LD_ADDR_VAR 0 2
94809: PUSH
94810: LD_INT 1
94812: PUSH
94813: LD_INT 2
94815: PUSH
94816: LD_INT 3
94818: PUSH
94819: LD_INT 4
94821: PUSH
94822: LD_INT 5
94824: PUSH
94825: LD_INT 6
94827: PUSH
94828: LD_INT 7
94830: PUSH
94831: LD_INT 8
94833: PUSH
94834: LD_INT 9
94836: PUSH
94837: LD_INT 10
94839: PUSH
94840: LD_INT 11
94842: PUSH
94843: LD_INT 12
94845: PUSH
94846: LD_INT 13
94848: PUSH
94849: LD_INT 14
94851: PUSH
94852: LD_INT 15
94854: PUSH
94855: LD_INT 16
94857: PUSH
94858: LD_INT 17
94860: PUSH
94861: LD_INT 18
94863: PUSH
94864: LD_INT 19
94866: PUSH
94867: LD_INT 20
94869: PUSH
94870: LD_INT 21
94872: PUSH
94873: LD_INT 22
94875: PUSH
94876: LD_INT 23
94878: PUSH
94879: LD_INT 24
94881: PUSH
94882: LD_INT 25
94884: PUSH
94885: LD_INT 26
94887: PUSH
94888: LD_INT 27
94890: PUSH
94891: LD_INT 28
94893: PUSH
94894: LD_INT 29
94896: PUSH
94897: LD_INT 30
94899: PUSH
94900: LD_INT 31
94902: PUSH
94903: LD_INT 32
94905: PUSH
94906: LD_INT 33
94908: PUSH
94909: LD_INT 34
94911: PUSH
94912: LD_INT 36
94914: PUSH
94915: EMPTY
94916: LIST
94917: LIST
94918: LIST
94919: LIST
94920: LIST
94921: LIST
94922: LIST
94923: LIST
94924: LIST
94925: LIST
94926: LIST
94927: LIST
94928: LIST
94929: LIST
94930: LIST
94931: LIST
94932: LIST
94933: LIST
94934: LIST
94935: LIST
94936: LIST
94937: LIST
94938: LIST
94939: LIST
94940: LIST
94941: LIST
94942: LIST
94943: LIST
94944: LIST
94945: LIST
94946: LIST
94947: LIST
94948: LIST
94949: LIST
94950: LIST
94951: PUSH
94952: LD_INT 101
94954: PUSH
94955: LD_INT 102
94957: PUSH
94958: LD_INT 103
94960: PUSH
94961: LD_INT 104
94963: PUSH
94964: LD_INT 105
94966: PUSH
94967: LD_INT 106
94969: PUSH
94970: LD_INT 107
94972: PUSH
94973: LD_INT 108
94975: PUSH
94976: LD_INT 109
94978: PUSH
94979: LD_INT 110
94981: PUSH
94982: LD_INT 111
94984: PUSH
94985: LD_INT 112
94987: PUSH
94988: LD_INT 113
94990: PUSH
94991: LD_INT 114
94993: PUSH
94994: LD_INT 116
94996: PUSH
94997: LD_INT 117
94999: PUSH
95000: LD_INT 118
95002: PUSH
95003: EMPTY
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: LIST
95013: LIST
95014: LIST
95015: LIST
95016: LIST
95017: LIST
95018: LIST
95019: LIST
95020: LIST
95021: PUSH
95022: EMPTY
95023: LIST
95024: LIST
95025: ST_TO_ADDR
95026: GO 95801
95028: LD_INT 16
95030: DOUBLE
95031: EQUAL
95032: IFTRUE 95036
95034: GO 95172
95036: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
95037: LD_ADDR_VAR 0 2
95041: PUSH
95042: LD_INT 2
95044: PUSH
95045: LD_INT 4
95047: PUSH
95048: LD_INT 5
95050: PUSH
95051: LD_INT 7
95053: PUSH
95054: LD_INT 11
95056: PUSH
95057: LD_INT 12
95059: PUSH
95060: LD_INT 15
95062: PUSH
95063: LD_INT 16
95065: PUSH
95066: LD_INT 20
95068: PUSH
95069: LD_INT 21
95071: PUSH
95072: LD_INT 22
95074: PUSH
95075: LD_INT 23
95077: PUSH
95078: LD_INT 25
95080: PUSH
95081: LD_INT 26
95083: PUSH
95084: LD_INT 30
95086: PUSH
95087: LD_INT 31
95089: PUSH
95090: LD_INT 32
95092: PUSH
95093: LD_INT 33
95095: PUSH
95096: LD_INT 34
95098: PUSH
95099: EMPTY
95100: LIST
95101: LIST
95102: LIST
95103: LIST
95104: LIST
95105: LIST
95106: LIST
95107: LIST
95108: LIST
95109: LIST
95110: LIST
95111: LIST
95112: LIST
95113: LIST
95114: LIST
95115: LIST
95116: LIST
95117: LIST
95118: LIST
95119: PUSH
95120: LD_INT 101
95122: PUSH
95123: LD_INT 102
95125: PUSH
95126: LD_INT 103
95128: PUSH
95129: LD_INT 106
95131: PUSH
95132: LD_INT 108
95134: PUSH
95135: LD_INT 112
95137: PUSH
95138: LD_INT 113
95140: PUSH
95141: LD_INT 114
95143: PUSH
95144: LD_INT 116
95146: PUSH
95147: LD_INT 117
95149: PUSH
95150: LD_INT 118
95152: PUSH
95153: EMPTY
95154: LIST
95155: LIST
95156: LIST
95157: LIST
95158: LIST
95159: LIST
95160: LIST
95161: LIST
95162: LIST
95163: LIST
95164: LIST
95165: PUSH
95166: EMPTY
95167: LIST
95168: LIST
95169: ST_TO_ADDR
95170: GO 95801
95172: LD_INT 17
95174: DOUBLE
95175: EQUAL
95176: IFTRUE 95180
95178: GO 95404
95180: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
95181: LD_ADDR_VAR 0 2
95185: PUSH
95186: LD_INT 1
95188: PUSH
95189: LD_INT 2
95191: PUSH
95192: LD_INT 3
95194: PUSH
95195: LD_INT 4
95197: PUSH
95198: LD_INT 5
95200: PUSH
95201: LD_INT 6
95203: PUSH
95204: LD_INT 7
95206: PUSH
95207: LD_INT 8
95209: PUSH
95210: LD_INT 9
95212: PUSH
95213: LD_INT 10
95215: PUSH
95216: LD_INT 11
95218: PUSH
95219: LD_INT 12
95221: PUSH
95222: LD_INT 13
95224: PUSH
95225: LD_INT 14
95227: PUSH
95228: LD_INT 15
95230: PUSH
95231: LD_INT 16
95233: PUSH
95234: LD_INT 17
95236: PUSH
95237: LD_INT 18
95239: PUSH
95240: LD_INT 19
95242: PUSH
95243: LD_INT 20
95245: PUSH
95246: LD_INT 21
95248: PUSH
95249: LD_INT 22
95251: PUSH
95252: LD_INT 23
95254: PUSH
95255: LD_INT 24
95257: PUSH
95258: LD_INT 25
95260: PUSH
95261: LD_INT 26
95263: PUSH
95264: LD_INT 27
95266: PUSH
95267: LD_INT 28
95269: PUSH
95270: LD_INT 29
95272: PUSH
95273: LD_INT 30
95275: PUSH
95276: LD_INT 31
95278: PUSH
95279: LD_INT 32
95281: PUSH
95282: LD_INT 33
95284: PUSH
95285: LD_INT 34
95287: PUSH
95288: LD_INT 36
95290: PUSH
95291: EMPTY
95292: LIST
95293: LIST
95294: LIST
95295: LIST
95296: LIST
95297: LIST
95298: LIST
95299: LIST
95300: LIST
95301: LIST
95302: LIST
95303: LIST
95304: LIST
95305: LIST
95306: LIST
95307: LIST
95308: LIST
95309: LIST
95310: LIST
95311: LIST
95312: LIST
95313: LIST
95314: LIST
95315: LIST
95316: LIST
95317: LIST
95318: LIST
95319: LIST
95320: LIST
95321: LIST
95322: LIST
95323: LIST
95324: LIST
95325: LIST
95326: LIST
95327: PUSH
95328: LD_INT 101
95330: PUSH
95331: LD_INT 102
95333: PUSH
95334: LD_INT 103
95336: PUSH
95337: LD_INT 104
95339: PUSH
95340: LD_INT 105
95342: PUSH
95343: LD_INT 106
95345: PUSH
95346: LD_INT 107
95348: PUSH
95349: LD_INT 108
95351: PUSH
95352: LD_INT 109
95354: PUSH
95355: LD_INT 110
95357: PUSH
95358: LD_INT 111
95360: PUSH
95361: LD_INT 112
95363: PUSH
95364: LD_INT 113
95366: PUSH
95367: LD_INT 114
95369: PUSH
95370: LD_INT 116
95372: PUSH
95373: LD_INT 117
95375: PUSH
95376: LD_INT 118
95378: PUSH
95379: EMPTY
95380: LIST
95381: LIST
95382: LIST
95383: LIST
95384: LIST
95385: LIST
95386: LIST
95387: LIST
95388: LIST
95389: LIST
95390: LIST
95391: LIST
95392: LIST
95393: LIST
95394: LIST
95395: LIST
95396: LIST
95397: PUSH
95398: EMPTY
95399: LIST
95400: LIST
95401: ST_TO_ADDR
95402: GO 95801
95404: LD_INT 18
95406: DOUBLE
95407: EQUAL
95408: IFTRUE 95412
95410: GO 95560
95412: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
95413: LD_ADDR_VAR 0 2
95417: PUSH
95418: LD_INT 2
95420: PUSH
95421: LD_INT 4
95423: PUSH
95424: LD_INT 5
95426: PUSH
95427: LD_INT 7
95429: PUSH
95430: LD_INT 11
95432: PUSH
95433: LD_INT 12
95435: PUSH
95436: LD_INT 15
95438: PUSH
95439: LD_INT 16
95441: PUSH
95442: LD_INT 20
95444: PUSH
95445: LD_INT 21
95447: PUSH
95448: LD_INT 22
95450: PUSH
95451: LD_INT 23
95453: PUSH
95454: LD_INT 25
95456: PUSH
95457: LD_INT 26
95459: PUSH
95460: LD_INT 30
95462: PUSH
95463: LD_INT 31
95465: PUSH
95466: LD_INT 32
95468: PUSH
95469: LD_INT 33
95471: PUSH
95472: LD_INT 34
95474: PUSH
95475: LD_INT 35
95477: PUSH
95478: LD_INT 36
95480: PUSH
95481: EMPTY
95482: LIST
95483: LIST
95484: LIST
95485: LIST
95486: LIST
95487: LIST
95488: LIST
95489: LIST
95490: LIST
95491: LIST
95492: LIST
95493: LIST
95494: LIST
95495: LIST
95496: LIST
95497: LIST
95498: LIST
95499: LIST
95500: LIST
95501: LIST
95502: LIST
95503: PUSH
95504: LD_INT 101
95506: PUSH
95507: LD_INT 102
95509: PUSH
95510: LD_INT 103
95512: PUSH
95513: LD_INT 106
95515: PUSH
95516: LD_INT 108
95518: PUSH
95519: LD_INT 112
95521: PUSH
95522: LD_INT 113
95524: PUSH
95525: LD_INT 114
95527: PUSH
95528: LD_INT 115
95530: PUSH
95531: LD_INT 116
95533: PUSH
95534: LD_INT 117
95536: PUSH
95537: LD_INT 118
95539: PUSH
95540: EMPTY
95541: LIST
95542: LIST
95543: LIST
95544: LIST
95545: LIST
95546: LIST
95547: LIST
95548: LIST
95549: LIST
95550: LIST
95551: LIST
95552: LIST
95553: PUSH
95554: EMPTY
95555: LIST
95556: LIST
95557: ST_TO_ADDR
95558: GO 95801
95560: LD_INT 19
95562: DOUBLE
95563: EQUAL
95564: IFTRUE 95568
95566: GO 95800
95568: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
95569: LD_ADDR_VAR 0 2
95573: PUSH
95574: LD_INT 1
95576: PUSH
95577: LD_INT 2
95579: PUSH
95580: LD_INT 3
95582: PUSH
95583: LD_INT 4
95585: PUSH
95586: LD_INT 5
95588: PUSH
95589: LD_INT 6
95591: PUSH
95592: LD_INT 7
95594: PUSH
95595: LD_INT 8
95597: PUSH
95598: LD_INT 9
95600: PUSH
95601: LD_INT 10
95603: PUSH
95604: LD_INT 11
95606: PUSH
95607: LD_INT 12
95609: PUSH
95610: LD_INT 13
95612: PUSH
95613: LD_INT 14
95615: PUSH
95616: LD_INT 15
95618: PUSH
95619: LD_INT 16
95621: PUSH
95622: LD_INT 17
95624: PUSH
95625: LD_INT 18
95627: PUSH
95628: LD_INT 19
95630: PUSH
95631: LD_INT 20
95633: PUSH
95634: LD_INT 21
95636: PUSH
95637: LD_INT 22
95639: PUSH
95640: LD_INT 23
95642: PUSH
95643: LD_INT 24
95645: PUSH
95646: LD_INT 25
95648: PUSH
95649: LD_INT 26
95651: PUSH
95652: LD_INT 27
95654: PUSH
95655: LD_INT 28
95657: PUSH
95658: LD_INT 29
95660: PUSH
95661: LD_INT 30
95663: PUSH
95664: LD_INT 31
95666: PUSH
95667: LD_INT 32
95669: PUSH
95670: LD_INT 33
95672: PUSH
95673: LD_INT 34
95675: PUSH
95676: LD_INT 35
95678: PUSH
95679: LD_INT 36
95681: PUSH
95682: EMPTY
95683: LIST
95684: LIST
95685: LIST
95686: LIST
95687: LIST
95688: LIST
95689: LIST
95690: LIST
95691: LIST
95692: LIST
95693: LIST
95694: LIST
95695: LIST
95696: LIST
95697: LIST
95698: LIST
95699: LIST
95700: LIST
95701: LIST
95702: LIST
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: LIST
95709: LIST
95710: LIST
95711: LIST
95712: LIST
95713: LIST
95714: LIST
95715: LIST
95716: LIST
95717: LIST
95718: LIST
95719: PUSH
95720: LD_INT 101
95722: PUSH
95723: LD_INT 102
95725: PUSH
95726: LD_INT 103
95728: PUSH
95729: LD_INT 104
95731: PUSH
95732: LD_INT 105
95734: PUSH
95735: LD_INT 106
95737: PUSH
95738: LD_INT 107
95740: PUSH
95741: LD_INT 108
95743: PUSH
95744: LD_INT 109
95746: PUSH
95747: LD_INT 110
95749: PUSH
95750: LD_INT 111
95752: PUSH
95753: LD_INT 112
95755: PUSH
95756: LD_INT 113
95758: PUSH
95759: LD_INT 114
95761: PUSH
95762: LD_INT 115
95764: PUSH
95765: LD_INT 116
95767: PUSH
95768: LD_INT 117
95770: PUSH
95771: LD_INT 118
95773: PUSH
95774: EMPTY
95775: LIST
95776: LIST
95777: LIST
95778: LIST
95779: LIST
95780: LIST
95781: LIST
95782: LIST
95783: LIST
95784: LIST
95785: LIST
95786: LIST
95787: LIST
95788: LIST
95789: LIST
95790: LIST
95791: LIST
95792: LIST
95793: PUSH
95794: EMPTY
95795: LIST
95796: LIST
95797: ST_TO_ADDR
95798: GO 95801
95800: POP
// end else
95801: GO 96032
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
95803: LD_ADDR_VAR 0 2
95807: PUSH
95808: LD_INT 1
95810: PUSH
95811: LD_INT 2
95813: PUSH
95814: LD_INT 3
95816: PUSH
95817: LD_INT 4
95819: PUSH
95820: LD_INT 5
95822: PUSH
95823: LD_INT 6
95825: PUSH
95826: LD_INT 7
95828: PUSH
95829: LD_INT 8
95831: PUSH
95832: LD_INT 9
95834: PUSH
95835: LD_INT 10
95837: PUSH
95838: LD_INT 11
95840: PUSH
95841: LD_INT 12
95843: PUSH
95844: LD_INT 13
95846: PUSH
95847: LD_INT 14
95849: PUSH
95850: LD_INT 15
95852: PUSH
95853: LD_INT 16
95855: PUSH
95856: LD_INT 17
95858: PUSH
95859: LD_INT 18
95861: PUSH
95862: LD_INT 19
95864: PUSH
95865: LD_INT 20
95867: PUSH
95868: LD_INT 21
95870: PUSH
95871: LD_INT 22
95873: PUSH
95874: LD_INT 23
95876: PUSH
95877: LD_INT 24
95879: PUSH
95880: LD_INT 25
95882: PUSH
95883: LD_INT 26
95885: PUSH
95886: LD_INT 27
95888: PUSH
95889: LD_INT 28
95891: PUSH
95892: LD_INT 29
95894: PUSH
95895: LD_INT 30
95897: PUSH
95898: LD_INT 31
95900: PUSH
95901: LD_INT 32
95903: PUSH
95904: LD_INT 33
95906: PUSH
95907: LD_INT 34
95909: PUSH
95910: LD_INT 35
95912: PUSH
95913: LD_INT 36
95915: PUSH
95916: EMPTY
95917: LIST
95918: LIST
95919: LIST
95920: LIST
95921: LIST
95922: LIST
95923: LIST
95924: LIST
95925: LIST
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: LIST
95950: LIST
95951: LIST
95952: LIST
95953: PUSH
95954: LD_INT 101
95956: PUSH
95957: LD_INT 102
95959: PUSH
95960: LD_INT 103
95962: PUSH
95963: LD_INT 104
95965: PUSH
95966: LD_INT 105
95968: PUSH
95969: LD_INT 106
95971: PUSH
95972: LD_INT 107
95974: PUSH
95975: LD_INT 108
95977: PUSH
95978: LD_INT 109
95980: PUSH
95981: LD_INT 110
95983: PUSH
95984: LD_INT 111
95986: PUSH
95987: LD_INT 112
95989: PUSH
95990: LD_INT 113
95992: PUSH
95993: LD_INT 114
95995: PUSH
95996: LD_INT 115
95998: PUSH
95999: LD_INT 116
96001: PUSH
96002: LD_INT 117
96004: PUSH
96005: LD_INT 118
96007: PUSH
96008: EMPTY
96009: LIST
96010: LIST
96011: LIST
96012: LIST
96013: LIST
96014: LIST
96015: LIST
96016: LIST
96017: LIST
96018: LIST
96019: LIST
96020: LIST
96021: LIST
96022: LIST
96023: LIST
96024: LIST
96025: LIST
96026: LIST
96027: PUSH
96028: EMPTY
96029: LIST
96030: LIST
96031: ST_TO_ADDR
// if result then
96032: LD_VAR 0 2
96036: IFFALSE 96822
// begin normal :=  ;
96038: LD_ADDR_VAR 0 5
96042: PUSH
96043: LD_STRING 
96045: ST_TO_ADDR
// hardcore :=  ;
96046: LD_ADDR_VAR 0 6
96050: PUSH
96051: LD_STRING 
96053: ST_TO_ADDR
// active :=  ;
96054: LD_ADDR_VAR 0 7
96058: PUSH
96059: LD_STRING 
96061: ST_TO_ADDR
// for i = 1 to normalCounter do
96062: LD_ADDR_VAR 0 8
96066: PUSH
96067: DOUBLE
96068: LD_INT 1
96070: DEC
96071: ST_TO_ADDR
96072: LD_EXP 110
96076: PUSH
96077: FOR_TO
96078: IFFALSE 96179
// begin tmp := 0 ;
96080: LD_ADDR_VAR 0 3
96084: PUSH
96085: LD_STRING 0
96087: ST_TO_ADDR
// if result [ 1 ] then
96088: LD_VAR 0 2
96092: PUSH
96093: LD_INT 1
96095: ARRAY
96096: IFFALSE 96161
// if result [ 1 ] [ 1 ] = i then
96098: LD_VAR 0 2
96102: PUSH
96103: LD_INT 1
96105: ARRAY
96106: PUSH
96107: LD_INT 1
96109: ARRAY
96110: PUSH
96111: LD_VAR 0 8
96115: EQUAL
96116: IFFALSE 96161
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
96118: LD_ADDR_VAR 0 2
96122: PUSH
96123: LD_VAR 0 2
96127: PPUSH
96128: LD_INT 1
96130: PPUSH
96131: LD_VAR 0 2
96135: PUSH
96136: LD_INT 1
96138: ARRAY
96139: PPUSH
96140: LD_INT 1
96142: PPUSH
96143: CALL_OW 3
96147: PPUSH
96148: CALL_OW 1
96152: ST_TO_ADDR
// tmp := 1 ;
96153: LD_ADDR_VAR 0 3
96157: PUSH
96158: LD_STRING 1
96160: ST_TO_ADDR
// end ; normal := normal & tmp ;
96161: LD_ADDR_VAR 0 5
96165: PUSH
96166: LD_VAR 0 5
96170: PUSH
96171: LD_VAR 0 3
96175: STR
96176: ST_TO_ADDR
// end ;
96177: GO 96077
96179: POP
96180: POP
// for i = 1 to hardcoreCounter do
96181: LD_ADDR_VAR 0 8
96185: PUSH
96186: DOUBLE
96187: LD_INT 1
96189: DEC
96190: ST_TO_ADDR
96191: LD_EXP 111
96195: PUSH
96196: FOR_TO
96197: IFFALSE 96302
// begin tmp := 0 ;
96199: LD_ADDR_VAR 0 3
96203: PUSH
96204: LD_STRING 0
96206: ST_TO_ADDR
// if result [ 2 ] then
96207: LD_VAR 0 2
96211: PUSH
96212: LD_INT 2
96214: ARRAY
96215: IFFALSE 96284
// if result [ 2 ] [ 1 ] = 100 + i then
96217: LD_VAR 0 2
96221: PUSH
96222: LD_INT 2
96224: ARRAY
96225: PUSH
96226: LD_INT 1
96228: ARRAY
96229: PUSH
96230: LD_INT 100
96232: PUSH
96233: LD_VAR 0 8
96237: PLUS
96238: EQUAL
96239: IFFALSE 96284
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
96241: LD_ADDR_VAR 0 2
96245: PUSH
96246: LD_VAR 0 2
96250: PPUSH
96251: LD_INT 2
96253: PPUSH
96254: LD_VAR 0 2
96258: PUSH
96259: LD_INT 2
96261: ARRAY
96262: PPUSH
96263: LD_INT 1
96265: PPUSH
96266: CALL_OW 3
96270: PPUSH
96271: CALL_OW 1
96275: ST_TO_ADDR
// tmp := 1 ;
96276: LD_ADDR_VAR 0 3
96280: PUSH
96281: LD_STRING 1
96283: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
96284: LD_ADDR_VAR 0 6
96288: PUSH
96289: LD_VAR 0 6
96293: PUSH
96294: LD_VAR 0 3
96298: STR
96299: ST_TO_ADDR
// end ;
96300: GO 96196
96302: POP
96303: POP
// if isGameLoad then
96304: LD_VAR 0 1
96308: IFFALSE 96783
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
96310: LD_ADDR_VAR 0 4
96314: PUSH
96315: LD_EXP 114
96319: PUSH
96320: LD_EXP 113
96324: PUSH
96325: LD_EXP 115
96329: PUSH
96330: LD_EXP 112
96334: PUSH
96335: LD_EXP 116
96339: PUSH
96340: LD_EXP 117
96344: PUSH
96345: LD_EXP 118
96349: PUSH
96350: LD_EXP 119
96354: PUSH
96355: LD_EXP 120
96359: PUSH
96360: LD_EXP 121
96364: PUSH
96365: LD_EXP 122
96369: PUSH
96370: LD_EXP 123
96374: PUSH
96375: LD_EXP 124
96379: PUSH
96380: LD_EXP 125
96384: PUSH
96385: LD_EXP 133
96389: PUSH
96390: LD_EXP 134
96394: PUSH
96395: LD_EXP 135
96399: PUSH
96400: LD_EXP 136
96404: PUSH
96405: LD_EXP 138
96409: PUSH
96410: LD_EXP 139
96414: PUSH
96415: LD_EXP 140
96419: PUSH
96420: LD_EXP 143
96424: PUSH
96425: LD_EXP 145
96429: PUSH
96430: LD_EXP 146
96434: PUSH
96435: LD_EXP 147
96439: PUSH
96440: LD_EXP 149
96444: PUSH
96445: LD_EXP 150
96449: PUSH
96450: LD_EXP 153
96454: PUSH
96455: LD_EXP 154
96459: PUSH
96460: LD_EXP 155
96464: PUSH
96465: LD_EXP 156
96469: PUSH
96470: LD_EXP 157
96474: PUSH
96475: LD_EXP 158
96479: PUSH
96480: LD_EXP 159
96484: PUSH
96485: LD_EXP 160
96489: PUSH
96490: LD_EXP 161
96494: PUSH
96495: LD_EXP 126
96499: PUSH
96500: LD_EXP 127
96504: PUSH
96505: LD_EXP 130
96509: PUSH
96510: LD_EXP 131
96514: PUSH
96515: LD_EXP 132
96519: PUSH
96520: LD_EXP 128
96524: PUSH
96525: LD_EXP 129
96529: PUSH
96530: LD_EXP 137
96534: PUSH
96535: LD_EXP 141
96539: PUSH
96540: LD_EXP 142
96544: PUSH
96545: LD_EXP 144
96549: PUSH
96550: LD_EXP 148
96554: PUSH
96555: LD_EXP 151
96559: PUSH
96560: LD_EXP 152
96564: PUSH
96565: LD_EXP 162
96569: PUSH
96570: LD_EXP 163
96574: PUSH
96575: LD_EXP 164
96579: PUSH
96580: LD_EXP 165
96584: PUSH
96585: EMPTY
96586: LIST
96587: LIST
96588: LIST
96589: LIST
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: LIST
96595: LIST
96596: LIST
96597: LIST
96598: LIST
96599: LIST
96600: LIST
96601: LIST
96602: LIST
96603: LIST
96604: LIST
96605: LIST
96606: LIST
96607: LIST
96608: LIST
96609: LIST
96610: LIST
96611: LIST
96612: LIST
96613: LIST
96614: LIST
96615: LIST
96616: LIST
96617: LIST
96618: LIST
96619: LIST
96620: LIST
96621: LIST
96622: LIST
96623: LIST
96624: LIST
96625: LIST
96626: LIST
96627: LIST
96628: LIST
96629: LIST
96630: LIST
96631: LIST
96632: LIST
96633: LIST
96634: LIST
96635: LIST
96636: LIST
96637: LIST
96638: LIST
96639: LIST
96640: ST_TO_ADDR
// tmp :=  ;
96641: LD_ADDR_VAR 0 3
96645: PUSH
96646: LD_STRING 
96648: ST_TO_ADDR
// for i = 1 to normalCounter do
96649: LD_ADDR_VAR 0 8
96653: PUSH
96654: DOUBLE
96655: LD_INT 1
96657: DEC
96658: ST_TO_ADDR
96659: LD_EXP 110
96663: PUSH
96664: FOR_TO
96665: IFFALSE 96701
// begin if flags [ i ] then
96667: LD_VAR 0 4
96671: PUSH
96672: LD_VAR 0 8
96676: ARRAY
96677: IFFALSE 96699
// tmp := tmp & i & ; ;
96679: LD_ADDR_VAR 0 3
96683: PUSH
96684: LD_VAR 0 3
96688: PUSH
96689: LD_VAR 0 8
96693: STR
96694: PUSH
96695: LD_STRING ;
96697: STR
96698: ST_TO_ADDR
// end ;
96699: GO 96664
96701: POP
96702: POP
// for i = 1 to hardcoreCounter do
96703: LD_ADDR_VAR 0 8
96707: PUSH
96708: DOUBLE
96709: LD_INT 1
96711: DEC
96712: ST_TO_ADDR
96713: LD_EXP 111
96717: PUSH
96718: FOR_TO
96719: IFFALSE 96765
// begin if flags [ normalCounter + i ] then
96721: LD_VAR 0 4
96725: PUSH
96726: LD_EXP 110
96730: PUSH
96731: LD_VAR 0 8
96735: PLUS
96736: ARRAY
96737: IFFALSE 96763
// tmp := tmp & ( 100 + i ) & ; ;
96739: LD_ADDR_VAR 0 3
96743: PUSH
96744: LD_VAR 0 3
96748: PUSH
96749: LD_INT 100
96751: PUSH
96752: LD_VAR 0 8
96756: PLUS
96757: STR
96758: PUSH
96759: LD_STRING ;
96761: STR
96762: ST_TO_ADDR
// end ;
96763: GO 96718
96765: POP
96766: POP
// if tmp then
96767: LD_VAR 0 3
96771: IFFALSE 96783
// active := tmp ;
96773: LD_ADDR_VAR 0 7
96777: PUSH
96778: LD_VAR 0 3
96782: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
96783: LD_STRING getStreamItemsFromMission("
96785: PUSH
96786: LD_VAR 0 5
96790: STR
96791: PUSH
96792: LD_STRING ","
96794: STR
96795: PUSH
96796: LD_VAR 0 6
96800: STR
96801: PUSH
96802: LD_STRING ","
96804: STR
96805: PUSH
96806: LD_VAR 0 7
96810: STR
96811: PUSH
96812: LD_STRING ")
96814: STR
96815: PPUSH
96816: CALL_OW 559
// end else
96820: GO 96829
// ToLua ( getStreamItemsFromMission("","","") ) ;
96822: LD_STRING getStreamItemsFromMission("","","")
96824: PPUSH
96825: CALL_OW 559
// end ;
96829: LD_VAR 0 2
96833: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
96834: LD_EXP 109
96838: PUSH
96839: LD_EXP 114
96843: AND
96844: IFFALSE 96968
96846: GO 96848
96848: DISABLE
96849: LD_INT 0
96851: PPUSH
96852: PPUSH
// begin enable ;
96853: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
96854: LD_ADDR_VAR 0 2
96858: PUSH
96859: LD_INT 22
96861: PUSH
96862: LD_OWVAR 2
96866: PUSH
96867: EMPTY
96868: LIST
96869: LIST
96870: PUSH
96871: LD_INT 2
96873: PUSH
96874: LD_INT 34
96876: PUSH
96877: LD_INT 7
96879: PUSH
96880: EMPTY
96881: LIST
96882: LIST
96883: PUSH
96884: LD_INT 34
96886: PUSH
96887: LD_INT 45
96889: PUSH
96890: EMPTY
96891: LIST
96892: LIST
96893: PUSH
96894: LD_INT 34
96896: PUSH
96897: LD_INT 28
96899: PUSH
96900: EMPTY
96901: LIST
96902: LIST
96903: PUSH
96904: LD_INT 34
96906: PUSH
96907: LD_INT 47
96909: PUSH
96910: EMPTY
96911: LIST
96912: LIST
96913: PUSH
96914: EMPTY
96915: LIST
96916: LIST
96917: LIST
96918: LIST
96919: LIST
96920: PUSH
96921: EMPTY
96922: LIST
96923: LIST
96924: PPUSH
96925: CALL_OW 69
96929: ST_TO_ADDR
// if not tmp then
96930: LD_VAR 0 2
96934: NOT
96935: IFFALSE 96939
// exit ;
96937: GO 96968
// for i in tmp do
96939: LD_ADDR_VAR 0 1
96943: PUSH
96944: LD_VAR 0 2
96948: PUSH
96949: FOR_IN
96950: IFFALSE 96966
// begin SetLives ( i , 0 ) ;
96952: LD_VAR 0 1
96956: PPUSH
96957: LD_INT 0
96959: PPUSH
96960: CALL_OW 234
// end ;
96964: GO 96949
96966: POP
96967: POP
// end ;
96968: PPOPN 2
96970: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
96971: LD_EXP 109
96975: PUSH
96976: LD_EXP 115
96980: AND
96981: IFFALSE 97065
96983: GO 96985
96985: DISABLE
96986: LD_INT 0
96988: PPUSH
96989: PPUSH
// begin enable ;
96990: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
96991: LD_ADDR_VAR 0 2
96995: PUSH
96996: LD_INT 22
96998: PUSH
96999: LD_OWVAR 2
97003: PUSH
97004: EMPTY
97005: LIST
97006: LIST
97007: PUSH
97008: LD_INT 32
97010: PUSH
97011: LD_INT 3
97013: PUSH
97014: EMPTY
97015: LIST
97016: LIST
97017: PUSH
97018: EMPTY
97019: LIST
97020: LIST
97021: PPUSH
97022: CALL_OW 69
97026: ST_TO_ADDR
// if not tmp then
97027: LD_VAR 0 2
97031: NOT
97032: IFFALSE 97036
// exit ;
97034: GO 97065
// for i in tmp do
97036: LD_ADDR_VAR 0 1
97040: PUSH
97041: LD_VAR 0 2
97045: PUSH
97046: FOR_IN
97047: IFFALSE 97063
// begin SetLives ( i , 0 ) ;
97049: LD_VAR 0 1
97053: PPUSH
97054: LD_INT 0
97056: PPUSH
97057: CALL_OW 234
// end ;
97061: GO 97046
97063: POP
97064: POP
// end ;
97065: PPOPN 2
97067: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
97068: LD_EXP 109
97072: PUSH
97073: LD_EXP 112
97077: AND
97078: IFFALSE 97171
97080: GO 97082
97082: DISABLE
97083: LD_INT 0
97085: PPUSH
// begin enable ;
97086: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
97087: LD_ADDR_VAR 0 1
97091: PUSH
97092: LD_INT 22
97094: PUSH
97095: LD_OWVAR 2
97099: PUSH
97100: EMPTY
97101: LIST
97102: LIST
97103: PUSH
97104: LD_INT 2
97106: PUSH
97107: LD_INT 25
97109: PUSH
97110: LD_INT 5
97112: PUSH
97113: EMPTY
97114: LIST
97115: LIST
97116: PUSH
97117: LD_INT 25
97119: PUSH
97120: LD_INT 9
97122: PUSH
97123: EMPTY
97124: LIST
97125: LIST
97126: PUSH
97127: LD_INT 25
97129: PUSH
97130: LD_INT 8
97132: PUSH
97133: EMPTY
97134: LIST
97135: LIST
97136: PUSH
97137: EMPTY
97138: LIST
97139: LIST
97140: LIST
97141: LIST
97142: PUSH
97143: EMPTY
97144: LIST
97145: LIST
97146: PPUSH
97147: CALL_OW 69
97151: PUSH
97152: FOR_IN
97153: IFFALSE 97169
// begin SetClass ( i , 1 ) ;
97155: LD_VAR 0 1
97159: PPUSH
97160: LD_INT 1
97162: PPUSH
97163: CALL_OW 336
// end ;
97167: GO 97152
97169: POP
97170: POP
// end ;
97171: PPOPN 1
97173: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
97174: LD_EXP 109
97178: PUSH
97179: LD_EXP 113
97183: AND
97184: PUSH
97185: LD_OWVAR 65
97189: PUSH
97190: LD_INT 7
97192: LESS
97193: AND
97194: IFFALSE 97208
97196: GO 97198
97198: DISABLE
// begin enable ;
97199: ENABLE
// game_speed := 7 ;
97200: LD_ADDR_OWVAR 65
97204: PUSH
97205: LD_INT 7
97207: ST_TO_ADDR
// end ;
97208: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
97209: LD_EXP 109
97213: PUSH
97214: LD_EXP 116
97218: AND
97219: IFFALSE 97421
97221: GO 97223
97223: DISABLE
97224: LD_INT 0
97226: PPUSH
97227: PPUSH
97228: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
97229: LD_ADDR_VAR 0 3
97233: PUSH
97234: LD_INT 81
97236: PUSH
97237: LD_OWVAR 2
97241: PUSH
97242: EMPTY
97243: LIST
97244: LIST
97245: PUSH
97246: LD_INT 21
97248: PUSH
97249: LD_INT 1
97251: PUSH
97252: EMPTY
97253: LIST
97254: LIST
97255: PUSH
97256: EMPTY
97257: LIST
97258: LIST
97259: PPUSH
97260: CALL_OW 69
97264: ST_TO_ADDR
// if not tmp then
97265: LD_VAR 0 3
97269: NOT
97270: IFFALSE 97274
// exit ;
97272: GO 97421
// if tmp > 5 then
97274: LD_VAR 0 3
97278: PUSH
97279: LD_INT 5
97281: GREATER
97282: IFFALSE 97294
// k := 5 else
97284: LD_ADDR_VAR 0 2
97288: PUSH
97289: LD_INT 5
97291: ST_TO_ADDR
97292: GO 97304
// k := tmp ;
97294: LD_ADDR_VAR 0 2
97298: PUSH
97299: LD_VAR 0 3
97303: ST_TO_ADDR
// for i := 1 to k do
97304: LD_ADDR_VAR 0 1
97308: PUSH
97309: DOUBLE
97310: LD_INT 1
97312: DEC
97313: ST_TO_ADDR
97314: LD_VAR 0 2
97318: PUSH
97319: FOR_TO
97320: IFFALSE 97419
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
97322: LD_VAR 0 3
97326: PUSH
97327: LD_VAR 0 1
97331: ARRAY
97332: PPUSH
97333: LD_VAR 0 1
97337: PUSH
97338: LD_INT 4
97340: MOD
97341: PUSH
97342: LD_INT 1
97344: PLUS
97345: PPUSH
97346: CALL_OW 259
97350: PUSH
97351: LD_INT 10
97353: LESS
97354: IFFALSE 97417
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
97356: LD_VAR 0 3
97360: PUSH
97361: LD_VAR 0 1
97365: ARRAY
97366: PPUSH
97367: LD_VAR 0 1
97371: PUSH
97372: LD_INT 4
97374: MOD
97375: PUSH
97376: LD_INT 1
97378: PLUS
97379: PPUSH
97380: LD_VAR 0 3
97384: PUSH
97385: LD_VAR 0 1
97389: ARRAY
97390: PPUSH
97391: LD_VAR 0 1
97395: PUSH
97396: LD_INT 4
97398: MOD
97399: PUSH
97400: LD_INT 1
97402: PLUS
97403: PPUSH
97404: CALL_OW 259
97408: PUSH
97409: LD_INT 1
97411: PLUS
97412: PPUSH
97413: CALL_OW 237
97417: GO 97319
97419: POP
97420: POP
// end ;
97421: PPOPN 3
97423: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
97424: LD_EXP 109
97428: PUSH
97429: LD_EXP 117
97433: AND
97434: IFFALSE 97454
97436: GO 97438
97438: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
97439: LD_INT 4
97441: PPUSH
97442: LD_OWVAR 2
97446: PPUSH
97447: LD_INT 0
97449: PPUSH
97450: CALL_OW 324
97454: END
// every 0 0$1 trigger StreamModeActive and sShovel do
97455: LD_EXP 109
97459: PUSH
97460: LD_EXP 146
97464: AND
97465: IFFALSE 97485
97467: GO 97469
97469: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
97470: LD_INT 19
97472: PPUSH
97473: LD_OWVAR 2
97477: PPUSH
97478: LD_INT 0
97480: PPUSH
97481: CALL_OW 324
97485: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
97486: LD_EXP 109
97490: PUSH
97491: LD_EXP 118
97495: AND
97496: IFFALSE 97598
97498: GO 97500
97500: DISABLE
97501: LD_INT 0
97503: PPUSH
97504: PPUSH
// begin enable ;
97505: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
97506: LD_ADDR_VAR 0 2
97510: PUSH
97511: LD_INT 22
97513: PUSH
97514: LD_OWVAR 2
97518: PUSH
97519: EMPTY
97520: LIST
97521: LIST
97522: PUSH
97523: LD_INT 2
97525: PUSH
97526: LD_INT 34
97528: PUSH
97529: LD_INT 11
97531: PUSH
97532: EMPTY
97533: LIST
97534: LIST
97535: PUSH
97536: LD_INT 34
97538: PUSH
97539: LD_INT 30
97541: PUSH
97542: EMPTY
97543: LIST
97544: LIST
97545: PUSH
97546: EMPTY
97547: LIST
97548: LIST
97549: LIST
97550: PUSH
97551: EMPTY
97552: LIST
97553: LIST
97554: PPUSH
97555: CALL_OW 69
97559: ST_TO_ADDR
// if not tmp then
97560: LD_VAR 0 2
97564: NOT
97565: IFFALSE 97569
// exit ;
97567: GO 97598
// for i in tmp do
97569: LD_ADDR_VAR 0 1
97573: PUSH
97574: LD_VAR 0 2
97578: PUSH
97579: FOR_IN
97580: IFFALSE 97596
// begin SetLives ( i , 0 ) ;
97582: LD_VAR 0 1
97586: PPUSH
97587: LD_INT 0
97589: PPUSH
97590: CALL_OW 234
// end ;
97594: GO 97579
97596: POP
97597: POP
// end ;
97598: PPOPN 2
97600: END
// every 0 0$1 trigger StreamModeActive and sBunker do
97601: LD_EXP 109
97605: PUSH
97606: LD_EXP 119
97610: AND
97611: IFFALSE 97631
97613: GO 97615
97615: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
97616: LD_INT 32
97618: PPUSH
97619: LD_OWVAR 2
97623: PPUSH
97624: LD_INT 0
97626: PPUSH
97627: CALL_OW 324
97631: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
97632: LD_EXP 109
97636: PUSH
97637: LD_EXP 120
97641: AND
97642: IFFALSE 97823
97644: GO 97646
97646: DISABLE
97647: LD_INT 0
97649: PPUSH
97650: PPUSH
97651: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
97652: LD_ADDR_VAR 0 2
97656: PUSH
97657: LD_INT 22
97659: PUSH
97660: LD_OWVAR 2
97664: PUSH
97665: EMPTY
97666: LIST
97667: LIST
97668: PUSH
97669: LD_INT 33
97671: PUSH
97672: LD_INT 3
97674: PUSH
97675: EMPTY
97676: LIST
97677: LIST
97678: PUSH
97679: EMPTY
97680: LIST
97681: LIST
97682: PPUSH
97683: CALL_OW 69
97687: ST_TO_ADDR
// if not tmp then
97688: LD_VAR 0 2
97692: NOT
97693: IFFALSE 97697
// exit ;
97695: GO 97823
// side := 0 ;
97697: LD_ADDR_VAR 0 3
97701: PUSH
97702: LD_INT 0
97704: ST_TO_ADDR
// for i := 1 to 8 do
97705: LD_ADDR_VAR 0 1
97709: PUSH
97710: DOUBLE
97711: LD_INT 1
97713: DEC
97714: ST_TO_ADDR
97715: LD_INT 8
97717: PUSH
97718: FOR_TO
97719: IFFALSE 97767
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
97721: LD_OWVAR 2
97725: PUSH
97726: LD_VAR 0 1
97730: NONEQUAL
97731: PUSH
97732: LD_OWVAR 2
97736: PPUSH
97737: LD_VAR 0 1
97741: PPUSH
97742: CALL_OW 81
97746: PUSH
97747: LD_INT 2
97749: EQUAL
97750: AND
97751: IFFALSE 97765
// begin side := i ;
97753: LD_ADDR_VAR 0 3
97757: PUSH
97758: LD_VAR 0 1
97762: ST_TO_ADDR
// break ;
97763: GO 97767
// end ;
97765: GO 97718
97767: POP
97768: POP
// if not side then
97769: LD_VAR 0 3
97773: NOT
97774: IFFALSE 97778
// exit ;
97776: GO 97823
// for i := 1 to tmp do
97778: LD_ADDR_VAR 0 1
97782: PUSH
97783: DOUBLE
97784: LD_INT 1
97786: DEC
97787: ST_TO_ADDR
97788: LD_VAR 0 2
97792: PUSH
97793: FOR_TO
97794: IFFALSE 97821
// if Prob ( 60 ) then
97796: LD_INT 60
97798: PPUSH
97799: CALL_OW 13
97803: IFFALSE 97819
// SetSide ( i , side ) ;
97805: LD_VAR 0 1
97809: PPUSH
97810: LD_VAR 0 3
97814: PPUSH
97815: CALL_OW 235
97819: GO 97793
97821: POP
97822: POP
// end ;
97823: PPOPN 3
97825: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
97826: LD_EXP 109
97830: PUSH
97831: LD_EXP 122
97835: AND
97836: IFFALSE 97955
97838: GO 97840
97840: DISABLE
97841: LD_INT 0
97843: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
97844: LD_ADDR_VAR 0 1
97848: PUSH
97849: LD_INT 22
97851: PUSH
97852: LD_OWVAR 2
97856: PUSH
97857: EMPTY
97858: LIST
97859: LIST
97860: PUSH
97861: LD_INT 21
97863: PUSH
97864: LD_INT 1
97866: PUSH
97867: EMPTY
97868: LIST
97869: LIST
97870: PUSH
97871: LD_INT 3
97873: PUSH
97874: LD_INT 23
97876: PUSH
97877: LD_INT 0
97879: PUSH
97880: EMPTY
97881: LIST
97882: LIST
97883: PUSH
97884: EMPTY
97885: LIST
97886: LIST
97887: PUSH
97888: EMPTY
97889: LIST
97890: LIST
97891: LIST
97892: PPUSH
97893: CALL_OW 69
97897: PUSH
97898: FOR_IN
97899: IFFALSE 97953
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97901: LD_VAR 0 1
97905: PPUSH
97906: CALL_OW 257
97910: PUSH
97911: LD_INT 1
97913: PUSH
97914: LD_INT 2
97916: PUSH
97917: LD_INT 3
97919: PUSH
97920: LD_INT 4
97922: PUSH
97923: EMPTY
97924: LIST
97925: LIST
97926: LIST
97927: LIST
97928: IN
97929: IFFALSE 97951
// SetClass ( un , rand ( 1 , 4 ) ) ;
97931: LD_VAR 0 1
97935: PPUSH
97936: LD_INT 1
97938: PPUSH
97939: LD_INT 4
97941: PPUSH
97942: CALL_OW 12
97946: PPUSH
97947: CALL_OW 336
97951: GO 97898
97953: POP
97954: POP
// end ;
97955: PPOPN 1
97957: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
97958: LD_EXP 109
97962: PUSH
97963: LD_EXP 121
97967: AND
97968: IFFALSE 98047
97970: GO 97972
97972: DISABLE
97973: LD_INT 0
97975: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97976: LD_ADDR_VAR 0 1
97980: PUSH
97981: LD_INT 22
97983: PUSH
97984: LD_OWVAR 2
97988: PUSH
97989: EMPTY
97990: LIST
97991: LIST
97992: PUSH
97993: LD_INT 21
97995: PUSH
97996: LD_INT 3
97998: PUSH
97999: EMPTY
98000: LIST
98001: LIST
98002: PUSH
98003: EMPTY
98004: LIST
98005: LIST
98006: PPUSH
98007: CALL_OW 69
98011: ST_TO_ADDR
// if not tmp then
98012: LD_VAR 0 1
98016: NOT
98017: IFFALSE 98021
// exit ;
98019: GO 98047
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
98021: LD_VAR 0 1
98025: PUSH
98026: LD_INT 1
98028: PPUSH
98029: LD_VAR 0 1
98033: PPUSH
98034: CALL_OW 12
98038: ARRAY
98039: PPUSH
98040: LD_INT 100
98042: PPUSH
98043: CALL_OW 234
// end ;
98047: PPOPN 1
98049: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
98050: LD_EXP 109
98054: PUSH
98055: LD_EXP 123
98059: AND
98060: IFFALSE 98158
98062: GO 98064
98064: DISABLE
98065: LD_INT 0
98067: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98068: LD_ADDR_VAR 0 1
98072: PUSH
98073: LD_INT 22
98075: PUSH
98076: LD_OWVAR 2
98080: PUSH
98081: EMPTY
98082: LIST
98083: LIST
98084: PUSH
98085: LD_INT 21
98087: PUSH
98088: LD_INT 1
98090: PUSH
98091: EMPTY
98092: LIST
98093: LIST
98094: PUSH
98095: EMPTY
98096: LIST
98097: LIST
98098: PPUSH
98099: CALL_OW 69
98103: ST_TO_ADDR
// if not tmp then
98104: LD_VAR 0 1
98108: NOT
98109: IFFALSE 98113
// exit ;
98111: GO 98158
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
98113: LD_VAR 0 1
98117: PUSH
98118: LD_INT 1
98120: PPUSH
98121: LD_VAR 0 1
98125: PPUSH
98126: CALL_OW 12
98130: ARRAY
98131: PPUSH
98132: LD_INT 1
98134: PPUSH
98135: LD_INT 4
98137: PPUSH
98138: CALL_OW 12
98142: PPUSH
98143: LD_INT 3000
98145: PPUSH
98146: LD_INT 9000
98148: PPUSH
98149: CALL_OW 12
98153: PPUSH
98154: CALL_OW 492
// end ;
98158: PPOPN 1
98160: END
// every 0 0$1 trigger StreamModeActive and sDepot do
98161: LD_EXP 109
98165: PUSH
98166: LD_EXP 124
98170: AND
98171: IFFALSE 98191
98173: GO 98175
98175: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
98176: LD_INT 1
98178: PPUSH
98179: LD_OWVAR 2
98183: PPUSH
98184: LD_INT 0
98186: PPUSH
98187: CALL_OW 324
98191: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
98192: LD_EXP 109
98196: PUSH
98197: LD_EXP 125
98201: AND
98202: IFFALSE 98285
98204: GO 98206
98206: DISABLE
98207: LD_INT 0
98209: PPUSH
98210: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98211: LD_ADDR_VAR 0 2
98215: PUSH
98216: LD_INT 22
98218: PUSH
98219: LD_OWVAR 2
98223: PUSH
98224: EMPTY
98225: LIST
98226: LIST
98227: PUSH
98228: LD_INT 21
98230: PUSH
98231: LD_INT 3
98233: PUSH
98234: EMPTY
98235: LIST
98236: LIST
98237: PUSH
98238: EMPTY
98239: LIST
98240: LIST
98241: PPUSH
98242: CALL_OW 69
98246: ST_TO_ADDR
// if not tmp then
98247: LD_VAR 0 2
98251: NOT
98252: IFFALSE 98256
// exit ;
98254: GO 98285
// for i in tmp do
98256: LD_ADDR_VAR 0 1
98260: PUSH
98261: LD_VAR 0 2
98265: PUSH
98266: FOR_IN
98267: IFFALSE 98283
// SetBLevel ( i , 10 ) ;
98269: LD_VAR 0 1
98273: PPUSH
98274: LD_INT 10
98276: PPUSH
98277: CALL_OW 241
98281: GO 98266
98283: POP
98284: POP
// end ;
98285: PPOPN 2
98287: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
98288: LD_EXP 109
98292: PUSH
98293: LD_EXP 126
98297: AND
98298: IFFALSE 98409
98300: GO 98302
98302: DISABLE
98303: LD_INT 0
98305: PPUSH
98306: PPUSH
98307: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98308: LD_ADDR_VAR 0 3
98312: PUSH
98313: LD_INT 22
98315: PUSH
98316: LD_OWVAR 2
98320: PUSH
98321: EMPTY
98322: LIST
98323: LIST
98324: PUSH
98325: LD_INT 25
98327: PUSH
98328: LD_INT 1
98330: PUSH
98331: EMPTY
98332: LIST
98333: LIST
98334: PUSH
98335: EMPTY
98336: LIST
98337: LIST
98338: PPUSH
98339: CALL_OW 69
98343: ST_TO_ADDR
// if not tmp then
98344: LD_VAR 0 3
98348: NOT
98349: IFFALSE 98353
// exit ;
98351: GO 98409
// un := tmp [ rand ( 1 , tmp ) ] ;
98353: LD_ADDR_VAR 0 2
98357: PUSH
98358: LD_VAR 0 3
98362: PUSH
98363: LD_INT 1
98365: PPUSH
98366: LD_VAR 0 3
98370: PPUSH
98371: CALL_OW 12
98375: ARRAY
98376: ST_TO_ADDR
// if Crawls ( un ) then
98377: LD_VAR 0 2
98381: PPUSH
98382: CALL_OW 318
98386: IFFALSE 98397
// ComWalk ( un ) ;
98388: LD_VAR 0 2
98392: PPUSH
98393: CALL_OW 138
// SetClass ( un , class_sniper ) ;
98397: LD_VAR 0 2
98401: PPUSH
98402: LD_INT 5
98404: PPUSH
98405: CALL_OW 336
// end ;
98409: PPOPN 3
98411: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
98412: LD_EXP 109
98416: PUSH
98417: LD_EXP 127
98421: AND
98422: PUSH
98423: LD_OWVAR 67
98427: PUSH
98428: LD_INT 4
98430: LESS
98431: AND
98432: IFFALSE 98451
98434: GO 98436
98436: DISABLE
// begin Difficulty := Difficulty + 1 ;
98437: LD_ADDR_OWVAR 67
98441: PUSH
98442: LD_OWVAR 67
98446: PUSH
98447: LD_INT 1
98449: PLUS
98450: ST_TO_ADDR
// end ;
98451: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
98452: LD_EXP 109
98456: PUSH
98457: LD_EXP 128
98461: AND
98462: IFFALSE 98565
98464: GO 98466
98466: DISABLE
98467: LD_INT 0
98469: PPUSH
// begin for i := 1 to 5 do
98470: LD_ADDR_VAR 0 1
98474: PUSH
98475: DOUBLE
98476: LD_INT 1
98478: DEC
98479: ST_TO_ADDR
98480: LD_INT 5
98482: PUSH
98483: FOR_TO
98484: IFFALSE 98563
// begin uc_nation := nation_nature ;
98486: LD_ADDR_OWVAR 21
98490: PUSH
98491: LD_INT 0
98493: ST_TO_ADDR
// uc_side := 0 ;
98494: LD_ADDR_OWVAR 20
98498: PUSH
98499: LD_INT 0
98501: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98502: LD_ADDR_OWVAR 29
98506: PUSH
98507: LD_INT 12
98509: PUSH
98510: LD_INT 12
98512: PUSH
98513: EMPTY
98514: LIST
98515: LIST
98516: ST_TO_ADDR
// hc_agressivity := 20 ;
98517: LD_ADDR_OWVAR 35
98521: PUSH
98522: LD_INT 20
98524: ST_TO_ADDR
// hc_class := class_tiger ;
98525: LD_ADDR_OWVAR 28
98529: PUSH
98530: LD_INT 14
98532: ST_TO_ADDR
// hc_gallery :=  ;
98533: LD_ADDR_OWVAR 33
98537: PUSH
98538: LD_STRING 
98540: ST_TO_ADDR
// hc_name :=  ;
98541: LD_ADDR_OWVAR 26
98545: PUSH
98546: LD_STRING 
98548: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
98549: CALL_OW 44
98553: PPUSH
98554: LD_INT 0
98556: PPUSH
98557: CALL_OW 51
// end ;
98561: GO 98483
98563: POP
98564: POP
// end ;
98565: PPOPN 1
98567: END
// every 0 0$1 trigger StreamModeActive and sBomb do
98568: LD_EXP 109
98572: PUSH
98573: LD_EXP 129
98577: AND
98578: IFFALSE 98587
98580: GO 98582
98582: DISABLE
// StreamSibBomb ;
98583: CALL 98588 0 0
98587: END
// export function StreamSibBomb ; var i , x , y ; begin
98588: LD_INT 0
98590: PPUSH
98591: PPUSH
98592: PPUSH
98593: PPUSH
// result := false ;
98594: LD_ADDR_VAR 0 1
98598: PUSH
98599: LD_INT 0
98601: ST_TO_ADDR
// for i := 1 to 16 do
98602: LD_ADDR_VAR 0 2
98606: PUSH
98607: DOUBLE
98608: LD_INT 1
98610: DEC
98611: ST_TO_ADDR
98612: LD_INT 16
98614: PUSH
98615: FOR_TO
98616: IFFALSE 98815
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98618: LD_ADDR_VAR 0 3
98622: PUSH
98623: LD_INT 10
98625: PUSH
98626: LD_INT 20
98628: PUSH
98629: LD_INT 30
98631: PUSH
98632: LD_INT 40
98634: PUSH
98635: LD_INT 50
98637: PUSH
98638: LD_INT 60
98640: PUSH
98641: LD_INT 70
98643: PUSH
98644: LD_INT 80
98646: PUSH
98647: LD_INT 90
98649: PUSH
98650: LD_INT 100
98652: PUSH
98653: LD_INT 110
98655: PUSH
98656: LD_INT 120
98658: PUSH
98659: LD_INT 130
98661: PUSH
98662: LD_INT 140
98664: PUSH
98665: LD_INT 150
98667: PUSH
98668: EMPTY
98669: LIST
98670: LIST
98671: LIST
98672: LIST
98673: LIST
98674: LIST
98675: LIST
98676: LIST
98677: LIST
98678: LIST
98679: LIST
98680: LIST
98681: LIST
98682: LIST
98683: LIST
98684: PUSH
98685: LD_INT 1
98687: PPUSH
98688: LD_INT 15
98690: PPUSH
98691: CALL_OW 12
98695: ARRAY
98696: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98697: LD_ADDR_VAR 0 4
98701: PUSH
98702: LD_INT 10
98704: PUSH
98705: LD_INT 20
98707: PUSH
98708: LD_INT 30
98710: PUSH
98711: LD_INT 40
98713: PUSH
98714: LD_INT 50
98716: PUSH
98717: LD_INT 60
98719: PUSH
98720: LD_INT 70
98722: PUSH
98723: LD_INT 80
98725: PUSH
98726: LD_INT 90
98728: PUSH
98729: LD_INT 100
98731: PUSH
98732: LD_INT 110
98734: PUSH
98735: LD_INT 120
98737: PUSH
98738: LD_INT 130
98740: PUSH
98741: LD_INT 140
98743: PUSH
98744: LD_INT 150
98746: PUSH
98747: EMPTY
98748: LIST
98749: LIST
98750: LIST
98751: LIST
98752: LIST
98753: LIST
98754: LIST
98755: LIST
98756: LIST
98757: LIST
98758: LIST
98759: LIST
98760: LIST
98761: LIST
98762: LIST
98763: PUSH
98764: LD_INT 1
98766: PPUSH
98767: LD_INT 15
98769: PPUSH
98770: CALL_OW 12
98774: ARRAY
98775: ST_TO_ADDR
// if ValidHex ( x , y ) then
98776: LD_VAR 0 3
98780: PPUSH
98781: LD_VAR 0 4
98785: PPUSH
98786: CALL_OW 488
98790: IFFALSE 98813
// begin result := [ x , y ] ;
98792: LD_ADDR_VAR 0 1
98796: PUSH
98797: LD_VAR 0 3
98801: PUSH
98802: LD_VAR 0 4
98806: PUSH
98807: EMPTY
98808: LIST
98809: LIST
98810: ST_TO_ADDR
// break ;
98811: GO 98815
// end ; end ;
98813: GO 98615
98815: POP
98816: POP
// if result then
98817: LD_VAR 0 1
98821: IFFALSE 98881
// begin ToLua ( playSibBomb() ) ;
98823: LD_STRING playSibBomb()
98825: PPUSH
98826: CALL_OW 559
// wait ( 0 0$14 ) ;
98830: LD_INT 490
98832: PPUSH
98833: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
98837: LD_VAR 0 1
98841: PUSH
98842: LD_INT 1
98844: ARRAY
98845: PPUSH
98846: LD_VAR 0 1
98850: PUSH
98851: LD_INT 2
98853: ARRAY
98854: PPUSH
98855: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
98859: LD_VAR 0 1
98863: PUSH
98864: LD_INT 1
98866: ARRAY
98867: PPUSH
98868: LD_VAR 0 1
98872: PUSH
98873: LD_INT 2
98875: ARRAY
98876: PPUSH
98877: CALL_OW 429
// end ; end ;
98881: LD_VAR 0 1
98885: RET
// every 0 0$1 trigger StreamModeActive and sReset do
98886: LD_EXP 109
98890: PUSH
98891: LD_EXP 131
98895: AND
98896: IFFALSE 98908
98898: GO 98900
98900: DISABLE
// YouLost (  ) ;
98901: LD_STRING 
98903: PPUSH
98904: CALL_OW 104
98908: END
// every 0 0$1 trigger StreamModeActive and sFog do
98909: LD_EXP 109
98913: PUSH
98914: LD_EXP 130
98918: AND
98919: IFFALSE 98933
98921: GO 98923
98923: DISABLE
// FogOff ( your_side ) ;
98924: LD_OWVAR 2
98928: PPUSH
98929: CALL_OW 344
98933: END
// every 0 0$1 trigger StreamModeActive and sSun do
98934: LD_EXP 109
98938: PUSH
98939: LD_EXP 132
98943: AND
98944: IFFALSE 98972
98946: GO 98948
98948: DISABLE
// begin solar_recharge_percent := 0 ;
98949: LD_ADDR_OWVAR 79
98953: PUSH
98954: LD_INT 0
98956: ST_TO_ADDR
// wait ( 5 5$00 ) ;
98957: LD_INT 10500
98959: PPUSH
98960: CALL_OW 67
// solar_recharge_percent := 100 ;
98964: LD_ADDR_OWVAR 79
98968: PUSH
98969: LD_INT 100
98971: ST_TO_ADDR
// end ;
98972: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
98973: LD_EXP 109
98977: PUSH
98978: LD_EXP 133
98982: AND
98983: IFFALSE 99222
98985: GO 98987
98987: DISABLE
98988: LD_INT 0
98990: PPUSH
98991: PPUSH
98992: PPUSH
// begin tmp := [ ] ;
98993: LD_ADDR_VAR 0 3
98997: PUSH
98998: EMPTY
98999: ST_TO_ADDR
// for i := 1 to 6 do
99000: LD_ADDR_VAR 0 1
99004: PUSH
99005: DOUBLE
99006: LD_INT 1
99008: DEC
99009: ST_TO_ADDR
99010: LD_INT 6
99012: PUSH
99013: FOR_TO
99014: IFFALSE 99119
// begin uc_nation := nation_nature ;
99016: LD_ADDR_OWVAR 21
99020: PUSH
99021: LD_INT 0
99023: ST_TO_ADDR
// uc_side := 0 ;
99024: LD_ADDR_OWVAR 20
99028: PUSH
99029: LD_INT 0
99031: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99032: LD_ADDR_OWVAR 29
99036: PUSH
99037: LD_INT 12
99039: PUSH
99040: LD_INT 12
99042: PUSH
99043: EMPTY
99044: LIST
99045: LIST
99046: ST_TO_ADDR
// hc_agressivity := 20 ;
99047: LD_ADDR_OWVAR 35
99051: PUSH
99052: LD_INT 20
99054: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
99055: LD_ADDR_OWVAR 28
99059: PUSH
99060: LD_INT 17
99062: ST_TO_ADDR
// hc_gallery :=  ;
99063: LD_ADDR_OWVAR 33
99067: PUSH
99068: LD_STRING 
99070: ST_TO_ADDR
// hc_name :=  ;
99071: LD_ADDR_OWVAR 26
99075: PUSH
99076: LD_STRING 
99078: ST_TO_ADDR
// un := CreateHuman ;
99079: LD_ADDR_VAR 0 2
99083: PUSH
99084: CALL_OW 44
99088: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
99089: LD_VAR 0 2
99093: PPUSH
99094: LD_INT 1
99096: PPUSH
99097: CALL_OW 51
// tmp := tmp ^ un ;
99101: LD_ADDR_VAR 0 3
99105: PUSH
99106: LD_VAR 0 3
99110: PUSH
99111: LD_VAR 0 2
99115: ADD
99116: ST_TO_ADDR
// end ;
99117: GO 99013
99119: POP
99120: POP
// repeat wait ( 0 0$1 ) ;
99121: LD_INT 35
99123: PPUSH
99124: CALL_OW 67
// for un in tmp do
99128: LD_ADDR_VAR 0 2
99132: PUSH
99133: LD_VAR 0 3
99137: PUSH
99138: FOR_IN
99139: IFFALSE 99213
// begin if IsDead ( un ) then
99141: LD_VAR 0 2
99145: PPUSH
99146: CALL_OW 301
99150: IFFALSE 99170
// begin tmp := tmp diff un ;
99152: LD_ADDR_VAR 0 3
99156: PUSH
99157: LD_VAR 0 3
99161: PUSH
99162: LD_VAR 0 2
99166: DIFF
99167: ST_TO_ADDR
// continue ;
99168: GO 99138
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
99170: LD_VAR 0 2
99174: PPUSH
99175: LD_INT 3
99177: PUSH
99178: LD_INT 22
99180: PUSH
99181: LD_INT 0
99183: PUSH
99184: EMPTY
99185: LIST
99186: LIST
99187: PUSH
99188: EMPTY
99189: LIST
99190: LIST
99191: PPUSH
99192: CALL_OW 69
99196: PPUSH
99197: LD_VAR 0 2
99201: PPUSH
99202: CALL_OW 74
99206: PPUSH
99207: CALL_OW 115
// end ;
99211: GO 99138
99213: POP
99214: POP
// until not tmp ;
99215: LD_VAR 0 3
99219: NOT
99220: IFFALSE 99121
// end ;
99222: PPOPN 3
99224: END
// every 0 0$1 trigger StreamModeActive and sTroll do
99225: LD_EXP 109
99229: PUSH
99230: LD_EXP 134
99234: AND
99235: IFFALSE 99289
99237: GO 99239
99239: DISABLE
// begin ToLua ( displayTroll(); ) ;
99240: LD_STRING displayTroll();
99242: PPUSH
99243: CALL_OW 559
// wait ( 3 3$00 ) ;
99247: LD_INT 6300
99249: PPUSH
99250: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99254: LD_STRING hideTroll();
99256: PPUSH
99257: CALL_OW 559
// wait ( 1 1$00 ) ;
99261: LD_INT 2100
99263: PPUSH
99264: CALL_OW 67
// ToLua ( displayTroll(); ) ;
99268: LD_STRING displayTroll();
99270: PPUSH
99271: CALL_OW 559
// wait ( 1 1$00 ) ;
99275: LD_INT 2100
99277: PPUSH
99278: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99282: LD_STRING hideTroll();
99284: PPUSH
99285: CALL_OW 559
// end ;
99289: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
99290: LD_EXP 109
99294: PUSH
99295: LD_EXP 135
99299: AND
99300: IFFALSE 99363
99302: GO 99304
99304: DISABLE
99305: LD_INT 0
99307: PPUSH
// begin p := 0 ;
99308: LD_ADDR_VAR 0 1
99312: PUSH
99313: LD_INT 0
99315: ST_TO_ADDR
// repeat game_speed := 1 ;
99316: LD_ADDR_OWVAR 65
99320: PUSH
99321: LD_INT 1
99323: ST_TO_ADDR
// wait ( 0 0$1 ) ;
99324: LD_INT 35
99326: PPUSH
99327: CALL_OW 67
// p := p + 1 ;
99331: LD_ADDR_VAR 0 1
99335: PUSH
99336: LD_VAR 0 1
99340: PUSH
99341: LD_INT 1
99343: PLUS
99344: ST_TO_ADDR
// until p >= 60 ;
99345: LD_VAR 0 1
99349: PUSH
99350: LD_INT 60
99352: GREATEREQUAL
99353: IFFALSE 99316
// game_speed := 4 ;
99355: LD_ADDR_OWVAR 65
99359: PUSH
99360: LD_INT 4
99362: ST_TO_ADDR
// end ;
99363: PPOPN 1
99365: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
99366: LD_EXP 109
99370: PUSH
99371: LD_EXP 136
99375: AND
99376: IFFALSE 99522
99378: GO 99380
99380: DISABLE
99381: LD_INT 0
99383: PPUSH
99384: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99385: LD_ADDR_VAR 0 1
99389: PUSH
99390: LD_INT 22
99392: PUSH
99393: LD_OWVAR 2
99397: PUSH
99398: EMPTY
99399: LIST
99400: LIST
99401: PUSH
99402: LD_INT 2
99404: PUSH
99405: LD_INT 30
99407: PUSH
99408: LD_INT 0
99410: PUSH
99411: EMPTY
99412: LIST
99413: LIST
99414: PUSH
99415: LD_INT 30
99417: PUSH
99418: LD_INT 1
99420: PUSH
99421: EMPTY
99422: LIST
99423: LIST
99424: PUSH
99425: EMPTY
99426: LIST
99427: LIST
99428: LIST
99429: PUSH
99430: EMPTY
99431: LIST
99432: LIST
99433: PPUSH
99434: CALL_OW 69
99438: ST_TO_ADDR
// if not depot then
99439: LD_VAR 0 1
99443: NOT
99444: IFFALSE 99448
// exit ;
99446: GO 99522
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
99448: LD_ADDR_VAR 0 2
99452: PUSH
99453: LD_VAR 0 1
99457: PUSH
99458: LD_INT 1
99460: PPUSH
99461: LD_VAR 0 1
99465: PPUSH
99466: CALL_OW 12
99470: ARRAY
99471: PPUSH
99472: CALL_OW 274
99476: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
99477: LD_VAR 0 2
99481: PPUSH
99482: LD_INT 1
99484: PPUSH
99485: LD_INT 0
99487: PPUSH
99488: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
99492: LD_VAR 0 2
99496: PPUSH
99497: LD_INT 2
99499: PPUSH
99500: LD_INT 0
99502: PPUSH
99503: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
99507: LD_VAR 0 2
99511: PPUSH
99512: LD_INT 3
99514: PPUSH
99515: LD_INT 0
99517: PPUSH
99518: CALL_OW 277
// end ;
99522: PPOPN 2
99524: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
99525: LD_EXP 109
99529: PUSH
99530: LD_EXP 137
99534: AND
99535: IFFALSE 99632
99537: GO 99539
99539: DISABLE
99540: LD_INT 0
99542: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99543: LD_ADDR_VAR 0 1
99547: PUSH
99548: LD_INT 22
99550: PUSH
99551: LD_OWVAR 2
99555: PUSH
99556: EMPTY
99557: LIST
99558: LIST
99559: PUSH
99560: LD_INT 21
99562: PUSH
99563: LD_INT 1
99565: PUSH
99566: EMPTY
99567: LIST
99568: LIST
99569: PUSH
99570: LD_INT 3
99572: PUSH
99573: LD_INT 23
99575: PUSH
99576: LD_INT 0
99578: PUSH
99579: EMPTY
99580: LIST
99581: LIST
99582: PUSH
99583: EMPTY
99584: LIST
99585: LIST
99586: PUSH
99587: EMPTY
99588: LIST
99589: LIST
99590: LIST
99591: PPUSH
99592: CALL_OW 69
99596: ST_TO_ADDR
// if not tmp then
99597: LD_VAR 0 1
99601: NOT
99602: IFFALSE 99606
// exit ;
99604: GO 99632
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
99606: LD_VAR 0 1
99610: PUSH
99611: LD_INT 1
99613: PPUSH
99614: LD_VAR 0 1
99618: PPUSH
99619: CALL_OW 12
99623: ARRAY
99624: PPUSH
99625: LD_INT 200
99627: PPUSH
99628: CALL_OW 234
// end ;
99632: PPOPN 1
99634: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
99635: LD_EXP 109
99639: PUSH
99640: LD_EXP 138
99644: AND
99645: IFFALSE 99724
99647: GO 99649
99649: DISABLE
99650: LD_INT 0
99652: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
99653: LD_ADDR_VAR 0 1
99657: PUSH
99658: LD_INT 22
99660: PUSH
99661: LD_OWVAR 2
99665: PUSH
99666: EMPTY
99667: LIST
99668: LIST
99669: PUSH
99670: LD_INT 21
99672: PUSH
99673: LD_INT 2
99675: PUSH
99676: EMPTY
99677: LIST
99678: LIST
99679: PUSH
99680: EMPTY
99681: LIST
99682: LIST
99683: PPUSH
99684: CALL_OW 69
99688: ST_TO_ADDR
// if not tmp then
99689: LD_VAR 0 1
99693: NOT
99694: IFFALSE 99698
// exit ;
99696: GO 99724
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
99698: LD_VAR 0 1
99702: PUSH
99703: LD_INT 1
99705: PPUSH
99706: LD_VAR 0 1
99710: PPUSH
99711: CALL_OW 12
99715: ARRAY
99716: PPUSH
99717: LD_INT 60
99719: PPUSH
99720: CALL_OW 234
// end ;
99724: PPOPN 1
99726: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
99727: LD_EXP 109
99731: PUSH
99732: LD_EXP 139
99736: AND
99737: IFFALSE 99836
99739: GO 99741
99741: DISABLE
99742: LD_INT 0
99744: PPUSH
99745: PPUSH
// begin enable ;
99746: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
99747: LD_ADDR_VAR 0 1
99751: PUSH
99752: LD_INT 22
99754: PUSH
99755: LD_OWVAR 2
99759: PUSH
99760: EMPTY
99761: LIST
99762: LIST
99763: PUSH
99764: LD_INT 61
99766: PUSH
99767: EMPTY
99768: LIST
99769: PUSH
99770: LD_INT 33
99772: PUSH
99773: LD_INT 2
99775: PUSH
99776: EMPTY
99777: LIST
99778: LIST
99779: PUSH
99780: EMPTY
99781: LIST
99782: LIST
99783: LIST
99784: PPUSH
99785: CALL_OW 69
99789: ST_TO_ADDR
// if not tmp then
99790: LD_VAR 0 1
99794: NOT
99795: IFFALSE 99799
// exit ;
99797: GO 99836
// for i in tmp do
99799: LD_ADDR_VAR 0 2
99803: PUSH
99804: LD_VAR 0 1
99808: PUSH
99809: FOR_IN
99810: IFFALSE 99834
// if IsControledBy ( i ) then
99812: LD_VAR 0 2
99816: PPUSH
99817: CALL_OW 312
99821: IFFALSE 99832
// ComUnlink ( i ) ;
99823: LD_VAR 0 2
99827: PPUSH
99828: CALL_OW 136
99832: GO 99809
99834: POP
99835: POP
// end ;
99836: PPOPN 2
99838: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
99839: LD_EXP 109
99843: PUSH
99844: LD_EXP 140
99848: AND
99849: IFFALSE 99989
99851: GO 99853
99853: DISABLE
99854: LD_INT 0
99856: PPUSH
99857: PPUSH
// begin ToLua ( displayPowell(); ) ;
99858: LD_STRING displayPowell();
99860: PPUSH
99861: CALL_OW 559
// uc_side := 0 ;
99865: LD_ADDR_OWVAR 20
99869: PUSH
99870: LD_INT 0
99872: ST_TO_ADDR
// uc_nation := 2 ;
99873: LD_ADDR_OWVAR 21
99877: PUSH
99878: LD_INT 2
99880: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
99881: LD_ADDR_OWVAR 37
99885: PUSH
99886: LD_INT 14
99888: ST_TO_ADDR
// vc_engine := engine_siberite ;
99889: LD_ADDR_OWVAR 39
99893: PUSH
99894: LD_INT 3
99896: ST_TO_ADDR
// vc_control := control_apeman ;
99897: LD_ADDR_OWVAR 38
99901: PUSH
99902: LD_INT 5
99904: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99905: LD_ADDR_OWVAR 40
99909: PUSH
99910: LD_INT 29
99912: ST_TO_ADDR
// un := CreateVehicle ;
99913: LD_ADDR_VAR 0 2
99917: PUSH
99918: CALL_OW 45
99922: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99923: LD_VAR 0 2
99927: PPUSH
99928: LD_INT 1
99930: PPUSH
99931: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99935: LD_INT 35
99937: PPUSH
99938: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99942: LD_VAR 0 2
99946: PPUSH
99947: LD_INT 22
99949: PUSH
99950: LD_OWVAR 2
99954: PUSH
99955: EMPTY
99956: LIST
99957: LIST
99958: PPUSH
99959: CALL_OW 69
99963: PPUSH
99964: LD_VAR 0 2
99968: PPUSH
99969: CALL_OW 74
99973: PPUSH
99974: CALL_OW 115
// until IsDead ( un ) ;
99978: LD_VAR 0 2
99982: PPUSH
99983: CALL_OW 301
99987: IFFALSE 99935
// end ;
99989: PPOPN 2
99991: END
// every 0 0$1 trigger StreamModeActive and sStu do
99992: LD_EXP 109
99996: PUSH
99997: LD_EXP 148
100001: AND
100002: IFFALSE 100018
100004: GO 100006
100006: DISABLE
// begin ToLua ( displayStucuk(); ) ;
100007: LD_STRING displayStucuk();
100009: PPUSH
100010: CALL_OW 559
// ResetFog ;
100014: CALL_OW 335
// end ;
100018: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
100019: LD_EXP 109
100023: PUSH
100024: LD_EXP 141
100028: AND
100029: IFFALSE 100170
100031: GO 100033
100033: DISABLE
100034: LD_INT 0
100036: PPUSH
100037: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100038: LD_ADDR_VAR 0 2
100042: PUSH
100043: LD_INT 22
100045: PUSH
100046: LD_OWVAR 2
100050: PUSH
100051: EMPTY
100052: LIST
100053: LIST
100054: PUSH
100055: LD_INT 21
100057: PUSH
100058: LD_INT 1
100060: PUSH
100061: EMPTY
100062: LIST
100063: LIST
100064: PUSH
100065: EMPTY
100066: LIST
100067: LIST
100068: PPUSH
100069: CALL_OW 69
100073: ST_TO_ADDR
// if not tmp then
100074: LD_VAR 0 2
100078: NOT
100079: IFFALSE 100083
// exit ;
100081: GO 100170
// un := tmp [ rand ( 1 , tmp ) ] ;
100083: LD_ADDR_VAR 0 1
100087: PUSH
100088: LD_VAR 0 2
100092: PUSH
100093: LD_INT 1
100095: PPUSH
100096: LD_VAR 0 2
100100: PPUSH
100101: CALL_OW 12
100105: ARRAY
100106: ST_TO_ADDR
// SetSide ( un , 0 ) ;
100107: LD_VAR 0 1
100111: PPUSH
100112: LD_INT 0
100114: PPUSH
100115: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
100119: LD_VAR 0 1
100123: PPUSH
100124: LD_OWVAR 3
100128: PUSH
100129: LD_VAR 0 1
100133: DIFF
100134: PPUSH
100135: LD_VAR 0 1
100139: PPUSH
100140: CALL_OW 74
100144: PPUSH
100145: CALL_OW 115
// wait ( 0 0$20 ) ;
100149: LD_INT 700
100151: PPUSH
100152: CALL_OW 67
// SetSide ( un , your_side ) ;
100156: LD_VAR 0 1
100160: PPUSH
100161: LD_OWVAR 2
100165: PPUSH
100166: CALL_OW 235
// end ;
100170: PPOPN 2
100172: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
100173: LD_EXP 109
100177: PUSH
100178: LD_EXP 142
100182: AND
100183: IFFALSE 100289
100185: GO 100187
100187: DISABLE
100188: LD_INT 0
100190: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100191: LD_ADDR_VAR 0 1
100195: PUSH
100196: LD_INT 22
100198: PUSH
100199: LD_OWVAR 2
100203: PUSH
100204: EMPTY
100205: LIST
100206: LIST
100207: PUSH
100208: LD_INT 2
100210: PUSH
100211: LD_INT 30
100213: PUSH
100214: LD_INT 0
100216: PUSH
100217: EMPTY
100218: LIST
100219: LIST
100220: PUSH
100221: LD_INT 30
100223: PUSH
100224: LD_INT 1
100226: PUSH
100227: EMPTY
100228: LIST
100229: LIST
100230: PUSH
100231: EMPTY
100232: LIST
100233: LIST
100234: LIST
100235: PUSH
100236: EMPTY
100237: LIST
100238: LIST
100239: PPUSH
100240: CALL_OW 69
100244: ST_TO_ADDR
// if not depot then
100245: LD_VAR 0 1
100249: NOT
100250: IFFALSE 100254
// exit ;
100252: GO 100289
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
100254: LD_VAR 0 1
100258: PUSH
100259: LD_INT 1
100261: ARRAY
100262: PPUSH
100263: CALL_OW 250
100267: PPUSH
100268: LD_VAR 0 1
100272: PUSH
100273: LD_INT 1
100275: ARRAY
100276: PPUSH
100277: CALL_OW 251
100281: PPUSH
100282: LD_INT 70
100284: PPUSH
100285: CALL_OW 495
// end ;
100289: PPOPN 1
100291: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
100292: LD_EXP 109
100296: PUSH
100297: LD_EXP 143
100301: AND
100302: IFFALSE 100513
100304: GO 100306
100306: DISABLE
100307: LD_INT 0
100309: PPUSH
100310: PPUSH
100311: PPUSH
100312: PPUSH
100313: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100314: LD_ADDR_VAR 0 5
100318: PUSH
100319: LD_INT 22
100321: PUSH
100322: LD_OWVAR 2
100326: PUSH
100327: EMPTY
100328: LIST
100329: LIST
100330: PUSH
100331: LD_INT 21
100333: PUSH
100334: LD_INT 1
100336: PUSH
100337: EMPTY
100338: LIST
100339: LIST
100340: PUSH
100341: EMPTY
100342: LIST
100343: LIST
100344: PPUSH
100345: CALL_OW 69
100349: ST_TO_ADDR
// if not tmp then
100350: LD_VAR 0 5
100354: NOT
100355: IFFALSE 100359
// exit ;
100357: GO 100513
// for i in tmp do
100359: LD_ADDR_VAR 0 1
100363: PUSH
100364: LD_VAR 0 5
100368: PUSH
100369: FOR_IN
100370: IFFALSE 100511
// begin d := rand ( 0 , 5 ) ;
100372: LD_ADDR_VAR 0 4
100376: PUSH
100377: LD_INT 0
100379: PPUSH
100380: LD_INT 5
100382: PPUSH
100383: CALL_OW 12
100387: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
100388: LD_ADDR_VAR 0 2
100392: PUSH
100393: LD_VAR 0 1
100397: PPUSH
100398: CALL_OW 250
100402: PPUSH
100403: LD_VAR 0 4
100407: PPUSH
100408: LD_INT 3
100410: PPUSH
100411: LD_INT 12
100413: PPUSH
100414: CALL_OW 12
100418: PPUSH
100419: CALL_OW 272
100423: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
100424: LD_ADDR_VAR 0 3
100428: PUSH
100429: LD_VAR 0 1
100433: PPUSH
100434: CALL_OW 251
100438: PPUSH
100439: LD_VAR 0 4
100443: PPUSH
100444: LD_INT 3
100446: PPUSH
100447: LD_INT 12
100449: PPUSH
100450: CALL_OW 12
100454: PPUSH
100455: CALL_OW 273
100459: ST_TO_ADDR
// if ValidHex ( x , y ) then
100460: LD_VAR 0 2
100464: PPUSH
100465: LD_VAR 0 3
100469: PPUSH
100470: CALL_OW 488
100474: IFFALSE 100509
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
100476: LD_VAR 0 1
100480: PPUSH
100481: LD_VAR 0 2
100485: PPUSH
100486: LD_VAR 0 3
100490: PPUSH
100491: LD_INT 3
100493: PPUSH
100494: LD_INT 6
100496: PPUSH
100497: CALL_OW 12
100501: PPUSH
100502: LD_INT 1
100504: PPUSH
100505: CALL_OW 483
// end ;
100509: GO 100369
100511: POP
100512: POP
// end ;
100513: PPOPN 5
100515: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
100516: LD_EXP 109
100520: PUSH
100521: LD_EXP 144
100525: AND
100526: IFFALSE 100620
100528: GO 100530
100530: DISABLE
100531: LD_INT 0
100533: PPUSH
100534: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
100535: LD_ADDR_VAR 0 2
100539: PUSH
100540: LD_INT 22
100542: PUSH
100543: LD_OWVAR 2
100547: PUSH
100548: EMPTY
100549: LIST
100550: LIST
100551: PUSH
100552: LD_INT 32
100554: PUSH
100555: LD_INT 1
100557: PUSH
100558: EMPTY
100559: LIST
100560: LIST
100561: PUSH
100562: LD_INT 21
100564: PUSH
100565: LD_INT 2
100567: PUSH
100568: EMPTY
100569: LIST
100570: LIST
100571: PUSH
100572: EMPTY
100573: LIST
100574: LIST
100575: LIST
100576: PPUSH
100577: CALL_OW 69
100581: ST_TO_ADDR
// if not tmp then
100582: LD_VAR 0 2
100586: NOT
100587: IFFALSE 100591
// exit ;
100589: GO 100620
// for i in tmp do
100591: LD_ADDR_VAR 0 1
100595: PUSH
100596: LD_VAR 0 2
100600: PUSH
100601: FOR_IN
100602: IFFALSE 100618
// SetFuel ( i , 0 ) ;
100604: LD_VAR 0 1
100608: PPUSH
100609: LD_INT 0
100611: PPUSH
100612: CALL_OW 240
100616: GO 100601
100618: POP
100619: POP
// end ;
100620: PPOPN 2
100622: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
100623: LD_EXP 109
100627: PUSH
100628: LD_EXP 145
100632: AND
100633: IFFALSE 100699
100635: GO 100637
100637: DISABLE
100638: LD_INT 0
100640: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100641: LD_ADDR_VAR 0 1
100645: PUSH
100646: LD_INT 22
100648: PUSH
100649: LD_OWVAR 2
100653: PUSH
100654: EMPTY
100655: LIST
100656: LIST
100657: PUSH
100658: LD_INT 30
100660: PUSH
100661: LD_INT 29
100663: PUSH
100664: EMPTY
100665: LIST
100666: LIST
100667: PUSH
100668: EMPTY
100669: LIST
100670: LIST
100671: PPUSH
100672: CALL_OW 69
100676: ST_TO_ADDR
// if not tmp then
100677: LD_VAR 0 1
100681: NOT
100682: IFFALSE 100686
// exit ;
100684: GO 100699
// DestroyUnit ( tmp [ 1 ] ) ;
100686: LD_VAR 0 1
100690: PUSH
100691: LD_INT 1
100693: ARRAY
100694: PPUSH
100695: CALL_OW 65
// end ;
100699: PPOPN 1
100701: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
100702: LD_EXP 109
100706: PUSH
100707: LD_EXP 147
100711: AND
100712: IFFALSE 100841
100714: GO 100716
100716: DISABLE
100717: LD_INT 0
100719: PPUSH
// begin uc_side := 0 ;
100720: LD_ADDR_OWVAR 20
100724: PUSH
100725: LD_INT 0
100727: ST_TO_ADDR
// uc_nation := nation_arabian ;
100728: LD_ADDR_OWVAR 21
100732: PUSH
100733: LD_INT 2
100735: ST_TO_ADDR
// hc_gallery :=  ;
100736: LD_ADDR_OWVAR 33
100740: PUSH
100741: LD_STRING 
100743: ST_TO_ADDR
// hc_name :=  ;
100744: LD_ADDR_OWVAR 26
100748: PUSH
100749: LD_STRING 
100751: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
100752: LD_INT 1
100754: PPUSH
100755: LD_INT 11
100757: PPUSH
100758: LD_INT 10
100760: PPUSH
100761: CALL_OW 380
// un := CreateHuman ;
100765: LD_ADDR_VAR 0 1
100769: PUSH
100770: CALL_OW 44
100774: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100775: LD_VAR 0 1
100779: PPUSH
100780: LD_INT 1
100782: PPUSH
100783: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100787: LD_INT 35
100789: PPUSH
100790: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100794: LD_VAR 0 1
100798: PPUSH
100799: LD_INT 22
100801: PUSH
100802: LD_OWVAR 2
100806: PUSH
100807: EMPTY
100808: LIST
100809: LIST
100810: PPUSH
100811: CALL_OW 69
100815: PPUSH
100816: LD_VAR 0 1
100820: PPUSH
100821: CALL_OW 74
100825: PPUSH
100826: CALL_OW 115
// until IsDead ( un ) ;
100830: LD_VAR 0 1
100834: PPUSH
100835: CALL_OW 301
100839: IFFALSE 100787
// end ;
100841: PPOPN 1
100843: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
100844: LD_EXP 109
100848: PUSH
100849: LD_EXP 149
100853: AND
100854: IFFALSE 100866
100856: GO 100858
100858: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
100859: LD_STRING earthquake(getX(game), 0, 32)
100861: PPUSH
100862: CALL_OW 559
100866: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
100867: LD_EXP 109
100871: PUSH
100872: LD_EXP 150
100876: AND
100877: IFFALSE 100968
100879: GO 100881
100881: DISABLE
100882: LD_INT 0
100884: PPUSH
// begin enable ;
100885: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
100886: LD_ADDR_VAR 0 1
100890: PUSH
100891: LD_INT 22
100893: PUSH
100894: LD_OWVAR 2
100898: PUSH
100899: EMPTY
100900: LIST
100901: LIST
100902: PUSH
100903: LD_INT 21
100905: PUSH
100906: LD_INT 2
100908: PUSH
100909: EMPTY
100910: LIST
100911: LIST
100912: PUSH
100913: LD_INT 33
100915: PUSH
100916: LD_INT 3
100918: PUSH
100919: EMPTY
100920: LIST
100921: LIST
100922: PUSH
100923: EMPTY
100924: LIST
100925: LIST
100926: LIST
100927: PPUSH
100928: CALL_OW 69
100932: ST_TO_ADDR
// if not tmp then
100933: LD_VAR 0 1
100937: NOT
100938: IFFALSE 100942
// exit ;
100940: GO 100968
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100942: LD_VAR 0 1
100946: PUSH
100947: LD_INT 1
100949: PPUSH
100950: LD_VAR 0 1
100954: PPUSH
100955: CALL_OW 12
100959: ARRAY
100960: PPUSH
100961: LD_INT 1
100963: PPUSH
100964: CALL_OW 234
// end ;
100968: PPOPN 1
100970: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
100971: LD_EXP 109
100975: PUSH
100976: LD_EXP 151
100980: AND
100981: IFFALSE 101122
100983: GO 100985
100985: DISABLE
100986: LD_INT 0
100988: PPUSH
100989: PPUSH
100990: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100991: LD_ADDR_VAR 0 3
100995: PUSH
100996: LD_INT 22
100998: PUSH
100999: LD_OWVAR 2
101003: PUSH
101004: EMPTY
101005: LIST
101006: LIST
101007: PUSH
101008: LD_INT 25
101010: PUSH
101011: LD_INT 1
101013: PUSH
101014: EMPTY
101015: LIST
101016: LIST
101017: PUSH
101018: EMPTY
101019: LIST
101020: LIST
101021: PPUSH
101022: CALL_OW 69
101026: ST_TO_ADDR
// if not tmp then
101027: LD_VAR 0 3
101031: NOT
101032: IFFALSE 101036
// exit ;
101034: GO 101122
// un := tmp [ rand ( 1 , tmp ) ] ;
101036: LD_ADDR_VAR 0 2
101040: PUSH
101041: LD_VAR 0 3
101045: PUSH
101046: LD_INT 1
101048: PPUSH
101049: LD_VAR 0 3
101053: PPUSH
101054: CALL_OW 12
101058: ARRAY
101059: ST_TO_ADDR
// if Crawls ( un ) then
101060: LD_VAR 0 2
101064: PPUSH
101065: CALL_OW 318
101069: IFFALSE 101080
// ComWalk ( un ) ;
101071: LD_VAR 0 2
101075: PPUSH
101076: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
101080: LD_VAR 0 2
101084: PPUSH
101085: LD_INT 9
101087: PPUSH
101088: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
101092: LD_INT 28
101094: PPUSH
101095: LD_OWVAR 2
101099: PPUSH
101100: LD_INT 2
101102: PPUSH
101103: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
101107: LD_INT 29
101109: PPUSH
101110: LD_OWVAR 2
101114: PPUSH
101115: LD_INT 2
101117: PPUSH
101118: CALL_OW 322
// end ;
101122: PPOPN 3
101124: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
101125: LD_EXP 109
101129: PUSH
101130: LD_EXP 152
101134: AND
101135: IFFALSE 101246
101137: GO 101139
101139: DISABLE
101140: LD_INT 0
101142: PPUSH
101143: PPUSH
101144: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101145: LD_ADDR_VAR 0 3
101149: PUSH
101150: LD_INT 22
101152: PUSH
101153: LD_OWVAR 2
101157: PUSH
101158: EMPTY
101159: LIST
101160: LIST
101161: PUSH
101162: LD_INT 25
101164: PUSH
101165: LD_INT 1
101167: PUSH
101168: EMPTY
101169: LIST
101170: LIST
101171: PUSH
101172: EMPTY
101173: LIST
101174: LIST
101175: PPUSH
101176: CALL_OW 69
101180: ST_TO_ADDR
// if not tmp then
101181: LD_VAR 0 3
101185: NOT
101186: IFFALSE 101190
// exit ;
101188: GO 101246
// un := tmp [ rand ( 1 , tmp ) ] ;
101190: LD_ADDR_VAR 0 2
101194: PUSH
101195: LD_VAR 0 3
101199: PUSH
101200: LD_INT 1
101202: PPUSH
101203: LD_VAR 0 3
101207: PPUSH
101208: CALL_OW 12
101212: ARRAY
101213: ST_TO_ADDR
// if Crawls ( un ) then
101214: LD_VAR 0 2
101218: PPUSH
101219: CALL_OW 318
101223: IFFALSE 101234
// ComWalk ( un ) ;
101225: LD_VAR 0 2
101229: PPUSH
101230: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101234: LD_VAR 0 2
101238: PPUSH
101239: LD_INT 8
101241: PPUSH
101242: CALL_OW 336
// end ;
101246: PPOPN 3
101248: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
101249: LD_EXP 109
101253: PUSH
101254: LD_EXP 153
101258: AND
101259: IFFALSE 101403
101261: GO 101263
101263: DISABLE
101264: LD_INT 0
101266: PPUSH
101267: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
101268: LD_ADDR_VAR 0 2
101272: PUSH
101273: LD_INT 22
101275: PUSH
101276: LD_OWVAR 2
101280: PUSH
101281: EMPTY
101282: LIST
101283: LIST
101284: PUSH
101285: LD_INT 21
101287: PUSH
101288: LD_INT 2
101290: PUSH
101291: EMPTY
101292: LIST
101293: LIST
101294: PUSH
101295: LD_INT 2
101297: PUSH
101298: LD_INT 34
101300: PUSH
101301: LD_INT 12
101303: PUSH
101304: EMPTY
101305: LIST
101306: LIST
101307: PUSH
101308: LD_INT 34
101310: PUSH
101311: LD_INT 51
101313: PUSH
101314: EMPTY
101315: LIST
101316: LIST
101317: PUSH
101318: LD_INT 34
101320: PUSH
101321: LD_INT 32
101323: PUSH
101324: EMPTY
101325: LIST
101326: LIST
101327: PUSH
101328: EMPTY
101329: LIST
101330: LIST
101331: LIST
101332: LIST
101333: PUSH
101334: EMPTY
101335: LIST
101336: LIST
101337: LIST
101338: PPUSH
101339: CALL_OW 69
101343: ST_TO_ADDR
// if not tmp then
101344: LD_VAR 0 2
101348: NOT
101349: IFFALSE 101353
// exit ;
101351: GO 101403
// for i in tmp do
101353: LD_ADDR_VAR 0 1
101357: PUSH
101358: LD_VAR 0 2
101362: PUSH
101363: FOR_IN
101364: IFFALSE 101401
// if GetCargo ( i , mat_artifact ) = 0 then
101366: LD_VAR 0 1
101370: PPUSH
101371: LD_INT 4
101373: PPUSH
101374: CALL_OW 289
101378: PUSH
101379: LD_INT 0
101381: EQUAL
101382: IFFALSE 101399
// SetCargo ( i , mat_siberit , 100 ) ;
101384: LD_VAR 0 1
101388: PPUSH
101389: LD_INT 3
101391: PPUSH
101392: LD_INT 100
101394: PPUSH
101395: CALL_OW 290
101399: GO 101363
101401: POP
101402: POP
// end ;
101403: PPOPN 2
101405: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
101406: LD_EXP 109
101410: PUSH
101411: LD_EXP 154
101415: AND
101416: IFFALSE 101599
101418: GO 101420
101420: DISABLE
101421: LD_INT 0
101423: PPUSH
101424: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101425: LD_ADDR_VAR 0 2
101429: PUSH
101430: LD_INT 22
101432: PUSH
101433: LD_OWVAR 2
101437: PUSH
101438: EMPTY
101439: LIST
101440: LIST
101441: PPUSH
101442: CALL_OW 69
101446: ST_TO_ADDR
// if not tmp then
101447: LD_VAR 0 2
101451: NOT
101452: IFFALSE 101456
// exit ;
101454: GO 101599
// for i := 1 to 2 do
101456: LD_ADDR_VAR 0 1
101460: PUSH
101461: DOUBLE
101462: LD_INT 1
101464: DEC
101465: ST_TO_ADDR
101466: LD_INT 2
101468: PUSH
101469: FOR_TO
101470: IFFALSE 101597
// begin uc_side := your_side ;
101472: LD_ADDR_OWVAR 20
101476: PUSH
101477: LD_OWVAR 2
101481: ST_TO_ADDR
// uc_nation := nation_american ;
101482: LD_ADDR_OWVAR 21
101486: PUSH
101487: LD_INT 1
101489: ST_TO_ADDR
// vc_chassis := us_morphling ;
101490: LD_ADDR_OWVAR 37
101494: PUSH
101495: LD_INT 5
101497: ST_TO_ADDR
// vc_engine := engine_siberite ;
101498: LD_ADDR_OWVAR 39
101502: PUSH
101503: LD_INT 3
101505: ST_TO_ADDR
// vc_control := control_computer ;
101506: LD_ADDR_OWVAR 38
101510: PUSH
101511: LD_INT 3
101513: ST_TO_ADDR
// vc_weapon := us_double_laser ;
101514: LD_ADDR_OWVAR 40
101518: PUSH
101519: LD_INT 10
101521: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
101522: LD_VAR 0 2
101526: PUSH
101527: LD_INT 1
101529: ARRAY
101530: PPUSH
101531: CALL_OW 310
101535: NOT
101536: IFFALSE 101583
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
101538: CALL_OW 45
101542: PPUSH
101543: LD_VAR 0 2
101547: PUSH
101548: LD_INT 1
101550: ARRAY
101551: PPUSH
101552: CALL_OW 250
101556: PPUSH
101557: LD_VAR 0 2
101561: PUSH
101562: LD_INT 1
101564: ARRAY
101565: PPUSH
101566: CALL_OW 251
101570: PPUSH
101571: LD_INT 12
101573: PPUSH
101574: LD_INT 1
101576: PPUSH
101577: CALL_OW 50
101581: GO 101595
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
101583: CALL_OW 45
101587: PPUSH
101588: LD_INT 1
101590: PPUSH
101591: CALL_OW 51
// end ;
101595: GO 101469
101597: POP
101598: POP
// end ;
101599: PPOPN 2
101601: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
101602: LD_EXP 109
101606: PUSH
101607: LD_EXP 155
101611: AND
101612: IFFALSE 101834
101614: GO 101616
101616: DISABLE
101617: LD_INT 0
101619: PPUSH
101620: PPUSH
101621: PPUSH
101622: PPUSH
101623: PPUSH
101624: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101625: LD_ADDR_VAR 0 6
101629: PUSH
101630: LD_INT 22
101632: PUSH
101633: LD_OWVAR 2
101637: PUSH
101638: EMPTY
101639: LIST
101640: LIST
101641: PUSH
101642: LD_INT 21
101644: PUSH
101645: LD_INT 1
101647: PUSH
101648: EMPTY
101649: LIST
101650: LIST
101651: PUSH
101652: LD_INT 3
101654: PUSH
101655: LD_INT 23
101657: PUSH
101658: LD_INT 0
101660: PUSH
101661: EMPTY
101662: LIST
101663: LIST
101664: PUSH
101665: EMPTY
101666: LIST
101667: LIST
101668: PUSH
101669: EMPTY
101670: LIST
101671: LIST
101672: LIST
101673: PPUSH
101674: CALL_OW 69
101678: ST_TO_ADDR
// if not tmp then
101679: LD_VAR 0 6
101683: NOT
101684: IFFALSE 101688
// exit ;
101686: GO 101834
// s1 := rand ( 1 , 4 ) ;
101688: LD_ADDR_VAR 0 2
101692: PUSH
101693: LD_INT 1
101695: PPUSH
101696: LD_INT 4
101698: PPUSH
101699: CALL_OW 12
101703: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
101704: LD_ADDR_VAR 0 4
101708: PUSH
101709: LD_VAR 0 6
101713: PUSH
101714: LD_INT 1
101716: ARRAY
101717: PPUSH
101718: LD_VAR 0 2
101722: PPUSH
101723: CALL_OW 259
101727: ST_TO_ADDR
// if s1 = 1 then
101728: LD_VAR 0 2
101732: PUSH
101733: LD_INT 1
101735: EQUAL
101736: IFFALSE 101756
// s2 := rand ( 2 , 4 ) else
101738: LD_ADDR_VAR 0 3
101742: PUSH
101743: LD_INT 2
101745: PPUSH
101746: LD_INT 4
101748: PPUSH
101749: CALL_OW 12
101753: ST_TO_ADDR
101754: GO 101764
// s2 := 1 ;
101756: LD_ADDR_VAR 0 3
101760: PUSH
101761: LD_INT 1
101763: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
101764: LD_ADDR_VAR 0 5
101768: PUSH
101769: LD_VAR 0 6
101773: PUSH
101774: LD_INT 1
101776: ARRAY
101777: PPUSH
101778: LD_VAR 0 3
101782: PPUSH
101783: CALL_OW 259
101787: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
101788: LD_VAR 0 6
101792: PUSH
101793: LD_INT 1
101795: ARRAY
101796: PPUSH
101797: LD_VAR 0 2
101801: PPUSH
101802: LD_VAR 0 5
101806: PPUSH
101807: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
101811: LD_VAR 0 6
101815: PUSH
101816: LD_INT 1
101818: ARRAY
101819: PPUSH
101820: LD_VAR 0 3
101824: PPUSH
101825: LD_VAR 0 4
101829: PPUSH
101830: CALL_OW 237
// end ;
101834: PPOPN 6
101836: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
101837: LD_EXP 109
101841: PUSH
101842: LD_EXP 156
101846: AND
101847: IFFALSE 101926
101849: GO 101851
101851: DISABLE
101852: LD_INT 0
101854: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
101855: LD_ADDR_VAR 0 1
101859: PUSH
101860: LD_INT 22
101862: PUSH
101863: LD_OWVAR 2
101867: PUSH
101868: EMPTY
101869: LIST
101870: LIST
101871: PUSH
101872: LD_INT 30
101874: PUSH
101875: LD_INT 3
101877: PUSH
101878: EMPTY
101879: LIST
101880: LIST
101881: PUSH
101882: EMPTY
101883: LIST
101884: LIST
101885: PPUSH
101886: CALL_OW 69
101890: ST_TO_ADDR
// if not tmp then
101891: LD_VAR 0 1
101895: NOT
101896: IFFALSE 101900
// exit ;
101898: GO 101926
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101900: LD_VAR 0 1
101904: PUSH
101905: LD_INT 1
101907: PPUSH
101908: LD_VAR 0 1
101912: PPUSH
101913: CALL_OW 12
101917: ARRAY
101918: PPUSH
101919: LD_INT 1
101921: PPUSH
101922: CALL_OW 234
// end ;
101926: PPOPN 1
101928: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101929: LD_EXP 109
101933: PUSH
101934: LD_EXP 157
101938: AND
101939: IFFALSE 102051
101941: GO 101943
101943: DISABLE
101944: LD_INT 0
101946: PPUSH
101947: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
101948: LD_ADDR_VAR 0 2
101952: PUSH
101953: LD_INT 22
101955: PUSH
101956: LD_OWVAR 2
101960: PUSH
101961: EMPTY
101962: LIST
101963: LIST
101964: PUSH
101965: LD_INT 2
101967: PUSH
101968: LD_INT 30
101970: PUSH
101971: LD_INT 27
101973: PUSH
101974: EMPTY
101975: LIST
101976: LIST
101977: PUSH
101978: LD_INT 30
101980: PUSH
101981: LD_INT 26
101983: PUSH
101984: EMPTY
101985: LIST
101986: LIST
101987: PUSH
101988: LD_INT 30
101990: PUSH
101991: LD_INT 28
101993: PUSH
101994: EMPTY
101995: LIST
101996: LIST
101997: PUSH
101998: EMPTY
101999: LIST
102000: LIST
102001: LIST
102002: LIST
102003: PUSH
102004: EMPTY
102005: LIST
102006: LIST
102007: PPUSH
102008: CALL_OW 69
102012: ST_TO_ADDR
// if not tmp then
102013: LD_VAR 0 2
102017: NOT
102018: IFFALSE 102022
// exit ;
102020: GO 102051
// for i in tmp do
102022: LD_ADDR_VAR 0 1
102026: PUSH
102027: LD_VAR 0 2
102031: PUSH
102032: FOR_IN
102033: IFFALSE 102049
// SetLives ( i , 1 ) ;
102035: LD_VAR 0 1
102039: PPUSH
102040: LD_INT 1
102042: PPUSH
102043: CALL_OW 234
102047: GO 102032
102049: POP
102050: POP
// end ;
102051: PPOPN 2
102053: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
102054: LD_EXP 109
102058: PUSH
102059: LD_EXP 158
102063: AND
102064: IFFALSE 102351
102066: GO 102068
102068: DISABLE
102069: LD_INT 0
102071: PPUSH
102072: PPUSH
102073: PPUSH
// begin i := rand ( 1 , 7 ) ;
102074: LD_ADDR_VAR 0 1
102078: PUSH
102079: LD_INT 1
102081: PPUSH
102082: LD_INT 7
102084: PPUSH
102085: CALL_OW 12
102089: ST_TO_ADDR
// case i of 1 :
102090: LD_VAR 0 1
102094: PUSH
102095: LD_INT 1
102097: DOUBLE
102098: EQUAL
102099: IFTRUE 102103
102101: GO 102113
102103: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
102104: LD_STRING earthquake(getX(game), 0, 32)
102106: PPUSH
102107: CALL_OW 559
102111: GO 102351
102113: LD_INT 2
102115: DOUBLE
102116: EQUAL
102117: IFTRUE 102121
102119: GO 102135
102121: POP
// begin ToLua ( displayStucuk(); ) ;
102122: LD_STRING displayStucuk();
102124: PPUSH
102125: CALL_OW 559
// ResetFog ;
102129: CALL_OW 335
// end ; 3 :
102133: GO 102351
102135: LD_INT 3
102137: DOUBLE
102138: EQUAL
102139: IFTRUE 102143
102141: GO 102247
102143: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102144: LD_ADDR_VAR 0 2
102148: PUSH
102149: LD_INT 22
102151: PUSH
102152: LD_OWVAR 2
102156: PUSH
102157: EMPTY
102158: LIST
102159: LIST
102160: PUSH
102161: LD_INT 25
102163: PUSH
102164: LD_INT 1
102166: PUSH
102167: EMPTY
102168: LIST
102169: LIST
102170: PUSH
102171: EMPTY
102172: LIST
102173: LIST
102174: PPUSH
102175: CALL_OW 69
102179: ST_TO_ADDR
// if not tmp then
102180: LD_VAR 0 2
102184: NOT
102185: IFFALSE 102189
// exit ;
102187: GO 102351
// un := tmp [ rand ( 1 , tmp ) ] ;
102189: LD_ADDR_VAR 0 3
102193: PUSH
102194: LD_VAR 0 2
102198: PUSH
102199: LD_INT 1
102201: PPUSH
102202: LD_VAR 0 2
102206: PPUSH
102207: CALL_OW 12
102211: ARRAY
102212: ST_TO_ADDR
// if Crawls ( un ) then
102213: LD_VAR 0 3
102217: PPUSH
102218: CALL_OW 318
102222: IFFALSE 102233
// ComWalk ( un ) ;
102224: LD_VAR 0 3
102228: PPUSH
102229: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102233: LD_VAR 0 3
102237: PPUSH
102238: LD_INT 8
102240: PPUSH
102241: CALL_OW 336
// end ; 4 :
102245: GO 102351
102247: LD_INT 4
102249: DOUBLE
102250: EQUAL
102251: IFTRUE 102255
102253: GO 102329
102255: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102256: LD_ADDR_VAR 0 2
102260: PUSH
102261: LD_INT 22
102263: PUSH
102264: LD_OWVAR 2
102268: PUSH
102269: EMPTY
102270: LIST
102271: LIST
102272: PUSH
102273: LD_INT 30
102275: PUSH
102276: LD_INT 29
102278: PUSH
102279: EMPTY
102280: LIST
102281: LIST
102282: PUSH
102283: EMPTY
102284: LIST
102285: LIST
102286: PPUSH
102287: CALL_OW 69
102291: ST_TO_ADDR
// if not tmp then
102292: LD_VAR 0 2
102296: NOT
102297: IFFALSE 102301
// exit ;
102299: GO 102351
// CenterNowOnUnits ( tmp [ 1 ] ) ;
102301: LD_VAR 0 2
102305: PUSH
102306: LD_INT 1
102308: ARRAY
102309: PPUSH
102310: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
102314: LD_VAR 0 2
102318: PUSH
102319: LD_INT 1
102321: ARRAY
102322: PPUSH
102323: CALL_OW 65
// end ; 5 .. 7 :
102327: GO 102351
102329: LD_INT 5
102331: DOUBLE
102332: GREATEREQUAL
102333: IFFALSE 102341
102335: LD_INT 7
102337: DOUBLE
102338: LESSEQUAL
102339: IFTRUE 102343
102341: GO 102350
102343: POP
// StreamSibBomb ; end ;
102344: CALL 98588 0 0
102348: GO 102351
102350: POP
// end ;
102351: PPOPN 3
102353: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
102354: LD_EXP 109
102358: PUSH
102359: LD_EXP 159
102363: AND
102364: IFFALSE 102520
102366: GO 102368
102368: DISABLE
102369: LD_INT 0
102371: PPUSH
102372: PPUSH
102373: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
102374: LD_ADDR_VAR 0 2
102378: PUSH
102379: LD_INT 81
102381: PUSH
102382: LD_OWVAR 2
102386: PUSH
102387: EMPTY
102388: LIST
102389: LIST
102390: PUSH
102391: LD_INT 2
102393: PUSH
102394: LD_INT 21
102396: PUSH
102397: LD_INT 1
102399: PUSH
102400: EMPTY
102401: LIST
102402: LIST
102403: PUSH
102404: LD_INT 21
102406: PUSH
102407: LD_INT 2
102409: PUSH
102410: EMPTY
102411: LIST
102412: LIST
102413: PUSH
102414: EMPTY
102415: LIST
102416: LIST
102417: LIST
102418: PUSH
102419: EMPTY
102420: LIST
102421: LIST
102422: PPUSH
102423: CALL_OW 69
102427: ST_TO_ADDR
// if not tmp then
102428: LD_VAR 0 2
102432: NOT
102433: IFFALSE 102437
// exit ;
102435: GO 102520
// p := 0 ;
102437: LD_ADDR_VAR 0 3
102441: PUSH
102442: LD_INT 0
102444: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102445: LD_INT 35
102447: PPUSH
102448: CALL_OW 67
// p := p + 1 ;
102452: LD_ADDR_VAR 0 3
102456: PUSH
102457: LD_VAR 0 3
102461: PUSH
102462: LD_INT 1
102464: PLUS
102465: ST_TO_ADDR
// for i in tmp do
102466: LD_ADDR_VAR 0 1
102470: PUSH
102471: LD_VAR 0 2
102475: PUSH
102476: FOR_IN
102477: IFFALSE 102508
// if GetLives ( i ) < 1000 then
102479: LD_VAR 0 1
102483: PPUSH
102484: CALL_OW 256
102488: PUSH
102489: LD_INT 1000
102491: LESS
102492: IFFALSE 102506
// SetLives ( i , 1000 ) ;
102494: LD_VAR 0 1
102498: PPUSH
102499: LD_INT 1000
102501: PPUSH
102502: CALL_OW 234
102506: GO 102476
102508: POP
102509: POP
// until p > 20 ;
102510: LD_VAR 0 3
102514: PUSH
102515: LD_INT 20
102517: GREATER
102518: IFFALSE 102445
// end ;
102520: PPOPN 3
102522: END
// every 0 0$1 trigger StreamModeActive and sTime do
102523: LD_EXP 109
102527: PUSH
102528: LD_EXP 160
102532: AND
102533: IFFALSE 102568
102535: GO 102537
102537: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
102538: LD_INT 28
102540: PPUSH
102541: LD_OWVAR 2
102545: PPUSH
102546: LD_INT 2
102548: PPUSH
102549: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
102553: LD_INT 30
102555: PPUSH
102556: LD_OWVAR 2
102560: PPUSH
102561: LD_INT 2
102563: PPUSH
102564: CALL_OW 322
// end ;
102568: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
102569: LD_EXP 109
102573: PUSH
102574: LD_EXP 161
102578: AND
102579: IFFALSE 102700
102581: GO 102583
102583: DISABLE
102584: LD_INT 0
102586: PPUSH
102587: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102588: LD_ADDR_VAR 0 2
102592: PUSH
102593: LD_INT 22
102595: PUSH
102596: LD_OWVAR 2
102600: PUSH
102601: EMPTY
102602: LIST
102603: LIST
102604: PUSH
102605: LD_INT 21
102607: PUSH
102608: LD_INT 1
102610: PUSH
102611: EMPTY
102612: LIST
102613: LIST
102614: PUSH
102615: LD_INT 3
102617: PUSH
102618: LD_INT 23
102620: PUSH
102621: LD_INT 0
102623: PUSH
102624: EMPTY
102625: LIST
102626: LIST
102627: PUSH
102628: EMPTY
102629: LIST
102630: LIST
102631: PUSH
102632: EMPTY
102633: LIST
102634: LIST
102635: LIST
102636: PPUSH
102637: CALL_OW 69
102641: ST_TO_ADDR
// if not tmp then
102642: LD_VAR 0 2
102646: NOT
102647: IFFALSE 102651
// exit ;
102649: GO 102700
// for i in tmp do
102651: LD_ADDR_VAR 0 1
102655: PUSH
102656: LD_VAR 0 2
102660: PUSH
102661: FOR_IN
102662: IFFALSE 102698
// begin if Crawls ( i ) then
102664: LD_VAR 0 1
102668: PPUSH
102669: CALL_OW 318
102673: IFFALSE 102684
// ComWalk ( i ) ;
102675: LD_VAR 0 1
102679: PPUSH
102680: CALL_OW 138
// SetClass ( i , 2 ) ;
102684: LD_VAR 0 1
102688: PPUSH
102689: LD_INT 2
102691: PPUSH
102692: CALL_OW 336
// end ;
102696: GO 102661
102698: POP
102699: POP
// end ;
102700: PPOPN 2
102702: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
102703: LD_EXP 109
102707: PUSH
102708: LD_EXP 162
102712: AND
102713: IFFALSE 103001
102715: GO 102717
102717: DISABLE
102718: LD_INT 0
102720: PPUSH
102721: PPUSH
102722: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
102723: LD_OWVAR 2
102727: PPUSH
102728: LD_INT 9
102730: PPUSH
102731: LD_INT 1
102733: PPUSH
102734: LD_INT 1
102736: PPUSH
102737: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
102741: LD_INT 9
102743: PPUSH
102744: LD_OWVAR 2
102748: PPUSH
102749: CALL_OW 343
// uc_side := 9 ;
102753: LD_ADDR_OWVAR 20
102757: PUSH
102758: LD_INT 9
102760: ST_TO_ADDR
// uc_nation := 2 ;
102761: LD_ADDR_OWVAR 21
102765: PUSH
102766: LD_INT 2
102768: ST_TO_ADDR
// hc_name := Dark Warrior ;
102769: LD_ADDR_OWVAR 26
102773: PUSH
102774: LD_STRING Dark Warrior
102776: ST_TO_ADDR
// hc_gallery :=  ;
102777: LD_ADDR_OWVAR 33
102781: PUSH
102782: LD_STRING 
102784: ST_TO_ADDR
// hc_noskilllimit := true ;
102785: LD_ADDR_OWVAR 76
102789: PUSH
102790: LD_INT 1
102792: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
102793: LD_ADDR_OWVAR 31
102797: PUSH
102798: LD_INT 30
102800: PUSH
102801: LD_INT 30
102803: PUSH
102804: LD_INT 30
102806: PUSH
102807: LD_INT 30
102809: PUSH
102810: EMPTY
102811: LIST
102812: LIST
102813: LIST
102814: LIST
102815: ST_TO_ADDR
// un := CreateHuman ;
102816: LD_ADDR_VAR 0 3
102820: PUSH
102821: CALL_OW 44
102825: ST_TO_ADDR
// hc_noskilllimit := false ;
102826: LD_ADDR_OWVAR 76
102830: PUSH
102831: LD_INT 0
102833: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102834: LD_VAR 0 3
102838: PPUSH
102839: LD_INT 1
102841: PPUSH
102842: CALL_OW 51
// ToLua ( playRanger() ) ;
102846: LD_STRING playRanger()
102848: PPUSH
102849: CALL_OW 559
// p := 0 ;
102853: LD_ADDR_VAR 0 2
102857: PUSH
102858: LD_INT 0
102860: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102861: LD_INT 35
102863: PPUSH
102864: CALL_OW 67
// p := p + 1 ;
102868: LD_ADDR_VAR 0 2
102872: PUSH
102873: LD_VAR 0 2
102877: PUSH
102878: LD_INT 1
102880: PLUS
102881: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
102882: LD_VAR 0 3
102886: PPUSH
102887: CALL_OW 256
102891: PUSH
102892: LD_INT 1000
102894: LESS
102895: IFFALSE 102909
// SetLives ( un , 1000 ) ;
102897: LD_VAR 0 3
102901: PPUSH
102902: LD_INT 1000
102904: PPUSH
102905: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
102909: LD_VAR 0 3
102913: PPUSH
102914: LD_INT 81
102916: PUSH
102917: LD_OWVAR 2
102921: PUSH
102922: EMPTY
102923: LIST
102924: LIST
102925: PUSH
102926: LD_INT 91
102928: PUSH
102929: LD_VAR 0 3
102933: PUSH
102934: LD_INT 30
102936: PUSH
102937: EMPTY
102938: LIST
102939: LIST
102940: LIST
102941: PUSH
102942: EMPTY
102943: LIST
102944: LIST
102945: PPUSH
102946: CALL_OW 69
102950: PPUSH
102951: LD_VAR 0 3
102955: PPUSH
102956: CALL_OW 74
102960: PPUSH
102961: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
102965: LD_VAR 0 2
102969: PUSH
102970: LD_INT 80
102972: GREATER
102973: PUSH
102974: LD_VAR 0 3
102978: PPUSH
102979: CALL_OW 301
102983: OR
102984: IFFALSE 102861
// if un then
102986: LD_VAR 0 3
102990: IFFALSE 103001
// RemoveUnit ( un ) ;
102992: LD_VAR 0 3
102996: PPUSH
102997: CALL_OW 64
// end ;
103001: PPOPN 3
103003: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
103004: LD_EXP 163
103008: IFFALSE 103124
103010: GO 103012
103012: DISABLE
103013: LD_INT 0
103015: PPUSH
103016: PPUSH
103017: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
103018: LD_ADDR_VAR 0 2
103022: PUSH
103023: LD_INT 81
103025: PUSH
103026: LD_OWVAR 2
103030: PUSH
103031: EMPTY
103032: LIST
103033: LIST
103034: PUSH
103035: LD_INT 21
103037: PUSH
103038: LD_INT 1
103040: PUSH
103041: EMPTY
103042: LIST
103043: LIST
103044: PUSH
103045: EMPTY
103046: LIST
103047: LIST
103048: PPUSH
103049: CALL_OW 69
103053: ST_TO_ADDR
// ToLua ( playComputer() ) ;
103054: LD_STRING playComputer()
103056: PPUSH
103057: CALL_OW 559
// if not tmp then
103061: LD_VAR 0 2
103065: NOT
103066: IFFALSE 103070
// exit ;
103068: GO 103124
// for i in tmp do
103070: LD_ADDR_VAR 0 1
103074: PUSH
103075: LD_VAR 0 2
103079: PUSH
103080: FOR_IN
103081: IFFALSE 103122
// for j := 1 to 4 do
103083: LD_ADDR_VAR 0 3
103087: PUSH
103088: DOUBLE
103089: LD_INT 1
103091: DEC
103092: ST_TO_ADDR
103093: LD_INT 4
103095: PUSH
103096: FOR_TO
103097: IFFALSE 103118
// SetSkill ( i , j , 10 ) ;
103099: LD_VAR 0 1
103103: PPUSH
103104: LD_VAR 0 3
103108: PPUSH
103109: LD_INT 10
103111: PPUSH
103112: CALL_OW 237
103116: GO 103096
103118: POP
103119: POP
103120: GO 103080
103122: POP
103123: POP
// end ;
103124: PPOPN 3
103126: END
// every 0 0$1 trigger s30 do var i , tmp ;
103127: LD_EXP 164
103131: IFFALSE 103200
103133: GO 103135
103135: DISABLE
103136: LD_INT 0
103138: PPUSH
103139: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103140: LD_ADDR_VAR 0 2
103144: PUSH
103145: LD_INT 22
103147: PUSH
103148: LD_OWVAR 2
103152: PUSH
103153: EMPTY
103154: LIST
103155: LIST
103156: PPUSH
103157: CALL_OW 69
103161: ST_TO_ADDR
// if not tmp then
103162: LD_VAR 0 2
103166: NOT
103167: IFFALSE 103171
// exit ;
103169: GO 103200
// for i in tmp do
103171: LD_ADDR_VAR 0 1
103175: PUSH
103176: LD_VAR 0 2
103180: PUSH
103181: FOR_IN
103182: IFFALSE 103198
// SetLives ( i , 300 ) ;
103184: LD_VAR 0 1
103188: PPUSH
103189: LD_INT 300
103191: PPUSH
103192: CALL_OW 234
103196: GO 103181
103198: POP
103199: POP
// end ;
103200: PPOPN 2
103202: END
// every 0 0$1 trigger s60 do var i , tmp ;
103203: LD_EXP 165
103207: IFFALSE 103276
103209: GO 103211
103211: DISABLE
103212: LD_INT 0
103214: PPUSH
103215: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103216: LD_ADDR_VAR 0 2
103220: PUSH
103221: LD_INT 22
103223: PUSH
103224: LD_OWVAR 2
103228: PUSH
103229: EMPTY
103230: LIST
103231: LIST
103232: PPUSH
103233: CALL_OW 69
103237: ST_TO_ADDR
// if not tmp then
103238: LD_VAR 0 2
103242: NOT
103243: IFFALSE 103247
// exit ;
103245: GO 103276
// for i in tmp do
103247: LD_ADDR_VAR 0 1
103251: PUSH
103252: LD_VAR 0 2
103256: PUSH
103257: FOR_IN
103258: IFFALSE 103274
// SetLives ( i , 600 ) ;
103260: LD_VAR 0 1
103264: PPUSH
103265: LD_INT 600
103267: PPUSH
103268: CALL_OW 234
103272: GO 103257
103274: POP
103275: POP
// end ;
103276: PPOPN 2
103278: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
103279: LD_INT 0
103281: PPUSH
// case cmd of 301 :
103282: LD_VAR 0 1
103286: PUSH
103287: LD_INT 301
103289: DOUBLE
103290: EQUAL
103291: IFTRUE 103295
103293: GO 103327
103295: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
103296: LD_VAR 0 6
103300: PPUSH
103301: LD_VAR 0 7
103305: PPUSH
103306: LD_VAR 0 8
103310: PPUSH
103311: LD_VAR 0 4
103315: PPUSH
103316: LD_VAR 0 5
103320: PPUSH
103321: CALL 104536 0 5
103325: GO 103448
103327: LD_INT 302
103329: DOUBLE
103330: EQUAL
103331: IFTRUE 103335
103333: GO 103372
103335: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
103336: LD_VAR 0 6
103340: PPUSH
103341: LD_VAR 0 7
103345: PPUSH
103346: LD_VAR 0 8
103350: PPUSH
103351: LD_VAR 0 9
103355: PPUSH
103356: LD_VAR 0 4
103360: PPUSH
103361: LD_VAR 0 5
103365: PPUSH
103366: CALL 104627 0 6
103370: GO 103448
103372: LD_INT 303
103374: DOUBLE
103375: EQUAL
103376: IFTRUE 103380
103378: GO 103417
103380: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
103381: LD_VAR 0 6
103385: PPUSH
103386: LD_VAR 0 7
103390: PPUSH
103391: LD_VAR 0 8
103395: PPUSH
103396: LD_VAR 0 9
103400: PPUSH
103401: LD_VAR 0 4
103405: PPUSH
103406: LD_VAR 0 5
103410: PPUSH
103411: CALL 103453 0 6
103415: GO 103448
103417: LD_INT 304
103419: DOUBLE
103420: EQUAL
103421: IFTRUE 103425
103423: GO 103447
103425: POP
// hHackTeleport ( unit , x , y ) ; end ;
103426: LD_VAR 0 2
103430: PPUSH
103431: LD_VAR 0 4
103435: PPUSH
103436: LD_VAR 0 5
103440: PPUSH
103441: CALL 105220 0 3
103445: GO 103448
103447: POP
// end ;
103448: LD_VAR 0 12
103452: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
103453: LD_INT 0
103455: PPUSH
103456: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
103457: LD_VAR 0 1
103461: PUSH
103462: LD_INT 1
103464: LESS
103465: PUSH
103466: LD_VAR 0 1
103470: PUSH
103471: LD_INT 3
103473: GREATER
103474: OR
103475: PUSH
103476: LD_VAR 0 5
103480: PPUSH
103481: LD_VAR 0 6
103485: PPUSH
103486: CALL_OW 428
103490: OR
103491: IFFALSE 103495
// exit ;
103493: GO 104223
// uc_side := your_side ;
103495: LD_ADDR_OWVAR 20
103499: PUSH
103500: LD_OWVAR 2
103504: ST_TO_ADDR
// uc_nation := nation ;
103505: LD_ADDR_OWVAR 21
103509: PUSH
103510: LD_VAR 0 1
103514: ST_TO_ADDR
// bc_level = 1 ;
103515: LD_ADDR_OWVAR 43
103519: PUSH
103520: LD_INT 1
103522: ST_TO_ADDR
// case btype of 1 :
103523: LD_VAR 0 2
103527: PUSH
103528: LD_INT 1
103530: DOUBLE
103531: EQUAL
103532: IFTRUE 103536
103534: GO 103547
103536: POP
// bc_type := b_depot ; 2 :
103537: LD_ADDR_OWVAR 42
103541: PUSH
103542: LD_INT 0
103544: ST_TO_ADDR
103545: GO 104167
103547: LD_INT 2
103549: DOUBLE
103550: EQUAL
103551: IFTRUE 103555
103553: GO 103566
103555: POP
// bc_type := b_warehouse ; 3 :
103556: LD_ADDR_OWVAR 42
103560: PUSH
103561: LD_INT 1
103563: ST_TO_ADDR
103564: GO 104167
103566: LD_INT 3
103568: DOUBLE
103569: EQUAL
103570: IFTRUE 103574
103572: GO 103585
103574: POP
// bc_type := b_lab ; 4 .. 9 :
103575: LD_ADDR_OWVAR 42
103579: PUSH
103580: LD_INT 6
103582: ST_TO_ADDR
103583: GO 104167
103585: LD_INT 4
103587: DOUBLE
103588: GREATEREQUAL
103589: IFFALSE 103597
103591: LD_INT 9
103593: DOUBLE
103594: LESSEQUAL
103595: IFTRUE 103599
103597: GO 103659
103599: POP
// begin bc_type := b_lab_half ;
103600: LD_ADDR_OWVAR 42
103604: PUSH
103605: LD_INT 7
103607: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
103608: LD_ADDR_OWVAR 44
103612: PUSH
103613: LD_INT 10
103615: PUSH
103616: LD_INT 11
103618: PUSH
103619: LD_INT 12
103621: PUSH
103622: LD_INT 15
103624: PUSH
103625: LD_INT 14
103627: PUSH
103628: LD_INT 13
103630: PUSH
103631: EMPTY
103632: LIST
103633: LIST
103634: LIST
103635: LIST
103636: LIST
103637: LIST
103638: PUSH
103639: LD_VAR 0 2
103643: PUSH
103644: LD_INT 3
103646: MINUS
103647: ARRAY
103648: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
103649: LD_ADDR_OWVAR 45
103653: PUSH
103654: LD_INT 9
103656: ST_TO_ADDR
// end ; 10 .. 13 :
103657: GO 104167
103659: LD_INT 10
103661: DOUBLE
103662: GREATEREQUAL
103663: IFFALSE 103671
103665: LD_INT 13
103667: DOUBLE
103668: LESSEQUAL
103669: IFTRUE 103673
103671: GO 103750
103673: POP
// begin bc_type := b_lab_full ;
103674: LD_ADDR_OWVAR 42
103678: PUSH
103679: LD_INT 8
103681: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
103682: LD_ADDR_OWVAR 44
103686: PUSH
103687: LD_INT 10
103689: PUSH
103690: LD_INT 12
103692: PUSH
103693: LD_INT 14
103695: PUSH
103696: LD_INT 13
103698: PUSH
103699: EMPTY
103700: LIST
103701: LIST
103702: LIST
103703: LIST
103704: PUSH
103705: LD_VAR 0 2
103709: PUSH
103710: LD_INT 9
103712: MINUS
103713: ARRAY
103714: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
103715: LD_ADDR_OWVAR 45
103719: PUSH
103720: LD_INT 11
103722: PUSH
103723: LD_INT 15
103725: PUSH
103726: LD_INT 12
103728: PUSH
103729: LD_INT 15
103731: PUSH
103732: EMPTY
103733: LIST
103734: LIST
103735: LIST
103736: LIST
103737: PUSH
103738: LD_VAR 0 2
103742: PUSH
103743: LD_INT 9
103745: MINUS
103746: ARRAY
103747: ST_TO_ADDR
// end ; 14 :
103748: GO 104167
103750: LD_INT 14
103752: DOUBLE
103753: EQUAL
103754: IFTRUE 103758
103756: GO 103769
103758: POP
// bc_type := b_workshop ; 15 :
103759: LD_ADDR_OWVAR 42
103763: PUSH
103764: LD_INT 2
103766: ST_TO_ADDR
103767: GO 104167
103769: LD_INT 15
103771: DOUBLE
103772: EQUAL
103773: IFTRUE 103777
103775: GO 103788
103777: POP
// bc_type := b_factory ; 16 :
103778: LD_ADDR_OWVAR 42
103782: PUSH
103783: LD_INT 3
103785: ST_TO_ADDR
103786: GO 104167
103788: LD_INT 16
103790: DOUBLE
103791: EQUAL
103792: IFTRUE 103796
103794: GO 103807
103796: POP
// bc_type := b_ext_gun ; 17 :
103797: LD_ADDR_OWVAR 42
103801: PUSH
103802: LD_INT 17
103804: ST_TO_ADDR
103805: GO 104167
103807: LD_INT 17
103809: DOUBLE
103810: EQUAL
103811: IFTRUE 103815
103813: GO 103843
103815: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
103816: LD_ADDR_OWVAR 42
103820: PUSH
103821: LD_INT 19
103823: PUSH
103824: LD_INT 23
103826: PUSH
103827: LD_INT 19
103829: PUSH
103830: EMPTY
103831: LIST
103832: LIST
103833: LIST
103834: PUSH
103835: LD_VAR 0 1
103839: ARRAY
103840: ST_TO_ADDR
103841: GO 104167
103843: LD_INT 18
103845: DOUBLE
103846: EQUAL
103847: IFTRUE 103851
103849: GO 103862
103851: POP
// bc_type := b_ext_radar ; 19 :
103852: LD_ADDR_OWVAR 42
103856: PUSH
103857: LD_INT 20
103859: ST_TO_ADDR
103860: GO 104167
103862: LD_INT 19
103864: DOUBLE
103865: EQUAL
103866: IFTRUE 103870
103868: GO 103881
103870: POP
// bc_type := b_ext_radio ; 20 :
103871: LD_ADDR_OWVAR 42
103875: PUSH
103876: LD_INT 22
103878: ST_TO_ADDR
103879: GO 104167
103881: LD_INT 20
103883: DOUBLE
103884: EQUAL
103885: IFTRUE 103889
103887: GO 103900
103889: POP
// bc_type := b_ext_siberium ; 21 :
103890: LD_ADDR_OWVAR 42
103894: PUSH
103895: LD_INT 21
103897: ST_TO_ADDR
103898: GO 104167
103900: LD_INT 21
103902: DOUBLE
103903: EQUAL
103904: IFTRUE 103908
103906: GO 103919
103908: POP
// bc_type := b_ext_computer ; 22 :
103909: LD_ADDR_OWVAR 42
103913: PUSH
103914: LD_INT 24
103916: ST_TO_ADDR
103917: GO 104167
103919: LD_INT 22
103921: DOUBLE
103922: EQUAL
103923: IFTRUE 103927
103925: GO 103938
103927: POP
// bc_type := b_ext_track ; 23 :
103928: LD_ADDR_OWVAR 42
103932: PUSH
103933: LD_INT 16
103935: ST_TO_ADDR
103936: GO 104167
103938: LD_INT 23
103940: DOUBLE
103941: EQUAL
103942: IFTRUE 103946
103944: GO 103957
103946: POP
// bc_type := b_ext_laser ; 24 :
103947: LD_ADDR_OWVAR 42
103951: PUSH
103952: LD_INT 25
103954: ST_TO_ADDR
103955: GO 104167
103957: LD_INT 24
103959: DOUBLE
103960: EQUAL
103961: IFTRUE 103965
103963: GO 103976
103965: POP
// bc_type := b_control_tower ; 25 :
103966: LD_ADDR_OWVAR 42
103970: PUSH
103971: LD_INT 36
103973: ST_TO_ADDR
103974: GO 104167
103976: LD_INT 25
103978: DOUBLE
103979: EQUAL
103980: IFTRUE 103984
103982: GO 103995
103984: POP
// bc_type := b_breastwork ; 26 :
103985: LD_ADDR_OWVAR 42
103989: PUSH
103990: LD_INT 31
103992: ST_TO_ADDR
103993: GO 104167
103995: LD_INT 26
103997: DOUBLE
103998: EQUAL
103999: IFTRUE 104003
104001: GO 104014
104003: POP
// bc_type := b_bunker ; 27 :
104004: LD_ADDR_OWVAR 42
104008: PUSH
104009: LD_INT 32
104011: ST_TO_ADDR
104012: GO 104167
104014: LD_INT 27
104016: DOUBLE
104017: EQUAL
104018: IFTRUE 104022
104020: GO 104033
104022: POP
// bc_type := b_turret ; 28 :
104023: LD_ADDR_OWVAR 42
104027: PUSH
104028: LD_INT 33
104030: ST_TO_ADDR
104031: GO 104167
104033: LD_INT 28
104035: DOUBLE
104036: EQUAL
104037: IFTRUE 104041
104039: GO 104052
104041: POP
// bc_type := b_armoury ; 29 :
104042: LD_ADDR_OWVAR 42
104046: PUSH
104047: LD_INT 4
104049: ST_TO_ADDR
104050: GO 104167
104052: LD_INT 29
104054: DOUBLE
104055: EQUAL
104056: IFTRUE 104060
104058: GO 104071
104060: POP
// bc_type := b_barracks ; 30 :
104061: LD_ADDR_OWVAR 42
104065: PUSH
104066: LD_INT 5
104068: ST_TO_ADDR
104069: GO 104167
104071: LD_INT 30
104073: DOUBLE
104074: EQUAL
104075: IFTRUE 104079
104077: GO 104090
104079: POP
// bc_type := b_solar_power ; 31 :
104080: LD_ADDR_OWVAR 42
104084: PUSH
104085: LD_INT 27
104087: ST_TO_ADDR
104088: GO 104167
104090: LD_INT 31
104092: DOUBLE
104093: EQUAL
104094: IFTRUE 104098
104096: GO 104109
104098: POP
// bc_type := b_oil_power ; 32 :
104099: LD_ADDR_OWVAR 42
104103: PUSH
104104: LD_INT 26
104106: ST_TO_ADDR
104107: GO 104167
104109: LD_INT 32
104111: DOUBLE
104112: EQUAL
104113: IFTRUE 104117
104115: GO 104128
104117: POP
// bc_type := b_siberite_power ; 33 :
104118: LD_ADDR_OWVAR 42
104122: PUSH
104123: LD_INT 28
104125: ST_TO_ADDR
104126: GO 104167
104128: LD_INT 33
104130: DOUBLE
104131: EQUAL
104132: IFTRUE 104136
104134: GO 104147
104136: POP
// bc_type := b_oil_mine ; 34 :
104137: LD_ADDR_OWVAR 42
104141: PUSH
104142: LD_INT 29
104144: ST_TO_ADDR
104145: GO 104167
104147: LD_INT 34
104149: DOUBLE
104150: EQUAL
104151: IFTRUE 104155
104153: GO 104166
104155: POP
// bc_type := b_siberite_mine ; end ;
104156: LD_ADDR_OWVAR 42
104160: PUSH
104161: LD_INT 30
104163: ST_TO_ADDR
104164: GO 104167
104166: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
104167: LD_ADDR_VAR 0 8
104171: PUSH
104172: LD_VAR 0 5
104176: PPUSH
104177: LD_VAR 0 6
104181: PPUSH
104182: LD_VAR 0 3
104186: PPUSH
104187: CALL_OW 47
104191: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
104192: LD_OWVAR 42
104196: PUSH
104197: LD_INT 32
104199: PUSH
104200: LD_INT 33
104202: PUSH
104203: EMPTY
104204: LIST
104205: LIST
104206: IN
104207: IFFALSE 104223
// PlaceWeaponTurret ( b , weapon ) ;
104209: LD_VAR 0 8
104213: PPUSH
104214: LD_VAR 0 4
104218: PPUSH
104219: CALL_OW 431
// end ;
104223: LD_VAR 0 7
104227: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
104228: LD_INT 0
104230: PPUSH
104231: PPUSH
104232: PPUSH
104233: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104234: LD_ADDR_VAR 0 4
104238: PUSH
104239: LD_INT 22
104241: PUSH
104242: LD_OWVAR 2
104246: PUSH
104247: EMPTY
104248: LIST
104249: LIST
104250: PUSH
104251: LD_INT 2
104253: PUSH
104254: LD_INT 30
104256: PUSH
104257: LD_INT 0
104259: PUSH
104260: EMPTY
104261: LIST
104262: LIST
104263: PUSH
104264: LD_INT 30
104266: PUSH
104267: LD_INT 1
104269: PUSH
104270: EMPTY
104271: LIST
104272: LIST
104273: PUSH
104274: EMPTY
104275: LIST
104276: LIST
104277: LIST
104278: PUSH
104279: EMPTY
104280: LIST
104281: LIST
104282: PPUSH
104283: CALL_OW 69
104287: ST_TO_ADDR
// if not tmp then
104288: LD_VAR 0 4
104292: NOT
104293: IFFALSE 104297
// exit ;
104295: GO 104356
// for i in tmp do
104297: LD_ADDR_VAR 0 2
104301: PUSH
104302: LD_VAR 0 4
104306: PUSH
104307: FOR_IN
104308: IFFALSE 104354
// for j = 1 to 3 do
104310: LD_ADDR_VAR 0 3
104314: PUSH
104315: DOUBLE
104316: LD_INT 1
104318: DEC
104319: ST_TO_ADDR
104320: LD_INT 3
104322: PUSH
104323: FOR_TO
104324: IFFALSE 104350
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
104326: LD_VAR 0 2
104330: PPUSH
104331: CALL_OW 274
104335: PPUSH
104336: LD_VAR 0 3
104340: PPUSH
104341: LD_INT 99999
104343: PPUSH
104344: CALL_OW 277
104348: GO 104323
104350: POP
104351: POP
104352: GO 104307
104354: POP
104355: POP
// end ;
104356: LD_VAR 0 1
104360: RET
// export function hHackSetLevel10 ; var i , j ; begin
104361: LD_INT 0
104363: PPUSH
104364: PPUSH
104365: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104366: LD_ADDR_VAR 0 2
104370: PUSH
104371: LD_INT 21
104373: PUSH
104374: LD_INT 1
104376: PUSH
104377: EMPTY
104378: LIST
104379: LIST
104380: PPUSH
104381: CALL_OW 69
104385: PUSH
104386: FOR_IN
104387: IFFALSE 104439
// if IsSelected ( i ) then
104389: LD_VAR 0 2
104393: PPUSH
104394: CALL_OW 306
104398: IFFALSE 104437
// begin for j := 1 to 4 do
104400: LD_ADDR_VAR 0 3
104404: PUSH
104405: DOUBLE
104406: LD_INT 1
104408: DEC
104409: ST_TO_ADDR
104410: LD_INT 4
104412: PUSH
104413: FOR_TO
104414: IFFALSE 104435
// SetSkill ( i , j , 10 ) ;
104416: LD_VAR 0 2
104420: PPUSH
104421: LD_VAR 0 3
104425: PPUSH
104426: LD_INT 10
104428: PPUSH
104429: CALL_OW 237
104433: GO 104413
104435: POP
104436: POP
// end ;
104437: GO 104386
104439: POP
104440: POP
// end ;
104441: LD_VAR 0 1
104445: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
104446: LD_INT 0
104448: PPUSH
104449: PPUSH
104450: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
104451: LD_ADDR_VAR 0 2
104455: PUSH
104456: LD_INT 22
104458: PUSH
104459: LD_OWVAR 2
104463: PUSH
104464: EMPTY
104465: LIST
104466: LIST
104467: PUSH
104468: LD_INT 21
104470: PUSH
104471: LD_INT 1
104473: PUSH
104474: EMPTY
104475: LIST
104476: LIST
104477: PUSH
104478: EMPTY
104479: LIST
104480: LIST
104481: PPUSH
104482: CALL_OW 69
104486: PUSH
104487: FOR_IN
104488: IFFALSE 104529
// begin for j := 1 to 4 do
104490: LD_ADDR_VAR 0 3
104494: PUSH
104495: DOUBLE
104496: LD_INT 1
104498: DEC
104499: ST_TO_ADDR
104500: LD_INT 4
104502: PUSH
104503: FOR_TO
104504: IFFALSE 104525
// SetSkill ( i , j , 10 ) ;
104506: LD_VAR 0 2
104510: PPUSH
104511: LD_VAR 0 3
104515: PPUSH
104516: LD_INT 10
104518: PPUSH
104519: CALL_OW 237
104523: GO 104503
104525: POP
104526: POP
// end ;
104527: GO 104487
104529: POP
104530: POP
// end ;
104531: LD_VAR 0 1
104535: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
104536: LD_INT 0
104538: PPUSH
// uc_side := your_side ;
104539: LD_ADDR_OWVAR 20
104543: PUSH
104544: LD_OWVAR 2
104548: ST_TO_ADDR
// uc_nation := nation ;
104549: LD_ADDR_OWVAR 21
104553: PUSH
104554: LD_VAR 0 1
104558: ST_TO_ADDR
// InitHc ;
104559: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
104563: LD_INT 0
104565: PPUSH
104566: LD_VAR 0 2
104570: PPUSH
104571: LD_VAR 0 3
104575: PPUSH
104576: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
104580: LD_VAR 0 4
104584: PPUSH
104585: LD_VAR 0 5
104589: PPUSH
104590: CALL_OW 428
104594: PUSH
104595: LD_INT 0
104597: EQUAL
104598: IFFALSE 104622
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
104600: CALL_OW 44
104604: PPUSH
104605: LD_VAR 0 4
104609: PPUSH
104610: LD_VAR 0 5
104614: PPUSH
104615: LD_INT 1
104617: PPUSH
104618: CALL_OW 48
// end ;
104622: LD_VAR 0 6
104626: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
104627: LD_INT 0
104629: PPUSH
104630: PPUSH
// uc_side := your_side ;
104631: LD_ADDR_OWVAR 20
104635: PUSH
104636: LD_OWVAR 2
104640: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
104641: LD_VAR 0 1
104645: PUSH
104646: LD_INT 1
104648: PUSH
104649: LD_INT 2
104651: PUSH
104652: LD_INT 3
104654: PUSH
104655: LD_INT 4
104657: PUSH
104658: LD_INT 5
104660: PUSH
104661: EMPTY
104662: LIST
104663: LIST
104664: LIST
104665: LIST
104666: LIST
104667: IN
104668: IFFALSE 104680
// uc_nation := nation_american else
104670: LD_ADDR_OWVAR 21
104674: PUSH
104675: LD_INT 1
104677: ST_TO_ADDR
104678: GO 104723
// if chassis in [ 11 , 12 , 13 , 14 ] then
104680: LD_VAR 0 1
104684: PUSH
104685: LD_INT 11
104687: PUSH
104688: LD_INT 12
104690: PUSH
104691: LD_INT 13
104693: PUSH
104694: LD_INT 14
104696: PUSH
104697: EMPTY
104698: LIST
104699: LIST
104700: LIST
104701: LIST
104702: IN
104703: IFFALSE 104715
// uc_nation := nation_arabian else
104705: LD_ADDR_OWVAR 21
104709: PUSH
104710: LD_INT 2
104712: ST_TO_ADDR
104713: GO 104723
// uc_nation := nation_russian ;
104715: LD_ADDR_OWVAR 21
104719: PUSH
104720: LD_INT 3
104722: ST_TO_ADDR
// vc_chassis := chassis ;
104723: LD_ADDR_OWVAR 37
104727: PUSH
104728: LD_VAR 0 1
104732: ST_TO_ADDR
// vc_engine := engine ;
104733: LD_ADDR_OWVAR 39
104737: PUSH
104738: LD_VAR 0 2
104742: ST_TO_ADDR
// vc_control := control ;
104743: LD_ADDR_OWVAR 38
104747: PUSH
104748: LD_VAR 0 3
104752: ST_TO_ADDR
// vc_weapon := weapon ;
104753: LD_ADDR_OWVAR 40
104757: PUSH
104758: LD_VAR 0 4
104762: ST_TO_ADDR
// un := CreateVehicle ;
104763: LD_ADDR_VAR 0 8
104767: PUSH
104768: CALL_OW 45
104772: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
104773: LD_VAR 0 8
104777: PPUSH
104778: LD_INT 0
104780: PPUSH
104781: LD_INT 5
104783: PPUSH
104784: CALL_OW 12
104788: PPUSH
104789: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
104793: LD_VAR 0 8
104797: PPUSH
104798: LD_VAR 0 5
104802: PPUSH
104803: LD_VAR 0 6
104807: PPUSH
104808: LD_INT 1
104810: PPUSH
104811: CALL_OW 48
// end ;
104815: LD_VAR 0 7
104819: RET
// export hInvincible ; every 1 do
104820: GO 104822
104822: DISABLE
// hInvincible := [ ] ;
104823: LD_ADDR_EXP 166
104827: PUSH
104828: EMPTY
104829: ST_TO_ADDR
104830: END
// every 10 do var i ;
104831: GO 104833
104833: DISABLE
104834: LD_INT 0
104836: PPUSH
// begin enable ;
104837: ENABLE
// if not hInvincible then
104838: LD_EXP 166
104842: NOT
104843: IFFALSE 104847
// exit ;
104845: GO 104891
// for i in hInvincible do
104847: LD_ADDR_VAR 0 1
104851: PUSH
104852: LD_EXP 166
104856: PUSH
104857: FOR_IN
104858: IFFALSE 104889
// if GetLives ( i ) < 1000 then
104860: LD_VAR 0 1
104864: PPUSH
104865: CALL_OW 256
104869: PUSH
104870: LD_INT 1000
104872: LESS
104873: IFFALSE 104887
// SetLives ( i , 1000 ) ;
104875: LD_VAR 0 1
104879: PPUSH
104880: LD_INT 1000
104882: PPUSH
104883: CALL_OW 234
104887: GO 104857
104889: POP
104890: POP
// end ;
104891: PPOPN 1
104893: END
// export function hHackInvincible ; var i ; begin
104894: LD_INT 0
104896: PPUSH
104897: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
104898: LD_ADDR_VAR 0 2
104902: PUSH
104903: LD_INT 2
104905: PUSH
104906: LD_INT 21
104908: PUSH
104909: LD_INT 1
104911: PUSH
104912: EMPTY
104913: LIST
104914: LIST
104915: PUSH
104916: LD_INT 21
104918: PUSH
104919: LD_INT 2
104921: PUSH
104922: EMPTY
104923: LIST
104924: LIST
104925: PUSH
104926: EMPTY
104927: LIST
104928: LIST
104929: LIST
104930: PPUSH
104931: CALL_OW 69
104935: PUSH
104936: FOR_IN
104937: IFFALSE 104998
// if IsSelected ( i ) then
104939: LD_VAR 0 2
104943: PPUSH
104944: CALL_OW 306
104948: IFFALSE 104996
// begin if i in hInvincible then
104950: LD_VAR 0 2
104954: PUSH
104955: LD_EXP 166
104959: IN
104960: IFFALSE 104980
// hInvincible := hInvincible diff i else
104962: LD_ADDR_EXP 166
104966: PUSH
104967: LD_EXP 166
104971: PUSH
104972: LD_VAR 0 2
104976: DIFF
104977: ST_TO_ADDR
104978: GO 104996
// hInvincible := hInvincible union i ;
104980: LD_ADDR_EXP 166
104984: PUSH
104985: LD_EXP 166
104989: PUSH
104990: LD_VAR 0 2
104994: UNION
104995: ST_TO_ADDR
// end ;
104996: GO 104936
104998: POP
104999: POP
// end ;
105000: LD_VAR 0 1
105004: RET
// export function hHackInvisible ; var i , j ; begin
105005: LD_INT 0
105007: PPUSH
105008: PPUSH
105009: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105010: LD_ADDR_VAR 0 2
105014: PUSH
105015: LD_INT 21
105017: PUSH
105018: LD_INT 1
105020: PUSH
105021: EMPTY
105022: LIST
105023: LIST
105024: PPUSH
105025: CALL_OW 69
105029: PUSH
105030: FOR_IN
105031: IFFALSE 105055
// if IsSelected ( i ) then
105033: LD_VAR 0 2
105037: PPUSH
105038: CALL_OW 306
105042: IFFALSE 105053
// ComForceInvisible ( i ) ;
105044: LD_VAR 0 2
105048: PPUSH
105049: CALL_OW 496
105053: GO 105030
105055: POP
105056: POP
// end ;
105057: LD_VAR 0 1
105061: RET
// export function hHackChangeYourSide ; begin
105062: LD_INT 0
105064: PPUSH
// if your_side = 8 then
105065: LD_OWVAR 2
105069: PUSH
105070: LD_INT 8
105072: EQUAL
105073: IFFALSE 105085
// your_side := 0 else
105075: LD_ADDR_OWVAR 2
105079: PUSH
105080: LD_INT 0
105082: ST_TO_ADDR
105083: GO 105099
// your_side := your_side + 1 ;
105085: LD_ADDR_OWVAR 2
105089: PUSH
105090: LD_OWVAR 2
105094: PUSH
105095: LD_INT 1
105097: PLUS
105098: ST_TO_ADDR
// end ;
105099: LD_VAR 0 1
105103: RET
// export function hHackChangeUnitSide ; var i , j ; begin
105104: LD_INT 0
105106: PPUSH
105107: PPUSH
105108: PPUSH
// for i in all_units do
105109: LD_ADDR_VAR 0 2
105113: PUSH
105114: LD_OWVAR 3
105118: PUSH
105119: FOR_IN
105120: IFFALSE 105198
// if IsSelected ( i ) then
105122: LD_VAR 0 2
105126: PPUSH
105127: CALL_OW 306
105131: IFFALSE 105196
// begin j := GetSide ( i ) ;
105133: LD_ADDR_VAR 0 3
105137: PUSH
105138: LD_VAR 0 2
105142: PPUSH
105143: CALL_OW 255
105147: ST_TO_ADDR
// if j = 8 then
105148: LD_VAR 0 3
105152: PUSH
105153: LD_INT 8
105155: EQUAL
105156: IFFALSE 105168
// j := 0 else
105158: LD_ADDR_VAR 0 3
105162: PUSH
105163: LD_INT 0
105165: ST_TO_ADDR
105166: GO 105182
// j := j + 1 ;
105168: LD_ADDR_VAR 0 3
105172: PUSH
105173: LD_VAR 0 3
105177: PUSH
105178: LD_INT 1
105180: PLUS
105181: ST_TO_ADDR
// SetSide ( i , j ) ;
105182: LD_VAR 0 2
105186: PPUSH
105187: LD_VAR 0 3
105191: PPUSH
105192: CALL_OW 235
// end ;
105196: GO 105119
105198: POP
105199: POP
// end ;
105200: LD_VAR 0 1
105204: RET
// export function hHackFog ; begin
105205: LD_INT 0
105207: PPUSH
// FogOff ( true ) ;
105208: LD_INT 1
105210: PPUSH
105211: CALL_OW 344
// end ;
105215: LD_VAR 0 1
105219: RET
// export function hHackTeleport ( unit , x , y ) ; begin
105220: LD_INT 0
105222: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
105223: LD_VAR 0 1
105227: PPUSH
105228: LD_VAR 0 2
105232: PPUSH
105233: LD_VAR 0 3
105237: PPUSH
105238: LD_INT 1
105240: PPUSH
105241: LD_INT 1
105243: PPUSH
105244: CALL_OW 483
// CenterOnXY ( x , y ) ;
105248: LD_VAR 0 2
105252: PPUSH
105253: LD_VAR 0 3
105257: PPUSH
105258: CALL_OW 84
// end ;
105262: LD_VAR 0 4
105266: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
105267: LD_INT 0
105269: PPUSH
105270: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
105271: LD_VAR 0 1
105275: NOT
105276: PUSH
105277: LD_VAR 0 2
105281: PPUSH
105282: LD_VAR 0 3
105286: PPUSH
105287: CALL_OW 488
105291: NOT
105292: OR
105293: PUSH
105294: LD_VAR 0 1
105298: PPUSH
105299: CALL_OW 266
105303: PUSH
105304: LD_INT 3
105306: NONEQUAL
105307: PUSH
105308: LD_VAR 0 1
105312: PPUSH
105313: CALL_OW 247
105317: PUSH
105318: LD_INT 1
105320: EQUAL
105321: NOT
105322: AND
105323: OR
105324: IFFALSE 105328
// exit ;
105326: GO 105477
// if GetType ( factory ) = unit_human then
105328: LD_VAR 0 1
105332: PPUSH
105333: CALL_OW 247
105337: PUSH
105338: LD_INT 1
105340: EQUAL
105341: IFFALSE 105358
// factory := IsInUnit ( factory ) ;
105343: LD_ADDR_VAR 0 1
105347: PUSH
105348: LD_VAR 0 1
105352: PPUSH
105353: CALL_OW 310
105357: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
105358: LD_VAR 0 1
105362: PPUSH
105363: CALL_OW 266
105367: PUSH
105368: LD_INT 3
105370: NONEQUAL
105371: IFFALSE 105375
// exit ;
105373: GO 105477
// if HexInfo ( x , y ) = factory then
105375: LD_VAR 0 2
105379: PPUSH
105380: LD_VAR 0 3
105384: PPUSH
105385: CALL_OW 428
105389: PUSH
105390: LD_VAR 0 1
105394: EQUAL
105395: IFFALSE 105422
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
105397: LD_ADDR_EXP 167
105401: PUSH
105402: LD_EXP 167
105406: PPUSH
105407: LD_VAR 0 1
105411: PPUSH
105412: LD_INT 0
105414: PPUSH
105415: CALL_OW 1
105419: ST_TO_ADDR
105420: GO 105473
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
105422: LD_ADDR_EXP 167
105426: PUSH
105427: LD_EXP 167
105431: PPUSH
105432: LD_VAR 0 1
105436: PPUSH
105437: LD_VAR 0 1
105441: PPUSH
105442: CALL_OW 255
105446: PUSH
105447: LD_VAR 0 1
105451: PUSH
105452: LD_VAR 0 2
105456: PUSH
105457: LD_VAR 0 3
105461: PUSH
105462: EMPTY
105463: LIST
105464: LIST
105465: LIST
105466: LIST
105467: PPUSH
105468: CALL_OW 1
105472: ST_TO_ADDR
// UpdateFactoryWaypoints ;
105473: CALL 105482 0 0
// end ;
105477: LD_VAR 0 4
105481: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
105482: LD_INT 0
105484: PPUSH
105485: PPUSH
105486: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
105487: LD_STRING resetFactoryWaypoint();
105489: PPUSH
105490: CALL_OW 559
// if factoryWaypoints then
105494: LD_EXP 167
105498: IFFALSE 105624
// begin list := PrepareArray ( factoryWaypoints ) ;
105500: LD_ADDR_VAR 0 3
105504: PUSH
105505: LD_EXP 167
105509: PPUSH
105510: CALL 58729 0 1
105514: ST_TO_ADDR
// for i := 1 to list do
105515: LD_ADDR_VAR 0 2
105519: PUSH
105520: DOUBLE
105521: LD_INT 1
105523: DEC
105524: ST_TO_ADDR
105525: LD_VAR 0 3
105529: PUSH
105530: FOR_TO
105531: IFFALSE 105622
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
105533: LD_STRING setFactoryWaypointXY(
105535: PUSH
105536: LD_VAR 0 3
105540: PUSH
105541: LD_VAR 0 2
105545: ARRAY
105546: PUSH
105547: LD_INT 1
105549: ARRAY
105550: STR
105551: PUSH
105552: LD_STRING ,
105554: STR
105555: PUSH
105556: LD_VAR 0 3
105560: PUSH
105561: LD_VAR 0 2
105565: ARRAY
105566: PUSH
105567: LD_INT 2
105569: ARRAY
105570: STR
105571: PUSH
105572: LD_STRING ,
105574: STR
105575: PUSH
105576: LD_VAR 0 3
105580: PUSH
105581: LD_VAR 0 2
105585: ARRAY
105586: PUSH
105587: LD_INT 3
105589: ARRAY
105590: STR
105591: PUSH
105592: LD_STRING ,
105594: STR
105595: PUSH
105596: LD_VAR 0 3
105600: PUSH
105601: LD_VAR 0 2
105605: ARRAY
105606: PUSH
105607: LD_INT 4
105609: ARRAY
105610: STR
105611: PUSH
105612: LD_STRING )
105614: STR
105615: PPUSH
105616: CALL_OW 559
105620: GO 105530
105622: POP
105623: POP
// end ; end ;
105624: LD_VAR 0 1
105628: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
105629: LD_INT 0
105631: PPUSH
// if HexInfo ( x , y ) = warehouse then
105632: LD_VAR 0 2
105636: PPUSH
105637: LD_VAR 0 3
105641: PPUSH
105642: CALL_OW 428
105646: PUSH
105647: LD_VAR 0 1
105651: EQUAL
105652: IFFALSE 105679
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
105654: LD_ADDR_EXP 168
105658: PUSH
105659: LD_EXP 168
105663: PPUSH
105664: LD_VAR 0 1
105668: PPUSH
105669: LD_INT 0
105671: PPUSH
105672: CALL_OW 1
105676: ST_TO_ADDR
105677: GO 105730
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
105679: LD_ADDR_EXP 168
105683: PUSH
105684: LD_EXP 168
105688: PPUSH
105689: LD_VAR 0 1
105693: PPUSH
105694: LD_VAR 0 1
105698: PPUSH
105699: CALL_OW 255
105703: PUSH
105704: LD_VAR 0 1
105708: PUSH
105709: LD_VAR 0 2
105713: PUSH
105714: LD_VAR 0 3
105718: PUSH
105719: EMPTY
105720: LIST
105721: LIST
105722: LIST
105723: LIST
105724: PPUSH
105725: CALL_OW 1
105729: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
105730: CALL 105739 0 0
// end ;
105734: LD_VAR 0 4
105738: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
105739: LD_INT 0
105741: PPUSH
105742: PPUSH
105743: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
105744: LD_STRING resetWarehouseGatheringPoints();
105746: PPUSH
105747: CALL_OW 559
// if warehouseGatheringPoints then
105751: LD_EXP 168
105755: IFFALSE 105881
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
105757: LD_ADDR_VAR 0 3
105761: PUSH
105762: LD_EXP 168
105766: PPUSH
105767: CALL 58729 0 1
105771: ST_TO_ADDR
// for i := 1 to list do
105772: LD_ADDR_VAR 0 2
105776: PUSH
105777: DOUBLE
105778: LD_INT 1
105780: DEC
105781: ST_TO_ADDR
105782: LD_VAR 0 3
105786: PUSH
105787: FOR_TO
105788: IFFALSE 105879
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
105790: LD_STRING setWarehouseGatheringPointXY(
105792: PUSH
105793: LD_VAR 0 3
105797: PUSH
105798: LD_VAR 0 2
105802: ARRAY
105803: PUSH
105804: LD_INT 1
105806: ARRAY
105807: STR
105808: PUSH
105809: LD_STRING ,
105811: STR
105812: PUSH
105813: LD_VAR 0 3
105817: PUSH
105818: LD_VAR 0 2
105822: ARRAY
105823: PUSH
105824: LD_INT 2
105826: ARRAY
105827: STR
105828: PUSH
105829: LD_STRING ,
105831: STR
105832: PUSH
105833: LD_VAR 0 3
105837: PUSH
105838: LD_VAR 0 2
105842: ARRAY
105843: PUSH
105844: LD_INT 3
105846: ARRAY
105847: STR
105848: PUSH
105849: LD_STRING ,
105851: STR
105852: PUSH
105853: LD_VAR 0 3
105857: PUSH
105858: LD_VAR 0 2
105862: ARRAY
105863: PUSH
105864: LD_INT 4
105866: ARRAY
105867: STR
105868: PUSH
105869: LD_STRING )
105871: STR
105872: PPUSH
105873: CALL_OW 559
105877: GO 105787
105879: POP
105880: POP
// end ; end ;
105881: LD_VAR 0 1
105885: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
105886: LD_EXP 168
105890: IFFALSE 106575
105892: GO 105894
105894: DISABLE
105895: LD_INT 0
105897: PPUSH
105898: PPUSH
105899: PPUSH
105900: PPUSH
105901: PPUSH
105902: PPUSH
105903: PPUSH
105904: PPUSH
105905: PPUSH
// begin enable ;
105906: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
105907: LD_ADDR_VAR 0 3
105911: PUSH
105912: LD_EXP 168
105916: PPUSH
105917: CALL 58729 0 1
105921: ST_TO_ADDR
// if not list then
105922: LD_VAR 0 3
105926: NOT
105927: IFFALSE 105931
// exit ;
105929: GO 106575
// for i := 1 to list do
105931: LD_ADDR_VAR 0 1
105935: PUSH
105936: DOUBLE
105937: LD_INT 1
105939: DEC
105940: ST_TO_ADDR
105941: LD_VAR 0 3
105945: PUSH
105946: FOR_TO
105947: IFFALSE 106573
// begin depot := list [ i ] [ 2 ] ;
105949: LD_ADDR_VAR 0 8
105953: PUSH
105954: LD_VAR 0 3
105958: PUSH
105959: LD_VAR 0 1
105963: ARRAY
105964: PUSH
105965: LD_INT 2
105967: ARRAY
105968: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
105969: LD_ADDR_VAR 0 5
105973: PUSH
105974: LD_VAR 0 3
105978: PUSH
105979: LD_VAR 0 1
105983: ARRAY
105984: PUSH
105985: LD_INT 1
105987: ARRAY
105988: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
105989: LD_VAR 0 8
105993: PPUSH
105994: CALL_OW 301
105998: PUSH
105999: LD_VAR 0 5
106003: PUSH
106004: LD_VAR 0 8
106008: PPUSH
106009: CALL_OW 255
106013: NONEQUAL
106014: OR
106015: IFFALSE 106044
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
106017: LD_ADDR_EXP 168
106021: PUSH
106022: LD_EXP 168
106026: PPUSH
106027: LD_VAR 0 8
106031: PPUSH
106032: LD_INT 0
106034: PPUSH
106035: CALL_OW 1
106039: ST_TO_ADDR
// exit ;
106040: POP
106041: POP
106042: GO 106575
// end ; x := list [ i ] [ 3 ] ;
106044: LD_ADDR_VAR 0 6
106048: PUSH
106049: LD_VAR 0 3
106053: PUSH
106054: LD_VAR 0 1
106058: ARRAY
106059: PUSH
106060: LD_INT 3
106062: ARRAY
106063: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
106064: LD_ADDR_VAR 0 7
106068: PUSH
106069: LD_VAR 0 3
106073: PUSH
106074: LD_VAR 0 1
106078: ARRAY
106079: PUSH
106080: LD_INT 4
106082: ARRAY
106083: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
106084: LD_ADDR_VAR 0 9
106088: PUSH
106089: LD_VAR 0 6
106093: PPUSH
106094: LD_VAR 0 7
106098: PPUSH
106099: LD_INT 16
106101: PPUSH
106102: CALL 57313 0 3
106106: ST_TO_ADDR
// if not cratesNearbyPoint then
106107: LD_VAR 0 9
106111: NOT
106112: IFFALSE 106118
// exit ;
106114: POP
106115: POP
106116: GO 106575
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
106118: LD_ADDR_VAR 0 4
106122: PUSH
106123: LD_INT 22
106125: PUSH
106126: LD_VAR 0 5
106130: PUSH
106131: EMPTY
106132: LIST
106133: LIST
106134: PUSH
106135: LD_INT 3
106137: PUSH
106138: LD_INT 60
106140: PUSH
106141: EMPTY
106142: LIST
106143: PUSH
106144: EMPTY
106145: LIST
106146: LIST
106147: PUSH
106148: LD_INT 91
106150: PUSH
106151: LD_VAR 0 8
106155: PUSH
106156: LD_INT 6
106158: PUSH
106159: EMPTY
106160: LIST
106161: LIST
106162: LIST
106163: PUSH
106164: LD_INT 2
106166: PUSH
106167: LD_INT 25
106169: PUSH
106170: LD_INT 2
106172: PUSH
106173: EMPTY
106174: LIST
106175: LIST
106176: PUSH
106177: LD_INT 25
106179: PUSH
106180: LD_INT 16
106182: PUSH
106183: EMPTY
106184: LIST
106185: LIST
106186: PUSH
106187: EMPTY
106188: LIST
106189: LIST
106190: LIST
106191: PUSH
106192: EMPTY
106193: LIST
106194: LIST
106195: LIST
106196: LIST
106197: PPUSH
106198: CALL_OW 69
106202: PUSH
106203: LD_VAR 0 8
106207: PPUSH
106208: CALL_OW 313
106212: PPUSH
106213: LD_INT 3
106215: PUSH
106216: LD_INT 60
106218: PUSH
106219: EMPTY
106220: LIST
106221: PUSH
106222: EMPTY
106223: LIST
106224: LIST
106225: PUSH
106226: LD_INT 2
106228: PUSH
106229: LD_INT 25
106231: PUSH
106232: LD_INT 2
106234: PUSH
106235: EMPTY
106236: LIST
106237: LIST
106238: PUSH
106239: LD_INT 25
106241: PUSH
106242: LD_INT 16
106244: PUSH
106245: EMPTY
106246: LIST
106247: LIST
106248: PUSH
106249: EMPTY
106250: LIST
106251: LIST
106252: LIST
106253: PUSH
106254: EMPTY
106255: LIST
106256: LIST
106257: PPUSH
106258: CALL_OW 72
106262: UNION
106263: ST_TO_ADDR
// if tmp then
106264: LD_VAR 0 4
106268: IFFALSE 106348
// begin tmp := ShrinkArray ( tmp , 3 ) ;
106270: LD_ADDR_VAR 0 4
106274: PUSH
106275: LD_VAR 0 4
106279: PPUSH
106280: LD_INT 3
106282: PPUSH
106283: CALL 55282 0 2
106287: ST_TO_ADDR
// for j in tmp do
106288: LD_ADDR_VAR 0 2
106292: PUSH
106293: LD_VAR 0 4
106297: PUSH
106298: FOR_IN
106299: IFFALSE 106342
// begin if IsInUnit ( j ) then
106301: LD_VAR 0 2
106305: PPUSH
106306: CALL_OW 310
106310: IFFALSE 106321
// ComExit ( j ) ;
106312: LD_VAR 0 2
106316: PPUSH
106317: CALL 55365 0 1
// AddComCollect ( j , x , y ) ;
106321: LD_VAR 0 2
106325: PPUSH
106326: LD_VAR 0 6
106330: PPUSH
106331: LD_VAR 0 7
106335: PPUSH
106336: CALL_OW 177
// end ;
106340: GO 106298
106342: POP
106343: POP
// exit ;
106344: POP
106345: POP
106346: GO 106575
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
106348: LD_ADDR_VAR 0 4
106352: PUSH
106353: LD_INT 22
106355: PUSH
106356: LD_VAR 0 5
106360: PUSH
106361: EMPTY
106362: LIST
106363: LIST
106364: PUSH
106365: LD_INT 91
106367: PUSH
106368: LD_VAR 0 8
106372: PUSH
106373: LD_INT 8
106375: PUSH
106376: EMPTY
106377: LIST
106378: LIST
106379: LIST
106380: PUSH
106381: LD_INT 2
106383: PUSH
106384: LD_INT 34
106386: PUSH
106387: LD_INT 12
106389: PUSH
106390: EMPTY
106391: LIST
106392: LIST
106393: PUSH
106394: LD_INT 34
106396: PUSH
106397: LD_INT 51
106399: PUSH
106400: EMPTY
106401: LIST
106402: LIST
106403: PUSH
106404: LD_INT 34
106406: PUSH
106407: LD_INT 32
106409: PUSH
106410: EMPTY
106411: LIST
106412: LIST
106413: PUSH
106414: LD_INT 34
106416: PUSH
106417: LD_INT 89
106419: PUSH
106420: EMPTY
106421: LIST
106422: LIST
106423: PUSH
106424: EMPTY
106425: LIST
106426: LIST
106427: LIST
106428: LIST
106429: LIST
106430: PUSH
106431: EMPTY
106432: LIST
106433: LIST
106434: LIST
106435: PPUSH
106436: CALL_OW 69
106440: ST_TO_ADDR
// if tmp then
106441: LD_VAR 0 4
106445: IFFALSE 106571
// begin for j in tmp do
106447: LD_ADDR_VAR 0 2
106451: PUSH
106452: LD_VAR 0 4
106456: PUSH
106457: FOR_IN
106458: IFFALSE 106569
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
106460: LD_VAR 0 2
106464: PPUSH
106465: CALL_OW 262
106469: PUSH
106470: LD_INT 3
106472: EQUAL
106473: PUSH
106474: LD_VAR 0 2
106478: PPUSH
106479: CALL_OW 261
106483: PUSH
106484: LD_INT 20
106486: GREATER
106487: OR
106488: PUSH
106489: LD_VAR 0 2
106493: PPUSH
106494: CALL_OW 314
106498: NOT
106499: AND
106500: PUSH
106501: LD_VAR 0 2
106505: PPUSH
106506: CALL_OW 263
106510: PUSH
106511: LD_INT 1
106513: NONEQUAL
106514: PUSH
106515: LD_VAR 0 2
106519: PPUSH
106520: CALL_OW 311
106524: OR
106525: AND
106526: IFFALSE 106567
// begin ComCollect ( j , x , y ) ;
106528: LD_VAR 0 2
106532: PPUSH
106533: LD_VAR 0 6
106537: PPUSH
106538: LD_VAR 0 7
106542: PPUSH
106543: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
106547: LD_VAR 0 2
106551: PPUSH
106552: LD_VAR 0 8
106556: PPUSH
106557: CALL_OW 172
// exit ;
106561: POP
106562: POP
106563: POP
106564: POP
106565: GO 106575
// end ;
106567: GO 106457
106569: POP
106570: POP
// end ; end ;
106571: GO 105946
106573: POP
106574: POP
// end ; end_of_file
106575: PPOPN 9
106577: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
106578: LD_INT 0
106580: PPUSH
106581: PPUSH
106582: PPUSH
106583: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
106584: LD_VAR 0 1
106588: PPUSH
106589: CALL_OW 264
106593: PUSH
106594: LD_INT 91
106596: EQUAL
106597: IFFALSE 106669
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
106599: LD_INT 68
106601: PPUSH
106602: LD_VAR 0 1
106606: PPUSH
106607: CALL_OW 255
106611: PPUSH
106612: CALL_OW 321
106616: PUSH
106617: LD_INT 2
106619: EQUAL
106620: IFFALSE 106632
// eff := 70 else
106622: LD_ADDR_VAR 0 4
106626: PUSH
106627: LD_INT 70
106629: ST_TO_ADDR
106630: GO 106640
// eff := 30 ;
106632: LD_ADDR_VAR 0 4
106636: PUSH
106637: LD_INT 30
106639: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
106640: LD_VAR 0 1
106644: PPUSH
106645: CALL_OW 250
106649: PPUSH
106650: LD_VAR 0 1
106654: PPUSH
106655: CALL_OW 251
106659: PPUSH
106660: LD_VAR 0 4
106664: PPUSH
106665: CALL_OW 495
// end ; end ;
106669: LD_VAR 0 2
106673: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
106674: LD_INT 0
106676: PPUSH
// end ;
106677: LD_VAR 0 4
106681: RET
// export function SOS_Command ( cmd ) ; begin
106682: LD_INT 0
106684: PPUSH
// end ;
106685: LD_VAR 0 2
106689: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
106690: LD_INT 0
106692: PPUSH
// end ;
106693: LD_VAR 0 6
106697: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var tag , driver ; begin
106698: LD_INT 0
106700: PPUSH
106701: PPUSH
106702: PPUSH
// if not vehicle or not factory then
106703: LD_VAR 0 1
106707: NOT
106708: PUSH
106709: LD_VAR 0 2
106713: NOT
106714: OR
106715: IFFALSE 106719
// exit ;
106717: GO 107022
// if factoryWaypoints >= factory then
106719: LD_EXP 167
106723: PUSH
106724: LD_VAR 0 2
106728: GREATEREQUAL
106729: IFFALSE 107022
// if factoryWaypoints [ factory ] then
106731: LD_EXP 167
106735: PUSH
106736: LD_VAR 0 2
106740: ARRAY
106741: IFFALSE 107022
// begin if GetControl ( vehicle ) = control_manual then
106743: LD_VAR 0 1
106747: PPUSH
106748: CALL_OW 263
106752: PUSH
106753: LD_INT 1
106755: EQUAL
106756: IFFALSE 106909
// begin driver := IsDrivenBy ( vehicle ) ;
106758: LD_ADDR_VAR 0 5
106762: PUSH
106763: LD_VAR 0 1
106767: PPUSH
106768: CALL_OW 311
106772: ST_TO_ADDR
// tag := GetTag ( driver ) ;
106773: LD_ADDR_VAR 0 4
106777: PUSH
106778: LD_VAR 0 5
106782: PPUSH
106783: CALL_OW 110
106787: ST_TO_ADDR
// if tag = tDriver then
106788: LD_VAR 0 4
106792: PUSH
106793: LD_INT 501
106795: EQUAL
106796: IFFALSE 106800
// exit ;
106798: GO 107022
// if not HasTask ( driver ) then
106800: LD_VAR 0 5
106804: PPUSH
106805: CALL_OW 314
106809: NOT
106810: IFFALSE 106907
// begin SetTag ( driver , tDriver ) ;
106812: LD_VAR 0 5
106816: PPUSH
106817: LD_INT 501
106819: PPUSH
106820: CALL_OW 109
// ComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106824: LD_VAR 0 5
106828: PPUSH
106829: LD_EXP 167
106833: PUSH
106834: LD_VAR 0 2
106838: ARRAY
106839: PUSH
106840: LD_INT 3
106842: ARRAY
106843: PPUSH
106844: LD_EXP 167
106848: PUSH
106849: LD_VAR 0 2
106853: ARRAY
106854: PUSH
106855: LD_INT 4
106857: ARRAY
106858: PPUSH
106859: CALL_OW 111
// AddComExitVehicle ( driver ) ;
106863: LD_VAR 0 5
106867: PPUSH
106868: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
106872: LD_VAR 0 5
106876: PPUSH
106877: LD_VAR 0 2
106881: PPUSH
106882: CALL_OW 180
// wait ( 0 0$1 ) ;
106886: LD_INT 35
106888: PPUSH
106889: CALL_OW 67
// SetTag ( driver , tag ) ;
106893: LD_VAR 0 5
106897: PPUSH
106898: LD_VAR 0 4
106902: PPUSH
106903: CALL_OW 109
// end ; end else
106907: GO 107022
// if GetControl ( vehicle ) = control_remote then
106909: LD_VAR 0 1
106913: PPUSH
106914: CALL_OW 263
106918: PUSH
106919: LD_INT 2
106921: EQUAL
106922: IFFALSE 106983
// begin wait ( 0 0$2 ) ;
106924: LD_INT 70
106926: PPUSH
106927: CALL_OW 67
// if Connect ( vehicle ) then
106931: LD_VAR 0 1
106935: PPUSH
106936: CALL 25584 0 1
106940: IFFALSE 106981
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106942: LD_VAR 0 1
106946: PPUSH
106947: LD_EXP 167
106951: PUSH
106952: LD_VAR 0 2
106956: ARRAY
106957: PUSH
106958: LD_INT 3
106960: ARRAY
106961: PPUSH
106962: LD_EXP 167
106966: PUSH
106967: LD_VAR 0 2
106971: ARRAY
106972: PUSH
106973: LD_INT 4
106975: ARRAY
106976: PPUSH
106977: CALL_OW 171
// end else
106981: GO 107022
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106983: LD_VAR 0 1
106987: PPUSH
106988: LD_EXP 167
106992: PUSH
106993: LD_VAR 0 2
106997: ARRAY
106998: PUSH
106999: LD_INT 3
107001: ARRAY
107002: PPUSH
107003: LD_EXP 167
107007: PUSH
107008: LD_VAR 0 2
107012: ARRAY
107013: PUSH
107014: LD_INT 4
107016: ARRAY
107017: PPUSH
107018: CALL_OW 171
// end ; end ;
107022: LD_VAR 0 3
107026: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
107027: LD_INT 0
107029: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
107030: LD_VAR 0 1
107034: PUSH
107035: LD_INT 250
107037: EQUAL
107038: PUSH
107039: LD_VAR 0 2
107043: PPUSH
107044: CALL_OW 264
107048: PUSH
107049: LD_INT 81
107051: EQUAL
107052: AND
107053: IFFALSE 107074
// MinerPlaceMine ( unit , x , y ) ;
107055: LD_VAR 0 2
107059: PPUSH
107060: LD_VAR 0 4
107064: PPUSH
107065: LD_VAR 0 5
107069: PPUSH
107070: CALL 110064 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
107074: LD_VAR 0 1
107078: PUSH
107079: LD_INT 251
107081: EQUAL
107082: PUSH
107083: LD_VAR 0 2
107087: PPUSH
107088: CALL_OW 264
107092: PUSH
107093: LD_INT 81
107095: EQUAL
107096: AND
107097: IFFALSE 107118
// MinerDetonateMine ( unit , x , y ) ;
107099: LD_VAR 0 2
107103: PPUSH
107104: LD_VAR 0 4
107108: PPUSH
107109: LD_VAR 0 5
107113: PPUSH
107114: CALL 110339 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
107118: LD_VAR 0 1
107122: PUSH
107123: LD_INT 252
107125: EQUAL
107126: PUSH
107127: LD_VAR 0 2
107131: PPUSH
107132: CALL_OW 264
107136: PUSH
107137: LD_INT 81
107139: EQUAL
107140: AND
107141: IFFALSE 107162
// MinerCreateMinefield ( unit , x , y ) ;
107143: LD_VAR 0 2
107147: PPUSH
107148: LD_VAR 0 4
107152: PPUSH
107153: LD_VAR 0 5
107157: PPUSH
107158: CALL 110756 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
107162: LD_VAR 0 1
107166: PUSH
107167: LD_INT 253
107169: EQUAL
107170: PUSH
107171: LD_VAR 0 2
107175: PPUSH
107176: CALL_OW 257
107180: PUSH
107181: LD_INT 5
107183: EQUAL
107184: AND
107185: IFFALSE 107206
// ComBinocular ( unit , x , y ) ;
107187: LD_VAR 0 2
107191: PPUSH
107192: LD_VAR 0 4
107196: PPUSH
107197: LD_VAR 0 5
107201: PPUSH
107202: CALL 111125 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
107206: LD_VAR 0 1
107210: PUSH
107211: LD_INT 254
107213: EQUAL
107214: PUSH
107215: LD_VAR 0 2
107219: PPUSH
107220: CALL_OW 264
107224: PUSH
107225: LD_INT 99
107227: EQUAL
107228: AND
107229: PUSH
107230: LD_VAR 0 3
107234: PPUSH
107235: CALL_OW 263
107239: PUSH
107240: LD_INT 3
107242: EQUAL
107243: AND
107244: IFFALSE 107260
// HackDestroyVehicle ( unit , selectedUnit ) ;
107246: LD_VAR 0 2
107250: PPUSH
107251: LD_VAR 0 3
107255: PPUSH
107256: CALL 109428 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
107260: LD_VAR 0 1
107264: PUSH
107265: LD_INT 255
107267: EQUAL
107268: PUSH
107269: LD_VAR 0 2
107273: PPUSH
107274: CALL_OW 264
107278: PUSH
107279: LD_INT 14
107281: PUSH
107282: LD_INT 53
107284: PUSH
107285: EMPTY
107286: LIST
107287: LIST
107288: IN
107289: AND
107290: PUSH
107291: LD_VAR 0 4
107295: PPUSH
107296: LD_VAR 0 5
107300: PPUSH
107301: CALL_OW 488
107305: AND
107306: IFFALSE 107330
// CutTreeXYR ( unit , x , y , 12 ) ;
107308: LD_VAR 0 2
107312: PPUSH
107313: LD_VAR 0 4
107317: PPUSH
107318: LD_VAR 0 5
107322: PPUSH
107323: LD_INT 12
107325: PPUSH
107326: CALL 107425 0 4
// if cmd = 256 then
107330: LD_VAR 0 1
107334: PUSH
107335: LD_INT 256
107337: EQUAL
107338: IFFALSE 107359
// SetFactoryWaypoint ( unit , x , y ) ;
107340: LD_VAR 0 2
107344: PPUSH
107345: LD_VAR 0 4
107349: PPUSH
107350: LD_VAR 0 5
107354: PPUSH
107355: CALL 105267 0 3
// if cmd = 257 then
107359: LD_VAR 0 1
107363: PUSH
107364: LD_INT 257
107366: EQUAL
107367: IFFALSE 107388
// SetWarehouseGatheringPoint ( unit , x , y ) ;
107369: LD_VAR 0 2
107373: PPUSH
107374: LD_VAR 0 4
107378: PPUSH
107379: LD_VAR 0 5
107383: PPUSH
107384: CALL 105629 0 3
// if cmd = 258 then
107388: LD_VAR 0 1
107392: PUSH
107393: LD_INT 258
107395: EQUAL
107396: IFFALSE 107420
// BurnTreeXYR ( unit , x , y , 8 ) ;
107398: LD_VAR 0 2
107402: PPUSH
107403: LD_VAR 0 4
107407: PPUSH
107408: LD_VAR 0 5
107412: PPUSH
107413: LD_INT 8
107415: PPUSH
107416: CALL 107819 0 4
// end ;
107420: LD_VAR 0 6
107424: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107425: LD_INT 0
107427: PPUSH
107428: PPUSH
107429: PPUSH
107430: PPUSH
107431: PPUSH
107432: PPUSH
107433: PPUSH
107434: PPUSH
107435: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
107436: LD_VAR 0 1
107440: PPUSH
107441: CALL_OW 302
107445: NOT
107446: PUSH
107447: LD_VAR 0 2
107451: PPUSH
107452: LD_VAR 0 3
107456: PPUSH
107457: CALL_OW 488
107461: NOT
107462: OR
107463: PUSH
107464: LD_VAR 0 4
107468: NOT
107469: OR
107470: IFFALSE 107474
// exit ;
107472: GO 107814
// list := [ ] ;
107474: LD_ADDR_VAR 0 13
107478: PUSH
107479: EMPTY
107480: ST_TO_ADDR
// if x - r < 0 then
107481: LD_VAR 0 2
107485: PUSH
107486: LD_VAR 0 4
107490: MINUS
107491: PUSH
107492: LD_INT 0
107494: LESS
107495: IFFALSE 107507
// min_x := 0 else
107497: LD_ADDR_VAR 0 7
107501: PUSH
107502: LD_INT 0
107504: ST_TO_ADDR
107505: GO 107523
// min_x := x - r ;
107507: LD_ADDR_VAR 0 7
107511: PUSH
107512: LD_VAR 0 2
107516: PUSH
107517: LD_VAR 0 4
107521: MINUS
107522: ST_TO_ADDR
// if y - r < 0 then
107523: LD_VAR 0 3
107527: PUSH
107528: LD_VAR 0 4
107532: MINUS
107533: PUSH
107534: LD_INT 0
107536: LESS
107537: IFFALSE 107549
// min_y := 0 else
107539: LD_ADDR_VAR 0 8
107543: PUSH
107544: LD_INT 0
107546: ST_TO_ADDR
107547: GO 107565
// min_y := y - r ;
107549: LD_ADDR_VAR 0 8
107553: PUSH
107554: LD_VAR 0 3
107558: PUSH
107559: LD_VAR 0 4
107563: MINUS
107564: ST_TO_ADDR
// max_x := x + r ;
107565: LD_ADDR_VAR 0 9
107569: PUSH
107570: LD_VAR 0 2
107574: PUSH
107575: LD_VAR 0 4
107579: PLUS
107580: ST_TO_ADDR
// max_y := y + r ;
107581: LD_ADDR_VAR 0 10
107585: PUSH
107586: LD_VAR 0 3
107590: PUSH
107591: LD_VAR 0 4
107595: PLUS
107596: ST_TO_ADDR
// for _x = min_x to max_x do
107597: LD_ADDR_VAR 0 11
107601: PUSH
107602: DOUBLE
107603: LD_VAR 0 7
107607: DEC
107608: ST_TO_ADDR
107609: LD_VAR 0 9
107613: PUSH
107614: FOR_TO
107615: IFFALSE 107732
// for _y = min_y to max_y do
107617: LD_ADDR_VAR 0 12
107621: PUSH
107622: DOUBLE
107623: LD_VAR 0 8
107627: DEC
107628: ST_TO_ADDR
107629: LD_VAR 0 10
107633: PUSH
107634: FOR_TO
107635: IFFALSE 107728
// begin if not ValidHex ( _x , _y ) then
107637: LD_VAR 0 11
107641: PPUSH
107642: LD_VAR 0 12
107646: PPUSH
107647: CALL_OW 488
107651: NOT
107652: IFFALSE 107656
// continue ;
107654: GO 107634
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
107656: LD_VAR 0 11
107660: PPUSH
107661: LD_VAR 0 12
107665: PPUSH
107666: CALL_OW 351
107670: PUSH
107671: LD_VAR 0 11
107675: PPUSH
107676: LD_VAR 0 12
107680: PPUSH
107681: CALL_OW 554
107685: AND
107686: IFFALSE 107726
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
107688: LD_ADDR_VAR 0 13
107692: PUSH
107693: LD_VAR 0 13
107697: PPUSH
107698: LD_VAR 0 13
107702: PUSH
107703: LD_INT 1
107705: PLUS
107706: PPUSH
107707: LD_VAR 0 11
107711: PUSH
107712: LD_VAR 0 12
107716: PUSH
107717: EMPTY
107718: LIST
107719: LIST
107720: PPUSH
107721: CALL_OW 2
107725: ST_TO_ADDR
// end ;
107726: GO 107634
107728: POP
107729: POP
107730: GO 107614
107732: POP
107733: POP
// if not list then
107734: LD_VAR 0 13
107738: NOT
107739: IFFALSE 107743
// exit ;
107741: GO 107814
// for i in list do
107743: LD_ADDR_VAR 0 6
107747: PUSH
107748: LD_VAR 0 13
107752: PUSH
107753: FOR_IN
107754: IFFALSE 107812
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
107756: LD_VAR 0 1
107760: PPUSH
107761: LD_STRING M
107763: PUSH
107764: LD_VAR 0 6
107768: PUSH
107769: LD_INT 1
107771: ARRAY
107772: PUSH
107773: LD_VAR 0 6
107777: PUSH
107778: LD_INT 2
107780: ARRAY
107781: PUSH
107782: LD_INT 0
107784: PUSH
107785: LD_INT 0
107787: PUSH
107788: LD_INT 0
107790: PUSH
107791: LD_INT 0
107793: PUSH
107794: EMPTY
107795: LIST
107796: LIST
107797: LIST
107798: LIST
107799: LIST
107800: LIST
107801: LIST
107802: PUSH
107803: EMPTY
107804: LIST
107805: PPUSH
107806: CALL_OW 447
107810: GO 107753
107812: POP
107813: POP
// end ;
107814: LD_VAR 0 5
107818: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
107819: LD_INT 0
107821: PPUSH
107822: PPUSH
107823: PPUSH
107824: PPUSH
107825: PPUSH
107826: PPUSH
107827: PPUSH
107828: PPUSH
107829: PPUSH
107830: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
107831: LD_VAR 0 1
107835: PPUSH
107836: CALL_OW 302
107840: NOT
107841: PUSH
107842: LD_VAR 0 2
107846: PPUSH
107847: LD_VAR 0 3
107851: PPUSH
107852: CALL_OW 488
107856: NOT
107857: OR
107858: PUSH
107859: LD_VAR 0 4
107863: NOT
107864: OR
107865: IFFALSE 107869
// exit ;
107867: GO 108382
// list := [ ] ;
107869: LD_ADDR_VAR 0 13
107873: PUSH
107874: EMPTY
107875: ST_TO_ADDR
// if x - r < 0 then
107876: LD_VAR 0 2
107880: PUSH
107881: LD_VAR 0 4
107885: MINUS
107886: PUSH
107887: LD_INT 0
107889: LESS
107890: IFFALSE 107902
// min_x := 0 else
107892: LD_ADDR_VAR 0 7
107896: PUSH
107897: LD_INT 0
107899: ST_TO_ADDR
107900: GO 107918
// min_x := x - r ;
107902: LD_ADDR_VAR 0 7
107906: PUSH
107907: LD_VAR 0 2
107911: PUSH
107912: LD_VAR 0 4
107916: MINUS
107917: ST_TO_ADDR
// if y - r < 0 then
107918: LD_VAR 0 3
107922: PUSH
107923: LD_VAR 0 4
107927: MINUS
107928: PUSH
107929: LD_INT 0
107931: LESS
107932: IFFALSE 107944
// min_y := 0 else
107934: LD_ADDR_VAR 0 8
107938: PUSH
107939: LD_INT 0
107941: ST_TO_ADDR
107942: GO 107960
// min_y := y - r ;
107944: LD_ADDR_VAR 0 8
107948: PUSH
107949: LD_VAR 0 3
107953: PUSH
107954: LD_VAR 0 4
107958: MINUS
107959: ST_TO_ADDR
// max_x := x + r ;
107960: LD_ADDR_VAR 0 9
107964: PUSH
107965: LD_VAR 0 2
107969: PUSH
107970: LD_VAR 0 4
107974: PLUS
107975: ST_TO_ADDR
// max_y := y + r ;
107976: LD_ADDR_VAR 0 10
107980: PUSH
107981: LD_VAR 0 3
107985: PUSH
107986: LD_VAR 0 4
107990: PLUS
107991: ST_TO_ADDR
// for _x = min_x to max_x do
107992: LD_ADDR_VAR 0 11
107996: PUSH
107997: DOUBLE
107998: LD_VAR 0 7
108002: DEC
108003: ST_TO_ADDR
108004: LD_VAR 0 9
108008: PUSH
108009: FOR_TO
108010: IFFALSE 108127
// for _y = min_y to max_y do
108012: LD_ADDR_VAR 0 12
108016: PUSH
108017: DOUBLE
108018: LD_VAR 0 8
108022: DEC
108023: ST_TO_ADDR
108024: LD_VAR 0 10
108028: PUSH
108029: FOR_TO
108030: IFFALSE 108123
// begin if not ValidHex ( _x , _y ) then
108032: LD_VAR 0 11
108036: PPUSH
108037: LD_VAR 0 12
108041: PPUSH
108042: CALL_OW 488
108046: NOT
108047: IFFALSE 108051
// continue ;
108049: GO 108029
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108051: LD_VAR 0 11
108055: PPUSH
108056: LD_VAR 0 12
108060: PPUSH
108061: CALL_OW 351
108065: PUSH
108066: LD_VAR 0 11
108070: PPUSH
108071: LD_VAR 0 12
108075: PPUSH
108076: CALL_OW 554
108080: AND
108081: IFFALSE 108121
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108083: LD_ADDR_VAR 0 13
108087: PUSH
108088: LD_VAR 0 13
108092: PPUSH
108093: LD_VAR 0 13
108097: PUSH
108098: LD_INT 1
108100: PLUS
108101: PPUSH
108102: LD_VAR 0 11
108106: PUSH
108107: LD_VAR 0 12
108111: PUSH
108112: EMPTY
108113: LIST
108114: LIST
108115: PPUSH
108116: CALL_OW 2
108120: ST_TO_ADDR
// end ;
108121: GO 108029
108123: POP
108124: POP
108125: GO 108009
108127: POP
108128: POP
// if not list then
108129: LD_VAR 0 13
108133: NOT
108134: IFFALSE 108138
// exit ;
108136: GO 108382
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
108138: LD_ADDR_VAR 0 13
108142: PUSH
108143: LD_VAR 0 1
108147: PPUSH
108148: LD_VAR 0 13
108152: PPUSH
108153: LD_INT 1
108155: PPUSH
108156: LD_INT 1
108158: PPUSH
108159: CALL 22726 0 4
108163: ST_TO_ADDR
// ComStop ( flame ) ;
108164: LD_VAR 0 1
108168: PPUSH
108169: CALL_OW 141
// for i in list do
108173: LD_ADDR_VAR 0 6
108177: PUSH
108178: LD_VAR 0 13
108182: PUSH
108183: FOR_IN
108184: IFFALSE 108215
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
108186: LD_VAR 0 1
108190: PPUSH
108191: LD_VAR 0 6
108195: PUSH
108196: LD_INT 1
108198: ARRAY
108199: PPUSH
108200: LD_VAR 0 6
108204: PUSH
108205: LD_INT 2
108207: ARRAY
108208: PPUSH
108209: CALL_OW 176
108213: GO 108183
108215: POP
108216: POP
// repeat wait ( 0 0$1 ) ;
108217: LD_INT 35
108219: PPUSH
108220: CALL_OW 67
// task := GetTaskList ( flame ) ;
108224: LD_ADDR_VAR 0 14
108228: PUSH
108229: LD_VAR 0 1
108233: PPUSH
108234: CALL_OW 437
108238: ST_TO_ADDR
// if not task then
108239: LD_VAR 0 14
108243: NOT
108244: IFFALSE 108248
// exit ;
108246: GO 108382
// if task [ 1 ] [ 1 ] <> | then
108248: LD_VAR 0 14
108252: PUSH
108253: LD_INT 1
108255: ARRAY
108256: PUSH
108257: LD_INT 1
108259: ARRAY
108260: PUSH
108261: LD_STRING |
108263: NONEQUAL
108264: IFFALSE 108268
// exit ;
108266: GO 108382
// _x := task [ 1 ] [ 2 ] ;
108268: LD_ADDR_VAR 0 11
108272: PUSH
108273: LD_VAR 0 14
108277: PUSH
108278: LD_INT 1
108280: ARRAY
108281: PUSH
108282: LD_INT 2
108284: ARRAY
108285: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
108286: LD_ADDR_VAR 0 12
108290: PUSH
108291: LD_VAR 0 14
108295: PUSH
108296: LD_INT 1
108298: ARRAY
108299: PUSH
108300: LD_INT 3
108302: ARRAY
108303: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
108304: LD_VAR 0 11
108308: PPUSH
108309: LD_VAR 0 12
108313: PPUSH
108314: CALL_OW 351
108318: NOT
108319: PUSH
108320: LD_VAR 0 11
108324: PPUSH
108325: LD_VAR 0 12
108329: PPUSH
108330: CALL_OW 554
108334: NOT
108335: OR
108336: IFFALSE 108370
// begin task := Delete ( task , 1 ) ;
108338: LD_ADDR_VAR 0 14
108342: PUSH
108343: LD_VAR 0 14
108347: PPUSH
108348: LD_INT 1
108350: PPUSH
108351: CALL_OW 3
108355: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
108356: LD_VAR 0 1
108360: PPUSH
108361: LD_VAR 0 14
108365: PPUSH
108366: CALL_OW 446
// end ; until not HasTask ( flame ) ;
108370: LD_VAR 0 1
108374: PPUSH
108375: CALL_OW 314
108379: NOT
108380: IFFALSE 108217
// end ;
108382: LD_VAR 0 5
108386: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
108387: LD_EXP 170
108391: NOT
108392: IFFALSE 108442
108394: GO 108396
108396: DISABLE
// begin initHack := true ;
108397: LD_ADDR_EXP 170
108401: PUSH
108402: LD_INT 1
108404: ST_TO_ADDR
// hackTanks := [ ] ;
108405: LD_ADDR_EXP 171
108409: PUSH
108410: EMPTY
108411: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
108412: LD_ADDR_EXP 172
108416: PUSH
108417: EMPTY
108418: ST_TO_ADDR
// hackLimit := 3 ;
108419: LD_ADDR_EXP 173
108423: PUSH
108424: LD_INT 3
108426: ST_TO_ADDR
// hackDist := 12 ;
108427: LD_ADDR_EXP 174
108431: PUSH
108432: LD_INT 12
108434: ST_TO_ADDR
// hackCounter := [ ] ;
108435: LD_ADDR_EXP 175
108439: PUSH
108440: EMPTY
108441: ST_TO_ADDR
// end ;
108442: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
108443: LD_EXP 170
108447: PUSH
108448: LD_INT 34
108450: PUSH
108451: LD_INT 99
108453: PUSH
108454: EMPTY
108455: LIST
108456: LIST
108457: PPUSH
108458: CALL_OW 69
108462: AND
108463: IFFALSE 108716
108465: GO 108467
108467: DISABLE
108468: LD_INT 0
108470: PPUSH
108471: PPUSH
// begin enable ;
108472: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
108473: LD_ADDR_VAR 0 1
108477: PUSH
108478: LD_INT 34
108480: PUSH
108481: LD_INT 99
108483: PUSH
108484: EMPTY
108485: LIST
108486: LIST
108487: PPUSH
108488: CALL_OW 69
108492: PUSH
108493: FOR_IN
108494: IFFALSE 108714
// begin if not i in hackTanks then
108496: LD_VAR 0 1
108500: PUSH
108501: LD_EXP 171
108505: IN
108506: NOT
108507: IFFALSE 108590
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
108509: LD_ADDR_EXP 171
108513: PUSH
108514: LD_EXP 171
108518: PPUSH
108519: LD_EXP 171
108523: PUSH
108524: LD_INT 1
108526: PLUS
108527: PPUSH
108528: LD_VAR 0 1
108532: PPUSH
108533: CALL_OW 1
108537: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
108538: LD_ADDR_EXP 172
108542: PUSH
108543: LD_EXP 172
108547: PPUSH
108548: LD_EXP 172
108552: PUSH
108553: LD_INT 1
108555: PLUS
108556: PPUSH
108557: EMPTY
108558: PPUSH
108559: CALL_OW 1
108563: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
108564: LD_ADDR_EXP 175
108568: PUSH
108569: LD_EXP 175
108573: PPUSH
108574: LD_EXP 175
108578: PUSH
108579: LD_INT 1
108581: PLUS
108582: PPUSH
108583: EMPTY
108584: PPUSH
108585: CALL_OW 1
108589: ST_TO_ADDR
// end ; if not IsOk ( i ) then
108590: LD_VAR 0 1
108594: PPUSH
108595: CALL_OW 302
108599: NOT
108600: IFFALSE 108613
// begin HackUnlinkAll ( i ) ;
108602: LD_VAR 0 1
108606: PPUSH
108607: CALL 108719 0 1
// continue ;
108611: GO 108493
// end ; HackCheckCapturedStatus ( i ) ;
108613: LD_VAR 0 1
108617: PPUSH
108618: CALL 109162 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
108622: LD_ADDR_VAR 0 2
108626: PUSH
108627: LD_INT 81
108629: PUSH
108630: LD_VAR 0 1
108634: PPUSH
108635: CALL_OW 255
108639: PUSH
108640: EMPTY
108641: LIST
108642: LIST
108643: PUSH
108644: LD_INT 33
108646: PUSH
108647: LD_INT 3
108649: PUSH
108650: EMPTY
108651: LIST
108652: LIST
108653: PUSH
108654: LD_INT 91
108656: PUSH
108657: LD_VAR 0 1
108661: PUSH
108662: LD_EXP 174
108666: PUSH
108667: EMPTY
108668: LIST
108669: LIST
108670: LIST
108671: PUSH
108672: LD_INT 50
108674: PUSH
108675: EMPTY
108676: LIST
108677: PUSH
108678: EMPTY
108679: LIST
108680: LIST
108681: LIST
108682: LIST
108683: PPUSH
108684: CALL_OW 69
108688: ST_TO_ADDR
// if not tmp then
108689: LD_VAR 0 2
108693: NOT
108694: IFFALSE 108698
// continue ;
108696: GO 108493
// HackLink ( i , tmp ) ;
108698: LD_VAR 0 1
108702: PPUSH
108703: LD_VAR 0 2
108707: PPUSH
108708: CALL 108855 0 2
// end ;
108712: GO 108493
108714: POP
108715: POP
// end ;
108716: PPOPN 2
108718: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
108719: LD_INT 0
108721: PPUSH
108722: PPUSH
108723: PPUSH
// if not hack in hackTanks then
108724: LD_VAR 0 1
108728: PUSH
108729: LD_EXP 171
108733: IN
108734: NOT
108735: IFFALSE 108739
// exit ;
108737: GO 108850
// index := GetElementIndex ( hackTanks , hack ) ;
108739: LD_ADDR_VAR 0 4
108743: PUSH
108744: LD_EXP 171
108748: PPUSH
108749: LD_VAR 0 1
108753: PPUSH
108754: CALL 22023 0 2
108758: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
108759: LD_EXP 172
108763: PUSH
108764: LD_VAR 0 4
108768: ARRAY
108769: IFFALSE 108850
// begin for i in hackTanksCaptured [ index ] do
108771: LD_ADDR_VAR 0 3
108775: PUSH
108776: LD_EXP 172
108780: PUSH
108781: LD_VAR 0 4
108785: ARRAY
108786: PUSH
108787: FOR_IN
108788: IFFALSE 108814
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
108790: LD_VAR 0 3
108794: PUSH
108795: LD_INT 1
108797: ARRAY
108798: PPUSH
108799: LD_VAR 0 3
108803: PUSH
108804: LD_INT 2
108806: ARRAY
108807: PPUSH
108808: CALL_OW 235
108812: GO 108787
108814: POP
108815: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
108816: LD_ADDR_EXP 172
108820: PUSH
108821: LD_EXP 172
108825: PPUSH
108826: LD_VAR 0 4
108830: PPUSH
108831: EMPTY
108832: PPUSH
108833: CALL_OW 1
108837: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
108838: LD_VAR 0 1
108842: PPUSH
108843: LD_INT 0
108845: PPUSH
108846: CALL_OW 505
// end ; end ;
108850: LD_VAR 0 2
108854: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
108855: LD_INT 0
108857: PPUSH
108858: PPUSH
108859: PPUSH
// if not hack in hackTanks or not vehicles then
108860: LD_VAR 0 1
108864: PUSH
108865: LD_EXP 171
108869: IN
108870: NOT
108871: PUSH
108872: LD_VAR 0 2
108876: NOT
108877: OR
108878: IFFALSE 108882
// exit ;
108880: GO 109157
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
108882: LD_ADDR_VAR 0 2
108886: PUSH
108887: LD_VAR 0 1
108891: PPUSH
108892: LD_VAR 0 2
108896: PPUSH
108897: LD_INT 1
108899: PPUSH
108900: LD_INT 1
108902: PPUSH
108903: CALL 22673 0 4
108907: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
108908: LD_ADDR_VAR 0 5
108912: PUSH
108913: LD_EXP 171
108917: PPUSH
108918: LD_VAR 0 1
108922: PPUSH
108923: CALL 22023 0 2
108927: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
108928: LD_EXP 172
108932: PUSH
108933: LD_VAR 0 5
108937: ARRAY
108938: PUSH
108939: LD_EXP 173
108943: LESS
108944: IFFALSE 109133
// begin for i := 1 to vehicles do
108946: LD_ADDR_VAR 0 4
108950: PUSH
108951: DOUBLE
108952: LD_INT 1
108954: DEC
108955: ST_TO_ADDR
108956: LD_VAR 0 2
108960: PUSH
108961: FOR_TO
108962: IFFALSE 109131
// begin if hackTanksCaptured [ index ] = hackLimit then
108964: LD_EXP 172
108968: PUSH
108969: LD_VAR 0 5
108973: ARRAY
108974: PUSH
108975: LD_EXP 173
108979: EQUAL
108980: IFFALSE 108984
// break ;
108982: GO 109131
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
108984: LD_ADDR_EXP 175
108988: PUSH
108989: LD_EXP 175
108993: PPUSH
108994: LD_VAR 0 5
108998: PPUSH
108999: LD_EXP 175
109003: PUSH
109004: LD_VAR 0 5
109008: ARRAY
109009: PUSH
109010: LD_INT 1
109012: PLUS
109013: PPUSH
109014: CALL_OW 1
109018: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
109019: LD_ADDR_EXP 172
109023: PUSH
109024: LD_EXP 172
109028: PPUSH
109029: LD_VAR 0 5
109033: PUSH
109034: LD_EXP 172
109038: PUSH
109039: LD_VAR 0 5
109043: ARRAY
109044: PUSH
109045: LD_INT 1
109047: PLUS
109048: PUSH
109049: EMPTY
109050: LIST
109051: LIST
109052: PPUSH
109053: LD_VAR 0 2
109057: PUSH
109058: LD_VAR 0 4
109062: ARRAY
109063: PUSH
109064: LD_VAR 0 2
109068: PUSH
109069: LD_VAR 0 4
109073: ARRAY
109074: PPUSH
109075: CALL_OW 255
109079: PUSH
109080: EMPTY
109081: LIST
109082: LIST
109083: PPUSH
109084: CALL 22238 0 3
109088: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
109089: LD_VAR 0 2
109093: PUSH
109094: LD_VAR 0 4
109098: ARRAY
109099: PPUSH
109100: LD_VAR 0 1
109104: PPUSH
109105: CALL_OW 255
109109: PPUSH
109110: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
109114: LD_VAR 0 2
109118: PUSH
109119: LD_VAR 0 4
109123: ARRAY
109124: PPUSH
109125: CALL_OW 141
// end ;
109129: GO 108961
109131: POP
109132: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109133: LD_VAR 0 1
109137: PPUSH
109138: LD_EXP 172
109142: PUSH
109143: LD_VAR 0 5
109147: ARRAY
109148: PUSH
109149: LD_INT 0
109151: PLUS
109152: PPUSH
109153: CALL_OW 505
// end ;
109157: LD_VAR 0 3
109161: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
109162: LD_INT 0
109164: PPUSH
109165: PPUSH
109166: PPUSH
109167: PPUSH
// if not hack in hackTanks then
109168: LD_VAR 0 1
109172: PUSH
109173: LD_EXP 171
109177: IN
109178: NOT
109179: IFFALSE 109183
// exit ;
109181: GO 109423
// index := GetElementIndex ( hackTanks , hack ) ;
109183: LD_ADDR_VAR 0 4
109187: PUSH
109188: LD_EXP 171
109192: PPUSH
109193: LD_VAR 0 1
109197: PPUSH
109198: CALL 22023 0 2
109202: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
109203: LD_ADDR_VAR 0 3
109207: PUSH
109208: DOUBLE
109209: LD_EXP 172
109213: PUSH
109214: LD_VAR 0 4
109218: ARRAY
109219: INC
109220: ST_TO_ADDR
109221: LD_INT 1
109223: PUSH
109224: FOR_DOWNTO
109225: IFFALSE 109397
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
109227: LD_ADDR_VAR 0 5
109231: PUSH
109232: LD_EXP 172
109236: PUSH
109237: LD_VAR 0 4
109241: ARRAY
109242: PUSH
109243: LD_VAR 0 3
109247: ARRAY
109248: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
109249: LD_VAR 0 5
109253: PUSH
109254: LD_INT 1
109256: ARRAY
109257: PPUSH
109258: CALL_OW 302
109262: NOT
109263: PUSH
109264: LD_VAR 0 5
109268: PUSH
109269: LD_INT 1
109271: ARRAY
109272: PPUSH
109273: CALL_OW 255
109277: PUSH
109278: LD_VAR 0 1
109282: PPUSH
109283: CALL_OW 255
109287: NONEQUAL
109288: OR
109289: IFFALSE 109395
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
109291: LD_VAR 0 5
109295: PUSH
109296: LD_INT 1
109298: ARRAY
109299: PPUSH
109300: CALL_OW 305
109304: PUSH
109305: LD_VAR 0 5
109309: PUSH
109310: LD_INT 1
109312: ARRAY
109313: PPUSH
109314: CALL_OW 255
109318: PUSH
109319: LD_VAR 0 1
109323: PPUSH
109324: CALL_OW 255
109328: EQUAL
109329: AND
109330: IFFALSE 109354
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
109332: LD_VAR 0 5
109336: PUSH
109337: LD_INT 1
109339: ARRAY
109340: PPUSH
109341: LD_VAR 0 5
109345: PUSH
109346: LD_INT 2
109348: ARRAY
109349: PPUSH
109350: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
109354: LD_ADDR_EXP 172
109358: PUSH
109359: LD_EXP 172
109363: PPUSH
109364: LD_VAR 0 4
109368: PPUSH
109369: LD_EXP 172
109373: PUSH
109374: LD_VAR 0 4
109378: ARRAY
109379: PPUSH
109380: LD_VAR 0 3
109384: PPUSH
109385: CALL_OW 3
109389: PPUSH
109390: CALL_OW 1
109394: ST_TO_ADDR
// end ; end ;
109395: GO 109224
109397: POP
109398: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109399: LD_VAR 0 1
109403: PPUSH
109404: LD_EXP 172
109408: PUSH
109409: LD_VAR 0 4
109413: ARRAY
109414: PUSH
109415: LD_INT 0
109417: PLUS
109418: PPUSH
109419: CALL_OW 505
// end ;
109423: LD_VAR 0 2
109427: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
109428: LD_INT 0
109430: PPUSH
109431: PPUSH
109432: PPUSH
109433: PPUSH
// if not hack in hackTanks then
109434: LD_VAR 0 1
109438: PUSH
109439: LD_EXP 171
109443: IN
109444: NOT
109445: IFFALSE 109449
// exit ;
109447: GO 109534
// index := GetElementIndex ( hackTanks , hack ) ;
109449: LD_ADDR_VAR 0 5
109453: PUSH
109454: LD_EXP 171
109458: PPUSH
109459: LD_VAR 0 1
109463: PPUSH
109464: CALL 22023 0 2
109468: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
109469: LD_ADDR_VAR 0 4
109473: PUSH
109474: DOUBLE
109475: LD_INT 1
109477: DEC
109478: ST_TO_ADDR
109479: LD_EXP 172
109483: PUSH
109484: LD_VAR 0 5
109488: ARRAY
109489: PUSH
109490: FOR_TO
109491: IFFALSE 109532
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
109493: LD_EXP 172
109497: PUSH
109498: LD_VAR 0 5
109502: ARRAY
109503: PUSH
109504: LD_VAR 0 4
109508: ARRAY
109509: PUSH
109510: LD_INT 1
109512: ARRAY
109513: PUSH
109514: LD_VAR 0 2
109518: EQUAL
109519: IFFALSE 109530
// KillUnit ( vehicle ) ;
109521: LD_VAR 0 2
109525: PPUSH
109526: CALL_OW 66
109530: GO 109490
109532: POP
109533: POP
// end ;
109534: LD_VAR 0 3
109538: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
109539: LD_EXP 176
109543: NOT
109544: IFFALSE 109579
109546: GO 109548
109548: DISABLE
// begin initMiner := true ;
109549: LD_ADDR_EXP 176
109553: PUSH
109554: LD_INT 1
109556: ST_TO_ADDR
// minersList := [ ] ;
109557: LD_ADDR_EXP 177
109561: PUSH
109562: EMPTY
109563: ST_TO_ADDR
// minerMinesList := [ ] ;
109564: LD_ADDR_EXP 178
109568: PUSH
109569: EMPTY
109570: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
109571: LD_ADDR_EXP 179
109575: PUSH
109576: LD_INT 5
109578: ST_TO_ADDR
// end ;
109579: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
109580: LD_EXP 176
109584: PUSH
109585: LD_INT 34
109587: PUSH
109588: LD_INT 81
109590: PUSH
109591: EMPTY
109592: LIST
109593: LIST
109594: PPUSH
109595: CALL_OW 69
109599: AND
109600: IFFALSE 110061
109602: GO 109604
109604: DISABLE
109605: LD_INT 0
109607: PPUSH
109608: PPUSH
109609: PPUSH
109610: PPUSH
// begin enable ;
109611: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
109612: LD_ADDR_VAR 0 1
109616: PUSH
109617: LD_INT 34
109619: PUSH
109620: LD_INT 81
109622: PUSH
109623: EMPTY
109624: LIST
109625: LIST
109626: PPUSH
109627: CALL_OW 69
109631: PUSH
109632: FOR_IN
109633: IFFALSE 109705
// begin if not i in minersList then
109635: LD_VAR 0 1
109639: PUSH
109640: LD_EXP 177
109644: IN
109645: NOT
109646: IFFALSE 109703
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
109648: LD_ADDR_EXP 177
109652: PUSH
109653: LD_EXP 177
109657: PPUSH
109658: LD_EXP 177
109662: PUSH
109663: LD_INT 1
109665: PLUS
109666: PPUSH
109667: LD_VAR 0 1
109671: PPUSH
109672: CALL_OW 1
109676: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
109677: LD_ADDR_EXP 178
109681: PUSH
109682: LD_EXP 178
109686: PPUSH
109687: LD_EXP 178
109691: PUSH
109692: LD_INT 1
109694: PLUS
109695: PPUSH
109696: EMPTY
109697: PPUSH
109698: CALL_OW 1
109702: ST_TO_ADDR
// end end ;
109703: GO 109632
109705: POP
109706: POP
// for i := minerMinesList downto 1 do
109707: LD_ADDR_VAR 0 1
109711: PUSH
109712: DOUBLE
109713: LD_EXP 178
109717: INC
109718: ST_TO_ADDR
109719: LD_INT 1
109721: PUSH
109722: FOR_DOWNTO
109723: IFFALSE 110059
// begin if IsLive ( minersList [ i ] ) then
109725: LD_EXP 177
109729: PUSH
109730: LD_VAR 0 1
109734: ARRAY
109735: PPUSH
109736: CALL_OW 300
109740: IFFALSE 109768
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
109742: LD_EXP 177
109746: PUSH
109747: LD_VAR 0 1
109751: ARRAY
109752: PPUSH
109753: LD_EXP 178
109757: PUSH
109758: LD_VAR 0 1
109762: ARRAY
109763: PPUSH
109764: CALL_OW 505
// if not minerMinesList [ i ] then
109768: LD_EXP 178
109772: PUSH
109773: LD_VAR 0 1
109777: ARRAY
109778: NOT
109779: IFFALSE 109783
// continue ;
109781: GO 109722
// for j := minerMinesList [ i ] downto 1 do
109783: LD_ADDR_VAR 0 2
109787: PUSH
109788: DOUBLE
109789: LD_EXP 178
109793: PUSH
109794: LD_VAR 0 1
109798: ARRAY
109799: INC
109800: ST_TO_ADDR
109801: LD_INT 1
109803: PUSH
109804: FOR_DOWNTO
109805: IFFALSE 110055
// begin side := GetSide ( minersList [ i ] ) ;
109807: LD_ADDR_VAR 0 3
109811: PUSH
109812: LD_EXP 177
109816: PUSH
109817: LD_VAR 0 1
109821: ARRAY
109822: PPUSH
109823: CALL_OW 255
109827: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
109828: LD_ADDR_VAR 0 4
109832: PUSH
109833: LD_EXP 178
109837: PUSH
109838: LD_VAR 0 1
109842: ARRAY
109843: PUSH
109844: LD_VAR 0 2
109848: ARRAY
109849: PUSH
109850: LD_INT 1
109852: ARRAY
109853: PPUSH
109854: LD_EXP 178
109858: PUSH
109859: LD_VAR 0 1
109863: ARRAY
109864: PUSH
109865: LD_VAR 0 2
109869: ARRAY
109870: PUSH
109871: LD_INT 2
109873: ARRAY
109874: PPUSH
109875: CALL_OW 428
109879: ST_TO_ADDR
// if not tmp then
109880: LD_VAR 0 4
109884: NOT
109885: IFFALSE 109889
// continue ;
109887: GO 109804
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
109889: LD_VAR 0 4
109893: PUSH
109894: LD_INT 81
109896: PUSH
109897: LD_VAR 0 3
109901: PUSH
109902: EMPTY
109903: LIST
109904: LIST
109905: PPUSH
109906: CALL_OW 69
109910: IN
109911: PUSH
109912: LD_EXP 178
109916: PUSH
109917: LD_VAR 0 1
109921: ARRAY
109922: PUSH
109923: LD_VAR 0 2
109927: ARRAY
109928: PUSH
109929: LD_INT 1
109931: ARRAY
109932: PPUSH
109933: LD_EXP 178
109937: PUSH
109938: LD_VAR 0 1
109942: ARRAY
109943: PUSH
109944: LD_VAR 0 2
109948: ARRAY
109949: PUSH
109950: LD_INT 2
109952: ARRAY
109953: PPUSH
109954: CALL_OW 458
109958: AND
109959: IFFALSE 110053
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
109961: LD_EXP 178
109965: PUSH
109966: LD_VAR 0 1
109970: ARRAY
109971: PUSH
109972: LD_VAR 0 2
109976: ARRAY
109977: PUSH
109978: LD_INT 1
109980: ARRAY
109981: PPUSH
109982: LD_EXP 178
109986: PUSH
109987: LD_VAR 0 1
109991: ARRAY
109992: PUSH
109993: LD_VAR 0 2
109997: ARRAY
109998: PUSH
109999: LD_INT 2
110001: ARRAY
110002: PPUSH
110003: LD_VAR 0 3
110007: PPUSH
110008: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
110012: LD_ADDR_EXP 178
110016: PUSH
110017: LD_EXP 178
110021: PPUSH
110022: LD_VAR 0 1
110026: PPUSH
110027: LD_EXP 178
110031: PUSH
110032: LD_VAR 0 1
110036: ARRAY
110037: PPUSH
110038: LD_VAR 0 2
110042: PPUSH
110043: CALL_OW 3
110047: PPUSH
110048: CALL_OW 1
110052: ST_TO_ADDR
// end ; end ;
110053: GO 109804
110055: POP
110056: POP
// end ;
110057: GO 109722
110059: POP
110060: POP
// end ;
110061: PPOPN 4
110063: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
110064: LD_INT 0
110066: PPUSH
110067: PPUSH
// result := false ;
110068: LD_ADDR_VAR 0 4
110072: PUSH
110073: LD_INT 0
110075: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
110076: LD_VAR 0 1
110080: PPUSH
110081: CALL_OW 264
110085: PUSH
110086: LD_INT 81
110088: EQUAL
110089: NOT
110090: IFFALSE 110094
// exit ;
110092: GO 110334
// index := GetElementIndex ( minersList , unit ) ;
110094: LD_ADDR_VAR 0 5
110098: PUSH
110099: LD_EXP 177
110103: PPUSH
110104: LD_VAR 0 1
110108: PPUSH
110109: CALL 22023 0 2
110113: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
110114: LD_EXP 178
110118: PUSH
110119: LD_VAR 0 5
110123: ARRAY
110124: PUSH
110125: LD_EXP 179
110129: GREATEREQUAL
110130: IFFALSE 110134
// exit ;
110132: GO 110334
// ComMoveXY ( unit , x , y ) ;
110134: LD_VAR 0 1
110138: PPUSH
110139: LD_VAR 0 2
110143: PPUSH
110144: LD_VAR 0 3
110148: PPUSH
110149: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110153: LD_INT 35
110155: PPUSH
110156: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
110160: LD_VAR 0 1
110164: PPUSH
110165: LD_VAR 0 2
110169: PPUSH
110170: LD_VAR 0 3
110174: PPUSH
110175: CALL 53764 0 3
110179: NOT
110180: PUSH
110181: LD_VAR 0 1
110185: PPUSH
110186: CALL_OW 314
110190: AND
110191: IFFALSE 110195
// exit ;
110193: GO 110334
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
110195: LD_VAR 0 2
110199: PPUSH
110200: LD_VAR 0 3
110204: PPUSH
110205: CALL_OW 428
110209: PUSH
110210: LD_VAR 0 1
110214: EQUAL
110215: PUSH
110216: LD_VAR 0 1
110220: PPUSH
110221: CALL_OW 314
110225: NOT
110226: AND
110227: IFFALSE 110153
// PlaySoundXY ( x , y , PlantMine ) ;
110229: LD_VAR 0 2
110233: PPUSH
110234: LD_VAR 0 3
110238: PPUSH
110239: LD_STRING PlantMine
110241: PPUSH
110242: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
110246: LD_VAR 0 2
110250: PPUSH
110251: LD_VAR 0 3
110255: PPUSH
110256: LD_VAR 0 1
110260: PPUSH
110261: CALL_OW 255
110265: PPUSH
110266: LD_INT 0
110268: PPUSH
110269: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
110273: LD_ADDR_EXP 178
110277: PUSH
110278: LD_EXP 178
110282: PPUSH
110283: LD_VAR 0 5
110287: PUSH
110288: LD_EXP 178
110292: PUSH
110293: LD_VAR 0 5
110297: ARRAY
110298: PUSH
110299: LD_INT 1
110301: PLUS
110302: PUSH
110303: EMPTY
110304: LIST
110305: LIST
110306: PPUSH
110307: LD_VAR 0 2
110311: PUSH
110312: LD_VAR 0 3
110316: PUSH
110317: EMPTY
110318: LIST
110319: LIST
110320: PPUSH
110321: CALL 22238 0 3
110325: ST_TO_ADDR
// result := true ;
110326: LD_ADDR_VAR 0 4
110330: PUSH
110331: LD_INT 1
110333: ST_TO_ADDR
// end ;
110334: LD_VAR 0 4
110338: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
110339: LD_INT 0
110341: PPUSH
110342: PPUSH
110343: PPUSH
// if not unit in minersList then
110344: LD_VAR 0 1
110348: PUSH
110349: LD_EXP 177
110353: IN
110354: NOT
110355: IFFALSE 110359
// exit ;
110357: GO 110751
// index := GetElementIndex ( minersList , unit ) ;
110359: LD_ADDR_VAR 0 6
110363: PUSH
110364: LD_EXP 177
110368: PPUSH
110369: LD_VAR 0 1
110373: PPUSH
110374: CALL 22023 0 2
110378: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
110379: LD_ADDR_VAR 0 5
110383: PUSH
110384: DOUBLE
110385: LD_EXP 178
110389: PUSH
110390: LD_VAR 0 6
110394: ARRAY
110395: INC
110396: ST_TO_ADDR
110397: LD_INT 1
110399: PUSH
110400: FOR_DOWNTO
110401: IFFALSE 110562
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
110403: LD_EXP 178
110407: PUSH
110408: LD_VAR 0 6
110412: ARRAY
110413: PUSH
110414: LD_VAR 0 5
110418: ARRAY
110419: PUSH
110420: LD_INT 1
110422: ARRAY
110423: PUSH
110424: LD_VAR 0 2
110428: EQUAL
110429: PUSH
110430: LD_EXP 178
110434: PUSH
110435: LD_VAR 0 6
110439: ARRAY
110440: PUSH
110441: LD_VAR 0 5
110445: ARRAY
110446: PUSH
110447: LD_INT 2
110449: ARRAY
110450: PUSH
110451: LD_VAR 0 3
110455: EQUAL
110456: AND
110457: IFFALSE 110560
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110459: LD_EXP 178
110463: PUSH
110464: LD_VAR 0 6
110468: ARRAY
110469: PUSH
110470: LD_VAR 0 5
110474: ARRAY
110475: PUSH
110476: LD_INT 1
110478: ARRAY
110479: PPUSH
110480: LD_EXP 178
110484: PUSH
110485: LD_VAR 0 6
110489: ARRAY
110490: PUSH
110491: LD_VAR 0 5
110495: ARRAY
110496: PUSH
110497: LD_INT 2
110499: ARRAY
110500: PPUSH
110501: LD_VAR 0 1
110505: PPUSH
110506: CALL_OW 255
110510: PPUSH
110511: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
110515: LD_ADDR_EXP 178
110519: PUSH
110520: LD_EXP 178
110524: PPUSH
110525: LD_VAR 0 6
110529: PPUSH
110530: LD_EXP 178
110534: PUSH
110535: LD_VAR 0 6
110539: ARRAY
110540: PPUSH
110541: LD_VAR 0 5
110545: PPUSH
110546: CALL_OW 3
110550: PPUSH
110551: CALL_OW 1
110555: ST_TO_ADDR
// exit ;
110556: POP
110557: POP
110558: GO 110751
// end ; end ;
110560: GO 110400
110562: POP
110563: POP
// for i := minerMinesList [ index ] downto 1 do
110564: LD_ADDR_VAR 0 5
110568: PUSH
110569: DOUBLE
110570: LD_EXP 178
110574: PUSH
110575: LD_VAR 0 6
110579: ARRAY
110580: INC
110581: ST_TO_ADDR
110582: LD_INT 1
110584: PUSH
110585: FOR_DOWNTO
110586: IFFALSE 110749
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
110588: LD_EXP 178
110592: PUSH
110593: LD_VAR 0 6
110597: ARRAY
110598: PUSH
110599: LD_VAR 0 5
110603: ARRAY
110604: PUSH
110605: LD_INT 1
110607: ARRAY
110608: PPUSH
110609: LD_EXP 178
110613: PUSH
110614: LD_VAR 0 6
110618: ARRAY
110619: PUSH
110620: LD_VAR 0 5
110624: ARRAY
110625: PUSH
110626: LD_INT 2
110628: ARRAY
110629: PPUSH
110630: LD_VAR 0 2
110634: PPUSH
110635: LD_VAR 0 3
110639: PPUSH
110640: CALL_OW 298
110644: PUSH
110645: LD_INT 6
110647: LESS
110648: IFFALSE 110747
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110650: LD_EXP 178
110654: PUSH
110655: LD_VAR 0 6
110659: ARRAY
110660: PUSH
110661: LD_VAR 0 5
110665: ARRAY
110666: PUSH
110667: LD_INT 1
110669: ARRAY
110670: PPUSH
110671: LD_EXP 178
110675: PUSH
110676: LD_VAR 0 6
110680: ARRAY
110681: PUSH
110682: LD_VAR 0 5
110686: ARRAY
110687: PUSH
110688: LD_INT 2
110690: ARRAY
110691: PPUSH
110692: LD_VAR 0 1
110696: PPUSH
110697: CALL_OW 255
110701: PPUSH
110702: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
110706: LD_ADDR_EXP 178
110710: PUSH
110711: LD_EXP 178
110715: PPUSH
110716: LD_VAR 0 6
110720: PPUSH
110721: LD_EXP 178
110725: PUSH
110726: LD_VAR 0 6
110730: ARRAY
110731: PPUSH
110732: LD_VAR 0 5
110736: PPUSH
110737: CALL_OW 3
110741: PPUSH
110742: CALL_OW 1
110746: ST_TO_ADDR
// end ; end ;
110747: GO 110585
110749: POP
110750: POP
// end ;
110751: LD_VAR 0 4
110755: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
110756: LD_INT 0
110758: PPUSH
110759: PPUSH
110760: PPUSH
110761: PPUSH
110762: PPUSH
110763: PPUSH
110764: PPUSH
110765: PPUSH
110766: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
110767: LD_VAR 0 1
110771: PPUSH
110772: CALL_OW 264
110776: PUSH
110777: LD_INT 81
110779: EQUAL
110780: NOT
110781: PUSH
110782: LD_VAR 0 1
110786: PUSH
110787: LD_EXP 177
110791: IN
110792: NOT
110793: OR
110794: IFFALSE 110798
// exit ;
110796: GO 111120
// index := GetElementIndex ( minersList , unit ) ;
110798: LD_ADDR_VAR 0 6
110802: PUSH
110803: LD_EXP 177
110807: PPUSH
110808: LD_VAR 0 1
110812: PPUSH
110813: CALL 22023 0 2
110817: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
110818: LD_ADDR_VAR 0 8
110822: PUSH
110823: LD_EXP 179
110827: PUSH
110828: LD_EXP 178
110832: PUSH
110833: LD_VAR 0 6
110837: ARRAY
110838: MINUS
110839: ST_TO_ADDR
// if not minesFreeAmount then
110840: LD_VAR 0 8
110844: NOT
110845: IFFALSE 110849
// exit ;
110847: GO 111120
// tmp := [ ] ;
110849: LD_ADDR_VAR 0 7
110853: PUSH
110854: EMPTY
110855: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
110856: LD_ADDR_VAR 0 5
110860: PUSH
110861: DOUBLE
110862: LD_INT 1
110864: DEC
110865: ST_TO_ADDR
110866: LD_VAR 0 8
110870: PUSH
110871: FOR_TO
110872: IFFALSE 111067
// begin _d := rand ( 0 , 5 ) ;
110874: LD_ADDR_VAR 0 11
110878: PUSH
110879: LD_INT 0
110881: PPUSH
110882: LD_INT 5
110884: PPUSH
110885: CALL_OW 12
110889: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
110890: LD_ADDR_VAR 0 12
110894: PUSH
110895: LD_INT 2
110897: PPUSH
110898: LD_INT 6
110900: PPUSH
110901: CALL_OW 12
110905: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
110906: LD_ADDR_VAR 0 9
110910: PUSH
110911: LD_VAR 0 2
110915: PPUSH
110916: LD_VAR 0 11
110920: PPUSH
110921: LD_VAR 0 12
110925: PPUSH
110926: CALL_OW 272
110930: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
110931: LD_ADDR_VAR 0 10
110935: PUSH
110936: LD_VAR 0 3
110940: PPUSH
110941: LD_VAR 0 11
110945: PPUSH
110946: LD_VAR 0 12
110950: PPUSH
110951: CALL_OW 273
110955: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
110956: LD_VAR 0 9
110960: PPUSH
110961: LD_VAR 0 10
110965: PPUSH
110966: CALL_OW 488
110970: PUSH
110971: LD_VAR 0 9
110975: PUSH
110976: LD_VAR 0 10
110980: PUSH
110981: EMPTY
110982: LIST
110983: LIST
110984: PUSH
110985: LD_VAR 0 7
110989: IN
110990: NOT
110991: AND
110992: PUSH
110993: LD_VAR 0 9
110997: PPUSH
110998: LD_VAR 0 10
111002: PPUSH
111003: CALL_OW 458
111007: NOT
111008: AND
111009: IFFALSE 111051
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
111011: LD_ADDR_VAR 0 7
111015: PUSH
111016: LD_VAR 0 7
111020: PPUSH
111021: LD_VAR 0 7
111025: PUSH
111026: LD_INT 1
111028: PLUS
111029: PPUSH
111030: LD_VAR 0 9
111034: PUSH
111035: LD_VAR 0 10
111039: PUSH
111040: EMPTY
111041: LIST
111042: LIST
111043: PPUSH
111044: CALL_OW 1
111048: ST_TO_ADDR
111049: GO 111065
// i := i - 1 ;
111051: LD_ADDR_VAR 0 5
111055: PUSH
111056: LD_VAR 0 5
111060: PUSH
111061: LD_INT 1
111063: MINUS
111064: ST_TO_ADDR
// end ;
111065: GO 110871
111067: POP
111068: POP
// for i in tmp do
111069: LD_ADDR_VAR 0 5
111073: PUSH
111074: LD_VAR 0 7
111078: PUSH
111079: FOR_IN
111080: IFFALSE 111118
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
111082: LD_VAR 0 1
111086: PPUSH
111087: LD_VAR 0 5
111091: PUSH
111092: LD_INT 1
111094: ARRAY
111095: PPUSH
111096: LD_VAR 0 5
111100: PUSH
111101: LD_INT 2
111103: ARRAY
111104: PPUSH
111105: CALL 110064 0 3
111109: NOT
111110: IFFALSE 111116
// exit ;
111112: POP
111113: POP
111114: GO 111120
111116: GO 111079
111118: POP
111119: POP
// end ;
111120: LD_VAR 0 4
111124: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
111125: LD_INT 0
111127: PPUSH
111128: PPUSH
111129: PPUSH
111130: PPUSH
111131: PPUSH
111132: PPUSH
111133: PPUSH
// if not GetClass ( unit ) = class_sniper then
111134: LD_VAR 0 1
111138: PPUSH
111139: CALL_OW 257
111143: PUSH
111144: LD_INT 5
111146: EQUAL
111147: NOT
111148: IFFALSE 111152
// exit ;
111150: GO 111540
// dist := 8 ;
111152: LD_ADDR_VAR 0 5
111156: PUSH
111157: LD_INT 8
111159: ST_TO_ADDR
// viewRange := 12 ;
111160: LD_ADDR_VAR 0 7
111164: PUSH
111165: LD_INT 12
111167: ST_TO_ADDR
// side := GetSide ( unit ) ;
111168: LD_ADDR_VAR 0 6
111172: PUSH
111173: LD_VAR 0 1
111177: PPUSH
111178: CALL_OW 255
111182: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
111183: LD_INT 61
111185: PPUSH
111186: LD_VAR 0 6
111190: PPUSH
111191: CALL_OW 321
111195: PUSH
111196: LD_INT 2
111198: EQUAL
111199: IFFALSE 111209
// viewRange := 16 ;
111201: LD_ADDR_VAR 0 7
111205: PUSH
111206: LD_INT 16
111208: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
111209: LD_VAR 0 1
111213: PPUSH
111214: LD_VAR 0 2
111218: PPUSH
111219: LD_VAR 0 3
111223: PPUSH
111224: CALL_OW 297
111228: PUSH
111229: LD_VAR 0 5
111233: GREATER
111234: IFFALSE 111313
// begin ComMoveXY ( unit , x , y ) ;
111236: LD_VAR 0 1
111240: PPUSH
111241: LD_VAR 0 2
111245: PPUSH
111246: LD_VAR 0 3
111250: PPUSH
111251: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111255: LD_INT 35
111257: PPUSH
111258: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
111262: LD_VAR 0 1
111266: PPUSH
111267: LD_VAR 0 2
111271: PPUSH
111272: LD_VAR 0 3
111276: PPUSH
111277: CALL 53764 0 3
111281: NOT
111282: IFFALSE 111286
// exit ;
111284: GO 111540
// until GetDistUnitXY ( unit , x , y ) < dist ;
111286: LD_VAR 0 1
111290: PPUSH
111291: LD_VAR 0 2
111295: PPUSH
111296: LD_VAR 0 3
111300: PPUSH
111301: CALL_OW 297
111305: PUSH
111306: LD_VAR 0 5
111310: LESS
111311: IFFALSE 111255
// end ; ComTurnXY ( unit , x , y ) ;
111313: LD_VAR 0 1
111317: PPUSH
111318: LD_VAR 0 2
111322: PPUSH
111323: LD_VAR 0 3
111327: PPUSH
111328: CALL_OW 118
// wait ( 5 ) ;
111332: LD_INT 5
111334: PPUSH
111335: CALL_OW 67
// _d := GetDir ( unit ) ;
111339: LD_ADDR_VAR 0 10
111343: PUSH
111344: LD_VAR 0 1
111348: PPUSH
111349: CALL_OW 254
111353: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
111354: LD_ADDR_VAR 0 8
111358: PUSH
111359: LD_VAR 0 1
111363: PPUSH
111364: CALL_OW 250
111368: PPUSH
111369: LD_VAR 0 10
111373: PPUSH
111374: LD_VAR 0 5
111378: PPUSH
111379: CALL_OW 272
111383: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
111384: LD_ADDR_VAR 0 9
111388: PUSH
111389: LD_VAR 0 1
111393: PPUSH
111394: CALL_OW 251
111398: PPUSH
111399: LD_VAR 0 10
111403: PPUSH
111404: LD_VAR 0 5
111408: PPUSH
111409: CALL_OW 273
111413: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
111414: LD_VAR 0 8
111418: PPUSH
111419: LD_VAR 0 9
111423: PPUSH
111424: CALL_OW 488
111428: NOT
111429: IFFALSE 111433
// exit ;
111431: GO 111540
// ComAnimCustom ( unit , 1 ) ;
111433: LD_VAR 0 1
111437: PPUSH
111438: LD_INT 1
111440: PPUSH
111441: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
111445: LD_VAR 0 8
111449: PPUSH
111450: LD_VAR 0 9
111454: PPUSH
111455: LD_VAR 0 6
111459: PPUSH
111460: LD_VAR 0 7
111464: PPUSH
111465: CALL_OW 330
// repeat wait ( 1 ) ;
111469: LD_INT 1
111471: PPUSH
111472: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
111476: LD_VAR 0 1
111480: PPUSH
111481: CALL_OW 316
111485: PUSH
111486: LD_VAR 0 1
111490: PPUSH
111491: CALL_OW 314
111495: OR
111496: PUSH
111497: LD_VAR 0 1
111501: PPUSH
111502: CALL_OW 302
111506: NOT
111507: OR
111508: PUSH
111509: LD_VAR 0 1
111513: PPUSH
111514: CALL_OW 301
111518: OR
111519: IFFALSE 111469
// RemoveSeeing ( _x , _y , side ) ;
111521: LD_VAR 0 8
111525: PPUSH
111526: LD_VAR 0 9
111530: PPUSH
111531: LD_VAR 0 6
111535: PPUSH
111536: CALL_OW 331
// end ; end_of_file
111540: LD_VAR 0 4
111544: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
111545: LD_INT 0
111547: PPUSH
111548: PPUSH
111549: PPUSH
111550: PPUSH
111551: PPUSH
111552: PPUSH
111553: PPUSH
111554: PPUSH
111555: PPUSH
111556: PPUSH
111557: PPUSH
111558: PPUSH
111559: PPUSH
111560: PPUSH
111561: PPUSH
111562: PPUSH
111563: PPUSH
111564: PPUSH
111565: PPUSH
111566: PPUSH
111567: PPUSH
111568: PPUSH
111569: PPUSH
111570: PPUSH
111571: PPUSH
111572: PPUSH
111573: PPUSH
111574: PPUSH
111575: PPUSH
111576: PPUSH
111577: PPUSH
111578: PPUSH
111579: PPUSH
111580: PPUSH
// if not list then
111581: LD_VAR 0 1
111585: NOT
111586: IFFALSE 111590
// exit ;
111588: GO 116249
// base := list [ 1 ] ;
111590: LD_ADDR_VAR 0 3
111594: PUSH
111595: LD_VAR 0 1
111599: PUSH
111600: LD_INT 1
111602: ARRAY
111603: ST_TO_ADDR
// group := list [ 2 ] ;
111604: LD_ADDR_VAR 0 4
111608: PUSH
111609: LD_VAR 0 1
111613: PUSH
111614: LD_INT 2
111616: ARRAY
111617: ST_TO_ADDR
// path := list [ 3 ] ;
111618: LD_ADDR_VAR 0 5
111622: PUSH
111623: LD_VAR 0 1
111627: PUSH
111628: LD_INT 3
111630: ARRAY
111631: ST_TO_ADDR
// flags := list [ 4 ] ;
111632: LD_ADDR_VAR 0 6
111636: PUSH
111637: LD_VAR 0 1
111641: PUSH
111642: LD_INT 4
111644: ARRAY
111645: ST_TO_ADDR
// mined := [ ] ;
111646: LD_ADDR_VAR 0 27
111650: PUSH
111651: EMPTY
111652: ST_TO_ADDR
// bombed := [ ] ;
111653: LD_ADDR_VAR 0 28
111657: PUSH
111658: EMPTY
111659: ST_TO_ADDR
// healers := [ ] ;
111660: LD_ADDR_VAR 0 31
111664: PUSH
111665: EMPTY
111666: ST_TO_ADDR
// to_heal := [ ] ;
111667: LD_ADDR_VAR 0 30
111671: PUSH
111672: EMPTY
111673: ST_TO_ADDR
// repairs := [ ] ;
111674: LD_ADDR_VAR 0 33
111678: PUSH
111679: EMPTY
111680: ST_TO_ADDR
// to_repair := [ ] ;
111681: LD_ADDR_VAR 0 32
111685: PUSH
111686: EMPTY
111687: ST_TO_ADDR
// if not group or not path then
111688: LD_VAR 0 4
111692: NOT
111693: PUSH
111694: LD_VAR 0 5
111698: NOT
111699: OR
111700: IFFALSE 111704
// exit ;
111702: GO 116249
// side := GetSide ( group [ 1 ] ) ;
111704: LD_ADDR_VAR 0 35
111708: PUSH
111709: LD_VAR 0 4
111713: PUSH
111714: LD_INT 1
111716: ARRAY
111717: PPUSH
111718: CALL_OW 255
111722: ST_TO_ADDR
// if flags then
111723: LD_VAR 0 6
111727: IFFALSE 111871
// begin f_ignore_area := flags [ 1 ] ;
111729: LD_ADDR_VAR 0 17
111733: PUSH
111734: LD_VAR 0 6
111738: PUSH
111739: LD_INT 1
111741: ARRAY
111742: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
111743: LD_ADDR_VAR 0 18
111747: PUSH
111748: LD_VAR 0 6
111752: PUSH
111753: LD_INT 2
111755: ARRAY
111756: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
111757: LD_ADDR_VAR 0 19
111761: PUSH
111762: LD_VAR 0 6
111766: PUSH
111767: LD_INT 3
111769: ARRAY
111770: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
111771: LD_ADDR_VAR 0 20
111775: PUSH
111776: LD_VAR 0 6
111780: PUSH
111781: LD_INT 4
111783: ARRAY
111784: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
111785: LD_ADDR_VAR 0 21
111789: PUSH
111790: LD_VAR 0 6
111794: PUSH
111795: LD_INT 5
111797: ARRAY
111798: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
111799: LD_ADDR_VAR 0 22
111803: PUSH
111804: LD_VAR 0 6
111808: PUSH
111809: LD_INT 6
111811: ARRAY
111812: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
111813: LD_ADDR_VAR 0 23
111817: PUSH
111818: LD_VAR 0 6
111822: PUSH
111823: LD_INT 7
111825: ARRAY
111826: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
111827: LD_ADDR_VAR 0 24
111831: PUSH
111832: LD_VAR 0 6
111836: PUSH
111837: LD_INT 8
111839: ARRAY
111840: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
111841: LD_ADDR_VAR 0 25
111845: PUSH
111846: LD_VAR 0 6
111850: PUSH
111851: LD_INT 9
111853: ARRAY
111854: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
111855: LD_ADDR_VAR 0 26
111859: PUSH
111860: LD_VAR 0 6
111864: PUSH
111865: LD_INT 10
111867: ARRAY
111868: ST_TO_ADDR
// end else
111869: GO 111951
// begin f_ignore_area := false ;
111871: LD_ADDR_VAR 0 17
111875: PUSH
111876: LD_INT 0
111878: ST_TO_ADDR
// f_capture := false ;
111879: LD_ADDR_VAR 0 18
111883: PUSH
111884: LD_INT 0
111886: ST_TO_ADDR
// f_ignore_civ := false ;
111887: LD_ADDR_VAR 0 19
111891: PUSH
111892: LD_INT 0
111894: ST_TO_ADDR
// f_murder := false ;
111895: LD_ADDR_VAR 0 20
111899: PUSH
111900: LD_INT 0
111902: ST_TO_ADDR
// f_mines := false ;
111903: LD_ADDR_VAR 0 21
111907: PUSH
111908: LD_INT 0
111910: ST_TO_ADDR
// f_repair := false ;
111911: LD_ADDR_VAR 0 22
111915: PUSH
111916: LD_INT 0
111918: ST_TO_ADDR
// f_heal := false ;
111919: LD_ADDR_VAR 0 23
111923: PUSH
111924: LD_INT 0
111926: ST_TO_ADDR
// f_spacetime := false ;
111927: LD_ADDR_VAR 0 24
111931: PUSH
111932: LD_INT 0
111934: ST_TO_ADDR
// f_attack_depot := false ;
111935: LD_ADDR_VAR 0 25
111939: PUSH
111940: LD_INT 0
111942: ST_TO_ADDR
// f_crawl := false ;
111943: LD_ADDR_VAR 0 26
111947: PUSH
111948: LD_INT 0
111950: ST_TO_ADDR
// end ; if f_heal then
111951: LD_VAR 0 23
111955: IFFALSE 111982
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
111957: LD_ADDR_VAR 0 31
111961: PUSH
111962: LD_VAR 0 4
111966: PPUSH
111967: LD_INT 25
111969: PUSH
111970: LD_INT 4
111972: PUSH
111973: EMPTY
111974: LIST
111975: LIST
111976: PPUSH
111977: CALL_OW 72
111981: ST_TO_ADDR
// if f_repair then
111982: LD_VAR 0 22
111986: IFFALSE 112013
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
111988: LD_ADDR_VAR 0 33
111992: PUSH
111993: LD_VAR 0 4
111997: PPUSH
111998: LD_INT 25
112000: PUSH
112001: LD_INT 3
112003: PUSH
112004: EMPTY
112005: LIST
112006: LIST
112007: PPUSH
112008: CALL_OW 72
112012: ST_TO_ADDR
// units_path := [ ] ;
112013: LD_ADDR_VAR 0 16
112017: PUSH
112018: EMPTY
112019: ST_TO_ADDR
// for i = 1 to group do
112020: LD_ADDR_VAR 0 7
112024: PUSH
112025: DOUBLE
112026: LD_INT 1
112028: DEC
112029: ST_TO_ADDR
112030: LD_VAR 0 4
112034: PUSH
112035: FOR_TO
112036: IFFALSE 112065
// units_path := Replace ( units_path , i , path ) ;
112038: LD_ADDR_VAR 0 16
112042: PUSH
112043: LD_VAR 0 16
112047: PPUSH
112048: LD_VAR 0 7
112052: PPUSH
112053: LD_VAR 0 5
112057: PPUSH
112058: CALL_OW 1
112062: ST_TO_ADDR
112063: GO 112035
112065: POP
112066: POP
// repeat for i = group downto 1 do
112067: LD_ADDR_VAR 0 7
112071: PUSH
112072: DOUBLE
112073: LD_VAR 0 4
112077: INC
112078: ST_TO_ADDR
112079: LD_INT 1
112081: PUSH
112082: FOR_DOWNTO
112083: IFFALSE 116205
// begin wait ( 5 ) ;
112085: LD_INT 5
112087: PPUSH
112088: CALL_OW 67
// tmp := [ ] ;
112092: LD_ADDR_VAR 0 14
112096: PUSH
112097: EMPTY
112098: ST_TO_ADDR
// attacking := false ;
112099: LD_ADDR_VAR 0 29
112103: PUSH
112104: LD_INT 0
112106: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
112107: LD_VAR 0 4
112111: PUSH
112112: LD_VAR 0 7
112116: ARRAY
112117: PPUSH
112118: CALL_OW 301
112122: PUSH
112123: LD_VAR 0 4
112127: PUSH
112128: LD_VAR 0 7
112132: ARRAY
112133: NOT
112134: OR
112135: IFFALSE 112244
// begin if GetType ( group [ i ] ) = unit_human then
112137: LD_VAR 0 4
112141: PUSH
112142: LD_VAR 0 7
112146: ARRAY
112147: PPUSH
112148: CALL_OW 247
112152: PUSH
112153: LD_INT 1
112155: EQUAL
112156: IFFALSE 112202
// begin to_heal := to_heal diff group [ i ] ;
112158: LD_ADDR_VAR 0 30
112162: PUSH
112163: LD_VAR 0 30
112167: PUSH
112168: LD_VAR 0 4
112172: PUSH
112173: LD_VAR 0 7
112177: ARRAY
112178: DIFF
112179: ST_TO_ADDR
// healers := healers diff group [ i ] ;
112180: LD_ADDR_VAR 0 31
112184: PUSH
112185: LD_VAR 0 31
112189: PUSH
112190: LD_VAR 0 4
112194: PUSH
112195: LD_VAR 0 7
112199: ARRAY
112200: DIFF
112201: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
112202: LD_ADDR_VAR 0 4
112206: PUSH
112207: LD_VAR 0 4
112211: PPUSH
112212: LD_VAR 0 7
112216: PPUSH
112217: CALL_OW 3
112221: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
112222: LD_ADDR_VAR 0 16
112226: PUSH
112227: LD_VAR 0 16
112231: PPUSH
112232: LD_VAR 0 7
112236: PPUSH
112237: CALL_OW 3
112241: ST_TO_ADDR
// continue ;
112242: GO 112082
// end ; if f_repair then
112244: LD_VAR 0 22
112248: IFFALSE 112737
// begin if GetType ( group [ i ] ) = unit_vehicle then
112250: LD_VAR 0 4
112254: PUSH
112255: LD_VAR 0 7
112259: ARRAY
112260: PPUSH
112261: CALL_OW 247
112265: PUSH
112266: LD_INT 2
112268: EQUAL
112269: IFFALSE 112459
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
112271: LD_VAR 0 4
112275: PUSH
112276: LD_VAR 0 7
112280: ARRAY
112281: PPUSH
112282: CALL_OW 256
112286: PUSH
112287: LD_INT 700
112289: LESS
112290: PUSH
112291: LD_VAR 0 4
112295: PUSH
112296: LD_VAR 0 7
112300: ARRAY
112301: PUSH
112302: LD_VAR 0 32
112306: IN
112307: NOT
112308: AND
112309: IFFALSE 112333
// to_repair := to_repair union group [ i ] ;
112311: LD_ADDR_VAR 0 32
112315: PUSH
112316: LD_VAR 0 32
112320: PUSH
112321: LD_VAR 0 4
112325: PUSH
112326: LD_VAR 0 7
112330: ARRAY
112331: UNION
112332: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
112333: LD_VAR 0 4
112337: PUSH
112338: LD_VAR 0 7
112342: ARRAY
112343: PPUSH
112344: CALL_OW 256
112348: PUSH
112349: LD_INT 1000
112351: EQUAL
112352: PUSH
112353: LD_VAR 0 4
112357: PUSH
112358: LD_VAR 0 7
112362: ARRAY
112363: PUSH
112364: LD_VAR 0 32
112368: IN
112369: AND
112370: IFFALSE 112394
// to_repair := to_repair diff group [ i ] ;
112372: LD_ADDR_VAR 0 32
112376: PUSH
112377: LD_VAR 0 32
112381: PUSH
112382: LD_VAR 0 4
112386: PUSH
112387: LD_VAR 0 7
112391: ARRAY
112392: DIFF
112393: ST_TO_ADDR
// if group [ i ] in to_repair then
112394: LD_VAR 0 4
112398: PUSH
112399: LD_VAR 0 7
112403: ARRAY
112404: PUSH
112405: LD_VAR 0 32
112409: IN
112410: IFFALSE 112457
// begin if not IsInArea ( group [ i ] , f_repair ) then
112412: LD_VAR 0 4
112416: PUSH
112417: LD_VAR 0 7
112421: ARRAY
112422: PPUSH
112423: LD_VAR 0 22
112427: PPUSH
112428: CALL_OW 308
112432: NOT
112433: IFFALSE 112455
// ComMoveToArea ( group [ i ] , f_repair ) ;
112435: LD_VAR 0 4
112439: PUSH
112440: LD_VAR 0 7
112444: ARRAY
112445: PPUSH
112446: LD_VAR 0 22
112450: PPUSH
112451: CALL_OW 113
// continue ;
112455: GO 112082
// end ; end else
112457: GO 112737
// if group [ i ] in repairs then
112459: LD_VAR 0 4
112463: PUSH
112464: LD_VAR 0 7
112468: ARRAY
112469: PUSH
112470: LD_VAR 0 33
112474: IN
112475: IFFALSE 112737
// begin if IsInUnit ( group [ i ] ) then
112477: LD_VAR 0 4
112481: PUSH
112482: LD_VAR 0 7
112486: ARRAY
112487: PPUSH
112488: CALL_OW 310
112492: IFFALSE 112560
// begin z := IsInUnit ( group [ i ] ) ;
112494: LD_ADDR_VAR 0 13
112498: PUSH
112499: LD_VAR 0 4
112503: PUSH
112504: LD_VAR 0 7
112508: ARRAY
112509: PPUSH
112510: CALL_OW 310
112514: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
112515: LD_VAR 0 13
112519: PUSH
112520: LD_VAR 0 32
112524: IN
112525: PUSH
112526: LD_VAR 0 13
112530: PPUSH
112531: LD_VAR 0 22
112535: PPUSH
112536: CALL_OW 308
112540: AND
112541: IFFALSE 112558
// ComExitVehicle ( group [ i ] ) ;
112543: LD_VAR 0 4
112547: PUSH
112548: LD_VAR 0 7
112552: ARRAY
112553: PPUSH
112554: CALL_OW 121
// end else
112558: GO 112737
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
112560: LD_ADDR_VAR 0 13
112564: PUSH
112565: LD_VAR 0 4
112569: PPUSH
112570: LD_INT 95
112572: PUSH
112573: LD_VAR 0 22
112577: PUSH
112578: EMPTY
112579: LIST
112580: LIST
112581: PUSH
112582: LD_INT 58
112584: PUSH
112585: EMPTY
112586: LIST
112587: PUSH
112588: EMPTY
112589: LIST
112590: LIST
112591: PPUSH
112592: CALL_OW 72
112596: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
112597: LD_VAR 0 4
112601: PUSH
112602: LD_VAR 0 7
112606: ARRAY
112607: PPUSH
112608: CALL_OW 314
112612: NOT
112613: IFFALSE 112735
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
112615: LD_ADDR_VAR 0 10
112619: PUSH
112620: LD_VAR 0 13
112624: PPUSH
112625: LD_VAR 0 4
112629: PUSH
112630: LD_VAR 0 7
112634: ARRAY
112635: PPUSH
112636: CALL_OW 74
112640: ST_TO_ADDR
// if not x then
112641: LD_VAR 0 10
112645: NOT
112646: IFFALSE 112650
// continue ;
112648: GO 112082
// if GetLives ( x ) < 1000 then
112650: LD_VAR 0 10
112654: PPUSH
112655: CALL_OW 256
112659: PUSH
112660: LD_INT 1000
112662: LESS
112663: IFFALSE 112687
// ComRepairVehicle ( group [ i ] , x ) else
112665: LD_VAR 0 4
112669: PUSH
112670: LD_VAR 0 7
112674: ARRAY
112675: PPUSH
112676: LD_VAR 0 10
112680: PPUSH
112681: CALL_OW 129
112685: GO 112735
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
112687: LD_VAR 0 23
112691: PUSH
112692: LD_VAR 0 4
112696: PUSH
112697: LD_VAR 0 7
112701: ARRAY
112702: PPUSH
112703: CALL_OW 256
112707: PUSH
112708: LD_INT 1000
112710: LESS
112711: AND
112712: NOT
112713: IFFALSE 112735
// ComEnterUnit ( group [ i ] , x ) ;
112715: LD_VAR 0 4
112719: PUSH
112720: LD_VAR 0 7
112724: ARRAY
112725: PPUSH
112726: LD_VAR 0 10
112730: PPUSH
112731: CALL_OW 120
// end ; continue ;
112735: GO 112082
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
112737: LD_VAR 0 23
112741: PUSH
112742: LD_VAR 0 4
112746: PUSH
112747: LD_VAR 0 7
112751: ARRAY
112752: PPUSH
112753: CALL_OW 247
112757: PUSH
112758: LD_INT 1
112760: EQUAL
112761: AND
112762: IFFALSE 113240
// begin if group [ i ] in healers then
112764: LD_VAR 0 4
112768: PUSH
112769: LD_VAR 0 7
112773: ARRAY
112774: PUSH
112775: LD_VAR 0 31
112779: IN
112780: IFFALSE 113053
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
112782: LD_VAR 0 4
112786: PUSH
112787: LD_VAR 0 7
112791: ARRAY
112792: PPUSH
112793: LD_VAR 0 23
112797: PPUSH
112798: CALL_OW 308
112802: NOT
112803: PUSH
112804: LD_VAR 0 4
112808: PUSH
112809: LD_VAR 0 7
112813: ARRAY
112814: PPUSH
112815: CALL_OW 314
112819: NOT
112820: AND
112821: IFFALSE 112845
// ComMoveToArea ( group [ i ] , f_heal ) else
112823: LD_VAR 0 4
112827: PUSH
112828: LD_VAR 0 7
112832: ARRAY
112833: PPUSH
112834: LD_VAR 0 23
112838: PPUSH
112839: CALL_OW 113
112843: GO 113051
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
112845: LD_VAR 0 4
112849: PUSH
112850: LD_VAR 0 7
112854: ARRAY
112855: PPUSH
112856: CALL 52347 0 1
112860: PPUSH
112861: CALL_OW 256
112865: PUSH
112866: LD_INT 1000
112868: EQUAL
112869: IFFALSE 112888
// ComStop ( group [ i ] ) else
112871: LD_VAR 0 4
112875: PUSH
112876: LD_VAR 0 7
112880: ARRAY
112881: PPUSH
112882: CALL_OW 141
112886: GO 113051
// if not HasTask ( group [ i ] ) and to_heal then
112888: LD_VAR 0 4
112892: PUSH
112893: LD_VAR 0 7
112897: ARRAY
112898: PPUSH
112899: CALL_OW 314
112903: NOT
112904: PUSH
112905: LD_VAR 0 30
112909: AND
112910: IFFALSE 113051
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
112912: LD_ADDR_VAR 0 13
112916: PUSH
112917: LD_VAR 0 30
112921: PPUSH
112922: LD_INT 3
112924: PUSH
112925: LD_INT 54
112927: PUSH
112928: EMPTY
112929: LIST
112930: PUSH
112931: EMPTY
112932: LIST
112933: LIST
112934: PPUSH
112935: CALL_OW 72
112939: PPUSH
112940: LD_VAR 0 4
112944: PUSH
112945: LD_VAR 0 7
112949: ARRAY
112950: PPUSH
112951: CALL_OW 74
112955: ST_TO_ADDR
// if z then
112956: LD_VAR 0 13
112960: IFFALSE 113051
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
112962: LD_INT 91
112964: PUSH
112965: LD_VAR 0 13
112969: PUSH
112970: LD_INT 10
112972: PUSH
112973: EMPTY
112974: LIST
112975: LIST
112976: LIST
112977: PUSH
112978: LD_INT 81
112980: PUSH
112981: LD_VAR 0 13
112985: PPUSH
112986: CALL_OW 255
112990: PUSH
112991: EMPTY
112992: LIST
112993: LIST
112994: PUSH
112995: EMPTY
112996: LIST
112997: LIST
112998: PPUSH
112999: CALL_OW 69
113003: PUSH
113004: LD_INT 0
113006: EQUAL
113007: IFFALSE 113031
// ComHeal ( group [ i ] , z ) else
113009: LD_VAR 0 4
113013: PUSH
113014: LD_VAR 0 7
113018: ARRAY
113019: PPUSH
113020: LD_VAR 0 13
113024: PPUSH
113025: CALL_OW 128
113029: GO 113051
// ComMoveToArea ( group [ i ] , f_heal ) ;
113031: LD_VAR 0 4
113035: PUSH
113036: LD_VAR 0 7
113040: ARRAY
113041: PPUSH
113042: LD_VAR 0 23
113046: PPUSH
113047: CALL_OW 113
// end ; continue ;
113051: GO 112082
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
113053: LD_VAR 0 4
113057: PUSH
113058: LD_VAR 0 7
113062: ARRAY
113063: PPUSH
113064: CALL_OW 256
113068: PUSH
113069: LD_INT 700
113071: LESS
113072: PUSH
113073: LD_VAR 0 4
113077: PUSH
113078: LD_VAR 0 7
113082: ARRAY
113083: PUSH
113084: LD_VAR 0 30
113088: IN
113089: NOT
113090: AND
113091: IFFALSE 113115
// to_heal := to_heal union group [ i ] ;
113093: LD_ADDR_VAR 0 30
113097: PUSH
113098: LD_VAR 0 30
113102: PUSH
113103: LD_VAR 0 4
113107: PUSH
113108: LD_VAR 0 7
113112: ARRAY
113113: UNION
113114: ST_TO_ADDR
// if group [ i ] in to_heal then
113115: LD_VAR 0 4
113119: PUSH
113120: LD_VAR 0 7
113124: ARRAY
113125: PUSH
113126: LD_VAR 0 30
113130: IN
113131: IFFALSE 113240
// begin if GetLives ( group [ i ] ) = 1000 then
113133: LD_VAR 0 4
113137: PUSH
113138: LD_VAR 0 7
113142: ARRAY
113143: PPUSH
113144: CALL_OW 256
113148: PUSH
113149: LD_INT 1000
113151: EQUAL
113152: IFFALSE 113178
// to_heal := to_heal diff group [ i ] else
113154: LD_ADDR_VAR 0 30
113158: PUSH
113159: LD_VAR 0 30
113163: PUSH
113164: LD_VAR 0 4
113168: PUSH
113169: LD_VAR 0 7
113173: ARRAY
113174: DIFF
113175: ST_TO_ADDR
113176: GO 113240
// begin if not IsInArea ( group [ i ] , to_heal ) then
113178: LD_VAR 0 4
113182: PUSH
113183: LD_VAR 0 7
113187: ARRAY
113188: PPUSH
113189: LD_VAR 0 30
113193: PPUSH
113194: CALL_OW 308
113198: NOT
113199: IFFALSE 113223
// ComMoveToArea ( group [ i ] , f_heal ) else
113201: LD_VAR 0 4
113205: PUSH
113206: LD_VAR 0 7
113210: ARRAY
113211: PPUSH
113212: LD_VAR 0 23
113216: PPUSH
113217: CALL_OW 113
113221: GO 113238
// ComHold ( group [ i ] ) ;
113223: LD_VAR 0 4
113227: PUSH
113228: LD_VAR 0 7
113232: ARRAY
113233: PPUSH
113234: CALL_OW 140
// continue ;
113238: GO 112082
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
113240: LD_VAR 0 4
113244: PUSH
113245: LD_VAR 0 7
113249: ARRAY
113250: PPUSH
113251: LD_INT 10
113253: PPUSH
113254: CALL 50129 0 2
113258: NOT
113259: PUSH
113260: LD_VAR 0 16
113264: PUSH
113265: LD_VAR 0 7
113269: ARRAY
113270: PUSH
113271: EMPTY
113272: EQUAL
113273: NOT
113274: AND
113275: IFFALSE 113541
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
113277: LD_VAR 0 4
113281: PUSH
113282: LD_VAR 0 7
113286: ARRAY
113287: PPUSH
113288: CALL_OW 262
113292: PUSH
113293: LD_INT 1
113295: PUSH
113296: LD_INT 2
113298: PUSH
113299: EMPTY
113300: LIST
113301: LIST
113302: IN
113303: IFFALSE 113344
// if GetFuel ( group [ i ] ) < 10 then
113305: LD_VAR 0 4
113309: PUSH
113310: LD_VAR 0 7
113314: ARRAY
113315: PPUSH
113316: CALL_OW 261
113320: PUSH
113321: LD_INT 10
113323: LESS
113324: IFFALSE 113344
// SetFuel ( group [ i ] , 12 ) ;
113326: LD_VAR 0 4
113330: PUSH
113331: LD_VAR 0 7
113335: ARRAY
113336: PPUSH
113337: LD_INT 12
113339: PPUSH
113340: CALL_OW 240
// if units_path [ i ] then
113344: LD_VAR 0 16
113348: PUSH
113349: LD_VAR 0 7
113353: ARRAY
113354: IFFALSE 113539
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
113356: LD_VAR 0 4
113360: PUSH
113361: LD_VAR 0 7
113365: ARRAY
113366: PPUSH
113367: LD_VAR 0 16
113371: PUSH
113372: LD_VAR 0 7
113376: ARRAY
113377: PUSH
113378: LD_INT 1
113380: ARRAY
113381: PUSH
113382: LD_INT 1
113384: ARRAY
113385: PPUSH
113386: LD_VAR 0 16
113390: PUSH
113391: LD_VAR 0 7
113395: ARRAY
113396: PUSH
113397: LD_INT 1
113399: ARRAY
113400: PUSH
113401: LD_INT 2
113403: ARRAY
113404: PPUSH
113405: CALL_OW 297
113409: PUSH
113410: LD_INT 6
113412: GREATER
113413: IFFALSE 113488
// begin if not HasTask ( group [ i ] ) then
113415: LD_VAR 0 4
113419: PUSH
113420: LD_VAR 0 7
113424: ARRAY
113425: PPUSH
113426: CALL_OW 314
113430: NOT
113431: IFFALSE 113486
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
113433: LD_VAR 0 4
113437: PUSH
113438: LD_VAR 0 7
113442: ARRAY
113443: PPUSH
113444: LD_VAR 0 16
113448: PUSH
113449: LD_VAR 0 7
113453: ARRAY
113454: PUSH
113455: LD_INT 1
113457: ARRAY
113458: PUSH
113459: LD_INT 1
113461: ARRAY
113462: PPUSH
113463: LD_VAR 0 16
113467: PUSH
113468: LD_VAR 0 7
113472: ARRAY
113473: PUSH
113474: LD_INT 1
113476: ARRAY
113477: PUSH
113478: LD_INT 2
113480: ARRAY
113481: PPUSH
113482: CALL_OW 114
// end else
113486: GO 113539
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
113488: LD_ADDR_VAR 0 15
113492: PUSH
113493: LD_VAR 0 16
113497: PUSH
113498: LD_VAR 0 7
113502: ARRAY
113503: PPUSH
113504: LD_INT 1
113506: PPUSH
113507: CALL_OW 3
113511: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
113512: LD_ADDR_VAR 0 16
113516: PUSH
113517: LD_VAR 0 16
113521: PPUSH
113522: LD_VAR 0 7
113526: PPUSH
113527: LD_VAR 0 15
113531: PPUSH
113532: CALL_OW 1
113536: ST_TO_ADDR
// continue ;
113537: GO 112082
// end ; end ; end else
113539: GO 116203
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
113541: LD_ADDR_VAR 0 14
113545: PUSH
113546: LD_INT 81
113548: PUSH
113549: LD_VAR 0 4
113553: PUSH
113554: LD_VAR 0 7
113558: ARRAY
113559: PPUSH
113560: CALL_OW 255
113564: PUSH
113565: EMPTY
113566: LIST
113567: LIST
113568: PPUSH
113569: CALL_OW 69
113573: ST_TO_ADDR
// if not tmp then
113574: LD_VAR 0 14
113578: NOT
113579: IFFALSE 113583
// continue ;
113581: GO 112082
// if f_ignore_area then
113583: LD_VAR 0 17
113587: IFFALSE 113675
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
113589: LD_ADDR_VAR 0 15
113593: PUSH
113594: LD_VAR 0 14
113598: PPUSH
113599: LD_INT 3
113601: PUSH
113602: LD_INT 92
113604: PUSH
113605: LD_VAR 0 17
113609: PUSH
113610: LD_INT 1
113612: ARRAY
113613: PUSH
113614: LD_VAR 0 17
113618: PUSH
113619: LD_INT 2
113621: ARRAY
113622: PUSH
113623: LD_VAR 0 17
113627: PUSH
113628: LD_INT 3
113630: ARRAY
113631: PUSH
113632: EMPTY
113633: LIST
113634: LIST
113635: LIST
113636: LIST
113637: PUSH
113638: EMPTY
113639: LIST
113640: LIST
113641: PPUSH
113642: CALL_OW 72
113646: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
113647: LD_VAR 0 14
113651: PUSH
113652: LD_VAR 0 15
113656: DIFF
113657: IFFALSE 113675
// tmp := tmp diff tmp2 ;
113659: LD_ADDR_VAR 0 14
113663: PUSH
113664: LD_VAR 0 14
113668: PUSH
113669: LD_VAR 0 15
113673: DIFF
113674: ST_TO_ADDR
// end ; if not f_murder then
113675: LD_VAR 0 20
113679: NOT
113680: IFFALSE 113738
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
113682: LD_ADDR_VAR 0 15
113686: PUSH
113687: LD_VAR 0 14
113691: PPUSH
113692: LD_INT 3
113694: PUSH
113695: LD_INT 50
113697: PUSH
113698: EMPTY
113699: LIST
113700: PUSH
113701: EMPTY
113702: LIST
113703: LIST
113704: PPUSH
113705: CALL_OW 72
113709: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
113710: LD_VAR 0 14
113714: PUSH
113715: LD_VAR 0 15
113719: DIFF
113720: IFFALSE 113738
// tmp := tmp diff tmp2 ;
113722: LD_ADDR_VAR 0 14
113726: PUSH
113727: LD_VAR 0 14
113731: PUSH
113732: LD_VAR 0 15
113736: DIFF
113737: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
113738: LD_ADDR_VAR 0 14
113742: PUSH
113743: LD_VAR 0 4
113747: PUSH
113748: LD_VAR 0 7
113752: ARRAY
113753: PPUSH
113754: LD_VAR 0 14
113758: PPUSH
113759: LD_INT 1
113761: PPUSH
113762: LD_INT 1
113764: PPUSH
113765: CALL 22673 0 4
113769: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
113770: LD_VAR 0 4
113774: PUSH
113775: LD_VAR 0 7
113779: ARRAY
113780: PPUSH
113781: CALL_OW 257
113785: PUSH
113786: LD_INT 1
113788: EQUAL
113789: IFFALSE 114237
// begin if WantPlant ( group [ i ] ) then
113791: LD_VAR 0 4
113795: PUSH
113796: LD_VAR 0 7
113800: ARRAY
113801: PPUSH
113802: CALL 22174 0 1
113806: IFFALSE 113810
// continue ;
113808: GO 112082
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
113810: LD_VAR 0 18
113814: PUSH
113815: LD_VAR 0 4
113819: PUSH
113820: LD_VAR 0 7
113824: ARRAY
113825: PPUSH
113826: CALL_OW 310
113830: NOT
113831: AND
113832: PUSH
113833: LD_VAR 0 14
113837: PUSH
113838: LD_INT 1
113840: ARRAY
113841: PUSH
113842: LD_VAR 0 14
113846: PPUSH
113847: LD_INT 21
113849: PUSH
113850: LD_INT 2
113852: PUSH
113853: EMPTY
113854: LIST
113855: LIST
113856: PUSH
113857: LD_INT 58
113859: PUSH
113860: EMPTY
113861: LIST
113862: PUSH
113863: EMPTY
113864: LIST
113865: LIST
113866: PPUSH
113867: CALL_OW 72
113871: IN
113872: AND
113873: IFFALSE 113909
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
113875: LD_VAR 0 4
113879: PUSH
113880: LD_VAR 0 7
113884: ARRAY
113885: PPUSH
113886: LD_VAR 0 14
113890: PUSH
113891: LD_INT 1
113893: ARRAY
113894: PPUSH
113895: CALL_OW 120
// attacking := true ;
113899: LD_ADDR_VAR 0 29
113903: PUSH
113904: LD_INT 1
113906: ST_TO_ADDR
// continue ;
113907: GO 112082
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
113909: LD_VAR 0 26
113913: PUSH
113914: LD_VAR 0 4
113918: PUSH
113919: LD_VAR 0 7
113923: ARRAY
113924: PPUSH
113925: CALL_OW 257
113929: PUSH
113930: LD_INT 1
113932: EQUAL
113933: AND
113934: PUSH
113935: LD_VAR 0 4
113939: PUSH
113940: LD_VAR 0 7
113944: ARRAY
113945: PPUSH
113946: CALL_OW 256
113950: PUSH
113951: LD_INT 800
113953: LESS
113954: AND
113955: PUSH
113956: LD_VAR 0 4
113960: PUSH
113961: LD_VAR 0 7
113965: ARRAY
113966: PPUSH
113967: CALL_OW 318
113971: NOT
113972: AND
113973: IFFALSE 113990
// ComCrawl ( group [ i ] ) ;
113975: LD_VAR 0 4
113979: PUSH
113980: LD_VAR 0 7
113984: ARRAY
113985: PPUSH
113986: CALL_OW 137
// if f_mines then
113990: LD_VAR 0 21
113994: IFFALSE 114237
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
113996: LD_VAR 0 14
114000: PUSH
114001: LD_INT 1
114003: ARRAY
114004: PPUSH
114005: CALL_OW 247
114009: PUSH
114010: LD_INT 3
114012: EQUAL
114013: PUSH
114014: LD_VAR 0 14
114018: PUSH
114019: LD_INT 1
114021: ARRAY
114022: PUSH
114023: LD_VAR 0 27
114027: IN
114028: NOT
114029: AND
114030: IFFALSE 114237
// begin x := GetX ( tmp [ 1 ] ) ;
114032: LD_ADDR_VAR 0 10
114036: PUSH
114037: LD_VAR 0 14
114041: PUSH
114042: LD_INT 1
114044: ARRAY
114045: PPUSH
114046: CALL_OW 250
114050: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
114051: LD_ADDR_VAR 0 11
114055: PUSH
114056: LD_VAR 0 14
114060: PUSH
114061: LD_INT 1
114063: ARRAY
114064: PPUSH
114065: CALL_OW 251
114069: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
114070: LD_ADDR_VAR 0 12
114074: PUSH
114075: LD_VAR 0 4
114079: PUSH
114080: LD_VAR 0 7
114084: ARRAY
114085: PPUSH
114086: CALL 50214 0 1
114090: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
114091: LD_VAR 0 4
114095: PUSH
114096: LD_VAR 0 7
114100: ARRAY
114101: PPUSH
114102: LD_VAR 0 10
114106: PPUSH
114107: LD_VAR 0 11
114111: PPUSH
114112: LD_VAR 0 14
114116: PUSH
114117: LD_INT 1
114119: ARRAY
114120: PPUSH
114121: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
114125: LD_VAR 0 4
114129: PUSH
114130: LD_VAR 0 7
114134: ARRAY
114135: PPUSH
114136: LD_VAR 0 10
114140: PPUSH
114141: LD_VAR 0 12
114145: PPUSH
114146: LD_INT 7
114148: PPUSH
114149: CALL_OW 272
114153: PPUSH
114154: LD_VAR 0 11
114158: PPUSH
114159: LD_VAR 0 12
114163: PPUSH
114164: LD_INT 7
114166: PPUSH
114167: CALL_OW 273
114171: PPUSH
114172: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
114176: LD_VAR 0 4
114180: PUSH
114181: LD_VAR 0 7
114185: ARRAY
114186: PPUSH
114187: LD_INT 71
114189: PPUSH
114190: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
114194: LD_ADDR_VAR 0 27
114198: PUSH
114199: LD_VAR 0 27
114203: PPUSH
114204: LD_VAR 0 27
114208: PUSH
114209: LD_INT 1
114211: PLUS
114212: PPUSH
114213: LD_VAR 0 14
114217: PUSH
114218: LD_INT 1
114220: ARRAY
114221: PPUSH
114222: CALL_OW 1
114226: ST_TO_ADDR
// attacking := true ;
114227: LD_ADDR_VAR 0 29
114231: PUSH
114232: LD_INT 1
114234: ST_TO_ADDR
// continue ;
114235: GO 112082
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
114237: LD_VAR 0 4
114241: PUSH
114242: LD_VAR 0 7
114246: ARRAY
114247: PPUSH
114248: CALL_OW 257
114252: PUSH
114253: LD_INT 17
114255: EQUAL
114256: PUSH
114257: LD_VAR 0 4
114261: PUSH
114262: LD_VAR 0 7
114266: ARRAY
114267: PPUSH
114268: CALL_OW 110
114272: PUSH
114273: LD_INT 71
114275: EQUAL
114276: NOT
114277: AND
114278: IFFALSE 114424
// begin attacking := false ;
114280: LD_ADDR_VAR 0 29
114284: PUSH
114285: LD_INT 0
114287: ST_TO_ADDR
// k := 5 ;
114288: LD_ADDR_VAR 0 9
114292: PUSH
114293: LD_INT 5
114295: ST_TO_ADDR
// if tmp < k then
114296: LD_VAR 0 14
114300: PUSH
114301: LD_VAR 0 9
114305: LESS
114306: IFFALSE 114318
// k := tmp ;
114308: LD_ADDR_VAR 0 9
114312: PUSH
114313: LD_VAR 0 14
114317: ST_TO_ADDR
// for j = 1 to k do
114318: LD_ADDR_VAR 0 8
114322: PUSH
114323: DOUBLE
114324: LD_INT 1
114326: DEC
114327: ST_TO_ADDR
114328: LD_VAR 0 9
114332: PUSH
114333: FOR_TO
114334: IFFALSE 114422
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
114336: LD_VAR 0 14
114340: PUSH
114341: LD_VAR 0 8
114345: ARRAY
114346: PUSH
114347: LD_VAR 0 14
114351: PPUSH
114352: LD_INT 58
114354: PUSH
114355: EMPTY
114356: LIST
114357: PPUSH
114358: CALL_OW 72
114362: IN
114363: NOT
114364: IFFALSE 114420
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114366: LD_VAR 0 4
114370: PUSH
114371: LD_VAR 0 7
114375: ARRAY
114376: PPUSH
114377: LD_VAR 0 14
114381: PUSH
114382: LD_VAR 0 8
114386: ARRAY
114387: PPUSH
114388: CALL_OW 115
// attacking := true ;
114392: LD_ADDR_VAR 0 29
114396: PUSH
114397: LD_INT 1
114399: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
114400: LD_VAR 0 4
114404: PUSH
114405: LD_VAR 0 7
114409: ARRAY
114410: PPUSH
114411: LD_INT 71
114413: PPUSH
114414: CALL_OW 109
// continue ;
114418: GO 114333
// end ; end ;
114420: GO 114333
114422: POP
114423: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
114424: LD_VAR 0 4
114428: PUSH
114429: LD_VAR 0 7
114433: ARRAY
114434: PPUSH
114435: CALL_OW 257
114439: PUSH
114440: LD_INT 8
114442: EQUAL
114443: PUSH
114444: LD_VAR 0 4
114448: PUSH
114449: LD_VAR 0 7
114453: ARRAY
114454: PPUSH
114455: CALL_OW 264
114459: PUSH
114460: LD_INT 28
114462: PUSH
114463: LD_INT 45
114465: PUSH
114466: LD_INT 7
114468: PUSH
114469: LD_INT 47
114471: PUSH
114472: EMPTY
114473: LIST
114474: LIST
114475: LIST
114476: LIST
114477: IN
114478: OR
114479: IFFALSE 114735
// begin attacking := false ;
114481: LD_ADDR_VAR 0 29
114485: PUSH
114486: LD_INT 0
114488: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
114489: LD_VAR 0 14
114493: PUSH
114494: LD_INT 1
114496: ARRAY
114497: PPUSH
114498: CALL_OW 266
114502: PUSH
114503: LD_INT 32
114505: PUSH
114506: LD_INT 31
114508: PUSH
114509: LD_INT 33
114511: PUSH
114512: LD_INT 4
114514: PUSH
114515: LD_INT 5
114517: PUSH
114518: EMPTY
114519: LIST
114520: LIST
114521: LIST
114522: LIST
114523: LIST
114524: IN
114525: IFFALSE 114711
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
114527: LD_ADDR_VAR 0 9
114531: PUSH
114532: LD_VAR 0 14
114536: PUSH
114537: LD_INT 1
114539: ARRAY
114540: PPUSH
114541: CALL_OW 266
114545: PPUSH
114546: LD_VAR 0 14
114550: PUSH
114551: LD_INT 1
114553: ARRAY
114554: PPUSH
114555: CALL_OW 250
114559: PPUSH
114560: LD_VAR 0 14
114564: PUSH
114565: LD_INT 1
114567: ARRAY
114568: PPUSH
114569: CALL_OW 251
114573: PPUSH
114574: LD_VAR 0 14
114578: PUSH
114579: LD_INT 1
114581: ARRAY
114582: PPUSH
114583: CALL_OW 254
114587: PPUSH
114588: LD_VAR 0 14
114592: PUSH
114593: LD_INT 1
114595: ARRAY
114596: PPUSH
114597: CALL_OW 248
114601: PPUSH
114602: LD_INT 0
114604: PPUSH
114605: CALL 31584 0 6
114609: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
114610: LD_ADDR_VAR 0 8
114614: PUSH
114615: LD_VAR 0 4
114619: PUSH
114620: LD_VAR 0 7
114624: ARRAY
114625: PPUSH
114626: LD_VAR 0 9
114630: PPUSH
114631: CALL 50327 0 2
114635: ST_TO_ADDR
// if j then
114636: LD_VAR 0 8
114640: IFFALSE 114709
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
114642: LD_VAR 0 8
114646: PUSH
114647: LD_INT 1
114649: ARRAY
114650: PPUSH
114651: LD_VAR 0 8
114655: PUSH
114656: LD_INT 2
114658: ARRAY
114659: PPUSH
114660: CALL_OW 488
114664: IFFALSE 114709
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
114666: LD_VAR 0 4
114670: PUSH
114671: LD_VAR 0 7
114675: ARRAY
114676: PPUSH
114677: LD_VAR 0 8
114681: PUSH
114682: LD_INT 1
114684: ARRAY
114685: PPUSH
114686: LD_VAR 0 8
114690: PUSH
114691: LD_INT 2
114693: ARRAY
114694: PPUSH
114695: CALL_OW 116
// attacking := true ;
114699: LD_ADDR_VAR 0 29
114703: PUSH
114704: LD_INT 1
114706: ST_TO_ADDR
// continue ;
114707: GO 112082
// end ; end else
114709: GO 114735
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114711: LD_VAR 0 4
114715: PUSH
114716: LD_VAR 0 7
114720: ARRAY
114721: PPUSH
114722: LD_VAR 0 14
114726: PUSH
114727: LD_INT 1
114729: ARRAY
114730: PPUSH
114731: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
114735: LD_VAR 0 4
114739: PUSH
114740: LD_VAR 0 7
114744: ARRAY
114745: PPUSH
114746: CALL_OW 265
114750: PUSH
114751: LD_INT 11
114753: EQUAL
114754: IFFALSE 115032
// begin k := 10 ;
114756: LD_ADDR_VAR 0 9
114760: PUSH
114761: LD_INT 10
114763: ST_TO_ADDR
// x := 0 ;
114764: LD_ADDR_VAR 0 10
114768: PUSH
114769: LD_INT 0
114771: ST_TO_ADDR
// if tmp < k then
114772: LD_VAR 0 14
114776: PUSH
114777: LD_VAR 0 9
114781: LESS
114782: IFFALSE 114794
// k := tmp ;
114784: LD_ADDR_VAR 0 9
114788: PUSH
114789: LD_VAR 0 14
114793: ST_TO_ADDR
// for j = k downto 1 do
114794: LD_ADDR_VAR 0 8
114798: PUSH
114799: DOUBLE
114800: LD_VAR 0 9
114804: INC
114805: ST_TO_ADDR
114806: LD_INT 1
114808: PUSH
114809: FOR_DOWNTO
114810: IFFALSE 114885
// begin if GetType ( tmp [ j ] ) = unit_human then
114812: LD_VAR 0 14
114816: PUSH
114817: LD_VAR 0 8
114821: ARRAY
114822: PPUSH
114823: CALL_OW 247
114827: PUSH
114828: LD_INT 1
114830: EQUAL
114831: IFFALSE 114883
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
114833: LD_VAR 0 4
114837: PUSH
114838: LD_VAR 0 7
114842: ARRAY
114843: PPUSH
114844: LD_VAR 0 14
114848: PUSH
114849: LD_VAR 0 8
114853: ARRAY
114854: PPUSH
114855: CALL 50581 0 2
// x := tmp [ j ] ;
114859: LD_ADDR_VAR 0 10
114863: PUSH
114864: LD_VAR 0 14
114868: PUSH
114869: LD_VAR 0 8
114873: ARRAY
114874: ST_TO_ADDR
// attacking := true ;
114875: LD_ADDR_VAR 0 29
114879: PUSH
114880: LD_INT 1
114882: ST_TO_ADDR
// end ; end ;
114883: GO 114809
114885: POP
114886: POP
// if not x then
114887: LD_VAR 0 10
114891: NOT
114892: IFFALSE 115032
// begin attacking := true ;
114894: LD_ADDR_VAR 0 29
114898: PUSH
114899: LD_INT 1
114901: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
114902: LD_VAR 0 4
114906: PUSH
114907: LD_VAR 0 7
114911: ARRAY
114912: PPUSH
114913: CALL_OW 250
114917: PPUSH
114918: LD_VAR 0 4
114922: PUSH
114923: LD_VAR 0 7
114927: ARRAY
114928: PPUSH
114929: CALL_OW 251
114933: PPUSH
114934: CALL_OW 546
114938: PUSH
114939: LD_INT 2
114941: ARRAY
114942: PUSH
114943: LD_VAR 0 14
114947: PUSH
114948: LD_INT 1
114950: ARRAY
114951: PPUSH
114952: CALL_OW 250
114956: PPUSH
114957: LD_VAR 0 14
114961: PUSH
114962: LD_INT 1
114964: ARRAY
114965: PPUSH
114966: CALL_OW 251
114970: PPUSH
114971: CALL_OW 546
114975: PUSH
114976: LD_INT 2
114978: ARRAY
114979: EQUAL
114980: IFFALSE 115008
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
114982: LD_VAR 0 4
114986: PUSH
114987: LD_VAR 0 7
114991: ARRAY
114992: PPUSH
114993: LD_VAR 0 14
114997: PUSH
114998: LD_INT 1
115000: ARRAY
115001: PPUSH
115002: CALL 50581 0 2
115006: GO 115032
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115008: LD_VAR 0 4
115012: PUSH
115013: LD_VAR 0 7
115017: ARRAY
115018: PPUSH
115019: LD_VAR 0 14
115023: PUSH
115024: LD_INT 1
115026: ARRAY
115027: PPUSH
115028: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
115032: LD_VAR 0 4
115036: PUSH
115037: LD_VAR 0 7
115041: ARRAY
115042: PPUSH
115043: CALL_OW 264
115047: PUSH
115048: LD_INT 29
115050: EQUAL
115051: IFFALSE 115417
// begin if WantsToAttack ( group [ i ] ) in bombed then
115053: LD_VAR 0 4
115057: PUSH
115058: LD_VAR 0 7
115062: ARRAY
115063: PPUSH
115064: CALL_OW 319
115068: PUSH
115069: LD_VAR 0 28
115073: IN
115074: IFFALSE 115078
// continue ;
115076: GO 112082
// k := 8 ;
115078: LD_ADDR_VAR 0 9
115082: PUSH
115083: LD_INT 8
115085: ST_TO_ADDR
// x := 0 ;
115086: LD_ADDR_VAR 0 10
115090: PUSH
115091: LD_INT 0
115093: ST_TO_ADDR
// if tmp < k then
115094: LD_VAR 0 14
115098: PUSH
115099: LD_VAR 0 9
115103: LESS
115104: IFFALSE 115116
// k := tmp ;
115106: LD_ADDR_VAR 0 9
115110: PUSH
115111: LD_VAR 0 14
115115: ST_TO_ADDR
// for j = 1 to k do
115116: LD_ADDR_VAR 0 8
115120: PUSH
115121: DOUBLE
115122: LD_INT 1
115124: DEC
115125: ST_TO_ADDR
115126: LD_VAR 0 9
115130: PUSH
115131: FOR_TO
115132: IFFALSE 115264
// begin if GetType ( tmp [ j ] ) = unit_building then
115134: LD_VAR 0 14
115138: PUSH
115139: LD_VAR 0 8
115143: ARRAY
115144: PPUSH
115145: CALL_OW 247
115149: PUSH
115150: LD_INT 3
115152: EQUAL
115153: IFFALSE 115262
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
115155: LD_VAR 0 14
115159: PUSH
115160: LD_VAR 0 8
115164: ARRAY
115165: PUSH
115166: LD_VAR 0 28
115170: IN
115171: NOT
115172: PUSH
115173: LD_VAR 0 14
115177: PUSH
115178: LD_VAR 0 8
115182: ARRAY
115183: PPUSH
115184: CALL_OW 313
115188: AND
115189: IFFALSE 115262
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115191: LD_VAR 0 4
115195: PUSH
115196: LD_VAR 0 7
115200: ARRAY
115201: PPUSH
115202: LD_VAR 0 14
115206: PUSH
115207: LD_VAR 0 8
115211: ARRAY
115212: PPUSH
115213: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
115217: LD_ADDR_VAR 0 28
115221: PUSH
115222: LD_VAR 0 28
115226: PPUSH
115227: LD_VAR 0 28
115231: PUSH
115232: LD_INT 1
115234: PLUS
115235: PPUSH
115236: LD_VAR 0 14
115240: PUSH
115241: LD_VAR 0 8
115245: ARRAY
115246: PPUSH
115247: CALL_OW 1
115251: ST_TO_ADDR
// attacking := true ;
115252: LD_ADDR_VAR 0 29
115256: PUSH
115257: LD_INT 1
115259: ST_TO_ADDR
// break ;
115260: GO 115264
// end ; end ;
115262: GO 115131
115264: POP
115265: POP
// if not attacking and f_attack_depot then
115266: LD_VAR 0 29
115270: NOT
115271: PUSH
115272: LD_VAR 0 25
115276: AND
115277: IFFALSE 115372
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115279: LD_ADDR_VAR 0 13
115283: PUSH
115284: LD_VAR 0 14
115288: PPUSH
115289: LD_INT 2
115291: PUSH
115292: LD_INT 30
115294: PUSH
115295: LD_INT 0
115297: PUSH
115298: EMPTY
115299: LIST
115300: LIST
115301: PUSH
115302: LD_INT 30
115304: PUSH
115305: LD_INT 1
115307: PUSH
115308: EMPTY
115309: LIST
115310: LIST
115311: PUSH
115312: EMPTY
115313: LIST
115314: LIST
115315: LIST
115316: PPUSH
115317: CALL_OW 72
115321: ST_TO_ADDR
// if z then
115322: LD_VAR 0 13
115326: IFFALSE 115372
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
115328: LD_VAR 0 4
115332: PUSH
115333: LD_VAR 0 7
115337: ARRAY
115338: PPUSH
115339: LD_VAR 0 13
115343: PPUSH
115344: LD_VAR 0 4
115348: PUSH
115349: LD_VAR 0 7
115353: ARRAY
115354: PPUSH
115355: CALL_OW 74
115359: PPUSH
115360: CALL_OW 115
// attacking := true ;
115364: LD_ADDR_VAR 0 29
115368: PUSH
115369: LD_INT 1
115371: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
115372: LD_VAR 0 4
115376: PUSH
115377: LD_VAR 0 7
115381: ARRAY
115382: PPUSH
115383: CALL_OW 256
115387: PUSH
115388: LD_INT 500
115390: LESS
115391: IFFALSE 115417
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115393: LD_VAR 0 4
115397: PUSH
115398: LD_VAR 0 7
115402: ARRAY
115403: PPUSH
115404: LD_VAR 0 14
115408: PUSH
115409: LD_INT 1
115411: ARRAY
115412: PPUSH
115413: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
115417: LD_VAR 0 4
115421: PUSH
115422: LD_VAR 0 7
115426: ARRAY
115427: PPUSH
115428: CALL_OW 264
115432: PUSH
115433: LD_INT 49
115435: EQUAL
115436: IFFALSE 115557
// begin if not HasTask ( group [ i ] ) then
115438: LD_VAR 0 4
115442: PUSH
115443: LD_VAR 0 7
115447: ARRAY
115448: PPUSH
115449: CALL_OW 314
115453: NOT
115454: IFFALSE 115557
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
115456: LD_ADDR_VAR 0 9
115460: PUSH
115461: LD_INT 81
115463: PUSH
115464: LD_VAR 0 4
115468: PUSH
115469: LD_VAR 0 7
115473: ARRAY
115474: PPUSH
115475: CALL_OW 255
115479: PUSH
115480: EMPTY
115481: LIST
115482: LIST
115483: PPUSH
115484: CALL_OW 69
115488: PPUSH
115489: LD_VAR 0 4
115493: PUSH
115494: LD_VAR 0 7
115498: ARRAY
115499: PPUSH
115500: CALL_OW 74
115504: ST_TO_ADDR
// if k then
115505: LD_VAR 0 9
115509: IFFALSE 115557
// if GetDistUnits ( group [ i ] , k ) > 10 then
115511: LD_VAR 0 4
115515: PUSH
115516: LD_VAR 0 7
115520: ARRAY
115521: PPUSH
115522: LD_VAR 0 9
115526: PPUSH
115527: CALL_OW 296
115531: PUSH
115532: LD_INT 10
115534: GREATER
115535: IFFALSE 115557
// ComMoveUnit ( group [ i ] , k ) ;
115537: LD_VAR 0 4
115541: PUSH
115542: LD_VAR 0 7
115546: ARRAY
115547: PPUSH
115548: LD_VAR 0 9
115552: PPUSH
115553: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
115557: LD_VAR 0 4
115561: PUSH
115562: LD_VAR 0 7
115566: ARRAY
115567: PPUSH
115568: CALL_OW 256
115572: PUSH
115573: LD_INT 250
115575: LESS
115576: PUSH
115577: LD_VAR 0 4
115581: PUSH
115582: LD_VAR 0 7
115586: ARRAY
115587: PUSH
115588: LD_INT 21
115590: PUSH
115591: LD_INT 2
115593: PUSH
115594: EMPTY
115595: LIST
115596: LIST
115597: PUSH
115598: LD_INT 23
115600: PUSH
115601: LD_INT 2
115603: PUSH
115604: EMPTY
115605: LIST
115606: LIST
115607: PUSH
115608: EMPTY
115609: LIST
115610: LIST
115611: PPUSH
115612: CALL_OW 69
115616: IN
115617: AND
115618: IFFALSE 115743
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
115620: LD_ADDR_VAR 0 9
115624: PUSH
115625: LD_OWVAR 3
115629: PUSH
115630: LD_VAR 0 4
115634: PUSH
115635: LD_VAR 0 7
115639: ARRAY
115640: DIFF
115641: PPUSH
115642: LD_VAR 0 4
115646: PUSH
115647: LD_VAR 0 7
115651: ARRAY
115652: PPUSH
115653: CALL_OW 74
115657: ST_TO_ADDR
// if not k then
115658: LD_VAR 0 9
115662: NOT
115663: IFFALSE 115667
// continue ;
115665: GO 112082
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
115667: LD_VAR 0 9
115671: PUSH
115672: LD_INT 81
115674: PUSH
115675: LD_VAR 0 4
115679: PUSH
115680: LD_VAR 0 7
115684: ARRAY
115685: PPUSH
115686: CALL_OW 255
115690: PUSH
115691: EMPTY
115692: LIST
115693: LIST
115694: PPUSH
115695: CALL_OW 69
115699: IN
115700: PUSH
115701: LD_VAR 0 9
115705: PPUSH
115706: LD_VAR 0 4
115710: PUSH
115711: LD_VAR 0 7
115715: ARRAY
115716: PPUSH
115717: CALL_OW 296
115721: PUSH
115722: LD_INT 5
115724: LESS
115725: AND
115726: IFFALSE 115743
// ComAutodestruct ( group [ i ] ) ;
115728: LD_VAR 0 4
115732: PUSH
115733: LD_VAR 0 7
115737: ARRAY
115738: PPUSH
115739: CALL 50479 0 1
// end ; if f_attack_depot then
115743: LD_VAR 0 25
115747: IFFALSE 115859
// begin k := 6 ;
115749: LD_ADDR_VAR 0 9
115753: PUSH
115754: LD_INT 6
115756: ST_TO_ADDR
// if tmp < k then
115757: LD_VAR 0 14
115761: PUSH
115762: LD_VAR 0 9
115766: LESS
115767: IFFALSE 115779
// k := tmp ;
115769: LD_ADDR_VAR 0 9
115773: PUSH
115774: LD_VAR 0 14
115778: ST_TO_ADDR
// for j = 1 to k do
115779: LD_ADDR_VAR 0 8
115783: PUSH
115784: DOUBLE
115785: LD_INT 1
115787: DEC
115788: ST_TO_ADDR
115789: LD_VAR 0 9
115793: PUSH
115794: FOR_TO
115795: IFFALSE 115857
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
115797: LD_VAR 0 8
115801: PPUSH
115802: CALL_OW 266
115806: PUSH
115807: LD_INT 0
115809: PUSH
115810: LD_INT 1
115812: PUSH
115813: EMPTY
115814: LIST
115815: LIST
115816: IN
115817: IFFALSE 115855
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115819: LD_VAR 0 4
115823: PUSH
115824: LD_VAR 0 7
115828: ARRAY
115829: PPUSH
115830: LD_VAR 0 14
115834: PUSH
115835: LD_VAR 0 8
115839: ARRAY
115840: PPUSH
115841: CALL_OW 115
// attacking := true ;
115845: LD_ADDR_VAR 0 29
115849: PUSH
115850: LD_INT 1
115852: ST_TO_ADDR
// break ;
115853: GO 115857
// end ;
115855: GO 115794
115857: POP
115858: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
115859: LD_VAR 0 4
115863: PUSH
115864: LD_VAR 0 7
115868: ARRAY
115869: PPUSH
115870: CALL_OW 302
115874: PUSH
115875: LD_VAR 0 29
115879: NOT
115880: AND
115881: IFFALSE 116203
// begin if GetTag ( group [ i ] ) = 71 then
115883: LD_VAR 0 4
115887: PUSH
115888: LD_VAR 0 7
115892: ARRAY
115893: PPUSH
115894: CALL_OW 110
115898: PUSH
115899: LD_INT 71
115901: EQUAL
115902: IFFALSE 115943
// begin if HasTask ( group [ i ] ) then
115904: LD_VAR 0 4
115908: PUSH
115909: LD_VAR 0 7
115913: ARRAY
115914: PPUSH
115915: CALL_OW 314
115919: IFFALSE 115925
// continue else
115921: GO 112082
115923: GO 115943
// SetTag ( group [ i ] , 0 ) ;
115925: LD_VAR 0 4
115929: PUSH
115930: LD_VAR 0 7
115934: ARRAY
115935: PPUSH
115936: LD_INT 0
115938: PPUSH
115939: CALL_OW 109
// end ; k := 8 ;
115943: LD_ADDR_VAR 0 9
115947: PUSH
115948: LD_INT 8
115950: ST_TO_ADDR
// x := 0 ;
115951: LD_ADDR_VAR 0 10
115955: PUSH
115956: LD_INT 0
115958: ST_TO_ADDR
// if tmp < k then
115959: LD_VAR 0 14
115963: PUSH
115964: LD_VAR 0 9
115968: LESS
115969: IFFALSE 115981
// k := tmp ;
115971: LD_ADDR_VAR 0 9
115975: PUSH
115976: LD_VAR 0 14
115980: ST_TO_ADDR
// for j = 1 to k do
115981: LD_ADDR_VAR 0 8
115985: PUSH
115986: DOUBLE
115987: LD_INT 1
115989: DEC
115990: ST_TO_ADDR
115991: LD_VAR 0 9
115995: PUSH
115996: FOR_TO
115997: IFFALSE 116095
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
115999: LD_VAR 0 14
116003: PUSH
116004: LD_VAR 0 8
116008: ARRAY
116009: PPUSH
116010: CALL_OW 247
116014: PUSH
116015: LD_INT 1
116017: EQUAL
116018: PUSH
116019: LD_VAR 0 14
116023: PUSH
116024: LD_VAR 0 8
116028: ARRAY
116029: PPUSH
116030: CALL_OW 256
116034: PUSH
116035: LD_INT 250
116037: LESS
116038: PUSH
116039: LD_VAR 0 20
116043: AND
116044: PUSH
116045: LD_VAR 0 20
116049: NOT
116050: PUSH
116051: LD_VAR 0 14
116055: PUSH
116056: LD_VAR 0 8
116060: ARRAY
116061: PPUSH
116062: CALL_OW 256
116066: PUSH
116067: LD_INT 250
116069: GREATEREQUAL
116070: AND
116071: OR
116072: AND
116073: IFFALSE 116093
// begin x := tmp [ j ] ;
116075: LD_ADDR_VAR 0 10
116079: PUSH
116080: LD_VAR 0 14
116084: PUSH
116085: LD_VAR 0 8
116089: ARRAY
116090: ST_TO_ADDR
// break ;
116091: GO 116095
// end ;
116093: GO 115996
116095: POP
116096: POP
// if x then
116097: LD_VAR 0 10
116101: IFFALSE 116125
// ComAttackUnit ( group [ i ] , x ) else
116103: LD_VAR 0 4
116107: PUSH
116108: LD_VAR 0 7
116112: ARRAY
116113: PPUSH
116114: LD_VAR 0 10
116118: PPUSH
116119: CALL_OW 115
116123: GO 116149
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116125: LD_VAR 0 4
116129: PUSH
116130: LD_VAR 0 7
116134: ARRAY
116135: PPUSH
116136: LD_VAR 0 14
116140: PUSH
116141: LD_INT 1
116143: ARRAY
116144: PPUSH
116145: CALL_OW 115
// if not HasTask ( group [ i ] ) then
116149: LD_VAR 0 4
116153: PUSH
116154: LD_VAR 0 7
116158: ARRAY
116159: PPUSH
116160: CALL_OW 314
116164: NOT
116165: IFFALSE 116203
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
116167: LD_VAR 0 4
116171: PUSH
116172: LD_VAR 0 7
116176: ARRAY
116177: PPUSH
116178: LD_VAR 0 14
116182: PPUSH
116183: LD_VAR 0 4
116187: PUSH
116188: LD_VAR 0 7
116192: ARRAY
116193: PPUSH
116194: CALL_OW 74
116198: PPUSH
116199: CALL_OW 115
// end ; end ; end ;
116203: GO 112082
116205: POP
116206: POP
// wait ( 0 0$2 ) ;
116207: LD_INT 70
116209: PPUSH
116210: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
116214: LD_VAR 0 4
116218: NOT
116219: PUSH
116220: LD_VAR 0 4
116224: PUSH
116225: EMPTY
116226: EQUAL
116227: OR
116228: PUSH
116229: LD_INT 81
116231: PUSH
116232: LD_VAR 0 35
116236: PUSH
116237: EMPTY
116238: LIST
116239: LIST
116240: PPUSH
116241: CALL_OW 69
116245: NOT
116246: OR
116247: IFFALSE 112067
// end ;
116249: LD_VAR 0 2
116253: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
116254: LD_INT 0
116256: PPUSH
116257: PPUSH
116258: PPUSH
116259: PPUSH
116260: PPUSH
116261: PPUSH
// if not base or not mc_bases [ base ] or not solds then
116262: LD_VAR 0 1
116266: NOT
116267: PUSH
116268: LD_EXP 63
116272: PUSH
116273: LD_VAR 0 1
116277: ARRAY
116278: NOT
116279: OR
116280: PUSH
116281: LD_VAR 0 2
116285: NOT
116286: OR
116287: IFFALSE 116291
// exit ;
116289: GO 116845
// side := mc_sides [ base ] ;
116291: LD_ADDR_VAR 0 6
116295: PUSH
116296: LD_EXP 89
116300: PUSH
116301: LD_VAR 0 1
116305: ARRAY
116306: ST_TO_ADDR
// if not side then
116307: LD_VAR 0 6
116311: NOT
116312: IFFALSE 116316
// exit ;
116314: GO 116845
// for i in solds do
116316: LD_ADDR_VAR 0 7
116320: PUSH
116321: LD_VAR 0 2
116325: PUSH
116326: FOR_IN
116327: IFFALSE 116388
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
116329: LD_VAR 0 7
116333: PPUSH
116334: CALL_OW 310
116338: PPUSH
116339: CALL_OW 266
116343: PUSH
116344: LD_INT 32
116346: PUSH
116347: LD_INT 31
116349: PUSH
116350: EMPTY
116351: LIST
116352: LIST
116353: IN
116354: IFFALSE 116374
// solds := solds diff i else
116356: LD_ADDR_VAR 0 2
116360: PUSH
116361: LD_VAR 0 2
116365: PUSH
116366: LD_VAR 0 7
116370: DIFF
116371: ST_TO_ADDR
116372: GO 116386
// SetTag ( i , 18 ) ;
116374: LD_VAR 0 7
116378: PPUSH
116379: LD_INT 18
116381: PPUSH
116382: CALL_OW 109
116386: GO 116326
116388: POP
116389: POP
// if not solds then
116390: LD_VAR 0 2
116394: NOT
116395: IFFALSE 116399
// exit ;
116397: GO 116845
// repeat wait ( 0 0$2 ) ;
116399: LD_INT 70
116401: PPUSH
116402: CALL_OW 67
// enemy := mc_scan [ base ] ;
116406: LD_ADDR_VAR 0 4
116410: PUSH
116411: LD_EXP 86
116415: PUSH
116416: LD_VAR 0 1
116420: ARRAY
116421: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116422: LD_EXP 63
116426: PUSH
116427: LD_VAR 0 1
116431: ARRAY
116432: NOT
116433: PUSH
116434: LD_EXP 63
116438: PUSH
116439: LD_VAR 0 1
116443: ARRAY
116444: PUSH
116445: EMPTY
116446: EQUAL
116447: OR
116448: IFFALSE 116485
// begin for i in solds do
116450: LD_ADDR_VAR 0 7
116454: PUSH
116455: LD_VAR 0 2
116459: PUSH
116460: FOR_IN
116461: IFFALSE 116474
// ComStop ( i ) ;
116463: LD_VAR 0 7
116467: PPUSH
116468: CALL_OW 141
116472: GO 116460
116474: POP
116475: POP
// solds := [ ] ;
116476: LD_ADDR_VAR 0 2
116480: PUSH
116481: EMPTY
116482: ST_TO_ADDR
// exit ;
116483: GO 116845
// end ; for i in solds do
116485: LD_ADDR_VAR 0 7
116489: PUSH
116490: LD_VAR 0 2
116494: PUSH
116495: FOR_IN
116496: IFFALSE 116817
// begin if IsInUnit ( i ) then
116498: LD_VAR 0 7
116502: PPUSH
116503: CALL_OW 310
116507: IFFALSE 116518
// ComExitBuilding ( i ) ;
116509: LD_VAR 0 7
116513: PPUSH
116514: CALL_OW 122
// if GetLives ( i ) > 500 then
116518: LD_VAR 0 7
116522: PPUSH
116523: CALL_OW 256
116527: PUSH
116528: LD_INT 500
116530: GREATER
116531: IFFALSE 116584
// begin e := NearestUnitToUnit ( enemy , i ) ;
116533: LD_ADDR_VAR 0 5
116537: PUSH
116538: LD_VAR 0 4
116542: PPUSH
116543: LD_VAR 0 7
116547: PPUSH
116548: CALL_OW 74
116552: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
116553: LD_VAR 0 7
116557: PPUSH
116558: LD_VAR 0 5
116562: PPUSH
116563: CALL_OW 250
116567: PPUSH
116568: LD_VAR 0 5
116572: PPUSH
116573: CALL_OW 251
116577: PPUSH
116578: CALL_OW 114
// end else
116582: GO 116815
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
116584: LD_VAR 0 7
116588: PPUSH
116589: LD_EXP 63
116593: PUSH
116594: LD_VAR 0 1
116598: ARRAY
116599: PPUSH
116600: LD_INT 2
116602: PUSH
116603: LD_INT 30
116605: PUSH
116606: LD_INT 0
116608: PUSH
116609: EMPTY
116610: LIST
116611: LIST
116612: PUSH
116613: LD_INT 30
116615: PUSH
116616: LD_INT 1
116618: PUSH
116619: EMPTY
116620: LIST
116621: LIST
116622: PUSH
116623: LD_INT 30
116625: PUSH
116626: LD_INT 6
116628: PUSH
116629: EMPTY
116630: LIST
116631: LIST
116632: PUSH
116633: EMPTY
116634: LIST
116635: LIST
116636: LIST
116637: LIST
116638: PPUSH
116639: CALL_OW 72
116643: PPUSH
116644: LD_VAR 0 7
116648: PPUSH
116649: CALL_OW 74
116653: PPUSH
116654: CALL_OW 296
116658: PUSH
116659: LD_INT 10
116661: GREATER
116662: IFFALSE 116815
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
116664: LD_ADDR_VAR 0 8
116668: PUSH
116669: LD_EXP 63
116673: PUSH
116674: LD_VAR 0 1
116678: ARRAY
116679: PPUSH
116680: LD_INT 2
116682: PUSH
116683: LD_INT 30
116685: PUSH
116686: LD_INT 0
116688: PUSH
116689: EMPTY
116690: LIST
116691: LIST
116692: PUSH
116693: LD_INT 30
116695: PUSH
116696: LD_INT 1
116698: PUSH
116699: EMPTY
116700: LIST
116701: LIST
116702: PUSH
116703: LD_INT 30
116705: PUSH
116706: LD_INT 6
116708: PUSH
116709: EMPTY
116710: LIST
116711: LIST
116712: PUSH
116713: EMPTY
116714: LIST
116715: LIST
116716: LIST
116717: LIST
116718: PPUSH
116719: CALL_OW 72
116723: PPUSH
116724: LD_VAR 0 7
116728: PPUSH
116729: CALL_OW 74
116733: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
116734: LD_VAR 0 7
116738: PPUSH
116739: LD_VAR 0 8
116743: PPUSH
116744: CALL_OW 250
116748: PPUSH
116749: LD_INT 3
116751: PPUSH
116752: LD_INT 5
116754: PPUSH
116755: CALL_OW 272
116759: PPUSH
116760: LD_VAR 0 8
116764: PPUSH
116765: CALL_OW 251
116769: PPUSH
116770: LD_INT 3
116772: PPUSH
116773: LD_INT 5
116775: PPUSH
116776: CALL_OW 273
116780: PPUSH
116781: CALL_OW 111
// SetTag ( i , 0 ) ;
116785: LD_VAR 0 7
116789: PPUSH
116790: LD_INT 0
116792: PPUSH
116793: CALL_OW 109
// solds := solds diff i ;
116797: LD_ADDR_VAR 0 2
116801: PUSH
116802: LD_VAR 0 2
116806: PUSH
116807: LD_VAR 0 7
116811: DIFF
116812: ST_TO_ADDR
// continue ;
116813: GO 116495
// end ; end ;
116815: GO 116495
116817: POP
116818: POP
// until not solds or not enemy ;
116819: LD_VAR 0 2
116823: NOT
116824: PUSH
116825: LD_VAR 0 4
116829: NOT
116830: OR
116831: IFFALSE 116399
// MC_Reset ( base , 18 ) ;
116833: LD_VAR 0 1
116837: PPUSH
116838: LD_INT 18
116840: PPUSH
116841: CALL 64220 0 2
// end ;
116845: LD_VAR 0 3
116849: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
116850: LD_INT 0
116852: PPUSH
116853: PPUSH
116854: PPUSH
116855: PPUSH
116856: PPUSH
116857: PPUSH
116858: PPUSH
116859: PPUSH
116860: PPUSH
116861: PPUSH
116862: PPUSH
116863: PPUSH
116864: PPUSH
116865: PPUSH
116866: PPUSH
116867: PPUSH
116868: PPUSH
116869: PPUSH
116870: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
116871: LD_ADDR_VAR 0 12
116875: PUSH
116876: LD_EXP 63
116880: PUSH
116881: LD_VAR 0 1
116885: ARRAY
116886: PPUSH
116887: LD_INT 25
116889: PUSH
116890: LD_INT 3
116892: PUSH
116893: EMPTY
116894: LIST
116895: LIST
116896: PPUSH
116897: CALL_OW 72
116901: ST_TO_ADDR
// if mc_remote_driver [ base ] then
116902: LD_EXP 103
116906: PUSH
116907: LD_VAR 0 1
116911: ARRAY
116912: IFFALSE 116936
// mechs := mechs diff mc_remote_driver [ base ] ;
116914: LD_ADDR_VAR 0 12
116918: PUSH
116919: LD_VAR 0 12
116923: PUSH
116924: LD_EXP 103
116928: PUSH
116929: LD_VAR 0 1
116933: ARRAY
116934: DIFF
116935: ST_TO_ADDR
// for i in mechs do
116936: LD_ADDR_VAR 0 4
116940: PUSH
116941: LD_VAR 0 12
116945: PUSH
116946: FOR_IN
116947: IFFALSE 116982
// if GetTag ( i ) > 0 then
116949: LD_VAR 0 4
116953: PPUSH
116954: CALL_OW 110
116958: PUSH
116959: LD_INT 0
116961: GREATER
116962: IFFALSE 116980
// mechs := mechs diff i ;
116964: LD_ADDR_VAR 0 12
116968: PUSH
116969: LD_VAR 0 12
116973: PUSH
116974: LD_VAR 0 4
116978: DIFF
116979: ST_TO_ADDR
116980: GO 116946
116982: POP
116983: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116984: LD_ADDR_VAR 0 8
116988: PUSH
116989: LD_EXP 63
116993: PUSH
116994: LD_VAR 0 1
116998: ARRAY
116999: PPUSH
117000: LD_INT 2
117002: PUSH
117003: LD_INT 25
117005: PUSH
117006: LD_INT 1
117008: PUSH
117009: EMPTY
117010: LIST
117011: LIST
117012: PUSH
117013: LD_INT 25
117015: PUSH
117016: LD_INT 5
117018: PUSH
117019: EMPTY
117020: LIST
117021: LIST
117022: PUSH
117023: LD_INT 25
117025: PUSH
117026: LD_INT 8
117028: PUSH
117029: EMPTY
117030: LIST
117031: LIST
117032: PUSH
117033: LD_INT 25
117035: PUSH
117036: LD_INT 9
117038: PUSH
117039: EMPTY
117040: LIST
117041: LIST
117042: PUSH
117043: EMPTY
117044: LIST
117045: LIST
117046: LIST
117047: LIST
117048: LIST
117049: PPUSH
117050: CALL_OW 72
117054: ST_TO_ADDR
// if not defenders and not solds then
117055: LD_VAR 0 2
117059: NOT
117060: PUSH
117061: LD_VAR 0 8
117065: NOT
117066: AND
117067: IFFALSE 117071
// exit ;
117069: GO 118841
// depot_under_attack := false ;
117071: LD_ADDR_VAR 0 16
117075: PUSH
117076: LD_INT 0
117078: ST_TO_ADDR
// sold_defenders := [ ] ;
117079: LD_ADDR_VAR 0 17
117083: PUSH
117084: EMPTY
117085: ST_TO_ADDR
// if mechs then
117086: LD_VAR 0 12
117090: IFFALSE 117243
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
117092: LD_ADDR_VAR 0 4
117096: PUSH
117097: LD_VAR 0 2
117101: PPUSH
117102: LD_INT 21
117104: PUSH
117105: LD_INT 2
117107: PUSH
117108: EMPTY
117109: LIST
117110: LIST
117111: PPUSH
117112: CALL_OW 72
117116: PUSH
117117: FOR_IN
117118: IFFALSE 117241
// begin if GetTag ( i ) <> 20 then
117120: LD_VAR 0 4
117124: PPUSH
117125: CALL_OW 110
117129: PUSH
117130: LD_INT 20
117132: NONEQUAL
117133: IFFALSE 117147
// SetTag ( i , 20 ) ;
117135: LD_VAR 0 4
117139: PPUSH
117140: LD_INT 20
117142: PPUSH
117143: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
117147: LD_VAR 0 4
117151: PPUSH
117152: CALL_OW 263
117156: PUSH
117157: LD_INT 1
117159: EQUAL
117160: PUSH
117161: LD_VAR 0 4
117165: PPUSH
117166: CALL_OW 311
117170: NOT
117171: AND
117172: IFFALSE 117239
// begin un := mechs [ 1 ] ;
117174: LD_ADDR_VAR 0 10
117178: PUSH
117179: LD_VAR 0 12
117183: PUSH
117184: LD_INT 1
117186: ARRAY
117187: ST_TO_ADDR
// ComExit ( un ) ;
117188: LD_VAR 0 10
117192: PPUSH
117193: CALL 55365 0 1
// AddComEnterUnit ( un , i ) ;
117197: LD_VAR 0 10
117201: PPUSH
117202: LD_VAR 0 4
117206: PPUSH
117207: CALL_OW 180
// SetTag ( un , 19 ) ;
117211: LD_VAR 0 10
117215: PPUSH
117216: LD_INT 19
117218: PPUSH
117219: CALL_OW 109
// mechs := mechs diff un ;
117223: LD_ADDR_VAR 0 12
117227: PUSH
117228: LD_VAR 0 12
117232: PUSH
117233: LD_VAR 0 10
117237: DIFF
117238: ST_TO_ADDR
// end ; end ;
117239: GO 117117
117241: POP
117242: POP
// if solds then
117243: LD_VAR 0 8
117247: IFFALSE 117306
// for i in solds do
117249: LD_ADDR_VAR 0 4
117253: PUSH
117254: LD_VAR 0 8
117258: PUSH
117259: FOR_IN
117260: IFFALSE 117304
// if not GetTag ( i ) then
117262: LD_VAR 0 4
117266: PPUSH
117267: CALL_OW 110
117271: NOT
117272: IFFALSE 117302
// begin defenders := defenders union i ;
117274: LD_ADDR_VAR 0 2
117278: PUSH
117279: LD_VAR 0 2
117283: PUSH
117284: LD_VAR 0 4
117288: UNION
117289: ST_TO_ADDR
// SetTag ( i , 18 ) ;
117290: LD_VAR 0 4
117294: PPUSH
117295: LD_INT 18
117297: PPUSH
117298: CALL_OW 109
// end ;
117302: GO 117259
117304: POP
117305: POP
// repeat wait ( 0 0$2 ) ;
117306: LD_INT 70
117308: PPUSH
117309: CALL_OW 67
// enemy := mc_scan [ base ] ;
117313: LD_ADDR_VAR 0 21
117317: PUSH
117318: LD_EXP 86
117322: PUSH
117323: LD_VAR 0 1
117327: ARRAY
117328: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117329: LD_EXP 63
117333: PUSH
117334: LD_VAR 0 1
117338: ARRAY
117339: NOT
117340: PUSH
117341: LD_EXP 63
117345: PUSH
117346: LD_VAR 0 1
117350: ARRAY
117351: PUSH
117352: EMPTY
117353: EQUAL
117354: OR
117355: IFFALSE 117392
// begin for i in defenders do
117357: LD_ADDR_VAR 0 4
117361: PUSH
117362: LD_VAR 0 2
117366: PUSH
117367: FOR_IN
117368: IFFALSE 117381
// ComStop ( i ) ;
117370: LD_VAR 0 4
117374: PPUSH
117375: CALL_OW 141
117379: GO 117367
117381: POP
117382: POP
// defenders := [ ] ;
117383: LD_ADDR_VAR 0 2
117387: PUSH
117388: EMPTY
117389: ST_TO_ADDR
// exit ;
117390: GO 118841
// end ; for i in defenders do
117392: LD_ADDR_VAR 0 4
117396: PUSH
117397: LD_VAR 0 2
117401: PUSH
117402: FOR_IN
117403: IFFALSE 118301
// begin e := NearestUnitToUnit ( enemy , i ) ;
117405: LD_ADDR_VAR 0 13
117409: PUSH
117410: LD_VAR 0 21
117414: PPUSH
117415: LD_VAR 0 4
117419: PPUSH
117420: CALL_OW 74
117424: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
117425: LD_ADDR_VAR 0 7
117429: PUSH
117430: LD_EXP 63
117434: PUSH
117435: LD_VAR 0 1
117439: ARRAY
117440: PPUSH
117441: LD_INT 2
117443: PUSH
117444: LD_INT 30
117446: PUSH
117447: LD_INT 0
117449: PUSH
117450: EMPTY
117451: LIST
117452: LIST
117453: PUSH
117454: LD_INT 30
117456: PUSH
117457: LD_INT 1
117459: PUSH
117460: EMPTY
117461: LIST
117462: LIST
117463: PUSH
117464: EMPTY
117465: LIST
117466: LIST
117467: LIST
117468: PPUSH
117469: CALL_OW 72
117473: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
117474: LD_ADDR_VAR 0 16
117478: PUSH
117479: LD_VAR 0 7
117483: NOT
117484: PUSH
117485: LD_VAR 0 7
117489: PPUSH
117490: LD_INT 3
117492: PUSH
117493: LD_INT 24
117495: PUSH
117496: LD_INT 600
117498: PUSH
117499: EMPTY
117500: LIST
117501: LIST
117502: PUSH
117503: EMPTY
117504: LIST
117505: LIST
117506: PPUSH
117507: CALL_OW 72
117511: OR
117512: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
117513: LD_VAR 0 4
117517: PPUSH
117518: CALL_OW 247
117522: PUSH
117523: LD_INT 2
117525: DOUBLE
117526: EQUAL
117527: IFTRUE 117531
117529: GO 117927
117531: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
117532: LD_VAR 0 4
117536: PPUSH
117537: CALL_OW 256
117541: PUSH
117542: LD_INT 1000
117544: EQUAL
117545: PUSH
117546: LD_VAR 0 4
117550: PPUSH
117551: LD_VAR 0 13
117555: PPUSH
117556: CALL_OW 296
117560: PUSH
117561: LD_INT 40
117563: LESS
117564: PUSH
117565: LD_VAR 0 13
117569: PPUSH
117570: LD_EXP 88
117574: PUSH
117575: LD_VAR 0 1
117579: ARRAY
117580: PPUSH
117581: CALL_OW 308
117585: OR
117586: AND
117587: IFFALSE 117709
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
117589: LD_VAR 0 4
117593: PPUSH
117594: CALL_OW 262
117598: PUSH
117599: LD_INT 1
117601: EQUAL
117602: PUSH
117603: LD_VAR 0 4
117607: PPUSH
117608: CALL_OW 261
117612: PUSH
117613: LD_INT 30
117615: LESS
117616: AND
117617: PUSH
117618: LD_VAR 0 7
117622: AND
117623: IFFALSE 117693
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
117625: LD_VAR 0 4
117629: PPUSH
117630: LD_VAR 0 7
117634: PPUSH
117635: LD_VAR 0 4
117639: PPUSH
117640: CALL_OW 74
117644: PPUSH
117645: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
117649: LD_VAR 0 4
117653: PPUSH
117654: LD_VAR 0 7
117658: PPUSH
117659: LD_VAR 0 4
117663: PPUSH
117664: CALL_OW 74
117668: PPUSH
117669: CALL_OW 296
117673: PUSH
117674: LD_INT 6
117676: LESS
117677: IFFALSE 117691
// SetFuel ( i , 100 ) ;
117679: LD_VAR 0 4
117683: PPUSH
117684: LD_INT 100
117686: PPUSH
117687: CALL_OW 240
// end else
117691: GO 117707
// ComAttackUnit ( i , e ) ;
117693: LD_VAR 0 4
117697: PPUSH
117698: LD_VAR 0 13
117702: PPUSH
117703: CALL_OW 115
// end else
117707: GO 117810
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
117709: LD_VAR 0 13
117713: PPUSH
117714: LD_EXP 88
117718: PUSH
117719: LD_VAR 0 1
117723: ARRAY
117724: PPUSH
117725: CALL_OW 308
117729: NOT
117730: PUSH
117731: LD_VAR 0 4
117735: PPUSH
117736: LD_VAR 0 13
117740: PPUSH
117741: CALL_OW 296
117745: PUSH
117746: LD_INT 40
117748: GREATEREQUAL
117749: AND
117750: PUSH
117751: LD_VAR 0 4
117755: PPUSH
117756: CALL_OW 256
117760: PUSH
117761: LD_INT 650
117763: LESSEQUAL
117764: OR
117765: PUSH
117766: LD_VAR 0 4
117770: PPUSH
117771: LD_EXP 87
117775: PUSH
117776: LD_VAR 0 1
117780: ARRAY
117781: PPUSH
117782: CALL_OW 308
117786: NOT
117787: AND
117788: IFFALSE 117810
// ComMoveToArea ( i , mc_parking [ base ] ) ;
117790: LD_VAR 0 4
117794: PPUSH
117795: LD_EXP 87
117799: PUSH
117800: LD_VAR 0 1
117804: ARRAY
117805: PPUSH
117806: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
117810: LD_VAR 0 4
117814: PPUSH
117815: CALL_OW 256
117819: PUSH
117820: LD_INT 1000
117822: LESS
117823: PUSH
117824: LD_VAR 0 4
117828: PPUSH
117829: CALL_OW 263
117833: PUSH
117834: LD_INT 1
117836: EQUAL
117837: AND
117838: PUSH
117839: LD_VAR 0 4
117843: PPUSH
117844: CALL_OW 311
117848: AND
117849: PUSH
117850: LD_VAR 0 4
117854: PPUSH
117855: LD_EXP 87
117859: PUSH
117860: LD_VAR 0 1
117864: ARRAY
117865: PPUSH
117866: CALL_OW 308
117870: AND
117871: IFFALSE 117925
// begin mech := IsDrivenBy ( i ) ;
117873: LD_ADDR_VAR 0 9
117877: PUSH
117878: LD_VAR 0 4
117882: PPUSH
117883: CALL_OW 311
117887: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
117888: LD_VAR 0 9
117892: PPUSH
117893: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
117897: LD_VAR 0 9
117901: PPUSH
117902: LD_VAR 0 4
117906: PPUSH
117907: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
117911: LD_VAR 0 9
117915: PPUSH
117916: LD_VAR 0 4
117920: PPUSH
117921: CALL_OW 180
// end ; end ; unit_human :
117925: GO 118272
117927: LD_INT 1
117929: DOUBLE
117930: EQUAL
117931: IFTRUE 117935
117933: GO 118271
117935: POP
// begin b := IsInUnit ( i ) ;
117936: LD_ADDR_VAR 0 18
117940: PUSH
117941: LD_VAR 0 4
117945: PPUSH
117946: CALL_OW 310
117950: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
117951: LD_ADDR_VAR 0 19
117955: PUSH
117956: LD_VAR 0 18
117960: NOT
117961: PUSH
117962: LD_VAR 0 18
117966: PPUSH
117967: CALL_OW 266
117971: PUSH
117972: LD_INT 32
117974: PUSH
117975: LD_INT 31
117977: PUSH
117978: EMPTY
117979: LIST
117980: LIST
117981: IN
117982: OR
117983: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
117984: LD_VAR 0 18
117988: PPUSH
117989: CALL_OW 266
117993: PUSH
117994: LD_INT 5
117996: EQUAL
117997: PUSH
117998: LD_VAR 0 4
118002: PPUSH
118003: CALL_OW 257
118007: PUSH
118008: LD_INT 1
118010: PUSH
118011: LD_INT 2
118013: PUSH
118014: LD_INT 3
118016: PUSH
118017: LD_INT 4
118019: PUSH
118020: EMPTY
118021: LIST
118022: LIST
118023: LIST
118024: LIST
118025: IN
118026: AND
118027: IFFALSE 118064
// begin class := AllowSpecClass ( i ) ;
118029: LD_ADDR_VAR 0 20
118033: PUSH
118034: LD_VAR 0 4
118038: PPUSH
118039: CALL 19062 0 1
118043: ST_TO_ADDR
// if class then
118044: LD_VAR 0 20
118048: IFFALSE 118064
// ComChangeProfession ( i , class ) ;
118050: LD_VAR 0 4
118054: PPUSH
118055: LD_VAR 0 20
118059: PPUSH
118060: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
118064: LD_VAR 0 16
118068: PUSH
118069: LD_VAR 0 2
118073: PPUSH
118074: LD_INT 21
118076: PUSH
118077: LD_INT 2
118079: PUSH
118080: EMPTY
118081: LIST
118082: LIST
118083: PPUSH
118084: CALL_OW 72
118088: PUSH
118089: LD_INT 1
118091: LESSEQUAL
118092: OR
118093: PUSH
118094: LD_VAR 0 19
118098: AND
118099: PUSH
118100: LD_VAR 0 4
118104: PUSH
118105: LD_VAR 0 17
118109: IN
118110: NOT
118111: AND
118112: IFFALSE 118205
// begin if b then
118114: LD_VAR 0 18
118118: IFFALSE 118167
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
118120: LD_VAR 0 18
118124: PPUSH
118125: LD_VAR 0 21
118129: PPUSH
118130: LD_VAR 0 18
118134: PPUSH
118135: CALL_OW 74
118139: PPUSH
118140: CALL_OW 296
118144: PUSH
118145: LD_INT 10
118147: LESS
118148: PUSH
118149: LD_VAR 0 18
118153: PPUSH
118154: CALL_OW 461
118158: PUSH
118159: LD_INT 7
118161: NONEQUAL
118162: AND
118163: IFFALSE 118167
// continue ;
118165: GO 117402
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
118167: LD_ADDR_VAR 0 17
118171: PUSH
118172: LD_VAR 0 17
118176: PPUSH
118177: LD_VAR 0 17
118181: PUSH
118182: LD_INT 1
118184: PLUS
118185: PPUSH
118186: LD_VAR 0 4
118190: PPUSH
118191: CALL_OW 1
118195: ST_TO_ADDR
// ComExitBuilding ( i ) ;
118196: LD_VAR 0 4
118200: PPUSH
118201: CALL_OW 122
// end ; if sold_defenders then
118205: LD_VAR 0 17
118209: IFFALSE 118269
// if i in sold_defenders then
118211: LD_VAR 0 4
118215: PUSH
118216: LD_VAR 0 17
118220: IN
118221: IFFALSE 118269
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
118223: LD_VAR 0 4
118227: PPUSH
118228: CALL_OW 314
118232: NOT
118233: PUSH
118234: LD_VAR 0 4
118238: PPUSH
118239: LD_VAR 0 13
118243: PPUSH
118244: CALL_OW 296
118248: PUSH
118249: LD_INT 30
118251: LESS
118252: AND
118253: IFFALSE 118269
// ComAttackUnit ( i , e ) ;
118255: LD_VAR 0 4
118259: PPUSH
118260: LD_VAR 0 13
118264: PPUSH
118265: CALL_OW 115
// end ; end ; end ;
118269: GO 118272
118271: POP
// if IsDead ( i ) then
118272: LD_VAR 0 4
118276: PPUSH
118277: CALL_OW 301
118281: IFFALSE 118299
// defenders := defenders diff i ;
118283: LD_ADDR_VAR 0 2
118287: PUSH
118288: LD_VAR 0 2
118292: PUSH
118293: LD_VAR 0 4
118297: DIFF
118298: ST_TO_ADDR
// end ;
118299: GO 117402
118301: POP
118302: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
118303: LD_VAR 0 21
118307: NOT
118308: PUSH
118309: LD_VAR 0 2
118313: NOT
118314: OR
118315: PUSH
118316: LD_EXP 63
118320: PUSH
118321: LD_VAR 0 1
118325: ARRAY
118326: NOT
118327: OR
118328: IFFALSE 117306
// MC_Reset ( base , 18 ) ;
118330: LD_VAR 0 1
118334: PPUSH
118335: LD_INT 18
118337: PPUSH
118338: CALL 64220 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118342: LD_ADDR_VAR 0 2
118346: PUSH
118347: LD_VAR 0 2
118351: PUSH
118352: LD_VAR 0 2
118356: PPUSH
118357: LD_INT 2
118359: PUSH
118360: LD_INT 25
118362: PUSH
118363: LD_INT 1
118365: PUSH
118366: EMPTY
118367: LIST
118368: LIST
118369: PUSH
118370: LD_INT 25
118372: PUSH
118373: LD_INT 5
118375: PUSH
118376: EMPTY
118377: LIST
118378: LIST
118379: PUSH
118380: LD_INT 25
118382: PUSH
118383: LD_INT 8
118385: PUSH
118386: EMPTY
118387: LIST
118388: LIST
118389: PUSH
118390: LD_INT 25
118392: PUSH
118393: LD_INT 9
118395: PUSH
118396: EMPTY
118397: LIST
118398: LIST
118399: PUSH
118400: EMPTY
118401: LIST
118402: LIST
118403: LIST
118404: LIST
118405: LIST
118406: PPUSH
118407: CALL_OW 72
118411: DIFF
118412: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
118413: LD_VAR 0 21
118417: NOT
118418: PUSH
118419: LD_VAR 0 2
118423: PPUSH
118424: LD_INT 21
118426: PUSH
118427: LD_INT 2
118429: PUSH
118430: EMPTY
118431: LIST
118432: LIST
118433: PPUSH
118434: CALL_OW 72
118438: AND
118439: IFFALSE 118777
// begin tmp := FilterByTag ( defenders , 19 ) ;
118441: LD_ADDR_VAR 0 11
118445: PUSH
118446: LD_VAR 0 2
118450: PPUSH
118451: LD_INT 19
118453: PPUSH
118454: CALL 52536 0 2
118458: ST_TO_ADDR
// if tmp then
118459: LD_VAR 0 11
118463: IFFALSE 118533
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
118465: LD_ADDR_VAR 0 11
118469: PUSH
118470: LD_VAR 0 11
118474: PPUSH
118475: LD_INT 25
118477: PUSH
118478: LD_INT 3
118480: PUSH
118481: EMPTY
118482: LIST
118483: LIST
118484: PPUSH
118485: CALL_OW 72
118489: ST_TO_ADDR
// if tmp then
118490: LD_VAR 0 11
118494: IFFALSE 118533
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
118496: LD_ADDR_EXP 75
118500: PUSH
118501: LD_EXP 75
118505: PPUSH
118506: LD_VAR 0 1
118510: PPUSH
118511: LD_EXP 75
118515: PUSH
118516: LD_VAR 0 1
118520: ARRAY
118521: PUSH
118522: LD_VAR 0 11
118526: UNION
118527: PPUSH
118528: CALL_OW 1
118532: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
118533: LD_VAR 0 1
118537: PPUSH
118538: LD_INT 19
118540: PPUSH
118541: CALL 64220 0 2
// repeat wait ( 0 0$1 ) ;
118545: LD_INT 35
118547: PPUSH
118548: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118552: LD_EXP 63
118556: PUSH
118557: LD_VAR 0 1
118561: ARRAY
118562: NOT
118563: PUSH
118564: LD_EXP 63
118568: PUSH
118569: LD_VAR 0 1
118573: ARRAY
118574: PUSH
118575: EMPTY
118576: EQUAL
118577: OR
118578: IFFALSE 118615
// begin for i in defenders do
118580: LD_ADDR_VAR 0 4
118584: PUSH
118585: LD_VAR 0 2
118589: PUSH
118590: FOR_IN
118591: IFFALSE 118604
// ComStop ( i ) ;
118593: LD_VAR 0 4
118597: PPUSH
118598: CALL_OW 141
118602: GO 118590
118604: POP
118605: POP
// defenders := [ ] ;
118606: LD_ADDR_VAR 0 2
118610: PUSH
118611: EMPTY
118612: ST_TO_ADDR
// exit ;
118613: GO 118841
// end ; for i in defenders do
118615: LD_ADDR_VAR 0 4
118619: PUSH
118620: LD_VAR 0 2
118624: PUSH
118625: FOR_IN
118626: IFFALSE 118715
// begin if not IsInArea ( i , mc_parking [ base ] ) then
118628: LD_VAR 0 4
118632: PPUSH
118633: LD_EXP 87
118637: PUSH
118638: LD_VAR 0 1
118642: ARRAY
118643: PPUSH
118644: CALL_OW 308
118648: NOT
118649: IFFALSE 118673
// ComMoveToArea ( i , mc_parking [ base ] ) else
118651: LD_VAR 0 4
118655: PPUSH
118656: LD_EXP 87
118660: PUSH
118661: LD_VAR 0 1
118665: ARRAY
118666: PPUSH
118667: CALL_OW 113
118671: GO 118713
// if GetControl ( i ) = control_manual then
118673: LD_VAR 0 4
118677: PPUSH
118678: CALL_OW 263
118682: PUSH
118683: LD_INT 1
118685: EQUAL
118686: IFFALSE 118713
// if IsDrivenBy ( i ) then
118688: LD_VAR 0 4
118692: PPUSH
118693: CALL_OW 311
118697: IFFALSE 118713
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
118699: LD_VAR 0 4
118703: PPUSH
118704: CALL_OW 311
118708: PPUSH
118709: CALL_OW 121
// end ;
118713: GO 118625
118715: POP
118716: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
118717: LD_VAR 0 2
118721: PPUSH
118722: LD_INT 95
118724: PUSH
118725: LD_EXP 87
118729: PUSH
118730: LD_VAR 0 1
118734: ARRAY
118735: PUSH
118736: EMPTY
118737: LIST
118738: LIST
118739: PPUSH
118740: CALL_OW 72
118744: PUSH
118745: LD_VAR 0 2
118749: EQUAL
118750: PUSH
118751: LD_EXP 86
118755: PUSH
118756: LD_VAR 0 1
118760: ARRAY
118761: OR
118762: PUSH
118763: LD_EXP 63
118767: PUSH
118768: LD_VAR 0 1
118772: ARRAY
118773: NOT
118774: OR
118775: IFFALSE 118545
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
118777: LD_ADDR_EXP 85
118781: PUSH
118782: LD_EXP 85
118786: PPUSH
118787: LD_VAR 0 1
118791: PPUSH
118792: LD_VAR 0 2
118796: PPUSH
118797: LD_INT 21
118799: PUSH
118800: LD_INT 2
118802: PUSH
118803: EMPTY
118804: LIST
118805: LIST
118806: PPUSH
118807: CALL_OW 72
118811: PPUSH
118812: CALL_OW 1
118816: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
118817: LD_VAR 0 1
118821: PPUSH
118822: LD_INT 19
118824: PPUSH
118825: CALL 64220 0 2
// MC_Reset ( base , 20 ) ;
118829: LD_VAR 0 1
118833: PPUSH
118834: LD_INT 20
118836: PPUSH
118837: CALL 64220 0 2
// end ; end_of_file
118841: LD_VAR 0 3
118845: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
118846: LD_VAR 0 1
118850: PUSH
118851: LD_INT 200
118853: DOUBLE
118854: GREATEREQUAL
118855: IFFALSE 118863
118857: LD_INT 299
118859: DOUBLE
118860: LESSEQUAL
118861: IFTRUE 118865
118863: GO 118897
118865: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
118866: LD_VAR 0 1
118870: PPUSH
118871: LD_VAR 0 2
118875: PPUSH
118876: LD_VAR 0 3
118880: PPUSH
118881: LD_VAR 0 4
118885: PPUSH
118886: LD_VAR 0 5
118890: PPUSH
118891: CALL 107027 0 5
118895: GO 118974
118897: LD_INT 300
118899: DOUBLE
118900: GREATEREQUAL
118901: IFFALSE 118909
118903: LD_INT 399
118905: DOUBLE
118906: LESSEQUAL
118907: IFTRUE 118911
118909: GO 118973
118911: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
118912: LD_VAR 0 1
118916: PPUSH
118917: LD_VAR 0 2
118921: PPUSH
118922: LD_VAR 0 3
118926: PPUSH
118927: LD_VAR 0 4
118931: PPUSH
118932: LD_VAR 0 5
118936: PPUSH
118937: LD_VAR 0 6
118941: PPUSH
118942: LD_VAR 0 7
118946: PPUSH
118947: LD_VAR 0 8
118951: PPUSH
118952: LD_VAR 0 9
118956: PPUSH
118957: LD_VAR 0 10
118961: PPUSH
118962: LD_VAR 0 11
118966: PPUSH
118967: CALL 103279 0 11
118971: GO 118974
118973: POP
// end ;
118974: PPOPN 11
118976: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
118977: LD_VAR 0 1
118981: PPUSH
118982: LD_VAR 0 2
118986: PPUSH
118987: LD_VAR 0 3
118991: PPUSH
118992: LD_VAR 0 4
118996: PPUSH
118997: LD_VAR 0 5
119001: PPUSH
119002: CALL 106690 0 5
// end ; end_of_file
119006: PPOPN 5
119008: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
119009: LD_VAR 0 1
119013: PPUSH
119014: LD_VAR 0 2
119018: PPUSH
119019: LD_VAR 0 3
119023: PPUSH
119024: LD_VAR 0 4
119028: PPUSH
119029: LD_VAR 0 5
119033: PPUSH
119034: LD_VAR 0 6
119038: PPUSH
119039: CALL 90931 0 6
// end ;
119043: PPOPN 6
119045: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
119046: LD_INT 0
119048: PPUSH
// begin if not units then
119049: LD_VAR 0 1
119053: NOT
119054: IFFALSE 119058
// exit ;
119056: GO 119058
// end ;
119058: PPOPN 7
119060: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
119061: CALL 90818 0 0
// end ;
119065: PPOPN 1
119067: END
