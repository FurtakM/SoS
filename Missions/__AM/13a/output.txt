// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 619 0 0
// InitMacro ;
  19: CALL 57457 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 49198 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 49198 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 49198 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 49198 0 9
// PrepareArabian ;
 147: CALL 3690 0 0
// PrepareRussian ;
 151: CALL 2825 0 0
// PrepareAlliance ;
 155: CALL 821 0 0
// MC_Start ( ) ;
 159: CALL 59569 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6853 0 0
// end ;
 180: END
// export function CustomInitMacro ; var i ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 185: LD_ADDR_EXP 83
 189: PUSH
 190: LD_INT 1
 192: PUSH
 193: LD_INT 2
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 200: LD_ADDR_EXP 84
 204: PUSH
 205: LD_INT 3
 207: PUSH
 208: LD_INT 4
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 215: LD_INT 1
 217: PPUSH
 218: LD_INT 12
 220: PUSH
 221: LD_INT 15
 223: PUSH
 224: LD_INT 18
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: PUSH
 232: LD_OWVAR 67
 236: ARRAY
 237: PPUSH
 238: LD_INT 7
 240: PPUSH
 241: CALL 80786 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 245: LD_INT 1
 247: PPUSH
 248: LD_EXP 54
 252: PPUSH
 253: CALL 81212 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 257: LD_INT 1
 259: PPUSH
 260: LD_INT 6
 262: PPUSH
 263: CALL 81670 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 267: LD_INT 1
 269: PPUSH
 270: LD_INT 9
 272: PUSH
 273: EMPTY
 274: LIST
 275: PPUSH
 276: CALL 81939 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 13
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 2
 291: PUSH
 292: LD_INT 32
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: PUSH
 301: EMPTY
 302: LIST
 303: PPUSH
 304: CALL 81152 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 308: LD_INT 2
 310: PPUSH
 311: LD_INT 12
 313: PUSH
 314: LD_INT 14
 316: PUSH
 317: LD_INT 10
 319: PUSH
 320: LD_INT 11
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 81846 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_EXP 51
 340: PPUSH
 341: CALL 81212 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 345: LD_INT 2
 347: PPUSH
 348: LD_INT 8
 350: PPUSH
 351: CALL 81670 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 355: LD_INT 2
 357: PPUSH
 358: LD_INT 10
 360: PUSH
 361: EMPTY
 362: LIST
 363: PPUSH
 364: CALL 81939 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 368: LD_INT 2
 370: PPUSH
 371: LD_INT 6
 373: PUSH
 374: LD_INT 71
 376: PUSH
 377: LD_INT 116
 379: PUSH
 380: LD_INT 4
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_INT 4
 391: PUSH
 392: LD_INT 85
 394: PUSH
 395: LD_INT 116
 397: PUSH
 398: LD_INT 4
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: LD_INT 32
 409: PUSH
 410: LD_INT 83
 412: PUSH
 413: LD_INT 111
 415: PUSH
 416: LD_INT 4
 418: PUSH
 419: EMPTY
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: PUSH
 425: LD_INT 32
 427: PUSH
 428: LD_INT 87
 430: PUSH
 431: LD_INT 121
 433: PUSH
 434: LD_INT 4
 436: PUSH
 437: EMPTY
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 88
 448: PUSH
 449: LD_INT 128
 451: PUSH
 452: LD_INT 4
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: PUSH
 461: LD_INT 32
 463: PUSH
 464: LD_INT 59
 466: PUSH
 467: LD_INT 89
 469: PUSH
 470: LD_INT 3
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_INT 33
 481: PUSH
 482: LD_INT 69
 484: PUSH
 485: LD_INT 98
 487: PUSH
 488: LD_INT 3
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: PUSH
 497: LD_INT 33
 499: PUSH
 500: LD_INT 77
 502: PUSH
 503: LD_INT 103
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 33
 517: PUSH
 518: LD_INT 83
 520: PUSH
 521: LD_INT 105
 523: PUSH
 524: LD_INT 3
 526: PUSH
 527: EMPTY
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 33
 535: PUSH
 536: LD_INT 71
 538: PUSH
 539: LD_INT 125
 541: PUSH
 542: LD_INT 5
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PPUSH
 563: CALL 80996 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 567: LD_INT 2
 569: PPUSH
 570: LD_INT 21
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 3
 578: PUSH
 579: LD_INT 51
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PUSH
 588: LD_INT 22
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 3
 596: PUSH
 597: LD_INT 52
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: PPUSH
 610: CALL 81152 0 2
// end ;
 614: LD_VAR 0 1
 618: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 619: LD_INT 0
 621: PPUSH
// debug := 0 ;
 622: LD_ADDR_EXP 1
 626: PUSH
 627: LD_INT 0
 629: ST_TO_ADDR
// game := true ;
 630: LD_ADDR_EXP 2
 634: PUSH
 635: LD_INT 1
 637: ST_TO_ADDR
// gossudarov_arrive := false ;
 638: LD_ADDR_EXP 4
 642: PUSH
 643: LD_INT 0
 645: ST_TO_ADDR
// ru_lab_builded := false ;
 646: LD_ADDR_EXP 5
 650: PUSH
 651: LD_INT 0
 653: ST_TO_ADDR
// player_spotted := false ;
 654: LD_ADDR_EXP 6
 658: PUSH
 659: LD_INT 0
 661: ST_TO_ADDR
// first_attack := false ;
 662: LD_ADDR_EXP 7
 666: PUSH
 667: LD_INT 0
 669: ST_TO_ADDR
// ru_attackers := [ ] ;
 670: LD_ADDR_EXP 52
 674: PUSH
 675: EMPTY
 676: ST_TO_ADDR
// ar_base_spotted := false ;
 677: LD_ADDR_EXP 8
 681: PUSH
 682: LD_INT 0
 684: ST_TO_ADDR
// ar_active_attack := false ;
 685: LD_ADDR_EXP 9
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// ar_attackers := [ ] ;
 693: LD_ADDR_EXP 10
 697: PUSH
 698: EMPTY
 699: ST_TO_ADDR
// first_powell_attack := false ;
 700: LD_ADDR_EXP 11
 704: PUSH
 705: LD_INT 0
 707: ST_TO_ADDR
// abdul_escaped := true ;
 708: LD_ADDR_EXP 12
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// loss_counter := 0 ;
 716: LD_ADDR_EXP 13
 720: PUSH
 721: LD_INT 0
 723: ST_TO_ADDR
// hack_counter := 0 ;
 724: LD_ADDR_EXP 14
 728: PUSH
 729: LD_INT 0
 731: ST_TO_ADDR
// end ;
 732: LD_VAR 0 1
 736: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 737: LD_EXP 48
 741: PPUSH
 742: CALL_OW 255
 746: PUSH
 747: LD_INT 7
 749: EQUAL
 750: PUSH
 751: LD_EXP 47
 755: PPUSH
 756: CALL_OW 255
 760: PUSH
 761: LD_INT 7
 763: EQUAL
 764: AND
 765: PUSH
 766: LD_EXP 48
 770: PPUSH
 771: CALL_OW 302
 775: AND
 776: PUSH
 777: LD_EXP 47
 781: PPUSH
 782: CALL_OW 302
 786: AND
 787: IFFALSE 799
 789: GO 791
 791: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 792: LD_STRING ACH_COMRADE
 794: PPUSH
 795: CALL_OW 543
 799: END
// every 0 0$1 trigger hack_counter >= 10 do
 800: LD_EXP 14
 804: PUSH
 805: LD_INT 10
 807: GREATEREQUAL
 808: IFFALSE 820
 810: GO 812
 812: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 813: LD_STRING ACH_HACK
 815: PPUSH
 816: CALL_OW 543
 820: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 821: LD_INT 0
 823: PPUSH
 824: PPUSH
 825: PPUSH
 826: PPUSH
// uc_side := 7 ;
 827: LD_ADDR_OWVAR 20
 831: PUSH
 832: LD_INT 7
 834: ST_TO_ADDR
// uc_nation := 1 ;
 835: LD_ADDR_OWVAR 21
 839: PUSH
 840: LD_INT 1
 842: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 843: LD_ADDR_EXP 15
 847: PUSH
 848: LD_STRING JMM
 850: PPUSH
 851: LD_EXP 1
 855: NOT
 856: PPUSH
 857: LD_STRING 12a_
 859: PPUSH
 860: CALL 14292 0 3
 864: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 865: LD_EXP 15
 869: PPUSH
 870: LD_INT 71
 872: PPUSH
 873: LD_INT 23
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 883: LD_EXP 15
 887: PPUSH
 888: LD_INT 2
 890: PPUSH
 891: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 895: LD_ADDR_EXP 16
 899: PUSH
 900: LD_STRING Roth
 902: PPUSH
 903: LD_EXP 1
 907: NOT
 908: PPUSH
 909: LD_STRING 12a_
 911: PPUSH
 912: CALL 14292 0 3
 916: ST_TO_ADDR
// if Roth then
 917: LD_EXP 16
 921: IFFALSE 941
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 923: LD_EXP 16
 927: PPUSH
 928: LD_INT 71
 930: PPUSH
 931: LD_INT 21
 933: PPUSH
 934: LD_INT 0
 936: PPUSH
 937: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 941: LD_ADDR_EXP 17
 945: PUSH
 946: LD_STRING Lisa
 948: PPUSH
 949: LD_EXP 1
 953: NOT
 954: PPUSH
 955: LD_STRING 12a_
 957: PPUSH
 958: CALL 14292 0 3
 962: ST_TO_ADDR
// if Lisa then
 963: LD_EXP 17
 967: IFFALSE 984
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 969: LD_EXP 17
 973: PPUSH
 974: LD_INT 13
 976: PPUSH
 977: LD_INT 0
 979: PPUSH
 980: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 984: LD_ADDR_EXP 18
 988: PUSH
 989: LD_STRING Donaldson
 991: PPUSH
 992: LD_EXP 1
 996: NOT
 997: PPUSH
 998: LD_STRING 12a_
1000: PPUSH
1001: CALL 14292 0 3
1005: ST_TO_ADDR
// if Donaldson then
1006: LD_EXP 18
1010: IFFALSE 1027
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1012: LD_EXP 18
1016: PPUSH
1017: LD_INT 13
1019: PPUSH
1020: LD_INT 0
1022: PPUSH
1023: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1027: LD_ADDR_EXP 19
1031: PUSH
1032: LD_STRING Bobby
1034: PPUSH
1035: LD_EXP 1
1039: NOT
1040: PPUSH
1041: LD_STRING 12a_
1043: PPUSH
1044: CALL 14292 0 3
1048: ST_TO_ADDR
// if Bobby then
1049: LD_EXP 19
1053: IFFALSE 1070
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1055: LD_EXP 19
1059: PPUSH
1060: LD_INT 13
1062: PPUSH
1063: LD_INT 0
1065: PPUSH
1066: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1070: LD_ADDR_EXP 20
1074: PUSH
1075: LD_STRING Cyrus
1077: PPUSH
1078: LD_EXP 1
1082: NOT
1083: PPUSH
1084: LD_STRING 12a_
1086: PPUSH
1087: CALL 14292 0 3
1091: ST_TO_ADDR
// if Cyrus then
1092: LD_EXP 20
1096: IFFALSE 1113
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1098: LD_EXP 20
1102: PPUSH
1103: LD_INT 13
1105: PPUSH
1106: LD_INT 0
1108: PPUSH
1109: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1113: LD_ADDR_EXP 21
1117: PUSH
1118: LD_STRING Denis
1120: PPUSH
1121: LD_EXP 1
1125: NOT
1126: PPUSH
1127: LD_STRING 12a_
1129: PPUSH
1130: CALL 14292 0 3
1134: ST_TO_ADDR
// if Denis then
1135: LD_EXP 21
1139: IFFALSE 1156
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1141: LD_EXP 21
1145: PPUSH
1146: LD_INT 13
1148: PPUSH
1149: LD_INT 0
1151: PPUSH
1152: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1156: LD_ADDR_EXP 22
1160: PUSH
1161: LD_STRING Brown
1163: PPUSH
1164: LD_EXP 1
1168: NOT
1169: PPUSH
1170: LD_STRING 12a_
1172: PPUSH
1173: CALL 14292 0 3
1177: ST_TO_ADDR
// if Brown then
1178: LD_EXP 22
1182: IFFALSE 1199
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1184: LD_EXP 22
1188: PPUSH
1189: LD_INT 13
1191: PPUSH
1192: LD_INT 0
1194: PPUSH
1195: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1199: LD_ADDR_EXP 23
1203: PUSH
1204: LD_STRING Gladstone
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: LD_STRING 12a_
1215: PPUSH
1216: CALL 14292 0 3
1220: ST_TO_ADDR
// if Gladstone then
1221: LD_EXP 23
1225: IFFALSE 1242
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1227: LD_EXP 23
1231: PPUSH
1232: LD_INT 13
1234: PPUSH
1235: LD_INT 0
1237: PPUSH
1238: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1242: LD_ADDR_EXP 24
1246: PUSH
1247: LD_STRING Houten
1249: PPUSH
1250: LD_EXP 1
1254: NOT
1255: PPUSH
1256: LD_STRING 12a_
1258: PPUSH
1259: CALL 14292 0 3
1263: ST_TO_ADDR
// if Houten then
1264: LD_EXP 24
1268: IFFALSE 1285
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1270: LD_EXP 24
1274: PPUSH
1275: LD_INT 13
1277: PPUSH
1278: LD_INT 0
1280: PPUSH
1281: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1285: LD_ADDR_EXP 25
1289: PUSH
1290: LD_STRING Cornell
1292: PPUSH
1293: LD_EXP 1
1297: NOT
1298: PPUSH
1299: LD_STRING 12a_
1301: PPUSH
1302: CALL 14292 0 3
1306: ST_TO_ADDR
// if Cornel then
1307: LD_EXP 25
1311: IFFALSE 1328
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1313: LD_EXP 25
1317: PPUSH
1318: LD_INT 13
1320: PPUSH
1321: LD_INT 0
1323: PPUSH
1324: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1328: LD_ADDR_EXP 26
1332: PUSH
1333: LD_STRING Gary
1335: PPUSH
1336: LD_EXP 1
1340: NOT
1341: PPUSH
1342: LD_STRING 12a_
1344: PPUSH
1345: CALL 14292 0 3
1349: ST_TO_ADDR
// if Gary then
1350: LD_EXP 26
1354: IFFALSE 1371
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1356: LD_EXP 26
1360: PPUSH
1361: LD_INT 13
1363: PPUSH
1364: LD_INT 0
1366: PPUSH
1367: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1371: LD_ADDR_EXP 27
1375: PUSH
1376: LD_STRING Frank
1378: PPUSH
1379: LD_EXP 1
1383: NOT
1384: PPUSH
1385: LD_STRING 12a_
1387: PPUSH
1388: CALL 14292 0 3
1392: ST_TO_ADDR
// if Frank then
1393: LD_EXP 27
1397: IFFALSE 1414
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1399: LD_EXP 27
1403: PPUSH
1404: LD_INT 13
1406: PPUSH
1407: LD_INT 0
1409: PPUSH
1410: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1414: LD_ADDR_EXP 28
1418: PUSH
1419: LD_STRING Kikuchi
1421: PPUSH
1422: LD_EXP 1
1426: NOT
1427: PPUSH
1428: LD_STRING 12a_
1430: PPUSH
1431: CALL 14292 0 3
1435: ST_TO_ADDR
// if Kikuchi then
1436: LD_EXP 28
1440: IFFALSE 1457
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1442: LD_EXP 28
1446: PPUSH
1447: LD_INT 13
1449: PPUSH
1450: LD_INT 0
1452: PPUSH
1453: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1457: LD_ADDR_EXP 29
1461: PUSH
1462: LD_STRING Simms
1464: PPUSH
1465: LD_EXP 1
1469: NOT
1470: PPUSH
1471: LD_STRING 12a_
1473: PPUSH
1474: CALL 14292 0 3
1478: ST_TO_ADDR
// if Simms then
1479: LD_EXP 29
1483: IFFALSE 1500
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1485: LD_EXP 29
1489: PPUSH
1490: LD_INT 13
1492: PPUSH
1493: LD_INT 0
1495: PPUSH
1496: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1500: LD_ADDR_EXP 30
1504: PUSH
1505: LD_STRING Joan
1507: PPUSH
1508: LD_EXP 1
1512: NOT
1513: PPUSH
1514: LD_STRING 12a_
1516: PPUSH
1517: CALL 14292 0 3
1521: ST_TO_ADDR
// if Joan then
1522: LD_EXP 30
1526: IFFALSE 1543
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1528: LD_EXP 30
1532: PPUSH
1533: LD_INT 13
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1543: LD_ADDR_EXP 31
1547: PUSH
1548: LD_STRING DeltaDoctor
1550: PPUSH
1551: LD_EXP 1
1555: NOT
1556: PPUSH
1557: LD_STRING 12a_
1559: PPUSH
1560: CALL 14292 0 3
1564: ST_TO_ADDR
// if DeltaDoctor then
1565: LD_EXP 31
1569: IFFALSE 1586
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1571: LD_EXP 31
1575: PPUSH
1576: LD_INT 13
1578: PPUSH
1579: LD_INT 0
1581: PPUSH
1582: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1586: LD_ADDR_VAR 0 4
1590: PUSH
1591: LD_STRING 12a_others
1593: PPUSH
1594: CALL_OW 31
1598: ST_TO_ADDR
// if tmp then
1599: LD_VAR 0 4
1603: IFFALSE 1637
// for i in tmp do
1605: LD_ADDR_VAR 0 3
1609: PUSH
1610: LD_VAR 0 4
1614: PUSH
1615: FOR_IN
1616: IFFALSE 1635
// PlaceUnitArea ( i , alliance_start , false ) ;
1618: LD_VAR 0 3
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
1633: GO 1615
1635: POP
1636: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 3
1642: PPUSH
1643: LD_INT 3
1645: PPUSH
1646: LD_INT 12
1648: PPUSH
1649: LD_INT 100
1651: PPUSH
1652: CALL 21407 0 5
// veh := CreateVehicle ;
1656: LD_ADDR_VAR 0 2
1660: PUSH
1661: CALL_OW 45
1665: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1666: LD_VAR 0 2
1670: PPUSH
1671: LD_INT 2
1673: PPUSH
1674: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1678: LD_VAR 0 2
1682: PPUSH
1683: LD_INT 60
1685: PPUSH
1686: LD_INT 6
1688: PPUSH
1689: LD_INT 0
1691: PPUSH
1692: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1696: LD_VAR 0 2
1700: PPUSH
1701: LD_INT 4
1703: PPUSH
1704: LD_INT 30
1706: PPUSH
1707: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1711: LD_STRING 11_artifact_captured
1713: PPUSH
1714: LD_INT 0
1716: PPUSH
1717: CALL_OW 30
1721: IFFALSE 1797
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1723: LD_INT 3
1725: PPUSH
1726: LD_INT 3
1728: PPUSH
1729: LD_INT 3
1731: PPUSH
1732: LD_INT 12
1734: PPUSH
1735: LD_INT 100
1737: PPUSH
1738: CALL 21407 0 5
// veh := CreateVehicle ;
1742: LD_ADDR_VAR 0 2
1746: PUSH
1747: CALL_OW 45
1751: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1752: LD_VAR 0 2
1756: PPUSH
1757: LD_INT 3
1759: PPUSH
1760: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1764: LD_VAR 0 2
1768: PPUSH
1769: LD_INT 75
1771: PPUSH
1772: LD_INT 6
1774: PPUSH
1775: LD_INT 0
1777: PPUSH
1778: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1782: LD_VAR 0 2
1786: PPUSH
1787: LD_INT 4
1789: PPUSH
1790: LD_INT 50
1792: PPUSH
1793: CALL_OW 290
// end ; end ;
1797: LD_VAR 0 1
1801: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1802: LD_INT 0
1804: PPUSH
1805: PPUSH
1806: PPUSH
1807: PPUSH
// uc_side := 6 ;
1808: LD_ADDR_OWVAR 20
1812: PUSH
1813: LD_INT 6
1815: ST_TO_ADDR
// uc_nation := 3 ;
1816: LD_ADDR_OWVAR 21
1820: PUSH
1821: LD_INT 3
1823: ST_TO_ADDR
// InitHc ;
1824: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1828: LD_ADDR_EXP 32
1832: PUSH
1833: LD_STRING Gossudarov
1835: PPUSH
1836: CALL_OW 25
1840: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1841: LD_ADDR_EXP 33
1845: PUSH
1846: LD_STRING Kirilenkova
1848: PPUSH
1849: CALL_OW 25
1853: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1854: LD_ADDR_EXP 34
1858: PUSH
1859: LD_STRING Titov
1861: PPUSH
1862: CALL_OW 25
1866: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1867: LD_ADDR_EXP 39
1871: PUSH
1872: LD_STRING Oblukov
1874: PPUSH
1875: CALL_OW 25
1879: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1880: LD_ADDR_EXP 36
1884: PUSH
1885: LD_STRING Dolgov
1887: PPUSH
1888: CALL_OW 25
1892: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1893: LD_ADDR_EXP 37
1897: PUSH
1898: LD_STRING Petrosyan
1900: PPUSH
1901: CALL_OW 25
1905: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1906: LD_ADDR_EXP 38
1910: PUSH
1911: LD_STRING Scholtze
1913: PPUSH
1914: CALL_OW 25
1918: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1919: LD_ADDR_EXP 40
1923: PUSH
1924: LD_STRING Kapitsova
1926: PPUSH
1927: CALL_OW 25
1931: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1932: LD_ADDR_VAR 0 2
1936: PUSH
1937: LD_EXP 32
1941: PUSH
1942: LD_EXP 33
1946: PUSH
1947: LD_EXP 34
1951: PUSH
1952: LD_EXP 39
1956: PUSH
1957: LD_EXP 36
1961: PUSH
1962: LD_EXP 37
1966: PUSH
1967: LD_EXP 38
1971: PUSH
1972: LD_EXP 40
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: LIST
1985: LIST
1986: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1987: LD_INT 1
1989: PPUSH
1990: LD_INT 4
1992: PPUSH
1993: LD_INT 8
1995: PPUSH
1996: CALL_OW 380
// un := CreateHuman ;
2000: LD_ADDR_VAR 0 4
2004: PUSH
2005: CALL_OW 44
2009: ST_TO_ADDR
// tmp := tmp ^ un ;
2010: LD_ADDR_VAR 0 2
2014: PUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_VAR 0 4
2024: ADD
2025: ST_TO_ADDR
// for i in tmp do
2026: LD_ADDR_VAR 0 3
2030: PUSH
2031: LD_VAR 0 2
2035: PUSH
2036: FOR_IN
2037: IFFALSE 2056
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2039: LD_VAR 0 3
2043: PPUSH
2044: LD_INT 14
2046: PPUSH
2047: LD_INT 0
2049: PPUSH
2050: CALL_OW 49
2054: GO 2036
2056: POP
2057: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
2058: LD_VAR 0 2
2062: PPUSH
2063: LD_EXP 3
2067: PPUSH
2068: CALL_OW 250
2072: PPUSH
2073: LD_EXP 3
2077: PPUSH
2078: CALL_OW 251
2082: PPUSH
2083: CALL_OW 111
// end ;
2087: LD_VAR 0 1
2091: RET
// export function PrepareBelkov ; begin
2092: LD_INT 0
2094: PPUSH
// uc_side := 4 ;
2095: LD_ADDR_OWVAR 20
2099: PUSH
2100: LD_INT 4
2102: ST_TO_ADDR
// uc_nation := 3 ;
2103: LD_ADDR_OWVAR 21
2107: PUSH
2108: LD_INT 3
2110: ST_TO_ADDR
// InitHc ;
2111: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2115: LD_ADDR_EXP 47
2119: PUSH
2120: LD_STRING Belkov
2122: PPUSH
2123: CALL_OW 25
2127: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2128: LD_EXP 47
2132: PPUSH
2133: LD_INT 14
2135: PPUSH
2136: LD_INT 0
2138: PPUSH
2139: CALL_OW 49
// end ;
2143: LD_VAR 0 1
2147: RET
// export function PrepareGnyevko ; begin
2148: LD_INT 0
2150: PPUSH
// uc_side := 4 ;
2151: LD_ADDR_OWVAR 20
2155: PUSH
2156: LD_INT 4
2158: ST_TO_ADDR
// uc_nation := 3 ;
2159: LD_ADDR_OWVAR 21
2163: PUSH
2164: LD_INT 3
2166: ST_TO_ADDR
// InitHc ;
2167: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2171: LD_ADDR_EXP 48
2175: PUSH
2176: LD_STRING Gnyevko
2178: PPUSH
2179: CALL_OW 25
2183: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2184: LD_EXP 48
2188: PPUSH
2189: LD_INT 14
2191: PPUSH
2192: LD_INT 0
2194: PPUSH
2195: CALL_OW 49
// end ;
2199: LD_VAR 0 1
2203: RET
// export function PrepareBurlak ; var i , tmp ; begin
2204: LD_INT 0
2206: PPUSH
2207: PPUSH
2208: PPUSH
// uc_side := 4 ;
2209: LD_ADDR_OWVAR 20
2213: PUSH
2214: LD_INT 4
2216: ST_TO_ADDR
// uc_nation := 3 ;
2217: LD_ADDR_OWVAR 21
2221: PUSH
2222: LD_INT 3
2224: ST_TO_ADDR
// InitHc ;
2225: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2229: LD_ADDR_EXP 46
2233: PUSH
2234: LD_STRING Burlak
2236: PPUSH
2237: CALL_OW 25
2241: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2242: LD_INT 24
2244: PUSH
2245: LD_INT 23
2247: PUSH
2248: LD_INT 22
2250: PUSH
2251: EMPTY
2252: LIST
2253: LIST
2254: LIST
2255: PUSH
2256: LD_OWVAR 67
2260: ARRAY
2261: PPUSH
2262: LD_INT 1
2264: PPUSH
2265: LD_INT 1
2267: PPUSH
2268: LD_INT 45
2270: PUSH
2271: LD_INT 44
2273: PUSH
2274: LD_INT 43
2276: PUSH
2277: EMPTY
2278: LIST
2279: LIST
2280: LIST
2281: PUSH
2282: LD_OWVAR 67
2286: ARRAY
2287: PPUSH
2288: LD_INT 0
2290: PPUSH
2291: CALL 21407 0 5
// Masha := CreateVehicle ;
2295: LD_ADDR_EXP 49
2299: PUSH
2300: CALL_OW 45
2304: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2305: LD_EXP 49
2309: PUSH
2310: LD_EXP 46
2314: PUSH
2315: EMPTY
2316: LIST
2317: LIST
2318: PPUSH
2319: LD_INT 499
2321: PPUSH
2322: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2326: LD_EXP 49
2330: PPUSH
2331: LD_INT 3
2333: PPUSH
2334: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2338: LD_EXP 49
2342: PPUSH
2343: LD_INT 1
2345: PPUSH
2346: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2350: LD_INT 1
2352: PPUSH
2353: LD_INT 18
2355: PPUSH
2356: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2360: LD_INT 35
2362: PPUSH
2363: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: LD_INT 18
2374: PPUSH
2375: EMPTY
2376: PPUSH
2377: CALL_OW 70
2381: ST_TO_ADDR
// if tmp then
2382: LD_VAR 0 3
2386: IFFALSE 2420
// for i in tmp do
2388: LD_ADDR_VAR 0 2
2392: PUSH
2393: LD_VAR 0 3
2397: PUSH
2398: FOR_IN
2399: IFFALSE 2418
// ComMoveXY ( i , 114 , 9 ) ;
2401: LD_VAR 0 2
2405: PPUSH
2406: LD_INT 114
2408: PPUSH
2409: LD_INT 9
2411: PPUSH
2412: CALL_OW 111
2416: GO 2398
2418: POP
2419: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2420: LD_INT 18
2422: PPUSH
2423: EMPTY
2424: PPUSH
2425: CALL_OW 70
2429: NOT
2430: PUSH
2431: LD_INT 123
2433: PPUSH
2434: LD_INT 3
2436: PPUSH
2437: CALL_OW 428
2441: PUSH
2442: LD_INT 0
2444: EQUAL
2445: AND
2446: IFFALSE 2360
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2448: LD_EXP 49
2452: PPUSH
2453: LD_INT 123
2455: PPUSH
2456: LD_INT 3
2458: PPUSH
2459: LD_INT 0
2461: PPUSH
2462: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2466: LD_EXP 46
2470: PPUSH
2471: LD_INT 125
2473: PPUSH
2474: LD_INT 1
2476: PPUSH
2477: LD_INT 0
2479: PPUSH
2480: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2484: LD_EXP 46
2488: PPUSH
2489: LD_EXP 49
2493: PPUSH
2494: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2498: LD_INT 10
2500: PPUSH
2501: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2505: LD_EXP 49
2509: PPUSH
2510: LD_INT 110
2512: PPUSH
2513: LD_INT 10
2515: PPUSH
2516: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2520: LD_ADDR_EXP 42
2524: PUSH
2525: LD_STRING Petrovova
2527: PPUSH
2528: CALL_OW 25
2532: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2533: LD_ADDR_EXP 44
2537: PUSH
2538: LD_STRING Kuzmov
2540: PPUSH
2541: CALL_OW 25
2545: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2546: LD_ADDR_EXP 43
2550: PUSH
2551: LD_STRING Kovalyuk
2553: PPUSH
2554: CALL_OW 25
2558: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2559: LD_ADDR_EXP 41
2563: PUSH
2564: LD_STRING Lipshchin
2566: PPUSH
2567: CALL_OW 25
2571: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2572: LD_ADDR_EXP 45
2576: PUSH
2577: LD_STRING Karamazov
2579: PPUSH
2580: CALL_OW 25
2584: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2585: LD_ADDR_VAR 0 3
2589: PUSH
2590: LD_EXP 42
2594: PUSH
2595: LD_EXP 44
2599: PUSH
2600: LD_EXP 43
2604: PUSH
2605: LD_EXP 41
2609: PUSH
2610: LD_EXP 45
2614: PUSH
2615: EMPTY
2616: LIST
2617: LIST
2618: LIST
2619: LIST
2620: LIST
2621: ST_TO_ADDR
// for i in tmp do
2622: LD_ADDR_VAR 0 2
2626: PUSH
2627: LD_VAR 0 3
2631: PUSH
2632: FOR_IN
2633: IFFALSE 2672
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2635: LD_VAR 0 2
2639: PPUSH
2640: LD_INT 399
2642: PPUSH
2643: LD_INT 799
2645: PPUSH
2646: CALL_OW 12
2650: PPUSH
2651: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2655: LD_VAR 0 2
2659: PPUSH
2660: LD_INT 19
2662: PPUSH
2663: LD_INT 0
2665: PPUSH
2666: CALL_OW 49
// end ;
2670: GO 2632
2672: POP
2673: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2674: LD_VAR 0 3
2678: PPUSH
2679: LD_INT 116
2681: PPUSH
2682: LD_INT 8
2684: PPUSH
2685: CALL_OW 111
// AddComHold ( tmp ) ;
2689: LD_VAR 0 3
2693: PPUSH
2694: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2698: LD_ADDR_VAR 0 2
2702: PUSH
2703: LD_VAR 0 3
2707: PPUSH
2708: LD_INT 25
2710: PUSH
2711: LD_INT 1
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: PPUSH
2718: CALL_OW 72
2722: PUSH
2723: FOR_IN
2724: IFFALSE 2764
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2726: LD_VAR 0 2
2730: PPUSH
2731: LD_INT 20
2733: PPUSH
2734: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2738: LD_VAR 0 2
2742: PPUSH
2743: LD_INT 147
2745: PPUSH
2746: LD_INT 45
2748: PPUSH
2749: CALL_OW 178
// AddComCrawl ( i ) ;
2753: LD_VAR 0 2
2757: PPUSH
2758: CALL_OW 197
// end ;
2762: GO 2723
2764: POP
2765: POP
// repeat wait ( 0 0$1 ) ;
2766: LD_INT 35
2768: PPUSH
2769: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2773: LD_EXP 49
2777: PPUSH
2778: LD_INT 110
2780: PPUSH
2781: LD_INT 10
2783: PPUSH
2784: CALL_OW 307
2788: PUSH
2789: LD_EXP 49
2793: PPUSH
2794: CALL_OW 305
2798: NOT
2799: OR
2800: IFFALSE 2766
// ComStop ( Burlak ) ;
2802: LD_EXP 46
2806: PPUSH
2807: CALL_OW 141
// AddComHold ( Burlak ) ;
2811: LD_EXP 46
2815: PPUSH
2816: CALL_OW 200
// end ; end_of_file
2820: LD_VAR 0 1
2824: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2825: LD_INT 0
2827: PPUSH
2828: PPUSH
2829: PPUSH
2830: PPUSH
// uc_side := 3 ;
2831: LD_ADDR_OWVAR 20
2835: PUSH
2836: LD_INT 3
2838: ST_TO_ADDR
// uc_nation := 3 ;
2839: LD_ADDR_OWVAR 21
2843: PUSH
2844: LD_INT 3
2846: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2847: LD_ADDR_EXP 50
2851: PUSH
2852: LD_INT 47
2854: PPUSH
2855: LD_INT 4
2857: PPUSH
2858: LD_STRING 
2860: PPUSH
2861: LD_INT 7
2863: PUSH
2864: LD_INT 8
2866: PUSH
2867: LD_INT 9
2869: PUSH
2870: EMPTY
2871: LIST
2872: LIST
2873: LIST
2874: PUSH
2875: LD_OWVAR 67
2879: ARRAY
2880: PPUSH
2881: LD_INT 10000
2883: PUSH
2884: LD_INT 3000
2886: PUSH
2887: LD_INT 300
2889: PUSH
2890: EMPTY
2891: LIST
2892: LIST
2893: LIST
2894: PPUSH
2895: LD_INT 9
2897: PUSH
2898: LD_INT 5
2900: PUSH
2901: LD_INT 6
2903: PUSH
2904: LD_INT 6
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: LIST
2911: LIST
2912: PPUSH
2913: CALL 24816 0 6
2917: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2918: LD_ADDR_EXP 59
2922: PUSH
2923: LD_EXP 59
2927: PPUSH
2928: LD_INT 2
2930: PPUSH
2931: LD_EXP 50
2935: PPUSH
2936: CALL_OW 1
2940: ST_TO_ADDR
// tmp := [ ] ;
2941: LD_ADDR_VAR 0 4
2945: PUSH
2946: EMPTY
2947: ST_TO_ADDR
// for i = 1 to 4 do
2948: LD_ADDR_VAR 0 2
2952: PUSH
2953: DOUBLE
2954: LD_INT 1
2956: DEC
2957: ST_TO_ADDR
2958: LD_INT 4
2960: PUSH
2961: FOR_TO
2962: IFFALSE 3055
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2964: LD_INT 22
2966: PPUSH
2967: LD_INT 3
2969: PPUSH
2970: LD_INT 3
2972: PPUSH
2973: LD_INT 43
2975: PUSH
2976: LD_INT 45
2978: PUSH
2979: LD_INT 45
2981: PUSH
2982: LD_INT 44
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: PUSH
2991: LD_VAR 0 2
2995: PUSH
2996: LD_INT 4
2998: MOD
2999: PUSH
3000: LD_INT 1
3002: PLUS
3003: ARRAY
3004: PPUSH
3005: LD_INT 100
3007: PPUSH
3008: CALL 21407 0 5
// veh := CreateVehicle ;
3012: LD_ADDR_VAR 0 3
3016: PUSH
3017: CALL_OW 45
3021: ST_TO_ADDR
// tmp := tmp ^ veh ;
3022: LD_ADDR_VAR 0 4
3026: PUSH
3027: LD_VAR 0 4
3031: PUSH
3032: LD_VAR 0 3
3036: ADD
3037: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3038: LD_VAR 0 3
3042: PPUSH
3043: LD_INT 2
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 49
// end ;
3053: GO 2961
3055: POP
3056: POP
// russian_guard := tmp ;
3057: LD_ADDR_EXP 51
3061: PUSH
3062: LD_VAR 0 4
3066: ST_TO_ADDR
// end ;
3067: LD_VAR 0 1
3071: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
3072: LD_INT 47
3074: PPUSH
3075: CALL_OW 302
3079: PUSH
3080: LD_EXP 6
3084: AND
3085: IFFALSE 3687
3087: GO 3089
3089: DISABLE
3090: LD_INT 0
3092: PPUSH
3093: PPUSH
3094: PPUSH
3095: PPUSH
3096: PPUSH
3097: PPUSH
// begin enable ;
3098: ENABLE
// base := 2 ;
3099: LD_ADDR_VAR 0 2
3103: PUSH
3104: LD_INT 2
3106: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3107: LD_ADDR_VAR 0 4
3111: PUSH
3112: LD_INT 0
3114: PUSH
3115: LD_INT 0
3117: PUSH
3118: LD_INT 0
3120: PUSH
3121: LD_INT 0
3123: PUSH
3124: LD_INT 0
3126: PUSH
3127: LD_INT 0
3129: PUSH
3130: LD_INT 0
3132: PUSH
3133: LD_INT 0
3135: PUSH
3136: LD_INT 1
3138: PUSH
3139: LD_INT 0
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3154: LD_ADDR_VAR 0 3
3158: PUSH
3159: LD_INT 22
3161: PUSH
3162: LD_INT 1
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: LD_INT 45
3170: PUSH
3171: EMPTY
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: PUSH
3177: LD_INT 21
3179: PUSH
3180: LD_INT 1
3182: PUSH
3183: LD_INT 3
3185: PUSH
3186: LD_INT 45
3188: PUSH
3189: EMPTY
3190: LIST
3191: LIST
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 22
3197: PUSH
3198: LD_INT 1
3200: PUSH
3201: LD_INT 3
3203: PUSH
3204: LD_INT 45
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: PUSH
3213: LD_INT 23
3215: PUSH
3216: LD_INT 1
3218: PUSH
3219: LD_INT 3
3221: PUSH
3222: LD_INT 46
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: LIST
3229: LIST
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: LIST
3235: LIST
3236: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3237: LD_ADDR_VAR 0 1
3241: PUSH
3242: DOUBLE
3243: LD_INT 1
3245: DEC
3246: ST_TO_ADDR
3247: LD_OWVAR 67
3251: PUSH
3252: LD_OWVAR 1
3256: PUSH
3257: LD_INT 21000
3259: DIV
3260: PLUS
3261: PUSH
3262: FOR_TO
3263: IFFALSE 3351
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3265: LD_ADDR_VAR 0 3
3269: PUSH
3270: LD_VAR 0 3
3274: PPUSH
3275: LD_VAR 0 3
3279: PUSH
3280: LD_INT 1
3282: PLUS
3283: PPUSH
3284: LD_INT 23
3286: PUSH
3287: LD_INT 24
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PUSH
3294: LD_INT 1
3296: PPUSH
3297: LD_INT 2
3299: PPUSH
3300: CALL_OW 12
3304: ARRAY
3305: PUSH
3306: LD_INT 1
3308: PUSH
3309: LD_INT 3
3311: PUSH
3312: LD_INT 46
3314: PUSH
3315: LD_INT 47
3317: PUSH
3318: LD_INT 45
3320: PUSH
3321: EMPTY
3322: LIST
3323: LIST
3324: LIST
3325: PUSH
3326: LD_INT 1
3328: PPUSH
3329: LD_INT 3
3331: PPUSH
3332: CALL_OW 12
3336: ARRAY
3337: PUSH
3338: EMPTY
3339: LIST
3340: LIST
3341: LIST
3342: LIST
3343: PPUSH
3344: CALL_OW 2
3348: ST_TO_ADDR
3349: GO 3262
3351: POP
3352: POP
// MC_InsertProduceList ( base , tmp ) ;
3353: LD_VAR 0 2
3357: PPUSH
3358: LD_VAR 0 3
3362: PPUSH
3363: CALL 81152 0 2
// repeat wait ( 0 0$1 ) ;
3367: LD_INT 35
3369: PPUSH
3370: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3374: LD_EXP 78
3378: PUSH
3379: LD_VAR 0 2
3383: ARRAY
3384: PUSH
3385: LD_INT 6
3387: GREATER
3388: IFFALSE 3367
// wait ( 0 0$20 ) ;
3390: LD_INT 700
3392: PPUSH
3393: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3397: LD_ADDR_VAR 0 5
3401: PUSH
3402: LD_INT 71
3404: PUSH
3405: LD_INT 19
3407: PUSH
3408: EMPTY
3409: LIST
3410: LIST
3411: PUSH
3412: LD_INT 91
3414: PUSH
3415: LD_INT 67
3417: PUSH
3418: EMPTY
3419: LIST
3420: LIST
3421: PUSH
3422: LD_INT 52
3424: PUSH
3425: LD_INT 44
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: PUSH
3432: LD_INT 68
3434: PUSH
3435: LD_INT 48
3437: PUSH
3438: EMPTY
3439: LIST
3440: LIST
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3448: LD_ADDR_VAR 0 6
3452: PUSH
3453: LD_EXP 78
3457: PUSH
3458: LD_VAR 0 2
3462: ARRAY
3463: PUSH
3464: LD_EXP 78
3468: PUSH
3469: LD_VAR 0 2
3473: ARRAY
3474: PPUSH
3475: LD_INT 2
3477: PUSH
3478: LD_INT 34
3480: PUSH
3481: LD_INT 51
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: PUSH
3488: LD_INT 34
3490: PUSH
3491: LD_INT 52
3493: PUSH
3494: EMPTY
3495: LIST
3496: LIST
3497: PUSH
3498: EMPTY
3499: LIST
3500: LIST
3501: LIST
3502: PPUSH
3503: CALL_OW 72
3507: DIFF
3508: ST_TO_ADDR
// if not attackers then
3509: LD_VAR 0 6
3513: NOT
3514: IFFALSE 3518
// exit ;
3516: GO 3687
// ru_attackers := attackers ;
3518: LD_ADDR_EXP 52
3522: PUSH
3523: LD_VAR 0 6
3527: ST_TO_ADDR
// for i = 1 to attackers do
3528: LD_ADDR_VAR 0 1
3532: PUSH
3533: DOUBLE
3534: LD_INT 1
3536: DEC
3537: ST_TO_ADDR
3538: LD_VAR 0 6
3542: PUSH
3543: FOR_TO
3544: IFFALSE 3621
// begin case i mod 3 of 0 :
3546: LD_VAR 0 1
3550: PUSH
3551: LD_INT 3
3553: MOD
3554: PUSH
3555: LD_INT 0
3557: DOUBLE
3558: EQUAL
3559: IFTRUE 3563
3561: GO 3566
3563: POP
// ; 1 :
3564: GO 3619
3566: LD_INT 1
3568: DOUBLE
3569: EQUAL
3570: IFTRUE 3574
3572: GO 3592
3574: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3575: LD_VAR 0 1
3579: PPUSH
3580: LD_INT 32
3582: PPUSH
3583: LD_INT 49
3585: PPUSH
3586: CALL_OW 114
3590: GO 3619
3592: LD_INT 2
3594: DOUBLE
3595: EQUAL
3596: IFTRUE 3600
3598: GO 3618
3600: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3601: LD_VAR 0 1
3605: PPUSH
3606: LD_INT 117
3608: PPUSH
3609: LD_INT 107
3611: PPUSH
3612: CALL_OW 114
3616: GO 3619
3618: POP
// end ;
3619: GO 3543
3621: POP
3622: POP
// repeat wait ( 0 0$1 ) ;
3623: LD_INT 35
3625: PPUSH
3626: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3630: LD_VAR 0 6
3634: PPUSH
3635: LD_INT 60
3637: PUSH
3638: EMPTY
3639: LIST
3640: PPUSH
3641: CALL_OW 72
3645: NOT
3646: IFFALSE 3623
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3648: LD_VAR 0 2
3652: PPUSH
3653: LD_VAR 0 6
3657: PPUSH
3658: LD_VAR 0 5
3662: PPUSH
3663: LD_VAR 0 4
3667: PPUSH
3668: CALL 81337 0 4
// if not first_attack then
3672: LD_EXP 7
3676: NOT
3677: IFFALSE 3687
// first_attack := true ;
3679: LD_ADDR_EXP 7
3683: PUSH
3684: LD_INT 1
3686: ST_TO_ADDR
// end ; end_of_file
3687: PPOPN 6
3689: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3690: LD_INT 0
3692: PPUSH
3693: PPUSH
3694: PPUSH
3695: PPUSH
3696: PPUSH
3697: PPUSH
3698: PPUSH
// uc_side := 2 ;
3699: LD_ADDR_OWVAR 20
3703: PUSH
3704: LD_INT 2
3706: ST_TO_ADDR
// uc_nation := 2 ;
3707: LD_ADDR_OWVAR 21
3711: PUSH
3712: LD_INT 2
3714: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3715: LD_ADDR_EXP 55
3719: PUSH
3720: LD_STRING Abdul
3722: PPUSH
3723: CALL_OW 25
3727: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3728: LD_EXP 55
3732: PPUSH
3733: LD_INT 11
3735: PPUSH
3736: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3740: LD_EXP 55
3744: PPUSH
3745: LD_INT 1
3747: PPUSH
3748: CALL_OW 52
// vc_chassis := 31 ;
3752: LD_ADDR_OWVAR 37
3756: PUSH
3757: LD_INT 31
3759: ST_TO_ADDR
// vc_control := control_rider ;
3760: LD_ADDR_OWVAR 38
3764: PUSH
3765: LD_INT 4
3767: ST_TO_ADDR
// mastodont := CreateVehicle ;
3768: LD_ADDR_EXP 56
3772: PUSH
3773: CALL_OW 45
3777: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3778: LD_EXP 56
3782: PPUSH
3783: LD_INT 153
3785: PPUSH
3786: LD_INT 71
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 48
// InitVc ;
3796: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3800: LD_ADDR_EXP 53
3804: PUSH
3805: LD_INT 1
3807: PPUSH
3808: LD_INT 3
3810: PPUSH
3811: LD_STRING 
3813: PPUSH
3814: LD_INT 7
3816: PUSH
3817: LD_INT 8
3819: PUSH
3820: LD_INT 9
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: LIST
3827: PUSH
3828: LD_OWVAR 67
3832: ARRAY
3833: PPUSH
3834: LD_INT 5000
3836: PUSH
3837: LD_INT 1000
3839: PUSH
3840: LD_INT 300
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: PPUSH
3848: LD_INT 22
3850: PUSH
3851: LD_INT 5
3853: PUSH
3854: LD_INT 6
3856: PUSH
3857: LD_INT 9
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: LIST
3864: LIST
3865: PPUSH
3866: CALL 24816 0 6
3870: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3871: LD_ADDR_EXP 59
3875: PUSH
3876: LD_EXP 59
3880: PPUSH
3881: LD_INT 1
3883: PPUSH
3884: LD_EXP 53
3888: PPUSH
3889: CALL_OW 1
3893: ST_TO_ADDR
// tmp := [ ] ;
3894: LD_ADDR_VAR 0 4
3898: PUSH
3899: EMPTY
3900: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3901: LD_ADDR_OWVAR 37
3905: PUSH
3906: LD_INT 14
3908: ST_TO_ADDR
// vc_engine := engine_siberite ;
3909: LD_ADDR_OWVAR 39
3913: PUSH
3914: LD_INT 3
3916: ST_TO_ADDR
// vc_control := control_manual ;
3917: LD_ADDR_OWVAR 38
3921: PUSH
3922: LD_INT 1
3924: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3925: LD_ADDR_OWVAR 40
3929: PUSH
3930: LD_INT 31
3932: ST_TO_ADDR
// for i = 1 to 3 do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: DOUBLE
3939: LD_INT 1
3941: DEC
3942: ST_TO_ADDR
3943: LD_INT 3
3945: PUSH
3946: FOR_TO
3947: IFFALSE 4191
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3949: LD_ADDR_VAR 0 5
3953: PUSH
3954: LD_INT 153
3956: PUSH
3957: LD_INT 71
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: PUSH
3964: LD_INT 155
3966: PUSH
3967: LD_INT 81
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PUSH
3978: LD_VAR 0 2
3982: PUSH
3983: LD_INT 2
3985: MOD
3986: PUSH
3987: LD_INT 1
3989: PLUS
3990: ARRAY
3991: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3992: LD_INT 0
3994: PPUSH
3995: LD_INT 3
3997: PPUSH
3998: LD_INT 7
4000: PUSH
4001: LD_INT 8
4003: PUSH
4004: LD_INT 9
4006: PUSH
4007: EMPTY
4008: LIST
4009: LIST
4010: LIST
4011: PUSH
4012: LD_OWVAR 67
4016: ARRAY
4017: PPUSH
4018: CALL_OW 380
// un := CreateVehicle ;
4022: LD_ADDR_VAR 0 6
4026: PUSH
4027: CALL_OW 45
4031: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4032: LD_VAR 0 6
4036: PPUSH
4037: LD_INT 0
4039: PPUSH
4040: LD_INT 5
4042: PPUSH
4043: CALL_OW 12
4047: PPUSH
4048: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4052: LD_VAR 0 6
4056: PPUSH
4057: LD_VAR 0 5
4061: PUSH
4062: LD_INT 1
4064: ARRAY
4065: PPUSH
4066: LD_VAR 0 5
4070: PUSH
4071: LD_INT 2
4073: ARRAY
4074: PPUSH
4075: LD_INT 6
4077: PPUSH
4078: LD_INT 0
4080: PPUSH
4081: CALL_OW 50
// un2 := CreateHuman ;
4085: LD_ADDR_VAR 0 7
4089: PUSH
4090: CALL_OW 44
4094: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4095: LD_VAR 0 7
4099: PPUSH
4100: LD_VAR 0 6
4104: PPUSH
4105: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4109: LD_ADDR_EXP 59
4113: PUSH
4114: LD_EXP 59
4118: PPUSH
4119: LD_INT 1
4121: PUSH
4122: LD_EXP 59
4126: PUSH
4127: LD_INT 1
4129: ARRAY
4130: PUSH
4131: LD_INT 1
4133: PLUS
4134: PUSH
4135: EMPTY
4136: LIST
4137: LIST
4138: PPUSH
4139: LD_VAR 0 6
4143: PPUSH
4144: CALL 21529 0 3
4148: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4149: LD_ADDR_EXP 59
4153: PUSH
4154: LD_EXP 59
4158: PPUSH
4159: LD_INT 1
4161: PUSH
4162: LD_EXP 59
4166: PUSH
4167: LD_INT 1
4169: ARRAY
4170: PUSH
4171: LD_INT 1
4173: PLUS
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: PPUSH
4179: LD_VAR 0 7
4183: PPUSH
4184: CALL 21529 0 3
4188: ST_TO_ADDR
// end ;
4189: GO 3946
4191: POP
4192: POP
// for i = 1 to 5 do
4193: LD_ADDR_VAR 0 2
4197: PUSH
4198: DOUBLE
4199: LD_INT 1
4201: DEC
4202: ST_TO_ADDR
4203: LD_INT 5
4205: PUSH
4206: FOR_TO
4207: IFFALSE 4300
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4209: LD_INT 14
4211: PPUSH
4212: LD_INT 3
4214: PPUSH
4215: LD_INT 1
4217: PPUSH
4218: LD_INT 25
4220: PUSH
4221: LD_INT 28
4223: PUSH
4224: LD_INT 28
4226: PUSH
4227: LD_INT 26
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: LIST
4234: LIST
4235: PUSH
4236: LD_VAR 0 2
4240: PUSH
4241: LD_INT 4
4243: MOD
4244: PUSH
4245: LD_INT 1
4247: PLUS
4248: ARRAY
4249: PPUSH
4250: LD_INT 100
4252: PPUSH
4253: CALL 21407 0 5
// veh := CreateVehicle ;
4257: LD_ADDR_VAR 0 3
4261: PUSH
4262: CALL_OW 45
4266: ST_TO_ADDR
// tmp := tmp ^ veh ;
4267: LD_ADDR_VAR 0 4
4271: PUSH
4272: LD_VAR 0 4
4276: PUSH
4277: LD_VAR 0 3
4281: ADD
4282: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4283: LD_VAR 0 3
4287: PPUSH
4288: LD_INT 1
4290: PPUSH
4291: LD_INT 0
4293: PPUSH
4294: CALL_OW 49
// end ;
4298: GO 4206
4300: POP
4301: POP
// arabian_guard := tmp ;
4302: LD_ADDR_EXP 54
4306: PUSH
4307: LD_VAR 0 4
4311: ST_TO_ADDR
// end ;
4312: LD_VAR 0 1
4316: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4317: LD_INT 22
4319: PUSH
4320: LD_INT 7
4322: PUSH
4323: EMPTY
4324: LIST
4325: LIST
4326: PUSH
4327: LD_INT 91
4329: PUSH
4330: LD_INT 1
4332: PUSH
4333: LD_INT 12
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: LIST
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: PPUSH
4345: CALL_OW 69
4349: PUSH
4350: LD_EXP 56
4354: PPUSH
4355: CALL_OW 256
4359: PUSH
4360: LD_INT 990
4362: LESS
4363: OR
4364: PUSH
4365: LD_EXP 55
4369: PPUSH
4370: CALL_OW 256
4374: PUSH
4375: LD_INT 990
4377: LESS
4378: OR
4379: IFFALSE 4522
4381: GO 4383
4383: DISABLE
// begin if IsInUnit ( Abdul ) then
4384: LD_EXP 55
4388: PPUSH
4389: CALL_OW 310
4393: IFFALSE 4404
// ComExitBuilding ( Abdul ) ;
4395: LD_EXP 55
4399: PPUSH
4400: CALL_OW 122
// if Mastodont then
4404: LD_EXP 56
4408: IFFALSE 4425
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4410: LD_EXP 56
4414: PPUSH
4415: LD_INT 205
4417: PPUSH
4418: LD_INT 132
4420: PPUSH
4421: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4425: LD_EXP 55
4429: PPUSH
4430: LD_INT 205
4432: PPUSH
4433: LD_INT 132
4435: PPUSH
4436: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4440: LD_INT 35
4442: PPUSH
4443: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4447: LD_EXP 55
4451: PPUSH
4452: LD_INT 21
4454: PPUSH
4455: CALL_OW 308
4459: IFFALSE 4440
// RemoveUnit ( Abdul ) ;
4461: LD_EXP 55
4465: PPUSH
4466: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4470: LD_INT 35
4472: PPUSH
4473: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4477: LD_EXP 56
4481: PPUSH
4482: LD_INT 21
4484: PPUSH
4485: CALL_OW 308
4489: PUSH
4490: LD_EXP 56
4494: PPUSH
4495: CALL_OW 301
4499: OR
4500: IFFALSE 4470
// if IsOk ( Mastodont ) then
4502: LD_EXP 56
4506: PPUSH
4507: CALL_OW 302
4511: IFFALSE 4522
// RemoveUnit ( Mastodont ) ;
4513: LD_EXP 56
4517: PPUSH
4518: CALL_OW 64
// end ;
4522: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4523: LD_EXP 55
4527: PPUSH
4528: CALL_OW 301
4532: PUSH
4533: LD_INT 22
4535: PUSH
4536: LD_INT 2
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: PUSH
4543: LD_INT 2
4545: PUSH
4546: LD_INT 25
4548: PUSH
4549: LD_INT 1
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 25
4558: PUSH
4559: LD_INT 2
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: LD_INT 25
4568: PUSH
4569: LD_INT 3
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: LD_INT 25
4578: PUSH
4579: LD_INT 4
4581: PUSH
4582: EMPTY
4583: LIST
4584: LIST
4585: PUSH
4586: LD_INT 25
4588: PUSH
4589: LD_INT 8
4591: PUSH
4592: EMPTY
4593: LIST
4594: LIST
4595: PUSH
4596: EMPTY
4597: LIST
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: PUSH
4604: EMPTY
4605: LIST
4606: LIST
4607: PPUSH
4608: CALL_OW 69
4612: PUSH
4613: LD_INT 16
4615: PUSH
4616: LD_INT 19
4618: PUSH
4619: LD_INT 22
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: LIST
4626: PUSH
4627: LD_OWVAR 67
4631: ARRAY
4632: LESS
4633: OR
4634: IFFALSE 5307
4636: GO 4638
4638: DISABLE
4639: LD_INT 0
4641: PPUSH
4642: PPUSH
4643: PPUSH
4644: PPUSH
4645: PPUSH
4646: PPUSH
// begin MC_Kill ( 1 ) ;
4647: LD_INT 1
4649: PPUSH
4650: CALL 57692 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4654: LD_ADDR_VAR 0 2
4658: PUSH
4659: LD_INT 22
4661: PUSH
4662: LD_INT 2
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: LD_INT 25
4674: PUSH
4675: LD_INT 1
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: LD_INT 25
4684: PUSH
4685: LD_INT 2
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: PUSH
4692: LD_INT 25
4694: PUSH
4695: LD_INT 3
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: PUSH
4702: LD_INT 25
4704: PUSH
4705: LD_INT 4
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: LD_INT 25
4714: PUSH
4715: LD_INT 8
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: LIST
4726: LIST
4727: LIST
4728: LIST
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PPUSH
4734: CALL_OW 69
4738: ST_TO_ADDR
// for i in tmp do
4739: LD_ADDR_VAR 0 5
4743: PUSH
4744: LD_VAR 0 2
4748: PUSH
4749: FOR_IN
4750: IFFALSE 4766
// SetTag ( i , 10 ) ;
4752: LD_VAR 0 5
4756: PPUSH
4757: LD_INT 10
4759: PPUSH
4760: CALL_OW 109
4764: GO 4749
4766: POP
4767: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4768: LD_ADDR_VAR 0 3
4772: PUSH
4773: LD_INT 22
4775: PUSH
4776: LD_INT 2
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: LD_INT 21
4785: PUSH
4786: LD_INT 1
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: PPUSH
4797: CALL_OW 69
4801: PUSH
4802: LD_VAR 0 2
4806: DIFF
4807: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4808: LD_ADDR_VAR 0 1
4812: PUSH
4813: LD_INT 22
4815: PUSH
4816: LD_INT 2
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: PUSH
4823: LD_INT 21
4825: PUSH
4826: LD_INT 2
4828: PUSH
4829: EMPTY
4830: LIST
4831: LIST
4832: PUSH
4833: LD_INT 24
4835: PUSH
4836: LD_INT 300
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: LIST
4847: PPUSH
4848: CALL_OW 69
4852: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4853: LD_ADDR_VAR 0 4
4857: PUSH
4858: LD_VAR 0 1
4862: PPUSH
4863: LD_INT 33
4865: PUSH
4866: LD_INT 1
4868: PUSH
4869: EMPTY
4870: LIST
4871: LIST
4872: PUSH
4873: LD_INT 58
4875: PUSH
4876: EMPTY
4877: LIST
4878: PUSH
4879: EMPTY
4880: LIST
4881: LIST
4882: PPUSH
4883: CALL_OW 72
4887: ST_TO_ADDR
// for i in tmp do
4888: LD_ADDR_VAR 0 5
4892: PUSH
4893: LD_VAR 0 2
4897: PUSH
4898: FOR_IN
4899: IFFALSE 5083
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4901: LD_VAR 0 5
4905: PUSH
4906: LD_INT 55
4908: PUSH
4909: EMPTY
4910: LIST
4911: PPUSH
4912: CALL_OW 69
4916: IN
4917: IFFALSE 4936
// begin AddComMoveXY ( i , 209 , 132 ) ;
4919: LD_VAR 0 5
4923: PPUSH
4924: LD_INT 209
4926: PPUSH
4927: LD_INT 132
4929: PPUSH
4930: CALL_OW 171
// continue ;
4934: GO 4898
// end ; if IsInUnit ( i ) then
4936: LD_VAR 0 5
4940: PPUSH
4941: CALL_OW 310
4945: IFFALSE 4963
// begin ComExitBuilding ( i ) ;
4947: LD_VAR 0 5
4951: PPUSH
4952: CALL_OW 122
// wait ( 3 ) ;
4956: LD_INT 3
4958: PPUSH
4959: CALL_OW 67
// end ; if tmp_empty then
4963: LD_VAR 0 4
4967: IFFALSE 5066
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4969: LD_VAR 0 5
4973: PPUSH
4974: LD_VAR 0 4
4978: PPUSH
4979: LD_VAR 0 5
4983: PPUSH
4984: CALL_OW 74
4988: PPUSH
4989: CALL_OW 296
4993: PUSH
4994: LD_INT 25
4996: LESS
4997: IFFALSE 5066
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4999: LD_ADDR_VAR 0 6
5003: PUSH
5004: LD_VAR 0 4
5008: PPUSH
5009: LD_VAR 0 5
5013: PPUSH
5014: CALL_OW 74
5018: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5019: LD_VAR 0 5
5023: PPUSH
5024: LD_VAR 0 6
5028: PPUSH
5029: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5033: LD_VAR 0 5
5037: PPUSH
5038: LD_INT 209
5040: PPUSH
5041: LD_INT 132
5043: PPUSH
5044: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5048: LD_ADDR_VAR 0 4
5052: PUSH
5053: LD_VAR 0 4
5057: PUSH
5058: LD_VAR 0 6
5062: DIFF
5063: ST_TO_ADDR
// continue ;
5064: GO 4898
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5066: LD_VAR 0 5
5070: PPUSH
5071: LD_INT 201
5073: PPUSH
5074: LD_INT 132
5076: PPUSH
5077: CALL_OW 171
// end ;
5081: GO 4898
5083: POP
5084: POP
// for i in tmp_ape do
5085: LD_ADDR_VAR 0 5
5089: PUSH
5090: LD_VAR 0 3
5094: PUSH
5095: FOR_IN
5096: IFFALSE 5135
// begin if IsInUnit ( i ) then
5098: LD_VAR 0 5
5102: PPUSH
5103: CALL_OW 310
5107: IFFALSE 5118
// ComExitBuilding ( i ) ;
5109: LD_VAR 0 5
5113: PPUSH
5114: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5118: LD_VAR 0 5
5122: PPUSH
5123: LD_INT 201
5125: PPUSH
5126: LD_INT 132
5128: PPUSH
5129: CALL_OW 171
// end ;
5133: GO 5095
5135: POP
5136: POP
// repeat wait ( 0 0$1 ) ;
5137: LD_INT 35
5139: PPUSH
5140: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5144: LD_ADDR_VAR 0 5
5148: PUSH
5149: LD_VAR 0 2
5153: PUSH
5154: LD_VAR 0 3
5158: UNION
5159: PUSH
5160: LD_VAR 0 1
5164: UNION
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5198
// if not HasTask ( i ) then
5169: LD_VAR 0 5
5173: PPUSH
5174: CALL_OW 314
5178: NOT
5179: IFFALSE 5196
// ComMoveXY ( i , 201 , 132 ) ;
5181: LD_VAR 0 5
5185: PPUSH
5186: LD_INT 201
5188: PPUSH
5189: LD_INT 132
5191: PPUSH
5192: CALL_OW 111
5196: GO 5166
5198: POP
5199: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5200: LD_INT 21
5202: PPUSH
5203: LD_INT 22
5205: PUSH
5206: LD_INT 2
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PPUSH
5213: CALL_OW 70
5217: IFFALSE 5258
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5219: LD_ADDR_VAR 0 5
5223: PUSH
5224: LD_INT 21
5226: PPUSH
5227: LD_INT 22
5229: PUSH
5230: LD_INT 2
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: PPUSH
5237: CALL_OW 70
5241: PUSH
5242: FOR_IN
5243: IFFALSE 5256
// RemoveUnit ( i ) ;
5245: LD_VAR 0 5
5249: PPUSH
5250: CALL_OW 64
5254: GO 5242
5256: POP
5257: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5258: LD_INT 22
5260: PUSH
5261: LD_INT 2
5263: PUSH
5264: EMPTY
5265: LIST
5266: LIST
5267: PUSH
5268: LD_INT 2
5270: PUSH
5271: LD_INT 21
5273: PUSH
5274: LD_INT 1
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: PUSH
5281: LD_INT 21
5283: PUSH
5284: LD_INT 2
5286: PUSH
5287: EMPTY
5288: LIST
5289: LIST
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: LIST
5295: PUSH
5296: EMPTY
5297: LIST
5298: LIST
5299: PPUSH
5300: CALL_OW 69
5304: NOT
5305: IFFALSE 5137
// end ;
5307: PPOPN 6
5309: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5310: LD_EXP 9
5314: PUSH
5315: LD_INT 92
5317: PPUSH
5318: LD_INT 40
5320: PPUSH
5321: CALL_OW 428
5325: PPUSH
5326: CALL_OW 266
5330: PUSH
5331: LD_INT 30
5333: EQUAL
5334: AND
5335: IFFALSE 5531
5337: GO 5339
5339: DISABLE
5340: LD_INT 0
5342: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5343: LD_ADDR_VAR 0 1
5347: PUSH
5348: LD_EXP 59
5352: PUSH
5353: LD_INT 1
5355: ARRAY
5356: PPUSH
5357: LD_INT 25
5359: PUSH
5360: LD_INT 4
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: PPUSH
5367: CALL_OW 72
5371: ST_TO_ADDR
// if not sci then
5372: LD_VAR 0 1
5376: NOT
5377: IFFALSE 5381
// exit ;
5379: GO 5531
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5381: LD_ADDR_EXP 59
5385: PUSH
5386: LD_EXP 59
5390: PPUSH
5391: LD_INT 1
5393: PPUSH
5394: LD_EXP 59
5398: PUSH
5399: LD_INT 1
5401: ARRAY
5402: PUSH
5403: LD_VAR 0 1
5407: PUSH
5408: LD_INT 1
5410: ARRAY
5411: DIFF
5412: PPUSH
5413: CALL_OW 1
5417: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5418: LD_VAR 0 1
5422: PUSH
5423: LD_INT 1
5425: ARRAY
5426: PPUSH
5427: CALL_OW 310
5431: IFFALSE 5446
// ComExitBuilding ( sci [ 1 ] ) ;
5433: LD_VAR 0 1
5437: PUSH
5438: LD_INT 1
5440: ARRAY
5441: PPUSH
5442: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5446: LD_INT 2
5448: PPUSH
5449: LD_INT 105
5451: PPUSH
5452: LD_INT 14
5454: PPUSH
5455: LD_INT 20
5457: PPUSH
5458: CALL 22425 0 4
5462: PUSH
5463: LD_INT 4
5465: ARRAY
5466: PUSH
5467: LD_INT 10
5469: LESS
5470: IFFALSE 5493
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5472: LD_VAR 0 1
5476: PUSH
5477: LD_INT 1
5479: ARRAY
5480: PPUSH
5481: LD_INT 105
5483: PPUSH
5484: LD_INT 14
5486: PPUSH
5487: CALL_OW 171
5491: GO 5512
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5493: LD_VAR 0 1
5497: PUSH
5498: LD_INT 1
5500: ARRAY
5501: PPUSH
5502: LD_INT 118
5504: PPUSH
5505: LD_INT 77
5507: PPUSH
5508: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5512: LD_VAR 0 1
5516: PUSH
5517: LD_INT 1
5519: ARRAY
5520: PPUSH
5521: LD_INT 92
5523: PPUSH
5524: LD_INT 40
5526: PPUSH
5527: CALL_OW 218
// end ;
5531: PPOPN 1
5533: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5534: LD_INT 1
5536: PPUSH
5537: CALL_OW 302
5541: PUSH
5542: LD_EXP 9
5546: AND
5547: IFFALSE 6006
5549: GO 5551
5551: DISABLE
5552: LD_INT 0
5554: PPUSH
5555: PPUSH
5556: PPUSH
5557: PPUSH
5558: PPUSH
5559: PPUSH
// begin enable ;
5560: ENABLE
// base := 1 ;
5561: LD_ADDR_VAR 0 2
5565: PUSH
5566: LD_INT 1
5568: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5569: LD_ADDR_VAR 0 4
5573: PUSH
5574: LD_INT 0
5576: PUSH
5577: LD_INT 0
5579: PUSH
5580: LD_INT 0
5582: PUSH
5583: LD_INT 0
5585: PUSH
5586: LD_INT 0
5588: PUSH
5589: LD_INT 0
5591: PUSH
5592: LD_INT 0
5594: PUSH
5595: LD_INT 0
5597: PUSH
5598: LD_INT 1
5600: PUSH
5601: LD_INT 0
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: LIST
5614: LIST
5615: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5616: LD_ADDR_VAR 0 3
5620: PUSH
5621: LD_INT 14
5623: PUSH
5624: LD_INT 1
5626: PUSH
5627: LD_INT 2
5629: PUSH
5630: LD_INT 26
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: PUSH
5639: LD_INT 14
5641: PUSH
5642: LD_INT 1
5644: PUSH
5645: LD_INT 2
5647: PUSH
5648: LD_INT 28
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: PUSH
5657: LD_INT 13
5659: PUSH
5660: LD_INT 1
5662: PUSH
5663: LD_INT 2
5665: PUSH
5666: LD_INT 29
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: LIST
5679: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5680: LD_ADDR_VAR 0 1
5684: PUSH
5685: DOUBLE
5686: LD_INT 1
5688: DEC
5689: ST_TO_ADDR
5690: LD_OWVAR 67
5694: PUSH
5695: LD_OWVAR 1
5699: PUSH
5700: LD_INT 21000
5702: DIV
5703: PLUS
5704: PUSH
5705: FOR_TO
5706: IFFALSE 5798
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5708: LD_ADDR_VAR 0 3
5712: PUSH
5713: LD_VAR 0 3
5717: PPUSH
5718: LD_VAR 0 3
5722: PUSH
5723: LD_INT 1
5725: PLUS
5726: PPUSH
5727: LD_INT 13
5729: PUSH
5730: LD_INT 14
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: PUSH
5737: LD_INT 1
5739: PPUSH
5740: LD_INT 2
5742: PPUSH
5743: CALL_OW 12
5747: ARRAY
5748: PUSH
5749: LD_INT 1
5751: PUSH
5752: LD_INT 2
5754: PUSH
5755: LD_INT 28
5757: PUSH
5758: LD_INT 29
5760: PUSH
5761: LD_INT 25
5763: PUSH
5764: LD_INT 26
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: PUSH
5773: LD_INT 1
5775: PPUSH
5776: LD_INT 4
5778: PPUSH
5779: CALL_OW 12
5783: ARRAY
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: LIST
5789: LIST
5790: PPUSH
5791: CALL_OW 2
5795: ST_TO_ADDR
5796: GO 5705
5798: POP
5799: POP
// MC_InsertProduceList ( base , tmp ) ;
5800: LD_VAR 0 2
5804: PPUSH
5805: LD_VAR 0 3
5809: PPUSH
5810: CALL 81152 0 2
// repeat wait ( 0 0$1 ) ;
5814: LD_INT 35
5816: PPUSH
5817: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5821: LD_EXP 78
5825: PUSH
5826: LD_VAR 0 2
5830: ARRAY
5831: PUSH
5832: LD_INT 6
5834: GREATER
5835: IFFALSE 5814
// wait ( 0 0$20 ) ;
5837: LD_INT 700
5839: PPUSH
5840: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5844: LD_ADDR_VAR 0 5
5848: PUSH
5849: LD_INT 124
5851: PUSH
5852: LD_INT 85
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: LD_INT 90
5861: PUSH
5862: LD_INT 61
5864: PUSH
5865: EMPTY
5866: LIST
5867: LIST
5868: PUSH
5869: LD_INT 69
5871: PUSH
5872: LD_INT 48
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: PUSH
5879: LD_INT 68
5881: PUSH
5882: LD_INT 48
5884: PUSH
5885: EMPTY
5886: LIST
5887: LIST
5888: PUSH
5889: EMPTY
5890: LIST
5891: LIST
5892: LIST
5893: LIST
5894: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5895: LD_ADDR_VAR 0 6
5899: PUSH
5900: LD_EXP 78
5904: PUSH
5905: LD_VAR 0 2
5909: ARRAY
5910: PUSH
5911: LD_EXP 78
5915: PUSH
5916: LD_VAR 0 2
5920: ARRAY
5921: PPUSH
5922: LD_INT 34
5924: PUSH
5925: LD_INT 32
5927: PUSH
5928: EMPTY
5929: LIST
5930: LIST
5931: PPUSH
5932: CALL_OW 72
5936: DIFF
5937: ST_TO_ADDR
// if not attackers then
5938: LD_VAR 0 6
5942: NOT
5943: IFFALSE 5947
// exit ;
5945: GO 6006
// ar_attackers := attackers ;
5947: LD_ADDR_EXP 10
5951: PUSH
5952: LD_VAR 0 6
5956: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5957: LD_INT 35
5959: PPUSH
5960: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5964: LD_VAR 0 6
5968: PPUSH
5969: LD_INT 60
5971: PUSH
5972: EMPTY
5973: LIST
5974: PPUSH
5975: CALL_OW 72
5979: NOT
5980: IFFALSE 5957
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5982: LD_VAR 0 2
5986: PPUSH
5987: LD_VAR 0 6
5991: PPUSH
5992: LD_VAR 0 5
5996: PPUSH
5997: LD_VAR 0 4
6001: PPUSH
6002: CALL 81337 0 4
// end ;
6006: PPOPN 6
6008: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6009: LD_INT 1
6011: PPUSH
6012: CALL_OW 302
6016: PUSH
6017: LD_EXP 9
6021: AND
6022: PUSH
6023: LD_EXP 49
6027: PPUSH
6028: LD_INT 22
6030: PPUSH
6031: CALL_OW 308
6035: AND
6036: PUSH
6037: LD_INT 1
6039: PPUSH
6040: CALL 81500 0 1
6044: PUSH
6045: LD_INT 0
6047: EQUAL
6048: AND
6049: PUSH
6050: LD_EXP 10
6054: NOT
6055: AND
6056: IFFALSE 6520
6058: GO 6060
6060: DISABLE
6061: LD_INT 0
6063: PPUSH
6064: PPUSH
6065: PPUSH
6066: PPUSH
6067: PPUSH
6068: PPUSH
6069: PPUSH
// begin base := 1 ;
6070: LD_ADDR_VAR 0 2
6074: PUSH
6075: LD_INT 1
6077: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6078: LD_ADDR_VAR 0 4
6082: PUSH
6083: LD_INT 0
6085: PUSH
6086: LD_INT 0
6088: PUSH
6089: LD_INT 0
6091: PUSH
6092: LD_INT 0
6094: PUSH
6095: LD_INT 0
6097: PUSH
6098: LD_INT 0
6100: PUSH
6101: LD_INT 0
6103: PUSH
6104: LD_INT 0
6106: PUSH
6107: LD_INT 1
6109: PUSH
6110: LD_INT 0
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: LIST
6121: LIST
6122: LIST
6123: LIST
6124: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6125: LD_ADDR_VAR 0 3
6129: PUSH
6130: LD_INT 13
6132: PUSH
6133: LD_INT 1
6135: PUSH
6136: LD_INT 2
6138: PUSH
6139: LD_INT 28
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PUSH
6148: LD_INT 13
6150: PUSH
6151: LD_INT 1
6153: PUSH
6154: LD_INT 2
6156: PUSH
6157: LD_INT 27
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: LIST
6164: LIST
6165: PUSH
6166: LD_INT 13
6168: PUSH
6169: LD_INT 1
6171: PUSH
6172: LD_INT 2
6174: PUSH
6175: LD_INT 25
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: PUSH
6184: LD_INT 11
6186: PUSH
6187: LD_INT 2
6189: PUSH
6190: LD_INT 2
6192: PUSH
6193: LD_INT 24
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: LIST
6200: LIST
6201: PUSH
6202: LD_INT 11
6204: PUSH
6205: LD_INT 2
6207: PUSH
6208: LD_INT 2
6210: PUSH
6211: LD_INT 24
6213: PUSH
6214: EMPTY
6215: LIST
6216: LIST
6217: LIST
6218: LIST
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6227: LD_VAR 0 2
6231: PPUSH
6232: LD_VAR 0 3
6236: PPUSH
6237: CALL 81152 0 2
// repeat wait ( 0 0$1 ) ;
6241: LD_INT 35
6243: PPUSH
6244: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6248: LD_EXP 78
6252: PUSH
6253: LD_VAR 0 2
6257: ARRAY
6258: PUSH
6259: LD_INT 6
6261: GREATEREQUAL
6262: IFFALSE 6241
// wait ( 0 0$20 ) ;
6264: LD_INT 700
6266: PPUSH
6267: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6271: LD_ADDR_VAR 0 5
6275: PUSH
6276: LD_INT 119
6278: PUSH
6279: LD_INT 9
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: PUSH
6286: EMPTY
6287: LIST
6288: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6289: LD_ADDR_VAR 0 6
6293: PUSH
6294: LD_EXP 78
6298: PUSH
6299: LD_VAR 0 2
6303: ARRAY
6304: PUSH
6305: LD_EXP 78
6309: PUSH
6310: LD_VAR 0 2
6314: ARRAY
6315: PPUSH
6316: LD_INT 34
6318: PUSH
6319: LD_INT 32
6321: PUSH
6322: EMPTY
6323: LIST
6324: LIST
6325: PPUSH
6326: CALL_OW 72
6330: DIFF
6331: ST_TO_ADDR
// if not attackers then
6332: LD_VAR 0 6
6336: NOT
6337: IFFALSE 6341
// exit ;
6339: GO 6520
// uc_side := 2 ;
6341: LD_ADDR_OWVAR 20
6345: PUSH
6346: LD_INT 2
6348: ST_TO_ADDR
// uc_nation := 2 ;
6349: LD_ADDR_OWVAR 21
6353: PUSH
6354: LD_INT 2
6356: ST_TO_ADDR
// InitHc ;
6357: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6361: LD_ADDR_VAR 0 1
6365: PUSH
6366: DOUBLE
6367: LD_INT 1
6369: DEC
6370: ST_TO_ADDR
6371: LD_INT 4
6373: PUSH
6374: LD_INT 5
6376: PUSH
6377: LD_INT 6
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: LIST
6384: PUSH
6385: LD_OWVAR 67
6389: ARRAY
6390: PUSH
6391: FOR_TO
6392: IFFALSE 6469
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6394: LD_INT 0
6396: PPUSH
6397: LD_INT 15
6399: PUSH
6400: LD_INT 17
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: CALL_OW 12
6417: ARRAY
6418: PPUSH
6419: LD_INT 8
6421: PPUSH
6422: CALL_OW 380
// un := CreateHuman ;
6426: LD_ADDR_VAR 0 7
6430: PUSH
6431: CALL_OW 44
6435: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6436: LD_VAR 0 7
6440: PPUSH
6441: LD_INT 23
6443: PPUSH
6444: LD_INT 0
6446: PPUSH
6447: CALL_OW 49
// attackers := attackers union un ;
6451: LD_ADDR_VAR 0 6
6455: PUSH
6456: LD_VAR 0 6
6460: PUSH
6461: LD_VAR 0 7
6465: UNION
6466: ST_TO_ADDR
// end ;
6467: GO 6391
6469: POP
6470: POP
// repeat wait ( 0 0$1 ) ;
6471: LD_INT 35
6473: PPUSH
6474: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6478: LD_VAR 0 6
6482: PPUSH
6483: LD_INT 60
6485: PUSH
6486: EMPTY
6487: LIST
6488: PPUSH
6489: CALL_OW 72
6493: NOT
6494: IFFALSE 6471
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6496: LD_VAR 0 2
6500: PPUSH
6501: LD_VAR 0 6
6505: PPUSH
6506: LD_VAR 0 5
6510: PPUSH
6511: LD_VAR 0 4
6515: PPUSH
6516: CALL 81337 0 4
// end ; end_of_file
6520: PPOPN 7
6522: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6523: LD_INT 0
6525: PPUSH
6526: PPUSH
6527: PPUSH
6528: PPUSH
// uc_side := 1 ;
6529: LD_ADDR_OWVAR 20
6533: PUSH
6534: LD_INT 1
6536: ST_TO_ADDR
// uc_nation := 1 ;
6537: LD_ADDR_OWVAR 21
6541: PUSH
6542: LD_INT 1
6544: ST_TO_ADDR
// InitHc ;
6545: CALL_OW 19
// InitVc ;
6549: CALL_OW 20
// tmp := [ ] ;
6553: LD_ADDR_VAR 0 3
6557: PUSH
6558: EMPTY
6559: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6560: LD_ADDR_VAR 0 2
6564: PUSH
6565: DOUBLE
6566: LD_INT 1
6568: DEC
6569: ST_TO_ADDR
6570: LD_INT 5
6572: PUSH
6573: LD_INT 6
6575: PUSH
6576: LD_INT 6
6578: PUSH
6579: EMPTY
6580: LIST
6581: LIST
6582: LIST
6583: PUSH
6584: LD_OWVAR 67
6588: ARRAY
6589: PUSH
6590: FOR_TO
6591: IFFALSE 6728
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6593: LD_INT 2
6595: PUSH
6596: LD_INT 4
6598: PUSH
6599: LD_INT 5
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: LIST
6606: PUSH
6607: LD_INT 1
6609: PPUSH
6610: LD_INT 3
6612: PPUSH
6613: CALL_OW 12
6617: ARRAY
6618: PPUSH
6619: LD_INT 1
6621: PUSH
6622: LD_INT 3
6624: PUSH
6625: EMPTY
6626: LIST
6627: LIST
6628: PUSH
6629: LD_INT 1
6631: PPUSH
6632: LD_INT 2
6634: PPUSH
6635: CALL_OW 12
6639: ARRAY
6640: PPUSH
6641: LD_INT 3
6643: PPUSH
6644: LD_INT 9
6646: PUSH
6647: LD_INT 7
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 1
6656: PPUSH
6657: LD_INT 2
6659: PPUSH
6660: CALL_OW 12
6664: ARRAY
6665: PPUSH
6666: LD_INT 78
6668: PPUSH
6669: CALL 21407 0 5
// veh := CreateVehicle ;
6673: LD_ADDR_VAR 0 4
6677: PUSH
6678: CALL_OW 45
6682: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6683: LD_VAR 0 4
6687: PPUSH
6688: LD_INT 2
6690: PPUSH
6691: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6695: LD_VAR 0 4
6699: PPUSH
6700: LD_INT 17
6702: PPUSH
6703: LD_INT 0
6705: PPUSH
6706: CALL_OW 49
// tmp := tmp ^ veh ;
6710: LD_ADDR_VAR 0 3
6714: PUSH
6715: LD_VAR 0 3
6719: PUSH
6720: LD_VAR 0 4
6724: ADD
6725: ST_TO_ADDR
// end ;
6726: GO 6590
6728: POP
6729: POP
// if not tmp then
6730: LD_VAR 0 3
6734: NOT
6735: IFFALSE 6739
// exit ;
6737: GO 6848
// if not first_powell_attack then
6739: LD_EXP 11
6743: NOT
6744: IFFALSE 6754
// first_powell_attack := true ;
6746: LD_ADDR_EXP 11
6750: PUSH
6751: LD_INT 1
6753: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6754: LD_INT 70
6756: PPUSH
6757: CALL_OW 67
// for i in tmp do
6761: LD_ADDR_VAR 0 2
6765: PUSH
6766: LD_VAR 0 3
6770: PUSH
6771: FOR_IN
6772: IFFALSE 6839
// if IsOk ( i ) then
6774: LD_VAR 0 2
6778: PPUSH
6779: CALL_OW 302
6783: IFFALSE 6821
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6785: LD_VAR 0 2
6789: PPUSH
6790: LD_INT 81
6792: PUSH
6793: LD_INT 1
6795: PUSH
6796: EMPTY
6797: LIST
6798: LIST
6799: PPUSH
6800: CALL_OW 69
6804: PPUSH
6805: LD_VAR 0 2
6809: PPUSH
6810: CALL_OW 74
6814: PPUSH
6815: CALL_OW 115
6819: GO 6837
// tmp := tmp diff i ;
6821: LD_ADDR_VAR 0 3
6825: PUSH
6826: LD_VAR 0 3
6830: PUSH
6831: LD_VAR 0 2
6835: DIFF
6836: ST_TO_ADDR
6837: GO 6771
6839: POP
6840: POP
// until not tmp ;
6841: LD_VAR 0 3
6845: NOT
6846: IFFALSE 6754
// end ; end_of_file
6848: LD_VAR 0 1
6852: RET
// export function Action ; var tmp , i , un ; begin
6853: LD_INT 0
6855: PPUSH
6856: PPUSH
6857: PPUSH
6858: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6859: LD_INT 68
6861: PPUSH
6862: LD_INT 39
6864: PPUSH
6865: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6869: LD_ADDR_VAR 0 2
6873: PUSH
6874: LD_INT 22
6876: PUSH
6877: LD_INT 7
6879: PUSH
6880: EMPTY
6881: LIST
6882: LIST
6883: PPUSH
6884: CALL_OW 69
6888: ST_TO_ADDR
// InGameOn ;
6889: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6893: LD_VAR 0 2
6897: PPUSH
6898: LD_INT 71
6900: PPUSH
6901: LD_INT 49
6903: PPUSH
6904: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6908: LD_INT 35
6910: PPUSH
6911: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6915: LD_INT 7
6917: PPUSH
6918: LD_INT 71
6920: PPUSH
6921: LD_INT 51
6923: PPUSH
6924: CALL_OW 293
6928: IFFALSE 6908
// DialogueOn ;
6930: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6934: LD_EXP 15
6938: PPUSH
6939: LD_STRING D1-JMM-1
6941: PPUSH
6942: CALL_OW 88
// if Joan then
6946: LD_EXP 30
6950: IFFALSE 6964
// Say ( Joan , D1-Joan-1 ) ;
6952: LD_EXP 30
6956: PPUSH
6957: LD_STRING D1-Joan-1
6959: PPUSH
6960: CALL_OW 88
// if Lisa then
6964: LD_EXP 17
6968: IFFALSE 6982
// Say ( Lisa , D1-Lisa-1 ) ;
6970: LD_EXP 17
6974: PPUSH
6975: LD_STRING D1-Lisa-1
6977: PPUSH
6978: CALL_OW 88
// if Joan or Lisa then
6982: LD_EXP 30
6986: PUSH
6987: LD_EXP 17
6991: OR
6992: IFFALSE 7006
// Say ( JMM , D1-JMM-2 ) ;
6994: LD_EXP 15
6998: PPUSH
6999: LD_STRING D1-JMM-2
7001: PPUSH
7002: CALL_OW 88
// DialogueOff ;
7006: CALL_OW 7
// InGameOff ;
7010: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7014: LD_INT 71
7016: PPUSH
7017: LD_INT 50
7019: PPUSH
7020: LD_INT 7
7022: PPUSH
7023: LD_INT 30
7025: NEG
7026: PPUSH
7027: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7031: LD_INT 71
7033: PPUSH
7034: LD_INT 50
7036: PPUSH
7037: LD_INT 7
7039: PPUSH
7040: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7044: LD_STRING M1
7046: PPUSH
7047: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7051: LD_INT 35
7053: PPUSH
7054: CALL_OW 67
// until freedom ;
7058: LD_EXP 3
7062: IFFALSE 7051
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7064: LD_INT 350
7066: PPUSH
7067: LD_INT 700
7069: PPUSH
7070: CALL_OW 12
7074: PPUSH
7075: CALL_OW 67
// PrepareGossudarov ;
7079: CALL 1802 0 0
// repeat wait ( 0 0$1 ) ;
7083: LD_INT 35
7085: PPUSH
7086: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7090: LD_INT 22
7092: PUSH
7093: LD_INT 6
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 24
7105: PUSH
7106: LD_INT 1000
7108: PUSH
7109: EMPTY
7110: LIST
7111: LIST
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: PUSH
7117: EMPTY
7118: LIST
7119: LIST
7120: PPUSH
7121: CALL_OW 69
7125: PUSH
7126: LD_INT 7
7128: PPUSH
7129: LD_EXP 32
7133: PPUSH
7134: CALL_OW 292
7138: OR
7139: IFFALSE 7083
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7141: LD_ADDR_VAR 0 2
7145: PUSH
7146: LD_INT 22
7148: PUSH
7149: LD_INT 6
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: PPUSH
7156: CALL_OW 69
7160: ST_TO_ADDR
// for i in tmp do
7161: LD_ADDR_VAR 0 3
7165: PUSH
7166: LD_VAR 0 2
7170: PUSH
7171: FOR_IN
7172: IFFALSE 7188
// SetSide ( i , 7 ) ;
7174: LD_VAR 0 3
7178: PPUSH
7179: LD_INT 7
7181: PPUSH
7182: CALL_OW 235
7186: GO 7171
7188: POP
7189: POP
// DialogueOn ;
7190: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7194: LD_EXP 15
7198: PUSH
7199: LD_EXP 16
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: PPUSH
7208: LD_EXP 32
7212: PPUSH
7213: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7217: LD_EXP 32
7221: PPUSH
7222: CALL_OW 87
// if not Roth then
7226: LD_EXP 16
7230: NOT
7231: IFFALSE 7323
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7233: LD_VAR 0 2
7237: PPUSH
7238: LD_INT 3
7240: PUSH
7241: LD_INT 24
7243: PUSH
7244: LD_INT 1000
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: PPUSH
7255: CALL_OW 72
7259: IFFALSE 7273
// Say ( JMM , D2-JMM-1 ) ;
7261: LD_EXP 15
7265: PPUSH
7266: LD_STRING D2-JMM-1
7268: PPUSH
7269: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7273: LD_EXP 15
7277: PPUSH
7278: LD_STRING D2-JMM-1b
7280: PPUSH
7281: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7285: LD_EXP 32
7289: PPUSH
7290: LD_STRING D2-Gos-1
7292: PPUSH
7293: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7297: LD_EXP 15
7301: PPUSH
7302: LD_STRING D2-JMM-2
7304: PPUSH
7305: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7309: LD_EXP 32
7313: PPUSH
7314: LD_STRING D2-Gos-2
7316: PPUSH
7317: CALL_OW 88
// end else
7321: GO 7475
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7323: LD_VAR 0 2
7327: PPUSH
7328: LD_INT 3
7330: PUSH
7331: LD_INT 24
7333: PUSH
7334: LD_INT 1000
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: PPUSH
7345: CALL_OW 72
7349: IFFALSE 7375
// begin Say ( Roth , D2-Roth-2 ) ;
7351: LD_EXP 16
7355: PPUSH
7356: LD_STRING D2-Roth-2
7358: PPUSH
7359: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7363: LD_EXP 15
7367: PPUSH
7368: LD_STRING D2-JMM-1a
7370: PPUSH
7371: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7375: LD_EXP 16
7379: PPUSH
7380: LD_STRING D2-Roth-2a
7382: PPUSH
7383: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7387: LD_EXP 16
7391: PPUSH
7392: LD_STRING D2-Roth-2b
7394: PPUSH
7395: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7399: LD_EXP 15
7403: PPUSH
7404: LD_STRING D2-JMM-3
7406: PPUSH
7407: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7411: LD_VAR 0 2
7415: PPUSH
7416: LD_INT 3
7418: PUSH
7419: LD_INT 24
7421: PUSH
7422: LD_INT 1000
7424: PUSH
7425: EMPTY
7426: LIST
7427: LIST
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: PPUSH
7433: CALL_OW 72
7437: IFFALSE 7475
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7439: LD_EXP 32
7443: PPUSH
7444: LD_STRING D2-Gos-3
7446: PPUSH
7447: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7451: LD_EXP 15
7455: PPUSH
7456: LD_STRING D2-JMM-4
7458: PPUSH
7459: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7463: LD_EXP 32
7467: PPUSH
7468: LD_STRING D2-Gos-4
7470: PPUSH
7471: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7475: LD_EXP 15
7479: PPUSH
7480: LD_STRING D2-JMM-5
7482: PPUSH
7483: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7487: LD_EXP 32
7491: PPUSH
7492: LD_STRING D2-Gos-5
7494: PPUSH
7495: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7499: LD_EXP 15
7503: PPUSH
7504: LD_STRING D2-JMM-6
7506: PPUSH
7507: CALL_OW 88
// DialogueOff ;
7511: CALL_OW 7
// wait ( 0 0$2 ) ;
7515: LD_INT 70
7517: PPUSH
7518: CALL_OW 67
// if Kirilenkova then
7522: LD_EXP 33
7526: IFFALSE 7540
// Say ( Kirilenkova , D3-Kir-1 ) ;
7528: LD_EXP 33
7532: PPUSH
7533: LD_STRING D3-Kir-1
7535: PPUSH
7536: CALL_OW 88
// gossudarov_arrive := true ;
7540: LD_ADDR_EXP 4
7544: PUSH
7545: LD_INT 1
7547: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7548: LD_INT 35
7550: PPUSH
7551: CALL_OW 67
// until ru_lab_builded ;
7555: LD_EXP 5
7559: IFFALSE 7548
// DialogueOn ;
7561: CALL_OW 6
// if Kirilenkova then
7565: LD_EXP 33
7569: IFFALSE 7585
// Say ( Kirilenkova , D3a-Kir-1 ) else
7571: LD_EXP 33
7575: PPUSH
7576: LD_STRING D3a-Kir-1
7578: PPUSH
7579: CALL_OW 88
7583: GO 7607
// begin un := SciRu ;
7585: LD_ADDR_VAR 0 4
7589: PUSH
7590: CALL 12719 0 0
7594: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7595: LD_VAR 0 4
7599: PPUSH
7600: LD_STRING D3a-Sci1-1
7602: PPUSH
7603: CALL_OW 88
// end ; if Kirilenkova or un then
7607: LD_EXP 33
7611: PUSH
7612: LD_VAR 0 4
7616: OR
7617: IFFALSE 7631
// Say ( JMM , D3a-JMM-1 ) ;
7619: LD_EXP 15
7623: PPUSH
7624: LD_STRING D3a-JMM-1
7626: PPUSH
7627: CALL_OW 88
// DialogueOff ;
7631: CALL_OW 7
// end ;
7635: LD_VAR 0 1
7639: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7640: LD_EXP 4
7644: PUSH
7645: LD_INT 22
7647: PUSH
7648: LD_INT 7
7650: PUSH
7651: EMPTY
7652: LIST
7653: LIST
7654: PUSH
7655: LD_INT 2
7657: PUSH
7658: LD_INT 25
7660: PUSH
7661: LD_INT 1
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: LD_INT 25
7670: PUSH
7671: LD_INT 2
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: PUSH
7678: LD_INT 25
7680: PUSH
7681: LD_INT 3
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: LD_INT 25
7690: PUSH
7691: LD_INT 4
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: PUSH
7698: LD_INT 25
7700: PUSH
7701: LD_INT 5
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: PUSH
7708: LD_INT 25
7710: PUSH
7711: LD_INT 8
7713: PUSH
7714: EMPTY
7715: LIST
7716: LIST
7717: PUSH
7718: LD_INT 25
7720: PUSH
7721: LD_INT 9
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: LIST
7736: LIST
7737: PUSH
7738: EMPTY
7739: LIST
7740: LIST
7741: PPUSH
7742: CALL_OW 69
7746: PUSH
7747: LD_INT 7
7749: LESS
7750: AND
7751: IFFALSE 7763
7753: GO 7755
7755: DISABLE
// YouLost ( TooMany ) ;
7756: LD_STRING TooMany
7758: PPUSH
7759: CALL_OW 104
7763: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7764: LD_EXP 32
7768: PPUSH
7769: CALL_OW 255
7773: PUSH
7774: LD_INT 7
7776: EQUAL
7777: IFFALSE 7977
7779: GO 7781
7781: DISABLE
7782: LD_INT 0
7784: PPUSH
7785: PPUSH
7786: PPUSH
// begin uc_side := 3 ;
7787: LD_ADDR_OWVAR 20
7791: PUSH
7792: LD_INT 3
7794: ST_TO_ADDR
// uc_nation := 3 ;
7795: LD_ADDR_OWVAR 21
7799: PUSH
7800: LD_INT 3
7802: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7803: LD_INT 21
7805: PPUSH
7806: LD_INT 3
7808: PPUSH
7809: LD_INT 3
7811: PPUSH
7812: LD_INT 42
7814: PPUSH
7815: LD_INT 100
7817: PPUSH
7818: CALL 21407 0 5
// un := CreateVehicle ;
7822: LD_ADDR_VAR 0 3
7826: PUSH
7827: CALL_OW 45
7831: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7832: LD_VAR 0 3
7836: PPUSH
7837: LD_INT 15
7839: PPUSH
7840: LD_INT 0
7842: PPUSH
7843: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7847: LD_VAR 0 3
7851: PPUSH
7852: LD_INT 67
7854: PPUSH
7855: LD_INT 45
7857: PPUSH
7858: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7862: LD_VAR 0 3
7866: PPUSH
7867: LD_INT 70
7869: PPUSH
7870: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7874: LD_VAR 0 3
7878: PPUSH
7879: LD_INT 69
7881: PPUSH
7882: LD_INT 18
7884: PPUSH
7885: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7889: LD_VAR 0 3
7893: PPUSH
7894: LD_INT 60
7896: PPUSH
7897: LD_INT 2
7899: PPUSH
7900: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7904: LD_INT 35
7906: PPUSH
7907: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7911: LD_VAR 0 3
7915: PPUSH
7916: CALL_OW 302
7920: NOT
7921: PUSH
7922: LD_VAR 0 3
7926: PPUSH
7927: LD_INT 17
7929: PPUSH
7930: CALL_OW 308
7934: OR
7935: IFFALSE 7904
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7937: LD_VAR 0 3
7941: PPUSH
7942: LD_INT 17
7944: PPUSH
7945: CALL_OW 308
7949: PUSH
7950: LD_VAR 0 3
7954: PPUSH
7955: LD_INT 60
7957: PPUSH
7958: LD_INT 2
7960: PPUSH
7961: CALL_OW 307
7965: OR
7966: IFFALSE 7977
// RemoveUnit ( un ) ;
7968: LD_VAR 0 3
7972: PPUSH
7973: CALL_OW 64
// end ;
7977: PPOPN 3
7979: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
7980: LD_EXP 4
7984: IFFALSE 8226
7986: GO 7988
7988: DISABLE
7989: LD_INT 0
7991: PPUSH
7992: PPUSH
7993: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7994: LD_INT 70
7996: PPUSH
7997: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8001: LD_ADDR_VAR 0 3
8005: PUSH
8006: LD_INT 22
8008: PUSH
8009: LD_INT 7
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: PUSH
8016: LD_INT 101
8018: PUSH
8019: LD_INT 3
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: EMPTY
8027: LIST
8028: LIST
8029: PPUSH
8030: CALL_OW 69
8034: ST_TO_ADDR
// until tmp ;
8035: LD_VAR 0 3
8039: IFFALSE 7994
// un := NearestUnitToUnit ( tmp , JMM ) ;
8041: LD_ADDR_VAR 0 2
8045: PUSH
8046: LD_VAR 0 3
8050: PPUSH
8051: LD_EXP 15
8055: PPUSH
8056: CALL_OW 74
8060: ST_TO_ADDR
// player_spotted := true ;
8061: LD_ADDR_EXP 6
8065: PUSH
8066: LD_INT 1
8068: ST_TO_ADDR
// tmp := SciRu ;
8069: LD_ADDR_VAR 0 3
8073: PUSH
8074: CALL 12719 0 0
8078: ST_TO_ADDR
// if not tmp then
8079: LD_VAR 0 3
8083: NOT
8084: IFFALSE 8096
// tmp := SolRu ;
8086: LD_ADDR_VAR 0 3
8090: PUSH
8091: CALL 12866 0 0
8095: ST_TO_ADDR
// DialogueOn ;
8096: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8100: LD_VAR 0 2
8104: PPUSH
8105: CALL_OW 250
8109: PPUSH
8110: LD_VAR 0 2
8114: PPUSH
8115: CALL_OW 251
8119: PPUSH
8120: LD_INT 7
8122: PPUSH
8123: LD_INT 8
8125: NEG
8126: PPUSH
8127: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8131: LD_VAR 0 2
8135: PPUSH
8136: CALL_OW 87
// if tmp then
8140: LD_VAR 0 3
8144: IFFALSE 8158
// Say ( tmp , D4-RSci1-1 ) ;
8146: LD_VAR 0 3
8150: PPUSH
8151: LD_STRING D4-RSci1-1
8153: PPUSH
8154: CALL_OW 88
// if Gossudarov then
8158: LD_EXP 32
8162: IFFALSE 8188
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8164: LD_EXP 32
8168: PPUSH
8169: LD_STRING D4-Gos-1
8171: PPUSH
8172: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8176: LD_EXP 15
8180: PPUSH
8181: LD_STRING D4-JMM-1
8183: PPUSH
8184: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8188: LD_VAR 0 2
8192: PPUSH
8193: CALL_OW 250
8197: PPUSH
8198: LD_VAR 0 2
8202: PPUSH
8203: CALL_OW 251
8207: PPUSH
8208: LD_INT 7
8210: PPUSH
8211: CALL_OW 331
// DialogueOff ;
8215: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8219: LD_STRING M5
8221: PPUSH
8222: CALL_OW 337
// end ;
8226: PPOPN 3
8228: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8229: LD_EXP 6
8233: IFFALSE 8822
8235: GO 8237
8237: DISABLE
8238: LD_INT 0
8240: PPUSH
8241: PPUSH
8242: PPUSH
// begin PrepareBelkov ;
8243: CALL 2092 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8247: LD_EXP 47
8251: PPUSH
8252: LD_INT 118
8254: PPUSH
8255: LD_INT 106
8257: PPUSH
8258: CALL_OW 111
// AddComHold ( Belkov ) ;
8262: LD_EXP 47
8266: PPUSH
8267: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8271: LD_INT 35
8273: PPUSH
8274: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8278: LD_EXP 47
8282: PPUSH
8283: LD_INT 118
8285: PPUSH
8286: LD_INT 106
8288: PPUSH
8289: CALL_OW 307
8293: IFFALSE 8271
// ChangeSideFog ( 4 , 7 ) ;
8295: LD_INT 4
8297: PPUSH
8298: LD_INT 7
8300: PPUSH
8301: CALL_OW 343
// if IsOk ( Belkov ) then
8305: LD_EXP 47
8309: PPUSH
8310: CALL_OW 302
8314: IFFALSE 8398
// begin InGameOn ;
8316: CALL_OW 8
// DialogueOn ;
8320: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8324: LD_EXP 47
8328: PPUSH
8329: LD_STRING D5-Bel-1
8331: PPUSH
8332: CALL_OW 94
// if Gossudarov then
8336: LD_EXP 32
8340: IFFALSE 8390
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8342: LD_EXP 32
8346: PPUSH
8347: LD_STRING D5-Gos-1
8349: PPUSH
8350: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8354: LD_EXP 15
8358: PPUSH
8359: LD_STRING D5-JMM-1
8361: PPUSH
8362: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8366: LD_EXP 32
8370: PPUSH
8371: LD_STRING D5-Gos-2
8373: PPUSH
8374: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8378: LD_EXP 15
8382: PPUSH
8383: LD_STRING D5-JMM-2
8385: PPUSH
8386: CALL_OW 88
// end ; DialogueOff ;
8390: CALL_OW 7
// InGameOff ;
8394: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8398: LD_STRING QSaveBelkov
8400: PPUSH
8401: CALL_OW 97
8405: PUSH
8406: LD_INT 1
8408: DOUBLE
8409: EQUAL
8410: IFTRUE 8414
8412: GO 8464
8414: POP
// begin DialogueOn ;
8415: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8419: LD_EXP 15
8423: PPUSH
8424: LD_STRING D5a-JMM-1
8426: PPUSH
8427: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8431: LD_EXP 47
8435: PPUSH
8436: LD_STRING D5a-Bel-1
8438: PPUSH
8439: CALL_OW 94
// DialogueOff ;
8443: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8447: LD_EXP 47
8451: PPUSH
8452: LD_INT 83
8454: PPUSH
8455: LD_INT 49
8457: PPUSH
8458: CALL_OW 111
// end ; 2 :
8462: GO 8497
8464: LD_INT 2
8466: DOUBLE
8467: EQUAL
8468: IFTRUE 8472
8470: GO 8496
8472: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8473: LD_EXP 15
8477: PPUSH
8478: LD_STRING D5a-JMM-2
8480: PPUSH
8481: CALL_OW 88
// ComHold ( Belkov ) ;
8485: LD_EXP 47
8489: PPUSH
8490: CALL_OW 140
// end ; end ;
8494: GO 8497
8496: POP
// time := 0 0$00 ;
8497: LD_ADDR_VAR 0 1
8501: PUSH
8502: LD_INT 0
8504: ST_TO_ADDR
// vehSpawned := false ;
8505: LD_ADDR_VAR 0 3
8509: PUSH
8510: LD_INT 0
8512: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8513: LD_INT 35
8515: PPUSH
8516: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8520: LD_VAR 0 1
8524: PUSH
8525: LD_INT 350
8527: PUSH
8528: LD_INT 175
8530: PUSH
8531: LD_INT 70
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: LIST
8538: PUSH
8539: LD_OWVAR 67
8543: ARRAY
8544: GREATEREQUAL
8545: PUSH
8546: LD_VAR 0 3
8550: NOT
8551: AND
8552: IFFALSE 8642
// begin vehSpawned := true ;
8554: LD_ADDR_VAR 0 3
8558: PUSH
8559: LD_INT 1
8561: ST_TO_ADDR
// uc_side := 3 ;
8562: LD_ADDR_OWVAR 20
8566: PUSH
8567: LD_INT 3
8569: ST_TO_ADDR
// uc_nation := 3 ;
8570: LD_ADDR_OWVAR 21
8574: PUSH
8575: LD_INT 3
8577: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8578: LD_INT 22
8580: PPUSH
8581: LD_INT 3
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: LD_INT 43
8589: PPUSH
8590: LD_INT 100
8592: PPUSH
8593: CALL 21407 0 5
// veh := CreateVehicle ;
8597: LD_ADDR_VAR 0 2
8601: PUSH
8602: CALL_OW 45
8606: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8607: LD_VAR 0 2
8611: PPUSH
8612: LD_INT 130
8614: PPUSH
8615: LD_INT 131
8617: PPUSH
8618: LD_INT 0
8620: PPUSH
8621: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8625: LD_VAR 0 2
8629: PPUSH
8630: LD_INT 100
8632: PPUSH
8633: LD_INT 82
8635: PPUSH
8636: CALL_OW 114
// end else
8640: GO 8656
// time := time + 0 0$1 ;
8642: LD_ADDR_VAR 0 1
8646: PUSH
8647: LD_VAR 0 1
8651: PUSH
8652: LD_INT 35
8654: PLUS
8655: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8656: LD_EXP 47
8660: PPUSH
8661: CALL_OW 301
8665: PUSH
8666: LD_EXP 47
8670: PPUSH
8671: CALL_OW 255
8675: PUSH
8676: LD_INT 4
8678: EQUAL
8679: AND
8680: PUSH
8681: LD_INT 22
8683: PUSH
8684: LD_INT 7
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: PPUSH
8691: CALL_OW 69
8695: PPUSH
8696: LD_EXP 47
8700: PPUSH
8701: CALL_OW 74
8705: PPUSH
8706: LD_EXP 47
8710: PPUSH
8711: CALL_OW 296
8715: PUSH
8716: LD_INT 10
8718: LESS
8719: OR
8720: IFFALSE 8513
// if IsDead ( Belkov ) then
8722: LD_EXP 47
8726: PPUSH
8727: CALL_OW 301
8731: IFFALSE 8756
// begin CenterNowOnUnits ( Belkov ) ;
8733: LD_EXP 47
8737: PPUSH
8738: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8742: LD_EXP 15
8746: PPUSH
8747: LD_STRING D5a-JMM-2a
8749: PPUSH
8750: CALL_OW 88
// exit ;
8754: GO 8822
// end ; if See ( 7 , Belkov ) then
8756: LD_INT 7
8758: PPUSH
8759: LD_EXP 47
8763: PPUSH
8764: CALL_OW 292
8768: IFFALSE 8782
// SetSide ( Belkov , 7 ) ;
8770: LD_EXP 47
8774: PPUSH
8775: LD_INT 7
8777: PPUSH
8778: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8782: LD_INT 35
8784: PPUSH
8785: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8789: LD_EXP 47
8793: PPUSH
8794: LD_INT 66
8796: PPUSH
8797: LD_INT 45
8799: PPUSH
8800: CALL_OW 297
8804: PUSH
8805: LD_INT 30
8807: LESS
8808: IFFALSE 8782
// Say ( Belkov , D6-Bel-1 ) ;
8810: LD_EXP 47
8814: PPUSH
8815: LD_STRING D6-Bel-1
8817: PPUSH
8818: CALL_OW 88
// end ;
8822: PPOPN 3
8824: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8825: LD_EXP 47
8829: PPUSH
8830: CALL_OW 302
8834: PUSH
8835: LD_EXP 47
8839: PPUSH
8840: CALL_OW 504
8844: PUSH
8845: LD_INT 2
8847: PUSH
8848: LD_INT 34
8850: PUSH
8851: LD_INT 47
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: PUSH
8858: LD_INT 34
8860: PUSH
8861: LD_INT 45
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PUSH
8868: EMPTY
8869: LIST
8870: LIST
8871: LIST
8872: PPUSH
8873: CALL_OW 69
8877: IN
8878: AND
8879: IFFALSE 8896
8881: GO 8883
8883: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8884: LD_EXP 47
8888: PPUSH
8889: LD_STRING D7-Bel-1
8891: PPUSH
8892: CALL_OW 88
8896: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8897: LD_INT 22
8899: PUSH
8900: LD_INT 7
8902: PUSH
8903: EMPTY
8904: LIST
8905: LIST
8906: PUSH
8907: LD_INT 101
8909: PUSH
8910: LD_INT 2
8912: PUSH
8913: EMPTY
8914: LIST
8915: LIST
8916: PUSH
8917: EMPTY
8918: LIST
8919: LIST
8920: PPUSH
8921: CALL_OW 69
8925: PUSH
8926: LD_EXP 8
8930: NOT
8931: AND
8932: PUSH
8933: LD_EXP 46
8937: PPUSH
8938: CALL_OW 305
8942: NOT
8943: AND
8944: IFFALSE 9414
8946: GO 8948
8948: DISABLE
8949: LD_INT 0
8951: PPUSH
// begin ar_base_spotted := true ;
8952: LD_ADDR_EXP 8
8956: PUSH
8957: LD_INT 1
8959: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8960: LD_ADDR_VAR 0 1
8964: PUSH
8965: LD_INT 22
8967: PUSH
8968: LD_INT 2
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: PUSH
8975: LD_INT 21
8977: PUSH
8978: LD_INT 3
8980: PUSH
8981: EMPTY
8982: LIST
8983: LIST
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: PPUSH
8989: CALL_OW 69
8993: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8994: LD_ADDR_VAR 0 1
8998: PUSH
8999: LD_VAR 0 1
9003: PPUSH
9004: LD_EXP 15
9008: PPUSH
9009: CALL_OW 74
9013: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9014: LD_INT 7
9016: PPUSH
9017: LD_INT 3
9019: PPUSH
9020: CALL_OW 332
// DialogueOn ;
9024: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9028: LD_VAR 0 1
9032: PPUSH
9033: CALL_OW 250
9037: PPUSH
9038: LD_VAR 0 1
9042: PPUSH
9043: CALL_OW 251
9047: PPUSH
9048: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9052: LD_ADDR_VAR 0 1
9056: PUSH
9057: LD_INT 22
9059: PUSH
9060: LD_INT 7
9062: PUSH
9063: EMPTY
9064: LIST
9065: LIST
9066: PUSH
9067: LD_INT 23
9069: PUSH
9070: LD_INT 1
9072: PUSH
9073: EMPTY
9074: LIST
9075: LIST
9076: PUSH
9077: LD_INT 26
9079: PUSH
9080: LD_INT 1
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: PUSH
9087: EMPTY
9088: LIST
9089: LIST
9090: LIST
9091: PPUSH
9092: CALL_OW 69
9096: PUSH
9097: LD_EXP 15
9101: PUSH
9102: LD_EXP 19
9106: PUSH
9107: LD_EXP 20
9111: PUSH
9112: LD_EXP 27
9116: PUSH
9117: LD_EXP 16
9121: PUSH
9122: LD_EXP 25
9126: PUSH
9127: LD_EXP 21
9131: PUSH
9132: LD_EXP 23
9136: PUSH
9137: EMPTY
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: LIST
9145: LIST
9146: DIFF
9147: ST_TO_ADDR
// if not tmp then
9148: LD_VAR 0 1
9152: NOT
9153: IFFALSE 9227
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9155: LD_ADDR_VAR 0 1
9159: PUSH
9160: LD_INT 22
9162: PUSH
9163: LD_INT 7
9165: PUSH
9166: EMPTY
9167: LIST
9168: LIST
9169: PUSH
9170: LD_INT 23
9172: PUSH
9173: LD_INT 1
9175: PUSH
9176: EMPTY
9177: LIST
9178: LIST
9179: PUSH
9180: LD_INT 26
9182: PUSH
9183: LD_INT 2
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: LIST
9194: PPUSH
9195: CALL_OW 69
9199: PUSH
9200: LD_EXP 30
9204: PUSH
9205: LD_EXP 17
9209: PUSH
9210: LD_EXP 28
9214: PUSH
9215: LD_EXP 29
9219: PUSH
9220: EMPTY
9221: LIST
9222: LIST
9223: LIST
9224: LIST
9225: DIFF
9226: ST_TO_ADDR
// if tmp then
9227: LD_VAR 0 1
9231: IFFALSE 9302
// case GetSex ( tmp [ 1 ] ) of sex_male :
9233: LD_VAR 0 1
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: CALL_OW 258
9246: PUSH
9247: LD_INT 1
9249: DOUBLE
9250: EQUAL
9251: IFTRUE 9255
9253: GO 9274
9255: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9256: LD_VAR 0 1
9260: PUSH
9261: LD_INT 1
9263: ARRAY
9264: PPUSH
9265: LD_STRING D9-Sol1-1
9267: PPUSH
9268: CALL_OW 88
9272: GO 9302
9274: LD_INT 2
9276: DOUBLE
9277: EQUAL
9278: IFTRUE 9282
9280: GO 9301
9282: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9283: LD_VAR 0 1
9287: PUSH
9288: LD_INT 1
9290: ARRAY
9291: PPUSH
9292: LD_STRING D9-FSol1-1
9294: PPUSH
9295: CALL_OW 88
9299: GO 9302
9301: POP
// if Frank then
9302: LD_EXP 27
9306: IFFALSE 9410
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9308: LD_EXP 56
9312: PPUSH
9313: CALL_OW 250
9317: PPUSH
9318: LD_EXP 56
9322: PPUSH
9323: CALL_OW 251
9327: PPUSH
9328: LD_INT 7
9330: PPUSH
9331: LD_INT 8
9333: PPUSH
9334: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9338: LD_EXP 56
9342: PPUSH
9343: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9347: LD_EXP 27
9351: PPUSH
9352: LD_STRING D9-Frank-1
9354: PPUSH
9355: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9359: LD_EXP 15
9363: PPUSH
9364: LD_STRING D9-JMM-1
9366: PPUSH
9367: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9371: LD_EXP 27
9375: PPUSH
9376: LD_STRING D9-Frank-2
9378: PPUSH
9379: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9383: LD_EXP 56
9387: PPUSH
9388: CALL_OW 250
9392: PPUSH
9393: LD_EXP 56
9397: PPUSH
9398: CALL_OW 251
9402: PPUSH
9403: LD_INT 7
9405: PPUSH
9406: CALL_OW 331
// end ; DialogueOff ;
9410: CALL_OW 7
// end ;
9414: PPOPN 1
9416: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9417: LD_EXP 7
9421: PUSH
9422: LD_OWVAR 1
9426: PUSH
9427: LD_INT 42000
9429: GREATEREQUAL
9430: OR
9431: IFFALSE 10458
9433: GO 9435
9435: DISABLE
9436: LD_INT 0
9438: PPUSH
9439: PPUSH
// begin selected_option := 1 ;
9440: LD_ADDR_VAR 0 2
9444: PUSH
9445: LD_INT 1
9447: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9448: LD_INT 10500
9450: PPUSH
9451: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9455: LD_INT 35
9457: PPUSH
9458: CALL_OW 67
// until not ru_attackers ;
9462: LD_EXP 52
9466: NOT
9467: IFFALSE 9455
// PrepareBurlak ;
9469: CALL 2204 0 0
// repeat wait ( 0 0$2 ) ;
9473: LD_INT 70
9475: PPUSH
9476: CALL_OW 67
// until not HasTask ( Burlak ) ;
9480: LD_EXP 46
9484: PPUSH
9485: CALL_OW 314
9489: NOT
9490: IFFALSE 9473
// InGameOn ;
9492: CALL_OW 8
// DialogueOn ;
9496: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9500: LD_EXP 49
9504: PPUSH
9505: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9509: LD_EXP 46
9513: PPUSH
9514: LD_STRING D10-Bur-1
9516: PPUSH
9517: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9521: LD_EXP 47
9525: PUSH
9526: LD_EXP 47
9530: PPUSH
9531: CALL_OW 255
9535: PUSH
9536: LD_INT 7
9538: EQUAL
9539: AND
9540: IFFALSE 9554
// Say ( Belkov , D10-Bel-1 ) ;
9542: LD_EXP 47
9546: PPUSH
9547: LD_STRING D10-Bel-1
9549: PPUSH
9550: CALL_OW 88
// if Gossudarov then
9554: LD_EXP 32
9558: IFFALSE 9572
// Say ( Gossudarov , D10-Gos-1 ) ;
9560: LD_EXP 32
9564: PPUSH
9565: LD_STRING D10-Gos-1
9567: PPUSH
9568: CALL_OW 88
// if Kirilenkova then
9572: LD_EXP 33
9576: IFFALSE 9590
// Say ( Kirilenkova , D10-Kir-1 ) ;
9578: LD_EXP 33
9582: PPUSH
9583: LD_STRING D10-Kir-1
9585: PPUSH
9586: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9590: CALL 12866 0 0
9594: PPUSH
9595: LD_STRING D10-RSol1-1
9597: PPUSH
9598: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9602: LD_EXP 46
9606: PPUSH
9607: LD_STRING D10-Bur-2
9609: PPUSH
9610: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9614: LD_EXP 15
9618: PPUSH
9619: LD_STRING D10-JMM-2
9621: PPUSH
9622: CALL_OW 88
// if Kirilenkova then
9626: LD_EXP 33
9630: IFFALSE 9646
// Say ( Kirilenkova , D10-Kir-2 ) else
9632: LD_EXP 33
9636: PPUSH
9637: LD_STRING D10-Kir-2
9639: PPUSH
9640: CALL_OW 88
9644: GO 9658
// Say ( SolRu , D10-RSol1-2 ) ;
9646: CALL 12866 0 0
9650: PPUSH
9651: LD_STRING D10-RSol1-2
9653: PPUSH
9654: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9658: LD_EXP 15
9662: PPUSH
9663: LD_STRING D10-JMM-3
9665: PPUSH
9666: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9670: LD_EXP 46
9674: PPUSH
9675: LD_STRING D10-Bur-3
9677: PPUSH
9678: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9682: LD_EXP 15
9686: PPUSH
9687: LD_STRING D10-JMM-4
9689: PPUSH
9690: CALL_OW 88
// DialogueOff ;
9694: CALL_OW 7
// InGameOff ;
9698: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9702: LD_STRING M2
9704: PPUSH
9705: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9709: LD_INT 35
9711: PPUSH
9712: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9716: LD_INT 22
9718: PUSH
9719: LD_INT 7
9721: PUSH
9722: EMPTY
9723: LIST
9724: LIST
9725: PUSH
9726: LD_INT 91
9728: PUSH
9729: LD_EXP 46
9733: PUSH
9734: LD_INT 8
9736: PUSH
9737: EMPTY
9738: LIST
9739: LIST
9740: LIST
9741: PUSH
9742: EMPTY
9743: LIST
9744: LIST
9745: PPUSH
9746: CALL_OW 69
9750: IFFALSE 9709
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9752: LD_ADDR_VAR 0 1
9756: PUSH
9757: LD_INT 22
9759: PUSH
9760: LD_INT 4
9762: PUSH
9763: EMPTY
9764: LIST
9765: LIST
9766: PPUSH
9767: CALL_OW 69
9771: PUSH
9772: FOR_IN
9773: IFFALSE 9789
// SetSide ( i , 7 ) ;
9775: LD_VAR 0 1
9779: PPUSH
9780: LD_INT 7
9782: PPUSH
9783: CALL_OW 235
9787: GO 9772
9789: POP
9790: POP
// ChangeMissionObjectives ( M3 ) ;
9791: LD_STRING M3
9793: PPUSH
9794: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9798: LD_INT 35
9800: PPUSH
9801: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9805: LD_EXP 15
9809: PPUSH
9810: LD_EXP 46
9814: PPUSH
9815: CALL_OW 296
9819: PUSH
9820: LD_INT 8
9822: LESS
9823: IFFALSE 9798
// ComTurnUnit ( JMM , Burlak ) ;
9825: LD_EXP 15
9829: PPUSH
9830: LD_EXP 46
9834: PPUSH
9835: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9839: LD_EXP 46
9843: PPUSH
9844: LD_EXP 15
9848: PPUSH
9849: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9853: LD_INT 10
9855: PPUSH
9856: CALL_OW 67
// DialogueOn ;
9860: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9864: LD_EXP 15
9868: PPUSH
9869: LD_STRING D11-JMM-1
9871: PPUSH
9872: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9876: LD_EXP 46
9880: PPUSH
9881: LD_STRING D11-Bur-1
9883: PPUSH
9884: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9888: LD_EXP 15
9892: PPUSH
9893: LD_STRING D11-JMM-2
9895: PPUSH
9896: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9900: LD_EXP 46
9904: PPUSH
9905: LD_STRING D11-Bur-2
9907: PPUSH
9908: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9912: LD_EXP 15
9916: PPUSH
9917: LD_STRING D11-JMM-3
9919: PPUSH
9920: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9924: LD_EXP 46
9928: PPUSH
9929: LD_STRING D11-Bur-3
9931: PPUSH
9932: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9936: LD_EXP 15
9940: PPUSH
9941: LD_STRING D11-JMM-4
9943: PPUSH
9944: CALL_OW 88
// if ar_base_spotted then
9948: LD_EXP 8
9952: IFFALSE 9968
// Say ( Burlak , D12-Bur-1 ) else
9954: LD_EXP 46
9958: PPUSH
9959: LD_STRING D12-Bur-1
9961: PPUSH
9962: CALL_OW 88
9966: GO 10007
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9968: LD_INT 7
9970: PPUSH
9971: LD_INT 3
9973: PPUSH
9974: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9978: LD_INT 127
9980: PPUSH
9981: LD_INT 45
9983: PPUSH
9984: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9988: LD_EXP 46
9992: PPUSH
9993: LD_STRING D12-Bur-1a
9995: PPUSH
9996: CALL_OW 88
// dwait ( 0 0$2 ) ;
10000: LD_INT 70
10002: PPUSH
10003: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10007: LD_EXP 46
10011: PPUSH
10012: LD_STRING D12-Bur-1b
10014: PPUSH
10015: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10019: LD_EXP 15
10023: PPUSH
10024: LD_STRING D12-JMM-1
10026: PPUSH
10027: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10031: LD_EXP 46
10035: PPUSH
10036: LD_STRING D12-Bur-2
10038: PPUSH
10039: CALL_OW 88
// if Roth then
10043: LD_EXP 16
10047: IFFALSE 10063
// Say ( Roth , D12-Roth-2 ) else
10049: LD_EXP 16
10053: PPUSH
10054: LD_STRING D12-Roth-2
10056: PPUSH
10057: CALL_OW 88
10061: GO 10075
// Say ( SciRu , D12-RSci1-2 ) ;
10063: CALL 12719 0 0
10067: PPUSH
10068: LD_STRING D12-RSci1-2
10070: PPUSH
10071: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10075: LD_EXP 15
10079: PPUSH
10080: LD_STRING D12-JMM-2
10082: PPUSH
10083: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10087: LD_EXP 46
10091: PPUSH
10092: LD_STRING D12-Bur-3
10094: PPUSH
10095: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10099: LD_EXP 15
10103: PPUSH
10104: LD_STRING D12-JMM-3
10106: PPUSH
10107: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10111: LD_EXP 46
10115: PPUSH
10116: LD_STRING D12-Bur-4
10118: PPUSH
10119: CALL_OW 88
// case Query ( QBase ) of 1 :
10123: LD_STRING QBase
10125: PPUSH
10126: CALL_OW 97
10130: PUSH
10131: LD_INT 1
10133: DOUBLE
10134: EQUAL
10135: IFTRUE 10139
10137: GO 10257
10139: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10140: LD_EXP 15
10144: PPUSH
10145: LD_STRING D13a-JMM-1
10147: PPUSH
10148: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10152: LD_EXP 46
10156: PPUSH
10157: LD_STRING D13a-Bur-1
10159: PPUSH
10160: CALL_OW 88
// if Roth then
10164: LD_EXP 16
10168: IFFALSE 10184
// Say ( Roth , D13a-Roth-1 ) else
10170: LD_EXP 16
10174: PPUSH
10175: LD_STRING D13a-Roth-1
10177: PPUSH
10178: CALL_OW 88
10182: GO 10196
// Say ( SciRu , D13a-RSci1-1 ) ;
10184: CALL 12719 0 0
10188: PPUSH
10189: LD_STRING D13a-RSci1-1
10191: PPUSH
10192: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10196: LD_EXP 15
10200: PPUSH
10201: LD_STRING D13a-JMM-2
10203: PPUSH
10204: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10208: LD_STRING QBaseAgain
10210: PPUSH
10211: CALL_OW 97
10215: PUSH
10216: LD_INT 1
10218: DOUBLE
10219: EQUAL
10220: IFTRUE 10224
10222: GO 10235
10224: POP
// selected_option := 2 ; 2 :
10225: LD_ADDR_VAR 0 2
10229: PUSH
10230: LD_INT 2
10232: ST_TO_ADDR
10233: GO 10255
10235: LD_INT 2
10237: DOUBLE
10238: EQUAL
10239: IFTRUE 10243
10241: GO 10254
10243: POP
// selected_option := 3 ; end ;
10244: LD_ADDR_VAR 0 2
10248: PUSH
10249: LD_INT 3
10251: ST_TO_ADDR
10252: GO 10255
10254: POP
// end ; 2 :
10255: GO 10296
10257: LD_INT 2
10259: DOUBLE
10260: EQUAL
10261: IFTRUE 10265
10263: GO 10276
10265: POP
// selected_option := 2 ; 3 :
10266: LD_ADDR_VAR 0 2
10270: PUSH
10271: LD_INT 2
10273: ST_TO_ADDR
10274: GO 10296
10276: LD_INT 3
10278: DOUBLE
10279: EQUAL
10280: IFTRUE 10284
10282: GO 10295
10284: POP
// selected_option := 3 ; end ;
10285: LD_ADDR_VAR 0 2
10289: PUSH
10290: LD_INT 3
10292: ST_TO_ADDR
10293: GO 10296
10295: POP
// if selected_option = 2 then
10296: LD_VAR 0 2
10300: PUSH
10301: LD_INT 2
10303: EQUAL
10304: IFFALSE 10398
// begin Say ( JMM , D13b-JMM-1 ) ;
10306: LD_EXP 15
10310: PPUSH
10311: LD_STRING D13b-JMM-1
10313: PPUSH
10314: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10318: LD_EXP 46
10322: PPUSH
10323: LD_STRING D13b-Bur-1
10325: PPUSH
10326: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10330: LD_EXP 15
10334: PPUSH
10335: LD_STRING D13b-JMM-2
10337: PPUSH
10338: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10342: LD_EXP 55
10346: PPUSH
10347: LD_STRING D13b-Abd-2
10349: PPUSH
10350: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10354: LD_EXP 15
10358: PPUSH
10359: LD_STRING D13b-JMM-3
10361: PPUSH
10362: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10366: LD_EXP 55
10370: PPUSH
10371: LD_STRING D13b-Abd-3
10373: PPUSH
10374: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10378: LD_EXP 15
10382: PPUSH
10383: LD_STRING D13b-JMM-4
10385: PPUSH
10386: CALL_OW 88
// ar_active_attack := true ;
10390: LD_ADDR_EXP 9
10394: PUSH
10395: LD_INT 1
10397: ST_TO_ADDR
// end ; if selected_option = 3 then
10398: LD_VAR 0 2
10402: PUSH
10403: LD_INT 3
10405: EQUAL
10406: IFFALSE 10432
// begin Say ( JMM , D13c-JMM-1 ) ;
10408: LD_EXP 15
10412: PPUSH
10413: LD_STRING D13c-JMM-1
10415: PPUSH
10416: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10420: LD_EXP 46
10424: PPUSH
10425: LD_STRING D13c-Bur-1
10427: PPUSH
10428: CALL_OW 88
// end ; DialogueOff ;
10432: CALL_OW 7
// if not ar_active_attack then
10436: LD_EXP 9
10440: NOT
10441: IFFALSE 10458
// begin wait ( 6 6$00 ) ;
10443: LD_INT 12600
10445: PPUSH
10446: CALL_OW 67
// ar_active_attack := true ;
10450: LD_ADDR_EXP 9
10454: PUSH
10455: LD_INT 1
10457: ST_TO_ADDR
// end ; end ;
10458: PPOPN 2
10460: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10461: LD_EXP 46
10465: PPUSH
10466: CALL_OW 305
10470: PUSH
10471: LD_EXP 46
10475: PPUSH
10476: CALL_OW 255
10480: PUSH
10481: LD_INT 7
10483: EQUAL
10484: AND
10485: IFFALSE 10681
10487: GO 10489
10489: DISABLE
10490: LD_INT 0
10492: PPUSH
// begin wait ( 4 4$40 ) ;
10493: LD_INT 9800
10495: PPUSH
10496: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10500: LD_INT 35
10502: PPUSH
10503: CALL_OW 67
// until not ru_attackers ;
10507: LD_EXP 52
10511: NOT
10512: IFFALSE 10500
// PrepareGnyevko ;
10514: CALL 2148 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10518: LD_EXP 48
10522: PPUSH
10523: LD_INT 124
10525: PPUSH
10526: LD_INT 118
10528: PPUSH
10529: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10533: LD_EXP 48
10537: PPUSH
10538: CALL_OW 200
// time := 0 0$00 ;
10542: LD_ADDR_VAR 0 1
10546: PUSH
10547: LD_INT 0
10549: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10550: LD_INT 35
10552: PPUSH
10553: CALL_OW 67
// time := time + 0 0$1 ;
10557: LD_ADDR_VAR 0 1
10561: PUSH
10562: LD_VAR 0 1
10566: PUSH
10567: LD_INT 35
10569: PLUS
10570: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10571: LD_EXP 48
10575: PPUSH
10576: LD_INT 124
10578: PPUSH
10579: LD_INT 118
10581: PPUSH
10582: CALL_OW 307
10586: PUSH
10587: LD_VAR 0 1
10591: PUSH
10592: LD_INT 1050
10594: GREATEREQUAL
10595: OR
10596: IFFALSE 10550
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10598: LD_EXP 48
10602: PPUSH
10603: LD_STRING DBelkov-Gny-1
10605: PPUSH
10606: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10610: LD_EXP 46
10614: PPUSH
10615: LD_STRING DBelkov-Bur-1a
10617: PPUSH
10618: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10622: LD_INT 35
10624: PPUSH
10625: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10629: LD_EXP 48
10633: PPUSH
10634: LD_INT 22
10636: PUSH
10637: LD_INT 7
10639: PUSH
10640: EMPTY
10641: LIST
10642: LIST
10643: PPUSH
10644: CALL_OW 69
10648: PPUSH
10649: LD_EXP 48
10653: PPUSH
10654: CALL_OW 74
10658: PPUSH
10659: CALL_OW 296
10663: PUSH
10664: LD_INT 8
10666: LESS
10667: IFFALSE 10622
// SetSide ( Gnyevko , 7 ) ;
10669: LD_EXP 48
10673: PPUSH
10674: LD_INT 7
10676: PPUSH
10677: CALL_OW 235
// end ;
10681: PPOPN 1
10683: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10684: LD_EXP 46
10688: PPUSH
10689: CALL_OW 255
10693: PUSH
10694: LD_INT 7
10696: EQUAL
10697: IFFALSE 10707
10699: GO 10701
10701: DISABLE
// begin enable ;
10702: ENABLE
// PrepareAmericanAttack ;
10703: CALL 6523 0 0
// end ;
10707: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10708: LD_INT 22
10710: PUSH
10711: LD_INT 1
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: PPUSH
10718: CALL_OW 69
10722: IFFALSE 10906
10724: GO 10726
10726: DISABLE
10727: LD_INT 0
10729: PPUSH
10730: PPUSH
// begin while true do
10731: LD_INT 1
10733: IFFALSE 10790
// begin wait ( 0 0$1 ) ;
10735: LD_INT 35
10737: PPUSH
10738: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10742: LD_ADDR_VAR 0 2
10746: PUSH
10747: LD_INT 22
10749: PUSH
10750: LD_INT 1
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: PPUSH
10757: CALL_OW 69
10761: PPUSH
10762: LD_EXP 15
10766: PPUSH
10767: CALL_OW 74
10771: ST_TO_ADDR
// if See ( 7 , tmp ) then
10772: LD_INT 7
10774: PPUSH
10775: LD_VAR 0 2
10779: PPUSH
10780: CALL_OW 292
10784: IFFALSE 10788
// break ;
10786: GO 10790
// end ;
10788: GO 10731
// DialogueOn ;
10790: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10794: LD_VAR 0 2
10798: PPUSH
10799: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10803: LD_VAR 0 2
10807: PPUSH
10808: CALL_OW 250
10812: PPUSH
10813: LD_VAR 0 2
10817: PPUSH
10818: CALL_OW 251
10822: PPUSH
10823: LD_INT 7
10825: PPUSH
10826: LD_INT 8
10828: PPUSH
10829: CALL_OW 330
// if Denis then
10833: LD_EXP 21
10837: IFFALSE 10851
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10839: LD_EXP 21
10843: PPUSH
10844: LD_STRING DAmerAttack-Pet-1
10846: PPUSH
10847: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10851: LD_EXP 15
10855: PPUSH
10856: LD_STRING DAmerAttack-JMM-1
10858: PPUSH
10859: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10863: LD_EXP 46
10867: PPUSH
10868: LD_STRING DStop-Bur-1
10870: PPUSH
10871: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10875: LD_VAR 0 2
10879: PPUSH
10880: CALL_OW 250
10884: PPUSH
10885: LD_VAR 0 2
10889: PPUSH
10890: CALL_OW 251
10894: PPUSH
10895: LD_INT 7
10897: PPUSH
10898: CALL_OW 331
// DialogueOff ;
10902: CALL_OW 7
// end ;
10906: PPOPN 2
10908: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10909: LD_INT 22
10911: PUSH
10912: LD_INT 3
10914: PUSH
10915: EMPTY
10916: LIST
10917: LIST
10918: PUSH
10919: LD_INT 21
10921: PUSH
10922: LD_INT 1
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: PUSH
10929: EMPTY
10930: LIST
10931: LIST
10932: PPUSH
10933: CALL_OW 69
10937: PUSH
10938: LD_INT 0
10940: EQUAL
10941: IFFALSE 10983
10943: GO 10945
10945: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10946: LD_STRING M5a
10948: PPUSH
10949: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10953: LD_EXP 15
10957: PPUSH
10958: LD_STRING D8-JMM-1
10960: PPUSH
10961: CALL_OW 88
// if Gossudarov then
10965: LD_EXP 32
10969: IFFALSE 10983
// Say ( Gossudarov , D8-Gos-1 ) ;
10971: LD_EXP 32
10975: PPUSH
10976: LD_STRING D8-Gos-1
10978: PPUSH
10979: CALL_OW 88
// end ;
10983: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10984: LD_INT 22
10986: PUSH
10987: LD_INT 2
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: PUSH
10994: LD_INT 21
10996: PUSH
10997: LD_INT 1
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: PUSH
11004: EMPTY
11005: LIST
11006: LIST
11007: PPUSH
11008: CALL_OW 69
11012: PUSH
11013: LD_INT 0
11015: EQUAL
11016: IFFALSE 11066
11018: GO 11020
11020: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11021: LD_STRING M4c
11023: PPUSH
11024: CALL_OW 337
// if Roth then
11028: LD_EXP 16
11032: IFFALSE 11048
// Say ( Roth , DStop-Roth-1 ) else
11034: LD_EXP 16
11038: PPUSH
11039: LD_STRING DStop-Roth-1
11041: PPUSH
11042: CALL_OW 88
11046: GO 11066
// if Gossudarov then
11048: LD_EXP 32
11052: IFFALSE 11066
// Say ( Gossudarov , D8-Gos-1a ) ;
11054: LD_EXP 32
11058: PPUSH
11059: LD_STRING D8-Gos-1a
11061: PPUSH
11062: CALL_OW 88
// end ;
11066: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11067: LD_INT 7
11069: PPUSH
11070: LD_INT 1
11072: PPUSH
11073: LD_INT 1
11075: PPUSH
11076: CALL 14355 0 3
11080: PUSH
11081: LD_INT 0
11083: EQUAL
11084: PUSH
11085: LD_INT 7
11087: PPUSH
11088: LD_INT 3
11090: PPUSH
11091: LD_INT 1
11093: PPUSH
11094: CALL 14355 0 3
11098: PUSH
11099: LD_INT 0
11101: EQUAL
11102: AND
11103: IFFALSE 11115
11105: GO 11107
11107: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11108: LD_STRING M1a
11110: PPUSH
11111: CALL_OW 337
// end ;
11115: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11116: LD_INT 22
11118: PUSH
11119: LD_INT 2
11121: PUSH
11122: EMPTY
11123: LIST
11124: LIST
11125: PUSH
11126: LD_INT 21
11128: PUSH
11129: LD_INT 1
11131: PUSH
11132: EMPTY
11133: LIST
11134: LIST
11135: PUSH
11136: EMPTY
11137: LIST
11138: LIST
11139: PPUSH
11140: CALL_OW 69
11144: PUSH
11145: LD_INT 0
11147: EQUAL
11148: PUSH
11149: LD_INT 22
11151: PUSH
11152: LD_INT 3
11154: PUSH
11155: EMPTY
11156: LIST
11157: LIST
11158: PUSH
11159: LD_INT 21
11161: PUSH
11162: LD_INT 1
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PUSH
11169: EMPTY
11170: LIST
11171: LIST
11172: PPUSH
11173: CALL_OW 69
11177: PUSH
11178: LD_INT 0
11180: EQUAL
11181: AND
11182: PUSH
11183: LD_INT 22
11185: PUSH
11186: LD_INT 1
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: PPUSH
11193: CALL_OW 69
11197: PUSH
11198: LD_INT 0
11200: EQUAL
11201: AND
11202: PUSH
11203: LD_INT 7
11205: PPUSH
11206: LD_INT 1
11208: PPUSH
11209: LD_INT 1
11211: PPUSH
11212: CALL 14355 0 3
11216: PUSH
11217: LD_INT 0
11219: EQUAL
11220: AND
11221: PUSH
11222: LD_INT 7
11224: PPUSH
11225: LD_INT 3
11227: PPUSH
11228: LD_INT 1
11230: PPUSH
11231: CALL 14355 0 3
11235: PUSH
11236: LD_INT 0
11238: EQUAL
11239: AND
11240: IFFALSE 12716
11242: GO 11244
11244: DISABLE
11245: LD_INT 0
11247: PPUSH
11248: PPUSH
11249: PPUSH
11250: PPUSH
11251: PPUSH
11252: PPUSH
// begin m1 := false ;
11253: LD_ADDR_VAR 0 4
11257: PUSH
11258: LD_INT 0
11260: ST_TO_ADDR
// m2 := false ;
11261: LD_ADDR_VAR 0 5
11265: PUSH
11266: LD_INT 0
11268: ST_TO_ADDR
// m3 := false ;
11269: LD_ADDR_VAR 0 6
11273: PUSH
11274: LD_INT 0
11276: ST_TO_ADDR
// if tick < 40 40$00 then
11277: LD_OWVAR 1
11281: PUSH
11282: LD_INT 84000
11284: LESS
11285: IFFALSE 11294
// SetAchievement ( ACH_ASPEED_17 ) ;
11287: LD_STRING ACH_ASPEED_17
11289: PPUSH
11290: CALL_OW 543
// wait ( 0 0$1 ) ;
11294: LD_INT 35
11296: PPUSH
11297: CALL_OW 67
// if not IsDead ( Masha ) then
11301: LD_EXP 49
11305: PPUSH
11306: CALL_OW 301
11310: NOT
11311: IFFALSE 11333
// begin m1 := true ;
11313: LD_ADDR_VAR 0 4
11317: PUSH
11318: LD_INT 1
11320: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11321: LD_STRING Masha
11323: PPUSH
11324: LD_INT 1
11326: PPUSH
11327: CALL_OW 101
// end else
11331: GO 11344
// AddMedal ( Masha , - 1 ) ;
11333: LD_STRING Masha
11335: PPUSH
11336: LD_INT 1
11338: NEG
11339: PPUSH
11340: CALL_OW 101
// if abdul_escaped then
11344: LD_EXP 12
11348: IFFALSE 11363
// AddMedal ( Abdul , - 1 ) else
11350: LD_STRING Abdul
11352: PPUSH
11353: LD_INT 1
11355: NEG
11356: PPUSH
11357: CALL_OW 101
11361: GO 11381
// begin m2 := true ;
11363: LD_ADDR_VAR 0 5
11367: PUSH
11368: LD_INT 1
11370: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11371: LD_STRING Abdul
11373: PPUSH
11374: LD_INT 1
11376: PPUSH
11377: CALL_OW 101
// end ; if loss_counter = 0 then
11381: LD_EXP 13
11385: PUSH
11386: LD_INT 0
11388: EQUAL
11389: IFFALSE 11411
// begin m3 := true ;
11391: LD_ADDR_VAR 0 6
11395: PUSH
11396: LD_INT 1
11398: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11399: LD_STRING People
11401: PPUSH
11402: LD_INT 2
11404: PPUSH
11405: CALL_OW 101
// end else
11409: GO 11469
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11411: LD_EXP 13
11415: PUSH
11416: LD_INT 3
11418: PUSH
11419: LD_INT 2
11421: PUSH
11422: LD_INT 2
11424: PUSH
11425: EMPTY
11426: LIST
11427: LIST
11428: LIST
11429: PUSH
11430: LD_OWVAR 67
11434: ARRAY
11435: LESSEQUAL
11436: IFFALSE 11458
// begin AddMedal ( People , 1 ) ;
11438: LD_STRING People
11440: PPUSH
11441: LD_INT 1
11443: PPUSH
11444: CALL_OW 101
// m3 := true ;
11448: LD_ADDR_VAR 0 6
11452: PUSH
11453: LD_INT 1
11455: ST_TO_ADDR
// end else
11456: GO 11469
// AddMedal ( People , - 1 ) ;
11458: LD_STRING People
11460: PPUSH
11461: LD_INT 1
11463: NEG
11464: PPUSH
11465: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11469: LD_OWVAR 67
11473: PUSH
11474: LD_INT 3
11476: EQUAL
11477: PUSH
11478: LD_VAR 0 4
11482: AND
11483: PUSH
11484: LD_VAR 0 5
11488: AND
11489: PUSH
11490: LD_VAR 0 6
11494: AND
11495: IFFALSE 11507
// SetAchievementEX ( ACH_AMER , 17 ) ;
11497: LD_STRING ACH_AMER
11499: PPUSH
11500: LD_INT 17
11502: PPUSH
11503: CALL_OW 564
// GiveMedals ( MAIN ) ;
11507: LD_STRING MAIN
11509: PPUSH
11510: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11514: LD_ADDR_VAR 0 2
11518: PUSH
11519: LD_INT 22
11521: PUSH
11522: LD_INT 7
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: PUSH
11529: LD_INT 2
11531: PUSH
11532: LD_INT 25
11534: PUSH
11535: LD_INT 1
11537: PUSH
11538: EMPTY
11539: LIST
11540: LIST
11541: PUSH
11542: LD_INT 25
11544: PUSH
11545: LD_INT 2
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: PUSH
11552: LD_INT 25
11554: PUSH
11555: LD_INT 3
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PUSH
11562: LD_INT 25
11564: PUSH
11565: LD_INT 4
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: PUSH
11572: LD_INT 25
11574: PUSH
11575: LD_INT 5
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: PUSH
11582: LD_INT 25
11584: PUSH
11585: LD_INT 8
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: PUSH
11592: LD_INT 25
11594: PUSH
11595: LD_INT 9
11597: PUSH
11598: EMPTY
11599: LIST
11600: LIST
11601: PUSH
11602: EMPTY
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: LIST
11609: LIST
11610: LIST
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PPUSH
11616: CALL_OW 69
11620: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11621: LD_VAR 0 2
11625: PPUSH
11626: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11630: LD_ADDR_VAR 0 3
11634: PUSH
11635: LD_EXP 15
11639: PUSH
11640: LD_EXP 16
11644: PUSH
11645: LD_EXP 17
11649: PUSH
11650: LD_EXP 18
11654: PUSH
11655: LD_EXP 19
11659: PUSH
11660: LD_EXP 20
11664: PUSH
11665: LD_EXP 21
11669: PUSH
11670: LD_EXP 22
11674: PUSH
11675: LD_EXP 23
11679: PUSH
11680: LD_EXP 24
11684: PUSH
11685: LD_EXP 25
11689: PUSH
11690: LD_EXP 26
11694: PUSH
11695: LD_EXP 27
11699: PUSH
11700: LD_EXP 28
11704: PUSH
11705: LD_EXP 29
11709: PUSH
11710: LD_EXP 30
11714: PUSH
11715: LD_EXP 31
11719: PUSH
11720: LD_EXP 32
11724: PUSH
11725: LD_EXP 33
11729: PUSH
11730: LD_EXP 34
11734: PUSH
11735: LD_EXP 36
11739: PUSH
11740: LD_EXP 37
11744: PUSH
11745: LD_EXP 38
11749: PUSH
11750: LD_EXP 39
11754: PUSH
11755: LD_EXP 40
11759: PUSH
11760: LD_EXP 41
11764: PUSH
11765: LD_EXP 42
11769: PUSH
11770: LD_EXP 43
11774: PUSH
11775: LD_EXP 44
11779: PUSH
11780: LD_EXP 45
11784: PUSH
11785: LD_EXP 46
11789: PUSH
11790: LD_EXP 47
11794: PUSH
11795: LD_EXP 48
11799: PUSH
11800: EMPTY
11801: LIST
11802: LIST
11803: LIST
11804: LIST
11805: LIST
11806: LIST
11807: LIST
11808: LIST
11809: LIST
11810: LIST
11811: LIST
11812: LIST
11813: LIST
11814: LIST
11815: LIST
11816: LIST
11817: LIST
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: LIST
11824: LIST
11825: LIST
11826: LIST
11827: LIST
11828: LIST
11829: LIST
11830: LIST
11831: LIST
11832: LIST
11833: LIST
11834: ST_TO_ADDR
// if tmp diff tmp2 then
11835: LD_VAR 0 2
11839: PUSH
11840: LD_VAR 0 3
11844: DIFF
11845: IFFALSE 11865
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11847: LD_VAR 0 2
11851: PUSH
11852: LD_VAR 0 3
11856: DIFF
11857: PPUSH
11858: LD_STRING 13a_others
11860: PPUSH
11861: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11865: LD_EXP 15
11869: PPUSH
11870: LD_STRING 13a_JMM
11872: PPUSH
11873: CALL_OW 38
// if Titov then
11877: LD_EXP 34
11881: IFFALSE 11895
// SaveCharacters ( Titov , 13a_Titov ) ;
11883: LD_EXP 34
11887: PPUSH
11888: LD_STRING 13a_Titov
11890: PPUSH
11891: CALL_OW 38
// if Dolgov then
11895: LD_EXP 36
11899: IFFALSE 11913
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11901: LD_EXP 36
11905: PPUSH
11906: LD_STRING 13a_Dolgov
11908: PPUSH
11909: CALL_OW 38
// if Petrosyan then
11913: LD_EXP 37
11917: IFFALSE 11931
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11919: LD_EXP 37
11923: PPUSH
11924: LD_STRING 13a_Petrosyan
11926: PPUSH
11927: CALL_OW 38
// if Scholtze then
11931: LD_EXP 38
11935: IFFALSE 11949
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11937: LD_EXP 38
11941: PPUSH
11942: LD_STRING 13a_Scholtze
11944: PPUSH
11945: CALL_OW 38
// if Oblukov then
11949: LD_EXP 39
11953: IFFALSE 11967
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11955: LD_EXP 39
11959: PPUSH
11960: LD_STRING 13a_Oblukov
11962: PPUSH
11963: CALL_OW 38
// if Kapitsova then
11967: LD_EXP 40
11971: IFFALSE 11985
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11973: LD_EXP 40
11977: PPUSH
11978: LD_STRING 13a_Kapitsova
11980: PPUSH
11981: CALL_OW 38
// if Lipshchin then
11985: LD_EXP 41
11989: IFFALSE 12003
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11991: LD_EXP 41
11995: PPUSH
11996: LD_STRING 13a_Lipshchin
11998: PPUSH
11999: CALL_OW 38
// if Petrovova then
12003: LD_EXP 42
12007: IFFALSE 12021
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12009: LD_EXP 42
12013: PPUSH
12014: LD_STRING 13a_Petrovova
12016: PPUSH
12017: CALL_OW 38
// if Kovalyuk then
12021: LD_EXP 43
12025: IFFALSE 12039
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12027: LD_EXP 43
12031: PPUSH
12032: LD_STRING 13a_Kovalyuk
12034: PPUSH
12035: CALL_OW 38
// if Kuzmov then
12039: LD_EXP 44
12043: IFFALSE 12057
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12045: LD_EXP 44
12049: PPUSH
12050: LD_STRING 13a_Kuzmov
12052: PPUSH
12053: CALL_OW 38
// if Karamazov then
12057: LD_EXP 45
12061: IFFALSE 12075
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12063: LD_EXP 45
12067: PPUSH
12068: LD_STRING 13a_Karamazov
12070: PPUSH
12071: CALL_OW 38
// if Burlak then
12075: LD_EXP 46
12079: IFFALSE 12093
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12081: LD_EXP 46
12085: PPUSH
12086: LD_STRING 13a_Burlak
12088: PPUSH
12089: CALL_OW 38
// if Belkov then
12093: LD_EXP 47
12097: IFFALSE 12111
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12099: LD_EXP 47
12103: PPUSH
12104: LD_STRING 13a_Belkov
12106: PPUSH
12107: CALL_OW 38
// if Gnyevko then
12111: LD_EXP 48
12115: IFFALSE 12129
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12117: LD_EXP 48
12121: PPUSH
12122: LD_STRING 13a_Gnyevko
12124: PPUSH
12125: CALL_OW 38
// if Lisa then
12129: LD_EXP 17
12133: IFFALSE 12147
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12135: LD_EXP 17
12139: PPUSH
12140: LD_STRING 13a_Lisa
12142: PPUSH
12143: CALL_OW 38
// if Donaldson then
12147: LD_EXP 18
12151: IFFALSE 12165
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12153: LD_EXP 18
12157: PPUSH
12158: LD_STRING 13a_Donaldson
12160: PPUSH
12161: CALL_OW 38
// if Bobby then
12165: LD_EXP 19
12169: IFFALSE 12183
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12171: LD_EXP 19
12175: PPUSH
12176: LD_STRING 13a_Bobby
12178: PPUSH
12179: CALL_OW 38
// if Cyrus then
12183: LD_EXP 20
12187: IFFALSE 12201
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12189: LD_EXP 20
12193: PPUSH
12194: LD_STRING 13a_Cyrus
12196: PPUSH
12197: CALL_OW 38
// if Denis then
12201: LD_EXP 21
12205: IFFALSE 12219
// SaveCharacters ( Denis , 13a_Denis ) ;
12207: LD_EXP 21
12211: PPUSH
12212: LD_STRING 13a_Denis
12214: PPUSH
12215: CALL_OW 38
// if Brown then
12219: LD_EXP 22
12223: IFFALSE 12237
// SaveCharacters ( Brown , 13a_Brown ) ;
12225: LD_EXP 22
12229: PPUSH
12230: LD_STRING 13a_Brown
12232: PPUSH
12233: CALL_OW 38
// if Gladstone then
12237: LD_EXP 23
12241: IFFALSE 12255
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12243: LD_EXP 23
12247: PPUSH
12248: LD_STRING 13a_Gladstone
12250: PPUSH
12251: CALL_OW 38
// if Houten then
12255: LD_EXP 24
12259: IFFALSE 12273
// SaveCharacters ( Houten , 13a_Houten ) ;
12261: LD_EXP 24
12265: PPUSH
12266: LD_STRING 13a_Houten
12268: PPUSH
12269: CALL_OW 38
// if Cornel then
12273: LD_EXP 25
12277: IFFALSE 12291
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12279: LD_EXP 25
12283: PPUSH
12284: LD_STRING 13a_Cornel
12286: PPUSH
12287: CALL_OW 38
// if Gary then
12291: LD_EXP 26
12295: IFFALSE 12309
// SaveCharacters ( Gary , 13a_Gary ) ;
12297: LD_EXP 26
12301: PPUSH
12302: LD_STRING 13a_Gary
12304: PPUSH
12305: CALL_OW 38
// if Frank then
12309: LD_EXP 27
12313: IFFALSE 12327
// SaveCharacters ( Frank , 13a_Frank ) ;
12315: LD_EXP 27
12319: PPUSH
12320: LD_STRING 13a_Frank
12322: PPUSH
12323: CALL_OW 38
// if Kikuchi then
12327: LD_EXP 28
12331: IFFALSE 12345
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12333: LD_EXP 28
12337: PPUSH
12338: LD_STRING 13a_Kikuchi
12340: PPUSH
12341: CALL_OW 38
// if Simms then
12345: LD_EXP 29
12349: IFFALSE 12363
// SaveCharacters ( Simms , 13a_Simms ) ;
12351: LD_EXP 29
12355: PPUSH
12356: LD_STRING 13a_Simms
12358: PPUSH
12359: CALL_OW 38
// if Joan then
12363: LD_EXP 30
12367: IFFALSE 12381
// SaveCharacters ( Joan , 13a_Joan ) ;
12369: LD_EXP 30
12373: PPUSH
12374: LD_STRING 13a_Joan
12376: PPUSH
12377: CALL_OW 38
// if DeltaDoctor then
12381: LD_EXP 31
12385: IFFALSE 12399
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12387: LD_EXP 31
12391: PPUSH
12392: LD_STRING 13a_DeltaDoctor
12394: PPUSH
12395: CALL_OW 38
// if Gossudarov then
12399: LD_EXP 32
12403: IFFALSE 12417
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12405: LD_EXP 32
12409: PPUSH
12410: LD_STRING 13a_Gossudarov
12412: PPUSH
12413: CALL_OW 38
// if Kirilenkova then
12417: LD_EXP 33
12421: IFFALSE 12435
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12423: LD_EXP 33
12427: PPUSH
12428: LD_STRING 13a_Kirilenkova
12430: PPUSH
12431: CALL_OW 38
// if Roth then
12435: LD_EXP 16
12439: IFFALSE 12453
// SaveCharacters ( Roth , 13a_Roth ) ;
12441: LD_EXP 16
12445: PPUSH
12446: LD_STRING 13a_Roth
12448: PPUSH
12449: CALL_OW 38
// if Masha then
12453: LD_EXP 49
12457: IFFALSE 12512
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12459: LD_EXP 49
12463: PPUSH
12464: CALL_OW 265
12468: PUSH
12469: LD_EXP 49
12473: PPUSH
12474: CALL_OW 262
12478: PUSH
12479: LD_EXP 49
12483: PPUSH
12484: CALL_OW 263
12488: PUSH
12489: LD_EXP 49
12493: PPUSH
12494: CALL_OW 264
12498: PUSH
12499: EMPTY
12500: LIST
12501: LIST
12502: LIST
12503: LIST
12504: PPUSH
12505: LD_STRING 13a_Masha
12507: PPUSH
12508: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12512: LD_ADDR_VAR 0 2
12516: PUSH
12517: LD_INT 21
12519: PUSH
12520: LD_INT 3
12522: PUSH
12523: EMPTY
12524: LIST
12525: LIST
12526: PPUSH
12527: CALL_OW 69
12531: ST_TO_ADDR
// tmp2 := [ ] ;
12532: LD_ADDR_VAR 0 3
12536: PUSH
12537: EMPTY
12538: ST_TO_ADDR
// if tmp then
12539: LD_VAR 0 2
12543: IFFALSE 12694
// for i in tmp do
12545: LD_ADDR_VAR 0 1
12549: PUSH
12550: LD_VAR 0 2
12554: PUSH
12555: FOR_IN
12556: IFFALSE 12692
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12558: LD_ADDR_VAR 0 3
12562: PUSH
12563: LD_VAR 0 3
12567: PUSH
12568: LD_VAR 0 1
12572: PPUSH
12573: CALL_OW 255
12577: PUSH
12578: LD_VAR 0 1
12582: PPUSH
12583: CALL_OW 248
12587: PUSH
12588: LD_VAR 0 1
12592: PPUSH
12593: CALL_OW 266
12597: PUSH
12598: LD_VAR 0 1
12602: PPUSH
12603: CALL_OW 250
12607: PUSH
12608: LD_VAR 0 1
12612: PPUSH
12613: CALL_OW 251
12617: PUSH
12618: LD_VAR 0 1
12622: PPUSH
12623: CALL_OW 254
12627: PUSH
12628: LD_VAR 0 1
12632: PPUSH
12633: CALL_OW 267
12637: PUSH
12638: LD_VAR 0 1
12642: PPUSH
12643: LD_INT 1
12645: PPUSH
12646: CALL_OW 268
12650: PUSH
12651: LD_VAR 0 1
12655: PPUSH
12656: LD_INT 2
12658: PPUSH
12659: CALL_OW 268
12663: PUSH
12664: LD_VAR 0 1
12668: PPUSH
12669: CALL_OW 269
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: LIST
12683: LIST
12684: LIST
12685: PUSH
12686: EMPTY
12687: LIST
12688: ADD
12689: ST_TO_ADDR
12690: GO 12555
12692: POP
12693: POP
// if tmp2 then
12694: LD_VAR 0 3
12698: IFFALSE 12712
// SaveVariable ( tmp2 , 13a_buildings ) ;
12700: LD_VAR 0 3
12704: PPUSH
12705: LD_STRING 13a_buildings
12707: PPUSH
12708: CALL_OW 39
// YouWin ;
12712: CALL_OW 103
// end ;
12716: PPOPN 6
12718: END
// export function SciRu ; var tmp , t ; begin
12719: LD_INT 0
12721: PPUSH
12722: PPUSH
12723: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12724: LD_ADDR_VAR 0 3
12728: PUSH
12729: LD_EXP 32
12733: PUSH
12734: LD_EXP 46
12738: PUSH
12739: LD_EXP 34
12743: PUSH
12744: LD_EXP 47
12748: PUSH
12749: LD_EXP 48
12753: PUSH
12754: LD_EXP 37
12758: PUSH
12759: LD_EXP 38
12763: PUSH
12764: LD_EXP 36
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: LIST
12773: LIST
12774: LIST
12775: LIST
12776: LIST
12777: LIST
12778: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12779: LD_ADDR_VAR 0 2
12783: PUSH
12784: LD_INT 22
12786: PUSH
12787: LD_INT 7
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: LD_INT 23
12796: PUSH
12797: LD_INT 3
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 25
12806: PUSH
12807: LD_INT 4
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PUSH
12814: LD_INT 26
12816: PUSH
12817: LD_INT 1
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: PUSH
12824: EMPTY
12825: LIST
12826: LIST
12827: LIST
12828: LIST
12829: PPUSH
12830: CALL_OW 69
12834: PUSH
12835: LD_VAR 0 3
12839: DIFF
12840: ST_TO_ADDR
// if tmp then
12841: LD_VAR 0 2
12845: IFFALSE 12861
// result := tmp [ 1 ] ;
12847: LD_ADDR_VAR 0 1
12851: PUSH
12852: LD_VAR 0 2
12856: PUSH
12857: LD_INT 1
12859: ARRAY
12860: ST_TO_ADDR
// end ;
12861: LD_VAR 0 1
12865: RET
// export function SolRu ; var tmp , t ; begin
12866: LD_INT 0
12868: PPUSH
12869: PPUSH
12870: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12871: LD_ADDR_VAR 0 3
12875: PUSH
12876: LD_EXP 32
12880: PUSH
12881: LD_EXP 46
12885: PUSH
12886: LD_EXP 34
12890: PUSH
12891: LD_EXP 47
12895: PUSH
12896: LD_EXP 48
12900: PUSH
12901: LD_EXP 37
12905: PUSH
12906: LD_EXP 38
12910: PUSH
12911: LD_EXP 36
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: LIST
12924: LIST
12925: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12926: LD_ADDR_VAR 0 2
12930: PUSH
12931: LD_INT 22
12933: PUSH
12934: LD_INT 7
12936: PUSH
12937: EMPTY
12938: LIST
12939: LIST
12940: PUSH
12941: LD_INT 23
12943: PUSH
12944: LD_INT 3
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: PUSH
12951: LD_INT 25
12953: PUSH
12954: LD_INT 1
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: PUSH
12961: LD_INT 26
12963: PUSH
12964: LD_INT 1
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: PUSH
12971: EMPTY
12972: LIST
12973: LIST
12974: LIST
12975: LIST
12976: PPUSH
12977: CALL_OW 69
12981: PUSH
12982: LD_VAR 0 3
12986: DIFF
12987: ST_TO_ADDR
// if tmp then
12988: LD_VAR 0 2
12992: IFFALSE 13008
// result := tmp [ 1 ] ;
12994: LD_ADDR_VAR 0 1
12998: PUSH
12999: LD_VAR 0 2
13003: PUSH
13004: LD_INT 1
13006: ARRAY
13007: ST_TO_ADDR
// end ; end_of_file
13008: LD_VAR 0 1
13012: RET
// export function CustomEvent ( event ) ; begin
13013: LD_INT 0
13015: PPUSH
// end ;
13016: LD_VAR 0 2
13020: RET
// on UnitDestroyed ( un ) do var i , side ;
13021: LD_INT 0
13023: PPUSH
13024: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13025: LD_VAR 0 1
13029: PUSH
13030: LD_INT 22
13032: PUSH
13033: LD_INT 7
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: PUSH
13040: LD_INT 2
13042: PUSH
13043: LD_INT 25
13045: PUSH
13046: LD_INT 1
13048: PUSH
13049: EMPTY
13050: LIST
13051: LIST
13052: PUSH
13053: LD_INT 25
13055: PUSH
13056: LD_INT 2
13058: PUSH
13059: EMPTY
13060: LIST
13061: LIST
13062: PUSH
13063: LD_INT 25
13065: PUSH
13066: LD_INT 3
13068: PUSH
13069: EMPTY
13070: LIST
13071: LIST
13072: PUSH
13073: LD_INT 25
13075: PUSH
13076: LD_INT 4
13078: PUSH
13079: EMPTY
13080: LIST
13081: LIST
13082: PUSH
13083: LD_INT 25
13085: PUSH
13086: LD_INT 5
13088: PUSH
13089: EMPTY
13090: LIST
13091: LIST
13092: PUSH
13093: LD_INT 25
13095: PUSH
13096: LD_INT 8
13098: PUSH
13099: EMPTY
13100: LIST
13101: LIST
13102: PUSH
13103: LD_INT 25
13105: PUSH
13106: LD_INT 9
13108: PUSH
13109: EMPTY
13110: LIST
13111: LIST
13112: PUSH
13113: EMPTY
13114: LIST
13115: LIST
13116: LIST
13117: LIST
13118: LIST
13119: LIST
13120: LIST
13121: LIST
13122: PUSH
13123: EMPTY
13124: LIST
13125: LIST
13126: PPUSH
13127: CALL_OW 69
13131: IN
13132: IFFALSE 13148
// loss_counter := loss_counter + 1 ;
13134: LD_ADDR_EXP 13
13138: PUSH
13139: LD_EXP 13
13143: PUSH
13144: LD_INT 1
13146: PLUS
13147: ST_TO_ADDR
// if un = Abdul then
13148: LD_VAR 0 1
13152: PUSH
13153: LD_EXP 55
13157: EQUAL
13158: IFFALSE 13168
// abdul_escaped := false ;
13160: LD_ADDR_EXP 12
13164: PUSH
13165: LD_INT 0
13167: ST_TO_ADDR
// if un in ru_attackers then
13168: LD_VAR 0 1
13172: PUSH
13173: LD_EXP 52
13177: IN
13178: IFFALSE 13196
// ru_attackers := ru_attackers diff un ;
13180: LD_ADDR_EXP 52
13184: PUSH
13185: LD_EXP 52
13189: PUSH
13190: LD_VAR 0 1
13194: DIFF
13195: ST_TO_ADDR
// if un in ar_attackers then
13196: LD_VAR 0 1
13200: PUSH
13201: LD_EXP 10
13205: IN
13206: IFFALSE 13224
// ar_attackers := ar_attackers diff un ;
13208: LD_ADDR_EXP 10
13212: PUSH
13213: LD_EXP 10
13217: PUSH
13218: LD_VAR 0 1
13222: DIFF
13223: ST_TO_ADDR
// if un = JMM then
13224: LD_VAR 0 1
13228: PUSH
13229: LD_EXP 15
13233: EQUAL
13234: IFFALSE 13245
// begin YouLost ( JMM ) ;
13236: LD_STRING JMM
13238: PPUSH
13239: CALL_OW 104
// exit ;
13243: GO 13334
// end ; if un = Burlak then
13245: LD_VAR 0 1
13249: PUSH
13250: LD_EXP 46
13254: EQUAL
13255: IFFALSE 13266
// begin YouLost ( Burlak ) ;
13257: LD_STRING Burlak
13259: PPUSH
13260: CALL_OW 104
// exit ;
13264: GO 13334
// end ; if un = freedom then
13266: LD_VAR 0 1
13270: PUSH
13271: LD_EXP 3
13275: EQUAL
13276: IFFALSE 13287
// begin YouLost ( Destroyed ) ;
13278: LD_STRING Destroyed
13280: PPUSH
13281: CALL_OW 104
// exit ;
13285: GO 13334
// end ; if un = Masha then
13287: LD_VAR 0 1
13291: PUSH
13292: LD_EXP 49
13296: EQUAL
13297: IFFALSE 13306
// ChangeMissionObjectives ( M4b ) ;
13299: LD_STRING M4b
13301: PPUSH
13302: CALL_OW 337
// if un = Mastodont then
13306: LD_VAR 0 1
13310: PUSH
13311: LD_EXP 56
13315: EQUAL
13316: IFFALSE 13325
// ChangeMissionObjectives ( M4a ) ;
13318: LD_STRING M4a
13320: PPUSH
13321: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13325: LD_VAR 0 1
13329: PPUSH
13330: CALL 84544 0 1
// end ;
13334: PPOPN 3
13336: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13337: LD_VAR 0 1
13341: PPUSH
13342: LD_VAR 0 2
13346: PPUSH
13347: CALL 86878 0 2
// end ;
13351: PPOPN 2
13353: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13354: LD_VAR 0 1
13358: PPUSH
13359: CALL 85946 0 1
// end ;
13363: PPOPN 1
13365: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13366: LD_VAR 0 1
13370: PUSH
13371: LD_INT 22
13373: PUSH
13374: LD_INT 7
13376: PUSH
13377: EMPTY
13378: LIST
13379: LIST
13380: PUSH
13381: LD_INT 30
13383: PUSH
13384: LD_INT 0
13386: PUSH
13387: EMPTY
13388: LIST
13389: LIST
13390: PUSH
13391: EMPTY
13392: LIST
13393: LIST
13394: PPUSH
13395: CALL_OW 69
13399: IN
13400: IFFALSE 13439
// begin SetBName ( building , freedom ) ;
13402: LD_VAR 0 1
13406: PPUSH
13407: LD_STRING freedom
13409: PPUSH
13410: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13414: LD_INT 0
13416: PPUSH
13417: LD_INT 7
13419: PPUSH
13420: LD_INT 0
13422: PPUSH
13423: CALL_OW 324
// freedom := building ;
13427: LD_ADDR_EXP 3
13431: PUSH
13432: LD_VAR 0 1
13436: ST_TO_ADDR
// exit ;
13437: GO 13505
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13439: LD_VAR 0 1
13443: PUSH
13444: LD_INT 22
13446: PUSH
13447: LD_INT 7
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: PUSH
13454: LD_INT 23
13456: PUSH
13457: LD_INT 3
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 30
13466: PUSH
13467: LD_INT 6
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: LIST
13478: PPUSH
13479: CALL_OW 69
13483: IN
13484: IFFALSE 13496
// begin ru_lab_builded := true ;
13486: LD_ADDR_EXP 5
13490: PUSH
13491: LD_INT 1
13493: ST_TO_ADDR
// exit ;
13494: GO 13505
// end ; MCE_BuildingComplete ( building ) ;
13496: LD_VAR 0 1
13500: PPUSH
13501: CALL 86187 0 1
// end ;
13505: PPOPN 1
13507: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13508: LD_VAR 0 1
13512: PPUSH
13513: LD_VAR 0 2
13517: PPUSH
13518: CALL 84240 0 2
// end ;
13522: PPOPN 2
13524: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13525: LD_VAR 0 1
13529: PPUSH
13530: LD_VAR 0 2
13534: PPUSH
13535: LD_VAR 0 3
13539: PPUSH
13540: LD_VAR 0 4
13544: PPUSH
13545: LD_VAR 0 5
13549: PPUSH
13550: CALL 83860 0 5
// end ;
13554: PPOPN 5
13556: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13557: LD_VAR 0 1
13561: PPUSH
13562: LD_VAR 0 2
13566: PPUSH
13567: CALL 83456 0 2
// end ;
13571: PPOPN 2
13573: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
13574: LD_VAR 0 1
13578: PPUSH
13579: CALL_OW 263
13583: PUSH
13584: LD_INT 3
13586: EQUAL
13587: PUSH
13588: LD_VAR 0 2
13592: PPUSH
13593: CALL_OW 263
13597: PUSH
13598: LD_INT 3
13600: EQUAL
13601: OR
13602: IFFALSE 13618
// hack_counter := hack_counter + 1 ;
13604: LD_ADDR_EXP 14
13608: PUSH
13609: LD_EXP 14
13613: PUSH
13614: LD_INT 1
13616: PLUS
13617: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13618: LD_VAR 0 1
13622: PPUSH
13623: LD_VAR 0 2
13627: PPUSH
13628: LD_VAR 0 3
13632: PPUSH
13633: LD_VAR 0 4
13637: PPUSH
13638: CALL 83294 0 4
// end ;
13642: PPOPN 4
13644: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13645: LD_VAR 0 1
13649: PPUSH
13650: LD_VAR 0 2
13654: PPUSH
13655: LD_VAR 0 3
13659: PPUSH
13660: CALL 83069 0 3
// end ;
13664: PPOPN 3
13666: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13667: LD_VAR 0 1
13671: PPUSH
13672: LD_VAR 0 2
13676: PPUSH
13677: CALL 82954 0 2
// end ;
13681: PPOPN 2
13683: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13684: LD_VAR 0 1
13688: PPUSH
13689: LD_VAR 0 2
13693: PPUSH
13694: CALL 87139 0 2
// end ;
13698: PPOPN 2
13700: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13701: LD_VAR 0 1
13705: PPUSH
13706: LD_VAR 0 2
13710: PPUSH
13711: LD_VAR 0 3
13715: PPUSH
13716: LD_VAR 0 4
13720: PPUSH
13721: CALL 87355 0 4
// end ;
13725: PPOPN 4
13727: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13728: LD_VAR 0 1
13732: PPUSH
13733: LD_VAR 0 2
13737: PPUSH
13738: CALL 82763 0 2
// end ;
13742: PPOPN 2
13744: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13745: LD_VAR 0 1
13749: PPUSH
13750: CALL 87638 0 1
// end ; end_of_file
13754: PPOPN 1
13756: END
// every 0 0$30 do var cr , time ;
13757: GO 13759
13759: DISABLE
13760: LD_INT 0
13762: PPUSH
13763: PPUSH
// begin time := 0 0$30 ;
13764: LD_ADDR_VAR 0 2
13768: PUSH
13769: LD_INT 1050
13771: ST_TO_ADDR
// while game do
13772: LD_EXP 2
13776: IFFALSE 13875
// begin wait ( time ) ;
13778: LD_VAR 0 2
13782: PPUSH
13783: CALL_OW 67
// if tick > 2 2$00 then
13787: LD_OWVAR 1
13791: PUSH
13792: LD_INT 4200
13794: GREATER
13795: IFFALSE 13828
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13797: LD_ADDR_VAR 0 2
13801: PUSH
13802: LD_VAR 0 2
13806: PUSH
13807: LD_INT 280
13809: PUSH
13810: LD_INT 420
13812: PUSH
13813: LD_INT 630
13815: PUSH
13816: EMPTY
13817: LIST
13818: LIST
13819: LIST
13820: PUSH
13821: LD_OWVAR 67
13825: ARRAY
13826: PLUS
13827: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13828: LD_INT 1
13830: PPUSH
13831: LD_INT 5
13833: PPUSH
13834: CALL_OW 12
13838: PPUSH
13839: LD_INT 70
13841: PPUSH
13842: LD_INT 49
13844: PPUSH
13845: LD_INT 25
13847: PPUSH
13848: LD_INT 1
13850: PPUSH
13851: CALL_OW 56
// if time > 5 5$00 then
13855: LD_VAR 0 2
13859: PUSH
13860: LD_INT 10500
13862: GREATER
13863: IFFALSE 13873
// time := 0 0$30 ;
13865: LD_ADDR_VAR 0 2
13869: PUSH
13870: LD_INT 1050
13872: ST_TO_ADDR
// end ;
13873: GO 13772
// end ;
13875: PPOPN 2
13877: END
// every 0 0$30 do var cr , time ;
13878: GO 13880
13880: DISABLE
13881: LD_INT 0
13883: PPUSH
13884: PPUSH
// begin time := 0 0$20 ;
13885: LD_ADDR_VAR 0 2
13889: PUSH
13890: LD_INT 700
13892: ST_TO_ADDR
// while game do
13893: LD_EXP 2
13897: IFFALSE 13986
// begin wait ( time ) ;
13899: LD_VAR 0 2
13903: PPUSH
13904: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13908: LD_ADDR_VAR 0 2
13912: PUSH
13913: LD_VAR 0 2
13917: PUSH
13918: LD_INT 490
13920: PUSH
13921: LD_INT 525
13923: PUSH
13924: LD_INT 560
13926: PUSH
13927: EMPTY
13928: LIST
13929: LIST
13930: LIST
13931: PUSH
13932: LD_OWVAR 67
13936: ARRAY
13937: PLUS
13938: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13939: LD_INT 3
13941: PPUSH
13942: LD_INT 5
13944: PPUSH
13945: CALL_OW 12
13949: PPUSH
13950: LD_INT 26
13952: PPUSH
13953: LD_INT 9
13955: PPUSH
13956: LD_INT 30
13958: PPUSH
13959: LD_INT 1
13961: PPUSH
13962: CALL_OW 56
// if time > 3 3$00 then
13966: LD_VAR 0 2
13970: PUSH
13971: LD_INT 6300
13973: GREATER
13974: IFFALSE 13984
// time := 0 0$20 ;
13976: LD_ADDR_VAR 0 2
13980: PUSH
13981: LD_INT 700
13983: ST_TO_ADDR
// end ;
13984: GO 13893
// end ;
13986: PPOPN 2
13988: END
// every 0 0$30 do var cr , time ;
13989: GO 13991
13991: DISABLE
13992: LD_INT 0
13994: PPUSH
13995: PPUSH
// begin time := 0 0$20 ;
13996: LD_ADDR_VAR 0 2
14000: PUSH
14001: LD_INT 700
14003: ST_TO_ADDR
// while game do
14004: LD_EXP 2
14008: IFFALSE 14133
// begin wait ( time ) ;
14010: LD_VAR 0 2
14014: PPUSH
14015: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
14019: LD_ADDR_VAR 0 2
14023: PUSH
14024: LD_VAR 0 2
14028: PUSH
14029: LD_INT 175
14031: PUSH
14032: LD_INT 210
14034: PUSH
14035: LD_INT 280
14037: PUSH
14038: EMPTY
14039: LIST
14040: LIST
14041: LIST
14042: PUSH
14043: LD_OWVAR 67
14047: ARRAY
14048: PLUS
14049: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14050: LD_INT 1
14052: PPUSH
14053: LD_INT 5
14055: PPUSH
14056: CALL_OW 12
14060: PPUSH
14061: LD_INT 179
14063: PPUSH
14064: LD_INT 101
14066: PPUSH
14067: LD_INT 20
14069: PPUSH
14070: LD_INT 1
14072: PPUSH
14073: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14077: LD_INT 350
14079: PPUSH
14080: LD_INT 525
14082: PPUSH
14083: CALL_OW 12
14087: PPUSH
14088: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14092: LD_INT 1
14094: PPUSH
14095: LD_INT 5
14097: PPUSH
14098: CALL_OW 12
14102: PPUSH
14103: LD_INT 9
14105: PPUSH
14106: LD_INT 1
14108: PPUSH
14109: CALL_OW 55
// if time > 4 4$00 then
14113: LD_VAR 0 2
14117: PUSH
14118: LD_INT 8400
14120: GREATER
14121: IFFALSE 14131
// time := 0 0$30 ;
14123: LD_ADDR_VAR 0 2
14127: PUSH
14128: LD_INT 1050
14130: ST_TO_ADDR
// end ;
14131: GO 14004
// end ;
14133: PPOPN 2
14135: END
// every 0 0$30 do var cr , time ;
14136: GO 14138
14138: DISABLE
14139: LD_INT 0
14141: PPUSH
14142: PPUSH
// begin time := 0 0$10 ;
14143: LD_ADDR_VAR 0 2
14147: PUSH
14148: LD_INT 350
14150: ST_TO_ADDR
// while game do
14151: LD_EXP 2
14155: IFFALSE 14289
// begin wait ( time ) ;
14157: LD_VAR 0 2
14161: PPUSH
14162: CALL_OW 67
// time := time + 0 0$10 ;
14166: LD_ADDR_VAR 0 2
14170: PUSH
14171: LD_VAR 0 2
14175: PUSH
14176: LD_INT 350
14178: PLUS
14179: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14180: LD_INT 1
14182: PPUSH
14183: LD_INT 5
14185: PPUSH
14186: CALL_OW 12
14190: PPUSH
14191: LD_INT 11
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14201: LD_ADDR_VAR 0 1
14205: PUSH
14206: LD_INT 1
14208: PPUSH
14209: LD_INT 3
14211: PPUSH
14212: CALL_OW 12
14216: ST_TO_ADDR
// if cr = 1 then
14217: LD_VAR 0 1
14221: PUSH
14222: LD_INT 1
14224: EQUAL
14225: IFFALSE 14269
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14227: LD_INT 700
14229: PPUSH
14230: LD_INT 1575
14232: PPUSH
14233: CALL_OW 12
14237: PPUSH
14238: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14242: LD_INT 1
14244: PPUSH
14245: LD_INT 5
14247: PPUSH
14248: CALL_OW 12
14252: PPUSH
14253: LD_INT 34
14255: PPUSH
14256: LD_INT 50
14258: PPUSH
14259: LD_INT 7
14261: PPUSH
14262: LD_INT 1
14264: PPUSH
14265: CALL_OW 56
// end ; if time > 8 8$00 then
14269: LD_VAR 0 2
14273: PUSH
14274: LD_INT 16800
14276: GREATER
14277: IFFALSE 14287
// time := 0 0$40 ;
14279: LD_ADDR_VAR 0 2
14283: PUSH
14284: LD_INT 1400
14286: ST_TO_ADDR
// end ;
14287: GO 14151
// end ; end_of_file
14289: PPOPN 2
14291: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14292: LD_INT 0
14294: PPUSH
14295: PPUSH
// if exist_mode then
14296: LD_VAR 0 2
14300: IFFALSE 14325
// unit := CreateCharacter ( prefix & ident ) else
14302: LD_ADDR_VAR 0 5
14306: PUSH
14307: LD_VAR 0 3
14311: PUSH
14312: LD_VAR 0 1
14316: STR
14317: PPUSH
14318: CALL_OW 34
14322: ST_TO_ADDR
14323: GO 14340
// unit := NewCharacter ( ident ) ;
14325: LD_ADDR_VAR 0 5
14329: PUSH
14330: LD_VAR 0 1
14334: PPUSH
14335: CALL_OW 25
14339: ST_TO_ADDR
// result := unit ;
14340: LD_ADDR_VAR 0 4
14344: PUSH
14345: LD_VAR 0 5
14349: ST_TO_ADDR
// end ;
14350: LD_VAR 0 4
14354: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14355: LD_INT 0
14357: PPUSH
14358: PPUSH
// if not side or not nation then
14359: LD_VAR 0 1
14363: NOT
14364: PUSH
14365: LD_VAR 0 2
14369: NOT
14370: OR
14371: IFFALSE 14375
// exit ;
14373: GO 15019
// case nation of nation_american :
14375: LD_VAR 0 2
14379: PUSH
14380: LD_INT 1
14382: DOUBLE
14383: EQUAL
14384: IFTRUE 14388
14386: GO 14562
14388: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
14389: LD_ADDR_VAR 0 4
14393: PUSH
14394: LD_INT 35
14396: PUSH
14397: LD_INT 45
14399: PUSH
14400: LD_INT 46
14402: PUSH
14403: LD_INT 47
14405: PUSH
14406: LD_INT 1
14408: PUSH
14409: LD_INT 2
14411: PUSH
14412: LD_INT 6
14414: PUSH
14415: LD_INT 15
14417: PUSH
14418: LD_INT 16
14420: PUSH
14421: LD_INT 7
14423: PUSH
14424: LD_INT 12
14426: PUSH
14427: LD_INT 13
14429: PUSH
14430: LD_INT 10
14432: PUSH
14433: LD_INT 14
14435: PUSH
14436: LD_INT 20
14438: PUSH
14439: LD_INT 21
14441: PUSH
14442: LD_INT 22
14444: PUSH
14445: LD_INT 25
14447: PUSH
14448: LD_INT 32
14450: PUSH
14451: LD_INT 27
14453: PUSH
14454: LD_INT 36
14456: PUSH
14457: LD_INT 69
14459: PUSH
14460: LD_INT 39
14462: PUSH
14463: LD_INT 34
14465: PUSH
14466: LD_INT 40
14468: PUSH
14469: LD_INT 48
14471: PUSH
14472: LD_INT 49
14474: PUSH
14475: LD_INT 50
14477: PUSH
14478: LD_INT 51
14480: PUSH
14481: LD_INT 52
14483: PUSH
14484: LD_INT 53
14486: PUSH
14487: LD_INT 54
14489: PUSH
14490: LD_INT 55
14492: PUSH
14493: LD_INT 56
14495: PUSH
14496: LD_INT 57
14498: PUSH
14499: LD_INT 58
14501: PUSH
14502: LD_INT 59
14504: PUSH
14505: LD_INT 60
14507: PUSH
14508: LD_INT 61
14510: PUSH
14511: LD_INT 62
14513: PUSH
14514: LD_INT 80
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: LIST
14521: LIST
14522: LIST
14523: LIST
14524: LIST
14525: LIST
14526: LIST
14527: LIST
14528: LIST
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: LIST
14534: LIST
14535: LIST
14536: LIST
14537: LIST
14538: LIST
14539: LIST
14540: LIST
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: ST_TO_ADDR
14560: GO 14943
14562: LD_INT 2
14564: DOUBLE
14565: EQUAL
14566: IFTRUE 14570
14568: GO 14752
14570: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
14571: LD_ADDR_VAR 0 4
14575: PUSH
14576: LD_INT 35
14578: PUSH
14579: LD_INT 45
14581: PUSH
14582: LD_INT 46
14584: PUSH
14585: LD_INT 47
14587: PUSH
14588: LD_INT 70
14590: PUSH
14591: LD_INT 1
14593: PUSH
14594: LD_INT 11
14596: PUSH
14597: LD_INT 3
14599: PUSH
14600: LD_INT 4
14602: PUSH
14603: LD_INT 5
14605: PUSH
14606: LD_INT 6
14608: PUSH
14609: LD_INT 15
14611: PUSH
14612: LD_INT 18
14614: PUSH
14615: LD_INT 7
14617: PUSH
14618: LD_INT 17
14620: PUSH
14621: LD_INT 8
14623: PUSH
14624: LD_INT 20
14626: PUSH
14627: LD_INT 21
14629: PUSH
14630: LD_INT 22
14632: PUSH
14633: LD_INT 72
14635: PUSH
14636: LD_INT 26
14638: PUSH
14639: LD_INT 69
14641: PUSH
14642: LD_INT 39
14644: PUSH
14645: LD_INT 40
14647: PUSH
14648: LD_INT 41
14650: PUSH
14651: LD_INT 42
14653: PUSH
14654: LD_INT 43
14656: PUSH
14657: LD_INT 48
14659: PUSH
14660: LD_INT 49
14662: PUSH
14663: LD_INT 50
14665: PUSH
14666: LD_INT 51
14668: PUSH
14669: LD_INT 52
14671: PUSH
14672: LD_INT 53
14674: PUSH
14675: LD_INT 54
14677: PUSH
14678: LD_INT 55
14680: PUSH
14681: LD_INT 56
14683: PUSH
14684: LD_INT 60
14686: PUSH
14687: LD_INT 61
14689: PUSH
14690: LD_INT 62
14692: PUSH
14693: LD_INT 66
14695: PUSH
14696: LD_INT 67
14698: PUSH
14699: LD_INT 68
14701: PUSH
14702: LD_INT 81
14704: PUSH
14705: EMPTY
14706: LIST
14707: LIST
14708: LIST
14709: LIST
14710: LIST
14711: LIST
14712: LIST
14713: LIST
14714: LIST
14715: LIST
14716: LIST
14717: LIST
14718: LIST
14719: LIST
14720: LIST
14721: LIST
14722: LIST
14723: LIST
14724: LIST
14725: LIST
14726: LIST
14727: LIST
14728: LIST
14729: LIST
14730: LIST
14731: LIST
14732: LIST
14733: LIST
14734: LIST
14735: LIST
14736: LIST
14737: LIST
14738: LIST
14739: LIST
14740: LIST
14741: LIST
14742: LIST
14743: LIST
14744: LIST
14745: LIST
14746: LIST
14747: LIST
14748: LIST
14749: ST_TO_ADDR
14750: GO 14943
14752: LD_INT 3
14754: DOUBLE
14755: EQUAL
14756: IFTRUE 14760
14758: GO 14942
14760: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14761: LD_ADDR_VAR 0 4
14765: PUSH
14766: LD_INT 46
14768: PUSH
14769: LD_INT 47
14771: PUSH
14772: LD_INT 1
14774: PUSH
14775: LD_INT 2
14777: PUSH
14778: LD_INT 11
14780: PUSH
14781: LD_INT 9
14783: PUSH
14784: LD_INT 20
14786: PUSH
14787: LD_INT 19
14789: PUSH
14790: LD_INT 21
14792: PUSH
14793: LD_INT 24
14795: PUSH
14796: LD_INT 22
14798: PUSH
14799: LD_INT 25
14801: PUSH
14802: LD_INT 28
14804: PUSH
14805: LD_INT 29
14807: PUSH
14808: LD_INT 30
14810: PUSH
14811: LD_INT 31
14813: PUSH
14814: LD_INT 37
14816: PUSH
14817: LD_INT 38
14819: PUSH
14820: LD_INT 32
14822: PUSH
14823: LD_INT 27
14825: PUSH
14826: LD_INT 33
14828: PUSH
14829: LD_INT 69
14831: PUSH
14832: LD_INT 39
14834: PUSH
14835: LD_INT 34
14837: PUSH
14838: LD_INT 40
14840: PUSH
14841: LD_INT 71
14843: PUSH
14844: LD_INT 23
14846: PUSH
14847: LD_INT 44
14849: PUSH
14850: LD_INT 48
14852: PUSH
14853: LD_INT 49
14855: PUSH
14856: LD_INT 50
14858: PUSH
14859: LD_INT 51
14861: PUSH
14862: LD_INT 52
14864: PUSH
14865: LD_INT 53
14867: PUSH
14868: LD_INT 54
14870: PUSH
14871: LD_INT 55
14873: PUSH
14874: LD_INT 56
14876: PUSH
14877: LD_INT 57
14879: PUSH
14880: LD_INT 58
14882: PUSH
14883: LD_INT 59
14885: PUSH
14886: LD_INT 63
14888: PUSH
14889: LD_INT 64
14891: PUSH
14892: LD_INT 65
14894: PUSH
14895: EMPTY
14896: LIST
14897: LIST
14898: LIST
14899: LIST
14900: LIST
14901: LIST
14902: LIST
14903: LIST
14904: LIST
14905: LIST
14906: LIST
14907: LIST
14908: LIST
14909: LIST
14910: LIST
14911: LIST
14912: LIST
14913: LIST
14914: LIST
14915: LIST
14916: LIST
14917: LIST
14918: LIST
14919: LIST
14920: LIST
14921: LIST
14922: LIST
14923: LIST
14924: LIST
14925: LIST
14926: LIST
14927: LIST
14928: LIST
14929: LIST
14930: LIST
14931: LIST
14932: LIST
14933: LIST
14934: LIST
14935: LIST
14936: LIST
14937: LIST
14938: LIST
14939: ST_TO_ADDR
14940: GO 14943
14942: POP
// if state > - 1 and state < 3 then
14943: LD_VAR 0 3
14947: PUSH
14948: LD_INT 1
14950: NEG
14951: GREATER
14952: PUSH
14953: LD_VAR 0 3
14957: PUSH
14958: LD_INT 3
14960: LESS
14961: AND
14962: IFFALSE 15019
// for i in result do
14964: LD_ADDR_VAR 0 5
14968: PUSH
14969: LD_VAR 0 4
14973: PUSH
14974: FOR_IN
14975: IFFALSE 15017
// if GetTech ( i , side ) <> state then
14977: LD_VAR 0 5
14981: PPUSH
14982: LD_VAR 0 1
14986: PPUSH
14987: CALL_OW 321
14991: PUSH
14992: LD_VAR 0 3
14996: NONEQUAL
14997: IFFALSE 15015
// result := result diff i ;
14999: LD_ADDR_VAR 0 4
15003: PUSH
15004: LD_VAR 0 4
15008: PUSH
15009: LD_VAR 0 5
15013: DIFF
15014: ST_TO_ADDR
15015: GO 14974
15017: POP
15018: POP
// end ;
15019: LD_VAR 0 4
15023: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15024: LD_INT 0
15026: PPUSH
15027: PPUSH
15028: PPUSH
// result := true ;
15029: LD_ADDR_VAR 0 3
15033: PUSH
15034: LD_INT 1
15036: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15037: LD_ADDR_VAR 0 5
15041: PUSH
15042: LD_VAR 0 2
15046: PPUSH
15047: CALL_OW 480
15051: ST_TO_ADDR
// if not tmp then
15052: LD_VAR 0 5
15056: NOT
15057: IFFALSE 15061
// exit ;
15059: GO 15110
// for i in tmp do
15061: LD_ADDR_VAR 0 4
15065: PUSH
15066: LD_VAR 0 5
15070: PUSH
15071: FOR_IN
15072: IFFALSE 15108
// if GetTech ( i , side ) <> state_researched then
15074: LD_VAR 0 4
15078: PPUSH
15079: LD_VAR 0 1
15083: PPUSH
15084: CALL_OW 321
15088: PUSH
15089: LD_INT 2
15091: NONEQUAL
15092: IFFALSE 15106
// begin result := false ;
15094: LD_ADDR_VAR 0 3
15098: PUSH
15099: LD_INT 0
15101: ST_TO_ADDR
// exit ;
15102: POP
15103: POP
15104: GO 15110
// end ;
15106: GO 15071
15108: POP
15109: POP
// end ;
15110: LD_VAR 0 3
15114: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15115: LD_INT 0
15117: PPUSH
15118: PPUSH
15119: PPUSH
15120: PPUSH
15121: PPUSH
15122: PPUSH
15123: PPUSH
15124: PPUSH
15125: PPUSH
15126: PPUSH
15127: PPUSH
15128: PPUSH
15129: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15130: LD_VAR 0 1
15134: NOT
15135: PUSH
15136: LD_VAR 0 1
15140: PPUSH
15141: CALL_OW 257
15145: PUSH
15146: LD_INT 9
15148: NONEQUAL
15149: OR
15150: IFFALSE 15154
// exit ;
15152: GO 15727
// side := GetSide ( unit ) ;
15154: LD_ADDR_VAR 0 9
15158: PUSH
15159: LD_VAR 0 1
15163: PPUSH
15164: CALL_OW 255
15168: ST_TO_ADDR
// tech_space := tech_spacanom ;
15169: LD_ADDR_VAR 0 12
15173: PUSH
15174: LD_INT 29
15176: ST_TO_ADDR
// tech_time := tech_taurad ;
15177: LD_ADDR_VAR 0 13
15181: PUSH
15182: LD_INT 28
15184: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15185: LD_ADDR_VAR 0 11
15189: PUSH
15190: LD_VAR 0 1
15194: PPUSH
15195: CALL_OW 310
15199: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15200: LD_VAR 0 11
15204: PPUSH
15205: CALL_OW 247
15209: PUSH
15210: LD_INT 2
15212: EQUAL
15213: IFFALSE 15217
// exit ;
15215: GO 15727
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15217: LD_ADDR_VAR 0 8
15221: PUSH
15222: LD_INT 81
15224: PUSH
15225: LD_VAR 0 9
15229: PUSH
15230: EMPTY
15231: LIST
15232: LIST
15233: PUSH
15234: LD_INT 3
15236: PUSH
15237: LD_INT 21
15239: PUSH
15240: LD_INT 3
15242: PUSH
15243: EMPTY
15244: LIST
15245: LIST
15246: PUSH
15247: EMPTY
15248: LIST
15249: LIST
15250: PUSH
15251: EMPTY
15252: LIST
15253: LIST
15254: PPUSH
15255: CALL_OW 69
15259: ST_TO_ADDR
// if not tmp then
15260: LD_VAR 0 8
15264: NOT
15265: IFFALSE 15269
// exit ;
15267: GO 15727
// if in_unit then
15269: LD_VAR 0 11
15273: IFFALSE 15297
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15275: LD_ADDR_VAR 0 10
15279: PUSH
15280: LD_VAR 0 8
15284: PPUSH
15285: LD_VAR 0 11
15289: PPUSH
15290: CALL_OW 74
15294: ST_TO_ADDR
15295: GO 15317
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15297: LD_ADDR_VAR 0 10
15301: PUSH
15302: LD_VAR 0 8
15306: PPUSH
15307: LD_VAR 0 1
15311: PPUSH
15312: CALL_OW 74
15316: ST_TO_ADDR
// if not enemy then
15317: LD_VAR 0 10
15321: NOT
15322: IFFALSE 15326
// exit ;
15324: GO 15727
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15326: LD_VAR 0 11
15330: PUSH
15331: LD_VAR 0 11
15335: PPUSH
15336: LD_VAR 0 10
15340: PPUSH
15341: CALL_OW 296
15345: PUSH
15346: LD_INT 13
15348: GREATER
15349: AND
15350: PUSH
15351: LD_VAR 0 1
15355: PPUSH
15356: LD_VAR 0 10
15360: PPUSH
15361: CALL_OW 296
15365: PUSH
15366: LD_INT 12
15368: GREATER
15369: OR
15370: IFFALSE 15374
// exit ;
15372: GO 15727
// missile := [ 1 ] ;
15374: LD_ADDR_VAR 0 14
15378: PUSH
15379: LD_INT 1
15381: PUSH
15382: EMPTY
15383: LIST
15384: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15385: LD_VAR 0 9
15389: PPUSH
15390: LD_VAR 0 12
15394: PPUSH
15395: CALL_OW 325
15399: IFFALSE 15428
// missile := Insert ( missile , missile + 1 , 2 ) ;
15401: LD_ADDR_VAR 0 14
15405: PUSH
15406: LD_VAR 0 14
15410: PPUSH
15411: LD_VAR 0 14
15415: PUSH
15416: LD_INT 1
15418: PLUS
15419: PPUSH
15420: LD_INT 2
15422: PPUSH
15423: CALL_OW 2
15427: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15428: LD_VAR 0 9
15432: PPUSH
15433: LD_VAR 0 13
15437: PPUSH
15438: CALL_OW 325
15442: PUSH
15443: LD_VAR 0 10
15447: PPUSH
15448: CALL_OW 255
15452: PPUSH
15453: LD_VAR 0 13
15457: PPUSH
15458: CALL_OW 325
15462: NOT
15463: AND
15464: IFFALSE 15493
// missile := Insert ( missile , missile + 1 , 3 ) ;
15466: LD_ADDR_VAR 0 14
15470: PUSH
15471: LD_VAR 0 14
15475: PPUSH
15476: LD_VAR 0 14
15480: PUSH
15481: LD_INT 1
15483: PLUS
15484: PPUSH
15485: LD_INT 3
15487: PPUSH
15488: CALL_OW 2
15492: ST_TO_ADDR
// if missile < 2 then
15493: LD_VAR 0 14
15497: PUSH
15498: LD_INT 2
15500: LESS
15501: IFFALSE 15505
// exit ;
15503: GO 15727
// x := GetX ( enemy ) ;
15505: LD_ADDR_VAR 0 4
15509: PUSH
15510: LD_VAR 0 10
15514: PPUSH
15515: CALL_OW 250
15519: ST_TO_ADDR
// y := GetY ( enemy ) ;
15520: LD_ADDR_VAR 0 5
15524: PUSH
15525: LD_VAR 0 10
15529: PPUSH
15530: CALL_OW 251
15534: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15535: LD_ADDR_VAR 0 6
15539: PUSH
15540: LD_VAR 0 4
15544: PUSH
15545: LD_INT 1
15547: NEG
15548: PPUSH
15549: LD_INT 1
15551: PPUSH
15552: CALL_OW 12
15556: PLUS
15557: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15558: LD_ADDR_VAR 0 7
15562: PUSH
15563: LD_VAR 0 5
15567: PUSH
15568: LD_INT 1
15570: NEG
15571: PPUSH
15572: LD_INT 1
15574: PPUSH
15575: CALL_OW 12
15579: PLUS
15580: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15581: LD_VAR 0 6
15585: PPUSH
15586: LD_VAR 0 7
15590: PPUSH
15591: CALL_OW 488
15595: NOT
15596: IFFALSE 15618
// begin _x := x ;
15598: LD_ADDR_VAR 0 6
15602: PUSH
15603: LD_VAR 0 4
15607: ST_TO_ADDR
// _y := y ;
15608: LD_ADDR_VAR 0 7
15612: PUSH
15613: LD_VAR 0 5
15617: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15618: LD_ADDR_VAR 0 3
15622: PUSH
15623: LD_INT 1
15625: PPUSH
15626: LD_VAR 0 14
15630: PPUSH
15631: CALL_OW 12
15635: ST_TO_ADDR
// case i of 1 :
15636: LD_VAR 0 3
15640: PUSH
15641: LD_INT 1
15643: DOUBLE
15644: EQUAL
15645: IFTRUE 15649
15647: GO 15666
15649: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15650: LD_VAR 0 1
15654: PPUSH
15655: LD_VAR 0 10
15659: PPUSH
15660: CALL_OW 115
15664: GO 15727
15666: LD_INT 2
15668: DOUBLE
15669: EQUAL
15670: IFTRUE 15674
15672: GO 15696
15674: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15675: LD_VAR 0 1
15679: PPUSH
15680: LD_VAR 0 6
15684: PPUSH
15685: LD_VAR 0 7
15689: PPUSH
15690: CALL_OW 153
15694: GO 15727
15696: LD_INT 3
15698: DOUBLE
15699: EQUAL
15700: IFTRUE 15704
15702: GO 15726
15704: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15705: LD_VAR 0 1
15709: PPUSH
15710: LD_VAR 0 6
15714: PPUSH
15715: LD_VAR 0 7
15719: PPUSH
15720: CALL_OW 154
15724: GO 15727
15726: POP
// end ;
15727: LD_VAR 0 2
15731: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15732: LD_INT 0
15734: PPUSH
15735: PPUSH
15736: PPUSH
15737: PPUSH
15738: PPUSH
15739: PPUSH
// if not unit or not building then
15740: LD_VAR 0 1
15744: NOT
15745: PUSH
15746: LD_VAR 0 2
15750: NOT
15751: OR
15752: IFFALSE 15756
// exit ;
15754: GO 15914
// x := GetX ( building ) ;
15756: LD_ADDR_VAR 0 5
15760: PUSH
15761: LD_VAR 0 2
15765: PPUSH
15766: CALL_OW 250
15770: ST_TO_ADDR
// y := GetY ( building ) ;
15771: LD_ADDR_VAR 0 6
15775: PUSH
15776: LD_VAR 0 2
15780: PPUSH
15781: CALL_OW 251
15785: ST_TO_ADDR
// for i = 0 to 5 do
15786: LD_ADDR_VAR 0 4
15790: PUSH
15791: DOUBLE
15792: LD_INT 0
15794: DEC
15795: ST_TO_ADDR
15796: LD_INT 5
15798: PUSH
15799: FOR_TO
15800: IFFALSE 15912
// begin _x := ShiftX ( x , i , 3 ) ;
15802: LD_ADDR_VAR 0 7
15806: PUSH
15807: LD_VAR 0 5
15811: PPUSH
15812: LD_VAR 0 4
15816: PPUSH
15817: LD_INT 3
15819: PPUSH
15820: CALL_OW 272
15824: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15825: LD_ADDR_VAR 0 8
15829: PUSH
15830: LD_VAR 0 6
15834: PPUSH
15835: LD_VAR 0 4
15839: PPUSH
15840: LD_INT 3
15842: PPUSH
15843: CALL_OW 273
15847: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15848: LD_VAR 0 7
15852: PPUSH
15853: LD_VAR 0 8
15857: PPUSH
15858: CALL_OW 488
15862: NOT
15863: IFFALSE 15867
// continue ;
15865: GO 15799
// if HexInfo ( _x , _y ) = 0 then
15867: LD_VAR 0 7
15871: PPUSH
15872: LD_VAR 0 8
15876: PPUSH
15877: CALL_OW 428
15881: PUSH
15882: LD_INT 0
15884: EQUAL
15885: IFFALSE 15910
// begin ComMoveXY ( unit , _x , _y ) ;
15887: LD_VAR 0 1
15891: PPUSH
15892: LD_VAR 0 7
15896: PPUSH
15897: LD_VAR 0 8
15901: PPUSH
15902: CALL_OW 111
// exit ;
15906: POP
15907: POP
15908: GO 15914
// end ; end ;
15910: GO 15799
15912: POP
15913: POP
// end ;
15914: LD_VAR 0 3
15918: RET
// export function ScanBase ( side , base_area ) ; begin
15919: LD_INT 0
15921: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15922: LD_ADDR_VAR 0 3
15926: PUSH
15927: LD_VAR 0 2
15931: PPUSH
15932: LD_INT 81
15934: PUSH
15935: LD_VAR 0 1
15939: PUSH
15940: EMPTY
15941: LIST
15942: LIST
15943: PPUSH
15944: CALL_OW 70
15948: ST_TO_ADDR
// end ;
15949: LD_VAR 0 3
15953: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15954: LD_INT 0
15956: PPUSH
15957: PPUSH
15958: PPUSH
15959: PPUSH
15960: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15961: LD_VAR 0 1
15965: NOT
15966: PUSH
15967: LD_EXP 59
15971: PUSH
15972: LD_VAR 0 1
15976: ARRAY
15977: NOT
15978: OR
15979: PUSH
15980: LD_VAR 0 2
15984: NOT
15985: OR
15986: PUSH
15987: LD_VAR 0 3
15991: NOT
15992: OR
15993: IFFALSE 15997
// exit ;
15995: GO 16510
// side := mc_sides [ base ] ;
15997: LD_ADDR_VAR 0 6
16001: PUSH
16002: LD_EXP 85
16006: PUSH
16007: LD_VAR 0 1
16011: ARRAY
16012: ST_TO_ADDR
// if not side then
16013: LD_VAR 0 6
16017: NOT
16018: IFFALSE 16022
// exit ;
16020: GO 16510
// for i in solds do
16022: LD_ADDR_VAR 0 7
16026: PUSH
16027: LD_VAR 0 2
16031: PUSH
16032: FOR_IN
16033: IFFALSE 16094
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
16035: LD_VAR 0 7
16039: PPUSH
16040: CALL_OW 310
16044: PPUSH
16045: CALL_OW 266
16049: PUSH
16050: LD_INT 32
16052: PUSH
16053: LD_INT 31
16055: PUSH
16056: EMPTY
16057: LIST
16058: LIST
16059: IN
16060: IFFALSE 16080
// solds := solds diff i else
16062: LD_ADDR_VAR 0 2
16066: PUSH
16067: LD_VAR 0 2
16071: PUSH
16072: LD_VAR 0 7
16076: DIFF
16077: ST_TO_ADDR
16078: GO 16092
// SetTag ( i , 18 ) ;
16080: LD_VAR 0 7
16084: PPUSH
16085: LD_INT 18
16087: PPUSH
16088: CALL_OW 109
16092: GO 16032
16094: POP
16095: POP
// if not solds then
16096: LD_VAR 0 2
16100: NOT
16101: IFFALSE 16105
// exit ;
16103: GO 16510
// repeat wait ( 0 0$1 ) ;
16105: LD_INT 35
16107: PPUSH
16108: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
16112: LD_ADDR_VAR 0 5
16116: PUSH
16117: LD_VAR 0 6
16121: PPUSH
16122: LD_VAR 0 3
16126: PPUSH
16127: CALL 15919 0 2
16131: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
16132: LD_EXP 59
16136: PUSH
16137: LD_VAR 0 1
16141: ARRAY
16142: NOT
16143: PUSH
16144: LD_EXP 59
16148: PUSH
16149: LD_VAR 0 1
16153: ARRAY
16154: PUSH
16155: EMPTY
16156: EQUAL
16157: OR
16158: IFFALSE 16195
// begin for i in solds do
16160: LD_ADDR_VAR 0 7
16164: PUSH
16165: LD_VAR 0 2
16169: PUSH
16170: FOR_IN
16171: IFFALSE 16184
// ComStop ( i ) ;
16173: LD_VAR 0 7
16177: PPUSH
16178: CALL_OW 141
16182: GO 16170
16184: POP
16185: POP
// solds := [ ] ;
16186: LD_ADDR_VAR 0 2
16190: PUSH
16191: EMPTY
16192: ST_TO_ADDR
// exit ;
16193: GO 16510
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
16195: LD_VAR 0 5
16199: NOT
16200: PUSH
16201: LD_VAR 0 5
16205: PUSH
16206: LD_INT 3
16208: GREATER
16209: OR
16210: PUSH
16211: LD_EXP 81
16215: PUSH
16216: LD_VAR 0 1
16220: ARRAY
16221: OR
16222: IFFALSE 16263
// begin for i in solds do
16224: LD_ADDR_VAR 0 7
16228: PUSH
16229: LD_VAR 0 2
16233: PUSH
16234: FOR_IN
16235: IFFALSE 16259
// if HasTask ( i ) then
16237: LD_VAR 0 7
16241: PPUSH
16242: CALL_OW 314
16246: IFFALSE 16257
// ComStop ( i ) ;
16248: LD_VAR 0 7
16252: PPUSH
16253: CALL_OW 141
16257: GO 16234
16259: POP
16260: POP
// break ;
16261: GO 16498
// end ; for i in solds do
16263: LD_ADDR_VAR 0 7
16267: PUSH
16268: LD_VAR 0 2
16272: PUSH
16273: FOR_IN
16274: IFFALSE 16490
// begin if IsInUnit ( i ) then
16276: LD_VAR 0 7
16280: PPUSH
16281: CALL_OW 310
16285: IFFALSE 16296
// ComExitBuilding ( i ) ;
16287: LD_VAR 0 7
16291: PPUSH
16292: CALL_OW 122
// if GetLives ( i ) > 333 then
16296: LD_VAR 0 7
16300: PPUSH
16301: CALL_OW 256
16305: PUSH
16306: LD_INT 333
16308: GREATER
16309: IFFALSE 16337
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
16311: LD_VAR 0 7
16315: PPUSH
16316: LD_VAR 0 5
16320: PPUSH
16321: LD_VAR 0 7
16325: PPUSH
16326: CALL_OW 74
16330: PPUSH
16331: CALL_OW 115
16335: GO 16488
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
16337: LD_ADDR_VAR 0 8
16341: PUSH
16342: LD_EXP 59
16346: PUSH
16347: LD_VAR 0 1
16351: ARRAY
16352: PPUSH
16353: LD_INT 2
16355: PUSH
16356: LD_INT 30
16358: PUSH
16359: LD_INT 0
16361: PUSH
16362: EMPTY
16363: LIST
16364: LIST
16365: PUSH
16366: LD_INT 30
16368: PUSH
16369: LD_INT 1
16371: PUSH
16372: EMPTY
16373: LIST
16374: LIST
16375: PUSH
16376: LD_INT 30
16378: PUSH
16379: LD_INT 6
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: PUSH
16386: EMPTY
16387: LIST
16388: LIST
16389: LIST
16390: LIST
16391: PPUSH
16392: CALL_OW 72
16396: PPUSH
16397: LD_VAR 0 7
16401: PPUSH
16402: CALL_OW 74
16406: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
16407: LD_VAR 0 7
16411: PPUSH
16412: LD_VAR 0 8
16416: PPUSH
16417: CALL_OW 250
16421: PPUSH
16422: LD_INT 3
16424: PPUSH
16425: LD_INT 5
16427: PPUSH
16428: CALL_OW 272
16432: PPUSH
16433: LD_VAR 0 8
16437: PPUSH
16438: CALL_OW 251
16442: PPUSH
16443: LD_INT 3
16445: PPUSH
16446: LD_INT 5
16448: PPUSH
16449: CALL_OW 273
16453: PPUSH
16454: CALL_OW 111
// SetTag ( i , 0 ) ;
16458: LD_VAR 0 7
16462: PPUSH
16463: LD_INT 0
16465: PPUSH
16466: CALL_OW 109
// solds := solds diff i ;
16470: LD_ADDR_VAR 0 2
16474: PUSH
16475: LD_VAR 0 2
16479: PUSH
16480: LD_VAR 0 7
16484: DIFF
16485: ST_TO_ADDR
// continue ;
16486: GO 16273
// end ; end ;
16488: GO 16273
16490: POP
16491: POP
// until solds ;
16492: LD_VAR 0 2
16496: IFFALSE 16105
// MC_Reset ( base , 18 ) ;
16498: LD_VAR 0 1
16502: PPUSH
16503: LD_INT 18
16505: PPUSH
16506: CALL 61535 0 2
// end ;
16510: LD_VAR 0 4
16514: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16515: LD_INT 0
16517: PPUSH
16518: PPUSH
16519: PPUSH
16520: PPUSH
16521: PPUSH
16522: PPUSH
16523: PPUSH
16524: PPUSH
16525: PPUSH
16526: PPUSH
16527: PPUSH
16528: PPUSH
16529: PPUSH
16530: PPUSH
16531: PPUSH
16532: PPUSH
16533: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16534: LD_ADDR_VAR 0 13
16538: PUSH
16539: LD_EXP 59
16543: PUSH
16544: LD_VAR 0 1
16548: ARRAY
16549: PPUSH
16550: LD_INT 25
16552: PUSH
16553: LD_INT 3
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: PPUSH
16560: CALL_OW 72
16564: ST_TO_ADDR
// if mc_remote_driver [ base ] then
16565: LD_EXP 99
16569: PUSH
16570: LD_VAR 0 1
16574: ARRAY
16575: IFFALSE 16599
// mechs := mechs diff mc_remote_driver [ base ] ;
16577: LD_ADDR_VAR 0 13
16581: PUSH
16582: LD_VAR 0 13
16586: PUSH
16587: LD_EXP 99
16591: PUSH
16592: LD_VAR 0 1
16596: ARRAY
16597: DIFF
16598: ST_TO_ADDR
// for i in mechs do
16599: LD_ADDR_VAR 0 5
16603: PUSH
16604: LD_VAR 0 13
16608: PUSH
16609: FOR_IN
16610: IFFALSE 16645
// if GetTag ( i ) > 0 then
16612: LD_VAR 0 5
16616: PPUSH
16617: CALL_OW 110
16621: PUSH
16622: LD_INT 0
16624: GREATER
16625: IFFALSE 16643
// mechs := mechs diff i ;
16627: LD_ADDR_VAR 0 13
16631: PUSH
16632: LD_VAR 0 13
16636: PUSH
16637: LD_VAR 0 5
16641: DIFF
16642: ST_TO_ADDR
16643: GO 16609
16645: POP
16646: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16647: LD_ADDR_VAR 0 9
16651: PUSH
16652: LD_EXP 59
16656: PUSH
16657: LD_VAR 0 1
16661: ARRAY
16662: PPUSH
16663: LD_INT 2
16665: PUSH
16666: LD_INT 25
16668: PUSH
16669: LD_INT 1
16671: PUSH
16672: EMPTY
16673: LIST
16674: LIST
16675: PUSH
16676: LD_INT 25
16678: PUSH
16679: LD_INT 5
16681: PUSH
16682: EMPTY
16683: LIST
16684: LIST
16685: PUSH
16686: LD_INT 25
16688: PUSH
16689: LD_INT 8
16691: PUSH
16692: EMPTY
16693: LIST
16694: LIST
16695: PUSH
16696: LD_INT 25
16698: PUSH
16699: LD_INT 9
16701: PUSH
16702: EMPTY
16703: LIST
16704: LIST
16705: PUSH
16706: EMPTY
16707: LIST
16708: LIST
16709: LIST
16710: LIST
16711: LIST
16712: PPUSH
16713: CALL_OW 72
16717: ST_TO_ADDR
// if not defenders and not solds then
16718: LD_VAR 0 2
16722: NOT
16723: PUSH
16724: LD_VAR 0 9
16728: NOT
16729: AND
16730: IFFALSE 16734
// exit ;
16732: GO 18360
// depot_under_attack := false ;
16734: LD_ADDR_VAR 0 17
16738: PUSH
16739: LD_INT 0
16741: ST_TO_ADDR
// sold_defenders := [ ] ;
16742: LD_ADDR_VAR 0 18
16746: PUSH
16747: EMPTY
16748: ST_TO_ADDR
// if mechs then
16749: LD_VAR 0 13
16753: IFFALSE 16882
// for i in defenders do
16755: LD_ADDR_VAR 0 5
16759: PUSH
16760: LD_VAR 0 2
16764: PUSH
16765: FOR_IN
16766: IFFALSE 16880
// begin SetTag ( i , 20 ) ;
16768: LD_VAR 0 5
16772: PPUSH
16773: LD_INT 20
16775: PPUSH
16776: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16780: LD_VAR 0 5
16784: PPUSH
16785: CALL_OW 263
16789: PUSH
16790: LD_INT 1
16792: EQUAL
16793: PUSH
16794: LD_VAR 0 5
16798: PPUSH
16799: CALL_OW 311
16803: NOT
16804: AND
16805: PUSH
16806: LD_VAR 0 13
16810: AND
16811: IFFALSE 16878
// begin un := mechs [ 1 ] ;
16813: LD_ADDR_VAR 0 11
16817: PUSH
16818: LD_VAR 0 13
16822: PUSH
16823: LD_INT 1
16825: ARRAY
16826: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16827: LD_VAR 0 11
16831: PPUSH
16832: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16836: LD_VAR 0 11
16840: PPUSH
16841: LD_VAR 0 5
16845: PPUSH
16846: CALL_OW 180
// SetTag ( un , 19 ) ;
16850: LD_VAR 0 11
16854: PPUSH
16855: LD_INT 19
16857: PPUSH
16858: CALL_OW 109
// mechs := mechs diff un ;
16862: LD_ADDR_VAR 0 13
16866: PUSH
16867: LD_VAR 0 13
16871: PUSH
16872: LD_VAR 0 11
16876: DIFF
16877: ST_TO_ADDR
// end ; end ;
16878: GO 16765
16880: POP
16881: POP
// if solds then
16882: LD_VAR 0 9
16886: IFFALSE 16945
// for i in solds do
16888: LD_ADDR_VAR 0 5
16892: PUSH
16893: LD_VAR 0 9
16897: PUSH
16898: FOR_IN
16899: IFFALSE 16943
// if not GetTag ( i ) then
16901: LD_VAR 0 5
16905: PPUSH
16906: CALL_OW 110
16910: NOT
16911: IFFALSE 16941
// begin defenders := defenders union i ;
16913: LD_ADDR_VAR 0 2
16917: PUSH
16918: LD_VAR 0 2
16922: PUSH
16923: LD_VAR 0 5
16927: UNION
16928: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16929: LD_VAR 0 5
16933: PPUSH
16934: LD_INT 18
16936: PPUSH
16937: CALL_OW 109
// end ;
16941: GO 16898
16943: POP
16944: POP
// repeat wait ( 0 0$1 ) ;
16945: LD_INT 35
16947: PPUSH
16948: CALL_OW 67
// enemy := mc_scan [ base ] ;
16952: LD_ADDR_VAR 0 3
16956: PUSH
16957: LD_EXP 82
16961: PUSH
16962: LD_VAR 0 1
16966: ARRAY
16967: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
16968: LD_EXP 59
16972: PUSH
16973: LD_VAR 0 1
16977: ARRAY
16978: NOT
16979: PUSH
16980: LD_EXP 59
16984: PUSH
16985: LD_VAR 0 1
16989: ARRAY
16990: PUSH
16991: EMPTY
16992: EQUAL
16993: OR
16994: IFFALSE 17031
// begin for i in defenders do
16996: LD_ADDR_VAR 0 5
17000: PUSH
17001: LD_VAR 0 2
17005: PUSH
17006: FOR_IN
17007: IFFALSE 17020
// ComStop ( i ) ;
17009: LD_VAR 0 5
17013: PPUSH
17014: CALL_OW 141
17018: GO 17006
17020: POP
17021: POP
// defenders := [ ] ;
17022: LD_ADDR_VAR 0 2
17026: PUSH
17027: EMPTY
17028: ST_TO_ADDR
// exit ;
17029: GO 18360
// end ; for i in defenders do
17031: LD_ADDR_VAR 0 5
17035: PUSH
17036: LD_VAR 0 2
17040: PUSH
17041: FOR_IN
17042: IFFALSE 17860
// begin e := NearestUnitToUnit ( enemy , i ) ;
17044: LD_ADDR_VAR 0 14
17048: PUSH
17049: LD_VAR 0 3
17053: PPUSH
17054: LD_VAR 0 5
17058: PPUSH
17059: CALL_OW 74
17063: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
17064: LD_ADDR_VAR 0 8
17068: PUSH
17069: LD_EXP 59
17073: PUSH
17074: LD_VAR 0 1
17078: ARRAY
17079: PPUSH
17080: LD_INT 2
17082: PUSH
17083: LD_INT 30
17085: PUSH
17086: LD_INT 0
17088: PUSH
17089: EMPTY
17090: LIST
17091: LIST
17092: PUSH
17093: LD_INT 30
17095: PUSH
17096: LD_INT 1
17098: PUSH
17099: EMPTY
17100: LIST
17101: LIST
17102: PUSH
17103: EMPTY
17104: LIST
17105: LIST
17106: LIST
17107: PPUSH
17108: CALL_OW 72
17112: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
17113: LD_ADDR_VAR 0 17
17117: PUSH
17118: LD_VAR 0 8
17122: NOT
17123: PUSH
17124: LD_VAR 0 8
17128: PPUSH
17129: LD_INT 3
17131: PUSH
17132: LD_INT 24
17134: PUSH
17135: LD_INT 600
17137: PUSH
17138: EMPTY
17139: LIST
17140: LIST
17141: PUSH
17142: EMPTY
17143: LIST
17144: LIST
17145: PPUSH
17146: CALL_OW 72
17150: OR
17151: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
17152: LD_VAR 0 5
17156: PPUSH
17157: CALL_OW 247
17161: PUSH
17162: LD_INT 2
17164: DOUBLE
17165: EQUAL
17166: IFTRUE 17170
17168: GO 17566
17170: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
17171: LD_VAR 0 5
17175: PPUSH
17176: CALL_OW 256
17180: PUSH
17181: LD_INT 650
17183: GREATER
17184: PUSH
17185: LD_VAR 0 5
17189: PPUSH
17190: LD_VAR 0 14
17194: PPUSH
17195: CALL_OW 296
17199: PUSH
17200: LD_INT 40
17202: LESS
17203: PUSH
17204: LD_VAR 0 14
17208: PPUSH
17209: LD_EXP 84
17213: PUSH
17214: LD_VAR 0 1
17218: ARRAY
17219: PPUSH
17220: CALL_OW 308
17224: OR
17225: AND
17226: IFFALSE 17348
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
17228: LD_VAR 0 5
17232: PPUSH
17233: CALL_OW 262
17237: PUSH
17238: LD_INT 1
17240: EQUAL
17241: PUSH
17242: LD_VAR 0 5
17246: PPUSH
17247: CALL_OW 261
17251: PUSH
17252: LD_INT 30
17254: LESS
17255: AND
17256: PUSH
17257: LD_VAR 0 8
17261: AND
17262: IFFALSE 17332
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
17264: LD_VAR 0 5
17268: PPUSH
17269: LD_VAR 0 8
17273: PPUSH
17274: LD_VAR 0 5
17278: PPUSH
17279: CALL_OW 74
17283: PPUSH
17284: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
17288: LD_VAR 0 5
17292: PPUSH
17293: LD_VAR 0 8
17297: PPUSH
17298: LD_VAR 0 5
17302: PPUSH
17303: CALL_OW 74
17307: PPUSH
17308: CALL_OW 296
17312: PUSH
17313: LD_INT 6
17315: LESS
17316: IFFALSE 17330
// SetFuel ( i , 100 ) ;
17318: LD_VAR 0 5
17322: PPUSH
17323: LD_INT 100
17325: PPUSH
17326: CALL_OW 240
// end else
17330: GO 17346
// ComAttackUnit ( i , e ) ;
17332: LD_VAR 0 5
17336: PPUSH
17337: LD_VAR 0 14
17341: PPUSH
17342: CALL_OW 115
// end else
17346: GO 17449
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
17348: LD_VAR 0 14
17352: PPUSH
17353: LD_EXP 84
17357: PUSH
17358: LD_VAR 0 1
17362: ARRAY
17363: PPUSH
17364: CALL_OW 308
17368: NOT
17369: PUSH
17370: LD_VAR 0 5
17374: PPUSH
17375: LD_VAR 0 14
17379: PPUSH
17380: CALL_OW 296
17384: PUSH
17385: LD_INT 40
17387: GREATEREQUAL
17388: AND
17389: PUSH
17390: LD_VAR 0 5
17394: PPUSH
17395: CALL_OW 256
17399: PUSH
17400: LD_INT 650
17402: LESSEQUAL
17403: OR
17404: PUSH
17405: LD_VAR 0 5
17409: PPUSH
17410: LD_EXP 83
17414: PUSH
17415: LD_VAR 0 1
17419: ARRAY
17420: PPUSH
17421: CALL_OW 308
17425: NOT
17426: AND
17427: IFFALSE 17449
// ComMoveToArea ( i , mc_parking [ base ] ) ;
17429: LD_VAR 0 5
17433: PPUSH
17434: LD_EXP 83
17438: PUSH
17439: LD_VAR 0 1
17443: ARRAY
17444: PPUSH
17445: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
17449: LD_VAR 0 5
17453: PPUSH
17454: CALL_OW 256
17458: PUSH
17459: LD_INT 998
17461: LESS
17462: PUSH
17463: LD_VAR 0 5
17467: PPUSH
17468: CALL_OW 263
17472: PUSH
17473: LD_INT 1
17475: EQUAL
17476: AND
17477: PUSH
17478: LD_VAR 0 5
17482: PPUSH
17483: CALL_OW 311
17487: AND
17488: PUSH
17489: LD_VAR 0 5
17493: PPUSH
17494: LD_EXP 83
17498: PUSH
17499: LD_VAR 0 1
17503: ARRAY
17504: PPUSH
17505: CALL_OW 308
17509: AND
17510: IFFALSE 17564
// begin mech := IsDrivenBy ( i ) ;
17512: LD_ADDR_VAR 0 10
17516: PUSH
17517: LD_VAR 0 5
17521: PPUSH
17522: CALL_OW 311
17526: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
17527: LD_VAR 0 10
17531: PPUSH
17532: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
17536: LD_VAR 0 10
17540: PPUSH
17541: LD_VAR 0 5
17545: PPUSH
17546: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
17550: LD_VAR 0 10
17554: PPUSH
17555: LD_VAR 0 5
17559: PPUSH
17560: CALL_OW 180
// end ; end ; unit_human :
17564: GO 17831
17566: LD_INT 1
17568: DOUBLE
17569: EQUAL
17570: IFTRUE 17574
17572: GO 17830
17574: POP
// begin b := IsInUnit ( i ) ;
17575: LD_ADDR_VAR 0 19
17579: PUSH
17580: LD_VAR 0 5
17584: PPUSH
17585: CALL_OW 310
17589: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
17590: LD_ADDR_VAR 0 20
17594: PUSH
17595: LD_VAR 0 19
17599: NOT
17600: PUSH
17601: LD_VAR 0 19
17605: PPUSH
17606: CALL_OW 266
17610: PUSH
17611: LD_INT 32
17613: PUSH
17614: LD_INT 31
17616: PUSH
17617: EMPTY
17618: LIST
17619: LIST
17620: IN
17621: OR
17622: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
17623: LD_VAR 0 17
17627: PUSH
17628: LD_VAR 0 2
17632: PPUSH
17633: LD_INT 21
17635: PUSH
17636: LD_INT 2
17638: PUSH
17639: EMPTY
17640: LIST
17641: LIST
17642: PPUSH
17643: CALL_OW 72
17647: PUSH
17648: LD_INT 1
17650: LESSEQUAL
17651: OR
17652: PUSH
17653: LD_VAR 0 20
17657: AND
17658: PUSH
17659: LD_VAR 0 5
17663: PUSH
17664: LD_VAR 0 18
17668: IN
17669: NOT
17670: AND
17671: IFFALSE 17764
// begin if b then
17673: LD_VAR 0 19
17677: IFFALSE 17726
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
17679: LD_VAR 0 19
17683: PPUSH
17684: LD_VAR 0 3
17688: PPUSH
17689: LD_VAR 0 19
17693: PPUSH
17694: CALL_OW 74
17698: PPUSH
17699: CALL_OW 296
17703: PUSH
17704: LD_INT 10
17706: LESS
17707: PUSH
17708: LD_VAR 0 19
17712: PPUSH
17713: CALL_OW 461
17717: PUSH
17718: LD_INT 7
17720: NONEQUAL
17721: AND
17722: IFFALSE 17726
// continue ;
17724: GO 17041
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
17726: LD_ADDR_VAR 0 18
17730: PUSH
17731: LD_VAR 0 18
17735: PPUSH
17736: LD_VAR 0 18
17740: PUSH
17741: LD_INT 1
17743: PLUS
17744: PPUSH
17745: LD_VAR 0 5
17749: PPUSH
17750: CALL_OW 1
17754: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17755: LD_VAR 0 5
17759: PPUSH
17760: CALL_OW 122
// end ; if sold_defenders then
17764: LD_VAR 0 18
17768: IFFALSE 17828
// if i in sold_defenders then
17770: LD_VAR 0 5
17774: PUSH
17775: LD_VAR 0 18
17779: IN
17780: IFFALSE 17828
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17782: LD_VAR 0 5
17786: PPUSH
17787: CALL_OW 314
17791: NOT
17792: PUSH
17793: LD_VAR 0 5
17797: PPUSH
17798: LD_VAR 0 14
17802: PPUSH
17803: CALL_OW 296
17807: PUSH
17808: LD_INT 30
17810: LESS
17811: AND
17812: IFFALSE 17828
// ComAttackUnit ( i , e ) ;
17814: LD_VAR 0 5
17818: PPUSH
17819: LD_VAR 0 14
17823: PPUSH
17824: CALL_OW 115
// end ; end ; end ;
17828: GO 17831
17830: POP
// if IsDead ( i ) then
17831: LD_VAR 0 5
17835: PPUSH
17836: CALL_OW 301
17840: IFFALSE 17858
// defenders := defenders diff i ;
17842: LD_ADDR_VAR 0 2
17846: PUSH
17847: LD_VAR 0 2
17851: PUSH
17852: LD_VAR 0 5
17856: DIFF
17857: ST_TO_ADDR
// end ;
17858: GO 17041
17860: POP
17861: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
17862: LD_VAR 0 3
17866: NOT
17867: PUSH
17868: LD_VAR 0 2
17872: NOT
17873: OR
17874: PUSH
17875: LD_EXP 59
17879: PUSH
17880: LD_VAR 0 1
17884: ARRAY
17885: NOT
17886: OR
17887: IFFALSE 16945
// MC_Reset ( base , 18 ) ;
17889: LD_VAR 0 1
17893: PPUSH
17894: LD_INT 18
17896: PPUSH
17897: CALL 61535 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17901: LD_ADDR_VAR 0 2
17905: PUSH
17906: LD_VAR 0 2
17910: PUSH
17911: LD_VAR 0 2
17915: PPUSH
17916: LD_INT 2
17918: PUSH
17919: LD_INT 25
17921: PUSH
17922: LD_INT 1
17924: PUSH
17925: EMPTY
17926: LIST
17927: LIST
17928: PUSH
17929: LD_INT 25
17931: PUSH
17932: LD_INT 5
17934: PUSH
17935: EMPTY
17936: LIST
17937: LIST
17938: PUSH
17939: LD_INT 25
17941: PUSH
17942: LD_INT 8
17944: PUSH
17945: EMPTY
17946: LIST
17947: LIST
17948: PUSH
17949: LD_INT 25
17951: PUSH
17952: LD_INT 9
17954: PUSH
17955: EMPTY
17956: LIST
17957: LIST
17958: PUSH
17959: EMPTY
17960: LIST
17961: LIST
17962: LIST
17963: LIST
17964: LIST
17965: PPUSH
17966: CALL_OW 72
17970: DIFF
17971: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17972: LD_VAR 0 3
17976: NOT
17977: PUSH
17978: LD_VAR 0 2
17982: PPUSH
17983: LD_INT 21
17985: PUSH
17986: LD_INT 2
17988: PUSH
17989: EMPTY
17990: LIST
17991: LIST
17992: PPUSH
17993: CALL_OW 72
17997: AND
17998: IFFALSE 18336
// begin tmp := FilterByTag ( defenders , 19 ) ;
18000: LD_ADDR_VAR 0 12
18004: PUSH
18005: LD_VAR 0 2
18009: PPUSH
18010: LD_INT 19
18012: PPUSH
18013: CALL 54792 0 2
18017: ST_TO_ADDR
// if tmp then
18018: LD_VAR 0 12
18022: IFFALSE 18092
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
18024: LD_ADDR_VAR 0 12
18028: PUSH
18029: LD_VAR 0 12
18033: PPUSH
18034: LD_INT 25
18036: PUSH
18037: LD_INT 3
18039: PUSH
18040: EMPTY
18041: LIST
18042: LIST
18043: PPUSH
18044: CALL_OW 72
18048: ST_TO_ADDR
// if tmp then
18049: LD_VAR 0 12
18053: IFFALSE 18092
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
18055: LD_ADDR_EXP 71
18059: PUSH
18060: LD_EXP 71
18064: PPUSH
18065: LD_VAR 0 1
18069: PPUSH
18070: LD_EXP 71
18074: PUSH
18075: LD_VAR 0 1
18079: ARRAY
18080: PUSH
18081: LD_VAR 0 12
18085: UNION
18086: PPUSH
18087: CALL_OW 1
18091: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
18092: LD_VAR 0 1
18096: PPUSH
18097: LD_INT 19
18099: PPUSH
18100: CALL 61535 0 2
// repeat wait ( 0 0$1 ) ;
18104: LD_INT 35
18106: PPUSH
18107: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
18111: LD_EXP 59
18115: PUSH
18116: LD_VAR 0 1
18120: ARRAY
18121: NOT
18122: PUSH
18123: LD_EXP 59
18127: PUSH
18128: LD_VAR 0 1
18132: ARRAY
18133: PUSH
18134: EMPTY
18135: EQUAL
18136: OR
18137: IFFALSE 18174
// begin for i in defenders do
18139: LD_ADDR_VAR 0 5
18143: PUSH
18144: LD_VAR 0 2
18148: PUSH
18149: FOR_IN
18150: IFFALSE 18163
// ComStop ( i ) ;
18152: LD_VAR 0 5
18156: PPUSH
18157: CALL_OW 141
18161: GO 18149
18163: POP
18164: POP
// defenders := [ ] ;
18165: LD_ADDR_VAR 0 2
18169: PUSH
18170: EMPTY
18171: ST_TO_ADDR
// exit ;
18172: GO 18360
// end ; for i in defenders do
18174: LD_ADDR_VAR 0 5
18178: PUSH
18179: LD_VAR 0 2
18183: PUSH
18184: FOR_IN
18185: IFFALSE 18274
// begin if not IsInArea ( i , mc_parking [ base ] ) then
18187: LD_VAR 0 5
18191: PPUSH
18192: LD_EXP 83
18196: PUSH
18197: LD_VAR 0 1
18201: ARRAY
18202: PPUSH
18203: CALL_OW 308
18207: NOT
18208: IFFALSE 18232
// ComMoveToArea ( i , mc_parking [ base ] ) else
18210: LD_VAR 0 5
18214: PPUSH
18215: LD_EXP 83
18219: PUSH
18220: LD_VAR 0 1
18224: ARRAY
18225: PPUSH
18226: CALL_OW 113
18230: GO 18272
// if GetControl ( i ) = control_manual then
18232: LD_VAR 0 5
18236: PPUSH
18237: CALL_OW 263
18241: PUSH
18242: LD_INT 1
18244: EQUAL
18245: IFFALSE 18272
// if IsDrivenBy ( i ) then
18247: LD_VAR 0 5
18251: PPUSH
18252: CALL_OW 311
18256: IFFALSE 18272
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
18258: LD_VAR 0 5
18262: PPUSH
18263: CALL_OW 311
18267: PPUSH
18268: CALL_OW 121
// end ;
18272: GO 18184
18274: POP
18275: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
18276: LD_VAR 0 2
18280: PPUSH
18281: LD_INT 95
18283: PUSH
18284: LD_EXP 83
18288: PUSH
18289: LD_VAR 0 1
18293: ARRAY
18294: PUSH
18295: EMPTY
18296: LIST
18297: LIST
18298: PPUSH
18299: CALL_OW 72
18303: PUSH
18304: LD_VAR 0 2
18308: EQUAL
18309: PUSH
18310: LD_EXP 82
18314: PUSH
18315: LD_VAR 0 1
18319: ARRAY
18320: OR
18321: PUSH
18322: LD_EXP 59
18326: PUSH
18327: LD_VAR 0 1
18331: ARRAY
18332: NOT
18333: OR
18334: IFFALSE 18104
// end ; MC_Reset ( base , 19 ) ;
18336: LD_VAR 0 1
18340: PPUSH
18341: LD_INT 19
18343: PPUSH
18344: CALL 61535 0 2
// MC_Reset ( base , 20 ) ;
18348: LD_VAR 0 1
18352: PPUSH
18353: LD_INT 20
18355: PPUSH
18356: CALL 61535 0 2
// end ;
18360: LD_VAR 0 4
18364: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
18365: LD_INT 0
18367: PPUSH
18368: PPUSH
18369: PPUSH
18370: PPUSH
// result := false ;
18371: LD_ADDR_VAR 0 2
18375: PUSH
18376: LD_INT 0
18378: ST_TO_ADDR
// side := GetSide ( unit ) ;
18379: LD_ADDR_VAR 0 3
18383: PUSH
18384: LD_VAR 0 1
18388: PPUSH
18389: CALL_OW 255
18393: ST_TO_ADDR
// nat := GetNation ( unit ) ;
18394: LD_ADDR_VAR 0 4
18398: PUSH
18399: LD_VAR 0 1
18403: PPUSH
18404: CALL_OW 248
18408: ST_TO_ADDR
// case nat of 1 :
18409: LD_VAR 0 4
18413: PUSH
18414: LD_INT 1
18416: DOUBLE
18417: EQUAL
18418: IFTRUE 18422
18420: GO 18433
18422: POP
// tech := tech_lassight ; 2 :
18423: LD_ADDR_VAR 0 5
18427: PUSH
18428: LD_INT 12
18430: ST_TO_ADDR
18431: GO 18472
18433: LD_INT 2
18435: DOUBLE
18436: EQUAL
18437: IFTRUE 18441
18439: GO 18452
18441: POP
// tech := tech_mortar ; 3 :
18442: LD_ADDR_VAR 0 5
18446: PUSH
18447: LD_INT 41
18449: ST_TO_ADDR
18450: GO 18472
18452: LD_INT 3
18454: DOUBLE
18455: EQUAL
18456: IFTRUE 18460
18458: GO 18471
18460: POP
// tech := tech_bazooka ; end ;
18461: LD_ADDR_VAR 0 5
18465: PUSH
18466: LD_INT 44
18468: ST_TO_ADDR
18469: GO 18472
18471: POP
// if Researched ( side , tech ) then
18472: LD_VAR 0 3
18476: PPUSH
18477: LD_VAR 0 5
18481: PPUSH
18482: CALL_OW 325
18486: IFFALSE 18513
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
18488: LD_ADDR_VAR 0 2
18492: PUSH
18493: LD_INT 5
18495: PUSH
18496: LD_INT 8
18498: PUSH
18499: LD_INT 9
18501: PUSH
18502: EMPTY
18503: LIST
18504: LIST
18505: LIST
18506: PUSH
18507: LD_VAR 0 4
18511: ARRAY
18512: ST_TO_ADDR
// end ;
18513: LD_VAR 0 2
18517: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
18518: LD_INT 0
18520: PPUSH
18521: PPUSH
18522: PPUSH
// if not mines then
18523: LD_VAR 0 2
18527: NOT
18528: IFFALSE 18532
// exit ;
18530: GO 18676
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18532: LD_ADDR_VAR 0 5
18536: PUSH
18537: LD_INT 81
18539: PUSH
18540: LD_VAR 0 1
18544: PUSH
18545: EMPTY
18546: LIST
18547: LIST
18548: PUSH
18549: LD_INT 3
18551: PUSH
18552: LD_INT 21
18554: PUSH
18555: LD_INT 3
18557: PUSH
18558: EMPTY
18559: LIST
18560: LIST
18561: PUSH
18562: EMPTY
18563: LIST
18564: LIST
18565: PUSH
18566: EMPTY
18567: LIST
18568: LIST
18569: PPUSH
18570: CALL_OW 69
18574: ST_TO_ADDR
// for i in mines do
18575: LD_ADDR_VAR 0 4
18579: PUSH
18580: LD_VAR 0 2
18584: PUSH
18585: FOR_IN
18586: IFFALSE 18674
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
18588: LD_VAR 0 4
18592: PUSH
18593: LD_INT 1
18595: ARRAY
18596: PPUSH
18597: LD_VAR 0 4
18601: PUSH
18602: LD_INT 2
18604: ARRAY
18605: PPUSH
18606: CALL_OW 458
18610: NOT
18611: IFFALSE 18615
// continue ;
18613: GO 18585
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
18615: LD_VAR 0 4
18619: PUSH
18620: LD_INT 1
18622: ARRAY
18623: PPUSH
18624: LD_VAR 0 4
18628: PUSH
18629: LD_INT 2
18631: ARRAY
18632: PPUSH
18633: CALL_OW 428
18637: PUSH
18638: LD_VAR 0 5
18642: IN
18643: IFFALSE 18672
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
18645: LD_VAR 0 4
18649: PUSH
18650: LD_INT 1
18652: ARRAY
18653: PPUSH
18654: LD_VAR 0 4
18658: PUSH
18659: LD_INT 2
18661: ARRAY
18662: PPUSH
18663: LD_VAR 0 1
18667: PPUSH
18668: CALL_OW 456
// end ;
18672: GO 18585
18674: POP
18675: POP
// end ;
18676: LD_VAR 0 3
18680: RET
// export function Count ( array ) ; var i ; begin
18681: LD_INT 0
18683: PPUSH
18684: PPUSH
// result := 0 ;
18685: LD_ADDR_VAR 0 2
18689: PUSH
18690: LD_INT 0
18692: ST_TO_ADDR
// for i in array do
18693: LD_ADDR_VAR 0 3
18697: PUSH
18698: LD_VAR 0 1
18702: PUSH
18703: FOR_IN
18704: IFFALSE 18728
// if i then
18706: LD_VAR 0 3
18710: IFFALSE 18726
// result := result + 1 ;
18712: LD_ADDR_VAR 0 2
18716: PUSH
18717: LD_VAR 0 2
18721: PUSH
18722: LD_INT 1
18724: PLUS
18725: ST_TO_ADDR
18726: GO 18703
18728: POP
18729: POP
// end ;
18730: LD_VAR 0 2
18734: RET
// export function IsEmpty ( building ) ; begin
18735: LD_INT 0
18737: PPUSH
// if not building then
18738: LD_VAR 0 1
18742: NOT
18743: IFFALSE 18747
// exit ;
18745: GO 18790
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18747: LD_ADDR_VAR 0 2
18751: PUSH
18752: LD_VAR 0 1
18756: PUSH
18757: LD_INT 22
18759: PUSH
18760: LD_VAR 0 1
18764: PPUSH
18765: CALL_OW 255
18769: PUSH
18770: EMPTY
18771: LIST
18772: LIST
18773: PUSH
18774: LD_INT 58
18776: PUSH
18777: EMPTY
18778: LIST
18779: PUSH
18780: EMPTY
18781: LIST
18782: LIST
18783: PPUSH
18784: CALL_OW 69
18788: IN
18789: ST_TO_ADDR
// end ;
18790: LD_VAR 0 2
18794: RET
// export function IsNotFull ( building ) ; begin
18795: LD_INT 0
18797: PPUSH
// if not building then
18798: LD_VAR 0 1
18802: NOT
18803: IFFALSE 18807
// exit ;
18805: GO 18826
// result := UnitsInside ( building ) < 6 ;
18807: LD_ADDR_VAR 0 2
18811: PUSH
18812: LD_VAR 0 1
18816: PPUSH
18817: CALL_OW 313
18821: PUSH
18822: LD_INT 6
18824: LESS
18825: ST_TO_ADDR
// end ;
18826: LD_VAR 0 2
18830: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18831: LD_INT 0
18833: PPUSH
18834: PPUSH
18835: PPUSH
18836: PPUSH
// tmp := [ ] ;
18837: LD_ADDR_VAR 0 3
18841: PUSH
18842: EMPTY
18843: ST_TO_ADDR
// list := [ ] ;
18844: LD_ADDR_VAR 0 5
18848: PUSH
18849: EMPTY
18850: ST_TO_ADDR
// for i = 16 to 25 do
18851: LD_ADDR_VAR 0 4
18855: PUSH
18856: DOUBLE
18857: LD_INT 16
18859: DEC
18860: ST_TO_ADDR
18861: LD_INT 25
18863: PUSH
18864: FOR_TO
18865: IFFALSE 18938
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18867: LD_ADDR_VAR 0 3
18871: PUSH
18872: LD_VAR 0 3
18876: PUSH
18877: LD_INT 22
18879: PUSH
18880: LD_VAR 0 1
18884: PPUSH
18885: CALL_OW 255
18889: PUSH
18890: EMPTY
18891: LIST
18892: LIST
18893: PUSH
18894: LD_INT 91
18896: PUSH
18897: LD_VAR 0 1
18901: PUSH
18902: LD_INT 6
18904: PUSH
18905: EMPTY
18906: LIST
18907: LIST
18908: LIST
18909: PUSH
18910: LD_INT 30
18912: PUSH
18913: LD_VAR 0 4
18917: PUSH
18918: EMPTY
18919: LIST
18920: LIST
18921: PUSH
18922: EMPTY
18923: LIST
18924: LIST
18925: LIST
18926: PUSH
18927: EMPTY
18928: LIST
18929: PPUSH
18930: CALL_OW 69
18934: ADD
18935: ST_TO_ADDR
18936: GO 18864
18938: POP
18939: POP
// for i = 1 to tmp do
18940: LD_ADDR_VAR 0 4
18944: PUSH
18945: DOUBLE
18946: LD_INT 1
18948: DEC
18949: ST_TO_ADDR
18950: LD_VAR 0 3
18954: PUSH
18955: FOR_TO
18956: IFFALSE 19044
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18958: LD_ADDR_VAR 0 5
18962: PUSH
18963: LD_VAR 0 5
18967: PUSH
18968: LD_VAR 0 3
18972: PUSH
18973: LD_VAR 0 4
18977: ARRAY
18978: PPUSH
18979: CALL_OW 266
18983: PUSH
18984: LD_VAR 0 3
18988: PUSH
18989: LD_VAR 0 4
18993: ARRAY
18994: PPUSH
18995: CALL_OW 250
18999: PUSH
19000: LD_VAR 0 3
19004: PUSH
19005: LD_VAR 0 4
19009: ARRAY
19010: PPUSH
19011: CALL_OW 251
19015: PUSH
19016: LD_VAR 0 3
19020: PUSH
19021: LD_VAR 0 4
19025: ARRAY
19026: PPUSH
19027: CALL_OW 254
19031: PUSH
19032: EMPTY
19033: LIST
19034: LIST
19035: LIST
19036: LIST
19037: PUSH
19038: EMPTY
19039: LIST
19040: ADD
19041: ST_TO_ADDR
19042: GO 18955
19044: POP
19045: POP
// result := list ;
19046: LD_ADDR_VAR 0 2
19050: PUSH
19051: LD_VAR 0 5
19055: ST_TO_ADDR
// end ;
19056: LD_VAR 0 2
19060: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
19061: LD_INT 0
19063: PPUSH
19064: PPUSH
19065: PPUSH
19066: PPUSH
19067: PPUSH
19068: PPUSH
19069: PPUSH
// if not factory then
19070: LD_VAR 0 1
19074: NOT
19075: IFFALSE 19079
// exit ;
19077: GO 19672
// if control = control_apeman then
19079: LD_VAR 0 4
19083: PUSH
19084: LD_INT 5
19086: EQUAL
19087: IFFALSE 19196
// begin tmp := UnitsInside ( factory ) ;
19089: LD_ADDR_VAR 0 8
19093: PUSH
19094: LD_VAR 0 1
19098: PPUSH
19099: CALL_OW 313
19103: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
19104: LD_VAR 0 8
19108: PPUSH
19109: LD_INT 25
19111: PUSH
19112: LD_INT 12
19114: PUSH
19115: EMPTY
19116: LIST
19117: LIST
19118: PPUSH
19119: CALL_OW 72
19123: NOT
19124: IFFALSE 19134
// control := control_manual ;
19126: LD_ADDR_VAR 0 4
19130: PUSH
19131: LD_INT 1
19133: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
19134: LD_ADDR_VAR 0 8
19138: PUSH
19139: LD_VAR 0 1
19143: PPUSH
19144: CALL 18831 0 1
19148: ST_TO_ADDR
// if tmp then
19149: LD_VAR 0 8
19153: IFFALSE 19196
// begin for i in tmp do
19155: LD_ADDR_VAR 0 7
19159: PUSH
19160: LD_VAR 0 8
19164: PUSH
19165: FOR_IN
19166: IFFALSE 19194
// if i [ 1 ] = b_ext_radio then
19168: LD_VAR 0 7
19172: PUSH
19173: LD_INT 1
19175: ARRAY
19176: PUSH
19177: LD_INT 22
19179: EQUAL
19180: IFFALSE 19192
// begin control := control_remote ;
19182: LD_ADDR_VAR 0 4
19186: PUSH
19187: LD_INT 2
19189: ST_TO_ADDR
// break ;
19190: GO 19194
// end ;
19192: GO 19165
19194: POP
19195: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19196: LD_VAR 0 1
19200: PPUSH
19201: LD_VAR 0 2
19205: PPUSH
19206: LD_VAR 0 3
19210: PPUSH
19211: LD_VAR 0 4
19215: PPUSH
19216: LD_VAR 0 5
19220: PPUSH
19221: CALL_OW 448
19225: IFFALSE 19260
// begin result := [ chassis , engine , control , weapon ] ;
19227: LD_ADDR_VAR 0 6
19231: PUSH
19232: LD_VAR 0 2
19236: PUSH
19237: LD_VAR 0 3
19241: PUSH
19242: LD_VAR 0 4
19246: PUSH
19247: LD_VAR 0 5
19251: PUSH
19252: EMPTY
19253: LIST
19254: LIST
19255: LIST
19256: LIST
19257: ST_TO_ADDR
// exit ;
19258: GO 19672
// end ; _chassis := AvailableChassisList ( factory ) ;
19260: LD_ADDR_VAR 0 9
19264: PUSH
19265: LD_VAR 0 1
19269: PPUSH
19270: CALL_OW 475
19274: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
19275: LD_ADDR_VAR 0 11
19279: PUSH
19280: LD_VAR 0 1
19284: PPUSH
19285: CALL_OW 476
19289: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
19290: LD_ADDR_VAR 0 12
19294: PUSH
19295: LD_VAR 0 1
19299: PPUSH
19300: CALL_OW 477
19304: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
19305: LD_ADDR_VAR 0 10
19309: PUSH
19310: LD_VAR 0 1
19314: PPUSH
19315: CALL_OW 478
19319: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
19320: LD_VAR 0 9
19324: NOT
19325: PUSH
19326: LD_VAR 0 11
19330: NOT
19331: OR
19332: PUSH
19333: LD_VAR 0 12
19337: NOT
19338: OR
19339: PUSH
19340: LD_VAR 0 10
19344: NOT
19345: OR
19346: IFFALSE 19381
// begin result := [ chassis , engine , control , weapon ] ;
19348: LD_ADDR_VAR 0 6
19352: PUSH
19353: LD_VAR 0 2
19357: PUSH
19358: LD_VAR 0 3
19362: PUSH
19363: LD_VAR 0 4
19367: PUSH
19368: LD_VAR 0 5
19372: PUSH
19373: EMPTY
19374: LIST
19375: LIST
19376: LIST
19377: LIST
19378: ST_TO_ADDR
// exit ;
19379: GO 19672
// end ; if not chassis in _chassis then
19381: LD_VAR 0 2
19385: PUSH
19386: LD_VAR 0 9
19390: IN
19391: NOT
19392: IFFALSE 19418
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
19394: LD_ADDR_VAR 0 2
19398: PUSH
19399: LD_VAR 0 9
19403: PUSH
19404: LD_INT 1
19406: PPUSH
19407: LD_VAR 0 9
19411: PPUSH
19412: CALL_OW 12
19416: ARRAY
19417: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
19418: LD_VAR 0 2
19422: PPUSH
19423: LD_VAR 0 3
19427: PPUSH
19428: CALL 19677 0 2
19432: NOT
19433: IFFALSE 19492
// repeat engine := _engine [ 1 ] ;
19435: LD_ADDR_VAR 0 3
19439: PUSH
19440: LD_VAR 0 11
19444: PUSH
19445: LD_INT 1
19447: ARRAY
19448: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
19449: LD_ADDR_VAR 0 11
19453: PUSH
19454: LD_VAR 0 11
19458: PPUSH
19459: LD_INT 1
19461: PPUSH
19462: CALL_OW 3
19466: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
19467: LD_VAR 0 2
19471: PPUSH
19472: LD_VAR 0 3
19476: PPUSH
19477: CALL 19677 0 2
19481: PUSH
19482: LD_VAR 0 11
19486: PUSH
19487: EMPTY
19488: EQUAL
19489: OR
19490: IFFALSE 19435
// if not control in _control then
19492: LD_VAR 0 4
19496: PUSH
19497: LD_VAR 0 12
19501: IN
19502: NOT
19503: IFFALSE 19529
// control := _control [ rand ( 1 , _control ) ] ;
19505: LD_ADDR_VAR 0 4
19509: PUSH
19510: LD_VAR 0 12
19514: PUSH
19515: LD_INT 1
19517: PPUSH
19518: LD_VAR 0 12
19522: PPUSH
19523: CALL_OW 12
19527: ARRAY
19528: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
19529: LD_VAR 0 2
19533: PPUSH
19534: LD_VAR 0 5
19538: PPUSH
19539: CALL 19897 0 2
19543: NOT
19544: IFFALSE 19603
// repeat weapon := _weapon [ 1 ] ;
19546: LD_ADDR_VAR 0 5
19550: PUSH
19551: LD_VAR 0 10
19555: PUSH
19556: LD_INT 1
19558: ARRAY
19559: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
19560: LD_ADDR_VAR 0 10
19564: PUSH
19565: LD_VAR 0 10
19569: PPUSH
19570: LD_INT 1
19572: PPUSH
19573: CALL_OW 3
19577: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
19578: LD_VAR 0 2
19582: PPUSH
19583: LD_VAR 0 5
19587: PPUSH
19588: CALL 19897 0 2
19592: PUSH
19593: LD_VAR 0 10
19597: PUSH
19598: EMPTY
19599: EQUAL
19600: OR
19601: IFFALSE 19546
// result := [ ] ;
19603: LD_ADDR_VAR 0 6
19607: PUSH
19608: EMPTY
19609: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19610: LD_VAR 0 1
19614: PPUSH
19615: LD_VAR 0 2
19619: PPUSH
19620: LD_VAR 0 3
19624: PPUSH
19625: LD_VAR 0 4
19629: PPUSH
19630: LD_VAR 0 5
19634: PPUSH
19635: CALL_OW 448
19639: IFFALSE 19672
// result := [ chassis , engine , control , weapon ] ;
19641: LD_ADDR_VAR 0 6
19645: PUSH
19646: LD_VAR 0 2
19650: PUSH
19651: LD_VAR 0 3
19655: PUSH
19656: LD_VAR 0 4
19660: PUSH
19661: LD_VAR 0 5
19665: PUSH
19666: EMPTY
19667: LIST
19668: LIST
19669: LIST
19670: LIST
19671: ST_TO_ADDR
// end ;
19672: LD_VAR 0 6
19676: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
19677: LD_INT 0
19679: PPUSH
// if not chassis or not engine then
19680: LD_VAR 0 1
19684: NOT
19685: PUSH
19686: LD_VAR 0 2
19690: NOT
19691: OR
19692: IFFALSE 19696
// exit ;
19694: GO 19892
// case engine of engine_solar :
19696: LD_VAR 0 2
19700: PUSH
19701: LD_INT 2
19703: DOUBLE
19704: EQUAL
19705: IFTRUE 19709
19707: GO 19747
19709: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19710: LD_ADDR_VAR 0 3
19714: PUSH
19715: LD_INT 11
19717: PUSH
19718: LD_INT 12
19720: PUSH
19721: LD_INT 13
19723: PUSH
19724: LD_INT 14
19726: PUSH
19727: LD_INT 1
19729: PUSH
19730: LD_INT 2
19732: PUSH
19733: LD_INT 3
19735: PUSH
19736: EMPTY
19737: LIST
19738: LIST
19739: LIST
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: ST_TO_ADDR
19745: GO 19876
19747: LD_INT 1
19749: DOUBLE
19750: EQUAL
19751: IFTRUE 19755
19753: GO 19817
19755: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19756: LD_ADDR_VAR 0 3
19760: PUSH
19761: LD_INT 11
19763: PUSH
19764: LD_INT 12
19766: PUSH
19767: LD_INT 13
19769: PUSH
19770: LD_INT 14
19772: PUSH
19773: LD_INT 1
19775: PUSH
19776: LD_INT 2
19778: PUSH
19779: LD_INT 3
19781: PUSH
19782: LD_INT 4
19784: PUSH
19785: LD_INT 5
19787: PUSH
19788: LD_INT 21
19790: PUSH
19791: LD_INT 23
19793: PUSH
19794: LD_INT 22
19796: PUSH
19797: LD_INT 24
19799: PUSH
19800: EMPTY
19801: LIST
19802: LIST
19803: LIST
19804: LIST
19805: LIST
19806: LIST
19807: LIST
19808: LIST
19809: LIST
19810: LIST
19811: LIST
19812: LIST
19813: LIST
19814: ST_TO_ADDR
19815: GO 19876
19817: LD_INT 3
19819: DOUBLE
19820: EQUAL
19821: IFTRUE 19825
19823: GO 19875
19825: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19826: LD_ADDR_VAR 0 3
19830: PUSH
19831: LD_INT 13
19833: PUSH
19834: LD_INT 14
19836: PUSH
19837: LD_INT 2
19839: PUSH
19840: LD_INT 3
19842: PUSH
19843: LD_INT 4
19845: PUSH
19846: LD_INT 5
19848: PUSH
19849: LD_INT 21
19851: PUSH
19852: LD_INT 22
19854: PUSH
19855: LD_INT 23
19857: PUSH
19858: LD_INT 24
19860: PUSH
19861: EMPTY
19862: LIST
19863: LIST
19864: LIST
19865: LIST
19866: LIST
19867: LIST
19868: LIST
19869: LIST
19870: LIST
19871: LIST
19872: ST_TO_ADDR
19873: GO 19876
19875: POP
// result := ( chassis in result ) ;
19876: LD_ADDR_VAR 0 3
19880: PUSH
19881: LD_VAR 0 1
19885: PUSH
19886: LD_VAR 0 3
19890: IN
19891: ST_TO_ADDR
// end ;
19892: LD_VAR 0 3
19896: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19897: LD_INT 0
19899: PPUSH
// if not chassis or not weapon then
19900: LD_VAR 0 1
19904: NOT
19905: PUSH
19906: LD_VAR 0 2
19910: NOT
19911: OR
19912: IFFALSE 19916
// exit ;
19914: GO 20942
// case weapon of us_machine_gun :
19916: LD_VAR 0 2
19920: PUSH
19921: LD_INT 2
19923: DOUBLE
19924: EQUAL
19925: IFTRUE 19929
19927: GO 19959
19929: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19930: LD_ADDR_VAR 0 3
19934: PUSH
19935: LD_INT 1
19937: PUSH
19938: LD_INT 2
19940: PUSH
19941: LD_INT 3
19943: PUSH
19944: LD_INT 4
19946: PUSH
19947: LD_INT 5
19949: PUSH
19950: EMPTY
19951: LIST
19952: LIST
19953: LIST
19954: LIST
19955: LIST
19956: ST_TO_ADDR
19957: GO 20926
19959: LD_INT 3
19961: DOUBLE
19962: EQUAL
19963: IFTRUE 19967
19965: GO 19997
19967: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19968: LD_ADDR_VAR 0 3
19972: PUSH
19973: LD_INT 1
19975: PUSH
19976: LD_INT 2
19978: PUSH
19979: LD_INT 3
19981: PUSH
19982: LD_INT 4
19984: PUSH
19985: LD_INT 5
19987: PUSH
19988: EMPTY
19989: LIST
19990: LIST
19991: LIST
19992: LIST
19993: LIST
19994: ST_TO_ADDR
19995: GO 20926
19997: LD_INT 11
19999: DOUBLE
20000: EQUAL
20001: IFTRUE 20005
20003: GO 20035
20005: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
20006: LD_ADDR_VAR 0 3
20010: PUSH
20011: LD_INT 1
20013: PUSH
20014: LD_INT 2
20016: PUSH
20017: LD_INT 3
20019: PUSH
20020: LD_INT 4
20022: PUSH
20023: LD_INT 5
20025: PUSH
20026: EMPTY
20027: LIST
20028: LIST
20029: LIST
20030: LIST
20031: LIST
20032: ST_TO_ADDR
20033: GO 20926
20035: LD_INT 4
20037: DOUBLE
20038: EQUAL
20039: IFTRUE 20043
20041: GO 20069
20043: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
20044: LD_ADDR_VAR 0 3
20048: PUSH
20049: LD_INT 2
20051: PUSH
20052: LD_INT 3
20054: PUSH
20055: LD_INT 4
20057: PUSH
20058: LD_INT 5
20060: PUSH
20061: EMPTY
20062: LIST
20063: LIST
20064: LIST
20065: LIST
20066: ST_TO_ADDR
20067: GO 20926
20069: LD_INT 5
20071: DOUBLE
20072: EQUAL
20073: IFTRUE 20077
20075: GO 20103
20077: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
20078: LD_ADDR_VAR 0 3
20082: PUSH
20083: LD_INT 2
20085: PUSH
20086: LD_INT 3
20088: PUSH
20089: LD_INT 4
20091: PUSH
20092: LD_INT 5
20094: PUSH
20095: EMPTY
20096: LIST
20097: LIST
20098: LIST
20099: LIST
20100: ST_TO_ADDR
20101: GO 20926
20103: LD_INT 9
20105: DOUBLE
20106: EQUAL
20107: IFTRUE 20111
20109: GO 20137
20111: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
20112: LD_ADDR_VAR 0 3
20116: PUSH
20117: LD_INT 2
20119: PUSH
20120: LD_INT 3
20122: PUSH
20123: LD_INT 4
20125: PUSH
20126: LD_INT 5
20128: PUSH
20129: EMPTY
20130: LIST
20131: LIST
20132: LIST
20133: LIST
20134: ST_TO_ADDR
20135: GO 20926
20137: LD_INT 7
20139: DOUBLE
20140: EQUAL
20141: IFTRUE 20145
20143: GO 20171
20145: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
20146: LD_ADDR_VAR 0 3
20150: PUSH
20151: LD_INT 2
20153: PUSH
20154: LD_INT 3
20156: PUSH
20157: LD_INT 4
20159: PUSH
20160: LD_INT 5
20162: PUSH
20163: EMPTY
20164: LIST
20165: LIST
20166: LIST
20167: LIST
20168: ST_TO_ADDR
20169: GO 20926
20171: LD_INT 12
20173: DOUBLE
20174: EQUAL
20175: IFTRUE 20179
20177: GO 20205
20179: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
20180: LD_ADDR_VAR 0 3
20184: PUSH
20185: LD_INT 2
20187: PUSH
20188: LD_INT 3
20190: PUSH
20191: LD_INT 4
20193: PUSH
20194: LD_INT 5
20196: PUSH
20197: EMPTY
20198: LIST
20199: LIST
20200: LIST
20201: LIST
20202: ST_TO_ADDR
20203: GO 20926
20205: LD_INT 13
20207: DOUBLE
20208: EQUAL
20209: IFTRUE 20213
20211: GO 20239
20213: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
20214: LD_ADDR_VAR 0 3
20218: PUSH
20219: LD_INT 2
20221: PUSH
20222: LD_INT 3
20224: PUSH
20225: LD_INT 4
20227: PUSH
20228: LD_INT 5
20230: PUSH
20231: EMPTY
20232: LIST
20233: LIST
20234: LIST
20235: LIST
20236: ST_TO_ADDR
20237: GO 20926
20239: LD_INT 14
20241: DOUBLE
20242: EQUAL
20243: IFTRUE 20247
20245: GO 20265
20247: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
20248: LD_ADDR_VAR 0 3
20252: PUSH
20253: LD_INT 4
20255: PUSH
20256: LD_INT 5
20258: PUSH
20259: EMPTY
20260: LIST
20261: LIST
20262: ST_TO_ADDR
20263: GO 20926
20265: LD_INT 6
20267: DOUBLE
20268: EQUAL
20269: IFTRUE 20273
20271: GO 20291
20273: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
20274: LD_ADDR_VAR 0 3
20278: PUSH
20279: LD_INT 4
20281: PUSH
20282: LD_INT 5
20284: PUSH
20285: EMPTY
20286: LIST
20287: LIST
20288: ST_TO_ADDR
20289: GO 20926
20291: LD_INT 10
20293: DOUBLE
20294: EQUAL
20295: IFTRUE 20299
20297: GO 20317
20299: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
20300: LD_ADDR_VAR 0 3
20304: PUSH
20305: LD_INT 4
20307: PUSH
20308: LD_INT 5
20310: PUSH
20311: EMPTY
20312: LIST
20313: LIST
20314: ST_TO_ADDR
20315: GO 20926
20317: LD_INT 22
20319: DOUBLE
20320: EQUAL
20321: IFTRUE 20325
20323: GO 20351
20325: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
20326: LD_ADDR_VAR 0 3
20330: PUSH
20331: LD_INT 11
20333: PUSH
20334: LD_INT 12
20336: PUSH
20337: LD_INT 13
20339: PUSH
20340: LD_INT 14
20342: PUSH
20343: EMPTY
20344: LIST
20345: LIST
20346: LIST
20347: LIST
20348: ST_TO_ADDR
20349: GO 20926
20351: LD_INT 23
20353: DOUBLE
20354: EQUAL
20355: IFTRUE 20359
20357: GO 20385
20359: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
20360: LD_ADDR_VAR 0 3
20364: PUSH
20365: LD_INT 11
20367: PUSH
20368: LD_INT 12
20370: PUSH
20371: LD_INT 13
20373: PUSH
20374: LD_INT 14
20376: PUSH
20377: EMPTY
20378: LIST
20379: LIST
20380: LIST
20381: LIST
20382: ST_TO_ADDR
20383: GO 20926
20385: LD_INT 24
20387: DOUBLE
20388: EQUAL
20389: IFTRUE 20393
20391: GO 20419
20393: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
20394: LD_ADDR_VAR 0 3
20398: PUSH
20399: LD_INT 11
20401: PUSH
20402: LD_INT 12
20404: PUSH
20405: LD_INT 13
20407: PUSH
20408: LD_INT 14
20410: PUSH
20411: EMPTY
20412: LIST
20413: LIST
20414: LIST
20415: LIST
20416: ST_TO_ADDR
20417: GO 20926
20419: LD_INT 30
20421: DOUBLE
20422: EQUAL
20423: IFTRUE 20427
20425: GO 20453
20427: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
20428: LD_ADDR_VAR 0 3
20432: PUSH
20433: LD_INT 11
20435: PUSH
20436: LD_INT 12
20438: PUSH
20439: LD_INT 13
20441: PUSH
20442: LD_INT 14
20444: PUSH
20445: EMPTY
20446: LIST
20447: LIST
20448: LIST
20449: LIST
20450: ST_TO_ADDR
20451: GO 20926
20453: LD_INT 25
20455: DOUBLE
20456: EQUAL
20457: IFTRUE 20461
20459: GO 20479
20461: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
20462: LD_ADDR_VAR 0 3
20466: PUSH
20467: LD_INT 13
20469: PUSH
20470: LD_INT 14
20472: PUSH
20473: EMPTY
20474: LIST
20475: LIST
20476: ST_TO_ADDR
20477: GO 20926
20479: LD_INT 27
20481: DOUBLE
20482: EQUAL
20483: IFTRUE 20487
20485: GO 20505
20487: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
20488: LD_ADDR_VAR 0 3
20492: PUSH
20493: LD_INT 13
20495: PUSH
20496: LD_INT 14
20498: PUSH
20499: EMPTY
20500: LIST
20501: LIST
20502: ST_TO_ADDR
20503: GO 20926
20505: LD_INT 28
20507: DOUBLE
20508: EQUAL
20509: IFTRUE 20513
20511: GO 20531
20513: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
20514: LD_ADDR_VAR 0 3
20518: PUSH
20519: LD_INT 13
20521: PUSH
20522: LD_INT 14
20524: PUSH
20525: EMPTY
20526: LIST
20527: LIST
20528: ST_TO_ADDR
20529: GO 20926
20531: LD_INT 29
20533: DOUBLE
20534: EQUAL
20535: IFTRUE 20539
20537: GO 20557
20539: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
20540: LD_ADDR_VAR 0 3
20544: PUSH
20545: LD_INT 13
20547: PUSH
20548: LD_INT 14
20550: PUSH
20551: EMPTY
20552: LIST
20553: LIST
20554: ST_TO_ADDR
20555: GO 20926
20557: LD_INT 31
20559: DOUBLE
20560: EQUAL
20561: IFTRUE 20565
20563: GO 20583
20565: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
20566: LD_ADDR_VAR 0 3
20570: PUSH
20571: LD_INT 13
20573: PUSH
20574: LD_INT 14
20576: PUSH
20577: EMPTY
20578: LIST
20579: LIST
20580: ST_TO_ADDR
20581: GO 20926
20583: LD_INT 26
20585: DOUBLE
20586: EQUAL
20587: IFTRUE 20591
20589: GO 20609
20591: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
20592: LD_ADDR_VAR 0 3
20596: PUSH
20597: LD_INT 13
20599: PUSH
20600: LD_INT 14
20602: PUSH
20603: EMPTY
20604: LIST
20605: LIST
20606: ST_TO_ADDR
20607: GO 20926
20609: LD_INT 42
20611: DOUBLE
20612: EQUAL
20613: IFTRUE 20617
20615: GO 20643
20617: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
20618: LD_ADDR_VAR 0 3
20622: PUSH
20623: LD_INT 21
20625: PUSH
20626: LD_INT 22
20628: PUSH
20629: LD_INT 23
20631: PUSH
20632: LD_INT 24
20634: PUSH
20635: EMPTY
20636: LIST
20637: LIST
20638: LIST
20639: LIST
20640: ST_TO_ADDR
20641: GO 20926
20643: LD_INT 43
20645: DOUBLE
20646: EQUAL
20647: IFTRUE 20651
20649: GO 20677
20651: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
20652: LD_ADDR_VAR 0 3
20656: PUSH
20657: LD_INT 21
20659: PUSH
20660: LD_INT 22
20662: PUSH
20663: LD_INT 23
20665: PUSH
20666: LD_INT 24
20668: PUSH
20669: EMPTY
20670: LIST
20671: LIST
20672: LIST
20673: LIST
20674: ST_TO_ADDR
20675: GO 20926
20677: LD_INT 44
20679: DOUBLE
20680: EQUAL
20681: IFTRUE 20685
20683: GO 20711
20685: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
20686: LD_ADDR_VAR 0 3
20690: PUSH
20691: LD_INT 21
20693: PUSH
20694: LD_INT 22
20696: PUSH
20697: LD_INT 23
20699: PUSH
20700: LD_INT 24
20702: PUSH
20703: EMPTY
20704: LIST
20705: LIST
20706: LIST
20707: LIST
20708: ST_TO_ADDR
20709: GO 20926
20711: LD_INT 45
20713: DOUBLE
20714: EQUAL
20715: IFTRUE 20719
20717: GO 20745
20719: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20720: LD_ADDR_VAR 0 3
20724: PUSH
20725: LD_INT 21
20727: PUSH
20728: LD_INT 22
20730: PUSH
20731: LD_INT 23
20733: PUSH
20734: LD_INT 24
20736: PUSH
20737: EMPTY
20738: LIST
20739: LIST
20740: LIST
20741: LIST
20742: ST_TO_ADDR
20743: GO 20926
20745: LD_INT 49
20747: DOUBLE
20748: EQUAL
20749: IFTRUE 20753
20751: GO 20779
20753: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20754: LD_ADDR_VAR 0 3
20758: PUSH
20759: LD_INT 21
20761: PUSH
20762: LD_INT 22
20764: PUSH
20765: LD_INT 23
20767: PUSH
20768: LD_INT 24
20770: PUSH
20771: EMPTY
20772: LIST
20773: LIST
20774: LIST
20775: LIST
20776: ST_TO_ADDR
20777: GO 20926
20779: LD_INT 51
20781: DOUBLE
20782: EQUAL
20783: IFTRUE 20787
20785: GO 20813
20787: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20788: LD_ADDR_VAR 0 3
20792: PUSH
20793: LD_INT 21
20795: PUSH
20796: LD_INT 22
20798: PUSH
20799: LD_INT 23
20801: PUSH
20802: LD_INT 24
20804: PUSH
20805: EMPTY
20806: LIST
20807: LIST
20808: LIST
20809: LIST
20810: ST_TO_ADDR
20811: GO 20926
20813: LD_INT 52
20815: DOUBLE
20816: EQUAL
20817: IFTRUE 20821
20819: GO 20847
20821: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20822: LD_ADDR_VAR 0 3
20826: PUSH
20827: LD_INT 21
20829: PUSH
20830: LD_INT 22
20832: PUSH
20833: LD_INT 23
20835: PUSH
20836: LD_INT 24
20838: PUSH
20839: EMPTY
20840: LIST
20841: LIST
20842: LIST
20843: LIST
20844: ST_TO_ADDR
20845: GO 20926
20847: LD_INT 53
20849: DOUBLE
20850: EQUAL
20851: IFTRUE 20855
20853: GO 20873
20855: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20856: LD_ADDR_VAR 0 3
20860: PUSH
20861: LD_INT 23
20863: PUSH
20864: LD_INT 24
20866: PUSH
20867: EMPTY
20868: LIST
20869: LIST
20870: ST_TO_ADDR
20871: GO 20926
20873: LD_INT 46
20875: DOUBLE
20876: EQUAL
20877: IFTRUE 20881
20879: GO 20899
20881: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20882: LD_ADDR_VAR 0 3
20886: PUSH
20887: LD_INT 23
20889: PUSH
20890: LD_INT 24
20892: PUSH
20893: EMPTY
20894: LIST
20895: LIST
20896: ST_TO_ADDR
20897: GO 20926
20899: LD_INT 47
20901: DOUBLE
20902: EQUAL
20903: IFTRUE 20907
20905: GO 20925
20907: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20908: LD_ADDR_VAR 0 3
20912: PUSH
20913: LD_INT 23
20915: PUSH
20916: LD_INT 24
20918: PUSH
20919: EMPTY
20920: LIST
20921: LIST
20922: ST_TO_ADDR
20923: GO 20926
20925: POP
// result := ( chassis in result ) ;
20926: LD_ADDR_VAR 0 3
20930: PUSH
20931: LD_VAR 0 1
20935: PUSH
20936: LD_VAR 0 3
20940: IN
20941: ST_TO_ADDR
// end ;
20942: LD_VAR 0 3
20946: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20947: LD_INT 0
20949: PPUSH
20950: PPUSH
20951: PPUSH
20952: PPUSH
20953: PPUSH
20954: PPUSH
20955: PPUSH
// result := array ;
20956: LD_ADDR_VAR 0 5
20960: PUSH
20961: LD_VAR 0 1
20965: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20966: LD_VAR 0 1
20970: NOT
20971: PUSH
20972: LD_VAR 0 2
20976: NOT
20977: OR
20978: PUSH
20979: LD_VAR 0 3
20983: NOT
20984: OR
20985: PUSH
20986: LD_VAR 0 2
20990: PUSH
20991: LD_VAR 0 1
20995: GREATER
20996: OR
20997: PUSH
20998: LD_VAR 0 3
21002: PUSH
21003: LD_VAR 0 1
21007: GREATER
21008: OR
21009: IFFALSE 21013
// exit ;
21011: GO 21309
// if direction then
21013: LD_VAR 0 4
21017: IFFALSE 21081
// begin d := 1 ;
21019: LD_ADDR_VAR 0 9
21023: PUSH
21024: LD_INT 1
21026: ST_TO_ADDR
// if i_from > i_to then
21027: LD_VAR 0 2
21031: PUSH
21032: LD_VAR 0 3
21036: GREATER
21037: IFFALSE 21063
// length := ( array - i_from ) + i_to else
21039: LD_ADDR_VAR 0 11
21043: PUSH
21044: LD_VAR 0 1
21048: PUSH
21049: LD_VAR 0 2
21053: MINUS
21054: PUSH
21055: LD_VAR 0 3
21059: PLUS
21060: ST_TO_ADDR
21061: GO 21079
// length := i_to - i_from ;
21063: LD_ADDR_VAR 0 11
21067: PUSH
21068: LD_VAR 0 3
21072: PUSH
21073: LD_VAR 0 2
21077: MINUS
21078: ST_TO_ADDR
// end else
21079: GO 21142
// begin d := - 1 ;
21081: LD_ADDR_VAR 0 9
21085: PUSH
21086: LD_INT 1
21088: NEG
21089: ST_TO_ADDR
// if i_from > i_to then
21090: LD_VAR 0 2
21094: PUSH
21095: LD_VAR 0 3
21099: GREATER
21100: IFFALSE 21120
// length := i_from - i_to else
21102: LD_ADDR_VAR 0 11
21106: PUSH
21107: LD_VAR 0 2
21111: PUSH
21112: LD_VAR 0 3
21116: MINUS
21117: ST_TO_ADDR
21118: GO 21142
// length := ( array - i_to ) + i_from ;
21120: LD_ADDR_VAR 0 11
21124: PUSH
21125: LD_VAR 0 1
21129: PUSH
21130: LD_VAR 0 3
21134: MINUS
21135: PUSH
21136: LD_VAR 0 2
21140: PLUS
21141: ST_TO_ADDR
// end ; if not length then
21142: LD_VAR 0 11
21146: NOT
21147: IFFALSE 21151
// exit ;
21149: GO 21309
// tmp := array ;
21151: LD_ADDR_VAR 0 10
21155: PUSH
21156: LD_VAR 0 1
21160: ST_TO_ADDR
// for i = 1 to length do
21161: LD_ADDR_VAR 0 6
21165: PUSH
21166: DOUBLE
21167: LD_INT 1
21169: DEC
21170: ST_TO_ADDR
21171: LD_VAR 0 11
21175: PUSH
21176: FOR_TO
21177: IFFALSE 21297
// begin for j = 1 to array do
21179: LD_ADDR_VAR 0 7
21183: PUSH
21184: DOUBLE
21185: LD_INT 1
21187: DEC
21188: ST_TO_ADDR
21189: LD_VAR 0 1
21193: PUSH
21194: FOR_TO
21195: IFFALSE 21283
// begin k := j + d ;
21197: LD_ADDR_VAR 0 8
21201: PUSH
21202: LD_VAR 0 7
21206: PUSH
21207: LD_VAR 0 9
21211: PLUS
21212: ST_TO_ADDR
// if k > array then
21213: LD_VAR 0 8
21217: PUSH
21218: LD_VAR 0 1
21222: GREATER
21223: IFFALSE 21233
// k := 1 ;
21225: LD_ADDR_VAR 0 8
21229: PUSH
21230: LD_INT 1
21232: ST_TO_ADDR
// if not k then
21233: LD_VAR 0 8
21237: NOT
21238: IFFALSE 21250
// k := array ;
21240: LD_ADDR_VAR 0 8
21244: PUSH
21245: LD_VAR 0 1
21249: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
21250: LD_ADDR_VAR 0 10
21254: PUSH
21255: LD_VAR 0 10
21259: PPUSH
21260: LD_VAR 0 8
21264: PPUSH
21265: LD_VAR 0 1
21269: PUSH
21270: LD_VAR 0 7
21274: ARRAY
21275: PPUSH
21276: CALL_OW 1
21280: ST_TO_ADDR
// end ;
21281: GO 21194
21283: POP
21284: POP
// array := tmp ;
21285: LD_ADDR_VAR 0 1
21289: PUSH
21290: LD_VAR 0 10
21294: ST_TO_ADDR
// end ;
21295: GO 21176
21297: POP
21298: POP
// result := array ;
21299: LD_ADDR_VAR 0 5
21303: PUSH
21304: LD_VAR 0 1
21308: ST_TO_ADDR
// end ;
21309: LD_VAR 0 5
21313: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
21314: LD_INT 0
21316: PPUSH
21317: PPUSH
// result := 0 ;
21318: LD_ADDR_VAR 0 3
21322: PUSH
21323: LD_INT 0
21325: ST_TO_ADDR
// if not array or not value in array then
21326: LD_VAR 0 1
21330: NOT
21331: PUSH
21332: LD_VAR 0 2
21336: PUSH
21337: LD_VAR 0 1
21341: IN
21342: NOT
21343: OR
21344: IFFALSE 21348
// exit ;
21346: GO 21402
// for i = 1 to array do
21348: LD_ADDR_VAR 0 4
21352: PUSH
21353: DOUBLE
21354: LD_INT 1
21356: DEC
21357: ST_TO_ADDR
21358: LD_VAR 0 1
21362: PUSH
21363: FOR_TO
21364: IFFALSE 21400
// if value = array [ i ] then
21366: LD_VAR 0 2
21370: PUSH
21371: LD_VAR 0 1
21375: PUSH
21376: LD_VAR 0 4
21380: ARRAY
21381: EQUAL
21382: IFFALSE 21398
// begin result := i ;
21384: LD_ADDR_VAR 0 3
21388: PUSH
21389: LD_VAR 0 4
21393: ST_TO_ADDR
// exit ;
21394: POP
21395: POP
21396: GO 21402
// end ;
21398: GO 21363
21400: POP
21401: POP
// end ;
21402: LD_VAR 0 3
21406: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
21407: LD_INT 0
21409: PPUSH
// vc_chassis := chassis ;
21410: LD_ADDR_OWVAR 37
21414: PUSH
21415: LD_VAR 0 1
21419: ST_TO_ADDR
// vc_engine := engine ;
21420: LD_ADDR_OWVAR 39
21424: PUSH
21425: LD_VAR 0 2
21429: ST_TO_ADDR
// vc_control := control ;
21430: LD_ADDR_OWVAR 38
21434: PUSH
21435: LD_VAR 0 3
21439: ST_TO_ADDR
// vc_weapon := weapon ;
21440: LD_ADDR_OWVAR 40
21444: PUSH
21445: LD_VAR 0 4
21449: ST_TO_ADDR
// vc_fuel_battery := fuel ;
21450: LD_ADDR_OWVAR 41
21454: PUSH
21455: LD_VAR 0 5
21459: ST_TO_ADDR
// end ;
21460: LD_VAR 0 6
21464: RET
// export function WantPlant ( unit ) ; var task ; begin
21465: LD_INT 0
21467: PPUSH
21468: PPUSH
// result := false ;
21469: LD_ADDR_VAR 0 2
21473: PUSH
21474: LD_INT 0
21476: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
21477: LD_ADDR_VAR 0 3
21481: PUSH
21482: LD_VAR 0 1
21486: PPUSH
21487: CALL_OW 437
21491: ST_TO_ADDR
// if task then
21492: LD_VAR 0 3
21496: IFFALSE 21524
// if task [ 1 ] [ 1 ] = p then
21498: LD_VAR 0 3
21502: PUSH
21503: LD_INT 1
21505: ARRAY
21506: PUSH
21507: LD_INT 1
21509: ARRAY
21510: PUSH
21511: LD_STRING p
21513: EQUAL
21514: IFFALSE 21524
// result := true ;
21516: LD_ADDR_VAR 0 2
21520: PUSH
21521: LD_INT 1
21523: ST_TO_ADDR
// end ;
21524: LD_VAR 0 2
21528: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
21529: LD_INT 0
21531: PPUSH
21532: PPUSH
21533: PPUSH
21534: PPUSH
// if pos < 1 then
21535: LD_VAR 0 2
21539: PUSH
21540: LD_INT 1
21542: LESS
21543: IFFALSE 21547
// exit ;
21545: GO 21850
// if pos = 1 then
21547: LD_VAR 0 2
21551: PUSH
21552: LD_INT 1
21554: EQUAL
21555: IFFALSE 21588
// result := Replace ( arr , pos [ 1 ] , value ) else
21557: LD_ADDR_VAR 0 4
21561: PUSH
21562: LD_VAR 0 1
21566: PPUSH
21567: LD_VAR 0 2
21571: PUSH
21572: LD_INT 1
21574: ARRAY
21575: PPUSH
21576: LD_VAR 0 3
21580: PPUSH
21581: CALL_OW 1
21585: ST_TO_ADDR
21586: GO 21850
// begin tmp := arr ;
21588: LD_ADDR_VAR 0 6
21592: PUSH
21593: LD_VAR 0 1
21597: ST_TO_ADDR
// s_arr := [ tmp ] ;
21598: LD_ADDR_VAR 0 7
21602: PUSH
21603: LD_VAR 0 6
21607: PUSH
21608: EMPTY
21609: LIST
21610: ST_TO_ADDR
// for i = 1 to pos - 1 do
21611: LD_ADDR_VAR 0 5
21615: PUSH
21616: DOUBLE
21617: LD_INT 1
21619: DEC
21620: ST_TO_ADDR
21621: LD_VAR 0 2
21625: PUSH
21626: LD_INT 1
21628: MINUS
21629: PUSH
21630: FOR_TO
21631: IFFALSE 21676
// begin tmp := tmp [ pos [ i ] ] ;
21633: LD_ADDR_VAR 0 6
21637: PUSH
21638: LD_VAR 0 6
21642: PUSH
21643: LD_VAR 0 2
21647: PUSH
21648: LD_VAR 0 5
21652: ARRAY
21653: ARRAY
21654: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
21655: LD_ADDR_VAR 0 7
21659: PUSH
21660: LD_VAR 0 7
21664: PUSH
21665: LD_VAR 0 6
21669: PUSH
21670: EMPTY
21671: LIST
21672: ADD
21673: ST_TO_ADDR
// end ;
21674: GO 21630
21676: POP
21677: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
21678: LD_ADDR_VAR 0 6
21682: PUSH
21683: LD_VAR 0 6
21687: PPUSH
21688: LD_VAR 0 2
21692: PUSH
21693: LD_VAR 0 2
21697: ARRAY
21698: PPUSH
21699: LD_VAR 0 3
21703: PPUSH
21704: CALL_OW 1
21708: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21709: LD_ADDR_VAR 0 7
21713: PUSH
21714: LD_VAR 0 7
21718: PPUSH
21719: LD_VAR 0 7
21723: PPUSH
21724: LD_VAR 0 6
21728: PPUSH
21729: CALL_OW 1
21733: ST_TO_ADDR
// for i = s_arr downto 2 do
21734: LD_ADDR_VAR 0 5
21738: PUSH
21739: DOUBLE
21740: LD_VAR 0 7
21744: INC
21745: ST_TO_ADDR
21746: LD_INT 2
21748: PUSH
21749: FOR_DOWNTO
21750: IFFALSE 21834
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21752: LD_ADDR_VAR 0 6
21756: PUSH
21757: LD_VAR 0 7
21761: PUSH
21762: LD_VAR 0 5
21766: PUSH
21767: LD_INT 1
21769: MINUS
21770: ARRAY
21771: PPUSH
21772: LD_VAR 0 2
21776: PUSH
21777: LD_VAR 0 5
21781: PUSH
21782: LD_INT 1
21784: MINUS
21785: ARRAY
21786: PPUSH
21787: LD_VAR 0 7
21791: PUSH
21792: LD_VAR 0 5
21796: ARRAY
21797: PPUSH
21798: CALL_OW 1
21802: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21803: LD_ADDR_VAR 0 7
21807: PUSH
21808: LD_VAR 0 7
21812: PPUSH
21813: LD_VAR 0 5
21817: PUSH
21818: LD_INT 1
21820: MINUS
21821: PPUSH
21822: LD_VAR 0 6
21826: PPUSH
21827: CALL_OW 1
21831: ST_TO_ADDR
// end ;
21832: GO 21749
21834: POP
21835: POP
// result := s_arr [ 1 ] ;
21836: LD_ADDR_VAR 0 4
21840: PUSH
21841: LD_VAR 0 7
21845: PUSH
21846: LD_INT 1
21848: ARRAY
21849: ST_TO_ADDR
// end ; end ;
21850: LD_VAR 0 4
21854: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21855: LD_INT 0
21857: PPUSH
21858: PPUSH
// if not list then
21859: LD_VAR 0 1
21863: NOT
21864: IFFALSE 21868
// exit ;
21866: GO 21959
// i := list [ pos1 ] ;
21868: LD_ADDR_VAR 0 5
21872: PUSH
21873: LD_VAR 0 1
21877: PUSH
21878: LD_VAR 0 2
21882: ARRAY
21883: ST_TO_ADDR
// if not i then
21884: LD_VAR 0 5
21888: NOT
21889: IFFALSE 21893
// exit ;
21891: GO 21959
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21893: LD_ADDR_VAR 0 1
21897: PUSH
21898: LD_VAR 0 1
21902: PPUSH
21903: LD_VAR 0 2
21907: PPUSH
21908: LD_VAR 0 1
21912: PUSH
21913: LD_VAR 0 3
21917: ARRAY
21918: PPUSH
21919: CALL_OW 1
21923: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21924: LD_ADDR_VAR 0 1
21928: PUSH
21929: LD_VAR 0 1
21933: PPUSH
21934: LD_VAR 0 3
21938: PPUSH
21939: LD_VAR 0 5
21943: PPUSH
21944: CALL_OW 1
21948: ST_TO_ADDR
// result := list ;
21949: LD_ADDR_VAR 0 4
21953: PUSH
21954: LD_VAR 0 1
21958: ST_TO_ADDR
// end ;
21959: LD_VAR 0 4
21963: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21964: LD_INT 0
21966: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21967: LD_ADDR_VAR 0 5
21971: PUSH
21972: LD_VAR 0 1
21976: PPUSH
21977: CALL_OW 250
21981: PPUSH
21982: LD_VAR 0 1
21986: PPUSH
21987: CALL_OW 251
21991: PPUSH
21992: LD_VAR 0 2
21996: PPUSH
21997: LD_VAR 0 3
22001: PPUSH
22002: LD_VAR 0 4
22006: PPUSH
22007: CALL 22017 0 5
22011: ST_TO_ADDR
// end ;
22012: LD_VAR 0 5
22016: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
22017: LD_INT 0
22019: PPUSH
22020: PPUSH
22021: PPUSH
22022: PPUSH
// if not list then
22023: LD_VAR 0 3
22027: NOT
22028: IFFALSE 22032
// exit ;
22030: GO 22420
// result := [ ] ;
22032: LD_ADDR_VAR 0 6
22036: PUSH
22037: EMPTY
22038: ST_TO_ADDR
// for i in list do
22039: LD_ADDR_VAR 0 7
22043: PUSH
22044: LD_VAR 0 3
22048: PUSH
22049: FOR_IN
22050: IFFALSE 22252
// begin tmp := GetDistUnitXY ( i , x , y ) ;
22052: LD_ADDR_VAR 0 9
22056: PUSH
22057: LD_VAR 0 7
22061: PPUSH
22062: LD_VAR 0 1
22066: PPUSH
22067: LD_VAR 0 2
22071: PPUSH
22072: CALL_OW 297
22076: ST_TO_ADDR
// if not result then
22077: LD_VAR 0 6
22081: NOT
22082: IFFALSE 22108
// result := [ [ i , tmp ] ] else
22084: LD_ADDR_VAR 0 6
22088: PUSH
22089: LD_VAR 0 7
22093: PUSH
22094: LD_VAR 0 9
22098: PUSH
22099: EMPTY
22100: LIST
22101: LIST
22102: PUSH
22103: EMPTY
22104: LIST
22105: ST_TO_ADDR
22106: GO 22250
// begin if result [ result ] [ 2 ] < tmp then
22108: LD_VAR 0 6
22112: PUSH
22113: LD_VAR 0 6
22117: ARRAY
22118: PUSH
22119: LD_INT 2
22121: ARRAY
22122: PUSH
22123: LD_VAR 0 9
22127: LESS
22128: IFFALSE 22170
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
22130: LD_ADDR_VAR 0 6
22134: PUSH
22135: LD_VAR 0 6
22139: PPUSH
22140: LD_VAR 0 6
22144: PUSH
22145: LD_INT 1
22147: PLUS
22148: PPUSH
22149: LD_VAR 0 7
22153: PUSH
22154: LD_VAR 0 9
22158: PUSH
22159: EMPTY
22160: LIST
22161: LIST
22162: PPUSH
22163: CALL_OW 2
22167: ST_TO_ADDR
22168: GO 22250
// for j = 1 to result do
22170: LD_ADDR_VAR 0 8
22174: PUSH
22175: DOUBLE
22176: LD_INT 1
22178: DEC
22179: ST_TO_ADDR
22180: LD_VAR 0 6
22184: PUSH
22185: FOR_TO
22186: IFFALSE 22248
// begin if tmp < result [ j ] [ 2 ] then
22188: LD_VAR 0 9
22192: PUSH
22193: LD_VAR 0 6
22197: PUSH
22198: LD_VAR 0 8
22202: ARRAY
22203: PUSH
22204: LD_INT 2
22206: ARRAY
22207: LESS
22208: IFFALSE 22246
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22210: LD_ADDR_VAR 0 6
22214: PUSH
22215: LD_VAR 0 6
22219: PPUSH
22220: LD_VAR 0 8
22224: PPUSH
22225: LD_VAR 0 7
22229: PUSH
22230: LD_VAR 0 9
22234: PUSH
22235: EMPTY
22236: LIST
22237: LIST
22238: PPUSH
22239: CALL_OW 2
22243: ST_TO_ADDR
// break ;
22244: GO 22248
// end ; end ;
22246: GO 22185
22248: POP
22249: POP
// end ; end ;
22250: GO 22049
22252: POP
22253: POP
// if result and not asc then
22254: LD_VAR 0 6
22258: PUSH
22259: LD_VAR 0 4
22263: NOT
22264: AND
22265: IFFALSE 22340
// begin tmp := result ;
22267: LD_ADDR_VAR 0 9
22271: PUSH
22272: LD_VAR 0 6
22276: ST_TO_ADDR
// for i = tmp downto 1 do
22277: LD_ADDR_VAR 0 7
22281: PUSH
22282: DOUBLE
22283: LD_VAR 0 9
22287: INC
22288: ST_TO_ADDR
22289: LD_INT 1
22291: PUSH
22292: FOR_DOWNTO
22293: IFFALSE 22338
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
22295: LD_ADDR_VAR 0 6
22299: PUSH
22300: LD_VAR 0 6
22304: PPUSH
22305: LD_VAR 0 9
22309: PUSH
22310: LD_VAR 0 7
22314: MINUS
22315: PUSH
22316: LD_INT 1
22318: PLUS
22319: PPUSH
22320: LD_VAR 0 9
22324: PUSH
22325: LD_VAR 0 7
22329: ARRAY
22330: PPUSH
22331: CALL_OW 1
22335: ST_TO_ADDR
22336: GO 22292
22338: POP
22339: POP
// end ; tmp := [ ] ;
22340: LD_ADDR_VAR 0 9
22344: PUSH
22345: EMPTY
22346: ST_TO_ADDR
// if mode then
22347: LD_VAR 0 5
22351: IFFALSE 22420
// begin for i = 1 to result do
22353: LD_ADDR_VAR 0 7
22357: PUSH
22358: DOUBLE
22359: LD_INT 1
22361: DEC
22362: ST_TO_ADDR
22363: LD_VAR 0 6
22367: PUSH
22368: FOR_TO
22369: IFFALSE 22408
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
22371: LD_ADDR_VAR 0 9
22375: PUSH
22376: LD_VAR 0 9
22380: PPUSH
22381: LD_VAR 0 7
22385: PPUSH
22386: LD_VAR 0 6
22390: PUSH
22391: LD_VAR 0 7
22395: ARRAY
22396: PUSH
22397: LD_INT 1
22399: ARRAY
22400: PPUSH
22401: CALL_OW 1
22405: ST_TO_ADDR
22406: GO 22368
22408: POP
22409: POP
// result := tmp ;
22410: LD_ADDR_VAR 0 6
22414: PUSH
22415: LD_VAR 0 9
22419: ST_TO_ADDR
// end ; end ;
22420: LD_VAR 0 6
22424: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
22425: LD_INT 0
22427: PPUSH
22428: PPUSH
22429: PPUSH
22430: PPUSH
22431: PPUSH
22432: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
22433: LD_ADDR_VAR 0 5
22437: PUSH
22438: LD_INT 0
22440: PUSH
22441: LD_INT 0
22443: PUSH
22444: LD_INT 0
22446: PUSH
22447: EMPTY
22448: PUSH
22449: EMPTY
22450: LIST
22451: LIST
22452: LIST
22453: LIST
22454: ST_TO_ADDR
// if not x or not y then
22455: LD_VAR 0 2
22459: NOT
22460: PUSH
22461: LD_VAR 0 3
22465: NOT
22466: OR
22467: IFFALSE 22471
// exit ;
22469: GO 24117
// if not range then
22471: LD_VAR 0 4
22475: NOT
22476: IFFALSE 22486
// range := 10 ;
22478: LD_ADDR_VAR 0 4
22482: PUSH
22483: LD_INT 10
22485: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22486: LD_ADDR_VAR 0 8
22490: PUSH
22491: LD_INT 81
22493: PUSH
22494: LD_VAR 0 1
22498: PUSH
22499: EMPTY
22500: LIST
22501: LIST
22502: PUSH
22503: LD_INT 92
22505: PUSH
22506: LD_VAR 0 2
22510: PUSH
22511: LD_VAR 0 3
22515: PUSH
22516: LD_VAR 0 4
22520: PUSH
22521: EMPTY
22522: LIST
22523: LIST
22524: LIST
22525: LIST
22526: PUSH
22527: LD_INT 3
22529: PUSH
22530: LD_INT 21
22532: PUSH
22533: LD_INT 3
22535: PUSH
22536: EMPTY
22537: LIST
22538: LIST
22539: PUSH
22540: EMPTY
22541: LIST
22542: LIST
22543: PUSH
22544: EMPTY
22545: LIST
22546: LIST
22547: LIST
22548: PPUSH
22549: CALL_OW 69
22553: ST_TO_ADDR
// if not tmp then
22554: LD_VAR 0 8
22558: NOT
22559: IFFALSE 22563
// exit ;
22561: GO 24117
// for i in tmp do
22563: LD_ADDR_VAR 0 6
22567: PUSH
22568: LD_VAR 0 8
22572: PUSH
22573: FOR_IN
22574: IFFALSE 24092
// begin points := [ 0 , 0 , 0 ] ;
22576: LD_ADDR_VAR 0 9
22580: PUSH
22581: LD_INT 0
22583: PUSH
22584: LD_INT 0
22586: PUSH
22587: LD_INT 0
22589: PUSH
22590: EMPTY
22591: LIST
22592: LIST
22593: LIST
22594: ST_TO_ADDR
// bpoints := 1 ;
22595: LD_ADDR_VAR 0 10
22599: PUSH
22600: LD_INT 1
22602: ST_TO_ADDR
// case GetType ( i ) of unit_human :
22603: LD_VAR 0 6
22607: PPUSH
22608: CALL_OW 247
22612: PUSH
22613: LD_INT 1
22615: DOUBLE
22616: EQUAL
22617: IFTRUE 22621
22619: GO 23199
22621: POP
// begin if GetClass ( i ) = 1 then
22622: LD_VAR 0 6
22626: PPUSH
22627: CALL_OW 257
22631: PUSH
22632: LD_INT 1
22634: EQUAL
22635: IFFALSE 22656
// points := [ 10 , 5 , 3 ] ;
22637: LD_ADDR_VAR 0 9
22641: PUSH
22642: LD_INT 10
22644: PUSH
22645: LD_INT 5
22647: PUSH
22648: LD_INT 3
22650: PUSH
22651: EMPTY
22652: LIST
22653: LIST
22654: LIST
22655: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
22656: LD_VAR 0 6
22660: PPUSH
22661: CALL_OW 257
22665: PUSH
22666: LD_INT 2
22668: PUSH
22669: LD_INT 3
22671: PUSH
22672: LD_INT 4
22674: PUSH
22675: EMPTY
22676: LIST
22677: LIST
22678: LIST
22679: IN
22680: IFFALSE 22701
// points := [ 3 , 2 , 1 ] ;
22682: LD_ADDR_VAR 0 9
22686: PUSH
22687: LD_INT 3
22689: PUSH
22690: LD_INT 2
22692: PUSH
22693: LD_INT 1
22695: PUSH
22696: EMPTY
22697: LIST
22698: LIST
22699: LIST
22700: ST_TO_ADDR
// if GetClass ( i ) = 5 then
22701: LD_VAR 0 6
22705: PPUSH
22706: CALL_OW 257
22710: PUSH
22711: LD_INT 5
22713: EQUAL
22714: IFFALSE 22735
// points := [ 130 , 5 , 2 ] ;
22716: LD_ADDR_VAR 0 9
22720: PUSH
22721: LD_INT 130
22723: PUSH
22724: LD_INT 5
22726: PUSH
22727: LD_INT 2
22729: PUSH
22730: EMPTY
22731: LIST
22732: LIST
22733: LIST
22734: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22735: LD_VAR 0 6
22739: PPUSH
22740: CALL_OW 257
22744: PUSH
22745: LD_INT 8
22747: EQUAL
22748: IFFALSE 22769
// points := [ 35 , 35 , 30 ] ;
22750: LD_ADDR_VAR 0 9
22754: PUSH
22755: LD_INT 35
22757: PUSH
22758: LD_INT 35
22760: PUSH
22761: LD_INT 30
22763: PUSH
22764: EMPTY
22765: LIST
22766: LIST
22767: LIST
22768: ST_TO_ADDR
// if GetClass ( i ) = 9 then
22769: LD_VAR 0 6
22773: PPUSH
22774: CALL_OW 257
22778: PUSH
22779: LD_INT 9
22781: EQUAL
22782: IFFALSE 22803
// points := [ 20 , 55 , 40 ] ;
22784: LD_ADDR_VAR 0 9
22788: PUSH
22789: LD_INT 20
22791: PUSH
22792: LD_INT 55
22794: PUSH
22795: LD_INT 40
22797: PUSH
22798: EMPTY
22799: LIST
22800: LIST
22801: LIST
22802: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
22803: LD_VAR 0 6
22807: PPUSH
22808: CALL_OW 257
22812: PUSH
22813: LD_INT 12
22815: PUSH
22816: LD_INT 16
22818: PUSH
22819: EMPTY
22820: LIST
22821: LIST
22822: IN
22823: IFFALSE 22844
// points := [ 5 , 3 , 2 ] ;
22825: LD_ADDR_VAR 0 9
22829: PUSH
22830: LD_INT 5
22832: PUSH
22833: LD_INT 3
22835: PUSH
22836: LD_INT 2
22838: PUSH
22839: EMPTY
22840: LIST
22841: LIST
22842: LIST
22843: ST_TO_ADDR
// if GetClass ( i ) = 17 then
22844: LD_VAR 0 6
22848: PPUSH
22849: CALL_OW 257
22853: PUSH
22854: LD_INT 17
22856: EQUAL
22857: IFFALSE 22878
// points := [ 100 , 50 , 75 ] ;
22859: LD_ADDR_VAR 0 9
22863: PUSH
22864: LD_INT 100
22866: PUSH
22867: LD_INT 50
22869: PUSH
22870: LD_INT 75
22872: PUSH
22873: EMPTY
22874: LIST
22875: LIST
22876: LIST
22877: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22878: LD_VAR 0 6
22882: PPUSH
22883: CALL_OW 257
22887: PUSH
22888: LD_INT 15
22890: EQUAL
22891: IFFALSE 22912
// points := [ 10 , 5 , 3 ] ;
22893: LD_ADDR_VAR 0 9
22897: PUSH
22898: LD_INT 10
22900: PUSH
22901: LD_INT 5
22903: PUSH
22904: LD_INT 3
22906: PUSH
22907: EMPTY
22908: LIST
22909: LIST
22910: LIST
22911: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22912: LD_VAR 0 6
22916: PPUSH
22917: CALL_OW 257
22921: PUSH
22922: LD_INT 14
22924: EQUAL
22925: IFFALSE 22946
// points := [ 10 , 0 , 0 ] ;
22927: LD_ADDR_VAR 0 9
22931: PUSH
22932: LD_INT 10
22934: PUSH
22935: LD_INT 0
22937: PUSH
22938: LD_INT 0
22940: PUSH
22941: EMPTY
22942: LIST
22943: LIST
22944: LIST
22945: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22946: LD_VAR 0 6
22950: PPUSH
22951: CALL_OW 257
22955: PUSH
22956: LD_INT 11
22958: EQUAL
22959: IFFALSE 22980
// points := [ 30 , 10 , 5 ] ;
22961: LD_ADDR_VAR 0 9
22965: PUSH
22966: LD_INT 30
22968: PUSH
22969: LD_INT 10
22971: PUSH
22972: LD_INT 5
22974: PUSH
22975: EMPTY
22976: LIST
22977: LIST
22978: LIST
22979: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22980: LD_VAR 0 1
22984: PPUSH
22985: LD_INT 5
22987: PPUSH
22988: CALL_OW 321
22992: PUSH
22993: LD_INT 2
22995: EQUAL
22996: IFFALSE 23013
// bpoints := bpoints * 1.8 ;
22998: LD_ADDR_VAR 0 10
23002: PUSH
23003: LD_VAR 0 10
23007: PUSH
23008: LD_REAL  1.80000000000000E+0000
23011: MUL
23012: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
23013: LD_VAR 0 6
23017: PPUSH
23018: CALL_OW 257
23022: PUSH
23023: LD_INT 1
23025: PUSH
23026: LD_INT 2
23028: PUSH
23029: LD_INT 3
23031: PUSH
23032: LD_INT 4
23034: PUSH
23035: EMPTY
23036: LIST
23037: LIST
23038: LIST
23039: LIST
23040: IN
23041: PUSH
23042: LD_VAR 0 1
23046: PPUSH
23047: LD_INT 51
23049: PPUSH
23050: CALL_OW 321
23054: PUSH
23055: LD_INT 2
23057: EQUAL
23058: AND
23059: IFFALSE 23076
// bpoints := bpoints * 1.2 ;
23061: LD_ADDR_VAR 0 10
23065: PUSH
23066: LD_VAR 0 10
23070: PUSH
23071: LD_REAL  1.20000000000000E+0000
23074: MUL
23075: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
23076: LD_VAR 0 6
23080: PPUSH
23081: CALL_OW 257
23085: PUSH
23086: LD_INT 5
23088: PUSH
23089: LD_INT 7
23091: PUSH
23092: LD_INT 9
23094: PUSH
23095: EMPTY
23096: LIST
23097: LIST
23098: LIST
23099: IN
23100: PUSH
23101: LD_VAR 0 1
23105: PPUSH
23106: LD_INT 52
23108: PPUSH
23109: CALL_OW 321
23113: PUSH
23114: LD_INT 2
23116: EQUAL
23117: AND
23118: IFFALSE 23135
// bpoints := bpoints * 1.5 ;
23120: LD_ADDR_VAR 0 10
23124: PUSH
23125: LD_VAR 0 10
23129: PUSH
23130: LD_REAL  1.50000000000000E+0000
23133: MUL
23134: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
23135: LD_VAR 0 1
23139: PPUSH
23140: LD_INT 66
23142: PPUSH
23143: CALL_OW 321
23147: PUSH
23148: LD_INT 2
23150: EQUAL
23151: IFFALSE 23168
// bpoints := bpoints * 1.1 ;
23153: LD_ADDR_VAR 0 10
23157: PUSH
23158: LD_VAR 0 10
23162: PUSH
23163: LD_REAL  1.10000000000000E+0000
23166: MUL
23167: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
23168: LD_ADDR_VAR 0 10
23172: PUSH
23173: LD_VAR 0 10
23177: PUSH
23178: LD_VAR 0 6
23182: PPUSH
23183: LD_INT 1
23185: PPUSH
23186: CALL_OW 259
23190: PUSH
23191: LD_REAL  1.15000000000000E+0000
23194: MUL
23195: MUL
23196: ST_TO_ADDR
// end ; unit_vehicle :
23197: GO 24021
23199: LD_INT 2
23201: DOUBLE
23202: EQUAL
23203: IFTRUE 23207
23205: GO 24009
23207: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
23208: LD_VAR 0 6
23212: PPUSH
23213: CALL_OW 264
23217: PUSH
23218: LD_INT 2
23220: PUSH
23221: LD_INT 42
23223: PUSH
23224: LD_INT 24
23226: PUSH
23227: EMPTY
23228: LIST
23229: LIST
23230: LIST
23231: IN
23232: IFFALSE 23253
// points := [ 25 , 5 , 3 ] ;
23234: LD_ADDR_VAR 0 9
23238: PUSH
23239: LD_INT 25
23241: PUSH
23242: LD_INT 5
23244: PUSH
23245: LD_INT 3
23247: PUSH
23248: EMPTY
23249: LIST
23250: LIST
23251: LIST
23252: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
23253: LD_VAR 0 6
23257: PPUSH
23258: CALL_OW 264
23262: PUSH
23263: LD_INT 4
23265: PUSH
23266: LD_INT 43
23268: PUSH
23269: LD_INT 25
23271: PUSH
23272: EMPTY
23273: LIST
23274: LIST
23275: LIST
23276: IN
23277: IFFALSE 23298
// points := [ 40 , 15 , 5 ] ;
23279: LD_ADDR_VAR 0 9
23283: PUSH
23284: LD_INT 40
23286: PUSH
23287: LD_INT 15
23289: PUSH
23290: LD_INT 5
23292: PUSH
23293: EMPTY
23294: LIST
23295: LIST
23296: LIST
23297: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
23298: LD_VAR 0 6
23302: PPUSH
23303: CALL_OW 264
23307: PUSH
23308: LD_INT 3
23310: PUSH
23311: LD_INT 23
23313: PUSH
23314: EMPTY
23315: LIST
23316: LIST
23317: IN
23318: IFFALSE 23339
// points := [ 7 , 25 , 8 ] ;
23320: LD_ADDR_VAR 0 9
23324: PUSH
23325: LD_INT 7
23327: PUSH
23328: LD_INT 25
23330: PUSH
23331: LD_INT 8
23333: PUSH
23334: EMPTY
23335: LIST
23336: LIST
23337: LIST
23338: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
23339: LD_VAR 0 6
23343: PPUSH
23344: CALL_OW 264
23348: PUSH
23349: LD_INT 5
23351: PUSH
23352: LD_INT 27
23354: PUSH
23355: LD_INT 44
23357: PUSH
23358: EMPTY
23359: LIST
23360: LIST
23361: LIST
23362: IN
23363: IFFALSE 23384
// points := [ 14 , 50 , 16 ] ;
23365: LD_ADDR_VAR 0 9
23369: PUSH
23370: LD_INT 14
23372: PUSH
23373: LD_INT 50
23375: PUSH
23376: LD_INT 16
23378: PUSH
23379: EMPTY
23380: LIST
23381: LIST
23382: LIST
23383: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
23384: LD_VAR 0 6
23388: PPUSH
23389: CALL_OW 264
23393: PUSH
23394: LD_INT 6
23396: PUSH
23397: LD_INT 46
23399: PUSH
23400: EMPTY
23401: LIST
23402: LIST
23403: IN
23404: IFFALSE 23425
// points := [ 32 , 120 , 70 ] ;
23406: LD_ADDR_VAR 0 9
23410: PUSH
23411: LD_INT 32
23413: PUSH
23414: LD_INT 120
23416: PUSH
23417: LD_INT 70
23419: PUSH
23420: EMPTY
23421: LIST
23422: LIST
23423: LIST
23424: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
23425: LD_VAR 0 6
23429: PPUSH
23430: CALL_OW 264
23434: PUSH
23435: LD_INT 7
23437: PUSH
23438: LD_INT 28
23440: PUSH
23441: LD_INT 45
23443: PUSH
23444: EMPTY
23445: LIST
23446: LIST
23447: LIST
23448: IN
23449: IFFALSE 23470
// points := [ 35 , 20 , 45 ] ;
23451: LD_ADDR_VAR 0 9
23455: PUSH
23456: LD_INT 35
23458: PUSH
23459: LD_INT 20
23461: PUSH
23462: LD_INT 45
23464: PUSH
23465: EMPTY
23466: LIST
23467: LIST
23468: LIST
23469: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
23470: LD_VAR 0 6
23474: PPUSH
23475: CALL_OW 264
23479: PUSH
23480: LD_INT 47
23482: PUSH
23483: EMPTY
23484: LIST
23485: IN
23486: IFFALSE 23507
// points := [ 67 , 45 , 75 ] ;
23488: LD_ADDR_VAR 0 9
23492: PUSH
23493: LD_INT 67
23495: PUSH
23496: LD_INT 45
23498: PUSH
23499: LD_INT 75
23501: PUSH
23502: EMPTY
23503: LIST
23504: LIST
23505: LIST
23506: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
23507: LD_VAR 0 6
23511: PPUSH
23512: CALL_OW 264
23516: PUSH
23517: LD_INT 26
23519: PUSH
23520: EMPTY
23521: LIST
23522: IN
23523: IFFALSE 23544
// points := [ 120 , 30 , 80 ] ;
23525: LD_ADDR_VAR 0 9
23529: PUSH
23530: LD_INT 120
23532: PUSH
23533: LD_INT 30
23535: PUSH
23536: LD_INT 80
23538: PUSH
23539: EMPTY
23540: LIST
23541: LIST
23542: LIST
23543: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
23544: LD_VAR 0 6
23548: PPUSH
23549: CALL_OW 264
23553: PUSH
23554: LD_INT 22
23556: PUSH
23557: EMPTY
23558: LIST
23559: IN
23560: IFFALSE 23581
// points := [ 40 , 1 , 1 ] ;
23562: LD_ADDR_VAR 0 9
23566: PUSH
23567: LD_INT 40
23569: PUSH
23570: LD_INT 1
23572: PUSH
23573: LD_INT 1
23575: PUSH
23576: EMPTY
23577: LIST
23578: LIST
23579: LIST
23580: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
23581: LD_VAR 0 6
23585: PPUSH
23586: CALL_OW 264
23590: PUSH
23591: LD_INT 29
23593: PUSH
23594: EMPTY
23595: LIST
23596: IN
23597: IFFALSE 23618
// points := [ 70 , 200 , 400 ] ;
23599: LD_ADDR_VAR 0 9
23603: PUSH
23604: LD_INT 70
23606: PUSH
23607: LD_INT 200
23609: PUSH
23610: LD_INT 400
23612: PUSH
23613: EMPTY
23614: LIST
23615: LIST
23616: LIST
23617: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
23618: LD_VAR 0 6
23622: PPUSH
23623: CALL_OW 264
23627: PUSH
23628: LD_INT 14
23630: PUSH
23631: LD_INT 53
23633: PUSH
23634: EMPTY
23635: LIST
23636: LIST
23637: IN
23638: IFFALSE 23659
// points := [ 40 , 10 , 20 ] ;
23640: LD_ADDR_VAR 0 9
23644: PUSH
23645: LD_INT 40
23647: PUSH
23648: LD_INT 10
23650: PUSH
23651: LD_INT 20
23653: PUSH
23654: EMPTY
23655: LIST
23656: LIST
23657: LIST
23658: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
23659: LD_VAR 0 6
23663: PPUSH
23664: CALL_OW 264
23668: PUSH
23669: LD_INT 9
23671: PUSH
23672: EMPTY
23673: LIST
23674: IN
23675: IFFALSE 23696
// points := [ 5 , 70 , 20 ] ;
23677: LD_ADDR_VAR 0 9
23681: PUSH
23682: LD_INT 5
23684: PUSH
23685: LD_INT 70
23687: PUSH
23688: LD_INT 20
23690: PUSH
23691: EMPTY
23692: LIST
23693: LIST
23694: LIST
23695: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
23696: LD_VAR 0 6
23700: PPUSH
23701: CALL_OW 264
23705: PUSH
23706: LD_INT 10
23708: PUSH
23709: EMPTY
23710: LIST
23711: IN
23712: IFFALSE 23733
// points := [ 35 , 110 , 70 ] ;
23714: LD_ADDR_VAR 0 9
23718: PUSH
23719: LD_INT 35
23721: PUSH
23722: LD_INT 110
23724: PUSH
23725: LD_INT 70
23727: PUSH
23728: EMPTY
23729: LIST
23730: LIST
23731: LIST
23732: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23733: LD_VAR 0 6
23737: PPUSH
23738: CALL_OW 265
23742: PUSH
23743: LD_INT 25
23745: EQUAL
23746: IFFALSE 23767
// points := [ 80 , 65 , 100 ] ;
23748: LD_ADDR_VAR 0 9
23752: PUSH
23753: LD_INT 80
23755: PUSH
23756: LD_INT 65
23758: PUSH
23759: LD_INT 100
23761: PUSH
23762: EMPTY
23763: LIST
23764: LIST
23765: LIST
23766: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
23767: LD_VAR 0 6
23771: PPUSH
23772: CALL_OW 263
23776: PUSH
23777: LD_INT 1
23779: EQUAL
23780: IFFALSE 23815
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
23782: LD_ADDR_VAR 0 10
23786: PUSH
23787: LD_VAR 0 10
23791: PUSH
23792: LD_VAR 0 6
23796: PPUSH
23797: CALL_OW 311
23801: PPUSH
23802: LD_INT 3
23804: PPUSH
23805: CALL_OW 259
23809: PUSH
23810: LD_INT 4
23812: MUL
23813: MUL
23814: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
23815: LD_VAR 0 6
23819: PPUSH
23820: CALL_OW 263
23824: PUSH
23825: LD_INT 2
23827: EQUAL
23828: IFFALSE 23879
// begin j := IsControledBy ( i ) ;
23830: LD_ADDR_VAR 0 7
23834: PUSH
23835: LD_VAR 0 6
23839: PPUSH
23840: CALL_OW 312
23844: ST_TO_ADDR
// if j then
23845: LD_VAR 0 7
23849: IFFALSE 23879
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
23851: LD_ADDR_VAR 0 10
23855: PUSH
23856: LD_VAR 0 10
23860: PUSH
23861: LD_VAR 0 7
23865: PPUSH
23866: LD_INT 3
23868: PPUSH
23869: CALL_OW 259
23873: PUSH
23874: LD_INT 3
23876: MUL
23877: MUL
23878: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23879: LD_VAR 0 6
23883: PPUSH
23884: CALL_OW 264
23888: PUSH
23889: LD_INT 5
23891: PUSH
23892: LD_INT 6
23894: PUSH
23895: LD_INT 46
23897: PUSH
23898: LD_INT 44
23900: PUSH
23901: LD_INT 47
23903: PUSH
23904: LD_INT 45
23906: PUSH
23907: LD_INT 28
23909: PUSH
23910: LD_INT 7
23912: PUSH
23913: LD_INT 27
23915: PUSH
23916: LD_INT 29
23918: PUSH
23919: EMPTY
23920: LIST
23921: LIST
23922: LIST
23923: LIST
23924: LIST
23925: LIST
23926: LIST
23927: LIST
23928: LIST
23929: LIST
23930: IN
23931: PUSH
23932: LD_VAR 0 1
23936: PPUSH
23937: LD_INT 52
23939: PPUSH
23940: CALL_OW 321
23944: PUSH
23945: LD_INT 2
23947: EQUAL
23948: AND
23949: IFFALSE 23966
// bpoints := bpoints * 1.2 ;
23951: LD_ADDR_VAR 0 10
23955: PUSH
23956: LD_VAR 0 10
23960: PUSH
23961: LD_REAL  1.20000000000000E+0000
23964: MUL
23965: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23966: LD_VAR 0 6
23970: PPUSH
23971: CALL_OW 264
23975: PUSH
23976: LD_INT 6
23978: PUSH
23979: LD_INT 46
23981: PUSH
23982: LD_INT 47
23984: PUSH
23985: EMPTY
23986: LIST
23987: LIST
23988: LIST
23989: IN
23990: IFFALSE 24007
// bpoints := bpoints * 1.2 ;
23992: LD_ADDR_VAR 0 10
23996: PUSH
23997: LD_VAR 0 10
24001: PUSH
24002: LD_REAL  1.20000000000000E+0000
24005: MUL
24006: ST_TO_ADDR
// end ; unit_building :
24007: GO 24021
24009: LD_INT 3
24011: DOUBLE
24012: EQUAL
24013: IFTRUE 24017
24015: GO 24020
24017: POP
// ; end ;
24018: GO 24021
24020: POP
// for j = 1 to 3 do
24021: LD_ADDR_VAR 0 7
24025: PUSH
24026: DOUBLE
24027: LD_INT 1
24029: DEC
24030: ST_TO_ADDR
24031: LD_INT 3
24033: PUSH
24034: FOR_TO
24035: IFFALSE 24088
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
24037: LD_ADDR_VAR 0 5
24041: PUSH
24042: LD_VAR 0 5
24046: PPUSH
24047: LD_VAR 0 7
24051: PPUSH
24052: LD_VAR 0 5
24056: PUSH
24057: LD_VAR 0 7
24061: ARRAY
24062: PUSH
24063: LD_VAR 0 9
24067: PUSH
24068: LD_VAR 0 7
24072: ARRAY
24073: PUSH
24074: LD_VAR 0 10
24078: MUL
24079: PLUS
24080: PPUSH
24081: CALL_OW 1
24085: ST_TO_ADDR
24086: GO 24034
24088: POP
24089: POP
// end ;
24090: GO 22573
24092: POP
24093: POP
// result := Replace ( result , 4 , tmp ) ;
24094: LD_ADDR_VAR 0 5
24098: PUSH
24099: LD_VAR 0 5
24103: PPUSH
24104: LD_INT 4
24106: PPUSH
24107: LD_VAR 0 8
24111: PPUSH
24112: CALL_OW 1
24116: ST_TO_ADDR
// end ;
24117: LD_VAR 0 5
24121: RET
// export function DangerAtRange ( unit , range ) ; begin
24122: LD_INT 0
24124: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
24125: LD_ADDR_VAR 0 3
24129: PUSH
24130: LD_VAR 0 1
24134: PPUSH
24135: CALL_OW 255
24139: PPUSH
24140: LD_VAR 0 1
24144: PPUSH
24145: CALL_OW 250
24149: PPUSH
24150: LD_VAR 0 1
24154: PPUSH
24155: CALL_OW 251
24159: PPUSH
24160: LD_VAR 0 2
24164: PPUSH
24165: CALL 22425 0 4
24169: ST_TO_ADDR
// end ;
24170: LD_VAR 0 3
24174: RET
// export function DangerInArea ( side , area ) ; begin
24175: LD_INT 0
24177: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
24178: LD_ADDR_VAR 0 3
24182: PUSH
24183: LD_VAR 0 2
24187: PPUSH
24188: LD_INT 81
24190: PUSH
24191: LD_VAR 0 1
24195: PUSH
24196: EMPTY
24197: LIST
24198: LIST
24199: PPUSH
24200: CALL_OW 70
24204: ST_TO_ADDR
// end ;
24205: LD_VAR 0 3
24209: RET
// export function IsExtension ( b ) ; begin
24210: LD_INT 0
24212: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
24213: LD_ADDR_VAR 0 2
24217: PUSH
24218: LD_VAR 0 1
24222: PUSH
24223: LD_INT 23
24225: PUSH
24226: LD_INT 20
24228: PUSH
24229: LD_INT 22
24231: PUSH
24232: LD_INT 17
24234: PUSH
24235: LD_INT 24
24237: PUSH
24238: LD_INT 21
24240: PUSH
24241: LD_INT 19
24243: PUSH
24244: LD_INT 16
24246: PUSH
24247: LD_INT 25
24249: PUSH
24250: LD_INT 18
24252: PUSH
24253: EMPTY
24254: LIST
24255: LIST
24256: LIST
24257: LIST
24258: LIST
24259: LIST
24260: LIST
24261: LIST
24262: LIST
24263: LIST
24264: IN
24265: ST_TO_ADDR
// end ;
24266: LD_VAR 0 2
24270: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
24271: LD_INT 0
24273: PPUSH
24274: PPUSH
24275: PPUSH
// result := [ ] ;
24276: LD_ADDR_VAR 0 3
24280: PUSH
24281: EMPTY
24282: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
24283: LD_ADDR_VAR 0 4
24287: PUSH
24288: LD_VAR 0 2
24292: PPUSH
24293: LD_INT 21
24295: PUSH
24296: LD_INT 3
24298: PUSH
24299: EMPTY
24300: LIST
24301: LIST
24302: PPUSH
24303: CALL_OW 70
24307: ST_TO_ADDR
// if not tmp then
24308: LD_VAR 0 4
24312: NOT
24313: IFFALSE 24317
// exit ;
24315: GO 24375
// for i in tmp do
24317: LD_ADDR_VAR 0 5
24321: PUSH
24322: LD_VAR 0 4
24326: PUSH
24327: FOR_IN
24328: IFFALSE 24363
// if GetBase ( i ) <> base then
24330: LD_VAR 0 5
24334: PPUSH
24335: CALL_OW 274
24339: PUSH
24340: LD_VAR 0 1
24344: NONEQUAL
24345: IFFALSE 24361
// ComLinkToBase ( base , i ) ;
24347: LD_VAR 0 1
24351: PPUSH
24352: LD_VAR 0 5
24356: PPUSH
24357: CALL_OW 169
24361: GO 24327
24363: POP
24364: POP
// result := tmp ;
24365: LD_ADDR_VAR 0 3
24369: PUSH
24370: LD_VAR 0 4
24374: ST_TO_ADDR
// end ;
24375: LD_VAR 0 3
24379: RET
// export function ComComplete ( unit , b ) ; var i ; begin
24380: LD_INT 0
24382: PPUSH
24383: PPUSH
// if BuildingStatus ( b ) = bs_build then
24384: LD_VAR 0 2
24388: PPUSH
24389: CALL_OW 461
24393: PUSH
24394: LD_INT 1
24396: EQUAL
24397: IFFALSE 24457
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
24399: LD_VAR 0 1
24403: PPUSH
24404: LD_STRING h
24406: PUSH
24407: LD_VAR 0 2
24411: PPUSH
24412: CALL_OW 250
24416: PUSH
24417: LD_VAR 0 2
24421: PPUSH
24422: CALL_OW 251
24426: PUSH
24427: LD_VAR 0 2
24431: PUSH
24432: LD_INT 0
24434: PUSH
24435: LD_INT 0
24437: PUSH
24438: LD_INT 0
24440: PUSH
24441: EMPTY
24442: LIST
24443: LIST
24444: LIST
24445: LIST
24446: LIST
24447: LIST
24448: LIST
24449: PUSH
24450: EMPTY
24451: LIST
24452: PPUSH
24453: CALL_OW 446
// end ;
24457: LD_VAR 0 3
24461: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
24462: LD_INT 0
24464: PPUSH
24465: PPUSH
24466: PPUSH
24467: PPUSH
24468: PPUSH
24469: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
24470: LD_VAR 0 1
24474: NOT
24475: PUSH
24476: LD_VAR 0 1
24480: PPUSH
24481: CALL_OW 263
24485: PUSH
24486: LD_INT 2
24488: EQUAL
24489: NOT
24490: OR
24491: IFFALSE 24495
// exit ;
24493: GO 24811
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
24495: LD_ADDR_VAR 0 6
24499: PUSH
24500: LD_INT 22
24502: PUSH
24503: LD_VAR 0 1
24507: PPUSH
24508: CALL_OW 255
24512: PUSH
24513: EMPTY
24514: LIST
24515: LIST
24516: PUSH
24517: LD_INT 2
24519: PUSH
24520: LD_INT 30
24522: PUSH
24523: LD_INT 36
24525: PUSH
24526: EMPTY
24527: LIST
24528: LIST
24529: PUSH
24530: LD_INT 34
24532: PUSH
24533: LD_INT 31
24535: PUSH
24536: EMPTY
24537: LIST
24538: LIST
24539: PUSH
24540: EMPTY
24541: LIST
24542: LIST
24543: LIST
24544: PUSH
24545: EMPTY
24546: LIST
24547: LIST
24548: PPUSH
24549: CALL_OW 69
24553: ST_TO_ADDR
// if not tmp then
24554: LD_VAR 0 6
24558: NOT
24559: IFFALSE 24563
// exit ;
24561: GO 24811
// result := [ ] ;
24563: LD_ADDR_VAR 0 2
24567: PUSH
24568: EMPTY
24569: ST_TO_ADDR
// for i in tmp do
24570: LD_ADDR_VAR 0 3
24574: PUSH
24575: LD_VAR 0 6
24579: PUSH
24580: FOR_IN
24581: IFFALSE 24652
// begin t := UnitsInside ( i ) ;
24583: LD_ADDR_VAR 0 4
24587: PUSH
24588: LD_VAR 0 3
24592: PPUSH
24593: CALL_OW 313
24597: ST_TO_ADDR
// if t then
24598: LD_VAR 0 4
24602: IFFALSE 24650
// for j in t do
24604: LD_ADDR_VAR 0 7
24608: PUSH
24609: LD_VAR 0 4
24613: PUSH
24614: FOR_IN
24615: IFFALSE 24648
// result := Insert ( result , result + 1 , j ) ;
24617: LD_ADDR_VAR 0 2
24621: PUSH
24622: LD_VAR 0 2
24626: PPUSH
24627: LD_VAR 0 2
24631: PUSH
24632: LD_INT 1
24634: PLUS
24635: PPUSH
24636: LD_VAR 0 7
24640: PPUSH
24641: CALL_OW 2
24645: ST_TO_ADDR
24646: GO 24614
24648: POP
24649: POP
// end ;
24650: GO 24580
24652: POP
24653: POP
// if not result then
24654: LD_VAR 0 2
24658: NOT
24659: IFFALSE 24663
// exit ;
24661: GO 24811
// mech := result [ 1 ] ;
24663: LD_ADDR_VAR 0 5
24667: PUSH
24668: LD_VAR 0 2
24672: PUSH
24673: LD_INT 1
24675: ARRAY
24676: ST_TO_ADDR
// if result > 1 then
24677: LD_VAR 0 2
24681: PUSH
24682: LD_INT 1
24684: GREATER
24685: IFFALSE 24797
// for i = 2 to result do
24687: LD_ADDR_VAR 0 3
24691: PUSH
24692: DOUBLE
24693: LD_INT 2
24695: DEC
24696: ST_TO_ADDR
24697: LD_VAR 0 2
24701: PUSH
24702: FOR_TO
24703: IFFALSE 24795
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
24705: LD_ADDR_VAR 0 4
24709: PUSH
24710: LD_VAR 0 2
24714: PUSH
24715: LD_VAR 0 3
24719: ARRAY
24720: PPUSH
24721: LD_INT 3
24723: PPUSH
24724: CALL_OW 259
24728: PUSH
24729: LD_VAR 0 2
24733: PUSH
24734: LD_VAR 0 3
24738: ARRAY
24739: PPUSH
24740: CALL_OW 432
24744: MINUS
24745: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
24746: LD_VAR 0 4
24750: PUSH
24751: LD_VAR 0 5
24755: PPUSH
24756: LD_INT 3
24758: PPUSH
24759: CALL_OW 259
24763: PUSH
24764: LD_VAR 0 5
24768: PPUSH
24769: CALL_OW 432
24773: MINUS
24774: GREATEREQUAL
24775: IFFALSE 24793
// mech := result [ i ] ;
24777: LD_ADDR_VAR 0 5
24781: PUSH
24782: LD_VAR 0 2
24786: PUSH
24787: LD_VAR 0 3
24791: ARRAY
24792: ST_TO_ADDR
// end ;
24793: GO 24702
24795: POP
24796: POP
// ComLinkTo ( vehicle , mech ) ;
24797: LD_VAR 0 1
24801: PPUSH
24802: LD_VAR 0 5
24806: PPUSH
24807: CALL_OW 135
// end ;
24811: LD_VAR 0 2
24815: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
24816: LD_INT 0
24818: PPUSH
24819: PPUSH
24820: PPUSH
24821: PPUSH
24822: PPUSH
24823: PPUSH
24824: PPUSH
24825: PPUSH
24826: PPUSH
24827: PPUSH
24828: PPUSH
24829: PPUSH
24830: PPUSH
// result := [ ] ;
24831: LD_ADDR_VAR 0 7
24835: PUSH
24836: EMPTY
24837: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
24838: LD_VAR 0 1
24842: PPUSH
24843: CALL_OW 266
24847: PUSH
24848: LD_INT 0
24850: PUSH
24851: LD_INT 1
24853: PUSH
24854: EMPTY
24855: LIST
24856: LIST
24857: IN
24858: NOT
24859: IFFALSE 24863
// exit ;
24861: GO 26494
// if name then
24863: LD_VAR 0 3
24867: IFFALSE 24883
// SetBName ( base_dep , name ) ;
24869: LD_VAR 0 1
24873: PPUSH
24874: LD_VAR 0 3
24878: PPUSH
24879: CALL_OW 500
// base := GetBase ( base_dep ) ;
24883: LD_ADDR_VAR 0 15
24887: PUSH
24888: LD_VAR 0 1
24892: PPUSH
24893: CALL_OW 274
24897: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24898: LD_ADDR_VAR 0 16
24902: PUSH
24903: LD_VAR 0 1
24907: PPUSH
24908: CALL_OW 255
24912: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24913: LD_ADDR_VAR 0 17
24917: PUSH
24918: LD_VAR 0 1
24922: PPUSH
24923: CALL_OW 248
24927: ST_TO_ADDR
// if sources then
24928: LD_VAR 0 5
24932: IFFALSE 24979
// for i = 1 to 3 do
24934: LD_ADDR_VAR 0 8
24938: PUSH
24939: DOUBLE
24940: LD_INT 1
24942: DEC
24943: ST_TO_ADDR
24944: LD_INT 3
24946: PUSH
24947: FOR_TO
24948: IFFALSE 24977
// AddResourceType ( base , i , sources [ i ] ) ;
24950: LD_VAR 0 15
24954: PPUSH
24955: LD_VAR 0 8
24959: PPUSH
24960: LD_VAR 0 5
24964: PUSH
24965: LD_VAR 0 8
24969: ARRAY
24970: PPUSH
24971: CALL_OW 276
24975: GO 24947
24977: POP
24978: POP
// buildings := GetBaseBuildings ( base , area ) ;
24979: LD_ADDR_VAR 0 18
24983: PUSH
24984: LD_VAR 0 15
24988: PPUSH
24989: LD_VAR 0 2
24993: PPUSH
24994: CALL 24271 0 2
24998: ST_TO_ADDR
// InitHc ;
24999: CALL_OW 19
// InitUc ;
25003: CALL_OW 18
// uc_side := side ;
25007: LD_ADDR_OWVAR 20
25011: PUSH
25012: LD_VAR 0 16
25016: ST_TO_ADDR
// uc_nation := nation ;
25017: LD_ADDR_OWVAR 21
25021: PUSH
25022: LD_VAR 0 17
25026: ST_TO_ADDR
// if buildings then
25027: LD_VAR 0 18
25031: IFFALSE 26353
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
25033: LD_ADDR_VAR 0 19
25037: PUSH
25038: LD_VAR 0 18
25042: PPUSH
25043: LD_INT 2
25045: PUSH
25046: LD_INT 30
25048: PUSH
25049: LD_INT 29
25051: PUSH
25052: EMPTY
25053: LIST
25054: LIST
25055: PUSH
25056: LD_INT 30
25058: PUSH
25059: LD_INT 30
25061: PUSH
25062: EMPTY
25063: LIST
25064: LIST
25065: PUSH
25066: EMPTY
25067: LIST
25068: LIST
25069: LIST
25070: PPUSH
25071: CALL_OW 72
25075: ST_TO_ADDR
// if tmp then
25076: LD_VAR 0 19
25080: IFFALSE 25128
// for i in tmp do
25082: LD_ADDR_VAR 0 8
25086: PUSH
25087: LD_VAR 0 19
25091: PUSH
25092: FOR_IN
25093: IFFALSE 25126
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
25095: LD_VAR 0 8
25099: PPUSH
25100: CALL_OW 250
25104: PPUSH
25105: LD_VAR 0 8
25109: PPUSH
25110: CALL_OW 251
25114: PPUSH
25115: LD_VAR 0 16
25119: PPUSH
25120: CALL_OW 441
25124: GO 25092
25126: POP
25127: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
25128: LD_VAR 0 18
25132: PPUSH
25133: LD_INT 2
25135: PUSH
25136: LD_INT 30
25138: PUSH
25139: LD_INT 32
25141: PUSH
25142: EMPTY
25143: LIST
25144: LIST
25145: PUSH
25146: LD_INT 30
25148: PUSH
25149: LD_INT 33
25151: PUSH
25152: EMPTY
25153: LIST
25154: LIST
25155: PUSH
25156: EMPTY
25157: LIST
25158: LIST
25159: LIST
25160: PPUSH
25161: CALL_OW 72
25165: IFFALSE 25253
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
25167: LD_ADDR_VAR 0 8
25171: PUSH
25172: LD_VAR 0 18
25176: PPUSH
25177: LD_INT 2
25179: PUSH
25180: LD_INT 30
25182: PUSH
25183: LD_INT 32
25185: PUSH
25186: EMPTY
25187: LIST
25188: LIST
25189: PUSH
25190: LD_INT 30
25192: PUSH
25193: LD_INT 33
25195: PUSH
25196: EMPTY
25197: LIST
25198: LIST
25199: PUSH
25200: EMPTY
25201: LIST
25202: LIST
25203: LIST
25204: PPUSH
25205: CALL_OW 72
25209: PUSH
25210: FOR_IN
25211: IFFALSE 25251
// begin if not GetBWeapon ( i ) then
25213: LD_VAR 0 8
25217: PPUSH
25218: CALL_OW 269
25222: NOT
25223: IFFALSE 25249
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
25225: LD_VAR 0 8
25229: PPUSH
25230: LD_VAR 0 8
25234: PPUSH
25235: LD_VAR 0 2
25239: PPUSH
25240: CALL 26499 0 2
25244: PPUSH
25245: CALL_OW 431
// end ;
25249: GO 25210
25251: POP
25252: POP
// end ; for i = 1 to personel do
25253: LD_ADDR_VAR 0 8
25257: PUSH
25258: DOUBLE
25259: LD_INT 1
25261: DEC
25262: ST_TO_ADDR
25263: LD_VAR 0 6
25267: PUSH
25268: FOR_TO
25269: IFFALSE 26333
// begin if i > 4 then
25271: LD_VAR 0 8
25275: PUSH
25276: LD_INT 4
25278: GREATER
25279: IFFALSE 25283
// break ;
25281: GO 26333
// case i of 1 :
25283: LD_VAR 0 8
25287: PUSH
25288: LD_INT 1
25290: DOUBLE
25291: EQUAL
25292: IFTRUE 25296
25294: GO 25376
25296: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
25297: LD_ADDR_VAR 0 12
25301: PUSH
25302: LD_VAR 0 18
25306: PPUSH
25307: LD_INT 22
25309: PUSH
25310: LD_VAR 0 16
25314: PUSH
25315: EMPTY
25316: LIST
25317: LIST
25318: PUSH
25319: LD_INT 58
25321: PUSH
25322: EMPTY
25323: LIST
25324: PUSH
25325: LD_INT 2
25327: PUSH
25328: LD_INT 30
25330: PUSH
25331: LD_INT 32
25333: PUSH
25334: EMPTY
25335: LIST
25336: LIST
25337: PUSH
25338: LD_INT 30
25340: PUSH
25341: LD_INT 4
25343: PUSH
25344: EMPTY
25345: LIST
25346: LIST
25347: PUSH
25348: LD_INT 30
25350: PUSH
25351: LD_INT 5
25353: PUSH
25354: EMPTY
25355: LIST
25356: LIST
25357: PUSH
25358: EMPTY
25359: LIST
25360: LIST
25361: LIST
25362: LIST
25363: PUSH
25364: EMPTY
25365: LIST
25366: LIST
25367: LIST
25368: PPUSH
25369: CALL_OW 72
25373: ST_TO_ADDR
25374: GO 25598
25376: LD_INT 2
25378: DOUBLE
25379: EQUAL
25380: IFTRUE 25384
25382: GO 25446
25384: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
25385: LD_ADDR_VAR 0 12
25389: PUSH
25390: LD_VAR 0 18
25394: PPUSH
25395: LD_INT 22
25397: PUSH
25398: LD_VAR 0 16
25402: PUSH
25403: EMPTY
25404: LIST
25405: LIST
25406: PUSH
25407: LD_INT 2
25409: PUSH
25410: LD_INT 30
25412: PUSH
25413: LD_INT 0
25415: PUSH
25416: EMPTY
25417: LIST
25418: LIST
25419: PUSH
25420: LD_INT 30
25422: PUSH
25423: LD_INT 1
25425: PUSH
25426: EMPTY
25427: LIST
25428: LIST
25429: PUSH
25430: EMPTY
25431: LIST
25432: LIST
25433: LIST
25434: PUSH
25435: EMPTY
25436: LIST
25437: LIST
25438: PPUSH
25439: CALL_OW 72
25443: ST_TO_ADDR
25444: GO 25598
25446: LD_INT 3
25448: DOUBLE
25449: EQUAL
25450: IFTRUE 25454
25452: GO 25516
25454: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
25455: LD_ADDR_VAR 0 12
25459: PUSH
25460: LD_VAR 0 18
25464: PPUSH
25465: LD_INT 22
25467: PUSH
25468: LD_VAR 0 16
25472: PUSH
25473: EMPTY
25474: LIST
25475: LIST
25476: PUSH
25477: LD_INT 2
25479: PUSH
25480: LD_INT 30
25482: PUSH
25483: LD_INT 2
25485: PUSH
25486: EMPTY
25487: LIST
25488: LIST
25489: PUSH
25490: LD_INT 30
25492: PUSH
25493: LD_INT 3
25495: PUSH
25496: EMPTY
25497: LIST
25498: LIST
25499: PUSH
25500: EMPTY
25501: LIST
25502: LIST
25503: LIST
25504: PUSH
25505: EMPTY
25506: LIST
25507: LIST
25508: PPUSH
25509: CALL_OW 72
25513: ST_TO_ADDR
25514: GO 25598
25516: LD_INT 4
25518: DOUBLE
25519: EQUAL
25520: IFTRUE 25524
25522: GO 25597
25524: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
25525: LD_ADDR_VAR 0 12
25529: PUSH
25530: LD_VAR 0 18
25534: PPUSH
25535: LD_INT 22
25537: PUSH
25538: LD_VAR 0 16
25542: PUSH
25543: EMPTY
25544: LIST
25545: LIST
25546: PUSH
25547: LD_INT 2
25549: PUSH
25550: LD_INT 30
25552: PUSH
25553: LD_INT 6
25555: PUSH
25556: EMPTY
25557: LIST
25558: LIST
25559: PUSH
25560: LD_INT 30
25562: PUSH
25563: LD_INT 7
25565: PUSH
25566: EMPTY
25567: LIST
25568: LIST
25569: PUSH
25570: LD_INT 30
25572: PUSH
25573: LD_INT 8
25575: PUSH
25576: EMPTY
25577: LIST
25578: LIST
25579: PUSH
25580: EMPTY
25581: LIST
25582: LIST
25583: LIST
25584: LIST
25585: PUSH
25586: EMPTY
25587: LIST
25588: LIST
25589: PPUSH
25590: CALL_OW 72
25594: ST_TO_ADDR
25595: GO 25598
25597: POP
// if i = 1 then
25598: LD_VAR 0 8
25602: PUSH
25603: LD_INT 1
25605: EQUAL
25606: IFFALSE 25717
// begin tmp := [ ] ;
25608: LD_ADDR_VAR 0 19
25612: PUSH
25613: EMPTY
25614: ST_TO_ADDR
// for j in f do
25615: LD_ADDR_VAR 0 9
25619: PUSH
25620: LD_VAR 0 12
25624: PUSH
25625: FOR_IN
25626: IFFALSE 25699
// if GetBType ( j ) = b_bunker then
25628: LD_VAR 0 9
25632: PPUSH
25633: CALL_OW 266
25637: PUSH
25638: LD_INT 32
25640: EQUAL
25641: IFFALSE 25668
// tmp := Insert ( tmp , 1 , j ) else
25643: LD_ADDR_VAR 0 19
25647: PUSH
25648: LD_VAR 0 19
25652: PPUSH
25653: LD_INT 1
25655: PPUSH
25656: LD_VAR 0 9
25660: PPUSH
25661: CALL_OW 2
25665: ST_TO_ADDR
25666: GO 25697
// tmp := Insert ( tmp , tmp + 1 , j ) ;
25668: LD_ADDR_VAR 0 19
25672: PUSH
25673: LD_VAR 0 19
25677: PPUSH
25678: LD_VAR 0 19
25682: PUSH
25683: LD_INT 1
25685: PLUS
25686: PPUSH
25687: LD_VAR 0 9
25691: PPUSH
25692: CALL_OW 2
25696: ST_TO_ADDR
25697: GO 25625
25699: POP
25700: POP
// if tmp then
25701: LD_VAR 0 19
25705: IFFALSE 25717
// f := tmp ;
25707: LD_ADDR_VAR 0 12
25711: PUSH
25712: LD_VAR 0 19
25716: ST_TO_ADDR
// end ; x := personel [ i ] ;
25717: LD_ADDR_VAR 0 13
25721: PUSH
25722: LD_VAR 0 6
25726: PUSH
25727: LD_VAR 0 8
25731: ARRAY
25732: ST_TO_ADDR
// if x = - 1 then
25733: LD_VAR 0 13
25737: PUSH
25738: LD_INT 1
25740: NEG
25741: EQUAL
25742: IFFALSE 25951
// begin for j in f do
25744: LD_ADDR_VAR 0 9
25748: PUSH
25749: LD_VAR 0 12
25753: PUSH
25754: FOR_IN
25755: IFFALSE 25947
// repeat InitHc ;
25757: CALL_OW 19
// if GetBType ( j ) = b_barracks then
25761: LD_VAR 0 9
25765: PPUSH
25766: CALL_OW 266
25770: PUSH
25771: LD_INT 5
25773: EQUAL
25774: IFFALSE 25844
// begin if UnitsInside ( j ) < 3 then
25776: LD_VAR 0 9
25780: PPUSH
25781: CALL_OW 313
25785: PUSH
25786: LD_INT 3
25788: LESS
25789: IFFALSE 25825
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25791: LD_INT 0
25793: PPUSH
25794: LD_INT 5
25796: PUSH
25797: LD_INT 8
25799: PUSH
25800: LD_INT 9
25802: PUSH
25803: EMPTY
25804: LIST
25805: LIST
25806: LIST
25807: PUSH
25808: LD_VAR 0 17
25812: ARRAY
25813: PPUSH
25814: LD_VAR 0 4
25818: PPUSH
25819: CALL_OW 380
25823: GO 25842
// PrepareHuman ( false , i , skill ) ;
25825: LD_INT 0
25827: PPUSH
25828: LD_VAR 0 8
25832: PPUSH
25833: LD_VAR 0 4
25837: PPUSH
25838: CALL_OW 380
// end else
25842: GO 25861
// PrepareHuman ( false , i , skill ) ;
25844: LD_INT 0
25846: PPUSH
25847: LD_VAR 0 8
25851: PPUSH
25852: LD_VAR 0 4
25856: PPUSH
25857: CALL_OW 380
// un := CreateHuman ;
25861: LD_ADDR_VAR 0 14
25865: PUSH
25866: CALL_OW 44
25870: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25871: LD_ADDR_VAR 0 7
25875: PUSH
25876: LD_VAR 0 7
25880: PPUSH
25881: LD_INT 1
25883: PPUSH
25884: LD_VAR 0 14
25888: PPUSH
25889: CALL_OW 2
25893: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25894: LD_VAR 0 14
25898: PPUSH
25899: LD_VAR 0 9
25903: PPUSH
25904: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25908: LD_VAR 0 9
25912: PPUSH
25913: CALL_OW 313
25917: PUSH
25918: LD_INT 6
25920: EQUAL
25921: PUSH
25922: LD_VAR 0 9
25926: PPUSH
25927: CALL_OW 266
25931: PUSH
25932: LD_INT 32
25934: PUSH
25935: LD_INT 31
25937: PUSH
25938: EMPTY
25939: LIST
25940: LIST
25941: IN
25942: OR
25943: IFFALSE 25757
25945: GO 25754
25947: POP
25948: POP
// end else
25949: GO 26331
// for j = 1 to x do
25951: LD_ADDR_VAR 0 9
25955: PUSH
25956: DOUBLE
25957: LD_INT 1
25959: DEC
25960: ST_TO_ADDR
25961: LD_VAR 0 13
25965: PUSH
25966: FOR_TO
25967: IFFALSE 26329
// begin InitHc ;
25969: CALL_OW 19
// if not f then
25973: LD_VAR 0 12
25977: NOT
25978: IFFALSE 26067
// begin PrepareHuman ( false , i , skill ) ;
25980: LD_INT 0
25982: PPUSH
25983: LD_VAR 0 8
25987: PPUSH
25988: LD_VAR 0 4
25992: PPUSH
25993: CALL_OW 380
// un := CreateHuman ;
25997: LD_ADDR_VAR 0 14
26001: PUSH
26002: CALL_OW 44
26006: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26007: LD_ADDR_VAR 0 7
26011: PUSH
26012: LD_VAR 0 7
26016: PPUSH
26017: LD_INT 1
26019: PPUSH
26020: LD_VAR 0 14
26024: PPUSH
26025: CALL_OW 2
26029: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26030: LD_VAR 0 14
26034: PPUSH
26035: LD_VAR 0 1
26039: PPUSH
26040: CALL_OW 250
26044: PPUSH
26045: LD_VAR 0 1
26049: PPUSH
26050: CALL_OW 251
26054: PPUSH
26055: LD_INT 10
26057: PPUSH
26058: LD_INT 0
26060: PPUSH
26061: CALL_OW 50
// continue ;
26065: GO 25966
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
26067: LD_VAR 0 12
26071: PUSH
26072: LD_INT 1
26074: ARRAY
26075: PPUSH
26076: CALL_OW 313
26080: PUSH
26081: LD_VAR 0 12
26085: PUSH
26086: LD_INT 1
26088: ARRAY
26089: PPUSH
26090: CALL_OW 266
26094: PUSH
26095: LD_INT 32
26097: PUSH
26098: LD_INT 31
26100: PUSH
26101: EMPTY
26102: LIST
26103: LIST
26104: IN
26105: AND
26106: PUSH
26107: LD_VAR 0 12
26111: PUSH
26112: LD_INT 1
26114: ARRAY
26115: PPUSH
26116: CALL_OW 313
26120: PUSH
26121: LD_INT 6
26123: EQUAL
26124: OR
26125: IFFALSE 26145
// f := Delete ( f , 1 ) ;
26127: LD_ADDR_VAR 0 12
26131: PUSH
26132: LD_VAR 0 12
26136: PPUSH
26137: LD_INT 1
26139: PPUSH
26140: CALL_OW 3
26144: ST_TO_ADDR
// if not f then
26145: LD_VAR 0 12
26149: NOT
26150: IFFALSE 26168
// begin x := x + 2 ;
26152: LD_ADDR_VAR 0 13
26156: PUSH
26157: LD_VAR 0 13
26161: PUSH
26162: LD_INT 2
26164: PLUS
26165: ST_TO_ADDR
// continue ;
26166: GO 25966
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
26168: LD_VAR 0 12
26172: PUSH
26173: LD_INT 1
26175: ARRAY
26176: PPUSH
26177: CALL_OW 266
26181: PUSH
26182: LD_INT 5
26184: EQUAL
26185: IFFALSE 26259
// begin if UnitsInside ( f [ 1 ] ) < 3 then
26187: LD_VAR 0 12
26191: PUSH
26192: LD_INT 1
26194: ARRAY
26195: PPUSH
26196: CALL_OW 313
26200: PUSH
26201: LD_INT 3
26203: LESS
26204: IFFALSE 26240
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26206: LD_INT 0
26208: PPUSH
26209: LD_INT 5
26211: PUSH
26212: LD_INT 8
26214: PUSH
26215: LD_INT 9
26217: PUSH
26218: EMPTY
26219: LIST
26220: LIST
26221: LIST
26222: PUSH
26223: LD_VAR 0 17
26227: ARRAY
26228: PPUSH
26229: LD_VAR 0 4
26233: PPUSH
26234: CALL_OW 380
26238: GO 26257
// PrepareHuman ( false , i , skill ) ;
26240: LD_INT 0
26242: PPUSH
26243: LD_VAR 0 8
26247: PPUSH
26248: LD_VAR 0 4
26252: PPUSH
26253: CALL_OW 380
// end else
26257: GO 26276
// PrepareHuman ( false , i , skill ) ;
26259: LD_INT 0
26261: PPUSH
26262: LD_VAR 0 8
26266: PPUSH
26267: LD_VAR 0 4
26271: PPUSH
26272: CALL_OW 380
// un := CreateHuman ;
26276: LD_ADDR_VAR 0 14
26280: PUSH
26281: CALL_OW 44
26285: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26286: LD_ADDR_VAR 0 7
26290: PUSH
26291: LD_VAR 0 7
26295: PPUSH
26296: LD_INT 1
26298: PPUSH
26299: LD_VAR 0 14
26303: PPUSH
26304: CALL_OW 2
26308: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
26309: LD_VAR 0 14
26313: PPUSH
26314: LD_VAR 0 12
26318: PUSH
26319: LD_INT 1
26321: ARRAY
26322: PPUSH
26323: CALL_OW 52
// end ;
26327: GO 25966
26329: POP
26330: POP
// end ;
26331: GO 25268
26333: POP
26334: POP
// result := result ^ buildings ;
26335: LD_ADDR_VAR 0 7
26339: PUSH
26340: LD_VAR 0 7
26344: PUSH
26345: LD_VAR 0 18
26349: ADD
26350: ST_TO_ADDR
// end else
26351: GO 26494
// begin for i = 1 to personel do
26353: LD_ADDR_VAR 0 8
26357: PUSH
26358: DOUBLE
26359: LD_INT 1
26361: DEC
26362: ST_TO_ADDR
26363: LD_VAR 0 6
26367: PUSH
26368: FOR_TO
26369: IFFALSE 26492
// begin if i > 4 then
26371: LD_VAR 0 8
26375: PUSH
26376: LD_INT 4
26378: GREATER
26379: IFFALSE 26383
// break ;
26381: GO 26492
// x := personel [ i ] ;
26383: LD_ADDR_VAR 0 13
26387: PUSH
26388: LD_VAR 0 6
26392: PUSH
26393: LD_VAR 0 8
26397: ARRAY
26398: ST_TO_ADDR
// if x = - 1 then
26399: LD_VAR 0 13
26403: PUSH
26404: LD_INT 1
26406: NEG
26407: EQUAL
26408: IFFALSE 26412
// continue ;
26410: GO 26368
// PrepareHuman ( false , i , skill ) ;
26412: LD_INT 0
26414: PPUSH
26415: LD_VAR 0 8
26419: PPUSH
26420: LD_VAR 0 4
26424: PPUSH
26425: CALL_OW 380
// un := CreateHuman ;
26429: LD_ADDR_VAR 0 14
26433: PUSH
26434: CALL_OW 44
26438: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26439: LD_VAR 0 14
26443: PPUSH
26444: LD_VAR 0 1
26448: PPUSH
26449: CALL_OW 250
26453: PPUSH
26454: LD_VAR 0 1
26458: PPUSH
26459: CALL_OW 251
26463: PPUSH
26464: LD_INT 10
26466: PPUSH
26467: LD_INT 0
26469: PPUSH
26470: CALL_OW 50
// result := result ^ un ;
26474: LD_ADDR_VAR 0 7
26478: PUSH
26479: LD_VAR 0 7
26483: PUSH
26484: LD_VAR 0 14
26488: ADD
26489: ST_TO_ADDR
// end ;
26490: GO 26368
26492: POP
26493: POP
// end ; end ;
26494: LD_VAR 0 7
26498: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
26499: LD_INT 0
26501: PPUSH
26502: PPUSH
26503: PPUSH
26504: PPUSH
26505: PPUSH
26506: PPUSH
26507: PPUSH
26508: PPUSH
26509: PPUSH
26510: PPUSH
26511: PPUSH
26512: PPUSH
26513: PPUSH
26514: PPUSH
26515: PPUSH
26516: PPUSH
// result := false ;
26517: LD_ADDR_VAR 0 3
26521: PUSH
26522: LD_INT 0
26524: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
26525: LD_VAR 0 1
26529: NOT
26530: PUSH
26531: LD_VAR 0 1
26535: PPUSH
26536: CALL_OW 266
26540: PUSH
26541: LD_INT 32
26543: PUSH
26544: LD_INT 33
26546: PUSH
26547: EMPTY
26548: LIST
26549: LIST
26550: IN
26551: NOT
26552: OR
26553: IFFALSE 26557
// exit ;
26555: GO 27693
// nat := GetNation ( tower ) ;
26557: LD_ADDR_VAR 0 12
26561: PUSH
26562: LD_VAR 0 1
26566: PPUSH
26567: CALL_OW 248
26571: ST_TO_ADDR
// side := GetSide ( tower ) ;
26572: LD_ADDR_VAR 0 16
26576: PUSH
26577: LD_VAR 0 1
26581: PPUSH
26582: CALL_OW 255
26586: ST_TO_ADDR
// x := GetX ( tower ) ;
26587: LD_ADDR_VAR 0 10
26591: PUSH
26592: LD_VAR 0 1
26596: PPUSH
26597: CALL_OW 250
26601: ST_TO_ADDR
// y := GetY ( tower ) ;
26602: LD_ADDR_VAR 0 11
26606: PUSH
26607: LD_VAR 0 1
26611: PPUSH
26612: CALL_OW 251
26616: ST_TO_ADDR
// if not x or not y then
26617: LD_VAR 0 10
26621: NOT
26622: PUSH
26623: LD_VAR 0 11
26627: NOT
26628: OR
26629: IFFALSE 26633
// exit ;
26631: GO 27693
// weapon := 0 ;
26633: LD_ADDR_VAR 0 18
26637: PUSH
26638: LD_INT 0
26640: ST_TO_ADDR
// fac_list := [ ] ;
26641: LD_ADDR_VAR 0 17
26645: PUSH
26646: EMPTY
26647: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
26648: LD_ADDR_VAR 0 6
26652: PUSH
26653: LD_VAR 0 1
26657: PPUSH
26658: CALL_OW 274
26662: PPUSH
26663: LD_VAR 0 2
26667: PPUSH
26668: CALL 24271 0 2
26672: PPUSH
26673: LD_INT 30
26675: PUSH
26676: LD_INT 3
26678: PUSH
26679: EMPTY
26680: LIST
26681: LIST
26682: PPUSH
26683: CALL_OW 72
26687: ST_TO_ADDR
// if not factories then
26688: LD_VAR 0 6
26692: NOT
26693: IFFALSE 26697
// exit ;
26695: GO 27693
// for i in factories do
26697: LD_ADDR_VAR 0 8
26701: PUSH
26702: LD_VAR 0 6
26706: PUSH
26707: FOR_IN
26708: IFFALSE 26733
// fac_list := fac_list union AvailableWeaponList ( i ) ;
26710: LD_ADDR_VAR 0 17
26714: PUSH
26715: LD_VAR 0 17
26719: PUSH
26720: LD_VAR 0 8
26724: PPUSH
26725: CALL_OW 478
26729: UNION
26730: ST_TO_ADDR
26731: GO 26707
26733: POP
26734: POP
// if not fac_list then
26735: LD_VAR 0 17
26739: NOT
26740: IFFALSE 26744
// exit ;
26742: GO 27693
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
26744: LD_ADDR_VAR 0 5
26748: PUSH
26749: LD_INT 4
26751: PUSH
26752: LD_INT 5
26754: PUSH
26755: LD_INT 9
26757: PUSH
26758: LD_INT 10
26760: PUSH
26761: LD_INT 6
26763: PUSH
26764: LD_INT 7
26766: PUSH
26767: LD_INT 11
26769: PUSH
26770: EMPTY
26771: LIST
26772: LIST
26773: LIST
26774: LIST
26775: LIST
26776: LIST
26777: LIST
26778: PUSH
26779: LD_INT 27
26781: PUSH
26782: LD_INT 28
26784: PUSH
26785: LD_INT 26
26787: PUSH
26788: LD_INT 30
26790: PUSH
26791: EMPTY
26792: LIST
26793: LIST
26794: LIST
26795: LIST
26796: PUSH
26797: LD_INT 43
26799: PUSH
26800: LD_INT 44
26802: PUSH
26803: LD_INT 46
26805: PUSH
26806: LD_INT 45
26808: PUSH
26809: LD_INT 47
26811: PUSH
26812: LD_INT 49
26814: PUSH
26815: EMPTY
26816: LIST
26817: LIST
26818: LIST
26819: LIST
26820: LIST
26821: LIST
26822: PUSH
26823: EMPTY
26824: LIST
26825: LIST
26826: LIST
26827: PUSH
26828: LD_VAR 0 12
26832: ARRAY
26833: ST_TO_ADDR
// for i in list do
26834: LD_ADDR_VAR 0 8
26838: PUSH
26839: LD_VAR 0 5
26843: PUSH
26844: FOR_IN
26845: IFFALSE 26878
// if not i in fac_list then
26847: LD_VAR 0 8
26851: PUSH
26852: LD_VAR 0 17
26856: IN
26857: NOT
26858: IFFALSE 26876
// list := list diff i ;
26860: LD_ADDR_VAR 0 5
26864: PUSH
26865: LD_VAR 0 5
26869: PUSH
26870: LD_VAR 0 8
26874: DIFF
26875: ST_TO_ADDR
26876: GO 26844
26878: POP
26879: POP
// if not list then
26880: LD_VAR 0 5
26884: NOT
26885: IFFALSE 26889
// exit ;
26887: GO 27693
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26889: LD_VAR 0 12
26893: PUSH
26894: LD_INT 3
26896: EQUAL
26897: PUSH
26898: LD_INT 49
26900: PUSH
26901: LD_VAR 0 5
26905: IN
26906: AND
26907: PUSH
26908: LD_INT 31
26910: PPUSH
26911: LD_VAR 0 16
26915: PPUSH
26916: CALL_OW 321
26920: PUSH
26921: LD_INT 2
26923: EQUAL
26924: AND
26925: IFFALSE 26985
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26927: LD_INT 22
26929: PUSH
26930: LD_VAR 0 16
26934: PUSH
26935: EMPTY
26936: LIST
26937: LIST
26938: PUSH
26939: LD_INT 35
26941: PUSH
26942: LD_INT 49
26944: PUSH
26945: EMPTY
26946: LIST
26947: LIST
26948: PUSH
26949: LD_INT 91
26951: PUSH
26952: LD_VAR 0 1
26956: PUSH
26957: LD_INT 10
26959: PUSH
26960: EMPTY
26961: LIST
26962: LIST
26963: LIST
26964: PUSH
26965: EMPTY
26966: LIST
26967: LIST
26968: LIST
26969: PPUSH
26970: CALL_OW 69
26974: NOT
26975: IFFALSE 26985
// weapon := ru_time_lapser ;
26977: LD_ADDR_VAR 0 18
26981: PUSH
26982: LD_INT 49
26984: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26985: LD_VAR 0 12
26989: PUSH
26990: LD_INT 1
26992: PUSH
26993: LD_INT 2
26995: PUSH
26996: EMPTY
26997: LIST
26998: LIST
26999: IN
27000: PUSH
27001: LD_INT 11
27003: PUSH
27004: LD_VAR 0 5
27008: IN
27009: PUSH
27010: LD_INT 30
27012: PUSH
27013: LD_VAR 0 5
27017: IN
27018: OR
27019: AND
27020: PUSH
27021: LD_INT 6
27023: PPUSH
27024: LD_VAR 0 16
27028: PPUSH
27029: CALL_OW 321
27033: PUSH
27034: LD_INT 2
27036: EQUAL
27037: AND
27038: IFFALSE 27203
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
27040: LD_INT 22
27042: PUSH
27043: LD_VAR 0 16
27047: PUSH
27048: EMPTY
27049: LIST
27050: LIST
27051: PUSH
27052: LD_INT 2
27054: PUSH
27055: LD_INT 35
27057: PUSH
27058: LD_INT 11
27060: PUSH
27061: EMPTY
27062: LIST
27063: LIST
27064: PUSH
27065: LD_INT 35
27067: PUSH
27068: LD_INT 30
27070: PUSH
27071: EMPTY
27072: LIST
27073: LIST
27074: PUSH
27075: EMPTY
27076: LIST
27077: LIST
27078: LIST
27079: PUSH
27080: LD_INT 91
27082: PUSH
27083: LD_VAR 0 1
27087: PUSH
27088: LD_INT 18
27090: PUSH
27091: EMPTY
27092: LIST
27093: LIST
27094: LIST
27095: PUSH
27096: EMPTY
27097: LIST
27098: LIST
27099: LIST
27100: PPUSH
27101: CALL_OW 69
27105: NOT
27106: PUSH
27107: LD_INT 22
27109: PUSH
27110: LD_VAR 0 16
27114: PUSH
27115: EMPTY
27116: LIST
27117: LIST
27118: PUSH
27119: LD_INT 2
27121: PUSH
27122: LD_INT 30
27124: PUSH
27125: LD_INT 32
27127: PUSH
27128: EMPTY
27129: LIST
27130: LIST
27131: PUSH
27132: LD_INT 30
27134: PUSH
27135: LD_INT 33
27137: PUSH
27138: EMPTY
27139: LIST
27140: LIST
27141: PUSH
27142: EMPTY
27143: LIST
27144: LIST
27145: LIST
27146: PUSH
27147: LD_INT 91
27149: PUSH
27150: LD_VAR 0 1
27154: PUSH
27155: LD_INT 12
27157: PUSH
27158: EMPTY
27159: LIST
27160: LIST
27161: LIST
27162: PUSH
27163: EMPTY
27164: LIST
27165: LIST
27166: LIST
27167: PUSH
27168: EMPTY
27169: LIST
27170: PPUSH
27171: CALL_OW 69
27175: PUSH
27176: LD_INT 2
27178: GREATER
27179: AND
27180: IFFALSE 27203
// weapon := [ us_radar , ar_radar ] [ nat ] ;
27182: LD_ADDR_VAR 0 18
27186: PUSH
27187: LD_INT 11
27189: PUSH
27190: LD_INT 30
27192: PUSH
27193: EMPTY
27194: LIST
27195: LIST
27196: PUSH
27197: LD_VAR 0 12
27201: ARRAY
27202: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
27203: LD_VAR 0 18
27207: NOT
27208: PUSH
27209: LD_INT 40
27211: PPUSH
27212: LD_VAR 0 16
27216: PPUSH
27217: CALL_OW 321
27221: PUSH
27222: LD_INT 2
27224: EQUAL
27225: AND
27226: PUSH
27227: LD_INT 7
27229: PUSH
27230: LD_VAR 0 5
27234: IN
27235: PUSH
27236: LD_INT 28
27238: PUSH
27239: LD_VAR 0 5
27243: IN
27244: OR
27245: PUSH
27246: LD_INT 45
27248: PUSH
27249: LD_VAR 0 5
27253: IN
27254: OR
27255: AND
27256: IFFALSE 27510
// begin hex := GetHexInfo ( x , y ) ;
27258: LD_ADDR_VAR 0 4
27262: PUSH
27263: LD_VAR 0 10
27267: PPUSH
27268: LD_VAR 0 11
27272: PPUSH
27273: CALL_OW 546
27277: ST_TO_ADDR
// if hex [ 1 ] then
27278: LD_VAR 0 4
27282: PUSH
27283: LD_INT 1
27285: ARRAY
27286: IFFALSE 27290
// exit ;
27288: GO 27693
// height := hex [ 2 ] ;
27290: LD_ADDR_VAR 0 15
27294: PUSH
27295: LD_VAR 0 4
27299: PUSH
27300: LD_INT 2
27302: ARRAY
27303: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
27304: LD_ADDR_VAR 0 14
27308: PUSH
27309: LD_INT 0
27311: PUSH
27312: LD_INT 2
27314: PUSH
27315: LD_INT 3
27317: PUSH
27318: LD_INT 5
27320: PUSH
27321: EMPTY
27322: LIST
27323: LIST
27324: LIST
27325: LIST
27326: ST_TO_ADDR
// for i in tmp do
27327: LD_ADDR_VAR 0 8
27331: PUSH
27332: LD_VAR 0 14
27336: PUSH
27337: FOR_IN
27338: IFFALSE 27508
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
27340: LD_ADDR_VAR 0 9
27344: PUSH
27345: LD_VAR 0 10
27349: PPUSH
27350: LD_VAR 0 8
27354: PPUSH
27355: LD_INT 5
27357: PPUSH
27358: CALL_OW 272
27362: PUSH
27363: LD_VAR 0 11
27367: PPUSH
27368: LD_VAR 0 8
27372: PPUSH
27373: LD_INT 5
27375: PPUSH
27376: CALL_OW 273
27380: PUSH
27381: EMPTY
27382: LIST
27383: LIST
27384: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
27385: LD_VAR 0 9
27389: PUSH
27390: LD_INT 1
27392: ARRAY
27393: PPUSH
27394: LD_VAR 0 9
27398: PUSH
27399: LD_INT 2
27401: ARRAY
27402: PPUSH
27403: CALL_OW 488
27407: IFFALSE 27506
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
27409: LD_ADDR_VAR 0 4
27413: PUSH
27414: LD_VAR 0 9
27418: PUSH
27419: LD_INT 1
27421: ARRAY
27422: PPUSH
27423: LD_VAR 0 9
27427: PUSH
27428: LD_INT 2
27430: ARRAY
27431: PPUSH
27432: CALL_OW 546
27436: ST_TO_ADDR
// if hex [ 1 ] then
27437: LD_VAR 0 4
27441: PUSH
27442: LD_INT 1
27444: ARRAY
27445: IFFALSE 27449
// continue ;
27447: GO 27337
// h := hex [ 2 ] ;
27449: LD_ADDR_VAR 0 13
27453: PUSH
27454: LD_VAR 0 4
27458: PUSH
27459: LD_INT 2
27461: ARRAY
27462: ST_TO_ADDR
// if h + 7 < height then
27463: LD_VAR 0 13
27467: PUSH
27468: LD_INT 7
27470: PLUS
27471: PUSH
27472: LD_VAR 0 15
27476: LESS
27477: IFFALSE 27506
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
27479: LD_ADDR_VAR 0 18
27483: PUSH
27484: LD_INT 7
27486: PUSH
27487: LD_INT 28
27489: PUSH
27490: LD_INT 45
27492: PUSH
27493: EMPTY
27494: LIST
27495: LIST
27496: LIST
27497: PUSH
27498: LD_VAR 0 12
27502: ARRAY
27503: ST_TO_ADDR
// break ;
27504: GO 27508
// end ; end ; end ;
27506: GO 27337
27508: POP
27509: POP
// end ; if not weapon then
27510: LD_VAR 0 18
27514: NOT
27515: IFFALSE 27575
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
27517: LD_ADDR_VAR 0 5
27521: PUSH
27522: LD_VAR 0 5
27526: PUSH
27527: LD_INT 11
27529: PUSH
27530: LD_INT 30
27532: PUSH
27533: LD_INT 49
27535: PUSH
27536: EMPTY
27537: LIST
27538: LIST
27539: LIST
27540: DIFF
27541: ST_TO_ADDR
// if not list then
27542: LD_VAR 0 5
27546: NOT
27547: IFFALSE 27551
// exit ;
27549: GO 27693
// weapon := list [ rand ( 1 , list ) ] ;
27551: LD_ADDR_VAR 0 18
27555: PUSH
27556: LD_VAR 0 5
27560: PUSH
27561: LD_INT 1
27563: PPUSH
27564: LD_VAR 0 5
27568: PPUSH
27569: CALL_OW 12
27573: ARRAY
27574: ST_TO_ADDR
// end ; if weapon then
27575: LD_VAR 0 18
27579: IFFALSE 27693
// begin tmp := CostOfWeapon ( weapon ) ;
27581: LD_ADDR_VAR 0 14
27585: PUSH
27586: LD_VAR 0 18
27590: PPUSH
27591: CALL_OW 451
27595: ST_TO_ADDR
// j := GetBase ( tower ) ;
27596: LD_ADDR_VAR 0 9
27600: PUSH
27601: LD_VAR 0 1
27605: PPUSH
27606: CALL_OW 274
27610: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
27611: LD_VAR 0 9
27615: PPUSH
27616: LD_INT 1
27618: PPUSH
27619: CALL_OW 275
27623: PUSH
27624: LD_VAR 0 14
27628: PUSH
27629: LD_INT 1
27631: ARRAY
27632: GREATEREQUAL
27633: PUSH
27634: LD_VAR 0 9
27638: PPUSH
27639: LD_INT 2
27641: PPUSH
27642: CALL_OW 275
27646: PUSH
27647: LD_VAR 0 14
27651: PUSH
27652: LD_INT 2
27654: ARRAY
27655: GREATEREQUAL
27656: AND
27657: PUSH
27658: LD_VAR 0 9
27662: PPUSH
27663: LD_INT 3
27665: PPUSH
27666: CALL_OW 275
27670: PUSH
27671: LD_VAR 0 14
27675: PUSH
27676: LD_INT 3
27678: ARRAY
27679: GREATEREQUAL
27680: AND
27681: IFFALSE 27693
// result := weapon ;
27683: LD_ADDR_VAR 0 3
27687: PUSH
27688: LD_VAR 0 18
27692: ST_TO_ADDR
// end ; end ;
27693: LD_VAR 0 3
27697: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
27698: LD_INT 0
27700: PPUSH
27701: PPUSH
// result := true ;
27702: LD_ADDR_VAR 0 3
27706: PUSH
27707: LD_INT 1
27709: ST_TO_ADDR
// if array1 = array2 then
27710: LD_VAR 0 1
27714: PUSH
27715: LD_VAR 0 2
27719: EQUAL
27720: IFFALSE 27780
// begin for i = 1 to array1 do
27722: LD_ADDR_VAR 0 4
27726: PUSH
27727: DOUBLE
27728: LD_INT 1
27730: DEC
27731: ST_TO_ADDR
27732: LD_VAR 0 1
27736: PUSH
27737: FOR_TO
27738: IFFALSE 27776
// if array1 [ i ] <> array2 [ i ] then
27740: LD_VAR 0 1
27744: PUSH
27745: LD_VAR 0 4
27749: ARRAY
27750: PUSH
27751: LD_VAR 0 2
27755: PUSH
27756: LD_VAR 0 4
27760: ARRAY
27761: NONEQUAL
27762: IFFALSE 27774
// begin result := false ;
27764: LD_ADDR_VAR 0 3
27768: PUSH
27769: LD_INT 0
27771: ST_TO_ADDR
// break ;
27772: GO 27776
// end ;
27774: GO 27737
27776: POP
27777: POP
// end else
27778: GO 27788
// result := false ;
27780: LD_ADDR_VAR 0 3
27784: PUSH
27785: LD_INT 0
27787: ST_TO_ADDR
// end ;
27788: LD_VAR 0 3
27792: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
27793: LD_INT 0
27795: PPUSH
27796: PPUSH
27797: PPUSH
// pom := GetBase ( fac ) ;
27798: LD_ADDR_VAR 0 5
27802: PUSH
27803: LD_VAR 0 1
27807: PPUSH
27808: CALL_OW 274
27812: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
27813: LD_ADDR_VAR 0 4
27817: PUSH
27818: LD_VAR 0 2
27822: PUSH
27823: LD_INT 1
27825: ARRAY
27826: PPUSH
27827: LD_VAR 0 2
27831: PUSH
27832: LD_INT 2
27834: ARRAY
27835: PPUSH
27836: LD_VAR 0 2
27840: PUSH
27841: LD_INT 3
27843: ARRAY
27844: PPUSH
27845: LD_VAR 0 2
27849: PUSH
27850: LD_INT 4
27852: ARRAY
27853: PPUSH
27854: CALL_OW 449
27858: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27859: LD_ADDR_VAR 0 3
27863: PUSH
27864: LD_VAR 0 5
27868: PPUSH
27869: LD_INT 1
27871: PPUSH
27872: CALL_OW 275
27876: PUSH
27877: LD_VAR 0 4
27881: PUSH
27882: LD_INT 1
27884: ARRAY
27885: GREATEREQUAL
27886: PUSH
27887: LD_VAR 0 5
27891: PPUSH
27892: LD_INT 2
27894: PPUSH
27895: CALL_OW 275
27899: PUSH
27900: LD_VAR 0 4
27904: PUSH
27905: LD_INT 2
27907: ARRAY
27908: GREATEREQUAL
27909: AND
27910: PUSH
27911: LD_VAR 0 5
27915: PPUSH
27916: LD_INT 3
27918: PPUSH
27919: CALL_OW 275
27923: PUSH
27924: LD_VAR 0 4
27928: PUSH
27929: LD_INT 3
27931: ARRAY
27932: GREATEREQUAL
27933: AND
27934: ST_TO_ADDR
// end ;
27935: LD_VAR 0 3
27939: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27940: LD_INT 0
27942: PPUSH
27943: PPUSH
27944: PPUSH
27945: PPUSH
// pom := GetBase ( building ) ;
27946: LD_ADDR_VAR 0 3
27950: PUSH
27951: LD_VAR 0 1
27955: PPUSH
27956: CALL_OW 274
27960: ST_TO_ADDR
// if not pom then
27961: LD_VAR 0 3
27965: NOT
27966: IFFALSE 27970
// exit ;
27968: GO 28140
// btype := GetBType ( building ) ;
27970: LD_ADDR_VAR 0 5
27974: PUSH
27975: LD_VAR 0 1
27979: PPUSH
27980: CALL_OW 266
27984: ST_TO_ADDR
// if btype = b_armoury then
27985: LD_VAR 0 5
27989: PUSH
27990: LD_INT 4
27992: EQUAL
27993: IFFALSE 28003
// btype := b_barracks ;
27995: LD_ADDR_VAR 0 5
27999: PUSH
28000: LD_INT 5
28002: ST_TO_ADDR
// if btype = b_depot then
28003: LD_VAR 0 5
28007: PUSH
28008: LD_INT 0
28010: EQUAL
28011: IFFALSE 28021
// btype := b_warehouse ;
28013: LD_ADDR_VAR 0 5
28017: PUSH
28018: LD_INT 1
28020: ST_TO_ADDR
// if btype = b_workshop then
28021: LD_VAR 0 5
28025: PUSH
28026: LD_INT 2
28028: EQUAL
28029: IFFALSE 28039
// btype := b_factory ;
28031: LD_ADDR_VAR 0 5
28035: PUSH
28036: LD_INT 3
28038: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28039: LD_ADDR_VAR 0 4
28043: PUSH
28044: LD_VAR 0 5
28048: PPUSH
28049: LD_VAR 0 1
28053: PPUSH
28054: CALL_OW 248
28058: PPUSH
28059: CALL_OW 450
28063: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28064: LD_ADDR_VAR 0 2
28068: PUSH
28069: LD_VAR 0 3
28073: PPUSH
28074: LD_INT 1
28076: PPUSH
28077: CALL_OW 275
28081: PUSH
28082: LD_VAR 0 4
28086: PUSH
28087: LD_INT 1
28089: ARRAY
28090: GREATEREQUAL
28091: PUSH
28092: LD_VAR 0 3
28096: PPUSH
28097: LD_INT 2
28099: PPUSH
28100: CALL_OW 275
28104: PUSH
28105: LD_VAR 0 4
28109: PUSH
28110: LD_INT 2
28112: ARRAY
28113: GREATEREQUAL
28114: AND
28115: PUSH
28116: LD_VAR 0 3
28120: PPUSH
28121: LD_INT 3
28123: PPUSH
28124: CALL_OW 275
28128: PUSH
28129: LD_VAR 0 4
28133: PUSH
28134: LD_INT 3
28136: ARRAY
28137: GREATEREQUAL
28138: AND
28139: ST_TO_ADDR
// end ;
28140: LD_VAR 0 2
28144: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
28145: LD_INT 0
28147: PPUSH
28148: PPUSH
28149: PPUSH
// pom := GetBase ( building ) ;
28150: LD_ADDR_VAR 0 4
28154: PUSH
28155: LD_VAR 0 1
28159: PPUSH
28160: CALL_OW 274
28164: ST_TO_ADDR
// if not pom then
28165: LD_VAR 0 4
28169: NOT
28170: IFFALSE 28174
// exit ;
28172: GO 28275
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28174: LD_ADDR_VAR 0 5
28178: PUSH
28179: LD_VAR 0 2
28183: PPUSH
28184: LD_VAR 0 1
28188: PPUSH
28189: CALL_OW 248
28193: PPUSH
28194: CALL_OW 450
28198: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28199: LD_ADDR_VAR 0 3
28203: PUSH
28204: LD_VAR 0 4
28208: PPUSH
28209: LD_INT 1
28211: PPUSH
28212: CALL_OW 275
28216: PUSH
28217: LD_VAR 0 5
28221: PUSH
28222: LD_INT 1
28224: ARRAY
28225: GREATEREQUAL
28226: PUSH
28227: LD_VAR 0 4
28231: PPUSH
28232: LD_INT 2
28234: PPUSH
28235: CALL_OW 275
28239: PUSH
28240: LD_VAR 0 5
28244: PUSH
28245: LD_INT 2
28247: ARRAY
28248: GREATEREQUAL
28249: AND
28250: PUSH
28251: LD_VAR 0 4
28255: PPUSH
28256: LD_INT 3
28258: PPUSH
28259: CALL_OW 275
28263: PUSH
28264: LD_VAR 0 5
28268: PUSH
28269: LD_INT 3
28271: ARRAY
28272: GREATEREQUAL
28273: AND
28274: ST_TO_ADDR
// end ;
28275: LD_VAR 0 3
28279: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
28280: LD_INT 0
28282: PPUSH
28283: PPUSH
28284: PPUSH
28285: PPUSH
28286: PPUSH
28287: PPUSH
28288: PPUSH
28289: PPUSH
28290: PPUSH
28291: PPUSH
// result := false ;
28292: LD_ADDR_VAR 0 6
28296: PUSH
28297: LD_INT 0
28299: ST_TO_ADDR
// if not base or not btype or not x or not y then
28300: LD_VAR 0 1
28304: NOT
28305: PUSH
28306: LD_VAR 0 2
28310: NOT
28311: OR
28312: PUSH
28313: LD_VAR 0 3
28317: NOT
28318: OR
28319: PUSH
28320: LD_VAR 0 4
28324: NOT
28325: OR
28326: IFFALSE 28330
// exit ;
28328: GO 28939
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
28330: LD_ADDR_VAR 0 12
28334: PUSH
28335: LD_VAR 0 2
28339: PPUSH
28340: LD_VAR 0 3
28344: PPUSH
28345: LD_VAR 0 4
28349: PPUSH
28350: LD_VAR 0 5
28354: PPUSH
28355: LD_VAR 0 1
28359: PUSH
28360: LD_INT 1
28362: ARRAY
28363: PPUSH
28364: CALL_OW 248
28368: PPUSH
28369: LD_INT 0
28371: PPUSH
28372: CALL 29776 0 6
28376: ST_TO_ADDR
// if not hexes then
28377: LD_VAR 0 12
28381: NOT
28382: IFFALSE 28386
// exit ;
28384: GO 28939
// for i = 1 to hexes do
28386: LD_ADDR_VAR 0 7
28390: PUSH
28391: DOUBLE
28392: LD_INT 1
28394: DEC
28395: ST_TO_ADDR
28396: LD_VAR 0 12
28400: PUSH
28401: FOR_TO
28402: IFFALSE 28937
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28404: LD_ADDR_VAR 0 11
28408: PUSH
28409: LD_VAR 0 12
28413: PUSH
28414: LD_VAR 0 7
28418: ARRAY
28419: PUSH
28420: LD_INT 1
28422: ARRAY
28423: PPUSH
28424: LD_VAR 0 12
28428: PUSH
28429: LD_VAR 0 7
28433: ARRAY
28434: PUSH
28435: LD_INT 2
28437: ARRAY
28438: PPUSH
28439: CALL_OW 428
28443: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
28444: LD_VAR 0 12
28448: PUSH
28449: LD_VAR 0 7
28453: ARRAY
28454: PUSH
28455: LD_INT 1
28457: ARRAY
28458: PPUSH
28459: LD_VAR 0 12
28463: PUSH
28464: LD_VAR 0 7
28468: ARRAY
28469: PUSH
28470: LD_INT 2
28472: ARRAY
28473: PPUSH
28474: CALL_OW 351
28478: PUSH
28479: LD_VAR 0 12
28483: PUSH
28484: LD_VAR 0 7
28488: ARRAY
28489: PUSH
28490: LD_INT 1
28492: ARRAY
28493: PPUSH
28494: LD_VAR 0 12
28498: PUSH
28499: LD_VAR 0 7
28503: ARRAY
28504: PUSH
28505: LD_INT 2
28507: ARRAY
28508: PPUSH
28509: CALL_OW 488
28513: NOT
28514: OR
28515: PUSH
28516: LD_VAR 0 11
28520: PPUSH
28521: CALL_OW 247
28525: PUSH
28526: LD_INT 3
28528: EQUAL
28529: OR
28530: IFFALSE 28536
// exit ;
28532: POP
28533: POP
28534: GO 28939
// if not tmp or not tmp in base then
28536: LD_VAR 0 11
28540: NOT
28541: PUSH
28542: LD_VAR 0 11
28546: PUSH
28547: LD_VAR 0 1
28551: IN
28552: NOT
28553: OR
28554: IFFALSE 28558
// continue ;
28556: GO 28401
// result := true ;
28558: LD_ADDR_VAR 0 6
28562: PUSH
28563: LD_INT 1
28565: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28566: LD_ADDR_VAR 0 15
28570: PUSH
28571: LD_VAR 0 1
28575: PPUSH
28576: LD_INT 22
28578: PUSH
28579: LD_VAR 0 11
28583: PPUSH
28584: CALL_OW 255
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: PUSH
28593: LD_INT 2
28595: PUSH
28596: LD_INT 30
28598: PUSH
28599: LD_INT 0
28601: PUSH
28602: EMPTY
28603: LIST
28604: LIST
28605: PUSH
28606: LD_INT 30
28608: PUSH
28609: LD_INT 1
28611: PUSH
28612: EMPTY
28613: LIST
28614: LIST
28615: PUSH
28616: EMPTY
28617: LIST
28618: LIST
28619: LIST
28620: PUSH
28621: EMPTY
28622: LIST
28623: LIST
28624: PPUSH
28625: CALL_OW 72
28629: ST_TO_ADDR
// if dep then
28630: LD_VAR 0 15
28634: IFFALSE 28770
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
28636: LD_ADDR_VAR 0 14
28640: PUSH
28641: LD_VAR 0 15
28645: PUSH
28646: LD_INT 1
28648: ARRAY
28649: PPUSH
28650: CALL_OW 250
28654: PPUSH
28655: LD_VAR 0 15
28659: PUSH
28660: LD_INT 1
28662: ARRAY
28663: PPUSH
28664: CALL_OW 254
28668: PPUSH
28669: LD_INT 5
28671: PPUSH
28672: CALL_OW 272
28676: PUSH
28677: LD_VAR 0 15
28681: PUSH
28682: LD_INT 1
28684: ARRAY
28685: PPUSH
28686: CALL_OW 251
28690: PPUSH
28691: LD_VAR 0 15
28695: PUSH
28696: LD_INT 1
28698: ARRAY
28699: PPUSH
28700: CALL_OW 254
28704: PPUSH
28705: LD_INT 5
28707: PPUSH
28708: CALL_OW 273
28712: PUSH
28713: EMPTY
28714: LIST
28715: LIST
28716: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
28717: LD_VAR 0 14
28721: PUSH
28722: LD_INT 1
28724: ARRAY
28725: PPUSH
28726: LD_VAR 0 14
28730: PUSH
28731: LD_INT 2
28733: ARRAY
28734: PPUSH
28735: CALL_OW 488
28739: IFFALSE 28770
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
28741: LD_VAR 0 11
28745: PPUSH
28746: LD_VAR 0 14
28750: PUSH
28751: LD_INT 1
28753: ARRAY
28754: PPUSH
28755: LD_VAR 0 14
28759: PUSH
28760: LD_INT 2
28762: ARRAY
28763: PPUSH
28764: CALL_OW 111
// continue ;
28768: GO 28401
// end ; end ; r := GetDir ( tmp ) ;
28770: LD_ADDR_VAR 0 13
28774: PUSH
28775: LD_VAR 0 11
28779: PPUSH
28780: CALL_OW 254
28784: ST_TO_ADDR
// if r = 5 then
28785: LD_VAR 0 13
28789: PUSH
28790: LD_INT 5
28792: EQUAL
28793: IFFALSE 28803
// r := 0 ;
28795: LD_ADDR_VAR 0 13
28799: PUSH
28800: LD_INT 0
28802: ST_TO_ADDR
// for j = r to 5 do
28803: LD_ADDR_VAR 0 8
28807: PUSH
28808: DOUBLE
28809: LD_VAR 0 13
28813: DEC
28814: ST_TO_ADDR
28815: LD_INT 5
28817: PUSH
28818: FOR_TO
28819: IFFALSE 28933
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
28821: LD_ADDR_VAR 0 9
28825: PUSH
28826: LD_VAR 0 11
28830: PPUSH
28831: CALL_OW 250
28835: PPUSH
28836: LD_VAR 0 8
28840: PPUSH
28841: LD_INT 2
28843: PPUSH
28844: CALL_OW 272
28848: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
28849: LD_ADDR_VAR 0 10
28853: PUSH
28854: LD_VAR 0 11
28858: PPUSH
28859: CALL_OW 251
28863: PPUSH
28864: LD_VAR 0 8
28868: PPUSH
28869: LD_INT 2
28871: PPUSH
28872: CALL_OW 273
28876: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28877: LD_VAR 0 9
28881: PPUSH
28882: LD_VAR 0 10
28886: PPUSH
28887: CALL_OW 488
28891: PUSH
28892: LD_VAR 0 9
28896: PPUSH
28897: LD_VAR 0 10
28901: PPUSH
28902: CALL_OW 428
28906: NOT
28907: AND
28908: IFFALSE 28931
// begin ComMoveXY ( tmp , _x , _y ) ;
28910: LD_VAR 0 11
28914: PPUSH
28915: LD_VAR 0 9
28919: PPUSH
28920: LD_VAR 0 10
28924: PPUSH
28925: CALL_OW 111
// break ;
28929: GO 28933
// end ; end ;
28931: GO 28818
28933: POP
28934: POP
// end ;
28935: GO 28401
28937: POP
28938: POP
// end ;
28939: LD_VAR 0 6
28943: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
28944: LD_INT 0
28946: PPUSH
28947: PPUSH
28948: PPUSH
28949: PPUSH
28950: PPUSH
28951: PPUSH
28952: PPUSH
28953: PPUSH
28954: PPUSH
28955: PPUSH
// result := false ;
28956: LD_ADDR_VAR 0 6
28960: PUSH
28961: LD_INT 0
28963: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28964: LD_VAR 0 1
28968: NOT
28969: PUSH
28970: LD_VAR 0 1
28974: PPUSH
28975: CALL_OW 266
28979: PUSH
28980: LD_INT 0
28982: PUSH
28983: LD_INT 1
28985: PUSH
28986: EMPTY
28987: LIST
28988: LIST
28989: IN
28990: NOT
28991: OR
28992: PUSH
28993: LD_VAR 0 2
28997: NOT
28998: OR
28999: PUSH
29000: LD_VAR 0 5
29004: PUSH
29005: LD_INT 0
29007: PUSH
29008: LD_INT 1
29010: PUSH
29011: LD_INT 2
29013: PUSH
29014: LD_INT 3
29016: PUSH
29017: LD_INT 4
29019: PUSH
29020: LD_INT 5
29022: PUSH
29023: EMPTY
29024: LIST
29025: LIST
29026: LIST
29027: LIST
29028: LIST
29029: LIST
29030: IN
29031: NOT
29032: OR
29033: PUSH
29034: LD_VAR 0 3
29038: PPUSH
29039: LD_VAR 0 4
29043: PPUSH
29044: CALL_OW 488
29048: NOT
29049: OR
29050: IFFALSE 29054
// exit ;
29052: GO 29771
// pom := GetBase ( depot ) ;
29054: LD_ADDR_VAR 0 10
29058: PUSH
29059: LD_VAR 0 1
29063: PPUSH
29064: CALL_OW 274
29068: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
29069: LD_ADDR_VAR 0 11
29073: PUSH
29074: LD_VAR 0 2
29078: PPUSH
29079: LD_VAR 0 1
29083: PPUSH
29084: CALL_OW 248
29088: PPUSH
29089: CALL_OW 450
29093: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
29094: LD_VAR 0 10
29098: PPUSH
29099: LD_INT 1
29101: PPUSH
29102: CALL_OW 275
29106: PUSH
29107: LD_VAR 0 11
29111: PUSH
29112: LD_INT 1
29114: ARRAY
29115: GREATEREQUAL
29116: PUSH
29117: LD_VAR 0 10
29121: PPUSH
29122: LD_INT 2
29124: PPUSH
29125: CALL_OW 275
29129: PUSH
29130: LD_VAR 0 11
29134: PUSH
29135: LD_INT 2
29137: ARRAY
29138: GREATEREQUAL
29139: AND
29140: PUSH
29141: LD_VAR 0 10
29145: PPUSH
29146: LD_INT 3
29148: PPUSH
29149: CALL_OW 275
29153: PUSH
29154: LD_VAR 0 11
29158: PUSH
29159: LD_INT 3
29161: ARRAY
29162: GREATEREQUAL
29163: AND
29164: NOT
29165: IFFALSE 29169
// exit ;
29167: GO 29771
// if GetBType ( depot ) = b_depot then
29169: LD_VAR 0 1
29173: PPUSH
29174: CALL_OW 266
29178: PUSH
29179: LD_INT 0
29181: EQUAL
29182: IFFALSE 29194
// dist := 28 else
29184: LD_ADDR_VAR 0 14
29188: PUSH
29189: LD_INT 28
29191: ST_TO_ADDR
29192: GO 29202
// dist := 36 ;
29194: LD_ADDR_VAR 0 14
29198: PUSH
29199: LD_INT 36
29201: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
29202: LD_VAR 0 1
29206: PPUSH
29207: LD_VAR 0 3
29211: PPUSH
29212: LD_VAR 0 4
29216: PPUSH
29217: CALL_OW 297
29221: PUSH
29222: LD_VAR 0 14
29226: GREATER
29227: IFFALSE 29231
// exit ;
29229: GO 29771
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
29231: LD_ADDR_VAR 0 12
29235: PUSH
29236: LD_VAR 0 2
29240: PPUSH
29241: LD_VAR 0 3
29245: PPUSH
29246: LD_VAR 0 4
29250: PPUSH
29251: LD_VAR 0 5
29255: PPUSH
29256: LD_VAR 0 1
29260: PPUSH
29261: CALL_OW 248
29265: PPUSH
29266: LD_INT 0
29268: PPUSH
29269: CALL 29776 0 6
29273: ST_TO_ADDR
// if not hexes then
29274: LD_VAR 0 12
29278: NOT
29279: IFFALSE 29283
// exit ;
29281: GO 29771
// hex := GetHexInfo ( x , y ) ;
29283: LD_ADDR_VAR 0 15
29287: PUSH
29288: LD_VAR 0 3
29292: PPUSH
29293: LD_VAR 0 4
29297: PPUSH
29298: CALL_OW 546
29302: ST_TO_ADDR
// if hex [ 1 ] then
29303: LD_VAR 0 15
29307: PUSH
29308: LD_INT 1
29310: ARRAY
29311: IFFALSE 29315
// exit ;
29313: GO 29771
// height := hex [ 2 ] ;
29315: LD_ADDR_VAR 0 13
29319: PUSH
29320: LD_VAR 0 15
29324: PUSH
29325: LD_INT 2
29327: ARRAY
29328: ST_TO_ADDR
// for i = 1 to hexes do
29329: LD_ADDR_VAR 0 7
29333: PUSH
29334: DOUBLE
29335: LD_INT 1
29337: DEC
29338: ST_TO_ADDR
29339: LD_VAR 0 12
29343: PUSH
29344: FOR_TO
29345: IFFALSE 29675
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
29347: LD_VAR 0 12
29351: PUSH
29352: LD_VAR 0 7
29356: ARRAY
29357: PUSH
29358: LD_INT 1
29360: ARRAY
29361: PPUSH
29362: LD_VAR 0 12
29366: PUSH
29367: LD_VAR 0 7
29371: ARRAY
29372: PUSH
29373: LD_INT 2
29375: ARRAY
29376: PPUSH
29377: CALL_OW 488
29381: NOT
29382: PUSH
29383: LD_VAR 0 12
29387: PUSH
29388: LD_VAR 0 7
29392: ARRAY
29393: PUSH
29394: LD_INT 1
29396: ARRAY
29397: PPUSH
29398: LD_VAR 0 12
29402: PUSH
29403: LD_VAR 0 7
29407: ARRAY
29408: PUSH
29409: LD_INT 2
29411: ARRAY
29412: PPUSH
29413: CALL_OW 428
29417: PUSH
29418: LD_INT 0
29420: GREATER
29421: OR
29422: PUSH
29423: LD_VAR 0 12
29427: PUSH
29428: LD_VAR 0 7
29432: ARRAY
29433: PUSH
29434: LD_INT 1
29436: ARRAY
29437: PPUSH
29438: LD_VAR 0 12
29442: PUSH
29443: LD_VAR 0 7
29447: ARRAY
29448: PUSH
29449: LD_INT 2
29451: ARRAY
29452: PPUSH
29453: CALL_OW 351
29457: OR
29458: IFFALSE 29464
// exit ;
29460: POP
29461: POP
29462: GO 29771
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29464: LD_ADDR_VAR 0 8
29468: PUSH
29469: LD_VAR 0 12
29473: PUSH
29474: LD_VAR 0 7
29478: ARRAY
29479: PUSH
29480: LD_INT 1
29482: ARRAY
29483: PPUSH
29484: LD_VAR 0 12
29488: PUSH
29489: LD_VAR 0 7
29493: ARRAY
29494: PUSH
29495: LD_INT 2
29497: ARRAY
29498: PPUSH
29499: CALL_OW 546
29503: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
29504: LD_VAR 0 8
29508: PUSH
29509: LD_INT 1
29511: ARRAY
29512: PUSH
29513: LD_VAR 0 8
29517: PUSH
29518: LD_INT 2
29520: ARRAY
29521: PUSH
29522: LD_VAR 0 13
29526: PUSH
29527: LD_INT 2
29529: PLUS
29530: GREATER
29531: OR
29532: PUSH
29533: LD_VAR 0 8
29537: PUSH
29538: LD_INT 2
29540: ARRAY
29541: PUSH
29542: LD_VAR 0 13
29546: PUSH
29547: LD_INT 2
29549: MINUS
29550: LESS
29551: OR
29552: PUSH
29553: LD_VAR 0 8
29557: PUSH
29558: LD_INT 3
29560: ARRAY
29561: PUSH
29562: LD_INT 0
29564: PUSH
29565: LD_INT 8
29567: PUSH
29568: LD_INT 9
29570: PUSH
29571: LD_INT 10
29573: PUSH
29574: LD_INT 11
29576: PUSH
29577: LD_INT 12
29579: PUSH
29580: LD_INT 13
29582: PUSH
29583: LD_INT 16
29585: PUSH
29586: LD_INT 17
29588: PUSH
29589: LD_INT 18
29591: PUSH
29592: LD_INT 19
29594: PUSH
29595: LD_INT 20
29597: PUSH
29598: LD_INT 21
29600: PUSH
29601: EMPTY
29602: LIST
29603: LIST
29604: LIST
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: LIST
29611: LIST
29612: LIST
29613: LIST
29614: LIST
29615: IN
29616: NOT
29617: OR
29618: PUSH
29619: LD_VAR 0 8
29623: PUSH
29624: LD_INT 5
29626: ARRAY
29627: NOT
29628: OR
29629: PUSH
29630: LD_VAR 0 8
29634: PUSH
29635: LD_INT 6
29637: ARRAY
29638: PUSH
29639: LD_INT 1
29641: PUSH
29642: LD_INT 2
29644: PUSH
29645: LD_INT 7
29647: PUSH
29648: LD_INT 9
29650: PUSH
29651: LD_INT 10
29653: PUSH
29654: LD_INT 11
29656: PUSH
29657: EMPTY
29658: LIST
29659: LIST
29660: LIST
29661: LIST
29662: LIST
29663: LIST
29664: IN
29665: NOT
29666: OR
29667: IFFALSE 29673
// exit ;
29669: POP
29670: POP
29671: GO 29771
// end ;
29673: GO 29344
29675: POP
29676: POP
// side := GetSide ( depot ) ;
29677: LD_ADDR_VAR 0 9
29681: PUSH
29682: LD_VAR 0 1
29686: PPUSH
29687: CALL_OW 255
29691: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
29692: LD_VAR 0 9
29696: PPUSH
29697: LD_VAR 0 3
29701: PPUSH
29702: LD_VAR 0 4
29706: PPUSH
29707: LD_INT 20
29709: PPUSH
29710: CALL 22425 0 4
29714: PUSH
29715: LD_INT 4
29717: ARRAY
29718: IFFALSE 29722
// exit ;
29720: GO 29771
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
29722: LD_VAR 0 2
29726: PUSH
29727: LD_INT 29
29729: PUSH
29730: LD_INT 30
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: IN
29737: PUSH
29738: LD_VAR 0 3
29742: PPUSH
29743: LD_VAR 0 4
29747: PPUSH
29748: LD_VAR 0 9
29752: PPUSH
29753: CALL_OW 440
29757: NOT
29758: AND
29759: IFFALSE 29763
// exit ;
29761: GO 29771
// result := true ;
29763: LD_ADDR_VAR 0 6
29767: PUSH
29768: LD_INT 1
29770: ST_TO_ADDR
// end ;
29771: LD_VAR 0 6
29775: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
29776: LD_INT 0
29778: PPUSH
29779: PPUSH
29780: PPUSH
29781: PPUSH
29782: PPUSH
29783: PPUSH
29784: PPUSH
29785: PPUSH
29786: PPUSH
29787: PPUSH
29788: PPUSH
29789: PPUSH
29790: PPUSH
29791: PPUSH
29792: PPUSH
29793: PPUSH
29794: PPUSH
29795: PPUSH
29796: PPUSH
29797: PPUSH
29798: PPUSH
29799: PPUSH
29800: PPUSH
29801: PPUSH
29802: PPUSH
29803: PPUSH
29804: PPUSH
29805: PPUSH
29806: PPUSH
29807: PPUSH
29808: PPUSH
29809: PPUSH
29810: PPUSH
29811: PPUSH
29812: PPUSH
29813: PPUSH
29814: PPUSH
29815: PPUSH
29816: PPUSH
29817: PPUSH
29818: PPUSH
29819: PPUSH
29820: PPUSH
29821: PPUSH
29822: PPUSH
29823: PPUSH
29824: PPUSH
29825: PPUSH
29826: PPUSH
29827: PPUSH
29828: PPUSH
29829: PPUSH
29830: PPUSH
29831: PPUSH
29832: PPUSH
29833: PPUSH
29834: PPUSH
29835: PPUSH
// result = [ ] ;
29836: LD_ADDR_VAR 0 7
29840: PUSH
29841: EMPTY
29842: ST_TO_ADDR
// temp_list = [ ] ;
29843: LD_ADDR_VAR 0 9
29847: PUSH
29848: EMPTY
29849: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29850: LD_VAR 0 4
29854: PUSH
29855: LD_INT 0
29857: PUSH
29858: LD_INT 1
29860: PUSH
29861: LD_INT 2
29863: PUSH
29864: LD_INT 3
29866: PUSH
29867: LD_INT 4
29869: PUSH
29870: LD_INT 5
29872: PUSH
29873: EMPTY
29874: LIST
29875: LIST
29876: LIST
29877: LIST
29878: LIST
29879: LIST
29880: IN
29881: NOT
29882: PUSH
29883: LD_VAR 0 1
29887: PUSH
29888: LD_INT 0
29890: PUSH
29891: LD_INT 1
29893: PUSH
29894: EMPTY
29895: LIST
29896: LIST
29897: IN
29898: PUSH
29899: LD_VAR 0 5
29903: PUSH
29904: LD_INT 1
29906: PUSH
29907: LD_INT 2
29909: PUSH
29910: LD_INT 3
29912: PUSH
29913: EMPTY
29914: LIST
29915: LIST
29916: LIST
29917: IN
29918: NOT
29919: AND
29920: OR
29921: IFFALSE 29925
// exit ;
29923: GO 48316
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29925: LD_VAR 0 1
29929: PUSH
29930: LD_INT 6
29932: PUSH
29933: LD_INT 7
29935: PUSH
29936: LD_INT 8
29938: PUSH
29939: LD_INT 13
29941: PUSH
29942: LD_INT 12
29944: PUSH
29945: LD_INT 15
29947: PUSH
29948: LD_INT 11
29950: PUSH
29951: LD_INT 14
29953: PUSH
29954: LD_INT 10
29956: PUSH
29957: EMPTY
29958: LIST
29959: LIST
29960: LIST
29961: LIST
29962: LIST
29963: LIST
29964: LIST
29965: LIST
29966: LIST
29967: IN
29968: IFFALSE 29978
// btype = b_lab ;
29970: LD_ADDR_VAR 0 1
29974: PUSH
29975: LD_INT 6
29977: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29978: LD_VAR 0 6
29982: PUSH
29983: LD_INT 0
29985: PUSH
29986: LD_INT 1
29988: PUSH
29989: LD_INT 2
29991: PUSH
29992: EMPTY
29993: LIST
29994: LIST
29995: LIST
29996: IN
29997: NOT
29998: PUSH
29999: LD_VAR 0 1
30003: PUSH
30004: LD_INT 0
30006: PUSH
30007: LD_INT 1
30009: PUSH
30010: LD_INT 2
30012: PUSH
30013: LD_INT 3
30015: PUSH
30016: LD_INT 6
30018: PUSH
30019: LD_INT 36
30021: PUSH
30022: LD_INT 4
30024: PUSH
30025: LD_INT 5
30027: PUSH
30028: LD_INT 31
30030: PUSH
30031: LD_INT 32
30033: PUSH
30034: LD_INT 33
30036: PUSH
30037: EMPTY
30038: LIST
30039: LIST
30040: LIST
30041: LIST
30042: LIST
30043: LIST
30044: LIST
30045: LIST
30046: LIST
30047: LIST
30048: LIST
30049: IN
30050: NOT
30051: PUSH
30052: LD_VAR 0 6
30056: PUSH
30057: LD_INT 1
30059: EQUAL
30060: AND
30061: OR
30062: PUSH
30063: LD_VAR 0 1
30067: PUSH
30068: LD_INT 2
30070: PUSH
30071: LD_INT 3
30073: PUSH
30074: EMPTY
30075: LIST
30076: LIST
30077: IN
30078: NOT
30079: PUSH
30080: LD_VAR 0 6
30084: PUSH
30085: LD_INT 2
30087: EQUAL
30088: AND
30089: OR
30090: IFFALSE 30100
// mode = 0 ;
30092: LD_ADDR_VAR 0 6
30096: PUSH
30097: LD_INT 0
30099: ST_TO_ADDR
// case mode of 0 :
30100: LD_VAR 0 6
30104: PUSH
30105: LD_INT 0
30107: DOUBLE
30108: EQUAL
30109: IFTRUE 30113
30111: GO 41566
30113: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
30114: LD_ADDR_VAR 0 11
30118: PUSH
30119: LD_INT 0
30121: PUSH
30122: LD_INT 0
30124: PUSH
30125: EMPTY
30126: LIST
30127: LIST
30128: PUSH
30129: LD_INT 0
30131: PUSH
30132: LD_INT 1
30134: NEG
30135: PUSH
30136: EMPTY
30137: LIST
30138: LIST
30139: PUSH
30140: LD_INT 1
30142: PUSH
30143: LD_INT 0
30145: PUSH
30146: EMPTY
30147: LIST
30148: LIST
30149: PUSH
30150: LD_INT 1
30152: PUSH
30153: LD_INT 1
30155: PUSH
30156: EMPTY
30157: LIST
30158: LIST
30159: PUSH
30160: LD_INT 0
30162: PUSH
30163: LD_INT 1
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 1
30172: NEG
30173: PUSH
30174: LD_INT 0
30176: PUSH
30177: EMPTY
30178: LIST
30179: LIST
30180: PUSH
30181: LD_INT 1
30183: NEG
30184: PUSH
30185: LD_INT 1
30187: NEG
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: PUSH
30193: LD_INT 1
30195: NEG
30196: PUSH
30197: LD_INT 2
30199: NEG
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: LD_INT 0
30207: PUSH
30208: LD_INT 2
30210: NEG
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PUSH
30216: LD_INT 1
30218: PUSH
30219: LD_INT 1
30221: NEG
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: PUSH
30227: LD_INT 1
30229: PUSH
30230: LD_INT 2
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: PUSH
30237: LD_INT 0
30239: PUSH
30240: LD_INT 2
30242: PUSH
30243: EMPTY
30244: LIST
30245: LIST
30246: PUSH
30247: LD_INT 1
30249: NEG
30250: PUSH
30251: LD_INT 1
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: PUSH
30258: LD_INT 1
30260: PUSH
30261: LD_INT 3
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PUSH
30268: LD_INT 0
30270: PUSH
30271: LD_INT 3
30273: PUSH
30274: EMPTY
30275: LIST
30276: LIST
30277: PUSH
30278: LD_INT 1
30280: NEG
30281: PUSH
30282: LD_INT 2
30284: PUSH
30285: EMPTY
30286: LIST
30287: LIST
30288: PUSH
30289: EMPTY
30290: LIST
30291: LIST
30292: LIST
30293: LIST
30294: LIST
30295: LIST
30296: LIST
30297: LIST
30298: LIST
30299: LIST
30300: LIST
30301: LIST
30302: LIST
30303: LIST
30304: LIST
30305: LIST
30306: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30307: LD_ADDR_VAR 0 12
30311: PUSH
30312: LD_INT 0
30314: PUSH
30315: LD_INT 0
30317: PUSH
30318: EMPTY
30319: LIST
30320: LIST
30321: PUSH
30322: LD_INT 0
30324: PUSH
30325: LD_INT 1
30327: NEG
30328: PUSH
30329: EMPTY
30330: LIST
30331: LIST
30332: PUSH
30333: LD_INT 1
30335: PUSH
30336: LD_INT 0
30338: PUSH
30339: EMPTY
30340: LIST
30341: LIST
30342: PUSH
30343: LD_INT 1
30345: PUSH
30346: LD_INT 1
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: PUSH
30353: LD_INT 0
30355: PUSH
30356: LD_INT 1
30358: PUSH
30359: EMPTY
30360: LIST
30361: LIST
30362: PUSH
30363: LD_INT 1
30365: NEG
30366: PUSH
30367: LD_INT 0
30369: PUSH
30370: EMPTY
30371: LIST
30372: LIST
30373: PUSH
30374: LD_INT 1
30376: NEG
30377: PUSH
30378: LD_INT 1
30380: NEG
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: PUSH
30386: LD_INT 1
30388: PUSH
30389: LD_INT 1
30391: NEG
30392: PUSH
30393: EMPTY
30394: LIST
30395: LIST
30396: PUSH
30397: LD_INT 2
30399: PUSH
30400: LD_INT 0
30402: PUSH
30403: EMPTY
30404: LIST
30405: LIST
30406: PUSH
30407: LD_INT 2
30409: PUSH
30410: LD_INT 1
30412: PUSH
30413: EMPTY
30414: LIST
30415: LIST
30416: PUSH
30417: LD_INT 1
30419: NEG
30420: PUSH
30421: LD_INT 1
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: PUSH
30428: LD_INT 2
30430: NEG
30431: PUSH
30432: LD_INT 0
30434: PUSH
30435: EMPTY
30436: LIST
30437: LIST
30438: PUSH
30439: LD_INT 2
30441: NEG
30442: PUSH
30443: LD_INT 1
30445: NEG
30446: PUSH
30447: EMPTY
30448: LIST
30449: LIST
30450: PUSH
30451: LD_INT 2
30453: NEG
30454: PUSH
30455: LD_INT 1
30457: PUSH
30458: EMPTY
30459: LIST
30460: LIST
30461: PUSH
30462: LD_INT 3
30464: NEG
30465: PUSH
30466: LD_INT 0
30468: PUSH
30469: EMPTY
30470: LIST
30471: LIST
30472: PUSH
30473: LD_INT 3
30475: NEG
30476: PUSH
30477: LD_INT 1
30479: NEG
30480: PUSH
30481: EMPTY
30482: LIST
30483: LIST
30484: PUSH
30485: EMPTY
30486: LIST
30487: LIST
30488: LIST
30489: LIST
30490: LIST
30491: LIST
30492: LIST
30493: LIST
30494: LIST
30495: LIST
30496: LIST
30497: LIST
30498: LIST
30499: LIST
30500: LIST
30501: LIST
30502: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30503: LD_ADDR_VAR 0 13
30507: PUSH
30508: LD_INT 0
30510: PUSH
30511: LD_INT 0
30513: PUSH
30514: EMPTY
30515: LIST
30516: LIST
30517: PUSH
30518: LD_INT 0
30520: PUSH
30521: LD_INT 1
30523: NEG
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: LD_INT 1
30531: PUSH
30532: LD_INT 0
30534: PUSH
30535: EMPTY
30536: LIST
30537: LIST
30538: PUSH
30539: LD_INT 1
30541: PUSH
30542: LD_INT 1
30544: PUSH
30545: EMPTY
30546: LIST
30547: LIST
30548: PUSH
30549: LD_INT 0
30551: PUSH
30552: LD_INT 1
30554: PUSH
30555: EMPTY
30556: LIST
30557: LIST
30558: PUSH
30559: LD_INT 1
30561: NEG
30562: PUSH
30563: LD_INT 0
30565: PUSH
30566: EMPTY
30567: LIST
30568: LIST
30569: PUSH
30570: LD_INT 1
30572: NEG
30573: PUSH
30574: LD_INT 1
30576: NEG
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PUSH
30582: LD_INT 1
30584: NEG
30585: PUSH
30586: LD_INT 2
30588: NEG
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 2
30596: PUSH
30597: LD_INT 1
30599: PUSH
30600: EMPTY
30601: LIST
30602: LIST
30603: PUSH
30604: LD_INT 2
30606: PUSH
30607: LD_INT 2
30609: PUSH
30610: EMPTY
30611: LIST
30612: LIST
30613: PUSH
30614: LD_INT 1
30616: PUSH
30617: LD_INT 2
30619: PUSH
30620: EMPTY
30621: LIST
30622: LIST
30623: PUSH
30624: LD_INT 2
30626: NEG
30627: PUSH
30628: LD_INT 1
30630: NEG
30631: PUSH
30632: EMPTY
30633: LIST
30634: LIST
30635: PUSH
30636: LD_INT 2
30638: NEG
30639: PUSH
30640: LD_INT 2
30642: NEG
30643: PUSH
30644: EMPTY
30645: LIST
30646: LIST
30647: PUSH
30648: LD_INT 2
30650: NEG
30651: PUSH
30652: LD_INT 3
30654: NEG
30655: PUSH
30656: EMPTY
30657: LIST
30658: LIST
30659: PUSH
30660: LD_INT 3
30662: NEG
30663: PUSH
30664: LD_INT 2
30666: NEG
30667: PUSH
30668: EMPTY
30669: LIST
30670: LIST
30671: PUSH
30672: LD_INT 3
30674: NEG
30675: PUSH
30676: LD_INT 3
30678: NEG
30679: PUSH
30680: EMPTY
30681: LIST
30682: LIST
30683: PUSH
30684: EMPTY
30685: LIST
30686: LIST
30687: LIST
30688: LIST
30689: LIST
30690: LIST
30691: LIST
30692: LIST
30693: LIST
30694: LIST
30695: LIST
30696: LIST
30697: LIST
30698: LIST
30699: LIST
30700: LIST
30701: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
30702: LD_ADDR_VAR 0 14
30706: PUSH
30707: LD_INT 0
30709: PUSH
30710: LD_INT 0
30712: PUSH
30713: EMPTY
30714: LIST
30715: LIST
30716: PUSH
30717: LD_INT 0
30719: PUSH
30720: LD_INT 1
30722: NEG
30723: PUSH
30724: EMPTY
30725: LIST
30726: LIST
30727: PUSH
30728: LD_INT 1
30730: PUSH
30731: LD_INT 0
30733: PUSH
30734: EMPTY
30735: LIST
30736: LIST
30737: PUSH
30738: LD_INT 1
30740: PUSH
30741: LD_INT 1
30743: PUSH
30744: EMPTY
30745: LIST
30746: LIST
30747: PUSH
30748: LD_INT 0
30750: PUSH
30751: LD_INT 1
30753: PUSH
30754: EMPTY
30755: LIST
30756: LIST
30757: PUSH
30758: LD_INT 1
30760: NEG
30761: PUSH
30762: LD_INT 0
30764: PUSH
30765: EMPTY
30766: LIST
30767: LIST
30768: PUSH
30769: LD_INT 1
30771: NEG
30772: PUSH
30773: LD_INT 1
30775: NEG
30776: PUSH
30777: EMPTY
30778: LIST
30779: LIST
30780: PUSH
30781: LD_INT 1
30783: NEG
30784: PUSH
30785: LD_INT 2
30787: NEG
30788: PUSH
30789: EMPTY
30790: LIST
30791: LIST
30792: PUSH
30793: LD_INT 0
30795: PUSH
30796: LD_INT 2
30798: NEG
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PUSH
30804: LD_INT 1
30806: PUSH
30807: LD_INT 1
30809: NEG
30810: PUSH
30811: EMPTY
30812: LIST
30813: LIST
30814: PUSH
30815: LD_INT 1
30817: PUSH
30818: LD_INT 2
30820: PUSH
30821: EMPTY
30822: LIST
30823: LIST
30824: PUSH
30825: LD_INT 0
30827: PUSH
30828: LD_INT 2
30830: PUSH
30831: EMPTY
30832: LIST
30833: LIST
30834: PUSH
30835: LD_INT 1
30837: NEG
30838: PUSH
30839: LD_INT 1
30841: PUSH
30842: EMPTY
30843: LIST
30844: LIST
30845: PUSH
30846: LD_INT 1
30848: NEG
30849: PUSH
30850: LD_INT 3
30852: NEG
30853: PUSH
30854: EMPTY
30855: LIST
30856: LIST
30857: PUSH
30858: LD_INT 0
30860: PUSH
30861: LD_INT 3
30863: NEG
30864: PUSH
30865: EMPTY
30866: LIST
30867: LIST
30868: PUSH
30869: LD_INT 1
30871: PUSH
30872: LD_INT 2
30874: NEG
30875: PUSH
30876: EMPTY
30877: LIST
30878: LIST
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: LIST
30884: LIST
30885: LIST
30886: LIST
30887: LIST
30888: LIST
30889: LIST
30890: LIST
30891: LIST
30892: LIST
30893: LIST
30894: LIST
30895: LIST
30896: LIST
30897: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30898: LD_ADDR_VAR 0 15
30902: PUSH
30903: LD_INT 0
30905: PUSH
30906: LD_INT 0
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: LD_INT 0
30915: PUSH
30916: LD_INT 1
30918: NEG
30919: PUSH
30920: EMPTY
30921: LIST
30922: LIST
30923: PUSH
30924: LD_INT 1
30926: PUSH
30927: LD_INT 0
30929: PUSH
30930: EMPTY
30931: LIST
30932: LIST
30933: PUSH
30934: LD_INT 1
30936: PUSH
30937: LD_INT 1
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: PUSH
30944: LD_INT 0
30946: PUSH
30947: LD_INT 1
30949: PUSH
30950: EMPTY
30951: LIST
30952: LIST
30953: PUSH
30954: LD_INT 1
30956: NEG
30957: PUSH
30958: LD_INT 0
30960: PUSH
30961: EMPTY
30962: LIST
30963: LIST
30964: PUSH
30965: LD_INT 1
30967: NEG
30968: PUSH
30969: LD_INT 1
30971: NEG
30972: PUSH
30973: EMPTY
30974: LIST
30975: LIST
30976: PUSH
30977: LD_INT 1
30979: PUSH
30980: LD_INT 1
30982: NEG
30983: PUSH
30984: EMPTY
30985: LIST
30986: LIST
30987: PUSH
30988: LD_INT 2
30990: PUSH
30991: LD_INT 0
30993: PUSH
30994: EMPTY
30995: LIST
30996: LIST
30997: PUSH
30998: LD_INT 2
31000: PUSH
31001: LD_INT 1
31003: PUSH
31004: EMPTY
31005: LIST
31006: LIST
31007: PUSH
31008: LD_INT 1
31010: NEG
31011: PUSH
31012: LD_INT 1
31014: PUSH
31015: EMPTY
31016: LIST
31017: LIST
31018: PUSH
31019: LD_INT 2
31021: NEG
31022: PUSH
31023: LD_INT 0
31025: PUSH
31026: EMPTY
31027: LIST
31028: LIST
31029: PUSH
31030: LD_INT 2
31032: NEG
31033: PUSH
31034: LD_INT 1
31036: NEG
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PUSH
31042: LD_INT 2
31044: PUSH
31045: LD_INT 1
31047: NEG
31048: PUSH
31049: EMPTY
31050: LIST
31051: LIST
31052: PUSH
31053: LD_INT 3
31055: PUSH
31056: LD_INT 0
31058: PUSH
31059: EMPTY
31060: LIST
31061: LIST
31062: PUSH
31063: LD_INT 3
31065: PUSH
31066: LD_INT 1
31068: PUSH
31069: EMPTY
31070: LIST
31071: LIST
31072: PUSH
31073: EMPTY
31074: LIST
31075: LIST
31076: LIST
31077: LIST
31078: LIST
31079: LIST
31080: LIST
31081: LIST
31082: LIST
31083: LIST
31084: LIST
31085: LIST
31086: LIST
31087: LIST
31088: LIST
31089: LIST
31090: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
31091: LD_ADDR_VAR 0 16
31095: PUSH
31096: LD_INT 0
31098: PUSH
31099: LD_INT 0
31101: PUSH
31102: EMPTY
31103: LIST
31104: LIST
31105: PUSH
31106: LD_INT 0
31108: PUSH
31109: LD_INT 1
31111: NEG
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 1
31119: PUSH
31120: LD_INT 0
31122: PUSH
31123: EMPTY
31124: LIST
31125: LIST
31126: PUSH
31127: LD_INT 1
31129: PUSH
31130: LD_INT 1
31132: PUSH
31133: EMPTY
31134: LIST
31135: LIST
31136: PUSH
31137: LD_INT 0
31139: PUSH
31140: LD_INT 1
31142: PUSH
31143: EMPTY
31144: LIST
31145: LIST
31146: PUSH
31147: LD_INT 1
31149: NEG
31150: PUSH
31151: LD_INT 0
31153: PUSH
31154: EMPTY
31155: LIST
31156: LIST
31157: PUSH
31158: LD_INT 1
31160: NEG
31161: PUSH
31162: LD_INT 1
31164: NEG
31165: PUSH
31166: EMPTY
31167: LIST
31168: LIST
31169: PUSH
31170: LD_INT 1
31172: NEG
31173: PUSH
31174: LD_INT 2
31176: NEG
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: PUSH
31182: LD_INT 2
31184: PUSH
31185: LD_INT 1
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PUSH
31192: LD_INT 2
31194: PUSH
31195: LD_INT 2
31197: PUSH
31198: EMPTY
31199: LIST
31200: LIST
31201: PUSH
31202: LD_INT 1
31204: PUSH
31205: LD_INT 2
31207: PUSH
31208: EMPTY
31209: LIST
31210: LIST
31211: PUSH
31212: LD_INT 2
31214: NEG
31215: PUSH
31216: LD_INT 1
31218: NEG
31219: PUSH
31220: EMPTY
31221: LIST
31222: LIST
31223: PUSH
31224: LD_INT 2
31226: NEG
31227: PUSH
31228: LD_INT 2
31230: NEG
31231: PUSH
31232: EMPTY
31233: LIST
31234: LIST
31235: PUSH
31236: LD_INT 3
31238: PUSH
31239: LD_INT 2
31241: PUSH
31242: EMPTY
31243: LIST
31244: LIST
31245: PUSH
31246: LD_INT 3
31248: PUSH
31249: LD_INT 3
31251: PUSH
31252: EMPTY
31253: LIST
31254: LIST
31255: PUSH
31256: LD_INT 2
31258: PUSH
31259: LD_INT 3
31261: PUSH
31262: EMPTY
31263: LIST
31264: LIST
31265: PUSH
31266: EMPTY
31267: LIST
31268: LIST
31269: LIST
31270: LIST
31271: LIST
31272: LIST
31273: LIST
31274: LIST
31275: LIST
31276: LIST
31277: LIST
31278: LIST
31279: LIST
31280: LIST
31281: LIST
31282: LIST
31283: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31284: LD_ADDR_VAR 0 17
31288: PUSH
31289: LD_INT 0
31291: PUSH
31292: LD_INT 0
31294: PUSH
31295: EMPTY
31296: LIST
31297: LIST
31298: PUSH
31299: LD_INT 0
31301: PUSH
31302: LD_INT 1
31304: NEG
31305: PUSH
31306: EMPTY
31307: LIST
31308: LIST
31309: PUSH
31310: LD_INT 1
31312: PUSH
31313: LD_INT 0
31315: PUSH
31316: EMPTY
31317: LIST
31318: LIST
31319: PUSH
31320: LD_INT 1
31322: PUSH
31323: LD_INT 1
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: LD_INT 0
31332: PUSH
31333: LD_INT 1
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: PUSH
31340: LD_INT 1
31342: NEG
31343: PUSH
31344: LD_INT 0
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: PUSH
31351: LD_INT 1
31353: NEG
31354: PUSH
31355: LD_INT 1
31357: NEG
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PUSH
31363: LD_INT 1
31365: NEG
31366: PUSH
31367: LD_INT 2
31369: NEG
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 0
31377: PUSH
31378: LD_INT 2
31380: NEG
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: LD_INT 1
31388: PUSH
31389: LD_INT 1
31391: NEG
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: LD_INT 2
31399: PUSH
31400: LD_INT 0
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 2
31409: PUSH
31410: LD_INT 1
31412: PUSH
31413: EMPTY
31414: LIST
31415: LIST
31416: PUSH
31417: LD_INT 2
31419: PUSH
31420: LD_INT 2
31422: PUSH
31423: EMPTY
31424: LIST
31425: LIST
31426: PUSH
31427: LD_INT 1
31429: PUSH
31430: LD_INT 2
31432: PUSH
31433: EMPTY
31434: LIST
31435: LIST
31436: PUSH
31437: LD_INT 0
31439: PUSH
31440: LD_INT 2
31442: PUSH
31443: EMPTY
31444: LIST
31445: LIST
31446: PUSH
31447: LD_INT 1
31449: NEG
31450: PUSH
31451: LD_INT 1
31453: PUSH
31454: EMPTY
31455: LIST
31456: LIST
31457: PUSH
31458: LD_INT 2
31460: NEG
31461: PUSH
31462: LD_INT 0
31464: PUSH
31465: EMPTY
31466: LIST
31467: LIST
31468: PUSH
31469: LD_INT 2
31471: NEG
31472: PUSH
31473: LD_INT 1
31475: NEG
31476: PUSH
31477: EMPTY
31478: LIST
31479: LIST
31480: PUSH
31481: LD_INT 2
31483: NEG
31484: PUSH
31485: LD_INT 2
31487: NEG
31488: PUSH
31489: EMPTY
31490: LIST
31491: LIST
31492: PUSH
31493: EMPTY
31494: LIST
31495: LIST
31496: LIST
31497: LIST
31498: LIST
31499: LIST
31500: LIST
31501: LIST
31502: LIST
31503: LIST
31504: LIST
31505: LIST
31506: LIST
31507: LIST
31508: LIST
31509: LIST
31510: LIST
31511: LIST
31512: LIST
31513: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31514: LD_ADDR_VAR 0 18
31518: PUSH
31519: LD_INT 0
31521: PUSH
31522: LD_INT 0
31524: PUSH
31525: EMPTY
31526: LIST
31527: LIST
31528: PUSH
31529: LD_INT 0
31531: PUSH
31532: LD_INT 1
31534: NEG
31535: PUSH
31536: EMPTY
31537: LIST
31538: LIST
31539: PUSH
31540: LD_INT 1
31542: PUSH
31543: LD_INT 0
31545: PUSH
31546: EMPTY
31547: LIST
31548: LIST
31549: PUSH
31550: LD_INT 1
31552: PUSH
31553: LD_INT 1
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: LD_INT 0
31562: PUSH
31563: LD_INT 1
31565: PUSH
31566: EMPTY
31567: LIST
31568: LIST
31569: PUSH
31570: LD_INT 1
31572: NEG
31573: PUSH
31574: LD_INT 0
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PUSH
31581: LD_INT 1
31583: NEG
31584: PUSH
31585: LD_INT 1
31587: NEG
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 1
31595: NEG
31596: PUSH
31597: LD_INT 2
31599: NEG
31600: PUSH
31601: EMPTY
31602: LIST
31603: LIST
31604: PUSH
31605: LD_INT 0
31607: PUSH
31608: LD_INT 2
31610: NEG
31611: PUSH
31612: EMPTY
31613: LIST
31614: LIST
31615: PUSH
31616: LD_INT 1
31618: PUSH
31619: LD_INT 1
31621: NEG
31622: PUSH
31623: EMPTY
31624: LIST
31625: LIST
31626: PUSH
31627: LD_INT 2
31629: PUSH
31630: LD_INT 0
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: PUSH
31637: LD_INT 2
31639: PUSH
31640: LD_INT 1
31642: PUSH
31643: EMPTY
31644: LIST
31645: LIST
31646: PUSH
31647: LD_INT 2
31649: PUSH
31650: LD_INT 2
31652: PUSH
31653: EMPTY
31654: LIST
31655: LIST
31656: PUSH
31657: LD_INT 1
31659: PUSH
31660: LD_INT 2
31662: PUSH
31663: EMPTY
31664: LIST
31665: LIST
31666: PUSH
31667: LD_INT 0
31669: PUSH
31670: LD_INT 2
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: PUSH
31677: LD_INT 1
31679: NEG
31680: PUSH
31681: LD_INT 1
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: LD_INT 2
31690: NEG
31691: PUSH
31692: LD_INT 0
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: PUSH
31699: LD_INT 2
31701: NEG
31702: PUSH
31703: LD_INT 1
31705: NEG
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: LD_INT 2
31713: NEG
31714: PUSH
31715: LD_INT 2
31717: NEG
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: EMPTY
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: LIST
31732: LIST
31733: LIST
31734: LIST
31735: LIST
31736: LIST
31737: LIST
31738: LIST
31739: LIST
31740: LIST
31741: LIST
31742: LIST
31743: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31744: LD_ADDR_VAR 0 19
31748: PUSH
31749: LD_INT 0
31751: PUSH
31752: LD_INT 0
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: PUSH
31759: LD_INT 0
31761: PUSH
31762: LD_INT 1
31764: NEG
31765: PUSH
31766: EMPTY
31767: LIST
31768: LIST
31769: PUSH
31770: LD_INT 1
31772: PUSH
31773: LD_INT 0
31775: PUSH
31776: EMPTY
31777: LIST
31778: LIST
31779: PUSH
31780: LD_INT 1
31782: PUSH
31783: LD_INT 1
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: LD_INT 0
31792: PUSH
31793: LD_INT 1
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: PUSH
31800: LD_INT 1
31802: NEG
31803: PUSH
31804: LD_INT 0
31806: PUSH
31807: EMPTY
31808: LIST
31809: LIST
31810: PUSH
31811: LD_INT 1
31813: NEG
31814: PUSH
31815: LD_INT 1
31817: NEG
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PUSH
31823: LD_INT 1
31825: NEG
31826: PUSH
31827: LD_INT 2
31829: NEG
31830: PUSH
31831: EMPTY
31832: LIST
31833: LIST
31834: PUSH
31835: LD_INT 0
31837: PUSH
31838: LD_INT 2
31840: NEG
31841: PUSH
31842: EMPTY
31843: LIST
31844: LIST
31845: PUSH
31846: LD_INT 1
31848: PUSH
31849: LD_INT 1
31851: NEG
31852: PUSH
31853: EMPTY
31854: LIST
31855: LIST
31856: PUSH
31857: LD_INT 2
31859: PUSH
31860: LD_INT 0
31862: PUSH
31863: EMPTY
31864: LIST
31865: LIST
31866: PUSH
31867: LD_INT 2
31869: PUSH
31870: LD_INT 1
31872: PUSH
31873: EMPTY
31874: LIST
31875: LIST
31876: PUSH
31877: LD_INT 2
31879: PUSH
31880: LD_INT 2
31882: PUSH
31883: EMPTY
31884: LIST
31885: LIST
31886: PUSH
31887: LD_INT 1
31889: PUSH
31890: LD_INT 2
31892: PUSH
31893: EMPTY
31894: LIST
31895: LIST
31896: PUSH
31897: LD_INT 0
31899: PUSH
31900: LD_INT 2
31902: PUSH
31903: EMPTY
31904: LIST
31905: LIST
31906: PUSH
31907: LD_INT 1
31909: NEG
31910: PUSH
31911: LD_INT 1
31913: PUSH
31914: EMPTY
31915: LIST
31916: LIST
31917: PUSH
31918: LD_INT 2
31920: NEG
31921: PUSH
31922: LD_INT 0
31924: PUSH
31925: EMPTY
31926: LIST
31927: LIST
31928: PUSH
31929: LD_INT 2
31931: NEG
31932: PUSH
31933: LD_INT 1
31935: NEG
31936: PUSH
31937: EMPTY
31938: LIST
31939: LIST
31940: PUSH
31941: LD_INT 2
31943: NEG
31944: PUSH
31945: LD_INT 2
31947: NEG
31948: PUSH
31949: EMPTY
31950: LIST
31951: LIST
31952: PUSH
31953: EMPTY
31954: LIST
31955: LIST
31956: LIST
31957: LIST
31958: LIST
31959: LIST
31960: LIST
31961: LIST
31962: LIST
31963: LIST
31964: LIST
31965: LIST
31966: LIST
31967: LIST
31968: LIST
31969: LIST
31970: LIST
31971: LIST
31972: LIST
31973: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31974: LD_ADDR_VAR 0 20
31978: PUSH
31979: LD_INT 0
31981: PUSH
31982: LD_INT 0
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 0
31991: PUSH
31992: LD_INT 1
31994: NEG
31995: PUSH
31996: EMPTY
31997: LIST
31998: LIST
31999: PUSH
32000: LD_INT 1
32002: PUSH
32003: LD_INT 0
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PUSH
32010: LD_INT 1
32012: PUSH
32013: LD_INT 1
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: LD_INT 0
32022: PUSH
32023: LD_INT 1
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 1
32032: NEG
32033: PUSH
32034: LD_INT 0
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: PUSH
32041: LD_INT 1
32043: NEG
32044: PUSH
32045: LD_INT 1
32047: NEG
32048: PUSH
32049: EMPTY
32050: LIST
32051: LIST
32052: PUSH
32053: LD_INT 1
32055: NEG
32056: PUSH
32057: LD_INT 2
32059: NEG
32060: PUSH
32061: EMPTY
32062: LIST
32063: LIST
32064: PUSH
32065: LD_INT 0
32067: PUSH
32068: LD_INT 2
32070: NEG
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 1
32078: PUSH
32079: LD_INT 1
32081: NEG
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: PUSH
32087: LD_INT 2
32089: PUSH
32090: LD_INT 0
32092: PUSH
32093: EMPTY
32094: LIST
32095: LIST
32096: PUSH
32097: LD_INT 2
32099: PUSH
32100: LD_INT 1
32102: PUSH
32103: EMPTY
32104: LIST
32105: LIST
32106: PUSH
32107: LD_INT 2
32109: PUSH
32110: LD_INT 2
32112: PUSH
32113: EMPTY
32114: LIST
32115: LIST
32116: PUSH
32117: LD_INT 1
32119: PUSH
32120: LD_INT 2
32122: PUSH
32123: EMPTY
32124: LIST
32125: LIST
32126: PUSH
32127: LD_INT 0
32129: PUSH
32130: LD_INT 2
32132: PUSH
32133: EMPTY
32134: LIST
32135: LIST
32136: PUSH
32137: LD_INT 1
32139: NEG
32140: PUSH
32141: LD_INT 1
32143: PUSH
32144: EMPTY
32145: LIST
32146: LIST
32147: PUSH
32148: LD_INT 2
32150: NEG
32151: PUSH
32152: LD_INT 0
32154: PUSH
32155: EMPTY
32156: LIST
32157: LIST
32158: PUSH
32159: LD_INT 2
32161: NEG
32162: PUSH
32163: LD_INT 1
32165: NEG
32166: PUSH
32167: EMPTY
32168: LIST
32169: LIST
32170: PUSH
32171: LD_INT 2
32173: NEG
32174: PUSH
32175: LD_INT 2
32177: NEG
32178: PUSH
32179: EMPTY
32180: LIST
32181: LIST
32182: PUSH
32183: EMPTY
32184: LIST
32185: LIST
32186: LIST
32187: LIST
32188: LIST
32189: LIST
32190: LIST
32191: LIST
32192: LIST
32193: LIST
32194: LIST
32195: LIST
32196: LIST
32197: LIST
32198: LIST
32199: LIST
32200: LIST
32201: LIST
32202: LIST
32203: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32204: LD_ADDR_VAR 0 21
32208: PUSH
32209: LD_INT 0
32211: PUSH
32212: LD_INT 0
32214: PUSH
32215: EMPTY
32216: LIST
32217: LIST
32218: PUSH
32219: LD_INT 0
32221: PUSH
32222: LD_INT 1
32224: NEG
32225: PUSH
32226: EMPTY
32227: LIST
32228: LIST
32229: PUSH
32230: LD_INT 1
32232: PUSH
32233: LD_INT 0
32235: PUSH
32236: EMPTY
32237: LIST
32238: LIST
32239: PUSH
32240: LD_INT 1
32242: PUSH
32243: LD_INT 1
32245: PUSH
32246: EMPTY
32247: LIST
32248: LIST
32249: PUSH
32250: LD_INT 0
32252: PUSH
32253: LD_INT 1
32255: PUSH
32256: EMPTY
32257: LIST
32258: LIST
32259: PUSH
32260: LD_INT 1
32262: NEG
32263: PUSH
32264: LD_INT 0
32266: PUSH
32267: EMPTY
32268: LIST
32269: LIST
32270: PUSH
32271: LD_INT 1
32273: NEG
32274: PUSH
32275: LD_INT 1
32277: NEG
32278: PUSH
32279: EMPTY
32280: LIST
32281: LIST
32282: PUSH
32283: LD_INT 1
32285: NEG
32286: PUSH
32287: LD_INT 2
32289: NEG
32290: PUSH
32291: EMPTY
32292: LIST
32293: LIST
32294: PUSH
32295: LD_INT 0
32297: PUSH
32298: LD_INT 2
32300: NEG
32301: PUSH
32302: EMPTY
32303: LIST
32304: LIST
32305: PUSH
32306: LD_INT 1
32308: PUSH
32309: LD_INT 1
32311: NEG
32312: PUSH
32313: EMPTY
32314: LIST
32315: LIST
32316: PUSH
32317: LD_INT 2
32319: PUSH
32320: LD_INT 0
32322: PUSH
32323: EMPTY
32324: LIST
32325: LIST
32326: PUSH
32327: LD_INT 2
32329: PUSH
32330: LD_INT 1
32332: PUSH
32333: EMPTY
32334: LIST
32335: LIST
32336: PUSH
32337: LD_INT 2
32339: PUSH
32340: LD_INT 2
32342: PUSH
32343: EMPTY
32344: LIST
32345: LIST
32346: PUSH
32347: LD_INT 1
32349: PUSH
32350: LD_INT 2
32352: PUSH
32353: EMPTY
32354: LIST
32355: LIST
32356: PUSH
32357: LD_INT 0
32359: PUSH
32360: LD_INT 2
32362: PUSH
32363: EMPTY
32364: LIST
32365: LIST
32366: PUSH
32367: LD_INT 1
32369: NEG
32370: PUSH
32371: LD_INT 1
32373: PUSH
32374: EMPTY
32375: LIST
32376: LIST
32377: PUSH
32378: LD_INT 2
32380: NEG
32381: PUSH
32382: LD_INT 0
32384: PUSH
32385: EMPTY
32386: LIST
32387: LIST
32388: PUSH
32389: LD_INT 2
32391: NEG
32392: PUSH
32393: LD_INT 1
32395: NEG
32396: PUSH
32397: EMPTY
32398: LIST
32399: LIST
32400: PUSH
32401: LD_INT 2
32403: NEG
32404: PUSH
32405: LD_INT 2
32407: NEG
32408: PUSH
32409: EMPTY
32410: LIST
32411: LIST
32412: PUSH
32413: EMPTY
32414: LIST
32415: LIST
32416: LIST
32417: LIST
32418: LIST
32419: LIST
32420: LIST
32421: LIST
32422: LIST
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: LIST
32428: LIST
32429: LIST
32430: LIST
32431: LIST
32432: LIST
32433: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32434: LD_ADDR_VAR 0 22
32438: PUSH
32439: LD_INT 0
32441: PUSH
32442: LD_INT 0
32444: PUSH
32445: EMPTY
32446: LIST
32447: LIST
32448: PUSH
32449: LD_INT 0
32451: PUSH
32452: LD_INT 1
32454: NEG
32455: PUSH
32456: EMPTY
32457: LIST
32458: LIST
32459: PUSH
32460: LD_INT 1
32462: PUSH
32463: LD_INT 0
32465: PUSH
32466: EMPTY
32467: LIST
32468: LIST
32469: PUSH
32470: LD_INT 1
32472: PUSH
32473: LD_INT 1
32475: PUSH
32476: EMPTY
32477: LIST
32478: LIST
32479: PUSH
32480: LD_INT 0
32482: PUSH
32483: LD_INT 1
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PUSH
32490: LD_INT 1
32492: NEG
32493: PUSH
32494: LD_INT 0
32496: PUSH
32497: EMPTY
32498: LIST
32499: LIST
32500: PUSH
32501: LD_INT 1
32503: NEG
32504: PUSH
32505: LD_INT 1
32507: NEG
32508: PUSH
32509: EMPTY
32510: LIST
32511: LIST
32512: PUSH
32513: LD_INT 1
32515: NEG
32516: PUSH
32517: LD_INT 2
32519: NEG
32520: PUSH
32521: EMPTY
32522: LIST
32523: LIST
32524: PUSH
32525: LD_INT 0
32527: PUSH
32528: LD_INT 2
32530: NEG
32531: PUSH
32532: EMPTY
32533: LIST
32534: LIST
32535: PUSH
32536: LD_INT 1
32538: PUSH
32539: LD_INT 1
32541: NEG
32542: PUSH
32543: EMPTY
32544: LIST
32545: LIST
32546: PUSH
32547: LD_INT 2
32549: PUSH
32550: LD_INT 0
32552: PUSH
32553: EMPTY
32554: LIST
32555: LIST
32556: PUSH
32557: LD_INT 2
32559: PUSH
32560: LD_INT 1
32562: PUSH
32563: EMPTY
32564: LIST
32565: LIST
32566: PUSH
32567: LD_INT 2
32569: PUSH
32570: LD_INT 2
32572: PUSH
32573: EMPTY
32574: LIST
32575: LIST
32576: PUSH
32577: LD_INT 1
32579: PUSH
32580: LD_INT 2
32582: PUSH
32583: EMPTY
32584: LIST
32585: LIST
32586: PUSH
32587: LD_INT 0
32589: PUSH
32590: LD_INT 2
32592: PUSH
32593: EMPTY
32594: LIST
32595: LIST
32596: PUSH
32597: LD_INT 1
32599: NEG
32600: PUSH
32601: LD_INT 1
32603: PUSH
32604: EMPTY
32605: LIST
32606: LIST
32607: PUSH
32608: LD_INT 2
32610: NEG
32611: PUSH
32612: LD_INT 0
32614: PUSH
32615: EMPTY
32616: LIST
32617: LIST
32618: PUSH
32619: LD_INT 2
32621: NEG
32622: PUSH
32623: LD_INT 1
32625: NEG
32626: PUSH
32627: EMPTY
32628: LIST
32629: LIST
32630: PUSH
32631: LD_INT 2
32633: NEG
32634: PUSH
32635: LD_INT 2
32637: NEG
32638: PUSH
32639: EMPTY
32640: LIST
32641: LIST
32642: PUSH
32643: EMPTY
32644: LIST
32645: LIST
32646: LIST
32647: LIST
32648: LIST
32649: LIST
32650: LIST
32651: LIST
32652: LIST
32653: LIST
32654: LIST
32655: LIST
32656: LIST
32657: LIST
32658: LIST
32659: LIST
32660: LIST
32661: LIST
32662: LIST
32663: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
32664: LD_ADDR_VAR 0 23
32668: PUSH
32669: LD_INT 0
32671: PUSH
32672: LD_INT 0
32674: PUSH
32675: EMPTY
32676: LIST
32677: LIST
32678: PUSH
32679: LD_INT 0
32681: PUSH
32682: LD_INT 1
32684: NEG
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PUSH
32690: LD_INT 1
32692: PUSH
32693: LD_INT 0
32695: PUSH
32696: EMPTY
32697: LIST
32698: LIST
32699: PUSH
32700: LD_INT 1
32702: PUSH
32703: LD_INT 1
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PUSH
32710: LD_INT 0
32712: PUSH
32713: LD_INT 1
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 1
32722: NEG
32723: PUSH
32724: LD_INT 0
32726: PUSH
32727: EMPTY
32728: LIST
32729: LIST
32730: PUSH
32731: LD_INT 1
32733: NEG
32734: PUSH
32735: LD_INT 1
32737: NEG
32738: PUSH
32739: EMPTY
32740: LIST
32741: LIST
32742: PUSH
32743: LD_INT 1
32745: NEG
32746: PUSH
32747: LD_INT 2
32749: NEG
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 0
32757: PUSH
32758: LD_INT 2
32760: NEG
32761: PUSH
32762: EMPTY
32763: LIST
32764: LIST
32765: PUSH
32766: LD_INT 1
32768: PUSH
32769: LD_INT 1
32771: NEG
32772: PUSH
32773: EMPTY
32774: LIST
32775: LIST
32776: PUSH
32777: LD_INT 2
32779: PUSH
32780: LD_INT 0
32782: PUSH
32783: EMPTY
32784: LIST
32785: LIST
32786: PUSH
32787: LD_INT 2
32789: PUSH
32790: LD_INT 1
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 2
32799: PUSH
32800: LD_INT 2
32802: PUSH
32803: EMPTY
32804: LIST
32805: LIST
32806: PUSH
32807: LD_INT 1
32809: PUSH
32810: LD_INT 2
32812: PUSH
32813: EMPTY
32814: LIST
32815: LIST
32816: PUSH
32817: LD_INT 0
32819: PUSH
32820: LD_INT 2
32822: PUSH
32823: EMPTY
32824: LIST
32825: LIST
32826: PUSH
32827: LD_INT 1
32829: NEG
32830: PUSH
32831: LD_INT 1
32833: PUSH
32834: EMPTY
32835: LIST
32836: LIST
32837: PUSH
32838: LD_INT 2
32840: NEG
32841: PUSH
32842: LD_INT 0
32844: PUSH
32845: EMPTY
32846: LIST
32847: LIST
32848: PUSH
32849: LD_INT 2
32851: NEG
32852: PUSH
32853: LD_INT 1
32855: NEG
32856: PUSH
32857: EMPTY
32858: LIST
32859: LIST
32860: PUSH
32861: LD_INT 2
32863: NEG
32864: PUSH
32865: LD_INT 2
32867: NEG
32868: PUSH
32869: EMPTY
32870: LIST
32871: LIST
32872: PUSH
32873: LD_INT 2
32875: NEG
32876: PUSH
32877: LD_INT 3
32879: NEG
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: PUSH
32885: LD_INT 1
32887: NEG
32888: PUSH
32889: LD_INT 3
32891: NEG
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: PUSH
32897: LD_INT 1
32899: PUSH
32900: LD_INT 2
32902: NEG
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 2
32910: PUSH
32911: LD_INT 1
32913: NEG
32914: PUSH
32915: EMPTY
32916: LIST
32917: LIST
32918: PUSH
32919: EMPTY
32920: LIST
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: LIST
32939: LIST
32940: LIST
32941: LIST
32942: LIST
32943: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32944: LD_ADDR_VAR 0 24
32948: PUSH
32949: LD_INT 0
32951: PUSH
32952: LD_INT 0
32954: PUSH
32955: EMPTY
32956: LIST
32957: LIST
32958: PUSH
32959: LD_INT 0
32961: PUSH
32962: LD_INT 1
32964: NEG
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PUSH
32970: LD_INT 1
32972: PUSH
32973: LD_INT 0
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: PUSH
32980: LD_INT 1
32982: PUSH
32983: LD_INT 1
32985: PUSH
32986: EMPTY
32987: LIST
32988: LIST
32989: PUSH
32990: LD_INT 0
32992: PUSH
32993: LD_INT 1
32995: PUSH
32996: EMPTY
32997: LIST
32998: LIST
32999: PUSH
33000: LD_INT 1
33002: NEG
33003: PUSH
33004: LD_INT 0
33006: PUSH
33007: EMPTY
33008: LIST
33009: LIST
33010: PUSH
33011: LD_INT 1
33013: NEG
33014: PUSH
33015: LD_INT 1
33017: NEG
33018: PUSH
33019: EMPTY
33020: LIST
33021: LIST
33022: PUSH
33023: LD_INT 1
33025: NEG
33026: PUSH
33027: LD_INT 2
33029: NEG
33030: PUSH
33031: EMPTY
33032: LIST
33033: LIST
33034: PUSH
33035: LD_INT 0
33037: PUSH
33038: LD_INT 2
33040: NEG
33041: PUSH
33042: EMPTY
33043: LIST
33044: LIST
33045: PUSH
33046: LD_INT 1
33048: PUSH
33049: LD_INT 1
33051: NEG
33052: PUSH
33053: EMPTY
33054: LIST
33055: LIST
33056: PUSH
33057: LD_INT 2
33059: PUSH
33060: LD_INT 0
33062: PUSH
33063: EMPTY
33064: LIST
33065: LIST
33066: PUSH
33067: LD_INT 2
33069: PUSH
33070: LD_INT 1
33072: PUSH
33073: EMPTY
33074: LIST
33075: LIST
33076: PUSH
33077: LD_INT 2
33079: PUSH
33080: LD_INT 2
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: PUSH
33087: LD_INT 1
33089: PUSH
33090: LD_INT 2
33092: PUSH
33093: EMPTY
33094: LIST
33095: LIST
33096: PUSH
33097: LD_INT 0
33099: PUSH
33100: LD_INT 2
33102: PUSH
33103: EMPTY
33104: LIST
33105: LIST
33106: PUSH
33107: LD_INT 1
33109: NEG
33110: PUSH
33111: LD_INT 1
33113: PUSH
33114: EMPTY
33115: LIST
33116: LIST
33117: PUSH
33118: LD_INT 2
33120: NEG
33121: PUSH
33122: LD_INT 0
33124: PUSH
33125: EMPTY
33126: LIST
33127: LIST
33128: PUSH
33129: LD_INT 2
33131: NEG
33132: PUSH
33133: LD_INT 1
33135: NEG
33136: PUSH
33137: EMPTY
33138: LIST
33139: LIST
33140: PUSH
33141: LD_INT 2
33143: NEG
33144: PUSH
33145: LD_INT 2
33147: NEG
33148: PUSH
33149: EMPTY
33150: LIST
33151: LIST
33152: PUSH
33153: LD_INT 1
33155: PUSH
33156: LD_INT 2
33158: NEG
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: PUSH
33164: LD_INT 2
33166: PUSH
33167: LD_INT 1
33169: NEG
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 3
33177: PUSH
33178: LD_INT 1
33180: PUSH
33181: EMPTY
33182: LIST
33183: LIST
33184: PUSH
33185: LD_INT 3
33187: PUSH
33188: LD_INT 2
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: PUSH
33195: EMPTY
33196: LIST
33197: LIST
33198: LIST
33199: LIST
33200: LIST
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: LIST
33206: LIST
33207: LIST
33208: LIST
33209: LIST
33210: LIST
33211: LIST
33212: LIST
33213: LIST
33214: LIST
33215: LIST
33216: LIST
33217: LIST
33218: LIST
33219: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
33220: LD_ADDR_VAR 0 25
33224: PUSH
33225: LD_INT 0
33227: PUSH
33228: LD_INT 0
33230: PUSH
33231: EMPTY
33232: LIST
33233: LIST
33234: PUSH
33235: LD_INT 0
33237: PUSH
33238: LD_INT 1
33240: NEG
33241: PUSH
33242: EMPTY
33243: LIST
33244: LIST
33245: PUSH
33246: LD_INT 1
33248: PUSH
33249: LD_INT 0
33251: PUSH
33252: EMPTY
33253: LIST
33254: LIST
33255: PUSH
33256: LD_INT 1
33258: PUSH
33259: LD_INT 1
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 0
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 1
33278: NEG
33279: PUSH
33280: LD_INT 0
33282: PUSH
33283: EMPTY
33284: LIST
33285: LIST
33286: PUSH
33287: LD_INT 1
33289: NEG
33290: PUSH
33291: LD_INT 1
33293: NEG
33294: PUSH
33295: EMPTY
33296: LIST
33297: LIST
33298: PUSH
33299: LD_INT 1
33301: NEG
33302: PUSH
33303: LD_INT 2
33305: NEG
33306: PUSH
33307: EMPTY
33308: LIST
33309: LIST
33310: PUSH
33311: LD_INT 0
33313: PUSH
33314: LD_INT 2
33316: NEG
33317: PUSH
33318: EMPTY
33319: LIST
33320: LIST
33321: PUSH
33322: LD_INT 1
33324: PUSH
33325: LD_INT 1
33327: NEG
33328: PUSH
33329: EMPTY
33330: LIST
33331: LIST
33332: PUSH
33333: LD_INT 2
33335: PUSH
33336: LD_INT 0
33338: PUSH
33339: EMPTY
33340: LIST
33341: LIST
33342: PUSH
33343: LD_INT 2
33345: PUSH
33346: LD_INT 1
33348: PUSH
33349: EMPTY
33350: LIST
33351: LIST
33352: PUSH
33353: LD_INT 2
33355: PUSH
33356: LD_INT 2
33358: PUSH
33359: EMPTY
33360: LIST
33361: LIST
33362: PUSH
33363: LD_INT 1
33365: PUSH
33366: LD_INT 2
33368: PUSH
33369: EMPTY
33370: LIST
33371: LIST
33372: PUSH
33373: LD_INT 0
33375: PUSH
33376: LD_INT 2
33378: PUSH
33379: EMPTY
33380: LIST
33381: LIST
33382: PUSH
33383: LD_INT 1
33385: NEG
33386: PUSH
33387: LD_INT 1
33389: PUSH
33390: EMPTY
33391: LIST
33392: LIST
33393: PUSH
33394: LD_INT 2
33396: NEG
33397: PUSH
33398: LD_INT 0
33400: PUSH
33401: EMPTY
33402: LIST
33403: LIST
33404: PUSH
33405: LD_INT 2
33407: NEG
33408: PUSH
33409: LD_INT 1
33411: NEG
33412: PUSH
33413: EMPTY
33414: LIST
33415: LIST
33416: PUSH
33417: LD_INT 2
33419: NEG
33420: PUSH
33421: LD_INT 2
33423: NEG
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: PUSH
33429: LD_INT 3
33431: PUSH
33432: LD_INT 1
33434: PUSH
33435: EMPTY
33436: LIST
33437: LIST
33438: PUSH
33439: LD_INT 3
33441: PUSH
33442: LD_INT 2
33444: PUSH
33445: EMPTY
33446: LIST
33447: LIST
33448: PUSH
33449: LD_INT 2
33451: PUSH
33452: LD_INT 3
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: PUSH
33459: LD_INT 1
33461: PUSH
33462: LD_INT 3
33464: PUSH
33465: EMPTY
33466: LIST
33467: LIST
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: LIST
33473: LIST
33474: LIST
33475: LIST
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: LIST
33481: LIST
33482: LIST
33483: LIST
33484: LIST
33485: LIST
33486: LIST
33487: LIST
33488: LIST
33489: LIST
33490: LIST
33491: LIST
33492: LIST
33493: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
33494: LD_ADDR_VAR 0 26
33498: PUSH
33499: LD_INT 0
33501: PUSH
33502: LD_INT 0
33504: PUSH
33505: EMPTY
33506: LIST
33507: LIST
33508: PUSH
33509: LD_INT 0
33511: PUSH
33512: LD_INT 1
33514: NEG
33515: PUSH
33516: EMPTY
33517: LIST
33518: LIST
33519: PUSH
33520: LD_INT 1
33522: PUSH
33523: LD_INT 0
33525: PUSH
33526: EMPTY
33527: LIST
33528: LIST
33529: PUSH
33530: LD_INT 1
33532: PUSH
33533: LD_INT 1
33535: PUSH
33536: EMPTY
33537: LIST
33538: LIST
33539: PUSH
33540: LD_INT 0
33542: PUSH
33543: LD_INT 1
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: LD_INT 1
33552: NEG
33553: PUSH
33554: LD_INT 0
33556: PUSH
33557: EMPTY
33558: LIST
33559: LIST
33560: PUSH
33561: LD_INT 1
33563: NEG
33564: PUSH
33565: LD_INT 1
33567: NEG
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PUSH
33573: LD_INT 1
33575: NEG
33576: PUSH
33577: LD_INT 2
33579: NEG
33580: PUSH
33581: EMPTY
33582: LIST
33583: LIST
33584: PUSH
33585: LD_INT 0
33587: PUSH
33588: LD_INT 2
33590: NEG
33591: PUSH
33592: EMPTY
33593: LIST
33594: LIST
33595: PUSH
33596: LD_INT 1
33598: PUSH
33599: LD_INT 1
33601: NEG
33602: PUSH
33603: EMPTY
33604: LIST
33605: LIST
33606: PUSH
33607: LD_INT 2
33609: PUSH
33610: LD_INT 0
33612: PUSH
33613: EMPTY
33614: LIST
33615: LIST
33616: PUSH
33617: LD_INT 2
33619: PUSH
33620: LD_INT 1
33622: PUSH
33623: EMPTY
33624: LIST
33625: LIST
33626: PUSH
33627: LD_INT 2
33629: PUSH
33630: LD_INT 2
33632: PUSH
33633: EMPTY
33634: LIST
33635: LIST
33636: PUSH
33637: LD_INT 1
33639: PUSH
33640: LD_INT 2
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 0
33649: PUSH
33650: LD_INT 2
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: PUSH
33657: LD_INT 1
33659: NEG
33660: PUSH
33661: LD_INT 1
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: LD_INT 2
33670: NEG
33671: PUSH
33672: LD_INT 0
33674: PUSH
33675: EMPTY
33676: LIST
33677: LIST
33678: PUSH
33679: LD_INT 2
33681: NEG
33682: PUSH
33683: LD_INT 1
33685: NEG
33686: PUSH
33687: EMPTY
33688: LIST
33689: LIST
33690: PUSH
33691: LD_INT 2
33693: NEG
33694: PUSH
33695: LD_INT 2
33697: NEG
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PUSH
33703: LD_INT 2
33705: PUSH
33706: LD_INT 3
33708: PUSH
33709: EMPTY
33710: LIST
33711: LIST
33712: PUSH
33713: LD_INT 1
33715: PUSH
33716: LD_INT 3
33718: PUSH
33719: EMPTY
33720: LIST
33721: LIST
33722: PUSH
33723: LD_INT 1
33725: NEG
33726: PUSH
33727: LD_INT 2
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 2
33736: NEG
33737: PUSH
33738: LD_INT 1
33740: PUSH
33741: EMPTY
33742: LIST
33743: LIST
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: LIST
33749: LIST
33750: LIST
33751: LIST
33752: LIST
33753: LIST
33754: LIST
33755: LIST
33756: LIST
33757: LIST
33758: LIST
33759: LIST
33760: LIST
33761: LIST
33762: LIST
33763: LIST
33764: LIST
33765: LIST
33766: LIST
33767: LIST
33768: LIST
33769: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33770: LD_ADDR_VAR 0 27
33774: PUSH
33775: LD_INT 0
33777: PUSH
33778: LD_INT 0
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: LD_INT 0
33787: PUSH
33788: LD_INT 1
33790: NEG
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 1
33798: PUSH
33799: LD_INT 0
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_INT 1
33808: PUSH
33809: LD_INT 1
33811: PUSH
33812: EMPTY
33813: LIST
33814: LIST
33815: PUSH
33816: LD_INT 0
33818: PUSH
33819: LD_INT 1
33821: PUSH
33822: EMPTY
33823: LIST
33824: LIST
33825: PUSH
33826: LD_INT 1
33828: NEG
33829: PUSH
33830: LD_INT 0
33832: PUSH
33833: EMPTY
33834: LIST
33835: LIST
33836: PUSH
33837: LD_INT 1
33839: NEG
33840: PUSH
33841: LD_INT 1
33843: NEG
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: PUSH
33849: LD_INT 1
33851: NEG
33852: PUSH
33853: LD_INT 2
33855: NEG
33856: PUSH
33857: EMPTY
33858: LIST
33859: LIST
33860: PUSH
33861: LD_INT 0
33863: PUSH
33864: LD_INT 2
33866: NEG
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: PUSH
33872: LD_INT 1
33874: PUSH
33875: LD_INT 1
33877: NEG
33878: PUSH
33879: EMPTY
33880: LIST
33881: LIST
33882: PUSH
33883: LD_INT 2
33885: PUSH
33886: LD_INT 0
33888: PUSH
33889: EMPTY
33890: LIST
33891: LIST
33892: PUSH
33893: LD_INT 2
33895: PUSH
33896: LD_INT 1
33898: PUSH
33899: EMPTY
33900: LIST
33901: LIST
33902: PUSH
33903: LD_INT 2
33905: PUSH
33906: LD_INT 2
33908: PUSH
33909: EMPTY
33910: LIST
33911: LIST
33912: PUSH
33913: LD_INT 1
33915: PUSH
33916: LD_INT 2
33918: PUSH
33919: EMPTY
33920: LIST
33921: LIST
33922: PUSH
33923: LD_INT 0
33925: PUSH
33926: LD_INT 2
33928: PUSH
33929: EMPTY
33930: LIST
33931: LIST
33932: PUSH
33933: LD_INT 1
33935: NEG
33936: PUSH
33937: LD_INT 1
33939: PUSH
33940: EMPTY
33941: LIST
33942: LIST
33943: PUSH
33944: LD_INT 2
33946: NEG
33947: PUSH
33948: LD_INT 0
33950: PUSH
33951: EMPTY
33952: LIST
33953: LIST
33954: PUSH
33955: LD_INT 2
33957: NEG
33958: PUSH
33959: LD_INT 1
33961: NEG
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 2
33969: NEG
33970: PUSH
33971: LD_INT 2
33973: NEG
33974: PUSH
33975: EMPTY
33976: LIST
33977: LIST
33978: PUSH
33979: LD_INT 1
33981: NEG
33982: PUSH
33983: LD_INT 2
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: LD_INT 2
33992: NEG
33993: PUSH
33994: LD_INT 1
33996: PUSH
33997: EMPTY
33998: LIST
33999: LIST
34000: PUSH
34001: LD_INT 3
34003: NEG
34004: PUSH
34005: LD_INT 1
34007: NEG
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 3
34015: NEG
34016: PUSH
34017: LD_INT 2
34019: NEG
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: EMPTY
34026: LIST
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: LIST
34047: LIST
34048: LIST
34049: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
34050: LD_ADDR_VAR 0 28
34054: PUSH
34055: LD_INT 0
34057: PUSH
34058: LD_INT 0
34060: PUSH
34061: EMPTY
34062: LIST
34063: LIST
34064: PUSH
34065: LD_INT 0
34067: PUSH
34068: LD_INT 1
34070: NEG
34071: PUSH
34072: EMPTY
34073: LIST
34074: LIST
34075: PUSH
34076: LD_INT 1
34078: PUSH
34079: LD_INT 0
34081: PUSH
34082: EMPTY
34083: LIST
34084: LIST
34085: PUSH
34086: LD_INT 1
34088: PUSH
34089: LD_INT 1
34091: PUSH
34092: EMPTY
34093: LIST
34094: LIST
34095: PUSH
34096: LD_INT 0
34098: PUSH
34099: LD_INT 1
34101: PUSH
34102: EMPTY
34103: LIST
34104: LIST
34105: PUSH
34106: LD_INT 1
34108: NEG
34109: PUSH
34110: LD_INT 0
34112: PUSH
34113: EMPTY
34114: LIST
34115: LIST
34116: PUSH
34117: LD_INT 1
34119: NEG
34120: PUSH
34121: LD_INT 1
34123: NEG
34124: PUSH
34125: EMPTY
34126: LIST
34127: LIST
34128: PUSH
34129: LD_INT 1
34131: NEG
34132: PUSH
34133: LD_INT 2
34135: NEG
34136: PUSH
34137: EMPTY
34138: LIST
34139: LIST
34140: PUSH
34141: LD_INT 0
34143: PUSH
34144: LD_INT 2
34146: NEG
34147: PUSH
34148: EMPTY
34149: LIST
34150: LIST
34151: PUSH
34152: LD_INT 1
34154: PUSH
34155: LD_INT 1
34157: NEG
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PUSH
34163: LD_INT 2
34165: PUSH
34166: LD_INT 0
34168: PUSH
34169: EMPTY
34170: LIST
34171: LIST
34172: PUSH
34173: LD_INT 2
34175: PUSH
34176: LD_INT 1
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 2
34185: PUSH
34186: LD_INT 2
34188: PUSH
34189: EMPTY
34190: LIST
34191: LIST
34192: PUSH
34193: LD_INT 1
34195: PUSH
34196: LD_INT 2
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 0
34205: PUSH
34206: LD_INT 2
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 1
34215: NEG
34216: PUSH
34217: LD_INT 1
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 2
34226: NEG
34227: PUSH
34228: LD_INT 0
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: LD_INT 2
34237: NEG
34238: PUSH
34239: LD_INT 1
34241: NEG
34242: PUSH
34243: EMPTY
34244: LIST
34245: LIST
34246: PUSH
34247: LD_INT 2
34249: NEG
34250: PUSH
34251: LD_INT 2
34253: NEG
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: PUSH
34259: LD_INT 2
34261: NEG
34262: PUSH
34263: LD_INT 3
34265: NEG
34266: PUSH
34267: EMPTY
34268: LIST
34269: LIST
34270: PUSH
34271: LD_INT 1
34273: NEG
34274: PUSH
34275: LD_INT 3
34277: NEG
34278: PUSH
34279: EMPTY
34280: LIST
34281: LIST
34282: PUSH
34283: LD_INT 3
34285: NEG
34286: PUSH
34287: LD_INT 1
34289: NEG
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 3
34297: NEG
34298: PUSH
34299: LD_INT 2
34301: NEG
34302: PUSH
34303: EMPTY
34304: LIST
34305: LIST
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: LIST
34311: LIST
34312: LIST
34313: LIST
34314: LIST
34315: LIST
34316: LIST
34317: LIST
34318: LIST
34319: LIST
34320: LIST
34321: LIST
34322: LIST
34323: LIST
34324: LIST
34325: LIST
34326: LIST
34327: LIST
34328: LIST
34329: LIST
34330: LIST
34331: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34332: LD_ADDR_VAR 0 29
34336: PUSH
34337: LD_INT 0
34339: PUSH
34340: LD_INT 0
34342: PUSH
34343: EMPTY
34344: LIST
34345: LIST
34346: PUSH
34347: LD_INT 0
34349: PUSH
34350: LD_INT 1
34352: NEG
34353: PUSH
34354: EMPTY
34355: LIST
34356: LIST
34357: PUSH
34358: LD_INT 1
34360: PUSH
34361: LD_INT 0
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: PUSH
34368: LD_INT 1
34370: PUSH
34371: LD_INT 1
34373: PUSH
34374: EMPTY
34375: LIST
34376: LIST
34377: PUSH
34378: LD_INT 0
34380: PUSH
34381: LD_INT 1
34383: PUSH
34384: EMPTY
34385: LIST
34386: LIST
34387: PUSH
34388: LD_INT 1
34390: NEG
34391: PUSH
34392: LD_INT 0
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 1
34401: NEG
34402: PUSH
34403: LD_INT 1
34405: NEG
34406: PUSH
34407: EMPTY
34408: LIST
34409: LIST
34410: PUSH
34411: LD_INT 1
34413: NEG
34414: PUSH
34415: LD_INT 2
34417: NEG
34418: PUSH
34419: EMPTY
34420: LIST
34421: LIST
34422: PUSH
34423: LD_INT 0
34425: PUSH
34426: LD_INT 2
34428: NEG
34429: PUSH
34430: EMPTY
34431: LIST
34432: LIST
34433: PUSH
34434: LD_INT 1
34436: PUSH
34437: LD_INT 1
34439: NEG
34440: PUSH
34441: EMPTY
34442: LIST
34443: LIST
34444: PUSH
34445: LD_INT 2
34447: PUSH
34448: LD_INT 0
34450: PUSH
34451: EMPTY
34452: LIST
34453: LIST
34454: PUSH
34455: LD_INT 2
34457: PUSH
34458: LD_INT 1
34460: PUSH
34461: EMPTY
34462: LIST
34463: LIST
34464: PUSH
34465: LD_INT 1
34467: PUSH
34468: LD_INT 2
34470: PUSH
34471: EMPTY
34472: LIST
34473: LIST
34474: PUSH
34475: LD_INT 0
34477: PUSH
34478: LD_INT 2
34480: PUSH
34481: EMPTY
34482: LIST
34483: LIST
34484: PUSH
34485: LD_INT 1
34487: NEG
34488: PUSH
34489: LD_INT 1
34491: PUSH
34492: EMPTY
34493: LIST
34494: LIST
34495: PUSH
34496: LD_INT 2
34498: NEG
34499: PUSH
34500: LD_INT 1
34502: NEG
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: PUSH
34508: LD_INT 2
34510: NEG
34511: PUSH
34512: LD_INT 2
34514: NEG
34515: PUSH
34516: EMPTY
34517: LIST
34518: LIST
34519: PUSH
34520: LD_INT 2
34522: NEG
34523: PUSH
34524: LD_INT 3
34526: NEG
34527: PUSH
34528: EMPTY
34529: LIST
34530: LIST
34531: PUSH
34532: LD_INT 2
34534: PUSH
34535: LD_INT 1
34537: NEG
34538: PUSH
34539: EMPTY
34540: LIST
34541: LIST
34542: PUSH
34543: LD_INT 3
34545: PUSH
34546: LD_INT 1
34548: PUSH
34549: EMPTY
34550: LIST
34551: LIST
34552: PUSH
34553: LD_INT 1
34555: PUSH
34556: LD_INT 3
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 1
34565: NEG
34566: PUSH
34567: LD_INT 2
34569: PUSH
34570: EMPTY
34571: LIST
34572: LIST
34573: PUSH
34574: LD_INT 3
34576: NEG
34577: PUSH
34578: LD_INT 2
34580: NEG
34581: PUSH
34582: EMPTY
34583: LIST
34584: LIST
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: LIST
34590: LIST
34591: LIST
34592: LIST
34593: LIST
34594: LIST
34595: LIST
34596: LIST
34597: LIST
34598: LIST
34599: LIST
34600: LIST
34601: LIST
34602: LIST
34603: LIST
34604: LIST
34605: LIST
34606: LIST
34607: LIST
34608: LIST
34609: LIST
34610: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34611: LD_ADDR_VAR 0 30
34615: PUSH
34616: LD_INT 0
34618: PUSH
34619: LD_INT 0
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 0
34628: PUSH
34629: LD_INT 1
34631: NEG
34632: PUSH
34633: EMPTY
34634: LIST
34635: LIST
34636: PUSH
34637: LD_INT 1
34639: PUSH
34640: LD_INT 0
34642: PUSH
34643: EMPTY
34644: LIST
34645: LIST
34646: PUSH
34647: LD_INT 1
34649: PUSH
34650: LD_INT 1
34652: PUSH
34653: EMPTY
34654: LIST
34655: LIST
34656: PUSH
34657: LD_INT 0
34659: PUSH
34660: LD_INT 1
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: PUSH
34667: LD_INT 1
34669: NEG
34670: PUSH
34671: LD_INT 0
34673: PUSH
34674: EMPTY
34675: LIST
34676: LIST
34677: PUSH
34678: LD_INT 1
34680: NEG
34681: PUSH
34682: LD_INT 1
34684: NEG
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PUSH
34690: LD_INT 1
34692: NEG
34693: PUSH
34694: LD_INT 2
34696: NEG
34697: PUSH
34698: EMPTY
34699: LIST
34700: LIST
34701: PUSH
34702: LD_INT 0
34704: PUSH
34705: LD_INT 2
34707: NEG
34708: PUSH
34709: EMPTY
34710: LIST
34711: LIST
34712: PUSH
34713: LD_INT 1
34715: PUSH
34716: LD_INT 1
34718: NEG
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: PUSH
34724: LD_INT 2
34726: PUSH
34727: LD_INT 0
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 2
34736: PUSH
34737: LD_INT 1
34739: PUSH
34740: EMPTY
34741: LIST
34742: LIST
34743: PUSH
34744: LD_INT 2
34746: PUSH
34747: LD_INT 2
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: PUSH
34754: LD_INT 1
34756: PUSH
34757: LD_INT 2
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 1
34766: NEG
34767: PUSH
34768: LD_INT 1
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PUSH
34775: LD_INT 2
34777: NEG
34778: PUSH
34779: LD_INT 0
34781: PUSH
34782: EMPTY
34783: LIST
34784: LIST
34785: PUSH
34786: LD_INT 2
34788: NEG
34789: PUSH
34790: LD_INT 1
34792: NEG
34793: PUSH
34794: EMPTY
34795: LIST
34796: LIST
34797: PUSH
34798: LD_INT 1
34800: NEG
34801: PUSH
34802: LD_INT 3
34804: NEG
34805: PUSH
34806: EMPTY
34807: LIST
34808: LIST
34809: PUSH
34810: LD_INT 1
34812: PUSH
34813: LD_INT 2
34815: NEG
34816: PUSH
34817: EMPTY
34818: LIST
34819: LIST
34820: PUSH
34821: LD_INT 3
34823: PUSH
34824: LD_INT 2
34826: PUSH
34827: EMPTY
34828: LIST
34829: LIST
34830: PUSH
34831: LD_INT 2
34833: PUSH
34834: LD_INT 3
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: LD_INT 2
34843: NEG
34844: PUSH
34845: LD_INT 1
34847: PUSH
34848: EMPTY
34849: LIST
34850: LIST
34851: PUSH
34852: LD_INT 3
34854: NEG
34855: PUSH
34856: LD_INT 1
34858: NEG
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: LIST
34868: LIST
34869: LIST
34870: LIST
34871: LIST
34872: LIST
34873: LIST
34874: LIST
34875: LIST
34876: LIST
34877: LIST
34878: LIST
34879: LIST
34880: LIST
34881: LIST
34882: LIST
34883: LIST
34884: LIST
34885: LIST
34886: LIST
34887: LIST
34888: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34889: LD_ADDR_VAR 0 31
34893: PUSH
34894: LD_INT 0
34896: PUSH
34897: LD_INT 0
34899: PUSH
34900: EMPTY
34901: LIST
34902: LIST
34903: PUSH
34904: LD_INT 0
34906: PUSH
34907: LD_INT 1
34909: NEG
34910: PUSH
34911: EMPTY
34912: LIST
34913: LIST
34914: PUSH
34915: LD_INT 1
34917: PUSH
34918: LD_INT 0
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: LD_INT 1
34927: PUSH
34928: LD_INT 1
34930: PUSH
34931: EMPTY
34932: LIST
34933: LIST
34934: PUSH
34935: LD_INT 0
34937: PUSH
34938: LD_INT 1
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PUSH
34945: LD_INT 1
34947: NEG
34948: PUSH
34949: LD_INT 0
34951: PUSH
34952: EMPTY
34953: LIST
34954: LIST
34955: PUSH
34956: LD_INT 1
34958: NEG
34959: PUSH
34960: LD_INT 1
34962: NEG
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: LD_INT 1
34970: NEG
34971: PUSH
34972: LD_INT 2
34974: NEG
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: PUSH
34980: LD_INT 1
34982: PUSH
34983: LD_INT 1
34985: NEG
34986: PUSH
34987: EMPTY
34988: LIST
34989: LIST
34990: PUSH
34991: LD_INT 2
34993: PUSH
34994: LD_INT 0
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: PUSH
35001: LD_INT 2
35003: PUSH
35004: LD_INT 1
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: PUSH
35011: LD_INT 2
35013: PUSH
35014: LD_INT 2
35016: PUSH
35017: EMPTY
35018: LIST
35019: LIST
35020: PUSH
35021: LD_INT 1
35023: PUSH
35024: LD_INT 2
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: PUSH
35031: LD_INT 0
35033: PUSH
35034: LD_INT 2
35036: PUSH
35037: EMPTY
35038: LIST
35039: LIST
35040: PUSH
35041: LD_INT 1
35043: NEG
35044: PUSH
35045: LD_INT 1
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: LD_INT 2
35054: NEG
35055: PUSH
35056: LD_INT 1
35058: NEG
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PUSH
35064: LD_INT 2
35066: NEG
35067: PUSH
35068: LD_INT 2
35070: NEG
35071: PUSH
35072: EMPTY
35073: LIST
35074: LIST
35075: PUSH
35076: LD_INT 2
35078: NEG
35079: PUSH
35080: LD_INT 3
35082: NEG
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 2
35090: PUSH
35091: LD_INT 1
35093: NEG
35094: PUSH
35095: EMPTY
35096: LIST
35097: LIST
35098: PUSH
35099: LD_INT 3
35101: PUSH
35102: LD_INT 1
35104: PUSH
35105: EMPTY
35106: LIST
35107: LIST
35108: PUSH
35109: LD_INT 1
35111: PUSH
35112: LD_INT 3
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 1
35121: NEG
35122: PUSH
35123: LD_INT 2
35125: PUSH
35126: EMPTY
35127: LIST
35128: LIST
35129: PUSH
35130: LD_INT 3
35132: NEG
35133: PUSH
35134: LD_INT 2
35136: NEG
35137: PUSH
35138: EMPTY
35139: LIST
35140: LIST
35141: PUSH
35142: EMPTY
35143: LIST
35144: LIST
35145: LIST
35146: LIST
35147: LIST
35148: LIST
35149: LIST
35150: LIST
35151: LIST
35152: LIST
35153: LIST
35154: LIST
35155: LIST
35156: LIST
35157: LIST
35158: LIST
35159: LIST
35160: LIST
35161: LIST
35162: LIST
35163: LIST
35164: LIST
35165: LIST
35166: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35167: LD_ADDR_VAR 0 32
35171: PUSH
35172: LD_INT 0
35174: PUSH
35175: LD_INT 0
35177: PUSH
35178: EMPTY
35179: LIST
35180: LIST
35181: PUSH
35182: LD_INT 0
35184: PUSH
35185: LD_INT 1
35187: NEG
35188: PUSH
35189: EMPTY
35190: LIST
35191: LIST
35192: PUSH
35193: LD_INT 1
35195: PUSH
35196: LD_INT 0
35198: PUSH
35199: EMPTY
35200: LIST
35201: LIST
35202: PUSH
35203: LD_INT 1
35205: PUSH
35206: LD_INT 1
35208: PUSH
35209: EMPTY
35210: LIST
35211: LIST
35212: PUSH
35213: LD_INT 0
35215: PUSH
35216: LD_INT 1
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: LD_INT 1
35225: NEG
35226: PUSH
35227: LD_INT 0
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 1
35236: NEG
35237: PUSH
35238: LD_INT 1
35240: NEG
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 1
35248: NEG
35249: PUSH
35250: LD_INT 2
35252: NEG
35253: PUSH
35254: EMPTY
35255: LIST
35256: LIST
35257: PUSH
35258: LD_INT 0
35260: PUSH
35261: LD_INT 2
35263: NEG
35264: PUSH
35265: EMPTY
35266: LIST
35267: LIST
35268: PUSH
35269: LD_INT 1
35271: PUSH
35272: LD_INT 1
35274: NEG
35275: PUSH
35276: EMPTY
35277: LIST
35278: LIST
35279: PUSH
35280: LD_INT 2
35282: PUSH
35283: LD_INT 1
35285: PUSH
35286: EMPTY
35287: LIST
35288: LIST
35289: PUSH
35290: LD_INT 2
35292: PUSH
35293: LD_INT 2
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: PUSH
35300: LD_INT 1
35302: PUSH
35303: LD_INT 2
35305: PUSH
35306: EMPTY
35307: LIST
35308: LIST
35309: PUSH
35310: LD_INT 0
35312: PUSH
35313: LD_INT 2
35315: PUSH
35316: EMPTY
35317: LIST
35318: LIST
35319: PUSH
35320: LD_INT 1
35322: NEG
35323: PUSH
35324: LD_INT 1
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 2
35333: NEG
35334: PUSH
35335: LD_INT 0
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: LD_INT 2
35344: NEG
35345: PUSH
35346: LD_INT 1
35348: NEG
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 1
35356: NEG
35357: PUSH
35358: LD_INT 3
35360: NEG
35361: PUSH
35362: EMPTY
35363: LIST
35364: LIST
35365: PUSH
35366: LD_INT 1
35368: PUSH
35369: LD_INT 2
35371: NEG
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 3
35379: PUSH
35380: LD_INT 2
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: PUSH
35387: LD_INT 2
35389: PUSH
35390: LD_INT 3
35392: PUSH
35393: EMPTY
35394: LIST
35395: LIST
35396: PUSH
35397: LD_INT 2
35399: NEG
35400: PUSH
35401: LD_INT 1
35403: PUSH
35404: EMPTY
35405: LIST
35406: LIST
35407: PUSH
35408: LD_INT 3
35410: NEG
35411: PUSH
35412: LD_INT 1
35414: NEG
35415: PUSH
35416: EMPTY
35417: LIST
35418: LIST
35419: PUSH
35420: EMPTY
35421: LIST
35422: LIST
35423: LIST
35424: LIST
35425: LIST
35426: LIST
35427: LIST
35428: LIST
35429: LIST
35430: LIST
35431: LIST
35432: LIST
35433: LIST
35434: LIST
35435: LIST
35436: LIST
35437: LIST
35438: LIST
35439: LIST
35440: LIST
35441: LIST
35442: LIST
35443: LIST
35444: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35445: LD_ADDR_VAR 0 33
35449: PUSH
35450: LD_INT 0
35452: PUSH
35453: LD_INT 0
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: LD_INT 0
35462: PUSH
35463: LD_INT 1
35465: NEG
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PUSH
35471: LD_INT 1
35473: PUSH
35474: LD_INT 0
35476: PUSH
35477: EMPTY
35478: LIST
35479: LIST
35480: PUSH
35481: LD_INT 1
35483: PUSH
35484: LD_INT 1
35486: PUSH
35487: EMPTY
35488: LIST
35489: LIST
35490: PUSH
35491: LD_INT 0
35493: PUSH
35494: LD_INT 1
35496: PUSH
35497: EMPTY
35498: LIST
35499: LIST
35500: PUSH
35501: LD_INT 1
35503: NEG
35504: PUSH
35505: LD_INT 0
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: LD_INT 1
35514: NEG
35515: PUSH
35516: LD_INT 1
35518: NEG
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 1
35526: NEG
35527: PUSH
35528: LD_INT 2
35530: NEG
35531: PUSH
35532: EMPTY
35533: LIST
35534: LIST
35535: PUSH
35536: LD_INT 1
35538: PUSH
35539: LD_INT 1
35541: NEG
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: LD_INT 2
35549: PUSH
35550: LD_INT 0
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: PUSH
35557: LD_INT 2
35559: PUSH
35560: LD_INT 1
35562: PUSH
35563: EMPTY
35564: LIST
35565: LIST
35566: PUSH
35567: LD_INT 1
35569: PUSH
35570: LD_INT 2
35572: PUSH
35573: EMPTY
35574: LIST
35575: LIST
35576: PUSH
35577: LD_INT 0
35579: PUSH
35580: LD_INT 2
35582: PUSH
35583: EMPTY
35584: LIST
35585: LIST
35586: PUSH
35587: LD_INT 1
35589: NEG
35590: PUSH
35591: LD_INT 1
35593: PUSH
35594: EMPTY
35595: LIST
35596: LIST
35597: PUSH
35598: LD_INT 2
35600: NEG
35601: PUSH
35602: LD_INT 0
35604: PUSH
35605: EMPTY
35606: LIST
35607: LIST
35608: PUSH
35609: LD_INT 2
35611: NEG
35612: PUSH
35613: LD_INT 1
35615: NEG
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: LD_INT 2
35623: NEG
35624: PUSH
35625: LD_INT 2
35627: NEG
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: PUSH
35633: LD_INT 2
35635: NEG
35636: PUSH
35637: LD_INT 3
35639: NEG
35640: PUSH
35641: EMPTY
35642: LIST
35643: LIST
35644: PUSH
35645: LD_INT 2
35647: PUSH
35648: LD_INT 1
35650: NEG
35651: PUSH
35652: EMPTY
35653: LIST
35654: LIST
35655: PUSH
35656: LD_INT 3
35658: PUSH
35659: LD_INT 1
35661: PUSH
35662: EMPTY
35663: LIST
35664: LIST
35665: PUSH
35666: LD_INT 1
35668: PUSH
35669: LD_INT 3
35671: PUSH
35672: EMPTY
35673: LIST
35674: LIST
35675: PUSH
35676: LD_INT 1
35678: NEG
35679: PUSH
35680: LD_INT 2
35682: PUSH
35683: EMPTY
35684: LIST
35685: LIST
35686: PUSH
35687: LD_INT 3
35689: NEG
35690: PUSH
35691: LD_INT 2
35693: NEG
35694: PUSH
35695: EMPTY
35696: LIST
35697: LIST
35698: PUSH
35699: EMPTY
35700: LIST
35701: LIST
35702: LIST
35703: LIST
35704: LIST
35705: LIST
35706: LIST
35707: LIST
35708: LIST
35709: LIST
35710: LIST
35711: LIST
35712: LIST
35713: LIST
35714: LIST
35715: LIST
35716: LIST
35717: LIST
35718: LIST
35719: LIST
35720: LIST
35721: LIST
35722: LIST
35723: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35724: LD_ADDR_VAR 0 34
35728: PUSH
35729: LD_INT 0
35731: PUSH
35732: LD_INT 0
35734: PUSH
35735: EMPTY
35736: LIST
35737: LIST
35738: PUSH
35739: LD_INT 0
35741: PUSH
35742: LD_INT 1
35744: NEG
35745: PUSH
35746: EMPTY
35747: LIST
35748: LIST
35749: PUSH
35750: LD_INT 1
35752: PUSH
35753: LD_INT 0
35755: PUSH
35756: EMPTY
35757: LIST
35758: LIST
35759: PUSH
35760: LD_INT 1
35762: PUSH
35763: LD_INT 1
35765: PUSH
35766: EMPTY
35767: LIST
35768: LIST
35769: PUSH
35770: LD_INT 0
35772: PUSH
35773: LD_INT 1
35775: PUSH
35776: EMPTY
35777: LIST
35778: LIST
35779: PUSH
35780: LD_INT 1
35782: NEG
35783: PUSH
35784: LD_INT 0
35786: PUSH
35787: EMPTY
35788: LIST
35789: LIST
35790: PUSH
35791: LD_INT 1
35793: NEG
35794: PUSH
35795: LD_INT 1
35797: NEG
35798: PUSH
35799: EMPTY
35800: LIST
35801: LIST
35802: PUSH
35803: LD_INT 1
35805: NEG
35806: PUSH
35807: LD_INT 2
35809: NEG
35810: PUSH
35811: EMPTY
35812: LIST
35813: LIST
35814: PUSH
35815: LD_INT 0
35817: PUSH
35818: LD_INT 2
35820: NEG
35821: PUSH
35822: EMPTY
35823: LIST
35824: LIST
35825: PUSH
35826: LD_INT 1
35828: PUSH
35829: LD_INT 1
35831: NEG
35832: PUSH
35833: EMPTY
35834: LIST
35835: LIST
35836: PUSH
35837: LD_INT 2
35839: PUSH
35840: LD_INT 1
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: LD_INT 2
35849: PUSH
35850: LD_INT 2
35852: PUSH
35853: EMPTY
35854: LIST
35855: LIST
35856: PUSH
35857: LD_INT 1
35859: PUSH
35860: LD_INT 2
35862: PUSH
35863: EMPTY
35864: LIST
35865: LIST
35866: PUSH
35867: LD_INT 1
35869: NEG
35870: PUSH
35871: LD_INT 1
35873: PUSH
35874: EMPTY
35875: LIST
35876: LIST
35877: PUSH
35878: LD_INT 2
35880: NEG
35881: PUSH
35882: LD_INT 0
35884: PUSH
35885: EMPTY
35886: LIST
35887: LIST
35888: PUSH
35889: LD_INT 2
35891: NEG
35892: PUSH
35893: LD_INT 1
35895: NEG
35896: PUSH
35897: EMPTY
35898: LIST
35899: LIST
35900: PUSH
35901: LD_INT 2
35903: NEG
35904: PUSH
35905: LD_INT 2
35907: NEG
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: PUSH
35913: LD_INT 1
35915: NEG
35916: PUSH
35917: LD_INT 3
35919: NEG
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 1
35927: PUSH
35928: LD_INT 2
35930: NEG
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 3
35938: PUSH
35939: LD_INT 2
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: LD_INT 2
35948: PUSH
35949: LD_INT 3
35951: PUSH
35952: EMPTY
35953: LIST
35954: LIST
35955: PUSH
35956: LD_INT 2
35958: NEG
35959: PUSH
35960: LD_INT 1
35962: PUSH
35963: EMPTY
35964: LIST
35965: LIST
35966: PUSH
35967: LD_INT 3
35969: NEG
35970: PUSH
35971: LD_INT 1
35973: NEG
35974: PUSH
35975: EMPTY
35976: LIST
35977: LIST
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: LIST
35986: LIST
35987: LIST
35988: LIST
35989: LIST
35990: LIST
35991: LIST
35992: LIST
35993: LIST
35994: LIST
35995: LIST
35996: LIST
35997: LIST
35998: LIST
35999: LIST
36000: LIST
36001: LIST
36002: LIST
36003: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36004: LD_ADDR_VAR 0 35
36008: PUSH
36009: LD_INT 0
36011: PUSH
36012: LD_INT 0
36014: PUSH
36015: EMPTY
36016: LIST
36017: LIST
36018: PUSH
36019: LD_INT 0
36021: PUSH
36022: LD_INT 1
36024: NEG
36025: PUSH
36026: EMPTY
36027: LIST
36028: LIST
36029: PUSH
36030: LD_INT 1
36032: PUSH
36033: LD_INT 0
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: PUSH
36040: LD_INT 1
36042: PUSH
36043: LD_INT 1
36045: PUSH
36046: EMPTY
36047: LIST
36048: LIST
36049: PUSH
36050: LD_INT 0
36052: PUSH
36053: LD_INT 1
36055: PUSH
36056: EMPTY
36057: LIST
36058: LIST
36059: PUSH
36060: LD_INT 1
36062: NEG
36063: PUSH
36064: LD_INT 0
36066: PUSH
36067: EMPTY
36068: LIST
36069: LIST
36070: PUSH
36071: LD_INT 1
36073: NEG
36074: PUSH
36075: LD_INT 1
36077: NEG
36078: PUSH
36079: EMPTY
36080: LIST
36081: LIST
36082: PUSH
36083: LD_INT 2
36085: PUSH
36086: LD_INT 1
36088: PUSH
36089: EMPTY
36090: LIST
36091: LIST
36092: PUSH
36093: LD_INT 2
36095: NEG
36096: PUSH
36097: LD_INT 1
36099: NEG
36100: PUSH
36101: EMPTY
36102: LIST
36103: LIST
36104: PUSH
36105: EMPTY
36106: LIST
36107: LIST
36108: LIST
36109: LIST
36110: LIST
36111: LIST
36112: LIST
36113: LIST
36114: LIST
36115: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36116: LD_ADDR_VAR 0 36
36120: PUSH
36121: LD_INT 0
36123: PUSH
36124: LD_INT 0
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: PUSH
36131: LD_INT 0
36133: PUSH
36134: LD_INT 1
36136: NEG
36137: PUSH
36138: EMPTY
36139: LIST
36140: LIST
36141: PUSH
36142: LD_INT 1
36144: PUSH
36145: LD_INT 0
36147: PUSH
36148: EMPTY
36149: LIST
36150: LIST
36151: PUSH
36152: LD_INT 1
36154: PUSH
36155: LD_INT 1
36157: PUSH
36158: EMPTY
36159: LIST
36160: LIST
36161: PUSH
36162: LD_INT 0
36164: PUSH
36165: LD_INT 1
36167: PUSH
36168: EMPTY
36169: LIST
36170: LIST
36171: PUSH
36172: LD_INT 1
36174: NEG
36175: PUSH
36176: LD_INT 0
36178: PUSH
36179: EMPTY
36180: LIST
36181: LIST
36182: PUSH
36183: LD_INT 1
36185: NEG
36186: PUSH
36187: LD_INT 1
36189: NEG
36190: PUSH
36191: EMPTY
36192: LIST
36193: LIST
36194: PUSH
36195: LD_INT 1
36197: NEG
36198: PUSH
36199: LD_INT 2
36201: NEG
36202: PUSH
36203: EMPTY
36204: LIST
36205: LIST
36206: PUSH
36207: LD_INT 1
36209: PUSH
36210: LD_INT 2
36212: PUSH
36213: EMPTY
36214: LIST
36215: LIST
36216: PUSH
36217: EMPTY
36218: LIST
36219: LIST
36220: LIST
36221: LIST
36222: LIST
36223: LIST
36224: LIST
36225: LIST
36226: LIST
36227: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36228: LD_ADDR_VAR 0 37
36232: PUSH
36233: LD_INT 0
36235: PUSH
36236: LD_INT 0
36238: PUSH
36239: EMPTY
36240: LIST
36241: LIST
36242: PUSH
36243: LD_INT 0
36245: PUSH
36246: LD_INT 1
36248: NEG
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: PUSH
36254: LD_INT 1
36256: PUSH
36257: LD_INT 0
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: LD_INT 1
36266: PUSH
36267: LD_INT 1
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 0
36276: PUSH
36277: LD_INT 1
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: LD_INT 1
36286: NEG
36287: PUSH
36288: LD_INT 0
36290: PUSH
36291: EMPTY
36292: LIST
36293: LIST
36294: PUSH
36295: LD_INT 1
36297: NEG
36298: PUSH
36299: LD_INT 1
36301: NEG
36302: PUSH
36303: EMPTY
36304: LIST
36305: LIST
36306: PUSH
36307: LD_INT 1
36309: PUSH
36310: LD_INT 1
36312: NEG
36313: PUSH
36314: EMPTY
36315: LIST
36316: LIST
36317: PUSH
36318: LD_INT 1
36320: NEG
36321: PUSH
36322: LD_INT 1
36324: PUSH
36325: EMPTY
36326: LIST
36327: LIST
36328: PUSH
36329: EMPTY
36330: LIST
36331: LIST
36332: LIST
36333: LIST
36334: LIST
36335: LIST
36336: LIST
36337: LIST
36338: LIST
36339: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36340: LD_ADDR_VAR 0 38
36344: PUSH
36345: LD_INT 0
36347: PUSH
36348: LD_INT 0
36350: PUSH
36351: EMPTY
36352: LIST
36353: LIST
36354: PUSH
36355: LD_INT 0
36357: PUSH
36358: LD_INT 1
36360: NEG
36361: PUSH
36362: EMPTY
36363: LIST
36364: LIST
36365: PUSH
36366: LD_INT 1
36368: PUSH
36369: LD_INT 0
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: PUSH
36376: LD_INT 1
36378: PUSH
36379: LD_INT 1
36381: PUSH
36382: EMPTY
36383: LIST
36384: LIST
36385: PUSH
36386: LD_INT 0
36388: PUSH
36389: LD_INT 1
36391: PUSH
36392: EMPTY
36393: LIST
36394: LIST
36395: PUSH
36396: LD_INT 1
36398: NEG
36399: PUSH
36400: LD_INT 0
36402: PUSH
36403: EMPTY
36404: LIST
36405: LIST
36406: PUSH
36407: LD_INT 1
36409: NEG
36410: PUSH
36411: LD_INT 1
36413: NEG
36414: PUSH
36415: EMPTY
36416: LIST
36417: LIST
36418: PUSH
36419: LD_INT 2
36421: PUSH
36422: LD_INT 1
36424: PUSH
36425: EMPTY
36426: LIST
36427: LIST
36428: PUSH
36429: LD_INT 2
36431: NEG
36432: PUSH
36433: LD_INT 1
36435: NEG
36436: PUSH
36437: EMPTY
36438: LIST
36439: LIST
36440: PUSH
36441: EMPTY
36442: LIST
36443: LIST
36444: LIST
36445: LIST
36446: LIST
36447: LIST
36448: LIST
36449: LIST
36450: LIST
36451: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36452: LD_ADDR_VAR 0 39
36456: PUSH
36457: LD_INT 0
36459: PUSH
36460: LD_INT 0
36462: PUSH
36463: EMPTY
36464: LIST
36465: LIST
36466: PUSH
36467: LD_INT 0
36469: PUSH
36470: LD_INT 1
36472: NEG
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: PUSH
36478: LD_INT 1
36480: PUSH
36481: LD_INT 0
36483: PUSH
36484: EMPTY
36485: LIST
36486: LIST
36487: PUSH
36488: LD_INT 1
36490: PUSH
36491: LD_INT 1
36493: PUSH
36494: EMPTY
36495: LIST
36496: LIST
36497: PUSH
36498: LD_INT 0
36500: PUSH
36501: LD_INT 1
36503: PUSH
36504: EMPTY
36505: LIST
36506: LIST
36507: PUSH
36508: LD_INT 1
36510: NEG
36511: PUSH
36512: LD_INT 0
36514: PUSH
36515: EMPTY
36516: LIST
36517: LIST
36518: PUSH
36519: LD_INT 1
36521: NEG
36522: PUSH
36523: LD_INT 1
36525: NEG
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: PUSH
36531: LD_INT 1
36533: NEG
36534: PUSH
36535: LD_INT 2
36537: NEG
36538: PUSH
36539: EMPTY
36540: LIST
36541: LIST
36542: PUSH
36543: LD_INT 1
36545: PUSH
36546: LD_INT 2
36548: PUSH
36549: EMPTY
36550: LIST
36551: LIST
36552: PUSH
36553: EMPTY
36554: LIST
36555: LIST
36556: LIST
36557: LIST
36558: LIST
36559: LIST
36560: LIST
36561: LIST
36562: LIST
36563: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36564: LD_ADDR_VAR 0 40
36568: PUSH
36569: LD_INT 0
36571: PUSH
36572: LD_INT 0
36574: PUSH
36575: EMPTY
36576: LIST
36577: LIST
36578: PUSH
36579: LD_INT 0
36581: PUSH
36582: LD_INT 1
36584: NEG
36585: PUSH
36586: EMPTY
36587: LIST
36588: LIST
36589: PUSH
36590: LD_INT 1
36592: PUSH
36593: LD_INT 0
36595: PUSH
36596: EMPTY
36597: LIST
36598: LIST
36599: PUSH
36600: LD_INT 1
36602: PUSH
36603: LD_INT 1
36605: PUSH
36606: EMPTY
36607: LIST
36608: LIST
36609: PUSH
36610: LD_INT 0
36612: PUSH
36613: LD_INT 1
36615: PUSH
36616: EMPTY
36617: LIST
36618: LIST
36619: PUSH
36620: LD_INT 1
36622: NEG
36623: PUSH
36624: LD_INT 0
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 1
36633: NEG
36634: PUSH
36635: LD_INT 1
36637: NEG
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: LD_INT 1
36645: PUSH
36646: LD_INT 1
36648: NEG
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 1
36656: NEG
36657: PUSH
36658: LD_INT 1
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: EMPTY
36666: LIST
36667: LIST
36668: LIST
36669: LIST
36670: LIST
36671: LIST
36672: LIST
36673: LIST
36674: LIST
36675: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36676: LD_ADDR_VAR 0 41
36680: PUSH
36681: LD_INT 0
36683: PUSH
36684: LD_INT 0
36686: PUSH
36687: EMPTY
36688: LIST
36689: LIST
36690: PUSH
36691: LD_INT 0
36693: PUSH
36694: LD_INT 1
36696: NEG
36697: PUSH
36698: EMPTY
36699: LIST
36700: LIST
36701: PUSH
36702: LD_INT 1
36704: PUSH
36705: LD_INT 0
36707: PUSH
36708: EMPTY
36709: LIST
36710: LIST
36711: PUSH
36712: LD_INT 1
36714: PUSH
36715: LD_INT 1
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: LD_INT 0
36724: PUSH
36725: LD_INT 1
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 1
36734: NEG
36735: PUSH
36736: LD_INT 0
36738: PUSH
36739: EMPTY
36740: LIST
36741: LIST
36742: PUSH
36743: LD_INT 1
36745: NEG
36746: PUSH
36747: LD_INT 1
36749: NEG
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PUSH
36755: LD_INT 1
36757: NEG
36758: PUSH
36759: LD_INT 2
36761: NEG
36762: PUSH
36763: EMPTY
36764: LIST
36765: LIST
36766: PUSH
36767: LD_INT 1
36769: PUSH
36770: LD_INT 1
36772: NEG
36773: PUSH
36774: EMPTY
36775: LIST
36776: LIST
36777: PUSH
36778: LD_INT 2
36780: PUSH
36781: LD_INT 0
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PUSH
36788: LD_INT 2
36790: PUSH
36791: LD_INT 1
36793: PUSH
36794: EMPTY
36795: LIST
36796: LIST
36797: PUSH
36798: LD_INT 2
36800: PUSH
36801: LD_INT 2
36803: PUSH
36804: EMPTY
36805: LIST
36806: LIST
36807: PUSH
36808: LD_INT 1
36810: PUSH
36811: LD_INT 2
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 1
36820: NEG
36821: PUSH
36822: LD_INT 1
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PUSH
36829: LD_INT 2
36831: NEG
36832: PUSH
36833: LD_INT 0
36835: PUSH
36836: EMPTY
36837: LIST
36838: LIST
36839: PUSH
36840: LD_INT 2
36842: NEG
36843: PUSH
36844: LD_INT 1
36846: NEG
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: LD_INT 2
36854: NEG
36855: PUSH
36856: LD_INT 2
36858: NEG
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PUSH
36864: LD_INT 2
36866: NEG
36867: PUSH
36868: LD_INT 3
36870: NEG
36871: PUSH
36872: EMPTY
36873: LIST
36874: LIST
36875: PUSH
36876: LD_INT 2
36878: PUSH
36879: LD_INT 1
36881: NEG
36882: PUSH
36883: EMPTY
36884: LIST
36885: LIST
36886: PUSH
36887: LD_INT 3
36889: PUSH
36890: LD_INT 0
36892: PUSH
36893: EMPTY
36894: LIST
36895: LIST
36896: PUSH
36897: LD_INT 3
36899: PUSH
36900: LD_INT 1
36902: PUSH
36903: EMPTY
36904: LIST
36905: LIST
36906: PUSH
36907: LD_INT 3
36909: PUSH
36910: LD_INT 2
36912: PUSH
36913: EMPTY
36914: LIST
36915: LIST
36916: PUSH
36917: LD_INT 3
36919: PUSH
36920: LD_INT 3
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PUSH
36927: LD_INT 2
36929: PUSH
36930: LD_INT 3
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 2
36939: NEG
36940: PUSH
36941: LD_INT 1
36943: PUSH
36944: EMPTY
36945: LIST
36946: LIST
36947: PUSH
36948: LD_INT 3
36950: NEG
36951: PUSH
36952: LD_INT 0
36954: PUSH
36955: EMPTY
36956: LIST
36957: LIST
36958: PUSH
36959: LD_INT 3
36961: NEG
36962: PUSH
36963: LD_INT 1
36965: NEG
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: LD_INT 3
36973: NEG
36974: PUSH
36975: LD_INT 2
36977: NEG
36978: PUSH
36979: EMPTY
36980: LIST
36981: LIST
36982: PUSH
36983: LD_INT 3
36985: NEG
36986: PUSH
36987: LD_INT 3
36989: NEG
36990: PUSH
36991: EMPTY
36992: LIST
36993: LIST
36994: PUSH
36995: EMPTY
36996: LIST
36997: LIST
36998: LIST
36999: LIST
37000: LIST
37001: LIST
37002: LIST
37003: LIST
37004: LIST
37005: LIST
37006: LIST
37007: LIST
37008: LIST
37009: LIST
37010: LIST
37011: LIST
37012: LIST
37013: LIST
37014: LIST
37015: LIST
37016: LIST
37017: LIST
37018: LIST
37019: LIST
37020: LIST
37021: LIST
37022: LIST
37023: LIST
37024: LIST
37025: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37026: LD_ADDR_VAR 0 42
37030: PUSH
37031: LD_INT 0
37033: PUSH
37034: LD_INT 0
37036: PUSH
37037: EMPTY
37038: LIST
37039: LIST
37040: PUSH
37041: LD_INT 0
37043: PUSH
37044: LD_INT 1
37046: NEG
37047: PUSH
37048: EMPTY
37049: LIST
37050: LIST
37051: PUSH
37052: LD_INT 1
37054: PUSH
37055: LD_INT 0
37057: PUSH
37058: EMPTY
37059: LIST
37060: LIST
37061: PUSH
37062: LD_INT 1
37064: PUSH
37065: LD_INT 1
37067: PUSH
37068: EMPTY
37069: LIST
37070: LIST
37071: PUSH
37072: LD_INT 0
37074: PUSH
37075: LD_INT 1
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: PUSH
37082: LD_INT 1
37084: NEG
37085: PUSH
37086: LD_INT 0
37088: PUSH
37089: EMPTY
37090: LIST
37091: LIST
37092: PUSH
37093: LD_INT 1
37095: NEG
37096: PUSH
37097: LD_INT 1
37099: NEG
37100: PUSH
37101: EMPTY
37102: LIST
37103: LIST
37104: PUSH
37105: LD_INT 1
37107: NEG
37108: PUSH
37109: LD_INT 2
37111: NEG
37112: PUSH
37113: EMPTY
37114: LIST
37115: LIST
37116: PUSH
37117: LD_INT 0
37119: PUSH
37120: LD_INT 2
37122: NEG
37123: PUSH
37124: EMPTY
37125: LIST
37126: LIST
37127: PUSH
37128: LD_INT 1
37130: PUSH
37131: LD_INT 1
37133: NEG
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: PUSH
37139: LD_INT 2
37141: PUSH
37142: LD_INT 1
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: LD_INT 2
37151: PUSH
37152: LD_INT 2
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: LD_INT 1
37161: PUSH
37162: LD_INT 2
37164: PUSH
37165: EMPTY
37166: LIST
37167: LIST
37168: PUSH
37169: LD_INT 0
37171: PUSH
37172: LD_INT 2
37174: PUSH
37175: EMPTY
37176: LIST
37177: LIST
37178: PUSH
37179: LD_INT 1
37181: NEG
37182: PUSH
37183: LD_INT 1
37185: PUSH
37186: EMPTY
37187: LIST
37188: LIST
37189: PUSH
37190: LD_INT 2
37192: NEG
37193: PUSH
37194: LD_INT 1
37196: NEG
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 2
37204: NEG
37205: PUSH
37206: LD_INT 2
37208: NEG
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 2
37216: NEG
37217: PUSH
37218: LD_INT 3
37220: NEG
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 1
37228: NEG
37229: PUSH
37230: LD_INT 3
37232: NEG
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 0
37240: PUSH
37241: LD_INT 3
37243: NEG
37244: PUSH
37245: EMPTY
37246: LIST
37247: LIST
37248: PUSH
37249: LD_INT 1
37251: PUSH
37252: LD_INT 2
37254: NEG
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: PUSH
37260: LD_INT 3
37262: PUSH
37263: LD_INT 2
37265: PUSH
37266: EMPTY
37267: LIST
37268: LIST
37269: PUSH
37270: LD_INT 3
37272: PUSH
37273: LD_INT 3
37275: PUSH
37276: EMPTY
37277: LIST
37278: LIST
37279: PUSH
37280: LD_INT 2
37282: PUSH
37283: LD_INT 3
37285: PUSH
37286: EMPTY
37287: LIST
37288: LIST
37289: PUSH
37290: LD_INT 1
37292: PUSH
37293: LD_INT 3
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: PUSH
37300: LD_INT 0
37302: PUSH
37303: LD_INT 3
37305: PUSH
37306: EMPTY
37307: LIST
37308: LIST
37309: PUSH
37310: LD_INT 1
37312: NEG
37313: PUSH
37314: LD_INT 2
37316: PUSH
37317: EMPTY
37318: LIST
37319: LIST
37320: PUSH
37321: LD_INT 3
37323: NEG
37324: PUSH
37325: LD_INT 2
37327: NEG
37328: PUSH
37329: EMPTY
37330: LIST
37331: LIST
37332: PUSH
37333: LD_INT 3
37335: NEG
37336: PUSH
37337: LD_INT 3
37339: NEG
37340: PUSH
37341: EMPTY
37342: LIST
37343: LIST
37344: PUSH
37345: EMPTY
37346: LIST
37347: LIST
37348: LIST
37349: LIST
37350: LIST
37351: LIST
37352: LIST
37353: LIST
37354: LIST
37355: LIST
37356: LIST
37357: LIST
37358: LIST
37359: LIST
37360: LIST
37361: LIST
37362: LIST
37363: LIST
37364: LIST
37365: LIST
37366: LIST
37367: LIST
37368: LIST
37369: LIST
37370: LIST
37371: LIST
37372: LIST
37373: LIST
37374: LIST
37375: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37376: LD_ADDR_VAR 0 43
37380: PUSH
37381: LD_INT 0
37383: PUSH
37384: LD_INT 0
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 0
37393: PUSH
37394: LD_INT 1
37396: NEG
37397: PUSH
37398: EMPTY
37399: LIST
37400: LIST
37401: PUSH
37402: LD_INT 1
37404: PUSH
37405: LD_INT 0
37407: PUSH
37408: EMPTY
37409: LIST
37410: LIST
37411: PUSH
37412: LD_INT 1
37414: PUSH
37415: LD_INT 1
37417: PUSH
37418: EMPTY
37419: LIST
37420: LIST
37421: PUSH
37422: LD_INT 0
37424: PUSH
37425: LD_INT 1
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 1
37434: NEG
37435: PUSH
37436: LD_INT 0
37438: PUSH
37439: EMPTY
37440: LIST
37441: LIST
37442: PUSH
37443: LD_INT 1
37445: NEG
37446: PUSH
37447: LD_INT 1
37449: NEG
37450: PUSH
37451: EMPTY
37452: LIST
37453: LIST
37454: PUSH
37455: LD_INT 1
37457: NEG
37458: PUSH
37459: LD_INT 2
37461: NEG
37462: PUSH
37463: EMPTY
37464: LIST
37465: LIST
37466: PUSH
37467: LD_INT 0
37469: PUSH
37470: LD_INT 2
37472: NEG
37473: PUSH
37474: EMPTY
37475: LIST
37476: LIST
37477: PUSH
37478: LD_INT 1
37480: PUSH
37481: LD_INT 1
37483: NEG
37484: PUSH
37485: EMPTY
37486: LIST
37487: LIST
37488: PUSH
37489: LD_INT 2
37491: PUSH
37492: LD_INT 0
37494: PUSH
37495: EMPTY
37496: LIST
37497: LIST
37498: PUSH
37499: LD_INT 2
37501: PUSH
37502: LD_INT 1
37504: PUSH
37505: EMPTY
37506: LIST
37507: LIST
37508: PUSH
37509: LD_INT 1
37511: PUSH
37512: LD_INT 2
37514: PUSH
37515: EMPTY
37516: LIST
37517: LIST
37518: PUSH
37519: LD_INT 0
37521: PUSH
37522: LD_INT 2
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 1
37531: NEG
37532: PUSH
37533: LD_INT 1
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PUSH
37540: LD_INT 2
37542: NEG
37543: PUSH
37544: LD_INT 0
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 2
37553: NEG
37554: PUSH
37555: LD_INT 1
37557: NEG
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: LD_INT 1
37565: NEG
37566: PUSH
37567: LD_INT 3
37569: NEG
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: LD_INT 0
37577: PUSH
37578: LD_INT 3
37580: NEG
37581: PUSH
37582: EMPTY
37583: LIST
37584: LIST
37585: PUSH
37586: LD_INT 1
37588: PUSH
37589: LD_INT 2
37591: NEG
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 2
37599: PUSH
37600: LD_INT 1
37602: NEG
37603: PUSH
37604: EMPTY
37605: LIST
37606: LIST
37607: PUSH
37608: LD_INT 3
37610: PUSH
37611: LD_INT 0
37613: PUSH
37614: EMPTY
37615: LIST
37616: LIST
37617: PUSH
37618: LD_INT 3
37620: PUSH
37621: LD_INT 1
37623: PUSH
37624: EMPTY
37625: LIST
37626: LIST
37627: PUSH
37628: LD_INT 1
37630: PUSH
37631: LD_INT 3
37633: PUSH
37634: EMPTY
37635: LIST
37636: LIST
37637: PUSH
37638: LD_INT 0
37640: PUSH
37641: LD_INT 3
37643: PUSH
37644: EMPTY
37645: LIST
37646: LIST
37647: PUSH
37648: LD_INT 1
37650: NEG
37651: PUSH
37652: LD_INT 2
37654: PUSH
37655: EMPTY
37656: LIST
37657: LIST
37658: PUSH
37659: LD_INT 2
37661: NEG
37662: PUSH
37663: LD_INT 1
37665: PUSH
37666: EMPTY
37667: LIST
37668: LIST
37669: PUSH
37670: LD_INT 3
37672: NEG
37673: PUSH
37674: LD_INT 0
37676: PUSH
37677: EMPTY
37678: LIST
37679: LIST
37680: PUSH
37681: LD_INT 3
37683: NEG
37684: PUSH
37685: LD_INT 1
37687: NEG
37688: PUSH
37689: EMPTY
37690: LIST
37691: LIST
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: LIST
37697: LIST
37698: LIST
37699: LIST
37700: LIST
37701: LIST
37702: LIST
37703: LIST
37704: LIST
37705: LIST
37706: LIST
37707: LIST
37708: LIST
37709: LIST
37710: LIST
37711: LIST
37712: LIST
37713: LIST
37714: LIST
37715: LIST
37716: LIST
37717: LIST
37718: LIST
37719: LIST
37720: LIST
37721: LIST
37722: LIST
37723: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37724: LD_ADDR_VAR 0 44
37728: PUSH
37729: LD_INT 0
37731: PUSH
37732: LD_INT 0
37734: PUSH
37735: EMPTY
37736: LIST
37737: LIST
37738: PUSH
37739: LD_INT 0
37741: PUSH
37742: LD_INT 1
37744: NEG
37745: PUSH
37746: EMPTY
37747: LIST
37748: LIST
37749: PUSH
37750: LD_INT 1
37752: PUSH
37753: LD_INT 0
37755: PUSH
37756: EMPTY
37757: LIST
37758: LIST
37759: PUSH
37760: LD_INT 1
37762: PUSH
37763: LD_INT 1
37765: PUSH
37766: EMPTY
37767: LIST
37768: LIST
37769: PUSH
37770: LD_INT 0
37772: PUSH
37773: LD_INT 1
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: PUSH
37780: LD_INT 1
37782: NEG
37783: PUSH
37784: LD_INT 0
37786: PUSH
37787: EMPTY
37788: LIST
37789: LIST
37790: PUSH
37791: LD_INT 1
37793: NEG
37794: PUSH
37795: LD_INT 1
37797: NEG
37798: PUSH
37799: EMPTY
37800: LIST
37801: LIST
37802: PUSH
37803: LD_INT 1
37805: NEG
37806: PUSH
37807: LD_INT 2
37809: NEG
37810: PUSH
37811: EMPTY
37812: LIST
37813: LIST
37814: PUSH
37815: LD_INT 1
37817: PUSH
37818: LD_INT 1
37820: NEG
37821: PUSH
37822: EMPTY
37823: LIST
37824: LIST
37825: PUSH
37826: LD_INT 2
37828: PUSH
37829: LD_INT 0
37831: PUSH
37832: EMPTY
37833: LIST
37834: LIST
37835: PUSH
37836: LD_INT 2
37838: PUSH
37839: LD_INT 1
37841: PUSH
37842: EMPTY
37843: LIST
37844: LIST
37845: PUSH
37846: LD_INT 2
37848: PUSH
37849: LD_INT 2
37851: PUSH
37852: EMPTY
37853: LIST
37854: LIST
37855: PUSH
37856: LD_INT 1
37858: PUSH
37859: LD_INT 2
37861: PUSH
37862: EMPTY
37863: LIST
37864: LIST
37865: PUSH
37866: LD_INT 1
37868: NEG
37869: PUSH
37870: LD_INT 1
37872: PUSH
37873: EMPTY
37874: LIST
37875: LIST
37876: PUSH
37877: LD_INT 2
37879: NEG
37880: PUSH
37881: LD_INT 0
37883: PUSH
37884: EMPTY
37885: LIST
37886: LIST
37887: PUSH
37888: LD_INT 2
37890: NEG
37891: PUSH
37892: LD_INT 1
37894: NEG
37895: PUSH
37896: EMPTY
37897: LIST
37898: LIST
37899: PUSH
37900: LD_INT 2
37902: NEG
37903: PUSH
37904: LD_INT 2
37906: NEG
37907: PUSH
37908: EMPTY
37909: LIST
37910: LIST
37911: PUSH
37912: LD_INT 2
37914: NEG
37915: PUSH
37916: LD_INT 3
37918: NEG
37919: PUSH
37920: EMPTY
37921: LIST
37922: LIST
37923: PUSH
37924: LD_INT 2
37926: PUSH
37927: LD_INT 1
37929: NEG
37930: PUSH
37931: EMPTY
37932: LIST
37933: LIST
37934: PUSH
37935: LD_INT 3
37937: PUSH
37938: LD_INT 0
37940: PUSH
37941: EMPTY
37942: LIST
37943: LIST
37944: PUSH
37945: LD_INT 3
37947: PUSH
37948: LD_INT 1
37950: PUSH
37951: EMPTY
37952: LIST
37953: LIST
37954: PUSH
37955: LD_INT 3
37957: PUSH
37958: LD_INT 2
37960: PUSH
37961: EMPTY
37962: LIST
37963: LIST
37964: PUSH
37965: LD_INT 3
37967: PUSH
37968: LD_INT 3
37970: PUSH
37971: EMPTY
37972: LIST
37973: LIST
37974: PUSH
37975: LD_INT 2
37977: PUSH
37978: LD_INT 3
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 2
37987: NEG
37988: PUSH
37989: LD_INT 1
37991: PUSH
37992: EMPTY
37993: LIST
37994: LIST
37995: PUSH
37996: LD_INT 3
37998: NEG
37999: PUSH
38000: LD_INT 0
38002: PUSH
38003: EMPTY
38004: LIST
38005: LIST
38006: PUSH
38007: LD_INT 3
38009: NEG
38010: PUSH
38011: LD_INT 1
38013: NEG
38014: PUSH
38015: EMPTY
38016: LIST
38017: LIST
38018: PUSH
38019: LD_INT 3
38021: NEG
38022: PUSH
38023: LD_INT 2
38025: NEG
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: PUSH
38031: LD_INT 3
38033: NEG
38034: PUSH
38035: LD_INT 3
38037: NEG
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PUSH
38043: EMPTY
38044: LIST
38045: LIST
38046: LIST
38047: LIST
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: LIST
38055: LIST
38056: LIST
38057: LIST
38058: LIST
38059: LIST
38060: LIST
38061: LIST
38062: LIST
38063: LIST
38064: LIST
38065: LIST
38066: LIST
38067: LIST
38068: LIST
38069: LIST
38070: LIST
38071: LIST
38072: LIST
38073: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38074: LD_ADDR_VAR 0 45
38078: PUSH
38079: LD_INT 0
38081: PUSH
38082: LD_INT 0
38084: PUSH
38085: EMPTY
38086: LIST
38087: LIST
38088: PUSH
38089: LD_INT 0
38091: PUSH
38092: LD_INT 1
38094: NEG
38095: PUSH
38096: EMPTY
38097: LIST
38098: LIST
38099: PUSH
38100: LD_INT 1
38102: PUSH
38103: LD_INT 0
38105: PUSH
38106: EMPTY
38107: LIST
38108: LIST
38109: PUSH
38110: LD_INT 1
38112: PUSH
38113: LD_INT 1
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: PUSH
38120: LD_INT 0
38122: PUSH
38123: LD_INT 1
38125: PUSH
38126: EMPTY
38127: LIST
38128: LIST
38129: PUSH
38130: LD_INT 1
38132: NEG
38133: PUSH
38134: LD_INT 0
38136: PUSH
38137: EMPTY
38138: LIST
38139: LIST
38140: PUSH
38141: LD_INT 1
38143: NEG
38144: PUSH
38145: LD_INT 1
38147: NEG
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PUSH
38153: LD_INT 1
38155: NEG
38156: PUSH
38157: LD_INT 2
38159: NEG
38160: PUSH
38161: EMPTY
38162: LIST
38163: LIST
38164: PUSH
38165: LD_INT 0
38167: PUSH
38168: LD_INT 2
38170: NEG
38171: PUSH
38172: EMPTY
38173: LIST
38174: LIST
38175: PUSH
38176: LD_INT 1
38178: PUSH
38179: LD_INT 1
38181: NEG
38182: PUSH
38183: EMPTY
38184: LIST
38185: LIST
38186: PUSH
38187: LD_INT 2
38189: PUSH
38190: LD_INT 1
38192: PUSH
38193: EMPTY
38194: LIST
38195: LIST
38196: PUSH
38197: LD_INT 2
38199: PUSH
38200: LD_INT 2
38202: PUSH
38203: EMPTY
38204: LIST
38205: LIST
38206: PUSH
38207: LD_INT 1
38209: PUSH
38210: LD_INT 2
38212: PUSH
38213: EMPTY
38214: LIST
38215: LIST
38216: PUSH
38217: LD_INT 0
38219: PUSH
38220: LD_INT 2
38222: PUSH
38223: EMPTY
38224: LIST
38225: LIST
38226: PUSH
38227: LD_INT 1
38229: NEG
38230: PUSH
38231: LD_INT 1
38233: PUSH
38234: EMPTY
38235: LIST
38236: LIST
38237: PUSH
38238: LD_INT 2
38240: NEG
38241: PUSH
38242: LD_INT 1
38244: NEG
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: LD_INT 2
38252: NEG
38253: PUSH
38254: LD_INT 2
38256: NEG
38257: PUSH
38258: EMPTY
38259: LIST
38260: LIST
38261: PUSH
38262: LD_INT 2
38264: NEG
38265: PUSH
38266: LD_INT 3
38268: NEG
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PUSH
38274: LD_INT 1
38276: NEG
38277: PUSH
38278: LD_INT 3
38280: NEG
38281: PUSH
38282: EMPTY
38283: LIST
38284: LIST
38285: PUSH
38286: LD_INT 0
38288: PUSH
38289: LD_INT 3
38291: NEG
38292: PUSH
38293: EMPTY
38294: LIST
38295: LIST
38296: PUSH
38297: LD_INT 1
38299: PUSH
38300: LD_INT 2
38302: NEG
38303: PUSH
38304: EMPTY
38305: LIST
38306: LIST
38307: PUSH
38308: LD_INT 3
38310: PUSH
38311: LD_INT 2
38313: PUSH
38314: EMPTY
38315: LIST
38316: LIST
38317: PUSH
38318: LD_INT 3
38320: PUSH
38321: LD_INT 3
38323: PUSH
38324: EMPTY
38325: LIST
38326: LIST
38327: PUSH
38328: LD_INT 2
38330: PUSH
38331: LD_INT 3
38333: PUSH
38334: EMPTY
38335: LIST
38336: LIST
38337: PUSH
38338: LD_INT 1
38340: PUSH
38341: LD_INT 3
38343: PUSH
38344: EMPTY
38345: LIST
38346: LIST
38347: PUSH
38348: LD_INT 0
38350: PUSH
38351: LD_INT 3
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PUSH
38358: LD_INT 1
38360: NEG
38361: PUSH
38362: LD_INT 2
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: PUSH
38369: LD_INT 3
38371: NEG
38372: PUSH
38373: LD_INT 2
38375: NEG
38376: PUSH
38377: EMPTY
38378: LIST
38379: LIST
38380: PUSH
38381: LD_INT 3
38383: NEG
38384: PUSH
38385: LD_INT 3
38387: NEG
38388: PUSH
38389: EMPTY
38390: LIST
38391: LIST
38392: PUSH
38393: EMPTY
38394: LIST
38395: LIST
38396: LIST
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: LIST
38407: LIST
38408: LIST
38409: LIST
38410: LIST
38411: LIST
38412: LIST
38413: LIST
38414: LIST
38415: LIST
38416: LIST
38417: LIST
38418: LIST
38419: LIST
38420: LIST
38421: LIST
38422: LIST
38423: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38424: LD_ADDR_VAR 0 46
38428: PUSH
38429: LD_INT 0
38431: PUSH
38432: LD_INT 0
38434: PUSH
38435: EMPTY
38436: LIST
38437: LIST
38438: PUSH
38439: LD_INT 0
38441: PUSH
38442: LD_INT 1
38444: NEG
38445: PUSH
38446: EMPTY
38447: LIST
38448: LIST
38449: PUSH
38450: LD_INT 1
38452: PUSH
38453: LD_INT 0
38455: PUSH
38456: EMPTY
38457: LIST
38458: LIST
38459: PUSH
38460: LD_INT 1
38462: PUSH
38463: LD_INT 1
38465: PUSH
38466: EMPTY
38467: LIST
38468: LIST
38469: PUSH
38470: LD_INT 0
38472: PUSH
38473: LD_INT 1
38475: PUSH
38476: EMPTY
38477: LIST
38478: LIST
38479: PUSH
38480: LD_INT 1
38482: NEG
38483: PUSH
38484: LD_INT 0
38486: PUSH
38487: EMPTY
38488: LIST
38489: LIST
38490: PUSH
38491: LD_INT 1
38493: NEG
38494: PUSH
38495: LD_INT 1
38497: NEG
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 1
38505: NEG
38506: PUSH
38507: LD_INT 2
38509: NEG
38510: PUSH
38511: EMPTY
38512: LIST
38513: LIST
38514: PUSH
38515: LD_INT 0
38517: PUSH
38518: LD_INT 2
38520: NEG
38521: PUSH
38522: EMPTY
38523: LIST
38524: LIST
38525: PUSH
38526: LD_INT 1
38528: PUSH
38529: LD_INT 1
38531: NEG
38532: PUSH
38533: EMPTY
38534: LIST
38535: LIST
38536: PUSH
38537: LD_INT 2
38539: PUSH
38540: LD_INT 0
38542: PUSH
38543: EMPTY
38544: LIST
38545: LIST
38546: PUSH
38547: LD_INT 2
38549: PUSH
38550: LD_INT 1
38552: PUSH
38553: EMPTY
38554: LIST
38555: LIST
38556: PUSH
38557: LD_INT 1
38559: PUSH
38560: LD_INT 2
38562: PUSH
38563: EMPTY
38564: LIST
38565: LIST
38566: PUSH
38567: LD_INT 0
38569: PUSH
38570: LD_INT 2
38572: PUSH
38573: EMPTY
38574: LIST
38575: LIST
38576: PUSH
38577: LD_INT 1
38579: NEG
38580: PUSH
38581: LD_INT 1
38583: PUSH
38584: EMPTY
38585: LIST
38586: LIST
38587: PUSH
38588: LD_INT 2
38590: NEG
38591: PUSH
38592: LD_INT 0
38594: PUSH
38595: EMPTY
38596: LIST
38597: LIST
38598: PUSH
38599: LD_INT 2
38601: NEG
38602: PUSH
38603: LD_INT 1
38605: NEG
38606: PUSH
38607: EMPTY
38608: LIST
38609: LIST
38610: PUSH
38611: LD_INT 1
38613: NEG
38614: PUSH
38615: LD_INT 3
38617: NEG
38618: PUSH
38619: EMPTY
38620: LIST
38621: LIST
38622: PUSH
38623: LD_INT 0
38625: PUSH
38626: LD_INT 3
38628: NEG
38629: PUSH
38630: EMPTY
38631: LIST
38632: LIST
38633: PUSH
38634: LD_INT 1
38636: PUSH
38637: LD_INT 2
38639: NEG
38640: PUSH
38641: EMPTY
38642: LIST
38643: LIST
38644: PUSH
38645: LD_INT 2
38647: PUSH
38648: LD_INT 1
38650: NEG
38651: PUSH
38652: EMPTY
38653: LIST
38654: LIST
38655: PUSH
38656: LD_INT 3
38658: PUSH
38659: LD_INT 0
38661: PUSH
38662: EMPTY
38663: LIST
38664: LIST
38665: PUSH
38666: LD_INT 3
38668: PUSH
38669: LD_INT 1
38671: PUSH
38672: EMPTY
38673: LIST
38674: LIST
38675: PUSH
38676: LD_INT 1
38678: PUSH
38679: LD_INT 3
38681: PUSH
38682: EMPTY
38683: LIST
38684: LIST
38685: PUSH
38686: LD_INT 0
38688: PUSH
38689: LD_INT 3
38691: PUSH
38692: EMPTY
38693: LIST
38694: LIST
38695: PUSH
38696: LD_INT 1
38698: NEG
38699: PUSH
38700: LD_INT 2
38702: PUSH
38703: EMPTY
38704: LIST
38705: LIST
38706: PUSH
38707: LD_INT 2
38709: NEG
38710: PUSH
38711: LD_INT 1
38713: PUSH
38714: EMPTY
38715: LIST
38716: LIST
38717: PUSH
38718: LD_INT 3
38720: NEG
38721: PUSH
38722: LD_INT 0
38724: PUSH
38725: EMPTY
38726: LIST
38727: LIST
38728: PUSH
38729: LD_INT 3
38731: NEG
38732: PUSH
38733: LD_INT 1
38735: NEG
38736: PUSH
38737: EMPTY
38738: LIST
38739: LIST
38740: PUSH
38741: EMPTY
38742: LIST
38743: LIST
38744: LIST
38745: LIST
38746: LIST
38747: LIST
38748: LIST
38749: LIST
38750: LIST
38751: LIST
38752: LIST
38753: LIST
38754: LIST
38755: LIST
38756: LIST
38757: LIST
38758: LIST
38759: LIST
38760: LIST
38761: LIST
38762: LIST
38763: LIST
38764: LIST
38765: LIST
38766: LIST
38767: LIST
38768: LIST
38769: LIST
38770: LIST
38771: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38772: LD_ADDR_VAR 0 47
38776: PUSH
38777: LD_INT 0
38779: PUSH
38780: LD_INT 0
38782: PUSH
38783: EMPTY
38784: LIST
38785: LIST
38786: PUSH
38787: LD_INT 0
38789: PUSH
38790: LD_INT 1
38792: NEG
38793: PUSH
38794: EMPTY
38795: LIST
38796: LIST
38797: PUSH
38798: LD_INT 1
38800: PUSH
38801: LD_INT 0
38803: PUSH
38804: EMPTY
38805: LIST
38806: LIST
38807: PUSH
38808: LD_INT 1
38810: PUSH
38811: LD_INT 1
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: PUSH
38818: LD_INT 0
38820: PUSH
38821: LD_INT 1
38823: PUSH
38824: EMPTY
38825: LIST
38826: LIST
38827: PUSH
38828: LD_INT 1
38830: NEG
38831: PUSH
38832: LD_INT 0
38834: PUSH
38835: EMPTY
38836: LIST
38837: LIST
38838: PUSH
38839: LD_INT 1
38841: NEG
38842: PUSH
38843: LD_INT 1
38845: NEG
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: PUSH
38851: LD_INT 1
38853: NEG
38854: PUSH
38855: LD_INT 2
38857: NEG
38858: PUSH
38859: EMPTY
38860: LIST
38861: LIST
38862: PUSH
38863: LD_INT 0
38865: PUSH
38866: LD_INT 2
38868: NEG
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: PUSH
38874: LD_INT 1
38876: PUSH
38877: LD_INT 1
38879: NEG
38880: PUSH
38881: EMPTY
38882: LIST
38883: LIST
38884: PUSH
38885: LD_INT 2
38887: NEG
38888: PUSH
38889: LD_INT 1
38891: NEG
38892: PUSH
38893: EMPTY
38894: LIST
38895: LIST
38896: PUSH
38897: LD_INT 2
38899: NEG
38900: PUSH
38901: LD_INT 2
38903: NEG
38904: PUSH
38905: EMPTY
38906: LIST
38907: LIST
38908: PUSH
38909: EMPTY
38910: LIST
38911: LIST
38912: LIST
38913: LIST
38914: LIST
38915: LIST
38916: LIST
38917: LIST
38918: LIST
38919: LIST
38920: LIST
38921: LIST
38922: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38923: LD_ADDR_VAR 0 48
38927: PUSH
38928: LD_INT 0
38930: PUSH
38931: LD_INT 0
38933: PUSH
38934: EMPTY
38935: LIST
38936: LIST
38937: PUSH
38938: LD_INT 0
38940: PUSH
38941: LD_INT 1
38943: NEG
38944: PUSH
38945: EMPTY
38946: LIST
38947: LIST
38948: PUSH
38949: LD_INT 1
38951: PUSH
38952: LD_INT 0
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PUSH
38959: LD_INT 1
38961: PUSH
38962: LD_INT 1
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: LD_INT 0
38971: PUSH
38972: LD_INT 1
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: PUSH
38979: LD_INT 1
38981: NEG
38982: PUSH
38983: LD_INT 0
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 1
38992: NEG
38993: PUSH
38994: LD_INT 1
38996: NEG
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 1
39004: NEG
39005: PUSH
39006: LD_INT 2
39008: NEG
39009: PUSH
39010: EMPTY
39011: LIST
39012: LIST
39013: PUSH
39014: LD_INT 0
39016: PUSH
39017: LD_INT 2
39019: NEG
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: LD_INT 1
39027: PUSH
39028: LD_INT 1
39030: NEG
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PUSH
39036: LD_INT 2
39038: PUSH
39039: LD_INT 0
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: LD_INT 2
39048: PUSH
39049: LD_INT 1
39051: PUSH
39052: EMPTY
39053: LIST
39054: LIST
39055: PUSH
39056: EMPTY
39057: LIST
39058: LIST
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: LIST
39066: LIST
39067: LIST
39068: LIST
39069: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39070: LD_ADDR_VAR 0 49
39074: PUSH
39075: LD_INT 0
39077: PUSH
39078: LD_INT 0
39080: PUSH
39081: EMPTY
39082: LIST
39083: LIST
39084: PUSH
39085: LD_INT 0
39087: PUSH
39088: LD_INT 1
39090: NEG
39091: PUSH
39092: EMPTY
39093: LIST
39094: LIST
39095: PUSH
39096: LD_INT 1
39098: PUSH
39099: LD_INT 0
39101: PUSH
39102: EMPTY
39103: LIST
39104: LIST
39105: PUSH
39106: LD_INT 1
39108: PUSH
39109: LD_INT 1
39111: PUSH
39112: EMPTY
39113: LIST
39114: LIST
39115: PUSH
39116: LD_INT 0
39118: PUSH
39119: LD_INT 1
39121: PUSH
39122: EMPTY
39123: LIST
39124: LIST
39125: PUSH
39126: LD_INT 1
39128: NEG
39129: PUSH
39130: LD_INT 0
39132: PUSH
39133: EMPTY
39134: LIST
39135: LIST
39136: PUSH
39137: LD_INT 1
39139: NEG
39140: PUSH
39141: LD_INT 1
39143: NEG
39144: PUSH
39145: EMPTY
39146: LIST
39147: LIST
39148: PUSH
39149: LD_INT 1
39151: PUSH
39152: LD_INT 1
39154: NEG
39155: PUSH
39156: EMPTY
39157: LIST
39158: LIST
39159: PUSH
39160: LD_INT 2
39162: PUSH
39163: LD_INT 0
39165: PUSH
39166: EMPTY
39167: LIST
39168: LIST
39169: PUSH
39170: LD_INT 2
39172: PUSH
39173: LD_INT 1
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: PUSH
39180: LD_INT 2
39182: PUSH
39183: LD_INT 2
39185: PUSH
39186: EMPTY
39187: LIST
39188: LIST
39189: PUSH
39190: LD_INT 1
39192: PUSH
39193: LD_INT 2
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: EMPTY
39201: LIST
39202: LIST
39203: LIST
39204: LIST
39205: LIST
39206: LIST
39207: LIST
39208: LIST
39209: LIST
39210: LIST
39211: LIST
39212: LIST
39213: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39214: LD_ADDR_VAR 0 50
39218: PUSH
39219: LD_INT 0
39221: PUSH
39222: LD_INT 0
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PUSH
39229: LD_INT 0
39231: PUSH
39232: LD_INT 1
39234: NEG
39235: PUSH
39236: EMPTY
39237: LIST
39238: LIST
39239: PUSH
39240: LD_INT 1
39242: PUSH
39243: LD_INT 0
39245: PUSH
39246: EMPTY
39247: LIST
39248: LIST
39249: PUSH
39250: LD_INT 1
39252: PUSH
39253: LD_INT 1
39255: PUSH
39256: EMPTY
39257: LIST
39258: LIST
39259: PUSH
39260: LD_INT 0
39262: PUSH
39263: LD_INT 1
39265: PUSH
39266: EMPTY
39267: LIST
39268: LIST
39269: PUSH
39270: LD_INT 1
39272: NEG
39273: PUSH
39274: LD_INT 0
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: PUSH
39281: LD_INT 1
39283: NEG
39284: PUSH
39285: LD_INT 1
39287: NEG
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: PUSH
39293: LD_INT 2
39295: PUSH
39296: LD_INT 1
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: PUSH
39303: LD_INT 2
39305: PUSH
39306: LD_INT 2
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: LD_INT 1
39315: PUSH
39316: LD_INT 2
39318: PUSH
39319: EMPTY
39320: LIST
39321: LIST
39322: PUSH
39323: LD_INT 0
39325: PUSH
39326: LD_INT 2
39328: PUSH
39329: EMPTY
39330: LIST
39331: LIST
39332: PUSH
39333: LD_INT 1
39335: NEG
39336: PUSH
39337: LD_INT 1
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: EMPTY
39345: LIST
39346: LIST
39347: LIST
39348: LIST
39349: LIST
39350: LIST
39351: LIST
39352: LIST
39353: LIST
39354: LIST
39355: LIST
39356: LIST
39357: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39358: LD_ADDR_VAR 0 51
39362: PUSH
39363: LD_INT 0
39365: PUSH
39366: LD_INT 0
39368: PUSH
39369: EMPTY
39370: LIST
39371: LIST
39372: PUSH
39373: LD_INT 0
39375: PUSH
39376: LD_INT 1
39378: NEG
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: LD_INT 1
39386: PUSH
39387: LD_INT 0
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 1
39396: PUSH
39397: LD_INT 1
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: LD_INT 0
39406: PUSH
39407: LD_INT 1
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: PUSH
39414: LD_INT 1
39416: NEG
39417: PUSH
39418: LD_INT 0
39420: PUSH
39421: EMPTY
39422: LIST
39423: LIST
39424: PUSH
39425: LD_INT 1
39427: NEG
39428: PUSH
39429: LD_INT 1
39431: NEG
39432: PUSH
39433: EMPTY
39434: LIST
39435: LIST
39436: PUSH
39437: LD_INT 1
39439: PUSH
39440: LD_INT 2
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 0
39449: PUSH
39450: LD_INT 2
39452: PUSH
39453: EMPTY
39454: LIST
39455: LIST
39456: PUSH
39457: LD_INT 1
39459: NEG
39460: PUSH
39461: LD_INT 1
39463: PUSH
39464: EMPTY
39465: LIST
39466: LIST
39467: PUSH
39468: LD_INT 2
39470: NEG
39471: PUSH
39472: LD_INT 0
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PUSH
39479: LD_INT 2
39481: NEG
39482: PUSH
39483: LD_INT 1
39485: NEG
39486: PUSH
39487: EMPTY
39488: LIST
39489: LIST
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: LIST
39495: LIST
39496: LIST
39497: LIST
39498: LIST
39499: LIST
39500: LIST
39501: LIST
39502: LIST
39503: LIST
39504: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39505: LD_ADDR_VAR 0 52
39509: PUSH
39510: LD_INT 0
39512: PUSH
39513: LD_INT 0
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 0
39522: PUSH
39523: LD_INT 1
39525: NEG
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 1
39533: PUSH
39534: LD_INT 0
39536: PUSH
39537: EMPTY
39538: LIST
39539: LIST
39540: PUSH
39541: LD_INT 1
39543: PUSH
39544: LD_INT 1
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: LD_INT 0
39553: PUSH
39554: LD_INT 1
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 1
39563: NEG
39564: PUSH
39565: LD_INT 0
39567: PUSH
39568: EMPTY
39569: LIST
39570: LIST
39571: PUSH
39572: LD_INT 1
39574: NEG
39575: PUSH
39576: LD_INT 1
39578: NEG
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 1
39586: NEG
39587: PUSH
39588: LD_INT 2
39590: NEG
39591: PUSH
39592: EMPTY
39593: LIST
39594: LIST
39595: PUSH
39596: LD_INT 1
39598: NEG
39599: PUSH
39600: LD_INT 1
39602: PUSH
39603: EMPTY
39604: LIST
39605: LIST
39606: PUSH
39607: LD_INT 2
39609: NEG
39610: PUSH
39611: LD_INT 0
39613: PUSH
39614: EMPTY
39615: LIST
39616: LIST
39617: PUSH
39618: LD_INT 2
39620: NEG
39621: PUSH
39622: LD_INT 1
39624: NEG
39625: PUSH
39626: EMPTY
39627: LIST
39628: LIST
39629: PUSH
39630: LD_INT 2
39632: NEG
39633: PUSH
39634: LD_INT 2
39636: NEG
39637: PUSH
39638: EMPTY
39639: LIST
39640: LIST
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: LIST
39646: LIST
39647: LIST
39648: LIST
39649: LIST
39650: LIST
39651: LIST
39652: LIST
39653: LIST
39654: LIST
39655: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39656: LD_ADDR_VAR 0 53
39660: PUSH
39661: LD_INT 0
39663: PUSH
39664: LD_INT 0
39666: PUSH
39667: EMPTY
39668: LIST
39669: LIST
39670: PUSH
39671: LD_INT 0
39673: PUSH
39674: LD_INT 1
39676: NEG
39677: PUSH
39678: EMPTY
39679: LIST
39680: LIST
39681: PUSH
39682: LD_INT 1
39684: PUSH
39685: LD_INT 0
39687: PUSH
39688: EMPTY
39689: LIST
39690: LIST
39691: PUSH
39692: LD_INT 1
39694: PUSH
39695: LD_INT 1
39697: PUSH
39698: EMPTY
39699: LIST
39700: LIST
39701: PUSH
39702: LD_INT 0
39704: PUSH
39705: LD_INT 1
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 1
39714: NEG
39715: PUSH
39716: LD_INT 0
39718: PUSH
39719: EMPTY
39720: LIST
39721: LIST
39722: PUSH
39723: LD_INT 1
39725: NEG
39726: PUSH
39727: LD_INT 1
39729: NEG
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: LD_INT 1
39737: NEG
39738: PUSH
39739: LD_INT 2
39741: NEG
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 0
39749: PUSH
39750: LD_INT 2
39752: NEG
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 1
39760: PUSH
39761: LD_INT 1
39763: NEG
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 2
39771: PUSH
39772: LD_INT 0
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 2
39781: PUSH
39782: LD_INT 1
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: PUSH
39789: LD_INT 2
39791: PUSH
39792: LD_INT 2
39794: PUSH
39795: EMPTY
39796: LIST
39797: LIST
39798: PUSH
39799: LD_INT 1
39801: PUSH
39802: LD_INT 2
39804: PUSH
39805: EMPTY
39806: LIST
39807: LIST
39808: PUSH
39809: LD_INT 0
39811: PUSH
39812: LD_INT 2
39814: PUSH
39815: EMPTY
39816: LIST
39817: LIST
39818: PUSH
39819: LD_INT 1
39821: NEG
39822: PUSH
39823: LD_INT 1
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: LD_INT 2
39832: NEG
39833: PUSH
39834: LD_INT 0
39836: PUSH
39837: EMPTY
39838: LIST
39839: LIST
39840: PUSH
39841: LD_INT 2
39843: NEG
39844: PUSH
39845: LD_INT 1
39847: NEG
39848: PUSH
39849: EMPTY
39850: LIST
39851: LIST
39852: PUSH
39853: LD_INT 2
39855: NEG
39856: PUSH
39857: LD_INT 2
39859: NEG
39860: PUSH
39861: EMPTY
39862: LIST
39863: LIST
39864: PUSH
39865: EMPTY
39866: LIST
39867: LIST
39868: LIST
39869: LIST
39870: LIST
39871: LIST
39872: LIST
39873: LIST
39874: LIST
39875: LIST
39876: LIST
39877: LIST
39878: LIST
39879: LIST
39880: LIST
39881: LIST
39882: LIST
39883: LIST
39884: LIST
39885: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39886: LD_ADDR_VAR 0 54
39890: PUSH
39891: LD_INT 0
39893: PUSH
39894: LD_INT 0
39896: PUSH
39897: EMPTY
39898: LIST
39899: LIST
39900: PUSH
39901: LD_INT 0
39903: PUSH
39904: LD_INT 1
39906: NEG
39907: PUSH
39908: EMPTY
39909: LIST
39910: LIST
39911: PUSH
39912: LD_INT 1
39914: PUSH
39915: LD_INT 0
39917: PUSH
39918: EMPTY
39919: LIST
39920: LIST
39921: PUSH
39922: LD_INT 1
39924: PUSH
39925: LD_INT 1
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: LD_INT 0
39934: PUSH
39935: LD_INT 1
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: LD_INT 1
39944: NEG
39945: PUSH
39946: LD_INT 0
39948: PUSH
39949: EMPTY
39950: LIST
39951: LIST
39952: PUSH
39953: LD_INT 1
39955: NEG
39956: PUSH
39957: LD_INT 1
39959: NEG
39960: PUSH
39961: EMPTY
39962: LIST
39963: LIST
39964: PUSH
39965: LD_INT 1
39967: NEG
39968: PUSH
39969: LD_INT 2
39971: NEG
39972: PUSH
39973: EMPTY
39974: LIST
39975: LIST
39976: PUSH
39977: LD_INT 0
39979: PUSH
39980: LD_INT 2
39982: NEG
39983: PUSH
39984: EMPTY
39985: LIST
39986: LIST
39987: PUSH
39988: LD_INT 1
39990: PUSH
39991: LD_INT 1
39993: NEG
39994: PUSH
39995: EMPTY
39996: LIST
39997: LIST
39998: PUSH
39999: LD_INT 2
40001: PUSH
40002: LD_INT 0
40004: PUSH
40005: EMPTY
40006: LIST
40007: LIST
40008: PUSH
40009: LD_INT 2
40011: PUSH
40012: LD_INT 1
40014: PUSH
40015: EMPTY
40016: LIST
40017: LIST
40018: PUSH
40019: LD_INT 2
40021: PUSH
40022: LD_INT 2
40024: PUSH
40025: EMPTY
40026: LIST
40027: LIST
40028: PUSH
40029: LD_INT 1
40031: PUSH
40032: LD_INT 2
40034: PUSH
40035: EMPTY
40036: LIST
40037: LIST
40038: PUSH
40039: LD_INT 0
40041: PUSH
40042: LD_INT 2
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: LD_INT 1
40051: NEG
40052: PUSH
40053: LD_INT 1
40055: PUSH
40056: EMPTY
40057: LIST
40058: LIST
40059: PUSH
40060: LD_INT 2
40062: NEG
40063: PUSH
40064: LD_INT 0
40066: PUSH
40067: EMPTY
40068: LIST
40069: LIST
40070: PUSH
40071: LD_INT 2
40073: NEG
40074: PUSH
40075: LD_INT 1
40077: NEG
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 2
40085: NEG
40086: PUSH
40087: LD_INT 2
40089: NEG
40090: PUSH
40091: EMPTY
40092: LIST
40093: LIST
40094: PUSH
40095: EMPTY
40096: LIST
40097: LIST
40098: LIST
40099: LIST
40100: LIST
40101: LIST
40102: LIST
40103: LIST
40104: LIST
40105: LIST
40106: LIST
40107: LIST
40108: LIST
40109: LIST
40110: LIST
40111: LIST
40112: LIST
40113: LIST
40114: LIST
40115: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40116: LD_ADDR_VAR 0 55
40120: PUSH
40121: LD_INT 0
40123: PUSH
40124: LD_INT 0
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: PUSH
40131: LD_INT 0
40133: PUSH
40134: LD_INT 1
40136: NEG
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: PUSH
40142: LD_INT 1
40144: PUSH
40145: LD_INT 0
40147: PUSH
40148: EMPTY
40149: LIST
40150: LIST
40151: PUSH
40152: LD_INT 1
40154: PUSH
40155: LD_INT 1
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 0
40164: PUSH
40165: LD_INT 1
40167: PUSH
40168: EMPTY
40169: LIST
40170: LIST
40171: PUSH
40172: LD_INT 1
40174: NEG
40175: PUSH
40176: LD_INT 0
40178: PUSH
40179: EMPTY
40180: LIST
40181: LIST
40182: PUSH
40183: LD_INT 1
40185: NEG
40186: PUSH
40187: LD_INT 1
40189: NEG
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: PUSH
40195: LD_INT 1
40197: NEG
40198: PUSH
40199: LD_INT 2
40201: NEG
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 0
40209: PUSH
40210: LD_INT 2
40212: NEG
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: PUSH
40218: LD_INT 1
40220: PUSH
40221: LD_INT 1
40223: NEG
40224: PUSH
40225: EMPTY
40226: LIST
40227: LIST
40228: PUSH
40229: LD_INT 2
40231: PUSH
40232: LD_INT 0
40234: PUSH
40235: EMPTY
40236: LIST
40237: LIST
40238: PUSH
40239: LD_INT 2
40241: PUSH
40242: LD_INT 1
40244: PUSH
40245: EMPTY
40246: LIST
40247: LIST
40248: PUSH
40249: LD_INT 2
40251: PUSH
40252: LD_INT 2
40254: PUSH
40255: EMPTY
40256: LIST
40257: LIST
40258: PUSH
40259: LD_INT 1
40261: PUSH
40262: LD_INT 2
40264: PUSH
40265: EMPTY
40266: LIST
40267: LIST
40268: PUSH
40269: LD_INT 0
40271: PUSH
40272: LD_INT 2
40274: PUSH
40275: EMPTY
40276: LIST
40277: LIST
40278: PUSH
40279: LD_INT 1
40281: NEG
40282: PUSH
40283: LD_INT 1
40285: PUSH
40286: EMPTY
40287: LIST
40288: LIST
40289: PUSH
40290: LD_INT 2
40292: NEG
40293: PUSH
40294: LD_INT 0
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 2
40303: NEG
40304: PUSH
40305: LD_INT 1
40307: NEG
40308: PUSH
40309: EMPTY
40310: LIST
40311: LIST
40312: PUSH
40313: LD_INT 2
40315: NEG
40316: PUSH
40317: LD_INT 2
40319: NEG
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: LIST
40329: LIST
40330: LIST
40331: LIST
40332: LIST
40333: LIST
40334: LIST
40335: LIST
40336: LIST
40337: LIST
40338: LIST
40339: LIST
40340: LIST
40341: LIST
40342: LIST
40343: LIST
40344: LIST
40345: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40346: LD_ADDR_VAR 0 56
40350: PUSH
40351: LD_INT 0
40353: PUSH
40354: LD_INT 0
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 0
40363: PUSH
40364: LD_INT 1
40366: NEG
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: PUSH
40372: LD_INT 1
40374: PUSH
40375: LD_INT 0
40377: PUSH
40378: EMPTY
40379: LIST
40380: LIST
40381: PUSH
40382: LD_INT 1
40384: PUSH
40385: LD_INT 1
40387: PUSH
40388: EMPTY
40389: LIST
40390: LIST
40391: PUSH
40392: LD_INT 0
40394: PUSH
40395: LD_INT 1
40397: PUSH
40398: EMPTY
40399: LIST
40400: LIST
40401: PUSH
40402: LD_INT 1
40404: NEG
40405: PUSH
40406: LD_INT 0
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: LD_INT 1
40415: NEG
40416: PUSH
40417: LD_INT 1
40419: NEG
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: PUSH
40425: LD_INT 1
40427: NEG
40428: PUSH
40429: LD_INT 2
40431: NEG
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: PUSH
40437: LD_INT 0
40439: PUSH
40440: LD_INT 2
40442: NEG
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: PUSH
40448: LD_INT 1
40450: PUSH
40451: LD_INT 1
40453: NEG
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: LD_INT 2
40461: PUSH
40462: LD_INT 0
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: LD_INT 2
40471: PUSH
40472: LD_INT 1
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: PUSH
40479: LD_INT 2
40481: PUSH
40482: LD_INT 2
40484: PUSH
40485: EMPTY
40486: LIST
40487: LIST
40488: PUSH
40489: LD_INT 1
40491: PUSH
40492: LD_INT 2
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: LD_INT 0
40501: PUSH
40502: LD_INT 2
40504: PUSH
40505: EMPTY
40506: LIST
40507: LIST
40508: PUSH
40509: LD_INT 1
40511: NEG
40512: PUSH
40513: LD_INT 1
40515: PUSH
40516: EMPTY
40517: LIST
40518: LIST
40519: PUSH
40520: LD_INT 2
40522: NEG
40523: PUSH
40524: LD_INT 0
40526: PUSH
40527: EMPTY
40528: LIST
40529: LIST
40530: PUSH
40531: LD_INT 2
40533: NEG
40534: PUSH
40535: LD_INT 1
40537: NEG
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: LD_INT 2
40545: NEG
40546: PUSH
40547: LD_INT 2
40549: NEG
40550: PUSH
40551: EMPTY
40552: LIST
40553: LIST
40554: PUSH
40555: EMPTY
40556: LIST
40557: LIST
40558: LIST
40559: LIST
40560: LIST
40561: LIST
40562: LIST
40563: LIST
40564: LIST
40565: LIST
40566: LIST
40567: LIST
40568: LIST
40569: LIST
40570: LIST
40571: LIST
40572: LIST
40573: LIST
40574: LIST
40575: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40576: LD_ADDR_VAR 0 57
40580: PUSH
40581: LD_INT 0
40583: PUSH
40584: LD_INT 0
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PUSH
40591: LD_INT 0
40593: PUSH
40594: LD_INT 1
40596: NEG
40597: PUSH
40598: EMPTY
40599: LIST
40600: LIST
40601: PUSH
40602: LD_INT 1
40604: PUSH
40605: LD_INT 0
40607: PUSH
40608: EMPTY
40609: LIST
40610: LIST
40611: PUSH
40612: LD_INT 1
40614: PUSH
40615: LD_INT 1
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: PUSH
40622: LD_INT 0
40624: PUSH
40625: LD_INT 1
40627: PUSH
40628: EMPTY
40629: LIST
40630: LIST
40631: PUSH
40632: LD_INT 1
40634: NEG
40635: PUSH
40636: LD_INT 0
40638: PUSH
40639: EMPTY
40640: LIST
40641: LIST
40642: PUSH
40643: LD_INT 1
40645: NEG
40646: PUSH
40647: LD_INT 1
40649: NEG
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: PUSH
40655: LD_INT 1
40657: NEG
40658: PUSH
40659: LD_INT 2
40661: NEG
40662: PUSH
40663: EMPTY
40664: LIST
40665: LIST
40666: PUSH
40667: LD_INT 0
40669: PUSH
40670: LD_INT 2
40672: NEG
40673: PUSH
40674: EMPTY
40675: LIST
40676: LIST
40677: PUSH
40678: LD_INT 1
40680: PUSH
40681: LD_INT 1
40683: NEG
40684: PUSH
40685: EMPTY
40686: LIST
40687: LIST
40688: PUSH
40689: LD_INT 2
40691: PUSH
40692: LD_INT 0
40694: PUSH
40695: EMPTY
40696: LIST
40697: LIST
40698: PUSH
40699: LD_INT 2
40701: PUSH
40702: LD_INT 1
40704: PUSH
40705: EMPTY
40706: LIST
40707: LIST
40708: PUSH
40709: LD_INT 2
40711: PUSH
40712: LD_INT 2
40714: PUSH
40715: EMPTY
40716: LIST
40717: LIST
40718: PUSH
40719: LD_INT 1
40721: PUSH
40722: LD_INT 2
40724: PUSH
40725: EMPTY
40726: LIST
40727: LIST
40728: PUSH
40729: LD_INT 0
40731: PUSH
40732: LD_INT 2
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: PUSH
40739: LD_INT 1
40741: NEG
40742: PUSH
40743: LD_INT 1
40745: PUSH
40746: EMPTY
40747: LIST
40748: LIST
40749: PUSH
40750: LD_INT 2
40752: NEG
40753: PUSH
40754: LD_INT 0
40756: PUSH
40757: EMPTY
40758: LIST
40759: LIST
40760: PUSH
40761: LD_INT 2
40763: NEG
40764: PUSH
40765: LD_INT 1
40767: NEG
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: PUSH
40773: LD_INT 2
40775: NEG
40776: PUSH
40777: LD_INT 2
40779: NEG
40780: PUSH
40781: EMPTY
40782: LIST
40783: LIST
40784: PUSH
40785: EMPTY
40786: LIST
40787: LIST
40788: LIST
40789: LIST
40790: LIST
40791: LIST
40792: LIST
40793: LIST
40794: LIST
40795: LIST
40796: LIST
40797: LIST
40798: LIST
40799: LIST
40800: LIST
40801: LIST
40802: LIST
40803: LIST
40804: LIST
40805: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40806: LD_ADDR_VAR 0 58
40810: PUSH
40811: LD_INT 0
40813: PUSH
40814: LD_INT 0
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: PUSH
40821: LD_INT 0
40823: PUSH
40824: LD_INT 1
40826: NEG
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: LD_INT 1
40834: PUSH
40835: LD_INT 0
40837: PUSH
40838: EMPTY
40839: LIST
40840: LIST
40841: PUSH
40842: LD_INT 1
40844: PUSH
40845: LD_INT 1
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: LD_INT 0
40854: PUSH
40855: LD_INT 1
40857: PUSH
40858: EMPTY
40859: LIST
40860: LIST
40861: PUSH
40862: LD_INT 1
40864: NEG
40865: PUSH
40866: LD_INT 0
40868: PUSH
40869: EMPTY
40870: LIST
40871: LIST
40872: PUSH
40873: LD_INT 1
40875: NEG
40876: PUSH
40877: LD_INT 1
40879: NEG
40880: PUSH
40881: EMPTY
40882: LIST
40883: LIST
40884: PUSH
40885: LD_INT 1
40887: NEG
40888: PUSH
40889: LD_INT 2
40891: NEG
40892: PUSH
40893: EMPTY
40894: LIST
40895: LIST
40896: PUSH
40897: LD_INT 0
40899: PUSH
40900: LD_INT 2
40902: NEG
40903: PUSH
40904: EMPTY
40905: LIST
40906: LIST
40907: PUSH
40908: LD_INT 1
40910: PUSH
40911: LD_INT 1
40913: NEG
40914: PUSH
40915: EMPTY
40916: LIST
40917: LIST
40918: PUSH
40919: LD_INT 2
40921: PUSH
40922: LD_INT 0
40924: PUSH
40925: EMPTY
40926: LIST
40927: LIST
40928: PUSH
40929: LD_INT 2
40931: PUSH
40932: LD_INT 1
40934: PUSH
40935: EMPTY
40936: LIST
40937: LIST
40938: PUSH
40939: LD_INT 2
40941: PUSH
40942: LD_INT 2
40944: PUSH
40945: EMPTY
40946: LIST
40947: LIST
40948: PUSH
40949: LD_INT 1
40951: PUSH
40952: LD_INT 2
40954: PUSH
40955: EMPTY
40956: LIST
40957: LIST
40958: PUSH
40959: LD_INT 0
40961: PUSH
40962: LD_INT 2
40964: PUSH
40965: EMPTY
40966: LIST
40967: LIST
40968: PUSH
40969: LD_INT 1
40971: NEG
40972: PUSH
40973: LD_INT 1
40975: PUSH
40976: EMPTY
40977: LIST
40978: LIST
40979: PUSH
40980: LD_INT 2
40982: NEG
40983: PUSH
40984: LD_INT 0
40986: PUSH
40987: EMPTY
40988: LIST
40989: LIST
40990: PUSH
40991: LD_INT 2
40993: NEG
40994: PUSH
40995: LD_INT 1
40997: NEG
40998: PUSH
40999: EMPTY
41000: LIST
41001: LIST
41002: PUSH
41003: LD_INT 2
41005: NEG
41006: PUSH
41007: LD_INT 2
41009: NEG
41010: PUSH
41011: EMPTY
41012: LIST
41013: LIST
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: LIST
41019: LIST
41020: LIST
41021: LIST
41022: LIST
41023: LIST
41024: LIST
41025: LIST
41026: LIST
41027: LIST
41028: LIST
41029: LIST
41030: LIST
41031: LIST
41032: LIST
41033: LIST
41034: LIST
41035: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41036: LD_ADDR_VAR 0 59
41040: PUSH
41041: LD_INT 0
41043: PUSH
41044: LD_INT 0
41046: PUSH
41047: EMPTY
41048: LIST
41049: LIST
41050: PUSH
41051: LD_INT 0
41053: PUSH
41054: LD_INT 1
41056: NEG
41057: PUSH
41058: EMPTY
41059: LIST
41060: LIST
41061: PUSH
41062: LD_INT 1
41064: PUSH
41065: LD_INT 0
41067: PUSH
41068: EMPTY
41069: LIST
41070: LIST
41071: PUSH
41072: LD_INT 1
41074: PUSH
41075: LD_INT 1
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: PUSH
41082: LD_INT 0
41084: PUSH
41085: LD_INT 1
41087: PUSH
41088: EMPTY
41089: LIST
41090: LIST
41091: PUSH
41092: LD_INT 1
41094: NEG
41095: PUSH
41096: LD_INT 0
41098: PUSH
41099: EMPTY
41100: LIST
41101: LIST
41102: PUSH
41103: LD_INT 1
41105: NEG
41106: PUSH
41107: LD_INT 1
41109: NEG
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: LIST
41119: LIST
41120: LIST
41121: LIST
41122: LIST
41123: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41124: LD_ADDR_VAR 0 60
41128: PUSH
41129: LD_INT 0
41131: PUSH
41132: LD_INT 0
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: LD_INT 0
41141: PUSH
41142: LD_INT 1
41144: NEG
41145: PUSH
41146: EMPTY
41147: LIST
41148: LIST
41149: PUSH
41150: LD_INT 1
41152: PUSH
41153: LD_INT 0
41155: PUSH
41156: EMPTY
41157: LIST
41158: LIST
41159: PUSH
41160: LD_INT 1
41162: PUSH
41163: LD_INT 1
41165: PUSH
41166: EMPTY
41167: LIST
41168: LIST
41169: PUSH
41170: LD_INT 0
41172: PUSH
41173: LD_INT 1
41175: PUSH
41176: EMPTY
41177: LIST
41178: LIST
41179: PUSH
41180: LD_INT 1
41182: NEG
41183: PUSH
41184: LD_INT 0
41186: PUSH
41187: EMPTY
41188: LIST
41189: LIST
41190: PUSH
41191: LD_INT 1
41193: NEG
41194: PUSH
41195: LD_INT 1
41197: NEG
41198: PUSH
41199: EMPTY
41200: LIST
41201: LIST
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: LIST
41207: LIST
41208: LIST
41209: LIST
41210: LIST
41211: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41212: LD_ADDR_VAR 0 61
41216: PUSH
41217: LD_INT 0
41219: PUSH
41220: LD_INT 0
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: PUSH
41227: LD_INT 0
41229: PUSH
41230: LD_INT 1
41232: NEG
41233: PUSH
41234: EMPTY
41235: LIST
41236: LIST
41237: PUSH
41238: LD_INT 1
41240: PUSH
41241: LD_INT 0
41243: PUSH
41244: EMPTY
41245: LIST
41246: LIST
41247: PUSH
41248: LD_INT 1
41250: PUSH
41251: LD_INT 1
41253: PUSH
41254: EMPTY
41255: LIST
41256: LIST
41257: PUSH
41258: LD_INT 0
41260: PUSH
41261: LD_INT 1
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: PUSH
41268: LD_INT 1
41270: NEG
41271: PUSH
41272: LD_INT 0
41274: PUSH
41275: EMPTY
41276: LIST
41277: LIST
41278: PUSH
41279: LD_INT 1
41281: NEG
41282: PUSH
41283: LD_INT 1
41285: NEG
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: PUSH
41291: EMPTY
41292: LIST
41293: LIST
41294: LIST
41295: LIST
41296: LIST
41297: LIST
41298: LIST
41299: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41300: LD_ADDR_VAR 0 62
41304: PUSH
41305: LD_INT 0
41307: PUSH
41308: LD_INT 0
41310: PUSH
41311: EMPTY
41312: LIST
41313: LIST
41314: PUSH
41315: LD_INT 0
41317: PUSH
41318: LD_INT 1
41320: NEG
41321: PUSH
41322: EMPTY
41323: LIST
41324: LIST
41325: PUSH
41326: LD_INT 1
41328: PUSH
41329: LD_INT 0
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: PUSH
41336: LD_INT 1
41338: PUSH
41339: LD_INT 1
41341: PUSH
41342: EMPTY
41343: LIST
41344: LIST
41345: PUSH
41346: LD_INT 0
41348: PUSH
41349: LD_INT 1
41351: PUSH
41352: EMPTY
41353: LIST
41354: LIST
41355: PUSH
41356: LD_INT 1
41358: NEG
41359: PUSH
41360: LD_INT 0
41362: PUSH
41363: EMPTY
41364: LIST
41365: LIST
41366: PUSH
41367: LD_INT 1
41369: NEG
41370: PUSH
41371: LD_INT 1
41373: NEG
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: LIST
41383: LIST
41384: LIST
41385: LIST
41386: LIST
41387: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41388: LD_ADDR_VAR 0 63
41392: PUSH
41393: LD_INT 0
41395: PUSH
41396: LD_INT 0
41398: PUSH
41399: EMPTY
41400: LIST
41401: LIST
41402: PUSH
41403: LD_INT 0
41405: PUSH
41406: LD_INT 1
41408: NEG
41409: PUSH
41410: EMPTY
41411: LIST
41412: LIST
41413: PUSH
41414: LD_INT 1
41416: PUSH
41417: LD_INT 0
41419: PUSH
41420: EMPTY
41421: LIST
41422: LIST
41423: PUSH
41424: LD_INT 1
41426: PUSH
41427: LD_INT 1
41429: PUSH
41430: EMPTY
41431: LIST
41432: LIST
41433: PUSH
41434: LD_INT 0
41436: PUSH
41437: LD_INT 1
41439: PUSH
41440: EMPTY
41441: LIST
41442: LIST
41443: PUSH
41444: LD_INT 1
41446: NEG
41447: PUSH
41448: LD_INT 0
41450: PUSH
41451: EMPTY
41452: LIST
41453: LIST
41454: PUSH
41455: LD_INT 1
41457: NEG
41458: PUSH
41459: LD_INT 1
41461: NEG
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: PUSH
41467: EMPTY
41468: LIST
41469: LIST
41470: LIST
41471: LIST
41472: LIST
41473: LIST
41474: LIST
41475: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41476: LD_ADDR_VAR 0 64
41480: PUSH
41481: LD_INT 0
41483: PUSH
41484: LD_INT 0
41486: PUSH
41487: EMPTY
41488: LIST
41489: LIST
41490: PUSH
41491: LD_INT 0
41493: PUSH
41494: LD_INT 1
41496: NEG
41497: PUSH
41498: EMPTY
41499: LIST
41500: LIST
41501: PUSH
41502: LD_INT 1
41504: PUSH
41505: LD_INT 0
41507: PUSH
41508: EMPTY
41509: LIST
41510: LIST
41511: PUSH
41512: LD_INT 1
41514: PUSH
41515: LD_INT 1
41517: PUSH
41518: EMPTY
41519: LIST
41520: LIST
41521: PUSH
41522: LD_INT 0
41524: PUSH
41525: LD_INT 1
41527: PUSH
41528: EMPTY
41529: LIST
41530: LIST
41531: PUSH
41532: LD_INT 1
41534: NEG
41535: PUSH
41536: LD_INT 0
41538: PUSH
41539: EMPTY
41540: LIST
41541: LIST
41542: PUSH
41543: LD_INT 1
41545: NEG
41546: PUSH
41547: LD_INT 1
41549: NEG
41550: PUSH
41551: EMPTY
41552: LIST
41553: LIST
41554: PUSH
41555: EMPTY
41556: LIST
41557: LIST
41558: LIST
41559: LIST
41560: LIST
41561: LIST
41562: LIST
41563: ST_TO_ADDR
// end ; 1 :
41564: GO 47461
41566: LD_INT 1
41568: DOUBLE
41569: EQUAL
41570: IFTRUE 41574
41572: GO 44197
41574: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41575: LD_ADDR_VAR 0 11
41579: PUSH
41580: LD_INT 1
41582: NEG
41583: PUSH
41584: LD_INT 3
41586: NEG
41587: PUSH
41588: EMPTY
41589: LIST
41590: LIST
41591: PUSH
41592: LD_INT 0
41594: PUSH
41595: LD_INT 3
41597: NEG
41598: PUSH
41599: EMPTY
41600: LIST
41601: LIST
41602: PUSH
41603: LD_INT 1
41605: PUSH
41606: LD_INT 2
41608: NEG
41609: PUSH
41610: EMPTY
41611: LIST
41612: LIST
41613: PUSH
41614: EMPTY
41615: LIST
41616: LIST
41617: LIST
41618: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41619: LD_ADDR_VAR 0 12
41623: PUSH
41624: LD_INT 2
41626: PUSH
41627: LD_INT 1
41629: NEG
41630: PUSH
41631: EMPTY
41632: LIST
41633: LIST
41634: PUSH
41635: LD_INT 3
41637: PUSH
41638: LD_INT 0
41640: PUSH
41641: EMPTY
41642: LIST
41643: LIST
41644: PUSH
41645: LD_INT 3
41647: PUSH
41648: LD_INT 1
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: LIST
41659: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41660: LD_ADDR_VAR 0 13
41664: PUSH
41665: LD_INT 3
41667: PUSH
41668: LD_INT 2
41670: PUSH
41671: EMPTY
41672: LIST
41673: LIST
41674: PUSH
41675: LD_INT 3
41677: PUSH
41678: LD_INT 3
41680: PUSH
41681: EMPTY
41682: LIST
41683: LIST
41684: PUSH
41685: LD_INT 2
41687: PUSH
41688: LD_INT 3
41690: PUSH
41691: EMPTY
41692: LIST
41693: LIST
41694: PUSH
41695: EMPTY
41696: LIST
41697: LIST
41698: LIST
41699: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41700: LD_ADDR_VAR 0 14
41704: PUSH
41705: LD_INT 1
41707: PUSH
41708: LD_INT 3
41710: PUSH
41711: EMPTY
41712: LIST
41713: LIST
41714: PUSH
41715: LD_INT 0
41717: PUSH
41718: LD_INT 3
41720: PUSH
41721: EMPTY
41722: LIST
41723: LIST
41724: PUSH
41725: LD_INT 1
41727: NEG
41728: PUSH
41729: LD_INT 2
41731: PUSH
41732: EMPTY
41733: LIST
41734: LIST
41735: PUSH
41736: EMPTY
41737: LIST
41738: LIST
41739: LIST
41740: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41741: LD_ADDR_VAR 0 15
41745: PUSH
41746: LD_INT 2
41748: NEG
41749: PUSH
41750: LD_INT 1
41752: PUSH
41753: EMPTY
41754: LIST
41755: LIST
41756: PUSH
41757: LD_INT 3
41759: NEG
41760: PUSH
41761: LD_INT 0
41763: PUSH
41764: EMPTY
41765: LIST
41766: LIST
41767: PUSH
41768: LD_INT 3
41770: NEG
41771: PUSH
41772: LD_INT 1
41774: NEG
41775: PUSH
41776: EMPTY
41777: LIST
41778: LIST
41779: PUSH
41780: EMPTY
41781: LIST
41782: LIST
41783: LIST
41784: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41785: LD_ADDR_VAR 0 16
41789: PUSH
41790: LD_INT 2
41792: NEG
41793: PUSH
41794: LD_INT 3
41796: NEG
41797: PUSH
41798: EMPTY
41799: LIST
41800: LIST
41801: PUSH
41802: LD_INT 3
41804: NEG
41805: PUSH
41806: LD_INT 2
41808: NEG
41809: PUSH
41810: EMPTY
41811: LIST
41812: LIST
41813: PUSH
41814: LD_INT 3
41816: NEG
41817: PUSH
41818: LD_INT 3
41820: NEG
41821: PUSH
41822: EMPTY
41823: LIST
41824: LIST
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: LIST
41830: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41831: LD_ADDR_VAR 0 17
41835: PUSH
41836: LD_INT 1
41838: NEG
41839: PUSH
41840: LD_INT 3
41842: NEG
41843: PUSH
41844: EMPTY
41845: LIST
41846: LIST
41847: PUSH
41848: LD_INT 0
41850: PUSH
41851: LD_INT 3
41853: NEG
41854: PUSH
41855: EMPTY
41856: LIST
41857: LIST
41858: PUSH
41859: LD_INT 1
41861: PUSH
41862: LD_INT 2
41864: NEG
41865: PUSH
41866: EMPTY
41867: LIST
41868: LIST
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: LIST
41874: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41875: LD_ADDR_VAR 0 18
41879: PUSH
41880: LD_INT 2
41882: PUSH
41883: LD_INT 1
41885: NEG
41886: PUSH
41887: EMPTY
41888: LIST
41889: LIST
41890: PUSH
41891: LD_INT 3
41893: PUSH
41894: LD_INT 0
41896: PUSH
41897: EMPTY
41898: LIST
41899: LIST
41900: PUSH
41901: LD_INT 3
41903: PUSH
41904: LD_INT 1
41906: PUSH
41907: EMPTY
41908: LIST
41909: LIST
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: LIST
41915: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41916: LD_ADDR_VAR 0 19
41920: PUSH
41921: LD_INT 3
41923: PUSH
41924: LD_INT 2
41926: PUSH
41927: EMPTY
41928: LIST
41929: LIST
41930: PUSH
41931: LD_INT 3
41933: PUSH
41934: LD_INT 3
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PUSH
41941: LD_INT 2
41943: PUSH
41944: LD_INT 3
41946: PUSH
41947: EMPTY
41948: LIST
41949: LIST
41950: PUSH
41951: EMPTY
41952: LIST
41953: LIST
41954: LIST
41955: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41956: LD_ADDR_VAR 0 20
41960: PUSH
41961: LD_INT 1
41963: PUSH
41964: LD_INT 3
41966: PUSH
41967: EMPTY
41968: LIST
41969: LIST
41970: PUSH
41971: LD_INT 0
41973: PUSH
41974: LD_INT 3
41976: PUSH
41977: EMPTY
41978: LIST
41979: LIST
41980: PUSH
41981: LD_INT 1
41983: NEG
41984: PUSH
41985: LD_INT 2
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: LIST
41996: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41997: LD_ADDR_VAR 0 21
42001: PUSH
42002: LD_INT 2
42004: NEG
42005: PUSH
42006: LD_INT 1
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: PUSH
42013: LD_INT 3
42015: NEG
42016: PUSH
42017: LD_INT 0
42019: PUSH
42020: EMPTY
42021: LIST
42022: LIST
42023: PUSH
42024: LD_INT 3
42026: NEG
42027: PUSH
42028: LD_INT 1
42030: NEG
42031: PUSH
42032: EMPTY
42033: LIST
42034: LIST
42035: PUSH
42036: EMPTY
42037: LIST
42038: LIST
42039: LIST
42040: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42041: LD_ADDR_VAR 0 22
42045: PUSH
42046: LD_INT 2
42048: NEG
42049: PUSH
42050: LD_INT 3
42052: NEG
42053: PUSH
42054: EMPTY
42055: LIST
42056: LIST
42057: PUSH
42058: LD_INT 3
42060: NEG
42061: PUSH
42062: LD_INT 2
42064: NEG
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: PUSH
42070: LD_INT 3
42072: NEG
42073: PUSH
42074: LD_INT 3
42076: NEG
42077: PUSH
42078: EMPTY
42079: LIST
42080: LIST
42081: PUSH
42082: EMPTY
42083: LIST
42084: LIST
42085: LIST
42086: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
42087: LD_ADDR_VAR 0 23
42091: PUSH
42092: LD_INT 0
42094: PUSH
42095: LD_INT 3
42097: NEG
42098: PUSH
42099: EMPTY
42100: LIST
42101: LIST
42102: PUSH
42103: LD_INT 1
42105: NEG
42106: PUSH
42107: LD_INT 4
42109: NEG
42110: PUSH
42111: EMPTY
42112: LIST
42113: LIST
42114: PUSH
42115: LD_INT 1
42117: PUSH
42118: LD_INT 3
42120: NEG
42121: PUSH
42122: EMPTY
42123: LIST
42124: LIST
42125: PUSH
42126: EMPTY
42127: LIST
42128: LIST
42129: LIST
42130: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
42131: LD_ADDR_VAR 0 24
42135: PUSH
42136: LD_INT 3
42138: PUSH
42139: LD_INT 0
42141: PUSH
42142: EMPTY
42143: LIST
42144: LIST
42145: PUSH
42146: LD_INT 3
42148: PUSH
42149: LD_INT 1
42151: NEG
42152: PUSH
42153: EMPTY
42154: LIST
42155: LIST
42156: PUSH
42157: LD_INT 4
42159: PUSH
42160: LD_INT 1
42162: PUSH
42163: EMPTY
42164: LIST
42165: LIST
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: LIST
42171: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
42172: LD_ADDR_VAR 0 25
42176: PUSH
42177: LD_INT 3
42179: PUSH
42180: LD_INT 3
42182: PUSH
42183: EMPTY
42184: LIST
42185: LIST
42186: PUSH
42187: LD_INT 4
42189: PUSH
42190: LD_INT 3
42192: PUSH
42193: EMPTY
42194: LIST
42195: LIST
42196: PUSH
42197: LD_INT 3
42199: PUSH
42200: LD_INT 4
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: LIST
42211: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
42212: LD_ADDR_VAR 0 26
42216: PUSH
42217: LD_INT 0
42219: PUSH
42220: LD_INT 3
42222: PUSH
42223: EMPTY
42224: LIST
42225: LIST
42226: PUSH
42227: LD_INT 1
42229: PUSH
42230: LD_INT 4
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: LD_INT 1
42239: NEG
42240: PUSH
42241: LD_INT 3
42243: PUSH
42244: EMPTY
42245: LIST
42246: LIST
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: LIST
42252: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
42253: LD_ADDR_VAR 0 27
42257: PUSH
42258: LD_INT 3
42260: NEG
42261: PUSH
42262: LD_INT 0
42264: PUSH
42265: EMPTY
42266: LIST
42267: LIST
42268: PUSH
42269: LD_INT 3
42271: NEG
42272: PUSH
42273: LD_INT 1
42275: PUSH
42276: EMPTY
42277: LIST
42278: LIST
42279: PUSH
42280: LD_INT 4
42282: NEG
42283: PUSH
42284: LD_INT 1
42286: NEG
42287: PUSH
42288: EMPTY
42289: LIST
42290: LIST
42291: PUSH
42292: EMPTY
42293: LIST
42294: LIST
42295: LIST
42296: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
42297: LD_ADDR_VAR 0 28
42301: PUSH
42302: LD_INT 3
42304: NEG
42305: PUSH
42306: LD_INT 3
42308: NEG
42309: PUSH
42310: EMPTY
42311: LIST
42312: LIST
42313: PUSH
42314: LD_INT 3
42316: NEG
42317: PUSH
42318: LD_INT 4
42320: NEG
42321: PUSH
42322: EMPTY
42323: LIST
42324: LIST
42325: PUSH
42326: LD_INT 4
42328: NEG
42329: PUSH
42330: LD_INT 3
42332: NEG
42333: PUSH
42334: EMPTY
42335: LIST
42336: LIST
42337: PUSH
42338: EMPTY
42339: LIST
42340: LIST
42341: LIST
42342: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
42343: LD_ADDR_VAR 0 29
42347: PUSH
42348: LD_INT 1
42350: NEG
42351: PUSH
42352: LD_INT 3
42354: NEG
42355: PUSH
42356: EMPTY
42357: LIST
42358: LIST
42359: PUSH
42360: LD_INT 0
42362: PUSH
42363: LD_INT 3
42365: NEG
42366: PUSH
42367: EMPTY
42368: LIST
42369: LIST
42370: PUSH
42371: LD_INT 1
42373: PUSH
42374: LD_INT 2
42376: NEG
42377: PUSH
42378: EMPTY
42379: LIST
42380: LIST
42381: PUSH
42382: LD_INT 1
42384: NEG
42385: PUSH
42386: LD_INT 4
42388: NEG
42389: PUSH
42390: EMPTY
42391: LIST
42392: LIST
42393: PUSH
42394: LD_INT 0
42396: PUSH
42397: LD_INT 4
42399: NEG
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: LD_INT 1
42407: PUSH
42408: LD_INT 3
42410: NEG
42411: PUSH
42412: EMPTY
42413: LIST
42414: LIST
42415: PUSH
42416: LD_INT 1
42418: NEG
42419: PUSH
42420: LD_INT 5
42422: NEG
42423: PUSH
42424: EMPTY
42425: LIST
42426: LIST
42427: PUSH
42428: LD_INT 0
42430: PUSH
42431: LD_INT 5
42433: NEG
42434: PUSH
42435: EMPTY
42436: LIST
42437: LIST
42438: PUSH
42439: LD_INT 1
42441: PUSH
42442: LD_INT 4
42444: NEG
42445: PUSH
42446: EMPTY
42447: LIST
42448: LIST
42449: PUSH
42450: LD_INT 1
42452: NEG
42453: PUSH
42454: LD_INT 6
42456: NEG
42457: PUSH
42458: EMPTY
42459: LIST
42460: LIST
42461: PUSH
42462: LD_INT 0
42464: PUSH
42465: LD_INT 6
42467: NEG
42468: PUSH
42469: EMPTY
42470: LIST
42471: LIST
42472: PUSH
42473: LD_INT 1
42475: PUSH
42476: LD_INT 5
42478: NEG
42479: PUSH
42480: EMPTY
42481: LIST
42482: LIST
42483: PUSH
42484: EMPTY
42485: LIST
42486: LIST
42487: LIST
42488: LIST
42489: LIST
42490: LIST
42491: LIST
42492: LIST
42493: LIST
42494: LIST
42495: LIST
42496: LIST
42497: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
42498: LD_ADDR_VAR 0 30
42502: PUSH
42503: LD_INT 2
42505: PUSH
42506: LD_INT 1
42508: NEG
42509: PUSH
42510: EMPTY
42511: LIST
42512: LIST
42513: PUSH
42514: LD_INT 3
42516: PUSH
42517: LD_INT 0
42519: PUSH
42520: EMPTY
42521: LIST
42522: LIST
42523: PUSH
42524: LD_INT 3
42526: PUSH
42527: LD_INT 1
42529: PUSH
42530: EMPTY
42531: LIST
42532: LIST
42533: PUSH
42534: LD_INT 3
42536: PUSH
42537: LD_INT 1
42539: NEG
42540: PUSH
42541: EMPTY
42542: LIST
42543: LIST
42544: PUSH
42545: LD_INT 4
42547: PUSH
42548: LD_INT 0
42550: PUSH
42551: EMPTY
42552: LIST
42553: LIST
42554: PUSH
42555: LD_INT 4
42557: PUSH
42558: LD_INT 1
42560: PUSH
42561: EMPTY
42562: LIST
42563: LIST
42564: PUSH
42565: LD_INT 4
42567: PUSH
42568: LD_INT 1
42570: NEG
42571: PUSH
42572: EMPTY
42573: LIST
42574: LIST
42575: PUSH
42576: LD_INT 5
42578: PUSH
42579: LD_INT 0
42581: PUSH
42582: EMPTY
42583: LIST
42584: LIST
42585: PUSH
42586: LD_INT 5
42588: PUSH
42589: LD_INT 1
42591: PUSH
42592: EMPTY
42593: LIST
42594: LIST
42595: PUSH
42596: LD_INT 5
42598: PUSH
42599: LD_INT 1
42601: NEG
42602: PUSH
42603: EMPTY
42604: LIST
42605: LIST
42606: PUSH
42607: LD_INT 6
42609: PUSH
42610: LD_INT 0
42612: PUSH
42613: EMPTY
42614: LIST
42615: LIST
42616: PUSH
42617: LD_INT 6
42619: PUSH
42620: LD_INT 1
42622: PUSH
42623: EMPTY
42624: LIST
42625: LIST
42626: PUSH
42627: EMPTY
42628: LIST
42629: LIST
42630: LIST
42631: LIST
42632: LIST
42633: LIST
42634: LIST
42635: LIST
42636: LIST
42637: LIST
42638: LIST
42639: LIST
42640: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
42641: LD_ADDR_VAR 0 31
42645: PUSH
42646: LD_INT 3
42648: PUSH
42649: LD_INT 2
42651: PUSH
42652: EMPTY
42653: LIST
42654: LIST
42655: PUSH
42656: LD_INT 3
42658: PUSH
42659: LD_INT 3
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PUSH
42666: LD_INT 2
42668: PUSH
42669: LD_INT 3
42671: PUSH
42672: EMPTY
42673: LIST
42674: LIST
42675: PUSH
42676: LD_INT 4
42678: PUSH
42679: LD_INT 3
42681: PUSH
42682: EMPTY
42683: LIST
42684: LIST
42685: PUSH
42686: LD_INT 4
42688: PUSH
42689: LD_INT 4
42691: PUSH
42692: EMPTY
42693: LIST
42694: LIST
42695: PUSH
42696: LD_INT 3
42698: PUSH
42699: LD_INT 4
42701: PUSH
42702: EMPTY
42703: LIST
42704: LIST
42705: PUSH
42706: LD_INT 5
42708: PUSH
42709: LD_INT 4
42711: PUSH
42712: EMPTY
42713: LIST
42714: LIST
42715: PUSH
42716: LD_INT 5
42718: PUSH
42719: LD_INT 5
42721: PUSH
42722: EMPTY
42723: LIST
42724: LIST
42725: PUSH
42726: LD_INT 4
42728: PUSH
42729: LD_INT 5
42731: PUSH
42732: EMPTY
42733: LIST
42734: LIST
42735: PUSH
42736: LD_INT 6
42738: PUSH
42739: LD_INT 5
42741: PUSH
42742: EMPTY
42743: LIST
42744: LIST
42745: PUSH
42746: LD_INT 6
42748: PUSH
42749: LD_INT 6
42751: PUSH
42752: EMPTY
42753: LIST
42754: LIST
42755: PUSH
42756: LD_INT 5
42758: PUSH
42759: LD_INT 6
42761: PUSH
42762: EMPTY
42763: LIST
42764: LIST
42765: PUSH
42766: EMPTY
42767: LIST
42768: LIST
42769: LIST
42770: LIST
42771: LIST
42772: LIST
42773: LIST
42774: LIST
42775: LIST
42776: LIST
42777: LIST
42778: LIST
42779: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42780: LD_ADDR_VAR 0 32
42784: PUSH
42785: LD_INT 1
42787: PUSH
42788: LD_INT 3
42790: PUSH
42791: EMPTY
42792: LIST
42793: LIST
42794: PUSH
42795: LD_INT 0
42797: PUSH
42798: LD_INT 3
42800: PUSH
42801: EMPTY
42802: LIST
42803: LIST
42804: PUSH
42805: LD_INT 1
42807: NEG
42808: PUSH
42809: LD_INT 2
42811: PUSH
42812: EMPTY
42813: LIST
42814: LIST
42815: PUSH
42816: LD_INT 1
42818: PUSH
42819: LD_INT 4
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: PUSH
42826: LD_INT 0
42828: PUSH
42829: LD_INT 4
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: PUSH
42836: LD_INT 1
42838: NEG
42839: PUSH
42840: LD_INT 3
42842: PUSH
42843: EMPTY
42844: LIST
42845: LIST
42846: PUSH
42847: LD_INT 1
42849: PUSH
42850: LD_INT 5
42852: PUSH
42853: EMPTY
42854: LIST
42855: LIST
42856: PUSH
42857: LD_INT 0
42859: PUSH
42860: LD_INT 5
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: LD_INT 1
42869: NEG
42870: PUSH
42871: LD_INT 4
42873: PUSH
42874: EMPTY
42875: LIST
42876: LIST
42877: PUSH
42878: LD_INT 1
42880: PUSH
42881: LD_INT 6
42883: PUSH
42884: EMPTY
42885: LIST
42886: LIST
42887: PUSH
42888: LD_INT 0
42890: PUSH
42891: LD_INT 6
42893: PUSH
42894: EMPTY
42895: LIST
42896: LIST
42897: PUSH
42898: LD_INT 1
42900: NEG
42901: PUSH
42902: LD_INT 5
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: PUSH
42909: EMPTY
42910: LIST
42911: LIST
42912: LIST
42913: LIST
42914: LIST
42915: LIST
42916: LIST
42917: LIST
42918: LIST
42919: LIST
42920: LIST
42921: LIST
42922: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42923: LD_ADDR_VAR 0 33
42927: PUSH
42928: LD_INT 2
42930: NEG
42931: PUSH
42932: LD_INT 1
42934: PUSH
42935: EMPTY
42936: LIST
42937: LIST
42938: PUSH
42939: LD_INT 3
42941: NEG
42942: PUSH
42943: LD_INT 0
42945: PUSH
42946: EMPTY
42947: LIST
42948: LIST
42949: PUSH
42950: LD_INT 3
42952: NEG
42953: PUSH
42954: LD_INT 1
42956: NEG
42957: PUSH
42958: EMPTY
42959: LIST
42960: LIST
42961: PUSH
42962: LD_INT 3
42964: NEG
42965: PUSH
42966: LD_INT 1
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: PUSH
42973: LD_INT 4
42975: NEG
42976: PUSH
42977: LD_INT 0
42979: PUSH
42980: EMPTY
42981: LIST
42982: LIST
42983: PUSH
42984: LD_INT 4
42986: NEG
42987: PUSH
42988: LD_INT 1
42990: NEG
42991: PUSH
42992: EMPTY
42993: LIST
42994: LIST
42995: PUSH
42996: LD_INT 4
42998: NEG
42999: PUSH
43000: LD_INT 1
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: PUSH
43007: LD_INT 5
43009: NEG
43010: PUSH
43011: LD_INT 0
43013: PUSH
43014: EMPTY
43015: LIST
43016: LIST
43017: PUSH
43018: LD_INT 5
43020: NEG
43021: PUSH
43022: LD_INT 1
43024: NEG
43025: PUSH
43026: EMPTY
43027: LIST
43028: LIST
43029: PUSH
43030: LD_INT 5
43032: NEG
43033: PUSH
43034: LD_INT 1
43036: PUSH
43037: EMPTY
43038: LIST
43039: LIST
43040: PUSH
43041: LD_INT 6
43043: NEG
43044: PUSH
43045: LD_INT 0
43047: PUSH
43048: EMPTY
43049: LIST
43050: LIST
43051: PUSH
43052: LD_INT 6
43054: NEG
43055: PUSH
43056: LD_INT 1
43058: NEG
43059: PUSH
43060: EMPTY
43061: LIST
43062: LIST
43063: PUSH
43064: EMPTY
43065: LIST
43066: LIST
43067: LIST
43068: LIST
43069: LIST
43070: LIST
43071: LIST
43072: LIST
43073: LIST
43074: LIST
43075: LIST
43076: LIST
43077: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
43078: LD_ADDR_VAR 0 34
43082: PUSH
43083: LD_INT 2
43085: NEG
43086: PUSH
43087: LD_INT 3
43089: NEG
43090: PUSH
43091: EMPTY
43092: LIST
43093: LIST
43094: PUSH
43095: LD_INT 3
43097: NEG
43098: PUSH
43099: LD_INT 2
43101: NEG
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: PUSH
43107: LD_INT 3
43109: NEG
43110: PUSH
43111: LD_INT 3
43113: NEG
43114: PUSH
43115: EMPTY
43116: LIST
43117: LIST
43118: PUSH
43119: LD_INT 3
43121: NEG
43122: PUSH
43123: LD_INT 4
43125: NEG
43126: PUSH
43127: EMPTY
43128: LIST
43129: LIST
43130: PUSH
43131: LD_INT 4
43133: NEG
43134: PUSH
43135: LD_INT 3
43137: NEG
43138: PUSH
43139: EMPTY
43140: LIST
43141: LIST
43142: PUSH
43143: LD_INT 4
43145: NEG
43146: PUSH
43147: LD_INT 4
43149: NEG
43150: PUSH
43151: EMPTY
43152: LIST
43153: LIST
43154: PUSH
43155: LD_INT 4
43157: NEG
43158: PUSH
43159: LD_INT 5
43161: NEG
43162: PUSH
43163: EMPTY
43164: LIST
43165: LIST
43166: PUSH
43167: LD_INT 5
43169: NEG
43170: PUSH
43171: LD_INT 4
43173: NEG
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PUSH
43179: LD_INT 5
43181: NEG
43182: PUSH
43183: LD_INT 5
43185: NEG
43186: PUSH
43187: EMPTY
43188: LIST
43189: LIST
43190: PUSH
43191: LD_INT 5
43193: NEG
43194: PUSH
43195: LD_INT 6
43197: NEG
43198: PUSH
43199: EMPTY
43200: LIST
43201: LIST
43202: PUSH
43203: LD_INT 6
43205: NEG
43206: PUSH
43207: LD_INT 5
43209: NEG
43210: PUSH
43211: EMPTY
43212: LIST
43213: LIST
43214: PUSH
43215: LD_INT 6
43217: NEG
43218: PUSH
43219: LD_INT 6
43221: NEG
43222: PUSH
43223: EMPTY
43224: LIST
43225: LIST
43226: PUSH
43227: EMPTY
43228: LIST
43229: LIST
43230: LIST
43231: LIST
43232: LIST
43233: LIST
43234: LIST
43235: LIST
43236: LIST
43237: LIST
43238: LIST
43239: LIST
43240: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
43241: LD_ADDR_VAR 0 41
43245: PUSH
43246: LD_INT 0
43248: PUSH
43249: LD_INT 2
43251: NEG
43252: PUSH
43253: EMPTY
43254: LIST
43255: LIST
43256: PUSH
43257: LD_INT 1
43259: NEG
43260: PUSH
43261: LD_INT 3
43263: NEG
43264: PUSH
43265: EMPTY
43266: LIST
43267: LIST
43268: PUSH
43269: LD_INT 1
43271: PUSH
43272: LD_INT 2
43274: NEG
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: LIST
43284: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
43285: LD_ADDR_VAR 0 42
43289: PUSH
43290: LD_INT 2
43292: PUSH
43293: LD_INT 0
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 2
43302: PUSH
43303: LD_INT 1
43305: NEG
43306: PUSH
43307: EMPTY
43308: LIST
43309: LIST
43310: PUSH
43311: LD_INT 3
43313: PUSH
43314: LD_INT 1
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: PUSH
43321: EMPTY
43322: LIST
43323: LIST
43324: LIST
43325: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
43326: LD_ADDR_VAR 0 43
43330: PUSH
43331: LD_INT 2
43333: PUSH
43334: LD_INT 2
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: LD_INT 3
43343: PUSH
43344: LD_INT 2
43346: PUSH
43347: EMPTY
43348: LIST
43349: LIST
43350: PUSH
43351: LD_INT 2
43353: PUSH
43354: LD_INT 3
43356: PUSH
43357: EMPTY
43358: LIST
43359: LIST
43360: PUSH
43361: EMPTY
43362: LIST
43363: LIST
43364: LIST
43365: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
43366: LD_ADDR_VAR 0 44
43370: PUSH
43371: LD_INT 0
43373: PUSH
43374: LD_INT 2
43376: PUSH
43377: EMPTY
43378: LIST
43379: LIST
43380: PUSH
43381: LD_INT 1
43383: PUSH
43384: LD_INT 3
43386: PUSH
43387: EMPTY
43388: LIST
43389: LIST
43390: PUSH
43391: LD_INT 1
43393: NEG
43394: PUSH
43395: LD_INT 2
43397: PUSH
43398: EMPTY
43399: LIST
43400: LIST
43401: PUSH
43402: EMPTY
43403: LIST
43404: LIST
43405: LIST
43406: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
43407: LD_ADDR_VAR 0 45
43411: PUSH
43412: LD_INT 2
43414: NEG
43415: PUSH
43416: LD_INT 0
43418: PUSH
43419: EMPTY
43420: LIST
43421: LIST
43422: PUSH
43423: LD_INT 2
43425: NEG
43426: PUSH
43427: LD_INT 1
43429: PUSH
43430: EMPTY
43431: LIST
43432: LIST
43433: PUSH
43434: LD_INT 3
43436: NEG
43437: PUSH
43438: LD_INT 1
43440: NEG
43441: PUSH
43442: EMPTY
43443: LIST
43444: LIST
43445: PUSH
43446: EMPTY
43447: LIST
43448: LIST
43449: LIST
43450: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
43451: LD_ADDR_VAR 0 46
43455: PUSH
43456: LD_INT 2
43458: NEG
43459: PUSH
43460: LD_INT 2
43462: NEG
43463: PUSH
43464: EMPTY
43465: LIST
43466: LIST
43467: PUSH
43468: LD_INT 2
43470: NEG
43471: PUSH
43472: LD_INT 3
43474: NEG
43475: PUSH
43476: EMPTY
43477: LIST
43478: LIST
43479: PUSH
43480: LD_INT 3
43482: NEG
43483: PUSH
43484: LD_INT 2
43486: NEG
43487: PUSH
43488: EMPTY
43489: LIST
43490: LIST
43491: PUSH
43492: EMPTY
43493: LIST
43494: LIST
43495: LIST
43496: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
43497: LD_ADDR_VAR 0 47
43501: PUSH
43502: LD_INT 2
43504: NEG
43505: PUSH
43506: LD_INT 3
43508: NEG
43509: PUSH
43510: EMPTY
43511: LIST
43512: LIST
43513: PUSH
43514: LD_INT 1
43516: NEG
43517: PUSH
43518: LD_INT 3
43520: NEG
43521: PUSH
43522: EMPTY
43523: LIST
43524: LIST
43525: PUSH
43526: EMPTY
43527: LIST
43528: LIST
43529: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
43530: LD_ADDR_VAR 0 48
43534: PUSH
43535: LD_INT 1
43537: PUSH
43538: LD_INT 2
43540: NEG
43541: PUSH
43542: EMPTY
43543: LIST
43544: LIST
43545: PUSH
43546: LD_INT 2
43548: PUSH
43549: LD_INT 1
43551: NEG
43552: PUSH
43553: EMPTY
43554: LIST
43555: LIST
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
43561: LD_ADDR_VAR 0 49
43565: PUSH
43566: LD_INT 3
43568: PUSH
43569: LD_INT 1
43571: PUSH
43572: EMPTY
43573: LIST
43574: LIST
43575: PUSH
43576: LD_INT 3
43578: PUSH
43579: LD_INT 2
43581: PUSH
43582: EMPTY
43583: LIST
43584: LIST
43585: PUSH
43586: EMPTY
43587: LIST
43588: LIST
43589: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
43590: LD_ADDR_VAR 0 50
43594: PUSH
43595: LD_INT 2
43597: PUSH
43598: LD_INT 3
43600: PUSH
43601: EMPTY
43602: LIST
43603: LIST
43604: PUSH
43605: LD_INT 1
43607: PUSH
43608: LD_INT 3
43610: PUSH
43611: EMPTY
43612: LIST
43613: LIST
43614: PUSH
43615: EMPTY
43616: LIST
43617: LIST
43618: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
43619: LD_ADDR_VAR 0 51
43623: PUSH
43624: LD_INT 1
43626: NEG
43627: PUSH
43628: LD_INT 2
43630: PUSH
43631: EMPTY
43632: LIST
43633: LIST
43634: PUSH
43635: LD_INT 2
43637: NEG
43638: PUSH
43639: LD_INT 1
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: PUSH
43646: EMPTY
43647: LIST
43648: LIST
43649: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
43650: LD_ADDR_VAR 0 52
43654: PUSH
43655: LD_INT 3
43657: NEG
43658: PUSH
43659: LD_INT 1
43661: NEG
43662: PUSH
43663: EMPTY
43664: LIST
43665: LIST
43666: PUSH
43667: LD_INT 3
43669: NEG
43670: PUSH
43671: LD_INT 2
43673: NEG
43674: PUSH
43675: EMPTY
43676: LIST
43677: LIST
43678: PUSH
43679: EMPTY
43680: LIST
43681: LIST
43682: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43683: LD_ADDR_VAR 0 53
43687: PUSH
43688: LD_INT 1
43690: NEG
43691: PUSH
43692: LD_INT 3
43694: NEG
43695: PUSH
43696: EMPTY
43697: LIST
43698: LIST
43699: PUSH
43700: LD_INT 0
43702: PUSH
43703: LD_INT 3
43705: NEG
43706: PUSH
43707: EMPTY
43708: LIST
43709: LIST
43710: PUSH
43711: LD_INT 1
43713: PUSH
43714: LD_INT 2
43716: NEG
43717: PUSH
43718: EMPTY
43719: LIST
43720: LIST
43721: PUSH
43722: EMPTY
43723: LIST
43724: LIST
43725: LIST
43726: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43727: LD_ADDR_VAR 0 54
43731: PUSH
43732: LD_INT 2
43734: PUSH
43735: LD_INT 1
43737: NEG
43738: PUSH
43739: EMPTY
43740: LIST
43741: LIST
43742: PUSH
43743: LD_INT 3
43745: PUSH
43746: LD_INT 0
43748: PUSH
43749: EMPTY
43750: LIST
43751: LIST
43752: PUSH
43753: LD_INT 3
43755: PUSH
43756: LD_INT 1
43758: PUSH
43759: EMPTY
43760: LIST
43761: LIST
43762: PUSH
43763: EMPTY
43764: LIST
43765: LIST
43766: LIST
43767: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43768: LD_ADDR_VAR 0 55
43772: PUSH
43773: LD_INT 3
43775: PUSH
43776: LD_INT 2
43778: PUSH
43779: EMPTY
43780: LIST
43781: LIST
43782: PUSH
43783: LD_INT 3
43785: PUSH
43786: LD_INT 3
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PUSH
43793: LD_INT 2
43795: PUSH
43796: LD_INT 3
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: PUSH
43803: EMPTY
43804: LIST
43805: LIST
43806: LIST
43807: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43808: LD_ADDR_VAR 0 56
43812: PUSH
43813: LD_INT 1
43815: PUSH
43816: LD_INT 3
43818: PUSH
43819: EMPTY
43820: LIST
43821: LIST
43822: PUSH
43823: LD_INT 0
43825: PUSH
43826: LD_INT 3
43828: PUSH
43829: EMPTY
43830: LIST
43831: LIST
43832: PUSH
43833: LD_INT 1
43835: NEG
43836: PUSH
43837: LD_INT 2
43839: PUSH
43840: EMPTY
43841: LIST
43842: LIST
43843: PUSH
43844: EMPTY
43845: LIST
43846: LIST
43847: LIST
43848: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43849: LD_ADDR_VAR 0 57
43853: PUSH
43854: LD_INT 2
43856: NEG
43857: PUSH
43858: LD_INT 1
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: PUSH
43865: LD_INT 3
43867: NEG
43868: PUSH
43869: LD_INT 0
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: PUSH
43876: LD_INT 3
43878: NEG
43879: PUSH
43880: LD_INT 1
43882: NEG
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: PUSH
43888: EMPTY
43889: LIST
43890: LIST
43891: LIST
43892: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43893: LD_ADDR_VAR 0 58
43897: PUSH
43898: LD_INT 2
43900: NEG
43901: PUSH
43902: LD_INT 3
43904: NEG
43905: PUSH
43906: EMPTY
43907: LIST
43908: LIST
43909: PUSH
43910: LD_INT 3
43912: NEG
43913: PUSH
43914: LD_INT 2
43916: NEG
43917: PUSH
43918: EMPTY
43919: LIST
43920: LIST
43921: PUSH
43922: LD_INT 3
43924: NEG
43925: PUSH
43926: LD_INT 3
43928: NEG
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: PUSH
43934: EMPTY
43935: LIST
43936: LIST
43937: LIST
43938: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43939: LD_ADDR_VAR 0 59
43943: PUSH
43944: LD_INT 1
43946: NEG
43947: PUSH
43948: LD_INT 2
43950: NEG
43951: PUSH
43952: EMPTY
43953: LIST
43954: LIST
43955: PUSH
43956: LD_INT 0
43958: PUSH
43959: LD_INT 2
43961: NEG
43962: PUSH
43963: EMPTY
43964: LIST
43965: LIST
43966: PUSH
43967: LD_INT 1
43969: PUSH
43970: LD_INT 1
43972: NEG
43973: PUSH
43974: EMPTY
43975: LIST
43976: LIST
43977: PUSH
43978: EMPTY
43979: LIST
43980: LIST
43981: LIST
43982: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43983: LD_ADDR_VAR 0 60
43987: PUSH
43988: LD_INT 1
43990: PUSH
43991: LD_INT 1
43993: NEG
43994: PUSH
43995: EMPTY
43996: LIST
43997: LIST
43998: PUSH
43999: LD_INT 2
44001: PUSH
44002: LD_INT 0
44004: PUSH
44005: EMPTY
44006: LIST
44007: LIST
44008: PUSH
44009: LD_INT 2
44011: PUSH
44012: LD_INT 1
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: PUSH
44019: EMPTY
44020: LIST
44021: LIST
44022: LIST
44023: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
44024: LD_ADDR_VAR 0 61
44028: PUSH
44029: LD_INT 2
44031: PUSH
44032: LD_INT 1
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PUSH
44039: LD_INT 2
44041: PUSH
44042: LD_INT 2
44044: PUSH
44045: EMPTY
44046: LIST
44047: LIST
44048: PUSH
44049: LD_INT 1
44051: PUSH
44052: LD_INT 2
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: EMPTY
44060: LIST
44061: LIST
44062: LIST
44063: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
44064: LD_ADDR_VAR 0 62
44068: PUSH
44069: LD_INT 1
44071: PUSH
44072: LD_INT 2
44074: PUSH
44075: EMPTY
44076: LIST
44077: LIST
44078: PUSH
44079: LD_INT 0
44081: PUSH
44082: LD_INT 2
44084: PUSH
44085: EMPTY
44086: LIST
44087: LIST
44088: PUSH
44089: LD_INT 1
44091: NEG
44092: PUSH
44093: LD_INT 1
44095: PUSH
44096: EMPTY
44097: LIST
44098: LIST
44099: PUSH
44100: EMPTY
44101: LIST
44102: LIST
44103: LIST
44104: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
44105: LD_ADDR_VAR 0 63
44109: PUSH
44110: LD_INT 1
44112: NEG
44113: PUSH
44114: LD_INT 1
44116: PUSH
44117: EMPTY
44118: LIST
44119: LIST
44120: PUSH
44121: LD_INT 2
44123: NEG
44124: PUSH
44125: LD_INT 0
44127: PUSH
44128: EMPTY
44129: LIST
44130: LIST
44131: PUSH
44132: LD_INT 2
44134: NEG
44135: PUSH
44136: LD_INT 1
44138: NEG
44139: PUSH
44140: EMPTY
44141: LIST
44142: LIST
44143: PUSH
44144: EMPTY
44145: LIST
44146: LIST
44147: LIST
44148: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44149: LD_ADDR_VAR 0 64
44153: PUSH
44154: LD_INT 1
44156: NEG
44157: PUSH
44158: LD_INT 2
44160: NEG
44161: PUSH
44162: EMPTY
44163: LIST
44164: LIST
44165: PUSH
44166: LD_INT 2
44168: NEG
44169: PUSH
44170: LD_INT 1
44172: NEG
44173: PUSH
44174: EMPTY
44175: LIST
44176: LIST
44177: PUSH
44178: LD_INT 2
44180: NEG
44181: PUSH
44182: LD_INT 2
44184: NEG
44185: PUSH
44186: EMPTY
44187: LIST
44188: LIST
44189: PUSH
44190: EMPTY
44191: LIST
44192: LIST
44193: LIST
44194: ST_TO_ADDR
// end ; 2 :
44195: GO 47461
44197: LD_INT 2
44199: DOUBLE
44200: EQUAL
44201: IFTRUE 44205
44203: GO 47460
44205: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
44206: LD_ADDR_VAR 0 29
44210: PUSH
44211: LD_INT 4
44213: PUSH
44214: LD_INT 0
44216: PUSH
44217: EMPTY
44218: LIST
44219: LIST
44220: PUSH
44221: LD_INT 4
44223: PUSH
44224: LD_INT 1
44226: NEG
44227: PUSH
44228: EMPTY
44229: LIST
44230: LIST
44231: PUSH
44232: LD_INT 5
44234: PUSH
44235: LD_INT 0
44237: PUSH
44238: EMPTY
44239: LIST
44240: LIST
44241: PUSH
44242: LD_INT 5
44244: PUSH
44245: LD_INT 1
44247: PUSH
44248: EMPTY
44249: LIST
44250: LIST
44251: PUSH
44252: LD_INT 4
44254: PUSH
44255: LD_INT 1
44257: PUSH
44258: EMPTY
44259: LIST
44260: LIST
44261: PUSH
44262: LD_INT 3
44264: PUSH
44265: LD_INT 0
44267: PUSH
44268: EMPTY
44269: LIST
44270: LIST
44271: PUSH
44272: LD_INT 3
44274: PUSH
44275: LD_INT 1
44277: NEG
44278: PUSH
44279: EMPTY
44280: LIST
44281: LIST
44282: PUSH
44283: LD_INT 3
44285: PUSH
44286: LD_INT 2
44288: NEG
44289: PUSH
44290: EMPTY
44291: LIST
44292: LIST
44293: PUSH
44294: LD_INT 5
44296: PUSH
44297: LD_INT 2
44299: PUSH
44300: EMPTY
44301: LIST
44302: LIST
44303: PUSH
44304: LD_INT 3
44306: PUSH
44307: LD_INT 3
44309: PUSH
44310: EMPTY
44311: LIST
44312: LIST
44313: PUSH
44314: LD_INT 3
44316: PUSH
44317: LD_INT 2
44319: PUSH
44320: EMPTY
44321: LIST
44322: LIST
44323: PUSH
44324: LD_INT 4
44326: PUSH
44327: LD_INT 3
44329: PUSH
44330: EMPTY
44331: LIST
44332: LIST
44333: PUSH
44334: LD_INT 4
44336: PUSH
44337: LD_INT 4
44339: PUSH
44340: EMPTY
44341: LIST
44342: LIST
44343: PUSH
44344: LD_INT 3
44346: PUSH
44347: LD_INT 4
44349: PUSH
44350: EMPTY
44351: LIST
44352: LIST
44353: PUSH
44354: LD_INT 2
44356: PUSH
44357: LD_INT 3
44359: PUSH
44360: EMPTY
44361: LIST
44362: LIST
44363: PUSH
44364: LD_INT 2
44366: PUSH
44367: LD_INT 2
44369: PUSH
44370: EMPTY
44371: LIST
44372: LIST
44373: PUSH
44374: LD_INT 4
44376: PUSH
44377: LD_INT 2
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 2
44386: PUSH
44387: LD_INT 4
44389: PUSH
44390: EMPTY
44391: LIST
44392: LIST
44393: PUSH
44394: LD_INT 0
44396: PUSH
44397: LD_INT 4
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: PUSH
44404: LD_INT 0
44406: PUSH
44407: LD_INT 3
44409: PUSH
44410: EMPTY
44411: LIST
44412: LIST
44413: PUSH
44414: LD_INT 1
44416: PUSH
44417: LD_INT 4
44419: PUSH
44420: EMPTY
44421: LIST
44422: LIST
44423: PUSH
44424: LD_INT 1
44426: PUSH
44427: LD_INT 5
44429: PUSH
44430: EMPTY
44431: LIST
44432: LIST
44433: PUSH
44434: LD_INT 0
44436: PUSH
44437: LD_INT 5
44439: PUSH
44440: EMPTY
44441: LIST
44442: LIST
44443: PUSH
44444: LD_INT 1
44446: NEG
44447: PUSH
44448: LD_INT 4
44450: PUSH
44451: EMPTY
44452: LIST
44453: LIST
44454: PUSH
44455: LD_INT 1
44457: NEG
44458: PUSH
44459: LD_INT 3
44461: PUSH
44462: EMPTY
44463: LIST
44464: LIST
44465: PUSH
44466: LD_INT 2
44468: PUSH
44469: LD_INT 5
44471: PUSH
44472: EMPTY
44473: LIST
44474: LIST
44475: PUSH
44476: LD_INT 2
44478: NEG
44479: PUSH
44480: LD_INT 3
44482: PUSH
44483: EMPTY
44484: LIST
44485: LIST
44486: PUSH
44487: LD_INT 3
44489: NEG
44490: PUSH
44491: LD_INT 0
44493: PUSH
44494: EMPTY
44495: LIST
44496: LIST
44497: PUSH
44498: LD_INT 3
44500: NEG
44501: PUSH
44502: LD_INT 1
44504: NEG
44505: PUSH
44506: EMPTY
44507: LIST
44508: LIST
44509: PUSH
44510: LD_INT 2
44512: NEG
44513: PUSH
44514: LD_INT 0
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: PUSH
44521: LD_INT 2
44523: NEG
44524: PUSH
44525: LD_INT 1
44527: PUSH
44528: EMPTY
44529: LIST
44530: LIST
44531: PUSH
44532: LD_INT 3
44534: NEG
44535: PUSH
44536: LD_INT 1
44538: PUSH
44539: EMPTY
44540: LIST
44541: LIST
44542: PUSH
44543: LD_INT 4
44545: NEG
44546: PUSH
44547: LD_INT 0
44549: PUSH
44550: EMPTY
44551: LIST
44552: LIST
44553: PUSH
44554: LD_INT 4
44556: NEG
44557: PUSH
44558: LD_INT 1
44560: NEG
44561: PUSH
44562: EMPTY
44563: LIST
44564: LIST
44565: PUSH
44566: LD_INT 4
44568: NEG
44569: PUSH
44570: LD_INT 2
44572: NEG
44573: PUSH
44574: EMPTY
44575: LIST
44576: LIST
44577: PUSH
44578: LD_INT 2
44580: NEG
44581: PUSH
44582: LD_INT 2
44584: PUSH
44585: EMPTY
44586: LIST
44587: LIST
44588: PUSH
44589: LD_INT 4
44591: NEG
44592: PUSH
44593: LD_INT 4
44595: NEG
44596: PUSH
44597: EMPTY
44598: LIST
44599: LIST
44600: PUSH
44601: LD_INT 4
44603: NEG
44604: PUSH
44605: LD_INT 5
44607: NEG
44608: PUSH
44609: EMPTY
44610: LIST
44611: LIST
44612: PUSH
44613: LD_INT 3
44615: NEG
44616: PUSH
44617: LD_INT 4
44619: NEG
44620: PUSH
44621: EMPTY
44622: LIST
44623: LIST
44624: PUSH
44625: LD_INT 3
44627: NEG
44628: PUSH
44629: LD_INT 3
44631: NEG
44632: PUSH
44633: EMPTY
44634: LIST
44635: LIST
44636: PUSH
44637: LD_INT 4
44639: NEG
44640: PUSH
44641: LD_INT 3
44643: NEG
44644: PUSH
44645: EMPTY
44646: LIST
44647: LIST
44648: PUSH
44649: LD_INT 5
44651: NEG
44652: PUSH
44653: LD_INT 4
44655: NEG
44656: PUSH
44657: EMPTY
44658: LIST
44659: LIST
44660: PUSH
44661: LD_INT 5
44663: NEG
44664: PUSH
44665: LD_INT 5
44667: NEG
44668: PUSH
44669: EMPTY
44670: LIST
44671: LIST
44672: PUSH
44673: LD_INT 3
44675: NEG
44676: PUSH
44677: LD_INT 5
44679: NEG
44680: PUSH
44681: EMPTY
44682: LIST
44683: LIST
44684: PUSH
44685: LD_INT 5
44687: NEG
44688: PUSH
44689: LD_INT 3
44691: NEG
44692: PUSH
44693: EMPTY
44694: LIST
44695: LIST
44696: PUSH
44697: EMPTY
44698: LIST
44699: LIST
44700: LIST
44701: LIST
44702: LIST
44703: LIST
44704: LIST
44705: LIST
44706: LIST
44707: LIST
44708: LIST
44709: LIST
44710: LIST
44711: LIST
44712: LIST
44713: LIST
44714: LIST
44715: LIST
44716: LIST
44717: LIST
44718: LIST
44719: LIST
44720: LIST
44721: LIST
44722: LIST
44723: LIST
44724: LIST
44725: LIST
44726: LIST
44727: LIST
44728: LIST
44729: LIST
44730: LIST
44731: LIST
44732: LIST
44733: LIST
44734: LIST
44735: LIST
44736: LIST
44737: LIST
44738: LIST
44739: LIST
44740: LIST
44741: LIST
44742: LIST
44743: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
44744: LD_ADDR_VAR 0 30
44748: PUSH
44749: LD_INT 4
44751: PUSH
44752: LD_INT 4
44754: PUSH
44755: EMPTY
44756: LIST
44757: LIST
44758: PUSH
44759: LD_INT 4
44761: PUSH
44762: LD_INT 3
44764: PUSH
44765: EMPTY
44766: LIST
44767: LIST
44768: PUSH
44769: LD_INT 5
44771: PUSH
44772: LD_INT 4
44774: PUSH
44775: EMPTY
44776: LIST
44777: LIST
44778: PUSH
44779: LD_INT 5
44781: PUSH
44782: LD_INT 5
44784: PUSH
44785: EMPTY
44786: LIST
44787: LIST
44788: PUSH
44789: LD_INT 4
44791: PUSH
44792: LD_INT 5
44794: PUSH
44795: EMPTY
44796: LIST
44797: LIST
44798: PUSH
44799: LD_INT 3
44801: PUSH
44802: LD_INT 4
44804: PUSH
44805: EMPTY
44806: LIST
44807: LIST
44808: PUSH
44809: LD_INT 3
44811: PUSH
44812: LD_INT 3
44814: PUSH
44815: EMPTY
44816: LIST
44817: LIST
44818: PUSH
44819: LD_INT 5
44821: PUSH
44822: LD_INT 3
44824: PUSH
44825: EMPTY
44826: LIST
44827: LIST
44828: PUSH
44829: LD_INT 3
44831: PUSH
44832: LD_INT 5
44834: PUSH
44835: EMPTY
44836: LIST
44837: LIST
44838: PUSH
44839: LD_INT 0
44841: PUSH
44842: LD_INT 3
44844: PUSH
44845: EMPTY
44846: LIST
44847: LIST
44848: PUSH
44849: LD_INT 0
44851: PUSH
44852: LD_INT 2
44854: PUSH
44855: EMPTY
44856: LIST
44857: LIST
44858: PUSH
44859: LD_INT 1
44861: PUSH
44862: LD_INT 3
44864: PUSH
44865: EMPTY
44866: LIST
44867: LIST
44868: PUSH
44869: LD_INT 1
44871: PUSH
44872: LD_INT 4
44874: PUSH
44875: EMPTY
44876: LIST
44877: LIST
44878: PUSH
44879: LD_INT 0
44881: PUSH
44882: LD_INT 4
44884: PUSH
44885: EMPTY
44886: LIST
44887: LIST
44888: PUSH
44889: LD_INT 1
44891: NEG
44892: PUSH
44893: LD_INT 3
44895: PUSH
44896: EMPTY
44897: LIST
44898: LIST
44899: PUSH
44900: LD_INT 1
44902: NEG
44903: PUSH
44904: LD_INT 2
44906: PUSH
44907: EMPTY
44908: LIST
44909: LIST
44910: PUSH
44911: LD_INT 2
44913: PUSH
44914: LD_INT 4
44916: PUSH
44917: EMPTY
44918: LIST
44919: LIST
44920: PUSH
44921: LD_INT 2
44923: NEG
44924: PUSH
44925: LD_INT 2
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: PUSH
44932: LD_INT 4
44934: NEG
44935: PUSH
44936: LD_INT 0
44938: PUSH
44939: EMPTY
44940: LIST
44941: LIST
44942: PUSH
44943: LD_INT 4
44945: NEG
44946: PUSH
44947: LD_INT 1
44949: NEG
44950: PUSH
44951: EMPTY
44952: LIST
44953: LIST
44954: PUSH
44955: LD_INT 3
44957: NEG
44958: PUSH
44959: LD_INT 0
44961: PUSH
44962: EMPTY
44963: LIST
44964: LIST
44965: PUSH
44966: LD_INT 3
44968: NEG
44969: PUSH
44970: LD_INT 1
44972: PUSH
44973: EMPTY
44974: LIST
44975: LIST
44976: PUSH
44977: LD_INT 4
44979: NEG
44980: PUSH
44981: LD_INT 1
44983: PUSH
44984: EMPTY
44985: LIST
44986: LIST
44987: PUSH
44988: LD_INT 5
44990: NEG
44991: PUSH
44992: LD_INT 0
44994: PUSH
44995: EMPTY
44996: LIST
44997: LIST
44998: PUSH
44999: LD_INT 5
45001: NEG
45002: PUSH
45003: LD_INT 1
45005: NEG
45006: PUSH
45007: EMPTY
45008: LIST
45009: LIST
45010: PUSH
45011: LD_INT 5
45013: NEG
45014: PUSH
45015: LD_INT 2
45017: NEG
45018: PUSH
45019: EMPTY
45020: LIST
45021: LIST
45022: PUSH
45023: LD_INT 3
45025: NEG
45026: PUSH
45027: LD_INT 2
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PUSH
45034: LD_INT 3
45036: NEG
45037: PUSH
45038: LD_INT 3
45040: NEG
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: PUSH
45046: LD_INT 3
45048: NEG
45049: PUSH
45050: LD_INT 4
45052: NEG
45053: PUSH
45054: EMPTY
45055: LIST
45056: LIST
45057: PUSH
45058: LD_INT 2
45060: NEG
45061: PUSH
45062: LD_INT 3
45064: NEG
45065: PUSH
45066: EMPTY
45067: LIST
45068: LIST
45069: PUSH
45070: LD_INT 2
45072: NEG
45073: PUSH
45074: LD_INT 2
45076: NEG
45077: PUSH
45078: EMPTY
45079: LIST
45080: LIST
45081: PUSH
45082: LD_INT 3
45084: NEG
45085: PUSH
45086: LD_INT 2
45088: NEG
45089: PUSH
45090: EMPTY
45091: LIST
45092: LIST
45093: PUSH
45094: LD_INT 4
45096: NEG
45097: PUSH
45098: LD_INT 3
45100: NEG
45101: PUSH
45102: EMPTY
45103: LIST
45104: LIST
45105: PUSH
45106: LD_INT 4
45108: NEG
45109: PUSH
45110: LD_INT 4
45112: NEG
45113: PUSH
45114: EMPTY
45115: LIST
45116: LIST
45117: PUSH
45118: LD_INT 2
45120: NEG
45121: PUSH
45122: LD_INT 4
45124: NEG
45125: PUSH
45126: EMPTY
45127: LIST
45128: LIST
45129: PUSH
45130: LD_INT 4
45132: NEG
45133: PUSH
45134: LD_INT 2
45136: NEG
45137: PUSH
45138: EMPTY
45139: LIST
45140: LIST
45141: PUSH
45142: LD_INT 0
45144: PUSH
45145: LD_INT 4
45147: NEG
45148: PUSH
45149: EMPTY
45150: LIST
45151: LIST
45152: PUSH
45153: LD_INT 0
45155: PUSH
45156: LD_INT 5
45158: NEG
45159: PUSH
45160: EMPTY
45161: LIST
45162: LIST
45163: PUSH
45164: LD_INT 1
45166: PUSH
45167: LD_INT 4
45169: NEG
45170: PUSH
45171: EMPTY
45172: LIST
45173: LIST
45174: PUSH
45175: LD_INT 1
45177: PUSH
45178: LD_INT 3
45180: NEG
45181: PUSH
45182: EMPTY
45183: LIST
45184: LIST
45185: PUSH
45186: LD_INT 0
45188: PUSH
45189: LD_INT 3
45191: NEG
45192: PUSH
45193: EMPTY
45194: LIST
45195: LIST
45196: PUSH
45197: LD_INT 1
45199: NEG
45200: PUSH
45201: LD_INT 4
45203: NEG
45204: PUSH
45205: EMPTY
45206: LIST
45207: LIST
45208: PUSH
45209: LD_INT 1
45211: NEG
45212: PUSH
45213: LD_INT 5
45215: NEG
45216: PUSH
45217: EMPTY
45218: LIST
45219: LIST
45220: PUSH
45221: LD_INT 2
45223: PUSH
45224: LD_INT 3
45226: NEG
45227: PUSH
45228: EMPTY
45229: LIST
45230: LIST
45231: PUSH
45232: LD_INT 2
45234: NEG
45235: PUSH
45236: LD_INT 5
45238: NEG
45239: PUSH
45240: EMPTY
45241: LIST
45242: LIST
45243: PUSH
45244: EMPTY
45245: LIST
45246: LIST
45247: LIST
45248: LIST
45249: LIST
45250: LIST
45251: LIST
45252: LIST
45253: LIST
45254: LIST
45255: LIST
45256: LIST
45257: LIST
45258: LIST
45259: LIST
45260: LIST
45261: LIST
45262: LIST
45263: LIST
45264: LIST
45265: LIST
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: LIST
45271: LIST
45272: LIST
45273: LIST
45274: LIST
45275: LIST
45276: LIST
45277: LIST
45278: LIST
45279: LIST
45280: LIST
45281: LIST
45282: LIST
45283: LIST
45284: LIST
45285: LIST
45286: LIST
45287: LIST
45288: LIST
45289: LIST
45290: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
45291: LD_ADDR_VAR 0 31
45295: PUSH
45296: LD_INT 0
45298: PUSH
45299: LD_INT 4
45301: PUSH
45302: EMPTY
45303: LIST
45304: LIST
45305: PUSH
45306: LD_INT 0
45308: PUSH
45309: LD_INT 3
45311: PUSH
45312: EMPTY
45313: LIST
45314: LIST
45315: PUSH
45316: LD_INT 1
45318: PUSH
45319: LD_INT 4
45321: PUSH
45322: EMPTY
45323: LIST
45324: LIST
45325: PUSH
45326: LD_INT 1
45328: PUSH
45329: LD_INT 5
45331: PUSH
45332: EMPTY
45333: LIST
45334: LIST
45335: PUSH
45336: LD_INT 0
45338: PUSH
45339: LD_INT 5
45341: PUSH
45342: EMPTY
45343: LIST
45344: LIST
45345: PUSH
45346: LD_INT 1
45348: NEG
45349: PUSH
45350: LD_INT 4
45352: PUSH
45353: EMPTY
45354: LIST
45355: LIST
45356: PUSH
45357: LD_INT 1
45359: NEG
45360: PUSH
45361: LD_INT 3
45363: PUSH
45364: EMPTY
45365: LIST
45366: LIST
45367: PUSH
45368: LD_INT 2
45370: PUSH
45371: LD_INT 5
45373: PUSH
45374: EMPTY
45375: LIST
45376: LIST
45377: PUSH
45378: LD_INT 2
45380: NEG
45381: PUSH
45382: LD_INT 3
45384: PUSH
45385: EMPTY
45386: LIST
45387: LIST
45388: PUSH
45389: LD_INT 3
45391: NEG
45392: PUSH
45393: LD_INT 0
45395: PUSH
45396: EMPTY
45397: LIST
45398: LIST
45399: PUSH
45400: LD_INT 3
45402: NEG
45403: PUSH
45404: LD_INT 1
45406: NEG
45407: PUSH
45408: EMPTY
45409: LIST
45410: LIST
45411: PUSH
45412: LD_INT 2
45414: NEG
45415: PUSH
45416: LD_INT 0
45418: PUSH
45419: EMPTY
45420: LIST
45421: LIST
45422: PUSH
45423: LD_INT 2
45425: NEG
45426: PUSH
45427: LD_INT 1
45429: PUSH
45430: EMPTY
45431: LIST
45432: LIST
45433: PUSH
45434: LD_INT 3
45436: NEG
45437: PUSH
45438: LD_INT 1
45440: PUSH
45441: EMPTY
45442: LIST
45443: LIST
45444: PUSH
45445: LD_INT 4
45447: NEG
45448: PUSH
45449: LD_INT 0
45451: PUSH
45452: EMPTY
45453: LIST
45454: LIST
45455: PUSH
45456: LD_INT 4
45458: NEG
45459: PUSH
45460: LD_INT 1
45462: NEG
45463: PUSH
45464: EMPTY
45465: LIST
45466: LIST
45467: PUSH
45468: LD_INT 4
45470: NEG
45471: PUSH
45472: LD_INT 2
45474: NEG
45475: PUSH
45476: EMPTY
45477: LIST
45478: LIST
45479: PUSH
45480: LD_INT 2
45482: NEG
45483: PUSH
45484: LD_INT 2
45486: PUSH
45487: EMPTY
45488: LIST
45489: LIST
45490: PUSH
45491: LD_INT 4
45493: NEG
45494: PUSH
45495: LD_INT 4
45497: NEG
45498: PUSH
45499: EMPTY
45500: LIST
45501: LIST
45502: PUSH
45503: LD_INT 4
45505: NEG
45506: PUSH
45507: LD_INT 5
45509: NEG
45510: PUSH
45511: EMPTY
45512: LIST
45513: LIST
45514: PUSH
45515: LD_INT 3
45517: NEG
45518: PUSH
45519: LD_INT 4
45521: NEG
45522: PUSH
45523: EMPTY
45524: LIST
45525: LIST
45526: PUSH
45527: LD_INT 3
45529: NEG
45530: PUSH
45531: LD_INT 3
45533: NEG
45534: PUSH
45535: EMPTY
45536: LIST
45537: LIST
45538: PUSH
45539: LD_INT 4
45541: NEG
45542: PUSH
45543: LD_INT 3
45545: NEG
45546: PUSH
45547: EMPTY
45548: LIST
45549: LIST
45550: PUSH
45551: LD_INT 5
45553: NEG
45554: PUSH
45555: LD_INT 4
45557: NEG
45558: PUSH
45559: EMPTY
45560: LIST
45561: LIST
45562: PUSH
45563: LD_INT 5
45565: NEG
45566: PUSH
45567: LD_INT 5
45569: NEG
45570: PUSH
45571: EMPTY
45572: LIST
45573: LIST
45574: PUSH
45575: LD_INT 3
45577: NEG
45578: PUSH
45579: LD_INT 5
45581: NEG
45582: PUSH
45583: EMPTY
45584: LIST
45585: LIST
45586: PUSH
45587: LD_INT 5
45589: NEG
45590: PUSH
45591: LD_INT 3
45593: NEG
45594: PUSH
45595: EMPTY
45596: LIST
45597: LIST
45598: PUSH
45599: LD_INT 0
45601: PUSH
45602: LD_INT 3
45604: NEG
45605: PUSH
45606: EMPTY
45607: LIST
45608: LIST
45609: PUSH
45610: LD_INT 0
45612: PUSH
45613: LD_INT 4
45615: NEG
45616: PUSH
45617: EMPTY
45618: LIST
45619: LIST
45620: PUSH
45621: LD_INT 1
45623: PUSH
45624: LD_INT 3
45626: NEG
45627: PUSH
45628: EMPTY
45629: LIST
45630: LIST
45631: PUSH
45632: LD_INT 1
45634: PUSH
45635: LD_INT 2
45637: NEG
45638: PUSH
45639: EMPTY
45640: LIST
45641: LIST
45642: PUSH
45643: LD_INT 0
45645: PUSH
45646: LD_INT 2
45648: NEG
45649: PUSH
45650: EMPTY
45651: LIST
45652: LIST
45653: PUSH
45654: LD_INT 1
45656: NEG
45657: PUSH
45658: LD_INT 3
45660: NEG
45661: PUSH
45662: EMPTY
45663: LIST
45664: LIST
45665: PUSH
45666: LD_INT 1
45668: NEG
45669: PUSH
45670: LD_INT 4
45672: NEG
45673: PUSH
45674: EMPTY
45675: LIST
45676: LIST
45677: PUSH
45678: LD_INT 2
45680: PUSH
45681: LD_INT 2
45683: NEG
45684: PUSH
45685: EMPTY
45686: LIST
45687: LIST
45688: PUSH
45689: LD_INT 2
45691: NEG
45692: PUSH
45693: LD_INT 4
45695: NEG
45696: PUSH
45697: EMPTY
45698: LIST
45699: LIST
45700: PUSH
45701: LD_INT 4
45703: PUSH
45704: LD_INT 0
45706: PUSH
45707: EMPTY
45708: LIST
45709: LIST
45710: PUSH
45711: LD_INT 4
45713: PUSH
45714: LD_INT 1
45716: NEG
45717: PUSH
45718: EMPTY
45719: LIST
45720: LIST
45721: PUSH
45722: LD_INT 5
45724: PUSH
45725: LD_INT 0
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: PUSH
45732: LD_INT 5
45734: PUSH
45735: LD_INT 1
45737: PUSH
45738: EMPTY
45739: LIST
45740: LIST
45741: PUSH
45742: LD_INT 4
45744: PUSH
45745: LD_INT 1
45747: PUSH
45748: EMPTY
45749: LIST
45750: LIST
45751: PUSH
45752: LD_INT 3
45754: PUSH
45755: LD_INT 0
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PUSH
45762: LD_INT 3
45764: PUSH
45765: LD_INT 1
45767: NEG
45768: PUSH
45769: EMPTY
45770: LIST
45771: LIST
45772: PUSH
45773: LD_INT 3
45775: PUSH
45776: LD_INT 2
45778: NEG
45779: PUSH
45780: EMPTY
45781: LIST
45782: LIST
45783: PUSH
45784: LD_INT 5
45786: PUSH
45787: LD_INT 2
45789: PUSH
45790: EMPTY
45791: LIST
45792: LIST
45793: PUSH
45794: EMPTY
45795: LIST
45796: LIST
45797: LIST
45798: LIST
45799: LIST
45800: LIST
45801: LIST
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: LIST
45810: LIST
45811: LIST
45812: LIST
45813: LIST
45814: LIST
45815: LIST
45816: LIST
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: LIST
45824: LIST
45825: LIST
45826: LIST
45827: LIST
45828: LIST
45829: LIST
45830: LIST
45831: LIST
45832: LIST
45833: LIST
45834: LIST
45835: LIST
45836: LIST
45837: LIST
45838: LIST
45839: LIST
45840: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45841: LD_ADDR_VAR 0 32
45845: PUSH
45846: LD_INT 4
45848: NEG
45849: PUSH
45850: LD_INT 0
45852: PUSH
45853: EMPTY
45854: LIST
45855: LIST
45856: PUSH
45857: LD_INT 4
45859: NEG
45860: PUSH
45861: LD_INT 1
45863: NEG
45864: PUSH
45865: EMPTY
45866: LIST
45867: LIST
45868: PUSH
45869: LD_INT 3
45871: NEG
45872: PUSH
45873: LD_INT 0
45875: PUSH
45876: EMPTY
45877: LIST
45878: LIST
45879: PUSH
45880: LD_INT 3
45882: NEG
45883: PUSH
45884: LD_INT 1
45886: PUSH
45887: EMPTY
45888: LIST
45889: LIST
45890: PUSH
45891: LD_INT 4
45893: NEG
45894: PUSH
45895: LD_INT 1
45897: PUSH
45898: EMPTY
45899: LIST
45900: LIST
45901: PUSH
45902: LD_INT 5
45904: NEG
45905: PUSH
45906: LD_INT 0
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: PUSH
45913: LD_INT 5
45915: NEG
45916: PUSH
45917: LD_INT 1
45919: NEG
45920: PUSH
45921: EMPTY
45922: LIST
45923: LIST
45924: PUSH
45925: LD_INT 5
45927: NEG
45928: PUSH
45929: LD_INT 2
45931: NEG
45932: PUSH
45933: EMPTY
45934: LIST
45935: LIST
45936: PUSH
45937: LD_INT 3
45939: NEG
45940: PUSH
45941: LD_INT 2
45943: PUSH
45944: EMPTY
45945: LIST
45946: LIST
45947: PUSH
45948: LD_INT 3
45950: NEG
45951: PUSH
45952: LD_INT 3
45954: NEG
45955: PUSH
45956: EMPTY
45957: LIST
45958: LIST
45959: PUSH
45960: LD_INT 3
45962: NEG
45963: PUSH
45964: LD_INT 4
45966: NEG
45967: PUSH
45968: EMPTY
45969: LIST
45970: LIST
45971: PUSH
45972: LD_INT 2
45974: NEG
45975: PUSH
45976: LD_INT 3
45978: NEG
45979: PUSH
45980: EMPTY
45981: LIST
45982: LIST
45983: PUSH
45984: LD_INT 2
45986: NEG
45987: PUSH
45988: LD_INT 2
45990: NEG
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: PUSH
45996: LD_INT 3
45998: NEG
45999: PUSH
46000: LD_INT 2
46002: NEG
46003: PUSH
46004: EMPTY
46005: LIST
46006: LIST
46007: PUSH
46008: LD_INT 4
46010: NEG
46011: PUSH
46012: LD_INT 3
46014: NEG
46015: PUSH
46016: EMPTY
46017: LIST
46018: LIST
46019: PUSH
46020: LD_INT 4
46022: NEG
46023: PUSH
46024: LD_INT 4
46026: NEG
46027: PUSH
46028: EMPTY
46029: LIST
46030: LIST
46031: PUSH
46032: LD_INT 2
46034: NEG
46035: PUSH
46036: LD_INT 4
46038: NEG
46039: PUSH
46040: EMPTY
46041: LIST
46042: LIST
46043: PUSH
46044: LD_INT 4
46046: NEG
46047: PUSH
46048: LD_INT 2
46050: NEG
46051: PUSH
46052: EMPTY
46053: LIST
46054: LIST
46055: PUSH
46056: LD_INT 0
46058: PUSH
46059: LD_INT 4
46061: NEG
46062: PUSH
46063: EMPTY
46064: LIST
46065: LIST
46066: PUSH
46067: LD_INT 0
46069: PUSH
46070: LD_INT 5
46072: NEG
46073: PUSH
46074: EMPTY
46075: LIST
46076: LIST
46077: PUSH
46078: LD_INT 1
46080: PUSH
46081: LD_INT 4
46083: NEG
46084: PUSH
46085: EMPTY
46086: LIST
46087: LIST
46088: PUSH
46089: LD_INT 1
46091: PUSH
46092: LD_INT 3
46094: NEG
46095: PUSH
46096: EMPTY
46097: LIST
46098: LIST
46099: PUSH
46100: LD_INT 0
46102: PUSH
46103: LD_INT 3
46105: NEG
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: PUSH
46111: LD_INT 1
46113: NEG
46114: PUSH
46115: LD_INT 4
46117: NEG
46118: PUSH
46119: EMPTY
46120: LIST
46121: LIST
46122: PUSH
46123: LD_INT 1
46125: NEG
46126: PUSH
46127: LD_INT 5
46129: NEG
46130: PUSH
46131: EMPTY
46132: LIST
46133: LIST
46134: PUSH
46135: LD_INT 2
46137: PUSH
46138: LD_INT 3
46140: NEG
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: PUSH
46146: LD_INT 2
46148: NEG
46149: PUSH
46150: LD_INT 5
46152: NEG
46153: PUSH
46154: EMPTY
46155: LIST
46156: LIST
46157: PUSH
46158: LD_INT 3
46160: PUSH
46161: LD_INT 0
46163: PUSH
46164: EMPTY
46165: LIST
46166: LIST
46167: PUSH
46168: LD_INT 3
46170: PUSH
46171: LD_INT 1
46173: NEG
46174: PUSH
46175: EMPTY
46176: LIST
46177: LIST
46178: PUSH
46179: LD_INT 4
46181: PUSH
46182: LD_INT 0
46184: PUSH
46185: EMPTY
46186: LIST
46187: LIST
46188: PUSH
46189: LD_INT 4
46191: PUSH
46192: LD_INT 1
46194: PUSH
46195: EMPTY
46196: LIST
46197: LIST
46198: PUSH
46199: LD_INT 3
46201: PUSH
46202: LD_INT 1
46204: PUSH
46205: EMPTY
46206: LIST
46207: LIST
46208: PUSH
46209: LD_INT 2
46211: PUSH
46212: LD_INT 0
46214: PUSH
46215: EMPTY
46216: LIST
46217: LIST
46218: PUSH
46219: LD_INT 2
46221: PUSH
46222: LD_INT 1
46224: NEG
46225: PUSH
46226: EMPTY
46227: LIST
46228: LIST
46229: PUSH
46230: LD_INT 2
46232: PUSH
46233: LD_INT 2
46235: NEG
46236: PUSH
46237: EMPTY
46238: LIST
46239: LIST
46240: PUSH
46241: LD_INT 4
46243: PUSH
46244: LD_INT 2
46246: PUSH
46247: EMPTY
46248: LIST
46249: LIST
46250: PUSH
46251: LD_INT 4
46253: PUSH
46254: LD_INT 4
46256: PUSH
46257: EMPTY
46258: LIST
46259: LIST
46260: PUSH
46261: LD_INT 4
46263: PUSH
46264: LD_INT 3
46266: PUSH
46267: EMPTY
46268: LIST
46269: LIST
46270: PUSH
46271: LD_INT 5
46273: PUSH
46274: LD_INT 4
46276: PUSH
46277: EMPTY
46278: LIST
46279: LIST
46280: PUSH
46281: LD_INT 5
46283: PUSH
46284: LD_INT 5
46286: PUSH
46287: EMPTY
46288: LIST
46289: LIST
46290: PUSH
46291: LD_INT 4
46293: PUSH
46294: LD_INT 5
46296: PUSH
46297: EMPTY
46298: LIST
46299: LIST
46300: PUSH
46301: LD_INT 3
46303: PUSH
46304: LD_INT 4
46306: PUSH
46307: EMPTY
46308: LIST
46309: LIST
46310: PUSH
46311: LD_INT 3
46313: PUSH
46314: LD_INT 3
46316: PUSH
46317: EMPTY
46318: LIST
46319: LIST
46320: PUSH
46321: LD_INT 5
46323: PUSH
46324: LD_INT 3
46326: PUSH
46327: EMPTY
46328: LIST
46329: LIST
46330: PUSH
46331: LD_INT 3
46333: PUSH
46334: LD_INT 5
46336: PUSH
46337: EMPTY
46338: LIST
46339: LIST
46340: PUSH
46341: EMPTY
46342: LIST
46343: LIST
46344: LIST
46345: LIST
46346: LIST
46347: LIST
46348: LIST
46349: LIST
46350: LIST
46351: LIST
46352: LIST
46353: LIST
46354: LIST
46355: LIST
46356: LIST
46357: LIST
46358: LIST
46359: LIST
46360: LIST
46361: LIST
46362: LIST
46363: LIST
46364: LIST
46365: LIST
46366: LIST
46367: LIST
46368: LIST
46369: LIST
46370: LIST
46371: LIST
46372: LIST
46373: LIST
46374: LIST
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
46388: LD_ADDR_VAR 0 33
46392: PUSH
46393: LD_INT 4
46395: NEG
46396: PUSH
46397: LD_INT 4
46399: NEG
46400: PUSH
46401: EMPTY
46402: LIST
46403: LIST
46404: PUSH
46405: LD_INT 4
46407: NEG
46408: PUSH
46409: LD_INT 5
46411: NEG
46412: PUSH
46413: EMPTY
46414: LIST
46415: LIST
46416: PUSH
46417: LD_INT 3
46419: NEG
46420: PUSH
46421: LD_INT 4
46423: NEG
46424: PUSH
46425: EMPTY
46426: LIST
46427: LIST
46428: PUSH
46429: LD_INT 3
46431: NEG
46432: PUSH
46433: LD_INT 3
46435: NEG
46436: PUSH
46437: EMPTY
46438: LIST
46439: LIST
46440: PUSH
46441: LD_INT 4
46443: NEG
46444: PUSH
46445: LD_INT 3
46447: NEG
46448: PUSH
46449: EMPTY
46450: LIST
46451: LIST
46452: PUSH
46453: LD_INT 5
46455: NEG
46456: PUSH
46457: LD_INT 4
46459: NEG
46460: PUSH
46461: EMPTY
46462: LIST
46463: LIST
46464: PUSH
46465: LD_INT 5
46467: NEG
46468: PUSH
46469: LD_INT 5
46471: NEG
46472: PUSH
46473: EMPTY
46474: LIST
46475: LIST
46476: PUSH
46477: LD_INT 3
46479: NEG
46480: PUSH
46481: LD_INT 5
46483: NEG
46484: PUSH
46485: EMPTY
46486: LIST
46487: LIST
46488: PUSH
46489: LD_INT 5
46491: NEG
46492: PUSH
46493: LD_INT 3
46495: NEG
46496: PUSH
46497: EMPTY
46498: LIST
46499: LIST
46500: PUSH
46501: LD_INT 0
46503: PUSH
46504: LD_INT 3
46506: NEG
46507: PUSH
46508: EMPTY
46509: LIST
46510: LIST
46511: PUSH
46512: LD_INT 0
46514: PUSH
46515: LD_INT 4
46517: NEG
46518: PUSH
46519: EMPTY
46520: LIST
46521: LIST
46522: PUSH
46523: LD_INT 1
46525: PUSH
46526: LD_INT 3
46528: NEG
46529: PUSH
46530: EMPTY
46531: LIST
46532: LIST
46533: PUSH
46534: LD_INT 1
46536: PUSH
46537: LD_INT 2
46539: NEG
46540: PUSH
46541: EMPTY
46542: LIST
46543: LIST
46544: PUSH
46545: LD_INT 0
46547: PUSH
46548: LD_INT 2
46550: NEG
46551: PUSH
46552: EMPTY
46553: LIST
46554: LIST
46555: PUSH
46556: LD_INT 1
46558: NEG
46559: PUSH
46560: LD_INT 3
46562: NEG
46563: PUSH
46564: EMPTY
46565: LIST
46566: LIST
46567: PUSH
46568: LD_INT 1
46570: NEG
46571: PUSH
46572: LD_INT 4
46574: NEG
46575: PUSH
46576: EMPTY
46577: LIST
46578: LIST
46579: PUSH
46580: LD_INT 2
46582: PUSH
46583: LD_INT 2
46585: NEG
46586: PUSH
46587: EMPTY
46588: LIST
46589: LIST
46590: PUSH
46591: LD_INT 2
46593: NEG
46594: PUSH
46595: LD_INT 4
46597: NEG
46598: PUSH
46599: EMPTY
46600: LIST
46601: LIST
46602: PUSH
46603: LD_INT 4
46605: PUSH
46606: LD_INT 0
46608: PUSH
46609: EMPTY
46610: LIST
46611: LIST
46612: PUSH
46613: LD_INT 4
46615: PUSH
46616: LD_INT 1
46618: NEG
46619: PUSH
46620: EMPTY
46621: LIST
46622: LIST
46623: PUSH
46624: LD_INT 5
46626: PUSH
46627: LD_INT 0
46629: PUSH
46630: EMPTY
46631: LIST
46632: LIST
46633: PUSH
46634: LD_INT 5
46636: PUSH
46637: LD_INT 1
46639: PUSH
46640: EMPTY
46641: LIST
46642: LIST
46643: PUSH
46644: LD_INT 4
46646: PUSH
46647: LD_INT 1
46649: PUSH
46650: EMPTY
46651: LIST
46652: LIST
46653: PUSH
46654: LD_INT 3
46656: PUSH
46657: LD_INT 0
46659: PUSH
46660: EMPTY
46661: LIST
46662: LIST
46663: PUSH
46664: LD_INT 3
46666: PUSH
46667: LD_INT 1
46669: NEG
46670: PUSH
46671: EMPTY
46672: LIST
46673: LIST
46674: PUSH
46675: LD_INT 3
46677: PUSH
46678: LD_INT 2
46680: NEG
46681: PUSH
46682: EMPTY
46683: LIST
46684: LIST
46685: PUSH
46686: LD_INT 5
46688: PUSH
46689: LD_INT 2
46691: PUSH
46692: EMPTY
46693: LIST
46694: LIST
46695: PUSH
46696: LD_INT 3
46698: PUSH
46699: LD_INT 3
46701: PUSH
46702: EMPTY
46703: LIST
46704: LIST
46705: PUSH
46706: LD_INT 3
46708: PUSH
46709: LD_INT 2
46711: PUSH
46712: EMPTY
46713: LIST
46714: LIST
46715: PUSH
46716: LD_INT 4
46718: PUSH
46719: LD_INT 3
46721: PUSH
46722: EMPTY
46723: LIST
46724: LIST
46725: PUSH
46726: LD_INT 4
46728: PUSH
46729: LD_INT 4
46731: PUSH
46732: EMPTY
46733: LIST
46734: LIST
46735: PUSH
46736: LD_INT 3
46738: PUSH
46739: LD_INT 4
46741: PUSH
46742: EMPTY
46743: LIST
46744: LIST
46745: PUSH
46746: LD_INT 2
46748: PUSH
46749: LD_INT 3
46751: PUSH
46752: EMPTY
46753: LIST
46754: LIST
46755: PUSH
46756: LD_INT 2
46758: PUSH
46759: LD_INT 2
46761: PUSH
46762: EMPTY
46763: LIST
46764: LIST
46765: PUSH
46766: LD_INT 4
46768: PUSH
46769: LD_INT 2
46771: PUSH
46772: EMPTY
46773: LIST
46774: LIST
46775: PUSH
46776: LD_INT 2
46778: PUSH
46779: LD_INT 4
46781: PUSH
46782: EMPTY
46783: LIST
46784: LIST
46785: PUSH
46786: LD_INT 0
46788: PUSH
46789: LD_INT 4
46791: PUSH
46792: EMPTY
46793: LIST
46794: LIST
46795: PUSH
46796: LD_INT 0
46798: PUSH
46799: LD_INT 3
46801: PUSH
46802: EMPTY
46803: LIST
46804: LIST
46805: PUSH
46806: LD_INT 1
46808: PUSH
46809: LD_INT 4
46811: PUSH
46812: EMPTY
46813: LIST
46814: LIST
46815: PUSH
46816: LD_INT 1
46818: PUSH
46819: LD_INT 5
46821: PUSH
46822: EMPTY
46823: LIST
46824: LIST
46825: PUSH
46826: LD_INT 0
46828: PUSH
46829: LD_INT 5
46831: PUSH
46832: EMPTY
46833: LIST
46834: LIST
46835: PUSH
46836: LD_INT 1
46838: NEG
46839: PUSH
46840: LD_INT 4
46842: PUSH
46843: EMPTY
46844: LIST
46845: LIST
46846: PUSH
46847: LD_INT 1
46849: NEG
46850: PUSH
46851: LD_INT 3
46853: PUSH
46854: EMPTY
46855: LIST
46856: LIST
46857: PUSH
46858: LD_INT 2
46860: PUSH
46861: LD_INT 5
46863: PUSH
46864: EMPTY
46865: LIST
46866: LIST
46867: PUSH
46868: LD_INT 2
46870: NEG
46871: PUSH
46872: LD_INT 3
46874: PUSH
46875: EMPTY
46876: LIST
46877: LIST
46878: PUSH
46879: EMPTY
46880: LIST
46881: LIST
46882: LIST
46883: LIST
46884: LIST
46885: LIST
46886: LIST
46887: LIST
46888: LIST
46889: LIST
46890: LIST
46891: LIST
46892: LIST
46893: LIST
46894: LIST
46895: LIST
46896: LIST
46897: LIST
46898: LIST
46899: LIST
46900: LIST
46901: LIST
46902: LIST
46903: LIST
46904: LIST
46905: LIST
46906: LIST
46907: LIST
46908: LIST
46909: LIST
46910: LIST
46911: LIST
46912: LIST
46913: LIST
46914: LIST
46915: LIST
46916: LIST
46917: LIST
46918: LIST
46919: LIST
46920: LIST
46921: LIST
46922: LIST
46923: LIST
46924: LIST
46925: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46926: LD_ADDR_VAR 0 34
46930: PUSH
46931: LD_INT 0
46933: PUSH
46934: LD_INT 4
46936: NEG
46937: PUSH
46938: EMPTY
46939: LIST
46940: LIST
46941: PUSH
46942: LD_INT 0
46944: PUSH
46945: LD_INT 5
46947: NEG
46948: PUSH
46949: EMPTY
46950: LIST
46951: LIST
46952: PUSH
46953: LD_INT 1
46955: PUSH
46956: LD_INT 4
46958: NEG
46959: PUSH
46960: EMPTY
46961: LIST
46962: LIST
46963: PUSH
46964: LD_INT 1
46966: PUSH
46967: LD_INT 3
46969: NEG
46970: PUSH
46971: EMPTY
46972: LIST
46973: LIST
46974: PUSH
46975: LD_INT 0
46977: PUSH
46978: LD_INT 3
46980: NEG
46981: PUSH
46982: EMPTY
46983: LIST
46984: LIST
46985: PUSH
46986: LD_INT 1
46988: NEG
46989: PUSH
46990: LD_INT 4
46992: NEG
46993: PUSH
46994: EMPTY
46995: LIST
46996: LIST
46997: PUSH
46998: LD_INT 1
47000: NEG
47001: PUSH
47002: LD_INT 5
47004: NEG
47005: PUSH
47006: EMPTY
47007: LIST
47008: LIST
47009: PUSH
47010: LD_INT 2
47012: PUSH
47013: LD_INT 3
47015: NEG
47016: PUSH
47017: EMPTY
47018: LIST
47019: LIST
47020: PUSH
47021: LD_INT 2
47023: NEG
47024: PUSH
47025: LD_INT 5
47027: NEG
47028: PUSH
47029: EMPTY
47030: LIST
47031: LIST
47032: PUSH
47033: LD_INT 3
47035: PUSH
47036: LD_INT 0
47038: PUSH
47039: EMPTY
47040: LIST
47041: LIST
47042: PUSH
47043: LD_INT 3
47045: PUSH
47046: LD_INT 1
47048: NEG
47049: PUSH
47050: EMPTY
47051: LIST
47052: LIST
47053: PUSH
47054: LD_INT 4
47056: PUSH
47057: LD_INT 0
47059: PUSH
47060: EMPTY
47061: LIST
47062: LIST
47063: PUSH
47064: LD_INT 4
47066: PUSH
47067: LD_INT 1
47069: PUSH
47070: EMPTY
47071: LIST
47072: LIST
47073: PUSH
47074: LD_INT 3
47076: PUSH
47077: LD_INT 1
47079: PUSH
47080: EMPTY
47081: LIST
47082: LIST
47083: PUSH
47084: LD_INT 2
47086: PUSH
47087: LD_INT 0
47089: PUSH
47090: EMPTY
47091: LIST
47092: LIST
47093: PUSH
47094: LD_INT 2
47096: PUSH
47097: LD_INT 1
47099: NEG
47100: PUSH
47101: EMPTY
47102: LIST
47103: LIST
47104: PUSH
47105: LD_INT 2
47107: PUSH
47108: LD_INT 2
47110: NEG
47111: PUSH
47112: EMPTY
47113: LIST
47114: LIST
47115: PUSH
47116: LD_INT 4
47118: PUSH
47119: LD_INT 2
47121: PUSH
47122: EMPTY
47123: LIST
47124: LIST
47125: PUSH
47126: LD_INT 4
47128: PUSH
47129: LD_INT 4
47131: PUSH
47132: EMPTY
47133: LIST
47134: LIST
47135: PUSH
47136: LD_INT 4
47138: PUSH
47139: LD_INT 3
47141: PUSH
47142: EMPTY
47143: LIST
47144: LIST
47145: PUSH
47146: LD_INT 5
47148: PUSH
47149: LD_INT 4
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: PUSH
47156: LD_INT 5
47158: PUSH
47159: LD_INT 5
47161: PUSH
47162: EMPTY
47163: LIST
47164: LIST
47165: PUSH
47166: LD_INT 4
47168: PUSH
47169: LD_INT 5
47171: PUSH
47172: EMPTY
47173: LIST
47174: LIST
47175: PUSH
47176: LD_INT 3
47178: PUSH
47179: LD_INT 4
47181: PUSH
47182: EMPTY
47183: LIST
47184: LIST
47185: PUSH
47186: LD_INT 3
47188: PUSH
47189: LD_INT 3
47191: PUSH
47192: EMPTY
47193: LIST
47194: LIST
47195: PUSH
47196: LD_INT 5
47198: PUSH
47199: LD_INT 3
47201: PUSH
47202: EMPTY
47203: LIST
47204: LIST
47205: PUSH
47206: LD_INT 3
47208: PUSH
47209: LD_INT 5
47211: PUSH
47212: EMPTY
47213: LIST
47214: LIST
47215: PUSH
47216: LD_INT 0
47218: PUSH
47219: LD_INT 3
47221: PUSH
47222: EMPTY
47223: LIST
47224: LIST
47225: PUSH
47226: LD_INT 0
47228: PUSH
47229: LD_INT 2
47231: PUSH
47232: EMPTY
47233: LIST
47234: LIST
47235: PUSH
47236: LD_INT 1
47238: PUSH
47239: LD_INT 3
47241: PUSH
47242: EMPTY
47243: LIST
47244: LIST
47245: PUSH
47246: LD_INT 1
47248: PUSH
47249: LD_INT 4
47251: PUSH
47252: EMPTY
47253: LIST
47254: LIST
47255: PUSH
47256: LD_INT 0
47258: PUSH
47259: LD_INT 4
47261: PUSH
47262: EMPTY
47263: LIST
47264: LIST
47265: PUSH
47266: LD_INT 1
47268: NEG
47269: PUSH
47270: LD_INT 3
47272: PUSH
47273: EMPTY
47274: LIST
47275: LIST
47276: PUSH
47277: LD_INT 1
47279: NEG
47280: PUSH
47281: LD_INT 2
47283: PUSH
47284: EMPTY
47285: LIST
47286: LIST
47287: PUSH
47288: LD_INT 2
47290: PUSH
47291: LD_INT 4
47293: PUSH
47294: EMPTY
47295: LIST
47296: LIST
47297: PUSH
47298: LD_INT 2
47300: NEG
47301: PUSH
47302: LD_INT 2
47304: PUSH
47305: EMPTY
47306: LIST
47307: LIST
47308: PUSH
47309: LD_INT 4
47311: NEG
47312: PUSH
47313: LD_INT 0
47315: PUSH
47316: EMPTY
47317: LIST
47318: LIST
47319: PUSH
47320: LD_INT 4
47322: NEG
47323: PUSH
47324: LD_INT 1
47326: NEG
47327: PUSH
47328: EMPTY
47329: LIST
47330: LIST
47331: PUSH
47332: LD_INT 3
47334: NEG
47335: PUSH
47336: LD_INT 0
47338: PUSH
47339: EMPTY
47340: LIST
47341: LIST
47342: PUSH
47343: LD_INT 3
47345: NEG
47346: PUSH
47347: LD_INT 1
47349: PUSH
47350: EMPTY
47351: LIST
47352: LIST
47353: PUSH
47354: LD_INT 4
47356: NEG
47357: PUSH
47358: LD_INT 1
47360: PUSH
47361: EMPTY
47362: LIST
47363: LIST
47364: PUSH
47365: LD_INT 5
47367: NEG
47368: PUSH
47369: LD_INT 0
47371: PUSH
47372: EMPTY
47373: LIST
47374: LIST
47375: PUSH
47376: LD_INT 5
47378: NEG
47379: PUSH
47380: LD_INT 1
47382: NEG
47383: PUSH
47384: EMPTY
47385: LIST
47386: LIST
47387: PUSH
47388: LD_INT 5
47390: NEG
47391: PUSH
47392: LD_INT 2
47394: NEG
47395: PUSH
47396: EMPTY
47397: LIST
47398: LIST
47399: PUSH
47400: LD_INT 3
47402: NEG
47403: PUSH
47404: LD_INT 2
47406: PUSH
47407: EMPTY
47408: LIST
47409: LIST
47410: PUSH
47411: EMPTY
47412: LIST
47413: LIST
47414: LIST
47415: LIST
47416: LIST
47417: LIST
47418: LIST
47419: LIST
47420: LIST
47421: LIST
47422: LIST
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: LIST
47429: LIST
47430: LIST
47431: LIST
47432: LIST
47433: LIST
47434: LIST
47435: LIST
47436: LIST
47437: LIST
47438: LIST
47439: LIST
47440: LIST
47441: LIST
47442: LIST
47443: LIST
47444: LIST
47445: LIST
47446: LIST
47447: LIST
47448: LIST
47449: LIST
47450: LIST
47451: LIST
47452: LIST
47453: LIST
47454: LIST
47455: LIST
47456: LIST
47457: ST_TO_ADDR
// end ; end ;
47458: GO 47461
47460: POP
// case btype of b_depot , b_warehouse :
47461: LD_VAR 0 1
47465: PUSH
47466: LD_INT 0
47468: DOUBLE
47469: EQUAL
47470: IFTRUE 47480
47472: LD_INT 1
47474: DOUBLE
47475: EQUAL
47476: IFTRUE 47480
47478: GO 47681
47480: POP
// case nation of nation_american :
47481: LD_VAR 0 5
47485: PUSH
47486: LD_INT 1
47488: DOUBLE
47489: EQUAL
47490: IFTRUE 47494
47492: GO 47550
47494: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
47495: LD_ADDR_VAR 0 9
47499: PUSH
47500: LD_VAR 0 11
47504: PUSH
47505: LD_VAR 0 12
47509: PUSH
47510: LD_VAR 0 13
47514: PUSH
47515: LD_VAR 0 14
47519: PUSH
47520: LD_VAR 0 15
47524: PUSH
47525: LD_VAR 0 16
47529: PUSH
47530: EMPTY
47531: LIST
47532: LIST
47533: LIST
47534: LIST
47535: LIST
47536: LIST
47537: PUSH
47538: LD_VAR 0 4
47542: PUSH
47543: LD_INT 1
47545: PLUS
47546: ARRAY
47547: ST_TO_ADDR
47548: GO 47679
47550: LD_INT 2
47552: DOUBLE
47553: EQUAL
47554: IFTRUE 47558
47556: GO 47614
47558: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
47559: LD_ADDR_VAR 0 9
47563: PUSH
47564: LD_VAR 0 17
47568: PUSH
47569: LD_VAR 0 18
47573: PUSH
47574: LD_VAR 0 19
47578: PUSH
47579: LD_VAR 0 20
47583: PUSH
47584: LD_VAR 0 21
47588: PUSH
47589: LD_VAR 0 22
47593: PUSH
47594: EMPTY
47595: LIST
47596: LIST
47597: LIST
47598: LIST
47599: LIST
47600: LIST
47601: PUSH
47602: LD_VAR 0 4
47606: PUSH
47607: LD_INT 1
47609: PLUS
47610: ARRAY
47611: ST_TO_ADDR
47612: GO 47679
47614: LD_INT 3
47616: DOUBLE
47617: EQUAL
47618: IFTRUE 47622
47620: GO 47678
47622: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
47623: LD_ADDR_VAR 0 9
47627: PUSH
47628: LD_VAR 0 23
47632: PUSH
47633: LD_VAR 0 24
47637: PUSH
47638: LD_VAR 0 25
47642: PUSH
47643: LD_VAR 0 26
47647: PUSH
47648: LD_VAR 0 27
47652: PUSH
47653: LD_VAR 0 28
47657: PUSH
47658: EMPTY
47659: LIST
47660: LIST
47661: LIST
47662: LIST
47663: LIST
47664: LIST
47665: PUSH
47666: LD_VAR 0 4
47670: PUSH
47671: LD_INT 1
47673: PLUS
47674: ARRAY
47675: ST_TO_ADDR
47676: GO 47679
47678: POP
47679: GO 48234
47681: LD_INT 2
47683: DOUBLE
47684: EQUAL
47685: IFTRUE 47695
47687: LD_INT 3
47689: DOUBLE
47690: EQUAL
47691: IFTRUE 47695
47693: GO 47751
47695: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
47696: LD_ADDR_VAR 0 9
47700: PUSH
47701: LD_VAR 0 29
47705: PUSH
47706: LD_VAR 0 30
47710: PUSH
47711: LD_VAR 0 31
47715: PUSH
47716: LD_VAR 0 32
47720: PUSH
47721: LD_VAR 0 33
47725: PUSH
47726: LD_VAR 0 34
47730: PUSH
47731: EMPTY
47732: LIST
47733: LIST
47734: LIST
47735: LIST
47736: LIST
47737: LIST
47738: PUSH
47739: LD_VAR 0 4
47743: PUSH
47744: LD_INT 1
47746: PLUS
47747: ARRAY
47748: ST_TO_ADDR
47749: GO 48234
47751: LD_INT 16
47753: DOUBLE
47754: EQUAL
47755: IFTRUE 47813
47757: LD_INT 17
47759: DOUBLE
47760: EQUAL
47761: IFTRUE 47813
47763: LD_INT 18
47765: DOUBLE
47766: EQUAL
47767: IFTRUE 47813
47769: LD_INT 19
47771: DOUBLE
47772: EQUAL
47773: IFTRUE 47813
47775: LD_INT 22
47777: DOUBLE
47778: EQUAL
47779: IFTRUE 47813
47781: LD_INT 20
47783: DOUBLE
47784: EQUAL
47785: IFTRUE 47813
47787: LD_INT 21
47789: DOUBLE
47790: EQUAL
47791: IFTRUE 47813
47793: LD_INT 23
47795: DOUBLE
47796: EQUAL
47797: IFTRUE 47813
47799: LD_INT 24
47801: DOUBLE
47802: EQUAL
47803: IFTRUE 47813
47805: LD_INT 25
47807: DOUBLE
47808: EQUAL
47809: IFTRUE 47813
47811: GO 47869
47813: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47814: LD_ADDR_VAR 0 9
47818: PUSH
47819: LD_VAR 0 35
47823: PUSH
47824: LD_VAR 0 36
47828: PUSH
47829: LD_VAR 0 37
47833: PUSH
47834: LD_VAR 0 38
47838: PUSH
47839: LD_VAR 0 39
47843: PUSH
47844: LD_VAR 0 40
47848: PUSH
47849: EMPTY
47850: LIST
47851: LIST
47852: LIST
47853: LIST
47854: LIST
47855: LIST
47856: PUSH
47857: LD_VAR 0 4
47861: PUSH
47862: LD_INT 1
47864: PLUS
47865: ARRAY
47866: ST_TO_ADDR
47867: GO 48234
47869: LD_INT 6
47871: DOUBLE
47872: EQUAL
47873: IFTRUE 47925
47875: LD_INT 7
47877: DOUBLE
47878: EQUAL
47879: IFTRUE 47925
47881: LD_INT 8
47883: DOUBLE
47884: EQUAL
47885: IFTRUE 47925
47887: LD_INT 13
47889: DOUBLE
47890: EQUAL
47891: IFTRUE 47925
47893: LD_INT 12
47895: DOUBLE
47896: EQUAL
47897: IFTRUE 47925
47899: LD_INT 15
47901: DOUBLE
47902: EQUAL
47903: IFTRUE 47925
47905: LD_INT 11
47907: DOUBLE
47908: EQUAL
47909: IFTRUE 47925
47911: LD_INT 14
47913: DOUBLE
47914: EQUAL
47915: IFTRUE 47925
47917: LD_INT 10
47919: DOUBLE
47920: EQUAL
47921: IFTRUE 47925
47923: GO 47981
47925: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
47926: LD_ADDR_VAR 0 9
47930: PUSH
47931: LD_VAR 0 41
47935: PUSH
47936: LD_VAR 0 42
47940: PUSH
47941: LD_VAR 0 43
47945: PUSH
47946: LD_VAR 0 44
47950: PUSH
47951: LD_VAR 0 45
47955: PUSH
47956: LD_VAR 0 46
47960: PUSH
47961: EMPTY
47962: LIST
47963: LIST
47964: LIST
47965: LIST
47966: LIST
47967: LIST
47968: PUSH
47969: LD_VAR 0 4
47973: PUSH
47974: LD_INT 1
47976: PLUS
47977: ARRAY
47978: ST_TO_ADDR
47979: GO 48234
47981: LD_INT 36
47983: DOUBLE
47984: EQUAL
47985: IFTRUE 47989
47987: GO 48045
47989: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47990: LD_ADDR_VAR 0 9
47994: PUSH
47995: LD_VAR 0 47
47999: PUSH
48000: LD_VAR 0 48
48004: PUSH
48005: LD_VAR 0 49
48009: PUSH
48010: LD_VAR 0 50
48014: PUSH
48015: LD_VAR 0 51
48019: PUSH
48020: LD_VAR 0 52
48024: PUSH
48025: EMPTY
48026: LIST
48027: LIST
48028: LIST
48029: LIST
48030: LIST
48031: LIST
48032: PUSH
48033: LD_VAR 0 4
48037: PUSH
48038: LD_INT 1
48040: PLUS
48041: ARRAY
48042: ST_TO_ADDR
48043: GO 48234
48045: LD_INT 4
48047: DOUBLE
48048: EQUAL
48049: IFTRUE 48071
48051: LD_INT 5
48053: DOUBLE
48054: EQUAL
48055: IFTRUE 48071
48057: LD_INT 34
48059: DOUBLE
48060: EQUAL
48061: IFTRUE 48071
48063: LD_INT 37
48065: DOUBLE
48066: EQUAL
48067: IFTRUE 48071
48069: GO 48127
48071: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
48072: LD_ADDR_VAR 0 9
48076: PUSH
48077: LD_VAR 0 53
48081: PUSH
48082: LD_VAR 0 54
48086: PUSH
48087: LD_VAR 0 55
48091: PUSH
48092: LD_VAR 0 56
48096: PUSH
48097: LD_VAR 0 57
48101: PUSH
48102: LD_VAR 0 58
48106: PUSH
48107: EMPTY
48108: LIST
48109: LIST
48110: LIST
48111: LIST
48112: LIST
48113: LIST
48114: PUSH
48115: LD_VAR 0 4
48119: PUSH
48120: LD_INT 1
48122: PLUS
48123: ARRAY
48124: ST_TO_ADDR
48125: GO 48234
48127: LD_INT 31
48129: DOUBLE
48130: EQUAL
48131: IFTRUE 48177
48133: LD_INT 32
48135: DOUBLE
48136: EQUAL
48137: IFTRUE 48177
48139: LD_INT 33
48141: DOUBLE
48142: EQUAL
48143: IFTRUE 48177
48145: LD_INT 27
48147: DOUBLE
48148: EQUAL
48149: IFTRUE 48177
48151: LD_INT 26
48153: DOUBLE
48154: EQUAL
48155: IFTRUE 48177
48157: LD_INT 28
48159: DOUBLE
48160: EQUAL
48161: IFTRUE 48177
48163: LD_INT 29
48165: DOUBLE
48166: EQUAL
48167: IFTRUE 48177
48169: LD_INT 30
48171: DOUBLE
48172: EQUAL
48173: IFTRUE 48177
48175: GO 48233
48177: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
48178: LD_ADDR_VAR 0 9
48182: PUSH
48183: LD_VAR 0 59
48187: PUSH
48188: LD_VAR 0 60
48192: PUSH
48193: LD_VAR 0 61
48197: PUSH
48198: LD_VAR 0 62
48202: PUSH
48203: LD_VAR 0 63
48207: PUSH
48208: LD_VAR 0 64
48212: PUSH
48213: EMPTY
48214: LIST
48215: LIST
48216: LIST
48217: LIST
48218: LIST
48219: LIST
48220: PUSH
48221: LD_VAR 0 4
48225: PUSH
48226: LD_INT 1
48228: PLUS
48229: ARRAY
48230: ST_TO_ADDR
48231: GO 48234
48233: POP
// temp_list2 = [ ] ;
48234: LD_ADDR_VAR 0 10
48238: PUSH
48239: EMPTY
48240: ST_TO_ADDR
// for i in temp_list do
48241: LD_ADDR_VAR 0 8
48245: PUSH
48246: LD_VAR 0 9
48250: PUSH
48251: FOR_IN
48252: IFFALSE 48304
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
48254: LD_ADDR_VAR 0 10
48258: PUSH
48259: LD_VAR 0 10
48263: PUSH
48264: LD_VAR 0 8
48268: PUSH
48269: LD_INT 1
48271: ARRAY
48272: PUSH
48273: LD_VAR 0 2
48277: PLUS
48278: PUSH
48279: LD_VAR 0 8
48283: PUSH
48284: LD_INT 2
48286: ARRAY
48287: PUSH
48288: LD_VAR 0 3
48292: PLUS
48293: PUSH
48294: EMPTY
48295: LIST
48296: LIST
48297: PUSH
48298: EMPTY
48299: LIST
48300: ADD
48301: ST_TO_ADDR
48302: GO 48251
48304: POP
48305: POP
// result = temp_list2 ;
48306: LD_ADDR_VAR 0 7
48310: PUSH
48311: LD_VAR 0 10
48315: ST_TO_ADDR
// end ;
48316: LD_VAR 0 7
48320: RET
// export function EnemyInRange ( unit , dist ) ; begin
48321: LD_INT 0
48323: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
48324: LD_ADDR_VAR 0 3
48328: PUSH
48329: LD_VAR 0 1
48333: PPUSH
48334: CALL_OW 255
48338: PPUSH
48339: LD_VAR 0 1
48343: PPUSH
48344: CALL_OW 250
48348: PPUSH
48349: LD_VAR 0 1
48353: PPUSH
48354: CALL_OW 251
48358: PPUSH
48359: LD_VAR 0 2
48363: PPUSH
48364: CALL 22425 0 4
48368: PUSH
48369: LD_INT 4
48371: ARRAY
48372: ST_TO_ADDR
// end ;
48373: LD_VAR 0 3
48377: RET
// export function PlayerSeeMe ( unit ) ; begin
48378: LD_INT 0
48380: PPUSH
// result := See ( your_side , unit ) ;
48381: LD_ADDR_VAR 0 2
48385: PUSH
48386: LD_OWVAR 2
48390: PPUSH
48391: LD_VAR 0 1
48395: PPUSH
48396: CALL_OW 292
48400: ST_TO_ADDR
// end ;
48401: LD_VAR 0 2
48405: RET
// export function ReverseDir ( unit ) ; begin
48406: LD_INT 0
48408: PPUSH
// if not unit then
48409: LD_VAR 0 1
48413: NOT
48414: IFFALSE 48418
// exit ;
48416: GO 48441
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
48418: LD_ADDR_VAR 0 2
48422: PUSH
48423: LD_VAR 0 1
48427: PPUSH
48428: CALL_OW 254
48432: PUSH
48433: LD_INT 3
48435: PLUS
48436: PUSH
48437: LD_INT 6
48439: MOD
48440: ST_TO_ADDR
// end ;
48441: LD_VAR 0 2
48445: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
48446: LD_INT 0
48448: PPUSH
48449: PPUSH
48450: PPUSH
48451: PPUSH
48452: PPUSH
// if not hexes then
48453: LD_VAR 0 2
48457: NOT
48458: IFFALSE 48462
// exit ;
48460: GO 48610
// dist := 9999 ;
48462: LD_ADDR_VAR 0 5
48466: PUSH
48467: LD_INT 9999
48469: ST_TO_ADDR
// for i = 1 to hexes do
48470: LD_ADDR_VAR 0 4
48474: PUSH
48475: DOUBLE
48476: LD_INT 1
48478: DEC
48479: ST_TO_ADDR
48480: LD_VAR 0 2
48484: PUSH
48485: FOR_TO
48486: IFFALSE 48598
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
48488: LD_VAR 0 1
48492: PPUSH
48493: LD_VAR 0 2
48497: PUSH
48498: LD_VAR 0 4
48502: ARRAY
48503: PUSH
48504: LD_INT 1
48506: ARRAY
48507: PPUSH
48508: LD_VAR 0 2
48512: PUSH
48513: LD_VAR 0 4
48517: ARRAY
48518: PUSH
48519: LD_INT 2
48521: ARRAY
48522: PPUSH
48523: CALL_OW 297
48527: PUSH
48528: LD_VAR 0 5
48532: LESS
48533: IFFALSE 48596
// begin hex := hexes [ i ] ;
48535: LD_ADDR_VAR 0 7
48539: PUSH
48540: LD_VAR 0 2
48544: PUSH
48545: LD_VAR 0 4
48549: ARRAY
48550: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
48551: LD_ADDR_VAR 0 5
48555: PUSH
48556: LD_VAR 0 1
48560: PPUSH
48561: LD_VAR 0 2
48565: PUSH
48566: LD_VAR 0 4
48570: ARRAY
48571: PUSH
48572: LD_INT 1
48574: ARRAY
48575: PPUSH
48576: LD_VAR 0 2
48580: PUSH
48581: LD_VAR 0 4
48585: ARRAY
48586: PUSH
48587: LD_INT 2
48589: ARRAY
48590: PPUSH
48591: CALL_OW 297
48595: ST_TO_ADDR
// end ; end ;
48596: GO 48485
48598: POP
48599: POP
// result := hex ;
48600: LD_ADDR_VAR 0 3
48604: PUSH
48605: LD_VAR 0 7
48609: ST_TO_ADDR
// end ;
48610: LD_VAR 0 3
48614: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
48615: LD_INT 0
48617: PPUSH
48618: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
48619: LD_VAR 0 1
48623: NOT
48624: PUSH
48625: LD_VAR 0 1
48629: PUSH
48630: LD_INT 21
48632: PUSH
48633: LD_INT 2
48635: PUSH
48636: EMPTY
48637: LIST
48638: LIST
48639: PUSH
48640: LD_INT 23
48642: PUSH
48643: LD_INT 2
48645: PUSH
48646: EMPTY
48647: LIST
48648: LIST
48649: PUSH
48650: EMPTY
48651: LIST
48652: LIST
48653: PPUSH
48654: CALL_OW 69
48658: IN
48659: NOT
48660: OR
48661: IFFALSE 48665
// exit ;
48663: GO 48712
// for i = 1 to 3 do
48665: LD_ADDR_VAR 0 3
48669: PUSH
48670: DOUBLE
48671: LD_INT 1
48673: DEC
48674: ST_TO_ADDR
48675: LD_INT 3
48677: PUSH
48678: FOR_TO
48679: IFFALSE 48710
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
48681: LD_VAR 0 1
48685: PPUSH
48686: CALL_OW 250
48690: PPUSH
48691: LD_VAR 0 1
48695: PPUSH
48696: CALL_OW 251
48700: PPUSH
48701: LD_INT 1
48703: PPUSH
48704: CALL_OW 453
48708: GO 48678
48710: POP
48711: POP
// end ;
48712: LD_VAR 0 2
48716: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48717: LD_INT 0
48719: PPUSH
48720: PPUSH
48721: PPUSH
48722: PPUSH
48723: PPUSH
48724: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48725: LD_VAR 0 1
48729: NOT
48730: PUSH
48731: LD_VAR 0 2
48735: NOT
48736: OR
48737: PUSH
48738: LD_VAR 0 1
48742: PPUSH
48743: CALL_OW 314
48747: OR
48748: IFFALSE 48752
// exit ;
48750: GO 49193
// x := GetX ( enemy_unit ) ;
48752: LD_ADDR_VAR 0 7
48756: PUSH
48757: LD_VAR 0 2
48761: PPUSH
48762: CALL_OW 250
48766: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48767: LD_ADDR_VAR 0 8
48771: PUSH
48772: LD_VAR 0 2
48776: PPUSH
48777: CALL_OW 251
48781: ST_TO_ADDR
// if not x or not y then
48782: LD_VAR 0 7
48786: NOT
48787: PUSH
48788: LD_VAR 0 8
48792: NOT
48793: OR
48794: IFFALSE 48798
// exit ;
48796: GO 49193
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48798: LD_ADDR_VAR 0 6
48802: PUSH
48803: LD_VAR 0 7
48807: PPUSH
48808: LD_INT 0
48810: PPUSH
48811: LD_INT 4
48813: PPUSH
48814: CALL_OW 272
48818: PUSH
48819: LD_VAR 0 8
48823: PPUSH
48824: LD_INT 0
48826: PPUSH
48827: LD_INT 4
48829: PPUSH
48830: CALL_OW 273
48834: PUSH
48835: EMPTY
48836: LIST
48837: LIST
48838: PUSH
48839: LD_VAR 0 7
48843: PPUSH
48844: LD_INT 1
48846: PPUSH
48847: LD_INT 4
48849: PPUSH
48850: CALL_OW 272
48854: PUSH
48855: LD_VAR 0 8
48859: PPUSH
48860: LD_INT 1
48862: PPUSH
48863: LD_INT 4
48865: PPUSH
48866: CALL_OW 273
48870: PUSH
48871: EMPTY
48872: LIST
48873: LIST
48874: PUSH
48875: LD_VAR 0 7
48879: PPUSH
48880: LD_INT 2
48882: PPUSH
48883: LD_INT 4
48885: PPUSH
48886: CALL_OW 272
48890: PUSH
48891: LD_VAR 0 8
48895: PPUSH
48896: LD_INT 2
48898: PPUSH
48899: LD_INT 4
48901: PPUSH
48902: CALL_OW 273
48906: PUSH
48907: EMPTY
48908: LIST
48909: LIST
48910: PUSH
48911: LD_VAR 0 7
48915: PPUSH
48916: LD_INT 3
48918: PPUSH
48919: LD_INT 4
48921: PPUSH
48922: CALL_OW 272
48926: PUSH
48927: LD_VAR 0 8
48931: PPUSH
48932: LD_INT 3
48934: PPUSH
48935: LD_INT 4
48937: PPUSH
48938: CALL_OW 273
48942: PUSH
48943: EMPTY
48944: LIST
48945: LIST
48946: PUSH
48947: LD_VAR 0 7
48951: PPUSH
48952: LD_INT 4
48954: PPUSH
48955: LD_INT 4
48957: PPUSH
48958: CALL_OW 272
48962: PUSH
48963: LD_VAR 0 8
48967: PPUSH
48968: LD_INT 4
48970: PPUSH
48971: LD_INT 4
48973: PPUSH
48974: CALL_OW 273
48978: PUSH
48979: EMPTY
48980: LIST
48981: LIST
48982: PUSH
48983: LD_VAR 0 7
48987: PPUSH
48988: LD_INT 5
48990: PPUSH
48991: LD_INT 4
48993: PPUSH
48994: CALL_OW 272
48998: PUSH
48999: LD_VAR 0 8
49003: PPUSH
49004: LD_INT 5
49006: PPUSH
49007: LD_INT 4
49009: PPUSH
49010: CALL_OW 273
49014: PUSH
49015: EMPTY
49016: LIST
49017: LIST
49018: PUSH
49019: EMPTY
49020: LIST
49021: LIST
49022: LIST
49023: LIST
49024: LIST
49025: LIST
49026: ST_TO_ADDR
// for i = tmp downto 1 do
49027: LD_ADDR_VAR 0 4
49031: PUSH
49032: DOUBLE
49033: LD_VAR 0 6
49037: INC
49038: ST_TO_ADDR
49039: LD_INT 1
49041: PUSH
49042: FOR_DOWNTO
49043: IFFALSE 49144
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
49045: LD_VAR 0 6
49049: PUSH
49050: LD_VAR 0 4
49054: ARRAY
49055: PUSH
49056: LD_INT 1
49058: ARRAY
49059: PPUSH
49060: LD_VAR 0 6
49064: PUSH
49065: LD_VAR 0 4
49069: ARRAY
49070: PUSH
49071: LD_INT 2
49073: ARRAY
49074: PPUSH
49075: CALL_OW 488
49079: NOT
49080: PUSH
49081: LD_VAR 0 6
49085: PUSH
49086: LD_VAR 0 4
49090: ARRAY
49091: PUSH
49092: LD_INT 1
49094: ARRAY
49095: PPUSH
49096: LD_VAR 0 6
49100: PUSH
49101: LD_VAR 0 4
49105: ARRAY
49106: PUSH
49107: LD_INT 2
49109: ARRAY
49110: PPUSH
49111: CALL_OW 428
49115: PUSH
49116: LD_INT 0
49118: NONEQUAL
49119: OR
49120: IFFALSE 49142
// tmp := Delete ( tmp , i ) ;
49122: LD_ADDR_VAR 0 6
49126: PUSH
49127: LD_VAR 0 6
49131: PPUSH
49132: LD_VAR 0 4
49136: PPUSH
49137: CALL_OW 3
49141: ST_TO_ADDR
49142: GO 49042
49144: POP
49145: POP
// j := GetClosestHex ( unit , tmp ) ;
49146: LD_ADDR_VAR 0 5
49150: PUSH
49151: LD_VAR 0 1
49155: PPUSH
49156: LD_VAR 0 6
49160: PPUSH
49161: CALL 48446 0 2
49165: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
49166: LD_VAR 0 1
49170: PPUSH
49171: LD_VAR 0 5
49175: PUSH
49176: LD_INT 1
49178: ARRAY
49179: PPUSH
49180: LD_VAR 0 5
49184: PUSH
49185: LD_INT 2
49187: ARRAY
49188: PPUSH
49189: CALL_OW 111
// end ;
49193: LD_VAR 0 3
49197: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
49198: LD_INT 0
49200: PPUSH
49201: PPUSH
49202: PPUSH
// uc_side = 0 ;
49203: LD_ADDR_OWVAR 20
49207: PUSH
49208: LD_INT 0
49210: ST_TO_ADDR
// uc_nation = 0 ;
49211: LD_ADDR_OWVAR 21
49215: PUSH
49216: LD_INT 0
49218: ST_TO_ADDR
// InitHc ;
49219: CALL_OW 19
// InitVc ;
49223: CALL_OW 20
// if mastodonts then
49227: LD_VAR 0 6
49231: IFFALSE 49298
// for i = 1 to mastodonts do
49233: LD_ADDR_VAR 0 11
49237: PUSH
49238: DOUBLE
49239: LD_INT 1
49241: DEC
49242: ST_TO_ADDR
49243: LD_VAR 0 6
49247: PUSH
49248: FOR_TO
49249: IFFALSE 49296
// begin vc_chassis := 31 ;
49251: LD_ADDR_OWVAR 37
49255: PUSH
49256: LD_INT 31
49258: ST_TO_ADDR
// vc_control := control_rider ;
49259: LD_ADDR_OWVAR 38
49263: PUSH
49264: LD_INT 4
49266: ST_TO_ADDR
// animal := CreateVehicle ;
49267: LD_ADDR_VAR 0 12
49271: PUSH
49272: CALL_OW 45
49276: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49277: LD_VAR 0 12
49281: PPUSH
49282: LD_VAR 0 8
49286: PPUSH
49287: LD_INT 0
49289: PPUSH
49290: CALL 56069 0 3
// end ;
49294: GO 49248
49296: POP
49297: POP
// if horses then
49298: LD_VAR 0 5
49302: IFFALSE 49369
// for i = 1 to horses do
49304: LD_ADDR_VAR 0 11
49308: PUSH
49309: DOUBLE
49310: LD_INT 1
49312: DEC
49313: ST_TO_ADDR
49314: LD_VAR 0 5
49318: PUSH
49319: FOR_TO
49320: IFFALSE 49367
// begin hc_class := 21 ;
49322: LD_ADDR_OWVAR 28
49326: PUSH
49327: LD_INT 21
49329: ST_TO_ADDR
// hc_gallery :=  ;
49330: LD_ADDR_OWVAR 33
49334: PUSH
49335: LD_STRING 
49337: ST_TO_ADDR
// animal := CreateHuman ;
49338: LD_ADDR_VAR 0 12
49342: PUSH
49343: CALL_OW 44
49347: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49348: LD_VAR 0 12
49352: PPUSH
49353: LD_VAR 0 8
49357: PPUSH
49358: LD_INT 0
49360: PPUSH
49361: CALL 56069 0 3
// end ;
49365: GO 49319
49367: POP
49368: POP
// if birds then
49369: LD_VAR 0 1
49373: IFFALSE 49440
// for i = 1 to birds do
49375: LD_ADDR_VAR 0 11
49379: PUSH
49380: DOUBLE
49381: LD_INT 1
49383: DEC
49384: ST_TO_ADDR
49385: LD_VAR 0 1
49389: PUSH
49390: FOR_TO
49391: IFFALSE 49438
// begin hc_class = 18 ;
49393: LD_ADDR_OWVAR 28
49397: PUSH
49398: LD_INT 18
49400: ST_TO_ADDR
// hc_gallery =  ;
49401: LD_ADDR_OWVAR 33
49405: PUSH
49406: LD_STRING 
49408: ST_TO_ADDR
// animal := CreateHuman ;
49409: LD_ADDR_VAR 0 12
49413: PUSH
49414: CALL_OW 44
49418: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49419: LD_VAR 0 12
49423: PPUSH
49424: LD_VAR 0 8
49428: PPUSH
49429: LD_INT 0
49431: PPUSH
49432: CALL 56069 0 3
// end ;
49436: GO 49390
49438: POP
49439: POP
// if tigers then
49440: LD_VAR 0 2
49444: IFFALSE 49528
// for i = 1 to tigers do
49446: LD_ADDR_VAR 0 11
49450: PUSH
49451: DOUBLE
49452: LD_INT 1
49454: DEC
49455: ST_TO_ADDR
49456: LD_VAR 0 2
49460: PUSH
49461: FOR_TO
49462: IFFALSE 49526
// begin hc_class = class_tiger ;
49464: LD_ADDR_OWVAR 28
49468: PUSH
49469: LD_INT 14
49471: ST_TO_ADDR
// hc_gallery =  ;
49472: LD_ADDR_OWVAR 33
49476: PUSH
49477: LD_STRING 
49479: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49480: LD_ADDR_OWVAR 35
49484: PUSH
49485: LD_INT 7
49487: NEG
49488: PPUSH
49489: LD_INT 7
49491: PPUSH
49492: CALL_OW 12
49496: ST_TO_ADDR
// animal := CreateHuman ;
49497: LD_ADDR_VAR 0 12
49501: PUSH
49502: CALL_OW 44
49506: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49507: LD_VAR 0 12
49511: PPUSH
49512: LD_VAR 0 8
49516: PPUSH
49517: LD_INT 0
49519: PPUSH
49520: CALL 56069 0 3
// end ;
49524: GO 49461
49526: POP
49527: POP
// if apemans then
49528: LD_VAR 0 3
49532: IFFALSE 49655
// for i = 1 to apemans do
49534: LD_ADDR_VAR 0 11
49538: PUSH
49539: DOUBLE
49540: LD_INT 1
49542: DEC
49543: ST_TO_ADDR
49544: LD_VAR 0 3
49548: PUSH
49549: FOR_TO
49550: IFFALSE 49653
// begin hc_class = class_apeman ;
49552: LD_ADDR_OWVAR 28
49556: PUSH
49557: LD_INT 12
49559: ST_TO_ADDR
// hc_gallery =  ;
49560: LD_ADDR_OWVAR 33
49564: PUSH
49565: LD_STRING 
49567: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
49568: LD_ADDR_OWVAR 35
49572: PUSH
49573: LD_INT 5
49575: NEG
49576: PPUSH
49577: LD_INT 5
49579: PPUSH
49580: CALL_OW 12
49584: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49585: LD_ADDR_OWVAR 31
49589: PUSH
49590: LD_INT 1
49592: PPUSH
49593: LD_INT 3
49595: PPUSH
49596: CALL_OW 12
49600: PUSH
49601: LD_INT 1
49603: PPUSH
49604: LD_INT 3
49606: PPUSH
49607: CALL_OW 12
49611: PUSH
49612: LD_INT 0
49614: PUSH
49615: LD_INT 0
49617: PUSH
49618: EMPTY
49619: LIST
49620: LIST
49621: LIST
49622: LIST
49623: ST_TO_ADDR
// animal := CreateHuman ;
49624: LD_ADDR_VAR 0 12
49628: PUSH
49629: CALL_OW 44
49633: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49634: LD_VAR 0 12
49638: PPUSH
49639: LD_VAR 0 8
49643: PPUSH
49644: LD_INT 0
49646: PPUSH
49647: CALL 56069 0 3
// end ;
49651: GO 49549
49653: POP
49654: POP
// if enchidnas then
49655: LD_VAR 0 4
49659: IFFALSE 49726
// for i = 1 to enchidnas do
49661: LD_ADDR_VAR 0 11
49665: PUSH
49666: DOUBLE
49667: LD_INT 1
49669: DEC
49670: ST_TO_ADDR
49671: LD_VAR 0 4
49675: PUSH
49676: FOR_TO
49677: IFFALSE 49724
// begin hc_class = 13 ;
49679: LD_ADDR_OWVAR 28
49683: PUSH
49684: LD_INT 13
49686: ST_TO_ADDR
// hc_gallery =  ;
49687: LD_ADDR_OWVAR 33
49691: PUSH
49692: LD_STRING 
49694: ST_TO_ADDR
// animal := CreateHuman ;
49695: LD_ADDR_VAR 0 12
49699: PUSH
49700: CALL_OW 44
49704: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49705: LD_VAR 0 12
49709: PPUSH
49710: LD_VAR 0 8
49714: PPUSH
49715: LD_INT 0
49717: PPUSH
49718: CALL 56069 0 3
// end ;
49722: GO 49676
49724: POP
49725: POP
// if fishes then
49726: LD_VAR 0 7
49730: IFFALSE 49797
// for i = 1 to fishes do
49732: LD_ADDR_VAR 0 11
49736: PUSH
49737: DOUBLE
49738: LD_INT 1
49740: DEC
49741: ST_TO_ADDR
49742: LD_VAR 0 7
49746: PUSH
49747: FOR_TO
49748: IFFALSE 49795
// begin hc_class = 20 ;
49750: LD_ADDR_OWVAR 28
49754: PUSH
49755: LD_INT 20
49757: ST_TO_ADDR
// hc_gallery =  ;
49758: LD_ADDR_OWVAR 33
49762: PUSH
49763: LD_STRING 
49765: ST_TO_ADDR
// animal := CreateHuman ;
49766: LD_ADDR_VAR 0 12
49770: PUSH
49771: CALL_OW 44
49775: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49776: LD_VAR 0 12
49780: PPUSH
49781: LD_VAR 0 9
49785: PPUSH
49786: LD_INT 0
49788: PPUSH
49789: CALL 56069 0 3
// end ;
49793: GO 49747
49795: POP
49796: POP
// end ;
49797: LD_VAR 0 10
49801: RET
// export function WantHeal ( sci , unit ) ; begin
49802: LD_INT 0
49804: PPUSH
// if GetTaskList ( sci ) > 0 then
49805: LD_VAR 0 1
49809: PPUSH
49810: CALL_OW 437
49814: PUSH
49815: LD_INT 0
49817: GREATER
49818: IFFALSE 49888
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49820: LD_VAR 0 1
49824: PPUSH
49825: CALL_OW 437
49829: PUSH
49830: LD_INT 1
49832: ARRAY
49833: PUSH
49834: LD_INT 1
49836: ARRAY
49837: PUSH
49838: LD_STRING l
49840: EQUAL
49841: PUSH
49842: LD_VAR 0 1
49846: PPUSH
49847: CALL_OW 437
49851: PUSH
49852: LD_INT 1
49854: ARRAY
49855: PUSH
49856: LD_INT 4
49858: ARRAY
49859: PUSH
49860: LD_VAR 0 2
49864: EQUAL
49865: AND
49866: IFFALSE 49878
// result := true else
49868: LD_ADDR_VAR 0 3
49872: PUSH
49873: LD_INT 1
49875: ST_TO_ADDR
49876: GO 49886
// result := false ;
49878: LD_ADDR_VAR 0 3
49882: PUSH
49883: LD_INT 0
49885: ST_TO_ADDR
// end else
49886: GO 49896
// result := false ;
49888: LD_ADDR_VAR 0 3
49892: PUSH
49893: LD_INT 0
49895: ST_TO_ADDR
// end ;
49896: LD_VAR 0 3
49900: RET
// export function HealTarget ( sci ) ; begin
49901: LD_INT 0
49903: PPUSH
// if not sci then
49904: LD_VAR 0 1
49908: NOT
49909: IFFALSE 49913
// exit ;
49911: GO 49978
// result := 0 ;
49913: LD_ADDR_VAR 0 2
49917: PUSH
49918: LD_INT 0
49920: ST_TO_ADDR
// if GetTaskList ( sci ) then
49921: LD_VAR 0 1
49925: PPUSH
49926: CALL_OW 437
49930: IFFALSE 49978
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49932: LD_VAR 0 1
49936: PPUSH
49937: CALL_OW 437
49941: PUSH
49942: LD_INT 1
49944: ARRAY
49945: PUSH
49946: LD_INT 1
49948: ARRAY
49949: PUSH
49950: LD_STRING l
49952: EQUAL
49953: IFFALSE 49978
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49955: LD_ADDR_VAR 0 2
49959: PUSH
49960: LD_VAR 0 1
49964: PPUSH
49965: CALL_OW 437
49969: PUSH
49970: LD_INT 1
49972: ARRAY
49973: PUSH
49974: LD_INT 4
49976: ARRAY
49977: ST_TO_ADDR
// end ;
49978: LD_VAR 0 2
49982: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
49983: LD_INT 0
49985: PPUSH
49986: PPUSH
49987: PPUSH
49988: PPUSH
49989: PPUSH
49990: PPUSH
49991: PPUSH
49992: PPUSH
49993: PPUSH
49994: PPUSH
49995: PPUSH
49996: PPUSH
49997: PPUSH
49998: PPUSH
49999: PPUSH
50000: PPUSH
50001: PPUSH
50002: PPUSH
50003: PPUSH
50004: PPUSH
50005: PPUSH
50006: PPUSH
50007: PPUSH
50008: PPUSH
50009: PPUSH
50010: PPUSH
50011: PPUSH
50012: PPUSH
50013: PPUSH
50014: PPUSH
50015: PPUSH
50016: PPUSH
50017: PPUSH
50018: PPUSH
// if not list then
50019: LD_VAR 0 1
50023: NOT
50024: IFFALSE 50028
// exit ;
50026: GO 54680
// base := list [ 1 ] ;
50028: LD_ADDR_VAR 0 3
50032: PUSH
50033: LD_VAR 0 1
50037: PUSH
50038: LD_INT 1
50040: ARRAY
50041: ST_TO_ADDR
// group := list [ 2 ] ;
50042: LD_ADDR_VAR 0 4
50046: PUSH
50047: LD_VAR 0 1
50051: PUSH
50052: LD_INT 2
50054: ARRAY
50055: ST_TO_ADDR
// path := list [ 3 ] ;
50056: LD_ADDR_VAR 0 5
50060: PUSH
50061: LD_VAR 0 1
50065: PUSH
50066: LD_INT 3
50068: ARRAY
50069: ST_TO_ADDR
// flags := list [ 4 ] ;
50070: LD_ADDR_VAR 0 6
50074: PUSH
50075: LD_VAR 0 1
50079: PUSH
50080: LD_INT 4
50082: ARRAY
50083: ST_TO_ADDR
// mined := [ ] ;
50084: LD_ADDR_VAR 0 27
50088: PUSH
50089: EMPTY
50090: ST_TO_ADDR
// bombed := [ ] ;
50091: LD_ADDR_VAR 0 28
50095: PUSH
50096: EMPTY
50097: ST_TO_ADDR
// healers := [ ] ;
50098: LD_ADDR_VAR 0 31
50102: PUSH
50103: EMPTY
50104: ST_TO_ADDR
// to_heal := [ ] ;
50105: LD_ADDR_VAR 0 30
50109: PUSH
50110: EMPTY
50111: ST_TO_ADDR
// repairs := [ ] ;
50112: LD_ADDR_VAR 0 33
50116: PUSH
50117: EMPTY
50118: ST_TO_ADDR
// to_repair := [ ] ;
50119: LD_ADDR_VAR 0 32
50123: PUSH
50124: EMPTY
50125: ST_TO_ADDR
// if not group or not path then
50126: LD_VAR 0 4
50130: NOT
50131: PUSH
50132: LD_VAR 0 5
50136: NOT
50137: OR
50138: IFFALSE 50142
// exit ;
50140: GO 54680
// side := GetSide ( group [ 1 ] ) ;
50142: LD_ADDR_VAR 0 35
50146: PUSH
50147: LD_VAR 0 4
50151: PUSH
50152: LD_INT 1
50154: ARRAY
50155: PPUSH
50156: CALL_OW 255
50160: ST_TO_ADDR
// if flags then
50161: LD_VAR 0 6
50165: IFFALSE 50309
// begin f_ignore_area := flags [ 1 ] ;
50167: LD_ADDR_VAR 0 17
50171: PUSH
50172: LD_VAR 0 6
50176: PUSH
50177: LD_INT 1
50179: ARRAY
50180: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
50181: LD_ADDR_VAR 0 18
50185: PUSH
50186: LD_VAR 0 6
50190: PUSH
50191: LD_INT 2
50193: ARRAY
50194: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
50195: LD_ADDR_VAR 0 19
50199: PUSH
50200: LD_VAR 0 6
50204: PUSH
50205: LD_INT 3
50207: ARRAY
50208: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
50209: LD_ADDR_VAR 0 20
50213: PUSH
50214: LD_VAR 0 6
50218: PUSH
50219: LD_INT 4
50221: ARRAY
50222: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
50223: LD_ADDR_VAR 0 21
50227: PUSH
50228: LD_VAR 0 6
50232: PUSH
50233: LD_INT 5
50235: ARRAY
50236: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
50237: LD_ADDR_VAR 0 22
50241: PUSH
50242: LD_VAR 0 6
50246: PUSH
50247: LD_INT 6
50249: ARRAY
50250: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
50251: LD_ADDR_VAR 0 23
50255: PUSH
50256: LD_VAR 0 6
50260: PUSH
50261: LD_INT 7
50263: ARRAY
50264: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
50265: LD_ADDR_VAR 0 24
50269: PUSH
50270: LD_VAR 0 6
50274: PUSH
50275: LD_INT 8
50277: ARRAY
50278: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
50279: LD_ADDR_VAR 0 25
50283: PUSH
50284: LD_VAR 0 6
50288: PUSH
50289: LD_INT 9
50291: ARRAY
50292: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
50293: LD_ADDR_VAR 0 26
50297: PUSH
50298: LD_VAR 0 6
50302: PUSH
50303: LD_INT 10
50305: ARRAY
50306: ST_TO_ADDR
// end else
50307: GO 50389
// begin f_ignore_area := false ;
50309: LD_ADDR_VAR 0 17
50313: PUSH
50314: LD_INT 0
50316: ST_TO_ADDR
// f_capture := false ;
50317: LD_ADDR_VAR 0 18
50321: PUSH
50322: LD_INT 0
50324: ST_TO_ADDR
// f_ignore_civ := false ;
50325: LD_ADDR_VAR 0 19
50329: PUSH
50330: LD_INT 0
50332: ST_TO_ADDR
// f_murder := false ;
50333: LD_ADDR_VAR 0 20
50337: PUSH
50338: LD_INT 0
50340: ST_TO_ADDR
// f_mines := false ;
50341: LD_ADDR_VAR 0 21
50345: PUSH
50346: LD_INT 0
50348: ST_TO_ADDR
// f_repair := false ;
50349: LD_ADDR_VAR 0 22
50353: PUSH
50354: LD_INT 0
50356: ST_TO_ADDR
// f_heal := false ;
50357: LD_ADDR_VAR 0 23
50361: PUSH
50362: LD_INT 0
50364: ST_TO_ADDR
// f_spacetime := false ;
50365: LD_ADDR_VAR 0 24
50369: PUSH
50370: LD_INT 0
50372: ST_TO_ADDR
// f_attack_depot := false ;
50373: LD_ADDR_VAR 0 25
50377: PUSH
50378: LD_INT 0
50380: ST_TO_ADDR
// f_crawl := false ;
50381: LD_ADDR_VAR 0 26
50385: PUSH
50386: LD_INT 0
50388: ST_TO_ADDR
// end ; if f_heal then
50389: LD_VAR 0 23
50393: IFFALSE 50420
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
50395: LD_ADDR_VAR 0 31
50399: PUSH
50400: LD_VAR 0 4
50404: PPUSH
50405: LD_INT 25
50407: PUSH
50408: LD_INT 4
50410: PUSH
50411: EMPTY
50412: LIST
50413: LIST
50414: PPUSH
50415: CALL_OW 72
50419: ST_TO_ADDR
// if f_repair then
50420: LD_VAR 0 22
50424: IFFALSE 50451
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
50426: LD_ADDR_VAR 0 33
50430: PUSH
50431: LD_VAR 0 4
50435: PPUSH
50436: LD_INT 25
50438: PUSH
50439: LD_INT 3
50441: PUSH
50442: EMPTY
50443: LIST
50444: LIST
50445: PPUSH
50446: CALL_OW 72
50450: ST_TO_ADDR
// units_path := [ ] ;
50451: LD_ADDR_VAR 0 16
50455: PUSH
50456: EMPTY
50457: ST_TO_ADDR
// for i = 1 to group do
50458: LD_ADDR_VAR 0 7
50462: PUSH
50463: DOUBLE
50464: LD_INT 1
50466: DEC
50467: ST_TO_ADDR
50468: LD_VAR 0 4
50472: PUSH
50473: FOR_TO
50474: IFFALSE 50503
// units_path := Replace ( units_path , i , path ) ;
50476: LD_ADDR_VAR 0 16
50480: PUSH
50481: LD_VAR 0 16
50485: PPUSH
50486: LD_VAR 0 7
50490: PPUSH
50491: LD_VAR 0 5
50495: PPUSH
50496: CALL_OW 1
50500: ST_TO_ADDR
50501: GO 50473
50503: POP
50504: POP
// repeat for i = group downto 1 do
50505: LD_ADDR_VAR 0 7
50509: PUSH
50510: DOUBLE
50511: LD_VAR 0 4
50515: INC
50516: ST_TO_ADDR
50517: LD_INT 1
50519: PUSH
50520: FOR_DOWNTO
50521: IFFALSE 54643
// begin wait ( 5 ) ;
50523: LD_INT 5
50525: PPUSH
50526: CALL_OW 67
// tmp := [ ] ;
50530: LD_ADDR_VAR 0 14
50534: PUSH
50535: EMPTY
50536: ST_TO_ADDR
// attacking := false ;
50537: LD_ADDR_VAR 0 29
50541: PUSH
50542: LD_INT 0
50544: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
50545: LD_VAR 0 4
50549: PUSH
50550: LD_VAR 0 7
50554: ARRAY
50555: PPUSH
50556: CALL_OW 301
50560: PUSH
50561: LD_VAR 0 4
50565: PUSH
50566: LD_VAR 0 7
50570: ARRAY
50571: NOT
50572: OR
50573: IFFALSE 50682
// begin if GetType ( group [ i ] ) = unit_human then
50575: LD_VAR 0 4
50579: PUSH
50580: LD_VAR 0 7
50584: ARRAY
50585: PPUSH
50586: CALL_OW 247
50590: PUSH
50591: LD_INT 1
50593: EQUAL
50594: IFFALSE 50640
// begin to_heal := to_heal diff group [ i ] ;
50596: LD_ADDR_VAR 0 30
50600: PUSH
50601: LD_VAR 0 30
50605: PUSH
50606: LD_VAR 0 4
50610: PUSH
50611: LD_VAR 0 7
50615: ARRAY
50616: DIFF
50617: ST_TO_ADDR
// healers := healers diff group [ i ] ;
50618: LD_ADDR_VAR 0 31
50622: PUSH
50623: LD_VAR 0 31
50627: PUSH
50628: LD_VAR 0 4
50632: PUSH
50633: LD_VAR 0 7
50637: ARRAY
50638: DIFF
50639: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
50640: LD_ADDR_VAR 0 4
50644: PUSH
50645: LD_VAR 0 4
50649: PPUSH
50650: LD_VAR 0 7
50654: PPUSH
50655: CALL_OW 3
50659: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
50660: LD_ADDR_VAR 0 16
50664: PUSH
50665: LD_VAR 0 16
50669: PPUSH
50670: LD_VAR 0 7
50674: PPUSH
50675: CALL_OW 3
50679: ST_TO_ADDR
// continue ;
50680: GO 50520
// end ; if f_repair then
50682: LD_VAR 0 22
50686: IFFALSE 51175
// begin if GetType ( group [ i ] ) = unit_vehicle then
50688: LD_VAR 0 4
50692: PUSH
50693: LD_VAR 0 7
50697: ARRAY
50698: PPUSH
50699: CALL_OW 247
50703: PUSH
50704: LD_INT 2
50706: EQUAL
50707: IFFALSE 50897
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
50709: LD_VAR 0 4
50713: PUSH
50714: LD_VAR 0 7
50718: ARRAY
50719: PPUSH
50720: CALL_OW 256
50724: PUSH
50725: LD_INT 700
50727: LESS
50728: PUSH
50729: LD_VAR 0 4
50733: PUSH
50734: LD_VAR 0 7
50738: ARRAY
50739: PUSH
50740: LD_VAR 0 32
50744: IN
50745: NOT
50746: AND
50747: IFFALSE 50771
// to_repair := to_repair union group [ i ] ;
50749: LD_ADDR_VAR 0 32
50753: PUSH
50754: LD_VAR 0 32
50758: PUSH
50759: LD_VAR 0 4
50763: PUSH
50764: LD_VAR 0 7
50768: ARRAY
50769: UNION
50770: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
50771: LD_VAR 0 4
50775: PUSH
50776: LD_VAR 0 7
50780: ARRAY
50781: PPUSH
50782: CALL_OW 256
50786: PUSH
50787: LD_INT 1000
50789: EQUAL
50790: PUSH
50791: LD_VAR 0 4
50795: PUSH
50796: LD_VAR 0 7
50800: ARRAY
50801: PUSH
50802: LD_VAR 0 32
50806: IN
50807: AND
50808: IFFALSE 50832
// to_repair := to_repair diff group [ i ] ;
50810: LD_ADDR_VAR 0 32
50814: PUSH
50815: LD_VAR 0 32
50819: PUSH
50820: LD_VAR 0 4
50824: PUSH
50825: LD_VAR 0 7
50829: ARRAY
50830: DIFF
50831: ST_TO_ADDR
// if group [ i ] in to_repair then
50832: LD_VAR 0 4
50836: PUSH
50837: LD_VAR 0 7
50841: ARRAY
50842: PUSH
50843: LD_VAR 0 32
50847: IN
50848: IFFALSE 50895
// begin if not IsInArea ( group [ i ] , f_repair ) then
50850: LD_VAR 0 4
50854: PUSH
50855: LD_VAR 0 7
50859: ARRAY
50860: PPUSH
50861: LD_VAR 0 22
50865: PPUSH
50866: CALL_OW 308
50870: NOT
50871: IFFALSE 50893
// ComMoveToArea ( group [ i ] , f_repair ) ;
50873: LD_VAR 0 4
50877: PUSH
50878: LD_VAR 0 7
50882: ARRAY
50883: PPUSH
50884: LD_VAR 0 22
50888: PPUSH
50889: CALL_OW 113
// continue ;
50893: GO 50520
// end ; end else
50895: GO 51175
// if group [ i ] in repairs then
50897: LD_VAR 0 4
50901: PUSH
50902: LD_VAR 0 7
50906: ARRAY
50907: PUSH
50908: LD_VAR 0 33
50912: IN
50913: IFFALSE 51175
// begin if IsInUnit ( group [ i ] ) then
50915: LD_VAR 0 4
50919: PUSH
50920: LD_VAR 0 7
50924: ARRAY
50925: PPUSH
50926: CALL_OW 310
50930: IFFALSE 50998
// begin z := IsInUnit ( group [ i ] ) ;
50932: LD_ADDR_VAR 0 13
50936: PUSH
50937: LD_VAR 0 4
50941: PUSH
50942: LD_VAR 0 7
50946: ARRAY
50947: PPUSH
50948: CALL_OW 310
50952: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
50953: LD_VAR 0 13
50957: PUSH
50958: LD_VAR 0 32
50962: IN
50963: PUSH
50964: LD_VAR 0 13
50968: PPUSH
50969: LD_VAR 0 22
50973: PPUSH
50974: CALL_OW 308
50978: AND
50979: IFFALSE 50996
// ComExitVehicle ( group [ i ] ) ;
50981: LD_VAR 0 4
50985: PUSH
50986: LD_VAR 0 7
50990: ARRAY
50991: PPUSH
50992: CALL_OW 121
// end else
50996: GO 51175
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
50998: LD_ADDR_VAR 0 13
51002: PUSH
51003: LD_VAR 0 4
51007: PPUSH
51008: LD_INT 95
51010: PUSH
51011: LD_VAR 0 22
51015: PUSH
51016: EMPTY
51017: LIST
51018: LIST
51019: PUSH
51020: LD_INT 58
51022: PUSH
51023: EMPTY
51024: LIST
51025: PUSH
51026: EMPTY
51027: LIST
51028: LIST
51029: PPUSH
51030: CALL_OW 72
51034: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
51035: LD_VAR 0 4
51039: PUSH
51040: LD_VAR 0 7
51044: ARRAY
51045: PPUSH
51046: CALL_OW 314
51050: NOT
51051: IFFALSE 51173
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
51053: LD_ADDR_VAR 0 10
51057: PUSH
51058: LD_VAR 0 13
51062: PPUSH
51063: LD_VAR 0 4
51067: PUSH
51068: LD_VAR 0 7
51072: ARRAY
51073: PPUSH
51074: CALL_OW 74
51078: ST_TO_ADDR
// if not x then
51079: LD_VAR 0 10
51083: NOT
51084: IFFALSE 51088
// continue ;
51086: GO 50520
// if GetLives ( x ) < 1000 then
51088: LD_VAR 0 10
51092: PPUSH
51093: CALL_OW 256
51097: PUSH
51098: LD_INT 1000
51100: LESS
51101: IFFALSE 51125
// ComRepairVehicle ( group [ i ] , x ) else
51103: LD_VAR 0 4
51107: PUSH
51108: LD_VAR 0 7
51112: ARRAY
51113: PPUSH
51114: LD_VAR 0 10
51118: PPUSH
51119: CALL_OW 129
51123: GO 51173
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
51125: LD_VAR 0 23
51129: PUSH
51130: LD_VAR 0 4
51134: PUSH
51135: LD_VAR 0 7
51139: ARRAY
51140: PPUSH
51141: CALL_OW 256
51145: PUSH
51146: LD_INT 1000
51148: LESS
51149: AND
51150: NOT
51151: IFFALSE 51173
// ComEnterUnit ( group [ i ] , x ) ;
51153: LD_VAR 0 4
51157: PUSH
51158: LD_VAR 0 7
51162: ARRAY
51163: PPUSH
51164: LD_VAR 0 10
51168: PPUSH
51169: CALL_OW 120
// end ; continue ;
51173: GO 50520
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
51175: LD_VAR 0 23
51179: PUSH
51180: LD_VAR 0 4
51184: PUSH
51185: LD_VAR 0 7
51189: ARRAY
51190: PPUSH
51191: CALL_OW 247
51195: PUSH
51196: LD_INT 1
51198: EQUAL
51199: AND
51200: IFFALSE 51678
// begin if group [ i ] in healers then
51202: LD_VAR 0 4
51206: PUSH
51207: LD_VAR 0 7
51211: ARRAY
51212: PUSH
51213: LD_VAR 0 31
51217: IN
51218: IFFALSE 51491
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
51220: LD_VAR 0 4
51224: PUSH
51225: LD_VAR 0 7
51229: ARRAY
51230: PPUSH
51231: LD_VAR 0 23
51235: PPUSH
51236: CALL_OW 308
51240: NOT
51241: PUSH
51242: LD_VAR 0 4
51246: PUSH
51247: LD_VAR 0 7
51251: ARRAY
51252: PPUSH
51253: CALL_OW 314
51257: NOT
51258: AND
51259: IFFALSE 51283
// ComMoveToArea ( group [ i ] , f_heal ) else
51261: LD_VAR 0 4
51265: PUSH
51266: LD_VAR 0 7
51270: ARRAY
51271: PPUSH
51272: LD_VAR 0 23
51276: PPUSH
51277: CALL_OW 113
51281: GO 51489
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
51283: LD_VAR 0 4
51287: PUSH
51288: LD_VAR 0 7
51292: ARRAY
51293: PPUSH
51294: CALL 49901 0 1
51298: PPUSH
51299: CALL_OW 256
51303: PUSH
51304: LD_INT 1000
51306: EQUAL
51307: IFFALSE 51326
// ComStop ( group [ i ] ) else
51309: LD_VAR 0 4
51313: PUSH
51314: LD_VAR 0 7
51318: ARRAY
51319: PPUSH
51320: CALL_OW 141
51324: GO 51489
// if not HasTask ( group [ i ] ) and to_heal then
51326: LD_VAR 0 4
51330: PUSH
51331: LD_VAR 0 7
51335: ARRAY
51336: PPUSH
51337: CALL_OW 314
51341: NOT
51342: PUSH
51343: LD_VAR 0 30
51347: AND
51348: IFFALSE 51489
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
51350: LD_ADDR_VAR 0 13
51354: PUSH
51355: LD_VAR 0 30
51359: PPUSH
51360: LD_INT 3
51362: PUSH
51363: LD_INT 54
51365: PUSH
51366: EMPTY
51367: LIST
51368: PUSH
51369: EMPTY
51370: LIST
51371: LIST
51372: PPUSH
51373: CALL_OW 72
51377: PPUSH
51378: LD_VAR 0 4
51382: PUSH
51383: LD_VAR 0 7
51387: ARRAY
51388: PPUSH
51389: CALL_OW 74
51393: ST_TO_ADDR
// if z then
51394: LD_VAR 0 13
51398: IFFALSE 51489
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
51400: LD_INT 91
51402: PUSH
51403: LD_VAR 0 13
51407: PUSH
51408: LD_INT 10
51410: PUSH
51411: EMPTY
51412: LIST
51413: LIST
51414: LIST
51415: PUSH
51416: LD_INT 81
51418: PUSH
51419: LD_VAR 0 13
51423: PPUSH
51424: CALL_OW 255
51428: PUSH
51429: EMPTY
51430: LIST
51431: LIST
51432: PUSH
51433: EMPTY
51434: LIST
51435: LIST
51436: PPUSH
51437: CALL_OW 69
51441: PUSH
51442: LD_INT 0
51444: EQUAL
51445: IFFALSE 51469
// ComHeal ( group [ i ] , z ) else
51447: LD_VAR 0 4
51451: PUSH
51452: LD_VAR 0 7
51456: ARRAY
51457: PPUSH
51458: LD_VAR 0 13
51462: PPUSH
51463: CALL_OW 128
51467: GO 51489
// ComMoveToArea ( group [ i ] , f_heal ) ;
51469: LD_VAR 0 4
51473: PUSH
51474: LD_VAR 0 7
51478: ARRAY
51479: PPUSH
51480: LD_VAR 0 23
51484: PPUSH
51485: CALL_OW 113
// end ; continue ;
51489: GO 50520
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
51491: LD_VAR 0 4
51495: PUSH
51496: LD_VAR 0 7
51500: ARRAY
51501: PPUSH
51502: CALL_OW 256
51506: PUSH
51507: LD_INT 700
51509: LESS
51510: PUSH
51511: LD_VAR 0 4
51515: PUSH
51516: LD_VAR 0 7
51520: ARRAY
51521: PUSH
51522: LD_VAR 0 30
51526: IN
51527: NOT
51528: AND
51529: IFFALSE 51553
// to_heal := to_heal union group [ i ] ;
51531: LD_ADDR_VAR 0 30
51535: PUSH
51536: LD_VAR 0 30
51540: PUSH
51541: LD_VAR 0 4
51545: PUSH
51546: LD_VAR 0 7
51550: ARRAY
51551: UNION
51552: ST_TO_ADDR
// if group [ i ] in to_heal then
51553: LD_VAR 0 4
51557: PUSH
51558: LD_VAR 0 7
51562: ARRAY
51563: PUSH
51564: LD_VAR 0 30
51568: IN
51569: IFFALSE 51678
// begin if GetLives ( group [ i ] ) = 1000 then
51571: LD_VAR 0 4
51575: PUSH
51576: LD_VAR 0 7
51580: ARRAY
51581: PPUSH
51582: CALL_OW 256
51586: PUSH
51587: LD_INT 1000
51589: EQUAL
51590: IFFALSE 51616
// to_heal := to_heal diff group [ i ] else
51592: LD_ADDR_VAR 0 30
51596: PUSH
51597: LD_VAR 0 30
51601: PUSH
51602: LD_VAR 0 4
51606: PUSH
51607: LD_VAR 0 7
51611: ARRAY
51612: DIFF
51613: ST_TO_ADDR
51614: GO 51678
// begin if not IsInArea ( group [ i ] , to_heal ) then
51616: LD_VAR 0 4
51620: PUSH
51621: LD_VAR 0 7
51625: ARRAY
51626: PPUSH
51627: LD_VAR 0 30
51631: PPUSH
51632: CALL_OW 308
51636: NOT
51637: IFFALSE 51661
// ComMoveToArea ( group [ i ] , f_heal ) else
51639: LD_VAR 0 4
51643: PUSH
51644: LD_VAR 0 7
51648: ARRAY
51649: PPUSH
51650: LD_VAR 0 23
51654: PPUSH
51655: CALL_OW 113
51659: GO 51676
// ComHold ( group [ i ] ) ;
51661: LD_VAR 0 4
51665: PUSH
51666: LD_VAR 0 7
51670: ARRAY
51671: PPUSH
51672: CALL_OW 140
// continue ;
51676: GO 50520
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
51678: LD_VAR 0 4
51682: PUSH
51683: LD_VAR 0 7
51687: ARRAY
51688: PPUSH
51689: LD_INT 10
51691: PPUSH
51692: CALL 48321 0 2
51696: NOT
51697: PUSH
51698: LD_VAR 0 16
51702: PUSH
51703: LD_VAR 0 7
51707: ARRAY
51708: PUSH
51709: EMPTY
51710: EQUAL
51711: NOT
51712: AND
51713: IFFALSE 51979
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
51715: LD_VAR 0 4
51719: PUSH
51720: LD_VAR 0 7
51724: ARRAY
51725: PPUSH
51726: CALL_OW 262
51730: PUSH
51731: LD_INT 1
51733: PUSH
51734: LD_INT 2
51736: PUSH
51737: EMPTY
51738: LIST
51739: LIST
51740: IN
51741: IFFALSE 51782
// if GetFuel ( group [ i ] ) < 10 then
51743: LD_VAR 0 4
51747: PUSH
51748: LD_VAR 0 7
51752: ARRAY
51753: PPUSH
51754: CALL_OW 261
51758: PUSH
51759: LD_INT 10
51761: LESS
51762: IFFALSE 51782
// SetFuel ( group [ i ] , 12 ) ;
51764: LD_VAR 0 4
51768: PUSH
51769: LD_VAR 0 7
51773: ARRAY
51774: PPUSH
51775: LD_INT 12
51777: PPUSH
51778: CALL_OW 240
// if units_path [ i ] then
51782: LD_VAR 0 16
51786: PUSH
51787: LD_VAR 0 7
51791: ARRAY
51792: IFFALSE 51977
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
51794: LD_VAR 0 4
51798: PUSH
51799: LD_VAR 0 7
51803: ARRAY
51804: PPUSH
51805: LD_VAR 0 16
51809: PUSH
51810: LD_VAR 0 7
51814: ARRAY
51815: PUSH
51816: LD_INT 1
51818: ARRAY
51819: PUSH
51820: LD_INT 1
51822: ARRAY
51823: PPUSH
51824: LD_VAR 0 16
51828: PUSH
51829: LD_VAR 0 7
51833: ARRAY
51834: PUSH
51835: LD_INT 1
51837: ARRAY
51838: PUSH
51839: LD_INT 2
51841: ARRAY
51842: PPUSH
51843: CALL_OW 297
51847: PUSH
51848: LD_INT 6
51850: GREATER
51851: IFFALSE 51926
// begin if not HasTask ( group [ i ] ) then
51853: LD_VAR 0 4
51857: PUSH
51858: LD_VAR 0 7
51862: ARRAY
51863: PPUSH
51864: CALL_OW 314
51868: NOT
51869: IFFALSE 51924
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
51871: LD_VAR 0 4
51875: PUSH
51876: LD_VAR 0 7
51880: ARRAY
51881: PPUSH
51882: LD_VAR 0 16
51886: PUSH
51887: LD_VAR 0 7
51891: ARRAY
51892: PUSH
51893: LD_INT 1
51895: ARRAY
51896: PUSH
51897: LD_INT 1
51899: ARRAY
51900: PPUSH
51901: LD_VAR 0 16
51905: PUSH
51906: LD_VAR 0 7
51910: ARRAY
51911: PUSH
51912: LD_INT 1
51914: ARRAY
51915: PUSH
51916: LD_INT 2
51918: ARRAY
51919: PPUSH
51920: CALL_OW 114
// end else
51924: GO 51977
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
51926: LD_ADDR_VAR 0 15
51930: PUSH
51931: LD_VAR 0 16
51935: PUSH
51936: LD_VAR 0 7
51940: ARRAY
51941: PPUSH
51942: LD_INT 1
51944: PPUSH
51945: CALL_OW 3
51949: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
51950: LD_ADDR_VAR 0 16
51954: PUSH
51955: LD_VAR 0 16
51959: PPUSH
51960: LD_VAR 0 7
51964: PPUSH
51965: LD_VAR 0 15
51969: PPUSH
51970: CALL_OW 1
51974: ST_TO_ADDR
// continue ;
51975: GO 50520
// end ; end ; end else
51977: GO 54641
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
51979: LD_ADDR_VAR 0 14
51983: PUSH
51984: LD_INT 81
51986: PUSH
51987: LD_VAR 0 4
51991: PUSH
51992: LD_VAR 0 7
51996: ARRAY
51997: PPUSH
51998: CALL_OW 255
52002: PUSH
52003: EMPTY
52004: LIST
52005: LIST
52006: PPUSH
52007: CALL_OW 69
52011: ST_TO_ADDR
// if not tmp then
52012: LD_VAR 0 14
52016: NOT
52017: IFFALSE 52021
// continue ;
52019: GO 50520
// if f_ignore_area then
52021: LD_VAR 0 17
52025: IFFALSE 52113
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
52027: LD_ADDR_VAR 0 15
52031: PUSH
52032: LD_VAR 0 14
52036: PPUSH
52037: LD_INT 3
52039: PUSH
52040: LD_INT 92
52042: PUSH
52043: LD_VAR 0 17
52047: PUSH
52048: LD_INT 1
52050: ARRAY
52051: PUSH
52052: LD_VAR 0 17
52056: PUSH
52057: LD_INT 2
52059: ARRAY
52060: PUSH
52061: LD_VAR 0 17
52065: PUSH
52066: LD_INT 3
52068: ARRAY
52069: PUSH
52070: EMPTY
52071: LIST
52072: LIST
52073: LIST
52074: LIST
52075: PUSH
52076: EMPTY
52077: LIST
52078: LIST
52079: PPUSH
52080: CALL_OW 72
52084: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
52085: LD_VAR 0 14
52089: PUSH
52090: LD_VAR 0 15
52094: DIFF
52095: IFFALSE 52113
// tmp := tmp diff tmp2 ;
52097: LD_ADDR_VAR 0 14
52101: PUSH
52102: LD_VAR 0 14
52106: PUSH
52107: LD_VAR 0 15
52111: DIFF
52112: ST_TO_ADDR
// end ; if not f_murder then
52113: LD_VAR 0 20
52117: NOT
52118: IFFALSE 52176
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
52120: LD_ADDR_VAR 0 15
52124: PUSH
52125: LD_VAR 0 14
52129: PPUSH
52130: LD_INT 3
52132: PUSH
52133: LD_INT 50
52135: PUSH
52136: EMPTY
52137: LIST
52138: PUSH
52139: EMPTY
52140: LIST
52141: LIST
52142: PPUSH
52143: CALL_OW 72
52147: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
52148: LD_VAR 0 14
52152: PUSH
52153: LD_VAR 0 15
52157: DIFF
52158: IFFALSE 52176
// tmp := tmp diff tmp2 ;
52160: LD_ADDR_VAR 0 14
52164: PUSH
52165: LD_VAR 0 14
52169: PUSH
52170: LD_VAR 0 15
52174: DIFF
52175: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
52176: LD_ADDR_VAR 0 14
52180: PUSH
52181: LD_VAR 0 4
52185: PUSH
52186: LD_VAR 0 7
52190: ARRAY
52191: PPUSH
52192: LD_VAR 0 14
52196: PPUSH
52197: LD_INT 1
52199: PPUSH
52200: LD_INT 1
52202: PPUSH
52203: CALL 21964 0 4
52207: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
52208: LD_VAR 0 4
52212: PUSH
52213: LD_VAR 0 7
52217: ARRAY
52218: PPUSH
52219: CALL_OW 257
52223: PUSH
52224: LD_INT 1
52226: EQUAL
52227: IFFALSE 52675
// begin if WantPlant ( group [ i ] ) then
52229: LD_VAR 0 4
52233: PUSH
52234: LD_VAR 0 7
52238: ARRAY
52239: PPUSH
52240: CALL 21465 0 1
52244: IFFALSE 52248
// continue ;
52246: GO 50520
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
52248: LD_VAR 0 18
52252: PUSH
52253: LD_VAR 0 4
52257: PUSH
52258: LD_VAR 0 7
52262: ARRAY
52263: PPUSH
52264: CALL_OW 310
52268: NOT
52269: AND
52270: PUSH
52271: LD_VAR 0 14
52275: PUSH
52276: LD_INT 1
52278: ARRAY
52279: PUSH
52280: LD_VAR 0 14
52284: PPUSH
52285: LD_INT 21
52287: PUSH
52288: LD_INT 2
52290: PUSH
52291: EMPTY
52292: LIST
52293: LIST
52294: PUSH
52295: LD_INT 58
52297: PUSH
52298: EMPTY
52299: LIST
52300: PUSH
52301: EMPTY
52302: LIST
52303: LIST
52304: PPUSH
52305: CALL_OW 72
52309: IN
52310: AND
52311: IFFALSE 52347
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
52313: LD_VAR 0 4
52317: PUSH
52318: LD_VAR 0 7
52322: ARRAY
52323: PPUSH
52324: LD_VAR 0 14
52328: PUSH
52329: LD_INT 1
52331: ARRAY
52332: PPUSH
52333: CALL_OW 120
// attacking := true ;
52337: LD_ADDR_VAR 0 29
52341: PUSH
52342: LD_INT 1
52344: ST_TO_ADDR
// continue ;
52345: GO 50520
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
52347: LD_VAR 0 26
52351: PUSH
52352: LD_VAR 0 4
52356: PUSH
52357: LD_VAR 0 7
52361: ARRAY
52362: PPUSH
52363: CALL_OW 257
52367: PUSH
52368: LD_INT 1
52370: EQUAL
52371: AND
52372: PUSH
52373: LD_VAR 0 4
52377: PUSH
52378: LD_VAR 0 7
52382: ARRAY
52383: PPUSH
52384: CALL_OW 256
52388: PUSH
52389: LD_INT 800
52391: LESS
52392: AND
52393: PUSH
52394: LD_VAR 0 4
52398: PUSH
52399: LD_VAR 0 7
52403: ARRAY
52404: PPUSH
52405: CALL_OW 318
52409: NOT
52410: AND
52411: IFFALSE 52428
// ComCrawl ( group [ i ] ) ;
52413: LD_VAR 0 4
52417: PUSH
52418: LD_VAR 0 7
52422: ARRAY
52423: PPUSH
52424: CALL_OW 137
// if f_mines then
52428: LD_VAR 0 21
52432: IFFALSE 52675
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
52434: LD_VAR 0 14
52438: PUSH
52439: LD_INT 1
52441: ARRAY
52442: PPUSH
52443: CALL_OW 247
52447: PUSH
52448: LD_INT 3
52450: EQUAL
52451: PUSH
52452: LD_VAR 0 14
52456: PUSH
52457: LD_INT 1
52459: ARRAY
52460: PUSH
52461: LD_VAR 0 27
52465: IN
52466: NOT
52467: AND
52468: IFFALSE 52675
// begin x := GetX ( tmp [ 1 ] ) ;
52470: LD_ADDR_VAR 0 10
52474: PUSH
52475: LD_VAR 0 14
52479: PUSH
52480: LD_INT 1
52482: ARRAY
52483: PPUSH
52484: CALL_OW 250
52488: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
52489: LD_ADDR_VAR 0 11
52493: PUSH
52494: LD_VAR 0 14
52498: PUSH
52499: LD_INT 1
52501: ARRAY
52502: PPUSH
52503: CALL_OW 251
52507: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
52508: LD_ADDR_VAR 0 12
52512: PUSH
52513: LD_VAR 0 4
52517: PUSH
52518: LD_VAR 0 7
52522: ARRAY
52523: PPUSH
52524: CALL 48406 0 1
52528: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
52529: LD_VAR 0 4
52533: PUSH
52534: LD_VAR 0 7
52538: ARRAY
52539: PPUSH
52540: LD_VAR 0 10
52544: PPUSH
52545: LD_VAR 0 11
52549: PPUSH
52550: LD_VAR 0 14
52554: PUSH
52555: LD_INT 1
52557: ARRAY
52558: PPUSH
52559: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
52563: LD_VAR 0 4
52567: PUSH
52568: LD_VAR 0 7
52572: ARRAY
52573: PPUSH
52574: LD_VAR 0 10
52578: PPUSH
52579: LD_VAR 0 12
52583: PPUSH
52584: LD_INT 7
52586: PPUSH
52587: CALL_OW 272
52591: PPUSH
52592: LD_VAR 0 11
52596: PPUSH
52597: LD_VAR 0 12
52601: PPUSH
52602: LD_INT 7
52604: PPUSH
52605: CALL_OW 273
52609: PPUSH
52610: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
52614: LD_VAR 0 4
52618: PUSH
52619: LD_VAR 0 7
52623: ARRAY
52624: PPUSH
52625: LD_INT 71
52627: PPUSH
52628: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
52632: LD_ADDR_VAR 0 27
52636: PUSH
52637: LD_VAR 0 27
52641: PPUSH
52642: LD_VAR 0 27
52646: PUSH
52647: LD_INT 1
52649: PLUS
52650: PPUSH
52651: LD_VAR 0 14
52655: PUSH
52656: LD_INT 1
52658: ARRAY
52659: PPUSH
52660: CALL_OW 1
52664: ST_TO_ADDR
// attacking := true ;
52665: LD_ADDR_VAR 0 29
52669: PUSH
52670: LD_INT 1
52672: ST_TO_ADDR
// continue ;
52673: GO 50520
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
52675: LD_VAR 0 4
52679: PUSH
52680: LD_VAR 0 7
52684: ARRAY
52685: PPUSH
52686: CALL_OW 257
52690: PUSH
52691: LD_INT 17
52693: EQUAL
52694: PUSH
52695: LD_VAR 0 4
52699: PUSH
52700: LD_VAR 0 7
52704: ARRAY
52705: PPUSH
52706: CALL_OW 110
52710: PUSH
52711: LD_INT 71
52713: EQUAL
52714: NOT
52715: AND
52716: IFFALSE 52862
// begin attacking := false ;
52718: LD_ADDR_VAR 0 29
52722: PUSH
52723: LD_INT 0
52725: ST_TO_ADDR
// k := 5 ;
52726: LD_ADDR_VAR 0 9
52730: PUSH
52731: LD_INT 5
52733: ST_TO_ADDR
// if tmp < k then
52734: LD_VAR 0 14
52738: PUSH
52739: LD_VAR 0 9
52743: LESS
52744: IFFALSE 52756
// k := tmp ;
52746: LD_ADDR_VAR 0 9
52750: PUSH
52751: LD_VAR 0 14
52755: ST_TO_ADDR
// for j = 1 to k do
52756: LD_ADDR_VAR 0 8
52760: PUSH
52761: DOUBLE
52762: LD_INT 1
52764: DEC
52765: ST_TO_ADDR
52766: LD_VAR 0 9
52770: PUSH
52771: FOR_TO
52772: IFFALSE 52860
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
52774: LD_VAR 0 14
52778: PUSH
52779: LD_VAR 0 8
52783: ARRAY
52784: PUSH
52785: LD_VAR 0 14
52789: PPUSH
52790: LD_INT 58
52792: PUSH
52793: EMPTY
52794: LIST
52795: PPUSH
52796: CALL_OW 72
52800: IN
52801: NOT
52802: IFFALSE 52858
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52804: LD_VAR 0 4
52808: PUSH
52809: LD_VAR 0 7
52813: ARRAY
52814: PPUSH
52815: LD_VAR 0 14
52819: PUSH
52820: LD_VAR 0 8
52824: ARRAY
52825: PPUSH
52826: CALL_OW 115
// attacking := true ;
52830: LD_ADDR_VAR 0 29
52834: PUSH
52835: LD_INT 1
52837: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
52838: LD_VAR 0 4
52842: PUSH
52843: LD_VAR 0 7
52847: ARRAY
52848: PPUSH
52849: LD_INT 71
52851: PPUSH
52852: CALL_OW 109
// continue ;
52856: GO 52771
// end ; end ;
52858: GO 52771
52860: POP
52861: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
52862: LD_VAR 0 4
52866: PUSH
52867: LD_VAR 0 7
52871: ARRAY
52872: PPUSH
52873: CALL_OW 257
52877: PUSH
52878: LD_INT 8
52880: EQUAL
52881: PUSH
52882: LD_VAR 0 4
52886: PUSH
52887: LD_VAR 0 7
52891: ARRAY
52892: PPUSH
52893: CALL_OW 264
52897: PUSH
52898: LD_INT 28
52900: PUSH
52901: LD_INT 45
52903: PUSH
52904: LD_INT 7
52906: PUSH
52907: LD_INT 47
52909: PUSH
52910: EMPTY
52911: LIST
52912: LIST
52913: LIST
52914: LIST
52915: IN
52916: OR
52917: IFFALSE 53173
// begin attacking := false ;
52919: LD_ADDR_VAR 0 29
52923: PUSH
52924: LD_INT 0
52926: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
52927: LD_VAR 0 14
52931: PUSH
52932: LD_INT 1
52934: ARRAY
52935: PPUSH
52936: CALL_OW 266
52940: PUSH
52941: LD_INT 32
52943: PUSH
52944: LD_INT 31
52946: PUSH
52947: LD_INT 33
52949: PUSH
52950: LD_INT 4
52952: PUSH
52953: LD_INT 5
52955: PUSH
52956: EMPTY
52957: LIST
52958: LIST
52959: LIST
52960: LIST
52961: LIST
52962: IN
52963: IFFALSE 53149
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
52965: LD_ADDR_VAR 0 9
52969: PUSH
52970: LD_VAR 0 14
52974: PUSH
52975: LD_INT 1
52977: ARRAY
52978: PPUSH
52979: CALL_OW 266
52983: PPUSH
52984: LD_VAR 0 14
52988: PUSH
52989: LD_INT 1
52991: ARRAY
52992: PPUSH
52993: CALL_OW 250
52997: PPUSH
52998: LD_VAR 0 14
53002: PUSH
53003: LD_INT 1
53005: ARRAY
53006: PPUSH
53007: CALL_OW 251
53011: PPUSH
53012: LD_VAR 0 14
53016: PUSH
53017: LD_INT 1
53019: ARRAY
53020: PPUSH
53021: CALL_OW 254
53025: PPUSH
53026: LD_VAR 0 14
53030: PUSH
53031: LD_INT 1
53033: ARRAY
53034: PPUSH
53035: CALL_OW 248
53039: PPUSH
53040: LD_INT 0
53042: PPUSH
53043: CALL 29776 0 6
53047: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
53048: LD_ADDR_VAR 0 8
53052: PUSH
53053: LD_VAR 0 4
53057: PUSH
53058: LD_VAR 0 7
53062: ARRAY
53063: PPUSH
53064: LD_VAR 0 9
53068: PPUSH
53069: CALL 48446 0 2
53073: ST_TO_ADDR
// if j then
53074: LD_VAR 0 8
53078: IFFALSE 53147
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
53080: LD_VAR 0 8
53084: PUSH
53085: LD_INT 1
53087: ARRAY
53088: PPUSH
53089: LD_VAR 0 8
53093: PUSH
53094: LD_INT 2
53096: ARRAY
53097: PPUSH
53098: CALL_OW 488
53102: IFFALSE 53147
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
53104: LD_VAR 0 4
53108: PUSH
53109: LD_VAR 0 7
53113: ARRAY
53114: PPUSH
53115: LD_VAR 0 8
53119: PUSH
53120: LD_INT 1
53122: ARRAY
53123: PPUSH
53124: LD_VAR 0 8
53128: PUSH
53129: LD_INT 2
53131: ARRAY
53132: PPUSH
53133: CALL_OW 116
// attacking := true ;
53137: LD_ADDR_VAR 0 29
53141: PUSH
53142: LD_INT 1
53144: ST_TO_ADDR
// continue ;
53145: GO 50520
// end ; end else
53147: GO 53173
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53149: LD_VAR 0 4
53153: PUSH
53154: LD_VAR 0 7
53158: ARRAY
53159: PPUSH
53160: LD_VAR 0 14
53164: PUSH
53165: LD_INT 1
53167: ARRAY
53168: PPUSH
53169: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
53173: LD_VAR 0 4
53177: PUSH
53178: LD_VAR 0 7
53182: ARRAY
53183: PPUSH
53184: CALL_OW 265
53188: PUSH
53189: LD_INT 11
53191: EQUAL
53192: IFFALSE 53470
// begin k := 10 ;
53194: LD_ADDR_VAR 0 9
53198: PUSH
53199: LD_INT 10
53201: ST_TO_ADDR
// x := 0 ;
53202: LD_ADDR_VAR 0 10
53206: PUSH
53207: LD_INT 0
53209: ST_TO_ADDR
// if tmp < k then
53210: LD_VAR 0 14
53214: PUSH
53215: LD_VAR 0 9
53219: LESS
53220: IFFALSE 53232
// k := tmp ;
53222: LD_ADDR_VAR 0 9
53226: PUSH
53227: LD_VAR 0 14
53231: ST_TO_ADDR
// for j = k downto 1 do
53232: LD_ADDR_VAR 0 8
53236: PUSH
53237: DOUBLE
53238: LD_VAR 0 9
53242: INC
53243: ST_TO_ADDR
53244: LD_INT 1
53246: PUSH
53247: FOR_DOWNTO
53248: IFFALSE 53323
// begin if GetType ( tmp [ j ] ) = unit_human then
53250: LD_VAR 0 14
53254: PUSH
53255: LD_VAR 0 8
53259: ARRAY
53260: PPUSH
53261: CALL_OW 247
53265: PUSH
53266: LD_INT 1
53268: EQUAL
53269: IFFALSE 53321
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
53271: LD_VAR 0 4
53275: PUSH
53276: LD_VAR 0 7
53280: ARRAY
53281: PPUSH
53282: LD_VAR 0 14
53286: PUSH
53287: LD_VAR 0 8
53291: ARRAY
53292: PPUSH
53293: CALL 48717 0 2
// x := tmp [ j ] ;
53297: LD_ADDR_VAR 0 10
53301: PUSH
53302: LD_VAR 0 14
53306: PUSH
53307: LD_VAR 0 8
53311: ARRAY
53312: ST_TO_ADDR
// attacking := true ;
53313: LD_ADDR_VAR 0 29
53317: PUSH
53318: LD_INT 1
53320: ST_TO_ADDR
// end ; end ;
53321: GO 53247
53323: POP
53324: POP
// if not x then
53325: LD_VAR 0 10
53329: NOT
53330: IFFALSE 53470
// begin attacking := true ;
53332: LD_ADDR_VAR 0 29
53336: PUSH
53337: LD_INT 1
53339: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
53340: LD_VAR 0 4
53344: PUSH
53345: LD_VAR 0 7
53349: ARRAY
53350: PPUSH
53351: CALL_OW 250
53355: PPUSH
53356: LD_VAR 0 4
53360: PUSH
53361: LD_VAR 0 7
53365: ARRAY
53366: PPUSH
53367: CALL_OW 251
53371: PPUSH
53372: CALL_OW 546
53376: PUSH
53377: LD_INT 2
53379: ARRAY
53380: PUSH
53381: LD_VAR 0 14
53385: PUSH
53386: LD_INT 1
53388: ARRAY
53389: PPUSH
53390: CALL_OW 250
53394: PPUSH
53395: LD_VAR 0 14
53399: PUSH
53400: LD_INT 1
53402: ARRAY
53403: PPUSH
53404: CALL_OW 251
53408: PPUSH
53409: CALL_OW 546
53413: PUSH
53414: LD_INT 2
53416: ARRAY
53417: EQUAL
53418: IFFALSE 53446
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
53420: LD_VAR 0 4
53424: PUSH
53425: LD_VAR 0 7
53429: ARRAY
53430: PPUSH
53431: LD_VAR 0 14
53435: PUSH
53436: LD_INT 1
53438: ARRAY
53439: PPUSH
53440: CALL 48717 0 2
53444: GO 53470
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53446: LD_VAR 0 4
53450: PUSH
53451: LD_VAR 0 7
53455: ARRAY
53456: PPUSH
53457: LD_VAR 0 14
53461: PUSH
53462: LD_INT 1
53464: ARRAY
53465: PPUSH
53466: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
53470: LD_VAR 0 4
53474: PUSH
53475: LD_VAR 0 7
53479: ARRAY
53480: PPUSH
53481: CALL_OW 264
53485: PUSH
53486: LD_INT 29
53488: EQUAL
53489: IFFALSE 53855
// begin if WantsToAttack ( group [ i ] ) in bombed then
53491: LD_VAR 0 4
53495: PUSH
53496: LD_VAR 0 7
53500: ARRAY
53501: PPUSH
53502: CALL_OW 319
53506: PUSH
53507: LD_VAR 0 28
53511: IN
53512: IFFALSE 53516
// continue ;
53514: GO 50520
// k := 8 ;
53516: LD_ADDR_VAR 0 9
53520: PUSH
53521: LD_INT 8
53523: ST_TO_ADDR
// x := 0 ;
53524: LD_ADDR_VAR 0 10
53528: PUSH
53529: LD_INT 0
53531: ST_TO_ADDR
// if tmp < k then
53532: LD_VAR 0 14
53536: PUSH
53537: LD_VAR 0 9
53541: LESS
53542: IFFALSE 53554
// k := tmp ;
53544: LD_ADDR_VAR 0 9
53548: PUSH
53549: LD_VAR 0 14
53553: ST_TO_ADDR
// for j = 1 to k do
53554: LD_ADDR_VAR 0 8
53558: PUSH
53559: DOUBLE
53560: LD_INT 1
53562: DEC
53563: ST_TO_ADDR
53564: LD_VAR 0 9
53568: PUSH
53569: FOR_TO
53570: IFFALSE 53702
// begin if GetType ( tmp [ j ] ) = unit_building then
53572: LD_VAR 0 14
53576: PUSH
53577: LD_VAR 0 8
53581: ARRAY
53582: PPUSH
53583: CALL_OW 247
53587: PUSH
53588: LD_INT 3
53590: EQUAL
53591: IFFALSE 53700
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
53593: LD_VAR 0 14
53597: PUSH
53598: LD_VAR 0 8
53602: ARRAY
53603: PUSH
53604: LD_VAR 0 28
53608: IN
53609: NOT
53610: PUSH
53611: LD_VAR 0 14
53615: PUSH
53616: LD_VAR 0 8
53620: ARRAY
53621: PPUSH
53622: CALL_OW 313
53626: AND
53627: IFFALSE 53700
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53629: LD_VAR 0 4
53633: PUSH
53634: LD_VAR 0 7
53638: ARRAY
53639: PPUSH
53640: LD_VAR 0 14
53644: PUSH
53645: LD_VAR 0 8
53649: ARRAY
53650: PPUSH
53651: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
53655: LD_ADDR_VAR 0 28
53659: PUSH
53660: LD_VAR 0 28
53664: PPUSH
53665: LD_VAR 0 28
53669: PUSH
53670: LD_INT 1
53672: PLUS
53673: PPUSH
53674: LD_VAR 0 14
53678: PUSH
53679: LD_VAR 0 8
53683: ARRAY
53684: PPUSH
53685: CALL_OW 1
53689: ST_TO_ADDR
// attacking := true ;
53690: LD_ADDR_VAR 0 29
53694: PUSH
53695: LD_INT 1
53697: ST_TO_ADDR
// break ;
53698: GO 53702
// end ; end ;
53700: GO 53569
53702: POP
53703: POP
// if not attacking and f_attack_depot then
53704: LD_VAR 0 29
53708: NOT
53709: PUSH
53710: LD_VAR 0 25
53714: AND
53715: IFFALSE 53810
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53717: LD_ADDR_VAR 0 13
53721: PUSH
53722: LD_VAR 0 14
53726: PPUSH
53727: LD_INT 2
53729: PUSH
53730: LD_INT 30
53732: PUSH
53733: LD_INT 0
53735: PUSH
53736: EMPTY
53737: LIST
53738: LIST
53739: PUSH
53740: LD_INT 30
53742: PUSH
53743: LD_INT 1
53745: PUSH
53746: EMPTY
53747: LIST
53748: LIST
53749: PUSH
53750: EMPTY
53751: LIST
53752: LIST
53753: LIST
53754: PPUSH
53755: CALL_OW 72
53759: ST_TO_ADDR
// if z then
53760: LD_VAR 0 13
53764: IFFALSE 53810
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
53766: LD_VAR 0 4
53770: PUSH
53771: LD_VAR 0 7
53775: ARRAY
53776: PPUSH
53777: LD_VAR 0 13
53781: PPUSH
53782: LD_VAR 0 4
53786: PUSH
53787: LD_VAR 0 7
53791: ARRAY
53792: PPUSH
53793: CALL_OW 74
53797: PPUSH
53798: CALL_OW 115
// attacking := true ;
53802: LD_ADDR_VAR 0 29
53806: PUSH
53807: LD_INT 1
53809: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
53810: LD_VAR 0 4
53814: PUSH
53815: LD_VAR 0 7
53819: ARRAY
53820: PPUSH
53821: CALL_OW 256
53825: PUSH
53826: LD_INT 500
53828: LESS
53829: IFFALSE 53855
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53831: LD_VAR 0 4
53835: PUSH
53836: LD_VAR 0 7
53840: ARRAY
53841: PPUSH
53842: LD_VAR 0 14
53846: PUSH
53847: LD_INT 1
53849: ARRAY
53850: PPUSH
53851: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
53855: LD_VAR 0 4
53859: PUSH
53860: LD_VAR 0 7
53864: ARRAY
53865: PPUSH
53866: CALL_OW 264
53870: PUSH
53871: LD_INT 49
53873: EQUAL
53874: IFFALSE 53995
// begin if not HasTask ( group [ i ] ) then
53876: LD_VAR 0 4
53880: PUSH
53881: LD_VAR 0 7
53885: ARRAY
53886: PPUSH
53887: CALL_OW 314
53891: NOT
53892: IFFALSE 53995
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
53894: LD_ADDR_VAR 0 9
53898: PUSH
53899: LD_INT 81
53901: PUSH
53902: LD_VAR 0 4
53906: PUSH
53907: LD_VAR 0 7
53911: ARRAY
53912: PPUSH
53913: CALL_OW 255
53917: PUSH
53918: EMPTY
53919: LIST
53920: LIST
53921: PPUSH
53922: CALL_OW 69
53926: PPUSH
53927: LD_VAR 0 4
53931: PUSH
53932: LD_VAR 0 7
53936: ARRAY
53937: PPUSH
53938: CALL_OW 74
53942: ST_TO_ADDR
// if k then
53943: LD_VAR 0 9
53947: IFFALSE 53995
// if GetDistUnits ( group [ i ] , k ) > 10 then
53949: LD_VAR 0 4
53953: PUSH
53954: LD_VAR 0 7
53958: ARRAY
53959: PPUSH
53960: LD_VAR 0 9
53964: PPUSH
53965: CALL_OW 296
53969: PUSH
53970: LD_INT 10
53972: GREATER
53973: IFFALSE 53995
// ComMoveUnit ( group [ i ] , k ) ;
53975: LD_VAR 0 4
53979: PUSH
53980: LD_VAR 0 7
53984: ARRAY
53985: PPUSH
53986: LD_VAR 0 9
53990: PPUSH
53991: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53995: LD_VAR 0 4
53999: PUSH
54000: LD_VAR 0 7
54004: ARRAY
54005: PPUSH
54006: CALL_OW 256
54010: PUSH
54011: LD_INT 250
54013: LESS
54014: PUSH
54015: LD_VAR 0 4
54019: PUSH
54020: LD_VAR 0 7
54024: ARRAY
54025: PUSH
54026: LD_INT 21
54028: PUSH
54029: LD_INT 2
54031: PUSH
54032: EMPTY
54033: LIST
54034: LIST
54035: PUSH
54036: LD_INT 23
54038: PUSH
54039: LD_INT 2
54041: PUSH
54042: EMPTY
54043: LIST
54044: LIST
54045: PUSH
54046: EMPTY
54047: LIST
54048: LIST
54049: PPUSH
54050: CALL_OW 69
54054: IN
54055: AND
54056: IFFALSE 54181
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
54058: LD_ADDR_VAR 0 9
54062: PUSH
54063: LD_OWVAR 3
54067: PUSH
54068: LD_VAR 0 4
54072: PUSH
54073: LD_VAR 0 7
54077: ARRAY
54078: DIFF
54079: PPUSH
54080: LD_VAR 0 4
54084: PUSH
54085: LD_VAR 0 7
54089: ARRAY
54090: PPUSH
54091: CALL_OW 74
54095: ST_TO_ADDR
// if not k then
54096: LD_VAR 0 9
54100: NOT
54101: IFFALSE 54105
// continue ;
54103: GO 50520
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
54105: LD_VAR 0 9
54109: PUSH
54110: LD_INT 81
54112: PUSH
54113: LD_VAR 0 4
54117: PUSH
54118: LD_VAR 0 7
54122: ARRAY
54123: PPUSH
54124: CALL_OW 255
54128: PUSH
54129: EMPTY
54130: LIST
54131: LIST
54132: PPUSH
54133: CALL_OW 69
54137: IN
54138: PUSH
54139: LD_VAR 0 9
54143: PPUSH
54144: LD_VAR 0 4
54148: PUSH
54149: LD_VAR 0 7
54153: ARRAY
54154: PPUSH
54155: CALL_OW 296
54159: PUSH
54160: LD_INT 5
54162: LESS
54163: AND
54164: IFFALSE 54181
// ComAutodestruct ( group [ i ] ) ;
54166: LD_VAR 0 4
54170: PUSH
54171: LD_VAR 0 7
54175: ARRAY
54176: PPUSH
54177: CALL 48615 0 1
// end ; if f_attack_depot then
54181: LD_VAR 0 25
54185: IFFALSE 54297
// begin k := 6 ;
54187: LD_ADDR_VAR 0 9
54191: PUSH
54192: LD_INT 6
54194: ST_TO_ADDR
// if tmp < k then
54195: LD_VAR 0 14
54199: PUSH
54200: LD_VAR 0 9
54204: LESS
54205: IFFALSE 54217
// k := tmp ;
54207: LD_ADDR_VAR 0 9
54211: PUSH
54212: LD_VAR 0 14
54216: ST_TO_ADDR
// for j = 1 to k do
54217: LD_ADDR_VAR 0 8
54221: PUSH
54222: DOUBLE
54223: LD_INT 1
54225: DEC
54226: ST_TO_ADDR
54227: LD_VAR 0 9
54231: PUSH
54232: FOR_TO
54233: IFFALSE 54295
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
54235: LD_VAR 0 8
54239: PPUSH
54240: CALL_OW 266
54244: PUSH
54245: LD_INT 0
54247: PUSH
54248: LD_INT 1
54250: PUSH
54251: EMPTY
54252: LIST
54253: LIST
54254: IN
54255: IFFALSE 54293
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
54257: LD_VAR 0 4
54261: PUSH
54262: LD_VAR 0 7
54266: ARRAY
54267: PPUSH
54268: LD_VAR 0 14
54272: PUSH
54273: LD_VAR 0 8
54277: ARRAY
54278: PPUSH
54279: CALL_OW 115
// attacking := true ;
54283: LD_ADDR_VAR 0 29
54287: PUSH
54288: LD_INT 1
54290: ST_TO_ADDR
// break ;
54291: GO 54295
// end ;
54293: GO 54232
54295: POP
54296: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
54297: LD_VAR 0 4
54301: PUSH
54302: LD_VAR 0 7
54306: ARRAY
54307: PPUSH
54308: CALL_OW 302
54312: PUSH
54313: LD_VAR 0 29
54317: NOT
54318: AND
54319: IFFALSE 54641
// begin if GetTag ( group [ i ] ) = 71 then
54321: LD_VAR 0 4
54325: PUSH
54326: LD_VAR 0 7
54330: ARRAY
54331: PPUSH
54332: CALL_OW 110
54336: PUSH
54337: LD_INT 71
54339: EQUAL
54340: IFFALSE 54381
// begin if HasTask ( group [ i ] ) then
54342: LD_VAR 0 4
54346: PUSH
54347: LD_VAR 0 7
54351: ARRAY
54352: PPUSH
54353: CALL_OW 314
54357: IFFALSE 54363
// continue else
54359: GO 50520
54361: GO 54381
// SetTag ( group [ i ] , 0 ) ;
54363: LD_VAR 0 4
54367: PUSH
54368: LD_VAR 0 7
54372: ARRAY
54373: PPUSH
54374: LD_INT 0
54376: PPUSH
54377: CALL_OW 109
// end ; k := 8 ;
54381: LD_ADDR_VAR 0 9
54385: PUSH
54386: LD_INT 8
54388: ST_TO_ADDR
// x := 0 ;
54389: LD_ADDR_VAR 0 10
54393: PUSH
54394: LD_INT 0
54396: ST_TO_ADDR
// if tmp < k then
54397: LD_VAR 0 14
54401: PUSH
54402: LD_VAR 0 9
54406: LESS
54407: IFFALSE 54419
// k := tmp ;
54409: LD_ADDR_VAR 0 9
54413: PUSH
54414: LD_VAR 0 14
54418: ST_TO_ADDR
// for j = 1 to k do
54419: LD_ADDR_VAR 0 8
54423: PUSH
54424: DOUBLE
54425: LD_INT 1
54427: DEC
54428: ST_TO_ADDR
54429: LD_VAR 0 9
54433: PUSH
54434: FOR_TO
54435: IFFALSE 54533
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
54437: LD_VAR 0 14
54441: PUSH
54442: LD_VAR 0 8
54446: ARRAY
54447: PPUSH
54448: CALL_OW 247
54452: PUSH
54453: LD_INT 1
54455: EQUAL
54456: PUSH
54457: LD_VAR 0 14
54461: PUSH
54462: LD_VAR 0 8
54466: ARRAY
54467: PPUSH
54468: CALL_OW 256
54472: PUSH
54473: LD_INT 250
54475: LESS
54476: PUSH
54477: LD_VAR 0 20
54481: AND
54482: PUSH
54483: LD_VAR 0 20
54487: NOT
54488: PUSH
54489: LD_VAR 0 14
54493: PUSH
54494: LD_VAR 0 8
54498: ARRAY
54499: PPUSH
54500: CALL_OW 256
54504: PUSH
54505: LD_INT 250
54507: GREATEREQUAL
54508: AND
54509: OR
54510: AND
54511: IFFALSE 54531
// begin x := tmp [ j ] ;
54513: LD_ADDR_VAR 0 10
54517: PUSH
54518: LD_VAR 0 14
54522: PUSH
54523: LD_VAR 0 8
54527: ARRAY
54528: ST_TO_ADDR
// break ;
54529: GO 54533
// end ;
54531: GO 54434
54533: POP
54534: POP
// if x then
54535: LD_VAR 0 10
54539: IFFALSE 54563
// ComAttackUnit ( group [ i ] , x ) else
54541: LD_VAR 0 4
54545: PUSH
54546: LD_VAR 0 7
54550: ARRAY
54551: PPUSH
54552: LD_VAR 0 10
54556: PPUSH
54557: CALL_OW 115
54561: GO 54587
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
54563: LD_VAR 0 4
54567: PUSH
54568: LD_VAR 0 7
54572: ARRAY
54573: PPUSH
54574: LD_VAR 0 14
54578: PUSH
54579: LD_INT 1
54581: ARRAY
54582: PPUSH
54583: CALL_OW 115
// if not HasTask ( group [ i ] ) then
54587: LD_VAR 0 4
54591: PUSH
54592: LD_VAR 0 7
54596: ARRAY
54597: PPUSH
54598: CALL_OW 314
54602: NOT
54603: IFFALSE 54641
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
54605: LD_VAR 0 4
54609: PUSH
54610: LD_VAR 0 7
54614: ARRAY
54615: PPUSH
54616: LD_VAR 0 14
54620: PPUSH
54621: LD_VAR 0 4
54625: PUSH
54626: LD_VAR 0 7
54630: ARRAY
54631: PPUSH
54632: CALL_OW 74
54636: PPUSH
54637: CALL_OW 115
// end ; end ; end ;
54641: GO 50520
54643: POP
54644: POP
// wait ( 0 0$1 ) ;
54645: LD_INT 35
54647: PPUSH
54648: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
54652: LD_VAR 0 4
54656: PUSH
54657: EMPTY
54658: EQUAL
54659: PUSH
54660: LD_INT 81
54662: PUSH
54663: LD_VAR 0 35
54667: PUSH
54668: EMPTY
54669: LIST
54670: LIST
54671: PPUSH
54672: CALL_OW 69
54676: NOT
54677: OR
54678: IFFALSE 50505
// end ;
54680: LD_VAR 0 2
54684: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54685: LD_INT 0
54687: PPUSH
54688: PPUSH
54689: PPUSH
54690: PPUSH
// if not base_units then
54691: LD_VAR 0 1
54695: NOT
54696: IFFALSE 54700
// exit ;
54698: GO 54787
// result := false ;
54700: LD_ADDR_VAR 0 2
54704: PUSH
54705: LD_INT 0
54707: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54708: LD_ADDR_VAR 0 5
54712: PUSH
54713: LD_VAR 0 1
54717: PPUSH
54718: LD_INT 21
54720: PUSH
54721: LD_INT 3
54723: PUSH
54724: EMPTY
54725: LIST
54726: LIST
54727: PPUSH
54728: CALL_OW 72
54732: ST_TO_ADDR
// if not tmp then
54733: LD_VAR 0 5
54737: NOT
54738: IFFALSE 54742
// exit ;
54740: GO 54787
// for i in tmp do
54742: LD_ADDR_VAR 0 3
54746: PUSH
54747: LD_VAR 0 5
54751: PUSH
54752: FOR_IN
54753: IFFALSE 54785
// begin result := EnemyInRange ( i , 22 ) ;
54755: LD_ADDR_VAR 0 2
54759: PUSH
54760: LD_VAR 0 3
54764: PPUSH
54765: LD_INT 22
54767: PPUSH
54768: CALL 48321 0 2
54772: ST_TO_ADDR
// if result then
54773: LD_VAR 0 2
54777: IFFALSE 54783
// exit ;
54779: POP
54780: POP
54781: GO 54787
// end ;
54783: GO 54752
54785: POP
54786: POP
// end ;
54787: LD_VAR 0 2
54791: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
54792: LD_INT 0
54794: PPUSH
54795: PPUSH
// if not units then
54796: LD_VAR 0 1
54800: NOT
54801: IFFALSE 54805
// exit ;
54803: GO 54875
// result := [ ] ;
54805: LD_ADDR_VAR 0 3
54809: PUSH
54810: EMPTY
54811: ST_TO_ADDR
// for i in units do
54812: LD_ADDR_VAR 0 4
54816: PUSH
54817: LD_VAR 0 1
54821: PUSH
54822: FOR_IN
54823: IFFALSE 54873
// if GetTag ( i ) = tag then
54825: LD_VAR 0 4
54829: PPUSH
54830: CALL_OW 110
54834: PUSH
54835: LD_VAR 0 2
54839: EQUAL
54840: IFFALSE 54871
// result := Insert ( result , result + 1 , i ) ;
54842: LD_ADDR_VAR 0 3
54846: PUSH
54847: LD_VAR 0 3
54851: PPUSH
54852: LD_VAR 0 3
54856: PUSH
54857: LD_INT 1
54859: PLUS
54860: PPUSH
54861: LD_VAR 0 4
54865: PPUSH
54866: CALL_OW 2
54870: ST_TO_ADDR
54871: GO 54822
54873: POP
54874: POP
// end ;
54875: LD_VAR 0 3
54879: RET
// export function IsDriver ( un ) ; begin
54880: LD_INT 0
54882: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54883: LD_ADDR_VAR 0 2
54887: PUSH
54888: LD_VAR 0 1
54892: PUSH
54893: LD_INT 55
54895: PUSH
54896: EMPTY
54897: LIST
54898: PPUSH
54899: CALL_OW 69
54903: IN
54904: ST_TO_ADDR
// end ;
54905: LD_VAR 0 2
54909: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54910: LD_INT 0
54912: PPUSH
54913: PPUSH
// list := [ ] ;
54914: LD_ADDR_VAR 0 5
54918: PUSH
54919: EMPTY
54920: ST_TO_ADDR
// case d of 0 :
54921: LD_VAR 0 3
54925: PUSH
54926: LD_INT 0
54928: DOUBLE
54929: EQUAL
54930: IFTRUE 54934
54932: GO 55067
54934: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54935: LD_ADDR_VAR 0 5
54939: PUSH
54940: LD_VAR 0 1
54944: PUSH
54945: LD_INT 4
54947: MINUS
54948: PUSH
54949: LD_VAR 0 2
54953: PUSH
54954: LD_INT 4
54956: MINUS
54957: PUSH
54958: LD_INT 2
54960: PUSH
54961: EMPTY
54962: LIST
54963: LIST
54964: LIST
54965: PUSH
54966: LD_VAR 0 1
54970: PUSH
54971: LD_INT 3
54973: MINUS
54974: PUSH
54975: LD_VAR 0 2
54979: PUSH
54980: LD_INT 1
54982: PUSH
54983: EMPTY
54984: LIST
54985: LIST
54986: LIST
54987: PUSH
54988: LD_VAR 0 1
54992: PUSH
54993: LD_INT 4
54995: PLUS
54996: PUSH
54997: LD_VAR 0 2
55001: PUSH
55002: LD_INT 4
55004: PUSH
55005: EMPTY
55006: LIST
55007: LIST
55008: LIST
55009: PUSH
55010: LD_VAR 0 1
55014: PUSH
55015: LD_INT 3
55017: PLUS
55018: PUSH
55019: LD_VAR 0 2
55023: PUSH
55024: LD_INT 3
55026: PLUS
55027: PUSH
55028: LD_INT 5
55030: PUSH
55031: EMPTY
55032: LIST
55033: LIST
55034: LIST
55035: PUSH
55036: LD_VAR 0 1
55040: PUSH
55041: LD_VAR 0 2
55045: PUSH
55046: LD_INT 4
55048: PLUS
55049: PUSH
55050: LD_INT 0
55052: PUSH
55053: EMPTY
55054: LIST
55055: LIST
55056: LIST
55057: PUSH
55058: EMPTY
55059: LIST
55060: LIST
55061: LIST
55062: LIST
55063: LIST
55064: ST_TO_ADDR
// end ; 1 :
55065: GO 55765
55067: LD_INT 1
55069: DOUBLE
55070: EQUAL
55071: IFTRUE 55075
55073: GO 55208
55075: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
55076: LD_ADDR_VAR 0 5
55080: PUSH
55081: LD_VAR 0 1
55085: PUSH
55086: LD_VAR 0 2
55090: PUSH
55091: LD_INT 4
55093: MINUS
55094: PUSH
55095: LD_INT 3
55097: PUSH
55098: EMPTY
55099: LIST
55100: LIST
55101: LIST
55102: PUSH
55103: LD_VAR 0 1
55107: PUSH
55108: LD_INT 3
55110: MINUS
55111: PUSH
55112: LD_VAR 0 2
55116: PUSH
55117: LD_INT 3
55119: MINUS
55120: PUSH
55121: LD_INT 2
55123: PUSH
55124: EMPTY
55125: LIST
55126: LIST
55127: LIST
55128: PUSH
55129: LD_VAR 0 1
55133: PUSH
55134: LD_INT 4
55136: MINUS
55137: PUSH
55138: LD_VAR 0 2
55142: PUSH
55143: LD_INT 1
55145: PUSH
55146: EMPTY
55147: LIST
55148: LIST
55149: LIST
55150: PUSH
55151: LD_VAR 0 1
55155: PUSH
55156: LD_VAR 0 2
55160: PUSH
55161: LD_INT 3
55163: PLUS
55164: PUSH
55165: LD_INT 0
55167: PUSH
55168: EMPTY
55169: LIST
55170: LIST
55171: LIST
55172: PUSH
55173: LD_VAR 0 1
55177: PUSH
55178: LD_INT 4
55180: PLUS
55181: PUSH
55182: LD_VAR 0 2
55186: PUSH
55187: LD_INT 4
55189: PLUS
55190: PUSH
55191: LD_INT 5
55193: PUSH
55194: EMPTY
55195: LIST
55196: LIST
55197: LIST
55198: PUSH
55199: EMPTY
55200: LIST
55201: LIST
55202: LIST
55203: LIST
55204: LIST
55205: ST_TO_ADDR
// end ; 2 :
55206: GO 55765
55208: LD_INT 2
55210: DOUBLE
55211: EQUAL
55212: IFTRUE 55216
55214: GO 55345
55216: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
55217: LD_ADDR_VAR 0 5
55221: PUSH
55222: LD_VAR 0 1
55226: PUSH
55227: LD_VAR 0 2
55231: PUSH
55232: LD_INT 3
55234: MINUS
55235: PUSH
55236: LD_INT 3
55238: PUSH
55239: EMPTY
55240: LIST
55241: LIST
55242: LIST
55243: PUSH
55244: LD_VAR 0 1
55248: PUSH
55249: LD_INT 4
55251: PLUS
55252: PUSH
55253: LD_VAR 0 2
55257: PUSH
55258: LD_INT 4
55260: PUSH
55261: EMPTY
55262: LIST
55263: LIST
55264: LIST
55265: PUSH
55266: LD_VAR 0 1
55270: PUSH
55271: LD_VAR 0 2
55275: PUSH
55276: LD_INT 4
55278: PLUS
55279: PUSH
55280: LD_INT 0
55282: PUSH
55283: EMPTY
55284: LIST
55285: LIST
55286: LIST
55287: PUSH
55288: LD_VAR 0 1
55292: PUSH
55293: LD_INT 3
55295: MINUS
55296: PUSH
55297: LD_VAR 0 2
55301: PUSH
55302: LD_INT 1
55304: PUSH
55305: EMPTY
55306: LIST
55307: LIST
55308: LIST
55309: PUSH
55310: LD_VAR 0 1
55314: PUSH
55315: LD_INT 4
55317: MINUS
55318: PUSH
55319: LD_VAR 0 2
55323: PUSH
55324: LD_INT 4
55326: MINUS
55327: PUSH
55328: LD_INT 2
55330: PUSH
55331: EMPTY
55332: LIST
55333: LIST
55334: LIST
55335: PUSH
55336: EMPTY
55337: LIST
55338: LIST
55339: LIST
55340: LIST
55341: LIST
55342: ST_TO_ADDR
// end ; 3 :
55343: GO 55765
55345: LD_INT 3
55347: DOUBLE
55348: EQUAL
55349: IFTRUE 55353
55351: GO 55486
55353: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
55354: LD_ADDR_VAR 0 5
55358: PUSH
55359: LD_VAR 0 1
55363: PUSH
55364: LD_INT 3
55366: PLUS
55367: PUSH
55368: LD_VAR 0 2
55372: PUSH
55373: LD_INT 4
55375: PUSH
55376: EMPTY
55377: LIST
55378: LIST
55379: LIST
55380: PUSH
55381: LD_VAR 0 1
55385: PUSH
55386: LD_INT 4
55388: PLUS
55389: PUSH
55390: LD_VAR 0 2
55394: PUSH
55395: LD_INT 4
55397: PLUS
55398: PUSH
55399: LD_INT 5
55401: PUSH
55402: EMPTY
55403: LIST
55404: LIST
55405: LIST
55406: PUSH
55407: LD_VAR 0 1
55411: PUSH
55412: LD_INT 4
55414: MINUS
55415: PUSH
55416: LD_VAR 0 2
55420: PUSH
55421: LD_INT 1
55423: PUSH
55424: EMPTY
55425: LIST
55426: LIST
55427: LIST
55428: PUSH
55429: LD_VAR 0 1
55433: PUSH
55434: LD_VAR 0 2
55438: PUSH
55439: LD_INT 4
55441: MINUS
55442: PUSH
55443: LD_INT 3
55445: PUSH
55446: EMPTY
55447: LIST
55448: LIST
55449: LIST
55450: PUSH
55451: LD_VAR 0 1
55455: PUSH
55456: LD_INT 3
55458: MINUS
55459: PUSH
55460: LD_VAR 0 2
55464: PUSH
55465: LD_INT 3
55467: MINUS
55468: PUSH
55469: LD_INT 2
55471: PUSH
55472: EMPTY
55473: LIST
55474: LIST
55475: LIST
55476: PUSH
55477: EMPTY
55478: LIST
55479: LIST
55480: LIST
55481: LIST
55482: LIST
55483: ST_TO_ADDR
// end ; 4 :
55484: GO 55765
55486: LD_INT 4
55488: DOUBLE
55489: EQUAL
55490: IFTRUE 55494
55492: GO 55627
55494: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55495: LD_ADDR_VAR 0 5
55499: PUSH
55500: LD_VAR 0 1
55504: PUSH
55505: LD_VAR 0 2
55509: PUSH
55510: LD_INT 4
55512: PLUS
55513: PUSH
55514: LD_INT 0
55516: PUSH
55517: EMPTY
55518: LIST
55519: LIST
55520: LIST
55521: PUSH
55522: LD_VAR 0 1
55526: PUSH
55527: LD_INT 3
55529: PLUS
55530: PUSH
55531: LD_VAR 0 2
55535: PUSH
55536: LD_INT 3
55538: PLUS
55539: PUSH
55540: LD_INT 5
55542: PUSH
55543: EMPTY
55544: LIST
55545: LIST
55546: LIST
55547: PUSH
55548: LD_VAR 0 1
55552: PUSH
55553: LD_INT 4
55555: PLUS
55556: PUSH
55557: LD_VAR 0 2
55561: PUSH
55562: LD_INT 4
55564: PUSH
55565: EMPTY
55566: LIST
55567: LIST
55568: LIST
55569: PUSH
55570: LD_VAR 0 1
55574: PUSH
55575: LD_VAR 0 2
55579: PUSH
55580: LD_INT 3
55582: MINUS
55583: PUSH
55584: LD_INT 3
55586: PUSH
55587: EMPTY
55588: LIST
55589: LIST
55590: LIST
55591: PUSH
55592: LD_VAR 0 1
55596: PUSH
55597: LD_INT 4
55599: MINUS
55600: PUSH
55601: LD_VAR 0 2
55605: PUSH
55606: LD_INT 4
55608: MINUS
55609: PUSH
55610: LD_INT 2
55612: PUSH
55613: EMPTY
55614: LIST
55615: LIST
55616: LIST
55617: PUSH
55618: EMPTY
55619: LIST
55620: LIST
55621: LIST
55622: LIST
55623: LIST
55624: ST_TO_ADDR
// end ; 5 :
55625: GO 55765
55627: LD_INT 5
55629: DOUBLE
55630: EQUAL
55631: IFTRUE 55635
55633: GO 55764
55635: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55636: LD_ADDR_VAR 0 5
55640: PUSH
55641: LD_VAR 0 1
55645: PUSH
55646: LD_INT 4
55648: MINUS
55649: PUSH
55650: LD_VAR 0 2
55654: PUSH
55655: LD_INT 1
55657: PUSH
55658: EMPTY
55659: LIST
55660: LIST
55661: LIST
55662: PUSH
55663: LD_VAR 0 1
55667: PUSH
55668: LD_VAR 0 2
55672: PUSH
55673: LD_INT 4
55675: MINUS
55676: PUSH
55677: LD_INT 3
55679: PUSH
55680: EMPTY
55681: LIST
55682: LIST
55683: LIST
55684: PUSH
55685: LD_VAR 0 1
55689: PUSH
55690: LD_INT 4
55692: PLUS
55693: PUSH
55694: LD_VAR 0 2
55698: PUSH
55699: LD_INT 4
55701: PLUS
55702: PUSH
55703: LD_INT 5
55705: PUSH
55706: EMPTY
55707: LIST
55708: LIST
55709: LIST
55710: PUSH
55711: LD_VAR 0 1
55715: PUSH
55716: LD_INT 3
55718: PLUS
55719: PUSH
55720: LD_VAR 0 2
55724: PUSH
55725: LD_INT 4
55727: PUSH
55728: EMPTY
55729: LIST
55730: LIST
55731: LIST
55732: PUSH
55733: LD_VAR 0 1
55737: PUSH
55738: LD_VAR 0 2
55742: PUSH
55743: LD_INT 3
55745: PLUS
55746: PUSH
55747: LD_INT 0
55749: PUSH
55750: EMPTY
55751: LIST
55752: LIST
55753: LIST
55754: PUSH
55755: EMPTY
55756: LIST
55757: LIST
55758: LIST
55759: LIST
55760: LIST
55761: ST_TO_ADDR
// end ; end ;
55762: GO 55765
55764: POP
// result := list ;
55765: LD_ADDR_VAR 0 4
55769: PUSH
55770: LD_VAR 0 5
55774: ST_TO_ADDR
// end ;
55775: LD_VAR 0 4
55779: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55780: LD_INT 0
55782: PPUSH
55783: PPUSH
55784: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55785: LD_VAR 0 1
55789: NOT
55790: PUSH
55791: LD_VAR 0 2
55795: PUSH
55796: LD_INT 1
55798: PUSH
55799: LD_INT 2
55801: PUSH
55802: LD_INT 3
55804: PUSH
55805: LD_INT 4
55807: PUSH
55808: EMPTY
55809: LIST
55810: LIST
55811: LIST
55812: LIST
55813: IN
55814: NOT
55815: OR
55816: IFFALSE 55820
// exit ;
55818: GO 55912
// tmp := [ ] ;
55820: LD_ADDR_VAR 0 5
55824: PUSH
55825: EMPTY
55826: ST_TO_ADDR
// for i in units do
55827: LD_ADDR_VAR 0 4
55831: PUSH
55832: LD_VAR 0 1
55836: PUSH
55837: FOR_IN
55838: IFFALSE 55881
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55840: LD_ADDR_VAR 0 5
55844: PUSH
55845: LD_VAR 0 5
55849: PPUSH
55850: LD_VAR 0 5
55854: PUSH
55855: LD_INT 1
55857: PLUS
55858: PPUSH
55859: LD_VAR 0 4
55863: PPUSH
55864: LD_VAR 0 2
55868: PPUSH
55869: CALL_OW 259
55873: PPUSH
55874: CALL_OW 2
55878: ST_TO_ADDR
55879: GO 55837
55881: POP
55882: POP
// if not tmp then
55883: LD_VAR 0 5
55887: NOT
55888: IFFALSE 55892
// exit ;
55890: GO 55912
// result := SortListByListDesc ( units , tmp ) ;
55892: LD_ADDR_VAR 0 3
55896: PUSH
55897: LD_VAR 0 1
55901: PPUSH
55902: LD_VAR 0 5
55906: PPUSH
55907: CALL_OW 77
55911: ST_TO_ADDR
// end ;
55912: LD_VAR 0 3
55916: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55917: LD_INT 0
55919: PPUSH
55920: PPUSH
55921: PPUSH
// x := GetX ( building ) ;
55922: LD_ADDR_VAR 0 4
55926: PUSH
55927: LD_VAR 0 2
55931: PPUSH
55932: CALL_OW 250
55936: ST_TO_ADDR
// y := GetY ( building ) ;
55937: LD_ADDR_VAR 0 5
55941: PUSH
55942: LD_VAR 0 2
55946: PPUSH
55947: CALL_OW 251
55951: ST_TO_ADDR
// if GetTaskList ( unit ) then
55952: LD_VAR 0 1
55956: PPUSH
55957: CALL_OW 437
55961: IFFALSE 56056
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55963: LD_STRING e
55965: PUSH
55966: LD_VAR 0 1
55970: PPUSH
55971: CALL_OW 437
55975: PUSH
55976: LD_INT 1
55978: ARRAY
55979: PUSH
55980: LD_INT 1
55982: ARRAY
55983: EQUAL
55984: PUSH
55985: LD_VAR 0 4
55989: PUSH
55990: LD_VAR 0 1
55994: PPUSH
55995: CALL_OW 437
55999: PUSH
56000: LD_INT 1
56002: ARRAY
56003: PUSH
56004: LD_INT 2
56006: ARRAY
56007: EQUAL
56008: AND
56009: PUSH
56010: LD_VAR 0 5
56014: PUSH
56015: LD_VAR 0 1
56019: PPUSH
56020: CALL_OW 437
56024: PUSH
56025: LD_INT 1
56027: ARRAY
56028: PUSH
56029: LD_INT 3
56031: ARRAY
56032: EQUAL
56033: AND
56034: IFFALSE 56046
// result := true else
56036: LD_ADDR_VAR 0 3
56040: PUSH
56041: LD_INT 1
56043: ST_TO_ADDR
56044: GO 56054
// result := false ;
56046: LD_ADDR_VAR 0 3
56050: PUSH
56051: LD_INT 0
56053: ST_TO_ADDR
// end else
56054: GO 56064
// result := false ;
56056: LD_ADDR_VAR 0 3
56060: PUSH
56061: LD_INT 0
56063: ST_TO_ADDR
// end ;
56064: LD_VAR 0 3
56068: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
56069: LD_INT 0
56071: PPUSH
56072: PPUSH
56073: PPUSH
56074: PPUSH
// if not unit or not area then
56075: LD_VAR 0 1
56079: NOT
56080: PUSH
56081: LD_VAR 0 2
56085: NOT
56086: OR
56087: IFFALSE 56091
// exit ;
56089: GO 56255
// tmp := AreaToList ( area , i ) ;
56091: LD_ADDR_VAR 0 6
56095: PUSH
56096: LD_VAR 0 2
56100: PPUSH
56101: LD_VAR 0 5
56105: PPUSH
56106: CALL_OW 517
56110: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
56111: LD_ADDR_VAR 0 5
56115: PUSH
56116: DOUBLE
56117: LD_INT 1
56119: DEC
56120: ST_TO_ADDR
56121: LD_VAR 0 6
56125: PUSH
56126: LD_INT 1
56128: ARRAY
56129: PUSH
56130: FOR_TO
56131: IFFALSE 56253
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
56133: LD_ADDR_VAR 0 7
56137: PUSH
56138: LD_VAR 0 6
56142: PUSH
56143: LD_INT 1
56145: ARRAY
56146: PUSH
56147: LD_VAR 0 5
56151: ARRAY
56152: PUSH
56153: LD_VAR 0 6
56157: PUSH
56158: LD_INT 2
56160: ARRAY
56161: PUSH
56162: LD_VAR 0 5
56166: ARRAY
56167: PUSH
56168: EMPTY
56169: LIST
56170: LIST
56171: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
56172: LD_VAR 0 7
56176: PUSH
56177: LD_INT 1
56179: ARRAY
56180: PPUSH
56181: LD_VAR 0 7
56185: PUSH
56186: LD_INT 2
56188: ARRAY
56189: PPUSH
56190: CALL_OW 428
56194: PUSH
56195: LD_INT 0
56197: EQUAL
56198: IFFALSE 56251
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
56200: LD_VAR 0 1
56204: PPUSH
56205: LD_VAR 0 7
56209: PUSH
56210: LD_INT 1
56212: ARRAY
56213: PPUSH
56214: LD_VAR 0 7
56218: PUSH
56219: LD_INT 2
56221: ARRAY
56222: PPUSH
56223: LD_VAR 0 3
56227: PPUSH
56228: CALL_OW 48
// result := IsPlaced ( unit ) ;
56232: LD_ADDR_VAR 0 4
56236: PUSH
56237: LD_VAR 0 1
56241: PPUSH
56242: CALL_OW 305
56246: ST_TO_ADDR
// exit ;
56247: POP
56248: POP
56249: GO 56255
// end ; end ;
56251: GO 56130
56253: POP
56254: POP
// end ;
56255: LD_VAR 0 4
56259: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
56260: LD_INT 0
56262: PPUSH
56263: PPUSH
56264: PPUSH
// if not side or side > 8 then
56265: LD_VAR 0 1
56269: NOT
56270: PUSH
56271: LD_VAR 0 1
56275: PUSH
56276: LD_INT 8
56278: GREATER
56279: OR
56280: IFFALSE 56284
// exit ;
56282: GO 56471
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
56284: LD_ADDR_VAR 0 4
56288: PUSH
56289: LD_INT 22
56291: PUSH
56292: LD_VAR 0 1
56296: PUSH
56297: EMPTY
56298: LIST
56299: LIST
56300: PUSH
56301: LD_INT 21
56303: PUSH
56304: LD_INT 3
56306: PUSH
56307: EMPTY
56308: LIST
56309: LIST
56310: PUSH
56311: EMPTY
56312: LIST
56313: LIST
56314: PPUSH
56315: CALL_OW 69
56319: ST_TO_ADDR
// if not tmp then
56320: LD_VAR 0 4
56324: NOT
56325: IFFALSE 56329
// exit ;
56327: GO 56471
// enable_addtolog := true ;
56329: LD_ADDR_OWVAR 81
56333: PUSH
56334: LD_INT 1
56336: ST_TO_ADDR
// AddToLog ( [ ) ;
56337: LD_STRING [
56339: PPUSH
56340: CALL_OW 561
// for i in tmp do
56344: LD_ADDR_VAR 0 3
56348: PUSH
56349: LD_VAR 0 4
56353: PUSH
56354: FOR_IN
56355: IFFALSE 56462
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
56357: LD_STRING [
56359: PUSH
56360: LD_VAR 0 3
56364: PPUSH
56365: CALL_OW 266
56369: STR
56370: PUSH
56371: LD_STRING , 
56373: STR
56374: PUSH
56375: LD_VAR 0 3
56379: PPUSH
56380: CALL_OW 250
56384: STR
56385: PUSH
56386: LD_STRING , 
56388: STR
56389: PUSH
56390: LD_VAR 0 3
56394: PPUSH
56395: CALL_OW 251
56399: STR
56400: PUSH
56401: LD_STRING , 
56403: STR
56404: PUSH
56405: LD_VAR 0 3
56409: PPUSH
56410: CALL_OW 254
56414: STR
56415: PUSH
56416: LD_STRING , 
56418: STR
56419: PUSH
56420: LD_VAR 0 3
56424: PPUSH
56425: LD_INT 1
56427: PPUSH
56428: CALL_OW 268
56432: STR
56433: PUSH
56434: LD_STRING , 
56436: STR
56437: PUSH
56438: LD_VAR 0 3
56442: PPUSH
56443: LD_INT 2
56445: PPUSH
56446: CALL_OW 268
56450: STR
56451: PUSH
56452: LD_STRING ],
56454: STR
56455: PPUSH
56456: CALL_OW 561
// end ;
56460: GO 56354
56462: POP
56463: POP
// AddToLog ( ]; ) ;
56464: LD_STRING ];
56466: PPUSH
56467: CALL_OW 561
// end ;
56471: LD_VAR 0 2
56475: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56476: LD_INT 0
56478: PPUSH
56479: PPUSH
56480: PPUSH
56481: PPUSH
56482: PPUSH
// if not area or not rate or not max then
56483: LD_VAR 0 1
56487: NOT
56488: PUSH
56489: LD_VAR 0 2
56493: NOT
56494: OR
56495: PUSH
56496: LD_VAR 0 4
56500: NOT
56501: OR
56502: IFFALSE 56506
// exit ;
56504: GO 56698
// while 1 do
56506: LD_INT 1
56508: IFFALSE 56698
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56510: LD_ADDR_VAR 0 9
56514: PUSH
56515: LD_VAR 0 1
56519: PPUSH
56520: LD_INT 1
56522: PPUSH
56523: CALL_OW 287
56527: PUSH
56528: LD_INT 10
56530: MUL
56531: ST_TO_ADDR
// r := rate / 10 ;
56532: LD_ADDR_VAR 0 7
56536: PUSH
56537: LD_VAR 0 2
56541: PUSH
56542: LD_INT 10
56544: DIVREAL
56545: ST_TO_ADDR
// time := 1 1$00 ;
56546: LD_ADDR_VAR 0 8
56550: PUSH
56551: LD_INT 2100
56553: ST_TO_ADDR
// if amount < min then
56554: LD_VAR 0 9
56558: PUSH
56559: LD_VAR 0 3
56563: LESS
56564: IFFALSE 56582
// r := r * 2 else
56566: LD_ADDR_VAR 0 7
56570: PUSH
56571: LD_VAR 0 7
56575: PUSH
56576: LD_INT 2
56578: MUL
56579: ST_TO_ADDR
56580: GO 56608
// if amount > max then
56582: LD_VAR 0 9
56586: PUSH
56587: LD_VAR 0 4
56591: GREATER
56592: IFFALSE 56608
// r := r / 2 ;
56594: LD_ADDR_VAR 0 7
56598: PUSH
56599: LD_VAR 0 7
56603: PUSH
56604: LD_INT 2
56606: DIVREAL
56607: ST_TO_ADDR
// time := time / r ;
56608: LD_ADDR_VAR 0 8
56612: PUSH
56613: LD_VAR 0 8
56617: PUSH
56618: LD_VAR 0 7
56622: DIVREAL
56623: ST_TO_ADDR
// if time < 0 then
56624: LD_VAR 0 8
56628: PUSH
56629: LD_INT 0
56631: LESS
56632: IFFALSE 56649
// time := time * - 1 ;
56634: LD_ADDR_VAR 0 8
56638: PUSH
56639: LD_VAR 0 8
56643: PUSH
56644: LD_INT 1
56646: NEG
56647: MUL
56648: ST_TO_ADDR
// wait ( time ) ;
56649: LD_VAR 0 8
56653: PPUSH
56654: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
56658: LD_INT 35
56660: PPUSH
56661: LD_INT 875
56663: PPUSH
56664: CALL_OW 12
56668: PPUSH
56669: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56673: LD_INT 1
56675: PPUSH
56676: LD_INT 5
56678: PPUSH
56679: CALL_OW 12
56683: PPUSH
56684: LD_VAR 0 1
56688: PPUSH
56689: LD_INT 1
56691: PPUSH
56692: CALL_OW 55
// end ;
56696: GO 56506
// end ;
56698: LD_VAR 0 5
56702: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56703: LD_INT 0
56705: PPUSH
56706: PPUSH
56707: PPUSH
56708: PPUSH
56709: PPUSH
56710: PPUSH
56711: PPUSH
56712: PPUSH
// if not turrets or not factories then
56713: LD_VAR 0 1
56717: NOT
56718: PUSH
56719: LD_VAR 0 2
56723: NOT
56724: OR
56725: IFFALSE 56729
// exit ;
56727: GO 57036
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56729: LD_ADDR_VAR 0 10
56733: PUSH
56734: LD_INT 5
56736: PUSH
56737: LD_INT 6
56739: PUSH
56740: EMPTY
56741: LIST
56742: LIST
56743: PUSH
56744: LD_INT 2
56746: PUSH
56747: LD_INT 4
56749: PUSH
56750: EMPTY
56751: LIST
56752: LIST
56753: PUSH
56754: LD_INT 3
56756: PUSH
56757: LD_INT 5
56759: PUSH
56760: EMPTY
56761: LIST
56762: LIST
56763: PUSH
56764: EMPTY
56765: LIST
56766: LIST
56767: LIST
56768: PUSH
56769: LD_INT 24
56771: PUSH
56772: LD_INT 25
56774: PUSH
56775: EMPTY
56776: LIST
56777: LIST
56778: PUSH
56779: LD_INT 23
56781: PUSH
56782: LD_INT 27
56784: PUSH
56785: EMPTY
56786: LIST
56787: LIST
56788: PUSH
56789: EMPTY
56790: LIST
56791: LIST
56792: PUSH
56793: LD_INT 42
56795: PUSH
56796: LD_INT 43
56798: PUSH
56799: EMPTY
56800: LIST
56801: LIST
56802: PUSH
56803: LD_INT 44
56805: PUSH
56806: LD_INT 46
56808: PUSH
56809: EMPTY
56810: LIST
56811: LIST
56812: PUSH
56813: LD_INT 45
56815: PUSH
56816: LD_INT 47
56818: PUSH
56819: EMPTY
56820: LIST
56821: LIST
56822: PUSH
56823: EMPTY
56824: LIST
56825: LIST
56826: LIST
56827: PUSH
56828: EMPTY
56829: LIST
56830: LIST
56831: LIST
56832: ST_TO_ADDR
// result := [ ] ;
56833: LD_ADDR_VAR 0 3
56837: PUSH
56838: EMPTY
56839: ST_TO_ADDR
// for i in turrets do
56840: LD_ADDR_VAR 0 4
56844: PUSH
56845: LD_VAR 0 1
56849: PUSH
56850: FOR_IN
56851: IFFALSE 57034
// begin nat := GetNation ( i ) ;
56853: LD_ADDR_VAR 0 7
56857: PUSH
56858: LD_VAR 0 4
56862: PPUSH
56863: CALL_OW 248
56867: ST_TO_ADDR
// weapon := 0 ;
56868: LD_ADDR_VAR 0 8
56872: PUSH
56873: LD_INT 0
56875: ST_TO_ADDR
// if not nat then
56876: LD_VAR 0 7
56880: NOT
56881: IFFALSE 56885
// continue ;
56883: GO 56850
// for j in list [ nat ] do
56885: LD_ADDR_VAR 0 5
56889: PUSH
56890: LD_VAR 0 10
56894: PUSH
56895: LD_VAR 0 7
56899: ARRAY
56900: PUSH
56901: FOR_IN
56902: IFFALSE 56943
// if GetBWeapon ( i ) = j [ 1 ] then
56904: LD_VAR 0 4
56908: PPUSH
56909: CALL_OW 269
56913: PUSH
56914: LD_VAR 0 5
56918: PUSH
56919: LD_INT 1
56921: ARRAY
56922: EQUAL
56923: IFFALSE 56941
// begin weapon := j [ 2 ] ;
56925: LD_ADDR_VAR 0 8
56929: PUSH
56930: LD_VAR 0 5
56934: PUSH
56935: LD_INT 2
56937: ARRAY
56938: ST_TO_ADDR
// break ;
56939: GO 56943
// end ;
56941: GO 56901
56943: POP
56944: POP
// if not weapon then
56945: LD_VAR 0 8
56949: NOT
56950: IFFALSE 56954
// continue ;
56952: GO 56850
// for k in factories do
56954: LD_ADDR_VAR 0 6
56958: PUSH
56959: LD_VAR 0 2
56963: PUSH
56964: FOR_IN
56965: IFFALSE 57030
// begin weapons := AvailableWeaponList ( k ) ;
56967: LD_ADDR_VAR 0 9
56971: PUSH
56972: LD_VAR 0 6
56976: PPUSH
56977: CALL_OW 478
56981: ST_TO_ADDR
// if not weapons then
56982: LD_VAR 0 9
56986: NOT
56987: IFFALSE 56991
// continue ;
56989: GO 56964
// if weapon in weapons then
56991: LD_VAR 0 8
56995: PUSH
56996: LD_VAR 0 9
57000: IN
57001: IFFALSE 57028
// begin result := [ i , weapon ] ;
57003: LD_ADDR_VAR 0 3
57007: PUSH
57008: LD_VAR 0 4
57012: PUSH
57013: LD_VAR 0 8
57017: PUSH
57018: EMPTY
57019: LIST
57020: LIST
57021: ST_TO_ADDR
// exit ;
57022: POP
57023: POP
57024: POP
57025: POP
57026: GO 57036
// end ; end ;
57028: GO 56964
57030: POP
57031: POP
// end ;
57032: GO 56850
57034: POP
57035: POP
// end ;
57036: LD_VAR 0 3
57040: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
57041: LD_INT 0
57043: PPUSH
// if not side or side > 8 then
57044: LD_VAR 0 3
57048: NOT
57049: PUSH
57050: LD_VAR 0 3
57054: PUSH
57055: LD_INT 8
57057: GREATER
57058: OR
57059: IFFALSE 57063
// exit ;
57061: GO 57122
// if not range then
57063: LD_VAR 0 4
57067: NOT
57068: IFFALSE 57079
// range := - 12 ;
57070: LD_ADDR_VAR 0 4
57074: PUSH
57075: LD_INT 12
57077: NEG
57078: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
57079: LD_VAR 0 1
57083: PPUSH
57084: LD_VAR 0 2
57088: PPUSH
57089: LD_VAR 0 3
57093: PPUSH
57094: LD_VAR 0 4
57098: PPUSH
57099: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
57103: LD_VAR 0 1
57107: PPUSH
57108: LD_VAR 0 2
57112: PPUSH
57113: LD_VAR 0 3
57117: PPUSH
57118: CALL_OW 331
// end ;
57122: LD_VAR 0 5
57126: RET
// export function Video ( mode ) ; begin
57127: LD_INT 0
57129: PPUSH
// ingame_video = mode ;
57130: LD_ADDR_OWVAR 52
57134: PUSH
57135: LD_VAR 0 1
57139: ST_TO_ADDR
// interface_hidden = mode ;
57140: LD_ADDR_OWVAR 54
57144: PUSH
57145: LD_VAR 0 1
57149: ST_TO_ADDR
// end ;
57150: LD_VAR 0 2
57154: RET
// export function Join ( array , element ) ; begin
57155: LD_INT 0
57157: PPUSH
// result := array ^ element ;
57158: LD_ADDR_VAR 0 3
57162: PUSH
57163: LD_VAR 0 1
57167: PUSH
57168: LD_VAR 0 2
57172: ADD
57173: ST_TO_ADDR
// end ;
57174: LD_VAR 0 3
57178: RET
// export function JoinUnion ( array , element ) ; begin
57179: LD_INT 0
57181: PPUSH
// result := array union element ;
57182: LD_ADDR_VAR 0 3
57186: PUSH
57187: LD_VAR 0 1
57191: PUSH
57192: LD_VAR 0 2
57196: UNION
57197: ST_TO_ADDR
// end ;
57198: LD_VAR 0 3
57202: RET
// export function GetBehemoths ( side ) ; begin
57203: LD_INT 0
57205: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
57206: LD_ADDR_VAR 0 2
57210: PUSH
57211: LD_INT 22
57213: PUSH
57214: LD_VAR 0 1
57218: PUSH
57219: EMPTY
57220: LIST
57221: LIST
57222: PUSH
57223: LD_INT 31
57225: PUSH
57226: LD_INT 25
57228: PUSH
57229: EMPTY
57230: LIST
57231: LIST
57232: PUSH
57233: EMPTY
57234: LIST
57235: LIST
57236: PPUSH
57237: CALL_OW 69
57241: ST_TO_ADDR
// end ;
57242: LD_VAR 0 2
57246: RET
// export function Shuffle ( array ) ; var i , index ; begin
57247: LD_INT 0
57249: PPUSH
57250: PPUSH
57251: PPUSH
// result := [ ] ;
57252: LD_ADDR_VAR 0 2
57256: PUSH
57257: EMPTY
57258: ST_TO_ADDR
// if not array then
57259: LD_VAR 0 1
57263: NOT
57264: IFFALSE 57268
// exit ;
57266: GO 57367
// Randomize ;
57268: CALL_OW 10
// for i = array downto 1 do
57272: LD_ADDR_VAR 0 3
57276: PUSH
57277: DOUBLE
57278: LD_VAR 0 1
57282: INC
57283: ST_TO_ADDR
57284: LD_INT 1
57286: PUSH
57287: FOR_DOWNTO
57288: IFFALSE 57365
// begin index := rand ( 1 , array ) ;
57290: LD_ADDR_VAR 0 4
57294: PUSH
57295: LD_INT 1
57297: PPUSH
57298: LD_VAR 0 1
57302: PPUSH
57303: CALL_OW 12
57307: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
57308: LD_ADDR_VAR 0 2
57312: PUSH
57313: LD_VAR 0 2
57317: PPUSH
57318: LD_VAR 0 2
57322: PUSH
57323: LD_INT 1
57325: PLUS
57326: PPUSH
57327: LD_VAR 0 1
57331: PUSH
57332: LD_VAR 0 4
57336: ARRAY
57337: PPUSH
57338: CALL_OW 2
57342: ST_TO_ADDR
// array := Delete ( array , index ) ;
57343: LD_ADDR_VAR 0 1
57347: PUSH
57348: LD_VAR 0 1
57352: PPUSH
57353: LD_VAR 0 4
57357: PPUSH
57358: CALL_OW 3
57362: ST_TO_ADDR
// end ;
57363: GO 57287
57365: POP
57366: POP
// end ;
57367: LD_VAR 0 2
57371: RET
// export function GetBaseMaterials ( base ) ; begin
57372: LD_INT 0
57374: PPUSH
// result := [ 0 , 0 , 0 ] ;
57375: LD_ADDR_VAR 0 2
57379: PUSH
57380: LD_INT 0
57382: PUSH
57383: LD_INT 0
57385: PUSH
57386: LD_INT 0
57388: PUSH
57389: EMPTY
57390: LIST
57391: LIST
57392: LIST
57393: ST_TO_ADDR
// if not base then
57394: LD_VAR 0 1
57398: NOT
57399: IFFALSE 57403
// exit ;
57401: GO 57452
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57403: LD_ADDR_VAR 0 2
57407: PUSH
57408: LD_VAR 0 1
57412: PPUSH
57413: LD_INT 1
57415: PPUSH
57416: CALL_OW 275
57420: PUSH
57421: LD_VAR 0 1
57425: PPUSH
57426: LD_INT 2
57428: PPUSH
57429: CALL_OW 275
57433: PUSH
57434: LD_VAR 0 1
57438: PPUSH
57439: LD_INT 3
57441: PPUSH
57442: CALL_OW 275
57446: PUSH
57447: EMPTY
57448: LIST
57449: LIST
57450: LIST
57451: ST_TO_ADDR
// end ; end_of_file
57452: LD_VAR 0 2
57456: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
57457: LD_INT 0
57459: PPUSH
57460: PPUSH
// skirmish := false ;
57461: LD_ADDR_EXP 57
57465: PUSH
57466: LD_INT 0
57468: ST_TO_ADDR
// debug_mc := false ;
57469: LD_ADDR_EXP 58
57473: PUSH
57474: LD_INT 0
57476: ST_TO_ADDR
// mc_bases := [ ] ;
57477: LD_ADDR_EXP 59
57481: PUSH
57482: EMPTY
57483: ST_TO_ADDR
// mc_sides := [ ] ;
57484: LD_ADDR_EXP 85
57488: PUSH
57489: EMPTY
57490: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
57491: LD_ADDR_EXP 60
57495: PUSH
57496: EMPTY
57497: ST_TO_ADDR
// mc_building_repairs := [ ] ;
57498: LD_ADDR_EXP 61
57502: PUSH
57503: EMPTY
57504: ST_TO_ADDR
// mc_need_heal := [ ] ;
57505: LD_ADDR_EXP 62
57509: PUSH
57510: EMPTY
57511: ST_TO_ADDR
// mc_healers := [ ] ;
57512: LD_ADDR_EXP 63
57516: PUSH
57517: EMPTY
57518: ST_TO_ADDR
// mc_build_list := [ ] ;
57519: LD_ADDR_EXP 64
57523: PUSH
57524: EMPTY
57525: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
57526: LD_ADDR_EXP 91
57530: PUSH
57531: EMPTY
57532: ST_TO_ADDR
// mc_builders := [ ] ;
57533: LD_ADDR_EXP 65
57537: PUSH
57538: EMPTY
57539: ST_TO_ADDR
// mc_construct_list := [ ] ;
57540: LD_ADDR_EXP 66
57544: PUSH
57545: EMPTY
57546: ST_TO_ADDR
// mc_turret_list := [ ] ;
57547: LD_ADDR_EXP 67
57551: PUSH
57552: EMPTY
57553: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
57554: LD_ADDR_EXP 68
57558: PUSH
57559: EMPTY
57560: ST_TO_ADDR
// mc_miners := [ ] ;
57561: LD_ADDR_EXP 73
57565: PUSH
57566: EMPTY
57567: ST_TO_ADDR
// mc_mines := [ ] ;
57568: LD_ADDR_EXP 72
57572: PUSH
57573: EMPTY
57574: ST_TO_ADDR
// mc_minefields := [ ] ;
57575: LD_ADDR_EXP 74
57579: PUSH
57580: EMPTY
57581: ST_TO_ADDR
// mc_crates := [ ] ;
57582: LD_ADDR_EXP 75
57586: PUSH
57587: EMPTY
57588: ST_TO_ADDR
// mc_crates_collector := [ ] ;
57589: LD_ADDR_EXP 76
57593: PUSH
57594: EMPTY
57595: ST_TO_ADDR
// mc_crates_area := [ ] ;
57596: LD_ADDR_EXP 77
57600: PUSH
57601: EMPTY
57602: ST_TO_ADDR
// mc_vehicles := [ ] ;
57603: LD_ADDR_EXP 78
57607: PUSH
57608: EMPTY
57609: ST_TO_ADDR
// mc_attack := [ ] ;
57610: LD_ADDR_EXP 79
57614: PUSH
57615: EMPTY
57616: ST_TO_ADDR
// mc_produce := [ ] ;
57617: LD_ADDR_EXP 80
57621: PUSH
57622: EMPTY
57623: ST_TO_ADDR
// mc_defender := [ ] ;
57624: LD_ADDR_EXP 81
57628: PUSH
57629: EMPTY
57630: ST_TO_ADDR
// mc_parking := [ ] ;
57631: LD_ADDR_EXP 83
57635: PUSH
57636: EMPTY
57637: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
57638: LD_ADDR_EXP 69
57642: PUSH
57643: EMPTY
57644: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
57645: LD_ADDR_EXP 71
57649: PUSH
57650: EMPTY
57651: ST_TO_ADDR
// mc_scan := [ ] ;
57652: LD_ADDR_EXP 82
57656: PUSH
57657: EMPTY
57658: ST_TO_ADDR
// mc_scan_area := [ ] ;
57659: LD_ADDR_EXP 84
57663: PUSH
57664: EMPTY
57665: ST_TO_ADDR
// mc_tech := [ ] ;
57666: LD_ADDR_EXP 86
57670: PUSH
57671: EMPTY
57672: ST_TO_ADDR
// mc_class := [ ] ;
57673: LD_ADDR_EXP 100
57677: PUSH
57678: EMPTY
57679: ST_TO_ADDR
// mc_class_case_use := [ ] ;
57680: LD_ADDR_EXP 101
57684: PUSH
57685: EMPTY
57686: ST_TO_ADDR
// end ;
57687: LD_VAR 0 1
57691: RET
// export function MC_Kill ( base ) ; begin
57692: LD_INT 0
57694: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
57695: LD_ADDR_EXP 59
57699: PUSH
57700: LD_EXP 59
57704: PPUSH
57705: LD_VAR 0 1
57709: PPUSH
57710: EMPTY
57711: PPUSH
57712: CALL_OW 1
57716: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57717: LD_ADDR_EXP 60
57721: PUSH
57722: LD_EXP 60
57726: PPUSH
57727: LD_VAR 0 1
57731: PPUSH
57732: EMPTY
57733: PPUSH
57734: CALL_OW 1
57738: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57739: LD_ADDR_EXP 61
57743: PUSH
57744: LD_EXP 61
57748: PPUSH
57749: LD_VAR 0 1
57753: PPUSH
57754: EMPTY
57755: PPUSH
57756: CALL_OW 1
57760: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57761: LD_ADDR_EXP 62
57765: PUSH
57766: LD_EXP 62
57770: PPUSH
57771: LD_VAR 0 1
57775: PPUSH
57776: EMPTY
57777: PPUSH
57778: CALL_OW 1
57782: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57783: LD_ADDR_EXP 63
57787: PUSH
57788: LD_EXP 63
57792: PPUSH
57793: LD_VAR 0 1
57797: PPUSH
57798: EMPTY
57799: PPUSH
57800: CALL_OW 1
57804: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57805: LD_ADDR_EXP 64
57809: PUSH
57810: LD_EXP 64
57814: PPUSH
57815: LD_VAR 0 1
57819: PPUSH
57820: EMPTY
57821: PPUSH
57822: CALL_OW 1
57826: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57827: LD_ADDR_EXP 65
57831: PUSH
57832: LD_EXP 65
57836: PPUSH
57837: LD_VAR 0 1
57841: PPUSH
57842: EMPTY
57843: PPUSH
57844: CALL_OW 1
57848: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57849: LD_ADDR_EXP 66
57853: PUSH
57854: LD_EXP 66
57858: PPUSH
57859: LD_VAR 0 1
57863: PPUSH
57864: EMPTY
57865: PPUSH
57866: CALL_OW 1
57870: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57871: LD_ADDR_EXP 67
57875: PUSH
57876: LD_EXP 67
57880: PPUSH
57881: LD_VAR 0 1
57885: PPUSH
57886: EMPTY
57887: PPUSH
57888: CALL_OW 1
57892: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57893: LD_ADDR_EXP 68
57897: PUSH
57898: LD_EXP 68
57902: PPUSH
57903: LD_VAR 0 1
57907: PPUSH
57908: EMPTY
57909: PPUSH
57910: CALL_OW 1
57914: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57915: LD_ADDR_EXP 69
57919: PUSH
57920: LD_EXP 69
57924: PPUSH
57925: LD_VAR 0 1
57929: PPUSH
57930: EMPTY
57931: PPUSH
57932: CALL_OW 1
57936: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57937: LD_ADDR_EXP 70
57941: PUSH
57942: LD_EXP 70
57946: PPUSH
57947: LD_VAR 0 1
57951: PPUSH
57952: LD_INT 0
57954: PPUSH
57955: CALL_OW 1
57959: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57960: LD_ADDR_EXP 71
57964: PUSH
57965: LD_EXP 71
57969: PPUSH
57970: LD_VAR 0 1
57974: PPUSH
57975: EMPTY
57976: PPUSH
57977: CALL_OW 1
57981: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57982: LD_ADDR_EXP 72
57986: PUSH
57987: LD_EXP 72
57991: PPUSH
57992: LD_VAR 0 1
57996: PPUSH
57997: EMPTY
57998: PPUSH
57999: CALL_OW 1
58003: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58004: LD_ADDR_EXP 73
58008: PUSH
58009: LD_EXP 73
58013: PPUSH
58014: LD_VAR 0 1
58018: PPUSH
58019: EMPTY
58020: PPUSH
58021: CALL_OW 1
58025: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58026: LD_ADDR_EXP 74
58030: PUSH
58031: LD_EXP 74
58035: PPUSH
58036: LD_VAR 0 1
58040: PPUSH
58041: EMPTY
58042: PPUSH
58043: CALL_OW 1
58047: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58048: LD_ADDR_EXP 75
58052: PUSH
58053: LD_EXP 75
58057: PPUSH
58058: LD_VAR 0 1
58062: PPUSH
58063: EMPTY
58064: PPUSH
58065: CALL_OW 1
58069: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58070: LD_ADDR_EXP 76
58074: PUSH
58075: LD_EXP 76
58079: PPUSH
58080: LD_VAR 0 1
58084: PPUSH
58085: EMPTY
58086: PPUSH
58087: CALL_OW 1
58091: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58092: LD_ADDR_EXP 77
58096: PUSH
58097: LD_EXP 77
58101: PPUSH
58102: LD_VAR 0 1
58106: PPUSH
58107: EMPTY
58108: PPUSH
58109: CALL_OW 1
58113: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58114: LD_ADDR_EXP 78
58118: PUSH
58119: LD_EXP 78
58123: PPUSH
58124: LD_VAR 0 1
58128: PPUSH
58129: EMPTY
58130: PPUSH
58131: CALL_OW 1
58135: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58136: LD_ADDR_EXP 79
58140: PUSH
58141: LD_EXP 79
58145: PPUSH
58146: LD_VAR 0 1
58150: PPUSH
58151: EMPTY
58152: PPUSH
58153: CALL_OW 1
58157: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58158: LD_ADDR_EXP 80
58162: PUSH
58163: LD_EXP 80
58167: PPUSH
58168: LD_VAR 0 1
58172: PPUSH
58173: EMPTY
58174: PPUSH
58175: CALL_OW 1
58179: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58180: LD_ADDR_EXP 81
58184: PUSH
58185: LD_EXP 81
58189: PPUSH
58190: LD_VAR 0 1
58194: PPUSH
58195: EMPTY
58196: PPUSH
58197: CALL_OW 1
58201: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58202: LD_ADDR_EXP 82
58206: PUSH
58207: LD_EXP 82
58211: PPUSH
58212: LD_VAR 0 1
58216: PPUSH
58217: EMPTY
58218: PPUSH
58219: CALL_OW 1
58223: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58224: LD_ADDR_EXP 83
58228: PUSH
58229: LD_EXP 83
58233: PPUSH
58234: LD_VAR 0 1
58238: PPUSH
58239: EMPTY
58240: PPUSH
58241: CALL_OW 1
58245: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58246: LD_ADDR_EXP 84
58250: PUSH
58251: LD_EXP 84
58255: PPUSH
58256: LD_VAR 0 1
58260: PPUSH
58261: EMPTY
58262: PPUSH
58263: CALL_OW 1
58267: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58268: LD_ADDR_EXP 86
58272: PUSH
58273: LD_EXP 86
58277: PPUSH
58278: LD_VAR 0 1
58282: PPUSH
58283: EMPTY
58284: PPUSH
58285: CALL_OW 1
58289: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58290: LD_ADDR_EXP 88
58294: PUSH
58295: LD_EXP 88
58299: PPUSH
58300: LD_VAR 0 1
58304: PPUSH
58305: EMPTY
58306: PPUSH
58307: CALL_OW 1
58311: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58312: LD_ADDR_EXP 89
58316: PUSH
58317: LD_EXP 89
58321: PPUSH
58322: LD_VAR 0 1
58326: PPUSH
58327: EMPTY
58328: PPUSH
58329: CALL_OW 1
58333: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58334: LD_ADDR_EXP 90
58338: PUSH
58339: LD_EXP 90
58343: PPUSH
58344: LD_VAR 0 1
58348: PPUSH
58349: EMPTY
58350: PPUSH
58351: CALL_OW 1
58355: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58356: LD_ADDR_EXP 91
58360: PUSH
58361: LD_EXP 91
58365: PPUSH
58366: LD_VAR 0 1
58370: PPUSH
58371: EMPTY
58372: PPUSH
58373: CALL_OW 1
58377: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58378: LD_ADDR_EXP 92
58382: PUSH
58383: LD_EXP 92
58387: PPUSH
58388: LD_VAR 0 1
58392: PPUSH
58393: EMPTY
58394: PPUSH
58395: CALL_OW 1
58399: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58400: LD_ADDR_EXP 93
58404: PUSH
58405: LD_EXP 93
58409: PPUSH
58410: LD_VAR 0 1
58414: PPUSH
58415: EMPTY
58416: PPUSH
58417: CALL_OW 1
58421: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58422: LD_ADDR_EXP 94
58426: PUSH
58427: LD_EXP 94
58431: PPUSH
58432: LD_VAR 0 1
58436: PPUSH
58437: EMPTY
58438: PPUSH
58439: CALL_OW 1
58443: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58444: LD_ADDR_EXP 95
58448: PUSH
58449: LD_EXP 95
58453: PPUSH
58454: LD_VAR 0 1
58458: PPUSH
58459: EMPTY
58460: PPUSH
58461: CALL_OW 1
58465: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58466: LD_ADDR_EXP 96
58470: PUSH
58471: LD_EXP 96
58475: PPUSH
58476: LD_VAR 0 1
58480: PPUSH
58481: EMPTY
58482: PPUSH
58483: CALL_OW 1
58487: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58488: LD_ADDR_EXP 97
58492: PUSH
58493: LD_EXP 97
58497: PPUSH
58498: LD_VAR 0 1
58502: PPUSH
58503: EMPTY
58504: PPUSH
58505: CALL_OW 1
58509: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58510: LD_ADDR_EXP 98
58514: PUSH
58515: LD_EXP 98
58519: PPUSH
58520: LD_VAR 0 1
58524: PPUSH
58525: EMPTY
58526: PPUSH
58527: CALL_OW 1
58531: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58532: LD_ADDR_EXP 99
58536: PUSH
58537: LD_EXP 99
58541: PPUSH
58542: LD_VAR 0 1
58546: PPUSH
58547: EMPTY
58548: PPUSH
58549: CALL_OW 1
58553: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58554: LD_ADDR_EXP 100
58558: PUSH
58559: LD_EXP 100
58563: PPUSH
58564: LD_VAR 0 1
58568: PPUSH
58569: EMPTY
58570: PPUSH
58571: CALL_OW 1
58575: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58576: LD_ADDR_EXP 101
58580: PUSH
58581: LD_EXP 101
58585: PPUSH
58586: LD_VAR 0 1
58590: PPUSH
58591: LD_INT 0
58593: PPUSH
58594: CALL_OW 1
58598: ST_TO_ADDR
// end ;
58599: LD_VAR 0 2
58603: RET
// export function MC_Add ( side , units ) ; var base ; begin
58604: LD_INT 0
58606: PPUSH
58607: PPUSH
// base := mc_bases + 1 ;
58608: LD_ADDR_VAR 0 4
58612: PUSH
58613: LD_EXP 59
58617: PUSH
58618: LD_INT 1
58620: PLUS
58621: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
58622: LD_ADDR_EXP 85
58626: PUSH
58627: LD_EXP 85
58631: PPUSH
58632: LD_VAR 0 4
58636: PPUSH
58637: LD_VAR 0 1
58641: PPUSH
58642: CALL_OW 1
58646: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
58647: LD_ADDR_EXP 59
58651: PUSH
58652: LD_EXP 59
58656: PPUSH
58657: LD_VAR 0 4
58661: PPUSH
58662: LD_VAR 0 2
58666: PPUSH
58667: CALL_OW 1
58671: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
58672: LD_ADDR_EXP 60
58676: PUSH
58677: LD_EXP 60
58681: PPUSH
58682: LD_VAR 0 4
58686: PPUSH
58687: EMPTY
58688: PPUSH
58689: CALL_OW 1
58693: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
58694: LD_ADDR_EXP 61
58698: PUSH
58699: LD_EXP 61
58703: PPUSH
58704: LD_VAR 0 4
58708: PPUSH
58709: EMPTY
58710: PPUSH
58711: CALL_OW 1
58715: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
58716: LD_ADDR_EXP 62
58720: PUSH
58721: LD_EXP 62
58725: PPUSH
58726: LD_VAR 0 4
58730: PPUSH
58731: EMPTY
58732: PPUSH
58733: CALL_OW 1
58737: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
58738: LD_ADDR_EXP 63
58742: PUSH
58743: LD_EXP 63
58747: PPUSH
58748: LD_VAR 0 4
58752: PPUSH
58753: EMPTY
58754: PPUSH
58755: CALL_OW 1
58759: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
58760: LD_ADDR_EXP 64
58764: PUSH
58765: LD_EXP 64
58769: PPUSH
58770: LD_VAR 0 4
58774: PPUSH
58775: EMPTY
58776: PPUSH
58777: CALL_OW 1
58781: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
58782: LD_ADDR_EXP 65
58786: PUSH
58787: LD_EXP 65
58791: PPUSH
58792: LD_VAR 0 4
58796: PPUSH
58797: EMPTY
58798: PPUSH
58799: CALL_OW 1
58803: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
58804: LD_ADDR_EXP 66
58808: PUSH
58809: LD_EXP 66
58813: PPUSH
58814: LD_VAR 0 4
58818: PPUSH
58819: EMPTY
58820: PPUSH
58821: CALL_OW 1
58825: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
58826: LD_ADDR_EXP 67
58830: PUSH
58831: LD_EXP 67
58835: PPUSH
58836: LD_VAR 0 4
58840: PPUSH
58841: EMPTY
58842: PPUSH
58843: CALL_OW 1
58847: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58848: LD_ADDR_EXP 68
58852: PUSH
58853: LD_EXP 68
58857: PPUSH
58858: LD_VAR 0 4
58862: PPUSH
58863: EMPTY
58864: PPUSH
58865: CALL_OW 1
58869: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58870: LD_ADDR_EXP 69
58874: PUSH
58875: LD_EXP 69
58879: PPUSH
58880: LD_VAR 0 4
58884: PPUSH
58885: EMPTY
58886: PPUSH
58887: CALL_OW 1
58891: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58892: LD_ADDR_EXP 70
58896: PUSH
58897: LD_EXP 70
58901: PPUSH
58902: LD_VAR 0 4
58906: PPUSH
58907: LD_INT 0
58909: PPUSH
58910: CALL_OW 1
58914: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58915: LD_ADDR_EXP 71
58919: PUSH
58920: LD_EXP 71
58924: PPUSH
58925: LD_VAR 0 4
58929: PPUSH
58930: EMPTY
58931: PPUSH
58932: CALL_OW 1
58936: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
58937: LD_ADDR_EXP 72
58941: PUSH
58942: LD_EXP 72
58946: PPUSH
58947: LD_VAR 0 4
58951: PPUSH
58952: EMPTY
58953: PPUSH
58954: CALL_OW 1
58958: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58959: LD_ADDR_EXP 73
58963: PUSH
58964: LD_EXP 73
58968: PPUSH
58969: LD_VAR 0 4
58973: PPUSH
58974: EMPTY
58975: PPUSH
58976: CALL_OW 1
58980: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58981: LD_ADDR_EXP 74
58985: PUSH
58986: LD_EXP 74
58990: PPUSH
58991: LD_VAR 0 4
58995: PPUSH
58996: EMPTY
58997: PPUSH
58998: CALL_OW 1
59002: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
59003: LD_ADDR_EXP 75
59007: PUSH
59008: LD_EXP 75
59012: PPUSH
59013: LD_VAR 0 4
59017: PPUSH
59018: EMPTY
59019: PPUSH
59020: CALL_OW 1
59024: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
59025: LD_ADDR_EXP 76
59029: PUSH
59030: LD_EXP 76
59034: PPUSH
59035: LD_VAR 0 4
59039: PPUSH
59040: EMPTY
59041: PPUSH
59042: CALL_OW 1
59046: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
59047: LD_ADDR_EXP 77
59051: PUSH
59052: LD_EXP 77
59056: PPUSH
59057: LD_VAR 0 4
59061: PPUSH
59062: EMPTY
59063: PPUSH
59064: CALL_OW 1
59068: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
59069: LD_ADDR_EXP 78
59073: PUSH
59074: LD_EXP 78
59078: PPUSH
59079: LD_VAR 0 4
59083: PPUSH
59084: EMPTY
59085: PPUSH
59086: CALL_OW 1
59090: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
59091: LD_ADDR_EXP 79
59095: PUSH
59096: LD_EXP 79
59100: PPUSH
59101: LD_VAR 0 4
59105: PPUSH
59106: EMPTY
59107: PPUSH
59108: CALL_OW 1
59112: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
59113: LD_ADDR_EXP 80
59117: PUSH
59118: LD_EXP 80
59122: PPUSH
59123: LD_VAR 0 4
59127: PPUSH
59128: EMPTY
59129: PPUSH
59130: CALL_OW 1
59134: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
59135: LD_ADDR_EXP 81
59139: PUSH
59140: LD_EXP 81
59144: PPUSH
59145: LD_VAR 0 4
59149: PPUSH
59150: EMPTY
59151: PPUSH
59152: CALL_OW 1
59156: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
59157: LD_ADDR_EXP 82
59161: PUSH
59162: LD_EXP 82
59166: PPUSH
59167: LD_VAR 0 4
59171: PPUSH
59172: EMPTY
59173: PPUSH
59174: CALL_OW 1
59178: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
59179: LD_ADDR_EXP 83
59183: PUSH
59184: LD_EXP 83
59188: PPUSH
59189: LD_VAR 0 4
59193: PPUSH
59194: EMPTY
59195: PPUSH
59196: CALL_OW 1
59200: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
59201: LD_ADDR_EXP 84
59205: PUSH
59206: LD_EXP 84
59210: PPUSH
59211: LD_VAR 0 4
59215: PPUSH
59216: EMPTY
59217: PPUSH
59218: CALL_OW 1
59222: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
59223: LD_ADDR_EXP 86
59227: PUSH
59228: LD_EXP 86
59232: PPUSH
59233: LD_VAR 0 4
59237: PPUSH
59238: EMPTY
59239: PPUSH
59240: CALL_OW 1
59244: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
59245: LD_ADDR_EXP 88
59249: PUSH
59250: LD_EXP 88
59254: PPUSH
59255: LD_VAR 0 4
59259: PPUSH
59260: EMPTY
59261: PPUSH
59262: CALL_OW 1
59266: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
59267: LD_ADDR_EXP 89
59271: PUSH
59272: LD_EXP 89
59276: PPUSH
59277: LD_VAR 0 4
59281: PPUSH
59282: EMPTY
59283: PPUSH
59284: CALL_OW 1
59288: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
59289: LD_ADDR_EXP 90
59293: PUSH
59294: LD_EXP 90
59298: PPUSH
59299: LD_VAR 0 4
59303: PPUSH
59304: EMPTY
59305: PPUSH
59306: CALL_OW 1
59310: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
59311: LD_ADDR_EXP 91
59315: PUSH
59316: LD_EXP 91
59320: PPUSH
59321: LD_VAR 0 4
59325: PPUSH
59326: EMPTY
59327: PPUSH
59328: CALL_OW 1
59332: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
59333: LD_ADDR_EXP 92
59337: PUSH
59338: LD_EXP 92
59342: PPUSH
59343: LD_VAR 0 4
59347: PPUSH
59348: EMPTY
59349: PPUSH
59350: CALL_OW 1
59354: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
59355: LD_ADDR_EXP 93
59359: PUSH
59360: LD_EXP 93
59364: PPUSH
59365: LD_VAR 0 4
59369: PPUSH
59370: EMPTY
59371: PPUSH
59372: CALL_OW 1
59376: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
59377: LD_ADDR_EXP 94
59381: PUSH
59382: LD_EXP 94
59386: PPUSH
59387: LD_VAR 0 4
59391: PPUSH
59392: EMPTY
59393: PPUSH
59394: CALL_OW 1
59398: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
59399: LD_ADDR_EXP 95
59403: PUSH
59404: LD_EXP 95
59408: PPUSH
59409: LD_VAR 0 4
59413: PPUSH
59414: EMPTY
59415: PPUSH
59416: CALL_OW 1
59420: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
59421: LD_ADDR_EXP 96
59425: PUSH
59426: LD_EXP 96
59430: PPUSH
59431: LD_VAR 0 4
59435: PPUSH
59436: EMPTY
59437: PPUSH
59438: CALL_OW 1
59442: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
59443: LD_ADDR_EXP 97
59447: PUSH
59448: LD_EXP 97
59452: PPUSH
59453: LD_VAR 0 4
59457: PPUSH
59458: EMPTY
59459: PPUSH
59460: CALL_OW 1
59464: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
59465: LD_ADDR_EXP 98
59469: PUSH
59470: LD_EXP 98
59474: PPUSH
59475: LD_VAR 0 4
59479: PPUSH
59480: EMPTY
59481: PPUSH
59482: CALL_OW 1
59486: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
59487: LD_ADDR_EXP 99
59491: PUSH
59492: LD_EXP 99
59496: PPUSH
59497: LD_VAR 0 4
59501: PPUSH
59502: EMPTY
59503: PPUSH
59504: CALL_OW 1
59508: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
59509: LD_ADDR_EXP 100
59513: PUSH
59514: LD_EXP 100
59518: PPUSH
59519: LD_VAR 0 4
59523: PPUSH
59524: EMPTY
59525: PPUSH
59526: CALL_OW 1
59530: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
59531: LD_ADDR_EXP 101
59535: PUSH
59536: LD_EXP 101
59540: PPUSH
59541: LD_VAR 0 4
59545: PPUSH
59546: LD_INT 0
59548: PPUSH
59549: CALL_OW 1
59553: ST_TO_ADDR
// result := base ;
59554: LD_ADDR_VAR 0 3
59558: PUSH
59559: LD_VAR 0 4
59563: ST_TO_ADDR
// end ;
59564: LD_VAR 0 3
59568: RET
// export function MC_Start ( ) ; var i ; begin
59569: LD_INT 0
59571: PPUSH
59572: PPUSH
// for i = 1 to mc_bases do
59573: LD_ADDR_VAR 0 2
59577: PUSH
59578: DOUBLE
59579: LD_INT 1
59581: DEC
59582: ST_TO_ADDR
59583: LD_EXP 59
59587: PUSH
59588: FOR_TO
59589: IFFALSE 60666
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
59591: LD_ADDR_EXP 59
59595: PUSH
59596: LD_EXP 59
59600: PPUSH
59601: LD_VAR 0 2
59605: PPUSH
59606: LD_EXP 59
59610: PUSH
59611: LD_VAR 0 2
59615: ARRAY
59616: PUSH
59617: LD_INT 0
59619: DIFF
59620: PPUSH
59621: CALL_OW 1
59625: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
59626: LD_ADDR_EXP 60
59630: PUSH
59631: LD_EXP 60
59635: PPUSH
59636: LD_VAR 0 2
59640: PPUSH
59641: EMPTY
59642: PPUSH
59643: CALL_OW 1
59647: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59648: LD_ADDR_EXP 61
59652: PUSH
59653: LD_EXP 61
59657: PPUSH
59658: LD_VAR 0 2
59662: PPUSH
59663: EMPTY
59664: PPUSH
59665: CALL_OW 1
59669: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
59670: LD_ADDR_EXP 62
59674: PUSH
59675: LD_EXP 62
59679: PPUSH
59680: LD_VAR 0 2
59684: PPUSH
59685: EMPTY
59686: PPUSH
59687: CALL_OW 1
59691: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
59692: LD_ADDR_EXP 63
59696: PUSH
59697: LD_EXP 63
59701: PPUSH
59702: LD_VAR 0 2
59706: PPUSH
59707: EMPTY
59708: PUSH
59709: EMPTY
59710: PUSH
59711: EMPTY
59712: LIST
59713: LIST
59714: PPUSH
59715: CALL_OW 1
59719: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
59720: LD_ADDR_EXP 64
59724: PUSH
59725: LD_EXP 64
59729: PPUSH
59730: LD_VAR 0 2
59734: PPUSH
59735: EMPTY
59736: PPUSH
59737: CALL_OW 1
59741: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
59742: LD_ADDR_EXP 91
59746: PUSH
59747: LD_EXP 91
59751: PPUSH
59752: LD_VAR 0 2
59756: PPUSH
59757: EMPTY
59758: PPUSH
59759: CALL_OW 1
59763: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
59764: LD_ADDR_EXP 65
59768: PUSH
59769: LD_EXP 65
59773: PPUSH
59774: LD_VAR 0 2
59778: PPUSH
59779: EMPTY
59780: PPUSH
59781: CALL_OW 1
59785: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
59786: LD_ADDR_EXP 66
59790: PUSH
59791: LD_EXP 66
59795: PPUSH
59796: LD_VAR 0 2
59800: PPUSH
59801: EMPTY
59802: PPUSH
59803: CALL_OW 1
59807: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
59808: LD_ADDR_EXP 67
59812: PUSH
59813: LD_EXP 67
59817: PPUSH
59818: LD_VAR 0 2
59822: PPUSH
59823: LD_EXP 59
59827: PUSH
59828: LD_VAR 0 2
59832: ARRAY
59833: PPUSH
59834: LD_INT 2
59836: PUSH
59837: LD_INT 30
59839: PUSH
59840: LD_INT 32
59842: PUSH
59843: EMPTY
59844: LIST
59845: LIST
59846: PUSH
59847: LD_INT 30
59849: PUSH
59850: LD_INT 33
59852: PUSH
59853: EMPTY
59854: LIST
59855: LIST
59856: PUSH
59857: EMPTY
59858: LIST
59859: LIST
59860: LIST
59861: PPUSH
59862: CALL_OW 72
59866: PPUSH
59867: CALL_OW 1
59871: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
59872: LD_ADDR_EXP 68
59876: PUSH
59877: LD_EXP 68
59881: PPUSH
59882: LD_VAR 0 2
59886: PPUSH
59887: LD_EXP 59
59891: PUSH
59892: LD_VAR 0 2
59896: ARRAY
59897: PPUSH
59898: LD_INT 2
59900: PUSH
59901: LD_INT 30
59903: PUSH
59904: LD_INT 32
59906: PUSH
59907: EMPTY
59908: LIST
59909: LIST
59910: PUSH
59911: LD_INT 30
59913: PUSH
59914: LD_INT 31
59916: PUSH
59917: EMPTY
59918: LIST
59919: LIST
59920: PUSH
59921: EMPTY
59922: LIST
59923: LIST
59924: LIST
59925: PUSH
59926: LD_INT 58
59928: PUSH
59929: EMPTY
59930: LIST
59931: PUSH
59932: EMPTY
59933: LIST
59934: LIST
59935: PPUSH
59936: CALL_OW 72
59940: PPUSH
59941: CALL_OW 1
59945: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
59946: LD_ADDR_EXP 69
59950: PUSH
59951: LD_EXP 69
59955: PPUSH
59956: LD_VAR 0 2
59960: PPUSH
59961: EMPTY
59962: PPUSH
59963: CALL_OW 1
59967: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
59968: LD_ADDR_EXP 73
59972: PUSH
59973: LD_EXP 73
59977: PPUSH
59978: LD_VAR 0 2
59982: PPUSH
59983: EMPTY
59984: PPUSH
59985: CALL_OW 1
59989: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
59990: LD_ADDR_EXP 72
59994: PUSH
59995: LD_EXP 72
59999: PPUSH
60000: LD_VAR 0 2
60004: PPUSH
60005: EMPTY
60006: PPUSH
60007: CALL_OW 1
60011: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
60012: LD_ADDR_EXP 74
60016: PUSH
60017: LD_EXP 74
60021: PPUSH
60022: LD_VAR 0 2
60026: PPUSH
60027: EMPTY
60028: PPUSH
60029: CALL_OW 1
60033: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
60034: LD_ADDR_EXP 75
60038: PUSH
60039: LD_EXP 75
60043: PPUSH
60044: LD_VAR 0 2
60048: PPUSH
60049: EMPTY
60050: PPUSH
60051: CALL_OW 1
60055: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
60056: LD_ADDR_EXP 76
60060: PUSH
60061: LD_EXP 76
60065: PPUSH
60066: LD_VAR 0 2
60070: PPUSH
60071: EMPTY
60072: PPUSH
60073: CALL_OW 1
60077: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
60078: LD_ADDR_EXP 77
60082: PUSH
60083: LD_EXP 77
60087: PPUSH
60088: LD_VAR 0 2
60092: PPUSH
60093: EMPTY
60094: PPUSH
60095: CALL_OW 1
60099: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
60100: LD_ADDR_EXP 78
60104: PUSH
60105: LD_EXP 78
60109: PPUSH
60110: LD_VAR 0 2
60114: PPUSH
60115: EMPTY
60116: PPUSH
60117: CALL_OW 1
60121: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
60122: LD_ADDR_EXP 79
60126: PUSH
60127: LD_EXP 79
60131: PPUSH
60132: LD_VAR 0 2
60136: PPUSH
60137: EMPTY
60138: PPUSH
60139: CALL_OW 1
60143: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
60144: LD_ADDR_EXP 80
60148: PUSH
60149: LD_EXP 80
60153: PPUSH
60154: LD_VAR 0 2
60158: PPUSH
60159: EMPTY
60160: PPUSH
60161: CALL_OW 1
60165: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
60166: LD_ADDR_EXP 81
60170: PUSH
60171: LD_EXP 81
60175: PPUSH
60176: LD_VAR 0 2
60180: PPUSH
60181: EMPTY
60182: PPUSH
60183: CALL_OW 1
60187: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
60188: LD_ADDR_EXP 70
60192: PUSH
60193: LD_EXP 70
60197: PPUSH
60198: LD_VAR 0 2
60202: PPUSH
60203: LD_INT 0
60205: PPUSH
60206: CALL_OW 1
60210: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
60211: LD_ADDR_EXP 83
60215: PUSH
60216: LD_EXP 83
60220: PPUSH
60221: LD_VAR 0 2
60225: PPUSH
60226: LD_INT 0
60228: PPUSH
60229: CALL_OW 1
60233: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
60234: LD_ADDR_EXP 71
60238: PUSH
60239: LD_EXP 71
60243: PPUSH
60244: LD_VAR 0 2
60248: PPUSH
60249: EMPTY
60250: PPUSH
60251: CALL_OW 1
60255: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
60256: LD_ADDR_EXP 82
60260: PUSH
60261: LD_EXP 82
60265: PPUSH
60266: LD_VAR 0 2
60270: PPUSH
60271: LD_INT 0
60273: PPUSH
60274: CALL_OW 1
60278: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
60279: LD_ADDR_EXP 84
60283: PUSH
60284: LD_EXP 84
60288: PPUSH
60289: LD_VAR 0 2
60293: PPUSH
60294: EMPTY
60295: PPUSH
60296: CALL_OW 1
60300: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
60301: LD_ADDR_EXP 87
60305: PUSH
60306: LD_EXP 87
60310: PPUSH
60311: LD_VAR 0 2
60315: PPUSH
60316: LD_INT 0
60318: PPUSH
60319: CALL_OW 1
60323: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
60324: LD_ADDR_EXP 88
60328: PUSH
60329: LD_EXP 88
60333: PPUSH
60334: LD_VAR 0 2
60338: PPUSH
60339: EMPTY
60340: PPUSH
60341: CALL_OW 1
60345: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60346: LD_ADDR_EXP 89
60350: PUSH
60351: LD_EXP 89
60355: PPUSH
60356: LD_VAR 0 2
60360: PPUSH
60361: EMPTY
60362: PPUSH
60363: CALL_OW 1
60367: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60368: LD_ADDR_EXP 90
60372: PUSH
60373: LD_EXP 90
60377: PPUSH
60378: LD_VAR 0 2
60382: PPUSH
60383: EMPTY
60384: PPUSH
60385: CALL_OW 1
60389: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
60390: LD_ADDR_EXP 92
60394: PUSH
60395: LD_EXP 92
60399: PPUSH
60400: LD_VAR 0 2
60404: PPUSH
60405: LD_EXP 59
60409: PUSH
60410: LD_VAR 0 2
60414: ARRAY
60415: PPUSH
60416: LD_INT 2
60418: PUSH
60419: LD_INT 30
60421: PUSH
60422: LD_INT 6
60424: PUSH
60425: EMPTY
60426: LIST
60427: LIST
60428: PUSH
60429: LD_INT 30
60431: PUSH
60432: LD_INT 7
60434: PUSH
60435: EMPTY
60436: LIST
60437: LIST
60438: PUSH
60439: LD_INT 30
60441: PUSH
60442: LD_INT 8
60444: PUSH
60445: EMPTY
60446: LIST
60447: LIST
60448: PUSH
60449: EMPTY
60450: LIST
60451: LIST
60452: LIST
60453: LIST
60454: PPUSH
60455: CALL_OW 72
60459: PPUSH
60460: CALL_OW 1
60464: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
60465: LD_ADDR_EXP 93
60469: PUSH
60470: LD_EXP 93
60474: PPUSH
60475: LD_VAR 0 2
60479: PPUSH
60480: EMPTY
60481: PPUSH
60482: CALL_OW 1
60486: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
60487: LD_ADDR_EXP 94
60491: PUSH
60492: LD_EXP 94
60496: PPUSH
60497: LD_VAR 0 2
60501: PPUSH
60502: EMPTY
60503: PPUSH
60504: CALL_OW 1
60508: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
60509: LD_ADDR_EXP 95
60513: PUSH
60514: LD_EXP 95
60518: PPUSH
60519: LD_VAR 0 2
60523: PPUSH
60524: EMPTY
60525: PPUSH
60526: CALL_OW 1
60530: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
60531: LD_ADDR_EXP 96
60535: PUSH
60536: LD_EXP 96
60540: PPUSH
60541: LD_VAR 0 2
60545: PPUSH
60546: EMPTY
60547: PPUSH
60548: CALL_OW 1
60552: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60553: LD_ADDR_EXP 97
60557: PUSH
60558: LD_EXP 97
60562: PPUSH
60563: LD_VAR 0 2
60567: PPUSH
60568: EMPTY
60569: PPUSH
60570: CALL_OW 1
60574: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
60575: LD_ADDR_EXP 98
60579: PUSH
60580: LD_EXP 98
60584: PPUSH
60585: LD_VAR 0 2
60589: PPUSH
60590: EMPTY
60591: PPUSH
60592: CALL_OW 1
60596: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
60597: LD_ADDR_EXP 99
60601: PUSH
60602: LD_EXP 99
60606: PPUSH
60607: LD_VAR 0 2
60611: PPUSH
60612: EMPTY
60613: PPUSH
60614: CALL_OW 1
60618: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
60619: LD_ADDR_EXP 100
60623: PUSH
60624: LD_EXP 100
60628: PPUSH
60629: LD_VAR 0 2
60633: PPUSH
60634: EMPTY
60635: PPUSH
60636: CALL_OW 1
60640: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
60641: LD_ADDR_EXP 101
60645: PUSH
60646: LD_EXP 101
60650: PPUSH
60651: LD_VAR 0 2
60655: PPUSH
60656: LD_INT 0
60658: PPUSH
60659: CALL_OW 1
60663: ST_TO_ADDR
// end ;
60664: GO 59588
60666: POP
60667: POP
// MC_InitSides ( ) ;
60668: CALL 60954 0 0
// MC_InitResearch ( ) ;
60672: CALL 60693 0 0
// CustomInitMacro ( ) ;
60676: CALL 181 0 0
// skirmish := true ;
60680: LD_ADDR_EXP 57
60684: PUSH
60685: LD_INT 1
60687: ST_TO_ADDR
// end ;
60688: LD_VAR 0 1
60692: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
60693: LD_INT 0
60695: PPUSH
60696: PPUSH
60697: PPUSH
60698: PPUSH
60699: PPUSH
60700: PPUSH
// if not mc_bases then
60701: LD_EXP 59
60705: NOT
60706: IFFALSE 60710
// exit ;
60708: GO 60949
// for i = 1 to 8 do
60710: LD_ADDR_VAR 0 2
60714: PUSH
60715: DOUBLE
60716: LD_INT 1
60718: DEC
60719: ST_TO_ADDR
60720: LD_INT 8
60722: PUSH
60723: FOR_TO
60724: IFFALSE 60750
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
60726: LD_ADDR_EXP 86
60730: PUSH
60731: LD_EXP 86
60735: PPUSH
60736: LD_VAR 0 2
60740: PPUSH
60741: EMPTY
60742: PPUSH
60743: CALL_OW 1
60747: ST_TO_ADDR
60748: GO 60723
60750: POP
60751: POP
// tmp := [ ] ;
60752: LD_ADDR_VAR 0 5
60756: PUSH
60757: EMPTY
60758: ST_TO_ADDR
// for i = 1 to mc_sides do
60759: LD_ADDR_VAR 0 2
60763: PUSH
60764: DOUBLE
60765: LD_INT 1
60767: DEC
60768: ST_TO_ADDR
60769: LD_EXP 85
60773: PUSH
60774: FOR_TO
60775: IFFALSE 60833
// if not mc_sides [ i ] in tmp then
60777: LD_EXP 85
60781: PUSH
60782: LD_VAR 0 2
60786: ARRAY
60787: PUSH
60788: LD_VAR 0 5
60792: IN
60793: NOT
60794: IFFALSE 60831
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
60796: LD_ADDR_VAR 0 5
60800: PUSH
60801: LD_VAR 0 5
60805: PPUSH
60806: LD_VAR 0 5
60810: PUSH
60811: LD_INT 1
60813: PLUS
60814: PPUSH
60815: LD_EXP 85
60819: PUSH
60820: LD_VAR 0 2
60824: ARRAY
60825: PPUSH
60826: CALL_OW 2
60830: ST_TO_ADDR
60831: GO 60774
60833: POP
60834: POP
// if not tmp then
60835: LD_VAR 0 5
60839: NOT
60840: IFFALSE 60844
// exit ;
60842: GO 60949
// for j in tmp do
60844: LD_ADDR_VAR 0 3
60848: PUSH
60849: LD_VAR 0 5
60853: PUSH
60854: FOR_IN
60855: IFFALSE 60947
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
60857: LD_ADDR_VAR 0 6
60861: PUSH
60862: LD_INT 22
60864: PUSH
60865: LD_VAR 0 3
60869: PUSH
60870: EMPTY
60871: LIST
60872: LIST
60873: PPUSH
60874: CALL_OW 69
60878: ST_TO_ADDR
// if not un then
60879: LD_VAR 0 6
60883: NOT
60884: IFFALSE 60888
// continue ;
60886: GO 60854
// nation := GetNation ( un [ 1 ] ) ;
60888: LD_ADDR_VAR 0 4
60892: PUSH
60893: LD_VAR 0 6
60897: PUSH
60898: LD_INT 1
60900: ARRAY
60901: PPUSH
60902: CALL_OW 248
60906: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
60907: LD_ADDR_EXP 86
60911: PUSH
60912: LD_EXP 86
60916: PPUSH
60917: LD_VAR 0 3
60921: PPUSH
60922: LD_VAR 0 3
60926: PPUSH
60927: LD_VAR 0 4
60931: PPUSH
60932: LD_INT 1
60934: PPUSH
60935: CALL 14355 0 3
60939: PPUSH
60940: CALL_OW 1
60944: ST_TO_ADDR
// end ;
60945: GO 60854
60947: POP
60948: POP
// end ;
60949: LD_VAR 0 1
60953: RET
// export function MC_InitSides ( ) ; var i ; begin
60954: LD_INT 0
60956: PPUSH
60957: PPUSH
// if not mc_bases then
60958: LD_EXP 59
60962: NOT
60963: IFFALSE 60967
// exit ;
60965: GO 61041
// for i = 1 to mc_bases do
60967: LD_ADDR_VAR 0 2
60971: PUSH
60972: DOUBLE
60973: LD_INT 1
60975: DEC
60976: ST_TO_ADDR
60977: LD_EXP 59
60981: PUSH
60982: FOR_TO
60983: IFFALSE 61039
// if mc_bases [ i ] then
60985: LD_EXP 59
60989: PUSH
60990: LD_VAR 0 2
60994: ARRAY
60995: IFFALSE 61037
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
60997: LD_ADDR_EXP 85
61001: PUSH
61002: LD_EXP 85
61006: PPUSH
61007: LD_VAR 0 2
61011: PPUSH
61012: LD_EXP 59
61016: PUSH
61017: LD_VAR 0 2
61021: ARRAY
61022: PUSH
61023: LD_INT 1
61025: ARRAY
61026: PPUSH
61027: CALL_OW 255
61031: PPUSH
61032: CALL_OW 1
61036: ST_TO_ADDR
61037: GO 60982
61039: POP
61040: POP
// end ;
61041: LD_VAR 0 1
61045: RET
// every 0 0$01 trigger skirmish do
61046: LD_EXP 57
61050: IFFALSE 61204
61052: GO 61054
61054: DISABLE
// begin enable ;
61055: ENABLE
// MC_CheckBuildings ( ) ;
61056: CALL 65702 0 0
// MC_CheckPeopleLife ( ) ;
61060: CALL 65827 0 0
// RaiseSailEvent ( 100 ) ;
61064: LD_INT 100
61066: PPUSH
61067: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
61071: LD_INT 103
61073: PPUSH
61074: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
61078: LD_INT 104
61080: PPUSH
61081: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
61085: LD_INT 105
61087: PPUSH
61088: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
61092: LD_INT 106
61094: PPUSH
61095: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
61099: LD_INT 107
61101: PPUSH
61102: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
61106: LD_INT 108
61108: PPUSH
61109: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
61113: LD_INT 109
61115: PPUSH
61116: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
61120: LD_INT 110
61122: PPUSH
61123: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
61127: LD_INT 111
61129: PPUSH
61130: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
61134: LD_INT 112
61136: PPUSH
61137: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
61141: LD_INT 113
61143: PPUSH
61144: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
61148: LD_INT 120
61150: PPUSH
61151: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
61155: LD_INT 121
61157: PPUSH
61158: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
61162: LD_INT 122
61164: PPUSH
61165: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
61169: LD_INT 123
61171: PPUSH
61172: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
61176: LD_INT 124
61178: PPUSH
61179: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
61183: LD_INT 125
61185: PPUSH
61186: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
61190: LD_INT 126
61192: PPUSH
61193: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
61197: LD_INT 200
61199: PPUSH
61200: CALL_OW 427
// end ;
61204: END
// on SailEvent ( event ) do begin if event < 100 then
61205: LD_VAR 0 1
61209: PUSH
61210: LD_INT 100
61212: LESS
61213: IFFALSE 61224
// CustomEvent ( event ) ;
61215: LD_VAR 0 1
61219: PPUSH
61220: CALL 13013 0 1
// if event = 100 then
61224: LD_VAR 0 1
61228: PUSH
61229: LD_INT 100
61231: EQUAL
61232: IFFALSE 61238
// MC_ClassManager ( ) ;
61234: CALL 61630 0 0
// if event = 101 then
61238: LD_VAR 0 1
61242: PUSH
61243: LD_INT 101
61245: EQUAL
61246: IFFALSE 61252
// MC_RepairBuildings ( ) ;
61248: CALL 66423 0 0
// if event = 102 then
61252: LD_VAR 0 1
61256: PUSH
61257: LD_INT 102
61259: EQUAL
61260: IFFALSE 61266
// MC_Heal ( ) ;
61262: CALL 67287 0 0
// if event = 103 then
61266: LD_VAR 0 1
61270: PUSH
61271: LD_INT 103
61273: EQUAL
61274: IFFALSE 61280
// MC_Build ( ) ;
61276: CALL 67709 0 0
// if event = 104 then
61280: LD_VAR 0 1
61284: PUSH
61285: LD_INT 104
61287: EQUAL
61288: IFFALSE 61294
// MC_TurretWeapon ( ) ;
61290: CALL 69322 0 0
// if event = 105 then
61294: LD_VAR 0 1
61298: PUSH
61299: LD_INT 105
61301: EQUAL
61302: IFFALSE 61308
// MC_BuildUpgrade ( ) ;
61304: CALL 68873 0 0
// if event = 106 then
61308: LD_VAR 0 1
61312: PUSH
61313: LD_INT 106
61315: EQUAL
61316: IFFALSE 61322
// MC_PlantMines ( ) ;
61318: CALL 69752 0 0
// if event = 107 then
61322: LD_VAR 0 1
61326: PUSH
61327: LD_INT 107
61329: EQUAL
61330: IFFALSE 61336
// MC_CollectCrates ( ) ;
61332: CALL 70550 0 0
// if event = 108 then
61336: LD_VAR 0 1
61340: PUSH
61341: LD_INT 108
61343: EQUAL
61344: IFFALSE 61350
// MC_LinkRemoteControl ( ) ;
61346: CALL 72326 0 0
// if event = 109 then
61350: LD_VAR 0 1
61354: PUSH
61355: LD_INT 109
61357: EQUAL
61358: IFFALSE 61364
// MC_ProduceVehicle ( ) ;
61360: CALL 72507 0 0
// if event = 110 then
61364: LD_VAR 0 1
61368: PUSH
61369: LD_INT 110
61371: EQUAL
61372: IFFALSE 61378
// MC_SendAttack ( ) ;
61374: CALL 72973 0 0
// if event = 111 then
61378: LD_VAR 0 1
61382: PUSH
61383: LD_INT 111
61385: EQUAL
61386: IFFALSE 61392
// MC_Defend ( ) ;
61388: CALL 73081 0 0
// if event = 112 then
61392: LD_VAR 0 1
61396: PUSH
61397: LD_INT 112
61399: EQUAL
61400: IFFALSE 61406
// MC_Research ( ) ;
61402: CALL 73686 0 0
// if event = 113 then
61406: LD_VAR 0 1
61410: PUSH
61411: LD_INT 113
61413: EQUAL
61414: IFFALSE 61420
// MC_MinesTrigger ( ) ;
61416: CALL 74800 0 0
// if event = 120 then
61420: LD_VAR 0 1
61424: PUSH
61425: LD_INT 120
61427: EQUAL
61428: IFFALSE 61434
// MC_RepairVehicle ( ) ;
61430: CALL 74899 0 0
// if event = 121 then
61434: LD_VAR 0 1
61438: PUSH
61439: LD_INT 121
61441: EQUAL
61442: IFFALSE 61448
// MC_TameApe ( ) ;
61444: CALL 75629 0 0
// if event = 122 then
61448: LD_VAR 0 1
61452: PUSH
61453: LD_INT 122
61455: EQUAL
61456: IFFALSE 61462
// MC_ChangeApeClass ( ) ;
61458: CALL 76458 0 0
// if event = 123 then
61462: LD_VAR 0 1
61466: PUSH
61467: LD_INT 123
61469: EQUAL
61470: IFFALSE 61476
// MC_Bazooka ( ) ;
61472: CALL 77108 0 0
// if event = 124 then
61476: LD_VAR 0 1
61480: PUSH
61481: LD_INT 124
61483: EQUAL
61484: IFFALSE 61490
// MC_TeleportExit ( ) ;
61486: CALL 77306 0 0
// if event = 125 then
61490: LD_VAR 0 1
61494: PUSH
61495: LD_INT 125
61497: EQUAL
61498: IFFALSE 61504
// MC_Deposits ( ) ;
61500: CALL 77953 0 0
// if event = 126 then
61504: LD_VAR 0 1
61508: PUSH
61509: LD_INT 126
61511: EQUAL
61512: IFFALSE 61518
// MC_RemoteDriver ( ) ;
61514: CALL 78578 0 0
// if event = 200 then
61518: LD_VAR 0 1
61522: PUSH
61523: LD_INT 200
61525: EQUAL
61526: IFFALSE 61532
// MC_Idle ( ) ;
61528: CALL 80527 0 0
// end ;
61532: PPOPN 1
61534: END
// export function MC_Reset ( base , tag ) ; var i ; begin
61535: LD_INT 0
61537: PPUSH
61538: PPUSH
// if not mc_bases [ base ] or not tag then
61539: LD_EXP 59
61543: PUSH
61544: LD_VAR 0 1
61548: ARRAY
61549: NOT
61550: PUSH
61551: LD_VAR 0 2
61555: NOT
61556: OR
61557: IFFALSE 61561
// exit ;
61559: GO 61625
// for i in mc_bases [ base ] union mc_ape [ base ] do
61561: LD_ADDR_VAR 0 4
61565: PUSH
61566: LD_EXP 59
61570: PUSH
61571: LD_VAR 0 1
61575: ARRAY
61576: PUSH
61577: LD_EXP 88
61581: PUSH
61582: LD_VAR 0 1
61586: ARRAY
61587: UNION
61588: PUSH
61589: FOR_IN
61590: IFFALSE 61623
// if GetTag ( i ) = tag then
61592: LD_VAR 0 4
61596: PPUSH
61597: CALL_OW 110
61601: PUSH
61602: LD_VAR 0 2
61606: EQUAL
61607: IFFALSE 61621
// SetTag ( i , 0 ) ;
61609: LD_VAR 0 4
61613: PPUSH
61614: LD_INT 0
61616: PPUSH
61617: CALL_OW 109
61621: GO 61589
61623: POP
61624: POP
// end ;
61625: LD_VAR 0 3
61629: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
61630: LD_INT 0
61632: PPUSH
61633: PPUSH
61634: PPUSH
61635: PPUSH
61636: PPUSH
61637: PPUSH
61638: PPUSH
61639: PPUSH
// if not mc_bases then
61640: LD_EXP 59
61644: NOT
61645: IFFALSE 61649
// exit ;
61647: GO 62107
// for i = 1 to mc_bases do
61649: LD_ADDR_VAR 0 2
61653: PUSH
61654: DOUBLE
61655: LD_INT 1
61657: DEC
61658: ST_TO_ADDR
61659: LD_EXP 59
61663: PUSH
61664: FOR_TO
61665: IFFALSE 62105
// begin tmp := MC_ClassCheckReq ( i ) ;
61667: LD_ADDR_VAR 0 4
61671: PUSH
61672: LD_VAR 0 2
61676: PPUSH
61677: CALL 62112 0 1
61681: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
61682: LD_ADDR_EXP 100
61686: PUSH
61687: LD_EXP 100
61691: PPUSH
61692: LD_VAR 0 2
61696: PPUSH
61697: LD_VAR 0 4
61701: PPUSH
61702: CALL_OW 1
61706: ST_TO_ADDR
// if not tmp then
61707: LD_VAR 0 4
61711: NOT
61712: IFFALSE 61716
// continue ;
61714: GO 61664
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
61716: LD_ADDR_VAR 0 6
61720: PUSH
61721: LD_EXP 59
61725: PUSH
61726: LD_VAR 0 2
61730: ARRAY
61731: PPUSH
61732: LD_INT 2
61734: PUSH
61735: LD_INT 30
61737: PUSH
61738: LD_INT 4
61740: PUSH
61741: EMPTY
61742: LIST
61743: LIST
61744: PUSH
61745: LD_INT 30
61747: PUSH
61748: LD_INT 5
61750: PUSH
61751: EMPTY
61752: LIST
61753: LIST
61754: PUSH
61755: EMPTY
61756: LIST
61757: LIST
61758: LIST
61759: PPUSH
61760: CALL_OW 72
61764: PUSH
61765: LD_EXP 59
61769: PUSH
61770: LD_VAR 0 2
61774: ARRAY
61775: PPUSH
61776: LD_INT 2
61778: PUSH
61779: LD_INT 30
61781: PUSH
61782: LD_INT 0
61784: PUSH
61785: EMPTY
61786: LIST
61787: LIST
61788: PUSH
61789: LD_INT 30
61791: PUSH
61792: LD_INT 1
61794: PUSH
61795: EMPTY
61796: LIST
61797: LIST
61798: PUSH
61799: EMPTY
61800: LIST
61801: LIST
61802: LIST
61803: PPUSH
61804: CALL_OW 72
61808: PUSH
61809: LD_EXP 59
61813: PUSH
61814: LD_VAR 0 2
61818: ARRAY
61819: PPUSH
61820: LD_INT 30
61822: PUSH
61823: LD_INT 3
61825: PUSH
61826: EMPTY
61827: LIST
61828: LIST
61829: PPUSH
61830: CALL_OW 72
61834: PUSH
61835: LD_EXP 59
61839: PUSH
61840: LD_VAR 0 2
61844: ARRAY
61845: PPUSH
61846: LD_INT 2
61848: PUSH
61849: LD_INT 30
61851: PUSH
61852: LD_INT 6
61854: PUSH
61855: EMPTY
61856: LIST
61857: LIST
61858: PUSH
61859: LD_INT 30
61861: PUSH
61862: LD_INT 7
61864: PUSH
61865: EMPTY
61866: LIST
61867: LIST
61868: PUSH
61869: LD_INT 30
61871: PUSH
61872: LD_INT 8
61874: PUSH
61875: EMPTY
61876: LIST
61877: LIST
61878: PUSH
61879: EMPTY
61880: LIST
61881: LIST
61882: LIST
61883: LIST
61884: PPUSH
61885: CALL_OW 72
61889: PUSH
61890: EMPTY
61891: LIST
61892: LIST
61893: LIST
61894: LIST
61895: ST_TO_ADDR
// for j = 1 to 4 do
61896: LD_ADDR_VAR 0 3
61900: PUSH
61901: DOUBLE
61902: LD_INT 1
61904: DEC
61905: ST_TO_ADDR
61906: LD_INT 4
61908: PUSH
61909: FOR_TO
61910: IFFALSE 62101
// begin if not tmp [ j ] then
61912: LD_VAR 0 4
61916: PUSH
61917: LD_VAR 0 3
61921: ARRAY
61922: NOT
61923: IFFALSE 61927
// continue ;
61925: GO 61909
// for p in tmp [ j ] do
61927: LD_ADDR_VAR 0 5
61931: PUSH
61932: LD_VAR 0 4
61936: PUSH
61937: LD_VAR 0 3
61941: ARRAY
61942: PUSH
61943: FOR_IN
61944: IFFALSE 62097
// begin if not b [ j ] then
61946: LD_VAR 0 6
61950: PUSH
61951: LD_VAR 0 3
61955: ARRAY
61956: NOT
61957: IFFALSE 61961
// break ;
61959: GO 62097
// e := 0 ;
61961: LD_ADDR_VAR 0 7
61965: PUSH
61966: LD_INT 0
61968: ST_TO_ADDR
// for k in b [ j ] do
61969: LD_ADDR_VAR 0 8
61973: PUSH
61974: LD_VAR 0 6
61978: PUSH
61979: LD_VAR 0 3
61983: ARRAY
61984: PUSH
61985: FOR_IN
61986: IFFALSE 62013
// if IsNotFull ( k ) then
61988: LD_VAR 0 8
61992: PPUSH
61993: CALL 18795 0 1
61997: IFFALSE 62011
// begin e := k ;
61999: LD_ADDR_VAR 0 7
62003: PUSH
62004: LD_VAR 0 8
62008: ST_TO_ADDR
// break ;
62009: GO 62013
// end ;
62011: GO 61985
62013: POP
62014: POP
// if e and not UnitGoingToBuilding ( p , e ) then
62015: LD_VAR 0 7
62019: PUSH
62020: LD_VAR 0 5
62024: PPUSH
62025: LD_VAR 0 7
62029: PPUSH
62030: CALL 55917 0 2
62034: NOT
62035: AND
62036: IFFALSE 62095
// begin if IsInUnit ( p ) then
62038: LD_VAR 0 5
62042: PPUSH
62043: CALL_OW 310
62047: IFFALSE 62058
// ComExitBuilding ( p ) ;
62049: LD_VAR 0 5
62053: PPUSH
62054: CALL_OW 122
// ComEnterUnit ( p , e ) ;
62058: LD_VAR 0 5
62062: PPUSH
62063: LD_VAR 0 7
62067: PPUSH
62068: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
62072: LD_VAR 0 5
62076: PPUSH
62077: LD_VAR 0 3
62081: PPUSH
62082: CALL_OW 183
// AddComExitBuilding ( p ) ;
62086: LD_VAR 0 5
62090: PPUSH
62091: CALL_OW 182
// end ; end ;
62095: GO 61943
62097: POP
62098: POP
// end ;
62099: GO 61909
62101: POP
62102: POP
// end ;
62103: GO 61664
62105: POP
62106: POP
// end ;
62107: LD_VAR 0 1
62111: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
62112: LD_INT 0
62114: PPUSH
62115: PPUSH
62116: PPUSH
62117: PPUSH
62118: PPUSH
62119: PPUSH
62120: PPUSH
62121: PPUSH
62122: PPUSH
62123: PPUSH
62124: PPUSH
62125: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62126: LD_VAR 0 1
62130: NOT
62131: PUSH
62132: LD_EXP 59
62136: PUSH
62137: LD_VAR 0 1
62141: ARRAY
62142: NOT
62143: OR
62144: PUSH
62145: LD_EXP 59
62149: PUSH
62150: LD_VAR 0 1
62154: ARRAY
62155: PPUSH
62156: LD_INT 2
62158: PUSH
62159: LD_INT 30
62161: PUSH
62162: LD_INT 0
62164: PUSH
62165: EMPTY
62166: LIST
62167: LIST
62168: PUSH
62169: LD_INT 30
62171: PUSH
62172: LD_INT 1
62174: PUSH
62175: EMPTY
62176: LIST
62177: LIST
62178: PUSH
62179: EMPTY
62180: LIST
62181: LIST
62182: LIST
62183: PPUSH
62184: CALL_OW 72
62188: NOT
62189: OR
62190: IFFALSE 62194
// exit ;
62192: GO 65697
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62194: LD_ADDR_VAR 0 4
62198: PUSH
62199: LD_EXP 59
62203: PUSH
62204: LD_VAR 0 1
62208: ARRAY
62209: PPUSH
62210: LD_INT 2
62212: PUSH
62213: LD_INT 25
62215: PUSH
62216: LD_INT 1
62218: PUSH
62219: EMPTY
62220: LIST
62221: LIST
62222: PUSH
62223: LD_INT 25
62225: PUSH
62226: LD_INT 2
62228: PUSH
62229: EMPTY
62230: LIST
62231: LIST
62232: PUSH
62233: LD_INT 25
62235: PUSH
62236: LD_INT 3
62238: PUSH
62239: EMPTY
62240: LIST
62241: LIST
62242: PUSH
62243: LD_INT 25
62245: PUSH
62246: LD_INT 4
62248: PUSH
62249: EMPTY
62250: LIST
62251: LIST
62252: PUSH
62253: LD_INT 25
62255: PUSH
62256: LD_INT 5
62258: PUSH
62259: EMPTY
62260: LIST
62261: LIST
62262: PUSH
62263: LD_INT 25
62265: PUSH
62266: LD_INT 8
62268: PUSH
62269: EMPTY
62270: LIST
62271: LIST
62272: PUSH
62273: LD_INT 25
62275: PUSH
62276: LD_INT 9
62278: PUSH
62279: EMPTY
62280: LIST
62281: LIST
62282: PUSH
62283: EMPTY
62284: LIST
62285: LIST
62286: LIST
62287: LIST
62288: LIST
62289: LIST
62290: LIST
62291: LIST
62292: PPUSH
62293: CALL_OW 72
62297: ST_TO_ADDR
// if not tmp then
62298: LD_VAR 0 4
62302: NOT
62303: IFFALSE 62307
// exit ;
62305: GO 65697
// for i in tmp do
62307: LD_ADDR_VAR 0 3
62311: PUSH
62312: LD_VAR 0 4
62316: PUSH
62317: FOR_IN
62318: IFFALSE 62349
// if GetTag ( i ) then
62320: LD_VAR 0 3
62324: PPUSH
62325: CALL_OW 110
62329: IFFALSE 62347
// tmp := tmp diff i ;
62331: LD_ADDR_VAR 0 4
62335: PUSH
62336: LD_VAR 0 4
62340: PUSH
62341: LD_VAR 0 3
62345: DIFF
62346: ST_TO_ADDR
62347: GO 62317
62349: POP
62350: POP
// if not tmp then
62351: LD_VAR 0 4
62355: NOT
62356: IFFALSE 62360
// exit ;
62358: GO 65697
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62360: LD_ADDR_VAR 0 5
62364: PUSH
62365: LD_EXP 59
62369: PUSH
62370: LD_VAR 0 1
62374: ARRAY
62375: PPUSH
62376: LD_INT 2
62378: PUSH
62379: LD_INT 25
62381: PUSH
62382: LD_INT 1
62384: PUSH
62385: EMPTY
62386: LIST
62387: LIST
62388: PUSH
62389: LD_INT 25
62391: PUSH
62392: LD_INT 5
62394: PUSH
62395: EMPTY
62396: LIST
62397: LIST
62398: PUSH
62399: LD_INT 25
62401: PUSH
62402: LD_INT 8
62404: PUSH
62405: EMPTY
62406: LIST
62407: LIST
62408: PUSH
62409: LD_INT 25
62411: PUSH
62412: LD_INT 9
62414: PUSH
62415: EMPTY
62416: LIST
62417: LIST
62418: PUSH
62419: EMPTY
62420: LIST
62421: LIST
62422: LIST
62423: LIST
62424: LIST
62425: PPUSH
62426: CALL_OW 72
62430: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
62431: LD_ADDR_VAR 0 6
62435: PUSH
62436: LD_EXP 59
62440: PUSH
62441: LD_VAR 0 1
62445: ARRAY
62446: PPUSH
62447: LD_INT 25
62449: PUSH
62450: LD_INT 2
62452: PUSH
62453: EMPTY
62454: LIST
62455: LIST
62456: PPUSH
62457: CALL_OW 72
62461: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
62462: LD_ADDR_VAR 0 7
62466: PUSH
62467: LD_EXP 59
62471: PUSH
62472: LD_VAR 0 1
62476: ARRAY
62477: PPUSH
62478: LD_INT 25
62480: PUSH
62481: LD_INT 3
62483: PUSH
62484: EMPTY
62485: LIST
62486: LIST
62487: PPUSH
62488: CALL_OW 72
62492: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
62493: LD_ADDR_VAR 0 8
62497: PUSH
62498: LD_EXP 59
62502: PUSH
62503: LD_VAR 0 1
62507: ARRAY
62508: PPUSH
62509: LD_INT 25
62511: PUSH
62512: LD_INT 4
62514: PUSH
62515: EMPTY
62516: LIST
62517: LIST
62518: PUSH
62519: LD_INT 24
62521: PUSH
62522: LD_INT 251
62524: PUSH
62525: EMPTY
62526: LIST
62527: LIST
62528: PUSH
62529: EMPTY
62530: LIST
62531: LIST
62532: PPUSH
62533: CALL_OW 72
62537: ST_TO_ADDR
// if mc_scan [ base ] then
62538: LD_EXP 82
62542: PUSH
62543: LD_VAR 0 1
62547: ARRAY
62548: IFFALSE 63009
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
62550: LD_ADDR_EXP 101
62554: PUSH
62555: LD_EXP 101
62559: PPUSH
62560: LD_VAR 0 1
62564: PPUSH
62565: LD_INT 4
62567: PPUSH
62568: CALL_OW 1
62572: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62573: LD_ADDR_VAR 0 12
62577: PUSH
62578: LD_EXP 59
62582: PUSH
62583: LD_VAR 0 1
62587: ARRAY
62588: PPUSH
62589: LD_INT 2
62591: PUSH
62592: LD_INT 30
62594: PUSH
62595: LD_INT 4
62597: PUSH
62598: EMPTY
62599: LIST
62600: LIST
62601: PUSH
62602: LD_INT 30
62604: PUSH
62605: LD_INT 5
62607: PUSH
62608: EMPTY
62609: LIST
62610: LIST
62611: PUSH
62612: EMPTY
62613: LIST
62614: LIST
62615: LIST
62616: PPUSH
62617: CALL_OW 72
62621: ST_TO_ADDR
// if not b then
62622: LD_VAR 0 12
62626: NOT
62627: IFFALSE 62631
// exit ;
62629: GO 65697
// p := [ ] ;
62631: LD_ADDR_VAR 0 11
62635: PUSH
62636: EMPTY
62637: ST_TO_ADDR
// if sci >= 2 then
62638: LD_VAR 0 8
62642: PUSH
62643: LD_INT 2
62645: GREATEREQUAL
62646: IFFALSE 62677
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
62648: LD_ADDR_VAR 0 8
62652: PUSH
62653: LD_VAR 0 8
62657: PUSH
62658: LD_INT 1
62660: ARRAY
62661: PUSH
62662: LD_VAR 0 8
62666: PUSH
62667: LD_INT 2
62669: ARRAY
62670: PUSH
62671: EMPTY
62672: LIST
62673: LIST
62674: ST_TO_ADDR
62675: GO 62738
// if sci = 1 then
62677: LD_VAR 0 8
62681: PUSH
62682: LD_INT 1
62684: EQUAL
62685: IFFALSE 62706
// sci := [ sci [ 1 ] ] else
62687: LD_ADDR_VAR 0 8
62691: PUSH
62692: LD_VAR 0 8
62696: PUSH
62697: LD_INT 1
62699: ARRAY
62700: PUSH
62701: EMPTY
62702: LIST
62703: ST_TO_ADDR
62704: GO 62738
// if sci = 0 then
62706: LD_VAR 0 8
62710: PUSH
62711: LD_INT 0
62713: EQUAL
62714: IFFALSE 62738
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
62716: LD_ADDR_VAR 0 11
62720: PUSH
62721: LD_VAR 0 4
62725: PPUSH
62726: LD_INT 4
62728: PPUSH
62729: CALL 55780 0 2
62733: PUSH
62734: LD_INT 1
62736: ARRAY
62737: ST_TO_ADDR
// if eng > 4 then
62738: LD_VAR 0 6
62742: PUSH
62743: LD_INT 4
62745: GREATER
62746: IFFALSE 62792
// for i = eng downto 4 do
62748: LD_ADDR_VAR 0 3
62752: PUSH
62753: DOUBLE
62754: LD_VAR 0 6
62758: INC
62759: ST_TO_ADDR
62760: LD_INT 4
62762: PUSH
62763: FOR_DOWNTO
62764: IFFALSE 62790
// eng := eng diff eng [ i ] ;
62766: LD_ADDR_VAR 0 6
62770: PUSH
62771: LD_VAR 0 6
62775: PUSH
62776: LD_VAR 0 6
62780: PUSH
62781: LD_VAR 0 3
62785: ARRAY
62786: DIFF
62787: ST_TO_ADDR
62788: GO 62763
62790: POP
62791: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
62792: LD_ADDR_VAR 0 4
62796: PUSH
62797: LD_VAR 0 4
62801: PUSH
62802: LD_VAR 0 5
62806: PUSH
62807: LD_VAR 0 6
62811: UNION
62812: PUSH
62813: LD_VAR 0 7
62817: UNION
62818: PUSH
62819: LD_VAR 0 8
62823: UNION
62824: DIFF
62825: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
62826: LD_ADDR_VAR 0 13
62830: PUSH
62831: LD_EXP 59
62835: PUSH
62836: LD_VAR 0 1
62840: ARRAY
62841: PPUSH
62842: LD_INT 2
62844: PUSH
62845: LD_INT 30
62847: PUSH
62848: LD_INT 32
62850: PUSH
62851: EMPTY
62852: LIST
62853: LIST
62854: PUSH
62855: LD_INT 30
62857: PUSH
62858: LD_INT 31
62860: PUSH
62861: EMPTY
62862: LIST
62863: LIST
62864: PUSH
62865: EMPTY
62866: LIST
62867: LIST
62868: LIST
62869: PPUSH
62870: CALL_OW 72
62874: PUSH
62875: LD_EXP 59
62879: PUSH
62880: LD_VAR 0 1
62884: ARRAY
62885: PPUSH
62886: LD_INT 2
62888: PUSH
62889: LD_INT 30
62891: PUSH
62892: LD_INT 4
62894: PUSH
62895: EMPTY
62896: LIST
62897: LIST
62898: PUSH
62899: LD_INT 30
62901: PUSH
62902: LD_INT 5
62904: PUSH
62905: EMPTY
62906: LIST
62907: LIST
62908: PUSH
62909: EMPTY
62910: LIST
62911: LIST
62912: LIST
62913: PPUSH
62914: CALL_OW 72
62918: PUSH
62919: LD_INT 6
62921: MUL
62922: PLUS
62923: ST_TO_ADDR
// if bcount < tmp then
62924: LD_VAR 0 13
62928: PUSH
62929: LD_VAR 0 4
62933: LESS
62934: IFFALSE 62980
// for i = tmp downto bcount do
62936: LD_ADDR_VAR 0 3
62940: PUSH
62941: DOUBLE
62942: LD_VAR 0 4
62946: INC
62947: ST_TO_ADDR
62948: LD_VAR 0 13
62952: PUSH
62953: FOR_DOWNTO
62954: IFFALSE 62978
// tmp := Delete ( tmp , tmp ) ;
62956: LD_ADDR_VAR 0 4
62960: PUSH
62961: LD_VAR 0 4
62965: PPUSH
62966: LD_VAR 0 4
62970: PPUSH
62971: CALL_OW 3
62975: ST_TO_ADDR
62976: GO 62953
62978: POP
62979: POP
// result := [ tmp , 0 , 0 , p ] ;
62980: LD_ADDR_VAR 0 2
62984: PUSH
62985: LD_VAR 0 4
62989: PUSH
62990: LD_INT 0
62992: PUSH
62993: LD_INT 0
62995: PUSH
62996: LD_VAR 0 11
63000: PUSH
63001: EMPTY
63002: LIST
63003: LIST
63004: LIST
63005: LIST
63006: ST_TO_ADDR
// exit ;
63007: GO 65697
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63009: LD_EXP 59
63013: PUSH
63014: LD_VAR 0 1
63018: ARRAY
63019: PPUSH
63020: LD_INT 2
63022: PUSH
63023: LD_INT 30
63025: PUSH
63026: LD_INT 6
63028: PUSH
63029: EMPTY
63030: LIST
63031: LIST
63032: PUSH
63033: LD_INT 30
63035: PUSH
63036: LD_INT 7
63038: PUSH
63039: EMPTY
63040: LIST
63041: LIST
63042: PUSH
63043: LD_INT 30
63045: PUSH
63046: LD_INT 8
63048: PUSH
63049: EMPTY
63050: LIST
63051: LIST
63052: PUSH
63053: EMPTY
63054: LIST
63055: LIST
63056: LIST
63057: LIST
63058: PPUSH
63059: CALL_OW 72
63063: NOT
63064: PUSH
63065: LD_EXP 59
63069: PUSH
63070: LD_VAR 0 1
63074: ARRAY
63075: PPUSH
63076: LD_INT 30
63078: PUSH
63079: LD_INT 3
63081: PUSH
63082: EMPTY
63083: LIST
63084: LIST
63085: PPUSH
63086: CALL_OW 72
63090: NOT
63091: AND
63092: IFFALSE 63164
// begin if eng = tmp then
63094: LD_VAR 0 6
63098: PUSH
63099: LD_VAR 0 4
63103: EQUAL
63104: IFFALSE 63108
// exit ;
63106: GO 65697
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
63108: LD_ADDR_EXP 101
63112: PUSH
63113: LD_EXP 101
63117: PPUSH
63118: LD_VAR 0 1
63122: PPUSH
63123: LD_INT 1
63125: PPUSH
63126: CALL_OW 1
63130: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
63131: LD_ADDR_VAR 0 2
63135: PUSH
63136: LD_INT 0
63138: PUSH
63139: LD_VAR 0 4
63143: PUSH
63144: LD_VAR 0 6
63148: DIFF
63149: PUSH
63150: LD_INT 0
63152: PUSH
63153: LD_INT 0
63155: PUSH
63156: EMPTY
63157: LIST
63158: LIST
63159: LIST
63160: LIST
63161: ST_TO_ADDR
// exit ;
63162: GO 65697
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63164: LD_EXP 86
63168: PUSH
63169: LD_EXP 85
63173: PUSH
63174: LD_VAR 0 1
63178: ARRAY
63179: ARRAY
63180: PUSH
63181: LD_EXP 59
63185: PUSH
63186: LD_VAR 0 1
63190: ARRAY
63191: PPUSH
63192: LD_INT 2
63194: PUSH
63195: LD_INT 30
63197: PUSH
63198: LD_INT 6
63200: PUSH
63201: EMPTY
63202: LIST
63203: LIST
63204: PUSH
63205: LD_INT 30
63207: PUSH
63208: LD_INT 7
63210: PUSH
63211: EMPTY
63212: LIST
63213: LIST
63214: PUSH
63215: LD_INT 30
63217: PUSH
63218: LD_INT 8
63220: PUSH
63221: EMPTY
63222: LIST
63223: LIST
63224: PUSH
63225: EMPTY
63226: LIST
63227: LIST
63228: LIST
63229: LIST
63230: PPUSH
63231: CALL_OW 72
63235: AND
63236: PUSH
63237: LD_EXP 59
63241: PUSH
63242: LD_VAR 0 1
63246: ARRAY
63247: PPUSH
63248: LD_INT 30
63250: PUSH
63251: LD_INT 3
63253: PUSH
63254: EMPTY
63255: LIST
63256: LIST
63257: PPUSH
63258: CALL_OW 72
63262: NOT
63263: AND
63264: IFFALSE 63478
// begin if sci >= 6 then
63266: LD_VAR 0 8
63270: PUSH
63271: LD_INT 6
63273: GREATEREQUAL
63274: IFFALSE 63278
// exit ;
63276: GO 65697
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
63278: LD_ADDR_EXP 101
63282: PUSH
63283: LD_EXP 101
63287: PPUSH
63288: LD_VAR 0 1
63292: PPUSH
63293: LD_INT 2
63295: PPUSH
63296: CALL_OW 1
63300: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
63301: LD_ADDR_VAR 0 9
63305: PUSH
63306: LD_VAR 0 4
63310: PUSH
63311: LD_VAR 0 8
63315: DIFF
63316: PPUSH
63317: LD_INT 4
63319: PPUSH
63320: CALL 55780 0 2
63324: ST_TO_ADDR
// p := [ ] ;
63325: LD_ADDR_VAR 0 11
63329: PUSH
63330: EMPTY
63331: ST_TO_ADDR
// if sci < 6 and sort > 6 then
63332: LD_VAR 0 8
63336: PUSH
63337: LD_INT 6
63339: LESS
63340: PUSH
63341: LD_VAR 0 9
63345: PUSH
63346: LD_INT 6
63348: GREATER
63349: AND
63350: IFFALSE 63431
// begin for i = 1 to 6 - sci do
63352: LD_ADDR_VAR 0 3
63356: PUSH
63357: DOUBLE
63358: LD_INT 1
63360: DEC
63361: ST_TO_ADDR
63362: LD_INT 6
63364: PUSH
63365: LD_VAR 0 8
63369: MINUS
63370: PUSH
63371: FOR_TO
63372: IFFALSE 63427
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
63374: LD_ADDR_VAR 0 11
63378: PUSH
63379: LD_VAR 0 11
63383: PPUSH
63384: LD_VAR 0 11
63388: PUSH
63389: LD_INT 1
63391: PLUS
63392: PPUSH
63393: LD_VAR 0 9
63397: PUSH
63398: LD_INT 1
63400: ARRAY
63401: PPUSH
63402: CALL_OW 2
63406: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
63407: LD_ADDR_VAR 0 9
63411: PUSH
63412: LD_VAR 0 9
63416: PPUSH
63417: LD_INT 1
63419: PPUSH
63420: CALL_OW 3
63424: ST_TO_ADDR
// end ;
63425: GO 63371
63427: POP
63428: POP
// end else
63429: GO 63451
// if sort then
63431: LD_VAR 0 9
63435: IFFALSE 63451
// p := sort [ 1 ] ;
63437: LD_ADDR_VAR 0 11
63441: PUSH
63442: LD_VAR 0 9
63446: PUSH
63447: LD_INT 1
63449: ARRAY
63450: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
63451: LD_ADDR_VAR 0 2
63455: PUSH
63456: LD_INT 0
63458: PUSH
63459: LD_INT 0
63461: PUSH
63462: LD_INT 0
63464: PUSH
63465: LD_VAR 0 11
63469: PUSH
63470: EMPTY
63471: LIST
63472: LIST
63473: LIST
63474: LIST
63475: ST_TO_ADDR
// exit ;
63476: GO 65697
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63478: LD_EXP 86
63482: PUSH
63483: LD_EXP 85
63487: PUSH
63488: LD_VAR 0 1
63492: ARRAY
63493: ARRAY
63494: PUSH
63495: LD_EXP 59
63499: PUSH
63500: LD_VAR 0 1
63504: ARRAY
63505: PPUSH
63506: LD_INT 2
63508: PUSH
63509: LD_INT 30
63511: PUSH
63512: LD_INT 6
63514: PUSH
63515: EMPTY
63516: LIST
63517: LIST
63518: PUSH
63519: LD_INT 30
63521: PUSH
63522: LD_INT 7
63524: PUSH
63525: EMPTY
63526: LIST
63527: LIST
63528: PUSH
63529: LD_INT 30
63531: PUSH
63532: LD_INT 8
63534: PUSH
63535: EMPTY
63536: LIST
63537: LIST
63538: PUSH
63539: EMPTY
63540: LIST
63541: LIST
63542: LIST
63543: LIST
63544: PPUSH
63545: CALL_OW 72
63549: AND
63550: PUSH
63551: LD_EXP 59
63555: PUSH
63556: LD_VAR 0 1
63560: ARRAY
63561: PPUSH
63562: LD_INT 30
63564: PUSH
63565: LD_INT 3
63567: PUSH
63568: EMPTY
63569: LIST
63570: LIST
63571: PPUSH
63572: CALL_OW 72
63576: AND
63577: IFFALSE 64311
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
63579: LD_ADDR_EXP 101
63583: PUSH
63584: LD_EXP 101
63588: PPUSH
63589: LD_VAR 0 1
63593: PPUSH
63594: LD_INT 3
63596: PPUSH
63597: CALL_OW 1
63601: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63602: LD_ADDR_VAR 0 2
63606: PUSH
63607: LD_INT 0
63609: PUSH
63610: LD_INT 0
63612: PUSH
63613: LD_INT 0
63615: PUSH
63616: LD_INT 0
63618: PUSH
63619: EMPTY
63620: LIST
63621: LIST
63622: LIST
63623: LIST
63624: ST_TO_ADDR
// if not eng then
63625: LD_VAR 0 6
63629: NOT
63630: IFFALSE 63693
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
63632: LD_ADDR_VAR 0 11
63636: PUSH
63637: LD_VAR 0 4
63641: PPUSH
63642: LD_INT 2
63644: PPUSH
63645: CALL 55780 0 2
63649: PUSH
63650: LD_INT 1
63652: ARRAY
63653: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
63654: LD_ADDR_VAR 0 2
63658: PUSH
63659: LD_VAR 0 2
63663: PPUSH
63664: LD_INT 2
63666: PPUSH
63667: LD_VAR 0 11
63671: PPUSH
63672: CALL_OW 1
63676: ST_TO_ADDR
// tmp := tmp diff p ;
63677: LD_ADDR_VAR 0 4
63681: PUSH
63682: LD_VAR 0 4
63686: PUSH
63687: LD_VAR 0 11
63691: DIFF
63692: ST_TO_ADDR
// end ; if tmp and sci < 6 then
63693: LD_VAR 0 4
63697: PUSH
63698: LD_VAR 0 8
63702: PUSH
63703: LD_INT 6
63705: LESS
63706: AND
63707: IFFALSE 63895
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
63709: LD_ADDR_VAR 0 9
63713: PUSH
63714: LD_VAR 0 4
63718: PUSH
63719: LD_VAR 0 8
63723: PUSH
63724: LD_VAR 0 7
63728: UNION
63729: DIFF
63730: PPUSH
63731: LD_INT 4
63733: PPUSH
63734: CALL 55780 0 2
63738: ST_TO_ADDR
// p := [ ] ;
63739: LD_ADDR_VAR 0 11
63743: PUSH
63744: EMPTY
63745: ST_TO_ADDR
// if sort then
63746: LD_VAR 0 9
63750: IFFALSE 63866
// for i = 1 to 6 - sci do
63752: LD_ADDR_VAR 0 3
63756: PUSH
63757: DOUBLE
63758: LD_INT 1
63760: DEC
63761: ST_TO_ADDR
63762: LD_INT 6
63764: PUSH
63765: LD_VAR 0 8
63769: MINUS
63770: PUSH
63771: FOR_TO
63772: IFFALSE 63864
// begin if i = sort then
63774: LD_VAR 0 3
63778: PUSH
63779: LD_VAR 0 9
63783: EQUAL
63784: IFFALSE 63788
// break ;
63786: GO 63864
// if GetClass ( i ) = 4 then
63788: LD_VAR 0 3
63792: PPUSH
63793: CALL_OW 257
63797: PUSH
63798: LD_INT 4
63800: EQUAL
63801: IFFALSE 63805
// continue ;
63803: GO 63771
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63805: LD_ADDR_VAR 0 11
63809: PUSH
63810: LD_VAR 0 11
63814: PPUSH
63815: LD_VAR 0 11
63819: PUSH
63820: LD_INT 1
63822: PLUS
63823: PPUSH
63824: LD_VAR 0 9
63828: PUSH
63829: LD_VAR 0 3
63833: ARRAY
63834: PPUSH
63835: CALL_OW 2
63839: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63840: LD_ADDR_VAR 0 4
63844: PUSH
63845: LD_VAR 0 4
63849: PUSH
63850: LD_VAR 0 9
63854: PUSH
63855: LD_VAR 0 3
63859: ARRAY
63860: DIFF
63861: ST_TO_ADDR
// end ;
63862: GO 63771
63864: POP
63865: POP
// if p then
63866: LD_VAR 0 11
63870: IFFALSE 63895
// result := Replace ( result , 4 , p ) ;
63872: LD_ADDR_VAR 0 2
63876: PUSH
63877: LD_VAR 0 2
63881: PPUSH
63882: LD_INT 4
63884: PPUSH
63885: LD_VAR 0 11
63889: PPUSH
63890: CALL_OW 1
63894: ST_TO_ADDR
// end ; if tmp and mech < 6 then
63895: LD_VAR 0 4
63899: PUSH
63900: LD_VAR 0 7
63904: PUSH
63905: LD_INT 6
63907: LESS
63908: AND
63909: IFFALSE 64097
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63911: LD_ADDR_VAR 0 9
63915: PUSH
63916: LD_VAR 0 4
63920: PUSH
63921: LD_VAR 0 8
63925: PUSH
63926: LD_VAR 0 7
63930: UNION
63931: DIFF
63932: PPUSH
63933: LD_INT 3
63935: PPUSH
63936: CALL 55780 0 2
63940: ST_TO_ADDR
// p := [ ] ;
63941: LD_ADDR_VAR 0 11
63945: PUSH
63946: EMPTY
63947: ST_TO_ADDR
// if sort then
63948: LD_VAR 0 9
63952: IFFALSE 64068
// for i = 1 to 6 - mech do
63954: LD_ADDR_VAR 0 3
63958: PUSH
63959: DOUBLE
63960: LD_INT 1
63962: DEC
63963: ST_TO_ADDR
63964: LD_INT 6
63966: PUSH
63967: LD_VAR 0 7
63971: MINUS
63972: PUSH
63973: FOR_TO
63974: IFFALSE 64066
// begin if i = sort then
63976: LD_VAR 0 3
63980: PUSH
63981: LD_VAR 0 9
63985: EQUAL
63986: IFFALSE 63990
// break ;
63988: GO 64066
// if GetClass ( i ) = 3 then
63990: LD_VAR 0 3
63994: PPUSH
63995: CALL_OW 257
63999: PUSH
64000: LD_INT 3
64002: EQUAL
64003: IFFALSE 64007
// continue ;
64005: GO 63973
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64007: LD_ADDR_VAR 0 11
64011: PUSH
64012: LD_VAR 0 11
64016: PPUSH
64017: LD_VAR 0 11
64021: PUSH
64022: LD_INT 1
64024: PLUS
64025: PPUSH
64026: LD_VAR 0 9
64030: PUSH
64031: LD_VAR 0 3
64035: ARRAY
64036: PPUSH
64037: CALL_OW 2
64041: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64042: LD_ADDR_VAR 0 4
64046: PUSH
64047: LD_VAR 0 4
64051: PUSH
64052: LD_VAR 0 9
64056: PUSH
64057: LD_VAR 0 3
64061: ARRAY
64062: DIFF
64063: ST_TO_ADDR
// end ;
64064: GO 63973
64066: POP
64067: POP
// if p then
64068: LD_VAR 0 11
64072: IFFALSE 64097
// result := Replace ( result , 3 , p ) ;
64074: LD_ADDR_VAR 0 2
64078: PUSH
64079: LD_VAR 0 2
64083: PPUSH
64084: LD_INT 3
64086: PPUSH
64087: LD_VAR 0 11
64091: PPUSH
64092: CALL_OW 1
64096: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
64097: LD_VAR 0 4
64101: PUSH
64102: LD_INT 6
64104: GREATER
64105: PUSH
64106: LD_VAR 0 6
64110: PUSH
64111: LD_INT 6
64113: LESS
64114: AND
64115: IFFALSE 64309
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64117: LD_ADDR_VAR 0 9
64121: PUSH
64122: LD_VAR 0 4
64126: PUSH
64127: LD_VAR 0 8
64131: PUSH
64132: LD_VAR 0 7
64136: UNION
64137: PUSH
64138: LD_VAR 0 6
64142: UNION
64143: DIFF
64144: PPUSH
64145: LD_INT 2
64147: PPUSH
64148: CALL 55780 0 2
64152: ST_TO_ADDR
// p := [ ] ;
64153: LD_ADDR_VAR 0 11
64157: PUSH
64158: EMPTY
64159: ST_TO_ADDR
// if sort then
64160: LD_VAR 0 9
64164: IFFALSE 64280
// for i = 1 to 6 - eng do
64166: LD_ADDR_VAR 0 3
64170: PUSH
64171: DOUBLE
64172: LD_INT 1
64174: DEC
64175: ST_TO_ADDR
64176: LD_INT 6
64178: PUSH
64179: LD_VAR 0 6
64183: MINUS
64184: PUSH
64185: FOR_TO
64186: IFFALSE 64278
// begin if i = sort then
64188: LD_VAR 0 3
64192: PUSH
64193: LD_VAR 0 9
64197: EQUAL
64198: IFFALSE 64202
// break ;
64200: GO 64278
// if GetClass ( i ) = 2 then
64202: LD_VAR 0 3
64206: PPUSH
64207: CALL_OW 257
64211: PUSH
64212: LD_INT 2
64214: EQUAL
64215: IFFALSE 64219
// continue ;
64217: GO 64185
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64219: LD_ADDR_VAR 0 11
64223: PUSH
64224: LD_VAR 0 11
64228: PPUSH
64229: LD_VAR 0 11
64233: PUSH
64234: LD_INT 1
64236: PLUS
64237: PPUSH
64238: LD_VAR 0 9
64242: PUSH
64243: LD_VAR 0 3
64247: ARRAY
64248: PPUSH
64249: CALL_OW 2
64253: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64254: LD_ADDR_VAR 0 4
64258: PUSH
64259: LD_VAR 0 4
64263: PUSH
64264: LD_VAR 0 9
64268: PUSH
64269: LD_VAR 0 3
64273: ARRAY
64274: DIFF
64275: ST_TO_ADDR
// end ;
64276: GO 64185
64278: POP
64279: POP
// if p then
64280: LD_VAR 0 11
64284: IFFALSE 64309
// result := Replace ( result , 2 , p ) ;
64286: LD_ADDR_VAR 0 2
64290: PUSH
64291: LD_VAR 0 2
64295: PPUSH
64296: LD_INT 2
64298: PPUSH
64299: LD_VAR 0 11
64303: PPUSH
64304: CALL_OW 1
64308: ST_TO_ADDR
// end ; exit ;
64309: GO 65697
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
64311: LD_EXP 86
64315: PUSH
64316: LD_EXP 85
64320: PUSH
64321: LD_VAR 0 1
64325: ARRAY
64326: ARRAY
64327: NOT
64328: PUSH
64329: LD_EXP 59
64333: PUSH
64334: LD_VAR 0 1
64338: ARRAY
64339: PPUSH
64340: LD_INT 30
64342: PUSH
64343: LD_INT 3
64345: PUSH
64346: EMPTY
64347: LIST
64348: LIST
64349: PPUSH
64350: CALL_OW 72
64354: AND
64355: PUSH
64356: LD_EXP 64
64360: PUSH
64361: LD_VAR 0 1
64365: ARRAY
64366: AND
64367: IFFALSE 64975
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
64369: LD_ADDR_EXP 101
64373: PUSH
64374: LD_EXP 101
64378: PPUSH
64379: LD_VAR 0 1
64383: PPUSH
64384: LD_INT 5
64386: PPUSH
64387: CALL_OW 1
64391: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64392: LD_ADDR_VAR 0 2
64396: PUSH
64397: LD_INT 0
64399: PUSH
64400: LD_INT 0
64402: PUSH
64403: LD_INT 0
64405: PUSH
64406: LD_INT 0
64408: PUSH
64409: EMPTY
64410: LIST
64411: LIST
64412: LIST
64413: LIST
64414: ST_TO_ADDR
// if sci > 1 then
64415: LD_VAR 0 8
64419: PUSH
64420: LD_INT 1
64422: GREATER
64423: IFFALSE 64451
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
64425: LD_ADDR_VAR 0 4
64429: PUSH
64430: LD_VAR 0 4
64434: PUSH
64435: LD_VAR 0 8
64439: PUSH
64440: LD_VAR 0 8
64444: PUSH
64445: LD_INT 1
64447: ARRAY
64448: DIFF
64449: DIFF
64450: ST_TO_ADDR
// if tmp and not sci then
64451: LD_VAR 0 4
64455: PUSH
64456: LD_VAR 0 8
64460: NOT
64461: AND
64462: IFFALSE 64531
// begin sort := SortBySkill ( tmp , 4 ) ;
64464: LD_ADDR_VAR 0 9
64468: PUSH
64469: LD_VAR 0 4
64473: PPUSH
64474: LD_INT 4
64476: PPUSH
64477: CALL 55780 0 2
64481: ST_TO_ADDR
// if sort then
64482: LD_VAR 0 9
64486: IFFALSE 64502
// p := sort [ 1 ] ;
64488: LD_ADDR_VAR 0 11
64492: PUSH
64493: LD_VAR 0 9
64497: PUSH
64498: LD_INT 1
64500: ARRAY
64501: ST_TO_ADDR
// if p then
64502: LD_VAR 0 11
64506: IFFALSE 64531
// result := Replace ( result , 4 , p ) ;
64508: LD_ADDR_VAR 0 2
64512: PUSH
64513: LD_VAR 0 2
64517: PPUSH
64518: LD_INT 4
64520: PPUSH
64521: LD_VAR 0 11
64525: PPUSH
64526: CALL_OW 1
64530: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64531: LD_ADDR_VAR 0 4
64535: PUSH
64536: LD_VAR 0 4
64540: PUSH
64541: LD_VAR 0 7
64545: DIFF
64546: ST_TO_ADDR
// if tmp and mech < 6 then
64547: LD_VAR 0 4
64551: PUSH
64552: LD_VAR 0 7
64556: PUSH
64557: LD_INT 6
64559: LESS
64560: AND
64561: IFFALSE 64749
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
64563: LD_ADDR_VAR 0 9
64567: PUSH
64568: LD_VAR 0 4
64572: PUSH
64573: LD_VAR 0 8
64577: PUSH
64578: LD_VAR 0 7
64582: UNION
64583: DIFF
64584: PPUSH
64585: LD_INT 3
64587: PPUSH
64588: CALL 55780 0 2
64592: ST_TO_ADDR
// p := [ ] ;
64593: LD_ADDR_VAR 0 11
64597: PUSH
64598: EMPTY
64599: ST_TO_ADDR
// if sort then
64600: LD_VAR 0 9
64604: IFFALSE 64720
// for i = 1 to 6 - mech do
64606: LD_ADDR_VAR 0 3
64610: PUSH
64611: DOUBLE
64612: LD_INT 1
64614: DEC
64615: ST_TO_ADDR
64616: LD_INT 6
64618: PUSH
64619: LD_VAR 0 7
64623: MINUS
64624: PUSH
64625: FOR_TO
64626: IFFALSE 64718
// begin if i = sort then
64628: LD_VAR 0 3
64632: PUSH
64633: LD_VAR 0 9
64637: EQUAL
64638: IFFALSE 64642
// break ;
64640: GO 64718
// if GetClass ( i ) = 3 then
64642: LD_VAR 0 3
64646: PPUSH
64647: CALL_OW 257
64651: PUSH
64652: LD_INT 3
64654: EQUAL
64655: IFFALSE 64659
// continue ;
64657: GO 64625
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64659: LD_ADDR_VAR 0 11
64663: PUSH
64664: LD_VAR 0 11
64668: PPUSH
64669: LD_VAR 0 11
64673: PUSH
64674: LD_INT 1
64676: PLUS
64677: PPUSH
64678: LD_VAR 0 9
64682: PUSH
64683: LD_VAR 0 3
64687: ARRAY
64688: PPUSH
64689: CALL_OW 2
64693: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64694: LD_ADDR_VAR 0 4
64698: PUSH
64699: LD_VAR 0 4
64703: PUSH
64704: LD_VAR 0 9
64708: PUSH
64709: LD_VAR 0 3
64713: ARRAY
64714: DIFF
64715: ST_TO_ADDR
// end ;
64716: GO 64625
64718: POP
64719: POP
// if p then
64720: LD_VAR 0 11
64724: IFFALSE 64749
// result := Replace ( result , 3 , p ) ;
64726: LD_ADDR_VAR 0 2
64730: PUSH
64731: LD_VAR 0 2
64735: PPUSH
64736: LD_INT 3
64738: PPUSH
64739: LD_VAR 0 11
64743: PPUSH
64744: CALL_OW 1
64748: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64749: LD_ADDR_VAR 0 4
64753: PUSH
64754: LD_VAR 0 4
64758: PUSH
64759: LD_VAR 0 6
64763: DIFF
64764: ST_TO_ADDR
// if tmp and eng < 6 then
64765: LD_VAR 0 4
64769: PUSH
64770: LD_VAR 0 6
64774: PUSH
64775: LD_INT 6
64777: LESS
64778: AND
64779: IFFALSE 64973
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64781: LD_ADDR_VAR 0 9
64785: PUSH
64786: LD_VAR 0 4
64790: PUSH
64791: LD_VAR 0 8
64795: PUSH
64796: LD_VAR 0 7
64800: UNION
64801: PUSH
64802: LD_VAR 0 6
64806: UNION
64807: DIFF
64808: PPUSH
64809: LD_INT 2
64811: PPUSH
64812: CALL 55780 0 2
64816: ST_TO_ADDR
// p := [ ] ;
64817: LD_ADDR_VAR 0 11
64821: PUSH
64822: EMPTY
64823: ST_TO_ADDR
// if sort then
64824: LD_VAR 0 9
64828: IFFALSE 64944
// for i = 1 to 6 - eng do
64830: LD_ADDR_VAR 0 3
64834: PUSH
64835: DOUBLE
64836: LD_INT 1
64838: DEC
64839: ST_TO_ADDR
64840: LD_INT 6
64842: PUSH
64843: LD_VAR 0 6
64847: MINUS
64848: PUSH
64849: FOR_TO
64850: IFFALSE 64942
// begin if i = sort then
64852: LD_VAR 0 3
64856: PUSH
64857: LD_VAR 0 9
64861: EQUAL
64862: IFFALSE 64866
// break ;
64864: GO 64942
// if GetClass ( i ) = 2 then
64866: LD_VAR 0 3
64870: PPUSH
64871: CALL_OW 257
64875: PUSH
64876: LD_INT 2
64878: EQUAL
64879: IFFALSE 64883
// continue ;
64881: GO 64849
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64883: LD_ADDR_VAR 0 11
64887: PUSH
64888: LD_VAR 0 11
64892: PPUSH
64893: LD_VAR 0 11
64897: PUSH
64898: LD_INT 1
64900: PLUS
64901: PPUSH
64902: LD_VAR 0 9
64906: PUSH
64907: LD_VAR 0 3
64911: ARRAY
64912: PPUSH
64913: CALL_OW 2
64917: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64918: LD_ADDR_VAR 0 4
64922: PUSH
64923: LD_VAR 0 4
64927: PUSH
64928: LD_VAR 0 9
64932: PUSH
64933: LD_VAR 0 3
64937: ARRAY
64938: DIFF
64939: ST_TO_ADDR
// end ;
64940: GO 64849
64942: POP
64943: POP
// if p then
64944: LD_VAR 0 11
64948: IFFALSE 64973
// result := Replace ( result , 2 , p ) ;
64950: LD_ADDR_VAR 0 2
64954: PUSH
64955: LD_VAR 0 2
64959: PPUSH
64960: LD_INT 2
64962: PPUSH
64963: LD_VAR 0 11
64967: PPUSH
64968: CALL_OW 1
64972: ST_TO_ADDR
// end ; exit ;
64973: GO 65697
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
64975: LD_EXP 86
64979: PUSH
64980: LD_EXP 85
64984: PUSH
64985: LD_VAR 0 1
64989: ARRAY
64990: ARRAY
64991: NOT
64992: PUSH
64993: LD_EXP 59
64997: PUSH
64998: LD_VAR 0 1
65002: ARRAY
65003: PPUSH
65004: LD_INT 30
65006: PUSH
65007: LD_INT 3
65009: PUSH
65010: EMPTY
65011: LIST
65012: LIST
65013: PPUSH
65014: CALL_OW 72
65018: AND
65019: PUSH
65020: LD_EXP 64
65024: PUSH
65025: LD_VAR 0 1
65029: ARRAY
65030: NOT
65031: AND
65032: IFFALSE 65697
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
65034: LD_ADDR_EXP 101
65038: PUSH
65039: LD_EXP 101
65043: PPUSH
65044: LD_VAR 0 1
65048: PPUSH
65049: LD_INT 6
65051: PPUSH
65052: CALL_OW 1
65056: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
65057: LD_ADDR_VAR 0 2
65061: PUSH
65062: LD_INT 0
65064: PUSH
65065: LD_INT 0
65067: PUSH
65068: LD_INT 0
65070: PUSH
65071: LD_INT 0
65073: PUSH
65074: EMPTY
65075: LIST
65076: LIST
65077: LIST
65078: LIST
65079: ST_TO_ADDR
// if sci >= 1 then
65080: LD_VAR 0 8
65084: PUSH
65085: LD_INT 1
65087: GREATEREQUAL
65088: IFFALSE 65110
// tmp := tmp diff sci [ 1 ] ;
65090: LD_ADDR_VAR 0 4
65094: PUSH
65095: LD_VAR 0 4
65099: PUSH
65100: LD_VAR 0 8
65104: PUSH
65105: LD_INT 1
65107: ARRAY
65108: DIFF
65109: ST_TO_ADDR
// if tmp and not sci then
65110: LD_VAR 0 4
65114: PUSH
65115: LD_VAR 0 8
65119: NOT
65120: AND
65121: IFFALSE 65190
// begin sort := SortBySkill ( tmp , 4 ) ;
65123: LD_ADDR_VAR 0 9
65127: PUSH
65128: LD_VAR 0 4
65132: PPUSH
65133: LD_INT 4
65135: PPUSH
65136: CALL 55780 0 2
65140: ST_TO_ADDR
// if sort then
65141: LD_VAR 0 9
65145: IFFALSE 65161
// p := sort [ 1 ] ;
65147: LD_ADDR_VAR 0 11
65151: PUSH
65152: LD_VAR 0 9
65156: PUSH
65157: LD_INT 1
65159: ARRAY
65160: ST_TO_ADDR
// if p then
65161: LD_VAR 0 11
65165: IFFALSE 65190
// result := Replace ( result , 4 , p ) ;
65167: LD_ADDR_VAR 0 2
65171: PUSH
65172: LD_VAR 0 2
65176: PPUSH
65177: LD_INT 4
65179: PPUSH
65180: LD_VAR 0 11
65184: PPUSH
65185: CALL_OW 1
65189: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
65190: LD_ADDR_VAR 0 4
65194: PUSH
65195: LD_VAR 0 4
65199: PUSH
65200: LD_VAR 0 7
65204: DIFF
65205: ST_TO_ADDR
// if tmp and mech < 6 then
65206: LD_VAR 0 4
65210: PUSH
65211: LD_VAR 0 7
65215: PUSH
65216: LD_INT 6
65218: LESS
65219: AND
65220: IFFALSE 65402
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
65222: LD_ADDR_VAR 0 9
65226: PUSH
65227: LD_VAR 0 4
65231: PUSH
65232: LD_VAR 0 7
65236: DIFF
65237: PPUSH
65238: LD_INT 3
65240: PPUSH
65241: CALL 55780 0 2
65245: ST_TO_ADDR
// p := [ ] ;
65246: LD_ADDR_VAR 0 11
65250: PUSH
65251: EMPTY
65252: ST_TO_ADDR
// if sort then
65253: LD_VAR 0 9
65257: IFFALSE 65373
// for i = 1 to 6 - mech do
65259: LD_ADDR_VAR 0 3
65263: PUSH
65264: DOUBLE
65265: LD_INT 1
65267: DEC
65268: ST_TO_ADDR
65269: LD_INT 6
65271: PUSH
65272: LD_VAR 0 7
65276: MINUS
65277: PUSH
65278: FOR_TO
65279: IFFALSE 65371
// begin if i = sort then
65281: LD_VAR 0 3
65285: PUSH
65286: LD_VAR 0 9
65290: EQUAL
65291: IFFALSE 65295
// break ;
65293: GO 65371
// if GetClass ( i ) = 3 then
65295: LD_VAR 0 3
65299: PPUSH
65300: CALL_OW 257
65304: PUSH
65305: LD_INT 3
65307: EQUAL
65308: IFFALSE 65312
// continue ;
65310: GO 65278
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65312: LD_ADDR_VAR 0 11
65316: PUSH
65317: LD_VAR 0 11
65321: PPUSH
65322: LD_VAR 0 11
65326: PUSH
65327: LD_INT 1
65329: PLUS
65330: PPUSH
65331: LD_VAR 0 9
65335: PUSH
65336: LD_VAR 0 3
65340: ARRAY
65341: PPUSH
65342: CALL_OW 2
65346: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65347: LD_ADDR_VAR 0 4
65351: PUSH
65352: LD_VAR 0 4
65356: PUSH
65357: LD_VAR 0 9
65361: PUSH
65362: LD_VAR 0 3
65366: ARRAY
65367: DIFF
65368: ST_TO_ADDR
// end ;
65369: GO 65278
65371: POP
65372: POP
// if p then
65373: LD_VAR 0 11
65377: IFFALSE 65402
// result := Replace ( result , 3 , p ) ;
65379: LD_ADDR_VAR 0 2
65383: PUSH
65384: LD_VAR 0 2
65388: PPUSH
65389: LD_INT 3
65391: PPUSH
65392: LD_VAR 0 11
65396: PPUSH
65397: CALL_OW 1
65401: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
65402: LD_ADDR_VAR 0 4
65406: PUSH
65407: LD_VAR 0 4
65411: PUSH
65412: LD_VAR 0 6
65416: DIFF
65417: ST_TO_ADDR
// if tmp and eng < 4 then
65418: LD_VAR 0 4
65422: PUSH
65423: LD_VAR 0 6
65427: PUSH
65428: LD_INT 4
65430: LESS
65431: AND
65432: IFFALSE 65622
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
65434: LD_ADDR_VAR 0 9
65438: PUSH
65439: LD_VAR 0 4
65443: PUSH
65444: LD_VAR 0 7
65448: PUSH
65449: LD_VAR 0 6
65453: UNION
65454: DIFF
65455: PPUSH
65456: LD_INT 2
65458: PPUSH
65459: CALL 55780 0 2
65463: ST_TO_ADDR
// p := [ ] ;
65464: LD_ADDR_VAR 0 11
65468: PUSH
65469: EMPTY
65470: ST_TO_ADDR
// if sort then
65471: LD_VAR 0 9
65475: IFFALSE 65591
// for i = 1 to 4 - eng do
65477: LD_ADDR_VAR 0 3
65481: PUSH
65482: DOUBLE
65483: LD_INT 1
65485: DEC
65486: ST_TO_ADDR
65487: LD_INT 4
65489: PUSH
65490: LD_VAR 0 6
65494: MINUS
65495: PUSH
65496: FOR_TO
65497: IFFALSE 65589
// begin if i = sort then
65499: LD_VAR 0 3
65503: PUSH
65504: LD_VAR 0 9
65508: EQUAL
65509: IFFALSE 65513
// break ;
65511: GO 65589
// if GetClass ( i ) = 2 then
65513: LD_VAR 0 3
65517: PPUSH
65518: CALL_OW 257
65522: PUSH
65523: LD_INT 2
65525: EQUAL
65526: IFFALSE 65530
// continue ;
65528: GO 65496
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65530: LD_ADDR_VAR 0 11
65534: PUSH
65535: LD_VAR 0 11
65539: PPUSH
65540: LD_VAR 0 11
65544: PUSH
65545: LD_INT 1
65547: PLUS
65548: PPUSH
65549: LD_VAR 0 9
65553: PUSH
65554: LD_VAR 0 3
65558: ARRAY
65559: PPUSH
65560: CALL_OW 2
65564: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65565: LD_ADDR_VAR 0 4
65569: PUSH
65570: LD_VAR 0 4
65574: PUSH
65575: LD_VAR 0 9
65579: PUSH
65580: LD_VAR 0 3
65584: ARRAY
65585: DIFF
65586: ST_TO_ADDR
// end ;
65587: GO 65496
65589: POP
65590: POP
// if p then
65591: LD_VAR 0 11
65595: IFFALSE 65620
// result := Replace ( result , 2 , p ) ;
65597: LD_ADDR_VAR 0 2
65601: PUSH
65602: LD_VAR 0 2
65606: PPUSH
65607: LD_INT 2
65609: PPUSH
65610: LD_VAR 0 11
65614: PPUSH
65615: CALL_OW 1
65619: ST_TO_ADDR
// end else
65620: GO 65666
// for i = eng downto 5 do
65622: LD_ADDR_VAR 0 3
65626: PUSH
65627: DOUBLE
65628: LD_VAR 0 6
65632: INC
65633: ST_TO_ADDR
65634: LD_INT 5
65636: PUSH
65637: FOR_DOWNTO
65638: IFFALSE 65664
// tmp := tmp union eng [ i ] ;
65640: LD_ADDR_VAR 0 4
65644: PUSH
65645: LD_VAR 0 4
65649: PUSH
65650: LD_VAR 0 6
65654: PUSH
65655: LD_VAR 0 3
65659: ARRAY
65660: UNION
65661: ST_TO_ADDR
65662: GO 65637
65664: POP
65665: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
65666: LD_ADDR_VAR 0 2
65670: PUSH
65671: LD_VAR 0 2
65675: PPUSH
65676: LD_INT 1
65678: PPUSH
65679: LD_VAR 0 4
65683: PUSH
65684: LD_VAR 0 5
65688: DIFF
65689: PPUSH
65690: CALL_OW 1
65694: ST_TO_ADDR
// exit ;
65695: GO 65697
// end ; end ;
65697: LD_VAR 0 2
65701: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
65702: LD_INT 0
65704: PPUSH
65705: PPUSH
65706: PPUSH
// if not mc_bases then
65707: LD_EXP 59
65711: NOT
65712: IFFALSE 65716
// exit ;
65714: GO 65822
// for i = 1 to mc_bases do
65716: LD_ADDR_VAR 0 2
65720: PUSH
65721: DOUBLE
65722: LD_INT 1
65724: DEC
65725: ST_TO_ADDR
65726: LD_EXP 59
65730: PUSH
65731: FOR_TO
65732: IFFALSE 65813
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65734: LD_ADDR_VAR 0 3
65738: PUSH
65739: LD_EXP 59
65743: PUSH
65744: LD_VAR 0 2
65748: ARRAY
65749: PPUSH
65750: LD_INT 21
65752: PUSH
65753: LD_INT 3
65755: PUSH
65756: EMPTY
65757: LIST
65758: LIST
65759: PUSH
65760: LD_INT 3
65762: PUSH
65763: LD_INT 24
65765: PUSH
65766: LD_INT 1000
65768: PUSH
65769: EMPTY
65770: LIST
65771: LIST
65772: PUSH
65773: EMPTY
65774: LIST
65775: LIST
65776: PUSH
65777: EMPTY
65778: LIST
65779: LIST
65780: PPUSH
65781: CALL_OW 72
65785: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
65786: LD_ADDR_EXP 60
65790: PUSH
65791: LD_EXP 60
65795: PPUSH
65796: LD_VAR 0 2
65800: PPUSH
65801: LD_VAR 0 3
65805: PPUSH
65806: CALL_OW 1
65810: ST_TO_ADDR
// end ;
65811: GO 65731
65813: POP
65814: POP
// RaiseSailEvent ( 101 ) ;
65815: LD_INT 101
65817: PPUSH
65818: CALL_OW 427
// end ;
65822: LD_VAR 0 1
65826: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
65827: LD_INT 0
65829: PPUSH
65830: PPUSH
65831: PPUSH
65832: PPUSH
65833: PPUSH
65834: PPUSH
65835: PPUSH
// if not mc_bases then
65836: LD_EXP 59
65840: NOT
65841: IFFALSE 65845
// exit ;
65843: GO 66418
// for i = 1 to mc_bases do
65845: LD_ADDR_VAR 0 2
65849: PUSH
65850: DOUBLE
65851: LD_INT 1
65853: DEC
65854: ST_TO_ADDR
65855: LD_EXP 59
65859: PUSH
65860: FOR_TO
65861: IFFALSE 66409
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
65863: LD_ADDR_VAR 0 5
65867: PUSH
65868: LD_EXP 59
65872: PUSH
65873: LD_VAR 0 2
65877: ARRAY
65878: PUSH
65879: LD_EXP 88
65883: PUSH
65884: LD_VAR 0 2
65888: ARRAY
65889: UNION
65890: PPUSH
65891: LD_INT 21
65893: PUSH
65894: LD_INT 1
65896: PUSH
65897: EMPTY
65898: LIST
65899: LIST
65900: PUSH
65901: LD_INT 1
65903: PUSH
65904: LD_INT 3
65906: PUSH
65907: LD_INT 54
65909: PUSH
65910: EMPTY
65911: LIST
65912: PUSH
65913: EMPTY
65914: LIST
65915: LIST
65916: PUSH
65917: LD_INT 3
65919: PUSH
65920: LD_INT 24
65922: PUSH
65923: LD_INT 800
65925: PUSH
65926: EMPTY
65927: LIST
65928: LIST
65929: PUSH
65930: EMPTY
65931: LIST
65932: LIST
65933: PUSH
65934: EMPTY
65935: LIST
65936: LIST
65937: LIST
65938: PUSH
65939: EMPTY
65940: LIST
65941: LIST
65942: PPUSH
65943: CALL_OW 72
65947: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
65948: LD_ADDR_VAR 0 6
65952: PUSH
65953: LD_EXP 59
65957: PUSH
65958: LD_VAR 0 2
65962: ARRAY
65963: PPUSH
65964: LD_INT 21
65966: PUSH
65967: LD_INT 1
65969: PUSH
65970: EMPTY
65971: LIST
65972: LIST
65973: PUSH
65974: LD_INT 1
65976: PUSH
65977: LD_INT 3
65979: PUSH
65980: LD_INT 54
65982: PUSH
65983: EMPTY
65984: LIST
65985: PUSH
65986: EMPTY
65987: LIST
65988: LIST
65989: PUSH
65990: LD_INT 3
65992: PUSH
65993: LD_INT 24
65995: PUSH
65996: LD_INT 250
65998: PUSH
65999: EMPTY
66000: LIST
66001: LIST
66002: PUSH
66003: EMPTY
66004: LIST
66005: LIST
66006: PUSH
66007: EMPTY
66008: LIST
66009: LIST
66010: LIST
66011: PUSH
66012: EMPTY
66013: LIST
66014: LIST
66015: PPUSH
66016: CALL_OW 72
66020: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
66021: LD_ADDR_VAR 0 7
66025: PUSH
66026: LD_VAR 0 5
66030: PUSH
66031: LD_VAR 0 6
66035: DIFF
66036: ST_TO_ADDR
// if not need_heal_1 then
66037: LD_VAR 0 6
66041: NOT
66042: IFFALSE 66075
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
66044: LD_ADDR_EXP 62
66048: PUSH
66049: LD_EXP 62
66053: PPUSH
66054: LD_VAR 0 2
66058: PUSH
66059: LD_INT 1
66061: PUSH
66062: EMPTY
66063: LIST
66064: LIST
66065: PPUSH
66066: EMPTY
66067: PPUSH
66068: CALL 21529 0 3
66072: ST_TO_ADDR
66073: GO 66145
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
66075: LD_ADDR_EXP 62
66079: PUSH
66080: LD_EXP 62
66084: PPUSH
66085: LD_VAR 0 2
66089: PUSH
66090: LD_INT 1
66092: PUSH
66093: EMPTY
66094: LIST
66095: LIST
66096: PPUSH
66097: LD_EXP 62
66101: PUSH
66102: LD_VAR 0 2
66106: ARRAY
66107: PUSH
66108: LD_INT 1
66110: ARRAY
66111: PPUSH
66112: LD_INT 3
66114: PUSH
66115: LD_INT 24
66117: PUSH
66118: LD_INT 1000
66120: PUSH
66121: EMPTY
66122: LIST
66123: LIST
66124: PUSH
66125: EMPTY
66126: LIST
66127: LIST
66128: PPUSH
66129: CALL_OW 72
66133: PUSH
66134: LD_VAR 0 6
66138: UNION
66139: PPUSH
66140: CALL 21529 0 3
66144: ST_TO_ADDR
// if not need_heal_2 then
66145: LD_VAR 0 7
66149: NOT
66150: IFFALSE 66183
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
66152: LD_ADDR_EXP 62
66156: PUSH
66157: LD_EXP 62
66161: PPUSH
66162: LD_VAR 0 2
66166: PUSH
66167: LD_INT 2
66169: PUSH
66170: EMPTY
66171: LIST
66172: LIST
66173: PPUSH
66174: EMPTY
66175: PPUSH
66176: CALL 21529 0 3
66180: ST_TO_ADDR
66181: GO 66215
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
66183: LD_ADDR_EXP 62
66187: PUSH
66188: LD_EXP 62
66192: PPUSH
66193: LD_VAR 0 2
66197: PUSH
66198: LD_INT 2
66200: PUSH
66201: EMPTY
66202: LIST
66203: LIST
66204: PPUSH
66205: LD_VAR 0 7
66209: PPUSH
66210: CALL 21529 0 3
66214: ST_TO_ADDR
// if need_heal_2 then
66215: LD_VAR 0 7
66219: IFFALSE 66391
// for j in need_heal_2 do
66221: LD_ADDR_VAR 0 3
66225: PUSH
66226: LD_VAR 0 7
66230: PUSH
66231: FOR_IN
66232: IFFALSE 66389
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
66234: LD_ADDR_VAR 0 5
66238: PUSH
66239: LD_EXP 59
66243: PUSH
66244: LD_VAR 0 2
66248: ARRAY
66249: PPUSH
66250: LD_INT 2
66252: PUSH
66253: LD_INT 30
66255: PUSH
66256: LD_INT 6
66258: PUSH
66259: EMPTY
66260: LIST
66261: LIST
66262: PUSH
66263: LD_INT 30
66265: PUSH
66266: LD_INT 7
66268: PUSH
66269: EMPTY
66270: LIST
66271: LIST
66272: PUSH
66273: LD_INT 30
66275: PUSH
66276: LD_INT 8
66278: PUSH
66279: EMPTY
66280: LIST
66281: LIST
66282: PUSH
66283: LD_INT 30
66285: PUSH
66286: LD_INT 0
66288: PUSH
66289: EMPTY
66290: LIST
66291: LIST
66292: PUSH
66293: LD_INT 30
66295: PUSH
66296: LD_INT 1
66298: PUSH
66299: EMPTY
66300: LIST
66301: LIST
66302: PUSH
66303: LD_INT 25
66305: PUSH
66306: LD_INT 4
66308: PUSH
66309: EMPTY
66310: LIST
66311: LIST
66312: PUSH
66313: EMPTY
66314: LIST
66315: LIST
66316: LIST
66317: LIST
66318: LIST
66319: LIST
66320: LIST
66321: PPUSH
66322: CALL_OW 72
66326: ST_TO_ADDR
// if tmp then
66327: LD_VAR 0 5
66331: IFFALSE 66387
// begin k := NearestUnitToUnit ( tmp , j ) ;
66333: LD_ADDR_VAR 0 4
66337: PUSH
66338: LD_VAR 0 5
66342: PPUSH
66343: LD_VAR 0 3
66347: PPUSH
66348: CALL_OW 74
66352: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
66353: LD_VAR 0 3
66357: PPUSH
66358: LD_VAR 0 4
66362: PPUSH
66363: CALL_OW 296
66367: PUSH
66368: LD_INT 7
66370: GREATER
66371: IFFALSE 66387
// ComMoveUnit ( j , k ) ;
66373: LD_VAR 0 3
66377: PPUSH
66378: LD_VAR 0 4
66382: PPUSH
66383: CALL_OW 112
// end ; end ;
66387: GO 66231
66389: POP
66390: POP
// if not need_heal_1 and not need_heal_2 then
66391: LD_VAR 0 6
66395: NOT
66396: PUSH
66397: LD_VAR 0 7
66401: NOT
66402: AND
66403: IFFALSE 66407
// continue ;
66405: GO 65860
// end ;
66407: GO 65860
66409: POP
66410: POP
// RaiseSailEvent ( 102 ) ;
66411: LD_INT 102
66413: PPUSH
66414: CALL_OW 427
// end ;
66418: LD_VAR 0 1
66422: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
66423: LD_INT 0
66425: PPUSH
66426: PPUSH
66427: PPUSH
66428: PPUSH
66429: PPUSH
66430: PPUSH
66431: PPUSH
66432: PPUSH
// if not mc_bases then
66433: LD_EXP 59
66437: NOT
66438: IFFALSE 66442
// exit ;
66440: GO 67282
// for i = 1 to mc_bases do
66442: LD_ADDR_VAR 0 2
66446: PUSH
66447: DOUBLE
66448: LD_INT 1
66450: DEC
66451: ST_TO_ADDR
66452: LD_EXP 59
66456: PUSH
66457: FOR_TO
66458: IFFALSE 67280
// begin if not mc_building_need_repair [ i ] then
66460: LD_EXP 60
66464: PUSH
66465: LD_VAR 0 2
66469: ARRAY
66470: NOT
66471: IFFALSE 66645
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
66473: LD_ADDR_VAR 0 6
66477: PUSH
66478: LD_EXP 78
66482: PUSH
66483: LD_VAR 0 2
66487: ARRAY
66488: PPUSH
66489: LD_INT 3
66491: PUSH
66492: LD_INT 24
66494: PUSH
66495: LD_INT 1000
66497: PUSH
66498: EMPTY
66499: LIST
66500: LIST
66501: PUSH
66502: EMPTY
66503: LIST
66504: LIST
66505: PUSH
66506: LD_INT 2
66508: PUSH
66509: LD_INT 34
66511: PUSH
66512: LD_INT 13
66514: PUSH
66515: EMPTY
66516: LIST
66517: LIST
66518: PUSH
66519: LD_INT 34
66521: PUSH
66522: LD_INT 52
66524: PUSH
66525: EMPTY
66526: LIST
66527: LIST
66528: PUSH
66529: EMPTY
66530: LIST
66531: LIST
66532: LIST
66533: PUSH
66534: EMPTY
66535: LIST
66536: LIST
66537: PPUSH
66538: CALL_OW 72
66542: ST_TO_ADDR
// if cranes then
66543: LD_VAR 0 6
66547: IFFALSE 66609
// for j in cranes do
66549: LD_ADDR_VAR 0 3
66553: PUSH
66554: LD_VAR 0 6
66558: PUSH
66559: FOR_IN
66560: IFFALSE 66607
// if not IsInArea ( j , mc_parking [ i ] ) then
66562: LD_VAR 0 3
66566: PPUSH
66567: LD_EXP 83
66571: PUSH
66572: LD_VAR 0 2
66576: ARRAY
66577: PPUSH
66578: CALL_OW 308
66582: NOT
66583: IFFALSE 66605
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66585: LD_VAR 0 3
66589: PPUSH
66590: LD_EXP 83
66594: PUSH
66595: LD_VAR 0 2
66599: ARRAY
66600: PPUSH
66601: CALL_OW 113
66605: GO 66559
66607: POP
66608: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
66609: LD_ADDR_EXP 61
66613: PUSH
66614: LD_EXP 61
66618: PPUSH
66619: LD_VAR 0 2
66623: PPUSH
66624: EMPTY
66625: PPUSH
66626: CALL_OW 1
66630: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
66631: LD_VAR 0 2
66635: PPUSH
66636: LD_INT 101
66638: PPUSH
66639: CALL 61535 0 2
// continue ;
66643: GO 66457
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
66645: LD_ADDR_EXP 65
66649: PUSH
66650: LD_EXP 65
66654: PPUSH
66655: LD_VAR 0 2
66659: PPUSH
66660: EMPTY
66661: PPUSH
66662: CALL_OW 1
66666: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66667: LD_VAR 0 2
66671: PPUSH
66672: LD_INT 103
66674: PPUSH
66675: CALL 61535 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
66679: LD_ADDR_VAR 0 5
66683: PUSH
66684: LD_EXP 59
66688: PUSH
66689: LD_VAR 0 2
66693: ARRAY
66694: PUSH
66695: LD_EXP 88
66699: PUSH
66700: LD_VAR 0 2
66704: ARRAY
66705: UNION
66706: PPUSH
66707: LD_INT 2
66709: PUSH
66710: LD_INT 25
66712: PUSH
66713: LD_INT 2
66715: PUSH
66716: EMPTY
66717: LIST
66718: LIST
66719: PUSH
66720: LD_INT 25
66722: PUSH
66723: LD_INT 16
66725: PUSH
66726: EMPTY
66727: LIST
66728: LIST
66729: PUSH
66730: EMPTY
66731: LIST
66732: LIST
66733: LIST
66734: PUSH
66735: EMPTY
66736: LIST
66737: PPUSH
66738: CALL_OW 72
66742: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
66743: LD_ADDR_VAR 0 6
66747: PUSH
66748: LD_EXP 78
66752: PUSH
66753: LD_VAR 0 2
66757: ARRAY
66758: PPUSH
66759: LD_INT 2
66761: PUSH
66762: LD_INT 34
66764: PUSH
66765: LD_INT 13
66767: PUSH
66768: EMPTY
66769: LIST
66770: LIST
66771: PUSH
66772: LD_INT 34
66774: PUSH
66775: LD_INT 52
66777: PUSH
66778: EMPTY
66779: LIST
66780: LIST
66781: PUSH
66782: EMPTY
66783: LIST
66784: LIST
66785: LIST
66786: PPUSH
66787: CALL_OW 72
66791: ST_TO_ADDR
// if cranes then
66792: LD_VAR 0 6
66796: IFFALSE 66932
// begin for j in cranes do
66798: LD_ADDR_VAR 0 3
66802: PUSH
66803: LD_VAR 0 6
66807: PUSH
66808: FOR_IN
66809: IFFALSE 66930
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
66811: LD_VAR 0 3
66815: PPUSH
66816: CALL_OW 256
66820: PUSH
66821: LD_INT 500
66823: GREATEREQUAL
66824: PUSH
66825: LD_VAR 0 3
66829: PPUSH
66830: CALL_OW 314
66834: NOT
66835: AND
66836: IFFALSE 66870
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
66838: LD_VAR 0 3
66842: PPUSH
66843: LD_EXP 60
66847: PUSH
66848: LD_VAR 0 2
66852: ARRAY
66853: PPUSH
66854: LD_VAR 0 3
66858: PPUSH
66859: CALL_OW 74
66863: PPUSH
66864: CALL_OW 130
66868: GO 66928
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
66870: LD_VAR 0 3
66874: PPUSH
66875: CALL_OW 256
66879: PUSH
66880: LD_INT 500
66882: LESS
66883: PUSH
66884: LD_VAR 0 3
66888: PPUSH
66889: LD_EXP 83
66893: PUSH
66894: LD_VAR 0 2
66898: ARRAY
66899: PPUSH
66900: CALL_OW 308
66904: NOT
66905: AND
66906: IFFALSE 66928
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66908: LD_VAR 0 3
66912: PPUSH
66913: LD_EXP 83
66917: PUSH
66918: LD_VAR 0 2
66922: ARRAY
66923: PPUSH
66924: CALL_OW 113
66928: GO 66808
66930: POP
66931: POP
// end ; if not tmp then
66932: LD_VAR 0 5
66936: NOT
66937: IFFALSE 66941
// continue ;
66939: GO 66457
// for j in tmp do
66941: LD_ADDR_VAR 0 3
66945: PUSH
66946: LD_VAR 0 5
66950: PUSH
66951: FOR_IN
66952: IFFALSE 67276
// begin if mc_need_heal [ i ] then
66954: LD_EXP 62
66958: PUSH
66959: LD_VAR 0 2
66963: ARRAY
66964: IFFALSE 67012
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
66966: LD_VAR 0 3
66970: PUSH
66971: LD_EXP 62
66975: PUSH
66976: LD_VAR 0 2
66980: ARRAY
66981: PUSH
66982: LD_INT 1
66984: ARRAY
66985: IN
66986: PUSH
66987: LD_VAR 0 3
66991: PUSH
66992: LD_EXP 62
66996: PUSH
66997: LD_VAR 0 2
67001: ARRAY
67002: PUSH
67003: LD_INT 2
67005: ARRAY
67006: IN
67007: OR
67008: IFFALSE 67012
// continue ;
67010: GO 66951
// if IsInUnit ( j ) then
67012: LD_VAR 0 3
67016: PPUSH
67017: CALL_OW 310
67021: IFFALSE 67032
// ComExitBuilding ( j ) ;
67023: LD_VAR 0 3
67027: PPUSH
67028: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
67032: LD_VAR 0 3
67036: PUSH
67037: LD_EXP 61
67041: PUSH
67042: LD_VAR 0 2
67046: ARRAY
67047: IN
67048: NOT
67049: IFFALSE 67107
// begin SetTag ( j , 101 ) ;
67051: LD_VAR 0 3
67055: PPUSH
67056: LD_INT 101
67058: PPUSH
67059: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
67063: LD_ADDR_EXP 61
67067: PUSH
67068: LD_EXP 61
67072: PPUSH
67073: LD_VAR 0 2
67077: PUSH
67078: LD_EXP 61
67082: PUSH
67083: LD_VAR 0 2
67087: ARRAY
67088: PUSH
67089: LD_INT 1
67091: PLUS
67092: PUSH
67093: EMPTY
67094: LIST
67095: LIST
67096: PPUSH
67097: LD_VAR 0 3
67101: PPUSH
67102: CALL 21529 0 3
67106: ST_TO_ADDR
// end ; wait ( 1 ) ;
67107: LD_INT 1
67109: PPUSH
67110: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
67114: LD_ADDR_VAR 0 7
67118: PUSH
67119: LD_EXP 60
67123: PUSH
67124: LD_VAR 0 2
67128: ARRAY
67129: ST_TO_ADDR
// if mc_scan [ i ] then
67130: LD_EXP 82
67134: PUSH
67135: LD_VAR 0 2
67139: ARRAY
67140: IFFALSE 67209
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
67142: LD_ADDR_VAR 0 7
67146: PUSH
67147: LD_EXP 60
67151: PUSH
67152: LD_VAR 0 2
67156: ARRAY
67157: PPUSH
67158: LD_INT 3
67160: PUSH
67161: LD_INT 2
67163: PUSH
67164: LD_INT 30
67166: PUSH
67167: LD_INT 32
67169: PUSH
67170: EMPTY
67171: LIST
67172: LIST
67173: PUSH
67174: LD_INT 30
67176: PUSH
67177: LD_INT 33
67179: PUSH
67180: EMPTY
67181: LIST
67182: LIST
67183: PUSH
67184: LD_INT 30
67186: PUSH
67187: LD_INT 31
67189: PUSH
67190: EMPTY
67191: LIST
67192: LIST
67193: PUSH
67194: EMPTY
67195: LIST
67196: LIST
67197: LIST
67198: LIST
67199: PUSH
67200: EMPTY
67201: LIST
67202: LIST
67203: PPUSH
67204: CALL_OW 72
67208: ST_TO_ADDR
// if not to_repair_tmp then
67209: LD_VAR 0 7
67213: NOT
67214: IFFALSE 67218
// continue ;
67216: GO 66951
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
67218: LD_ADDR_VAR 0 8
67222: PUSH
67223: LD_VAR 0 7
67227: PPUSH
67228: LD_VAR 0 3
67232: PPUSH
67233: CALL_OW 74
67237: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
67238: LD_VAR 0 8
67242: PPUSH
67243: LD_INT 14
67245: PPUSH
67246: CALL 24122 0 2
67250: PUSH
67251: LD_INT 4
67253: ARRAY
67254: PUSH
67255: LD_INT 5
67257: LESS
67258: IFFALSE 67274
// ComRepairBuilding ( j , to_repair ) ;
67260: LD_VAR 0 3
67264: PPUSH
67265: LD_VAR 0 8
67269: PPUSH
67270: CALL_OW 130
// end ;
67274: GO 66951
67276: POP
67277: POP
// end ;
67278: GO 66457
67280: POP
67281: POP
// end ;
67282: LD_VAR 0 1
67286: RET
// export function MC_Heal ; var i , j , tmp ; begin
67287: LD_INT 0
67289: PPUSH
67290: PPUSH
67291: PPUSH
67292: PPUSH
// if not mc_bases then
67293: LD_EXP 59
67297: NOT
67298: IFFALSE 67302
// exit ;
67300: GO 67704
// for i = 1 to mc_bases do
67302: LD_ADDR_VAR 0 2
67306: PUSH
67307: DOUBLE
67308: LD_INT 1
67310: DEC
67311: ST_TO_ADDR
67312: LD_EXP 59
67316: PUSH
67317: FOR_TO
67318: IFFALSE 67702
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
67320: LD_EXP 62
67324: PUSH
67325: LD_VAR 0 2
67329: ARRAY
67330: PUSH
67331: LD_INT 1
67333: ARRAY
67334: NOT
67335: PUSH
67336: LD_EXP 62
67340: PUSH
67341: LD_VAR 0 2
67345: ARRAY
67346: PUSH
67347: LD_INT 2
67349: ARRAY
67350: NOT
67351: AND
67352: IFFALSE 67390
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
67354: LD_ADDR_EXP 63
67358: PUSH
67359: LD_EXP 63
67363: PPUSH
67364: LD_VAR 0 2
67368: PPUSH
67369: EMPTY
67370: PPUSH
67371: CALL_OW 1
67375: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
67376: LD_VAR 0 2
67380: PPUSH
67381: LD_INT 102
67383: PPUSH
67384: CALL 61535 0 2
// continue ;
67388: GO 67317
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
67390: LD_ADDR_VAR 0 4
67394: PUSH
67395: LD_EXP 59
67399: PUSH
67400: LD_VAR 0 2
67404: ARRAY
67405: PPUSH
67406: LD_INT 25
67408: PUSH
67409: LD_INT 4
67411: PUSH
67412: EMPTY
67413: LIST
67414: LIST
67415: PPUSH
67416: CALL_OW 72
67420: ST_TO_ADDR
// if not tmp then
67421: LD_VAR 0 4
67425: NOT
67426: IFFALSE 67430
// continue ;
67428: GO 67317
// if mc_taming [ i ] then
67430: LD_EXP 90
67434: PUSH
67435: LD_VAR 0 2
67439: ARRAY
67440: IFFALSE 67464
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
67442: LD_ADDR_EXP 90
67446: PUSH
67447: LD_EXP 90
67451: PPUSH
67452: LD_VAR 0 2
67456: PPUSH
67457: EMPTY
67458: PPUSH
67459: CALL_OW 1
67463: ST_TO_ADDR
// for j in tmp do
67464: LD_ADDR_VAR 0 3
67468: PUSH
67469: LD_VAR 0 4
67473: PUSH
67474: FOR_IN
67475: IFFALSE 67698
// begin if IsInUnit ( j ) then
67477: LD_VAR 0 3
67481: PPUSH
67482: CALL_OW 310
67486: IFFALSE 67497
// ComExitBuilding ( j ) ;
67488: LD_VAR 0 3
67492: PPUSH
67493: CALL_OW 122
// if not j in mc_healers [ i ] then
67497: LD_VAR 0 3
67501: PUSH
67502: LD_EXP 63
67506: PUSH
67507: LD_VAR 0 2
67511: ARRAY
67512: IN
67513: NOT
67514: IFFALSE 67560
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
67516: LD_ADDR_EXP 63
67520: PUSH
67521: LD_EXP 63
67525: PPUSH
67526: LD_VAR 0 2
67530: PUSH
67531: LD_EXP 63
67535: PUSH
67536: LD_VAR 0 2
67540: ARRAY
67541: PUSH
67542: LD_INT 1
67544: PLUS
67545: PUSH
67546: EMPTY
67547: LIST
67548: LIST
67549: PPUSH
67550: LD_VAR 0 3
67554: PPUSH
67555: CALL 21529 0 3
67559: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
67560: LD_VAR 0 3
67564: PPUSH
67565: CALL_OW 110
67569: PUSH
67570: LD_INT 102
67572: NONEQUAL
67573: IFFALSE 67587
// SetTag ( j , 102 ) ;
67575: LD_VAR 0 3
67579: PPUSH
67580: LD_INT 102
67582: PPUSH
67583: CALL_OW 109
// Wait ( 3 ) ;
67587: LD_INT 3
67589: PPUSH
67590: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
67594: LD_EXP 62
67598: PUSH
67599: LD_VAR 0 2
67603: ARRAY
67604: PUSH
67605: LD_INT 1
67607: ARRAY
67608: IFFALSE 67640
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
67610: LD_VAR 0 3
67614: PPUSH
67615: LD_EXP 62
67619: PUSH
67620: LD_VAR 0 2
67624: ARRAY
67625: PUSH
67626: LD_INT 1
67628: ARRAY
67629: PUSH
67630: LD_INT 1
67632: ARRAY
67633: PPUSH
67634: CALL_OW 128
67638: GO 67696
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
67640: LD_VAR 0 3
67644: PPUSH
67645: CALL_OW 314
67649: NOT
67650: PUSH
67651: LD_EXP 62
67655: PUSH
67656: LD_VAR 0 2
67660: ARRAY
67661: PUSH
67662: LD_INT 2
67664: ARRAY
67665: AND
67666: IFFALSE 67696
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
67668: LD_VAR 0 3
67672: PPUSH
67673: LD_EXP 62
67677: PUSH
67678: LD_VAR 0 2
67682: ARRAY
67683: PUSH
67684: LD_INT 2
67686: ARRAY
67687: PUSH
67688: LD_INT 1
67690: ARRAY
67691: PPUSH
67692: CALL_OW 128
// end ;
67696: GO 67474
67698: POP
67699: POP
// end ;
67700: GO 67317
67702: POP
67703: POP
// end ;
67704: LD_VAR 0 1
67708: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
67709: LD_INT 0
67711: PPUSH
67712: PPUSH
67713: PPUSH
67714: PPUSH
67715: PPUSH
// if not mc_bases then
67716: LD_EXP 59
67720: NOT
67721: IFFALSE 67725
// exit ;
67723: GO 68868
// for i = 1 to mc_bases do
67725: LD_ADDR_VAR 0 2
67729: PUSH
67730: DOUBLE
67731: LD_INT 1
67733: DEC
67734: ST_TO_ADDR
67735: LD_EXP 59
67739: PUSH
67740: FOR_TO
67741: IFFALSE 68866
// begin if mc_scan [ i ] then
67743: LD_EXP 82
67747: PUSH
67748: LD_VAR 0 2
67752: ARRAY
67753: IFFALSE 67757
// continue ;
67755: GO 67740
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
67757: LD_EXP 64
67761: PUSH
67762: LD_VAR 0 2
67766: ARRAY
67767: NOT
67768: PUSH
67769: LD_EXP 66
67773: PUSH
67774: LD_VAR 0 2
67778: ARRAY
67779: NOT
67780: AND
67781: PUSH
67782: LD_EXP 65
67786: PUSH
67787: LD_VAR 0 2
67791: ARRAY
67792: AND
67793: IFFALSE 67831
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
67795: LD_ADDR_EXP 65
67799: PUSH
67800: LD_EXP 65
67804: PPUSH
67805: LD_VAR 0 2
67809: PPUSH
67810: EMPTY
67811: PPUSH
67812: CALL_OW 1
67816: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
67817: LD_VAR 0 2
67821: PPUSH
67822: LD_INT 103
67824: PPUSH
67825: CALL 61535 0 2
// continue ;
67829: GO 67740
// end ; if mc_construct_list [ i ] then
67831: LD_EXP 66
67835: PUSH
67836: LD_VAR 0 2
67840: ARRAY
67841: IFFALSE 68061
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67843: LD_ADDR_VAR 0 4
67847: PUSH
67848: LD_EXP 59
67852: PUSH
67853: LD_VAR 0 2
67857: ARRAY
67858: PPUSH
67859: LD_INT 25
67861: PUSH
67862: LD_INT 2
67864: PUSH
67865: EMPTY
67866: LIST
67867: LIST
67868: PPUSH
67869: CALL_OW 72
67873: PUSH
67874: LD_EXP 61
67878: PUSH
67879: LD_VAR 0 2
67883: ARRAY
67884: DIFF
67885: ST_TO_ADDR
// if not tmp then
67886: LD_VAR 0 4
67890: NOT
67891: IFFALSE 67895
// continue ;
67893: GO 67740
// for j in tmp do
67895: LD_ADDR_VAR 0 3
67899: PUSH
67900: LD_VAR 0 4
67904: PUSH
67905: FOR_IN
67906: IFFALSE 68057
// begin if not mc_builders [ i ] then
67908: LD_EXP 65
67912: PUSH
67913: LD_VAR 0 2
67917: ARRAY
67918: NOT
67919: IFFALSE 67977
// begin SetTag ( j , 103 ) ;
67921: LD_VAR 0 3
67925: PPUSH
67926: LD_INT 103
67928: PPUSH
67929: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67933: LD_ADDR_EXP 65
67937: PUSH
67938: LD_EXP 65
67942: PPUSH
67943: LD_VAR 0 2
67947: PUSH
67948: LD_EXP 65
67952: PUSH
67953: LD_VAR 0 2
67957: ARRAY
67958: PUSH
67959: LD_INT 1
67961: PLUS
67962: PUSH
67963: EMPTY
67964: LIST
67965: LIST
67966: PPUSH
67967: LD_VAR 0 3
67971: PPUSH
67972: CALL 21529 0 3
67976: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67977: LD_VAR 0 3
67981: PPUSH
67982: CALL_OW 310
67986: IFFALSE 67997
// ComExitBuilding ( j ) ;
67988: LD_VAR 0 3
67992: PPUSH
67993: CALL_OW 122
// wait ( 3 ) ;
67997: LD_INT 3
67999: PPUSH
68000: CALL_OW 67
// if not mc_construct_list [ i ] then
68004: LD_EXP 66
68008: PUSH
68009: LD_VAR 0 2
68013: ARRAY
68014: NOT
68015: IFFALSE 68019
// break ;
68017: GO 68057
// if not HasTask ( j ) then
68019: LD_VAR 0 3
68023: PPUSH
68024: CALL_OW 314
68028: NOT
68029: IFFALSE 68055
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
68031: LD_VAR 0 3
68035: PPUSH
68036: LD_EXP 66
68040: PUSH
68041: LD_VAR 0 2
68045: ARRAY
68046: PUSH
68047: LD_INT 1
68049: ARRAY
68050: PPUSH
68051: CALL 24380 0 2
// end ;
68055: GO 67905
68057: POP
68058: POP
// end else
68059: GO 68864
// if mc_build_list [ i ] then
68061: LD_EXP 64
68065: PUSH
68066: LD_VAR 0 2
68070: ARRAY
68071: IFFALSE 68864
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68073: LD_ADDR_VAR 0 5
68077: PUSH
68078: LD_EXP 59
68082: PUSH
68083: LD_VAR 0 2
68087: ARRAY
68088: PPUSH
68089: LD_INT 2
68091: PUSH
68092: LD_INT 30
68094: PUSH
68095: LD_INT 0
68097: PUSH
68098: EMPTY
68099: LIST
68100: LIST
68101: PUSH
68102: LD_INT 30
68104: PUSH
68105: LD_INT 1
68107: PUSH
68108: EMPTY
68109: LIST
68110: LIST
68111: PUSH
68112: EMPTY
68113: LIST
68114: LIST
68115: LIST
68116: PPUSH
68117: CALL_OW 72
68121: ST_TO_ADDR
// if depot then
68122: LD_VAR 0 5
68126: IFFALSE 68144
// depot := depot [ 1 ] else
68128: LD_ADDR_VAR 0 5
68132: PUSH
68133: LD_VAR 0 5
68137: PUSH
68138: LD_INT 1
68140: ARRAY
68141: ST_TO_ADDR
68142: GO 68152
// depot := 0 ;
68144: LD_ADDR_VAR 0 5
68148: PUSH
68149: LD_INT 0
68151: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
68152: LD_EXP 64
68156: PUSH
68157: LD_VAR 0 2
68161: ARRAY
68162: PUSH
68163: LD_INT 1
68165: ARRAY
68166: PUSH
68167: LD_INT 1
68169: ARRAY
68170: PPUSH
68171: CALL 24210 0 1
68175: PUSH
68176: LD_EXP 59
68180: PUSH
68181: LD_VAR 0 2
68185: ARRAY
68186: PPUSH
68187: LD_INT 2
68189: PUSH
68190: LD_INT 30
68192: PUSH
68193: LD_INT 2
68195: PUSH
68196: EMPTY
68197: LIST
68198: LIST
68199: PUSH
68200: LD_INT 30
68202: PUSH
68203: LD_INT 3
68205: PUSH
68206: EMPTY
68207: LIST
68208: LIST
68209: PUSH
68210: EMPTY
68211: LIST
68212: LIST
68213: LIST
68214: PPUSH
68215: CALL_OW 72
68219: NOT
68220: AND
68221: IFFALSE 68326
// begin for j = 1 to mc_build_list [ i ] do
68223: LD_ADDR_VAR 0 3
68227: PUSH
68228: DOUBLE
68229: LD_INT 1
68231: DEC
68232: ST_TO_ADDR
68233: LD_EXP 64
68237: PUSH
68238: LD_VAR 0 2
68242: ARRAY
68243: PUSH
68244: FOR_TO
68245: IFFALSE 68324
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
68247: LD_EXP 64
68251: PUSH
68252: LD_VAR 0 2
68256: ARRAY
68257: PUSH
68258: LD_VAR 0 3
68262: ARRAY
68263: PUSH
68264: LD_INT 1
68266: ARRAY
68267: PUSH
68268: LD_INT 2
68270: EQUAL
68271: IFFALSE 68322
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
68273: LD_ADDR_EXP 64
68277: PUSH
68278: LD_EXP 64
68282: PPUSH
68283: LD_VAR 0 2
68287: PPUSH
68288: LD_EXP 64
68292: PUSH
68293: LD_VAR 0 2
68297: ARRAY
68298: PPUSH
68299: LD_VAR 0 3
68303: PPUSH
68304: LD_INT 1
68306: PPUSH
68307: LD_INT 0
68309: PPUSH
68310: CALL 20947 0 4
68314: PPUSH
68315: CALL_OW 1
68319: ST_TO_ADDR
// break ;
68320: GO 68324
// end ;
68322: GO 68244
68324: POP
68325: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
68326: LD_EXP 64
68330: PUSH
68331: LD_VAR 0 2
68335: ARRAY
68336: PUSH
68337: LD_INT 1
68339: ARRAY
68340: PUSH
68341: LD_INT 1
68343: ARRAY
68344: PUSH
68345: LD_INT 0
68347: EQUAL
68348: PUSH
68349: LD_VAR 0 5
68353: PUSH
68354: LD_VAR 0 5
68358: PPUSH
68359: LD_EXP 64
68363: PUSH
68364: LD_VAR 0 2
68368: ARRAY
68369: PUSH
68370: LD_INT 1
68372: ARRAY
68373: PUSH
68374: LD_INT 1
68376: ARRAY
68377: PPUSH
68378: LD_EXP 64
68382: PUSH
68383: LD_VAR 0 2
68387: ARRAY
68388: PUSH
68389: LD_INT 1
68391: ARRAY
68392: PUSH
68393: LD_INT 2
68395: ARRAY
68396: PPUSH
68397: LD_EXP 64
68401: PUSH
68402: LD_VAR 0 2
68406: ARRAY
68407: PUSH
68408: LD_INT 1
68410: ARRAY
68411: PUSH
68412: LD_INT 3
68414: ARRAY
68415: PPUSH
68416: LD_EXP 64
68420: PUSH
68421: LD_VAR 0 2
68425: ARRAY
68426: PUSH
68427: LD_INT 1
68429: ARRAY
68430: PUSH
68431: LD_INT 4
68433: ARRAY
68434: PPUSH
68435: CALL 28944 0 5
68439: AND
68440: OR
68441: IFFALSE 68722
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
68443: LD_ADDR_VAR 0 4
68447: PUSH
68448: LD_EXP 59
68452: PUSH
68453: LD_VAR 0 2
68457: ARRAY
68458: PPUSH
68459: LD_INT 25
68461: PUSH
68462: LD_INT 2
68464: PUSH
68465: EMPTY
68466: LIST
68467: LIST
68468: PPUSH
68469: CALL_OW 72
68473: PUSH
68474: LD_EXP 61
68478: PUSH
68479: LD_VAR 0 2
68483: ARRAY
68484: DIFF
68485: ST_TO_ADDR
// if not tmp then
68486: LD_VAR 0 4
68490: NOT
68491: IFFALSE 68495
// continue ;
68493: GO 67740
// for j in tmp do
68495: LD_ADDR_VAR 0 3
68499: PUSH
68500: LD_VAR 0 4
68504: PUSH
68505: FOR_IN
68506: IFFALSE 68718
// begin if not mc_builders [ i ] then
68508: LD_EXP 65
68512: PUSH
68513: LD_VAR 0 2
68517: ARRAY
68518: NOT
68519: IFFALSE 68577
// begin SetTag ( j , 103 ) ;
68521: LD_VAR 0 3
68525: PPUSH
68526: LD_INT 103
68528: PPUSH
68529: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
68533: LD_ADDR_EXP 65
68537: PUSH
68538: LD_EXP 65
68542: PPUSH
68543: LD_VAR 0 2
68547: PUSH
68548: LD_EXP 65
68552: PUSH
68553: LD_VAR 0 2
68557: ARRAY
68558: PUSH
68559: LD_INT 1
68561: PLUS
68562: PUSH
68563: EMPTY
68564: LIST
68565: LIST
68566: PPUSH
68567: LD_VAR 0 3
68571: PPUSH
68572: CALL 21529 0 3
68576: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
68577: LD_VAR 0 3
68581: PPUSH
68582: CALL_OW 310
68586: IFFALSE 68597
// ComExitBuilding ( j ) ;
68588: LD_VAR 0 3
68592: PPUSH
68593: CALL_OW 122
// wait ( 3 ) ;
68597: LD_INT 3
68599: PPUSH
68600: CALL_OW 67
// if not mc_build_list [ i ] then
68604: LD_EXP 64
68608: PUSH
68609: LD_VAR 0 2
68613: ARRAY
68614: NOT
68615: IFFALSE 68619
// break ;
68617: GO 68718
// if not HasTask ( j ) then
68619: LD_VAR 0 3
68623: PPUSH
68624: CALL_OW 314
68628: NOT
68629: IFFALSE 68716
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
68631: LD_VAR 0 3
68635: PPUSH
68636: LD_EXP 64
68640: PUSH
68641: LD_VAR 0 2
68645: ARRAY
68646: PUSH
68647: LD_INT 1
68649: ARRAY
68650: PUSH
68651: LD_INT 1
68653: ARRAY
68654: PPUSH
68655: LD_EXP 64
68659: PUSH
68660: LD_VAR 0 2
68664: ARRAY
68665: PUSH
68666: LD_INT 1
68668: ARRAY
68669: PUSH
68670: LD_INT 2
68672: ARRAY
68673: PPUSH
68674: LD_EXP 64
68678: PUSH
68679: LD_VAR 0 2
68683: ARRAY
68684: PUSH
68685: LD_INT 1
68687: ARRAY
68688: PUSH
68689: LD_INT 3
68691: ARRAY
68692: PPUSH
68693: LD_EXP 64
68697: PUSH
68698: LD_VAR 0 2
68702: ARRAY
68703: PUSH
68704: LD_INT 1
68706: ARRAY
68707: PUSH
68708: LD_INT 4
68710: ARRAY
68711: PPUSH
68712: CALL_OW 145
// end ;
68716: GO 68505
68718: POP
68719: POP
// end else
68720: GO 68864
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
68722: LD_EXP 59
68726: PUSH
68727: LD_VAR 0 2
68731: ARRAY
68732: PPUSH
68733: LD_EXP 64
68737: PUSH
68738: LD_VAR 0 2
68742: ARRAY
68743: PUSH
68744: LD_INT 1
68746: ARRAY
68747: PUSH
68748: LD_INT 1
68750: ARRAY
68751: PPUSH
68752: LD_EXP 64
68756: PUSH
68757: LD_VAR 0 2
68761: ARRAY
68762: PUSH
68763: LD_INT 1
68765: ARRAY
68766: PUSH
68767: LD_INT 2
68769: ARRAY
68770: PPUSH
68771: LD_EXP 64
68775: PUSH
68776: LD_VAR 0 2
68780: ARRAY
68781: PUSH
68782: LD_INT 1
68784: ARRAY
68785: PUSH
68786: LD_INT 3
68788: ARRAY
68789: PPUSH
68790: LD_EXP 64
68794: PUSH
68795: LD_VAR 0 2
68799: ARRAY
68800: PUSH
68801: LD_INT 1
68803: ARRAY
68804: PUSH
68805: LD_INT 4
68807: ARRAY
68808: PPUSH
68809: CALL 28280 0 5
68813: NOT
68814: IFFALSE 68864
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
68816: LD_ADDR_EXP 64
68820: PUSH
68821: LD_EXP 64
68825: PPUSH
68826: LD_VAR 0 2
68830: PPUSH
68831: LD_EXP 64
68835: PUSH
68836: LD_VAR 0 2
68840: ARRAY
68841: PPUSH
68842: LD_INT 1
68844: PPUSH
68845: LD_INT 1
68847: NEG
68848: PPUSH
68849: LD_INT 0
68851: PPUSH
68852: CALL 20947 0 4
68856: PPUSH
68857: CALL_OW 1
68861: ST_TO_ADDR
// continue ;
68862: GO 67740
// end ; end ; end ;
68864: GO 67740
68866: POP
68867: POP
// end ;
68868: LD_VAR 0 1
68872: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
68873: LD_INT 0
68875: PPUSH
68876: PPUSH
68877: PPUSH
68878: PPUSH
68879: PPUSH
68880: PPUSH
// if not mc_bases then
68881: LD_EXP 59
68885: NOT
68886: IFFALSE 68890
// exit ;
68888: GO 69317
// for i = 1 to mc_bases do
68890: LD_ADDR_VAR 0 2
68894: PUSH
68895: DOUBLE
68896: LD_INT 1
68898: DEC
68899: ST_TO_ADDR
68900: LD_EXP 59
68904: PUSH
68905: FOR_TO
68906: IFFALSE 69315
// begin tmp := mc_build_upgrade [ i ] ;
68908: LD_ADDR_VAR 0 4
68912: PUSH
68913: LD_EXP 91
68917: PUSH
68918: LD_VAR 0 2
68922: ARRAY
68923: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
68924: LD_ADDR_VAR 0 6
68928: PUSH
68929: LD_EXP 92
68933: PUSH
68934: LD_VAR 0 2
68938: ARRAY
68939: PPUSH
68940: LD_INT 2
68942: PUSH
68943: LD_INT 30
68945: PUSH
68946: LD_INT 6
68948: PUSH
68949: EMPTY
68950: LIST
68951: LIST
68952: PUSH
68953: LD_INT 30
68955: PUSH
68956: LD_INT 7
68958: PUSH
68959: EMPTY
68960: LIST
68961: LIST
68962: PUSH
68963: EMPTY
68964: LIST
68965: LIST
68966: LIST
68967: PPUSH
68968: CALL_OW 72
68972: ST_TO_ADDR
// if not tmp and not lab then
68973: LD_VAR 0 4
68977: NOT
68978: PUSH
68979: LD_VAR 0 6
68983: NOT
68984: AND
68985: IFFALSE 68989
// continue ;
68987: GO 68905
// if tmp then
68989: LD_VAR 0 4
68993: IFFALSE 69113
// for j in tmp do
68995: LD_ADDR_VAR 0 3
68999: PUSH
69000: LD_VAR 0 4
69004: PUSH
69005: FOR_IN
69006: IFFALSE 69111
// begin if UpgradeCost ( j ) then
69008: LD_VAR 0 3
69012: PPUSH
69013: CALL 27940 0 1
69017: IFFALSE 69109
// begin ComUpgrade ( j ) ;
69019: LD_VAR 0 3
69023: PPUSH
69024: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
69028: LD_ADDR_EXP 91
69032: PUSH
69033: LD_EXP 91
69037: PPUSH
69038: LD_VAR 0 2
69042: PPUSH
69043: LD_EXP 91
69047: PUSH
69048: LD_VAR 0 2
69052: ARRAY
69053: PUSH
69054: LD_VAR 0 3
69058: DIFF
69059: PPUSH
69060: CALL_OW 1
69064: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
69065: LD_ADDR_EXP 66
69069: PUSH
69070: LD_EXP 66
69074: PPUSH
69075: LD_VAR 0 2
69079: PUSH
69080: LD_EXP 66
69084: PUSH
69085: LD_VAR 0 2
69089: ARRAY
69090: PUSH
69091: LD_INT 1
69093: PLUS
69094: PUSH
69095: EMPTY
69096: LIST
69097: LIST
69098: PPUSH
69099: LD_VAR 0 3
69103: PPUSH
69104: CALL 21529 0 3
69108: ST_TO_ADDR
// end ; end ;
69109: GO 69005
69111: POP
69112: POP
// if not lab or not mc_lab_upgrade [ i ] then
69113: LD_VAR 0 6
69117: NOT
69118: PUSH
69119: LD_EXP 93
69123: PUSH
69124: LD_VAR 0 2
69128: ARRAY
69129: NOT
69130: OR
69131: IFFALSE 69135
// continue ;
69133: GO 68905
// for j in lab do
69135: LD_ADDR_VAR 0 3
69139: PUSH
69140: LD_VAR 0 6
69144: PUSH
69145: FOR_IN
69146: IFFALSE 69311
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
69148: LD_VAR 0 3
69152: PPUSH
69153: CALL_OW 266
69157: PUSH
69158: LD_INT 6
69160: PUSH
69161: LD_INT 7
69163: PUSH
69164: EMPTY
69165: LIST
69166: LIST
69167: IN
69168: PUSH
69169: LD_VAR 0 3
69173: PPUSH
69174: CALL_OW 461
69178: PUSH
69179: LD_INT 1
69181: NONEQUAL
69182: AND
69183: IFFALSE 69309
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
69185: LD_VAR 0 3
69189: PPUSH
69190: LD_EXP 93
69194: PUSH
69195: LD_VAR 0 2
69199: ARRAY
69200: PUSH
69201: LD_INT 1
69203: ARRAY
69204: PPUSH
69205: CALL 28145 0 2
69209: IFFALSE 69309
// begin ComCancel ( j ) ;
69211: LD_VAR 0 3
69215: PPUSH
69216: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
69220: LD_VAR 0 3
69224: PPUSH
69225: LD_EXP 93
69229: PUSH
69230: LD_VAR 0 2
69234: ARRAY
69235: PUSH
69236: LD_INT 1
69238: ARRAY
69239: PPUSH
69240: CALL_OW 207
// if not j in mc_construct_list [ i ] then
69244: LD_VAR 0 3
69248: PUSH
69249: LD_EXP 66
69253: PUSH
69254: LD_VAR 0 2
69258: ARRAY
69259: IN
69260: NOT
69261: IFFALSE 69307
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
69263: LD_ADDR_EXP 66
69267: PUSH
69268: LD_EXP 66
69272: PPUSH
69273: LD_VAR 0 2
69277: PUSH
69278: LD_EXP 66
69282: PUSH
69283: LD_VAR 0 2
69287: ARRAY
69288: PUSH
69289: LD_INT 1
69291: PLUS
69292: PUSH
69293: EMPTY
69294: LIST
69295: LIST
69296: PPUSH
69297: LD_VAR 0 3
69301: PPUSH
69302: CALL 21529 0 3
69306: ST_TO_ADDR
// break ;
69307: GO 69311
// end ; end ; end ;
69309: GO 69145
69311: POP
69312: POP
// end ;
69313: GO 68905
69315: POP
69316: POP
// end ;
69317: LD_VAR 0 1
69321: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
69322: LD_INT 0
69324: PPUSH
69325: PPUSH
69326: PPUSH
69327: PPUSH
69328: PPUSH
69329: PPUSH
69330: PPUSH
69331: PPUSH
69332: PPUSH
// if not mc_bases then
69333: LD_EXP 59
69337: NOT
69338: IFFALSE 69342
// exit ;
69340: GO 69747
// for i = 1 to mc_bases do
69342: LD_ADDR_VAR 0 2
69346: PUSH
69347: DOUBLE
69348: LD_INT 1
69350: DEC
69351: ST_TO_ADDR
69352: LD_EXP 59
69356: PUSH
69357: FOR_TO
69358: IFFALSE 69745
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
69360: LD_EXP 67
69364: PUSH
69365: LD_VAR 0 2
69369: ARRAY
69370: NOT
69371: PUSH
69372: LD_EXP 59
69376: PUSH
69377: LD_VAR 0 2
69381: ARRAY
69382: PPUSH
69383: LD_INT 30
69385: PUSH
69386: LD_INT 3
69388: PUSH
69389: EMPTY
69390: LIST
69391: LIST
69392: PPUSH
69393: CALL_OW 72
69397: NOT
69398: OR
69399: IFFALSE 69403
// continue ;
69401: GO 69357
// busy := false ;
69403: LD_ADDR_VAR 0 8
69407: PUSH
69408: LD_INT 0
69410: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69411: LD_ADDR_VAR 0 4
69415: PUSH
69416: LD_EXP 59
69420: PUSH
69421: LD_VAR 0 2
69425: ARRAY
69426: PPUSH
69427: LD_INT 30
69429: PUSH
69430: LD_INT 3
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PPUSH
69437: CALL_OW 72
69441: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
69442: LD_ADDR_VAR 0 6
69446: PUSH
69447: LD_EXP 67
69451: PUSH
69452: LD_VAR 0 2
69456: ARRAY
69457: PPUSH
69458: LD_INT 2
69460: PUSH
69461: LD_INT 30
69463: PUSH
69464: LD_INT 32
69466: PUSH
69467: EMPTY
69468: LIST
69469: LIST
69470: PUSH
69471: LD_INT 30
69473: PUSH
69474: LD_INT 33
69476: PUSH
69477: EMPTY
69478: LIST
69479: LIST
69480: PUSH
69481: EMPTY
69482: LIST
69483: LIST
69484: LIST
69485: PPUSH
69486: CALL_OW 72
69490: ST_TO_ADDR
// if not t then
69491: LD_VAR 0 6
69495: NOT
69496: IFFALSE 69500
// continue ;
69498: GO 69357
// for j in tmp do
69500: LD_ADDR_VAR 0 3
69504: PUSH
69505: LD_VAR 0 4
69509: PUSH
69510: FOR_IN
69511: IFFALSE 69541
// if not BuildingStatus ( j ) = bs_idle then
69513: LD_VAR 0 3
69517: PPUSH
69518: CALL_OW 461
69522: PUSH
69523: LD_INT 2
69525: EQUAL
69526: NOT
69527: IFFALSE 69539
// begin busy := true ;
69529: LD_ADDR_VAR 0 8
69533: PUSH
69534: LD_INT 1
69536: ST_TO_ADDR
// break ;
69537: GO 69541
// end ;
69539: GO 69510
69541: POP
69542: POP
// if busy then
69543: LD_VAR 0 8
69547: IFFALSE 69551
// continue ;
69549: GO 69357
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
69551: LD_ADDR_VAR 0 7
69555: PUSH
69556: LD_VAR 0 6
69560: PPUSH
69561: LD_INT 35
69563: PUSH
69564: LD_INT 0
69566: PUSH
69567: EMPTY
69568: LIST
69569: LIST
69570: PPUSH
69571: CALL_OW 72
69575: ST_TO_ADDR
// if tw then
69576: LD_VAR 0 7
69580: IFFALSE 69657
// begin tw := tw [ 1 ] ;
69582: LD_ADDR_VAR 0 7
69586: PUSH
69587: LD_VAR 0 7
69591: PUSH
69592: LD_INT 1
69594: ARRAY
69595: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
69596: LD_ADDR_VAR 0 9
69600: PUSH
69601: LD_VAR 0 7
69605: PPUSH
69606: LD_EXP 84
69610: PUSH
69611: LD_VAR 0 2
69615: ARRAY
69616: PPUSH
69617: CALL 26499 0 2
69621: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
69622: LD_EXP 98
69626: PUSH
69627: LD_VAR 0 2
69631: ARRAY
69632: IFFALSE 69655
// if not weapon in mc_allowed_tower_weapons [ i ] then
69634: LD_VAR 0 9
69638: PUSH
69639: LD_EXP 98
69643: PUSH
69644: LD_VAR 0 2
69648: ARRAY
69649: IN
69650: NOT
69651: IFFALSE 69655
// continue ;
69653: GO 69357
// end else
69655: GO 69720
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
69657: LD_ADDR_VAR 0 5
69661: PUSH
69662: LD_EXP 67
69666: PUSH
69667: LD_VAR 0 2
69671: ARRAY
69672: PPUSH
69673: LD_VAR 0 4
69677: PPUSH
69678: CALL 56703 0 2
69682: ST_TO_ADDR
// if not tmp2 then
69683: LD_VAR 0 5
69687: NOT
69688: IFFALSE 69692
// continue ;
69690: GO 69357
// tw := tmp2 [ 1 ] ;
69692: LD_ADDR_VAR 0 7
69696: PUSH
69697: LD_VAR 0 5
69701: PUSH
69702: LD_INT 1
69704: ARRAY
69705: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
69706: LD_ADDR_VAR 0 9
69710: PUSH
69711: LD_VAR 0 5
69715: PUSH
69716: LD_INT 2
69718: ARRAY
69719: ST_TO_ADDR
// end ; if not weapon then
69720: LD_VAR 0 9
69724: NOT
69725: IFFALSE 69729
// continue ;
69727: GO 69357
// ComPlaceWeapon ( tw , weapon ) ;
69729: LD_VAR 0 7
69733: PPUSH
69734: LD_VAR 0 9
69738: PPUSH
69739: CALL_OW 148
// end ;
69743: GO 69357
69745: POP
69746: POP
// end ;
69747: LD_VAR 0 1
69751: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
69752: LD_INT 0
69754: PPUSH
69755: PPUSH
69756: PPUSH
69757: PPUSH
69758: PPUSH
69759: PPUSH
// if not mc_bases then
69760: LD_EXP 59
69764: NOT
69765: IFFALSE 69769
// exit ;
69767: GO 70545
// for i = 1 to mc_bases do
69769: LD_ADDR_VAR 0 2
69773: PUSH
69774: DOUBLE
69775: LD_INT 1
69777: DEC
69778: ST_TO_ADDR
69779: LD_EXP 59
69783: PUSH
69784: FOR_TO
69785: IFFALSE 70543
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
69787: LD_EXP 72
69791: PUSH
69792: LD_VAR 0 2
69796: ARRAY
69797: NOT
69798: PUSH
69799: LD_EXP 72
69803: PUSH
69804: LD_VAR 0 2
69808: ARRAY
69809: PUSH
69810: LD_EXP 73
69814: PUSH
69815: LD_VAR 0 2
69819: ARRAY
69820: EQUAL
69821: OR
69822: PUSH
69823: LD_EXP 82
69827: PUSH
69828: LD_VAR 0 2
69832: ARRAY
69833: OR
69834: IFFALSE 69838
// continue ;
69836: GO 69784
// if mc_miners [ i ] then
69838: LD_EXP 73
69842: PUSH
69843: LD_VAR 0 2
69847: ARRAY
69848: IFFALSE 70230
// begin for j = mc_miners [ i ] downto 1 do
69850: LD_ADDR_VAR 0 3
69854: PUSH
69855: DOUBLE
69856: LD_EXP 73
69860: PUSH
69861: LD_VAR 0 2
69865: ARRAY
69866: INC
69867: ST_TO_ADDR
69868: LD_INT 1
69870: PUSH
69871: FOR_DOWNTO
69872: IFFALSE 70228
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
69874: LD_EXP 73
69878: PUSH
69879: LD_VAR 0 2
69883: ARRAY
69884: PUSH
69885: LD_VAR 0 3
69889: ARRAY
69890: PPUSH
69891: CALL_OW 301
69895: PUSH
69896: LD_EXP 73
69900: PUSH
69901: LD_VAR 0 2
69905: ARRAY
69906: PUSH
69907: LD_VAR 0 3
69911: ARRAY
69912: PPUSH
69913: CALL_OW 257
69917: PUSH
69918: LD_INT 1
69920: NONEQUAL
69921: OR
69922: IFFALSE 69985
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
69924: LD_ADDR_VAR 0 5
69928: PUSH
69929: LD_EXP 73
69933: PUSH
69934: LD_VAR 0 2
69938: ARRAY
69939: PUSH
69940: LD_EXP 73
69944: PUSH
69945: LD_VAR 0 2
69949: ARRAY
69950: PUSH
69951: LD_VAR 0 3
69955: ARRAY
69956: DIFF
69957: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
69958: LD_ADDR_EXP 73
69962: PUSH
69963: LD_EXP 73
69967: PPUSH
69968: LD_VAR 0 2
69972: PPUSH
69973: LD_VAR 0 5
69977: PPUSH
69978: CALL_OW 1
69982: ST_TO_ADDR
// continue ;
69983: GO 69871
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
69985: LD_EXP 73
69989: PUSH
69990: LD_VAR 0 2
69994: ARRAY
69995: PUSH
69996: LD_VAR 0 3
70000: ARRAY
70001: PPUSH
70002: CALL_OW 257
70006: PUSH
70007: LD_INT 1
70009: EQUAL
70010: PUSH
70011: LD_EXP 73
70015: PUSH
70016: LD_VAR 0 2
70020: ARRAY
70021: PUSH
70022: LD_VAR 0 3
70026: ARRAY
70027: PPUSH
70028: CALL_OW 459
70032: NOT
70033: AND
70034: PUSH
70035: LD_EXP 73
70039: PUSH
70040: LD_VAR 0 2
70044: ARRAY
70045: PUSH
70046: LD_VAR 0 3
70050: ARRAY
70051: PPUSH
70052: CALL_OW 314
70056: NOT
70057: AND
70058: IFFALSE 70226
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
70060: LD_EXP 73
70064: PUSH
70065: LD_VAR 0 2
70069: ARRAY
70070: PUSH
70071: LD_VAR 0 3
70075: ARRAY
70076: PPUSH
70077: CALL_OW 310
70081: IFFALSE 70104
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
70083: LD_EXP 73
70087: PUSH
70088: LD_VAR 0 2
70092: ARRAY
70093: PUSH
70094: LD_VAR 0 3
70098: ARRAY
70099: PPUSH
70100: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
70104: LD_EXP 73
70108: PUSH
70109: LD_VAR 0 2
70113: ARRAY
70114: PUSH
70115: LD_VAR 0 3
70119: ARRAY
70120: PPUSH
70121: CALL_OW 314
70125: NOT
70126: IFFALSE 70226
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
70128: LD_EXP 73
70132: PUSH
70133: LD_VAR 0 2
70137: ARRAY
70138: PUSH
70139: LD_VAR 0 3
70143: ARRAY
70144: PPUSH
70145: LD_EXP 72
70149: PUSH
70150: LD_VAR 0 2
70154: ARRAY
70155: PUSH
70156: LD_VAR 0 3
70160: PUSH
70161: LD_EXP 72
70165: PUSH
70166: LD_VAR 0 2
70170: ARRAY
70171: MOD
70172: PUSH
70173: LD_INT 1
70175: PLUS
70176: ARRAY
70177: PUSH
70178: LD_INT 1
70180: ARRAY
70181: PPUSH
70182: LD_EXP 72
70186: PUSH
70187: LD_VAR 0 2
70191: ARRAY
70192: PUSH
70193: LD_VAR 0 3
70197: PUSH
70198: LD_EXP 72
70202: PUSH
70203: LD_VAR 0 2
70207: ARRAY
70208: MOD
70209: PUSH
70210: LD_INT 1
70212: PLUS
70213: ARRAY
70214: PUSH
70215: LD_INT 2
70217: ARRAY
70218: PPUSH
70219: LD_INT 0
70221: PPUSH
70222: CALL_OW 193
// end ; end ;
70226: GO 69871
70228: POP
70229: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
70230: LD_ADDR_VAR 0 5
70234: PUSH
70235: LD_EXP 59
70239: PUSH
70240: LD_VAR 0 2
70244: ARRAY
70245: PPUSH
70246: LD_INT 2
70248: PUSH
70249: LD_INT 30
70251: PUSH
70252: LD_INT 4
70254: PUSH
70255: EMPTY
70256: LIST
70257: LIST
70258: PUSH
70259: LD_INT 30
70261: PUSH
70262: LD_INT 5
70264: PUSH
70265: EMPTY
70266: LIST
70267: LIST
70268: PUSH
70269: LD_INT 30
70271: PUSH
70272: LD_INT 32
70274: PUSH
70275: EMPTY
70276: LIST
70277: LIST
70278: PUSH
70279: EMPTY
70280: LIST
70281: LIST
70282: LIST
70283: LIST
70284: PPUSH
70285: CALL_OW 72
70289: ST_TO_ADDR
// if not tmp then
70290: LD_VAR 0 5
70294: NOT
70295: IFFALSE 70299
// continue ;
70297: GO 69784
// list := [ ] ;
70299: LD_ADDR_VAR 0 6
70303: PUSH
70304: EMPTY
70305: ST_TO_ADDR
// for j in tmp do
70306: LD_ADDR_VAR 0 3
70310: PUSH
70311: LD_VAR 0 5
70315: PUSH
70316: FOR_IN
70317: IFFALSE 70386
// begin for k in UnitsInside ( j ) do
70319: LD_ADDR_VAR 0 4
70323: PUSH
70324: LD_VAR 0 3
70328: PPUSH
70329: CALL_OW 313
70333: PUSH
70334: FOR_IN
70335: IFFALSE 70382
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
70337: LD_VAR 0 4
70341: PPUSH
70342: CALL_OW 257
70346: PUSH
70347: LD_INT 1
70349: EQUAL
70350: PUSH
70351: LD_VAR 0 4
70355: PPUSH
70356: CALL_OW 459
70360: NOT
70361: AND
70362: IFFALSE 70380
// list := list ^ k ;
70364: LD_ADDR_VAR 0 6
70368: PUSH
70369: LD_VAR 0 6
70373: PUSH
70374: LD_VAR 0 4
70378: ADD
70379: ST_TO_ADDR
70380: GO 70334
70382: POP
70383: POP
// end ;
70384: GO 70316
70386: POP
70387: POP
// list := list diff mc_miners [ i ] ;
70388: LD_ADDR_VAR 0 6
70392: PUSH
70393: LD_VAR 0 6
70397: PUSH
70398: LD_EXP 73
70402: PUSH
70403: LD_VAR 0 2
70407: ARRAY
70408: DIFF
70409: ST_TO_ADDR
// if not list then
70410: LD_VAR 0 6
70414: NOT
70415: IFFALSE 70419
// continue ;
70417: GO 69784
// k := mc_mines [ i ] - mc_miners [ i ] ;
70419: LD_ADDR_VAR 0 4
70423: PUSH
70424: LD_EXP 72
70428: PUSH
70429: LD_VAR 0 2
70433: ARRAY
70434: PUSH
70435: LD_EXP 73
70439: PUSH
70440: LD_VAR 0 2
70444: ARRAY
70445: MINUS
70446: ST_TO_ADDR
// if k > list then
70447: LD_VAR 0 4
70451: PUSH
70452: LD_VAR 0 6
70456: GREATER
70457: IFFALSE 70469
// k := list ;
70459: LD_ADDR_VAR 0 4
70463: PUSH
70464: LD_VAR 0 6
70468: ST_TO_ADDR
// for j = 1 to k do
70469: LD_ADDR_VAR 0 3
70473: PUSH
70474: DOUBLE
70475: LD_INT 1
70477: DEC
70478: ST_TO_ADDR
70479: LD_VAR 0 4
70483: PUSH
70484: FOR_TO
70485: IFFALSE 70539
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
70487: LD_ADDR_EXP 73
70491: PUSH
70492: LD_EXP 73
70496: PPUSH
70497: LD_VAR 0 2
70501: PUSH
70502: LD_EXP 73
70506: PUSH
70507: LD_VAR 0 2
70511: ARRAY
70512: PUSH
70513: LD_INT 1
70515: PLUS
70516: PUSH
70517: EMPTY
70518: LIST
70519: LIST
70520: PPUSH
70521: LD_VAR 0 6
70525: PUSH
70526: LD_VAR 0 3
70530: ARRAY
70531: PPUSH
70532: CALL 21529 0 3
70536: ST_TO_ADDR
70537: GO 70484
70539: POP
70540: POP
// end ;
70541: GO 69784
70543: POP
70544: POP
// end ;
70545: LD_VAR 0 1
70549: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
70550: LD_INT 0
70552: PPUSH
70553: PPUSH
70554: PPUSH
70555: PPUSH
70556: PPUSH
70557: PPUSH
70558: PPUSH
70559: PPUSH
70560: PPUSH
70561: PPUSH
// if not mc_bases then
70562: LD_EXP 59
70566: NOT
70567: IFFALSE 70571
// exit ;
70569: GO 72321
// for i = 1 to mc_bases do
70571: LD_ADDR_VAR 0 2
70575: PUSH
70576: DOUBLE
70577: LD_INT 1
70579: DEC
70580: ST_TO_ADDR
70581: LD_EXP 59
70585: PUSH
70586: FOR_TO
70587: IFFALSE 72319
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
70589: LD_EXP 59
70593: PUSH
70594: LD_VAR 0 2
70598: ARRAY
70599: NOT
70600: PUSH
70601: LD_EXP 66
70605: PUSH
70606: LD_VAR 0 2
70610: ARRAY
70611: OR
70612: IFFALSE 70616
// continue ;
70614: GO 70586
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
70616: LD_EXP 75
70620: PUSH
70621: LD_VAR 0 2
70625: ARRAY
70626: NOT
70627: PUSH
70628: LD_EXP 76
70632: PUSH
70633: LD_VAR 0 2
70637: ARRAY
70638: AND
70639: IFFALSE 70677
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
70641: LD_ADDR_EXP 76
70645: PUSH
70646: LD_EXP 76
70650: PPUSH
70651: LD_VAR 0 2
70655: PPUSH
70656: EMPTY
70657: PPUSH
70658: CALL_OW 1
70662: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
70663: LD_VAR 0 2
70667: PPUSH
70668: LD_INT 107
70670: PPUSH
70671: CALL 61535 0 2
// continue ;
70675: GO 70586
// end ; target := [ ] ;
70677: LD_ADDR_VAR 0 6
70681: PUSH
70682: EMPTY
70683: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
70684: LD_ADDR_VAR 0 3
70688: PUSH
70689: DOUBLE
70690: LD_EXP 75
70694: PUSH
70695: LD_VAR 0 2
70699: ARRAY
70700: INC
70701: ST_TO_ADDR
70702: LD_INT 1
70704: PUSH
70705: FOR_DOWNTO
70706: IFFALSE 70966
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
70708: LD_EXP 75
70712: PUSH
70713: LD_VAR 0 2
70717: ARRAY
70718: PUSH
70719: LD_VAR 0 3
70723: ARRAY
70724: PUSH
70725: LD_INT 2
70727: ARRAY
70728: PPUSH
70729: LD_EXP 75
70733: PUSH
70734: LD_VAR 0 2
70738: ARRAY
70739: PUSH
70740: LD_VAR 0 3
70744: ARRAY
70745: PUSH
70746: LD_INT 3
70748: ARRAY
70749: PPUSH
70750: CALL_OW 488
70754: PUSH
70755: LD_EXP 75
70759: PUSH
70760: LD_VAR 0 2
70764: ARRAY
70765: PUSH
70766: LD_VAR 0 3
70770: ARRAY
70771: PUSH
70772: LD_INT 2
70774: ARRAY
70775: PPUSH
70776: LD_EXP 75
70780: PUSH
70781: LD_VAR 0 2
70785: ARRAY
70786: PUSH
70787: LD_VAR 0 3
70791: ARRAY
70792: PUSH
70793: LD_INT 3
70795: ARRAY
70796: PPUSH
70797: CALL_OW 284
70801: PUSH
70802: LD_INT 0
70804: EQUAL
70805: AND
70806: IFFALSE 70861
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
70808: LD_ADDR_VAR 0 5
70812: PUSH
70813: LD_EXP 75
70817: PUSH
70818: LD_VAR 0 2
70822: ARRAY
70823: PPUSH
70824: LD_VAR 0 3
70828: PPUSH
70829: CALL_OW 3
70833: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
70834: LD_ADDR_EXP 75
70838: PUSH
70839: LD_EXP 75
70843: PPUSH
70844: LD_VAR 0 2
70848: PPUSH
70849: LD_VAR 0 5
70853: PPUSH
70854: CALL_OW 1
70858: ST_TO_ADDR
// continue ;
70859: GO 70705
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70861: LD_EXP 59
70865: PUSH
70866: LD_VAR 0 2
70870: ARRAY
70871: PUSH
70872: LD_INT 1
70874: ARRAY
70875: PPUSH
70876: CALL_OW 255
70880: PPUSH
70881: LD_EXP 75
70885: PUSH
70886: LD_VAR 0 2
70890: ARRAY
70891: PUSH
70892: LD_VAR 0 3
70896: ARRAY
70897: PUSH
70898: LD_INT 2
70900: ARRAY
70901: PPUSH
70902: LD_EXP 75
70906: PUSH
70907: LD_VAR 0 2
70911: ARRAY
70912: PUSH
70913: LD_VAR 0 3
70917: ARRAY
70918: PUSH
70919: LD_INT 3
70921: ARRAY
70922: PPUSH
70923: LD_INT 30
70925: PPUSH
70926: CALL 22425 0 4
70930: PUSH
70931: LD_INT 4
70933: ARRAY
70934: PUSH
70935: LD_INT 0
70937: EQUAL
70938: IFFALSE 70964
// begin target := mc_crates [ i ] [ j ] ;
70940: LD_ADDR_VAR 0 6
70944: PUSH
70945: LD_EXP 75
70949: PUSH
70950: LD_VAR 0 2
70954: ARRAY
70955: PUSH
70956: LD_VAR 0 3
70960: ARRAY
70961: ST_TO_ADDR
// break ;
70962: GO 70966
// end ; end ;
70964: GO 70705
70966: POP
70967: POP
// if not target then
70968: LD_VAR 0 6
70972: NOT
70973: IFFALSE 70977
// continue ;
70975: GO 70586
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
70977: LD_ADDR_VAR 0 7
70981: PUSH
70982: LD_EXP 78
70986: PUSH
70987: LD_VAR 0 2
70991: ARRAY
70992: PPUSH
70993: LD_INT 2
70995: PUSH
70996: LD_INT 3
70998: PUSH
70999: LD_INT 58
71001: PUSH
71002: EMPTY
71003: LIST
71004: PUSH
71005: EMPTY
71006: LIST
71007: LIST
71008: PUSH
71009: LD_INT 61
71011: PUSH
71012: EMPTY
71013: LIST
71014: PUSH
71015: LD_INT 33
71017: PUSH
71018: LD_INT 5
71020: PUSH
71021: EMPTY
71022: LIST
71023: LIST
71024: PUSH
71025: LD_INT 33
71027: PUSH
71028: LD_INT 3
71030: PUSH
71031: EMPTY
71032: LIST
71033: LIST
71034: PUSH
71035: EMPTY
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: LIST
71041: PUSH
71042: LD_INT 2
71044: PUSH
71045: LD_INT 34
71047: PUSH
71048: LD_INT 32
71050: PUSH
71051: EMPTY
71052: LIST
71053: LIST
71054: PUSH
71055: LD_INT 34
71057: PUSH
71058: LD_INT 51
71060: PUSH
71061: EMPTY
71062: LIST
71063: LIST
71064: PUSH
71065: LD_INT 34
71067: PUSH
71068: LD_INT 12
71070: PUSH
71071: EMPTY
71072: LIST
71073: LIST
71074: PUSH
71075: EMPTY
71076: LIST
71077: LIST
71078: LIST
71079: LIST
71080: PUSH
71081: EMPTY
71082: LIST
71083: LIST
71084: PPUSH
71085: CALL_OW 72
71089: ST_TO_ADDR
// if not cargo then
71090: LD_VAR 0 7
71094: NOT
71095: IFFALSE 71738
// begin if mc_crates_collector [ i ] < 5 then
71097: LD_EXP 76
71101: PUSH
71102: LD_VAR 0 2
71106: ARRAY
71107: PUSH
71108: LD_INT 5
71110: LESS
71111: IFFALSE 71477
// begin if mc_ape [ i ] then
71113: LD_EXP 88
71117: PUSH
71118: LD_VAR 0 2
71122: ARRAY
71123: IFFALSE 71170
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
71125: LD_ADDR_VAR 0 5
71129: PUSH
71130: LD_EXP 88
71134: PUSH
71135: LD_VAR 0 2
71139: ARRAY
71140: PPUSH
71141: LD_INT 25
71143: PUSH
71144: LD_INT 16
71146: PUSH
71147: EMPTY
71148: LIST
71149: LIST
71150: PUSH
71151: LD_INT 24
71153: PUSH
71154: LD_INT 750
71156: PUSH
71157: EMPTY
71158: LIST
71159: LIST
71160: PUSH
71161: EMPTY
71162: LIST
71163: LIST
71164: PPUSH
71165: CALL_OW 72
71169: ST_TO_ADDR
// if not tmp then
71170: LD_VAR 0 5
71174: NOT
71175: IFFALSE 71222
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
71177: LD_ADDR_VAR 0 5
71181: PUSH
71182: LD_EXP 59
71186: PUSH
71187: LD_VAR 0 2
71191: ARRAY
71192: PPUSH
71193: LD_INT 25
71195: PUSH
71196: LD_INT 2
71198: PUSH
71199: EMPTY
71200: LIST
71201: LIST
71202: PUSH
71203: LD_INT 24
71205: PUSH
71206: LD_INT 750
71208: PUSH
71209: EMPTY
71210: LIST
71211: LIST
71212: PUSH
71213: EMPTY
71214: LIST
71215: LIST
71216: PPUSH
71217: CALL_OW 72
71221: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
71222: LD_EXP 88
71226: PUSH
71227: LD_VAR 0 2
71231: ARRAY
71232: PUSH
71233: LD_EXP 59
71237: PUSH
71238: LD_VAR 0 2
71242: ARRAY
71243: PPUSH
71244: LD_INT 25
71246: PUSH
71247: LD_INT 2
71249: PUSH
71250: EMPTY
71251: LIST
71252: LIST
71253: PUSH
71254: LD_INT 24
71256: PUSH
71257: LD_INT 750
71259: PUSH
71260: EMPTY
71261: LIST
71262: LIST
71263: PUSH
71264: EMPTY
71265: LIST
71266: LIST
71267: PPUSH
71268: CALL_OW 72
71272: AND
71273: PUSH
71274: LD_VAR 0 5
71278: PUSH
71279: LD_INT 5
71281: LESS
71282: AND
71283: IFFALSE 71365
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
71285: LD_ADDR_VAR 0 3
71289: PUSH
71290: LD_EXP 59
71294: PUSH
71295: LD_VAR 0 2
71299: ARRAY
71300: PPUSH
71301: LD_INT 25
71303: PUSH
71304: LD_INT 2
71306: PUSH
71307: EMPTY
71308: LIST
71309: LIST
71310: PUSH
71311: LD_INT 24
71313: PUSH
71314: LD_INT 750
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PUSH
71321: EMPTY
71322: LIST
71323: LIST
71324: PPUSH
71325: CALL_OW 72
71329: PUSH
71330: FOR_IN
71331: IFFALSE 71363
// begin tmp := tmp union j ;
71333: LD_ADDR_VAR 0 5
71337: PUSH
71338: LD_VAR 0 5
71342: PUSH
71343: LD_VAR 0 3
71347: UNION
71348: ST_TO_ADDR
// if tmp >= 5 then
71349: LD_VAR 0 5
71353: PUSH
71354: LD_INT 5
71356: GREATEREQUAL
71357: IFFALSE 71361
// break ;
71359: GO 71363
// end ;
71361: GO 71330
71363: POP
71364: POP
// end ; if not tmp then
71365: LD_VAR 0 5
71369: NOT
71370: IFFALSE 71374
// continue ;
71372: GO 70586
// for j in tmp do
71374: LD_ADDR_VAR 0 3
71378: PUSH
71379: LD_VAR 0 5
71383: PUSH
71384: FOR_IN
71385: IFFALSE 71475
// if not GetTag ( j ) then
71387: LD_VAR 0 3
71391: PPUSH
71392: CALL_OW 110
71396: NOT
71397: IFFALSE 71473
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
71399: LD_ADDR_EXP 76
71403: PUSH
71404: LD_EXP 76
71408: PPUSH
71409: LD_VAR 0 2
71413: PUSH
71414: LD_EXP 76
71418: PUSH
71419: LD_VAR 0 2
71423: ARRAY
71424: PUSH
71425: LD_INT 1
71427: PLUS
71428: PUSH
71429: EMPTY
71430: LIST
71431: LIST
71432: PPUSH
71433: LD_VAR 0 3
71437: PPUSH
71438: CALL 21529 0 3
71442: ST_TO_ADDR
// SetTag ( j , 107 ) ;
71443: LD_VAR 0 3
71447: PPUSH
71448: LD_INT 107
71450: PPUSH
71451: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
71455: LD_EXP 76
71459: PUSH
71460: LD_VAR 0 2
71464: ARRAY
71465: PUSH
71466: LD_INT 5
71468: GREATEREQUAL
71469: IFFALSE 71473
// break ;
71471: GO 71475
// end ;
71473: GO 71384
71475: POP
71476: POP
// end ; if mc_crates_collector [ i ] and target then
71477: LD_EXP 76
71481: PUSH
71482: LD_VAR 0 2
71486: ARRAY
71487: PUSH
71488: LD_VAR 0 6
71492: AND
71493: IFFALSE 71736
// begin if mc_crates_collector [ i ] < target [ 1 ] then
71495: LD_EXP 76
71499: PUSH
71500: LD_VAR 0 2
71504: ARRAY
71505: PUSH
71506: LD_VAR 0 6
71510: PUSH
71511: LD_INT 1
71513: ARRAY
71514: LESS
71515: IFFALSE 71535
// tmp := mc_crates_collector [ i ] else
71517: LD_ADDR_VAR 0 5
71521: PUSH
71522: LD_EXP 76
71526: PUSH
71527: LD_VAR 0 2
71531: ARRAY
71532: ST_TO_ADDR
71533: GO 71549
// tmp := target [ 1 ] ;
71535: LD_ADDR_VAR 0 5
71539: PUSH
71540: LD_VAR 0 6
71544: PUSH
71545: LD_INT 1
71547: ARRAY
71548: ST_TO_ADDR
// k := 0 ;
71549: LD_ADDR_VAR 0 4
71553: PUSH
71554: LD_INT 0
71556: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
71557: LD_ADDR_VAR 0 3
71561: PUSH
71562: LD_EXP 76
71566: PUSH
71567: LD_VAR 0 2
71571: ARRAY
71572: PUSH
71573: FOR_IN
71574: IFFALSE 71734
// begin k := k + 1 ;
71576: LD_ADDR_VAR 0 4
71580: PUSH
71581: LD_VAR 0 4
71585: PUSH
71586: LD_INT 1
71588: PLUS
71589: ST_TO_ADDR
// if k > tmp then
71590: LD_VAR 0 4
71594: PUSH
71595: LD_VAR 0 5
71599: GREATER
71600: IFFALSE 71604
// break ;
71602: GO 71734
// if not GetClass ( j ) in [ 2 , 16 ] then
71604: LD_VAR 0 3
71608: PPUSH
71609: CALL_OW 257
71613: PUSH
71614: LD_INT 2
71616: PUSH
71617: LD_INT 16
71619: PUSH
71620: EMPTY
71621: LIST
71622: LIST
71623: IN
71624: NOT
71625: IFFALSE 71678
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
71627: LD_ADDR_EXP 76
71631: PUSH
71632: LD_EXP 76
71636: PPUSH
71637: LD_VAR 0 2
71641: PPUSH
71642: LD_EXP 76
71646: PUSH
71647: LD_VAR 0 2
71651: ARRAY
71652: PUSH
71653: LD_VAR 0 3
71657: DIFF
71658: PPUSH
71659: CALL_OW 1
71663: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71664: LD_VAR 0 3
71668: PPUSH
71669: LD_INT 0
71671: PPUSH
71672: CALL_OW 109
// continue ;
71676: GO 71573
// end ; if IsInUnit ( j ) then
71678: LD_VAR 0 3
71682: PPUSH
71683: CALL_OW 310
71687: IFFALSE 71698
// ComExitBuilding ( j ) ;
71689: LD_VAR 0 3
71693: PPUSH
71694: CALL_OW 122
// wait ( 3 ) ;
71698: LD_INT 3
71700: PPUSH
71701: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71705: LD_VAR 0 3
71709: PPUSH
71710: LD_VAR 0 6
71714: PUSH
71715: LD_INT 2
71717: ARRAY
71718: PPUSH
71719: LD_VAR 0 6
71723: PUSH
71724: LD_INT 3
71726: ARRAY
71727: PPUSH
71728: CALL_OW 117
// end ;
71732: GO 71573
71734: POP
71735: POP
// end ; end else
71736: GO 72317
// begin for j in cargo do
71738: LD_ADDR_VAR 0 3
71742: PUSH
71743: LD_VAR 0 7
71747: PUSH
71748: FOR_IN
71749: IFFALSE 72315
// begin if GetTag ( j ) <> 0 then
71751: LD_VAR 0 3
71755: PPUSH
71756: CALL_OW 110
71760: PUSH
71761: LD_INT 0
71763: NONEQUAL
71764: IFFALSE 71768
// continue ;
71766: GO 71748
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
71768: LD_VAR 0 3
71772: PPUSH
71773: CALL_OW 256
71777: PUSH
71778: LD_INT 1000
71780: LESS
71781: PUSH
71782: LD_VAR 0 3
71786: PPUSH
71787: LD_EXP 83
71791: PUSH
71792: LD_VAR 0 2
71796: ARRAY
71797: PPUSH
71798: CALL_OW 308
71802: NOT
71803: AND
71804: IFFALSE 71826
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71806: LD_VAR 0 3
71810: PPUSH
71811: LD_EXP 83
71815: PUSH
71816: LD_VAR 0 2
71820: ARRAY
71821: PPUSH
71822: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71826: LD_VAR 0 3
71830: PPUSH
71831: CALL_OW 256
71835: PUSH
71836: LD_INT 1000
71838: LESS
71839: PUSH
71840: LD_VAR 0 3
71844: PPUSH
71845: LD_EXP 83
71849: PUSH
71850: LD_VAR 0 2
71854: ARRAY
71855: PPUSH
71856: CALL_OW 308
71860: AND
71861: IFFALSE 71865
// continue ;
71863: GO 71748
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71865: LD_VAR 0 3
71869: PPUSH
71870: CALL_OW 262
71874: PUSH
71875: LD_INT 2
71877: EQUAL
71878: PUSH
71879: LD_VAR 0 3
71883: PPUSH
71884: CALL_OW 261
71888: PUSH
71889: LD_INT 15
71891: LESS
71892: AND
71893: IFFALSE 71897
// continue ;
71895: GO 71748
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71897: LD_VAR 0 3
71901: PPUSH
71902: CALL_OW 262
71906: PUSH
71907: LD_INT 1
71909: EQUAL
71910: PUSH
71911: LD_VAR 0 3
71915: PPUSH
71916: CALL_OW 261
71920: PUSH
71921: LD_INT 10
71923: LESS
71924: AND
71925: IFFALSE 72254
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71927: LD_ADDR_VAR 0 8
71931: PUSH
71932: LD_EXP 59
71936: PUSH
71937: LD_VAR 0 2
71941: ARRAY
71942: PPUSH
71943: LD_INT 2
71945: PUSH
71946: LD_INT 30
71948: PUSH
71949: LD_INT 0
71951: PUSH
71952: EMPTY
71953: LIST
71954: LIST
71955: PUSH
71956: LD_INT 30
71958: PUSH
71959: LD_INT 1
71961: PUSH
71962: EMPTY
71963: LIST
71964: LIST
71965: PUSH
71966: EMPTY
71967: LIST
71968: LIST
71969: LIST
71970: PPUSH
71971: CALL_OW 72
71975: ST_TO_ADDR
// if not depot then
71976: LD_VAR 0 8
71980: NOT
71981: IFFALSE 71985
// continue ;
71983: GO 71748
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
71985: LD_VAR 0 3
71989: PPUSH
71990: LD_VAR 0 8
71994: PPUSH
71995: LD_VAR 0 3
71999: PPUSH
72000: CALL_OW 74
72004: PPUSH
72005: CALL_OW 296
72009: PUSH
72010: LD_INT 6
72012: LESS
72013: IFFALSE 72029
// SetFuel ( j , 100 ) else
72015: LD_VAR 0 3
72019: PPUSH
72020: LD_INT 100
72022: PPUSH
72023: CALL_OW 240
72027: GO 72254
// if GetFuel ( j ) = 0 then
72029: LD_VAR 0 3
72033: PPUSH
72034: CALL_OW 261
72038: PUSH
72039: LD_INT 0
72041: EQUAL
72042: IFFALSE 72254
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
72044: LD_ADDR_EXP 78
72048: PUSH
72049: LD_EXP 78
72053: PPUSH
72054: LD_VAR 0 2
72058: PPUSH
72059: LD_EXP 78
72063: PUSH
72064: LD_VAR 0 2
72068: ARRAY
72069: PUSH
72070: LD_VAR 0 3
72074: DIFF
72075: PPUSH
72076: CALL_OW 1
72080: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
72081: LD_VAR 0 3
72085: PPUSH
72086: CALL_OW 263
72090: PUSH
72091: LD_INT 1
72093: EQUAL
72094: IFFALSE 72110
// ComExitVehicle ( IsInUnit ( j ) ) ;
72096: LD_VAR 0 3
72100: PPUSH
72101: CALL_OW 310
72105: PPUSH
72106: CALL_OW 121
// if GetControl ( j ) = control_remote then
72110: LD_VAR 0 3
72114: PPUSH
72115: CALL_OW 263
72119: PUSH
72120: LD_INT 2
72122: EQUAL
72123: IFFALSE 72134
// ComUnlink ( j ) ;
72125: LD_VAR 0 3
72129: PPUSH
72130: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
72134: LD_ADDR_VAR 0 9
72138: PUSH
72139: LD_VAR 0 2
72143: PPUSH
72144: LD_INT 3
72146: PPUSH
72147: CALL 81607 0 2
72151: ST_TO_ADDR
// if fac then
72152: LD_VAR 0 9
72156: IFFALSE 72252
// begin for k in fac do
72158: LD_ADDR_VAR 0 4
72162: PUSH
72163: LD_VAR 0 9
72167: PUSH
72168: FOR_IN
72169: IFFALSE 72250
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
72171: LD_ADDR_VAR 0 10
72175: PUSH
72176: LD_VAR 0 9
72180: PPUSH
72181: LD_VAR 0 3
72185: PPUSH
72186: CALL_OW 265
72190: PPUSH
72191: LD_VAR 0 3
72195: PPUSH
72196: CALL_OW 262
72200: PPUSH
72201: LD_VAR 0 3
72205: PPUSH
72206: CALL_OW 263
72210: PPUSH
72211: LD_VAR 0 3
72215: PPUSH
72216: CALL_OW 264
72220: PPUSH
72221: CALL 19061 0 5
72225: ST_TO_ADDR
// if components then
72226: LD_VAR 0 10
72230: IFFALSE 72248
// begin MC_InsertProduceList ( i , components ) ;
72232: LD_VAR 0 2
72236: PPUSH
72237: LD_VAR 0 10
72241: PPUSH
72242: CALL 81152 0 2
// break ;
72246: GO 72250
// end ; end ;
72248: GO 72168
72250: POP
72251: POP
// end ; continue ;
72252: GO 71748
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
72254: LD_VAR 0 3
72258: PPUSH
72259: LD_INT 1
72261: PPUSH
72262: CALL_OW 289
72266: PUSH
72267: LD_INT 100
72269: LESS
72270: PUSH
72271: LD_VAR 0 3
72275: PPUSH
72276: CALL_OW 314
72280: NOT
72281: AND
72282: IFFALSE 72311
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
72284: LD_VAR 0 3
72288: PPUSH
72289: LD_VAR 0 6
72293: PUSH
72294: LD_INT 2
72296: ARRAY
72297: PPUSH
72298: LD_VAR 0 6
72302: PUSH
72303: LD_INT 3
72305: ARRAY
72306: PPUSH
72307: CALL_OW 117
// break ;
72311: GO 72315
// end ;
72313: GO 71748
72315: POP
72316: POP
// end ; end ;
72317: GO 70586
72319: POP
72320: POP
// end ;
72321: LD_VAR 0 1
72325: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
72326: LD_INT 0
72328: PPUSH
72329: PPUSH
72330: PPUSH
72331: PPUSH
// if not mc_bases then
72332: LD_EXP 59
72336: NOT
72337: IFFALSE 72341
// exit ;
72339: GO 72502
// for i = 1 to mc_bases do
72341: LD_ADDR_VAR 0 2
72345: PUSH
72346: DOUBLE
72347: LD_INT 1
72349: DEC
72350: ST_TO_ADDR
72351: LD_EXP 59
72355: PUSH
72356: FOR_TO
72357: IFFALSE 72500
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
72359: LD_ADDR_VAR 0 4
72363: PUSH
72364: LD_EXP 78
72368: PUSH
72369: LD_VAR 0 2
72373: ARRAY
72374: PUSH
72375: LD_EXP 81
72379: PUSH
72380: LD_VAR 0 2
72384: ARRAY
72385: UNION
72386: PPUSH
72387: LD_INT 33
72389: PUSH
72390: LD_INT 2
72392: PUSH
72393: EMPTY
72394: LIST
72395: LIST
72396: PPUSH
72397: CALL_OW 72
72401: ST_TO_ADDR
// if tmp then
72402: LD_VAR 0 4
72406: IFFALSE 72498
// for j in tmp do
72408: LD_ADDR_VAR 0 3
72412: PUSH
72413: LD_VAR 0 4
72417: PUSH
72418: FOR_IN
72419: IFFALSE 72496
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
72421: LD_VAR 0 3
72425: PPUSH
72426: CALL_OW 312
72430: NOT
72431: PUSH
72432: LD_VAR 0 3
72436: PPUSH
72437: CALL_OW 256
72441: PUSH
72442: LD_INT 250
72444: GREATEREQUAL
72445: AND
72446: IFFALSE 72459
// Connect ( j ) else
72448: LD_VAR 0 3
72452: PPUSH
72453: CALL 24462 0 1
72457: GO 72494
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
72459: LD_VAR 0 3
72463: PPUSH
72464: CALL_OW 256
72468: PUSH
72469: LD_INT 250
72471: LESS
72472: PUSH
72473: LD_VAR 0 3
72477: PPUSH
72478: CALL_OW 312
72482: AND
72483: IFFALSE 72494
// ComUnlink ( j ) ;
72485: LD_VAR 0 3
72489: PPUSH
72490: CALL_OW 136
72494: GO 72418
72496: POP
72497: POP
// end ;
72498: GO 72356
72500: POP
72501: POP
// end ;
72502: LD_VAR 0 1
72506: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
72507: LD_INT 0
72509: PPUSH
72510: PPUSH
72511: PPUSH
72512: PPUSH
72513: PPUSH
// if not mc_bases then
72514: LD_EXP 59
72518: NOT
72519: IFFALSE 72523
// exit ;
72521: GO 72968
// for i = 1 to mc_bases do
72523: LD_ADDR_VAR 0 2
72527: PUSH
72528: DOUBLE
72529: LD_INT 1
72531: DEC
72532: ST_TO_ADDR
72533: LD_EXP 59
72537: PUSH
72538: FOR_TO
72539: IFFALSE 72966
// begin if not mc_produce [ i ] then
72541: LD_EXP 80
72545: PUSH
72546: LD_VAR 0 2
72550: ARRAY
72551: NOT
72552: IFFALSE 72556
// continue ;
72554: GO 72538
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72556: LD_ADDR_VAR 0 5
72560: PUSH
72561: LD_EXP 59
72565: PUSH
72566: LD_VAR 0 2
72570: ARRAY
72571: PPUSH
72572: LD_INT 30
72574: PUSH
72575: LD_INT 3
72577: PUSH
72578: EMPTY
72579: LIST
72580: LIST
72581: PPUSH
72582: CALL_OW 72
72586: ST_TO_ADDR
// if not fac then
72587: LD_VAR 0 5
72591: NOT
72592: IFFALSE 72596
// continue ;
72594: GO 72538
// for j in fac do
72596: LD_ADDR_VAR 0 3
72600: PUSH
72601: LD_VAR 0 5
72605: PUSH
72606: FOR_IN
72607: IFFALSE 72962
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
72609: LD_VAR 0 3
72613: PPUSH
72614: CALL_OW 461
72618: PUSH
72619: LD_INT 2
72621: NONEQUAL
72622: PUSH
72623: LD_VAR 0 3
72627: PPUSH
72628: LD_INT 15
72630: PPUSH
72631: CALL 24122 0 2
72635: PUSH
72636: LD_INT 4
72638: ARRAY
72639: OR
72640: IFFALSE 72644
// continue ;
72642: GO 72606
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
72644: LD_VAR 0 3
72648: PPUSH
72649: LD_EXP 80
72653: PUSH
72654: LD_VAR 0 2
72658: ARRAY
72659: PUSH
72660: LD_INT 1
72662: ARRAY
72663: PUSH
72664: LD_INT 1
72666: ARRAY
72667: PPUSH
72668: LD_EXP 80
72672: PUSH
72673: LD_VAR 0 2
72677: ARRAY
72678: PUSH
72679: LD_INT 1
72681: ARRAY
72682: PUSH
72683: LD_INT 2
72685: ARRAY
72686: PPUSH
72687: LD_EXP 80
72691: PUSH
72692: LD_VAR 0 2
72696: ARRAY
72697: PUSH
72698: LD_INT 1
72700: ARRAY
72701: PUSH
72702: LD_INT 3
72704: ARRAY
72705: PPUSH
72706: LD_EXP 80
72710: PUSH
72711: LD_VAR 0 2
72715: ARRAY
72716: PUSH
72717: LD_INT 1
72719: ARRAY
72720: PUSH
72721: LD_INT 4
72723: ARRAY
72724: PPUSH
72725: CALL_OW 448
72729: PUSH
72730: LD_VAR 0 3
72734: PPUSH
72735: LD_EXP 80
72739: PUSH
72740: LD_VAR 0 2
72744: ARRAY
72745: PUSH
72746: LD_INT 1
72748: ARRAY
72749: PUSH
72750: LD_INT 1
72752: ARRAY
72753: PUSH
72754: LD_EXP 80
72758: PUSH
72759: LD_VAR 0 2
72763: ARRAY
72764: PUSH
72765: LD_INT 1
72767: ARRAY
72768: PUSH
72769: LD_INT 2
72771: ARRAY
72772: PUSH
72773: LD_EXP 80
72777: PUSH
72778: LD_VAR 0 2
72782: ARRAY
72783: PUSH
72784: LD_INT 1
72786: ARRAY
72787: PUSH
72788: LD_INT 3
72790: ARRAY
72791: PUSH
72792: LD_EXP 80
72796: PUSH
72797: LD_VAR 0 2
72801: ARRAY
72802: PUSH
72803: LD_INT 1
72805: ARRAY
72806: PUSH
72807: LD_INT 4
72809: ARRAY
72810: PUSH
72811: EMPTY
72812: LIST
72813: LIST
72814: LIST
72815: LIST
72816: PPUSH
72817: CALL 27793 0 2
72821: AND
72822: IFFALSE 72960
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
72824: LD_VAR 0 3
72828: PPUSH
72829: LD_EXP 80
72833: PUSH
72834: LD_VAR 0 2
72838: ARRAY
72839: PUSH
72840: LD_INT 1
72842: ARRAY
72843: PUSH
72844: LD_INT 1
72846: ARRAY
72847: PPUSH
72848: LD_EXP 80
72852: PUSH
72853: LD_VAR 0 2
72857: ARRAY
72858: PUSH
72859: LD_INT 1
72861: ARRAY
72862: PUSH
72863: LD_INT 2
72865: ARRAY
72866: PPUSH
72867: LD_EXP 80
72871: PUSH
72872: LD_VAR 0 2
72876: ARRAY
72877: PUSH
72878: LD_INT 1
72880: ARRAY
72881: PUSH
72882: LD_INT 3
72884: ARRAY
72885: PPUSH
72886: LD_EXP 80
72890: PUSH
72891: LD_VAR 0 2
72895: ARRAY
72896: PUSH
72897: LD_INT 1
72899: ARRAY
72900: PUSH
72901: LD_INT 4
72903: ARRAY
72904: PPUSH
72905: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
72909: LD_ADDR_VAR 0 4
72913: PUSH
72914: LD_EXP 80
72918: PUSH
72919: LD_VAR 0 2
72923: ARRAY
72924: PPUSH
72925: LD_INT 1
72927: PPUSH
72928: CALL_OW 3
72932: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
72933: LD_ADDR_EXP 80
72937: PUSH
72938: LD_EXP 80
72942: PPUSH
72943: LD_VAR 0 2
72947: PPUSH
72948: LD_VAR 0 4
72952: PPUSH
72953: CALL_OW 1
72957: ST_TO_ADDR
// break ;
72958: GO 72962
// end ; end ;
72960: GO 72606
72962: POP
72963: POP
// end ;
72964: GO 72538
72966: POP
72967: POP
// end ;
72968: LD_VAR 0 1
72972: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
72973: LD_INT 0
72975: PPUSH
72976: PPUSH
72977: PPUSH
// if not mc_bases then
72978: LD_EXP 59
72982: NOT
72983: IFFALSE 72987
// exit ;
72985: GO 73076
// for i = 1 to mc_bases do
72987: LD_ADDR_VAR 0 2
72991: PUSH
72992: DOUBLE
72993: LD_INT 1
72995: DEC
72996: ST_TO_ADDR
72997: LD_EXP 59
73001: PUSH
73002: FOR_TO
73003: IFFALSE 73074
// begin if mc_attack [ i ] then
73005: LD_EXP 79
73009: PUSH
73010: LD_VAR 0 2
73014: ARRAY
73015: IFFALSE 73072
// begin tmp := mc_attack [ i ] [ 1 ] ;
73017: LD_ADDR_VAR 0 3
73021: PUSH
73022: LD_EXP 79
73026: PUSH
73027: LD_VAR 0 2
73031: ARRAY
73032: PUSH
73033: LD_INT 1
73035: ARRAY
73036: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
73037: LD_ADDR_EXP 79
73041: PUSH
73042: LD_EXP 79
73046: PPUSH
73047: LD_VAR 0 2
73051: PPUSH
73052: EMPTY
73053: PPUSH
73054: CALL_OW 1
73058: ST_TO_ADDR
// Attack ( tmp ) ;
73059: LD_VAR 0 3
73063: PPUSH
73064: CALL 49983 0 1
// exit ;
73068: POP
73069: POP
73070: GO 73076
// end ; end ;
73072: GO 73002
73074: POP
73075: POP
// end ;
73076: LD_VAR 0 1
73080: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
73081: LD_INT 0
73083: PPUSH
73084: PPUSH
73085: PPUSH
73086: PPUSH
73087: PPUSH
73088: PPUSH
73089: PPUSH
// if not mc_bases then
73090: LD_EXP 59
73094: NOT
73095: IFFALSE 73099
// exit ;
73097: GO 73681
// for i = 1 to mc_bases do
73099: LD_ADDR_VAR 0 2
73103: PUSH
73104: DOUBLE
73105: LD_INT 1
73107: DEC
73108: ST_TO_ADDR
73109: LD_EXP 59
73113: PUSH
73114: FOR_TO
73115: IFFALSE 73679
// begin if not mc_bases [ i ] then
73117: LD_EXP 59
73121: PUSH
73122: LD_VAR 0 2
73126: ARRAY
73127: NOT
73128: IFFALSE 73132
// continue ;
73130: GO 73114
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
73132: LD_ADDR_VAR 0 7
73136: PUSH
73137: LD_EXP 59
73141: PUSH
73142: LD_VAR 0 2
73146: ARRAY
73147: PUSH
73148: LD_INT 1
73150: ARRAY
73151: PPUSH
73152: CALL 18365 0 1
73156: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
73157: LD_ADDR_EXP 82
73161: PUSH
73162: LD_EXP 82
73166: PPUSH
73167: LD_VAR 0 2
73171: PPUSH
73172: LD_EXP 59
73176: PUSH
73177: LD_VAR 0 2
73181: ARRAY
73182: PUSH
73183: LD_INT 1
73185: ARRAY
73186: PPUSH
73187: CALL_OW 255
73191: PPUSH
73192: LD_EXP 84
73196: PUSH
73197: LD_VAR 0 2
73201: ARRAY
73202: PPUSH
73203: CALL 15919 0 2
73207: PPUSH
73208: CALL_OW 1
73212: ST_TO_ADDR
// if not mc_scan [ i ] then
73213: LD_EXP 82
73217: PUSH
73218: LD_VAR 0 2
73222: ARRAY
73223: NOT
73224: IFFALSE 73379
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73226: LD_ADDR_VAR 0 4
73230: PUSH
73231: LD_EXP 59
73235: PUSH
73236: LD_VAR 0 2
73240: ARRAY
73241: PPUSH
73242: LD_INT 2
73244: PUSH
73245: LD_INT 25
73247: PUSH
73248: LD_INT 5
73250: PUSH
73251: EMPTY
73252: LIST
73253: LIST
73254: PUSH
73255: LD_INT 25
73257: PUSH
73258: LD_INT 8
73260: PUSH
73261: EMPTY
73262: LIST
73263: LIST
73264: PUSH
73265: LD_INT 25
73267: PUSH
73268: LD_INT 9
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PUSH
73275: EMPTY
73276: LIST
73277: LIST
73278: LIST
73279: LIST
73280: PPUSH
73281: CALL_OW 72
73285: ST_TO_ADDR
// if not tmp then
73286: LD_VAR 0 4
73290: NOT
73291: IFFALSE 73295
// continue ;
73293: GO 73114
// for j in tmp do
73295: LD_ADDR_VAR 0 3
73299: PUSH
73300: LD_VAR 0 4
73304: PUSH
73305: FOR_IN
73306: IFFALSE 73377
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
73308: LD_VAR 0 3
73312: PPUSH
73313: CALL_OW 310
73317: PPUSH
73318: CALL_OW 266
73322: PUSH
73323: LD_INT 5
73325: EQUAL
73326: PUSH
73327: LD_VAR 0 3
73331: PPUSH
73332: CALL_OW 257
73336: PUSH
73337: LD_INT 1
73339: EQUAL
73340: AND
73341: PUSH
73342: LD_VAR 0 3
73346: PPUSH
73347: CALL_OW 459
73351: NOT
73352: AND
73353: PUSH
73354: LD_VAR 0 7
73358: AND
73359: IFFALSE 73375
// ComChangeProfession ( j , class ) ;
73361: LD_VAR 0 3
73365: PPUSH
73366: LD_VAR 0 7
73370: PPUSH
73371: CALL_OW 123
73375: GO 73305
73377: POP
73378: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
73379: LD_EXP 82
73383: PUSH
73384: LD_VAR 0 2
73388: ARRAY
73389: PUSH
73390: LD_EXP 81
73394: PUSH
73395: LD_VAR 0 2
73399: ARRAY
73400: NOT
73401: AND
73402: PUSH
73403: LD_EXP 59
73407: PUSH
73408: LD_VAR 0 2
73412: ARRAY
73413: PPUSH
73414: LD_INT 30
73416: PUSH
73417: LD_INT 32
73419: PUSH
73420: EMPTY
73421: LIST
73422: LIST
73423: PPUSH
73424: CALL_OW 72
73428: NOT
73429: AND
73430: PUSH
73431: LD_EXP 59
73435: PUSH
73436: LD_VAR 0 2
73440: ARRAY
73441: PPUSH
73442: LD_INT 2
73444: PUSH
73445: LD_INT 30
73447: PUSH
73448: LD_INT 4
73450: PUSH
73451: EMPTY
73452: LIST
73453: LIST
73454: PUSH
73455: LD_INT 30
73457: PUSH
73458: LD_INT 5
73460: PUSH
73461: EMPTY
73462: LIST
73463: LIST
73464: PUSH
73465: EMPTY
73466: LIST
73467: LIST
73468: LIST
73469: PPUSH
73470: CALL_OW 72
73474: NOT
73475: AND
73476: IFFALSE 73608
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73478: LD_ADDR_VAR 0 4
73482: PUSH
73483: LD_EXP 59
73487: PUSH
73488: LD_VAR 0 2
73492: ARRAY
73493: PPUSH
73494: LD_INT 2
73496: PUSH
73497: LD_INT 25
73499: PUSH
73500: LD_INT 1
73502: PUSH
73503: EMPTY
73504: LIST
73505: LIST
73506: PUSH
73507: LD_INT 25
73509: PUSH
73510: LD_INT 5
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: PUSH
73517: LD_INT 25
73519: PUSH
73520: LD_INT 8
73522: PUSH
73523: EMPTY
73524: LIST
73525: LIST
73526: PUSH
73527: LD_INT 25
73529: PUSH
73530: LD_INT 9
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: PUSH
73537: EMPTY
73538: LIST
73539: LIST
73540: LIST
73541: LIST
73542: LIST
73543: PPUSH
73544: CALL_OW 72
73548: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
73549: LD_ADDR_VAR 0 4
73553: PUSH
73554: LD_VAR 0 4
73558: PUSH
73559: LD_VAR 0 4
73563: PPUSH
73564: LD_INT 18
73566: PPUSH
73567: CALL 54792 0 2
73571: DIFF
73572: ST_TO_ADDR
// if tmp then
73573: LD_VAR 0 4
73577: IFFALSE 73608
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
73579: LD_VAR 0 2
73583: PPUSH
73584: LD_VAR 0 4
73588: PPUSH
73589: LD_EXP 84
73593: PUSH
73594: LD_VAR 0 2
73598: ARRAY
73599: PPUSH
73600: CALL 15954 0 3
// exit ;
73604: POP
73605: POP
73606: GO 73681
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
73608: LD_EXP 82
73612: PUSH
73613: LD_VAR 0 2
73617: ARRAY
73618: PUSH
73619: LD_EXP 81
73623: PUSH
73624: LD_VAR 0 2
73628: ARRAY
73629: AND
73630: IFFALSE 73677
// begin tmp := mc_defender [ i ] ;
73632: LD_ADDR_VAR 0 4
73636: PUSH
73637: LD_EXP 81
73641: PUSH
73642: LD_VAR 0 2
73646: ARRAY
73647: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
73648: LD_VAR 0 2
73652: PPUSH
73653: LD_VAR 0 4
73657: PPUSH
73658: LD_EXP 82
73662: PUSH
73663: LD_VAR 0 2
73667: ARRAY
73668: PPUSH
73669: CALL 16515 0 3
// exit ;
73673: POP
73674: POP
73675: GO 73681
// end ; end ;
73677: GO 73114
73679: POP
73680: POP
// end ;
73681: LD_VAR 0 1
73685: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73686: LD_INT 0
73688: PPUSH
73689: PPUSH
73690: PPUSH
73691: PPUSH
73692: PPUSH
73693: PPUSH
73694: PPUSH
73695: PPUSH
73696: PPUSH
73697: PPUSH
73698: PPUSH
// if not mc_bases then
73699: LD_EXP 59
73703: NOT
73704: IFFALSE 73708
// exit ;
73706: GO 74795
// for i = 1 to mc_bases do
73708: LD_ADDR_VAR 0 2
73712: PUSH
73713: DOUBLE
73714: LD_INT 1
73716: DEC
73717: ST_TO_ADDR
73718: LD_EXP 59
73722: PUSH
73723: FOR_TO
73724: IFFALSE 74793
// begin tmp := mc_lab [ i ] ;
73726: LD_ADDR_VAR 0 6
73730: PUSH
73731: LD_EXP 92
73735: PUSH
73736: LD_VAR 0 2
73740: ARRAY
73741: ST_TO_ADDR
// if not tmp then
73742: LD_VAR 0 6
73746: NOT
73747: IFFALSE 73751
// continue ;
73749: GO 73723
// idle_lab := 0 ;
73751: LD_ADDR_VAR 0 11
73755: PUSH
73756: LD_INT 0
73758: ST_TO_ADDR
// for j in tmp do
73759: LD_ADDR_VAR 0 3
73763: PUSH
73764: LD_VAR 0 6
73768: PUSH
73769: FOR_IN
73770: IFFALSE 74789
// begin researching := false ;
73772: LD_ADDR_VAR 0 10
73776: PUSH
73777: LD_INT 0
73779: ST_TO_ADDR
// side := GetSide ( j ) ;
73780: LD_ADDR_VAR 0 4
73784: PUSH
73785: LD_VAR 0 3
73789: PPUSH
73790: CALL_OW 255
73794: ST_TO_ADDR
// if not mc_tech [ side ] then
73795: LD_EXP 86
73799: PUSH
73800: LD_VAR 0 4
73804: ARRAY
73805: NOT
73806: IFFALSE 73810
// continue ;
73808: GO 73769
// if BuildingStatus ( j ) = bs_idle then
73810: LD_VAR 0 3
73814: PPUSH
73815: CALL_OW 461
73819: PUSH
73820: LD_INT 2
73822: EQUAL
73823: IFFALSE 74011
// begin if idle_lab and UnitsInside ( j ) < 6 then
73825: LD_VAR 0 11
73829: PUSH
73830: LD_VAR 0 3
73834: PPUSH
73835: CALL_OW 313
73839: PUSH
73840: LD_INT 6
73842: LESS
73843: AND
73844: IFFALSE 73915
// begin tmp2 := UnitsInside ( idle_lab ) ;
73846: LD_ADDR_VAR 0 9
73850: PUSH
73851: LD_VAR 0 11
73855: PPUSH
73856: CALL_OW 313
73860: ST_TO_ADDR
// if tmp2 then
73861: LD_VAR 0 9
73865: IFFALSE 73907
// for x in tmp2 do
73867: LD_ADDR_VAR 0 7
73871: PUSH
73872: LD_VAR 0 9
73876: PUSH
73877: FOR_IN
73878: IFFALSE 73905
// begin ComExitBuilding ( x ) ;
73880: LD_VAR 0 7
73884: PPUSH
73885: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73889: LD_VAR 0 7
73893: PPUSH
73894: LD_VAR 0 3
73898: PPUSH
73899: CALL_OW 180
// end ;
73903: GO 73877
73905: POP
73906: POP
// idle_lab := 0 ;
73907: LD_ADDR_VAR 0 11
73911: PUSH
73912: LD_INT 0
73914: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
73915: LD_ADDR_VAR 0 5
73919: PUSH
73920: LD_EXP 86
73924: PUSH
73925: LD_VAR 0 4
73929: ARRAY
73930: PUSH
73931: FOR_IN
73932: IFFALSE 73992
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
73934: LD_VAR 0 3
73938: PPUSH
73939: LD_VAR 0 5
73943: PPUSH
73944: CALL_OW 430
73948: PUSH
73949: LD_VAR 0 4
73953: PPUSH
73954: LD_VAR 0 5
73958: PPUSH
73959: CALL 15024 0 2
73963: AND
73964: IFFALSE 73990
// begin researching := true ;
73966: LD_ADDR_VAR 0 10
73970: PUSH
73971: LD_INT 1
73973: ST_TO_ADDR
// ComResearch ( j , t ) ;
73974: LD_VAR 0 3
73978: PPUSH
73979: LD_VAR 0 5
73983: PPUSH
73984: CALL_OW 124
// break ;
73988: GO 73992
// end ;
73990: GO 73931
73992: POP
73993: POP
// if not researching then
73994: LD_VAR 0 10
73998: NOT
73999: IFFALSE 74011
// idle_lab := j ;
74001: LD_ADDR_VAR 0 11
74005: PUSH
74006: LD_VAR 0 3
74010: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
74011: LD_VAR 0 3
74015: PPUSH
74016: CALL_OW 461
74020: PUSH
74021: LD_INT 10
74023: EQUAL
74024: IFFALSE 74612
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
74026: LD_EXP 88
74030: PUSH
74031: LD_VAR 0 2
74035: ARRAY
74036: NOT
74037: PUSH
74038: LD_EXP 89
74042: PUSH
74043: LD_VAR 0 2
74047: ARRAY
74048: NOT
74049: AND
74050: PUSH
74051: LD_EXP 86
74055: PUSH
74056: LD_VAR 0 4
74060: ARRAY
74061: PUSH
74062: LD_INT 1
74064: GREATER
74065: AND
74066: IFFALSE 74197
// begin ComCancel ( j ) ;
74068: LD_VAR 0 3
74072: PPUSH
74073: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
74077: LD_ADDR_EXP 86
74081: PUSH
74082: LD_EXP 86
74086: PPUSH
74087: LD_VAR 0 4
74091: PPUSH
74092: LD_EXP 86
74096: PUSH
74097: LD_VAR 0 4
74101: ARRAY
74102: PPUSH
74103: LD_EXP 86
74107: PUSH
74108: LD_VAR 0 4
74112: ARRAY
74113: PUSH
74114: LD_INT 1
74116: MINUS
74117: PPUSH
74118: LD_EXP 86
74122: PUSH
74123: LD_VAR 0 4
74127: ARRAY
74128: PPUSH
74129: LD_INT 0
74131: PPUSH
74132: CALL 20947 0 4
74136: PPUSH
74137: CALL_OW 1
74141: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
74142: LD_ADDR_EXP 86
74146: PUSH
74147: LD_EXP 86
74151: PPUSH
74152: LD_VAR 0 4
74156: PPUSH
74157: LD_EXP 86
74161: PUSH
74162: LD_VAR 0 4
74166: ARRAY
74167: PPUSH
74168: LD_EXP 86
74172: PUSH
74173: LD_VAR 0 4
74177: ARRAY
74178: PPUSH
74179: LD_INT 1
74181: PPUSH
74182: LD_INT 0
74184: PPUSH
74185: CALL 20947 0 4
74189: PPUSH
74190: CALL_OW 1
74194: ST_TO_ADDR
// continue ;
74195: GO 73769
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
74197: LD_EXP 88
74201: PUSH
74202: LD_VAR 0 2
74206: ARRAY
74207: PUSH
74208: LD_EXP 89
74212: PUSH
74213: LD_VAR 0 2
74217: ARRAY
74218: NOT
74219: AND
74220: IFFALSE 74347
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
74222: LD_ADDR_EXP 89
74226: PUSH
74227: LD_EXP 89
74231: PPUSH
74232: LD_VAR 0 2
74236: PUSH
74237: LD_EXP 89
74241: PUSH
74242: LD_VAR 0 2
74246: ARRAY
74247: PUSH
74248: LD_INT 1
74250: PLUS
74251: PUSH
74252: EMPTY
74253: LIST
74254: LIST
74255: PPUSH
74256: LD_EXP 88
74260: PUSH
74261: LD_VAR 0 2
74265: ARRAY
74266: PUSH
74267: LD_INT 1
74269: ARRAY
74270: PPUSH
74271: CALL 21529 0 3
74275: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
74276: LD_EXP 88
74280: PUSH
74281: LD_VAR 0 2
74285: ARRAY
74286: PUSH
74287: LD_INT 1
74289: ARRAY
74290: PPUSH
74291: LD_INT 112
74293: PPUSH
74294: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
74298: LD_ADDR_VAR 0 9
74302: PUSH
74303: LD_EXP 88
74307: PUSH
74308: LD_VAR 0 2
74312: ARRAY
74313: PPUSH
74314: LD_INT 1
74316: PPUSH
74317: CALL_OW 3
74321: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
74322: LD_ADDR_EXP 88
74326: PUSH
74327: LD_EXP 88
74331: PPUSH
74332: LD_VAR 0 2
74336: PPUSH
74337: LD_VAR 0 9
74341: PPUSH
74342: CALL_OW 1
74346: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
74347: LD_EXP 88
74351: PUSH
74352: LD_VAR 0 2
74356: ARRAY
74357: PUSH
74358: LD_EXP 89
74362: PUSH
74363: LD_VAR 0 2
74367: ARRAY
74368: AND
74369: PUSH
74370: LD_EXP 89
74374: PUSH
74375: LD_VAR 0 2
74379: ARRAY
74380: PUSH
74381: LD_INT 1
74383: ARRAY
74384: PPUSH
74385: CALL_OW 310
74389: NOT
74390: AND
74391: PUSH
74392: LD_VAR 0 3
74396: PPUSH
74397: CALL_OW 313
74401: PUSH
74402: LD_INT 6
74404: EQUAL
74405: AND
74406: IFFALSE 74462
// begin tmp2 := UnitsInside ( j ) ;
74408: LD_ADDR_VAR 0 9
74412: PUSH
74413: LD_VAR 0 3
74417: PPUSH
74418: CALL_OW 313
74422: ST_TO_ADDR
// if tmp2 = 6 then
74423: LD_VAR 0 9
74427: PUSH
74428: LD_INT 6
74430: EQUAL
74431: IFFALSE 74462
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
74433: LD_VAR 0 9
74437: PUSH
74438: LD_INT 1
74440: ARRAY
74441: PPUSH
74442: LD_INT 112
74444: PPUSH
74445: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
74449: LD_VAR 0 9
74453: PUSH
74454: LD_INT 1
74456: ARRAY
74457: PPUSH
74458: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
74462: LD_EXP 89
74466: PUSH
74467: LD_VAR 0 2
74471: ARRAY
74472: PUSH
74473: LD_EXP 89
74477: PUSH
74478: LD_VAR 0 2
74482: ARRAY
74483: PUSH
74484: LD_INT 1
74486: ARRAY
74487: PPUSH
74488: CALL_OW 314
74492: NOT
74493: AND
74494: PUSH
74495: LD_EXP 89
74499: PUSH
74500: LD_VAR 0 2
74504: ARRAY
74505: PUSH
74506: LD_INT 1
74508: ARRAY
74509: PPUSH
74510: CALL_OW 310
74514: NOT
74515: AND
74516: IFFALSE 74542
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
74518: LD_EXP 89
74522: PUSH
74523: LD_VAR 0 2
74527: ARRAY
74528: PUSH
74529: LD_INT 1
74531: ARRAY
74532: PPUSH
74533: LD_VAR 0 3
74537: PPUSH
74538: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
74542: LD_EXP 89
74546: PUSH
74547: LD_VAR 0 2
74551: ARRAY
74552: PUSH
74553: LD_INT 1
74555: ARRAY
74556: PPUSH
74557: CALL_OW 310
74561: PUSH
74562: LD_EXP 89
74566: PUSH
74567: LD_VAR 0 2
74571: ARRAY
74572: PUSH
74573: LD_INT 1
74575: ARRAY
74576: PPUSH
74577: CALL_OW 310
74581: PPUSH
74582: CALL_OW 461
74586: PUSH
74587: LD_INT 3
74589: NONEQUAL
74590: AND
74591: IFFALSE 74612
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74593: LD_EXP 89
74597: PUSH
74598: LD_VAR 0 2
74602: ARRAY
74603: PUSH
74604: LD_INT 1
74606: ARRAY
74607: PPUSH
74608: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74612: LD_VAR 0 3
74616: PPUSH
74617: CALL_OW 461
74621: PUSH
74622: LD_INT 6
74624: EQUAL
74625: PUSH
74626: LD_VAR 0 6
74630: PUSH
74631: LD_INT 1
74633: GREATER
74634: AND
74635: IFFALSE 74787
// begin sci := [ ] ;
74637: LD_ADDR_VAR 0 8
74641: PUSH
74642: EMPTY
74643: ST_TO_ADDR
// for x in ( tmp diff j ) do
74644: LD_ADDR_VAR 0 7
74648: PUSH
74649: LD_VAR 0 6
74653: PUSH
74654: LD_VAR 0 3
74658: DIFF
74659: PUSH
74660: FOR_IN
74661: IFFALSE 74713
// begin if sci = 6 then
74663: LD_VAR 0 8
74667: PUSH
74668: LD_INT 6
74670: EQUAL
74671: IFFALSE 74675
// break ;
74673: GO 74713
// if BuildingStatus ( x ) = bs_idle then
74675: LD_VAR 0 7
74679: PPUSH
74680: CALL_OW 461
74684: PUSH
74685: LD_INT 2
74687: EQUAL
74688: IFFALSE 74711
// sci := sci ^ UnitsInside ( x ) ;
74690: LD_ADDR_VAR 0 8
74694: PUSH
74695: LD_VAR 0 8
74699: PUSH
74700: LD_VAR 0 7
74704: PPUSH
74705: CALL_OW 313
74709: ADD
74710: ST_TO_ADDR
// end ;
74711: GO 74660
74713: POP
74714: POP
// if not sci then
74715: LD_VAR 0 8
74719: NOT
74720: IFFALSE 74724
// continue ;
74722: GO 73769
// for x in sci do
74724: LD_ADDR_VAR 0 7
74728: PUSH
74729: LD_VAR 0 8
74733: PUSH
74734: FOR_IN
74735: IFFALSE 74785
// if IsInUnit ( x ) and not HasTask ( x ) then
74737: LD_VAR 0 7
74741: PPUSH
74742: CALL_OW 310
74746: PUSH
74747: LD_VAR 0 7
74751: PPUSH
74752: CALL_OW 314
74756: NOT
74757: AND
74758: IFFALSE 74783
// begin ComExitBuilding ( x ) ;
74760: LD_VAR 0 7
74764: PPUSH
74765: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74769: LD_VAR 0 7
74773: PPUSH
74774: LD_VAR 0 3
74778: PPUSH
74779: CALL_OW 180
// end ;
74783: GO 74734
74785: POP
74786: POP
// end ; end ;
74787: GO 73769
74789: POP
74790: POP
// end ;
74791: GO 73723
74793: POP
74794: POP
// end ;
74795: LD_VAR 0 1
74799: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74800: LD_INT 0
74802: PPUSH
74803: PPUSH
// if not mc_bases then
74804: LD_EXP 59
74808: NOT
74809: IFFALSE 74813
// exit ;
74811: GO 74894
// for i = 1 to mc_bases do
74813: LD_ADDR_VAR 0 2
74817: PUSH
74818: DOUBLE
74819: LD_INT 1
74821: DEC
74822: ST_TO_ADDR
74823: LD_EXP 59
74827: PUSH
74828: FOR_TO
74829: IFFALSE 74892
// if mc_mines [ i ] and mc_miners [ i ] then
74831: LD_EXP 72
74835: PUSH
74836: LD_VAR 0 2
74840: ARRAY
74841: PUSH
74842: LD_EXP 73
74846: PUSH
74847: LD_VAR 0 2
74851: ARRAY
74852: AND
74853: IFFALSE 74890
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74855: LD_EXP 73
74859: PUSH
74860: LD_VAR 0 2
74864: ARRAY
74865: PUSH
74866: LD_INT 1
74868: ARRAY
74869: PPUSH
74870: CALL_OW 255
74874: PPUSH
74875: LD_EXP 72
74879: PUSH
74880: LD_VAR 0 2
74884: ARRAY
74885: PPUSH
74886: CALL 18518 0 2
74890: GO 74828
74892: POP
74893: POP
// end ;
74894: LD_VAR 0 1
74898: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
74899: LD_INT 0
74901: PPUSH
74902: PPUSH
74903: PPUSH
74904: PPUSH
74905: PPUSH
74906: PPUSH
74907: PPUSH
74908: PPUSH
// if not mc_bases or not mc_parking then
74909: LD_EXP 59
74913: NOT
74914: PUSH
74915: LD_EXP 83
74919: NOT
74920: OR
74921: IFFALSE 74925
// exit ;
74923: GO 75624
// for i = 1 to mc_bases do
74925: LD_ADDR_VAR 0 2
74929: PUSH
74930: DOUBLE
74931: LD_INT 1
74933: DEC
74934: ST_TO_ADDR
74935: LD_EXP 59
74939: PUSH
74940: FOR_TO
74941: IFFALSE 75622
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
74943: LD_EXP 59
74947: PUSH
74948: LD_VAR 0 2
74952: ARRAY
74953: NOT
74954: PUSH
74955: LD_EXP 83
74959: PUSH
74960: LD_VAR 0 2
74964: ARRAY
74965: NOT
74966: OR
74967: IFFALSE 74971
// continue ;
74969: GO 74940
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74971: LD_ADDR_VAR 0 5
74975: PUSH
74976: LD_EXP 59
74980: PUSH
74981: LD_VAR 0 2
74985: ARRAY
74986: PUSH
74987: LD_INT 1
74989: ARRAY
74990: PPUSH
74991: CALL_OW 255
74995: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74996: LD_ADDR_VAR 0 6
75000: PUSH
75001: LD_EXP 59
75005: PUSH
75006: LD_VAR 0 2
75010: ARRAY
75011: PPUSH
75012: LD_INT 30
75014: PUSH
75015: LD_INT 3
75017: PUSH
75018: EMPTY
75019: LIST
75020: LIST
75021: PPUSH
75022: CALL_OW 72
75026: ST_TO_ADDR
// if not fac then
75027: LD_VAR 0 6
75031: NOT
75032: IFFALSE 75083
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75034: LD_ADDR_VAR 0 6
75038: PUSH
75039: LD_EXP 59
75043: PUSH
75044: LD_VAR 0 2
75048: ARRAY
75049: PPUSH
75050: LD_INT 2
75052: PUSH
75053: LD_INT 30
75055: PUSH
75056: LD_INT 0
75058: PUSH
75059: EMPTY
75060: LIST
75061: LIST
75062: PUSH
75063: LD_INT 30
75065: PUSH
75066: LD_INT 1
75068: PUSH
75069: EMPTY
75070: LIST
75071: LIST
75072: PUSH
75073: EMPTY
75074: LIST
75075: LIST
75076: LIST
75077: PPUSH
75078: CALL_OW 72
75082: ST_TO_ADDR
// if not fac then
75083: LD_VAR 0 6
75087: NOT
75088: IFFALSE 75092
// continue ;
75090: GO 74940
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75092: LD_ADDR_VAR 0 7
75096: PUSH
75097: LD_EXP 83
75101: PUSH
75102: LD_VAR 0 2
75106: ARRAY
75107: PPUSH
75108: LD_INT 22
75110: PUSH
75111: LD_VAR 0 5
75115: PUSH
75116: EMPTY
75117: LIST
75118: LIST
75119: PUSH
75120: LD_INT 21
75122: PUSH
75123: LD_INT 2
75125: PUSH
75126: EMPTY
75127: LIST
75128: LIST
75129: PUSH
75130: LD_INT 3
75132: PUSH
75133: LD_INT 24
75135: PUSH
75136: LD_INT 1000
75138: PUSH
75139: EMPTY
75140: LIST
75141: LIST
75142: PUSH
75143: EMPTY
75144: LIST
75145: LIST
75146: PUSH
75147: EMPTY
75148: LIST
75149: LIST
75150: LIST
75151: PPUSH
75152: CALL_OW 70
75156: ST_TO_ADDR
// for j in fac do
75157: LD_ADDR_VAR 0 3
75161: PUSH
75162: LD_VAR 0 6
75166: PUSH
75167: FOR_IN
75168: IFFALSE 75249
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75170: LD_ADDR_VAR 0 7
75174: PUSH
75175: LD_VAR 0 7
75179: PUSH
75180: LD_INT 22
75182: PUSH
75183: LD_VAR 0 5
75187: PUSH
75188: EMPTY
75189: LIST
75190: LIST
75191: PUSH
75192: LD_INT 91
75194: PUSH
75195: LD_VAR 0 3
75199: PUSH
75200: LD_INT 15
75202: PUSH
75203: EMPTY
75204: LIST
75205: LIST
75206: LIST
75207: PUSH
75208: LD_INT 21
75210: PUSH
75211: LD_INT 2
75213: PUSH
75214: EMPTY
75215: LIST
75216: LIST
75217: PUSH
75218: LD_INT 3
75220: PUSH
75221: LD_INT 24
75223: PUSH
75224: LD_INT 1000
75226: PUSH
75227: EMPTY
75228: LIST
75229: LIST
75230: PUSH
75231: EMPTY
75232: LIST
75233: LIST
75234: PUSH
75235: EMPTY
75236: LIST
75237: LIST
75238: LIST
75239: LIST
75240: PPUSH
75241: CALL_OW 69
75245: UNION
75246: ST_TO_ADDR
75247: GO 75167
75249: POP
75250: POP
// if not vehs then
75251: LD_VAR 0 7
75255: NOT
75256: IFFALSE 75282
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
75258: LD_ADDR_EXP 71
75262: PUSH
75263: LD_EXP 71
75267: PPUSH
75268: LD_VAR 0 2
75272: PPUSH
75273: EMPTY
75274: PPUSH
75275: CALL_OW 1
75279: ST_TO_ADDR
// continue ;
75280: GO 74940
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75282: LD_ADDR_VAR 0 8
75286: PUSH
75287: LD_EXP 59
75291: PUSH
75292: LD_VAR 0 2
75296: ARRAY
75297: PPUSH
75298: LD_INT 30
75300: PUSH
75301: LD_INT 3
75303: PUSH
75304: EMPTY
75305: LIST
75306: LIST
75307: PPUSH
75308: CALL_OW 72
75312: ST_TO_ADDR
// if tmp then
75313: LD_VAR 0 8
75317: IFFALSE 75420
// begin for j in tmp do
75319: LD_ADDR_VAR 0 3
75323: PUSH
75324: LD_VAR 0 8
75328: PUSH
75329: FOR_IN
75330: IFFALSE 75418
// for k in UnitsInside ( j ) do
75332: LD_ADDR_VAR 0 4
75336: PUSH
75337: LD_VAR 0 3
75341: PPUSH
75342: CALL_OW 313
75346: PUSH
75347: FOR_IN
75348: IFFALSE 75414
// if k then
75350: LD_VAR 0 4
75354: IFFALSE 75412
// if not k in mc_repair_vehicle [ i ] then
75356: LD_VAR 0 4
75360: PUSH
75361: LD_EXP 71
75365: PUSH
75366: LD_VAR 0 2
75370: ARRAY
75371: IN
75372: NOT
75373: IFFALSE 75412
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
75375: LD_ADDR_EXP 71
75379: PUSH
75380: LD_EXP 71
75384: PPUSH
75385: LD_VAR 0 2
75389: PPUSH
75390: LD_EXP 71
75394: PUSH
75395: LD_VAR 0 2
75399: ARRAY
75400: PUSH
75401: LD_VAR 0 4
75405: UNION
75406: PPUSH
75407: CALL_OW 1
75411: ST_TO_ADDR
75412: GO 75347
75414: POP
75415: POP
75416: GO 75329
75418: POP
75419: POP
// end ; if not mc_repair_vehicle [ i ] then
75420: LD_EXP 71
75424: PUSH
75425: LD_VAR 0 2
75429: ARRAY
75430: NOT
75431: IFFALSE 75435
// continue ;
75433: GO 74940
// for j in mc_repair_vehicle [ i ] do
75435: LD_ADDR_VAR 0 3
75439: PUSH
75440: LD_EXP 71
75444: PUSH
75445: LD_VAR 0 2
75449: ARRAY
75450: PUSH
75451: FOR_IN
75452: IFFALSE 75618
// begin if GetClass ( j ) <> 3 then
75454: LD_VAR 0 3
75458: PPUSH
75459: CALL_OW 257
75463: PUSH
75464: LD_INT 3
75466: NONEQUAL
75467: IFFALSE 75508
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
75469: LD_ADDR_EXP 71
75473: PUSH
75474: LD_EXP 71
75478: PPUSH
75479: LD_VAR 0 2
75483: PPUSH
75484: LD_EXP 71
75488: PUSH
75489: LD_VAR 0 2
75493: ARRAY
75494: PUSH
75495: LD_VAR 0 3
75499: DIFF
75500: PPUSH
75501: CALL_OW 1
75505: ST_TO_ADDR
// continue ;
75506: GO 75451
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75508: LD_VAR 0 3
75512: PPUSH
75513: CALL_OW 311
75517: NOT
75518: PUSH
75519: LD_VAR 0 3
75523: PUSH
75524: LD_EXP 62
75528: PUSH
75529: LD_VAR 0 2
75533: ARRAY
75534: PUSH
75535: LD_INT 1
75537: ARRAY
75538: IN
75539: NOT
75540: AND
75541: PUSH
75542: LD_VAR 0 3
75546: PUSH
75547: LD_EXP 62
75551: PUSH
75552: LD_VAR 0 2
75556: ARRAY
75557: PUSH
75558: LD_INT 2
75560: ARRAY
75561: IN
75562: NOT
75563: AND
75564: IFFALSE 75616
// begin if IsInUnit ( j ) then
75566: LD_VAR 0 3
75570: PPUSH
75571: CALL_OW 310
75575: IFFALSE 75586
// ComExitBuilding ( j ) ;
75577: LD_VAR 0 3
75581: PPUSH
75582: CALL_OW 122
// if not HasTask ( j ) then
75586: LD_VAR 0 3
75590: PPUSH
75591: CALL_OW 314
75595: NOT
75596: IFFALSE 75616
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
75598: LD_VAR 0 3
75602: PPUSH
75603: LD_VAR 0 7
75607: PUSH
75608: LD_INT 1
75610: ARRAY
75611: PPUSH
75612: CALL_OW 189
// end ; end ;
75616: GO 75451
75618: POP
75619: POP
// end ;
75620: GO 74940
75622: POP
75623: POP
// end ;
75624: LD_VAR 0 1
75628: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75629: LD_INT 0
75631: PPUSH
75632: PPUSH
75633: PPUSH
75634: PPUSH
75635: PPUSH
75636: PPUSH
75637: PPUSH
75638: PPUSH
75639: PPUSH
75640: PPUSH
75641: PPUSH
// if not mc_bases then
75642: LD_EXP 59
75646: NOT
75647: IFFALSE 75651
// exit ;
75649: GO 76453
// for i = 1 to mc_bases do
75651: LD_ADDR_VAR 0 2
75655: PUSH
75656: DOUBLE
75657: LD_INT 1
75659: DEC
75660: ST_TO_ADDR
75661: LD_EXP 59
75665: PUSH
75666: FOR_TO
75667: IFFALSE 76451
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75669: LD_EXP 87
75673: PUSH
75674: LD_VAR 0 2
75678: ARRAY
75679: NOT
75680: PUSH
75681: LD_EXP 62
75685: PUSH
75686: LD_VAR 0 2
75690: ARRAY
75691: PUSH
75692: LD_INT 1
75694: ARRAY
75695: OR
75696: PUSH
75697: LD_EXP 62
75701: PUSH
75702: LD_VAR 0 2
75706: ARRAY
75707: PUSH
75708: LD_INT 2
75710: ARRAY
75711: OR
75712: PUSH
75713: LD_EXP 85
75717: PUSH
75718: LD_VAR 0 2
75722: ARRAY
75723: PPUSH
75724: LD_INT 1
75726: PPUSH
75727: CALL_OW 325
75731: NOT
75732: OR
75733: PUSH
75734: LD_EXP 82
75738: PUSH
75739: LD_VAR 0 2
75743: ARRAY
75744: OR
75745: IFFALSE 75749
// continue ;
75747: GO 75666
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75749: LD_ADDR_VAR 0 8
75753: PUSH
75754: LD_EXP 59
75758: PUSH
75759: LD_VAR 0 2
75763: ARRAY
75764: PPUSH
75765: LD_INT 25
75767: PUSH
75768: LD_INT 4
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 50
75777: PUSH
75778: EMPTY
75779: LIST
75780: PUSH
75781: LD_INT 3
75783: PUSH
75784: LD_INT 60
75786: PUSH
75787: EMPTY
75788: LIST
75789: PUSH
75790: EMPTY
75791: LIST
75792: LIST
75793: PUSH
75794: EMPTY
75795: LIST
75796: LIST
75797: LIST
75798: PPUSH
75799: CALL_OW 72
75803: PUSH
75804: LD_EXP 63
75808: PUSH
75809: LD_VAR 0 2
75813: ARRAY
75814: DIFF
75815: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75816: LD_ADDR_VAR 0 9
75820: PUSH
75821: LD_EXP 59
75825: PUSH
75826: LD_VAR 0 2
75830: ARRAY
75831: PPUSH
75832: LD_INT 2
75834: PUSH
75835: LD_INT 30
75837: PUSH
75838: LD_INT 0
75840: PUSH
75841: EMPTY
75842: LIST
75843: LIST
75844: PUSH
75845: LD_INT 30
75847: PUSH
75848: LD_INT 1
75850: PUSH
75851: EMPTY
75852: LIST
75853: LIST
75854: PUSH
75855: EMPTY
75856: LIST
75857: LIST
75858: LIST
75859: PPUSH
75860: CALL_OW 72
75864: ST_TO_ADDR
// if not tmp or not dep then
75865: LD_VAR 0 8
75869: NOT
75870: PUSH
75871: LD_VAR 0 9
75875: NOT
75876: OR
75877: IFFALSE 75881
// continue ;
75879: GO 75666
// side := GetSide ( tmp [ 1 ] ) ;
75881: LD_ADDR_VAR 0 11
75885: PUSH
75886: LD_VAR 0 8
75890: PUSH
75891: LD_INT 1
75893: ARRAY
75894: PPUSH
75895: CALL_OW 255
75899: ST_TO_ADDR
// dep := dep [ 1 ] ;
75900: LD_ADDR_VAR 0 9
75904: PUSH
75905: LD_VAR 0 9
75909: PUSH
75910: LD_INT 1
75912: ARRAY
75913: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
75914: LD_ADDR_VAR 0 7
75918: PUSH
75919: LD_EXP 87
75923: PUSH
75924: LD_VAR 0 2
75928: ARRAY
75929: PPUSH
75930: LD_INT 22
75932: PUSH
75933: LD_INT 0
75935: PUSH
75936: EMPTY
75937: LIST
75938: LIST
75939: PUSH
75940: LD_INT 25
75942: PUSH
75943: LD_INT 12
75945: PUSH
75946: EMPTY
75947: LIST
75948: LIST
75949: PUSH
75950: EMPTY
75951: LIST
75952: LIST
75953: PPUSH
75954: CALL_OW 70
75958: PUSH
75959: LD_INT 22
75961: PUSH
75962: LD_INT 0
75964: PUSH
75965: EMPTY
75966: LIST
75967: LIST
75968: PUSH
75969: LD_INT 25
75971: PUSH
75972: LD_INT 12
75974: PUSH
75975: EMPTY
75976: LIST
75977: LIST
75978: PUSH
75979: LD_INT 91
75981: PUSH
75982: LD_VAR 0 9
75986: PUSH
75987: LD_INT 20
75989: PUSH
75990: EMPTY
75991: LIST
75992: LIST
75993: LIST
75994: PUSH
75995: EMPTY
75996: LIST
75997: LIST
75998: LIST
75999: PPUSH
76000: CALL_OW 69
76004: UNION
76005: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
76006: LD_ADDR_VAR 0 10
76010: PUSH
76011: LD_EXP 87
76015: PUSH
76016: LD_VAR 0 2
76020: ARRAY
76021: PPUSH
76022: LD_INT 81
76024: PUSH
76025: LD_VAR 0 11
76029: PUSH
76030: EMPTY
76031: LIST
76032: LIST
76033: PPUSH
76034: CALL_OW 70
76038: ST_TO_ADDR
// if not apes or danger_at_area then
76039: LD_VAR 0 7
76043: NOT
76044: PUSH
76045: LD_VAR 0 10
76049: OR
76050: IFFALSE 76100
// begin if mc_taming [ i ] then
76052: LD_EXP 90
76056: PUSH
76057: LD_VAR 0 2
76061: ARRAY
76062: IFFALSE 76098
// begin MC_Reset ( i , 121 ) ;
76064: LD_VAR 0 2
76068: PPUSH
76069: LD_INT 121
76071: PPUSH
76072: CALL 61535 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
76076: LD_ADDR_EXP 90
76080: PUSH
76081: LD_EXP 90
76085: PPUSH
76086: LD_VAR 0 2
76090: PPUSH
76091: EMPTY
76092: PPUSH
76093: CALL_OW 1
76097: ST_TO_ADDR
// end ; continue ;
76098: GO 75666
// end ; for j in tmp do
76100: LD_ADDR_VAR 0 3
76104: PUSH
76105: LD_VAR 0 8
76109: PUSH
76110: FOR_IN
76111: IFFALSE 76447
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
76113: LD_VAR 0 3
76117: PUSH
76118: LD_EXP 90
76122: PUSH
76123: LD_VAR 0 2
76127: ARRAY
76128: IN
76129: NOT
76130: PUSH
76131: LD_EXP 90
76135: PUSH
76136: LD_VAR 0 2
76140: ARRAY
76141: PUSH
76142: LD_INT 3
76144: LESS
76145: AND
76146: IFFALSE 76204
// begin SetTag ( j , 121 ) ;
76148: LD_VAR 0 3
76152: PPUSH
76153: LD_INT 121
76155: PPUSH
76156: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
76160: LD_ADDR_EXP 90
76164: PUSH
76165: LD_EXP 90
76169: PPUSH
76170: LD_VAR 0 2
76174: PUSH
76175: LD_EXP 90
76179: PUSH
76180: LD_VAR 0 2
76184: ARRAY
76185: PUSH
76186: LD_INT 1
76188: PLUS
76189: PUSH
76190: EMPTY
76191: LIST
76192: LIST
76193: PPUSH
76194: LD_VAR 0 3
76198: PPUSH
76199: CALL 21529 0 3
76203: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
76204: LD_VAR 0 3
76208: PUSH
76209: LD_EXP 90
76213: PUSH
76214: LD_VAR 0 2
76218: ARRAY
76219: IN
76220: IFFALSE 76445
// begin if GetClass ( j ) <> 4 then
76222: LD_VAR 0 3
76226: PPUSH
76227: CALL_OW 257
76231: PUSH
76232: LD_INT 4
76234: NONEQUAL
76235: IFFALSE 76288
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
76237: LD_ADDR_EXP 90
76241: PUSH
76242: LD_EXP 90
76246: PPUSH
76247: LD_VAR 0 2
76251: PPUSH
76252: LD_EXP 90
76256: PUSH
76257: LD_VAR 0 2
76261: ARRAY
76262: PUSH
76263: LD_VAR 0 3
76267: DIFF
76268: PPUSH
76269: CALL_OW 1
76273: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76274: LD_VAR 0 3
76278: PPUSH
76279: LD_INT 0
76281: PPUSH
76282: CALL_OW 109
// continue ;
76286: GO 76110
// end ; if IsInUnit ( j ) then
76288: LD_VAR 0 3
76292: PPUSH
76293: CALL_OW 310
76297: IFFALSE 76308
// ComExitBuilding ( j ) ;
76299: LD_VAR 0 3
76303: PPUSH
76304: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
76308: LD_ADDR_VAR 0 6
76312: PUSH
76313: LD_VAR 0 7
76317: PPUSH
76318: LD_VAR 0 3
76322: PPUSH
76323: CALL_OW 74
76327: ST_TO_ADDR
// if not ape then
76328: LD_VAR 0 6
76332: NOT
76333: IFFALSE 76337
// break ;
76335: GO 76447
// x := GetX ( ape ) ;
76337: LD_ADDR_VAR 0 4
76341: PUSH
76342: LD_VAR 0 6
76346: PPUSH
76347: CALL_OW 250
76351: ST_TO_ADDR
// y := GetY ( ape ) ;
76352: LD_ADDR_VAR 0 5
76356: PUSH
76357: LD_VAR 0 6
76361: PPUSH
76362: CALL_OW 251
76366: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76367: LD_VAR 0 4
76371: PPUSH
76372: LD_VAR 0 5
76376: PPUSH
76377: CALL_OW 488
76381: NOT
76382: PUSH
76383: LD_VAR 0 11
76387: PPUSH
76388: LD_VAR 0 4
76392: PPUSH
76393: LD_VAR 0 5
76397: PPUSH
76398: LD_INT 20
76400: PPUSH
76401: CALL 22425 0 4
76405: PUSH
76406: LD_INT 4
76408: ARRAY
76409: OR
76410: IFFALSE 76414
// break ;
76412: GO 76447
// if not HasTask ( j ) then
76414: LD_VAR 0 3
76418: PPUSH
76419: CALL_OW 314
76423: NOT
76424: IFFALSE 76445
// ComTameXY ( j , x , y ) ;
76426: LD_VAR 0 3
76430: PPUSH
76431: LD_VAR 0 4
76435: PPUSH
76436: LD_VAR 0 5
76440: PPUSH
76441: CALL_OW 131
// end ; end ;
76445: GO 76110
76447: POP
76448: POP
// end ;
76449: GO 75666
76451: POP
76452: POP
// end ;
76453: LD_VAR 0 1
76457: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
76458: LD_INT 0
76460: PPUSH
76461: PPUSH
76462: PPUSH
76463: PPUSH
76464: PPUSH
76465: PPUSH
76466: PPUSH
76467: PPUSH
// if not mc_bases then
76468: LD_EXP 59
76472: NOT
76473: IFFALSE 76477
// exit ;
76475: GO 77103
// for i = 1 to mc_bases do
76477: LD_ADDR_VAR 0 2
76481: PUSH
76482: DOUBLE
76483: LD_INT 1
76485: DEC
76486: ST_TO_ADDR
76487: LD_EXP 59
76491: PUSH
76492: FOR_TO
76493: IFFALSE 77101
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
76495: LD_EXP 88
76499: PUSH
76500: LD_VAR 0 2
76504: ARRAY
76505: NOT
76506: PUSH
76507: LD_EXP 88
76511: PUSH
76512: LD_VAR 0 2
76516: ARRAY
76517: PPUSH
76518: LD_INT 25
76520: PUSH
76521: LD_INT 12
76523: PUSH
76524: EMPTY
76525: LIST
76526: LIST
76527: PPUSH
76528: CALL_OW 72
76532: NOT
76533: OR
76534: IFFALSE 76538
// continue ;
76536: GO 76492
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
76538: LD_ADDR_VAR 0 5
76542: PUSH
76543: LD_EXP 88
76547: PUSH
76548: LD_VAR 0 2
76552: ARRAY
76553: PUSH
76554: LD_INT 1
76556: ARRAY
76557: PPUSH
76558: CALL_OW 255
76562: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
76563: LD_VAR 0 5
76567: PPUSH
76568: LD_INT 2
76570: PPUSH
76571: CALL_OW 325
76575: IFFALSE 76828
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76577: LD_ADDR_VAR 0 4
76581: PUSH
76582: LD_EXP 88
76586: PUSH
76587: LD_VAR 0 2
76591: ARRAY
76592: PPUSH
76593: LD_INT 25
76595: PUSH
76596: LD_INT 16
76598: PUSH
76599: EMPTY
76600: LIST
76601: LIST
76602: PPUSH
76603: CALL_OW 72
76607: ST_TO_ADDR
// if tmp < 6 then
76608: LD_VAR 0 4
76612: PUSH
76613: LD_INT 6
76615: LESS
76616: IFFALSE 76828
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76618: LD_ADDR_VAR 0 6
76622: PUSH
76623: LD_EXP 59
76627: PUSH
76628: LD_VAR 0 2
76632: ARRAY
76633: PPUSH
76634: LD_INT 2
76636: PUSH
76637: LD_INT 30
76639: PUSH
76640: LD_INT 0
76642: PUSH
76643: EMPTY
76644: LIST
76645: LIST
76646: PUSH
76647: LD_INT 30
76649: PUSH
76650: LD_INT 1
76652: PUSH
76653: EMPTY
76654: LIST
76655: LIST
76656: PUSH
76657: EMPTY
76658: LIST
76659: LIST
76660: LIST
76661: PPUSH
76662: CALL_OW 72
76666: ST_TO_ADDR
// if depot then
76667: LD_VAR 0 6
76671: IFFALSE 76828
// begin selected := 0 ;
76673: LD_ADDR_VAR 0 7
76677: PUSH
76678: LD_INT 0
76680: ST_TO_ADDR
// for j in depot do
76681: LD_ADDR_VAR 0 3
76685: PUSH
76686: LD_VAR 0 6
76690: PUSH
76691: FOR_IN
76692: IFFALSE 76723
// begin if UnitsInside ( j ) < 6 then
76694: LD_VAR 0 3
76698: PPUSH
76699: CALL_OW 313
76703: PUSH
76704: LD_INT 6
76706: LESS
76707: IFFALSE 76721
// begin selected := j ;
76709: LD_ADDR_VAR 0 7
76713: PUSH
76714: LD_VAR 0 3
76718: ST_TO_ADDR
// break ;
76719: GO 76723
// end ; end ;
76721: GO 76691
76723: POP
76724: POP
// if selected then
76725: LD_VAR 0 7
76729: IFFALSE 76828
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76731: LD_ADDR_VAR 0 3
76735: PUSH
76736: LD_EXP 88
76740: PUSH
76741: LD_VAR 0 2
76745: ARRAY
76746: PPUSH
76747: LD_INT 25
76749: PUSH
76750: LD_INT 12
76752: PUSH
76753: EMPTY
76754: LIST
76755: LIST
76756: PPUSH
76757: CALL_OW 72
76761: PUSH
76762: FOR_IN
76763: IFFALSE 76826
// if not HasTask ( j ) then
76765: LD_VAR 0 3
76769: PPUSH
76770: CALL_OW 314
76774: NOT
76775: IFFALSE 76824
// begin if not IsInUnit ( j ) then
76777: LD_VAR 0 3
76781: PPUSH
76782: CALL_OW 310
76786: NOT
76787: IFFALSE 76803
// ComEnterUnit ( j , selected ) ;
76789: LD_VAR 0 3
76793: PPUSH
76794: LD_VAR 0 7
76798: PPUSH
76799: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76803: LD_VAR 0 3
76807: PPUSH
76808: LD_INT 16
76810: PPUSH
76811: CALL_OW 183
// AddComExitBuilding ( j ) ;
76815: LD_VAR 0 3
76819: PPUSH
76820: CALL_OW 182
// end ;
76824: GO 76762
76826: POP
76827: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76828: LD_VAR 0 5
76832: PPUSH
76833: LD_INT 11
76835: PPUSH
76836: CALL_OW 325
76840: IFFALSE 77099
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76842: LD_ADDR_VAR 0 4
76846: PUSH
76847: LD_EXP 88
76851: PUSH
76852: LD_VAR 0 2
76856: ARRAY
76857: PPUSH
76858: LD_INT 25
76860: PUSH
76861: LD_INT 16
76863: PUSH
76864: EMPTY
76865: LIST
76866: LIST
76867: PPUSH
76868: CALL_OW 72
76872: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
76873: LD_VAR 0 4
76877: PUSH
76878: LD_INT 6
76880: GREATEREQUAL
76881: PUSH
76882: LD_VAR 0 5
76886: PPUSH
76887: LD_INT 2
76889: PPUSH
76890: CALL_OW 325
76894: NOT
76895: OR
76896: IFFALSE 77099
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76898: LD_ADDR_VAR 0 8
76902: PUSH
76903: LD_EXP 59
76907: PUSH
76908: LD_VAR 0 2
76912: ARRAY
76913: PPUSH
76914: LD_INT 2
76916: PUSH
76917: LD_INT 30
76919: PUSH
76920: LD_INT 4
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: LD_INT 30
76929: PUSH
76930: LD_INT 5
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: PUSH
76937: EMPTY
76938: LIST
76939: LIST
76940: LIST
76941: PPUSH
76942: CALL_OW 72
76946: ST_TO_ADDR
// if barracks then
76947: LD_VAR 0 8
76951: IFFALSE 77099
// begin selected := 0 ;
76953: LD_ADDR_VAR 0 7
76957: PUSH
76958: LD_INT 0
76960: ST_TO_ADDR
// for j in barracks do
76961: LD_ADDR_VAR 0 3
76965: PUSH
76966: LD_VAR 0 8
76970: PUSH
76971: FOR_IN
76972: IFFALSE 77003
// begin if UnitsInside ( j ) < 6 then
76974: LD_VAR 0 3
76978: PPUSH
76979: CALL_OW 313
76983: PUSH
76984: LD_INT 6
76986: LESS
76987: IFFALSE 77001
// begin selected := j ;
76989: LD_ADDR_VAR 0 7
76993: PUSH
76994: LD_VAR 0 3
76998: ST_TO_ADDR
// break ;
76999: GO 77003
// end ; end ;
77001: GO 76971
77003: POP
77004: POP
// if selected then
77005: LD_VAR 0 7
77009: IFFALSE 77099
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
77011: LD_ADDR_VAR 0 3
77015: PUSH
77016: LD_EXP 88
77020: PUSH
77021: LD_VAR 0 2
77025: ARRAY
77026: PPUSH
77027: LD_INT 25
77029: PUSH
77030: LD_INT 12
77032: PUSH
77033: EMPTY
77034: LIST
77035: LIST
77036: PPUSH
77037: CALL_OW 72
77041: PUSH
77042: FOR_IN
77043: IFFALSE 77097
// if not IsInUnit ( j ) and not HasTask ( j ) then
77045: LD_VAR 0 3
77049: PPUSH
77050: CALL_OW 310
77054: NOT
77055: PUSH
77056: LD_VAR 0 3
77060: PPUSH
77061: CALL_OW 314
77065: NOT
77066: AND
77067: IFFALSE 77095
// begin ComEnterUnit ( j , selected ) ;
77069: LD_VAR 0 3
77073: PPUSH
77074: LD_VAR 0 7
77078: PPUSH
77079: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
77083: LD_VAR 0 3
77087: PPUSH
77088: LD_INT 15
77090: PPUSH
77091: CALL_OW 183
// end ;
77095: GO 77042
77097: POP
77098: POP
// end ; end ; end ; end ; end ;
77099: GO 76492
77101: POP
77102: POP
// end ;
77103: LD_VAR 0 1
77107: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
77108: LD_INT 0
77110: PPUSH
77111: PPUSH
77112: PPUSH
77113: PPUSH
// if not mc_bases then
77114: LD_EXP 59
77118: NOT
77119: IFFALSE 77123
// exit ;
77121: GO 77301
// for i = 1 to mc_bases do
77123: LD_ADDR_VAR 0 2
77127: PUSH
77128: DOUBLE
77129: LD_INT 1
77131: DEC
77132: ST_TO_ADDR
77133: LD_EXP 59
77137: PUSH
77138: FOR_TO
77139: IFFALSE 77299
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
77141: LD_ADDR_VAR 0 4
77145: PUSH
77146: LD_EXP 59
77150: PUSH
77151: LD_VAR 0 2
77155: ARRAY
77156: PPUSH
77157: LD_INT 25
77159: PUSH
77160: LD_INT 9
77162: PUSH
77163: EMPTY
77164: LIST
77165: LIST
77166: PPUSH
77167: CALL_OW 72
77171: ST_TO_ADDR
// if not tmp then
77172: LD_VAR 0 4
77176: NOT
77177: IFFALSE 77181
// continue ;
77179: GO 77138
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
77181: LD_EXP 85
77185: PUSH
77186: LD_VAR 0 2
77190: ARRAY
77191: PPUSH
77192: LD_INT 29
77194: PPUSH
77195: CALL_OW 325
77199: NOT
77200: PUSH
77201: LD_EXP 85
77205: PUSH
77206: LD_VAR 0 2
77210: ARRAY
77211: PPUSH
77212: LD_INT 28
77214: PPUSH
77215: CALL_OW 325
77219: NOT
77220: AND
77221: IFFALSE 77225
// continue ;
77223: GO 77138
// for j in tmp do
77225: LD_ADDR_VAR 0 3
77229: PUSH
77230: LD_VAR 0 4
77234: PUSH
77235: FOR_IN
77236: IFFALSE 77295
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
77238: LD_VAR 0 3
77242: PUSH
77243: LD_EXP 62
77247: PUSH
77248: LD_VAR 0 2
77252: ARRAY
77253: PUSH
77254: LD_INT 1
77256: ARRAY
77257: IN
77258: NOT
77259: PUSH
77260: LD_VAR 0 3
77264: PUSH
77265: LD_EXP 62
77269: PUSH
77270: LD_VAR 0 2
77274: ARRAY
77275: PUSH
77276: LD_INT 2
77278: ARRAY
77279: IN
77280: NOT
77281: AND
77282: IFFALSE 77293
// ComSpaceTimeShoot ( j ) ;
77284: LD_VAR 0 3
77288: PPUSH
77289: CALL 15115 0 1
77293: GO 77235
77295: POP
77296: POP
// end ;
77297: GO 77138
77299: POP
77300: POP
// end ;
77301: LD_VAR 0 1
77305: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
77306: LD_INT 0
77308: PPUSH
77309: PPUSH
77310: PPUSH
77311: PPUSH
77312: PPUSH
77313: PPUSH
77314: PPUSH
77315: PPUSH
77316: PPUSH
// if not mc_bases then
77317: LD_EXP 59
77321: NOT
77322: IFFALSE 77326
// exit ;
77324: GO 77948
// for i = 1 to mc_bases do
77326: LD_ADDR_VAR 0 2
77330: PUSH
77331: DOUBLE
77332: LD_INT 1
77334: DEC
77335: ST_TO_ADDR
77336: LD_EXP 59
77340: PUSH
77341: FOR_TO
77342: IFFALSE 77946
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
77344: LD_EXP 94
77348: PUSH
77349: LD_VAR 0 2
77353: ARRAY
77354: NOT
77355: PUSH
77356: LD_INT 38
77358: PPUSH
77359: LD_EXP 85
77363: PUSH
77364: LD_VAR 0 2
77368: ARRAY
77369: PPUSH
77370: CALL_OW 321
77374: PUSH
77375: LD_INT 2
77377: NONEQUAL
77378: OR
77379: IFFALSE 77383
// continue ;
77381: GO 77341
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
77383: LD_ADDR_VAR 0 8
77387: PUSH
77388: LD_EXP 59
77392: PUSH
77393: LD_VAR 0 2
77397: ARRAY
77398: PPUSH
77399: LD_INT 30
77401: PUSH
77402: LD_INT 34
77404: PUSH
77405: EMPTY
77406: LIST
77407: LIST
77408: PPUSH
77409: CALL_OW 72
77413: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
77414: LD_ADDR_VAR 0 9
77418: PUSH
77419: LD_EXP 59
77423: PUSH
77424: LD_VAR 0 2
77428: ARRAY
77429: PPUSH
77430: LD_INT 25
77432: PUSH
77433: LD_INT 4
77435: PUSH
77436: EMPTY
77437: LIST
77438: LIST
77439: PPUSH
77440: CALL_OW 72
77444: PPUSH
77445: LD_INT 0
77447: PPUSH
77448: CALL 54792 0 2
77452: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
77453: LD_VAR 0 9
77457: NOT
77458: PUSH
77459: LD_VAR 0 8
77463: NOT
77464: OR
77465: PUSH
77466: LD_EXP 59
77470: PUSH
77471: LD_VAR 0 2
77475: ARRAY
77476: PPUSH
77477: LD_INT 124
77479: PPUSH
77480: CALL 54792 0 2
77484: OR
77485: IFFALSE 77489
// continue ;
77487: GO 77341
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
77489: LD_EXP 95
77493: PUSH
77494: LD_VAR 0 2
77498: ARRAY
77499: PUSH
77500: LD_EXP 94
77504: PUSH
77505: LD_VAR 0 2
77509: ARRAY
77510: LESS
77511: PUSH
77512: LD_EXP 95
77516: PUSH
77517: LD_VAR 0 2
77521: ARRAY
77522: PUSH
77523: LD_VAR 0 8
77527: LESS
77528: AND
77529: IFFALSE 77944
// begin tmp := sci [ 1 ] ;
77531: LD_ADDR_VAR 0 7
77535: PUSH
77536: LD_VAR 0 9
77540: PUSH
77541: LD_INT 1
77543: ARRAY
77544: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
77545: LD_VAR 0 7
77549: PPUSH
77550: LD_INT 124
77552: PPUSH
77553: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
77557: LD_ADDR_VAR 0 3
77561: PUSH
77562: DOUBLE
77563: LD_EXP 94
77567: PUSH
77568: LD_VAR 0 2
77572: ARRAY
77573: INC
77574: ST_TO_ADDR
77575: LD_EXP 94
77579: PUSH
77580: LD_VAR 0 2
77584: ARRAY
77585: PUSH
77586: FOR_DOWNTO
77587: IFFALSE 77930
// begin if IsInUnit ( tmp ) then
77589: LD_VAR 0 7
77593: PPUSH
77594: CALL_OW 310
77598: IFFALSE 77609
// ComExitBuilding ( tmp ) ;
77600: LD_VAR 0 7
77604: PPUSH
77605: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77609: LD_INT 35
77611: PPUSH
77612: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77616: LD_VAR 0 7
77620: PPUSH
77621: CALL_OW 310
77625: NOT
77626: PUSH
77627: LD_VAR 0 7
77631: PPUSH
77632: CALL_OW 314
77636: NOT
77637: AND
77638: IFFALSE 77609
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77640: LD_ADDR_VAR 0 6
77644: PUSH
77645: LD_VAR 0 7
77649: PPUSH
77650: CALL_OW 250
77654: PUSH
77655: LD_VAR 0 7
77659: PPUSH
77660: CALL_OW 251
77664: PUSH
77665: EMPTY
77666: LIST
77667: LIST
77668: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77669: LD_INT 35
77671: PPUSH
77672: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77676: LD_ADDR_VAR 0 4
77680: PUSH
77681: LD_EXP 94
77685: PUSH
77686: LD_VAR 0 2
77690: ARRAY
77691: PUSH
77692: LD_VAR 0 3
77696: ARRAY
77697: PUSH
77698: LD_INT 1
77700: ARRAY
77701: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77702: LD_ADDR_VAR 0 5
77706: PUSH
77707: LD_EXP 94
77711: PUSH
77712: LD_VAR 0 2
77716: ARRAY
77717: PUSH
77718: LD_VAR 0 3
77722: ARRAY
77723: PUSH
77724: LD_INT 2
77726: ARRAY
77727: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77728: LD_VAR 0 7
77732: PPUSH
77733: LD_INT 10
77735: PPUSH
77736: CALL 24122 0 2
77740: PUSH
77741: LD_INT 4
77743: ARRAY
77744: IFFALSE 77782
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77746: LD_VAR 0 7
77750: PPUSH
77751: LD_VAR 0 6
77755: PUSH
77756: LD_INT 1
77758: ARRAY
77759: PPUSH
77760: LD_VAR 0 6
77764: PUSH
77765: LD_INT 2
77767: ARRAY
77768: PPUSH
77769: CALL_OW 111
// wait ( 0 0$10 ) ;
77773: LD_INT 350
77775: PPUSH
77776: CALL_OW 67
// end else
77780: GO 77808
// begin ComMoveXY ( tmp , x , y ) ;
77782: LD_VAR 0 7
77786: PPUSH
77787: LD_VAR 0 4
77791: PPUSH
77792: LD_VAR 0 5
77796: PPUSH
77797: CALL_OW 111
// wait ( 0 0$3 ) ;
77801: LD_INT 105
77803: PPUSH
77804: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77808: LD_VAR 0 7
77812: PPUSH
77813: LD_VAR 0 4
77817: PPUSH
77818: LD_VAR 0 5
77822: PPUSH
77823: CALL_OW 307
77827: IFFALSE 77669
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77829: LD_VAR 0 7
77833: PPUSH
77834: LD_VAR 0 4
77838: PPUSH
77839: LD_VAR 0 5
77843: PPUSH
77844: LD_VAR 0 8
77848: PUSH
77849: LD_VAR 0 3
77853: ARRAY
77854: PPUSH
77855: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77859: LD_INT 35
77861: PPUSH
77862: CALL_OW 67
// until not HasTask ( tmp ) ;
77866: LD_VAR 0 7
77870: PPUSH
77871: CALL_OW 314
77875: NOT
77876: IFFALSE 77859
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
77878: LD_ADDR_EXP 95
77882: PUSH
77883: LD_EXP 95
77887: PPUSH
77888: LD_VAR 0 2
77892: PUSH
77893: LD_EXP 95
77897: PUSH
77898: LD_VAR 0 2
77902: ARRAY
77903: PUSH
77904: LD_INT 1
77906: PLUS
77907: PUSH
77908: EMPTY
77909: LIST
77910: LIST
77911: PPUSH
77912: LD_VAR 0 8
77916: PUSH
77917: LD_VAR 0 3
77921: ARRAY
77922: PPUSH
77923: CALL 21529 0 3
77927: ST_TO_ADDR
// end ;
77928: GO 77586
77930: POP
77931: POP
// MC_Reset ( i , 124 ) ;
77932: LD_VAR 0 2
77936: PPUSH
77937: LD_INT 124
77939: PPUSH
77940: CALL 61535 0 2
// end ; end ;
77944: GO 77341
77946: POP
77947: POP
// end ;
77948: LD_VAR 0 1
77952: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
77953: LD_INT 0
77955: PPUSH
77956: PPUSH
77957: PPUSH
// if not mc_bases then
77958: LD_EXP 59
77962: NOT
77963: IFFALSE 77967
// exit ;
77965: GO 78573
// for i = 1 to mc_bases do
77967: LD_ADDR_VAR 0 2
77971: PUSH
77972: DOUBLE
77973: LD_INT 1
77975: DEC
77976: ST_TO_ADDR
77977: LD_EXP 59
77981: PUSH
77982: FOR_TO
77983: IFFALSE 78571
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
77985: LD_ADDR_VAR 0 3
77989: PUSH
77990: LD_EXP 59
77994: PUSH
77995: LD_VAR 0 2
77999: ARRAY
78000: PPUSH
78001: LD_INT 25
78003: PUSH
78004: LD_INT 4
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: PPUSH
78011: CALL_OW 72
78015: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78016: LD_VAR 0 3
78020: NOT
78021: PUSH
78022: LD_EXP 96
78026: PUSH
78027: LD_VAR 0 2
78031: ARRAY
78032: NOT
78033: OR
78034: PUSH
78035: LD_EXP 59
78039: PUSH
78040: LD_VAR 0 2
78044: ARRAY
78045: PPUSH
78046: LD_INT 2
78048: PUSH
78049: LD_INT 30
78051: PUSH
78052: LD_INT 0
78054: PUSH
78055: EMPTY
78056: LIST
78057: LIST
78058: PUSH
78059: LD_INT 30
78061: PUSH
78062: LD_INT 1
78064: PUSH
78065: EMPTY
78066: LIST
78067: LIST
78068: PUSH
78069: EMPTY
78070: LIST
78071: LIST
78072: LIST
78073: PPUSH
78074: CALL_OW 72
78078: NOT
78079: OR
78080: IFFALSE 78130
// begin if mc_deposits_finder [ i ] then
78082: LD_EXP 97
78086: PUSH
78087: LD_VAR 0 2
78091: ARRAY
78092: IFFALSE 78128
// begin MC_Reset ( i , 125 ) ;
78094: LD_VAR 0 2
78098: PPUSH
78099: LD_INT 125
78101: PPUSH
78102: CALL 61535 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78106: LD_ADDR_EXP 97
78110: PUSH
78111: LD_EXP 97
78115: PPUSH
78116: LD_VAR 0 2
78120: PPUSH
78121: EMPTY
78122: PPUSH
78123: CALL_OW 1
78127: ST_TO_ADDR
// end ; continue ;
78128: GO 77982
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
78130: LD_EXP 96
78134: PUSH
78135: LD_VAR 0 2
78139: ARRAY
78140: PUSH
78141: LD_INT 1
78143: ARRAY
78144: PUSH
78145: LD_INT 3
78147: ARRAY
78148: PUSH
78149: LD_INT 1
78151: EQUAL
78152: PUSH
78153: LD_INT 20
78155: PPUSH
78156: LD_EXP 85
78160: PUSH
78161: LD_VAR 0 2
78165: ARRAY
78166: PPUSH
78167: CALL_OW 321
78171: PUSH
78172: LD_INT 2
78174: NONEQUAL
78175: AND
78176: IFFALSE 78226
// begin if mc_deposits_finder [ i ] then
78178: LD_EXP 97
78182: PUSH
78183: LD_VAR 0 2
78187: ARRAY
78188: IFFALSE 78224
// begin MC_Reset ( i , 125 ) ;
78190: LD_VAR 0 2
78194: PPUSH
78195: LD_INT 125
78197: PPUSH
78198: CALL 61535 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78202: LD_ADDR_EXP 97
78206: PUSH
78207: LD_EXP 97
78211: PPUSH
78212: LD_VAR 0 2
78216: PPUSH
78217: EMPTY
78218: PPUSH
78219: CALL_OW 1
78223: ST_TO_ADDR
// end ; continue ;
78224: GO 77982
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
78226: LD_EXP 96
78230: PUSH
78231: LD_VAR 0 2
78235: ARRAY
78236: PUSH
78237: LD_INT 1
78239: ARRAY
78240: PUSH
78241: LD_INT 1
78243: ARRAY
78244: PPUSH
78245: LD_EXP 96
78249: PUSH
78250: LD_VAR 0 2
78254: ARRAY
78255: PUSH
78256: LD_INT 1
78258: ARRAY
78259: PUSH
78260: LD_INT 2
78262: ARRAY
78263: PPUSH
78264: LD_EXP 85
78268: PUSH
78269: LD_VAR 0 2
78273: ARRAY
78274: PPUSH
78275: CALL_OW 440
78279: IFFALSE 78322
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
78281: LD_ADDR_EXP 96
78285: PUSH
78286: LD_EXP 96
78290: PPUSH
78291: LD_VAR 0 2
78295: PPUSH
78296: LD_EXP 96
78300: PUSH
78301: LD_VAR 0 2
78305: ARRAY
78306: PPUSH
78307: LD_INT 1
78309: PPUSH
78310: CALL_OW 3
78314: PPUSH
78315: CALL_OW 1
78319: ST_TO_ADDR
78320: GO 78569
// begin if not mc_deposits_finder [ i ] then
78322: LD_EXP 97
78326: PUSH
78327: LD_VAR 0 2
78331: ARRAY
78332: NOT
78333: IFFALSE 78385
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
78335: LD_ADDR_EXP 97
78339: PUSH
78340: LD_EXP 97
78344: PPUSH
78345: LD_VAR 0 2
78349: PPUSH
78350: LD_VAR 0 3
78354: PUSH
78355: LD_INT 1
78357: ARRAY
78358: PUSH
78359: EMPTY
78360: LIST
78361: PPUSH
78362: CALL_OW 1
78366: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
78367: LD_VAR 0 3
78371: PUSH
78372: LD_INT 1
78374: ARRAY
78375: PPUSH
78376: LD_INT 125
78378: PPUSH
78379: CALL_OW 109
// end else
78383: GO 78569
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
78385: LD_EXP 97
78389: PUSH
78390: LD_VAR 0 2
78394: ARRAY
78395: PUSH
78396: LD_INT 1
78398: ARRAY
78399: PPUSH
78400: CALL_OW 310
78404: IFFALSE 78427
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
78406: LD_EXP 97
78410: PUSH
78411: LD_VAR 0 2
78415: ARRAY
78416: PUSH
78417: LD_INT 1
78419: ARRAY
78420: PPUSH
78421: CALL_OW 122
78425: GO 78569
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
78427: LD_EXP 97
78431: PUSH
78432: LD_VAR 0 2
78436: ARRAY
78437: PUSH
78438: LD_INT 1
78440: ARRAY
78441: PPUSH
78442: CALL_OW 314
78446: NOT
78447: PUSH
78448: LD_EXP 97
78452: PUSH
78453: LD_VAR 0 2
78457: ARRAY
78458: PUSH
78459: LD_INT 1
78461: ARRAY
78462: PPUSH
78463: LD_EXP 96
78467: PUSH
78468: LD_VAR 0 2
78472: ARRAY
78473: PUSH
78474: LD_INT 1
78476: ARRAY
78477: PUSH
78478: LD_INT 1
78480: ARRAY
78481: PPUSH
78482: LD_EXP 96
78486: PUSH
78487: LD_VAR 0 2
78491: ARRAY
78492: PUSH
78493: LD_INT 1
78495: ARRAY
78496: PUSH
78497: LD_INT 2
78499: ARRAY
78500: PPUSH
78501: CALL_OW 297
78505: PUSH
78506: LD_INT 6
78508: GREATER
78509: AND
78510: IFFALSE 78569
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
78512: LD_EXP 97
78516: PUSH
78517: LD_VAR 0 2
78521: ARRAY
78522: PUSH
78523: LD_INT 1
78525: ARRAY
78526: PPUSH
78527: LD_EXP 96
78531: PUSH
78532: LD_VAR 0 2
78536: ARRAY
78537: PUSH
78538: LD_INT 1
78540: ARRAY
78541: PUSH
78542: LD_INT 1
78544: ARRAY
78545: PPUSH
78546: LD_EXP 96
78550: PUSH
78551: LD_VAR 0 2
78555: ARRAY
78556: PUSH
78557: LD_INT 1
78559: ARRAY
78560: PUSH
78561: LD_INT 2
78563: ARRAY
78564: PPUSH
78565: CALL_OW 111
// end ; end ; end ;
78569: GO 77982
78571: POP
78572: POP
// end ;
78573: LD_VAR 0 1
78577: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
78578: LD_INT 0
78580: PPUSH
78581: PPUSH
78582: PPUSH
78583: PPUSH
78584: PPUSH
78585: PPUSH
78586: PPUSH
78587: PPUSH
78588: PPUSH
78589: PPUSH
78590: PPUSH
// if not mc_bases then
78591: LD_EXP 59
78595: NOT
78596: IFFALSE 78600
// exit ;
78598: GO 79540
// for i = 1 to mc_bases do
78600: LD_ADDR_VAR 0 2
78604: PUSH
78605: DOUBLE
78606: LD_INT 1
78608: DEC
78609: ST_TO_ADDR
78610: LD_EXP 59
78614: PUSH
78615: FOR_TO
78616: IFFALSE 79538
// begin if not mc_bases [ i ] or mc_scan [ i ] then
78618: LD_EXP 59
78622: PUSH
78623: LD_VAR 0 2
78627: ARRAY
78628: NOT
78629: PUSH
78630: LD_EXP 82
78634: PUSH
78635: LD_VAR 0 2
78639: ARRAY
78640: OR
78641: IFFALSE 78645
// continue ;
78643: GO 78615
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78645: LD_ADDR_VAR 0 7
78649: PUSH
78650: LD_EXP 59
78654: PUSH
78655: LD_VAR 0 2
78659: ARRAY
78660: PUSH
78661: LD_INT 1
78663: ARRAY
78664: PPUSH
78665: CALL_OW 248
78669: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78670: LD_VAR 0 7
78674: PUSH
78675: LD_INT 3
78677: EQUAL
78678: PUSH
78679: LD_EXP 78
78683: PUSH
78684: LD_VAR 0 2
78688: ARRAY
78689: PUSH
78690: LD_EXP 81
78694: PUSH
78695: LD_VAR 0 2
78699: ARRAY
78700: UNION
78701: PPUSH
78702: LD_INT 33
78704: PUSH
78705: LD_INT 2
78707: PUSH
78708: EMPTY
78709: LIST
78710: LIST
78711: PPUSH
78712: CALL_OW 72
78716: NOT
78717: OR
78718: IFFALSE 78722
// continue ;
78720: GO 78615
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78722: LD_ADDR_VAR 0 9
78726: PUSH
78727: LD_EXP 59
78731: PUSH
78732: LD_VAR 0 2
78736: ARRAY
78737: PPUSH
78738: LD_INT 30
78740: PUSH
78741: LD_INT 36
78743: PUSH
78744: EMPTY
78745: LIST
78746: LIST
78747: PPUSH
78748: CALL_OW 72
78752: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78753: LD_ADDR_VAR 0 10
78757: PUSH
78758: LD_EXP 78
78762: PUSH
78763: LD_VAR 0 2
78767: ARRAY
78768: PPUSH
78769: LD_INT 34
78771: PUSH
78772: LD_INT 31
78774: PUSH
78775: EMPTY
78776: LIST
78777: LIST
78778: PPUSH
78779: CALL_OW 72
78783: ST_TO_ADDR
// if not cts and not mcts then
78784: LD_VAR 0 9
78788: NOT
78789: PUSH
78790: LD_VAR 0 10
78794: NOT
78795: AND
78796: IFFALSE 78800
// continue ;
78798: GO 78615
// x := cts ;
78800: LD_ADDR_VAR 0 11
78804: PUSH
78805: LD_VAR 0 9
78809: ST_TO_ADDR
// if not x then
78810: LD_VAR 0 11
78814: NOT
78815: IFFALSE 78827
// x := mcts ;
78817: LD_ADDR_VAR 0 11
78821: PUSH
78822: LD_VAR 0 10
78826: ST_TO_ADDR
// if not x then
78827: LD_VAR 0 11
78831: NOT
78832: IFFALSE 78836
// continue ;
78834: GO 78615
// if mc_remote_driver [ i ] then
78836: LD_EXP 99
78840: PUSH
78841: LD_VAR 0 2
78845: ARRAY
78846: IFFALSE 79233
// for j in mc_remote_driver [ i ] do
78848: LD_ADDR_VAR 0 3
78852: PUSH
78853: LD_EXP 99
78857: PUSH
78858: LD_VAR 0 2
78862: ARRAY
78863: PUSH
78864: FOR_IN
78865: IFFALSE 79231
// begin if GetClass ( j ) <> 3 then
78867: LD_VAR 0 3
78871: PPUSH
78872: CALL_OW 257
78876: PUSH
78877: LD_INT 3
78879: NONEQUAL
78880: IFFALSE 78933
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
78882: LD_ADDR_EXP 99
78886: PUSH
78887: LD_EXP 99
78891: PPUSH
78892: LD_VAR 0 2
78896: PPUSH
78897: LD_EXP 99
78901: PUSH
78902: LD_VAR 0 2
78906: ARRAY
78907: PUSH
78908: LD_VAR 0 3
78912: DIFF
78913: PPUSH
78914: CALL_OW 1
78918: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78919: LD_VAR 0 3
78923: PPUSH
78924: LD_INT 0
78926: PPUSH
78927: CALL_OW 109
// continue ;
78931: GO 78864
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
78933: LD_EXP 78
78937: PUSH
78938: LD_VAR 0 2
78942: ARRAY
78943: PPUSH
78944: LD_INT 34
78946: PUSH
78947: LD_INT 31
78949: PUSH
78950: EMPTY
78951: LIST
78952: LIST
78953: PUSH
78954: LD_INT 58
78956: PUSH
78957: EMPTY
78958: LIST
78959: PUSH
78960: EMPTY
78961: LIST
78962: LIST
78963: PPUSH
78964: CALL_OW 72
78968: PUSH
78969: LD_VAR 0 3
78973: PPUSH
78974: CALL 54880 0 1
78978: NOT
78979: AND
78980: IFFALSE 79051
// begin if IsInUnit ( j ) then
78982: LD_VAR 0 3
78986: PPUSH
78987: CALL_OW 310
78991: IFFALSE 79002
// ComExitBuilding ( j ) ;
78993: LD_VAR 0 3
78997: PPUSH
78998: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
79002: LD_VAR 0 3
79006: PPUSH
79007: LD_EXP 78
79011: PUSH
79012: LD_VAR 0 2
79016: ARRAY
79017: PPUSH
79018: LD_INT 34
79020: PUSH
79021: LD_INT 31
79023: PUSH
79024: EMPTY
79025: LIST
79026: LIST
79027: PUSH
79028: LD_INT 58
79030: PUSH
79031: EMPTY
79032: LIST
79033: PUSH
79034: EMPTY
79035: LIST
79036: LIST
79037: PPUSH
79038: CALL_OW 72
79042: PUSH
79043: LD_INT 1
79045: ARRAY
79046: PPUSH
79047: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
79051: LD_VAR 0 3
79055: PPUSH
79056: CALL_OW 310
79060: NOT
79061: PUSH
79062: LD_VAR 0 3
79066: PPUSH
79067: CALL_OW 310
79071: PPUSH
79072: CALL_OW 266
79076: PUSH
79077: LD_INT 36
79079: NONEQUAL
79080: PUSH
79081: LD_VAR 0 3
79085: PPUSH
79086: CALL 54880 0 1
79090: NOT
79091: AND
79092: OR
79093: IFFALSE 79229
// begin if IsInUnit ( j ) then
79095: LD_VAR 0 3
79099: PPUSH
79100: CALL_OW 310
79104: IFFALSE 79115
// ComExitBuilding ( j ) ;
79106: LD_VAR 0 3
79110: PPUSH
79111: CALL_OW 122
// ct := 0 ;
79115: LD_ADDR_VAR 0 8
79119: PUSH
79120: LD_INT 0
79122: ST_TO_ADDR
// for k in x do
79123: LD_ADDR_VAR 0 4
79127: PUSH
79128: LD_VAR 0 11
79132: PUSH
79133: FOR_IN
79134: IFFALSE 79207
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
79136: LD_VAR 0 4
79140: PPUSH
79141: CALL_OW 264
79145: PUSH
79146: LD_INT 31
79148: EQUAL
79149: PUSH
79150: LD_VAR 0 4
79154: PPUSH
79155: CALL_OW 311
79159: NOT
79160: AND
79161: PUSH
79162: LD_VAR 0 4
79166: PPUSH
79167: CALL_OW 266
79171: PUSH
79172: LD_INT 36
79174: EQUAL
79175: PUSH
79176: LD_VAR 0 4
79180: PPUSH
79181: CALL_OW 313
79185: PUSH
79186: LD_INT 3
79188: LESS
79189: AND
79190: OR
79191: IFFALSE 79205
// begin ct := k ;
79193: LD_ADDR_VAR 0 8
79197: PUSH
79198: LD_VAR 0 4
79202: ST_TO_ADDR
// break ;
79203: GO 79207
// end ;
79205: GO 79133
79207: POP
79208: POP
// if ct then
79209: LD_VAR 0 8
79213: IFFALSE 79229
// ComEnterUnit ( j , ct ) ;
79215: LD_VAR 0 3
79219: PPUSH
79220: LD_VAR 0 8
79224: PPUSH
79225: CALL_OW 120
// end ; end ;
79229: GO 78864
79231: POP
79232: POP
// places := 0 ;
79233: LD_ADDR_VAR 0 5
79237: PUSH
79238: LD_INT 0
79240: ST_TO_ADDR
// for j = 1 to x do
79241: LD_ADDR_VAR 0 3
79245: PUSH
79246: DOUBLE
79247: LD_INT 1
79249: DEC
79250: ST_TO_ADDR
79251: LD_VAR 0 11
79255: PUSH
79256: FOR_TO
79257: IFFALSE 79333
// if GetWeapon ( x [ j ] ) = ar_control_tower then
79259: LD_VAR 0 11
79263: PUSH
79264: LD_VAR 0 3
79268: ARRAY
79269: PPUSH
79270: CALL_OW 264
79274: PUSH
79275: LD_INT 31
79277: EQUAL
79278: IFFALSE 79296
// places := places + 1 else
79280: LD_ADDR_VAR 0 5
79284: PUSH
79285: LD_VAR 0 5
79289: PUSH
79290: LD_INT 1
79292: PLUS
79293: ST_TO_ADDR
79294: GO 79331
// if GetBType ( x [ j ] ) = b_control_tower then
79296: LD_VAR 0 11
79300: PUSH
79301: LD_VAR 0 3
79305: ARRAY
79306: PPUSH
79307: CALL_OW 266
79311: PUSH
79312: LD_INT 36
79314: EQUAL
79315: IFFALSE 79331
// places := places + 3 ;
79317: LD_ADDR_VAR 0 5
79321: PUSH
79322: LD_VAR 0 5
79326: PUSH
79327: LD_INT 3
79329: PLUS
79330: ST_TO_ADDR
79331: GO 79256
79333: POP
79334: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
79335: LD_VAR 0 5
79339: PUSH
79340: LD_INT 0
79342: EQUAL
79343: PUSH
79344: LD_VAR 0 5
79348: PUSH
79349: LD_EXP 99
79353: PUSH
79354: LD_VAR 0 2
79358: ARRAY
79359: LESSEQUAL
79360: OR
79361: IFFALSE 79365
// continue ;
79363: GO 78615
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
79365: LD_ADDR_VAR 0 6
79369: PUSH
79370: LD_EXP 59
79374: PUSH
79375: LD_VAR 0 2
79379: ARRAY
79380: PPUSH
79381: LD_INT 25
79383: PUSH
79384: LD_INT 3
79386: PUSH
79387: EMPTY
79388: LIST
79389: LIST
79390: PPUSH
79391: CALL_OW 72
79395: PUSH
79396: LD_EXP 99
79400: PUSH
79401: LD_VAR 0 2
79405: ARRAY
79406: DIFF
79407: PPUSH
79408: LD_INT 3
79410: PPUSH
79411: CALL 55780 0 2
79415: ST_TO_ADDR
// for j in tmp do
79416: LD_ADDR_VAR 0 3
79420: PUSH
79421: LD_VAR 0 6
79425: PUSH
79426: FOR_IN
79427: IFFALSE 79462
// if GetTag ( j ) > 0 then
79429: LD_VAR 0 3
79433: PPUSH
79434: CALL_OW 110
79438: PUSH
79439: LD_INT 0
79441: GREATER
79442: IFFALSE 79460
// tmp := tmp diff j ;
79444: LD_ADDR_VAR 0 6
79448: PUSH
79449: LD_VAR 0 6
79453: PUSH
79454: LD_VAR 0 3
79458: DIFF
79459: ST_TO_ADDR
79460: GO 79426
79462: POP
79463: POP
// if not tmp then
79464: LD_VAR 0 6
79468: NOT
79469: IFFALSE 79473
// continue ;
79471: GO 78615
// if places then
79473: LD_VAR 0 5
79477: IFFALSE 79536
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
79479: LD_ADDR_EXP 99
79483: PUSH
79484: LD_EXP 99
79488: PPUSH
79489: LD_VAR 0 2
79493: PPUSH
79494: LD_EXP 99
79498: PUSH
79499: LD_VAR 0 2
79503: ARRAY
79504: PUSH
79505: LD_VAR 0 6
79509: PUSH
79510: LD_INT 1
79512: ARRAY
79513: UNION
79514: PPUSH
79515: CALL_OW 1
79519: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
79520: LD_VAR 0 6
79524: PUSH
79525: LD_INT 1
79527: ARRAY
79528: PPUSH
79529: LD_INT 126
79531: PPUSH
79532: CALL_OW 109
// end ; end ;
79536: GO 78615
79538: POP
79539: POP
// end ;
79540: LD_VAR 0 1
79544: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
79545: LD_INT 0
79547: PPUSH
79548: PPUSH
79549: PPUSH
79550: PPUSH
79551: PPUSH
79552: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
79553: LD_VAR 0 1
79557: NOT
79558: PUSH
79559: LD_VAR 0 2
79563: NOT
79564: OR
79565: PUSH
79566: LD_VAR 0 3
79570: NOT
79571: OR
79572: PUSH
79573: LD_VAR 0 4
79577: PUSH
79578: LD_INT 1
79580: PUSH
79581: LD_INT 2
79583: PUSH
79584: LD_INT 3
79586: PUSH
79587: LD_INT 4
79589: PUSH
79590: LD_INT 5
79592: PUSH
79593: LD_INT 8
79595: PUSH
79596: LD_INT 9
79598: PUSH
79599: LD_INT 15
79601: PUSH
79602: LD_INT 16
79604: PUSH
79605: EMPTY
79606: LIST
79607: LIST
79608: LIST
79609: LIST
79610: LIST
79611: LIST
79612: LIST
79613: LIST
79614: LIST
79615: IN
79616: NOT
79617: OR
79618: IFFALSE 79622
// exit ;
79620: GO 80522
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
79622: LD_ADDR_VAR 0 2
79626: PUSH
79627: LD_VAR 0 2
79631: PPUSH
79632: LD_INT 21
79634: PUSH
79635: LD_INT 3
79637: PUSH
79638: EMPTY
79639: LIST
79640: LIST
79641: PUSH
79642: LD_INT 24
79644: PUSH
79645: LD_INT 250
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: EMPTY
79653: LIST
79654: LIST
79655: PPUSH
79656: CALL_OW 72
79660: ST_TO_ADDR
// case class of 1 , 15 :
79661: LD_VAR 0 4
79665: PUSH
79666: LD_INT 1
79668: DOUBLE
79669: EQUAL
79670: IFTRUE 79680
79672: LD_INT 15
79674: DOUBLE
79675: EQUAL
79676: IFTRUE 79680
79678: GO 79765
79680: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
79681: LD_ADDR_VAR 0 8
79685: PUSH
79686: LD_VAR 0 2
79690: PPUSH
79691: LD_INT 2
79693: PUSH
79694: LD_INT 30
79696: PUSH
79697: LD_INT 32
79699: PUSH
79700: EMPTY
79701: LIST
79702: LIST
79703: PUSH
79704: LD_INT 30
79706: PUSH
79707: LD_INT 31
79709: PUSH
79710: EMPTY
79711: LIST
79712: LIST
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: LIST
79718: PPUSH
79719: CALL_OW 72
79723: PUSH
79724: LD_VAR 0 2
79728: PPUSH
79729: LD_INT 2
79731: PUSH
79732: LD_INT 30
79734: PUSH
79735: LD_INT 4
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: LD_INT 30
79744: PUSH
79745: LD_INT 5
79747: PUSH
79748: EMPTY
79749: LIST
79750: LIST
79751: PUSH
79752: EMPTY
79753: LIST
79754: LIST
79755: LIST
79756: PPUSH
79757: CALL_OW 72
79761: ADD
79762: ST_TO_ADDR
79763: GO 80011
79765: LD_INT 2
79767: DOUBLE
79768: EQUAL
79769: IFTRUE 79779
79771: LD_INT 16
79773: DOUBLE
79774: EQUAL
79775: IFTRUE 79779
79777: GO 79825
79779: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
79780: LD_ADDR_VAR 0 8
79784: PUSH
79785: LD_VAR 0 2
79789: PPUSH
79790: LD_INT 2
79792: PUSH
79793: LD_INT 30
79795: PUSH
79796: LD_INT 0
79798: PUSH
79799: EMPTY
79800: LIST
79801: LIST
79802: PUSH
79803: LD_INT 30
79805: PUSH
79806: LD_INT 1
79808: PUSH
79809: EMPTY
79810: LIST
79811: LIST
79812: PUSH
79813: EMPTY
79814: LIST
79815: LIST
79816: LIST
79817: PPUSH
79818: CALL_OW 72
79822: ST_TO_ADDR
79823: GO 80011
79825: LD_INT 3
79827: DOUBLE
79828: EQUAL
79829: IFTRUE 79833
79831: GO 79879
79833: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
79834: LD_ADDR_VAR 0 8
79838: PUSH
79839: LD_VAR 0 2
79843: PPUSH
79844: LD_INT 2
79846: PUSH
79847: LD_INT 30
79849: PUSH
79850: LD_INT 2
79852: PUSH
79853: EMPTY
79854: LIST
79855: LIST
79856: PUSH
79857: LD_INT 30
79859: PUSH
79860: LD_INT 3
79862: PUSH
79863: EMPTY
79864: LIST
79865: LIST
79866: PUSH
79867: EMPTY
79868: LIST
79869: LIST
79870: LIST
79871: PPUSH
79872: CALL_OW 72
79876: ST_TO_ADDR
79877: GO 80011
79879: LD_INT 4
79881: DOUBLE
79882: EQUAL
79883: IFTRUE 79887
79885: GO 79944
79887: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
79888: LD_ADDR_VAR 0 8
79892: PUSH
79893: LD_VAR 0 2
79897: PPUSH
79898: LD_INT 2
79900: PUSH
79901: LD_INT 30
79903: PUSH
79904: LD_INT 6
79906: PUSH
79907: EMPTY
79908: LIST
79909: LIST
79910: PUSH
79911: LD_INT 30
79913: PUSH
79914: LD_INT 7
79916: PUSH
79917: EMPTY
79918: LIST
79919: LIST
79920: PUSH
79921: LD_INT 30
79923: PUSH
79924: LD_INT 8
79926: PUSH
79927: EMPTY
79928: LIST
79929: LIST
79930: PUSH
79931: EMPTY
79932: LIST
79933: LIST
79934: LIST
79935: LIST
79936: PPUSH
79937: CALL_OW 72
79941: ST_TO_ADDR
79942: GO 80011
79944: LD_INT 5
79946: DOUBLE
79947: EQUAL
79948: IFTRUE 79964
79950: LD_INT 8
79952: DOUBLE
79953: EQUAL
79954: IFTRUE 79964
79956: LD_INT 9
79958: DOUBLE
79959: EQUAL
79960: IFTRUE 79964
79962: GO 80010
79964: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
79965: LD_ADDR_VAR 0 8
79969: PUSH
79970: LD_VAR 0 2
79974: PPUSH
79975: LD_INT 2
79977: PUSH
79978: LD_INT 30
79980: PUSH
79981: LD_INT 4
79983: PUSH
79984: EMPTY
79985: LIST
79986: LIST
79987: PUSH
79988: LD_INT 30
79990: PUSH
79991: LD_INT 5
79993: PUSH
79994: EMPTY
79995: LIST
79996: LIST
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: LIST
80002: PPUSH
80003: CALL_OW 72
80007: ST_TO_ADDR
80008: GO 80011
80010: POP
// if not tmp then
80011: LD_VAR 0 8
80015: NOT
80016: IFFALSE 80020
// exit ;
80018: GO 80522
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
80020: LD_VAR 0 4
80024: PUSH
80025: LD_INT 1
80027: PUSH
80028: LD_INT 15
80030: PUSH
80031: EMPTY
80032: LIST
80033: LIST
80034: IN
80035: PUSH
80036: LD_EXP 68
80040: PUSH
80041: LD_VAR 0 1
80045: ARRAY
80046: AND
80047: IFFALSE 80203
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
80049: LD_ADDR_VAR 0 9
80053: PUSH
80054: LD_EXP 68
80058: PUSH
80059: LD_VAR 0 1
80063: ARRAY
80064: PUSH
80065: LD_INT 1
80067: ARRAY
80068: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
80069: LD_VAR 0 9
80073: PUSH
80074: LD_EXP 69
80078: PUSH
80079: LD_VAR 0 1
80083: ARRAY
80084: IN
80085: NOT
80086: IFFALSE 80201
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
80088: LD_ADDR_EXP 69
80092: PUSH
80093: LD_EXP 69
80097: PPUSH
80098: LD_VAR 0 1
80102: PUSH
80103: LD_EXP 69
80107: PUSH
80108: LD_VAR 0 1
80112: ARRAY
80113: PUSH
80114: LD_INT 1
80116: PLUS
80117: PUSH
80118: EMPTY
80119: LIST
80120: LIST
80121: PPUSH
80122: LD_VAR 0 9
80126: PPUSH
80127: CALL 21529 0 3
80131: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
80132: LD_ADDR_EXP 68
80136: PUSH
80137: LD_EXP 68
80141: PPUSH
80142: LD_VAR 0 1
80146: PPUSH
80147: LD_EXP 68
80151: PUSH
80152: LD_VAR 0 1
80156: ARRAY
80157: PUSH
80158: LD_VAR 0 9
80162: DIFF
80163: PPUSH
80164: CALL_OW 1
80168: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
80169: LD_VAR 0 3
80173: PPUSH
80174: LD_EXP 69
80178: PUSH
80179: LD_VAR 0 1
80183: ARRAY
80184: PUSH
80185: LD_EXP 69
80189: PUSH
80190: LD_VAR 0 1
80194: ARRAY
80195: ARRAY
80196: PPUSH
80197: CALL_OW 120
// end ; exit ;
80201: GO 80522
// end ; if tmp > 1 then
80203: LD_VAR 0 8
80207: PUSH
80208: LD_INT 1
80210: GREATER
80211: IFFALSE 80315
// for i = 2 to tmp do
80213: LD_ADDR_VAR 0 6
80217: PUSH
80218: DOUBLE
80219: LD_INT 2
80221: DEC
80222: ST_TO_ADDR
80223: LD_VAR 0 8
80227: PUSH
80228: FOR_TO
80229: IFFALSE 80313
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
80231: LD_VAR 0 8
80235: PUSH
80236: LD_VAR 0 6
80240: ARRAY
80241: PPUSH
80242: CALL_OW 461
80246: PUSH
80247: LD_INT 6
80249: EQUAL
80250: IFFALSE 80311
// begin x := tmp [ i ] ;
80252: LD_ADDR_VAR 0 9
80256: PUSH
80257: LD_VAR 0 8
80261: PUSH
80262: LD_VAR 0 6
80266: ARRAY
80267: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
80268: LD_ADDR_VAR 0 8
80272: PUSH
80273: LD_VAR 0 8
80277: PPUSH
80278: LD_VAR 0 6
80282: PPUSH
80283: CALL_OW 3
80287: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
80288: LD_ADDR_VAR 0 8
80292: PUSH
80293: LD_VAR 0 8
80297: PPUSH
80298: LD_INT 1
80300: PPUSH
80301: LD_VAR 0 9
80305: PPUSH
80306: CALL_OW 2
80310: ST_TO_ADDR
// end ;
80311: GO 80228
80313: POP
80314: POP
// for i in tmp do
80315: LD_ADDR_VAR 0 6
80319: PUSH
80320: LD_VAR 0 8
80324: PUSH
80325: FOR_IN
80326: IFFALSE 80395
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
80328: LD_VAR 0 6
80332: PPUSH
80333: CALL_OW 313
80337: PUSH
80338: LD_INT 6
80340: LESS
80341: PUSH
80342: LD_VAR 0 6
80346: PPUSH
80347: CALL_OW 266
80351: PUSH
80352: LD_INT 31
80354: PUSH
80355: LD_INT 32
80357: PUSH
80358: EMPTY
80359: LIST
80360: LIST
80361: IN
80362: NOT
80363: AND
80364: PUSH
80365: LD_VAR 0 6
80369: PPUSH
80370: CALL_OW 313
80374: PUSH
80375: LD_INT 0
80377: EQUAL
80378: OR
80379: IFFALSE 80393
// begin j := i ;
80381: LD_ADDR_VAR 0 7
80385: PUSH
80386: LD_VAR 0 6
80390: ST_TO_ADDR
// break ;
80391: GO 80395
// end ; end ;
80393: GO 80325
80395: POP
80396: POP
// if j then
80397: LD_VAR 0 7
80401: IFFALSE 80419
// ComEnterUnit ( unit , j ) else
80403: LD_VAR 0 3
80407: PPUSH
80408: LD_VAR 0 7
80412: PPUSH
80413: CALL_OW 120
80417: GO 80522
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80419: LD_ADDR_VAR 0 10
80423: PUSH
80424: LD_VAR 0 2
80428: PPUSH
80429: LD_INT 2
80431: PUSH
80432: LD_INT 30
80434: PUSH
80435: LD_INT 0
80437: PUSH
80438: EMPTY
80439: LIST
80440: LIST
80441: PUSH
80442: LD_INT 30
80444: PUSH
80445: LD_INT 1
80447: PUSH
80448: EMPTY
80449: LIST
80450: LIST
80451: PUSH
80452: EMPTY
80453: LIST
80454: LIST
80455: LIST
80456: PPUSH
80457: CALL_OW 72
80461: ST_TO_ADDR
// if depot then
80462: LD_VAR 0 10
80466: IFFALSE 80522
// begin depot := NearestUnitToUnit ( depot , unit ) ;
80468: LD_ADDR_VAR 0 10
80472: PUSH
80473: LD_VAR 0 10
80477: PPUSH
80478: LD_VAR 0 3
80482: PPUSH
80483: CALL_OW 74
80487: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
80488: LD_VAR 0 3
80492: PPUSH
80493: LD_VAR 0 10
80497: PPUSH
80498: CALL_OW 296
80502: PUSH
80503: LD_INT 10
80505: GREATER
80506: IFFALSE 80522
// ComStandNearbyBuilding ( unit , depot ) ;
80508: LD_VAR 0 3
80512: PPUSH
80513: LD_VAR 0 10
80517: PPUSH
80518: CALL 15732 0 2
// end ; end ; end ;
80522: LD_VAR 0 5
80526: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
80527: LD_INT 0
80529: PPUSH
80530: PPUSH
80531: PPUSH
80532: PPUSH
// if not mc_bases then
80533: LD_EXP 59
80537: NOT
80538: IFFALSE 80542
// exit ;
80540: GO 80781
// for i = 1 to mc_bases do
80542: LD_ADDR_VAR 0 2
80546: PUSH
80547: DOUBLE
80548: LD_INT 1
80550: DEC
80551: ST_TO_ADDR
80552: LD_EXP 59
80556: PUSH
80557: FOR_TO
80558: IFFALSE 80779
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
80560: LD_ADDR_VAR 0 4
80564: PUSH
80565: LD_EXP 59
80569: PUSH
80570: LD_VAR 0 2
80574: ARRAY
80575: PPUSH
80576: LD_INT 21
80578: PUSH
80579: LD_INT 1
80581: PUSH
80582: EMPTY
80583: LIST
80584: LIST
80585: PPUSH
80586: CALL_OW 72
80590: PUSH
80591: LD_EXP 88
80595: PUSH
80596: LD_VAR 0 2
80600: ARRAY
80601: UNION
80602: ST_TO_ADDR
// if not tmp then
80603: LD_VAR 0 4
80607: NOT
80608: IFFALSE 80612
// continue ;
80610: GO 80557
// for j in tmp do
80612: LD_ADDR_VAR 0 3
80616: PUSH
80617: LD_VAR 0 4
80621: PUSH
80622: FOR_IN
80623: IFFALSE 80775
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
80625: LD_VAR 0 3
80629: PPUSH
80630: CALL_OW 110
80634: NOT
80635: PUSH
80636: LD_VAR 0 3
80640: PPUSH
80641: CALL_OW 314
80645: NOT
80646: AND
80647: PUSH
80648: LD_VAR 0 3
80652: PPUSH
80653: CALL_OW 311
80657: NOT
80658: AND
80659: PUSH
80660: LD_VAR 0 3
80664: PPUSH
80665: CALL_OW 310
80669: NOT
80670: AND
80671: PUSH
80672: LD_VAR 0 3
80676: PUSH
80677: LD_EXP 62
80681: PUSH
80682: LD_VAR 0 2
80686: ARRAY
80687: PUSH
80688: LD_INT 1
80690: ARRAY
80691: IN
80692: NOT
80693: AND
80694: PUSH
80695: LD_VAR 0 3
80699: PUSH
80700: LD_EXP 62
80704: PUSH
80705: LD_VAR 0 2
80709: ARRAY
80710: PUSH
80711: LD_INT 2
80713: ARRAY
80714: IN
80715: NOT
80716: AND
80717: PUSH
80718: LD_VAR 0 3
80722: PUSH
80723: LD_EXP 71
80727: PUSH
80728: LD_VAR 0 2
80732: ARRAY
80733: IN
80734: NOT
80735: AND
80736: IFFALSE 80773
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
80738: LD_VAR 0 2
80742: PPUSH
80743: LD_EXP 59
80747: PUSH
80748: LD_VAR 0 2
80752: ARRAY
80753: PPUSH
80754: LD_VAR 0 3
80758: PPUSH
80759: LD_VAR 0 3
80763: PPUSH
80764: CALL_OW 257
80768: PPUSH
80769: CALL 79545 0 4
// end ;
80773: GO 80622
80775: POP
80776: POP
// end ;
80777: GO 80557
80779: POP
80780: POP
// end ;
80781: LD_VAR 0 1
80785: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
80786: LD_INT 0
80788: PPUSH
80789: PPUSH
80790: PPUSH
80791: PPUSH
80792: PPUSH
80793: PPUSH
// if not mc_bases [ base ] then
80794: LD_EXP 59
80798: PUSH
80799: LD_VAR 0 1
80803: ARRAY
80804: NOT
80805: IFFALSE 80809
// exit ;
80807: GO 80991
// tmp := [ ] ;
80809: LD_ADDR_VAR 0 6
80813: PUSH
80814: EMPTY
80815: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80816: LD_ADDR_VAR 0 7
80820: PUSH
80821: LD_VAR 0 3
80825: PPUSH
80826: LD_INT 0
80828: PPUSH
80829: CALL_OW 517
80833: ST_TO_ADDR
// if not list then
80834: LD_VAR 0 7
80838: NOT
80839: IFFALSE 80843
// exit ;
80841: GO 80991
// for i = 1 to amount do
80843: LD_ADDR_VAR 0 5
80847: PUSH
80848: DOUBLE
80849: LD_INT 1
80851: DEC
80852: ST_TO_ADDR
80853: LD_VAR 0 2
80857: PUSH
80858: FOR_TO
80859: IFFALSE 80939
// begin x := rand ( 1 , list [ 1 ] ) ;
80861: LD_ADDR_VAR 0 8
80865: PUSH
80866: LD_INT 1
80868: PPUSH
80869: LD_VAR 0 7
80873: PUSH
80874: LD_INT 1
80876: ARRAY
80877: PPUSH
80878: CALL_OW 12
80882: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
80883: LD_ADDR_VAR 0 6
80887: PUSH
80888: LD_VAR 0 6
80892: PPUSH
80893: LD_VAR 0 5
80897: PPUSH
80898: LD_VAR 0 7
80902: PUSH
80903: LD_INT 1
80905: ARRAY
80906: PUSH
80907: LD_VAR 0 8
80911: ARRAY
80912: PUSH
80913: LD_VAR 0 7
80917: PUSH
80918: LD_INT 2
80920: ARRAY
80921: PUSH
80922: LD_VAR 0 8
80926: ARRAY
80927: PUSH
80928: EMPTY
80929: LIST
80930: LIST
80931: PPUSH
80932: CALL_OW 1
80936: ST_TO_ADDR
// end ;
80937: GO 80858
80939: POP
80940: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
80941: LD_ADDR_EXP 72
80945: PUSH
80946: LD_EXP 72
80950: PPUSH
80951: LD_VAR 0 1
80955: PPUSH
80956: LD_VAR 0 6
80960: PPUSH
80961: CALL_OW 1
80965: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
80966: LD_ADDR_EXP 74
80970: PUSH
80971: LD_EXP 74
80975: PPUSH
80976: LD_VAR 0 1
80980: PPUSH
80981: LD_VAR 0 3
80985: PPUSH
80986: CALL_OW 1
80990: ST_TO_ADDR
// end ;
80991: LD_VAR 0 4
80995: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
80996: LD_INT 0
80998: PPUSH
// if not mc_bases [ base ] then
80999: LD_EXP 59
81003: PUSH
81004: LD_VAR 0 1
81008: ARRAY
81009: NOT
81010: IFFALSE 81014
// exit ;
81012: GO 81039
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
81014: LD_ADDR_EXP 64
81018: PUSH
81019: LD_EXP 64
81023: PPUSH
81024: LD_VAR 0 1
81028: PPUSH
81029: LD_VAR 0 2
81033: PPUSH
81034: CALL_OW 1
81038: ST_TO_ADDR
// end ;
81039: LD_VAR 0 3
81043: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
81044: LD_INT 0
81046: PPUSH
// if not mc_bases [ base ] then
81047: LD_EXP 59
81051: PUSH
81052: LD_VAR 0 1
81056: ARRAY
81057: NOT
81058: IFFALSE 81062
// exit ;
81060: GO 81099
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
81062: LD_ADDR_EXP 64
81066: PUSH
81067: LD_EXP 64
81071: PPUSH
81072: LD_VAR 0 1
81076: PPUSH
81077: LD_EXP 64
81081: PUSH
81082: LD_VAR 0 1
81086: ARRAY
81087: PUSH
81088: LD_VAR 0 2
81092: UNION
81093: PPUSH
81094: CALL_OW 1
81098: ST_TO_ADDR
// end ;
81099: LD_VAR 0 3
81103: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
81104: LD_INT 0
81106: PPUSH
// if not mc_bases [ base ] then
81107: LD_EXP 59
81111: PUSH
81112: LD_VAR 0 1
81116: ARRAY
81117: NOT
81118: IFFALSE 81122
// exit ;
81120: GO 81147
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
81122: LD_ADDR_EXP 80
81126: PUSH
81127: LD_EXP 80
81131: PPUSH
81132: LD_VAR 0 1
81136: PPUSH
81137: LD_VAR 0 2
81141: PPUSH
81142: CALL_OW 1
81146: ST_TO_ADDR
// end ;
81147: LD_VAR 0 3
81151: RET
// export function MC_InsertProduceList ( base , components ) ; begin
81152: LD_INT 0
81154: PPUSH
// if not mc_bases [ base ] then
81155: LD_EXP 59
81159: PUSH
81160: LD_VAR 0 1
81164: ARRAY
81165: NOT
81166: IFFALSE 81170
// exit ;
81168: GO 81207
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
81170: LD_ADDR_EXP 80
81174: PUSH
81175: LD_EXP 80
81179: PPUSH
81180: LD_VAR 0 1
81184: PPUSH
81185: LD_EXP 80
81189: PUSH
81190: LD_VAR 0 1
81194: ARRAY
81195: PUSH
81196: LD_VAR 0 2
81200: ADD
81201: PPUSH
81202: CALL_OW 1
81206: ST_TO_ADDR
// end ;
81207: LD_VAR 0 3
81211: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
81212: LD_INT 0
81214: PPUSH
// if not mc_bases [ base ] then
81215: LD_EXP 59
81219: PUSH
81220: LD_VAR 0 1
81224: ARRAY
81225: NOT
81226: IFFALSE 81230
// exit ;
81228: GO 81284
// mc_defender := Replace ( mc_defender , base , deflist ) ;
81230: LD_ADDR_EXP 81
81234: PUSH
81235: LD_EXP 81
81239: PPUSH
81240: LD_VAR 0 1
81244: PPUSH
81245: LD_VAR 0 2
81249: PPUSH
81250: CALL_OW 1
81254: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
81255: LD_ADDR_EXP 70
81259: PUSH
81260: LD_EXP 70
81264: PPUSH
81265: LD_VAR 0 1
81269: PPUSH
81270: LD_VAR 0 2
81274: PUSH
81275: LD_INT 0
81277: PLUS
81278: PPUSH
81279: CALL_OW 1
81283: ST_TO_ADDR
// end ;
81284: LD_VAR 0 3
81288: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
81289: LD_INT 0
81291: PPUSH
// if not mc_bases [ base ] then
81292: LD_EXP 59
81296: PUSH
81297: LD_VAR 0 1
81301: ARRAY
81302: NOT
81303: IFFALSE 81307
// exit ;
81305: GO 81332
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
81307: LD_ADDR_EXP 70
81311: PUSH
81312: LD_EXP 70
81316: PPUSH
81317: LD_VAR 0 1
81321: PPUSH
81322: LD_VAR 0 2
81326: PPUSH
81327: CALL_OW 1
81331: ST_TO_ADDR
// end ;
81332: LD_VAR 0 3
81336: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
81337: LD_INT 0
81339: PPUSH
81340: PPUSH
81341: PPUSH
81342: PPUSH
// if not mc_bases [ base ] then
81343: LD_EXP 59
81347: PUSH
81348: LD_VAR 0 1
81352: ARRAY
81353: NOT
81354: IFFALSE 81358
// exit ;
81356: GO 81423
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
81358: LD_ADDR_EXP 79
81362: PUSH
81363: LD_EXP 79
81367: PPUSH
81368: LD_VAR 0 1
81372: PUSH
81373: LD_EXP 79
81377: PUSH
81378: LD_VAR 0 1
81382: ARRAY
81383: PUSH
81384: LD_INT 1
81386: PLUS
81387: PUSH
81388: EMPTY
81389: LIST
81390: LIST
81391: PPUSH
81392: LD_VAR 0 1
81396: PUSH
81397: LD_VAR 0 2
81401: PUSH
81402: LD_VAR 0 3
81406: PUSH
81407: LD_VAR 0 4
81411: PUSH
81412: EMPTY
81413: LIST
81414: LIST
81415: LIST
81416: LIST
81417: PPUSH
81418: CALL 21529 0 3
81422: ST_TO_ADDR
// end ;
81423: LD_VAR 0 5
81427: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
81428: LD_INT 0
81430: PPUSH
// if not mc_bases [ base ] then
81431: LD_EXP 59
81435: PUSH
81436: LD_VAR 0 1
81440: ARRAY
81441: NOT
81442: IFFALSE 81446
// exit ;
81444: GO 81471
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
81446: LD_ADDR_EXP 96
81450: PUSH
81451: LD_EXP 96
81455: PPUSH
81456: LD_VAR 0 1
81460: PPUSH
81461: LD_VAR 0 2
81465: PPUSH
81466: CALL_OW 1
81470: ST_TO_ADDR
// end ;
81471: LD_VAR 0 3
81475: RET
// export function MC_GetMinesField ( base ) ; begin
81476: LD_INT 0
81478: PPUSH
// result := mc_mines [ base ] ;
81479: LD_ADDR_VAR 0 2
81483: PUSH
81484: LD_EXP 72
81488: PUSH
81489: LD_VAR 0 1
81493: ARRAY
81494: ST_TO_ADDR
// end ;
81495: LD_VAR 0 2
81499: RET
// export function MC_GetProduceList ( base ) ; begin
81500: LD_INT 0
81502: PPUSH
// result := mc_produce [ base ] ;
81503: LD_ADDR_VAR 0 2
81507: PUSH
81508: LD_EXP 80
81512: PUSH
81513: LD_VAR 0 1
81517: ARRAY
81518: ST_TO_ADDR
// end ;
81519: LD_VAR 0 2
81523: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
81524: LD_INT 0
81526: PPUSH
81527: PPUSH
// if not mc_bases then
81528: LD_EXP 59
81532: NOT
81533: IFFALSE 81537
// exit ;
81535: GO 81602
// if mc_bases [ base ] then
81537: LD_EXP 59
81541: PUSH
81542: LD_VAR 0 1
81546: ARRAY
81547: IFFALSE 81602
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81549: LD_ADDR_VAR 0 3
81553: PUSH
81554: LD_EXP 59
81558: PUSH
81559: LD_VAR 0 1
81563: ARRAY
81564: PPUSH
81565: LD_INT 30
81567: PUSH
81568: LD_VAR 0 2
81572: PUSH
81573: EMPTY
81574: LIST
81575: LIST
81576: PPUSH
81577: CALL_OW 72
81581: ST_TO_ADDR
// if result then
81582: LD_VAR 0 3
81586: IFFALSE 81602
// result := result [ 1 ] ;
81588: LD_ADDR_VAR 0 3
81592: PUSH
81593: LD_VAR 0 3
81597: PUSH
81598: LD_INT 1
81600: ARRAY
81601: ST_TO_ADDR
// end ; end ;
81602: LD_VAR 0 3
81606: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
81607: LD_INT 0
81609: PPUSH
81610: PPUSH
// if not mc_bases then
81611: LD_EXP 59
81615: NOT
81616: IFFALSE 81620
// exit ;
81618: GO 81665
// if mc_bases [ base ] then
81620: LD_EXP 59
81624: PUSH
81625: LD_VAR 0 1
81629: ARRAY
81630: IFFALSE 81665
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81632: LD_ADDR_VAR 0 3
81636: PUSH
81637: LD_EXP 59
81641: PUSH
81642: LD_VAR 0 1
81646: ARRAY
81647: PPUSH
81648: LD_INT 30
81650: PUSH
81651: LD_VAR 0 2
81655: PUSH
81656: EMPTY
81657: LIST
81658: LIST
81659: PPUSH
81660: CALL_OW 72
81664: ST_TO_ADDR
// end ;
81665: LD_VAR 0 3
81669: RET
// export function MC_SetTame ( base , area ) ; begin
81670: LD_INT 0
81672: PPUSH
// if not mc_bases or not base then
81673: LD_EXP 59
81677: NOT
81678: PUSH
81679: LD_VAR 0 1
81683: NOT
81684: OR
81685: IFFALSE 81689
// exit ;
81687: GO 81714
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
81689: LD_ADDR_EXP 87
81693: PUSH
81694: LD_EXP 87
81698: PPUSH
81699: LD_VAR 0 1
81703: PPUSH
81704: LD_VAR 0 2
81708: PPUSH
81709: CALL_OW 1
81713: ST_TO_ADDR
// end ;
81714: LD_VAR 0 3
81718: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
81719: LD_INT 0
81721: PPUSH
81722: PPUSH
// if not mc_bases or not base then
81723: LD_EXP 59
81727: NOT
81728: PUSH
81729: LD_VAR 0 1
81733: NOT
81734: OR
81735: IFFALSE 81739
// exit ;
81737: GO 81841
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81739: LD_ADDR_VAR 0 4
81743: PUSH
81744: LD_EXP 59
81748: PUSH
81749: LD_VAR 0 1
81753: ARRAY
81754: PPUSH
81755: LD_INT 30
81757: PUSH
81758: LD_VAR 0 2
81762: PUSH
81763: EMPTY
81764: LIST
81765: LIST
81766: PPUSH
81767: CALL_OW 72
81771: ST_TO_ADDR
// if not tmp then
81772: LD_VAR 0 4
81776: NOT
81777: IFFALSE 81781
// exit ;
81779: GO 81841
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
81781: LD_ADDR_EXP 91
81785: PUSH
81786: LD_EXP 91
81790: PPUSH
81791: LD_VAR 0 1
81795: PPUSH
81796: LD_EXP 91
81800: PUSH
81801: LD_VAR 0 1
81805: ARRAY
81806: PPUSH
81807: LD_EXP 91
81811: PUSH
81812: LD_VAR 0 1
81816: ARRAY
81817: PUSH
81818: LD_INT 1
81820: PLUS
81821: PPUSH
81822: LD_VAR 0 4
81826: PUSH
81827: LD_INT 1
81829: ARRAY
81830: PPUSH
81831: CALL_OW 2
81835: PPUSH
81836: CALL_OW 1
81840: ST_TO_ADDR
// end ;
81841: LD_VAR 0 3
81845: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
81846: LD_INT 0
81848: PPUSH
81849: PPUSH
// if not mc_bases or not base or not kinds then
81850: LD_EXP 59
81854: NOT
81855: PUSH
81856: LD_VAR 0 1
81860: NOT
81861: OR
81862: PUSH
81863: LD_VAR 0 2
81867: NOT
81868: OR
81869: IFFALSE 81873
// exit ;
81871: GO 81934
// for i in kinds do
81873: LD_ADDR_VAR 0 4
81877: PUSH
81878: LD_VAR 0 2
81882: PUSH
81883: FOR_IN
81884: IFFALSE 81932
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
81886: LD_ADDR_EXP 93
81890: PUSH
81891: LD_EXP 93
81895: PPUSH
81896: LD_VAR 0 1
81900: PUSH
81901: LD_EXP 93
81905: PUSH
81906: LD_VAR 0 1
81910: ARRAY
81911: PUSH
81912: LD_INT 1
81914: PLUS
81915: PUSH
81916: EMPTY
81917: LIST
81918: LIST
81919: PPUSH
81920: LD_VAR 0 4
81924: PPUSH
81925: CALL 21529 0 3
81929: ST_TO_ADDR
81930: GO 81883
81932: POP
81933: POP
// end ;
81934: LD_VAR 0 3
81938: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
81939: LD_INT 0
81941: PPUSH
// if not mc_bases or not base or not areas then
81942: LD_EXP 59
81946: NOT
81947: PUSH
81948: LD_VAR 0 1
81952: NOT
81953: OR
81954: PUSH
81955: LD_VAR 0 2
81959: NOT
81960: OR
81961: IFFALSE 81965
// exit ;
81963: GO 81990
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
81965: LD_ADDR_EXP 77
81969: PUSH
81970: LD_EXP 77
81974: PPUSH
81975: LD_VAR 0 1
81979: PPUSH
81980: LD_VAR 0 2
81984: PPUSH
81985: CALL_OW 1
81989: ST_TO_ADDR
// end ;
81990: LD_VAR 0 3
81994: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
81995: LD_INT 0
81997: PPUSH
// if not mc_bases or not base or not teleports_exit then
81998: LD_EXP 59
82002: NOT
82003: PUSH
82004: LD_VAR 0 1
82008: NOT
82009: OR
82010: PUSH
82011: LD_VAR 0 2
82015: NOT
82016: OR
82017: IFFALSE 82021
// exit ;
82019: GO 82046
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
82021: LD_ADDR_EXP 94
82025: PUSH
82026: LD_EXP 94
82030: PPUSH
82031: LD_VAR 0 1
82035: PPUSH
82036: LD_VAR 0 2
82040: PPUSH
82041: CALL_OW 1
82045: ST_TO_ADDR
// end ;
82046: LD_VAR 0 3
82050: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
82051: LD_INT 0
82053: PPUSH
82054: PPUSH
82055: PPUSH
// if not mc_bases or not base or not ext_list then
82056: LD_EXP 59
82060: NOT
82061: PUSH
82062: LD_VAR 0 1
82066: NOT
82067: OR
82068: PUSH
82069: LD_VAR 0 5
82073: NOT
82074: OR
82075: IFFALSE 82079
// exit ;
82077: GO 82252
// tmp := GetFacExtXYD ( x , y , d ) ;
82079: LD_ADDR_VAR 0 8
82083: PUSH
82084: LD_VAR 0 2
82088: PPUSH
82089: LD_VAR 0 3
82093: PPUSH
82094: LD_VAR 0 4
82098: PPUSH
82099: CALL 54910 0 3
82103: ST_TO_ADDR
// if not tmp then
82104: LD_VAR 0 8
82108: NOT
82109: IFFALSE 82113
// exit ;
82111: GO 82252
// for i in tmp do
82113: LD_ADDR_VAR 0 7
82117: PUSH
82118: LD_VAR 0 8
82122: PUSH
82123: FOR_IN
82124: IFFALSE 82250
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
82126: LD_ADDR_EXP 64
82130: PUSH
82131: LD_EXP 64
82135: PPUSH
82136: LD_VAR 0 1
82140: PPUSH
82141: LD_EXP 64
82145: PUSH
82146: LD_VAR 0 1
82150: ARRAY
82151: PPUSH
82152: LD_EXP 64
82156: PUSH
82157: LD_VAR 0 1
82161: ARRAY
82162: PUSH
82163: LD_INT 1
82165: PLUS
82166: PPUSH
82167: LD_VAR 0 5
82171: PUSH
82172: LD_INT 1
82174: ARRAY
82175: PUSH
82176: LD_VAR 0 7
82180: PUSH
82181: LD_INT 1
82183: ARRAY
82184: PUSH
82185: LD_VAR 0 7
82189: PUSH
82190: LD_INT 2
82192: ARRAY
82193: PUSH
82194: LD_VAR 0 7
82198: PUSH
82199: LD_INT 3
82201: ARRAY
82202: PUSH
82203: EMPTY
82204: LIST
82205: LIST
82206: LIST
82207: LIST
82208: PPUSH
82209: CALL_OW 2
82213: PPUSH
82214: CALL_OW 1
82218: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
82219: LD_ADDR_VAR 0 5
82223: PUSH
82224: LD_VAR 0 5
82228: PPUSH
82229: LD_INT 1
82231: PPUSH
82232: CALL_OW 3
82236: ST_TO_ADDR
// if not ext_list then
82237: LD_VAR 0 5
82241: NOT
82242: IFFALSE 82248
// exit ;
82244: POP
82245: POP
82246: GO 82252
// end ;
82248: GO 82123
82250: POP
82251: POP
// end ;
82252: LD_VAR 0 6
82256: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
82257: LD_INT 0
82259: PPUSH
// if not mc_bases or not base or not weapon_list then
82260: LD_EXP 59
82264: NOT
82265: PUSH
82266: LD_VAR 0 1
82270: NOT
82271: OR
82272: PUSH
82273: LD_VAR 0 2
82277: NOT
82278: OR
82279: IFFALSE 82283
// exit ;
82281: GO 82308
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
82283: LD_ADDR_EXP 98
82287: PUSH
82288: LD_EXP 98
82292: PPUSH
82293: LD_VAR 0 1
82297: PPUSH
82298: LD_VAR 0 2
82302: PPUSH
82303: CALL_OW 1
82307: ST_TO_ADDR
// end ;
82308: LD_VAR 0 3
82312: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
82313: LD_INT 0
82315: PPUSH
// if not mc_bases or not base or not tech_list then
82316: LD_EXP 59
82320: NOT
82321: PUSH
82322: LD_VAR 0 1
82326: NOT
82327: OR
82328: PUSH
82329: LD_VAR 0 2
82333: NOT
82334: OR
82335: IFFALSE 82339
// exit ;
82337: GO 82364
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
82339: LD_ADDR_EXP 86
82343: PUSH
82344: LD_EXP 86
82348: PPUSH
82349: LD_VAR 0 1
82353: PPUSH
82354: LD_VAR 0 2
82358: PPUSH
82359: CALL_OW 1
82363: ST_TO_ADDR
// end ;
82364: LD_VAR 0 3
82368: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
82369: LD_INT 0
82371: PPUSH
// if not mc_bases or not parking_area or not base then
82372: LD_EXP 59
82376: NOT
82377: PUSH
82378: LD_VAR 0 2
82382: NOT
82383: OR
82384: PUSH
82385: LD_VAR 0 1
82389: NOT
82390: OR
82391: IFFALSE 82395
// exit ;
82393: GO 82420
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
82395: LD_ADDR_EXP 83
82399: PUSH
82400: LD_EXP 83
82404: PPUSH
82405: LD_VAR 0 1
82409: PPUSH
82410: LD_VAR 0 2
82414: PPUSH
82415: CALL_OW 1
82419: ST_TO_ADDR
// end ;
82420: LD_VAR 0 3
82424: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
82425: LD_INT 0
82427: PPUSH
// if not mc_bases or not base or not scan_area then
82428: LD_EXP 59
82432: NOT
82433: PUSH
82434: LD_VAR 0 1
82438: NOT
82439: OR
82440: PUSH
82441: LD_VAR 0 2
82445: NOT
82446: OR
82447: IFFALSE 82451
// exit ;
82449: GO 82476
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
82451: LD_ADDR_EXP 84
82455: PUSH
82456: LD_EXP 84
82460: PPUSH
82461: LD_VAR 0 1
82465: PPUSH
82466: LD_VAR 0 2
82470: PPUSH
82471: CALL_OW 1
82475: ST_TO_ADDR
// end ;
82476: LD_VAR 0 3
82480: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
82481: LD_INT 0
82483: PPUSH
82484: PPUSH
// if not mc_bases or not base then
82485: LD_EXP 59
82489: NOT
82490: PUSH
82491: LD_VAR 0 1
82495: NOT
82496: OR
82497: IFFALSE 82501
// exit ;
82499: GO 82565
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
82501: LD_ADDR_VAR 0 3
82505: PUSH
82506: LD_INT 1
82508: PUSH
82509: LD_INT 2
82511: PUSH
82512: LD_INT 3
82514: PUSH
82515: LD_INT 4
82517: PUSH
82518: LD_INT 11
82520: PUSH
82521: EMPTY
82522: LIST
82523: LIST
82524: LIST
82525: LIST
82526: LIST
82527: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
82528: LD_ADDR_EXP 86
82532: PUSH
82533: LD_EXP 86
82537: PPUSH
82538: LD_VAR 0 1
82542: PPUSH
82543: LD_EXP 86
82547: PUSH
82548: LD_VAR 0 1
82552: ARRAY
82553: PUSH
82554: LD_VAR 0 3
82558: DIFF
82559: PPUSH
82560: CALL_OW 1
82564: ST_TO_ADDR
// end ;
82565: LD_VAR 0 2
82569: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
82570: LD_INT 0
82572: PPUSH
// result := mc_vehicles [ base ] ;
82573: LD_ADDR_VAR 0 3
82577: PUSH
82578: LD_EXP 78
82582: PUSH
82583: LD_VAR 0 1
82587: ARRAY
82588: ST_TO_ADDR
// if onlyCombat then
82589: LD_VAR 0 2
82593: IFFALSE 82758
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
82595: LD_ADDR_VAR 0 3
82599: PUSH
82600: LD_VAR 0 3
82604: PUSH
82605: LD_VAR 0 3
82609: PPUSH
82610: LD_INT 2
82612: PUSH
82613: LD_INT 34
82615: PUSH
82616: LD_INT 12
82618: PUSH
82619: EMPTY
82620: LIST
82621: LIST
82622: PUSH
82623: LD_INT 34
82625: PUSH
82626: LD_INT 51
82628: PUSH
82629: EMPTY
82630: LIST
82631: LIST
82632: PUSH
82633: LD_INT 34
82635: PUSH
82636: LD_EXP 103
82640: PUSH
82641: EMPTY
82642: LIST
82643: LIST
82644: PUSH
82645: LD_INT 34
82647: PUSH
82648: LD_INT 32
82650: PUSH
82651: EMPTY
82652: LIST
82653: LIST
82654: PUSH
82655: LD_INT 34
82657: PUSH
82658: LD_INT 13
82660: PUSH
82661: EMPTY
82662: LIST
82663: LIST
82664: PUSH
82665: LD_INT 34
82667: PUSH
82668: LD_INT 52
82670: PUSH
82671: EMPTY
82672: LIST
82673: LIST
82674: PUSH
82675: LD_INT 34
82677: PUSH
82678: LD_INT 14
82680: PUSH
82681: EMPTY
82682: LIST
82683: LIST
82684: PUSH
82685: LD_INT 34
82687: PUSH
82688: LD_INT 53
82690: PUSH
82691: EMPTY
82692: LIST
82693: LIST
82694: PUSH
82695: LD_INT 34
82697: PUSH
82698: LD_EXP 102
82702: PUSH
82703: EMPTY
82704: LIST
82705: LIST
82706: PUSH
82707: LD_INT 34
82709: PUSH
82710: LD_INT 31
82712: PUSH
82713: EMPTY
82714: LIST
82715: LIST
82716: PUSH
82717: LD_INT 34
82719: PUSH
82720: LD_INT 48
82722: PUSH
82723: EMPTY
82724: LIST
82725: LIST
82726: PUSH
82727: LD_INT 34
82729: PUSH
82730: LD_INT 8
82732: PUSH
82733: EMPTY
82734: LIST
82735: LIST
82736: PUSH
82737: EMPTY
82738: LIST
82739: LIST
82740: LIST
82741: LIST
82742: LIST
82743: LIST
82744: LIST
82745: LIST
82746: LIST
82747: LIST
82748: LIST
82749: LIST
82750: LIST
82751: PPUSH
82752: CALL_OW 72
82756: DIFF
82757: ST_TO_ADDR
// end ; end_of_file
82758: LD_VAR 0 3
82762: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
82763: LD_INT 0
82765: PPUSH
82766: PPUSH
82767: PPUSH
// if not mc_bases or not skirmish then
82768: LD_EXP 59
82772: NOT
82773: PUSH
82774: LD_EXP 57
82778: NOT
82779: OR
82780: IFFALSE 82784
// exit ;
82782: GO 82949
// for i = 1 to mc_bases do
82784: LD_ADDR_VAR 0 4
82788: PUSH
82789: DOUBLE
82790: LD_INT 1
82792: DEC
82793: ST_TO_ADDR
82794: LD_EXP 59
82798: PUSH
82799: FOR_TO
82800: IFFALSE 82947
// begin if sci in mc_bases [ i ] then
82802: LD_VAR 0 2
82806: PUSH
82807: LD_EXP 59
82811: PUSH
82812: LD_VAR 0 4
82816: ARRAY
82817: IN
82818: IFFALSE 82945
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
82820: LD_ADDR_EXP 88
82824: PUSH
82825: LD_EXP 88
82829: PPUSH
82830: LD_VAR 0 4
82834: PUSH
82835: LD_EXP 88
82839: PUSH
82840: LD_VAR 0 4
82844: ARRAY
82845: PUSH
82846: LD_INT 1
82848: PLUS
82849: PUSH
82850: EMPTY
82851: LIST
82852: LIST
82853: PPUSH
82854: LD_VAR 0 1
82858: PPUSH
82859: CALL 21529 0 3
82863: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
82864: LD_ADDR_VAR 0 5
82868: PUSH
82869: LD_EXP 59
82873: PUSH
82874: LD_VAR 0 4
82878: ARRAY
82879: PPUSH
82880: LD_INT 2
82882: PUSH
82883: LD_INT 30
82885: PUSH
82886: LD_INT 0
82888: PUSH
82889: EMPTY
82890: LIST
82891: LIST
82892: PUSH
82893: LD_INT 30
82895: PUSH
82896: LD_INT 1
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: PUSH
82903: EMPTY
82904: LIST
82905: LIST
82906: LIST
82907: PPUSH
82908: CALL_OW 72
82912: PPUSH
82913: LD_VAR 0 1
82917: PPUSH
82918: CALL_OW 74
82922: ST_TO_ADDR
// if tmp then
82923: LD_VAR 0 5
82927: IFFALSE 82943
// ComStandNearbyBuilding ( ape , tmp ) ;
82929: LD_VAR 0 1
82933: PPUSH
82934: LD_VAR 0 5
82938: PPUSH
82939: CALL 15732 0 2
// break ;
82943: GO 82947
// end ; end ;
82945: GO 82799
82947: POP
82948: POP
// end ;
82949: LD_VAR 0 3
82953: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
82954: LD_INT 0
82956: PPUSH
82957: PPUSH
82958: PPUSH
// if not mc_bases or not skirmish then
82959: LD_EXP 59
82963: NOT
82964: PUSH
82965: LD_EXP 57
82969: NOT
82970: OR
82971: IFFALSE 82975
// exit ;
82973: GO 83064
// for i = 1 to mc_bases do
82975: LD_ADDR_VAR 0 4
82979: PUSH
82980: DOUBLE
82981: LD_INT 1
82983: DEC
82984: ST_TO_ADDR
82985: LD_EXP 59
82989: PUSH
82990: FOR_TO
82991: IFFALSE 83062
// begin if building in mc_busy_turret_list [ i ] then
82993: LD_VAR 0 1
82997: PUSH
82998: LD_EXP 69
83002: PUSH
83003: LD_VAR 0 4
83007: ARRAY
83008: IN
83009: IFFALSE 83060
// begin tmp := mc_busy_turret_list [ i ] diff building ;
83011: LD_ADDR_VAR 0 5
83015: PUSH
83016: LD_EXP 69
83020: PUSH
83021: LD_VAR 0 4
83025: ARRAY
83026: PUSH
83027: LD_VAR 0 1
83031: DIFF
83032: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
83033: LD_ADDR_EXP 69
83037: PUSH
83038: LD_EXP 69
83042: PPUSH
83043: LD_VAR 0 4
83047: PPUSH
83048: LD_VAR 0 5
83052: PPUSH
83053: CALL_OW 1
83057: ST_TO_ADDR
// break ;
83058: GO 83062
// end ; end ;
83060: GO 82990
83062: POP
83063: POP
// end ;
83064: LD_VAR 0 3
83068: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
83069: LD_INT 0
83071: PPUSH
83072: PPUSH
83073: PPUSH
// if not mc_bases or not skirmish then
83074: LD_EXP 59
83078: NOT
83079: PUSH
83080: LD_EXP 57
83084: NOT
83085: OR
83086: IFFALSE 83090
// exit ;
83088: GO 83289
// for i = 1 to mc_bases do
83090: LD_ADDR_VAR 0 5
83094: PUSH
83095: DOUBLE
83096: LD_INT 1
83098: DEC
83099: ST_TO_ADDR
83100: LD_EXP 59
83104: PUSH
83105: FOR_TO
83106: IFFALSE 83287
// if building in mc_bases [ i ] then
83108: LD_VAR 0 1
83112: PUSH
83113: LD_EXP 59
83117: PUSH
83118: LD_VAR 0 5
83122: ARRAY
83123: IN
83124: IFFALSE 83285
// begin tmp := mc_bases [ i ] diff building ;
83126: LD_ADDR_VAR 0 6
83130: PUSH
83131: LD_EXP 59
83135: PUSH
83136: LD_VAR 0 5
83140: ARRAY
83141: PUSH
83142: LD_VAR 0 1
83146: DIFF
83147: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
83148: LD_ADDR_EXP 59
83152: PUSH
83153: LD_EXP 59
83157: PPUSH
83158: LD_VAR 0 5
83162: PPUSH
83163: LD_VAR 0 6
83167: PPUSH
83168: CALL_OW 1
83172: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
83173: LD_VAR 0 1
83177: PUSH
83178: LD_EXP 67
83182: PUSH
83183: LD_VAR 0 5
83187: ARRAY
83188: IN
83189: IFFALSE 83228
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
83191: LD_ADDR_EXP 67
83195: PUSH
83196: LD_EXP 67
83200: PPUSH
83201: LD_VAR 0 5
83205: PPUSH
83206: LD_EXP 67
83210: PUSH
83211: LD_VAR 0 5
83215: ARRAY
83216: PUSH
83217: LD_VAR 0 1
83221: DIFF
83222: PPUSH
83223: CALL_OW 1
83227: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
83228: LD_VAR 0 1
83232: PUSH
83233: LD_EXP 68
83237: PUSH
83238: LD_VAR 0 5
83242: ARRAY
83243: IN
83244: IFFALSE 83283
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
83246: LD_ADDR_EXP 68
83250: PUSH
83251: LD_EXP 68
83255: PPUSH
83256: LD_VAR 0 5
83260: PPUSH
83261: LD_EXP 68
83265: PUSH
83266: LD_VAR 0 5
83270: ARRAY
83271: PUSH
83272: LD_VAR 0 1
83276: DIFF
83277: PPUSH
83278: CALL_OW 1
83282: ST_TO_ADDR
// break ;
83283: GO 83287
// end ;
83285: GO 83105
83287: POP
83288: POP
// end ;
83289: LD_VAR 0 4
83293: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
83294: LD_INT 0
83296: PPUSH
83297: PPUSH
83298: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
83299: LD_EXP 59
83303: NOT
83304: PUSH
83305: LD_EXP 57
83309: NOT
83310: OR
83311: PUSH
83312: LD_VAR 0 3
83316: PUSH
83317: LD_EXP 85
83321: IN
83322: NOT
83323: OR
83324: IFFALSE 83328
// exit ;
83326: GO 83451
// for i = 1 to mc_vehicles do
83328: LD_ADDR_VAR 0 6
83332: PUSH
83333: DOUBLE
83334: LD_INT 1
83336: DEC
83337: ST_TO_ADDR
83338: LD_EXP 78
83342: PUSH
83343: FOR_TO
83344: IFFALSE 83449
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
83346: LD_VAR 0 2
83350: PUSH
83351: LD_EXP 78
83355: PUSH
83356: LD_VAR 0 6
83360: ARRAY
83361: IN
83362: PUSH
83363: LD_VAR 0 1
83367: PUSH
83368: LD_EXP 78
83372: PUSH
83373: LD_VAR 0 6
83377: ARRAY
83378: IN
83379: OR
83380: IFFALSE 83447
// begin tmp := mc_vehicles [ i ] diff old ;
83382: LD_ADDR_VAR 0 7
83386: PUSH
83387: LD_EXP 78
83391: PUSH
83392: LD_VAR 0 6
83396: ARRAY
83397: PUSH
83398: LD_VAR 0 2
83402: DIFF
83403: ST_TO_ADDR
// tmp := tmp diff new ;
83404: LD_ADDR_VAR 0 7
83408: PUSH
83409: LD_VAR 0 7
83413: PUSH
83414: LD_VAR 0 1
83418: DIFF
83419: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
83420: LD_ADDR_EXP 78
83424: PUSH
83425: LD_EXP 78
83429: PPUSH
83430: LD_VAR 0 6
83434: PPUSH
83435: LD_VAR 0 7
83439: PPUSH
83440: CALL_OW 1
83444: ST_TO_ADDR
// break ;
83445: GO 83449
// end ;
83447: GO 83343
83449: POP
83450: POP
// end ;
83451: LD_VAR 0 5
83455: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
83456: LD_INT 0
83458: PPUSH
83459: PPUSH
83460: PPUSH
83461: PPUSH
// if not mc_bases or not skirmish then
83462: LD_EXP 59
83466: NOT
83467: PUSH
83468: LD_EXP 57
83472: NOT
83473: OR
83474: IFFALSE 83478
// exit ;
83476: GO 83855
// side := GetSide ( vehicle ) ;
83478: LD_ADDR_VAR 0 5
83482: PUSH
83483: LD_VAR 0 1
83487: PPUSH
83488: CALL_OW 255
83492: ST_TO_ADDR
// for i = 1 to mc_bases do
83493: LD_ADDR_VAR 0 4
83497: PUSH
83498: DOUBLE
83499: LD_INT 1
83501: DEC
83502: ST_TO_ADDR
83503: LD_EXP 59
83507: PUSH
83508: FOR_TO
83509: IFFALSE 83853
// begin if factory in mc_bases [ i ] then
83511: LD_VAR 0 2
83515: PUSH
83516: LD_EXP 59
83520: PUSH
83521: LD_VAR 0 4
83525: ARRAY
83526: IN
83527: IFFALSE 83851
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
83529: LD_EXP 81
83533: PUSH
83534: LD_VAR 0 4
83538: ARRAY
83539: PUSH
83540: LD_EXP 70
83544: PUSH
83545: LD_VAR 0 4
83549: ARRAY
83550: LESS
83551: PUSH
83552: LD_VAR 0 1
83556: PPUSH
83557: CALL_OW 264
83561: PUSH
83562: LD_INT 31
83564: PUSH
83565: LD_INT 32
83567: PUSH
83568: LD_INT 51
83570: PUSH
83571: LD_EXP 103
83575: PUSH
83576: LD_INT 12
83578: PUSH
83579: LD_INT 30
83581: PUSH
83582: LD_EXP 102
83586: PUSH
83587: LD_INT 11
83589: PUSH
83590: LD_INT 53
83592: PUSH
83593: LD_INT 14
83595: PUSH
83596: LD_EXP 106
83600: PUSH
83601: LD_INT 29
83603: PUSH
83604: LD_EXP 104
83608: PUSH
83609: LD_INT 13
83611: PUSH
83612: LD_INT 52
83614: PUSH
83615: LD_INT 48
83617: PUSH
83618: LD_INT 8
83620: PUSH
83621: EMPTY
83622: LIST
83623: LIST
83624: LIST
83625: LIST
83626: LIST
83627: LIST
83628: LIST
83629: LIST
83630: LIST
83631: LIST
83632: LIST
83633: LIST
83634: LIST
83635: LIST
83636: LIST
83637: LIST
83638: LIST
83639: IN
83640: NOT
83641: AND
83642: IFFALSE 83690
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
83644: LD_ADDR_EXP 81
83648: PUSH
83649: LD_EXP 81
83653: PPUSH
83654: LD_VAR 0 4
83658: PUSH
83659: LD_EXP 81
83663: PUSH
83664: LD_VAR 0 4
83668: ARRAY
83669: PUSH
83670: LD_INT 1
83672: PLUS
83673: PUSH
83674: EMPTY
83675: LIST
83676: LIST
83677: PPUSH
83678: LD_VAR 0 1
83682: PPUSH
83683: CALL 21529 0 3
83687: ST_TO_ADDR
83688: GO 83734
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
83690: LD_ADDR_EXP 78
83694: PUSH
83695: LD_EXP 78
83699: PPUSH
83700: LD_VAR 0 4
83704: PUSH
83705: LD_EXP 78
83709: PUSH
83710: LD_VAR 0 4
83714: ARRAY
83715: PUSH
83716: LD_INT 1
83718: PLUS
83719: PUSH
83720: EMPTY
83721: LIST
83722: LIST
83723: PPUSH
83724: LD_VAR 0 1
83728: PPUSH
83729: CALL 21529 0 3
83733: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
83734: LD_VAR 0 1
83738: PPUSH
83739: CALL_OW 263
83743: PUSH
83744: LD_INT 2
83746: EQUAL
83747: IFFALSE 83767
// begin repeat wait ( 0 0$1 ) ;
83749: LD_INT 35
83751: PPUSH
83752: CALL_OW 67
// until IsControledBy ( vehicle ) ;
83756: LD_VAR 0 1
83760: PPUSH
83761: CALL_OW 312
83765: IFFALSE 83749
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
83767: LD_VAR 0 1
83771: PPUSH
83772: LD_EXP 83
83776: PUSH
83777: LD_VAR 0 4
83781: ARRAY
83782: PPUSH
83783: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
83787: LD_VAR 0 1
83791: PPUSH
83792: CALL_OW 263
83796: PUSH
83797: LD_INT 1
83799: NONEQUAL
83800: IFFALSE 83804
// break ;
83802: GO 83853
// repeat wait ( 0 0$1 ) ;
83804: LD_INT 35
83806: PPUSH
83807: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
83811: LD_VAR 0 1
83815: PPUSH
83816: LD_EXP 83
83820: PUSH
83821: LD_VAR 0 4
83825: ARRAY
83826: PPUSH
83827: CALL_OW 308
83831: IFFALSE 83804
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
83833: LD_VAR 0 1
83837: PPUSH
83838: CALL_OW 311
83842: PPUSH
83843: CALL_OW 121
// exit ;
83847: POP
83848: POP
83849: GO 83855
// end ; end ;
83851: GO 83508
83853: POP
83854: POP
// end ;
83855: LD_VAR 0 3
83859: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
83860: LD_INT 0
83862: PPUSH
83863: PPUSH
83864: PPUSH
83865: PPUSH
// if not mc_bases or not skirmish then
83866: LD_EXP 59
83870: NOT
83871: PUSH
83872: LD_EXP 57
83876: NOT
83877: OR
83878: IFFALSE 83882
// exit ;
83880: GO 84235
// repeat wait ( 0 0$1 ) ;
83882: LD_INT 35
83884: PPUSH
83885: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
83889: LD_VAR 0 2
83893: PPUSH
83894: LD_VAR 0 3
83898: PPUSH
83899: CALL_OW 284
83903: IFFALSE 83882
// if GetResourceTypeXY ( x , y ) = mat_artefact then
83905: LD_VAR 0 2
83909: PPUSH
83910: LD_VAR 0 3
83914: PPUSH
83915: CALL_OW 283
83919: PUSH
83920: LD_INT 4
83922: EQUAL
83923: IFFALSE 83927
// exit ;
83925: GO 84235
// for i = 1 to mc_bases do
83927: LD_ADDR_VAR 0 7
83931: PUSH
83932: DOUBLE
83933: LD_INT 1
83935: DEC
83936: ST_TO_ADDR
83937: LD_EXP 59
83941: PUSH
83942: FOR_TO
83943: IFFALSE 84233
// begin if mc_crates_area [ i ] then
83945: LD_EXP 77
83949: PUSH
83950: LD_VAR 0 7
83954: ARRAY
83955: IFFALSE 84066
// for j in mc_crates_area [ i ] do
83957: LD_ADDR_VAR 0 8
83961: PUSH
83962: LD_EXP 77
83966: PUSH
83967: LD_VAR 0 7
83971: ARRAY
83972: PUSH
83973: FOR_IN
83974: IFFALSE 84064
// if InArea ( x , y , j ) then
83976: LD_VAR 0 2
83980: PPUSH
83981: LD_VAR 0 3
83985: PPUSH
83986: LD_VAR 0 8
83990: PPUSH
83991: CALL_OW 309
83995: IFFALSE 84062
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83997: LD_ADDR_EXP 75
84001: PUSH
84002: LD_EXP 75
84006: PPUSH
84007: LD_VAR 0 7
84011: PUSH
84012: LD_EXP 75
84016: PUSH
84017: LD_VAR 0 7
84021: ARRAY
84022: PUSH
84023: LD_INT 1
84025: PLUS
84026: PUSH
84027: EMPTY
84028: LIST
84029: LIST
84030: PPUSH
84031: LD_VAR 0 4
84035: PUSH
84036: LD_VAR 0 2
84040: PUSH
84041: LD_VAR 0 3
84045: PUSH
84046: EMPTY
84047: LIST
84048: LIST
84049: LIST
84050: PPUSH
84051: CALL 21529 0 3
84055: ST_TO_ADDR
// exit ;
84056: POP
84057: POP
84058: POP
84059: POP
84060: GO 84235
// end ;
84062: GO 83973
84064: POP
84065: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84066: LD_ADDR_VAR 0 9
84070: PUSH
84071: LD_EXP 59
84075: PUSH
84076: LD_VAR 0 7
84080: ARRAY
84081: PPUSH
84082: LD_INT 2
84084: PUSH
84085: LD_INT 30
84087: PUSH
84088: LD_INT 0
84090: PUSH
84091: EMPTY
84092: LIST
84093: LIST
84094: PUSH
84095: LD_INT 30
84097: PUSH
84098: LD_INT 1
84100: PUSH
84101: EMPTY
84102: LIST
84103: LIST
84104: PUSH
84105: EMPTY
84106: LIST
84107: LIST
84108: LIST
84109: PPUSH
84110: CALL_OW 72
84114: ST_TO_ADDR
// if not depot then
84115: LD_VAR 0 9
84119: NOT
84120: IFFALSE 84124
// continue ;
84122: GO 83942
// for j in depot do
84124: LD_ADDR_VAR 0 8
84128: PUSH
84129: LD_VAR 0 9
84133: PUSH
84134: FOR_IN
84135: IFFALSE 84229
// if GetDistUnitXY ( j , x , y ) < 30 then
84137: LD_VAR 0 8
84141: PPUSH
84142: LD_VAR 0 2
84146: PPUSH
84147: LD_VAR 0 3
84151: PPUSH
84152: CALL_OW 297
84156: PUSH
84157: LD_INT 30
84159: LESS
84160: IFFALSE 84227
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84162: LD_ADDR_EXP 75
84166: PUSH
84167: LD_EXP 75
84171: PPUSH
84172: LD_VAR 0 7
84176: PUSH
84177: LD_EXP 75
84181: PUSH
84182: LD_VAR 0 7
84186: ARRAY
84187: PUSH
84188: LD_INT 1
84190: PLUS
84191: PUSH
84192: EMPTY
84193: LIST
84194: LIST
84195: PPUSH
84196: LD_VAR 0 4
84200: PUSH
84201: LD_VAR 0 2
84205: PUSH
84206: LD_VAR 0 3
84210: PUSH
84211: EMPTY
84212: LIST
84213: LIST
84214: LIST
84215: PPUSH
84216: CALL 21529 0 3
84220: ST_TO_ADDR
// exit ;
84221: POP
84222: POP
84223: POP
84224: POP
84225: GO 84235
// end ;
84227: GO 84134
84229: POP
84230: POP
// end ;
84231: GO 83942
84233: POP
84234: POP
// end ;
84235: LD_VAR 0 6
84239: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
84240: LD_INT 0
84242: PPUSH
84243: PPUSH
84244: PPUSH
84245: PPUSH
// if not mc_bases or not skirmish then
84246: LD_EXP 59
84250: NOT
84251: PUSH
84252: LD_EXP 57
84256: NOT
84257: OR
84258: IFFALSE 84262
// exit ;
84260: GO 84539
// side := GetSide ( lab ) ;
84262: LD_ADDR_VAR 0 4
84266: PUSH
84267: LD_VAR 0 2
84271: PPUSH
84272: CALL_OW 255
84276: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
84277: LD_VAR 0 4
84281: PUSH
84282: LD_EXP 85
84286: IN
84287: NOT
84288: PUSH
84289: LD_EXP 86
84293: NOT
84294: OR
84295: PUSH
84296: LD_EXP 59
84300: NOT
84301: OR
84302: IFFALSE 84306
// exit ;
84304: GO 84539
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
84306: LD_ADDR_EXP 86
84310: PUSH
84311: LD_EXP 86
84315: PPUSH
84316: LD_VAR 0 4
84320: PPUSH
84321: LD_EXP 86
84325: PUSH
84326: LD_VAR 0 4
84330: ARRAY
84331: PUSH
84332: LD_VAR 0 1
84336: DIFF
84337: PPUSH
84338: CALL_OW 1
84342: ST_TO_ADDR
// for i = 1 to mc_bases do
84343: LD_ADDR_VAR 0 5
84347: PUSH
84348: DOUBLE
84349: LD_INT 1
84351: DEC
84352: ST_TO_ADDR
84353: LD_EXP 59
84357: PUSH
84358: FOR_TO
84359: IFFALSE 84537
// begin if lab in mc_bases [ i ] then
84361: LD_VAR 0 2
84365: PUSH
84366: LD_EXP 59
84370: PUSH
84371: LD_VAR 0 5
84375: ARRAY
84376: IN
84377: IFFALSE 84535
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
84379: LD_VAR 0 1
84383: PUSH
84384: LD_INT 11
84386: PUSH
84387: LD_INT 4
84389: PUSH
84390: LD_INT 3
84392: PUSH
84393: LD_INT 2
84395: PUSH
84396: EMPTY
84397: LIST
84398: LIST
84399: LIST
84400: LIST
84401: IN
84402: PUSH
84403: LD_EXP 89
84407: PUSH
84408: LD_VAR 0 5
84412: ARRAY
84413: AND
84414: IFFALSE 84535
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
84416: LD_ADDR_VAR 0 6
84420: PUSH
84421: LD_EXP 89
84425: PUSH
84426: LD_VAR 0 5
84430: ARRAY
84431: PUSH
84432: LD_INT 1
84434: ARRAY
84435: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84436: LD_ADDR_EXP 89
84440: PUSH
84441: LD_EXP 89
84445: PPUSH
84446: LD_VAR 0 5
84450: PPUSH
84451: EMPTY
84452: PPUSH
84453: CALL_OW 1
84457: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
84458: LD_VAR 0 6
84462: PPUSH
84463: LD_INT 0
84465: PPUSH
84466: CALL_OW 109
// ComExitBuilding ( tmp ) ;
84470: LD_VAR 0 6
84474: PPUSH
84475: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
84479: LD_ADDR_EXP 88
84483: PUSH
84484: LD_EXP 88
84488: PPUSH
84489: LD_VAR 0 5
84493: PPUSH
84494: LD_EXP 88
84498: PUSH
84499: LD_VAR 0 5
84503: ARRAY
84504: PPUSH
84505: LD_INT 1
84507: PPUSH
84508: LD_VAR 0 6
84512: PPUSH
84513: CALL_OW 2
84517: PPUSH
84518: CALL_OW 1
84522: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
84523: LD_VAR 0 5
84527: PPUSH
84528: LD_INT 112
84530: PPUSH
84531: CALL 61535 0 2
// end ; end ; end ;
84535: GO 84358
84537: POP
84538: POP
// end ;
84539: LD_VAR 0 3
84543: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
84544: LD_INT 0
84546: PPUSH
84547: PPUSH
84548: PPUSH
84549: PPUSH
84550: PPUSH
84551: PPUSH
84552: PPUSH
84553: PPUSH
// if not mc_bases or not skirmish then
84554: LD_EXP 59
84558: NOT
84559: PUSH
84560: LD_EXP 57
84564: NOT
84565: OR
84566: IFFALSE 84570
// exit ;
84568: GO 85941
// for i = 1 to mc_bases do
84570: LD_ADDR_VAR 0 3
84574: PUSH
84575: DOUBLE
84576: LD_INT 1
84578: DEC
84579: ST_TO_ADDR
84580: LD_EXP 59
84584: PUSH
84585: FOR_TO
84586: IFFALSE 85939
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
84588: LD_VAR 0 1
84592: PUSH
84593: LD_EXP 59
84597: PUSH
84598: LD_VAR 0 3
84602: ARRAY
84603: IN
84604: PUSH
84605: LD_VAR 0 1
84609: PUSH
84610: LD_EXP 66
84614: PUSH
84615: LD_VAR 0 3
84619: ARRAY
84620: IN
84621: OR
84622: PUSH
84623: LD_VAR 0 1
84627: PUSH
84628: LD_EXP 81
84632: PUSH
84633: LD_VAR 0 3
84637: ARRAY
84638: IN
84639: OR
84640: PUSH
84641: LD_VAR 0 1
84645: PUSH
84646: LD_EXP 78
84650: PUSH
84651: LD_VAR 0 3
84655: ARRAY
84656: IN
84657: OR
84658: PUSH
84659: LD_VAR 0 1
84663: PUSH
84664: LD_EXP 88
84668: PUSH
84669: LD_VAR 0 3
84673: ARRAY
84674: IN
84675: OR
84676: PUSH
84677: LD_VAR 0 1
84681: PUSH
84682: LD_EXP 89
84686: PUSH
84687: LD_VAR 0 3
84691: ARRAY
84692: IN
84693: OR
84694: IFFALSE 85937
// begin if un in mc_ape [ i ] then
84696: LD_VAR 0 1
84700: PUSH
84701: LD_EXP 88
84705: PUSH
84706: LD_VAR 0 3
84710: ARRAY
84711: IN
84712: IFFALSE 84751
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
84714: LD_ADDR_EXP 88
84718: PUSH
84719: LD_EXP 88
84723: PPUSH
84724: LD_VAR 0 3
84728: PPUSH
84729: LD_EXP 88
84733: PUSH
84734: LD_VAR 0 3
84738: ARRAY
84739: PUSH
84740: LD_VAR 0 1
84744: DIFF
84745: PPUSH
84746: CALL_OW 1
84750: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
84751: LD_VAR 0 1
84755: PUSH
84756: LD_EXP 89
84760: PUSH
84761: LD_VAR 0 3
84765: ARRAY
84766: IN
84767: IFFALSE 84791
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84769: LD_ADDR_EXP 89
84773: PUSH
84774: LD_EXP 89
84778: PPUSH
84779: LD_VAR 0 3
84783: PPUSH
84784: EMPTY
84785: PPUSH
84786: CALL_OW 1
84790: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
84791: LD_VAR 0 1
84795: PPUSH
84796: CALL_OW 247
84800: PUSH
84801: LD_INT 2
84803: EQUAL
84804: PUSH
84805: LD_VAR 0 1
84809: PPUSH
84810: CALL_OW 110
84814: PUSH
84815: LD_INT 20
84817: EQUAL
84818: PUSH
84819: LD_VAR 0 1
84823: PUSH
84824: LD_EXP 81
84828: PUSH
84829: LD_VAR 0 3
84833: ARRAY
84834: IN
84835: OR
84836: PUSH
84837: LD_VAR 0 1
84841: PPUSH
84842: CALL_OW 264
84846: PUSH
84847: LD_INT 12
84849: PUSH
84850: LD_INT 51
84852: PUSH
84853: LD_EXP 103
84857: PUSH
84858: LD_INT 32
84860: PUSH
84861: LD_INT 13
84863: PUSH
84864: LD_INT 52
84866: PUSH
84867: LD_INT 31
84869: PUSH
84870: EMPTY
84871: LIST
84872: LIST
84873: LIST
84874: LIST
84875: LIST
84876: LIST
84877: LIST
84878: IN
84879: OR
84880: AND
84881: IFFALSE 85189
// begin if un in mc_defender [ i ] then
84883: LD_VAR 0 1
84887: PUSH
84888: LD_EXP 81
84892: PUSH
84893: LD_VAR 0 3
84897: ARRAY
84898: IN
84899: IFFALSE 84938
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84901: LD_ADDR_EXP 81
84905: PUSH
84906: LD_EXP 81
84910: PPUSH
84911: LD_VAR 0 3
84915: PPUSH
84916: LD_EXP 81
84920: PUSH
84921: LD_VAR 0 3
84925: ARRAY
84926: PUSH
84927: LD_VAR 0 1
84931: DIFF
84932: PPUSH
84933: CALL_OW 1
84937: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
84938: LD_ADDR_VAR 0 8
84942: PUSH
84943: LD_VAR 0 3
84947: PPUSH
84948: LD_INT 3
84950: PPUSH
84951: CALL 81607 0 2
84955: ST_TO_ADDR
// if fac then
84956: LD_VAR 0 8
84960: IFFALSE 85189
// begin for j in fac do
84962: LD_ADDR_VAR 0 4
84966: PUSH
84967: LD_VAR 0 8
84971: PUSH
84972: FOR_IN
84973: IFFALSE 85187
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
84975: LD_ADDR_VAR 0 9
84979: PUSH
84980: LD_VAR 0 8
84984: PPUSH
84985: LD_VAR 0 1
84989: PPUSH
84990: CALL_OW 265
84994: PPUSH
84995: LD_VAR 0 1
84999: PPUSH
85000: CALL_OW 262
85004: PPUSH
85005: LD_VAR 0 1
85009: PPUSH
85010: CALL_OW 263
85014: PPUSH
85015: LD_VAR 0 1
85019: PPUSH
85020: CALL_OW 264
85024: PPUSH
85025: CALL 19061 0 5
85029: ST_TO_ADDR
// if components then
85030: LD_VAR 0 9
85034: IFFALSE 85185
// begin if GetWeapon ( un ) = ar_control_tower then
85036: LD_VAR 0 1
85040: PPUSH
85041: CALL_OW 264
85045: PUSH
85046: LD_INT 31
85048: EQUAL
85049: IFFALSE 85166
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
85051: LD_VAR 0 1
85055: PPUSH
85056: CALL_OW 311
85060: PPUSH
85061: LD_INT 0
85063: PPUSH
85064: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
85068: LD_ADDR_EXP 99
85072: PUSH
85073: LD_EXP 99
85077: PPUSH
85078: LD_VAR 0 3
85082: PPUSH
85083: LD_EXP 99
85087: PUSH
85088: LD_VAR 0 3
85092: ARRAY
85093: PUSH
85094: LD_VAR 0 1
85098: PPUSH
85099: CALL_OW 311
85103: DIFF
85104: PPUSH
85105: CALL_OW 1
85109: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
85110: LD_ADDR_VAR 0 7
85114: PUSH
85115: LD_EXP 80
85119: PUSH
85120: LD_VAR 0 3
85124: ARRAY
85125: PPUSH
85126: LD_INT 1
85128: PPUSH
85129: LD_VAR 0 9
85133: PPUSH
85134: CALL_OW 2
85138: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
85139: LD_ADDR_EXP 80
85143: PUSH
85144: LD_EXP 80
85148: PPUSH
85149: LD_VAR 0 3
85153: PPUSH
85154: LD_VAR 0 7
85158: PPUSH
85159: CALL_OW 1
85163: ST_TO_ADDR
// end else
85164: GO 85183
// MC_InsertProduceList ( i , [ components ] ) ;
85166: LD_VAR 0 3
85170: PPUSH
85171: LD_VAR 0 9
85175: PUSH
85176: EMPTY
85177: LIST
85178: PPUSH
85179: CALL 81152 0 2
// break ;
85183: GO 85187
// end ; end ;
85185: GO 84972
85187: POP
85188: POP
// end ; end ; if GetType ( un ) = unit_building then
85189: LD_VAR 0 1
85193: PPUSH
85194: CALL_OW 247
85198: PUSH
85199: LD_INT 3
85201: EQUAL
85202: IFFALSE 85605
// begin btype := GetBType ( un ) ;
85204: LD_ADDR_VAR 0 5
85208: PUSH
85209: LD_VAR 0 1
85213: PPUSH
85214: CALL_OW 266
85218: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
85219: LD_VAR 0 5
85223: PUSH
85224: LD_INT 29
85226: PUSH
85227: LD_INT 30
85229: PUSH
85230: EMPTY
85231: LIST
85232: LIST
85233: IN
85234: IFFALSE 85307
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
85236: LD_VAR 0 1
85240: PPUSH
85241: CALL_OW 250
85245: PPUSH
85246: LD_VAR 0 1
85250: PPUSH
85251: CALL_OW 251
85255: PPUSH
85256: LD_VAR 0 1
85260: PPUSH
85261: CALL_OW 255
85265: PPUSH
85266: CALL_OW 440
85270: NOT
85271: IFFALSE 85307
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
85273: LD_VAR 0 1
85277: PPUSH
85278: CALL_OW 250
85282: PPUSH
85283: LD_VAR 0 1
85287: PPUSH
85288: CALL_OW 251
85292: PPUSH
85293: LD_VAR 0 1
85297: PPUSH
85298: CALL_OW 255
85302: PPUSH
85303: CALL_OW 441
// end ; if btype = b_warehouse then
85307: LD_VAR 0 5
85311: PUSH
85312: LD_INT 1
85314: EQUAL
85315: IFFALSE 85333
// begin btype := b_depot ;
85317: LD_ADDR_VAR 0 5
85321: PUSH
85322: LD_INT 0
85324: ST_TO_ADDR
// pos := 1 ;
85325: LD_ADDR_VAR 0 6
85329: PUSH
85330: LD_INT 1
85332: ST_TO_ADDR
// end ; if btype = b_factory then
85333: LD_VAR 0 5
85337: PUSH
85338: LD_INT 3
85340: EQUAL
85341: IFFALSE 85359
// begin btype := b_workshop ;
85343: LD_ADDR_VAR 0 5
85347: PUSH
85348: LD_INT 2
85350: ST_TO_ADDR
// pos := 1 ;
85351: LD_ADDR_VAR 0 6
85355: PUSH
85356: LD_INT 1
85358: ST_TO_ADDR
// end ; if btype = b_barracks then
85359: LD_VAR 0 5
85363: PUSH
85364: LD_INT 5
85366: EQUAL
85367: IFFALSE 85377
// btype := b_armoury ;
85369: LD_ADDR_VAR 0 5
85373: PUSH
85374: LD_INT 4
85376: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
85377: LD_VAR 0 5
85381: PUSH
85382: LD_INT 7
85384: PUSH
85385: LD_INT 8
85387: PUSH
85388: EMPTY
85389: LIST
85390: LIST
85391: IN
85392: IFFALSE 85402
// btype := b_lab ;
85394: LD_ADDR_VAR 0 5
85398: PUSH
85399: LD_INT 6
85401: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
85402: LD_ADDR_EXP 64
85406: PUSH
85407: LD_EXP 64
85411: PPUSH
85412: LD_VAR 0 3
85416: PUSH
85417: LD_EXP 64
85421: PUSH
85422: LD_VAR 0 3
85426: ARRAY
85427: PUSH
85428: LD_INT 1
85430: PLUS
85431: PUSH
85432: EMPTY
85433: LIST
85434: LIST
85435: PPUSH
85436: LD_VAR 0 5
85440: PUSH
85441: LD_VAR 0 1
85445: PPUSH
85446: CALL_OW 250
85450: PUSH
85451: LD_VAR 0 1
85455: PPUSH
85456: CALL_OW 251
85460: PUSH
85461: LD_VAR 0 1
85465: PPUSH
85466: CALL_OW 254
85470: PUSH
85471: EMPTY
85472: LIST
85473: LIST
85474: LIST
85475: LIST
85476: PPUSH
85477: CALL 21529 0 3
85481: ST_TO_ADDR
// if pos = 1 then
85482: LD_VAR 0 6
85486: PUSH
85487: LD_INT 1
85489: EQUAL
85490: IFFALSE 85605
// begin tmp := mc_build_list [ i ] ;
85492: LD_ADDR_VAR 0 7
85496: PUSH
85497: LD_EXP 64
85501: PUSH
85502: LD_VAR 0 3
85506: ARRAY
85507: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
85508: LD_VAR 0 7
85512: PPUSH
85513: LD_INT 2
85515: PUSH
85516: LD_INT 30
85518: PUSH
85519: LD_INT 0
85521: PUSH
85522: EMPTY
85523: LIST
85524: LIST
85525: PUSH
85526: LD_INT 30
85528: PUSH
85529: LD_INT 1
85531: PUSH
85532: EMPTY
85533: LIST
85534: LIST
85535: PUSH
85536: EMPTY
85537: LIST
85538: LIST
85539: LIST
85540: PPUSH
85541: CALL_OW 72
85545: IFFALSE 85555
// pos := 2 ;
85547: LD_ADDR_VAR 0 6
85551: PUSH
85552: LD_INT 2
85554: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
85555: LD_ADDR_VAR 0 7
85559: PUSH
85560: LD_VAR 0 7
85564: PPUSH
85565: LD_VAR 0 6
85569: PPUSH
85570: LD_VAR 0 7
85574: PPUSH
85575: CALL 21855 0 3
85579: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
85580: LD_ADDR_EXP 64
85584: PUSH
85585: LD_EXP 64
85589: PPUSH
85590: LD_VAR 0 3
85594: PPUSH
85595: LD_VAR 0 7
85599: PPUSH
85600: CALL_OW 1
85604: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
85605: LD_VAR 0 1
85609: PUSH
85610: LD_EXP 59
85614: PUSH
85615: LD_VAR 0 3
85619: ARRAY
85620: IN
85621: IFFALSE 85660
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
85623: LD_ADDR_EXP 59
85627: PUSH
85628: LD_EXP 59
85632: PPUSH
85633: LD_VAR 0 3
85637: PPUSH
85638: LD_EXP 59
85642: PUSH
85643: LD_VAR 0 3
85647: ARRAY
85648: PUSH
85649: LD_VAR 0 1
85653: DIFF
85654: PPUSH
85655: CALL_OW 1
85659: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
85660: LD_VAR 0 1
85664: PUSH
85665: LD_EXP 66
85669: PUSH
85670: LD_VAR 0 3
85674: ARRAY
85675: IN
85676: IFFALSE 85715
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
85678: LD_ADDR_EXP 66
85682: PUSH
85683: LD_EXP 66
85687: PPUSH
85688: LD_VAR 0 3
85692: PPUSH
85693: LD_EXP 66
85697: PUSH
85698: LD_VAR 0 3
85702: ARRAY
85703: PUSH
85704: LD_VAR 0 1
85708: DIFF
85709: PPUSH
85710: CALL_OW 1
85714: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
85715: LD_VAR 0 1
85719: PUSH
85720: LD_EXP 78
85724: PUSH
85725: LD_VAR 0 3
85729: ARRAY
85730: IN
85731: IFFALSE 85770
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
85733: LD_ADDR_EXP 78
85737: PUSH
85738: LD_EXP 78
85742: PPUSH
85743: LD_VAR 0 3
85747: PPUSH
85748: LD_EXP 78
85752: PUSH
85753: LD_VAR 0 3
85757: ARRAY
85758: PUSH
85759: LD_VAR 0 1
85763: DIFF
85764: PPUSH
85765: CALL_OW 1
85769: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
85770: LD_VAR 0 1
85774: PUSH
85775: LD_EXP 81
85779: PUSH
85780: LD_VAR 0 3
85784: ARRAY
85785: IN
85786: IFFALSE 85825
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85788: LD_ADDR_EXP 81
85792: PUSH
85793: LD_EXP 81
85797: PPUSH
85798: LD_VAR 0 3
85802: PPUSH
85803: LD_EXP 81
85807: PUSH
85808: LD_VAR 0 3
85812: ARRAY
85813: PUSH
85814: LD_VAR 0 1
85818: DIFF
85819: PPUSH
85820: CALL_OW 1
85824: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
85825: LD_VAR 0 1
85829: PUSH
85830: LD_EXP 68
85834: PUSH
85835: LD_VAR 0 3
85839: ARRAY
85840: IN
85841: IFFALSE 85880
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
85843: LD_ADDR_EXP 68
85847: PUSH
85848: LD_EXP 68
85852: PPUSH
85853: LD_VAR 0 3
85857: PPUSH
85858: LD_EXP 68
85862: PUSH
85863: LD_VAR 0 3
85867: ARRAY
85868: PUSH
85869: LD_VAR 0 1
85873: DIFF
85874: PPUSH
85875: CALL_OW 1
85879: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
85880: LD_VAR 0 1
85884: PUSH
85885: LD_EXP 67
85889: PUSH
85890: LD_VAR 0 3
85894: ARRAY
85895: IN
85896: IFFALSE 85935
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
85898: LD_ADDR_EXP 67
85902: PUSH
85903: LD_EXP 67
85907: PPUSH
85908: LD_VAR 0 3
85912: PPUSH
85913: LD_EXP 67
85917: PUSH
85918: LD_VAR 0 3
85922: ARRAY
85923: PUSH
85924: LD_VAR 0 1
85928: DIFF
85929: PPUSH
85930: CALL_OW 1
85934: ST_TO_ADDR
// end ; break ;
85935: GO 85939
// end ;
85937: GO 84585
85939: POP
85940: POP
// end ;
85941: LD_VAR 0 2
85945: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
85946: LD_INT 0
85948: PPUSH
85949: PPUSH
85950: PPUSH
// if not mc_bases or not skirmish then
85951: LD_EXP 59
85955: NOT
85956: PUSH
85957: LD_EXP 57
85961: NOT
85962: OR
85963: IFFALSE 85967
// exit ;
85965: GO 86182
// for i = 1 to mc_bases do
85967: LD_ADDR_VAR 0 3
85971: PUSH
85972: DOUBLE
85973: LD_INT 1
85975: DEC
85976: ST_TO_ADDR
85977: LD_EXP 59
85981: PUSH
85982: FOR_TO
85983: IFFALSE 86180
// begin if building in mc_construct_list [ i ] then
85985: LD_VAR 0 1
85989: PUSH
85990: LD_EXP 66
85994: PUSH
85995: LD_VAR 0 3
85999: ARRAY
86000: IN
86001: IFFALSE 86178
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86003: LD_ADDR_EXP 66
86007: PUSH
86008: LD_EXP 66
86012: PPUSH
86013: LD_VAR 0 3
86017: PPUSH
86018: LD_EXP 66
86022: PUSH
86023: LD_VAR 0 3
86027: ARRAY
86028: PUSH
86029: LD_VAR 0 1
86033: DIFF
86034: PPUSH
86035: CALL_OW 1
86039: ST_TO_ADDR
// if building in mc_lab [ i ] then
86040: LD_VAR 0 1
86044: PUSH
86045: LD_EXP 92
86049: PUSH
86050: LD_VAR 0 3
86054: ARRAY
86055: IN
86056: IFFALSE 86111
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
86058: LD_ADDR_EXP 93
86062: PUSH
86063: LD_EXP 93
86067: PPUSH
86068: LD_VAR 0 3
86072: PPUSH
86073: LD_EXP 93
86077: PUSH
86078: LD_VAR 0 3
86082: ARRAY
86083: PPUSH
86084: LD_INT 1
86086: PPUSH
86087: LD_EXP 93
86091: PUSH
86092: LD_VAR 0 3
86096: ARRAY
86097: PPUSH
86098: LD_INT 0
86100: PPUSH
86101: CALL 20947 0 4
86105: PPUSH
86106: CALL_OW 1
86110: ST_TO_ADDR
// if not building in mc_bases [ i ] then
86111: LD_VAR 0 1
86115: PUSH
86116: LD_EXP 59
86120: PUSH
86121: LD_VAR 0 3
86125: ARRAY
86126: IN
86127: NOT
86128: IFFALSE 86174
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86130: LD_ADDR_EXP 59
86134: PUSH
86135: LD_EXP 59
86139: PPUSH
86140: LD_VAR 0 3
86144: PUSH
86145: LD_EXP 59
86149: PUSH
86150: LD_VAR 0 3
86154: ARRAY
86155: PUSH
86156: LD_INT 1
86158: PLUS
86159: PUSH
86160: EMPTY
86161: LIST
86162: LIST
86163: PPUSH
86164: LD_VAR 0 1
86168: PPUSH
86169: CALL 21529 0 3
86173: ST_TO_ADDR
// exit ;
86174: POP
86175: POP
86176: GO 86182
// end ; end ;
86178: GO 85982
86180: POP
86181: POP
// end ;
86182: LD_VAR 0 2
86186: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
86187: LD_INT 0
86189: PPUSH
86190: PPUSH
86191: PPUSH
86192: PPUSH
86193: PPUSH
86194: PPUSH
86195: PPUSH
// if not mc_bases or not skirmish then
86196: LD_EXP 59
86200: NOT
86201: PUSH
86202: LD_EXP 57
86206: NOT
86207: OR
86208: IFFALSE 86212
// exit ;
86210: GO 86873
// for i = 1 to mc_bases do
86212: LD_ADDR_VAR 0 3
86216: PUSH
86217: DOUBLE
86218: LD_INT 1
86220: DEC
86221: ST_TO_ADDR
86222: LD_EXP 59
86226: PUSH
86227: FOR_TO
86228: IFFALSE 86871
// begin if building in mc_construct_list [ i ] then
86230: LD_VAR 0 1
86234: PUSH
86235: LD_EXP 66
86239: PUSH
86240: LD_VAR 0 3
86244: ARRAY
86245: IN
86246: IFFALSE 86869
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86248: LD_ADDR_EXP 66
86252: PUSH
86253: LD_EXP 66
86257: PPUSH
86258: LD_VAR 0 3
86262: PPUSH
86263: LD_EXP 66
86267: PUSH
86268: LD_VAR 0 3
86272: ARRAY
86273: PUSH
86274: LD_VAR 0 1
86278: DIFF
86279: PPUSH
86280: CALL_OW 1
86284: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86285: LD_ADDR_EXP 59
86289: PUSH
86290: LD_EXP 59
86294: PPUSH
86295: LD_VAR 0 3
86299: PUSH
86300: LD_EXP 59
86304: PUSH
86305: LD_VAR 0 3
86309: ARRAY
86310: PUSH
86311: LD_INT 1
86313: PLUS
86314: PUSH
86315: EMPTY
86316: LIST
86317: LIST
86318: PPUSH
86319: LD_VAR 0 1
86323: PPUSH
86324: CALL 21529 0 3
86328: ST_TO_ADDR
// btype := GetBType ( building ) ;
86329: LD_ADDR_VAR 0 5
86333: PUSH
86334: LD_VAR 0 1
86338: PPUSH
86339: CALL_OW 266
86343: ST_TO_ADDR
// side := GetSide ( building ) ;
86344: LD_ADDR_VAR 0 8
86348: PUSH
86349: LD_VAR 0 1
86353: PPUSH
86354: CALL_OW 255
86358: ST_TO_ADDR
// if btype = b_lab then
86359: LD_VAR 0 5
86363: PUSH
86364: LD_INT 6
86366: EQUAL
86367: IFFALSE 86417
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
86369: LD_ADDR_EXP 92
86373: PUSH
86374: LD_EXP 92
86378: PPUSH
86379: LD_VAR 0 3
86383: PUSH
86384: LD_EXP 92
86388: PUSH
86389: LD_VAR 0 3
86393: ARRAY
86394: PUSH
86395: LD_INT 1
86397: PLUS
86398: PUSH
86399: EMPTY
86400: LIST
86401: LIST
86402: PPUSH
86403: LD_VAR 0 1
86407: PPUSH
86408: CALL 21529 0 3
86412: ST_TO_ADDR
// exit ;
86413: POP
86414: POP
86415: GO 86873
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
86417: LD_VAR 0 5
86421: PUSH
86422: LD_INT 0
86424: PUSH
86425: LD_INT 2
86427: PUSH
86428: LD_INT 4
86430: PUSH
86431: EMPTY
86432: LIST
86433: LIST
86434: LIST
86435: IN
86436: IFFALSE 86560
// begin if btype = b_armoury then
86438: LD_VAR 0 5
86442: PUSH
86443: LD_INT 4
86445: EQUAL
86446: IFFALSE 86456
// btype := b_barracks ;
86448: LD_ADDR_VAR 0 5
86452: PUSH
86453: LD_INT 5
86455: ST_TO_ADDR
// if btype = b_depot then
86456: LD_VAR 0 5
86460: PUSH
86461: LD_INT 0
86463: EQUAL
86464: IFFALSE 86474
// btype := b_warehouse ;
86466: LD_ADDR_VAR 0 5
86470: PUSH
86471: LD_INT 1
86473: ST_TO_ADDR
// if btype = b_workshop then
86474: LD_VAR 0 5
86478: PUSH
86479: LD_INT 2
86481: EQUAL
86482: IFFALSE 86492
// btype := b_factory ;
86484: LD_ADDR_VAR 0 5
86488: PUSH
86489: LD_INT 3
86491: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
86492: LD_VAR 0 5
86496: PPUSH
86497: LD_VAR 0 8
86501: PPUSH
86502: CALL_OW 323
86506: PUSH
86507: LD_INT 1
86509: EQUAL
86510: IFFALSE 86556
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
86512: LD_ADDR_EXP 91
86516: PUSH
86517: LD_EXP 91
86521: PPUSH
86522: LD_VAR 0 3
86526: PUSH
86527: LD_EXP 91
86531: PUSH
86532: LD_VAR 0 3
86536: ARRAY
86537: PUSH
86538: LD_INT 1
86540: PLUS
86541: PUSH
86542: EMPTY
86543: LIST
86544: LIST
86545: PPUSH
86546: LD_VAR 0 1
86550: PPUSH
86551: CALL 21529 0 3
86555: ST_TO_ADDR
// exit ;
86556: POP
86557: POP
86558: GO 86873
// end ; if btype in [ b_bunker , b_turret ] then
86560: LD_VAR 0 5
86564: PUSH
86565: LD_INT 32
86567: PUSH
86568: LD_INT 33
86570: PUSH
86571: EMPTY
86572: LIST
86573: LIST
86574: IN
86575: IFFALSE 86865
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
86577: LD_ADDR_EXP 67
86581: PUSH
86582: LD_EXP 67
86586: PPUSH
86587: LD_VAR 0 3
86591: PUSH
86592: LD_EXP 67
86596: PUSH
86597: LD_VAR 0 3
86601: ARRAY
86602: PUSH
86603: LD_INT 1
86605: PLUS
86606: PUSH
86607: EMPTY
86608: LIST
86609: LIST
86610: PPUSH
86611: LD_VAR 0 1
86615: PPUSH
86616: CALL 21529 0 3
86620: ST_TO_ADDR
// if btype = b_bunker then
86621: LD_VAR 0 5
86625: PUSH
86626: LD_INT 32
86628: EQUAL
86629: IFFALSE 86865
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86631: LD_ADDR_EXP 68
86635: PUSH
86636: LD_EXP 68
86640: PPUSH
86641: LD_VAR 0 3
86645: PUSH
86646: LD_EXP 68
86650: PUSH
86651: LD_VAR 0 3
86655: ARRAY
86656: PUSH
86657: LD_INT 1
86659: PLUS
86660: PUSH
86661: EMPTY
86662: LIST
86663: LIST
86664: PPUSH
86665: LD_VAR 0 1
86669: PPUSH
86670: CALL 21529 0 3
86674: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
86675: LD_ADDR_VAR 0 6
86679: PUSH
86680: LD_EXP 59
86684: PUSH
86685: LD_VAR 0 3
86689: ARRAY
86690: PPUSH
86691: LD_INT 25
86693: PUSH
86694: LD_INT 1
86696: PUSH
86697: EMPTY
86698: LIST
86699: LIST
86700: PUSH
86701: LD_INT 3
86703: PUSH
86704: LD_INT 54
86706: PUSH
86707: EMPTY
86708: LIST
86709: PUSH
86710: EMPTY
86711: LIST
86712: LIST
86713: PUSH
86714: EMPTY
86715: LIST
86716: LIST
86717: PPUSH
86718: CALL_OW 72
86722: ST_TO_ADDR
// if tmp then
86723: LD_VAR 0 6
86727: IFFALSE 86733
// exit ;
86729: POP
86730: POP
86731: GO 86873
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86733: LD_ADDR_VAR 0 6
86737: PUSH
86738: LD_EXP 59
86742: PUSH
86743: LD_VAR 0 3
86747: ARRAY
86748: PPUSH
86749: LD_INT 2
86751: PUSH
86752: LD_INT 30
86754: PUSH
86755: LD_INT 4
86757: PUSH
86758: EMPTY
86759: LIST
86760: LIST
86761: PUSH
86762: LD_INT 30
86764: PUSH
86765: LD_INT 5
86767: PUSH
86768: EMPTY
86769: LIST
86770: LIST
86771: PUSH
86772: EMPTY
86773: LIST
86774: LIST
86775: LIST
86776: PPUSH
86777: CALL_OW 72
86781: ST_TO_ADDR
// if not tmp then
86782: LD_VAR 0 6
86786: NOT
86787: IFFALSE 86793
// exit ;
86789: POP
86790: POP
86791: GO 86873
// for j in tmp do
86793: LD_ADDR_VAR 0 4
86797: PUSH
86798: LD_VAR 0 6
86802: PUSH
86803: FOR_IN
86804: IFFALSE 86863
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
86806: LD_ADDR_VAR 0 7
86810: PUSH
86811: LD_VAR 0 4
86815: PPUSH
86816: CALL_OW 313
86820: PPUSH
86821: LD_INT 25
86823: PUSH
86824: LD_INT 1
86826: PUSH
86827: EMPTY
86828: LIST
86829: LIST
86830: PPUSH
86831: CALL_OW 72
86835: ST_TO_ADDR
// if units then
86836: LD_VAR 0 7
86840: IFFALSE 86861
// begin ComExitBuilding ( units [ 1 ] ) ;
86842: LD_VAR 0 7
86846: PUSH
86847: LD_INT 1
86849: ARRAY
86850: PPUSH
86851: CALL_OW 122
// exit ;
86855: POP
86856: POP
86857: POP
86858: POP
86859: GO 86873
// end ; end ;
86861: GO 86803
86863: POP
86864: POP
// end ; end ; exit ;
86865: POP
86866: POP
86867: GO 86873
// end ; end ;
86869: GO 86227
86871: POP
86872: POP
// end ;
86873: LD_VAR 0 2
86877: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
86878: LD_INT 0
86880: PPUSH
86881: PPUSH
86882: PPUSH
86883: PPUSH
86884: PPUSH
86885: PPUSH
86886: PPUSH
// if not mc_bases or not skirmish then
86887: LD_EXP 59
86891: NOT
86892: PUSH
86893: LD_EXP 57
86897: NOT
86898: OR
86899: IFFALSE 86903
// exit ;
86901: GO 87134
// btype := GetBType ( building ) ;
86903: LD_ADDR_VAR 0 6
86907: PUSH
86908: LD_VAR 0 1
86912: PPUSH
86913: CALL_OW 266
86917: ST_TO_ADDR
// x := GetX ( building ) ;
86918: LD_ADDR_VAR 0 7
86922: PUSH
86923: LD_VAR 0 1
86927: PPUSH
86928: CALL_OW 250
86932: ST_TO_ADDR
// y := GetY ( building ) ;
86933: LD_ADDR_VAR 0 8
86937: PUSH
86938: LD_VAR 0 1
86942: PPUSH
86943: CALL_OW 251
86947: ST_TO_ADDR
// d := GetDir ( building ) ;
86948: LD_ADDR_VAR 0 9
86952: PUSH
86953: LD_VAR 0 1
86957: PPUSH
86958: CALL_OW 254
86962: ST_TO_ADDR
// for i = 1 to mc_bases do
86963: LD_ADDR_VAR 0 4
86967: PUSH
86968: DOUBLE
86969: LD_INT 1
86971: DEC
86972: ST_TO_ADDR
86973: LD_EXP 59
86977: PUSH
86978: FOR_TO
86979: IFFALSE 87132
// begin if not mc_build_list [ i ] then
86981: LD_EXP 64
86985: PUSH
86986: LD_VAR 0 4
86990: ARRAY
86991: NOT
86992: IFFALSE 86996
// continue ;
86994: GO 86978
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
86996: LD_VAR 0 6
87000: PUSH
87001: LD_VAR 0 7
87005: PUSH
87006: LD_VAR 0 8
87010: PUSH
87011: LD_VAR 0 9
87015: PUSH
87016: EMPTY
87017: LIST
87018: LIST
87019: LIST
87020: LIST
87021: PPUSH
87022: LD_EXP 64
87026: PUSH
87027: LD_VAR 0 4
87031: ARRAY
87032: PUSH
87033: LD_INT 1
87035: ARRAY
87036: PPUSH
87037: CALL 27698 0 2
87041: IFFALSE 87130
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
87043: LD_ADDR_EXP 64
87047: PUSH
87048: LD_EXP 64
87052: PPUSH
87053: LD_VAR 0 4
87057: PPUSH
87058: LD_EXP 64
87062: PUSH
87063: LD_VAR 0 4
87067: ARRAY
87068: PPUSH
87069: LD_INT 1
87071: PPUSH
87072: CALL_OW 3
87076: PPUSH
87077: CALL_OW 1
87081: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
87082: LD_ADDR_EXP 66
87086: PUSH
87087: LD_EXP 66
87091: PPUSH
87092: LD_VAR 0 4
87096: PUSH
87097: LD_EXP 66
87101: PUSH
87102: LD_VAR 0 4
87106: ARRAY
87107: PUSH
87108: LD_INT 1
87110: PLUS
87111: PUSH
87112: EMPTY
87113: LIST
87114: LIST
87115: PPUSH
87116: LD_VAR 0 1
87120: PPUSH
87121: CALL 21529 0 3
87125: ST_TO_ADDR
// exit ;
87126: POP
87127: POP
87128: GO 87134
// end ; end ;
87130: GO 86978
87132: POP
87133: POP
// end ;
87134: LD_VAR 0 3
87138: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
87139: LD_INT 0
87141: PPUSH
87142: PPUSH
87143: PPUSH
// if not mc_bases or not skirmish then
87144: LD_EXP 59
87148: NOT
87149: PUSH
87150: LD_EXP 57
87154: NOT
87155: OR
87156: IFFALSE 87160
// exit ;
87158: GO 87350
// for i = 1 to mc_bases do
87160: LD_ADDR_VAR 0 4
87164: PUSH
87165: DOUBLE
87166: LD_INT 1
87168: DEC
87169: ST_TO_ADDR
87170: LD_EXP 59
87174: PUSH
87175: FOR_TO
87176: IFFALSE 87263
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
87178: LD_VAR 0 1
87182: PUSH
87183: LD_EXP 67
87187: PUSH
87188: LD_VAR 0 4
87192: ARRAY
87193: IN
87194: PUSH
87195: LD_VAR 0 1
87199: PUSH
87200: LD_EXP 68
87204: PUSH
87205: LD_VAR 0 4
87209: ARRAY
87210: IN
87211: NOT
87212: AND
87213: IFFALSE 87261
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
87215: LD_ADDR_EXP 68
87219: PUSH
87220: LD_EXP 68
87224: PPUSH
87225: LD_VAR 0 4
87229: PUSH
87230: LD_EXP 68
87234: PUSH
87235: LD_VAR 0 4
87239: ARRAY
87240: PUSH
87241: LD_INT 1
87243: PLUS
87244: PUSH
87245: EMPTY
87246: LIST
87247: LIST
87248: PPUSH
87249: LD_VAR 0 1
87253: PPUSH
87254: CALL 21529 0 3
87258: ST_TO_ADDR
// break ;
87259: GO 87263
// end ; end ;
87261: GO 87175
87263: POP
87264: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
87265: LD_VAR 0 1
87269: PPUSH
87270: CALL_OW 257
87274: PUSH
87275: LD_EXP 85
87279: IN
87280: PUSH
87281: LD_VAR 0 1
87285: PPUSH
87286: CALL_OW 266
87290: PUSH
87291: LD_INT 5
87293: EQUAL
87294: AND
87295: PUSH
87296: LD_VAR 0 2
87300: PPUSH
87301: CALL_OW 110
87305: PUSH
87306: LD_INT 18
87308: NONEQUAL
87309: AND
87310: IFFALSE 87350
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
87312: LD_VAR 0 2
87316: PPUSH
87317: CALL_OW 257
87321: PUSH
87322: LD_INT 5
87324: PUSH
87325: LD_INT 8
87327: PUSH
87328: LD_INT 9
87330: PUSH
87331: EMPTY
87332: LIST
87333: LIST
87334: LIST
87335: IN
87336: IFFALSE 87350
// SetClass ( unit , 1 ) ;
87338: LD_VAR 0 2
87342: PPUSH
87343: LD_INT 1
87345: PPUSH
87346: CALL_OW 336
// end ;
87350: LD_VAR 0 3
87354: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
87355: LD_INT 0
87357: PPUSH
87358: PPUSH
// if not mc_bases or not skirmish then
87359: LD_EXP 59
87363: NOT
87364: PUSH
87365: LD_EXP 57
87369: NOT
87370: OR
87371: IFFALSE 87375
// exit ;
87373: GO 87491
// if GetLives ( abandoned_vehicle ) > 250 then
87375: LD_VAR 0 2
87379: PPUSH
87380: CALL_OW 256
87384: PUSH
87385: LD_INT 250
87387: GREATER
87388: IFFALSE 87392
// exit ;
87390: GO 87491
// for i = 1 to mc_bases do
87392: LD_ADDR_VAR 0 6
87396: PUSH
87397: DOUBLE
87398: LD_INT 1
87400: DEC
87401: ST_TO_ADDR
87402: LD_EXP 59
87406: PUSH
87407: FOR_TO
87408: IFFALSE 87489
// begin if driver in mc_bases [ i ] then
87410: LD_VAR 0 1
87414: PUSH
87415: LD_EXP 59
87419: PUSH
87420: LD_VAR 0 6
87424: ARRAY
87425: IN
87426: IFFALSE 87487
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
87428: LD_VAR 0 1
87432: PPUSH
87433: LD_EXP 59
87437: PUSH
87438: LD_VAR 0 6
87442: ARRAY
87443: PPUSH
87444: LD_INT 2
87446: PUSH
87447: LD_INT 30
87449: PUSH
87450: LD_INT 0
87452: PUSH
87453: EMPTY
87454: LIST
87455: LIST
87456: PUSH
87457: LD_INT 30
87459: PUSH
87460: LD_INT 1
87462: PUSH
87463: EMPTY
87464: LIST
87465: LIST
87466: PUSH
87467: EMPTY
87468: LIST
87469: LIST
87470: LIST
87471: PPUSH
87472: CALL_OW 72
87476: PUSH
87477: LD_INT 1
87479: ARRAY
87480: PPUSH
87481: CALL_OW 112
// break ;
87485: GO 87489
// end ; end ;
87487: GO 87407
87489: POP
87490: POP
// end ; end_of_file
87491: LD_VAR 0 5
87495: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
87496: GO 87498
87498: DISABLE
// begin ru_radar := 98 ;
87499: LD_ADDR_EXP 102
87503: PUSH
87504: LD_INT 98
87506: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
87507: LD_ADDR_EXP 103
87511: PUSH
87512: LD_INT 89
87514: ST_TO_ADDR
// us_hack := 99 ;
87515: LD_ADDR_EXP 104
87519: PUSH
87520: LD_INT 99
87522: ST_TO_ADDR
// us_artillery := 97 ;
87523: LD_ADDR_EXP 105
87527: PUSH
87528: LD_INT 97
87530: ST_TO_ADDR
// ar_bio_bomb := 91 ;
87531: LD_ADDR_EXP 106
87535: PUSH
87536: LD_INT 91
87538: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
87539: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
87540: LD_INT 0
87542: PPUSH
87543: PPUSH
87544: PPUSH
87545: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
87546: LD_VAR 0 1
87550: PPUSH
87551: CALL_OW 264
87555: PUSH
87556: LD_EXP 106
87560: EQUAL
87561: IFFALSE 87633
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
87563: LD_INT 68
87565: PPUSH
87566: LD_VAR 0 1
87570: PPUSH
87571: CALL_OW 255
87575: PPUSH
87576: CALL_OW 321
87580: PUSH
87581: LD_INT 2
87583: EQUAL
87584: IFFALSE 87596
// eff := 70 else
87586: LD_ADDR_VAR 0 6
87590: PUSH
87591: LD_INT 70
87593: ST_TO_ADDR
87594: GO 87604
// eff := 30 ;
87596: LD_ADDR_VAR 0 6
87600: PUSH
87601: LD_INT 30
87603: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
87604: LD_VAR 0 1
87608: PPUSH
87609: CALL_OW 250
87613: PPUSH
87614: LD_VAR 0 1
87618: PPUSH
87619: CALL_OW 251
87623: PPUSH
87624: LD_VAR 0 6
87628: PPUSH
87629: CALL_OW 495
// end ; end ;
87633: LD_VAR 0 4
87637: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
87638: LD_INT 0
87640: PPUSH
87641: PPUSH
87642: PPUSH
87643: PPUSH
87644: PPUSH
87645: PPUSH
// if cmd = 124 then
87646: LD_VAR 0 1
87650: PUSH
87651: LD_INT 124
87653: EQUAL
87654: IFFALSE 87860
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
87656: LD_ADDR_VAR 0 5
87660: PUSH
87661: LD_INT 2
87663: PUSH
87664: LD_INT 34
87666: PUSH
87667: LD_INT 53
87669: PUSH
87670: EMPTY
87671: LIST
87672: LIST
87673: PUSH
87674: LD_INT 34
87676: PUSH
87677: LD_INT 14
87679: PUSH
87680: EMPTY
87681: LIST
87682: LIST
87683: PUSH
87684: EMPTY
87685: LIST
87686: LIST
87687: LIST
87688: PPUSH
87689: CALL_OW 69
87693: ST_TO_ADDR
// if not tmp then
87694: LD_VAR 0 5
87698: NOT
87699: IFFALSE 87703
// exit ;
87701: GO 87860
// for i in tmp do
87703: LD_ADDR_VAR 0 3
87707: PUSH
87708: LD_VAR 0 5
87712: PUSH
87713: FOR_IN
87714: IFFALSE 87858
// begin taskList := GetTaskList ( i ) ;
87716: LD_ADDR_VAR 0 6
87720: PUSH
87721: LD_VAR 0 3
87725: PPUSH
87726: CALL_OW 437
87730: ST_TO_ADDR
// if not taskList then
87731: LD_VAR 0 6
87735: NOT
87736: IFFALSE 87740
// continue ;
87738: GO 87713
// for j = 1 to taskList do
87740: LD_ADDR_VAR 0 4
87744: PUSH
87745: DOUBLE
87746: LD_INT 1
87748: DEC
87749: ST_TO_ADDR
87750: LD_VAR 0 6
87754: PUSH
87755: FOR_TO
87756: IFFALSE 87854
// if taskList [ j ] [ 1 ] = | then
87758: LD_VAR 0 6
87762: PUSH
87763: LD_VAR 0 4
87767: ARRAY
87768: PUSH
87769: LD_INT 1
87771: ARRAY
87772: PUSH
87773: LD_STRING |
87775: EQUAL
87776: IFFALSE 87852
// begin _taskList := Delete ( taskList , 1 ) ;
87778: LD_ADDR_VAR 0 7
87782: PUSH
87783: LD_VAR 0 6
87787: PPUSH
87788: LD_INT 1
87790: PPUSH
87791: CALL_OW 3
87795: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
87796: LD_VAR 0 3
87800: PPUSH
87801: LD_VAR 0 7
87805: PPUSH
87806: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
87810: LD_VAR 0 3
87814: PPUSH
87815: LD_VAR 0 6
87819: PUSH
87820: LD_VAR 0 4
87824: ARRAY
87825: PUSH
87826: LD_INT 2
87828: ARRAY
87829: PPUSH
87830: LD_VAR 0 6
87834: PUSH
87835: LD_VAR 0 4
87839: ARRAY
87840: PUSH
87841: LD_INT 3
87843: ARRAY
87844: PPUSH
87845: LD_INT 8
87847: PPUSH
87848: CALL 87865 0 4
// end ;
87852: GO 87755
87854: POP
87855: POP
// end ;
87856: GO 87713
87858: POP
87859: POP
// end ; end ;
87860: LD_VAR 0 2
87864: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
87865: LD_INT 0
87867: PPUSH
87868: PPUSH
87869: PPUSH
87870: PPUSH
87871: PPUSH
87872: PPUSH
87873: PPUSH
87874: PPUSH
87875: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
87876: LD_VAR 0 1
87880: NOT
87881: PUSH
87882: LD_VAR 0 2
87886: PPUSH
87887: LD_VAR 0 3
87891: PPUSH
87892: CALL_OW 488
87896: NOT
87897: OR
87898: PUSH
87899: LD_VAR 0 4
87903: NOT
87904: OR
87905: IFFALSE 87909
// exit ;
87907: GO 88249
// list := [ ] ;
87909: LD_ADDR_VAR 0 13
87913: PUSH
87914: EMPTY
87915: ST_TO_ADDR
// if x - r < 0 then
87916: LD_VAR 0 2
87920: PUSH
87921: LD_VAR 0 4
87925: MINUS
87926: PUSH
87927: LD_INT 0
87929: LESS
87930: IFFALSE 87942
// min_x := 0 else
87932: LD_ADDR_VAR 0 7
87936: PUSH
87937: LD_INT 0
87939: ST_TO_ADDR
87940: GO 87958
// min_x := x - r ;
87942: LD_ADDR_VAR 0 7
87946: PUSH
87947: LD_VAR 0 2
87951: PUSH
87952: LD_VAR 0 4
87956: MINUS
87957: ST_TO_ADDR
// if y - r < 0 then
87958: LD_VAR 0 3
87962: PUSH
87963: LD_VAR 0 4
87967: MINUS
87968: PUSH
87969: LD_INT 0
87971: LESS
87972: IFFALSE 87984
// min_y := 0 else
87974: LD_ADDR_VAR 0 8
87978: PUSH
87979: LD_INT 0
87981: ST_TO_ADDR
87982: GO 88000
// min_y := y - r ;
87984: LD_ADDR_VAR 0 8
87988: PUSH
87989: LD_VAR 0 3
87993: PUSH
87994: LD_VAR 0 4
87998: MINUS
87999: ST_TO_ADDR
// max_x := x + r ;
88000: LD_ADDR_VAR 0 9
88004: PUSH
88005: LD_VAR 0 2
88009: PUSH
88010: LD_VAR 0 4
88014: PLUS
88015: ST_TO_ADDR
// max_y := y + r ;
88016: LD_ADDR_VAR 0 10
88020: PUSH
88021: LD_VAR 0 3
88025: PUSH
88026: LD_VAR 0 4
88030: PLUS
88031: ST_TO_ADDR
// for _x = min_x to max_x do
88032: LD_ADDR_VAR 0 11
88036: PUSH
88037: DOUBLE
88038: LD_VAR 0 7
88042: DEC
88043: ST_TO_ADDR
88044: LD_VAR 0 9
88048: PUSH
88049: FOR_TO
88050: IFFALSE 88167
// for _y = min_y to max_y do
88052: LD_ADDR_VAR 0 12
88056: PUSH
88057: DOUBLE
88058: LD_VAR 0 8
88062: DEC
88063: ST_TO_ADDR
88064: LD_VAR 0 10
88068: PUSH
88069: FOR_TO
88070: IFFALSE 88163
// begin if not ValidHex ( _x , _y ) then
88072: LD_VAR 0 11
88076: PPUSH
88077: LD_VAR 0 12
88081: PPUSH
88082: CALL_OW 488
88086: NOT
88087: IFFALSE 88091
// continue ;
88089: GO 88069
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
88091: LD_VAR 0 11
88095: PPUSH
88096: LD_VAR 0 12
88100: PPUSH
88101: CALL_OW 351
88105: PUSH
88106: LD_VAR 0 11
88110: PPUSH
88111: LD_VAR 0 12
88115: PPUSH
88116: CALL_OW 554
88120: AND
88121: IFFALSE 88161
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
88123: LD_ADDR_VAR 0 13
88127: PUSH
88128: LD_VAR 0 13
88132: PPUSH
88133: LD_VAR 0 13
88137: PUSH
88138: LD_INT 1
88140: PLUS
88141: PPUSH
88142: LD_VAR 0 11
88146: PUSH
88147: LD_VAR 0 12
88151: PUSH
88152: EMPTY
88153: LIST
88154: LIST
88155: PPUSH
88156: CALL_OW 2
88160: ST_TO_ADDR
// end ;
88161: GO 88069
88163: POP
88164: POP
88165: GO 88049
88167: POP
88168: POP
// if not list then
88169: LD_VAR 0 13
88173: NOT
88174: IFFALSE 88178
// exit ;
88176: GO 88249
// for i in list do
88178: LD_ADDR_VAR 0 6
88182: PUSH
88183: LD_VAR 0 13
88187: PUSH
88188: FOR_IN
88189: IFFALSE 88247
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
88191: LD_VAR 0 1
88195: PPUSH
88196: LD_STRING M
88198: PUSH
88199: LD_VAR 0 6
88203: PUSH
88204: LD_INT 1
88206: ARRAY
88207: PUSH
88208: LD_VAR 0 6
88212: PUSH
88213: LD_INT 2
88215: ARRAY
88216: PUSH
88217: LD_INT 0
88219: PUSH
88220: LD_INT 0
88222: PUSH
88223: LD_INT 0
88225: PUSH
88226: LD_INT 0
88228: PUSH
88229: EMPTY
88230: LIST
88231: LIST
88232: LIST
88233: LIST
88234: LIST
88235: LIST
88236: LIST
88237: PUSH
88238: EMPTY
88239: LIST
88240: PPUSH
88241: CALL_OW 447
88245: GO 88188
88247: POP
88248: POP
// end ;
88249: LD_VAR 0 5
88253: RET
